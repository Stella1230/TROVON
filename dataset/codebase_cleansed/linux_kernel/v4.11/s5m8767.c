static int s5m8767_get_register(struct s5m8767_info *s5m8767, int reg_id,\r\nint *reg, int *enable_ctrl)\r\n{\r\nint i;\r\nunsigned int mode;\r\nswitch (reg_id) {\r\ncase S5M8767_LDO1 ... S5M8767_LDO2:\r\n*reg = S5M8767_REG_LDO1CTRL + (reg_id - S5M8767_LDO1);\r\nbreak;\r\ncase S5M8767_LDO3 ... S5M8767_LDO28:\r\n*reg = S5M8767_REG_LDO3CTRL + (reg_id - S5M8767_LDO3);\r\nbreak;\r\ncase S5M8767_BUCK1:\r\n*reg = S5M8767_REG_BUCK1CTRL1;\r\nbreak;\r\ncase S5M8767_BUCK2 ... S5M8767_BUCK4:\r\n*reg = S5M8767_REG_BUCK2CTRL + (reg_id - S5M8767_BUCK2) * 9;\r\nbreak;\r\ncase S5M8767_BUCK5:\r\n*reg = S5M8767_REG_BUCK5CTRL1;\r\nbreak;\r\ncase S5M8767_BUCK6 ... S5M8767_BUCK9:\r\n*reg = S5M8767_REG_BUCK6CTRL1 + (reg_id - S5M8767_BUCK6) * 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < s5m8767->num_regulators; i++) {\r\nif (s5m8767->opmode[i].id == reg_id) {\r\nmode = s5m8767->opmode[i].mode;\r\nbreak;\r\n}\r\n}\r\nif (i >= s5m8767->num_regulators)\r\nreturn -EINVAL;\r\n*enable_ctrl = s5m8767_opmode_reg[reg_id][mode] << S5M8767_ENCTRL_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int s5m8767_get_vsel_reg(int reg_id, struct s5m8767_info *s5m8767)\r\n{\r\nint reg;\r\nswitch (reg_id) {\r\ncase S5M8767_LDO1 ... S5M8767_LDO2:\r\nreg = S5M8767_REG_LDO1CTRL + (reg_id - S5M8767_LDO1);\r\nbreak;\r\ncase S5M8767_LDO3 ... S5M8767_LDO28:\r\nreg = S5M8767_REG_LDO3CTRL + (reg_id - S5M8767_LDO3);\r\nbreak;\r\ncase S5M8767_BUCK1:\r\nreg = S5M8767_REG_BUCK1CTRL2;\r\nbreak;\r\ncase S5M8767_BUCK2:\r\nreg = S5M8767_REG_BUCK2DVS1;\r\nif (s5m8767->buck2_gpiodvs)\r\nreg += s5m8767->buck_gpioindex;\r\nbreak;\r\ncase S5M8767_BUCK3:\r\nreg = S5M8767_REG_BUCK3DVS1;\r\nif (s5m8767->buck3_gpiodvs)\r\nreg += s5m8767->buck_gpioindex;\r\nbreak;\r\ncase S5M8767_BUCK4:\r\nreg = S5M8767_REG_BUCK4DVS1;\r\nif (s5m8767->buck4_gpiodvs)\r\nreg += s5m8767->buck_gpioindex;\r\nbreak;\r\ncase S5M8767_BUCK5:\r\nreg = S5M8767_REG_BUCK5CTRL2;\r\nbreak;\r\ncase S5M8767_BUCK6 ... S5M8767_BUCK9:\r\nreg = S5M8767_REG_BUCK6CTRL2 + (reg_id - S5M8767_BUCK6) * 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn reg;\r\n}\r\nstatic int s5m8767_convert_voltage_to_sel(const struct sec_voltage_desc *desc,\r\nint min_vol)\r\n{\r\nint selector = 0;\r\nif (desc == NULL)\r\nreturn -EINVAL;\r\nif (min_vol > desc->max)\r\nreturn -EINVAL;\r\nif (min_vol < desc->min)\r\nmin_vol = desc->min;\r\nselector = DIV_ROUND_UP(min_vol - desc->min, desc->step);\r\nif (desc->min + desc->step * selector > desc->max)\r\nreturn -EINVAL;\r\nreturn selector;\r\n}\r\nstatic inline int s5m8767_set_high(struct s5m8767_info *s5m8767)\r\n{\r\nint temp_index = s5m8767->buck_gpioindex;\r\ngpio_set_value(s5m8767->buck_gpios[0], (temp_index >> 2) & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[1], (temp_index >> 1) & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[2], temp_index & 0x1);\r\nreturn 0;\r\n}\r\nstatic inline int s5m8767_set_low(struct s5m8767_info *s5m8767)\r\n{\r\nint temp_index = s5m8767->buck_gpioindex;\r\ngpio_set_value(s5m8767->buck_gpios[2], temp_index & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[1], (temp_index >> 1) & 0x1);\r\ngpio_set_value(s5m8767->buck_gpios[0], (temp_index >> 2) & 0x1);\r\nreturn 0;\r\n}\r\nstatic int s5m8767_set_voltage_sel(struct regulator_dev *rdev,\r\nunsigned selector)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nint reg_id = rdev_get_id(rdev);\r\nint old_index, index = 0;\r\nu8 *buck234_vol = NULL;\r\nswitch (reg_id) {\r\ncase S5M8767_LDO1 ... S5M8767_LDO28:\r\nbreak;\r\ncase S5M8767_BUCK1 ... S5M8767_BUCK6:\r\nif (reg_id == S5M8767_BUCK2 && s5m8767->buck2_gpiodvs)\r\nbuck234_vol = &s5m8767->buck2_vol[0];\r\nelse if (reg_id == S5M8767_BUCK3 && s5m8767->buck3_gpiodvs)\r\nbuck234_vol = &s5m8767->buck3_vol[0];\r\nelse if (reg_id == S5M8767_BUCK4 && s5m8767->buck4_gpiodvs)\r\nbuck234_vol = &s5m8767->buck4_vol[0];\r\nbreak;\r\ncase S5M8767_BUCK7 ... S5M8767_BUCK8:\r\nreturn -EINVAL;\r\ncase S5M8767_BUCK9:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (buck234_vol) {\r\nwhile (*buck234_vol != selector) {\r\nbuck234_vol++;\r\nindex++;\r\n}\r\nold_index = s5m8767->buck_gpioindex;\r\ns5m8767->buck_gpioindex = index;\r\nif (index > old_index)\r\nreturn s5m8767_set_high(s5m8767);\r\nelse\r\nreturn s5m8767_set_low(s5m8767);\r\n} else {\r\nreturn regulator_set_voltage_sel_regmap(rdev, selector);\r\n}\r\n}\r\nstatic int s5m8767_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_sel,\r\nunsigned int new_sel)\r\n{\r\nstruct s5m8767_info *s5m8767 = rdev_get_drvdata(rdev);\r\nconst struct sec_voltage_desc *desc;\r\nint reg_id = rdev_get_id(rdev);\r\ndesc = reg_voltage_map[reg_id];\r\nif ((old_sel < new_sel) && s5m8767->ramp_delay)\r\nreturn DIV_ROUND_UP(desc->step * (new_sel - old_sel),\r\ns5m8767->ramp_delay * 1000);\r\nreturn 0;\r\n}\r\nstatic void s5m8767_regulator_config_ext_control(struct s5m8767_info *s5m8767,\r\nstruct sec_regulator_data *rdata,\r\nstruct regulator_config *config)\r\n{\r\nint i, mode = 0;\r\nif (rdata->id != S5M8767_BUCK9)\r\nreturn;\r\nfor (i = 0; i < s5m8767->num_regulators; i++) {\r\nconst struct sec_opmode_data *opmode = &s5m8767->opmode[i];\r\nif (opmode->id == rdata->id) {\r\nmode = s5m8767_opmode_reg[rdata->id][opmode->mode];\r\nbreak;\r\n}\r\n}\r\nif (mode != S5M8767_ENCTRL_USE_GPIO) {\r\ndev_warn(s5m8767->dev,\r\n"ext-control for %s: mismatched op_mode (%x), ignoring\n",\r\nrdata->reg_node->name, mode);\r\nreturn;\r\n}\r\nif (!gpio_is_valid(rdata->ext_control_gpio)) {\r\ndev_warn(s5m8767->dev,\r\n"ext-control for %s: GPIO not valid, ignoring\n",\r\nrdata->reg_node->name);\r\nreturn;\r\n}\r\nconfig->ena_gpio = rdata->ext_control_gpio;\r\nconfig->ena_gpio_flags = GPIOF_OUT_INIT_HIGH;\r\n}\r\nstatic int s5m8767_enable_ext_control(struct s5m8767_info *s5m8767,\r\nstruct regulator_dev *rdev)\r\n{\r\nint id = rdev_get_id(rdev);\r\nint ret, reg, enable_ctrl;\r\nif (id != S5M8767_BUCK9)\r\nreturn -EINVAL;\r\nret = s5m8767_get_register(s5m8767, id, &reg, &enable_ctrl);\r\nif (ret)\r\nreturn ret;\r\nreturn regmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nreg, S5M8767_ENCTRL_MASK,\r\nS5M8767_ENCTRL_USE_GPIO << S5M8767_ENCTRL_SHIFT);\r\n}\r\nstatic int s5m8767_pmic_dt_parse_dvs_gpio(struct sec_pmic_dev *iodev,\r\nstruct sec_platform_data *pdata,\r\nstruct device_node *pmic_np)\r\n{\r\nint i, gpio;\r\nfor (i = 0; i < 3; i++) {\r\ngpio = of_get_named_gpio(pmic_np,\r\n"s5m8767,pmic-buck-dvs-gpios", i);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(iodev->dev, "invalid gpio[%d]: %d\n", i, gpio);\r\nreturn -EINVAL;\r\n}\r\npdata->buck_gpios[i] = gpio;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_ds_gpio(struct sec_pmic_dev *iodev,\r\nstruct sec_platform_data *pdata,\r\nstruct device_node *pmic_np)\r\n{\r\nint i, gpio;\r\nfor (i = 0; i < 3; i++) {\r\ngpio = of_get_named_gpio(pmic_np,\r\n"s5m8767,pmic-buck-ds-gpios", i);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(iodev->dev, "invalid gpio[%d]: %d\n", i, gpio);\r\nreturn -EINVAL;\r\n}\r\npdata->buck_ds[i] = gpio;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_pdata(struct platform_device *pdev,\r\nstruct sec_platform_data *pdata)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct device_node *pmic_np, *regulators_np, *reg_np;\r\nstruct sec_regulator_data *rdata;\r\nstruct sec_opmode_data *rmode;\r\nunsigned int i, dvs_voltage_nr = 8, ret;\r\npmic_np = iodev->dev->of_node;\r\nif (!pmic_np) {\r\ndev_err(iodev->dev, "could not find pmic sub-node\n");\r\nreturn -ENODEV;\r\n}\r\nregulators_np = of_get_child_by_name(pmic_np, "regulators");\r\nif (!regulators_np) {\r\ndev_err(iodev->dev, "could not find regulators sub-node\n");\r\nreturn -EINVAL;\r\n}\r\npdata->num_regulators = of_get_child_count(regulators_np);\r\nrdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *\r\npdata->num_regulators, GFP_KERNEL);\r\nif (!rdata)\r\nreturn -ENOMEM;\r\nrmode = devm_kzalloc(&pdev->dev, sizeof(*rmode) *\r\npdata->num_regulators, GFP_KERNEL);\r\nif (!rmode)\r\nreturn -ENOMEM;\r\npdata->regulators = rdata;\r\npdata->opmode = rmode;\r\nfor_each_child_of_node(regulators_np, reg_np) {\r\nfor (i = 0; i < ARRAY_SIZE(regulators); i++)\r\nif (!of_node_cmp(reg_np->name, regulators[i].name))\r\nbreak;\r\nif (i == ARRAY_SIZE(regulators)) {\r\ndev_warn(iodev->dev,\r\n"don't know how to configure regulator %s\n",\r\nreg_np->name);\r\ncontinue;\r\n}\r\nrdata->ext_control_gpio = of_get_named_gpio(reg_np,\r\n"s5m8767,pmic-ext-control-gpios", 0);\r\nrdata->id = i;\r\nrdata->initdata = of_get_regulator_init_data(\r\n&pdev->dev, reg_np,\r\n&regulators[i]);\r\nrdata->reg_node = reg_np;\r\nrdata++;\r\nrmode->id = i;\r\nif (of_property_read_u32(reg_np, "op_mode",\r\n&rmode->mode)) {\r\ndev_warn(iodev->dev,\r\n"no op_mode property property at %s\n",\r\nreg_np->full_name);\r\nrmode->mode = S5M8767_OPMODE_NORMAL_MODE;\r\n}\r\nrmode++;\r\n}\r\nof_node_put(regulators_np);\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck2-uses-gpio-dvs", NULL)) {\r\npdata->buck2_gpiodvs = true;\r\nif (of_property_read_u32_array(pmic_np,\r\n"s5m8767,pmic-buck2-dvs-voltage",\r\npdata->buck2_voltage, dvs_voltage_nr)) {\r\ndev_err(iodev->dev, "buck2 voltages not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck3-uses-gpio-dvs", NULL)) {\r\npdata->buck3_gpiodvs = true;\r\nif (of_property_read_u32_array(pmic_np,\r\n"s5m8767,pmic-buck3-dvs-voltage",\r\npdata->buck3_voltage, dvs_voltage_nr)) {\r\ndev_err(iodev->dev, "buck3 voltages not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck4-uses-gpio-dvs", NULL)) {\r\npdata->buck4_gpiodvs = true;\r\nif (of_property_read_u32_array(pmic_np,\r\n"s5m8767,pmic-buck4-dvs-voltage",\r\npdata->buck4_voltage, dvs_voltage_nr)) {\r\ndev_err(iodev->dev, "buck4 voltages not specified\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\r\npdata->buck4_gpiodvs) {\r\nret = s5m8767_pmic_dt_parse_dvs_gpio(iodev, pdata, pmic_np);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (of_property_read_u32(pmic_np,\r\n"s5m8767,pmic-buck-default-dvs-idx",\r\n&pdata->buck_default_idx)) {\r\npdata->buck_default_idx = 0;\r\n} else {\r\nif (pdata->buck_default_idx >= 8) {\r\npdata->buck_default_idx = 0;\r\ndev_info(iodev->dev,\r\n"invalid value for default dvs index, use 0\n");\r\n}\r\n}\r\n}\r\nret = s5m8767_pmic_dt_parse_ds_gpio(iodev, pdata, pmic_np);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck2-ramp-enable", NULL))\r\npdata->buck2_ramp_enable = true;\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck3-ramp-enable", NULL))\r\npdata->buck3_ramp_enable = true;\r\nif (of_get_property(pmic_np, "s5m8767,pmic-buck4-ramp-enable", NULL))\r\npdata->buck4_ramp_enable = true;\r\nif (pdata->buck2_ramp_enable || pdata->buck3_ramp_enable\r\n|| pdata->buck4_ramp_enable) {\r\nif (of_property_read_u32(pmic_np, "s5m8767,pmic-buck-ramp-delay",\r\n&pdata->buck_ramp_delay))\r\npdata->buck_ramp_delay = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_dt_parse_pdata(struct platform_device *pdev,\r\nstruct sec_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5m8767_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct sec_platform_data *pdata = iodev->pdata;\r\nstruct regulator_config config = { };\r\nstruct s5m8767_info *s5m8767;\r\nint i, ret, buck_init;\r\nif (!pdata) {\r\ndev_err(pdev->dev.parent, "Platform data not supplied\n");\r\nreturn -ENODEV;\r\n}\r\nif (iodev->dev->of_node) {\r\nret = s5m8767_pmic_dt_parse_pdata(pdev, pdata);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pdata->buck2_gpiodvs) {\r\nif (pdata->buck3_gpiodvs || pdata->buck4_gpiodvs) {\r\ndev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (pdata->buck3_gpiodvs) {\r\nif (pdata->buck2_gpiodvs || pdata->buck4_gpiodvs) {\r\ndev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (pdata->buck4_gpiodvs) {\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs) {\r\ndev_err(&pdev->dev, "S5M8767 GPIO DVS NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\ns5m8767 = devm_kzalloc(&pdev->dev, sizeof(struct s5m8767_info),\r\nGFP_KERNEL);\r\nif (!s5m8767)\r\nreturn -ENOMEM;\r\ns5m8767->dev = &pdev->dev;\r\ns5m8767->iodev = iodev;\r\ns5m8767->num_regulators = pdata->num_regulators;\r\nplatform_set_drvdata(pdev, s5m8767);\r\ns5m8767->buck_gpioindex = pdata->buck_default_idx;\r\ns5m8767->buck2_gpiodvs = pdata->buck2_gpiodvs;\r\ns5m8767->buck3_gpiodvs = pdata->buck3_gpiodvs;\r\ns5m8767->buck4_gpiodvs = pdata->buck4_gpiodvs;\r\ns5m8767->buck_gpios[0] = pdata->buck_gpios[0];\r\ns5m8767->buck_gpios[1] = pdata->buck_gpios[1];\r\ns5m8767->buck_gpios[2] = pdata->buck_gpios[2];\r\ns5m8767->buck_ds[0] = pdata->buck_ds[0];\r\ns5m8767->buck_ds[1] = pdata->buck_ds[1];\r\ns5m8767->buck_ds[2] = pdata->buck_ds[2];\r\ns5m8767->ramp_delay = pdata->buck_ramp_delay;\r\ns5m8767->buck2_ramp = pdata->buck2_ramp_enable;\r\ns5m8767->buck3_ramp = pdata->buck3_ramp_enable;\r\ns5m8767->buck4_ramp = pdata->buck4_ramp_enable;\r\ns5m8767->opmode = pdata->opmode;\r\nbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\r\npdata->buck2_init);\r\nregmap_write(s5m8767->iodev->regmap_pmic, S5M8767_REG_BUCK2DVS2,\r\nbuck_init);\r\nbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\r\npdata->buck3_init);\r\nregmap_write(s5m8767->iodev->regmap_pmic, S5M8767_REG_BUCK3DVS2,\r\nbuck_init);\r\nbuck_init = s5m8767_convert_voltage_to_sel(&buck_voltage_val2,\r\npdata->buck4_init);\r\nregmap_write(s5m8767->iodev->regmap_pmic, S5M8767_REG_BUCK4DVS2,\r\nbuck_init);\r\nfor (i = 0; i < 8; i++) {\r\nif (s5m8767->buck2_gpiodvs) {\r\ns5m8767->buck2_vol[i] =\r\ns5m8767_convert_voltage_to_sel(\r\n&buck_voltage_val2,\r\npdata->buck2_voltage[i]);\r\n}\r\nif (s5m8767->buck3_gpiodvs) {\r\ns5m8767->buck3_vol[i] =\r\ns5m8767_convert_voltage_to_sel(\r\n&buck_voltage_val2,\r\npdata->buck3_voltage[i]);\r\n}\r\nif (s5m8767->buck4_gpiodvs) {\r\ns5m8767->buck4_vol[i] =\r\ns5m8767_convert_voltage_to_sel(\r\n&buck_voltage_val2,\r\npdata->buck4_voltage[i]);\r\n}\r\n}\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\r\npdata->buck4_gpiodvs) {\r\nif (!gpio_is_valid(pdata->buck_gpios[0]) ||\r\n!gpio_is_valid(pdata->buck_gpios[1]) ||\r\n!gpio_is_valid(pdata->buck_gpios[2])) {\r\ndev_err(&pdev->dev, "GPIO NOT VALID\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[0],\r\n"S5M8767 SET1");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[1],\r\n"S5M8767 SET2");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_gpios[2],\r\n"S5M8767 SET3");\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_output(pdata->buck_gpios[0],\r\n(s5m8767->buck_gpioindex >> 2) & 0x1);\r\ngpio_direction_output(pdata->buck_gpios[1],\r\n(s5m8767->buck_gpioindex >> 1) & 0x1);\r\ngpio_direction_output(pdata->buck_gpios[2],\r\n(s5m8767->buck_gpioindex >> 0) & 0x1);\r\n}\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_ds[0], "S5M8767 DS2");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_ds[1], "S5M8767 DS3");\r\nif (ret)\r\nreturn ret;\r\nret = devm_gpio_request(&pdev->dev, pdata->buck_ds[2], "S5M8767 DS4");\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_output(pdata->buck_ds[0], 0x0);\r\ngpio_direction_output(pdata->buck_ds[1], 0x0);\r\ngpio_direction_output(pdata->buck_ds[2], 0x0);\r\nif (pdata->buck2_gpiodvs || pdata->buck3_gpiodvs ||\r\npdata->buck4_gpiodvs) {\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_BUCK2CTRL, 1 << 1,\r\n(pdata->buck2_gpiodvs) ? (1 << 1) : (0 << 1));\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_BUCK3CTRL, 1 << 1,\r\n(pdata->buck3_gpiodvs) ? (1 << 1) : (0 << 1));\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_BUCK4CTRL, 1 << 1,\r\n(pdata->buck4_gpiodvs) ? (1 << 1) : (0 << 1));\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (s5m8767->buck2_gpiodvs) {\r\nregmap_write(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_BUCK2DVS1 + i,\r\ns5m8767->buck2_vol[i]);\r\n}\r\nif (s5m8767->buck3_gpiodvs) {\r\nregmap_write(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_BUCK3DVS1 + i,\r\ns5m8767->buck3_vol[i]);\r\n}\r\nif (s5m8767->buck4_gpiodvs) {\r\nregmap_write(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_BUCK4DVS1 + i,\r\ns5m8767->buck4_vol[i]);\r\n}\r\n}\r\nif (s5m8767->buck2_ramp)\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_DVSRAMP, 0x08, 0x08);\r\nif (s5m8767->buck3_ramp)\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_DVSRAMP, 0x04, 0x04);\r\nif (s5m8767->buck4_ramp)\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_DVSRAMP, 0x02, 0x02);\r\nif (s5m8767->buck2_ramp || s5m8767->buck3_ramp\r\n|| s5m8767->buck4_ramp) {\r\nunsigned int val;\r\nswitch (s5m8767->ramp_delay) {\r\ncase 5:\r\nval = S5M8767_DVS_BUCK_RAMP_5;\r\nbreak;\r\ncase 10:\r\nval = S5M8767_DVS_BUCK_RAMP_10;\r\nbreak;\r\ncase 25:\r\nval = S5M8767_DVS_BUCK_RAMP_25;\r\nbreak;\r\ncase 50:\r\nval = S5M8767_DVS_BUCK_RAMP_50;\r\nbreak;\r\ncase 100:\r\nval = S5M8767_DVS_BUCK_RAMP_100;\r\nbreak;\r\ndefault:\r\nval = S5M8767_DVS_BUCK_RAMP_10;\r\n}\r\nregmap_update_bits(s5m8767->iodev->regmap_pmic,\r\nS5M8767_REG_DVSRAMP,\r\nS5M8767_DVS_BUCK_RAMP_MASK,\r\nval << S5M8767_DVS_BUCK_RAMP_SHIFT);\r\n}\r\nfor (i = 0; i < pdata->num_regulators; i++) {\r\nconst struct sec_voltage_desc *desc;\r\nint id = pdata->regulators[i].id;\r\nint enable_reg, enable_val;\r\nstruct regulator_dev *rdev;\r\ndesc = reg_voltage_map[id];\r\nif (desc) {\r\nregulators[id].n_voltages =\r\n(desc->max - desc->min) / desc->step + 1;\r\nregulators[id].min_uV = desc->min;\r\nregulators[id].uV_step = desc->step;\r\nregulators[id].vsel_reg =\r\ns5m8767_get_vsel_reg(id, s5m8767);\r\nif (id < S5M8767_BUCK1)\r\nregulators[id].vsel_mask = 0x3f;\r\nelse\r\nregulators[id].vsel_mask = 0xff;\r\nret = s5m8767_get_register(s5m8767, id, &enable_reg,\r\n&enable_val);\r\nif (ret) {\r\ndev_err(s5m8767->dev, "error reading registers\n");\r\nreturn ret;\r\n}\r\nregulators[id].enable_reg = enable_reg;\r\nregulators[id].enable_mask = S5M8767_ENCTRL_MASK;\r\nregulators[id].enable_val = enable_val;\r\n}\r\nconfig.dev = s5m8767->dev;\r\nconfig.init_data = pdata->regulators[i].initdata;\r\nconfig.driver_data = s5m8767;\r\nconfig.regmap = iodev->regmap_pmic;\r\nconfig.of_node = pdata->regulators[i].reg_node;\r\nconfig.ena_gpio = -EINVAL;\r\nconfig.ena_gpio_flags = 0;\r\nconfig.ena_gpio_initialized = true;\r\nif (gpio_is_valid(pdata->regulators[i].ext_control_gpio))\r\ns5m8767_regulator_config_ext_control(s5m8767,\r\n&pdata->regulators[i], &config);\r\nrdev = devm_regulator_register(&pdev->dev, &regulators[id],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\nret = PTR_ERR(rdev);\r\ndev_err(s5m8767->dev, "regulator init failed for %d\n",\r\nid);\r\nreturn ret;\r\n}\r\nif (gpio_is_valid(pdata->regulators[i].ext_control_gpio)) {\r\nret = s5m8767_enable_ext_control(s5m8767, rdev);\r\nif (ret < 0) {\r\ndev_err(s5m8767->dev,\r\n"failed to enable gpio control over %s: %d\n",\r\nrdev->desc->name, ret);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init s5m8767_pmic_init(void)\r\n{\r\nreturn platform_driver_register(&s5m8767_pmic_driver);\r\n}\r\nstatic void __exit s5m8767_pmic_exit(void)\r\n{\r\nplatform_driver_unregister(&s5m8767_pmic_driver);\r\n}
