ssize_t\r\nradeon_dp_aux_transfer_native(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\r\n{\r\nstruct radeon_i2c_chan *chan =\r\ncontainer_of(aux, struct radeon_i2c_chan, aux);\r\nstruct drm_device *dev = chan->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint ret = 0, i;\r\nuint32_t tmp, ack = 0;\r\nint instance = chan->rec.i2c_id & 0xf;\r\nu8 byte;\r\nu8 *buf = msg->buffer;\r\nint retry_count = 0;\r\nint bytes;\r\nint msize;\r\nbool is_write = false;\r\nif (WARN_ON(msg->size > 16))\r\nreturn -E2BIG;\r\nswitch (msg->request & ~DP_AUX_I2C_MOT) {\r\ncase DP_AUX_NATIVE_WRITE:\r\ncase DP_AUX_I2C_WRITE:\r\nis_write = true;\r\nbreak;\r\ncase DP_AUX_NATIVE_READ:\r\ncase DP_AUX_I2C_READ:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmsize = 0;\r\nbytes = BARE_ADDRESS_SIZE;\r\nif (msg->size) {\r\nmsize = msg->size - 1;\r\nbytes++;\r\nif (is_write)\r\nbytes += msg->size;\r\n}\r\nmutex_lock(&chan->mutex);\r\ntmp = RREG32(chan->rec.mask_clk_reg);\r\ntmp |= (1 << 16);\r\nWREG32(chan->rec.mask_clk_reg, tmp);\r\ntmp = RREG32(AUX_CONTROL + aux_offset[instance]);\r\ntmp &= AUX_HPD_SEL(0x7);\r\ntmp |= AUX_HPD_SEL(chan->rec.hpd);\r\ntmp |= AUX_EN | AUX_LS_READ_EN;\r\nWREG32(AUX_CONTROL + aux_offset[instance], tmp);\r\nWREG32(AUX_SW_CONTROL + aux_offset[instance],\r\nAUX_SW_WR_BYTES(bytes));\r\nWREG32(AUX_SW_CONTROL + aux_offset[instance],\r\nAUX_SW_WR_BYTES(bytes));\r\nbyte = (msg->request << 4) | ((msg->address >> 16) & 0xf);\r\nWREG32(AUX_SW_DATA + aux_offset[instance],\r\nAUX_SW_DATA_MASK(byte) | AUX_SW_AUTOINCREMENT_DISABLE);\r\nbyte = (msg->address >> 8) & 0xff;\r\nWREG32(AUX_SW_DATA + aux_offset[instance],\r\nAUX_SW_DATA_MASK(byte));\r\nbyte = msg->address & 0xff;\r\nWREG32(AUX_SW_DATA + aux_offset[instance],\r\nAUX_SW_DATA_MASK(byte));\r\nbyte = msize;\r\nWREG32(AUX_SW_DATA + aux_offset[instance],\r\nAUX_SW_DATA_MASK(byte));\r\nif (is_write) {\r\nfor (i = 0; i < msg->size; i++) {\r\nWREG32(AUX_SW_DATA + aux_offset[instance],\r\nAUX_SW_DATA_MASK(buf[i]));\r\n}\r\n}\r\nWREG32(AUX_SW_INTERRUPT_CONTROL + aux_offset[instance], AUX_SW_DONE_ACK);\r\nWREG32(AUX_SW_CONTROL + aux_offset[instance],\r\nAUX_SW_WR_BYTES(bytes) | AUX_SW_GO);\r\ndo {\r\ntmp = RREG32(AUX_SW_STATUS + aux_offset[instance]);\r\nif (tmp & AUX_SW_DONE) {\r\nbreak;\r\n}\r\nusleep_range(100, 200);\r\n} while (retry_count++ < 1000);\r\nif (retry_count >= 1000) {\r\nDRM_ERROR("auxch hw never signalled completion, error %08x\n", tmp);\r\nret = -EIO;\r\ngoto done;\r\n}\r\nif (tmp & AUX_SW_RX_TIMEOUT) {\r\nret = -ETIMEDOUT;\r\ngoto done;\r\n}\r\nif (tmp & AUX_RX_ERROR_FLAGS) {\r\nDRM_DEBUG_KMS("dp_aux_ch flags not zero: %08x\n", tmp);\r\nret = -EIO;\r\ngoto done;\r\n}\r\nbytes = AUX_SW_REPLY_GET_BYTE_COUNT(tmp);\r\nif (bytes) {\r\nWREG32(AUX_SW_DATA + aux_offset[instance],\r\nAUX_SW_DATA_RW | AUX_SW_AUTOINCREMENT_DISABLE);\r\ntmp = RREG32(AUX_SW_DATA + aux_offset[instance]);\r\nack = (tmp >> 8) & 0xff;\r\nfor (i = 0; i < bytes - 1; i++) {\r\ntmp = RREG32(AUX_SW_DATA + aux_offset[instance]);\r\nif (buf)\r\nbuf[i] = (tmp >> 8) & 0xff;\r\n}\r\nif (buf)\r\nret = bytes - 1;\r\n}\r\nWREG32(AUX_SW_INTERRUPT_CONTROL + aux_offset[instance], AUX_SW_DONE_ACK);\r\nif (is_write)\r\nret = msg->size;\r\ndone:\r\nmutex_unlock(&chan->mutex);\r\nif (ret >= 0)\r\nmsg->reply = ack >> 4;\r\nreturn ret;\r\n}
