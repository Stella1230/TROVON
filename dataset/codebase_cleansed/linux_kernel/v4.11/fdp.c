static int fdp_nci_create_conn(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct core_conn_create_dest_spec_params param;\r\nint r;\r\nparam.type = FDP_PATCH_CONN_PARAM_TYPE;\r\nparam.length = 0x00;\r\nr = nci_core_conn_create(info->ndev, FDP_PATCH_CONN_DEST, 1,\r\nsizeof(param), &param);\r\nif (r)\r\nreturn r;\r\nreturn nci_get_conn_info_by_dest_type_params(ndev,\r\nFDP_PATCH_CONN_DEST, NULL);\r\n}\r\nstatic inline int fdp_nci_get_versions(struct nci_dev *ndev)\r\n{\r\nreturn nci_core_cmd(ndev, NCI_OP_CORE_GET_CONFIG_CMD,\r\nsizeof(nci_core_get_config_otp_ram_version),\r\n(__u8 *) &nci_core_get_config_otp_ram_version);\r\n}\r\nstatic inline int fdp_nci_patch_cmd(struct nci_dev *ndev, u8 type)\r\n{\r\nreturn nci_prop_cmd(ndev, NCI_OP_PROP_PATCH_OID, sizeof(type), &type);\r\n}\r\nstatic inline int fdp_nci_set_production_data(struct nci_dev *ndev, u8 len,\r\nchar *data)\r\n{\r\nreturn nci_prop_cmd(ndev, NCI_OP_PROP_SET_PDATA_OID, len, data);\r\n}\r\nstatic int fdp_nci_set_clock(struct nci_dev *ndev, u8 clock_type,\r\nu32 clock_freq)\r\n{\r\nu32 fc = 13560;\r\nu32 nd, num, delta;\r\nchar data[9];\r\nnd = (24 * fc) / clock_freq;\r\ndelta = 24 * fc - nd * clock_freq;\r\nnum = (32768 * delta) / clock_freq;\r\ndata[0] = 0x00;\r\ndata[1] = 0x00;\r\ndata[2] = 0x00;\r\ndata[3] = 0x10;\r\ndata[4] = 0x04;\r\ndata[5] = num & 0xFF;\r\ndata[6] = (num >> 8) & 0xff;\r\ndata[7] = nd;\r\ndata[8] = clock_type;\r\nreturn fdp_nci_set_production_data(ndev, 9, data);\r\n}\r\nstatic void fdp_nci_send_patch_cb(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\ninfo->setup_patch_sent = 1;\r\nwake_up(&info->setup_wq);\r\n}\r\nstatic void fdp_nci_set_data_pkt_counter(struct nci_dev *ndev,\r\nvoid (*cb)(struct nci_dev *ndev), int count)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "NCI data pkt counter %d\n", count);\r\natomic_set(&info->data_pkt_counter, count);\r\ninfo->data_pkt_counter_cb = cb;\r\n}\r\nstatic int fdp_nci_send_patch(struct nci_dev *ndev, u8 conn_id, u8 type)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nconst struct firmware *fw;\r\nstruct sk_buff *skb;\r\nunsigned long len;\r\nu8 max_size, payload_size;\r\nint rc = 0;\r\nif ((type == NCI_PATCH_TYPE_OTP && !info->otp_patch) ||\r\n(type == NCI_PATCH_TYPE_RAM && !info->ram_patch))\r\nreturn -EINVAL;\r\nif (type == NCI_PATCH_TYPE_OTP)\r\nfw = info->otp_patch;\r\nelse\r\nfw = info->ram_patch;\r\nmax_size = nci_conn_max_data_pkt_payload_size(ndev, conn_id);\r\nif (max_size <= 0)\r\nreturn -EINVAL;\r\nlen = fw->size;\r\nfdp_nci_set_data_pkt_counter(ndev, fdp_nci_send_patch_cb,\r\nDIV_ROUND_UP(fw->size, max_size));\r\nwhile (len) {\r\npayload_size = min_t(unsigned long, (unsigned long) max_size,\r\nlen);\r\nskb = nci_skb_alloc(ndev, (NCI_CTRL_HDR_SIZE + payload_size),\r\nGFP_KERNEL);\r\nif (!skb) {\r\nfdp_nci_set_data_pkt_counter(ndev, NULL, 0);\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, NCI_CTRL_HDR_SIZE);\r\nmemcpy(skb_put(skb, payload_size), fw->data + (fw->size - len),\r\npayload_size);\r\nrc = nci_send_data(ndev, conn_id, skb);\r\nif (rc) {\r\nfdp_nci_set_data_pkt_counter(ndev, NULL, 0);\r\nreturn rc;\r\n}\r\nlen -= payload_size;\r\n}\r\nreturn rc;\r\n}\r\nstatic int fdp_nci_open(struct nci_dev *ndev)\r\n{\r\nint r;\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\nr = info->phy_ops->enable(info->phy);\r\nreturn r;\r\n}\r\nstatic int fdp_nci_close(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int fdp_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (atomic_dec_and_test(&info->data_pkt_counter))\r\ninfo->data_pkt_counter_cb(ndev);\r\nreturn info->phy_ops->write(info->phy, skb);\r\n}\r\nint fdp_nci_recv_frame(struct nci_dev *ndev, struct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\nreturn nci_recv_frame(ndev, skb);\r\n}\r\nstatic int fdp_nci_request_firmware(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nu8 *data;\r\nint r;\r\nr = request_firmware(&info->ram_patch, FDP_RAM_PATCH_NAME, dev);\r\nif (r < 0) {\r\nnfc_err(dev, "RAM patch request error\n");\r\ngoto error;\r\n}\r\ndata = (u8 *) info->ram_patch->data;\r\ninfo->ram_patch_version =\r\ndata[FDP_FW_HEADER_SIZE] |\r\n(data[FDP_FW_HEADER_SIZE + 1] << 8) |\r\n(data[FDP_FW_HEADER_SIZE + 2] << 16) |\r\n(data[FDP_FW_HEADER_SIZE + 3] << 24);\r\ndev_dbg(dev, "RAM patch version: %d, size: %d\n",\r\ninfo->ram_patch_version, (int) info->ram_patch->size);\r\nr = request_firmware(&info->otp_patch, FDP_OTP_PATCH_NAME, dev);\r\nif (r < 0) {\r\nnfc_err(dev, "OTP patch request error\n");\r\ngoto out;\r\n}\r\ndata = (u8 *) info->otp_patch->data;\r\ninfo->otp_patch_version =\r\ndata[FDP_FW_HEADER_SIZE] |\r\n(data[FDP_FW_HEADER_SIZE + 1] << 8) |\r\n(data[FDP_FW_HEADER_SIZE+2] << 16) |\r\n(data[FDP_FW_HEADER_SIZE+3] << 24);\r\ndev_dbg(dev, "OTP patch version: %d, size: %d\n",\r\ninfo->otp_patch_version, (int) info->otp_patch->size);\r\nout:\r\nreturn 0;\r\nerror:\r\nreturn r;\r\n}\r\nstatic void fdp_nci_release_firmware(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nif (info->otp_patch) {\r\nrelease_firmware(info->otp_patch);\r\ninfo->otp_patch = NULL;\r\n}\r\nif (info->ram_patch) {\r\nrelease_firmware(info->ram_patch);\r\ninfo->ram_patch = NULL;\r\n}\r\n}\r\nstatic int fdp_nci_patch_otp(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nint conn_id;\r\nint r = 0;\r\nif (info->otp_version >= info->otp_patch_version)\r\ngoto out;\r\ninfo->setup_patch_sent = 0;\r\ninfo->setup_reset_ntf = 0;\r\ninfo->setup_patch_ntf = 0;\r\nr = fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_OTP);\r\nif (r)\r\ngoto out;\r\nconn_id = fdp_nci_create_conn(ndev);\r\nif (conn_id < 0) {\r\nr = conn_id;\r\ngoto out;\r\n}\r\nr = fdp_nci_send_patch(ndev, conn_id, NCI_PATCH_TYPE_OTP);\r\nif (r)\r\ngoto out;\r\nwait_event_interruptible(info->setup_wq,\r\ninfo->setup_patch_sent == 1);\r\nmsleep(FDP_FW_UPDATE_SLEEP);\r\nr = nci_core_conn_close(info->ndev, conn_id);\r\nif (r)\r\ngoto out;\r\nif (fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_EOT)) {\r\nnfc_err(dev, "OTP patch error 0x%x\n", r);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nwait_event_interruptible(info->setup_wq, info->setup_patch_ntf);\r\nr = info->setup_patch_status;\r\nif (r) {\r\nnfc_err(dev, "OTP patch error 0x%x\n", r);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nwait_event_interruptible(info->setup_wq, info->setup_reset_ntf);\r\nout:\r\nreturn r;\r\n}\r\nstatic int fdp_nci_patch_ram(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nint conn_id;\r\nint r = 0;\r\nif (info->ram_version >= info->ram_patch_version)\r\ngoto out;\r\ninfo->setup_patch_sent = 0;\r\ninfo->setup_reset_ntf = 0;\r\ninfo->setup_patch_ntf = 0;\r\nr = fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_RAM);\r\nif (r)\r\ngoto out;\r\nconn_id = fdp_nci_create_conn(ndev);\r\nif (conn_id < 0) {\r\nr = conn_id;\r\ngoto out;\r\n}\r\nr = fdp_nci_send_patch(ndev, conn_id, NCI_PATCH_TYPE_RAM);\r\nif (r)\r\ngoto out;\r\nwait_event_interruptible(info->setup_wq,\r\ninfo->setup_patch_sent == 1);\r\nmsleep(FDP_FW_UPDATE_SLEEP);\r\nr = nci_core_conn_close(info->ndev, conn_id);\r\nif (r)\r\ngoto out;\r\nif (fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_EOT)) {\r\nnfc_err(dev, "RAM patch error 0x%x\n", r);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nwait_event_interruptible(info->setup_wq, info->setup_patch_ntf);\r\nr = info->setup_patch_status;\r\nif (r) {\r\nnfc_err(dev, "RAM patch error 0x%x\n", r);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nwait_event_interruptible(info->setup_wq, info->setup_reset_ntf);\r\nout:\r\nreturn r;\r\n}\r\nstatic int fdp_nci_setup(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nint r;\r\nu8 patched = 0;\r\ndev_dbg(dev, "%s\n", __func__);\r\nr = nci_core_init(ndev);\r\nif (r)\r\ngoto error;\r\nr = fdp_nci_get_versions(ndev);\r\nif (r)\r\ngoto error;\r\nr = fdp_nci_request_firmware(ndev);\r\nif (r)\r\ngoto error;\r\nif (info->otp_version < info->otp_patch_version) {\r\nr = fdp_nci_patch_otp(ndev);\r\nif (r)\r\ngoto error;\r\npatched = 1;\r\n}\r\nif (info->ram_version < info->ram_patch_version) {\r\nr = fdp_nci_patch_ram(ndev);\r\nif (r)\r\ngoto error;\r\npatched = 1;\r\n}\r\nfdp_nci_release_firmware(ndev);\r\nif (patched) {\r\nr = nci_core_init(ndev);\r\nif (r)\r\ngoto error;\r\nr = fdp_nci_get_versions(ndev);\r\nif (r)\r\ngoto error;\r\nif (info->otp_version != info->otp_patch_version ||\r\ninfo->ram_version != info->ram_patch_version) {\r\nnfc_err(dev, "Firmware update failed");\r\nr = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\nreturn nci_core_reset(ndev);\r\nerror:\r\nfdp_nci_release_firmware(ndev);\r\nnfc_err(dev, "Setup error %d\n", r);\r\nreturn r;\r\n}\r\nstatic int fdp_nci_post_setup(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nint r;\r\nif (info->fw_vsc_cfg && info->fw_vsc_cfg[0]) {\r\nr = fdp_nci_set_production_data(ndev, info->fw_vsc_cfg[3],\r\n&info->fw_vsc_cfg[4]);\r\nif (r) {\r\nnfc_err(dev, "Vendor specific config set error %d\n",\r\nr);\r\nreturn r;\r\n}\r\n}\r\nr = fdp_nci_set_clock(ndev, info->clock_type, info->clock_freq);\r\nif (r) {\r\nnfc_err(dev, "Clock set error %d\n", r);\r\nreturn r;\r\n}\r\nr = nci_core_reset(ndev);\r\nif (r)\r\nreturn r;\r\nreturn nci_core_init(ndev);\r\n}\r\nstatic int fdp_nci_core_reset_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\ninfo->setup_reset_ntf = 1;\r\nwake_up(&info->setup_wq);\r\nreturn 0;\r\n}\r\nstatic int fdp_nci_prop_patch_ntf_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\ninfo->setup_patch_ntf = 1;\r\ninfo->setup_patch_status = skb->data[0];\r\nwake_up(&info->setup_wq);\r\nreturn 0;\r\n}\r\nstatic int fdp_nci_prop_patch_rsp_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nu8 status = skb->data[0];\r\ndev_dbg(dev, "%s: status 0x%x\n", __func__, status);\r\nnci_req_complete(ndev, status);\r\nreturn 0;\r\n}\r\nstatic int fdp_nci_prop_set_production_data_rsp_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nu8 status = skb->data[0];\r\ndev_dbg(dev, "%s: status 0x%x\n", __func__, status);\r\nnci_req_complete(ndev, status);\r\nreturn 0;\r\n}\r\nstatic int fdp_nci_core_get_config_rsp_packet(struct nci_dev *ndev,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\nstruct nci_core_get_config_rsp *rsp = (void *) skb->data;\r\nu8 i, *p;\r\nif (rsp->status == NCI_STATUS_OK) {\r\np = rsp->data;\r\nfor (i = 0; i < 4; i++) {\r\nswitch (*p++) {\r\ncase NCI_PARAM_ID_FW_RAM_VERSION:\r\np++;\r\ninfo->ram_version = le32_to_cpup((__le32 *) p);\r\np += 4;\r\nbreak;\r\ncase NCI_PARAM_ID_FW_OTP_VERSION:\r\np++;\r\ninfo->otp_version = le32_to_cpup((__le32 *) p);\r\np += 4;\r\nbreak;\r\ncase NCI_PARAM_ID_OTP_LIMITED_VERSION:\r\np++;\r\ninfo->otp_version = le32_to_cpup((__le32 *) p);\r\np += 4;\r\nbreak;\r\ncase NCI_PARAM_ID_KEY_INDEX_ID:\r\np++;\r\ninfo->key_index = *p++;\r\n}\r\n}\r\n}\r\ndev_dbg(dev, "OTP version %d\n", info->otp_version);\r\ndev_dbg(dev, "RAM version %d\n", info->ram_version);\r\ndev_dbg(dev, "key index %d\n", info->key_index);\r\ndev_dbg(dev, "%s: status 0x%x\n", __func__, rsp->status);\r\nnci_req_complete(ndev, rsp->status);\r\nreturn 0;\r\n}\r\nint fdp_nci_probe(struct fdp_i2c_phy *phy, struct nfc_phy_ops *phy_ops,\r\nstruct nci_dev **ndevp, int tx_headroom,\r\nint tx_tailroom, u8 clock_type, u32 clock_freq,\r\nu8 *fw_vsc_cfg)\r\n{\r\nstruct device *dev = &phy->i2c_dev->dev;\r\nstruct fdp_nci_info *info;\r\nstruct nci_dev *ndev;\r\nu32 protocols;\r\nint r;\r\ninfo = kzalloc(sizeof(struct fdp_nci_info), GFP_KERNEL);\r\nif (!info) {\r\nr = -ENOMEM;\r\ngoto err_info_alloc;\r\n}\r\ninfo->phy = phy;\r\ninfo->phy_ops = phy_ops;\r\ninfo->clock_type = clock_type;\r\ninfo->clock_freq = clock_freq;\r\ninfo->fw_vsc_cfg = fw_vsc_cfg;\r\ninit_waitqueue_head(&info->setup_wq);\r\nprotocols = NFC_PROTO_JEWEL_MASK |\r\nNFC_PROTO_MIFARE_MASK |\r\nNFC_PROTO_FELICA_MASK |\r\nNFC_PROTO_ISO14443_MASK |\r\nNFC_PROTO_ISO14443_B_MASK |\r\nNFC_PROTO_NFC_DEP_MASK |\r\nNFC_PROTO_ISO15693_MASK;\r\nndev = nci_allocate_device(&nci_ops, protocols, tx_headroom,\r\ntx_tailroom);\r\nif (!ndev) {\r\nnfc_err(dev, "Cannot allocate nfc ndev\n");\r\nr = -ENOMEM;\r\ngoto err_alloc_ndev;\r\n}\r\nr = nci_register_device(ndev);\r\nif (r)\r\ngoto err_regdev;\r\n*ndevp = ndev;\r\ninfo->ndev = ndev;\r\nnci_set_drvdata(ndev, info);\r\nreturn 0;\r\nerr_regdev:\r\nnci_free_device(ndev);\r\nerr_alloc_ndev:\r\nkfree(info);\r\nerr_info_alloc:\r\nreturn r;\r\n}\r\nvoid fdp_nci_remove(struct nci_dev *ndev)\r\n{\r\nstruct fdp_nci_info *info = nci_get_drvdata(ndev);\r\nstruct device *dev = &info->phy->i2c_dev->dev;\r\ndev_dbg(dev, "%s\n", __func__);\r\nnci_unregister_device(ndev);\r\nnci_free_device(ndev);\r\nkfree(info);\r\n}
