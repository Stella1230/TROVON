STATIC int\r\nxfs_qm_dquot_walk(\r\nstruct xfs_mount *mp,\r\nint type,\r\nint (*execute)(struct xfs_dquot *dqp, void *data),\r\nvoid *data)\r\n{\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\r\nuint32_t next_index;\r\nint last_error = 0;\r\nint skipped;\r\nint nr_found;\r\nrestart:\r\nskipped = 0;\r\nnext_index = 0;\r\nnr_found = 0;\r\nwhile (1) {\r\nstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\r\nint error = 0;\r\nint i;\r\nmutex_lock(&qi->qi_tree_lock);\r\nnr_found = radix_tree_gang_lookup(tree, (void **)batch,\r\nnext_index, XFS_DQ_LOOKUP_BATCH);\r\nif (!nr_found) {\r\nmutex_unlock(&qi->qi_tree_lock);\r\nbreak;\r\n}\r\nfor (i = 0; i < nr_found; i++) {\r\nstruct xfs_dquot *dqp = batch[i];\r\nnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\r\nerror = execute(batch[i], data);\r\nif (error == -EAGAIN) {\r\nskipped++;\r\ncontinue;\r\n}\r\nif (error && last_error != -EFSCORRUPTED)\r\nlast_error = error;\r\n}\r\nmutex_unlock(&qi->qi_tree_lock);\r\nif (last_error == -EFSCORRUPTED) {\r\nskipped = 0;\r\nbreak;\r\n}\r\n}\r\nif (skipped) {\r\ndelay(1);\r\ngoto restart;\r\n}\r\nreturn last_error;\r\n}\r\nSTATIC int\r\nxfs_qm_dqpurge(\r\nstruct xfs_dquot *dqp,\r\nvoid *data)\r\n{\r\nstruct xfs_mount *mp = dqp->q_mount;\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nxfs_dqlock(dqp);\r\nif ((dqp->dq_flags & XFS_DQ_FREEING) || dqp->q_nrefs != 0) {\r\nxfs_dqunlock(dqp);\r\nreturn -EAGAIN;\r\n}\r\ndqp->dq_flags |= XFS_DQ_FREEING;\r\nxfs_dqflock(dqp);\r\nif (XFS_DQ_IS_DIRTY(dqp)) {\r\nstruct xfs_buf *bp = NULL;\r\nint error;\r\nerror = xfs_qm_dqflush(dqp, &bp);\r\nif (error) {\r\nxfs_warn(mp, "%s: dquot %p flush failed",\r\n__func__, dqp);\r\n} else {\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\n}\r\nxfs_dqflock(dqp);\r\n}\r\nASSERT(atomic_read(&dqp->q_pincount) == 0);\r\nASSERT(XFS_FORCED_SHUTDOWN(mp) ||\r\n!(dqp->q_logitem.qli_item.li_flags & XFS_LI_IN_AIL));\r\nxfs_dqfunlock(dqp);\r\nxfs_dqunlock(dqp);\r\nradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\r\nbe32_to_cpu(dqp->q_core.d_id));\r\nqi->qi_dquots--;\r\nASSERT(!list_empty(&dqp->q_lru));\r\nlist_lru_del(&qi->qi_lru, &dqp->q_lru);\r\nXFS_STATS_DEC(mp, xs_qm_dquot_unused);\r\nxfs_qm_dqdestroy(dqp);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_dqpurge_all(\r\nstruct xfs_mount *mp,\r\nuint flags)\r\n{\r\nif (flags & XFS_QMOPT_UQUOTA)\r\nxfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\r\nif (flags & XFS_QMOPT_GQUOTA)\r\nxfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\r\nif (flags & XFS_QMOPT_PQUOTA)\r\nxfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\r\n}\r\nvoid\r\nxfs_qm_unmount(\r\nstruct xfs_mount *mp)\r\n{\r\nif (mp->m_quotainfo) {\r\nxfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\r\nxfs_qm_destroy_quotainfo(mp);\r\n}\r\n}\r\nvoid\r\nxfs_qm_unmount_quotas(\r\nxfs_mount_t *mp)\r\n{\r\nASSERT(mp->m_rootip);\r\nxfs_qm_dqdetach(mp->m_rootip);\r\nif (mp->m_rbmip)\r\nxfs_qm_dqdetach(mp->m_rbmip);\r\nif (mp->m_rsumip)\r\nxfs_qm_dqdetach(mp->m_rsumip);\r\nif (mp->m_quotainfo) {\r\nif (mp->m_quotainfo->qi_uquotaip) {\r\nIRELE(mp->m_quotainfo->qi_uquotaip);\r\nmp->m_quotainfo->qi_uquotaip = NULL;\r\n}\r\nif (mp->m_quotainfo->qi_gquotaip) {\r\nIRELE(mp->m_quotainfo->qi_gquotaip);\r\nmp->m_quotainfo->qi_gquotaip = NULL;\r\n}\r\nif (mp->m_quotainfo->qi_pquotaip) {\r\nIRELE(mp->m_quotainfo->qi_pquotaip);\r\nmp->m_quotainfo->qi_pquotaip = NULL;\r\n}\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_dqattach_one(\r\nxfs_inode_t *ip,\r\nxfs_dqid_t id,\r\nuint type,\r\nuint doalloc,\r\nxfs_dquot_t **IO_idqpp)\r\n{\r\nxfs_dquot_t *dqp;\r\nint error;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nerror = 0;\r\ndqp = *IO_idqpp;\r\nif (dqp) {\r\ntrace_xfs_dqattach_found(dqp);\r\nreturn 0;\r\n}\r\nerror = xfs_qm_dqget(ip->i_mount, ip, id, type,\r\ndoalloc | XFS_QMOPT_DOWARN, &dqp);\r\nif (error)\r\nreturn error;\r\ntrace_xfs_dqattach_get(dqp);\r\n*IO_idqpp = dqp;\r\nxfs_dqunlock(dqp);\r\nreturn 0;\r\n}\r\nstatic bool\r\nxfs_qm_need_dqattach(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nif (!XFS_IS_QUOTA_RUNNING(mp))\r\nreturn false;\r\nif (!XFS_IS_QUOTA_ON(mp))\r\nreturn false;\r\nif (!XFS_NOT_DQATTACHED(mp, ip))\r\nreturn false;\r\nif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nxfs_qm_dqattach_locked(\r\nxfs_inode_t *ip,\r\nuint flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nint error = 0;\r\nif (!xfs_qm_need_dqattach(ip))\r\nreturn 0;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\r\nerror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\r\nflags & XFS_QMOPT_DQALLOC,\r\n&ip->i_udquot);\r\nif (error)\r\ngoto done;\r\nASSERT(ip->i_udquot);\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\r\nerror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\r\nflags & XFS_QMOPT_DQALLOC,\r\n&ip->i_gdquot);\r\nif (error)\r\ngoto done;\r\nASSERT(ip->i_gdquot);\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\r\nerror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\r\nflags & XFS_QMOPT_DQALLOC,\r\n&ip->i_pdquot);\r\nif (error)\r\ngoto done;\r\nASSERT(ip->i_pdquot);\r\n}\r\ndone:\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_dqattach(\r\nstruct xfs_inode *ip,\r\nuint flags)\r\n{\r\nint error;\r\nif (!xfs_qm_need_dqattach(ip))\r\nreturn 0;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_qm_dqattach_locked(ip, flags);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nvoid\r\nxfs_qm_dqdetach(\r\nxfs_inode_t *ip)\r\n{\r\nif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\r\nreturn;\r\ntrace_xfs_dquot_dqdetach(ip);\r\nASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\r\nif (ip->i_udquot) {\r\nxfs_qm_dqrele(ip->i_udquot);\r\nip->i_udquot = NULL;\r\n}\r\nif (ip->i_gdquot) {\r\nxfs_qm_dqrele(ip->i_gdquot);\r\nip->i_gdquot = NULL;\r\n}\r\nif (ip->i_pdquot) {\r\nxfs_qm_dqrele(ip->i_pdquot);\r\nip->i_pdquot = NULL;\r\n}\r\n}\r\nstatic enum lru_status\r\nxfs_qm_dquot_isolate(\r\nstruct list_head *item,\r\nstruct list_lru_one *lru,\r\nspinlock_t *lru_lock,\r\nvoid *arg)\r\n__releases(lru_lock) __acquires(lru_lock)\r\n{\r\nstruct xfs_dquot *dqp = container_of(item,\r\nstruct xfs_dquot, q_lru);\r\nstruct xfs_qm_isolate *isol = arg;\r\nif (!xfs_dqlock_nowait(dqp))\r\ngoto out_miss_busy;\r\nif (dqp->q_nrefs) {\r\nxfs_dqunlock(dqp);\r\nXFS_STATS_INC(dqp->q_mount, xs_qm_dqwants);\r\ntrace_xfs_dqreclaim_want(dqp);\r\nlist_lru_isolate(lru, &dqp->q_lru);\r\nXFS_STATS_DEC(dqp->q_mount, xs_qm_dquot_unused);\r\nreturn LRU_REMOVED;\r\n}\r\nif (!xfs_dqflock_nowait(dqp)) {\r\nxfs_dqunlock(dqp);\r\ngoto out_miss_busy;\r\n}\r\nif (XFS_DQ_IS_DIRTY(dqp)) {\r\nstruct xfs_buf *bp = NULL;\r\nint error;\r\ntrace_xfs_dqreclaim_dirty(dqp);\r\nspin_unlock(lru_lock);\r\nerror = xfs_qm_dqflush(dqp, &bp);\r\nif (error) {\r\nxfs_warn(dqp->q_mount, "%s: dquot %p flush failed",\r\n__func__, dqp);\r\ngoto out_unlock_dirty;\r\n}\r\nxfs_buf_delwri_queue(bp, &isol->buffers);\r\nxfs_buf_relse(bp);\r\ngoto out_unlock_dirty;\r\n}\r\nxfs_dqfunlock(dqp);\r\ndqp->dq_flags |= XFS_DQ_FREEING;\r\nxfs_dqunlock(dqp);\r\nASSERT(dqp->q_nrefs == 0);\r\nlist_lru_isolate_move(lru, &dqp->q_lru, &isol->dispose);\r\nXFS_STATS_DEC(dqp->q_mount, xs_qm_dquot_unused);\r\ntrace_xfs_dqreclaim_done(dqp);\r\nXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaims);\r\nreturn LRU_REMOVED;\r\nout_miss_busy:\r\ntrace_xfs_dqreclaim_busy(dqp);\r\nXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaim_misses);\r\nreturn LRU_SKIP;\r\nout_unlock_dirty:\r\ntrace_xfs_dqreclaim_busy(dqp);\r\nXFS_STATS_INC(dqp->q_mount, xs_qm_dqreclaim_misses);\r\nxfs_dqunlock(dqp);\r\nspin_lock(lru_lock);\r\nreturn LRU_RETRY;\r\n}\r\nstatic unsigned long\r\nxfs_qm_shrink_scan(\r\nstruct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nstruct xfs_quotainfo *qi = container_of(shrink,\r\nstruct xfs_quotainfo, qi_shrinker);\r\nstruct xfs_qm_isolate isol;\r\nunsigned long freed;\r\nint error;\r\nif ((sc->gfp_mask & (__GFP_FS|__GFP_DIRECT_RECLAIM)) != (__GFP_FS|__GFP_DIRECT_RECLAIM))\r\nreturn 0;\r\nINIT_LIST_HEAD(&isol.buffers);\r\nINIT_LIST_HEAD(&isol.dispose);\r\nfreed = list_lru_shrink_walk(&qi->qi_lru, sc,\r\nxfs_qm_dquot_isolate, &isol);\r\nerror = xfs_buf_delwri_submit(&isol.buffers);\r\nif (error)\r\nxfs_warn(NULL, "%s: dquot reclaim failed", __func__);\r\nwhile (!list_empty(&isol.dispose)) {\r\nstruct xfs_dquot *dqp;\r\ndqp = list_first_entry(&isol.dispose, struct xfs_dquot, q_lru);\r\nlist_del_init(&dqp->q_lru);\r\nxfs_qm_dqfree_one(dqp);\r\n}\r\nreturn freed;\r\n}\r\nstatic unsigned long\r\nxfs_qm_shrink_count(\r\nstruct shrinker *shrink,\r\nstruct shrink_control *sc)\r\n{\r\nstruct xfs_quotainfo *qi = container_of(shrink,\r\nstruct xfs_quotainfo, qi_shrinker);\r\nreturn list_lru_shrink_count(&qi->qi_lru, sc);\r\n}\r\nSTATIC void\r\nxfs_qm_set_defquota(\r\nxfs_mount_t *mp,\r\nuint type,\r\nxfs_quotainfo_t *qinf)\r\n{\r\nxfs_dquot_t *dqp;\r\nstruct xfs_def_quota *defq;\r\nint error;\r\nerror = xfs_qm_dqread(mp, 0, type, XFS_QMOPT_DOWARN, &dqp);\r\nif (!error) {\r\nxfs_disk_dquot_t *ddqp = &dqp->q_core;\r\ndefq = xfs_get_defquota(dqp, qinf);\r\ndefq->bhardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\r\ndefq->bsoftlimit = be64_to_cpu(ddqp->d_blk_softlimit);\r\ndefq->ihardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\r\ndefq->isoftlimit = be64_to_cpu(ddqp->d_ino_softlimit);\r\ndefq->rtbhardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\r\ndefq->rtbsoftlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\r\nxfs_qm_dqdestroy(dqp);\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_init_quotainfo(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_quotainfo_t *qinf;\r\nint error;\r\nxfs_dquot_t *dqp;\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nqinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);\r\nerror = list_lru_init(&qinf->qi_lru);\r\nif (error)\r\ngoto out_free_qinf;\r\nerror = xfs_qm_init_quotainos(mp);\r\nif (error)\r\ngoto out_free_lru;\r\nINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\r\nINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\r\nINIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);\r\nmutex_init(&qinf->qi_tree_lock);\r\nmutex_init(&qinf->qi_quotaofflock);\r\nqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\r\nqinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);\r\nmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\r\nerror = xfs_qm_dqread(mp, 0,\r\nXFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\r\n(XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\r\nXFS_DQ_PROJ),\r\nXFS_QMOPT_DOWARN, &dqp);\r\nif (!error) {\r\nxfs_disk_dquot_t *ddqp = &dqp->q_core;\r\nqinf->qi_btimelimit = ddqp->d_btimer ?\r\nbe32_to_cpu(ddqp->d_btimer) : XFS_QM_BTIMELIMIT;\r\nqinf->qi_itimelimit = ddqp->d_itimer ?\r\nbe32_to_cpu(ddqp->d_itimer) : XFS_QM_ITIMELIMIT;\r\nqinf->qi_rtbtimelimit = ddqp->d_rtbtimer ?\r\nbe32_to_cpu(ddqp->d_rtbtimer) : XFS_QM_RTBTIMELIMIT;\r\nqinf->qi_bwarnlimit = ddqp->d_bwarns ?\r\nbe16_to_cpu(ddqp->d_bwarns) : XFS_QM_BWARNLIMIT;\r\nqinf->qi_iwarnlimit = ddqp->d_iwarns ?\r\nbe16_to_cpu(ddqp->d_iwarns) : XFS_QM_IWARNLIMIT;\r\nqinf->qi_rtbwarnlimit = ddqp->d_rtbwarns ?\r\nbe16_to_cpu(ddqp->d_rtbwarns) : XFS_QM_RTBWARNLIMIT;\r\nxfs_qm_dqdestroy(dqp);\r\n} else {\r\nqinf->qi_btimelimit = XFS_QM_BTIMELIMIT;\r\nqinf->qi_itimelimit = XFS_QM_ITIMELIMIT;\r\nqinf->qi_rtbtimelimit = XFS_QM_RTBTIMELIMIT;\r\nqinf->qi_bwarnlimit = XFS_QM_BWARNLIMIT;\r\nqinf->qi_iwarnlimit = XFS_QM_IWARNLIMIT;\r\nqinf->qi_rtbwarnlimit = XFS_QM_RTBWARNLIMIT;\r\n}\r\nif (XFS_IS_UQUOTA_RUNNING(mp))\r\nxfs_qm_set_defquota(mp, XFS_DQ_USER, qinf);\r\nif (XFS_IS_GQUOTA_RUNNING(mp))\r\nxfs_qm_set_defquota(mp, XFS_DQ_GROUP, qinf);\r\nif (XFS_IS_PQUOTA_RUNNING(mp))\r\nxfs_qm_set_defquota(mp, XFS_DQ_PROJ, qinf);\r\nqinf->qi_shrinker.count_objects = xfs_qm_shrink_count;\r\nqinf->qi_shrinker.scan_objects = xfs_qm_shrink_scan;\r\nqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\r\nqinf->qi_shrinker.flags = SHRINKER_NUMA_AWARE;\r\nregister_shrinker(&qinf->qi_shrinker);\r\nreturn 0;\r\nout_free_lru:\r\nlist_lru_destroy(&qinf->qi_lru);\r\nout_free_qinf:\r\nkmem_free(qinf);\r\nmp->m_quotainfo = NULL;\r\nreturn error;\r\n}\r\nvoid\r\nxfs_qm_destroy_quotainfo(\r\nxfs_mount_t *mp)\r\n{\r\nxfs_quotainfo_t *qi;\r\nqi = mp->m_quotainfo;\r\nASSERT(qi != NULL);\r\nunregister_shrinker(&qi->qi_shrinker);\r\nlist_lru_destroy(&qi->qi_lru);\r\nif (qi->qi_uquotaip) {\r\nIRELE(qi->qi_uquotaip);\r\nqi->qi_uquotaip = NULL;\r\n}\r\nif (qi->qi_gquotaip) {\r\nIRELE(qi->qi_gquotaip);\r\nqi->qi_gquotaip = NULL;\r\n}\r\nif (qi->qi_pquotaip) {\r\nIRELE(qi->qi_pquotaip);\r\nqi->qi_pquotaip = NULL;\r\n}\r\nmutex_destroy(&qi->qi_quotaofflock);\r\nkmem_free(qi);\r\nmp->m_quotainfo = NULL;\r\n}\r\nSTATIC int\r\nxfs_qm_qino_alloc(\r\nxfs_mount_t *mp,\r\nxfs_inode_t **ip,\r\nuint flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nint committed;\r\nbool need_alloc = true;\r\n*ip = NULL;\r\nif (!xfs_sb_version_has_pquotino(&mp->m_sb) &&\r\n(flags & (XFS_QMOPT_PQUOTA|XFS_QMOPT_GQUOTA))) {\r\nxfs_ino_t ino = NULLFSINO;\r\nif ((flags & XFS_QMOPT_PQUOTA) &&\r\n(mp->m_sb.sb_gquotino != NULLFSINO)) {\r\nino = mp->m_sb.sb_gquotino;\r\nASSERT(mp->m_sb.sb_pquotino == NULLFSINO);\r\n} else if ((flags & XFS_QMOPT_GQUOTA) &&\r\n(mp->m_sb.sb_pquotino != NULLFSINO)) {\r\nino = mp->m_sb.sb_pquotino;\r\nASSERT(mp->m_sb.sb_gquotino == NULLFSINO);\r\n}\r\nif (ino != NULLFSINO) {\r\nerror = xfs_iget(mp, NULL, ino, 0, 0, ip);\r\nif (error)\r\nreturn error;\r\nmp->m_sb.sb_gquotino = NULLFSINO;\r\nmp->m_sb.sb_pquotino = NULLFSINO;\r\nneed_alloc = false;\r\n}\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_create,\r\nXFS_QM_QINOCREATE_SPACE_RES(mp), 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nif (need_alloc) {\r\nerror = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip,\r\n&committed);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\nreturn error;\r\n}\r\n}\r\nspin_lock(&mp->m_sb_lock);\r\nif (flags & XFS_QMOPT_SBVERSION) {\r\nASSERT(!xfs_sb_version_hasquota(&mp->m_sb));\r\nxfs_sb_version_addquota(&mp->m_sb);\r\nmp->m_sb.sb_uquotino = NULLFSINO;\r\nmp->m_sb.sb_gquotino = NULLFSINO;\r\nmp->m_sb.sb_pquotino = NULLFSINO;\r\nmp->m_sb.sb_qflags = mp->m_qflags & XFS_ALL_QUOTA_ACCT;\r\n}\r\nif (flags & XFS_QMOPT_UQUOTA)\r\nmp->m_sb.sb_uquotino = (*ip)->i_ino;\r\nelse if (flags & XFS_QMOPT_GQUOTA)\r\nmp->m_sb.sb_gquotino = (*ip)->i_ino;\r\nelse\r\nmp->m_sb.sb_pquotino = (*ip)->i_ino;\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_log_sb(tp);\r\nerror = xfs_trans_commit(tp);\r\nif (error) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\nxfs_alert(mp, "%s failed (error %d)!", __func__, error);\r\n}\r\nif (need_alloc)\r\nxfs_finish_inode_setup(*ip);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_qm_reset_dqcounts(\r\nxfs_mount_t *mp,\r\nxfs_buf_t *bp,\r\nxfs_dqid_t id,\r\nuint type)\r\n{\r\nstruct xfs_dqblk *dqb;\r\nint j;\r\ntrace_xfs_reset_dqcounts(bp, _RET_IP_);\r\n#ifdef DEBUG\r\nj = XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\r\ndo_div(j, sizeof(xfs_dqblk_t));\r\nASSERT(mp->m_quotainfo->qi_dqperchunk == j);\r\n#endif\r\ndqb = bp->b_addr;\r\nfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\r\nstruct xfs_disk_dquot *ddq;\r\nddq = (struct xfs_disk_dquot *)&dqb[j];\r\nxfs_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR,\r\n"xfs_quotacheck");\r\nddq->d_flags = type;\r\nddq->d_bcount = 0;\r\nddq->d_icount = 0;\r\nddq->d_rtbcount = 0;\r\nddq->d_btimer = 0;\r\nddq->d_itimer = 0;\r\nddq->d_rtbtimer = 0;\r\nddq->d_bwarns = 0;\r\nddq->d_iwarns = 0;\r\nddq->d_rtbwarns = 0;\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nxfs_update_cksum((char *)&dqb[j],\r\nsizeof(struct xfs_dqblk),\r\nXFS_DQUOT_CRC_OFF);\r\n}\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_dqiter_bufs(\r\nstruct xfs_mount *mp,\r\nxfs_dqid_t firstid,\r\nxfs_fsblock_t bno,\r\nxfs_filblks_t blkcnt,\r\nuint flags,\r\nstruct list_head *buffer_list)\r\n{\r\nstruct xfs_buf *bp;\r\nint error;\r\nint type;\r\nASSERT(blkcnt > 0);\r\ntype = flags & XFS_QMOPT_UQUOTA ? XFS_DQ_USER :\r\n(flags & XFS_QMOPT_PQUOTA ? XFS_DQ_PROJ : XFS_DQ_GROUP);\r\nerror = 0;\r\nwhile (blkcnt--) {\r\nerror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, bno),\r\nmp->m_quotainfo->qi_dqchunklen, 0, &bp,\r\n&xfs_dquot_buf_ops);\r\nif (error == -EFSCORRUPTED) {\r\nerror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, bno),\r\nmp->m_quotainfo->qi_dqchunklen, 0, &bp,\r\nNULL);\r\n}\r\nif (error)\r\nbreak;\r\nbp->b_ops = &xfs_dquot_buf_ops;\r\nxfs_qm_reset_dqcounts(mp, bp, firstid, type);\r\nxfs_buf_delwri_queue(bp, buffer_list);\r\nxfs_buf_relse(bp);\r\nbno++;\r\nfirstid += mp->m_quotainfo->qi_dqperchunk;\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_dqiterate(\r\nstruct xfs_mount *mp,\r\nstruct xfs_inode *qip,\r\nuint flags,\r\nstruct list_head *buffer_list)\r\n{\r\nstruct xfs_bmbt_irec *map;\r\nint i, nmaps;\r\nint error;\r\nxfs_fileoff_t lblkno;\r\nxfs_filblks_t maxlblkcnt;\r\nxfs_dqid_t firstid;\r\nxfs_fsblock_t rablkno;\r\nxfs_filblks_t rablkcnt;\r\nerror = 0;\r\nif (qip->i_d.di_nblocks == 0)\r\nreturn 0;\r\nmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), KM_SLEEP);\r\nlblkno = 0;\r\nmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\r\ndo {\r\nuint lock_mode;\r\nnmaps = XFS_DQITER_MAP_SIZE;\r\nlock_mode = xfs_ilock_data_map_shared(qip);\r\nerror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\r\nmap, &nmaps, 0);\r\nxfs_iunlock(qip, lock_mode);\r\nif (error)\r\nbreak;\r\nASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\r\nfor (i = 0; i < nmaps; i++) {\r\nASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\r\nASSERT(map[i].br_blockcount);\r\nlblkno += map[i].br_blockcount;\r\nif (map[i].br_startblock == HOLESTARTBLOCK)\r\ncontinue;\r\nfirstid = (xfs_dqid_t) map[i].br_startoff *\r\nmp->m_quotainfo->qi_dqperchunk;\r\nif ((i+1 < nmaps) &&\r\n(map[i+1].br_startblock != HOLESTARTBLOCK)) {\r\nrablkcnt = map[i+1].br_blockcount;\r\nrablkno = map[i+1].br_startblock;\r\nwhile (rablkcnt--) {\r\nxfs_buf_readahead(mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, rablkno),\r\nmp->m_quotainfo->qi_dqchunklen,\r\n&xfs_dquot_buf_ops);\r\nrablkno++;\r\n}\r\n}\r\nerror = xfs_qm_dqiter_bufs(mp, firstid,\r\nmap[i].br_startblock,\r\nmap[i].br_blockcount,\r\nflags, buffer_list);\r\nif (error)\r\ngoto out;\r\n}\r\n} while (nmaps > 0);\r\nout:\r\nkmem_free(map);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_quotacheck_dqadjust(\r\nstruct xfs_inode *ip,\r\nxfs_dqid_t id,\r\nuint type,\r\nxfs_qcnt_t nblks,\r\nxfs_qcnt_t rtblks)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_dquot *dqp;\r\nint error;\r\nerror = xfs_qm_dqget(mp, ip, id, type,\r\nXFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\r\nif (error) {\r\nASSERT(error != -ESRCH);\r\nASSERT(error != -ENOENT);\r\nreturn error;\r\n}\r\ntrace_xfs_dqadjust(dqp);\r\nbe64_add_cpu(&dqp->q_core.d_icount, 1);\r\ndqp->q_res_icount++;\r\nif (nblks) {\r\nbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\r\ndqp->q_res_bcount += nblks;\r\n}\r\nif (rtblks) {\r\nbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\r\ndqp->q_res_rtbcount += rtblks;\r\n}\r\nif (dqp->q_core.d_id) {\r\nxfs_qm_adjust_dqlimits(mp, dqp);\r\nxfs_qm_adjust_dqtimers(mp, &dqp->q_core);\r\n}\r\ndqp->dq_flags |= XFS_DQ_DIRTY;\r\nxfs_qm_dqput(dqp);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_qm_get_rtblks(\r\nxfs_inode_t *ip,\r\nxfs_qcnt_t *O_rtblks)\r\n{\r\nxfs_filblks_t rtblks;\r\nxfs_extnum_t idx;\r\nxfs_ifork_t *ifp;\r\nxfs_extnum_t nextents;\r\nint error;\r\nASSERT(XFS_IS_REALTIME_INODE(ip));\r\nifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\r\nif (!(ifp->if_flags & XFS_IFEXTENTS)) {\r\nif ((error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))\r\nreturn error;\r\n}\r\nrtblks = 0;\r\nnextents = xfs_iext_count(ifp);\r\nfor (idx = 0; idx < nextents; idx++)\r\nrtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));\r\n*O_rtblks = (xfs_qcnt_t)rtblks;\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_qm_dqusage_adjust(\r\nxfs_mount_t *mp,\r\nxfs_ino_t ino,\r\nvoid __user *buffer,\r\nint ubsize,\r\nint *ubused,\r\nint *res)\r\n{\r\nxfs_inode_t *ip;\r\nxfs_qcnt_t nblks, rtblks = 0;\r\nint error;\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nif (xfs_is_quota_inode(&mp->m_sb, ino)) {\r\n*res = BULKSTAT_RV_NOTHING;\r\nreturn -EINVAL;\r\n}\r\nerror = xfs_iget(mp, NULL, ino, XFS_IGET_DONTCACHE, XFS_ILOCK_EXCL,\r\n&ip);\r\nif (error) {\r\n*res = BULKSTAT_RV_NOTHING;\r\nreturn error;\r\n}\r\nASSERT(ip->i_delayed_blks == 0);\r\nif (XFS_IS_REALTIME_INODE(ip)) {\r\nerror = xfs_qm_get_rtblks(ip, &rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nnblks = (xfs_qcnt_t)ip->i_d.di_nblocks - rtblks;\r\nif (XFS_IS_UQUOTA_ON(mp)) {\r\nerror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_uid,\r\nXFS_DQ_USER, nblks, rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp)) {\r\nerror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_gid,\r\nXFS_DQ_GROUP, nblks, rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp)) {\r\nerror = xfs_qm_quotacheck_dqadjust(ip, xfs_get_projid(ip),\r\nXFS_DQ_PROJ, nblks, rtblks);\r\nif (error)\r\ngoto error0;\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nIRELE(ip);\r\n*res = BULKSTAT_RV_DIDONE;\r\nreturn 0;\r\nerror0:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nIRELE(ip);\r\n*res = BULKSTAT_RV_GIVEUP;\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_flush_one(\r\nstruct xfs_dquot *dqp,\r\nvoid *data)\r\n{\r\nstruct list_head *buffer_list = data;\r\nstruct xfs_buf *bp = NULL;\r\nint error = 0;\r\nxfs_dqlock(dqp);\r\nif (dqp->dq_flags & XFS_DQ_FREEING)\r\ngoto out_unlock;\r\nif (!XFS_DQ_IS_DIRTY(dqp))\r\ngoto out_unlock;\r\nxfs_dqflock(dqp);\r\nerror = xfs_qm_dqflush(dqp, &bp);\r\nif (error)\r\ngoto out_unlock;\r\nxfs_buf_delwri_queue(bp, buffer_list);\r\nxfs_buf_relse(bp);\r\nout_unlock:\r\nxfs_dqunlock(dqp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_quotacheck(\r\nxfs_mount_t *mp)\r\n{\r\nint done, count, error, error2;\r\nxfs_ino_t lastino;\r\nsize_t structsz;\r\nuint flags;\r\nLIST_HEAD (buffer_list);\r\nstruct xfs_inode *uip = mp->m_quotainfo->qi_uquotaip;\r\nstruct xfs_inode *gip = mp->m_quotainfo->qi_gquotaip;\r\nstruct xfs_inode *pip = mp->m_quotainfo->qi_pquotaip;\r\ncount = INT_MAX;\r\nstructsz = 1;\r\nlastino = 0;\r\nflags = 0;\r\nASSERT(uip || gip || pip);\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nxfs_notice(mp, "Quotacheck needed: Please wait.");\r\nif (uip) {\r\nerror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\r\n&buffer_list);\r\nif (error)\r\ngoto error_return;\r\nflags |= XFS_UQUOTA_CHKD;\r\n}\r\nif (gip) {\r\nerror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\r\n&buffer_list);\r\nif (error)\r\ngoto error_return;\r\nflags |= XFS_GQUOTA_CHKD;\r\n}\r\nif (pip) {\r\nerror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\r\n&buffer_list);\r\nif (error)\r\ngoto error_return;\r\nflags |= XFS_PQUOTA_CHKD;\r\n}\r\ndo {\r\nerror = xfs_bulkstat(mp, &lastino, &count,\r\nxfs_qm_dqusage_adjust,\r\nstructsz, NULL, &done);\r\nif (error)\r\nbreak;\r\n} while (!done);\r\nif (XFS_IS_UQUOTA_ON(mp)) {\r\nerror = xfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_flush_one,\r\n&buffer_list);\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp)) {\r\nerror2 = xfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_flush_one,\r\n&buffer_list);\r\nif (!error)\r\nerror = error2;\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp)) {\r\nerror2 = xfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_flush_one,\r\n&buffer_list);\r\nif (!error)\r\nerror = error2;\r\n}\r\nerror2 = xfs_buf_delwri_submit(&buffer_list);\r\nif (!error)\r\nerror = error2;\r\nif (error) {\r\nxfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\r\ngoto error_return;\r\n}\r\nmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\r\nmp->m_qflags |= flags;\r\nerror_return:\r\nwhile (!list_empty(&buffer_list)) {\r\nstruct xfs_buf *bp =\r\nlist_first_entry(&buffer_list, struct xfs_buf, b_list);\r\nlist_del_init(&bp->b_list);\r\nxfs_buf_relse(bp);\r\n}\r\nif (error) {\r\nxfs_warn(mp,\r\n"Quotacheck: Unsuccessful (Error %d): Disabling quotas.",\r\nerror);\r\nASSERT(mp->m_quotainfo != NULL);\r\nxfs_qm_destroy_quotainfo(mp);\r\nif (xfs_mount_reset_sbqflags(mp)) {\r\nxfs_warn(mp,\r\n"Quotacheck: Failed to reset quota flags.");\r\n}\r\n} else\r\nxfs_notice(mp, "Quotacheck: Done.");\r\nreturn error;\r\n}\r\nvoid\r\nxfs_qm_mount_quotas(\r\nstruct xfs_mount *mp)\r\n{\r\nint error = 0;\r\nuint sbf;\r\nif (mp->m_sb.sb_rextents) {\r\nxfs_notice(mp, "Cannot turn on quotas for realtime filesystem");\r\nmp->m_qflags = 0;\r\ngoto write_changes;\r\n}\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nerror = xfs_qm_init_quotainfo(mp);\r\nif (error) {\r\nASSERT(mp->m_quotainfo == NULL);\r\nmp->m_qflags = 0;\r\ngoto write_changes;\r\n}\r\nif (XFS_QM_NEED_QUOTACHECK(mp)) {\r\nerror = xfs_qm_quotacheck(mp);\r\nif (error) {\r\nreturn;\r\n}\r\n}\r\nif (!XFS_IS_UQUOTA_ON(mp))\r\nmp->m_qflags &= ~XFS_UQUOTA_CHKD;\r\nif (!XFS_IS_GQUOTA_ON(mp))\r\nmp->m_qflags &= ~XFS_GQUOTA_CHKD;\r\nif (!XFS_IS_PQUOTA_ON(mp))\r\nmp->m_qflags &= ~XFS_PQUOTA_CHKD;\r\nwrite_changes:\r\nspin_lock(&mp->m_sb_lock);\r\nsbf = mp->m_sb.sb_qflags;\r\nmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\r\nspin_unlock(&mp->m_sb_lock);\r\nif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\r\nif (xfs_sync_sb(mp, false)) {\r\nASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\r\nxfs_alert(mp, "%s: Superblock update failed!",\r\n__func__);\r\n}\r\n}\r\nif (error) {\r\nxfs_warn(mp, "Failed to initialize disk quotas.");\r\nreturn;\r\n}\r\n}\r\nSTATIC int\r\nxfs_qm_init_quotainos(\r\nxfs_mount_t *mp)\r\n{\r\nstruct xfs_inode *uip = NULL;\r\nstruct xfs_inode *gip = NULL;\r\nstruct xfs_inode *pip = NULL;\r\nint error;\r\nuint flags = 0;\r\nASSERT(mp->m_quotainfo);\r\nif (xfs_sb_version_hasquota(&mp->m_sb)) {\r\nif (XFS_IS_UQUOTA_ON(mp) &&\r\nmp->m_sb.sb_uquotino != NULLFSINO) {\r\nASSERT(mp->m_sb.sb_uquotino > 0);\r\nerror = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\r\n0, 0, &uip);\r\nif (error)\r\nreturn error;\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp) &&\r\nmp->m_sb.sb_gquotino != NULLFSINO) {\r\nASSERT(mp->m_sb.sb_gquotino > 0);\r\nerror = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\r\n0, 0, &gip);\r\nif (error)\r\ngoto error_rele;\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp) &&\r\nmp->m_sb.sb_pquotino != NULLFSINO) {\r\nASSERT(mp->m_sb.sb_pquotino > 0);\r\nerror = xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\r\n0, 0, &pip);\r\nif (error)\r\ngoto error_rele;\r\n}\r\n} else {\r\nflags |= XFS_QMOPT_SBVERSION;\r\n}\r\nif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\r\nerror = xfs_qm_qino_alloc(mp, &uip,\r\nflags | XFS_QMOPT_UQUOTA);\r\nif (error)\r\ngoto error_rele;\r\nflags &= ~XFS_QMOPT_SBVERSION;\r\n}\r\nif (XFS_IS_GQUOTA_ON(mp) && gip == NULL) {\r\nerror = xfs_qm_qino_alloc(mp, &gip,\r\nflags | XFS_QMOPT_GQUOTA);\r\nif (error)\r\ngoto error_rele;\r\nflags &= ~XFS_QMOPT_SBVERSION;\r\n}\r\nif (XFS_IS_PQUOTA_ON(mp) && pip == NULL) {\r\nerror = xfs_qm_qino_alloc(mp, &pip,\r\nflags | XFS_QMOPT_PQUOTA);\r\nif (error)\r\ngoto error_rele;\r\n}\r\nmp->m_quotainfo->qi_uquotaip = uip;\r\nmp->m_quotainfo->qi_gquotaip = gip;\r\nmp->m_quotainfo->qi_pquotaip = pip;\r\nreturn 0;\r\nerror_rele:\r\nif (uip)\r\nIRELE(uip);\r\nif (gip)\r\nIRELE(gip);\r\nif (pip)\r\nIRELE(pip);\r\nreturn error;\r\n}\r\nSTATIC void\r\nxfs_qm_dqfree_one(\r\nstruct xfs_dquot *dqp)\r\n{\r\nstruct xfs_mount *mp = dqp->q_mount;\r\nstruct xfs_quotainfo *qi = mp->m_quotainfo;\r\nmutex_lock(&qi->qi_tree_lock);\r\nradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\r\nbe32_to_cpu(dqp->q_core.d_id));\r\nqi->qi_dquots--;\r\nmutex_unlock(&qi->qi_tree_lock);\r\nxfs_qm_dqdestroy(dqp);\r\n}\r\nint\r\nxfs_qm_vop_dqalloc(\r\nstruct xfs_inode *ip,\r\nxfs_dqid_t uid,\r\nxfs_dqid_t gid,\r\nprid_t prid,\r\nuint flags,\r\nstruct xfs_dquot **O_udqpp,\r\nstruct xfs_dquot **O_gdqpp,\r\nstruct xfs_dquot **O_pdqpp)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_dquot *uq = NULL;\r\nstruct xfs_dquot *gq = NULL;\r\nstruct xfs_dquot *pq = NULL;\r\nint error;\r\nuint lockflags;\r\nif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\r\nreturn 0;\r\nlockflags = XFS_ILOCK_EXCL;\r\nxfs_ilock(ip, lockflags);\r\nif ((flags & XFS_QMOPT_INHERIT) && XFS_INHERIT_GID(ip))\r\ngid = ip->i_d.di_gid;\r\nif (XFS_NOT_DQATTACHED(mp, ip)) {\r\nerror = xfs_qm_dqattach_locked(ip, XFS_QMOPT_DQALLOC);\r\nif (error) {\r\nxfs_iunlock(ip, lockflags);\r\nreturn error;\r\n}\r\n}\r\nif ((flags & XFS_QMOPT_UQUOTA) && XFS_IS_UQUOTA_ON(mp)) {\r\nif (ip->i_d.di_uid != uid) {\r\nxfs_iunlock(ip, lockflags);\r\nerror = xfs_qm_dqget(mp, NULL, uid,\r\nXFS_DQ_USER,\r\nXFS_QMOPT_DQALLOC |\r\nXFS_QMOPT_DOWARN,\r\n&uq);\r\nif (error) {\r\nASSERT(error != -ENOENT);\r\nreturn error;\r\n}\r\nxfs_dqunlock(uq);\r\nlockflags = XFS_ILOCK_SHARED;\r\nxfs_ilock(ip, lockflags);\r\n} else {\r\nASSERT(ip->i_udquot);\r\nuq = xfs_qm_dqhold(ip->i_udquot);\r\n}\r\n}\r\nif ((flags & XFS_QMOPT_GQUOTA) && XFS_IS_GQUOTA_ON(mp)) {\r\nif (ip->i_d.di_gid != gid) {\r\nxfs_iunlock(ip, lockflags);\r\nerror = xfs_qm_dqget(mp, NULL, gid,\r\nXFS_DQ_GROUP,\r\nXFS_QMOPT_DQALLOC |\r\nXFS_QMOPT_DOWARN,\r\n&gq);\r\nif (error) {\r\nASSERT(error != -ENOENT);\r\ngoto error_rele;\r\n}\r\nxfs_dqunlock(gq);\r\nlockflags = XFS_ILOCK_SHARED;\r\nxfs_ilock(ip, lockflags);\r\n} else {\r\nASSERT(ip->i_gdquot);\r\ngq = xfs_qm_dqhold(ip->i_gdquot);\r\n}\r\n}\r\nif ((flags & XFS_QMOPT_PQUOTA) && XFS_IS_PQUOTA_ON(mp)) {\r\nif (xfs_get_projid(ip) != prid) {\r\nxfs_iunlock(ip, lockflags);\r\nerror = xfs_qm_dqget(mp, NULL, (xfs_dqid_t)prid,\r\nXFS_DQ_PROJ,\r\nXFS_QMOPT_DQALLOC |\r\nXFS_QMOPT_DOWARN,\r\n&pq);\r\nif (error) {\r\nASSERT(error != -ENOENT);\r\ngoto error_rele;\r\n}\r\nxfs_dqunlock(pq);\r\nlockflags = XFS_ILOCK_SHARED;\r\nxfs_ilock(ip, lockflags);\r\n} else {\r\nASSERT(ip->i_pdquot);\r\npq = xfs_qm_dqhold(ip->i_pdquot);\r\n}\r\n}\r\nif (uq)\r\ntrace_xfs_dquot_dqalloc(ip);\r\nxfs_iunlock(ip, lockflags);\r\nif (O_udqpp)\r\n*O_udqpp = uq;\r\nelse\r\nxfs_qm_dqrele(uq);\r\nif (O_gdqpp)\r\n*O_gdqpp = gq;\r\nelse\r\nxfs_qm_dqrele(gq);\r\nif (O_pdqpp)\r\n*O_pdqpp = pq;\r\nelse\r\nxfs_qm_dqrele(pq);\r\nreturn 0;\r\nerror_rele:\r\nxfs_qm_dqrele(gq);\r\nxfs_qm_dqrele(uq);\r\nreturn error;\r\n}\r\nxfs_dquot_t *\r\nxfs_qm_vop_chown(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip,\r\nxfs_dquot_t **IO_olddq,\r\nxfs_dquot_t *newdq)\r\n{\r\nxfs_dquot_t *prevdq;\r\nuint bfield = XFS_IS_REALTIME_INODE(ip) ?\r\nXFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\r\nprevdq = *IO_olddq;\r\nASSERT(prevdq);\r\nASSERT(prevdq != newdq);\r\nxfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\r\nxfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\r\nxfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\r\nxfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\r\n*IO_olddq = xfs_qm_dqhold(newdq);\r\nreturn prevdq;\r\n}\r\nint\r\nxfs_qm_vop_chown_reserve(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *ip,\r\nstruct xfs_dquot *udqp,\r\nstruct xfs_dquot *gdqp,\r\nstruct xfs_dquot *pdqp,\r\nuint flags)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nuint delblks, blkflags, prjflags = 0;\r\nstruct xfs_dquot *udq_unres = NULL;\r\nstruct xfs_dquot *gdq_unres = NULL;\r\nstruct xfs_dquot *pdq_unres = NULL;\r\nstruct xfs_dquot *udq_delblks = NULL;\r\nstruct xfs_dquot *gdq_delblks = NULL;\r\nstruct xfs_dquot *pdq_delblks = NULL;\r\nint error;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\ndelblks = ip->i_delayed_blks;\r\nblkflags = XFS_IS_REALTIME_INODE(ip) ?\r\nXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\r\nif (XFS_IS_UQUOTA_ON(mp) && udqp &&\r\nip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\r\nudq_delblks = udqp;\r\nif (delblks) {\r\nASSERT(ip->i_udquot);\r\nudq_unres = ip->i_udquot;\r\n}\r\n}\r\nif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\r\nip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\r\ngdq_delblks = gdqp;\r\nif (delblks) {\r\nASSERT(ip->i_gdquot);\r\ngdq_unres = ip->i_gdquot;\r\n}\r\n}\r\nif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\r\nxfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\r\nprjflags = XFS_QMOPT_ENOSPC;\r\npdq_delblks = pdqp;\r\nif (delblks) {\r\nASSERT(ip->i_pdquot);\r\npdq_unres = ip->i_pdquot;\r\n}\r\n}\r\nerror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\r\nudq_delblks, gdq_delblks, pdq_delblks,\r\nip->i_d.di_nblocks, 1,\r\nflags | blkflags | prjflags);\r\nif (error)\r\nreturn error;\r\nif (delblks) {\r\nASSERT(udq_delblks || gdq_delblks || pdq_delblks);\r\nASSERT(udq_unres || gdq_unres || pdq_unres);\r\nerror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\r\nudq_delblks, gdq_delblks, pdq_delblks,\r\n(xfs_qcnt_t)delblks, 0,\r\nflags | blkflags | prjflags);\r\nif (error)\r\nreturn error;\r\nxfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\r\nudq_unres, gdq_unres, pdq_unres,\r\n-((xfs_qcnt_t)delblks), 0, blkflags);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_qm_vop_rename_dqattach(\r\nstruct xfs_inode **i_tab)\r\n{\r\nstruct xfs_mount *mp = i_tab[0]->i_mount;\r\nint i;\r\nif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\r\nreturn 0;\r\nfor (i = 0; (i < 4 && i_tab[i]); i++) {\r\nstruct xfs_inode *ip = i_tab[i];\r\nint error;\r\nif (i == 0 || ip != i_tab[i-1]) {\r\nif (XFS_NOT_DQATTACHED(mp, ip)) {\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_vop_create_dqattach(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *ip,\r\nstruct xfs_dquot *udqp,\r\nstruct xfs_dquot *gdqp,\r\nstruct xfs_dquot *pdqp)\r\n{\r\nstruct xfs_mount *mp = tp->t_mountp;\r\nif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\r\nreturn;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nASSERT(XFS_IS_QUOTA_RUNNING(mp));\r\nif (udqp && XFS_IS_UQUOTA_ON(mp)) {\r\nASSERT(ip->i_udquot == NULL);\r\nASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\r\nip->i_udquot = xfs_qm_dqhold(udqp);\r\nxfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\r\n}\r\nif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\r\nASSERT(ip->i_gdquot == NULL);\r\nASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\r\nip->i_gdquot = xfs_qm_dqhold(gdqp);\r\nxfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\r\n}\r\nif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\r\nASSERT(ip->i_pdquot == NULL);\r\nASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\r\nip->i_pdquot = xfs_qm_dqhold(pdqp);\r\nxfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\r\n}\r\n}
