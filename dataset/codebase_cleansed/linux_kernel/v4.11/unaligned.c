static void fixup_load(struct disasm_state *state, struct pt_regs *regs,\r\nstruct callee_regs *cregs)\r\n{\r\nint val;\r\nif ((state->aa == 1) || (state->aa == 2)) {\r\nset_reg(state->wb_reg, state->src1 + state->src2, regs, cregs);\r\nif (state->aa == 2)\r\nstate->src2 = 0;\r\n}\r\nif (state->zz == 0) {\r\nget32_unaligned_check(val, state->src1 + state->src2);\r\n} else {\r\nget16_unaligned_check(val, state->src1 + state->src2);\r\nif (state->x)\r\nval = (val << 16) >> 16;\r\n}\r\nif (state->pref == 0)\r\nset_reg(state->dest, val, regs, cregs);\r\nreturn;\r\nfault: state->fault = 1;\r\n}\r\nstatic void fixup_store(struct disasm_state *state, struct pt_regs *regs,\r\nstruct callee_regs *cregs)\r\n{\r\nif ((state->aa == 1) || (state->aa == 2)) {\r\nset_reg(state->wb_reg, state->src2 + state->src3, regs, cregs);\r\nif (state->aa == 3)\r\nstate->src3 = 0;\r\n} else if (state->aa == 3) {\r\nif (state->zz == 2) {\r\nset_reg(state->wb_reg, state->src2 + (state->src3 << 1),\r\nregs, cregs);\r\n} else if (!state->zz) {\r\nset_reg(state->wb_reg, state->src2 + (state->src3 << 2),\r\nregs, cregs);\r\n} else {\r\ngoto fault;\r\n}\r\n}\r\nif (!state->zz)\r\nput32_unaligned_check(state->src1, state->src2 + state->src3);\r\nelse\r\nput16_unaligned_check(state->src1, state->src2 + state->src3);\r\nreturn;\r\nfault: state->fault = 1;\r\n}\r\nint misaligned_fixup(unsigned long address, struct pt_regs *regs,\r\nstruct callee_regs *cregs)\r\n{\r\nstruct disasm_state state;\r\nchar buf[TASK_COMM_LEN];\r\nif (!user_mode(regs) || !unaligned_enabled)\r\nreturn 1;\r\nif (no_unaligned_warning) {\r\npr_warn_once("%s(%d) made unaligned access which was emulated"\r\n" by kernel assist\n. This can degrade application"\r\n" performance significantly\n. To enable further"\r\n" logging of such instances, please \n"\r\n" echo 0 > /proc/sys/kernel/ignore-unaligned-usertrap\n",\r\nget_task_comm(buf, current), task_pid_nr(current));\r\n} else {\r\npr_warn("%s(%d): unaligned access to/from 0x%lx by PC: 0x%lx\n",\r\nget_task_comm(buf, current), task_pid_nr(current),\r\naddress, regs->ret);\r\n}\r\ndisasm_instr(regs->ret, &state, 1, regs, cregs);\r\nif (state.fault)\r\ngoto fault;\r\nif ((state.zz == 1) || (state.di))\r\ngoto fault;\r\nif (!state.write)\r\nfixup_load(&state, regs, cregs);\r\nelse\r\nfixup_store(&state, regs, cregs);\r\nif (state.fault)\r\ngoto fault;\r\nif (delay_mode(regs)) {\r\nregs->ret = regs->bta & ~1U;\r\nregs->status32 &= ~STATUS_DE_MASK;\r\n} else {\r\nregs->ret += state.instr_len;\r\nif ((regs->ret == regs->lp_end) && (regs->lp_count)) {\r\nregs->ret = regs->lp_start;\r\nregs->lp_count--;\r\n}\r\n}\r\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\r\nreturn 0;\r\nfault:\r\npr_err("Alignment trap: fault in fix-up %08lx at [<%08lx>]\n",\r\nstate.words[0], address);\r\nreturn 1;\r\n}
