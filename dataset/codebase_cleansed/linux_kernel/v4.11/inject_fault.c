static void prepare_fault32(struct kvm_vcpu *vcpu, u32 mode, u32 vect_offset)\r\n{\r\nunsigned long cpsr;\r\nunsigned long new_spsr_value = *vcpu_cpsr(vcpu);\r\nbool is_thumb = (new_spsr_value & COMPAT_PSR_T_BIT);\r\nu32 return_offset = (is_thumb) ? 4 : 0;\r\nu32 sctlr = vcpu_cp15(vcpu, c1_SCTLR);\r\ncpsr = mode | COMPAT_PSR_I_BIT;\r\nif (sctlr & (1 << 30))\r\ncpsr |= COMPAT_PSR_T_BIT;\r\nif (sctlr & (1 << 25))\r\ncpsr |= COMPAT_PSR_E_BIT;\r\n*vcpu_cpsr(vcpu) = cpsr;\r\n*vcpu_spsr(vcpu) = new_spsr_value;\r\n*vcpu_reg32(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;\r\nif (sctlr & (1 << 13))\r\nvect_offset += 0xffff0000;\r\nelse\r\nvect_offset += vcpu_cp15(vcpu, c12_VBAR);\r\n*vcpu_pc(vcpu) = vect_offset;\r\n}\r\nstatic void inject_undef32(struct kvm_vcpu *vcpu)\r\n{\r\nprepare_fault32(vcpu, COMPAT_PSR_MODE_UND, 4);\r\n}\r\nstatic void inject_abt32(struct kvm_vcpu *vcpu, bool is_pabt,\r\nunsigned long addr)\r\n{\r\nu32 vect_offset;\r\nu32 *far, *fsr;\r\nbool is_lpae;\r\nif (is_pabt) {\r\nvect_offset = 12;\r\nfar = &vcpu_cp15(vcpu, c6_IFAR);\r\nfsr = &vcpu_cp15(vcpu, c5_IFSR);\r\n} else {\r\nvect_offset = 16;\r\nfar = &vcpu_cp15(vcpu, c6_DFAR);\r\nfsr = &vcpu_cp15(vcpu, c5_DFSR);\r\n}\r\nprepare_fault32(vcpu, COMPAT_PSR_MODE_ABT | COMPAT_PSR_A_BIT, vect_offset);\r\n*far = addr;\r\nis_lpae = (vcpu_cp15(vcpu, c2_TTBCR) >> 31);\r\nif (is_lpae)\r\n*fsr = 1 << 9 | 0x34;\r\nelse\r\n*fsr = 0x14;\r\n}\r\nstatic u64 get_except_vector(struct kvm_vcpu *vcpu, enum exception_type type)\r\n{\r\nu64 exc_offset;\r\nswitch (*vcpu_cpsr(vcpu) & (PSR_MODE_MASK | PSR_MODE32_BIT)) {\r\ncase PSR_MODE_EL1t:\r\nexc_offset = CURRENT_EL_SP_EL0_VECTOR;\r\nbreak;\r\ncase PSR_MODE_EL1h:\r\nexc_offset = CURRENT_EL_SP_ELx_VECTOR;\r\nbreak;\r\ncase PSR_MODE_EL0t:\r\nexc_offset = LOWER_EL_AArch64_VECTOR;\r\nbreak;\r\ndefault:\r\nexc_offset = LOWER_EL_AArch32_VECTOR;\r\n}\r\nreturn vcpu_sys_reg(vcpu, VBAR_EL1) + exc_offset + type;\r\n}\r\nstatic void inject_abt64(struct kvm_vcpu *vcpu, bool is_iabt, unsigned long addr)\r\n{\r\nunsigned long cpsr = *vcpu_cpsr(vcpu);\r\nbool is_aarch32 = vcpu_mode_is_32bit(vcpu);\r\nu32 esr = 0;\r\n*vcpu_elr_el1(vcpu) = *vcpu_pc(vcpu);\r\n*vcpu_pc(vcpu) = get_except_vector(vcpu, except_type_sync);\r\n*vcpu_cpsr(vcpu) = PSTATE_FAULT_BITS_64;\r\n*vcpu_spsr(vcpu) = cpsr;\r\nvcpu_sys_reg(vcpu, FAR_EL1) = addr;\r\nif (kvm_vcpu_trap_il_is32bit(vcpu))\r\nesr |= ESR_ELx_IL;\r\nif (is_aarch32 || (cpsr & PSR_MODE_MASK) == PSR_MODE_EL0t)\r\nesr |= (ESR_ELx_EC_IABT_LOW << ESR_ELx_EC_SHIFT);\r\nelse\r\nesr |= (ESR_ELx_EC_IABT_CUR << ESR_ELx_EC_SHIFT);\r\nif (!is_iabt)\r\nesr |= ESR_ELx_EC_DABT_LOW << ESR_ELx_EC_SHIFT;\r\nvcpu_sys_reg(vcpu, ESR_EL1) = esr | ESR_ELx_FSC_EXTABT;\r\n}\r\nstatic void inject_undef64(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long cpsr = *vcpu_cpsr(vcpu);\r\nu32 esr = (ESR_ELx_EC_UNKNOWN << ESR_ELx_EC_SHIFT);\r\n*vcpu_elr_el1(vcpu) = *vcpu_pc(vcpu);\r\n*vcpu_pc(vcpu) = get_except_vector(vcpu, except_type_sync);\r\n*vcpu_cpsr(vcpu) = PSTATE_FAULT_BITS_64;\r\n*vcpu_spsr(vcpu) = cpsr;\r\nif (kvm_vcpu_trap_il_is32bit(vcpu))\r\nesr |= ESR_ELx_IL;\r\nvcpu_sys_reg(vcpu, ESR_EL1) = esr;\r\n}\r\nvoid kvm_inject_dabt(struct kvm_vcpu *vcpu, unsigned long addr)\r\n{\r\nif (!(vcpu->arch.hcr_el2 & HCR_RW))\r\ninject_abt32(vcpu, false, addr);\r\nelse\r\ninject_abt64(vcpu, false, addr);\r\n}\r\nvoid kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr)\r\n{\r\nif (!(vcpu->arch.hcr_el2 & HCR_RW))\r\ninject_abt32(vcpu, true, addr);\r\nelse\r\ninject_abt64(vcpu, true, addr);\r\n}\r\nvoid kvm_inject_undefined(struct kvm_vcpu *vcpu)\r\n{\r\nif (!(vcpu->arch.hcr_el2 & HCR_RW))\r\ninject_undef32(vcpu);\r\nelse\r\ninject_undef64(vcpu);\r\n}\r\nvoid kvm_inject_vabt(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu_set_hcr(vcpu, vcpu_get_hcr(vcpu) | HCR_VSE);\r\n}
