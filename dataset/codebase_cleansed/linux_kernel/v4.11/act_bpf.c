static int tcf_bpf(struct sk_buff *skb, const struct tc_action *act,\r\nstruct tcf_result *res)\r\n{\r\nbool at_ingress = skb_at_tc_ingress(skb);\r\nstruct tcf_bpf *prog = to_bpf(act);\r\nstruct bpf_prog *filter;\r\nint action, filter_res;\r\ntcf_lastuse_update(&prog->tcf_tm);\r\nbstats_cpu_update(this_cpu_ptr(prog->common.cpu_bstats), skb);\r\nrcu_read_lock();\r\nfilter = rcu_dereference(prog->filter);\r\nif (at_ingress) {\r\n__skb_push(skb, skb->mac_len);\r\nbpf_compute_data_end(skb);\r\nfilter_res = BPF_PROG_RUN(filter, skb);\r\n__skb_pull(skb, skb->mac_len);\r\n} else {\r\nbpf_compute_data_end(skb);\r\nfilter_res = BPF_PROG_RUN(filter, skb);\r\n}\r\nrcu_read_unlock();\r\nswitch (filter_res) {\r\ncase TC_ACT_PIPE:\r\ncase TC_ACT_RECLASSIFY:\r\ncase TC_ACT_OK:\r\ncase TC_ACT_REDIRECT:\r\naction = filter_res;\r\nbreak;\r\ncase TC_ACT_SHOT:\r\naction = filter_res;\r\nqstats_drop_inc(this_cpu_ptr(prog->common.cpu_qstats));\r\nbreak;\r\ncase TC_ACT_UNSPEC:\r\naction = prog->tcf_action;\r\nbreak;\r\ndefault:\r\naction = TC_ACT_UNSPEC;\r\nbreak;\r\n}\r\nreturn action;\r\n}\r\nstatic bool tcf_bpf_is_ebpf(const struct tcf_bpf *prog)\r\n{\r\nreturn !prog->bpf_ops;\r\n}\r\nstatic int tcf_bpf_dump_bpf_info(const struct tcf_bpf *prog,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nlattr *nla;\r\nif (nla_put_u16(skb, TCA_ACT_BPF_OPS_LEN, prog->bpf_num_ops))\r\nreturn -EMSGSIZE;\r\nnla = nla_reserve(skb, TCA_ACT_BPF_OPS, prog->bpf_num_ops *\r\nsizeof(struct sock_filter));\r\nif (nla == NULL)\r\nreturn -EMSGSIZE;\r\nmemcpy(nla_data(nla), prog->bpf_ops, nla_len(nla));\r\nreturn 0;\r\n}\r\nstatic int tcf_bpf_dump_ebpf_info(const struct tcf_bpf *prog,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nlattr *nla;\r\nif (prog->bpf_name &&\r\nnla_put_string(skb, TCA_ACT_BPF_NAME, prog->bpf_name))\r\nreturn -EMSGSIZE;\r\nnla = nla_reserve(skb, TCA_ACT_BPF_TAG, sizeof(prog->filter->tag));\r\nif (nla == NULL)\r\nreturn -EMSGSIZE;\r\nmemcpy(nla_data(nla), prog->filter->tag, nla_len(nla));\r\nreturn 0;\r\n}\r\nstatic int tcf_bpf_dump(struct sk_buff *skb, struct tc_action *act,\r\nint bind, int ref)\r\n{\r\nunsigned char *tp = skb_tail_pointer(skb);\r\nstruct tcf_bpf *prog = to_bpf(act);\r\nstruct tc_act_bpf opt = {\r\n.index = prog->tcf_index,\r\n.refcnt = prog->tcf_refcnt - ref,\r\n.bindcnt = prog->tcf_bindcnt - bind,\r\n.action = prog->tcf_action,\r\n};\r\nstruct tcf_t tm;\r\nint ret;\r\nif (nla_put(skb, TCA_ACT_BPF_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nif (tcf_bpf_is_ebpf(prog))\r\nret = tcf_bpf_dump_ebpf_info(prog, skb);\r\nelse\r\nret = tcf_bpf_dump_bpf_info(prog, skb);\r\nif (ret)\r\ngoto nla_put_failure;\r\ntcf_tm_dump(&tm, &prog->tcf_tm);\r\nif (nla_put_64bit(skb, TCA_ACT_BPF_TM, sizeof(tm), &tm,\r\nTCA_ACT_BPF_PAD))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, tp);\r\nreturn -1;\r\n}\r\nstatic int tcf_bpf_init_from_ops(struct nlattr **tb, struct tcf_bpf_cfg *cfg)\r\n{\r\nstruct sock_filter *bpf_ops;\r\nstruct sock_fprog_kern fprog_tmp;\r\nstruct bpf_prog *fp;\r\nu16 bpf_size, bpf_num_ops;\r\nint ret;\r\nbpf_num_ops = nla_get_u16(tb[TCA_ACT_BPF_OPS_LEN]);\r\nif (bpf_num_ops > BPF_MAXINSNS || bpf_num_ops == 0)\r\nreturn -EINVAL;\r\nbpf_size = bpf_num_ops * sizeof(*bpf_ops);\r\nif (bpf_size != nla_len(tb[TCA_ACT_BPF_OPS]))\r\nreturn -EINVAL;\r\nbpf_ops = kzalloc(bpf_size, GFP_KERNEL);\r\nif (bpf_ops == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(bpf_ops, nla_data(tb[TCA_ACT_BPF_OPS]), bpf_size);\r\nfprog_tmp.len = bpf_num_ops;\r\nfprog_tmp.filter = bpf_ops;\r\nret = bpf_prog_create(&fp, &fprog_tmp);\r\nif (ret < 0) {\r\nkfree(bpf_ops);\r\nreturn ret;\r\n}\r\ncfg->bpf_ops = bpf_ops;\r\ncfg->bpf_num_ops = bpf_num_ops;\r\ncfg->filter = fp;\r\ncfg->is_ebpf = false;\r\nreturn 0;\r\n}\r\nstatic int tcf_bpf_init_from_efd(struct nlattr **tb, struct tcf_bpf_cfg *cfg)\r\n{\r\nstruct bpf_prog *fp;\r\nchar *name = NULL;\r\nu32 bpf_fd;\r\nbpf_fd = nla_get_u32(tb[TCA_ACT_BPF_FD]);\r\nfp = bpf_prog_get_type(bpf_fd, BPF_PROG_TYPE_SCHED_ACT);\r\nif (IS_ERR(fp))\r\nreturn PTR_ERR(fp);\r\nif (tb[TCA_ACT_BPF_NAME]) {\r\nname = nla_memdup(tb[TCA_ACT_BPF_NAME], GFP_KERNEL);\r\nif (!name) {\r\nbpf_prog_put(fp);\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncfg->bpf_name = name;\r\ncfg->filter = fp;\r\ncfg->is_ebpf = true;\r\nreturn 0;\r\n}\r\nstatic void tcf_bpf_cfg_cleanup(const struct tcf_bpf_cfg *cfg)\r\n{\r\nif (cfg->is_ebpf)\r\nbpf_prog_put(cfg->filter);\r\nelse\r\nbpf_prog_destroy(cfg->filter);\r\nkfree(cfg->bpf_ops);\r\nkfree(cfg->bpf_name);\r\n}\r\nstatic void tcf_bpf_prog_fill_cfg(const struct tcf_bpf *prog,\r\nstruct tcf_bpf_cfg *cfg)\r\n{\r\ncfg->is_ebpf = tcf_bpf_is_ebpf(prog);\r\ncfg->filter = rcu_dereference_protected(prog->filter, 1);\r\ncfg->bpf_ops = prog->bpf_ops;\r\ncfg->bpf_name = prog->bpf_name;\r\n}\r\nstatic int tcf_bpf_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action **act,\r\nint replace, int bind)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, bpf_net_id);\r\nstruct nlattr *tb[TCA_ACT_BPF_MAX + 1];\r\nstruct tcf_bpf_cfg cfg, old;\r\nstruct tc_act_bpf *parm;\r\nstruct tcf_bpf *prog;\r\nbool is_bpf, is_ebpf;\r\nint ret, res = 0;\r\nif (!nla)\r\nreturn -EINVAL;\r\nret = nla_parse_nested(tb, TCA_ACT_BPF_MAX, nla, act_bpf_policy);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!tb[TCA_ACT_BPF_PARMS])\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_ACT_BPF_PARMS]);\r\nif (!tcf_hash_check(tn, parm->index, act, bind)) {\r\nret = tcf_hash_create(tn, parm->index, est, act,\r\n&act_bpf_ops, bind, true);\r\nif (ret < 0)\r\nreturn ret;\r\nres = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(*act, bind);\r\nif (!replace)\r\nreturn -EEXIST;\r\n}\r\nis_bpf = tb[TCA_ACT_BPF_OPS_LEN] && tb[TCA_ACT_BPF_OPS];\r\nis_ebpf = tb[TCA_ACT_BPF_FD];\r\nif ((!is_bpf && !is_ebpf) || (is_bpf && is_ebpf)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\nret = is_bpf ? tcf_bpf_init_from_ops(tb, &cfg) :\r\ntcf_bpf_init_from_efd(tb, &cfg);\r\nif (ret < 0)\r\ngoto out;\r\nprog = to_bpf(*act);\r\nASSERT_RTNL();\r\nif (res != ACT_P_CREATED)\r\ntcf_bpf_prog_fill_cfg(prog, &old);\r\nprog->bpf_ops = cfg.bpf_ops;\r\nprog->bpf_name = cfg.bpf_name;\r\nif (cfg.bpf_num_ops)\r\nprog->bpf_num_ops = cfg.bpf_num_ops;\r\nprog->tcf_action = parm->action;\r\nrcu_assign_pointer(prog->filter, cfg.filter);\r\nif (res == ACT_P_CREATED) {\r\ntcf_hash_insert(tn, *act);\r\n} else {\r\nsynchronize_rcu();\r\ntcf_bpf_cfg_cleanup(&old);\r\n}\r\nreturn res;\r\nout:\r\nif (res == ACT_P_CREATED)\r\ntcf_hash_cleanup(*act, est);\r\nreturn ret;\r\n}\r\nstatic void tcf_bpf_cleanup(struct tc_action *act, int bind)\r\n{\r\nstruct tcf_bpf_cfg tmp;\r\ntcf_bpf_prog_fill_cfg(to_bpf(act), &tmp);\r\ntcf_bpf_cfg_cleanup(&tmp);\r\n}\r\nstatic int tcf_bpf_walker(struct net *net, struct sk_buff *skb,\r\nstruct netlink_callback *cb, int type,\r\nconst struct tc_action_ops *ops)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, bpf_net_id);\r\nreturn tcf_generic_walker(tn, skb, cb, type, ops);\r\n}\r\nstatic int tcf_bpf_search(struct net *net, struct tc_action **a, u32 index)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, bpf_net_id);\r\nreturn tcf_hash_search(tn, a, index);\r\n}\r\nstatic __net_init int bpf_init_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, bpf_net_id);\r\nreturn tc_action_net_init(tn, &act_bpf_ops, BPF_TAB_MASK);\r\n}\r\nstatic void __net_exit bpf_exit_net(struct net *net)\r\n{\r\nstruct tc_action_net *tn = net_generic(net, bpf_net_id);\r\ntc_action_net_exit(tn);\r\n}\r\nstatic int __init bpf_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_bpf_ops, &bpf_net_ops);\r\n}\r\nstatic void __exit bpf_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_bpf_ops, &bpf_net_ops);\r\n}
