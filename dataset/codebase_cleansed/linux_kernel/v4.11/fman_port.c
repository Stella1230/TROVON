static int init_bmi_rx(struct fman_port *port)\r\n{\r\nstruct fman_port_rx_bmi_regs __iomem *regs = &port->bmi_regs->rx;\r\nstruct fman_port_cfg *cfg = port->cfg;\r\nu32 tmp;\r\ntmp = (u32)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;\r\ntmp |= BMI_DMA_ATTR_WRITE_OPTIMIZE;\r\niowrite32be(tmp, &regs->fmbm_rda);\r\ntmp = (cfg->rx_pri_elevation / PORT_BMI_FIFO_UNITS - 1) <<\r\nBMI_RX_FIFO_PRI_ELEVATION_SHIFT;\r\ntmp |= cfg->rx_fifo_thr / PORT_BMI_FIFO_UNITS - 1;\r\niowrite32be(tmp, &regs->fmbm_rfp);\r\nif (cfg->excessive_threshold_register)\r\niowrite32be(BMI_RX_FIFO_THRESHOLD_ETHE, &regs->fmbm_reth);\r\ntmp = (cfg->cheksum_last_bytes_ignore & BMI_FRAME_END_CS_IGNORE_MASK) <<\r\nBMI_FRAME_END_CS_IGNORE_SHIFT;\r\ntmp |= (cfg->rx_cut_end_bytes & BMI_RX_FRAME_END_CUT_MASK) <<\r\nBMI_RX_FRAME_END_CUT_SHIFT;\r\nif (cfg->errata_A006320)\r\ntmp &= 0xffe0ffff;\r\niowrite32be(tmp, &regs->fmbm_rfed);\r\ntmp = ((cfg->int_context.ext_buf_offset / PORT_IC_OFFSET_UNITS) &\r\nBMI_IC_TO_EXT_MASK) << BMI_IC_TO_EXT_SHIFT;\r\ntmp |= ((cfg->int_context.int_context_offset / PORT_IC_OFFSET_UNITS) &\r\nBMI_IC_FROM_INT_MASK) << BMI_IC_FROM_INT_SHIFT;\r\ntmp |= (cfg->int_context.size / PORT_IC_OFFSET_UNITS) &\r\nBMI_IC_SIZE_MASK;\r\niowrite32be(tmp, &regs->fmbm_ricp);\r\ntmp = ((cfg->int_buf_start_margin / PORT_IC_OFFSET_UNITS) &\r\nBMI_INT_BUF_MARG_MASK) << BMI_INT_BUF_MARG_SHIFT;\r\niowrite32be(tmp, &regs->fmbm_rim);\r\ntmp = (cfg->buf_margins.start_margins & BMI_EXT_BUF_MARG_START_MASK) <<\r\nBMI_EXT_BUF_MARG_START_SHIFT;\r\ntmp |= cfg->buf_margins.end_margins & BMI_EXT_BUF_MARG_END_MASK;\r\niowrite32be(tmp, &regs->fmbm_rebm);\r\ntmp = BMI_CMD_RX_MR_DEF;\r\ntmp |= BMI_CMD_ATTR_ORDER;\r\ntmp |= (u32)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;\r\ntmp |= BMI_CMD_ATTR_SYNC;\r\niowrite32be(tmp, &regs->fmbm_rfca);\r\ntmp = (u32)cfg->rx_fd_bits << BMI_NEXT_ENG_FD_BITS_SHIFT;\r\ntmp |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;\r\niowrite32be(tmp, &regs->fmbm_rfne);\r\niowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR, &regs->fmbm_rfene);\r\niowrite32be((cfg->dflt_fqid & DFLT_FQ_ID), &regs->fmbm_rfqid);\r\niowrite32be((cfg->err_fqid & DFLT_FQ_ID), &regs->fmbm_refqid);\r\niowrite32be(cfg->discard_mask, &regs->fmbm_rfsdm);\r\niowrite32be(cfg->err_mask, &regs->fmbm_rfsem);\r\nreturn 0;\r\n}\r\nstatic int init_bmi_tx(struct fman_port *port)\r\n{\r\nstruct fman_port_tx_bmi_regs __iomem *regs = &port->bmi_regs->tx;\r\nstruct fman_port_cfg *cfg = port->cfg;\r\nu32 tmp;\r\ntmp = 0;\r\niowrite32be(tmp, &regs->fmbm_tcfg);\r\ntmp = (u32)cfg->dma_swap_data << BMI_DMA_ATTR_SWP_SHIFT;\r\niowrite32be(tmp, &regs->fmbm_tda);\r\ntmp = (cfg->tx_fifo_min_level / PORT_BMI_FIFO_UNITS) <<\r\nBMI_TX_FIFO_MIN_FILL_SHIFT;\r\ntmp |= ((cfg->tx_fifo_deq_pipeline_depth - 1) &\r\nBMI_FIFO_PIPELINE_DEPTH_MASK) << BMI_FIFO_PIPELINE_DEPTH_SHIFT;\r\ntmp |= (cfg->tx_fifo_low_comf_level / PORT_BMI_FIFO_UNITS) - 1;\r\niowrite32be(tmp, &regs->fmbm_tfp);\r\ntmp = (cfg->cheksum_last_bytes_ignore & BMI_FRAME_END_CS_IGNORE_MASK) <<\r\nBMI_FRAME_END_CS_IGNORE_SHIFT;\r\niowrite32be(tmp, &regs->fmbm_tfed);\r\ntmp = ((cfg->int_context.ext_buf_offset / PORT_IC_OFFSET_UNITS) &\r\nBMI_IC_TO_EXT_MASK) << BMI_IC_TO_EXT_SHIFT;\r\ntmp |= ((cfg->int_context.int_context_offset / PORT_IC_OFFSET_UNITS) &\r\nBMI_IC_FROM_INT_MASK) << BMI_IC_FROM_INT_SHIFT;\r\ntmp |= (cfg->int_context.size / PORT_IC_OFFSET_UNITS) &\r\nBMI_IC_SIZE_MASK;\r\niowrite32be(tmp, &regs->fmbm_ticp);\r\ntmp = BMI_CMD_TX_MR_DEF;\r\ntmp |= BMI_CMD_ATTR_ORDER;\r\ntmp |= (u32)cfg->color << BMI_CMD_ATTR_COLOR_SHIFT;\r\niowrite32be(tmp, &regs->fmbm_tfca);\r\niowrite32be(NIA_ENG_QMI_DEQ, &regs->fmbm_tfdne);\r\niowrite32be(NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR, &regs->fmbm_tfene);\r\nif (cfg->fmbm_tfne_has_features)\r\niowrite32be(!cfg->dflt_fqid ?\r\nBMI_EBD_EN | NIA_BMI_AC_FETCH_ALL_FRAME :\r\nNIA_BMI_AC_FETCH_ALL_FRAME, &regs->fmbm_tfne);\r\nif (!cfg->dflt_fqid && cfg->dont_release_buf) {\r\niowrite32be(DFLT_FQ_ID, &regs->fmbm_tcfqid);\r\niowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,\r\n&regs->fmbm_tfene);\r\nif (cfg->fmbm_tfne_has_features)\r\niowrite32be(ioread32be(&regs->fmbm_tfne) & ~BMI_EBD_EN,\r\n&regs->fmbm_tfne);\r\n}\r\nif (cfg->dflt_fqid || !cfg->dont_release_buf)\r\niowrite32be(cfg->dflt_fqid & DFLT_FQ_ID, &regs->fmbm_tcfqid);\r\niowrite32be((cfg->err_fqid & DFLT_FQ_ID), &regs->fmbm_tefqid);\r\nreturn 0;\r\n}\r\nstatic int init_qmi(struct fman_port *port)\r\n{\r\nstruct fman_port_qmi_regs __iomem *regs = port->qmi_regs;\r\nstruct fman_port_cfg *cfg = port->cfg;\r\nu32 tmp;\r\nif (port->port_type == FMAN_PORT_TYPE_RX) {\r\niowrite32be(NIA_ENG_BMI | NIA_BMI_AC_RELEASE, &regs->fmqm_pnen);\r\nreturn 0;\r\n}\r\nif (port->port_type == FMAN_PORT_TYPE_TX) {\r\niowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,\r\n&regs->fmqm_pnen);\r\niowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX, &regs->fmqm_pndn);\r\n}\r\ntmp = 0;\r\nif (cfg->deq_high_priority)\r\ntmp |= QMI_DEQ_CFG_PRI;\r\nswitch (cfg->deq_type) {\r\ncase FMAN_PORT_DEQ_BY_PRI:\r\ntmp |= QMI_DEQ_CFG_TYPE1;\r\nbreak;\r\ncase FMAN_PORT_DEQ_ACTIVE_FQ:\r\ntmp |= QMI_DEQ_CFG_TYPE2;\r\nbreak;\r\ncase FMAN_PORT_DEQ_ACTIVE_FQ_NO_ICS:\r\ntmp |= QMI_DEQ_CFG_TYPE3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (cfg->deq_prefetch_option) {\r\ncase FMAN_PORT_DEQ_NO_PREFETCH:\r\nbreak;\r\ncase FMAN_PORT_DEQ_PART_PREFETCH:\r\ntmp |= QMI_DEQ_CFG_PREFETCH_PARTIAL;\r\nbreak;\r\ncase FMAN_PORT_DEQ_FULL_PREFETCH:\r\ntmp |= QMI_DEQ_CFG_PREFETCH_FULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntmp |= (cfg->deq_sp & QMI_DEQ_CFG_SP_MASK) << QMI_DEQ_CFG_SP_SHIFT;\r\ntmp |= cfg->deq_byte_cnt;\r\niowrite32be(tmp, &regs->fmqm_pndc);\r\nreturn 0;\r\n}\r\nstatic int init(struct fman_port *port)\r\n{\r\nint err;\r\nswitch (port->port_type) {\r\ncase FMAN_PORT_TYPE_RX:\r\nerr = init_bmi_rx(port);\r\nbreak;\r\ncase FMAN_PORT_TYPE_TX:\r\nerr = init_bmi_tx(port);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (err)\r\nreturn err;\r\nerr = init_qmi(port);\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int set_bpools(const struct fman_port *port,\r\nconst struct fman_port_bpools *bp)\r\n{\r\nu32 __iomem *bp_reg, *bp_depl_reg;\r\nu32 tmp;\r\nu8 i, max_bp_num;\r\nbool grp_depl_used = false, rx_port;\r\nswitch (port->port_type) {\r\ncase FMAN_PORT_TYPE_RX:\r\nmax_bp_num = port->ext_pools_num;\r\nrx_port = true;\r\nbp_reg = port->bmi_regs->rx.fmbm_ebmpi;\r\nbp_depl_reg = &port->bmi_regs->rx.fmbm_mpd;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rx_port) {\r\nfor (i = 0; (i < (bp->count - 1) &&\r\n(i < FMAN_PORT_MAX_EXT_POOLS_NUM - 1)); i++) {\r\nif (bp->bpool[i].size > bp->bpool[i + 1].size)\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < bp->count; i++) {\r\ntmp = BMI_EXT_BUF_POOL_VALID;\r\ntmp |= ((u32)bp->bpool[i].bpid <<\r\nBMI_EXT_BUF_POOL_ID_SHIFT) & BMI_EXT_BUF_POOL_ID_MASK;\r\nif (rx_port) {\r\nif (bp->counters_enable)\r\ntmp |= BMI_EXT_BUF_POOL_EN_COUNTER;\r\nif (bp->bpool[i].is_backup)\r\ntmp |= BMI_EXT_BUF_POOL_BACKUP;\r\ntmp |= (u32)bp->bpool[i].size;\r\n}\r\niowrite32be(tmp, &bp_reg[i]);\r\n}\r\nfor (i = bp->count; i < max_bp_num; i++)\r\niowrite32be(0, &bp_reg[i]);\r\ntmp = 0;\r\nfor (i = 0; i < FMAN_PORT_MAX_EXT_POOLS_NUM; i++) {\r\nif (bp->bpool[i].grp_bp_depleted) {\r\ngrp_depl_used = true;\r\ntmp |= 0x80000000 >> i;\r\n}\r\nif (bp->bpool[i].single_bp_depleted)\r\ntmp |= 0x80 >> i;\r\n}\r\nif (grp_depl_used)\r\ntmp |= ((u32)bp->grp_bp_depleted_num - 1) <<\r\nBMI_POOL_DEP_NUM_OF_POOLS_SHIFT;\r\niowrite32be(tmp, bp_depl_reg);\r\nreturn 0;\r\n}\r\nstatic bool is_init_done(struct fman_port_cfg *cfg)\r\n{\r\nif (!cfg)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int verify_size_of_fifo(struct fman_port *port)\r\n{\r\nu32 min_fifo_size_required = 0, opt_fifo_size_for_b2b = 0;\r\nif (port->port_type == FMAN_PORT_TYPE_TX) {\r\nmin_fifo_size_required = (u32)\r\n(roundup(port->max_frame_length,\r\nFMAN_BMI_FIFO_UNITS) + (3 * FMAN_BMI_FIFO_UNITS));\r\nmin_fifo_size_required +=\r\nport->cfg->tx_fifo_deq_pipeline_depth *\r\nFMAN_BMI_FIFO_UNITS;\r\nopt_fifo_size_for_b2b = min_fifo_size_required;\r\nif (port->port_speed == 10000)\r\nopt_fifo_size_for_b2b += 3 * FMAN_BMI_FIFO_UNITS;\r\nelse\r\nopt_fifo_size_for_b2b += 2 * FMAN_BMI_FIFO_UNITS;\r\n}\r\nelse if (port->port_type == FMAN_PORT_TYPE_RX) {\r\nif (port->rev_info.major >= 6)\r\nmin_fifo_size_required = (u32)\r\n(roundup(port->max_frame_length,\r\nFMAN_BMI_FIFO_UNITS) +\r\n(5 * FMAN_BMI_FIFO_UNITS));\r\nelse\r\nmin_fifo_size_required = (u32)\r\n(roundup(min(port->max_frame_length,\r\nport->rx_pools_params.largest_buf_size),\r\nFMAN_BMI_FIFO_UNITS) +\r\n(7 * FMAN_BMI_FIFO_UNITS));\r\nopt_fifo_size_for_b2b = min_fifo_size_required;\r\nif (port->port_speed == 10000)\r\nopt_fifo_size_for_b2b += 8 * FMAN_BMI_FIFO_UNITS;\r\nelse\r\nopt_fifo_size_for_b2b += 3 * FMAN_BMI_FIFO_UNITS;\r\n}\r\nWARN_ON(min_fifo_size_required <= 0);\r\nWARN_ON(opt_fifo_size_for_b2b < min_fifo_size_required);\r\nif (port->fifo_bufs.num < min_fifo_size_required)\r\ndev_dbg(port->dev, "%s: FIFO size should be enlarged to %d bytes\n",\r\n__func__, min_fifo_size_required);\r\nelse if (port->fifo_bufs.num < opt_fifo_size_for_b2b)\r\ndev_dbg(port->dev, "%s: For b2b processing,FIFO may be enlarged to %d bytes\n",\r\n__func__, opt_fifo_size_for_b2b);\r\nreturn 0;\r\n}\r\nstatic int set_ext_buffer_pools(struct fman_port *port)\r\n{\r\nstruct fman_ext_pools *ext_buf_pools = &port->cfg->ext_buf_pools;\r\nstruct fman_buf_pool_depletion *buf_pool_depletion =\r\n&port->cfg->buf_pool_depletion;\r\nu8 ordered_array[FMAN_PORT_MAX_EXT_POOLS_NUM];\r\nu16 sizes_array[BM_MAX_NUM_OF_POOLS];\r\nint i = 0, j = 0, err;\r\nstruct fman_port_bpools bpools;\r\nmemset(&ordered_array, 0, sizeof(u8) * FMAN_PORT_MAX_EXT_POOLS_NUM);\r\nmemset(&sizes_array, 0, sizeof(u16) * BM_MAX_NUM_OF_POOLS);\r\nmemcpy(&port->ext_buf_pools, ext_buf_pools,\r\nsizeof(struct fman_ext_pools));\r\nfman_sp_set_buf_pools_in_asc_order_of_buf_sizes(ext_buf_pools,\r\nordered_array,\r\nsizes_array);\r\nmemset(&bpools, 0, sizeof(struct fman_port_bpools));\r\nbpools.count = ext_buf_pools->num_of_pools_used;\r\nbpools.counters_enable = true;\r\nfor (i = 0; i < ext_buf_pools->num_of_pools_used; i++) {\r\nbpools.bpool[i].bpid = ordered_array[i];\r\nbpools.bpool[i].size = sizes_array[ordered_array[i]];\r\n}\r\nport->rx_pools_params.num_of_pools = ext_buf_pools->num_of_pools_used;\r\nport->rx_pools_params.largest_buf_size =\r\nsizes_array[ordered_array[ext_buf_pools->num_of_pools_used - 1]];\r\nport->rx_pools_params.second_largest_buf_size =\r\nsizes_array[ordered_array[ext_buf_pools->num_of_pools_used - 2]];\r\nif (buf_pool_depletion->pools_grp_mode_enable) {\r\nbpools.grp_bp_depleted_num = buf_pool_depletion->num_of_pools;\r\nfor (i = 0; i < port->bm_max_num_of_pools; i++) {\r\nif (buf_pool_depletion->pools_to_consider[i]) {\r\nfor (j = 0; j < ext_buf_pools->\r\nnum_of_pools_used; j++) {\r\nif (i == ordered_array[j]) {\r\nbpools.bpool[j].\r\ngrp_bp_depleted = true;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (buf_pool_depletion->single_pool_mode_enable) {\r\nfor (i = 0; i < port->bm_max_num_of_pools; i++) {\r\nif (buf_pool_depletion->\r\npools_to_consider_for_single_mode[i]) {\r\nfor (j = 0; j < ext_buf_pools->\r\nnum_of_pools_used; j++) {\r\nif (i == ordered_array[j]) {\r\nbpools.bpool[j].\r\nsingle_bp_depleted = true;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nerr = set_bpools(port, &bpools);\r\nif (err != 0) {\r\ndev_err(port->dev, "%s: set_bpools() failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_low_level_driver(struct fman_port *port)\r\n{\r\nstruct fman_port_cfg *cfg = port->cfg;\r\nu32 tmp_val;\r\nswitch (port->port_type) {\r\ncase FMAN_PORT_TYPE_RX:\r\ncfg->err_mask = (RX_ERRS_TO_ENQ & ~cfg->discard_mask);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntmp_val = (u32)((port->internal_buf_offset % OFFSET_UNITS) ?\r\n(port->internal_buf_offset / OFFSET_UNITS + 1) :\r\n(port->internal_buf_offset / OFFSET_UNITS));\r\nport->internal_buf_offset = (u8)(tmp_val * OFFSET_UNITS);\r\nport->cfg->int_buf_start_margin = port->internal_buf_offset;\r\nif (init(port) != 0) {\r\ndev_err(port->dev, "%s: fman port initialization failed\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nif (port->port_type == FMAN_PORT_TYPE_TX) {\r\nif (!cfg->dflt_fqid && cfg->dont_release_buf) {\r\niowrite32be(0xFFFFFF, &port->bmi_regs->tx.fmbm_tcfqid);\r\niowrite32be(NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE,\r\n&port->bmi_regs->tx.fmbm_tfene);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fill_soc_specific_params(struct fman_port *port)\r\n{\r\nu32 bmi_max_fifo_size;\r\nbmi_max_fifo_size = fman_get_bmi_max_fifo_size(port->fm);\r\nport->max_port_fifo_size = MAX_PORT_FIFO_SIZE(bmi_max_fifo_size);\r\nport->bm_max_num_of_pools = 64;\r\nswitch (port->rev_info.major) {\r\ncase 2:\r\ncase 3:\r\nport->max_num_of_ext_pools = 4;\r\nport->max_num_of_sub_portals = 12;\r\nbreak;\r\ncase 6:\r\nport->max_num_of_ext_pools = 8;\r\nport->max_num_of_sub_portals = 16;\r\nbreak;\r\ndefault:\r\ndev_err(port->dev, "%s: Unsupported FMan version\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_dflt_fifo_deq_pipeline_depth(u8 major, enum fman_port_type type,\r\nu16 speed)\r\n{\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_RX:\r\ncase FMAN_PORT_TYPE_TX:\r\nswitch (speed) {\r\ncase 10000:\r\nreturn 4;\r\ncase 1000:\r\nif (major >= 6)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int get_dflt_num_of_tasks(u8 major, enum fman_port_type type,\r\nu16 speed)\r\n{\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_RX:\r\ncase FMAN_PORT_TYPE_TX:\r\nswitch (speed) {\r\ncase 10000:\r\nreturn 16;\r\ncase 1000:\r\nif (major >= 6)\r\nreturn 4;\r\nelse\r\nreturn 3;\r\ndefault:\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int get_dflt_extra_num_of_tasks(u8 major, enum fman_port_type type,\r\nu16 speed)\r\n{\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_RX:\r\nif (major >= 6)\r\nreturn 0;\r\nif (speed == 10000)\r\nreturn 8;\r\nelse\r\nreturn 2;\r\ncase FMAN_PORT_TYPE_TX:\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int get_dflt_num_of_open_dmas(u8 major, enum fman_port_type type,\r\nu16 speed)\r\n{\r\nint val;\r\nif (major >= 6) {\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_TX:\r\nif (speed == 10000)\r\nval = 12;\r\nelse\r\nval = 3;\r\nbreak;\r\ncase FMAN_PORT_TYPE_RX:\r\nif (speed == 10000)\r\nval = 8;\r\nelse\r\nval = 2;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n} else {\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_TX:\r\ncase FMAN_PORT_TYPE_RX:\r\nif (speed == 10000)\r\nval = 8;\r\nelse\r\nval = 1;\r\nbreak;\r\ndefault:\r\nval = 0;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic int get_dflt_extra_num_of_open_dmas(u8 major, enum fman_port_type type,\r\nu16 speed)\r\n{\r\nif (major >= 6)\r\nreturn 0;\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_RX:\r\ncase FMAN_PORT_TYPE_TX:\r\nif (speed == 10000)\r\nreturn 8;\r\nelse\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int get_dflt_num_of_fifo_bufs(u8 major, enum fman_port_type type,\r\nu16 speed)\r\n{\r\nint val;\r\nif (major >= 6) {\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_TX:\r\nif (speed == 10000)\r\nval = 64;\r\nelse\r\nval = 50;\r\nbreak;\r\ncase FMAN_PORT_TYPE_RX:\r\nif (speed == 10000)\r\nval = 96;\r\nelse\r\nval = 50;\r\nbreak;\r\ndefault:\r\nval = 0;\r\n}\r\n} else {\r\nswitch (type) {\r\ncase FMAN_PORT_TYPE_TX:\r\nif (speed == 10000)\r\nval = 48;\r\nelse\r\nval = 44;\r\nbreak;\r\ncase FMAN_PORT_TYPE_RX:\r\nif (speed == 10000)\r\nval = 48;\r\nelse\r\nval = 45;\r\nbreak;\r\ndefault:\r\nval = 0;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic void set_dflt_cfg(struct fman_port *port,\r\nstruct fman_port_params *port_params)\r\n{\r\nstruct fman_port_cfg *cfg = port->cfg;\r\ncfg->dma_swap_data = FMAN_PORT_DMA_NO_SWAP;\r\ncfg->color = FMAN_PORT_COLOR_GREEN;\r\ncfg->rx_cut_end_bytes = DFLT_PORT_CUT_BYTES_FROM_END;\r\ncfg->rx_pri_elevation = BMI_PRIORITY_ELEVATION_LEVEL;\r\ncfg->rx_fifo_thr = BMI_FIFO_THRESHOLD;\r\ncfg->tx_fifo_low_comf_level = (5 * 1024);\r\ncfg->deq_type = FMAN_PORT_DEQ_BY_PRI;\r\ncfg->deq_prefetch_option = FMAN_PORT_DEQ_FULL_PREFETCH;\r\ncfg->tx_fifo_deq_pipeline_depth =\r\nBMI_DEQUEUE_PIPELINE_DEPTH(port->port_type, port->port_speed);\r\ncfg->deq_byte_cnt = QMI_BYTE_COUNT_LEVEL_CONTROL(port->port_type);\r\ncfg->rx_pri_elevation =\r\nDFLT_PORT_RX_FIFO_PRI_ELEVATION_LEV(port->max_port_fifo_size);\r\nport->cfg->rx_fifo_thr =\r\nDFLT_PORT_RX_FIFO_THRESHOLD(port->rev_info.major,\r\nport->max_port_fifo_size);\r\nif ((port->rev_info.major == 6) &&\r\n((port->rev_info.minor == 0) || (port->rev_info.minor == 3)))\r\ncfg->errata_A006320 = true;\r\nif (port->rev_info.major < 6)\r\ncfg->excessive_threshold_register = true;\r\nelse\r\ncfg->fmbm_tfne_has_features = true;\r\ncfg->buffer_prefix_content.data_align =\r\nDFLT_PORT_BUFFER_PREFIX_CONTEXT_DATA_ALIGN;\r\n}\r\nstatic void set_rx_dflt_cfg(struct fman_port *port,\r\nstruct fman_port_params *port_params)\r\n{\r\nport->cfg->discard_mask = DFLT_PORT_ERRORS_TO_DISCARD;\r\nmemcpy(&port->cfg->ext_buf_pools,\r\n&port_params->specific_params.rx_params.ext_buf_pools,\r\nsizeof(struct fman_ext_pools));\r\nport->cfg->err_fqid =\r\nport_params->specific_params.rx_params.err_fqid;\r\nport->cfg->dflt_fqid =\r\nport_params->specific_params.rx_params.dflt_fqid;\r\n}\r\nstatic void set_tx_dflt_cfg(struct fman_port *port,\r\nstruct fman_port_params *port_params,\r\nstruct fman_port_dts_params *dts_params)\r\n{\r\nport->cfg->tx_fifo_deq_pipeline_depth =\r\nget_dflt_fifo_deq_pipeline_depth(port->rev_info.major,\r\nport->port_type,\r\nport->port_speed);\r\nport->cfg->err_fqid =\r\nport_params->specific_params.non_rx_params.err_fqid;\r\nport->cfg->deq_sp =\r\n(u8)(dts_params->qman_channel_id & QMI_DEQ_CFG_SUBPORTAL_MASK);\r\nport->cfg->dflt_fqid =\r\nport_params->specific_params.non_rx_params.dflt_fqid;\r\nport->cfg->deq_high_priority = true;\r\n}\r\nint fman_port_config(struct fman_port *port, struct fman_port_params *params)\r\n{\r\nvoid __iomem *base_addr = port->dts_params.base_addr;\r\nint err;\r\nport->cfg = kzalloc(sizeof(*port->cfg), GFP_KERNEL);\r\nif (!port->cfg)\r\ngoto err_params;\r\nport->port_type = port->dts_params.type;\r\nport->port_speed = port->dts_params.speed;\r\nport->port_id = port->dts_params.id;\r\nport->fm = port->dts_params.fman;\r\nport->ext_pools_num = (u8)8;\r\nfman_get_revision(port->fm, &port->rev_info);\r\nerr = fill_soc_specific_params(port);\r\nif (err)\r\ngoto err_port_cfg;\r\nswitch (port->port_type) {\r\ncase FMAN_PORT_TYPE_RX:\r\nset_rx_dflt_cfg(port, params);\r\ncase FMAN_PORT_TYPE_TX:\r\nset_tx_dflt_cfg(port, params, &port->dts_params);\r\ndefault:\r\nset_dflt_cfg(port, params);\r\n}\r\nport->bmi_regs = base_addr + BMI_PORT_REGS_OFFSET;\r\nport->qmi_regs = base_addr + QMI_PORT_REGS_OFFSET;\r\nport->max_frame_length = DFLT_PORT_MAX_FRAME_LENGTH;\r\nport->fifo_bufs.num =\r\nget_dflt_num_of_fifo_bufs(port->rev_info.major, port->port_type,\r\nport->port_speed) * FMAN_BMI_FIFO_UNITS;\r\nport->fifo_bufs.extra =\r\nDFLT_PORT_EXTRA_NUM_OF_FIFO_BUFS * FMAN_BMI_FIFO_UNITS;\r\nport->open_dmas.num =\r\nget_dflt_num_of_open_dmas(port->rev_info.major,\r\nport->port_type, port->port_speed);\r\nport->open_dmas.extra =\r\nget_dflt_extra_num_of_open_dmas(port->rev_info.major,\r\nport->port_type, port->port_speed);\r\nport->tasks.num =\r\nget_dflt_num_of_tasks(port->rev_info.major,\r\nport->port_type, port->port_speed);\r\nport->tasks.extra =\r\nget_dflt_extra_num_of_tasks(port->rev_info.major,\r\nport->port_type, port->port_speed);\r\nif ((port->rev_info.major == 6) && (port->rev_info.minor == 0) &&\r\n(((port->port_type == FMAN_PORT_TYPE_TX) &&\r\n(port->port_speed == 1000)))) {\r\nport->open_dmas.num = 16;\r\nport->open_dmas.extra = 0;\r\n}\r\nif (port->rev_info.major >= 6 &&\r\nport->port_type == FMAN_PORT_TYPE_TX &&\r\nport->port_speed == 1000) {\r\nif (port->rev_info.major >= 6) {\r\nu32 reg;\r\nreg = 0x00001013;\r\niowrite32be(reg, &port->bmi_regs->tx.fmbm_tfp);\r\n}\r\n}\r\nreturn 0;\r\nerr_port_cfg:\r\nkfree(port->cfg);\r\nerr_params:\r\nkfree(port);\r\nreturn -EINVAL;\r\n}\r\nint fman_port_init(struct fman_port *port)\r\n{\r\nstruct fman_port_cfg *cfg;\r\nint err;\r\nstruct fman_port_init_params params;\r\nif (is_init_done(port->cfg))\r\nreturn -EINVAL;\r\nerr = fman_sp_build_buffer_struct(&port->cfg->int_context,\r\n&port->cfg->buffer_prefix_content,\r\n&port->cfg->buf_margins,\r\n&port->buffer_offsets,\r\n&port->internal_buf_offset);\r\nif (err)\r\nreturn err;\r\ncfg = port->cfg;\r\nif (port->port_type == FMAN_PORT_TYPE_RX) {\r\nerr = set_ext_buffer_pools(port);\r\nif (err)\r\nreturn err;\r\nif (cfg->buf_margins.start_margins + MIN_EXT_BUF_SIZE +\r\ncfg->buf_margins.end_margins >\r\nport->rx_pools_params.largest_buf_size) {\r\ndev_err(port->dev, "%s: buf_margins.start_margins (%d) + minimum buf size (64) + buf_margins.end_margins (%d) is larger than maximum external buffer size (%d)\n",\r\n__func__, cfg->buf_margins.start_margins,\r\ncfg->buf_margins.end_margins,\r\nport->rx_pools_params.largest_buf_size);\r\nreturn -EINVAL;\r\n}\r\n}\r\nmemset(&params, 0, sizeof(params));\r\nparams.port_id = port->port_id;\r\nparams.port_type = port->port_type;\r\nparams.port_speed = port->port_speed;\r\nparams.num_of_tasks = (u8)port->tasks.num;\r\nparams.num_of_extra_tasks = (u8)port->tasks.extra;\r\nparams.num_of_open_dmas = (u8)port->open_dmas.num;\r\nparams.num_of_extra_open_dmas = (u8)port->open_dmas.extra;\r\nif (port->fifo_bufs.num) {\r\nerr = verify_size_of_fifo(port);\r\nif (err)\r\nreturn err;\r\n}\r\nparams.size_of_fifo = port->fifo_bufs.num;\r\nparams.extra_size_of_fifo = port->fifo_bufs.extra;\r\nparams.deq_pipeline_depth = port->cfg->tx_fifo_deq_pipeline_depth;\r\nparams.max_frame_length = port->max_frame_length;\r\nerr = fman_set_port_params(port->fm, &params);\r\nif (err)\r\nreturn err;\r\nerr = init_low_level_driver(port);\r\nif (err)\r\nreturn err;\r\nkfree(port->cfg);\r\nport->cfg = NULL;\r\nreturn 0;\r\n}\r\nint fman_port_cfg_buf_prefix_content(struct fman_port *port,\r\nstruct fman_buffer_prefix_content *\r\nbuffer_prefix_content)\r\n{\r\nif (is_init_done(port->cfg))\r\nreturn -EINVAL;\r\nmemcpy(&port->cfg->buffer_prefix_content,\r\nbuffer_prefix_content,\r\nsizeof(struct fman_buffer_prefix_content));\r\nif (!port->cfg->buffer_prefix_content.data_align)\r\nport->cfg->buffer_prefix_content.data_align =\r\nDFLT_PORT_BUFFER_PREFIX_CONTEXT_DATA_ALIGN;\r\nreturn 0;\r\n}\r\nint fman_port_disable(struct fman_port *port)\r\n{\r\nu32 __iomem *bmi_cfg_reg, *bmi_status_reg;\r\nu32 tmp;\r\nbool rx_port, failure = false;\r\nint count;\r\nif (!is_init_done(port->cfg))\r\nreturn -EINVAL;\r\nswitch (port->port_type) {\r\ncase FMAN_PORT_TYPE_RX:\r\nbmi_cfg_reg = &port->bmi_regs->rx.fmbm_rcfg;\r\nbmi_status_reg = &port->bmi_regs->rx.fmbm_rst;\r\nrx_port = true;\r\nbreak;\r\ncase FMAN_PORT_TYPE_TX:\r\nbmi_cfg_reg = &port->bmi_regs->tx.fmbm_tcfg;\r\nbmi_status_reg = &port->bmi_regs->tx.fmbm_tst;\r\nrx_port = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!rx_port) {\r\ntmp = ioread32be(&port->qmi_regs->fmqm_pnc) & ~QMI_PORT_CFG_EN;\r\niowrite32be(tmp, &port->qmi_regs->fmqm_pnc);\r\ncount = 100;\r\ndo {\r\nudelay(10);\r\ntmp = ioread32be(&port->qmi_regs->fmqm_pns);\r\n} while ((tmp & QMI_PORT_STATUS_DEQ_FD_BSY) && --count);\r\nif (count == 0) {\r\nfailure = true;\r\n}\r\n}\r\ntmp = ioread32be(bmi_cfg_reg) & ~BMI_PORT_CFG_EN;\r\niowrite32be(tmp, bmi_cfg_reg);\r\ncount = 500;\r\ndo {\r\nudelay(10);\r\ntmp = ioread32be(bmi_status_reg);\r\n} while ((tmp & BMI_PORT_STATUS_BSY) && --count);\r\nif (count == 0) {\r\nfailure = true;\r\n}\r\nif (failure)\r\ndev_dbg(port->dev, "%s: FMan Port[%d]: BMI or QMI is Busy. Port forced down\n",\r\n__func__, port->port_id);\r\nreturn 0;\r\n}\r\nint fman_port_enable(struct fman_port *port)\r\n{\r\nu32 __iomem *bmi_cfg_reg;\r\nu32 tmp;\r\nbool rx_port;\r\nif (!is_init_done(port->cfg))\r\nreturn -EINVAL;\r\nswitch (port->port_type) {\r\ncase FMAN_PORT_TYPE_RX:\r\nbmi_cfg_reg = &port->bmi_regs->rx.fmbm_rcfg;\r\nrx_port = true;\r\nbreak;\r\ncase FMAN_PORT_TYPE_TX:\r\nbmi_cfg_reg = &port->bmi_regs->tx.fmbm_tcfg;\r\nrx_port = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!rx_port) {\r\ntmp = ioread32be(&port->qmi_regs->fmqm_pnc) | QMI_PORT_CFG_EN;\r\niowrite32be(tmp, &port->qmi_regs->fmqm_pnc);\r\n}\r\ntmp = ioread32be(bmi_cfg_reg) | BMI_PORT_CFG_EN;\r\niowrite32be(tmp, bmi_cfg_reg);\r\nreturn 0;\r\n}\r\nstruct fman_port *fman_port_bind(struct device *dev)\r\n{\r\nreturn (struct fman_port *)(dev_get_drvdata(get_device(dev)));\r\n}\r\nu32 fman_port_get_qman_channel_id(struct fman_port *port)\r\n{\r\nreturn port->dts_params.qman_channel_id;\r\n}\r\nstatic int fman_port_probe(struct platform_device *of_dev)\r\n{\r\nstruct fman_port *port;\r\nstruct fman *fman;\r\nstruct device_node *fm_node, *port_node;\r\nstruct resource res;\r\nstruct resource *dev_res;\r\nu32 val;\r\nint err = 0, lenp;\r\nenum fman_port_type port_type;\r\nu16 port_speed;\r\nu8 port_id;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nport->dev = &of_dev->dev;\r\nport_node = of_node_get(of_dev->dev.of_node);\r\nfm_node = of_get_parent(port_node);\r\nif (!fm_node) {\r\ndev_err(port->dev, "%s: of_get_parent() failed\n", __func__);\r\nerr = -ENODEV;\r\ngoto return_err;\r\n}\r\nfman = dev_get_drvdata(&of_find_device_by_node(fm_node)->dev);\r\nof_node_put(fm_node);\r\nif (!fman) {\r\nerr = -EINVAL;\r\ngoto return_err;\r\n}\r\nerr = of_property_read_u32(port_node, "cell-index", &val);\r\nif (err) {\r\ndev_err(port->dev, "%s: reading cell-index for %s failed\n",\r\n__func__, port_node->full_name);\r\nerr = -EINVAL;\r\ngoto return_err;\r\n}\r\nport_id = (u8)val;\r\nport->dts_params.id = port_id;\r\nif (of_device_is_compatible(port_node, "fsl,fman-v3-port-tx")) {\r\nport_type = FMAN_PORT_TYPE_TX;\r\nport_speed = 1000;\r\nif (of_find_property(port_node, "fsl,fman-10g-port", &lenp))\r\nport_speed = 10000;\r\n} else if (of_device_is_compatible(port_node, "fsl,fman-v2-port-tx")) {\r\nif (port_id >= TX_10G_PORT_BASE)\r\nport_speed = 10000;\r\nelse\r\nport_speed = 1000;\r\nport_type = FMAN_PORT_TYPE_TX;\r\n} else if (of_device_is_compatible(port_node, "fsl,fman-v3-port-rx")) {\r\nport_type = FMAN_PORT_TYPE_RX;\r\nport_speed = 1000;\r\nif (of_find_property(port_node, "fsl,fman-10g-port", &lenp))\r\nport_speed = 10000;\r\n} else if (of_device_is_compatible(port_node, "fsl,fman-v2-port-rx")) {\r\nif (port_id >= RX_10G_PORT_BASE)\r\nport_speed = 10000;\r\nelse\r\nport_speed = 1000;\r\nport_type = FMAN_PORT_TYPE_RX;\r\n} else {\r\ndev_err(port->dev, "%s: Illegal port type\n", __func__);\r\nerr = -EINVAL;\r\ngoto return_err;\r\n}\r\nport->dts_params.type = port_type;\r\nport->dts_params.speed = port_speed;\r\nif (port_type == FMAN_PORT_TYPE_TX) {\r\nu32 qman_channel_id;\r\nqman_channel_id = fman_get_qman_channel_id(fman, port_id);\r\nif (qman_channel_id == 0) {\r\ndev_err(port->dev, "%s: incorrect qman-channel-id\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto return_err;\r\n}\r\nport->dts_params.qman_channel_id = qman_channel_id;\r\n}\r\nerr = of_address_to_resource(port_node, 0, &res);\r\nif (err < 0) {\r\ndev_err(port->dev, "%s: of_address_to_resource() failed\n",\r\n__func__);\r\nerr = -ENOMEM;\r\ngoto return_err;\r\n}\r\nport->dts_params.fman = fman;\r\nof_node_put(port_node);\r\ndev_res = __devm_request_region(port->dev, &res, res.start,\r\nresource_size(&res), "fman-port");\r\nif (!dev_res) {\r\ndev_err(port->dev, "%s: __devm_request_region() failed\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto free_port;\r\n}\r\nport->dts_params.base_addr = devm_ioremap(port->dev, res.start,\r\nresource_size(&res));\r\nif (!port->dts_params.base_addr)\r\ndev_err(port->dev, "%s: devm_ioremap() failed\n", __func__);\r\ndev_set_drvdata(&of_dev->dev, port);\r\nreturn 0;\r\nreturn_err:\r\nof_node_put(port_node);\r\nfree_port:\r\nkfree(port);\r\nreturn err;\r\n}\r\nstatic int __init fman_port_load(void)\r\n{\r\nint err;\r\npr_debug("FSL DPAA FMan driver\n");\r\nerr = platform_driver_register(&fman_port_driver);\r\nif (err < 0)\r\npr_err("Error, platform_driver_register() = %d\n", err);\r\nreturn err;\r\n}\r\nstatic void __exit fman_port_unload(void)\r\n{\r\nplatform_driver_unregister(&fman_port_driver);\r\n}
