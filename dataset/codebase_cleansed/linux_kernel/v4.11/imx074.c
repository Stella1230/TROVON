static struct imx074 *to_imx074(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct imx074, subdev);\r\n}\r\nstatic const struct imx074_datafmt *imx074_find_datafmt(u32 code)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(imx074_colour_fmts); i++)\r\nif (imx074_colour_fmts[i].code == code)\r\nreturn imx074_colour_fmts + i;\r\nreturn NULL;\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u16 addr, const u8 data)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg;\r\nunsigned char tx[3];\r\nint ret;\r\nmsg.addr = client->addr;\r\nmsg.buf = tx;\r\nmsg.len = 3;\r\nmsg.flags = 0;\r\ntx[0] = addr >> 8;\r\ntx[1] = addr & 0xff;\r\ntx[2] = data;\r\nret = i2c_transfer(adap, &msg, 1);\r\nmdelay(2);\r\nreturn ret == 1 ? 0 : -EIO;\r\n}\r\nstatic int reg_read(struct i2c_client *client, const u16 addr)\r\n{\r\nu8 buf[2] = {addr >> 8, addr & 0xff};\r\nint ret;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = buf,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 2,\r\n.buf = buf,\r\n},\r\n};\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0) {\r\ndev_warn(&client->dev, "Reading register %x from %x failed\n",\r\naddr, client->addr);\r\nreturn ret;\r\n}\r\nreturn buf[0] & 0xff;\r\n}\r\nstatic int imx074_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nconst struct imx074_datafmt *fmt = imx074_find_datafmt(mf->code);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct imx074 *priv = to_imx074(client);\r\nif (format->pad)\r\nreturn -EINVAL;\r\ndev_dbg(sd->v4l2_dev->dev, "%s(%u)\n", __func__, mf->code);\r\nif (!fmt) {\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nmf->code = imx074_colour_fmts[0].code;\r\nmf->colorspace = imx074_colour_fmts[0].colorspace;\r\n}\r\nmf->width = IMX074_WIDTH;\r\nmf->height = IMX074_HEIGHT;\r\nmf->field = V4L2_FIELD_NONE;\r\nif (format->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\npriv->fmt = imx074_find_datafmt(mf->code);\r\nelse\r\ncfg->try_fmt = *mf;\r\nreturn 0;\r\n}\r\nstatic int imx074_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct imx074 *priv = to_imx074(client);\r\nconst struct imx074_datafmt *fmt = priv->fmt;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->code = fmt->code;\r\nmf->colorspace = fmt->colorspace;\r\nmf->width = IMX074_WIDTH;\r\nmf->height = IMX074_HEIGHT;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int imx074_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = IMX074_WIDTH;\r\nsel->r.height = IMX074_HEIGHT;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_CROP:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int imx074_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad ||\r\n(unsigned int)code->index >= ARRAY_SIZE(imx074_colour_fmts))\r\nreturn -EINVAL;\r\ncode->code = imx074_colour_fmts[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int imx074_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn reg_write(client, MODE_SELECT, !!enable);\r\n}\r\nstatic int imx074_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct imx074 *priv = to_imx074(client);\r\nreturn soc_camera_set_power(&client->dev, ssdd, priv->clk, on);\r\n}\r\nstatic int imx074_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\ncfg->type = V4L2_MBUS_CSI2;\r\ncfg->flags = V4L2_MBUS_CSI2_2_LANE |\r\nV4L2_MBUS_CSI2_CHANNEL_0 |\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK;\r\nreturn 0;\r\n}\r\nstatic int imx074_video_probe(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nint ret;\r\nu16 id;\r\nret = imx074_s_power(subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = reg_read(client, 0);\r\nif (ret < 0)\r\ngoto done;\r\nid = ret << 8;\r\nret = reg_read(client, 1);\r\nif (ret < 0)\r\ngoto done;\r\nid |= ret;\r\ndev_info(&client->dev, "Chip ID 0x%04x detected\n", id);\r\nif (id != 0x74) {\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nreg_write(client, PLL_MULTIPLIER, 0x2D);\r\nreg_write(client, PRE_PLL_CLK_DIV, 0x02);\r\nreg_write(client, PLSTATIM, 0x4B);\r\nreg_write(client, 0x3024, 0x00);\r\nreg_write(client, IMAGE_ORIENTATION, 0x00);\r\nreg_write(client, 0x0112, 0x08);\r\nreg_write(client, 0x0113, 0x08);\r\nreg_write(client, VNDMY_ABLMGSHLMT, 0x80);\r\nreg_write(client, Y_OPBADDR_START_DI, 0x08);\r\nreg_write(client, 0x3015, 0x37);\r\nreg_write(client, 0x301C, 0x01);\r\nreg_write(client, 0x302C, 0x05);\r\nreg_write(client, 0x3031, 0x26);\r\nreg_write(client, 0x3041, 0x60);\r\nreg_write(client, 0x3051, 0x24);\r\nreg_write(client, 0x3053, 0x34);\r\nreg_write(client, 0x3057, 0xC0);\r\nreg_write(client, 0x305C, 0x09);\r\nreg_write(client, 0x305D, 0x07);\r\nreg_write(client, 0x3060, 0x30);\r\nreg_write(client, 0x3065, 0x00);\r\nreg_write(client, 0x30AA, 0x08);\r\nreg_write(client, 0x30AB, 0x1C);\r\nreg_write(client, 0x30B0, 0x32);\r\nreg_write(client, 0x30B2, 0x83);\r\nreg_write(client, 0x30D3, 0x04);\r\nreg_write(client, 0x3106, 0x78);\r\nreg_write(client, 0x310C, 0x82);\r\nreg_write(client, 0x3304, 0x05);\r\nreg_write(client, 0x3305, 0x04);\r\nreg_write(client, 0x3306, 0x11);\r\nreg_write(client, 0x3307, 0x02);\r\nreg_write(client, 0x3308, 0x0C);\r\nreg_write(client, 0x3309, 0x06);\r\nreg_write(client, 0x330A, 0x08);\r\nreg_write(client, 0x330B, 0x04);\r\nreg_write(client, 0x330C, 0x08);\r\nreg_write(client, 0x330D, 0x06);\r\nreg_write(client, 0x330E, 0x01);\r\nreg_write(client, 0x3381, 0x00);\r\nreg_write(client, FRAME_LENGTH_LINES_HI, 0x06);\r\nreg_write(client, FRAME_LENGTH_LINES_LO, 0x48);\r\nreg_write(client, YADDR_START, 0x00);\r\nreg_write(client, YADDR_END, 0x2F);\r\nreg_write(client, X_OUTPUT_SIZE_MSB, 0x08);\r\nreg_write(client, X_OUTPUT_SIZE_LSB, 0x38);\r\nreg_write(client, Y_OUTPUT_SIZE_MSB, 0x06);\r\nreg_write(client, Y_OUTPUT_SIZE_LSB, 0x18);\r\nreg_write(client, X_EVEN_INC, 0x01);\r\nreg_write(client, X_ODD_INC, 0x03);\r\nreg_write(client, Y_EVEN_INC, 0x01);\r\nreg_write(client, Y_ODD_INC, 0x03);\r\nreg_write(client, HMODEADD, 0x00);\r\nreg_write(client, VMODEADD, 0x16);\r\nreg_write(client, VAPPLINE_START, 0x24);\r\nreg_write(client, VAPPLINE_END, 0x53);\r\nreg_write(client, SHUTTER, 0x00);\r\nreg_write(client, HADDAVE, 0x80);\r\nreg_write(client, LANESEL, 0x00);\r\nreg_write(client, GROUPED_PARAMETER_HOLD, 0x00);\r\nret = 0;\r\ndone:\r\nimx074_s_power(subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int imx074_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct imx074 *priv;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nint ret;\r\nif (!ssdd) {\r\ndev_err(&client->dev, "IMX074: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");\r\nreturn -EIO;\r\n}\r\npriv = devm_kzalloc(&client->dev, sizeof(struct imx074), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&priv->subdev, client, &imx074_subdev_ops);\r\npriv->fmt = &imx074_colour_fmts[0];\r\npriv->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(priv->clk)) {\r\ndev_info(&client->dev, "Error %ld getting clock\n", PTR_ERR(priv->clk));\r\nreturn -EPROBE_DEFER;\r\n}\r\nret = soc_camera_power_init(&client->dev, ssdd);\r\nif (ret < 0)\r\ngoto epwrinit;\r\nret = imx074_video_probe(client);\r\nif (ret < 0)\r\ngoto eprobe;\r\nret = v4l2_async_register_subdev(&priv->subdev);\r\nif (!ret)\r\nreturn 0;\r\nepwrinit:\r\neprobe:\r\nv4l2_clk_put(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int imx074_remove(struct i2c_client *client)\r\n{\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct imx074 *priv = to_imx074(client);\r\nv4l2_async_unregister_subdev(&priv->subdev);\r\nv4l2_clk_put(priv->clk);\r\nif (ssdd->free_bus)\r\nssdd->free_bus(ssdd);\r\nreturn 0;\r\n}
