static void bgpio_write8(void __iomem *reg, unsigned long data)\r\n{\r\nwriteb(data, reg);\r\n}\r\nstatic unsigned long bgpio_read8(void __iomem *reg)\r\n{\r\nreturn readb(reg);\r\n}\r\nstatic void bgpio_write16(void __iomem *reg, unsigned long data)\r\n{\r\nwritew(data, reg);\r\n}\r\nstatic unsigned long bgpio_read16(void __iomem *reg)\r\n{\r\nreturn readw(reg);\r\n}\r\nstatic void bgpio_write32(void __iomem *reg, unsigned long data)\r\n{\r\nwritel(data, reg);\r\n}\r\nstatic unsigned long bgpio_read32(void __iomem *reg)\r\n{\r\nreturn readl(reg);\r\n}\r\nstatic void bgpio_write64(void __iomem *reg, unsigned long data)\r\n{\r\nwriteq(data, reg);\r\n}\r\nstatic unsigned long bgpio_read64(void __iomem *reg)\r\n{\r\nreturn readq(reg);\r\n}\r\nstatic void bgpio_write16be(void __iomem *reg, unsigned long data)\r\n{\r\niowrite16be(data, reg);\r\n}\r\nstatic unsigned long bgpio_read16be(void __iomem *reg)\r\n{\r\nreturn ioread16be(reg);\r\n}\r\nstatic void bgpio_write32be(void __iomem *reg, unsigned long data)\r\n{\r\niowrite32be(data, reg);\r\n}\r\nstatic unsigned long bgpio_read32be(void __iomem *reg)\r\n{\r\nreturn ioread32be(reg);\r\n}\r\nstatic unsigned long bgpio_pin2mask(struct gpio_chip *gc, unsigned int pin)\r\n{\r\nreturn BIT(pin);\r\n}\r\nstatic unsigned long bgpio_pin2mask_be(struct gpio_chip *gc,\r\nunsigned int pin)\r\n{\r\nreturn BIT(gc->bgpio_bits - 1 - pin);\r\n}\r\nstatic int bgpio_get_set(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nunsigned long pinmask = gc->pin2mask(gc, gpio);\r\nif (gc->bgpio_dir & pinmask)\r\nreturn !!(gc->read_reg(gc->reg_set) & pinmask);\r\nelse\r\nreturn !!(gc->read_reg(gc->reg_dat) & pinmask);\r\n}\r\nstatic int bgpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn !!(gc->read_reg(gc->reg_dat) & gc->pin2mask(gc, gpio));\r\n}\r\nstatic void bgpio_set_none(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\n}\r\nstatic void bgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long mask = gc->pin2mask(gc, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nif (val)\r\ngc->bgpio_data |= mask;\r\nelse\r\ngc->bgpio_data &= ~mask;\r\ngc->write_reg(gc->reg_dat, gc->bgpio_data);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\n}\r\nstatic void bgpio_set_with_clear(struct gpio_chip *gc, unsigned int gpio,\r\nint val)\r\n{\r\nunsigned long mask = gc->pin2mask(gc, gpio);\r\nif (val)\r\ngc->write_reg(gc->reg_set, mask);\r\nelse\r\ngc->write_reg(gc->reg_clr, mask);\r\n}\r\nstatic void bgpio_set_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long mask = gc->pin2mask(gc, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nif (val)\r\ngc->bgpio_data |= mask;\r\nelse\r\ngc->bgpio_data &= ~mask;\r\ngc->write_reg(gc->reg_set, gc->bgpio_data);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\n}\r\nstatic void bgpio_multiple_get_masks(struct gpio_chip *gc,\r\nunsigned long *mask, unsigned long *bits,\r\nunsigned long *set_mask,\r\nunsigned long *clear_mask)\r\n{\r\nint i;\r\n*set_mask = 0;\r\n*clear_mask = 0;\r\nfor (i = 0; i < gc->bgpio_bits; i++) {\r\nif (*mask == 0)\r\nbreak;\r\nif (__test_and_clear_bit(i, mask)) {\r\nif (test_bit(i, bits))\r\n*set_mask |= gc->pin2mask(gc, i);\r\nelse\r\n*clear_mask |= gc->pin2mask(gc, i);\r\n}\r\n}\r\n}\r\nstatic void bgpio_set_multiple_single_reg(struct gpio_chip *gc,\r\nunsigned long *mask,\r\nunsigned long *bits,\r\nvoid __iomem *reg)\r\n{\r\nunsigned long flags;\r\nunsigned long set_mask, clear_mask;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\nbgpio_multiple_get_masks(gc, mask, bits, &set_mask, &clear_mask);\r\ngc->bgpio_data |= set_mask;\r\ngc->bgpio_data &= ~clear_mask;\r\ngc->write_reg(reg, gc->bgpio_data);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\n}\r\nstatic void bgpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,\r\nunsigned long *bits)\r\n{\r\nbgpio_set_multiple_single_reg(gc, mask, bits, gc->reg_dat);\r\n}\r\nstatic void bgpio_set_multiple_set(struct gpio_chip *gc, unsigned long *mask,\r\nunsigned long *bits)\r\n{\r\nbgpio_set_multiple_single_reg(gc, mask, bits, gc->reg_set);\r\n}\r\nstatic void bgpio_set_multiple_with_clear(struct gpio_chip *gc,\r\nunsigned long *mask,\r\nunsigned long *bits)\r\n{\r\nunsigned long set_mask, clear_mask;\r\nbgpio_multiple_get_masks(gc, mask, bits, &set_mask, &clear_mask);\r\nif (set_mask)\r\ngc->write_reg(gc->reg_set, set_mask);\r\nif (clear_mask)\r\ngc->write_reg(gc->reg_clr, clear_mask);\r\n}\r\nstatic int bgpio_simple_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_out_err(struct gpio_chip *gc, unsigned int gpio,\r\nint val)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int bgpio_simple_dir_out(struct gpio_chip *gc, unsigned int gpio,\r\nint val)\r\n{\r\ngc->set(gc, gpio, val);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\ngc->bgpio_dir &= ~gc->pin2mask(gc, gpio);\r\ngc->write_reg(gc->reg_dir, gc->bgpio_dir);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_get_dir(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn !(gc->read_reg(gc->reg_dir) & gc->pin2mask(gc, gpio));\r\n}\r\nstatic int bgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\ngc->set(gc, gpio, val);\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\ngc->bgpio_dir |= gc->pin2mask(gc, gpio);\r\ngc->write_reg(gc->reg_dir, gc->bgpio_dir);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_in_inv(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\ngc->bgpio_dir |= gc->pin2mask(gc, gpio);\r\ngc->write_reg(gc->reg_dir, gc->bgpio_dir);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_dir_out_inv(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\ngc->set(gc, gpio, val);\r\nspin_lock_irqsave(&gc->bgpio_lock, flags);\r\ngc->bgpio_dir &= ~gc->pin2mask(gc, gpio);\r\ngc->write_reg(gc->reg_dir, gc->bgpio_dir);\r\nspin_unlock_irqrestore(&gc->bgpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bgpio_get_dir_inv(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn !!(gc->read_reg(gc->reg_dir) & gc->pin2mask(gc, gpio));\r\n}\r\nstatic int bgpio_setup_accessors(struct device *dev,\r\nstruct gpio_chip *gc,\r\nbool bit_be,\r\nbool byte_be)\r\n{\r\nswitch (gc->bgpio_bits) {\r\ncase 8:\r\ngc->read_reg = bgpio_read8;\r\ngc->write_reg = bgpio_write8;\r\nbreak;\r\ncase 16:\r\nif (byte_be) {\r\ngc->read_reg = bgpio_read16be;\r\ngc->write_reg = bgpio_write16be;\r\n} else {\r\ngc->read_reg = bgpio_read16;\r\ngc->write_reg = bgpio_write16;\r\n}\r\nbreak;\r\ncase 32:\r\nif (byte_be) {\r\ngc->read_reg = bgpio_read32be;\r\ngc->write_reg = bgpio_write32be;\r\n} else {\r\ngc->read_reg = bgpio_read32;\r\ngc->write_reg = bgpio_write32;\r\n}\r\nbreak;\r\n#if BITS_PER_LONG >= 64\r\ncase 64:\r\nif (byte_be) {\r\ndev_err(dev,\r\n"64 bit big endian byte order unsupported\n");\r\nreturn -EINVAL;\r\n} else {\r\ngc->read_reg = bgpio_read64;\r\ngc->write_reg = bgpio_write64;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(dev, "unsupported data width %u bits\n", gc->bgpio_bits);\r\nreturn -EINVAL;\r\n}\r\ngc->pin2mask = bit_be ? bgpio_pin2mask_be : bgpio_pin2mask;\r\nreturn 0;\r\n}\r\nstatic int bgpio_setup_io(struct gpio_chip *gc,\r\nvoid __iomem *dat,\r\nvoid __iomem *set,\r\nvoid __iomem *clr,\r\nunsigned long flags)\r\n{\r\ngc->reg_dat = dat;\r\nif (!gc->reg_dat)\r\nreturn -EINVAL;\r\nif (set && clr) {\r\ngc->reg_set = set;\r\ngc->reg_clr = clr;\r\ngc->set = bgpio_set_with_clear;\r\ngc->set_multiple = bgpio_set_multiple_with_clear;\r\n} else if (set && !clr) {\r\ngc->reg_set = set;\r\ngc->set = bgpio_set_set;\r\ngc->set_multiple = bgpio_set_multiple_set;\r\n} else if (flags & BGPIOF_NO_OUTPUT) {\r\ngc->set = bgpio_set_none;\r\ngc->set_multiple = NULL;\r\n} else {\r\ngc->set = bgpio_set;\r\ngc->set_multiple = bgpio_set_multiple;\r\n}\r\nif (!(flags & BGPIOF_UNREADABLE_REG_SET) &&\r\n(flags & BGPIOF_READ_OUTPUT_REG_SET))\r\ngc->get = bgpio_get_set;\r\nelse\r\ngc->get = bgpio_get;\r\nreturn 0;\r\n}\r\nstatic int bgpio_setup_direction(struct gpio_chip *gc,\r\nvoid __iomem *dirout,\r\nvoid __iomem *dirin,\r\nunsigned long flags)\r\n{\r\nif (dirout && dirin) {\r\nreturn -EINVAL;\r\n} else if (dirout) {\r\ngc->reg_dir = dirout;\r\ngc->direction_output = bgpio_dir_out;\r\ngc->direction_input = bgpio_dir_in;\r\ngc->get_direction = bgpio_get_dir;\r\n} else if (dirin) {\r\ngc->reg_dir = dirin;\r\ngc->direction_output = bgpio_dir_out_inv;\r\ngc->direction_input = bgpio_dir_in_inv;\r\ngc->get_direction = bgpio_get_dir_inv;\r\n} else {\r\nif (flags & BGPIOF_NO_OUTPUT)\r\ngc->direction_output = bgpio_dir_out_err;\r\nelse\r\ngc->direction_output = bgpio_simple_dir_out;\r\ngc->direction_input = bgpio_simple_dir_in;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bgpio_request(struct gpio_chip *chip, unsigned gpio_pin)\r\n{\r\nif (gpio_pin < chip->ngpio)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nint bgpio_init(struct gpio_chip *gc, struct device *dev,\r\nunsigned long sz, void __iomem *dat, void __iomem *set,\r\nvoid __iomem *clr, void __iomem *dirout, void __iomem *dirin,\r\nunsigned long flags)\r\n{\r\nint ret;\r\nif (!is_power_of_2(sz))\r\nreturn -EINVAL;\r\ngc->bgpio_bits = sz * 8;\r\nif (gc->bgpio_bits > BITS_PER_LONG)\r\nreturn -EINVAL;\r\nspin_lock_init(&gc->bgpio_lock);\r\ngc->parent = dev;\r\ngc->label = dev_name(dev);\r\ngc->base = -1;\r\ngc->ngpio = gc->bgpio_bits;\r\ngc->request = bgpio_request;\r\nret = bgpio_setup_io(gc, dat, set, clr, flags);\r\nif (ret)\r\nreturn ret;\r\nret = bgpio_setup_accessors(dev, gc, flags & BGPIOF_BIG_ENDIAN,\r\nflags & BGPIOF_BIG_ENDIAN_BYTE_ORDER);\r\nif (ret)\r\nreturn ret;\r\nret = bgpio_setup_direction(gc, dirout, dirin, flags);\r\nif (ret)\r\nreturn ret;\r\ngc->bgpio_data = gc->read_reg(gc->reg_dat);\r\nif (gc->set == bgpio_set_set &&\r\n!(flags & BGPIOF_UNREADABLE_REG_SET))\r\ngc->bgpio_data = gc->read_reg(gc->reg_set);\r\nif (gc->reg_dir && !(flags & BGPIOF_UNREADABLE_REG_DIR))\r\ngc->bgpio_dir = gc->read_reg(gc->reg_dir);\r\nreturn ret;\r\n}\r\nstatic void __iomem *bgpio_map(struct platform_device *pdev,\r\nconst char *name,\r\nresource_size_t sane_sz)\r\n{\r\nstruct resource *r;\r\nresource_size_t sz;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\r\nif (!r)\r\nreturn NULL;\r\nsz = resource_size(r);\r\nif (sz != sane_sz)\r\nreturn IOMEM_ERR_PTR(-EINVAL);\r\nreturn devm_ioremap_resource(&pdev->dev, r);\r\n}\r\nstatic struct bgpio_pdata *bgpio_parse_dt(struct platform_device *pdev,\r\nunsigned long *flags)\r\n{\r\nstruct bgpio_pdata *pdata;\r\nif (!of_match_device(bgpio_of_match, &pdev->dev))\r\nreturn NULL;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(struct bgpio_pdata),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->base = -1;\r\nif (of_device_is_big_endian(pdev->dev.of_node))\r\n*flags |= BGPIOF_BIG_ENDIAN_BYTE_ORDER;\r\nif (of_property_read_bool(pdev->dev.of_node, "no-output"))\r\n*flags |= BGPIOF_NO_OUTPUT;\r\nreturn pdata;\r\n}\r\nstatic struct bgpio_pdata *bgpio_parse_dt(struct platform_device *pdev,\r\nunsigned long *flags)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int bgpio_pdev_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *r;\r\nvoid __iomem *dat;\r\nvoid __iomem *set;\r\nvoid __iomem *clr;\r\nvoid __iomem *dirout;\r\nvoid __iomem *dirin;\r\nunsigned long sz;\r\nunsigned long flags = 0;\r\nint err;\r\nstruct gpio_chip *gc;\r\nstruct bgpio_pdata *pdata;\r\npdata = bgpio_parse_dt(pdev, &flags);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nif (!pdata) {\r\npdata = dev_get_platdata(dev);\r\nflags = pdev->id_entry->driver_data;\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");\r\nif (!r)\r\nreturn -EINVAL;\r\nsz = resource_size(r);\r\ndat = bgpio_map(pdev, "dat", sz);\r\nif (IS_ERR(dat))\r\nreturn PTR_ERR(dat);\r\nset = bgpio_map(pdev, "set", sz);\r\nif (IS_ERR(set))\r\nreturn PTR_ERR(set);\r\nclr = bgpio_map(pdev, "clr", sz);\r\nif (IS_ERR(clr))\r\nreturn PTR_ERR(clr);\r\ndirout = bgpio_map(pdev, "dirout", sz);\r\nif (IS_ERR(dirout))\r\nreturn PTR_ERR(dirout);\r\ndirin = bgpio_map(pdev, "dirin", sz);\r\nif (IS_ERR(dirin))\r\nreturn PTR_ERR(dirin);\r\ngc = devm_kzalloc(&pdev->dev, sizeof(*gc), GFP_KERNEL);\r\nif (!gc)\r\nreturn -ENOMEM;\r\nerr = bgpio_init(gc, dev, sz, dat, set, clr, dirout, dirin, flags);\r\nif (err)\r\nreturn err;\r\nif (pdata) {\r\nif (pdata->label)\r\ngc->label = pdata->label;\r\ngc->base = pdata->base;\r\nif (pdata->ngpio > 0)\r\ngc->ngpio = pdata->ngpio;\r\n}\r\nplatform_set_drvdata(pdev, gc);\r\nreturn devm_gpiochip_add_data(&pdev->dev, gc, NULL);\r\n}
