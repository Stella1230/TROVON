static u32 lpc18xx_pll0_mdec2msel(u32 x)\r\n{\r\nint i;\r\nswitch (x) {\r\ncase 0x18003: return 1;\r\ncase 0x10003: return 2;\r\ndefault:\r\nfor (i = LPC18XX_PLL0_MSEL_MAX + 1; x != 0x4000 && i > 0; i--)\r\nx = ((x ^ x >> 14) & 1) | (x << 1 & 0x7fff);\r\nreturn i;\r\n}\r\n}\r\nstatic u32 lpc18xx_pll0_msel2mdec(u32 msel)\r\n{\r\nu32 i, x = 0x4000;\r\nswitch (msel) {\r\ncase 0: return 0;\r\ncase 1: return 0x18003;\r\ncase 2: return 0x10003;\r\ndefault:\r\nfor (i = msel; i <= LPC18XX_PLL0_MSEL_MAX; i++)\r\nx = ((x ^ x >> 1) & 1) << 14 | (x >> 1 & 0xffff);\r\nreturn x;\r\n}\r\n}\r\nstatic u32 lpc18xx_pll0_msel2seli(u32 msel)\r\n{\r\nu32 tmp;\r\nif (msel > 16384) return 1;\r\nif (msel > 8192) return 2;\r\nif (msel > 2048) return 4;\r\nif (msel >= 501) return 8;\r\nif (msel >= 60) {\r\ntmp = 1024 / (msel + 9);\r\nreturn ((1024 == (tmp * (msel + 9))) == 0) ? tmp * 4 : (tmp + 1) * 4;\r\n}\r\nreturn (msel & 0x3c) + 4;\r\n}\r\nstatic u32 lpc18xx_pll0_msel2selp(u32 msel)\r\n{\r\nif (msel < 60)\r\nreturn (msel >> 1) + 1;\r\nreturn 31;\r\n}\r\nstatic unsigned long lpc18xx_pll0_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc18xx_pll *pll = to_lpc_pll(hw);\r\nu32 ctrl, mdiv, msel, npdiv;\r\nctrl = clk_readl(pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\r\nmdiv = clk_readl(pll->reg + LPC18XX_CGU_PLL0USB_MDIV);\r\nnpdiv = clk_readl(pll->reg + LPC18XX_CGU_PLL0USB_NP_DIV);\r\nif (ctrl & LPC18XX_PLL0_CTRL_BYPASS)\r\nreturn parent_rate;\r\nif (npdiv != LPC18XX_PLL0_NP_DIVS_1) {\r\npr_warn("%s: pre/post dividers not supported\n", __func__);\r\nreturn 0;\r\n}\r\nmsel = lpc18xx_pll0_mdec2msel(mdiv & LPC18XX_PLL0_MDIV_MDEC_MASK);\r\nif (msel)\r\nreturn 2 * msel * parent_rate;\r\npr_warn("%s: unable to calculate rate\n", __func__);\r\nreturn 0;\r\n}\r\nstatic long lpc18xx_pll0_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long m;\r\nif (*prate < rate) {\r\npr_warn("%s: pll dividers not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nm = DIV_ROUND_UP_ULL(*prate, rate * 2);\r\nif (m <= 0 && m > LPC18XX_PLL0_MSEL_MAX) {\r\npr_warn("%s: unable to support rate %lu\n", __func__, rate);\r\nreturn -EINVAL;\r\n}\r\nreturn 2 * *prate * m;\r\n}\r\nstatic int lpc18xx_pll0_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc18xx_pll *pll = to_lpc_pll(hw);\r\nu32 ctrl, stat, m;\r\nint retry = 3;\r\nif (parent_rate < rate) {\r\npr_warn("%s: pll dividers not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nm = DIV_ROUND_UP_ULL(parent_rate, rate * 2);\r\nif (m <= 0 && m > LPC18XX_PLL0_MSEL_MAX) {\r\npr_warn("%s: unable to support rate %lu\n", __func__, rate);\r\nreturn -EINVAL;\r\n}\r\nm = lpc18xx_pll0_msel2mdec(m);\r\nm |= lpc18xx_pll0_msel2selp(m) << LPC18XX_PLL0_MDIV_SELP_SHIFT;\r\nm |= lpc18xx_pll0_msel2seli(m) << LPC18XX_PLL0_MDIV_SELI_SHIFT;\r\nctrl = clk_readl(pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\r\nctrl |= LPC18XX_PLL0_CTRL_PD;\r\nctrl &= ~(LPC18XX_PLL0_CTRL_BYPASS | LPC18XX_PLL0_CTRL_DIRECTI |\r\nLPC18XX_PLL0_CTRL_DIRECTO | LPC18XX_PLL0_CTRL_CLKEN);\r\nclk_writel(ctrl, pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\r\nclk_writel(m, pll->reg + LPC18XX_CGU_PLL0USB_MDIV);\r\nclk_writel(LPC18XX_PLL0_NP_DIVS_1, pll->reg + LPC18XX_CGU_PLL0USB_NP_DIV);\r\nctrl &= ~LPC18XX_PLL0_CTRL_PD;\r\nclk_writel(ctrl, pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\r\ndo {\r\nudelay(10);\r\nstat = clk_readl(pll->reg + LPC18XX_CGU_PLL0USB_STAT);\r\nif (stat & LPC18XX_PLL0_STAT_LOCK) {\r\nctrl |= LPC18XX_PLL0_CTRL_CLKEN;\r\nclk_writel(ctrl, pll->reg + LPC18XX_CGU_PLL0USB_CTRL);\r\nreturn 0;\r\n}\r\n} while (retry--);\r\npr_warn("%s: unable to lock pll\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long lpc18xx_pll1_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc18xx_pll *pll = to_lpc_pll(hw);\r\nu16 msel, nsel, psel;\r\nbool direct, fbsel;\r\nu32 stat, ctrl;\r\nstat = clk_readl(pll->reg + LPC18XX_CGU_PLL1_STAT);\r\nctrl = clk_readl(pll->reg + LPC18XX_CGU_PLL1_CTRL);\r\ndirect = (ctrl & LPC18XX_PLL1_CTRL_DIRECT) ? true : false;\r\nfbsel = (ctrl & LPC18XX_PLL1_CTRL_FBSEL) ? true : false;\r\nmsel = ((ctrl >> 16) & 0xff) + 1;\r\nnsel = ((ctrl >> 12) & 0x3) + 1;\r\nif (direct || fbsel)\r\nreturn msel * (parent_rate / nsel);\r\npsel = (ctrl >> 8) & 0x3;\r\npsel = 1 << psel;\r\nreturn (msel / (2 * psel)) * (parent_rate / nsel);\r\n}\r\nstatic int lpc18xx_cgu_gate_enable(struct clk_hw *hw)\r\n{\r\nreturn clk_gate_ops.enable(hw);\r\n}\r\nstatic void lpc18xx_cgu_gate_disable(struct clk_hw *hw)\r\n{\r\nclk_gate_ops.disable(hw);\r\n}\r\nstatic int lpc18xx_cgu_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nconst struct clk_hw *parent;\r\nparent = clk_hw_get_parent(hw);\r\nif (!parent)\r\nreturn 0;\r\nif (!clk_hw_is_enabled(parent))\r\nreturn 0;\r\nreturn clk_gate_ops.is_enabled(hw);\r\n}\r\nstatic void lpc18xx_fill_parent_names(const char **parent, u32 *id, int size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nparent[i] = clk_src_names[id[i]];\r\n}\r\nstatic struct clk *lpc18xx_cgu_register_div(struct lpc18xx_cgu_src_clk_div *clk,\r\nvoid __iomem *base, int n)\r\n{\r\nvoid __iomem *reg = base + LPC18XX_CGU_IDIV_CTRL(n);\r\nconst char *name = clk_src_names[clk->clk_id];\r\nconst char *parents[CLK_SRC_MAX];\r\nclk->div.reg = reg;\r\nclk->mux.reg = reg;\r\nclk->gate.reg = reg;\r\nlpc18xx_fill_parent_names(parents, clk->mux.table, clk->n_parents);\r\nreturn clk_register_composite(NULL, name, parents, clk->n_parents,\r\n&clk->mux.hw, &clk_mux_ops,\r\n&clk->div.hw, &clk_divider_ops,\r\n&clk->gate.hw, &lpc18xx_gate_ops, 0);\r\n}\r\nstatic struct clk *lpc18xx_register_base_clk(struct lpc18xx_cgu_base_clk *clk,\r\nvoid __iomem *reg_base, int n)\r\n{\r\nvoid __iomem *reg = reg_base + LPC18XX_CGU_BASE_CLK(n);\r\nconst char *name = clk_base_names[clk->clk_id];\r\nconst char *parents[CLK_SRC_MAX];\r\nif (clk->n_parents == 0)\r\nreturn ERR_PTR(-ENOENT);\r\nclk->mux.reg = reg;\r\nclk->gate.reg = reg;\r\nlpc18xx_fill_parent_names(parents, clk->mux.table, clk->n_parents);\r\nif (n == BASE_SAFE_CLK)\r\nreturn clk_register_composite(NULL, name, parents, clk->n_parents,\r\n&clk->mux.hw, &clk_mux_ops,\r\nNULL, NULL, NULL, NULL, 0);\r\nreturn clk_register_composite(NULL, name, parents, clk->n_parents,\r\n&clk->mux.hw, &clk_mux_ops,\r\nNULL, NULL,\r\n&clk->gate.hw, &lpc18xx_gate_ops, 0);\r\n}\r\nstatic struct clk *lpc18xx_cgu_register_pll(struct lpc18xx_cgu_pll_clk *clk,\r\nvoid __iomem *base)\r\n{\r\nconst char *name = clk_src_names[clk->clk_id];\r\nconst char *parents[CLK_SRC_MAX];\r\nclk->pll.reg = base;\r\nclk->mux.reg = base + clk->reg_offset + LPC18XX_CGU_PLL_CTRL_OFFSET;\r\nclk->gate.reg = base + clk->reg_offset + LPC18XX_CGU_PLL_CTRL_OFFSET;\r\nlpc18xx_fill_parent_names(parents, clk->mux.table, clk->n_parents);\r\nreturn clk_register_composite(NULL, name, parents, clk->n_parents,\r\n&clk->mux.hw, &clk_mux_ops,\r\n&clk->pll.hw, clk->pll_ops,\r\n&clk->gate.hw, &lpc18xx_gate_ops, 0);\r\n}\r\nstatic void __init lpc18xx_cgu_register_source_clks(struct device_node *np,\r\nvoid __iomem *base)\r\n{\r\nconst char *parents[CLK_SRC_MAX];\r\nstruct clk *clk;\r\nint i;\r\nclk = clk_register_fixed_rate(NULL, clk_src_names[CLK_SRC_IRC],\r\nNULL, 0, 12000000);\r\nif (IS_ERR(clk))\r\npr_warn("%s: failed to register irc clk\n", __func__);\r\nparents[0] = of_clk_get_parent_name(np, 0);\r\nclk = clk_register_gate(NULL, clk_src_names[CLK_SRC_OSC], parents[0],\r\n0, base + LPC18XX_CGU_XTAL_OSC_CTRL,\r\n0, CLK_GATE_SET_TO_DISABLE, NULL);\r\nif (IS_ERR(clk))\r\npr_warn("%s: failed to register osc clk\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(lpc18xx_cgu_src_clk_plls); i++) {\r\nclk = lpc18xx_cgu_register_pll(&lpc18xx_cgu_src_clk_plls[i],\r\nbase);\r\nif (IS_ERR(clk))\r\npr_warn("%s: failed to register pll (%d)\n", __func__, i);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(lpc18xx_cgu_src_clk_divs); i++) {\r\nclk = lpc18xx_cgu_register_div(&lpc18xx_cgu_src_clk_divs[i],\r\nbase, i);\r\nif (IS_ERR(clk))\r\npr_warn("%s: failed to register div %d\n", __func__, i);\r\n}\r\n}\r\nstatic void __init lpc18xx_cgu_register_base_clks(void __iomem *reg_base)\r\n{\r\nint i;\r\nfor (i = BASE_SAFE_CLK; i < BASE_CLK_MAX; i++) {\r\nclk_base[i] = lpc18xx_register_base_clk(&lpc18xx_cgu_base_clks[i],\r\nreg_base, i);\r\nif (IS_ERR(clk_base[i]) && PTR_ERR(clk_base[i]) != -ENOENT)\r\npr_warn("%s: register base clk %d failed\n", __func__, i);\r\n}\r\n}\r\nstatic void __init lpc18xx_cgu_init(struct device_node *np)\r\n{\r\nvoid __iomem *reg_base;\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base) {\r\npr_warn("%s: failed to map address range\n", __func__);\r\nreturn;\r\n}\r\nlpc18xx_cgu_register_source_clks(np, reg_base);\r\nlpc18xx_cgu_register_base_clks(reg_base);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_base_data);\r\n}
