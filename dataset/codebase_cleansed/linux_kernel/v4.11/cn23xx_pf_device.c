void cn23xx_dump_pf_initialized_regs(struct octeon_device *oct)\r\n{\r\nint i = 0;\r\nu32 regval = 0;\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%llx\n",\r\n"CN23XX_WIN_WR_MASK_REG", CVM_CAST64(CN23XX_WIN_WR_MASK_REG),\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_WIN_WR_MASK_REG)));\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_SCRATCH1", CVM_CAST64(CN23XX_SLI_SCRATCH1),\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_SCRATCH1)));\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_RST_SOFT_RST", CN23XX_RST_SOFT_RST,\r\nlio_pci_readq(oct, CN23XX_RST_SOFT_RST));\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_DPI_DMA_CONTROL", CN23XX_DPI_DMA_CONTROL,\r\nlio_pci_readq(oct, CN23XX_DPI_DMA_CONTROL));\r\nfor (i = 0; i < 6; i++) {\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_DPI_DMA_ENG_ENB", i,\r\nCN23XX_DPI_DMA_ENG_ENB(i),\r\nlio_pci_readq(oct, CN23XX_DPI_DMA_ENG_ENB(i)));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_DPI_DMA_ENG_BUF", i,\r\nCN23XX_DPI_DMA_ENG_BUF(i),\r\nlio_pci_readq(oct, CN23XX_DPI_DMA_ENG_BUF(i)));\r\n}\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n", "CN23XX_DPI_CTL",\r\nCN23XX_DPI_CTL, lio_pci_readq(oct, CN23XX_DPI_CTL));\r\npci_read_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, &regval);\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_CONFIG_PCIE_DEVCTL",\r\nCVM_CAST64(CN23XX_CONFIG_PCIE_DEVCTL), CVM_CAST64(regval));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_DPI_SLI_PRTX_CFG", oct->pcie_port,\r\nCN23XX_DPI_SLI_PRTX_CFG(oct->pcie_port),\r\nlio_pci_readq(oct, CN23XX_DPI_SLI_PRTX_CFG(oct->pcie_port)));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_S2M_PORTX_CTL", oct->pcie_port,\r\nCVM_CAST64(CN23XX_SLI_S2M_PORTX_CTL(oct->pcie_port)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_S2M_PORTX_CTL(oct->pcie_port))));\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_RING_RST", CVM_CAST64(CN23XX_SLI_PKT_IOQ_RING_RST),\r\n(u64)octeon_read_csr64(oct, CN23XX_SLI_PKT_IOQ_RING_RST));\r\nfor (i = 0; i < CN23XX_MAX_MACS; i++) {\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_PKT_MAC_RINFO64", i,\r\nCVM_CAST64(CN23XX_SLI_PKT_MAC_RINFO64(i, oct->pf_num)),\r\nCVM_CAST64(octeon_read_csr64\r\n(oct, CN23XX_SLI_PKT_MAC_RINFO64\r\n(i, oct->pf_num))));\r\n}\r\nfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_IQ_PKT_CONTROL64", i,\r\nCVM_CAST64(CN23XX_SLI_IQ_PKT_CONTROL64(i)),\r\nCVM_CAST64(octeon_read_csr64\r\n(oct, CN23XX_SLI_IQ_PKT_CONTROL64(i))));\r\n}\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_WMARK", CVM_CAST64(CN23XX_SLI_OQ_WMARK),\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_OQ_WMARK)));\r\nfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_PKT_CONTROL", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_PKT_CONTROL(i)),\r\nCVM_CAST64(octeon_read_csr(\r\noct, CN23XX_SLI_OQ_PKT_CONTROL(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_PKT_INT_LEVELS", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_PKT_INT_LEVELS(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_OQ_PKT_INT_LEVELS(i))));\r\n}\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"cn23xx->intr_enb_reg64",\r\nCVM_CAST64((long)(cn23xx->intr_enb_reg64)),\r\nCVM_CAST64(readq(cn23xx->intr_enb_reg64)));\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"cn23xx->intr_sum_reg64",\r\nCVM_CAST64((long)(cn23xx->intr_sum_reg64)),\r\nCVM_CAST64(readq(cn23xx->intr_sum_reg64)));\r\nfor (i = 0; i < CN23XX_MAX_INPUT_QUEUES; i++) {\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_IQ_BASE_ADDR64", i,\r\nCVM_CAST64(CN23XX_SLI_IQ_BASE_ADDR64(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_BASE_ADDR64(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_IQ_SIZE", i,\r\nCVM_CAST64(CN23XX_SLI_IQ_SIZE(i)),\r\nCVM_CAST64(octeon_read_csr\r\n(oct, CN23XX_SLI_IQ_SIZE(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_IQ_DOORBELL", i,\r\nCVM_CAST64(CN23XX_SLI_IQ_DOORBELL(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_DOORBELL(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_IQ_INSTR_COUNT64", i,\r\nCVM_CAST64(CN23XX_SLI_IQ_INSTR_COUNT64(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_INSTR_COUNT64(i))));\r\n}\r\nfor (i = 0; i < CN23XX_MAX_OUTPUT_QUEUES; i++) {\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_BASE_ADDR64", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_BASE_ADDR64(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_OQ_BASE_ADDR64(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_SIZE", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_SIZE(i)),\r\nCVM_CAST64(octeon_read_csr\r\n(oct, CN23XX_SLI_OQ_SIZE(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_BUFF_INFO_SIZE", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_BUFF_INFO_SIZE(i)),\r\nCVM_CAST64(octeon_read_csr(\r\noct, CN23XX_SLI_OQ_BUFF_INFO_SIZE(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_PKTS_SENT", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_PKTS_SENT(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_OQ_PKTS_SENT(i))));\r\ndev_dbg(&oct->pci_dev->dev, "%s(%d)[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_OQ_PKTS_CREDIT", i,\r\nCVM_CAST64(CN23XX_SLI_OQ_PKTS_CREDIT(i)),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_OQ_PKTS_CREDIT(i))));\r\n}\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_PKT_TIME_INT",\r\nCVM_CAST64(CN23XX_SLI_PKT_TIME_INT),\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_PKT_TIME_INT)));\r\ndev_dbg(&oct->pci_dev->dev, "%s[%llx] : 0x%016llx\n",\r\n"CN23XX_SLI_PKT_CNT_INT",\r\nCVM_CAST64(CN23XX_SLI_PKT_CNT_INT),\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_PKT_CNT_INT)));\r\n}\r\nstatic int cn23xx_pf_soft_reset(struct octeon_device *oct)\r\n{\r\nocteon_write_csr64(oct, CN23XX_WIN_WR_MASK_REG, 0xFF);\r\ndev_dbg(&oct->pci_dev->dev, "OCTEON[%d]: BIST enabled for CN23XX soft reset\n",\r\noct->octeon_id);\r\nocteon_write_csr64(oct, CN23XX_SLI_SCRATCH1, 0x1234ULL);\r\nlio_pci_readq(oct, CN23XX_RST_SOFT_RST);\r\nlio_pci_writeq(oct, 1, CN23XX_RST_SOFT_RST);\r\nmdelay(100);\r\nif (octeon_read_csr64(oct, CN23XX_SLI_SCRATCH1) == 0x1234ULL) {\r\ndev_err(&oct->pci_dev->dev, "OCTEON[%d]: Soft reset failed\n",\r\noct->octeon_id);\r\nreturn 1;\r\n}\r\ndev_dbg(&oct->pci_dev->dev, "OCTEON[%d]: Reset completed\n",\r\noct->octeon_id);\r\nocteon_write_csr64(oct, CN23XX_WIN_WR_MASK_REG, 0xFF);\r\nreturn 0;\r\n}\r\nstatic void cn23xx_enable_error_reporting(struct octeon_device *oct)\r\n{\r\nu32 regval;\r\nu32 uncorrectable_err_mask, corrtable_err_status;\r\npci_read_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, &regval);\r\nif (regval & CN23XX_CONFIG_PCIE_DEVCTL_MASK) {\r\nuncorrectable_err_mask = 0;\r\ncorrtable_err_status = 0;\r\npci_read_config_dword(oct->pci_dev,\r\nCN23XX_CONFIG_PCIE_UNCORRECT_ERR_MASK,\r\n&uncorrectable_err_mask);\r\npci_read_config_dword(oct->pci_dev,\r\nCN23XX_CONFIG_PCIE_CORRECT_ERR_STATUS,\r\n&corrtable_err_status);\r\ndev_err(&oct->pci_dev->dev, "PCI-E Fatal error detected;\n"\r\n"\tdev_ctl_status_reg = 0x%08x\n"\r\n"\tuncorrectable_error_mask_reg = 0x%08x\n"\r\n"\tcorrectable_error_status_reg = 0x%08x\n",\r\nregval, uncorrectable_err_mask,\r\ncorrtable_err_status);\r\n}\r\nregval |= 0xf;\r\ndev_dbg(&oct->pci_dev->dev, "OCTEON[%d]: Enabling PCI-E error reporting..\n",\r\noct->octeon_id);\r\npci_write_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, regval);\r\n}\r\nstatic u32 cn23xx_coprocessor_clock(struct octeon_device *oct)\r\n{\r\nreturn (((lio_pci_readq(oct, CN23XX_RST_BOOT) >> 24) & 0x3f) * 50);\r\n}\r\nu32 cn23xx_pf_get_oq_ticks(struct octeon_device *oct, u32 time_intr_in_us)\r\n{\r\nu32 oqticks_per_us = cn23xx_coprocessor_clock(oct);\r\noct->pfvf_hsword.coproc_tics_per_us = oqticks_per_us;\r\noqticks_per_us *= 1000;\r\noqticks_per_us /= 1024;\r\noqticks_per_us *= time_intr_in_us;\r\noqticks_per_us /= 1000;\r\nreturn oqticks_per_us;\r\n}\r\nstatic void cn23xx_setup_global_mac_regs(struct octeon_device *oct)\r\n{\r\nu16 mac_no = oct->pcie_port;\r\nu16 pf_num = oct->pf_num;\r\nu64 reg_val;\r\nu64 temp;\r\ndev_dbg(&oct->pci_dev->dev, "%s:Using pcie port %d\n",\r\n__func__, mac_no);\r\nreg_val =\r\nocteon_read_csr64(oct, CN23XX_SLI_PKT_MAC_RINFO64(mac_no, pf_num));\r\nif (oct->rev_id == OCTEON_CN23XX_REV_1_1) {\r\nreg_val = pf_num * CN23XX_MAX_RINGS_PER_PF_PASS_1_1;\r\n} else {\r\nreg_val = pf_num * CN23XX_MAX_RINGS_PER_PF;\r\n}\r\nreg_val = reg_val |\r\n(oct->sriov_info.trs << CN23XX_PKT_MAC_CTL_RINFO_TRS_BIT_POS);\r\ntemp = oct->sriov_info.rings_per_vf & 0xff;\r\nreg_val |= (temp << CN23XX_PKT_MAC_CTL_RINFO_RPVF_BIT_POS);\r\ntemp = oct->sriov_info.max_vfs & 0xff;\r\nreg_val |= (temp << CN23XX_PKT_MAC_CTL_RINFO_NVFS_BIT_POS);\r\nocteon_write_csr64(oct, CN23XX_SLI_PKT_MAC_RINFO64(mac_no, pf_num),\r\nreg_val);\r\ndev_dbg(&oct->pci_dev->dev, "SLI_PKT_MAC(%d)_PF(%d)_RINFO : 0x%016llx\n",\r\nmac_no, pf_num, (u64)octeon_read_csr64\r\n(oct, CN23XX_SLI_PKT_MAC_RINFO64(mac_no, pf_num)));\r\n}\r\nstatic int cn23xx_reset_io_queues(struct octeon_device *oct)\r\n{\r\nint ret_val = 0;\r\nu64 d64;\r\nu32 q_no, srn, ern;\r\nu32 loop = 1000;\r\nsrn = oct->sriov_info.pf_srn;\r\nern = srn + oct->sriov_info.num_pf_rings;\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nd64 = octeon_read_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nd64 = d64 | CN23XX_PKT_INPUT_CTL_RST;\r\nocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no), d64);\r\n}\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nu64 reg_val = octeon_read_csr64(oct,\r\nCN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nwhile ((READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_RST) &&\r\n!(READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_QUIET) &&\r\nloop--) {\r\nWRITE_ONCE(reg_val, octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no)));\r\n}\r\nif (!loop) {\r\ndev_err(&oct->pci_dev->dev,\r\n"clearing the reset reg failed or setting the quiet reg failed for qno: %u\n",\r\nq_no);\r\nreturn -1;\r\n}\r\nWRITE_ONCE(reg_val, READ_ONCE(reg_val) &\r\n~CN23XX_PKT_INPUT_CTL_RST);\r\nocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\r\nREAD_ONCE(reg_val));\r\nWRITE_ONCE(reg_val, octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no)));\r\nif (READ_ONCE(reg_val) & CN23XX_PKT_INPUT_CTL_RST) {\r\ndev_err(&oct->pci_dev->dev,\r\n"clearing the reset failed for qno: %u\n",\r\nq_no);\r\nret_val = -1;\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int cn23xx_pf_setup_global_input_regs(struct octeon_device *oct)\r\n{\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nstruct octeon_instr_queue *iq;\r\nu64 intr_threshold, reg_val;\r\nu32 q_no, ern, srn;\r\nu64 pf_num;\r\nu64 vf_num;\r\npf_num = oct->pf_num;\r\nsrn = oct->sriov_info.pf_srn;\r\nern = srn + oct->sriov_info.num_pf_rings;\r\nif (cn23xx_reset_io_queues(oct))\r\nreturn -1;\r\nfor (q_no = 0; q_no < ern; q_no++) {\r\nreg_val = oct->pcie_port << CN23XX_PKT_INPUT_CTL_MAC_NUM_POS;\r\nif (q_no < oct->sriov_info.pf_srn) {\r\nvf_num = q_no / oct->sriov_info.rings_per_vf;\r\nvf_num += 1;\r\n} else {\r\nvf_num = 0;\r\n}\r\nreg_val |= vf_num << CN23XX_PKT_INPUT_CTL_VF_NUM_POS;\r\nreg_val |= pf_num << CN23XX_PKT_INPUT_CTL_PF_NUM_POS;\r\nocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\r\nreg_val);\r\n}\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nvoid __iomem *inst_cnt_reg;\r\niq = oct->instr_queue[q_no];\r\nif (iq)\r\ninst_cnt_reg = iq->inst_cnt_reg;\r\nelse\r\ninst_cnt_reg = (u8 *)oct->mmio[0].hw_addr +\r\nCN23XX_SLI_IQ_INSTR_COUNT64(q_no);\r\nreg_val =\r\nocteon_read_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nreg_val |= CN23XX_PKT_INPUT_CTL_MASK;\r\nocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\r\nreg_val);\r\nintr_threshold = CFG_GET_IQ_INTR_PKT(cn23xx->conf) &\r\nCN23XX_PKT_IN_DONE_WMARK_MASK;\r\nwriteq((readq(inst_cnt_reg) &\r\n~(CN23XX_PKT_IN_DONE_WMARK_MASK <<\r\nCN23XX_PKT_IN_DONE_WMARK_BIT_POS)) |\r\n(intr_threshold << CN23XX_PKT_IN_DONE_WMARK_BIT_POS),\r\ninst_cnt_reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cn23xx_pf_setup_global_output_regs(struct octeon_device *oct)\r\n{\r\nu32 reg_val;\r\nu32 q_no, ern, srn;\r\nu64 time_threshold;\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nsrn = oct->sriov_info.pf_srn;\r\nern = srn + oct->sriov_info.num_pf_rings;\r\nif (CFG_GET_IS_SLI_BP_ON(cn23xx->conf)) {\r\nocteon_write_csr64(oct, CN23XX_SLI_OQ_WMARK, 32);\r\n} else {\r\nocteon_write_csr64(oct, CN23XX_SLI_OQ_WMARK, 0);\r\n}\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nreg_val = octeon_read_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no));\r\nreg_val |=\r\n(CN23XX_PKT_OUTPUT_CTL_IPTR | CN23XX_PKT_OUTPUT_CTL_DPTR);\r\nreg_val &= ~(CN23XX_PKT_OUTPUT_CTL_BMODE);\r\nreg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ROR_P);\r\nreg_val &= ~(CN23XX_PKT_OUTPUT_CTL_NSR_P);\r\n#ifdef __LITTLE_ENDIAN_BITFIELD\r\nreg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ES_P);\r\n#else\r\nreg_val |= (CN23XX_PKT_OUTPUT_CTL_ES_P);\r\n#endif\r\nreg_val &= ~(CN23XX_PKT_OUTPUT_CTL_ROR);\r\nreg_val &= ~(CN23XX_PKT_OUTPUT_CTL_NSR);\r\nreg_val |= (CN23XX_PKT_OUTPUT_CTL_ES);\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no), reg_val);\r\ntime_threshold = cn23xx_pf_get_oq_ticks(\r\noct, (u32)CFG_GET_OQ_INTR_TIME(cn23xx->conf));\r\nocteon_write_csr64(oct, CN23XX_SLI_OQ_PKT_INT_LEVELS(q_no),\r\n(CFG_GET_OQ_INTR_PKT(cn23xx->conf) |\r\n(time_threshold << 32)));\r\n}\r\nwriteq(0x40, (u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OQ_WMARK);\r\nif ((oct->rev_id == OCTEON_CN23XX_REV_1_0) ||\r\n(oct->rev_id == OCTEON_CN23XX_REV_1_1))\r\nwriteq(readq((u8 *)oct->mmio[0].hw_addr +\r\nCN23XX_SLI_GBL_CONTROL) | 0x2,\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_GBL_CONTROL);\r\nif (oct->pf_num)\r\nwriteq(0xffffffffffffffffULL,\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OUT_BP_EN2_W1S);\r\nelse\r\nwriteq(0xffffffffffffffffULL,\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OUT_BP_EN_W1S);\r\n}\r\nstatic int cn23xx_setup_pf_device_regs(struct octeon_device *oct)\r\n{\r\ncn23xx_enable_error_reporting(oct);\r\ncn23xx_setup_global_mac_regs(oct);\r\nif (cn23xx_pf_setup_global_input_regs(oct))\r\nreturn -1;\r\ncn23xx_pf_setup_global_output_regs(oct);\r\nocteon_write_csr64(oct, CN23XX_SLI_WINDOW_CTL,\r\nCN23XX_SLI_WINDOW_CTL_DEFAULT);\r\nocteon_write_csr64(oct, CN23XX_SLI_PKT_IN_JABBER, CN23XX_INPUT_JABBER);\r\nreturn 0;\r\n}\r\nstatic void cn23xx_setup_iq_regs(struct octeon_device *oct, u32 iq_no)\r\n{\r\nstruct octeon_instr_queue *iq = oct->instr_queue[iq_no];\r\nu64 pkt_in_done;\r\niq_no += oct->sriov_info.pf_srn;\r\nocteon_write_csr64(oct, CN23XX_SLI_IQ_BASE_ADDR64(iq_no),\r\niq->base_addr_dma);\r\nocteon_write_csr(oct, CN23XX_SLI_IQ_SIZE(iq_no), iq->max_count);\r\niq->doorbell_reg =\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_IQ_DOORBELL(iq_no);\r\niq->inst_cnt_reg =\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_IQ_INSTR_COUNT64(iq_no);\r\ndev_dbg(&oct->pci_dev->dev, "InstQ[%d]:dbell reg @ 0x%p instcnt_reg @ 0x%p\n",\r\niq_no, iq->doorbell_reg, iq->inst_cnt_reg);\r\npkt_in_done = readq(iq->inst_cnt_reg);\r\nif (oct->msix_on) {\r\nwriteq((pkt_in_done | CN23XX_INTR_CINT_ENB),\r\niq->inst_cnt_reg);\r\n} else {\r\nwriteq(pkt_in_done, iq->inst_cnt_reg);\r\n}\r\niq->reset_instr_cnt = 0;\r\n}\r\nstatic void cn23xx_setup_oq_regs(struct octeon_device *oct, u32 oq_no)\r\n{\r\nu32 reg_val;\r\nstruct octeon_droq *droq = oct->droq[oq_no];\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nu64 time_threshold;\r\nu64 cnt_threshold;\r\noq_no += oct->sriov_info.pf_srn;\r\nocteon_write_csr64(oct, CN23XX_SLI_OQ_BASE_ADDR64(oq_no),\r\ndroq->desc_ring_dma);\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_SIZE(oq_no), droq->max_count);\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_BUFF_INFO_SIZE(oq_no),\r\n(droq->buffer_size | (OCT_RH_SIZE << 16)));\r\ndroq->pkts_sent_reg =\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OQ_PKTS_SENT(oq_no);\r\ndroq->pkts_credit_reg =\r\n(u8 *)oct->mmio[0].hw_addr + CN23XX_SLI_OQ_PKTS_CREDIT(oq_no);\r\nif (!oct->msix_on) {\r\nreg_val =\r\nocteon_read_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no));\r\nreg_val |= CN23XX_PKT_OUTPUT_CTL_TENB;\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no),\r\nreg_val);\r\nreg_val =\r\nocteon_read_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no));\r\nreg_val |= CN23XX_PKT_OUTPUT_CTL_CENB;\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(oq_no),\r\nreg_val);\r\n} else {\r\ntime_threshold = cn23xx_pf_get_oq_ticks(\r\noct, (u32)CFG_GET_OQ_INTR_TIME(cn23xx->conf));\r\ncnt_threshold = (u32)CFG_GET_OQ_INTR_PKT(cn23xx->conf);\r\nocteon_write_csr64(\r\noct, CN23XX_SLI_OQ_PKT_INT_LEVELS(oq_no),\r\n((time_threshold << 32 | cnt_threshold)));\r\n}\r\n}\r\nstatic void cn23xx_pf_mbox_thread(struct work_struct *work)\r\n{\r\nstruct cavium_wk *wk = (struct cavium_wk *)work;\r\nstruct octeon_mbox *mbox = (struct octeon_mbox *)wk->ctxptr;\r\nstruct octeon_device *oct = mbox->oct_dev;\r\nu64 mbox_int_val, val64;\r\nu32 q_no, i;\r\nif (oct->rev_id < OCTEON_CN23XX_REV_1_1) {\r\nmbox_int_val = readq(mbox->mbox_int_reg);\r\nwriteq(mbox_int_val, mbox->mbox_int_reg);\r\nfor (i = 0; i < oct->sriov_info.num_vfs_alloced; i++) {\r\nq_no = i * oct->sriov_info.rings_per_vf;\r\nval64 = readq(oct->mbox[q_no]->mbox_write_reg);\r\nif (val64 && (val64 != OCTEON_PFVFACK)) {\r\nif (octeon_mbox_read(oct->mbox[q_no]))\r\nocteon_mbox_process_message(\r\noct->mbox[q_no]);\r\n}\r\n}\r\nschedule_delayed_work(&wk->work, msecs_to_jiffies(10));\r\n} else {\r\nocteon_mbox_process_message(mbox);\r\n}\r\n}\r\nstatic int cn23xx_setup_pf_mbox(struct octeon_device *oct)\r\n{\r\nstruct octeon_mbox *mbox = NULL;\r\nu16 mac_no = oct->pcie_port;\r\nu16 pf_num = oct->pf_num;\r\nu32 q_no, i;\r\nif (!oct->sriov_info.max_vfs)\r\nreturn 0;\r\nfor (i = 0; i < oct->sriov_info.max_vfs; i++) {\r\nq_no = i * oct->sriov_info.rings_per_vf;\r\nmbox = vmalloc(sizeof(*mbox));\r\nif (!mbox)\r\ngoto free_mbox;\r\nmemset(mbox, 0, sizeof(struct octeon_mbox));\r\nspin_lock_init(&mbox->lock);\r\nmbox->oct_dev = oct;\r\nmbox->q_no = q_no;\r\nmbox->state = OCTEON_MBOX_STATE_IDLE;\r\nmbox->mbox_int_reg = (u8 *)oct->mmio[0].hw_addr +\r\nCN23XX_SLI_MAC_PF_MBOX_INT(mac_no, pf_num);\r\nmbox->mbox_write_reg = (u8 *)oct->mmio[0].hw_addr +\r\nCN23XX_SLI_PKT_PF_VF_MBOX_SIG(q_no, 0);\r\nmbox->mbox_read_reg = (u8 *)oct->mmio[0].hw_addr +\r\nCN23XX_SLI_PKT_PF_VF_MBOX_SIG(q_no, 1);\r\nINIT_DELAYED_WORK(&mbox->mbox_poll_wk.work,\r\ncn23xx_pf_mbox_thread);\r\nmbox->mbox_poll_wk.ctxptr = (void *)mbox;\r\noct->mbox[q_no] = mbox;\r\nwriteq(OCTEON_PFVFSIG, mbox->mbox_read_reg);\r\n}\r\nif (oct->rev_id < OCTEON_CN23XX_REV_1_1)\r\nschedule_delayed_work(&oct->mbox[0]->mbox_poll_wk.work,\r\nmsecs_to_jiffies(0));\r\nreturn 0;\r\nfree_mbox:\r\nwhile (i) {\r\ni--;\r\nvfree(oct->mbox[i]);\r\n}\r\nreturn 1;\r\n}\r\nstatic int cn23xx_free_pf_mbox(struct octeon_device *oct)\r\n{\r\nu32 q_no, i;\r\nif (!oct->sriov_info.max_vfs)\r\nreturn 0;\r\nfor (i = 0; i < oct->sriov_info.max_vfs; i++) {\r\nq_no = i * oct->sriov_info.rings_per_vf;\r\ncancel_delayed_work_sync(\r\n&oct->mbox[q_no]->mbox_poll_wk.work);\r\nvfree(oct->mbox[q_no]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cn23xx_enable_io_queues(struct octeon_device *oct)\r\n{\r\nu64 reg_val;\r\nu32 srn, ern, q_no;\r\nu32 loop = 1000;\r\nsrn = oct->sriov_info.pf_srn;\r\nern = srn + oct->num_iqs;\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nif (oct->io_qmask.iq64B & BIT_ULL(q_no - srn)) {\r\nreg_val = octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nreg_val = reg_val | CN23XX_PKT_INPUT_CTL_IS_64B;\r\nocteon_write_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no), reg_val);\r\n}\r\nif (oct->io_qmask.iq & BIT_ULL(q_no - srn)) {\r\nreg_val = octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nif (reg_val & CN23XX_PKT_INPUT_CTL_RST) {\r\nwhile ((reg_val & CN23XX_PKT_INPUT_CTL_RST) &&\r\n!(reg_val &\r\nCN23XX_PKT_INPUT_CTL_QUIET) &&\r\n--loop) {\r\nreg_val = octeon_read_csr64(\r\noct,\r\nCN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\n}\r\nif (!loop) {\r\ndev_err(&oct->pci_dev->dev,\r\n"clearing the reset reg failed or setting the quiet reg failed for qno: %u\n",\r\nq_no);\r\nreturn -1;\r\n}\r\nreg_val = reg_val & ~CN23XX_PKT_INPUT_CTL_RST;\r\nocteon_write_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\r\nreg_val);\r\nreg_val = octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nif (reg_val & CN23XX_PKT_INPUT_CTL_RST) {\r\ndev_err(&oct->pci_dev->dev,\r\n"clearing the reset failed for qno: %u\n",\r\nq_no);\r\nreturn -1;\r\n}\r\n}\r\nreg_val = octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no));\r\nreg_val = reg_val | CN23XX_PKT_INPUT_CTL_RING_ENB;\r\nocteon_write_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no), reg_val);\r\n}\r\n}\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nu32 reg_val;\r\nif (oct->io_qmask.oq & BIT_ULL(q_no - srn)) {\r\nreg_val = octeon_read_csr(\r\noct, CN23XX_SLI_OQ_PKT_CONTROL(q_no));\r\nreg_val = reg_val | CN23XX_PKT_OUTPUT_CTL_RING_ENB;\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_PKT_CONTROL(q_no),\r\nreg_val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cn23xx_disable_io_queues(struct octeon_device *oct)\r\n{\r\nint q_no, loop;\r\nu64 d64;\r\nu32 d32;\r\nu32 srn, ern;\r\nsrn = oct->sriov_info.pf_srn;\r\nern = srn + oct->num_iqs;\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nloop = HZ;\r\nWRITE_ONCE(d64, octeon_read_csr64(\r\noct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no)));\r\nWRITE_ONCE(d64, READ_ONCE(d64) &\r\n(~(CN23XX_PKT_INPUT_CTL_RING_ENB)));\r\nWRITE_ONCE(d64, READ_ONCE(d64) | CN23XX_PKT_INPUT_CTL_RST);\r\nocteon_write_csr64(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\r\nREAD_ONCE(d64));\r\nWRITE_ONCE(d64, octeon_read_csr64(\r\noct, CN23XX_SLI_PKT_IOQ_RING_RST));\r\nwhile (!(READ_ONCE(d64) & BIT_ULL(q_no)) && loop--) {\r\nWRITE_ONCE(d64, octeon_read_csr64(\r\noct, CN23XX_SLI_PKT_IOQ_RING_RST));\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nocteon_write_csr(oct, CN23XX_SLI_IQ_DOORBELL(q_no), 0xFFFFFFFF);\r\nwhile (octeon_read_csr64(oct, CN23XX_SLI_IQ_DOORBELL(q_no)) &&\r\nloop--) {\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nfor (q_no = srn; q_no < ern; q_no++) {\r\nloop = HZ;\r\nWRITE_ONCE(d64, octeon_read_csr64(\r\noct, CN23XX_SLI_PKT_IOQ_RING_RST));\r\nwhile (!(READ_ONCE(d64) & BIT_ULL(q_no)) && loop--) {\r\nWRITE_ONCE(d64, octeon_read_csr64(\r\noct, CN23XX_SLI_PKT_IOQ_RING_RST));\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_PKTS_CREDIT(q_no),\r\n0xFFFFFFFF);\r\nwhile (octeon_read_csr64(oct,\r\nCN23XX_SLI_OQ_PKTS_CREDIT(q_no)) &&\r\nloop--) {\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nWRITE_ONCE(d32, octeon_read_csr(\r\noct, CN23XX_SLI_OQ_PKTS_SENT(q_no)));\r\nocteon_write_csr(oct, CN23XX_SLI_OQ_PKTS_SENT(q_no),\r\nREAD_ONCE(d32));\r\n}\r\n}\r\nstatic u64 cn23xx_pf_msix_interrupt_handler(void *dev)\r\n{\r\nstruct octeon_ioq_vector *ioq_vector = (struct octeon_ioq_vector *)dev;\r\nstruct octeon_device *oct = ioq_vector->oct_dev;\r\nu64 pkts_sent;\r\nu64 ret = 0;\r\nstruct octeon_droq *droq = oct->droq[ioq_vector->droq_index];\r\ndev_dbg(&oct->pci_dev->dev, "In %s octeon_dev @ %p\n", __func__, oct);\r\nif (!droq) {\r\ndev_err(&oct->pci_dev->dev, "23XX bringup FIXME: oct pfnum:%d ioq_vector->ioq_num :%d droq is NULL\n",\r\noct->pf_num, ioq_vector->ioq_num);\r\nreturn 0;\r\n}\r\npkts_sent = readq(droq->pkts_sent_reg);\r\nif (!pkts_sent || (pkts_sent == 0xFFFFFFFFFFFFFFFFULL))\r\nreturn ret;\r\nif ((pkts_sent & CN23XX_INTR_PO_INT) ||\r\n(pkts_sent & CN23XX_INTR_PI_INT)) {\r\nif (pkts_sent & CN23XX_INTR_PO_INT)\r\nret |= MSIX_PO_INT;\r\n}\r\nif (pkts_sent & CN23XX_INTR_PI_INT)\r\nret |= MSIX_PI_INT;\r\nreturn ret;\r\n}\r\nstatic void cn23xx_handle_pf_mbox_intr(struct octeon_device *oct)\r\n{\r\nstruct delayed_work *work;\r\nu64 mbox_int_val;\r\nu32 i, q_no;\r\nmbox_int_val = readq(oct->mbox[0]->mbox_int_reg);\r\nfor (i = 0; i < oct->sriov_info.num_vfs_alloced; i++) {\r\nq_no = i * oct->sriov_info.rings_per_vf;\r\nif (mbox_int_val & BIT_ULL(q_no)) {\r\nwriteq(BIT_ULL(q_no),\r\noct->mbox[0]->mbox_int_reg);\r\nif (octeon_mbox_read(oct->mbox[q_no])) {\r\nwork = &oct->mbox[q_no]->mbox_poll_wk.work;\r\nschedule_delayed_work(work,\r\nmsecs_to_jiffies(0));\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t cn23xx_interrupt_handler(void *dev)\r\n{\r\nstruct octeon_device *oct = (struct octeon_device *)dev;\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nu64 intr64;\r\ndev_dbg(&oct->pci_dev->dev, "In %s octeon_dev @ %p\n", __func__, oct);\r\nintr64 = readq(cn23xx->intr_sum_reg64);\r\noct->int_status = 0;\r\nif (intr64 & CN23XX_INTR_ERR)\r\ndev_err(&oct->pci_dev->dev, "OCTEON[%d]: Error Intr: 0x%016llx\n",\r\noct->octeon_id, CVM_CAST64(intr64));\r\nif (intr64 & CN23XX_INTR_VF_MBOX)\r\ncn23xx_handle_pf_mbox_intr(oct);\r\nif (oct->msix_on != LIO_FLAG_MSIX_ENABLED) {\r\nif (intr64 & CN23XX_INTR_PKT_DATA)\r\noct->int_status |= OCT_DEV_INTR_PKT_DATA;\r\n}\r\nif (intr64 & (CN23XX_INTR_DMA0_FORCE))\r\noct->int_status |= OCT_DEV_INTR_DMA0_FORCE;\r\nif (intr64 & (CN23XX_INTR_DMA1_FORCE))\r\noct->int_status |= OCT_DEV_INTR_DMA1_FORCE;\r\nwriteq(intr64, cn23xx->intr_sum_reg64);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cn23xx_bar1_idx_setup(struct octeon_device *oct, u64 core_addr,\r\nu32 idx, int valid)\r\n{\r\nu64 bar1;\r\nu64 reg_adr;\r\nif (!valid) {\r\nreg_adr = lio_pci_readq(\r\noct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\r\nWRITE_ONCE(bar1, reg_adr);\r\nlio_pci_writeq(oct, (READ_ONCE(bar1) & 0xFFFFFFFEULL),\r\nCN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\r\nreg_adr = lio_pci_readq(\r\noct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\r\nWRITE_ONCE(bar1, reg_adr);\r\nreturn;\r\n}\r\nlio_pci_writeq(oct, (((core_addr >> 22) << 4) | PCI_BAR1_MASK),\r\nCN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\r\nWRITE_ONCE(bar1, lio_pci_readq(\r\noct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx)));\r\n}\r\nstatic void cn23xx_bar1_idx_write(struct octeon_device *oct, u32 idx, u32 mask)\r\n{\r\nlio_pci_writeq(oct, mask,\r\nCN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\r\n}\r\nstatic u32 cn23xx_bar1_idx_read(struct octeon_device *oct, u32 idx)\r\n{\r\nreturn (u32)lio_pci_readq(\r\noct, CN23XX_PEM_BAR1_INDEX_REG(oct->pcie_port, idx));\r\n}\r\nstatic u32 cn23xx_update_read_index(struct octeon_instr_queue *iq)\r\n{\r\nu32 new_idx;\r\nu32 last_done;\r\nu32 pkt_in_done = readl(iq->inst_cnt_reg);\r\nlast_done = pkt_in_done - iq->pkt_in_done;\r\niq->pkt_in_done = pkt_in_done;\r\nnew_idx = (iq->octeon_read_index +\r\n(u32)(last_done & CN23XX_PKT_IN_DONE_CNT_MASK)) %\r\niq->max_count;\r\nreturn new_idx;\r\n}\r\nstatic void cn23xx_enable_pf_interrupt(struct octeon_device *oct, u8 intr_flag)\r\n{\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nu64 intr_val = 0;\r\nif (intr_flag == OCTEON_ALL_INTR) {\r\nwriteq(cn23xx->intr_mask64, cn23xx->intr_enb_reg64);\r\n} else if (intr_flag & OCTEON_OUTPUT_INTR) {\r\nintr_val = readq(cn23xx->intr_enb_reg64);\r\nintr_val |= CN23XX_INTR_PKT_DATA;\r\nwriteq(intr_val, cn23xx->intr_enb_reg64);\r\n} else if ((intr_flag & OCTEON_MBOX_INTR) &&\r\n(oct->sriov_info.max_vfs > 0)) {\r\nif (oct->rev_id >= OCTEON_CN23XX_REV_1_1) {\r\nintr_val = readq(cn23xx->intr_enb_reg64);\r\nintr_val |= CN23XX_INTR_VF_MBOX;\r\nwriteq(intr_val, cn23xx->intr_enb_reg64);\r\n}\r\n}\r\n}\r\nstatic void cn23xx_disable_pf_interrupt(struct octeon_device *oct, u8 intr_flag)\r\n{\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nu64 intr_val = 0;\r\nif (intr_flag == OCTEON_ALL_INTR) {\r\nwriteq(0, cn23xx->intr_enb_reg64);\r\n} else if (intr_flag & OCTEON_OUTPUT_INTR) {\r\nintr_val = readq(cn23xx->intr_enb_reg64);\r\nintr_val &= ~CN23XX_INTR_PKT_DATA;\r\nwriteq(intr_val, cn23xx->intr_enb_reg64);\r\n} else if ((intr_flag & OCTEON_MBOX_INTR) &&\r\n(oct->sriov_info.max_vfs > 0)) {\r\nif (oct->rev_id >= OCTEON_CN23XX_REV_1_1) {\r\nintr_val = readq(cn23xx->intr_enb_reg64);\r\nintr_val &= ~CN23XX_INTR_VF_MBOX;\r\nwriteq(intr_val, cn23xx->intr_enb_reg64);\r\n}\r\n}\r\n}\r\nstatic void cn23xx_get_pcie_qlmport(struct octeon_device *oct)\r\n{\r\noct->pcie_port = (octeon_read_csr(oct, CN23XX_SLI_MAC_NUMBER)) & 0xff;\r\ndev_dbg(&oct->pci_dev->dev, "OCTEON: CN23xx uses PCIE Port %d\n",\r\noct->pcie_port);\r\n}\r\nstatic void cn23xx_get_pf_num(struct octeon_device *oct)\r\n{\r\nu32 fdl_bit = 0;\r\npci_read_config_dword(oct->pci_dev, CN23XX_PCIE_SRIOV_FDL, &fdl_bit);\r\noct->pf_num = ((fdl_bit >> CN23XX_PCIE_SRIOV_FDL_BIT_POS) &\r\nCN23XX_PCIE_SRIOV_FDL_MASK);\r\n}\r\nstatic void cn23xx_setup_reg_address(struct octeon_device *oct)\r\n{\r\nu8 __iomem *bar0_pciaddr = oct->mmio[0].hw_addr;\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\noct->reg_list.pci_win_wr_addr_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_ADDR_HI);\r\noct->reg_list.pci_win_wr_addr_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_ADDR_LO);\r\noct->reg_list.pci_win_wr_addr =\r\n(u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_ADDR64);\r\noct->reg_list.pci_win_rd_addr_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_ADDR_HI);\r\noct->reg_list.pci_win_rd_addr_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_ADDR_LO);\r\noct->reg_list.pci_win_rd_addr =\r\n(u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_ADDR64);\r\noct->reg_list.pci_win_wr_data_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_DATA_HI);\r\noct->reg_list.pci_win_wr_data_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_DATA_LO);\r\noct->reg_list.pci_win_wr_data =\r\n(u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_WR_DATA64);\r\noct->reg_list.pci_win_rd_data_hi =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_DATA_HI);\r\noct->reg_list.pci_win_rd_data_lo =\r\n(u32 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_DATA_LO);\r\noct->reg_list.pci_win_rd_data =\r\n(u64 __iomem *)(bar0_pciaddr + CN23XX_WIN_RD_DATA64);\r\ncn23xx_get_pcie_qlmport(oct);\r\ncn23xx->intr_mask64 = CN23XX_INTR_MASK;\r\nif (!oct->msix_on)\r\ncn23xx->intr_mask64 |= CN23XX_INTR_PKT_TIME;\r\nif (oct->rev_id >= OCTEON_CN23XX_REV_1_1)\r\ncn23xx->intr_mask64 |= CN23XX_INTR_VF_MBOX;\r\ncn23xx->intr_sum_reg64 =\r\nbar0_pciaddr +\r\nCN23XX_SLI_MAC_PF_INT_SUM64(oct->pcie_port, oct->pf_num);\r\ncn23xx->intr_enb_reg64 =\r\nbar0_pciaddr +\r\nCN23XX_SLI_MAC_PF_INT_ENB64(oct->pcie_port, oct->pf_num);\r\n}\r\nstatic int cn23xx_sriov_config(struct octeon_device *oct)\r\n{\r\nstruct octeon_cn23xx_pf *cn23xx = (struct octeon_cn23xx_pf *)oct->chip;\r\nu32 max_rings, total_rings, max_vfs, rings_per_vf;\r\nu32 pf_srn, num_pf_rings;\r\nu32 max_possible_vfs;\r\ncn23xx->conf =\r\n(struct octeon_config *)oct_get_config_info(oct, LIO_23XX);\r\nswitch (oct->rev_id) {\r\ncase OCTEON_CN23XX_REV_1_0:\r\nmax_rings = CN23XX_MAX_RINGS_PER_PF_PASS_1_0;\r\nmax_possible_vfs = CN23XX_MAX_VFS_PER_PF_PASS_1_0;\r\nbreak;\r\ncase OCTEON_CN23XX_REV_1_1:\r\nmax_rings = CN23XX_MAX_RINGS_PER_PF_PASS_1_1;\r\nmax_possible_vfs = CN23XX_MAX_VFS_PER_PF_PASS_1_1;\r\nbreak;\r\ndefault:\r\nmax_rings = CN23XX_MAX_RINGS_PER_PF;\r\nmax_possible_vfs = CN23XX_MAX_VFS_PER_PF;\r\nbreak;\r\n}\r\nif (max_rings <= num_present_cpus())\r\nnum_pf_rings = 1;\r\nelse\r\nnum_pf_rings = num_present_cpus();\r\n#ifdef CONFIG_PCI_IOV\r\nmax_vfs = min_t(u32,\r\n(max_rings - num_pf_rings), max_possible_vfs);\r\nrings_per_vf = 1;\r\n#else\r\nmax_vfs = 0;\r\nrings_per_vf = 0;\r\n#endif\r\ntotal_rings = num_pf_rings + max_vfs;\r\npf_srn = total_rings - num_pf_rings;\r\noct->sriov_info.trs = total_rings;\r\noct->sriov_info.max_vfs = max_vfs;\r\noct->sriov_info.rings_per_vf = rings_per_vf;\r\noct->sriov_info.pf_srn = pf_srn;\r\noct->sriov_info.num_pf_rings = num_pf_rings;\r\ndev_notice(&oct->pci_dev->dev, "trs:%d max_vfs:%d rings_per_vf:%d pf_srn:%d num_pf_rings:%d\n",\r\noct->sriov_info.trs, oct->sriov_info.max_vfs,\r\noct->sriov_info.rings_per_vf, oct->sriov_info.pf_srn,\r\noct->sriov_info.num_pf_rings);\r\noct->sriov_info.sriov_enabled = 0;\r\nreturn 0;\r\n}\r\nint setup_cn23xx_octeon_pf_device(struct octeon_device *oct)\r\n{\r\nif (octeon_map_pci_barx(oct, 0, 0))\r\nreturn 1;\r\nif (octeon_map_pci_barx(oct, 1, MAX_BAR1_IOREMAP_SIZE)) {\r\ndev_err(&oct->pci_dev->dev, "%s CN23XX BAR1 map failed\n",\r\n__func__);\r\nocteon_unmap_pci_barx(oct, 0);\r\nreturn 1;\r\n}\r\ncn23xx_get_pf_num(oct);\r\nif (cn23xx_sriov_config(oct)) {\r\nocteon_unmap_pci_barx(oct, 0);\r\nocteon_unmap_pci_barx(oct, 1);\r\nreturn 1;\r\n}\r\nocteon_write_csr64(oct, CN23XX_SLI_MAC_CREDIT_CNT, 0x3F802080802080ULL);\r\noct->fn_list.setup_iq_regs = cn23xx_setup_iq_regs;\r\noct->fn_list.setup_oq_regs = cn23xx_setup_oq_regs;\r\noct->fn_list.setup_mbox = cn23xx_setup_pf_mbox;\r\noct->fn_list.free_mbox = cn23xx_free_pf_mbox;\r\noct->fn_list.process_interrupt_regs = cn23xx_interrupt_handler;\r\noct->fn_list.msix_interrupt_handler = cn23xx_pf_msix_interrupt_handler;\r\noct->fn_list.soft_reset = cn23xx_pf_soft_reset;\r\noct->fn_list.setup_device_regs = cn23xx_setup_pf_device_regs;\r\noct->fn_list.update_iq_read_idx = cn23xx_update_read_index;\r\noct->fn_list.bar1_idx_setup = cn23xx_bar1_idx_setup;\r\noct->fn_list.bar1_idx_write = cn23xx_bar1_idx_write;\r\noct->fn_list.bar1_idx_read = cn23xx_bar1_idx_read;\r\noct->fn_list.enable_interrupt = cn23xx_enable_pf_interrupt;\r\noct->fn_list.disable_interrupt = cn23xx_disable_pf_interrupt;\r\noct->fn_list.enable_io_queues = cn23xx_enable_io_queues;\r\noct->fn_list.disable_io_queues = cn23xx_disable_io_queues;\r\ncn23xx_setup_reg_address(oct);\r\noct->coproc_clock_rate = 1000000ULL * cn23xx_coprocessor_clock(oct);\r\nreturn 0;\r\n}\r\nint validate_cn23xx_pf_config_info(struct octeon_device *oct,\r\nstruct octeon_config *conf23xx)\r\n{\r\nif (CFG_GET_IQ_MAX_Q(conf23xx) > CN23XX_MAX_INPUT_QUEUES) {\r\ndev_err(&oct->pci_dev->dev, "%s: Num IQ (%d) exceeds Max (%d)\n",\r\n__func__, CFG_GET_IQ_MAX_Q(conf23xx),\r\nCN23XX_MAX_INPUT_QUEUES);\r\nreturn 1;\r\n}\r\nif (CFG_GET_OQ_MAX_Q(conf23xx) > CN23XX_MAX_OUTPUT_QUEUES) {\r\ndev_err(&oct->pci_dev->dev, "%s: Num OQ (%d) exceeds Max (%d)\n",\r\n__func__, CFG_GET_OQ_MAX_Q(conf23xx),\r\nCN23XX_MAX_OUTPUT_QUEUES);\r\nreturn 1;\r\n}\r\nif (CFG_GET_IQ_INSTR_TYPE(conf23xx) != OCTEON_32BYTE_INSTR &&\r\nCFG_GET_IQ_INSTR_TYPE(conf23xx) != OCTEON_64BYTE_INSTR) {\r\ndev_err(&oct->pci_dev->dev, "%s: Invalid instr type for IQ\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nif (!(CFG_GET_OQ_INFO_PTR(conf23xx)) ||\r\n!(CFG_GET_OQ_REFILL_THRESHOLD(conf23xx))) {\r\ndev_err(&oct->pci_dev->dev, "%s: Invalid parameter for OQ\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nif (!(CFG_GET_OQ_INTR_TIME(conf23xx))) {\r\ndev_err(&oct->pci_dev->dev, "%s: Invalid parameter for OQ\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid cn23xx_dump_iq_regs(struct octeon_device *oct)\r\n{\r\nu32 regval, q_no;\r\ndev_dbg(&oct->pci_dev->dev, "SLI_IQ_DOORBELL_0 [0x%x]: 0x%016llx\n",\r\nCN23XX_SLI_IQ_DOORBELL(0),\r\nCVM_CAST64(octeon_read_csr64\r\n(oct, CN23XX_SLI_IQ_DOORBELL(0))));\r\ndev_dbg(&oct->pci_dev->dev, "SLI_IQ_BASEADDR_0 [0x%x]: 0x%016llx\n",\r\nCN23XX_SLI_IQ_BASE_ADDR64(0),\r\nCVM_CAST64(octeon_read_csr64\r\n(oct, CN23XX_SLI_IQ_BASE_ADDR64(0))));\r\ndev_dbg(&oct->pci_dev->dev, "SLI_IQ_FIFO_RSIZE_0 [0x%x]: 0x%016llx\n",\r\nCN23XX_SLI_IQ_SIZE(0),\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_IQ_SIZE(0))));\r\ndev_dbg(&oct->pci_dev->dev, "SLI_CTL_STATUS [0x%x]: 0x%016llx\n",\r\nCN23XX_SLI_CTL_STATUS,\r\nCVM_CAST64(octeon_read_csr64(oct, CN23XX_SLI_CTL_STATUS)));\r\nfor (q_no = 0; q_no < CN23XX_MAX_INPUT_QUEUES; q_no++) {\r\ndev_dbg(&oct->pci_dev->dev, "SLI_PKT[%d]_INPUT_CTL [0x%x]: 0x%016llx\n",\r\nq_no, CN23XX_SLI_IQ_PKT_CONTROL64(q_no),\r\nCVM_CAST64(octeon_read_csr64\r\n(oct, CN23XX_SLI_IQ_PKT_CONTROL64(q_no))));\r\n}\r\npci_read_config_dword(oct->pci_dev, CN23XX_CONFIG_PCIE_DEVCTL, &regval);\r\ndev_dbg(&oct->pci_dev->dev, "Config DevCtl [0x%x]: 0x%08x\n",\r\nCN23XX_CONFIG_PCIE_DEVCTL, regval);\r\ndev_dbg(&oct->pci_dev->dev, "SLI_PRT[%d]_CFG [0x%llx]: 0x%016llx\n",\r\noct->pcie_port, CN23XX_DPI_SLI_PRTX_CFG(oct->pcie_port),\r\nCVM_CAST64(lio_pci_readq(\r\noct, CN23XX_DPI_SLI_PRTX_CFG(oct->pcie_port))));\r\ndev_dbg(&oct->pci_dev->dev, "SLI_S2M_PORT[%d]_CTL [0x%x]: 0x%016llx\n",\r\noct->pcie_port, CN23XX_SLI_S2M_PORTX_CTL(oct->pcie_port),\r\nCVM_CAST64(octeon_read_csr64(\r\noct, CN23XX_SLI_S2M_PORTX_CTL(oct->pcie_port))));\r\n}\r\nint cn23xx_fw_loaded(struct octeon_device *oct)\r\n{\r\nu64 val;\r\nval = octeon_read_csr64(oct, CN23XX_SLI_SCRATCH1);\r\nreturn (val >> 1) & 1ULL;\r\n}\r\nvoid cn23xx_tell_vf_its_macaddr_changed(struct octeon_device *oct, int vfidx,\r\nu8 *mac)\r\n{\r\nif (oct->sriov_info.vf_drv_loaded_mask & BIT_ULL(vfidx)) {\r\nstruct octeon_mbox_cmd mbox_cmd;\r\nmbox_cmd.msg.u64 = 0;\r\nmbox_cmd.msg.s.type = OCTEON_MBOX_REQUEST;\r\nmbox_cmd.msg.s.resp_needed = 0;\r\nmbox_cmd.msg.s.cmd = OCTEON_PF_CHANGED_VF_MACADDR;\r\nmbox_cmd.msg.s.len = 1;\r\nmbox_cmd.recv_len = 0;\r\nmbox_cmd.recv_status = 0;\r\nmbox_cmd.fn = NULL;\r\nmbox_cmd.fn_arg = 0;\r\nether_addr_copy(mbox_cmd.msg.s.params, mac);\r\nmbox_cmd.q_no = vfidx * oct->sriov_info.rings_per_vf;\r\nocteon_mbox_write(oct, &mbox_cmd);\r\n}\r\n}
