static struct pnfs_layoutdriver_type *\r\nfind_pnfs_driver_locked(u32 id)\r\n{\r\nstruct pnfs_layoutdriver_type *local;\r\nlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\r\nif (local->id == id)\r\ngoto out;\r\nlocal = NULL;\r\nout:\r\ndprintk("%s: Searching for id %u, found %p\n", __func__, id, local);\r\nreturn local;\r\n}\r\nstatic struct pnfs_layoutdriver_type *\r\nfind_pnfs_driver(u32 id)\r\n{\r\nstruct pnfs_layoutdriver_type *local;\r\nspin_lock(&pnfs_spinlock);\r\nlocal = find_pnfs_driver_locked(id);\r\nif (local != NULL && !try_module_get(local->owner)) {\r\ndprintk("%s: Could not grab reference on module\n", __func__);\r\nlocal = NULL;\r\n}\r\nspin_unlock(&pnfs_spinlock);\r\nreturn local;\r\n}\r\nvoid\r\nunset_pnfs_layoutdriver(struct nfs_server *nfss)\r\n{\r\nif (nfss->pnfs_curr_ld) {\r\nif (nfss->pnfs_curr_ld->clear_layoutdriver)\r\nnfss->pnfs_curr_ld->clear_layoutdriver(nfss);\r\nif (atomic_dec_and_test(&nfss->nfs_client->cl_mds_count))\r\nnfs4_deviceid_purge_client(nfss->nfs_client);\r\nmodule_put(nfss->pnfs_curr_ld->owner);\r\n}\r\nnfss->pnfs_curr_ld = NULL;\r\n}\r\nstatic int\r\nld_cmp(const void *e1, const void *e2)\r\n{\r\nu32 ld1 = *((u32 *)e1);\r\nu32 ld2 = *((u32 *)e2);\r\nint i;\r\nfor (i = 0; ld_prefs[i] != 0; i++) {\r\nif (ld1 == ld_prefs[i])\r\nreturn -1;\r\nif (ld2 == ld_prefs[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nset_pnfs_layoutdriver(struct nfs_server *server, const struct nfs_fh *mntfh,\r\nstruct nfs_fsinfo *fsinfo)\r\n{\r\nstruct pnfs_layoutdriver_type *ld_type = NULL;\r\nu32 id;\r\nint i;\r\nif (fsinfo->nlayouttypes == 0)\r\ngoto out_no_driver;\r\nif (!(server->nfs_client->cl_exchange_flags &\r\n(EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS))) {\r\nprintk(KERN_ERR "NFS: %s: cl_exchange_flags 0x%x\n",\r\n__func__, server->nfs_client->cl_exchange_flags);\r\ngoto out_no_driver;\r\n}\r\nsort(fsinfo->layouttype, fsinfo->nlayouttypes,\r\nsizeof(*fsinfo->layouttype), ld_cmp, NULL);\r\nfor (i = 0; i < fsinfo->nlayouttypes; i++) {\r\nid = fsinfo->layouttype[i];\r\nld_type = find_pnfs_driver(id);\r\nif (!ld_type) {\r\nrequest_module("%s-%u", LAYOUT_NFSV4_1_MODULE_PREFIX,\r\nid);\r\nld_type = find_pnfs_driver(id);\r\n}\r\nif (ld_type)\r\nbreak;\r\n}\r\nif (!ld_type) {\r\ndprintk("%s: No pNFS module found!\n", __func__);\r\ngoto out_no_driver;\r\n}\r\nserver->pnfs_curr_ld = ld_type;\r\nif (ld_type->set_layoutdriver\r\n&& ld_type->set_layoutdriver(server, mntfh)) {\r\nprintk(KERN_ERR "NFS: %s: Error initializing pNFS layout "\r\n"driver %u.\n", __func__, id);\r\nmodule_put(ld_type->owner);\r\ngoto out_no_driver;\r\n}\r\natomic_inc(&server->nfs_client->cl_mds_count);\r\ndprintk("%s: pNFS module for %u set\n", __func__, id);\r\nreturn;\r\nout_no_driver:\r\ndprintk("%s: Using NFSv4 I/O\n", __func__);\r\nserver->pnfs_curr_ld = NULL;\r\n}\r\nint\r\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\r\n{\r\nint status = -EINVAL;\r\nstruct pnfs_layoutdriver_type *tmp;\r\nif (ld_type->id == 0) {\r\nprintk(KERN_ERR "NFS: %s id 0 is reserved\n", __func__);\r\nreturn status;\r\n}\r\nif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\r\nprintk(KERN_ERR "NFS: %s Layout driver must provide "\r\n"alloc_lseg and free_lseg.\n", __func__);\r\nreturn status;\r\n}\r\nspin_lock(&pnfs_spinlock);\r\ntmp = find_pnfs_driver_locked(ld_type->id);\r\nif (!tmp) {\r\nlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\r\nstatus = 0;\r\ndprintk("%s Registering id:%u name:%s\n", __func__, ld_type->id,\r\nld_type->name);\r\n} else {\r\nprintk(KERN_ERR "NFS: %s Module with id %d already loaded!\n",\r\n__func__, ld_type->id);\r\n}\r\nspin_unlock(&pnfs_spinlock);\r\nreturn status;\r\n}\r\nvoid\r\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\r\n{\r\ndprintk("%s Deregistering id:%u\n", __func__, ld_type->id);\r\nspin_lock(&pnfs_spinlock);\r\nlist_del(&ld_type->pnfs_tblid);\r\nspin_unlock(&pnfs_spinlock);\r\n}\r\nvoid\r\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\natomic_inc(&lo->plh_refcount);\r\n}\r\nstatic struct pnfs_layout_hdr *\r\npnfs_alloc_layout_hdr(struct inode *ino, gfp_t gfp_flags)\r\n{\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\r\nreturn ld->alloc_layout_hdr(ino, gfp_flags);\r\n}\r\nstatic void\r\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\r\nstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\r\nif (!list_empty(&lo->plh_layouts)) {\r\nstruct nfs_client *clp = server->nfs_client;\r\nspin_lock(&clp->cl_lock);\r\nlist_del_init(&lo->plh_layouts);\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nput_rpccred(lo->plh_lc_cred);\r\nreturn ld->free_layout_hdr(lo);\r\n}\r\nstatic void\r\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\r\ndprintk("%s: freeing layout cache %p\n", __func__, lo);\r\nnfsi->layout = NULL;\r\nnfsi->write_io = 0;\r\nnfsi->read_io = 0;\r\n}\r\nvoid\r\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\npnfs_layoutreturn_before_put_layout_hdr(lo);\r\nif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\r\nif (!list_empty(&lo->plh_segs))\r\nWARN_ONCE(1, "NFS: BUG unfreed layout segments.\n");\r\npnfs_detach_layout_hdr(lo);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_layout_hdr(lo);\r\n}\r\n}\r\nstatic void\r\npnfs_set_plh_return_info(struct pnfs_layout_hdr *lo, enum pnfs_iomode iomode,\r\nu32 seq)\r\n{\r\nif (lo->plh_return_iomode != 0 && lo->plh_return_iomode != iomode)\r\niomode = IOMODE_ANY;\r\nlo->plh_return_iomode = iomode;\r\nset_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags);\r\nif (seq != 0) {\r\nWARN_ON_ONCE(lo->plh_return_seq != 0 && lo->plh_return_seq != seq);\r\nlo->plh_return_seq = seq;\r\n}\r\n}\r\nstatic void\r\npnfs_clear_layoutreturn_info(struct pnfs_layout_hdr *lo)\r\n{\r\nlo->plh_return_iomode = 0;\r\nlo->plh_return_seq = 0;\r\nclear_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags);\r\n}\r\nstatic void pnfs_clear_layoutreturn_waitbit(struct pnfs_layout_hdr *lo)\r\n{\r\nclear_bit_unlock(NFS_LAYOUT_RETURN, &lo->plh_flags);\r\nclear_bit(NFS_LAYOUT_RETURN_LOCK, &lo->plh_flags);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&lo->plh_flags, NFS_LAYOUT_RETURN);\r\nrpc_wake_up(&NFS_SERVER(lo->plh_inode)->roc_rpcwaitq);\r\n}\r\nstatic void\r\npnfs_clear_lseg_state(struct pnfs_layout_segment *lseg,\r\nstruct list_head *free_me)\r\n{\r\nclear_bit(NFS_LSEG_ROC, &lseg->pls_flags);\r\nclear_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\r\nif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags))\r\npnfs_lseg_dec_and_remove_zero(lseg, free_me);\r\nif (test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\r\npnfs_lseg_dec_and_remove_zero(lseg, free_me);\r\n}\r\nint\r\npnfs_mark_layout_stateid_invalid(struct pnfs_layout_hdr *lo,\r\nstruct list_head *lseg_list)\r\n{\r\nstruct pnfs_layout_range range = {\r\n.iomode = IOMODE_ANY,\r\n.offset = 0,\r\n.length = NFS4_MAX_UINT64,\r\n};\r\nstruct pnfs_layout_segment *lseg, *next;\r\nset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\r\npnfs_clear_layoutreturn_info(lo);\r\nlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\r\npnfs_clear_lseg_state(lseg, lseg_list);\r\npnfs_free_returned_lsegs(lo, lseg_list, &range, 0);\r\nif (test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags) &&\r\n!test_and_set_bit(NFS_LAYOUT_RETURN_LOCK, &lo->plh_flags))\r\npnfs_clear_layoutreturn_waitbit(lo);\r\nreturn !list_empty(&lo->plh_segs);\r\n}\r\nstatic int\r\npnfs_iomode_to_fail_bit(u32 iomode)\r\n{\r\nreturn iomode == IOMODE_RW ?\r\nNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\r\n}\r\nstatic void\r\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\r\n{\r\nlo->plh_retry_timestamp = jiffies;\r\nif (!test_and_set_bit(fail_bit, &lo->plh_flags))\r\natomic_inc(&lo->plh_refcount);\r\n}\r\nstatic void\r\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\r\n{\r\nif (test_and_clear_bit(fail_bit, &lo->plh_flags))\r\natomic_dec(&lo->plh_refcount);\r\n}\r\nstatic void\r\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nstruct pnfs_layout_range range = {\r\n.iomode = iomode,\r\n.offset = 0,\r\n.length = NFS4_MAX_UINT64,\r\n};\r\nLIST_HEAD(head);\r\nspin_lock(&inode->i_lock);\r\npnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\r\npnfs_mark_matching_lsegs_invalid(lo, &head, &range, 0);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg_list(&head);\r\ndprintk("%s Setting layout IOMODE_%s fail bit\n", __func__,\r\niomode == IOMODE_RW ? "RW" : "READ");\r\n}\r\nstatic bool\r\npnfs_layout_io_test_failed(struct pnfs_layout_hdr *lo, u32 iomode)\r\n{\r\nunsigned long start, end;\r\nint fail_bit = pnfs_iomode_to_fail_bit(iomode);\r\nif (test_bit(fail_bit, &lo->plh_flags) == 0)\r\nreturn false;\r\nend = jiffies;\r\nstart = end - PNFS_LAYOUTGET_RETRY_TIMEOUT;\r\nif (!time_in_range(lo->plh_retry_timestamp, start, end)) {\r\npnfs_layout_clear_fail_bit(lo, fail_bit);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\npnfs_init_lseg(struct pnfs_layout_hdr *lo, struct pnfs_layout_segment *lseg,\r\nconst struct pnfs_layout_range *range,\r\nconst nfs4_stateid *stateid)\r\n{\r\nINIT_LIST_HEAD(&lseg->pls_list);\r\nINIT_LIST_HEAD(&lseg->pls_lc_list);\r\natomic_set(&lseg->pls_refcount, 1);\r\nset_bit(NFS_LSEG_VALID, &lseg->pls_flags);\r\nlseg->pls_layout = lo;\r\nlseg->pls_range = *range;\r\nlseg->pls_seq = be32_to_cpu(stateid->seqid);\r\n}\r\nstatic void pnfs_free_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nif (lseg != NULL) {\r\nstruct inode *inode = lseg->pls_layout->plh_inode;\r\nNFS_SERVER(inode)->pnfs_curr_ld->free_lseg(lseg);\r\n}\r\n}\r\nstatic void\r\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\r\nlist_del_init(&lseg->pls_list);\r\natomic_dec(&lo->plh_refcount);\r\nif (test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags))\r\nreturn;\r\nif (list_empty(&lo->plh_segs) &&\r\n!test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags) &&\r\n!test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\r\nif (atomic_read(&lo->plh_outstanding) == 0)\r\nset_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\r\nclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\r\n}\r\n}\r\nstatic bool\r\npnfs_cache_lseg_for_layoutreturn(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nif (test_and_clear_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags) &&\r\npnfs_layout_is_valid(lo)) {\r\npnfs_set_plh_return_info(lo, lseg->pls_range.iomode, 0);\r\nlist_move_tail(&lseg->pls_list, &lo->plh_return_segs);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid\r\npnfs_put_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nstruct inode *inode;\r\nif (!lseg)\r\nreturn;\r\ndprintk("%s: lseg %p ref %d valid %d\n", __func__, lseg,\r\natomic_read(&lseg->pls_refcount),\r\ntest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\r\nlo = lseg->pls_layout;\r\ninode = lo->plh_inode;\r\nif (atomic_dec_and_lock(&lseg->pls_refcount, &inode->i_lock)) {\r\nif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\r\nspin_unlock(&inode->i_lock);\r\nreturn;\r\n}\r\npnfs_get_layout_hdr(lo);\r\npnfs_layout_remove_lseg(lo, lseg);\r\nif (pnfs_cache_lseg_for_layoutreturn(lo, lseg))\r\nlseg = NULL;\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg(lseg);\r\npnfs_put_layout_hdr(lo);\r\n}\r\n}\r\nstatic void pnfs_free_lseg_async_work(struct work_struct *work)\r\n{\r\nstruct pnfs_layout_segment *lseg;\r\nstruct pnfs_layout_hdr *lo;\r\nlseg = container_of(work, struct pnfs_layout_segment, pls_work);\r\nlo = lseg->pls_layout;\r\npnfs_free_lseg(lseg);\r\npnfs_put_layout_hdr(lo);\r\n}\r\nstatic void pnfs_free_lseg_async(struct pnfs_layout_segment *lseg)\r\n{\r\nINIT_WORK(&lseg->pls_work, pnfs_free_lseg_async_work);\r\nschedule_work(&lseg->pls_work);\r\n}\r\nvoid\r\npnfs_put_lseg_locked(struct pnfs_layout_segment *lseg)\r\n{\r\nif (!lseg)\r\nreturn;\r\nassert_spin_locked(&lseg->pls_layout->plh_inode->i_lock);\r\ndprintk("%s: lseg %p ref %d valid %d\n", __func__, lseg,\r\natomic_read(&lseg->pls_refcount),\r\ntest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\r\nif (atomic_dec_and_test(&lseg->pls_refcount)) {\r\nstruct pnfs_layout_hdr *lo = lseg->pls_layout;\r\nif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags))\r\nreturn;\r\npnfs_layout_remove_lseg(lo, lseg);\r\nif (!pnfs_cache_lseg_for_layoutreturn(lo, lseg)) {\r\npnfs_get_layout_hdr(lo);\r\npnfs_free_lseg_async(lseg);\r\n}\r\n}\r\n}\r\nstatic bool\r\npnfs_lseg_range_contained(const struct pnfs_layout_range *l1,\r\nconst struct pnfs_layout_range *l2)\r\n{\r\nu64 start1 = l1->offset;\r\nu64 end1 = pnfs_end_offset(start1, l1->length);\r\nu64 start2 = l2->offset;\r\nu64 end2 = pnfs_end_offset(start2, l2->length);\r\nreturn (start1 <= start2) && (end1 >= end2);\r\n}\r\nstatic bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\r\nstruct list_head *tmp_list)\r\n{\r\nif (!atomic_dec_and_test(&lseg->pls_refcount))\r\nreturn false;\r\npnfs_layout_remove_lseg(lseg->pls_layout, lseg);\r\nlist_add(&lseg->pls_list, tmp_list);\r\nreturn true;\r\n}\r\nstatic int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\r\nstruct list_head *tmp_list)\r\n{\r\nint rv = 0;\r\nif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\r\ndprintk("%s: lseg %p ref %d\n", __func__, lseg,\r\natomic_read(&lseg->pls_refcount));\r\nif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\r\nrv = 1;\r\n}\r\nreturn rv;\r\n}\r\nstatic bool pnfs_seqid_is_newer(u32 s1, u32 s2)\r\n{\r\nreturn (s32)(s1 - s2) > 0;\r\n}\r\nstatic bool\r\npnfs_should_free_range(const struct pnfs_layout_range *lseg_range,\r\nconst struct pnfs_layout_range *recall_range)\r\n{\r\nreturn (recall_range->iomode == IOMODE_ANY ||\r\nlseg_range->iomode == recall_range->iomode) &&\r\npnfs_lseg_range_intersecting(lseg_range, recall_range);\r\n}\r\nstatic bool\r\npnfs_match_lseg_recall(const struct pnfs_layout_segment *lseg,\r\nconst struct pnfs_layout_range *recall_range,\r\nu32 seq)\r\n{\r\nif (seq != 0 && pnfs_seqid_is_newer(lseg->pls_seq, seq))\r\nreturn false;\r\nif (recall_range == NULL)\r\nreturn true;\r\nreturn pnfs_should_free_range(&lseg->pls_range, recall_range);\r\n}\r\nint\r\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\r\nstruct list_head *tmp_list,\r\nconst struct pnfs_layout_range *recall_range,\r\nu32 seq)\r\n{\r\nstruct pnfs_layout_segment *lseg, *next;\r\nint remaining = 0;\r\ndprintk("%s:Begin lo %p\n", __func__, lo);\r\nif (list_empty(&lo->plh_segs))\r\nreturn 0;\r\nlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\r\nif (pnfs_match_lseg_recall(lseg, recall_range, seq)) {\r\ndprintk("%s: freeing lseg %p iomode %d seq %u"\r\n"offset %llu length %llu\n", __func__,\r\nlseg, lseg->pls_range.iomode, lseg->pls_seq,\r\nlseg->pls_range.offset, lseg->pls_range.length);\r\nif (!mark_lseg_invalid(lseg, tmp_list))\r\nremaining++;\r\n}\r\ndprintk("%s:Return %i\n", __func__, remaining);\r\nreturn remaining;\r\n}\r\nstatic void\r\npnfs_free_returned_lsegs(struct pnfs_layout_hdr *lo,\r\nstruct list_head *free_me,\r\nconst struct pnfs_layout_range *range,\r\nu32 seq)\r\n{\r\nstruct pnfs_layout_segment *lseg, *next;\r\nlist_for_each_entry_safe(lseg, next, &lo->plh_return_segs, pls_list) {\r\nif (pnfs_match_lseg_recall(lseg, range, seq))\r\nlist_move_tail(&lseg->pls_list, free_me);\r\n}\r\n}\r\nvoid\r\npnfs_free_lseg_list(struct list_head *free_me)\r\n{\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nif (list_empty(free_me))\r\nreturn;\r\nlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\r\nlist_del(&lseg->pls_list);\r\npnfs_free_lseg(lseg);\r\n}\r\n}\r\nvoid\r\npnfs_destroy_layout(struct nfs_inode *nfsi)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nLIST_HEAD(tmp_list);\r\nspin_lock(&nfsi->vfs_inode.i_lock);\r\nlo = nfsi->layout;\r\nif (lo) {\r\npnfs_get_layout_hdr(lo);\r\npnfs_mark_layout_stateid_invalid(lo, &tmp_list);\r\npnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RO_FAILED);\r\npnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RW_FAILED);\r\nspin_unlock(&nfsi->vfs_inode.i_lock);\r\npnfs_free_lseg_list(&tmp_list);\r\npnfs_put_layout_hdr(lo);\r\n} else\r\nspin_unlock(&nfsi->vfs_inode.i_lock);\r\n}\r\nstatic bool\r\npnfs_layout_add_bulk_destroy_list(struct inode *inode,\r\nstruct list_head *layout_list)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nbool ret = false;\r\nspin_lock(&inode->i_lock);\r\nlo = NFS_I(inode)->layout;\r\nif (lo != NULL && list_empty(&lo->plh_bulk_destroy)) {\r\npnfs_get_layout_hdr(lo);\r\nlist_add(&lo->plh_bulk_destroy, layout_list);\r\nret = true;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\r\nstruct nfs_server *server,\r\nstruct list_head *layout_list)\r\n{\r\nstruct pnfs_layout_hdr *lo, *next;\r\nstruct inode *inode;\r\nlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\r\nif (test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags))\r\ncontinue;\r\ninode = igrab(lo->plh_inode);\r\nif (inode == NULL)\r\ncontinue;\r\nlist_del_init(&lo->plh_layouts);\r\nif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\r\ncontinue;\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\niput(inode);\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\r\nbool is_bulk_recall)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nstruct inode *inode;\r\nLIST_HEAD(lseg_list);\r\nint ret = 0;\r\nwhile (!list_empty(layout_list)) {\r\nlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\r\nplh_bulk_destroy);\r\ndprintk("%s freeing layout for inode %lu\n", __func__,\r\nlo->plh_inode->i_ino);\r\ninode = lo->plh_inode;\r\npnfs_layoutcommit_inode(inode, false);\r\nspin_lock(&inode->i_lock);\r\nlist_del_init(&lo->plh_bulk_destroy);\r\nif (pnfs_mark_layout_stateid_invalid(lo, &lseg_list)) {\r\nif (is_bulk_recall)\r\nset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\r\nret = -EAGAIN;\r\n}\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg_list(&lseg_list);\r\nnfs_commit_inode(inode, 0);\r\npnfs_put_layout_hdr(lo);\r\niput(inode);\r\n}\r\nreturn ret;\r\n}\r\nint\r\npnfs_destroy_layouts_byfsid(struct nfs_client *clp,\r\nstruct nfs_fsid *fsid,\r\nbool is_recall)\r\n{\r\nstruct nfs_server *server;\r\nLIST_HEAD(layout_list);\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nrestart:\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nif (memcmp(&server->fsid, fsid, sizeof(*fsid)) != 0)\r\ncontinue;\r\nif (pnfs_layout_bulk_destroy_byserver_locked(clp,\r\nserver,\r\n&layout_list) != 0)\r\ngoto restart;\r\n}\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\nif (list_empty(&layout_list))\r\nreturn 0;\r\nreturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\r\n}\r\nint\r\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\r\nbool is_recall)\r\n{\r\nstruct nfs_server *server;\r\nLIST_HEAD(layout_list);\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nrestart:\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nif (pnfs_layout_bulk_destroy_byserver_locked(clp,\r\nserver,\r\n&layout_list) != 0)\r\ngoto restart;\r\n}\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\nif (list_empty(&layout_list))\r\nreturn 0;\r\nreturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\r\n}\r\nvoid\r\npnfs_destroy_all_layouts(struct nfs_client *clp)\r\n{\r\nnfs4_deviceid_mark_client_invalid(clp);\r\nnfs4_deviceid_purge_client(clp);\r\npnfs_destroy_layouts_byclid(clp, false);\r\n}\r\nvoid\r\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\r\nbool update_barrier)\r\n{\r\nu32 oldseq, newseq, new_barrier = 0;\r\noldseq = be32_to_cpu(lo->plh_stateid.seqid);\r\nnewseq = be32_to_cpu(new->seqid);\r\nif (!pnfs_layout_is_valid(lo)) {\r\nnfs4_stateid_copy(&lo->plh_stateid, new);\r\nlo->plh_barrier = newseq;\r\npnfs_clear_layoutreturn_info(lo);\r\nclear_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);\r\nreturn;\r\n}\r\nif (pnfs_seqid_is_newer(newseq, oldseq)) {\r\nnfs4_stateid_copy(&lo->plh_stateid, new);\r\nnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\r\n}\r\nif (update_barrier)\r\nnew_barrier = be32_to_cpu(new->seqid);\r\nelse if (new_barrier == 0)\r\nreturn;\r\nif (pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\r\nlo->plh_barrier = new_barrier;\r\n}\r\nstatic bool\r\npnfs_layout_stateid_blocked(const struct pnfs_layout_hdr *lo,\r\nconst nfs4_stateid *stateid)\r\n{\r\nu32 seqid = be32_to_cpu(stateid->seqid);\r\nreturn !pnfs_seqid_is_newer(seqid, lo->plh_barrier);\r\n}\r\nstatic bool\r\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo)\r\n{\r\nreturn lo->plh_block_lgets ||\r\ntest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\r\n}\r\nstatic struct pnfs_layout_segment *\r\nsend_layoutget(struct pnfs_layout_hdr *lo,\r\nstruct nfs_open_context *ctx,\r\nnfs4_stateid *stateid,\r\nconst struct pnfs_layout_range *range,\r\nlong *timeout, gfp_t gfp_flags)\r\n{\r\nstruct inode *ino = lo->plh_inode;\r\nstruct nfs_server *server = NFS_SERVER(ino);\r\nstruct nfs4_layoutget *lgp;\r\nloff_t i_size;\r\ndprintk("--> %s\n", __func__);\r\nlgp = kzalloc(sizeof(*lgp), gfp_flags);\r\nif (lgp == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ni_size = i_size_read(ino);\r\nlgp->args.minlength = PAGE_SIZE;\r\nif (lgp->args.minlength > range->length)\r\nlgp->args.minlength = range->length;\r\nif (range->iomode == IOMODE_READ) {\r\nif (range->offset >= i_size)\r\nlgp->args.minlength = 0;\r\nelse if (i_size - range->offset < lgp->args.minlength)\r\nlgp->args.minlength = i_size - range->offset;\r\n}\r\nlgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;\r\npnfs_copy_range(&lgp->args.range, range);\r\nlgp->args.type = server->pnfs_curr_ld->id;\r\nlgp->args.inode = ino;\r\nlgp->args.ctx = get_nfs_open_context(ctx);\r\nnfs4_stateid_copy(&lgp->args.stateid, stateid);\r\nlgp->gfp_flags = gfp_flags;\r\nlgp->cred = lo->plh_lc_cred;\r\nreturn nfs4_proc_layoutget(lgp, timeout, gfp_flags);\r\n}\r\nstatic void pnfs_clear_layoutcommit(struct inode *inode,\r\nstruct list_head *head)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\r\nreturn;\r\nlist_for_each_entry_safe(lseg, tmp, &nfsi->layout->plh_segs, pls_list) {\r\nif (!test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\r\ncontinue;\r\npnfs_lseg_dec_and_remove_zero(lseg, head);\r\n}\r\n}\r\nvoid pnfs_layoutreturn_free_lsegs(struct pnfs_layout_hdr *lo,\r\nconst nfs4_stateid *arg_stateid,\r\nconst struct pnfs_layout_range *range,\r\nconst nfs4_stateid *stateid)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nLIST_HEAD(freeme);\r\nspin_lock(&inode->i_lock);\r\nif (!pnfs_layout_is_valid(lo) || !arg_stateid ||\r\n!nfs4_stateid_match_other(&lo->plh_stateid, arg_stateid))\r\ngoto out_unlock;\r\nif (stateid) {\r\nu32 seq = be32_to_cpu(arg_stateid->seqid);\r\npnfs_mark_matching_lsegs_invalid(lo, &freeme, range, seq);\r\npnfs_free_returned_lsegs(lo, &freeme, range, seq);\r\npnfs_set_layout_stateid(lo, stateid, true);\r\n} else\r\npnfs_mark_layout_stateid_invalid(lo, &freeme);\r\nout_unlock:\r\npnfs_clear_layoutreturn_waitbit(lo);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg_list(&freeme);\r\n}\r\nstatic bool\r\npnfs_prepare_layoutreturn(struct pnfs_layout_hdr *lo,\r\nnfs4_stateid *stateid,\r\nenum pnfs_iomode *iomode)\r\n{\r\nif (atomic_read(&lo->plh_outstanding) != 0)\r\nreturn false;\r\nif (test_and_set_bit(NFS_LAYOUT_RETURN_LOCK, &lo->plh_flags))\r\nreturn false;\r\nset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\r\npnfs_get_layout_hdr(lo);\r\nif (test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags)) {\r\nif (stateid != NULL) {\r\nnfs4_stateid_copy(stateid, &lo->plh_stateid);\r\nif (lo->plh_return_seq != 0)\r\nstateid->seqid = cpu_to_be32(lo->plh_return_seq);\r\n}\r\nif (iomode != NULL)\r\n*iomode = lo->plh_return_iomode;\r\npnfs_clear_layoutreturn_info(lo);\r\nreturn true;\r\n}\r\nif (stateid != NULL)\r\nnfs4_stateid_copy(stateid, &lo->plh_stateid);\r\nif (iomode != NULL)\r\n*iomode = IOMODE_ANY;\r\nreturn true;\r\n}\r\nstatic void\r\npnfs_init_layoutreturn_args(struct nfs4_layoutreturn_args *args,\r\nstruct pnfs_layout_hdr *lo,\r\nconst nfs4_stateid *stateid,\r\nenum pnfs_iomode iomode)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nargs->layout_type = NFS_SERVER(inode)->pnfs_curr_ld->id;\r\nargs->inode = inode;\r\nargs->range.iomode = iomode;\r\nargs->range.offset = 0;\r\nargs->range.length = NFS4_MAX_UINT64;\r\nargs->layout = lo;\r\nnfs4_stateid_copy(&args->stateid, stateid);\r\n}\r\nstatic int\r\npnfs_send_layoutreturn(struct pnfs_layout_hdr *lo, const nfs4_stateid *stateid,\r\nenum pnfs_iomode iomode, bool sync)\r\n{\r\nstruct inode *ino = lo->plh_inode;\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\r\nstruct nfs4_layoutreturn *lrp;\r\nint status = 0;\r\nlrp = kzalloc(sizeof(*lrp), GFP_NOFS);\r\nif (unlikely(lrp == NULL)) {\r\nstatus = -ENOMEM;\r\nspin_lock(&ino->i_lock);\r\npnfs_clear_layoutreturn_waitbit(lo);\r\nspin_unlock(&ino->i_lock);\r\npnfs_put_layout_hdr(lo);\r\ngoto out;\r\n}\r\npnfs_init_layoutreturn_args(&lrp->args, lo, stateid, iomode);\r\nlrp->args.ld_private = &lrp->ld_private;\r\nlrp->clp = NFS_SERVER(ino)->nfs_client;\r\nlrp->cred = lo->plh_lc_cred;\r\nif (ld->prepare_layoutreturn)\r\nld->prepare_layoutreturn(&lrp->args);\r\nstatus = nfs4_proc_layoutreturn(lrp, sync);\r\nout:\r\ndprintk("<-- %s status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic bool\r\npnfs_layout_need_return(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct pnfs_layout_segment *s;\r\nif (!test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags))\r\nreturn false;\r\nlist_for_each_entry(s, &lo->plh_segs, pls_list) {\r\nif (test_bit(NFS_LSEG_LAYOUTRETURN, &s->pls_flags))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void pnfs_layoutreturn_before_put_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct inode *inode= lo->plh_inode;\r\nif (!test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags))\r\nreturn;\r\nspin_lock(&inode->i_lock);\r\nif (pnfs_layout_need_return(lo)) {\r\nnfs4_stateid stateid;\r\nenum pnfs_iomode iomode;\r\nbool send;\r\nsend = pnfs_prepare_layoutreturn(lo, &stateid, &iomode);\r\nspin_unlock(&inode->i_lock);\r\nif (send) {\r\npnfs_send_layoutreturn(lo, &stateid, iomode, false);\r\n}\r\n} else\r\nspin_unlock(&inode->i_lock);\r\n}\r\nint\r\n_pnfs_return_layout(struct inode *ino)\r\n{\r\nstruct pnfs_layout_hdr *lo = NULL;\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nLIST_HEAD(tmp_list);\r\nnfs4_stateid stateid;\r\nint status = 0;\r\nbool send;\r\ndprintk("NFS: %s for inode %lu\n", __func__, ino->i_ino);\r\nspin_lock(&ino->i_lock);\r\nlo = nfsi->layout;\r\nif (!lo) {\r\nspin_unlock(&ino->i_lock);\r\ndprintk("NFS: %s no layout to return\n", __func__);\r\ngoto out;\r\n}\r\npnfs_get_layout_hdr(lo);\r\nif (test_bit(NFS_LAYOUT_RETURN_LOCK, &lo->plh_flags)) {\r\nspin_unlock(&ino->i_lock);\r\nif (wait_on_bit(&lo->plh_flags, NFS_LAYOUT_RETURN,\r\nTASK_UNINTERRUPTIBLE))\r\ngoto out_put_layout_hdr;\r\nspin_lock(&ino->i_lock);\r\n}\r\npnfs_clear_layoutcommit(ino, &tmp_list);\r\npnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL, 0);\r\nif (NFS_SERVER(ino)->pnfs_curr_ld->return_range) {\r\nstruct pnfs_layout_range range = {\r\n.iomode = IOMODE_ANY,\r\n.offset = 0,\r\n.length = NFS4_MAX_UINT64,\r\n};\r\nNFS_SERVER(ino)->pnfs_curr_ld->return_range(lo, &range);\r\n}\r\nif (!test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags)) {\r\nspin_unlock(&ino->i_lock);\r\ndprintk("NFS: %s no layout segments to return\n", __func__);\r\ngoto out_put_layout_hdr;\r\n}\r\nsend = pnfs_prepare_layoutreturn(lo, &stateid, NULL);\r\nspin_unlock(&ino->i_lock);\r\nif (send)\r\nstatus = pnfs_send_layoutreturn(lo, &stateid, IOMODE_ANY, true);\r\nout_put_layout_hdr:\r\npnfs_free_lseg_list(&tmp_list);\r\npnfs_put_layout_hdr(lo);\r\nout:\r\ndprintk("<-- %s status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nint\r\npnfs_commit_and_return_layout(struct inode *inode)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nint ret;\r\nspin_lock(&inode->i_lock);\r\nlo = NFS_I(inode)->layout;\r\nif (lo == NULL) {\r\nspin_unlock(&inode->i_lock);\r\nreturn 0;\r\n}\r\npnfs_get_layout_hdr(lo);\r\nlo->plh_block_lgets++;\r\nspin_unlock(&inode->i_lock);\r\nfilemap_fdatawait(inode->i_mapping);\r\nret = pnfs_layoutcommit_inode(inode, true);\r\nif (ret == 0)\r\nret = _pnfs_return_layout(inode);\r\nspin_lock(&inode->i_lock);\r\nlo->plh_block_lgets--;\r\nspin_unlock(&inode->i_lock);\r\npnfs_put_layout_hdr(lo);\r\nreturn ret;\r\n}\r\nbool pnfs_roc(struct inode *ino,\r\nstruct nfs4_layoutreturn_args *args,\r\nstruct nfs4_layoutreturn_res *res,\r\nconst struct rpc_cred *cred)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nstruct nfs_open_context *ctx;\r\nstruct nfs4_state *state;\r\nstruct pnfs_layout_hdr *lo;\r\nstruct pnfs_layout_segment *lseg, *next;\r\nnfs4_stateid stateid;\r\nenum pnfs_iomode iomode = 0;\r\nbool layoutreturn = false, roc = false;\r\nbool skip_read = false;\r\nif (!nfs_have_layout(ino))\r\nreturn false;\r\nretry:\r\nspin_lock(&ino->i_lock);\r\nlo = nfsi->layout;\r\nif (!lo || !pnfs_layout_is_valid(lo) ||\r\ntest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags))\r\ngoto out_noroc;\r\nif (test_bit(NFS_LAYOUT_RETURN_LOCK, &lo->plh_flags)) {\r\npnfs_get_layout_hdr(lo);\r\nspin_unlock(&ino->i_lock);\r\nwait_on_bit(&lo->plh_flags, NFS_LAYOUT_RETURN,\r\nTASK_UNINTERRUPTIBLE);\r\npnfs_put_layout_hdr(lo);\r\ngoto retry;\r\n}\r\nif (nfs4_check_delegation(ino, FMODE_READ)) {\r\nif (nfs4_check_delegation(ino, FMODE_WRITE))\r\ngoto out_noroc;\r\nskip_read = true;\r\n}\r\nlist_for_each_entry(ctx, &nfsi->open_files, list) {\r\nstate = ctx->state;\r\nif (state == NULL)\r\ncontinue;\r\nif (state->state & FMODE_WRITE)\r\ngoto out_noroc;\r\nif (state->state & FMODE_READ)\r\nskip_read = true;\r\n}\r\nlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list) {\r\nif (skip_read && lseg->pls_range.iomode == IOMODE_READ)\r\ncontinue;\r\nif (!test_and_clear_bit(NFS_LSEG_ROC, &lseg->pls_flags))\r\ncontinue;\r\nset_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\r\nif (!mark_lseg_invalid(lseg, &lo->plh_return_segs))\r\ncontinue;\r\npnfs_set_plh_return_info(lo, lseg->pls_range.iomode, 0);\r\n}\r\nif (!test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags))\r\ngoto out_noroc;\r\nlayoutreturn = pnfs_prepare_layoutreturn(lo, &stateid, &iomode);\r\nif (!layoutreturn || cred != lo->plh_lc_cred)\r\ngoto out_noroc;\r\nroc = layoutreturn;\r\npnfs_init_layoutreturn_args(args, lo, &stateid, iomode);\r\nres->lrs_present = 0;\r\nlayoutreturn = false;\r\nout_noroc:\r\nspin_unlock(&ino->i_lock);\r\npnfs_layoutcommit_inode(ino, true);\r\nif (roc) {\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\r\nif (ld->prepare_layoutreturn)\r\nld->prepare_layoutreturn(args);\r\nreturn true;\r\n}\r\nif (layoutreturn)\r\npnfs_send_layoutreturn(lo, &stateid, iomode, true);\r\nreturn false;\r\n}\r\nvoid pnfs_roc_release(struct nfs4_layoutreturn_args *args,\r\nstruct nfs4_layoutreturn_res *res,\r\nint ret)\r\n{\r\nstruct pnfs_layout_hdr *lo = args->layout;\r\nconst nfs4_stateid *arg_stateid = NULL;\r\nconst nfs4_stateid *res_stateid = NULL;\r\nstruct nfs4_xdr_opaque_data *ld_private = args->ld_private;\r\nif (ret == 0) {\r\narg_stateid = &args->stateid;\r\nif (res->lrs_present)\r\nres_stateid = &res->stateid;\r\n}\r\npnfs_layoutreturn_free_lsegs(lo, arg_stateid, &args->range,\r\nres_stateid);\r\nif (ld_private && ld_private->ops && ld_private->ops->free)\r\nld_private->ops->free(ld_private);\r\npnfs_put_layout_hdr(lo);\r\ntrace_nfs4_layoutreturn_on_close(args->inode, 0);\r\n}\r\nbool pnfs_wait_on_layoutreturn(struct inode *ino, struct rpc_task *task)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nstruct pnfs_layout_hdr *lo;\r\nbool sleep = false;\r\nspin_lock(&ino->i_lock);\r\nlo = nfsi->layout;\r\nif (lo && test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\r\nrpc_sleep_on(&NFS_SERVER(ino)->roc_rpcwaitq, task, NULL);\r\nsleep = true;\r\n}\r\nspin_unlock(&ino->i_lock);\r\nreturn sleep;\r\n}\r\nstatic s64\r\npnfs_lseg_range_cmp(const struct pnfs_layout_range *l1,\r\nconst struct pnfs_layout_range *l2)\r\n{\r\ns64 d;\r\nd = l1->offset - l2->offset;\r\nif (d)\r\nreturn d;\r\nd = l2->length - l1->length;\r\nif (d)\r\nreturn d;\r\nreturn (int)(l1->iomode == IOMODE_READ) - (int)(l2->iomode == IOMODE_READ);\r\n}\r\nstatic bool\r\npnfs_lseg_range_is_after(const struct pnfs_layout_range *l1,\r\nconst struct pnfs_layout_range *l2)\r\n{\r\nreturn pnfs_lseg_range_cmp(l1, l2) > 0;\r\n}\r\nstatic bool\r\npnfs_lseg_no_merge(struct pnfs_layout_segment *lseg,\r\nstruct pnfs_layout_segment *old)\r\n{\r\nreturn false;\r\n}\r\nvoid\r\npnfs_generic_layout_insert_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_segment *lseg,\r\nbool (*is_after)(const struct pnfs_layout_range *,\r\nconst struct pnfs_layout_range *),\r\nbool (*do_merge)(struct pnfs_layout_segment *,\r\nstruct pnfs_layout_segment *),\r\nstruct list_head *free_me)\r\n{\r\nstruct pnfs_layout_segment *lp, *tmp;\r\ndprintk("%s:Begin\n", __func__);\r\nlist_for_each_entry_safe(lp, tmp, &lo->plh_segs, pls_list) {\r\nif (test_bit(NFS_LSEG_VALID, &lp->pls_flags) == 0)\r\ncontinue;\r\nif (do_merge(lseg, lp)) {\r\nmark_lseg_invalid(lp, free_me);\r\ncontinue;\r\n}\r\nif (is_after(&lseg->pls_range, &lp->pls_range))\r\ncontinue;\r\nlist_add_tail(&lseg->pls_list, &lp->pls_list);\r\ndprintk("%s: inserted lseg %p "\r\n"iomode %d offset %llu length %llu before "\r\n"lp %p iomode %d offset %llu length %llu\n",\r\n__func__, lseg, lseg->pls_range.iomode,\r\nlseg->pls_range.offset, lseg->pls_range.length,\r\nlp, lp->pls_range.iomode, lp->pls_range.offset,\r\nlp->pls_range.length);\r\ngoto out;\r\n}\r\nlist_add_tail(&lseg->pls_list, &lo->plh_segs);\r\ndprintk("%s: inserted lseg %p "\r\n"iomode %d offset %llu length %llu at tail\n",\r\n__func__, lseg, lseg->pls_range.iomode,\r\nlseg->pls_range.offset, lseg->pls_range.length);\r\nout:\r\npnfs_get_layout_hdr(lo);\r\ndprintk("%s:Return\n", __func__);\r\n}\r\nstatic void\r\npnfs_layout_insert_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_segment *lseg,\r\nstruct list_head *free_me)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\r\nif (ld->add_lseg != NULL)\r\nld->add_lseg(lo, lseg, free_me);\r\nelse\r\npnfs_generic_layout_insert_lseg(lo, lseg,\r\npnfs_lseg_range_is_after,\r\npnfs_lseg_no_merge,\r\nfree_me);\r\n}\r\nstatic struct pnfs_layout_hdr *\r\nalloc_init_layout_hdr(struct inode *ino,\r\nstruct nfs_open_context *ctx,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nlo = pnfs_alloc_layout_hdr(ino, gfp_flags);\r\nif (!lo)\r\nreturn NULL;\r\natomic_set(&lo->plh_refcount, 1);\r\nINIT_LIST_HEAD(&lo->plh_layouts);\r\nINIT_LIST_HEAD(&lo->plh_segs);\r\nINIT_LIST_HEAD(&lo->plh_return_segs);\r\nINIT_LIST_HEAD(&lo->plh_bulk_destroy);\r\nlo->plh_inode = ino;\r\nlo->plh_lc_cred = get_rpccred(ctx->cred);\r\nlo->plh_flags |= 1 << NFS_LAYOUT_INVALID_STID;\r\nreturn lo;\r\n}\r\nstatic struct pnfs_layout_hdr *\r\npnfs_find_alloc_layout(struct inode *ino,\r\nstruct nfs_open_context *ctx,\r\ngfp_t gfp_flags)\r\n__releases(&ino->i_lock\r\nstatic bool\r\npnfs_lseg_range_match(const struct pnfs_layout_range *ls_range,\r\nconst struct pnfs_layout_range *range,\r\nbool strict_iomode)\r\n{\r\nstruct pnfs_layout_range range1;\r\nif ((range->iomode == IOMODE_RW &&\r\nls_range->iomode != IOMODE_RW) ||\r\n(range->iomode != ls_range->iomode &&\r\nstrict_iomode == true) ||\r\n!pnfs_lseg_range_intersecting(ls_range, range))\r\nreturn 0;\r\nrange1 = *range;\r\nrange1.length = 1;\r\nreturn pnfs_lseg_range_contained(ls_range, &range1);\r\n}\r\nstatic struct pnfs_layout_segment *\r\npnfs_find_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_range *range,\r\nbool strict_iomode)\r\n{\r\nstruct pnfs_layout_segment *lseg, *ret = NULL;\r\ndprintk("%s:Begin\n", __func__);\r\nlist_for_each_entry(lseg, &lo->plh_segs, pls_list) {\r\nif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags) &&\r\n!test_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags) &&\r\npnfs_lseg_range_match(&lseg->pls_range, range,\r\nstrict_iomode)) {\r\nret = pnfs_get_lseg(lseg);\r\nbreak;\r\n}\r\n}\r\ndprintk("%s:Return lseg %p ref %d\n",\r\n__func__, ret, ret ? atomic_read(&ret->pls_refcount) : 0);\r\nreturn ret;\r\n}\r\nstatic bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,\r\nstruct inode *ino, int iomode)\r\n{\r\nstruct nfs4_threshold *t = ctx->mdsthreshold;\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nloff_t fsize = i_size_read(ino);\r\nbool size = false, size_set = false, io = false, io_set = false, ret = false;\r\nif (t == NULL)\r\nreturn ret;\r\ndprintk("%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\n",\r\n__func__, t->bm, t->rd_sz, t->wr_sz, t->rd_io_sz, t->wr_io_sz);\r\nswitch (iomode) {\r\ncase IOMODE_READ:\r\nif (t->bm & THRESHOLD_RD) {\r\ndprintk("%s fsize %llu\n", __func__, fsize);\r\nsize_set = true;\r\nif (fsize < t->rd_sz)\r\nsize = true;\r\n}\r\nif (t->bm & THRESHOLD_RD_IO) {\r\ndprintk("%s nfsi->read_io %llu\n", __func__,\r\nnfsi->read_io);\r\nio_set = true;\r\nif (nfsi->read_io < t->rd_io_sz)\r\nio = true;\r\n}\r\nbreak;\r\ncase IOMODE_RW:\r\nif (t->bm & THRESHOLD_WR) {\r\ndprintk("%s fsize %llu\n", __func__, fsize);\r\nsize_set = true;\r\nif (fsize < t->wr_sz)\r\nsize = true;\r\n}\r\nif (t->bm & THRESHOLD_WR_IO) {\r\ndprintk("%s nfsi->write_io %llu\n", __func__,\r\nnfsi->write_io);\r\nio_set = true;\r\nif (nfsi->write_io < t->wr_io_sz)\r\nio = true;\r\n}\r\nbreak;\r\n}\r\nif (size_set && io_set) {\r\nif (size && io)\r\nret = true;\r\n} else if (size || io)\r\nret = true;\r\ndprintk("<-- %s size %d io %d ret %d\n", __func__, size, io, ret);\r\nreturn ret;\r\n}\r\nstatic bool pnfs_prepare_to_retry_layoutget(struct pnfs_layout_hdr *lo)\r\n{\r\npnfs_layoutcommit_inode(lo->plh_inode, false);\r\nreturn !wait_on_bit_action(&lo->plh_flags, NFS_LAYOUT_RETURN,\r\nnfs_wait_bit_killable,\r\nTASK_UNINTERRUPTIBLE);\r\n}\r\nstatic void pnfs_clear_first_layoutget(struct pnfs_layout_hdr *lo)\r\n{\r\nunsigned long *bitlock = &lo->plh_flags;\r\nclear_bit_unlock(NFS_LAYOUT_FIRST_LAYOUTGET, bitlock);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(bitlock, NFS_LAYOUT_FIRST_LAYOUTGET);\r\n}\r\nstruct pnfs_layout_segment *\r\npnfs_update_layout(struct inode *ino,\r\nstruct nfs_open_context *ctx,\r\nloff_t pos,\r\nu64 count,\r\nenum pnfs_iomode iomode,\r\nbool strict_iomode,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_layout_range arg = {\r\n.iomode = iomode,\r\n.offset = pos,\r\n.length = count,\r\n};\r\nunsigned pg_offset, seq;\r\nstruct nfs_server *server = NFS_SERVER(ino);\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct pnfs_layout_hdr *lo = NULL;\r\nstruct pnfs_layout_segment *lseg = NULL;\r\nnfs4_stateid stateid;\r\nlong timeout = 0;\r\nunsigned long giveup = jiffies + (clp->cl_lease_time << 1);\r\nbool first;\r\nif (!pnfs_enabled_sb(NFS_SERVER(ino))) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_NO_PNFS);\r\ngoto out;\r\n}\r\nif (iomode == IOMODE_READ && i_size_read(ino) == 0) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_RD_ZEROLEN);\r\ngoto out;\r\n}\r\nif (pnfs_within_mdsthreshold(ctx, ino, iomode)) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_MDSTHRESH);\r\ngoto out;\r\n}\r\nlookup_again:\r\nnfs4_client_recover_expired_lease(clp);\r\nfirst = false;\r\nspin_lock(&ino->i_lock);\r\nlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\r\nif (lo == NULL) {\r\nspin_unlock(&ino->i_lock);\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_NOMEM);\r\ngoto out;\r\n}\r\nif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_BULK_RECALL);\r\ndprintk("%s matches recall, use MDS\n", __func__);\r\ngoto out_unlock;\r\n}\r\nif (pnfs_layout_io_test_failed(lo, iomode)) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_IO_TEST_FAIL);\r\ngoto out_unlock;\r\n}\r\nlseg = pnfs_find_lseg(lo, &arg, strict_iomode);\r\nif (lseg) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_FOUND_CACHED);\r\ngoto out_unlock;\r\n}\r\nif (!nfs4_valid_open_stateid(ctx->state)) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_INVALID_OPEN);\r\ngoto out_unlock;\r\n}\r\nif (test_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags)) {\r\nif (test_and_set_bit(NFS_LAYOUT_FIRST_LAYOUTGET,\r\n&lo->plh_flags)) {\r\nspin_unlock(&ino->i_lock);\r\nwait_on_bit(&lo->plh_flags, NFS_LAYOUT_FIRST_LAYOUTGET,\r\nTASK_UNINTERRUPTIBLE);\r\npnfs_put_layout_hdr(lo);\r\ndprintk("%s retrying\n", __func__);\r\ngoto lookup_again;\r\n}\r\nfirst = true;\r\ndo {\r\nseq = read_seqbegin(&ctx->state->seqlock);\r\nnfs4_stateid_copy(&stateid, &ctx->state->stateid);\r\n} while (read_seqretry(&ctx->state->seqlock, seq));\r\n} else {\r\nnfs4_stateid_copy(&stateid, &lo->plh_stateid);\r\n}\r\nif (test_bit(NFS_LAYOUT_RETURN, &lo->plh_flags)) {\r\nspin_unlock(&ino->i_lock);\r\ndprintk("%s wait for layoutreturn\n", __func__);\r\nif (pnfs_prepare_to_retry_layoutget(lo)) {\r\nif (first)\r\npnfs_clear_first_layoutget(lo);\r\npnfs_put_layout_hdr(lo);\r\ndprintk("%s retrying\n", __func__);\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo,\r\nlseg, PNFS_UPDATE_LAYOUT_RETRY);\r\ngoto lookup_again;\r\n}\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_RETURN);\r\ngoto out_put_layout_hdr;\r\n}\r\nif (pnfs_layoutgets_blocked(lo)) {\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_BLOCKED);\r\ngoto out_unlock;\r\n}\r\natomic_inc(&lo->plh_outstanding);\r\nspin_unlock(&ino->i_lock);\r\nif (list_empty(&lo->plh_layouts)) {\r\nspin_lock(&clp->cl_lock);\r\nif (list_empty(&lo->plh_layouts))\r\nlist_add_tail(&lo->plh_layouts, &server->layouts);\r\nspin_unlock(&clp->cl_lock);\r\n}\r\npg_offset = arg.offset & ~PAGE_MASK;\r\nif (pg_offset) {\r\narg.offset -= pg_offset;\r\narg.length += pg_offset;\r\n}\r\nif (arg.length != NFS4_MAX_UINT64)\r\narg.length = PAGE_ALIGN(arg.length);\r\nlseg = send_layoutget(lo, ctx, &stateid, &arg, &timeout, gfp_flags);\r\ntrace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,\r\nPNFS_UPDATE_LAYOUT_SEND_LAYOUTGET);\r\natomic_dec(&lo->plh_outstanding);\r\nif (IS_ERR(lseg)) {\r\nswitch(PTR_ERR(lseg)) {\r\ncase -EBUSY:\r\nif (time_after(jiffies, giveup))\r\nlseg = NULL;\r\nbreak;\r\ncase -ERECALLCONFLICT:\r\nif (first) {\r\nlseg = NULL;\r\nbreak;\r\n}\r\nif (time_after(jiffies, giveup))\r\npnfs_destroy_layout(NFS_I(ino));\r\ncase -EAGAIN:\r\nbreak;\r\ndefault:\r\nif (!nfs_error_is_fatal(PTR_ERR(lseg))) {\r\npnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\r\nlseg = NULL;\r\n}\r\ngoto out_put_layout_hdr;\r\n}\r\nif (lseg) {\r\nif (first)\r\npnfs_clear_first_layoutget(lo);\r\ntrace_pnfs_update_layout(ino, pos, count,\r\niomode, lo, lseg, PNFS_UPDATE_LAYOUT_RETRY);\r\npnfs_put_layout_hdr(lo);\r\ngoto lookup_again;\r\n}\r\n} else {\r\npnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\r\n}\r\nout_put_layout_hdr:\r\nif (first)\r\npnfs_clear_first_layoutget(lo);\r\npnfs_put_layout_hdr(lo);\r\nout:\r\ndprintk("%s: inode %s/%llu pNFS layout segment %s for "\r\n"(%s, offset: %llu, length: %llu)\n",\r\n__func__, ino->i_sb->s_id,\r\n(unsigned long long)NFS_FILEID(ino),\r\nIS_ERR_OR_NULL(lseg) ? "not found" : "found",\r\niomode==IOMODE_RW ? "read/write" : "read-only",\r\n(unsigned long long)pos,\r\n(unsigned long long)count);\r\nreturn lseg;\r\nout_unlock:\r\nspin_unlock(&ino->i_lock);\r\ngoto out_put_layout_hdr;\r\n}\r\nstatic bool\r\npnfs_sanity_check_layout_range(struct pnfs_layout_range *range)\r\n{\r\nswitch (range->iomode) {\r\ncase IOMODE_READ:\r\ncase IOMODE_RW:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (range->offset == NFS4_MAX_UINT64)\r\nreturn false;\r\nif (range->length == 0)\r\nreturn false;\r\nif (range->length != NFS4_MAX_UINT64 &&\r\nrange->length > NFS4_MAX_UINT64 - range->offset)\r\nreturn false;\r\nreturn true;\r\n}\r\nstruct pnfs_layout_segment *\r\npnfs_layout_process(struct nfs4_layoutget *lgp)\r\n{\r\nstruct pnfs_layout_hdr *lo = NFS_I(lgp->args.inode)->layout;\r\nstruct nfs4_layoutget_res *res = &lgp->res;\r\nstruct pnfs_layout_segment *lseg;\r\nstruct inode *ino = lo->plh_inode;\r\nLIST_HEAD(free_me);\r\nif (!pnfs_sanity_check_layout_range(&res->range))\r\nreturn ERR_PTR(-EINVAL);\r\nlseg = NFS_SERVER(ino)->pnfs_curr_ld->alloc_lseg(lo, res, lgp->gfp_flags);\r\nif (IS_ERR_OR_NULL(lseg)) {\r\nif (!lseg)\r\nlseg = ERR_PTR(-ENOMEM);\r\ndprintk("%s: Could not allocate layout: error %ld\n",\r\n__func__, PTR_ERR(lseg));\r\nreturn lseg;\r\n}\r\npnfs_init_lseg(lo, lseg, &res->range, &res->stateid);\r\nspin_lock(&ino->i_lock);\r\nif (pnfs_layoutgets_blocked(lo)) {\r\ndprintk("%s forget reply due to state\n", __func__);\r\ngoto out_forget;\r\n}\r\nif (!pnfs_layout_is_valid(lo)) {\r\npnfs_set_layout_stateid(lo, &res->stateid, true);\r\n} else if (nfs4_stateid_match_other(&lo->plh_stateid, &res->stateid)) {\r\nif (pnfs_layout_stateid_blocked(lo, &res->stateid)) {\r\ndprintk("%s forget reply due to sequence\n", __func__);\r\ngoto out_forget;\r\n}\r\npnfs_set_layout_stateid(lo, &res->stateid, false);\r\n} else {\r\npnfs_mark_layout_stateid_invalid(lo, &free_me);\r\ngoto out_forget;\r\n}\r\npnfs_get_lseg(lseg);\r\npnfs_layout_insert_lseg(lo, lseg, &free_me);\r\nif (res->return_on_close)\r\nset_bit(NFS_LSEG_ROC, &lseg->pls_flags);\r\nspin_unlock(&ino->i_lock);\r\npnfs_free_lseg_list(&free_me);\r\nreturn lseg;\r\nout_forget:\r\nspin_unlock(&ino->i_lock);\r\nlseg->pls_layout = lo;\r\nNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nint\r\npnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,\r\nstruct list_head *tmp_list,\r\nconst struct pnfs_layout_range *return_range,\r\nu32 seq)\r\n{\r\nstruct pnfs_layout_segment *lseg, *next;\r\nint remaining = 0;\r\ndprintk("%s:Begin lo %p\n", __func__, lo);\r\nif (list_empty(&lo->plh_segs))\r\nreturn 0;\r\nassert_spin_locked(&lo->plh_inode->i_lock);\r\nlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\r\nif (pnfs_match_lseg_recall(lseg, return_range, seq)) {\r\ndprintk("%s: marking lseg %p iomode %d "\r\n"offset %llu length %llu\n", __func__,\r\nlseg, lseg->pls_range.iomode,\r\nlseg->pls_range.offset,\r\nlseg->pls_range.length);\r\nif (mark_lseg_invalid(lseg, tmp_list))\r\ncontinue;\r\nremaining++;\r\nset_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);\r\n}\r\nif (remaining)\r\npnfs_set_plh_return_info(lo, return_range->iomode, seq);\r\nreturn remaining;\r\n}\r\nvoid pnfs_error_mark_layout_for_return(struct inode *inode,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct pnfs_layout_hdr *lo = NFS_I(inode)->layout;\r\nstruct pnfs_layout_range range = {\r\n.iomode = lseg->pls_range.iomode,\r\n.offset = 0,\r\n.length = NFS4_MAX_UINT64,\r\n};\r\nbool return_now = false;\r\nspin_lock(&inode->i_lock);\r\npnfs_set_plh_return_info(lo, range.iomode, 0);\r\nset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\r\nif (!pnfs_mark_matching_lsegs_return(lo, &lo->plh_return_segs, &range, 0)) {\r\nnfs4_stateid stateid;\r\nenum pnfs_iomode iomode;\r\nreturn_now = pnfs_prepare_layoutreturn(lo, &stateid, &iomode);\r\nspin_unlock(&inode->i_lock);\r\nif (return_now)\r\npnfs_send_layoutreturn(lo, &stateid, iomode, false);\r\n} else {\r\nspin_unlock(&inode->i_lock);\r\nnfs_commit_inode(inode, 0);\r\n}\r\n}\r\nvoid\r\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\r\n{\r\nu64 rd_size = req->wb_bytes;\r\nif (pgio->pg_lseg == NULL) {\r\nif (pgio->pg_dreq == NULL)\r\nrd_size = i_size_read(pgio->pg_inode) - req_offset(req);\r\nelse\r\nrd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\nreq_offset(req),\r\nrd_size,\r\nIOMODE_READ,\r\nfalse,\r\nGFP_KERNEL);\r\nif (IS_ERR(pgio->pg_lseg)) {\r\npgio->pg_error = PTR_ERR(pgio->pg_lseg);\r\npgio->pg_lseg = NULL;\r\nreturn;\r\n}\r\n}\r\nif (pgio->pg_lseg == NULL)\r\nnfs_pageio_reset_read_mds(pgio);\r\n}\r\nvoid\r\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *req, u64 wb_size)\r\n{\r\nif (pgio->pg_lseg == NULL) {\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\nreq_offset(req),\r\nwb_size,\r\nIOMODE_RW,\r\nfalse,\r\nGFP_NOFS);\r\nif (IS_ERR(pgio->pg_lseg)) {\r\npgio->pg_error = PTR_ERR(pgio->pg_lseg);\r\npgio->pg_lseg = NULL;\r\nreturn;\r\n}\r\n}\r\nif (pgio->pg_lseg == NULL)\r\nnfs_pageio_reset_write_mds(pgio);\r\n}\r\nvoid\r\npnfs_generic_pg_cleanup(struct nfs_pageio_descriptor *desc)\r\n{\r\nif (desc->pg_lseg) {\r\npnfs_put_lseg(desc->pg_lseg);\r\ndesc->pg_lseg = NULL;\r\n}\r\n}\r\nsize_t\r\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *prev, struct nfs_page *req)\r\n{\r\nunsigned int size;\r\nu64 seg_end, req_start, seg_left;\r\nsize = nfs_generic_pg_test(pgio, prev, req);\r\nif (!size)\r\nreturn 0;\r\nif (pgio->pg_lseg) {\r\nseg_end = pnfs_end_offset(pgio->pg_lseg->pls_range.offset,\r\npgio->pg_lseg->pls_range.length);\r\nreq_start = req_offset(req);\r\nWARN_ON_ONCE(req_start >= seg_end);\r\nif (req_start >= seg_end) {\r\nif (pgio->pg_ops->pg_cleanup)\r\npgio->pg_ops->pg_cleanup(pgio);\r\nif (pgio->pg_ops->pg_init)\r\npgio->pg_ops->pg_init(pgio, req);\r\nreturn 0;\r\n}\r\nseg_left = seg_end - req_start;\r\nif (seg_left < size)\r\nsize = (unsigned int)seg_left;\r\n}\r\nreturn size;\r\n}\r\nint pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nnfs_pageio_init_write(&pgio, hdr->inode, FLUSH_STABLE, true,\r\nhdr->completion_ops);\r\nset_bit(NFS_CONTEXT_RESEND_WRITES, &hdr->args.context->flags);\r\nreturn nfs_pageio_resend(&pgio, hdr);\r\n}\r\nstatic void pnfs_ld_handle_write_error(struct nfs_pgio_header *hdr)\r\n{\r\ndprintk("pnfs write error = %d\n", hdr->pnfs_error);\r\nif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\r\nPNFS_LAYOUTRET_ON_ERROR) {\r\npnfs_return_layout(hdr->inode);\r\n}\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\r\nhdr->task.tk_status = pnfs_write_done_resend_to_mds(hdr);\r\n}\r\nvoid pnfs_ld_write_done(struct nfs_pgio_header *hdr)\r\n{\r\nif (likely(!hdr->pnfs_error)) {\r\npnfs_set_layoutcommit(hdr->inode, hdr->lseg,\r\nhdr->mds_offset + hdr->res.count);\r\nhdr->mds_ops->rpc_call_done(&hdr->task, hdr);\r\n}\r\ntrace_nfs4_pnfs_write(hdr, hdr->pnfs_error);\r\nif (unlikely(hdr->pnfs_error))\r\npnfs_ld_handle_write_error(hdr);\r\nhdr->mds_ops->rpc_release(hdr);\r\n}\r\nstatic void\r\npnfs_write_through_mds(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\nlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\r\nnfs_pageio_reset_write_mds(desc);\r\nmirror->pg_recoalesce = 1;\r\n}\r\nnfs_pgio_data_destroy(hdr);\r\nhdr->release(hdr);\r\n}\r\nstatic enum pnfs_try_status\r\npnfs_try_to_write_data(struct nfs_pgio_header *hdr,\r\nconst struct rpc_call_ops *call_ops,\r\nstruct pnfs_layout_segment *lseg,\r\nint how)\r\n{\r\nstruct inode *inode = hdr->inode;\r\nenum pnfs_try_status trypnfs;\r\nstruct nfs_server *nfss = NFS_SERVER(inode);\r\nhdr->mds_ops = call_ops;\r\ndprintk("%s: Writing ino:%lu %u@%llu (how %d)\n", __func__,\r\ninode->i_ino, hdr->args.count, hdr->args.offset, how);\r\ntrypnfs = nfss->pnfs_curr_ld->write_pagelist(hdr, how);\r\nif (trypnfs != PNFS_NOT_ATTEMPTED)\r\nnfs_inc_stats(inode, NFSIOS_PNFS_WRITE);\r\ndprintk("%s End (trypnfs:%d)\n", __func__, trypnfs);\r\nreturn trypnfs;\r\n}\r\nstatic void\r\npnfs_do_write(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr, int how)\r\n{\r\nconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\r\nstruct pnfs_layout_segment *lseg = desc->pg_lseg;\r\nenum pnfs_try_status trypnfs;\r\ntrypnfs = pnfs_try_to_write_data(hdr, call_ops, lseg, how);\r\nif (trypnfs == PNFS_NOT_ATTEMPTED)\r\npnfs_write_through_mds(desc, hdr);\r\n}\r\nstatic void pnfs_writehdr_free(struct nfs_pgio_header *hdr)\r\n{\r\npnfs_put_lseg(hdr->lseg);\r\nnfs_pgio_header_free(hdr);\r\n}\r\nint\r\npnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc)\r\n{\r\nstruct nfs_pgio_header *hdr;\r\nint ret;\r\nhdr = nfs_pgio_header_alloc(desc->pg_rw_ops);\r\nif (!hdr) {\r\ndesc->pg_error = -ENOMEM;\r\nreturn desc->pg_error;\r\n}\r\nnfs_pgheader_init(desc, hdr, pnfs_writehdr_free);\r\nhdr->lseg = pnfs_get_lseg(desc->pg_lseg);\r\nret = nfs_generic_pgio(desc, hdr);\r\nif (!ret)\r\npnfs_do_write(desc, hdr, desc->pg_ioflags);\r\nreturn ret;\r\n}\r\nint pnfs_read_done_resend_to_mds(struct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nnfs_pageio_init_read(&pgio, hdr->inode, true, hdr->completion_ops);\r\nreturn nfs_pageio_resend(&pgio, hdr);\r\n}\r\nstatic void pnfs_ld_handle_read_error(struct nfs_pgio_header *hdr)\r\n{\r\ndprintk("pnfs read error = %d\n", hdr->pnfs_error);\r\nif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\r\nPNFS_LAYOUTRET_ON_ERROR) {\r\npnfs_return_layout(hdr->inode);\r\n}\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\r\nhdr->task.tk_status = pnfs_read_done_resend_to_mds(hdr);\r\n}\r\nvoid pnfs_ld_read_done(struct nfs_pgio_header *hdr)\r\n{\r\nif (likely(!hdr->pnfs_error))\r\nhdr->mds_ops->rpc_call_done(&hdr->task, hdr);\r\ntrace_nfs4_pnfs_read(hdr, hdr->pnfs_error);\r\nif (unlikely(hdr->pnfs_error))\r\npnfs_ld_handle_read_error(hdr);\r\nhdr->mds_ops->rpc_release(hdr);\r\n}\r\nstatic void\r\npnfs_read_through_mds(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(desc);\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\nlist_splice_tail_init(&hdr->pages, &mirror->pg_list);\r\nnfs_pageio_reset_read_mds(desc);\r\nmirror->pg_recoalesce = 1;\r\n}\r\nnfs_pgio_data_destroy(hdr);\r\nhdr->release(hdr);\r\n}\r\nstatic enum pnfs_try_status\r\npnfs_try_to_read_data(struct nfs_pgio_header *hdr,\r\nconst struct rpc_call_ops *call_ops,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct inode *inode = hdr->inode;\r\nstruct nfs_server *nfss = NFS_SERVER(inode);\r\nenum pnfs_try_status trypnfs;\r\nhdr->mds_ops = call_ops;\r\ndprintk("%s: Reading ino:%lu %u@%llu\n",\r\n__func__, inode->i_ino, hdr->args.count, hdr->args.offset);\r\ntrypnfs = nfss->pnfs_curr_ld->read_pagelist(hdr);\r\nif (trypnfs != PNFS_NOT_ATTEMPTED)\r\nnfs_inc_stats(inode, NFSIOS_PNFS_READ);\r\ndprintk("%s End (trypnfs:%d)\n", __func__, trypnfs);\r\nreturn trypnfs;\r\n}\r\nvoid pnfs_read_resend_pnfs(struct nfs_pgio_header *hdr)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\npnfs_put_lseg(hdr->lseg);\r\nhdr->lseg = NULL;\r\nnfs_pageio_init_read(&pgio, hdr->inode, false,\r\nhdr->completion_ops);\r\nhdr->task.tk_status = nfs_pageio_resend(&pgio, hdr);\r\n}\r\n}\r\nstatic void\r\npnfs_do_read(struct nfs_pageio_descriptor *desc, struct nfs_pgio_header *hdr)\r\n{\r\nconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\r\nstruct pnfs_layout_segment *lseg = desc->pg_lseg;\r\nenum pnfs_try_status trypnfs;\r\ntrypnfs = pnfs_try_to_read_data(hdr, call_ops, lseg);\r\nif (trypnfs == PNFS_TRY_AGAIN)\r\npnfs_read_resend_pnfs(hdr);\r\nif (trypnfs == PNFS_NOT_ATTEMPTED || hdr->task.tk_status)\r\npnfs_read_through_mds(desc, hdr);\r\n}\r\nstatic void pnfs_readhdr_free(struct nfs_pgio_header *hdr)\r\n{\r\npnfs_put_lseg(hdr->lseg);\r\nnfs_pgio_header_free(hdr);\r\n}\r\nint\r\npnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)\r\n{\r\nstruct nfs_pgio_header *hdr;\r\nint ret;\r\nhdr = nfs_pgio_header_alloc(desc->pg_rw_ops);\r\nif (!hdr) {\r\ndesc->pg_error = -ENOMEM;\r\nreturn desc->pg_error;\r\n}\r\nnfs_pgheader_init(desc, hdr, pnfs_readhdr_free);\r\nhdr->lseg = pnfs_get_lseg(desc->pg_lseg);\r\nret = nfs_generic_pgio(desc, hdr);\r\nif (!ret)\r\npnfs_do_read(desc, hdr);\r\nreturn ret;\r\n}\r\nstatic void pnfs_clear_layoutcommitting(struct inode *inode)\r\n{\r\nunsigned long *bitlock = &NFS_I(inode)->flags;\r\nclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\r\nsmp_mb__after_atomic();\r\nwake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\r\n}\r\nstatic void pnfs_list_write_lseg(struct inode *inode, struct list_head *listp)\r\n{\r\nstruct pnfs_layout_segment *lseg;\r\nlist_for_each_entry(lseg, &NFS_I(inode)->layout->plh_segs, pls_list) {\r\nif (lseg->pls_range.iomode == IOMODE_RW &&\r\ntest_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\r\nlist_add(&lseg->pls_lc_list, listp);\r\n}\r\n}\r\nstatic void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\r\n{\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\r\nlist_del_init(&lseg->pls_lc_list);\r\npnfs_put_lseg(lseg);\r\n}\r\npnfs_clear_layoutcommitting(inode);\r\n}\r\nvoid pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\r\n{\r\npnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\r\n}\r\nvoid\r\npnfs_set_layoutcommit(struct inode *inode, struct pnfs_layout_segment *lseg,\r\nloff_t end_pos)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nbool mark_as_dirty = false;\r\nspin_lock(&inode->i_lock);\r\nif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\r\nnfsi->layout->plh_lwb = end_pos;\r\nmark_as_dirty = true;\r\ndprintk("%s: Set layoutcommit for inode %lu ",\r\n__func__, inode->i_ino);\r\n} else if (end_pos > nfsi->layout->plh_lwb)\r\nnfsi->layout->plh_lwb = end_pos;\r\nif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags)) {\r\npnfs_get_lseg(lseg);\r\n}\r\nspin_unlock(&inode->i_lock);\r\ndprintk("%s: lseg %p end_pos %llu\n",\r\n__func__, lseg, nfsi->layout->plh_lwb);\r\nif (mark_as_dirty)\r\nmark_inode_dirty_sync(inode);\r\n}\r\nvoid pnfs_cleanup_layoutcommit(struct nfs4_layoutcommit_data *data)\r\n{\r\nstruct nfs_server *nfss = NFS_SERVER(data->args.inode);\r\nif (nfss->pnfs_curr_ld->cleanup_layoutcommit)\r\nnfss->pnfs_curr_ld->cleanup_layoutcommit(data);\r\npnfs_list_write_lseg_done(data->args.inode, &data->lseg_list);\r\n}\r\nint\r\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\r\n{\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\r\nstruct nfs4_layoutcommit_data *data;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nloff_t end_pos;\r\nint status;\r\nif (!pnfs_layoutcommit_outstanding(inode))\r\nreturn 0;\r\ndprintk("--> %s inode %lu\n", __func__, inode->i_ino);\r\nstatus = -EAGAIN;\r\nif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\r\nif (!sync)\r\ngoto out;\r\nstatus = wait_on_bit_lock_action(&nfsi->flags,\r\nNFS_INO_LAYOUTCOMMITTING,\r\nnfs_wait_bit_killable,\r\nTASK_KILLABLE);\r\nif (status)\r\ngoto out;\r\n}\r\nstatus = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_NOFS);\r\nif (!data)\r\ngoto clear_layoutcommitting;\r\nstatus = 0;\r\nspin_lock(&inode->i_lock);\r\nif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\r\ngoto out_unlock;\r\nINIT_LIST_HEAD(&data->lseg_list);\r\npnfs_list_write_lseg(inode, &data->lseg_list);\r\nend_pos = nfsi->layout->plh_lwb;\r\nnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\r\nspin_unlock(&inode->i_lock);\r\ndata->args.inode = inode;\r\ndata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\r\nnfs_fattr_init(&data->fattr);\r\ndata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\r\ndata->res.fattr = &data->fattr;\r\nif (end_pos != 0)\r\ndata->args.lastbytewritten = end_pos - 1;\r\nelse\r\ndata->args.lastbytewritten = U64_MAX;\r\ndata->res.server = NFS_SERVER(inode);\r\nif (ld->prepare_layoutcommit) {\r\nstatus = ld->prepare_layoutcommit(&data->args);\r\nif (status) {\r\nput_rpccred(data->cred);\r\nspin_lock(&inode->i_lock);\r\nset_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags);\r\nif (end_pos > nfsi->layout->plh_lwb)\r\nnfsi->layout->plh_lwb = end_pos;\r\ngoto out_unlock;\r\n}\r\n}\r\nstatus = nfs4_proc_layoutcommit(data, sync);\r\nout:\r\nif (status)\r\nmark_inode_dirty_sync(inode);\r\ndprintk("<-- %s status %d\n", __func__, status);\r\nreturn status;\r\nout_unlock:\r\nspin_unlock(&inode->i_lock);\r\nkfree(data);\r\nclear_layoutcommitting:\r\npnfs_clear_layoutcommitting(inode);\r\ngoto out;\r\n}\r\nint\r\npnfs_generic_sync(struct inode *inode, bool datasync)\r\n{\r\nreturn pnfs_layoutcommit_inode(inode, true);\r\n}\r\nstruct nfs4_threshold *pnfs_mdsthreshold_alloc(void)\r\n{\r\nstruct nfs4_threshold *thp;\r\nthp = kzalloc(sizeof(*thp), GFP_NOFS);\r\nif (!thp) {\r\ndprintk("%s mdsthreshold allocation failed\n", __func__);\r\nreturn NULL;\r\n}\r\nreturn thp;\r\n}\r\nint\r\npnfs_report_layoutstat(struct inode *inode, gfp_t gfp_flags)\r\n{\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(inode)->pnfs_curr_ld;\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct nfs42_layoutstat_data *data;\r\nstruct pnfs_layout_hdr *hdr;\r\nint status = 0;\r\nif (!pnfs_enabled_sb(server) || !ld->prepare_layoutstats)\r\ngoto out;\r\nif (!nfs_server_capable(inode, NFS_CAP_LAYOUTSTATS))\r\ngoto out;\r\nif (test_and_set_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags))\r\ngoto out;\r\nspin_lock(&inode->i_lock);\r\nif (!NFS_I(inode)->layout) {\r\nspin_unlock(&inode->i_lock);\r\ngoto out_clear_layoutstats;\r\n}\r\nhdr = NFS_I(inode)->layout;\r\npnfs_get_layout_hdr(hdr);\r\nspin_unlock(&inode->i_lock);\r\ndata = kzalloc(sizeof(*data), gfp_flags);\r\nif (!data) {\r\nstatus = -ENOMEM;\r\ngoto out_put;\r\n}\r\ndata->args.fh = NFS_FH(inode);\r\ndata->args.inode = inode;\r\nstatus = ld->prepare_layoutstats(&data->args);\r\nif (status)\r\ngoto out_free;\r\nstatus = nfs42_proc_layoutstats_generic(NFS_SERVER(inode), data);\r\nout:\r\ndprintk("%s returns %d\n", __func__, status);\r\nreturn status;\r\nout_free:\r\nkfree(data);\r\nout_put:\r\npnfs_put_layout_hdr(hdr);\r\nout_clear_layoutstats:\r\nsmp_mb__before_atomic();\r\nclear_bit(NFS_INO_LAYOUTSTATS, &nfsi->flags);\r\nsmp_mb__after_atomic();\r\ngoto out;\r\n}
