struct videobuf_buffer *videobuf_alloc_vb(struct videobuf_queue *q)\r\n{\r\nstruct videobuf_buffer *vb;\r\nBUG_ON(q->msize < sizeof(*vb));\r\nif (!q->int_ops || !q->int_ops->alloc_vb) {\r\nprintk(KERN_ERR "No specific ops defined!\n");\r\nBUG();\r\n}\r\nvb = q->int_ops->alloc_vb(q->msize);\r\nif (NULL != vb) {\r\ninit_waitqueue_head(&vb->done);\r\nvb->magic = MAGIC_BUFFER;\r\n}\r\nreturn vb;\r\n}\r\nstatic int state_neither_active_nor_queued(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nunsigned long flags;\r\nbool rc;\r\nspin_lock_irqsave(q->irqlock, flags);\r\nrc = vb->state != VIDEOBUF_ACTIVE && vb->state != VIDEOBUF_QUEUED;\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nreturn rc;\r\n}\r\nint videobuf_waiton(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nint non_blocking, int intr)\r\n{\r\nbool is_ext_locked;\r\nint ret = 0;\r\nMAGIC_CHECK(vb->magic, MAGIC_BUFFER);\r\nif (non_blocking) {\r\nif (state_neither_active_nor_queued(q, vb))\r\nreturn 0;\r\nreturn -EAGAIN;\r\n}\r\nis_ext_locked = q->ext_lock && mutex_is_locked(q->ext_lock);\r\nif (is_ext_locked)\r\nmutex_unlock(q->ext_lock);\r\nif (intr)\r\nret = wait_event_interruptible(vb->done,\r\nstate_neither_active_nor_queued(q, vb));\r\nelse\r\nwait_event(vb->done, state_neither_active_nor_queued(q, vb));\r\nif (is_ext_locked)\r\nmutex_lock(q->ext_lock);\r\nreturn ret;\r\n}\r\nint videobuf_iolock(struct videobuf_queue *q, struct videobuf_buffer *vb,\r\nstruct v4l2_framebuffer *fbuf)\r\n{\r\nMAGIC_CHECK(vb->magic, MAGIC_BUFFER);\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nreturn CALL(q, iolock, q, vb, fbuf);\r\n}\r\nvoid *videobuf_queue_to_vaddr(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf)\r\n{\r\nif (q->int_ops->vaddr)\r\nreturn q->int_ops->vaddr(buf);\r\nreturn NULL;\r\n}\r\nvoid videobuf_queue_core_init(struct videobuf_queue *q,\r\nconst struct videobuf_queue_ops *ops,\r\nstruct device *dev,\r\nspinlock_t *irqlock,\r\nenum v4l2_buf_type type,\r\nenum v4l2_field field,\r\nunsigned int msize,\r\nvoid *priv,\r\nstruct videobuf_qtype_ops *int_ops,\r\nstruct mutex *ext_lock)\r\n{\r\nBUG_ON(!q);\r\nmemset(q, 0, sizeof(*q));\r\nq->irqlock = irqlock;\r\nq->ext_lock = ext_lock;\r\nq->dev = dev;\r\nq->type = type;\r\nq->field = field;\r\nq->msize = msize;\r\nq->ops = ops;\r\nq->priv_data = priv;\r\nq->int_ops = int_ops;\r\nBUG_ON(!q->ops->buf_setup);\r\nBUG_ON(!q->ops->buf_prepare);\r\nBUG_ON(!q->ops->buf_queue);\r\nBUG_ON(!q->ops->buf_release);\r\nBUG_ON(!irqlock);\r\nBUG_ON(!q->int_ops);\r\nmutex_init(&q->vb_lock);\r\ninit_waitqueue_head(&q->wait);\r\nINIT_LIST_HEAD(&q->stream);\r\n}\r\nint videobuf_queue_is_busy(struct videobuf_queue *q)\r\n{\r\nint i;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nif (q->streaming) {\r\ndprintk(1, "busy: streaming active\n");\r\nreturn 1;\r\n}\r\nif (q->reading) {\r\ndprintk(1, "busy: pending read #1\n");\r\nreturn 1;\r\n}\r\nif (q->read_buf) {\r\ndprintk(1, "busy: pending read #2\n");\r\nreturn 1;\r\n}\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nif (q->bufs[i]->map) {\r\ndprintk(1, "busy: buffer #%d mapped\n", i);\r\nreturn 1;\r\n}\r\nif (q->bufs[i]->state == VIDEOBUF_QUEUED) {\r\ndprintk(1, "busy: buffer #%d queued\n", i);\r\nreturn 1;\r\n}\r\nif (q->bufs[i]->state == VIDEOBUF_ACTIVE) {\r\ndprintk(1, "busy: buffer #%d avtive\n", i);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __videobuf_free(struct videobuf_queue *q)\r\n{\r\nint i;\r\ndprintk(1, "%s\n", __func__);\r\nif (!q)\r\nreturn 0;\r\nif (q->streaming || q->reading) {\r\ndprintk(1, "Cannot free buffers when streaming or reading\n");\r\nreturn -EBUSY;\r\n}\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++)\r\nif (q->bufs[i] && q->bufs[i]->map) {\r\ndprintk(1, "Cannot free mmapped buffers\n");\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nq->ops->buf_release(q, q->bufs[i]);\r\nkfree(q->bufs[i]);\r\nq->bufs[i] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nvoid videobuf_queue_cancel(struct videobuf_queue *q)\r\n{\r\nunsigned long flags = 0;\r\nint i;\r\nq->streaming = 0;\r\nq->reading = 0;\r\nwake_up_interruptible_sync(&q->wait);\r\nspin_lock_irqsave(q->irqlock, flags);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nif (q->bufs[i]->state == VIDEOBUF_QUEUED) {\r\nlist_del(&q->bufs[i]->queue);\r\nq->bufs[i]->state = VIDEOBUF_ERROR;\r\nwake_up_all(&q->bufs[i]->done);\r\n}\r\n}\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nq->ops->buf_release(q, q->bufs[i]);\r\n}\r\nINIT_LIST_HEAD(&q->stream);\r\n}\r\nenum v4l2_field videobuf_next_field(struct videobuf_queue *q)\r\n{\r\nenum v4l2_field field = q->field;\r\nBUG_ON(V4L2_FIELD_ANY == field);\r\nif (V4L2_FIELD_ALTERNATE == field) {\r\nif (V4L2_FIELD_TOP == q->last) {\r\nfield = V4L2_FIELD_BOTTOM;\r\nq->last = V4L2_FIELD_BOTTOM;\r\n} else {\r\nfield = V4L2_FIELD_TOP;\r\nq->last = V4L2_FIELD_TOP;\r\n}\r\n}\r\nreturn field;\r\n}\r\nstatic void videobuf_status(struct videobuf_queue *q, struct v4l2_buffer *b,\r\nstruct videobuf_buffer *vb, enum v4l2_buf_type type)\r\n{\r\nMAGIC_CHECK(vb->magic, MAGIC_BUFFER);\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nb->index = vb->i;\r\nb->type = type;\r\nb->memory = vb->memory;\r\nswitch (b->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nb->m.offset = vb->boff;\r\nb->length = vb->bsize;\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nb->m.userptr = vb->baddr;\r\nb->length = vb->bsize;\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\nb->m.offset = vb->boff;\r\nbreak;\r\ncase V4L2_MEMORY_DMABUF:\r\nbreak;\r\n}\r\nb->flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nif (vb->map)\r\nb->flags |= V4L2_BUF_FLAG_MAPPED;\r\nswitch (vb->state) {\r\ncase VIDEOBUF_PREPARED:\r\ncase VIDEOBUF_QUEUED:\r\ncase VIDEOBUF_ACTIVE:\r\nb->flags |= V4L2_BUF_FLAG_QUEUED;\r\nbreak;\r\ncase VIDEOBUF_ERROR:\r\nb->flags |= V4L2_BUF_FLAG_ERROR;\r\ncase VIDEOBUF_DONE:\r\nb->flags |= V4L2_BUF_FLAG_DONE;\r\nbreak;\r\ncase VIDEOBUF_NEEDS_INIT:\r\ncase VIDEOBUF_IDLE:\r\nbreak;\r\n}\r\nb->field = vb->field;\r\nb->timestamp = vb->ts;\r\nb->bytesused = vb->size;\r\nb->sequence = vb->field_count >> 1;\r\n}\r\nint videobuf_mmap_free(struct videobuf_queue *q)\r\n{\r\nint ret;\r\nvideobuf_queue_lock(q);\r\nret = __videobuf_free(q);\r\nvideobuf_queue_unlock(q);\r\nreturn ret;\r\n}\r\nint __videobuf_mmap_setup(struct videobuf_queue *q,\r\nunsigned int bcount, unsigned int bsize,\r\nenum v4l2_memory memory)\r\n{\r\nunsigned int i;\r\nint err;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nerr = __videobuf_free(q);\r\nif (0 != err)\r\nreturn err;\r\nfor (i = 0; i < bcount; i++) {\r\nq->bufs[i] = videobuf_alloc_vb(q);\r\nif (NULL == q->bufs[i])\r\nbreak;\r\nq->bufs[i]->i = i;\r\nq->bufs[i]->memory = memory;\r\nq->bufs[i]->bsize = bsize;\r\nswitch (memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nq->bufs[i]->boff = PAGE_ALIGN(bsize) * i;\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\ncase V4L2_MEMORY_OVERLAY:\r\ncase V4L2_MEMORY_DMABUF:\r\nbreak;\r\n}\r\n}\r\nif (!i)\r\nreturn -ENOMEM;\r\ndprintk(1, "mmap setup: %d buffers, %d bytes each\n", i, bsize);\r\nreturn i;\r\n}\r\nint videobuf_mmap_setup(struct videobuf_queue *q,\r\nunsigned int bcount, unsigned int bsize,\r\nenum v4l2_memory memory)\r\n{\r\nint ret;\r\nvideobuf_queue_lock(q);\r\nret = __videobuf_mmap_setup(q, bcount, bsize, memory);\r\nvideobuf_queue_unlock(q);\r\nreturn ret;\r\n}\r\nint videobuf_reqbufs(struct videobuf_queue *q,\r\nstruct v4l2_requestbuffers *req)\r\n{\r\nunsigned int size, count;\r\nint retval;\r\nif (req->memory != V4L2_MEMORY_MMAP &&\r\nreq->memory != V4L2_MEMORY_USERPTR &&\r\nreq->memory != V4L2_MEMORY_OVERLAY) {\r\ndprintk(1, "reqbufs: memory type invalid\n");\r\nreturn -EINVAL;\r\n}\r\nvideobuf_queue_lock(q);\r\nif (req->type != q->type) {\r\ndprintk(1, "reqbufs: queue type invalid\n");\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nif (q->streaming) {\r\ndprintk(1, "reqbufs: streaming already exists\n");\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\nif (!list_empty(&q->stream)) {\r\ndprintk(1, "reqbufs: stream running\n");\r\nretval = -EBUSY;\r\ngoto done;\r\n}\r\nif (req->count == 0) {\r\ndprintk(1, "reqbufs: count invalid (%d)\n", req->count);\r\nretval = __videobuf_free(q);\r\ngoto done;\r\n}\r\ncount = req->count;\r\nif (count > VIDEO_MAX_FRAME)\r\ncount = VIDEO_MAX_FRAME;\r\nsize = 0;\r\nq->ops->buf_setup(q, &count, &size);\r\ndprintk(1, "reqbufs: bufs=%d, size=0x%x [%u pages total]\n",\r\ncount, size,\r\n(unsigned int)((count * PAGE_ALIGN(size)) >> PAGE_SHIFT));\r\nretval = __videobuf_mmap_setup(q, count, size, req->memory);\r\nif (retval < 0) {\r\ndprintk(1, "reqbufs: mmap setup returned %d\n", retval);\r\ngoto done;\r\n}\r\nreq->count = retval;\r\nretval = 0;\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nreturn retval;\r\n}\r\nint videobuf_querybuf(struct videobuf_queue *q, struct v4l2_buffer *b)\r\n{\r\nint ret = -EINVAL;\r\nvideobuf_queue_lock(q);\r\nif (unlikely(b->type != q->type)) {\r\ndprintk(1, "querybuf: Wrong type.\n");\r\ngoto done;\r\n}\r\nif (unlikely(b->index >= VIDEO_MAX_FRAME)) {\r\ndprintk(1, "querybuf: index out of range.\n");\r\ngoto done;\r\n}\r\nif (unlikely(NULL == q->bufs[b->index])) {\r\ndprintk(1, "querybuf: buffer is null.\n");\r\ngoto done;\r\n}\r\nvideobuf_status(q, b, q->bufs[b->index], q->type);\r\nret = 0;\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nreturn ret;\r\n}\r\nint videobuf_qbuf(struct videobuf_queue *q, struct v4l2_buffer *b)\r\n{\r\nstruct videobuf_buffer *buf;\r\nenum v4l2_field field;\r\nunsigned long flags = 0;\r\nint retval;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nif (b->memory == V4L2_MEMORY_MMAP)\r\ndown_read(&current->mm->mmap_sem);\r\nvideobuf_queue_lock(q);\r\nretval = -EBUSY;\r\nif (q->reading) {\r\ndprintk(1, "qbuf: Reading running...\n");\r\ngoto done;\r\n}\r\nretval = -EINVAL;\r\nif (b->type != q->type) {\r\ndprintk(1, "qbuf: Wrong type.\n");\r\ngoto done;\r\n}\r\nif (b->index >= VIDEO_MAX_FRAME) {\r\ndprintk(1, "qbuf: index out of range.\n");\r\ngoto done;\r\n}\r\nbuf = q->bufs[b->index];\r\nif (NULL == buf) {\r\ndprintk(1, "qbuf: buffer is null.\n");\r\ngoto done;\r\n}\r\nMAGIC_CHECK(buf->magic, MAGIC_BUFFER);\r\nif (buf->memory != b->memory) {\r\ndprintk(1, "qbuf: memory type is wrong.\n");\r\ngoto done;\r\n}\r\nif (buf->state != VIDEOBUF_NEEDS_INIT && buf->state != VIDEOBUF_IDLE) {\r\ndprintk(1, "qbuf: buffer is already queued or active.\n");\r\ngoto done;\r\n}\r\nswitch (b->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nif (0 == buf->baddr) {\r\ndprintk(1, "qbuf: mmap requested but buffer addr is zero!\n");\r\ngoto done;\r\n}\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT\r\n|| q->type == V4L2_BUF_TYPE_VBI_OUTPUT\r\n|| q->type == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT\r\n|| q->type == V4L2_BUF_TYPE_SDR_OUTPUT) {\r\nbuf->size = b->bytesused;\r\nbuf->field = b->field;\r\nbuf->ts = b->timestamp;\r\n}\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nif (b->length < buf->bsize) {\r\ndprintk(1, "qbuf: buffer length is not enough\n");\r\ngoto done;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT != buf->state &&\r\nbuf->baddr != b->m.userptr)\r\nq->ops->buf_release(q, buf);\r\nbuf->baddr = b->m.userptr;\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\nbuf->boff = b->m.offset;\r\nbreak;\r\ndefault:\r\ndprintk(1, "qbuf: wrong memory type\n");\r\ngoto done;\r\n}\r\ndprintk(1, "qbuf: requesting next field\n");\r\nfield = videobuf_next_field(q);\r\nretval = q->ops->buf_prepare(q, buf, field);\r\nif (0 != retval) {\r\ndprintk(1, "qbuf: buffer_prepare returned %d\n", retval);\r\ngoto done;\r\n}\r\nlist_add_tail(&buf->stream, &q->stream);\r\nif (q->streaming) {\r\nspin_lock_irqsave(q->irqlock, flags);\r\nq->ops->buf_queue(q, buf);\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\n}\r\ndprintk(1, "qbuf: succeeded\n");\r\nretval = 0;\r\nwake_up_interruptible_sync(&q->wait);\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nif (b->memory == V4L2_MEMORY_MMAP)\r\nup_read(&current->mm->mmap_sem);\r\nreturn retval;\r\n}\r\nstatic int stream_next_buffer_check_queue(struct videobuf_queue *q, int noblock)\r\n{\r\nint retval;\r\nchecks:\r\nif (!q->streaming) {\r\ndprintk(1, "next_buffer: Not streaming\n");\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nif (list_empty(&q->stream)) {\r\nif (noblock) {\r\nretval = -EAGAIN;\r\ndprintk(2, "next_buffer: no buffers to dequeue\n");\r\ngoto done;\r\n} else {\r\ndprintk(2, "next_buffer: waiting on buffer\n");\r\nvideobuf_queue_unlock(q);\r\nretval = wait_event_interruptible(q->wait,\r\n!list_empty(&q->stream) || !q->streaming);\r\nvideobuf_queue_lock(q);\r\nif (retval)\r\ngoto done;\r\ngoto checks;\r\n}\r\n}\r\nretval = 0;\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int stream_next_buffer(struct videobuf_queue *q,\r\nstruct videobuf_buffer **vb, int nonblocking)\r\n{\r\nint retval;\r\nstruct videobuf_buffer *buf = NULL;\r\nretval = stream_next_buffer_check_queue(q, nonblocking);\r\nif (retval)\r\ngoto done;\r\nbuf = list_entry(q->stream.next, struct videobuf_buffer, stream);\r\nretval = videobuf_waiton(q, buf, nonblocking, 1);\r\nif (retval < 0)\r\ngoto done;\r\n*vb = buf;\r\ndone:\r\nreturn retval;\r\n}\r\nint videobuf_dqbuf(struct videobuf_queue *q,\r\nstruct v4l2_buffer *b, int nonblocking)\r\n{\r\nstruct videobuf_buffer *buf = NULL;\r\nint retval;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nmemset(b, 0, sizeof(*b));\r\nvideobuf_queue_lock(q);\r\nretval = stream_next_buffer(q, &buf, nonblocking);\r\nif (retval < 0) {\r\ndprintk(1, "dqbuf: next_buffer error: %i\n", retval);\r\ngoto done;\r\n}\r\nswitch (buf->state) {\r\ncase VIDEOBUF_ERROR:\r\ndprintk(1, "dqbuf: state is error\n");\r\nbreak;\r\ncase VIDEOBUF_DONE:\r\ndprintk(1, "dqbuf: state is done\n");\r\nbreak;\r\ndefault:\r\ndprintk(1, "dqbuf: state invalid\n");\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nCALL(q, sync, q, buf);\r\nvideobuf_status(q, b, buf, q->type);\r\nlist_del(&buf->stream);\r\nbuf->state = VIDEOBUF_IDLE;\r\nb->flags &= ~V4L2_BUF_FLAG_DONE;\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nreturn retval;\r\n}\r\nint videobuf_streamon(struct videobuf_queue *q)\r\n{\r\nstruct videobuf_buffer *buf;\r\nunsigned long flags = 0;\r\nint retval;\r\nvideobuf_queue_lock(q);\r\nretval = -EBUSY;\r\nif (q->reading)\r\ngoto done;\r\nretval = 0;\r\nif (q->streaming)\r\ngoto done;\r\nq->streaming = 1;\r\nspin_lock_irqsave(q->irqlock, flags);\r\nlist_for_each_entry(buf, &q->stream, stream)\r\nif (buf->state == VIDEOBUF_PREPARED)\r\nq->ops->buf_queue(q, buf);\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nwake_up_interruptible_sync(&q->wait);\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nreturn retval;\r\n}\r\nstatic int __videobuf_streamoff(struct videobuf_queue *q)\r\n{\r\nif (!q->streaming)\r\nreturn -EINVAL;\r\nvideobuf_queue_cancel(q);\r\nreturn 0;\r\n}\r\nint videobuf_streamoff(struct videobuf_queue *q)\r\n{\r\nint retval;\r\nvideobuf_queue_lock(q);\r\nretval = __videobuf_streamoff(q);\r\nvideobuf_queue_unlock(q);\r\nreturn retval;\r\n}\r\nstatic ssize_t videobuf_read_zerocopy(struct videobuf_queue *q,\r\nchar __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nenum v4l2_field field;\r\nunsigned long flags = 0;\r\nint retval;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nq->read_buf = videobuf_alloc_vb(q);\r\nif (NULL == q->read_buf)\r\nreturn -ENOMEM;\r\nq->read_buf->memory = V4L2_MEMORY_USERPTR;\r\nq->read_buf->baddr = (unsigned long)data;\r\nq->read_buf->bsize = count;\r\nfield = videobuf_next_field(q);\r\nretval = q->ops->buf_prepare(q, q->read_buf, field);\r\nif (0 != retval)\r\ngoto done;\r\nspin_lock_irqsave(q->irqlock, flags);\r\nq->ops->buf_queue(q, q->read_buf);\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nretval = videobuf_waiton(q, q->read_buf, 0, 0);\r\nif (0 == retval) {\r\nCALL(q, sync, q, q->read_buf);\r\nif (VIDEOBUF_ERROR == q->read_buf->state)\r\nretval = -EIO;\r\nelse\r\nretval = q->read_buf->size;\r\n}\r\ndone:\r\nq->ops->buf_release(q, q->read_buf);\r\nkfree(q->read_buf);\r\nq->read_buf = NULL;\r\nreturn retval;\r\n}\r\nstatic int __videobuf_copy_to_user(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf,\r\nchar __user *data, size_t count,\r\nint nonblocking)\r\n{\r\nvoid *vaddr = CALLPTR(q, vaddr, buf);\r\nif (count > buf->size - q->read_off)\r\ncount = buf->size - q->read_off;\r\nif (copy_to_user(data, vaddr + q->read_off, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic int __videobuf_copy_stream(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf,\r\nchar __user *data, size_t count, size_t pos,\r\nint vbihack, int nonblocking)\r\n{\r\nunsigned int *fc = CALLPTR(q, vaddr, buf);\r\nif (vbihack) {\r\nfc += (buf->size >> 2) - 1;\r\n*fc = buf->field_count >> 1;\r\ndprintk(1, "vbihack: %d\n", *fc);\r\n}\r\ncount = __videobuf_copy_to_user(q, buf, data, count, nonblocking);\r\nif ((count == -EFAULT) && (pos == 0))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nssize_t videobuf_read_one(struct videobuf_queue *q,\r\nchar __user *data, size_t count, loff_t *ppos,\r\nint nonblocking)\r\n{\r\nenum v4l2_field field;\r\nunsigned long flags = 0;\r\nunsigned size = 0, nbufs = 1;\r\nint retval;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nvideobuf_queue_lock(q);\r\nq->ops->buf_setup(q, &nbufs, &size);\r\nif (NULL == q->read_buf &&\r\ncount >= size &&\r\n!nonblocking) {\r\nretval = videobuf_read_zerocopy(q, data, count, ppos);\r\nif (retval >= 0 || retval == -EIO)\r\ngoto done;\r\n}\r\nif (NULL == q->read_buf) {\r\nretval = -ENOMEM;\r\nq->read_buf = videobuf_alloc_vb(q);\r\ndprintk(1, "video alloc=0x%p\n", q->read_buf);\r\nif (NULL == q->read_buf)\r\ngoto done;\r\nq->read_buf->memory = V4L2_MEMORY_USERPTR;\r\nq->read_buf->bsize = count;\r\nfield = videobuf_next_field(q);\r\nretval = q->ops->buf_prepare(q, q->read_buf, field);\r\nif (0 != retval) {\r\nkfree(q->read_buf);\r\nq->read_buf = NULL;\r\ngoto done;\r\n}\r\nspin_lock_irqsave(q->irqlock, flags);\r\nq->ops->buf_queue(q, q->read_buf);\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nq->read_off = 0;\r\n}\r\nretval = videobuf_waiton(q, q->read_buf, nonblocking, 1);\r\nif (0 != retval)\r\ngoto done;\r\nCALL(q, sync, q, q->read_buf);\r\nif (VIDEOBUF_ERROR == q->read_buf->state) {\r\nq->ops->buf_release(q, q->read_buf);\r\nkfree(q->read_buf);\r\nq->read_buf = NULL;\r\nretval = -EIO;\r\ngoto done;\r\n}\r\nretval = __videobuf_copy_to_user(q, q->read_buf, data, count, nonblocking);\r\nif (retval < 0)\r\ngoto done;\r\nq->read_off += retval;\r\nif (q->read_off == q->read_buf->size) {\r\nq->ops->buf_release(q, q->read_buf);\r\nkfree(q->read_buf);\r\nq->read_buf = NULL;\r\n}\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nreturn retval;\r\n}\r\nstatic int __videobuf_read_start(struct videobuf_queue *q)\r\n{\r\nenum v4l2_field field;\r\nunsigned long flags = 0;\r\nunsigned int count = 0, size = 0;\r\nint err, i;\r\nq->ops->buf_setup(q, &count, &size);\r\nif (count < 2)\r\ncount = 2;\r\nif (count > VIDEO_MAX_FRAME)\r\ncount = VIDEO_MAX_FRAME;\r\nsize = PAGE_ALIGN(size);\r\nerr = __videobuf_mmap_setup(q, count, size, V4L2_MEMORY_USERPTR);\r\nif (err < 0)\r\nreturn err;\r\ncount = err;\r\nfor (i = 0; i < count; i++) {\r\nfield = videobuf_next_field(q);\r\nerr = q->ops->buf_prepare(q, q->bufs[i], field);\r\nif (err)\r\nreturn err;\r\nlist_add_tail(&q->bufs[i]->stream, &q->stream);\r\n}\r\nspin_lock_irqsave(q->irqlock, flags);\r\nfor (i = 0; i < count; i++)\r\nq->ops->buf_queue(q, q->bufs[i]);\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nq->reading = 1;\r\nreturn 0;\r\n}\r\nstatic void __videobuf_read_stop(struct videobuf_queue *q)\r\n{\r\nint i;\r\nvideobuf_queue_cancel(q);\r\n__videobuf_free(q);\r\nINIT_LIST_HEAD(&q->stream);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nkfree(q->bufs[i]);\r\nq->bufs[i] = NULL;\r\n}\r\nq->read_buf = NULL;\r\n}\r\nint videobuf_read_start(struct videobuf_queue *q)\r\n{\r\nint rc;\r\nvideobuf_queue_lock(q);\r\nrc = __videobuf_read_start(q);\r\nvideobuf_queue_unlock(q);\r\nreturn rc;\r\n}\r\nvoid videobuf_read_stop(struct videobuf_queue *q)\r\n{\r\nvideobuf_queue_lock(q);\r\n__videobuf_read_stop(q);\r\nvideobuf_queue_unlock(q);\r\n}\r\nvoid videobuf_stop(struct videobuf_queue *q)\r\n{\r\nvideobuf_queue_lock(q);\r\nif (q->streaming)\r\n__videobuf_streamoff(q);\r\nif (q->reading)\r\n__videobuf_read_stop(q);\r\nvideobuf_queue_unlock(q);\r\n}\r\nssize_t videobuf_read_stream(struct videobuf_queue *q,\r\nchar __user *data, size_t count, loff_t *ppos,\r\nint vbihack, int nonblocking)\r\n{\r\nint rc, retval;\r\nunsigned long flags = 0;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\ndprintk(2, "%s\n", __func__);\r\nvideobuf_queue_lock(q);\r\nretval = -EBUSY;\r\nif (q->streaming)\r\ngoto done;\r\nif (!q->reading) {\r\nretval = __videobuf_read_start(q);\r\nif (retval < 0)\r\ngoto done;\r\n}\r\nretval = 0;\r\nwhile (count > 0) {\r\nif (NULL == q->read_buf) {\r\nq->read_buf = list_entry(q->stream.next,\r\nstruct videobuf_buffer,\r\nstream);\r\nlist_del(&q->read_buf->stream);\r\nq->read_off = 0;\r\n}\r\nrc = videobuf_waiton(q, q->read_buf, nonblocking, 1);\r\nif (rc < 0) {\r\nif (0 == retval)\r\nretval = rc;\r\nbreak;\r\n}\r\nif (q->read_buf->state == VIDEOBUF_DONE) {\r\nrc = __videobuf_copy_stream(q, q->read_buf, data + retval, count,\r\nretval, vbihack, nonblocking);\r\nif (rc < 0) {\r\nretval = rc;\r\nbreak;\r\n}\r\nretval += rc;\r\ncount -= rc;\r\nq->read_off += rc;\r\n} else {\r\nq->read_off = q->read_buf->size;\r\nif (0 == retval)\r\nretval = -EIO;\r\n}\r\nif (q->read_off == q->read_buf->size) {\r\nlist_add_tail(&q->read_buf->stream,\r\n&q->stream);\r\nspin_lock_irqsave(q->irqlock, flags);\r\nq->ops->buf_queue(q, q->read_buf);\r\nspin_unlock_irqrestore(q->irqlock, flags);\r\nq->read_buf = NULL;\r\n}\r\nif (retval < 0)\r\nbreak;\r\n}\r\ndone:\r\nvideobuf_queue_unlock(q);\r\nreturn retval;\r\n}\r\nunsigned int videobuf_poll_stream(struct file *file,\r\nstruct videobuf_queue *q,\r\npoll_table *wait)\r\n{\r\nunsigned long req_events = poll_requested_events(wait);\r\nstruct videobuf_buffer *buf = NULL;\r\nunsigned int rc = 0;\r\nvideobuf_queue_lock(q);\r\nif (q->streaming) {\r\nif (!list_empty(&q->stream))\r\nbuf = list_entry(q->stream.next,\r\nstruct videobuf_buffer, stream);\r\n} else if (req_events & (POLLIN | POLLRDNORM)) {\r\nif (!q->reading)\r\n__videobuf_read_start(q);\r\nif (!q->reading) {\r\nrc = POLLERR;\r\n} else if (NULL == q->read_buf) {\r\nq->read_buf = list_entry(q->stream.next,\r\nstruct videobuf_buffer,\r\nstream);\r\nlist_del(&q->read_buf->stream);\r\nq->read_off = 0;\r\n}\r\nbuf = q->read_buf;\r\n}\r\nif (!buf)\r\nrc = POLLERR;\r\nif (0 == rc) {\r\npoll_wait(file, &buf->done, wait);\r\nif (buf->state == VIDEOBUF_DONE ||\r\nbuf->state == VIDEOBUF_ERROR) {\r\nswitch (q->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nrc = POLLOUT | POLLWRNORM;\r\nbreak;\r\ndefault:\r\nrc = POLLIN | POLLRDNORM;\r\nbreak;\r\n}\r\n}\r\n}\r\nvideobuf_queue_unlock(q);\r\nreturn rc;\r\n}\r\nint videobuf_mmap_mapper(struct videobuf_queue *q, struct vm_area_struct *vma)\r\n{\r\nint rc = -EINVAL;\r\nint i;\r\nMAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);\r\nif (!(vma->vm_flags & VM_WRITE) || !(vma->vm_flags & VM_SHARED)) {\r\ndprintk(1, "mmap appl bug: PROT_WRITE and MAP_SHARED are required\n");\r\nreturn -EINVAL;\r\n}\r\nvideobuf_queue_lock(q);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nstruct videobuf_buffer *buf = q->bufs[i];\r\nif (buf && buf->memory == V4L2_MEMORY_MMAP &&\r\nbuf->boff == (vma->vm_pgoff << PAGE_SHIFT)) {\r\nrc = CALL(q, mmap_mapper, q, buf, vma);\r\nbreak;\r\n}\r\n}\r\nvideobuf_queue_unlock(q);\r\nreturn rc;\r\n}
