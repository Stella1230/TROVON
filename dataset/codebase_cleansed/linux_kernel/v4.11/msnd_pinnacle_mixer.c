static int snd_msndmix_info_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[3] = {\r\n"Analog", "MASS", "SPDIF",\r\n};\r\nstruct snd_msnd *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned items = test_bit(F_HAVEDIGITAL, &chip->flags) ? 3 : 2;\r\nreturn snd_ctl_enum_info(uinfo, 1, items, texts);\r\n}\r\nstatic int snd_msndmix_get_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_msnd *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = 0;\r\nif (chip->recsrc & MSND_MASK_SYNTH) {\r\nucontrol->value.enumerated.item[0] = 1;\r\n} else if ((chip->recsrc & MSND_MASK_DIGITAL) &&\r\ntest_bit(F_HAVEDIGITAL, &chip->flags)) {\r\nucontrol->value.enumerated.item[0] = 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_msndmix_set_mux(struct snd_msnd *chip, int val)\r\n{\r\nunsigned newrecsrc;\r\nint change;\r\nunsigned char msndbyte;\r\nswitch (val) {\r\ncase 0:\r\nnewrecsrc = MSND_MASK_IMIX;\r\nmsndbyte = HDEXAR_SET_ANA_IN;\r\nbreak;\r\ncase 1:\r\nnewrecsrc = MSND_MASK_SYNTH;\r\nmsndbyte = HDEXAR_SET_SYNTH_IN;\r\nbreak;\r\ncase 2:\r\nnewrecsrc = MSND_MASK_DIGITAL;\r\nmsndbyte = HDEXAR_SET_DAT_IN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nchange = newrecsrc != chip->recsrc;\r\nif (change) {\r\nchange = 0;\r\nif (!snd_msnd_send_word(chip, 0, 0, msndbyte))\r\nif (!snd_msnd_send_dsp_cmd(chip, HDEX_AUX_REQ)) {\r\nchip->recsrc = newrecsrc;\r\nchange = 1;\r\n}\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_msndmix_put_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_msnd *msnd = snd_kcontrol_chip(kcontrol);\r\nreturn snd_msndmix_set_mux(msnd, ucontrol->value.enumerated.item[0]);\r\n}\r\nstatic int snd_msndmix_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_msndmix_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_msnd *msnd = snd_kcontrol_chip(kcontrol);\r\nint addr = kcontrol->private_value;\r\nunsigned long flags;\r\nspin_lock_irqsave(&msnd->mixer_lock, flags);\r\nucontrol->value.integer.value[0] = msnd->left_levels[addr] * 100;\r\nucontrol->value.integer.value[0] /= 0xFFFF;\r\nucontrol->value.integer.value[1] = msnd->right_levels[addr] * 100;\r\nucontrol->value.integer.value[1] /= 0xFFFF;\r\nspin_unlock_irqrestore(&msnd->mixer_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_msndmix_set(struct snd_msnd *dev, int d, int left, int right)\r\n{\r\nint bLeft, bRight;\r\nint wLeft, wRight;\r\nint updatemaster = 0;\r\nif (d >= LEVEL_ENTRIES)\r\nreturn -EINVAL;\r\nbLeft = left * 0xff / 100;\r\nwLeft = left * 0xffff / 100;\r\nbRight = right * 0xff / 100;\r\nwRight = right * 0xffff / 100;\r\ndev->left_levels[d] = wLeft;\r\ndev->right_levels[d] = wRight;\r\nswitch (d) {\r\ncase MSND_MIXER_LINE:\r\nwriteb(bLeft, dev->SMA + SMA_bInPotPosLeft);\r\nwriteb(bRight, dev->SMA + SMA_bInPotPosRight);\r\nif (snd_msnd_send_word(dev, 0, 0, HDEXAR_IN_SET_POTS) == 0)\r\nsnd_msnd_send_dsp_cmd(dev, HDEX_AUX_REQ);\r\nbreak;\r\ncase MSND_MIXER_MIC:\r\nif (dev->type == msndClassic)\r\nreturn -EINVAL;\r\nwriteb(bLeft, dev->SMA + SMA_bMicPotPosLeft);\r\nwriteb(bRight, dev->SMA + SMA_bMicPotPosRight);\r\nif (snd_msnd_send_word(dev, 0, 0, HDEXAR_MIC_SET_POTS) == 0)\r\nsnd_msnd_send_dsp_cmd(dev, HDEX_AUX_REQ);\r\nbreak;\r\ncase MSND_MIXER_VOLUME:\r\nwritew(wLeft, dev->SMA + SMA_wCurrMastVolLeft);\r\nwritew(wRight, dev->SMA + SMA_wCurrMastVolRight);\r\ncase MSND_MIXER_AUX:\r\ncase MSND_MIXER_SYNTH:\r\ncase MSND_MIXER_PCM:\r\ncase MSND_MIXER_IMIX:\r\nupdatemaster = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (updatemaster) {\r\nupdate_volm(MSND_MIXER_PCM, wCurrPlayVol);\r\nupdate_volm(MSND_MIXER_IMIX, wCurrInVol);\r\nif (dev->type == msndPinnacle)\r\nupdate_volm(MSND_MIXER_SYNTH, wCurrMHdrVol);\r\nupdate_potm(MSND_MIXER_AUX, bAuxPotPos, HDEXAR_AUX_SET_POTS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_msndmix_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_msnd *msnd = snd_kcontrol_chip(kcontrol);\r\nint change, addr = kcontrol->private_value;\r\nint left, right;\r\nunsigned long flags;\r\nleft = ucontrol->value.integer.value[0] % 101;\r\nright = ucontrol->value.integer.value[1] % 101;\r\nspin_lock_irqsave(&msnd->mixer_lock, flags);\r\nchange = msnd->left_levels[addr] != left\r\n|| msnd->right_levels[addr] != right;\r\nsnd_msndmix_set(msnd, addr, left, right);\r\nspin_unlock_irqrestore(&msnd->mixer_lock, flags);\r\nreturn change;\r\n}\r\nint snd_msndmix_new(struct snd_card *card)\r\n{\r\nstruct snd_msnd *chip = card->private_data;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!chip))\r\nreturn -EINVAL;\r\nspin_lock_init(&chip->mixer_lock);\r\nstrcpy(card->mixername, "MSND Pinnacle Mixer");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_msnd_controls); idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(snd_msnd_controls + idx, chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_msndmix_setup(struct snd_msnd *dev)\r\n{\r\nupdate_pot(MSND_MIXER_LINE, bInPotPos, HDEXAR_IN_SET_POTS);\r\nupdate_potm(MSND_MIXER_AUX, bAuxPotPos, HDEXAR_AUX_SET_POTS);\r\nupdate_volm(MSND_MIXER_PCM, wCurrPlayVol);\r\nupdate_volm(MSND_MIXER_IMIX, wCurrInVol);\r\nif (dev->type == msndPinnacle) {\r\nupdate_pot(MSND_MIXER_MIC, bMicPotPos, HDEXAR_MIC_SET_POTS);\r\nupdate_volm(MSND_MIXER_SYNTH, wCurrMHdrVol);\r\n}\r\n}\r\nint snd_msndmix_force_recsrc(struct snd_msnd *dev, int recsrc)\r\n{\r\ndev->recsrc = -1;\r\nreturn snd_msndmix_set_mux(dev, recsrc);\r\n}
