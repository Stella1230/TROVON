static inline void vsp1_wpf_write(struct vsp1_rwpf *wpf,\r\nstruct vsp1_dl_list *dl, u32 reg, u32 data)\r\n{\r\nvsp1_dl_list_write(dl, reg + wpf->entity.index * VI6_WPF_OFFSET, data);\r\n}\r\nstatic int vsp1_wpf_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vsp1_rwpf *wpf =\r\ncontainer_of(ctrl->handler, struct vsp1_rwpf, ctrls);\r\nunsigned int i;\r\nu32 flip = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\ncase V4L2_CID_VFLIP:\r\nfor (i = 0; i < WPF_CTRL_MAX; ++i) {\r\nif (wpf->flip.ctrls[i])\r\nflip |= wpf->flip.ctrls[i]->val ? BIT(i) : 0;\r\n}\r\nspin_lock_irq(&wpf->flip.lock);\r\nwpf->flip.pending = flip;\r\nspin_unlock_irq(&wpf->flip.lock);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wpf_init_controls(struct vsp1_rwpf *wpf)\r\n{\r\nstruct vsp1_device *vsp1 = wpf->entity.vsp1;\r\nunsigned int num_flip_ctrls;\r\nspin_lock_init(&wpf->flip.lock);\r\nif (wpf->entity.index != 0) {\r\nnum_flip_ctrls = 0;\r\n} else if (vsp1->info->features & VSP1_HAS_WPF_HFLIP) {\r\nnum_flip_ctrls = 2;\r\n} else if (vsp1->info->features & VSP1_HAS_WPF_VFLIP) {\r\nnum_flip_ctrls = 1;\r\n} else {\r\nnum_flip_ctrls = 0;\r\n}\r\nvsp1_rwpf_init_ctrls(wpf, num_flip_ctrls);\r\nif (num_flip_ctrls >= 1) {\r\nwpf->flip.ctrls[WPF_CTRL_VFLIP] =\r\nv4l2_ctrl_new_std(&wpf->ctrls, &vsp1_wpf_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\n}\r\nif (num_flip_ctrls == 2) {\r\nwpf->flip.ctrls[WPF_CTRL_HFLIP] =\r\nv4l2_ctrl_new_std(&wpf->ctrls, &vsp1_wpf_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_cluster(2, wpf->flip.ctrls);\r\n}\r\nif (wpf->ctrls.error) {\r\ndev_err(vsp1->dev, "wpf%u: failed to initialize controls\n",\r\nwpf->entity.index);\r\nreturn wpf->ctrls.error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wpf_s_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct vsp1_rwpf *wpf = to_rwpf(subdev);\r\nstruct vsp1_device *vsp1 = wpf->entity.vsp1;\r\nif (enable)\r\nreturn 0;\r\nvsp1_write(vsp1, VI6_WPF_IRQ_ENB(wpf->entity.index), 0);\r\nvsp1_write(vsp1, wpf->entity.index * VI6_WPF_OFFSET +\r\nVI6_WPF_SRCRPF, 0);\r\nreturn 0;\r\n}\r\nstatic void vsp1_wpf_destroy(struct vsp1_entity *entity)\r\n{\r\nstruct vsp1_rwpf *wpf = entity_to_rwpf(entity);\r\nvsp1_dlm_destroy(wpf->dlm);\r\n}\r\nstatic void wpf_configure(struct vsp1_entity *entity,\r\nstruct vsp1_pipeline *pipe,\r\nstruct vsp1_dl_list *dl,\r\nenum vsp1_entity_params params)\r\n{\r\nstruct vsp1_rwpf *wpf = to_rwpf(&entity->subdev);\r\nstruct vsp1_device *vsp1 = wpf->entity.vsp1;\r\nconst struct v4l2_mbus_framefmt *source_format;\r\nconst struct v4l2_mbus_framefmt *sink_format;\r\nunsigned int i;\r\nu32 outfmt = 0;\r\nu32 srcrpf = 0;\r\nif (params == VSP1_ENTITY_PARAMS_RUNTIME) {\r\nconst unsigned int mask = BIT(WPF_CTRL_VFLIP)\r\n| BIT(WPF_CTRL_HFLIP);\r\nunsigned long flags;\r\nspin_lock_irqsave(&wpf->flip.lock, flags);\r\nwpf->flip.active = (wpf->flip.active & ~mask)\r\n| (wpf->flip.pending & mask);\r\nspin_unlock_irqrestore(&wpf->flip.lock, flags);\r\noutfmt = (wpf->alpha << VI6_WPF_OUTFMT_PDV_SHIFT) | wpf->outfmt;\r\nif (wpf->flip.active & BIT(WPF_CTRL_VFLIP))\r\noutfmt |= VI6_WPF_OUTFMT_FLP;\r\nif (wpf->flip.active & BIT(WPF_CTRL_HFLIP))\r\noutfmt |= VI6_WPF_OUTFMT_HFLP;\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_OUTFMT, outfmt);\r\nreturn;\r\n}\r\nsink_format = vsp1_entity_get_pad_format(&wpf->entity,\r\nwpf->entity.config,\r\nRWPF_PAD_SINK);\r\nsource_format = vsp1_entity_get_pad_format(&wpf->entity,\r\nwpf->entity.config,\r\nRWPF_PAD_SOURCE);\r\nif (params == VSP1_ENTITY_PARAMS_PARTITION) {\r\nconst struct v4l2_pix_format_mplane *format = &wpf->format;\r\nstruct vsp1_rwpf_memory mem = wpf->mem;\r\nunsigned int flip = wpf->flip.active;\r\nunsigned int width = source_format->width;\r\nunsigned int height = source_format->height;\r\nunsigned int offset;\r\nif (pipe->partitions > 1)\r\nwidth = pipe->partition.width;\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_HSZCLIP, VI6_WPF_SZCLIP_EN |\r\n(0 << VI6_WPF_SZCLIP_OFST_SHIFT) |\r\n(width << VI6_WPF_SZCLIP_SIZE_SHIFT));\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_VSZCLIP, VI6_WPF_SZCLIP_EN |\r\n(0 << VI6_WPF_SZCLIP_OFST_SHIFT) |\r\n(height << VI6_WPF_SZCLIP_SIZE_SHIFT));\r\nif (pipe->lif)\r\nreturn;\r\nif (pipe->partitions > 1) {\r\nconst struct vsp1_format_info *fmtinfo = wpf->fmtinfo;\r\nif (flip & BIT(WPF_CTRL_HFLIP))\r\noffset = format->width - pipe->partition.left\r\n- pipe->partition.width;\r\nelse\r\noffset = pipe->partition.left;\r\nmem.addr[0] += offset * fmtinfo->bpp[0] / 8;\r\nif (format->num_planes > 1) {\r\nmem.addr[1] += offset / fmtinfo->hsub\r\n* fmtinfo->bpp[1] / 8;\r\nmem.addr[2] += offset / fmtinfo->hsub\r\n* fmtinfo->bpp[2] / 8;\r\n}\r\n}\r\nif (flip & BIT(WPF_CTRL_VFLIP)) {\r\nmem.addr[0] += (format->height - 1)\r\n* format->plane_fmt[0].bytesperline;\r\nif (format->num_planes > 1) {\r\noffset = (format->height / wpf->fmtinfo->vsub - 1)\r\n* format->plane_fmt[1].bytesperline;\r\nmem.addr[1] += offset;\r\nmem.addr[2] += offset;\r\n}\r\n}\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_DSTM_ADDR_Y, mem.addr[0]);\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_DSTM_ADDR_C0, mem.addr[1]);\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_DSTM_ADDR_C1, mem.addr[2]);\r\nreturn;\r\n}\r\nif (!pipe->lif) {\r\nconst struct v4l2_pix_format_mplane *format = &wpf->format;\r\nconst struct vsp1_format_info *fmtinfo = wpf->fmtinfo;\r\noutfmt = fmtinfo->hwfmt << VI6_WPF_OUTFMT_WRFMT_SHIFT;\r\nif (fmtinfo->alpha)\r\noutfmt |= VI6_WPF_OUTFMT_PXA;\r\nif (fmtinfo->swap_yc)\r\noutfmt |= VI6_WPF_OUTFMT_SPYCS;\r\nif (fmtinfo->swap_uv)\r\noutfmt |= VI6_WPF_OUTFMT_SPUVS;\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_DSTM_STRIDE_Y,\r\nformat->plane_fmt[0].bytesperline);\r\nif (format->num_planes > 1)\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_DSTM_STRIDE_C,\r\nformat->plane_fmt[1].bytesperline);\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_DSWAP, fmtinfo->swap);\r\nif (vsp1->info->features & VSP1_HAS_WPF_HFLIP &&\r\nwpf->entity.index == 0)\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_ROT_CTRL,\r\nVI6_WPF_ROT_CTRL_LN16 |\r\n(256 << VI6_WPF_ROT_CTRL_LMEM_WD_SHIFT));\r\n}\r\nif (sink_format->code != source_format->code)\r\noutfmt |= VI6_WPF_OUTFMT_CSC;\r\nwpf->outfmt = outfmt;\r\nvsp1_dl_list_write(dl, VI6_DPR_WPF_FPORCH(wpf->entity.index),\r\nVI6_DPR_WPF_FPORCH_FP_WPFN);\r\nvsp1_dl_list_write(dl, VI6_WPF_WRBCK_CTRL, 0);\r\nfor (i = 0; i < vsp1->info->rpf_count; ++i) {\r\nstruct vsp1_rwpf *input = pipe->inputs[i];\r\nif (!input)\r\ncontinue;\r\nsrcrpf |= (!pipe->bru && pipe->num_inputs == 1)\r\n? VI6_WPF_SRCRPF_RPF_ACT_MST(input->entity.index)\r\n: VI6_WPF_SRCRPF_RPF_ACT_SUB(input->entity.index);\r\n}\r\nif (pipe->bru || pipe->num_inputs > 1)\r\nsrcrpf |= VI6_WPF_SRCRPF_VIRACT_MST;\r\nvsp1_wpf_write(wpf, dl, VI6_WPF_SRCRPF, srcrpf);\r\nvsp1_dl_list_write(dl, VI6_WPF_IRQ_STA(wpf->entity.index), 0);\r\nvsp1_dl_list_write(dl, VI6_WPF_IRQ_ENB(wpf->entity.index),\r\nVI6_WFP_IRQ_ENB_DFEE);\r\n}\r\nstruct vsp1_rwpf *vsp1_wpf_create(struct vsp1_device *vsp1, unsigned int index)\r\n{\r\nstruct vsp1_rwpf *wpf;\r\nchar name[6];\r\nint ret;\r\nwpf = devm_kzalloc(vsp1->dev, sizeof(*wpf), GFP_KERNEL);\r\nif (wpf == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (vsp1->info->gen == 2) {\r\nwpf->max_width = WPF_GEN2_MAX_WIDTH;\r\nwpf->max_height = WPF_GEN2_MAX_HEIGHT;\r\n} else {\r\nwpf->max_width = WPF_GEN3_MAX_WIDTH;\r\nwpf->max_height = WPF_GEN3_MAX_HEIGHT;\r\n}\r\nwpf->entity.ops = &wpf_entity_ops;\r\nwpf->entity.type = VSP1_ENTITY_WPF;\r\nwpf->entity.index = index;\r\nsprintf(name, "wpf.%u", index);\r\nret = vsp1_entity_init(vsp1, &wpf->entity, name, 2, &wpf_ops,\r\nMEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nwpf->dlm = vsp1_dlm_create(vsp1, index, 64);\r\nif (!wpf->dlm) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = wpf_init_controls(wpf);\r\nif (ret < 0) {\r\ndev_err(vsp1->dev, "wpf%u: failed to initialize controls\n",\r\nindex);\r\ngoto error;\r\n}\r\nv4l2_ctrl_handler_setup(&wpf->ctrls);\r\nreturn wpf;\r\nerror:\r\nvsp1_entity_destroy(&wpf->entity);\r\nreturn ERR_PTR(ret);\r\n}
