static u32 bcm_iproc_qspi_get_l2_int_status(struct bcm_qspi_soc_intc *soc_intc)\r\n{\r\nstruct bcm_iproc_intc *priv =\r\ncontainer_of(soc_intc, struct bcm_iproc_intc, soc_intc);\r\nvoid __iomem *mmio = priv->int_status_reg;\r\nint i;\r\nu32 val = 0, sts = 0;\r\nfor (i = 0; i < INTR_COUNT; i++) {\r\nif (bcm_qspi_readl(priv->big_endian, mmio + (i * 4)))\r\nval |= 1UL << i;\r\n}\r\nif (val & INTR_MSPI_DONE_MASK)\r\nsts |= MSPI_DONE;\r\nif (val & BSPI_LR_INTERRUPTS_ALL)\r\nsts |= BSPI_DONE;\r\nif (val & BSPI_LR_INTERRUPTS_ERROR)\r\nsts |= BSPI_ERR;\r\nreturn sts;\r\n}\r\nstatic void bcm_iproc_qspi_int_ack(struct bcm_qspi_soc_intc *soc_intc, int type)\r\n{\r\nstruct bcm_iproc_intc *priv =\r\ncontainer_of(soc_intc, struct bcm_iproc_intc, soc_intc);\r\nvoid __iomem *mmio = priv->int_status_reg;\r\nu32 mask = get_qspi_mask(type);\r\nint i;\r\nfor (i = 0; i < INTR_COUNT; i++) {\r\nif (mask & (1UL << i))\r\nbcm_qspi_writel(priv->big_endian, 1, mmio + (i * 4));\r\n}\r\n}\r\nstatic void bcm_iproc_qspi_int_set(struct bcm_qspi_soc_intc *soc_intc, int type,\r\nbool en)\r\n{\r\nstruct bcm_iproc_intc *priv =\r\ncontainer_of(soc_intc, struct bcm_iproc_intc, soc_intc);\r\nvoid __iomem *mmio = priv->int_reg;\r\nu32 mask = get_qspi_mask(type);\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->soclock, flags);\r\nval = bcm_qspi_readl(priv->big_endian, mmio);\r\nif (en)\r\nval = val | (mask << INTR_BASE_BIT_SHIFT);\r\nelse\r\nval = val & ~(mask << INTR_BASE_BIT_SHIFT);\r\nbcm_qspi_writel(priv->big_endian, val, mmio);\r\nspin_unlock_irqrestore(&priv->soclock, flags);\r\n}\r\nstatic int bcm_iproc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm_iproc_intc *priv;\r\nstruct bcm_qspi_soc_intc *soc_intc;\r\nstruct resource *res;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nsoc_intc = &priv->soc_intc;\r\npriv->pdev = pdev;\r\nspin_lock_init(&priv->soclock);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "intr_regs");\r\npriv->int_reg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->int_reg))\r\nreturn PTR_ERR(priv->int_reg);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"intr_status_reg");\r\npriv->int_status_reg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->int_status_reg))\r\nreturn PTR_ERR(priv->int_status_reg);\r\npriv->big_endian = of_device_is_big_endian(dev->of_node);\r\nbcm_iproc_qspi_int_ack(soc_intc, MSPI_BSPI_DONE);\r\nbcm_iproc_qspi_int_set(soc_intc, MSPI_BSPI_DONE, false);\r\nsoc_intc->bcm_qspi_int_ack = bcm_iproc_qspi_int_ack;\r\nsoc_intc->bcm_qspi_int_set = bcm_iproc_qspi_int_set;\r\nsoc_intc->bcm_qspi_get_int_status = bcm_iproc_qspi_get_l2_int_status;\r\nreturn bcm_qspi_probe(pdev, soc_intc);\r\n}\r\nstatic int bcm_iproc_remove(struct platform_device *pdev)\r\n{\r\nreturn bcm_qspi_remove(pdev);\r\n}
