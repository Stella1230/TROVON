int snd_skl_get_module_info(struct skl_sst *ctx,\r\nstruct skl_module_cfg *mconfig)\r\n{\r\nstruct uuid_module *module;\r\nuuid_le *uuid_mod;\r\nuuid_mod = (uuid_le *)mconfig->guid;\r\nif (list_empty(&ctx->uuid_list)) {\r\ndev_err(ctx->dev, "Module list is empty\n");\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(module, &ctx->uuid_list, list) {\r\nif (uuid_le_cmp(*uuid_mod, module->uuid) == 0) {\r\nmconfig->id.module_id = module->id;\r\nmconfig->is_loadable = module->is_loadable;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int skl_get_pvtid_map(struct uuid_module *module, int instance_id)\r\n{\r\nint pvt_id;\r\nfor (pvt_id = 0; pvt_id < module->max_instance; pvt_id++) {\r\nif (module->instance_id[pvt_id] == instance_id)\r\nreturn pvt_id;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint skl_get_pvt_instance_id_map(struct skl_sst *ctx,\r\nint module_id, int instance_id)\r\n{\r\nstruct uuid_module *module;\r\nlist_for_each_entry(module, &ctx->uuid_list, list) {\r\nif (module->id == module_id)\r\nreturn skl_get_pvtid_map(module, instance_id);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int skl_getid_32(struct uuid_module *module, u64 *val,\r\nint word1_mask, int word2_mask)\r\n{\r\nint index, max_inst, pvt_id;\r\nu32 mask_val;\r\nmax_inst = module->max_instance;\r\nmask_val = (u32)(*val >> word1_mask);\r\nif (mask_val != 0xffffffff) {\r\nindex = ffz(mask_val);\r\npvt_id = index + word1_mask + word2_mask;\r\nif (pvt_id <= (max_inst - 1)) {\r\n*val |= 1ULL << (index + word1_mask);\r\nreturn pvt_id;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int skl_pvtid_128(struct uuid_module *module)\r\n{\r\nint j, i, word1_mask, word2_mask = 0, pvt_id;\r\nfor (j = 0; j < MAX_INSTANCE_BUFF; j++) {\r\nword1_mask = 0;\r\nfor (i = 0; i < 2; i++) {\r\npvt_id = skl_getid_32(module, &module->pvt_id[j],\r\nword1_mask, word2_mask);\r\nif (pvt_id >= 0)\r\nreturn pvt_id;\r\nword1_mask += 32;\r\nif ((word1_mask + word2_mask) >= module->max_instance)\r\nreturn -EINVAL;\r\n}\r\nword2_mask += 64;\r\nif (word2_mask >= module->max_instance)\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint skl_get_pvt_id(struct skl_sst *ctx, struct skl_module_cfg *mconfig)\r\n{\r\nstruct uuid_module *module;\r\nuuid_le *uuid_mod;\r\nint pvt_id;\r\nuuid_mod = (uuid_le *)mconfig->guid;\r\nlist_for_each_entry(module, &ctx->uuid_list, list) {\r\nif (uuid_le_cmp(*uuid_mod, module->uuid) == 0) {\r\npvt_id = skl_pvtid_128(module);\r\nif (pvt_id >= 0) {\r\nmodule->instance_id[pvt_id] =\r\nmconfig->id.instance_id;\r\nreturn pvt_id;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint skl_put_pvt_id(struct skl_sst *ctx, struct skl_module_cfg *mconfig)\r\n{\r\nint i;\r\nuuid_le *uuid_mod;\r\nstruct uuid_module *module;\r\nuuid_mod = (uuid_le *)mconfig->guid;\r\nlist_for_each_entry(module, &ctx->uuid_list, list) {\r\nif (uuid_le_cmp(*uuid_mod, module->uuid) == 0) {\r\nif (mconfig->id.pvt_id != 0)\r\ni = (mconfig->id.pvt_id) / 64;\r\nelse\r\ni = 0;\r\nmodule->pvt_id[i] &= ~(1 << (mconfig->id.pvt_id));\r\nmconfig->id.pvt_id = -1;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint snd_skl_parse_uuids(struct sst_dsp *ctx, const struct firmware *fw,\r\nunsigned int offset, int index)\r\n{\r\nstruct adsp_fw_hdr *adsp_hdr;\r\nstruct adsp_module_entry *mod_entry;\r\nint i, num_entry, size;\r\nuuid_le *uuid_bin;\r\nconst char *buf;\r\nstruct skl_sst *skl = ctx->thread_context;\r\nstruct uuid_module *module;\r\nstruct firmware stripped_fw;\r\nunsigned int safe_file;\r\nstripped_fw.data = fw->data;\r\nstripped_fw.size = fw->size;\r\nskl_dsp_strip_extended_manifest(&stripped_fw);\r\nbuf = stripped_fw.data;\r\nsafe_file = sizeof(*adsp_hdr) + offset;\r\nif (stripped_fw.size <= safe_file) {\r\ndev_err(ctx->dev, "Small fw file size, No space for hdr\n");\r\nreturn -EINVAL;\r\n}\r\nadsp_hdr = (struct adsp_fw_hdr *)(buf + offset);\r\nsafe_file += adsp_hdr->len + sizeof(*mod_entry);\r\nif (stripped_fw.size <= safe_file) {\r\ndev_err(ctx->dev, "Small fw file size, No module entry\n");\r\nreturn -EINVAL;\r\n}\r\nmod_entry = (struct adsp_module_entry *)\r\n(buf + offset + adsp_hdr->len);\r\nnum_entry = adsp_hdr->num_modules;\r\nsafe_file += num_entry * sizeof(*mod_entry);\r\nif (stripped_fw.size <= safe_file) {\r\ndev_err(ctx->dev, "Small fw file size, No modules\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_entry; i++, mod_entry++) {\r\nmodule = kzalloc(sizeof(*module), GFP_KERNEL);\r\nif (!module)\r\nreturn -ENOMEM;\r\nuuid_bin = (uuid_le *)mod_entry->uuid.id;\r\nmemcpy(&module->uuid, uuid_bin, sizeof(module->uuid));\r\nmodule->id = (i | (index << 12));\r\nmodule->is_loadable = mod_entry->type.load_type;\r\nmodule->max_instance = mod_entry->instance_max_count;\r\nsize = sizeof(int) * mod_entry->instance_max_count;\r\nmodule->instance_id = devm_kzalloc(ctx->dev, size, GFP_KERNEL);\r\nif (!module->instance_id) {\r\nkfree(module);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail(&module->list, &skl->uuid_list);\r\ndev_dbg(ctx->dev,\r\n"Adding uuid :%pUL mod id: %d Loadable: %d\n",\r\n&module->uuid, module->id, module->is_loadable);\r\n}\r\nreturn 0;\r\n}\r\nvoid skl_freeup_uuid_list(struct skl_sst *ctx)\r\n{\r\nstruct uuid_module *uuid, *_uuid;\r\nlist_for_each_entry_safe(uuid, _uuid, &ctx->uuid_list, list) {\r\nlist_del(&uuid->list);\r\nkfree(uuid);\r\n}\r\n}\r\nint skl_dsp_strip_extended_manifest(struct firmware *fw)\r\n{\r\nstruct skl_ext_manifest_hdr *hdr;\r\nif (fw->size < sizeof(hdr)) {\r\npr_err("%s: Firmware file small, no hdr\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nhdr = (struct skl_ext_manifest_hdr *)fw->data;\r\nif (hdr->id == SKL_EXT_MANIFEST_HEADER_MAGIC) {\r\nfw->size -= hdr->len;\r\nfw->data += hdr->len;\r\n}\r\nreturn 0;\r\n}
