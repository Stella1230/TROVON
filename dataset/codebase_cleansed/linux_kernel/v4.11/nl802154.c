static struct wpan_dev *\r\n__cfg802154_wpan_dev_from_attrs(struct net *netns, struct nlattr **attrs)\r\n{\r\nstruct cfg802154_registered_device *rdev;\r\nstruct wpan_dev *result = NULL;\r\nbool have_ifidx = attrs[NL802154_ATTR_IFINDEX];\r\nbool have_wpan_dev_id = attrs[NL802154_ATTR_WPAN_DEV];\r\nu64 wpan_dev_id;\r\nint wpan_phy_idx = -1;\r\nint ifidx = -1;\r\nASSERT_RTNL();\r\nif (!have_ifidx && !have_wpan_dev_id)\r\nreturn ERR_PTR(-EINVAL);\r\nif (have_ifidx)\r\nifidx = nla_get_u32(attrs[NL802154_ATTR_IFINDEX]);\r\nif (have_wpan_dev_id) {\r\nwpan_dev_id = nla_get_u64(attrs[NL802154_ATTR_WPAN_DEV]);\r\nwpan_phy_idx = wpan_dev_id >> 32;\r\n}\r\nlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\r\nstruct wpan_dev *wpan_dev;\r\nif (wpan_phy_net(&rdev->wpan_phy) != netns)\r\ncontinue;\r\nif (have_wpan_dev_id && rdev->wpan_phy_idx != wpan_phy_idx)\r\ncontinue;\r\nlist_for_each_entry(wpan_dev, &rdev->wpan_dev_list, list) {\r\nif (have_ifidx && wpan_dev->netdev &&\r\nwpan_dev->netdev->ifindex == ifidx) {\r\nresult = wpan_dev;\r\nbreak;\r\n}\r\nif (have_wpan_dev_id &&\r\nwpan_dev->identifier == (u32)wpan_dev_id) {\r\nresult = wpan_dev;\r\nbreak;\r\n}\r\n}\r\nif (result)\r\nbreak;\r\n}\r\nif (result)\r\nreturn result;\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic struct cfg802154_registered_device *\r\n__cfg802154_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\r\n{\r\nstruct cfg802154_registered_device *rdev = NULL, *tmp;\r\nstruct net_device *netdev;\r\nASSERT_RTNL();\r\nif (!attrs[NL802154_ATTR_WPAN_PHY] &&\r\n!attrs[NL802154_ATTR_IFINDEX] &&\r\n!attrs[NL802154_ATTR_WPAN_DEV])\r\nreturn ERR_PTR(-EINVAL);\r\nif (attrs[NL802154_ATTR_WPAN_PHY])\r\nrdev = cfg802154_rdev_by_wpan_phy_idx(\r\nnla_get_u32(attrs[NL802154_ATTR_WPAN_PHY]));\r\nif (attrs[NL802154_ATTR_WPAN_DEV]) {\r\nu64 wpan_dev_id = nla_get_u64(attrs[NL802154_ATTR_WPAN_DEV]);\r\nstruct wpan_dev *wpan_dev;\r\nbool found = false;\r\ntmp = cfg802154_rdev_by_wpan_phy_idx(wpan_dev_id >> 32);\r\nif (tmp) {\r\nlist_for_each_entry(wpan_dev, &tmp->wpan_dev_list, list) {\r\nif (wpan_dev->identifier != (u32)wpan_dev_id)\r\ncontinue;\r\nfound = true;\r\nbreak;\r\n}\r\nif (!found)\r\ntmp = NULL;\r\nif (rdev && tmp != rdev)\r\nreturn ERR_PTR(-EINVAL);\r\nrdev = tmp;\r\n}\r\n}\r\nif (attrs[NL802154_ATTR_IFINDEX]) {\r\nint ifindex = nla_get_u32(attrs[NL802154_ATTR_IFINDEX]);\r\nnetdev = __dev_get_by_index(netns, ifindex);\r\nif (netdev) {\r\nif (netdev->ieee802154_ptr)\r\ntmp = wpan_phy_to_rdev(\r\nnetdev->ieee802154_ptr->wpan_phy);\r\nelse\r\ntmp = NULL;\r\nif (!tmp)\r\nreturn ERR_PTR(-EINVAL);\r\nif (rdev && tmp != rdev)\r\nreturn ERR_PTR(-EINVAL);\r\nrdev = tmp;\r\n}\r\n}\r\nif (!rdev)\r\nreturn ERR_PTR(-ENODEV);\r\nif (netns != wpan_phy_net(&rdev->wpan_phy))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn rdev;\r\n}\r\nstatic struct cfg802154_registered_device *\r\ncfg802154_get_dev_from_info(struct net *netns, struct genl_info *info)\r\n{\r\nreturn __cfg802154_rdev_from_attrs(netns, info->attrs);\r\n}\r\nstatic int\r\nnl802154_prepare_wpan_dev_dump(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct cfg802154_registered_device **rdev,\r\nstruct wpan_dev **wpan_dev)\r\n{\r\nint err;\r\nrtnl_lock();\r\nif (!cb->args[0]) {\r\nerr = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl802154_fam.hdrsize,\r\ngenl_family_attrbuf(&nl802154_fam),\r\nnl802154_fam.maxattr,\r\nnl802154_policy);\r\nif (err)\r\ngoto out_unlock;\r\n*wpan_dev = __cfg802154_wpan_dev_from_attrs(sock_net(skb->sk),\r\ngenl_family_attrbuf(&nl802154_fam));\r\nif (IS_ERR(*wpan_dev)) {\r\nerr = PTR_ERR(*wpan_dev);\r\ngoto out_unlock;\r\n}\r\n*rdev = wpan_phy_to_rdev((*wpan_dev)->wpan_phy);\r\ncb->args[0] = (*rdev)->wpan_phy_idx + 1;\r\ncb->args[1] = (*wpan_dev)->identifier;\r\n} else {\r\nstruct wpan_phy *wpan_phy = wpan_phy_idx_to_wpan_phy(cb->args[0] - 1);\r\nstruct wpan_dev *tmp;\r\nif (!wpan_phy) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\n*rdev = wpan_phy_to_rdev(wpan_phy);\r\n*wpan_dev = NULL;\r\nlist_for_each_entry(tmp, &(*rdev)->wpan_dev_list, list) {\r\nif (tmp->identifier == cb->args[1]) {\r\n*wpan_dev = tmp;\r\nbreak;\r\n}\r\n}\r\nif (!*wpan_dev) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\n}\r\nreturn 0;\r\nout_unlock:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void\r\nnl802154_finish_wpan_dev_dump(struct cfg802154_registered_device *rdev)\r\n{\r\nrtnl_unlock();\r\n}\r\nstatic inline void *nl802154hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\r\nint flags, u8 cmd)\r\n{\r\nreturn genlmsg_put(skb, portid, seq, &nl802154_fam, flags, cmd);\r\n}\r\nstatic int\r\nnl802154_put_flags(struct sk_buff *msg, int attr, u32 mask)\r\n{\r\nstruct nlattr *nl_flags = nla_nest_start(msg, attr);\r\nint i;\r\nif (!nl_flags)\r\nreturn -ENOBUFS;\r\ni = 0;\r\nwhile (mask) {\r\nif ((mask & 1) && nla_put_flag(msg, i))\r\nreturn -ENOBUFS;\r\nmask >>= 1;\r\ni++;\r\n}\r\nnla_nest_end(msg, nl_flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nnl802154_send_wpan_phy_channels(struct cfg802154_registered_device *rdev,\r\nstruct sk_buff *msg)\r\n{\r\nstruct nlattr *nl_page;\r\nunsigned long page;\r\nnl_page = nla_nest_start(msg, NL802154_ATTR_CHANNELS_SUPPORTED);\r\nif (!nl_page)\r\nreturn -ENOBUFS;\r\nfor (page = 0; page <= IEEE802154_MAX_PAGE; page++) {\r\nif (nla_put_u32(msg, NL802154_ATTR_SUPPORTED_CHANNEL,\r\nrdev->wpan_phy.supported.channels[page]))\r\nreturn -ENOBUFS;\r\n}\r\nnla_nest_end(msg, nl_page);\r\nreturn 0;\r\n}\r\nstatic int\r\nnl802154_put_capabilities(struct sk_buff *msg,\r\nstruct cfg802154_registered_device *rdev)\r\n{\r\nconst struct wpan_phy_supported *caps = &rdev->wpan_phy.supported;\r\nstruct nlattr *nl_caps, *nl_channels;\r\nint i;\r\nnl_caps = nla_nest_start(msg, NL802154_ATTR_WPAN_PHY_CAPS);\r\nif (!nl_caps)\r\nreturn -ENOBUFS;\r\nnl_channels = nla_nest_start(msg, NL802154_CAP_ATTR_CHANNELS);\r\nif (!nl_channels)\r\nreturn -ENOBUFS;\r\nfor (i = 0; i <= IEEE802154_MAX_PAGE; i++) {\r\nif (caps->channels[i]) {\r\nif (nl802154_put_flags(msg, i, caps->channels[i]))\r\nreturn -ENOBUFS;\r\n}\r\n}\r\nnla_nest_end(msg, nl_channels);\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL) {\r\nstruct nlattr *nl_ed_lvls;\r\nnl_ed_lvls = nla_nest_start(msg,\r\nNL802154_CAP_ATTR_CCA_ED_LEVELS);\r\nif (!nl_ed_lvls)\r\nreturn -ENOBUFS;\r\nfor (i = 0; i < caps->cca_ed_levels_size; i++) {\r\nif (nla_put_s32(msg, i, caps->cca_ed_levels[i]))\r\nreturn -ENOBUFS;\r\n}\r\nnla_nest_end(msg, nl_ed_lvls);\r\n}\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER) {\r\nstruct nlattr *nl_tx_pwrs;\r\nnl_tx_pwrs = nla_nest_start(msg, NL802154_CAP_ATTR_TX_POWERS);\r\nif (!nl_tx_pwrs)\r\nreturn -ENOBUFS;\r\nfor (i = 0; i < caps->tx_powers_size; i++) {\r\nif (nla_put_s32(msg, i, caps->tx_powers[i]))\r\nreturn -ENOBUFS;\r\n}\r\nnla_nest_end(msg, nl_tx_pwrs);\r\n}\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE) {\r\nif (nl802154_put_flags(msg, NL802154_CAP_ATTR_CCA_MODES,\r\ncaps->cca_modes) ||\r\nnl802154_put_flags(msg, NL802154_CAP_ATTR_CCA_OPTS,\r\ncaps->cca_opts))\r\nreturn -ENOBUFS;\r\n}\r\nif (nla_put_u8(msg, NL802154_CAP_ATTR_MIN_MINBE, caps->min_minbe) ||\r\nnla_put_u8(msg, NL802154_CAP_ATTR_MAX_MINBE, caps->max_minbe) ||\r\nnla_put_u8(msg, NL802154_CAP_ATTR_MIN_MAXBE, caps->min_maxbe) ||\r\nnla_put_u8(msg, NL802154_CAP_ATTR_MAX_MAXBE, caps->max_maxbe) ||\r\nnla_put_u8(msg, NL802154_CAP_ATTR_MIN_CSMA_BACKOFFS,\r\ncaps->min_csma_backoffs) ||\r\nnla_put_u8(msg, NL802154_CAP_ATTR_MAX_CSMA_BACKOFFS,\r\ncaps->max_csma_backoffs) ||\r\nnla_put_s8(msg, NL802154_CAP_ATTR_MIN_FRAME_RETRIES,\r\ncaps->min_frame_retries) ||\r\nnla_put_s8(msg, NL802154_CAP_ATTR_MAX_FRAME_RETRIES,\r\ncaps->max_frame_retries) ||\r\nnl802154_put_flags(msg, NL802154_CAP_ATTR_IFTYPES,\r\ncaps->iftypes) ||\r\nnla_put_u32(msg, NL802154_CAP_ATTR_LBT, caps->lbt))\r\nreturn -ENOBUFS;\r\nnla_nest_end(msg, nl_caps);\r\nreturn 0;\r\n}\r\nstatic int nl802154_send_wpan_phy(struct cfg802154_registered_device *rdev,\r\nenum nl802154_commands cmd,\r\nstruct sk_buff *msg, u32 portid, u32 seq,\r\nint flags)\r\n{\r\nstruct nlattr *nl_cmds;\r\nvoid *hdr;\r\nint i;\r\nhdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\r\nif (!hdr)\r\nreturn -ENOBUFS;\r\nif (nla_put_u32(msg, NL802154_ATTR_WPAN_PHY, rdev->wpan_phy_idx) ||\r\nnla_put_string(msg, NL802154_ATTR_WPAN_PHY_NAME,\r\nwpan_phy_name(&rdev->wpan_phy)) ||\r\nnla_put_u32(msg, NL802154_ATTR_GENERATION,\r\ncfg802154_rdev_list_generation))\r\ngoto nla_put_failure;\r\nif (cmd != NL802154_CMD_NEW_WPAN_PHY)\r\ngoto finish;\r\nif (nla_put_u8(msg, NL802154_ATTR_PAGE,\r\nrdev->wpan_phy.current_page) ||\r\nnla_put_u8(msg, NL802154_ATTR_CHANNEL,\r\nrdev->wpan_phy.current_channel))\r\ngoto nla_put_failure;\r\nif (nl802154_send_wpan_phy_channels(rdev, msg))\r\ngoto nla_put_failure;\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE) {\r\nif (nla_put_u32(msg, NL802154_ATTR_CCA_MODE,\r\nrdev->wpan_phy.cca.mode))\r\ngoto nla_put_failure;\r\nif (rdev->wpan_phy.cca.mode == NL802154_CCA_ENERGY_CARRIER) {\r\nif (nla_put_u32(msg, NL802154_ATTR_CCA_OPT,\r\nrdev->wpan_phy.cca.opt))\r\ngoto nla_put_failure;\r\n}\r\n}\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER) {\r\nif (nla_put_s32(msg, NL802154_ATTR_TX_POWER,\r\nrdev->wpan_phy.transmit_power))\r\ngoto nla_put_failure;\r\n}\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL) {\r\nif (nla_put_s32(msg, NL802154_ATTR_CCA_ED_LEVEL,\r\nrdev->wpan_phy.cca_ed_level))\r\ngoto nla_put_failure;\r\n}\r\nif (nl802154_put_capabilities(msg, rdev))\r\ngoto nla_put_failure;\r\nnl_cmds = nla_nest_start(msg, NL802154_ATTR_SUPPORTED_COMMANDS);\r\nif (!nl_cmds)\r\ngoto nla_put_failure;\r\ni = 0;\r\n#define CMD(op, n) \\r\ndo { \\r\nif (rdev->ops->op) { \\r\ni++; \\r\nif (nla_put_u32(msg, i, NL802154_CMD_ ## n)) \\r\ngoto nla_put_failure; \\r\n} \\r\n} while (0)\r\nCMD(add_virtual_intf, NEW_INTERFACE);\r\nCMD(del_virtual_intf, DEL_INTERFACE);\r\nCMD(set_channel, SET_CHANNEL);\r\nCMD(set_pan_id, SET_PAN_ID);\r\nCMD(set_short_addr, SET_SHORT_ADDR);\r\nCMD(set_backoff_exponent, SET_BACKOFF_EXPONENT);\r\nCMD(set_max_csma_backoffs, SET_MAX_CSMA_BACKOFFS);\r\nCMD(set_max_frame_retries, SET_MAX_FRAME_RETRIES);\r\nCMD(set_lbt_mode, SET_LBT_MODE);\r\nCMD(set_ackreq_default, SET_ACKREQ_DEFAULT);\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER)\r\nCMD(set_tx_power, SET_TX_POWER);\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL)\r\nCMD(set_cca_ed_level, SET_CCA_ED_LEVEL);\r\nif (rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE)\r\nCMD(set_cca_mode, SET_CCA_MODE);\r\n#undef CMD\r\nnla_nest_end(msg, nl_cmds);\r\nfinish:\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int nl802154_dump_wpan_phy_parse(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct nl802154_dump_wpan_phy_state *state)\r\n{\r\nstruct nlattr **tb = genl_family_attrbuf(&nl802154_fam);\r\nint ret = nlmsg_parse(cb->nlh, GENL_HDRLEN + nl802154_fam.hdrsize,\r\ntb, nl802154_fam.maxattr, nl802154_policy);\r\nif (ret)\r\nreturn 0;\r\nif (tb[NL802154_ATTR_WPAN_PHY])\r\nstate->filter_wpan_phy = nla_get_u32(tb[NL802154_ATTR_WPAN_PHY]);\r\nif (tb[NL802154_ATTR_WPAN_DEV])\r\nstate->filter_wpan_phy = nla_get_u64(tb[NL802154_ATTR_WPAN_DEV]) >> 32;\r\nif (tb[NL802154_ATTR_IFINDEX]) {\r\nstruct net_device *netdev;\r\nstruct cfg802154_registered_device *rdev;\r\nint ifidx = nla_get_u32(tb[NL802154_ATTR_IFINDEX]);\r\nnetdev = __dev_get_by_index(&init_net, ifidx);\r\nif (!netdev)\r\nreturn -ENODEV;\r\nif (netdev->ieee802154_ptr) {\r\nrdev = wpan_phy_to_rdev(\r\nnetdev->ieee802154_ptr->wpan_phy);\r\nstate->filter_wpan_phy = rdev->wpan_phy_idx;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnl802154_dump_wpan_phy(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint idx = 0, ret;\r\nstruct nl802154_dump_wpan_phy_state *state = (void *)cb->args[0];\r\nstruct cfg802154_registered_device *rdev;\r\nrtnl_lock();\r\nif (!state) {\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state) {\r\nrtnl_unlock();\r\nreturn -ENOMEM;\r\n}\r\nstate->filter_wpan_phy = -1;\r\nret = nl802154_dump_wpan_phy_parse(skb, cb, state);\r\nif (ret) {\r\nkfree(state);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\ncb->args[0] = (long)state;\r\n}\r\nlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\r\nif (!net_eq(wpan_phy_net(&rdev->wpan_phy), sock_net(skb->sk)))\r\ncontinue;\r\nif (++idx <= state->start)\r\ncontinue;\r\nif (state->filter_wpan_phy != -1 &&\r\nstate->filter_wpan_phy != rdev->wpan_phy_idx)\r\ncontinue;\r\nret = nl802154_send_wpan_phy(rdev,\r\nNL802154_CMD_NEW_WPAN_PHY,\r\nskb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI);\r\nif (ret < 0) {\r\nif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\r\n!skb->len && cb->min_dump_alloc < 4096) {\r\ncb->min_dump_alloc = 4096;\r\nrtnl_unlock();\r\nreturn 1;\r\n}\r\nidx--;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nrtnl_unlock();\r\nstate->start = idx;\r\nreturn skb->len;\r\n}\r\nstatic int nl802154_dump_wpan_phy_done(struct netlink_callback *cb)\r\n{\r\nkfree((void *)cb->args[0]);\r\nreturn 0;\r\n}\r\nstatic int nl802154_get_wpan_phy(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *msg;\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nif (nl802154_send_wpan_phy(rdev, NL802154_CMD_NEW_WPAN_PHY, msg,\r\ninfo->snd_portid, info->snd_seq, 0) < 0) {\r\nnlmsg_free(msg);\r\nreturn -ENOBUFS;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic inline u64 wpan_dev_id(struct wpan_dev *wpan_dev)\r\n{\r\nreturn (u64)wpan_dev->identifier |\r\n((u64)wpan_phy_to_rdev(wpan_dev->wpan_phy)->wpan_phy_idx << 32);\r\n}\r\nstatic int\r\nieee802154_llsec_send_key_id(struct sk_buff *msg,\r\nconst struct ieee802154_llsec_key_id *desc)\r\n{\r\nstruct nlattr *nl_dev_addr;\r\nif (nla_put_u32(msg, NL802154_KEY_ID_ATTR_MODE, desc->mode))\r\nreturn -ENOBUFS;\r\nswitch (desc->mode) {\r\ncase NL802154_KEY_ID_MODE_IMPLICIT:\r\nnl_dev_addr = nla_nest_start(msg, NL802154_KEY_ID_ATTR_IMPLICIT);\r\nif (!nl_dev_addr)\r\nreturn -ENOBUFS;\r\nif (nla_put_le16(msg, NL802154_DEV_ADDR_ATTR_PAN_ID,\r\ndesc->device_addr.pan_id) ||\r\nnla_put_u32(msg, NL802154_DEV_ADDR_ATTR_MODE,\r\ndesc->device_addr.mode))\r\nreturn -ENOBUFS;\r\nswitch (desc->device_addr.mode) {\r\ncase NL802154_DEV_ADDR_SHORT:\r\nif (nla_put_le16(msg, NL802154_DEV_ADDR_ATTR_SHORT,\r\ndesc->device_addr.short_addr))\r\nreturn -ENOBUFS;\r\nbreak;\r\ncase NL802154_DEV_ADDR_EXTENDED:\r\nif (nla_put_le64(msg, NL802154_DEV_ADDR_ATTR_EXTENDED,\r\ndesc->device_addr.extended_addr,\r\nNL802154_DEV_ADDR_ATTR_PAD))\r\nreturn -ENOBUFS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nnla_nest_end(msg, nl_dev_addr);\r\nbreak;\r\ncase NL802154_KEY_ID_MODE_INDEX:\r\nbreak;\r\ncase NL802154_KEY_ID_MODE_INDEX_SHORT:\r\nif (nla_put_le32(msg, NL802154_KEY_ID_ATTR_SOURCE_SHORT,\r\ndesc->short_source))\r\nreturn -ENOBUFS;\r\nbreak;\r\ncase NL802154_KEY_ID_MODE_INDEX_EXTENDED:\r\nif (nla_put_le64(msg, NL802154_KEY_ID_ATTR_SOURCE_EXTENDED,\r\ndesc->extended_source,\r\nNL802154_KEY_ID_ATTR_PAD))\r\nreturn -ENOBUFS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (desc->mode != NL802154_KEY_ID_MODE_IMPLICIT) {\r\nif (nla_put_u8(msg, NL802154_KEY_ID_ATTR_INDEX, desc->id))\r\nreturn -ENOBUFS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nl802154_get_llsec_params(struct sk_buff *msg,\r\nstruct cfg802154_registered_device *rdev,\r\nstruct wpan_dev *wpan_dev)\r\n{\r\nstruct nlattr *nl_key_id;\r\nstruct ieee802154_llsec_params params;\r\nint ret;\r\nret = rdev_get_llsec_params(rdev, wpan_dev, &params);\r\nif (ret < 0)\r\nreturn ret;\r\nif (nla_put_u8(msg, NL802154_ATTR_SEC_ENABLED, params.enabled) ||\r\nnla_put_u32(msg, NL802154_ATTR_SEC_OUT_LEVEL, params.out_level) ||\r\nnla_put_be32(msg, NL802154_ATTR_SEC_FRAME_COUNTER,\r\nparams.frame_counter))\r\nreturn -ENOBUFS;\r\nnl_key_id = nla_nest_start(msg, NL802154_ATTR_SEC_OUT_KEY_ID);\r\nif (!nl_key_id)\r\nreturn -ENOBUFS;\r\nret = ieee802154_llsec_send_key_id(msg, &params.out_key);\r\nif (ret < 0)\r\nreturn ret;\r\nnla_nest_end(msg, nl_key_id);\r\nreturn 0;\r\n}\r\nstatic int\r\nnl802154_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\r\nstruct cfg802154_registered_device *rdev,\r\nstruct wpan_dev *wpan_dev)\r\n{\r\nstruct net_device *dev = wpan_dev->netdev;\r\nvoid *hdr;\r\nhdr = nl802154hdr_put(msg, portid, seq, flags,\r\nNL802154_CMD_NEW_INTERFACE);\r\nif (!hdr)\r\nreturn -1;\r\nif (dev &&\r\n(nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex) ||\r\nnla_put_string(msg, NL802154_ATTR_IFNAME, dev->name)))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, NL802154_ATTR_WPAN_PHY, rdev->wpan_phy_idx) ||\r\nnla_put_u32(msg, NL802154_ATTR_IFTYPE, wpan_dev->iftype) ||\r\nnla_put_u64_64bit(msg, NL802154_ATTR_WPAN_DEV,\r\nwpan_dev_id(wpan_dev), NL802154_ATTR_PAD) ||\r\nnla_put_u32(msg, NL802154_ATTR_GENERATION,\r\nrdev->devlist_generation ^\r\n(cfg802154_rdev_list_generation << 2)))\r\ngoto nla_put_failure;\r\nif (nla_put_le64(msg, NL802154_ATTR_EXTENDED_ADDR,\r\nwpan_dev->extended_addr,\r\nNL802154_ATTR_PAD) ||\r\nnla_put_le16(msg, NL802154_ATTR_SHORT_ADDR,\r\nwpan_dev->short_addr) ||\r\nnla_put_le16(msg, NL802154_ATTR_PAN_ID, wpan_dev->pan_id))\r\ngoto nla_put_failure;\r\nif (nla_put_s8(msg, NL802154_ATTR_MAX_FRAME_RETRIES,\r\nwpan_dev->frame_retries) ||\r\nnla_put_u8(msg, NL802154_ATTR_MAX_BE, wpan_dev->max_be) ||\r\nnla_put_u8(msg, NL802154_ATTR_MAX_CSMA_BACKOFFS,\r\nwpan_dev->csma_retries) ||\r\nnla_put_u8(msg, NL802154_ATTR_MIN_BE, wpan_dev->min_be))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(msg, NL802154_ATTR_LBT_MODE, wpan_dev->lbt))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(msg, NL802154_ATTR_ACKREQ_DEFAULT, wpan_dev->ackreq))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_IEEE802154_NL802154_EXPERIMENTAL\r\nif (nl802154_get_llsec_params(msg, rdev, wpan_dev) < 0)\r\ngoto nla_put_failure;\r\n#endif\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nnl802154_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint wp_idx = 0;\r\nint if_idx = 0;\r\nint wp_start = cb->args[0];\r\nint if_start = cb->args[1];\r\nstruct cfg802154_registered_device *rdev;\r\nstruct wpan_dev *wpan_dev;\r\nrtnl_lock();\r\nlist_for_each_entry(rdev, &cfg802154_rdev_list, list) {\r\nif (!net_eq(wpan_phy_net(&rdev->wpan_phy), sock_net(skb->sk)))\r\ncontinue;\r\nif (wp_idx < wp_start) {\r\nwp_idx++;\r\ncontinue;\r\n}\r\nif_idx = 0;\r\nlist_for_each_entry(wpan_dev, &rdev->wpan_dev_list, list) {\r\nif (if_idx < if_start) {\r\nif_idx++;\r\ncontinue;\r\n}\r\nif (nl802154_send_iface(skb, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nrdev, wpan_dev) < 0) {\r\ngoto out;\r\n}\r\nif_idx++;\r\n}\r\nwp_idx++;\r\n}\r\nout:\r\nrtnl_unlock();\r\ncb->args[0] = wp_idx;\r\ncb->args[1] = if_idx;\r\nreturn skb->len;\r\n}\r\nstatic int nl802154_get_interface(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct sk_buff *msg;\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct wpan_dev *wdev = info->user_ptr[1];\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nif (nl802154_send_iface(msg, info->snd_portid, info->snd_seq, 0,\r\nrdev, wdev) < 0) {\r\nnlmsg_free(msg);\r\nreturn -ENOBUFS;\r\n}\r\nreturn genlmsg_reply(msg, info);\r\n}\r\nstatic int nl802154_new_interface(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nenum nl802154_iftype type = NL802154_IFTYPE_UNSPEC;\r\n__le64 extended_addr = cpu_to_le64(0x0000000000000000ULL);\r\nif (!info->attrs[NL802154_ATTR_IFNAME])\r\nreturn -EINVAL;\r\nif (info->attrs[NL802154_ATTR_IFTYPE]) {\r\ntype = nla_get_u32(info->attrs[NL802154_ATTR_IFTYPE]);\r\nif (type > NL802154_IFTYPE_MAX ||\r\n!(rdev->wpan_phy.supported.iftypes & BIT(type)))\r\nreturn -EINVAL;\r\n}\r\nif (info->attrs[NL802154_ATTR_EXTENDED_ADDR])\r\nextended_addr = nla_get_le64(info->attrs[NL802154_ATTR_EXTENDED_ADDR]);\r\nif (!rdev->ops->add_virtual_intf)\r\nreturn -EOPNOTSUPP;\r\nreturn rdev_add_virtual_intf(rdev,\r\nnla_data(info->attrs[NL802154_ATTR_IFNAME]),\r\nNET_NAME_USER, type, extended_addr);\r\n}\r\nstatic int nl802154_del_interface(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct wpan_dev *wpan_dev = info->user_ptr[1];\r\nif (!rdev->ops->del_virtual_intf)\r\nreturn -EOPNOTSUPP;\r\nif (!wpan_dev->netdev)\r\ninfo->user_ptr[1] = NULL;\r\nreturn rdev_del_virtual_intf(rdev, wpan_dev);\r\n}\r\nstatic int nl802154_set_channel(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nu8 channel, page;\r\nif (!info->attrs[NL802154_ATTR_PAGE] ||\r\n!info->attrs[NL802154_ATTR_CHANNEL])\r\nreturn -EINVAL;\r\npage = nla_get_u8(info->attrs[NL802154_ATTR_PAGE]);\r\nchannel = nla_get_u8(info->attrs[NL802154_ATTR_CHANNEL]);\r\nif (page > IEEE802154_MAX_PAGE || channel > IEEE802154_MAX_CHANNEL ||\r\n!(rdev->wpan_phy.supported.channels[page] & BIT(channel)))\r\nreturn -EINVAL;\r\nreturn rdev_set_channel(rdev, page, channel);\r\n}\r\nstatic int nl802154_set_cca_mode(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct wpan_phy_cca cca;\r\nif (!(rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_MODE))\r\nreturn -EOPNOTSUPP;\r\nif (!info->attrs[NL802154_ATTR_CCA_MODE])\r\nreturn -EINVAL;\r\ncca.mode = nla_get_u32(info->attrs[NL802154_ATTR_CCA_MODE]);\r\nif (cca.mode < NL802154_CCA_ENERGY ||\r\ncca.mode > NL802154_CCA_ATTR_MAX ||\r\n!(rdev->wpan_phy.supported.cca_modes & BIT(cca.mode)))\r\nreturn -EINVAL;\r\nif (cca.mode == NL802154_CCA_ENERGY_CARRIER) {\r\nif (!info->attrs[NL802154_ATTR_CCA_OPT])\r\nreturn -EINVAL;\r\ncca.opt = nla_get_u32(info->attrs[NL802154_ATTR_CCA_OPT]);\r\nif (cca.opt > NL802154_CCA_OPT_ATTR_MAX ||\r\n!(rdev->wpan_phy.supported.cca_opts & BIT(cca.opt)))\r\nreturn -EINVAL;\r\n}\r\nreturn rdev_set_cca_mode(rdev, &cca);\r\n}\r\nstatic int nl802154_set_cca_ed_level(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\ns32 ed_level;\r\nint i;\r\nif (!(rdev->wpan_phy.flags & WPAN_PHY_FLAG_CCA_ED_LEVEL))\r\nreturn -EOPNOTSUPP;\r\nif (!info->attrs[NL802154_ATTR_CCA_ED_LEVEL])\r\nreturn -EINVAL;\r\ned_level = nla_get_s32(info->attrs[NL802154_ATTR_CCA_ED_LEVEL]);\r\nfor (i = 0; i < rdev->wpan_phy.supported.cca_ed_levels_size; i++) {\r\nif (ed_level == rdev->wpan_phy.supported.cca_ed_levels[i])\r\nreturn rdev_set_cca_ed_level(rdev, ed_level);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int nl802154_set_tx_power(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\ns32 power;\r\nint i;\r\nif (!(rdev->wpan_phy.flags & WPAN_PHY_FLAG_TXPOWER))\r\nreturn -EOPNOTSUPP;\r\nif (!info->attrs[NL802154_ATTR_TX_POWER])\r\nreturn -EINVAL;\r\npower = nla_get_s32(info->attrs[NL802154_ATTR_TX_POWER]);\r\nfor (i = 0; i < rdev->wpan_phy.supported.tx_powers_size; i++) {\r\nif (power == rdev->wpan_phy.supported.tx_powers[i])\r\nreturn rdev_set_tx_power(rdev, power);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int nl802154_set_pan_id(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\n__le16 pan_id;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (wpan_dev->lowpan_dev) {\r\nif (netif_running(wpan_dev->lowpan_dev))\r\nreturn -EBUSY;\r\n}\r\nif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR ||\r\n!info->attrs[NL802154_ATTR_PAN_ID])\r\nreturn -EINVAL;\r\npan_id = nla_get_le16(info->attrs[NL802154_ATTR_PAN_ID]);\r\nif (pan_id == cpu_to_le16(IEEE802154_PAN_ID_BROADCAST))\r\nreturn -EINVAL;\r\nreturn rdev_set_pan_id(rdev, wpan_dev, pan_id);\r\n}\r\nstatic int nl802154_set_short_addr(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\n__le16 short_addr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (wpan_dev->lowpan_dev) {\r\nif (netif_running(wpan_dev->lowpan_dev))\r\nreturn -EBUSY;\r\n}\r\nif (wpan_dev->iftype == NL802154_IFTYPE_MONITOR ||\r\n!info->attrs[NL802154_ATTR_SHORT_ADDR])\r\nreturn -EINVAL;\r\nshort_addr = nla_get_le16(info->attrs[NL802154_ATTR_SHORT_ADDR]);\r\nif (short_addr == cpu_to_le16(IEEE802154_ADDR_SHORT_UNSPEC) ||\r\nshort_addr == cpu_to_le16(IEEE802154_ADDR_SHORT_BROADCAST))\r\nreturn -EINVAL;\r\nreturn rdev_set_short_addr(rdev, wpan_dev, short_addr);\r\n}\r\nstatic int\r\nnl802154_set_backoff_exponent(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nu8 min_be, max_be;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!info->attrs[NL802154_ATTR_MIN_BE] ||\r\n!info->attrs[NL802154_ATTR_MAX_BE])\r\nreturn -EINVAL;\r\nmin_be = nla_get_u8(info->attrs[NL802154_ATTR_MIN_BE]);\r\nmax_be = nla_get_u8(info->attrs[NL802154_ATTR_MAX_BE]);\r\nif (min_be < rdev->wpan_phy.supported.min_minbe ||\r\nmin_be > rdev->wpan_phy.supported.max_minbe ||\r\nmax_be < rdev->wpan_phy.supported.min_maxbe ||\r\nmax_be > rdev->wpan_phy.supported.max_maxbe ||\r\nmin_be > max_be)\r\nreturn -EINVAL;\r\nreturn rdev_set_backoff_exponent(rdev, wpan_dev, min_be, max_be);\r\n}\r\nstatic int\r\nnl802154_set_max_csma_backoffs(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nu8 max_csma_backoffs;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!info->attrs[NL802154_ATTR_MAX_CSMA_BACKOFFS])\r\nreturn -EINVAL;\r\nmax_csma_backoffs = nla_get_u8(\r\ninfo->attrs[NL802154_ATTR_MAX_CSMA_BACKOFFS]);\r\nif (max_csma_backoffs < rdev->wpan_phy.supported.min_csma_backoffs ||\r\nmax_csma_backoffs > rdev->wpan_phy.supported.max_csma_backoffs)\r\nreturn -EINVAL;\r\nreturn rdev_set_max_csma_backoffs(rdev, wpan_dev, max_csma_backoffs);\r\n}\r\nstatic int\r\nnl802154_set_max_frame_retries(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\ns8 max_frame_retries;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!info->attrs[NL802154_ATTR_MAX_FRAME_RETRIES])\r\nreturn -EINVAL;\r\nmax_frame_retries = nla_get_s8(\r\ninfo->attrs[NL802154_ATTR_MAX_FRAME_RETRIES]);\r\nif (max_frame_retries < rdev->wpan_phy.supported.min_frame_retries ||\r\nmax_frame_retries > rdev->wpan_phy.supported.max_frame_retries)\r\nreturn -EINVAL;\r\nreturn rdev_set_max_frame_retries(rdev, wpan_dev, max_frame_retries);\r\n}\r\nstatic int nl802154_set_lbt_mode(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nint mode;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!info->attrs[NL802154_ATTR_LBT_MODE])\r\nreturn -EINVAL;\r\nmode = nla_get_u8(info->attrs[NL802154_ATTR_LBT_MODE]);\r\nif (mode != 0 && mode != 1)\r\nreturn -EINVAL;\r\nif (!wpan_phy_supported_bool(mode, rdev->wpan_phy.supported.lbt))\r\nreturn -EINVAL;\r\nreturn rdev_set_lbt_mode(rdev, wpan_dev, mode);\r\n}\r\nstatic int\r\nnl802154_set_ackreq_default(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nint ackreq;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!info->attrs[NL802154_ATTR_ACKREQ_DEFAULT])\r\nreturn -EINVAL;\r\nackreq = nla_get_u8(info->attrs[NL802154_ATTR_ACKREQ_DEFAULT]);\r\nif (ackreq != 0 && ackreq != 1)\r\nreturn -EINVAL;\r\nreturn rdev_set_ackreq_default(rdev, wpan_dev, ackreq);\r\n}\r\nstatic int nl802154_wpan_phy_netns(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net *net;\r\nint err;\r\nif (info->attrs[NL802154_ATTR_PID]) {\r\nu32 pid = nla_get_u32(info->attrs[NL802154_ATTR_PID]);\r\nnet = get_net_ns_by_pid(pid);\r\n} else if (info->attrs[NL802154_ATTR_NETNS_FD]) {\r\nu32 fd = nla_get_u32(info->attrs[NL802154_ATTR_NETNS_FD]);\r\nnet = get_net_ns_by_fd(fd);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\nerr = 0;\r\nif (!net_eq(wpan_phy_net(&rdev->wpan_phy), net))\r\nerr = cfg802154_switch_netns(rdev, net);\r\nput_net(net);\r\nreturn err;\r\n}\r\nstatic int\r\nieee802154_llsec_parse_dev_addr(struct nlattr *nla,\r\nstruct ieee802154_addr *addr)\r\n{\r\nstruct nlattr *attrs[NL802154_DEV_ADDR_ATTR_MAX + 1];\r\nif (!nla || nla_parse_nested(attrs, NL802154_DEV_ADDR_ATTR_MAX, nla,\r\nnl802154_dev_addr_policy))\r\nreturn -EINVAL;\r\nif (!attrs[NL802154_DEV_ADDR_ATTR_PAN_ID] ||\r\n!attrs[NL802154_DEV_ADDR_ATTR_MODE] ||\r\n!(attrs[NL802154_DEV_ADDR_ATTR_SHORT] ||\r\nattrs[NL802154_DEV_ADDR_ATTR_EXTENDED]))\r\nreturn -EINVAL;\r\naddr->pan_id = nla_get_le16(attrs[NL802154_DEV_ADDR_ATTR_PAN_ID]);\r\naddr->mode = nla_get_u32(attrs[NL802154_DEV_ADDR_ATTR_MODE]);\r\nswitch (addr->mode) {\r\ncase NL802154_DEV_ADDR_SHORT:\r\naddr->short_addr = nla_get_le16(attrs[NL802154_DEV_ADDR_ATTR_SHORT]);\r\nbreak;\r\ncase NL802154_DEV_ADDR_EXTENDED:\r\naddr->extended_addr = nla_get_le64(attrs[NL802154_DEV_ADDR_ATTR_EXTENDED]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nieee802154_llsec_parse_key_id(struct nlattr *nla,\r\nstruct ieee802154_llsec_key_id *desc)\r\n{\r\nstruct nlattr *attrs[NL802154_KEY_ID_ATTR_MAX + 1];\r\nif (!nla || nla_parse_nested(attrs, NL802154_KEY_ID_ATTR_MAX, nla,\r\nnl802154_key_id_policy))\r\nreturn -EINVAL;\r\nif (!attrs[NL802154_KEY_ID_ATTR_MODE])\r\nreturn -EINVAL;\r\ndesc->mode = nla_get_u32(attrs[NL802154_KEY_ID_ATTR_MODE]);\r\nswitch (desc->mode) {\r\ncase NL802154_KEY_ID_MODE_IMPLICIT:\r\nif (!attrs[NL802154_KEY_ID_ATTR_IMPLICIT])\r\nreturn -EINVAL;\r\nif (ieee802154_llsec_parse_dev_addr(attrs[NL802154_KEY_ID_ATTR_IMPLICIT],\r\n&desc->device_addr) < 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase NL802154_KEY_ID_MODE_INDEX:\r\nbreak;\r\ncase NL802154_KEY_ID_MODE_INDEX_SHORT:\r\nif (!attrs[NL802154_KEY_ID_ATTR_SOURCE_SHORT])\r\nreturn -EINVAL;\r\ndesc->short_source = nla_get_le32(attrs[NL802154_KEY_ID_ATTR_SOURCE_SHORT]);\r\nbreak;\r\ncase NL802154_KEY_ID_MODE_INDEX_EXTENDED:\r\nif (!attrs[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED])\r\nreturn -EINVAL;\r\ndesc->extended_source = nla_get_le64(attrs[NL802154_KEY_ID_ATTR_SOURCE_EXTENDED]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (desc->mode != NL802154_KEY_ID_MODE_IMPLICIT) {\r\nif (!attrs[NL802154_KEY_ID_ATTR_INDEX])\r\nreturn -EINVAL;\r\ndesc->id = nla_get_u8(attrs[NL802154_KEY_ID_ATTR_INDEX]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nl802154_set_llsec_params(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct ieee802154_llsec_params params;\r\nu32 changed = 0;\r\nint ret;\r\nif (info->attrs[NL802154_ATTR_SEC_ENABLED]) {\r\nu8 enabled;\r\nenabled = nla_get_u8(info->attrs[NL802154_ATTR_SEC_ENABLED]);\r\nif (enabled != 0 && enabled != 1)\r\nreturn -EINVAL;\r\nparams.enabled = nla_get_u8(info->attrs[NL802154_ATTR_SEC_ENABLED]);\r\nchanged |= IEEE802154_LLSEC_PARAM_ENABLED;\r\n}\r\nif (info->attrs[NL802154_ATTR_SEC_OUT_KEY_ID]) {\r\nret = ieee802154_llsec_parse_key_id(info->attrs[NL802154_ATTR_SEC_OUT_KEY_ID],\r\n&params.out_key);\r\nif (ret < 0)\r\nreturn ret;\r\nchanged |= IEEE802154_LLSEC_PARAM_OUT_KEY;\r\n}\r\nif (info->attrs[NL802154_ATTR_SEC_OUT_LEVEL]) {\r\nparams.out_level = nla_get_u32(info->attrs[NL802154_ATTR_SEC_OUT_LEVEL]);\r\nif (params.out_level > NL802154_SECLEVEL_MAX)\r\nreturn -EINVAL;\r\nchanged |= IEEE802154_LLSEC_PARAM_OUT_LEVEL;\r\n}\r\nif (info->attrs[NL802154_ATTR_SEC_FRAME_COUNTER]) {\r\nparams.frame_counter = nla_get_be32(info->attrs[NL802154_ATTR_SEC_FRAME_COUNTER]);\r\nchanged |= IEEE802154_LLSEC_PARAM_FRAME_COUNTER;\r\n}\r\nreturn rdev_set_llsec_params(rdev, wpan_dev, &params, changed);\r\n}\r\nstatic int nl802154_send_key(struct sk_buff *msg, u32 cmd, u32 portid,\r\nu32 seq, int flags,\r\nstruct cfg802154_registered_device *rdev,\r\nstruct net_device *dev,\r\nconst struct ieee802154_llsec_key_entry *key)\r\n{\r\nvoid *hdr;\r\nu32 commands[NL802154_CMD_FRAME_NR_IDS / 32];\r\nstruct nlattr *nl_key, *nl_key_id;\r\nhdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\r\nif (!hdr)\r\nreturn -1;\r\nif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\r\ngoto nla_put_failure;\r\nnl_key = nla_nest_start(msg, NL802154_ATTR_SEC_KEY);\r\nif (!nl_key)\r\ngoto nla_put_failure;\r\nnl_key_id = nla_nest_start(msg, NL802154_KEY_ATTR_ID);\r\nif (!nl_key_id)\r\ngoto nla_put_failure;\r\nif (ieee802154_llsec_send_key_id(msg, &key->id) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(msg, nl_key_id);\r\nif (nla_put_u8(msg, NL802154_KEY_ATTR_USAGE_FRAMES,\r\nkey->key->frame_types))\r\ngoto nla_put_failure;\r\nif (key->key->frame_types & BIT(NL802154_FRAME_CMD)) {\r\nmemset(commands, 0, sizeof(commands));\r\ncommands[7] = key->key->cmd_frame_ids;\r\nif (nla_put(msg, NL802154_KEY_ATTR_USAGE_CMDS,\r\nsizeof(commands), commands))\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put(msg, NL802154_KEY_ATTR_BYTES, NL802154_KEY_SIZE,\r\nkey->key->key))\r\ngoto nla_put_failure;\r\nnla_nest_end(msg, nl_key);\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nnl802154_dump_llsec_key(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct cfg802154_registered_device *rdev = NULL;\r\nstruct ieee802154_llsec_key_entry *key;\r\nstruct ieee802154_llsec_table *table;\r\nstruct wpan_dev *wpan_dev;\r\nint err;\r\nerr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\r\nif (err)\r\nreturn err;\r\nif (!wpan_dev->netdev) {\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nrdev_lock_llsec_table(rdev, wpan_dev);\r\nrdev_get_llsec_table(rdev, wpan_dev, &table);\r\nif (cb->args[2])\r\ngoto out;\r\nlist_for_each_entry(key, &table->keys, list) {\r\nif (nl802154_send_key(skb, NL802154_CMD_NEW_SEC_KEY,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nrdev, wpan_dev->netdev, key) < 0) {\r\nerr = -EIO;\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\ngoto out_err;\r\n}\r\n}\r\ncb->args[2] = 1;\r\nout:\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\nerr = skb->len;\r\nout_err:\r\nnl802154_finish_wpan_dev_dump(rdev);\r\nreturn err;\r\n}\r\nstatic int nl802154_add_llsec_key(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct nlattr *attrs[NL802154_KEY_ATTR_MAX + 1];\r\nstruct ieee802154_llsec_key key = { };\r\nstruct ieee802154_llsec_key_id id = { };\r\nu32 commands[NL802154_CMD_FRAME_NR_IDS / 32] = { };\r\nif (nla_parse_nested(attrs, NL802154_KEY_ATTR_MAX,\r\ninfo->attrs[NL802154_ATTR_SEC_KEY],\r\nnl802154_key_policy))\r\nreturn -EINVAL;\r\nif (!attrs[NL802154_KEY_ATTR_USAGE_FRAMES] ||\r\n!attrs[NL802154_KEY_ATTR_BYTES])\r\nreturn -EINVAL;\r\nif (ieee802154_llsec_parse_key_id(attrs[NL802154_KEY_ATTR_ID], &id) < 0)\r\nreturn -ENOBUFS;\r\nkey.frame_types = nla_get_u8(attrs[NL802154_KEY_ATTR_USAGE_FRAMES]);\r\nif (key.frame_types > BIT(NL802154_FRAME_MAX) ||\r\n((key.frame_types & BIT(NL802154_FRAME_CMD)) &&\r\n!attrs[NL802154_KEY_ATTR_USAGE_CMDS]))\r\nreturn -EINVAL;\r\nif (attrs[NL802154_KEY_ATTR_USAGE_CMDS]) {\r\nnla_memcpy(commands, attrs[NL802154_KEY_ATTR_USAGE_CMDS],\r\nNL802154_CMD_FRAME_NR_IDS / 8);\r\nif (commands[0] || commands[1] || commands[2] || commands[3] ||\r\ncommands[4] || commands[5] || commands[6] ||\r\ncommands[7] > BIT(NL802154_CMD_FRAME_MAX))\r\nreturn -EINVAL;\r\nkey.cmd_frame_ids = commands[7];\r\n} else {\r\nkey.cmd_frame_ids = 0;\r\n}\r\nnla_memcpy(key.key, attrs[NL802154_KEY_ATTR_BYTES], NL802154_KEY_SIZE);\r\nif (ieee802154_llsec_parse_key_id(attrs[NL802154_KEY_ATTR_ID], &id) < 0)\r\nreturn -ENOBUFS;\r\nreturn rdev_add_llsec_key(rdev, wpan_dev, &id, &key);\r\n}\r\nstatic int nl802154_del_llsec_key(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct nlattr *attrs[NL802154_KEY_ATTR_MAX + 1];\r\nstruct ieee802154_llsec_key_id id;\r\nif (nla_parse_nested(attrs, NL802154_KEY_ATTR_MAX,\r\ninfo->attrs[NL802154_ATTR_SEC_KEY],\r\nnl802154_key_policy))\r\nreturn -EINVAL;\r\nif (ieee802154_llsec_parse_key_id(attrs[NL802154_KEY_ATTR_ID], &id) < 0)\r\nreturn -ENOBUFS;\r\nreturn rdev_del_llsec_key(rdev, wpan_dev, &id);\r\n}\r\nstatic int nl802154_send_device(struct sk_buff *msg, u32 cmd, u32 portid,\r\nu32 seq, int flags,\r\nstruct cfg802154_registered_device *rdev,\r\nstruct net_device *dev,\r\nconst struct ieee802154_llsec_device *dev_desc)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nl_device;\r\nhdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\r\nif (!hdr)\r\nreturn -1;\r\nif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\r\ngoto nla_put_failure;\r\nnl_device = nla_nest_start(msg, NL802154_ATTR_SEC_DEVICE);\r\nif (!nl_device)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, NL802154_DEV_ATTR_FRAME_COUNTER,\r\ndev_desc->frame_counter) ||\r\nnla_put_le16(msg, NL802154_DEV_ATTR_PAN_ID, dev_desc->pan_id) ||\r\nnla_put_le16(msg, NL802154_DEV_ATTR_SHORT_ADDR,\r\ndev_desc->short_addr) ||\r\nnla_put_le64(msg, NL802154_DEV_ATTR_EXTENDED_ADDR,\r\ndev_desc->hwaddr, NL802154_DEV_ATTR_PAD) ||\r\nnla_put_u8(msg, NL802154_DEV_ATTR_SECLEVEL_EXEMPT,\r\ndev_desc->seclevel_exempt) ||\r\nnla_put_u32(msg, NL802154_DEV_ATTR_KEY_MODE, dev_desc->key_mode))\r\ngoto nla_put_failure;\r\nnla_nest_end(msg, nl_device);\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nnl802154_dump_llsec_dev(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct cfg802154_registered_device *rdev = NULL;\r\nstruct ieee802154_llsec_device *dev;\r\nstruct ieee802154_llsec_table *table;\r\nstruct wpan_dev *wpan_dev;\r\nint err;\r\nerr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\r\nif (err)\r\nreturn err;\r\nif (!wpan_dev->netdev) {\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nrdev_lock_llsec_table(rdev, wpan_dev);\r\nrdev_get_llsec_table(rdev, wpan_dev, &table);\r\nif (cb->args[2])\r\ngoto out;\r\nlist_for_each_entry(dev, &table->devices, list) {\r\nif (nl802154_send_device(skb, NL802154_CMD_NEW_SEC_LEVEL,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nrdev, wpan_dev->netdev, dev) < 0) {\r\nerr = -EIO;\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\ngoto out_err;\r\n}\r\n}\r\ncb->args[2] = 1;\r\nout:\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\nerr = skb->len;\r\nout_err:\r\nnl802154_finish_wpan_dev_dump(rdev);\r\nreturn err;\r\n}\r\nstatic int\r\nieee802154_llsec_parse_device(struct nlattr *nla,\r\nstruct ieee802154_llsec_device *dev)\r\n{\r\nstruct nlattr *attrs[NL802154_DEV_ATTR_MAX + 1];\r\nif (!nla || nla_parse_nested(attrs, NL802154_DEV_ATTR_MAX, nla,\r\nnl802154_dev_policy))\r\nreturn -EINVAL;\r\nmemset(dev, 0, sizeof(*dev));\r\nif (!attrs[NL802154_DEV_ATTR_FRAME_COUNTER] ||\r\n!attrs[NL802154_DEV_ATTR_PAN_ID] ||\r\n!attrs[NL802154_DEV_ATTR_SHORT_ADDR] ||\r\n!attrs[NL802154_DEV_ATTR_EXTENDED_ADDR] ||\r\n!attrs[NL802154_DEV_ATTR_SECLEVEL_EXEMPT] ||\r\n!attrs[NL802154_DEV_ATTR_KEY_MODE])\r\nreturn -EINVAL;\r\ndev->frame_counter = nla_get_u32(attrs[NL802154_DEV_ATTR_FRAME_COUNTER]);\r\ndev->pan_id = nla_get_le16(attrs[NL802154_DEV_ATTR_PAN_ID]);\r\ndev->short_addr = nla_get_le16(attrs[NL802154_DEV_ATTR_SHORT_ADDR]);\r\ndev->hwaddr = nla_get_le64(attrs[NL802154_DEV_ATTR_EXTENDED_ADDR]);\r\ndev->seclevel_exempt = nla_get_u8(attrs[NL802154_DEV_ATTR_SECLEVEL_EXEMPT]);\r\ndev->key_mode = nla_get_u32(attrs[NL802154_DEV_ATTR_KEY_MODE]);\r\nif (dev->key_mode > NL802154_DEVKEY_MAX ||\r\n(dev->seclevel_exempt != 0 && dev->seclevel_exempt != 1))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int nl802154_add_llsec_dev(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct ieee802154_llsec_device dev_desc;\r\nif (ieee802154_llsec_parse_device(info->attrs[NL802154_ATTR_SEC_DEVICE],\r\n&dev_desc) < 0)\r\nreturn -EINVAL;\r\nreturn rdev_add_device(rdev, wpan_dev, &dev_desc);\r\n}\r\nstatic int nl802154_del_llsec_dev(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct nlattr *attrs[NL802154_DEV_ATTR_MAX + 1];\r\n__le64 extended_addr;\r\nif (nla_parse_nested(attrs, NL802154_DEV_ATTR_MAX,\r\ninfo->attrs[NL802154_ATTR_SEC_DEVICE],\r\nnl802154_dev_policy))\r\nreturn -EINVAL;\r\nif (!attrs[NL802154_DEV_ATTR_EXTENDED_ADDR])\r\nreturn -EINVAL;\r\nextended_addr = nla_get_le64(attrs[NL802154_DEV_ATTR_EXTENDED_ADDR]);\r\nreturn rdev_del_device(rdev, wpan_dev, extended_addr);\r\n}\r\nstatic int nl802154_send_devkey(struct sk_buff *msg, u32 cmd, u32 portid,\r\nu32 seq, int flags,\r\nstruct cfg802154_registered_device *rdev,\r\nstruct net_device *dev, __le64 extended_addr,\r\nconst struct ieee802154_llsec_device_key *devkey)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nl_devkey, *nl_key_id;\r\nhdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\r\nif (!hdr)\r\nreturn -1;\r\nif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\r\ngoto nla_put_failure;\r\nnl_devkey = nla_nest_start(msg, NL802154_ATTR_SEC_DEVKEY);\r\nif (!nl_devkey)\r\ngoto nla_put_failure;\r\nif (nla_put_le64(msg, NL802154_DEVKEY_ATTR_EXTENDED_ADDR,\r\nextended_addr, NL802154_DEVKEY_ATTR_PAD) ||\r\nnla_put_u32(msg, NL802154_DEVKEY_ATTR_FRAME_COUNTER,\r\ndevkey->frame_counter))\r\ngoto nla_put_failure;\r\nnl_key_id = nla_nest_start(msg, NL802154_DEVKEY_ATTR_ID);\r\nif (!nl_key_id)\r\ngoto nla_put_failure;\r\nif (ieee802154_llsec_send_key_id(msg, &devkey->key_id) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(msg, nl_key_id);\r\nnla_nest_end(msg, nl_devkey);\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nnl802154_dump_llsec_devkey(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct cfg802154_registered_device *rdev = NULL;\r\nstruct ieee802154_llsec_device_key *kpos;\r\nstruct ieee802154_llsec_device *dpos;\r\nstruct ieee802154_llsec_table *table;\r\nstruct wpan_dev *wpan_dev;\r\nint err;\r\nerr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\r\nif (err)\r\nreturn err;\r\nif (!wpan_dev->netdev) {\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nrdev_lock_llsec_table(rdev, wpan_dev);\r\nrdev_get_llsec_table(rdev, wpan_dev, &table);\r\nif (cb->args[2])\r\ngoto out;\r\nlist_for_each_entry(dpos, &table->devices, list) {\r\nlist_for_each_entry(kpos, &dpos->keys, list) {\r\nif (nl802154_send_devkey(skb,\r\nNL802154_CMD_NEW_SEC_LEVEL,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNLM_F_MULTI, rdev,\r\nwpan_dev->netdev,\r\ndpos->hwaddr,\r\nkpos) < 0) {\r\nerr = -EIO;\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\ngoto out_err;\r\n}\r\n}\r\n}\r\ncb->args[2] = 1;\r\nout:\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\nerr = skb->len;\r\nout_err:\r\nnl802154_finish_wpan_dev_dump(rdev);\r\nreturn err;\r\n}\r\nstatic int nl802154_add_llsec_devkey(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct nlattr *attrs[NL802154_DEVKEY_ATTR_MAX + 1];\r\nstruct ieee802154_llsec_device_key key;\r\n__le64 extended_addr;\r\nif (!info->attrs[NL802154_ATTR_SEC_DEVKEY] ||\r\nnla_parse_nested(attrs, NL802154_DEVKEY_ATTR_MAX,\r\ninfo->attrs[NL802154_ATTR_SEC_DEVKEY],\r\nnl802154_devkey_policy) < 0)\r\nreturn -EINVAL;\r\nif (!attrs[NL802154_DEVKEY_ATTR_FRAME_COUNTER] ||\r\n!attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR])\r\nreturn -EINVAL;\r\nif (ieee802154_llsec_parse_key_id(attrs[NL802154_DEVKEY_ATTR_ID],\r\n&key.key_id) < 0)\r\nreturn -ENOBUFS;\r\nkey.frame_counter = nla_get_u32(attrs[NL802154_DEVKEY_ATTR_FRAME_COUNTER]);\r\nextended_addr = nla_get_le64(attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR]);\r\nreturn rdev_add_devkey(rdev, wpan_dev, extended_addr, &key);\r\n}\r\nstatic int nl802154_del_llsec_devkey(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct nlattr *attrs[NL802154_DEVKEY_ATTR_MAX + 1];\r\nstruct ieee802154_llsec_device_key key;\r\n__le64 extended_addr;\r\nif (nla_parse_nested(attrs, NL802154_DEVKEY_ATTR_MAX,\r\ninfo->attrs[NL802154_ATTR_SEC_DEVKEY],\r\nnl802154_devkey_policy))\r\nreturn -EINVAL;\r\nif (!attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR])\r\nreturn -EINVAL;\r\nif (ieee802154_llsec_parse_key_id(attrs[NL802154_DEVKEY_ATTR_ID],\r\n&key.key_id) < 0)\r\nreturn -ENOBUFS;\r\nextended_addr = nla_get_le64(attrs[NL802154_DEVKEY_ATTR_EXTENDED_ADDR]);\r\nreturn rdev_del_devkey(rdev, wpan_dev, extended_addr, &key);\r\n}\r\nstatic int nl802154_send_seclevel(struct sk_buff *msg, u32 cmd, u32 portid,\r\nu32 seq, int flags,\r\nstruct cfg802154_registered_device *rdev,\r\nstruct net_device *dev,\r\nconst struct ieee802154_llsec_seclevel *sl)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *nl_seclevel;\r\nhdr = nl802154hdr_put(msg, portid, seq, flags, cmd);\r\nif (!hdr)\r\nreturn -1;\r\nif (nla_put_u32(msg, NL802154_ATTR_IFINDEX, dev->ifindex))\r\ngoto nla_put_failure;\r\nnl_seclevel = nla_nest_start(msg, NL802154_ATTR_SEC_LEVEL);\r\nif (!nl_seclevel)\r\ngoto nla_put_failure;\r\nif (nla_put_u32(msg, NL802154_SECLEVEL_ATTR_FRAME, sl->frame_type) ||\r\nnla_put_u32(msg, NL802154_SECLEVEL_ATTR_LEVELS, sl->sec_levels) ||\r\nnla_put_u8(msg, NL802154_SECLEVEL_ATTR_DEV_OVERRIDE,\r\nsl->device_override))\r\ngoto nla_put_failure;\r\nif (sl->frame_type == NL802154_FRAME_CMD) {\r\nif (nla_put_u32(msg, NL802154_SECLEVEL_ATTR_CMD_FRAME,\r\nsl->cmd_frame_id))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(msg, nl_seclevel);\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nnl802154_dump_llsec_seclevel(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct cfg802154_registered_device *rdev = NULL;\r\nstruct ieee802154_llsec_seclevel *sl;\r\nstruct ieee802154_llsec_table *table;\r\nstruct wpan_dev *wpan_dev;\r\nint err;\r\nerr = nl802154_prepare_wpan_dev_dump(skb, cb, &rdev, &wpan_dev);\r\nif (err)\r\nreturn err;\r\nif (!wpan_dev->netdev) {\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nrdev_lock_llsec_table(rdev, wpan_dev);\r\nrdev_get_llsec_table(rdev, wpan_dev, &table);\r\nif (cb->args[2])\r\ngoto out;\r\nlist_for_each_entry(sl, &table->security_levels, list) {\r\nif (nl802154_send_seclevel(skb, NL802154_CMD_NEW_SEC_LEVEL,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\nrdev, wpan_dev->netdev, sl) < 0) {\r\nerr = -EIO;\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\ngoto out_err;\r\n}\r\n}\r\ncb->args[2] = 1;\r\nout:\r\nrdev_unlock_llsec_table(rdev, wpan_dev);\r\nerr = skb->len;\r\nout_err:\r\nnl802154_finish_wpan_dev_dump(rdev);\r\nreturn err;\r\n}\r\nstatic int\r\nllsec_parse_seclevel(struct nlattr *nla, struct ieee802154_llsec_seclevel *sl)\r\n{\r\nstruct nlattr *attrs[NL802154_SECLEVEL_ATTR_MAX + 1];\r\nif (!nla || nla_parse_nested(attrs, NL802154_SECLEVEL_ATTR_MAX, nla,\r\nnl802154_seclevel_policy))\r\nreturn -EINVAL;\r\nmemset(sl, 0, sizeof(*sl));\r\nif (!attrs[NL802154_SECLEVEL_ATTR_LEVELS] ||\r\n!attrs[NL802154_SECLEVEL_ATTR_FRAME] ||\r\n!attrs[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE])\r\nreturn -EINVAL;\r\nsl->sec_levels = nla_get_u8(attrs[NL802154_SECLEVEL_ATTR_LEVELS]);\r\nsl->frame_type = nla_get_u32(attrs[NL802154_SECLEVEL_ATTR_FRAME]);\r\nsl->device_override = nla_get_u8(attrs[NL802154_SECLEVEL_ATTR_DEV_OVERRIDE]);\r\nif (sl->frame_type > NL802154_FRAME_MAX ||\r\n(sl->device_override != 0 && sl->device_override != 1))\r\nreturn -EINVAL;\r\nif (sl->frame_type == NL802154_FRAME_CMD) {\r\nif (!attrs[NL802154_SECLEVEL_ATTR_CMD_FRAME])\r\nreturn -EINVAL;\r\nsl->cmd_frame_id = nla_get_u32(attrs[NL802154_SECLEVEL_ATTR_CMD_FRAME]);\r\nif (sl->cmd_frame_id > NL802154_CMD_FRAME_MAX)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nl802154_add_llsec_seclevel(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct ieee802154_llsec_seclevel sl;\r\nif (llsec_parse_seclevel(info->attrs[NL802154_ATTR_SEC_LEVEL],\r\n&sl) < 0)\r\nreturn -EINVAL;\r\nreturn rdev_add_seclevel(rdev, wpan_dev, &sl);\r\n}\r\nstatic int nl802154_del_llsec_seclevel(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev = info->user_ptr[0];\r\nstruct net_device *dev = info->user_ptr[1];\r\nstruct wpan_dev *wpan_dev = dev->ieee802154_ptr;\r\nstruct ieee802154_llsec_seclevel sl;\r\nif (!info->attrs[NL802154_ATTR_SEC_LEVEL] ||\r\nllsec_parse_seclevel(info->attrs[NL802154_ATTR_SEC_LEVEL],\r\n&sl) < 0)\r\nreturn -EINVAL;\r\nreturn rdev_del_seclevel(rdev, wpan_dev, &sl);\r\n}\r\nstatic int nl802154_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nstruct cfg802154_registered_device *rdev;\r\nstruct wpan_dev *wpan_dev;\r\nstruct net_device *dev;\r\nbool rtnl = ops->internal_flags & NL802154_FLAG_NEED_RTNL;\r\nif (rtnl)\r\nrtnl_lock();\r\nif (ops->internal_flags & NL802154_FLAG_NEED_WPAN_PHY) {\r\nrdev = cfg802154_get_dev_from_info(genl_info_net(info), info);\r\nif (IS_ERR(rdev)) {\r\nif (rtnl)\r\nrtnl_unlock();\r\nreturn PTR_ERR(rdev);\r\n}\r\ninfo->user_ptr[0] = rdev;\r\n} else if (ops->internal_flags & NL802154_FLAG_NEED_NETDEV ||\r\nops->internal_flags & NL802154_FLAG_NEED_WPAN_DEV) {\r\nASSERT_RTNL();\r\nwpan_dev = __cfg802154_wpan_dev_from_attrs(genl_info_net(info),\r\ninfo->attrs);\r\nif (IS_ERR(wpan_dev)) {\r\nif (rtnl)\r\nrtnl_unlock();\r\nreturn PTR_ERR(wpan_dev);\r\n}\r\ndev = wpan_dev->netdev;\r\nrdev = wpan_phy_to_rdev(wpan_dev->wpan_phy);\r\nif (ops->internal_flags & NL802154_FLAG_NEED_NETDEV) {\r\nif (!dev) {\r\nif (rtnl)\r\nrtnl_unlock();\r\nreturn -EINVAL;\r\n}\r\ninfo->user_ptr[1] = dev;\r\n} else {\r\ninfo->user_ptr[1] = wpan_dev;\r\n}\r\nif (dev) {\r\nif (ops->internal_flags & NL802154_FLAG_CHECK_NETDEV_UP &&\r\n!netif_running(dev)) {\r\nif (rtnl)\r\nrtnl_unlock();\r\nreturn -ENETDOWN;\r\n}\r\ndev_hold(dev);\r\n}\r\ninfo->user_ptr[0] = rdev;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nl802154_post_doit(const struct genl_ops *ops, struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nif (info->user_ptr[1]) {\r\nif (ops->internal_flags & NL802154_FLAG_NEED_WPAN_DEV) {\r\nstruct wpan_dev *wpan_dev = info->user_ptr[1];\r\nif (wpan_dev->netdev)\r\ndev_put(wpan_dev->netdev);\r\n} else {\r\ndev_put(info->user_ptr[1]);\r\n}\r\n}\r\nif (ops->internal_flags & NL802154_FLAG_NEED_RTNL)\r\nrtnl_unlock();\r\n}\r\nint __init nl802154_init(void)\r\n{\r\nreturn genl_register_family(&nl802154_fam);\r\n}\r\nvoid nl802154_exit(void)\r\n{\r\ngenl_unregister_family(&nl802154_fam);\r\n}
