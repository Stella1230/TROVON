static void brcms_c_scb_ampdu_update_max_txlen(struct ampdu_info *ampdu, u8 dur)\r\n{\r\nu32 rate, mcs;\r\nfor (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {\r\nrate = mcs_2_rate(mcs, false, false);\r\nampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;\r\nrate = mcs_2_rate(mcs, true, false);\r\nampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;\r\nrate = mcs_2_rate(mcs, false, true);\r\nampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;\r\nrate = mcs_2_rate(mcs, true, true);\r\nampdu->max_txlen[mcs][1][1] = (rate * dur) >> 3;\r\n}\r\n}\r\nstatic bool brcms_c_ampdu_cap(struct ampdu_info *ampdu)\r\n{\r\nif (BRCMS_PHY_11N_CAP(ampdu->wlc->band))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int brcms_c_ampdu_set(struct ampdu_info *ampdu, bool on)\r\n{\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nstruct bcma_device *core = wlc->hw->d11core;\r\nwlc->pub->_ampdu = false;\r\nif (on) {\r\nif (!(wlc->pub->_n_enab & SUPPORT_11N)) {\r\nbrcms_err(core, "wl%d: driver not nmode enabled\n",\r\nwlc->pub->unit);\r\nreturn -ENOTSUPP;\r\n}\r\nif (!brcms_c_ampdu_cap(ampdu)) {\r\nbrcms_err(core, "wl%d: device not ampdu capable\n",\r\nwlc->pub->unit);\r\nreturn -ENOTSUPP;\r\n}\r\nwlc->pub->_ampdu = on;\r\n}\r\nreturn 0;\r\n}\r\nstatic void brcms_c_ffpld_init(struct ampdu_info *ampdu)\r\n{\r\nint i, j;\r\nstruct brcms_fifo_info *fifo;\r\nfor (j = 0; j < NUM_FFPLD_FIFO; j++) {\r\nfifo = (ampdu->fifo_tb + j);\r\nfifo->ampdu_pld_size = 0;\r\nfor (i = 0; i <= FFPLD_MAX_MCS; i++)\r\nfifo->mcs2ampdu_table[i] = 255;\r\nfifo->dmaxferrate = 0;\r\nfifo->accum_txampdu = 0;\r\nfifo->prev_txfunfl = 0;\r\nfifo->accum_txfunfl = 0;\r\n}\r\n}\r\nstruct ampdu_info *brcms_c_ampdu_attach(struct brcms_c_info *wlc)\r\n{\r\nstruct ampdu_info *ampdu;\r\nint i;\r\nampdu = kzalloc(sizeof(struct ampdu_info), GFP_ATOMIC);\r\nif (!ampdu)\r\nreturn NULL;\r\nampdu->wlc = wlc;\r\nfor (i = 0; i < AMPDU_MAX_SCB_TID; i++)\r\nampdu->ini_enable[i] = true;\r\nampdu->ini_enable[PRIO_8021D_VO] = false;\r\nampdu->ini_enable[PRIO_8021D_NC] = false;\r\nampdu->ini_enable[PRIO_8021D_NONE] = false;\r\nampdu->ini_enable[PRIO_8021D_BK] = false;\r\nampdu->ba_tx_wsize = AMPDU_TX_BA_DEF_WSIZE;\r\nampdu->ba_rx_wsize = AMPDU_RX_BA_DEF_WSIZE;\r\nampdu->mpdu_density = AMPDU_DEF_MPDU_DENSITY;\r\nampdu->max_pdu = AUTO;\r\nampdu->dur = AMPDU_MAX_DUR;\r\nampdu->ffpld_rsvd = AMPDU_DEF_FFPLD_RSVD;\r\nif (BRCMS_ISNPHY(wlc->band) && NREV_LT(wlc->band->phyrev, 2))\r\nampdu->rx_factor = IEEE80211_HT_MAX_AMPDU_32K;\r\nelse\r\nampdu->rx_factor = IEEE80211_HT_MAX_AMPDU_64K;\r\nampdu->retry_limit = AMPDU_DEF_RETRY_LIMIT;\r\nampdu->rr_retry_limit = AMPDU_DEF_RR_RETRY_LIMIT;\r\nfor (i = 0; i < AMPDU_MAX_SCB_TID; i++) {\r\nampdu->retry_limit_tid[i] = ampdu->retry_limit;\r\nampdu->rr_retry_limit_tid[i] = ampdu->rr_retry_limit;\r\n}\r\nbrcms_c_scb_ampdu_update_max_txlen(ampdu, ampdu->dur);\r\nampdu->mfbr = false;\r\nbrcms_c_ampdu_set(ampdu, wlc->pub->_ampdu);\r\nampdu->tx_max_funl = FFPLD_TX_MAX_UNFL;\r\nbrcms_c_ffpld_init(ampdu);\r\nreturn ampdu;\r\n}\r\nvoid brcms_c_ampdu_detach(struct ampdu_info *ampdu)\r\n{\r\nkfree(ampdu);\r\n}\r\nstatic void brcms_c_scb_ampdu_update_config(struct ampdu_info *ampdu,\r\nstruct scb *scb)\r\n{\r\nstruct scb_ampdu *scb_ampdu = &scb->scb_ampdu;\r\nint i;\r\nscb_ampdu->max_pdu = AMPDU_NUM_MPDU;\r\nfor (i = 0; i < NUM_FFPLD_FIFO; i++) {\r\nif (ampdu->fifo_tb[i].ampdu_pld_size > FFPLD_PLD_INCR)\r\nscb_ampdu->max_pdu = AMPDU_NUM_MPDU_LEGACY;\r\n}\r\nif (ampdu->max_pdu != AUTO)\r\nscb_ampdu->max_pdu = (u8) ampdu->max_pdu;\r\nscb_ampdu->release = min_t(u8, scb_ampdu->max_pdu,\r\nAMPDU_SCB_MAX_RELEASE);\r\nif (scb_ampdu->max_rx_ampdu_bytes)\r\nscb_ampdu->release = min_t(u8, scb_ampdu->release,\r\nscb_ampdu->max_rx_ampdu_bytes / 1600);\r\nscb_ampdu->release = min(scb_ampdu->release,\r\nampdu->fifo_tb[TX_AC_BE_FIFO].\r\nmcs2ampdu_table[FFPLD_MAX_MCS]);\r\n}\r\nstatic void brcms_c_scb_ampdu_update_config_all(struct ampdu_info *ampdu)\r\n{\r\nbrcms_c_scb_ampdu_update_config(ampdu, &ampdu->wlc->pri_scb);\r\n}\r\nstatic void brcms_c_ffpld_calc_mcs2ampdu_table(struct ampdu_info *ampdu, int f)\r\n{\r\nint i;\r\nu32 phy_rate, dma_rate, tmp;\r\nu8 max_mpdu;\r\nstruct brcms_fifo_info *fifo = (ampdu->fifo_tb + f);\r\nmax_mpdu = min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS],\r\nAMPDU_NUM_MPDU_LEGACY);\r\nphy_rate = mcs_2_rate(FFPLD_MAX_MCS, true, false);\r\ndma_rate =\r\n(((phy_rate / 100) *\r\n(max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))\r\n/ (max_mpdu * FFPLD_MPDU_SIZE)) * 100;\r\nfifo->dmaxferrate = dma_rate;\r\ndma_rate = dma_rate >> 7;\r\nfor (i = 0; i < FFPLD_MAX_MCS; i++) {\r\nphy_rate = mcs_2_rate(i, true, false) >> 7;\r\nif (phy_rate > dma_rate) {\r\ntmp = ((fifo->ampdu_pld_size * phy_rate) /\r\n((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;\r\ntmp = min_t(u32, tmp, 255);\r\nfifo->mcs2ampdu_table[i] = (u8) tmp;\r\n}\r\n}\r\n}\r\nstatic int brcms_c_ffpld_check_txfunfl(struct brcms_c_info *wlc, int fid)\r\n{\r\nstruct ampdu_info *ampdu = wlc->ampdu;\r\nu32 phy_rate = mcs_2_rate(FFPLD_MAX_MCS, true, false);\r\nu32 txunfl_ratio;\r\nu8 max_mpdu;\r\nu32 current_ampdu_cnt = 0;\r\nu16 max_pld_size;\r\nu32 new_txunfl;\r\nstruct brcms_fifo_info *fifo = (ampdu->fifo_tb + fid);\r\nuint xmtfifo_sz;\r\nu16 cur_txunfl;\r\ncur_txunfl = brcms_b_read_shm(wlc->hw,\r\nM_UCODE_MACSTAT +\r\noffsetof(struct macstat, txfunfl[fid]));\r\nnew_txunfl = (u16) (cur_txunfl - fifo->prev_txfunfl);\r\nif (new_txunfl == 0) {\r\nbrcms_dbg_ht(wlc->hw->d11core,\r\n"TX status FRAG set but no tx underflows\n");\r\nreturn -1;\r\n}\r\nfifo->prev_txfunfl = cur_txunfl;\r\nif (!ampdu->tx_max_funl)\r\nreturn 1;\r\nif (brcms_b_xmtfifo_sz_get(wlc->hw, fid, &xmtfifo_sz))\r\nreturn -1;\r\nif ((TXFIFO_SIZE_UNIT * (u32) xmtfifo_sz) <= ampdu->ffpld_rsvd)\r\nreturn 1;\r\nmax_pld_size = TXFIFO_SIZE_UNIT * xmtfifo_sz - ampdu->ffpld_rsvd;\r\nfifo->accum_txfunfl += new_txunfl;\r\nif (fifo->accum_txfunfl < 10)\r\nreturn 0;\r\nbrcms_dbg_ht(wlc->hw->d11core, "ampdu_count %d tx_underflows %d\n",\r\ncurrent_ampdu_cnt, fifo->accum_txfunfl);\r\ntxunfl_ratio = current_ampdu_cnt / fifo->accum_txfunfl;\r\nif (txunfl_ratio > ampdu->tx_max_funl) {\r\nif (current_ampdu_cnt >= FFPLD_MAX_AMPDU_CNT)\r\nfifo->accum_txfunfl = 0;\r\nreturn 0;\r\n}\r\nmax_mpdu = min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS],\r\nAMPDU_NUM_MPDU_LEGACY);\r\nif (fifo->ampdu_pld_size >= max_mpdu * FFPLD_MPDU_SIZE) {\r\nfifo->accum_txfunfl = 0;\r\nreturn 0;\r\n}\r\nif (fifo->ampdu_pld_size < max_pld_size) {\r\nfifo->ampdu_pld_size += FFPLD_PLD_INCR;\r\nif (fifo->ampdu_pld_size > max_pld_size)\r\nfifo->ampdu_pld_size = max_pld_size;\r\nbrcms_c_scb_ampdu_update_config_all(ampdu);\r\nfifo->dmaxferrate =\r\n(((phy_rate / 100) *\r\n(max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))\r\n/ (max_mpdu * FFPLD_MPDU_SIZE)) * 100;\r\nbrcms_dbg_ht(wlc->hw->d11core,\r\n"DMA estimated transfer rate %d; "\r\n"pre-load size %d\n",\r\nfifo->dmaxferrate, fifo->ampdu_pld_size);\r\n} else {\r\nif (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] > 1) {\r\nif (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] == 255)\r\nfifo->mcs2ampdu_table[FFPLD_MAX_MCS] =\r\nAMPDU_NUM_MPDU_LEGACY - 1;\r\nelse\r\nfifo->mcs2ampdu_table[FFPLD_MAX_MCS] -= 1;\r\nbrcms_c_ffpld_calc_mcs2ampdu_table(ampdu, fid);\r\nbrcms_c_scb_ampdu_update_config_all(ampdu);\r\n}\r\n}\r\nfifo->accum_txfunfl = 0;\r\nreturn 0;\r\n}\r\nvoid\r\nbrcms_c_ampdu_tx_operational(struct brcms_c_info *wlc, u8 tid,\r\nu8 ba_wsize,\r\nuint max_rx_ampdu_bytes)\r\n{\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct scb_ampdu_tid_ini *ini;\r\nstruct ampdu_info *ampdu = wlc->ampdu;\r\nstruct scb *scb = &wlc->pri_scb;\r\nscb_ampdu = &scb->scb_ampdu;\r\nif (!ampdu->ini_enable[tid]) {\r\nbrcms_err(wlc->hw->d11core, "%s: Rejecting tid %d\n",\r\n__func__, tid);\r\nreturn;\r\n}\r\nini = &scb_ampdu->ini[tid];\r\nini->tid = tid;\r\nini->scb = scb_ampdu->scb;\r\nini->ba_wsize = ba_wsize;\r\nscb_ampdu->max_rx_ampdu_bytes = max_rx_ampdu_bytes;\r\n}\r\nvoid brcms_c_ampdu_reset_session(struct brcms_ampdu_session *session,\r\nstruct brcms_c_info *wlc)\r\n{\r\nsession->wlc = wlc;\r\nskb_queue_head_init(&session->skb_list);\r\nsession->max_ampdu_len = 0;\r\nsession->max_ampdu_frames = 0;\r\nsession->ampdu_len = 0;\r\nsession->dma_len = 0;\r\n}\r\nint brcms_c_ampdu_add_frame(struct brcms_ampdu_session *session,\r\nstruct sk_buff *p)\r\n{\r\nstruct brcms_c_info *wlc = session->wlc;\r\nstruct ampdu_info *ampdu = wlc->ampdu;\r\nstruct scb *scb = &wlc->pri_scb;\r\nstruct scb_ampdu *scb_ampdu = &scb->scb_ampdu;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);\r\nstruct ieee80211_tx_rate *txrate = tx_info->status.rates;\r\nstruct d11txh *txh = (struct d11txh *)p->data;\r\nunsigned ampdu_frames;\r\nu8 ndelim, tid;\r\nu8 *plcp;\r\nuint len;\r\nu16 mcl;\r\nbool fbr_iscck;\r\nbool rr;\r\nndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];\r\nplcp = (u8 *)(txh + 1);\r\nfbr_iscck = !(le16_to_cpu(txh->XtraFrameTypes) & 0x03);\r\nlen = fbr_iscck ? BRCMS_GET_CCK_PLCP_LEN(txh->FragPLCPFallback) :\r\nBRCMS_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);\r\nlen = roundup(len, 4) + (ndelim + 1) * AMPDU_DELIMITER_LEN;\r\nampdu_frames = skb_queue_len(&session->skb_list);\r\nif (ampdu_frames != 0) {\r\nstruct sk_buff *first;\r\nif (ampdu_frames + 1 > session->max_ampdu_frames ||\r\nsession->ampdu_len + len > session->max_ampdu_len)\r\nreturn -ENOSPC;\r\nfirst = skb_peek(&session->skb_list);\r\nif (p->priority != first->priority)\r\nreturn -ENOSPC;\r\n}\r\nsession->ampdu_len += len;\r\nsession->dma_len += p->len;\r\ntid = (u8)p->priority;\r\nif (txrate[0].count <= ampdu->rr_retry_limit_tid[tid]) {\r\ntxrate[0].count++;\r\nrr = true;\r\n} else {\r\ntxrate[1].count++;\r\nrr = false;\r\n}\r\nif (ampdu_frames == 0) {\r\nu8 plcp0, plcp3, is40, sgi, mcs;\r\nuint fifo = le16_to_cpu(txh->TxFrameID) & TXFID_QUEUE_MASK;\r\nstruct brcms_fifo_info *f = &ampdu->fifo_tb[fifo];\r\nif (rr) {\r\nplcp0 = plcp[0];\r\nplcp3 = plcp[3];\r\n} else {\r\nplcp0 = txh->FragPLCPFallback[0];\r\nplcp3 = txh->FragPLCPFallback[3];\r\n}\r\nis40 = (plcp0 & MIMO_PLCP_40MHZ) ? 1 : 0;\r\nsgi = plcp3_issgi(plcp3) ? 1 : 0;\r\nmcs = plcp0 & ~MIMO_PLCP_40MHZ;\r\nsession->max_ampdu_len = min(scb_ampdu->max_rx_ampdu_bytes,\r\nampdu->max_txlen[mcs][is40][sgi]);\r\nsession->max_ampdu_frames = scb_ampdu->max_pdu;\r\nif (mcs_2_rate(mcs, true, false) >= f->dmaxferrate) {\r\nsession->max_ampdu_frames =\r\nmin_t(u16, f->mcs2ampdu_table[mcs],\r\nsession->max_ampdu_frames);\r\n}\r\n}\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nmcl &= ~TXC_AMPDU_MASK;\r\nmcl |= (TXC_AMPDU_MIDDLE << TXC_AMPDU_SHIFT);\r\nmcl &= ~(TXC_STARTMSDU | TXC_SENDRTS | TXC_SENDCTS);\r\ntxh->MacTxControlLow = cpu_to_le16(mcl);\r\ntxh->PreloadSize = 0;\r\nskb_queue_tail(&session->skb_list, p);\r\nreturn 0;\r\n}\r\nvoid brcms_c_ampdu_finalize(struct brcms_ampdu_session *session)\r\n{\r\nstruct brcms_c_info *wlc = session->wlc;\r\nstruct ampdu_info *ampdu = wlc->ampdu;\r\nstruct sk_buff *first, *last;\r\nstruct d11txh *txh;\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct ieee80211_tx_rate *txrate;\r\nu8 ndelim;\r\nu8 *plcp;\r\nuint len;\r\nuint fifo;\r\nstruct brcms_fifo_info *f;\r\nu16 mcl;\r\nbool fbr;\r\nbool fbr_iscck;\r\nstruct ieee80211_rts *rts;\r\nbool use_rts = false, use_cts = false;\r\nu16 dma_len = session->dma_len;\r\nu16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;\r\nu32 rspec = 0, rspec_fallback = 0;\r\nu32 rts_rspec = 0, rts_rspec_fallback = 0;\r\nu8 plcp0, plcp3, is40, sgi, mcs;\r\nu16 mch;\r\nu8 preamble_type = BRCMS_GF_PREAMBLE;\r\nu8 fbr_preamble_type = BRCMS_GF_PREAMBLE;\r\nu8 rts_preamble_type = BRCMS_LONG_PREAMBLE;\r\nu8 rts_fbr_preamble_type = BRCMS_LONG_PREAMBLE;\r\nif (skb_queue_empty(&session->skb_list))\r\nreturn;\r\nfirst = skb_peek(&session->skb_list);\r\nlast = skb_peek_tail(&session->skb_list);\r\ntxh = (struct d11txh *)last->data;\r\nfifo = le16_to_cpu(txh->TxFrameID) & TXFID_QUEUE_MASK;\r\nf = &ampdu->fifo_tb[fifo];\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nmcl &= ~TXC_AMPDU_MASK;\r\nmcl |= (TXC_AMPDU_LAST << TXC_AMPDU_SHIFT);\r\ntxh->MacTxControlLow = cpu_to_le16(mcl);\r\nndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];\r\ntxh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] = 0;\r\nsession->ampdu_len -= ndelim * AMPDU_DELIMITER_LEN;\r\nfbr_iscck = ((le16_to_cpu(txh->XtraFrameTypes) & 0x3) == 0);\r\nlen = fbr_iscck ? BRCMS_GET_CCK_PLCP_LEN(txh->FragPLCPFallback) :\r\nBRCMS_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);\r\nsession->ampdu_len -= roundup(len, 4) - len;\r\ntx_info = IEEE80211_SKB_CB(first);\r\ntxrate = tx_info->status.rates;\r\ntxh = (struct d11txh *)first->data;\r\nplcp = (u8 *)(txh + 1);\r\nrts = (struct ieee80211_rts *)&txh->rts_frame;\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nif (first != last) {\r\nmcl &= ~TXC_AMPDU_MASK;\r\nmcl |= (TXC_AMPDU_FIRST << TXC_AMPDU_SHIFT);\r\n}\r\nmcl |= TXC_STARTMSDU;\r\nif (ieee80211_is_rts(rts->frame_control)) {\r\nmcl |= TXC_SENDRTS;\r\nuse_rts = true;\r\n}\r\nif (ieee80211_is_cts(rts->frame_control)) {\r\nmcl |= TXC_SENDCTS;\r\nuse_cts = true;\r\n}\r\ntxh->MacTxControlLow = cpu_to_le16(mcl);\r\nfbr = txrate[1].count > 0;\r\nif (!fbr) {\r\nplcp0 = plcp[0];\r\nplcp3 = plcp[3];\r\n} else {\r\nplcp0 = txh->FragPLCPFallback[0];\r\nplcp3 = txh->FragPLCPFallback[3];\r\n}\r\nis40 = (plcp0 & MIMO_PLCP_40MHZ) ? 1 : 0;\r\nsgi = plcp3_issgi(plcp3) ? 1 : 0;\r\nmcs = plcp0 & ~MIMO_PLCP_40MHZ;\r\nif (is40) {\r\nif (CHSPEC_SB_UPPER(wlc_phy_chanspec_get(wlc->band->pi)))\r\nmimo_ctlchbw = PHY_TXC1_BW_20MHZ_UP;\r\nelse\r\nmimo_ctlchbw = PHY_TXC1_BW_20MHZ;\r\n}\r\nrspec = RSPEC_MIMORATE;\r\nrspec |= plcp[0] & ~MIMO_PLCP_40MHZ;\r\nif (plcp[0] & MIMO_PLCP_40MHZ)\r\nrspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);\r\nfbr_iscck = !(le16_to_cpu(txh->XtraFrameTypes) & 0x03);\r\nif (fbr_iscck) {\r\nrspec_fallback =\r\ncck_rspec(cck_phy2mac_rate(txh->FragPLCPFallback[0]));\r\n} else {\r\nrspec_fallback = RSPEC_MIMORATE;\r\nrspec_fallback |= txh->FragPLCPFallback[0] & ~MIMO_PLCP_40MHZ;\r\nif (txh->FragPLCPFallback[0] & MIMO_PLCP_40MHZ)\r\nrspec_fallback |= PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT;\r\n}\r\nif (use_rts || use_cts) {\r\nrts_rspec =\r\nbrcms_c_rspec_to_rts_rspec(wlc, rspec,\r\nfalse, mimo_ctlchbw);\r\nrts_rspec_fallback =\r\nbrcms_c_rspec_to_rts_rspec(wlc, rspec_fallback,\r\nfalse, mimo_ctlchbw);\r\n}\r\nBRCMS_SET_MIMO_PLCP_LEN(plcp, session->ampdu_len);\r\nBRCMS_SET_MIMO_PLCP_AMPDU(plcp);\r\nif (txh->MModeLen) {\r\nu16 mmodelen = brcms_c_calc_lsig_len(wlc, rspec,\r\nsession->ampdu_len);\r\ntxh->MModeLen = cpu_to_le16(mmodelen);\r\npreamble_type = BRCMS_MM_PREAMBLE;\r\n}\r\nif (txh->MModeFbrLen) {\r\nu16 mmfbrlen = brcms_c_calc_lsig_len(wlc, rspec_fallback,\r\nsession->ampdu_len);\r\ntxh->MModeFbrLen = cpu_to_le16(mmfbrlen);\r\nfbr_preamble_type = BRCMS_MM_PREAMBLE;\r\n}\r\nif (mcs_2_rate(mcs, true, false) >= f->dmaxferrate) {\r\ndma_len = min(dma_len, f->ampdu_pld_size);\r\ntxh->PreloadSize = cpu_to_le16(dma_len);\r\n} else {\r\ntxh->PreloadSize = 0;\r\n}\r\nmch = le16_to_cpu(txh->MacTxControlHigh);\r\nif (use_rts || use_cts) {\r\nu16 durid;\r\nif ((mch & TXC_PREAMBLE_RTS_MAIN_SHORT) ==\r\nTXC_PREAMBLE_RTS_MAIN_SHORT)\r\nrts_preamble_type = BRCMS_SHORT_PREAMBLE;\r\nif ((mch & TXC_PREAMBLE_RTS_FB_SHORT) ==\r\nTXC_PREAMBLE_RTS_FB_SHORT)\r\nrts_fbr_preamble_type = BRCMS_SHORT_PREAMBLE;\r\ndurid = brcms_c_compute_rtscts_dur(wlc, use_cts, rts_rspec,\r\nrspec, rts_preamble_type,\r\npreamble_type,\r\nsession->ampdu_len, true);\r\nrts->duration = cpu_to_le16(durid);\r\ndurid = brcms_c_compute_rtscts_dur(wlc, use_cts,\r\nrts_rspec_fallback,\r\nrspec_fallback,\r\nrts_fbr_preamble_type,\r\nfbr_preamble_type,\r\nsession->ampdu_len, true);\r\ntxh->RTSDurFallback = cpu_to_le16(durid);\r\ntxh->TxFesTimeNormal = rts->duration;\r\ntxh->TxFesTimeFallback = txh->RTSDurFallback;\r\n}\r\nif (fbr) {\r\nmch |= TXC_AMPDU_FBR;\r\ntxh->MacTxControlHigh = cpu_to_le16(mch);\r\nBRCMS_SET_MIMO_PLCP_AMPDU(plcp);\r\nBRCMS_SET_MIMO_PLCP_AMPDU(txh->FragPLCPFallback);\r\n}\r\nbrcms_dbg_ht(wlc->hw->d11core, "wl%d: count %d ampdu_len %d\n",\r\nwlc->pub->unit, skb_queue_len(&session->skb_list),\r\nsession->ampdu_len);\r\n}\r\nstatic void\r\nbrcms_c_ampdu_rate_status(struct brcms_c_info *wlc,\r\nstruct ieee80211_tx_info *tx_info,\r\nstruct tx_status *txs, u8 mcs)\r\n{\r\nstruct ieee80211_tx_rate *txrate = tx_info->status.rates;\r\nint i;\r\nfor (i = 2; i < IEEE80211_TX_MAX_RATES; i++) {\r\ntxrate[i].idx = -1;\r\ntxrate[i].count = 0;\r\n}\r\n}\r\nstatic void\r\nbrcms_c_ampdu_dotxstatus_complete(struct ampdu_info *ampdu, struct scb *scb,\r\nstruct sk_buff *p, struct tx_status *txs,\r\nu32 s1, u32 s2)\r\n{\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nstruct scb_ampdu_tid_ini *ini;\r\nu8 bitmap[8], queue, tid;\r\nstruct d11txh *txh;\r\nu8 *plcp;\r\nstruct ieee80211_hdr *h;\r\nu16 seq, start_seq = 0, bindex, index, mcl;\r\nu8 mcs = 0;\r\nbool ba_recd = false, ack_recd = false;\r\nu8 suc_mpdu = 0, tot_mpdu = 0;\r\nuint supr_status;\r\nbool update_rate = true, retry = true, tx_error = false;\r\nu16 mimoantsel = 0;\r\nu8 antselid = 0;\r\nu8 retry_limit, rr_retry_limit;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);\r\n#ifdef DEBUG\r\nu8 hole[AMPDU_MAX_MPDU];\r\nmemset(hole, 0, sizeof(hole));\r\n#endif\r\nscb_ampdu = &scb->scb_ampdu;\r\ntid = (u8) (p->priority);\r\nini = &scb_ampdu->ini[tid];\r\nretry_limit = ampdu->retry_limit_tid[tid];\r\nrr_retry_limit = ampdu->rr_retry_limit_tid[tid];\r\nmemset(bitmap, 0, sizeof(bitmap));\r\nqueue = txs->frameid & TXFID_QUEUE_MASK;\r\nsupr_status = txs->status & TX_STATUS_SUPR_MASK;\r\nif (txs->status & TX_STATUS_ACK_RCV) {\r\nif (TX_STATUS_SUPR_UF == supr_status)\r\nupdate_rate = false;\r\nWARN_ON(!(txs->status & TX_STATUS_INTERMEDIATE));\r\nstart_seq = txs->sequence >> SEQNUM_SHIFT;\r\nbitmap[0] = (txs->status & TX_STATUS_BA_BMAP03_MASK) >>\r\nTX_STATUS_BA_BMAP03_SHIFT;\r\nWARN_ON(s1 & TX_STATUS_INTERMEDIATE);\r\nWARN_ON(!(s1 & TX_STATUS_AMPDU));\r\nbitmap[0] |=\r\n(s1 & TX_STATUS_BA_BMAP47_MASK) <<\r\nTX_STATUS_BA_BMAP47_SHIFT;\r\nbitmap[1] = (s1 >> 8) & 0xff;\r\nbitmap[2] = (s1 >> 16) & 0xff;\r\nbitmap[3] = (s1 >> 24) & 0xff;\r\nbitmap[4] = s2 & 0xff;\r\nbitmap[5] = (s2 >> 8) & 0xff;\r\nbitmap[6] = (s2 >> 16) & 0xff;\r\nbitmap[7] = (s2 >> 24) & 0xff;\r\nba_recd = true;\r\n} else {\r\nif (supr_status) {\r\nupdate_rate = false;\r\nif (supr_status == TX_STATUS_SUPR_BADCH) {\r\nbrcms_dbg_ht(wlc->hw->d11core,\r\n"%s: Pkt tx suppressed, illegal channel possibly %d\n",\r\n__func__, CHSPEC_CHANNEL(\r\nwlc->default_bss->chanspec));\r\n} else {\r\nif (supr_status != TX_STATUS_SUPR_FRAG)\r\nbrcms_err(wlc->hw->d11core,\r\n"%s: supr_status 0x%x\n",\r\n__func__, supr_status);\r\n}\r\nif (supr_status == TX_STATUS_SUPR_BADCH ||\r\nsupr_status == TX_STATUS_SUPR_EXPTIME) {\r\nretry = false;\r\n} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {\r\n} else if (supr_status == TX_STATUS_SUPR_FRAG) {\r\nif (brcms_c_ffpld_check_txfunfl(wlc, queue) > 0)\r\ntx_error = true;\r\n}\r\n} else if (txs->phyerr) {\r\nupdate_rate = false;\r\nbrcms_dbg_ht(wlc->hw->d11core,\r\n"%s: ampdu tx phy error (0x%x)\n",\r\n__func__, txs->phyerr);\r\n}\r\n}\r\nwhile (p) {\r\ntx_info = IEEE80211_SKB_CB(p);\r\ntxh = (struct d11txh *) p->data;\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nplcp = (u8 *) (txh + 1);\r\nh = (struct ieee80211_hdr *)(plcp + D11_PHY_HDR_LEN);\r\nseq = le16_to_cpu(h->seq_ctrl) >> SEQNUM_SHIFT;\r\ntrace_brcms_txdesc(&wlc->hw->d11core->dev, txh, sizeof(*txh));\r\nif (tot_mpdu == 0) {\r\nmcs = plcp[0] & MIMO_PLCP_MCS_MASK;\r\nmimoantsel = le16_to_cpu(txh->ABI_MimoAntSel);\r\n}\r\nindex = TX_SEQ_TO_INDEX(seq);\r\nack_recd = false;\r\nif (ba_recd) {\r\nbindex = MODSUB_POW2(seq, start_seq, SEQNUM_MAX);\r\nbrcms_dbg_ht(wlc->hw->d11core,\r\n"tid %d seq %d, start_seq %d, bindex %d set %d, index %d\n",\r\ntid, seq, start_seq, bindex,\r\nisset(bitmap, bindex), index);\r\nif ((bindex < AMPDU_TX_BA_MAX_WSIZE)\r\n&& isset(bitmap, bindex)) {\r\nini->txretry[index] = 0;\r\nbrcms_c_ampdu_rate_status(wlc, tx_info, txs,\r\nmcs);\r\ntx_info->flags |= IEEE80211_TX_STAT_ACK;\r\ntx_info->flags |= IEEE80211_TX_STAT_AMPDU;\r\ntx_info->status.ampdu_ack_len =\r\ntx_info->status.ampdu_len = 1;\r\nskb_pull(p, D11_PHY_HDR_LEN);\r\nskb_pull(p, D11_TXH_LEN);\r\nieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,\r\np);\r\nack_recd = true;\r\nsuc_mpdu++;\r\n}\r\n}\r\nif (!ack_recd) {\r\nif (retry && (ini->txretry[index] < (int)retry_limit)) {\r\nint ret;\r\nini->txretry[index]++;\r\nret = brcms_c_txfifo(wlc, queue, p);\r\nWARN_ONCE(ret, "queue %d out of txds\n", queue);\r\n} else {\r\nieee80211_tx_info_clear_status(tx_info);\r\ntx_info->status.ampdu_ack_len = 0;\r\ntx_info->status.ampdu_len = 1;\r\ntx_info->flags |=\r\nIEEE80211_TX_STAT_AMPDU_NO_BACK;\r\nskb_pull(p, D11_PHY_HDR_LEN);\r\nskb_pull(p, D11_TXH_LEN);\r\nbrcms_dbg_ht(wlc->hw->d11core,\r\n"BA Timeout, seq %d\n",\r\nseq);\r\nieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,\r\np);\r\n}\r\n}\r\ntot_mpdu++;\r\nif (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==\r\nTXC_AMPDU_LAST)\r\nbreak;\r\np = dma_getnexttxp(wlc->hw->di[queue], DMA_RANGE_TRANSMITTED);\r\n}\r\nantselid = brcms_c_antsel_antsel2id(wlc->asi, mimoantsel);\r\n}\r\nvoid\r\nbrcms_c_ampdu_dotxstatus(struct ampdu_info *ampdu, struct scb *scb,\r\nstruct sk_buff *p, struct tx_status *txs)\r\n{\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nstruct scb_ampdu_tid_ini *ini;\r\nu32 s1 = 0, s2 = 0;\r\nstruct ieee80211_tx_info *tx_info;\r\ntx_info = IEEE80211_SKB_CB(p);\r\nif (txs->status & TX_STATUS_ACK_RCV) {\r\nu8 status_delay = 0;\r\ns1 = bcma_read32(wlc->hw->d11core, D11REGOFFS(frmtxstatus));\r\nwhile ((s1 & TXS_V) == 0) {\r\nudelay(1);\r\nstatus_delay++;\r\nif (status_delay > 10)\r\nreturn;\r\ns1 = bcma_read32(wlc->hw->d11core,\r\nD11REGOFFS(frmtxstatus));\r\n}\r\ns2 = bcma_read32(wlc->hw->d11core, D11REGOFFS(frmtxstatus2));\r\n}\r\nif (scb) {\r\nscb_ampdu = &scb->scb_ampdu;\r\nini = &scb_ampdu->ini[p->priority];\r\nbrcms_c_ampdu_dotxstatus_complete(ampdu, scb, p, txs, s1, s2);\r\n} else {\r\nu8 queue = txs->frameid & TXFID_QUEUE_MASK;\r\nstruct d11txh *txh;\r\nu16 mcl;\r\nwhile (p) {\r\ntx_info = IEEE80211_SKB_CB(p);\r\ntxh = (struct d11txh *) p->data;\r\ntrace_brcms_txdesc(&wlc->hw->d11core->dev, txh,\r\nsizeof(*txh));\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nbrcmu_pkt_buf_free_skb(p);\r\nif (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==\r\nTXC_AMPDU_LAST)\r\nbreak;\r\np = dma_getnexttxp(wlc->hw->di[queue],\r\nDMA_RANGE_TRANSMITTED);\r\n}\r\n}\r\n}\r\nvoid brcms_c_ampdu_macaddr_upd(struct brcms_c_info *wlc)\r\n{\r\nchar template[T_RAM_ACCESS_SZ * 2];\r\nmemset(template, 0, sizeof(template));\r\nmemcpy(template, wlc->pub->cur_etheraddr, ETH_ALEN);\r\nbrcms_b_write_template_ram(wlc->hw, (T_BA_TPL_BASE + 16),\r\n(T_RAM_ACCESS_SZ * 2),\r\ntemplate);\r\n}\r\nbool brcms_c_aggregatable(struct brcms_c_info *wlc, u8 tid)\r\n{\r\nreturn wlc->ampdu->ini_enable[tid];\r\n}\r\nvoid brcms_c_ampdu_shm_upd(struct ampdu_info *ampdu)\r\n{\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nif ((ampdu->rx_factor & IEEE80211_HT_AMPDU_PARM_FACTOR) ==\r\nIEEE80211_HT_MAX_AMPDU_64K) {\r\nbrcms_b_write_shm(wlc->hw, M_MIMO_MAXSYM, MIMO_MAXSYM_MAX);\r\nbrcms_b_write_shm(wlc->hw, M_WATCHDOG_8TU, WATCHDOG_8TU_MAX);\r\n} else {\r\nbrcms_b_write_shm(wlc->hw, M_MIMO_MAXSYM, MIMO_MAXSYM_DEF);\r\nbrcms_b_write_shm(wlc->hw, M_WATCHDOG_8TU, WATCHDOG_8TU_DEF);\r\n}\r\n}\r\nstatic void dma_cb_fn_ampdu(void *txi, void *arg_a)\r\n{\r\nstruct ieee80211_sta *sta = arg_a;\r\nstruct ieee80211_tx_info *tx_info = (struct ieee80211_tx_info *)txi;\r\nif ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n(tx_info->rate_driver_data[0] == sta || sta == NULL))\r\ntx_info->rate_driver_data[0] = NULL;\r\n}\r\nvoid brcms_c_ampdu_flush(struct brcms_c_info *wlc,\r\nstruct ieee80211_sta *sta, u16 tid)\r\n{\r\nbrcms_c_inval_dma_pkts(wlc->hw, sta, dma_cb_fn_ampdu);\r\n}
