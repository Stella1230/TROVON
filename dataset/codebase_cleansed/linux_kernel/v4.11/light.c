static struct gb_connection *get_conn_from_channel(struct gb_channel *channel)\r\n{\r\nreturn channel->light->glights->connection;\r\n}\r\nstatic struct gb_connection *get_conn_from_light(struct gb_light *light)\r\n{\r\nreturn light->glights->connection;\r\n}\r\nstatic bool is_channel_flash(struct gb_channel *channel)\r\n{\r\nreturn !!(channel->mode & (GB_CHANNEL_MODE_FLASH | GB_CHANNEL_MODE_TORCH\r\n| GB_CHANNEL_MODE_INDICATOR));\r\n}\r\nstatic struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)\r\n{\r\nstruct led_classdev_flash *fled_cdev = lcdev_to_flcdev(cdev);\r\nreturn container_of(fled_cdev, struct gb_channel, fled);\r\n}\r\nstatic struct led_classdev *get_channel_cdev(struct gb_channel *channel)\r\n{\r\nreturn &channel->fled.led_cdev;\r\n}\r\nstatic struct gb_channel *get_channel_from_mode(struct gb_light *light,\r\nu32 mode)\r\n{\r\nstruct gb_channel *channel = NULL;\r\nint i;\r\nfor (i = 0; i < light->channels_count; i++) {\r\nchannel = &light->channels[i];\r\nif (channel && channel->mode == mode)\r\nbreak;\r\n}\r\nreturn channel;\r\n}\r\nstatic int __gb_lights_flash_intensity_set(struct gb_channel *channel,\r\nu32 intensity)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_set_flash_intensity_request req;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\nreturn ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.intensity_uA = cpu_to_le32(intensity);\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_INTENSITY,\r\n&req, sizeof(req), NULL, 0);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int __gb_lights_flash_brightness_set(struct gb_channel *channel)\r\n{\r\nu32 intensity;\r\nif (channel->mode & GB_CHANNEL_MODE_FLASH)\r\nchannel = get_channel_from_mode(channel->light,\r\nGB_CHANNEL_MODE_TORCH);\r\nintensity = channel->intensity_uA.min +\r\n(channel->intensity_uA.step * channel->led->brightness);\r\nreturn __gb_lights_flash_intensity_set(channel, intensity);\r\n}\r\nstatic struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)\r\n{\r\nreturn container_of(cdev, struct gb_channel, cled);\r\n}\r\nstatic struct led_classdev *get_channel_cdev(struct gb_channel *channel)\r\n{\r\nreturn &channel->cled;\r\n}\r\nstatic int __gb_lights_flash_brightness_set(struct gb_channel *channel)\r\n{\r\nreturn 0;\r\n}\r\nstatic void led_lock(struct led_classdev *cdev)\r\n{\r\nmutex_lock(&cdev->led_access);\r\n}\r\nstatic void led_unlock(struct led_classdev *cdev)\r\n{\r\nmutex_unlock(&cdev->led_access);\r\n}\r\nstatic ssize_t color_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct led_classdev *cdev = dev_get_drvdata(dev);\r\nstruct gb_channel *channel = get_channel_from_cdev(cdev);\r\nreturn sprintf(buf, "0x%08x\n", channel->color);\r\n}\r\nstatic ssize_t color_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct led_classdev *cdev = dev_get_drvdata(dev);\r\nstruct gb_channel *channel = get_channel_from_cdev(cdev);\r\nu32 color;\r\nint ret;\r\nled_lock(cdev);\r\nif (led_sysfs_is_disabled(cdev)) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nret = kstrtou32(buf, 0, &color);\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse color value %d\n", ret);\r\ngoto unlock;\r\n}\r\nret = gb_lights_color_set(channel, color);\r\nif (ret < 0)\r\ngoto unlock;\r\nchannel->color = color;\r\nret = size;\r\nunlock:\r\nled_unlock(cdev);\r\nreturn ret;\r\n}\r\nstatic int channel_attr_groups_set(struct gb_channel *channel,\r\nstruct led_classdev *cdev)\r\n{\r\nint attr = 0;\r\nint size = 0;\r\nif (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)\r\nsize++;\r\nif (channel->flags & GB_LIGHT_CHANNEL_FADER)\r\nsize += 2;\r\nif (!size)\r\nreturn 0;\r\nchannel->attrs = kcalloc(size + 1, sizeof(*channel->attrs), GFP_KERNEL);\r\nif (!channel->attrs)\r\nreturn -ENOMEM;\r\nchannel->attr_group = kcalloc(1, sizeof(*channel->attr_group),\r\nGFP_KERNEL);\r\nif (!channel->attr_group)\r\nreturn -ENOMEM;\r\nchannel->attr_groups = kcalloc(2, sizeof(*channel->attr_groups),\r\nGFP_KERNEL);\r\nif (!channel->attr_groups)\r\nreturn -ENOMEM;\r\nif (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)\r\nchannel->attrs[attr++] = &dev_attr_color.attr;\r\nif (channel->flags & GB_LIGHT_CHANNEL_FADER) {\r\nchannel->attrs[attr++] = &dev_attr_fade_in.attr;\r\nchannel->attrs[attr++] = &dev_attr_fade_out.attr;\r\n}\r\nchannel->attr_group->attrs = channel->attrs;\r\nchannel->attr_groups[0] = channel->attr_group;\r\ncdev->groups = channel->attr_groups;\r\nreturn 0;\r\n}\r\nstatic int gb_lights_fade_set(struct gb_channel *channel)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_set_fade_request req;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\nreturn ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.fade_in = channel->fade_in;\r\nreq.fade_out = channel->fade_out;\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FADE,\r\n&req, sizeof(req), NULL, 0);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_lights_color_set(struct gb_channel *channel, u32 color)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_set_color_request req;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\nreturn ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.color = cpu_to_le32(color);\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_COLOR,\r\n&req, sizeof(req), NULL, 0);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int __gb_lights_led_brightness_set(struct gb_channel *channel)\r\n{\r\nstruct gb_lights_set_brightness_request req;\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nbool old_active;\r\nint ret;\r\nmutex_lock(&channel->lock);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nold_active = channel->active;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.brightness = (u8)channel->led->brightness;\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BRIGHTNESS,\r\n&req, sizeof(req), NULL, 0);\r\nif (ret < 0)\r\ngoto out_pm_put;\r\nif (channel->led->brightness)\r\nchannel->active = true;\r\nelse\r\nchannel->active = false;\r\nif (!old_active && channel->active)\r\ngoto out_unlock;\r\nif (old_active && !channel->active)\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nout_pm_put:\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nout_unlock:\r\nmutex_unlock(&channel->lock);\r\nreturn ret;\r\n}\r\nstatic int __gb_lights_brightness_set(struct gb_channel *channel)\r\n{\r\nint ret;\r\nif (channel->releasing)\r\nreturn 0;\r\nif (is_channel_flash(channel))\r\nret = __gb_lights_flash_brightness_set(channel);\r\nelse\r\nret = __gb_lights_led_brightness_set(channel);\r\nreturn ret;\r\n}\r\nstatic int gb_brightness_set(struct led_classdev *cdev,\r\nenum led_brightness value)\r\n{\r\nstruct gb_channel *channel = get_channel_from_cdev(cdev);\r\nchannel->led->brightness = value;\r\nreturn __gb_lights_brightness_set(channel);\r\n}\r\nstatic enum led_brightness gb_brightness_get(struct led_classdev *cdev)\r\n{\r\nstruct gb_channel *channel = get_channel_from_cdev(cdev);\r\nreturn channel->led->brightness;\r\n}\r\nstatic int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct gb_channel *channel = get_channel_from_cdev(cdev);\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_blink_request req;\r\nbool old_active;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nif (!delay_on || !delay_off)\r\nreturn -EINVAL;\r\nmutex_lock(&channel->lock);\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\ngoto out_unlock;\r\nold_active = channel->active;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.time_on_ms = cpu_to_le16(*delay_on);\r\nreq.time_off_ms = cpu_to_le16(*delay_off);\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BLINK, &req,\r\nsizeof(req), NULL, 0);\r\nif (ret < 0)\r\ngoto out_pm_put;\r\nif (*delay_on)\r\nchannel->active = true;\r\nelse\r\nchannel->active = false;\r\nif (!old_active && channel->active)\r\ngoto out_unlock;\r\nif (old_active && !channel->active)\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nout_pm_put:\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nout_unlock:\r\nmutex_unlock(&channel->lock);\r\nreturn ret;\r\n}\r\nstatic void gb_lights_led_operations_set(struct gb_channel *channel,\r\nstruct led_classdev *cdev)\r\n{\r\ncdev->brightness_get = gb_brightness_get;\r\ncdev->brightness_set_blocking = gb_brightness_set;\r\nif (channel->flags & GB_LIGHT_CHANNEL_BLINK)\r\ncdev->blink_set = gb_blink_set;\r\n}\r\nstatic void __gb_lights_channel_v4l2_config(struct led_flash_setting *channel_s,\r\nstruct led_flash_setting *v4l2_s)\r\n{\r\nv4l2_s->min = channel_s->min;\r\nv4l2_s->max = channel_s->max;\r\nv4l2_s->step = channel_s->step;\r\nv4l2_s->val = channel_s->max;\r\n}\r\nstatic int gb_lights_light_v4l2_register(struct gb_light *light)\r\n{\r\nstruct gb_connection *connection = get_conn_from_light(light);\r\nstruct device *dev = &connection->bundle->dev;\r\nstruct v4l2_flash_config *sd_cfg;\r\nstruct led_classdev_flash *fled;\r\nstruct led_classdev_flash *iled = NULL;\r\nstruct gb_channel *channel_torch, *channel_ind, *channel_flash;\r\nint ret = 0;\r\nsd_cfg = kcalloc(1, sizeof(*sd_cfg), GFP_KERNEL);\r\nif (!sd_cfg)\r\nreturn -ENOMEM;\r\nchannel_torch = get_channel_from_mode(light, GB_CHANNEL_MODE_TORCH);\r\nif (channel_torch)\r\n__gb_lights_channel_v4l2_config(&channel_torch->intensity_uA,\r\n&sd_cfg->torch_intensity);\r\nchannel_ind = get_channel_from_mode(light, GB_CHANNEL_MODE_INDICATOR);\r\nif (channel_ind) {\r\n__gb_lights_channel_v4l2_config(&channel_ind->intensity_uA,\r\n&sd_cfg->indicator_intensity);\r\niled = &channel_ind->fled;\r\n}\r\nchannel_flash = get_channel_from_mode(light, GB_CHANNEL_MODE_FLASH);\r\nWARN_ON(!channel_flash);\r\nfled = &channel_flash->fled;\r\nsnprintf(sd_cfg->dev_name, sizeof(sd_cfg->dev_name), "%s", light->name);\r\nsd_cfg->flash_faults = LED_FAULT_OVER_VOLTAGE | LED_FAULT_TIMEOUT |\r\nLED_FAULT_OVER_TEMPERATURE | LED_FAULT_SHORT_CIRCUIT |\r\nLED_FAULT_OVER_CURRENT | LED_FAULT_INDICATOR |\r\nLED_FAULT_UNDER_VOLTAGE | LED_FAULT_INPUT_VOLTAGE |\r\nLED_FAULT_LED_OVER_TEMPERATURE;\r\nlight->v4l2_flash = v4l2_flash_init(dev, NULL, fled, iled,\r\n&v4l2_flash_ops, sd_cfg);\r\nif (IS_ERR_OR_NULL(light->v4l2_flash)) {\r\nret = PTR_ERR(light->v4l2_flash);\r\ngoto out_free;\r\n}\r\nreturn ret;\r\nout_free:\r\nkfree(sd_cfg);\r\nreturn ret;\r\n}\r\nstatic void gb_lights_light_v4l2_unregister(struct gb_light *light)\r\n{\r\nv4l2_flash_release(light->v4l2_flash);\r\n}\r\nstatic int gb_lights_light_v4l2_register(struct gb_light *light)\r\n{\r\nstruct gb_connection *connection = get_conn_from_light(light);\r\ndev_err(&connection->bundle->dev, "no support for v4l2 subdevices\n");\r\nreturn 0;\r\n}\r\nstatic void gb_lights_light_v4l2_unregister(struct gb_light *light)\r\n{\r\n}\r\nstatic int gb_lights_flash_intensity_set(struct led_classdev_flash *fcdev,\r\nu32 brightness)\r\n{\r\nstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\r\nfled);\r\nint ret;\r\nret = __gb_lights_flash_intensity_set(channel, brightness);\r\nif (ret < 0)\r\nreturn ret;\r\nfcdev->brightness.val = brightness;\r\nreturn 0;\r\n}\r\nstatic int gb_lights_flash_intensity_get(struct led_classdev_flash *fcdev,\r\nu32 *brightness)\r\n{\r\n*brightness = fcdev->brightness.val;\r\nreturn 0;\r\n}\r\nstatic int gb_lights_flash_strobe_set(struct led_classdev_flash *fcdev,\r\nbool state)\r\n{\r\nstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\r\nfled);\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_set_flash_strobe_request req;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\nreturn ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.state = state ? 1 : 0;\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_STROBE,\r\n&req, sizeof(req), NULL, 0);\r\nif (!ret)\r\nchannel->strobe_state = state;\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_lights_flash_strobe_get(struct led_classdev_flash *fcdev,\r\nbool *state)\r\n{\r\nstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\r\nfled);\r\n*state = channel->strobe_state;\r\nreturn 0;\r\n}\r\nstatic int gb_lights_flash_timeout_set(struct led_classdev_flash *fcdev,\r\nu32 timeout)\r\n{\r\nstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\r\nfled);\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_set_flash_timeout_request req;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\nreturn ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nreq.timeout_us = cpu_to_le32(timeout);\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_TIMEOUT,\r\n&req, sizeof(req), NULL, 0);\r\nif (!ret)\r\nfcdev->timeout.val = timeout;\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_lights_flash_fault_get(struct led_classdev_flash *fcdev,\r\nu32 *fault)\r\n{\r\nstruct gb_channel *channel = container_of(fcdev, struct gb_channel,\r\nfled);\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_bundle *bundle = connection->bundle;\r\nstruct gb_lights_get_flash_fault_request req;\r\nstruct gb_lights_get_flash_fault_response resp;\r\nint ret;\r\nif (channel->releasing)\r\nreturn -ESHUTDOWN;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret < 0)\r\nreturn ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_FLASH_FAULT,\r\n&req, sizeof(req), &resp, sizeof(resp));\r\nif (!ret)\r\n*fault = le32_to_cpu(resp.fault);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int __gb_lights_channel_torch_attach(struct gb_channel *channel,\r\nstruct gb_channel *channel_torch)\r\n{\r\nchar *name;\r\nif (!(channel->mode & GB_CHANNEL_MODE_FLASH))\r\nreturn 0;\r\nchannel->led->max_brightness = channel_torch->led->max_brightness;\r\nname = kasprintf(GFP_KERNEL, "%s_%s", channel->led->name,\r\nchannel_torch->mode_name);\r\nif (!name)\r\nreturn -ENOMEM;\r\nkfree(channel->led->name);\r\nchannel->led->name = name;\r\nchannel_torch->led = channel->led;\r\nreturn 0;\r\n}\r\nstatic int __gb_lights_flash_led_register(struct gb_channel *channel)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct led_classdev_flash *fled = &channel->fled;\r\nstruct led_flash_setting *fset;\r\nstruct gb_channel *channel_torch;\r\nint ret;\r\nfled->ops = &gb_lights_flash_ops;\r\nfled->led_cdev.flags |= LED_DEV_CAP_FLASH;\r\nfset = &fled->brightness;\r\nfset->min = channel->intensity_uA.min;\r\nfset->max = channel->intensity_uA.max;\r\nfset->step = channel->intensity_uA.step;\r\nfset->val = channel->intensity_uA.max;\r\nif (channel->mode & GB_CHANNEL_MODE_FLASH) {\r\nfset = &fled->timeout;\r\nfset->min = channel->timeout_us.min;\r\nfset->max = channel->timeout_us.max;\r\nfset->step = channel->timeout_us.step;\r\nfset->val = channel->timeout_us.max;\r\n}\r\nchannel_torch = get_channel_from_mode(channel->light,\r\nGB_CHANNEL_MODE_TORCH);\r\nif (channel_torch) {\r\nret = __gb_lights_channel_torch_attach(channel, channel_torch);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nret = led_classdev_flash_register(&connection->bundle->dev, fled);\r\nif (ret < 0)\r\ngoto fail;\r\nchannel->is_registered = true;\r\nreturn 0;\r\nfail:\r\nchannel->led = NULL;\r\nreturn ret;\r\n}\r\nstatic void __gb_lights_flash_led_unregister(struct gb_channel *channel)\r\n{\r\nif (!channel->is_registered)\r\nreturn;\r\nled_classdev_flash_unregister(&channel->fled);\r\n}\r\nstatic int gb_lights_channel_flash_config(struct gb_channel *channel)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct gb_lights_get_channel_flash_config_request req;\r\nstruct gb_lights_get_channel_flash_config_response conf;\r\nstruct led_flash_setting *fset;\r\nint ret;\r\nreq.light_id = channel->light->id;\r\nreq.channel_id = channel->id;\r\nret = gb_operation_sync(connection,\r\nGB_LIGHTS_TYPE_GET_CHANNEL_FLASH_CONFIG,\r\n&req, sizeof(req), &conf, sizeof(conf));\r\nif (ret < 0)\r\nreturn ret;\r\nfset = &channel->intensity_uA;\r\nfset->min = le32_to_cpu(conf.intensity_min_uA);\r\nfset->max = le32_to_cpu(conf.intensity_max_uA);\r\nfset->step = le32_to_cpu(conf.intensity_step_uA);\r\nchannel->led->max_brightness = (fset->max - fset->min) / fset->step;\r\nif (channel->mode & GB_CHANNEL_MODE_FLASH) {\r\nfset = &channel->timeout_us;\r\nfset->min = le32_to_cpu(conf.timeout_min_us);\r\nfset->max = le32_to_cpu(conf.timeout_max_us);\r\nfset->step = le32_to_cpu(conf.timeout_step_us);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_lights_channel_flash_config(struct gb_channel *channel)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\ndev_err(&connection->bundle->dev, "no support for flash devices\n");\r\nreturn 0;\r\n}\r\nstatic int __gb_lights_flash_led_register(struct gb_channel *channel)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __gb_lights_flash_led_unregister(struct gb_channel *channel)\r\n{\r\n}\r\nstatic int __gb_lights_led_register(struct gb_channel *channel)\r\n{\r\nstruct gb_connection *connection = get_conn_from_channel(channel);\r\nstruct led_classdev *cdev = get_channel_cdev(channel);\r\nint ret;\r\nret = led_classdev_register(&connection->bundle->dev, cdev);\r\nif (ret < 0)\r\nchannel->led = NULL;\r\nelse\r\nchannel->is_registered = true;\r\nreturn ret;\r\n}\r\nstatic int gb_lights_channel_register(struct gb_channel *channel)\r\n{\r\nif (!is_channel_flash(channel))\r\nreturn __gb_lights_led_register(channel);\r\nif (!(channel->mode & GB_CHANNEL_MODE_TORCH))\r\nreturn __gb_lights_flash_led_register(channel);\r\nreturn 0;\r\n}\r\nstatic void __gb_lights_led_unregister(struct gb_channel *channel)\r\n{\r\nstruct led_classdev *cdev = get_channel_cdev(channel);\r\nif (!channel->is_registered)\r\nreturn;\r\nled_classdev_unregister(cdev);\r\nchannel->led = NULL;\r\n}\r\nstatic void gb_lights_channel_unregister(struct gb_channel *channel)\r\n{\r\nif (!is_channel_flash(channel)) {\r\n__gb_lights_led_unregister(channel);\r\nreturn;\r\n}\r\nif (channel->mode & GB_CHANNEL_MODE_TORCH)\r\n__gb_lights_led_unregister(channel);\r\nelse\r\n__gb_lights_flash_led_unregister(channel);\r\n}\r\nstatic int gb_lights_channel_config(struct gb_light *light,\r\nstruct gb_channel *channel)\r\n{\r\nstruct gb_lights_get_channel_config_response conf;\r\nstruct gb_lights_get_channel_config_request req;\r\nstruct gb_connection *connection = get_conn_from_light(light);\r\nstruct led_classdev *cdev = get_channel_cdev(channel);\r\nchar *name;\r\nint ret;\r\nreq.light_id = light->id;\r\nreq.channel_id = channel->id;\r\nret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_CHANNEL_CONFIG,\r\n&req, sizeof(req), &conf, sizeof(conf));\r\nif (ret < 0)\r\nreturn ret;\r\nchannel->light = light;\r\nchannel->mode = le32_to_cpu(conf.mode);\r\nchannel->flags = le32_to_cpu(conf.flags);\r\nchannel->color = le32_to_cpu(conf.color);\r\nchannel->color_name = kstrndup(conf.color_name, NAMES_MAX, GFP_KERNEL);\r\nif (!channel->color_name)\r\nreturn -ENOMEM;\r\nchannel->mode_name = kstrndup(conf.mode_name, NAMES_MAX, GFP_KERNEL);\r\nif (!channel->mode_name)\r\nreturn -ENOMEM;\r\nchannel->led = cdev;\r\nname = kasprintf(GFP_KERNEL, "%s:%s:%s", light->name,\r\nchannel->color_name, channel->mode_name);\r\nif (!name)\r\nreturn -ENOMEM;\r\ncdev->name = name;\r\ncdev->max_brightness = conf.max_brightness;\r\nret = channel_attr_groups_set(channel, cdev);\r\nif (ret < 0)\r\nreturn ret;\r\ngb_lights_led_operations_set(channel, cdev);\r\nif (!is_channel_flash(channel))\r\nreturn ret;\r\nlight->has_flash = true;\r\nret = gb_lights_channel_flash_config(channel);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int gb_lights_light_config(struct gb_lights *glights, u8 id)\r\n{\r\nstruct gb_light *light = &glights->lights[id];\r\nstruct gb_lights_get_light_config_request req;\r\nstruct gb_lights_get_light_config_response conf;\r\nint ret;\r\nint i;\r\nlight->glights = glights;\r\nlight->id = id;\r\nreq.id = id;\r\nret = gb_operation_sync(glights->connection,\r\nGB_LIGHTS_TYPE_GET_LIGHT_CONFIG,\r\n&req, sizeof(req), &conf, sizeof(conf));\r\nif (ret < 0)\r\nreturn ret;\r\nif (!conf.channel_count)\r\nreturn -EINVAL;\r\nif (!strlen(conf.name))\r\nreturn -EINVAL;\r\nlight->channels_count = conf.channel_count;\r\nlight->name = kstrndup(conf.name, NAMES_MAX, GFP_KERNEL);\r\nlight->channels = kzalloc(light->channels_count *\r\nsizeof(struct gb_channel), GFP_KERNEL);\r\nif (!light->channels)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < light->channels_count; i++) {\r\nlight->channels[i].id = i;\r\nret = gb_lights_channel_config(light, &light->channels[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_lights_light_register(struct gb_light *light)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < light->channels_count; i++) {\r\nret = gb_lights_channel_register(&light->channels[i]);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&light->channels[i].lock);\r\n}\r\nlight->ready = true;\r\nif (light->has_flash) {\r\nret = gb_lights_light_v4l2_register(light);\r\nif (ret < 0) {\r\nlight->has_flash = false;\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void gb_lights_channel_free(struct gb_channel *channel)\r\n{\r\nkfree(channel->attrs);\r\nkfree(channel->attr_group);\r\nkfree(channel->attr_groups);\r\nkfree(channel->color_name);\r\nkfree(channel->mode_name);\r\nmutex_destroy(&channel->lock);\r\n}\r\nstatic void gb_lights_channel_release(struct gb_channel *channel)\r\n{\r\nchannel->releasing = true;\r\ngb_lights_channel_unregister(channel);\r\ngb_lights_channel_free(channel);\r\n}\r\nstatic void gb_lights_light_release(struct gb_light *light)\r\n{\r\nint i;\r\nint count;\r\nlight->ready = false;\r\ncount = light->channels_count;\r\nif (light->has_flash)\r\ngb_lights_light_v4l2_unregister(light);\r\nfor (i = 0; i < count; i++) {\r\ngb_lights_channel_release(&light->channels[i]);\r\nlight->channels_count--;\r\n}\r\nkfree(light->channels);\r\nkfree(light->name);\r\n}\r\nstatic void gb_lights_release(struct gb_lights *glights)\r\n{\r\nint i;\r\nif (!glights)\r\nreturn;\r\nmutex_lock(&glights->lights_lock);\r\nif (!glights->lights)\r\ngoto free_glights;\r\nfor (i = 0; i < glights->lights_count; i++)\r\ngb_lights_light_release(&glights->lights[i]);\r\nkfree(glights->lights);\r\nfree_glights:\r\nmutex_unlock(&glights->lights_lock);\r\nmutex_destroy(&glights->lights_lock);\r\nkfree(glights);\r\n}\r\nstatic int gb_lights_get_count(struct gb_lights *glights)\r\n{\r\nstruct gb_lights_get_lights_response resp;\r\nint ret;\r\nret = gb_operation_sync(glights->connection, GB_LIGHTS_TYPE_GET_LIGHTS,\r\nNULL, 0, &resp, sizeof(resp));\r\nif (ret < 0)\r\nreturn ret;\r\nif (!resp.lights_count)\r\nreturn -EINVAL;\r\nglights->lights_count = resp.lights_count;\r\nreturn 0;\r\n}\r\nstatic int gb_lights_create_all(struct gb_lights *glights)\r\n{\r\nstruct gb_connection *connection = glights->connection;\r\nint ret;\r\nint i;\r\nmutex_lock(&glights->lights_lock);\r\nret = gb_lights_get_count(glights);\r\nif (ret < 0)\r\ngoto out;\r\nglights->lights = kzalloc(glights->lights_count *\r\nsizeof(struct gb_light), GFP_KERNEL);\r\nif (!glights->lights) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < glights->lights_count; i++) {\r\nret = gb_lights_light_config(glights, i);\r\nif (ret < 0) {\r\ndev_err(&connection->bundle->dev,\r\n"Fail to configure lights device\n");\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&glights->lights_lock);\r\nreturn ret;\r\n}\r\nstatic int gb_lights_register_all(struct gb_lights *glights)\r\n{\r\nstruct gb_connection *connection = glights->connection;\r\nint ret = 0;\r\nint i;\r\nmutex_lock(&glights->lights_lock);\r\nfor (i = 0; i < glights->lights_count; i++) {\r\nret = gb_lights_light_register(&glights->lights[i]);\r\nif (ret < 0) {\r\ndev_err(&connection->bundle->dev,\r\n"Fail to enable lights device\n");\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&glights->lights_lock);\r\nreturn ret;\r\n}\r\nstatic int gb_lights_request_handler(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct device *dev = &connection->bundle->dev;\r\nstruct gb_lights *glights = gb_connection_get_data(connection);\r\nstruct gb_light *light;\r\nstruct gb_message *request;\r\nstruct gb_lights_event_request *payload;\r\nint ret = 0;\r\nu8 light_id;\r\nu8 event;\r\nif (op->type != GB_LIGHTS_TYPE_EVENT) {\r\ndev_err(dev, "Unsupported unsolicited event: %u\n", op->type);\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request;\r\nif (request->payload_size < sizeof(*payload)) {\r\ndev_err(dev, "Wrong event size received (%zu < %zu)\n",\r\nrequest->payload_size, sizeof(*payload));\r\nreturn -EINVAL;\r\n}\r\npayload = request->payload;\r\nlight_id = payload->light_id;\r\nif (light_id >= glights->lights_count ||\r\n!glights->lights[light_id].ready) {\r\ndev_err(dev, "Event received for unconfigured light id: %d\n",\r\nlight_id);\r\nreturn -EINVAL;\r\n}\r\nevent = payload->event;\r\nif (event & GB_LIGHTS_LIGHT_CONFIG) {\r\nlight = &glights->lights[light_id];\r\nmutex_lock(&glights->lights_lock);\r\ngb_lights_light_release(light);\r\nret = gb_lights_light_config(glights, light_id);\r\nif (!ret)\r\nret = gb_lights_light_register(light);\r\nif (ret < 0)\r\ngb_lights_light_release(light);\r\nmutex_unlock(&glights->lights_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int gb_lights_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_connection *connection;\r\nstruct gb_lights *glights;\r\nint ret;\r\nif (bundle->num_cports != 1)\r\nreturn -ENODEV;\r\ncport_desc = &bundle->cport_desc[0];\r\nif (cport_desc->protocol_id != GREYBUS_PROTOCOL_LIGHTS)\r\nreturn -ENODEV;\r\nglights = kzalloc(sizeof(*glights), GFP_KERNEL);\r\nif (!glights)\r\nreturn -ENOMEM;\r\nmutex_init(&glights->lights_lock);\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\ngb_lights_request_handler);\r\nif (IS_ERR(connection)) {\r\nret = PTR_ERR(connection);\r\ngoto out;\r\n}\r\nglights->connection = connection;\r\ngb_connection_set_data(connection, glights);\r\ngreybus_set_drvdata(bundle, glights);\r\nret = gb_connection_enable_tx(connection);\r\nif (ret)\r\ngoto error_connection_destroy;\r\nret = gb_lights_create_all(glights);\r\nif (ret < 0)\r\ngoto error_connection_disable;\r\nret = gb_connection_enable(connection);\r\nif (ret)\r\ngoto error_connection_disable;\r\nret = gb_lights_register_all(glights);\r\nif (ret < 0)\r\ngoto error_connection_disable;\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\nerror_connection_disable:\r\ngb_connection_disable(connection);\r\nerror_connection_destroy:\r\ngb_connection_destroy(connection);\r\nout:\r\ngb_lights_release(glights);\r\nreturn ret;\r\n}\r\nstatic void gb_lights_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_lights *glights = greybus_get_drvdata(bundle);\r\nif (gb_pm_runtime_get_sync(bundle))\r\ngb_pm_runtime_get_noresume(bundle);\r\ngb_connection_disable(glights->connection);\r\ngb_connection_destroy(glights->connection);\r\ngb_lights_release(glights);\r\n}
