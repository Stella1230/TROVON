static inline u8 hdmi_readb(struct inno_hdmi *hdmi, u16 offset)\r\n{\r\nreturn readl_relaxed(hdmi->regs + (offset) * 0x04);\r\n}\r\nstatic inline void hdmi_writeb(struct inno_hdmi *hdmi, u16 offset, u32 val)\r\n{\r\nwritel_relaxed(val, hdmi->regs + (offset) * 0x04);\r\n}\r\nstatic inline void hdmi_modb(struct inno_hdmi *hdmi, u16 offset,\r\nu32 msk, u32 val)\r\n{\r\nu8 temp = hdmi_readb(hdmi, offset) & ~msk;\r\ntemp |= val & msk;\r\nhdmi_writeb(hdmi, offset, temp);\r\n}\r\nstatic void inno_hdmi_i2c_init(struct inno_hdmi *hdmi)\r\n{\r\nint ddc_bus_freq;\r\nddc_bus_freq = (hdmi->tmds_rate >> 2) / HDMI_SCL_RATE;\r\nhdmi_writeb(hdmi, DDC_BUS_FREQ_L, ddc_bus_freq & 0xFF);\r\nhdmi_writeb(hdmi, DDC_BUS_FREQ_H, (ddc_bus_freq >> 8) & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);\r\nhdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);\r\n}\r\nstatic void inno_hdmi_sys_power(struct inno_hdmi *hdmi, bool enable)\r\n{\r\nif (enable)\r\nhdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_ON);\r\nelse\r\nhdmi_modb(hdmi, HDMI_SYS_CTRL, m_POWER, v_PWR_OFF);\r\n}\r\nstatic void inno_hdmi_set_pwr_mode(struct inno_hdmi *hdmi, int mode)\r\n{\r\nswitch (mode) {\r\ncase NORMAL:\r\ninno_hdmi_sys_power(hdmi, false);\r\nhdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS, 0x6f);\r\nhdmi_writeb(hdmi, HDMI_PHY_DRIVER, 0xbb);\r\nhdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);\r\nhdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x14);\r\nhdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x10);\r\nhdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x0f);\r\nhdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x00);\r\nhdmi_writeb(hdmi, HDMI_PHY_SYNC, 0x01);\r\ninno_hdmi_sys_power(hdmi, true);\r\nbreak;\r\ncase LOWER_PWR:\r\ninno_hdmi_sys_power(hdmi, false);\r\nhdmi_writeb(hdmi, HDMI_PHY_DRIVER, 0x00);\r\nhdmi_writeb(hdmi, HDMI_PHY_PRE_EMPHASIS, 0x00);\r\nhdmi_writeb(hdmi, HDMI_PHY_CHG_PWR, 0x00);\r\nhdmi_writeb(hdmi, HDMI_PHY_SYS_CTL, 0x15);\r\nbreak;\r\ndefault:\r\ndev_err(hdmi->dev, "Unknown power mode %d\n", mode);\r\n}\r\n}\r\nstatic void inno_hdmi_reset(struct inno_hdmi *hdmi)\r\n{\r\nu32 val;\r\nu32 msk;\r\nhdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_DIGITAL, v_NOT_RST_DIGITAL);\r\nudelay(100);\r\nhdmi_modb(hdmi, HDMI_SYS_CTRL, m_RST_ANALOG, v_NOT_RST_ANALOG);\r\nudelay(100);\r\nmsk = m_REG_CLK_INV | m_REG_CLK_SOURCE | m_POWER | m_INT_POL;\r\nval = v_REG_CLK_INV | v_REG_CLK_SOURCE_SYS | v_PWR_ON | v_INT_POL_HIGH;\r\nhdmi_modb(hdmi, HDMI_SYS_CTRL, msk, val);\r\ninno_hdmi_set_pwr_mode(hdmi, NORMAL);\r\n}\r\nstatic int inno_hdmi_upload_frame(struct inno_hdmi *hdmi, int setup_rc,\r\nunion hdmi_infoframe *frame, u32 frame_index,\r\nu32 mask, u32 disable, u32 enable)\r\n{\r\nif (mask)\r\nhdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, disable);\r\nhdmi_writeb(hdmi, HDMI_CONTROL_PACKET_BUF_INDEX, frame_index);\r\nif (setup_rc >= 0) {\r\nu8 packed_frame[HDMI_MAXIMUM_INFO_FRAME_SIZE];\r\nssize_t rc, i;\r\nrc = hdmi_infoframe_pack(frame, packed_frame,\r\nsizeof(packed_frame));\r\nif (rc < 0)\r\nreturn rc;\r\nfor (i = 0; i < rc; i++)\r\nhdmi_writeb(hdmi, HDMI_CONTROL_PACKET_ADDR + i,\r\npacked_frame[i]);\r\nif (mask)\r\nhdmi_modb(hdmi, HDMI_PACKET_SEND_AUTO, mask, enable);\r\n}\r\nreturn setup_rc;\r\n}\r\nstatic int inno_hdmi_config_video_vsi(struct inno_hdmi *hdmi,\r\nstruct drm_display_mode *mode)\r\n{\r\nunion hdmi_infoframe frame;\r\nint rc;\r\nrc = drm_hdmi_vendor_infoframe_from_display_mode(&frame.vendor.hdmi,\r\nmode);\r\nreturn inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_VSI,\r\nm_PACKET_VSI_EN, v_PACKET_VSI_EN(0), v_PACKET_VSI_EN(1));\r\n}\r\nstatic int inno_hdmi_config_video_avi(struct inno_hdmi *hdmi,\r\nstruct drm_display_mode *mode)\r\n{\r\nunion hdmi_infoframe frame;\r\nint rc;\r\nrc = drm_hdmi_avi_infoframe_from_display_mode(&frame.avi, mode);\r\nif (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV444)\r\nframe.avi.colorspace = HDMI_COLORSPACE_YUV444;\r\nelse if (hdmi->hdmi_data.enc_out_format == HDMI_COLORSPACE_YUV422)\r\nframe.avi.colorspace = HDMI_COLORSPACE_YUV422;\r\nelse\r\nframe.avi.colorspace = HDMI_COLORSPACE_RGB;\r\nreturn inno_hdmi_upload_frame(hdmi, rc, &frame, INFOFRAME_AVI, 0, 0, 0);\r\n}\r\nstatic int inno_hdmi_config_video_csc(struct inno_hdmi *hdmi)\r\n{\r\nstruct hdmi_data_info *data = &hdmi->hdmi_data;\r\nint c0_c2_change = 0;\r\nint csc_enable = 0;\r\nint csc_mode = 0;\r\nint auto_csc = 0;\r\nint value;\r\nint i;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_CONTRL1, v_DE_EXTERNAL |\r\nv_VIDEO_INPUT_FORMAT(VIDEO_INPUT_SDR_RGB444));\r\nvalue = v_VIDEO_INPUT_BITS(VIDEO_INPUT_8BITS) |\r\nv_VIDEO_OUTPUT_COLOR(0) |\r\nv_VIDEO_INPUT_CSP(0);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_CONTRL2, value);\r\nif (data->enc_in_format == data->enc_out_format) {\r\nif ((data->enc_in_format == HDMI_COLORSPACE_RGB) ||\r\n(data->enc_in_format >= HDMI_COLORSPACE_YUV444)) {\r\nvalue = v_SOF_DISABLE | v_COLOR_DEPTH_NOT_INDICATED(1);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);\r\nhdmi_modb(hdmi, HDMI_VIDEO_CONTRL,\r\nm_VIDEO_AUTO_CSC | m_VIDEO_C0_C2_SWAP,\r\nv_VIDEO_AUTO_CSC(AUTO_CSC_DISABLE) |\r\nv_VIDEO_C0_C2_SWAP(C0_C2_CHANGE_DISABLE));\r\nreturn 0;\r\n}\r\n}\r\nif (data->colorimetry == HDMI_COLORIMETRY_ITU_601) {\r\nif ((data->enc_in_format == HDMI_COLORSPACE_RGB) &&\r\n(data->enc_out_format == HDMI_COLORSPACE_YUV444)) {\r\ncsc_mode = CSC_RGB_0_255_TO_ITU601_16_235_8BIT;\r\nauto_csc = AUTO_CSC_DISABLE;\r\nc0_c2_change = C0_C2_CHANGE_DISABLE;\r\ncsc_enable = v_CSC_ENABLE;\r\n} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&\r\n(data->enc_out_format == HDMI_COLORSPACE_RGB)) {\r\ncsc_mode = CSC_ITU601_16_235_TO_RGB_0_255_8BIT;\r\nauto_csc = AUTO_CSC_ENABLE;\r\nc0_c2_change = C0_C2_CHANGE_DISABLE;\r\ncsc_enable = v_CSC_DISABLE;\r\n}\r\n} else {\r\nif ((data->enc_in_format == HDMI_COLORSPACE_RGB) &&\r\n(data->enc_out_format == HDMI_COLORSPACE_YUV444)) {\r\ncsc_mode = CSC_RGB_0_255_TO_ITU709_16_235_8BIT;\r\nauto_csc = AUTO_CSC_DISABLE;\r\nc0_c2_change = C0_C2_CHANGE_DISABLE;\r\ncsc_enable = v_CSC_ENABLE;\r\n} else if ((data->enc_in_format == HDMI_COLORSPACE_YUV444) &&\r\n(data->enc_out_format == HDMI_COLORSPACE_RGB)) {\r\ncsc_mode = CSC_ITU709_16_235_TO_RGB_0_255_8BIT;\r\nauto_csc = AUTO_CSC_ENABLE;\r\nc0_c2_change = C0_C2_CHANGE_DISABLE;\r\ncsc_enable = v_CSC_DISABLE;\r\n}\r\n}\r\nfor (i = 0; i < 24; i++)\r\nhdmi_writeb(hdmi, HDMI_VIDEO_CSC_COEF + i,\r\ncoeff_csc[csc_mode][i]);\r\nvalue = v_SOF_DISABLE | csc_enable | v_COLOR_DEPTH_NOT_INDICATED(1);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_CONTRL3, value);\r\nhdmi_modb(hdmi, HDMI_VIDEO_CONTRL, m_VIDEO_AUTO_CSC |\r\nm_VIDEO_C0_C2_SWAP, v_VIDEO_AUTO_CSC(auto_csc) |\r\nv_VIDEO_C0_C2_SWAP(c0_c2_change));\r\nreturn 0;\r\n}\r\nstatic int inno_hdmi_config_video_timing(struct inno_hdmi *hdmi,\r\nstruct drm_display_mode *mode)\r\n{\r\nint value;\r\nvalue = v_EXTERANL_VIDEO(1);\r\nvalue |= mode->flags & DRM_MODE_FLAG_PHSYNC ?\r\nv_HSYNC_POLARITY(1) : v_HSYNC_POLARITY(0);\r\nvalue |= mode->flags & DRM_MODE_FLAG_PVSYNC ?\r\nv_VSYNC_POLARITY(1) : v_VSYNC_POLARITY(0);\r\nvalue |= mode->flags & DRM_MODE_FLAG_INTERLACE ?\r\nv_INETLACE(1) : v_INETLACE(0);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_TIMING_CTL, value);\r\nvalue = mode->htotal;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_L, value & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HTOTAL_H, (value >> 8) & 0xFF);\r\nvalue = mode->htotal - mode->hdisplay;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_L, value & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HBLANK_H, (value >> 8) & 0xFF);\r\nvalue = mode->hsync_start - mode->hdisplay;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_L, value & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDELAY_H, (value >> 8) & 0xFF);\r\nvalue = mode->hsync_end - mode->hsync_start;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_L, value & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_HDURATION_H, (value >> 8) & 0xFF);\r\nvalue = mode->vtotal;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_L, value & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_VTOTAL_H, (value >> 8) & 0xFF);\r\nvalue = mode->vtotal - mode->vdisplay;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_VBLANK, value & 0xFF);\r\nvalue = mode->vsync_start - mode->vdisplay;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDELAY, value & 0xFF);\r\nvalue = mode->vsync_end - mode->vsync_start;\r\nhdmi_writeb(hdmi, HDMI_VIDEO_EXT_VDURATION, value & 0xFF);\r\nhdmi_writeb(hdmi, HDMI_PHY_PRE_DIV_RATIO, 0x1e);\r\nhdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_LOW, 0x2c);\r\nhdmi_writeb(hdmi, HDMI_PHY_FEEDBACK_DIV_RATIO_HIGH, 0x01);\r\nreturn 0;\r\n}\r\nstatic int inno_hdmi_setup(struct inno_hdmi *hdmi,\r\nstruct drm_display_mode *mode)\r\n{\r\nhdmi->hdmi_data.vic = drm_match_cea_mode(mode);\r\nhdmi->hdmi_data.enc_in_format = HDMI_COLORSPACE_RGB;\r\nhdmi->hdmi_data.enc_out_format = HDMI_COLORSPACE_RGB;\r\nif ((hdmi->hdmi_data.vic == 6) || (hdmi->hdmi_data.vic == 7) ||\r\n(hdmi->hdmi_data.vic == 21) || (hdmi->hdmi_data.vic == 22) ||\r\n(hdmi->hdmi_data.vic == 2) || (hdmi->hdmi_data.vic == 3) ||\r\n(hdmi->hdmi_data.vic == 17) || (hdmi->hdmi_data.vic == 18))\r\nhdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_601;\r\nelse\r\nhdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_709;\r\nhdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE | m_VIDEO_BLACK,\r\nv_AUDIO_MUTE(1) | v_VIDEO_MUTE(1));\r\nhdmi_writeb(hdmi, HDMI_HDCP_CTRL,\r\nv_HDMI_DVI(hdmi->hdmi_data.sink_is_hdmi));\r\ninno_hdmi_config_video_timing(hdmi, mode);\r\ninno_hdmi_config_video_csc(hdmi);\r\nif (hdmi->hdmi_data.sink_is_hdmi) {\r\ninno_hdmi_config_video_avi(hdmi, mode);\r\ninno_hdmi_config_video_vsi(hdmi, mode);\r\n}\r\nhdmi->tmds_rate = mode->clock * 1000;\r\ninno_hdmi_i2c_init(hdmi);\r\nhdmi_modb(hdmi, HDMI_AV_MUTE, m_AUDIO_MUTE | m_VIDEO_BLACK,\r\nv_AUDIO_MUTE(0) | v_VIDEO_MUTE(0));\r\nreturn 0;\r\n}\r\nstatic void inno_hdmi_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nstruct inno_hdmi *hdmi = to_inno_hdmi(encoder);\r\ninno_hdmi_setup(hdmi, adj_mode);\r\nmemcpy(&hdmi->previous_mode, adj_mode, sizeof(hdmi->previous_mode));\r\n}\r\nstatic void inno_hdmi_encoder_enable(struct drm_encoder *encoder)\r\n{\r\nstruct inno_hdmi *hdmi = to_inno_hdmi(encoder);\r\ninno_hdmi_set_pwr_mode(hdmi, NORMAL);\r\n}\r\nstatic void inno_hdmi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct inno_hdmi *hdmi = to_inno_hdmi(encoder);\r\ninno_hdmi_set_pwr_mode(hdmi, LOWER_PWR);\r\n}\r\nstatic bool inno_hdmi_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adj_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int\r\ninno_hdmi_encoder_atomic_check(struct drm_encoder *encoder,\r\nstruct drm_crtc_state *crtc_state,\r\nstruct drm_connector_state *conn_state)\r\n{\r\nstruct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);\r\ns->output_mode = ROCKCHIP_OUT_MODE_P888;\r\ns->output_type = DRM_MODE_CONNECTOR_HDMIA;\r\nreturn 0;\r\n}\r\nstatic enum drm_connector_status\r\ninno_hdmi_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct inno_hdmi *hdmi = to_inno_hdmi(connector);\r\nreturn (hdmi_readb(hdmi, HDMI_STATUS) & m_HOTPLUG) ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic int inno_hdmi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct inno_hdmi *hdmi = to_inno_hdmi(connector);\r\nstruct edid *edid;\r\nint ret = 0;\r\nif (!hdmi->ddc)\r\nreturn 0;\r\nedid = drm_get_edid(connector, hdmi->ddc);\r\nif (edid) {\r\nhdmi->hdmi_data.sink_is_hdmi = drm_detect_hdmi_monitor(edid);\r\nhdmi->hdmi_data.sink_has_audio = drm_detect_monitor_audio(edid);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic enum drm_mode_status\r\ninno_hdmi_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic int\r\ninno_hdmi_probe_single_connector_modes(struct drm_connector *connector,\r\nuint32_t maxX, uint32_t maxY)\r\n{\r\nreturn drm_helper_probe_single_connector_modes(connector, 1920, 1080);\r\n}\r\nstatic void inno_hdmi_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int inno_hdmi_register(struct drm_device *drm, struct inno_hdmi *hdmi)\r\n{\r\nstruct drm_encoder *encoder = &hdmi->encoder;\r\nstruct device *dev = hdmi->dev;\r\nencoder->possible_crtcs = drm_of_find_possible_crtcs(drm, dev->of_node);\r\nif (encoder->possible_crtcs == 0)\r\nreturn -EPROBE_DEFER;\r\ndrm_encoder_helper_add(encoder, &inno_hdmi_encoder_helper_funcs);\r\ndrm_encoder_init(drm, encoder, &inno_hdmi_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS, NULL);\r\nhdmi->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_connector_helper_add(&hdmi->connector,\r\n&inno_hdmi_connector_helper_funcs);\r\ndrm_connector_init(drm, &hdmi->connector, &inno_hdmi_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\ndrm_mode_connector_attach_encoder(&hdmi->connector, encoder);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t inno_hdmi_i2c_irq(struct inno_hdmi *hdmi)\r\n{\r\nstruct inno_hdmi_i2c *i2c = hdmi->i2c;\r\nu8 stat;\r\nstat = hdmi_readb(hdmi, HDMI_INTERRUPT_STATUS1);\r\nif (!(stat & m_INT_EDID_READY))\r\nreturn IRQ_NONE;\r\nhdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);\r\ncomplete(&i2c->cmp);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t inno_hdmi_hardirq(int irq, void *dev_id)\r\n{\r\nstruct inno_hdmi *hdmi = dev_id;\r\nirqreturn_t ret = IRQ_NONE;\r\nu8 interrupt;\r\nif (hdmi->i2c)\r\nret = inno_hdmi_i2c_irq(hdmi);\r\ninterrupt = hdmi_readb(hdmi, HDMI_STATUS);\r\nif (interrupt & m_INT_HOTPLUG) {\r\nhdmi_modb(hdmi, HDMI_STATUS, m_INT_HOTPLUG, m_INT_HOTPLUG);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t inno_hdmi_irq(int irq, void *dev_id)\r\n{\r\nstruct inno_hdmi *hdmi = dev_id;\r\ndrm_helper_hpd_irq_event(hdmi->connector.dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int inno_hdmi_i2c_read(struct inno_hdmi *hdmi, struct i2c_msg *msgs)\r\n{\r\nint length = msgs->len;\r\nu8 *buf = msgs->buf;\r\nint ret;\r\nret = wait_for_completion_timeout(&hdmi->i2c->cmp, HZ / 10);\r\nif (!ret)\r\nreturn -EAGAIN;\r\nwhile (length--)\r\n*buf++ = hdmi_readb(hdmi, HDMI_EDID_FIFO_ADDR);\r\nreturn 0;\r\n}\r\nstatic int inno_hdmi_i2c_write(struct inno_hdmi *hdmi, struct i2c_msg *msgs)\r\n{\r\nif ((msgs->len != 1) ||\r\n((msgs->addr != DDC_ADDR) && (msgs->addr != DDC_SEGMENT_ADDR)))\r\nreturn -EINVAL;\r\nreinit_completion(&hdmi->i2c->cmp);\r\nif (msgs->addr == DDC_SEGMENT_ADDR)\r\nhdmi->i2c->segment_addr = msgs->buf[0];\r\nif (msgs->addr == DDC_ADDR)\r\nhdmi->i2c->ddc_addr = msgs->buf[0];\r\nhdmi_writeb(hdmi, HDMI_EDID_FIFO_OFFSET, 0x00);\r\nhdmi_writeb(hdmi, HDMI_EDID_WORD_ADDR, hdmi->i2c->ddc_addr);\r\nhdmi_writeb(hdmi, HDMI_EDID_SEGMENT_POINTER, hdmi->i2c->segment_addr);\r\nreturn 0;\r\n}\r\nstatic int inno_hdmi_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct inno_hdmi *hdmi = i2c_get_adapdata(adap);\r\nstruct inno_hdmi_i2c *i2c = hdmi->i2c;\r\nint i, ret = 0;\r\nmutex_lock(&i2c->lock);\r\nhdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, m_INT_EDID_READY);\r\nhdmi_writeb(hdmi, HDMI_INTERRUPT_STATUS1, m_INT_EDID_READY);\r\nfor (i = 0; i < num; i++) {\r\ndev_dbg(hdmi->dev, "xfer: num: %d/%d, len: %d, flags: %#x\n",\r\ni + 1, num, msgs[i].len, msgs[i].flags);\r\nif (msgs[i].flags & I2C_M_RD)\r\nret = inno_hdmi_i2c_read(hdmi, &msgs[i]);\r\nelse\r\nret = inno_hdmi_i2c_write(hdmi, &msgs[i]);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (!ret)\r\nret = num;\r\nhdmi_writeb(hdmi, HDMI_INTERRUPT_MASK1, 0);\r\nmutex_unlock(&i2c->lock);\r\nreturn ret;\r\n}\r\nstatic u32 inno_hdmi_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic struct i2c_adapter *inno_hdmi_i2c_adapter(struct inno_hdmi *hdmi)\r\n{\r\nstruct i2c_adapter *adap;\r\nstruct inno_hdmi_i2c *i2c;\r\nint ret;\r\ni2c = devm_kzalloc(hdmi->dev, sizeof(*i2c), GFP_KERNEL);\r\nif (!i2c)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&i2c->lock);\r\ninit_completion(&i2c->cmp);\r\nadap = &i2c->adap;\r\nadap->class = I2C_CLASS_DDC;\r\nadap->owner = THIS_MODULE;\r\nadap->dev.parent = hdmi->dev;\r\nadap->dev.of_node = hdmi->dev->of_node;\r\nadap->algo = &inno_hdmi_algorithm;\r\nstrlcpy(adap->name, "Inno HDMI", sizeof(adap->name));\r\ni2c_set_adapdata(adap, hdmi);\r\nret = i2c_add_adapter(adap);\r\nif (ret) {\r\ndev_warn(hdmi->dev, "cannot add %s I2C adapter\n", adap->name);\r\ndevm_kfree(hdmi->dev, i2c);\r\nreturn ERR_PTR(ret);\r\n}\r\nhdmi->i2c = i2c;\r\ndev_info(hdmi->dev, "registered %s I2C bus driver\n", adap->name);\r\nreturn adap;\r\n}\r\nstatic int inno_hdmi_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct drm_device *drm = data;\r\nstruct inno_hdmi *hdmi;\r\nstruct resource *iores;\r\nint irq;\r\nint ret;\r\nhdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi)\r\nreturn -ENOMEM;\r\nhdmi->dev = dev;\r\nhdmi->drm_dev = drm;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iores)\r\nreturn -ENXIO;\r\nhdmi->regs = devm_ioremap_resource(dev, iores);\r\nif (IS_ERR(hdmi->regs))\r\nreturn PTR_ERR(hdmi->regs);\r\nhdmi->pclk = devm_clk_get(hdmi->dev, "pclk");\r\nif (IS_ERR(hdmi->pclk)) {\r\ndev_err(hdmi->dev, "Unable to get HDMI pclk clk\n");\r\nreturn PTR_ERR(hdmi->pclk);\r\n}\r\nret = clk_prepare_enable(hdmi->pclk);\r\nif (ret) {\r\ndev_err(hdmi->dev, "Cannot enable HDMI pclk clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ninno_hdmi_reset(hdmi);\r\nhdmi->ddc = inno_hdmi_i2c_adapter(hdmi);\r\nif (IS_ERR(hdmi->ddc)) {\r\nret = PTR_ERR(hdmi->ddc);\r\nhdmi->ddc = NULL;\r\nreturn ret;\r\n}\r\nhdmi->tmds_rate = clk_get_rate(hdmi->pclk);\r\ninno_hdmi_i2c_init(hdmi);\r\nret = inno_hdmi_register(drm, hdmi);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(dev, hdmi);\r\nhdmi_modb(hdmi, HDMI_STATUS, m_MASK_INT_HOTPLUG, v_MASK_INT_HOTPLUG(1));\r\nret = devm_request_threaded_irq(dev, irq, inno_hdmi_hardirq,\r\ninno_hdmi_irq, IRQF_SHARED,\r\ndev_name(dev), hdmi);\r\nreturn ret;\r\n}\r\nstatic void inno_hdmi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct inno_hdmi *hdmi = dev_get_drvdata(dev);\r\nhdmi->connector.funcs->destroy(&hdmi->connector);\r\nhdmi->encoder.funcs->destroy(&hdmi->encoder);\r\nclk_disable_unprepare(hdmi->pclk);\r\ni2c_put_adapter(hdmi->ddc);\r\n}\r\nstatic int inno_hdmi_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &inno_hdmi_ops);\r\n}\r\nstatic int inno_hdmi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &inno_hdmi_ops);\r\nreturn 0;\r\n}
