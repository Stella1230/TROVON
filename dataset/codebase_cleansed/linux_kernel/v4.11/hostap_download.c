static int prism2_enable_aux_port(struct net_device *dev, int enable)\r\n{\r\nu16 val, reg;\r\nint i, tries;\r\nunsigned long flags;\r\nstruct hostap_interface *iface;\r\nlocal_info_t *local;\r\niface = netdev_priv(dev);\r\nlocal = iface->local;\r\nif (local->no_pri) {\r\nif (enable) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: no PRI f/w - assuming Aux "\r\n"port is already enabled\n", dev->name);\r\n}\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&local->cmdlock, flags);\r\ntries = HFA384X_CMD_BUSY_TIMEOUT;\r\nwhile (HFA384X_INW(HFA384X_CMD_OFF) & HFA384X_CMD_BUSY && tries > 0) {\r\ntries--;\r\nudelay(1);\r\n}\r\nif (tries == 0) {\r\nreg = HFA384X_INW(HFA384X_CMD_OFF);\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\nprintk("%s: prism2_enable_aux_port - timeout - reg=0x%04x\n",\r\ndev->name, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nval = HFA384X_INW(HFA384X_CONTROL_OFF);\r\nif (enable) {\r\nHFA384X_OUTW(HFA384X_AUX_MAGIC0, HFA384X_PARAM0_OFF);\r\nHFA384X_OUTW(HFA384X_AUX_MAGIC1, HFA384X_PARAM1_OFF);\r\nHFA384X_OUTW(HFA384X_AUX_MAGIC2, HFA384X_PARAM2_OFF);\r\nif ((val & HFA384X_AUX_PORT_MASK) != HFA384X_AUX_PORT_DISABLED)\r\nprintk("prism2_enable_aux_port: was not disabled!?\n");\r\nval &= ~HFA384X_AUX_PORT_MASK;\r\nval |= HFA384X_AUX_PORT_ENABLE;\r\n} else {\r\nHFA384X_OUTW(0, HFA384X_PARAM0_OFF);\r\nHFA384X_OUTW(0, HFA384X_PARAM1_OFF);\r\nHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\r\nif ((val & HFA384X_AUX_PORT_MASK) != HFA384X_AUX_PORT_ENABLED)\r\nprintk("prism2_enable_aux_port: was not enabled!?\n");\r\nval &= ~HFA384X_AUX_PORT_MASK;\r\nval |= HFA384X_AUX_PORT_DISABLE;\r\n}\r\nHFA384X_OUTW(val, HFA384X_CONTROL_OFF);\r\nudelay(5);\r\ni = 10000;\r\nwhile (i > 0) {\r\nval = HFA384X_INW(HFA384X_CONTROL_OFF);\r\nval &= HFA384X_AUX_PORT_MASK;\r\nif ((enable && val == HFA384X_AUX_PORT_ENABLED) ||\r\n(!enable && val == HFA384X_AUX_PORT_DISABLED))\r\nbreak;\r\nudelay(10);\r\ni--;\r\n}\r\nspin_unlock_irqrestore(&local->cmdlock, flags);\r\nif (i == 0) {\r\nprintk("prism2_enable_aux_port(%d) timed out\n",\r\nenable);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hfa384x_from_aux(struct net_device *dev, unsigned int addr, int len,\r\nvoid *buf)\r\n{\r\nu16 page, offset;\r\nif (addr & 1 || len & 1)\r\nreturn -1;\r\npage = addr >> 7;\r\noffset = addr & 0x7f;\r\nHFA384X_OUTW(page, HFA384X_AUXPAGE_OFF);\r\nHFA384X_OUTW(offset, HFA384X_AUXOFFSET_OFF);\r\nudelay(5);\r\n#ifdef PRISM2_PCI\r\n{\r\n__le16 *pos = (__le16 *) buf;\r\nwhile (len > 0) {\r\n*pos++ = HFA384X_INW_DATA(HFA384X_AUXDATA_OFF);\r\nlen -= 2;\r\n}\r\n}\r\n#else\r\nHFA384X_INSW(HFA384X_AUXDATA_OFF, buf, len / 2);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int hfa384x_to_aux(struct net_device *dev, unsigned int addr, int len,\r\nvoid *buf)\r\n{\r\nu16 page, offset;\r\nif (addr & 1 || len & 1)\r\nreturn -1;\r\npage = addr >> 7;\r\noffset = addr & 0x7f;\r\nHFA384X_OUTW(page, HFA384X_AUXPAGE_OFF);\r\nHFA384X_OUTW(offset, HFA384X_AUXOFFSET_OFF);\r\nudelay(5);\r\n#ifdef PRISM2_PCI\r\n{\r\n__le16 *pos = (__le16 *) buf;\r\nwhile (len > 0) {\r\nHFA384X_OUTW_DATA(*pos++, HFA384X_AUXDATA_OFF);\r\nlen -= 2;\r\n}\r\n}\r\n#else\r\nHFA384X_OUTSW(HFA384X_AUXDATA_OFF, buf, len / 2);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int prism2_pda_ok(u8 *buf)\r\n{\r\n__le16 *pda = (__le16 *) buf;\r\nint pos;\r\nu16 len, pdr;\r\nif (buf[0] == 0xff && buf[1] == 0x00 && buf[2] == 0xff &&\r\nbuf[3] == 0x00)\r\nreturn 0;\r\npos = 0;\r\nwhile (pos + 1 < PRISM2_PDA_SIZE / 2) {\r\nlen = le16_to_cpu(pda[pos]);\r\npdr = le16_to_cpu(pda[pos + 1]);\r\nif (len == 0 || pos + len > PRISM2_PDA_SIZE / 2)\r\nreturn 0;\r\nif (pdr == 0x0000 && len == 2) {\r\nreturn 1;\r\n}\r\npos += len + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int prism2_download_aux_dump_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct prism2_download_aux_dump *ctx = m->private;\r\nhfa384x_from_aux(ctx->local->dev, (unsigned long)v - 1, 0x80, ctx->page);\r\nseq_write(m, ctx->page, 0x80);\r\nreturn 0;\r\n}\r\nstatic void *prism2_download_aux_dump_proc_start(struct seq_file *m, loff_t *_pos)\r\n{\r\nstruct prism2_download_aux_dump *ctx = m->private;\r\nprism2_enable_aux_port(ctx->local->dev, 1);\r\nif (*_pos >= prism2_download_aux_dump_npages)\r\nreturn NULL;\r\nreturn (void *)((unsigned long)*_pos + 1);\r\n}\r\nstatic void *prism2_download_aux_dump_proc_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\n++*_pos;\r\nif (*_pos >= prism2_download_aux_dump_npages)\r\nreturn NULL;\r\nreturn (void *)((unsigned long)*_pos + 1);\r\n}\r\nstatic void prism2_download_aux_dump_proc_stop(struct seq_file *m, void *v)\r\n{\r\nstruct prism2_download_aux_dump *ctx = m->private;\r\nprism2_enable_aux_port(ctx->local->dev, 0);\r\n}\r\nstatic int prism2_download_aux_dump_proc_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = seq_open_private(file, &prism2_download_aux_dump_proc_seqops,\r\nsizeof(struct prism2_download_aux_dump));\r\nif (ret == 0) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = PDE_DATA(inode);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 * prism2_read_pda(struct net_device *dev)\r\n{\r\nu8 *buf;\r\nint res, i, found = 0;\r\n#define NUM_PDA_ADDRS 4\r\nunsigned int pda_addr[NUM_PDA_ADDRS] = {\r\n0x7f0000 ,\r\n0x3f0000 ,\r\n0x390000 ,\r\n0x7f0002 ,\r\n};\r\nbuf = kmalloc(PRISM2_PDA_SIZE, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn NULL;\r\nprism2_enable_aux_port(dev, 1);\r\nfor (i = 0; i < NUM_PDA_ADDRS; i++) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: trying to read PDA from 0x%08x",\r\ndev->name, pda_addr[i]);\r\nres = hfa384x_from_aux(dev, pda_addr[i], PRISM2_PDA_SIZE, buf);\r\nif (res)\r\ncontinue;\r\nif (res == 0 && prism2_pda_ok(buf)) {\r\nPDEBUG2(DEBUG_EXTRA2, ": OK\n");\r\nfound = 1;\r\nbreak;\r\n} else {\r\nPDEBUG2(DEBUG_EXTRA2, ": failed\n");\r\n}\r\n}\r\nprism2_enable_aux_port(dev, 0);\r\nif (!found) {\r\nprintk(KERN_DEBUG "%s: valid PDA not found\n", dev->name);\r\nkfree(buf);\r\nbuf = NULL;\r\n}\r\nreturn buf;\r\n}\r\nstatic int prism2_download_volatile(local_info_t *local,\r\nstruct prism2_download_data *param)\r\n{\r\nstruct net_device *dev = local->dev;\r\nint ret = 0, i;\r\nu16 param0, param1;\r\nif (local->hw_downloading) {\r\nprintk(KERN_WARNING "%s: Already downloading - aborting new "\r\n"request\n", dev->name);\r\nreturn -1;\r\n}\r\nlocal->hw_downloading = 1;\r\nif (local->pri_only) {\r\nhfa384x_disable_interrupts(dev);\r\n} else {\r\nprism2_hw_shutdown(dev, 0);\r\nif (prism2_hw_init(dev, 0)) {\r\nprintk(KERN_WARNING "%s: Could not initialize card for"\r\n" download\n", dev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\n}\r\nif (prism2_enable_aux_port(dev, 1)) {\r\nprintk(KERN_WARNING "%s: Could not enable AUX port\n",\r\ndev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\nparam0 = param->start_addr & 0xffff;\r\nparam1 = param->start_addr >> 16;\r\nHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\r\nHFA384X_OUTW(param1, HFA384X_PARAM1_OFF);\r\nif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\r\n(HFA384X_PROGMODE_ENABLE_VOLATILE << 8),\r\nparam0)) {\r\nprintk(KERN_WARNING "%s: Download command execution failed\n",\r\ndev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\nfor (i = 0; i < param->num_areas; i++) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: Writing %d bytes at 0x%08x\n",\r\ndev->name, param->data[i].len, param->data[i].addr);\r\nif (hfa384x_to_aux(dev, param->data[i].addr,\r\nparam->data[i].len, param->data[i].data)) {\r\nprintk(KERN_WARNING "%s: RAM download at 0x%08x "\r\n"(len=%d) failed\n", dev->name,\r\nparam->data[i].addr, param->data[i].len);\r\nret = -1;\r\ngoto out;\r\n}\r\n}\r\nHFA384X_OUTW(param1, HFA384X_PARAM1_OFF);\r\nHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\r\nif (hfa384x_cmd_no_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\r\n(HFA384X_PROGMODE_DISABLE << 8), param0)) {\r\nprintk(KERN_WARNING "%s: Download command execution failed\n",\r\ndev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\nmdelay(5);\r\nHFA384X_OUTW(HFA384X_EV_CMD, HFA384X_EVACK_OFF);\r\nif (prism2_enable_aux_port(dev, 0)) {\r\nprintk(KERN_DEBUG "%s: Disabling AUX port failed\n",\r\ndev->name);\r\n}\r\nmdelay(5);\r\nlocal->hw_downloading = 0;\r\nif (prism2_hw_config(dev, 2)) {\r\nprintk(KERN_WARNING "%s: Card configuration after RAM "\r\n"download failed\n", dev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\nout:\r\nlocal->hw_downloading = 0;\r\nreturn ret;\r\n}\r\nstatic int prism2_enable_genesis(local_info_t *local, int hcr)\r\n{\r\nstruct net_device *dev = local->dev;\r\nu8 initseq[4] = { 0x00, 0xe1, 0xa1, 0xff };\r\nu8 readbuf[4];\r\nprintk(KERN_DEBUG "%s: test Genesis mode with HCR 0x%02x\n",\r\ndev->name, hcr);\r\nlocal->func->cor_sreset(local);\r\nhfa384x_to_aux(dev, 0x7e0038, sizeof(initseq), initseq);\r\nlocal->func->genesis_reset(local, hcr);\r\nhfa384x_from_aux(dev, 0x7e0038, sizeof(readbuf), readbuf);\r\nhfa384x_to_aux(dev, 0x7e0038, sizeof(initseq), initseq);\r\nhfa384x_from_aux(dev, 0x7e0038, sizeof(readbuf), readbuf);\r\nif (memcmp(initseq, readbuf, sizeof(initseq)) == 0) {\r\nprintk(KERN_DEBUG "Readback test succeeded, HCR 0x%02x\n",\r\nhcr);\r\nreturn 0;\r\n} else {\r\nprintk(KERN_DEBUG "Readback test failed, HCR 0x%02x "\r\n"write %02x %02x %02x %02x read %02x %02x %02x %02x\n",\r\nhcr, initseq[0], initseq[1], initseq[2], initseq[3],\r\nreadbuf[0], readbuf[1], readbuf[2], readbuf[3]);\r\nreturn 1;\r\n}\r\n}\r\nstatic int prism2_get_ram_size(local_info_t *local)\r\n{\r\nint ret;\r\nif (prism2_enable_genesis(local, 0x1f) == 0)\r\nret = 8;\r\nelse if (prism2_enable_genesis(local, 0x0f) == 0)\r\nret = 16;\r\nelse\r\nret = -1;\r\nlocal->func->genesis_reset(local, ret == 16 ? 0x07 : 0x17);\r\nreturn ret;\r\n}\r\nstatic int prism2_download_genesis(local_info_t *local,\r\nstruct prism2_download_data *param)\r\n{\r\nstruct net_device *dev = local->dev;\r\nint ram16 = 0, i;\r\nint ret = 0;\r\nif (local->hw_downloading) {\r\nprintk(KERN_WARNING "%s: Already downloading - aborting new "\r\n"request\n", dev->name);\r\nreturn -EBUSY;\r\n}\r\nif (!local->func->genesis_reset || !local->func->cor_sreset) {\r\nprintk(KERN_INFO "%s: Genesis mode downloading not supported "\r\n"with this hwmodel\n", dev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\nlocal->hw_downloading = 1;\r\nif (prism2_enable_aux_port(dev, 1)) {\r\nprintk(KERN_DEBUG "%s: failed to enable AUX port\n",\r\ndev->name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (local->sram_type == -1) {\r\nif (prism2_enable_genesis(local, 0x1f) == 0) {\r\nram16 = 0;\r\nPDEBUG(DEBUG_EXTRA2, "%s: Genesis mode OK using x8 "\r\n"SRAM\n", dev->name);\r\n} else if (prism2_enable_genesis(local, 0x0f) == 0) {\r\nram16 = 1;\r\nPDEBUG(DEBUG_EXTRA2, "%s: Genesis mode OK using x16 "\r\n"SRAM\n", dev->name);\r\n} else {\r\nprintk(KERN_DEBUG "%s: Could not initiate genesis "\r\n"mode\n", dev->name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\n} else {\r\nif (prism2_enable_genesis(local, local->sram_type == 8 ?\r\n0x1f : 0x0f)) {\r\nprintk(KERN_DEBUG "%s: Failed to set Genesis "\r\n"mode (sram_type=%d)\n", dev->name,\r\nlocal->sram_type);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nram16 = local->sram_type != 8;\r\n}\r\nfor (i = 0; i < param->num_areas; i++) {\r\nPDEBUG(DEBUG_EXTRA2, "%s: Writing %d bytes at 0x%08x\n",\r\ndev->name, param->data[i].len, param->data[i].addr);\r\nif (hfa384x_to_aux(dev, param->data[i].addr,\r\nparam->data[i].len, param->data[i].data)) {\r\nprintk(KERN_WARNING "%s: RAM download at 0x%08x "\r\n"(len=%d) failed\n", dev->name,\r\nparam->data[i].addr, param->data[i].len);\r\nret = -EIO;\r\ngoto out;\r\n}\r\n}\r\nPDEBUG(DEBUG_EXTRA2, "Disable genesis mode\n");\r\nlocal->func->genesis_reset(local, ram16 ? 0x07 : 0x17);\r\nif (prism2_enable_aux_port(dev, 0)) {\r\nprintk(KERN_DEBUG "%s: Failed to disable AUX port\n",\r\ndev->name);\r\n}\r\nmdelay(5);\r\nlocal->hw_downloading = 0;\r\nPDEBUG(DEBUG_EXTRA2, "Trying to initialize card\n");\r\nhfa384x_disable_interrupts(dev);\r\nif (prism2_hw_init(dev, 1)) {\r\nprintk(KERN_DEBUG "%s: Initialization after genesis mode "\r\n"download failed\n", dev->name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nPDEBUG(DEBUG_EXTRA2, "Card initialized - running PRI only\n");\r\nif (prism2_hw_init2(dev, 1)) {\r\nprintk(KERN_DEBUG "%s: Initialization(2) after genesis mode "\r\n"download failed\n", dev->name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nout:\r\nlocal->hw_downloading = 0;\r\nreturn ret;\r\n}\r\nstatic inline int prism2_download_block(struct net_device *dev,\r\nu32 addr, u8 *data,\r\nu32 bufaddr, int rest_len)\r\n{\r\nu16 param0, param1;\r\nint block_len;\r\nblock_len = rest_len < 4096 ? rest_len : 4096;\r\nparam0 = addr & 0xffff;\r\nparam1 = addr >> 16;\r\nHFA384X_OUTW(block_len, HFA384X_PARAM2_OFF);\r\nHFA384X_OUTW(param1, HFA384X_PARAM1_OFF);\r\nif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\r\n(HFA384X_PROGMODE_ENABLE_NON_VOLATILE << 8),\r\nparam0)) {\r\nprintk(KERN_WARNING "%s: Flash download command execution "\r\n"failed\n", dev->name);\r\nreturn -1;\r\n}\r\nif (hfa384x_to_aux(dev, bufaddr, block_len, data)) {\r\nprintk(KERN_WARNING "%s: flash download at 0x%08x "\r\n"(len=%d) failed\n", dev->name, addr, block_len);\r\nreturn -1;\r\n}\r\nHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\r\nHFA384X_OUTW(0, HFA384X_PARAM1_OFF);\r\nif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\r\n(HFA384X_PROGMODE_PROGRAM_NON_VOLATILE << 8),\r\n0)) {\r\nprintk(KERN_WARNING "%s: Flash write command execution "\r\n"failed\n", dev->name);\r\nreturn -1;\r\n}\r\nreturn block_len;\r\n}\r\nstatic int prism2_download_nonvolatile(local_info_t *local,\r\nstruct prism2_download_data *dl)\r\n{\r\nstruct net_device *dev = local->dev;\r\nint ret = 0, i;\r\nstruct {\r\n__le16 page;\r\n__le16 offset;\r\n__le16 len;\r\n} dlbuffer;\r\nu32 bufaddr;\r\nif (local->hw_downloading) {\r\nprintk(KERN_WARNING "%s: Already downloading - aborting new "\r\n"request\n", dev->name);\r\nreturn -1;\r\n}\r\nret = local->func->get_rid(dev, HFA384X_RID_DOWNLOADBUFFER,\r\n&dlbuffer, 6, 0);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "%s: Could not read download buffer "\r\n"parameters\n", dev->name);\r\ngoto out;\r\n}\r\nprintk(KERN_DEBUG "Download buffer: %d bytes at 0x%04x:0x%04x\n",\r\nle16_to_cpu(dlbuffer.len),\r\nle16_to_cpu(dlbuffer.page),\r\nle16_to_cpu(dlbuffer.offset));\r\nbufaddr = (le16_to_cpu(dlbuffer.page) << 7) + le16_to_cpu(dlbuffer.offset);\r\nlocal->hw_downloading = 1;\r\nif (!local->pri_only) {\r\nprism2_hw_shutdown(dev, 0);\r\nif (prism2_hw_init(dev, 0)) {\r\nprintk(KERN_WARNING "%s: Could not initialize card for"\r\n" download\n", dev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\n}\r\nhfa384x_disable_interrupts(dev);\r\nif (prism2_enable_aux_port(dev, 1)) {\r\nprintk(KERN_WARNING "%s: Could not enable AUX port\n",\r\ndev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\nprintk(KERN_DEBUG "%s: starting flash download\n", dev->name);\r\nfor (i = 0; i < dl->num_areas; i++) {\r\nint rest_len = dl->data[i].len;\r\nint data_off = 0;\r\nwhile (rest_len > 0) {\r\nint block_len;\r\nblock_len = prism2_download_block(\r\ndev, dl->data[i].addr + data_off,\r\ndl->data[i].data + data_off, bufaddr,\r\nrest_len);\r\nif (block_len < 0) {\r\nret = -1;\r\ngoto out;\r\n}\r\nrest_len -= block_len;\r\ndata_off += block_len;\r\n}\r\n}\r\nHFA384X_OUTW(0, HFA384X_PARAM1_OFF);\r\nHFA384X_OUTW(0, HFA384X_PARAM2_OFF);\r\nif (hfa384x_cmd_wait(dev, HFA384X_CMDCODE_DOWNLOAD |\r\n(HFA384X_PROGMODE_DISABLE << 8), 0)) {\r\nprintk(KERN_WARNING "%s: Download command execution failed\n",\r\ndev->name);\r\nret = -1;\r\ngoto out;\r\n}\r\nif (prism2_enable_aux_port(dev, 0)) {\r\nprintk(KERN_DEBUG "%s: Disabling AUX port failed\n",\r\ndev->name);\r\n}\r\nmdelay(5);\r\nlocal->func->hw_reset(dev);\r\nlocal->hw_downloading = 0;\r\nif (prism2_hw_config(dev, 2)) {\r\nprintk(KERN_WARNING "%s: Card configuration after flash "\r\n"download failed\n", dev->name);\r\nret = -1;\r\n} else {\r\nprintk(KERN_INFO "%s: Card initialized successfully after "\r\n"flash download\n", dev->name);\r\n}\r\nout:\r\nlocal->hw_downloading = 0;\r\nreturn ret;\r\n}\r\nstatic void prism2_download_free_data(struct prism2_download_data *dl)\r\n{\r\nint i;\r\nif (dl == NULL)\r\nreturn;\r\nfor (i = 0; i < dl->num_areas; i++)\r\nkfree(dl->data[i].data);\r\nkfree(dl);\r\n}\r\nstatic int prism2_download(local_info_t *local,\r\nstruct prism2_download_param *param)\r\n{\r\nint ret = 0;\r\nint i;\r\nu32 total_len = 0;\r\nstruct prism2_download_data *dl = NULL;\r\nprintk(KERN_DEBUG "prism2_download: dl_cmd=%d start_addr=0x%08x "\r\n"num_areas=%d\n",\r\nparam->dl_cmd, param->start_addr, param->num_areas);\r\nif (param->num_areas > 100) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndl = kzalloc(sizeof(*dl) + param->num_areas *\r\nsizeof(struct prism2_download_data_area), GFP_KERNEL);\r\nif (dl == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndl->dl_cmd = param->dl_cmd;\r\ndl->start_addr = param->start_addr;\r\ndl->num_areas = param->num_areas;\r\nfor (i = 0; i < param->num_areas; i++) {\r\nPDEBUG(DEBUG_EXTRA2,\r\n" area %d: addr=0x%08x len=%d ptr=0x%p\n",\r\ni, param->data[i].addr, param->data[i].len,\r\nparam->data[i].ptr);\r\ndl->data[i].addr = param->data[i].addr;\r\ndl->data[i].len = param->data[i].len;\r\ntotal_len += param->data[i].len;\r\nif (param->data[i].len > PRISM2_MAX_DOWNLOAD_AREA_LEN ||\r\ntotal_len > PRISM2_MAX_DOWNLOAD_LEN) {\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\ndl->data[i].data = kmalloc(dl->data[i].len, GFP_KERNEL);\r\nif (dl->data[i].data == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(dl->data[i].data, param->data[i].ptr,\r\nparam->data[i].len)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nswitch (param->dl_cmd) {\r\ncase PRISM2_DOWNLOAD_VOLATILE:\r\ncase PRISM2_DOWNLOAD_VOLATILE_PERSISTENT:\r\nret = prism2_download_volatile(local, dl);\r\nbreak;\r\ncase PRISM2_DOWNLOAD_VOLATILE_GENESIS:\r\ncase PRISM2_DOWNLOAD_VOLATILE_GENESIS_PERSISTENT:\r\nret = prism2_download_genesis(local, dl);\r\nbreak;\r\ncase PRISM2_DOWNLOAD_NON_VOLATILE:\r\n#ifdef PRISM2_NON_VOLATILE_DOWNLOAD\r\nret = prism2_download_nonvolatile(local, dl);\r\n#else\r\nprintk(KERN_INFO "%s: non-volatile downloading not enabled\n",\r\nlocal->dev->name);\r\nret = -EOPNOTSUPP;\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "%s: unsupported download command %d\n",\r\nlocal->dev->name, param->dl_cmd);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nif (ret == 0 && dl &&\r\nparam->dl_cmd == PRISM2_DOWNLOAD_VOLATILE_GENESIS_PERSISTENT) {\r\nprism2_download_free_data(local->dl_pri);\r\nlocal->dl_pri = dl;\r\n} else if (ret == 0 && dl &&\r\nparam->dl_cmd == PRISM2_DOWNLOAD_VOLATILE_PERSISTENT) {\r\nprism2_download_free_data(local->dl_sec);\r\nlocal->dl_sec = dl;\r\n} else\r\nprism2_download_free_data(dl);\r\nreturn ret;\r\n}
