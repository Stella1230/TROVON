int\r\nxfs_qm_scall_quotaoff(\r\nxfs_mount_t *mp,\r\nuint flags)\r\n{\r\nstruct xfs_quotainfo *q = mp->m_quotainfo;\r\nuint dqtype;\r\nint error;\r\nuint inactivate_flags;\r\nxfs_qoff_logitem_t *qoffstart;\r\nif ((mp->m_qflags & flags) == 0)\r\nreturn -EEXIST;\r\nerror = 0;\r\nflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\r\nASSERT(q);\r\nmutex_lock(&q->qi_quotaofflock);\r\nif ((flags & XFS_ALL_QUOTA_ACCT) == 0) {\r\nmp->m_qflags &= ~(flags);\r\nspin_lock(&mp->m_sb_lock);\r\nmp->m_sb.sb_qflags = mp->m_qflags;\r\nspin_unlock(&mp->m_sb_lock);\r\nmutex_unlock(&q->qi_quotaofflock);\r\nreturn xfs_sync_sb(mp, false);\r\n}\r\ndqtype = 0;\r\ninactivate_flags = 0;\r\nif (flags & XFS_UQUOTA_ACCT) {\r\ndqtype |= XFS_QMOPT_UQUOTA;\r\nflags |= (XFS_UQUOTA_CHKD | XFS_UQUOTA_ENFD);\r\ninactivate_flags |= XFS_UQUOTA_ACTIVE;\r\n}\r\nif (flags & XFS_GQUOTA_ACCT) {\r\ndqtype |= XFS_QMOPT_GQUOTA;\r\nflags |= (XFS_GQUOTA_CHKD | XFS_GQUOTA_ENFD);\r\ninactivate_flags |= XFS_GQUOTA_ACTIVE;\r\n}\r\nif (flags & XFS_PQUOTA_ACCT) {\r\ndqtype |= XFS_QMOPT_PQUOTA;\r\nflags |= (XFS_PQUOTA_CHKD | XFS_PQUOTA_ENFD);\r\ninactivate_flags |= XFS_PQUOTA_ACTIVE;\r\n}\r\nif ((mp->m_qflags & flags) == 0)\r\ngoto out_unlock;\r\nerror = xfs_qm_log_quotaoff(mp, &qoffstart, flags);\r\nif (error)\r\ngoto out_unlock;\r\nmp->m_qflags &= ~inactivate_flags;\r\nxfs_qm_dqrele_all_inodes(mp, flags);\r\nmp->m_qflags &= ~flags;\r\nxfs_qm_dqpurge_all(mp, dqtype);\r\nerror = xfs_qm_log_quotaoff_end(mp, qoffstart, flags);\r\nif (error) {\r\nxfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\r\ngoto out_unlock;\r\n}\r\nif (mp->m_qflags == 0) {\r\nmutex_unlock(&q->qi_quotaofflock);\r\nxfs_qm_destroy_quotainfo(mp);\r\nreturn 0;\r\n}\r\nif ((dqtype & XFS_QMOPT_UQUOTA) && q->qi_uquotaip) {\r\nIRELE(q->qi_uquotaip);\r\nq->qi_uquotaip = NULL;\r\n}\r\nif ((dqtype & XFS_QMOPT_GQUOTA) && q->qi_gquotaip) {\r\nIRELE(q->qi_gquotaip);\r\nq->qi_gquotaip = NULL;\r\n}\r\nif ((dqtype & XFS_QMOPT_PQUOTA) && q->qi_pquotaip) {\r\nIRELE(q->qi_pquotaip);\r\nq->qi_pquotaip = NULL;\r\n}\r\nout_unlock:\r\nmutex_unlock(&q->qi_quotaofflock);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_scall_trunc_qfile(\r\nstruct xfs_mount *mp,\r\nxfs_ino_t ino)\r\n{\r\nstruct xfs_inode *ip;\r\nstruct xfs_trans *tp;\r\nint error;\r\nif (ino == NULLFSINO)\r\nreturn 0;\r\nerror = xfs_iget(mp, NULL, ino, 0, 0, &ip);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(ip, XFS_IOLOCK_EXCL);\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\r\nif (error) {\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\ngoto out_put;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nip->i_d.di_size = 0;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\ngoto out_unlock;\r\n}\r\nASSERT(ip->i_d.di_nextents == 0);\r\nxfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nerror = xfs_trans_commit(tp);\r\nout_unlock:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL | XFS_IOLOCK_EXCL);\r\nout_put:\r\nIRELE(ip);\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_scall_trunc_qfiles(\r\nxfs_mount_t *mp,\r\nuint flags)\r\n{\r\nint error = -EINVAL;\r\nif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\r\n(flags & ~XFS_DQ_ALLTYPES)) {\r\nxfs_debug(mp, "%s: flags=%x m_qflags=%x",\r\n__func__, flags, mp->m_qflags);\r\nreturn -EINVAL;\r\n}\r\nif (flags & XFS_DQ_USER) {\r\nerror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\r\nif (error)\r\nreturn error;\r\n}\r\nif (flags & XFS_DQ_GROUP) {\r\nerror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\r\nif (error)\r\nreturn error;\r\n}\r\nif (flags & XFS_DQ_PROJ)\r\nerror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_scall_quotaon(\r\nxfs_mount_t *mp,\r\nuint flags)\r\n{\r\nint error;\r\nuint qf;\r\nflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\r\nflags &= ~(XFS_ALL_QUOTA_ACCT);\r\nif (flags == 0) {\r\nxfs_debug(mp, "%s: zero flags, m_qflags=%x",\r\n__func__, mp->m_qflags);\r\nreturn -EINVAL;\r\n}\r\nif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\r\n(flags & XFS_UQUOTA_ENFD)) ||\r\n((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\r\n(flags & XFS_GQUOTA_ENFD)) ||\r\n((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\r\n(flags & XFS_PQUOTA_ENFD))) {\r\nxfs_debug(mp,\r\n"%s: Can't enforce without acct, flags=%x sbflags=%x",\r\n__func__, flags, mp->m_sb.sb_qflags);\r\nreturn -EINVAL;\r\n}\r\nif ((mp->m_qflags & flags) == flags)\r\nreturn -EEXIST;\r\nspin_lock(&mp->m_sb_lock);\r\nqf = mp->m_sb.sb_qflags;\r\nmp->m_sb.sb_qflags = qf | flags;\r\nspin_unlock(&mp->m_sb_lock);\r\nif ((qf & flags) == flags)\r\nreturn -EEXIST;\r\nerror = xfs_sync_sb(mp, false);\r\nif (error)\r\nreturn error;\r\nif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\r\n(mp->m_qflags & XFS_UQUOTA_ACCT)) ||\r\n((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\r\n(mp->m_qflags & XFS_PQUOTA_ACCT)) ||\r\n((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\r\n(mp->m_qflags & XFS_GQUOTA_ACCT)))\r\nreturn 0;\r\nif (! XFS_IS_QUOTA_RUNNING(mp))\r\nreturn -ESRCH;\r\nmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\r\nmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\r\nmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\r\nreturn 0;\r\n}\r\nint\r\nxfs_qm_scall_setqlim(\r\nstruct xfs_mount *mp,\r\nxfs_dqid_t id,\r\nuint type,\r\nstruct qc_dqblk *newlim)\r\n{\r\nstruct xfs_quotainfo *q = mp->m_quotainfo;\r\nstruct xfs_disk_dquot *ddq;\r\nstruct xfs_dquot *dqp;\r\nstruct xfs_trans *tp;\r\nstruct xfs_def_quota *defq;\r\nint error;\r\nxfs_qcnt_t hard, soft;\r\nif (newlim->d_fieldmask & ~XFS_QC_MASK)\r\nreturn -EINVAL;\r\nif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\r\nreturn 0;\r\nmutex_lock(&q->qi_quotaofflock);\r\nerror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\r\nif (error) {\r\nASSERT(error != -ENOENT);\r\ngoto out_unlock;\r\n}\r\ndefq = xfs_get_defquota(dqp, q);\r\nxfs_dqunlock(dqp);\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_qm_setqlim, 0, 0, 0, &tp);\r\nif (error)\r\ngoto out_rele;\r\nxfs_dqlock(dqp);\r\nxfs_trans_dqjoin(tp, dqp);\r\nddq = &dqp->q_core;\r\nhard = (newlim->d_fieldmask & QC_SPC_HARD) ?\r\n(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\r\nbe64_to_cpu(ddq->d_blk_hardlimit);\r\nsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\r\n(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\r\nbe64_to_cpu(ddq->d_blk_softlimit);\r\nif (hard == 0 || hard >= soft) {\r\nddq->d_blk_hardlimit = cpu_to_be64(hard);\r\nddq->d_blk_softlimit = cpu_to_be64(soft);\r\nxfs_dquot_set_prealloc_limits(dqp);\r\nif (id == 0) {\r\ndefq->bhardlimit = hard;\r\ndefq->bsoftlimit = soft;\r\n}\r\n} else {\r\nxfs_debug(mp, "blkhard %Ld < blksoft %Ld", hard, soft);\r\n}\r\nhard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\r\n(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\r\nbe64_to_cpu(ddq->d_rtb_hardlimit);\r\nsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\r\n(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\r\nbe64_to_cpu(ddq->d_rtb_softlimit);\r\nif (hard == 0 || hard >= soft) {\r\nddq->d_rtb_hardlimit = cpu_to_be64(hard);\r\nddq->d_rtb_softlimit = cpu_to_be64(soft);\r\nif (id == 0) {\r\ndefq->rtbhardlimit = hard;\r\ndefq->rtbsoftlimit = soft;\r\n}\r\n} else {\r\nxfs_debug(mp, "rtbhard %Ld < rtbsoft %Ld", hard, soft);\r\n}\r\nhard = (newlim->d_fieldmask & QC_INO_HARD) ?\r\n(xfs_qcnt_t) newlim->d_ino_hardlimit :\r\nbe64_to_cpu(ddq->d_ino_hardlimit);\r\nsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\r\n(xfs_qcnt_t) newlim->d_ino_softlimit :\r\nbe64_to_cpu(ddq->d_ino_softlimit);\r\nif (hard == 0 || hard >= soft) {\r\nddq->d_ino_hardlimit = cpu_to_be64(hard);\r\nddq->d_ino_softlimit = cpu_to_be64(soft);\r\nif (id == 0) {\r\ndefq->ihardlimit = hard;\r\ndefq->isoftlimit = soft;\r\n}\r\n} else {\r\nxfs_debug(mp, "ihard %Ld < isoft %Ld", hard, soft);\r\n}\r\nif (newlim->d_fieldmask & QC_SPC_WARNS)\r\nddq->d_bwarns = cpu_to_be16(newlim->d_spc_warns);\r\nif (newlim->d_fieldmask & QC_INO_WARNS)\r\nddq->d_iwarns = cpu_to_be16(newlim->d_ino_warns);\r\nif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\r\nddq->d_rtbwarns = cpu_to_be16(newlim->d_rt_spc_warns);\r\nif (id == 0) {\r\nif (newlim->d_fieldmask & QC_SPC_TIMER) {\r\nq->qi_btimelimit = newlim->d_spc_timer;\r\nddq->d_btimer = cpu_to_be32(newlim->d_spc_timer);\r\n}\r\nif (newlim->d_fieldmask & QC_INO_TIMER) {\r\nq->qi_itimelimit = newlim->d_ino_timer;\r\nddq->d_itimer = cpu_to_be32(newlim->d_ino_timer);\r\n}\r\nif (newlim->d_fieldmask & QC_RT_SPC_TIMER) {\r\nq->qi_rtbtimelimit = newlim->d_rt_spc_timer;\r\nddq->d_rtbtimer = cpu_to_be32(newlim->d_rt_spc_timer);\r\n}\r\nif (newlim->d_fieldmask & QC_SPC_WARNS)\r\nq->qi_bwarnlimit = newlim->d_spc_warns;\r\nif (newlim->d_fieldmask & QC_INO_WARNS)\r\nq->qi_iwarnlimit = newlim->d_ino_warns;\r\nif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\r\nq->qi_rtbwarnlimit = newlim->d_rt_spc_warns;\r\n} else {\r\nxfs_qm_adjust_dqtimers(mp, ddq);\r\n}\r\ndqp->dq_flags |= XFS_DQ_DIRTY;\r\nxfs_trans_log_dquot(tp, dqp);\r\nerror = xfs_trans_commit(tp);\r\nout_rele:\r\nxfs_qm_dqrele(dqp);\r\nout_unlock:\r\nmutex_unlock(&q->qi_quotaofflock);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_qm_log_quotaoff_end(\r\nxfs_mount_t *mp,\r\nxfs_qoff_logitem_t *startqoff,\r\nuint flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_qoff_logitem_t *qoffi;\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_qm_equotaoff, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nqoffi = xfs_trans_get_qoff_item(tp, startqoff,\r\nflags & XFS_ALL_QUOTA_ACCT);\r\nxfs_trans_log_quotaoff_item(tp, qoffi);\r\nxfs_trans_set_sync(tp);\r\nreturn xfs_trans_commit(tp);\r\n}\r\nSTATIC int\r\nxfs_qm_log_quotaoff(\r\nxfs_mount_t *mp,\r\nxfs_qoff_logitem_t **qoffstartp,\r\nuint flags)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_qoff_logitem_t *qoffi;\r\n*qoffstartp = NULL;\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_qm_quotaoff, 0, 0, 0, &tp);\r\nif (error)\r\ngoto out;\r\nqoffi = xfs_trans_get_qoff_item(tp, NULL, flags & XFS_ALL_QUOTA_ACCT);\r\nxfs_trans_log_quotaoff_item(tp, qoffi);\r\nspin_lock(&mp->m_sb_lock);\r\nmp->m_sb.sb_qflags = (mp->m_qflags & ~(flags)) & XFS_MOUNT_QUOTA_ALL;\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_log_sb(tp);\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp);\r\nif (error)\r\ngoto out;\r\n*qoffstartp = qoffi;\r\nout:\r\nreturn error;\r\n}\r\nint\r\nxfs_qm_scall_getquota(\r\nstruct xfs_mount *mp,\r\nxfs_dqid_t *id,\r\nuint type,\r\nstruct qc_dqblk *dst,\r\nuint dqget_flags)\r\n{\r\nstruct xfs_dquot *dqp;\r\nint error;\r\nerror = xfs_qm_dqget(mp, NULL, *id, type, dqget_flags, &dqp);\r\nif (error)\r\nreturn error;\r\nif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\r\nerror = -ENOENT;\r\ngoto out_put;\r\n}\r\n*id = be32_to_cpu(dqp->q_core.d_id);\r\nmemset(dst, 0, sizeof(*dst));\r\ndst->d_spc_hardlimit =\r\nXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));\r\ndst->d_spc_softlimit =\r\nXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));\r\ndst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\r\ndst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\r\ndst->d_space = XFS_FSB_TO_B(mp, dqp->q_res_bcount);\r\ndst->d_ino_count = dqp->q_res_icount;\r\ndst->d_spc_timer = be32_to_cpu(dqp->q_core.d_btimer);\r\ndst->d_ino_timer = be32_to_cpu(dqp->q_core.d_itimer);\r\ndst->d_ino_warns = be16_to_cpu(dqp->q_core.d_iwarns);\r\ndst->d_spc_warns = be16_to_cpu(dqp->q_core.d_bwarns);\r\ndst->d_rt_spc_hardlimit =\r\nXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));\r\ndst->d_rt_spc_softlimit =\r\nXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));\r\ndst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_res_rtbcount);\r\ndst->d_rt_spc_timer = be32_to_cpu(dqp->q_core.d_rtbtimer);\r\ndst->d_rt_spc_warns = be16_to_cpu(dqp->q_core.d_rtbwarns);\r\nif ((!XFS_IS_UQUOTA_ENFORCED(mp) &&\r\ndqp->q_core.d_flags == XFS_DQ_USER) ||\r\n(!XFS_IS_GQUOTA_ENFORCED(mp) &&\r\ndqp->q_core.d_flags == XFS_DQ_GROUP) ||\r\n(!XFS_IS_PQUOTA_ENFORCED(mp) &&\r\ndqp->q_core.d_flags == XFS_DQ_PROJ)) {\r\ndst->d_spc_timer = 0;\r\ndst->d_ino_timer = 0;\r\ndst->d_rt_spc_timer = 0;\r\n}\r\n#ifdef DEBUG\r\nif (((XFS_IS_UQUOTA_ENFORCED(mp) && type == XFS_DQ_USER) ||\r\n(XFS_IS_GQUOTA_ENFORCED(mp) && type == XFS_DQ_GROUP) ||\r\n(XFS_IS_PQUOTA_ENFORCED(mp) && type == XFS_DQ_PROJ)) &&\r\n*id != 0) {\r\nif ((dst->d_space > dst->d_spc_softlimit) &&\r\n(dst->d_spc_softlimit > 0)) {\r\nASSERT(dst->d_spc_timer != 0);\r\n}\r\nif ((dst->d_ino_count > dst->d_ino_softlimit) &&\r\n(dst->d_ino_softlimit > 0)) {\r\nASSERT(dst->d_ino_timer != 0);\r\n}\r\n}\r\n#endif\r\nout_put:\r\nxfs_qm_dqput(dqp);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_dqrele_inode(\r\nstruct xfs_inode *ip,\r\nint flags,\r\nvoid *args)\r\n{\r\nif (ip == ip->i_mount->m_quotainfo->qi_uquotaip ||\r\nip == ip->i_mount->m_quotainfo->qi_gquotaip ||\r\nip == ip->i_mount->m_quotainfo->qi_pquotaip) {\r\nASSERT(ip->i_udquot == NULL);\r\nASSERT(ip->i_gdquot == NULL);\r\nASSERT(ip->i_pdquot == NULL);\r\nreturn 0;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nif ((flags & XFS_UQUOTA_ACCT) && ip->i_udquot) {\r\nxfs_qm_dqrele(ip->i_udquot);\r\nip->i_udquot = NULL;\r\n}\r\nif ((flags & XFS_GQUOTA_ACCT) && ip->i_gdquot) {\r\nxfs_qm_dqrele(ip->i_gdquot);\r\nip->i_gdquot = NULL;\r\n}\r\nif ((flags & XFS_PQUOTA_ACCT) && ip->i_pdquot) {\r\nxfs_qm_dqrele(ip->i_pdquot);\r\nip->i_pdquot = NULL;\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_qm_dqrele_all_inodes(\r\nstruct xfs_mount *mp,\r\nuint flags)\r\n{\r\nASSERT(mp->m_quotainfo);\r\nxfs_inode_ag_iterator(mp, xfs_dqrele_inode, flags, NULL);\r\n}
