static void tea5767_status_dump(struct tea5767_priv *priv,\r\nunsigned char *buffer)\r\n{\r\nunsigned int div, frq;\r\nif (TEA5767_READY_FLAG_MASK & buffer[0])\r\ntuner_info("Ready Flag ON\n");\r\nelse\r\ntuner_info("Ready Flag OFF\n");\r\nif (TEA5767_BAND_LIMIT_MASK & buffer[0])\r\ntuner_info("Tuner at band limit\n");\r\nelse\r\ntuner_info("Tuner not at band limit\n");\r\ndiv = ((buffer[0] & 0x3f) << 8) | buffer[1];\r\nswitch (priv->ctrl.xtal_freq) {\r\ncase TEA5767_HIGH_LO_13MHz:\r\nfrq = (div * 50000 - 700000 - 225000) / 4;\r\nbreak;\r\ncase TEA5767_LOW_LO_13MHz:\r\nfrq = (div * 50000 + 700000 + 225000) / 4;\r\nbreak;\r\ncase TEA5767_LOW_LO_32768:\r\nfrq = (div * 32768 + 700000 + 225000) / 4;\r\nbreak;\r\ncase TEA5767_HIGH_LO_32768:\r\ndefault:\r\nfrq = (div * 32768 - 700000 - 225000) / 4;\r\nbreak;\r\n}\r\nbuffer[0] = (div >> 8) & 0x3f;\r\nbuffer[1] = div & 0xff;\r\ntuner_info("Frequency %d.%03d KHz (divider = 0x%04x)\n",\r\nfrq / 1000, frq % 1000, div);\r\nif (TEA5767_STEREO_MASK & buffer[2])\r\ntuner_info("Stereo\n");\r\nelse\r\ntuner_info("Mono\n");\r\ntuner_info("IF Counter = %d\n", buffer[2] & TEA5767_IF_CNTR_MASK);\r\ntuner_info("ADC Level = %d\n",\r\n(buffer[3] & TEA5767_ADC_LEVEL_MASK) >> 4);\r\ntuner_info("Chip ID = %d\n", (buffer[3] & TEA5767_CHIP_ID_MASK));\r\ntuner_info("Reserved = 0x%02x\n",\r\n(buffer[4] & TEA5767_RESERVED_MASK));\r\n}\r\nstatic int set_radio_freq(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\nunsigned int frq = params->frequency;\r\nunsigned char buffer[5];\r\nunsigned div;\r\nint rc;\r\ntuner_dbg("radio freq = %d.%03d MHz\n", frq/16000,(frq/16)%1000);\r\nbuffer[2] = 0;\r\nif (priv->ctrl.port1)\r\nbuffer[2] |= TEA5767_PORT1_HIGH;\r\nif (params->audmode == V4L2_TUNER_MODE_MONO) {\r\ntuner_dbg("TEA5767 set to mono\n");\r\nbuffer[2] |= TEA5767_MONO;\r\n} else {\r\ntuner_dbg("TEA5767 set to stereo\n");\r\n}\r\nbuffer[3] = 0;\r\nif (priv->ctrl.port2)\r\nbuffer[3] |= TEA5767_PORT2_HIGH;\r\nif (priv->ctrl.high_cut)\r\nbuffer[3] |= TEA5767_HIGH_CUT_CTRL;\r\nif (priv->ctrl.st_noise)\r\nbuffer[3] |= TEA5767_ST_NOISE_CTL;\r\nif (priv->ctrl.soft_mute)\r\nbuffer[3] |= TEA5767_SOFT_MUTE;\r\nif (priv->ctrl.japan_band)\r\nbuffer[3] |= TEA5767_JAPAN_BAND;\r\nbuffer[4] = 0;\r\nif (priv->ctrl.deemph_75)\r\nbuffer[4] |= TEA5767_DEEMPH_75;\r\nif (priv->ctrl.pllref)\r\nbuffer[4] |= TEA5767_PLLREF_ENABLE;\r\nswitch (priv->ctrl.xtal_freq) {\r\ncase TEA5767_HIGH_LO_13MHz:\r\ntuner_dbg("radio HIGH LO inject xtal @ 13 MHz\n");\r\nbuffer[2] |= TEA5767_HIGH_LO_INJECT;\r\ndiv = (frq * (4000 / 16) + 700000 + 225000 + 25000) / 50000;\r\nbreak;\r\ncase TEA5767_LOW_LO_13MHz:\r\ntuner_dbg("radio LOW LO inject xtal @ 13 MHz\n");\r\ndiv = (frq * (4000 / 16) - 700000 - 225000 + 25000) / 50000;\r\nbreak;\r\ncase TEA5767_LOW_LO_32768:\r\ntuner_dbg("radio LOW LO inject xtal @ 32,768 MHz\n");\r\nbuffer[3] |= TEA5767_XTAL_32768;\r\ndiv = ((frq * (4000 / 16) - 700000 - 225000) + 16384) >> 15;\r\nbreak;\r\ncase TEA5767_HIGH_LO_32768:\r\ndefault:\r\ntuner_dbg("radio HIGH LO inject xtal @ 32,768 MHz\n");\r\nbuffer[2] |= TEA5767_HIGH_LO_INJECT;\r\nbuffer[3] |= TEA5767_XTAL_32768;\r\ndiv = ((frq * (4000 / 16) + 700000 + 225000) + 16384) >> 15;\r\nbreak;\r\n}\r\nbuffer[0] = (div >> 8) & 0x3f;\r\nbuffer[1] = div & 0xff;\r\nif (5 != (rc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 5)))\r\ntuner_warn("i2c i/o error: rc == %d (should be 5)\n", rc);\r\nif (debug) {\r\nif (5 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props, buffer, 5)))\r\ntuner_warn("i2c i/o error: rc == %d (should be 5)\n", rc);\r\nelse\r\ntea5767_status_dump(priv, buffer);\r\n}\r\npriv->frequency = frq * 125 / 2;\r\nreturn 0;\r\n}\r\nstatic int tea5767_read_status(struct dvb_frontend *fe, char *buffer)\r\n{\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\nint rc;\r\nmemset(buffer, 0, 5);\r\nif (5 != (rc = tuner_i2c_xfer_recv(&priv->i2c_props, buffer, 5))) {\r\ntuner_warn("i2c i/o error: rc == %d (should be 5)\n", rc);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int tea5767_signal(struct dvb_frontend *fe, const char *buffer)\r\n{\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\nint signal = ((buffer[3] & TEA5767_ADC_LEVEL_MASK) << 8);\r\ntuner_dbg("Signal strength: %d\n", signal);\r\nreturn signal;\r\n}\r\nstatic inline int tea5767_stereo(struct dvb_frontend *fe, const char *buffer)\r\n{\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\nint stereo = buffer[2] & TEA5767_STEREO_MASK;\r\ntuner_dbg("Radio ST GET = %02x\n", stereo);\r\nreturn (stereo ? V4L2_TUNER_SUB_STEREO : 0);\r\n}\r\nstatic int tea5767_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nunsigned char buffer[5];\r\n*status = 0;\r\nif (0 == tea5767_read_status(fe, buffer)) {\r\nif (tea5767_signal(fe, buffer))\r\n*status = TUNER_STATUS_LOCKED;\r\nif (tea5767_stereo(fe, buffer))\r\n*status |= TUNER_STATUS_STEREO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tea5767_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nunsigned char buffer[5];\r\n*strength = 0;\r\nif (0 == tea5767_read_status(fe, buffer))\r\n*strength = tea5767_signal(fe, buffer);\r\nreturn 0;\r\n}\r\nstatic int tea5767_standby(struct dvb_frontend *fe)\r\n{\r\nunsigned char buffer[5];\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\nunsigned div, rc;\r\ndiv = (87500 * 4 + 700 + 225 + 25) / 50;\r\nbuffer[0] = (div >> 8) & 0x3f;\r\nbuffer[1] = div & 0xff;\r\nbuffer[2] = TEA5767_PORT1_HIGH;\r\nbuffer[3] = TEA5767_PORT2_HIGH | TEA5767_HIGH_CUT_CTRL |\r\nTEA5767_ST_NOISE_CTL | TEA5767_JAPAN_BAND | TEA5767_STDBY;\r\nbuffer[4] = 0;\r\nif (5 != (rc = tuner_i2c_xfer_send(&priv->i2c_props, buffer, 5)))\r\ntuner_warn("i2c i/o error: rc == %d (should be 5)\n", rc);\r\nreturn 0;\r\n}\r\nint tea5767_autodetection(struct i2c_adapter* i2c_adap, u8 i2c_addr)\r\n{\r\nstruct tuner_i2c_props i2c = { .adap = i2c_adap, .addr = i2c_addr };\r\nunsigned char buffer[7] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nint rc;\r\nif ((rc = tuner_i2c_xfer_recv(&i2c, buffer, 7))< 5) {\r\npr_warn("It is not a TEA5767. Received %i bytes.\n", rc);\r\nreturn -EINVAL;\r\n}\r\nif (buffer[0] == buffer[1] && buffer[0] == buffer[2] &&\r\nbuffer[0] == buffer[3] && buffer[0] == buffer[4]) {\r\npr_warn("All bytes are equal. It is not a TEA5767\n");\r\nreturn -EINVAL;\r\n}\r\nif (((buffer[3] & 0x0f) != 0x00) || (buffer[4] != 0x00)) {\r\npr_warn("Chip ID is not zero. It is not a TEA5767\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tea5767_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int tea5767_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int tea5767_set_config (struct dvb_frontend *fe, void *priv_cfg)\r\n{\r\nstruct tea5767_priv *priv = fe->tuner_priv;\r\nmemcpy(&priv->ctrl, priv_cfg, sizeof(priv->ctrl));\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tea5767_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter* i2c_adap,\r\nu8 i2c_addr)\r\n{\r\nstruct tea5767_priv *priv = NULL;\r\npriv = kzalloc(sizeof(struct tea5767_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\nfe->tuner_priv = priv;\r\npriv->i2c_props.addr = i2c_addr;\r\npriv->i2c_props.adap = i2c_adap;\r\npriv->i2c_props.name = "tea5767";\r\npriv->ctrl.xtal_freq = TEA5767_HIGH_LO_32768;\r\npriv->ctrl.port1 = 1;\r\npriv->ctrl.port2 = 1;\r\npriv->ctrl.high_cut = 1;\r\npriv->ctrl.st_noise = 1;\r\npriv->ctrl.japan_band = 1;\r\nmemcpy(&fe->ops.tuner_ops, &tea5767_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\ntuner_info("type set to %s\n", "Philips TEA5767HN FM Radio");\r\nreturn fe;\r\n}
