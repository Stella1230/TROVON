static int\r\nlgs8gl5_write_reg(struct lgs8gl5_state *state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = {reg, data};\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: error (reg=0x%02x, val=0x%02x, ret=%i)\n",\r\n__func__, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int\r\nlgs8gl5_read_reg(struct lgs8gl5_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = {reg};\r\nu8 b1[] = {0};\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n},\r\n{\r\n.addr = state->config->demod_address,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nreturn -EIO;\r\nreturn b1[0];\r\n}\r\nstatic int\r\nlgs8gl5_update_reg(struct lgs8gl5_state *state, u8 reg, u8 data)\r\n{\r\nlgs8gl5_read_reg(state, reg);\r\nlgs8gl5_write_reg(state, reg, data);\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_update_alt_reg(struct lgs8gl5_state *state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 b0[] = {reg};\r\nu8 b1[] = {0};\r\nu8 b2[] = {reg, data};\r\nstruct i2c_msg msg[3] = {\r\n{\r\n.addr = state->config->demod_address + 2,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n},\r\n{\r\n.addr = state->config->demod_address + 2,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n},\r\n{\r\n.addr = state->config->demod_address + 2,\r\n.flags = 0,\r\n.buf = b2,\r\n.len = 2\r\n},\r\n};\r\nret = i2c_transfer(state->i2c, msg, 3);\r\nreturn (ret != 3) ? -1 : 0;\r\n}\r\nstatic void\r\nlgs8gl5_soft_reset(struct lgs8gl5_state *state)\r\n{\r\nu8 val;\r\ndprintk("%s\n", __func__);\r\nval = lgs8gl5_read_reg(state, REG_RESET);\r\nlgs8gl5_write_reg(state, REG_RESET, val & ~REG_RESET_OFF);\r\nlgs8gl5_write_reg(state, REG_RESET, val | REG_RESET_OFF);\r\nmsleep(5);\r\n}\r\nstatic void\r\nlgs8gl5_start_demod(struct lgs8gl5_state *state)\r\n{\r\nu8 val;\r\nint n;\r\ndprintk("%s\n", __func__);\r\nlgs8gl5_update_alt_reg(state, 0xc2, 0x28);\r\nlgs8gl5_soft_reset(state);\r\nlgs8gl5_update_reg(state, REG_07, 0x10);\r\nlgs8gl5_update_reg(state, REG_07, 0x10);\r\nlgs8gl5_write_reg(state, REG_09, 0x0e);\r\nlgs8gl5_write_reg(state, REG_0A, 0xe5);\r\nlgs8gl5_write_reg(state, REG_0B, 0x35);\r\nlgs8gl5_write_reg(state, REG_0C, 0x30);\r\nlgs8gl5_update_reg(state, REG_03, 0x00);\r\nlgs8gl5_update_reg(state, REG_7E, 0x01);\r\nlgs8gl5_update_alt_reg(state, 0xc5, 0x00);\r\nlgs8gl5_update_reg(state, REG_04, 0x02);\r\nlgs8gl5_update_reg(state, REG_37, 0x01);\r\nlgs8gl5_soft_reset(state);\r\nfor (n = 0; n < 10; n++) {\r\nval = lgs8gl5_read_reg(state, REG_STRENGTH);\r\ndprintk("Wait for carrier[%d] 0x%02X\n", n, val);\r\nif (val & REG_STRENGTH_CARRIER)\r\nbreak;\r\nmsleep(4);\r\n}\r\nif (!(val & REG_STRENGTH_CARRIER))\r\nreturn;\r\nfor (n = 0; n < 20; n++) {\r\nval = lgs8gl5_read_reg(state, REG_STATUS);\r\ndprintk("Wait for lock[%d] 0x%02X\n", n, val);\r\nif (val & REG_STATUS_LOCK)\r\nbreak;\r\nmsleep(12);\r\n}\r\nif (!(val & REG_STATUS_LOCK))\r\nreturn;\r\nlgs8gl5_write_reg(state, REG_7D, lgs8gl5_read_reg(state, REG_A2));\r\nlgs8gl5_soft_reset(state);\r\n}\r\nstatic int\r\nlgs8gl5_init(struct dvb_frontend *fe)\r\n{\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nlgs8gl5_update_alt_reg(state, 0xc2, 0x28);\r\nlgs8gl5_soft_reset(state);\r\nlgs8gl5_update_reg(state, REG_07, 0x10);\r\nlgs8gl5_update_reg(state, REG_07, 0x10);\r\nlgs8gl5_write_reg(state, REG_09, 0x0e);\r\nlgs8gl5_write_reg(state, REG_0A, 0xe5);\r\nlgs8gl5_write_reg(state, REG_0B, 0x35);\r\nlgs8gl5_write_reg(state, REG_0C, 0x30);\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\nu8 level = lgs8gl5_read_reg(state, REG_STRENGTH);\r\nu8 flags = lgs8gl5_read_reg(state, REG_STATUS);\r\n*status = 0;\r\nif ((level & REG_STRENGTH_MASK) > 0)\r\n*status |= FE_HAS_SIGNAL;\r\nif (level & REG_STRENGTH_CARRIER)\r\n*status |= FE_HAS_CARRIER;\r\nif (flags & REG_STATUS_SYNC)\r\n*status |= FE_HAS_SYNC;\r\nif (flags & REG_STATUS_LOCK)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_read_signal_strength(struct dvb_frontend *fe, u16 *signal_strength)\r\n{\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\nu8 level = lgs8gl5_read_reg(state, REG_STRENGTH);\r\n*signal_strength = (level & REG_STRENGTH_MASK) << 8;\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\nu8 level = lgs8gl5_read_reg(state, REG_STRENGTH);\r\n*snr = (level & REG_STRENGTH_MASK) << 8;\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (p->bandwidth_hz != 8000000)\r\nreturn -EINVAL;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nlgs8gl5_start_demod(state);\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\nu8 inv = lgs8gl5_read_reg(state, REG_INVERSION);\r\np->inversion = (inv & REG_INVERSION_ON) ? INVERSION_ON : INVERSION_OFF;\r\np->code_rate_HP = FEC_1_2;\r\np->code_rate_LP = FEC_7_8;\r\np->guard_interval = GUARD_INTERVAL_1_32;\r\np->transmission_mode = TRANSMISSION_MODE_2K;\r\np->modulation = QAM_64;\r\np->hierarchy = HIERARCHY_NONE;\r\np->bandwidth_hz = 8000000;\r\nreturn 0;\r\n}\r\nstatic int\r\nlgs8gl5_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 240;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nlgs8gl5_release(struct dvb_frontend *fe)\r\n{\r\nstruct lgs8gl5_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend*\r\nlgs8gl5_attach(const struct lgs8gl5_config *config, struct i2c_adapter *i2c)\r\n{\r\nstruct lgs8gl5_state *state = NULL;\r\ndprintk("%s\n", __func__);\r\nstate = kzalloc(sizeof(struct lgs8gl5_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nif (lgs8gl5_read_reg(state, REG_RESET) < 0)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &lgs8gl5_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
