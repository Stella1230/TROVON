static inline struct ths7303_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ths7303_state, sd);\r\n}\r\nstatic int ths7303_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int ths7303_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ths7303_setval(struct v4l2_subdev *sd,\r\nenum ths7303_filter_mode mode)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ths7303_state *state = to_state(sd);\r\nconst struct ths7303_platform_data *pdata = state->pdata;\r\nu8 val, sel = 0;\r\nint err, disable = 0;\r\nif (!client)\r\nreturn -EINVAL;\r\nswitch (mode) {\r\ncase THS7303_FILTER_MODE_1080P:\r\nsel = 0x3;\r\nbreak;\r\ncase THS7303_FILTER_MODE_720P_1080I:\r\nsel = 0x2;\r\nbreak;\r\ncase THS7303_FILTER_MODE_480P_576P:\r\nsel = 0x1;\r\nbreak;\r\ncase THS7303_FILTER_MODE_480I_576I:\r\nsel = 0x0;\r\nbreak;\r\ndefault:\r\ndisable = 1;\r\n}\r\nval = (sel << 6) | (sel << 3);\r\nif (!disable)\r\nval |= (pdata->ch_1 & 0x27);\r\nerr = ths7303_write(sd, THS7303_CHANNEL_1, val);\r\nif (err)\r\ngoto out;\r\nval = (sel << 6) | (sel << 3);\r\nif (!disable)\r\nval |= (pdata->ch_2 & 0x27);\r\nerr = ths7303_write(sd, THS7303_CHANNEL_2, val);\r\nif (err)\r\ngoto out;\r\nval = (sel << 6) | (sel << 3);\r\nif (!disable)\r\nval |= (pdata->ch_3 & 0x27);\r\nerr = ths7303_write(sd, THS7303_CHANNEL_3, val);\r\nif (err)\r\ngoto out;\r\nreturn 0;\r\nout:\r\npr_info("write byte data failed\n");\r\nreturn err;\r\n}\r\nstatic int ths7303_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct ths7303_state *state = to_state(sd);\r\nif (norm & (V4L2_STD_ALL & ~V4L2_STD_SECAM)) {\r\nstate->std_id = 1;\r\nstate->bt.pixelclock = 0;\r\nreturn ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I);\r\n}\r\nreturn ths7303_setval(sd, THS7303_FILTER_MODE_DISABLE);\r\n}\r\nstatic int ths7303_config(struct v4l2_subdev *sd)\r\n{\r\nstruct ths7303_state *state = to_state(sd);\r\nint res;\r\nif (!state->stream_on) {\r\nths7303_write(sd, THS7303_CHANNEL_1,\r\n(ths7303_read(sd, THS7303_CHANNEL_1) & 0xf8) |\r\n0x00);\r\nths7303_write(sd, THS7303_CHANNEL_2,\r\n(ths7303_read(sd, THS7303_CHANNEL_2) & 0xf8) |\r\n0x00);\r\nths7303_write(sd, THS7303_CHANNEL_3,\r\n(ths7303_read(sd, THS7303_CHANNEL_3) & 0xf8) |\r\n0x00);\r\nreturn 0;\r\n}\r\nif (state->bt.pixelclock > 120000000)\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_1080P);\r\nelse if (state->bt.pixelclock > 70000000)\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_720P_1080I);\r\nelse if (state->bt.pixelclock > 20000000)\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_480P_576P);\r\nelse if (state->std_id)\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I);\r\nelse\r\nres = ths7303_setval(sd, THS7303_FILTER_MODE_DISABLE);\r\nreturn res;\r\n}\r\nstatic int ths7303_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct ths7303_state *state = to_state(sd);\r\nstate->stream_on = enable;\r\nreturn ths7303_config(sd);\r\n}\r\nstatic int ths7303_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nstruct ths7303_state *state = to_state(sd);\r\nif (!dv_timings || dv_timings->type != V4L2_DV_BT_656_1120)\r\nreturn -EINVAL;\r\nstate->bt = dv_timings->bt;\r\nstate->std_id = 0;\r\nreturn ths7303_config(sd);\r\n}\r\nstatic int ths7303_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nreg->size = 1;\r\nreg->val = ths7303_read(sd, reg->reg);\r\nreturn 0;\r\n}\r\nstatic int ths7303_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nths7303_write(sd, reg->reg, reg->val);\r\nreturn 0;\r\n}\r\nstatic void ths7303_log_channel_status(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nu8 val = ths7303_read(sd, reg);\r\nif ((val & 0x7) == 0) {\r\nv4l2_info(sd, "Channel %d Off\n", reg);\r\nreturn;\r\n}\r\nv4l2_info(sd, "Channel %d On\n", reg);\r\nv4l2_info(sd, " value 0x%x\n", val);\r\nv4l2_info(sd, " %s\n", stc_lpf_sel_txt[(val >> 6) & 0x3]);\r\nv4l2_info(sd, " %s\n", in_mux_sel_txt[(val >> 5) & 0x1]);\r\nv4l2_info(sd, " %s\n", lpf_freq_sel_txt[(val >> 3) & 0x3]);\r\nv4l2_info(sd, " %s\n", in_bias_sel_dis_cont_txt[(val >> 0) & 0x7]);\r\n}\r\nstatic int ths7303_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct ths7303_state *state = to_state(sd);\r\nv4l2_info(sd, "stream %s\n", state->stream_on ? "On" : "Off");\r\nif (state->bt.pixelclock) {\r\nstruct v4l2_bt_timings *bt = &state->bt;\r\nu32 frame_width, frame_height;\r\nframe_width = V4L2_DV_BT_FRAME_WIDTH(bt);\r\nframe_height = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nv4l2_info(sd,\r\n"timings: %dx%d%s%d (%dx%d). Pix freq. = %d Hz. Polarities = 0x%x\n",\r\nbt->width, bt->height, bt->interlaced ? "i" : "p",\r\n(frame_height * frame_width) > 0 ?\r\n(int)bt->pixelclock /\r\n(frame_height * frame_width) : 0,\r\nframe_width, frame_height,\r\n(int)bt->pixelclock, bt->polarities);\r\n} else {\r\nv4l2_info(sd, "no timings set\n");\r\n}\r\nths7303_log_channel_status(sd, THS7303_CHANNEL_1);\r\nths7303_log_channel_status(sd, THS7303_CHANNEL_2);\r\nths7303_log_channel_status(sd, THS7303_CHANNEL_3);\r\nreturn 0;\r\n}\r\nstatic int ths7303_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ths7303_platform_data *pdata = client->dev.platform_data;\r\nstruct ths7303_state *state;\r\nstruct v4l2_subdev *sd;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nstate = devm_kzalloc(&client->dev, sizeof(struct ths7303_state),\r\nGFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->pdata = pdata;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ths7303_ops);\r\nif (ths7303_setval(sd, THS7303_FILTER_MODE_480I_576I) < 0) {\r\nv4l_err(client, "Setting to 480I_576I filter mode failed!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ths7303_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nreturn 0;\r\n}
