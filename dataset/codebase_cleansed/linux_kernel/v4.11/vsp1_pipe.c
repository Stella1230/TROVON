const struct vsp1_format_info *vsp1_get_format_info(struct vsp1_device *vsp1,\r\nu32 fourcc)\r\n{\r\nunsigned int i;\r\nif (vsp1->info->gen != 2 && fourcc == V4L2_PIX_FMT_VYUY)\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(vsp1_video_formats); ++i) {\r\nconst struct vsp1_format_info *info = &vsp1_video_formats[i];\r\nif (info->fourcc == fourcc)\r\nreturn info;\r\n}\r\nreturn NULL;\r\n}\r\nvoid vsp1_pipeline_reset(struct vsp1_pipeline *pipe)\r\n{\r\nunsigned int i;\r\nif (pipe->bru) {\r\nstruct vsp1_bru *bru = to_bru(&pipe->bru->subdev);\r\nfor (i = 0; i < ARRAY_SIZE(bru->inputs); ++i)\r\nbru->inputs[i].rpf = NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pipe->inputs); ++i) {\r\nif (pipe->inputs[i]) {\r\npipe->inputs[i]->pipe = NULL;\r\npipe->inputs[i] = NULL;\r\n}\r\n}\r\nif (pipe->output) {\r\npipe->output->pipe = NULL;\r\npipe->output = NULL;\r\n}\r\nINIT_LIST_HEAD(&pipe->entities);\r\npipe->state = VSP1_PIPELINE_STOPPED;\r\npipe->buffers_ready = 0;\r\npipe->num_inputs = 0;\r\npipe->bru = NULL;\r\npipe->lif = NULL;\r\npipe->uds = NULL;\r\n}\r\nvoid vsp1_pipeline_init(struct vsp1_pipeline *pipe)\r\n{\r\nmutex_init(&pipe->lock);\r\nspin_lock_init(&pipe->irqlock);\r\ninit_waitqueue_head(&pipe->wq);\r\nkref_init(&pipe->kref);\r\nINIT_LIST_HEAD(&pipe->entities);\r\npipe->state = VSP1_PIPELINE_STOPPED;\r\n}\r\nvoid vsp1_pipeline_run(struct vsp1_pipeline *pipe)\r\n{\r\nstruct vsp1_device *vsp1 = pipe->output->entity.vsp1;\r\nif (pipe->state == VSP1_PIPELINE_STOPPED) {\r\nvsp1_write(vsp1, VI6_CMD(pipe->output->entity.index),\r\nVI6_CMD_STRCMD);\r\npipe->state = VSP1_PIPELINE_RUNNING;\r\n}\r\npipe->buffers_ready = 0;\r\n}\r\nbool vsp1_pipeline_stopped(struct vsp1_pipeline *pipe)\r\n{\r\nunsigned long flags;\r\nbool stopped;\r\nspin_lock_irqsave(&pipe->irqlock, flags);\r\nstopped = pipe->state == VSP1_PIPELINE_STOPPED;\r\nspin_unlock_irqrestore(&pipe->irqlock, flags);\r\nreturn stopped;\r\n}\r\nint vsp1_pipeline_stop(struct vsp1_pipeline *pipe)\r\n{\r\nstruct vsp1_entity *entity;\r\nunsigned long flags;\r\nint ret;\r\nif (pipe->lif) {\r\nret = vsp1_reset_wpf(pipe->output->entity.vsp1,\r\npipe->output->entity.index);\r\nif (ret == 0) {\r\nspin_lock_irqsave(&pipe->irqlock, flags);\r\npipe->state = VSP1_PIPELINE_STOPPED;\r\nspin_unlock_irqrestore(&pipe->irqlock, flags);\r\n}\r\n} else {\r\nspin_lock_irqsave(&pipe->irqlock, flags);\r\nif (pipe->state == VSP1_PIPELINE_RUNNING)\r\npipe->state = VSP1_PIPELINE_STOPPING;\r\nspin_unlock_irqrestore(&pipe->irqlock, flags);\r\nret = wait_event_timeout(pipe->wq, vsp1_pipeline_stopped(pipe),\r\nmsecs_to_jiffies(500));\r\nret = ret == 0 ? -ETIMEDOUT : 0;\r\n}\r\nlist_for_each_entry(entity, &pipe->entities, list_pipe) {\r\nif (entity->route && entity->route->reg)\r\nvsp1_write(entity->vsp1, entity->route->reg,\r\nVI6_DPR_NODE_UNUSED);\r\n}\r\nv4l2_subdev_call(&pipe->output->entity.subdev, video, s_stream, 0);\r\nreturn ret;\r\n}\r\nbool vsp1_pipeline_ready(struct vsp1_pipeline *pipe)\r\n{\r\nunsigned int mask;\r\nmask = ((1 << pipe->num_inputs) - 1) << 1;\r\nif (!pipe->lif)\r\nmask |= 1 << 0;\r\nreturn pipe->buffers_ready == mask;\r\n}\r\nvoid vsp1_pipeline_frame_end(struct vsp1_pipeline *pipe)\r\n{\r\nif (pipe == NULL)\r\nreturn;\r\nvsp1_dlm_irq_frame_end(pipe->output->dlm);\r\nif (pipe->frame_end)\r\npipe->frame_end(pipe);\r\npipe->sequence++;\r\n}\r\nvoid vsp1_pipeline_propagate_alpha(struct vsp1_pipeline *pipe,\r\nstruct vsp1_dl_list *dl, unsigned int alpha)\r\n{\r\nif (!pipe->uds)\r\nreturn;\r\nif (pipe->uds_input->type == VSP1_ENTITY_BRU)\r\nalpha = 255;\r\nvsp1_uds_set_alpha(pipe->uds, dl, alpha);\r\n}\r\nvoid vsp1_pipelines_suspend(struct vsp1_device *vsp1)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf = vsp1->wpf[i];\r\nstruct vsp1_pipeline *pipe;\r\nif (wpf == NULL)\r\ncontinue;\r\npipe = wpf->pipe;\r\nif (pipe == NULL)\r\ncontinue;\r\nspin_lock_irqsave(&pipe->irqlock, flags);\r\nif (pipe->state == VSP1_PIPELINE_RUNNING)\r\npipe->state = VSP1_PIPELINE_STOPPING;\r\nspin_unlock_irqrestore(&pipe->irqlock, flags);\r\n}\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf = vsp1->wpf[i];\r\nstruct vsp1_pipeline *pipe;\r\nif (wpf == NULL)\r\ncontinue;\r\npipe = wpf->pipe;\r\nif (pipe == NULL)\r\ncontinue;\r\nret = wait_event_timeout(pipe->wq, vsp1_pipeline_stopped(pipe),\r\nmsecs_to_jiffies(500));\r\nif (ret == 0)\r\ndev_warn(vsp1->dev, "pipeline %u stop timeout\n",\r\nwpf->entity.index);\r\n}\r\n}\r\nvoid vsp1_pipelines_resume(struct vsp1_device *vsp1)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf = vsp1->wpf[i];\r\nstruct vsp1_pipeline *pipe;\r\nif (wpf == NULL)\r\ncontinue;\r\npipe = wpf->pipe;\r\nif (pipe == NULL)\r\ncontinue;\r\nspin_lock_irqsave(&pipe->irqlock, flags);\r\nif (vsp1_pipeline_ready(pipe))\r\nvsp1_pipeline_run(pipe);\r\nspin_unlock_irqrestore(&pipe->irqlock, flags);\r\n}\r\n}
