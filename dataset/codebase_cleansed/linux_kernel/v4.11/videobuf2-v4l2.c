static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer *b)\r\n{\r\nif (!V4L2_TYPE_IS_MULTIPLANAR(b->type))\r\nreturn 0;\r\nif (b->m.planes == NULL) {\r\ndprintk(1, "multi-planar buffer passed but planes array not provided\n");\r\nreturn -EINVAL;\r\n}\r\nif (b->length < vb->num_planes || b->length > VB2_MAX_PLANES) {\r\ndprintk(1, "incorrect planes array length, expected %d, got %d\n",\r\nvb->num_planes, b->length);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)\r\n{\r\nreturn __verify_planes_array(vb, pb);\r\n}\r\nstatic int __verify_length(struct vb2_buffer *vb, const struct v4l2_buffer *b)\r\n{\r\nunsigned int length;\r\nunsigned int bytesused;\r\nunsigned int plane;\r\nif (!V4L2_TYPE_IS_OUTPUT(b->type))\r\nreturn 0;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(b->type)) {\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nlength = (b->memory == VB2_MEMORY_USERPTR ||\r\nb->memory == VB2_MEMORY_DMABUF)\r\n? b->m.planes[plane].length\r\n: vb->planes[plane].length;\r\nbytesused = b->m.planes[plane].bytesused\r\n? b->m.planes[plane].bytesused : length;\r\nif (b->m.planes[plane].bytesused > length)\r\nreturn -EINVAL;\r\nif (b->m.planes[plane].data_offset > 0 &&\r\nb->m.planes[plane].data_offset >= bytesused)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nlength = (b->memory == VB2_MEMORY_USERPTR)\r\n? b->length : vb->planes[0].length;\r\nif (b->bytesused > length)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __copy_timestamp(struct vb2_buffer *vb, const void *pb)\r\n{\r\nconst struct v4l2_buffer *b = pb;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nif (q->is_output) {\r\nif (q->copy_timestamp)\r\nvb->timestamp = timeval_to_ns(&b->timestamp);\r\nvbuf->flags |= b->flags & V4L2_BUF_FLAG_TIMECODE;\r\nif (b->flags & V4L2_BUF_FLAG_TIMECODE)\r\nvbuf->timecode = b->timecode;\r\n}\r\n}\r\nstatic void vb2_warn_zero_bytesused(struct vb2_buffer *vb)\r\n{\r\nstatic bool check_once;\r\nif (check_once)\r\nreturn;\r\ncheck_once = true;\r\nWARN_ON(1);\r\npr_warn("use of bytesused == 0 is deprecated and will be removed in the future,\n");\r\nif (vb->vb2_queue->allow_zero_bytesused)\r\npr_warn("use VIDIOC_DECODER_CMD(V4L2_DEC_CMD_STOP) instead.\n");\r\nelse\r\npr_warn("use the actual size instead.\n");\r\n}\r\nstatic int vb2_queue_or_prepare_buf(struct vb2_queue *q, struct v4l2_buffer *b,\r\nconst char *opname)\r\n{\r\nif (b->type != q->type) {\r\ndprintk(1, "%s: invalid buffer type\n", opname);\r\nreturn -EINVAL;\r\n}\r\nif (b->index >= q->num_buffers) {\r\ndprintk(1, "%s: buffer index out of range\n", opname);\r\nreturn -EINVAL;\r\n}\r\nif (q->bufs[b->index] == NULL) {\r\ndprintk(1, "%s: buffer is NULL\n", opname);\r\nreturn -EINVAL;\r\n}\r\nif (b->memory != q->memory) {\r\ndprintk(1, "%s: invalid memory type\n", opname);\r\nreturn -EINVAL;\r\n}\r\nreturn __verify_planes_array(q->bufs[b->index], b);\r\n}\r\nstatic void __fill_v4l2_buffer(struct vb2_buffer *vb, void *pb)\r\n{\r\nstruct v4l2_buffer *b = pb;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned int plane;\r\nb->index = vb->index;\r\nb->type = vb->type;\r\nb->memory = vb->memory;\r\nb->bytesused = 0;\r\nb->flags = vbuf->flags;\r\nb->field = vbuf->field;\r\nb->timestamp = ns_to_timeval(vb->timestamp);\r\nb->timecode = vbuf->timecode;\r\nb->sequence = vbuf->sequence;\r\nb->reserved2 = 0;\r\nb->reserved = 0;\r\nif (q->is_multiplanar) {\r\nb->length = vb->num_planes;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nstruct v4l2_plane *pdst = &b->m.planes[plane];\r\nstruct vb2_plane *psrc = &vb->planes[plane];\r\npdst->bytesused = psrc->bytesused;\r\npdst->length = psrc->length;\r\nif (q->memory == VB2_MEMORY_MMAP)\r\npdst->m.mem_offset = psrc->m.offset;\r\nelse if (q->memory == VB2_MEMORY_USERPTR)\r\npdst->m.userptr = psrc->m.userptr;\r\nelse if (q->memory == VB2_MEMORY_DMABUF)\r\npdst->m.fd = psrc->m.fd;\r\npdst->data_offset = psrc->data_offset;\r\nmemset(pdst->reserved, 0, sizeof(pdst->reserved));\r\n}\r\n} else {\r\nb->length = vb->planes[0].length;\r\nb->bytesused = vb->planes[0].bytesused;\r\nif (q->memory == VB2_MEMORY_MMAP)\r\nb->m.offset = vb->planes[0].m.offset;\r\nelse if (q->memory == VB2_MEMORY_USERPTR)\r\nb->m.userptr = vb->planes[0].m.userptr;\r\nelse if (q->memory == VB2_MEMORY_DMABUF)\r\nb->m.fd = vb->planes[0].m.fd;\r\n}\r\nb->flags &= ~V4L2_BUFFER_MASK_FLAGS;\r\nb->flags |= q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK;\r\nif (!q->copy_timestamp) {\r\nb->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nb->flags |= q->timestamp_flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\n}\r\nswitch (vb->state) {\r\ncase VB2_BUF_STATE_QUEUED:\r\ncase VB2_BUF_STATE_ACTIVE:\r\nb->flags |= V4L2_BUF_FLAG_QUEUED;\r\nbreak;\r\ncase VB2_BUF_STATE_ERROR:\r\nb->flags |= V4L2_BUF_FLAG_ERROR;\r\ncase VB2_BUF_STATE_DONE:\r\nb->flags |= V4L2_BUF_FLAG_DONE;\r\nbreak;\r\ncase VB2_BUF_STATE_PREPARED:\r\nb->flags |= V4L2_BUF_FLAG_PREPARED;\r\nbreak;\r\ncase VB2_BUF_STATE_PREPARING:\r\ncase VB2_BUF_STATE_DEQUEUED:\r\ncase VB2_BUF_STATE_REQUEUEING:\r\nbreak;\r\n}\r\nif (vb2_buffer_in_use(q, vb))\r\nb->flags |= V4L2_BUF_FLAG_MAPPED;\r\nif (!q->is_output &&\r\nb->flags & V4L2_BUF_FLAG_DONE &&\r\nb->flags & V4L2_BUF_FLAG_LAST)\r\nq->last_buffer_dequeued = true;\r\n}\r\nstatic int __fill_vb2_buffer(struct vb2_buffer *vb,\r\nconst void *pb, struct vb2_plane *planes)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nconst struct v4l2_buffer *b = pb;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nunsigned int plane;\r\nint ret;\r\nret = __verify_length(vb, b);\r\nif (ret < 0) {\r\ndprintk(1, "plane parameters verification failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (b->field == V4L2_FIELD_ALTERNATE && q->is_output) {\r\ndprintk(1, "the field is incorrectly set to ALTERNATE for an output buffer\n");\r\nreturn -EINVAL;\r\n}\r\nvb->timestamp = 0;\r\nvbuf->sequence = 0;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(b->type)) {\r\nif (b->memory == VB2_MEMORY_USERPTR) {\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nplanes[plane].m.userptr =\r\nb->m.planes[plane].m.userptr;\r\nplanes[plane].length =\r\nb->m.planes[plane].length;\r\n}\r\n}\r\nif (b->memory == VB2_MEMORY_DMABUF) {\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nplanes[plane].m.fd =\r\nb->m.planes[plane].m.fd;\r\nplanes[plane].length =\r\nb->m.planes[plane].length;\r\n}\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(b->type)) {\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nstruct vb2_plane *pdst = &planes[plane];\r\nstruct v4l2_plane *psrc = &b->m.planes[plane];\r\nif (psrc->bytesused == 0)\r\nvb2_warn_zero_bytesused(vb);\r\nif (vb->vb2_queue->allow_zero_bytesused)\r\npdst->bytesused = psrc->bytesused;\r\nelse\r\npdst->bytesused = psrc->bytesused ?\r\npsrc->bytesused : pdst->length;\r\npdst->data_offset = psrc->data_offset;\r\n}\r\n}\r\n} else {\r\nif (b->memory == VB2_MEMORY_USERPTR) {\r\nplanes[0].m.userptr = b->m.userptr;\r\nplanes[0].length = b->length;\r\n}\r\nif (b->memory == VB2_MEMORY_DMABUF) {\r\nplanes[0].m.fd = b->m.fd;\r\nplanes[0].length = b->length;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(b->type)) {\r\nif (b->bytesused == 0)\r\nvb2_warn_zero_bytesused(vb);\r\nif (vb->vb2_queue->allow_zero_bytesused)\r\nplanes[0].bytesused = b->bytesused;\r\nelse\r\nplanes[0].bytesused = b->bytesused ?\r\nb->bytesused : planes[0].length;\r\n} else\r\nplanes[0].bytesused = 0;\r\n}\r\nvbuf->flags = b->flags & ~V4L2_BUFFER_MASK_FLAGS;\r\nif (!vb->vb2_queue->copy_timestamp || !V4L2_TYPE_IS_OUTPUT(b->type)) {\r\nvbuf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(b->type)) {\r\nvbuf->flags &= ~V4L2_BUF_FLAG_TIMECODE;\r\nvbuf->field = b->field;\r\n} else {\r\nvbuf->flags &= ~V4L2_BUFFER_OUT_FLAGS;\r\n}\r\nreturn 0;\r\n}\r\nint vb2_querybuf(struct vb2_queue *q, struct v4l2_buffer *b)\r\n{\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nif (b->type != q->type) {\r\ndprintk(1, "wrong buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (b->index >= q->num_buffers) {\r\ndprintk(1, "buffer index out of range\n");\r\nreturn -EINVAL;\r\n}\r\nvb = q->bufs[b->index];\r\nret = __verify_planes_array(vb, b);\r\nif (!ret)\r\nvb2_core_querybuf(q, b->index, b);\r\nreturn ret;\r\n}\r\nint vb2_reqbufs(struct vb2_queue *q, struct v4l2_requestbuffers *req)\r\n{\r\nint ret = vb2_verify_memory_type(q, req->memory, req->type);\r\nreturn ret ? ret : vb2_core_reqbufs(q, req->memory, &req->count);\r\n}\r\nint vb2_prepare_buf(struct vb2_queue *q, struct v4l2_buffer *b)\r\n{\r\nint ret;\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nret = vb2_queue_or_prepare_buf(q, b, "prepare_buf");\r\nreturn ret ? ret : vb2_core_prepare_buf(q, b->index, b);\r\n}\r\nint vb2_create_bufs(struct vb2_queue *q, struct v4l2_create_buffers *create)\r\n{\r\nunsigned requested_planes = 1;\r\nunsigned requested_sizes[VIDEO_MAX_PLANES];\r\nstruct v4l2_format *f = &create->format;\r\nint ret = vb2_verify_memory_type(q, create->memory, f->type);\r\nunsigned i;\r\ncreate->index = q->num_buffers;\r\nif (create->count == 0)\r\nreturn ret != -EBUSY ? ret : 0;\r\nswitch (f->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nrequested_planes = f->fmt.pix_mp.num_planes;\r\nif (requested_planes == 0 ||\r\nrequested_planes > VIDEO_MAX_PLANES)\r\nreturn -EINVAL;\r\nfor (i = 0; i < requested_planes; i++)\r\nrequested_sizes[i] =\r\nf->fmt.pix_mp.plane_fmt[i].sizeimage;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nrequested_sizes[0] = f->fmt.pix.sizeimage;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nrequested_sizes[0] = f->fmt.vbi.samples_per_line *\r\n(f->fmt.vbi.count[0] + f->fmt.vbi.count[1]);\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nrequested_sizes[0] = f->fmt.sliced.io_size;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SDR_CAPTURE:\r\ncase V4L2_BUF_TYPE_SDR_OUTPUT:\r\nrequested_sizes[0] = f->fmt.sdr.buffersize;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < requested_planes; i++)\r\nif (requested_sizes[i] == 0)\r\nreturn -EINVAL;\r\nreturn ret ? ret : vb2_core_create_bufs(q, create->memory,\r\n&create->count, requested_planes, requested_sizes);\r\n}\r\nint vb2_qbuf(struct vb2_queue *q, struct v4l2_buffer *b)\r\n{\r\nint ret;\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nret = vb2_queue_or_prepare_buf(q, b, "qbuf");\r\nreturn ret ? ret : vb2_core_qbuf(q, b->index, b);\r\n}\r\nint vb2_dqbuf(struct vb2_queue *q, struct v4l2_buffer *b, bool nonblocking)\r\n{\r\nint ret;\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (b->type != q->type) {\r\ndprintk(1, "invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nret = vb2_core_dqbuf(q, NULL, b, nonblocking);\r\nb->flags &= ~V4L2_BUF_FLAG_DONE;\r\nreturn ret;\r\n}\r\nint vb2_streamon(struct vb2_queue *q, enum v4l2_buf_type type)\r\n{\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nreturn vb2_core_streamon(q, type);\r\n}\r\nint vb2_streamoff(struct vb2_queue *q, enum v4l2_buf_type type)\r\n{\r\nif (vb2_fileio_is_active(q)) {\r\ndprintk(1, "file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nreturn vb2_core_streamoff(q, type);\r\n}\r\nint vb2_expbuf(struct vb2_queue *q, struct v4l2_exportbuffer *eb)\r\n{\r\nreturn vb2_core_expbuf(q, &eb->fd, eb->type, eb->index,\r\neb->plane, eb->flags);\r\n}\r\nint vb2_queue_init(struct vb2_queue *q)\r\n{\r\nif (WARN_ON(!q) ||\r\nWARN_ON(q->timestamp_flags &\r\n~(V4L2_BUF_FLAG_TIMESTAMP_MASK |\r\nV4L2_BUF_FLAG_TSTAMP_SRC_MASK)))\r\nreturn -EINVAL;\r\nWARN_ON((q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK) ==\r\nV4L2_BUF_FLAG_TIMESTAMP_UNKNOWN);\r\nif (WARN_ON(VB2_MEMORY_MMAP != (int)V4L2_MEMORY_MMAP)\r\n|| WARN_ON(VB2_MEMORY_USERPTR != (int)V4L2_MEMORY_USERPTR)\r\n|| WARN_ON(VB2_MEMORY_DMABUF != (int)V4L2_MEMORY_DMABUF))\r\nreturn -EINVAL;\r\nif (q->buf_struct_size == 0)\r\nq->buf_struct_size = sizeof(struct vb2_v4l2_buffer);\r\nq->buf_ops = &v4l2_buf_ops;\r\nq->is_multiplanar = V4L2_TYPE_IS_MULTIPLANAR(q->type);\r\nq->is_output = V4L2_TYPE_IS_OUTPUT(q->type);\r\nq->copy_timestamp = (q->timestamp_flags & V4L2_BUF_FLAG_TIMESTAMP_MASK)\r\n== V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nq->quirk_poll_must_check_waiting_for_buffers = true;\r\nreturn vb2_core_queue_init(q);\r\n}\r\nvoid vb2_queue_release(struct vb2_queue *q)\r\n{\r\nvb2_core_queue_release(q);\r\n}\r\nunsigned int vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nunsigned long req_events = poll_requested_events(wait);\r\nunsigned int res = 0;\r\nif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags)) {\r\nstruct v4l2_fh *fh = file->private_data;\r\nif (v4l2_event_pending(fh))\r\nres = POLLPRI;\r\nelse if (req_events & POLLPRI)\r\npoll_wait(file, &fh->wait, wait);\r\n}\r\nreturn res | vb2_core_poll(q, file, wait);\r\n}\r\nstatic inline bool vb2_queue_is_busy(struct video_device *vdev, struct file *file)\r\n{\r\nreturn vdev->queue->owner && vdev->queue->owner != file->private_data;\r\n}\r\nint vb2_ioctl_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nint res = vb2_verify_memory_type(vdev->queue, p->memory, p->type);\r\nif (res)\r\nreturn res;\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nres = vb2_core_reqbufs(vdev->queue, p->memory, &p->count);\r\nif (res == 0)\r\nvdev->queue->owner = p->count ? file->private_data : NULL;\r\nreturn res;\r\n}\r\nint vb2_ioctl_create_bufs(struct file *file, void *priv,\r\nstruct v4l2_create_buffers *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nint res = vb2_verify_memory_type(vdev->queue, p->memory,\r\np->format.type);\r\np->index = vdev->queue->num_buffers;\r\nif (p->count == 0)\r\nreturn res != -EBUSY ? res : 0;\r\nif (res)\r\nreturn res;\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nres = vb2_create_bufs(vdev->queue, p);\r\nif (res == 0)\r\nvdev->queue->owner = file->private_data;\r\nreturn res;\r\n}\r\nint vb2_ioctl_prepare_buf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nreturn vb2_prepare_buf(vdev->queue, p);\r\n}\r\nint vb2_ioctl_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nreturn vb2_querybuf(vdev->queue, p);\r\n}\r\nint vb2_ioctl_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nreturn vb2_qbuf(vdev->queue, p);\r\n}\r\nint vb2_ioctl_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nreturn vb2_dqbuf(vdev->queue, p, file->f_flags & O_NONBLOCK);\r\n}\r\nint vb2_ioctl_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nreturn vb2_streamon(vdev->queue, i);\r\n}\r\nint vb2_ioctl_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nreturn vb2_streamoff(vdev->queue, i);\r\n}\r\nint vb2_ioctl_expbuf(struct file *file, void *priv, struct v4l2_exportbuffer *p)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vb2_queue_is_busy(vdev, file))\r\nreturn -EBUSY;\r\nreturn vb2_expbuf(vdev->queue, p);\r\n}\r\nint vb2_fop_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nreturn vb2_mmap(vdev->queue, vma);\r\n}\r\nint _vb2_fop_release(struct file *file, struct mutex *lock)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (lock)\r\nmutex_lock(lock);\r\nif (file->private_data == vdev->queue->owner) {\r\nvb2_queue_release(vdev->queue);\r\nvdev->queue->owner = NULL;\r\n}\r\nif (lock)\r\nmutex_unlock(lock);\r\nreturn v4l2_fh_release(file);\r\n}\r\nint vb2_fop_release(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct mutex *lock = vdev->queue->lock ? vdev->queue->lock : vdev->lock;\r\nreturn _vb2_fop_release(file, lock);\r\n}\r\nssize_t vb2_fop_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct mutex *lock = vdev->queue->lock ? vdev->queue->lock : vdev->lock;\r\nint err = -EBUSY;\r\nif (!(vdev->queue->io_modes & VB2_WRITE))\r\nreturn -EINVAL;\r\nif (lock && mutex_lock_interruptible(lock))\r\nreturn -ERESTARTSYS;\r\nif (vb2_queue_is_busy(vdev, file))\r\ngoto exit;\r\nerr = vb2_write(vdev->queue, buf, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\nif (vdev->queue->fileio)\r\nvdev->queue->owner = file->private_data;\r\nexit:\r\nif (lock)\r\nmutex_unlock(lock);\r\nreturn err;\r\n}\r\nssize_t vb2_fop_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct mutex *lock = vdev->queue->lock ? vdev->queue->lock : vdev->lock;\r\nint err = -EBUSY;\r\nif (!(vdev->queue->io_modes & VB2_READ))\r\nreturn -EINVAL;\r\nif (lock && mutex_lock_interruptible(lock))\r\nreturn -ERESTARTSYS;\r\nif (vb2_queue_is_busy(vdev, file))\r\ngoto exit;\r\nerr = vb2_read(vdev->queue, buf, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\nif (vdev->queue->fileio)\r\nvdev->queue->owner = file->private_data;\r\nexit:\r\nif (lock)\r\nmutex_unlock(lock);\r\nreturn err;\r\n}\r\nunsigned int vb2_fop_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct vb2_queue *q = vdev->queue;\r\nstruct mutex *lock = q->lock ? q->lock : vdev->lock;\r\nunsigned res;\r\nvoid *fileio;\r\nWARN_ON(!lock);\r\nif (lock && mutex_lock_interruptible(lock))\r\nreturn POLLERR;\r\nfileio = q->fileio;\r\nres = vb2_poll(vdev->queue, file, wait);\r\nif (!fileio && q->fileio)\r\nq->owner = file->private_data;\r\nif (lock)\r\nmutex_unlock(lock);\r\nreturn res;\r\n}\r\nunsigned long vb2_fop_get_unmapped_area(struct file *file, unsigned long addr,\r\nunsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nreturn vb2_get_unmapped_area(vdev->queue, addr, len, pgoff, flags);\r\n}\r\nvoid vb2_ops_wait_prepare(struct vb2_queue *vq)\r\n{\r\nmutex_unlock(vq->lock);\r\n}\r\nvoid vb2_ops_wait_finish(struct vb2_queue *vq)\r\n{\r\nmutex_lock(vq->lock);\r\n}
