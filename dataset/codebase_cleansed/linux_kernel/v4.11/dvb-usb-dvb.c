static int dvb_usb_ctrl_feed(struct dvb_demux_feed *dvbdmxfeed, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\r\nint newfeedcount, ret;\r\nif (adap == NULL)\r\nreturn -ENODEV;\r\nif ((adap->active_fe < 0) ||\r\n(adap->active_fe >= adap->num_frontends_initialized)) {\r\nreturn -EINVAL;\r\n}\r\nnewfeedcount = adap->feedcount + (onoff ? 1 : -1);\r\nif (newfeedcount == 0) {\r\ndeb_ts("stop feeding\n");\r\nusb_urb_kill(&adap->fe_adap[adap->active_fe].stream);\r\nif (adap->props.fe[adap->active_fe].streaming_ctrl != NULL) {\r\nret = adap->props.fe[adap->active_fe].streaming_ctrl(adap, 0);\r\nif (ret < 0) {\r\nerr("error while stopping stream.");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nadap->feedcount = newfeedcount;\r\ndeb_ts("setting pid (%s): %5d %04x at index %d '%s'\n",\r\nadap->fe_adap[adap->active_fe].pid_filtering ?\r\n"yes" : "no", dvbdmxfeed->pid, dvbdmxfeed->pid,\r\ndvbdmxfeed->index, onoff ? "on" : "off");\r\nif (adap->props.fe[adap->active_fe].caps & DVB_USB_ADAP_HAS_PID_FILTER &&\r\nadap->fe_adap[adap->active_fe].pid_filtering &&\r\nadap->props.fe[adap->active_fe].pid_filter != NULL)\r\nadap->props.fe[adap->active_fe].pid_filter(adap, dvbdmxfeed->index, dvbdmxfeed->pid, onoff);\r\nif (adap->feedcount == onoff && adap->feedcount > 0) {\r\ndeb_ts("submitting all URBs\n");\r\nusb_urb_submit(&adap->fe_adap[adap->active_fe].stream);\r\ndeb_ts("controlling pid parser\n");\r\nif (adap->props.fe[adap->active_fe].caps & DVB_USB_ADAP_HAS_PID_FILTER &&\r\nadap->props.fe[adap->active_fe].caps &\r\nDVB_USB_ADAP_PID_FILTER_CAN_BE_TURNED_OFF &&\r\nadap->props.fe[adap->active_fe].pid_filter_ctrl != NULL) {\r\nret = adap->props.fe[adap->active_fe].pid_filter_ctrl(adap,\r\nadap->fe_adap[adap->active_fe].pid_filtering);\r\nif (ret < 0) {\r\nerr("could not handle pid_parser");\r\nreturn ret;\r\n}\r\n}\r\ndeb_ts("start feeding\n");\r\nif (adap->props.fe[adap->active_fe].streaming_ctrl != NULL) {\r\nret = adap->props.fe[adap->active_fe].streaming_ctrl(adap, 1);\r\nif (ret < 0) {\r\nerr("error while enabling fifo.");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\ndeb_ts("start pid: 0x%04x, feedtype: %d\n", dvbdmxfeed->pid,\r\ndvbdmxfeed->type);\r\nreturn dvb_usb_ctrl_feed(dvbdmxfeed, 1);\r\n}\r\nstatic int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\ndeb_ts("stop pid: 0x%04x, feedtype: %d\n", dvbdmxfeed->pid, dvbdmxfeed->type);\r\nreturn dvb_usb_ctrl_feed(dvbdmxfeed, 0);\r\n}\r\nstatic int dvb_usb_media_device_init(struct dvb_usb_adapter *adap)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nstruct media_device *mdev;\r\nstruct dvb_usb_device *d = adap->dev;\r\nstruct usb_device *udev = d->udev;\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmedia_device_usb_init(mdev, udev, d->desc->name);\r\ndvb_register_media_controller(&adap->dvb_adap, mdev);\r\ndev_info(&d->udev->dev, "media controller created\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_media_device_register(struct dvb_usb_adapter *adap)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nreturn media_device_register(adap->dvb_adap.mdev);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void dvb_usb_media_device_unregister(struct dvb_usb_adapter *adap)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER_DVB\r\nif (!adap->dvb_adap.mdev)\r\nreturn;\r\nmedia_device_unregister(adap->dvb_adap.mdev);\r\nmedia_device_cleanup(adap->dvb_adap.mdev);\r\nkfree(adap->dvb_adap.mdev);\r\nadap->dvb_adap.mdev = NULL;\r\n#endif\r\n}\r\nint dvb_usb_adapter_dvb_init(struct dvb_usb_adapter *adap, short *adapter_nums)\r\n{\r\nint i;\r\nint ret = dvb_register_adapter(&adap->dvb_adap, adap->dev->desc->name,\r\nadap->dev->owner, &adap->dev->udev->dev,\r\nadapter_nums);\r\nif (ret < 0) {\r\ndeb_info("dvb_register_adapter failed: error %d", ret);\r\ngoto err;\r\n}\r\nadap->dvb_adap.priv = adap;\r\nret = dvb_usb_media_device_init(adap);\r\nif (ret < 0) {\r\ndeb_info("dvb_usb_media_device_init failed: error %d", ret);\r\ngoto err_mc;\r\n}\r\nif (adap->dev->props.read_mac_address) {\r\nif (adap->dev->props.read_mac_address(adap->dev, adap->dvb_adap.proposed_mac) == 0)\r\ninfo("MAC address: %pM", adap->dvb_adap.proposed_mac);\r\nelse\r\nerr("MAC address reading failed.");\r\n}\r\nadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\nadap->demux.priv = adap;\r\nadap->demux.filternum = 0;\r\nfor (i = 0; i < adap->props.num_frontends; i++) {\r\nif (adap->demux.filternum < adap->fe_adap[i].max_feed_count)\r\nadap->demux.filternum = adap->fe_adap[i].max_feed_count;\r\n}\r\nadap->demux.feednum = adap->demux.filternum;\r\nadap->demux.start_feed = dvb_usb_start_feed;\r\nadap->demux.stop_feed = dvb_usb_stop_feed;\r\nadap->demux.write_to_decoder = NULL;\r\nif ((ret = dvb_dmx_init(&adap->demux)) < 0) {\r\nerr("dvb_dmx_init failed: error %d", ret);\r\ngoto err_dmx;\r\n}\r\nadap->dmxdev.filternum = adap->demux.filternum;\r\nadap->dmxdev.demux = &adap->demux.dmx;\r\nadap->dmxdev.capabilities = 0;\r\nif ((ret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap)) < 0) {\r\nerr("dvb_dmxdev_init failed: error %d", ret);\r\ngoto err_dmx_dev;\r\n}\r\nif ((ret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net,\r\n&adap->demux.dmx)) < 0) {\r\nerr("dvb_net_init failed: error %d", ret);\r\ngoto err_net_init;\r\n}\r\nadap->state |= DVB_USB_ADAP_STATE_DVB;\r\nreturn 0;\r\nerr_net_init:\r\ndvb_dmxdev_release(&adap->dmxdev);\r\nerr_dmx_dev:\r\ndvb_dmx_release(&adap->demux);\r\nerr_dmx:\r\ndvb_usb_media_device_unregister(adap);\r\nerr_mc:\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nerr:\r\nreturn ret;\r\n}\r\nint dvb_usb_adapter_dvb_exit(struct dvb_usb_adapter *adap)\r\n{\r\nif (adap->state & DVB_USB_ADAP_STATE_DVB) {\r\ndeb_info("unregistering DVB part\n");\r\ndvb_net_release(&adap->dvb_net);\r\nadap->demux.dmx.close(&adap->demux.dmx);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\ndvb_dmx_release(&adap->demux);\r\ndvb_usb_media_device_unregister(adap);\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nadap->state &= ~DVB_USB_ADAP_STATE_DVB;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_set_active_fe(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nint ret = (adap->props.frontend_ctrl) ?\r\nadap->props.frontend_ctrl(fe, onoff) : 0;\r\nif (ret < 0) {\r\nerr("frontend_ctrl request failed");\r\nreturn ret;\r\n}\r\nif (onoff)\r\nadap->active_fe = fe->id;\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_fe_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\ndvb_usb_device_power_ctrl(adap->dev, 1);\r\ndvb_usb_set_active_fe(fe, 1);\r\nif (adap->fe_adap[fe->id].fe_init)\r\nadap->fe_adap[fe->id].fe_init(fe);\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nif (adap->fe_adap[fe->id].fe_sleep)\r\nadap->fe_adap[fe->id].fe_sleep(fe);\r\ndvb_usb_set_active_fe(fe, 0);\r\nreturn dvb_usb_device_power_ctrl(adap->dev, 0);\r\n}\r\nint dvb_usb_adapter_frontend_init(struct dvb_usb_adapter *adap)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < adap->props.num_frontends; i++) {\r\nif (adap->props.fe[i].frontend_attach == NULL) {\r\nerr("strange: '%s' #%d,%d doesn't want to attach a frontend.",\r\nadap->dev->desc->name, adap->id, i);\r\nreturn 0;\r\n}\r\nret = adap->props.fe[i].frontend_attach(adap);\r\nif (ret || adap->fe_adap[i].fe == NULL) {\r\nif (i == 0)\r\nerr("no frontend was attached by '%s'",\r\nadap->dev->desc->name);\r\nreturn 0;\r\n}\r\nadap->fe_adap[i].fe->id = i;\r\nadap->fe_adap[i].fe_init = adap->fe_adap[i].fe->ops.init;\r\nadap->fe_adap[i].fe->ops.init = dvb_usb_fe_wakeup;\r\nadap->fe_adap[i].fe_sleep = adap->fe_adap[i].fe->ops.sleep;\r\nadap->fe_adap[i].fe->ops.sleep = dvb_usb_fe_sleep;\r\nif (dvb_register_frontend(&adap->dvb_adap, adap->fe_adap[i].fe)) {\r\nerr("Frontend %d registration failed.", i);\r\ndvb_frontend_detach(adap->fe_adap[i].fe);\r\nadap->fe_adap[i].fe = NULL;\r\nif (i == 0)\r\nreturn -ENODEV;\r\nelse\r\nreturn 0;\r\n}\r\nif (adap->props.fe[i].tuner_attach != NULL)\r\nadap->props.fe[i].tuner_attach(adap);\r\nadap->num_frontends_initialized++;\r\n}\r\nret = dvb_create_media_graph(&adap->dvb_adap, true);\r\nif (ret)\r\nreturn ret;\r\nret = dvb_usb_media_device_register(adap);\r\nreturn ret;\r\n}\r\nint dvb_usb_adapter_frontend_exit(struct dvb_usb_adapter *adap)\r\n{\r\nint i = adap->num_frontends_initialized - 1;\r\nfor (; i >= 0; i--) {\r\nif (adap->fe_adap[i].fe != NULL) {\r\ndvb_unregister_frontend(adap->fe_adap[i].fe);\r\ndvb_frontend_detach(adap->fe_adap[i].fe);\r\n}\r\n}\r\nadap->num_frontends_initialized = 0;\r\nreturn 0;\r\n}
