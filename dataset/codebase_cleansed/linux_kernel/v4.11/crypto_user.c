static struct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\r\n{\r\nstruct crypto_alg *q, *alg = NULL;\r\ndown_read(&crypto_alg_sem);\r\nlist_for_each_entry(q, &crypto_alg_list, cra_list) {\r\nint match = 0;\r\nif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\r\ncontinue;\r\nif (strlen(p->cru_driver_name))\r\nmatch = !strcmp(q->cra_driver_name,\r\np->cru_driver_name);\r\nelse if (!exact)\r\nmatch = !strcmp(q->cra_name, p->cru_name);\r\nif (!match)\r\ncontinue;\r\nif (unlikely(!crypto_mod_get(q)))\r\ncontinue;\r\nalg = q;\r\nbreak;\r\n}\r\nup_read(&crypto_alg_sem);\r\nreturn alg;\r\n}\r\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_cipher rcipher;\r\nstrncpy(rcipher.type, "cipher", sizeof(rcipher.type));\r\nrcipher.blocksize = alg->cra_blocksize;\r\nrcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\r\nrcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\r\nsizeof(struct crypto_report_cipher), &rcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_comp rcomp;\r\nstrncpy(rcomp.type, "compression", sizeof(rcomp.type));\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\r\nsizeof(struct crypto_report_comp), &rcomp))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_acomp racomp;\r\nstrncpy(racomp.type, "acomp", sizeof(racomp.type));\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\r\nsizeof(struct crypto_report_acomp), &racomp))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_akcipher rakcipher;\r\nstrncpy(rakcipher.type, "akcipher", sizeof(rakcipher.type));\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\r\nsizeof(struct crypto_report_akcipher), &rakcipher))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_kpp rkpp;\r\nstrncpy(rkpp.type, "kpp", sizeof(rkpp.type));\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\r\nsizeof(struct crypto_report_kpp), &rkpp))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_report_one(struct crypto_alg *alg,\r\nstruct crypto_user_alg *ualg, struct sk_buff *skb)\r\n{\r\nstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\r\nstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\r\nsizeof(ualg->cru_driver_name));\r\nstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\r\nsizeof(ualg->cru_module_name));\r\nualg->cru_type = 0;\r\nualg->cru_mask = 0;\r\nualg->cru_flags = alg->cra_flags;\r\nualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\r\nif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\r\ngoto nla_put_failure;\r\nif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\r\nstruct crypto_report_larval rl;\r\nstrncpy(rl.type, "larval", sizeof(rl.type));\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\r\nsizeof(struct crypto_report_larval), &rl))\r\ngoto nla_put_failure;\r\ngoto out;\r\n}\r\nif (alg->cra_type && alg->cra_type->report) {\r\nif (alg->cra_type->report(skb, alg))\r\ngoto nla_put_failure;\r\ngoto out;\r\n}\r\nswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\r\ncase CRYPTO_ALG_TYPE_CIPHER:\r\nif (crypto_report_cipher(skb, alg))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_COMPRESS:\r\nif (crypto_report_comp(skb, alg))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_ACOMPRESS:\r\nif (crypto_report_acomp(skb, alg))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_AKCIPHER:\r\nif (crypto_report_akcipher(skb, alg))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_KPP:\r\nif (crypto_report_kpp(skb, alg))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nout:\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_report_alg(struct crypto_alg *alg,\r\nstruct crypto_dump_info *info)\r\n{\r\nstruct sk_buff *in_skb = info->in_skb;\r\nstruct sk_buff *skb = info->out_skb;\r\nstruct nlmsghdr *nlh;\r\nstruct crypto_user_alg *ualg;\r\nint err = 0;\r\nnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\r\nCRYPTO_MSG_GETALG, sizeof(*ualg), info->nlmsg_flags);\r\nif (!nlh) {\r\nerr = -EMSGSIZE;\r\ngoto out;\r\n}\r\nualg = nlmsg_data(nlh);\r\nerr = crypto_report_one(alg, ualg, skb);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\ngoto out;\r\n}\r\nnlmsg_end(skb, nlh);\r\nout:\r\nreturn err;\r\n}\r\nstatic int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct crypto_user_alg *p = nlmsg_data(in_nlh);\r\nstruct crypto_alg *alg;\r\nstruct sk_buff *skb;\r\nstruct crypto_dump_info info;\r\nint err;\r\nif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\r\nreturn -EINVAL;\r\nalg = crypto_alg_match(p, 0);\r\nif (!alg)\r\nreturn -ENOENT;\r\nerr = -ENOMEM;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (!skb)\r\ngoto drop_alg;\r\ninfo.in_skb = in_skb;\r\ninfo.out_skb = skb;\r\ninfo.nlmsg_seq = in_nlh->nlmsg_seq;\r\ninfo.nlmsg_flags = 0;\r\nerr = crypto_report_alg(alg, &info);\r\ndrop_alg:\r\ncrypto_mod_put(alg);\r\nif (err)\r\nreturn err;\r\nreturn nlmsg_unicast(crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\r\n}\r\nstatic int crypto_dump_report(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_dump_info info;\r\nint err;\r\nif (cb->args[0])\r\ngoto out;\r\ncb->args[0] = 1;\r\ninfo.in_skb = cb->skb;\r\ninfo.out_skb = skb;\r\ninfo.nlmsg_seq = cb->nlh->nlmsg_seq;\r\ninfo.nlmsg_flags = NLM_F_MULTI;\r\nlist_for_each_entry(alg, &crypto_alg_list, cra_list) {\r\nerr = crypto_report_alg(alg, &info);\r\nif (err)\r\ngoto out_err;\r\n}\r\nout:\r\nreturn skb->len;\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int crypto_dump_report_done(struct netlink_callback *cb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_user_alg *p = nlmsg_data(nlh);\r\nstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\r\nLIST_HEAD(list);\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\r\nreturn -EINVAL;\r\nif (priority && !strlen(p->cru_driver_name))\r\nreturn -EINVAL;\r\nalg = crypto_alg_match(p, 1);\r\nif (!alg)\r\nreturn -ENOENT;\r\ndown_write(&crypto_alg_sem);\r\ncrypto_remove_spawns(alg, &list, NULL);\r\nif (priority)\r\nalg->cra_priority = nla_get_u32(priority);\r\nup_write(&crypto_alg_sem);\r\ncrypto_mod_put(alg);\r\ncrypto_remove_final(&list);\r\nreturn 0;\r\n}\r\nstatic int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct crypto_alg *alg;\r\nstruct crypto_user_alg *p = nlmsg_data(nlh);\r\nint err;\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\r\nreturn -EINVAL;\r\nalg = crypto_alg_match(p, 1);\r\nif (!alg)\r\nreturn -ENOENT;\r\nerr = -EINVAL;\r\nif (!(alg->cra_flags & CRYPTO_ALG_INSTANCE))\r\ngoto drop_alg;\r\nerr = -EBUSY;\r\nif (atomic_read(&alg->cra_refcnt) > 2)\r\ngoto drop_alg;\r\nerr = crypto_unregister_instance((struct crypto_instance *)alg);\r\ndrop_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int crypto_add_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nint exact = 0;\r\nconst char *name;\r\nstruct crypto_alg *alg;\r\nstruct crypto_user_alg *p = nlmsg_data(nlh);\r\nstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\r\nreturn -EINVAL;\r\nif (strlen(p->cru_driver_name))\r\nexact = 1;\r\nif (priority && !exact)\r\nreturn -EINVAL;\r\nalg = crypto_alg_match(p, exact);\r\nif (alg) {\r\ncrypto_mod_put(alg);\r\nreturn -EEXIST;\r\n}\r\nif (strlen(p->cru_driver_name))\r\nname = p->cru_driver_name;\r\nelse\r\nname = p->cru_name;\r\nalg = crypto_alg_mod_lookup(name, p->cru_type, p->cru_mask);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\ndown_write(&crypto_alg_sem);\r\nif (priority)\r\nalg->cra_priority = nla_get_u32(priority);\r\nup_write(&crypto_alg_sem);\r\ncrypto_mod_put(alg);\r\nreturn 0;\r\n}\r\nstatic int crypto_del_rng(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nif (!netlink_capable(skb, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn crypto_del_default_rng();\r\n}\r\nstatic int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\r\nconst struct crypto_link *link;\r\nint type, err;\r\ntype = nlh->nlmsg_type;\r\nif (type > CRYPTO_MSG_MAX)\r\nreturn -EINVAL;\r\ntype -= CRYPTO_MSG_BASE;\r\nlink = &crypto_dispatch[type];\r\nif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\r\n(nlh->nlmsg_flags & NLM_F_DUMP))) {\r\nstruct crypto_alg *alg;\r\nu16 dump_alloc = 0;\r\nif (link->dump == NULL)\r\nreturn -EINVAL;\r\ndown_read(&crypto_alg_sem);\r\nlist_for_each_entry(alg, &crypto_alg_list, cra_list)\r\ndump_alloc += CRYPTO_REPORT_MAXSIZE;\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = link->dump,\r\n.done = link->done,\r\n.min_dump_alloc = dump_alloc,\r\n};\r\nerr = netlink_dump_start(crypto_nlsk, skb, nlh, &c);\r\n}\r\nup_read(&crypto_alg_sem);\r\nreturn err;\r\n}\r\nerr = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,\r\ncrypto_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (link->doit == NULL)\r\nreturn -EINVAL;\r\nreturn link->doit(skb, nlh, attrs);\r\n}\r\nstatic void crypto_netlink_rcv(struct sk_buff *skb)\r\n{\r\nmutex_lock(&crypto_cfg_mutex);\r\nnetlink_rcv_skb(skb, &crypto_user_rcv_msg);\r\nmutex_unlock(&crypto_cfg_mutex);\r\n}\r\nstatic int __init crypto_user_init(void)\r\n{\r\nstruct netlink_kernel_cfg cfg = {\r\n.input = crypto_netlink_rcv,\r\n};\r\ncrypto_nlsk = netlink_kernel_create(&init_net, NETLINK_CRYPTO, &cfg);\r\nif (!crypto_nlsk)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit crypto_user_exit(void)\r\n{\r\nnetlink_kernel_release(crypto_nlsk);\r\n}
