static int nct7904_bank_lock(struct nct7904_data *data, unsigned bank)\r\n{\r\nint ret;\r\nmutex_lock(&data->bank_lock);\r\nif (data->bank_sel == bank)\r\nreturn 0;\r\nret = i2c_smbus_write_byte_data(data->client, BANK_SEL_REG, bank);\r\nif (ret == 0)\r\ndata->bank_sel = bank;\r\nelse\r\ndata->bank_sel = -1;\r\nreturn ret;\r\n}\r\nstatic inline void nct7904_bank_release(struct nct7904_data *data)\r\n{\r\nmutex_unlock(&data->bank_lock);\r\n}\r\nstatic int nct7904_read_reg(struct nct7904_data *data,\r\nunsigned bank, unsigned reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = nct7904_bank_lock(data, bank);\r\nif (ret == 0)\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nnct7904_bank_release(data);\r\nreturn ret;\r\n}\r\nstatic int nct7904_read_reg16(struct nct7904_data *data,\r\nunsigned bank, unsigned reg)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret, hi;\r\nret = nct7904_bank_lock(data, bank);\r\nif (ret == 0) {\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret >= 0) {\r\nhi = ret;\r\nret = i2c_smbus_read_byte_data(client, reg + 1);\r\nif (ret >= 0)\r\nret |= hi << 8;\r\n}\r\n}\r\nnct7904_bank_release(data);\r\nreturn ret;\r\n}\r\nstatic int nct7904_write_reg(struct nct7904_data *data,\r\nunsigned bank, unsigned reg, u8 val)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = nct7904_bank_lock(data, bank);\r\nif (ret == 0)\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nnct7904_bank_release(data);\r\nreturn ret;\r\n}\r\nstatic int nct7904_read_fan(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nunsigned int cnt, rpm;\r\nint ret;\r\nswitch(attr) {\r\ncase hwmon_fan_input:\r\nret = nct7904_read_reg16(data, BANK_0,\r\nFANIN1_HV_REG + channel * 2);\r\nif (ret < 0)\r\nreturn ret;\r\ncnt = ((ret & 0xff00) >> 3) | (ret & 0x1f);\r\nif (cnt == 0x1fff)\r\nrpm = 0;\r\nelse\r\nrpm = 1350000 / cnt;\r\n*val = rpm;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t nct7904_fan_is_visible(const void *_data, u32 attr, int channel)\r\n{\r\nconst struct nct7904_data *data = _data;\r\nif (attr == hwmon_fan_input && data->fanin_mask & (1 << channel))\r\nreturn S_IRUGO;\r\nreturn 0;\r\n}\r\nstatic int nct7904_read_in(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret, volt, index;\r\nindex = nct7904_chan_to_index[channel];\r\nswitch(attr) {\r\ncase hwmon_in_input:\r\nret = nct7904_read_reg16(data, BANK_0,\r\nVSEN1_HV_REG + index * 2);\r\nif (ret < 0)\r\nreturn ret;\r\nvolt = ((ret & 0xff00) >> 5) | (ret & 0x7);\r\nif (index < 14)\r\nvolt *= 2;\r\nelse\r\nvolt *= 6;\r\n*val = volt;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t nct7904_in_is_visible(const void *_data, u32 attr, int channel)\r\n{\r\nconst struct nct7904_data *data = _data;\r\nint index = nct7904_chan_to_index[channel];\r\nif (channel > 0 && attr == hwmon_in_input &&\r\n(data->vsen_mask & BIT(index)))\r\nreturn S_IRUGO;\r\nreturn 0;\r\n}\r\nstatic int nct7904_read_temp(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret, temp;\r\nswitch(attr) {\r\ncase hwmon_temp_input:\r\nif (channel == 0)\r\nret = nct7904_read_reg16(data, BANK_0, LTD_HV_REG);\r\nelse\r\nret = nct7904_read_reg16(data, BANK_0,\r\nT_CPU1_HV_REG + (channel - 1) * 2);\r\nif (ret < 0)\r\nreturn ret;\r\ntemp = ((ret & 0xff00) >> 5) | (ret & 0x7);\r\n*val = sign_extend32(temp, 10) * 125;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t nct7904_temp_is_visible(const void *_data, u32 attr, int channel)\r\n{\r\nconst struct nct7904_data *data = _data;\r\nif (attr == hwmon_temp_input) {\r\nif (channel == 0) {\r\nif (data->vsen_mask & BIT(17))\r\nreturn S_IRUGO;\r\n} else {\r\nif (data->tcpu_mask & BIT(channel - 1))\r\nreturn S_IRUGO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nct7904_read_pwm(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nswitch(attr) {\r\ncase hwmon_pwm_input:\r\nret = nct7904_read_reg(data, BANK_3, FANCTL1_OUT_REG + channel);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\ncase hwmon_pwm_enable:\r\nret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + channel);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret ? 2 : 1;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int nct7904_write_pwm(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct nct7904_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nswitch(attr) {\r\ncase hwmon_pwm_input:\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\nret = nct7904_write_reg(data, BANK_3, FANCTL1_OUT_REG + channel,\r\nval);\r\nreturn ret;\r\ncase hwmon_pwm_enable:\r\nif (val < 1 || val > 2 ||\r\n(val == 2 && !data->fan_mode[channel]))\r\nreturn -EINVAL;\r\nret = nct7904_write_reg(data, BANK_3, FANCTL1_FMR_REG + channel,\r\nval == 2 ? data->fan_mode[channel] : 0);\r\nreturn ret;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t nct7904_pwm_is_visible(const void *_data, u32 attr, int channel)\r\n{\r\nswitch(attr) {\r\ncase hwmon_pwm_input:\r\ncase hwmon_pwm_enable:\r\nreturn S_IRUGO | S_IWUSR;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int nct7904_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nswitch (type) {\r\ncase hwmon_in:\r\nreturn nct7904_read_in(dev, attr, channel, val);\r\ncase hwmon_fan:\r\nreturn nct7904_read_fan(dev, attr, channel, val);\r\ncase hwmon_pwm:\r\nreturn nct7904_read_pwm(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn nct7904_read_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int nct7904_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long val)\r\n{\r\nswitch (type) {\r\ncase hwmon_pwm:\r\nreturn nct7904_write_pwm(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t nct7904_is_visible(const void *data,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (type) {\r\ncase hwmon_in:\r\nreturn nct7904_in_is_visible(data, attr, channel);\r\ncase hwmon_fan:\r\nreturn nct7904_fan_is_visible(data, attr, channel);\r\ncase hwmon_pwm:\r\nreturn nct7904_pwm_is_visible(data, attr, channel);\r\ncase hwmon_temp:\r\nreturn nct7904_temp_is_visible(data, attr, channel);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int nct7904_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nif (!i2c_check_functionality(adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE |\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_byte_data(client, VENDOR_ID_REG) != NUVOTON_ID ||\r\ni2c_smbus_read_byte_data(client, CHIP_ID_REG) != NCT7904_ID ||\r\n(i2c_smbus_read_byte_data(client, DEVICE_ID_REG) & 0xf0) != 0x50 ||\r\n(i2c_smbus_read_byte_data(client, BANK_SEL_REG) & 0xf8) != 0x00)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "nct7904", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int nct7904_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct nct7904_data *data;\r\nstruct device *hwmon_dev;\r\nstruct device *dev = &client->dev;\r\nint ret, i;\r\nu32 mask;\r\ndata = devm_kzalloc(dev, sizeof(struct nct7904_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->client = client;\r\nmutex_init(&data->bank_lock);\r\ndata->bank_sel = -1;\r\nret = nct7904_read_reg16(data, BANK_0, FANIN_CTRL0_REG);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->fanin_mask = (ret >> 8) | ((ret & 0xff) << 8);\r\nmask = 0;\r\nret = nct7904_read_reg16(data, BANK_0, VT_ADC_CTRL0_REG);\r\nif (ret >= 0)\r\nmask = (ret >> 8) | ((ret & 0xff) << 8);\r\nret = nct7904_read_reg(data, BANK_0, VT_ADC_CTRL2_REG);\r\nif (ret >= 0)\r\nmask |= (ret << 16);\r\ndata->vsen_mask = mask;\r\nret = nct7904_read_reg16(data, BANK_0, DTS_T_CTRL0_REG);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->tcpu_mask = ((ret >> 8) & 0xf) | ((ret & 0xf) << 4);\r\nfor (i = 0; i < FANCTL_MAX; i++) {\r\nret = nct7904_read_reg(data, BANK_3, FANCTL1_FMR_REG + i);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->fan_mode[i] = ret;\r\n}\r\nhwmon_dev =\r\ndevm_hwmon_device_register_with_info(dev, client->name, data,\r\n&nct7904_chip_info, NULL);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
