static const char *dma_fence_array_get_driver_name(struct dma_fence *fence)\r\n{\r\nreturn "dma_fence_array";\r\n}\r\nstatic const char *dma_fence_array_get_timeline_name(struct dma_fence *fence)\r\n{\r\nreturn "unbound";\r\n}\r\nstatic void dma_fence_array_cb_func(struct dma_fence *f,\r\nstruct dma_fence_cb *cb)\r\n{\r\nstruct dma_fence_array_cb *array_cb =\r\ncontainer_of(cb, struct dma_fence_array_cb, cb);\r\nstruct dma_fence_array *array = array_cb->array;\r\nif (atomic_dec_and_test(&array->num_pending))\r\ndma_fence_signal(&array->base);\r\ndma_fence_put(&array->base);\r\n}\r\nstatic bool dma_fence_array_enable_signaling(struct dma_fence *fence)\r\n{\r\nstruct dma_fence_array *array = to_dma_fence_array(fence);\r\nstruct dma_fence_array_cb *cb = (void *)(&array[1]);\r\nunsigned i;\r\nfor (i = 0; i < array->num_fences; ++i) {\r\ncb[i].array = array;\r\ndma_fence_get(&array->base);\r\nif (dma_fence_add_callback(array->fences[i], &cb[i].cb,\r\ndma_fence_array_cb_func)) {\r\ndma_fence_put(&array->base);\r\nif (atomic_dec_and_test(&array->num_pending))\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic bool dma_fence_array_signaled(struct dma_fence *fence)\r\n{\r\nstruct dma_fence_array *array = to_dma_fence_array(fence);\r\nreturn atomic_read(&array->num_pending) <= 0;\r\n}\r\nstatic void dma_fence_array_release(struct dma_fence *fence)\r\n{\r\nstruct dma_fence_array *array = to_dma_fence_array(fence);\r\nunsigned i;\r\nfor (i = 0; i < array->num_fences; ++i)\r\ndma_fence_put(array->fences[i]);\r\nkfree(array->fences);\r\ndma_fence_free(fence);\r\n}\r\nstruct dma_fence_array *dma_fence_array_create(int num_fences,\r\nstruct dma_fence **fences,\r\nu64 context, unsigned seqno,\r\nbool signal_on_any)\r\n{\r\nstruct dma_fence_array *array;\r\nsize_t size = sizeof(*array);\r\nsize += num_fences * sizeof(struct dma_fence_array_cb);\r\narray = kzalloc(size, GFP_KERNEL);\r\nif (!array)\r\nreturn NULL;\r\nspin_lock_init(&array->lock);\r\ndma_fence_init(&array->base, &dma_fence_array_ops, &array->lock,\r\ncontext, seqno);\r\narray->num_fences = num_fences;\r\natomic_set(&array->num_pending, signal_on_any ? 1 : num_fences);\r\narray->fences = fences;\r\nreturn array;\r\n}
