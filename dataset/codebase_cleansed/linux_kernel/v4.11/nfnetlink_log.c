static struct nfnl_log_net *nfnl_log_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, nfnl_log_net_id);\r\n}\r\nstatic inline u_int8_t instance_hashfn(u_int16_t group_num)\r\n{\r\nreturn ((group_num & 0xff) % INSTANCE_BUCKETS);\r\n}\r\nstatic struct nfulnl_instance *\r\n__instance_lookup(struct nfnl_log_net *log, u_int16_t group_num)\r\n{\r\nstruct hlist_head *head;\r\nstruct nfulnl_instance *inst;\r\nhead = &log->instance_table[instance_hashfn(group_num)];\r\nhlist_for_each_entry_rcu(inst, head, hlist) {\r\nif (inst->group_num == group_num)\r\nreturn inst;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void\r\ninstance_get(struct nfulnl_instance *inst)\r\n{\r\natomic_inc(&inst->use);\r\n}\r\nstatic struct nfulnl_instance *\r\ninstance_lookup_get(struct nfnl_log_net *log, u_int16_t group_num)\r\n{\r\nstruct nfulnl_instance *inst;\r\nrcu_read_lock_bh();\r\ninst = __instance_lookup(log, group_num);\r\nif (inst && !atomic_inc_not_zero(&inst->use))\r\ninst = NULL;\r\nrcu_read_unlock_bh();\r\nreturn inst;\r\n}\r\nstatic void nfulnl_instance_free_rcu(struct rcu_head *head)\r\n{\r\nstruct nfulnl_instance *inst =\r\ncontainer_of(head, struct nfulnl_instance, rcu);\r\nput_net(inst->net);\r\nkfree(inst);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void\r\ninstance_put(struct nfulnl_instance *inst)\r\n{\r\nif (inst && atomic_dec_and_test(&inst->use))\r\ncall_rcu_bh(&inst->rcu, nfulnl_instance_free_rcu);\r\n}\r\nstatic struct nfulnl_instance *\r\ninstance_create(struct net *net, u_int16_t group_num,\r\nu32 portid, struct user_namespace *user_ns)\r\n{\r\nstruct nfulnl_instance *inst;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nint err;\r\nspin_lock_bh(&log->instances_lock);\r\nif (__instance_lookup(log, group_num)) {\r\nerr = -EEXIST;\r\ngoto out_unlock;\r\n}\r\ninst = kzalloc(sizeof(*inst), GFP_ATOMIC);\r\nif (!inst) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nif (!try_module_get(THIS_MODULE)) {\r\nkfree(inst);\r\nerr = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nINIT_HLIST_NODE(&inst->hlist);\r\nspin_lock_init(&inst->lock);\r\natomic_set(&inst->use, 2);\r\nsetup_timer(&inst->timer, nfulnl_timer, (unsigned long)inst);\r\ninst->net = get_net(net);\r\ninst->peer_user_ns = user_ns;\r\ninst->peer_portid = portid;\r\ninst->group_num = group_num;\r\ninst->qthreshold = NFULNL_QTHRESH_DEFAULT;\r\ninst->flushtimeout = NFULNL_TIMEOUT_DEFAULT;\r\ninst->nlbufsiz = NFULNL_NLBUFSIZ_DEFAULT;\r\ninst->copy_mode = NFULNL_COPY_PACKET;\r\ninst->copy_range = NFULNL_COPY_RANGE_MAX;\r\nhlist_add_head_rcu(&inst->hlist,\r\n&log->instance_table[instance_hashfn(group_num)]);\r\nspin_unlock_bh(&log->instances_lock);\r\nreturn inst;\r\nout_unlock:\r\nspin_unlock_bh(&log->instances_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void\r\n__instance_destroy(struct nfulnl_instance *inst)\r\n{\r\nhlist_del_rcu(&inst->hlist);\r\nspin_lock(&inst->lock);\r\ninst->copy_mode = NFULNL_COPY_DISABLED;\r\nif (inst->skb)\r\n__nfulnl_flush(inst);\r\nspin_unlock(&inst->lock);\r\ninstance_put(inst);\r\n}\r\nstatic inline void\r\ninstance_destroy(struct nfnl_log_net *log,\r\nstruct nfulnl_instance *inst)\r\n{\r\nspin_lock_bh(&log->instances_lock);\r\n__instance_destroy(inst);\r\nspin_unlock_bh(&log->instances_lock);\r\n}\r\nstatic int\r\nnfulnl_set_mode(struct nfulnl_instance *inst, u_int8_t mode,\r\nunsigned int range)\r\n{\r\nint status = 0;\r\nspin_lock_bh(&inst->lock);\r\nswitch (mode) {\r\ncase NFULNL_COPY_NONE:\r\ncase NFULNL_COPY_META:\r\ninst->copy_mode = mode;\r\ninst->copy_range = 0;\r\nbreak;\r\ncase NFULNL_COPY_PACKET:\r\ninst->copy_mode = mode;\r\nif (range == 0)\r\nrange = NFULNL_COPY_RANGE_MAX;\r\ninst->copy_range = min_t(unsigned int,\r\nrange, NFULNL_COPY_RANGE_MAX);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_bh(&inst->lock);\r\nreturn status;\r\n}\r\nstatic int\r\nnfulnl_set_nlbufsiz(struct nfulnl_instance *inst, u_int32_t nlbufsiz)\r\n{\r\nint status;\r\nspin_lock_bh(&inst->lock);\r\nif (nlbufsiz < NFULNL_NLBUFSIZ_DEFAULT)\r\nstatus = -ERANGE;\r\nelse if (nlbufsiz > 131072)\r\nstatus = -ERANGE;\r\nelse {\r\ninst->nlbufsiz = nlbufsiz;\r\nstatus = 0;\r\n}\r\nspin_unlock_bh(&inst->lock);\r\nreturn status;\r\n}\r\nstatic void\r\nnfulnl_set_timeout(struct nfulnl_instance *inst, u_int32_t timeout)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->flushtimeout = timeout;\r\nspin_unlock_bh(&inst->lock);\r\n}\r\nstatic void\r\nnfulnl_set_qthresh(struct nfulnl_instance *inst, u_int32_t qthresh)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->qthreshold = qthresh;\r\nspin_unlock_bh(&inst->lock);\r\n}\r\nstatic int\r\nnfulnl_set_flags(struct nfulnl_instance *inst, u_int16_t flags)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->flags = flags;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *\r\nnfulnl_alloc_skb(struct net *net, u32 peer_portid, unsigned int inst_size,\r\nunsigned int pkt_size)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int n;\r\nn = max(inst_size, pkt_size);\r\nskb = alloc_skb(n, GFP_ATOMIC | __GFP_NOWARN);\r\nif (!skb) {\r\nif (n > pkt_size) {\r\nskb = alloc_skb(pkt_size, GFP_ATOMIC);\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic void\r\n__nfulnl_send(struct nfulnl_instance *inst)\r\n{\r\nif (inst->qlen > 1) {\r\nstruct nlmsghdr *nlh = nlmsg_put(inst->skb, 0, 0,\r\nNLMSG_DONE,\r\nsizeof(struct nfgenmsg),\r\n0);\r\nif (WARN_ONCE(!nlh, "bad nlskb size: %u, tailroom %d\n",\r\ninst->skb->len, skb_tailroom(inst->skb))) {\r\nkfree_skb(inst->skb);\r\ngoto out;\r\n}\r\n}\r\nnfnetlink_unicast(inst->skb, inst->net, inst->peer_portid,\r\nMSG_DONTWAIT);\r\nout:\r\ninst->qlen = 0;\r\ninst->skb = NULL;\r\n}\r\nstatic void\r\n__nfulnl_flush(struct nfulnl_instance *inst)\r\n{\r\nif (del_timer(&inst->timer))\r\ninstance_put(inst);\r\nif (inst->skb)\r\n__nfulnl_send(inst);\r\n}\r\nstatic void\r\nnfulnl_timer(unsigned long data)\r\n{\r\nstruct nfulnl_instance *inst = (struct nfulnl_instance *)data;\r\nspin_lock_bh(&inst->lock);\r\nif (inst->skb)\r\n__nfulnl_send(inst);\r\nspin_unlock_bh(&inst->lock);\r\ninstance_put(inst);\r\n}\r\nstatic inline int\r\n__build_packet_message(struct nfnl_log_net *log,\r\nstruct nfulnl_instance *inst,\r\nconst struct sk_buff *skb,\r\nunsigned int data_len,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct net_device *indev,\r\nconst struct net_device *outdev,\r\nconst char *prefix, unsigned int plen,\r\nconst struct nfnl_ct_hook *nfnl_ct,\r\nstruct nf_conn *ct, enum ip_conntrack_info ctinfo)\r\n{\r\nstruct nfulnl_msg_packet_hdr pmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nsk_buff_data_t old_tail = inst->skb->tail;\r\nstruct sock *sk;\r\nconst unsigned char *hwhdrp;\r\nnlh = nlmsg_put(inst->skb, 0, 0,\r\nNFNL_SUBSYS_ULOG << 8 | NFULNL_MSG_PACKET,\r\nsizeof(struct nfgenmsg), 0);\r\nif (!nlh)\r\nreturn -1;\r\nnfmsg = nlmsg_data(nlh);\r\nnfmsg->nfgen_family = pf;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(inst->group_num);\r\nmemset(&pmsg, 0, sizeof(pmsg));\r\npmsg.hw_protocol = skb->protocol;\r\npmsg.hook = hooknum;\r\nif (nla_put(inst->skb, NFULA_PACKET_HDR, sizeof(pmsg), &pmsg))\r\ngoto nla_put_failure;\r\nif (prefix &&\r\nnla_put(inst->skb, NFULA_PREFIX, plen, prefix))\r\ngoto nla_put_failure;\r\nif (indev) {\r\n#if !IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(indev->ifindex)))\r\ngoto nla_put_failure;\r\n#else\r\nif (pf == PF_BRIDGE) {\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\r\nhtonl(indev->ifindex)) ||\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(br_port_get_rcu(indev)->br->dev->ifindex)))\r\ngoto nla_put_failure;\r\n} else {\r\nstruct net_device *physindev;\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(indev->ifindex)))\r\ngoto nla_put_failure;\r\nphysindev = nf_bridge_get_physindev(skb);\r\nif (physindev &&\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\r\nhtonl(physindev->ifindex)))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\n}\r\nif (outdev) {\r\n#if !IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(outdev->ifindex)))\r\ngoto nla_put_failure;\r\n#else\r\nif (pf == PF_BRIDGE) {\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\r\nhtonl(outdev->ifindex)) ||\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(br_port_get_rcu(outdev)->br->dev->ifindex)))\r\ngoto nla_put_failure;\r\n} else {\r\nstruct net_device *physoutdev;\r\nif (nla_put_be32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(outdev->ifindex)))\r\ngoto nla_put_failure;\r\nphysoutdev = nf_bridge_get_physoutdev(skb);\r\nif (physoutdev &&\r\nnla_put_be32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\r\nhtonl(physoutdev->ifindex)))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\n}\r\nif (skb->mark &&\r\nnla_put_be32(inst->skb, NFULA_MARK, htonl(skb->mark)))\r\ngoto nla_put_failure;\r\nif (indev && skb->dev &&\r\nskb->mac_header != skb->network_header) {\r\nstruct nfulnl_msg_packet_hw phw;\r\nint len;\r\nmemset(&phw, 0, sizeof(phw));\r\nlen = dev_parse_header(skb, phw.hw_addr);\r\nif (len > 0) {\r\nphw.hw_addrlen = htons(len);\r\nif (nla_put(inst->skb, NFULA_HWADDR, sizeof(phw), &phw))\r\ngoto nla_put_failure;\r\n}\r\n}\r\nif (indev && skb_mac_header_was_set(skb)) {\r\nif (nla_put_be16(inst->skb, NFULA_HWTYPE, htons(skb->dev->type)) ||\r\nnla_put_be16(inst->skb, NFULA_HWLEN,\r\nhtons(skb->dev->hard_header_len)))\r\ngoto nla_put_failure;\r\nhwhdrp = skb_mac_header(skb);\r\nif (skb->dev->type == ARPHRD_SIT)\r\nhwhdrp -= ETH_HLEN;\r\nif (hwhdrp >= skb->head &&\r\nnla_put(inst->skb, NFULA_HWHEADER,\r\nskb->dev->hard_header_len, hwhdrp))\r\ngoto nla_put_failure;\r\n}\r\nif (skb->tstamp) {\r\nstruct nfulnl_msg_packet_timestamp ts;\r\nstruct timespec64 kts = ktime_to_timespec64(skb->tstamp);\r\nts.sec = cpu_to_be64(kts.tv_sec);\r\nts.usec = cpu_to_be64(kts.tv_nsec / NSEC_PER_USEC);\r\nif (nla_put(inst->skb, NFULA_TIMESTAMP, sizeof(ts), &ts))\r\ngoto nla_put_failure;\r\n}\r\nsk = skb->sk;\r\nif (sk && sk_fullsock(sk)) {\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_socket && sk->sk_socket->file) {\r\nstruct file *file = sk->sk_socket->file;\r\nconst struct cred *cred = file->f_cred;\r\nstruct user_namespace *user_ns = inst->peer_user_ns;\r\n__be32 uid = htonl(from_kuid_munged(user_ns, cred->fsuid));\r\n__be32 gid = htonl(from_kgid_munged(user_ns, cred->fsgid));\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (nla_put_be32(inst->skb, NFULA_UID, uid) ||\r\nnla_put_be32(inst->skb, NFULA_GID, gid))\r\ngoto nla_put_failure;\r\n} else\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nif ((inst->flags & NFULNL_CFG_F_SEQ) &&\r\nnla_put_be32(inst->skb, NFULA_SEQ, htonl(inst->seq++)))\r\ngoto nla_put_failure;\r\nif ((inst->flags & NFULNL_CFG_F_SEQ_GLOBAL) &&\r\nnla_put_be32(inst->skb, NFULA_SEQ_GLOBAL,\r\nhtonl(atomic_inc_return(&log->global_seq))))\r\ngoto nla_put_failure;\r\nif (ct && nfnl_ct->build(inst->skb, ct, ctinfo,\r\nNFULA_CT, NFULA_CT_INFO) < 0)\r\ngoto nla_put_failure;\r\nif (data_len) {\r\nstruct nlattr *nla;\r\nint size = nla_attr_size(data_len);\r\nif (skb_tailroom(inst->skb) < nla_total_size(data_len))\r\ngoto nla_put_failure;\r\nnla = (struct nlattr *)skb_put(inst->skb, nla_total_size(data_len));\r\nnla->nla_type = NFULA_PAYLOAD;\r\nnla->nla_len = size;\r\nif (skb_copy_bits(skb, 0, nla_data(nla), data_len))\r\nBUG();\r\n}\r\nnlh->nlmsg_len = inst->skb->tail - old_tail;\r\nreturn 0;\r\nnla_put_failure:\r\nPRINTR(KERN_ERR "nfnetlink_log: error creating log nlmsg\n");\r\nreturn -1;\r\n}\r\nvoid\r\nnfulnl_log_packet(struct net *net,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *li_user,\r\nconst char *prefix)\r\n{\r\nsize_t size;\r\nunsigned int data_len;\r\nstruct nfulnl_instance *inst;\r\nconst struct nf_loginfo *li;\r\nunsigned int qthreshold;\r\nunsigned int plen;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nconst struct nfnl_ct_hook *nfnl_ct = NULL;\r\nstruct nf_conn *ct = NULL;\r\nenum ip_conntrack_info uninitialized_var(ctinfo);\r\nif (li_user && li_user->type == NF_LOG_TYPE_ULOG)\r\nli = li_user;\r\nelse\r\nli = &default_loginfo;\r\ninst = instance_lookup_get(log, li->u.ulog.group);\r\nif (!inst)\r\nreturn;\r\nplen = 0;\r\nif (prefix)\r\nplen = strlen(prefix) + 1;\r\nsize = nlmsg_total_size(sizeof(struct nfgenmsg))\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_hdr))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(plen)\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_hw))\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_timestamp))\r\n+ nla_total_size(sizeof(struct nfgenmsg));\r\nif (in && skb_mac_header_was_set(skb)) {\r\nsize += nla_total_size(skb->dev->hard_header_len)\r\n+ nla_total_size(sizeof(u_int16_t))\r\n+ nla_total_size(sizeof(u_int16_t));\r\n}\r\nspin_lock_bh(&inst->lock);\r\nif (inst->flags & NFULNL_CFG_F_SEQ)\r\nsize += nla_total_size(sizeof(u_int32_t));\r\nif (inst->flags & NFULNL_CFG_F_SEQ_GLOBAL)\r\nsize += nla_total_size(sizeof(u_int32_t));\r\nif (inst->flags & NFULNL_CFG_F_CONNTRACK) {\r\nnfnl_ct = rcu_dereference(nfnl_ct_hook);\r\nif (nfnl_ct != NULL) {\r\nct = nfnl_ct->get_ct(skb, &ctinfo);\r\nif (ct != NULL)\r\nsize += nfnl_ct->build_size(ct);\r\n}\r\n}\r\nqthreshold = inst->qthreshold;\r\nif (li->u.ulog.qthreshold)\r\nif (qthreshold > li->u.ulog.qthreshold)\r\nqthreshold = li->u.ulog.qthreshold;\r\nswitch (inst->copy_mode) {\r\ncase NFULNL_COPY_META:\r\ncase NFULNL_COPY_NONE:\r\ndata_len = 0;\r\nbreak;\r\ncase NFULNL_COPY_PACKET:\r\ndata_len = inst->copy_range;\r\nif ((li->u.ulog.flags & NF_LOG_F_COPY_LEN) &&\r\n(li->u.ulog.copy_len < data_len))\r\ndata_len = li->u.ulog.copy_len;\r\nif (data_len > skb->len)\r\ndata_len = skb->len;\r\nsize += nla_total_size(data_len);\r\nbreak;\r\ncase NFULNL_COPY_DISABLED:\r\ndefault:\r\ngoto unlock_and_release;\r\n}\r\nif (inst->skb && size > skb_tailroom(inst->skb)) {\r\n__nfulnl_flush(inst);\r\n}\r\nif (!inst->skb) {\r\ninst->skb = nfulnl_alloc_skb(net, inst->peer_portid,\r\ninst->nlbufsiz, size);\r\nif (!inst->skb)\r\ngoto alloc_failure;\r\n}\r\ninst->qlen++;\r\n__build_packet_message(log, inst, skb, data_len, pf,\r\nhooknum, in, out, prefix, plen,\r\nnfnl_ct, ct, ctinfo);\r\nif (inst->qlen >= qthreshold)\r\n__nfulnl_flush(inst);\r\nelse if (!timer_pending(&inst->timer)) {\r\ninstance_get(inst);\r\ninst->timer.expires = jiffies + (inst->flushtimeout*HZ/100);\r\nadd_timer(&inst->timer);\r\n}\r\nunlock_and_release:\r\nspin_unlock_bh(&inst->lock);\r\ninstance_put(inst);\r\nreturn;\r\nalloc_failure:\r\ngoto unlock_and_release;\r\n}\r\nstatic int\r\nnfulnl_rcv_nl_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct netlink_notify *n = ptr;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(n->net);\r\nif (event == NETLINK_URELEASE && n->protocol == NETLINK_NETFILTER) {\r\nint i;\r\nspin_lock_bh(&log->instances_lock);\r\nfor (i = 0; i < INSTANCE_BUCKETS; i++) {\r\nstruct hlist_node *t2;\r\nstruct nfulnl_instance *inst;\r\nstruct hlist_head *head = &log->instance_table[i];\r\nhlist_for_each_entry_safe(inst, t2, head, hlist) {\r\nif (n->portid == inst->peer_portid)\r\n__instance_destroy(inst);\r\n}\r\n}\r\nspin_unlock_bh(&log->instances_lock);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int nfulnl_recv_unsupp(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nfqa[])\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int nfulnl_recv_config(struct net *net, struct sock *ctnl,\r\nstruct sk_buff *skb, const struct nlmsghdr *nlh,\r\nconst struct nlattr * const nfula[])\r\n{\r\nstruct nfgenmsg *nfmsg = nlmsg_data(nlh);\r\nu_int16_t group_num = ntohs(nfmsg->res_id);\r\nstruct nfulnl_instance *inst;\r\nstruct nfulnl_msg_config_cmd *cmd = NULL;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\nint ret = 0;\r\nu16 flags = 0;\r\nif (nfula[NFULA_CFG_CMD]) {\r\nu_int8_t pf = nfmsg->nfgen_family;\r\ncmd = nla_data(nfula[NFULA_CFG_CMD]);\r\nswitch (cmd->command) {\r\ncase NFULNL_CFG_CMD_PF_BIND:\r\nreturn nf_log_bind_pf(net, pf, &nfulnl_logger);\r\ncase NFULNL_CFG_CMD_PF_UNBIND:\r\nnf_log_unbind_pf(net, pf);\r\nreturn 0;\r\n}\r\n}\r\ninst = instance_lookup_get(log, group_num);\r\nif (inst && inst->peer_portid != NETLINK_CB(skb).portid) {\r\nret = -EPERM;\r\ngoto out_put;\r\n}\r\nif (nfula[NFULA_CFG_FLAGS]) {\r\nflags = ntohs(nla_get_be16(nfula[NFULA_CFG_FLAGS]));\r\nif ((flags & NFULNL_CFG_F_CONNTRACK) &&\r\n!rcu_access_pointer(nfnl_ct_hook)) {\r\n#ifdef CONFIG_MODULES\r\nnfnl_unlock(NFNL_SUBSYS_ULOG);\r\nrequest_module("ip_conntrack_netlink");\r\nnfnl_lock(NFNL_SUBSYS_ULOG);\r\nif (rcu_access_pointer(nfnl_ct_hook)) {\r\nret = -EAGAIN;\r\ngoto out_put;\r\n}\r\n#endif\r\nret = -EOPNOTSUPP;\r\ngoto out_put;\r\n}\r\n}\r\nif (cmd != NULL) {\r\nswitch (cmd->command) {\r\ncase NFULNL_CFG_CMD_BIND:\r\nif (inst) {\r\nret = -EBUSY;\r\ngoto out_put;\r\n}\r\ninst = instance_create(net, group_num,\r\nNETLINK_CB(skb).portid,\r\nsk_user_ns(NETLINK_CB(skb).sk));\r\nif (IS_ERR(inst)) {\r\nret = PTR_ERR(inst);\r\ngoto out;\r\n}\r\nbreak;\r\ncase NFULNL_CFG_CMD_UNBIND:\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ninstance_destroy(log, inst);\r\ngoto out_put;\r\ndefault:\r\nret = -ENOTSUPP;\r\ngoto out_put;\r\n}\r\n} else if (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (nfula[NFULA_CFG_MODE]) {\r\nstruct nfulnl_msg_config_mode *params =\r\nnla_data(nfula[NFULA_CFG_MODE]);\r\nnfulnl_set_mode(inst, params->copy_mode,\r\nntohl(params->copy_range));\r\n}\r\nif (nfula[NFULA_CFG_TIMEOUT]) {\r\n__be32 timeout = nla_get_be32(nfula[NFULA_CFG_TIMEOUT]);\r\nnfulnl_set_timeout(inst, ntohl(timeout));\r\n}\r\nif (nfula[NFULA_CFG_NLBUFSIZ]) {\r\n__be32 nlbufsiz = nla_get_be32(nfula[NFULA_CFG_NLBUFSIZ]);\r\nnfulnl_set_nlbufsiz(inst, ntohl(nlbufsiz));\r\n}\r\nif (nfula[NFULA_CFG_QTHRESH]) {\r\n__be32 qthresh = nla_get_be32(nfula[NFULA_CFG_QTHRESH]);\r\nnfulnl_set_qthresh(inst, ntohl(qthresh));\r\n}\r\nif (nfula[NFULA_CFG_FLAGS])\r\nnfulnl_set_flags(inst, flags);\r\nout_put:\r\ninstance_put(inst);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct hlist_node *get_first(struct net *net, struct iter_state *st)\r\n{\r\nstruct nfnl_log_net *log;\r\nif (!st)\r\nreturn NULL;\r\nlog = nfnl_log_pernet(net);\r\nfor (st->bucket = 0; st->bucket < INSTANCE_BUCKETS; st->bucket++) {\r\nstruct hlist_head *head = &log->instance_table[st->bucket];\r\nif (!hlist_empty(head))\r\nreturn rcu_dereference_bh(hlist_first_rcu(head));\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_node *get_next(struct net *net, struct iter_state *st,\r\nstruct hlist_node *h)\r\n{\r\nh = rcu_dereference_bh(hlist_next_rcu(h));\r\nwhile (!h) {\r\nstruct nfnl_log_net *log;\r\nstruct hlist_head *head;\r\nif (++st->bucket >= INSTANCE_BUCKETS)\r\nreturn NULL;\r\nlog = nfnl_log_pernet(net);\r\nhead = &log->instance_table[st->bucket];\r\nh = rcu_dereference_bh(hlist_first_rcu(head));\r\n}\r\nreturn h;\r\n}\r\nstatic struct hlist_node *get_idx(struct net *net, struct iter_state *st,\r\nloff_t pos)\r\n{\r\nstruct hlist_node *head;\r\nhead = get_first(net, st);\r\nif (head)\r\nwhile (pos && (head = get_next(net, st, head)))\r\npos--;\r\nreturn pos ? NULL : head;\r\n}\r\nstatic void *seq_start(struct seq_file *s, loff_t *pos)\r\n__acquires(rcu_bh)\r\n{\r\nrcu_read_lock_bh();\r\nreturn get_idx(seq_file_net(s), s->private, *pos);\r\n}\r\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn get_next(seq_file_net(s), s->private, v);\r\n}\r\nstatic void seq_stop(struct seq_file *s, void *v)\r\n__releases(rcu_bh)\r\n{\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int seq_show(struct seq_file *s, void *v)\r\n{\r\nconst struct nfulnl_instance *inst = v;\r\nseq_printf(s, "%5u %6u %5u %1u %5u %6u %2u\n",\r\ninst->group_num,\r\ninst->peer_portid, inst->qlen,\r\ninst->copy_mode, inst->copy_range,\r\ninst->flushtimeout, atomic_read(&inst->use));\r\nreturn 0;\r\n}\r\nstatic int nful_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &nful_seq_ops,\r\nsizeof(struct iter_state));\r\n}\r\nstatic int __net_init nfnl_log_net_init(struct net *net)\r\n{\r\nunsigned int i;\r\nstruct nfnl_log_net *log = nfnl_log_pernet(net);\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *proc;\r\nkuid_t root_uid;\r\nkgid_t root_gid;\r\n#endif\r\nfor (i = 0; i < INSTANCE_BUCKETS; i++)\r\nINIT_HLIST_HEAD(&log->instance_table[i]);\r\nspin_lock_init(&log->instances_lock);\r\n#ifdef CONFIG_PROC_FS\r\nproc = proc_create("nfnetlink_log", 0440,\r\nnet->nf.proc_netfilter, &nful_file_ops);\r\nif (!proc)\r\nreturn -ENOMEM;\r\nroot_uid = make_kuid(net->user_ns, 0);\r\nroot_gid = make_kgid(net->user_ns, 0);\r\nif (uid_valid(root_uid) && gid_valid(root_gid))\r\nproc_set_user(proc, root_uid, root_gid);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __net_exit nfnl_log_net_exit(struct net *net)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nfnetlink_log", net->nf.proc_netfilter);\r\n#endif\r\nnf_log_unset(net, &nfulnl_logger);\r\n}\r\nstatic int __init nfnetlink_log_init(void)\r\n{\r\nint status;\r\nstatus = register_pernet_subsys(&nfnl_log_net_ops);\r\nif (status < 0) {\r\npr_err("failed to register pernet ops\n");\r\ngoto out;\r\n}\r\nnetlink_register_notifier(&nfulnl_rtnl_notifier);\r\nstatus = nfnetlink_subsys_register(&nfulnl_subsys);\r\nif (status < 0) {\r\npr_err("failed to create netlink socket\n");\r\ngoto cleanup_netlink_notifier;\r\n}\r\nstatus = nf_log_register(NFPROTO_UNSPEC, &nfulnl_logger);\r\nif (status < 0) {\r\npr_err("failed to register logger\n");\r\ngoto cleanup_subsys;\r\n}\r\nreturn status;\r\ncleanup_subsys:\r\nnfnetlink_subsys_unregister(&nfulnl_subsys);\r\ncleanup_netlink_notifier:\r\nnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\r\nunregister_pernet_subsys(&nfnl_log_net_ops);\r\nout:\r\nreturn status;\r\n}\r\nstatic void __exit nfnetlink_log_fini(void)\r\n{\r\nnf_log_unregister(&nfulnl_logger);\r\nnfnetlink_subsys_unregister(&nfulnl_subsys);\r\nnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\r\nunregister_pernet_subsys(&nfnl_log_net_ops);\r\n}
