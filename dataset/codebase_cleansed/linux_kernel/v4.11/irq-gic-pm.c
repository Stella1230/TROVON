static int gic_runtime_resume(struct device *dev)\r\n{\r\nstruct gic_chip_data *gic = dev_get_drvdata(dev);\r\nint ret;\r\nret = pm_clk_resume(dev);\r\nif (ret)\r\nreturn ret;\r\nif (!gic)\r\nreturn 0;\r\ngic_dist_restore(gic);\r\ngic_cpu_restore(gic);\r\nreturn 0;\r\n}\r\nstatic int gic_runtime_suspend(struct device *dev)\r\n{\r\nstruct gic_chip_data *gic = dev_get_drvdata(dev);\r\ngic_dist_save(gic);\r\ngic_cpu_save(gic);\r\nreturn pm_clk_suspend(dev);\r\n}\r\nstatic int gic_get_clocks(struct device *dev, const struct gic_clk_data *data)\r\n{\r\nunsigned int i;\r\nint ret;\r\nif (!dev || !data)\r\nreturn -EINVAL;\r\nret = pm_clk_create(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < data->num_clocks; i++) {\r\nret = of_pm_clk_add_clk(dev, data->clocks[i]);\r\nif (ret) {\r\ndev_err(dev, "failed to add clock %s\n",\r\ndata->clocks[i]);\r\npm_clk_destroy(dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gic_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct gic_clk_data *data;\r\nstruct gic_chip_data *gic;\r\nint ret, irq;\r\ndata = of_device_get_match_data(&pdev->dev);\r\nif (!data) {\r\ndev_err(&pdev->dev, "no device match found\n");\r\nreturn -ENODEV;\r\n}\r\nirq = irq_of_parse_and_map(dev->of_node, 0);\r\nif (!irq) {\r\ndev_err(dev, "no parent interrupt found!\n");\r\nreturn -EINVAL;\r\n}\r\nret = gic_get_clocks(dev, data);\r\nif (ret)\r\ngoto irq_dispose;\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0)\r\ngoto rpm_disable;\r\nret = gic_of_init_child(dev, &gic, irq);\r\nif (ret)\r\ngoto rpm_put;\r\nplatform_set_drvdata(pdev, gic);\r\npm_runtime_put(dev);\r\ndev_info(dev, "GIC IRQ controller registered\n");\r\nreturn 0;\r\nrpm_put:\r\npm_runtime_put_sync(dev);\r\nrpm_disable:\r\npm_runtime_disable(dev);\r\npm_clk_destroy(dev);\r\nirq_dispose:\r\nirq_dispose_mapping(irq);\r\nreturn ret;\r\n}
