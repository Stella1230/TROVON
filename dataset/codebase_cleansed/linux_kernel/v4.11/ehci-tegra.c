static int tegra_reset_usb_controller(struct platform_device *pdev)\r\n{\r\nstruct device_node *phy_np;\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct tegra_ehci_hcd *tegra =\r\n(struct tegra_ehci_hcd *)hcd_to_ehci(hcd)->priv;\r\nbool has_utmi_pad_registers = false;\r\nphy_np = of_parse_phandle(pdev->dev.of_node, "nvidia,phy", 0);\r\nif (!phy_np)\r\nreturn -ENOENT;\r\nif (of_property_read_bool(phy_np, "nvidia,has-utmi-pad-registers"))\r\nhas_utmi_pad_registers = true;\r\nif (!usb1_reset_attempted) {\r\nstruct reset_control *usb1_reset;\r\nif (!has_utmi_pad_registers)\r\nusb1_reset = of_reset_control_get(phy_np, "utmi-pads");\r\nelse\r\nusb1_reset = tegra->rst;\r\nif (IS_ERR(usb1_reset)) {\r\ndev_warn(&pdev->dev,\r\n"can't get utmi-pads reset from the PHY\n");\r\ndev_warn(&pdev->dev,\r\n"continuing, but please update your DT\n");\r\n} else {\r\nreset_control_assert(usb1_reset);\r\nudelay(1);\r\nreset_control_deassert(usb1_reset);\r\nif (!has_utmi_pad_registers)\r\nreset_control_put(usb1_reset);\r\n}\r\nusb1_reset_attempted = true;\r\n}\r\nif (!has_utmi_pad_registers) {\r\nreset_control_assert(tegra->rst);\r\nudelay(1);\r\nreset_control_deassert(tegra->rst);\r\n}\r\nof_node_put(phy_np);\r\nreturn 0;\r\n}\r\nstatic int tegra_ehci_internal_port_reset(\r\nstruct ehci_hcd *ehci,\r\nu32 __iomem *portsc_reg\r\n)\r\n{\r\nu32 temp;\r\nunsigned long flags;\r\nint retval = 0;\r\nint i, tries;\r\nu32 saved_usbintr;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nsaved_usbintr = ehci_readl(ehci, &ehci->regs->intr_enable);\r\nehci_writel(ehci, 0, &ehci->regs->intr_enable);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nfor (i = 0; i < 2; i++) {\r\ntemp = ehci_readl(ehci, portsc_reg);\r\ntemp |= PORT_RESET;\r\nehci_writel(ehci, temp, portsc_reg);\r\nmdelay(10);\r\ntemp &= ~PORT_RESET;\r\nehci_writel(ehci, temp, portsc_reg);\r\nmdelay(1);\r\ntries = 100;\r\ndo {\r\nmdelay(1);\r\ntemp = ehci_readl(ehci, portsc_reg);\r\n} while (!(temp & PORT_PE) && tries--);\r\nif (temp & PORT_PE)\r\nbreak;\r\n}\r\nif (i == 2)\r\nretval = -ETIMEDOUT;\r\nif (temp & PORT_CSC)\r\nehci_writel(ehci, PORT_CSC, portsc_reg);\r\ntemp = ehci_readl(ehci, &ehci->regs->status);\r\nehci_writel(ehci, temp, &ehci->regs->status);\r\nehci_writel(ehci, saved_usbintr, &ehci->regs->intr_enable);\r\nreturn retval;\r\n}\r\nstatic int tegra_ehci_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct tegra_ehci_hcd *tegra = (struct tegra_ehci_hcd *)ehci->priv;\r\nu32 __iomem *status_reg;\r\nu32 temp;\r\nunsigned long flags;\r\nint retval = 0;\r\nstatus_reg = &ehci->regs->port_status[(wIndex & 0xff) - 1];\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (typeReq == GetPortStatus) {\r\ntemp = ehci_readl(ehci, status_reg);\r\nif (tegra->port_resuming && !(temp & PORT_SUSPEND)) {\r\ntegra->port_resuming = 0;\r\ntegra_usb_phy_postresume(hcd->usb_phy);\r\n}\r\n}\r\nelse if (typeReq == SetPortFeature && wValue == USB_PORT_FEAT_SUSPEND) {\r\ntemp = ehci_readl(ehci, status_reg);\r\nif ((temp & PORT_PE) == 0 || (temp & PORT_RESET) != 0) {\r\nretval = -EPIPE;\r\ngoto done;\r\n}\r\ntemp &= ~(PORT_RWC_BITS | PORT_WKCONN_E);\r\ntemp |= PORT_WKDISC_E | PORT_WKOC_E;\r\nehci_writel(ehci, temp | PORT_SUSPEND, status_reg);\r\nif (ehci_handshake(ehci, status_reg, PORT_SUSPEND,\r\nPORT_SUSPEND, 5000))\r\npr_err("%s: timeout waiting for SUSPEND\n", __func__);\r\nset_bit((wIndex & 0xff) - 1, &ehci->suspended_ports);\r\ngoto done;\r\n}\r\nif (tegra->needs_double_reset &&\r\n(typeReq == SetPortFeature && wValue == USB_PORT_FEAT_RESET)) {\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn tegra_ehci_internal_port_reset(ehci, status_reg);\r\n}\r\nelse if (typeReq == ClearPortFeature &&\r\nwValue == USB_PORT_FEAT_SUSPEND) {\r\ntemp = ehci_readl(ehci, status_reg);\r\nif ((temp & PORT_RESET) || !(temp & PORT_PE)) {\r\nretval = -EPIPE;\r\ngoto done;\r\n}\r\nif (!(temp & PORT_SUSPEND))\r\ngoto done;\r\ntegra_usb_phy_preresume(hcd->usb_phy);\r\nehci->reset_done[wIndex-1] = jiffies + msecs_to_jiffies(25);\r\ntemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\r\nehci_writel(ehci, temp | PORT_RESUME, status_reg);\r\nset_bit(wIndex-1, &ehci->resuming_ports);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nmsleep(20);\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nif (ehci_handshake(ehci, status_reg, PORT_RESUME, 0, 2000))\r\npr_err("%s: timeout waiting for RESUME\n", __func__);\r\nif (ehci_handshake(ehci, status_reg, PORT_SUSPEND, 0, 2000))\r\npr_err("%s: timeout waiting for SUSPEND\n", __func__);\r\nehci->reset_done[wIndex-1] = 0;\r\nclear_bit(wIndex-1, &ehci->resuming_ports);\r\ntegra->port_resuming = 1;\r\ngoto done;\r\n}\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\r\ndone:\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void free_dma_aligned_buffer(struct urb *urb)\r\n{\r\nstruct dma_aligned_buffer *temp;\r\nsize_t length;\r\nif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\r\nreturn;\r\ntemp = container_of(urb->transfer_buffer,\r\nstruct dma_aligned_buffer, data);\r\nif (usb_urb_dir_in(urb)) {\r\nif (usb_pipeisoc(urb->pipe))\r\nlength = urb->transfer_buffer_length;\r\nelse\r\nlength = urb->actual_length;\r\nmemcpy(temp->old_xfer_buffer, temp->data, length);\r\n}\r\nurb->transfer_buffer = temp->old_xfer_buffer;\r\nkfree(temp->kmalloc_ptr);\r\nurb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\r\n}\r\nstatic int alloc_dma_aligned_buffer(struct urb *urb, gfp_t mem_flags)\r\n{\r\nstruct dma_aligned_buffer *temp, *kmalloc_ptr;\r\nsize_t kmalloc_size;\r\nif (urb->num_sgs || urb->sg ||\r\nurb->transfer_buffer_length == 0 ||\r\n!((uintptr_t)urb->transfer_buffer & (TEGRA_USB_DMA_ALIGN - 1)))\r\nreturn 0;\r\nkmalloc_size = urb->transfer_buffer_length +\r\nsizeof(struct dma_aligned_buffer) + TEGRA_USB_DMA_ALIGN - 1;\r\nkmalloc_ptr = kmalloc(kmalloc_size, mem_flags);\r\nif (!kmalloc_ptr)\r\nreturn -ENOMEM;\r\ntemp = PTR_ALIGN(kmalloc_ptr + 1, TEGRA_USB_DMA_ALIGN) - 1;\r\ntemp->kmalloc_ptr = kmalloc_ptr;\r\ntemp->old_xfer_buffer = urb->transfer_buffer;\r\nif (usb_urb_dir_out(urb))\r\nmemcpy(temp->data, urb->transfer_buffer,\r\nurb->transfer_buffer_length);\r\nurb->transfer_buffer = temp->data;\r\nurb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\r\nreturn 0;\r\n}\r\nstatic int tegra_ehci_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint ret;\r\nret = alloc_dma_aligned_buffer(urb, mem_flags);\r\nif (ret)\r\nreturn ret;\r\nret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\r\nif (ret)\r\nfree_dma_aligned_buffer(urb);\r\nreturn ret;\r\n}\r\nstatic void tegra_ehci_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nusb_hcd_unmap_urb_for_dma(hcd, urb);\r\nfree_dma_aligned_buffer(urb);\r\n}\r\nstatic int tegra_ehci_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct tegra_ehci_soc_config *soc_config;\r\nstruct resource *res;\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct tegra_ehci_hcd *tegra;\r\nint err = 0;\r\nint irq;\r\nstruct usb_phy *u_phy;\r\nmatch = of_match_device(tegra_ehci_of_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\nsoc_config = match->data;\r\nerr = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err)\r\nreturn err;\r\nhcd = usb_create_hcd(&tegra_ehci_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!hcd) {\r\ndev_err(&pdev->dev, "Unable to create HCD\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, hcd);\r\nehci = hcd_to_ehci(hcd);\r\ntegra = (struct tegra_ehci_hcd *)ehci->priv;\r\nhcd->has_tt = 1;\r\ntegra->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tegra->clk)) {\r\ndev_err(&pdev->dev, "Can't get ehci clock\n");\r\nerr = PTR_ERR(tegra->clk);\r\ngoto cleanup_hcd_create;\r\n}\r\ntegra->rst = devm_reset_control_get(&pdev->dev, "usb");\r\nif (IS_ERR(tegra->rst)) {\r\ndev_err(&pdev->dev, "Can't get ehci reset\n");\r\nerr = PTR_ERR(tegra->rst);\r\ngoto cleanup_hcd_create;\r\n}\r\nerr = clk_prepare_enable(tegra->clk);\r\nif (err)\r\ngoto cleanup_hcd_create;\r\nerr = tegra_reset_usb_controller(pdev);\r\nif (err)\r\ngoto cleanup_clk_en;\r\nu_phy = devm_usb_get_phy_by_phandle(&pdev->dev, "nvidia,phy", 0);\r\nif (IS_ERR(u_phy)) {\r\nerr = -EPROBE_DEFER;\r\ngoto cleanup_clk_en;\r\n}\r\nhcd->usb_phy = u_phy;\r\ntegra->needs_double_reset = of_property_read_bool(pdev->dev.of_node,\r\n"nvidia,needs-double-reset");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nerr = PTR_ERR(hcd->regs);\r\ngoto cleanup_clk_en;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nehci->caps = hcd->regs + 0x100;\r\nehci->has_hostpc = soc_config->has_hostpc;\r\nerr = usb_phy_init(hcd->usb_phy);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to initialize phy\n");\r\ngoto cleanup_clk_en;\r\n}\r\nu_phy->otg = devm_kzalloc(&pdev->dev, sizeof(struct usb_otg),\r\nGFP_KERNEL);\r\nif (!u_phy->otg) {\r\nerr = -ENOMEM;\r\ngoto cleanup_phy;\r\n}\r\nu_phy->otg->host = hcd_to_bus(hcd);\r\nerr = usb_phy_set_suspend(hcd->usb_phy, 0);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to power on the phy\n");\r\ngoto cleanup_phy;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "Failed to get IRQ\n");\r\nerr = -ENODEV;\r\ngoto cleanup_phy;\r\n}\r\notg_set_host(u_phy->otg, &hcd->self);\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to add USB HCD\n");\r\ngoto cleanup_otg_set_host;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn err;\r\ncleanup_otg_set_host:\r\notg_set_host(u_phy->otg, NULL);\r\ncleanup_phy:\r\nusb_phy_shutdown(hcd->usb_phy);\r\ncleanup_clk_en:\r\nclk_disable_unprepare(tegra->clk);\r\ncleanup_hcd_create:\r\nusb_put_hcd(hcd);\r\nreturn err;\r\n}\r\nstatic int tegra_ehci_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct tegra_ehci_hcd *tegra =\r\n(struct tegra_ehci_hcd *)hcd_to_ehci(hcd)->priv;\r\notg_set_host(hcd->usb_phy->otg, NULL);\r\nusb_phy_shutdown(hcd->usb_phy);\r\nusb_remove_hcd(hcd);\r\nclk_disable_unprepare(tegra->clk);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic void tegra_ehci_hcd_shutdown(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}\r\nstatic int tegra_ehci_reset(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nint txfifothresh;\r\nretval = ehci_setup(hcd);\r\nif (retval)\r\nreturn retval;\r\ntxfifothresh = ehci->has_hostpc ? 0x10 : 10;\r\nehci_writel(ehci, txfifothresh << 16, &ehci->regs->txfill_tuning);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_tegra_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info(DRV_NAME ": " DRIVER_DESC "\n");\r\nehci_init_driver(&tegra_ehci_hc_driver, &tegra_overrides);\r\ntegra_ehci_hc_driver.map_urb_for_dma = tegra_ehci_map_urb_for_dma;\r\ntegra_ehci_hc_driver.unmap_urb_for_dma = tegra_ehci_unmap_urb_for_dma;\r\ntegra_ehci_hc_driver.hub_control = tegra_ehci_hub_control;\r\nreturn platform_driver_register(&tegra_ehci_driver);\r\n}\r\nstatic void __exit ehci_tegra_cleanup(void)\r\n{\r\nplatform_driver_unregister(&tegra_ehci_driver);\r\n}
