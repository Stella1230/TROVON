static int mtk_reg_read(void *context,\r\nunsigned int reg, void *_val, size_t bytes)\r\n{\r\nvoid __iomem *base = context;\r\nu32 *val = _val;\r\nint i = 0, words = bytes / 4;\r\nwhile (words--)\r\n*val++ = readl(base + reg + (i++ * 4));\r\nreturn 0;\r\n}\r\nstatic int mtk_reg_write(void *context,\r\nunsigned int reg, void *_val, size_t bytes)\r\n{\r\nvoid __iomem *base = context;\r\nu32 *val = _val;\r\nint i = 0, words = bytes / 4;\r\nwhile (words--)\r\nwritel(*val++, base + reg + (i++ * 4));\r\nreturn 0;\r\n}\r\nstatic int mtk_efuse_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct nvmem_device *nvmem;\r\nstruct nvmem_config *econfig;\r\nvoid __iomem *base;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\neconfig = devm_kzalloc(dev, sizeof(*econfig), GFP_KERNEL);\r\nif (!econfig)\r\nreturn -ENOMEM;\r\neconfig->stride = 4;\r\neconfig->word_size = 4;\r\neconfig->reg_read = mtk_reg_read;\r\neconfig->reg_write = mtk_reg_write;\r\neconfig->size = resource_size(res);\r\neconfig->priv = base;\r\neconfig->dev = dev;\r\neconfig->owner = THIS_MODULE;\r\nnvmem = nvmem_register(econfig);\r\nif (IS_ERR(nvmem))\r\nreturn PTR_ERR(nvmem);\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\n}\r\nstatic int mtk_efuse_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}\r\nstatic int __init mtk_efuse_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&mtk_efuse_driver);\r\nif (ret) {\r\npr_err("Failed to register efuse driver\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit mtk_efuse_exit(void)\r\n{\r\nreturn platform_driver_unregister(&mtk_efuse_driver);\r\n}
