static inline struct sync_pt *dma_fence_to_sync_pt(struct dma_fence *fence)\r\n{\r\nif (fence->ops != &timeline_fence_ops)\r\nreturn NULL;\r\nreturn container_of(fence, struct sync_pt, base);\r\n}\r\nstatic struct sync_timeline *sync_timeline_create(const char *name)\r\n{\r\nstruct sync_timeline *obj;\r\nobj = kzalloc(sizeof(*obj), GFP_KERNEL);\r\nif (!obj)\r\nreturn NULL;\r\nkref_init(&obj->kref);\r\nobj->context = dma_fence_context_alloc(1);\r\nstrlcpy(obj->name, name, sizeof(obj->name));\r\nINIT_LIST_HEAD(&obj->child_list_head);\r\nINIT_LIST_HEAD(&obj->active_list_head);\r\nspin_lock_init(&obj->child_list_lock);\r\nsync_timeline_debug_add(obj);\r\nreturn obj;\r\n}\r\nstatic void sync_timeline_free(struct kref *kref)\r\n{\r\nstruct sync_timeline *obj =\r\ncontainer_of(kref, struct sync_timeline, kref);\r\nsync_timeline_debug_remove(obj);\r\nkfree(obj);\r\n}\r\nstatic void sync_timeline_get(struct sync_timeline *obj)\r\n{\r\nkref_get(&obj->kref);\r\n}\r\nstatic void sync_timeline_put(struct sync_timeline *obj)\r\n{\r\nkref_put(&obj->kref, sync_timeline_free);\r\n}\r\nstatic void sync_timeline_signal(struct sync_timeline *obj, unsigned int inc)\r\n{\r\nunsigned long flags;\r\nstruct sync_pt *pt, *next;\r\ntrace_sync_timeline(obj);\r\nspin_lock_irqsave(&obj->child_list_lock, flags);\r\nobj->value += inc;\r\nlist_for_each_entry_safe(pt, next, &obj->active_list_head,\r\nactive_list) {\r\nif (dma_fence_is_signaled_locked(&pt->base))\r\nlist_del_init(&pt->active_list);\r\n}\r\nspin_unlock_irqrestore(&obj->child_list_lock, flags);\r\n}\r\nstatic struct sync_pt *sync_pt_create(struct sync_timeline *obj, int size,\r\nunsigned int value)\r\n{\r\nunsigned long flags;\r\nstruct sync_pt *pt;\r\nif (size < sizeof(*pt))\r\nreturn NULL;\r\npt = kzalloc(size, GFP_KERNEL);\r\nif (!pt)\r\nreturn NULL;\r\nspin_lock_irqsave(&obj->child_list_lock, flags);\r\nsync_timeline_get(obj);\r\ndma_fence_init(&pt->base, &timeline_fence_ops, &obj->child_list_lock,\r\nobj->context, value);\r\nlist_add_tail(&pt->child_list, &obj->child_list_head);\r\nINIT_LIST_HEAD(&pt->active_list);\r\nspin_unlock_irqrestore(&obj->child_list_lock, flags);\r\nreturn pt;\r\n}\r\nstatic const char *timeline_fence_get_driver_name(struct dma_fence *fence)\r\n{\r\nreturn "sw_sync";\r\n}\r\nstatic const char *timeline_fence_get_timeline_name(struct dma_fence *fence)\r\n{\r\nstruct sync_timeline *parent = dma_fence_parent(fence);\r\nreturn parent->name;\r\n}\r\nstatic void timeline_fence_release(struct dma_fence *fence)\r\n{\r\nstruct sync_pt *pt = dma_fence_to_sync_pt(fence);\r\nstruct sync_timeline *parent = dma_fence_parent(fence);\r\nunsigned long flags;\r\nspin_lock_irqsave(fence->lock, flags);\r\nlist_del(&pt->child_list);\r\nif (!list_empty(&pt->active_list))\r\nlist_del(&pt->active_list);\r\nspin_unlock_irqrestore(fence->lock, flags);\r\nsync_timeline_put(parent);\r\ndma_fence_free(fence);\r\n}\r\nstatic bool timeline_fence_signaled(struct dma_fence *fence)\r\n{\r\nstruct sync_timeline *parent = dma_fence_parent(fence);\r\nreturn (fence->seqno > parent->value) ? false : true;\r\n}\r\nstatic bool timeline_fence_enable_signaling(struct dma_fence *fence)\r\n{\r\nstruct sync_pt *pt = dma_fence_to_sync_pt(fence);\r\nstruct sync_timeline *parent = dma_fence_parent(fence);\r\nif (timeline_fence_signaled(fence))\r\nreturn false;\r\nlist_add_tail(&pt->active_list, &parent->active_list_head);\r\nreturn true;\r\n}\r\nstatic void timeline_fence_value_str(struct dma_fence *fence,\r\nchar *str, int size)\r\n{\r\nsnprintf(str, size, "%d", fence->seqno);\r\n}\r\nstatic void timeline_fence_timeline_value_str(struct dma_fence *fence,\r\nchar *str, int size)\r\n{\r\nstruct sync_timeline *parent = dma_fence_parent(fence);\r\nsnprintf(str, size, "%d", parent->value);\r\n}\r\nstatic int sw_sync_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nstruct sync_timeline *obj;\r\nchar task_comm[TASK_COMM_LEN];\r\nget_task_comm(task_comm, current);\r\nobj = sync_timeline_create(task_comm);\r\nif (!obj)\r\nreturn -ENOMEM;\r\nfile->private_data = obj;\r\nreturn 0;\r\n}\r\nstatic int sw_sync_debugfs_release(struct inode *inode, struct file *file)\r\n{\r\nstruct sync_timeline *obj = file->private_data;\r\nsmp_wmb();\r\nsync_timeline_put(obj);\r\nreturn 0;\r\n}\r\nstatic long sw_sync_ioctl_create_fence(struct sync_timeline *obj,\r\nunsigned long arg)\r\n{\r\nint fd = get_unused_fd_flags(O_CLOEXEC);\r\nint err;\r\nstruct sync_pt *pt;\r\nstruct sync_file *sync_file;\r\nstruct sw_sync_create_fence_data data;\r\nif (fd < 0)\r\nreturn fd;\r\nif (copy_from_user(&data, (void __user *)arg, sizeof(data))) {\r\nerr = -EFAULT;\r\ngoto err;\r\n}\r\npt = sync_pt_create(obj, sizeof(*pt), data.value);\r\nif (!pt) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nsync_file = sync_file_create(&pt->base);\r\ndma_fence_put(&pt->base);\r\nif (!sync_file) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\ndata.fence = fd;\r\nif (copy_to_user((void __user *)arg, &data, sizeof(data))) {\r\nfput(sync_file->file);\r\nerr = -EFAULT;\r\ngoto err;\r\n}\r\nfd_install(fd, sync_file->file);\r\nreturn 0;\r\nerr:\r\nput_unused_fd(fd);\r\nreturn err;\r\n}\r\nstatic long sw_sync_ioctl_inc(struct sync_timeline *obj, unsigned long arg)\r\n{\r\nu32 value;\r\nif (copy_from_user(&value, (void __user *)arg, sizeof(value)))\r\nreturn -EFAULT;\r\nsync_timeline_signal(obj, value);\r\nreturn 0;\r\n}\r\nstatic long sw_sync_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sync_timeline *obj = file->private_data;\r\nswitch (cmd) {\r\ncase SW_SYNC_IOC_CREATE_FENCE:\r\nreturn sw_sync_ioctl_create_fence(obj, arg);\r\ncase SW_SYNC_IOC_INC:\r\nreturn sw_sync_ioctl_inc(obj, arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}
