static inline struct f_sourcesink *func_to_ss(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_sourcesink, function);\r\n}\r\nstatic inline struct usb_request *ss_alloc_ep_req(struct usb_ep *ep, int len)\r\n{\r\nreturn alloc_ep_req(ep, len);\r\n}\r\nstatic void disable_ep(struct usb_composite_dev *cdev, struct usb_ep *ep)\r\n{\r\nint value;\r\nvalue = usb_ep_disable(ep);\r\nif (value < 0)\r\nDBG(cdev, "disable %s --> %d\n", ep->name, value);\r\n}\r\nvoid disable_endpoints(struct usb_composite_dev *cdev,\r\nstruct usb_ep *in, struct usb_ep *out,\r\nstruct usb_ep *iso_in, struct usb_ep *iso_out)\r\n{\r\ndisable_ep(cdev, in);\r\ndisable_ep(cdev, out);\r\nif (iso_in)\r\ndisable_ep(cdev, iso_in);\r\nif (iso_out)\r\ndisable_ep(cdev, iso_out);\r\n}\r\nstatic int\r\nsourcesink_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_sourcesink *ss = func_to_ss(f);\r\nint id;\r\nint ret;\r\nid = usb_interface_id(c, f);\r\nif (id < 0)\r\nreturn id;\r\nsource_sink_intf_alt0.bInterfaceNumber = id;\r\nsource_sink_intf_alt1.bInterfaceNumber = id;\r\nss->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_source_desc);\r\nif (!ss->in_ep) {\r\nautoconf_fail:\r\nERROR(cdev, "%s: can't autoconfigure on %s\n",\r\nf->name, cdev->gadget->name);\r\nreturn -ENODEV;\r\n}\r\nss->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_sink_desc);\r\nif (!ss->out_ep)\r\ngoto autoconf_fail;\r\nif (ss->isoc_interval < 1)\r\nss->isoc_interval = 1;\r\nif (ss->isoc_interval > 16)\r\nss->isoc_interval = 16;\r\nif (ss->isoc_mult > 2)\r\nss->isoc_mult = 2;\r\nif (ss->isoc_maxburst > 15)\r\nss->isoc_maxburst = 15;\r\nfs_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket > 1023 ?\r\n1023 : ss->isoc_maxpacket;\r\nfs_iso_source_desc.bInterval = ss->isoc_interval;\r\nfs_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket > 1023 ?\r\n1023 : ss->isoc_maxpacket;\r\nfs_iso_sink_desc.bInterval = ss->isoc_interval;\r\nss->iso_in_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_source_desc);\r\nif (!ss->iso_in_ep)\r\ngoto no_iso;\r\nss->iso_out_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_sink_desc);\r\nif (!ss->iso_out_ep) {\r\nusb_ep_autoconfig_release(ss->iso_in_ep);\r\nss->iso_in_ep = NULL;\r\nno_iso:\r\nfs_source_sink_descs[FS_ALT_IFC_1_OFFSET] = NULL;\r\nhs_source_sink_descs[HS_ALT_IFC_1_OFFSET] = NULL;\r\nss_source_sink_descs[SS_ALT_IFC_1_OFFSET] = NULL;\r\n}\r\nif (ss->isoc_maxpacket > 1024)\r\nss->isoc_maxpacket = 1024;\r\nhs_source_desc.bEndpointAddress = fs_source_desc.bEndpointAddress;\r\nhs_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;\r\nhs_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket;\r\nhs_iso_source_desc.wMaxPacketSize |= ss->isoc_mult << 11;\r\nhs_iso_source_desc.bInterval = ss->isoc_interval;\r\nhs_iso_source_desc.bEndpointAddress =\r\nfs_iso_source_desc.bEndpointAddress;\r\nhs_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket;\r\nhs_iso_sink_desc.wMaxPacketSize |= ss->isoc_mult << 11;\r\nhs_iso_sink_desc.bInterval = ss->isoc_interval;\r\nhs_iso_sink_desc.bEndpointAddress = fs_iso_sink_desc.bEndpointAddress;\r\nss_source_desc.bEndpointAddress =\r\nfs_source_desc.bEndpointAddress;\r\nss_sink_desc.bEndpointAddress =\r\nfs_sink_desc.bEndpointAddress;\r\nss_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket;\r\nss_iso_source_desc.bInterval = ss->isoc_interval;\r\nss_iso_source_comp_desc.bmAttributes = ss->isoc_mult;\r\nss_iso_source_comp_desc.bMaxBurst = ss->isoc_maxburst;\r\nss_iso_source_comp_desc.wBytesPerInterval = ss->isoc_maxpacket *\r\n(ss->isoc_mult + 1) * (ss->isoc_maxburst + 1);\r\nss_iso_source_desc.bEndpointAddress =\r\nfs_iso_source_desc.bEndpointAddress;\r\nss_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket;\r\nss_iso_sink_desc.bInterval = ss->isoc_interval;\r\nss_iso_sink_comp_desc.bmAttributes = ss->isoc_mult;\r\nss_iso_sink_comp_desc.bMaxBurst = ss->isoc_maxburst;\r\nss_iso_sink_comp_desc.wBytesPerInterval = ss->isoc_maxpacket *\r\n(ss->isoc_mult + 1) * (ss->isoc_maxburst + 1);\r\nss_iso_sink_desc.bEndpointAddress = fs_iso_sink_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(f, fs_source_sink_descs,\r\nhs_source_sink_descs, ss_source_sink_descs, NULL);\r\nif (ret)\r\nreturn ret;\r\nDBG(cdev, "%s speed %s: IN/%s, OUT/%s, ISO-IN/%s, ISO-OUT/%s\n",\r\n(gadget_is_superspeed(c->cdev->gadget) ? "super" :\r\n(gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full")),\r\nf->name, ss->in_ep->name, ss->out_ep->name,\r\nss->iso_in_ep ? ss->iso_in_ep->name : "<none>",\r\nss->iso_out_ep ? ss->iso_out_ep->name : "<none>");\r\nreturn 0;\r\n}\r\nstatic void\r\nsourcesink_free_func(struct usb_function *f)\r\n{\r\nstruct f_ss_opts *opts;\r\nopts = container_of(f->fi, struct f_ss_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt--;\r\nmutex_unlock(&opts->lock);\r\nusb_free_all_descriptors(f);\r\nkfree(func_to_ss(f));\r\n}\r\nstatic int check_read_data(struct f_sourcesink *ss, struct usb_request *req)\r\n{\r\nunsigned i;\r\nu8 *buf = req->buf;\r\nstruct usb_composite_dev *cdev = ss->function.config->cdev;\r\nint max_packet_size = le16_to_cpu(ss->out_ep->desc->wMaxPacketSize);\r\nif (ss->pattern == 2)\r\nreturn 0;\r\nfor (i = 0; i < req->actual; i++, buf++) {\r\nswitch (ss->pattern) {\r\ncase 0:\r\nif (*buf == 0)\r\ncontinue;\r\nbreak;\r\ncase 1:\r\nif (*buf == (u8)((i % max_packet_size) % 63))\r\ncontinue;\r\nbreak;\r\n}\r\nERROR(cdev, "bad OUT byte, buf[%d] = %d\n", i, *buf);\r\nusb_ep_set_halt(ss->out_ep);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void reinit_write_data(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nunsigned i;\r\nu8 *buf = req->buf;\r\nint max_packet_size = le16_to_cpu(ep->desc->wMaxPacketSize);\r\nstruct f_sourcesink *ss = ep->driver_data;\r\nswitch (ss->pattern) {\r\ncase 0:\r\nmemset(req->buf, 0, req->length);\r\nbreak;\r\ncase 1:\r\nfor (i = 0; i < req->length; i++)\r\n*buf++ = (u8) ((i % max_packet_size) % 63);\r\nbreak;\r\ncase 2:\r\nbreak;\r\n}\r\n}\r\nstatic void source_sink_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct usb_composite_dev *cdev;\r\nstruct f_sourcesink *ss = ep->driver_data;\r\nint status = req->status;\r\nif (!ss)\r\nreturn;\r\ncdev = ss->function.config->cdev;\r\nswitch (status) {\r\ncase 0:\r\nif (ep == ss->out_ep) {\r\ncheck_read_data(ss, req);\r\nif (ss->pattern != 2)\r\nmemset(req->buf, 0x55, req->length);\r\n}\r\nbreak;\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nVDBG(cdev, "%s gone (%d), %d/%d\n", ep->name, status,\r\nreq->actual, req->length);\r\nif (ep == ss->out_ep)\r\ncheck_read_data(ss, req);\r\nfree_ep_req(ep, req);\r\nreturn;\r\ncase -EOVERFLOW:\r\ndefault:\r\n#if 1\r\nDBG(cdev, "%s complete --> %d, %d/%d\n", ep->name,\r\nstatus, req->actual, req->length);\r\n#endif\r\ncase -EREMOTEIO:\r\nbreak;\r\n}\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (status) {\r\nERROR(cdev, "kill %s: resubmit %d bytes --> %d\n",\r\nep->name, req->length, status);\r\nusb_ep_set_halt(ep);\r\n}\r\n}\r\nstatic int source_sink_start_ep(struct f_sourcesink *ss, bool is_in,\r\nbool is_iso, int speed)\r\n{\r\nstruct usb_ep *ep;\r\nstruct usb_request *req;\r\nint i, size, qlen, status = 0;\r\nif (is_iso) {\r\nswitch (speed) {\r\ncase USB_SPEED_SUPER:\r\nsize = ss->isoc_maxpacket *\r\n(ss->isoc_mult + 1) *\r\n(ss->isoc_maxburst + 1);\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nsize = ss->isoc_maxpacket * (ss->isoc_mult + 1);\r\nbreak;\r\ndefault:\r\nsize = ss->isoc_maxpacket > 1023 ?\r\n1023 : ss->isoc_maxpacket;\r\nbreak;\r\n}\r\nep = is_in ? ss->iso_in_ep : ss->iso_out_ep;\r\nqlen = ss->iso_qlen;\r\n} else {\r\nep = is_in ? ss->in_ep : ss->out_ep;\r\nqlen = ss->bulk_qlen;\r\nsize = ss->buflen;\r\n}\r\nfor (i = 0; i < qlen; i++) {\r\nreq = ss_alloc_ep_req(ep, size);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->complete = source_sink_complete;\r\nif (is_in)\r\nreinit_write_data(ep, req);\r\nelse if (ss->pattern != 2)\r\nmemset(req->buf, 0x55, req->length);\r\nstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (status) {\r\nstruct usb_composite_dev *cdev;\r\ncdev = ss->function.config->cdev;\r\nERROR(cdev, "start %s%s %s --> %d\n",\r\nis_iso ? "ISO-" : "", is_in ? "IN" : "OUT",\r\nep->name, status);\r\nfree_ep_req(ep, req);\r\nreturn status;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void disable_source_sink(struct f_sourcesink *ss)\r\n{\r\nstruct usb_composite_dev *cdev;\r\ncdev = ss->function.config->cdev;\r\ndisable_endpoints(cdev, ss->in_ep, ss->out_ep, ss->iso_in_ep,\r\nss->iso_out_ep);\r\nVDBG(cdev, "%s disabled\n", ss->function.name);\r\n}\r\nstatic int\r\nenable_source_sink(struct usb_composite_dev *cdev, struct f_sourcesink *ss,\r\nint alt)\r\n{\r\nint result = 0;\r\nint speed = cdev->gadget->speed;\r\nstruct usb_ep *ep;\r\nep = ss->in_ep;\r\nresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\r\nif (result)\r\nreturn result;\r\nresult = usb_ep_enable(ep);\r\nif (result < 0)\r\nreturn result;\r\nep->driver_data = ss;\r\nresult = source_sink_start_ep(ss, true, false, speed);\r\nif (result < 0) {\r\nfail:\r\nep = ss->in_ep;\r\nusb_ep_disable(ep);\r\nreturn result;\r\n}\r\nep = ss->out_ep;\r\nresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\r\nif (result)\r\ngoto fail;\r\nresult = usb_ep_enable(ep);\r\nif (result < 0)\r\ngoto fail;\r\nep->driver_data = ss;\r\nresult = source_sink_start_ep(ss, false, false, speed);\r\nif (result < 0) {\r\nfail2:\r\nep = ss->out_ep;\r\nusb_ep_disable(ep);\r\ngoto fail;\r\n}\r\nif (alt == 0)\r\ngoto out;\r\nep = ss->iso_in_ep;\r\nif (ep) {\r\nresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\r\nif (result)\r\ngoto fail2;\r\nresult = usb_ep_enable(ep);\r\nif (result < 0)\r\ngoto fail2;\r\nep->driver_data = ss;\r\nresult = source_sink_start_ep(ss, true, true, speed);\r\nif (result < 0) {\r\nfail3:\r\nep = ss->iso_in_ep;\r\nif (ep)\r\nusb_ep_disable(ep);\r\ngoto fail2;\r\n}\r\n}\r\nep = ss->iso_out_ep;\r\nif (ep) {\r\nresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\r\nif (result)\r\ngoto fail3;\r\nresult = usb_ep_enable(ep);\r\nif (result < 0)\r\ngoto fail3;\r\nep->driver_data = ss;\r\nresult = source_sink_start_ep(ss, false, true, speed);\r\nif (result < 0) {\r\nusb_ep_disable(ep);\r\ngoto fail3;\r\n}\r\n}\r\nout:\r\nss->cur_alt = alt;\r\nDBG(cdev, "%s enabled, alt intf %d\n", ss->function.name, alt);\r\nreturn result;\r\n}\r\nstatic int sourcesink_set_alt(struct usb_function *f,\r\nunsigned intf, unsigned alt)\r\n{\r\nstruct f_sourcesink *ss = func_to_ss(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\ndisable_source_sink(ss);\r\nreturn enable_source_sink(cdev, ss, alt);\r\n}\r\nstatic int sourcesink_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct f_sourcesink *ss = func_to_ss(f);\r\nreturn ss->cur_alt;\r\n}\r\nstatic void sourcesink_disable(struct usb_function *f)\r\n{\r\nstruct f_sourcesink *ss = func_to_ss(f);\r\ndisable_source_sink(ss);\r\n}\r\nstatic int sourcesink_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_configuration *c = f->config;\r\nstruct usb_request *req = c->cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nreq->length = USB_COMP_EP0_BUFSIZ;\r\nswitch (ctrl->bRequest) {\r\ncase 0x5b:\r\nif (ctrl->bRequestType != (USB_DIR_OUT|USB_TYPE_VENDOR))\r\ngoto unknown;\r\nif (w_value || w_index)\r\nbreak;\r\nif (w_length > req->length)\r\nbreak;\r\nvalue = w_length;\r\nbreak;\r\ncase 0x5c:\r\nif (ctrl->bRequestType != (USB_DIR_IN|USB_TYPE_VENDOR))\r\ngoto unknown;\r\nif (w_value || w_index)\r\nbreak;\r\nif (w_length > req->length)\r\nbreak;\r\nvalue = w_length;\r\nbreak;\r\ndefault:\r\nunknown:\r\nVDBG(c->cdev,\r\n"unknown control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nVDBG(c->cdev, "source/sink req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(c->cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(c->cdev, "source/sink response, err %d\n",\r\nvalue);\r\n}\r\nreturn value;\r\n}\r\nstatic struct usb_function *source_sink_alloc_func(\r\nstruct usb_function_instance *fi)\r\n{\r\nstruct f_sourcesink *ss;\r\nstruct f_ss_opts *ss_opts;\r\nss = kzalloc(sizeof(*ss), GFP_KERNEL);\r\nif (!ss)\r\nreturn NULL;\r\nss_opts = container_of(fi, struct f_ss_opts, func_inst);\r\nmutex_lock(&ss_opts->lock);\r\nss_opts->refcnt++;\r\nmutex_unlock(&ss_opts->lock);\r\nss->pattern = ss_opts->pattern;\r\nss->isoc_interval = ss_opts->isoc_interval;\r\nss->isoc_maxpacket = ss_opts->isoc_maxpacket;\r\nss->isoc_mult = ss_opts->isoc_mult;\r\nss->isoc_maxburst = ss_opts->isoc_maxburst;\r\nss->buflen = ss_opts->bulk_buflen;\r\nss->bulk_qlen = ss_opts->bulk_qlen;\r\nss->iso_qlen = ss_opts->iso_qlen;\r\nss->function.name = "source/sink";\r\nss->function.bind = sourcesink_bind;\r\nss->function.set_alt = sourcesink_set_alt;\r\nss->function.get_alt = sourcesink_get_alt;\r\nss->function.disable = sourcesink_disable;\r\nss->function.setup = sourcesink_setup;\r\nss->function.strings = sourcesink_strings;\r\nss->function.free_func = sourcesink_free_func;\r\nreturn &ss->function;\r\n}\r\nstatic inline struct f_ss_opts *to_f_ss_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_ss_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void ss_attr_release(struct config_item *item)\r\n{\r\nstruct f_ss_opts *ss_opts = to_f_ss_opts(item);\r\nusb_put_function_instance(&ss_opts->func_inst);\r\n}\r\nstatic ssize_t f_ss_opts_pattern_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->pattern);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_pattern_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu8 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou8(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nif (num != 0 && num != 1 && num != 2) {\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nopts->pattern = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_interval_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->isoc_interval);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_interval_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu8 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou8(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nif (num > 16) {\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nopts->isoc_interval = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_maxpacket_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->isoc_maxpacket);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_maxpacket_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu16 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou16(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nif (num > 1024) {\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nopts->isoc_maxpacket = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_mult_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->isoc_mult);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_mult_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu8 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou8(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nif (num > 2) {\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nopts->isoc_mult = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_maxburst_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->isoc_maxburst);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_isoc_maxburst_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu8 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou8(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nif (num > 15) {\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\nopts->isoc_maxburst = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_bulk_buflen_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->bulk_buflen);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_bulk_buflen_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu32 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou32(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nopts->bulk_buflen = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_bulk_qlen_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->bulk_qlen);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_bulk_qlen_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu32 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou32(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nopts->bulk_qlen = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_ss_opts_iso_qlen_show(struct config_item *item, char *page)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%u\n", opts->iso_qlen);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_ss_opts_iso_qlen_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_ss_opts *opts = to_f_ss_opts(item);\r\nint ret;\r\nu32 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou32(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nopts->iso_qlen = num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic void source_sink_free_instance(struct usb_function_instance *fi)\r\n{\r\nstruct f_ss_opts *ss_opts;\r\nss_opts = container_of(fi, struct f_ss_opts, func_inst);\r\nkfree(ss_opts);\r\n}\r\nstatic struct usb_function_instance *source_sink_alloc_inst(void)\r\n{\r\nstruct f_ss_opts *ss_opts;\r\nss_opts = kzalloc(sizeof(*ss_opts), GFP_KERNEL);\r\nif (!ss_opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&ss_opts->lock);\r\nss_opts->func_inst.free_func_inst = source_sink_free_instance;\r\nss_opts->isoc_interval = GZERO_ISOC_INTERVAL;\r\nss_opts->isoc_maxpacket = GZERO_ISOC_MAXPACKET;\r\nss_opts->bulk_buflen = GZERO_BULK_BUFLEN;\r\nss_opts->bulk_qlen = GZERO_SS_BULK_QLEN;\r\nss_opts->iso_qlen = GZERO_SS_ISO_QLEN;\r\nconfig_group_init_type_name(&ss_opts->func_inst.group, "",\r\n&ss_func_type);\r\nreturn &ss_opts->func_inst;\r\n}\r\nstatic int __init sslb_modinit(void)\r\n{\r\nint ret;\r\nret = usb_function_register(&SourceSinkusb_func);\r\nif (ret)\r\nreturn ret;\r\nret = lb_modinit();\r\nif (ret)\r\nusb_function_unregister(&SourceSinkusb_func);\r\nreturn ret;\r\n}\r\nstatic void __exit sslb_modexit(void)\r\n{\r\nusb_function_unregister(&SourceSinkusb_func);\r\nlb_modexit();\r\n}
