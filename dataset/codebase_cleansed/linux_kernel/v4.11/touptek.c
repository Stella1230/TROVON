static int val_reply(struct gspca_dev *gspca_dev, const char *reply, int rc)\r\n{\r\nif (rc < 0) {\r\nPERR("reply has error %d", rc);\r\nreturn -EIO;\r\n}\r\nif (rc != 1) {\r\nPERR("Bad reply size %d", rc);\r\nreturn -EIO;\r\n}\r\nif (reply[0] != 0x08) {\r\nPERR("Bad reply 0x%02x", (int)reply[0]);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 value, u16 index)\r\n{\r\nchar *buff = gspca_dev->usb_buf;\r\nint rc;\r\nPDEBUG(D_USBO,\r\n"reg_w bReq=0x0B, bReqT=0xC0, wVal=0x%04X, wInd=0x%04X\n",\r\nvalue, index);\r\nrc = usb_control_msg(gspca_dev->dev, usb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0x0B, 0xC0, value, index, buff, 1, 500);\r\nPDEBUG(D_USBO, "rc=%d, ret={0x%02x}", rc, (int)buff[0]);\r\nif (rc < 0) {\r\nPERR("Failed reg_w(0x0B, 0xC0, 0x%04X, 0x%04X) w/ rc %d\n",\r\nvalue, index, rc);\r\ngspca_dev->usb_err = rc;\r\nreturn;\r\n}\r\nif (val_reply(gspca_dev, buff, rc)) {\r\nPERR("Bad reply to reg_w(0x0B, 0xC0, 0x%04X, 0x%04X\n",\r\nvalue, index);\r\ngspca_dev->usb_err = -EIO;\r\n}\r\n}\r\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\r\nconst struct cmd *p, int l)\r\n{\r\ndo {\r\nreg_w(gspca_dev, p->value, p->index);\r\np++;\r\n} while (--l > 0);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu16 value;\r\nunsigned int w = gspca_dev->pixfmt.width;\r\nif (w == 800)\r\nvalue = val * 5;\r\nelse if (w == 1600)\r\nvalue = val * 3;\r\nelse if (w == 3264)\r\nvalue = val * 3 / 2;\r\nelse {\r\nPERR("Invalid width %u\n", w);\r\ngspca_dev->usb_err = -EINVAL;\r\nreturn;\r\n}\r\nPDEBUG(D_STREAM, "exposure: 0x%04X ms\n", value);\r\nreg_w(gspca_dev, value, REG_COARSE_INTEGRATION_TIME_);\r\nreg_w(gspca_dev, value, REG_COARSE_INTEGRATION_TIME_);\r\n}\r\nstatic int gainify(int in)\r\n{\r\nif (in <= 0x7F)\r\nreturn 0x1000 | in;\r\nelse if (in <= 0xFF)\r\nreturn 0x1080 | in / 2;\r\nelse\r\nreturn 0x1180 | in / 4;\r\n}\r\nstatic void setggain(struct gspca_dev *gspca_dev, u16 global_gain)\r\n{\r\nu16 normalized;\r\nnormalized = gainify(global_gain);\r\nPDEBUG(D_STREAM, "gain G1/G2 (0x%04X): 0x%04X (src 0x%04X)\n",\r\nREG_GREEN1_GAIN,\r\nnormalized, global_gain);\r\nreg_w(gspca_dev, normalized, REG_GREEN1_GAIN);\r\nreg_w(gspca_dev, normalized, REG_GREEN2_GAIN);\r\n}\r\nstatic void setbgain(struct gspca_dev *gspca_dev,\r\nu16 gain, u16 global_gain)\r\n{\r\nu16 normalized;\r\nnormalized = global_gain +\r\n((u32)global_gain) * gain / GAIN_MAX;\r\nif (normalized > GAIN_MAX) {\r\nPDEBUG(D_STREAM, "Truncating blue 0x%04X w/ value 0x%04X\n",\r\nGAIN_MAX, normalized);\r\nnormalized = GAIN_MAX;\r\n}\r\nnormalized = gainify(normalized);\r\nPDEBUG(D_STREAM, "gain B (0x%04X): 0x%04X w/ source 0x%04X\n",\r\nREG_BLUE_GAIN, normalized, gain);\r\nreg_w(gspca_dev, normalized, REG_BLUE_GAIN);\r\n}\r\nstatic void setrgain(struct gspca_dev *gspca_dev,\r\nu16 gain, u16 global_gain)\r\n{\r\nu16 normalized;\r\nnormalized = global_gain +\r\n((u32)global_gain) * gain / GAIN_MAX;\r\nif (normalized > GAIN_MAX) {\r\nPDEBUG(D_STREAM, "Truncating gain 0x%04X w/ value 0x%04X\n",\r\nGAIN_MAX, normalized);\r\nnormalized = GAIN_MAX;\r\n}\r\nnormalized = gainify(normalized);\r\nPDEBUG(D_STREAM, "gain R (0x%04X): 0x%04X w / source 0x%04X\n",\r\nREG_RED_GAIN, normalized, gain);\r\nreg_w(gspca_dev, normalized, REG_RED_GAIN);\r\n}\r\nstatic void configure_wh(struct gspca_dev *gspca_dev)\r\n{\r\nunsigned int w = gspca_dev->pixfmt.width;\r\nPDEBUG(D_STREAM, "configure_wh\n");\r\nif (w == 800) {\r\nstatic const struct cmd reg_init_res[] = {\r\n{0x0060, REG_X_ADDR_START},\r\n{0x0CD9, REG_X_ADDR_END},\r\n{0x0036, REG_Y_ADDR_START},\r\n{0x098F, REG_Y_ADDR_END},\r\n{0x07C7, REG_READ_MODE},\r\n};\r\nreg_w_buf(gspca_dev,\r\nreg_init_res, ARRAY_SIZE(reg_init_res));\r\n} else if (w == 1600) {\r\nstatic const struct cmd reg_init_res[] = {\r\n{0x009C, REG_X_ADDR_START},\r\n{0x0D19, REG_X_ADDR_END},\r\n{0x0068, REG_Y_ADDR_START},\r\n{0x09C5, REG_Y_ADDR_END},\r\n{0x06C3, REG_READ_MODE},\r\n};\r\nreg_w_buf(gspca_dev,\r\nreg_init_res, ARRAY_SIZE(reg_init_res));\r\n} else if (w == 3264) {\r\nstatic const struct cmd reg_init_res[] = {\r\n{0x00E8, REG_X_ADDR_START},\r\n{0x0DA7, REG_X_ADDR_END},\r\n{0x009E, REG_Y_ADDR_START},\r\n{0x0A2D, REG_Y_ADDR_END},\r\n{0x0241, REG_READ_MODE},\r\n};\r\nreg_w_buf(gspca_dev,\r\nreg_init_res, ARRAY_SIZE(reg_init_res));\r\n} else {\r\nPERR("bad width %u\n", w);\r\ngspca_dev->usb_err = -EINVAL;\r\nreturn;\r\n}\r\nreg_w(gspca_dev, 0x0000, REG_SCALING_MODE);\r\nreg_w(gspca_dev, 0x0010, REG_SCALE_M);\r\nreg_w(gspca_dev, w, REG_X_OUTPUT_SIZE);\r\nreg_w(gspca_dev, gspca_dev->pixfmt.height, REG_Y_OUTPUT_SIZE);\r\nif (w == 800) {\r\nreg_w(gspca_dev, 0x0384, REG_FRAME_LENGTH_LINES_);\r\nreg_w(gspca_dev, 0x0960, REG_LINE_LENGTH_PCK_);\r\n} else if (w == 1600) {\r\nreg_w(gspca_dev, 0x0640, REG_FRAME_LENGTH_LINES_);\r\nreg_w(gspca_dev, 0x0FA0, REG_LINE_LENGTH_PCK_);\r\n} else if (w == 3264) {\r\nreg_w(gspca_dev, 0x0B4B, REG_FRAME_LENGTH_LINES_);\r\nreg_w(gspca_dev, 0x1F40, REG_LINE_LENGTH_PCK_);\r\n} else {\r\nPERR("bad width %u\n", w);\r\ngspca_dev->usb_err = -EINVAL;\r\nreturn;\r\n}\r\n}\r\nstatic void configure_encrypted(struct gspca_dev *gspca_dev)\r\n{\r\nstatic const struct cmd reg_init_begin[] = {\r\n{0x0100, REG_SOFTWARE_RESET},\r\n{0x0000, REG_MODE_SELECT},\r\n{0x0100, REG_GROUPED_PARAMETER_HOLD},\r\n{0x0004, REG_VT_PIX_CLK_DIV},\r\n{0x0001, REG_VT_SYS_CLK_DIV},\r\n{0x0008, REG_OP_PIX_CLK_DIV},\r\n{0x0001, REG_OP_SYS_CLK_DIV},\r\n{0x0004, REG_PRE_PLL_CLK_DIV},\r\n{0x0040, REG_PLL_MULTIPLIER},\r\n{0x0000, REG_GROUPED_PARAMETER_HOLD},\r\n{0x0100, REG_GROUPED_PARAMETER_HOLD},\r\n};\r\nstatic const struct cmd reg_init_end[] = {\r\n{0x0000, REG_GROUPED_PARAMETER_HOLD},\r\n{0x0301, 0x31AE},\r\n{0x0805, 0x3064},\r\n{0x0071, 0x3170},\r\n{0x10DE, REG_RESET_REGISTER},\r\n{0x0000, REG_MODE_SELECT},\r\n{0x0010, REG_PLL_MULTIPLIER},\r\n{0x0100, REG_MODE_SELECT},\r\n};\r\nPDEBUG(D_STREAM, "Encrypted begin, w = %u\n", gspca_dev->pixfmt.width);\r\nreg_w_buf(gspca_dev, reg_init_begin, ARRAY_SIZE(reg_init_begin));\r\nconfigure_wh(gspca_dev);\r\nreg_w_buf(gspca_dev, reg_init_end, ARRAY_SIZE(reg_init_end));\r\nreg_w(gspca_dev, 0x0100, REG_GROUPED_PARAMETER_HOLD);\r\nreg_w(gspca_dev, 0x0000, REG_GROUPED_PARAMETER_HOLD);\r\nPDEBUG(D_STREAM, "Encrypted end\n");\r\n}\r\nstatic int configure(struct gspca_dev *gspca_dev)\r\n{\r\nint rc;\r\nchar *buff = gspca_dev->usb_buf;\r\nPDEBUG(D_STREAM, "configure()\n");\r\nrc = usb_control_msg(gspca_dev->dev, usb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0x16, 0xC0, 0x0000, 0x0000, buff, 2, 500);\r\nif (val_reply(gspca_dev, buff, rc)) {\r\nPERR("failed key req");\r\nreturn -EIO;\r\n}\r\nrc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x01, 0x40, 0x0001, 0x000F, NULL, 0, 500);\r\nif (rc < 0) {\r\nPERR("failed to replay packet 176 w/ rc %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x01, 0x40, 0x0000, 0x000F, NULL, 0, 500);\r\nif (rc < 0) {\r\nPERR("failed to replay packet 178 w/ rc %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x01, 0x40, 0x0001, 0x000F, NULL, 0, 500);\r\nif (rc < 0) {\r\nPERR("failed to replay packet 180 w/ rc %d\n", rc);\r\nreturn rc;\r\n}\r\ngspca_dev->usb_err = 0;\r\nconfigure_encrypted(gspca_dev);\r\nif (gspca_dev->usb_err)\r\nreturn gspca_dev->usb_err;\r\nrc = usb_control_msg(gspca_dev->dev, usb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x01, 0x40, 0x0003, 0x000F, NULL, 0, 500);\r\nif (rc < 0) {\r\nPERR("failed to replay final packet w/ rc %d\n", rc);\r\nreturn rc;\r\n}\r\nPDEBUG(D_STREAM, "Configure complete\n");\r\nreturn 0;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\ngspca_dev->cam.cam_mode = vga_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\r\ngspca_dev->cam.no_urb_create = 0;\r\ngspca_dev->cam.bulk_nurbs = 4;\r\ngspca_dev->cam.bulk_size = BULK_SIZE;\r\ngspca_dev->cam.bulk = 1;\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint rc;\r\nsd->this_f = 0;\r\nrc = configure(gspca_dev);\r\nif (rc < 0) {\r\nPERR("Failed configure");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (len != BULK_SIZE) {\r\nif (sd->this_f + len == gspca_dev->pixfmt.sizeimage) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET, data, len);\r\nPDEBUG(D_FRAM, "finish frame sz %u/%u w/ len %u\n",\r\nsd->this_f, gspca_dev->pixfmt.sizeimage, len);\r\n} else {\r\ngspca_frame_add(gspca_dev, DISCARD_PACKET, NULL, 0);\r\nPDEBUG(D_FRAM, "abort frame sz %u/%u w/ len %u\n",\r\nsd->this_f, gspca_dev->pixfmt.sizeimage, len);\r\n}\r\nsd->this_f = 0;\r\n} else {\r\nif (sd->this_f == 0)\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\r\nelse\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\nsd->this_f += len;\r\n}\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\nsetexposure(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nsetggain(gspca_dev, gspca_dev->gain->val);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nsd->blue->val = ctrl->val;\r\nsetbgain(gspca_dev, sd->blue->val, gspca_dev->gain->val);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nsd->red->val = ctrl->val;\r\nsetrgain(gspca_dev, sd->red->val, gspca_dev->gain->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 800, 1, 350);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 511, 1, 128);\r\nsd->blue = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BLUE_BALANCE, 0, 1023, 1, 80);\r\nsd->red = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_RED_BALANCE, 0, 1023, 1, 295);\r\nif (hdl->error) {\r\nPERR("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int __init sd_mod_init(void)\r\n{\r\nint ret;\r\nret = usb_register(&sd_driver);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void __exit sd_mod_exit(void)\r\n{\r\nusb_deregister(&sd_driver);\r\n}
