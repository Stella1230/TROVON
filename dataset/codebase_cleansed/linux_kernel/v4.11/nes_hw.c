static inline void print_ip(struct nes_cm_node *cm_node)\r\n{\r\nunsigned char *rem_addr;\r\nif (cm_node) {\r\nrem_addr = (unsigned char *)&cm_node->rem_addr;\r\nprintk(KERN_ERR PFX "Remote IP addr: %pI4\n", rem_addr);\r\n}\r\n}\r\nvoid nes_nic_init_timer_defaults(struct nes_device *nesdev, u8 jumbomode)\r\n{\r\nunsigned long flags;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_tune_timer *shared_timer = &nesadapter->tune_timer;\r\nspin_lock_irqsave(&nesadapter->periodic_timer_lock, flags);\r\nshared_timer->timer_in_use_min = NES_NIC_FAST_TIMER_LOW;\r\nshared_timer->timer_in_use_max = NES_NIC_FAST_TIMER_HIGH;\r\nif (jumbomode) {\r\nshared_timer->threshold_low = DEFAULT_JUMBO_NES_QL_LOW;\r\nshared_timer->threshold_target = DEFAULT_JUMBO_NES_QL_TARGET;\r\nshared_timer->threshold_high = DEFAULT_JUMBO_NES_QL_HIGH;\r\n} else {\r\nshared_timer->threshold_low = DEFAULT_NES_QL_LOW;\r\nshared_timer->threshold_target = DEFAULT_NES_QL_TARGET;\r\nshared_timer->threshold_high = DEFAULT_NES_QL_HIGH;\r\n}\r\nspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);\r\n}\r\nstatic void nes_nic_init_timer(struct nes_device *nesdev)\r\n{\r\nunsigned long flags;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_tune_timer *shared_timer = &nesadapter->tune_timer;\r\nspin_lock_irqsave(&nesadapter->periodic_timer_lock, flags);\r\nif (shared_timer->timer_in_use_old == 0) {\r\nnesdev->deepcq_count = 0;\r\nshared_timer->timer_direction_upward = 0;\r\nshared_timer->timer_direction_downward = 0;\r\nshared_timer->timer_in_use = NES_NIC_FAST_TIMER;\r\nshared_timer->timer_in_use_old = 0;\r\n}\r\nif (shared_timer->timer_in_use != shared_timer->timer_in_use_old) {\r\nshared_timer->timer_in_use_old = shared_timer->timer_in_use;\r\nnes_write32(nesdev->regs+NES_PERIODIC_CONTROL,\r\n0x80000000 | ((u32)(shared_timer->timer_in_use*8)));\r\n}\r\nspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);\r\n}\r\nstatic void nes_nic_tune_timer(struct nes_device *nesdev)\r\n{\r\nunsigned long flags;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_tune_timer *shared_timer = &nesadapter->tune_timer;\r\nu16 cq_count = nesdev->currcq_count;\r\nspin_lock_irqsave(&nesadapter->periodic_timer_lock, flags);\r\nif (shared_timer->cq_count_old <= cq_count)\r\nshared_timer->cq_direction_downward = 0;\r\nelse\r\nshared_timer->cq_direction_downward++;\r\nshared_timer->cq_count_old = cq_count;\r\nif (shared_timer->cq_direction_downward > NES_NIC_CQ_DOWNWARD_TREND) {\r\nif (cq_count <= shared_timer->threshold_low &&\r\nshared_timer->threshold_low > 4) {\r\nshared_timer->threshold_low = shared_timer->threshold_low/2;\r\nshared_timer->cq_direction_downward=0;\r\nnesdev->currcq_count = 0;\r\nspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);\r\nreturn;\r\n}\r\n}\r\nif (cq_count > 1) {\r\nnesdev->deepcq_count += cq_count;\r\nif (cq_count <= shared_timer->threshold_low) {\r\nshared_timer->timer_direction_upward++;\r\nshared_timer->timer_direction_downward = 0;\r\n} else if (cq_count <= shared_timer->threshold_target) {\r\nshared_timer->timer_direction_upward = 0;\r\nshared_timer->timer_direction_downward = 0;\r\n} else if (cq_count <= shared_timer->threshold_high) {\r\nshared_timer->timer_direction_downward++;\r\nshared_timer->timer_direction_upward = 0;\r\n} else if (cq_count <= (shared_timer->threshold_high) * 2) {\r\nshared_timer->timer_in_use -= 2;\r\nshared_timer->timer_direction_upward = 0;\r\nshared_timer->timer_direction_downward++;\r\n} else {\r\nshared_timer->timer_in_use -= 4;\r\nshared_timer->timer_direction_upward = 0;\r\nshared_timer->timer_direction_downward++;\r\n}\r\nif (shared_timer->timer_direction_upward > 3 ) {\r\nshared_timer->timer_in_use += 3;\r\nshared_timer->timer_direction_upward = 0;\r\nshared_timer->timer_direction_downward = 0;\r\n}\r\nif (shared_timer->timer_direction_downward > 5) {\r\nshared_timer->timer_in_use -= 4 ;\r\nshared_timer->timer_direction_downward = 0;\r\nshared_timer->timer_direction_upward = 0;\r\n}\r\n}\r\nif (shared_timer->timer_in_use > shared_timer->threshold_high)\r\nshared_timer->timer_in_use = shared_timer->threshold_high;\r\nelse if (shared_timer->timer_in_use < shared_timer->threshold_low)\r\nshared_timer->timer_in_use = shared_timer->threshold_low;\r\nnesdev->currcq_count = 0;\r\nspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);\r\n}\r\nstruct nes_adapter *nes_init_adapter(struct nes_device *nesdev, u8 hw_rev) {\r\nstruct nes_adapter *nesadapter = NULL;\r\nunsigned long num_pds;\r\nu32 u32temp;\r\nu32 port_count;\r\nu16 max_rq_wrs;\r\nu16 max_sq_wrs;\r\nu32 max_mr;\r\nu32 max_256pbl;\r\nu32 max_4kpbl;\r\nu32 max_qp;\r\nu32 max_irrq;\r\nu32 max_cq;\r\nu32 hte_index_mask;\r\nu32 adapter_size;\r\nu32 arp_table_size;\r\nu16 vendor_id;\r\nu16 device_id;\r\nu8 OneG_Mode;\r\nu8 func_index;\r\nlist_for_each_entry(nesadapter, &nes_adapter_list, list) {\r\nnes_debug(NES_DBG_INIT, "Searching Adapter list for PCI devfn = 0x%X,"\r\n" adapter PCI slot/bus = %u/%u, pci devices PCI slot/bus = %u/%u, .\n",\r\nnesdev->pcidev->devfn,\r\nPCI_SLOT(nesadapter->devfn),\r\nnesadapter->bus_number,\r\nPCI_SLOT(nesdev->pcidev->devfn),\r\nnesdev->pcidev->bus->number );\r\nif ((PCI_SLOT(nesadapter->devfn) == PCI_SLOT(nesdev->pcidev->devfn)) &&\r\n(nesadapter->bus_number == nesdev->pcidev->bus->number)) {\r\nnesadapter->ref_count++;\r\nreturn nesadapter;\r\n}\r\n}\r\nnum_pds = pci_resource_len(nesdev->pcidev, BAR_1) >> PAGE_SHIFT;\r\nif ((hw_rev != NE020_REV) && (hw_rev != NE020_REV1)) {\r\nnes_debug(NES_DBG_INIT, "NE020 driver detected unknown hardware revision 0x%x\n",\r\nhw_rev);\r\nreturn NULL;\r\n}\r\nnes_debug(NES_DBG_INIT, "Determine Soft Reset, QP_control=0x%x, CPU0=0x%x, CPU1=0x%x, CPU2=0x%x\n",\r\nnes_read_indexed(nesdev, NES_IDX_QP_CONTROL + PCI_FUNC(nesdev->pcidev->devfn) * 8),\r\nnes_read_indexed(nesdev, NES_IDX_INT_CPU_STATUS),\r\nnes_read_indexed(nesdev, NES_IDX_INT_CPU_STATUS + 4),\r\nnes_read_indexed(nesdev, NES_IDX_INT_CPU_STATUS + 8));\r\nnes_debug(NES_DBG_INIT, "Reset and init NE020\n");\r\nif ((port_count = nes_reset_adapter_ne020(nesdev, &OneG_Mode)) == 0)\r\nreturn NULL;\r\nmax_qp = nes_read_indexed(nesdev, NES_IDX_QP_CTX_SIZE);\r\nnes_debug(NES_DBG_INIT, "QP_CTX_SIZE=%u\n", max_qp);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_QUAD_HASH_TABLE_SIZE);\r\nif (max_qp > ((u32)1 << (u32temp & 0x001f))) {\r\nnes_debug(NES_DBG_INIT, "Reducing Max QPs to %u due to hash table size = 0x%08X\n",\r\nmax_qp, u32temp);\r\nmax_qp = (u32)1 << (u32temp & 0x001f);\r\n}\r\nhte_index_mask = ((u32)1 << ((u32temp & 0x001f)+1))-1;\r\nnes_debug(NES_DBG_INIT, "Max QP = %u, hte_index_mask = 0x%08X.\n",\r\nmax_qp, hte_index_mask);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_IRRQ_COUNT);\r\nmax_irrq = 1 << (u32temp & 0x001f);\r\nif (max_qp > max_irrq) {\r\nmax_qp = max_irrq;\r\nnes_debug(NES_DBG_INIT, "Reducing Max QPs to %u due to Available Q1s.\n",\r\nmax_qp);\r\n}\r\nif (num_pds > max_qp)\r\nnum_pds = max_qp;\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MRT_SIZE);\r\nmax_mr = (u32)8192 << (u32temp & 0x7);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_PBL_REGION_SIZE);\r\nmax_256pbl = (u32)1 << (u32temp & 0x0000001f);\r\nmax_4kpbl = (u32)1 << ((u32temp >> 16) & 0x0000001f);\r\nmax_cq = nes_read_indexed(nesdev, NES_IDX_CQ_CTX_SIZE);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_ARP_CACHE_SIZE);\r\narp_table_size = 1 << u32temp;\r\nadapter_size = (sizeof(struct nes_adapter) +\r\n(sizeof(unsigned long)-1)) & (~(sizeof(unsigned long)-1));\r\nadapter_size += sizeof(unsigned long) * BITS_TO_LONGS(max_qp);\r\nadapter_size += sizeof(unsigned long) * BITS_TO_LONGS(max_mr);\r\nadapter_size += sizeof(unsigned long) * BITS_TO_LONGS(max_cq);\r\nadapter_size += sizeof(unsigned long) * BITS_TO_LONGS(num_pds);\r\nadapter_size += sizeof(unsigned long) * BITS_TO_LONGS(arp_table_size);\r\nadapter_size += sizeof(struct nes_qp **) * max_qp;\r\nnesadapter = kzalloc(adapter_size, GFP_KERNEL);\r\nif (!nesadapter)\r\nreturn NULL;\r\nnes_debug(NES_DBG_INIT, "Allocating new nesadapter @ %p, size = %u (actual size = %u).\n",\r\nnesadapter, (u32)sizeof(struct nes_adapter), adapter_size);\r\nif (nes_read_eeprom_values(nesdev, nesadapter)) {\r\nprintk(KERN_ERR PFX "Unable to read EEPROM data.\n");\r\nkfree(nesadapter);\r\nreturn NULL;\r\n}\r\nnesadapter->vendor_id = (((u32) nesadapter->mac_addr_high) << 8) |\r\n(nesadapter->mac_addr_low >> 24);\r\npci_bus_read_config_word(nesdev->pcidev->bus, nesdev->pcidev->devfn,\r\nPCI_DEVICE_ID, &device_id);\r\nnesadapter->vendor_part_id = device_id;\r\nif (nes_init_serdes(nesdev, hw_rev, port_count, nesadapter,\r\nOneG_Mode)) {\r\nkfree(nesadapter);\r\nreturn NULL;\r\n}\r\nnes_init_csr_ne020(nesdev, hw_rev, port_count);\r\nmemset(nesadapter->pft_mcast_map, 255,\r\nsizeof nesadapter->pft_mcast_map);\r\nnesadapter->devfn = nesdev->pcidev->devfn;\r\nnesadapter->bus_number = nesdev->pcidev->bus->number;\r\nnesadapter->ref_count = 1;\r\nnesadapter->timer_int_req = 0xffff0000;\r\nnesadapter->OneG_Mode = OneG_Mode;\r\nnesadapter->doorbell_start = nesdev->doorbell_region;\r\nnesadapter->hw_rev = hw_rev;\r\nnesadapter->port_count = port_count;\r\nnesadapter->max_qp = max_qp;\r\nnesadapter->hte_index_mask = hte_index_mask;\r\nnesadapter->max_irrq = max_irrq;\r\nnesadapter->max_mr = max_mr;\r\nnesadapter->max_256pbl = max_256pbl - 1;\r\nnesadapter->max_4kpbl = max_4kpbl - 1;\r\nnesadapter->max_cq = max_cq;\r\nnesadapter->free_256pbl = max_256pbl - 1;\r\nnesadapter->free_4kpbl = max_4kpbl - 1;\r\nnesadapter->max_pd = num_pds;\r\nnesadapter->arp_table_size = arp_table_size;\r\nnesadapter->et_pkt_rate_low = NES_TIMER_ENABLE_LIMIT;\r\nif (nes_drv_opt & NES_DRV_OPT_DISABLE_INT_MOD) {\r\nnesadapter->et_use_adaptive_rx_coalesce = 0;\r\nnesadapter->timer_int_limit = NES_TIMER_INT_LIMIT;\r\nnesadapter->et_rx_coalesce_usecs_irq = interrupt_mod_interval;\r\n} else {\r\nnesadapter->et_use_adaptive_rx_coalesce = 1;\r\nnesadapter->timer_int_limit = NES_TIMER_INT_LIMIT_DYNAMIC;\r\nnesadapter->et_rx_coalesce_usecs_irq = 0;\r\nprintk(PFX "%s: Using Adaptive Interrupt Moderation\n", __func__);\r\n}\r\nif (nesadapter->et_rx_coalesce_usecs_irq)\r\nnes_write32(nesdev->regs+NES_PERIODIC_CONTROL, 0x80000000 |\r\n((u32)(nesadapter->et_rx_coalesce_usecs_irq * 8)));\r\nelse\r\nnes_write32(nesdev->regs+NES_PERIODIC_CONTROL, 0x00000000);\r\nnesadapter->base_pd = 1;\r\nnesadapter->device_cap_flags = IB_DEVICE_LOCAL_DMA_LKEY |\r\nIB_DEVICE_MEM_WINDOW |\r\nIB_DEVICE_MEM_MGT_EXTENSIONS;\r\nnesadapter->allocated_qps = (unsigned long *)&(((unsigned char *)nesadapter)\r\n[(sizeof(struct nes_adapter)+(sizeof(unsigned long)-1))&(~(sizeof(unsigned long\r\nunsigned int nes_reset_adapter_ne020(struct nes_device *nesdev, u8 *OneG_Mode)\r\n{\r\nu32 port_count;\r\nu32 u32temp;\r\nu32 i;\r\nu32temp = nes_read32(nesdev->regs+NES_SOFTWARE_RESET);\r\nport_count = ((u32temp & 0x00000300) >> 8) + 1;\r\n*OneG_Mode = (u32temp & 0x00003c00) ? 0 : 1;\r\nnes_debug(NES_DBG_INIT, "Initial Software Reset = 0x%08X, port_count=%u\n",\r\nu32temp, port_count);\r\nif (*OneG_Mode)\r\nnes_debug(NES_DBG_INIT, "Running in 1G mode.\n");\r\nu32temp &= 0xff00ffc0;\r\nswitch (port_count) {\r\ncase 1:\r\nu32temp |= 0x00ee0000;\r\nbreak;\r\ncase 2:\r\nu32temp |= 0x00cc0000;\r\nbreak;\r\ncase 4:\r\nu32temp |= 0x00000000;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\nbreak;\r\n}\r\nif (nes_read_indexed(nesdev, NES_IDX_QP_CONTROL+(PCI_FUNC(nesdev->pcidev->devfn)*8))) {\r\nnes_debug(NES_DBG_INIT, "Issuing Full Soft reset = 0x%08X\n", u32temp | 0xd);\r\nnes_write32(nesdev->regs+NES_SOFTWARE_RESET, u32temp | 0xd);\r\ni = 0;\r\nwhile (((nes_read32(nesdev->regs+NES_SOFTWARE_RESET) & 0x00000040) == 0) && i++ < 10000)\r\nmdelay(1);\r\nif (i > 10000) {\r\nnes_debug(NES_DBG_INIT, "Did not see full soft reset done.\n");\r\nreturn 0;\r\n}\r\ni = 0;\r\nwhile ((nes_read_indexed(nesdev, NES_IDX_INT_CPU_STATUS) != 0x80) && i++ < 10000)\r\nmdelay(1);\r\nif (i > 10000) {\r\nprintk(KERN_ERR PFX "Internal CPU not ready, status = %02X\n",\r\nnes_read_indexed(nesdev, NES_IDX_INT_CPU_STATUS));\r\nreturn 0;\r\n}\r\n}\r\nswitch (port_count) {\r\ncase 1:\r\nu32temp |= 0x00ee0010;\r\nbreak;\r\ncase 2:\r\nu32temp |= 0x00cc0030;\r\nbreak;\r\ncase 4:\r\nu32temp |= 0x00000030;\r\nbreak;\r\n}\r\nnes_debug(NES_DBG_INIT, "Issuing Port Soft reset = 0x%08X\n", u32temp | 0xd);\r\nnes_write32(nesdev->regs+NES_SOFTWARE_RESET, u32temp | 0xd);\r\ni = 0;\r\nwhile (((nes_read32(nesdev->regs+NES_SOFTWARE_RESET) & 0x00000040) == 0) && i++ < 10000)\r\nmdelay(1);\r\nif (i > 10000) {\r\nnes_debug(NES_DBG_INIT, "Did not see port soft reset done.\n");\r\nreturn 0;\r\n}\r\ni = 0;\r\nwhile (((u32temp = (nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS0)\r\n& 0x0000000f)) != 0x0000000f) && i++ < 5000)\r\nmdelay(1);\r\nif (i > 5000) {\r\nnes_debug(NES_DBG_INIT, "Serdes 0 not ready, status=%x\n", u32temp);\r\nreturn 0;\r\n}\r\nif (port_count > 1) {\r\ni = 0;\r\nwhile (((u32temp = (nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS1)\r\n& 0x0000000f)) != 0x0000000f) && i++ < 5000)\r\nmdelay(1);\r\nif (i > 5000) {\r\nnes_debug(NES_DBG_INIT, "Serdes 1 not ready, status=%x\n", u32temp);\r\nreturn 0;\r\n}\r\n}\r\nreturn port_count;\r\n}\r\nstatic int nes_init_serdes(struct nes_device *nesdev, u8 hw_rev, u8 port_count,\r\nstruct nes_adapter *nesadapter, u8 OneG_Mode)\r\n{\r\nint i;\r\nu32 u32temp;\r\nu32 sds;\r\nif (hw_rev != NE020_REV) {\r\nswitch (nesadapter->phy_type[0]) {\r\ncase NES_PHY_TYPE_CX4:\r\nif (wide_ppm_offset)\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000FFFAA);\r\nelse\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000000FF);\r\nbreak;\r\ncase NES_PHY_TYPE_KR:\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000000FF);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP0, 0x00000000);\r\nbreak;\r\ncase NES_PHY_TYPE_PUMA_1G:\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000000FF);\r\nsds = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0);\r\nsds |= 0x00000100;\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0, sds);\r\nbreak;\r\ndefault:\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000000FF);\r\nbreak;\r\n}\r\nif (!OneG_Mode)\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_HIGHZ_LANE_MODE0, 0x11110000);\r\nif (port_count < 2)\r\nreturn 0;\r\nif (!(OneG_Mode && (nesadapter->phy_type[1] != NES_PHY_TYPE_PUMA_1G)))\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL1, 0x000000FF);\r\nswitch (nesadapter->phy_type[1]) {\r\ncase NES_PHY_TYPE_ARGUS:\r\ncase NES_PHY_TYPE_SFP_D:\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP0, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP1, 0x00000000);\r\nbreak;\r\ncase NES_PHY_TYPE_CX4:\r\nif (wide_ppm_offset)\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL1, 0x000FFFAA);\r\nbreak;\r\ncase NES_PHY_TYPE_KR:\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP1, 0x00000000);\r\nbreak;\r\ncase NES_PHY_TYPE_PUMA_1G:\r\nsds = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1);\r\nsds |= 0x000000100;\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, sds);\r\n}\r\nif (!OneG_Mode) {\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_HIGHZ_LANE_MODE1, 0x11110000);\r\nsds = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1);\r\nsds &= 0xFFFFFFBF;\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, sds);\r\n}\r\n} else {\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0, 0x00000008);\r\ni = 0;\r\nwhile (((u32temp = (nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS0)\r\n& 0x0000000f)) != 0x0000000f) && i++ < 5000)\r\nmdelay(1);\r\nif (i > 5000) {\r\nnes_debug(NES_DBG_PHY, "Init: serdes 0 not ready, status=%x\n", u32temp);\r\nreturn 1;\r\n}\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP0, 0x000bdef7);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_DRIVE0, 0x9ce73000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_MODE0, 0x0ff00000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_SIGDET0, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_BYPASS0, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_LOOPBACK_CONTROL0, 0x00000000);\r\nif (OneG_Mode)\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_EQ_CONTROL0, 0xf0182222);\r\nelse\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_EQ_CONTROL0, 0xf0042222);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000000ff);\r\nif (port_count > 1) {\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, 0x00000048);\r\ni = 0;\r\nwhile (((u32temp = (nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS1)\r\n& 0x0000000f)) != 0x0000000f) && (i++ < 5000))\r\nmdelay(1);\r\nif (i > 5000) {\r\nprintk("%s: Init: serdes 1 not ready, status=%x\n", __func__, u32temp);\r\n}\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP1, 0x000bdef7);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_DRIVE1, 0x9ce73000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_MODE1, 0x0ff00000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_SIGDET1, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_BYPASS1, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_LOOPBACK_CONTROL1, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_EQ_CONTROL1, 0xf0002222);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL1, 0x000000ff);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void nes_init_csr_ne020(struct nes_device *nesdev, u8 hw_rev, u8 port_count)\r\n{\r\nu32 u32temp;\r\nnes_debug(NES_DBG_INIT, "port_count=%d\n", port_count);\r\nnes_write_indexed(nesdev, 0x000001E4, 0x00000007);\r\nnes_write_indexed(nesdev, 0x000001E8, 0x00020874);\r\nnes_write_indexed(nesdev, 0x000001D8, 0x00048002);\r\nnes_write_indexed(nesdev, 0x000001FC, 0x00050005);\r\nnes_write_indexed(nesdev, 0x00000600, 0x55555555);\r\nnes_write_indexed(nesdev, 0x00000604, 0x55555555);\r\nnes_write_indexed(nesdev, 0x00002000, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002004, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002008, 0x0000FFFF);\r\nnes_write_indexed(nesdev, 0x0000200C, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002010, 0x000003c1);\r\nnes_write_indexed(nesdev, 0x0000201C, 0x75345678);\r\nif (port_count > 1) {\r\nnes_write_indexed(nesdev, 0x00002200, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002204, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002208, 0x0000FFFF);\r\nnes_write_indexed(nesdev, 0x0000220C, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002210, 0x000003c1);\r\nnes_write_indexed(nesdev, 0x0000221C, 0x75345678);\r\nnes_write_indexed(nesdev, 0x00000908, 0x20000001);\r\n}\r\nif (port_count > 2) {\r\nnes_write_indexed(nesdev, 0x00002400, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002404, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002408, 0x0000FFFF);\r\nnes_write_indexed(nesdev, 0x0000240C, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002410, 0x000003c1);\r\nnes_write_indexed(nesdev, 0x0000241C, 0x75345678);\r\nnes_write_indexed(nesdev, 0x00000910, 0x20000001);\r\nnes_write_indexed(nesdev, 0x00002600, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002604, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002608, 0x0000FFFF);\r\nnes_write_indexed(nesdev, 0x0000260C, 0x00000001);\r\nnes_write_indexed(nesdev, 0x00002610, 0x000003c1);\r\nnes_write_indexed(nesdev, 0x0000261C, 0x75345678);\r\nnes_write_indexed(nesdev, 0x00000918, 0x20000001);\r\n}\r\nnes_write_indexed(nesdev, 0x00005000, 0x00018000);\r\nnes_write_indexed(nesdev, NES_IDX_WQM_CONFIG1, (wqm_quanta << 1) |\r\n0x00000001);\r\nnes_write_indexed(nesdev, 0x00005008, 0x1F1F1F1F);\r\nnes_write_indexed(nesdev, 0x00005010, 0x1F1F1F1F);\r\nnes_write_indexed(nesdev, 0x00005018, 0x1F1F1F1F);\r\nnes_write_indexed(nesdev, 0x00005020, 0x1F1F1F1F);\r\nnes_write_indexed(nesdev, 0x00006090, 0xFFFFFFFF);\r\nnes_write_indexed(nesdev, 0x00000900, 0x20000001);\r\nnes_write_indexed(nesdev, 0x000060C0, 0x0000028e);\r\nnes_write_indexed(nesdev, 0x000060C8, 0x00000020);\r\nnes_write_indexed(nesdev, 0x000001EC, 0x7b2625a0);\r\nif (hw_rev != NE020_REV) {\r\nu32temp = nes_read_indexed(nesdev, 0x000008e8);\r\nu32temp |= 0x80000000;\r\nnes_write_indexed(nesdev, 0x000008e8, u32temp);\r\nu32temp = nes_read_indexed(nesdev, 0x000021f8);\r\nu32temp &= 0x7fffffff;\r\nu32temp |= 0x7fff0010;\r\nnes_write_indexed(nesdev, 0x000021f8, u32temp);\r\nif (port_count > 1) {\r\nu32temp = nes_read_indexed(nesdev, 0x000023f8);\r\nu32temp &= 0x7fffffff;\r\nu32temp |= 0x7fff0010;\r\nnes_write_indexed(nesdev, 0x000023f8, u32temp);\r\n}\r\n}\r\n}\r\nvoid nes_destroy_adapter(struct nes_adapter *nesadapter)\r\n{\r\nstruct nes_adapter *tmp_adapter;\r\nlist_for_each_entry(tmp_adapter, &nes_adapter_list, list) {\r\nnes_debug(NES_DBG_SHUTDOWN, "Nes Adapter list entry = 0x%p.\n",\r\ntmp_adapter);\r\n}\r\nnesadapter->ref_count--;\r\nif (!nesadapter->ref_count) {\r\nif (nesadapter->hw_rev == NE020_REV) {\r\ndel_timer(&nesadapter->mh_timer);\r\n}\r\ndel_timer(&nesadapter->lc_timer);\r\nlist_del(&nesadapter->list);\r\nkfree(nesadapter);\r\n}\r\n}\r\nint nes_init_cqp(struct nes_device *nesdev)\r\n{\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_cqp_qp_context *cqp_qp_context;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_hw_ceq *ceq;\r\nstruct nes_hw_ceq *nic_ceq;\r\nstruct nes_hw_aeq *aeq;\r\nvoid *vmem;\r\ndma_addr_t pmem;\r\nu32 count=0;\r\nu32 cqp_head;\r\nu64 u64temp;\r\nu32 u32temp;\r\nnesdev->cqp_mem_size = 512 +\r\n(sizeof(struct nes_hw_cqp_wqe) * NES_CQP_SQ_SIZE) +\r\n(sizeof(struct nes_hw_cqe) * NES_CCQ_SIZE) +\r\nmax(((u32)sizeof(struct nes_hw_ceqe) * NES_CCEQ_SIZE), (u32)256) +\r\nmax(((u32)sizeof(struct nes_hw_ceqe) * NES_NIC_CEQ_SIZE), (u32)256) +\r\n(sizeof(struct nes_hw_aeqe) * nesadapter->max_qp) +\r\nsizeof(struct nes_hw_cqp_qp_context);\r\nnesdev->cqp_vbase = pci_zalloc_consistent(nesdev->pcidev,\r\nnesdev->cqp_mem_size,\r\n&nesdev->cqp_pbase);\r\nif (!nesdev->cqp_vbase) {\r\nnes_debug(NES_DBG_INIT, "Unable to allocate memory for host descriptor rings\n");\r\nreturn -ENOMEM;\r\n}\r\nnesdev->nes_cqp_requests = kzalloc(sizeof(struct nes_cqp_request) *\r\n2 * NES_CQP_SQ_SIZE, GFP_KERNEL);\r\nif (!nesdev->nes_cqp_requests) {\r\npci_free_consistent(nesdev->pcidev, nesdev->cqp_mem_size, nesdev->cqp.sq_vbase,\r\nnesdev->cqp.sq_pbase);\r\nreturn -ENOMEM;\r\n}\r\nnes_debug(NES_DBG_INIT, "Allocated CQP structures at %p (phys = %016lX), size = %u.\n",\r\nnesdev->cqp_vbase, (unsigned long)nesdev->cqp_pbase, nesdev->cqp_mem_size);\r\nspin_lock_init(&nesdev->cqp.lock);\r\ninit_waitqueue_head(&nesdev->cqp.waitq);\r\nvmem = (void *)(((unsigned long)nesdev->cqp_vbase + (512 - 1)) &\r\n~(unsigned long)(512 - 1));\r\npmem = (dma_addr_t)(((unsigned long long)nesdev->cqp_pbase + (512 - 1)) &\r\n~(unsigned long long)(512 - 1));\r\nnesdev->cqp.sq_vbase = vmem;\r\nnesdev->cqp.sq_pbase = pmem;\r\nnesdev->cqp.sq_size = NES_CQP_SQ_SIZE;\r\nnesdev->cqp.sq_head = 0;\r\nnesdev->cqp.sq_tail = 0;\r\nnesdev->cqp.qp_id = PCI_FUNC(nesdev->pcidev->devfn);\r\nvmem += (sizeof(struct nes_hw_cqp_wqe) * nesdev->cqp.sq_size);\r\npmem += (sizeof(struct nes_hw_cqp_wqe) * nesdev->cqp.sq_size);\r\nnesdev->ccq.cq_vbase = vmem;\r\nnesdev->ccq.cq_pbase = pmem;\r\nnesdev->ccq.cq_size = NES_CCQ_SIZE;\r\nnesdev->ccq.cq_head = 0;\r\nnesdev->ccq.ce_handler = nes_cqp_ce_handler;\r\nnesdev->ccq.cq_number = PCI_FUNC(nesdev->pcidev->devfn);\r\nvmem += (sizeof(struct nes_hw_cqe) * nesdev->ccq.cq_size);\r\npmem += (sizeof(struct nes_hw_cqe) * nesdev->ccq.cq_size);\r\nnesdev->ceq_index = PCI_FUNC(nesdev->pcidev->devfn);\r\nceq = &nesadapter->ceq[nesdev->ceq_index];\r\nceq->ceq_vbase = vmem;\r\nceq->ceq_pbase = pmem;\r\nceq->ceq_size = NES_CCEQ_SIZE;\r\nceq->ceq_head = 0;\r\nvmem += max(((u32)sizeof(struct nes_hw_ceqe) * ceq->ceq_size), (u32)256);\r\npmem += max(((u32)sizeof(struct nes_hw_ceqe) * ceq->ceq_size), (u32)256);\r\nnesdev->nic_ceq_index = PCI_FUNC(nesdev->pcidev->devfn) + 8;\r\nnic_ceq = &nesadapter->ceq[nesdev->nic_ceq_index];\r\nnic_ceq->ceq_vbase = vmem;\r\nnic_ceq->ceq_pbase = pmem;\r\nnic_ceq->ceq_size = NES_NIC_CEQ_SIZE;\r\nnic_ceq->ceq_head = 0;\r\nvmem += max(((u32)sizeof(struct nes_hw_ceqe) * nic_ceq->ceq_size), (u32)256);\r\npmem += max(((u32)sizeof(struct nes_hw_ceqe) * nic_ceq->ceq_size), (u32)256);\r\naeq = &nesadapter->aeq[PCI_FUNC(nesdev->pcidev->devfn)];\r\naeq->aeq_vbase = vmem;\r\naeq->aeq_pbase = pmem;\r\naeq->aeq_size = nesadapter->max_qp;\r\naeq->aeq_head = 0;\r\nvmem += (sizeof(struct nes_hw_aeqe) * aeq->aeq_size);\r\npmem += (sizeof(struct nes_hw_aeqe) * aeq->aeq_size);\r\ncqp_qp_context = vmem;\r\ncqp_qp_context->context_words[0] =\r\ncpu_to_le32((PCI_FUNC(nesdev->pcidev->devfn) << 12) + (2 << 10));\r\ncqp_qp_context->context_words[1] = 0;\r\ncqp_qp_context->context_words[2] = cpu_to_le32((u32)nesdev->cqp.sq_pbase);\r\ncqp_qp_context->context_words[3] = cpu_to_le32(((u64)nesdev->cqp.sq_pbase) >> 32);\r\nif ((sizeof(dma_addr_t) > 4)) {\r\nnes_write_indexed(nesdev,\r\nNES_IDX_CREATE_CQP_HIGH + (PCI_FUNC(nesdev->pcidev->devfn) * 8),\r\n((u64)pmem) >> 32);\r\n} else {\r\nnes_write_indexed(nesdev,\r\nNES_IDX_CREATE_CQP_HIGH + (PCI_FUNC(nesdev->pcidev->devfn) * 8), 0);\r\n}\r\nnes_write_indexed(nesdev,\r\nNES_IDX_CREATE_CQP_LOW + (PCI_FUNC(nesdev->pcidev->devfn) * 8),\r\n(u32)pmem);\r\nINIT_LIST_HEAD(&nesdev->cqp_avail_reqs);\r\nINIT_LIST_HEAD(&nesdev->cqp_pending_reqs);\r\nfor (count = 0; count < 2*NES_CQP_SQ_SIZE; count++) {\r\ninit_waitqueue_head(&nesdev->nes_cqp_requests[count].waitq);\r\nlist_add_tail(&nesdev->nes_cqp_requests[count].list, &nesdev->cqp_avail_reqs);\r\n}\r\ncqp_head = nesdev->cqp.sq_head++;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_CREATE_CQ | NES_CQP_CQ_CEQ_VALID |\r\nNES_CQP_CQ_CHK_OVERFLOW | ((u32)nesdev->ccq.cq_size << 16)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\n(nesdev->ccq.cq_number |\r\n((u32)nesdev->ceq_index << 16)));\r\nu64temp = (u64)nesdev->ccq.cq_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] = 0;\r\nu64temp = (unsigned long)&nesdev->ccq;\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_LOW_IDX] =\r\ncpu_to_le32((u32)(u64temp >> 1));\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] =\r\ncpu_to_le32(((u32)((u64temp) >> 33)) & 0x7FFFFFFF);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_DOORBELL_INDEX_HIGH_IDX] = 0;\r\ncqp_head = nesdev->cqp.sq_head++;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_CREATE_CEQ + ((u32)nesdev->ceq_index << 8)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_CEQ_WQE_ELEMENT_COUNT_IDX, ceq->ceq_size);\r\nu64temp = (u64)ceq->ceq_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncqp_head = nesdev->cqp.sq_head++;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_CREATE_AEQ + ((u32)PCI_FUNC(nesdev->pcidev->devfn) << 8)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_AEQ_WQE_ELEMENT_COUNT_IDX, aeq->aeq_size);\r\nu64temp = (u64)aeq->aeq_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncqp_head = nesdev->cqp.sq_head++;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_CREATE_CEQ + ((u32)nesdev->nic_ceq_index << 8)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_CEQ_WQE_ELEMENT_COUNT_IDX, nic_ceq->ceq_size);\r\nu64temp = (u64)nic_ceq->ceq_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncount = 0;\r\ndo {\r\nif (count++ > 1000) {\r\nprintk(KERN_ERR PFX "Error creating CQP\n");\r\npci_free_consistent(nesdev->pcidev, nesdev->cqp_mem_size,\r\nnesdev->cqp_vbase, nesdev->cqp_pbase);\r\nreturn -1;\r\n}\r\nudelay(10);\r\n} while (!(nes_read_indexed(nesdev,\r\nNES_IDX_QP_CONTROL + (PCI_FUNC(nesdev->pcidev->devfn) * 8)) & (1 << 8)));\r\nnes_debug(NES_DBG_INIT, "CQP Status = 0x%08X\n", nes_read_indexed(nesdev,\r\nNES_IDX_QP_CONTROL+(PCI_FUNC(nesdev->pcidev->devfn)*8)));\r\nu32temp = 0x04800000;\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, u32temp | nesdev->cqp.qp_id);\r\ncount = 0;\r\ndo {\r\nif (count++ > 1000) {\r\nprintk(KERN_ERR PFX "Error creating CCQ, CEQ, and AEQ\n");\r\npci_free_consistent(nesdev->pcidev, nesdev->cqp_mem_size,\r\nnesdev->cqp_vbase, nesdev->cqp_pbase);\r\nreturn -1;\r\n}\r\nudelay(10);\r\n} while (((nes_read_indexed(nesdev,\r\nNES_IDX_QP_CONTROL+(PCI_FUNC(nesdev->pcidev->devfn)*8)) & (15<<8)) != (15<<8)));\r\nnes_debug(NES_DBG_INIT, "QP Status = 0x%08X\n", nes_read_indexed(nesdev,\r\nNES_IDX_QP_CONTROL+(PCI_FUNC(nesdev->pcidev->devfn)*8)));\r\nnesdev->cqp.sq_tail++;\r\nreturn 0;\r\n}\r\nint nes_destroy_cqp(struct nes_device *nesdev)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nu32 count = 0;\r\nu32 cqp_head;\r\nunsigned long flags;\r\ndo {\r\nif (count++ > 1000)\r\nbreak;\r\nudelay(10);\r\n} while (!(nesdev->cqp.sq_head == nesdev->cqp.sq_tail));\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC, NES_CQE_ALLOC_RESET |\r\nnesdev->ccq.cq_number);\r\nnes_write32(nesdev->regs+NES_INT_MASK, 0x7fffffff);\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\ncqp_head = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_DESTROY_AEQ |\r\n((u32)PCI_FUNC(nesdev->pcidev->devfn) << 8));\r\ncqp_wqe->wqe_words[NES_CQP_WQE_COMP_CTX_HIGH_IDX] = 0;\r\ncqp_head = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_DESTROY_CEQ |\r\n((u32)nesdev->nic_ceq_index << 8));\r\ncqp_head = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_DESTROY_CEQ |\r\n(nesdev->ceq_index << 8));\r\ncqp_head = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_DESTROY_CQ);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(nesdev->ccq.cq_number |\r\n((u32)nesdev->ceq_index << 16));\r\ncqp_head = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_DESTROY_QP |\r\nNES_CQP_QP_TYPE_CQP);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(nesdev->cqp.qp_id);\r\nbarrier();\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, 0x05800000 | nesdev->cqp.qp_id);\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\ncount = 0;\r\ndo {\r\nif (count++ > 1000) {\r\nprintk(KERN_ERR PFX "Function%d: Error destroying CCQ, CEQ, and AEQ\n",\r\nPCI_FUNC(nesdev->pcidev->devfn));\r\nbreak;\r\n}\r\nudelay(10);\r\n} while (((nes_read_indexed(nesdev,\r\nNES_IDX_QP_CONTROL + (PCI_FUNC(nesdev->pcidev->devfn)*8)) & (15 << 8)) != 0));\r\nnes_debug(NES_DBG_SHUTDOWN, "Function%d: QP Status = 0x%08X\n",\r\nPCI_FUNC(nesdev->pcidev->devfn),\r\nnes_read_indexed(nesdev,\r\nNES_IDX_QP_CONTROL+(PCI_FUNC(nesdev->pcidev->devfn)*8)));\r\nkfree(nesdev->nes_cqp_requests);\r\npci_free_consistent(nesdev->pcidev, nesdev->cqp_mem_size, nesdev->cqp.sq_vbase,\r\nnesdev->cqp.sq_pbase);\r\nreturn 0;\r\n}\r\nstatic int nes_init_1g_phy(struct nes_device *nesdev, u8 phy_type, u8 phy_index)\r\n{\r\nu32 counter = 0;\r\nu16 phy_data;\r\nint ret = 0;\r\nnes_read_1G_phy_reg(nesdev, 1, phy_index, &phy_data);\r\nnes_write_1G_phy_reg(nesdev, 23, phy_index, 0xb000);\r\nnes_write_1G_phy_reg(nesdev, 0, phy_index, 0x8000);\r\nudelay(100);\r\ncounter = 0;\r\ndo {\r\nnes_read_1G_phy_reg(nesdev, 0, phy_index, &phy_data);\r\nif (counter++ > 100) {\r\nret = -1;\r\nbreak;\r\n}\r\n} while (phy_data & 0x8000);\r\nphy_data &= 0xbfff;\r\nphy_data |= 0x1140;\r\nnes_write_1G_phy_reg(nesdev, 0, phy_index, phy_data);\r\nnes_read_1G_phy_reg(nesdev, 0, phy_index, &phy_data);\r\nnes_read_1G_phy_reg(nesdev, 0x17, phy_index, &phy_data);\r\nnes_read_1G_phy_reg(nesdev, 0x1e, phy_index, &phy_data);\r\nnes_read_1G_phy_reg(nesdev, 0x19, phy_index, &phy_data);\r\nnes_write_1G_phy_reg(nesdev, 0x19, phy_index, 0xffee);\r\nnes_read_1G_phy_reg(nesdev, 0x19, phy_index, &phy_data);\r\nnes_read_1G_phy_reg(nesdev, 4, phy_index, &phy_data);\r\nnes_write_1G_phy_reg(nesdev, 4, phy_index, (phy_data & ~(0x03E0)) | 0xc00);\r\nnes_read_1G_phy_reg(nesdev, 4, phy_index, &phy_data);\r\nnes_read_1G_phy_reg(nesdev, 9, phy_index, &phy_data);\r\nnes_write_1G_phy_reg(nesdev, 9, phy_index, phy_data & ~(0x0100));\r\nnes_read_1G_phy_reg(nesdev, 9, phy_index, &phy_data);\r\nnes_read_1G_phy_reg(nesdev, 0, phy_index, &phy_data);\r\nnes_write_1G_phy_reg(nesdev, 0, phy_index, phy_data | 0x0300);\r\nreturn ret;\r\n}\r\nstatic int nes_init_2025_phy(struct nes_device *nesdev, u8 phy_type, u8 phy_index)\r\n{\r\nu32 temp_phy_data = 0;\r\nu32 temp_phy_data2 = 0;\r\nu32 counter = 0;\r\nu32 sds;\r\nu32 mac_index = nesdev->mac_index;\r\nint ret = 0;\r\nunsigned int first_attempt = 1;\r\nnes_read_10G_phy_reg(nesdev, phy_index, 0x3, 0xd7ee);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nudelay(1500);\r\nnes_read_10G_phy_reg(nesdev, phy_index, 0x3, 0xd7ee);\r\ntemp_phy_data2 = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nif (temp_phy_data != temp_phy_data2) {\r\nnes_read_10G_phy_reg(nesdev, phy_index, 0x3, 0xd7fd);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nif ((temp_phy_data & 0xff) > 0x20)\r\nreturn 0;\r\nprintk(PFX "Reinitialize external PHY\n");\r\n}\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0x0000, 0x8000);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc300, 0x0000);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc316, 0x000A);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc318, 0x0052);\r\nswitch (phy_type) {\r\ncase NES_PHY_TYPE_ARGUS:\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc316, 0x000A);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc318, 0x0052);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc302, 0x000C);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc319, 0x0008);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0027, 0x0001);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc31a, 0x0098);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0026, 0x0E00);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd006, 0x0007);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd007, 0x000A);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd008, 0x0009);\r\nbreak;\r\ncase NES_PHY_TYPE_SFP_D:\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc316, 0x000A);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc318, 0x0052);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc302, 0x0004);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc319, 0x0038);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0027, 0x0013);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc31a, 0x0098);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0026, 0x0E00);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd006, 0x0007);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd007, 0x000A);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd008, 0x0009);\r\nbreak;\r\ncase NES_PHY_TYPE_KR:\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc316, 0x000A);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc318, 0x0052);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc302, 0x000C);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc319, 0x0010);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0027, 0x0013);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc31a, 0x0080);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0026, 0x0E00);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd006, 0x000B);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd007, 0x0003);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd008, 0x0004);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0022, 0x406D);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0023, 0x0020);\r\nbreak;\r\n}\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0x0028, 0xA528);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc300, 0x0002);\r\ncounter = 0;\r\nmdelay(690);\r\nnes_read_10G_phy_reg(nesdev, phy_index, 0x3, 0xd7ee);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\ndo {\r\nif (counter++ > 150) {\r\nprintk(PFX "No PHY heartbeat\n");\r\nbreak;\r\n}\r\nmdelay(1);\r\nnes_read_10G_phy_reg(nesdev, phy_index, 0x3, 0xd7ee);\r\ntemp_phy_data2 = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\n} while ((temp_phy_data2 == temp_phy_data));\r\ncounter = 0;\r\ndo {\r\nnes_read_10G_phy_reg(nesdev, phy_index, 0x3, 0xd7fd);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nif (counter++ > 300) {\r\nif (((temp_phy_data & 0xff) == 0x0) && first_attempt) {\r\nfirst_attempt = 0;\r\ncounter = 0;\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0xe854, 0x00c0);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x3, 0xe854, 0x0040);\r\ncontinue;\r\n} else {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nmdelay(10);\r\n} while ((temp_phy_data & 0xff) < 0x30);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xd003, 0x0000);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xF00D, 0x00FE);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xF00E, 0x0032);\r\nif (phy_type == NES_PHY_TYPE_KR) {\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xF00F, 0x000C);\r\n} else {\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xF00F, 0x0002);\r\nnes_write_10G_phy_reg(nesdev, phy_index, 0x1, 0xc314, 0x0063);\r\n}\r\nsds = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0 + mac_index * 0x200);\r\nsds |= 0x1;\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0 + mac_index * 0x200, sds);\r\nsds &= 0xfffffffe;\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0 + mac_index * 0x200, sds);\r\ncounter = 0;\r\nwhile (((nes_read32(nesdev->regs + NES_SOFTWARE_RESET) & 0x00000040) != 0x00000040)\r\n&& (counter++ < 5000))\r\n;\r\nreturn ret;\r\n}\r\nint nes_init_phy(struct nes_device *nesdev)\r\n{\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 mac_index = nesdev->mac_index;\r\nu32 tx_config = 0;\r\nunsigned long flags;\r\nu8 phy_type = nesadapter->phy_type[mac_index];\r\nu8 phy_index = nesadapter->phy_index[mac_index];\r\nint ret = 0;\r\ntx_config = nes_read_indexed(nesdev, NES_IDX_MAC_TX_CONFIG);\r\nif (phy_type == NES_PHY_TYPE_1G) {\r\ntx_config &= 0xFFFFFFE3;\r\ntx_config |= 0x04;\r\n} else {\r\ntx_config &= 0xFFFFFFE3;\r\ntx_config |= 0x1D;\r\n}\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_CONFIG, tx_config);\r\nspin_lock_irqsave(&nesdev->nesadapter->phy_lock, flags);\r\nswitch (phy_type) {\r\ncase NES_PHY_TYPE_1G:\r\nret = nes_init_1g_phy(nesdev, phy_type, phy_index);\r\nbreak;\r\ncase NES_PHY_TYPE_ARGUS:\r\ncase NES_PHY_TYPE_SFP_D:\r\ncase NES_PHY_TYPE_KR:\r\nret = nes_init_2025_phy(nesdev, phy_type, phy_index);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&nesdev->nesadapter->phy_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void nes_replenish_nic_rq(struct nes_vnic *nesvnic)\r\n{\r\nunsigned long flags;\r\ndma_addr_t bus_address;\r\nstruct sk_buff *skb;\r\nstruct nes_hw_nic_rq_wqe *nic_rqe;\r\nstruct nes_hw_nic *nesnic;\r\nstruct nes_device *nesdev;\r\nstruct nes_rskb_cb *cb;\r\nu32 rx_wqes_posted = 0;\r\nnesnic = &nesvnic->nic;\r\nnesdev = nesvnic->nesdev;\r\nspin_lock_irqsave(&nesnic->rq_lock, flags);\r\nif (nesnic->replenishing_rq !=0) {\r\nif (((nesnic->rq_size-1) == atomic_read(&nesvnic->rx_skbs_needed)) &&\r\n(atomic_read(&nesvnic->rx_skb_timer_running) == 0)) {\r\natomic_set(&nesvnic->rx_skb_timer_running, 1);\r\nspin_unlock_irqrestore(&nesnic->rq_lock, flags);\r\nnesvnic->rq_wqes_timer.expires = jiffies + (HZ/2);\r\nadd_timer(&nesvnic->rq_wqes_timer);\r\n} else\r\nspin_unlock_irqrestore(&nesnic->rq_lock, flags);\r\nreturn;\r\n}\r\nnesnic->replenishing_rq = 1;\r\nspin_unlock_irqrestore(&nesnic->rq_lock, flags);\r\ndo {\r\nskb = dev_alloc_skb(nesvnic->max_frame_size);\r\nif (skb) {\r\nskb->dev = nesvnic->netdev;\r\nbus_address = pci_map_single(nesdev->pcidev,\r\nskb->data, nesvnic->max_frame_size, PCI_DMA_FROMDEVICE);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->busaddr = bus_address;\r\ncb->maplen = nesvnic->max_frame_size;\r\nnic_rqe = &nesnic->rq_vbase[nesvnic->nic.rq_head];\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_1_0_IDX] =\r\ncpu_to_le32(nesvnic->max_frame_size);\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_3_2_IDX] = 0;\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX] =\r\ncpu_to_le32((u32)bus_address);\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX] =\r\ncpu_to_le32((u32)((u64)bus_address >> 32));\r\nnesnic->rx_skb[nesnic->rq_head] = skb;\r\nnesnic->rq_head++;\r\nnesnic->rq_head &= nesnic->rq_size - 1;\r\natomic_dec(&nesvnic->rx_skbs_needed);\r\nbarrier();\r\nif (++rx_wqes_posted == 255) {\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, (rx_wqes_posted << 24) | nesnic->qp_id);\r\nrx_wqes_posted = 0;\r\n}\r\n} else {\r\nspin_lock_irqsave(&nesnic->rq_lock, flags);\r\nif (((nesnic->rq_size-1) == atomic_read(&nesvnic->rx_skbs_needed)) &&\r\n(atomic_read(&nesvnic->rx_skb_timer_running) == 0)) {\r\natomic_set(&nesvnic->rx_skb_timer_running, 1);\r\nspin_unlock_irqrestore(&nesnic->rq_lock, flags);\r\nnesvnic->rq_wqes_timer.expires = jiffies + (HZ/2);\r\nadd_timer(&nesvnic->rq_wqes_timer);\r\n} else\r\nspin_unlock_irqrestore(&nesnic->rq_lock, flags);\r\nbreak;\r\n}\r\n} while (atomic_read(&nesvnic->rx_skbs_needed));\r\nbarrier();\r\nif (rx_wqes_posted)\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, (rx_wqes_posted << 24) | nesnic->qp_id);\r\nnesnic->replenishing_rq = 0;\r\n}\r\nstatic void nes_rq_wqes_timeout(unsigned long parm)\r\n{\r\nstruct nes_vnic *nesvnic = (struct nes_vnic *)parm;\r\nprintk("%s: Timer fired.\n", __func__);\r\natomic_set(&nesvnic->rx_skb_timer_running, 0);\r\nif (atomic_read(&nesvnic->rx_skbs_needed))\r\nnes_replenish_nic_rq(nesvnic);\r\n}\r\nint nes_init_nic_qp(struct nes_device *nesdev, struct net_device *netdev)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_hw_nic_sq_wqe *nic_sqe;\r\nstruct nes_hw_nic_qp_context *nic_context;\r\nstruct sk_buff *skb;\r\nstruct nes_hw_nic_rq_wqe *nic_rqe;\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nunsigned long flags;\r\nvoid *vmem;\r\ndma_addr_t pmem;\r\nu64 u64temp;\r\nint ret;\r\nu32 cqp_head;\r\nu32 counter;\r\nu32 wqe_count;\r\nstruct nes_rskb_cb *cb;\r\nu8 jumbomode=0;\r\nnesvnic->nic_mem_size = 256 +\r\n(NES_NIC_WQ_SIZE * sizeof(struct nes_first_frag)) +\r\n(NES_NIC_WQ_SIZE * sizeof(struct nes_hw_nic_sq_wqe)) +\r\n(NES_NIC_WQ_SIZE * sizeof(struct nes_hw_nic_rq_wqe)) +\r\n(NES_NIC_WQ_SIZE * 2 * sizeof(struct nes_hw_nic_cqe)) +\r\nsizeof(struct nes_hw_nic_qp_context);\r\nnesvnic->nic_vbase = pci_zalloc_consistent(nesdev->pcidev,\r\nnesvnic->nic_mem_size,\r\n&nesvnic->nic_pbase);\r\nif (!nesvnic->nic_vbase) {\r\nnes_debug(NES_DBG_INIT, "Unable to allocate memory for NIC host descriptor rings\n");\r\nreturn -ENOMEM;\r\n}\r\nnes_debug(NES_DBG_INIT, "Allocated NIC QP structures at %p (phys = %016lX), size = %u.\n",\r\nnesvnic->nic_vbase, (unsigned long)nesvnic->nic_pbase, nesvnic->nic_mem_size);\r\nvmem = (void *)(((unsigned long)nesvnic->nic_vbase + (256 - 1)) &\r\n~(unsigned long)(256 - 1));\r\npmem = (dma_addr_t)(((unsigned long long)nesvnic->nic_pbase + (256 - 1)) &\r\n~(unsigned long long)(256 - 1));\r\nnesvnic->nic.first_frag_vbase = vmem;\r\nfor (counter = 0; counter < NES_NIC_WQ_SIZE; counter++) {\r\nnesvnic->nic.frag_paddr[counter] = pmem;\r\npmem += sizeof(struct nes_first_frag);\r\n}\r\nvmem += (NES_NIC_WQ_SIZE * sizeof(struct nes_first_frag));\r\nnesvnic->nic.sq_vbase = (void *)vmem;\r\nnesvnic->nic.sq_pbase = pmem;\r\nnesvnic->nic.sq_head = 0;\r\nnesvnic->nic.sq_tail = 0;\r\nnesvnic->nic.sq_size = NES_NIC_WQ_SIZE;\r\nfor (counter = 0; counter < NES_NIC_WQ_SIZE; counter++) {\r\nnic_sqe = &nesvnic->nic.sq_vbase[counter];\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_MISC_IDX] =\r\ncpu_to_le32(NES_NIC_SQ_WQE_DISABLE_CHKSUM |\r\nNES_NIC_SQ_WQE_COMPLETION);\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_LENGTH_0_TAG_IDX] =\r\ncpu_to_le32((u32)NES_FIRST_FRAG_SIZE << 16);\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_LOW_IDX] =\r\ncpu_to_le32((u32)nesvnic->nic.frag_paddr[counter]);\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_HIGH_IDX] =\r\ncpu_to_le32((u32)((u64)nesvnic->nic.frag_paddr[counter] >> 32));\r\n}\r\nnesvnic->get_cqp_request = nes_get_cqp_request;\r\nnesvnic->post_cqp_request = nes_post_cqp_request;\r\nnesvnic->mcrq_mcast_filter = NULL;\r\nspin_lock_init(&nesvnic->nic.rq_lock);\r\nvmem += (NES_NIC_WQ_SIZE * sizeof(struct nes_hw_nic_sq_wqe));\r\npmem += (NES_NIC_WQ_SIZE * sizeof(struct nes_hw_nic_sq_wqe));\r\nnesvnic->nic.rq_vbase = vmem;\r\nnesvnic->nic.rq_pbase = pmem;\r\nnesvnic->nic.rq_head = 0;\r\nnesvnic->nic.rq_tail = 0;\r\nnesvnic->nic.rq_size = NES_NIC_WQ_SIZE;\r\nvmem += (NES_NIC_WQ_SIZE * sizeof(struct nes_hw_nic_rq_wqe));\r\npmem += (NES_NIC_WQ_SIZE * sizeof(struct nes_hw_nic_rq_wqe));\r\nif (nesdev->nesadapter->netdev_count > 2)\r\nnesvnic->mcrq_qp_id = nesvnic->nic_index + 32;\r\nelse\r\nnesvnic->mcrq_qp_id = nesvnic->nic.qp_id + 4;\r\nnesvnic->nic_cq.cq_vbase = vmem;\r\nnesvnic->nic_cq.cq_pbase = pmem;\r\nnesvnic->nic_cq.cq_head = 0;\r\nnesvnic->nic_cq.cq_size = NES_NIC_WQ_SIZE * 2;\r\nnesvnic->nic_cq.ce_handler = nes_nic_napi_ce_handler;\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\ncqp_head = nesdev->cqp.sq_head;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(\r\nNES_CQP_CREATE_CQ | NES_CQP_CQ_CEQ_VALID |\r\n((u32)nesvnic->nic_cq.cq_size << 16));\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(\r\nnesvnic->nic_cq.cq_number | ((u32)nesdev->nic_ceq_index << 16));\r\nu64temp = (u64)nesvnic->nic_cq.cq_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] = 0;\r\nu64temp = (unsigned long)&nesvnic->nic_cq;\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_LOW_IDX] = cpu_to_le32((u32)(u64temp >> 1));\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] =\r\ncpu_to_le32(((u32)((u64temp) >> 33)) & 0x7FFFFFFF);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_DOORBELL_INDEX_HIGH_IDX] = 0;\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nnic_context = (void *)(&nesvnic->nic_cq.cq_vbase[nesvnic->nic_cq.cq_size]);\r\nnic_context->context_words[NES_NIC_CTX_MISC_IDX] =\r\ncpu_to_le32((u32)NES_NIC_CTX_SIZE |\r\n((u32)PCI_FUNC(nesdev->pcidev->devfn) << 12));\r\nnes_debug(NES_DBG_INIT, "RX_WINDOW_BUFFER_PAGE_TABLE_SIZE = 0x%08X, RX_WINDOW_BUFFER_SIZE = 0x%08X\n",\r\nnes_read_indexed(nesdev, NES_IDX_RX_WINDOW_BUFFER_PAGE_TABLE_SIZE),\r\nnes_read_indexed(nesdev, NES_IDX_RX_WINDOW_BUFFER_SIZE));\r\nif (nes_read_indexed(nesdev, NES_IDX_RX_WINDOW_BUFFER_SIZE) != 0) {\r\nnic_context->context_words[NES_NIC_CTX_MISC_IDX] |= cpu_to_le32(NES_NIC_BACK_STORE);\r\n}\r\nu64temp = (u64)nesvnic->nic.sq_pbase;\r\nnic_context->context_words[NES_NIC_CTX_SQ_LOW_IDX] = cpu_to_le32((u32)u64temp);\r\nnic_context->context_words[NES_NIC_CTX_SQ_HIGH_IDX] = cpu_to_le32((u32)(u64temp >> 32));\r\nu64temp = (u64)nesvnic->nic.rq_pbase;\r\nnic_context->context_words[NES_NIC_CTX_RQ_LOW_IDX] = cpu_to_le32((u32)u64temp);\r\nnic_context->context_words[NES_NIC_CTX_RQ_HIGH_IDX] = cpu_to_le32((u32)(u64temp >> 32));\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_CREATE_QP |\r\nNES_CQP_QP_TYPE_NIC);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(nesvnic->nic.qp_id);\r\nu64temp = (u64)nesvnic->nic_cq.cq_pbase +\r\n(nesvnic->nic_cq.cq_size * sizeof(struct nes_hw_nic_cqe));\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, u64temp);\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\nnesdev->cqp.sq_head = cqp_head;\r\nbarrier();\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, 0x02800000 | nesdev->cqp.qp_id);\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nnes_debug(NES_DBG_INIT, "Waiting for create NIC QP%u to complete.\n",\r\nnesvnic->nic.qp_id);\r\nret = wait_event_timeout(nesdev->cqp.waitq, (nesdev->cqp.sq_tail == cqp_head),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_INIT, "Create NIC QP%u completed, wait_event_timeout ret = %u.\n",\r\nnesvnic->nic.qp_id, ret);\r\nif (!ret) {\r\nnes_debug(NES_DBG_INIT, "NIC QP%u create timeout expired\n", nesvnic->nic.qp_id);\r\npci_free_consistent(nesdev->pcidev, nesvnic->nic_mem_size, nesvnic->nic_vbase,\r\nnesvnic->nic_pbase);\r\nreturn -EIO;\r\n}\r\nfor (counter = 0; counter < (NES_NIC_WQ_SIZE - 1); counter++) {\r\nskb = dev_alloc_skb(nesvnic->max_frame_size);\r\nif (!skb) {\r\nnes_debug(NES_DBG_INIT, "%s: out of memory for receive skb\n", netdev->name);\r\nnes_destroy_nic_qp(nesvnic);\r\nreturn -ENOMEM;\r\n}\r\nskb->dev = netdev;\r\npmem = pci_map_single(nesdev->pcidev, skb->data,\r\nnesvnic->max_frame_size, PCI_DMA_FROMDEVICE);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->busaddr = pmem;\r\ncb->maplen = nesvnic->max_frame_size;\r\nnic_rqe = &nesvnic->nic.rq_vbase[counter];\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_1_0_IDX] = cpu_to_le32(nesvnic->max_frame_size);\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_3_2_IDX] = 0;\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX] = cpu_to_le32((u32)pmem);\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX] = cpu_to_le32((u32)((u64)pmem >> 32));\r\nnesvnic->nic.rx_skb[counter] = skb;\r\n}\r\nwqe_count = NES_NIC_WQ_SIZE - 1;\r\nnesvnic->nic.rq_head = wqe_count;\r\nbarrier();\r\ndo {\r\ncounter = min(wqe_count, ((u32)255));\r\nwqe_count -= counter;\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, (counter << 24) | nesvnic->nic.qp_id);\r\n} while (wqe_count);\r\ninit_timer(&nesvnic->rq_wqes_timer);\r\nnesvnic->rq_wqes_timer.function = nes_rq_wqes_timeout;\r\nnesvnic->rq_wqes_timer.data = (unsigned long)nesvnic;\r\nnes_debug(NES_DBG_INIT, "NAPI support Enabled\n");\r\nif (nesdev->nesadapter->et_use_adaptive_rx_coalesce)\r\n{\r\nnes_nic_init_timer(nesdev);\r\nif (netdev->mtu > 1500)\r\njumbomode = 1;\r\nnes_nic_init_timer_defaults(nesdev, jumbomode);\r\n}\r\nif ((nesdev->nesadapter->allow_unaligned_fpdus) &&\r\n(nes_init_mgt_qp(nesdev, netdev, nesvnic))) {\r\nnes_debug(NES_DBG_INIT, "%s: Out of memory for pau nic\n", netdev->name);\r\nnes_destroy_nic_qp(nesvnic);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid nes_destroy_nic_qp(struct nes_vnic *nesvnic)\r\n{\r\nu64 u64temp;\r\ndma_addr_t bus_address;\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_hw_nic_sq_wqe *nic_sqe;\r\n__le16 *wqe_fragment_length;\r\nu16 wqe_fragment_index;\r\nu32 cqp_head;\r\nu32 wqm_cfg0;\r\nunsigned long flags;\r\nstruct sk_buff *rx_skb;\r\nstruct nes_rskb_cb *cb;\r\nint ret;\r\nif (nesdev->nesadapter->allow_unaligned_fpdus)\r\nnes_destroy_mgt(nesvnic);\r\nwqm_cfg0 = nes_read_indexed(nesdev, NES_IDX_WQM_CONFIG0);\r\nnes_write_indexed(nesdev, NES_IDX_WQM_CONFIG0, wqm_cfg0 & 0xFFFF7FFF);\r\nwhile (nesvnic->nic.rq_head != nesvnic->nic.rq_tail) {\r\nrx_skb = nesvnic->nic.rx_skb[nesvnic->nic.rq_tail];\r\ncb = (struct nes_rskb_cb *)&rx_skb->cb[0];\r\npci_unmap_single(nesdev->pcidev, cb->busaddr, cb->maplen,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(nesvnic->nic.rx_skb[nesvnic->nic.rq_tail++]);\r\nnesvnic->nic.rq_tail &= (nesvnic->nic.rq_size - 1);\r\n}\r\nwhile (nesvnic->nic.sq_head != nesvnic->nic.sq_tail) {\r\nnic_sqe = &nesvnic->nic.sq_vbase[nesvnic->nic.sq_tail];\r\nwqe_fragment_index = 1;\r\nwqe_fragment_length = (__le16 *)\r\n&nic_sqe->wqe_words[NES_NIC_SQ_WQE_LENGTH_0_TAG_IDX];\r\nwqe_fragment_length++;\r\nif (le16_to_cpu(wqe_fragment_length[wqe_fragment_index]) != 0) {\r\nu64temp = (u64)le32_to_cpu(\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_LOW_IDX+\r\nwqe_fragment_index*2]);\r\nu64temp += ((u64)le32_to_cpu(\r\nnic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_HIGH_IDX\r\n+ wqe_fragment_index*2]))<<32;\r\nbus_address = (dma_addr_t)u64temp;\r\nif (test_and_clear_bit(nesvnic->nic.sq_tail,\r\nnesvnic->nic.first_frag_overflow)) {\r\npci_unmap_single(nesdev->pcidev,\r\nbus_address,\r\nle16_to_cpu(wqe_fragment_length[\r\nwqe_fragment_index++]),\r\nPCI_DMA_TODEVICE);\r\n}\r\nfor (; wqe_fragment_index < 5; wqe_fragment_index++) {\r\nif (wqe_fragment_length[wqe_fragment_index]) {\r\nu64temp = le32_to_cpu(\r\nnic_sqe->wqe_words[\r\nNES_NIC_SQ_WQE_FRAG0_LOW_IDX+\r\nwqe_fragment_index*2]);\r\nu64temp += ((u64)le32_to_cpu(\r\nnic_sqe->wqe_words[\r\nNES_NIC_SQ_WQE_FRAG0_HIGH_IDX+\r\nwqe_fragment_index*2]))<<32;\r\nbus_address = (dma_addr_t)u64temp;\r\npci_unmap_page(nesdev->pcidev,\r\nbus_address,\r\nle16_to_cpu(\r\nwqe_fragment_length[\r\nwqe_fragment_index]),\r\nPCI_DMA_TODEVICE);\r\n} else\r\nbreak;\r\n}\r\n}\r\nif (nesvnic->nic.tx_skb[nesvnic->nic.sq_tail])\r\ndev_kfree_skb(\r\nnesvnic->nic.tx_skb[nesvnic->nic.sq_tail]);\r\nnesvnic->nic.sq_tail = (nesvnic->nic.sq_tail + 1)\r\n& (nesvnic->nic.sq_size - 1);\r\n}\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\ncqp_head = nesdev->cqp.sq_head;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_DESTROY_QP | NES_CQP_QP_TYPE_NIC));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\nnesvnic->nic.qp_id);\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_DESTROY_CQ | ((u32)nesvnic->nic_cq.cq_size << 16)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\n(nesvnic->nic_cq.cq_number | ((u32)nesdev->nic_ceq_index << 16)));\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\nnesdev->cqp.sq_head = cqp_head;\r\nbarrier();\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, 0x02800000 | nesdev->cqp.qp_id);\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nnes_debug(NES_DBG_SHUTDOWN, "Waiting for CQP, cqp_head=%u, cqp.sq_head=%u,"\r\n" cqp.sq_tail=%u, cqp.sq_size=%u\n",\r\ncqp_head, nesdev->cqp.sq_head,\r\nnesdev->cqp.sq_tail, nesdev->cqp.sq_size);\r\nret = wait_event_timeout(nesdev->cqp.waitq, (nesdev->cqp.sq_tail == cqp_head),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_SHUTDOWN, "Destroy NIC QP returned, wait_event_timeout ret = %u, cqp_head=%u,"\r\n" cqp.sq_head=%u, cqp.sq_tail=%u\n",\r\nret, cqp_head, nesdev->cqp.sq_head, nesdev->cqp.sq_tail);\r\nif (!ret) {\r\nnes_debug(NES_DBG_SHUTDOWN, "NIC QP%u destroy timeout expired\n",\r\nnesvnic->nic.qp_id);\r\n}\r\npci_free_consistent(nesdev->pcidev, nesvnic->nic_mem_size, nesvnic->nic_vbase,\r\nnesvnic->nic_pbase);\r\nnes_write_indexed(nesdev, NES_IDX_WQM_CONFIG0, wqm_cfg0);\r\n}\r\nint nes_napi_isr(struct nes_device *nesdev)\r\n{\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 int_stat;\r\nif (nesdev->napi_isr_ran) {\r\nint_stat = nesdev->int_stat;\r\n} else {\r\nint_stat = nes_read32(nesdev->regs + NES_INT_STAT);\r\nnesdev->int_stat = int_stat;\r\nnesdev->napi_isr_ran = 1;\r\n}\r\nint_stat &= nesdev->int_req;\r\nif ((int_stat) && ((int_stat & 0x0000ff00) == int_stat)) {\r\nnesdev->napi_isr_ran = 0;\r\nnes_write32(nesdev->regs + NES_INT_STAT,\r\n(int_stat &\r\n~(NES_INT_INTF | NES_INT_TIMER | NES_INT_MAC0 | NES_INT_MAC1 | NES_INT_MAC2 | NES_INT_MAC3)));\r\nnes_process_ceq(nesdev, &nesdev->nesadapter->ceq[nesdev->nic_ceq_index]);\r\nif (unlikely((((nesadapter->et_rx_coalesce_usecs_irq) &&\r\n(!nesadapter->et_use_adaptive_rx_coalesce)) ||\r\n((nesadapter->et_use_adaptive_rx_coalesce) &&\r\n(nesdev->deepcq_count > nesadapter->et_pkt_rate_low))))) {\r\nif ((nesdev->int_req & NES_INT_TIMER) == 0) {\r\nnesdev->int_req |= NES_INT_TIMER;\r\nnes_write32(nesdev->regs+NES_TIMER_STAT,\r\nnesdev->timer_int_req | ~(nesdev->nesadapter->timer_int_req));\r\nnes_write32(nesdev->regs+NES_INTF_INT_MASK,\r\n~(nesdev->intf_int_req | NES_INTF_PERIODIC_TIMER));\r\n}\r\nif (unlikely(nesadapter->et_use_adaptive_rx_coalesce))\r\n{\r\nnes_nic_init_timer(nesdev);\r\n}\r\nnes_write32(nesdev->regs+NES_INT_MASK, 0x0000ffff | (~nesdev->int_req));\r\n} else {\r\nnesdev->int_req &= ~NES_INT_TIMER;\r\nnes_write32(nesdev->regs+NES_INTF_INT_MASK, ~(nesdev->intf_int_req));\r\nnes_write32(nesdev->regs+NES_INT_MASK, ~nesdev->int_req);\r\n}\r\nnesdev->deepcq_count = 0;\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void process_critical_error(struct nes_device *nesdev)\r\n{\r\nu32 debug_error;\r\nu32 nes_idx_debug_error_masks0 = 0;\r\nu16 error_module = 0;\r\ndebug_error = nes_read_indexed(nesdev, NES_IDX_DEBUG_ERROR_CONTROL_STATUS);\r\nprintk(KERN_ERR PFX "Critical Error reported by device!!! 0x%02X\n",\r\n(u16)debug_error);\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_CONTROL_STATUS,\r\n0x01010000 | (debug_error & 0x0000ffff));\r\nif (crit_err_count++ > 10)\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS1, 1 << 0x17);\r\nerror_module = (u16) (debug_error & 0x1F00) >> 8;\r\nif (++nesdev->nesadapter->crit_error_count[error_module-1] >=\r\nnes_max_critical_error_count) {\r\nprintk(KERN_ERR PFX "Masking off critical error for module "\r\n"0x%02X\n", (u16)error_module);\r\nnes_idx_debug_error_masks0 = nes_read_indexed(nesdev,\r\nNES_IDX_DEBUG_ERROR_MASKS0);\r\nnes_write_indexed(nesdev, NES_IDX_DEBUG_ERROR_MASKS0,\r\nnes_idx_debug_error_masks0 | (1 << error_module));\r\n}\r\n}\r\nvoid nes_dpc(unsigned long param)\r\n{\r\nstruct nes_device *nesdev = (struct nes_device *)param;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 counter;\r\nu32 loop_counter = 0;\r\nu32 int_status_bit;\r\nu32 int_stat;\r\nu32 timer_stat;\r\nu32 temp_int_stat;\r\nu32 intf_int_stat;\r\nu32 processed_intf_int = 0;\r\nu16 processed_timer_int = 0;\r\nu16 completion_ints = 0;\r\nu16 timer_ints = 0;\r\ndo {\r\ntimer_stat = 0;\r\nif (nesdev->napi_isr_ran) {\r\nnesdev->napi_isr_ran = 0;\r\nint_stat = nesdev->int_stat;\r\n} else\r\nint_stat = nes_read32(nesdev->regs+NES_INT_STAT);\r\nif (processed_intf_int != 0)\r\nint_stat &= nesdev->int_req & ~NES_INT_INTF;\r\nelse\r\nint_stat &= nesdev->int_req;\r\nif (processed_timer_int == 0) {\r\nprocessed_timer_int = 1;\r\nif (int_stat & NES_INT_TIMER) {\r\ntimer_stat = nes_read32(nesdev->regs + NES_TIMER_STAT);\r\nif ((timer_stat & nesdev->timer_int_req) == 0) {\r\nint_stat &= ~NES_INT_TIMER;\r\n}\r\n}\r\n} else {\r\nint_stat &= ~NES_INT_TIMER;\r\n}\r\nif (int_stat) {\r\nif (int_stat & ~(NES_INT_INTF | NES_INT_TIMER | NES_INT_MAC0|\r\nNES_INT_MAC1|NES_INT_MAC2 | NES_INT_MAC3)) {\r\nnes_write32(nesdev->regs+NES_INT_STAT,\r\n(int_stat & ~(NES_INT_INTF | NES_INT_TIMER | NES_INT_MAC0|\r\nNES_INT_MAC1 | NES_INT_MAC2 | NES_INT_MAC3)));\r\n}\r\ntemp_int_stat = int_stat;\r\nfor (counter = 0, int_status_bit = 1; counter < 16; counter++) {\r\nif (int_stat & int_status_bit) {\r\nnes_process_ceq(nesdev, &nesadapter->ceq[counter]);\r\ntemp_int_stat &= ~int_status_bit;\r\ncompletion_ints = 1;\r\n}\r\nif (!(temp_int_stat & 0x0000ffff))\r\nbreak;\r\nint_status_bit <<= 1;\r\n}\r\nint_status_bit = 1 << (16 + PCI_FUNC(nesdev->pcidev->devfn));\r\nif (int_stat & int_status_bit) {\r\nnes_process_aeq(nesdev, &nesadapter->aeq[PCI_FUNC(nesdev->pcidev->devfn)]);\r\n}\r\nint_status_bit = 1 << (24 + nesdev->mac_index);\r\nif (int_stat & int_status_bit) {\r\nnes_process_mac_intr(nesdev, nesdev->mac_index);\r\n}\r\nif (int_stat & NES_INT_TIMER) {\r\nif (timer_stat & nesdev->timer_int_req) {\r\nnes_write32(nesdev->regs + NES_TIMER_STAT,\r\n(timer_stat & nesdev->timer_int_req) |\r\n~(nesdev->nesadapter->timer_int_req));\r\ntimer_ints = 1;\r\n}\r\n}\r\nif (int_stat & NES_INT_INTF) {\r\nprocessed_intf_int = 1;\r\nintf_int_stat = nes_read32(nesdev->regs+NES_INTF_INT_STAT);\r\nintf_int_stat &= nesdev->intf_int_req;\r\nif (NES_INTF_INT_CRITERR & intf_int_stat) {\r\nprocess_critical_error(nesdev);\r\n}\r\nif (NES_INTF_INT_PCIERR & intf_int_stat) {\r\nprintk(KERN_ERR PFX "PCI Error reported by device!!!\n");\r\nBUG();\r\n}\r\nif (NES_INTF_INT_AEQ_OFLOW & intf_int_stat) {\r\nprintk(KERN_ERR PFX "AEQ Overflow reported by device!!!\n");\r\nBUG();\r\n}\r\nnes_write32(nesdev->regs+NES_INTF_INT_STAT, intf_int_stat);\r\n}\r\nif (int_stat & NES_INT_TSW) {\r\n}\r\n}\r\nint_stat &= ~NES_INT_INTF | NES_INT_TIMER | NES_INT_MAC0 |\r\nNES_INT_MAC1 | NES_INT_MAC2 | NES_INT_MAC3;\r\n} while ((int_stat != 0) && (loop_counter++ < MAX_DPC_ITERATIONS));\r\nif (timer_ints == 1) {\r\nif ((nesadapter->et_rx_coalesce_usecs_irq) || (nesadapter->et_use_adaptive_rx_coalesce)) {\r\nif (completion_ints == 0) {\r\nnesdev->timer_only_int_count++;\r\nif (nesdev->timer_only_int_count>=nesadapter->timer_int_limit) {\r\nnesdev->timer_only_int_count = 0;\r\nnesdev->int_req &= ~NES_INT_TIMER;\r\nnes_write32(nesdev->regs + NES_INTF_INT_MASK, ~(nesdev->intf_int_req));\r\nnes_write32(nesdev->regs + NES_INT_MASK, ~nesdev->int_req);\r\n} else {\r\nnes_write32(nesdev->regs+NES_INT_MASK, 0x0000ffff | (~nesdev->int_req));\r\n}\r\n} else {\r\nif (unlikely(nesadapter->et_use_adaptive_rx_coalesce))\r\n{\r\nnes_nic_init_timer(nesdev);\r\n}\r\nnesdev->timer_only_int_count = 0;\r\nnes_write32(nesdev->regs+NES_INT_MASK, 0x0000ffff | (~nesdev->int_req));\r\n}\r\n} else {\r\nnesdev->timer_only_int_count = 0;\r\nnesdev->int_req &= ~NES_INT_TIMER;\r\nnes_write32(nesdev->regs+NES_INTF_INT_MASK, ~(nesdev->intf_int_req));\r\nnes_write32(nesdev->regs+NES_TIMER_STAT,\r\nnesdev->timer_int_req | ~(nesdev->nesadapter->timer_int_req));\r\nnes_write32(nesdev->regs+NES_INT_MASK, ~nesdev->int_req);\r\n}\r\n} else {\r\nif ( (completion_ints == 1) &&\r\n(((nesadapter->et_rx_coalesce_usecs_irq) &&\r\n(!nesadapter->et_use_adaptive_rx_coalesce)) ||\r\n((nesdev->deepcq_count > nesadapter->et_pkt_rate_low) &&\r\n(nesadapter->et_use_adaptive_rx_coalesce) )) ) {\r\nnesdev->timer_only_int_count = 0;\r\nnesdev->int_req |= NES_INT_TIMER;\r\nnes_write32(nesdev->regs+NES_TIMER_STAT,\r\nnesdev->timer_int_req | ~(nesdev->nesadapter->timer_int_req));\r\nnes_write32(nesdev->regs+NES_INTF_INT_MASK,\r\n~(nesdev->intf_int_req | NES_INTF_PERIODIC_TIMER));\r\nnes_write32(nesdev->regs+NES_INT_MASK, 0x0000ffff | (~nesdev->int_req));\r\n} else {\r\nnes_write32(nesdev->regs+NES_INT_MASK, ~nesdev->int_req);\r\n}\r\n}\r\nnesdev->deepcq_count = 0;\r\n}\r\nstatic void nes_process_ceq(struct nes_device *nesdev, struct nes_hw_ceq *ceq)\r\n{\r\nu64 u64temp;\r\nstruct nes_hw_cq *cq;\r\nu32 head;\r\nu32 ceq_size;\r\nhead = ceq->ceq_head;\r\nceq_size = ceq->ceq_size;\r\ndo {\r\nif (le32_to_cpu(ceq->ceq_vbase[head].ceqe_words[NES_CEQE_CQ_CTX_HIGH_IDX]) &\r\nNES_CEQE_VALID) {\r\nu64temp = (((u64)(le32_to_cpu(ceq->ceq_vbase[head].ceqe_words[NES_CEQE_CQ_CTX_HIGH_IDX]))) << 32) |\r\n((u64)(le32_to_cpu(ceq->ceq_vbase[head].ceqe_words[NES_CEQE_CQ_CTX_LOW_IDX])));\r\nu64temp <<= 1;\r\ncq = *((struct nes_hw_cq **)&u64temp);\r\nbarrier();\r\nceq->ceq_vbase[head].ceqe_words[NES_CEQE_CQ_CTX_HIGH_IDX] = 0;\r\ncq->ce_handler(nesdev, cq);\r\nif (++head >= ceq_size)\r\nhead = 0;\r\n} else {\r\nbreak;\r\n}\r\n} while (1);\r\nceq->ceq_head = head;\r\n}\r\nstatic void nes_process_aeq(struct nes_device *nesdev, struct nes_hw_aeq *aeq)\r\n{\r\nu32 head;\r\nu32 aeq_size;\r\nu32 aeqe_misc;\r\nu32 aeqe_cq_id;\r\nstruct nes_hw_aeqe volatile *aeqe;\r\nhead = aeq->aeq_head;\r\naeq_size = aeq->aeq_size;\r\ndo {\r\naeqe = &aeq->aeq_vbase[head];\r\nif ((le32_to_cpu(aeqe->aeqe_words[NES_AEQE_MISC_IDX]) & NES_AEQE_VALID) == 0)\r\nbreak;\r\naeqe_misc = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_MISC_IDX]);\r\naeqe_cq_id = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]);\r\nif (aeqe_misc & (NES_AEQE_QP|NES_AEQE_CQ)) {\r\nif (aeqe_cq_id >= NES_FIRST_QPN) {\r\nnes_process_iwarp_aeqe(nesdev, (struct nes_hw_aeqe *)aeqe);\r\n} else {\r\nnes_debug(NES_DBG_AEQ, "Processing CQP related AE, misc = 0x%04X\n",\r\n(u16)(aeqe_misc >> 16));\r\n}\r\n}\r\naeqe->aeqe_words[NES_AEQE_MISC_IDX] = 0;\r\nif (++head >= aeq_size)\r\nhead = 0;\r\nnes_write32(nesdev->regs + NES_AEQ_ALLOC, 1 << 16);\r\n}\r\nwhile (1);\r\naeq->aeq_head = head;\r\n}\r\nstatic void nes_reset_link(struct nes_device *nesdev, u32 mac_index)\r\n{\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 reset_value;\r\nu32 i=0;\r\nu32 u32temp;\r\nif (nesadapter->hw_rev == NE020_REV) {\r\nreturn;\r\n}\r\nmh_detected++;\r\nreset_value = nes_read32(nesdev->regs+NES_SOFTWARE_RESET);\r\nif ((mac_index == 0) || ((mac_index == 1) && (nesadapter->OneG_Mode)))\r\nreset_value |= 0x0000001d;\r\nelse\r\nreset_value |= 0x0000002d;\r\nif (4 <= (nesadapter->link_interrupt_count[mac_index] / ((u16)NES_MAX_LINK_INTERRUPTS))) {\r\nif ((!nesadapter->OneG_Mode) && (nesadapter->port_count == 2)) {\r\nnesadapter->link_interrupt_count[0] = 0;\r\nnesadapter->link_interrupt_count[1] = 0;\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1);\r\nif (0x00000040 & u32temp)\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, 0x0000F088);\r\nelse\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, 0x0000F0C8);\r\nreset_value |= 0x0000003d;\r\n}\r\nnesadapter->link_interrupt_count[mac_index] = 0;\r\n}\r\nnes_write32(nesdev->regs+NES_SOFTWARE_RESET, reset_value);\r\nwhile (((nes_read32(nesdev->regs+NES_SOFTWARE_RESET)\r\n& 0x00000040) != 0x00000040) && (i++ < 5000));\r\nif (0x0000003d == (reset_value & 0x0000003d)) {\r\nu32 pcs_control_status0, pcs_control_status1;\r\nfor (i = 0; i < 10; i++) {\r\npcs_control_status0 = nes_read_indexed(nesdev, NES_IDX_PHY_PCS_CONTROL_STATUS0);\r\npcs_control_status1 = nes_read_indexed(nesdev, NES_IDX_PHY_PCS_CONTROL_STATUS0 + 0x200);\r\nif (((0x0F000000 == (pcs_control_status0 & 0x0F000000))\r\n&& (pcs_control_status0 & 0x00100000))\r\n|| ((0x0F000000 == (pcs_control_status1 & 0x0F000000))\r\n&& (pcs_control_status1 & 0x00100000)))\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\nif (10 == i) {\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1);\r\nif (0x00000040 & u32temp)\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, 0x0000F088);\r\nelse\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL1, 0x0000F0C8);\r\nnes_write32(nesdev->regs+NES_SOFTWARE_RESET, reset_value);\r\nwhile (((nes_read32(nesdev->regs + NES_SOFTWARE_RESET)\r\n& 0x00000040) != 0x00000040) && (i++ < 5000));\r\n}\r\n}\r\n}\r\nstatic void nes_process_mac_intr(struct nes_device *nesdev, u32 mac_number)\r\n{\r\nunsigned long flags;\r\nu32 pcs_control_status;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_vnic *nesvnic;\r\nu32 mac_status;\r\nu32 mac_index = nesdev->mac_index;\r\nu32 u32temp;\r\nu16 phy_data;\r\nu16 temp_phy_data;\r\nu32 pcs_val = 0x0f0f0000;\r\nu32 pcs_mask = 0x0f1f0000;\r\nu32 cdr_ctrl;\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nif (nesadapter->mac_sw_state[mac_number] != NES_MAC_SW_IDLE) {\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\nreturn;\r\n}\r\nnesadapter->mac_sw_state[mac_number] = NES_MAC_SW_INTERRUPT;\r\nmac_status = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS + (mac_index * 0x200));\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS + (mac_index * 0x200), mac_status);\r\nnes_debug(NES_DBG_PHY, "MAC%u interrupt status = 0x%X.\n", mac_number, mac_status);\r\nif (mac_status & (NES_MAC_INT_LINK_STAT_CHG | NES_MAC_INT_XGMII_EXT)) {\r\nnesdev->link_status_interrupts++;\r\nif (0 == (++nesadapter->link_interrupt_count[mac_index] % ((u16)NES_MAX_LINK_INTERRUPTS)))\r\nnes_reset_link(nesdev, mac_index);\r\nif ((nesadapter->OneG_Mode) &&\r\n(nesadapter->phy_type[mac_index] != NES_PHY_TYPE_PUMA_1G)) {\r\ndo {\r\nnes_read_1G_phy_reg(nesdev, 0x1a,\r\nnesadapter->phy_index[mac_index], &phy_data);\r\nnes_debug(NES_DBG_PHY, "Phy%d data from register 0x1a = 0x%X.\n",\r\nnesadapter->phy_index[mac_index], phy_data);\r\n} while (phy_data&0x8000);\r\ntemp_phy_data = 0;\r\ndo {\r\nnes_read_1G_phy_reg(nesdev, 0x11,\r\nnesadapter->phy_index[mac_index], &phy_data);\r\nnes_debug(NES_DBG_PHY, "Phy%d data from register 0x11 = 0x%X.\n",\r\nnesadapter->phy_index[mac_index], phy_data);\r\nif (temp_phy_data == phy_data)\r\nbreak;\r\ntemp_phy_data = phy_data;\r\n} while (1);\r\nnes_read_1G_phy_reg(nesdev, 0x1e,\r\nnesadapter->phy_index[mac_index], &phy_data);\r\nnes_debug(NES_DBG_PHY, "Phy%d data from register 0x1e = 0x%X.\n",\r\nnesadapter->phy_index[mac_index], phy_data);\r\nnes_read_1G_phy_reg(nesdev, 1,\r\nnesadapter->phy_index[mac_index], &phy_data);\r\nnes_debug(NES_DBG_PHY, "1G phy%u data from register 1 = 0x%X\n",\r\nnesadapter->phy_index[mac_index], phy_data);\r\nif (temp_phy_data & 0x1000) {\r\nnes_debug(NES_DBG_PHY, "The Link is up according to the PHY\n");\r\nphy_data = 4;\r\n} else {\r\nnes_debug(NES_DBG_PHY, "The Link is down according to the PHY\n");\r\n}\r\n}\r\nnes_debug(NES_DBG_PHY, "Eth SERDES Common Status: 0=0x%08X, 1=0x%08X\n",\r\nnes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS0),\r\nnes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS0+0x200));\r\nif (nesadapter->phy_type[mac_index] == NES_PHY_TYPE_PUMA_1G) {\r\nswitch (mac_index) {\r\ncase 1:\r\ncase 3:\r\npcs_control_status = nes_read_indexed(nesdev,\r\nNES_IDX_PHY_PCS_CONTROL_STATUS0 + 0x200);\r\nbreak;\r\ndefault:\r\npcs_control_status = nes_read_indexed(nesdev,\r\nNES_IDX_PHY_PCS_CONTROL_STATUS0);\r\nbreak;\r\n}\r\n} else {\r\npcs_control_status = nes_read_indexed(nesdev,\r\nNES_IDX_PHY_PCS_CONTROL_STATUS0 + ((mac_index & 1) * 0x200));\r\npcs_control_status = nes_read_indexed(nesdev,\r\nNES_IDX_PHY_PCS_CONTROL_STATUS0 + ((mac_index & 1) * 0x200));\r\n}\r\nnes_debug(NES_DBG_PHY, "PCS PHY Control/Status%u: 0x%08X\n",\r\nmac_index, pcs_control_status);\r\nif ((nesadapter->OneG_Mode) &&\r\n(nesadapter->phy_type[mac_index] != NES_PHY_TYPE_PUMA_1G)) {\r\nu32temp = 0x01010000;\r\nif (nesadapter->port_count > 2) {\r\nu32temp |= 0x02020000;\r\n}\r\nif ((pcs_control_status & u32temp)!= u32temp) {\r\nphy_data = 0;\r\nnes_debug(NES_DBG_PHY, "PCS says the link is down\n");\r\n}\r\n} else {\r\nswitch (nesadapter->phy_type[mac_index]) {\r\ncase NES_PHY_TYPE_ARGUS:\r\ncase NES_PHY_TYPE_SFP_D:\r\ncase NES_PHY_TYPE_KR:\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 4, 0x0008);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 4, 0xc001);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 4, 0xc002);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 4, 0xc005);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 4, 0xc006);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 1, 0x9003);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 1, 0x9004);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 1, 0x9005);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 1, 0x9003);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 3, 0x0021);\r\nnes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 3, 0x0021);\r\nphy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nphy_data = (!temp_phy_data && (phy_data == 0x8000)) ? 0x4 : 0x0;\r\nnes_debug(NES_DBG_PHY, "%s: Phy data = 0x%04X, link was %s.\n",\r\n__func__, phy_data, nesadapter->mac_link_down[mac_index] ? "DOWN" : "UP");\r\nbreak;\r\ncase NES_PHY_TYPE_PUMA_1G:\r\nif (mac_index < 2)\r\npcs_val = pcs_mask = 0x01010000;\r\nelse\r\npcs_val = pcs_mask = 0x02020000;\r\ndefault:\r\nphy_data = (pcs_val == (pcs_control_status & pcs_mask)) ? 0x4 : 0x0;\r\nbreak;\r\n}\r\n}\r\nif (phy_data & 0x0004) {\r\nif (wide_ppm_offset &&\r\n(nesadapter->phy_type[mac_index] == NES_PHY_TYPE_CX4) &&\r\n(nesadapter->hw_rev != NE020_REV)) {\r\ncdr_ctrl = nes_read_indexed(nesdev,\r\nNES_IDX_ETH_SERDES_CDR_CONTROL0 +\r\nmac_index * 0x200);\r\nnes_write_indexed(nesdev,\r\nNES_IDX_ETH_SERDES_CDR_CONTROL0 +\r\nmac_index * 0x200,\r\ncdr_ctrl | 0x000F0000);\r\n}\r\nnesadapter->mac_link_down[mac_index] = 0;\r\nlist_for_each_entry(nesvnic, &nesadapter->nesvnic_list[mac_index], list) {\r\nnes_debug(NES_DBG_PHY, "The Link is UP!!. linkup was %d\n",\r\nnesvnic->linkup);\r\nif (nesvnic->linkup == 0) {\r\nprintk(PFX "The Link is now up for port %s, netdev %p.\n",\r\nnesvnic->netdev->name, nesvnic->netdev);\r\nif (netif_queue_stopped(nesvnic->netdev))\r\nnetif_start_queue(nesvnic->netdev);\r\nnesvnic->linkup = 1;\r\nnetif_carrier_on(nesvnic->netdev);\r\nspin_lock(&nesvnic->port_ibevent_lock);\r\nif (nesvnic->of_device_registered) {\r\nif (nesdev->iw_status == 0) {\r\nnesdev->iw_status = 1;\r\nnes_port_ibevent(nesvnic);\r\n}\r\n}\r\nspin_unlock(&nesvnic->port_ibevent_lock);\r\n}\r\n}\r\n} else {\r\nif (wide_ppm_offset &&\r\n(nesadapter->phy_type[mac_index] == NES_PHY_TYPE_CX4) &&\r\n(nesadapter->hw_rev != NE020_REV)) {\r\ncdr_ctrl = nes_read_indexed(nesdev,\r\nNES_IDX_ETH_SERDES_CDR_CONTROL0 +\r\nmac_index * 0x200);\r\nnes_write_indexed(nesdev,\r\nNES_IDX_ETH_SERDES_CDR_CONTROL0 +\r\nmac_index * 0x200,\r\ncdr_ctrl & 0xFFF0FFFF);\r\n}\r\nnesadapter->mac_link_down[mac_index] = 1;\r\nlist_for_each_entry(nesvnic, &nesadapter->nesvnic_list[mac_index], list) {\r\nnes_debug(NES_DBG_PHY, "The Link is Down!!. linkup was %d\n",\r\nnesvnic->linkup);\r\nif (nesvnic->linkup == 1) {\r\nprintk(PFX "The Link is now down for port %s, netdev %p.\n",\r\nnesvnic->netdev->name, nesvnic->netdev);\r\nif (!(netif_queue_stopped(nesvnic->netdev)))\r\nnetif_stop_queue(nesvnic->netdev);\r\nnesvnic->linkup = 0;\r\nnetif_carrier_off(nesvnic->netdev);\r\nspin_lock(&nesvnic->port_ibevent_lock);\r\nif (nesvnic->of_device_registered) {\r\nif (nesdev->iw_status == 1) {\r\nnesdev->iw_status = 0;\r\nnes_port_ibevent(nesvnic);\r\n}\r\n}\r\nspin_unlock(&nesvnic->port_ibevent_lock);\r\n}\r\n}\r\n}\r\nif (nesadapter->phy_type[mac_index] == NES_PHY_TYPE_SFP_D) {\r\nnesdev->link_recheck = 1;\r\nmod_delayed_work(system_wq, &nesdev->work,\r\nNES_LINK_RECHECK_DELAY);\r\n}\r\n}\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\nnesadapter->mac_sw_state[mac_number] = NES_MAC_SW_IDLE;\r\n}\r\nvoid nes_recheck_link_status(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct nes_device *nesdev = container_of(work, struct nes_device, work.work);\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_vnic *nesvnic;\r\nu32 mac_index = nesdev->mac_index;\r\nu16 phy_data;\r\nu16 temp_phy_data;\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 1, 0x9003);\r\ntemp_phy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 3, 0x0021);\r\nnes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nnes_read_10G_phy_reg(nesdev, nesadapter->phy_index[mac_index], 3, 0x0021);\r\nphy_data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\nphy_data = (!temp_phy_data && (phy_data == 0x8000)) ? 0x4 : 0x0;\r\nnes_debug(NES_DBG_PHY, "%s: Phy data = 0x%04X, link was %s.\n",\r\n__func__, phy_data,\r\nnesadapter->mac_link_down[mac_index] ? "DOWN" : "UP");\r\nif (phy_data & 0x0004) {\r\nnesadapter->mac_link_down[mac_index] = 0;\r\nlist_for_each_entry(nesvnic, &nesadapter->nesvnic_list[mac_index], list) {\r\nif (nesvnic->linkup == 0) {\r\nprintk(PFX "The Link is now up for port %s, netdev %p.\n",\r\nnesvnic->netdev->name, nesvnic->netdev);\r\nif (netif_queue_stopped(nesvnic->netdev))\r\nnetif_start_queue(nesvnic->netdev);\r\nnesvnic->linkup = 1;\r\nnetif_carrier_on(nesvnic->netdev);\r\nspin_lock(&nesvnic->port_ibevent_lock);\r\nif (nesvnic->of_device_registered) {\r\nif (nesdev->iw_status == 0) {\r\nnesdev->iw_status = 1;\r\nnes_port_ibevent(nesvnic);\r\n}\r\n}\r\nspin_unlock(&nesvnic->port_ibevent_lock);\r\n}\r\n}\r\n} else {\r\nnesadapter->mac_link_down[mac_index] = 1;\r\nlist_for_each_entry(nesvnic, &nesadapter->nesvnic_list[mac_index], list) {\r\nif (nesvnic->linkup == 1) {\r\nprintk(PFX "The Link is now down for port %s, netdev %p.\n",\r\nnesvnic->netdev->name, nesvnic->netdev);\r\nif (!(netif_queue_stopped(nesvnic->netdev)))\r\nnetif_stop_queue(nesvnic->netdev);\r\nnesvnic->linkup = 0;\r\nnetif_carrier_off(nesvnic->netdev);\r\nspin_lock(&nesvnic->port_ibevent_lock);\r\nif (nesvnic->of_device_registered) {\r\nif (nesdev->iw_status == 1) {\r\nnesdev->iw_status = 0;\r\nnes_port_ibevent(nesvnic);\r\n}\r\n}\r\nspin_unlock(&nesvnic->port_ibevent_lock);\r\n}\r\n}\r\n}\r\nif (nesdev->link_recheck++ < NES_LINK_RECHECK_MAX)\r\nschedule_delayed_work(&nesdev->work, NES_LINK_RECHECK_DELAY);\r\nelse\r\nnesdev->link_recheck = 0;\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\n}\r\nstatic void nes_nic_napi_ce_handler(struct nes_device *nesdev, struct nes_hw_nic_cq *cq)\r\n{\r\nstruct nes_vnic *nesvnic = container_of(cq, struct nes_vnic, nic_cq);\r\nnapi_schedule(&nesvnic->napi);\r\n}\r\nvoid nes_nic_ce_handler(struct nes_device *nesdev, struct nes_hw_nic_cq *cq)\r\n{\r\nu64 u64temp;\r\ndma_addr_t bus_address;\r\nstruct nes_hw_nic *nesnic;\r\nstruct nes_vnic *nesvnic = container_of(cq, struct nes_vnic, nic_cq);\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_hw_nic_rq_wqe *nic_rqe;\r\nstruct nes_hw_nic_sq_wqe *nic_sqe;\r\nstruct sk_buff *skb;\r\nstruct sk_buff *rx_skb;\r\nstruct nes_rskb_cb *cb;\r\n__le16 *wqe_fragment_length;\r\nu32 head;\r\nu32 cq_size;\r\nu32 rx_pkt_size;\r\nu32 cqe_count=0;\r\nu32 cqe_errv;\r\nu32 cqe_misc;\r\nu16 wqe_fragment_index = 1;\r\nu16 vlan_tag;\r\nu16 pkt_type;\r\nu16 rqes_processed = 0;\r\nu8 sq_cqes = 0;\r\nhead = cq->cq_head;\r\ncq_size = cq->cq_size;\r\ncq->cqes_pending = 1;\r\ndo {\r\nif (le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_NIC_CQE_MISC_IDX]) &\r\nNES_NIC_CQE_VALID) {\r\nnesnic = &nesvnic->nic;\r\ncqe_misc = le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_NIC_CQE_MISC_IDX]);\r\nif (cqe_misc & NES_NIC_CQE_SQ) {\r\nsq_cqes++;\r\nwqe_fragment_index = 1;\r\nnic_sqe = &nesnic->sq_vbase[nesnic->sq_tail];\r\nskb = nesnic->tx_skb[nesnic->sq_tail];\r\nwqe_fragment_length = (__le16 *)&nic_sqe->wqe_words[NES_NIC_SQ_WQE_LENGTH_0_TAG_IDX];\r\nwqe_fragment_length++;\r\nif (le16_to_cpu(wqe_fragment_length[wqe_fragment_index]) != 0) {\r\nu64temp = (u64) le32_to_cpu(nic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_LOW_IDX +\r\nwqe_fragment_index * 2]);\r\nu64temp += ((u64)le32_to_cpu(nic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_HIGH_IDX +\r\nwqe_fragment_index * 2])) << 32;\r\nbus_address = (dma_addr_t)u64temp;\r\nif (test_and_clear_bit(nesnic->sq_tail, nesnic->first_frag_overflow)) {\r\npci_unmap_single(nesdev->pcidev,\r\nbus_address,\r\nle16_to_cpu(wqe_fragment_length[wqe_fragment_index++]),\r\nPCI_DMA_TODEVICE);\r\n}\r\nfor (; wqe_fragment_index < 5; wqe_fragment_index++) {\r\nif (wqe_fragment_length[wqe_fragment_index]) {\r\nu64temp = le32_to_cpu(nic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_LOW_IDX +\r\nwqe_fragment_index * 2]);\r\nu64temp += ((u64)le32_to_cpu(nic_sqe->wqe_words[NES_NIC_SQ_WQE_FRAG0_HIGH_IDX\r\n+ wqe_fragment_index * 2])) <<32;\r\nbus_address = (dma_addr_t)u64temp;\r\npci_unmap_page(nesdev->pcidev,\r\nbus_address,\r\nle16_to_cpu(wqe_fragment_length[wqe_fragment_index]),\r\nPCI_DMA_TODEVICE);\r\n} else\r\nbreak;\r\n}\r\n}\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nnesnic->sq_tail++;\r\nnesnic->sq_tail &= nesnic->sq_size-1;\r\nif (sq_cqes > 128) {\r\nbarrier();\r\nif (netif_queue_stopped(nesvnic->netdev))\r\nnetif_wake_queue(nesvnic->netdev);\r\nsq_cqes = 0;\r\n}\r\n} else {\r\nrqes_processed ++;\r\ncq->rx_cqes_completed++;\r\ncq->rx_pkts_indicated++;\r\nrx_pkt_size = cqe_misc & 0x0000ffff;\r\nnic_rqe = &nesnic->rq_vbase[nesnic->rq_tail];\r\nrx_skb = nesnic->rx_skb[nesnic->rq_tail];\r\nnic_rqe = &nesnic->rq_vbase[nesvnic->nic.rq_tail];\r\nbus_address = (dma_addr_t)le32_to_cpu(nic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX]);\r\nbus_address += ((u64)le32_to_cpu(nic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX])) << 32;\r\npci_unmap_single(nesdev->pcidev, bus_address,\r\nnesvnic->max_frame_size, PCI_DMA_FROMDEVICE);\r\ncb = (struct nes_rskb_cb *)&rx_skb->cb[0];\r\ncb->busaddr = 0;\r\nrx_skb->len = 0;\r\nskb_put(rx_skb, rx_pkt_size);\r\nrx_skb->protocol = eth_type_trans(rx_skb, nesvnic->netdev);\r\nnesnic->rq_tail++;\r\nnesnic->rq_tail &= nesnic->rq_size - 1;\r\natomic_inc(&nesvnic->rx_skbs_needed);\r\nif (atomic_read(&nesvnic->rx_skbs_needed) > (nesvnic->nic.rq_size>>1)) {\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC,\r\ncq->cq_number | (cqe_count << 16));\r\nnesdev->currcq_count += cqe_count;\r\ncqe_count = 0;\r\nnes_replenish_nic_rq(nesvnic);\r\n}\r\npkt_type = (u16)(le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_NIC_CQE_TAG_PKT_TYPE_IDX]));\r\ncqe_errv = (cqe_misc & NES_NIC_CQE_ERRV_MASK) >> NES_NIC_CQE_ERRV_SHIFT;\r\nrx_skb->ip_summed = CHECKSUM_NONE;\r\nif ((NES_PKT_TYPE_TCPV4_BITS == (pkt_type & NES_PKT_TYPE_TCPV4_MASK)) ||\r\n(NES_PKT_TYPE_UDPV4_BITS == (pkt_type & NES_PKT_TYPE_UDPV4_MASK))) {\r\nif ((cqe_errv &\r\n(NES_NIC_ERRV_BITS_IPV4_CSUM_ERR | NES_NIC_ERRV_BITS_TCPUDP_CSUM_ERR |\r\nNES_NIC_ERRV_BITS_IPH_ERR | NES_NIC_ERRV_BITS_WQE_OVERRUN)) == 0) {\r\nif (nesvnic->netdev->features & NETIF_F_RXCSUM)\r\nrx_skb->ip_summed = CHECKSUM_UNNECESSARY;\r\n} else\r\nnes_debug(NES_DBG_CQ, "%s: unsuccessfully checksummed TCP or UDP packet."\r\n" errv = 0x%X, pkt_type = 0x%X.\n",\r\nnesvnic->netdev->name, cqe_errv, pkt_type);\r\n} else if ((pkt_type & NES_PKT_TYPE_IPV4_MASK) == NES_PKT_TYPE_IPV4_BITS) {\r\nif ((cqe_errv &\r\n(NES_NIC_ERRV_BITS_IPV4_CSUM_ERR | NES_NIC_ERRV_BITS_IPH_ERR |\r\nNES_NIC_ERRV_BITS_WQE_OVERRUN)) == 0) {\r\nif (nesvnic->netdev->features & NETIF_F_RXCSUM) {\r\nrx_skb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\n} else\r\nnes_debug(NES_DBG_CQ, "%s: unsuccessfully checksummed TCP or UDP packet."\r\n" errv = 0x%X, pkt_type = 0x%X.\n",\r\nnesvnic->netdev->name, cqe_errv, pkt_type);\r\n}\r\nif ((pkt_type & NES_PKT_TYPE_APBVT_MASK) == NES_PKT_TYPE_APBVT_BITS) {\r\nif (nes_cm_recv(rx_skb, nesvnic->netdev))\r\nrx_skb = NULL;\r\n}\r\nif (rx_skb == NULL)\r\ngoto skip_rx_indicate0;\r\nif (cqe_misc & NES_NIC_CQE_TAG_VALID) {\r\nvlan_tag = (u16)(le32_to_cpu(\r\ncq->cq_vbase[head].cqe_words[NES_NIC_CQE_TAG_PKT_TYPE_IDX])\r\n>> 16);\r\nnes_debug(NES_DBG_CQ, "%s: Reporting stripped VLAN packet. Tag = 0x%04X\n",\r\nnesvnic->netdev->name, vlan_tag);\r\n__vlan_hwaccel_put_tag(rx_skb, htons(ETH_P_8021Q), vlan_tag);\r\n}\r\nnapi_gro_receive(&nesvnic->napi, rx_skb);\r\nskip_rx_indicate0:\r\n;\r\n}\r\ncq->cq_vbase[head].cqe_words[NES_NIC_CQE_MISC_IDX] = 0;\r\ncqe_count++;\r\nif (++head >= cq_size)\r\nhead = 0;\r\nif (cqe_count == 255) {\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC,\r\ncq->cq_number | (cqe_count << 16));\r\nnesdev->currcq_count += cqe_count;\r\ncqe_count = 0;\r\n}\r\nif (cq->rx_cqes_completed >= nesvnic->budget)\r\nbreak;\r\n} else {\r\ncq->cqes_pending = 0;\r\nbreak;\r\n}\r\n} while (1);\r\nif (sq_cqes) {\r\nbarrier();\r\nif (netif_queue_stopped(nesvnic->netdev))\r\nnetif_wake_queue(nesvnic->netdev);\r\n}\r\ncq->cq_head = head;\r\ncq->cqe_allocs_pending = cqe_count;\r\nif (unlikely(nesadapter->et_use_adaptive_rx_coalesce))\r\n{\r\nnesdev->currcq_count += cqe_count;\r\nnes_nic_tune_timer(nesdev);\r\n}\r\nif (atomic_read(&nesvnic->rx_skbs_needed))\r\nnes_replenish_nic_rq(nesvnic);\r\n}\r\nstatic void nes_cqp_ce_handler(struct nes_device *nesdev, struct nes_hw_cq *cq)\r\n{\r\nu64 u64temp;\r\nunsigned long flags;\r\nstruct nes_hw_cqp *cqp = NULL;\r\nstruct nes_cqp_request *cqp_request;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nu32 head;\r\nu32 cq_size;\r\nu32 cqe_count=0;\r\nu32 error_code;\r\nu32 opcode;\r\nu32 ctx_index;\r\nhead = cq->cq_head;\r\ncq_size = cq->cq_size;\r\ndo {\r\nopcode = le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_CQE_OPCODE_IDX]);\r\nif (opcode & NES_CQE_VALID) {\r\ncqp = &nesdev->cqp;\r\nerror_code = le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_CQE_ERROR_CODE_IDX]);\r\nif (error_code) {\r\nnes_debug(NES_DBG_CQP, "Bad Completion code for opcode 0x%02X from CQP,"\r\n" Major/Minor codes = 0x%04X:%04X.\n",\r\nle32_to_cpu(cq->cq_vbase[head].cqe_words[NES_CQE_OPCODE_IDX])&0x3f,\r\n(u16)(error_code >> 16),\r\n(u16)error_code);\r\n}\r\nu64temp = (((u64)(le32_to_cpu(cq->cq_vbase[head].\r\ncqe_words[NES_CQE_COMP_COMP_CTX_HIGH_IDX]))) << 32) |\r\n((u64)(le32_to_cpu(cq->cq_vbase[head].\r\ncqe_words[NES_CQE_COMP_COMP_CTX_LOW_IDX])));\r\ncqp_request = (struct nes_cqp_request *)(unsigned long)u64temp;\r\nif (cqp_request) {\r\nif (cqp_request->waiting) {\r\ncqp_request->major_code = (u16)(error_code >> 16);\r\ncqp_request->minor_code = (u16)error_code;\r\nbarrier();\r\ncqp_request->request_done = 1;\r\nwake_up(&cqp_request->waitq);\r\nnes_put_cqp_request(nesdev, cqp_request);\r\n} else {\r\nif (cqp_request->callback)\r\ncqp_request->cqp_callback(nesdev, cqp_request);\r\nnes_free_cqp_request(nesdev, cqp_request);\r\n}\r\n} else {\r\nwake_up(&nesdev->cqp.waitq);\r\n}\r\ncq->cq_vbase[head].cqe_words[NES_CQE_OPCODE_IDX] = 0;\r\nnes_write32(nesdev->regs + NES_CQE_ALLOC, cq->cq_number | (1 << 16));\r\nif (++cqp->sq_tail >= cqp->sq_size)\r\ncqp->sq_tail = 0;\r\ncqe_count++;\r\nif (++head >= cq_size)\r\nhead = 0;\r\n} else {\r\nbreak;\r\n}\r\n} while (1);\r\ncq->cq_head = head;\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\nwhile ((!list_empty(&nesdev->cqp_pending_reqs)) &&\r\n((((nesdev->cqp.sq_tail+nesdev->cqp.sq_size)-nesdev->cqp.sq_head) &\r\n(nesdev->cqp.sq_size - 1)) != 1)) {\r\ncqp_request = list_entry(nesdev->cqp_pending_reqs.next,\r\nstruct nes_cqp_request, list);\r\nlist_del_init(&cqp_request->list);\r\nhead = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[head];\r\nmemcpy(cqp_wqe, &cqp_request->cqp_wqe, sizeof(*cqp_wqe));\r\nbarrier();\r\nopcode = cqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX];\r\nif ((opcode & NES_CQP_OPCODE_MASK) == NES_CQP_DOWNLOAD_SEGMENT)\r\nctx_index = NES_CQP_WQE_DL_COMP_CTX_LOW_IDX;\r\nelse\r\nctx_index = NES_CQP_WQE_COMP_CTX_LOW_IDX;\r\ncqp_wqe->wqe_words[ctx_index] =\r\ncpu_to_le32((u32)((unsigned long)cqp_request));\r\ncqp_wqe->wqe_words[ctx_index + 1] =\r\ncpu_to_le32((u32)(upper_32_bits((unsigned long)cqp_request)));\r\nnes_debug(NES_DBG_CQP, "CQP request %p (opcode 0x%02X) put on CQPs SQ wqe%u.\n",\r\ncqp_request, le32_to_cpu(cqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX])&0x3f, head);\r\nbarrier();\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, 0x01800000 | nesdev->cqp.qp_id);\r\n}\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nnes_write32(nesdev->regs+NES_CQE_ALLOC, NES_CQE_ALLOC_NOTIFY_NEXT |\r\ncq->cq_number);\r\nnes_read32(nesdev->regs+NES_CQE_ALLOC);\r\n}\r\nstatic u8 *locate_mpa(u8 *pkt, u32 aeq_info)\r\n{\r\nif (aeq_info & NES_AEQE_Q2_DATA_ETHERNET) {\r\npkt += ETH_HLEN;\r\npkt += 4 * (pkt[0] & 0x0f);\r\npkt += 4 * ((pkt[12] >> 4) & 0x0f);\r\n}\r\nreturn pkt;\r\n}\r\nstatic u32 iwarp_opcode(struct nes_qp *nesqp, u32 aeq_info)\r\n{\r\nu8 *pkt;\r\nu16 *mpa;\r\nu32 opcode = 0xffffffff;\r\nif (aeq_info & NES_AEQE_Q2_DATA_WRITTEN) {\r\npkt = nesqp->hwqp.q2_vbase + BAD_FRAME_OFFSET;\r\nmpa = (u16 *)locate_mpa(pkt, aeq_info);\r\nopcode = be16_to_cpu(mpa[1]) & 0xf;\r\n}\r\nreturn opcode;\r\n}\r\nstatic int nes_bld_terminate_hdr(struct nes_qp *nesqp, u16 async_event_id, u32 aeq_info)\r\n{\r\nu8 *pkt = nesqp->hwqp.q2_vbase + BAD_FRAME_OFFSET;\r\nu16 ddp_seg_len;\r\nint copy_len = 0;\r\nu8 is_tagged = 0;\r\nu8 flush_code = 0;\r\nstruct nes_terminate_hdr *termhdr;\r\ntermhdr = (struct nes_terminate_hdr *)nesqp->hwqp.q2_vbase;\r\nmemset(termhdr, 0, 64);\r\nif (aeq_info & NES_AEQE_Q2_DATA_WRITTEN) {\r\npkt = locate_mpa(pkt, aeq_info);\r\nddp_seg_len = be16_to_cpu(*(u16 *)pkt);\r\nif (ddp_seg_len) {\r\ncopy_len = 2;\r\ntermhdr->hdrct = DDP_LEN_FLAG;\r\nif (pkt[2] & 0x80) {\r\nis_tagged = 1;\r\nif (ddp_seg_len >= TERM_DDP_LEN_TAGGED) {\r\ncopy_len += TERM_DDP_LEN_TAGGED;\r\ntermhdr->hdrct |= DDP_HDR_FLAG;\r\n}\r\n} else {\r\nif (ddp_seg_len >= TERM_DDP_LEN_UNTAGGED) {\r\ncopy_len += TERM_DDP_LEN_UNTAGGED;\r\ntermhdr->hdrct |= DDP_HDR_FLAG;\r\n}\r\nif (ddp_seg_len >= (TERM_DDP_LEN_UNTAGGED + TERM_RDMA_LEN)) {\r\nif ((pkt[3] & RDMA_OPCODE_MASK) == RDMA_READ_REQ_OPCODE) {\r\ncopy_len += TERM_RDMA_LEN;\r\ntermhdr->hdrct |= RDMA_HDR_FLAG;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nswitch (async_event_id) {\r\ncase NES_AEQE_AEID_AMP_UNALLOCATED_STAG:\r\nswitch (iwarp_opcode(nesqp, aeq_info)) {\r\ncase IWARP_OPCODE_WRITE:\r\nflush_code = IB_WC_LOC_PROT_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_TAGGED_BUFFER;\r\ntermhdr->error_code = DDP_TAGGED_INV_STAG;\r\nbreak;\r\ndefault:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_INV_STAG;\r\n}\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_INVALID_STAG:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_INV_STAG;\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_BAD_QP:\r\nflush_code = IB_WC_LOC_QP_OP_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_QN;\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_BAD_STAG_KEY:\r\ncase NES_AEQE_AEID_AMP_BAD_STAG_INDEX:\r\nswitch (iwarp_opcode(nesqp, aeq_info)) {\r\ncase IWARP_OPCODE_SEND_INV:\r\ncase IWARP_OPCODE_SEND_SE_INV:\r\nflush_code = IB_WC_REM_OP_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_OP;\r\ntermhdr->error_code = RDMAP_CANT_INV_STAG;\r\nbreak;\r\ndefault:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_INV_STAG;\r\n}\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_BOUNDS_VIOLATION:\r\nif (aeq_info & (NES_AEQE_Q2_DATA_ETHERNET | NES_AEQE_Q2_DATA_MPA)) {\r\nflush_code = IB_WC_LOC_PROT_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_TAGGED_BUFFER;\r\ntermhdr->error_code = DDP_TAGGED_BOUNDS;\r\n} else {\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_INV_BOUNDS;\r\n}\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_RIGHTS_VIOLATION:\r\ncase NES_AEQE_AEID_AMP_INVALIDATE_NO_REMOTE_ACCESS_RIGHTS:\r\ncase NES_AEQE_AEID_PRIV_OPERATION_DENIED:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_ACCESS;\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_TO_WRAP:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_TO_WRAP;\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_BAD_PD:\r\nswitch (iwarp_opcode(nesqp, aeq_info)) {\r\ncase IWARP_OPCODE_WRITE:\r\nflush_code = IB_WC_LOC_PROT_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_TAGGED_BUFFER;\r\ntermhdr->error_code = DDP_TAGGED_UNASSOC_STAG;\r\nbreak;\r\ncase IWARP_OPCODE_SEND_INV:\r\ncase IWARP_OPCODE_SEND_SE_INV:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_CANT_INV_STAG;\r\nbreak;\r\ndefault:\r\nflush_code = IB_WC_REM_ACCESS_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_PROT;\r\ntermhdr->error_code = RDMAP_UNASSOC_STAG;\r\n}\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_RECEIVED_MARKER_AND_LENGTH_FIELDS_DONT_MATCH:\r\nflush_code = IB_WC_LOC_LEN_ERR;\r\ntermhdr->layer_etype = (LAYER_MPA << 4) | DDP_LLP;\r\ntermhdr->error_code = MPA_MARKER;\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_RECEIVED_MPA_CRC_ERROR:\r\nflush_code = IB_WC_GENERAL_ERR;\r\ntermhdr->layer_etype = (LAYER_MPA << 4) | DDP_LLP;\r\ntermhdr->error_code = MPA_CRC;\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_SEGMENT_TOO_LARGE:\r\ncase NES_AEQE_AEID_LLP_SEGMENT_TOO_SMALL:\r\nflush_code = IB_WC_LOC_LEN_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_CATASTROPHIC;\r\ntermhdr->error_code = DDP_CATASTROPHIC_LOCAL;\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_LCE_LOCAL_CATASTROPHIC:\r\ncase NES_AEQE_AEID_DDP_NO_L_BIT:\r\nflush_code = IB_WC_FATAL_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_CATASTROPHIC;\r\ntermhdr->error_code = DDP_CATASTROPHIC_LOCAL;\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_INVALID_MSN_GAP_IN_MSN:\r\ncase NES_AEQE_AEID_DDP_INVALID_MSN_RANGE_IS_NOT_VALID:\r\nflush_code = IB_WC_GENERAL_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_MSN_RANGE;\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_UBE_DDP_MESSAGE_TOO_LONG_FOR_AVAILABLE_BUFFER:\r\nflush_code = IB_WC_LOC_LEN_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_TOO_LONG;\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_DDP_VERSION:\r\nflush_code = IB_WC_GENERAL_ERR;\r\nif (is_tagged) {\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_TAGGED_BUFFER;\r\ntermhdr->error_code = DDP_TAGGED_INV_DDP_VER;\r\n} else {\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_DDP_VER;\r\n}\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_MO:\r\nflush_code = IB_WC_GENERAL_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_MO;\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_MSN_NO_BUFFER_AVAILABLE:\r\nflush_code = IB_WC_REM_OP_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_MSN_NO_BUF;\r\nbreak;\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_QN:\r\nflush_code = IB_WC_GENERAL_ERR;\r\ntermhdr->layer_etype = (LAYER_DDP << 4) | DDP_UNTAGGED_BUFFER;\r\ntermhdr->error_code = DDP_UNTAGGED_INV_QN;\r\nbreak;\r\ncase NES_AEQE_AEID_RDMAP_ROE_INVALID_RDMAP_VERSION:\r\nflush_code = IB_WC_GENERAL_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_OP;\r\ntermhdr->error_code = RDMAP_INV_RDMAP_VER;\r\nbreak;\r\ncase NES_AEQE_AEID_RDMAP_ROE_UNEXPECTED_OPCODE:\r\nflush_code = IB_WC_LOC_QP_OP_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_OP;\r\ntermhdr->error_code = RDMAP_UNEXPECTED_OP;\r\nbreak;\r\ndefault:\r\nflush_code = IB_WC_FATAL_ERR;\r\ntermhdr->layer_etype = (LAYER_RDMA << 4) | RDMAP_REMOTE_OP;\r\ntermhdr->error_code = RDMAP_UNSPECIFIED;\r\nbreak;\r\n}\r\nif (copy_len)\r\nmemcpy(termhdr + 1, pkt, copy_len);\r\nif ((flush_code) && ((NES_AEQE_INBOUND_RDMA & aeq_info) == 0)) {\r\nif (aeq_info & NES_AEQE_SQ)\r\nnesqp->term_sq_flush_code = flush_code;\r\nelse\r\nnesqp->term_rq_flush_code = flush_code;\r\n}\r\nreturn sizeof(struct nes_terminate_hdr) + copy_len;\r\n}\r\nstatic void nes_terminate_connection(struct nes_device *nesdev, struct nes_qp *nesqp,\r\nstruct nes_hw_aeqe *aeqe, enum ib_event_type eventtype)\r\n{\r\nu64 context;\r\nunsigned long flags;\r\nu32 aeq_info;\r\nu16 async_event_id;\r\nu8 tcp_state;\r\nu8 iwarp_state;\r\nu32 termlen = 0;\r\nu32 mod_qp_flags = NES_CQP_QP_IWARP_STATE_TERMINATE |\r\nNES_CQP_QP_TERM_DONT_SEND_FIN;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nif (nesqp->term_flags & NES_TERM_SENT)\r\nreturn;\r\naeq_info = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_MISC_IDX]);\r\ntcp_state = (aeq_info & NES_AEQE_TCP_STATE_MASK) >> NES_AEQE_TCP_STATE_SHIFT;\r\niwarp_state = (aeq_info & NES_AEQE_IWARP_STATE_MASK) >> NES_AEQE_IWARP_STATE_SHIFT;\r\nasync_event_id = (u16)aeq_info;\r\ncontext = (unsigned long)nesadapter->qp_table[le32_to_cpu(\r\naeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]) - NES_FIRST_QPN];\r\nif (!context) {\r\nWARN_ON(!context);\r\nreturn;\r\n}\r\nnesqp = (struct nes_qp *)(unsigned long)context;\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nnesqp->hw_iwarp_state = iwarp_state;\r\nnesqp->hw_tcp_state = tcp_state;\r\nnesqp->last_aeq = async_event_id;\r\nnesqp->terminate_eventtype = eventtype;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nif (nesadapter->send_term_ok)\r\ntermlen = nes_bld_terminate_hdr(nesqp, async_event_id, aeq_info);\r\nelse\r\nmod_qp_flags |= NES_CQP_QP_TERM_DONT_SEND_TERM_MSG;\r\nif (!nesdev->iw_status) {\r\nnesqp->term_flags = NES_TERM_DONE;\r\nnes_hw_modify_qp(nesdev, nesqp, NES_CQP_QP_IWARP_STATE_ERROR, 0, 0);\r\nnes_cm_disconn(nesqp);\r\n} else {\r\nnes_terminate_start_timer(nesqp);\r\nnesqp->term_flags |= NES_TERM_SENT;\r\nnes_hw_modify_qp(nesdev, nesqp, mod_qp_flags, termlen, 0);\r\n}\r\n}\r\nstatic void nes_terminate_send_fin(struct nes_device *nesdev,\r\nstruct nes_qp *nesqp, struct nes_hw_aeqe *aeqe)\r\n{\r\nu32 aeq_info;\r\nu16 async_event_id;\r\nu8 tcp_state;\r\nu8 iwarp_state;\r\nunsigned long flags;\r\naeq_info = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_MISC_IDX]);\r\ntcp_state = (aeq_info & NES_AEQE_TCP_STATE_MASK) >> NES_AEQE_TCP_STATE_SHIFT;\r\niwarp_state = (aeq_info & NES_AEQE_IWARP_STATE_MASK) >> NES_AEQE_IWARP_STATE_SHIFT;\r\nasync_event_id = (u16)aeq_info;\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nnesqp->hw_iwarp_state = iwarp_state;\r\nnesqp->hw_tcp_state = tcp_state;\r\nnesqp->last_aeq = async_event_id;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nnes_hw_modify_qp(nesdev, nesqp, NES_CQP_QP_IWARP_STATE_TERMINATE |\r\nNES_CQP_QP_TERM_DONT_SEND_TERM_MSG, 0, 0);\r\n}\r\nstatic void nes_terminate_done(struct nes_qp *nesqp, int timeout_occurred)\r\n{\r\nu32 next_iwarp_state = NES_CQP_QP_IWARP_STATE_ERROR;\r\nunsigned long flags;\r\nstruct nes_vnic *nesvnic = to_nesvnic(nesqp->ibqp.device);\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nu8 first_time = 0;\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nif (nesqp->hte_added) {\r\nnesqp->hte_added = 0;\r\nnext_iwarp_state |= NES_CQP_QP_DEL_HTE;\r\n}\r\nfirst_time = (nesqp->term_flags & NES_TERM_DONE) == 0;\r\nnesqp->term_flags |= NES_TERM_DONE;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nif (first_time) {\r\nif (timeout_occurred == 0)\r\ndel_timer(&nesqp->terminate_timer);\r\nelse\r\nnext_iwarp_state |= NES_CQP_QP_RESET;\r\nnes_hw_modify_qp(nesdev, nesqp, next_iwarp_state, 0, 0);\r\nnes_cm_disconn(nesqp);\r\n}\r\n}\r\nstatic void nes_terminate_received(struct nes_device *nesdev,\r\nstruct nes_qp *nesqp, struct nes_hw_aeqe *aeqe)\r\n{\r\nu32 aeq_info;\r\nu8 *pkt;\r\nu32 *mpa;\r\nu8 ddp_ctl;\r\nu8 rdma_ctl;\r\nu16 aeq_id = 0;\r\naeq_info = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_MISC_IDX]);\r\nif (aeq_info & NES_AEQE_Q2_DATA_WRITTEN) {\r\npkt = nesqp->hwqp.q2_vbase + BAD_FRAME_OFFSET;\r\nmpa = (u32 *)locate_mpa(pkt, aeq_info);\r\nddp_ctl = (be32_to_cpu(mpa[0]) >> 8) & 0xff;\r\nrdma_ctl = be32_to_cpu(mpa[0]) & 0xff;\r\nif ((ddp_ctl & 0xc0) != 0x40)\r\naeq_id = NES_AEQE_AEID_DDP_LCE_LOCAL_CATASTROPHIC;\r\nelse if ((ddp_ctl & 0x03) != 1)\r\naeq_id = NES_AEQE_AEID_DDP_UBE_INVALID_DDP_VERSION;\r\nelse if (be32_to_cpu(mpa[2]) != 2)\r\naeq_id = NES_AEQE_AEID_DDP_UBE_INVALID_QN;\r\nelse if (be32_to_cpu(mpa[3]) != 1)\r\naeq_id = NES_AEQE_AEID_DDP_INVALID_MSN_GAP_IN_MSN;\r\nelse if (be32_to_cpu(mpa[4]) != 0)\r\naeq_id = NES_AEQE_AEID_DDP_UBE_INVALID_MO;\r\nelse if ((rdma_ctl & 0xc0) != 0x40)\r\naeq_id = NES_AEQE_AEID_RDMAP_ROE_INVALID_RDMAP_VERSION;\r\nif (aeq_id) {\r\naeq_info = (aeq_info & 0xffff0000) | aeq_id;\r\naeqe->aeqe_words[NES_AEQE_MISC_IDX] = cpu_to_le32(aeq_info);\r\nnes_terminate_connection(nesdev, nesqp, aeqe, IB_EVENT_QP_FATAL);\r\nreturn;\r\n}\r\n}\r\nnesqp->term_flags |= NES_TERM_RCVD;\r\nnesqp->terminate_eventtype = IB_EVENT_QP_FATAL;\r\nnes_terminate_start_timer(nesqp);\r\nnes_terminate_send_fin(nesdev, nesqp, aeqe);\r\n}\r\nvoid nes_terminate_timeout(unsigned long context)\r\n{\r\nstruct nes_qp *nesqp = (struct nes_qp *)(unsigned long)context;\r\nnes_terminate_done(nesqp, 1);\r\n}\r\nstatic void nes_terminate_start_timer(struct nes_qp *nesqp)\r\n{\r\nmod_timer(&nesqp->terminate_timer, (jiffies + HZ));\r\n}\r\nstatic void nes_process_iwarp_aeqe(struct nes_device *nesdev,\r\nstruct nes_hw_aeqe *aeqe)\r\n{\r\nu64 context;\r\nunsigned long flags;\r\nstruct nes_qp *nesqp;\r\nstruct nes_hw_cq *hw_cq;\r\nstruct nes_cq *nescq;\r\nint resource_allocated;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 aeq_info;\r\nu32 next_iwarp_state = 0;\r\nu32 aeqe_cq_id;\r\nu16 async_event_id;\r\nu8 tcp_state;\r\nu8 iwarp_state;\r\nstruct ib_event ibevent;\r\nnes_debug(NES_DBG_AEQ, "\n");\r\naeq_info = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_MISC_IDX]);\r\nif ((NES_AEQE_INBOUND_RDMA & aeq_info) || (!(NES_AEQE_QP & aeq_info))) {\r\ncontext = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_CTXT_LOW_IDX]);\r\ncontext += ((u64)le32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_CTXT_HIGH_IDX])) << 32;\r\n} else {\r\ncontext = (unsigned long)nesadapter->qp_table[le32_to_cpu(\r\naeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]) - NES_FIRST_QPN];\r\nBUG_ON(!context);\r\n}\r\nnesqp = (struct nes_qp *)(unsigned long)context;\r\nasync_event_id = (u16)aeq_info;\r\ntcp_state = (aeq_info & NES_AEQE_TCP_STATE_MASK) >> NES_AEQE_TCP_STATE_SHIFT;\r\niwarp_state = (aeq_info & NES_AEQE_IWARP_STATE_MASK) >> NES_AEQE_IWARP_STATE_SHIFT;\r\nnes_debug(NES_DBG_AEQ, "aeid = 0x%04X, qp-cq id = %d, aeqe = %p,"\r\n" Tcp state = %s, iWARP state = %s\n",\r\nasync_event_id,\r\nle32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]), aeqe,\r\nnes_tcp_state_str[tcp_state], nes_iwarp_state_str[iwarp_state]);\r\naeqe_cq_id = le32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]);\r\nif (aeq_info & NES_AEQE_QP) {\r\nif (!nes_is_resource_allocated(nesadapter,\r\nnesadapter->allocated_qps,\r\naeqe_cq_id))\r\nreturn;\r\n}\r\nswitch (async_event_id) {\r\ncase NES_AEQE_AEID_LLP_FIN_RECEIVED:\r\nif (nesqp->term_flags)\r\nreturn;\r\nif (atomic_inc_return(&nesqp->close_timer_started) == 1) {\r\nif ((tcp_state == NES_AEQE_TCP_STATE_CLOSE_WAIT) &&\r\n(nesqp->ibqp_state == IB_QPS_RTS)) {\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nnesqp->hw_iwarp_state = iwarp_state;\r\nnesqp->hw_tcp_state = tcp_state;\r\nnesqp->last_aeq = async_event_id;\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_CLOSING;\r\nnesqp->hw_iwarp_state = NES_AEQE_IWARP_STATE_CLOSING;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nnes_hw_modify_qp(nesdev, nesqp, next_iwarp_state, 0, 0);\r\nnes_cm_disconn(nesqp);\r\n}\r\nnesqp->cm_id->add_ref(nesqp->cm_id);\r\nschedule_nes_timer(nesqp->cm_node, (struct sk_buff *)nesqp,\r\nNES_TIMER_TYPE_CLOSE, 1, 0);\r\nnes_debug(NES_DBG_AEQ, "QP%u Not decrementing QP refcount (%d),"\r\n" need ae to finish up, original_last_aeq = 0x%04X."\r\n" last_aeq = 0x%04X, scheduling timer. TCP state = %d\n",\r\nnesqp->hwqp.qp_id, atomic_read(&nesqp->refcount),\r\nasync_event_id, nesqp->last_aeq, tcp_state);\r\n}\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_CLOSE_COMPLETE:\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nnesqp->hw_iwarp_state = iwarp_state;\r\nnesqp->hw_tcp_state = tcp_state;\r\nnesqp->last_aeq = async_event_id;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nnes_cm_disconn(nesqp);\r\nbreak;\r\ncase NES_AEQE_AEID_RESET_SENT:\r\ntcp_state = NES_AEQE_TCP_STATE_CLOSED;\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nnesqp->hw_iwarp_state = iwarp_state;\r\nnesqp->hw_tcp_state = tcp_state;\r\nnesqp->last_aeq = async_event_id;\r\nnesqp->hte_added = 0;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nnext_iwarp_state = NES_CQP_QP_IWARP_STATE_ERROR | NES_CQP_QP_DEL_HTE;\r\nnes_hw_modify_qp(nesdev, nesqp, next_iwarp_state, 0, 0);\r\nnes_cm_disconn(nesqp);\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_CONNECTION_RESET:\r\nif (atomic_read(&nesqp->close_timer_started))\r\nreturn;\r\nspin_lock_irqsave(&nesqp->lock, flags);\r\nnesqp->hw_iwarp_state = iwarp_state;\r\nnesqp->hw_tcp_state = tcp_state;\r\nnesqp->last_aeq = async_event_id;\r\nspin_unlock_irqrestore(&nesqp->lock, flags);\r\nnes_cm_disconn(nesqp);\r\nbreak;\r\ncase NES_AEQE_AEID_TERMINATE_SENT:\r\nnes_terminate_send_fin(nesdev, nesqp, aeqe);\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_TERMINATE_RECEIVED:\r\nnes_terminate_received(nesdev, nesqp, aeqe);\r\nbreak;\r\ncase NES_AEQE_AEID_AMP_BAD_STAG_KEY:\r\ncase NES_AEQE_AEID_AMP_BAD_STAG_INDEX:\r\ncase NES_AEQE_AEID_AMP_UNALLOCATED_STAG:\r\ncase NES_AEQE_AEID_AMP_INVALID_STAG:\r\ncase NES_AEQE_AEID_AMP_RIGHTS_VIOLATION:\r\ncase NES_AEQE_AEID_AMP_INVALIDATE_NO_REMOTE_ACCESS_RIGHTS:\r\ncase NES_AEQE_AEID_PRIV_OPERATION_DENIED:\r\ncase NES_AEQE_AEID_DDP_UBE_DDP_MESSAGE_TOO_LONG_FOR_AVAILABLE_BUFFER:\r\ncase NES_AEQE_AEID_AMP_BOUNDS_VIOLATION:\r\ncase NES_AEQE_AEID_AMP_TO_WRAP:\r\nprintk(KERN_ERR PFX "QP[%u] async_event_id=0x%04X IB_EVENT_QP_ACCESS_ERR\n",\r\nnesqp->hwqp.qp_id, async_event_id);\r\nnes_terminate_connection(nesdev, nesqp, aeqe, IB_EVENT_QP_ACCESS_ERR);\r\nbreak;\r\ncase NES_AEQE_AEID_LLP_SEGMENT_TOO_LARGE:\r\ncase NES_AEQE_AEID_LLP_SEGMENT_TOO_SMALL:\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_MO:\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_QN:\r\nif (iwarp_opcode(nesqp, aeq_info) > IWARP_OPCODE_TERM) {\r\naeq_info &= 0xffff0000;\r\naeq_info |= NES_AEQE_AEID_RDMAP_ROE_UNEXPECTED_OPCODE;\r\naeqe->aeqe_words[NES_AEQE_MISC_IDX] = cpu_to_le32(aeq_info);\r\n}\r\ncase NES_AEQE_AEID_RDMAP_ROE_BAD_LLP_CLOSE:\r\ncase NES_AEQE_AEID_LLP_TOO_MANY_RETRIES:\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_MSN_NO_BUFFER_AVAILABLE:\r\ncase NES_AEQE_AEID_LLP_RECEIVED_MPA_CRC_ERROR:\r\ncase NES_AEQE_AEID_AMP_BAD_QP:\r\ncase NES_AEQE_AEID_LLP_RECEIVED_MARKER_AND_LENGTH_FIELDS_DONT_MATCH:\r\ncase NES_AEQE_AEID_DDP_LCE_LOCAL_CATASTROPHIC:\r\ncase NES_AEQE_AEID_DDP_NO_L_BIT:\r\ncase NES_AEQE_AEID_DDP_INVALID_MSN_GAP_IN_MSN:\r\ncase NES_AEQE_AEID_DDP_INVALID_MSN_RANGE_IS_NOT_VALID:\r\ncase NES_AEQE_AEID_DDP_UBE_INVALID_DDP_VERSION:\r\ncase NES_AEQE_AEID_RDMAP_ROE_INVALID_RDMAP_VERSION:\r\ncase NES_AEQE_AEID_RDMAP_ROE_UNEXPECTED_OPCODE:\r\ncase NES_AEQE_AEID_AMP_BAD_PD:\r\ncase NES_AEQE_AEID_AMP_FASTREG_SHARED:\r\ncase NES_AEQE_AEID_AMP_FASTREG_VALID_STAG:\r\ncase NES_AEQE_AEID_AMP_FASTREG_MW_STAG:\r\ncase NES_AEQE_AEID_AMP_FASTREG_INVALID_RIGHTS:\r\ncase NES_AEQE_AEID_AMP_FASTREG_PBL_TABLE_OVERFLOW:\r\ncase NES_AEQE_AEID_AMP_FASTREG_INVALID_LENGTH:\r\ncase NES_AEQE_AEID_AMP_INVALIDATE_SHARED:\r\ncase NES_AEQE_AEID_AMP_INVALIDATE_MR_WITH_BOUND_WINDOWS:\r\ncase NES_AEQE_AEID_AMP_MWBIND_VALID_STAG:\r\ncase NES_AEQE_AEID_AMP_MWBIND_OF_MR_STAG:\r\ncase NES_AEQE_AEID_AMP_MWBIND_TO_ZERO_BASED_STAG:\r\ncase NES_AEQE_AEID_AMP_MWBIND_TO_MW_STAG:\r\ncase NES_AEQE_AEID_AMP_MWBIND_INVALID_RIGHTS:\r\ncase NES_AEQE_AEID_AMP_MWBIND_INVALID_BOUNDS:\r\ncase NES_AEQE_AEID_AMP_MWBIND_TO_INVALID_PARENT:\r\ncase NES_AEQE_AEID_AMP_MWBIND_BIND_DISABLED:\r\ncase NES_AEQE_AEID_BAD_CLOSE:\r\ncase NES_AEQE_AEID_RDMA_READ_WHILE_ORD_ZERO:\r\ncase NES_AEQE_AEID_STAG_ZERO_INVALID:\r\ncase NES_AEQE_AEID_ROE_INVALID_RDMA_READ_REQUEST:\r\ncase NES_AEQE_AEID_ROE_INVALID_RDMA_WRITE_OR_READ_RESP:\r\nprintk(KERN_ERR PFX "QP[%u] async_event_id=0x%04X IB_EVENT_QP_FATAL\n",\r\nnesqp->hwqp.qp_id, async_event_id);\r\nprint_ip(nesqp->cm_node);\r\nif (!atomic_read(&nesqp->close_timer_started))\r\nnes_terminate_connection(nesdev, nesqp, aeqe, IB_EVENT_QP_FATAL);\r\nbreak;\r\ncase NES_AEQE_AEID_CQ_OPERATION_ERROR:\r\ncontext <<= 1;\r\nnes_debug(NES_DBG_AEQ, "Processing an NES_AEQE_AEID_CQ_OPERATION_ERROR event on CQ%u, %p\n",\r\nle32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]), (void *)(unsigned long)context);\r\nresource_allocated = nes_is_resource_allocated(nesadapter, nesadapter->allocated_cqs,\r\nle32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]));\r\nif (resource_allocated) {\r\nprintk(KERN_ERR PFX "%s: Processing an NES_AEQE_AEID_CQ_OPERATION_ERROR event on CQ%u\n",\r\n__func__, le32_to_cpu(aeqe->aeqe_words[NES_AEQE_COMP_QP_CQ_ID_IDX]));\r\nhw_cq = (struct nes_hw_cq *)(unsigned long)context;\r\nif (hw_cq) {\r\nnescq = container_of(hw_cq, struct nes_cq, hw_cq);\r\nif (nescq->ibcq.event_handler) {\r\nibevent.device = nescq->ibcq.device;\r\nibevent.event = IB_EVENT_CQ_ERR;\r\nibevent.element.cq = &nescq->ibcq;\r\nnescq->ibcq.event_handler(&ibevent, nescq->ibcq.cq_context);\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nnes_debug(NES_DBG_AEQ, "Processing an iWARP related AE for QP, misc = 0x%04X\n",\r\nasync_event_id);\r\nbreak;\r\n}\r\n}\r\nvoid nes_iwarp_ce_handler(struct nes_device *nesdev, struct nes_hw_cq *hw_cq)\r\n{\r\nstruct nes_cq *nescq = container_of(hw_cq, struct nes_cq, hw_cq);\r\nnes_write32(nesdev->regs+NES_CQ_ACK, nescq->hw_cq.cq_number);\r\nif (nescq->ibcq.comp_handler)\r\nnescq->ibcq.comp_handler(&nescq->ibcq, nescq->ibcq.cq_context);\r\nreturn;\r\n}\r\nint nes_manage_apbvt(struct nes_vnic *nesvnic, u32 accel_local_port,\r\nu32 nic_index, u32 add_port)\r\n{\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nint ret = 0;\r\nu16 major_code;\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_QP, "Failed to get a cqp_request.\n");\r\nreturn -ENOMEM;\r\n}\r\ncqp_request->waiting = 1;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_debug(NES_DBG_QP, "%s APBV for local port=%u(0x%04x), nic_index=%u\n",\r\n(add_port == NES_MANAGE_APBVT_ADD) ? "ADD" : "DEL",\r\naccel_local_port, accel_local_port, nic_index);\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX, (NES_CQP_MANAGE_APBVT |\r\n((add_port == NES_MANAGE_APBVT_ADD) ? NES_CQP_APBVT_ADD : 0)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\n((nic_index << NES_CQP_APBVT_NIC_SHIFT) | accel_local_port));\r\nnes_debug(NES_DBG_QP, "Waiting for CQP completion for APBVT.\n");\r\natomic_set(&cqp_request->refcount, 2);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nif (add_port == NES_MANAGE_APBVT_ADD)\r\nret = wait_event_timeout(cqp_request->waitq, (cqp_request->request_done != 0),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_QP, "Completed, ret=%u, CQP Major:Minor codes = 0x%04X:0x%04X\n",\r\nret, cqp_request->major_code, cqp_request->minor_code);\r\nmajor_code = cqp_request->major_code;\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nif (!ret)\r\nreturn -ETIME;\r\nelse if (major_code)\r\nreturn -EIO;\r\nelse\r\nreturn 0;\r\n}\r\nvoid nes_manage_arp_cache(struct net_device *netdev, unsigned char *mac_addr,\r\nu32 ip_addr, u32 action)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_vnic *nesvnic = netdev_priv(netdev);\r\nstruct nes_device *nesdev;\r\nstruct nes_cqp_request *cqp_request;\r\nint arp_index;\r\nnesdev = nesvnic->nesdev;\r\narp_index = nes_arp_table(nesdev, ip_addr, mac_addr, action);\r\nif (arp_index == -1) {\r\nreturn;\r\n}\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_NETDEV, "Failed to get a cqp_request.\n");\r\nreturn;\r\n}\r\ncqp_request->waiting = 0;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(\r\nNES_CQP_MANAGE_ARP_CACHE | NES_CQP_ARP_PERM);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] |= cpu_to_le32(\r\n(u32)PCI_FUNC(nesdev->pcidev->devfn) << NES_CQP_ARP_AEQ_INDEX_SHIFT);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(arp_index);\r\nif (action == NES_ARP_ADD) {\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] |= cpu_to_le32(NES_CQP_ARP_VALID);\r\ncqp_wqe->wqe_words[NES_CQP_ARP_WQE_MAC_ADDR_LOW_IDX] = cpu_to_le32(\r\n(((u32)mac_addr[2]) << 24) | (((u32)mac_addr[3]) << 16) |\r\n(((u32)mac_addr[4]) << 8) | (u32)mac_addr[5]);\r\ncqp_wqe->wqe_words[NES_CQP_ARP_WQE_MAC_HIGH_IDX] = cpu_to_le32(\r\n(((u32)mac_addr[0]) << 8) | (u32)mac_addr[1]);\r\n} else {\r\ncqp_wqe->wqe_words[NES_CQP_ARP_WQE_MAC_ADDR_LOW_IDX] = 0;\r\ncqp_wqe->wqe_words[NES_CQP_ARP_WQE_MAC_HIGH_IDX] = 0;\r\n}\r\nnes_debug(NES_DBG_NETDEV, "Not waiting for CQP, cqp.sq_head=%u, cqp.sq_tail=%u\n",\r\nnesdev->cqp.sq_head, nesdev->cqp.sq_tail);\r\natomic_set(&cqp_request->refcount, 1);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\n}\r\nvoid flush_wqes(struct nes_device *nesdev, struct nes_qp *nesqp,\r\nu32 which_wq, u32 wait_completion)\r\n{\r\nstruct nes_cqp_request *cqp_request;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nu32 sq_code = (NES_IWARP_CQE_MAJOR_FLUSH << 16) | NES_IWARP_CQE_MINOR_FLUSH;\r\nu32 rq_code = (NES_IWARP_CQE_MAJOR_FLUSH << 16) | NES_IWARP_CQE_MINOR_FLUSH;\r\nint ret;\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_QP, "Failed to get a cqp_request.\n");\r\nreturn;\r\n}\r\nif (wait_completion) {\r\ncqp_request->waiting = 1;\r\natomic_set(&cqp_request->refcount, 2);\r\n} else {\r\ncqp_request->waiting = 0;\r\n}\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nif ((nesqp->term_sq_flush_code) && (which_wq & NES_CQP_FLUSH_SQ)) {\r\nwhich_wq |= NES_CQP_FLUSH_MAJ_MIN;\r\nsq_code = (CQE_MAJOR_DRV << 16) | nesqp->term_sq_flush_code;\r\nnesqp->term_sq_flush_code = 0;\r\n}\r\nif ((nesqp->term_rq_flush_code) && (which_wq & NES_CQP_FLUSH_RQ)) {\r\nwhich_wq |= NES_CQP_FLUSH_MAJ_MIN;\r\nrq_code = (CQE_MAJOR_DRV << 16) | nesqp->term_rq_flush_code;\r\nnesqp->term_rq_flush_code = 0;\r\n}\r\nif (which_wq & NES_CQP_FLUSH_MAJ_MIN) {\r\ncqp_wqe->wqe_words[NES_CQP_QP_WQE_FLUSH_SQ_CODE] = cpu_to_le32(sq_code);\r\ncqp_wqe->wqe_words[NES_CQP_QP_WQE_FLUSH_RQ_CODE] = cpu_to_le32(rq_code);\r\n}\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] =\r\ncpu_to_le32(NES_CQP_FLUSH_WQES | which_wq);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(nesqp->hwqp.qp_id);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nif (wait_completion) {\r\nret = wait_event_timeout(cqp_request->waitq, (cqp_request->request_done != 0),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_QP, "Flush SQ QP WQEs completed, ret=%u,"\r\n" CQP Major:Minor codes = 0x%04X:0x%04X\n",\r\nret, cqp_request->major_code, cqp_request->minor_code);\r\nnes_put_cqp_request(nesdev, cqp_request);\r\n}\r\n}
