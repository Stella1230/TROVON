static int cpg_sd_clock_enable(struct clk_hw *hw)\r\n{\r\nstruct sd_clock *clock = to_sd_clock(hw);\r\nu32 val, sd_fc;\r\nunsigned int i;\r\nval = readl(clock->reg);\r\nsd_fc = val & CPG_SD_FC_MASK;\r\nfor (i = 0; i < clock->div_num; i++)\r\nif (sd_fc == (clock->div_table[i].val & CPG_SD_FC_MASK))\r\nbreak;\r\nif (i >= clock->div_num)\r\nreturn -EINVAL;\r\nval &= ~(CPG_SD_STP_MASK);\r\nval |= clock->div_table[i].val & CPG_SD_STP_MASK;\r\nwritel(val, clock->reg);\r\nreturn 0;\r\n}\r\nstatic void cpg_sd_clock_disable(struct clk_hw *hw)\r\n{\r\nstruct sd_clock *clock = to_sd_clock(hw);\r\nwritel(readl(clock->reg) | CPG_SD_STP_MASK, clock->reg);\r\n}\r\nstatic int cpg_sd_clock_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct sd_clock *clock = to_sd_clock(hw);\r\nreturn !(readl(clock->reg) & CPG_SD_STP_MASK);\r\n}\r\nstatic unsigned long cpg_sd_clock_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct sd_clock *clock = to_sd_clock(hw);\r\nunsigned long rate = parent_rate;\r\nu32 val, sd_fc;\r\nunsigned int i;\r\nval = readl(clock->reg);\r\nsd_fc = val & CPG_SD_FC_MASK;\r\nfor (i = 0; i < clock->div_num; i++)\r\nif (sd_fc == (clock->div_table[i].val & CPG_SD_FC_MASK))\r\nbreak;\r\nif (i >= clock->div_num)\r\nreturn -EINVAL;\r\nreturn DIV_ROUND_CLOSEST(rate, clock->div_table[i].div);\r\n}\r\nstatic unsigned int cpg_sd_clock_calc_div(struct sd_clock *clock,\r\nunsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nunsigned int div;\r\nif (!rate)\r\nrate = 1;\r\ndiv = DIV_ROUND_CLOSEST(parent_rate, rate);\r\nreturn clamp_t(unsigned int, div, clock->div_min, clock->div_max);\r\n}\r\nstatic long cpg_sd_clock_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct sd_clock *clock = to_sd_clock(hw);\r\nunsigned int div = cpg_sd_clock_calc_div(clock, rate, *parent_rate);\r\nreturn DIV_ROUND_CLOSEST(*parent_rate, div);\r\n}\r\nstatic int cpg_sd_clock_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct sd_clock *clock = to_sd_clock(hw);\r\nunsigned int div = cpg_sd_clock_calc_div(clock, rate, parent_rate);\r\nu32 val;\r\nunsigned int i;\r\nfor (i = 0; i < clock->div_num; i++)\r\nif (div == clock->div_table[i].div)\r\nbreak;\r\nif (i >= clock->div_num)\r\nreturn -EINVAL;\r\nval = readl(clock->reg);\r\nval &= ~(CPG_SD_STP_MASK | CPG_SD_FC_MASK);\r\nval |= clock->div_table[i].val & (CPG_SD_STP_MASK | CPG_SD_FC_MASK);\r\nwritel(val, clock->reg);\r\nreturn 0;\r\n}\r\nstatic struct clk * __init cpg_sd_clk_register(const struct cpg_core_clk *core,\r\nvoid __iomem *base,\r\nconst char *parent_name)\r\n{\r\nstruct clk_init_data init;\r\nstruct sd_clock *clock;\r\nstruct clk *clk;\r\nunsigned int i;\r\nclock = kzalloc(sizeof(*clock), GFP_KERNEL);\r\nif (!clock)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = core->name;\r\ninit.ops = &cpg_sd_clock_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclock->reg = base + core->offset;\r\nclock->hw.init = &init;\r\nclock->div_table = cpg_sd_div_table;\r\nclock->div_num = ARRAY_SIZE(cpg_sd_div_table);\r\nclock->div_max = clock->div_table[0].div;\r\nclock->div_min = clock->div_max;\r\nfor (i = 1; i < clock->div_num; i++) {\r\nclock->div_max = max(clock->div_max, clock->div_table[i].div);\r\nclock->div_min = min(clock->div_min, clock->div_table[i].div);\r\n}\r\nclk = clk_register(NULL, &clock->hw);\r\nif (IS_ERR(clk))\r\nkfree(clock);\r\nreturn clk;\r\n}\r\nstruct clk * __init rcar_gen3_cpg_clk_register(struct device *dev,\r\nconst struct cpg_core_clk *core, const struct cpg_mssr_info *info,\r\nstruct clk **clks, void __iomem *base)\r\n{\r\nconst struct clk *parent;\r\nunsigned int mult = 1;\r\nunsigned int div = 1;\r\nu32 value;\r\nparent = clks[core->parent];\r\nif (IS_ERR(parent))\r\nreturn ERR_CAST(parent);\r\nswitch (core->type) {\r\ncase CLK_TYPE_GEN3_MAIN:\r\ndiv = cpg_pll_config->extal_div;\r\nbreak;\r\ncase CLK_TYPE_GEN3_PLL0:\r\nvalue = readl(base + CPG_PLL0CR);\r\nmult = (((value >> 24) & 0x7f) + 1) * 2;\r\nbreak;\r\ncase CLK_TYPE_GEN3_PLL1:\r\nmult = cpg_pll_config->pll1_mult;\r\nbreak;\r\ncase CLK_TYPE_GEN3_PLL2:\r\nvalue = readl(base + CPG_PLL2CR);\r\nmult = (((value >> 24) & 0x7f) + 1) * 2;\r\nbreak;\r\ncase CLK_TYPE_GEN3_PLL3:\r\nmult = cpg_pll_config->pll3_mult;\r\nbreak;\r\ncase CLK_TYPE_GEN3_PLL4:\r\nvalue = readl(base + CPG_PLL4CR);\r\nmult = (((value >> 24) & 0x7f) + 1) * 2;\r\nbreak;\r\ncase CLK_TYPE_GEN3_SD:\r\nreturn cpg_sd_clk_register(core, base, __clk_get_name(parent));\r\ncase CLK_TYPE_GEN3_R:\r\nvalue = readl(base + CPG_RCKCR) & 0x3f;\r\nif (clk_get_rate(clks[cpg_clk_extalr])) {\r\nparent = clks[cpg_clk_extalr];\r\nvalue |= BIT(15);\r\n}\r\nwritel(value, base + CPG_RCKCR);\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn clk_register_fixed_factor(NULL, core->name,\r\n__clk_get_name(parent), 0, mult, div);\r\n}\r\nint __init rcar_gen3_cpg_init(const struct rcar_gen3_cpg_pll_config *config,\r\nunsigned int clk_extalr)\r\n{\r\ncpg_pll_config = config;\r\ncpg_clk_extalr = clk_extalr;\r\nreturn 0;\r\n}
