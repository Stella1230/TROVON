static u32\r\nnvbios_vpstate_offset(struct nvkm_bios *b)\r\n{\r\nstruct bit_entry bit_P;\r\nif (!bit_entry(b, 'P', &bit_P)) {\r\nif (bit_P.version == 2)\r\nreturn nvbios_rd32(b, bit_P.offset + 0x38);\r\n}\r\nreturn 0x0000;\r\n}\r\nint\r\nnvbios_vpstate_parse(struct nvkm_bios *b, struct nvbios_vpstate_header *h)\r\n{\r\nif (!h)\r\nreturn -EINVAL;\r\nh->offset = nvbios_vpstate_offset(b);\r\nif (!h->offset)\r\nreturn -ENODEV;\r\nh->version = nvbios_rd08(b, h->offset);\r\nswitch (h->version) {\r\ncase 0x10:\r\nh->hlen = nvbios_rd08(b, h->offset + 0x1);\r\nh->elen = nvbios_rd08(b, h->offset + 0x2);\r\nh->slen = nvbios_rd08(b, h->offset + 0x3);\r\nh->scount = nvbios_rd08(b, h->offset + 0x4);\r\nh->ecount = nvbios_rd08(b, h->offset + 0x5);\r\nh->base_id = nvbios_rd08(b, h->offset + 0x0f);\r\nh->boost_id = nvbios_rd08(b, h->offset + 0x10);\r\nh->tdp_id = nvbios_rd08(b, h->offset + 0x11);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint\r\nnvbios_vpstate_entry(struct nvkm_bios *b, struct nvbios_vpstate_header *h,\r\nu8 idx, struct nvbios_vpstate_entry *e)\r\n{\r\nu32 offset;\r\nif (!e || !h || idx > h->ecount)\r\nreturn -EINVAL;\r\noffset = h->offset + h->hlen + idx * (h->elen + (h->slen * h->scount));\r\ne->pstate = nvbios_rd08(b, offset);\r\ne->clock_mhz = nvbios_rd16(b, offset + 0x5);\r\nreturn 0;\r\n}
