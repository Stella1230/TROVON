static int i2c_write_reg(struct i2c_adapter *adapter, u8 adr,\r\nu8 reg, u8 data)\r\n{\r\nu8 m[2] = {reg, data};\r\nstruct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 2};\r\nif (i2c_transfer(adapter, &msg, 1) != 1) {\r\ndev_err(&adapter->dev,\r\n"Failed to write to I2C register %02x@%02x!\n",\r\nreg, adr);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_write(struct i2c_adapter *adapter, u8 adr,\r\nu8 *data, u8 len)\r\n{\r\nstruct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len};\r\nif (i2c_transfer(adapter, &msg, 1) != 1) {\r\ndev_err(&adapter->dev, "Failed to write to I2C!\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_read_reg(struct i2c_adapter *adapter, u8 adr,\r\nu8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = &reg, .len = 1},\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1} };\r\nif (i2c_transfer(adapter, msgs, 2) != 2) {\r\ndev_err(&adapter->dev, "error in i2c_read_reg\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_read(struct i2c_adapter *adapter, u8 adr,\r\nu8 reg, u8 *data, u8 n)\r\n{\r\nstruct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,\r\n.buf = &reg, .len = 1},\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = data, .len = n} };\r\nif (i2c_transfer(adapter, msgs, 2) != 2) {\r\ndev_err(&adapter->dev, "error in i2c_read\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_block(struct cxd *ci, u8 adr, u8 *data, u8 n)\r\n{\r\nint status;\r\nstatus = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);\r\nif (!status) {\r\nci->lastaddress = adr;\r\nstatus = i2c_read(ci->i2c, ci->cfg.adr, 1, data, n);\r\n}\r\nreturn status;\r\n}\r\nstatic int read_reg(struct cxd *ci, u8 reg, u8 *val)\r\n{\r\nreturn read_block(ci, reg, val, 1);\r\n}\r\nstatic int read_pccard(struct cxd *ci, u16 address, u8 *data, u8 n)\r\n{\r\nint status;\r\nu8 addr[3] = {2, address & 0xff, address >> 8};\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);\r\nif (!status)\r\nstatus = i2c_read(ci->i2c, ci->cfg.adr, 3, data, n);\r\nreturn status;\r\n}\r\nstatic int write_pccard(struct cxd *ci, u16 address, u8 *data, u8 n)\r\n{\r\nint status;\r\nu8 addr[3] = {2, address & 0xff, address >> 8};\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);\r\nif (!status) {\r\nu8 buf[256] = {3};\r\nmemcpy(buf+1, data, n);\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, buf, n+1);\r\n}\r\nreturn status;\r\n}\r\nstatic int read_io(struct cxd *ci, u16 address, u8 *val)\r\n{\r\nint status;\r\nu8 addr[3] = {2, address & 0xff, address >> 8};\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);\r\nif (!status)\r\nstatus = i2c_read(ci->i2c, ci->cfg.adr, 3, val, 1);\r\nreturn status;\r\n}\r\nstatic int write_io(struct cxd *ci, u16 address, u8 val)\r\n{\r\nint status;\r\nu8 addr[3] = {2, address & 0xff, address >> 8};\r\nu8 buf[2] = {3, val};\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);\r\nif (!status)\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, buf, 2);\r\nreturn status;\r\n}\r\nstatic int write_regm(struct cxd *ci, u8 reg, u8 val, u8 mask)\r\n{\r\nint status;\r\nstatus = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, reg);\r\nif (!status && reg >= 6 && reg <= 8 && mask != 0xff)\r\nstatus = i2c_read_reg(ci->i2c, ci->cfg.adr, 1, &ci->regs[reg]);\r\nci->regs[reg] = (ci->regs[reg] & (~mask)) | val;\r\nif (!status) {\r\nci->lastaddress = reg;\r\nstatus = i2c_write_reg(ci->i2c, ci->cfg.adr, 1, ci->regs[reg]);\r\n}\r\nif (reg == 0x20)\r\nci->regs[reg] &= 0x7f;\r\nreturn status;\r\n}\r\nstatic int write_reg(struct cxd *ci, u8 reg, u8 val)\r\n{\r\nreturn write_regm(ci, reg, val, 0xff);\r\n}\r\nstatic int write_block(struct cxd *ci, u8 adr, u8 *data, int n)\r\n{\r\nint status;\r\nu8 buf[256] = {1};\r\nstatus = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);\r\nif (!status) {\r\nci->lastaddress = adr;\r\nmemcpy(buf + 1, data, n);\r\nstatus = i2c_write(ci->i2c, ci->cfg.adr, buf, n + 1);\r\n}\r\nreturn status;\r\n}\r\nstatic void set_mode(struct cxd *ci, int mode)\r\n{\r\nif (mode == ci->mode)\r\nreturn;\r\nswitch (mode) {\r\ncase 0x00:\r\nwrite_regm(ci, 0x06, 0x00, 0x07);\r\nbreak;\r\ncase 0x01:\r\nwrite_regm(ci, 0x06, 0x02, 0x07);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nci->mode = mode;\r\n}\r\nstatic void cam_mode(struct cxd *ci, int mode)\r\n{\r\nif (mode == ci->cammode)\r\nreturn;\r\nswitch (mode) {\r\ncase 0x00:\r\nwrite_regm(ci, 0x20, 0x80, 0x80);\r\nbreak;\r\ncase 0x01:\r\n#ifdef BUFFER_MODE\r\nif (!ci->en.read_data)\r\nreturn;\r\ndev_info(&ci->i2c->dev, "enable cam buffer mode\n");\r\nwrite_regm(ci, 0x08, 0x40, 0x40);\r\nwrite_regm(ci, 0x08, 0x80, 0x80);\r\n#endif\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nci->cammode = mode;\r\n}\r\nstatic int init(struct cxd *ci)\r\n{\r\nint status;\r\nmutex_lock(&ci->lock);\r\nci->mode = -1;\r\ndo {\r\nstatus = write_reg(ci, 0x00, 0x00);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x01, 0x00);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x02, 0x10);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x03, 0x00);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x05, 0xFF);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x06, 0x1F);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x07, 0x1F);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x08, 0x28);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x14, 0x20);\r\nif (status < 0)\r\nbreak;\r\n#if 0\r\nstatus = write_reg(ci, 0x09, 0x4D);\r\nif (status < 0)\r\nbreak;\r\n#endif\r\nstatus = write_reg(ci, 0x0A, 0xA7);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x0B, 0x33);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x0C, 0x33);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_regm(ci, 0x14, 0x00, 0x0F);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x15, ci->clk_reg_b);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_regm(ci, 0x16, 0x00, 0x0F);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x17, ci->clk_reg_f);\r\nif (status < 0)\r\nbreak;\r\nif (ci->cfg.clock_mode) {\r\nif (ci->cfg.polarity) {\r\nstatus = write_reg(ci, 0x09, 0x6f);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = write_reg(ci, 0x09, 0x6d);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = write_reg(ci, 0x20, 0x68);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x21, 0x00);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x22, 0x02);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nif (ci->cfg.polarity) {\r\nstatus = write_reg(ci, 0x09, 0x4f);\r\nif (status < 0)\r\nbreak;\r\n} else {\r\nstatus = write_reg(ci, 0x09, 0x4d);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = write_reg(ci, 0x20, 0x28);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x21, 0x00);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x22, 0x07);\r\nif (status < 0)\r\nbreak;\r\n}\r\nstatus = write_regm(ci, 0x20, 0x80, 0x80);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_regm(ci, 0x03, 0x02, 0x02);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x01, 0x04);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_reg(ci, 0x00, 0x31);\r\nif (status < 0)\r\nbreak;\r\nstatus = write_regm(ci, 0x09, 0x08, 0x08);\r\nif (status < 0)\r\nbreak;\r\nci->cammode = -1;\r\ncam_mode(ci, 0);\r\n} while (0);\r\nmutex_unlock(&ci->lock);\r\nreturn 0;\r\n}\r\nstatic int read_attribute_mem(struct dvb_ca_en50221 *ca,\r\nint slot, int address)\r\n{\r\nstruct cxd *ci = ca->data;\r\n#if 0\r\nif (ci->amem_read) {\r\nif (address <= 0 || address > 1024)\r\nreturn -EIO;\r\nreturn ci->amem[address];\r\n}\r\nmutex_lock(&ci->lock);\r\nwrite_regm(ci, 0x06, 0x00, 0x05);\r\nread_pccard(ci, 0, &ci->amem[0], 128);\r\nread_pccard(ci, 128, &ci->amem[0], 128);\r\nread_pccard(ci, 256, &ci->amem[0], 128);\r\nread_pccard(ci, 384, &ci->amem[0], 128);\r\nwrite_regm(ci, 0x06, 0x05, 0x05);\r\nmutex_unlock(&ci->lock);\r\nreturn ci->amem[address];\r\n#else\r\nu8 val;\r\nmutex_lock(&ci->lock);\r\nset_mode(ci, 1);\r\nread_pccard(ci, address, &val, 1);\r\nmutex_unlock(&ci->lock);\r\nreturn val;\r\n#endif\r\n}\r\nstatic int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,\r\nint address, u8 value)\r\n{\r\nstruct cxd *ci = ca->data;\r\nmutex_lock(&ci->lock);\r\nset_mode(ci, 1);\r\nwrite_pccard(ci, address, &value, 1);\r\nmutex_unlock(&ci->lock);\r\nreturn 0;\r\n}\r\nstatic int read_cam_control(struct dvb_ca_en50221 *ca,\r\nint slot, u8 address)\r\n{\r\nstruct cxd *ci = ca->data;\r\nu8 val;\r\nmutex_lock(&ci->lock);\r\nset_mode(ci, 0);\r\nread_io(ci, address, &val);\r\nmutex_unlock(&ci->lock);\r\nreturn val;\r\n}\r\nstatic int write_cam_control(struct dvb_ca_en50221 *ca, int slot,\r\nu8 address, u8 value)\r\n{\r\nstruct cxd *ci = ca->data;\r\nmutex_lock(&ci->lock);\r\nset_mode(ci, 0);\r\nwrite_io(ci, address, value);\r\nmutex_unlock(&ci->lock);\r\nreturn 0;\r\n}\r\nstatic int slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct cxd *ci = ca->data;\r\nmutex_lock(&ci->lock);\r\n#if 0\r\nwrite_reg(ci, 0x00, 0x21);\r\nwrite_reg(ci, 0x06, 0x1F);\r\nwrite_reg(ci, 0x00, 0x31);\r\n#else\r\n#if 0\r\nwrite_reg(ci, 0x06, 0x1F);\r\nwrite_reg(ci, 0x06, 0x2F);\r\n#else\r\ncam_mode(ci, 0);\r\nwrite_reg(ci, 0x00, 0x21);\r\nwrite_reg(ci, 0x06, 0x1F);\r\nwrite_reg(ci, 0x00, 0x31);\r\nwrite_regm(ci, 0x20, 0x80, 0x80);\r\nwrite_reg(ci, 0x03, 0x02);\r\nci->ready = 0;\r\n#endif\r\n#endif\r\nci->mode = -1;\r\n{\r\nint i;\r\n#if 0\r\nu8 val;\r\n#endif\r\nfor (i = 0; i < 100; i++) {\r\nusleep_range(10000, 11000);\r\n#if 0\r\nread_reg(ci, 0x06, &val);\r\ndev_info(&ci->i2c->dev, "%d:%02x\n", i, val);\r\nif (!(val&0x10))\r\nbreak;\r\n#else\r\nif (ci->ready)\r\nbreak;\r\n#endif\r\n}\r\n}\r\nmutex_unlock(&ci->lock);\r\nreturn 0;\r\n}\r\nstatic int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct cxd *ci = ca->data;\r\ndev_info(&ci->i2c->dev, "slot_shutdown\n");\r\nmutex_lock(&ci->lock);\r\nwrite_regm(ci, 0x09, 0x08, 0x08);\r\nwrite_regm(ci, 0x20, 0x80, 0x80);\r\nwrite_regm(ci, 0x06, 0x07, 0x07);\r\nci->mode = -1;\r\nmutex_unlock(&ci->lock);\r\nreturn 0;\r\n}\r\nstatic int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct cxd *ci = ca->data;\r\nmutex_lock(&ci->lock);\r\nwrite_regm(ci, 0x09, 0x00, 0x08);\r\nset_mode(ci, 0);\r\n#ifdef BUFFER_MODE\r\ncam_mode(ci, 1);\r\n#endif\r\nmutex_unlock(&ci->lock);\r\nreturn 0;\r\n}\r\nstatic int campoll(struct cxd *ci)\r\n{\r\nu8 istat;\r\nread_reg(ci, 0x04, &istat);\r\nif (!istat)\r\nreturn 0;\r\nwrite_reg(ci, 0x05, istat);\r\nif (istat&0x40) {\r\nci->dr = 1;\r\ndev_info(&ci->i2c->dev, "DR\n");\r\n}\r\nif (istat&0x20)\r\ndev_info(&ci->i2c->dev, "WC\n");\r\nif (istat&2) {\r\nu8 slotstat;\r\nread_reg(ci, 0x01, &slotstat);\r\nif (!(2&slotstat)) {\r\nif (!ci->slot_stat) {\r\nci->slot_stat = DVB_CA_EN50221_POLL_CAM_PRESENT;\r\nwrite_regm(ci, 0x03, 0x08, 0x08);\r\n}\r\n} else {\r\nif (ci->slot_stat) {\r\nci->slot_stat = 0;\r\nwrite_regm(ci, 0x03, 0x00, 0x08);\r\ndev_info(&ci->i2c->dev, "NO CAM\n");\r\nci->ready = 0;\r\n}\r\n}\r\nif (istat&8 &&\r\nci->slot_stat == DVB_CA_EN50221_POLL_CAM_PRESENT) {\r\nci->ready = 1;\r\nci->slot_stat |= DVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\r\n{\r\nstruct cxd *ci = ca->data;\r\nu8 slotstat;\r\nmutex_lock(&ci->lock);\r\ncampoll(ci);\r\nread_reg(ci, 0x01, &slotstat);\r\nmutex_unlock(&ci->lock);\r\nreturn ci->slot_stat;\r\n}\r\nstatic int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)\r\n{\r\nstruct cxd *ci = ca->data;\r\nu8 msb, lsb;\r\nu16 len;\r\nmutex_lock(&ci->lock);\r\ncampoll(ci);\r\nmutex_unlock(&ci->lock);\r\ndev_info(&ci->i2c->dev, "read_data\n");\r\nif (!ci->dr)\r\nreturn 0;\r\nmutex_lock(&ci->lock);\r\nread_reg(ci, 0x0f, &msb);\r\nread_reg(ci, 0x10, &lsb);\r\nlen = (msb<<8)|lsb;\r\nread_block(ci, 0x12, ebuf, len);\r\nci->dr = 0;\r\nmutex_unlock(&ci->lock);\r\nreturn len;\r\n}\r\nstatic int write_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount)\r\n{\r\nstruct cxd *ci = ca->data;\r\nmutex_lock(&ci->lock);\r\ndev_info(&ci->i2c->dev, "write_data %d\n", ecount);\r\nwrite_reg(ci, 0x0d, ecount>>8);\r\nwrite_reg(ci, 0x0e, ecount&0xff);\r\nwrite_block(ci, 0x11, ebuf, ecount);\r\nmutex_unlock(&ci->lock);\r\nreturn ecount;\r\n}\r\nstruct dvb_ca_en50221 *cxd2099_attach(struct cxd2099_cfg *cfg,\r\nvoid *priv,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cxd *ci;\r\nu8 val;\r\nif (i2c_read_reg(i2c, cfg->adr, 0, &val) < 0) {\r\ndev_info(&i2c->dev, "No CXD2099 detected at %02x\n", cfg->adr);\r\nreturn NULL;\r\n}\r\nci = kzalloc(sizeof(struct cxd), GFP_KERNEL);\r\nif (!ci)\r\nreturn NULL;\r\nmutex_init(&ci->lock);\r\nci->cfg = *cfg;\r\nci->i2c = i2c;\r\nci->lastaddress = 0xff;\r\nci->clk_reg_b = 0x4a;\r\nci->clk_reg_f = 0x1b;\r\nci->en = en_templ;\r\nci->en.data = ci;\r\ninit(ci);\r\ndev_info(&i2c->dev, "Attached CXD2099AR at %02x\n", ci->cfg.adr);\r\nreturn &ci->en;\r\n}
