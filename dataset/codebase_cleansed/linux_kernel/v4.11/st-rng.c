static int st_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)\r\n{\r\nstruct st_rng_data *ddata = (struct st_rng_data *)rng->priv;\r\nu32 status;\r\nint i;\r\nfor (i = 0; i < ST_RNG_FILL_FIFO_TIMEOUT; i++) {\r\nstatus = readl_relaxed(ddata->base + ST_RNG_STATUS_REG);\r\nif (status & ST_RNG_STATUS_FIFO_FULL)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == ST_RNG_FILL_FIFO_TIMEOUT)\r\nreturn 0;\r\nfor (i = 0; i < ST_RNG_FIFO_SIZE && i < max; i += 2)\r\n*(u16 *)(data + i) =\r\nreadl_relaxed(ddata->base + ST_RNG_DATA_REG);\r\nreturn i;\r\n}\r\nstatic int st_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct st_rng_data *ddata;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nint ret;\r\nddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nret = clk_prepare_enable(clk);\r\nif (ret)\r\nreturn ret;\r\nddata->ops.priv = (unsigned long)ddata;\r\nddata->ops.read = st_rng_read;\r\nddata->ops.name = pdev->name;\r\nddata->base = base;\r\nddata->clk = clk;\r\ndev_set_drvdata(&pdev->dev, ddata);\r\nret = hwrng_register(&ddata->ops);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register HW RNG\n");\r\nclk_disable_unprepare(clk);\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "Successfully registered HW RNG\n");\r\nreturn 0;\r\n}\r\nstatic int st_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct st_rng_data *ddata = dev_get_drvdata(&pdev->dev);\r\nhwrng_unregister(&ddata->ops);\r\nclk_disable_unprepare(ddata->clk);\r\nreturn 0;\r\n}
