void ath9k_htc_beaconq_config(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath9k_tx_queue_info qi, qi_be;\r\nmemset(&qi, 0, sizeof(struct ath9k_tx_queue_info));\r\nmemset(&qi_be, 0, sizeof(struct ath9k_tx_queue_info));\r\nath9k_hw_get_txq_props(ah, priv->beacon.beaconq, &qi);\r\nif (priv->ah->opmode == NL80211_IFTYPE_AP ||\r\npriv->ah->opmode == NL80211_IFTYPE_MESH_POINT) {\r\nqi.tqi_aifs = 1;\r\nqi.tqi_cwmin = 0;\r\nqi.tqi_cwmax = 0;\r\n} else if (priv->ah->opmode == NL80211_IFTYPE_ADHOC) {\r\nint qnum = priv->hwq_map[IEEE80211_AC_BE];\r\nath9k_hw_get_txq_props(ah, qnum, &qi_be);\r\nqi.tqi_aifs = qi_be.tqi_aifs;\r\nif (ah->slottime == 20)\r\nqi.tqi_cwmin = 2*qi_be.tqi_cwmin;\r\nelse\r\nqi.tqi_cwmin = 4*qi_be.tqi_cwmin;\r\nqi.tqi_cwmax = qi_be.tqi_cwmax;\r\n}\r\nif (!ath9k_hw_set_txq_props(ah, priv->beacon.beaconq, &qi)) {\r\nath_err(ath9k_hw_common(ah),\r\n"Unable to update beacon queue %u!\n", priv->beacon.beaconq);\r\n} else {\r\nath9k_hw_resettxqueue(ah, priv->beacon.beaconq);\r\n}\r\n}\r\nstatic void ath9k_htc_beacon_init(struct ath9k_htc_priv *priv,\r\nstruct ath_beacon_config *conf,\r\nbool reset_tsf)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nint ret __attribute__ ((unused));\r\n__be32 htc_imask = 0;\r\nu8 cmd_rsp;\r\nif (conf->intval >= TU_TO_USEC(DEFAULT_SWBA_RESPONSE))\r\nah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;\r\nelse\r\nah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nif (reset_tsf)\r\nath9k_hw_reset_tsf(ah);\r\nath9k_htc_beaconq_config(priv);\r\nath9k_hw_beaconinit(ah, conf->nexttbtt, conf->intval);\r\npriv->beacon.bmisscnt = 0;\r\nhtc_imask = cpu_to_be32(ah->imask);\r\nWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\r\n}\r\nstatic void ath9k_htc_beacon_config_sta(struct ath9k_htc_priv *priv,\r\nstruct ath_beacon_config *bss_conf)\r\n{\r\nstruct ath9k_beacon_state bs;\r\nenum ath9k_int imask = 0;\r\n__be32 htc_imask = 0;\r\nint ret __attribute__ ((unused));\r\nu8 cmd_rsp;\r\nif (ath9k_cmn_beacon_config_sta(priv->ah, bss_conf, &bs) == -EPERM)\r\nreturn;\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nath9k_hw_set_sta_beacon_timers(priv->ah, &bs);\r\nimask |= ATH9K_INT_BMISS;\r\nhtc_imask = cpu_to_be32(imask);\r\nWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\r\n}\r\nstatic void ath9k_htc_beacon_config_ap(struct ath9k_htc_priv *priv,\r\nstruct ath_beacon_config *conf)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nah->imask = 0;\r\nath9k_cmn_beacon_config_ap(ah, conf, ATH9K_HTC_MAX_BCN_VIF);\r\nath9k_htc_beacon_init(priv, conf, false);\r\n}\r\nstatic void ath9k_htc_beacon_config_adhoc(struct ath9k_htc_priv *priv,\r\nstruct ath_beacon_config *conf)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nah->imask = 0;\r\nath9k_cmn_beacon_config_adhoc(ah, conf);\r\nath9k_htc_beacon_init(priv, conf, conf->ibss_creator);\r\n}\r\nvoid ath9k_htc_beaconep(void *drv_priv, struct sk_buff *skb,\r\nenum htc_endpoint_id ep_id, bool txok)\r\n{\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void ath9k_htc_send_buffered(struct ath9k_htc_priv *priv,\r\nint slot)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ieee80211_vif *vif;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nint padpos, padsize, ret, tx_slot;\r\nspin_lock_bh(&priv->beacon_lock);\r\nvif = priv->beacon.bslot[slot];\r\nskb = ieee80211_get_buffered_bc(priv->hw, vif);\r\nwhile(skb) {\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\npadpos = ieee80211_hdrlen(hdr->frame_control);\r\npadsize = padpos & 3;\r\nif (padsize && skb->len > padpos) {\r\nif (skb_headroom(skb) < padsize) {\r\ndev_kfree_skb_any(skb);\r\ngoto next;\r\n}\r\nskb_push(skb, padsize);\r\nmemmove(skb->data, skb->data + padsize, padpos);\r\n}\r\ntx_slot = ath9k_htc_tx_get_slot(priv);\r\nif (tx_slot < 0) {\r\nath_dbg(common, XMIT, "No free CAB slot\n");\r\ndev_kfree_skb_any(skb);\r\ngoto next;\r\n}\r\nret = ath9k_htc_tx_start(priv, NULL, skb, tx_slot, true);\r\nif (ret != 0) {\r\nath9k_htc_tx_clear_slot(priv, tx_slot);\r\ndev_kfree_skb_any(skb);\r\nath_dbg(common, XMIT, "Failed to send CAB frame\n");\r\n} else {\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.queued_cnt++;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\nnext:\r\nskb = ieee80211_get_buffered_bc(priv->hw, vif);\r\n}\r\nspin_unlock_bh(&priv->beacon_lock);\r\n}\r\nstatic void ath9k_htc_send_beacon(struct ath9k_htc_priv *priv,\r\nint slot)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ieee80211_vif *vif;\r\nstruct ath9k_htc_vif *avp;\r\nstruct tx_beacon_header beacon_hdr;\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct sk_buff *beacon;\r\nu8 *tx_fhdr;\r\nint ret;\r\nmemset(&beacon_hdr, 0, sizeof(struct tx_beacon_header));\r\nspin_lock_bh(&priv->beacon_lock);\r\nvif = priv->beacon.bslot[slot];\r\navp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nif (unlikely(test_bit(ATH_OP_SCANNING, &common->op_flags))) {\r\nspin_unlock_bh(&priv->beacon_lock);\r\nreturn;\r\n}\r\nbeacon = ieee80211_beacon_get(priv->hw, vif);\r\nif (!beacon) {\r\nspin_unlock_bh(&priv->beacon_lock);\r\nreturn;\r\n}\r\nmgmt = (struct ieee80211_mgmt *)beacon->data;\r\nmgmt->u.beacon.timestamp = avp->tsfadjust;\r\ninfo = IEEE80211_SKB_CB(beacon);\r\nif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\r\nstruct ieee80211_hdr *hdr =\r\n(struct ieee80211_hdr *) beacon->data;\r\navp->seq_no += 0x10;\r\nhdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\r\nhdr->seq_ctrl |= cpu_to_le16(avp->seq_no);\r\n}\r\ntx_ctl = HTC_SKB_CB(beacon);\r\nmemset(tx_ctl, 0, sizeof(*tx_ctl));\r\ntx_ctl->type = ATH9K_HTC_BEACON;\r\ntx_ctl->epid = priv->beacon_ep;\r\nbeacon_hdr.vif_index = avp->index;\r\ntx_fhdr = skb_push(beacon, sizeof(beacon_hdr));\r\nmemcpy(tx_fhdr, (u8 *) &beacon_hdr, sizeof(beacon_hdr));\r\nret = htc_send(priv->htc, beacon);\r\nif (ret != 0) {\r\nif (ret == -ENOMEM) {\r\nath_dbg(common, BSTUCK,\r\n"Failed to send beacon, no free TX buffer\n");\r\n}\r\ndev_kfree_skb_any(beacon);\r\n}\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath9k_htc_csa_is_finished(priv);\r\n}\r\nstatic int ath9k_htc_choose_bslot(struct ath9k_htc_priv *priv,\r\nstruct wmi_event_swba *swba)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nu64 tsf;\r\nu32 tsftu;\r\nu16 intval;\r\nint slot;\r\nintval = priv->cur_beacon_conf.beacon_interval;\r\ntsf = be64_to_cpu(swba->tsf);\r\ntsftu = TSF_TO_TU(tsf >> 32, tsf);\r\nslot = ((tsftu % intval) * ATH9K_HTC_MAX_BCN_VIF) / intval;\r\nslot = ATH9K_HTC_MAX_BCN_VIF - slot - 1;\r\nath_dbg(common, BEACON,\r\n"Choose slot: %d, tsf: %llu, tsftu: %u, intval: %u\n",\r\nslot, tsf, tsftu, intval);\r\nreturn slot;\r\n}\r\nvoid ath9k_htc_swba(struct ath9k_htc_priv *priv,\r\nstruct wmi_event_swba *swba)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint slot;\r\nif (swba->beacon_pending != 0) {\r\npriv->beacon.bmisscnt++;\r\nif (priv->beacon.bmisscnt > BSTUCK_THRESHOLD) {\r\nath_dbg(common, BSTUCK, "Beacon stuck, HW reset\n");\r\nieee80211_queue_work(priv->hw,\r\n&priv->fatal_work);\r\n}\r\nreturn;\r\n}\r\nif (priv->beacon.bmisscnt) {\r\nath_dbg(common, BSTUCK,\r\n"Resuming beacon xmit after %u misses\n",\r\npriv->beacon.bmisscnt);\r\npriv->beacon.bmisscnt = 0;\r\n}\r\nslot = ath9k_htc_choose_bslot(priv, swba);\r\nspin_lock_bh(&priv->beacon_lock);\r\nif (priv->beacon.bslot[slot] == NULL) {\r\nspin_unlock_bh(&priv->beacon_lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath9k_htc_send_buffered(priv, slot);\r\nath9k_htc_send_beacon(priv, slot);\r\n}\r\nvoid ath9k_htc_assign_bslot(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nint i = 0;\r\nspin_lock_bh(&priv->beacon_lock);\r\nfor (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++) {\r\nif (priv->beacon.bslot[i] == NULL) {\r\navp->bslot = i;\r\nbreak;\r\n}\r\n}\r\npriv->beacon.bslot[avp->bslot] = vif;\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath_dbg(common, CONFIG, "Added interface at beacon slot: %d\n",\r\navp->bslot);\r\n}\r\nvoid ath9k_htc_remove_bslot(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nspin_lock_bh(&priv->beacon_lock);\r\npriv->beacon.bslot[avp->bslot] = NULL;\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath_dbg(common, CONFIG, "Removed interface at beacon slot: %d\n",\r\navp->bslot);\r\n}\r\nvoid ath9k_htc_set_tsfadjust(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nu64 tsfadjust;\r\nif (avp->bslot == 0)\r\nreturn;\r\ntsfadjust = cur_conf->beacon_interval * avp->bslot / ATH9K_HTC_MAX_BCN_VIF;\r\navp->tsfadjust = cpu_to_le64(TU_TO_USEC(tsfadjust));\r\nath_dbg(common, CONFIG, "tsfadjust is: %llu for bslot: %d\n",\r\n(unsigned long long)tsfadjust, avp->bslot);\r\n}\r\nstatic void ath9k_htc_beacon_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nbool *beacon_configured = (bool *)data;\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nif (vif->type == NL80211_IFTYPE_STATION &&\r\navp->beacon_configured)\r\n*beacon_configured = true;\r\n}\r\nstatic bool ath9k_htc_check_beacon_config(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nbool beacon_configured;\r\nif ((priv->ah->opmode == NL80211_IFTYPE_AP) &&\r\n(priv->num_ap_vif > 1) &&\r\n(vif->type == NL80211_IFTYPE_AP) &&\r\n(cur_conf->beacon_interval != bss_conf->beacon_int)) {\r\nath_dbg(common, CONFIG,\r\n"Changing beacon interval of multiple AP interfaces !\n");\r\nreturn false;\r\n}\r\nif (priv->num_ap_vif &&\r\n(vif->type != NL80211_IFTYPE_AP)) {\r\nath_dbg(common, CONFIG,\r\n"HW in AP mode, cannot set STA beacon parameters\n");\r\nreturn false;\r\n}\r\nif ((priv->ah->opmode == NL80211_IFTYPE_STATION) &&\r\n(priv->num_sta_vif > 1) &&\r\n(vif->type == NL80211_IFTYPE_STATION)) {\r\nbeacon_configured = false;\r\nieee80211_iterate_active_interfaces_atomic(\r\npriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nath9k_htc_beacon_iter, &beacon_configured);\r\nif (beacon_configured) {\r\nath_dbg(common, CONFIG,\r\n"Beacon already configured for a station interface\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nvoid ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nif (!ath9k_htc_check_beacon_config(priv, vif))\r\nreturn;\r\ncur_conf->beacon_interval = bss_conf->beacon_int;\r\nif (cur_conf->beacon_interval == 0)\r\ncur_conf->beacon_interval = 100;\r\ncur_conf->dtim_period = bss_conf->dtim_period;\r\ncur_conf->bmiss_timeout =\r\nATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nath9k_htc_beacon_config_sta(priv, cur_conf);\r\navp->beacon_configured = true;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nath9k_htc_beacon_config_adhoc(priv, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_AP:\r\nath9k_htc_beacon_config_ap(priv, cur_conf);\r\nbreak;\r\ndefault:\r\nath_dbg(common, CONFIG, "Unsupported beaconing mode\n");\r\nreturn;\r\n}\r\n}\r\nvoid ath9k_htc_beacon_reconfig(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nswitch (priv->ah->opmode) {\r\ncase NL80211_IFTYPE_STATION:\r\nath9k_htc_beacon_config_sta(priv, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nath9k_htc_beacon_config_adhoc(priv, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_AP:\r\nath9k_htc_beacon_config_ap(priv, cur_conf);\r\nbreak;\r\ndefault:\r\nath_dbg(common, CONFIG, "Unsupported beaconing mode\n");\r\nreturn;\r\n}\r\n}\r\nbool ath9k_htc_csa_is_finished(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ieee80211_vif *vif;\r\nvif = priv->csa_vif;\r\nif (!vif || !vif->csa_active)\r\nreturn false;\r\nif (!ieee80211_csa_is_complete(vif))\r\nreturn false;\r\nieee80211_csa_finish(vif);\r\npriv->csa_vif = NULL;\r\nreturn true;\r\n}
