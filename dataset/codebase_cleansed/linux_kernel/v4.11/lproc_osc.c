static ssize_t active_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nreturn sprintf(buf, "%d\n", !dev->u.cli.cl_import->imp_deactive);\r\n}\r\nstatic ssize_t active_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val > 1)\r\nreturn -ERANGE;\r\nif (dev->u.cli.cl_import->imp_deactive == val)\r\nrc = ptlrpc_set_import_active(dev->u.cli.cl_import, val);\r\nelse\r\nCDEBUG(D_CONFIG, "activate %ld: ignoring repeat request\n",\r\nval);\r\nreturn count;\r\n}\r\nstatic ssize_t max_rpcs_in_flight_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nreturn sprintf(buf, "%u\n", cli->cl_max_rpcs_in_flight);\r\n}\r\nstatic ssize_t max_rpcs_in_flight_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nint rc;\r\nunsigned long val;\r\nint adding, added, req_count;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val < 1 || val > OSC_MAX_RIF_MAX)\r\nreturn -ERANGE;\r\nadding = val - cli->cl_max_rpcs_in_flight;\r\nreq_count = atomic_read(&osc_pool_req_count);\r\nif (adding > 0 && req_count < osc_reqpool_maxreqcount) {\r\nif (req_count + adding > osc_reqpool_maxreqcount)\r\nadding = osc_reqpool_maxreqcount - req_count;\r\nadded = osc_rq_pool->prp_populate(osc_rq_pool, adding);\r\natomic_add(added, &osc_pool_req_count);\r\n}\r\nspin_lock(&cli->cl_loi_list_lock);\r\ncli->cl_max_rpcs_in_flight = val;\r\nclient_adjust_max_dirty(cli);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t max_dirty_mb_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nlong val;\r\nint mult;\r\nspin_lock(&cli->cl_loi_list_lock);\r\nval = cli->cl_dirty_max_pages;\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nmult = 1 << (20 - PAGE_SHIFT);\r\nreturn lprocfs_read_frac_helper(buf, PAGE_SIZE, val, mult);\r\n}\r\nstatic ssize_t max_dirty_mb_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nint rc;\r\nunsigned long pages_number;\r\nrc = kstrtoul(buffer, 10, &pages_number);\r\nif (rc)\r\nreturn rc;\r\npages_number *= 1 << (20 - PAGE_SHIFT);\r\nif (pages_number <= 0 ||\r\npages_number >= OSC_MAX_DIRTY_MB_MAX << (20 - PAGE_SHIFT) ||\r\npages_number > totalram_pages / 4)\r\nreturn -ERANGE;\r\nspin_lock(&cli->cl_loi_list_lock);\r\ncli->cl_dirty_max_pages = pages_number;\r\nosc_wake_cache_waiters(cli);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn count;\r\n}\r\nstatic int osc_cached_mb_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *dev = m->private;\r\nstruct client_obd *cli = &dev->u.cli;\r\nint shift = 20 - PAGE_SHIFT;\r\nseq_printf(m,\r\n"used_mb: %ld\n"\r\n"busy_cnt: %ld\n"\r\n"reclaim: %llu\n",\r\n(atomic_long_read(&cli->cl_lru_in_list) +\r\natomic_long_read(&cli->cl_lru_busy)) >> shift,\r\natomic_long_read(&cli->cl_lru_busy),\r\ncli->cl_lru_reclaim);\r\nreturn 0;\r\n}\r\nstatic ssize_t osc_cached_mb_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *dev = ((struct seq_file *)file->private_data)->private;\r\nstruct client_obd *cli = &dev->u.cli;\r\nlong pages_number, rc;\r\nchar kernbuf[128];\r\nint mult;\r\nu64 val;\r\nif (count >= sizeof(kernbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nkernbuf[count] = 0;\r\nmult = 1 << (20 - PAGE_SHIFT);\r\nbuffer += lprocfs_find_named_value(kernbuf, "used_mb:", &count) -\r\nkernbuf;\r\nrc = lprocfs_write_frac_u64_helper(buffer, count, &val, mult);\r\nif (rc)\r\nreturn rc;\r\nif (val > LONG_MAX)\r\nreturn -ERANGE;\r\npages_number = (long)val;\r\nif (pages_number < 0)\r\nreturn -ERANGE;\r\nrc = atomic_long_read(&cli->cl_lru_in_list) - pages_number;\r\nif (rc > 0) {\r\nstruct lu_env *env;\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\n(void)osc_lru_shrink(env, cli, rc, true);\r\ncl_env_put(env, &refcheck);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t cur_dirty_bytes_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nint len;\r\nspin_lock(&cli->cl_loi_list_lock);\r\nlen = sprintf(buf, "%lu\n", cli->cl_dirty_pages << PAGE_SHIFT);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t cur_grant_bytes_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nint len;\r\nspin_lock(&cli->cl_loi_list_lock);\r\nlen = sprintf(buf, "%lu\n", cli->cl_avail_grant);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t cur_grant_bytes_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &obd->u.cli;\r\nint rc;\r\nunsigned long long val;\r\nrc = kstrtoull(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nspin_lock(&cli->cl_loi_list_lock);\r\nif (val >= cli->cl_avail_grant) {\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nif (cli->cl_import->imp_state == LUSTRE_IMP_FULL)\r\nrc = osc_shrink_grant_to_target(cli, val);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t cur_lost_grant_bytes_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nint len;\r\nspin_lock(&cli->cl_loi_list_lock);\r\nlen = sprintf(buf, "%lu\n", cli->cl_lost_grant);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn len;\r\n}\r\nstatic ssize_t grant_shrink_interval_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nreturn sprintf(buf, "%d\n", obd->u.cli.cl_grant_shrink_interval);\r\n}\r\nstatic ssize_t grant_shrink_interval_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val <= 0)\r\nreturn -ERANGE;\r\nobd->u.cli.cl_grant_shrink_interval = val;\r\nreturn count;\r\n}\r\nstatic ssize_t checksums_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nreturn sprintf(buf, "%d\n", obd->u.cli.cl_checksum ? 1 : 0);\r\n}\r\nstatic ssize_t checksums_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nobd->u.cli.cl_checksum = (val ? 1 : 0);\r\nreturn count;\r\n}\r\nstatic int osc_checksum_type_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct obd_device *obd = m->private;\r\nint i;\r\nDECLARE_CKSUM_NAME;\r\nif (!obd)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(cksum_name); i++) {\r\nif (((1 << i) & obd->u.cli.cl_supp_cksum_types) == 0)\r\ncontinue;\r\nif (obd->u.cli.cl_cksum_type == (1 << i))\r\nseq_printf(m, "[%s] ", cksum_name[i]);\r\nelse\r\nseq_printf(m, "%s ", cksum_name[i]);\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic ssize_t osc_checksum_type_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nint i;\r\nDECLARE_CKSUM_NAME;\r\nchar kernbuf[10];\r\nif (!obd)\r\nreturn 0;\r\nif (count > sizeof(kernbuf) - 1)\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nif (count > 0 && kernbuf[count - 1] == '\n')\r\nkernbuf[count - 1] = '\0';\r\nelse\r\nkernbuf[count] = '\0';\r\nfor (i = 0; i < ARRAY_SIZE(cksum_name); i++) {\r\nif (((1 << i) & obd->u.cli.cl_supp_cksum_types) == 0)\r\ncontinue;\r\nif (!strcmp(kernbuf, cksum_name[i])) {\r\nobd->u.cli.cl_cksum_type = 1 << i;\r\nreturn count;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t resend_count_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nreturn sprintf(buf, "%u\n", atomic_read(&obd->u.cli.cl_resends));\r\n}\r\nstatic ssize_t resend_count_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\natomic_set(&obd->u.cli.cl_resends, val);\r\nreturn count;\r\n}\r\nstatic ssize_t contention_seconds_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct osc_device *od = obd2osc_dev(obd);\r\nreturn sprintf(buf, "%u\n", od->od_contention_time);\r\n}\r\nstatic ssize_t contention_seconds_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct osc_device *od = obd2osc_dev(obd);\r\nint rc;\r\nint val;\r\nrc = kstrtoint(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val < 0)\r\nreturn -EINVAL;\r\nod->od_contention_time = val;\r\nreturn count;\r\n}\r\nstatic ssize_t lockless_truncate_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct osc_device *od = obd2osc_dev(obd);\r\nreturn sprintf(buf, "%u\n", od->od_lockless_truncate);\r\n}\r\nstatic ssize_t lockless_truncate_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct osc_device *od = obd2osc_dev(obd);\r\nint rc;\r\nunsigned int val;\r\nrc = kstrtouint(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nod->od_lockless_truncate = val;\r\nreturn count;\r\n}\r\nstatic ssize_t destroys_in_flight_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *obd = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nreturn sprintf(buf, "%u\n",\r\natomic_read(&obd->u.cli.cl_destroy_in_flight));\r\n}\r\nstatic ssize_t max_pages_per_rpc_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nreturn sprintf(buf, "%d\n", cli->cl_max_pages_per_rpc);\r\n}\r\nstatic ssize_t max_pages_per_rpc_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nstruct obd_connect_data *ocd = &cli->cl_import->imp_connect_data;\r\nint chunk_mask, rc;\r\nunsigned long long val;\r\nrc = kstrtoull(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val >= ONE_MB_BRW_SIZE)\r\nval >>= PAGE_SHIFT;\r\nchunk_mask = ~((1 << (cli->cl_chunkbits - PAGE_SHIFT)) - 1);\r\nval = (val + ~chunk_mask) & chunk_mask;\r\nif (!val || (ocd->ocd_brw_size &&\r\nval > ocd->ocd_brw_size >> PAGE_SHIFT)) {\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&cli->cl_loi_list_lock);\r\ncli->cl_max_pages_per_rpc = val;\r\nclient_adjust_max_dirty(cli);\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t unstable_stats_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct obd_device *dev = container_of(kobj, struct obd_device,\r\nobd_kobj);\r\nstruct client_obd *cli = &dev->u.cli;\r\nlong pages;\r\nint mb;\r\npages = atomic_long_read(&cli->cl_unstable_count);\r\nmb = (pages * PAGE_SIZE) >> 20;\r\nreturn sprintf(buf, "unstable_pages: %20ld\n"\r\n"unstable_mb: %10d\n", pages, mb);\r\n}\r\nstatic int osc_rpc_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timespec64 now;\r\nstruct obd_device *dev = seq->private;\r\nstruct client_obd *cli = &dev->u.cli;\r\nunsigned long read_tot = 0, write_tot = 0, read_cum, write_cum;\r\nint i;\r\nktime_get_real_ts64(&now);\r\nspin_lock(&cli->cl_loi_list_lock);\r\nseq_printf(seq, "snapshot_time: %llu.%9lu (secs.usecs)\n",\r\n(s64)now.tv_sec, (unsigned long)now.tv_nsec);\r\nseq_printf(seq, "read RPCs in flight: %d\n",\r\ncli->cl_r_in_flight);\r\nseq_printf(seq, "write RPCs in flight: %d\n",\r\ncli->cl_w_in_flight);\r\nseq_printf(seq, "pending write pages: %d\n",\r\natomic_read(&cli->cl_pending_w_pages));\r\nseq_printf(seq, "pending read pages: %d\n",\r\natomic_read(&cli->cl_pending_r_pages));\r\nseq_puts(seq, "\n\t\t\tread\t\t\twrite\n");\r\nseq_puts(seq, "pages per rpc rpcs % cum % |");\r\nseq_puts(seq, " rpcs % cum %\n");\r\nread_tot = lprocfs_oh_sum(&cli->cl_read_page_hist);\r\nwrite_tot = lprocfs_oh_sum(&cli->cl_write_page_hist);\r\nread_cum = 0;\r\nwrite_cum = 0;\r\nfor (i = 0; i < OBD_HIST_MAX; i++) {\r\nunsigned long r = cli->cl_read_page_hist.oh_buckets[i];\r\nunsigned long w = cli->cl_write_page_hist.oh_buckets[i];\r\nread_cum += r;\r\nwrite_cum += w;\r\nseq_printf(seq, "%d:\t\t%10lu %3lu %3lu | %10lu %3lu %3lu\n",\r\n1 << i, r, pct(r, read_tot),\r\npct(read_cum, read_tot), w,\r\npct(w, write_tot),\r\npct(write_cum, write_tot));\r\nif (read_cum == read_tot && write_cum == write_tot)\r\nbreak;\r\n}\r\nseq_puts(seq, "\n\t\t\tread\t\t\twrite\n");\r\nseq_puts(seq, "rpcs in flight rpcs % cum % |");\r\nseq_puts(seq, " rpcs % cum %\n");\r\nread_tot = lprocfs_oh_sum(&cli->cl_read_rpc_hist);\r\nwrite_tot = lprocfs_oh_sum(&cli->cl_write_rpc_hist);\r\nread_cum = 0;\r\nwrite_cum = 0;\r\nfor (i = 0; i < OBD_HIST_MAX; i++) {\r\nunsigned long r = cli->cl_read_rpc_hist.oh_buckets[i];\r\nunsigned long w = cli->cl_write_rpc_hist.oh_buckets[i];\r\nread_cum += r;\r\nwrite_cum += w;\r\nseq_printf(seq, "%d:\t\t%10lu %3lu %3lu | %10lu %3lu %3lu\n",\r\ni, r, pct(r, read_tot),\r\npct(read_cum, read_tot), w,\r\npct(w, write_tot),\r\npct(write_cum, write_tot));\r\nif (read_cum == read_tot && write_cum == write_tot)\r\nbreak;\r\n}\r\nseq_puts(seq, "\n\t\t\tread\t\t\twrite\n");\r\nseq_puts(seq, "offset rpcs % cum % |");\r\nseq_puts(seq, " rpcs % cum %\n");\r\nread_tot = lprocfs_oh_sum(&cli->cl_read_offset_hist);\r\nwrite_tot = lprocfs_oh_sum(&cli->cl_write_offset_hist);\r\nread_cum = 0;\r\nwrite_cum = 0;\r\nfor (i = 0; i < OBD_HIST_MAX; i++) {\r\nunsigned long r = cli->cl_read_offset_hist.oh_buckets[i];\r\nunsigned long w = cli->cl_write_offset_hist.oh_buckets[i];\r\nread_cum += r;\r\nwrite_cum += w;\r\nseq_printf(seq, "%d:\t\t%10lu %3lu %3lu | %10lu %3lu %3lu\n",\r\n(i == 0) ? 0 : 1 << (i - 1),\r\nr, pct(r, read_tot), pct(read_cum, read_tot),\r\nw, pct(w, write_tot), pct(write_cum, write_tot));\r\nif (read_cum == read_tot && write_cum == write_tot)\r\nbreak;\r\n}\r\nspin_unlock(&cli->cl_loi_list_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t osc_rpc_stats_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct obd_device *dev = seq->private;\r\nstruct client_obd *cli = &dev->u.cli;\r\nlprocfs_oh_clear(&cli->cl_read_rpc_hist);\r\nlprocfs_oh_clear(&cli->cl_write_rpc_hist);\r\nlprocfs_oh_clear(&cli->cl_read_page_hist);\r\nlprocfs_oh_clear(&cli->cl_write_page_hist);\r\nlprocfs_oh_clear(&cli->cl_read_offset_hist);\r\nlprocfs_oh_clear(&cli->cl_write_offset_hist);\r\nreturn len;\r\n}\r\nstatic int osc_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timespec64 now;\r\nstruct obd_device *dev = seq->private;\r\nstruct osc_stats *stats = &obd2osc_dev(dev)->od_stats;\r\nktime_get_real_ts64(&now);\r\nseq_printf(seq, "snapshot_time: %llu.%9lu (secs.usecs)\n",\r\n(s64)now.tv_sec, (unsigned long)now.tv_nsec);\r\nseq_printf(seq, "lockless_write_bytes\t\t%llu\n",\r\nstats->os_lockless_writes);\r\nseq_printf(seq, "lockless_read_bytes\t\t%llu\n",\r\nstats->os_lockless_reads);\r\nseq_printf(seq, "lockless_truncate\t\t%llu\n",\r\nstats->os_lockless_truncates);\r\nreturn 0;\r\n}\r\nstatic ssize_t osc_stats_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct obd_device *dev = seq->private;\r\nstruct osc_stats *stats = &obd2osc_dev(dev)->od_stats;\r\nmemset(stats, 0, sizeof(*stats));\r\nreturn len;\r\n}\r\nint lproc_osc_attach_seqstat(struct obd_device *dev)\r\n{\r\nint rc;\r\nrc = ldebugfs_seq_create(dev->obd_debugfs_entry, "osc_stats", 0644,\r\n&osc_stats_fops, dev);\r\nif (rc == 0)\r\nrc = ldebugfs_obd_seq_create(dev, "rpc_stats", 0644,\r\n&osc_rpc_stats_fops, dev);\r\nreturn rc;\r\n}\r\nvoid lprocfs_osc_init_vars(struct lprocfs_static_vars *lvars)\r\n{\r\nlvars->sysfs_vars = &osc_attr_group;\r\nlvars->obd_vars = lprocfs_osc_obd_vars;\r\n}
