static u8 calc_lrc(u8 *buf, int len)\r\n{\r\nint i;\r\nu8 sum = 0;\r\nfor (i = 0; i < len; i++)\r\nsum = sum ^ buf[i];\r\nreturn sum;\r\n}\r\nstatic int flexcop_eeprom_request(struct flexcop_device *fc,\r\nflexcop_access_op_t op, u16 addr, u8 *buf, u16 len, int retries)\r\n{\r\nint i,ret = 0;\r\nu8 chipaddr = 0x50 | ((addr >> 8) & 3);\r\nfor (i = 0; i < retries; i++) {\r\nret = fc->i2c_request(&fc->fc_i2c_adap[1], op, chipaddr,\r\naddr & 0xff, buf, len);\r\nif (ret == 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int flexcop_eeprom_lrc_read(struct flexcop_device *fc, u16 addr,\r\nu8 *buf, u16 len, int retries)\r\n{\r\nint ret = flexcop_eeprom_request(fc, FC_READ, addr, buf, len, retries);\r\nif (ret == 0)\r\nif (calc_lrc(buf, len - 1) != buf[len - 1])\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nint flexcop_eeprom_check_mac_addr(struct flexcop_device *fc, int extended)\r\n{\r\nu8 buf[8];\r\nint ret = 0;\r\nif ((ret = flexcop_eeprom_lrc_read(fc,0x3f8,buf,8,4)) == 0) {\r\nif (extended != 0) {\r\nerr("TODO: extended (EUI64) MAC addresses aren't completely supported yet");\r\nret = -EINVAL;\r\n} else\r\nmemcpy(fc->dvb_adapter.proposed_mac,buf,6);\r\n}\r\nreturn ret;\r\n}
