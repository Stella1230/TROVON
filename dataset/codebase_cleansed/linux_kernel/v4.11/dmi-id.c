static ssize_t sys_dmi_field_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *page)\r\n{\r\nint field = to_dmi_dev_attr(attr)->field;\r\nssize_t len;\r\nlen = scnprintf(page, PAGE_SIZE, "%s\n", dmi_get_system_info(field));\r\npage[len-1] = '\n';\r\nreturn len;\r\n}\r\nstatic void ascii_filter(char *d, const char *s)\r\n{\r\nfor (; *s; s++)\r\nif (*s > ' ' && *s < 127 && *s != ':')\r\n*(d++) = *s;\r\n*d = 0;\r\n}\r\nstatic ssize_t get_modalias(char *buffer, size_t buffer_size)\r\n{\r\nstatic const struct mafield {\r\nconst char *prefix;\r\nint field;\r\n} fields[] = {\r\n{ "bvn", DMI_BIOS_VENDOR },\r\n{ "bvr", DMI_BIOS_VERSION },\r\n{ "bd", DMI_BIOS_DATE },\r\n{ "svn", DMI_SYS_VENDOR },\r\n{ "pn", DMI_PRODUCT_NAME },\r\n{ "pvr", DMI_PRODUCT_VERSION },\r\n{ "rvn", DMI_BOARD_VENDOR },\r\n{ "rn", DMI_BOARD_NAME },\r\n{ "rvr", DMI_BOARD_VERSION },\r\n{ "cvn", DMI_CHASSIS_VENDOR },\r\n{ "ct", DMI_CHASSIS_TYPE },\r\n{ "cvr", DMI_CHASSIS_VERSION },\r\n{ NULL, DMI_NONE }\r\n};\r\nssize_t l, left;\r\nchar *p;\r\nconst struct mafield *f;\r\nstrcpy(buffer, "dmi");\r\np = buffer + 3; left = buffer_size - 4;\r\nfor (f = fields; f->prefix && left > 0; f++) {\r\nconst char *c;\r\nchar *t;\r\nc = dmi_get_system_info(f->field);\r\nif (!c)\r\ncontinue;\r\nt = kmalloc(strlen(c) + 1, GFP_KERNEL);\r\nif (!t)\r\nbreak;\r\nascii_filter(t, c);\r\nl = scnprintf(p, left, ":%s%s", f->prefix, t);\r\nkfree(t);\r\np += l;\r\nleft -= l;\r\n}\r\np[0] = ':';\r\np[1] = 0;\r\nreturn p - buffer + 1;\r\n}\r\nstatic ssize_t sys_dmi_modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nssize_t r;\r\nr = get_modalias(page, PAGE_SIZE-1);\r\npage[r] = '\n';\r\npage[r+1] = 0;\r\nreturn r+1;\r\n}\r\nstatic int dmi_dev_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nssize_t len;\r\nif (add_uevent_var(env, "MODALIAS="))\r\nreturn -ENOMEM;\r\nlen = get_modalias(&env->buf[env->buflen - 1],\r\nsizeof(env->buf) - env->buflen);\r\nif (len >= (sizeof(env->buf) - env->buflen))\r\nreturn -ENOMEM;\r\nenv->buflen += len;\r\nreturn 0;\r\n}\r\nstatic void __init dmi_id_init_attr_table(void)\r\n{\r\nint i;\r\ni = 0;\r\nADD_DMI_ATTR(bios_vendor, DMI_BIOS_VENDOR);\r\nADD_DMI_ATTR(bios_version, DMI_BIOS_VERSION);\r\nADD_DMI_ATTR(bios_date, DMI_BIOS_DATE);\r\nADD_DMI_ATTR(sys_vendor, DMI_SYS_VENDOR);\r\nADD_DMI_ATTR(product_name, DMI_PRODUCT_NAME);\r\nADD_DMI_ATTR(product_version, DMI_PRODUCT_VERSION);\r\nADD_DMI_ATTR(product_serial, DMI_PRODUCT_SERIAL);\r\nADD_DMI_ATTR(product_uuid, DMI_PRODUCT_UUID);\r\nADD_DMI_ATTR(board_vendor, DMI_BOARD_VENDOR);\r\nADD_DMI_ATTR(board_name, DMI_BOARD_NAME);\r\nADD_DMI_ATTR(board_version, DMI_BOARD_VERSION);\r\nADD_DMI_ATTR(board_serial, DMI_BOARD_SERIAL);\r\nADD_DMI_ATTR(board_asset_tag, DMI_BOARD_ASSET_TAG);\r\nADD_DMI_ATTR(chassis_vendor, DMI_CHASSIS_VENDOR);\r\nADD_DMI_ATTR(chassis_type, DMI_CHASSIS_TYPE);\r\nADD_DMI_ATTR(chassis_version, DMI_CHASSIS_VERSION);\r\nADD_DMI_ATTR(chassis_serial, DMI_CHASSIS_SERIAL);\r\nADD_DMI_ATTR(chassis_asset_tag, DMI_CHASSIS_ASSET_TAG);\r\nsys_dmi_attributes[i++] = &sys_dmi_modalias_attr.attr;\r\n}\r\nstatic int __init dmi_id_init(void)\r\n{\r\nint ret;\r\nif (!dmi_available)\r\nreturn -ENODEV;\r\ndmi_id_init_attr_table();\r\nret = class_register(&dmi_class);\r\nif (ret)\r\nreturn ret;\r\ndmi_dev = kzalloc(sizeof(*dmi_dev), GFP_KERNEL);\r\nif (!dmi_dev) {\r\nret = -ENOMEM;\r\ngoto fail_class_unregister;\r\n}\r\ndmi_dev->class = &dmi_class;\r\ndev_set_name(dmi_dev, "id");\r\ndmi_dev->groups = sys_dmi_attribute_groups;\r\nret = device_register(dmi_dev);\r\nif (ret)\r\ngoto fail_put_dmi_dev;\r\nreturn 0;\r\nfail_put_dmi_dev:\r\nput_device(dmi_dev);\r\nfail_class_unregister:\r\nclass_unregister(&dmi_class);\r\nreturn ret;\r\n}
