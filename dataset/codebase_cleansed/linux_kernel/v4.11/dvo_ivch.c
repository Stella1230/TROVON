static bool ivch_read(struct intel_dvo_device *dvo, int addr, uint16_t *data)\r\n{\r\nstruct ivch_priv *priv = dvo->dev_priv;\r\nstruct i2c_adapter *adapter = dvo->i2c_bus;\r\nu8 out_buf[1];\r\nu8 in_buf[2];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = dvo->slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 0,\r\n},\r\n{\r\n.addr = 0,\r\n.flags = I2C_M_NOSTART,\r\n.len = 1,\r\n.buf = out_buf,\r\n},\r\n{\r\n.addr = dvo->slave_addr,\r\n.flags = I2C_M_RD | I2C_M_NOSTART,\r\n.len = 2,\r\n.buf = in_buf,\r\n}\r\n};\r\nout_buf[0] = addr;\r\nif (i2c_transfer(adapter, msgs, 3) == 3) {\r\n*data = (in_buf[1] << 8) | in_buf[0];\r\nreturn true;\r\n}\r\nif (!priv->quiet) {\r\nDRM_DEBUG_KMS("Unable to read register 0x%02x from "\r\n"%s:%02x.\n",\r\naddr, adapter->name, dvo->slave_addr);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ivch_write(struct intel_dvo_device *dvo, int addr, uint16_t data)\r\n{\r\nstruct ivch_priv *priv = dvo->dev_priv;\r\nstruct i2c_adapter *adapter = dvo->i2c_bus;\r\nu8 out_buf[3];\r\nstruct i2c_msg msg = {\r\n.addr = dvo->slave_addr,\r\n.flags = 0,\r\n.len = 3,\r\n.buf = out_buf,\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = data & 0xff;\r\nout_buf[2] = data >> 8;\r\nif (i2c_transfer(adapter, &msg, 1) == 1)\r\nreturn true;\r\nif (!priv->quiet) {\r\nDRM_DEBUG_KMS("Unable to write register 0x%02x to %s:%d.\n",\r\naddr, adapter->name, dvo->slave_addr);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ivch_init(struct intel_dvo_device *dvo,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct ivch_priv *priv;\r\nuint16_t temp;\r\nint i;\r\npriv = kzalloc(sizeof(struct ivch_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn false;\r\ndvo->i2c_bus = adapter;\r\ndvo->dev_priv = priv;\r\npriv->quiet = true;\r\nif (!ivch_read(dvo, VR00, &temp))\r\ngoto out;\r\npriv->quiet = false;\r\nif ((temp & VR00_BASE_ADDRESS_MASK) != dvo->slave_addr) {\r\nDRM_DEBUG_KMS("ivch detect failed due to address mismatch "\r\n"(%d vs %d)\n",\r\n(temp & VR00_BASE_ADDRESS_MASK), dvo->slave_addr);\r\ngoto out;\r\n}\r\nivch_read(dvo, VR20, &priv->width);\r\nivch_read(dvo, VR21, &priv->height);\r\nfor (i = 0; i < ARRAY_SIZE(backup_addresses); i++)\r\nivch_read(dvo, backup_addresses[i], priv->reg_backup + i);\r\nivch_dump_regs(dvo);\r\nreturn true;\r\nout:\r\nkfree(priv);\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status ivch_detect(struct intel_dvo_device *dvo)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic enum drm_mode_status ivch_mode_valid(struct intel_dvo_device *dvo,\r\nstruct drm_display_mode *mode)\r\n{\r\nif (mode->clock > 112000)\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic void ivch_reset(struct intel_dvo_device *dvo)\r\n{\r\nstruct ivch_priv *priv = dvo->dev_priv;\r\nint i;\r\nDRM_DEBUG_KMS("Resetting the IVCH registers\n");\r\nivch_write(dvo, VR10, 0x0000);\r\nfor (i = 0; i < ARRAY_SIZE(backup_addresses); i++)\r\nivch_write(dvo, backup_addresses[i], priv->reg_backup[i]);\r\n}\r\nstatic void ivch_dpms(struct intel_dvo_device *dvo, bool enable)\r\n{\r\nint i;\r\nuint16_t vr01, vr30, backlight;\r\nivch_reset(dvo);\r\nif (!ivch_read(dvo, VR01, &vr01))\r\nreturn;\r\nif (enable)\r\nbacklight = 1;\r\nelse\r\nbacklight = 0;\r\nivch_write(dvo, VR80, backlight);\r\nif (enable)\r\nvr01 |= VR01_LCD_ENABLE | VR01_DVO_ENABLE;\r\nelse\r\nvr01 &= ~(VR01_LCD_ENABLE | VR01_DVO_ENABLE);\r\nivch_write(dvo, VR01, vr01);\r\nfor (i = 0; i < 100; i++) {\r\nif (!ivch_read(dvo, VR30, &vr30))\r\nbreak;\r\nif (((vr30 & VR30_PANEL_ON) != 0) == enable)\r\nbreak;\r\nudelay(1000);\r\n}\r\nudelay(16 * 1000);\r\n}\r\nstatic bool ivch_get_hw_state(struct intel_dvo_device *dvo)\r\n{\r\nuint16_t vr01;\r\nivch_reset(dvo);\r\nif (!ivch_read(dvo, VR01, &vr01))\r\nreturn false;\r\nif (vr01 & VR01_LCD_ENABLE)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void ivch_mode_set(struct intel_dvo_device *dvo,\r\nconst struct drm_display_mode *mode,\r\nconst struct drm_display_mode *adjusted_mode)\r\n{\r\nstruct ivch_priv *priv = dvo->dev_priv;\r\nuint16_t vr40 = 0;\r\nuint16_t vr01 = 0;\r\nuint16_t vr10;\r\nivch_reset(dvo);\r\nvr10 = priv->reg_backup[ARRAY_SIZE(backup_addresses) - 1];\r\nvr10 &= VR10_INTERFACE_DEPTH_MASK;\r\nif (vr10 == VR10_INTERFACE_2X18 || vr10 == VR10_INTERFACE_1X18)\r\nvr01 = VR01_DITHER_ENABLE;\r\nvr40 = (VR40_STALL_ENABLE | VR40_VERTICAL_INTERP_ENABLE |\r\nVR40_HORIZONTAL_INTERP_ENABLE);\r\nif (mode->hdisplay != adjusted_mode->crtc_hdisplay ||\r\nmode->vdisplay != adjusted_mode->crtc_vdisplay) {\r\nuint16_t x_ratio, y_ratio;\r\nvr01 |= VR01_PANEL_FIT_ENABLE;\r\nvr40 |= VR40_CLOCK_GATING_ENABLE;\r\nx_ratio = (((mode->hdisplay - 1) << 16) /\r\n(adjusted_mode->crtc_hdisplay - 1)) >> 2;\r\ny_ratio = (((mode->vdisplay - 1) << 16) /\r\n(adjusted_mode->crtc_vdisplay - 1)) >> 2;\r\nivch_write(dvo, VR42, x_ratio);\r\nivch_write(dvo, VR41, y_ratio);\r\n} else {\r\nvr01 &= ~VR01_PANEL_FIT_ENABLE;\r\nvr40 &= ~VR40_CLOCK_GATING_ENABLE;\r\n}\r\nvr40 &= ~VR40_AUTO_RATIO_ENABLE;\r\nivch_write(dvo, VR01, vr01);\r\nivch_write(dvo, VR40, vr40);\r\n}\r\nstatic void ivch_dump_regs(struct intel_dvo_device *dvo)\r\n{\r\nuint16_t val;\r\nivch_read(dvo, VR00, &val);\r\nDRM_DEBUG_KMS("VR00: 0x%04x\n", val);\r\nivch_read(dvo, VR01, &val);\r\nDRM_DEBUG_KMS("VR01: 0x%04x\n", val);\r\nivch_read(dvo, VR10, &val);\r\nDRM_DEBUG_KMS("VR10: 0x%04x\n", val);\r\nivch_read(dvo, VR30, &val);\r\nDRM_DEBUG_KMS("VR30: 0x%04x\n", val);\r\nivch_read(dvo, VR40, &val);\r\nDRM_DEBUG_KMS("VR40: 0x%04x\n", val);\r\nivch_read(dvo, VR80, &val);\r\nDRM_DEBUG_KMS("VR80: 0x%04x\n", val);\r\nivch_read(dvo, VR81, &val);\r\nDRM_DEBUG_KMS("VR81: 0x%04x\n", val);\r\nivch_read(dvo, VR82, &val);\r\nDRM_DEBUG_KMS("VR82: 0x%04x\n", val);\r\nivch_read(dvo, VR83, &val);\r\nDRM_DEBUG_KMS("VR83: 0x%04x\n", val);\r\nivch_read(dvo, VR84, &val);\r\nDRM_DEBUG_KMS("VR84: 0x%04x\n", val);\r\nivch_read(dvo, VR85, &val);\r\nDRM_DEBUG_KMS("VR85: 0x%04x\n", val);\r\nivch_read(dvo, VR86, &val);\r\nDRM_DEBUG_KMS("VR86: 0x%04x\n", val);\r\nivch_read(dvo, VR87, &val);\r\nDRM_DEBUG_KMS("VR87: 0x%04x\n", val);\r\nivch_read(dvo, VR88, &val);\r\nDRM_DEBUG_KMS("VR88: 0x%04x\n", val);\r\nivch_read(dvo, VR8E, &val);\r\nDRM_DEBUG_KMS("VR8E: 0x%04x\n", val);\r\nivch_read(dvo, VR8F, &val);\r\nDRM_DEBUG_KMS("VR8F: 0x%04x\n", val);\r\n}\r\nstatic void ivch_destroy(struct intel_dvo_device *dvo)\r\n{\r\nstruct ivch_priv *priv = dvo->dev_priv;\r\nif (priv) {\r\nkfree(priv);\r\ndvo->dev_priv = NULL;\r\n}\r\n}
