static int hdmi_pin_set_slot_channel(struct hdac_device *codec,\r\nhda_nid_t pin_nid, int asp_slot, int channel)\r\n{\r\nreturn snd_hdac_codec_write(codec, pin_nid, 0,\r\nAC_VERB_SET_HDMI_CHAN_SLOT,\r\n(channel << 4) | asp_slot);\r\n}\r\nstatic int hdmi_pin_get_slot_channel(struct hdac_device *codec,\r\nhda_nid_t pin_nid, int asp_slot)\r\n{\r\nreturn (snd_hdac_codec_read(codec, pin_nid, 0,\r\nAC_VERB_GET_HDMI_CHAN_SLOT,\r\nasp_slot) & 0xf0) >> 4;\r\n}\r\nstatic int hdmi_get_channel_count(struct hdac_device *codec, hda_nid_t cvt_nid)\r\n{\r\nreturn 1 + snd_hdac_codec_read(codec, cvt_nid, 0,\r\nAC_VERB_GET_CVT_CHAN_COUNT, 0);\r\n}\r\nstatic void hdmi_set_channel_count(struct hdac_device *codec,\r\nhda_nid_t cvt_nid, int chs)\r\n{\r\nif (chs != hdmi_get_channel_count(codec, cvt_nid))\r\nsnd_hdac_codec_write(codec, cvt_nid, 0,\r\nAC_VERB_SET_CVT_CHAN_COUNT, chs - 1);\r\n}\r\nstatic void init_channel_allocations(void)\r\n{\r\nint i, j;\r\nstruct hdac_cea_channel_speaker_allocation *p;\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\np = channel_allocations + i;\r\np->channels = 0;\r\np->spk_mask = 0;\r\nfor (j = 0; j < ARRAY_SIZE(p->speakers); j++)\r\nif (p->speakers[j]) {\r\np->channels++;\r\np->spk_mask |= p->speakers[j];\r\n}\r\n}\r\n}\r\nstatic int get_channel_allocation_order(int ca)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\nif (channel_allocations[i].ca_index == ca)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nvoid snd_hdac_print_channel_allocation(int spk_alloc, char *buf, int buflen)\r\n{\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(cea_speaker_allocation_names); i++) {\r\nif (spk_alloc & (1 << i))\r\nj += snprintf(buf + j, buflen - j, " %s",\r\ncea_speaker_allocation_names[i]);\r\n}\r\nbuf[j] = '\0';\r\n}\r\nstatic int hdmi_channel_allocation_spk_alloc_blk(struct hdac_device *codec,\r\nint spk_alloc, int channels)\r\n{\r\nint i;\r\nint ca = 0;\r\nint spk_mask = 0;\r\nchar buf[SND_PRINT_CHANNEL_ALLOCATION_ADVISED_BUFSIZE];\r\nif (channels <= 2)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\r\nif (spk_alloc & (1 << i))\r\nspk_mask |= eld_speaker_allocation_bits[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\nif (channels == channel_allocations[i].channels &&\r\n(spk_mask & channel_allocations[i].spk_mask) ==\r\nchannel_allocations[i].spk_mask) {\r\nca = channel_allocations[i].ca_index;\r\nbreak;\r\n}\r\n}\r\nif (!ca) {\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\nif (channels == channel_allocations[i].channels) {\r\nca = channel_allocations[i].ca_index;\r\nbreak;\r\n}\r\n}\r\n}\r\nsnd_hdac_print_channel_allocation(spk_alloc, buf, sizeof(buf));\r\ndev_dbg(&codec->dev, "HDMI: select CA 0x%x for %d-channel allocation: %s\n",\r\nca, channels, buf);\r\nreturn ca;\r\n}\r\nstatic void hdmi_debug_channel_mapping(struct hdac_chmap *chmap,\r\nhda_nid_t pin_nid)\r\n{\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nint i;\r\nint channel;\r\nfor (i = 0; i < 8; i++) {\r\nchannel = chmap->ops.pin_get_slot_channel(\r\nchmap->hdac, pin_nid, i);\r\ndev_dbg(&chmap->hdac->dev, "HDMI: ASP channel %d => slot %d\n",\r\nchannel, i);\r\n}\r\n#endif\r\n}\r\nstatic void hdmi_std_setup_channel_mapping(struct hdac_chmap *chmap,\r\nhda_nid_t pin_nid,\r\nbool non_pcm,\r\nint ca)\r\n{\r\nstruct hdac_cea_channel_speaker_allocation *ch_alloc;\r\nint i;\r\nint err;\r\nint order;\r\nint non_pcm_mapping[8];\r\norder = get_channel_allocation_order(ca);\r\nch_alloc = &channel_allocations[order];\r\nif (hdmi_channel_mapping[ca][1] == 0) {\r\nint hdmi_slot = 0;\r\nfor (i = 0; i < ch_alloc->channels; i++) {\r\nwhile (!WARN_ON(hdmi_slot >= 8) &&\r\n!ch_alloc->speakers[7 - hdmi_slot])\r\nhdmi_slot++;\r\nhdmi_channel_mapping[ca][i] = (i << 4) | hdmi_slot++;\r\n}\r\nfor (hdmi_slot = 0; hdmi_slot < 8; hdmi_slot++)\r\nif (!ch_alloc->speakers[7 - hdmi_slot])\r\nhdmi_channel_mapping[ca][i++] = (0xf << 4) | hdmi_slot;\r\n}\r\nif (non_pcm) {\r\nfor (i = 0; i < ch_alloc->channels; i++)\r\nnon_pcm_mapping[i] = (i << 4) | i;\r\nfor (; i < 8; i++)\r\nnon_pcm_mapping[i] = (0xf << 4) | i;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nint slotsetup = non_pcm ? non_pcm_mapping[i] : hdmi_channel_mapping[ca][i];\r\nint hdmi_slot = slotsetup & 0x0f;\r\nint channel = (slotsetup & 0xf0) >> 4;\r\nerr = chmap->ops.pin_set_slot_channel(chmap->hdac,\r\npin_nid, hdmi_slot, channel);\r\nif (err) {\r\ndev_dbg(&chmap->hdac->dev, "HDMI: channel mapping failed\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nint snd_hdac_chmap_to_spk_mask(unsigned char c)\r\n{\r\nstruct channel_map_table *t = map_tables;\r\nfor (; t->map; t++) {\r\nif (t->map == c)\r\nreturn t->spk_mask;\r\n}\r\nreturn 0;\r\n}\r\nstatic int to_cea_slot(int ordered_ca, unsigned char pos)\r\n{\r\nint mask = snd_hdac_chmap_to_spk_mask(pos);\r\nint i;\r\nif (ordered_ca >= ARRAY_SIZE(channel_allocations))\r\nreturn -1;\r\nif (mask) {\r\nfor (i = 0; i < 8; i++) {\r\nif (channel_allocations[ordered_ca].speakers[7 - i] == mask)\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint snd_hdac_spk_to_chmap(int spk)\r\n{\r\nstruct channel_map_table *t = map_tables;\r\nfor (; t->map; t++) {\r\nif (t->spk_mask == spk)\r\nreturn t->map;\r\n}\r\nreturn 0;\r\n}\r\nstatic int from_cea_slot(int ordered_ca, unsigned char slot)\r\n{\r\nint mask;\r\nif (slot >= 8)\r\nreturn 0;\r\nmask = channel_allocations[ordered_ca].speakers[7 - slot];\r\nreturn snd_hdac_spk_to_chmap(mask);\r\n}\r\nstatic int hdmi_manual_channel_allocation(int chs, unsigned char *map)\r\n{\r\nint i, spks = 0, spk_mask = 0;\r\nfor (i = 0; i < chs; i++) {\r\nint mask = snd_hdac_chmap_to_spk_mask(map[i]);\r\nif (mask) {\r\nspk_mask |= mask;\r\nspks++;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++) {\r\nif ((chs == channel_allocations[i].channels ||\r\nspks == channel_allocations[i].channels) &&\r\n(spk_mask & channel_allocations[i].spk_mask) ==\r\nchannel_allocations[i].spk_mask)\r\nreturn channel_allocations[i].ca_index;\r\n}\r\nreturn -1;\r\n}\r\nstatic int hdmi_manual_setup_channel_mapping(struct hdac_chmap *chmap,\r\nhda_nid_t pin_nid,\r\nint chs, unsigned char *map,\r\nint ca)\r\n{\r\nint ordered_ca = get_channel_allocation_order(ca);\r\nint alsa_pos, hdmi_slot;\r\nint assignments[8] = {[0 ... 7] = 0xf};\r\nfor (alsa_pos = 0; alsa_pos < chs; alsa_pos++) {\r\nhdmi_slot = to_cea_slot(ordered_ca, map[alsa_pos]);\r\nif (hdmi_slot < 0)\r\ncontinue;\r\nassignments[hdmi_slot] = alsa_pos;\r\n}\r\nfor (hdmi_slot = 0; hdmi_slot < 8; hdmi_slot++) {\r\nint err;\r\nerr = chmap->ops.pin_set_slot_channel(chmap->hdac,\r\npin_nid, hdmi_slot, assignments[hdmi_slot]);\r\nif (err)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hdmi_setup_fake_chmap(unsigned char *map, int ca)\r\n{\r\nint i;\r\nint ordered_ca = get_channel_allocation_order(ca);\r\nfor (i = 0; i < 8; i++) {\r\nif (ordered_ca < ARRAY_SIZE(channel_allocations) &&\r\ni < channel_allocations[ordered_ca].channels)\r\nmap[i] = from_cea_slot(ordered_ca, hdmi_channel_mapping[ca][i] & 0x0f);\r\nelse\r\nmap[i] = 0;\r\n}\r\n}\r\nvoid snd_hdac_setup_channel_mapping(struct hdac_chmap *chmap,\r\nhda_nid_t pin_nid, bool non_pcm, int ca,\r\nint channels, unsigned char *map,\r\nbool chmap_set)\r\n{\r\nif (!non_pcm && chmap_set) {\r\nhdmi_manual_setup_channel_mapping(chmap, pin_nid,\r\nchannels, map, ca);\r\n} else {\r\nhdmi_std_setup_channel_mapping(chmap, pin_nid, non_pcm, ca);\r\nhdmi_setup_fake_chmap(map, ca);\r\n}\r\nhdmi_debug_channel_mapping(chmap, pin_nid);\r\n}\r\nint snd_hdac_get_active_channels(int ca)\r\n{\r\nint ordered_ca = get_channel_allocation_order(ca);\r\nif (ordered_ca >= ARRAY_SIZE(channel_allocations))\r\nordered_ca = 0;\r\nreturn channel_allocations[ordered_ca].channels;\r\n}\r\nstruct hdac_cea_channel_speaker_allocation *snd_hdac_get_ch_alloc_from_ca(int ca)\r\n{\r\nreturn &channel_allocations[get_channel_allocation_order(ca)];\r\n}\r\nint snd_hdac_channel_allocation(struct hdac_device *hdac, int spk_alloc,\r\nint channels, bool chmap_set, bool non_pcm, unsigned char *map)\r\n{\r\nint ca;\r\nif (!non_pcm && chmap_set)\r\nca = hdmi_manual_channel_allocation(channels, map);\r\nelse\r\nca = hdmi_channel_allocation_spk_alloc_blk(hdac,\r\nspk_alloc, channels);\r\nif (ca < 0)\r\nca = 0;\r\nreturn ca;\r\n}\r\nstatic int hdmi_chmap_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct hdac_chmap *chmap = info->private_data;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chmap->channels_max;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = SNDRV_CHMAP_LAST;\r\nreturn 0;\r\n}\r\nstatic int hdmi_chmap_cea_alloc_validate_get_type(struct hdac_chmap *chmap,\r\nstruct hdac_cea_channel_speaker_allocation *cap, int channels)\r\n{\r\nif (cap->channels != channels)\r\nreturn -1;\r\nreturn SNDRV_CTL_TLVT_CHMAP_VAR;\r\n}\r\nstatic void hdmi_cea_alloc_to_tlv_chmap(struct hdac_chmap *hchmap,\r\nstruct hdac_cea_channel_speaker_allocation *cap,\r\nunsigned int *chmap, int channels)\r\n{\r\nint count = 0;\r\nint c;\r\nfor (c = 7; c >= 0; c--) {\r\nint spk = cap->speakers[c];\r\nif (!spk)\r\ncontinue;\r\nchmap[count++] = snd_hdac_spk_to_chmap(spk);\r\n}\r\nWARN_ON(count != channels);\r\n}\r\nstatic int spk_mask_from_spk_alloc(int spk_alloc)\r\n{\r\nint i;\r\nint spk_mask = eld_speaker_allocation_bits[0];\r\nfor (i = 0; i < ARRAY_SIZE(eld_speaker_allocation_bits); i++) {\r\nif (spk_alloc & (1 << i))\r\nspk_mask |= eld_speaker_allocation_bits[i];\r\n}\r\nreturn spk_mask;\r\n}\r\nstatic int hdmi_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct hdac_chmap *chmap = info->private_data;\r\nint pcm_idx = kcontrol->private_value;\r\nunsigned int __user *dst;\r\nint chs, count = 0;\r\nunsigned long max_chs;\r\nint type;\r\nint spk_alloc, spk_mask;\r\nif (size < 8)\r\nreturn -ENOMEM;\r\nif (put_user(SNDRV_CTL_TLVT_CONTAINER, tlv))\r\nreturn -EFAULT;\r\nsize -= 8;\r\ndst = tlv + 2;\r\nspk_alloc = chmap->ops.get_spk_alloc(chmap->hdac, pcm_idx);\r\nspk_mask = spk_mask_from_spk_alloc(spk_alloc);\r\nmax_chs = hweight_long(spk_mask);\r\nfor (chs = 2; chs <= max_chs; chs++) {\r\nint i;\r\nstruct hdac_cea_channel_speaker_allocation *cap;\r\ncap = channel_allocations;\r\nfor (i = 0; i < ARRAY_SIZE(channel_allocations); i++, cap++) {\r\nint chs_bytes = chs * 4;\r\nunsigned int tlv_chmap[8];\r\nif (cap->channels != chs)\r\ncontinue;\r\nif (!(cap->spk_mask == (spk_mask & cap->spk_mask)))\r\ncontinue;\r\ntype = chmap->ops.chmap_cea_alloc_validate_get_type(\r\nchmap, cap, chs);\r\nif (type < 0)\r\nreturn -ENODEV;\r\nif (size < 8)\r\nreturn -ENOMEM;\r\nif (put_user(type, dst) ||\r\nput_user(chs_bytes, dst + 1))\r\nreturn -EFAULT;\r\ndst += 2;\r\nsize -= 8;\r\ncount += 8;\r\nif (size < chs_bytes)\r\nreturn -ENOMEM;\r\nsize -= chs_bytes;\r\ncount += chs_bytes;\r\nchmap->ops.cea_alloc_to_tlv_chmap(chmap, cap,\r\ntlv_chmap, chs);\r\nif (copy_to_user(dst, tlv_chmap, chs_bytes))\r\nreturn -EFAULT;\r\ndst += chs;\r\n}\r\n}\r\nif (put_user(count, tlv + 1))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int hdmi_chmap_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct hdac_chmap *chmap = info->private_data;\r\nint pcm_idx = kcontrol->private_value;\r\nunsigned char pcm_chmap[8];\r\nint i;\r\nmemset(pcm_chmap, 0, sizeof(pcm_chmap));\r\nchmap->ops.get_chmap(chmap->hdac, pcm_idx, pcm_chmap);\r\nfor (i = 0; i < sizeof(chmap); i++)\r\nucontrol->value.integer.value[i] = pcm_chmap[i];\r\nreturn 0;\r\n}\r\nstatic int hdmi_chmap_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct hdac_chmap *hchmap = info->private_data;\r\nint pcm_idx = kcontrol->private_value;\r\nunsigned int ctl_idx;\r\nstruct snd_pcm_substream *substream;\r\nunsigned char chmap[8], per_pin_chmap[8];\r\nint i, err, ca, prepared = 0;\r\nif (!hchmap->ops.is_pcm_attached(hchmap->hdac, pcm_idx))\r\nreturn 0;\r\nctl_idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nsubstream = snd_pcm_chmap_substream(info, ctl_idx);\r\nif (!substream || !substream->runtime)\r\nreturn 0;\r\nswitch (substream->runtime->status->state) {\r\ncase SNDRV_PCM_STATE_OPEN:\r\ncase SNDRV_PCM_STATE_SETUP:\r\nbreak;\r\ncase SNDRV_PCM_STATE_PREPARED:\r\nprepared = 1;\r\nbreak;\r\ndefault:\r\nreturn -EBUSY;\r\n}\r\nmemset(chmap, 0, sizeof(chmap));\r\nfor (i = 0; i < ARRAY_SIZE(chmap); i++)\r\nchmap[i] = ucontrol->value.integer.value[i];\r\nhchmap->ops.get_chmap(hchmap->hdac, pcm_idx, per_pin_chmap);\r\nif (!memcmp(chmap, per_pin_chmap, sizeof(chmap)))\r\nreturn 0;\r\nca = hdmi_manual_channel_allocation(ARRAY_SIZE(chmap), chmap);\r\nif (ca < 0)\r\nreturn -EINVAL;\r\nif (hchmap->ops.chmap_validate) {\r\nerr = hchmap->ops.chmap_validate(hchmap, ca,\r\nARRAY_SIZE(chmap), chmap);\r\nif (err)\r\nreturn err;\r\n}\r\nhchmap->ops.set_chmap(hchmap->hdac, pcm_idx, chmap, prepared);\r\nreturn 0;\r\n}\r\nvoid snd_hdac_register_chmap_ops(struct hdac_device *hdac,\r\nstruct hdac_chmap *chmap)\r\n{\r\nchmap->ops = chmap_ops;\r\nchmap->hdac = hdac;\r\ninit_channel_allocations();\r\n}\r\nint snd_hdac_add_chmap_ctls(struct snd_pcm *pcm, int pcm_idx,\r\nstruct hdac_chmap *hchmap)\r\n{\r\nstruct snd_pcm_chmap *chmap;\r\nstruct snd_kcontrol *kctl;\r\nint err, i;\r\nerr = snd_pcm_add_chmap_ctls(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK,\r\nNULL, 0, pcm_idx, &chmap);\r\nif (err < 0)\r\nreturn err;\r\nchmap->private_data = hchmap;\r\nkctl = chmap->kctl;\r\nfor (i = 0; i < kctl->count; i++)\r\nkctl->vd[i].access |= SNDRV_CTL_ELEM_ACCESS_WRITE;\r\nkctl->info = hdmi_chmap_ctl_info;\r\nkctl->get = hdmi_chmap_ctl_get;\r\nkctl->put = hdmi_chmap_ctl_put;\r\nkctl->tlv.c = hdmi_chmap_ctl_tlv;\r\nreturn 0;\r\n}
