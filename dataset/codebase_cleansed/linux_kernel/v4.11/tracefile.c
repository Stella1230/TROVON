static inline struct cfs_trace_page *\r\ncfs_tage_from_list(struct list_head *list)\r\n{\r\nreturn list_entry(list, struct cfs_trace_page, linkage);\r\n}\r\nstatic struct cfs_trace_page *cfs_tage_alloc(gfp_t gfp)\r\n{\r\nstruct page *page;\r\nstruct cfs_trace_page *tage;\r\nif (!in_interrupt() && memory_pressure_get())\r\nreturn NULL;\r\ngfp |= __GFP_NOWARN;\r\npage = alloc_page(gfp);\r\nif (!page)\r\nreturn NULL;\r\ntage = kmalloc(sizeof(*tage), gfp);\r\nif (!tage) {\r\n__free_page(page);\r\nreturn NULL;\r\n}\r\ntage->page = page;\r\natomic_inc(&cfs_tage_allocated);\r\nreturn tage;\r\n}\r\nstatic void cfs_tage_free(struct cfs_trace_page *tage)\r\n{\r\n__free_page(tage->page);\r\nkfree(tage);\r\natomic_dec(&cfs_tage_allocated);\r\n}\r\nstatic void cfs_tage_to_tail(struct cfs_trace_page *tage,\r\nstruct list_head *queue)\r\n{\r\nlist_move_tail(&tage->linkage, queue);\r\n}\r\nint cfs_trace_refill_stock(struct cfs_trace_cpu_data *tcd, gfp_t gfp,\r\nstruct list_head *stock)\r\n{\r\nint i;\r\nfor (i = 0; i + tcd->tcd_cur_stock_pages < TCD_STOCK_PAGES ; ++i) {\r\nstruct cfs_trace_page *tage;\r\ntage = cfs_tage_alloc(gfp);\r\nif (!tage)\r\nbreak;\r\nlist_add_tail(&tage->linkage, stock);\r\n}\r\nreturn i;\r\n}\r\nstatic struct cfs_trace_page *\r\ncfs_trace_get_tage_try(struct cfs_trace_cpu_data *tcd, unsigned long len)\r\n{\r\nstruct cfs_trace_page *tage;\r\nif (tcd->tcd_cur_pages > 0) {\r\n__LASSERT(!list_empty(&tcd->tcd_pages));\r\ntage = cfs_tage_from_list(tcd->tcd_pages.prev);\r\nif (tage->used + len <= PAGE_SIZE)\r\nreturn tage;\r\n}\r\nif (tcd->tcd_cur_pages < tcd->tcd_max_pages) {\r\nif (tcd->tcd_cur_stock_pages > 0) {\r\ntage = cfs_tage_from_list(tcd->tcd_stock_pages.prev);\r\n--tcd->tcd_cur_stock_pages;\r\nlist_del_init(&tage->linkage);\r\n} else {\r\ntage = cfs_tage_alloc(GFP_ATOMIC);\r\nif (unlikely(!tage)) {\r\nif ((!memory_pressure_get() ||\r\nin_interrupt()) && printk_ratelimit())\r\nprintk(KERN_WARNING\r\n"cannot allocate a tage (%ld)\n",\r\ntcd->tcd_cur_pages);\r\nreturn NULL;\r\n}\r\n}\r\ntage->used = 0;\r\ntage->cpu = smp_processor_id();\r\ntage->type = tcd->tcd_type;\r\nlist_add_tail(&tage->linkage, &tcd->tcd_pages);\r\ntcd->tcd_cur_pages++;\r\nif (tcd->tcd_cur_pages > 8 && thread_running) {\r\nstruct tracefiled_ctl *tctl = &trace_tctl;\r\nwake_up(&tctl->tctl_waitq);\r\n}\r\nreturn tage;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void cfs_tcd_shrink(struct cfs_trace_cpu_data *tcd)\r\n{\r\nint pgcount = tcd->tcd_cur_pages / 10;\r\nstruct page_collection pc;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\nif (printk_ratelimit())\r\nprintk(KERN_WARNING "debug daemon buffer overflowed; discarding 10%% of pages (%d of %ld)\n",\r\npgcount + 1, tcd->tcd_cur_pages);\r\nINIT_LIST_HEAD(&pc.pc_pages);\r\nlist_for_each_entry_safe(tage, tmp, &tcd->tcd_pages, linkage) {\r\nif (!pgcount--)\r\nbreak;\r\nlist_move_tail(&tage->linkage, &pc.pc_pages);\r\ntcd->tcd_cur_pages--;\r\n}\r\nput_pages_on_tcd_daemon_list(&pc, tcd);\r\n}\r\nstatic struct cfs_trace_page *cfs_trace_get_tage(struct cfs_trace_cpu_data *tcd,\r\nunsigned long len)\r\n{\r\nstruct cfs_trace_page *tage;\r\nif (len > PAGE_SIZE) {\r\npr_err("cowardly refusing to write %lu bytes in a page\n", len);\r\nreturn NULL;\r\n}\r\ntage = cfs_trace_get_tage_try(tcd, len);\r\nif (tage)\r\nreturn tage;\r\nif (thread_running)\r\ncfs_tcd_shrink(tcd);\r\nif (tcd->tcd_cur_pages > 0) {\r\ntage = cfs_tage_from_list(tcd->tcd_pages.next);\r\ntage->used = 0;\r\ncfs_tage_to_tail(tage, &tcd->tcd_pages);\r\n}\r\nreturn tage;\r\n}\r\nint libcfs_debug_msg(struct libcfs_debug_msg_data *msgdata,\r\nconst char *format, ...)\r\n{\r\nva_list args;\r\nint rc;\r\nva_start(args, format);\r\nrc = libcfs_debug_vmsg2(msgdata, format, args, NULL);\r\nva_end(args);\r\nreturn rc;\r\n}\r\nint libcfs_debug_vmsg2(struct libcfs_debug_msg_data *msgdata,\r\nconst char *format1, va_list args,\r\nconst char *format2, ...)\r\n{\r\nstruct cfs_trace_cpu_data *tcd = NULL;\r\nstruct ptldebug_header header = { 0 };\r\nstruct cfs_trace_page *tage;\r\nchar *string_buf = NULL;\r\nchar *debug_buf;\r\nint known_size;\r\nint needed = 85;\r\nint max_nob;\r\nva_list ap;\r\nint depth;\r\nint i;\r\nint remain;\r\nint mask = msgdata->msg_mask;\r\nconst char *file = kbasename(msgdata->msg_file);\r\nstruct cfs_debug_limit_state *cdls = msgdata->msg_cdls;\r\ntcd = cfs_trace_get_tcd();\r\ncfs_set_ptldebug_header(&header, msgdata, CDEBUG_STACK());\r\nif (!tcd)\r\ngoto console;\r\nif (!tcd->tcd_cur_pages)\r\nheader.ph_flags |= PH_FLAG_FIRST_RECORD;\r\nif (tcd->tcd_shutting_down) {\r\ncfs_trace_put_tcd(tcd);\r\ntcd = NULL;\r\ngoto console;\r\n}\r\ndepth = __current_nesting_level();\r\nknown_size = strlen(file) + 1 + depth;\r\nif (msgdata->msg_fn)\r\nknown_size += strlen(msgdata->msg_fn) + 1;\r\nif (libcfs_debug_binary)\r\nknown_size += sizeof(header);\r\nfor (i = 0; i < 2; i++) {\r\ntage = cfs_trace_get_tage(tcd, needed + known_size + 1);\r\nif (!tage) {\r\nif (needed + known_size > PAGE_SIZE)\r\nmask |= D_ERROR;\r\ncfs_trace_put_tcd(tcd);\r\ntcd = NULL;\r\ngoto console;\r\n}\r\nstring_buf = (char *)page_address(tage->page) +\r\ntage->used + known_size;\r\nmax_nob = PAGE_SIZE - tage->used - known_size;\r\nif (max_nob <= 0) {\r\nprintk(KERN_EMERG "negative max_nob: %d\n",\r\nmax_nob);\r\nmask |= D_ERROR;\r\ncfs_trace_put_tcd(tcd);\r\ntcd = NULL;\r\ngoto console;\r\n}\r\nneeded = 0;\r\nif (format1) {\r\nva_copy(ap, args);\r\nneeded = vsnprintf(string_buf, max_nob, format1, ap);\r\nva_end(ap);\r\n}\r\nif (format2) {\r\nremain = max_nob - needed;\r\nif (remain < 0)\r\nremain = 0;\r\nva_start(ap, format2);\r\nneeded += vsnprintf(string_buf + needed, remain,\r\nformat2, ap);\r\nva_end(ap);\r\n}\r\nif (needed < max_nob)\r\nbreak;\r\n}\r\nif (*(string_buf + needed - 1) != '\n')\r\nprintk(KERN_INFO "format at %s:%d:%s doesn't end in newline\n",\r\nfile, msgdata->msg_line, msgdata->msg_fn);\r\nheader.ph_len = known_size + needed;\r\ndebug_buf = (char *)page_address(tage->page) + tage->used;\r\nif (libcfs_debug_binary) {\r\nmemcpy(debug_buf, &header, sizeof(header));\r\ntage->used += sizeof(header);\r\ndebug_buf += sizeof(header);\r\n}\r\nwhile (depth-- > 0) {\r\n*(debug_buf++) = '.';\r\n++tage->used;\r\n}\r\nstrcpy(debug_buf, file);\r\ntage->used += strlen(file) + 1;\r\ndebug_buf += strlen(file) + 1;\r\nif (msgdata->msg_fn) {\r\nstrcpy(debug_buf, msgdata->msg_fn);\r\ntage->used += strlen(msgdata->msg_fn) + 1;\r\ndebug_buf += strlen(msgdata->msg_fn) + 1;\r\n}\r\n__LASSERT(debug_buf == string_buf);\r\ntage->used += needed;\r\n__LASSERT(tage->used <= PAGE_SIZE);\r\nconsole:\r\nif (!(mask & libcfs_printk)) {\r\nif (tcd)\r\ncfs_trace_put_tcd(tcd);\r\nreturn 1;\r\n}\r\nif (cdls) {\r\nif (libcfs_console_ratelimit &&\r\ncdls->cdls_next &&\r\n!cfs_time_after(cfs_time_current(), cdls->cdls_next)) {\r\ncdls->cdls_count++;\r\nif (tcd)\r\ncfs_trace_put_tcd(tcd);\r\nreturn 1;\r\n}\r\nif (cfs_time_after(cfs_time_current(),\r\ncdls->cdls_next + libcfs_console_max_delay +\r\ncfs_time_seconds(10))) {\r\ncdls->cdls_delay /= libcfs_console_backoff * 4;\r\n} else {\r\ncdls->cdls_delay *= libcfs_console_backoff;\r\n}\r\nif (cdls->cdls_delay < libcfs_console_min_delay)\r\ncdls->cdls_delay = libcfs_console_min_delay;\r\nelse if (cdls->cdls_delay > libcfs_console_max_delay)\r\ncdls->cdls_delay = libcfs_console_max_delay;\r\ncdls->cdls_next = (cfs_time_current() + cdls->cdls_delay) | 1;\r\n}\r\nif (tcd) {\r\ncfs_print_to_console(&header, mask, string_buf, needed, file,\r\nmsgdata->msg_fn);\r\ncfs_trace_put_tcd(tcd);\r\n} else {\r\nstring_buf = cfs_trace_get_console_buffer();\r\nneeded = 0;\r\nif (format1) {\r\nva_copy(ap, args);\r\nneeded = vsnprintf(string_buf,\r\nCFS_TRACE_CONSOLE_BUFFER_SIZE,\r\nformat1, ap);\r\nva_end(ap);\r\n}\r\nif (format2) {\r\nremain = CFS_TRACE_CONSOLE_BUFFER_SIZE - needed;\r\nif (remain > 0) {\r\nva_start(ap, format2);\r\nneeded += vsnprintf(string_buf + needed, remain,\r\nformat2, ap);\r\nva_end(ap);\r\n}\r\n}\r\ncfs_print_to_console(&header, mask,\r\nstring_buf, needed, file, msgdata->msg_fn);\r\nput_cpu();\r\n}\r\nif (cdls && cdls->cdls_count) {\r\nstring_buf = cfs_trace_get_console_buffer();\r\nneeded = snprintf(string_buf, CFS_TRACE_CONSOLE_BUFFER_SIZE,\r\n"Skipped %d previous similar message%s\n",\r\ncdls->cdls_count,\r\n(cdls->cdls_count > 1) ? "s" : "");\r\ncfs_print_to_console(&header, mask,\r\nstring_buf, needed, file, msgdata->msg_fn);\r\nput_cpu();\r\ncdls->cdls_count = 0;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\ncfs_trace_assertion_failed(const char *str,\r\nstruct libcfs_debug_msg_data *msgdata)\r\n{\r\nstruct ptldebug_header hdr;\r\nlibcfs_panic_in_progress = 1;\r\nlibcfs_catastrophe = 1;\r\nmb();\r\ncfs_set_ptldebug_header(&hdr, msgdata, CDEBUG_STACK());\r\ncfs_print_to_console(&hdr, D_EMERG, str, strlen(str),\r\nmsgdata->msg_file, msgdata->msg_fn);\r\npanic("Lustre debug assertion failure\n");\r\n}\r\nstatic void\r\npanic_collect_pages(struct page_collection *pc)\r\n{\r\nstruct cfs_trace_cpu_data *tcd;\r\nint i;\r\nint j;\r\nINIT_LIST_HEAD(&pc->pc_pages);\r\ncfs_tcd_for_each(tcd, i, j) {\r\nlist_splice_init(&tcd->tcd_pages, &pc->pc_pages);\r\ntcd->tcd_cur_pages = 0;\r\nif (pc->pc_want_daemon_pages) {\r\nlist_splice_init(&tcd->tcd_daemon_pages, &pc->pc_pages);\r\ntcd->tcd_cur_daemon_pages = 0;\r\n}\r\n}\r\n}\r\nstatic void collect_pages_on_all_cpus(struct page_collection *pc)\r\n{\r\nstruct cfs_trace_cpu_data *tcd;\r\nint i, cpu;\r\nfor_each_possible_cpu(cpu) {\r\ncfs_tcd_for_each_type_lock(tcd, i, cpu) {\r\nlist_splice_init(&tcd->tcd_pages, &pc->pc_pages);\r\ntcd->tcd_cur_pages = 0;\r\nif (pc->pc_want_daemon_pages) {\r\nlist_splice_init(&tcd->tcd_daemon_pages,\r\n&pc->pc_pages);\r\ntcd->tcd_cur_daemon_pages = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic void collect_pages(struct page_collection *pc)\r\n{\r\nINIT_LIST_HEAD(&pc->pc_pages);\r\nif (libcfs_panic_in_progress)\r\npanic_collect_pages(pc);\r\nelse\r\ncollect_pages_on_all_cpus(pc);\r\n}\r\nstatic void put_pages_back_on_all_cpus(struct page_collection *pc)\r\n{\r\nstruct cfs_trace_cpu_data *tcd;\r\nstruct list_head *cur_head;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\nint i, cpu;\r\nfor_each_possible_cpu(cpu) {\r\ncfs_tcd_for_each_type_lock(tcd, i, cpu) {\r\ncur_head = tcd->tcd_pages.next;\r\nlist_for_each_entry_safe(tage, tmp, &pc->pc_pages,\r\nlinkage) {\r\n__LASSERT_TAGE_INVARIANT(tage);\r\nif (tage->cpu != cpu || tage->type != i)\r\ncontinue;\r\ncfs_tage_to_tail(tage, cur_head);\r\ntcd->tcd_cur_pages++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void put_pages_back(struct page_collection *pc)\r\n{\r\nif (!libcfs_panic_in_progress)\r\nput_pages_back_on_all_cpus(pc);\r\n}\r\nstatic void put_pages_on_tcd_daemon_list(struct page_collection *pc,\r\nstruct cfs_trace_cpu_data *tcd)\r\n{\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\nlist_for_each_entry_safe(tage, tmp, &pc->pc_pages, linkage) {\r\n__LASSERT_TAGE_INVARIANT(tage);\r\nif (tage->cpu != tcd->tcd_cpu || tage->type != tcd->tcd_type)\r\ncontinue;\r\ncfs_tage_to_tail(tage, &tcd->tcd_daemon_pages);\r\ntcd->tcd_cur_daemon_pages++;\r\nif (tcd->tcd_cur_daemon_pages > tcd->tcd_max_pages) {\r\nstruct cfs_trace_page *victim;\r\n__LASSERT(!list_empty(&tcd->tcd_daemon_pages));\r\nvictim = cfs_tage_from_list(tcd->tcd_daemon_pages.next);\r\n__LASSERT_TAGE_INVARIANT(victim);\r\nlist_del(&victim->linkage);\r\ncfs_tage_free(victim);\r\ntcd->tcd_cur_daemon_pages--;\r\n}\r\n}\r\n}\r\nstatic void put_pages_on_daemon_list(struct page_collection *pc)\r\n{\r\nstruct cfs_trace_cpu_data *tcd;\r\nint i, cpu;\r\nfor_each_possible_cpu(cpu) {\r\ncfs_tcd_for_each_type_lock(tcd, i, cpu)\r\nput_pages_on_tcd_daemon_list(pc, tcd);\r\n}\r\n}\r\nvoid cfs_trace_debug_print(void)\r\n{\r\nstruct page_collection pc;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\npc.pc_want_daemon_pages = 1;\r\ncollect_pages(&pc);\r\nlist_for_each_entry_safe(tage, tmp, &pc.pc_pages, linkage) {\r\nchar *p, *file, *fn;\r\nstruct page *page;\r\n__LASSERT_TAGE_INVARIANT(tage);\r\npage = tage->page;\r\np = page_address(page);\r\nwhile (p < ((char *)page_address(page) + tage->used)) {\r\nstruct ptldebug_header *hdr;\r\nint len;\r\nhdr = (void *)p;\r\np += sizeof(*hdr);\r\nfile = p;\r\np += strlen(file) + 1;\r\nfn = p;\r\np += strlen(fn) + 1;\r\nlen = hdr->ph_len - (int)(p - (char *)hdr);\r\ncfs_print_to_console(hdr, D_EMERG, p, len, file, fn);\r\np += len;\r\n}\r\nlist_del(&tage->linkage);\r\ncfs_tage_free(tage);\r\n}\r\n}\r\nint cfs_tracefile_dump_all_pages(char *filename)\r\n{\r\nstruct page_collection pc;\r\nstruct file *filp;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\nchar *buf;\r\nmm_segment_t __oldfs;\r\nint rc;\r\ncfs_tracefile_write_lock();\r\nfilp = filp_open(filename, O_CREAT | O_EXCL | O_WRONLY | O_LARGEFILE,\r\n0600);\r\nif (IS_ERR(filp)) {\r\nrc = PTR_ERR(filp);\r\nfilp = NULL;\r\npr_err("LustreError: can't open %s for dump: rc %d\n",\r\nfilename, rc);\r\ngoto out;\r\n}\r\npc.pc_want_daemon_pages = 1;\r\ncollect_pages(&pc);\r\nif (list_empty(&pc.pc_pages)) {\r\nrc = 0;\r\ngoto close;\r\n}\r\n__oldfs = get_fs();\r\nset_fs(get_ds());\r\nlist_for_each_entry_safe(tage, tmp, &pc.pc_pages, linkage) {\r\n__LASSERT_TAGE_INVARIANT(tage);\r\nbuf = kmap(tage->page);\r\nrc = vfs_write(filp, (__force const char __user *)buf,\r\ntage->used, &filp->f_pos);\r\nkunmap(tage->page);\r\nif (rc != (int)tage->used) {\r\nprintk(KERN_WARNING "wanted to write %u but wrote %d\n",\r\ntage->used, rc);\r\nput_pages_back(&pc);\r\n__LASSERT(list_empty(&pc.pc_pages));\r\nbreak;\r\n}\r\nlist_del(&tage->linkage);\r\ncfs_tage_free(tage);\r\n}\r\nset_fs(__oldfs);\r\nrc = vfs_fsync(filp, 1);\r\nif (rc)\r\npr_err("sync returns %d\n", rc);\r\nclose:\r\nfilp_close(filp, NULL);\r\nout:\r\ncfs_tracefile_write_unlock();\r\nreturn rc;\r\n}\r\nvoid cfs_trace_flush_pages(void)\r\n{\r\nstruct page_collection pc;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\npc.pc_want_daemon_pages = 1;\r\ncollect_pages(&pc);\r\nlist_for_each_entry_safe(tage, tmp, &pc.pc_pages, linkage) {\r\n__LASSERT_TAGE_INVARIANT(tage);\r\nlist_del(&tage->linkage);\r\ncfs_tage_free(tage);\r\n}\r\n}\r\nint cfs_trace_copyin_string(char *knl_buffer, int knl_buffer_nob,\r\nconst char __user *usr_buffer, int usr_buffer_nob)\r\n{\r\nint nob;\r\nif (usr_buffer_nob > knl_buffer_nob)\r\nreturn -EOVERFLOW;\r\nif (copy_from_user((void *)knl_buffer,\r\nusr_buffer, usr_buffer_nob))\r\nreturn -EFAULT;\r\nnob = strnlen(knl_buffer, usr_buffer_nob);\r\nwhile (nob-- >= 0)\r\nif (!isspace(knl_buffer[nob]))\r\nbreak;\r\nif (nob < 0)\r\nreturn -EINVAL;\r\nif (nob == knl_buffer_nob)\r\nreturn -EOVERFLOW;\r\nknl_buffer[nob + 1] = 0;\r\nreturn 0;\r\n}\r\nint cfs_trace_copyout_string(char __user *usr_buffer, int usr_buffer_nob,\r\nconst char *knl_buffer, char *append)\r\n{\r\nint nob = strlen(knl_buffer);\r\nif (nob > usr_buffer_nob)\r\nnob = usr_buffer_nob;\r\nif (copy_to_user(usr_buffer, knl_buffer, nob))\r\nreturn -EFAULT;\r\nif (append && nob < usr_buffer_nob) {\r\nif (copy_to_user(usr_buffer + nob, append, 1))\r\nreturn -EFAULT;\r\nnob++;\r\n}\r\nreturn nob;\r\n}\r\nint cfs_trace_allocate_string_buffer(char **str, int nob)\r\n{\r\nif (nob > 2 * PAGE_SIZE)\r\nreturn -EINVAL;\r\n*str = kmalloc(nob, GFP_KERNEL | __GFP_ZERO);\r\nif (!*str)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint cfs_trace_dump_debug_buffer_usrstr(void __user *usr_str, int usr_str_nob)\r\n{\r\nchar *str;\r\nint rc;\r\nrc = cfs_trace_allocate_string_buffer(&str, usr_str_nob + 1);\r\nif (rc)\r\nreturn rc;\r\nrc = cfs_trace_copyin_string(str, usr_str_nob + 1,\r\nusr_str, usr_str_nob);\r\nif (rc)\r\ngoto out;\r\nif (str[0] != '/') {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = cfs_tracefile_dump_all_pages(str);\r\nout:\r\nkfree(str);\r\nreturn rc;\r\n}\r\nint cfs_trace_daemon_command(char *str)\r\n{\r\nint rc = 0;\r\ncfs_tracefile_write_lock();\r\nif (!strcmp(str, "stop")) {\r\ncfs_tracefile_write_unlock();\r\ncfs_trace_stop_thread();\r\ncfs_tracefile_write_lock();\r\nmemset(cfs_tracefile, 0, sizeof(cfs_tracefile));\r\n} else if (!strncmp(str, "size=", 5)) {\r\nunsigned long tmp;\r\nrc = kstrtoul(str + 5, 10, &tmp);\r\nif (!rc) {\r\nif (tmp < 10 || tmp > 20480)\r\ncfs_tracefile_size = CFS_TRACEFILE_SIZE;\r\nelse\r\ncfs_tracefile_size = tmp << 20;\r\n}\r\n} else if (strlen(str) >= sizeof(cfs_tracefile)) {\r\nrc = -ENAMETOOLONG;\r\n} else if (str[0] != '/') {\r\nrc = -EINVAL;\r\n} else {\r\nstrcpy(cfs_tracefile, str);\r\nprintk(KERN_INFO\r\n"Lustre: debug daemon will attempt to start writing to %s (%lukB max)\n",\r\ncfs_tracefile,\r\n(long)(cfs_tracefile_size >> 10));\r\ncfs_trace_start_thread();\r\n}\r\ncfs_tracefile_write_unlock();\r\nreturn rc;\r\n}\r\nint cfs_trace_daemon_command_usrstr(void __user *usr_str, int usr_str_nob)\r\n{\r\nchar *str;\r\nint rc;\r\nrc = cfs_trace_allocate_string_buffer(&str, usr_str_nob + 1);\r\nif (rc)\r\nreturn rc;\r\nrc = cfs_trace_copyin_string(str, usr_str_nob + 1,\r\nusr_str, usr_str_nob);\r\nif (!rc)\r\nrc = cfs_trace_daemon_command(str);\r\nkfree(str);\r\nreturn rc;\r\n}\r\nint cfs_trace_set_debug_mb(int mb)\r\n{\r\nint i;\r\nint j;\r\nint pages;\r\nint limit = cfs_trace_max_debug_mb();\r\nstruct cfs_trace_cpu_data *tcd;\r\nif (mb < num_possible_cpus()) {\r\nprintk(KERN_WARNING\r\n"Lustre: %d MB is too small for debug buffer size, setting it to %d MB.\n",\r\nmb, num_possible_cpus());\r\nmb = num_possible_cpus();\r\n}\r\nif (mb > limit) {\r\nprintk(KERN_WARNING\r\n"Lustre: %d MB is too large for debug buffer size, setting it to %d MB.\n",\r\nmb, limit);\r\nmb = limit;\r\n}\r\nmb /= num_possible_cpus();\r\npages = mb << (20 - PAGE_SHIFT);\r\ncfs_tracefile_write_lock();\r\ncfs_tcd_for_each(tcd, i, j)\r\ntcd->tcd_max_pages = (pages * tcd->tcd_pages_factor) / 100;\r\ncfs_tracefile_write_unlock();\r\nreturn 0;\r\n}\r\nint cfs_trace_get_debug_mb(void)\r\n{\r\nint i;\r\nint j;\r\nstruct cfs_trace_cpu_data *tcd;\r\nint total_pages = 0;\r\ncfs_tracefile_read_lock();\r\ncfs_tcd_for_each(tcd, i, j)\r\ntotal_pages += tcd->tcd_max_pages;\r\ncfs_tracefile_read_unlock();\r\nreturn (total_pages >> (20 - PAGE_SHIFT)) + 1;\r\n}\r\nstatic int tracefiled(void *arg)\r\n{\r\nstruct page_collection pc;\r\nstruct tracefiled_ctl *tctl = arg;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\nmm_segment_t __oldfs;\r\nstruct file *filp;\r\nchar *buf;\r\nint last_loop = 0;\r\nint rc;\r\ncomplete(&tctl->tctl_start);\r\nwhile (1) {\r\nwait_queue_t __wait;\r\npc.pc_want_daemon_pages = 0;\r\ncollect_pages(&pc);\r\nif (list_empty(&pc.pc_pages))\r\ngoto end_loop;\r\nfilp = NULL;\r\ncfs_tracefile_read_lock();\r\nif (cfs_tracefile[0]) {\r\nfilp = filp_open(cfs_tracefile,\r\nO_CREAT | O_RDWR | O_LARGEFILE,\r\n0600);\r\nif (IS_ERR(filp)) {\r\nrc = PTR_ERR(filp);\r\nfilp = NULL;\r\nprintk(KERN_WARNING "couldn't open %s: %d\n",\r\ncfs_tracefile, rc);\r\n}\r\n}\r\ncfs_tracefile_read_unlock();\r\nif (!filp) {\r\nput_pages_on_daemon_list(&pc);\r\n__LASSERT(list_empty(&pc.pc_pages));\r\ngoto end_loop;\r\n}\r\n__oldfs = get_fs();\r\nset_fs(get_ds());\r\nlist_for_each_entry_safe(tage, tmp, &pc.pc_pages, linkage) {\r\nstatic loff_t f_pos;\r\n__LASSERT_TAGE_INVARIANT(tage);\r\nif (f_pos >= (off_t)cfs_tracefile_size)\r\nf_pos = 0;\r\nelse if (f_pos > i_size_read(file_inode(filp)))\r\nf_pos = i_size_read(file_inode(filp));\r\nbuf = kmap(tage->page);\r\nrc = vfs_write(filp, (__force const char __user *)buf,\r\ntage->used, &f_pos);\r\nkunmap(tage->page);\r\nif (rc != (int)tage->used) {\r\nprintk(KERN_WARNING "wanted to write %u but wrote %d\n",\r\ntage->used, rc);\r\nput_pages_back(&pc);\r\n__LASSERT(list_empty(&pc.pc_pages));\r\nbreak;\r\n}\r\n}\r\nset_fs(__oldfs);\r\nfilp_close(filp, NULL);\r\nput_pages_on_daemon_list(&pc);\r\nif (!list_empty(&pc.pc_pages)) {\r\nint i;\r\nprintk(KERN_ALERT "Lustre: trace pages aren't empty\n");\r\npr_err("total cpus(%d): ", num_possible_cpus());\r\nfor (i = 0; i < num_possible_cpus(); i++)\r\nif (cpu_online(i))\r\npr_cont("%d(on) ", i);\r\nelse\r\npr_cont("%d(off) ", i);\r\npr_cont("\n");\r\ni = 0;\r\nlist_for_each_entry_safe(tage, tmp, &pc.pc_pages,\r\nlinkage)\r\npr_err("page %d belongs to cpu %d\n",\r\n++i, tage->cpu);\r\npr_err("There are %d pages unwritten\n", i);\r\n}\r\n__LASSERT(list_empty(&pc.pc_pages));\r\nend_loop:\r\nif (atomic_read(&tctl->tctl_shutdown)) {\r\nif (!last_loop) {\r\nlast_loop = 1;\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\ninit_waitqueue_entry(&__wait, current);\r\nadd_wait_queue(&tctl->tctl_waitq, &__wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\nremove_wait_queue(&tctl->tctl_waitq, &__wait);\r\n}\r\ncomplete(&tctl->tctl_stop);\r\nreturn 0;\r\n}\r\nint cfs_trace_start_thread(void)\r\n{\r\nstruct tracefiled_ctl *tctl = &trace_tctl;\r\nstruct task_struct *task;\r\nint rc = 0;\r\nmutex_lock(&cfs_trace_thread_mutex);\r\nif (thread_running)\r\ngoto out;\r\ninit_completion(&tctl->tctl_start);\r\ninit_completion(&tctl->tctl_stop);\r\ninit_waitqueue_head(&tctl->tctl_waitq);\r\natomic_set(&tctl->tctl_shutdown, 0);\r\ntask = kthread_run(tracefiled, tctl, "ktracefiled");\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\ngoto out;\r\n}\r\nwait_for_completion(&tctl->tctl_start);\r\nthread_running = 1;\r\nout:\r\nmutex_unlock(&cfs_trace_thread_mutex);\r\nreturn rc;\r\n}\r\nvoid cfs_trace_stop_thread(void)\r\n{\r\nstruct tracefiled_ctl *tctl = &trace_tctl;\r\nmutex_lock(&cfs_trace_thread_mutex);\r\nif (thread_running) {\r\nprintk(KERN_INFO\r\n"Lustre: shutting down debug daemon thread...\n");\r\natomic_set(&tctl->tctl_shutdown, 1);\r\nwait_for_completion(&tctl->tctl_stop);\r\nthread_running = 0;\r\n}\r\nmutex_unlock(&cfs_trace_thread_mutex);\r\n}\r\nint cfs_tracefile_init(int max_pages)\r\n{\r\nstruct cfs_trace_cpu_data *tcd;\r\nint i;\r\nint j;\r\nint rc;\r\nint factor;\r\nrc = cfs_tracefile_init_arch();\r\nif (rc)\r\nreturn rc;\r\ncfs_tcd_for_each(tcd, i, j) {\r\nfactor = tcd->tcd_pages_factor;\r\nINIT_LIST_HEAD(&tcd->tcd_pages);\r\nINIT_LIST_HEAD(&tcd->tcd_stock_pages);\r\nINIT_LIST_HEAD(&tcd->tcd_daemon_pages);\r\ntcd->tcd_cur_pages = 0;\r\ntcd->tcd_cur_stock_pages = 0;\r\ntcd->tcd_cur_daemon_pages = 0;\r\ntcd->tcd_max_pages = (max_pages * factor) / 100;\r\nLASSERT(tcd->tcd_max_pages > 0);\r\ntcd->tcd_shutting_down = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void trace_cleanup_on_all_cpus(void)\r\n{\r\nstruct cfs_trace_cpu_data *tcd;\r\nstruct cfs_trace_page *tage;\r\nstruct cfs_trace_page *tmp;\r\nint i, cpu;\r\nfor_each_possible_cpu(cpu) {\r\ncfs_tcd_for_each_type_lock(tcd, i, cpu) {\r\ntcd->tcd_shutting_down = 1;\r\nlist_for_each_entry_safe(tage, tmp, &tcd->tcd_pages,\r\nlinkage) {\r\n__LASSERT_TAGE_INVARIANT(tage);\r\nlist_del(&tage->linkage);\r\ncfs_tage_free(tage);\r\n}\r\ntcd->tcd_cur_pages = 0;\r\n}\r\n}\r\n}\r\nstatic void cfs_trace_cleanup(void)\r\n{\r\nstruct page_collection pc;\r\nINIT_LIST_HEAD(&pc.pc_pages);\r\ntrace_cleanup_on_all_cpus();\r\ncfs_tracefile_fini_arch();\r\n}\r\nvoid cfs_tracefile_exit(void)\r\n{\r\ncfs_trace_stop_thread();\r\ncfs_trace_cleanup();\r\n}
