static int lola_init_pin(struct lola *chip, struct lola_pin *pin,\r\nint dir, int nid)\r\n{\r\nunsigned int val;\r\nint err;\r\npin->nid = nid;\r\nerr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);\r\nreturn err;\r\n}\r\nval &= 0x00f00fff;\r\nif (val == 0x00400200)\r\npin->is_analog = false;\r\nelse if (val == 0x0040000a && dir == CAPT)\r\npin->is_analog = true;\r\nelse if (val == 0x0040000c && dir == PLAY)\r\npin->is_analog = true;\r\nelse {\r\ndev_err(chip->card->dev, "Invalid wcaps 0x%x for 0x%x\n", val, nid);\r\nreturn -EINVAL;\r\n}\r\nif (!pin->is_analog)\r\nreturn 0;\r\nif (dir == PLAY)\r\nerr = lola_read_param(chip, nid, LOLA_PAR_AMP_OUT_CAP, &val);\r\nelse\r\nerr = lola_read_param(chip, nid, LOLA_PAR_AMP_IN_CAP, &val);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Can't read AMP-caps for 0x%x\n", nid);\r\nreturn err;\r\n}\r\npin->amp_mute = LOLA_AMP_MUTE_CAPABLE(val);\r\npin->amp_step_size = LOLA_AMP_STEP_SIZE(val);\r\npin->amp_num_steps = LOLA_AMP_NUM_STEPS(val);\r\nif (pin->amp_num_steps) {\r\npin->amp_num_steps++;\r\npin->amp_step_size++;\r\n}\r\npin->amp_offset = LOLA_AMP_OFFSET(val);\r\nerr = lola_codec_read(chip, nid, LOLA_VERB_GET_MAX_LEVEL, 0, 0, &val,\r\nNULL);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Can't get MAX_LEVEL 0x%x\n", nid);\r\nreturn err;\r\n}\r\npin->max_level = val & 0x3ff;\r\npin->config_default_reg = 0;\r\npin->fixed_gain_list_len = 0;\r\npin->cur_gain_step = 0;\r\nreturn 0;\r\n}\r\nint lola_init_pins(struct lola *chip, int dir, int *nidp)\r\n{\r\nint i, err, nid;\r\nnid = *nidp;\r\nfor (i = 0; i < chip->pin[dir].num_pins; i++, nid++) {\r\nerr = lola_init_pin(chip, &chip->pin[dir].pins[i], dir, nid);\r\nif (err < 0)\r\nreturn err;\r\nif (chip->pin[dir].pins[i].is_analog)\r\nchip->pin[dir].num_analog_pins++;\r\n}\r\n*nidp = nid;\r\nreturn 0;\r\n}\r\nvoid lola_free_mixer(struct lola *chip)\r\n{\r\nvfree(chip->mixer.array_saved);\r\n}\r\nint lola_init_mixer_widget(struct lola *chip, int nid)\r\n{\r\nunsigned int val;\r\nint err;\r\nerr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\r\nif (err < 0) {\r\ndev_err(chip->card->dev, "Can't read wcaps for 0x%x\n", nid);\r\nreturn err;\r\n}\r\nif ((val & 0xfff00000) != 0x02f00000) {\r\ndev_dbg(chip->card->dev, "No valid mixer widget\n");\r\nreturn 0;\r\n}\r\nchip->mixer.nid = nid;\r\nchip->mixer.caps = val;\r\nchip->mixer.array = (struct lola_mixer_array __iomem *)\r\n(chip->bar[BAR1].remap_addr + LOLA_BAR1_SOURCE_GAIN_ENABLE);\r\nchip->mixer.array_saved = vmalloc(sizeof(struct lola_mixer_array));\r\nchip->mixer.src_stream_outs = chip->pcm[PLAY].num_streams;\r\nchip->mixer.src_phys_ins = chip->pin[CAPT].num_pins;\r\nchip->mixer.dest_stream_ins = chip->pcm[CAPT].num_streams;\r\nchip->mixer.dest_phys_outs = chip->pin[PLAY].num_pins;\r\nchip->mixer.src_stream_out_ofs = chip->mixer.src_phys_ins +\r\nLOLA_MIXER_SRC_INPUT_PLAY_SEPARATION(val);\r\nchip->mixer.dest_phys_out_ofs = chip->mixer.dest_stream_ins +\r\nLOLA_MIXER_DEST_REC_OUTPUT_SEPARATION(val);\r\nif (chip->mixer.src_stream_out_ofs > MAX_AUDIO_INOUT_COUNT ||\r\nchip->mixer.dest_phys_out_ofs > MAX_STREAM_IN_COUNT) {\r\ndev_err(chip->card->dev, "Invalid mixer widget size\n");\r\nreturn -EINVAL;\r\n}\r\nchip->mixer.src_mask = ((1U << chip->mixer.src_phys_ins) - 1) |\r\n(((1U << chip->mixer.src_stream_outs) - 1)\r\n<< chip->mixer.src_stream_out_ofs);\r\nchip->mixer.dest_mask = ((1U << chip->mixer.dest_stream_ins) - 1) |\r\n(((1U << chip->mixer.dest_phys_outs) - 1)\r\n<< chip->mixer.dest_phys_out_ofs);\r\ndev_dbg(chip->card->dev, "Mixer src_mask=%x, dest_mask=%x\n",\r\nchip->mixer.src_mask, chip->mixer.dest_mask);\r\nreturn 0;\r\n}\r\nstatic int lola_mixer_set_src_gain(struct lola *chip, unsigned int id,\r\nunsigned short gain, bool on)\r\n{\r\nunsigned int oldval, val;\r\nif (!(chip->mixer.src_mask & (1 << id)))\r\nreturn -EINVAL;\r\noldval = val = readl(&chip->mixer.array->src_gain_enable);\r\nif (on)\r\nval |= (1 << id);\r\nelse\r\nval &= ~(1 << id);\r\nif ((val == oldval) &&\r\n(gain == readw(&chip->mixer.array->src_gain[id])))\r\nreturn 0;\r\ndev_dbg(chip->card->dev,\r\n"lola_mixer_set_src_gain (id=%d, gain=%d) enable=%x\n",\r\nid, gain, val);\r\nwritew(gain, &chip->mixer.array->src_gain[id]);\r\nwritel(val, &chip->mixer.array->src_gain_enable);\r\nlola_codec_flush(chip);\r\nreturn lola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_SOURCE_GAIN, id, 0);\r\n}\r\nstatic int lola_mixer_set_mapping_gain(struct lola *chip,\r\nunsigned int src, unsigned int dest,\r\nunsigned short gain, bool on)\r\n{\r\nunsigned int val;\r\nif (!(chip->mixer.src_mask & (1 << src)) ||\r\n!(chip->mixer.dest_mask & (1 << dest)))\r\nreturn -EINVAL;\r\nif (on)\r\nwritew(gain, &chip->mixer.array->dest_mix_gain[dest][src]);\r\nval = readl(&chip->mixer.array->dest_mix_gain_enable[dest]);\r\nif (on)\r\nval |= (1 << src);\r\nelse\r\nval &= ~(1 << src);\r\nwritel(val, &chip->mixer.array->dest_mix_gain_enable[dest]);\r\nlola_codec_flush(chip);\r\nreturn lola_codec_write(chip, chip->mixer.nid, LOLA_VERB_SET_MIX_GAIN,\r\nsrc, dest);\r\n}\r\nint lola_setup_all_analog_gains(struct lola *chip, int dir, bool mute)\r\n{\r\nstruct lola_pin *pin;\r\nint idx, max_idx;\r\npin = chip->pin[dir].pins;\r\nmax_idx = chip->pin[dir].num_pins;\r\nfor (idx = 0; idx < max_idx; idx++) {\r\nif (pin[idx].is_analog) {\r\nunsigned int val = mute ? 0 : pin[idx].cur_gain_step;\r\nset_analog_volume(chip, dir, idx, val, false);\r\n}\r\n}\r\nreturn lola_codec_flush(chip);\r\n}\r\nvoid lola_save_mixer(struct lola *chip)\r\n{\r\nif (chip->mixer.array_saved) {\r\nmemcpy_fromio(chip->mixer.array_saved, chip->mixer.array,\r\nsizeof(*chip->mixer.array));\r\n}\r\nlola_setup_all_analog_gains(chip, PLAY, true);\r\n}\r\nvoid lola_restore_mixer(struct lola *chip)\r\n{\r\nint i;\r\nif (chip->mixer.array_saved) {\r\nmemcpy_toio(chip->mixer.array, chip->mixer.array_saved,\r\nsizeof(*chip->mixer.array));\r\nfor (i = 0; i < chip->mixer.src_phys_ins; i++)\r\nlola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_SOURCE_GAIN,\r\ni, 0);\r\nfor (i = 0; i < chip->mixer.src_stream_outs; i++)\r\nlola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_SOURCE_GAIN,\r\nchip->mixer.src_stream_out_ofs + i, 0);\r\nfor (i = 0; i < chip->mixer.dest_stream_ins; i++)\r\nlola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_DESTINATION_GAIN,\r\ni, 0);\r\nfor (i = 0; i < chip->mixer.dest_phys_outs; i++)\r\nlola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_DESTINATION_GAIN,\r\nchip->mixer.dest_phys_out_ofs + i, 0);\r\nlola_codec_flush(chip);\r\n}\r\n}\r\nstatic int set_analog_volume(struct lola *chip, int dir,\r\nunsigned int idx, unsigned int val,\r\nbool external_call)\r\n{\r\nstruct lola_pin *pin;\r\nint err;\r\nif (idx >= chip->pin[dir].num_pins)\r\nreturn -EINVAL;\r\npin = &chip->pin[dir].pins[idx];\r\nif (!pin->is_analog || pin->amp_num_steps <= val)\r\nreturn -EINVAL;\r\nif (external_call && pin->cur_gain_step == val)\r\nreturn 0;\r\nif (external_call)\r\nlola_codec_flush(chip);\r\ndev_dbg(chip->card->dev,\r\n"set_analog_volume (dir=%d idx=%d, volume=%d)\n",\r\ndir, idx, val);\r\nerr = lola_codec_write(chip, pin->nid,\r\nLOLA_VERB_SET_AMP_GAIN_MUTE, val, 0);\r\nif (err < 0)\r\nreturn err;\r\nif (external_call)\r\npin->cur_gain_step = val;\r\nreturn 0;\r\n}\r\nint lola_set_src_config(struct lola *chip, unsigned int src_mask, bool update)\r\n{\r\nint ret = 0;\r\nint success = 0;\r\nint n, err;\r\nif ((chip->input_src_caps_mask & src_mask) != src_mask)\r\nreturn -EINVAL;\r\nfor (n = 0; n < chip->pin[CAPT].num_pins; n += 2) {\r\nunsigned int mask = 3U << n;\r\nunsigned int new_src, src_state;\r\nif (!(chip->input_src_caps_mask & mask))\r\ncontinue;\r\nnew_src = (src_mask & mask) != 0;\r\nif (update) {\r\nsrc_state = (chip->input_src_mask & mask) != 0;\r\nif (src_state == new_src)\r\ncontinue;\r\n}\r\nerr = lola_codec_write(chip, chip->pcm[CAPT].streams[n].nid,\r\nLOLA_VERB_SET_SRC, new_src, 0);\r\nif (!err)\r\nsuccess++;\r\nelse\r\nret = err;\r\n}\r\nif (success)\r\nret = lola_codec_flush(chip);\r\nif (!ret)\r\nchip->input_src_mask = src_mask;\r\nreturn ret;\r\n}\r\nstatic int init_mixer_values(struct lola *chip)\r\n{\r\nint i;\r\nlola_set_src_config(chip, (1 << chip->pin[CAPT].num_pins) - 1, false);\r\nmemset_io(chip->mixer.array, 0, sizeof(*chip->mixer.array));\r\nfor (i = 0; i < chip->mixer.dest_stream_ins; i++)\r\nlola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_DESTINATION_GAIN,\r\ni, 0);\r\nfor (i = 0; i < chip->mixer.dest_phys_outs; i++)\r\nlola_codec_write(chip, chip->mixer.nid,\r\nLOLA_VERB_SET_DESTINATION_GAIN,\r\nchip->mixer.dest_phys_out_ofs + i, 0);\r\nfor (i = 0; i < chip->mixer.src_phys_ins; i++)\r\nlola_mixer_set_src_gain(chip, i, 336, true);\r\nfor (i = 0; i < chip->mixer.src_stream_outs; i++)\r\nlola_mixer_set_src_gain(chip,\r\ni + chip->mixer.src_stream_out_ofs,\r\n336, true);\r\nfor (i = 0; i < chip->mixer.dest_stream_ins; i++) {\r\nint src = i % chip->mixer.src_phys_ins;\r\nlola_mixer_set_mapping_gain(chip, src, i, 336, true);\r\n}\r\nfor (i = 0; i < chip->mixer.src_stream_outs; i++) {\r\nint src = chip->mixer.src_stream_out_ofs + i;\r\nint dst = chip->mixer.dest_phys_out_ofs +\r\ni % chip->mixer.dest_phys_outs;\r\nlola_mixer_set_mapping_gain(chip, src, dst, 336, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lola_analog_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nint dir = kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chip->pin[dir].num_pins;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = chip->pin[dir].pins[0].amp_num_steps;\r\nreturn 0;\r\n}\r\nstatic int lola_analog_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nint dir = kcontrol->private_value;\r\nint i;\r\nfor (i = 0; i < chip->pin[dir].num_pins; i++)\r\nucontrol->value.integer.value[i] =\r\nchip->pin[dir].pins[i].cur_gain_step;\r\nreturn 0;\r\n}\r\nstatic int lola_analog_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nint dir = kcontrol->private_value;\r\nint i, err;\r\nfor (i = 0; i < chip->pin[dir].num_pins; i++) {\r\nerr = set_analog_volume(chip, dir, i,\r\nucontrol->value.integer.value[i],\r\ntrue);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lola_analog_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nint dir = kcontrol->private_value;\r\nunsigned int val1, val2;\r\nstruct lola_pin *pin;\r\nif (size < 4 * sizeof(unsigned int))\r\nreturn -ENOMEM;\r\npin = &chip->pin[dir].pins[0];\r\nval2 = pin->amp_step_size * 25;\r\nval1 = -1 * (int)pin->amp_offset * (int)val2;\r\n#ifdef TLV_DB_SCALE_MUTE\r\nval2 |= TLV_DB_SCALE_MUTE;\r\n#endif\r\nif (put_user(SNDRV_CTL_TLVT_DB_SCALE, tlv))\r\nreturn -EFAULT;\r\nif (put_user(2 * sizeof(unsigned int), tlv + 1))\r\nreturn -EFAULT;\r\nif (put_user(val1, tlv + 2))\r\nreturn -EFAULT;\r\nif (put_user(val2, tlv + 3))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int create_analog_mixer(struct lola *chip, int dir, char *name)\r\n{\r\nif (!chip->pin[dir].num_pins)\r\nreturn 0;\r\nif (chip->pin[dir].num_pins != chip->pin[dir].num_analog_pins)\r\nreturn 0;\r\nlola_analog_mixer.name = name;\r\nlola_analog_mixer.private_value = dir;\r\nreturn snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&lola_analog_mixer, chip));\r\n}\r\nstatic int lola_input_src_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = chip->pin[CAPT].num_pins;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int lola_input_src_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nint i;\r\nfor (i = 0; i < chip->pin[CAPT].num_pins; i++)\r\nucontrol->value.integer.value[i] =\r\n!!(chip->input_src_mask & (1 << i));\r\nreturn 0;\r\n}\r\nstatic int lola_input_src_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nint i;\r\nunsigned int mask;\r\nmask = 0;\r\nfor (i = 0; i < chip->pin[CAPT].num_pins; i++)\r\nif (ucontrol->value.integer.value[i])\r\nmask |= 1 << i;\r\nreturn lola_set_src_config(chip, mask, true);\r\n}\r\nstatic int create_input_src_mixer(struct lola *chip)\r\n{\r\nif (!chip->input_src_caps_mask)\r\nreturn 0;\r\nreturn snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&lola_input_src_mixer, chip));\r\n}\r\nstatic int lola_src_gain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int count = (kcontrol->private_value >> 8) & 0xff;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = count;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 409;\r\nreturn 0;\r\n}\r\nstatic int lola_src_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int ofs = kcontrol->private_value & 0xff;\r\nunsigned int count = (kcontrol->private_value >> 8) & 0xff;\r\nunsigned int mask, i;\r\nmask = readl(&chip->mixer.array->src_gain_enable);\r\nfor (i = 0; i < count; i++) {\r\nunsigned int idx = ofs + i;\r\nunsigned short val;\r\nif (!(chip->mixer.src_mask & (1 << idx)))\r\nreturn -EINVAL;\r\nif (mask & (1 << idx))\r\nval = readw(&chip->mixer.array->src_gain[idx]) + 1;\r\nelse\r\nval = 0;\r\nucontrol->value.integer.value[i] = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lola_src_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lola *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int ofs = kcontrol->private_value & 0xff;\r\nunsigned int count = (kcontrol->private_value >> 8) & 0xff;\r\nint i, err;\r\nfor (i = 0; i < count; i++) {\r\nunsigned int idx = ofs + i;\r\nunsigned short val = ucontrol->value.integer.value[i];\r\nif (val)\r\nval--;\r\nerr = lola_mixer_set_src_gain(chip, idx, val, !!val);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_src_gain_mixer(struct lola *chip,\r\nint num, int ofs, char *name)\r\n{\r\nlola_src_gain_mixer.name = name;\r\nlola_src_gain_mixer.private_value = ofs + (num << 8);\r\nreturn snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&lola_src_gain_mixer, chip));\r\n}\r\nint lola_create_mixer(struct lola *chip)\r\n{\r\nint err;\r\nerr = create_analog_mixer(chip, PLAY, "Analog Playback Volume");\r\nif (err < 0)\r\nreturn err;\r\nerr = create_analog_mixer(chip, CAPT, "Analog Capture Volume");\r\nif (err < 0)\r\nreturn err;\r\nerr = create_input_src_mixer(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = create_src_gain_mixer(chip, chip->mixer.src_phys_ins, 0,\r\n"Digital Capture Volume");\r\nif (err < 0)\r\nreturn err;\r\nerr = create_src_gain_mixer(chip, chip->mixer.src_stream_outs,\r\nchip->mixer.src_stream_out_ofs,\r\n"Digital Playback Volume");\r\nif (err < 0)\r\nreturn err;\r\n#if 0\r\nerr = create_dest_gain_mixer(chip,\r\nchip->mixer.src_phys_ins, 0,\r\nchip->mixer.dest_stream_ins, 0,\r\n"Line Capture Volume");\r\nif (err < 0)\r\nreturn err;\r\nerr = create_dest_gain_mixer(chip,\r\nchip->mixer.src_stream_outs,\r\nchip->mixer.src_stream_out_ofs,\r\nchip->mixer.dest_stream_ins, 0,\r\n"Stream-Loopback Capture Volume");\r\nif (err < 0)\r\nreturn err;\r\nerr = create_dest_gain_mixer(chip,\r\nchip->mixer.src_phys_ins, 0,\r\nchip->mixer.dest_phys_outs,\r\nchip->mixer.dest_phys_out_ofs,\r\n"Line-Loopback Playback Volume");\r\nif (err < 0)\r\nreturn err;\r\nerr = create_dest_gain_mixer(chip,\r\nchip->mixer.src_stream_outs,\r\nchip->mixer.src_stream_out_ofs,\r\nchip->mixer.dest_phys_outs,\r\nchip->mixer.dest_phys_out_ofs,\r\n"Stream Playback Volume");\r\nif (err < 0)\r\nreturn err;\r\n#endif\r\nreturn init_mixer_values(chip);\r\n}
