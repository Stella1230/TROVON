static void enter_4op_mode(void)\r\n{\r\nint i;\r\nstatic int v4op[MAX_VOICE] = {\r\n0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17\r\n};\r\ndevc->cmask = 0x3f;\r\nopl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x3f);\r\nfor (i = 0; i < 3; i++)\r\npv_map[i].voice_mode = 4;\r\nfor (i = 3; i < 6; i++)\r\npv_map[i].voice_mode = 0;\r\nfor (i = 9; i < 12; i++)\r\npv_map[i].voice_mode = 4;\r\nfor (i = 12; i < 15; i++)\r\npv_map[i].voice_mode = 0;\r\nfor (i = 0; i < 12; i++)\r\ndevc->lv_map[i] = v4op[i];\r\ndevc->v_alloc->max_voice = devc->nr_voice = 12;\r\n}\r\nstatic int opl3_ioctl(int dev, unsigned int cmd, void __user * arg)\r\n{\r\nstruct sbi_instrument ins;\r\nswitch (cmd) {\r\ncase SNDCTL_FM_LOAD_INSTR:\r\nprintk(KERN_WARNING "Warning: Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. Fix the program.\n");\r\nif (copy_from_user(&ins, arg, sizeof(ins)))\r\nreturn -EFAULT;\r\nif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR) {\r\nprintk(KERN_WARNING "FM Error: Invalid instrument number %d\n", ins.channel);\r\nreturn -EINVAL;\r\n}\r\nreturn store_instr(ins.channel, &ins);\r\ncase SNDCTL_SYNTH_INFO:\r\ndevc->fm_info.nr_voices = (devc->nr_voice == 12) ? 6 : devc->nr_voice;\r\nif (copy_to_user(arg, &devc->fm_info, sizeof(devc->fm_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_SYNTH_MEMAVL:\r\nreturn 0x7fffffff;\r\ncase SNDCTL_FM_4OP_ENABLE:\r\nif (devc->model == 2)\r\nenter_4op_mode();\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int opl3_detect(int ioaddr)\r\n{\r\nunsigned char stat1, signature;\r\nint i;\r\nif (devc != NULL)\r\n{\r\nprintk(KERN_ERR "opl3: Only one OPL3 supported.\n");\r\nreturn 0;\r\n}\r\ndevc = kzalloc(sizeof(*devc), GFP_KERNEL);\r\nif (devc == NULL)\r\n{\r\nprintk(KERN_ERR "opl3: Can't allocate memory for the device control "\r\n"structure \n ");\r\nreturn 0;\r\n}\r\nstrcpy(devc->fm_info.name, "OPL2");\r\nif (!request_region(ioaddr, 4, devc->fm_info.name)) {\r\nprintk(KERN_WARNING "opl3: I/O port 0x%x already in use\n", ioaddr);\r\ngoto cleanup_devc;\r\n}\r\ndevc->base = ioaddr;\r\nopl3_command(ioaddr, TIMER_CONTROL_REGISTER, TIMER1_MASK | TIMER2_MASK);\r\nopl3_command(ioaddr, TIMER_CONTROL_REGISTER, IRQ_RESET);\r\nsignature = stat1 = inb(ioaddr);\r\nif (signature != 0x00 && signature != 0x06 && signature != 0x02 &&\r\nsignature != 0x0f)\r\n{\r\nMDB(printk(KERN_INFO "OPL3 not detected %x\n", signature));\r\ngoto cleanup_region;\r\n}\r\nif (signature == 0x06)\r\n{\r\ndetected_model = 2;\r\n}\r\nelse if (signature == 0x00 || signature == 0x0f)\r\n{\r\nunsigned char tmp;\r\ndetected_model = 3;\r\nopl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0x00);\r\nopl3_command(ioaddr + 2, OPL3_MODE_REGISTER, OPL3_ENABLE | OPL4_ENABLE);\r\nif ((tmp = inb(ioaddr)) == 0x02)\r\n{\r\ndetected_model = 4;\r\n}\r\nif (request_region(ioaddr - 8, 2, "OPL4"))\r\n{\r\nint tmp;\r\noutb((0x02), ioaddr - 8);\r\nudelay(10);\r\ntmp = inb(ioaddr - 7);\r\nudelay(10);\r\nif (tmp == 0x20)\r\n{\r\ndetected_model = 4;\r\noutb((0xF8), ioaddr - 8);\r\nudelay(10);\r\noutb((0x1B), ioaddr - 7);\r\nudelay(10);\r\n}\r\nelse\r\n{\r\nrelease_region(ioaddr - 8, 2);\r\ndetected_model = 3;\r\n}\r\n}\r\nopl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0);\r\n}\r\nfor (i = 0; i < 9; i++)\r\nopl3_command(ioaddr, KEYON_BLOCK + i, 0);\r\nopl3_command(ioaddr, TEST_REGISTER, ENABLE_WAVE_SELECT);\r\nopl3_command(ioaddr, PERCOSSION_REGISTER, 0x00);\r\nreturn 1;\r\ncleanup_region:\r\nrelease_region(ioaddr, 4);\r\ncleanup_devc:\r\nkfree(devc);\r\ndevc = NULL;\r\nreturn 0;\r\n}\r\nstatic int opl3_kill_note (int devno, int voice, int note, int velocity)\r\n{\r\nstruct physical_voice_info *map;\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn 0;\r\ndevc->v_alloc->map[voice] = 0;\r\nmap = &pv_map[devc->lv_map[voice]];\r\nif (map->voice_mode == 0)\r\nreturn 0;\r\nopl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, devc->voc[voice].keyon_byte & ~0x20);\r\ndevc->voc[voice].keyon_byte = 0;\r\ndevc->voc[voice].bender = 0;\r\ndevc->voc[voice].volume = 64;\r\ndevc->voc[voice].panning = 0xffff;\r\ndevc->voc[voice].bender_range = 200;\r\ndevc->voc[voice].orig_freq = 0;\r\ndevc->voc[voice].current_freq = 0;\r\ndevc->voc[voice].mode = 0;\r\nreturn 0;\r\n}\r\nstatic int store_instr(int instr_no, struct sbi_instrument *instr)\r\n{\r\nif (instr->key != FM_PATCH && (instr->key != OPL3_PATCH || devc->model != 2))\r\nprintk(KERN_WARNING "FM warning: Invalid patch format field (key) 0x%x\n", instr->key);\r\nmemcpy((char *) &(devc->i_map[instr_no]), (char *) instr, sizeof(*instr));\r\nreturn 0;\r\n}\r\nstatic int opl3_set_instr (int dev, int voice, int instr_no)\r\n{\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn 0;\r\nif (instr_no < 0 || instr_no >= SBFM_MAXINSTR)\r\ninstr_no = 0;\r\ndevc->act_i[voice] = &devc->i_map[instr_no];\r\nreturn 0;\r\n}\r\nstatic void calc_vol(unsigned char *regbyte, int volume, int main_vol)\r\n{\r\nint level = (~*regbyte & 0x3f);\r\nif (main_vol > 127)\r\nmain_vol = 127;\r\nvolume = (volume * main_vol) / 127;\r\nif (level)\r\nlevel += fm_volume_table[volume];\r\nif (level > 0x3f)\r\nlevel = 0x3f;\r\nif (level < 0)\r\nlevel = 0;\r\n*regbyte = (*regbyte & 0xc0) | (~level & 0x3f);\r\n}\r\nstatic void set_voice_volume(int voice, int volume, int main_vol)\r\n{\r\nunsigned char vol1, vol2, vol3, vol4;\r\nstruct sbi_instrument *instr;\r\nstruct physical_voice_info *map;\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn;\r\nmap = &pv_map[devc->lv_map[voice]];\r\ninstr = devc->act_i[voice];\r\nif (!instr)\r\ninstr = &devc->i_map[0];\r\nif (instr->channel < 0)\r\nreturn;\r\nif (devc->voc[voice].mode == 0)\r\nreturn;\r\nif (devc->voc[voice].mode == 2)\r\n{\r\nvol1 = instr->operators[2];\r\nvol2 = instr->operators[3];\r\nif ((instr->operators[10] & 0x01))\r\n{\r\ncalc_vol(&vol1, volume, main_vol);\r\ncalc_vol(&vol2, volume, main_vol);\r\n}\r\nelse\r\n{\r\ncalc_vol(&vol2, volume, main_vol);\r\n}\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\r\n}\r\nelse\r\n{\r\nint connection;\r\nvol1 = instr->operators[2];\r\nvol2 = instr->operators[3];\r\nvol3 = instr->operators[OFFS_4OP + 2];\r\nvol4 = instr->operators[OFFS_4OP + 3];\r\nconnection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\r\nswitch (connection)\r\n{\r\ncase 0:\r\ncalc_vol(&vol4, volume, main_vol);\r\nbreak;\r\ncase 1:\r\ncalc_vol(&vol2, volume, main_vol);\r\ncalc_vol(&vol4, volume, main_vol);\r\nbreak;\r\ncase 2:\r\ncalc_vol(&vol1, volume, main_vol);\r\ncalc_vol(&vol4, volume, main_vol);\r\nbreak;\r\ncase 3:\r\ncalc_vol(&vol1, volume, main_vol);\r\ncalc_vol(&vol3, volume, main_vol);\r\ncalc_vol(&vol4, volume, main_vol);\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[2], vol3);\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[3], vol4);\r\n}\r\n}\r\nstatic int opl3_start_note (int dev, int voice, int note, int volume)\r\n{\r\nunsigned char data, fpc;\r\nint block, fnum, freq, voice_mode, pan;\r\nstruct sbi_instrument *instr;\r\nstruct physical_voice_info *map;\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn 0;\r\nmap = &pv_map[devc->lv_map[voice]];\r\npan = devc->voc[voice].panning;\r\nif (map->voice_mode == 0)\r\nreturn 0;\r\nif (note == 255)\r\n{\r\nset_voice_volume(voice, volume, devc->voc[voice].volume);\r\nreturn 0;\r\n}\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[1], 0xff);\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[0], 0xff);\r\nif (map->voice_mode == 4)\r\n{\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[2], 0xff);\r\nopl3_command(map->ioaddr, KSL_LEVEL + map->op[3], 0xff);\r\n}\r\nopl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, 0x00);\r\ninstr = devc->act_i[voice];\r\nif (!instr)\r\ninstr = &devc->i_map[0];\r\nif (instr->channel < 0)\r\n{\r\nprintk(KERN_WARNING "opl3: Initializing voice %d with undefined instrument\n", voice);\r\nreturn 0;\r\n}\r\nif (map->voice_mode == 2 && instr->key == OPL3_PATCH)\r\nreturn 0;\r\nvoice_mode = map->voice_mode;\r\nif (voice_mode == 4)\r\n{\r\nint voice_shift;\r\nvoice_shift = (map->ioaddr == devc->left_io) ? 0 : 3;\r\nvoice_shift += map->voice_num;\r\nif (instr->key != OPL3_PATCH)\r\n{\r\nvoice_mode = 2;\r\ndevc->cmask &= ~(1 << voice_shift);\r\n}\r\nelse\r\n{\r\ndevc->cmask |= (1 << voice_shift);\r\n}\r\nopl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\r\n}\r\nopl3_command(map->ioaddr, AM_VIB + map->op[0], instr->operators[0]);\r\nopl3_command(map->ioaddr, AM_VIB + map->op[1], instr->operators[1]);\r\nopl3_command(map->ioaddr, ATTACK_DECAY + map->op[0], instr->operators[4]);\r\nopl3_command(map->ioaddr, ATTACK_DECAY + map->op[1], instr->operators[5]);\r\nopl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[0], instr->operators[6]);\r\nopl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[1], instr->operators[7]);\r\nopl3_command(map->ioaddr, WAVE_SELECT + map->op[0], instr->operators[8]);\r\nopl3_command(map->ioaddr, WAVE_SELECT + map->op[1], instr->operators[9]);\r\nfpc = instr->operators[10];\r\nif (pan != 0xffff)\r\n{\r\nfpc &= ~STEREO_BITS;\r\nif (pan < -64)\r\nfpc |= VOICE_TO_LEFT;\r\nelse\r\nif (pan > 64)\r\nfpc |= VOICE_TO_RIGHT;\r\nelse\r\nfpc |= (VOICE_TO_LEFT | VOICE_TO_RIGHT);\r\n}\r\nif (!(fpc & 0x30))\r\nfpc |= 0x30;\r\nopl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num, fpc);\r\nif (voice_mode == 4)\r\n{\r\nopl3_command(map->ioaddr, AM_VIB + map->op[2], instr->operators[OFFS_4OP + 0]);\r\nopl3_command(map->ioaddr, AM_VIB + map->op[3], instr->operators[OFFS_4OP + 1]);\r\nopl3_command(map->ioaddr, ATTACK_DECAY + map->op[2], instr->operators[OFFS_4OP + 4]);\r\nopl3_command(map->ioaddr, ATTACK_DECAY + map->op[3], instr->operators[OFFS_4OP + 5]);\r\nopl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[2], instr->operators[OFFS_4OP + 6]);\r\nopl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[3], instr->operators[OFFS_4OP + 7]);\r\nopl3_command(map->ioaddr, WAVE_SELECT + map->op[2], instr->operators[OFFS_4OP + 8]);\r\nopl3_command(map->ioaddr, WAVE_SELECT + map->op[3], instr->operators[OFFS_4OP + 9]);\r\nfpc = instr->operators[OFFS_4OP + 10];\r\nif (!(fpc & 0x30))\r\nfpc |= 0x30;\r\nopl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num + 3, fpc);\r\n}\r\ndevc->voc[voice].mode = voice_mode;\r\nset_voice_volume(voice, volume, devc->voc[voice].volume);\r\nfreq = devc->voc[voice].orig_freq = note_to_freq(note) / 1000;\r\nfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\r\ndevc->voc[voice].current_freq = freq;\r\nfreq_to_fnum(freq, &block, &fnum);\r\ndata = fnum & 0xff;\r\nopl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\r\ndata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\r\ndevc->voc[voice].keyon_byte = data;\r\nopl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\r\nif (voice_mode == 4)\r\nopl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num + 3, data);\r\nreturn 0;\r\n}\r\nstatic void freq_to_fnum (int freq, int *block, int *fnum)\r\n{\r\nint f, octave;\r\nf = freq;\r\noctave = 5;\r\nif (f == 0)\r\noctave = 0;\r\nelse if (f < 261)\r\n{\r\nwhile (f < 261)\r\n{\r\noctave--;\r\nf <<= 1;\r\n}\r\n}\r\nelse if (f > 493)\r\n{\r\nwhile (f > 493)\r\n{\r\noctave++;\r\nf >>= 1;\r\n}\r\n}\r\nif (octave > 7)\r\noctave = 7;\r\n*fnum = freq * (1 << (20 - octave)) / 49716;\r\n*block = octave;\r\n}\r\nstatic void opl3_command (int io_addr, unsigned int addr, unsigned int val)\r\n{\r\nint i;\r\noutb(((unsigned char) (addr & 0xff)), io_addr);\r\nif (devc->model != 2)\r\nudelay(10);\r\nelse\r\nfor (i = 0; i < 2; i++)\r\ninb(io_addr);\r\noutb(((unsigned char) (val & 0xff)), io_addr + 1);\r\nif (devc->model != 2)\r\nudelay(30);\r\nelse\r\nfor (i = 0; i < 2; i++)\r\ninb(io_addr);\r\n}\r\nstatic void opl3_reset(int devno)\r\n{\r\nint i;\r\nfor (i = 0; i < 18; i++)\r\ndevc->lv_map[i] = i;\r\nfor (i = 0; i < devc->nr_voice; i++)\r\n{\r\nopl3_command(pv_map[devc->lv_map[i]].ioaddr,\r\nKSL_LEVEL + pv_map[devc->lv_map[i]].op[0], 0xff);\r\nopl3_command(pv_map[devc->lv_map[i]].ioaddr,\r\nKSL_LEVEL + pv_map[devc->lv_map[i]].op[1], 0xff);\r\nif (pv_map[devc->lv_map[i]].voice_mode == 4)\r\n{\r\nopl3_command(pv_map[devc->lv_map[i]].ioaddr,\r\nKSL_LEVEL + pv_map[devc->lv_map[i]].op[2], 0xff);\r\nopl3_command(pv_map[devc->lv_map[i]].ioaddr,\r\nKSL_LEVEL + pv_map[devc->lv_map[i]].op[3], 0xff);\r\n}\r\nopl3_kill_note(devno, i, 0, 64);\r\n}\r\nif (devc->model == 2)\r\n{\r\ndevc->v_alloc->max_voice = devc->nr_voice = 18;\r\nfor (i = 0; i < 18; i++)\r\npv_map[i].voice_mode = 2;\r\n}\r\n}\r\nstatic int opl3_open(int dev, int mode)\r\n{\r\nint i;\r\nif (devc->busy)\r\nreturn -EBUSY;\r\ndevc->busy = 1;\r\ndevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\r\ndevc->v_alloc->timestamp = 0;\r\nfor (i = 0; i < 18; i++)\r\n{\r\ndevc->v_alloc->map[i] = 0;\r\ndevc->v_alloc->alloc_times[i] = 0;\r\n}\r\ndevc->cmask = 0x00;\r\nif (devc->model == 2)\r\nopl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\r\nreturn 0;\r\n}\r\nstatic void opl3_close(int dev)\r\n{\r\ndevc->busy = 0;\r\ndevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\r\ndevc->fm_info.nr_drums = 0;\r\ndevc->fm_info.perc_mode = 0;\r\nopl3_reset(dev);\r\n}\r\nstatic void opl3_hw_control(int dev, unsigned char *event)\r\n{\r\n}\r\nstatic int opl3_load_patch(int dev, int format, const char __user *addr,\r\nint count, int pmgr_flag)\r\n{\r\nstruct sbi_instrument ins;\r\nif (count <sizeof(ins))\r\n{\r\nprintk(KERN_WARNING "FM Error: Patch record too short\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&ins, addr, sizeof(ins)))\r\nreturn -EFAULT;\r\nif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\r\n{\r\nprintk(KERN_WARNING "FM Error: Invalid instrument number %d\n", ins.channel);\r\nreturn -EINVAL;\r\n}\r\nins.key = format;\r\nreturn store_instr(ins.channel, &ins);\r\n}\r\nstatic void opl3_panning(int dev, int voice, int value)\r\n{\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn;\r\ndevc->voc[voice].panning = value;\r\n}\r\nstatic void opl3_volume_method(int dev, int mode)\r\n{\r\n}\r\nstatic void opl3_aftertouch(int dev, int voice, int pressure)\r\n{\r\nint tmp;\r\nstruct sbi_instrument *instr;\r\nstruct physical_voice_info *map;\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn;\r\nmap = &pv_map[devc->lv_map[voice]];\r\nif (map->voice_mode == 0)\r\nreturn;\r\ninstr = devc->act_i[voice];\r\nif (!instr)\r\ninstr = &devc->i_map[0];\r\nif (devc->voc[voice].mode == 4)\r\n{\r\nint connection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\r\nswitch (connection)\r\n{\r\ncase 0:\r\nSET_VIBRATO(4);\r\nbreak;\r\ncase 1:\r\nSET_VIBRATO(2);\r\nSET_VIBRATO(4);\r\nbreak;\r\ncase 2:\r\nSET_VIBRATO(1);\r\nSET_VIBRATO(4);\r\nbreak;\r\ncase 3:\r\nSET_VIBRATO(1);\r\nSET_VIBRATO(3);\r\nSET_VIBRATO(4);\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nSET_VIBRATO(1);\r\nif ((instr->operators[10] & 0x01))\r\nSET_VIBRATO(2);\r\n}\r\n}\r\nstatic void bend_pitch(int dev, int voice, int value)\r\n{\r\nunsigned char data;\r\nint block, fnum, freq;\r\nstruct physical_voice_info *map;\r\nmap = &pv_map[devc->lv_map[voice]];\r\nif (map->voice_mode == 0)\r\nreturn;\r\ndevc->voc[voice].bender = value;\r\nif (!value)\r\nreturn;\r\nif (!(devc->voc[voice].keyon_byte & 0x20))\r\nreturn;\r\nfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\r\ndevc->voc[voice].current_freq = freq;\r\nfreq_to_fnum(freq, &block, &fnum);\r\ndata = fnum & 0xff;\r\nopl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\r\ndata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\r\ndevc->voc[voice].keyon_byte = data;\r\nopl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\r\n}\r\nstatic void opl3_controller (int dev, int voice, int ctrl_num, int value)\r\n{\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn;\r\nswitch (ctrl_num)\r\n{\r\ncase CTRL_PITCH_BENDER:\r\nbend_pitch(dev, voice, value);\r\nbreak;\r\ncase CTRL_PITCH_BENDER_RANGE:\r\ndevc->voc[voice].bender_range = value;\r\nbreak;\r\ncase CTL_MAIN_VOLUME:\r\ndevc->voc[voice].volume = value / 128;\r\nbreak;\r\ncase CTL_PAN:\r\ndevc->voc[voice].panning = (value * 2) - 128;\r\nbreak;\r\n}\r\n}\r\nstatic void opl3_bender(int dev, int voice, int value)\r\n{\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn;\r\nbend_pitch(dev, voice, value - 8192);\r\n}\r\nstatic int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info *alloc)\r\n{\r\nint i, p, best, first, avail, best_time = 0x7fffffff;\r\nstruct sbi_instrument *instr;\r\nint is4op;\r\nint instr_no;\r\nif (chn < 0 || chn > 15)\r\ninstr_no = 0;\r\nelse\r\ninstr_no = devc->chn_info[chn].pgm_num;\r\ninstr = &devc->i_map[instr_no];\r\nif (instr->channel < 0 ||\r\ndevc->nr_voice != 12)\r\nis4op = 0;\r\nelse if (devc->nr_voice == 12)\r\nis4op = (instr->key == OPL3_PATCH);\r\nelse\r\nis4op = 0;\r\nif (is4op)\r\n{\r\nfirst = p = 0;\r\navail = 6;\r\n}\r\nelse\r\n{\r\nif (devc->nr_voice == 12)\r\nfirst = p = 6;\r\nelse\r\nfirst = p = 0;\r\navail = devc->nr_voice;\r\n}\r\nbest = first;\r\nfor (i = 0; i < avail; i++)\r\n{\r\nif (alloc->map[p] == 0)\r\n{\r\nreturn p;\r\n}\r\nif (alloc->alloc_times[p] < best_time)\r\n{\r\nbest_time = alloc->alloc_times[p];\r\nbest = p;\r\n}\r\np = (p + 1) % avail;\r\n}\r\nif (best < 0)\r\nbest = 0;\r\nif (best > devc->nr_voice)\r\nbest -= devc->nr_voice;\r\nreturn best;\r\n}\r\nstatic void opl3_setup_voice(int dev, int voice, int chn)\r\n{\r\nstruct channel_info *info;\r\nif (voice < 0 || voice >= devc->nr_voice)\r\nreturn;\r\nif (chn < 0 || chn > 15)\r\nreturn;\r\ninfo = &synth_devs[dev]->chn_info[chn];\r\nopl3_set_instr(dev, voice, info->pgm_num);\r\ndevc->voc[voice].bender = 0;\r\ndevc->voc[voice].bender_range = info->bender_range;\r\ndevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\r\ndevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\r\n}\r\nstatic int opl3_init(int ioaddr, struct module *owner)\r\n{\r\nint i;\r\nint me;\r\nif (devc == NULL)\r\n{\r\nprintk(KERN_ERR "opl3: Device control structure not initialized.\n");\r\nreturn -1;\r\n}\r\nif ((me = sound_alloc_synthdev()) == -1)\r\n{\r\nprintk(KERN_WARNING "opl3: Too many synthesizers\n");\r\nreturn -1;\r\n}\r\ndevc->nr_voice = 9;\r\ndevc->fm_info.device = 0;\r\ndevc->fm_info.synth_type = SYNTH_TYPE_FM;\r\ndevc->fm_info.synth_subtype = FM_TYPE_ADLIB;\r\ndevc->fm_info.perc_mode = 0;\r\ndevc->fm_info.nr_voices = 9;\r\ndevc->fm_info.nr_drums = 0;\r\ndevc->fm_info.instr_bank_size = SBFM_MAXINSTR;\r\ndevc->fm_info.capabilities = 0;\r\ndevc->left_io = ioaddr;\r\ndevc->right_io = ioaddr + 2;\r\nif (detected_model <= 2)\r\ndevc->model = 1;\r\nelse\r\n{\r\ndevc->model = 2;\r\nif (detected_model == 4)\r\ndevc->is_opl4 = 1;\r\n}\r\nopl3_operations.info = &devc->fm_info;\r\nsynth_devs[me] = &opl3_operations;\r\nif (owner)\r\nsynth_devs[me]->owner = owner;\r\nsequencer_init();\r\ndevc->v_alloc = &opl3_operations.alloc;\r\ndevc->chn_info = &opl3_operations.chn_info[0];\r\nif (devc->model == 2)\r\n{\r\nif (devc->is_opl4)\r\nstrcpy(devc->fm_info.name, "Yamaha OPL4/OPL3 FM");\r\nelse\r\nstrcpy(devc->fm_info.name, "Yamaha OPL3");\r\ndevc->v_alloc->max_voice = devc->nr_voice = 18;\r\ndevc->fm_info.nr_drums = 0;\r\ndevc->fm_info.synth_subtype = FM_TYPE_OPL3;\r\ndevc->fm_info.capabilities |= SYNTH_CAP_OPL3;\r\nfor (i = 0; i < 18; i++)\r\n{\r\nif (pv_map[i].ioaddr == USE_LEFT)\r\npv_map[i].ioaddr = devc->left_io;\r\nelse\r\npv_map[i].ioaddr = devc->right_io;\r\n}\r\nopl3_command(devc->right_io, OPL3_MODE_REGISTER, OPL3_ENABLE);\r\nopl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x00);\r\n}\r\nelse\r\n{\r\nstrcpy(devc->fm_info.name, "Yamaha OPL2");\r\ndevc->v_alloc->max_voice = devc->nr_voice = 9;\r\ndevc->fm_info.nr_drums = 0;\r\nfor (i = 0; i < 18; i++)\r\npv_map[i].ioaddr = devc->left_io;\r\n}\r\nconf_printf2(devc->fm_info.name, ioaddr, 0, -1, -1);\r\nfor (i = 0; i < SBFM_MAXINSTR; i++)\r\ndevc->i_map[i].channel = -1;\r\nreturn me;\r\n}\r\nstatic int __init init_opl3 (void)\r\n{\r\nprintk(KERN_INFO "YM3812 and OPL-3 driver Copyright (C) by Hannu Savolainen, Rob Hooft 1993-1996\n");\r\nif (io != -1)\r\n{\r\nif (!opl3_detect(io))\r\n{\r\nreturn -ENODEV;\r\n}\r\nme = opl3_init(io, THIS_MODULE);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_opl3(void)\r\n{\r\nif (devc && io != -1)\r\n{\r\nif (devc->base) {\r\nrelease_region(devc->base,4);\r\nif (devc->is_opl4)\r\nrelease_region(devc->base - 8, 2);\r\n}\r\nkfree(devc);\r\ndevc = NULL;\r\nsound_unload_synthdev(me);\r\n}\r\n}\r\nstatic int __init setup_opl3(char *str)\r\n{\r\nint ints[2];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nreturn 1;\r\n}
