static inline struct sii902x *bridge_to_sii902x(struct drm_bridge *bridge)\r\n{\r\nreturn container_of(bridge, struct sii902x, bridge);\r\n}\r\nstatic inline struct sii902x *connector_to_sii902x(struct drm_connector *con)\r\n{\r\nreturn container_of(con, struct sii902x, connector);\r\n}\r\nstatic void sii902x_reset(struct sii902x *sii902x)\r\n{\r\nif (!sii902x->reset_gpio)\r\nreturn;\r\ngpiod_set_value(sii902x->reset_gpio, 1);\r\nusleep_range(150, 200);\r\ngpiod_set_value(sii902x->reset_gpio, 0);\r\n}\r\nstatic enum drm_connector_status\r\nsii902x_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct sii902x *sii902x = connector_to_sii902x(connector);\r\nunsigned int status;\r\nregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\r\nreturn (status & SII902X_PLUGGED_STATUS) ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic int sii902x_get_modes(struct drm_connector *connector)\r\n{\r\nstruct sii902x *sii902x = connector_to_sii902x(connector);\r\nstruct regmap *regmap = sii902x->regmap;\r\nu32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\r\nunsigned long timeout;\r\nunsigned int status;\r\nstruct edid *edid;\r\nint num = 0;\r\nint ret;\r\nret = regmap_update_bits(regmap, SII902X_SYS_CTRL_DATA,\r\nSII902X_SYS_CTRL_DDC_BUS_REQ,\r\nSII902X_SYS_CTRL_DDC_BUS_REQ);\r\nif (ret)\r\nreturn ret;\r\ntimeout = jiffies +\r\nmsecs_to_jiffies(SII902X_I2C_BUS_ACQUISITION_TIMEOUT_MS);\r\ndo {\r\nret = regmap_read(regmap, SII902X_SYS_CTRL_DATA, &status);\r\nif (ret)\r\nreturn ret;\r\n} while (!(status & SII902X_SYS_CTRL_DDC_BUS_GRTD) &&\r\ntime_before(jiffies, timeout));\r\nif (!(status & SII902X_SYS_CTRL_DDC_BUS_GRTD)) {\r\ndev_err(&sii902x->i2c->dev, "failed to acquire the i2c bus");\r\nreturn -ETIMEDOUT;\r\n}\r\nret = regmap_write(regmap, SII902X_SYS_CTRL_DATA, status);\r\nif (ret)\r\nreturn ret;\r\nedid = drm_get_edid(connector, sii902x->i2c->adapter);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nif (edid) {\r\nnum = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nret = drm_display_info_set_bus_formats(&connector->display_info,\r\n&bus_format, 1);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(regmap, SII902X_SYS_CTRL_DATA, &status);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_update_bits(regmap, SII902X_SYS_CTRL_DATA,\r\nSII902X_SYS_CTRL_DDC_BUS_REQ |\r\nSII902X_SYS_CTRL_DDC_BUS_GRTD, 0);\r\nif (ret)\r\nreturn ret;\r\ntimeout = jiffies +\r\nmsecs_to_jiffies(SII902X_I2C_BUS_ACQUISITION_TIMEOUT_MS);\r\ndo {\r\nret = regmap_read(regmap, SII902X_SYS_CTRL_DATA, &status);\r\nif (ret)\r\nreturn ret;\r\n} while (status & (SII902X_SYS_CTRL_DDC_BUS_REQ |\r\nSII902X_SYS_CTRL_DDC_BUS_GRTD) &&\r\ntime_before(jiffies, timeout));\r\nif (status & (SII902X_SYS_CTRL_DDC_BUS_REQ |\r\nSII902X_SYS_CTRL_DDC_BUS_GRTD)) {\r\ndev_err(&sii902x->i2c->dev, "failed to release the i2c bus");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn num;\r\n}\r\nstatic enum drm_mode_status sii902x_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic void sii902x_bridge_disable(struct drm_bridge *bridge)\r\n{\r\nstruct sii902x *sii902x = bridge_to_sii902x(bridge);\r\nregmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,\r\nSII902X_SYS_CTRL_PWR_DWN,\r\nSII902X_SYS_CTRL_PWR_DWN);\r\n}\r\nstatic void sii902x_bridge_enable(struct drm_bridge *bridge)\r\n{\r\nstruct sii902x *sii902x = bridge_to_sii902x(bridge);\r\nregmap_update_bits(sii902x->regmap, SII902X_PWR_STATE_CTRL,\r\nSII902X_AVI_POWER_STATE_MSK,\r\nSII902X_AVI_POWER_STATE_D(0));\r\nregmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,\r\nSII902X_SYS_CTRL_PWR_DWN, 0);\r\n}\r\nstatic void sii902x_bridge_mode_set(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adj)\r\n{\r\nstruct sii902x *sii902x = bridge_to_sii902x(bridge);\r\nstruct regmap *regmap = sii902x->regmap;\r\nu8 buf[HDMI_INFOFRAME_SIZE(AVI)];\r\nstruct hdmi_avi_infoframe frame;\r\nint ret;\r\nbuf[0] = adj->clock;\r\nbuf[1] = adj->clock >> 8;\r\nbuf[2] = adj->vrefresh;\r\nbuf[3] = 0x00;\r\nbuf[4] = adj->hdisplay;\r\nbuf[5] = adj->hdisplay >> 8;\r\nbuf[6] = adj->vdisplay;\r\nbuf[7] = adj->vdisplay >> 8;\r\nbuf[8] = SII902X_TPI_CLK_RATIO_1X | SII902X_TPI_AVI_PIXEL_REP_NONE |\r\nSII902X_TPI_AVI_PIXEL_REP_BUS_24BIT;\r\nbuf[9] = SII902X_TPI_AVI_INPUT_RANGE_AUTO |\r\nSII902X_TPI_AVI_INPUT_COLORSPACE_RGB;\r\nret = regmap_bulk_write(regmap, SII902X_TPI_VIDEO_DATA, buf, 10);\r\nif (ret)\r\nreturn;\r\nret = drm_hdmi_avi_infoframe_from_display_mode(&frame, adj);\r\nif (ret < 0) {\r\nDRM_ERROR("couldn't fill AVI infoframe\n");\r\nreturn;\r\n}\r\nret = hdmi_avi_infoframe_pack(&frame, buf, sizeof(buf));\r\nif (ret < 0) {\r\nDRM_ERROR("failed to pack AVI infoframe: %d\n", ret);\r\nreturn;\r\n}\r\nregmap_bulk_write(regmap, SII902X_TPI_AVI_INFOFRAME,\r\nbuf + HDMI_INFOFRAME_HEADER_SIZE - 1,\r\nHDMI_AVI_INFOFRAME_SIZE + 1);\r\n}\r\nstatic int sii902x_bridge_attach(struct drm_bridge *bridge)\r\n{\r\nstruct sii902x *sii902x = bridge_to_sii902x(bridge);\r\nstruct drm_device *drm = bridge->dev;\r\nint ret;\r\ndrm_connector_helper_add(&sii902x->connector,\r\n&sii902x_connector_helper_funcs);\r\nif (!drm_core_check_feature(drm, DRIVER_ATOMIC)) {\r\ndev_err(&sii902x->i2c->dev,\r\n"sii902x driver is only compatible with DRM devices supporting atomic updates");\r\nreturn -ENOTSUPP;\r\n}\r\nret = drm_connector_init(drm, &sii902x->connector,\r\n&sii902x_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\nif (ret)\r\nreturn ret;\r\nif (sii902x->i2c->irq > 0)\r\nsii902x->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\nelse\r\nsii902x->connector.polled = DRM_CONNECTOR_POLL_CONNECT;\r\ndrm_mode_connector_attach_encoder(&sii902x->connector, bridge->encoder);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sii902x_interrupt(int irq, void *data)\r\n{\r\nstruct sii902x *sii902x = data;\r\nunsigned int status = 0;\r\nregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\r\nregmap_write(sii902x->regmap, SII902X_INT_STATUS, status);\r\nif ((status & SII902X_HOTPLUG_EVENT) && sii902x->bridge.dev)\r\ndrm_helper_hpd_irq_event(sii902x->bridge.dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sii902x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nunsigned int status = 0;\r\nstruct sii902x *sii902x;\r\nu8 chipid[4];\r\nint ret;\r\nsii902x = devm_kzalloc(dev, sizeof(*sii902x), GFP_KERNEL);\r\nif (!sii902x)\r\nreturn -ENOMEM;\r\nsii902x->i2c = client;\r\nsii902x->regmap = devm_regmap_init_i2c(client, &sii902x_regmap_config);\r\nif (IS_ERR(sii902x->regmap))\r\nreturn PTR_ERR(sii902x->regmap);\r\nsii902x->reset_gpio = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_OUT_LOW);\r\nif (IS_ERR(sii902x->reset_gpio)) {\r\ndev_err(dev, "Failed to retrieve/request reset gpio: %ld\n",\r\nPTR_ERR(sii902x->reset_gpio));\r\nreturn PTR_ERR(sii902x->reset_gpio);\r\n}\r\nsii902x_reset(sii902x);\r\nret = regmap_write(sii902x->regmap, SII902X_REG_TPI_RQB, 0x0);\r\nif (ret)\r\nreturn ret;\r\nret = regmap_bulk_read(sii902x->regmap, SII902X_REG_CHIPID(0),\r\n&chipid, 4);\r\nif (ret) {\r\ndev_err(dev, "regmap_read failed %d\n", ret);\r\nreturn ret;\r\n}\r\nif (chipid[0] != 0xb0) {\r\ndev_err(dev, "Invalid chipid: %02x (expecting 0xb0)\n",\r\nchipid[0]);\r\nreturn -EINVAL;\r\n}\r\nregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\r\nregmap_write(sii902x->regmap, SII902X_INT_STATUS, status);\r\nif (client->irq > 0) {\r\nregmap_write(sii902x->regmap, SII902X_INT_ENABLE,\r\nSII902X_HOTPLUG_EVENT);\r\nret = devm_request_threaded_irq(dev, client->irq, NULL,\r\nsii902x_interrupt,\r\nIRQF_ONESHOT, dev_name(dev),\r\nsii902x);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsii902x->bridge.funcs = &sii902x_bridge_funcs;\r\nsii902x->bridge.of_node = dev->of_node;\r\nret = drm_bridge_add(&sii902x->bridge);\r\nif (ret) {\r\ndev_err(dev, "Failed to add drm_bridge\n");\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(client, sii902x);\r\nreturn 0;\r\n}\r\nstatic int sii902x_remove(struct i2c_client *client)\r\n{\r\nstruct sii902x *sii902x = i2c_get_clientdata(client);\r\ndrm_bridge_remove(&sii902x->bridge);\r\nreturn 0;\r\n}
