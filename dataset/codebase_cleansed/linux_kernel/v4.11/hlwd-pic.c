static void hlwd_pic_mask_and_ack(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nu32 mask = 1 << irq;\r\nclrbits32(io_base + HW_BROADWAY_IMR, mask);\r\nout_be32(io_base + HW_BROADWAY_ICR, mask);\r\n}\r\nstatic void hlwd_pic_ack(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nout_be32(io_base + HW_BROADWAY_ICR, 1 << irq);\r\n}\r\nstatic void hlwd_pic_mask(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nclrbits32(io_base + HW_BROADWAY_IMR, 1 << irq);\r\n}\r\nstatic void hlwd_pic_unmask(struct irq_data *d)\r\n{\r\nint irq = irqd_to_hwirq(d);\r\nvoid __iomem *io_base = irq_data_get_irq_chip_data(d);\r\nsetbits32(io_base + HW_BROADWAY_IMR, 1 << irq);\r\n}\r\nstatic int hlwd_pic_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_data(virq, h->host_data);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &hlwd_pic, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic unsigned int __hlwd_pic_get_irq(struct irq_domain *h)\r\n{\r\nvoid __iomem *io_base = h->host_data;\r\nint irq;\r\nu32 irq_status;\r\nirq_status = in_be32(io_base + HW_BROADWAY_ICR) &\r\nin_be32(io_base + HW_BROADWAY_IMR);\r\nif (irq_status == 0)\r\nreturn 0;\r\nirq = __ffs(irq_status);\r\nreturn irq_linear_revmap(h, irq);\r\n}\r\nstatic void hlwd_pic_irq_cascade(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct irq_domain *irq_domain = irq_desc_get_handler_data(desc);\r\nunsigned int virq;\r\nraw_spin_lock(&desc->lock);\r\nchip->irq_mask(&desc->irq_data);\r\nraw_spin_unlock(&desc->lock);\r\nvirq = __hlwd_pic_get_irq(irq_domain);\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\nelse\r\npr_err("spurious interrupt!\n");\r\nraw_spin_lock(&desc->lock);\r\nchip->irq_ack(&desc->irq_data);\r\nif (!irqd_irq_disabled(&desc->irq_data) && chip->irq_unmask)\r\nchip->irq_unmask(&desc->irq_data);\r\nraw_spin_unlock(&desc->lock);\r\n}\r\nstatic void __hlwd_quiesce(void __iomem *io_base)\r\n{\r\nout_be32(io_base + HW_BROADWAY_IMR, 0);\r\nout_be32(io_base + HW_BROADWAY_ICR, 0xffffffff);\r\n}\r\nstruct irq_domain *hlwd_pic_init(struct device_node *np)\r\n{\r\nstruct irq_domain *irq_domain;\r\nstruct resource res;\r\nvoid __iomem *io_base;\r\nint retval;\r\nretval = of_address_to_resource(np, 0, &res);\r\nif (retval) {\r\npr_err("no io memory range found\n");\r\nreturn NULL;\r\n}\r\nio_base = ioremap(res.start, resource_size(&res));\r\nif (!io_base) {\r\npr_err("ioremap failed\n");\r\nreturn NULL;\r\n}\r\npr_info("controller at 0x%08x mapped to 0x%p\n", res.start, io_base);\r\n__hlwd_quiesce(io_base);\r\nirq_domain = irq_domain_add_linear(np, HLWD_NR_IRQS,\r\n&hlwd_irq_domain_ops, io_base);\r\nif (!irq_domain) {\r\npr_err("failed to allocate irq_domain\n");\r\niounmap(io_base);\r\nreturn NULL;\r\n}\r\nreturn irq_domain;\r\n}\r\nunsigned int hlwd_pic_get_irq(void)\r\n{\r\nreturn __hlwd_pic_get_irq(hlwd_irq_host);\r\n}\r\nvoid hlwd_pic_probe(void)\r\n{\r\nstruct irq_domain *host;\r\nstruct device_node *np;\r\nconst u32 *interrupts;\r\nint cascade_virq;\r\nfor_each_compatible_node(np, NULL, "nintendo,hollywood-pic") {\r\ninterrupts = of_get_property(np, "interrupts", NULL);\r\nif (interrupts) {\r\nhost = hlwd_pic_init(np);\r\nBUG_ON(!host);\r\ncascade_virq = irq_of_parse_and_map(np, 0);\r\nirq_set_handler_data(cascade_virq, host);\r\nirq_set_chained_handler(cascade_virq,\r\nhlwd_pic_irq_cascade);\r\nhlwd_irq_host = host;\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid hlwd_quiesce(void)\r\n{\r\nvoid __iomem *io_base = hlwd_irq_host->host_data;\r\n__hlwd_quiesce(io_base);\r\n}
