static void ena_safe_update_stat(u64 *src, u64 *dst,\r\nstruct u64_stats_sync *syncp)\r\n{\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(syncp);\r\n*(dst) = *src;\r\n} while (u64_stats_fetch_retry_irq(syncp, start));\r\n}\r\nstatic void ena_queue_stats(struct ena_adapter *adapter, u64 **data)\r\n{\r\nconst struct ena_stats *ena_stats;\r\nstruct ena_ring *ring;\r\nu64 *ptr;\r\nint i, j;\r\nfor (i = 0; i < adapter->num_queues; i++) {\r\nring = &adapter->tx_ring[i];\r\nfor (j = 0; j < ENA_STATS_ARRAY_TX; j++) {\r\nena_stats = &ena_stats_tx_strings[j];\r\nptr = (u64 *)((uintptr_t)&ring->tx_stats +\r\n(uintptr_t)ena_stats->stat_offset);\r\nena_safe_update_stat(ptr, (*data)++, &ring->syncp);\r\n}\r\nring = &adapter->rx_ring[i];\r\nfor (j = 0; j < ENA_STATS_ARRAY_RX; j++) {\r\nena_stats = &ena_stats_rx_strings[j];\r\nptr = (u64 *)((uintptr_t)&ring->rx_stats +\r\n(uintptr_t)ena_stats->stat_offset);\r\nena_safe_update_stat(ptr, (*data)++, &ring->syncp);\r\n}\r\n}\r\n}\r\nstatic void ena_dev_admin_queue_stats(struct ena_adapter *adapter, u64 **data)\r\n{\r\nconst struct ena_stats *ena_stats;\r\nu32 *ptr;\r\nint i;\r\nfor (i = 0; i < ENA_STATS_ARRAY_ENA_COM; i++) {\r\nena_stats = &ena_stats_ena_com_strings[i];\r\nptr = (u32 *)((uintptr_t)&adapter->ena_dev->admin_queue.stats +\r\n(uintptr_t)ena_stats->stat_offset);\r\n*(*data)++ = *ptr;\r\n}\r\n}\r\nstatic void ena_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats,\r\nu64 *data)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nconst struct ena_stats *ena_stats;\r\nu64 *ptr;\r\nint i;\r\nfor (i = 0; i < ENA_STATS_ARRAY_GLOBAL; i++) {\r\nena_stats = &ena_stats_global_strings[i];\r\nptr = (u64 *)((uintptr_t)&adapter->dev_stats +\r\n(uintptr_t)ena_stats->stat_offset);\r\nena_safe_update_stat(ptr, data++, &adapter->syncp);\r\n}\r\nena_queue_stats(adapter, &data);\r\nena_dev_admin_queue_stats(adapter, &data);\r\n}\r\nint ena_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nif (sset != ETH_SS_STATS)\r\nreturn -EOPNOTSUPP;\r\nreturn adapter->num_queues * (ENA_STATS_ARRAY_TX + ENA_STATS_ARRAY_RX)\r\n+ ENA_STATS_ARRAY_GLOBAL + ENA_STATS_ARRAY_ENA_COM;\r\n}\r\nstatic void ena_queue_strings(struct ena_adapter *adapter, u8 **data)\r\n{\r\nconst struct ena_stats *ena_stats;\r\nint i, j;\r\nfor (i = 0; i < adapter->num_queues; i++) {\r\nfor (j = 0; j < ENA_STATS_ARRAY_TX; j++) {\r\nena_stats = &ena_stats_tx_strings[j];\r\nsnprintf(*data, ETH_GSTRING_LEN,\r\n"queue_%u_tx_%s", i, ena_stats->name);\r\n(*data) += ETH_GSTRING_LEN;\r\n}\r\nfor (j = 0; j < ENA_STATS_ARRAY_RX; j++) {\r\nena_stats = &ena_stats_rx_strings[j];\r\nsnprintf(*data, ETH_GSTRING_LEN,\r\n"queue_%u_rx_%s", i, ena_stats->name);\r\n(*data) += ETH_GSTRING_LEN;\r\n}\r\n}\r\n}\r\nstatic void ena_com_dev_strings(u8 **data)\r\n{\r\nconst struct ena_stats *ena_stats;\r\nint i;\r\nfor (i = 0; i < ENA_STATS_ARRAY_ENA_COM; i++) {\r\nena_stats = &ena_stats_ena_com_strings[i];\r\nsnprintf(*data, ETH_GSTRING_LEN,\r\n"ena_admin_q_%s", ena_stats->name);\r\n(*data) += ETH_GSTRING_LEN;\r\n}\r\n}\r\nstatic void ena_get_strings(struct net_device *netdev, u32 sset, u8 *data)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nconst struct ena_stats *ena_stats;\r\nint i;\r\nif (sset != ETH_SS_STATS)\r\nreturn;\r\nfor (i = 0; i < ENA_STATS_ARRAY_GLOBAL; i++) {\r\nena_stats = &ena_stats_global_strings[i];\r\nmemcpy(data, ena_stats->name, ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nena_queue_strings(adapter, &data);\r\nena_com_dev_strings(&data);\r\n}\r\nstatic int ena_get_link_ksettings(struct net_device *netdev,\r\nstruct ethtool_link_ksettings *link_ksettings)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nstruct ena_com_dev *ena_dev = adapter->ena_dev;\r\nstruct ena_admin_get_feature_link_desc *link;\r\nstruct ena_admin_get_feat_resp feat_resp;\r\nint rc;\r\nrc = ena_com_get_link_params(ena_dev, &feat_resp);\r\nif (rc)\r\nreturn rc;\r\nlink = &feat_resp.u.link;\r\nlink_ksettings->base.speed = link->speed;\r\nif (link->flags & ENA_ADMIN_GET_FEATURE_LINK_DESC_AUTONEG_MASK) {\r\nethtool_link_ksettings_add_link_mode(link_ksettings,\r\nsupported, Autoneg);\r\nethtool_link_ksettings_add_link_mode(link_ksettings,\r\nsupported, Autoneg);\r\n}\r\nlink_ksettings->base.autoneg =\r\n(link->flags & ENA_ADMIN_GET_FEATURE_LINK_DESC_AUTONEG_MASK) ?\r\nAUTONEG_ENABLE : AUTONEG_DISABLE;\r\nlink_ksettings->base.duplex = DUPLEX_FULL;\r\nreturn 0;\r\n}\r\nstatic int ena_get_coalesce(struct net_device *net_dev,\r\nstruct ethtool_coalesce *coalesce)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(net_dev);\r\nstruct ena_com_dev *ena_dev = adapter->ena_dev;\r\nstruct ena_intr_moder_entry intr_moder_entry;\r\nif (!ena_com_interrupt_moderation_supported(ena_dev)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\ncoalesce->tx_coalesce_usecs =\r\nena_com_get_nonadaptive_moderation_interval_tx(ena_dev) /\r\nena_dev->intr_delay_resolution;\r\nif (!ena_com_get_adaptive_moderation_enabled(ena_dev)) {\r\ncoalesce->rx_coalesce_usecs =\r\nena_com_get_nonadaptive_moderation_interval_rx(ena_dev)\r\n/ ena_dev->intr_delay_resolution;\r\n} else {\r\nena_com_get_intr_moderation_entry(adapter->ena_dev, ENA_INTR_MODER_LOWEST, &intr_moder_entry);\r\ncoalesce->rx_coalesce_usecs_low = intr_moder_entry.intr_moder_interval;\r\ncoalesce->rx_max_coalesced_frames_low = intr_moder_entry.pkts_per_interval;\r\nena_com_get_intr_moderation_entry(adapter->ena_dev, ENA_INTR_MODER_MID, &intr_moder_entry);\r\ncoalesce->rx_coalesce_usecs = intr_moder_entry.intr_moder_interval;\r\ncoalesce->rx_max_coalesced_frames = intr_moder_entry.pkts_per_interval;\r\nena_com_get_intr_moderation_entry(adapter->ena_dev, ENA_INTR_MODER_HIGHEST, &intr_moder_entry);\r\ncoalesce->rx_coalesce_usecs_high = intr_moder_entry.intr_moder_interval;\r\ncoalesce->rx_max_coalesced_frames_high = intr_moder_entry.pkts_per_interval;\r\n}\r\ncoalesce->use_adaptive_rx_coalesce =\r\nena_com_get_adaptive_moderation_enabled(ena_dev);\r\nreturn 0;\r\n}\r\nstatic void ena_update_tx_rings_intr_moderation(struct ena_adapter *adapter)\r\n{\r\nunsigned int val;\r\nint i;\r\nval = ena_com_get_nonadaptive_moderation_interval_tx(adapter->ena_dev);\r\nfor (i = 0; i < adapter->num_queues; i++)\r\nadapter->tx_ring[i].smoothed_interval = val;\r\n}\r\nstatic int ena_set_coalesce(struct net_device *net_dev,\r\nstruct ethtool_coalesce *coalesce)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(net_dev);\r\nstruct ena_com_dev *ena_dev = adapter->ena_dev;\r\nstruct ena_intr_moder_entry intr_moder_entry;\r\nint rc;\r\nif (!ena_com_interrupt_moderation_supported(ena_dev)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (coalesce->rx_coalesce_usecs_irq ||\r\ncoalesce->rx_max_coalesced_frames_irq ||\r\ncoalesce->tx_coalesce_usecs_irq ||\r\ncoalesce->tx_max_coalesced_frames ||\r\ncoalesce->tx_max_coalesced_frames_irq ||\r\ncoalesce->stats_block_coalesce_usecs ||\r\ncoalesce->use_adaptive_tx_coalesce ||\r\ncoalesce->pkt_rate_low ||\r\ncoalesce->tx_coalesce_usecs_low ||\r\ncoalesce->tx_max_coalesced_frames_low ||\r\ncoalesce->pkt_rate_high ||\r\ncoalesce->tx_coalesce_usecs_high ||\r\ncoalesce->tx_max_coalesced_frames_high ||\r\ncoalesce->rate_sample_interval)\r\nreturn -EINVAL;\r\nrc = ena_com_update_nonadaptive_moderation_interval_tx(ena_dev,\r\ncoalesce->tx_coalesce_usecs);\r\nif (rc)\r\nreturn rc;\r\nena_update_tx_rings_intr_moderation(adapter);\r\nif (ena_com_get_adaptive_moderation_enabled(ena_dev)) {\r\nif (!coalesce->use_adaptive_rx_coalesce) {\r\nena_com_disable_adaptive_moderation(ena_dev);\r\nrc = ena_com_update_nonadaptive_moderation_interval_rx(ena_dev,\r\ncoalesce->rx_coalesce_usecs);\r\nreturn rc;\r\n}\r\n} else {\r\nif (coalesce->use_adaptive_rx_coalesce) {\r\nena_com_enable_adaptive_moderation(ena_dev);\r\n} else {\r\nrc = ena_com_update_nonadaptive_moderation_interval_rx(ena_dev,\r\ncoalesce->rx_coalesce_usecs);\r\nreturn rc;\r\n}\r\n}\r\nintr_moder_entry.intr_moder_interval = coalesce->rx_coalesce_usecs_low;\r\nintr_moder_entry.pkts_per_interval = coalesce->rx_max_coalesced_frames_low;\r\nintr_moder_entry.bytes_per_interval = ENA_INTR_BYTE_COUNT_NOT_SUPPORTED;\r\nena_com_init_intr_moderation_entry(adapter->ena_dev, ENA_INTR_MODER_LOWEST, &intr_moder_entry);\r\nintr_moder_entry.intr_moder_interval = coalesce->rx_coalesce_usecs;\r\nintr_moder_entry.pkts_per_interval = coalesce->rx_max_coalesced_frames;\r\nintr_moder_entry.bytes_per_interval = ENA_INTR_BYTE_COUNT_NOT_SUPPORTED;\r\nena_com_init_intr_moderation_entry(adapter->ena_dev, ENA_INTR_MODER_MID, &intr_moder_entry);\r\nintr_moder_entry.intr_moder_interval = coalesce->rx_coalesce_usecs_high;\r\nintr_moder_entry.pkts_per_interval = coalesce->rx_max_coalesced_frames_high;\r\nintr_moder_entry.bytes_per_interval = ENA_INTR_BYTE_COUNT_NOT_SUPPORTED;\r\nena_com_init_intr_moderation_entry(adapter->ena_dev, ENA_INTR_MODER_HIGHEST, &intr_moder_entry);\r\nreturn 0;\r\n}\r\nstatic u32 ena_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void ena_set_msglevel(struct net_device *netdev, u32 value)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nadapter->msg_enable = value;\r\n}\r\nstatic void ena_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(adapter->pdev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic void ena_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nstruct ena_ring *tx_ring = &adapter->tx_ring[0];\r\nstruct ena_ring *rx_ring = &adapter->rx_ring[0];\r\nring->rx_max_pending = rx_ring->ring_size;\r\nring->tx_max_pending = tx_ring->ring_size;\r\nring->rx_pending = rx_ring->ring_size;\r\nring->tx_pending = tx_ring->ring_size;\r\n}\r\nstatic u32 ena_flow_hash_to_flow_type(u16 hash_fields)\r\n{\r\nu32 data = 0;\r\nif (hash_fields & ENA_ADMIN_RSS_L2_DA)\r\ndata |= RXH_L2DA;\r\nif (hash_fields & ENA_ADMIN_RSS_L3_DA)\r\ndata |= RXH_IP_DST;\r\nif (hash_fields & ENA_ADMIN_RSS_L3_SA)\r\ndata |= RXH_IP_SRC;\r\nif (hash_fields & ENA_ADMIN_RSS_L4_DP)\r\ndata |= RXH_L4_B_2_3;\r\nif (hash_fields & ENA_ADMIN_RSS_L4_SP)\r\ndata |= RXH_L4_B_0_1;\r\nreturn data;\r\n}\r\nstatic u16 ena_flow_data_to_flow_hash(u32 hash_fields)\r\n{\r\nu16 data = 0;\r\nif (hash_fields & RXH_L2DA)\r\ndata |= ENA_ADMIN_RSS_L2_DA;\r\nif (hash_fields & RXH_IP_DST)\r\ndata |= ENA_ADMIN_RSS_L3_DA;\r\nif (hash_fields & RXH_IP_SRC)\r\ndata |= ENA_ADMIN_RSS_L3_SA;\r\nif (hash_fields & RXH_L4_B_2_3)\r\ndata |= ENA_ADMIN_RSS_L4_DP;\r\nif (hash_fields & RXH_L4_B_0_1)\r\ndata |= ENA_ADMIN_RSS_L4_SP;\r\nreturn data;\r\n}\r\nstatic int ena_get_rss_hash(struct ena_com_dev *ena_dev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nenum ena_admin_flow_hash_proto proto;\r\nu16 hash_fields;\r\nint rc;\r\ncmd->data = 0;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\nproto = ENA_ADMIN_RSS_TCP4;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nproto = ENA_ADMIN_RSS_UDP4;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nproto = ENA_ADMIN_RSS_TCP6;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nproto = ENA_ADMIN_RSS_UDP6;\r\nbreak;\r\ncase IPV4_FLOW:\r\nproto = ENA_ADMIN_RSS_IP4;\r\nbreak;\r\ncase IPV6_FLOW:\r\nproto = ENA_ADMIN_RSS_IP6;\r\nbreak;\r\ncase ETHER_FLOW:\r\nproto = ENA_ADMIN_RSS_NOT_IP;\r\nbreak;\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrc = ena_com_get_hash_ctrl(ena_dev, proto, &hash_fields);\r\nif (rc) {\r\nif (rc == -EPERM)\r\nrc = -EOPNOTSUPP;\r\nreturn rc;\r\n}\r\ncmd->data = ena_flow_hash_to_flow_type(hash_fields);\r\nreturn 0;\r\n}\r\nstatic int ena_set_rss_hash(struct ena_com_dev *ena_dev,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nenum ena_admin_flow_hash_proto proto;\r\nu16 hash_fields;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\nproto = ENA_ADMIN_RSS_TCP4;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nproto = ENA_ADMIN_RSS_UDP4;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\nproto = ENA_ADMIN_RSS_TCP6;\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nproto = ENA_ADMIN_RSS_UDP6;\r\nbreak;\r\ncase IPV4_FLOW:\r\nproto = ENA_ADMIN_RSS_IP4;\r\nbreak;\r\ncase IPV6_FLOW:\r\nproto = ENA_ADMIN_RSS_IP6;\r\nbreak;\r\ncase ETHER_FLOW:\r\nproto = ENA_ADMIN_RSS_NOT_IP;\r\nbreak;\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nhash_fields = ena_flow_data_to_flow_hash(cmd->data);\r\nreturn ena_com_fill_hash_ctrl(ena_dev, proto, hash_fields);\r\n}\r\nstatic int ena_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nint rc = 0;\r\nswitch (info->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nrc = ena_set_rss_hash(adapter->ena_dev, info);\r\nbreak;\r\ncase ETHTOOL_SRXCLSRLDEL:\r\ncase ETHTOOL_SRXCLSRLINS:\r\ndefault:\r\nnetif_err(adapter, drv, netdev,\r\n"Command parameter %d is not supported\n", info->cmd);\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn (rc == -EPERM) ? -EOPNOTSUPP : rc;\r\n}\r\nstatic int ena_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info,\r\nu32 *rules)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nint rc = 0;\r\nswitch (info->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ninfo->data = adapter->num_queues;\r\nrc = 0;\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\nrc = ena_get_rss_hash(adapter->ena_dev, info);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLCNT:\r\ncase ETHTOOL_GRXCLSRULE:\r\ncase ETHTOOL_GRXCLSRLALL:\r\ndefault:\r\nnetif_err(adapter, drv, netdev,\r\n"Command parameter %d is not supported\n", info->cmd);\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn (rc == -EPERM) ? -EOPNOTSUPP : rc;\r\n}\r\nstatic u32 ena_get_rxfh_indir_size(struct net_device *netdev)\r\n{\r\nreturn ENA_RX_RSS_TABLE_SIZE;\r\n}\r\nstatic u32 ena_get_rxfh_key_size(struct net_device *netdev)\r\n{\r\nreturn ENA_HASH_KEY_SIZE;\r\n}\r\nstatic int ena_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\r\nu8 *hfunc)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nenum ena_admin_hash_functions ena_func;\r\nu8 func;\r\nint rc;\r\nrc = ena_com_indirect_table_get(adapter->ena_dev, indir);\r\nif (rc)\r\nreturn rc;\r\nrc = ena_com_get_hash_function(adapter->ena_dev, &ena_func, key);\r\nif (rc)\r\nreturn rc;\r\nswitch (ena_func) {\r\ncase ENA_ADMIN_TOEPLITZ:\r\nfunc = ETH_RSS_HASH_TOP;\r\nbreak;\r\ncase ENA_ADMIN_CRC32:\r\nfunc = ETH_RSS_HASH_XOR;\r\nbreak;\r\ndefault:\r\nnetif_err(adapter, drv, netdev,\r\n"Command parameter is not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (hfunc)\r\n*hfunc = func;\r\nreturn rc;\r\n}\r\nstatic int ena_set_rxfh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *key, const u8 hfunc)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nstruct ena_com_dev *ena_dev = adapter->ena_dev;\r\nenum ena_admin_hash_functions func;\r\nint rc, i;\r\nif (indir) {\r\nfor (i = 0; i < ENA_RX_RSS_TABLE_SIZE; i++) {\r\nrc = ena_com_indirect_table_fill_entry(ena_dev,\r\nENA_IO_RXQ_IDX(indir[i]),\r\ni);\r\nif (unlikely(rc)) {\r\nnetif_err(adapter, drv, netdev,\r\n"Cannot fill indirect table (index is too large)\n");\r\nreturn rc;\r\n}\r\n}\r\nrc = ena_com_indirect_table_set(ena_dev);\r\nif (rc) {\r\nnetif_err(adapter, drv, netdev,\r\n"Cannot set indirect table\n");\r\nreturn rc == -EPERM ? -EOPNOTSUPP : rc;\r\n}\r\n}\r\nswitch (hfunc) {\r\ncase ETH_RSS_HASH_TOP:\r\nfunc = ENA_ADMIN_TOEPLITZ;\r\nbreak;\r\ncase ETH_RSS_HASH_XOR:\r\nfunc = ENA_ADMIN_CRC32;\r\nbreak;\r\ndefault:\r\nnetif_err(adapter, drv, netdev, "Unsupported hfunc %d\n",\r\nhfunc);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (key) {\r\nrc = ena_com_fill_hash_function(ena_dev, func, key,\r\nENA_HASH_KEY_SIZE,\r\n0xFFFFFFFF);\r\nif (unlikely(rc)) {\r\nnetif_err(adapter, drv, netdev, "Cannot fill key\n");\r\nreturn rc == -EPERM ? -EOPNOTSUPP : rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ena_get_channels(struct net_device *netdev,\r\nstruct ethtool_channels *channels)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nchannels->max_rx = ENA_MAX_NUM_IO_QUEUES;\r\nchannels->max_tx = ENA_MAX_NUM_IO_QUEUES;\r\nchannels->max_other = 0;\r\nchannels->max_combined = 0;\r\nchannels->rx_count = adapter->num_queues;\r\nchannels->tx_count = adapter->num_queues;\r\nchannels->other_count = 0;\r\nchannels->combined_count = 0;\r\n}\r\nstatic int ena_get_tunable(struct net_device *netdev,\r\nconst struct ethtool_tunable *tuna, void *data)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nint ret = 0;\r\nswitch (tuna->id) {\r\ncase ETHTOOL_RX_COPYBREAK:\r\n*(u32 *)data = adapter->rx_copybreak;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ena_set_tunable(struct net_device *netdev,\r\nconst struct ethtool_tunable *tuna,\r\nconst void *data)\r\n{\r\nstruct ena_adapter *adapter = netdev_priv(netdev);\r\nint ret = 0;\r\nu32 len;\r\nswitch (tuna->id) {\r\ncase ETHTOOL_RX_COPYBREAK:\r\nlen = *(u32 *)data;\r\nif (len > adapter->netdev->mtu) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nadapter->rx_copybreak = len;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid ena_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &ena_ethtool_ops;\r\n}\r\nstatic void ena_dump_stats_ex(struct ena_adapter *adapter, u8 *buf)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu8 *strings_buf;\r\nu64 *data_buf;\r\nint strings_num;\r\nint i, rc;\r\nstrings_num = ena_get_sset_count(netdev, ETH_SS_STATS);\r\nif (strings_num <= 0) {\r\nnetif_err(adapter, drv, netdev, "Can't get stats num\n");\r\nreturn;\r\n}\r\nstrings_buf = devm_kzalloc(&adapter->pdev->dev,\r\nstrings_num * ETH_GSTRING_LEN,\r\nGFP_ATOMIC);\r\nif (!strings_buf) {\r\nnetif_err(adapter, drv, netdev,\r\n"failed to alloc strings_buf\n");\r\nreturn;\r\n}\r\ndata_buf = devm_kzalloc(&adapter->pdev->dev,\r\nstrings_num * sizeof(u64),\r\nGFP_ATOMIC);\r\nif (!data_buf) {\r\nnetif_err(adapter, drv, netdev,\r\n"failed to allocate data buf\n");\r\ndevm_kfree(&adapter->pdev->dev, strings_buf);\r\nreturn;\r\n}\r\nena_get_strings(netdev, ETH_SS_STATS, strings_buf);\r\nena_get_ethtool_stats(netdev, NULL, data_buf);\r\nif (buf)\r\nfor (i = 0; i < strings_num; i++) {\r\nrc = snprintf(buf, ETH_GSTRING_LEN + sizeof(u64),\r\n"%s %llu\n",\r\nstrings_buf + i * ETH_GSTRING_LEN,\r\ndata_buf[i]);\r\nbuf += rc;\r\n}\r\nelse\r\nfor (i = 0; i < strings_num; i++)\r\nnetif_err(adapter, drv, netdev, "%s: %llu\n",\r\nstrings_buf + i * ETH_GSTRING_LEN,\r\ndata_buf[i]);\r\ndevm_kfree(&adapter->pdev->dev, strings_buf);\r\ndevm_kfree(&adapter->pdev->dev, data_buf);\r\n}\r\nvoid ena_dump_stats_to_buf(struct ena_adapter *adapter, u8 *buf)\r\n{\r\nif (!buf)\r\nreturn;\r\nena_dump_stats_ex(adapter, buf);\r\n}\r\nvoid ena_dump_stats_to_dmesg(struct ena_adapter *adapter)\r\n{\r\nena_dump_stats_ex(adapter, NULL);\r\n}
