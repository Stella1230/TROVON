static inline void __iomem *hip04_dist_base(struct irq_data *d)\r\n{\r\nstruct hip04_irq_data *hip04_data = irq_data_get_irq_chip_data(d);\r\nreturn hip04_data->dist_base;\r\n}\r\nstatic inline void __iomem *hip04_cpu_base(struct irq_data *d)\r\n{\r\nstruct hip04_irq_data *hip04_data = irq_data_get_irq_chip_data(d);\r\nreturn hip04_data->cpu_base;\r\n}\r\nstatic inline unsigned int hip04_irq(struct irq_data *d)\r\n{\r\nreturn d->hwirq;\r\n}\r\nstatic void hip04_mask_irq(struct irq_data *d)\r\n{\r\nu32 mask = 1 << (hip04_irq(d) % 32);\r\nraw_spin_lock(&irq_controller_lock);\r\nwritel_relaxed(mask, hip04_dist_base(d) + GIC_DIST_ENABLE_CLEAR +\r\n(hip04_irq(d) / 32) * 4);\r\nraw_spin_unlock(&irq_controller_lock);\r\n}\r\nstatic void hip04_unmask_irq(struct irq_data *d)\r\n{\r\nu32 mask = 1 << (hip04_irq(d) % 32);\r\nraw_spin_lock(&irq_controller_lock);\r\nwritel_relaxed(mask, hip04_dist_base(d) + GIC_DIST_ENABLE_SET +\r\n(hip04_irq(d) / 32) * 4);\r\nraw_spin_unlock(&irq_controller_lock);\r\n}\r\nstatic void hip04_eoi_irq(struct irq_data *d)\r\n{\r\nwritel_relaxed(hip04_irq(d), hip04_cpu_base(d) + GIC_CPU_EOI);\r\n}\r\nstatic int hip04_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nvoid __iomem *base = hip04_dist_base(d);\r\nunsigned int irq = hip04_irq(d);\r\nint ret;\r\nif (irq < 16)\r\nreturn -EINVAL;\r\nif (irq >= 32 && type != IRQ_TYPE_LEVEL_HIGH &&\r\ntype != IRQ_TYPE_EDGE_RISING)\r\nreturn -EINVAL;\r\nraw_spin_lock(&irq_controller_lock);\r\nret = gic_configure_irq(irq, type, base, NULL);\r\nraw_spin_unlock(&irq_controller_lock);\r\nreturn ret;\r\n}\r\nstatic int hip04_irq_set_affinity(struct irq_data *d,\r\nconst struct cpumask *mask_val,\r\nbool force)\r\n{\r\nvoid __iomem *reg;\r\nunsigned int cpu, shift = (hip04_irq(d) % 2) * 16;\r\nu32 val, mask, bit;\r\nif (!force)\r\ncpu = cpumask_any_and(mask_val, cpu_online_mask);\r\nelse\r\ncpu = cpumask_first(mask_val);\r\nif (cpu >= NR_HIP04_CPU_IF || cpu >= nr_cpu_ids)\r\nreturn -EINVAL;\r\nraw_spin_lock(&irq_controller_lock);\r\nreg = hip04_dist_base(d) + GIC_DIST_TARGET + ((hip04_irq(d) * 2) & ~3);\r\nmask = 0xffff << shift;\r\nbit = hip04_cpu_map[cpu] << shift;\r\nval = readl_relaxed(reg) & ~mask;\r\nwritel_relaxed(val | bit, reg);\r\nraw_spin_unlock(&irq_controller_lock);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic void __exception_irq_entry hip04_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 irqstat, irqnr;\r\nvoid __iomem *cpu_base = hip04_data.cpu_base;\r\ndo {\r\nirqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);\r\nirqnr = irqstat & GICC_IAR_INT_ID_MASK;\r\nif (likely(irqnr > 15 && irqnr <= HIP04_MAX_IRQS)) {\r\nhandle_domain_irq(hip04_data.domain, irqnr, regs);\r\ncontinue;\r\n}\r\nif (irqnr < 16) {\r\nwritel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);\r\n#ifdef CONFIG_SMP\r\nhandle_IPI(irqnr, regs);\r\n#endif\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\n}\r\nstatic u16 hip04_get_cpumask(struct hip04_irq_data *intc)\r\n{\r\nvoid __iomem *base = intc->dist_base;\r\nu32 mask, i;\r\nfor (i = mask = 0; i < 32; i += 2) {\r\nmask = readl_relaxed(base + GIC_DIST_TARGET + i * 2);\r\nmask |= mask >> 16;\r\nif (mask)\r\nbreak;\r\n}\r\nif (!mask)\r\npr_crit("GIC CPU mask not found - kernel will fail to boot.\n");\r\nreturn mask;\r\n}\r\nstatic void __init hip04_irq_dist_init(struct hip04_irq_data *intc)\r\n{\r\nunsigned int i;\r\nu32 cpumask;\r\nunsigned int nr_irqs = intc->nr_irqs;\r\nvoid __iomem *base = intc->dist_base;\r\nwritel_relaxed(0, base + GIC_DIST_CTRL);\r\ncpumask = hip04_get_cpumask(intc);\r\ncpumask |= cpumask << 16;\r\nfor (i = 32; i < nr_irqs; i += 2)\r\nwritel_relaxed(cpumask, base + GIC_DIST_TARGET + ((i * 2) & ~3));\r\ngic_dist_config(base, nr_irqs, NULL);\r\nwritel_relaxed(1, base + GIC_DIST_CTRL);\r\n}\r\nstatic void hip04_irq_cpu_init(struct hip04_irq_data *intc)\r\n{\r\nvoid __iomem *dist_base = intc->dist_base;\r\nvoid __iomem *base = intc->cpu_base;\r\nunsigned int cpu_mask, cpu = smp_processor_id();\r\nint i;\r\nBUG_ON(cpu >= NR_HIP04_CPU_IF);\r\ncpu_mask = hip04_get_cpumask(intc);\r\nhip04_cpu_map[cpu] = cpu_mask;\r\nfor (i = 0; i < NR_HIP04_CPU_IF; i++)\r\nif (i != cpu)\r\nhip04_cpu_map[i] &= ~cpu_mask;\r\ngic_cpu_config(dist_base, NULL);\r\nwritel_relaxed(0xf0, base + GIC_CPU_PRIMASK);\r\nwritel_relaxed(1, base + GIC_CPU_CTRL);\r\n}\r\nstatic void hip04_raise_softirq(const struct cpumask *mask, unsigned int irq)\r\n{\r\nint cpu;\r\nunsigned long flags, map = 0;\r\nraw_spin_lock_irqsave(&irq_controller_lock, flags);\r\nfor_each_cpu(cpu, mask)\r\nmap |= hip04_cpu_map[cpu];\r\ndmb(ishst);\r\nwritel_relaxed(map << 8 | irq, hip04_data.dist_base + GIC_DIST_SOFTINT);\r\nraw_spin_unlock_irqrestore(&irq_controller_lock, flags);\r\n}\r\nstatic int hip04_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nif (hw < 32) {\r\nirq_set_percpu_devid(irq);\r\nirq_set_chip_and_handler(irq, &hip04_irq_chip,\r\nhandle_percpu_devid_irq);\r\nirq_set_status_flags(irq, IRQ_NOAUTOEN);\r\n} else {\r\nirq_set_chip_and_handler(irq, &hip04_irq_chip,\r\nhandle_fasteoi_irq);\r\nirq_set_probe(irq);\r\n}\r\nirq_set_chip_data(irq, d->host_data);\r\nreturn 0;\r\n}\r\nstatic int hip04_irq_domain_xlate(struct irq_domain *d,\r\nstruct device_node *controller,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nunsigned long ret = 0;\r\nif (irq_domain_get_of_node(d) != controller)\r\nreturn -EINVAL;\r\nif (intsize < 3)\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[1] + 16;\r\nif (!intspec[0])\r\n*out_hwirq += 16;\r\n*out_type = intspec[2] & IRQ_TYPE_SENSE_MASK;\r\nreturn ret;\r\n}\r\nstatic int hip04_irq_starting_cpu(unsigned int cpu)\r\n{\r\nhip04_irq_cpu_init(&hip04_data);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nhip04_of_init(struct device_node *node, struct device_node *parent)\r\n{\r\nirq_hw_number_t hwirq_base = 16;\r\nint nr_irqs, irq_base, i;\r\nif (WARN_ON(!node))\r\nreturn -ENODEV;\r\nhip04_data.dist_base = of_iomap(node, 0);\r\nWARN(!hip04_data.dist_base, "fail to map hip04 intc dist registers\n");\r\nhip04_data.cpu_base = of_iomap(node, 1);\r\nWARN(!hip04_data.cpu_base, "unable to map hip04 intc cpu registers\n");\r\nfor (i = 0; i < NR_HIP04_CPU_IF; i++)\r\nhip04_cpu_map[i] = 0xffff;\r\nnr_irqs = readl_relaxed(hip04_data.dist_base + GIC_DIST_CTR) & 0x1f;\r\nnr_irqs = (nr_irqs + 1) * 32;\r\nif (nr_irqs > HIP04_MAX_IRQS)\r\nnr_irqs = HIP04_MAX_IRQS;\r\nhip04_data.nr_irqs = nr_irqs;\r\nnr_irqs -= hwirq_base;\r\nirq_base = irq_alloc_descs(-1, hwirq_base, nr_irqs, numa_node_id());\r\nif (irq_base < 0) {\r\npr_err("failed to allocate IRQ numbers\n");\r\nreturn -EINVAL;\r\n}\r\nhip04_data.domain = irq_domain_add_legacy(node, nr_irqs, irq_base,\r\nhwirq_base,\r\n&hip04_irq_domain_ops,\r\n&hip04_data);\r\nif (WARN_ON(!hip04_data.domain))\r\nreturn -EINVAL;\r\n#ifdef CONFIG_SMP\r\nset_smp_cross_call(hip04_raise_softirq);\r\n#endif\r\nset_handle_irq(hip04_handle_irq);\r\nhip04_irq_dist_init(&hip04_data);\r\ncpuhp_setup_state(CPUHP_AP_IRQ_HIP04_STARTING, "irqchip/hip04:starting",\r\nhip04_irq_starting_cpu, NULL);\r\nreturn 0;\r\n}
