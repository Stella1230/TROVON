static int adc081c_read_raw(struct iio_dev *iio,\r\nstruct iio_chan_spec const *channel, int *value,\r\nint *shift, long mask)\r\n{\r\nstruct adc081c *adc = iio_priv(iio);\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = i2c_smbus_read_word_swapped(adc->i2c, REG_CONV_RES);\r\nif (err < 0)\r\nreturn err;\r\n*value = (err & 0xFFF) >> (12 - adc->bits);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nerr = regulator_get_voltage(adc->ref);\r\nif (err < 0)\r\nreturn err;\r\n*value = err / 1000;\r\n*shift = adc->bits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic irqreturn_t adc081c_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct adc081c *data = iio_priv(indio_dev);\r\nu16 buf[8];\r\nint ret;\r\nret = i2c_smbus_read_word_swapped(data->i2c, REG_CONV_RES);\r\nif (ret < 0)\r\ngoto out;\r\nbuf[0] = ret;\r\niio_push_to_buffers_with_timestamp(indio_dev, buf,\r\niio_get_time_ns(indio_dev));\r\nout:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adc081c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *iio;\r\nstruct adc081c *adc;\r\nstruct adcxx1c_model *model;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_WORD_DATA))\r\nreturn -EOPNOTSUPP;\r\nif (ACPI_COMPANION(&client->dev)) {\r\nconst struct acpi_device_id *ad_id;\r\nad_id = acpi_match_device(client->dev.driver->acpi_match_table,\r\n&client->dev);\r\nif (!ad_id)\r\nreturn -ENODEV;\r\nmodel = &adcxx1c_models[ad_id->driver_data];\r\n} else {\r\nmodel = &adcxx1c_models[id->driver_data];\r\n}\r\niio = devm_iio_device_alloc(&client->dev, sizeof(*adc));\r\nif (!iio)\r\nreturn -ENOMEM;\r\nadc = iio_priv(iio);\r\nadc->i2c = client;\r\nadc->bits = model->bits;\r\nadc->ref = devm_regulator_get(&client->dev, "vref");\r\nif (IS_ERR(adc->ref))\r\nreturn PTR_ERR(adc->ref);\r\nerr = regulator_enable(adc->ref);\r\nif (err < 0)\r\nreturn err;\r\niio->dev.parent = &client->dev;\r\niio->dev.of_node = client->dev.of_node;\r\niio->name = dev_name(&client->dev);\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->info = &adc081c_info;\r\niio->channels = model->channels;\r\niio->num_channels = ADC081C_NUM_CHANNELS;\r\nerr = iio_triggered_buffer_setup(iio, NULL, adc081c_trigger_handler, NULL);\r\nif (err < 0) {\r\ndev_err(&client->dev, "iio triggered buffer setup failed\n");\r\ngoto err_regulator_disable;\r\n}\r\nerr = iio_device_register(iio);\r\nif (err < 0)\r\ngoto err_buffer_cleanup;\r\ni2c_set_clientdata(client, iio);\r\nreturn 0;\r\nerr_buffer_cleanup:\r\niio_triggered_buffer_cleanup(iio);\r\nerr_regulator_disable:\r\nregulator_disable(adc->ref);\r\nreturn err;\r\n}\r\nstatic int adc081c_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *iio = i2c_get_clientdata(client);\r\nstruct adc081c *adc = iio_priv(iio);\r\niio_device_unregister(iio);\r\niio_triggered_buffer_cleanup(iio);\r\nregulator_disable(adc->ref);\r\nreturn 0;\r\n}
