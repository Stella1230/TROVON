static int __init ima_template_setup(char *str)\r\n{\r\nstruct ima_template_desc *template_desc;\r\nint template_len = strlen(str);\r\nif (ima_template)\r\nreturn 1;\r\nima_init_template_list();\r\ntemplate_desc = lookup_template_desc(str);\r\nif (!template_desc) {\r\npr_err("template %s not found, using %s\n",\r\nstr, CONFIG_IMA_DEFAULT_TEMPLATE);\r\nreturn 1;\r\n}\r\nif (template_len == 3 && strcmp(str, IMA_TEMPLATE_IMA_NAME) == 0 &&\r\nima_hash_algo != HASH_ALGO_SHA1 && ima_hash_algo != HASH_ALGO_MD5) {\r\npr_err("template does not support hash alg\n");\r\nreturn 1;\r\n}\r\nima_template = template_desc;\r\nreturn 1;\r\n}\r\nstatic int __init ima_template_fmt_setup(char *str)\r\n{\r\nint num_templates = ARRAY_SIZE(builtin_templates);\r\nif (ima_template)\r\nreturn 1;\r\nif (template_desc_init_fields(str, NULL, NULL) < 0) {\r\npr_err("format string '%s' not valid, using template %s\n",\r\nstr, CONFIG_IMA_DEFAULT_TEMPLATE);\r\nreturn 1;\r\n}\r\nbuiltin_templates[num_templates - 1].fmt = str;\r\nima_template = builtin_templates + num_templates - 1;\r\nreturn 1;\r\n}\r\nstatic struct ima_template_desc *lookup_template_desc(const char *name)\r\n{\r\nstruct ima_template_desc *template_desc;\r\nint found = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\r\nif ((strcmp(template_desc->name, name) == 0) ||\r\n(strcmp(template_desc->fmt, name) == 0)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn found ? template_desc : NULL;\r\n}\r\nstatic struct ima_template_field *lookup_template_field(const char *field_id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(supported_fields); i++)\r\nif (strncmp(supported_fields[i].field_id, field_id,\r\nIMA_TEMPLATE_FIELD_ID_MAX_LEN) == 0)\r\nreturn &supported_fields[i];\r\nreturn NULL;\r\n}\r\nstatic int template_fmt_size(const char *template_fmt)\r\n{\r\nchar c;\r\nint template_fmt_len = strlen(template_fmt);\r\nint i = 0, j = 0;\r\nwhile (i < template_fmt_len) {\r\nc = template_fmt[i];\r\nif (c == '|')\r\nj++;\r\ni++;\r\n}\r\nreturn j + 1;\r\n}\r\nstatic int template_desc_init_fields(const char *template_fmt,\r\nstruct ima_template_field ***fields,\r\nint *num_fields)\r\n{\r\nconst char *template_fmt_ptr;\r\nstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\r\nint template_num_fields;\r\nint i, len;\r\nif (num_fields && *num_fields > 0)\r\nreturn 0;\r\ntemplate_num_fields = template_fmt_size(template_fmt);\r\nif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\r\npr_err("format string '%s' contains too many fields\n",\r\ntemplate_fmt);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\r\ni++, template_fmt_ptr += len + 1) {\r\nchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\r\nlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\r\nif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\r\npr_err("Invalid field with length %d\n", len);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(tmp_field_id, template_fmt_ptr, len);\r\ntmp_field_id[len] = '\0';\r\nfound_fields[i] = lookup_template_field(tmp_field_id);\r\nif (!found_fields[i]) {\r\npr_err("field '%s' not found\n", tmp_field_id);\r\nreturn -ENOENT;\r\n}\r\n}\r\nif (fields && num_fields) {\r\n*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\r\nif (*fields == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*fields, found_fields, i * sizeof(*fields));\r\n*num_fields = i;\r\n}\r\nreturn 0;\r\n}\r\nvoid ima_init_template_list(void)\r\n{\r\nint i;\r\nif (!list_empty(&defined_templates))\r\nreturn;\r\nspin_lock(&template_list);\r\nfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\r\nlist_add_tail_rcu(&builtin_templates[i].list,\r\n&defined_templates);\r\n}\r\nspin_unlock(&template_list);\r\n}\r\nstruct ima_template_desc *ima_template_desc_current(void)\r\n{\r\nif (!ima_template) {\r\nima_init_template_list();\r\nima_template =\r\nlookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\r\n}\r\nreturn ima_template;\r\n}\r\nint __init ima_init_template(void)\r\n{\r\nstruct ima_template_desc *template = ima_template_desc_current();\r\nint result;\r\nresult = template_desc_init_fields(template->fmt,\r\n&(template->fields),\r\n&(template->num_fields));\r\nif (result < 0)\r\npr_err("template %s init failed, result: %d\n",\r\n(strlen(template->name) ?\r\ntemplate->name : template->fmt), result);\r\nreturn result;\r\n}\r\nstatic struct ima_template_desc *restore_template_fmt(char *template_name)\r\n{\r\nstruct ima_template_desc *template_desc = NULL;\r\nint ret;\r\nret = template_desc_init_fields(template_name, NULL, NULL);\r\nif (ret < 0) {\r\npr_err("attempting to initialize the template \"%s\" failed\n",\r\ntemplate_name);\r\ngoto out;\r\n}\r\ntemplate_desc = kzalloc(sizeof(*template_desc), GFP_KERNEL);\r\nif (!template_desc)\r\ngoto out;\r\ntemplate_desc->name = "";\r\ntemplate_desc->fmt = kstrdup(template_name, GFP_KERNEL);\r\nif (!template_desc->fmt)\r\ngoto out;\r\nspin_lock(&template_list);\r\nlist_add_tail_rcu(&template_desc->list, &defined_templates);\r\nspin_unlock(&template_list);\r\nout:\r\nreturn template_desc;\r\n}\r\nstatic int ima_restore_template_data(struct ima_template_desc *template_desc,\r\nvoid *template_data,\r\nint template_data_size,\r\nstruct ima_template_entry **entry)\r\n{\r\nstruct binary_field_data {\r\nu32 len;\r\nu8 data[0];\r\n} __packed;\r\nstruct binary_field_data *field_data;\r\nint offset = 0;\r\nint ret = 0;\r\nint i;\r\n*entry = kzalloc(sizeof(**entry) +\r\ntemplate_desc->num_fields * sizeof(struct ima_field_data),\r\nGFP_NOFS);\r\nif (!*entry)\r\nreturn -ENOMEM;\r\n(*entry)->template_desc = template_desc;\r\nfor (i = 0; i < template_desc->num_fields; i++) {\r\nfield_data = template_data + offset;\r\nif (offset > (template_data_size - sizeof(*field_data))) {\r\npr_err("Restoring the template field failed\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\noffset += sizeof(*field_data);\r\nif (ima_canonical_fmt)\r\nfield_data->len = le32_to_cpu(field_data->len);\r\nif (offset > (template_data_size - field_data->len)) {\r\npr_err("Restoring the template field data failed\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\noffset += field_data->len;\r\n(*entry)->template_data[i].len = field_data->len;\r\n(*entry)->template_data_len += sizeof(field_data->len);\r\n(*entry)->template_data[i].data =\r\nkzalloc(field_data->len + 1, GFP_KERNEL);\r\nif (!(*entry)->template_data[i].data) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nmemcpy((*entry)->template_data[i].data, field_data->data,\r\nfield_data->len);\r\n(*entry)->template_data_len += field_data->len;\r\n}\r\nif (ret < 0) {\r\nima_free_template_entry(*entry);\r\n*entry = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint ima_restore_measurement_list(loff_t size, void *buf)\r\n{\r\nstruct binary_hdr_v1 {\r\nu32 pcr;\r\nu8 digest[TPM_DIGEST_SIZE];\r\nu32 template_name_len;\r\nchar template_name[0];\r\n} __packed;\r\nchar template_name[MAX_TEMPLATE_NAME_LEN];\r\nstruct binary_data_v1 {\r\nu32 template_data_size;\r\nchar template_data[0];\r\n} __packed;\r\nstruct ima_kexec_hdr *khdr = buf;\r\nstruct binary_hdr_v1 *hdr_v1;\r\nstruct binary_data_v1 *data_v1;\r\nvoid *bufp = buf + sizeof(*khdr);\r\nvoid *bufendp;\r\nstruct ima_template_entry *entry;\r\nstruct ima_template_desc *template_desc;\r\nunsigned long count = 0;\r\nint ret = 0;\r\nif (!buf || size < sizeof(*khdr))\r\nreturn 0;\r\nif (ima_canonical_fmt) {\r\nkhdr->version = le16_to_cpu(khdr->version);\r\nkhdr->count = le64_to_cpu(khdr->count);\r\nkhdr->buffer_size = le64_to_cpu(khdr->buffer_size);\r\n}\r\nif (khdr->version != 1) {\r\npr_err("attempting to restore a incompatible measurement list");\r\nreturn -EINVAL;\r\n}\r\nif (khdr->count > ULONG_MAX - 1) {\r\npr_err("attempting to restore too many measurements");\r\nreturn -EINVAL;\r\n}\r\nbufendp = buf + khdr->buffer_size;\r\nwhile ((bufp < bufendp) && (count++ < khdr->count)) {\r\nhdr_v1 = bufp;\r\nif (bufp > (bufendp - sizeof(*hdr_v1))) {\r\npr_err("attempting to restore partial measurement\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbufp += sizeof(*hdr_v1);\r\nif (ima_canonical_fmt)\r\nhdr_v1->template_name_len =\r\nle32_to_cpu(hdr_v1->template_name_len);\r\nif ((hdr_v1->template_name_len >= MAX_TEMPLATE_NAME_LEN) ||\r\n(bufp > (bufendp - hdr_v1->template_name_len))) {\r\npr_err("attempting to restore a template name \\r\nthat is too long\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata_v1 = bufp += (u_int8_t)hdr_v1->template_name_len;\r\nmemcpy(template_name, hdr_v1->template_name,\r\nhdr_v1->template_name_len);\r\ntemplate_name[hdr_v1->template_name_len] = 0;\r\nif (strcmp(template_name, "ima") == 0) {\r\npr_err("attempting to restore an unsupported \\r\ntemplate \"%s\" failed\n", template_name);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ntemplate_desc = lookup_template_desc(template_name);\r\nif (!template_desc) {\r\ntemplate_desc = restore_template_fmt(template_name);\r\nif (!template_desc)\r\nbreak;\r\n}\r\nret = template_desc_init_fields(template_desc->fmt,\r\n&(template_desc->fields),\r\n&(template_desc->num_fields));\r\nif (ret < 0) {\r\npr_err("attempting to restore the template fmt \"%s\" \\r\nfailed\n", template_desc->fmt);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (bufp > (bufendp - sizeof(data_v1->template_data_size))) {\r\npr_err("restoring the template data size failed\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbufp += (u_int8_t) sizeof(data_v1->template_data_size);\r\nif (ima_canonical_fmt)\r\ndata_v1->template_data_size =\r\nle32_to_cpu(data_v1->template_data_size);\r\nif (bufp > (bufendp - data_v1->template_data_size)) {\r\npr_err("restoring the template data failed\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nbufp += data_v1->template_data_size;\r\nret = ima_restore_template_data(template_desc,\r\ndata_v1->template_data,\r\ndata_v1->template_data_size,\r\n&entry);\r\nif (ret < 0)\r\nbreak;\r\nmemcpy(entry->digest, hdr_v1->digest, TPM_DIGEST_SIZE);\r\nentry->pcr =\r\n!ima_canonical_fmt ? hdr_v1->pcr : le32_to_cpu(hdr_v1->pcr);\r\nret = ima_restore_measurement_entry(entry);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}
