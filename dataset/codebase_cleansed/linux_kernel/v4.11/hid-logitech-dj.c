static void logi_dj_recv_destroy_djhid_device(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct dj_device *dj_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\ndj_dev = djrcv_dev->paired_dj_devices[dj_report->device_index];\r\ndjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nif (dj_dev != NULL) {\r\nhid_destroy_device(dj_dev->hdev);\r\nkfree(dj_dev);\r\n} else {\r\ndev_err(&djrcv_dev->hdev->dev, "%s: can't destroy a NULL device\n",\r\n__func__);\r\n}\r\n}\r\nstatic void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct hid_device *djrcv_hdev = djrcv_dev->hdev;\r\nstruct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nstruct hid_device *dj_hiddev;\r\nstruct dj_device *dj_dev;\r\nunsigned char tmpstr[3];\r\nif (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &\r\nSPFUNCTION_DEVICE_LIST_EMPTY) {\r\ndbg_hid("%s: device list is empty\n", __func__);\r\ndjrcv_dev->querying_devices = false;\r\nreturn;\r\n}\r\nif (djrcv_dev->paired_dj_devices[dj_report->device_index]) {\r\ndbg_hid("%s: device is already known\n", __func__);\r\nreturn;\r\n}\r\ndj_hiddev = hid_allocate_device();\r\nif (IS_ERR(dj_hiddev)) {\r\ndev_err(&djrcv_hdev->dev, "%s: hid_allocate_device failed\n",\r\n__func__);\r\nreturn;\r\n}\r\ndj_hiddev->ll_driver = &logi_dj_ll_driver;\r\ndj_hiddev->dev.parent = &djrcv_hdev->dev;\r\ndj_hiddev->bus = BUS_USB;\r\ndj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);\r\ndj_hiddev->product =\r\n(dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB]\r\n<< 8) |\r\ndj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB];\r\nsnprintf(dj_hiddev->name, sizeof(dj_hiddev->name),\r\n"Logitech Unifying Device. Wireless PID:%04x",\r\ndj_hiddev->product);\r\ndj_hiddev->group = HID_GROUP_LOGITECH_DJ_DEVICE;\r\nusb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));\r\nsnprintf(tmpstr, sizeof(tmpstr), ":%d", dj_report->device_index);\r\nstrlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));\r\ndj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);\r\nif (!dj_dev) {\r\ndev_err(&djrcv_hdev->dev, "%s: failed allocating dj_device\n",\r\n__func__);\r\ngoto dj_device_allocate_fail;\r\n}\r\ndj_dev->reports_supported = get_unaligned_le32(\r\ndj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);\r\ndj_dev->hdev = dj_hiddev;\r\ndj_dev->dj_receiver_dev = djrcv_dev;\r\ndj_dev->device_index = dj_report->device_index;\r\ndj_hiddev->driver_data = dj_dev;\r\ndjrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;\r\nif (hid_add_device(dj_hiddev)) {\r\ndev_err(&djrcv_hdev->dev, "%s: failed adding dj_device\n",\r\n__func__);\r\ngoto hid_add_device_fail;\r\n}\r\nreturn;\r\nhid_add_device_fail:\r\ndjrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;\r\nkfree(dj_dev);\r\ndj_device_allocate_fail:\r\nhid_destroy_device(dj_hiddev);\r\n}\r\nstatic void delayedwork_callback(struct work_struct *work)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev =\r\ncontainer_of(work, struct dj_receiver_dev, work);\r\nstruct dj_report dj_report;\r\nunsigned long flags;\r\nint count;\r\nint retval;\r\ndbg_hid("%s\n", __func__);\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\ncount = kfifo_out(&djrcv_dev->notif_fifo, &dj_report,\r\nsizeof(struct dj_report));\r\nif (count != sizeof(struct dj_report)) {\r\ndev_err(&djrcv_dev->hdev->dev, "%s: workitem triggered without "\r\n"notifications available\n", __func__);\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nreturn;\r\n}\r\nif (!kfifo_is_empty(&djrcv_dev->notif_fifo)) {\r\nif (schedule_work(&djrcv_dev->work) == 0) {\r\ndbg_hid("%s: did not schedule the work item, was "\r\n"already queued\n", __func__);\r\n}\r\n}\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nswitch (dj_report.report_type) {\r\ncase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\r\nlogi_dj_recv_add_djhid_device(djrcv_dev, &dj_report);\r\nbreak;\r\ncase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\r\nlogi_dj_recv_destroy_djhid_device(djrcv_dev, &dj_report);\r\nbreak;\r\ndefault:\r\nif (!djrcv_dev->paired_dj_devices[dj_report.device_index]) {\r\nretval = logi_dj_recv_query_paired_devices(djrcv_dev);\r\nif (!retval) {\r\nbreak;\r\n}\r\ndev_err(&djrcv_dev->hdev->dev,\r\n"%s:logi_dj_recv_query_paired_devices "\r\n"error:%d\n", __func__, retval);\r\n}\r\ndbg_hid("%s: unexpected report type\n", __func__);\r\n}\r\n}\r\nstatic void logi_dj_recv_queue_notification(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nkfifo_in(&djrcv_dev->notif_fifo, dj_report, sizeof(struct dj_report));\r\nif (schedule_work(&djrcv_dev->work) == 0) {\r\ndbg_hid("%s: did not schedule the work item, was already "\r\n"queued\n", __func__);\r\n}\r\n}\r\nstatic void logi_dj_recv_forward_null_report(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nunsigned int i;\r\nu8 reportbuffer[MAX_REPORT_SIZE];\r\nstruct dj_device *djdev;\r\ndjdev = djrcv_dev->paired_dj_devices[dj_report->device_index];\r\nmemset(reportbuffer, 0, sizeof(reportbuffer));\r\nfor (i = 0; i < NUMBER_OF_HID_REPORTS; i++) {\r\nif (djdev->reports_supported & (1 << i)) {\r\nreportbuffer[0] = i;\r\nif (hid_input_report(djdev->hdev,\r\nHID_INPUT_REPORT,\r\nreportbuffer,\r\nhid_reportid_size_map[i], 1)) {\r\ndbg_hid("hid_input_report error sending null "\r\n"report\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic void logi_dj_recv_forward_report(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct dj_device *dj_device;\r\ndj_device = djrcv_dev->paired_dj_devices[dj_report->device_index];\r\nif ((dj_report->report_type > ARRAY_SIZE(hid_reportid_size_map) - 1) ||\r\n(hid_reportid_size_map[dj_report->report_type] == 0)) {\r\ndbg_hid("invalid report type:%x\n", dj_report->report_type);\r\nreturn;\r\n}\r\nif (hid_input_report(dj_device->hdev,\r\nHID_INPUT_REPORT, &dj_report->report_type,\r\nhid_reportid_size_map[dj_report->report_type], 1)) {\r\ndbg_hid("hid_input_report error\n");\r\n}\r\n}\r\nstatic void logi_dj_recv_forward_hidpp(struct dj_device *dj_dev, u8 *data,\r\nint size)\r\n{\r\nif (hid_input_report(dj_dev->hdev, HID_INPUT_REPORT, data, size, 1))\r\ndbg_hid("hid_input_report error\n");\r\n}\r\nstatic int logi_dj_recv_send_report(struct dj_receiver_dev *djrcv_dev,\r\nstruct dj_report *dj_report)\r\n{\r\nstruct hid_device *hdev = djrcv_dev->hdev;\r\nstruct hid_report *report;\r\nstruct hid_report_enum *output_report_enum;\r\nu8 *data = (u8 *)(&dj_report->device_index);\r\nunsigned int i;\r\noutput_report_enum = &hdev->report_enum[HID_OUTPUT_REPORT];\r\nreport = output_report_enum->report_id_hash[REPORT_ID_DJ_SHORT];\r\nif (!report) {\r\ndev_err(&hdev->dev, "%s: unable to find dj report\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < DJREPORT_SHORT_LENGTH - 1; i++)\r\nreport->field[0]->value[i] = data[i];\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\nreturn 0;\r\n}\r\nstatic int logi_dj_recv_query_paired_devices(struct dj_receiver_dev *djrcv_dev)\r\n{\r\nstruct dj_report *dj_report;\r\nint retval;\r\nif (djrcv_dev->querying_devices)\r\nreturn 0;\r\ndj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\r\nif (!dj_report)\r\nreturn -ENOMEM;\r\ndj_report->report_id = REPORT_ID_DJ_SHORT;\r\ndj_report->device_index = 0xFF;\r\ndj_report->report_type = REPORT_TYPE_CMD_GET_PAIRED_DEVICES;\r\nretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\r\nkfree(dj_report);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\r\nunsigned timeout)\r\n{\r\nstruct hid_device *hdev = djrcv_dev->hdev;\r\nstruct dj_report *dj_report;\r\nu8 *buf;\r\nint retval;\r\ndj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\r\nif (!dj_report)\r\nreturn -ENOMEM;\r\ndj_report->report_id = REPORT_ID_DJ_SHORT;\r\ndj_report->device_index = 0xFF;\r\ndj_report->report_type = REPORT_TYPE_CMD_SWITCH;\r\ndj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\r\ndj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;\r\nretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\r\nmsleep(50);\r\nbuf = (u8 *)dj_report;\r\nmemset(buf, 0, HIDPP_REPORT_SHORT_LENGTH);\r\nbuf[0] = REPORT_ID_HIDPP_SHORT;\r\nbuf[1] = 0xFF;\r\nbuf[2] = 0x80;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x09;\r\nbuf[6] = 0x00;\r\nhid_hw_raw_request(hdev, REPORT_ID_HIDPP_SHORT, buf,\r\nHIDPP_REPORT_SHORT_LENGTH, HID_OUTPUT_REPORT,\r\nHID_REQ_SET_REPORT);\r\nkfree(dj_report);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_ll_open(struct hid_device *hid)\r\n{\r\ndbg_hid("%s:%s\n", __func__, hid->phys);\r\nreturn 0;\r\n}\r\nstatic void logi_dj_ll_close(struct hid_device *hid)\r\n{\r\ndbg_hid("%s:%s\n", __func__, hid->phys);\r\n}\r\nstatic int logi_dj_ll_raw_request(struct hid_device *hid,\r\nunsigned char reportnum, __u8 *buf,\r\nsize_t count, unsigned char report_type,\r\nint reqtype)\r\n{\r\nstruct dj_device *djdev = hid->driver_data;\r\nstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\r\nu8 *out_buf;\r\nint ret;\r\nif ((buf[0] == REPORT_ID_HIDPP_SHORT) ||\r\n(buf[0] == REPORT_ID_HIDPP_LONG)) {\r\nif (count < 2)\r\nreturn -EINVAL;\r\nif (count == 7 && !memcmp(buf, unifying_name_query,\r\nsizeof(unifying_name_query)))\r\nbuf[4] |= djdev->device_index - 1;\r\nelse\r\nbuf[1] = djdev->device_index;\r\nreturn hid_hw_raw_request(djrcv_dev->hdev, reportnum, buf,\r\ncount, report_type, reqtype);\r\n}\r\nif (buf[0] != REPORT_TYPE_LEDS)\r\nreturn -EINVAL;\r\nout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\r\nif (!out_buf)\r\nreturn -ENOMEM;\r\nif (count > DJREPORT_SHORT_LENGTH - 2)\r\ncount = DJREPORT_SHORT_LENGTH - 2;\r\nout_buf[0] = REPORT_ID_DJ_SHORT;\r\nout_buf[1] = djdev->device_index;\r\nmemcpy(out_buf + 2, buf, count);\r\nret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\r\nDJREPORT_SHORT_LENGTH, report_type, reqtype);\r\nkfree(out_buf);\r\nreturn ret;\r\n}\r\nstatic void rdcat(char *rdesc, unsigned int *rsize, const char *data, unsigned int size)\r\n{\r\nmemcpy(rdesc + *rsize, data, size);\r\n*rsize += size;\r\n}\r\nstatic int logi_dj_ll_parse(struct hid_device *hid)\r\n{\r\nstruct dj_device *djdev = hid->driver_data;\r\nunsigned int rsize = 0;\r\nchar *rdesc;\r\nint retval;\r\ndbg_hid("%s\n", __func__);\r\ndjdev->hdev->version = 0x0111;\r\ndjdev->hdev->country = 0x00;\r\nrdesc = kmalloc(MAX_RDESC_SIZE, GFP_KERNEL);\r\nif (!rdesc)\r\nreturn -ENOMEM;\r\nif (djdev->reports_supported & STD_KEYBOARD) {\r\ndbg_hid("%s: sending a kbd descriptor, reports_supported: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(rdesc, &rsize, kbd_descriptor, sizeof(kbd_descriptor));\r\n}\r\nif (djdev->reports_supported & STD_MOUSE) {\r\ndbg_hid("%s: sending a mouse descriptor, reports_supported: "\r\n"%x\n", __func__, djdev->reports_supported);\r\nrdcat(rdesc, &rsize, mse_descriptor, sizeof(mse_descriptor));\r\n}\r\nif (djdev->reports_supported & MULTIMEDIA) {\r\ndbg_hid("%s: sending a multimedia report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(rdesc, &rsize, consumer_descriptor, sizeof(consumer_descriptor));\r\n}\r\nif (djdev->reports_supported & POWER_KEYS) {\r\ndbg_hid("%s: sending a power keys report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(rdesc, &rsize, syscontrol_descriptor, sizeof(syscontrol_descriptor));\r\n}\r\nif (djdev->reports_supported & MEDIA_CENTER) {\r\ndbg_hid("%s: sending a media center report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\nrdcat(rdesc, &rsize, media_descriptor, sizeof(media_descriptor));\r\n}\r\nif (djdev->reports_supported & KBD_LEDS) {\r\ndbg_hid("%s: need to send kbd leds report descriptor: %x\n",\r\n__func__, djdev->reports_supported);\r\n}\r\nrdcat(rdesc, &rsize, hidpp_descriptor, sizeof(hidpp_descriptor));\r\nretval = hid_parse_report(hid, rdesc, rsize);\r\nkfree(rdesc);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_ll_start(struct hid_device *hid)\r\n{\r\ndbg_hid("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void logi_dj_ll_stop(struct hid_device *hid)\r\n{\r\ndbg_hid("%s\n", __func__);\r\n}\r\nstatic int logi_dj_dj_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data,\r\nint size)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nstruct dj_report *dj_report = (struct dj_report *) data;\r\nunsigned long flags;\r\nif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\r\n(dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\r\nif (dj_report->device_index != DJ_RECEIVER_INDEX)\r\ndev_err(&hdev->dev, "%s: invalid device index:%d\n",\r\n__func__, dj_report->device_index);\r\nreturn false;\r\n}\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\nif (!djrcv_dev->paired_dj_devices[dj_report->device_index]) {\r\nlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\r\ngoto out;\r\n}\r\nswitch (dj_report->report_type) {\r\ncase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\r\nbreak;\r\ncase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\r\nlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\r\nbreak;\r\ncase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\r\nif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\r\nSTATUS_LINKLOSS) {\r\nlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\r\n}\r\nbreak;\r\ndefault:\r\nlogi_dj_recv_forward_report(djrcv_dev, dj_report);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nreturn true;\r\n}\r\nstatic int logi_dj_hidpp_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data,\r\nint size)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nstruct dj_report *dj_report = (struct dj_report *) data;\r\nunsigned long flags;\r\nu8 device_index = dj_report->device_index;\r\nif (device_index == HIDPP_RECEIVER_INDEX) {\r\nif (size == HIDPP_REPORT_LONG_LENGTH &&\r\n!memcmp(data, unifying_name_answer,\r\nsizeof(unifying_name_answer)) &&\r\n((data[4] & 0xF0) == 0x40))\r\ndevice_index = (data[4] & 0x0F) + 1;\r\nelse\r\nreturn false;\r\n}\r\nif ((device_index < DJ_DEVICE_INDEX_MIN) ||\r\n(device_index > DJ_DEVICE_INDEX_MAX)) {\r\ndev_err(&hdev->dev, "%s: invalid device index:%d\n",\r\n__func__, dj_report->device_index);\r\nreturn false;\r\n}\r\nspin_lock_irqsave(&djrcv_dev->lock, flags);\r\nif (!djrcv_dev->paired_dj_devices[device_index])\r\ngoto out;\r\nlogi_dj_recv_forward_hidpp(djrcv_dev->paired_dj_devices[device_index],\r\ndata, size);\r\nout:\r\nspin_unlock_irqrestore(&djrcv_dev->lock, flags);\r\nreturn false;\r\n}\r\nstatic int logi_dj_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data,\r\nint size)\r\n{\r\ndbg_hid("%s, size:%d\n", __func__, size);\r\nswitch (data[0]) {\r\ncase REPORT_ID_DJ_SHORT:\r\nif (size != DJREPORT_SHORT_LENGTH) {\r\ndev_err(&hdev->dev, "DJ report of bad size (%d)", size);\r\nreturn false;\r\n}\r\nreturn logi_dj_dj_event(hdev, report, data, size);\r\ncase REPORT_ID_HIDPP_SHORT:\r\nif (size != HIDPP_REPORT_SHORT_LENGTH) {\r\ndev_err(&hdev->dev,\r\n"Short HID++ report of bad size (%d)", size);\r\nreturn false;\r\n}\r\nreturn logi_dj_hidpp_event(hdev, report, data, size);\r\ncase REPORT_ID_HIDPP_LONG:\r\nif (size != HIDPP_REPORT_LONG_LENGTH) {\r\ndev_err(&hdev->dev,\r\n"Long HID++ report of bad size (%d)", size);\r\nreturn false;\r\n}\r\nreturn logi_dj_hidpp_event(hdev, report, data, size);\r\n}\r\nreturn false;\r\n}\r\nstatic int logi_dj_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct dj_receiver_dev *djrcv_dev;\r\nint retval;\r\ndbg_hid("%s called for ifnum %d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber !=\r\nLOGITECH_DJ_INTERFACE_NUMBER) {\r\ndbg_hid("%s: ignoring ifnum %d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nreturn -ENODEV;\r\n}\r\ndjrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);\r\nif (!djrcv_dev) {\r\ndev_err(&hdev->dev,\r\n"%s:failed allocating dj_receiver_dev\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndjrcv_dev->hdev = hdev;\r\nINIT_WORK(&djrcv_dev->work, delayedwork_callback);\r\nspin_lock_init(&djrcv_dev->lock);\r\nif (kfifo_alloc(&djrcv_dev->notif_fifo,\r\nDJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),\r\nGFP_KERNEL)) {\r\ndev_err(&hdev->dev,\r\n"%s:failed allocating notif_fifo\n", __func__);\r\nkfree(djrcv_dev);\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, djrcv_dev);\r\nretval = hid_parse(hdev);\r\nif (retval) {\r\ndev_err(&hdev->dev,\r\n"%s:parse of interface 2 failed\n", __func__);\r\ngoto hid_parse_fail;\r\n}\r\nif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, REPORT_ID_DJ_SHORT,\r\n0, DJREPORT_SHORT_LENGTH - 1)) {\r\nretval = -ENODEV;\r\ngoto hid_parse_fail;\r\n}\r\nretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (retval) {\r\ndev_err(&hdev->dev,\r\n"%s:hid_hw_start returned error\n", __func__);\r\ngoto hid_hw_start_fail;\r\n}\r\nretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev,\r\n"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\n",\r\n__func__, retval);\r\ngoto switch_to_dj_mode_fail;\r\n}\r\nretval = hid_hw_open(hdev);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev, "%s:hid_hw_open returned error:%d\n",\r\n__func__, retval);\r\ngoto llopen_failed;\r\n}\r\nhid_device_io_start(hdev);\r\nretval = logi_dj_recv_query_paired_devices(djrcv_dev);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev, "%s:logi_dj_recv_query_paired_devices "\r\n"error:%d\n", __func__, retval);\r\ngoto logi_dj_recv_query_paired_devices_failed;\r\n}\r\nreturn retval;\r\nlogi_dj_recv_query_paired_devices_failed:\r\nhid_hw_close(hdev);\r\nllopen_failed:\r\nswitch_to_dj_mode_fail:\r\nhid_hw_stop(hdev);\r\nhid_hw_start_fail:\r\nhid_parse_fail:\r\nkfifo_free(&djrcv_dev->notif_fifo);\r\nkfree(djrcv_dev);\r\nhid_set_drvdata(hdev, NULL);\r\nreturn retval;\r\n}\r\nstatic int logi_dj_reset_resume(struct hid_device *hdev)\r\n{\r\nint retval;\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\r\nif (retval < 0) {\r\ndev_err(&hdev->dev,\r\n"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\n",\r\n__func__, retval);\r\n}\r\nreturn 0;\r\n}\r\nstatic void logi_dj_remove(struct hid_device *hdev)\r\n{\r\nstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\r\nstruct dj_device *dj_dev;\r\nint i;\r\ndbg_hid("%s\n", __func__);\r\ncancel_work_sync(&djrcv_dev->work);\r\nhid_hw_close(hdev);\r\nhid_hw_stop(hdev);\r\nfor (i = 0; i < (DJ_MAX_PAIRED_DEVICES + DJ_DEVICE_INDEX_MIN); i++) {\r\ndj_dev = djrcv_dev->paired_dj_devices[i];\r\nif (dj_dev != NULL) {\r\nhid_destroy_device(dj_dev->hdev);\r\nkfree(dj_dev);\r\ndjrcv_dev->paired_dj_devices[i] = NULL;\r\n}\r\n}\r\nkfifo_free(&djrcv_dev->notif_fifo);\r\nkfree(djrcv_dev);\r\nhid_set_drvdata(hdev, NULL);\r\n}
