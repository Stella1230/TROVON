unsigned int zfcp_fc_port_scan_backoff(void)\r\n{\r\nif (!port_scan_backoff)\r\nreturn 0;\r\nreturn get_random_int() % port_scan_backoff;\r\n}\r\nstatic void zfcp_fc_port_scan_time(struct zfcp_adapter *adapter)\r\n{\r\nunsigned long interval = msecs_to_jiffies(port_scan_ratelimit);\r\nunsigned long backoff = msecs_to_jiffies(zfcp_fc_port_scan_backoff());\r\nadapter->next_port_scan = jiffies + interval + backoff;\r\n}\r\nstatic void zfcp_fc_port_scan(struct zfcp_adapter *adapter)\r\n{\r\nunsigned long now = jiffies;\r\nunsigned long next = adapter->next_port_scan;\r\nunsigned long delay = 0, max;\r\nif (time_before(now, next)) {\r\ndelay = next - now;\r\nmax = msecs_to_jiffies(port_scan_ratelimit + port_scan_backoff);\r\ndelay = min(delay, max);\r\n}\r\nqueue_delayed_work(adapter->work_queue, &adapter->scan_work, delay);\r\n}\r\nvoid zfcp_fc_conditional_port_scan(struct zfcp_adapter *adapter)\r\n{\r\nif (no_auto_port_rescan)\r\nreturn;\r\nzfcp_fc_port_scan(adapter);\r\n}\r\nvoid zfcp_fc_inverse_conditional_port_scan(struct zfcp_adapter *adapter)\r\n{\r\nif (!no_auto_port_rescan)\r\nreturn;\r\nzfcp_fc_port_scan(adapter);\r\n}\r\nvoid zfcp_fc_post_event(struct work_struct *work)\r\n{\r\nstruct zfcp_fc_event *event = NULL, *tmp = NULL;\r\nLIST_HEAD(tmp_lh);\r\nstruct zfcp_fc_events *events = container_of(work,\r\nstruct zfcp_fc_events, work);\r\nstruct zfcp_adapter *adapter = container_of(events, struct zfcp_adapter,\r\nevents);\r\nspin_lock_bh(&events->list_lock);\r\nlist_splice_init(&events->list, &tmp_lh);\r\nspin_unlock_bh(&events->list_lock);\r\nlist_for_each_entry_safe(event, tmp, &tmp_lh, list) {\r\nfc_host_post_event(adapter->scsi_host, fc_get_event_number(),\r\nevent->code, event->data);\r\nlist_del(&event->list);\r\nkfree(event);\r\n}\r\n}\r\nvoid zfcp_fc_enqueue_event(struct zfcp_adapter *adapter,\r\nenum fc_host_event_code event_code, u32 event_data)\r\n{\r\nstruct zfcp_fc_event *event;\r\nevent = kmalloc(sizeof(struct zfcp_fc_event), GFP_ATOMIC);\r\nif (!event)\r\nreturn;\r\nevent->code = event_code;\r\nevent->data = event_data;\r\nspin_lock(&adapter->events.list_lock);\r\nlist_add_tail(&event->list, &adapter->events.list);\r\nspin_unlock(&adapter->events.list_lock);\r\nqueue_work(adapter->work_queue, &adapter->events.work);\r\n}\r\nstatic int zfcp_fc_wka_port_get(struct zfcp_fc_wka_port *wka_port)\r\n{\r\nif (mutex_lock_interruptible(&wka_port->mutex))\r\nreturn -ERESTARTSYS;\r\nif (wka_port->status == ZFCP_FC_WKA_PORT_OFFLINE ||\r\nwka_port->status == ZFCP_FC_WKA_PORT_CLOSING) {\r\nwka_port->status = ZFCP_FC_WKA_PORT_OPENING;\r\nif (zfcp_fsf_open_wka_port(wka_port))\r\nwka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\n}\r\nmutex_unlock(&wka_port->mutex);\r\nwait_event(wka_port->completion_wq,\r\nwka_port->status == ZFCP_FC_WKA_PORT_ONLINE ||\r\nwka_port->status == ZFCP_FC_WKA_PORT_OFFLINE);\r\nif (wka_port->status == ZFCP_FC_WKA_PORT_ONLINE) {\r\natomic_inc(&wka_port->refcount);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void zfcp_fc_wka_port_offline(struct work_struct *work)\r\n{\r\nstruct delayed_work *dw = to_delayed_work(work);\r\nstruct zfcp_fc_wka_port *wka_port =\r\ncontainer_of(dw, struct zfcp_fc_wka_port, work);\r\nmutex_lock(&wka_port->mutex);\r\nif ((atomic_read(&wka_port->refcount) != 0) ||\r\n(wka_port->status != ZFCP_FC_WKA_PORT_ONLINE))\r\ngoto out;\r\nwka_port->status = ZFCP_FC_WKA_PORT_CLOSING;\r\nif (zfcp_fsf_close_wka_port(wka_port)) {\r\nwka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\nwake_up(&wka_port->completion_wq);\r\n}\r\nout:\r\nmutex_unlock(&wka_port->mutex);\r\n}\r\nstatic void zfcp_fc_wka_port_put(struct zfcp_fc_wka_port *wka_port)\r\n{\r\nif (atomic_dec_return(&wka_port->refcount) != 0)\r\nreturn;\r\nschedule_delayed_work(&wka_port->work, HZ / 100);\r\n}\r\nstatic void zfcp_fc_wka_port_init(struct zfcp_fc_wka_port *wka_port, u32 d_id,\r\nstruct zfcp_adapter *adapter)\r\n{\r\ninit_waitqueue_head(&wka_port->completion_wq);\r\nwka_port->adapter = adapter;\r\nwka_port->d_id = d_id;\r\nwka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\natomic_set(&wka_port->refcount, 0);\r\nmutex_init(&wka_port->mutex);\r\nINIT_DELAYED_WORK(&wka_port->work, zfcp_fc_wka_port_offline);\r\n}\r\nstatic void zfcp_fc_wka_port_force_offline(struct zfcp_fc_wka_port *wka)\r\n{\r\ncancel_delayed_work_sync(&wka->work);\r\nmutex_lock(&wka->mutex);\r\nwka->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\nmutex_unlock(&wka->mutex);\r\n}\r\nvoid zfcp_fc_wka_ports_force_offline(struct zfcp_fc_wka_ports *gs)\r\n{\r\nif (!gs)\r\nreturn;\r\nzfcp_fc_wka_port_force_offline(&gs->ms);\r\nzfcp_fc_wka_port_force_offline(&gs->ts);\r\nzfcp_fc_wka_port_force_offline(&gs->ds);\r\nzfcp_fc_wka_port_force_offline(&gs->as);\r\n}\r\nstatic void _zfcp_fc_incoming_rscn(struct zfcp_fsf_req *fsf_req, u32 range,\r\nstruct fc_els_rscn_page *page)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_adapter *adapter = fsf_req->adapter;\r\nstruct zfcp_port *port;\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list) {\r\nif ((port->d_id & range) == (ntoh24(page->rscn_fid) & range))\r\nzfcp_fc_test_link(port);\r\nif (!port->d_id)\r\nzfcp_erp_port_reopen(port,\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fcrscn1");\r\n}\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\n}\r\nstatic void zfcp_fc_incoming_rscn(struct zfcp_fsf_req *fsf_req)\r\n{\r\nstruct fsf_status_read_buffer *status_buffer = (void *)fsf_req->data;\r\nstruct fc_els_rscn *head;\r\nstruct fc_els_rscn_page *page;\r\nu16 i;\r\nu16 no_entries;\r\nunsigned int afmt;\r\nhead = (struct fc_els_rscn *) status_buffer->payload.data;\r\npage = (struct fc_els_rscn_page *) head;\r\nno_entries = head->rscn_plen / sizeof(struct fc_els_rscn_page);\r\nfor (i = 1; i < no_entries; i++) {\r\npage++;\r\nafmt = page->rscn_page_flags & ELS_RSCN_ADDR_FMT_MASK;\r\n_zfcp_fc_incoming_rscn(fsf_req, zfcp_fc_rscn_range_mask[afmt],\r\npage);\r\nzfcp_fc_enqueue_event(fsf_req->adapter, FCH_EVT_RSCN,\r\n*(u32 *)page);\r\n}\r\nzfcp_fc_conditional_port_scan(fsf_req->adapter);\r\n}\r\nstatic void zfcp_fc_incoming_wwpn(struct zfcp_fsf_req *req, u64 wwpn)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct zfcp_port *port;\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\nif (port->wwpn == wwpn) {\r\nzfcp_erp_port_forced_reopen(port, 0, "fciwwp1");\r\nbreak;\r\n}\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\n}\r\nstatic void zfcp_fc_incoming_plogi(struct zfcp_fsf_req *req)\r\n{\r\nstruct fsf_status_read_buffer *status_buffer;\r\nstruct fc_els_flogi *plogi;\r\nstatus_buffer = (struct fsf_status_read_buffer *) req->data;\r\nplogi = (struct fc_els_flogi *) status_buffer->payload.data;\r\nzfcp_fc_incoming_wwpn(req, plogi->fl_wwpn);\r\n}\r\nstatic void zfcp_fc_incoming_logo(struct zfcp_fsf_req *req)\r\n{\r\nstruct fsf_status_read_buffer *status_buffer =\r\n(struct fsf_status_read_buffer *)req->data;\r\nstruct fc_els_logo *logo =\r\n(struct fc_els_logo *) status_buffer->payload.data;\r\nzfcp_fc_incoming_wwpn(req, logo->fl_n_port_wwn);\r\n}\r\nvoid zfcp_fc_incoming_els(struct zfcp_fsf_req *fsf_req)\r\n{\r\nstruct fsf_status_read_buffer *status_buffer =\r\n(struct fsf_status_read_buffer *) fsf_req->data;\r\nunsigned int els_type = status_buffer->payload.data[0];\r\nzfcp_dbf_san_in_els("fciels1", fsf_req);\r\nif (els_type == ELS_PLOGI)\r\nzfcp_fc_incoming_plogi(fsf_req);\r\nelse if (els_type == ELS_LOGO)\r\nzfcp_fc_incoming_logo(fsf_req);\r\nelse if (els_type == ELS_RSCN)\r\nzfcp_fc_incoming_rscn(fsf_req);\r\n}\r\nstatic void zfcp_fc_ns_gid_pn_eval(struct zfcp_fc_req *fc_req)\r\n{\r\nstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\r\nstruct zfcp_fc_gid_pn_rsp *gid_pn_rsp = &fc_req->u.gid_pn.rsp;\r\nif (ct_els->status)\r\nreturn;\r\nif (gid_pn_rsp->ct_hdr.ct_cmd != FC_FS_ACC)\r\nreturn;\r\nct_els->port->d_id = ntoh24(gid_pn_rsp->gid_pn.fp_fid);\r\n}\r\nstatic void zfcp_fc_complete(void *data)\r\n{\r\ncomplete(data);\r\n}\r\nstatic void zfcp_fc_ct_ns_init(struct fc_ct_hdr *ct_hdr, u16 cmd, u16 mr_size)\r\n{\r\nct_hdr->ct_rev = FC_CT_REV;\r\nct_hdr->ct_fs_type = FC_FST_DIR;\r\nct_hdr->ct_fs_subtype = FC_NS_SUBTYPE;\r\nct_hdr->ct_cmd = cmd;\r\nct_hdr->ct_mr_size = mr_size / 4;\r\n}\r\nstatic int zfcp_fc_ns_gid_pn_request(struct zfcp_port *port,\r\nstruct zfcp_fc_req *fc_req)\r\n{\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct zfcp_fc_gid_pn_req *gid_pn_req = &fc_req->u.gid_pn.req;\r\nstruct zfcp_fc_gid_pn_rsp *gid_pn_rsp = &fc_req->u.gid_pn.rsp;\r\nint ret;\r\nfc_req->ct_els.port = port;\r\nfc_req->ct_els.handler = zfcp_fc_complete;\r\nfc_req->ct_els.handler_data = &completion;\r\nfc_req->ct_els.req = &fc_req->sg_req;\r\nfc_req->ct_els.resp = &fc_req->sg_rsp;\r\nsg_init_one(&fc_req->sg_req, gid_pn_req, sizeof(*gid_pn_req));\r\nsg_init_one(&fc_req->sg_rsp, gid_pn_rsp, sizeof(*gid_pn_rsp));\r\nzfcp_fc_ct_ns_init(&gid_pn_req->ct_hdr,\r\nFC_NS_GID_PN, ZFCP_FC_CT_SIZE_PAGE);\r\ngid_pn_req->gid_pn.fn_wwpn = port->wwpn;\r\nret = zfcp_fsf_send_ct(&adapter->gs->ds, &fc_req->ct_els,\r\nadapter->pool.gid_pn_req,\r\nZFCP_FC_CTELS_TMO);\r\nif (!ret) {\r\nwait_for_completion(&completion);\r\nzfcp_fc_ns_gid_pn_eval(fc_req);\r\n}\r\nreturn ret;\r\n}\r\nstatic int zfcp_fc_ns_gid_pn(struct zfcp_port *port)\r\n{\r\nint ret;\r\nstruct zfcp_fc_req *fc_req;\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nfc_req = mempool_alloc(adapter->pool.gid_pn, GFP_ATOMIC);\r\nif (!fc_req)\r\nreturn -ENOMEM;\r\nmemset(fc_req, 0, sizeof(*fc_req));\r\nret = zfcp_fc_wka_port_get(&adapter->gs->ds);\r\nif (ret)\r\ngoto out;\r\nret = zfcp_fc_ns_gid_pn_request(port, fc_req);\r\nzfcp_fc_wka_port_put(&adapter->gs->ds);\r\nout:\r\nmempool_free(fc_req, adapter->pool.gid_pn);\r\nreturn ret;\r\n}\r\nvoid zfcp_fc_port_did_lookup(struct work_struct *work)\r\n{\r\nint ret;\r\nstruct zfcp_port *port = container_of(work, struct zfcp_port,\r\ngid_pn_work);\r\nret = zfcp_fc_ns_gid_pn(port);\r\nif (ret) {\r\nzfcp_erp_adapter_reopen(port->adapter, 0, "fcgpn_1");\r\ngoto out;\r\n}\r\nif (!port->d_id) {\r\nzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ERP_FAILED);\r\ngoto out;\r\n}\r\nzfcp_erp_port_reopen(port, 0, "fcgpn_3");\r\nout:\r\nput_device(&port->dev);\r\n}\r\nvoid zfcp_fc_trigger_did_lookup(struct zfcp_port *port)\r\n{\r\nget_device(&port->dev);\r\nif (!queue_work(port->adapter->work_queue, &port->gid_pn_work))\r\nput_device(&port->dev);\r\n}\r\nvoid zfcp_fc_plogi_evaluate(struct zfcp_port *port, struct fc_els_flogi *plogi)\r\n{\r\nif (plogi->fl_wwpn != port->wwpn) {\r\nport->d_id = 0;\r\ndev_warn(&port->adapter->ccw_device->dev,\r\n"A port opened with WWPN 0x%016Lx returned data that "\r\n"identifies it as WWPN 0x%016Lx\n",\r\n(unsigned long long) port->wwpn,\r\n(unsigned long long) plogi->fl_wwpn);\r\nreturn;\r\n}\r\nport->wwnn = plogi->fl_wwnn;\r\nport->maxframe_size = plogi->fl_csp.sp_bb_data;\r\nif (plogi->fl_cssp[0].cp_class & FC_CPC_VALID)\r\nport->supported_classes |= FC_COS_CLASS1;\r\nif (plogi->fl_cssp[1].cp_class & FC_CPC_VALID)\r\nport->supported_classes |= FC_COS_CLASS2;\r\nif (plogi->fl_cssp[2].cp_class & FC_CPC_VALID)\r\nport->supported_classes |= FC_COS_CLASS3;\r\nif (plogi->fl_cssp[3].cp_class & FC_CPC_VALID)\r\nport->supported_classes |= FC_COS_CLASS4;\r\n}\r\nstatic void zfcp_fc_adisc_handler(void *data)\r\n{\r\nstruct zfcp_fc_req *fc_req = data;\r\nstruct zfcp_port *port = fc_req->ct_els.port;\r\nstruct fc_els_adisc *adisc_resp = &fc_req->u.adisc.rsp;\r\nif (fc_req->ct_els.status) {\r\nzfcp_erp_port_forced_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fcadh_1");\r\ngoto out;\r\n}\r\nif (!port->wwnn)\r\nport->wwnn = adisc_resp->adisc_wwnn;\r\nif ((port->wwpn != adisc_resp->adisc_wwpn) ||\r\n!(atomic_read(&port->status) & ZFCP_STATUS_COMMON_OPEN)) {\r\nzfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fcadh_2");\r\ngoto out;\r\n}\r\nzfcp_scsi_schedule_rport_register(port);\r\nout:\r\natomic_andnot(ZFCP_STATUS_PORT_LINK_TEST, &port->status);\r\nput_device(&port->dev);\r\nkmem_cache_free(zfcp_fc_req_cache, fc_req);\r\n}\r\nstatic int zfcp_fc_adisc(struct zfcp_port *port)\r\n{\r\nstruct zfcp_fc_req *fc_req;\r\nstruct zfcp_adapter *adapter = port->adapter;\r\nstruct Scsi_Host *shost = adapter->scsi_host;\r\nint ret;\r\nfc_req = kmem_cache_zalloc(zfcp_fc_req_cache, GFP_ATOMIC);\r\nif (!fc_req)\r\nreturn -ENOMEM;\r\nfc_req->ct_els.port = port;\r\nfc_req->ct_els.req = &fc_req->sg_req;\r\nfc_req->ct_els.resp = &fc_req->sg_rsp;\r\nsg_init_one(&fc_req->sg_req, &fc_req->u.adisc.req,\r\nsizeof(struct fc_els_adisc));\r\nsg_init_one(&fc_req->sg_rsp, &fc_req->u.adisc.rsp,\r\nsizeof(struct fc_els_adisc));\r\nfc_req->ct_els.handler = zfcp_fc_adisc_handler;\r\nfc_req->ct_els.handler_data = fc_req;\r\nfc_req->u.adisc.req.adisc_wwpn = fc_host_port_name(shost);\r\nfc_req->u.adisc.req.adisc_wwnn = fc_host_node_name(shost);\r\nfc_req->u.adisc.req.adisc_cmd = ELS_ADISC;\r\nhton24(fc_req->u.adisc.req.adisc_port_id, fc_host_port_id(shost));\r\nret = zfcp_fsf_send_els(adapter, port->d_id, &fc_req->ct_els,\r\nZFCP_FC_CTELS_TMO);\r\nif (ret)\r\nkmem_cache_free(zfcp_fc_req_cache, fc_req);\r\nreturn ret;\r\n}\r\nvoid zfcp_fc_link_test_work(struct work_struct *work)\r\n{\r\nstruct zfcp_port *port =\r\ncontainer_of(work, struct zfcp_port, test_link_work);\r\nint retval;\r\nget_device(&port->dev);\r\nport->rport_task = RPORT_DEL;\r\nzfcp_scsi_rport_work(&port->rport_work);\r\nif (atomic_read(&port->status) & ZFCP_STATUS_PORT_LINK_TEST)\r\ngoto out;\r\natomic_or(ZFCP_STATUS_PORT_LINK_TEST, &port->status);\r\nretval = zfcp_fc_adisc(port);\r\nif (retval == 0)\r\nreturn;\r\natomic_andnot(ZFCP_STATUS_PORT_LINK_TEST, &port->status);\r\nzfcp_erp_port_forced_reopen(port, 0, "fcltwk1");\r\nout:\r\nput_device(&port->dev);\r\n}\r\nvoid zfcp_fc_test_link(struct zfcp_port *port)\r\n{\r\nget_device(&port->dev);\r\nif (!queue_work(port->adapter->work_queue, &port->test_link_work))\r\nput_device(&port->dev);\r\n}\r\nstatic struct zfcp_fc_req *zfcp_alloc_sg_env(int buf_num)\r\n{\r\nstruct zfcp_fc_req *fc_req;\r\nfc_req = kmem_cache_zalloc(zfcp_fc_req_cache, GFP_KERNEL);\r\nif (!fc_req)\r\nreturn NULL;\r\nif (zfcp_sg_setup_table(&fc_req->sg_rsp, buf_num)) {\r\nkmem_cache_free(zfcp_fc_req_cache, fc_req);\r\nreturn NULL;\r\n}\r\nsg_init_one(&fc_req->sg_req, &fc_req->u.gpn_ft.req,\r\nsizeof(struct zfcp_fc_gpn_ft_req));\r\nreturn fc_req;\r\n}\r\nstatic int zfcp_fc_send_gpn_ft(struct zfcp_fc_req *fc_req,\r\nstruct zfcp_adapter *adapter, int max_bytes)\r\n{\r\nstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\r\nstruct zfcp_fc_gpn_ft_req *req = &fc_req->u.gpn_ft.req;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint ret;\r\nzfcp_fc_ct_ns_init(&req->ct_hdr, FC_NS_GPN_FT, max_bytes);\r\nreq->gpn_ft.fn_fc4_type = FC_TYPE_FCP;\r\nct_els->handler = zfcp_fc_complete;\r\nct_els->handler_data = &completion;\r\nct_els->req = &fc_req->sg_req;\r\nct_els->resp = &fc_req->sg_rsp;\r\nret = zfcp_fsf_send_ct(&adapter->gs->ds, ct_els, NULL,\r\nZFCP_FC_CTELS_TMO);\r\nif (!ret)\r\nwait_for_completion(&completion);\r\nreturn ret;\r\n}\r\nstatic void zfcp_fc_validate_port(struct zfcp_port *port, struct list_head *lh)\r\n{\r\nif (!(atomic_read(&port->status) & ZFCP_STATUS_COMMON_NOESC))\r\nreturn;\r\natomic_andnot(ZFCP_STATUS_COMMON_NOESC, &port->status);\r\nif ((port->supported_classes != 0) ||\r\n!list_empty(&port->unit_list))\r\nreturn;\r\nlist_move_tail(&port->list, lh);\r\n}\r\nstatic int zfcp_fc_eval_gpn_ft(struct zfcp_fc_req *fc_req,\r\nstruct zfcp_adapter *adapter, int max_entries)\r\n{\r\nstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\r\nstruct scatterlist *sg = &fc_req->sg_rsp;\r\nstruct fc_ct_hdr *hdr = sg_virt(sg);\r\nstruct fc_gpn_ft_resp *acc = sg_virt(sg);\r\nstruct zfcp_port *port, *tmp;\r\nunsigned long flags;\r\nLIST_HEAD(remove_lh);\r\nu32 d_id;\r\nint ret = 0, x, last = 0;\r\nif (ct_els->status)\r\nreturn -EIO;\r\nif (hdr->ct_cmd != FC_FS_ACC) {\r\nif (hdr->ct_reason == FC_BA_RJT_UNABLE)\r\nreturn -EAGAIN;\r\nreturn -EIO;\r\n}\r\nif (hdr->ct_mr_size) {\r\ndev_warn(&adapter->ccw_device->dev,\r\n"The name server reported %d words residual data\n",\r\nhdr->ct_mr_size);\r\nreturn -E2BIG;\r\n}\r\nfor (x = 1; x < max_entries && !last; x++) {\r\nif (x % (ZFCP_FC_GPN_FT_ENT_PAGE + 1))\r\nacc++;\r\nelse\r\nacc = sg_virt(++sg);\r\nlast = acc->fp_flags & FC_NS_FID_LAST;\r\nd_id = ntoh24(acc->fp_fid);\r\nif (d_id >= FC_FID_WELL_KNOWN_BASE)\r\ncontinue;\r\nif (acc->fp_wwpn == fc_host_port_name(adapter->scsi_host))\r\ncontinue;\r\nport = zfcp_port_enqueue(adapter, acc->fp_wwpn,\r\nZFCP_STATUS_COMMON_NOESC, d_id);\r\nif (!IS_ERR(port))\r\nzfcp_erp_port_reopen(port, 0, "fcegpf1");\r\nelse if (PTR_ERR(port) != -EEXIST)\r\nret = PTR_ERR(port);\r\n}\r\nzfcp_erp_wait(adapter);\r\nwrite_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry_safe(port, tmp, &adapter->port_list, list)\r\nzfcp_fc_validate_port(port, &remove_lh);\r\nwrite_unlock_irqrestore(&adapter->port_list_lock, flags);\r\nlist_for_each_entry_safe(port, tmp, &remove_lh, list) {\r\nzfcp_erp_port_shutdown(port, 0, "fcegpf2");\r\ndevice_unregister(&port->dev);\r\n}\r\nreturn ret;\r\n}\r\nvoid zfcp_fc_scan_ports(struct work_struct *work)\r\n{\r\nstruct delayed_work *dw = to_delayed_work(work);\r\nstruct zfcp_adapter *adapter = container_of(dw, struct zfcp_adapter,\r\nscan_work);\r\nint ret, i;\r\nstruct zfcp_fc_req *fc_req;\r\nint chain, max_entries, buf_num, max_bytes;\r\nzfcp_fc_port_scan_time(adapter);\r\nchain = adapter->adapter_features & FSF_FEATURE_ELS_CT_CHAINED_SBALS;\r\nbuf_num = chain ? ZFCP_FC_GPN_FT_NUM_BUFS : 1;\r\nmax_entries = chain ? ZFCP_FC_GPN_FT_MAX_ENT : ZFCP_FC_GPN_FT_ENT_PAGE;\r\nmax_bytes = chain ? ZFCP_FC_GPN_FT_MAX_SIZE : ZFCP_FC_CT_SIZE_PAGE;\r\nif (fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPORT &&\r\nfc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPIV)\r\nreturn;\r\nif (zfcp_fc_wka_port_get(&adapter->gs->ds))\r\nreturn;\r\nfc_req = zfcp_alloc_sg_env(buf_num);\r\nif (!fc_req)\r\ngoto out;\r\nfor (i = 0; i < 3; i++) {\r\nret = zfcp_fc_send_gpn_ft(fc_req, adapter, max_bytes);\r\nif (!ret) {\r\nret = zfcp_fc_eval_gpn_ft(fc_req, adapter, max_entries);\r\nif (ret == -EAGAIN)\r\nssleep(1);\r\nelse\r\nbreak;\r\n}\r\n}\r\nzfcp_sg_free_table(&fc_req->sg_rsp, buf_num);\r\nkmem_cache_free(zfcp_fc_req_cache, fc_req);\r\nout:\r\nzfcp_fc_wka_port_put(&adapter->gs->ds);\r\n}\r\nstatic int zfcp_fc_gspn(struct zfcp_adapter *adapter,\r\nstruct zfcp_fc_req *fc_req)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nchar devno[] = "DEVNO:";\r\nstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\r\nstruct zfcp_fc_gspn_req *gspn_req = &fc_req->u.gspn.req;\r\nstruct zfcp_fc_gspn_rsp *gspn_rsp = &fc_req->u.gspn.rsp;\r\nint ret;\r\nzfcp_fc_ct_ns_init(&gspn_req->ct_hdr, FC_NS_GSPN_ID,\r\nFC_SYMBOLIC_NAME_SIZE);\r\nhton24(gspn_req->gspn.fp_fid, fc_host_port_id(adapter->scsi_host));\r\nsg_init_one(&fc_req->sg_req, gspn_req, sizeof(*gspn_req));\r\nsg_init_one(&fc_req->sg_rsp, gspn_rsp, sizeof(*gspn_rsp));\r\nct_els->handler = zfcp_fc_complete;\r\nct_els->handler_data = &completion;\r\nct_els->req = &fc_req->sg_req;\r\nct_els->resp = &fc_req->sg_rsp;\r\nret = zfcp_fsf_send_ct(&adapter->gs->ds, ct_els, NULL,\r\nZFCP_FC_CTELS_TMO);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&completion);\r\nif (ct_els->status)\r\nreturn ct_els->status;\r\nif (fc_host_port_type(adapter->scsi_host) == FC_PORTTYPE_NPIV &&\r\n!(strstr(gspn_rsp->gspn.fp_name, devno)))\r\nsnprintf(fc_host_symbolic_name(adapter->scsi_host),\r\nFC_SYMBOLIC_NAME_SIZE, "%s%s %s NAME: %s",\r\ngspn_rsp->gspn.fp_name, devno,\r\ndev_name(&adapter->ccw_device->dev),\r\ninit_utsname()->nodename);\r\nelse\r\nstrlcpy(fc_host_symbolic_name(adapter->scsi_host),\r\ngspn_rsp->gspn.fp_name, FC_SYMBOLIC_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void zfcp_fc_rspn(struct zfcp_adapter *adapter,\r\nstruct zfcp_fc_req *fc_req)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct Scsi_Host *shost = adapter->scsi_host;\r\nstruct zfcp_fsf_ct_els *ct_els = &fc_req->ct_els;\r\nstruct zfcp_fc_rspn_req *rspn_req = &fc_req->u.rspn.req;\r\nstruct fc_ct_hdr *rspn_rsp = &fc_req->u.rspn.rsp;\r\nint ret, len;\r\nzfcp_fc_ct_ns_init(&rspn_req->ct_hdr, FC_NS_RSPN_ID,\r\nFC_SYMBOLIC_NAME_SIZE);\r\nhton24(rspn_req->rspn.fr_fid.fp_fid, fc_host_port_id(shost));\r\nlen = strlcpy(rspn_req->rspn.fr_name, fc_host_symbolic_name(shost),\r\nFC_SYMBOLIC_NAME_SIZE);\r\nrspn_req->rspn.fr_name_len = len;\r\nsg_init_one(&fc_req->sg_req, rspn_req, sizeof(*rspn_req));\r\nsg_init_one(&fc_req->sg_rsp, rspn_rsp, sizeof(*rspn_rsp));\r\nct_els->handler = zfcp_fc_complete;\r\nct_els->handler_data = &completion;\r\nct_els->req = &fc_req->sg_req;\r\nct_els->resp = &fc_req->sg_rsp;\r\nret = zfcp_fsf_send_ct(&adapter->gs->ds, ct_els, NULL,\r\nZFCP_FC_CTELS_TMO);\r\nif (!ret)\r\nwait_for_completion(&completion);\r\n}\r\nvoid zfcp_fc_sym_name_update(struct work_struct *work)\r\n{\r\nstruct zfcp_adapter *adapter = container_of(work, struct zfcp_adapter,\r\nns_up_work);\r\nint ret;\r\nstruct zfcp_fc_req *fc_req;\r\nif (fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPORT &&\r\nfc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPIV)\r\nreturn;\r\nfc_req = kmem_cache_zalloc(zfcp_fc_req_cache, GFP_KERNEL);\r\nif (!fc_req)\r\nreturn;\r\nret = zfcp_fc_wka_port_get(&adapter->gs->ds);\r\nif (ret)\r\ngoto out_free;\r\nret = zfcp_fc_gspn(adapter, fc_req);\r\nif (ret || fc_host_port_type(adapter->scsi_host) != FC_PORTTYPE_NPIV)\r\ngoto out_ds_put;\r\nmemset(fc_req, 0, sizeof(*fc_req));\r\nzfcp_fc_rspn(adapter, fc_req);\r\nout_ds_put:\r\nzfcp_fc_wka_port_put(&adapter->gs->ds);\r\nout_free:\r\nkmem_cache_free(zfcp_fc_req_cache, fc_req);\r\n}\r\nstatic void zfcp_fc_ct_els_job_handler(void *data)\r\n{\r\nstruct bsg_job *job = data;\r\nstruct zfcp_fsf_ct_els *zfcp_ct_els = job->dd_data;\r\nstruct fc_bsg_reply *jr = job->reply;\r\njr->reply_payload_rcv_len = job->reply_payload.payload_len;\r\njr->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;\r\njr->result = zfcp_ct_els->status ? -EIO : 0;\r\nbsg_job_done(job, jr->result, jr->reply_payload_rcv_len);\r\n}\r\nstatic struct zfcp_fc_wka_port *zfcp_fc_job_wka_port(struct bsg_job *job)\r\n{\r\nu32 preamble_word1;\r\nu8 gs_type;\r\nstruct zfcp_adapter *adapter;\r\nstruct fc_bsg_request *bsg_request = job->request;\r\nstruct fc_rport *rport = fc_bsg_to_rport(job);\r\nstruct Scsi_Host *shost;\r\npreamble_word1 = bsg_request->rqst_data.r_ct.preamble_word1;\r\ngs_type = (preamble_word1 & 0xff000000) >> 24;\r\nshost = rport ? rport_to_shost(rport) : fc_bsg_to_shost(job);\r\nadapter = (struct zfcp_adapter *) shost->hostdata[0];\r\nswitch (gs_type) {\r\ncase FC_FST_ALIAS:\r\nreturn &adapter->gs->as;\r\ncase FC_FST_MGMT:\r\nreturn &adapter->gs->ms;\r\ncase FC_FST_TIME:\r\nreturn &adapter->gs->ts;\r\nbreak;\r\ncase FC_FST_DIR:\r\nreturn &adapter->gs->ds;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic void zfcp_fc_ct_job_handler(void *data)\r\n{\r\nstruct bsg_job *job = data;\r\nstruct zfcp_fc_wka_port *wka_port;\r\nwka_port = zfcp_fc_job_wka_port(job);\r\nzfcp_fc_wka_port_put(wka_port);\r\nzfcp_fc_ct_els_job_handler(data);\r\n}\r\nstatic int zfcp_fc_exec_els_job(struct bsg_job *job,\r\nstruct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_fsf_ct_els *els = job->dd_data;\r\nstruct fc_rport *rport = fc_bsg_to_rport(job);\r\nstruct fc_bsg_request *bsg_request = job->request;\r\nstruct zfcp_port *port;\r\nu32 d_id;\r\nif (rport) {\r\nport = zfcp_get_port_by_wwpn(adapter, rport->port_name);\r\nif (!port)\r\nreturn -EINVAL;\r\nd_id = port->d_id;\r\nput_device(&port->dev);\r\n} else\r\nd_id = ntoh24(bsg_request->rqst_data.h_els.port_id);\r\nels->handler = zfcp_fc_ct_els_job_handler;\r\nreturn zfcp_fsf_send_els(adapter, d_id, els, job->req->timeout / HZ);\r\n}\r\nstatic int zfcp_fc_exec_ct_job(struct bsg_job *job,\r\nstruct zfcp_adapter *adapter)\r\n{\r\nint ret;\r\nstruct zfcp_fsf_ct_els *ct = job->dd_data;\r\nstruct zfcp_fc_wka_port *wka_port;\r\nwka_port = zfcp_fc_job_wka_port(job);\r\nif (!wka_port)\r\nreturn -EINVAL;\r\nret = zfcp_fc_wka_port_get(wka_port);\r\nif (ret)\r\nreturn ret;\r\nct->handler = zfcp_fc_ct_job_handler;\r\nret = zfcp_fsf_send_ct(wka_port, ct, NULL, job->req->timeout / HZ);\r\nif (ret)\r\nzfcp_fc_wka_port_put(wka_port);\r\nreturn ret;\r\n}\r\nint zfcp_fc_exec_bsg_job(struct bsg_job *job)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct zfcp_adapter *adapter;\r\nstruct zfcp_fsf_ct_els *ct_els = job->dd_data;\r\nstruct fc_bsg_request *bsg_request = job->request;\r\nstruct fc_rport *rport = fc_bsg_to_rport(job);\r\nshost = rport ? rport_to_shost(rport) : fc_bsg_to_shost(job);\r\nadapter = (struct zfcp_adapter *)shost->hostdata[0];\r\nif (!(atomic_read(&adapter->status) & ZFCP_STATUS_COMMON_OPEN))\r\nreturn -EINVAL;\r\nct_els->req = job->request_payload.sg_list;\r\nct_els->resp = job->reply_payload.sg_list;\r\nct_els->handler_data = job;\r\nswitch (bsg_request->msgcode) {\r\ncase FC_BSG_RPT_ELS:\r\ncase FC_BSG_HST_ELS_NOLOGIN:\r\nreturn zfcp_fc_exec_els_job(job, adapter);\r\ncase FC_BSG_RPT_CT:\r\ncase FC_BSG_HST_CT:\r\nreturn zfcp_fc_exec_ct_job(job, adapter);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint zfcp_fc_timeout_bsg_job(struct bsg_job *job)\r\n{\r\nreturn -EAGAIN;\r\n}\r\nint zfcp_fc_gs_setup(struct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_fc_wka_ports *wka_ports;\r\nwka_ports = kzalloc(sizeof(struct zfcp_fc_wka_ports), GFP_KERNEL);\r\nif (!wka_ports)\r\nreturn -ENOMEM;\r\nadapter->gs = wka_ports;\r\nzfcp_fc_wka_port_init(&wka_ports->ms, FC_FID_MGMT_SERV, adapter);\r\nzfcp_fc_wka_port_init(&wka_ports->ts, FC_FID_TIME_SERV, adapter);\r\nzfcp_fc_wka_port_init(&wka_ports->ds, FC_FID_DIR_SERV, adapter);\r\nzfcp_fc_wka_port_init(&wka_ports->as, FC_FID_ALIASES, adapter);\r\nreturn 0;\r\n}\r\nvoid zfcp_fc_gs_destroy(struct zfcp_adapter *adapter)\r\n{\r\nkfree(adapter->gs);\r\nadapter->gs = NULL;\r\n}
