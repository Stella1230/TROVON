static ssize_t status_show_vhci(int pdev_nr, char *out)\r\n{\r\nstruct platform_device *pdev = *(vhci_pdevs + pdev_nr);\r\nstruct vhci_hcd *vhci;\r\nchar *s = out;\r\nint i = 0;\r\nunsigned long flags;\r\nif (!pdev || !out) {\r\nusbip_dbg_vhci_sysfs("show status error\n");\r\nreturn 0;\r\n}\r\nvhci = hcd_to_vhci(platform_get_drvdata(pdev));\r\nspin_lock_irqsave(&vhci->lock, flags);\r\nfor (i = 0; i < VHCI_HC_PORTS; i++) {\r\nstruct vhci_device *vdev = &vhci->vdev[i];\r\nspin_lock(&vdev->ud.lock);\r\nout += sprintf(out, "%04u %03u ",\r\n(pdev_nr * VHCI_HC_PORTS) + i,\r\nvdev->ud.status);\r\nif (vdev->ud.status == VDEV_ST_USED) {\r\nout += sprintf(out, "%03u %08x ",\r\nvdev->speed, vdev->devid);\r\nout += sprintf(out, "%16p %s",\r\nvdev->ud.tcp_socket,\r\ndev_name(&vdev->udev->dev));\r\n} else {\r\nout += sprintf(out, "000 00000000 ");\r\nout += sprintf(out, "0000000000000000 0-0");\r\n}\r\nout += sprintf(out, "\n");\r\nspin_unlock(&vdev->ud.lock);\r\n}\r\nspin_unlock_irqrestore(&vhci->lock, flags);\r\nreturn out - s;\r\n}\r\nstatic ssize_t status_show_not_ready(int pdev_nr, char *out)\r\n{\r\nchar *s = out;\r\nint i = 0;\r\nfor (i = 0; i < VHCI_HC_PORTS; i++) {\r\nout += sprintf(out, "%04u %03u ",\r\n(pdev_nr * VHCI_HC_PORTS) + i,\r\nVDEV_ST_NOTASSIGNED);\r\nout += sprintf(out, "000 00000000 0000000000000000 0-0");\r\nout += sprintf(out, "\n");\r\n}\r\nreturn out - s;\r\n}\r\nstatic int status_name_to_id(const char *name)\r\n{\r\nchar *c;\r\nlong val;\r\nint ret;\r\nc = strchr(name, '.');\r\nif (c == NULL)\r\nreturn 0;\r\nret = kstrtol(c+1, 10, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic ssize_t status_show(struct device *dev,\r\nstruct device_attribute *attr, char *out)\r\n{\r\nchar *s = out;\r\nint pdev_nr;\r\nout += sprintf(out,\r\n"port sta spd dev socket local_busid\n");\r\npdev_nr = status_name_to_id(attr->attr.name);\r\nif (pdev_nr < 0)\r\nout += status_show_not_ready(pdev_nr, out);\r\nelse\r\nout += status_show_vhci(pdev_nr, out);\r\nreturn out - s;\r\n}\r\nstatic ssize_t nports_show(struct device *dev, struct device_attribute *attr,\r\nchar *out)\r\n{\r\nchar *s = out;\r\nout += sprintf(out, "%d\n", VHCI_HC_PORTS * vhci_num_controllers);\r\nreturn out - s;\r\n}\r\nstatic int vhci_port_disconnect(struct vhci_hcd *vhci, __u32 rhport)\r\n{\r\nstruct vhci_device *vdev = &vhci->vdev[rhport];\r\nunsigned long flags;\r\nusbip_dbg_vhci_sysfs("enter\n");\r\nspin_lock_irqsave(&vhci->lock, flags);\r\nspin_lock(&vdev->ud.lock);\r\nif (vdev->ud.status == VDEV_ST_NULL) {\r\npr_err("not connected %d\n", vdev->ud.status);\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock_irqrestore(&vhci->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock_irqrestore(&vhci->lock, flags);\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_DOWN);\r\nreturn 0;\r\n}\r\nstatic int valid_port(__u32 pdev_nr, __u32 rhport)\r\n{\r\nif (pdev_nr >= vhci_num_controllers) {\r\npr_err("pdev %u\n", pdev_nr);\r\nreturn 0;\r\n}\r\nif (rhport >= VHCI_HC_PORTS) {\r\npr_err("rhport %u\n", rhport);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic ssize_t store_detach(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\n__u32 port = 0, pdev_nr = 0, rhport = 0;\r\nstruct usb_hcd *hcd;\r\nint ret;\r\nif (kstrtoint(buf, 10, &port) < 0)\r\nreturn -EINVAL;\r\npdev_nr = port_to_pdev_nr(port);\r\nrhport = port_to_rhport(port);\r\nif (!valid_port(pdev_nr, rhport))\r\nreturn -EINVAL;\r\nhcd = platform_get_drvdata(*(vhci_pdevs + pdev_nr));\r\nif (hcd == NULL) {\r\ndev_err(dev, "port is not ready %u\n", port);\r\nreturn -EAGAIN;\r\n}\r\nret = vhci_port_disconnect(hcd_to_vhci(hcd), rhport);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nusbip_dbg_vhci_sysfs("Leave\n");\r\nreturn count;\r\n}\r\nstatic int valid_args(__u32 pdev_nr, __u32 rhport, enum usb_device_speed speed)\r\n{\r\nif (!valid_port(pdev_nr, rhport)) {\r\nreturn 0;\r\n}\r\nswitch (speed) {\r\ncase USB_SPEED_LOW:\r\ncase USB_SPEED_FULL:\r\ncase USB_SPEED_HIGH:\r\ncase USB_SPEED_WIRELESS:\r\nbreak;\r\ndefault:\r\npr_err("Failed attach request for unsupported USB speed: %s\n",\r\nusb_speed_string(speed));\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic ssize_t store_attach(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct socket *socket;\r\nint sockfd = 0;\r\n__u32 port = 0, pdev_nr = 0, rhport = 0, devid = 0, speed = 0;\r\nstruct usb_hcd *hcd;\r\nstruct vhci_hcd *vhci;\r\nstruct vhci_device *vdev;\r\nint err;\r\nunsigned long flags;\r\nif (sscanf(buf, "%u %u %u %u", &port, &sockfd, &devid, &speed) != 4)\r\nreturn -EINVAL;\r\npdev_nr = port_to_pdev_nr(port);\r\nrhport = port_to_rhport(port);\r\nusbip_dbg_vhci_sysfs("port(%u) pdev(%d) rhport(%u)\n",\r\nport, pdev_nr, rhport);\r\nusbip_dbg_vhci_sysfs("sockfd(%u) devid(%u) speed(%u)\n",\r\nsockfd, devid, speed);\r\nif (!valid_args(pdev_nr, rhport, speed))\r\nreturn -EINVAL;\r\nhcd = platform_get_drvdata(*(vhci_pdevs + pdev_nr));\r\nif (hcd == NULL) {\r\ndev_err(dev, "port %d is not ready\n", port);\r\nreturn -EAGAIN;\r\n}\r\nvhci = hcd_to_vhci(hcd);\r\nvdev = &vhci->vdev[rhport];\r\nsocket = sockfd_lookup(sockfd, &err);\r\nif (!socket)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&vhci->lock, flags);\r\nspin_lock(&vdev->ud.lock);\r\nif (vdev->ud.status != VDEV_ST_NULL) {\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock_irqrestore(&vhci->lock, flags);\r\nsockfd_put(socket);\r\ndev_err(dev, "port %d already used\n", rhport);\r\nreturn -EINVAL;\r\n}\r\ndev_info(dev, "pdev(%u) rhport(%u) sockfd(%d)\n",\r\npdev_nr, rhport, sockfd);\r\ndev_info(dev, "devid(%u) speed(%u) speed_str(%s)\n",\r\ndevid, speed, usb_speed_string(speed));\r\nvdev->devid = devid;\r\nvdev->speed = speed;\r\nvdev->ud.tcp_socket = socket;\r\nvdev->ud.status = VDEV_ST_NOTASSIGNED;\r\nspin_unlock(&vdev->ud.lock);\r\nspin_unlock_irqrestore(&vhci->lock, flags);\r\nvdev->ud.tcp_rx = kthread_get_run(vhci_rx_loop, &vdev->ud, "vhci_rx");\r\nvdev->ud.tcp_tx = kthread_get_run(vhci_tx_loop, &vdev->ud, "vhci_tx");\r\nrh_port_connect(vdev, speed);\r\nreturn count;\r\n}\r\nstatic void set_status_attr(int id)\r\n{\r\nstruct status_attr *status;\r\nstatus = status_attrs + id;\r\nif (id == 0)\r\nstrcpy(status->name, "status");\r\nelse\r\nsnprintf(status->name, MAX_STATUS_NAME+1, "status.%d", id);\r\nstatus->attr.attr.name = status->name;\r\nstatus->attr.attr.mode = S_IRUGO;\r\nstatus->attr.show = status_show;\r\nsysfs_attr_init(&status->attr.attr);\r\n}\r\nstatic int init_status_attrs(void)\r\n{\r\nint id;\r\nstatus_attrs = kcalloc(vhci_num_controllers, sizeof(struct status_attr),\r\nGFP_KERNEL);\r\nif (status_attrs == NULL)\r\nreturn -ENOMEM;\r\nfor (id = 0; id < vhci_num_controllers; id++)\r\nset_status_attr(id);\r\nreturn 0;\r\n}\r\nstatic void finish_status_attrs(void)\r\n{\r\nkfree(status_attrs);\r\n}\r\nint vhci_init_attr_group(void)\r\n{\r\nstruct attribute **attrs;\r\nint ret, i;\r\nattrs = kcalloc((vhci_num_controllers + 5), sizeof(struct attribute *),\r\nGFP_KERNEL);\r\nif (attrs == NULL)\r\nreturn -ENOMEM;\r\nret = init_status_attrs();\r\nif (ret) {\r\nkfree(attrs);\r\nreturn ret;\r\n}\r\n*attrs = &dev_attr_nports.attr;\r\n*(attrs + 1) = &dev_attr_detach.attr;\r\n*(attrs + 2) = &dev_attr_attach.attr;\r\n*(attrs + 3) = &dev_attr_usbip_debug.attr;\r\nfor (i = 0; i < vhci_num_controllers; i++)\r\n*(attrs + i + 4) = &((status_attrs + i)->attr.attr);\r\nvhci_attr_group.attrs = attrs;\r\nreturn 0;\r\n}\r\nvoid vhci_finish_attr_group(void)\r\n{\r\nfinish_status_attrs();\r\nkfree(vhci_attr_group.attrs);\r\n}
