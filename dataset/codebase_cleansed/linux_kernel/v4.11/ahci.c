static void ahci_pci_save_initial_config(struct pci_dev *pdev,\r\nstruct ahci_host_priv *hpriv)\r\n{\r\nif (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361) {\r\ndev_info(&pdev->dev, "JMB361 has only one port\n");\r\nhpriv->force_port_map = 1;\r\n}\r\nif (hpriv->flags & AHCI_HFLAG_MV_PATA) {\r\nif (pdev->device == 0x6121)\r\nhpriv->mask_port_map = 0x3;\r\nelse\r\nhpriv->mask_port_map = 0xf;\r\ndev_info(&pdev->dev,\r\n"Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\n");\r\n}\r\nahci_save_initial_config(&pdev->dev, hpriv);\r\n}\r\nstatic int ahci_pci_reset_controller(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nahci_reset_controller(host);\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nu16 tmp16;\r\npci_read_config_word(pdev, 0x92, &tmp16);\r\nif ((tmp16 & hpriv->port_map) != hpriv->port_map) {\r\ntmp16 |= hpriv->port_map;\r\npci_write_config_word(pdev, 0x92, tmp16);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ahci_pci_init_controller(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nvoid __iomem *port_mmio;\r\nu32 tmp;\r\nint mv;\r\nif (hpriv->flags & AHCI_HFLAG_MV_PATA) {\r\nif (pdev->device == 0x6121)\r\nmv = 2;\r\nelse\r\nmv = 4;\r\nport_mmio = __ahci_port_base(host, mv);\r\nwritel(0, port_mmio + PORT_IRQ_MASK);\r\ntmp = readl(port_mmio + PORT_IRQ_STAT);\r\nVPRINTK("PORT_IRQ_STAT 0x%x\n", tmp);\r\nif (tmp)\r\nwritel(tmp, port_mmio + PORT_IRQ_STAT);\r\n}\r\nahci_init_controller(host);\r\n}\r\nstatic int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nbool online;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nahci_stop_engine(ap);\r\nrc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),\r\ndeadline, &online, NULL);\r\nhpriv->start_engine(ap);\r\nDPRINTK("EXIT, rc=%d, class=%u\n", rc, *class);\r\nreturn online ? -EAGAIN : rc;\r\n}\r\nstatic int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nstruct ata_taskfile tf;\r\nbool online;\r\nint rc;\r\nahci_stop_engine(ap);\r\nata_tf_init(link->device, &tf);\r\ntf.command = ATA_BUSY;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\nrc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),\r\ndeadline, &online, NULL);\r\nhpriv->start_engine(ap);\r\nif (online) {\r\nrc = ata_wait_after_reset(link, jiffies + 2 * HZ,\r\nahci_check_ready);\r\nif (rc)\r\nahci_kick_engine(ap);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nunsigned long tmo = deadline - jiffies;\r\nstruct ata_taskfile tf;\r\nbool online;\r\nint rc, i;\r\nDPRINTK("ENTER\n");\r\nahci_stop_engine(ap);\r\nfor (i = 0; i < 2; i++) {\r\nu16 val;\r\nu32 sstatus;\r\nint port = ap->port_no;\r\nstruct ata_host *host = ap->host;\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nata_tf_init(link->device, &tf);\r\ntf.command = ATA_BUSY;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\nrc = sata_link_hardreset(link, timing, deadline, &online,\r\nahci_check_ready);\r\nif (sata_scr_read(link, SCR_STATUS, &sstatus) != 0 ||\r\n(sstatus & 0xf) != 1)\r\nbreak;\r\nata_link_printk(link, KERN_INFO, "avn bounce port%d\n",\r\nport);\r\npci_read_config_word(pdev, 0x92, &val);\r\nval &= ~(1 << port);\r\npci_write_config_word(pdev, 0x92, val);\r\nata_msleep(ap, 1000);\r\nval |= 1 << port;\r\npci_write_config_word(pdev, 0x92, val);\r\ndeadline += tmo;\r\n}\r\nhpriv->start_engine(ap);\r\nif (online)\r\n*class = ahci_dev_classify(ap);\r\nDPRINTK("EXIT, rc=%d, class=%u\n", rc, *class);\r\nreturn rc;\r\n}\r\nstatic void ahci_pci_disable_interrupts(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\n}\r\nstatic int ahci_pci_device_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nahci_pci_disable_interrupts(host);\r\nreturn 0;\r\n}\r\nstatic int ahci_pci_device_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nint rc;\r\nrc = ahci_pci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_pci_init_controller(host);\r\nreturn 0;\r\n}\r\nstatic int ahci_pci_device_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(&pdev->dev,\r\n"BIOS update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nahci_pci_disable_interrupts(host);\r\nreturn ata_host_suspend(host, PMSG_SUSPEND);\r\n}\r\nstatic int ahci_pci_device_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nint rc;\r\nif (is_mcp89_apple(pdev))\r\nahci_mcp89_apple_enable(pdev);\r\nif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_pci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_pci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)\r\n{\r\nint rc;\r\nif (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))\r\nreturn 0;\r\nif (using_dac &&\r\n!dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {\r\nrc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"64-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev, "32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ahci_pci_print_info(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nu16 cc;\r\nconst char *scc_s;\r\npci_read_config_word(pdev, 0x0a, &cc);\r\nif (cc == PCI_CLASS_STORAGE_IDE)\r\nscc_s = "IDE";\r\nelse if (cc == PCI_CLASS_STORAGE_SATA)\r\nscc_s = "SATA";\r\nelse if (cc == PCI_CLASS_STORAGE_RAID)\r\nscc_s = "RAID";\r\nelse\r\nscc_s = "unknown";\r\nahci_print_info(host, scc_s);\r\n}\r\nstatic void ahci_p5wdh_workaround(struct ata_host *host)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "P5W DH Deluxe",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR,\r\n"ASUSTEK COMPUTER INC"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "P5W DH Deluxe"),\r\n},\r\n},\r\n{ }\r\n};\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nif (pdev->bus->number == 0 && pdev->devfn == PCI_DEVFN(0x1f, 2) &&\r\ndmi_check_system(sysids)) {\r\nstruct ata_port *ap = host->ports[1];\r\ndev_info(&pdev->dev,\r\n"enabling ASUS P5W DH Deluxe on-board SIMG4726 workaround\n");\r\nap->ops = &ahci_p5wdh_ops;\r\nap->link.flags |= ATA_LFLAG_NO_SRST | ATA_LFLAG_ASSUME_ATA;\r\n}\r\n}\r\nstatic void ahci_mcp89_apple_enable(struct pci_dev *pdev)\r\n{\r\nu32 val;\r\nprintk(KERN_INFO "ahci: enabling MCP89 AHCI mode\n");\r\npci_read_config_dword(pdev, 0xf8, &val);\r\nval |= 1 << 0x1b;\r\npci_write_config_dword(pdev, 0xf8, val);\r\npci_read_config_dword(pdev, 0x54c, &val);\r\nval |= 1 << 0xc;\r\npci_write_config_dword(pdev, 0x54c, val);\r\npci_read_config_dword(pdev, 0x4a4, &val);\r\nval &= 0xff;\r\nval |= 0x01060100;\r\npci_write_config_dword(pdev, 0x4a4, val);\r\npci_read_config_dword(pdev, 0x54c, &val);\r\nval &= ~(1 << 0xc);\r\npci_write_config_dword(pdev, 0x54c, val);\r\npci_read_config_dword(pdev, 0xf8, &val);\r\nval &= ~(1 << 0x1b);\r\npci_write_config_dword(pdev, 0xf8, val);\r\n}\r\nstatic bool is_mcp89_apple(struct pci_dev *pdev)\r\n{\r\nreturn pdev->vendor == PCI_VENDOR_ID_NVIDIA &&\r\npdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA &&\r\npdev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&\r\npdev->subsystem_device == 0xcb89;\r\n}\r\nstatic bool ahci_sb600_enable_64bit(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "ASUS M2A-VM",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"ASUSTeK Computer INC."),\r\nDMI_MATCH(DMI_BOARD_NAME, "M2A-VM"),\r\n},\r\n.driver_data = "20071026",\r\n},\r\n{\r\n.ident = "MSI K9A2 Platinum",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"MICRO-STAR INTER"),\r\nDMI_MATCH(DMI_BOARD_NAME, "MS-7376"),\r\n},\r\n},\r\n{\r\n.ident = "MSI K9AGM2",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"MICRO-STAR INTER"),\r\nDMI_MATCH(DMI_BOARD_NAME, "MS-7327"),\r\n},\r\n},\r\n{\r\n.ident = "ASUS M3A",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"ASUSTeK Computer INC."),\r\nDMI_MATCH(DMI_BOARD_NAME, "M3A"),\r\n},\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *match;\r\nint year, month, date;\r\nchar buf[9];\r\nmatch = dmi_first_match(sysids);\r\nif (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||\r\n!match)\r\nreturn false;\r\nif (!match->driver_data)\r\ngoto enable_64bit;\r\ndmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\r\nsnprintf(buf, sizeof(buf), "%04d%02d%02d", year, month, date);\r\nif (strcmp(buf, match->driver_data) >= 0)\r\ngoto enable_64bit;\r\nelse {\r\ndev_warn(&pdev->dev,\r\n"%s: BIOS too old, forcing 32bit DMA, update BIOS\n",\r\nmatch->ident);\r\nreturn false;\r\n}\r\nenable_64bit:\r\ndev_warn(&pdev->dev, "%s: enabling 64bit DMA\n", match->ident);\r\nreturn true;\r\n}\r\nstatic bool ahci_broken_system_poweroff(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id broken_systems[] = {\r\n{\r\n.ident = "HP Compaq nx6310",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq nx6310"),\r\n},\r\n.driver_data = (void *)0x1FUL,\r\n},\r\n{\r\n.ident = "HP Compaq 6720s",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq 6720s"),\r\n},\r\n.driver_data = (void *)0x1FUL,\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(broken_systems);\r\nif (dmi) {\r\nunsigned long slot = (unsigned long)dmi->driver_data;\r\nreturn slot == PCI_SLOT(pdev->devfn);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ahci_broken_suspend(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "dv4",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP Pavilion dv4 Notebook PC"),\r\n},\r\n.driver_data = "20090105",\r\n},\r\n{\r\n.ident = "dv5",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP Pavilion dv5 Notebook PC"),\r\n},\r\n.driver_data = "20090506",\r\n},\r\n{\r\n.ident = "dv6",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP Pavilion dv6 Notebook PC"),\r\n},\r\n.driver_data = "20090423",\r\n},\r\n{\r\n.ident = "HDX18",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP HDX18 Notebook PC"),\r\n},\r\n.driver_data = "20090430",\r\n},\r\n{\r\n.ident = "G725",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "eMachines"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "eMachines G725"),\r\n},\r\n.driver_data = "20091216",\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(sysids);\r\nint year, month, date;\r\nchar buf[9];\r\nif (!dmi || pdev->bus->number || pdev->devfn != PCI_DEVFN(0x1f, 2))\r\nreturn false;\r\ndmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\r\nsnprintf(buf, sizeof(buf), "%04d%02d%02d", year, month, date);\r\nreturn strcmp(buf, dmi->driver_data) < 0;\r\n}\r\nstatic bool ahci_broken_online(struct pci_dev *pdev)\r\n{\r\n#define ENCODE_BUSDEVFN(bus, slot, func) \\r\n(void *)(unsigned long)(((bus) << 8) | PCI_DEVFN((slot), (func)))\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "EP45-DQ6",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"Gigabyte Technology Co., Ltd."),\r\nDMI_MATCH(DMI_BOARD_NAME, "EP45-DQ6"),\r\n},\r\n.driver_data = ENCODE_BUSDEVFN(0x0a, 0x00, 0),\r\n},\r\n{\r\n.ident = "EP45-DS5",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"Gigabyte Technology Co., Ltd."),\r\nDMI_MATCH(DMI_BOARD_NAME, "EP45-DS5"),\r\n},\r\n.driver_data = ENCODE_BUSDEVFN(0x03, 0x00, 0),\r\n},\r\n{ }\r\n};\r\n#undef ENCODE_BUSDEVFN\r\nconst struct dmi_system_id *dmi = dmi_first_match(sysids);\r\nunsigned int val;\r\nif (!dmi)\r\nreturn false;\r\nval = (unsigned long)dmi->driver_data;\r\nreturn pdev->bus->number == (val >> 8) && pdev->devfn == (val & 0xff);\r\n}\r\nstatic bool ahci_broken_devslp(struct pci_dev *pdev)\r\n{\r\nstatic const struct pci_device_id ids[] = {\r\n{ PCI_VDEVICE(INTEL, 0x0f23)},\r\n{}\r\n};\r\nreturn pci_match_id(ids, pdev);\r\n}\r\nstatic void ahci_gtf_filter_workaround(struct ata_host *host)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "Aspire 3810T",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Acer"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Aspire 3810T"),\r\n},\r\n.driver_data = (void *)ATA_ACPI_FILTER_FPDMA_OFFSET,\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(sysids);\r\nunsigned int filter;\r\nint i;\r\nif (!dmi)\r\nreturn;\r\nfilter = (unsigned long)dmi->driver_data;\r\ndev_info(host->dev, "applying extra ACPI _GTF filter 0x%x for %s\n",\r\nfilter, dmi->ident);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nata_for_each_link(link, ap, EDGE)\r\nata_for_each_dev(dev, link, ALL)\r\ndev->gtf_filter |= filter;\r\n}\r\n}\r\nstatic inline void ahci_gtf_filter_workaround(struct ata_host *host)\r\n{}\r\nstatic irqreturn_t ahci_thunderx_irq_handler(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct ahci_host_priv *hpriv;\r\nunsigned int rc = 0;\r\nvoid __iomem *mmio;\r\nu32 irq_stat, irq_masked;\r\nunsigned int handled = 1;\r\nVPRINTK("ENTER\n");\r\nhpriv = host->private_data;\r\nmmio = hpriv->mmio;\r\nirq_stat = readl(mmio + HOST_IRQ_STAT);\r\nif (!irq_stat)\r\nreturn IRQ_NONE;\r\ndo {\r\nirq_masked = irq_stat & hpriv->port_map;\r\nspin_lock(&host->lock);\r\nrc = ahci_handle_port_intr(host, irq_masked);\r\nif (!rc)\r\nhandled = 0;\r\nwritel(irq_stat, mmio + HOST_IRQ_STAT);\r\nirq_stat = readl(mmio + HOST_IRQ_STAT);\r\nspin_unlock(&host->lock);\r\n} while (irq_stat);\r\nVPRINTK("EXIT\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void ahci_remap_check(struct pci_dev *pdev, int bar,\r\nstruct ahci_host_priv *hpriv)\r\n{\r\nint i, count = 0;\r\nu32 cap;\r\nif (pdev->vendor != PCI_VENDOR_ID_INTEL ||\r\npci_resource_len(pdev, bar) < SZ_512K ||\r\nbar != AHCI_PCI_BAR_STANDARD ||\r\n!(readl(hpriv->mmio + AHCI_VSCAP) & 1))\r\nreturn;\r\ncap = readq(hpriv->mmio + AHCI_REMAP_CAP);\r\nfor (i = 0; i < AHCI_MAX_REMAP; i++) {\r\nif ((cap & (1 << i)) == 0)\r\ncontinue;\r\nif (readl(hpriv->mmio + ahci_remap_dcc(i))\r\n!= PCI_CLASS_STORAGE_EXPRESS)\r\ncontinue;\r\ncount++;\r\n}\r\nif (!count)\r\nreturn;\r\ndev_warn(&pdev->dev, "Found %d remapped NVMe devices.\n", count);\r\ndev_warn(&pdev->dev, "Switch your BIOS from RAID to AHCI mode to use them.\n");\r\n}\r\nstatic int ahci_get_irq_vector(struct ata_host *host, int port)\r\n{\r\nreturn pci_irq_vector(to_pci_dev(host->dev), port);\r\n}\r\nstatic int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,\r\nstruct ahci_host_priv *hpriv)\r\n{\r\nint nvec;\r\nif (hpriv->flags & AHCI_HFLAG_NO_MSI)\r\nreturn -ENODEV;\r\nif (n_ports > 1) {\r\nnvec = pci_alloc_irq_vectors(pdev, n_ports, INT_MAX,\r\nPCI_IRQ_MSIX | PCI_IRQ_MSI);\r\nif (nvec > 0) {\r\nif (!(readl(hpriv->mmio + HOST_CTL) & HOST_MRSM)) {\r\nhpriv->get_irq_vector = ahci_get_irq_vector;\r\nhpriv->flags |= AHCI_HFLAG_MULTI_MSI;\r\nreturn nvec;\r\n}\r\nprintk(KERN_INFO\r\n"ahci: MRSM is on, fallback to single MSI\n");\r\npci_free_irq_vectors(pdev);\r\n}\r\n}\r\nnvec = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\r\nif (nvec == 1)\r\nreturn nvec;\r\nreturn pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSIX);\r\n}\r\nstatic int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned int board_id = ent->driver_data;\r\nstruct ata_port_info pi = ahci_port_info[board_id];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct ata_host *host;\r\nint n_ports, i, rc;\r\nint ahci_pci_bar = AHCI_PCI_BAR_STANDARD;\r\nVPRINTK("ENTER\n");\r\nWARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nif (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)\r\nreturn -ENODEV;\r\nif (is_mcp89_apple(pdev))\r\nahci_mcp89_apple_enable(pdev);\r\nif (pdev->vendor == PCI_VENDOR_ID_PROMISE)\r\ndev_info(&pdev->dev,\r\n"PDC42819 can only drive SATA devices with this driver\n");\r\nif (pdev->vendor == PCI_VENDOR_ID_STMICRO && pdev->device == 0xCC06)\r\nahci_pci_bar = AHCI_PCI_BAR_STA2X11;\r\nelse if (pdev->vendor == 0x1c44 && pdev->device == 0x8000)\r\nahci_pci_bar = AHCI_PCI_BAR_ENMOTUS;\r\nelse if (pdev->vendor == 0x177d && pdev->device == 0xa01c)\r\nahci_pci_bar = AHCI_PCI_BAR_CAVIUM;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\r\n(pdev->device == 0x2652 || pdev->device == 0x2653)) {\r\nu8 map;\r\npci_read_config_byte(pdev, ICH_MAP, &map);\r\nif (map & 0x3) {\r\ndev_info(&pdev->dev,\r\n"controller is in combined mode, can't enable AHCI mode\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nrc = pcim_iomap_regions_request_all(pdev, 1 << ahci_pci_bar, DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv)\r\nreturn -ENOMEM;\r\nhpriv->flags |= (unsigned long)pi.private_data;\r\nif (board_id == board_ahci_mcp65 &&\r\n(pdev->revision == 0xa1 || pdev->revision == 0xa2))\r\nhpriv->flags |= AHCI_HFLAG_NO_MSI;\r\nif (board_id == board_ahci_sb700 && pdev->revision >= 0x40)\r\nhpriv->flags &= ~AHCI_HFLAG_IGN_SERR_INTERNAL;\r\nif (ahci_sb600_enable_64bit(pdev))\r\nhpriv->flags &= ~AHCI_HFLAG_32BIT_ONLY;\r\nhpriv->mmio = pcim_iomap_table(pdev)[ahci_pci_bar];\r\nahci_remap_check(pdev, ahci_pci_bar, hpriv);\r\nif (ahci_broken_devslp(pdev))\r\nhpriv->flags |= AHCI_HFLAG_NO_DEVSLP;\r\n#ifdef CONFIG_ARM64\r\nif (pdev->vendor == 0x177d && pdev->device == 0xa01c)\r\nhpriv->irq_handler = ahci_thunderx_irq_handler;\r\n#endif\r\nahci_pci_save_initial_config(pdev, hpriv);\r\nif (hpriv->cap & HOST_CAP_NCQ) {\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (!(hpriv->flags & AHCI_HFLAG_NO_FPDMA_AA))\r\npi.flags |= ATA_FLAG_FPDMA_AA;\r\npi.flags |= ATA_FLAG_FPDMA_AUX;\r\n}\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nahci_set_em_messages(hpriv, &pi);\r\nif (ahci_broken_system_poweroff(pdev)) {\r\npi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN;\r\ndev_info(&pdev->dev,\r\n"quirky BIOS, skipping spindown on poweroff\n");\r\n}\r\nif (ahci_broken_suspend(pdev)) {\r\nhpriv->flags |= AHCI_HFLAG_NO_SUSPEND;\r\ndev_warn(&pdev->dev,\r\n"BIOS update required for suspend/resume\n");\r\n}\r\nif (ahci_broken_online(pdev)) {\r\nhpriv->flags |= AHCI_HFLAG_SRST_TOUT_IS_OFFLINE;\r\ndev_info(&pdev->dev,\r\n"online status unreliable, applying workaround\n");\r\n}\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->private_data = hpriv;\r\nif (ahci_init_msi(pdev, n_ports, hpriv) < 0) {\r\npci_intx(pdev, 1);\r\n}\r\nhpriv->irq = pci_irq_vector(pdev, 0);\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nelse\r\ndev_info(&pdev->dev, "SSS flag set, parallel bus scan disabled\n");\r\nif (pi.flags & ATA_FLAG_EM)\r\nahci_reset_em(host);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_pbar_desc(ap, ahci_pci_bar, -1, "abar");\r\nata_port_pbar_desc(ap, ahci_pci_bar,\r\n0x100 + ap->port_no * 0x80, "port");\r\nif (ap->flags & ATA_FLAG_EM)\r\nap->em_message_type = hpriv->em_msg_type;\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nahci_p5wdh_workaround(host);\r\nahci_gtf_filter_workaround(host);\r\nrc = ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);\r\nif (rc)\r\nreturn rc;\r\nrc = ahci_pci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_pci_init_controller(host);\r\nahci_pci_print_info(host);\r\npci_set_master(pdev);\r\nrc = ahci_host_activate(host, &ahci_sht);\r\nif (rc)\r\nreturn rc;\r\npm_runtime_put_noidle(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void ahci_remove_one(struct pci_dev *pdev)\r\n{\r\npm_runtime_get_noresume(&pdev->dev);\r\nata_pci_remove_one(pdev);\r\n}
