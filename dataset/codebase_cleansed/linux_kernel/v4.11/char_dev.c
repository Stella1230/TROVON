static inline int major_to_index(unsigned major)\r\n{\r\nreturn major % CHRDEV_MAJOR_HASH_SIZE;\r\n}\r\nvoid chrdev_show(struct seq_file *f, off_t offset)\r\n{\r\nstruct char_device_struct *cd;\r\nif (offset < CHRDEV_MAJOR_HASH_SIZE) {\r\nmutex_lock(&chrdevs_lock);\r\nfor (cd = chrdevs[offset]; cd; cd = cd->next)\r\nseq_printf(f, "%3d %s\n", cd->major, cd->name);\r\nmutex_unlock(&chrdevs_lock);\r\n}\r\n}\r\nstatic struct char_device_struct *\r\n__register_chrdev_region(unsigned int major, unsigned int baseminor,\r\nint minorct, const char *name)\r\n{\r\nstruct char_device_struct *cd, **cp;\r\nint ret = 0;\r\nint i;\r\ncd = kzalloc(sizeof(struct char_device_struct), GFP_KERNEL);\r\nif (cd == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_lock(&chrdevs_lock);\r\nif (major == 0) {\r\nfor (i = ARRAY_SIZE(chrdevs)-1; i > 0; i--) {\r\nif (chrdevs[i] == NULL)\r\nbreak;\r\n}\r\nif (i < CHRDEV_MAJOR_DYN_END)\r\npr_warn("CHRDEV \"%s\" major number %d goes below the dynamic allocation range\n",\r\nname, i);\r\nif (i == 0) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmajor = i;\r\n}\r\ncd->major = major;\r\ncd->baseminor = baseminor;\r\ncd->minorct = minorct;\r\nstrlcpy(cd->name, name, sizeof(cd->name));\r\ni = major_to_index(major);\r\nfor (cp = &chrdevs[i]; *cp; cp = &(*cp)->next)\r\nif ((*cp)->major > major ||\r\n((*cp)->major == major &&\r\n(((*cp)->baseminor >= baseminor) ||\r\n((*cp)->baseminor + (*cp)->minorct > baseminor))))\r\nbreak;\r\nif (*cp && (*cp)->major == major) {\r\nint old_min = (*cp)->baseminor;\r\nint old_max = (*cp)->baseminor + (*cp)->minorct - 1;\r\nint new_min = baseminor;\r\nint new_max = baseminor + minorct - 1;\r\nif (new_max >= old_min && new_max <= old_max) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (new_min <= old_max && new_min >= old_min) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\ncd->next = *cp;\r\n*cp = cd;\r\nmutex_unlock(&chrdevs_lock);\r\nreturn cd;\r\nout:\r\nmutex_unlock(&chrdevs_lock);\r\nkfree(cd);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct char_device_struct *\r\n__unregister_chrdev_region(unsigned major, unsigned baseminor, int minorct)\r\n{\r\nstruct char_device_struct *cd = NULL, **cp;\r\nint i = major_to_index(major);\r\nmutex_lock(&chrdevs_lock);\r\nfor (cp = &chrdevs[i]; *cp; cp = &(*cp)->next)\r\nif ((*cp)->major == major &&\r\n(*cp)->baseminor == baseminor &&\r\n(*cp)->minorct == minorct)\r\nbreak;\r\nif (*cp) {\r\ncd = *cp;\r\n*cp = cd->next;\r\n}\r\nmutex_unlock(&chrdevs_lock);\r\nreturn cd;\r\n}\r\nint register_chrdev_region(dev_t from, unsigned count, const char *name)\r\n{\r\nstruct char_device_struct *cd;\r\ndev_t to = from + count;\r\ndev_t n, next;\r\nfor (n = from; n < to; n = next) {\r\nnext = MKDEV(MAJOR(n)+1, 0);\r\nif (next > to)\r\nnext = to;\r\ncd = __register_chrdev_region(MAJOR(n), MINOR(n),\r\nnext - n, name);\r\nif (IS_ERR(cd))\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nto = n;\r\nfor (n = from; n < to; n = next) {\r\nnext = MKDEV(MAJOR(n)+1, 0);\r\nkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\r\n}\r\nreturn PTR_ERR(cd);\r\n}\r\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,\r\nconst char *name)\r\n{\r\nstruct char_device_struct *cd;\r\ncd = __register_chrdev_region(0, baseminor, count, name);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\n*dev = MKDEV(cd->major, cd->baseminor);\r\nreturn 0;\r\n}\r\nint __register_chrdev(unsigned int major, unsigned int baseminor,\r\nunsigned int count, const char *name,\r\nconst struct file_operations *fops)\r\n{\r\nstruct char_device_struct *cd;\r\nstruct cdev *cdev;\r\nint err = -ENOMEM;\r\ncd = __register_chrdev_region(major, baseminor, count, name);\r\nif (IS_ERR(cd))\r\nreturn PTR_ERR(cd);\r\ncdev = cdev_alloc();\r\nif (!cdev)\r\ngoto out2;\r\ncdev->owner = fops->owner;\r\ncdev->ops = fops;\r\nkobject_set_name(&cdev->kobj, "%s", name);\r\nerr = cdev_add(cdev, MKDEV(cd->major, baseminor), count);\r\nif (err)\r\ngoto out;\r\ncd->cdev = cdev;\r\nreturn major ? 0 : cd->major;\r\nout:\r\nkobject_put(&cdev->kobj);\r\nout2:\r\nkfree(__unregister_chrdev_region(cd->major, baseminor, count));\r\nreturn err;\r\n}\r\nvoid unregister_chrdev_region(dev_t from, unsigned count)\r\n{\r\ndev_t to = from + count;\r\ndev_t n, next;\r\nfor (n = from; n < to; n = next) {\r\nnext = MKDEV(MAJOR(n)+1, 0);\r\nif (next > to)\r\nnext = to;\r\nkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\r\n}\r\n}\r\nvoid __unregister_chrdev(unsigned int major, unsigned int baseminor,\r\nunsigned int count, const char *name)\r\n{\r\nstruct char_device_struct *cd;\r\ncd = __unregister_chrdev_region(major, baseminor, count);\r\nif (cd && cd->cdev)\r\ncdev_del(cd->cdev);\r\nkfree(cd);\r\n}\r\nstatic struct kobject *cdev_get(struct cdev *p)\r\n{\r\nstruct module *owner = p->owner;\r\nstruct kobject *kobj;\r\nif (owner && !try_module_get(owner))\r\nreturn NULL;\r\nkobj = kobject_get(&p->kobj);\r\nif (!kobj)\r\nmodule_put(owner);\r\nreturn kobj;\r\n}\r\nvoid cdev_put(struct cdev *p)\r\n{\r\nif (p) {\r\nstruct module *owner = p->owner;\r\nkobject_put(&p->kobj);\r\nmodule_put(owner);\r\n}\r\n}\r\nstatic int chrdev_open(struct inode *inode, struct file *filp)\r\n{\r\nconst struct file_operations *fops;\r\nstruct cdev *p;\r\nstruct cdev *new = NULL;\r\nint ret = 0;\r\nspin_lock(&cdev_lock);\r\np = inode->i_cdev;\r\nif (!p) {\r\nstruct kobject *kobj;\r\nint idx;\r\nspin_unlock(&cdev_lock);\r\nkobj = kobj_lookup(cdev_map, inode->i_rdev, &idx);\r\nif (!kobj)\r\nreturn -ENXIO;\r\nnew = container_of(kobj, struct cdev, kobj);\r\nspin_lock(&cdev_lock);\r\np = inode->i_cdev;\r\nif (!p) {\r\ninode->i_cdev = p = new;\r\nlist_add(&inode->i_devices, &p->list);\r\nnew = NULL;\r\n} else if (!cdev_get(p))\r\nret = -ENXIO;\r\n} else if (!cdev_get(p))\r\nret = -ENXIO;\r\nspin_unlock(&cdev_lock);\r\ncdev_put(new);\r\nif (ret)\r\nreturn ret;\r\nret = -ENXIO;\r\nfops = fops_get(p->ops);\r\nif (!fops)\r\ngoto out_cdev_put;\r\nreplace_fops(filp, fops);\r\nif (filp->f_op->open) {\r\nret = filp->f_op->open(inode, filp);\r\nif (ret)\r\ngoto out_cdev_put;\r\n}\r\nreturn 0;\r\nout_cdev_put:\r\ncdev_put(p);\r\nreturn ret;\r\n}\r\nvoid cd_forget(struct inode *inode)\r\n{\r\nspin_lock(&cdev_lock);\r\nlist_del_init(&inode->i_devices);\r\ninode->i_cdev = NULL;\r\ninode->i_mapping = &inode->i_data;\r\nspin_unlock(&cdev_lock);\r\n}\r\nstatic void cdev_purge(struct cdev *cdev)\r\n{\r\nspin_lock(&cdev_lock);\r\nwhile (!list_empty(&cdev->list)) {\r\nstruct inode *inode;\r\ninode = container_of(cdev->list.next, struct inode, i_devices);\r\nlist_del_init(&inode->i_devices);\r\ninode->i_cdev = NULL;\r\n}\r\nspin_unlock(&cdev_lock);\r\n}\r\nstatic struct kobject *exact_match(dev_t dev, int *part, void *data)\r\n{\r\nstruct cdev *p = data;\r\nreturn &p->kobj;\r\n}\r\nstatic int exact_lock(dev_t dev, void *data)\r\n{\r\nstruct cdev *p = data;\r\nreturn cdev_get(p) ? 0 : -1;\r\n}\r\nint cdev_add(struct cdev *p, dev_t dev, unsigned count)\r\n{\r\nint error;\r\np->dev = dev;\r\np->count = count;\r\nerror = kobj_map(cdev_map, dev, count, NULL,\r\nexact_match, exact_lock, p);\r\nif (error)\r\nreturn error;\r\nkobject_get(p->kobj.parent);\r\nreturn 0;\r\n}\r\nstatic void cdev_unmap(dev_t dev, unsigned count)\r\n{\r\nkobj_unmap(cdev_map, dev, count);\r\n}\r\nvoid cdev_del(struct cdev *p)\r\n{\r\ncdev_unmap(p->dev, p->count);\r\nkobject_put(&p->kobj);\r\n}\r\nstatic void cdev_default_release(struct kobject *kobj)\r\n{\r\nstruct cdev *p = container_of(kobj, struct cdev, kobj);\r\nstruct kobject *parent = kobj->parent;\r\ncdev_purge(p);\r\nkobject_put(parent);\r\n}\r\nstatic void cdev_dynamic_release(struct kobject *kobj)\r\n{\r\nstruct cdev *p = container_of(kobj, struct cdev, kobj);\r\nstruct kobject *parent = kobj->parent;\r\ncdev_purge(p);\r\nkfree(p);\r\nkobject_put(parent);\r\n}\r\nstruct cdev *cdev_alloc(void)\r\n{\r\nstruct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);\r\nif (p) {\r\nINIT_LIST_HEAD(&p->list);\r\nkobject_init(&p->kobj, &ktype_cdev_dynamic);\r\n}\r\nreturn p;\r\n}\r\nvoid cdev_init(struct cdev *cdev, const struct file_operations *fops)\r\n{\r\nmemset(cdev, 0, sizeof *cdev);\r\nINIT_LIST_HEAD(&cdev->list);\r\nkobject_init(&cdev->kobj, &ktype_cdev_default);\r\ncdev->ops = fops;\r\n}\r\nstatic struct kobject *base_probe(dev_t dev, int *part, void *data)\r\n{\r\nif (request_module("char-major-%d-%d", MAJOR(dev), MINOR(dev)) > 0)\r\nrequest_module("char-major-%d", MAJOR(dev));\r\nreturn NULL;\r\n}\r\nvoid __init chrdev_init(void)\r\n{\r\ncdev_map = kobj_map_init(base_probe, &chrdevs_lock);\r\n}
