void\r\ndisplay_buffer(char *buffer, int length)\r\n{\r\nif ((pc_debug & SHOW_BUFFER_CONTENTS) == 0)\r\nreturn;\r\nwhile (length > 0) {\r\nprintk("[%02x]", *buffer & 255);\r\nlength--;\r\nbuffer++;\r\n}\r\nprintk("\n");\r\n}\r\nstatic void\r\npimfor_encode_header(int operation, u32 oid, u32 length, pimfor_header_t *h)\r\n{\r\nh->version = PIMFOR_VERSION;\r\nh->operation = operation;\r\nh->device_id = PIMFOR_DEV_ID_MHLI_MIB;\r\nh->flags = 0;\r\nh->oid = cpu_to_be32(oid);\r\nh->length = cpu_to_be32(length);\r\n}\r\nstatic pimfor_header_t *\r\npimfor_decode_header(void *data, int len)\r\n{\r\npimfor_header_t *h = data;\r\nwhile ((void *) h < data + len) {\r\nif (h->flags & PIMFOR_FLAG_LITTLE_ENDIAN) {\r\nle32_to_cpus(&h->oid);\r\nle32_to_cpus(&h->length);\r\n} else {\r\nbe32_to_cpus(&h->oid);\r\nbe32_to_cpus(&h->length);\r\n}\r\nif (h->oid != OID_INL_TUNNEL)\r\nreturn h;\r\nh++;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nislpci_mgmt_rx_fill(struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nisl38xx_control_block *cb =\r\n(isl38xx_control_block *) priv->control_block;\r\nu32 curr = le32_to_cpu(cb->driver_curr_frag[ISL38XX_CB_RX_MGMTQ]);\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "islpci_mgmt_rx_fill\n");\r\n#endif\r\nwhile (curr - priv->index_mgmt_rx < ISL38XX_CB_MGMT_QSIZE) {\r\nu32 index = curr % ISL38XX_CB_MGMT_QSIZE;\r\nstruct islpci_membuf *buf = &priv->mgmt_rx[index];\r\nisl38xx_fragment *frag = &cb->rx_data_mgmt[index];\r\nif (buf->mem == NULL) {\r\nbuf->mem = kmalloc(MGMT_FRAME_SIZE, GFP_ATOMIC);\r\nif (!buf->mem)\r\nreturn -ENOMEM;\r\nbuf->size = MGMT_FRAME_SIZE;\r\n}\r\nif (buf->pci_addr == 0) {\r\nbuf->pci_addr = pci_map_single(priv->pdev, buf->mem,\r\nMGMT_FRAME_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, buf->pci_addr)) {\r\nprintk(KERN_WARNING\r\n"Failed to make memory DMA'able.\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfrag->size = cpu_to_le16(MGMT_FRAME_SIZE);\r\nfrag->flags = 0;\r\nfrag->address = cpu_to_le32(buf->pci_addr);\r\ncurr++;\r\nwmb();\r\ncb->driver_curr_frag[ISL38XX_CB_RX_MGMTQ] = cpu_to_le32(curr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nislpci_mgt_transmit(struct net_device *ndev, int operation, unsigned long oid,\r\nvoid *data, int length)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nisl38xx_control_block *cb =\r\n(isl38xx_control_block *) priv->control_block;\r\nvoid *p;\r\nint err = -EINVAL;\r\nunsigned long flags;\r\nisl38xx_fragment *frag;\r\nstruct islpci_membuf buf;\r\nu32 curr_frag;\r\nint index;\r\nint frag_len = length + PIMFOR_HEADER_SIZE;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "islpci_mgt_transmit\n");\r\n#endif\r\nif (frag_len > MGMT_FRAME_SIZE) {\r\nprintk(KERN_DEBUG "%s: mgmt frame too large %d\n",\r\nndev->name, frag_len);\r\ngoto error;\r\n}\r\nerr = -ENOMEM;\r\np = buf.mem = kmalloc(frag_len, GFP_KERNEL);\r\nif (!buf.mem)\r\ngoto error;\r\nbuf.size = frag_len;\r\npimfor_encode_header(operation, oid, length, (pimfor_header_t *) p);\r\np += PIMFOR_HEADER_SIZE;\r\nif (data)\r\nmemcpy(p, data, length);\r\nelse\r\nmemset(p, 0, length);\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\n{\r\npimfor_header_t *h = buf.mem;\r\nDEBUG(SHOW_PIMFOR_FRAMES,\r\n"PIMFOR: op %i, oid 0x%08lx, device %i, flags 0x%x length 0x%x\n",\r\nh->operation, oid, h->device_id, h->flags, length);\r\ndisplay_buffer((char *) h, sizeof (pimfor_header_t));\r\ndisplay_buffer(p, length);\r\n}\r\n#endif\r\nerr = -ENOMEM;\r\nbuf.pci_addr = pci_map_single(priv->pdev, buf.mem, frag_len,\r\nPCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, buf.pci_addr)) {\r\nprintk(KERN_WARNING "%s: cannot map PCI memory for mgmt\n",\r\nndev->name);\r\ngoto error_free;\r\n}\r\nspin_lock_irqsave(&priv->slock, flags);\r\ncurr_frag = le32_to_cpu(cb->driver_curr_frag[ISL38XX_CB_TX_MGMTQ]);\r\nif (curr_frag - priv->index_mgmt_tx >= ISL38XX_CB_MGMT_QSIZE) {\r\nprintk(KERN_WARNING "%s: mgmt tx queue is still full\n",\r\nndev->name);\r\ngoto error_unlock;\r\n}\r\nindex = curr_frag % ISL38XX_CB_MGMT_QSIZE;\r\npriv->mgmt_tx[index] = buf;\r\nfrag = &cb->tx_data_mgmt[index];\r\nfrag->size = cpu_to_le16(frag_len);\r\nfrag->flags = 0;\r\nfrag->address = cpu_to_le32(buf.pci_addr);\r\nwmb();\r\ncb->driver_curr_frag[ISL38XX_CB_TX_MGMTQ] = cpu_to_le32(curr_frag + 1);\r\nspin_unlock_irqrestore(&priv->slock, flags);\r\nislpci_trigger(priv);\r\nreturn 0;\r\nerror_unlock:\r\nspin_unlock_irqrestore(&priv->slock, flags);\r\nerror_free:\r\nkfree(buf.mem);\r\nerror:\r\nreturn err;\r\n}\r\nint\r\nislpci_mgt_receive(struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nisl38xx_control_block *cb =\r\n(isl38xx_control_block *) priv->control_block;\r\nu32 curr_frag;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "islpci_mgt_receive\n");\r\n#endif\r\ncurr_frag = le32_to_cpu(cb->device_curr_frag[ISL38XX_CB_RX_MGMTQ]);\r\nbarrier();\r\nfor (; priv->index_mgmt_rx < curr_frag; priv->index_mgmt_rx++) {\r\npimfor_header_t *header;\r\nu32 index = priv->index_mgmt_rx % ISL38XX_CB_MGMT_QSIZE;\r\nstruct islpci_membuf *buf = &priv->mgmt_rx[index];\r\nu16 frag_len;\r\nint size;\r\nstruct islpci_mgmtframe *frame;\r\nif (le16_to_cpu(cb->rx_data_mgmt[index].flags) != 0) {\r\nprintk(KERN_WARNING "%s: unknown flags 0x%04x\n",\r\nndev->name,\r\nle16_to_cpu(cb->rx_data_mgmt[index].flags));\r\ncontinue;\r\n}\r\nfrag_len = le16_to_cpu(cb->rx_data_mgmt[index].size);\r\nif (frag_len > MGMT_FRAME_SIZE) {\r\nprintk(KERN_WARNING\r\n"%s: Bogus packet size of %d (%#x).\n",\r\nndev->name, frag_len, frag_len);\r\nfrag_len = MGMT_FRAME_SIZE;\r\n}\r\npci_dma_sync_single_for_cpu(priv->pdev, buf->pci_addr,\r\nbuf->size, PCI_DMA_FROMDEVICE);\r\nheader = pimfor_decode_header(buf->mem, frag_len);\r\nif (!header) {\r\nprintk(KERN_WARNING "%s: no PIMFOR header found\n",\r\nndev->name);\r\ncontinue;\r\n}\r\nheader->device_id = priv->ndev->ifindex;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_PIMFOR_FRAMES,\r\n"PIMFOR: op %i, oid 0x%08x, device %i, flags 0x%x length 0x%x\n",\r\nheader->operation, header->oid, header->device_id,\r\nheader->flags, header->length);\r\ndisplay_buffer((char *) header, PIMFOR_HEADER_SIZE);\r\ndisplay_buffer((char *) header + PIMFOR_HEADER_SIZE,\r\nheader->length);\r\n#endif\r\nif (header->flags & PIMFOR_FLAG_APPLIC_ORIGIN) {\r\nprintk(KERN_DEBUG\r\n"%s: errant PIMFOR application frame\n",\r\nndev->name);\r\ncontinue;\r\n}\r\nsize = PIMFOR_HEADER_SIZE + header->length;\r\nframe = kmalloc(sizeof(struct islpci_mgmtframe) + size,\r\nGFP_ATOMIC);\r\nif (!frame)\r\ncontinue;\r\nframe->ndev = ndev;\r\nmemcpy(&frame->buf, header, size);\r\nframe->header = (pimfor_header_t *) frame->buf;\r\nframe->data = frame->buf + PIMFOR_HEADER_SIZE;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_PIMFOR_FRAMES,\r\n"frame: header: %p, data: %p, size: %d\n",\r\nframe->header, frame->data, size);\r\n#endif\r\nif (header->operation == PIMFOR_OP_TRAP) {\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nprintk(KERN_DEBUG\r\n"TRAP: oid 0x%x, device %i, flags 0x%x length %i\n",\r\nheader->oid, header->device_id, header->flags,\r\nheader->length);\r\n#endif\r\nINIT_WORK(&frame->ws, prism54_process_trap);\r\nschedule_work(&frame->ws);\r\n} else {\r\nif ((frame = xchg(&priv->mgmt_received, frame)) != NULL) {\r\nprintk(KERN_WARNING\r\n"%s: mgmt response not collected\n",\r\nndev->name);\r\nkfree(frame);\r\n}\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_TRACING, "Wake up Mgmt Queue\n");\r\n#endif\r\nwake_up(&priv->mgmt_wqueue);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nislpci_mgt_cleanup_transmit(struct net_device *ndev)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nisl38xx_control_block *cb =\r\n(isl38xx_control_block *) priv->control_block;\r\nu32 curr_frag;\r\n#if VERBOSE > SHOW_ERROR_MESSAGES\r\nDEBUG(SHOW_FUNCTION_CALLS, "islpci_mgt_cleanup_transmit\n");\r\n#endif\r\ncurr_frag = le32_to_cpu(cb->device_curr_frag[ISL38XX_CB_TX_MGMTQ]);\r\nbarrier();\r\nfor (; priv->index_mgmt_tx < curr_frag; priv->index_mgmt_tx++) {\r\nint index = priv->index_mgmt_tx % ISL38XX_CB_MGMT_QSIZE;\r\nstruct islpci_membuf *buf = &priv->mgmt_tx[index];\r\npci_unmap_single(priv->pdev, buf->pci_addr, buf->size,\r\nPCI_DMA_TODEVICE);\r\nbuf->pci_addr = 0;\r\nkfree(buf->mem);\r\nbuf->mem = NULL;\r\nbuf->size = 0;\r\n}\r\n}\r\nint\r\nislpci_mgt_transaction(struct net_device *ndev,\r\nint operation, unsigned long oid,\r\nvoid *senddata, int sendlen,\r\nstruct islpci_mgmtframe **recvframe)\r\n{\r\nislpci_private *priv = netdev_priv(ndev);\r\nconst long wait_cycle_jiffies = msecs_to_jiffies(ISL38XX_WAIT_CYCLE * 10);\r\nlong timeout_left = ISL38XX_MAX_WAIT_CYCLES * wait_cycle_jiffies;\r\nint err;\r\nDEFINE_WAIT(wait);\r\n*recvframe = NULL;\r\nif (mutex_lock_interruptible(&priv->mgmt_lock))\r\nreturn -ERESTARTSYS;\r\nprepare_to_wait(&priv->mgmt_wqueue, &wait, TASK_UNINTERRUPTIBLE);\r\nerr = islpci_mgt_transmit(ndev, operation, oid, senddata, sendlen);\r\nif (err)\r\ngoto out;\r\nerr = -ETIMEDOUT;\r\nwhile (timeout_left > 0) {\r\nint timeleft;\r\nstruct islpci_mgmtframe *frame;\r\ntimeleft = schedule_timeout_uninterruptible(wait_cycle_jiffies);\r\nframe = xchg(&priv->mgmt_received, NULL);\r\nif (frame) {\r\nif (frame->header->oid == oid) {\r\n*recvframe = frame;\r\nerr = 0;\r\ngoto out;\r\n} else {\r\nprintk(KERN_DEBUG\r\n"%s: expecting oid 0x%x, received 0x%x.\n",\r\nndev->name, (unsigned int) oid,\r\nframe->header->oid);\r\nkfree(frame);\r\nframe = NULL;\r\n}\r\n}\r\nif (timeleft == 0) {\r\nprintk(KERN_DEBUG\r\n"%s: timeout waiting for mgmt response %lu, "\r\n"triggering device\n",\r\nndev->name, timeout_left);\r\nislpci_trigger(priv);\r\n}\r\ntimeout_left += timeleft - wait_cycle_jiffies;\r\n}\r\nprintk(KERN_WARNING "%s: timeout waiting for mgmt response\n",\r\nndev->name);\r\nout:\r\nfinish_wait(&priv->mgmt_wqueue, &wait);\r\nmutex_unlock(&priv->mgmt_lock);\r\nreturn err;\r\n}
