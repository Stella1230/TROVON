static irqreturn_t vsp1_irq_handler(int irq, void *data)\r\n{\r\nu32 mask = VI6_WFP_IRQ_STA_DFE | VI6_WFP_IRQ_STA_FRE;\r\nstruct vsp1_device *vsp1 = data;\r\nirqreturn_t ret = IRQ_NONE;\r\nunsigned int i;\r\nu32 status;\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf = vsp1->wpf[i];\r\nif (wpf == NULL)\r\ncontinue;\r\nstatus = vsp1_read(vsp1, VI6_WPF_IRQ_STA(i));\r\nvsp1_write(vsp1, VI6_WPF_IRQ_STA(i), ~status & mask);\r\nif (status & VI6_WFP_IRQ_STA_DFE) {\r\nvsp1_pipeline_frame_end(wpf->pipe);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\nstatus = vsp1_read(vsp1, VI6_DISP_IRQ_STA);\r\nvsp1_write(vsp1, VI6_DISP_IRQ_STA, ~status & VI6_DISP_IRQ_STA_DST);\r\nif (status & VI6_DISP_IRQ_STA_DST) {\r\nvsp1_drm_display_start(vsp1);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vsp1_create_sink_links(struct vsp1_device *vsp1,\r\nstruct vsp1_entity *sink)\r\n{\r\nstruct media_entity *entity = &sink->subdev.entity;\r\nstruct vsp1_entity *source;\r\nunsigned int pad;\r\nint ret;\r\nlist_for_each_entry(source, &vsp1->entities, list_dev) {\r\nu32 flags;\r\nif (source->type == sink->type)\r\ncontinue;\r\nif (source->type == VSP1_ENTITY_LIF ||\r\nsource->type == VSP1_ENTITY_WPF)\r\ncontinue;\r\nflags = source->type == VSP1_ENTITY_RPF &&\r\nsink->type == VSP1_ENTITY_WPF &&\r\nsource->index == sink->index\r\n? MEDIA_LNK_FL_ENABLED : 0;\r\nfor (pad = 0; pad < entity->num_pads; ++pad) {\r\nif (!(entity->pads[pad].flags & MEDIA_PAD_FL_SINK))\r\ncontinue;\r\nret = media_create_pad_link(&source->subdev.entity,\r\nsource->source_pad,\r\nentity, pad, flags);\r\nif (ret < 0)\r\nreturn ret;\r\nif (flags & MEDIA_LNK_FL_ENABLED)\r\nsource->sink = entity;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vsp1_uapi_create_links(struct vsp1_device *vsp1)\r\n{\r\nstruct vsp1_entity *entity;\r\nunsigned int i;\r\nint ret;\r\nlist_for_each_entry(entity, &vsp1->entities, list_dev) {\r\nif (entity->type == VSP1_ENTITY_LIF ||\r\nentity->type == VSP1_ENTITY_RPF)\r\ncontinue;\r\nret = vsp1_create_sink_links(vsp1, entity);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (vsp1->lif) {\r\nret = media_create_pad_link(&vsp1->wpf[0]->entity.subdev.entity,\r\nRWPF_PAD_SOURCE,\r\n&vsp1->lif->entity.subdev.entity,\r\nLIF_PAD_SINK, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < vsp1->info->rpf_count; ++i) {\r\nstruct vsp1_rwpf *rpf = vsp1->rpf[i];\r\nret = media_create_pad_link(&rpf->video->video.entity, 0,\r\n&rpf->entity.subdev.entity,\r\nRWPF_PAD_SINK,\r\nMEDIA_LNK_FL_ENABLED |\r\nMEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf = vsp1->wpf[i];\r\nret = media_create_pad_link(&wpf->entity.subdev.entity,\r\nRWPF_PAD_SOURCE,\r\n&wpf->video->video.entity, 0,\r\nMEDIA_LNK_FL_IMMUTABLE |\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vsp1_destroy_entities(struct vsp1_device *vsp1)\r\n{\r\nstruct vsp1_entity *entity, *_entity;\r\nstruct vsp1_video *video, *_video;\r\nlist_for_each_entry_safe(entity, _entity, &vsp1->entities, list_dev) {\r\nlist_del(&entity->list_dev);\r\nvsp1_entity_destroy(entity);\r\n}\r\nlist_for_each_entry_safe(video, _video, &vsp1->videos, list) {\r\nlist_del(&video->list);\r\nvsp1_video_cleanup(video);\r\n}\r\nv4l2_device_unregister(&vsp1->v4l2_dev);\r\nif (vsp1->info->uapi)\r\nmedia_device_unregister(&vsp1->media_dev);\r\nmedia_device_cleanup(&vsp1->media_dev);\r\nif (!vsp1->info->uapi)\r\nvsp1_drm_cleanup(vsp1);\r\n}\r\nstatic int vsp1_create_entities(struct vsp1_device *vsp1)\r\n{\r\nstruct media_device *mdev = &vsp1->media_dev;\r\nstruct v4l2_device *vdev = &vsp1->v4l2_dev;\r\nstruct vsp1_entity *entity;\r\nunsigned int i;\r\nint ret;\r\nmdev->dev = vsp1->dev;\r\nmdev->hw_revision = vsp1->version;\r\nstrlcpy(mdev->model, vsp1->info->model, sizeof(mdev->model));\r\nsnprintf(mdev->bus_info, sizeof(mdev->bus_info), "platform:%s",\r\ndev_name(mdev->dev));\r\nmedia_device_init(mdev);\r\nvsp1->media_ops.link_setup = vsp1_entity_link_setup;\r\nif (vsp1->info->uapi)\r\nvsp1->media_ops.link_validate = v4l2_subdev_link_validate;\r\nvdev->mdev = mdev;\r\nret = v4l2_device_register(vsp1->dev, vdev);\r\nif (ret < 0) {\r\ndev_err(vsp1->dev, "V4L2 device registration failed (%d)\n",\r\nret);\r\ngoto done;\r\n}\r\nif (vsp1->info->features & VSP1_HAS_BRU) {\r\nvsp1->bru = vsp1_bru_create(vsp1);\r\nif (IS_ERR(vsp1->bru)) {\r\nret = PTR_ERR(vsp1->bru);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->bru->entity.list_dev, &vsp1->entities);\r\n}\r\nif (vsp1->info->features & VSP1_HAS_CLU) {\r\nvsp1->clu = vsp1_clu_create(vsp1);\r\nif (IS_ERR(vsp1->clu)) {\r\nret = PTR_ERR(vsp1->clu);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->clu->entity.list_dev, &vsp1->entities);\r\n}\r\nvsp1->hsi = vsp1_hsit_create(vsp1, true);\r\nif (IS_ERR(vsp1->hsi)) {\r\nret = PTR_ERR(vsp1->hsi);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->hsi->entity.list_dev, &vsp1->entities);\r\nvsp1->hst = vsp1_hsit_create(vsp1, false);\r\nif (IS_ERR(vsp1->hst)) {\r\nret = PTR_ERR(vsp1->hst);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->hst->entity.list_dev, &vsp1->entities);\r\nif (vsp1->info->features & VSP1_HAS_LIF && !vsp1->info->uapi) {\r\nvsp1->lif = vsp1_lif_create(vsp1);\r\nif (IS_ERR(vsp1->lif)) {\r\nret = PTR_ERR(vsp1->lif);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->lif->entity.list_dev, &vsp1->entities);\r\n}\r\nif (vsp1->info->features & VSP1_HAS_LUT) {\r\nvsp1->lut = vsp1_lut_create(vsp1);\r\nif (IS_ERR(vsp1->lut)) {\r\nret = PTR_ERR(vsp1->lut);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->lut->entity.list_dev, &vsp1->entities);\r\n}\r\nfor (i = 0; i < vsp1->info->rpf_count; ++i) {\r\nstruct vsp1_rwpf *rpf;\r\nrpf = vsp1_rpf_create(vsp1, i);\r\nif (IS_ERR(rpf)) {\r\nret = PTR_ERR(rpf);\r\ngoto done;\r\n}\r\nvsp1->rpf[i] = rpf;\r\nlist_add_tail(&rpf->entity.list_dev, &vsp1->entities);\r\nif (vsp1->info->uapi) {\r\nstruct vsp1_video *video = vsp1_video_create(vsp1, rpf);\r\nif (IS_ERR(video)) {\r\nret = PTR_ERR(video);\r\ngoto done;\r\n}\r\nlist_add_tail(&video->list, &vsp1->videos);\r\n}\r\n}\r\nif (vsp1->info->features & VSP1_HAS_SRU) {\r\nvsp1->sru = vsp1_sru_create(vsp1);\r\nif (IS_ERR(vsp1->sru)) {\r\nret = PTR_ERR(vsp1->sru);\r\ngoto done;\r\n}\r\nlist_add_tail(&vsp1->sru->entity.list_dev, &vsp1->entities);\r\n}\r\nfor (i = 0; i < vsp1->info->uds_count; ++i) {\r\nstruct vsp1_uds *uds;\r\nuds = vsp1_uds_create(vsp1, i);\r\nif (IS_ERR(uds)) {\r\nret = PTR_ERR(uds);\r\ngoto done;\r\n}\r\nvsp1->uds[i] = uds;\r\nlist_add_tail(&uds->entity.list_dev, &vsp1->entities);\r\n}\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nstruct vsp1_rwpf *wpf;\r\nwpf = vsp1_wpf_create(vsp1, i);\r\nif (IS_ERR(wpf)) {\r\nret = PTR_ERR(wpf);\r\ngoto done;\r\n}\r\nvsp1->wpf[i] = wpf;\r\nlist_add_tail(&wpf->entity.list_dev, &vsp1->entities);\r\nif (vsp1->info->uapi) {\r\nstruct vsp1_video *video = vsp1_video_create(vsp1, wpf);\r\nif (IS_ERR(video)) {\r\nret = PTR_ERR(video);\r\ngoto done;\r\n}\r\nlist_add_tail(&video->list, &vsp1->videos);\r\nwpf->entity.sink = &video->video.entity;\r\n}\r\n}\r\nlist_for_each_entry(entity, &vsp1->entities, list_dev) {\r\nret = v4l2_device_register_subdev(&vsp1->v4l2_dev,\r\n&entity->subdev);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nif (vsp1->info->uapi)\r\nret = vsp1_uapi_create_links(vsp1);\r\nelse\r\nret = vsp1_drm_create_links(vsp1);\r\nif (ret < 0)\r\ngoto done;\r\nif (vsp1->info->uapi) {\r\nret = v4l2_device_register_subdev_nodes(&vsp1->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = media_device_register(mdev);\r\n} else {\r\nret = vsp1_drm_init(vsp1);\r\n}\r\ndone:\r\nif (ret < 0)\r\nvsp1_destroy_entities(vsp1);\r\nreturn ret;\r\n}\r\nint vsp1_reset_wpf(struct vsp1_device *vsp1, unsigned int index)\r\n{\r\nunsigned int timeout;\r\nu32 status;\r\nstatus = vsp1_read(vsp1, VI6_STATUS);\r\nif (!(status & VI6_STATUS_SYS_ACT(index)))\r\nreturn 0;\r\nvsp1_write(vsp1, VI6_SRESET, VI6_SRESET_SRTS(index));\r\nfor (timeout = 10; timeout > 0; --timeout) {\r\nstatus = vsp1_read(vsp1, VI6_STATUS);\r\nif (!(status & VI6_STATUS_SYS_ACT(index)))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (!timeout) {\r\ndev_err(vsp1->dev, "failed to reset wpf.%u\n", index);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vsp1_device_init(struct vsp1_device *vsp1)\r\n{\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < vsp1->info->wpf_count; ++i) {\r\nret = vsp1_reset_wpf(vsp1, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nvsp1_write(vsp1, VI6_CLK_DCSWT, (8 << VI6_CLK_DCSWT_CSTPW_SHIFT) |\r\n(8 << VI6_CLK_DCSWT_CSTRW_SHIFT));\r\nfor (i = 0; i < vsp1->info->rpf_count; ++i)\r\nvsp1_write(vsp1, VI6_DPR_RPF_ROUTE(i), VI6_DPR_NODE_UNUSED);\r\nfor (i = 0; i < vsp1->info->uds_count; ++i)\r\nvsp1_write(vsp1, VI6_DPR_UDS_ROUTE(i), VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_SRU_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_LUT_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_CLU_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_HST_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_HSI_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_BRU_ROUTE, VI6_DPR_NODE_UNUSED);\r\nvsp1_write(vsp1, VI6_DPR_HGO_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |\r\n(VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));\r\nvsp1_write(vsp1, VI6_DPR_HGT_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |\r\n(VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));\r\nvsp1_dlm_setup(vsp1);\r\nreturn 0;\r\n}\r\nint vsp1_device_get(struct vsp1_device *vsp1)\r\n{\r\nint ret;\r\nret = pm_runtime_get_sync(vsp1->dev);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nvoid vsp1_device_put(struct vsp1_device *vsp1)\r\n{\r\npm_runtime_put_sync(vsp1->dev);\r\n}\r\nstatic int __maybe_unused vsp1_pm_suspend(struct device *dev)\r\n{\r\nstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\r\nvsp1_pipelines_suspend(vsp1);\r\npm_runtime_force_suspend(vsp1->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused vsp1_pm_resume(struct device *dev)\r\n{\r\nstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\r\npm_runtime_force_resume(vsp1->dev);\r\nvsp1_pipelines_resume(vsp1);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused vsp1_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\r\nrcar_fcp_disable(vsp1->fcp);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused vsp1_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct vsp1_device *vsp1 = dev_get_drvdata(dev);\r\nint ret;\r\nif (vsp1->info) {\r\nret = vsp1_device_init(vsp1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn rcar_fcp_enable(vsp1->fcp);\r\n}\r\nstatic int vsp1_probe(struct platform_device *pdev)\r\n{\r\nstruct vsp1_device *vsp1;\r\nstruct device_node *fcp_node;\r\nstruct resource *irq;\r\nstruct resource *io;\r\nunsigned int i;\r\nint ret;\r\nvsp1 = devm_kzalloc(&pdev->dev, sizeof(*vsp1), GFP_KERNEL);\r\nif (vsp1 == NULL)\r\nreturn -ENOMEM;\r\nvsp1->dev = &pdev->dev;\r\nINIT_LIST_HEAD(&vsp1->entities);\r\nINIT_LIST_HEAD(&vsp1->videos);\r\nplatform_set_drvdata(pdev, vsp1);\r\nio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvsp1->mmio = devm_ioremap_resource(&pdev->dev, io);\r\nif (IS_ERR(vsp1->mmio))\r\nreturn PTR_ERR(vsp1->mmio);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "missing IRQ\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq->start, vsp1_irq_handler,\r\nIRQF_SHARED, dev_name(&pdev->dev), vsp1);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\nreturn ret;\r\n}\r\nfcp_node = of_parse_phandle(pdev->dev.of_node, "renesas,fcp", 0);\r\nif (fcp_node) {\r\nvsp1->fcp = rcar_fcp_get(fcp_node);\r\nof_node_put(fcp_node);\r\nif (IS_ERR(vsp1->fcp)) {\r\ndev_dbg(&pdev->dev, "FCP not found (%ld)\n",\r\nPTR_ERR(vsp1->fcp));\r\nreturn PTR_ERR(vsp1->fcp);\r\n}\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0)\r\ngoto done;\r\nvsp1->version = vsp1_read(vsp1, VI6_IP_VERSION);\r\npm_runtime_put_sync(&pdev->dev);\r\nfor (i = 0; i < ARRAY_SIZE(vsp1_device_infos); ++i) {\r\nif ((vsp1->version & VI6_IP_VERSION_MODEL_MASK) ==\r\nvsp1_device_infos[i].version) {\r\nvsp1->info = &vsp1_device_infos[i];\r\nbreak;\r\n}\r\n}\r\nif (!vsp1->info) {\r\ndev_err(&pdev->dev, "unsupported IP version 0x%08x\n",\r\nvsp1->version);\r\nret = -ENXIO;\r\ngoto done;\r\n}\r\ndev_dbg(&pdev->dev, "IP version 0x%08x\n", vsp1->version);\r\nret = vsp1_create_entities(vsp1);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to create entities\n");\r\ngoto done;\r\n}\r\ndone:\r\nif (ret)\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int vsp1_remove(struct platform_device *pdev)\r\n{\r\nstruct vsp1_device *vsp1 = platform_get_drvdata(pdev);\r\nvsp1_destroy_entities(vsp1);\r\nrcar_fcp_put(vsp1->fcp);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
