static int surface3_button_lookup_gpio(struct device *dev, int acpi_index)\r\n{\r\nstruct gpio_desc *desc;\r\nint gpio;\r\ndesc = gpiod_get_index(dev, NULL, acpi_index, GPIOD_ASIS);\r\nif (IS_ERR(desc))\r\nreturn PTR_ERR(desc);\r\ngpio = desc_to_gpio(desc);\r\ngpiod_put(desc);\r\nreturn gpio;\r\n}\r\nstatic struct platform_device *\r\nsurface3_button_device_create(struct i2c_client *client,\r\nconst struct surface3_button_info *button_info,\r\nbool autorepeat)\r\n{\r\nconst struct surface3_button_info *info;\r\nstruct platform_device *pd;\r\nstruct gpio_keys_button *gpio_keys;\r\nstruct gpio_keys_platform_data *gpio_keys_pdata;\r\nint n_buttons = 0;\r\nint gpio;\r\nint error;\r\ngpio_keys_pdata = devm_kzalloc(&client->dev,\r\nsizeof(*gpio_keys_pdata) +\r\nsizeof(*gpio_keys) * MAX_NBUTTONS,\r\nGFP_KERNEL);\r\nif (!gpio_keys_pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\ngpio_keys = (void *)(gpio_keys_pdata + 1);\r\nfor (info = button_info; info->name; info++) {\r\nif (info->autorepeat != autorepeat)\r\ncontinue;\r\ngpio = surface3_button_lookup_gpio(&client->dev,\r\ninfo->acpi_index);\r\nif (!gpio_is_valid(gpio))\r\ncontinue;\r\ngpio_keys[n_buttons].type = info->event_type;\r\ngpio_keys[n_buttons].code = info->event_code;\r\ngpio_keys[n_buttons].gpio = gpio;\r\ngpio_keys[n_buttons].active_low = info->active_low;\r\ngpio_keys[n_buttons].desc = info->name;\r\ngpio_keys[n_buttons].wakeup = info->wakeup;\r\nn_buttons++;\r\n}\r\nif (n_buttons == 0) {\r\nerror = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\ngpio_keys_pdata->buttons = gpio_keys;\r\ngpio_keys_pdata->nbuttons = n_buttons;\r\ngpio_keys_pdata->rep = autorepeat;\r\npd = platform_device_alloc("gpio-keys", PLATFORM_DEVID_AUTO);\r\nif (!pd) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nerror = platform_device_add_data(pd, gpio_keys_pdata,\r\nsizeof(*gpio_keys_pdata));\r\nif (error)\r\ngoto err_free_pdev;\r\nerror = platform_device_add(pd);\r\nif (error)\r\ngoto err_free_pdev;\r\nreturn pd;\r\nerr_free_pdev:\r\nplatform_device_put(pd);\r\nerr_free_mem:\r\ndevm_kfree(&client->dev, gpio_keys_pdata);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic int surface3_button_remove(struct i2c_client *client)\r\n{\r\nstruct surface3_button_data *priv = i2c_get_clientdata(client);\r\nint i;\r\nfor (i = 0; i < BUTTON_TYPES; i++)\r\nif (priv->children[i])\r\nplatform_device_unregister(priv->children[i]);\r\nreturn 0;\r\n}\r\nstatic int surface3_button_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct surface3_button_data *priv;\r\nstruct platform_device *pd;\r\nint i;\r\nint error;\r\nif (strncmp(acpi_device_bid(ACPI_COMPANION(&client->dev)),\r\nSURFACE_BUTTON_OBJ_NAME,\r\nstrlen(SURFACE_BUTTON_OBJ_NAME)))\r\nreturn -ENODEV;\r\nif (gpiod_count(dev, KBUILD_MODNAME) <= 0) {\r\ndev_dbg(dev, "no GPIO attached, ignoring...\n");\r\nreturn -ENODEV;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, priv);\r\nfor (i = 0; i < BUTTON_TYPES; i++) {\r\npd = surface3_button_device_create(client,\r\nsurface3_button_surface3,\r\ni == 0);\r\nif (IS_ERR(pd)) {\r\nerror = PTR_ERR(pd);\r\nif (error != -ENODEV) {\r\nsurface3_button_remove(client);\r\nreturn error;\r\n}\r\ncontinue;\r\n}\r\npriv->children[i] = pd;\r\n}\r\nif (!priv->children[0] && !priv->children[1])\r\nreturn -ENODEV;\r\nreturn 0;\r\n}
