int cifs_remap(struct cifs_sb_info *cifs_sb)\r\n{\r\nint map_type;\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\r\nmap_type = SFM_MAP_UNI_RSVD;\r\nelse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\r\nmap_type = SFU_MAP_UNI_RSVD;\r\nelse\r\nmap_type = NO_MAP_UNI_RSVD;\r\nreturn map_type;\r\n}\r\nstatic bool\r\nconvert_sfu_char(const __u16 src_char, char *target)\r\n{\r\nswitch (src_char) {\r\ncase UNI_COLON:\r\n*target = ':';\r\nbreak;\r\ncase UNI_ASTERISK:\r\n*target = '*';\r\nbreak;\r\ncase UNI_QUESTION:\r\n*target = '?';\r\nbreak;\r\ncase UNI_PIPE:\r\n*target = '|';\r\nbreak;\r\ncase UNI_GRTRTHAN:\r\n*target = '>';\r\nbreak;\r\ncase UNI_LESSTHAN:\r\n*target = '<';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\nconvert_sfm_char(const __u16 src_char, char *target)\r\n{\r\nswitch (src_char) {\r\ncase SFM_COLON:\r\n*target = ':';\r\nbreak;\r\ncase SFM_ASTERISK:\r\n*target = '*';\r\nbreak;\r\ncase SFM_QUESTION:\r\n*target = '?';\r\nbreak;\r\ncase SFM_PIPE:\r\n*target = '|';\r\nbreak;\r\ncase SFM_GRTRTHAN:\r\n*target = '>';\r\nbreak;\r\ncase SFM_LESSTHAN:\r\n*target = '<';\r\nbreak;\r\ncase SFM_SLASH:\r\n*target = '\\';\r\nbreak;\r\ncase SFM_SPACE:\r\n*target = ' ';\r\nbreak;\r\ncase SFM_PERIOD:\r\n*target = '.';\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int\r\ncifs_mapchar(char *target, const __u16 *from, const struct nls_table *cp,\r\nint maptype)\r\n{\r\nint len = 1;\r\n__u16 src_char;\r\nsrc_char = *from;\r\nif ((maptype == SFM_MAP_UNI_RSVD) && convert_sfm_char(src_char, target))\r\nreturn len;\r\nelse if ((maptype == SFU_MAP_UNI_RSVD) &&\r\nconvert_sfu_char(src_char, target))\r\nreturn len;\r\nlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\r\nif (len <= 0)\r\ngoto surrogate_pair;\r\nreturn len;\r\nsurrogate_pair:\r\nif (strcmp(cp->charset, "utf8"))\r\ngoto unknown;\r\nlen = utf16s_to_utf8s(from, 3, UTF16_LITTLE_ENDIAN, target, 6);\r\nif (len <= 0)\r\ngoto unknown;\r\nreturn len;\r\nunknown:\r\n*target = '?';\r\nlen = 1;\r\nreturn len;\r\n}\r\nint\r\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\r\nconst struct nls_table *codepage, int map_type)\r\n{\r\nint i, charlen, safelen;\r\nint outlen = 0;\r\nint nullsize = nls_nullsize(codepage);\r\nint fromwords = fromlen / 2;\r\nchar tmp[NLS_MAX_CHARSET_SIZE];\r\n__u16 ftmp[3];\r\nsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\r\nfor (i = 0; i < fromwords; i++) {\r\nftmp[0] = get_unaligned_le16(&from[i]);\r\nif (ftmp[0] == 0)\r\nbreak;\r\nif (i + 1 < fromwords)\r\nftmp[1] = get_unaligned_le16(&from[i + 1]);\r\nelse\r\nftmp[1] = 0;\r\nif (i + 2 < fromwords)\r\nftmp[2] = get_unaligned_le16(&from[i + 2]);\r\nelse\r\nftmp[2] = 0;\r\nif (outlen >= safelen) {\r\ncharlen = cifs_mapchar(tmp, ftmp, codepage, map_type);\r\nif ((outlen + charlen) > (tolen - nullsize))\r\nbreak;\r\n}\r\ncharlen = cifs_mapchar(&to[outlen], ftmp, codepage, map_type);\r\noutlen += charlen;\r\nif (charlen == 4)\r\ni++;\r\nelse if (charlen >= 5)\r\ni += 2;\r\n}\r\nfor (i = 0; i < nullsize; i++)\r\nto[outlen++] = 0;\r\nreturn outlen;\r\n}\r\nint\r\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\r\nconst struct nls_table *codepage)\r\n{\r\nint charlen;\r\nint i;\r\nwchar_t wchar_to;\r\nif (!strcmp(codepage->charset, "utf8")) {\r\ni = utf8s_to_utf16s(from, len, UTF16_LITTLE_ENDIAN,\r\n(wchar_t *) to, len);\r\nif (i >= 0)\r\ngoto success;\r\n}\r\nfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\r\ncharlen = codepage->char2uni(from, len, &wchar_to);\r\nif (charlen < 1) {\r\ncifs_dbg(VFS, "strtoUTF16: char2uni of 0x%x returned %d\n",\r\n*from, charlen);\r\nwchar_to = 0x003f;\r\ncharlen = 1;\r\n}\r\nput_unaligned_le16(wchar_to, &to[i]);\r\n}\r\nsuccess:\r\nput_unaligned_le16(0, &to[i]);\r\nreturn i;\r\n}\r\nint\r\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\r\nconst struct nls_table *codepage)\r\n{\r\nint i;\r\nint charlen, outlen = 0;\r\nint maxwords = maxbytes / 2;\r\nchar tmp[NLS_MAX_CHARSET_SIZE];\r\n__u16 ftmp[3];\r\nfor (i = 0; i < maxwords; i++) {\r\nftmp[0] = get_unaligned_le16(&from[i]);\r\nif (ftmp[0] == 0)\r\nbreak;\r\nif (i + 1 < maxwords)\r\nftmp[1] = get_unaligned_le16(&from[i + 1]);\r\nelse\r\nftmp[1] = 0;\r\nif (i + 2 < maxwords)\r\nftmp[2] = get_unaligned_le16(&from[i + 2]);\r\nelse\r\nftmp[2] = 0;\r\ncharlen = cifs_mapchar(tmp, ftmp, codepage, NO_MAP_UNI_RSVD);\r\noutlen += charlen;\r\n}\r\nreturn outlen;\r\n}\r\nchar *\r\ncifs_strndup_from_utf16(const char *src, const int maxlen,\r\nconst bool is_unicode, const struct nls_table *codepage)\r\n{\r\nint len;\r\nchar *dst;\r\nif (is_unicode) {\r\nlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\r\nlen += nls_nullsize(codepage);\r\ndst = kmalloc(len, GFP_KERNEL);\r\nif (!dst)\r\nreturn NULL;\r\ncifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\r\nNO_MAP_UNI_RSVD);\r\n} else {\r\nlen = strnlen(src, maxlen);\r\nlen++;\r\ndst = kmalloc(len, GFP_KERNEL);\r\nif (!dst)\r\nreturn NULL;\r\nstrlcpy(dst, src, len);\r\n}\r\nreturn dst;\r\n}\r\nstatic __le16 convert_to_sfu_char(char src_char)\r\n{\r\n__le16 dest_char;\r\nswitch (src_char) {\r\ncase ':':\r\ndest_char = cpu_to_le16(UNI_COLON);\r\nbreak;\r\ncase '*':\r\ndest_char = cpu_to_le16(UNI_ASTERISK);\r\nbreak;\r\ncase '?':\r\ndest_char = cpu_to_le16(UNI_QUESTION);\r\nbreak;\r\ncase '<':\r\ndest_char = cpu_to_le16(UNI_LESSTHAN);\r\nbreak;\r\ncase '>':\r\ndest_char = cpu_to_le16(UNI_GRTRTHAN);\r\nbreak;\r\ncase '|':\r\ndest_char = cpu_to_le16(UNI_PIPE);\r\nbreak;\r\ndefault:\r\ndest_char = 0;\r\n}\r\nreturn dest_char;\r\n}\r\nstatic __le16 convert_to_sfm_char(char src_char, bool end_of_string)\r\n{\r\n__le16 dest_char;\r\nswitch (src_char) {\r\ncase ':':\r\ndest_char = cpu_to_le16(SFM_COLON);\r\nbreak;\r\ncase '*':\r\ndest_char = cpu_to_le16(SFM_ASTERISK);\r\nbreak;\r\ncase '?':\r\ndest_char = cpu_to_le16(SFM_QUESTION);\r\nbreak;\r\ncase '<':\r\ndest_char = cpu_to_le16(SFM_LESSTHAN);\r\nbreak;\r\ncase '>':\r\ndest_char = cpu_to_le16(SFM_GRTRTHAN);\r\nbreak;\r\ncase '|':\r\ndest_char = cpu_to_le16(SFM_PIPE);\r\nbreak;\r\ncase '.':\r\nif (end_of_string)\r\ndest_char = cpu_to_le16(SFM_PERIOD);\r\nelse\r\ndest_char = 0;\r\nbreak;\r\ncase ' ':\r\nif (end_of_string)\r\ndest_char = cpu_to_le16(SFM_SPACE);\r\nelse\r\ndest_char = 0;\r\nbreak;\r\ndefault:\r\ndest_char = 0;\r\n}\r\nreturn dest_char;\r\n}\r\nint\r\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\r\nconst struct nls_table *cp, int map_chars)\r\n{\r\nint i, charlen;\r\nint j = 0;\r\nchar src_char;\r\n__le16 dst_char;\r\nwchar_t tmp;\r\nwchar_t *wchar_to;\r\nint ret;\r\nunicode_t u;\r\nif (map_chars == NO_MAP_UNI_RSVD)\r\nreturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\r\nwchar_to = kzalloc(6, GFP_KERNEL);\r\nfor (i = 0; i < srclen; j++) {\r\nsrc_char = source[i];\r\ncharlen = 1;\r\nif (src_char == 0)\r\ngoto ctoUTF16_out;\r\nif (map_chars == SFU_MAP_UNI_RSVD)\r\ndst_char = convert_to_sfu_char(src_char);\r\nelse if (map_chars == SFM_MAP_UNI_RSVD) {\r\nbool end_of_string;\r\nif (i == srclen - 1)\r\nend_of_string = true;\r\nelse\r\nend_of_string = false;\r\ndst_char = convert_to_sfm_char(src_char, end_of_string);\r\n} else\r\ndst_char = 0;\r\nif (dst_char == 0) {\r\ncharlen = cp->char2uni(source + i, srclen - i, &tmp);\r\ndst_char = cpu_to_le16(tmp);\r\nif (charlen > 0)\r\ngoto ctoUTF16;\r\nif (strcmp(cp->charset, "utf8") || !wchar_to)\r\ngoto unknown;\r\nif (*(source + i) & 0x80) {\r\ncharlen = utf8_to_utf32(source + i, 6, &u);\r\nif (charlen < 0)\r\ngoto unknown;\r\n} else\r\ngoto unknown;\r\nret = utf8s_to_utf16s(source + i, charlen,\r\nUTF16_LITTLE_ENDIAN,\r\nwchar_to, 6);\r\nif (ret < 0)\r\ngoto unknown;\r\ni += charlen;\r\ndst_char = cpu_to_le16(*wchar_to);\r\nif (charlen <= 3)\r\nput_unaligned(dst_char, &target[j]);\r\nelse if (charlen == 4) {\r\nput_unaligned(dst_char, &target[j]);\r\ndst_char = cpu_to_le16(*(wchar_to + 1));\r\nj++;\r\nput_unaligned(dst_char, &target[j]);\r\n} else if (charlen >= 5) {\r\nput_unaligned(dst_char, &target[j]);\r\ndst_char = cpu_to_le16(*(wchar_to + 1));\r\nj++;\r\nput_unaligned(dst_char, &target[j]);\r\ndst_char = cpu_to_le16(*(wchar_to + 2));\r\nj++;\r\nput_unaligned(dst_char, &target[j]);\r\n}\r\ncontinue;\r\nunknown:\r\ndst_char = cpu_to_le16(0x003f);\r\ncharlen = 1;\r\n}\r\nctoUTF16:\r\ni += charlen;\r\nput_unaligned(dst_char, &target[j]);\r\n}\r\nctoUTF16_out:\r\nput_unaligned(0, &target[j]);\r\nkfree(wchar_to);\r\nreturn j;\r\n}\r\nstatic int\r\ncifs_local_to_utf16_bytes(const char *from, int len,\r\nconst struct nls_table *codepage)\r\n{\r\nint charlen;\r\nint i;\r\nwchar_t wchar_to;\r\nfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\r\ncharlen = codepage->char2uni(from, len, &wchar_to);\r\nif (charlen < 1)\r\ncharlen = 1;\r\n}\r\nreturn 2 * i;\r\n}\r\n__le16 *\r\ncifs_strndup_to_utf16(const char *src, const int maxlen, int *utf16_len,\r\nconst struct nls_table *cp, int remap)\r\n{\r\nint len;\r\n__le16 *dst;\r\nlen = cifs_local_to_utf16_bytes(src, maxlen, cp);\r\nlen += 2;\r\ndst = kmalloc(len, GFP_KERNEL);\r\nif (!dst) {\r\n*utf16_len = 0;\r\nreturn NULL;\r\n}\r\ncifsConvertToUTF16(dst, src, strlen(src), cp, remap);\r\n*utf16_len = len;\r\nreturn dst;\r\n}
