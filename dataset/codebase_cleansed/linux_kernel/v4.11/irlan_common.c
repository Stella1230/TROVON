static int __init irlan_init(void)\r\n{\r\nstruct irlan_cb *new;\r\n__u16 hints;\r\n#ifdef CONFIG_PROC_FS\r\n{ struct proc_dir_entry *proc;\r\nproc = proc_create("irlan", 0, proc_irda, &irlan_fops);\r\nif (!proc) {\r\nprintk(KERN_ERR "irlan_init: can't create /proc entry!\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\n#endif\r\nhints = irlmp_service_to_hint(S_LAN);\r\nckey = irlmp_register_client(hints, &irlan_client_discovery_indication,\r\nNULL, NULL);\r\nif (!ckey)\r\ngoto err_ckey;\r\nskey = irlmp_register_service(hints);\r\nif (!skey)\r\ngoto err_skey;\r\nnew = irlan_open(DEV_ADDR_ANY, DEV_ADDR_ANY);\r\nif (!new)\r\ngoto err_open;\r\nirlan_provider_open_ctrl_tsap(new);\r\nirlmp_discovery_request(DISCOVERY_DEFAULT_SLOTS);\r\nreturn 0;\r\nerr_open:\r\nirlmp_unregister_service(skey);\r\nerr_skey:\r\nirlmp_unregister_client(ckey);\r\nerr_ckey:\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("irlan", proc_irda);\r\n#endif\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit irlan_cleanup(void)\r\n{\r\nstruct irlan_cb *self, *next;\r\nirlmp_unregister_client(ckey);\r\nirlmp_unregister_service(skey);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("irlan", proc_irda);\r\n#endif\r\nrtnl_lock();\r\nlist_for_each_entry_safe(self, next, &irlans, dev_list) {\r\n__irlan_close(self);\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic struct irlan_cb __init *irlan_open(__u32 saddr, __u32 daddr)\r\n{\r\nstruct net_device *dev;\r\nstruct irlan_cb *self;\r\ndev = alloc_irlandev(eth ? "eth%d" : "irlan%d");\r\nif (!dev)\r\nreturn NULL;\r\nself = netdev_priv(dev);\r\nself->dev = dev;\r\nself->magic = IRLAN_MAGIC;\r\nself->saddr = saddr;\r\nself->daddr = daddr;\r\nself->provider.access_type = access;\r\nif (access == ACCESS_DIRECT) {\r\ndev->dev_addr[0] = 0x40;\r\ndev->dev_addr[1] = 0x00;\r\ndev->dev_addr[2] = 0x00;\r\ndev->dev_addr[3] = 0x00;\r\nget_random_bytes(dev->dev_addr+4, 1);\r\nget_random_bytes(dev->dev_addr+5, 1);\r\n}\r\nself->media = MEDIA_802_3;\r\nself->disconnect_reason = LM_USER_REQUEST;\r\ninit_timer(&self->watchdog_timer);\r\ninit_timer(&self->client.kick_timer);\r\ninit_waitqueue_head(&self->open_wait);\r\nskb_queue_head_init(&self->client.txq);\r\nirlan_next_client_state(self, IRLAN_IDLE);\r\nirlan_next_provider_state(self, IRLAN_IDLE);\r\nif (register_netdev(dev)) {\r\npr_debug("%s(), register_netdev() failed!\n",\r\n__func__);\r\nself = NULL;\r\nfree_netdev(dev);\r\n} else {\r\nrtnl_lock();\r\nlist_add_rcu(&self->dev_list, &irlans);\r\nrtnl_unlock();\r\n}\r\nreturn self;\r\n}\r\nstatic void __irlan_close(struct irlan_cb *self)\r\n{\r\nASSERT_RTNL();\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\ndel_timer_sync(&self->watchdog_timer);\r\ndel_timer_sync(&self->client.kick_timer);\r\nirlan_close_tsaps(self);\r\nif (self->client.iriap)\r\niriap_close(self->client.iriap);\r\nskb_queue_purge(&self->client.txq);\r\nunregister_netdevice(self->dev);\r\n}\r\nstruct irlan_cb *irlan_get_any(void)\r\n{\r\nstruct irlan_cb *self;\r\nlist_for_each_entry_rcu(self, &irlans, dev_list) {\r\nreturn self;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void irlan_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self;\r\nstruct tsap_cb *tsap;\r\nself = instance;\r\ntsap = sap;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nIRDA_ASSERT(tsap == self->tsap_data,return;);\r\nself->max_sdu_size = max_sdu_size;\r\nself->max_header_size = max_header_size;\r\npr_debug("%s: We are now connected!\n", __func__);\r\ndel_timer(&self->watchdog_timer);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nirlan_do_provider_event(self, IRLAN_DATA_CONNECT_INDICATION, NULL);\r\nirlan_do_client_event(self, IRLAN_DATA_CONNECT_INDICATION, NULL);\r\nif (self->provider.access_type == ACCESS_PEER) {\r\nirlan_get_unicast_addr(self);\r\nirlan_open_unicast_addr(self);\r\n}\r\nnetif_start_queue(self->dev);\r\n}\r\nstatic void irlan_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct irlan_cb *self;\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nself->max_sdu_size = max_sdu_size;\r\nself->max_header_size = max_header_size;\r\npr_debug("%s: We are now connected!\n", __func__);\r\ndel_timer(&self->watchdog_timer);\r\nirlan_get_unicast_addr(self);\r\nirlan_open_unicast_addr(self);\r\nirlan_set_broadcast_filter(self, TRUE);\r\nirlan_set_multicast_filter(self, TRUE);\r\nnetif_start_queue(self->dev);\r\nself->disconnect_reason = 0;\r\nwake_up_interruptible(&self->open_wait);\r\n}\r\nstatic void irlan_disconnect_indication(void *instance,\r\nvoid *sap, LM_REASON reason,\r\nstruct sk_buff *userdata)\r\n{\r\nstruct irlan_cb *self;\r\nstruct tsap_cb *tsap;\r\npr_debug("%s(), reason=%d\n", __func__ , reason);\r\nself = instance;\r\ntsap = sap;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nIRDA_ASSERT(tsap != NULL, return;);\r\nIRDA_ASSERT(tsap->magic == TTP_TSAP_MAGIC, return;);\r\nIRDA_ASSERT(tsap == self->tsap_data, return;);\r\npr_debug("IrLAN, data channel disconnected by peer!\n");\r\nself->disconnect_reason = reason;\r\nswitch (reason) {\r\ncase LM_USER_REQUEST:\r\npr_debug("%s(), User requested\n", __func__);\r\nbreak;\r\ncase LM_LAP_DISCONNECT:\r\npr_debug("%s(), Unexpected IrLAP disconnect\n", __func__);\r\nbreak;\r\ncase LM_CONNECT_FAILURE:\r\npr_debug("%s(), IrLAP connect failed\n", __func__);\r\nbreak;\r\ncase LM_LAP_RESET:\r\npr_debug("%s(), IrLAP reset\n", __func__);\r\nbreak;\r\ncase LM_INIT_DISCONNECT:\r\npr_debug("%s(), IrLMP connect failed\n", __func__);\r\nbreak;\r\ndefault:\r\nnet_err_ratelimited("%s(), Unknown disconnect reason\n",\r\n__func__);\r\nbreak;\r\n}\r\nif (userdata)\r\ndev_kfree_skb(userdata);\r\nirlan_do_client_event(self, IRLAN_LMP_DISCONNECT, NULL);\r\nirlan_do_provider_event(self, IRLAN_LMP_DISCONNECT, NULL);\r\nwake_up_interruptible(&self->open_wait);\r\n}\r\nvoid irlan_open_data_tsap(struct irlan_cb *self)\r\n{\r\nstruct tsap_cb *tsap;\r\nnotify_t notify;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (self->tsap_data)\r\nreturn;\r\nirda_notify_init(&notify);\r\nnotify.data_indication = irlan_eth_receive;\r\nnotify.udata_indication = irlan_eth_receive;\r\nnotify.connect_indication = irlan_connect_indication;\r\nnotify.connect_confirm = irlan_connect_confirm;\r\nnotify.flow_indication = irlan_eth_flow_indication;\r\nnotify.disconnect_indication = irlan_disconnect_indication;\r\nnotify.instance = self;\r\nstrlcpy(notify.name, "IrLAN data", sizeof(notify.name));\r\ntsap = irttp_open_tsap(LSAP_ANY, DEFAULT_INITIAL_CREDIT, &notify);\r\nif (!tsap) {\r\npr_debug("%s(), Got no tsap!\n", __func__);\r\nreturn;\r\n}\r\nself->tsap_data = tsap;\r\nself->stsap_sel_data = self->tsap_data->stsap_sel;\r\n}\r\nvoid irlan_close_tsaps(struct irlan_cb *self)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (self->tsap_data) {\r\nirttp_disconnect_request(self->tsap_data, NULL, P_NORMAL);\r\nirttp_close_tsap(self->tsap_data);\r\nself->tsap_data = NULL;\r\n}\r\nif (self->client.tsap_ctrl) {\r\nirttp_disconnect_request(self->client.tsap_ctrl, NULL,\r\nP_NORMAL);\r\nirttp_close_tsap(self->client.tsap_ctrl);\r\nself->client.tsap_ctrl = NULL;\r\n}\r\nif (self->provider.tsap_ctrl) {\r\nirttp_disconnect_request(self->provider.tsap_ctrl, NULL,\r\nP_NORMAL);\r\nirttp_close_tsap(self->provider.tsap_ctrl);\r\nself->provider.tsap_ctrl = NULL;\r\n}\r\nself->disconnect_reason = LM_USER_REQUEST;\r\n}\r\nvoid irlan_ias_register(struct irlan_cb *self, __u8 tsap_sel)\r\n{\r\nstruct ias_object *obj;\r\nstruct ias_value *new_value;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (!irias_find_object("IrLAN")) {\r\nobj = irias_new_object("IrLAN", IAS_IRLAN_ID);\r\nirias_add_integer_attrib(obj, "IrDA:TinyTP:LsapSel", tsap_sel,\r\nIAS_KERNEL_ATTR);\r\nirias_insert_object(obj);\r\n} else {\r\nnew_value = irias_new_integer_value(tsap_sel);\r\nirias_object_change_attribute("IrLAN", "IrDA:TinyTP:LsapSel",\r\nnew_value);\r\n}\r\nif (!irias_find_object("PnP")) {\r\nobj = irias_new_object("PnP", IAS_PNP_ID);\r\n#if 0\r\nirias_add_string_attrib(obj, "Name", sysctl_devname,\r\nIAS_KERNEL_ATTR);\r\n#else\r\nirias_add_string_attrib(obj, "Name", "Linux", IAS_KERNEL_ATTR);\r\n#endif\r\nirias_add_string_attrib(obj, "DeviceID", "HWP19F0",\r\nIAS_KERNEL_ATTR);\r\nirias_add_integer_attrib(obj, "CompCnt", 1, IAS_KERNEL_ATTR);\r\nif (self->provider.access_type == ACCESS_PEER)\r\nirias_add_string_attrib(obj, "Comp#01", "PNP8389",\r\nIAS_KERNEL_ATTR);\r\nelse\r\nirias_add_string_attrib(obj, "Comp#01", "PNP8294",\r\nIAS_KERNEL_ATTR);\r\nirias_add_string_attrib(obj, "Manufacturer",\r\n"Linux-IrDA Project", IAS_KERNEL_ATTR);\r\nirias_insert_object(obj);\r\n}\r\n}\r\nint irlan_run_ctrl_tx_queue(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\nif (irda_lock(&self->client.tx_busy) == FALSE)\r\nreturn -EBUSY;\r\nskb = skb_dequeue(&self->client.txq);\r\nif (!skb) {\r\nself->client.tx_busy = FALSE;\r\nreturn 0;\r\n}\r\nif ((self->client.tsap_ctrl == NULL) ||\r\n(self->client.state == IRLAN_IDLE))\r\n{\r\nself->client.tx_busy = FALSE;\r\ndev_kfree_skb(skb);\r\nreturn -1;\r\n}\r\npr_debug("%s(), sending ...\n", __func__);\r\nreturn irttp_data_request(self->client.tsap_ctrl, skb);\r\n}\r\nstatic void irlan_ctrl_data_request(struct irlan_cb *self, struct sk_buff *skb)\r\n{\r\nskb_queue_tail(&self->client.txq, skb);\r\nirlan_run_ctrl_tx_queue(self);\r\n}\r\nvoid irlan_get_provider_info(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER,\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_GET_PROVIDER_INFO;\r\nframe[1] = 0x00;\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nvoid irlan_open_data_channel(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_STRING_PARAMETER_LEN("MEDIA", "802.3") +\r\nIRLAN_STRING_PARAMETER_LEN("ACCESS_TYPE", "DIRECT"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_OPEN_DATA_CHANNEL;\r\nframe[1] = 0x02;\r\nirlan_insert_string_param(skb, "MEDIA", "802.3");\r\nirlan_insert_string_param(skb, "ACCESS_TYPE", "DIRECT");\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nvoid irlan_close_data_channel(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nif (self->client.tsap_ctrl == NULL)\r\nreturn;\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_BYTE_PARAMETER_LEN("DATA_CHAN"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_CLOSE_DATA_CHAN;\r\nframe[1] = 0x01;\r\nirlan_insert_byte_param(skb, "DATA_CHAN", self->dtsap_sel_data);\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nstatic void irlan_open_unicast_addr(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_BYTE_PARAMETER_LEN("DATA_CHAN") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "DIRECTED") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_MODE", "FILTER"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_FILTER_OPERATION;\r\nframe[1] = 0x03;\r\nirlan_insert_byte_param(skb, "DATA_CHAN" , self->dtsap_sel_data);\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "DIRECTED");\r\nirlan_insert_string_param(skb, "FILTER_MODE", "FILTER");\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nvoid irlan_set_broadcast_filter(struct irlan_cb *self, int status)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_BYTE_PARAMETER_LEN("DATA_CHAN") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "BROADCAST") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_MODE", "FILTER"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_FILTER_OPERATION;\r\nframe[1] = 0x03;\r\nirlan_insert_byte_param(skb, "DATA_CHAN", self->dtsap_sel_data);\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "BROADCAST");\r\nif (status)\r\nirlan_insert_string_param(skb, "FILTER_MODE", "FILTER");\r\nelse\r\nirlan_insert_string_param(skb, "FILTER_MODE", "NONE");\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nvoid irlan_set_multicast_filter(struct irlan_cb *self, int status)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_BYTE_PARAMETER_LEN("DATA_CHAN") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "MULTICAST") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_MODE", "NONE"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_FILTER_OPERATION;\r\nframe[1] = 0x03;\r\nirlan_insert_byte_param(skb, "DATA_CHAN", self->dtsap_sel_data);\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "MULTICAST");\r\nif (status)\r\nirlan_insert_string_param(skb, "FILTER_MODE", "ALL");\r\nelse\r\nirlan_insert_string_param(skb, "FILTER_MODE", "NONE");\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nstatic void irlan_get_unicast_addr(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_BYTE_PARAMETER_LEN("DATA_CHAN") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_TYPE", "DIRECTED") +\r\nIRLAN_STRING_PARAMETER_LEN("FILTER_OPERATION",\r\n"DYNAMIC"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_FILTER_OPERATION;\r\nframe[1] = 0x03;\r\nirlan_insert_byte_param(skb, "DATA_CHAN", self->dtsap_sel_data);\r\nirlan_insert_string_param(skb, "FILTER_TYPE", "DIRECTED");\r\nirlan_insert_string_param(skb, "FILTER_OPERATION", "DYNAMIC");\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nvoid irlan_get_media_char(struct irlan_cb *self)\r\n{\r\nstruct sk_buff *skb;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return;);\r\nskb = alloc_skb(IRLAN_MAX_HEADER + IRLAN_CMD_HEADER +\r\nIRLAN_STRING_PARAMETER_LEN("MEDIA", "802.3"),\r\nGFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, self->client.max_header_size);\r\nskb_put(skb, 2);\r\nframe = skb->data;\r\nframe[0] = CMD_GET_MEDIA_CHAR;\r\nframe[1] = 0x01;\r\nirlan_insert_string_param(skb, "MEDIA", "802.3");\r\nirlan_ctrl_data_request(self, skb);\r\n}\r\nint irlan_insert_byte_param(struct sk_buff *skb, char *param, __u8 value)\r\n{\r\nreturn __irlan_insert_param(skb, param, IRLAN_BYTE, value, 0, NULL, 0);\r\n}\r\nint irlan_insert_short_param(struct sk_buff *skb, char *param, __u16 value)\r\n{\r\nreturn __irlan_insert_param(skb, param, IRLAN_SHORT, 0, value, NULL, 0);\r\n}\r\nint irlan_insert_string_param(struct sk_buff *skb, char *param, char *string)\r\n{\r\nint string_len = strlen(string);\r\nreturn __irlan_insert_param(skb, param, IRLAN_ARRAY, 0, 0, string,\r\nstring_len);\r\n}\r\nint irlan_insert_array_param(struct sk_buff *skb, char *name, __u8 *array,\r\n__u16 array_len)\r\n{\r\nreturn __irlan_insert_param(skb, name, IRLAN_ARRAY, 0, 0, array,\r\narray_len);\r\n}\r\nstatic int __irlan_insert_param(struct sk_buff *skb, char *param, int type,\r\n__u8 value_byte, __u16 value_short,\r\n__u8 *value_array, __u16 value_len)\r\n{\r\n__u8 *frame;\r\n__u8 param_len;\r\n__le16 tmp_le;\r\nint n=0;\r\nif (skb == NULL) {\r\npr_debug("%s(), Got NULL skb\n", __func__);\r\nreturn 0;\r\n}\r\nparam_len = strlen(param);\r\nswitch (type) {\r\ncase IRLAN_BYTE:\r\nvalue_len = 1;\r\nbreak;\r\ncase IRLAN_SHORT:\r\nvalue_len = 2;\r\nbreak;\r\ncase IRLAN_ARRAY:\r\nIRDA_ASSERT(value_array != NULL, return 0;);\r\nIRDA_ASSERT(value_len > 0, return 0;);\r\nbreak;\r\ndefault:\r\npr_debug("%s(), Unknown parameter type!\n", __func__);\r\nreturn 0;\r\n}\r\nframe = skb_tail_pointer(skb);\r\nif (skb_tailroom(skb) < (param_len+value_len+3)) {\r\npr_debug("%s(), No more space at end of skb\n", __func__);\r\nreturn 0;\r\n}\r\nskb_put(skb, param_len+value_len+3);\r\nframe[n++] = param_len;\r\nmemcpy(frame+n, param, param_len); n += param_len;\r\ntmp_le = cpu_to_le16(value_len);\r\nmemcpy(frame+n, &tmp_le, 2); n += 2;\r\nswitch (type) {\r\ncase IRLAN_BYTE:\r\nframe[n++] = value_byte;\r\nbreak;\r\ncase IRLAN_SHORT:\r\ntmp_le = cpu_to_le16(value_short);\r\nmemcpy(frame+n, &tmp_le, 2); n += 2;\r\nbreak;\r\ncase IRLAN_ARRAY:\r\nmemcpy(frame+n, value_array, value_len); n+=value_len;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nIRDA_ASSERT(n == (param_len+value_len+3), return 0;);\r\nreturn param_len+value_len+3;\r\n}\r\nint irlan_extract_param(__u8 *buf, char *name, char *value, __u16 *len)\r\n{\r\n__u8 name_len;\r\n__u16 val_len;\r\nint n=0;\r\nname_len = buf[n++];\r\nif (name_len > 254) {\r\npr_debug("%s(), name_len > 254\n", __func__);\r\nreturn -RSP_INVALID_COMMAND_FORMAT;\r\n}\r\nmemcpy(name, buf+n, name_len);\r\nname[name_len] = '\0';\r\nn+=name_len;\r\nmemcpy(&val_len, buf+n, 2);\r\nle16_to_cpus(&val_len); n+=2;\r\nif (val_len >= 1016) {\r\npr_debug("%s(), parameter length to long\n", __func__);\r\nreturn -RSP_INVALID_COMMAND_FORMAT;\r\n}\r\n*len = val_len;\r\nmemcpy(value, buf+n, val_len);\r\nvalue[val_len] = '\0';\r\nn+=val_len;\r\npr_debug("Parameter: %s ", name);\r\npr_debug("Value: %s\n", value);\r\nreturn n;\r\n}\r\nstatic void *irlan_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nrcu_read_lock();\r\nreturn seq_list_start_head(&irlans, *pos);\r\n}\r\nstatic void *irlan_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &irlans, pos);\r\n}\r\nstatic void irlan_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int irlan_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == &irlans)\r\nseq_puts(seq, "IrLAN instances:\n");\r\nelse {\r\nstruct irlan_cb *self = list_entry(v, struct irlan_cb, dev_list);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRLAN_MAGIC, return -1;);\r\nseq_printf(seq,"ifname: %s,\n",\r\nself->dev->name);\r\nseq_printf(seq,"client state: %s, ",\r\nirlan_state[ self->client.state]);\r\nseq_printf(seq,"provider state: %s,\n",\r\nirlan_state[ self->provider.state]);\r\nseq_printf(seq,"saddr: %#08x, ",\r\nself->saddr);\r\nseq_printf(seq,"daddr: %#08x\n",\r\nself->daddr);\r\nseq_printf(seq,"version: %d.%d,\n",\r\nself->version[1], self->version[0]);\r\nseq_printf(seq,"access type: %s\n",\r\nirlan_access[self->client.access_type]);\r\nseq_printf(seq,"media: %s\n",\r\nirlan_media[self->media]);\r\nseq_printf(seq,"local filter:\n");\r\nseq_printf(seq,"remote filter: ");\r\nirlan_print_filter(seq, self->client.filter_type);\r\nseq_printf(seq,"tx busy: %s\n",\r\nnetif_queue_stopped(self->dev) ? "TRUE" : "FALSE");\r\nseq_putc(seq,'\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int irlan_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &irlan_seq_ops);\r\n}
