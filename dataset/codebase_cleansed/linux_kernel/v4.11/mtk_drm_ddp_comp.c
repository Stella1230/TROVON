void mtk_dither_set(struct mtk_ddp_comp *comp, unsigned int bpc,\r\nunsigned int CFG)\r\n{\r\nif (bpc == 0)\r\nreturn;\r\nif (bpc >= MTK_MIN_BPC) {\r\nwritel(0, comp->regs + DISP_DITHER_5);\r\nwritel(0, comp->regs + DISP_DITHER_7);\r\nwritel(DITHER_LSB_ERR_SHIFT_R(MTK_MAX_BPC - bpc) |\r\nDITHER_ADD_LSHIFT_R(MTK_MAX_BPC - bpc) |\r\nDITHER_NEW_BIT_MODE,\r\ncomp->regs + DISP_DITHER_15);\r\nwritel(DITHER_LSB_ERR_SHIFT_B(MTK_MAX_BPC - bpc) |\r\nDITHER_ADD_LSHIFT_B(MTK_MAX_BPC - bpc) |\r\nDITHER_LSB_ERR_SHIFT_G(MTK_MAX_BPC - bpc) |\r\nDITHER_ADD_LSHIFT_G(MTK_MAX_BPC - bpc),\r\ncomp->regs + DISP_DITHER_16);\r\nwritel(DISP_DITHERING, comp->regs + CFG);\r\n}\r\n}\r\nstatic void mtk_color_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh,\r\nunsigned int bpc)\r\n{\r\nwritel(w, comp->regs + DISP_COLOR_WIDTH);\r\nwritel(h, comp->regs + DISP_COLOR_HEIGHT);\r\n}\r\nstatic void mtk_color_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(COLOR_BYPASS_ALL | COLOR_SEQ_SEL,\r\ncomp->regs + DISP_COLOR_CFG_MAIN);\r\nwritel(0x1, comp->regs + DISP_COLOR_START);\r\n}\r\nstatic void mtk_od_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh,\r\nunsigned int bpc)\r\n{\r\nwritel(w << 16 | h, comp->regs + DISP_OD_SIZE);\r\nwritel(OD_RELAYMODE, comp->regs + DISP_OD_CFG);\r\nmtk_dither_set(comp, bpc, DISP_OD_CFG);\r\n}\r\nstatic void mtk_od_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(1, comp->regs + DISP_OD_EN);\r\n}\r\nstatic void mtk_ufoe_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(UFO_BYPASS, comp->regs + DISP_REG_UFO_START);\r\n}\r\nstatic void mtk_aal_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh,\r\nunsigned int bpc)\r\n{\r\nwritel(h << 16 | w, comp->regs + DISP_AAL_SIZE);\r\n}\r\nstatic void mtk_aal_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(AAL_EN, comp->regs + DISP_AAL_EN);\r\n}\r\nstatic void mtk_aal_stop(struct mtk_ddp_comp *comp)\r\n{\r\nwritel_relaxed(0x0, comp->regs + DISP_AAL_EN);\r\n}\r\nstatic void mtk_gamma_config(struct mtk_ddp_comp *comp, unsigned int w,\r\nunsigned int h, unsigned int vrefresh,\r\nunsigned int bpc)\r\n{\r\nwritel(h << 16 | w, comp->regs + DISP_GAMMA_SIZE);\r\nmtk_dither_set(comp, bpc, DISP_GAMMA_CFG);\r\n}\r\nstatic void mtk_gamma_start(struct mtk_ddp_comp *comp)\r\n{\r\nwritel(GAMMA_EN, comp->regs + DISP_GAMMA_EN);\r\n}\r\nstatic void mtk_gamma_stop(struct mtk_ddp_comp *comp)\r\n{\r\nwritel_relaxed(0x0, comp->regs + DISP_GAMMA_EN);\r\n}\r\nstatic void mtk_gamma_set(struct mtk_ddp_comp *comp,\r\nstruct drm_crtc_state *state)\r\n{\r\nunsigned int i, reg;\r\nstruct drm_color_lut *lut;\r\nvoid __iomem *lut_base;\r\nu32 word;\r\nif (state->gamma_lut) {\r\nreg = readl(comp->regs + DISP_GAMMA_CFG);\r\nreg = reg | GAMMA_LUT_EN;\r\nwritel(reg, comp->regs + DISP_GAMMA_CFG);\r\nlut_base = comp->regs + DISP_GAMMA_LUT;\r\nlut = (struct drm_color_lut *)state->gamma_lut->data;\r\nfor (i = 0; i < MTK_LUT_SIZE; i++) {\r\nword = (((lut[i].red >> 6) & LUT_10BIT_MASK) << 20) +\r\n(((lut[i].green >> 6) & LUT_10BIT_MASK) << 10) +\r\n((lut[i].blue >> 6) & LUT_10BIT_MASK);\r\nwritel(word, (lut_base + i * 4));\r\n}\r\n}\r\n}\r\nint mtk_ddp_comp_get_id(struct device_node *node,\r\nenum mtk_ddp_comp_type comp_type)\r\n{\r\nint id = of_alias_get_id(node, mtk_ddp_comp_stem[comp_type]);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mtk_ddp_matches); i++) {\r\nif (comp_type == mtk_ddp_matches[i].type &&\r\n(id < 0 || id == mtk_ddp_matches[i].alias_id))\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint mtk_ddp_comp_init(struct device *dev, struct device_node *node,\r\nstruct mtk_ddp_comp *comp, enum mtk_ddp_comp_id comp_id,\r\nconst struct mtk_ddp_comp_funcs *funcs)\r\n{\r\nenum mtk_ddp_comp_type type;\r\nstruct device_node *larb_node;\r\nstruct platform_device *larb_pdev;\r\nif (comp_id < 0 || comp_id >= DDP_COMPONENT_ID_MAX)\r\nreturn -EINVAL;\r\ncomp->id = comp_id;\r\ncomp->funcs = funcs ?: mtk_ddp_matches[comp_id].funcs;\r\nif (comp_id == DDP_COMPONENT_DPI0 ||\r\ncomp_id == DDP_COMPONENT_DSI0 ||\r\ncomp_id == DDP_COMPONENT_PWM0) {\r\ncomp->regs = NULL;\r\ncomp->clk = NULL;\r\ncomp->irq = 0;\r\nreturn 0;\r\n}\r\ncomp->regs = of_iomap(node, 0);\r\ncomp->irq = of_irq_get(node, 0);\r\ncomp->clk = of_clk_get(node, 0);\r\nif (IS_ERR(comp->clk))\r\ncomp->clk = NULL;\r\ntype = mtk_ddp_matches[comp_id].type;\r\ncomp->larb_dev = NULL;\r\nif (type != MTK_DISP_OVL &&\r\ntype != MTK_DISP_RDMA &&\r\ntype != MTK_DISP_WDMA)\r\nreturn 0;\r\nlarb_node = of_parse_phandle(node, "mediatek,larb", 0);\r\nif (!larb_node) {\r\ndev_err(dev,\r\n"Missing mediadek,larb phandle in %s node\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nlarb_pdev = of_find_device_by_node(larb_node);\r\nif (!larb_pdev) {\r\ndev_warn(dev, "Waiting for larb device %s\n",\r\nlarb_node->full_name);\r\nof_node_put(larb_node);\r\nreturn -EPROBE_DEFER;\r\n}\r\nof_node_put(larb_node);\r\ncomp->larb_dev = &larb_pdev->dev;\r\nreturn 0;\r\n}\r\nint mtk_ddp_comp_register(struct drm_device *drm, struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_drm_private *private = drm->dev_private;\r\nif (private->ddp_comp[comp->id])\r\nreturn -EBUSY;\r\nprivate->ddp_comp[comp->id] = comp;\r\nreturn 0;\r\n}\r\nvoid mtk_ddp_comp_unregister(struct drm_device *drm, struct mtk_ddp_comp *comp)\r\n{\r\nstruct mtk_drm_private *private = drm->dev_private;\r\nprivate->ddp_comp[comp->id] = NULL;\r\n}
