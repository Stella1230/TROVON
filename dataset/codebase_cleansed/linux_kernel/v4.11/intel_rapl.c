static struct rapl_package *find_package_by_id(int id)\r\n{\r\nstruct rapl_package *rp;\r\nlist_for_each_entry(rp, &rapl_packages, plist) {\r\nif (rp->id == id)\r\nreturn rp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int get_energy_counter(struct powercap_zone *power_zone, u64 *energy_raw)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 energy_now;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nif (!rapl_read_data_raw(rd, ENERGY_COUNTER, true, &energy_now)) {\r\n*energy_raw = energy_now;\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nput_online_cpus();\r\nreturn -EIO;\r\n}\r\nstatic int get_max_energy_counter(struct powercap_zone *pcd_dev, u64 *energy)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(pcd_dev);\r\n*energy = rapl_unit_xlate(rd, ENERGY_UNIT, ENERGY_STATUS_MASK, 0);\r\nreturn 0;\r\n}\r\nstatic int release_zone(struct powercap_zone *power_zone)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\r\nstruct rapl_package *rp = rd->rp;\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nkfree(rd);\r\nrp->domains = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int find_nr_power_limit(struct rapl_domain *rd)\r\n{\r\nint i, nr_pl = 0;\r\nfor (i = 0; i < NR_POWER_LIMITS; i++) {\r\nif (rd->rpl[i].name)\r\nnr_pl++;\r\n}\r\nreturn nr_pl;\r\n}\r\nstatic int set_domain_enable(struct powercap_zone *power_zone, bool mode)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\r\nif (rd->state & DOMAIN_STATE_BIOS_LOCKED)\r\nreturn -EACCES;\r\nget_online_cpus();\r\nrapl_write_data_raw(rd, PL1_ENABLE, mode);\r\nif (rapl_defaults->set_floor_freq)\r\nrapl_defaults->set_floor_freq(rd, mode);\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic int get_domain_enable(struct powercap_zone *power_zone, bool *mode)\r\n{\r\nstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\r\nu64 val;\r\nif (rd->state & DOMAIN_STATE_BIOS_LOCKED) {\r\n*mode = false;\r\nreturn 0;\r\n}\r\nget_online_cpus();\r\nif (rapl_read_data_raw(rd, PL1_ENABLE, true, &val)) {\r\nput_online_cpus();\r\nreturn -EIO;\r\n}\r\n*mode = val;\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic int contraint_to_pl(struct rapl_domain *rd, int cid)\r\n{\r\nint i, j;\r\nfor (i = 0, j = 0; i < NR_POWER_LIMITS; i++) {\r\nif ((rd->rpl[i].name) && j++ == cid) {\r\npr_debug("%s: index %d\n", __func__, i);\r\nreturn i;\r\n}\r\n}\r\npr_err("Cannot find matching power limit for constraint %d\n", cid);\r\nreturn -EINVAL;\r\n}\r\nstatic int set_power_limit(struct powercap_zone *power_zone, int cid,\r\nu64 power_limit)\r\n{\r\nstruct rapl_domain *rd;\r\nstruct rapl_package *rp;\r\nint ret = 0;\r\nint id;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nid = contraint_to_pl(rd, cid);\r\nif (id < 0) {\r\nret = id;\r\ngoto set_exit;\r\n}\r\nrp = rd->rp;\r\nif (rd->state & DOMAIN_STATE_BIOS_LOCKED) {\r\ndev_warn(&power_zone->dev, "%s locked by BIOS, monitoring only\n",\r\nrd->name);\r\nret = -EACCES;\r\ngoto set_exit;\r\n}\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nrapl_write_data_raw(rd, POWER_LIMIT1, power_limit);\r\nbreak;\r\ncase PL2_ENABLE:\r\nrapl_write_data_raw(rd, POWER_LIMIT2, power_limit);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\npackage_power_limit_irq_save(rp);\r\nset_exit:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int get_current_power_limit(struct powercap_zone *power_zone, int cid,\r\nu64 *data)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 val;\r\nint prim;\r\nint ret = 0;\r\nint id;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nid = contraint_to_pl(rd, cid);\r\nif (id < 0) {\r\nret = id;\r\ngoto get_exit;\r\n}\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nprim = POWER_LIMIT1;\r\nbreak;\r\ncase PL2_ENABLE:\r\nprim = POWER_LIMIT2;\r\nbreak;\r\ndefault:\r\nput_online_cpus();\r\nreturn -EINVAL;\r\n}\r\nif (rapl_read_data_raw(rd, prim, true, &val))\r\nret = -EIO;\r\nelse\r\n*data = val;\r\nget_exit:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int set_time_window(struct powercap_zone *power_zone, int cid,\r\nu64 window)\r\n{\r\nstruct rapl_domain *rd;\r\nint ret = 0;\r\nint id;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nid = contraint_to_pl(rd, cid);\r\nif (id < 0) {\r\nret = id;\r\ngoto set_time_exit;\r\n}\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nrapl_write_data_raw(rd, TIME_WINDOW1, window);\r\nbreak;\r\ncase PL2_ENABLE:\r\nrapl_write_data_raw(rd, TIME_WINDOW2, window);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nset_time_exit:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic int get_time_window(struct powercap_zone *power_zone, int cid, u64 *data)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 val;\r\nint ret = 0;\r\nint id;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nid = contraint_to_pl(rd, cid);\r\nif (id < 0) {\r\nret = id;\r\ngoto get_time_exit;\r\n}\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nret = rapl_read_data_raw(rd, TIME_WINDOW1, true, &val);\r\nbreak;\r\ncase PL2_ENABLE:\r\nret = rapl_read_data_raw(rd, TIME_WINDOW2, true, &val);\r\nbreak;\r\ndefault:\r\nput_online_cpus();\r\nreturn -EINVAL;\r\n}\r\nif (!ret)\r\n*data = val;\r\nget_time_exit:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic const char *get_constraint_name(struct powercap_zone *power_zone, int cid)\r\n{\r\nstruct rapl_domain *rd;\r\nint id;\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nid = contraint_to_pl(rd, cid);\r\nif (id >= 0)\r\nreturn rd->rpl[id].name;\r\nreturn NULL;\r\n}\r\nstatic int get_max_power(struct powercap_zone *power_zone, int id,\r\nu64 *data)\r\n{\r\nstruct rapl_domain *rd;\r\nu64 val;\r\nint prim;\r\nint ret = 0;\r\nget_online_cpus();\r\nrd = power_zone_to_rapl_domain(power_zone);\r\nswitch (rd->rpl[id].prim_id) {\r\ncase PL1_ENABLE:\r\nprim = THERMAL_SPEC_POWER;\r\nbreak;\r\ncase PL2_ENABLE:\r\nprim = MAX_POWER;\r\nbreak;\r\ndefault:\r\nput_online_cpus();\r\nreturn -EINVAL;\r\n}\r\nif (rapl_read_data_raw(rd, prim, true, &val))\r\nret = -EIO;\r\nelse\r\n*data = val;\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic void rapl_init_domains(struct rapl_package *rp)\r\n{\r\nint i;\r\nstruct rapl_domain *rd = rp->domains;\r\nfor (i = 0; i < RAPL_DOMAIN_MAX; i++) {\r\nunsigned int mask = rp->domain_map & (1 << i);\r\nswitch (mask) {\r\ncase BIT(RAPL_DOMAIN_PACKAGE):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PACKAGE];\r\nrd->id = RAPL_DOMAIN_PACKAGE;\r\nrd->msrs[0] = MSR_PKG_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PKG_ENERGY_STATUS;\r\nrd->msrs[2] = MSR_PKG_PERF_STATUS;\r\nrd->msrs[3] = 0;\r\nrd->msrs[4] = MSR_PKG_POWER_INFO;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nrd->rpl[1].prim_id = PL2_ENABLE;\r\nrd->rpl[1].name = pl2_name;\r\nbreak;\r\ncase BIT(RAPL_DOMAIN_PP0):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PP0];\r\nrd->id = RAPL_DOMAIN_PP0;\r\nrd->msrs[0] = MSR_PP0_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PP0_ENERGY_STATUS;\r\nrd->msrs[2] = 0;\r\nrd->msrs[3] = MSR_PP0_POLICY;\r\nrd->msrs[4] = 0;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nbreak;\r\ncase BIT(RAPL_DOMAIN_PP1):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PP1];\r\nrd->id = RAPL_DOMAIN_PP1;\r\nrd->msrs[0] = MSR_PP1_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PP1_ENERGY_STATUS;\r\nrd->msrs[2] = 0;\r\nrd->msrs[3] = MSR_PP1_POLICY;\r\nrd->msrs[4] = 0;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nbreak;\r\ncase BIT(RAPL_DOMAIN_DRAM):\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_DRAM];\r\nrd->id = RAPL_DOMAIN_DRAM;\r\nrd->msrs[0] = MSR_DRAM_POWER_LIMIT;\r\nrd->msrs[1] = MSR_DRAM_ENERGY_STATUS;\r\nrd->msrs[2] = MSR_DRAM_PERF_STATUS;\r\nrd->msrs[3] = 0;\r\nrd->msrs[4] = MSR_DRAM_POWER_INFO;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nrd->domain_energy_unit =\r\nrapl_defaults->dram_domain_energy_unit;\r\nif (rd->domain_energy_unit)\r\npr_info("DRAM domain energy unit %dpj\n",\r\nrd->domain_energy_unit);\r\nbreak;\r\n}\r\nif (mask) {\r\nrd->rp = rp;\r\nrd++;\r\n}\r\n}\r\n}\r\nstatic u64 rapl_unit_xlate(struct rapl_domain *rd, enum unit_type type,\r\nu64 value, int to_raw)\r\n{\r\nu64 units = 1;\r\nstruct rapl_package *rp = rd->rp;\r\nu64 scale = 1;\r\nswitch (type) {\r\ncase POWER_UNIT:\r\nunits = rp->power_unit;\r\nbreak;\r\ncase ENERGY_UNIT:\r\nscale = ENERGY_UNIT_SCALE;\r\nif (rd->domain_energy_unit)\r\nunits = rd->domain_energy_unit;\r\nelse\r\nunits = rp->energy_unit;\r\nbreak;\r\ncase TIME_UNIT:\r\nreturn rapl_defaults->compute_time_window(rp, value, to_raw);\r\ncase ARBITRARY_UNIT:\r\ndefault:\r\nreturn value;\r\n};\r\nif (to_raw)\r\nreturn div64_u64(value, units) * scale;\r\nvalue *= units;\r\nreturn div64_u64(value, scale);\r\n}\r\nstatic int rapl_read_data_raw(struct rapl_domain *rd,\r\nenum rapl_primitives prim,\r\nbool xlate, u64 *data)\r\n{\r\nu64 value, final;\r\nu32 msr;\r\nstruct rapl_primitive_info *rp = &rpi[prim];\r\nint cpu;\r\nif (!rp->name || rp->flag & RAPL_PRIMITIVE_DUMMY)\r\nreturn -EINVAL;\r\nmsr = rd->msrs[rp->id];\r\nif (!msr)\r\nreturn -EINVAL;\r\ncpu = rd->rp->lead_cpu;\r\nif (prim == FW_LOCK && rd->id == RAPL_DOMAIN_PACKAGE) {\r\nrp->mask = POWER_PACKAGE_LOCK;\r\nrp->shift = 63;\r\n}\r\nif (rp->flag & RAPL_PRIMITIVE_DERIVED) {\r\n*data = rd->rdd.primitives[prim];\r\nreturn 0;\r\n}\r\nif (rdmsrl_safe_on_cpu(cpu, msr, &value)) {\r\npr_debug("failed to read msr 0x%x on cpu %d\n", msr, cpu);\r\nreturn -EIO;\r\n}\r\nfinal = value & rp->mask;\r\nfinal = final >> rp->shift;\r\nif (xlate)\r\n*data = rapl_unit_xlate(rd, rp->unit, final, 0);\r\nelse\r\n*data = final;\r\nreturn 0;\r\n}\r\nstatic int msrl_update_safe(u32 msr_no, u64 clear_mask, u64 set_mask)\r\n{\r\nint err;\r\nu64 val;\r\nerr = rdmsrl_safe(msr_no, &val);\r\nif (err)\r\ngoto out;\r\nval &= ~clear_mask;\r\nval |= set_mask;\r\nerr = wrmsrl_safe(msr_no, val);\r\nout:\r\nreturn err;\r\n}\r\nstatic void msrl_update_func(void *info)\r\n{\r\nstruct msrl_action *ma = info;\r\nma->err = msrl_update_safe(ma->msr_no, ma->clear_mask, ma->set_mask);\r\n}\r\nstatic int rapl_write_data_raw(struct rapl_domain *rd,\r\nenum rapl_primitives prim,\r\nunsigned long long value)\r\n{\r\nstruct rapl_primitive_info *rp = &rpi[prim];\r\nint cpu;\r\nu64 bits;\r\nstruct msrl_action ma;\r\nint ret;\r\ncpu = rd->rp->lead_cpu;\r\nbits = rapl_unit_xlate(rd, rp->unit, value, 1);\r\nbits |= bits << rp->shift;\r\nmemset(&ma, 0, sizeof(ma));\r\nma.msr_no = rd->msrs[rp->id];\r\nma.clear_mask = rp->mask;\r\nma.set_mask = bits;\r\nret = smp_call_function_single(cpu, msrl_update_func, &ma, 1);\r\nif (ret)\r\nWARN_ON_ONCE(ret);\r\nelse\r\nret = ma.err;\r\nreturn ret;\r\n}\r\nstatic int rapl_check_unit_core(struct rapl_package *rp, int cpu)\r\n{\r\nu64 msr_val;\r\nu32 value;\r\nif (rdmsrl_safe_on_cpu(cpu, MSR_RAPL_POWER_UNIT, &msr_val)) {\r\npr_err("Failed to read power unit MSR 0x%x on CPU %d, exit.\n",\r\nMSR_RAPL_POWER_UNIT, cpu);\r\nreturn -ENODEV;\r\n}\r\nvalue = (msr_val & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;\r\nrp->energy_unit = ENERGY_UNIT_SCALE * 1000000 / (1 << value);\r\nvalue = (msr_val & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;\r\nrp->power_unit = 1000000 / (1 << value);\r\nvalue = (msr_val & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;\r\nrp->time_unit = 1000000 / (1 << value);\r\npr_debug("Core CPU package %d energy=%dpJ, time=%dus, power=%duW\n",\r\nrp->id, rp->energy_unit, rp->time_unit, rp->power_unit);\r\nreturn 0;\r\n}\r\nstatic int rapl_check_unit_atom(struct rapl_package *rp, int cpu)\r\n{\r\nu64 msr_val;\r\nu32 value;\r\nif (rdmsrl_safe_on_cpu(cpu, MSR_RAPL_POWER_UNIT, &msr_val)) {\r\npr_err("Failed to read power unit MSR 0x%x on CPU %d, exit.\n",\r\nMSR_RAPL_POWER_UNIT, cpu);\r\nreturn -ENODEV;\r\n}\r\nvalue = (msr_val & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;\r\nrp->energy_unit = ENERGY_UNIT_SCALE * 1 << value;\r\nvalue = (msr_val & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;\r\nrp->power_unit = (1 << value) * 1000;\r\nvalue = (msr_val & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;\r\nrp->time_unit = 1000000 / (1 << value);\r\npr_debug("Atom package %d energy=%dpJ, time=%dus, power=%duW\n",\r\nrp->id, rp->energy_unit, rp->time_unit, rp->power_unit);\r\nreturn 0;\r\n}\r\nstatic void power_limit_irq_save_cpu(void *info)\r\n{\r\nu32 l, h = 0;\r\nstruct rapl_package *rp = (struct rapl_package *)info;\r\nrdmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);\r\nif (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED)) {\r\nrp->power_limit_irq = l & PACKAGE_THERM_INT_PLN_ENABLE;\r\nrp->power_limit_irq |= PACKAGE_PLN_INT_SAVED;\r\n}\r\nl &= ~PACKAGE_THERM_INT_PLN_ENABLE;\r\nwrmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic void package_power_limit_irq_save(struct rapl_package *rp)\r\n{\r\nif (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))\r\nreturn;\r\nsmp_call_function_single(rp->lead_cpu, power_limit_irq_save_cpu, rp, 1);\r\n}\r\nstatic void package_power_limit_irq_restore(struct rapl_package *rp)\r\n{\r\nu32 l, h;\r\nif (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))\r\nreturn;\r\nif (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED))\r\nreturn;\r\nrdmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);\r\nif (rp->power_limit_irq & PACKAGE_THERM_INT_PLN_ENABLE)\r\nl |= PACKAGE_THERM_INT_PLN_ENABLE;\r\nelse\r\nl &= ~PACKAGE_THERM_INT_PLN_ENABLE;\r\nwrmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic void set_floor_freq_default(struct rapl_domain *rd, bool mode)\r\n{\r\nint nr_powerlimit = find_nr_power_limit(rd);\r\nrapl_write_data_raw(rd, PL1_CLAMP, mode);\r\nif (nr_powerlimit > 1) {\r\nrapl_write_data_raw(rd, PL2_ENABLE, mode);\r\nrapl_write_data_raw(rd, PL2_CLAMP, mode);\r\n}\r\n}\r\nstatic void set_floor_freq_atom(struct rapl_domain *rd, bool enable)\r\n{\r\nstatic u32 power_ctrl_orig_val;\r\nu32 mdata;\r\nif (!rapl_defaults->floor_freq_reg_addr) {\r\npr_err("Invalid floor frequency config register\n");\r\nreturn;\r\n}\r\nif (!power_ctrl_orig_val)\r\niosf_mbi_read(BT_MBI_UNIT_PMC, MBI_CR_READ,\r\nrapl_defaults->floor_freq_reg_addr,\r\n&power_ctrl_orig_val);\r\nmdata = power_ctrl_orig_val;\r\nif (enable) {\r\nmdata &= ~(0x7f << 8);\r\nmdata |= 1 << 8;\r\n}\r\niosf_mbi_write(BT_MBI_UNIT_PMC, MBI_CR_WRITE,\r\nrapl_defaults->floor_freq_reg_addr, mdata);\r\n}\r\nstatic u64 rapl_compute_time_window_core(struct rapl_package *rp, u64 value,\r\nbool to_raw)\r\n{\r\nu64 f, y;\r\nif (!to_raw) {\r\nf = (value & 0x60) >> 5;\r\ny = value & 0x1f;\r\nvalue = (1 << y) * (4 + f) * rp->time_unit / 4;\r\n} else {\r\ndo_div(value, rp->time_unit);\r\ny = ilog2(value);\r\nf = div64_u64(4 * (value - (1 << y)), 1 << y);\r\nvalue = (y & 0x1f) | ((f & 0x3) << 5);\r\n}\r\nreturn value;\r\n}\r\nstatic u64 rapl_compute_time_window_atom(struct rapl_package *rp, u64 value,\r\nbool to_raw)\r\n{\r\nif (!to_raw)\r\nreturn (value) ? value *= rp->time_unit : rp->time_unit;\r\nelse\r\nvalue = div64_u64(value, rp->time_unit);\r\nreturn value;\r\n}\r\nstatic void rapl_update_domain_data(struct rapl_package *rp)\r\n{\r\nint dmn, prim;\r\nu64 val;\r\nfor (dmn = 0; dmn < rp->nr_domains; dmn++) {\r\npr_debug("update package %d domain %s data\n", rp->id,\r\nrp->domains[dmn].name);\r\nfor (prim = 0; prim < NR_RAW_PRIMITIVES; prim++) {\r\nif (!rapl_read_data_raw(&rp->domains[dmn], prim,\r\nrpi[prim].unit, &val))\r\nrp->domains[dmn].rdd.primitives[prim] = val;\r\n}\r\n}\r\n}\r\nstatic void rapl_unregister_powercap(void)\r\n{\r\nif (platform_rapl_domain) {\r\npowercap_unregister_zone(control_type,\r\n&platform_rapl_domain->power_zone);\r\nkfree(platform_rapl_domain);\r\n}\r\npowercap_unregister_control_type(control_type);\r\n}\r\nstatic int rapl_package_register_powercap(struct rapl_package *rp)\r\n{\r\nstruct rapl_domain *rd;\r\nchar dev_name[17];\r\nstruct powercap_zone *power_zone = NULL;\r\nint nr_pl, ret;;\r\nrapl_update_domain_data(rp);\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nnr_pl = find_nr_power_limit(rd);\r\npr_debug("register socket %d package domain %s\n",\r\nrp->id, rd->name);\r\nmemset(dev_name, 0, sizeof(dev_name));\r\nsnprintf(dev_name, sizeof(dev_name), "%s-%d",\r\nrd->name, rp->id);\r\npower_zone = powercap_register_zone(&rd->power_zone,\r\ncontrol_type,\r\ndev_name, NULL,\r\n&zone_ops[rd->id],\r\nnr_pl,\r\n&constraint_ops);\r\nif (IS_ERR(power_zone)) {\r\npr_debug("failed to register package, %d\n",\r\nrp->id);\r\nreturn PTR_ERR(power_zone);\r\n}\r\nrp->power_zone = power_zone;\r\nbreak;\r\n}\r\n}\r\nif (!power_zone) {\r\npr_err("no package domain found, unknown topology!\n");\r\nreturn -ENODEV;\r\n}\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nif (rd->id == RAPL_DOMAIN_PACKAGE)\r\ncontinue;\r\nnr_pl = find_nr_power_limit(rd);\r\npower_zone = powercap_register_zone(&rd->power_zone,\r\ncontrol_type, rd->name,\r\nrp->power_zone,\r\n&zone_ops[rd->id], nr_pl,\r\n&constraint_ops);\r\nif (IS_ERR(power_zone)) {\r\npr_debug("failed to register power_zone, %d:%s:%s\n",\r\nrp->id, rd->name, dev_name);\r\nret = PTR_ERR(power_zone);\r\ngoto err_cleanup;\r\n}\r\n}\r\nreturn 0;\r\nerr_cleanup:\r\nwhile (--rd >= rp->domains) {\r\npr_debug("unregister package %d domain %s\n", rp->id, rd->name);\r\npowercap_unregister_zone(control_type, &rd->power_zone);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init rapl_register_psys(void)\r\n{\r\nstruct rapl_domain *rd;\r\nstruct powercap_zone *power_zone;\r\nu64 val;\r\nif (rdmsrl_safe_on_cpu(0, MSR_PLATFORM_ENERGY_STATUS, &val) || !val)\r\nreturn -ENODEV;\r\nif (rdmsrl_safe_on_cpu(0, MSR_PLATFORM_POWER_LIMIT, &val) || !val)\r\nreturn -ENODEV;\r\nrd = kzalloc(sizeof(*rd), GFP_KERNEL);\r\nif (!rd)\r\nreturn -ENOMEM;\r\nrd->name = rapl_domain_names[RAPL_DOMAIN_PLATFORM];\r\nrd->id = RAPL_DOMAIN_PLATFORM;\r\nrd->msrs[0] = MSR_PLATFORM_POWER_LIMIT;\r\nrd->msrs[1] = MSR_PLATFORM_ENERGY_STATUS;\r\nrd->rpl[0].prim_id = PL1_ENABLE;\r\nrd->rpl[0].name = pl1_name;\r\nrd->rpl[1].prim_id = PL2_ENABLE;\r\nrd->rpl[1].name = pl2_name;\r\nrd->rp = find_package_by_id(0);\r\npower_zone = powercap_register_zone(&rd->power_zone, control_type,\r\n"psys", NULL,\r\n&zone_ops[RAPL_DOMAIN_PLATFORM],\r\n2, &constraint_ops);\r\nif (IS_ERR(power_zone)) {\r\nkfree(rd);\r\nreturn PTR_ERR(power_zone);\r\n}\r\nplatform_rapl_domain = rd;\r\nreturn 0;\r\n}\r\nstatic int __init rapl_register_powercap(void)\r\n{\r\ncontrol_type = powercap_register_control_type(NULL, "intel-rapl", NULL);\r\nif (IS_ERR(control_type)) {\r\npr_debug("failed to register powercap control_type.\n");\r\nreturn PTR_ERR(control_type);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rapl_check_domain(int cpu, int domain)\r\n{\r\nunsigned msr;\r\nu64 val = 0;\r\nswitch (domain) {\r\ncase RAPL_DOMAIN_PACKAGE:\r\nmsr = MSR_PKG_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_PP0:\r\nmsr = MSR_PP0_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_PP1:\r\nmsr = MSR_PP1_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_DRAM:\r\nmsr = MSR_DRAM_ENERGY_STATUS;\r\nbreak;\r\ncase RAPL_DOMAIN_PLATFORM:\r\nreturn -EINVAL;\r\ndefault:\r\npr_err("invalid domain id %d\n", domain);\r\nreturn -EINVAL;\r\n}\r\nif (rdmsrl_safe_on_cpu(cpu, msr, &val) || !val)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void rapl_detect_powerlimit(struct rapl_domain *rd)\r\n{\r\nu64 val64;\r\nint i;\r\nif (!rapl_read_data_raw(rd, FW_LOCK, false, &val64)) {\r\nif (val64) {\r\npr_info("RAPL package %d domain %s locked by BIOS\n",\r\nrd->rp->id, rd->name);\r\nrd->state |= DOMAIN_STATE_BIOS_LOCKED;\r\n}\r\n}\r\nfor (i = 0; i < NR_POWER_LIMITS; i++) {\r\nint prim = rd->rpl[i].prim_id;\r\nif (rapl_read_data_raw(rd, prim, false, &val64))\r\nrd->rpl[i].name = NULL;\r\n}\r\n}\r\nstatic int rapl_detect_domains(struct rapl_package *rp, int cpu)\r\n{\r\nstruct rapl_domain *rd;\r\nint i;\r\nfor (i = 0; i < RAPL_DOMAIN_MAX; i++) {\r\nif (!rapl_check_domain(cpu, i)) {\r\nrp->domain_map |= 1 << i;\r\npr_info("Found RAPL domain %s\n", rapl_domain_names[i]);\r\n}\r\n}\r\nrp->nr_domains = bitmap_weight(&rp->domain_map, RAPL_DOMAIN_MAX);\r\nif (!rp->nr_domains) {\r\npr_debug("no valid rapl domains found in package %d\n", rp->id);\r\nreturn -ENODEV;\r\n}\r\npr_debug("found %d domains on package %d\n", rp->nr_domains, rp->id);\r\nrp->domains = kcalloc(rp->nr_domains + 1, sizeof(struct rapl_domain),\r\nGFP_KERNEL);\r\nif (!rp->domains)\r\nreturn -ENOMEM;\r\nrapl_init_domains(rp);\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++)\r\nrapl_detect_powerlimit(rd);\r\nreturn 0;\r\n}\r\nstatic void rapl_remove_package(struct rapl_package *rp)\r\n{\r\nstruct rapl_domain *rd, *rd_package = NULL;\r\npackage_power_limit_irq_restore(rp);\r\nfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\r\nrapl_write_data_raw(rd, PL1_ENABLE, 0);\r\nrapl_write_data_raw(rd, PL1_CLAMP, 0);\r\nif (find_nr_power_limit(rd) > 1) {\r\nrapl_write_data_raw(rd, PL2_ENABLE, 0);\r\nrapl_write_data_raw(rd, PL2_CLAMP, 0);\r\n}\r\nif (rd->id == RAPL_DOMAIN_PACKAGE) {\r\nrd_package = rd;\r\ncontinue;\r\n}\r\npr_debug("remove package, undo power limit on %d: %s\n",\r\nrp->id, rd->name);\r\npowercap_unregister_zone(control_type, &rd->power_zone);\r\n}\r\npowercap_unregister_zone(control_type, &rd_package->power_zone);\r\nlist_del(&rp->plist);\r\nkfree(rp);\r\n}\r\nstatic struct rapl_package *rapl_add_package(int cpu, int pkgid)\r\n{\r\nstruct rapl_package *rp;\r\nint ret;\r\nrp = kzalloc(sizeof(struct rapl_package), GFP_KERNEL);\r\nif (!rp)\r\nreturn ERR_PTR(-ENOMEM);\r\nrp->id = pkgid;\r\nrp->lead_cpu = cpu;\r\nif (rapl_detect_domains(rp, cpu) ||\r\nrapl_defaults->check_unit(rp, cpu)) {\r\nret = -ENODEV;\r\ngoto err_free_package;\r\n}\r\nret = rapl_package_register_powercap(rp);\r\nif (!ret) {\r\nINIT_LIST_HEAD(&rp->plist);\r\nlist_add(&rp->plist, &rapl_packages);\r\nreturn rp;\r\n}\r\nerr_free_package:\r\nkfree(rp->domains);\r\nkfree(rp);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int rapl_cpu_online(unsigned int cpu)\r\n{\r\nint pkgid = topology_physical_package_id(cpu);\r\nstruct rapl_package *rp;\r\nrp = find_package_by_id(pkgid);\r\nif (!rp) {\r\nrp = rapl_add_package(cpu, pkgid);\r\nif (IS_ERR(rp))\r\nreturn PTR_ERR(rp);\r\n}\r\ncpumask_set_cpu(cpu, &rp->cpumask);\r\nreturn 0;\r\n}\r\nstatic int rapl_cpu_down_prep(unsigned int cpu)\r\n{\r\nint pkgid = topology_physical_package_id(cpu);\r\nstruct rapl_package *rp;\r\nint lead_cpu;\r\nrp = find_package_by_id(pkgid);\r\nif (!rp)\r\nreturn 0;\r\ncpumask_clear_cpu(cpu, &rp->cpumask);\r\nlead_cpu = cpumask_first(&rp->cpumask);\r\nif (lead_cpu >= nr_cpu_ids)\r\nrapl_remove_package(rp);\r\nelse if (rp->lead_cpu == cpu)\r\nrp->lead_cpu = lead_cpu;\r\nreturn 0;\r\n}\r\nstatic int __init rapl_init(void)\r\n{\r\nconst struct x86_cpu_id *id;\r\nint ret;\r\nid = x86_match_cpu(rapl_ids);\r\nif (!id) {\r\npr_err("driver does not support CPU family %d model %d\n",\r\nboot_cpu_data.x86, boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nrapl_defaults = (struct rapl_defaults *)id->driver_data;\r\nret = rapl_register_powercap();\r\nif (ret)\r\nreturn ret;\r\nret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "powercap/rapl:online",\r\nrapl_cpu_online, rapl_cpu_down_prep);\r\nif (ret < 0)\r\ngoto err_unreg;\r\npcap_rapl_online = ret;\r\nrapl_register_psys();\r\nreturn 0;\r\nerr_unreg:\r\nrapl_unregister_powercap();\r\nreturn ret;\r\n}\r\nstatic void __exit rapl_exit(void)\r\n{\r\ncpuhp_remove_state(pcap_rapl_online);\r\nrapl_unregister_powercap();\r\n}
