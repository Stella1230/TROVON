static void read_page(struct hfi1_devdata *dd, u32 offset, u32 *result)\r\n{\r\nint i;\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_DATA(offset));\r\nfor (i = 0; i < EP_PAGE_DWORDS; i++)\r\nresult[i] = (u32)read_csr(dd, ASIC_EEP_DATA);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_NOP);\r\n}\r\nstatic int read_length(struct hfi1_devdata *dd, u32 start, u32 len, void *dest)\r\n{\r\nu32 buffer[EP_PAGE_DWORDS];\r\nu32 end;\r\nu32 start_offset;\r\nu32 read_start;\r\nu32 bytes;\r\nif (len == 0)\r\nreturn 0;\r\nend = start + len;\r\nif (end > (1 << CMD_SHIFT))\r\nreturn -EINVAL;\r\nstart_offset = start & EP_PAGE_MASK;\r\nif (start_offset) {\r\nread_start = start & ~EP_PAGE_MASK;\r\nread_page(dd, read_start, buffer);\r\nbytes = EP_PAGE_SIZE - start_offset;\r\nif (len <= bytes) {\r\nmemcpy(dest, (u8 *)buffer + start_offset, len);\r\nreturn 0;\r\n}\r\nmemcpy(dest, (u8 *)buffer + start_offset, bytes);\r\nstart += bytes;\r\nlen -= bytes;\r\ndest += bytes;\r\n}\r\nwhile (len >= EP_PAGE_SIZE) {\r\nread_page(dd, start, buffer);\r\nmemcpy(dest, buffer, EP_PAGE_SIZE);\r\nstart += EP_PAGE_SIZE;\r\nlen -= EP_PAGE_SIZE;\r\ndest += EP_PAGE_SIZE;\r\n}\r\nif (len) {\r\nread_page(dd, start, buffer);\r\nmemcpy(dest, buffer, len);\r\n}\r\nreturn 0;\r\n}\r\nint eprom_init(struct hfi1_devdata *dd)\r\n{\r\nint ret = 0;\r\nif (dd->pcidev->device != PCI_DEVICE_ID_INTEL0)\r\nreturn 0;\r\nret = acquire_chip_resource(dd, CR_EPROM, EPROM_TIMEOUT);\r\nif (ret) {\r\ndd_dev_err(dd,\r\n"%s: unable to acquire EPROM resource, no EPROM support\n",\r\n__func__);\r\ngoto done_asic;\r\n}\r\nwrite_csr(dd, ASIC_EEP_CTL_STAT, ASIC_EEP_CTL_STAT_EP_RESET_SMASK);\r\nwrite_csr(dd, ASIC_EEP_CTL_STAT,\r\nEP_SPEED_FULL << ASIC_EEP_CTL_STAT_RATE_SPI_SHIFT);\r\nwrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_RELEASE_POWERDOWN_NOID);\r\ndd->eprom_available = true;\r\nrelease_chip_resource(dd, CR_EPROM);\r\ndone_asic:\r\nreturn ret;\r\n}\r\nstatic int read_partition_platform_config(struct hfi1_devdata *dd, void **data,\r\nu32 *size)\r\n{\r\nvoid *buffer;\r\nvoid *p;\r\nu32 length;\r\nint ret;\r\nbuffer = kmalloc(P1_SIZE, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nret = read_length(dd, P1_START, P1_SIZE, buffer);\r\nif (ret) {\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\np = strnstr(buffer, IMAGE_TRAIL_MAGIC, P1_SIZE);\r\nif (p)\r\nlength = p - buffer;\r\nelse\r\nlength = P1_SIZE;\r\n*data = buffer;\r\n*size = length;\r\nreturn 0;\r\n}\r\nstatic int read_segment_platform_config(struct hfi1_devdata *dd,\r\nvoid *directory, void **data, u32 *size)\r\n{\r\nstruct hfi1_eprom_footer *footer;\r\nstruct hfi1_eprom_table_entry *table;\r\nstruct hfi1_eprom_table_entry *entry;\r\nvoid *buffer = NULL;\r\nvoid *table_buffer = NULL;\r\nint ret, i;\r\nu32 directory_size;\r\nu32 seg_base, seg_offset;\r\nu32 bytes_available, ncopied, to_copy;\r\nfooter = (struct hfi1_eprom_footer *)\r\n(directory + EP_PAGE_SIZE - sizeof(*footer));\r\nif (footer->version != FOOTER_VERSION)\r\nreturn -EINVAL;\r\nif (footer->oprom_size >= SEG_SIZE)\r\nreturn -EINVAL;\r\nif (footer->num_table_entries >\r\nMAX_TABLE_ENTRIES(SEG_SIZE - footer->oprom_size))\r\nreturn -EINVAL;\r\ndirectory_size = DIRECTORY_SIZE(footer->num_table_entries);\r\nif (directory_size <= EP_PAGE_SIZE) {\r\ntable = (struct hfi1_eprom_table_entry *)\r\n(directory + EP_PAGE_SIZE - directory_size);\r\n} else {\r\ntable_buffer = kmalloc(directory_size, GFP_KERNEL);\r\nif (!table_buffer)\r\nreturn -ENOMEM;\r\nret = read_length(dd, SEG_SIZE - directory_size,\r\ndirectory_size, table_buffer);\r\nif (ret)\r\ngoto done;\r\ntable = table_buffer;\r\n}\r\nfor (entry = NULL, i = 0; i < footer->num_table_entries; i++) {\r\nif (table[i].type == HFI1_EFT_PLATFORM_CONFIG) {\r\nentry = &table[i];\r\nbreak;\r\n}\r\n}\r\nif (!entry) {\r\nret = -ENOENT;\r\ngoto done;\r\n}\r\nif (entry->size > (4 * 1024)) {\r\ndd_dev_err(dd, "Bad configuration file size 0x%x\n",\r\nentry->size);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (entry->offset + entry->size < entry->offset) {\r\ndd_dev_err(dd,\r\n"Bad configuration file start + size 0x%x+0x%x\n",\r\nentry->offset, entry->size);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbuffer = kmalloc(entry->size, GFP_KERNEL);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nseg_offset = entry->offset % SEG_SIZE;\r\nseg_base = entry->offset - seg_offset;\r\nncopied = 0;\r\nwhile (ncopied < entry->size) {\r\nbytes_available = SEG_SIZE - seg_offset;\r\nif (seg_base == 0) {\r\nif (bytes_available <= directory_size) {\r\ndd_dev_err(dd,\r\n"Bad configuration file - offset 0x%x within footer+table\n",\r\nentry->offset);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbytes_available -= directory_size;\r\n}\r\nto_copy = entry->size - ncopied;\r\nif (to_copy > bytes_available)\r\nto_copy = bytes_available;\r\nret = read_length(dd, seg_base + seg_offset, to_copy,\r\nbuffer + ncopied);\r\nif (ret)\r\ngoto done;\r\nncopied += to_copy;\r\nseg_offset = footer->oprom_size;\r\nseg_base += SEG_SIZE;\r\n}\r\nret = 0;\r\n*data = buffer;\r\n*size = entry->size;\r\ndone:\r\nkfree(table_buffer);\r\nif (ret)\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nint eprom_read_platform_config(struct hfi1_devdata *dd, void **data, u32 *size)\r\n{\r\nu32 directory[EP_PAGE_DWORDS];\r\nint ret;\r\nif (!dd->eprom_available)\r\nreturn -ENXIO;\r\nret = acquire_chip_resource(dd, CR_EPROM, EPROM_TIMEOUT);\r\nif (ret)\r\nreturn -EBUSY;\r\nret = read_length(dd, SEG_SIZE - EP_PAGE_SIZE, EP_PAGE_SIZE, directory);\r\nif (ret)\r\ngoto done;\r\nif (directory[EP_PAGE_DWORDS - 1] == FOOTER_MAGIC) {\r\nret = read_segment_platform_config(dd, directory, data, size);\r\n} else {\r\nret = read_partition_platform_config(dd, data, size);\r\n}\r\ndone:\r\nrelease_chip_resource(dd, CR_EPROM);\r\nreturn ret;\r\n}
