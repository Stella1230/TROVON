static void tw686x_buf_done(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\r\nstruct tw686x_dev *dev = vc->dev;\r\nstruct vb2_v4l2_buffer *vb;\r\nstruct vb2_buffer *vb2_buf;\r\nif (vc->curr_bufs[pb]) {\r\nvb = &vc->curr_bufs[pb]->vb;\r\nvb->field = dev->dma_ops->field;\r\nvb->sequence = vc->sequence++;\r\nvb2_buf = &vb->vb2_buf;\r\nif (dev->dma_mode == TW686X_DMA_MODE_MEMCPY)\r\nmemcpy(vb2_plane_vaddr(vb2_buf, 0), desc->virt,\r\ndesc->size);\r\nvb2_buf->timestamp = ktime_get_ns();\r\nvb2_buffer_done(vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nvc->pb = !pb;\r\n}\r\nstatic void tw686x_memcpy_dma_free(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\r\nstruct tw686x_dev *dev = vc->dev;\r\nstruct pci_dev *pci_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\npci_dev = dev->pci_dev;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!pci_dev) {\r\nWARN(1, "trying to deallocate on missing device\n");\r\nreturn;\r\n}\r\nif (desc->virt) {\r\npci_free_consistent(dev->pci_dev, desc->size,\r\ndesc->virt, desc->phys);\r\ndesc->virt = NULL;\r\n}\r\n}\r\nstatic int tw686x_memcpy_dma_alloc(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_dev *dev = vc->dev;\r\nu32 reg = pb ? VDMA_B_ADDR[vc->ch] : VDMA_P_ADDR[vc->ch];\r\nunsigned int len;\r\nvoid *virt;\r\nWARN(vc->dma_descs[pb].virt,\r\n"Allocating buffer but previous still here\n");\r\nlen = (vc->width * vc->height * vc->format->depth) >> 3;\r\nvirt = pci_alloc_consistent(dev->pci_dev, len,\r\n&vc->dma_descs[pb].phys);\r\nif (!virt) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"dma%d: unable to allocate %s-buffer\n",\r\nvc->ch, pb ? "B" : "P");\r\nreturn -ENOMEM;\r\n}\r\nvc->dma_descs[pb].size = len;\r\nvc->dma_descs[pb].virt = virt;\r\nreg_write(dev, reg, vc->dma_descs[pb].phys);\r\nreturn 0;\r\n}\r\nstatic void tw686x_memcpy_buf_refill(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_v4l2_buf *buf;\r\nwhile (!list_empty(&vc->vidq_queued)) {\r\nbuf = list_first_entry(&vc->vidq_queued,\r\nstruct tw686x_v4l2_buf, list);\r\nlist_del(&buf->list);\r\nvc->curr_bufs[pb] = buf;\r\nreturn;\r\n}\r\nvc->curr_bufs[pb] = NULL;\r\n}\r\nstatic void tw686x_contig_buf_refill(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_v4l2_buf *buf;\r\nwhile (!list_empty(&vc->vidq_queued)) {\r\nu32 reg = pb ? VDMA_B_ADDR[vc->ch] : VDMA_P_ADDR[vc->ch];\r\ndma_addr_t phys;\r\nbuf = list_first_entry(&vc->vidq_queued,\r\nstruct tw686x_v4l2_buf, list);\r\nlist_del(&buf->list);\r\nphys = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\r\nreg_write(vc->dev, reg, phys);\r\nbuf->vb.vb2_buf.state = VB2_BUF_STATE_ACTIVE;\r\nvc->curr_bufs[pb] = buf;\r\nreturn;\r\n}\r\nvc->curr_bufs[pb] = NULL;\r\n}\r\nstatic int tw686x_sg_desc_fill(struct tw686x_sg_desc *descs,\r\nstruct tw686x_v4l2_buf *buf,\r\nunsigned int buf_len)\r\n{\r\nstruct sg_table *vbuf = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);\r\nunsigned int len, entry_len;\r\nstruct scatterlist *sg;\r\nint i, count;\r\nmemset(descs, 0, TW686X_SG_TABLE_SIZE);\r\ncount = 0;\r\nfor_each_sg(vbuf->sgl, sg, vbuf->nents, i) {\r\ndma_addr_t phys = sg_dma_address(sg);\r\nlen = sg_dma_len(sg);\r\nwhile (len && buf_len) {\r\nif (count == TW686X_MAX_SG_DESC_COUNT)\r\nreturn -ENOMEM;\r\nentry_len = min_t(unsigned int, len,\r\nTW686X_MAX_SG_ENTRY_SIZE);\r\nentry_len = min_t(unsigned int, entry_len, buf_len);\r\ndescs[count].phys = cpu_to_le32(phys);\r\ndescs[count++].flags_length =\r\ncpu_to_le32(BIT(30) | entry_len);\r\nphys += entry_len;\r\nlen -= entry_len;\r\nbuf_len -= entry_len;\r\n}\r\nif (!buf_len)\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void tw686x_sg_buf_refill(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_dev *dev = vc->dev;\r\nstruct tw686x_v4l2_buf *buf;\r\nwhile (!list_empty(&vc->vidq_queued)) {\r\nunsigned int buf_len;\r\nbuf = list_first_entry(&vc->vidq_queued,\r\nstruct tw686x_v4l2_buf, list);\r\nlist_del(&buf->list);\r\nbuf_len = (vc->width * vc->height * vc->format->depth) >> 3;\r\nif (tw686x_sg_desc_fill(vc->sg_descs[pb], buf, buf_len)) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"dma%d: unable to fill %s-buffer\n",\r\nvc->ch, pb ? "B" : "P");\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\ncontinue;\r\n}\r\nbuf->vb.vb2_buf.state = VB2_BUF_STATE_ACTIVE;\r\nvc->curr_bufs[pb] = buf;\r\nreturn;\r\n}\r\nvc->curr_bufs[pb] = NULL;\r\n}\r\nstatic void tw686x_sg_dma_free(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\r\nstruct tw686x_dev *dev = vc->dev;\r\nif (desc->size) {\r\npci_free_consistent(dev->pci_dev, desc->size,\r\ndesc->virt, desc->phys);\r\ndesc->virt = NULL;\r\n}\r\nvc->sg_descs[pb] = NULL;\r\n}\r\nstatic int tw686x_sg_dma_alloc(struct tw686x_video_channel *vc,\r\nunsigned int pb)\r\n{\r\nstruct tw686x_dma_desc *desc = &vc->dma_descs[pb];\r\nstruct tw686x_dev *dev = vc->dev;\r\nu32 reg = pb ? DMA_PAGE_TABLE1_ADDR[vc->ch] :\r\nDMA_PAGE_TABLE0_ADDR[vc->ch];\r\nvoid *virt;\r\nif (desc->size) {\r\nvirt = pci_alloc_consistent(dev->pci_dev, desc->size,\r\n&desc->phys);\r\nif (!virt) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"dma%d: unable to allocate %s-buffer\n",\r\nvc->ch, pb ? "B" : "P");\r\nreturn -ENOMEM;\r\n}\r\ndesc->virt = virt;\r\nreg_write(dev, reg, desc->phys);\r\n} else {\r\nvirt = dev->video_channels[0].dma_descs[pb].virt +\r\nvc->ch * TW686X_SG_TABLE_SIZE;\r\n}\r\nvc->sg_descs[pb] = virt;\r\nreturn 0;\r\n}\r\nstatic int tw686x_sg_setup(struct tw686x_dev *dev)\r\n{\r\nunsigned int sg_table_size, pb, ch, channels;\r\nif (is_second_gen(dev)) {\r\nchannels = max_channels(dev);\r\nsg_table_size = TW686X_SG_TABLE_SIZE;\r\n} else {\r\nchannels = 1;\r\nsg_table_size = max_channels(dev) * TW686X_SG_TABLE_SIZE;\r\n}\r\nfor (ch = 0; ch < channels; ch++) {\r\nstruct tw686x_video_channel *vc = &dev->video_channels[ch];\r\nfor (pb = 0; pb < 2; pb++)\r\nvc->dma_descs[pb].size = sg_table_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int tw686x_real_fps(unsigned int index, unsigned int max_fps)\r\n{\r\nunsigned long mask;\r\nif (!index || index >= ARRAY_SIZE(fps_map))\r\nreturn max_fps;\r\nmask = GENMASK(max_fps - 1, 0);\r\nreturn hweight_long(fps_map[index] & mask);\r\n}\r\nstatic unsigned int tw686x_fps_idx(unsigned int fps, unsigned int max_fps)\r\n{\r\nunsigned int idx, real_fps;\r\nint delta;\r\nidx = (12 + 15 * fps) / max_fps;\r\nif (!idx)\r\nreturn 1;\r\nreal_fps = tw686x_real_fps(idx, max_fps);\r\ndelta = real_fps - fps;\r\nif (delta < -1)\r\nidx++;\r\nelse if (delta > 1)\r\nidx--;\r\nif (idx >= 15)\r\nreturn 0;\r\nreturn idx;\r\n}\r\nstatic void tw686x_set_framerate(struct tw686x_video_channel *vc,\r\nunsigned int fps)\r\n{\r\nunsigned int i;\r\ni = tw686x_fps_idx(fps, TW686X_MAX_FPS(vc->video_standard));\r\nreg_write(vc->dev, VIDEO_FIELD_CTRL[vc->ch], fps_map[i]);\r\nvc->fps = tw686x_real_fps(i, TW686X_MAX_FPS(vc->video_standard));\r\n}\r\nstatic const struct tw686x_format *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int cnt;\r\nfor (cnt = 0; cnt < ARRAY_SIZE(formats); cnt++)\r\nif (formats[cnt].fourcc == fourcc)\r\nreturn &formats[cnt];\r\nreturn NULL;\r\n}\r\nstatic int tw686x_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct tw686x_video_channel *vc = vb2_get_drv_priv(vq);\r\nunsigned int szimage =\r\n(vc->width * vc->height * vc->format->depth) >> 3;\r\nif (vq->num_buffers + *nbuffers < 3)\r\n*nbuffers = 3 - vq->num_buffers;\r\nif (*nplanes) {\r\nif (*nplanes != 1 || sizes[0] < szimage)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nsizes[0] = szimage;\r\n*nplanes = 1;\r\nreturn 0;\r\n}\r\nstatic void tw686x_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct tw686x_video_channel *vc = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct tw686x_dev *dev = vc->dev;\r\nstruct pci_dev *pci_dev;\r\nunsigned long flags;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct tw686x_v4l2_buf *buf =\r\ncontainer_of(vbuf, struct tw686x_v4l2_buf, vb);\r\nspin_lock_irqsave(&dev->lock, flags);\r\npci_dev = dev->pci_dev;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!pci_dev) {\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&vc->qlock, flags);\r\nlist_add_tail(&buf->list, &vc->vidq_queued);\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\n}\r\nstatic void tw686x_clear_queue(struct tw686x_video_channel *vc,\r\nenum vb2_buffer_state state)\r\n{\r\nunsigned int pb;\r\nwhile (!list_empty(&vc->vidq_queued)) {\r\nstruct tw686x_v4l2_buf *buf;\r\nbuf = list_first_entry(&vc->vidq_queued,\r\nstruct tw686x_v4l2_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, state);\r\n}\r\nfor (pb = 0; pb < 2; pb++) {\r\nif (vc->curr_bufs[pb])\r\nvb2_buffer_done(&vc->curr_bufs[pb]->vb.vb2_buf, state);\r\nvc->curr_bufs[pb] = NULL;\r\n}\r\n}\r\nstatic int tw686x_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct tw686x_video_channel *vc = vb2_get_drv_priv(vq);\r\nstruct tw686x_dev *dev = vc->dev;\r\nstruct pci_dev *pci_dev;\r\nunsigned long flags;\r\nint pb, err;\r\nspin_lock_irqsave(&dev->lock, flags);\r\npci_dev = dev->pci_dev;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!pci_dev) {\r\nerr = -ENODEV;\r\ngoto err_clear_queue;\r\n}\r\nspin_lock_irqsave(&vc->qlock, flags);\r\nif (dev->dma_mode == TW686X_DMA_MODE_MEMCPY &&\r\n(!vc->dma_descs[0].virt || !vc->dma_descs[1].virt)) {\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\nv4l2_err(&dev->v4l2_dev,\r\n"video%d: refusing to start without DMA buffers\n",\r\nvc->num);\r\nerr = -ENOMEM;\r\ngoto err_clear_queue;\r\n}\r\nfor (pb = 0; pb < 2; pb++)\r\ndev->dma_ops->buf_refill(vc, pb);\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\nvc->sequence = 0;\r\nvc->pb = 0;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntw686x_enable_channel(dev, vc->ch);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmod_timer(&dev->dma_delay_timer, jiffies + msecs_to_jiffies(100));\r\nreturn 0;\r\nerr_clear_queue:\r\nspin_lock_irqsave(&vc->qlock, flags);\r\ntw686x_clear_queue(vc, VB2_BUF_STATE_QUEUED);\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\nreturn err;\r\n}\r\nstatic void tw686x_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct tw686x_video_channel *vc = vb2_get_drv_priv(vq);\r\nstruct tw686x_dev *dev = vc->dev;\r\nstruct pci_dev *pci_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\npci_dev = dev->pci_dev;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (pci_dev)\r\ntw686x_disable_channel(dev, vc->ch);\r\nspin_lock_irqsave(&vc->qlock, flags);\r\ntw686x_clear_queue(vc, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\n}\r\nstatic int tw686x_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct tw686x_video_channel *vc = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned int size =\r\n(vc->width * vc->height * vc->format->depth) >> 3;\r\nif (vb2_plane_size(vb, 0) < size)\r\nreturn -EINVAL;\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic int tw686x_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct tw686x_video_channel *vc;\r\nstruct tw686x_dev *dev;\r\nunsigned int ch;\r\nvc = container_of(ctrl->handler, struct tw686x_video_channel,\r\nctrl_handler);\r\ndev = vc->dev;\r\nch = vc->ch;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreg_write(dev, BRIGHT[ch], ctrl->val & 0xff);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\nreg_write(dev, CONTRAST[ch], ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\nreg_write(dev, SAT_U[ch], ctrl->val);\r\nreg_write(dev, SAT_V[ch], ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\nreg_write(dev, HUE[ch], ctrl->val & 0xff);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tw686x_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct tw686x_dev *dev = vc->dev;\r\nf->fmt.pix.width = vc->width;\r\nf->fmt.pix.height = vc->height;\r\nf->fmt.pix.field = dev->dma_ops->field;\r\nf->fmt.pix.pixelformat = vc->format->fourcc;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * vc->format->depth) / 8;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int tw686x_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct tw686x_dev *dev = vc->dev;\r\nunsigned int video_height = TW686X_VIDEO_HEIGHT(vc->video_standard);\r\nconst struct tw686x_format *format;\r\nformat = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (!format) {\r\nformat = &formats[0];\r\nf->fmt.pix.pixelformat = format->fourcc;\r\n}\r\nif (f->fmt.pix.width <= TW686X_VIDEO_WIDTH / 2)\r\nf->fmt.pix.width = TW686X_VIDEO_WIDTH / 2;\r\nelse\r\nf->fmt.pix.width = TW686X_VIDEO_WIDTH;\r\nif (f->fmt.pix.height <= video_height / 2)\r\nf->fmt.pix.height = video_height / 2;\r\nelse\r\nf->fmt.pix.height = video_height;\r\nf->fmt.pix.bytesperline = (f->fmt.pix.width * format->depth) / 8;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.field = dev->dma_ops->field;\r\nreturn 0;\r\n}\r\nstatic int tw686x_set_format(struct tw686x_video_channel *vc,\r\nunsigned int pixelformat, unsigned int width,\r\nunsigned int height, bool realloc)\r\n{\r\nstruct tw686x_dev *dev = vc->dev;\r\nu32 val, dma_width, dma_height, dma_line_width;\r\nint err, pb;\r\nvc->format = format_by_fourcc(pixelformat);\r\nvc->width = width;\r\nvc->height = height;\r\nif (dev->dma_ops->alloc && realloc) {\r\nfor (pb = 0; pb < 2; pb++)\r\ndev->dma_ops->free(vc, pb);\r\nfor (pb = 0; pb < 2; pb++) {\r\nerr = dev->dma_ops->alloc(vc, pb);\r\nif (err) {\r\nif (pb > 0)\r\ndev->dma_ops->free(vc, 0);\r\nreturn err;\r\n}\r\n}\r\n}\r\nval = reg_read(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch]);\r\nif (vc->width <= TW686X_VIDEO_WIDTH / 2)\r\nval |= BIT(23);\r\nelse\r\nval &= ~BIT(23);\r\nif (vc->height <= TW686X_VIDEO_HEIGHT(vc->video_standard) / 2)\r\nval |= BIT(24);\r\nelse\r\nval &= ~BIT(24);\r\nval &= ~0x7ffff;\r\nif (dev->dma_mode == TW686X_DMA_MODE_SG) {\r\nu32 start_idx, end_idx;\r\nstart_idx = is_second_gen(dev) ?\r\n0 : vc->ch * TW686X_MAX_SG_DESC_COUNT;\r\nend_idx = start_idx + TW686X_MAX_SG_DESC_COUNT - 1;\r\nval |= (end_idx << 10) | start_idx;\r\n}\r\nval &= ~(0x7 << 20);\r\nval |= vc->format->mode << 20;\r\nreg_write(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch], val);\r\ndma_width = (vc->width * 2) & 0x7ff;\r\ndma_height = vc->height / 2;\r\ndma_line_width = (vc->width * 2) & 0x7ff;\r\nval = (dma_height << 22) | (dma_line_width << 11) | dma_width;\r\nreg_write(vc->dev, VDMA_WHP[vc->ch], val);\r\nreturn 0;\r\n}\r\nstatic int tw686x_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nunsigned long area;\r\nbool realloc;\r\nint err;\r\nif (vb2_is_busy(&vc->vidq))\r\nreturn -EBUSY;\r\narea = vc->width * vc->height;\r\nerr = tw686x_try_fmt_vid_cap(file, priv, f);\r\nif (err)\r\nreturn err;\r\nrealloc = area != (f->fmt.pix.width * f->fmt.pix.height);\r\nreturn tw686x_set_format(vc, f->fmt.pix.pixelformat,\r\nf->fmt.pix.width, f->fmt.pix.height,\r\nrealloc);\r\n}\r\nstatic int tw686x_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct tw686x_dev *dev = vc->dev;\r\nstrlcpy(cap->driver, "tw686x", sizeof(cap->driver));\r\nstrlcpy(cap->card, dev->name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"PCI:%s", pci_name(dev->pci_dev));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int tw686x_set_standard(struct tw686x_video_channel *vc, v4l2_std_id id)\r\n{\r\nu32 val;\r\nif (id & V4L2_STD_NTSC)\r\nval = 0;\r\nelse if (id & V4L2_STD_PAL)\r\nval = 1;\r\nelse if (id & V4L2_STD_SECAM)\r\nval = 2;\r\nelse if (id & V4L2_STD_NTSC_443)\r\nval = 3;\r\nelse if (id & V4L2_STD_PAL_M)\r\nval = 4;\r\nelse if (id & V4L2_STD_PAL_Nc)\r\nval = 5;\r\nelse if (id & V4L2_STD_PAL_60)\r\nval = 6;\r\nelse\r\nreturn -EINVAL;\r\nvc->video_standard = id;\r\nreg_write(vc->dev, SDT[vc->ch], val);\r\nval = reg_read(vc->dev, VIDEO_CONTROL1);\r\nif (id & V4L2_STD_525_60)\r\nval &= ~(1 << (SYS_MODE_DMA_SHIFT + vc->ch));\r\nelse\r\nval |= (1 << (SYS_MODE_DMA_SHIFT + vc->ch));\r\nreg_write(vc->dev, VIDEO_CONTROL1, val);\r\nreturn 0;\r\n}\r\nstatic int tw686x_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct v4l2_format f;\r\nint ret;\r\nif (vc->video_standard == id)\r\nreturn 0;\r\nif (vb2_is_busy(&vc->vidq))\r\nreturn -EBUSY;\r\nret = tw686x_set_standard(vc, id);\r\nif (ret)\r\nreturn ret;\r\ntw686x_g_fmt_vid_cap(file, priv, &f);\r\ntw686x_s_fmt_vid_cap(file, priv, &f);\r\ntw686x_set_framerate(vc, vc->fps);\r\nreturn 0;\r\n}\r\nstatic int tw686x_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct tw686x_dev *dev = vc->dev;\r\nunsigned int old_std, detected_std = 0;\r\nunsigned long end;\r\nif (vb2_is_streaming(&vc->vidq))\r\nreturn -EBUSY;\r\nold_std = reg_read(dev, SDT[vc->ch]);\r\nreg_write(dev, SDT[vc->ch], 0x7);\r\nreg_write(dev, SDT_EN[vc->ch], 0xff);\r\nend = jiffies + msecs_to_jiffies(500);\r\nwhile (time_is_after_jiffies(end)) {\r\ndetected_std = reg_read(dev, SDT[vc->ch]);\r\nif (!(detected_std & BIT(7)))\r\nbreak;\r\nmsleep(100);\r\n}\r\nreg_write(dev, SDT[vc->ch], old_std);\r\nif (detected_std & BIT(7))\r\nreturn 0;\r\ndetected_std = (detected_std >> 4) & 0x7;\r\nswitch (detected_std) {\r\ncase TW686X_STD_NTSC_M:\r\n*std &= V4L2_STD_NTSC;\r\nbreak;\r\ncase TW686X_STD_NTSC_443:\r\n*std &= V4L2_STD_NTSC_443;\r\nbreak;\r\ncase TW686X_STD_PAL_M:\r\n*std &= V4L2_STD_PAL_M;\r\nbreak;\r\ncase TW686X_STD_PAL_60:\r\n*std &= V4L2_STD_PAL_60;\r\nbreak;\r\ncase TW686X_STD_PAL:\r\n*std &= V4L2_STD_PAL;\r\nbreak;\r\ncase TW686X_STD_PAL_CN:\r\n*std &= V4L2_STD_PAL_Nc;\r\nbreak;\r\ncase TW686X_STD_SECAM:\r\n*std &= V4L2_STD_SECAM;\r\nbreak;\r\ndefault:\r\n*std = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw686x_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\n*id = vc->video_standard;\r\nreturn 0;\r\n}\r\nstatic int tw686x_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nif (fsize->index)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfsize->stepwise.max_width = TW686X_VIDEO_WIDTH;\r\nfsize->stepwise.min_width = fsize->stepwise.max_width / 2;\r\nfsize->stepwise.step_width = fsize->stepwise.min_width;\r\nfsize->stepwise.max_height = TW686X_VIDEO_HEIGHT(vc->video_standard);\r\nfsize->stepwise.min_height = fsize->stepwise.max_height / 2;\r\nfsize->stepwise.step_height = fsize->stepwise.min_height;\r\nreturn 0;\r\n}\r\nstatic int tw686x_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *ival)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nint max_fps = TW686X_MAX_FPS(vc->video_standard);\r\nint max_rates = DIV_ROUND_UP(max_fps, 2);\r\nif (ival->index >= max_rates)\r\nreturn -EINVAL;\r\nival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nival->discrete.numerator = 1;\r\nif (ival->index < (max_rates - 1))\r\nival->discrete.denominator = (ival->index + 1) * 2;\r\nelse\r\nival->discrete.denominator = max_fps;\r\nreturn 0;\r\n}\r\nstatic int tw686x_g_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\nif (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp->parm.capture.readbuffers = 3;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = 1;\r\ncp->timeperframe.denominator = vc->fps;\r\nreturn 0;\r\n}\r\nstatic int tw686x_s_parm(struct file *file, void *priv,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\nunsigned int denominator = cp->timeperframe.denominator;\r\nunsigned int numerator = cp->timeperframe.numerator;\r\nunsigned int fps;\r\nif (vb2_is_busy(&vc->vidq))\r\nreturn -EBUSY;\r\nfps = (!numerator || !denominator) ? 0 : denominator / numerator;\r\nif (vc->fps != fps)\r\ntw686x_set_framerate(vc, fps);\r\nreturn tw686x_g_parm(file, priv, sp);\r\n}\r\nstatic int tw686x_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic void tw686x_set_input(struct tw686x_video_channel *vc, unsigned int i)\r\n{\r\nu32 val;\r\nvc->input = i;\r\nval = reg_read(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch]);\r\nval &= ~(0x3 << 30);\r\nval |= i << 30;\r\nreg_write(vc->dev, VDMA_CHANNEL_CONFIG[vc->ch], val);\r\n}\r\nstatic int tw686x_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nif (i >= TW686X_INPUTS_PER_CH)\r\nreturn -EINVAL;\r\nif (i == vc->input)\r\nreturn 0;\r\nif (vb2_is_busy(&vc->vidq))\r\nreturn -EBUSY;\r\ntw686x_set_input(vc, i);\r\nreturn 0;\r\n}\r\nstatic int tw686x_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\n*i = vc->input;\r\nreturn 0;\r\n}\r\nstatic int tw686x_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct tw686x_video_channel *vc = video_drvdata(file);\r\nunsigned int vidstat;\r\nif (i->index >= TW686X_INPUTS_PER_CH)\r\nreturn -EINVAL;\r\nsnprintf(i->name, sizeof(i->name), "Composite%d", i->index);\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->std = vc->device->tvnorms;\r\ni->capabilities = V4L2_IN_CAP_STD;\r\nvidstat = reg_read(vc->dev, VIDSTAT[vc->ch]);\r\ni->status = 0;\r\nif (vidstat & TW686X_VIDSTAT_VDLOSS)\r\ni->status |= V4L2_IN_ST_NO_SIGNAL;\r\nif (!(vidstat & TW686X_VIDSTAT_HLOCK))\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\nreturn 0;\r\n}\r\nvoid tw686x_video_irq(struct tw686x_dev *dev, unsigned long requests,\r\nunsigned int pb_status, unsigned int fifo_status,\r\nunsigned int *reset_ch)\r\n{\r\nstruct tw686x_video_channel *vc;\r\nunsigned long flags;\r\nunsigned int ch, pb;\r\nfor_each_set_bit(ch, &requests, max_channels(dev)) {\r\nvc = &dev->video_channels[ch];\r\nif (vc->no_signal && !(fifo_status & BIT(ch))) {\r\nv4l2_printk(KERN_DEBUG, &dev->v4l2_dev,\r\n"video%d: signal recovered\n", vc->num);\r\nvc->no_signal = false;\r\n*reset_ch |= BIT(ch);\r\nvc->pb = 0;\r\ncontinue;\r\n}\r\nvc->no_signal = !!(fifo_status & BIT(ch));\r\nif (!vc->no_signal) {\r\nu32 fifo_ov, fifo_bad;\r\nfifo_ov = (fifo_status >> 24) & BIT(ch);\r\nfifo_bad = (fifo_status >> 16) & BIT(ch);\r\nif (fifo_ov || fifo_bad) {\r\nv4l2_printk(KERN_DEBUG, &dev->v4l2_dev,\r\n"video%d: FIFO error\n", vc->num);\r\n*reset_ch |= BIT(ch);\r\nvc->pb = 0;\r\ncontinue;\r\n}\r\n}\r\npb = !!(pb_status & BIT(ch));\r\nif (vc->pb != pb) {\r\nv4l2_printk(KERN_DEBUG, &dev->v4l2_dev,\r\n"video%d: unexpected p-b buffer!\n",\r\nvc->num);\r\n*reset_ch |= BIT(ch);\r\nvc->pb = 0;\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&vc->qlock, flags);\r\ntw686x_buf_done(vc, pb);\r\ndev->dma_ops->buf_refill(vc, pb);\r\nspin_unlock_irqrestore(&vc->qlock, flags);\r\n}\r\n}\r\nvoid tw686x_video_free(struct tw686x_dev *dev)\r\n{\r\nunsigned int ch, pb;\r\nfor (ch = 0; ch < max_channels(dev); ch++) {\r\nstruct tw686x_video_channel *vc = &dev->video_channels[ch];\r\nvideo_unregister_device(vc->device);\r\nif (dev->dma_ops->free)\r\nfor (pb = 0; pb < 2; pb++)\r\ndev->dma_ops->free(vc, pb);\r\n}\r\n}\r\nint tw686x_video_init(struct tw686x_dev *dev)\r\n{\r\nunsigned int ch, val;\r\nint err;\r\nif (dev->dma_mode == TW686X_DMA_MODE_MEMCPY)\r\ndev->dma_ops = &memcpy_dma_ops;\r\nelse if (dev->dma_mode == TW686X_DMA_MODE_CONTIG)\r\ndev->dma_ops = &contig_dma_ops;\r\nelse if (dev->dma_mode == TW686X_DMA_MODE_SG)\r\ndev->dma_ops = &sg_dma_ops;\r\nelse\r\nreturn -EINVAL;\r\nerr = v4l2_device_register(&dev->pci_dev->dev, &dev->v4l2_dev);\r\nif (err)\r\nreturn err;\r\nif (dev->dma_ops->setup) {\r\nerr = dev->dma_ops->setup(dev);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (ch = 0; ch < max_channels(dev); ch++) {\r\nstruct tw686x_video_channel *vc = &dev->video_channels[ch];\r\nstruct video_device *vdev;\r\nmutex_init(&vc->vb_mutex);\r\nspin_lock_init(&vc->qlock);\r\nINIT_LIST_HEAD(&vc->vidq_queued);\r\nvc->dev = dev;\r\nvc->ch = ch;\r\nerr = tw686x_set_standard(vc, V4L2_STD_NTSC);\r\nif (err)\r\ngoto error;\r\nerr = tw686x_set_format(vc, formats[0].fourcc,\r\nTW686X_VIDEO_WIDTH,\r\nTW686X_VIDEO_HEIGHT(vc->video_standard),\r\ntrue);\r\nif (err)\r\ngoto error;\r\ntw686x_set_input(vc, 0);\r\ntw686x_set_framerate(vc, 30);\r\nreg_write(dev, VDELAY_LO[ch], 0x14);\r\nreg_write(dev, HACTIVE_LO[ch], 0xd0);\r\nreg_write(dev, VIDEO_SIZE[ch], 0);\r\nvc->vidq.io_modes = VB2_READ | VB2_MMAP | VB2_DMABUF;\r\nvc->vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvc->vidq.drv_priv = vc;\r\nvc->vidq.buf_struct_size = sizeof(struct tw686x_v4l2_buf);\r\nvc->vidq.ops = &tw686x_video_qops;\r\nvc->vidq.mem_ops = dev->dma_ops->mem_ops;\r\nvc->vidq.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nvc->vidq.min_buffers_needed = 2;\r\nvc->vidq.lock = &vc->vb_mutex;\r\nvc->vidq.gfp_flags = GFP_DMA32;\r\nvc->vidq.dev = &dev->pci_dev->dev;\r\nerr = vb2_queue_init(&vc->vidq);\r\nif (err) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"dma%d: cannot init vb2 queue\n", ch);\r\ngoto error;\r\n}\r\nerr = v4l2_ctrl_handler_init(&vc->ctrl_handler, 4);\r\nif (err) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"dma%d: cannot init ctrl handler\n", ch);\r\ngoto error;\r\n}\r\nv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 100);\r\nv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&vc->ctrl_handler, &ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nerr = vc->ctrl_handler.error;\r\nif (err)\r\ngoto error;\r\nerr = v4l2_ctrl_handler_setup(&vc->ctrl_handler);\r\nif (err)\r\ngoto error;\r\nvdev = video_device_alloc();\r\nif (!vdev) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"dma%d: unable to allocate device\n", ch);\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nsnprintf(vdev->name, sizeof(vdev->name), "%s video", dev->name);\r\nvdev->fops = &tw686x_video_fops;\r\nvdev->ioctl_ops = &tw686x_video_ioctl_ops;\r\nvdev->release = video_device_release;\r\nvdev->v4l2_dev = &dev->v4l2_dev;\r\nvdev->queue = &vc->vidq;\r\nvdev->tvnorms = V4L2_STD_525_60 | V4L2_STD_625_50;\r\nvdev->minor = -1;\r\nvdev->lock = &vc->vb_mutex;\r\nvdev->ctrl_handler = &vc->ctrl_handler;\r\nvc->device = vdev;\r\nvideo_set_drvdata(vdev, vc);\r\nerr = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (err < 0)\r\ngoto error;\r\nvc->num = vdev->num;\r\n}\r\nval = TW686X_DEF_PHASE_REF;\r\nfor (ch = 0; ch < max_channels(dev); ch++)\r\nval |= dev->dma_ops->hw_dma_mode << (16 + ch * 2);\r\nreg_write(dev, PHASE_REF, val);\r\nreg_write(dev, MISC2[0], 0xe7);\r\nreg_write(dev, VCTRL1[0], 0xcc);\r\nreg_write(dev, LOOP[0], 0xa5);\r\nif (max_channels(dev) > 4) {\r\nreg_write(dev, VCTRL1[1], 0xcc);\r\nreg_write(dev, LOOP[1], 0xa5);\r\nreg_write(dev, MISC2[1], 0xe7);\r\n}\r\nreturn 0;\r\nerror:\r\ntw686x_video_free(dev);\r\nreturn err;\r\n}
