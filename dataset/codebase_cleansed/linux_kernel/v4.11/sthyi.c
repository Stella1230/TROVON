static inline u64 cpu_id(u8 ctidx, void *diag224_buf)\r\n{\r\nreturn *((u64 *)(diag224_buf + (ctidx + 1) * DIAG204_CPU_NAME_LEN));\r\n}\r\nstatic u32 scale_cap(u32 in)\r\n{\r\nreturn (0x10000 * in) / 100;\r\n}\r\nstatic void fill_hdr(struct sthyi_sctns *sctns)\r\n{\r\nsctns->hdr.infhdln = sizeof(sctns->hdr);\r\nsctns->hdr.infmoff = sizeof(sctns->hdr);\r\nsctns->hdr.infmlen = sizeof(sctns->mac);\r\nsctns->hdr.infplen = sizeof(sctns->par);\r\nsctns->hdr.infpoff = sctns->hdr.infhdln + sctns->hdr.infmlen;\r\nsctns->hdr.infhtotl = sctns->hdr.infpoff + sctns->hdr.infplen;\r\n}\r\nstatic void fill_stsi_mac(struct sthyi_sctns *sctns,\r\nstruct sysinfo_1_1_1 *sysinfo)\r\n{\r\nif (stsi(sysinfo, 1, 1, 1))\r\nreturn;\r\nsclp_ocf_cpc_name_copy(sctns->mac.infmname);\r\nmemcpy(sctns->mac.infmtype, sysinfo->type, sizeof(sctns->mac.infmtype));\r\nmemcpy(sctns->mac.infmmanu, sysinfo->manufacturer, sizeof(sctns->mac.infmmanu));\r\nmemcpy(sctns->mac.infmpman, sysinfo->plant, sizeof(sctns->mac.infmpman));\r\nmemcpy(sctns->mac.infmseq, sysinfo->sequence, sizeof(sctns->mac.infmseq));\r\nsctns->mac.infmval1 |= MAC_ID_VLD | MAC_NAME_VLD;\r\n}\r\nstatic void fill_stsi_par(struct sthyi_sctns *sctns,\r\nstruct sysinfo_2_2_2 *sysinfo)\r\n{\r\nif (stsi(sysinfo, 2, 2, 2))\r\nreturn;\r\nsctns->par.infppnum = sysinfo->lpar_number;\r\nmemcpy(sctns->par.infppnam, sysinfo->name, sizeof(sctns->par.infppnam));\r\nsctns->par.infpval1 |= PAR_ID_VLD;\r\n}\r\nstatic void fill_stsi(struct sthyi_sctns *sctns)\r\n{\r\nvoid *sysinfo;\r\nsysinfo = (void *)__get_free_page(GFP_KERNEL);\r\nif (!sysinfo)\r\nreturn;\r\nfill_stsi_mac(sctns, sysinfo);\r\nfill_stsi_par(sctns, sysinfo);\r\nfree_pages((unsigned long)sysinfo, 0);\r\n}\r\nstatic void fill_diag_mac(struct sthyi_sctns *sctns,\r\nstruct diag204_x_phys_block *block,\r\nvoid *diag224_buf)\r\n{\r\nint i;\r\nfor (i = 0; i < block->hdr.cpus; i++) {\r\nswitch (cpu_id(block->cpus[i].ctidx, diag224_buf)) {\r\ncase CP:\r\nif (block->cpus[i].weight == DED_WEIGHT)\r\nsctns->mac.infmdcps++;\r\nelse\r\nsctns->mac.infmscps++;\r\nbreak;\r\ncase IFL:\r\nif (block->cpus[i].weight == DED_WEIGHT)\r\nsctns->mac.infmdifl++;\r\nelse\r\nsctns->mac.infmsifl++;\r\nbreak;\r\n}\r\n}\r\nsctns->mac.infmval1 |= MAC_CNT_VLD;\r\n}\r\nstatic struct diag204_x_part_block *lpar_cpu_inf(struct lpar_cpu_inf *part_inf,\r\nbool this_lpar,\r\nvoid *diag224_buf,\r\nstruct diag204_x_part_block *block)\r\n{\r\nint i, capped = 0, weight_cp = 0, weight_ifl = 0;\r\nstruct cpu_inf *cpu_inf;\r\nfor (i = 0; i < block->hdr.rcpus; i++) {\r\nif (!(block->cpus[i].cflag & DIAG204_CPU_ONLINE))\r\ncontinue;\r\nswitch (cpu_id(block->cpus[i].ctidx, diag224_buf)) {\r\ncase CP:\r\ncpu_inf = &part_inf->cp;\r\nif (block->cpus[i].cur_weight < DED_WEIGHT)\r\nweight_cp |= block->cpus[i].cur_weight;\r\nbreak;\r\ncase IFL:\r\ncpu_inf = &part_inf->ifl;\r\nif (block->cpus[i].cur_weight < DED_WEIGHT)\r\nweight_ifl |= block->cpus[i].cur_weight;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (!this_lpar)\r\ncontinue;\r\ncapped |= block->cpus[i].cflag & DIAG204_CPU_CAPPED;\r\ncpu_inf->lpar_cap |= block->cpus[i].cpu_type_cap;\r\ncpu_inf->lpar_grp_cap |= block->cpus[i].group_cpu_type_cap;\r\nif (block->cpus[i].weight == DED_WEIGHT)\r\ncpu_inf->cpu_num_ded += 1;\r\nelse\r\ncpu_inf->cpu_num_shd += 1;\r\n}\r\nif (this_lpar && capped) {\r\npart_inf->cp.lpar_weight = weight_cp;\r\npart_inf->ifl.lpar_weight = weight_ifl;\r\n}\r\npart_inf->cp.all_weight += weight_cp;\r\npart_inf->ifl.all_weight += weight_ifl;\r\nreturn (struct diag204_x_part_block *)&block->cpus[i];\r\n}\r\nstatic void fill_diag(struct sthyi_sctns *sctns)\r\n{\r\nint i, r, pages;\r\nbool this_lpar;\r\nvoid *diag204_buf;\r\nvoid *diag224_buf = NULL;\r\nstruct diag204_x_info_blk_hdr *ti_hdr;\r\nstruct diag204_x_part_block *part_block;\r\nstruct diag204_x_phys_block *phys_block;\r\nstruct lpar_cpu_inf lpar_inf = {};\r\npages = diag204((unsigned long)DIAG204_SUBC_RSI |\r\n(unsigned long)DIAG204_INFO_EXT, 0, NULL);\r\nif (pages <= 0)\r\nreturn;\r\ndiag204_buf = vmalloc(PAGE_SIZE * pages);\r\nif (!diag204_buf)\r\nreturn;\r\nr = diag204((unsigned long)DIAG204_SUBC_STIB7 |\r\n(unsigned long)DIAG204_INFO_EXT, pages, diag204_buf);\r\nif (r < 0)\r\ngoto out;\r\ndiag224_buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!diag224_buf || diag224(diag224_buf))\r\ngoto out;\r\nti_hdr = diag204_buf;\r\npart_block = diag204_buf + sizeof(*ti_hdr);\r\nfor (i = 0; i < ti_hdr->npar; i++) {\r\nthis_lpar = (void *)part_block - diag204_buf == ti_hdr->this_part;\r\npart_block = lpar_cpu_inf(&lpar_inf, this_lpar, diag224_buf,\r\npart_block);\r\n}\r\nphys_block = (struct diag204_x_phys_block *)part_block;\r\npart_block = diag204_buf + ti_hdr->this_part;\r\nif (part_block->hdr.mtid)\r\nsctns->par.infpflg1 = PAR_MT_EN;\r\nsctns->par.infpval1 |= PAR_GRP_VLD;\r\nsctns->par.infplgcp = scale_cap(lpar_inf.cp.lpar_grp_cap);\r\nsctns->par.infplgif = scale_cap(lpar_inf.ifl.lpar_grp_cap);\r\nmemcpy(sctns->par.infplgnm, part_block->hdr.hardware_group_name,\r\nsizeof(sctns->par.infplgnm));\r\nsctns->par.infpscps = lpar_inf.cp.cpu_num_shd;\r\nsctns->par.infpdcps = lpar_inf.cp.cpu_num_ded;\r\nsctns->par.infpsifl = lpar_inf.ifl.cpu_num_shd;\r\nsctns->par.infpdifl = lpar_inf.ifl.cpu_num_ded;\r\nsctns->par.infpval1 |= PAR_PCNT_VLD;\r\nsctns->par.infpabcp = scale_cap(lpar_inf.cp.lpar_cap);\r\nsctns->par.infpabif = scale_cap(lpar_inf.ifl.lpar_cap);\r\nsctns->par.infpval1 |= PAR_ABS_VLD;\r\nif (!(ti_hdr->flags & DIAG204_LPAR_PHYS_FLG)) {\r\nsctns->hdr.infhflg1 |= HDR_PERF_UNAV;\r\ngoto out;\r\n}\r\nfill_diag_mac(sctns, phys_block, diag224_buf);\r\nif (lpar_inf.cp.lpar_weight) {\r\nsctns->par.infpwbcp = sctns->mac.infmscps * 0x10000 *\r\nlpar_inf.cp.lpar_weight / lpar_inf.cp.all_weight;\r\n}\r\nif (lpar_inf.ifl.lpar_weight) {\r\nsctns->par.infpwbif = sctns->mac.infmsifl * 0x10000 *\r\nlpar_inf.ifl.lpar_weight / lpar_inf.ifl.all_weight;\r\n}\r\nsctns->par.infpval1 |= PAR_WGHT_VLD;\r\nout:\r\nfree_page((unsigned long)diag224_buf);\r\nvfree(diag204_buf);\r\n}\r\nstatic int sthyi(u64 vaddr)\r\n{\r\nregister u64 code asm("0") = 0;\r\nregister u64 addr asm("2") = vaddr;\r\nint cc;\r\nasm volatile(\r\n".insn rre,0xB2560000,%[code],%[addr]\n"\r\n"ipm %[cc]\n"\r\n"srl %[cc],28\n"\r\n: [cc] "=d" (cc)\r\n: [code] "d" (code), [addr] "a" (addr)\r\n: "memory", "cc");\r\nreturn cc;\r\n}\r\nint handle_sthyi(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1, reg2, r = 0;\r\nu64 code, addr, cc = 0;\r\nstruct sthyi_sctns *sctns = NULL;\r\nif (!__ratelimit(&vcpu->kvm->arch.sthyi_limit)) {\r\nkvm_s390_retry_instr(vcpu);\r\nreturn 0;\r\n}\r\nkvm_s390_get_regs_rre(vcpu, &reg1, &reg2);\r\ncode = vcpu->run->s.regs.gprs[reg1];\r\naddr = vcpu->run->s.regs.gprs[reg2];\r\nvcpu->stat.instruction_sthyi++;\r\nVCPU_EVENT(vcpu, 3, "STHYI: fc: %llu addr: 0x%016llx", code, addr);\r\ntrace_kvm_s390_handle_sthyi(vcpu, code, addr);\r\nif (reg1 == reg2 || reg1 & 1 || reg2 & 1 || addr & ~PAGE_MASK)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nif (code & 0xffff) {\r\ncc = 3;\r\ngoto out;\r\n}\r\nr = write_guest(vcpu, addr, reg2, &cc, 1);\r\nif (r)\r\nreturn kvm_s390_inject_prog_cond(vcpu, r);\r\nsctns = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!sctns)\r\nreturn -ENOMEM;\r\nif (test_facility(74)) {\r\ncc = sthyi((u64)sctns);\r\ngoto out;\r\n}\r\nfill_hdr(sctns);\r\nfill_stsi(sctns);\r\nfill_diag(sctns);\r\nout:\r\nif (!cc) {\r\nr = write_guest(vcpu, addr, reg2, sctns, PAGE_SIZE);\r\nif (r) {\r\nfree_page((unsigned long)sctns);\r\nreturn kvm_s390_inject_prog_cond(vcpu, r);\r\n}\r\n}\r\nfree_page((unsigned long)sctns);\r\nvcpu->run->s.regs.gprs[reg2 + 1] = cc ? 4 : 0;\r\nkvm_s390_set_psw_cc(vcpu, cc);\r\nreturn r;\r\n}
