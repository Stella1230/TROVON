static struct ip_tunnel *ipip6_tunnel_lookup(struct net *net,\r\nstruct net_device *dev, __be32 remote, __be32 local)\r\n{\r\nunsigned int h0 = HASH(remote);\r\nunsigned int h1 = HASH(local);\r\nstruct ip_tunnel *t;\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nfor_each_ip_tunnel_rcu(t, sitn->tunnels_r_l[h0 ^ h1]) {\r\nif (local == t->parms.iph.saddr &&\r\nremote == t->parms.iph.daddr &&\r\n(!dev || !t->parms.link || dev->ifindex == t->parms.link) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nfor_each_ip_tunnel_rcu(t, sitn->tunnels_r[h0]) {\r\nif (remote == t->parms.iph.daddr &&\r\n(!dev || !t->parms.link || dev->ifindex == t->parms.link) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nfor_each_ip_tunnel_rcu(t, sitn->tunnels_l[h1]) {\r\nif (local == t->parms.iph.saddr &&\r\n(!dev || !t->parms.link || dev->ifindex == t->parms.link) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nt = rcu_dereference(sitn->tunnels_wc[0]);\r\nif (t && (t->dev->flags & IFF_UP))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic struct ip_tunnel __rcu **__ipip6_bucket(struct sit_net *sitn,\r\nstruct ip_tunnel_parm *parms)\r\n{\r\n__be32 remote = parms->iph.daddr;\r\n__be32 local = parms->iph.saddr;\r\nunsigned int h = 0;\r\nint prio = 0;\r\nif (remote) {\r\nprio |= 2;\r\nh ^= HASH(remote);\r\n}\r\nif (local) {\r\nprio |= 1;\r\nh ^= HASH(local);\r\n}\r\nreturn &sitn->tunnels[prio][h];\r\n}\r\nstatic inline struct ip_tunnel __rcu **ipip6_bucket(struct sit_net *sitn,\r\nstruct ip_tunnel *t)\r\n{\r\nreturn __ipip6_bucket(sitn, &t->parms);\r\n}\r\nstatic void ipip6_tunnel_unlink(struct sit_net *sitn, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel __rcu **tp;\r\nstruct ip_tunnel *iter;\r\nfor (tp = ipip6_bucket(sitn, t);\r\n(iter = rtnl_dereference(*tp)) != NULL;\r\ntp = &iter->next) {\r\nif (t == iter) {\r\nrcu_assign_pointer(*tp, t->next);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ipip6_tunnel_link(struct sit_net *sitn, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel __rcu **tp = ipip6_bucket(sitn, t);\r\nrcu_assign_pointer(t->next, rtnl_dereference(*tp));\r\nrcu_assign_pointer(*tp, t);\r\n}\r\nstatic void ipip6_tunnel_clone_6rd(struct net_device *dev, struct sit_net *sitn)\r\n{\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nif (t->dev == sitn->fb_tunnel_dev) {\r\nipv6_addr_set(&t->ip6rd.prefix, htonl(0x20020000), 0, 0, 0);\r\nt->ip6rd.relay_prefix = 0;\r\nt->ip6rd.prefixlen = 16;\r\nt->ip6rd.relay_prefixlen = 0;\r\n} else {\r\nstruct ip_tunnel *t0 = netdev_priv(sitn->fb_tunnel_dev);\r\nmemcpy(&t->ip6rd, &t0->ip6rd, sizeof(t->ip6rd));\r\n}\r\n#endif\r\n}\r\nstatic int ipip6_tunnel_create(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct net *net = dev_net(dev);\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nint err;\r\nmemcpy(dev->dev_addr, &t->parms.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &t->parms.iph.daddr, 4);\r\nif ((__force u16)t->parms.i_flags & SIT_ISATAP)\r\ndev->priv_flags |= IFF_ISATAP;\r\ndev->rtnl_link_ops = &sit_link_ops;\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto out;\r\nipip6_tunnel_clone_6rd(dev, sitn);\r\ndev_hold(dev);\r\nipip6_tunnel_link(sitn, t);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic struct ip_tunnel *ipip6_tunnel_locate(struct net *net,\r\nstruct ip_tunnel_parm *parms, int create)\r\n{\r\n__be32 remote = parms->iph.daddr;\r\n__be32 local = parms->iph.saddr;\r\nstruct ip_tunnel *t, *nt;\r\nstruct ip_tunnel __rcu **tp;\r\nstruct net_device *dev;\r\nchar name[IFNAMSIZ];\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nfor (tp = __ipip6_bucket(sitn, parms);\r\n(t = rtnl_dereference(*tp)) != NULL;\r\ntp = &t->next) {\r\nif (local == t->parms.iph.saddr &&\r\nremote == t->parms.iph.daddr &&\r\nparms->link == t->parms.link) {\r\nif (create)\r\nreturn NULL;\r\nelse\r\nreturn t;\r\n}\r\n}\r\nif (!create)\r\ngoto failed;\r\nif (parms->name[0])\r\nstrlcpy(name, parms->name, IFNAMSIZ);\r\nelse\r\nstrcpy(name, "sit%d");\r\ndev = alloc_netdev(sizeof(*t), name, NET_NAME_UNKNOWN,\r\nipip6_tunnel_setup);\r\nif (!dev)\r\nreturn NULL;\r\ndev_net_set(dev, net);\r\nnt = netdev_priv(dev);\r\nnt->parms = *parms;\r\nif (ipip6_tunnel_create(dev) < 0)\r\ngoto failed_free;\r\nreturn nt;\r\nfailed_free:\r\nipip6_dev_free(dev);\r\nfailed:\r\nreturn NULL;\r\n}\r\nstatic struct ip_tunnel_prl_entry *\r\n__ipip6_tunnel_locate_prl(struct ip_tunnel *t, __be32 addr)\r\n{\r\nstruct ip_tunnel_prl_entry *prl;\r\nfor_each_prl_rcu(t->prl)\r\nif (prl->addr == addr)\r\nbreak;\r\nreturn prl;\r\n}\r\nstatic int ipip6_tunnel_get_prl(struct ip_tunnel *t,\r\nstruct ip_tunnel_prl __user *a)\r\n{\r\nstruct ip_tunnel_prl kprl, *kp;\r\nstruct ip_tunnel_prl_entry *prl;\r\nunsigned int cmax, c = 0, ca, len;\r\nint ret = 0;\r\nif (copy_from_user(&kprl, a, sizeof(kprl)))\r\nreturn -EFAULT;\r\ncmax = kprl.datalen / sizeof(kprl);\r\nif (cmax > 1 && kprl.addr != htonl(INADDR_ANY))\r\ncmax = 1;\r\nkp = (cmax <= 1 || capable(CAP_NET_ADMIN)) ?\r\nkcalloc(cmax, sizeof(*kp), GFP_KERNEL) :\r\nNULL;\r\nrcu_read_lock();\r\nca = t->prl_count < cmax ? t->prl_count : cmax;\r\nif (!kp) {\r\nkp = kcalloc(ca, sizeof(*kp), GFP_ATOMIC);\r\nif (!kp) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nc = 0;\r\nfor_each_prl_rcu(t->prl) {\r\nif (c >= cmax)\r\nbreak;\r\nif (kprl.addr != htonl(INADDR_ANY) && prl->addr != kprl.addr)\r\ncontinue;\r\nkp[c].addr = prl->addr;\r\nkp[c].flags = prl->flags;\r\nc++;\r\nif (kprl.addr != htonl(INADDR_ANY))\r\nbreak;\r\n}\r\nout:\r\nrcu_read_unlock();\r\nlen = sizeof(*kp) * c;\r\nret = 0;\r\nif ((len && copy_to_user(a + 1, kp, len)) || put_user(len, &a->datalen))\r\nret = -EFAULT;\r\nkfree(kp);\r\nreturn ret;\r\n}\r\nstatic int\r\nipip6_tunnel_add_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a, int chg)\r\n{\r\nstruct ip_tunnel_prl_entry *p;\r\nint err = 0;\r\nif (a->addr == htonl(INADDR_ANY))\r\nreturn -EINVAL;\r\nASSERT_RTNL();\r\nfor (p = rtnl_dereference(t->prl); p; p = rtnl_dereference(p->next)) {\r\nif (p->addr == a->addr) {\r\nif (chg) {\r\np->flags = a->flags;\r\ngoto out;\r\n}\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nif (chg) {\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\np = kzalloc(sizeof(struct ip_tunnel_prl_entry), GFP_KERNEL);\r\nif (!p) {\r\nerr = -ENOBUFS;\r\ngoto out;\r\n}\r\np->next = t->prl;\r\np->addr = a->addr;\r\np->flags = a->flags;\r\nt->prl_count++;\r\nrcu_assign_pointer(t->prl, p);\r\nout:\r\nreturn err;\r\n}\r\nstatic void prl_list_destroy_rcu(struct rcu_head *head)\r\n{\r\nstruct ip_tunnel_prl_entry *p, *n;\r\np = container_of(head, struct ip_tunnel_prl_entry, rcu_head);\r\ndo {\r\nn = rcu_dereference_protected(p->next, 1);\r\nkfree(p);\r\np = n;\r\n} while (p);\r\n}\r\nstatic int\r\nipip6_tunnel_del_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a)\r\n{\r\nstruct ip_tunnel_prl_entry *x;\r\nstruct ip_tunnel_prl_entry __rcu **p;\r\nint err = 0;\r\nASSERT_RTNL();\r\nif (a && a->addr != htonl(INADDR_ANY)) {\r\nfor (p = &t->prl;\r\n(x = rtnl_dereference(*p)) != NULL;\r\np = &x->next) {\r\nif (x->addr == a->addr) {\r\n*p = x->next;\r\nkfree_rcu(x, rcu_head);\r\nt->prl_count--;\r\ngoto out;\r\n}\r\n}\r\nerr = -ENXIO;\r\n} else {\r\nx = rtnl_dereference(t->prl);\r\nif (x) {\r\nt->prl_count = 0;\r\ncall_rcu(&x->rcu_head, prl_list_destroy_rcu);\r\nt->prl = NULL;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\nisatap_chksrc(struct sk_buff *skb, const struct iphdr *iph, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel_prl_entry *p;\r\nint ok = 1;\r\nrcu_read_lock();\r\np = __ipip6_tunnel_locate_prl(t, iph->saddr);\r\nif (p) {\r\nif (p->flags & PRL_DEFAULT)\r\nskb->ndisc_nodetype = NDISC_NODETYPE_DEFAULT;\r\nelse\r\nskb->ndisc_nodetype = NDISC_NODETYPE_NODEFAULT;\r\n} else {\r\nconst struct in6_addr *addr6 = &ipv6_hdr(skb)->saddr;\r\nif (ipv6_addr_is_isatap(addr6) &&\r\n(addr6->s6_addr32[3] == iph->saddr) &&\r\nipv6_chk_prefix(addr6, t->dev))\r\nskb->ndisc_nodetype = NDISC_NODETYPE_HOST;\r\nelse\r\nok = 0;\r\n}\r\nrcu_read_unlock();\r\nreturn ok;\r\n}\r\nstatic void ipip6_tunnel_uninit(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct sit_net *sitn = net_generic(tunnel->net, sit_net_id);\r\nif (dev == sitn->fb_tunnel_dev) {\r\nRCU_INIT_POINTER(sitn->tunnels_wc[0], NULL);\r\n} else {\r\nipip6_tunnel_unlink(sitn, tunnel);\r\nipip6_tunnel_del_prl(tunnel, NULL);\r\n}\r\ndst_cache_reset(&tunnel->dst_cache);\r\ndev_put(dev);\r\n}\r\nstatic int ipip6_err(struct sk_buff *skb, u32 info)\r\n{\r\nconst struct iphdr *iph = (const struct iphdr *)skb->data;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nunsigned int data_len = 0;\r\nstruct ip_tunnel *t;\r\nint err;\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_PARAMETERPROB:\r\nreturn 0;\r\ncase ICMP_DEST_UNREACH:\r\nswitch (code) {\r\ncase ICMP_SR_FAILED:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\nif (code != ICMP_EXC_TTL)\r\nreturn 0;\r\ndata_len = icmp_hdr(skb)->un.reserved[1] * 4;\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nbreak;\r\n}\r\nerr = -ENOENT;\r\nt = ipip6_tunnel_lookup(dev_net(skb->dev),\r\nskb->dev,\r\niph->daddr,\r\niph->saddr);\r\nif (!t)\r\ngoto out;\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\r\nipv4_update_pmtu(skb, dev_net(skb->dev), info,\r\nt->parms.link, 0, iph->protocol, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (type == ICMP_REDIRECT) {\r\nipv4_redirect(skb, dev_net(skb->dev), t->parms.link, 0,\r\niph->protocol, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = 0;\r\nif (!ip6_err_gen_icmpv6_unreach(skb, iph->ihl * 4, type, data_len))\r\ngoto out;\r\nif (t->parms.iph.daddr == 0)\r\ngoto out;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\ngoto out;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\nout:\r\nreturn err;\r\n}\r\nstatic inline bool is_spoofed_6rd(struct ip_tunnel *tunnel, const __be32 v4addr,\r\nconst struct in6_addr *v6addr)\r\n{\r\n__be32 v4embed = 0;\r\nif (check_6rd(tunnel, v6addr, &v4embed) && v4addr != v4embed)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool only_dnatted(const struct ip_tunnel *tunnel,\r\nconst struct in6_addr *v6dst)\r\n{\r\nint prefix_len;\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nprefix_len = tunnel->ip6rd.prefixlen + 32\r\n- tunnel->ip6rd.relay_prefixlen;\r\n#else\r\nprefix_len = 48;\r\n#endif\r\nreturn ipv6_chk_custom_prefix(v6dst, prefix_len, tunnel->dev);\r\n}\r\nstatic bool packet_is_spoofed(struct sk_buff *skb,\r\nconst struct iphdr *iph,\r\nstruct ip_tunnel *tunnel)\r\n{\r\nconst struct ipv6hdr *ipv6h;\r\nif (tunnel->dev->priv_flags & IFF_ISATAP) {\r\nif (!isatap_chksrc(skb, iph, tunnel))\r\nreturn true;\r\nreturn false;\r\n}\r\nif (tunnel->dev->flags & IFF_POINTOPOINT)\r\nreturn false;\r\nipv6h = ipv6_hdr(skb);\r\nif (unlikely(is_spoofed_6rd(tunnel, iph->saddr, &ipv6h->saddr))) {\r\nnet_warn_ratelimited("Src spoofed %pI4/%pI6c -> %pI4/%pI6c\n",\r\n&iph->saddr, &ipv6h->saddr,\r\n&iph->daddr, &ipv6h->daddr);\r\nreturn true;\r\n}\r\nif (likely(!is_spoofed_6rd(tunnel, iph->daddr, &ipv6h->daddr)))\r\nreturn false;\r\nif (only_dnatted(tunnel, &ipv6h->daddr))\r\nreturn false;\r\nnet_warn_ratelimited("Dst spoofed %pI4/%pI6c -> %pI4/%pI6c\n",\r\n&iph->saddr, &ipv6h->saddr,\r\n&iph->daddr, &ipv6h->daddr);\r\nreturn true;\r\n}\r\nstatic int ipip6_rcv(struct sk_buff *skb)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct ip_tunnel *tunnel;\r\nint err;\r\ntunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\r\niph->saddr, iph->daddr);\r\nif (tunnel) {\r\nstruct pcpu_sw_netstats *tstats;\r\nif (tunnel->parms.iph.protocol != IPPROTO_IPV6 &&\r\ntunnel->parms.iph.protocol != 0)\r\ngoto out;\r\nskb->mac_header = skb->network_header;\r\nskb_reset_network_header(skb);\r\nIPCB(skb)->flags = 0;\r\nskb->dev = tunnel->dev;\r\nif (packet_is_spoofed(skb, iph, tunnel)) {\r\ntunnel->dev->stats.rx_errors++;\r\ngoto out;\r\n}\r\nif (iptunnel_pull_header(skb, 0, htons(ETH_P_IPV6),\r\n!net_eq(tunnel->net, dev_net(tunnel->dev))))\r\ngoto out;\r\nerr = IP_ECN_decapsulate(iph, skb);\r\nif (unlikely(err)) {\r\nif (log_ecn_error)\r\nnet_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",\r\n&iph->saddr, iph->tos);\r\nif (err > 1) {\r\n++tunnel->dev->stats.rx_frame_errors;\r\n++tunnel->dev->stats.rx_errors;\r\ngoto out;\r\n}\r\n}\r\ntstats = this_cpu_ptr(tunnel->dev->tstats);\r\nu64_stats_update_begin(&tstats->syncp);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&tstats->syncp);\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nreturn 1;\r\nout:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int sit_tunnel_rcv(struct sk_buff *skb, u8 ipproto)\r\n{\r\nconst struct iphdr *iph;\r\nstruct ip_tunnel *tunnel;\r\niph = ip_hdr(skb);\r\ntunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\r\niph->saddr, iph->daddr);\r\nif (tunnel) {\r\nconst struct tnl_ptk_info *tpi;\r\nif (tunnel->parms.iph.protocol != ipproto &&\r\ntunnel->parms.iph.protocol != 0)\r\ngoto drop;\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto drop;\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nif (ipproto == IPPROTO_MPLS)\r\ntpi = &mplsip_tpi;\r\nelse\r\n#endif\r\ntpi = &ipip_tpi;\r\nif (iptunnel_pull_header(skb, 0, tpi->proto, false))\r\ngoto drop;\r\nreturn ip_tunnel_rcv(tunnel, skb, tpi, NULL, log_ecn_error);\r\n}\r\nreturn 1;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ipip_rcv(struct sk_buff *skb)\r\n{\r\nreturn sit_tunnel_rcv(skb, IPPROTO_IPIP);\r\n}\r\nstatic int mplsip_rcv(struct sk_buff *skb)\r\n{\r\nreturn sit_tunnel_rcv(skb, IPPROTO_MPLS);\r\n}\r\nstatic bool check_6rd(struct ip_tunnel *tunnel, const struct in6_addr *v6dst,\r\n__be32 *v4dst)\r\n{\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nif (ipv6_prefix_equal(v6dst, &tunnel->ip6rd.prefix,\r\ntunnel->ip6rd.prefixlen)) {\r\nunsigned int pbw0, pbi0;\r\nint pbi1;\r\nu32 d;\r\npbw0 = tunnel->ip6rd.prefixlen >> 5;\r\npbi0 = tunnel->ip6rd.prefixlen & 0x1f;\r\nd = (ntohl(v6dst->s6_addr32[pbw0]) << pbi0) >>\r\ntunnel->ip6rd.relay_prefixlen;\r\npbi1 = pbi0 - tunnel->ip6rd.relay_prefixlen;\r\nif (pbi1 > 0)\r\nd |= ntohl(v6dst->s6_addr32[pbw0 + 1]) >>\r\n(32 - pbi1);\r\n*v4dst = tunnel->ip6rd.relay_prefix | htonl(d);\r\nreturn true;\r\n}\r\n#else\r\nif (v6dst->s6_addr16[0] == htons(0x2002)) {\r\nmemcpy(v4dst, &v6dst->s6_addr16[1], 4);\r\nreturn true;\r\n}\r\n#endif\r\nreturn false;\r\n}\r\nstatic inline __be32 try_6rd(struct ip_tunnel *tunnel,\r\nconst struct in6_addr *v6dst)\r\n{\r\n__be32 dst = 0;\r\ncheck_6rd(tunnel, v6dst, &dst);\r\nreturn dst;\r\n}\r\nstatic netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nconst struct iphdr *tiph = &tunnel->parms.iph;\r\nconst struct ipv6hdr *iph6 = ipv6_hdr(skb);\r\nu8 tos = tunnel->parms.iph.tos;\r\n__be16 df = tiph->frag_off;\r\nstruct rtable *rt;\r\nstruct net_device *tdev;\r\nunsigned int max_headroom;\r\n__be32 dst = tiph->daddr;\r\nstruct flowi4 fl4;\r\nint mtu;\r\nconst struct in6_addr *addr6;\r\nint addr_type;\r\nu8 ttl;\r\nu8 protocol = IPPROTO_IPV6;\r\nint t_hlen = tunnel->hlen + sizeof(struct iphdr);\r\nif (tos == 1)\r\ntos = ipv6_get_dsfield(iph6);\r\nif (dev->priv_flags & IFF_ISATAP) {\r\nstruct neighbour *neigh = NULL;\r\nbool do_tx_error = false;\r\nif (skb_dst(skb))\r\nneigh = dst_neigh_lookup(skb_dst(skb), &iph6->daddr);\r\nif (!neigh) {\r\nnet_dbg_ratelimited("nexthop == NULL\n");\r\ngoto tx_error;\r\n}\r\naddr6 = (const struct in6_addr *)&neigh->primary_key;\r\naddr_type = ipv6_addr_type(addr6);\r\nif ((addr_type & IPV6_ADDR_UNICAST) &&\r\nipv6_addr_is_isatap(addr6))\r\ndst = addr6->s6_addr32[3];\r\nelse\r\ndo_tx_error = true;\r\nneigh_release(neigh);\r\nif (do_tx_error)\r\ngoto tx_error;\r\n}\r\nif (!dst)\r\ndst = try_6rd(tunnel, &iph6->daddr);\r\nif (!dst) {\r\nstruct neighbour *neigh = NULL;\r\nbool do_tx_error = false;\r\nif (skb_dst(skb))\r\nneigh = dst_neigh_lookup(skb_dst(skb), &iph6->daddr);\r\nif (!neigh) {\r\nnet_dbg_ratelimited("nexthop == NULL\n");\r\ngoto tx_error;\r\n}\r\naddr6 = (const struct in6_addr *)&neigh->primary_key;\r\naddr_type = ipv6_addr_type(addr6);\r\nif (addr_type == IPV6_ADDR_ANY) {\r\naddr6 = &ipv6_hdr(skb)->daddr;\r\naddr_type = ipv6_addr_type(addr6);\r\n}\r\nif ((addr_type & IPV6_ADDR_COMPATv4) != 0)\r\ndst = addr6->s6_addr32[3];\r\nelse\r\ndo_tx_error = true;\r\nneigh_release(neigh);\r\nif (do_tx_error)\r\ngoto tx_error;\r\n}\r\nrt = ip_route_output_ports(tunnel->net, &fl4, NULL,\r\ndst, tiph->saddr,\r\n0, 0,\r\nIPPROTO_IPV6, RT_TOS(tos),\r\ntunnel->parms.link);\r\nif (IS_ERR(rt)) {\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\nif (rt->rt_type != RTN_UNICAST) {\r\nip_rt_put(rt);\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\ntdev = rt->dst.dev;\r\nif (tdev == dev) {\r\nip_rt_put(rt);\r\ndev->stats.collisions++;\r\ngoto tx_error;\r\n}\r\nif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP4)) {\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nif (df) {\r\nmtu = dst_mtu(&rt->dst) - t_hlen;\r\nif (mtu < 68) {\r\ndev->stats.collisions++;\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nif (mtu < IPV6_MIN_MTU) {\r\nmtu = IPV6_MIN_MTU;\r\ndf = 0;\r\n}\r\nif (tunnel->parms.iph.daddr && skb_dst(skb))\r\nskb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);\r\nif (skb->len > mtu && !skb_is_gso(skb)) {\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\n}\r\nif (tunnel->err_count > 0) {\r\nif (time_before(jiffies,\r\ntunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\r\ntunnel->err_count--;\r\ndst_link_failure(skb);\r\n} else\r\ntunnel->err_count = 0;\r\n}\r\nmax_headroom = LL_RESERVED_SPACE(tdev) + t_hlen;\r\nif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\r\n(skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\r\nstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\r\nif (!new_skb) {\r\nip_rt_put(rt);\r\ndev->stats.tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb->sk)\r\nskb_set_owner_w(new_skb, skb->sk);\r\ndev_kfree_skb(skb);\r\nskb = new_skb;\r\niph6 = ipv6_hdr(skb);\r\n}\r\nttl = tiph->ttl;\r\nif (ttl == 0)\r\nttl = iph6->hop_limit;\r\ntos = INET_ECN_encapsulate(tos, ipv6_get_dsfield(iph6));\r\nif (ip_tunnel_encap(skb, tunnel, &protocol, &fl4) < 0) {\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nskb_set_inner_ipproto(skb, IPPROTO_IPV6);\r\niptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,\r\ndf, !net_eq(tunnel->net, dev_net(dev)));\r\nreturn NETDEV_TX_OK;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t sit_tunnel_xmit__(struct sk_buff *skb,\r\nstruct net_device *dev, u8 ipproto)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nconst struct iphdr *tiph = &tunnel->parms.iph;\r\nif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP4))\r\ngoto tx_error;\r\nskb_set_inner_ipproto(skb, ipproto);\r\nip_tunnel_xmit(skb, dev, tiph, ipproto);\r\nreturn NETDEV_TX_OK;\r\ntx_error:\r\nkfree_skb(skb);\r\ndev->stats.tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t sit_tunnel_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nsit_tunnel_xmit__(skb, dev, IPPROTO_IPIP);\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nipip6_tunnel_xmit(skb, dev);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_MPLS)\r\ncase htons(ETH_P_MPLS_UC):\r\nsit_tunnel_xmit__(skb, dev, IPPROTO_MPLS);\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto tx_err;\r\n}\r\nreturn NETDEV_TX_OK;\r\ntx_err:\r\ndev->stats.tx_errors++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ipip6_tunnel_bind_dev(struct net_device *dev)\r\n{\r\nstruct net_device *tdev = NULL;\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph;\r\nstruct flowi4 fl4;\r\ntunnel = netdev_priv(dev);\r\niph = &tunnel->parms.iph;\r\nif (iph->daddr) {\r\nstruct rtable *rt = ip_route_output_ports(tunnel->net, &fl4,\r\nNULL,\r\niph->daddr, iph->saddr,\r\n0, 0,\r\nIPPROTO_IPV6,\r\nRT_TOS(iph->tos),\r\ntunnel->parms.link);\r\nif (!IS_ERR(rt)) {\r\ntdev = rt->dst.dev;\r\nip_rt_put(rt);\r\n}\r\ndev->flags |= IFF_POINTOPOINT;\r\n}\r\nif (!tdev && tunnel->parms.link)\r\ntdev = __dev_get_by_index(tunnel->net, tunnel->parms.link);\r\nif (tdev) {\r\nint t_hlen = tunnel->hlen + sizeof(struct iphdr);\r\ndev->hard_header_len = tdev->hard_header_len + sizeof(struct iphdr);\r\ndev->mtu = tdev->mtu - t_hlen;\r\nif (dev->mtu < IPV6_MIN_MTU)\r\ndev->mtu = IPV6_MIN_MTU;\r\n}\r\n}\r\nstatic void ipip6_tunnel_update(struct ip_tunnel *t, struct ip_tunnel_parm *p)\r\n{\r\nstruct net *net = t->net;\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nipip6_tunnel_unlink(sitn, t);\r\nsynchronize_net();\r\nt->parms.iph.saddr = p->iph.saddr;\r\nt->parms.iph.daddr = p->iph.daddr;\r\nmemcpy(t->dev->dev_addr, &p->iph.saddr, 4);\r\nmemcpy(t->dev->broadcast, &p->iph.daddr, 4);\r\nipip6_tunnel_link(sitn, t);\r\nt->parms.iph.ttl = p->iph.ttl;\r\nt->parms.iph.tos = p->iph.tos;\r\nif (t->parms.link != p->link) {\r\nt->parms.link = p->link;\r\nipip6_tunnel_bind_dev(t->dev);\r\n}\r\ndst_cache_reset(&t->dst_cache);\r\nnetdev_state_change(t->dev);\r\n}\r\nstatic int ipip6_tunnel_update_6rd(struct ip_tunnel *t,\r\nstruct ip_tunnel_6rd *ip6rd)\r\n{\r\nstruct in6_addr prefix;\r\n__be32 relay_prefix;\r\nif (ip6rd->relay_prefixlen > 32 ||\r\nip6rd->prefixlen + (32 - ip6rd->relay_prefixlen) > 64)\r\nreturn -EINVAL;\r\nipv6_addr_prefix(&prefix, &ip6rd->prefix, ip6rd->prefixlen);\r\nif (!ipv6_addr_equal(&prefix, &ip6rd->prefix))\r\nreturn -EINVAL;\r\nif (ip6rd->relay_prefixlen)\r\nrelay_prefix = ip6rd->relay_prefix &\r\nhtonl(0xffffffffUL <<\r\n(32 - ip6rd->relay_prefixlen));\r\nelse\r\nrelay_prefix = 0;\r\nif (relay_prefix != ip6rd->relay_prefix)\r\nreturn -EINVAL;\r\nt->ip6rd.prefix = prefix;\r\nt->ip6rd.relay_prefix = relay_prefix;\r\nt->ip6rd.prefixlen = ip6rd->prefixlen;\r\nt->ip6rd.relay_prefixlen = ip6rd->relay_prefixlen;\r\ndst_cache_reset(&t->dst_cache);\r\nnetdev_state_change(t->dev);\r\nreturn 0;\r\n}\r\nstatic bool ipip6_valid_ip_proto(u8 ipproto)\r\n{\r\nreturn ipproto == IPPROTO_IPV6 ||\r\nipproto == IPPROTO_IPIP ||\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nipproto == IPPROTO_MPLS ||\r\n#endif\r\nipproto == 0;\r\n}\r\nstatic int\r\nipip6_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel_prl prl;\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct net *net = t->net;\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nstruct ip_tunnel_6rd ip6rd;\r\n#endif\r\nswitch (cmd) {\r\ncase SIOCGETTUNNEL:\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\ncase SIOCGET6RD:\r\n#endif\r\nif (dev == sitn->fb_tunnel_dev) {\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nt = ipip6_tunnel_locate(net, &p, 0);\r\nif (!t)\r\nt = netdev_priv(dev);\r\n}\r\nerr = -EFAULT;\r\nif (cmd == SIOCGETTUNNEL) {\r\nmemcpy(&p, &t->parms, sizeof(p));\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p,\r\nsizeof(p)))\r\ngoto done;\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\n} else {\r\nip6rd.prefix = t->ip6rd.prefix;\r\nip6rd.relay_prefix = t->ip6rd.relay_prefix;\r\nip6rd.prefixlen = t->ip6rd.prefixlen;\r\nip6rd.relay_prefixlen = t->ip6rd.relay_prefixlen;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &ip6rd,\r\nsizeof(ip6rd)))\r\ngoto done;\r\n#endif\r\n}\r\nerr = 0;\r\nbreak;\r\ncase SIOCADDTUNNEL:\r\ncase SIOCCHGTUNNEL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto done;\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\ngoto done;\r\nerr = -EINVAL;\r\nif (!ipip6_valid_ip_proto(p.iph.protocol))\r\ngoto done;\r\nif (p.iph.version != 4 ||\r\np.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)))\r\ngoto done;\r\nif (p.iph.ttl)\r\np.iph.frag_off |= htons(IP_DF);\r\nt = ipip6_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\r\nif (dev != sitn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\r\nif (t) {\r\nif (t->dev != dev) {\r\nerr = -EEXIST;\r\nbreak;\r\n}\r\n} else {\r\nif (((dev->flags&IFF_POINTOPOINT) && !p.iph.daddr) ||\r\n(!(dev->flags&IFF_POINTOPOINT) && p.iph.daddr)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nt = netdev_priv(dev);\r\n}\r\nipip6_tunnel_update(t, &p);\r\n}\r\nif (t) {\r\nerr = 0;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof(p)))\r\nerr = -EFAULT;\r\n} else\r\nerr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\r\nbreak;\r\ncase SIOCDELTUNNEL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto done;\r\nif (dev == sitn->fb_tunnel_dev) {\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\ngoto done;\r\nerr = -ENOENT;\r\nt = ipip6_tunnel_locate(net, &p, 0);\r\nif (!t)\r\ngoto done;\r\nerr = -EPERM;\r\nif (t == netdev_priv(sitn->fb_tunnel_dev))\r\ngoto done;\r\ndev = t->dev;\r\n}\r\nunregister_netdevice(dev);\r\nerr = 0;\r\nbreak;\r\ncase SIOCGETPRL:\r\nerr = -EINVAL;\r\nif (dev == sitn->fb_tunnel_dev)\r\ngoto done;\r\nerr = ipip6_tunnel_get_prl(t, ifr->ifr_ifru.ifru_data);\r\nbreak;\r\ncase SIOCADDPRL:\r\ncase SIOCDELPRL:\r\ncase SIOCCHGPRL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto done;\r\nerr = -EINVAL;\r\nif (dev == sitn->fb_tunnel_dev)\r\ngoto done;\r\nerr = -EFAULT;\r\nif (copy_from_user(&prl, ifr->ifr_ifru.ifru_data, sizeof(prl)))\r\ngoto done;\r\nswitch (cmd) {\r\ncase SIOCDELPRL:\r\nerr = ipip6_tunnel_del_prl(t, &prl);\r\nbreak;\r\ncase SIOCADDPRL:\r\ncase SIOCCHGPRL:\r\nerr = ipip6_tunnel_add_prl(t, &prl, cmd == SIOCCHGPRL);\r\nbreak;\r\n}\r\ndst_cache_reset(&t->dst_cache);\r\nnetdev_state_change(dev);\r\nbreak;\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\ncase SIOCADD6RD:\r\ncase SIOCCHG6RD:\r\ncase SIOCDEL6RD:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto done;\r\nerr = -EFAULT;\r\nif (copy_from_user(&ip6rd, ifr->ifr_ifru.ifru_data,\r\nsizeof(ip6rd)))\r\ngoto done;\r\nif (cmd != SIOCDEL6RD) {\r\nerr = ipip6_tunnel_update_6rd(t, &ip6rd);\r\nif (err < 0)\r\ngoto done;\r\n} else\r\nipip6_tunnel_clone_6rd(dev, sitn);\r\nerr = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\ndone:\r\nreturn err;\r\n}\r\nstatic void ipip6_dev_free(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\ndst_cache_destroy(&tunnel->dst_cache);\r\nfree_percpu(dev->tstats);\r\nfree_netdev(dev);\r\n}\r\nstatic void ipip6_tunnel_setup(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nint t_hlen = tunnel->hlen + sizeof(struct iphdr);\r\ndev->netdev_ops = &ipip6_netdev_ops;\r\ndev->destructor = ipip6_dev_free;\r\ndev->type = ARPHRD_SIT;\r\ndev->hard_header_len = LL_MAX_HEADER + t_hlen;\r\ndev->mtu = ETH_DATA_LEN - t_hlen;\r\ndev->min_mtu = IPV6_MIN_MTU;\r\ndev->max_mtu = 0xFFF8 - t_hlen;\r\ndev->flags = IFF_NOARP;\r\nnetif_keep_dst(dev);\r\ndev->addr_len = 4;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->features |= SIT_FEATURES;\r\ndev->hw_features |= SIT_FEATURES;\r\n}\r\nstatic int ipip6_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nint err;\r\ntunnel->dev = dev;\r\ntunnel->net = dev_net(dev);\r\nstrcpy(tunnel->parms.name, dev->name);\r\nipip6_tunnel_bind_dev(dev);\r\ndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\nerr = dst_cache_init(&tunnel->dst_cache, GFP_KERNEL);\r\nif (err) {\r\nfree_percpu(dev->tstats);\r\ndev->tstats = NULL;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __net_init ipip6_fb_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\nstruct net *net = dev_net(dev);\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\niph->version = 4;\r\niph->protocol = IPPROTO_IPV6;\r\niph->ihl = 5;\r\niph->ttl = 64;\r\ndev_hold(dev);\r\nrcu_assign_pointer(sitn->tunnels_wc[0], tunnel);\r\n}\r\nstatic int ipip6_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nu8 proto;\r\nif (!data || !data[IFLA_IPTUN_PROTO])\r\nreturn 0;\r\nproto = nla_get_u8(data[IFLA_IPTUN_PROTO]);\r\nif (!ipip6_valid_ip_proto(proto))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ipip6_netlink_parms(struct nlattr *data[],\r\nstruct ip_tunnel_parm *parms)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.version = 4;\r\nparms->iph.protocol = IPPROTO_IPV6;\r\nparms->iph.ihl = 5;\r\nparms->iph.ttl = 64;\r\nif (!data)\r\nreturn;\r\nif (data[IFLA_IPTUN_LINK])\r\nparms->link = nla_get_u32(data[IFLA_IPTUN_LINK]);\r\nif (data[IFLA_IPTUN_LOCAL])\r\nparms->iph.saddr = nla_get_be32(data[IFLA_IPTUN_LOCAL]);\r\nif (data[IFLA_IPTUN_REMOTE])\r\nparms->iph.daddr = nla_get_be32(data[IFLA_IPTUN_REMOTE]);\r\nif (data[IFLA_IPTUN_TTL]) {\r\nparms->iph.ttl = nla_get_u8(data[IFLA_IPTUN_TTL]);\r\nif (parms->iph.ttl)\r\nparms->iph.frag_off = htons(IP_DF);\r\n}\r\nif (data[IFLA_IPTUN_TOS])\r\nparms->iph.tos = nla_get_u8(data[IFLA_IPTUN_TOS]);\r\nif (!data[IFLA_IPTUN_PMTUDISC] || nla_get_u8(data[IFLA_IPTUN_PMTUDISC]))\r\nparms->iph.frag_off = htons(IP_DF);\r\nif (data[IFLA_IPTUN_FLAGS])\r\nparms->i_flags = nla_get_be16(data[IFLA_IPTUN_FLAGS]);\r\nif (data[IFLA_IPTUN_PROTO])\r\nparms->iph.protocol = nla_get_u8(data[IFLA_IPTUN_PROTO]);\r\n}\r\nstatic bool ipip6_netlink_encap_parms(struct nlattr *data[],\r\nstruct ip_tunnel_encap *ipencap)\r\n{\r\nbool ret = false;\r\nmemset(ipencap, 0, sizeof(*ipencap));\r\nif (!data)\r\nreturn ret;\r\nif (data[IFLA_IPTUN_ENCAP_TYPE]) {\r\nret = true;\r\nipencap->type = nla_get_u16(data[IFLA_IPTUN_ENCAP_TYPE]);\r\n}\r\nif (data[IFLA_IPTUN_ENCAP_FLAGS]) {\r\nret = true;\r\nipencap->flags = nla_get_u16(data[IFLA_IPTUN_ENCAP_FLAGS]);\r\n}\r\nif (data[IFLA_IPTUN_ENCAP_SPORT]) {\r\nret = true;\r\nipencap->sport = nla_get_be16(data[IFLA_IPTUN_ENCAP_SPORT]);\r\n}\r\nif (data[IFLA_IPTUN_ENCAP_DPORT]) {\r\nret = true;\r\nipencap->dport = nla_get_be16(data[IFLA_IPTUN_ENCAP_DPORT]);\r\n}\r\nreturn ret;\r\n}\r\nstatic bool ipip6_netlink_6rd_parms(struct nlattr *data[],\r\nstruct ip_tunnel_6rd *ip6rd)\r\n{\r\nbool ret = false;\r\nmemset(ip6rd, 0, sizeof(*ip6rd));\r\nif (!data)\r\nreturn ret;\r\nif (data[IFLA_IPTUN_6RD_PREFIX]) {\r\nret = true;\r\nip6rd->prefix = nla_get_in6_addr(data[IFLA_IPTUN_6RD_PREFIX]);\r\n}\r\nif (data[IFLA_IPTUN_6RD_RELAY_PREFIX]) {\r\nret = true;\r\nip6rd->relay_prefix =\r\nnla_get_be32(data[IFLA_IPTUN_6RD_RELAY_PREFIX]);\r\n}\r\nif (data[IFLA_IPTUN_6RD_PREFIXLEN]) {\r\nret = true;\r\nip6rd->prefixlen = nla_get_u16(data[IFLA_IPTUN_6RD_PREFIXLEN]);\r\n}\r\nif (data[IFLA_IPTUN_6RD_RELAY_PREFIXLEN]) {\r\nret = true;\r\nip6rd->relay_prefixlen =\r\nnla_get_u16(data[IFLA_IPTUN_6RD_RELAY_PREFIXLEN]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipip6_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct ip_tunnel *nt;\r\nstruct ip_tunnel_encap ipencap;\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nstruct ip_tunnel_6rd ip6rd;\r\n#endif\r\nint err;\r\nnt = netdev_priv(dev);\r\nif (ipip6_netlink_encap_parms(data, &ipencap)) {\r\nerr = ip_tunnel_encap_setup(nt, &ipencap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nipip6_netlink_parms(data, &nt->parms);\r\nif (ipip6_tunnel_locate(net, &nt->parms, 0))\r\nreturn -EEXIST;\r\nerr = ipip6_tunnel_create(dev);\r\nif (err < 0)\r\nreturn err;\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nif (ipip6_netlink_6rd_parms(data, &ip6rd))\r\nerr = ipip6_tunnel_update_6rd(nt, &ip6rd);\r\n#endif\r\nreturn err;\r\n}\r\nstatic int ipip6_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel_encap ipencap;\r\nstruct net *net = t->net;\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nstruct ip_tunnel_6rd ip6rd;\r\n#endif\r\nint err;\r\nif (dev == sitn->fb_tunnel_dev)\r\nreturn -EINVAL;\r\nif (ipip6_netlink_encap_parms(data, &ipencap)) {\r\nerr = ip_tunnel_encap_setup(t, &ipencap);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nipip6_netlink_parms(data, &p);\r\nif (((dev->flags & IFF_POINTOPOINT) && !p.iph.daddr) ||\r\n(!(dev->flags & IFF_POINTOPOINT) && p.iph.daddr))\r\nreturn -EINVAL;\r\nt = ipip6_tunnel_locate(net, &p, 0);\r\nif (t) {\r\nif (t->dev != dev)\r\nreturn -EEXIST;\r\n} else\r\nt = netdev_priv(dev);\r\nipip6_tunnel_update(t, &p);\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nif (ipip6_netlink_6rd_parms(data, &ip6rd))\r\nreturn ipip6_tunnel_update_6rd(t, &ip6rd);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic size_t ipip6_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(2) +\r\nnla_total_size(1) +\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nnla_total_size(sizeof(struct in6_addr)) +\r\nnla_total_size(4) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\n#endif\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\n0;\r\n}\r\nstatic int ipip6_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct ip_tunnel_parm *parm = &tunnel->parms;\r\nif (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||\r\nnla_put_in_addr(skb, IFLA_IPTUN_LOCAL, parm->iph.saddr) ||\r\nnla_put_in_addr(skb, IFLA_IPTUN_REMOTE, parm->iph.daddr) ||\r\nnla_put_u8(skb, IFLA_IPTUN_TTL, parm->iph.ttl) ||\r\nnla_put_u8(skb, IFLA_IPTUN_TOS, parm->iph.tos) ||\r\nnla_put_u8(skb, IFLA_IPTUN_PMTUDISC,\r\n!!(parm->iph.frag_off & htons(IP_DF))) ||\r\nnla_put_u8(skb, IFLA_IPTUN_PROTO, parm->iph.protocol) ||\r\nnla_put_be16(skb, IFLA_IPTUN_FLAGS, parm->i_flags))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_IPV6_SIT_6RD\r\nif (nla_put_in6_addr(skb, IFLA_IPTUN_6RD_PREFIX,\r\n&tunnel->ip6rd.prefix) ||\r\nnla_put_in_addr(skb, IFLA_IPTUN_6RD_RELAY_PREFIX,\r\ntunnel->ip6rd.relay_prefix) ||\r\nnla_put_u16(skb, IFLA_IPTUN_6RD_PREFIXLEN,\r\ntunnel->ip6rd.prefixlen) ||\r\nnla_put_u16(skb, IFLA_IPTUN_6RD_RELAY_PREFIXLEN,\r\ntunnel->ip6rd.relay_prefixlen))\r\ngoto nla_put_failure;\r\n#endif\r\nif (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE,\r\ntunnel->encap.type) ||\r\nnla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT,\r\ntunnel->encap.sport) ||\r\nnla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT,\r\ntunnel->encap.dport) ||\r\nnla_put_u16(skb, IFLA_IPTUN_ENCAP_FLAGS,\r\ntunnel->encap.flags))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void ipip6_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nif (dev != sitn->fb_tunnel_dev)\r\nunregister_netdevice_queue(dev, head);\r\n}\r\nstatic void __net_exit sit_destroy_tunnels(struct net *net,\r\nstruct list_head *head)\r\n{\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nstruct net_device *dev, *aux;\r\nint prio;\r\nfor_each_netdev_safe(net, dev, aux)\r\nif (dev->rtnl_link_ops == &sit_link_ops)\r\nunregister_netdevice_queue(dev, head);\r\nfor (prio = 1; prio < 4; prio++) {\r\nint h;\r\nfor (h = 0; h < IP6_SIT_HASH_SIZE; h++) {\r\nstruct ip_tunnel *t;\r\nt = rtnl_dereference(sitn->tunnels[prio][h]);\r\nwhile (t) {\r\nif (!net_eq(dev_net(t->dev), net))\r\nunregister_netdevice_queue(t->dev,\r\nhead);\r\nt = rtnl_dereference(t->next);\r\n}\r\n}\r\n}\r\n}\r\nstatic int __net_init sit_init_net(struct net *net)\r\n{\r\nstruct sit_net *sitn = net_generic(net, sit_net_id);\r\nstruct ip_tunnel *t;\r\nint err;\r\nsitn->tunnels[0] = sitn->tunnels_wc;\r\nsitn->tunnels[1] = sitn->tunnels_l;\r\nsitn->tunnels[2] = sitn->tunnels_r;\r\nsitn->tunnels[3] = sitn->tunnels_r_l;\r\nsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), "sit0",\r\nNET_NAME_UNKNOWN,\r\nipip6_tunnel_setup);\r\nif (!sitn->fb_tunnel_dev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_dev;\r\n}\r\ndev_net_set(sitn->fb_tunnel_dev, net);\r\nsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\r\nsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\r\nerr = register_netdev(sitn->fb_tunnel_dev);\r\nif (err)\r\ngoto err_reg_dev;\r\nipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\r\nipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\r\nt = netdev_priv(sitn->fb_tunnel_dev);\r\nstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\r\nreturn 0;\r\nerr_reg_dev:\r\nipip6_dev_free(sitn->fb_tunnel_dev);\r\nerr_alloc_dev:\r\nreturn err;\r\n}\r\nstatic void __net_exit sit_exit_net(struct net *net)\r\n{\r\nLIST_HEAD(list);\r\nrtnl_lock();\r\nsit_destroy_tunnels(net, &list);\r\nunregister_netdevice_many(&list);\r\nrtnl_unlock();\r\n}\r\nstatic void __exit sit_cleanup(void)\r\n{\r\nrtnl_link_unregister(&sit_link_ops);\r\nxfrm4_tunnel_deregister(&sit_handler, AF_INET6);\r\nxfrm4_tunnel_deregister(&ipip_handler, AF_INET);\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nxfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS);\r\n#endif\r\nunregister_pernet_device(&sit_net_ops);\r\nrcu_barrier();\r\n}\r\nstatic int __init sit_init(void)\r\n{\r\nint err;\r\npr_info("IPv6, IPv4 and MPLS over IPv4 tunneling driver\n");\r\nerr = register_pernet_device(&sit_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = xfrm4_tunnel_register(&sit_handler, AF_INET6);\r\nif (err < 0) {\r\npr_info("%s: can't register ip6ip4\n", __func__);\r\ngoto xfrm_tunnel_failed;\r\n}\r\nerr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\r\nif (err < 0) {\r\npr_info("%s: can't register ip4ip4\n", __func__);\r\ngoto xfrm_tunnel4_failed;\r\n}\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nerr = xfrm4_tunnel_register(&mplsip_handler, AF_MPLS);\r\nif (err < 0) {\r\npr_info("%s: can't register mplsip\n", __func__);\r\ngoto xfrm_tunnel_mpls_failed;\r\n}\r\n#endif\r\nerr = rtnl_link_register(&sit_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nout:\r\nreturn err;\r\nrtnl_link_failed:\r\n#if IS_ENABLED(CONFIG_MPLS)\r\nxfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS);\r\nxfrm_tunnel_mpls_failed:\r\n#endif\r\nxfrm4_tunnel_deregister(&ipip_handler, AF_INET);\r\nxfrm_tunnel4_failed:\r\nxfrm4_tunnel_deregister(&sit_handler, AF_INET6);\r\nxfrm_tunnel_failed:\r\nunregister_pernet_device(&sit_net_ops);\r\ngoto out;\r\n}
