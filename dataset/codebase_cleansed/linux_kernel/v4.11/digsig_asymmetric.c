static struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)\r\n{\r\nstruct key *key;\r\nchar name[12];\r\nsprintf(name, "id:%08x", keyid);\r\npr_debug("key search: \"%s\"\n", name);\r\nkey = get_ima_blacklist_keyring();\r\nif (key) {\r\nkey_ref_t kref;\r\nkref = keyring_search(make_key_ref(key, 1),\r\n&key_type_asymmetric, name);\r\nif (!IS_ERR(kref)) {\r\npr_err("Key '%s' is in ima_blacklist_keyring\n", name);\r\nreturn ERR_PTR(-EKEYREJECTED);\r\n}\r\n}\r\nif (keyring) {\r\nkey_ref_t kref;\r\nkref = keyring_search(make_key_ref(keyring, 1),\r\n&key_type_asymmetric, name);\r\nif (IS_ERR(kref))\r\nkey = ERR_CAST(kref);\r\nelse\r\nkey = key_ref_to_ptr(kref);\r\n} else {\r\nkey = request_key(&key_type_asymmetric, name, NULL);\r\n}\r\nif (IS_ERR(key)) {\r\npr_err_ratelimited("Request for unknown key '%s' err %ld\n",\r\nname, PTR_ERR(key));\r\nswitch (PTR_ERR(key)) {\r\ncase -EACCES:\r\ncase -ENOTDIR:\r\ncase -EAGAIN:\r\nreturn ERR_PTR(-ENOKEY);\r\ndefault:\r\nreturn key;\r\n}\r\n}\r\npr_debug("%s() = 0 [%x]\n", __func__, key_serial(key));\r\nreturn key;\r\n}\r\nint asymmetric_verify(struct key *keyring, const char *sig,\r\nint siglen, const char *data, int datalen)\r\n{\r\nstruct public_key_signature pks;\r\nstruct signature_v2_hdr *hdr = (struct signature_v2_hdr *)sig;\r\nstruct key *key;\r\nint ret = -ENOMEM;\r\nif (siglen <= sizeof(*hdr))\r\nreturn -EBADMSG;\r\nsiglen -= sizeof(*hdr);\r\nif (siglen != __be16_to_cpu(hdr->sig_size))\r\nreturn -EBADMSG;\r\nif (hdr->hash_algo >= HASH_ALGO__LAST)\r\nreturn -ENOPKG;\r\nkey = request_asymmetric_key(keyring, __be32_to_cpu(hdr->keyid));\r\nif (IS_ERR(key))\r\nreturn PTR_ERR(key);\r\nmemset(&pks, 0, sizeof(pks));\r\npks.pkey_algo = "rsa";\r\npks.hash_algo = hash_algo_name[hdr->hash_algo];\r\npks.digest = (u8 *)data;\r\npks.digest_size = datalen;\r\npks.s = hdr->sig;\r\npks.s_size = siglen;\r\nret = verify_signature(key, &pks);\r\nkey_put(key);\r\npr_debug("%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}
