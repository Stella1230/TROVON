static bool vp9_is_sf_ref_fb(struct vdec_vp9_inst *inst, struct vdec_fb *fb)\r\n{\r\nint i;\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nfor (i = 0; i < ARRAY_SIZE(vsi->sf_ref_fb); i++) {\r\nif (fb == &vsi->sf_ref_fb[i].fb)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic struct vdec_fb *vp9_rm_from_fb_use_list(struct vdec_vp9_inst\r\n*inst, void *addr)\r\n{\r\nstruct vdec_fb *fb = NULL;\r\nstruct vdec_fb_node *node;\r\nlist_for_each_entry(node, &inst->fb_use_list, list) {\r\nfb = (struct vdec_fb *)node->fb;\r\nif (fb->base_y.va == addr) {\r\nlist_move_tail(&node->list,\r\n&inst->available_fb_node_list);\r\nbreak;\r\n}\r\n}\r\nreturn fb;\r\n}\r\nstatic void vp9_add_to_fb_free_list(struct vdec_vp9_inst *inst,\r\nstruct vdec_fb *fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nif (fb) {\r\nnode = list_first_entry_or_null(&inst->available_fb_node_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nnode->fb = fb;\r\nlist_move_tail(&node->list, &inst->fb_free_list);\r\n}\r\n} else {\r\nmtk_vcodec_debug(inst, "No free fb node");\r\n}\r\n}\r\nstatic void vp9_free_sf_ref_fb(struct vdec_fb *fb)\r\n{\r\nstruct vp9_sf_ref_fb *sf_ref_fb =\r\ncontainer_of(fb, struct vp9_sf_ref_fb, fb);\r\nsf_ref_fb->used = 0;\r\n}\r\nstatic void vp9_ref_cnt_fb(struct vdec_vp9_inst *inst, int *idx,\r\nint new_idx)\r\n{\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nint ref_idx = *idx;\r\nif (ref_idx >= 0 && vsi->frm_bufs[ref_idx].ref_cnt > 0) {\r\nvsi->frm_bufs[ref_idx].ref_cnt--;\r\nif (vsi->frm_bufs[ref_idx].ref_cnt == 0) {\r\nif (!vp9_is_sf_ref_fb(inst,\r\nvsi->frm_bufs[ref_idx].buf.fb)) {\r\nstruct vdec_fb *fb;\r\nfb = vp9_rm_from_fb_use_list(inst,\r\nvsi->frm_bufs[ref_idx].buf.fb->base_y.va);\r\nvp9_add_to_fb_free_list(inst, fb);\r\n} else\r\nvp9_free_sf_ref_fb(\r\nvsi->frm_bufs[ref_idx].buf.fb);\r\n}\r\n}\r\n*idx = new_idx;\r\nvsi->frm_bufs[new_idx].ref_cnt++;\r\n}\r\nstatic void vp9_free_all_sf_ref_fb(struct vdec_vp9_inst *inst)\r\n{\r\nint i;\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nfor (i = 0; i < ARRAY_SIZE(vsi->sf_ref_fb); i++) {\r\nif (vsi->sf_ref_fb[i].fb.base_y.va) {\r\nmtk_vcodec_mem_free(inst->ctx,\r\n&vsi->sf_ref_fb[i].fb.base_y);\r\nmtk_vcodec_mem_free(inst->ctx,\r\n&vsi->sf_ref_fb[i].fb.base_c);\r\nvsi->sf_ref_fb[i].used = 0;\r\n}\r\n}\r\n}\r\nstatic int vp9_get_sf_ref_fb(struct vdec_vp9_inst *inst)\r\n{\r\nint idx;\r\nstruct mtk_vcodec_mem *mem_basy_y;\r\nstruct mtk_vcodec_mem *mem_basy_c;\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nfor (idx = 0;\r\nidx < ARRAY_SIZE(vsi->sf_ref_fb);\r\nidx++) {\r\nif (vsi->sf_ref_fb[idx].fb.base_y.va &&\r\nvsi->sf_ref_fb[idx].used == 0) {\r\nreturn idx;\r\n}\r\n}\r\nfor (idx = 0;\r\nidx < ARRAY_SIZE(vsi->sf_ref_fb);\r\nidx++) {\r\nif (vsi->sf_ref_fb[idx].fb.base_y.va == NULL)\r\nbreak;\r\n}\r\nif (idx == ARRAY_SIZE(vsi->sf_ref_fb)) {\r\nmtk_vcodec_err(inst, "List Full");\r\nreturn -1;\r\n}\r\nmem_basy_y = &vsi->sf_ref_fb[idx].fb.base_y;\r\nmem_basy_y->size = vsi->buf_sz_y_bs +\r\nvsi->buf_len_sz_y;\r\nif (mtk_vcodec_mem_alloc(inst->ctx, mem_basy_y)) {\r\nmtk_vcodec_err(inst, "Cannot allocate sf_ref_buf y_buf");\r\nreturn -1;\r\n}\r\nmem_basy_c = &vsi->sf_ref_fb[idx].fb.base_c;\r\nmem_basy_c->size = vsi->buf_sz_c_bs +\r\nvsi->buf_len_sz_c;\r\nif (mtk_vcodec_mem_alloc(inst->ctx, mem_basy_c)) {\r\nmtk_vcodec_err(inst, "Cannot allocate sf_ref_fb c_buf");\r\nreturn -1;\r\n}\r\nvsi->sf_ref_fb[idx].used = 0;\r\nreturn idx;\r\n}\r\nstatic bool vp9_alloc_work_buf(struct vdec_vp9_inst *inst)\r\n{\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nint result;\r\nstruct mtk_vcodec_mem *mem;\r\nunsigned int max_pic_w;\r\nunsigned int max_pic_h;\r\nif (!(inst->ctx->dev->dec_capability &\r\nVCODEC_CAPABILITY_4K_DISABLED)) {\r\nmax_pic_w = VCODEC_DEC_4K_CODED_WIDTH;\r\nmax_pic_h = VCODEC_DEC_4K_CODED_HEIGHT;\r\n} else {\r\nmax_pic_w = MTK_VDEC_MAX_W;\r\nmax_pic_h = MTK_VDEC_MAX_H;\r\n}\r\nif ((vsi->pic_w > max_pic_w) ||\r\n(vsi->pic_h > max_pic_h)) {\r\nmtk_vcodec_err(inst, "Invalid w/h %d/%d",\r\nvsi->pic_w, vsi->pic_h);\r\nreturn false;\r\n}\r\nmtk_vcodec_debug(inst, "BUF CHG(%d): w/h/sb_w/sb_h=%d/%d/%d/%d",\r\nvsi->resolution_changed,\r\nvsi->pic_w,\r\nvsi->pic_h,\r\nvsi->buf_w,\r\nvsi->buf_h);\r\nmem = &inst->mv_buf;\r\nif (mem->va)\r\nmtk_vcodec_mem_free(inst->ctx, mem);\r\nmem->size = ((vsi->buf_w / 64) *\r\n(vsi->buf_h / 64) + 2) * 36 * 16;\r\nresult = mtk_vcodec_mem_alloc(inst->ctx, mem);\r\nif (result) {\r\nmem->size = 0;\r\nmtk_vcodec_err(inst, "Cannot allocate mv_buf");\r\nreturn false;\r\n}\r\nvsi->mv_buf.va = (unsigned long)mem->va;\r\nvsi->mv_buf.pa = (unsigned long)mem->dma_addr;\r\nvsi->mv_buf.sz = (unsigned int)mem->size;\r\nvp9_free_all_sf_ref_fb(inst);\r\nvsi->sf_next_ref_fb_idx = vp9_get_sf_ref_fb(inst);\r\nreturn true;\r\n}\r\nstatic bool vp9_add_to_fb_disp_list(struct vdec_vp9_inst *inst,\r\nstruct vdec_fb *fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nif (!fb) {\r\nmtk_vcodec_err(inst, "fb == NULL");\r\nreturn false;\r\n}\r\nnode = list_first_entry_or_null(&inst->available_fb_node_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nnode->fb = fb;\r\nlist_move_tail(&node->list, &inst->fb_disp_list);\r\n} else {\r\nmtk_vcodec_err(inst, "No available fb node");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void vp9_swap_frm_bufs(struct vdec_vp9_inst *inst)\r\n{\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nstruct vp9_fb_info *frm_to_show;\r\nint ref_index = 0, mask;\r\nfor (mask = vsi->refresh_frm_flags; mask; mask >>= 1) {\r\nif (mask & 1)\r\nvp9_ref_cnt_fb(inst, &vsi->ref_frm_map[ref_index],\r\nvsi->new_fb_idx);\r\n++ref_index;\r\n}\r\nfrm_to_show = &vsi->frm_bufs[vsi->new_fb_idx].buf;\r\nvsi->frm_bufs[vsi->new_fb_idx].ref_cnt--;\r\nif (frm_to_show->fb != inst->cur_fb) {\r\nif ((frm_to_show->fb != NULL) &&\r\n(inst->cur_fb->base_y.size >=\r\nfrm_to_show->fb->base_y.size)) {\r\nmemcpy((void *)inst->cur_fb->base_y.va,\r\n(void *)frm_to_show->fb->base_y.va,\r\nvsi->buf_w *\r\nvsi->buf_h);\r\nmemcpy((void *)inst->cur_fb->base_c.va,\r\n(void *)frm_to_show->fb->base_c.va,\r\nvsi->buf_w *\r\nvsi->buf_h / 2);\r\n} else {\r\nif (frm_to_show->fb != NULL)\r\nmtk_vcodec_err(inst,\r\n"inst->cur_fb->base_y.size=%zu, frm_to_show->fb.base_y.size=%zu",\r\ninst->cur_fb->base_y.size,\r\nfrm_to_show->fb->base_y.size);\r\n}\r\nif (!vp9_is_sf_ref_fb(inst, inst->cur_fb)) {\r\nif (vsi->show_frame)\r\nvp9_add_to_fb_disp_list(inst, inst->cur_fb);\r\n}\r\n} else {\r\nif (!vp9_is_sf_ref_fb(inst, inst->cur_fb)) {\r\nif (vsi->show_frame)\r\nvp9_add_to_fb_disp_list(inst, frm_to_show->fb);\r\n}\r\n}\r\nif (vsi->frm_bufs[vsi->new_fb_idx].ref_cnt == 0) {\r\nif (!vp9_is_sf_ref_fb(\r\ninst, vsi->frm_bufs[vsi->new_fb_idx].buf.fb)) {\r\nstruct vdec_fb *fb;\r\nfb = vp9_rm_from_fb_use_list(inst,\r\nvsi->frm_bufs[vsi->new_fb_idx].buf.fb->base_y.va);\r\nvp9_add_to_fb_free_list(inst, fb);\r\n} else {\r\nvp9_free_sf_ref_fb(\r\nvsi->frm_bufs[vsi->new_fb_idx].buf.fb);\r\n}\r\n}\r\nif (vsi->sf_frm_cnt > 0 && vsi->sf_frm_idx != vsi->sf_frm_cnt - 1)\r\nvsi->sf_next_ref_fb_idx = vp9_get_sf_ref_fb(inst);\r\n}\r\nstatic bool vp9_wait_dec_end(struct vdec_vp9_inst *inst)\r\n{\r\nstruct mtk_vcodec_ctx *ctx = inst->ctx;\r\nmtk_vcodec_wait_for_done_ctx(inst->ctx,\r\nMTK_INST_IRQ_RECEIVED,\r\nWAIT_INTR_TIMEOUT_MS);\r\nif (ctx->irq_status & MTK_VDEC_IRQ_STATUS_DEC_SUCCESS)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic struct vdec_vp9_inst *vp9_alloc_inst(struct mtk_vcodec_ctx *ctx)\r\n{\r\nint result;\r\nstruct mtk_vcodec_mem mem;\r\nstruct vdec_vp9_inst *inst;\r\nmemset(&mem, 0, sizeof(mem));\r\nmem.size = sizeof(struct vdec_vp9_inst);\r\nresult = mtk_vcodec_mem_alloc(ctx, &mem);\r\nif (result)\r\nreturn NULL;\r\ninst = mem.va;\r\ninst->mem = mem;\r\nreturn inst;\r\n}\r\nstatic void vp9_free_inst(struct vdec_vp9_inst *inst)\r\n{\r\nstruct mtk_vcodec_mem mem;\r\nmem = inst->mem;\r\nif (mem.va)\r\nmtk_vcodec_mem_free(inst->ctx, &mem);\r\n}\r\nstatic bool vp9_decode_end_proc(struct vdec_vp9_inst *inst)\r\n{\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nbool ret = false;\r\nif (!vsi->show_existing_frame) {\r\nret = vp9_wait_dec_end(inst);\r\nif (!ret) {\r\nmtk_vcodec_err(inst, "Decode failed, Decode Timeout @[%d]",\r\nvsi->frm_num);\r\nreturn false;\r\n}\r\nif (vpu_dec_end(&inst->vpu)) {\r\nmtk_vcodec_err(inst, "vp9_dec_vpu_end failed");\r\nreturn false;\r\n}\r\nmtk_vcodec_debug(inst, "Decode Ok @%d (%d/%d)", vsi->frm_num,\r\nvsi->pic_w, vsi->pic_h);\r\n} else {\r\nmtk_vcodec_debug(inst, "Decode Ok @%d (show_existing_frame)",\r\nvsi->frm_num);\r\n}\r\nvp9_swap_frm_bufs(inst);\r\nvsi->frm_num++;\r\nreturn true;\r\n}\r\nstatic bool vp9_is_last_sub_frm(struct vdec_vp9_inst *inst)\r\n{\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nif (vsi->sf_frm_cnt <= 0 || vsi->sf_frm_idx == vsi->sf_frm_cnt)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct vdec_fb *vp9_rm_from_fb_disp_list(struct vdec_vp9_inst *inst)\r\n{\r\nstruct vdec_fb_node *node;\r\nstruct vdec_fb *fb = NULL;\r\nnode = list_first_entry_or_null(&inst->fb_disp_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nfb = (struct vdec_fb *)node->fb;\r\nfb->status |= FB_ST_DISPLAY;\r\nlist_move_tail(&node->list, &inst->available_fb_node_list);\r\nmtk_vcodec_debug(inst, "[FB] get disp fb %p st=%d",\r\nnode->fb, fb->status);\r\n} else\r\nmtk_vcodec_debug(inst, "[FB] there is no disp fb");\r\nreturn fb;\r\n}\r\nstatic bool vp9_add_to_fb_use_list(struct vdec_vp9_inst *inst,\r\nstruct vdec_fb *fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nif (!fb) {\r\nmtk_vcodec_debug(inst, "fb == NULL");\r\nreturn false;\r\n}\r\nnode = list_first_entry_or_null(&inst->available_fb_node_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nnode->fb = fb;\r\nlist_move_tail(&node->list, &inst->fb_use_list);\r\n} else {\r\nmtk_vcodec_err(inst, "No free fb node");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void vp9_reset(struct vdec_vp9_inst *inst)\r\n{\r\nstruct vdec_fb_node *node, *tmp;\r\nlist_for_each_entry_safe(node, tmp, &inst->fb_use_list, list)\r\nlist_move_tail(&node->list, &inst->fb_free_list);\r\nvp9_free_all_sf_ref_fb(inst);\r\ninst->vsi->sf_next_ref_fb_idx = vp9_get_sf_ref_fb(inst);\r\nif (vpu_dec_reset(&inst->vpu))\r\nmtk_vcodec_err(inst, "vp9_dec_vpu_reset failed");\r\ninst->vsi->mv_buf.va = (unsigned long)inst->mv_buf.va;\r\ninst->vsi->mv_buf.pa = (unsigned long)inst->mv_buf.dma_addr;\r\ninst->vsi->mv_buf.sz = (unsigned long)inst->mv_buf.size;\r\n}\r\nstatic void init_all_fb_lists(struct vdec_vp9_inst *inst)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&inst->available_fb_node_list);\r\nINIT_LIST_HEAD(&inst->fb_use_list);\r\nINIT_LIST_HEAD(&inst->fb_free_list);\r\nINIT_LIST_HEAD(&inst->fb_disp_list);\r\nfor (i = 0; i < ARRAY_SIZE(inst->dec_fb); i++) {\r\nINIT_LIST_HEAD(&inst->dec_fb[i].list);\r\ninst->dec_fb[i].fb = NULL;\r\nlist_add_tail(&inst->dec_fb[i].list,\r\n&inst->available_fb_node_list);\r\n}\r\n}\r\nstatic void get_pic_info(struct vdec_vp9_inst *inst, struct vdec_pic_info *pic)\r\n{\r\npic->y_bs_sz = inst->vsi->buf_sz_y_bs;\r\npic->c_bs_sz = inst->vsi->buf_sz_c_bs;\r\npic->y_len_sz = inst->vsi->buf_len_sz_y;\r\npic->c_len_sz = inst->vsi->buf_len_sz_c;\r\npic->pic_w = inst->vsi->pic_w;\r\npic->pic_h = inst->vsi->pic_h;\r\npic->buf_w = inst->vsi->buf_w;\r\npic->buf_h = inst->vsi->buf_h;\r\nmtk_vcodec_debug(inst, "pic(%d, %d), buf(%d, %d)",\r\npic->pic_w, pic->pic_h, pic->buf_w, pic->buf_h);\r\nmtk_vcodec_debug(inst, "Y(%d, %d), C(%d, %d)", pic->y_bs_sz,\r\npic->y_len_sz, pic->c_bs_sz, pic->c_len_sz);\r\n}\r\nstatic void get_disp_fb(struct vdec_vp9_inst *inst, struct vdec_fb **out_fb)\r\n{\r\n*out_fb = vp9_rm_from_fb_disp_list(inst);\r\nif (*out_fb)\r\n(*out_fb)->status |= FB_ST_DISPLAY;\r\n}\r\nstatic void get_free_fb(struct vdec_vp9_inst *inst, struct vdec_fb **out_fb)\r\n{\r\nstruct vdec_fb_node *node;\r\nstruct vdec_fb *fb = NULL;\r\nnode = list_first_entry_or_null(&inst->fb_free_list,\r\nstruct vdec_fb_node, list);\r\nif (node) {\r\nlist_move_tail(&node->list, &inst->available_fb_node_list);\r\nfb = (struct vdec_fb *)node->fb;\r\nfb->status |= FB_ST_FREE;\r\nmtk_vcodec_debug(inst, "[FB] get free fb %p st=%d",\r\nnode->fb, fb->status);\r\n} else {\r\nmtk_vcodec_debug(inst, "[FB] there is no free fb");\r\n}\r\n*out_fb = fb;\r\n}\r\nstatic void vdec_vp9_deinit(unsigned long h_vdec)\r\n{\r\nstruct vdec_vp9_inst *inst = (struct vdec_vp9_inst *)h_vdec;\r\nstruct mtk_vcodec_mem *mem;\r\nint ret = 0;\r\nret = vpu_dec_deinit(&inst->vpu);\r\nif (ret)\r\nmtk_vcodec_err(inst, "vpu_dec_deinit failed");\r\nmem = &inst->mv_buf;\r\nif (mem->va)\r\nmtk_vcodec_mem_free(inst->ctx, mem);\r\nvp9_free_all_sf_ref_fb(inst);\r\nvp9_free_inst(inst);\r\n}\r\nstatic int vdec_vp9_init(struct mtk_vcodec_ctx *ctx, unsigned long *h_vdec)\r\n{\r\nstruct vdec_vp9_inst *inst;\r\ninst = vp9_alloc_inst(ctx);\r\nif (!inst)\r\nreturn -ENOMEM;\r\ninst->total_frm_cnt = 0;\r\ninst->ctx = ctx;\r\ninst->vpu.id = IPI_VDEC_VP9;\r\ninst->vpu.dev = ctx->dev->vpu_plat_dev;\r\ninst->vpu.ctx = ctx;\r\ninst->vpu.handler = vpu_dec_ipi_handler;\r\nif (vpu_dec_init(&inst->vpu)) {\r\nmtk_vcodec_err(inst, "vp9_dec_vpu_init failed");\r\ngoto err_deinit_inst;\r\n}\r\ninst->vsi = (struct vdec_vp9_vsi *)inst->vpu.vsi;\r\ninit_all_fb_lists(inst);\r\n(*h_vdec) = (unsigned long)inst;\r\nreturn 0;\r\nerr_deinit_inst:\r\nvp9_free_inst(inst);\r\nreturn -EINVAL;\r\n}\r\nstatic int vdec_vp9_decode(unsigned long h_vdec, struct mtk_vcodec_mem *bs,\r\nstruct vdec_fb *fb, bool *res_chg)\r\n{\r\nint ret = 0;\r\nstruct vdec_vp9_inst *inst = (struct vdec_vp9_inst *)h_vdec;\r\nstruct vdec_vp9_vsi *vsi = inst->vsi;\r\nu32 data[3];\r\nint i;\r\n*res_chg = false;\r\nif ((bs == NULL) && (fb == NULL)) {\r\nmtk_vcodec_debug(inst, "[EOS]");\r\nvp9_reset(inst);\r\nreturn ret;\r\n}\r\nif (bs == NULL) {\r\nmtk_vcodec_err(inst, "bs == NULL");\r\nreturn -EINVAL;\r\n}\r\nmtk_vcodec_debug(inst, "Input BS Size = %zu", bs->size);\r\nwhile (1) {\r\nstruct vdec_fb *cur_fb = NULL;\r\ndata[0] = *((unsigned int *)bs->va);\r\ndata[1] = *((unsigned int *)(bs->va + 4));\r\ndata[2] = *((unsigned int *)(bs->va + 8));\r\nvsi->bs = *bs;\r\nif (fb)\r\nvsi->fb = *fb;\r\nif (!vsi->sf_init) {\r\nunsigned int sf_bs_sz;\r\nunsigned int sf_bs_off;\r\nunsigned char *sf_bs_src;\r\nunsigned char *sf_bs_dst;\r\nsf_bs_sz = bs->size > VP9_SUPER_FRAME_BS_SZ ?\r\nVP9_SUPER_FRAME_BS_SZ : bs->size;\r\nsf_bs_off = VP9_SUPER_FRAME_BS_SZ - sf_bs_sz;\r\nsf_bs_src = bs->va + bs->size - sf_bs_sz;\r\nsf_bs_dst = vsi->sf_bs_buf + sf_bs_off;\r\nmemcpy(sf_bs_dst, sf_bs_src, sf_bs_sz);\r\n} else {\r\nif ((vsi->sf_frm_cnt > 0) &&\r\n(vsi->sf_frm_idx < vsi->sf_frm_cnt)) {\r\nunsigned int idx = vsi->sf_frm_idx;\r\nmemcpy((void *)bs->va,\r\n(void *)(bs->va +\r\nvsi->sf_frm_offset[idx]),\r\nvsi->sf_frm_sz[idx]);\r\n}\r\n}\r\nret = vpu_dec_start(&inst->vpu, data, 3);\r\nif (ret) {\r\nmtk_vcodec_err(inst, "vpu_dec_start failed");\r\ngoto DECODE_ERROR;\r\n}\r\nif (vsi->resolution_changed) {\r\nif (!vp9_alloc_work_buf(inst)) {\r\nret = -EINVAL;\r\ngoto DECODE_ERROR;\r\n}\r\n}\r\nif (vsi->sf_frm_cnt > 0) {\r\ncur_fb = &vsi->sf_ref_fb[vsi->sf_next_ref_fb_idx].fb;\r\nif (vsi->sf_frm_idx < vsi->sf_frm_cnt)\r\ninst->cur_fb = cur_fb;\r\nelse\r\ninst->cur_fb = fb;\r\n} else {\r\ninst->cur_fb = fb;\r\n}\r\nvsi->frm_bufs[vsi->new_fb_idx].buf.fb = inst->cur_fb;\r\nif (!vp9_is_sf_ref_fb(inst, inst->cur_fb))\r\nvp9_add_to_fb_use_list(inst, inst->cur_fb);\r\nmtk_vcodec_debug(inst, "[#pic %d]", vsi->frm_num);\r\nif (vsi->show_existing_frame)\r\nmtk_vcodec_debug(inst,\r\n"drv->new_fb_idx=%d, drv->frm_to_show_idx=%d",\r\nvsi->new_fb_idx, vsi->frm_to_show_idx);\r\nif (vsi->show_existing_frame && (vsi->frm_to_show_idx <\r\nVP9_MAX_FRM_BUF_NUM)) {\r\nmtk_vcodec_err(inst,\r\n"Skip Decode drv->new_fb_idx=%d, drv->frm_to_show_idx=%d",\r\nvsi->new_fb_idx, vsi->frm_to_show_idx);\r\nvp9_ref_cnt_fb(inst, &vsi->new_fb_idx,\r\nvsi->frm_to_show_idx);\r\nret = -EINVAL;\r\ngoto DECODE_ERROR;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vsi->frm_refs); i++) {\r\nunsigned int idx = vsi->frm_refs[i].idx;\r\nvsi->frm_refs[i].buf = &vsi->frm_bufs[idx].buf;\r\n}\r\nif (vsi->resolution_changed) {\r\n*res_chg = true;\r\nmtk_vcodec_debug(inst, "VDEC_ST_RESOLUTION_CHANGED");\r\nret = 0;\r\ngoto DECODE_ERROR;\r\n}\r\nif (vp9_decode_end_proc(inst) != true) {\r\nmtk_vcodec_err(inst, "vp9_decode_end_proc");\r\nret = -EINVAL;\r\ngoto DECODE_ERROR;\r\n}\r\nif (vp9_is_last_sub_frm(inst))\r\nbreak;\r\n}\r\ninst->total_frm_cnt++;\r\nDECODE_ERROR:\r\nif (ret < 0)\r\nvp9_add_to_fb_free_list(inst, fb);\r\nreturn ret;\r\n}\r\nstatic void get_crop_info(struct vdec_vp9_inst *inst, struct v4l2_rect *cr)\r\n{\r\ncr->left = 0;\r\ncr->top = 0;\r\ncr->width = inst->vsi->pic_w;\r\ncr->height = inst->vsi->pic_h;\r\nmtk_vcodec_debug(inst, "get crop info l=%d, t=%d, w=%d, h=%d\n",\r\ncr->left, cr->top, cr->width, cr->height);\r\n}\r\nstatic int vdec_vp9_get_param(unsigned long h_vdec,\r\nenum vdec_get_param_type type, void *out)\r\n{\r\nstruct vdec_vp9_inst *inst = (struct vdec_vp9_inst *)h_vdec;\r\nint ret = 0;\r\nswitch (type) {\r\ncase GET_PARAM_DISP_FRAME_BUFFER:\r\nget_disp_fb(inst, out);\r\nbreak;\r\ncase GET_PARAM_FREE_FRAME_BUFFER:\r\nget_free_fb(inst, out);\r\nbreak;\r\ncase GET_PARAM_PIC_INFO:\r\nget_pic_info(inst, out);\r\nbreak;\r\ncase GET_PARAM_DPB_SIZE:\r\n*((unsigned int *)out) = MAX_VP9_DPB_SIZE;\r\nbreak;\r\ncase GET_PARAM_CROP_INFO:\r\nget_crop_info(inst, out);\r\nbreak;\r\ndefault:\r\nmtk_vcodec_err(inst, "not supported param type %d", type);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct vdec_common_if *get_vp9_dec_comm_if(void)\r\n{\r\nreturn &vdec_vp9_if;\r\n}
