static inline int big_key_gen_enckey(u8 *key)\r\n{\r\nreturn crypto_rng_get_bytes(big_key_rng, key, ENC_KEY_SIZE);\r\n}\r\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\r\n{\r\nint ret = -EINVAL;\r\nstruct scatterlist sgio;\r\nSKCIPHER_REQUEST_ON_STACK(req, big_key_skcipher);\r\nif (crypto_skcipher_setkey(big_key_skcipher, key, ENC_KEY_SIZE)) {\r\nret = -EAGAIN;\r\ngoto error;\r\n}\r\nskcipher_request_set_tfm(req, big_key_skcipher);\r\nskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\r\nNULL, NULL);\r\nsg_init_one(&sgio, data, datalen);\r\nskcipher_request_set_crypt(req, &sgio, &sgio, datalen, NULL);\r\nif (op == BIG_KEY_ENC)\r\nret = crypto_skcipher_encrypt(req);\r\nelse\r\nret = crypto_skcipher_decrypt(req);\r\nskcipher_request_zero(req);\r\nerror:\r\nreturn ret;\r\n}\r\nint big_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct path *path = (struct path *)&prep->payload.data[big_key_path];\r\nstruct file *file;\r\nu8 *enckey;\r\nu8 *data = NULL;\r\nssize_t written;\r\nsize_t datalen = prep->datalen;\r\nint ret;\r\nret = -EINVAL;\r\nif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\r\ngoto error;\r\nprep->quotalen = 16;\r\nprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\r\nif (datalen > BIG_KEY_FILE_THRESHOLD) {\r\nsize_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));\r\ndata = kmalloc(enclen, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmemcpy(data, prep->data, datalen);\r\nmemset(data + datalen, 0x00, enclen - datalen);\r\nenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\r\nif (!enckey) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = big_key_gen_enckey(enckey);\r\nif (ret)\r\ngoto err_enckey;\r\nret = big_key_crypt(BIG_KEY_ENC, data, enclen, enckey);\r\nif (ret)\r\ngoto err_enckey;\r\nfile = shmem_kernel_file_setup("", enclen, 0);\r\nif (IS_ERR(file)) {\r\nret = PTR_ERR(file);\r\ngoto err_enckey;\r\n}\r\nwritten = kernel_write(file, data, enclen, 0);\r\nif (written != enclen) {\r\nret = written;\r\nif (written >= 0)\r\nret = -ENOMEM;\r\ngoto err_fput;\r\n}\r\nprep->payload.data[big_key_data] = enckey;\r\n*path = file->f_path;\r\npath_get(path);\r\nfput(file);\r\nkfree(data);\r\n} else {\r\nvoid *data = kmalloc(datalen, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nprep->payload.data[big_key_data] = data;\r\nmemcpy(data, prep->data, prep->datalen);\r\n}\r\nreturn 0;\r\nerr_fput:\r\nfput(file);\r\nerr_enckey:\r\nkfree(enckey);\r\nerror:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\r\n{\r\nif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\r\nstruct path *path = (struct path *)&prep->payload.data[big_key_path];\r\npath_put(path);\r\n}\r\nkfree(prep->payload.data[big_key_data]);\r\n}\r\nvoid big_key_revoke(struct key *key)\r\n{\r\nstruct path *path = (struct path *)&key->payload.data[big_key_path];\r\nkey_payload_reserve(key, 0);\r\nif (key_is_instantiated(key) &&\r\n(size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\r\nvfs_truncate(path, 0);\r\n}\r\nvoid big_key_destroy(struct key *key)\r\n{\r\nsize_t datalen = (size_t)key->payload.data[big_key_len];\r\nif (datalen > BIG_KEY_FILE_THRESHOLD) {\r\nstruct path *path = (struct path *)&key->payload.data[big_key_path];\r\npath_put(path);\r\npath->mnt = NULL;\r\npath->dentry = NULL;\r\n}\r\nkfree(key->payload.data[big_key_data]);\r\nkey->payload.data[big_key_data] = NULL;\r\n}\r\nvoid big_key_describe(const struct key *key, struct seq_file *m)\r\n{\r\nsize_t datalen = (size_t)key->payload.data[big_key_len];\r\nseq_puts(m, key->description);\r\nif (key_is_instantiated(key))\r\nseq_printf(m, ": %zu [%s]",\r\ndatalen,\r\ndatalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff");\r\n}\r\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\r\n{\r\nsize_t datalen = (size_t)key->payload.data[big_key_len];\r\nlong ret;\r\nif (!buffer || buflen < datalen)\r\nreturn datalen;\r\nif (datalen > BIG_KEY_FILE_THRESHOLD) {\r\nstruct path *path = (struct path *)&key->payload.data[big_key_path];\r\nstruct file *file;\r\nu8 *data;\r\nu8 *enckey = (u8 *)key->payload.data[big_key_data];\r\nsize_t enclen = ALIGN(datalen, crypto_skcipher_blocksize(big_key_skcipher));\r\ndata = kmalloc(enclen, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nfile = dentry_open(path, O_RDONLY, current_cred());\r\nif (IS_ERR(file)) {\r\nret = PTR_ERR(file);\r\ngoto error;\r\n}\r\nret = kernel_read(file, 0, data, enclen);\r\nif (ret >= 0 && ret != enclen) {\r\nret = -EIO;\r\ngoto err_fput;\r\n}\r\nret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\r\nif (ret)\r\ngoto err_fput;\r\nret = datalen;\r\nif (copy_to_user(buffer, data, datalen) != 0)\r\nret = -EFAULT;\r\nerr_fput:\r\nfput(file);\r\nerror:\r\nkfree(data);\r\n} else {\r\nret = datalen;\r\nif (copy_to_user(buffer, key->payload.data[big_key_data],\r\ndatalen) != 0)\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init big_key_init(void)\r\n{\r\nstruct crypto_skcipher *cipher;\r\nstruct crypto_rng *rng;\r\nint ret;\r\nrng = crypto_alloc_rng(big_key_rng_name, 0, 0);\r\nif (IS_ERR(rng)) {\r\npr_err("Can't alloc rng: %ld\n", PTR_ERR(rng));\r\nreturn PTR_ERR(rng);\r\n}\r\nbig_key_rng = rng;\r\nret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\r\nif (ret) {\r\npr_err("Can't reset rng: %d\n", ret);\r\ngoto error_rng;\r\n}\r\ncipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(cipher)) {\r\nret = PTR_ERR(cipher);\r\npr_err("Can't alloc crypto: %d\n", ret);\r\ngoto error_rng;\r\n}\r\nbig_key_skcipher = cipher;\r\nret = register_key_type(&key_type_big_key);\r\nif (ret < 0) {\r\npr_err("Can't register type: %d\n", ret);\r\ngoto error_cipher;\r\n}\r\nreturn 0;\r\nerror_cipher:\r\ncrypto_free_skcipher(big_key_skcipher);\r\nerror_rng:\r\ncrypto_free_rng(big_key_rng);\r\nreturn ret;\r\n}
