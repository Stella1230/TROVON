static void asus_report_contact_down(struct input_dev *input,\r\nint toolType, u8 *data)\r\n{\r\nint touch_major, pressure;\r\nint x = (data[0] & CONTACT_X_MSB_MASK) << 4 | data[1];\r\nint y = MAX_Y - ((data[0] & CONTACT_Y_MSB_MASK) << 8 | data[2]);\r\nif (toolType == MT_TOOL_PALM) {\r\ntouch_major = MAX_TOUCH_MAJOR;\r\npressure = MAX_PRESSURE;\r\n} else {\r\ntouch_major = (data[3] >> 4) & CONTACT_TOUCH_MAJOR_MASK;\r\npressure = data[4] & CONTACT_PRESSURE_MASK;\r\n}\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, touch_major);\r\ninput_report_abs(input, ABS_MT_PRESSURE, pressure);\r\n}\r\nstatic void asus_report_tool_width(struct input_dev *input)\r\n{\r\nstruct input_mt *mt = input->mt;\r\nstruct input_mt_slot *oldest;\r\nint oldid, count, i;\r\noldest = NULL;\r\noldid = mt->trkid;\r\ncount = 0;\r\nfor (i = 0; i < mt->num_slots; ++i) {\r\nstruct input_mt_slot *ps = &mt->slots[i];\r\nint id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);\r\nif (id < 0)\r\ncontinue;\r\nif ((id - oldid) & TRKID_SGN) {\r\noldest = ps;\r\noldid = id;\r\n}\r\ncount++;\r\n}\r\nif (oldest) {\r\ninput_report_abs(input, ABS_TOOL_WIDTH,\r\ninput_mt_get_value(oldest, ABS_MT_TOUCH_MAJOR));\r\n}\r\n}\r\nstatic void asus_report_input(struct input_dev *input, u8 *data)\r\n{\r\nint i;\r\nu8 *contactData = data + 2;\r\nfor (i = 0; i < MAX_CONTACTS; i++) {\r\nbool down = !!(data[1] & BIT(i+3));\r\nint toolType = contactData[3] & CONTACT_TOOL_TYPE_MASK ?\r\nMT_TOOL_PALM : MT_TOOL_FINGER;\r\ninput_mt_slot(input, i);\r\ninput_mt_report_slot_state(input, toolType, down);\r\nif (down) {\r\nasus_report_contact_down(input, toolType, contactData);\r\ncontactData += CONTACT_DATA_SIZE;\r\n}\r\n}\r\ninput_report_key(input, BTN_LEFT, data[1] & BTN_LEFT_MASK);\r\nasus_report_tool_width(input);\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\n}\r\nstatic int asus_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif (drvdata->quirks & QUIRK_IS_MULTITOUCH &&\r\ndata[0] == INPUT_REPORT_ID &&\r\nsize == INPUT_REPORT_SIZE) {\r\nasus_report_input(drvdata->input, data);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int asus_input_configured(struct hid_device *hdev, struct hid_input *hi)\r\n{\r\nstruct input_dev *input = hi->input;\r\nstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif (drvdata->quirks & QUIRK_IS_MULTITOUCH) {\r\nint ret;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, MAX_X, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, MAX_Y, 0, 0);\r\ninput_set_abs_params(input, ABS_TOOL_WIDTH, 0, MAX_TOUCH_MAJOR, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, MAX_TOUCH_MAJOR, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, MAX_PRESSURE, 0, 0);\r\n__set_bit(BTN_LEFT, input->keybit);\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\nret = input_mt_init_slots(input, MAX_CONTACTS, INPUT_MT_POINTER);\r\nif (ret) {\r\nhid_err(hdev, "Asus input mt init slots failed: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\ndrvdata->input = input;\r\nreturn 0;\r\n}\r\nstatic int asus_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit,\r\nint *max)\r\n{\r\nstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif (drvdata->quirks & QUIRK_SKIP_INPUT_MAPPING) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int asus_start_multitouch(struct hid_device *hdev)\r\n{\r\nint ret;\r\nconst unsigned char buf[] = { FEATURE_REPORT_ID, 0x00, 0x03, 0x01, 0x00 };\r\nunsigned char *dmabuf = kmemdup(buf, sizeof(buf), GFP_KERNEL);\r\nif (!dmabuf) {\r\nret = -ENOMEM;\r\nhid_err(hdev, "Asus failed to alloc dma buf: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = hid_hw_raw_request(hdev, dmabuf[0], dmabuf, sizeof(buf),\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nkfree(dmabuf);\r\nif (ret != sizeof(buf)) {\r\nhid_err(hdev, "Asus failed to start multitouch: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused asus_reset_resume(struct hid_device *hdev)\r\n{\r\nstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif (drvdata->quirks & QUIRK_IS_MULTITOUCH)\r\nreturn asus_start_multitouch(hdev);\r\nreturn 0;\r\n}\r\nstatic int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct asus_drvdata *drvdata;\r\ndrvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (drvdata == NULL) {\r\nhid_err(hdev, "Can't alloc Asus descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, drvdata);\r\ndrvdata->quirks = id->driver_data;\r\nif (drvdata->quirks & QUIRK_NO_INIT_REPORTS)\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "Asus hid parse failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "Asus hw start failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!drvdata->input) {\r\nhid_err(hdev, "Asus input not registered\n");\r\nret = -ENOMEM;\r\ngoto err_stop_hw;\r\n}\r\nif (drvdata->quirks & QUIRK_IS_MULTITOUCH) {\r\ndrvdata->input->name = "Asus TouchPad";\r\n} else {\r\ndrvdata->input->name = "Asus Keyboard";\r\n}\r\nif (drvdata->quirks & QUIRK_IS_MULTITOUCH) {\r\nret = asus_start_multitouch(hdev);\r\nif (ret)\r\ngoto err_stop_hw;\r\n}\r\nreturn 0;\r\nerr_stop_hw:\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\nstatic __u8 *asus_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nstruct asus_drvdata *drvdata = hid_get_drvdata(hdev);\r\nif (drvdata->quirks & QUIRK_FIX_NOTEBOOK_REPORT &&\r\n*rsize >= 56 && rdesc[54] == 0x25 && rdesc[55] == 0x65) {\r\nhid_info(hdev, "Fixing up Asus notebook report descriptor\n");\r\nrdesc[55] = 0xdd;\r\n}\r\nreturn rdesc;\r\n}
