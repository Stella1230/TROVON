static void tango_cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)\r\n{\r\nstruct tango_chip *tchip = to_tango_chip(mtd_to_nand(mtd));\r\nif (ctrl & NAND_CLE)\r\nwriteb_relaxed(dat, tchip->base + PBUS_CMD);\r\nif (ctrl & NAND_ALE)\r\nwriteb_relaxed(dat, tchip->base + PBUS_ADDR);\r\n}\r\nstatic int tango_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct tango_nfc *nfc = to_tango_nfc(chip->controller);\r\nreturn readl_relaxed(nfc->pbus_base + PBUS_CS_CTRL) & PBUS_IORDY;\r\n}\r\nstatic u8 tango_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct tango_chip *tchip = to_tango_chip(mtd_to_nand(mtd));\r\nreturn readb_relaxed(tchip->base + PBUS_DATA);\r\n}\r\nstatic void tango_read_buf(struct mtd_info *mtd, u8 *buf, int len)\r\n{\r\nstruct tango_chip *tchip = to_tango_chip(mtd_to_nand(mtd));\r\nioread8_rep(tchip->base + PBUS_DATA, buf, len);\r\n}\r\nstatic void tango_write_buf(struct mtd_info *mtd, const u8 *buf, int len)\r\n{\r\nstruct tango_chip *tchip = to_tango_chip(mtd_to_nand(mtd));\r\niowrite8_rep(tchip->base + PBUS_DATA, buf, len);\r\n}\r\nstatic void tango_select_chip(struct mtd_info *mtd, int idx)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct tango_nfc *nfc = to_tango_nfc(chip->controller);\r\nstruct tango_chip *tchip = to_tango_chip(chip);\r\nif (idx < 0)\r\nreturn;\r\nwritel_relaxed(tchip->timing1, nfc->reg_base + NFC_TIMING1);\r\nwritel_relaxed(tchip->timing2, nfc->reg_base + NFC_TIMING2);\r\nwritel_relaxed(tchip->xfer_cfg, nfc->reg_base + NFC_XFER_CFG);\r\nwritel_relaxed(tchip->pkt_0_cfg, nfc->reg_base + NFC_PKT_0_CFG);\r\nwritel_relaxed(tchip->pkt_n_cfg, nfc->reg_base + NFC_PKT_N_CFG);\r\nwritel_relaxed(tchip->bb_cfg, nfc->reg_base + NFC_BB_CFG);\r\n}\r\nstatic int check_erased_page(struct nand_chip *chip, u8 *buf)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nu8 *meta = chip->oob_poi + BBM_SIZE;\r\nu8 *ecc = chip->oob_poi + BBM_SIZE + METADATA_SIZE;\r\nconst int ecc_size = chip->ecc.bytes;\r\nconst int pkt_size = chip->ecc.size;\r\nint i, res, meta_len, bitflips = 0;\r\nfor (i = 0; i < chip->ecc.steps; ++i) {\r\nmeta_len = i ? 0 : METADATA_SIZE;\r\nres = nand_check_erased_ecc_chunk(buf, pkt_size, ecc, ecc_size,\r\nmeta, meta_len,\r\nchip->ecc.strength);\r\nif (res < 0)\r\nmtd->ecc_stats.failed++;\r\nbitflips = max(res, bitflips);\r\nbuf += pkt_size;\r\necc += ecc_size;\r\n}\r\nreturn bitflips;\r\n}\r\nstatic int decode_error_report(struct tango_nfc *nfc)\r\n{\r\nu32 status, res;\r\nstatus = readl_relaxed(nfc->reg_base + NFC_XFER_STATUS);\r\nif (status & PAGE_IS_EMPTY)\r\nreturn 0;\r\nres = readl_relaxed(nfc->mem_base + ERROR_REPORT);\r\nif (DECODE_OK_PKT_0(res) && DECODE_OK_PKT_N(res))\r\nreturn max(ERR_COUNT_PKT_0(res), ERR_COUNT_PKT_N(res));\r\nreturn -EBADMSG;\r\n}\r\nstatic void tango_dma_callback(void *arg)\r\n{\r\ncomplete(arg);\r\n}\r\nstatic int do_dma(struct tango_nfc *nfc, int dir, int cmd, const void *buf,\r\nint len, int page)\r\n{\r\nvoid __iomem *addr = nfc->reg_base + NFC_STATUS;\r\nstruct dma_chan *chan = nfc->chan;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct scatterlist sg;\r\nstruct completion tx_done;\r\nint err = -EIO;\r\nu32 res, val;\r\nsg_init_one(&sg, buf, len);\r\nif (dma_map_sg(chan->device->dev, &sg, 1, dir) != 1)\r\nreturn -EIO;\r\ndesc = dmaengine_prep_slave_sg(chan, &sg, 1, dir, DMA_PREP_INTERRUPT);\r\nif (!desc)\r\ngoto dma_unmap;\r\ndesc->callback = tango_dma_callback;\r\ndesc->callback_param = &tx_done;\r\ninit_completion(&tx_done);\r\nwritel_relaxed(MODE_NFC, nfc->pbus_base + PBUS_PAD_MODE);\r\nwritel_relaxed(page, nfc->reg_base + NFC_ADDR_PAGE);\r\nwritel_relaxed(0, nfc->reg_base + NFC_ADDR_OFFSET);\r\nwritel_relaxed(cmd, nfc->reg_base + NFC_FLASH_CMD);\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\nres = wait_for_completion_timeout(&tx_done, HZ);\r\nif (res > 0)\r\nerr = readl_poll_timeout(addr, val, val & CMD_READY, 0, 1000);\r\nwritel_relaxed(MODE_RAW, nfc->pbus_base + PBUS_PAD_MODE);\r\ndma_unmap:\r\ndma_unmap_sg(chan->device->dev, &sg, 1, dir);\r\nreturn err;\r\n}\r\nstatic int tango_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nu8 *buf, int oob_required, int page)\r\n{\r\nstruct tango_nfc *nfc = to_tango_nfc(chip->controller);\r\nint err, res, len = mtd->writesize;\r\nif (oob_required)\r\nchip->ecc.read_oob(mtd, chip, page);\r\nerr = do_dma(nfc, DMA_FROM_DEVICE, NFC_READ, buf, len, page);\r\nif (err)\r\nreturn err;\r\nres = decode_error_report(nfc);\r\nif (res < 0) {\r\nchip->ecc.read_oob_raw(mtd, chip, page);\r\nres = check_erased_page(chip, buf);\r\n}\r\nreturn res;\r\n}\r\nstatic int tango_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst u8 *buf, int oob_required, int page)\r\n{\r\nstruct tango_nfc *nfc = to_tango_nfc(chip->controller);\r\nint err, len = mtd->writesize;\r\nif (oob_required)\r\nreturn -ENOTSUPP;\r\nwritel_relaxed(0xffffffff, nfc->mem_base + METADATA);\r\nerr = do_dma(nfc, DMA_TO_DEVICE, NFC_WRITE, buf, len, page);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void aux_read(struct nand_chip *chip, u8 **buf, int len, int *pos)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\n*pos += len;\r\nif (!*buf) {\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, *pos, -1);\r\n} else {\r\ntango_read_buf(mtd, *buf, len);\r\n*buf += len;\r\n}\r\n}\r\nstatic void aux_write(struct nand_chip *chip, const u8 **buf, int len, int *pos)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\n*pos += len;\r\nif (!*buf) {\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, *pos, -1);\r\n} else {\r\ntango_write_buf(mtd, *buf, len);\r\n*buf += len;\r\n}\r\n}\r\nstatic void raw_read(struct nand_chip *chip, u8 *buf, u8 *oob)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nu8 *oob_orig = oob;\r\nconst int page_size = mtd->writesize;\r\nconst int ecc_size = chip->ecc.bytes;\r\nconst int pkt_size = chip->ecc.size;\r\nint pos = 0;\r\nint rem = page_size;\r\nif (oob)\r\noob += BBM_SIZE;\r\naux_read(chip, &oob, METADATA_SIZE, &pos);\r\nwhile (rem > pkt_size) {\r\naux_read(chip, &buf, pkt_size, &pos);\r\naux_read(chip, &oob, ecc_size, &pos);\r\nrem = page_size - pos;\r\n}\r\naux_read(chip, &buf, rem, &pos);\r\naux_read(chip, &oob_orig, BBM_SIZE, &pos);\r\naux_read(chip, &buf, pkt_size - rem, &pos);\r\naux_read(chip, &oob, ecc_size, &pos);\r\n}\r\nstatic void raw_write(struct nand_chip *chip, const u8 *buf, const u8 *oob)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nconst u8 *oob_orig = oob;\r\nconst int page_size = mtd->writesize;\r\nconst int ecc_size = chip->ecc.bytes;\r\nconst int pkt_size = chip->ecc.size;\r\nint pos = 0;\r\nint rem = page_size;\r\nif (oob)\r\noob += BBM_SIZE;\r\naux_write(chip, &oob, METADATA_SIZE, &pos);\r\nwhile (rem > pkt_size) {\r\naux_write(chip, &buf, pkt_size, &pos);\r\naux_write(chip, &oob, ecc_size, &pos);\r\nrem = page_size - pos;\r\n}\r\naux_write(chip, &buf, rem, &pos);\r\naux_write(chip, &oob_orig, BBM_SIZE, &pos);\r\naux_write(chip, &buf, pkt_size - rem, &pos);\r\naux_write(chip, &oob, ecc_size, &pos);\r\n}\r\nstatic int tango_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nu8 *buf, int oob_required, int page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nraw_read(chip, buf, chip->oob_poi);\r\nreturn 0;\r\n}\r\nstatic int tango_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst u8 *buf, int oob_required, int page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);\r\nraw_write(chip, buf, chip->oob_poi);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nreturn 0;\r\n}\r\nstatic int tango_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nraw_read(chip, NULL, chip->oob_poi);\r\nreturn 0;\r\n}\r\nstatic int tango_write_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);\r\nraw_write(chip, NULL, chip->oob_poi);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nchip->waitfunc(mtd, chip);\r\nreturn 0;\r\n}\r\nstatic int oob_ecc(struct mtd_info *mtd, int idx, struct mtd_oob_region *res)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nif (idx >= ecc->steps)\r\nreturn -ERANGE;\r\nres->offset = BBM_SIZE + METADATA_SIZE + ecc->bytes * idx;\r\nres->length = ecc->bytes;\r\nreturn 0;\r\n}\r\nstatic int oob_free(struct mtd_info *mtd, int idx, struct mtd_oob_region *res)\r\n{\r\nreturn -ERANGE;\r\n}\r\nstatic u32 to_ticks(int kHz, int ps)\r\n{\r\nreturn DIV_ROUND_UP_ULL((u64)kHz * ps, NSEC_PER_SEC);\r\n}\r\nstatic int tango_set_timings(struct mtd_info *mtd,\r\nconst struct nand_data_interface *conf,\r\nbool check_only)\r\n{\r\nconst struct nand_sdr_timings *sdr = nand_get_sdr_timings(conf);\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct tango_nfc *nfc = to_tango_nfc(chip->controller);\r\nstruct tango_chip *tchip = to_tango_chip(chip);\r\nu32 Trdy, Textw, Twc, Twpw, Tacc, Thold, Trpw, Textr;\r\nint kHz = nfc->freq_kHz;\r\nif (IS_ERR(sdr))\r\nreturn PTR_ERR(sdr);\r\nif (check_only)\r\nreturn 0;\r\nTrdy = to_ticks(kHz, sdr->tCEA_max - sdr->tREA_max);\r\nTextw = to_ticks(kHz, sdr->tWB_max);\r\nTwc = to_ticks(kHz, sdr->tWC_min);\r\nTwpw = to_ticks(kHz, sdr->tWC_min - sdr->tWP_min);\r\nTacc = to_ticks(kHz, sdr->tREA_max);\r\nThold = to_ticks(kHz, sdr->tREH_min);\r\nTrpw = to_ticks(kHz, sdr->tRC_min - sdr->tREH_min);\r\nTextr = to_ticks(kHz, sdr->tRHZ_max);\r\ntchip->timing1 = TIMING(Trdy, Textw, Twc, Twpw);\r\ntchip->timing2 = TIMING(Tacc, Thold, Trpw, Textr);\r\nreturn 0;\r\n}\r\nstatic int chip_init(struct device *dev, struct device_node *np)\r\n{\r\nu32 cs;\r\nint err, res;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *chip;\r\nstruct tango_chip *tchip;\r\nstruct nand_ecc_ctrl *ecc;\r\nstruct tango_nfc *nfc = dev_get_drvdata(dev);\r\ntchip = devm_kzalloc(dev, sizeof(*tchip), GFP_KERNEL);\r\nif (!tchip)\r\nreturn -ENOMEM;\r\nres = of_property_count_u32_elems(np, "reg");\r\nif (res < 0)\r\nreturn res;\r\nif (res != 1)\r\nreturn -ENOTSUPP;\r\nerr = of_property_read_u32_index(np, "reg", 0, &cs);\r\nif (err)\r\nreturn err;\r\nif (cs >= MAX_CS)\r\nreturn -EINVAL;\r\nchip = &tchip->nand_chip;\r\necc = &chip->ecc;\r\nmtd = nand_to_mtd(chip);\r\nchip->read_byte = tango_read_byte;\r\nchip->write_buf = tango_write_buf;\r\nchip->read_buf = tango_read_buf;\r\nchip->select_chip = tango_select_chip;\r\nchip->cmd_ctrl = tango_cmd_ctrl;\r\nchip->dev_ready = tango_dev_ready;\r\nchip->setup_data_interface = tango_set_timings;\r\nchip->options = NAND_USE_BOUNCE_BUFFER |\r\nNAND_NO_SUBPAGE_WRITE |\r\nNAND_WAIT_TCCS;\r\nchip->controller = &nfc->hw;\r\ntchip->base = nfc->pbus_base + (cs * 256);\r\nnand_set_flash_node(chip, np);\r\nmtd_set_ooblayout(mtd, &tango_nand_ooblayout_ops);\r\nmtd->dev.parent = dev;\r\nerr = nand_scan_ident(mtd, 1, NULL);\r\nif (err)\r\nreturn err;\r\necc->mode = NAND_ECC_HW;\r\necc->algo = NAND_ECC_BCH;\r\necc->bytes = DIV_ROUND_UP(ecc->strength * FIELD_ORDER, BITS_PER_BYTE);\r\necc->read_page_raw = tango_read_page_raw;\r\necc->write_page_raw = tango_write_page_raw;\r\necc->read_page = tango_read_page;\r\necc->write_page = tango_write_page;\r\necc->read_oob = tango_read_oob;\r\necc->write_oob = tango_write_oob;\r\necc->options = NAND_ECC_CUSTOM_PAGE_ACCESS;\r\nerr = nand_scan_tail(mtd);\r\nif (err)\r\nreturn err;\r\ntchip->xfer_cfg = XFER_CFG(cs, 1, ecc->steps, METADATA_SIZE);\r\ntchip->pkt_0_cfg = PKT_CFG(ecc->size + METADATA_SIZE, ecc->strength);\r\ntchip->pkt_n_cfg = PKT_CFG(ecc->size, ecc->strength);\r\ntchip->bb_cfg = BB_CFG(mtd->writesize, BBM_SIZE);\r\nerr = mtd_device_register(mtd, NULL, 0);\r\nif (err)\r\nreturn err;\r\nnfc->chips[cs] = tchip;\r\nreturn 0;\r\n}\r\nstatic int tango_nand_remove(struct platform_device *pdev)\r\n{\r\nint cs;\r\nstruct tango_nfc *nfc = platform_get_drvdata(pdev);\r\ndma_release_channel(nfc->chan);\r\nfor (cs = 0; cs < MAX_CS; ++cs) {\r\nif (nfc->chips[cs])\r\nnand_release(nand_to_mtd(&nfc->chips[cs]->nand_chip));\r\n}\r\nreturn 0;\r\n}\r\nstatic int tango_nand_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct clk *clk;\r\nstruct resource *res;\r\nstruct tango_nfc *nfc;\r\nstruct device_node *np;\r\nnfc = devm_kzalloc(&pdev->dev, sizeof(*nfc), GFP_KERNEL);\r\nif (!nfc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnfc->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(nfc->reg_base))\r\nreturn PTR_ERR(nfc->reg_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nnfc->mem_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(nfc->mem_base))\r\nreturn PTR_ERR(nfc->mem_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nnfc->pbus_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(nfc->pbus_base))\r\nreturn PTR_ERR(nfc->pbus_base);\r\nwritel_relaxed(MODE_RAW, nfc->pbus_base + PBUS_PAD_MODE);\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nnfc->chan = dma_request_chan(&pdev->dev, "rxtx");\r\nif (IS_ERR(nfc->chan))\r\nreturn PTR_ERR(nfc->chan);\r\nplatform_set_drvdata(pdev, nfc);\r\nnand_hw_control_init(&nfc->hw);\r\nnfc->freq_kHz = clk_get_rate(clk) / 1000;\r\nfor_each_child_of_node(pdev->dev.of_node, np) {\r\nerr = chip_init(&pdev->dev, np);\r\nif (err) {\r\ntango_nand_remove(pdev);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}
