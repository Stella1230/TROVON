static inline\r\nstruct mdp5_kms *get_kms(struct mdp5_smp *smp)\r\n{\r\nstruct msm_drm_private *priv = smp->dev->dev_private;\r\nreturn to_mdp5_kms(to_mdp_kms(priv->kms));\r\n}\r\nstatic inline u32 pipe2client(enum mdp5_pipe pipe, int plane)\r\n{\r\n#define CID_UNUSED 0\r\nif (WARN_ON(plane >= pipe2nclients(pipe)))\r\nreturn CID_UNUSED;\r\nreturn mdp5_cfg->smp.clients[pipe] + plane;\r\n}\r\nstatic int smp_request_block(struct mdp5_smp *smp,\r\nstruct mdp5_smp_state *state,\r\nu32 cid, int nblks)\r\n{\r\nvoid *cs = state->client_state[cid];\r\nint i, avail, cnt = smp->blk_cnt;\r\nuint8_t reserved;\r\nWARN_ON(bitmap_weight(cs, cnt) > 0);\r\nreserved = smp->reserved[cid];\r\nif (reserved) {\r\nnblks = max(0, nblks - reserved);\r\nDBG("%d MMBs allocated (%d reserved)", nblks, reserved);\r\n}\r\navail = cnt - bitmap_weight(state->state, cnt);\r\nif (nblks > avail) {\r\ndev_err(smp->dev->dev, "out of blks (req=%d > avail=%d)\n",\r\nnblks, avail);\r\nreturn -ENOSPC;\r\n}\r\nfor (i = 0; i < nblks; i++) {\r\nint blk = find_first_zero_bit(state->state, cnt);\r\nset_bit(blk, cs);\r\nset_bit(blk, state->state);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_fifo_thresholds(struct mdp5_smp *smp,\r\nenum mdp5_pipe pipe, int nblks)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nu32 smp_entries_per_blk = smp->blk_size / (128 / BITS_PER_BYTE);\r\nu32 val;\r\nval = (nblks * smp_entries_per_blk) / 4;\r\nmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_0(pipe), val * 1);\r\nmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_1(pipe), val * 2);\r\nmdp5_write(mdp5_kms, REG_MDP5_PIPE_REQPRIO_FIFO_WM_2(pipe), val * 3);\r\n}\r\nuint32_t mdp5_smp_calculate(struct mdp5_smp *smp,\r\nconst struct mdp_format *format,\r\nu32 width, bool hdecim)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nint rev = mdp5_cfg_get_hw_rev(mdp5_kms->cfg);\r\nint i, hsub, nplanes, nlines;\r\nu32 fmt = format->base.pixel_format;\r\nuint32_t blkcfg = 0;\r\nnplanes = drm_format_num_planes(fmt);\r\nhsub = drm_format_horz_chroma_subsampling(fmt);\r\nnlines = 2;\r\nif ((rev > 0) && (format->chroma_sample > CHROMA_FULL)) {\r\nfmt = DRM_FORMAT_NV24;\r\nnplanes = 2;\r\nif (hdecim && (hsub > 1))\r\nhsub = 1;\r\n}\r\nfor (i = 0; i < nplanes; i++) {\r\nint n, fetch_stride, cpp;\r\ncpp = drm_format_plane_cpp(fmt, i);\r\nfetch_stride = width * cpp / (i ? hsub : 1);\r\nn = DIV_ROUND_UP(fetch_stride * nlines, smp->blk_size);\r\nif (rev == 0)\r\nn = roundup_pow_of_two(n);\r\nblkcfg |= (n << (8 * i));\r\n}\r\nreturn blkcfg;\r\n}\r\nint mdp5_smp_assign(struct mdp5_smp *smp, struct mdp5_smp_state *state,\r\nenum mdp5_pipe pipe, uint32_t blkcfg)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nstruct drm_device *dev = mdp5_kms->dev;\r\nint i, ret;\r\nfor (i = 0; i < pipe2nclients(pipe); i++) {\r\nu32 cid = pipe2client(pipe, i);\r\nint n = blkcfg & 0xff;\r\nif (!n)\r\ncontinue;\r\nDBG("%s[%d]: request %d SMP blocks", pipe2name(pipe), i, n);\r\nret = smp_request_block(smp, state, cid, n);\r\nif (ret) {\r\ndev_err(dev->dev, "Cannot allocate %d SMP blocks: %d\n",\r\nn, ret);\r\nreturn ret;\r\n}\r\nblkcfg >>= 8;\r\n}\r\nstate->assigned |= (1 << pipe);\r\nreturn 0;\r\n}\r\nvoid mdp5_smp_release(struct mdp5_smp *smp, struct mdp5_smp_state *state,\r\nenum mdp5_pipe pipe)\r\n{\r\nint i;\r\nint cnt = smp->blk_cnt;\r\nfor (i = 0; i < pipe2nclients(pipe); i++) {\r\nu32 cid = pipe2client(pipe, i);\r\nvoid *cs = state->client_state[cid];\r\nbitmap_andnot(state->state, state->state, cs, cnt);\r\nbitmap_zero(cs, cnt);\r\n}\r\nstate->released |= (1 << pipe);\r\n}\r\nstatic unsigned update_smp_state(struct mdp5_smp *smp,\r\nu32 cid, mdp5_smp_state_t *assigned)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nint cnt = smp->blk_cnt;\r\nunsigned nblks = 0;\r\nu32 blk, val;\r\nfor_each_set_bit(blk, *assigned, cnt) {\r\nint idx = blk / 3;\r\nint fld = blk % 3;\r\nval = mdp5_read(mdp5_kms, REG_MDP5_SMP_ALLOC_W_REG(idx));\r\nswitch (fld) {\r\ncase 0:\r\nval &= ~MDP5_SMP_ALLOC_W_REG_CLIENT0__MASK;\r\nval |= MDP5_SMP_ALLOC_W_REG_CLIENT0(cid);\r\nbreak;\r\ncase 1:\r\nval &= ~MDP5_SMP_ALLOC_W_REG_CLIENT1__MASK;\r\nval |= MDP5_SMP_ALLOC_W_REG_CLIENT1(cid);\r\nbreak;\r\ncase 2:\r\nval &= ~MDP5_SMP_ALLOC_W_REG_CLIENT2__MASK;\r\nval |= MDP5_SMP_ALLOC_W_REG_CLIENT2(cid);\r\nbreak;\r\n}\r\nmdp5_write(mdp5_kms, REG_MDP5_SMP_ALLOC_W_REG(idx), val);\r\nmdp5_write(mdp5_kms, REG_MDP5_SMP_ALLOC_R_REG(idx), val);\r\nnblks++;\r\n}\r\nreturn nblks;\r\n}\r\nvoid mdp5_smp_prepare_commit(struct mdp5_smp *smp, struct mdp5_smp_state *state)\r\n{\r\nenum mdp5_pipe pipe;\r\nfor_each_set_bit(pipe, &state->assigned, sizeof(state->assigned) * 8) {\r\nunsigned i, nblks = 0;\r\nfor (i = 0; i < pipe2nclients(pipe); i++) {\r\nu32 cid = pipe2client(pipe, i);\r\nvoid *cs = state->client_state[cid];\r\nnblks += update_smp_state(smp, cid, cs);\r\nDBG("assign %s:%u, %u blks",\r\npipe2name(pipe), i, nblks);\r\n}\r\nset_fifo_thresholds(smp, pipe, nblks);\r\n}\r\nstate->assigned = 0;\r\n}\r\nvoid mdp5_smp_complete_commit(struct mdp5_smp *smp, struct mdp5_smp_state *state)\r\n{\r\nenum mdp5_pipe pipe;\r\nfor_each_set_bit(pipe, &state->released, sizeof(state->released) * 8) {\r\nDBG("release %s", pipe2name(pipe));\r\nset_fifo_thresholds(smp, pipe, 0);\r\n}\r\nstate->released = 0;\r\n}\r\nvoid mdp5_smp_dump(struct mdp5_smp *smp, struct drm_printer *p)\r\n{\r\nstruct mdp5_kms *mdp5_kms = get_kms(smp);\r\nstruct mdp5_hw_pipe_state *hwpstate;\r\nstruct mdp5_smp_state *state;\r\nint total = 0, i, j;\r\ndrm_printf(p, "name\tinuse\tplane\n");\r\ndrm_printf(p, "----\t-----\t-----\n");\r\nif (drm_can_sleep())\r\ndrm_modeset_lock(&mdp5_kms->state_lock, NULL);\r\nhwpstate = &mdp5_kms->state->hwpipe;\r\nstate = &mdp5_kms->state->smp;\r\nfor (i = 0; i < mdp5_kms->num_hwpipes; i++) {\r\nstruct mdp5_hw_pipe *hwpipe = mdp5_kms->hwpipes[i];\r\nstruct drm_plane *plane = hwpstate->hwpipe_to_plane[hwpipe->idx];\r\nenum mdp5_pipe pipe = hwpipe->pipe;\r\nfor (j = 0; j < pipe2nclients(pipe); j++) {\r\nu32 cid = pipe2client(pipe, j);\r\nvoid *cs = state->client_state[cid];\r\nint inuse = bitmap_weight(cs, smp->blk_cnt);\r\ndrm_printf(p, "%s:%d\t%d\t%s\n",\r\npipe2name(pipe), j, inuse,\r\nplane ? plane->name : NULL);\r\ntotal += inuse;\r\n}\r\n}\r\ndrm_printf(p, "TOTAL:\t%d\t(of %d)\n", total, smp->blk_cnt);\r\ndrm_printf(p, "AVAIL:\t%d\n", smp->blk_cnt -\r\nbitmap_weight(state->state, smp->blk_cnt));\r\nif (drm_can_sleep())\r\ndrm_modeset_unlock(&mdp5_kms->state_lock);\r\n}\r\nvoid mdp5_smp_destroy(struct mdp5_smp *smp)\r\n{\r\nkfree(smp);\r\n}\r\nstruct mdp5_smp *mdp5_smp_init(struct mdp5_kms *mdp5_kms, const struct mdp5_smp_block *cfg)\r\n{\r\nstruct mdp5_smp_state *state = &mdp5_kms->state->smp;\r\nstruct mdp5_smp *smp = NULL;\r\nint ret;\r\nsmp = kzalloc(sizeof(*smp), GFP_KERNEL);\r\nif (unlikely(!smp)) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nsmp->dev = mdp5_kms->dev;\r\nsmp->blk_cnt = cfg->mmb_count;\r\nsmp->blk_size = cfg->mmb_size;\r\nbitmap_copy(state->state, cfg->reserved_state, smp->blk_cnt);\r\nmemcpy(smp->reserved, cfg->reserved, sizeof(smp->reserved));\r\nreturn smp;\r\nfail:\r\nif (smp)\r\nmdp5_smp_destroy(smp);\r\nreturn ERR_PTR(ret);\r\n}
