static int stih_cec_adap_enable(struct cec_adapter *adap, bool enable)\r\n{\r\nstruct stih_cec *cec = adap->priv;\r\nif (enable) {\r\nunsigned long clk_freq = clk_get_rate(cec->clk);\r\nu32 cec_clk_div = clk_freq / 10000;\r\nwritel(cec_clk_div, cec->regs + CEC_CLK_DIV);\r\nwritel(CEC_SBIT_TOUT_47MS | (CEC_DBIT_TOUT_28MS << 4),\r\ncec->regs + CEC_BIT_TOUT_THRESH);\r\nwritel(CEC_BIT_LPULSE_03MS | CEC_BIT_HPULSE_03MS,\r\ncec->regs + CEC_BIT_PULSE_THRESH);\r\nwritel(BIT(5) | BIT(7), cec->regs + CEC_TX_CTRL);\r\nwritel(CEC_TX_ARRAY_EN | CEC_RX_ARRAY_EN | CEC_TX_STOP_ON_NACK,\r\ncec->regs + CEC_DATA_ARRAY_CTRL);\r\nwritel(CEC_IN_FILTER_EN | CEC_EN | CEC_RX_RESET_EN,\r\ncec->regs + CEC_CTRL);\r\nwritel(0, cec->regs + CEC_ADDR_TABLE);\r\nwritel(0x0, cec->regs + CEC_STATUS);\r\nwritel(CEC_TX_DONE_IRQ_EN | CEC_RX_DONE_IRQ_EN |\r\nCEC_RX_SOM_IRQ_EN | CEC_RX_EOM_IRQ_EN |\r\nCEC_ERROR_IRQ_EN,\r\ncec->regs + CEC_IRQ_CTRL);\r\n} else {\r\nwritel(0, cec->regs + CEC_ADDR_TABLE);\r\nwritel(0x0, cec->regs + CEC_STATUS);\r\nwritel(0, cec->regs + CEC_IRQ_CTRL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stih_cec_adap_log_addr(struct cec_adapter *adap, u8 logical_addr)\r\n{\r\nstruct stih_cec *cec = adap->priv;\r\nu32 reg = readl(cec->regs + CEC_ADDR_TABLE);\r\nreg |= 1 << logical_addr;\r\nif (logical_addr == CEC_LOG_ADDR_INVALID)\r\nreg = 0;\r\nwritel(reg, cec->regs + CEC_ADDR_TABLE);\r\nreturn 0;\r\n}\r\nstatic int stih_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\r\nu32 signal_free_time, struct cec_msg *msg)\r\n{\r\nstruct stih_cec *cec = adap->priv;\r\nint i;\r\nfor (i = 0; i < msg->len; i++)\r\nwriteb(msg->msg[i], cec->regs + CEC_TX_DATA_BASE + i);\r\nwritel(CEC_TX_AUTO_SOM_EN | CEC_TX_AUTO_EOM_EN | CEC_TX_START |\r\nmsg->len, cec->regs + CEC_TX_ARRAY_CTRL);\r\nreturn 0;\r\n}\r\nstatic void stih_tx_done(struct stih_cec *cec, u32 status)\r\n{\r\nif (status & CEC_TX_ERROR) {\r\ncec_transmit_done(cec->adap, CEC_TX_STATUS_ERROR, 0, 0, 0, 1);\r\nreturn;\r\n}\r\nif (status & CEC_TX_ARB_ERROR) {\r\ncec_transmit_done(cec->adap,\r\nCEC_TX_STATUS_ARB_LOST, 1, 0, 0, 0);\r\nreturn;\r\n}\r\nif (!(status & CEC_TX_ACK_GET_STS)) {\r\ncec_transmit_done(cec->adap, CEC_TX_STATUS_NACK, 0, 1, 0, 0);\r\nreturn;\r\n}\r\ncec_transmit_done(cec->adap, CEC_TX_STATUS_OK, 0, 0, 0, 0);\r\n}\r\nstatic void stih_rx_done(struct stih_cec *cec, u32 status)\r\n{\r\nstruct cec_msg msg = {};\r\nu8 i;\r\nif (status & CEC_RX_ERROR_MIN)\r\nreturn;\r\nif (status & CEC_RX_ERROR_MAX)\r\nreturn;\r\nmsg.len = readl(cec->regs + CEC_DATA_ARRAY_STATUS) & 0x1f;\r\nif (!msg.len)\r\nreturn;\r\nif (msg.len > 16)\r\nmsg.len = 16;\r\nfor (i = 0; i < msg.len; i++)\r\nmsg.msg[i] = readl(cec->regs + CEC_RX_DATA_BASE + i);\r\ncec_received_msg(cec->adap, &msg);\r\n}\r\nstatic irqreturn_t stih_cec_irq_handler_thread(int irq, void *priv)\r\n{\r\nstruct stih_cec *cec = priv;\r\nif (cec->irq_status & CEC_TX_DONE_STS)\r\nstih_tx_done(cec, cec->irq_status);\r\nif (cec->irq_status & CEC_RX_DONE_STS)\r\nstih_rx_done(cec, cec->irq_status);\r\ncec->irq_status = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t stih_cec_irq_handler(int irq, void *priv)\r\n{\r\nstruct stih_cec *cec = priv;\r\ncec->irq_status = readl(cec->regs + CEC_STATUS);\r\nwritel(cec->irq_status, cec->regs + CEC_STATUS);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int stih_cec_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct stih_cec *cec;\r\nint ret;\r\ncec = devm_kzalloc(dev, sizeof(*cec), GFP_KERNEL);\r\nif (!cec)\r\nreturn -ENOMEM;\r\ncec->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncec->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(cec->regs))\r\nreturn PTR_ERR(cec->regs);\r\ncec->irq = platform_get_irq(pdev, 0);\r\nif (cec->irq < 0)\r\nreturn cec->irq;\r\nret = devm_request_threaded_irq(dev, cec->irq, stih_cec_irq_handler,\r\nstih_cec_irq_handler_thread, 0,\r\npdev->name, cec);\r\nif (ret)\r\nreturn ret;\r\ncec->clk = devm_clk_get(dev, "cec-clk");\r\nif (IS_ERR(cec->clk)) {\r\ndev_err(dev, "Cannot get cec clock\n");\r\nreturn PTR_ERR(cec->clk);\r\n}\r\ncec->adap = cec_allocate_adapter(&sti_cec_adap_ops, cec,\r\nCEC_NAME,\r\nCEC_CAP_LOG_ADDRS | CEC_CAP_PASSTHROUGH |\r\nCEC_CAP_PHYS_ADDR | CEC_CAP_TRANSMIT, 1);\r\nret = PTR_ERR_OR_ZERO(cec->adap);\r\nif (ret)\r\nreturn ret;\r\nret = cec_register_adapter(cec->adap, &pdev->dev);\r\nif (ret) {\r\ncec_delete_adapter(cec->adap);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, cec);\r\nreturn 0;\r\n}\r\nstatic int stih_cec_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
