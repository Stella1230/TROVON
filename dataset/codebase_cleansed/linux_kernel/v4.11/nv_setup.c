void NVWriteCrtc(struct nvidia_par *par, u8 index, u8 value)\r\n{\r\nVGA_WR08(par->PCIO, par->IOBase + 0x04, index);\r\nVGA_WR08(par->PCIO, par->IOBase + 0x05, value);\r\n}\r\nu8 NVReadCrtc(struct nvidia_par *par, u8 index)\r\n{\r\nVGA_WR08(par->PCIO, par->IOBase + 0x04, index);\r\nreturn (VGA_RD08(par->PCIO, par->IOBase + 0x05));\r\n}\r\nvoid NVWriteGr(struct nvidia_par *par, u8 index, u8 value)\r\n{\r\nVGA_WR08(par->PVIO, VGA_GFX_I, index);\r\nVGA_WR08(par->PVIO, VGA_GFX_D, value);\r\n}\r\nu8 NVReadGr(struct nvidia_par *par, u8 index)\r\n{\r\nVGA_WR08(par->PVIO, VGA_GFX_I, index);\r\nreturn (VGA_RD08(par->PVIO, VGA_GFX_D));\r\n}\r\nvoid NVWriteSeq(struct nvidia_par *par, u8 index, u8 value)\r\n{\r\nVGA_WR08(par->PVIO, VGA_SEQ_I, index);\r\nVGA_WR08(par->PVIO, VGA_SEQ_D, value);\r\n}\r\nu8 NVReadSeq(struct nvidia_par *par, u8 index)\r\n{\r\nVGA_WR08(par->PVIO, VGA_SEQ_I, index);\r\nreturn (VGA_RD08(par->PVIO, VGA_SEQ_D));\r\n}\r\nvoid NVWriteAttr(struct nvidia_par *par, u8 index, u8 value)\r\n{\r\nvolatile u8 tmp;\r\ntmp = VGA_RD08(par->PCIO, par->IOBase + 0x0a);\r\nif (par->paletteEnabled)\r\nindex &= ~0x20;\r\nelse\r\nindex |= 0x20;\r\nVGA_WR08(par->PCIO, VGA_ATT_IW, index);\r\nVGA_WR08(par->PCIO, VGA_ATT_W, value);\r\n}\r\nu8 NVReadAttr(struct nvidia_par *par, u8 index)\r\n{\r\nvolatile u8 tmp;\r\ntmp = VGA_RD08(par->PCIO, par->IOBase + 0x0a);\r\nif (par->paletteEnabled)\r\nindex &= ~0x20;\r\nelse\r\nindex |= 0x20;\r\nVGA_WR08(par->PCIO, VGA_ATT_IW, index);\r\nreturn (VGA_RD08(par->PCIO, VGA_ATT_R));\r\n}\r\nvoid NVWriteMiscOut(struct nvidia_par *par, u8 value)\r\n{\r\nVGA_WR08(par->PVIO, VGA_MIS_W, value);\r\n}\r\nu8 NVReadMiscOut(struct nvidia_par *par)\r\n{\r\nreturn (VGA_RD08(par->PVIO, VGA_MIS_R));\r\n}\r\nvoid NVWriteDacMask(struct nvidia_par *par, u8 value)\r\n{\r\nVGA_WR08(par->PDIO, VGA_PEL_MSK, value);\r\n}\r\nvoid NVWriteDacReadAddr(struct nvidia_par *par, u8 value)\r\n{\r\nVGA_WR08(par->PDIO, VGA_PEL_IR, value);\r\n}\r\nvoid NVWriteDacWriteAddr(struct nvidia_par *par, u8 value)\r\n{\r\nVGA_WR08(par->PDIO, VGA_PEL_IW, value);\r\n}\r\nvoid NVWriteDacData(struct nvidia_par *par, u8 value)\r\n{\r\nVGA_WR08(par->PDIO, VGA_PEL_D, value);\r\n}\r\nu8 NVReadDacData(struct nvidia_par *par)\r\n{\r\nreturn (VGA_RD08(par->PDIO, VGA_PEL_D));\r\n}\r\nstatic int NVIsConnected(struct nvidia_par *par, int output)\r\n{\r\nvolatile u32 __iomem *PRAMDAC = par->PRAMDAC0;\r\nu32 reg52C, reg608, dac0_reg608 = 0;\r\nint present;\r\nif (output) {\r\ndac0_reg608 = NV_RD32(PRAMDAC, 0x0608);\r\nPRAMDAC += 0x800;\r\n}\r\nreg52C = NV_RD32(PRAMDAC, 0x052C);\r\nreg608 = NV_RD32(PRAMDAC, 0x0608);\r\nNV_WR32(PRAMDAC, 0x0608, reg608 & ~0x00010000);\r\nNV_WR32(PRAMDAC, 0x052C, reg52C & 0x0000FEEE);\r\nmsleep(1);\r\nNV_WR32(PRAMDAC, 0x052C, NV_RD32(PRAMDAC, 0x052C) | 1);\r\nNV_WR32(par->PRAMDAC0, 0x0610, 0x94050140);\r\nNV_WR32(par->PRAMDAC0, 0x0608, NV_RD32(par->PRAMDAC0, 0x0608) |\r\n0x00001000);\r\nmsleep(1);\r\npresent = (NV_RD32(PRAMDAC, 0x0608) & (1 << 28)) ? 1 : 0;\r\nif (present)\r\nprintk("nvidiafb: CRTC%i analog found\n", output);\r\nelse\r\nprintk("nvidiafb: CRTC%i analog not found\n", output);\r\nif (output)\r\nNV_WR32(par->PRAMDAC0, 0x0608, dac0_reg608);\r\nNV_WR32(PRAMDAC, 0x052C, reg52C);\r\nNV_WR32(PRAMDAC, 0x0608, reg608);\r\nreturn present;\r\n}\r\nstatic void NVSelectHeadRegisters(struct nvidia_par *par, int head)\r\n{\r\nif (head) {\r\npar->PCIO = par->PCIO0 + 0x2000;\r\npar->PCRTC = par->PCRTC0 + 0x800;\r\npar->PRAMDAC = par->PRAMDAC0 + 0x800;\r\npar->PDIO = par->PDIO0 + 0x2000;\r\n} else {\r\npar->PCIO = par->PCIO0;\r\npar->PCRTC = par->PCRTC0;\r\npar->PRAMDAC = par->PRAMDAC0;\r\npar->PDIO = par->PDIO0;\r\n}\r\n}\r\nstatic void nv4GetConfig(struct nvidia_par *par)\r\n{\r\nif (NV_RD32(par->PFB, 0x0000) & 0x00000100) {\r\npar->RamAmountKBytes =\r\n((NV_RD32(par->PFB, 0x0000) >> 12) & 0x0F) * 1024 * 2 +\r\n1024 * 2;\r\n} else {\r\nswitch (NV_RD32(par->PFB, 0x0000) & 0x00000003) {\r\ncase 0:\r\npar->RamAmountKBytes = 1024 * 32;\r\nbreak;\r\ncase 1:\r\npar->RamAmountKBytes = 1024 * 4;\r\nbreak;\r\ncase 2:\r\npar->RamAmountKBytes = 1024 * 8;\r\nbreak;\r\ncase 3:\r\ndefault:\r\npar->RamAmountKBytes = 1024 * 16;\r\nbreak;\r\n}\r\n}\r\npar->CrystalFreqKHz = (NV_RD32(par->PEXTDEV, 0x0000) & 0x00000040) ?\r\n14318 : 13500;\r\npar->CURSOR = &par->PRAMIN[0x1E00];\r\npar->MinVClockFreqKHz = 12000;\r\npar->MaxVClockFreqKHz = 350000;\r\n}\r\nstatic void nv10GetConfig(struct nvidia_par *par)\r\n{\r\nstruct pci_dev *dev;\r\nu32 implementation = par->Chipset & 0x0ff0;\r\n#ifdef __BIG_ENDIAN\r\nif (!(NV_RD32(par->PMC, 0x0004) & 0x01000001)) {\r\nNV_WR32(par->PMC, 0x0004, 0x01000001);\r\nmb();\r\n}\r\n#endif\r\ndev = pci_get_bus_and_slot(0, 1);\r\nif ((par->Chipset & 0xffff) == 0x01a0) {\r\nu32 amt;\r\npci_read_config_dword(dev, 0x7c, &amt);\r\npar->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;\r\n} else if ((par->Chipset & 0xffff) == 0x01f0) {\r\nu32 amt;\r\npci_read_config_dword(dev, 0x84, &amt);\r\npar->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;\r\n} else {\r\npar->RamAmountKBytes =\r\n(NV_RD32(par->PFB, 0x020C) & 0xFFF00000) >> 10;\r\n}\r\npci_dev_put(dev);\r\npar->CrystalFreqKHz = (NV_RD32(par->PEXTDEV, 0x0000) & (1 << 6)) ?\r\n14318 : 13500;\r\nif (par->twoHeads && (implementation != 0x0110)) {\r\nif (NV_RD32(par->PEXTDEV, 0x0000) & (1 << 22))\r\npar->CrystalFreqKHz = 27000;\r\n}\r\npar->CURSOR = NULL;\r\npar->MinVClockFreqKHz = 12000;\r\npar->MaxVClockFreqKHz = par->twoStagePLL ? 400000 : 350000;\r\n}\r\nint NVCommonSetup(struct fb_info *info)\r\n{\r\nstruct nvidia_par *par = info->par;\r\nstruct fb_var_screeninfo *var;\r\nu16 implementation = par->Chipset & 0x0ff0;\r\nu8 *edidA = NULL, *edidB = NULL;\r\nstruct fb_monspecs *monitorA, *monitorB;\r\nstruct fb_monspecs *monA = NULL, *monB = NULL;\r\nint mobile = 0;\r\nint tvA = 0;\r\nint tvB = 0;\r\nint FlatPanel = -1;\r\nint Television = 0;\r\nint err = 0;\r\nvar = kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);\r\nmonitorA = kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);\r\nmonitorB = kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);\r\nif (!var || !monitorA || !monitorB) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\npar->PRAMIN = par->REGS + (0x00710000 / 4);\r\npar->PCRTC0 = par->REGS + (0x00600000 / 4);\r\npar->PRAMDAC0 = par->REGS + (0x00680000 / 4);\r\npar->PFB = par->REGS + (0x00100000 / 4);\r\npar->PFIFO = par->REGS + (0x00002000 / 4);\r\npar->PGRAPH = par->REGS + (0x00400000 / 4);\r\npar->PEXTDEV = par->REGS + (0x00101000 / 4);\r\npar->PTIMER = par->REGS + (0x00009000 / 4);\r\npar->PMC = par->REGS + (0x00000000 / 4);\r\npar->FIFO = par->REGS + (0x00800000 / 4);\r\npar->PCIO0 = (u8 __iomem *) par->REGS + 0x00601000;\r\npar->PDIO0 = (u8 __iomem *) par->REGS + 0x00681000;\r\npar->PVIO = (u8 __iomem *) par->REGS + 0x000C0000;\r\npar->twoHeads = (par->Architecture >= NV_ARCH_10) &&\r\n(implementation != 0x0100) &&\r\n(implementation != 0x0150) &&\r\n(implementation != 0x01A0) && (implementation != 0x0200);\r\npar->fpScaler = (par->FpScale && par->twoHeads &&\r\n(implementation != 0x0110));\r\npar->twoStagePLL = (implementation == 0x0310) ||\r\n(implementation == 0x0340) || (par->Architecture >= NV_ARCH_40);\r\npar->WaitVSyncPossible = (par->Architecture >= NV_ARCH_10) &&\r\n(implementation != 0x0100);\r\npar->BlendingPossible = ((par->Chipset & 0xffff) != 0x0020);\r\nswitch (par->Chipset & 0xffff) {\r\ncase 0x0112:\r\ncase 0x0174:\r\ncase 0x0175:\r\ncase 0x0176:\r\ncase 0x0177:\r\ncase 0x0179:\r\ncase 0x017C:\r\ncase 0x017D:\r\ncase 0x0186:\r\ncase 0x0187:\r\ncase 0x018D:\r\ncase 0x01D7:\r\ncase 0x0228:\r\ncase 0x0286:\r\ncase 0x028C:\r\ncase 0x0316:\r\ncase 0x0317:\r\ncase 0x031A:\r\ncase 0x031B:\r\ncase 0x031C:\r\ncase 0x031D:\r\ncase 0x031E:\r\ncase 0x031F:\r\ncase 0x0324:\r\ncase 0x0325:\r\ncase 0x0328:\r\ncase 0x0329:\r\ncase 0x032C:\r\ncase 0x032D:\r\ncase 0x0347:\r\ncase 0x0348:\r\ncase 0x0349:\r\ncase 0x034B:\r\ncase 0x034C:\r\ncase 0x0160:\r\ncase 0x0166:\r\ncase 0x0169:\r\ncase 0x016B:\r\ncase 0x016C:\r\ncase 0x016D:\r\ncase 0x00C8:\r\ncase 0x00CC:\r\ncase 0x0144:\r\ncase 0x0146:\r\ncase 0x0147:\r\ncase 0x0148:\r\ncase 0x0098:\r\ncase 0x0099:\r\nmobile = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (par->Architecture == NV_ARCH_04)\r\nnv4GetConfig(par);\r\nelse\r\nnv10GetConfig(par);\r\nNVSelectHeadRegisters(par, 0);\r\nNVLockUnlock(par, 0);\r\npar->IOBase = (NVReadMiscOut(par) & 0x01) ? 0x3d0 : 0x3b0;\r\npar->Television = 0;\r\nnvidia_create_i2c_busses(par);\r\nif (!par->twoHeads) {\r\npar->CRTCnumber = 0;\r\nif (nvidia_probe_i2c_connector(info, 1, &edidA))\r\nnvidia_probe_of_connector(info, 1, &edidA);\r\nif (edidA && !fb_parse_edid(edidA, var)) {\r\nprintk("nvidiafb: EDID found from BUS1\n");\r\nmonA = monitorA;\r\nfb_edid_to_monspecs(edidA, monA);\r\nFlatPanel = (monA->input & FB_DISP_DDI) ? 1 : 0;\r\nif ((par->Chipset & 0x0fff) <= 0x0020)\r\nFlatPanel = 0;\r\n} else {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x28);\r\nif (VGA_RD08(par->PCIO, 0x03D5) & 0x80) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x33);\r\nif (!(VGA_RD08(par->PCIO, 0x03D5) & 0x01))\r\nTelevision = 1;\r\nFlatPanel = 1;\r\n} else {\r\nFlatPanel = 0;\r\n}\r\nprintk("nvidiafb: HW is currently programmed for %s\n",\r\nFlatPanel ? (Television ? "TV" : "DFP") :\r\n"CRT");\r\n}\r\nif (par->FlatPanel == -1) {\r\npar->FlatPanel = FlatPanel;\r\npar->Television = Television;\r\n} else {\r\nprintk("nvidiafb: Forcing display type to %s as "\r\n"specified\n", par->FlatPanel ? "DFP" : "CRT");\r\n}\r\n} else {\r\nu8 outputAfromCRTC, outputBfromCRTC;\r\nint CRTCnumber = -1;\r\nu8 slaved_on_A, slaved_on_B;\r\nint analog_on_A, analog_on_B;\r\nu32 oldhead;\r\nu8 cr44;\r\nif (implementation != 0x0110) {\r\nif (NV_RD32(par->PRAMDAC0, 0x0000052C) & 0x100)\r\noutputAfromCRTC = 1;\r\nelse\r\noutputAfromCRTC = 0;\r\nif (NV_RD32(par->PRAMDAC0, 0x0000252C) & 0x100)\r\noutputBfromCRTC = 1;\r\nelse\r\noutputBfromCRTC = 0;\r\nanalog_on_A = NVIsConnected(par, 0);\r\nanalog_on_B = NVIsConnected(par, 1);\r\n} else {\r\noutputAfromCRTC = 0;\r\noutputBfromCRTC = 1;\r\nanalog_on_A = 0;\r\nanalog_on_B = 0;\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x44);\r\ncr44 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D5, 3);\r\nNVSelectHeadRegisters(par, 1);\r\nNVLockUnlock(par, 0);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x28);\r\nslaved_on_B = VGA_RD08(par->PCIO, 0x03D5) & 0x80;\r\nif (slaved_on_B) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x33);\r\ntvB = !(VGA_RD08(par->PCIO, 0x03D5) & 0x01);\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x44);\r\nVGA_WR08(par->PCIO, 0x03D5, 0);\r\nNVSelectHeadRegisters(par, 0);\r\nNVLockUnlock(par, 0);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x28);\r\nslaved_on_A = VGA_RD08(par->PCIO, 0x03D5) & 0x80;\r\nif (slaved_on_A) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x33);\r\ntvA = !(VGA_RD08(par->PCIO, 0x03D5) & 0x01);\r\n}\r\noldhead = NV_RD32(par->PCRTC0, 0x00000860);\r\nNV_WR32(par->PCRTC0, 0x00000860, oldhead | 0x00000010);\r\nif (nvidia_probe_i2c_connector(info, 1, &edidA))\r\nnvidia_probe_of_connector(info, 1, &edidA);\r\nif (edidA && !fb_parse_edid(edidA, var)) {\r\nprintk("nvidiafb: EDID found from BUS1\n");\r\nmonA = monitorA;\r\nfb_edid_to_monspecs(edidA, monA);\r\n}\r\nif (nvidia_probe_i2c_connector(info, 2, &edidB))\r\nnvidia_probe_of_connector(info, 2, &edidB);\r\nif (edidB && !fb_parse_edid(edidB, var)) {\r\nprintk("nvidiafb: EDID found from BUS2\n");\r\nmonB = monitorB;\r\nfb_edid_to_monspecs(edidB, monB);\r\n}\r\nif (slaved_on_A && !tvA) {\r\nCRTCnumber = 0;\r\nFlatPanel = 1;\r\nprintk("nvidiafb: CRTC 0 is currently programmed for "\r\n"DFP\n");\r\n} else if (slaved_on_B && !tvB) {\r\nCRTCnumber = 1;\r\nFlatPanel = 1;\r\nprintk("nvidiafb: CRTC 1 is currently programmed "\r\n"for DFP\n");\r\n} else if (analog_on_A) {\r\nCRTCnumber = outputAfromCRTC;\r\nFlatPanel = 0;\r\nprintk("nvidiafb: CRTC %i appears to have a "\r\n"CRT attached\n", CRTCnumber);\r\n} else if (analog_on_B) {\r\nCRTCnumber = outputBfromCRTC;\r\nFlatPanel = 0;\r\nprintk("nvidiafb: CRTC %i appears to have a "\r\n"CRT attached\n", CRTCnumber);\r\n} else if (slaved_on_A) {\r\nCRTCnumber = 0;\r\nFlatPanel = 1;\r\nTelevision = 1;\r\nprintk("nvidiafb: CRTC 0 is currently programmed "\r\n"for TV\n");\r\n} else if (slaved_on_B) {\r\nCRTCnumber = 1;\r\nFlatPanel = 1;\r\nTelevision = 1;\r\nprintk("nvidiafb: CRTC 1 is currently programmed for "\r\n"TV\n");\r\n} else if (monA) {\r\nFlatPanel = (monA->input & FB_DISP_DDI) ? 1 : 0;\r\n} else if (monB) {\r\nFlatPanel = (monB->input & FB_DISP_DDI) ? 1 : 0;\r\n}\r\nif (par->FlatPanel == -1) {\r\nif (FlatPanel != -1) {\r\npar->FlatPanel = FlatPanel;\r\npar->Television = Television;\r\n} else {\r\nprintk("nvidiafb: Unable to detect display "\r\n"type...\n");\r\nif (mobile) {\r\nprintk("...On a laptop, assuming "\r\n"DFP\n");\r\npar->FlatPanel = 1;\r\n} else {\r\nprintk("...Using default of CRT\n");\r\npar->FlatPanel = 0;\r\n}\r\n}\r\n} else {\r\nprintk("nvidiafb: Forcing display type to %s as "\r\n"specified\n", par->FlatPanel ? "DFP" : "CRT");\r\n}\r\nif (par->CRTCnumber == -1) {\r\nif (CRTCnumber != -1)\r\npar->CRTCnumber = CRTCnumber;\r\nelse {\r\nprintk("nvidiafb: Unable to detect which "\r\n"CRTCNumber...\n");\r\nif (par->FlatPanel)\r\npar->CRTCnumber = 1;\r\nelse\r\npar->CRTCnumber = 0;\r\nprintk("...Defaulting to CRTCNumber %i\n",\r\npar->CRTCnumber);\r\n}\r\n} else {\r\nprintk("nvidiafb: Forcing CRTCNumber %i as "\r\n"specified\n", par->CRTCnumber);\r\n}\r\nif (monA) {\r\nif (((monA->input & FB_DISP_DDI) &&\r\npar->FlatPanel) ||\r\n((!(monA->input & FB_DISP_DDI)) &&\r\n!par->FlatPanel)) {\r\nif (monB) {\r\nfb_destroy_modedb(monB->modedb);\r\nmonB = NULL;\r\n}\r\n} else {\r\nfb_destroy_modedb(monA->modedb);\r\nmonA = NULL;\r\n}\r\n}\r\nif (monB) {\r\nif (((monB->input & FB_DISP_DDI) &&\r\n!par->FlatPanel) ||\r\n((!(monB->input & FB_DISP_DDI)) &&\r\npar->FlatPanel)) {\r\nfb_destroy_modedb(monB->modedb);\r\nmonB = NULL;\r\n} else\r\nmonA = monB;\r\n}\r\nif (implementation == 0x0110)\r\ncr44 = par->CRTCnumber * 0x3;\r\nNV_WR32(par->PCRTC0, 0x00000860, oldhead);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x44);\r\nVGA_WR08(par->PCIO, 0x03D5, cr44);\r\nNVSelectHeadRegisters(par, par->CRTCnumber);\r\n}\r\nprintk("nvidiafb: Using %s on CRTC %i\n",\r\npar->FlatPanel ? (par->Television ? "TV" : "DFP") : "CRT",\r\npar->CRTCnumber);\r\nif (par->FlatPanel && !par->Television) {\r\npar->fpWidth = NV_RD32(par->PRAMDAC, 0x0820) + 1;\r\npar->fpHeight = NV_RD32(par->PRAMDAC, 0x0800) + 1;\r\npar->fpSyncs = NV_RD32(par->PRAMDAC, 0x0848) & 0x30000033;\r\nprintk("nvidiafb: Panel size is %i x %i\n", par->fpWidth, par->fpHeight);\r\n}\r\nif (monA)\r\ninfo->monspecs = *monA;\r\nif (!par->FlatPanel || !par->twoHeads)\r\npar->FPDither = 0;\r\npar->LVDS = 0;\r\nif (par->FlatPanel && par->twoHeads) {\r\nNV_WR32(par->PRAMDAC0, 0x08B0, 0x00010004);\r\nif (NV_RD32(par->PRAMDAC0, 0x08b4) & 1)\r\npar->LVDS = 1;\r\nprintk("nvidiafb: Panel is %s\n", par->LVDS ? "LVDS" : "TMDS");\r\n}\r\nkfree(edidA);\r\nkfree(edidB);\r\ndone:\r\nkfree(var);\r\nkfree(monitorA);\r\nkfree(monitorB);\r\nreturn err;\r\n}
