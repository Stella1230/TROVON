static int change_page_range(pte_t *ptep, pgtable_t token, unsigned long addr,\r\nvoid *data)\r\n{\r\nstruct page_change_data *cdata = data;\r\npte_t pte = *ptep;\r\npte = clear_pte_bit(pte, cdata->clear_mask);\r\npte = set_pte_bit(pte, cdata->set_mask);\r\nset_pte(ptep, pte);\r\nreturn 0;\r\n}\r\nstatic int __change_memory_common(unsigned long start, unsigned long size,\r\npgprot_t set_mask, pgprot_t clear_mask)\r\n{\r\nstruct page_change_data data;\r\nint ret;\r\ndata.set_mask = set_mask;\r\ndata.clear_mask = clear_mask;\r\nret = apply_to_page_range(&init_mm, start, size, change_page_range,\r\n&data);\r\nflush_tlb_kernel_range(start, start + size);\r\nreturn ret;\r\n}\r\nstatic int change_memory_common(unsigned long addr, int numpages,\r\npgprot_t set_mask, pgprot_t clear_mask)\r\n{\r\nunsigned long start = addr;\r\nunsigned long size = PAGE_SIZE*numpages;\r\nunsigned long end = start + size;\r\nstruct vm_struct *area;\r\nif (!PAGE_ALIGNED(addr)) {\r\nstart &= PAGE_MASK;\r\nend = start + size;\r\nWARN_ON_ONCE(1);\r\n}\r\narea = find_vm_area((void *)addr);\r\nif (!area ||\r\nend > (unsigned long)area->addr + area->size ||\r\n!(area->flags & VM_ALLOC))\r\nreturn -EINVAL;\r\nif (!numpages)\r\nreturn 0;\r\nreturn __change_memory_common(start, size, set_mask, clear_mask);\r\n}\r\nint set_memory_ro(unsigned long addr, int numpages)\r\n{\r\nreturn change_memory_common(addr, numpages,\r\n__pgprot(PTE_RDONLY),\r\n__pgprot(PTE_WRITE));\r\n}\r\nint set_memory_rw(unsigned long addr, int numpages)\r\n{\r\nreturn change_memory_common(addr, numpages,\r\n__pgprot(PTE_WRITE),\r\n__pgprot(PTE_RDONLY));\r\n}\r\nint set_memory_nx(unsigned long addr, int numpages)\r\n{\r\nreturn change_memory_common(addr, numpages,\r\n__pgprot(PTE_PXN),\r\n__pgprot(0));\r\n}\r\nint set_memory_x(unsigned long addr, int numpages)\r\n{\r\nreturn change_memory_common(addr, numpages,\r\n__pgprot(0),\r\n__pgprot(PTE_PXN));\r\n}\r\nvoid __kernel_map_pages(struct page *page, int numpages, int enable)\r\n{\r\nunsigned long addr = (unsigned long) page_address(page);\r\nif (enable)\r\n__change_memory_common(addr, PAGE_SIZE * numpages,\r\n__pgprot(PTE_VALID),\r\n__pgprot(0));\r\nelse\r\n__change_memory_common(addr, PAGE_SIZE * numpages,\r\n__pgprot(0),\r\n__pgprot(PTE_VALID));\r\n}\r\nbool kernel_page_present(struct page *page)\r\n{\r\npgd_t *pgd;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\nunsigned long addr = (unsigned long)page_address(page);\r\npgd = pgd_offset_k(addr);\r\nif (pgd_none(*pgd))\r\nreturn false;\r\npud = pud_offset(pgd, addr);\r\nif (pud_none(*pud))\r\nreturn false;\r\nif (pud_sect(*pud))\r\nreturn true;\r\npmd = pmd_offset(pud, addr);\r\nif (pmd_none(*pmd))\r\nreturn false;\r\nif (pmd_sect(*pmd))\r\nreturn true;\r\npte = pte_offset_kernel(pmd, addr);\r\nreturn pte_valid(*pte);\r\n}
