static void qla82xx_crb_addr_transform_setup(void)\r\n{\r\nqla82xx_crb_addr_transform(XDMA);\r\nqla82xx_crb_addr_transform(TIMR);\r\nqla82xx_crb_addr_transform(SRE);\r\nqla82xx_crb_addr_transform(SQN3);\r\nqla82xx_crb_addr_transform(SQN2);\r\nqla82xx_crb_addr_transform(SQN1);\r\nqla82xx_crb_addr_transform(SQN0);\r\nqla82xx_crb_addr_transform(SQS3);\r\nqla82xx_crb_addr_transform(SQS2);\r\nqla82xx_crb_addr_transform(SQS1);\r\nqla82xx_crb_addr_transform(SQS0);\r\nqla82xx_crb_addr_transform(RPMX7);\r\nqla82xx_crb_addr_transform(RPMX6);\r\nqla82xx_crb_addr_transform(RPMX5);\r\nqla82xx_crb_addr_transform(RPMX4);\r\nqla82xx_crb_addr_transform(RPMX3);\r\nqla82xx_crb_addr_transform(RPMX2);\r\nqla82xx_crb_addr_transform(RPMX1);\r\nqla82xx_crb_addr_transform(RPMX0);\r\nqla82xx_crb_addr_transform(ROMUSB);\r\nqla82xx_crb_addr_transform(SN);\r\nqla82xx_crb_addr_transform(QMN);\r\nqla82xx_crb_addr_transform(QMS);\r\nqla82xx_crb_addr_transform(PGNI);\r\nqla82xx_crb_addr_transform(PGND);\r\nqla82xx_crb_addr_transform(PGN3);\r\nqla82xx_crb_addr_transform(PGN2);\r\nqla82xx_crb_addr_transform(PGN1);\r\nqla82xx_crb_addr_transform(PGN0);\r\nqla82xx_crb_addr_transform(PGSI);\r\nqla82xx_crb_addr_transform(PGSD);\r\nqla82xx_crb_addr_transform(PGS3);\r\nqla82xx_crb_addr_transform(PGS2);\r\nqla82xx_crb_addr_transform(PGS1);\r\nqla82xx_crb_addr_transform(PGS0);\r\nqla82xx_crb_addr_transform(PS);\r\nqla82xx_crb_addr_transform(PH);\r\nqla82xx_crb_addr_transform(NIU);\r\nqla82xx_crb_addr_transform(I2Q);\r\nqla82xx_crb_addr_transform(EG);\r\nqla82xx_crb_addr_transform(MN);\r\nqla82xx_crb_addr_transform(MS);\r\nqla82xx_crb_addr_transform(CAS2);\r\nqla82xx_crb_addr_transform(CAS1);\r\nqla82xx_crb_addr_transform(CAS0);\r\nqla82xx_crb_addr_transform(CAM);\r\nqla82xx_crb_addr_transform(C2C1);\r\nqla82xx_crb_addr_transform(C2C0);\r\nqla82xx_crb_addr_transform(SMB);\r\nqla82xx_crb_addr_transform(OCM0);\r\nqla82xx_crb_addr_transform(I2C0);\r\nqla82xx_crb_table_initialized = 1;\r\n}\r\nchar *qdev_state(uint32_t dev_state)\r\n{\r\nreturn q_dev_state[dev_state];\r\n}\r\nstatic void\r\nqla82xx_pci_set_crbwindow_2M(struct qla_hw_data *ha, ulong off_in,\r\nvoid __iomem **off_out)\r\n{\r\nu32 win_read;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nha->crb_win = CRB_HI(off_in);\r\nwritel(ha->crb_win, CRB_WINDOW_2M + ha->nx_pcibase);\r\nwin_read = RD_REG_DWORD(CRB_WINDOW_2M + ha->nx_pcibase);\r\nif (win_read != ha->crb_win) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb000,\r\n"%s: Written crbwin (0x%x) "\r\n"!= Read crbwin (0x%x), off=0x%lx.\n",\r\n__func__, ha->crb_win, win_read, off_in);\r\n}\r\n*off_out = (off_in & MASK(16)) + CRB_INDIRECT_2M + ha->nx_pcibase;\r\n}\r\nstatic inline unsigned long\r\nqla82xx_pci_set_crbwindow(struct qla_hw_data *ha, u64 off)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nif ((off >= QLA82XX_CRB_PCIX_HOST) && (off < QLA82XX_CRB_DDR_NET)) {\r\nreturn off;\r\n}\r\nif ((off >= QLA82XX_CRB_PCIX_HOST) && (off < QLA82XX_CRB_PCIX_HOST2)) {\r\nif (ha->curr_window != 0)\r\nWARN_ON(1);\r\nreturn off;\r\n}\r\nif ((off > QLA82XX_CRB_PCIX_HOST2) && (off < QLA82XX_CRB_MAX)) {\r\noff = off - QLA82XX_CRB_PCIX_HOST2 + QLA82XX_CRB_PCIX_HOST;\r\nif (ha->curr_window != 1)\r\nreturn off;\r\nif ((off >= QLA82XX_PCI_DIRECT_CRB) &&\r\n(off < QLA82XX_PCI_CAMQM_MAX))\r\nreturn off;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb001,\r\n"%s: Warning: unm_nic_pci_set_crbwindow "\r\n"called with an unknown address(%llx).\n",\r\nQLA2XXX_DRIVER_NAME, off);\r\nreturn off;\r\n}\r\nstatic int\r\nqla82xx_pci_get_crb_addr_2M(struct qla_hw_data *ha, ulong off_in,\r\nvoid __iomem **off_out)\r\n{\r\nstruct crb_128M_2M_sub_block_map *m;\r\nif (off_in >= QLA82XX_CRB_MAX)\r\nreturn -1;\r\nif (off_in >= QLA82XX_PCI_CAMQM && off_in < QLA82XX_PCI_CAMQM_2M_END) {\r\n*off_out = (off_in - QLA82XX_PCI_CAMQM) +\r\nQLA82XX_PCI_CAMQM_2M_BASE + ha->nx_pcibase;\r\nreturn 0;\r\n}\r\nif (off_in < QLA82XX_PCI_CRBSPACE)\r\nreturn -1;\r\noff_in -= QLA82XX_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(off_in)].sub_block[CRB_SUBBLK(off_in)];\r\nif (m->valid && (m->start_128M <= off_in) && (m->end_128M > off_in)) {\r\n*off_out = off_in + m->start_2M - m->start_128M + ha->nx_pcibase;\r\nreturn 0;\r\n}\r\n*off_out = (void __iomem *)off_in;\r\nreturn 1;\r\n}\r\nstatic int qla82xx_crb_win_lock(struct qla_hw_data *ha)\r\n{\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= CRB_WIN_LOCK_TIMEOUT)\r\nreturn -1;\r\ntimeout++;\r\n}\r\nqla82xx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->portnum);\r\nreturn 0;\r\n}\r\nint\r\nqla82xx_wr_32(struct qla_hw_data *ha, ulong off_in, u32 data)\r\n{\r\nvoid __iomem *off;\r\nunsigned long flags = 0;\r\nint rv;\r\nrv = qla82xx_pci_get_crb_addr_2M(ha, off_in, &off);\r\nBUG_ON(rv == -1);\r\nif (rv == 1) {\r\n#ifndef __CHECKER__\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\n#endif\r\nqla82xx_crb_win_lock(ha);\r\nqla82xx_pci_set_crbwindow_2M(ha, off_in, &off);\r\n}\r\nwritel(data, (void __iomem *)off);\r\nif (rv == 1) {\r\nqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\r\n#ifndef __CHECKER__\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqla82xx_rd_32(struct qla_hw_data *ha, ulong off_in)\r\n{\r\nvoid __iomem *off;\r\nunsigned long flags = 0;\r\nint rv;\r\nu32 data;\r\nrv = qla82xx_pci_get_crb_addr_2M(ha, off_in, &off);\r\nBUG_ON(rv == -1);\r\nif (rv == 1) {\r\n#ifndef __CHECKER__\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\n#endif\r\nqla82xx_crb_win_lock(ha);\r\nqla82xx_pci_set_crbwindow_2M(ha, off_in, &off);\r\n}\r\ndata = RD_REG_DWORD(off);\r\nif (rv == 1) {\r\nqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\r\n#ifndef __CHECKER__\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n#endif\r\n}\r\nreturn data;\r\n}\r\nint qla82xx_idc_lock(struct qla_hw_data *ha)\r\n{\r\nint i;\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= IDC_LOCK_TIMEOUT)\r\nreturn -1;\r\ntimeout++;\r\nif (!in_interrupt())\r\nschedule();\r\nelse {\r\nfor (i = 0; i < 20; i++)\r\ncpu_relax();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid qla82xx_idc_unlock(struct qla_hw_data *ha)\r\n{\r\nqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));\r\n}\r\nstatic unsigned long\r\nqla82xx_pci_mem_bound_check(struct qla_hw_data *ha,\r\nunsigned long long addr, int size)\r\n{\r\nif (!addr_in_range(addr, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX) ||\r\n!addr_in_range(addr + size - 1, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX) ||\r\n((size != 1) && (size != 2) && (size != 4) && (size != 8)))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic unsigned long\r\nqla82xx_pci_set_window(struct qla_hw_data *ha, unsigned long long addr)\r\n{\r\nint window;\r\nu32 win_read;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nif (addr_in_range(addr, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX)) {\r\nwindow = MN_WIN(addr);\r\nha->ddr_mn_window = window;\r\nqla82xx_wr_32(ha,\r\nha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla82xx_rd_32(ha,\r\nha->mn_win_crb | QLA82XX_PCI_CRBSPACE);\r\nif ((win_read << 17) != window) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb003,\r\n"%s: Written MNwin (0x%x) != Read MNwin (0x%x).\n",\r\n__func__, window, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_DDR_NET;\r\n} else if (addr_in_range(addr, QLA82XX_ADDR_OCM0,\r\nQLA82XX_ADDR_OCM0_MAX)) {\r\nunsigned int temp1;\r\nif ((addr & 0x00ff800) == 0xff800) {\r\nql_log(ql_log_warn, vha, 0xb004,\r\n"%s: QM access not handled.\n", __func__);\r\naddr = -1UL;\r\n}\r\nwindow = OCM_WIN(addr);\r\nha->ddr_mn_window = window;\r\nqla82xx_wr_32(ha,\r\nha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla82xx_rd_32(ha,\r\nha->mn_win_crb | QLA82XX_PCI_CRBSPACE);\r\ntemp1 = ((window & 0x1FF) << 7) |\r\n((window & 0x0FFFE0000) >> 17);\r\nif (win_read != temp1) {\r\nql_log(ql_log_warn, vha, 0xb005,\r\n"%s: Written OCMwin (0x%x) != Read OCMwin (0x%x).\n",\r\n__func__, temp1, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_OCM0_2M;\r\n} else if (addr_in_range(addr, QLA82XX_ADDR_QDR_NET,\r\nQLA82XX_P3_ADDR_QDR_NET_MAX)) {\r\nwindow = MS_WIN(addr);\r\nha->qdr_sn_window = window;\r\nqla82xx_wr_32(ha,\r\nha->ms_win_crb | QLA82XX_PCI_CRBSPACE, window);\r\nwin_read = qla82xx_rd_32(ha,\r\nha->ms_win_crb | QLA82XX_PCI_CRBSPACE);\r\nif (win_read != window) {\r\nql_log(ql_log_warn, vha, 0xb006,\r\n"%s: Written MSwin (0x%x) != Read MSwin (0x%x).\n",\r\n__func__, window, win_read);\r\n}\r\naddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_QDR_NET;\r\n} else {\r\nif ((qla82xx_pci_set_window_warning_count++ < 8) ||\r\n(qla82xx_pci_set_window_warning_count%64 == 0)) {\r\nql_log(ql_log_warn, vha, 0xb007,\r\n"%s: Warning:%s Unknown address range!.\n",\r\n__func__, QLA2XXX_DRIVER_NAME);\r\n}\r\naddr = -1UL;\r\n}\r\nreturn addr;\r\n}\r\nstatic int qla82xx_pci_is_same_window(struct qla_hw_data *ha,\r\nunsigned long long addr)\r\n{\r\nint window;\r\nunsigned long long qdr_max;\r\nqdr_max = QLA82XX_P3_ADDR_QDR_NET_MAX;\r\nif (addr_in_range(addr, QLA82XX_ADDR_DDR_NET,\r\nQLA82XX_ADDR_DDR_NET_MAX))\r\nBUG();\r\nelse if (addr_in_range(addr, QLA82XX_ADDR_OCM0,\r\nQLA82XX_ADDR_OCM0_MAX))\r\nreturn 1;\r\nelse if (addr_in_range(addr, QLA82XX_ADDR_OCM1,\r\nQLA82XX_ADDR_OCM1_MAX))\r\nreturn 1;\r\nelse if (addr_in_range(addr, QLA82XX_ADDR_QDR_NET, qdr_max)) {\r\nwindow = ((addr - QLA82XX_ADDR_QDR_NET) >> 22) & 0x3f;\r\nif (ha->qdr_sn_window == window)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qla82xx_pci_mem_read_direct(struct qla_hw_data *ha,\r\nu64 off, void *data, int size)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr = NULL;\r\nint ret = 0;\r\nu64 start;\r\nuint8_t __iomem *mem_ptr = NULL;\r\nunsigned long mem_base;\r\nunsigned long mem_page;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nstart = qla82xx_pci_set_window(ha, off);\r\nif ((start == -1UL) ||\r\n(qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nql_log(ql_log_fatal, vha, 0xb008,\r\n"%s out of bound pci memory "\r\n"access, offset is 0x%llx.\n",\r\nQLA2XXX_DRIVER_NAME, off);\r\nreturn -1;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nmem_base = pci_resource_start(ha->pdev, 0);\r\nmem_page = start & PAGE_MASK;\r\nif (mem_page != ((start + size - 1) & PAGE_MASK))\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE * 2);\r\nelse\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\r\nif (mem_ptr == NULL) {\r\n*(u8 *)data = 0;\r\nreturn -1;\r\n}\r\naddr = mem_ptr;\r\naddr += start & (PAGE_SIZE - 1);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nswitch (size) {\r\ncase 1:\r\n*(u8 *)data = readb(addr);\r\nbreak;\r\ncase 2:\r\n*(u16 *)data = readw(addr);\r\nbreak;\r\ncase 4:\r\n*(u32 *)data = readl(addr);\r\nbreak;\r\ncase 8:\r\n*(u64 *)data = readq(addr);\r\nbreak;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_pci_mem_write_direct(struct qla_hw_data *ha,\r\nu64 off, void *data, int size)\r\n{\r\nunsigned long flags;\r\nvoid __iomem *addr = NULL;\r\nint ret = 0;\r\nu64 start;\r\nuint8_t __iomem *mem_ptr = NULL;\r\nunsigned long mem_base;\r\nunsigned long mem_page;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nstart = qla82xx_pci_set_window(ha, off);\r\nif ((start == -1UL) ||\r\n(qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nql_log(ql_log_fatal, vha, 0xb009,\r\n"%s out of bount memory "\r\n"access, offset is 0x%llx.\n",\r\nQLA2XXX_DRIVER_NAME, off);\r\nreturn -1;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nmem_base = pci_resource_start(ha->pdev, 0);\r\nmem_page = start & PAGE_MASK;\r\nif (mem_page != ((start + size - 1) & PAGE_MASK))\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE*2);\r\nelse\r\nmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\r\nif (mem_ptr == NULL)\r\nreturn -1;\r\naddr = mem_ptr;\r\naddr += start & (PAGE_SIZE - 1);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nswitch (size) {\r\ncase 1:\r\nwriteb(*(u8 *)data, addr);\r\nbreak;\r\ncase 2:\r\nwritew(*(u16 *)data, addr);\r\nbreak;\r\ncase 4:\r\nwritel(*(u32 *)data, addr);\r\nbreak;\r\ncase 8:\r\nwriteq(*(u64 *)data, addr);\r\nbreak;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nif (mem_ptr)\r\niounmap(mem_ptr);\r\nreturn ret;\r\n}\r\nstatic unsigned long\r\nqla82xx_decode_crb_addr(unsigned long addr)\r\n{\r\nint i;\r\nunsigned long base_addr, offset, pci_base;\r\nif (!qla82xx_crb_table_initialized)\r\nqla82xx_crb_addr_transform_setup();\r\npci_base = ADDR_ERROR;\r\nbase_addr = addr & 0xfff00000;\r\noffset = addr & 0x000fffff;\r\nfor (i = 0; i < MAX_CRB_XFORM; i++) {\r\nif (crb_addr_xform[i] == base_addr) {\r\npci_base = i << 20;\r\nbreak;\r\n}\r\n}\r\nif (pci_base == ADDR_ERROR)\r\nreturn pci_base;\r\nreturn pci_base + offset;\r\n}\r\nstatic int\r\nqla82xx_rom_lock(struct qla_hw_data *ha)\r\n{\r\nint done = 0, timeout = 0;\r\nuint32_t lock_owner = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwhile (!done) {\r\ndone = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));\r\nif (done == 1)\r\nbreak;\r\nif (timeout >= qla82xx_rom_lock_timeout) {\r\nlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\r\nql_dbg(ql_dbg_p3p, vha, 0xb157,\r\n"%s: Simultaneous flash access by following ports, active port = %d: accessing port = %d",\r\n__func__, ha->portnum, lock_owner);\r\nreturn -1;\r\n}\r\ntimeout++;\r\n}\r\nqla82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ha->portnum);\r\nreturn 0;\r\n}\r\nstatic void\r\nqla82xx_rom_unlock(struct qla_hw_data *ha)\r\n{\r\nqla82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, 0xffffffff);\r\nqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));\r\n}\r\nstatic int\r\nqla82xx_wait_rom_busy(struct qla_hw_data *ha)\r\n{\r\nlong timeout = 0;\r\nlong done = 0 ;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwhile (done == 0) {\r\ndone = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\r\ndone &= 4;\r\ntimeout++;\r\nif (timeout >= rom_max_timeout) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb00a,\r\n"%s: Timeout reached waiting for rom busy.\n",\r\nQLA2XXX_DRIVER_NAME);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_wait_rom_done(struct qla_hw_data *ha)\r\n{\r\nlong timeout = 0;\r\nlong done = 0 ;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwhile (done == 0) {\r\ndone = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\r\ndone &= 2;\r\ntimeout++;\r\nif (timeout >= rom_max_timeout) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb00b,\r\n"%s: Timeout reached waiting for rom done.\n",\r\nQLA2XXX_DRIVER_NAME);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_md_rw_32(struct qla_hw_data *ha, uint32_t off, u32 data, uint8_t flag)\r\n{\r\nuint32_t off_value, rval = 0;\r\nWRT_REG_DWORD(CRB_WINDOW_2M + ha->nx_pcibase, off & 0xFFFF0000);\r\nRD_REG_DWORD(CRB_WINDOW_2M + ha->nx_pcibase);\r\noff_value = (off & 0x0000FFFF);\r\nif (flag)\r\nWRT_REG_DWORD(off_value + CRB_INDIRECT_2M + ha->nx_pcibase,\r\ndata);\r\nelse\r\nrval = RD_REG_DWORD(off_value + CRB_INDIRECT_2M +\r\nha->nx_pcibase);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla82xx_do_rom_fast_read(struct qla_hw_data *ha, int addr, int *valp)\r\n{\r\nqla82xx_md_rw_32(ha, MD_DIRECT_ROM_WINDOW, (addr & 0xFFFF0000), 1);\r\n*valp = qla82xx_md_rw_32(ha, MD_DIRECT_ROM_READ_BASE +\r\n(addr & 0x0000FFFF), 0, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_rom_fast_read(struct qla_hw_data *ha, int addr, int *valp)\r\n{\r\nint ret, loops = 0;\r\nuint32_t lock_owner = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwhile ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {\r\nudelay(100);\r\nschedule();\r\nloops++;\r\n}\r\nif (loops >= 50000) {\r\nlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\r\nql_log(ql_log_fatal, vha, 0x00b9,\r\n"Failed to acquire SEM2 lock, Lock Owner %u.\n",\r\nlock_owner);\r\nreturn -1;\r\n}\r\nret = qla82xx_do_rom_fast_read(ha, addr, valp);\r\nqla82xx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_read_status_reg(struct qla_hw_data *ha, uint32_t *val)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_RDSR);\r\nqla82xx_wait_rom_busy(ha);\r\nif (qla82xx_wait_rom_done(ha)) {\r\nql_log(ql_log_warn, vha, 0xb00c,\r\n"Error waiting for rom done.\n");\r\nreturn -1;\r\n}\r\n*val = qla82xx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_flash_wait_write_finish(struct qla_hw_data *ha)\r\n{\r\nlong timeout = 0;\r\nuint32_t done = 1 ;\r\nuint32_t val;\r\nint ret = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\r\nwhile ((done != 0) && (ret == 0)) {\r\nret = qla82xx_read_status_reg(ha, &val);\r\ndone = val & 1;\r\ntimeout++;\r\nudelay(10);\r\ncond_resched();\r\nif (timeout >= 50000) {\r\nql_log(ql_log_warn, vha, 0xb00d,\r\n"Timeout reached waiting for write finish.\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_flash_set_write_enable(struct qla_hw_data *ha)\r\n{\r\nuint32_t val;\r\nqla82xx_wait_rom_busy(ha);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_WREN);\r\nqla82xx_wait_rom_busy(ha);\r\nif (qla82xx_wait_rom_done(ha))\r\nreturn -1;\r\nif (qla82xx_read_status_reg(ha, &val) != 0)\r\nreturn -1;\r\nif ((val & 2) != 2)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_write_status_reg(struct qla_hw_data *ha, uint32_t val)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nif (qla82xx_flash_set_write_enable(ha))\r\nreturn -1;\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_WDATA, val);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0x1);\r\nif (qla82xx_wait_rom_done(ha)) {\r\nql_log(ql_log_warn, vha, 0xb00e,\r\n"Error waiting for rom done.\n");\r\nreturn -1;\r\n}\r\nreturn qla82xx_flash_wait_write_finish(ha);\r\n}\r\nstatic int\r\nqla82xx_write_disable_flash(struct qla_hw_data *ha)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_WRDI);\r\nif (qla82xx_wait_rom_done(ha)) {\r\nql_log(ql_log_warn, vha, 0xb00f,\r\n"Error waiting for rom done.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nql82xx_rom_lock_d(struct qla_hw_data *ha)\r\n{\r\nint loops = 0;\r\nuint32_t lock_owner = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwhile ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {\r\nudelay(100);\r\ncond_resched();\r\nloops++;\r\n}\r\nif (loops >= 50000) {\r\nlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\r\nql_log(ql_log_warn, vha, 0xb010,\r\n"ROM lock failed, Lock Owner %u.\n", lock_owner);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_write_flash_dword(struct qla_hw_data *ha, uint32_t flashaddr,\r\nuint32_t data)\r\n{\r\nint ret = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nret = ql82xx_rom_lock_d(ha);\r\nif (ret < 0) {\r\nql_log(ql_log_warn, vha, 0xb011,\r\n"ROM lock failed.\n");\r\nreturn ret;\r\n}\r\nif (qla82xx_flash_set_write_enable(ha))\r\ngoto done_write;\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_WDATA, data);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, flashaddr);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_PP);\r\nqla82xx_wait_rom_busy(ha);\r\nif (qla82xx_wait_rom_done(ha)) {\r\nql_log(ql_log_warn, vha, 0xb012,\r\n"Error waiting for rom done.\n");\r\nret = -1;\r\ngoto done_write;\r\n}\r\nret = qla82xx_flash_wait_write_finish(ha);\r\ndone_write:\r\nqla82xx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_pinit_from_rom(scsi_qla_host_t *vha)\r\n{\r\nint addr, val;\r\nint i ;\r\nstruct crb_addr_pair *buf;\r\nunsigned long off;\r\nunsigned offset, n;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct crb_addr_pair {\r\nlong addr;\r\nlong data;\r\n};\r\nqla82xx_rom_lock(ha);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);\r\nval = qla82xx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_SRE + 0x1000, val & (~(0x1)));\r\nqla82xx_wr_32(ha, QLA82XX_CRB_EPG + 0x1300, 0x1);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x0, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x8, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c, 1);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c, 1);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);\r\nmsleep(20);\r\nif (test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);\r\nelse\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);\r\nqla82xx_rom_unlock(ha);\r\nif (qla82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||\r\nqla82xx_rom_fast_read(ha, 4, &n) != 0) {\r\nql_log(ql_log_fatal, vha, 0x006e,\r\n"Error Reading crb_init area: n: %08x.\n", n);\r\nreturn -1;\r\n}\r\noffset = n & 0xffffU;\r\nn = (n >> 16) & 0xffffU;\r\nif (n >= 1024) {\r\nql_log(ql_log_fatal, vha, 0x0071,\r\n"Card flash not initialized:n=0x%x.\n", n);\r\nreturn -1;\r\n}\r\nql_log(ql_log_info, vha, 0x0072,\r\n"%d CRB init values found in ROM.\n", n);\r\nbuf = kmalloc(n * sizeof(struct crb_addr_pair), GFP_KERNEL);\r\nif (buf == NULL) {\r\nql_log(ql_log_fatal, vha, 0x010c,\r\n"Unable to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nif (qla82xx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||\r\nqla82xx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) != 0) {\r\nkfree(buf);\r\nreturn -1;\r\n}\r\nbuf[i].addr = addr;\r\nbuf[i].data = val;\r\n}\r\nfor (i = 0; i < n; i++) {\r\noff = qla82xx_decode_crb_addr((unsigned long)buf[i].addr) +\r\nQLA82XX_PCI_CRBSPACE;\r\nif (off == QLA82XX_CAM_RAM(0x1fc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xbc))\r\ncontinue;\r\nif (off == (ROMUSB_GLB + 0xc8))\r\ncontinue;\r\nif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION))\r\ncontinue;\r\nif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION2))\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLA82XX_CRB_SMB)\r\ncontinue;\r\nif ((off & 0x0ff00000) == QLA82XX_CRB_DDR_NET)\r\ncontinue;\r\nif (off == ADDR_ERROR) {\r\nql_log(ql_log_fatal, vha, 0x0116,\r\n"Unknown addr: 0x%08lx.\n", buf[i].addr);\r\ncontinue;\r\n}\r\nqla82xx_wr_32(ha, off, buf[i].data);\r\nif (off == QLA82XX_ROMUSB_GLB_SW_RESET)\r\nmsleep(1000);\r\nmsleep(1);\r\n}\r\nkfree(buf);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0xec, 0x1e);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0x4c, 8);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_I+0x4c, 8);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0x8, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0xc, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0x8, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0xc, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0x8, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0xc, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0x8, 0);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0xc, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_pci_mem_write_2M(struct qla_hw_data *ha,\r\nu64 off, void *data, int size)\r\n{\r\nint i, j, ret = 0, loop, sz[2], off0;\r\nint scale, shift_amount, startword;\r\nuint32_t temp;\r\nuint64_t off8, mem_crb, tmpw, word[2] = {0, 0};\r\nif (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\r\nmem_crb = QLA82XX_CRB_QDR_NET;\r\nelse {\r\nmem_crb = QLA82XX_CRB_DDR_NET;\r\nif (qla82xx_pci_mem_bound_check(ha, off, size) == 0)\r\nreturn qla82xx_pci_mem_write_direct(ha,\r\noff, data, size);\r\n}\r\noff0 = off & 0x7;\r\nsz[0] = (size < (8 - off0)) ? size : (8 - off0);\r\nsz[1] = size - sz[0];\r\noff8 = off & 0xfffffff0;\r\nloop = (((off & 0xf) + size - 1) >> 4) + 1;\r\nshift_amount = 4;\r\nscale = 2;\r\nstartword = (off & 0xf)/8;\r\nfor (i = 0; i < loop; i++) {\r\nif (qla82xx_pci_mem_read_2M(ha, off8 +\r\n(i << shift_amount), &word[i * scale], 8))\r\nreturn -1;\r\n}\r\nswitch (size) {\r\ncase 1:\r\ntmpw = *((uint8_t *)data);\r\nbreak;\r\ncase 2:\r\ntmpw = *((uint16_t *)data);\r\nbreak;\r\ncase 4:\r\ntmpw = *((uint32_t *)data);\r\nbreak;\r\ncase 8:\r\ndefault:\r\ntmpw = *((uint64_t *)data);\r\nbreak;\r\n}\r\nif (sz[0] == 8) {\r\nword[startword] = tmpw;\r\n} else {\r\nword[startword] &=\r\n~((~(~0ULL << (sz[0] * 8))) << (off0 * 8));\r\nword[startword] |= tmpw << (off0 * 8);\r\n}\r\nif (sz[1] != 0) {\r\nword[startword+1] &= ~(~0ULL << (sz[1] * 8));\r\nword[startword+1] |= tmpw >> (sz[0] * 8);\r\n}\r\nfor (i = 0; i < loop; i++) {\r\ntemp = off8 + (i << shift_amount);\r\nqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_LO, temp);\r\ntemp = 0;\r\nqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_HI, temp);\r\ntemp = word[i * scale] & 0xffffffff;\r\nqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_LO, temp);\r\ntemp = (word[i * scale] >> 32) & 0xffffffff;\r\nqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_HI, temp);\r\ntemp = word[i*scale + 1] & 0xffffffff;\r\nqla82xx_wr_32(ha, mem_crb +\r\nMIU_TEST_AGT_WRDATA_UPPER_LO, temp);\r\ntemp = (word[i*scale + 1] >> 32) & 0xffffffff;\r\nqla82xx_wr_32(ha, mem_crb +\r\nMIU_TEST_AGT_WRDATA_UPPER_HI, temp);\r\ntemp = MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;\r\nqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\ntemp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;\r\nqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\r\nif ((temp & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&ha->pdev->dev,\r\n"failed to write through agent.\n");\r\nret = -1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_fw_load_from_flash(struct qla_hw_data *ha)\r\n{\r\nint i;\r\nlong size = 0;\r\nlong flashaddr = ha->flt_region_bootload << 2;\r\nlong memaddr = BOOTLD_START;\r\nu64 data;\r\nu32 high, low;\r\nsize = (IMAGE_START - BOOTLD_START) / 8;\r\nfor (i = 0; i < size; i++) {\r\nif ((qla82xx_rom_fast_read(ha, flashaddr, (int *)&low)) ||\r\n(qla82xx_rom_fast_read(ha, flashaddr + 4, (int *)&high))) {\r\nreturn -1;\r\n}\r\ndata = ((u64)high << 32) | low ;\r\nqla82xx_pci_mem_write_2M(ha, memaddr, &data, 8);\r\nflashaddr += 8;\r\nmemaddr += 8;\r\nif (i % 0x1000 == 0)\r\nmsleep(1);\r\n}\r\nudelay(100);\r\nread_lock(&ha->hw_lock);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\r\nread_unlock(&ha->hw_lock);\r\nreturn 0;\r\n}\r\nint\r\nqla82xx_pci_mem_read_2M(struct qla_hw_data *ha,\r\nu64 off, void *data, int size)\r\n{\r\nint i, j = 0, k, start, end, loop, sz[2], off0[2];\r\nint shift_amount;\r\nuint32_t temp;\r\nuint64_t off8, val, mem_crb, word[2] = {0, 0};\r\nif (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\r\nmem_crb = QLA82XX_CRB_QDR_NET;\r\nelse {\r\nmem_crb = QLA82XX_CRB_DDR_NET;\r\nif (qla82xx_pci_mem_bound_check(ha, off, size) == 0)\r\nreturn qla82xx_pci_mem_read_direct(ha,\r\noff, data, size);\r\n}\r\noff8 = off & 0xfffffff0;\r\noff0[0] = off & 0xf;\r\nsz[0] = (size < (16 - off0[0])) ? size : (16 - off0[0]);\r\nshift_amount = 4;\r\nloop = ((off0[0] + size - 1) >> shift_amount) + 1;\r\noff0[1] = 0;\r\nsz[1] = size - sz[0];\r\nfor (i = 0; i < loop; i++) {\r\ntemp = off8 + (i << shift_amount);\r\nqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);\r\ntemp = 0;\r\nqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);\r\ntemp = MIU_TA_CTL_ENABLE;\r\nqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\ntemp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;\r\nqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\r\nif ((temp & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&ha->pdev->dev,\r\n"failed to read through agent.\n");\r\nbreak;\r\n}\r\nstart = off0[i] >> 2;\r\nend = (off0[i] + sz[i] - 1) >> 2;\r\nfor (k = start; k <= end; k++) {\r\ntemp = qla82xx_rd_32(ha,\r\nmem_crb + MIU_TEST_AGT_RDDATA(k));\r\nword[i] |= ((uint64_t)temp << (32 * (k & 1)));\r\n}\r\n}\r\nif (j >= MAX_CTL_CHECK)\r\nreturn -1;\r\nif ((off0[0] & 7) == 0) {\r\nval = word[0];\r\n} else {\r\nval = ((word[0] >> (off0[0] * 8)) & (~(~0ULL << (sz[0] * 8)))) |\r\n((word[1] & (~(~0ULL << (sz[1] * 8)))) << (sz[0] * 8));\r\n}\r\nswitch (size) {\r\ncase 1:\r\n*(uint8_t *)data = val;\r\nbreak;\r\ncase 2:\r\n*(uint16_t *)data = val;\r\nbreak;\r\ncase 4:\r\n*(uint32_t *)data = val;\r\nbreak;\r\ncase 8:\r\n*(uint64_t *)data = val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct qla82xx_uri_table_desc *\r\nqla82xx_get_table_desc(const u8 *unirom, int section)\r\n{\r\nuint32_t i;\r\nstruct qla82xx_uri_table_desc *directory =\r\n(struct qla82xx_uri_table_desc *)&unirom[0];\r\n__le32 offset;\r\n__le32 tab_type;\r\n__le32 entries = cpu_to_le32(directory->num_entries);\r\nfor (i = 0; i < entries; i++) {\r\noffset = cpu_to_le32(directory->findex) +\r\n(i * cpu_to_le32(directory->entry_size));\r\ntab_type = cpu_to_le32(*((u32 *)&unirom[offset] + 8));\r\nif (tab_type == section)\r\nreturn (struct qla82xx_uri_table_desc *)&unirom[offset];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct qla82xx_uri_data_desc *\r\nqla82xx_get_data_desc(struct qla_hw_data *ha,\r\nu32 section, u32 idx_offset)\r\n{\r\nconst u8 *unirom = ha->hablob->fw->data;\r\nint idx = cpu_to_le32(*((int *)&unirom[ha->file_prd_off] + idx_offset));\r\nstruct qla82xx_uri_table_desc *tab_desc = NULL;\r\n__le32 offset;\r\ntab_desc = qla82xx_get_table_desc(unirom, section);\r\nif (!tab_desc)\r\nreturn NULL;\r\noffset = cpu_to_le32(tab_desc->findex) +\r\n(cpu_to_le32(tab_desc->entry_size) * idx);\r\nreturn (struct qla82xx_uri_data_desc *)&unirom[offset];\r\n}\r\nstatic u8 *\r\nqla82xx_get_bootld_offset(struct qla_hw_data *ha)\r\n{\r\nu32 offset = BOOTLD_START;\r\nstruct qla82xx_uri_data_desc *uri_desc = NULL;\r\nif (ha->fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\r\nuri_desc = qla82xx_get_data_desc(ha,\r\nQLA82XX_URI_DIR_SECT_BOOTLD, QLA82XX_URI_BOOTLD_IDX_OFF);\r\nif (uri_desc)\r\noffset = cpu_to_le32(uri_desc->findex);\r\n}\r\nreturn (u8 *)&ha->hablob->fw->data[offset];\r\n}\r\nstatic __le32\r\nqla82xx_get_fw_size(struct qla_hw_data *ha)\r\n{\r\nstruct qla82xx_uri_data_desc *uri_desc = NULL;\r\nif (ha->fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\r\nuri_desc = qla82xx_get_data_desc(ha, QLA82XX_URI_DIR_SECT_FW,\r\nQLA82XX_URI_FIRMWARE_IDX_OFF);\r\nif (uri_desc)\r\nreturn cpu_to_le32(uri_desc->size);\r\n}\r\nreturn cpu_to_le32(*(u32 *)&ha->hablob->fw->data[FW_SIZE_OFFSET]);\r\n}\r\nstatic u8 *\r\nqla82xx_get_fw_offs(struct qla_hw_data *ha)\r\n{\r\nu32 offset = IMAGE_START;\r\nstruct qla82xx_uri_data_desc *uri_desc = NULL;\r\nif (ha->fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\r\nuri_desc = qla82xx_get_data_desc(ha, QLA82XX_URI_DIR_SECT_FW,\r\nQLA82XX_URI_FIRMWARE_IDX_OFF);\r\nif (uri_desc)\r\noffset = cpu_to_le32(uri_desc->findex);\r\n}\r\nreturn (u8 *)&ha->hablob->fw->data[offset];\r\n}\r\nint qla82xx_pci_region_offset(struct pci_dev *pdev, int region)\r\n{\r\nunsigned long val = 0;\r\nu32 control;\r\nswitch (region) {\r\ncase 0:\r\nval = 0;\r\nbreak;\r\ncase 1:\r\npci_read_config_dword(pdev, QLA82XX_PCI_REG_MSIX_TBL, &control);\r\nval = control + QLA82XX_MSIX_TBL_SPACE;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nint\r\nqla82xx_iospace_config(struct qla_hw_data *ha)\r\n{\r\nuint32_t len = 0;\r\nif (pci_request_regions(ha->pdev, QLA2XXX_DRIVER_NAME)) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x000c,\r\n"Failed to reserver selected regions.\n");\r\ngoto iospace_error_exit;\r\n}\r\nif (!(pci_resource_flags(ha->pdev, 0) & IORESOURCE_MEM)) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x000d,\r\n"Region #0 not an MMIO resource, aborting.\n");\r\ngoto iospace_error_exit;\r\n}\r\nlen = pci_resource_len(ha->pdev, 0);\r\nha->nx_pcibase = ioremap(pci_resource_start(ha->pdev, 0), len);\r\nif (!ha->nx_pcibase) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x000e,\r\n"Cannot remap pcibase MMIO, aborting.\n");\r\ngoto iospace_error_exit;\r\n}\r\nif (IS_QLA8044(ha)) {\r\nha->iobase = ha->nx_pcibase;\r\n} else if (IS_QLA82XX(ha)) {\r\nha->iobase = ha->nx_pcibase + 0xbc000 + (ha->pdev->devfn << 11);\r\n}\r\nif (!ql2xdbwr) {\r\nha->nxdb_wr_ptr = ioremap((pci_resource_start(ha->pdev, 4) +\r\n(ha->pdev->devfn << 12)), 4);\r\nif (!ha->nxdb_wr_ptr) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x000f,\r\n"Cannot remap MMIO, aborting.\n");\r\ngoto iospace_error_exit;\r\n}\r\nha->nxdb_rd_ptr = ha->nx_pcibase + (512 * 1024) +\r\n(ha->pdev->devfn * 8);\r\n} else {\r\nha->nxdb_wr_ptr = (void __iomem *)(ha->pdev->devfn == 6 ?\r\nQLA82XX_CAMRAM_DB1 :\r\nQLA82XX_CAMRAM_DB2);\r\n}\r\nha->max_req_queues = ha->max_rsp_queues = 1;\r\nha->msix_count = ha->max_rsp_queues + 1;\r\nql_dbg_pci(ql_dbg_multiq, ha->pdev, 0xc006,\r\n"nx_pci_base=%p iobase=%p "\r\n"max_req_queues=%d msix_count=%d.\n",\r\nha->nx_pcibase, ha->iobase,\r\nha->max_req_queues, ha->msix_count);\r\nql_dbg_pci(ql_dbg_init, ha->pdev, 0x0010,\r\n"nx_pci_base=%p iobase=%p "\r\n"max_req_queues=%d msix_count=%d.\n",\r\nha->nx_pcibase, ha->iobase,\r\nha->max_req_queues, ha->msix_count);\r\nreturn 0;\r\niospace_error_exit:\r\nreturn -ENOMEM;\r\n}\r\nint\r\nqla82xx_pci_config(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint ret;\r\npci_set_master(ha->pdev);\r\nret = pci_set_mwi(ha->pdev);\r\nha->chip_revision = ha->pdev->revision;\r\nql_dbg(ql_dbg_init, vha, 0x0043,\r\n"Chip revision:%d; pci_set_mwi() returned %d.\n",\r\nha->chip_revision, ret);\r\nreturn 0;\r\n}\r\nvoid\r\nqla82xx_reset_chip(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nha->isp_ops->disable_intrs(ha);\r\n}\r\nvoid qla82xx_config_rings(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_82xx __iomem *reg = &ha->iobase->isp82;\r\nstruct init_cb_81xx *icb;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nicb = (struct init_cb_81xx *)ha->init_cb;\r\nicb->request_q_outpointer = cpu_to_le16(0);\r\nicb->response_q_inpointer = cpu_to_le16(0);\r\nicb->request_q_length = cpu_to_le16(req->length);\r\nicb->response_q_length = cpu_to_le16(rsp->length);\r\nicb->request_q_address[0] = cpu_to_le32(LSD(req->dma));\r\nicb->request_q_address[1] = cpu_to_le32(MSD(req->dma));\r\nicb->response_q_address[0] = cpu_to_le32(LSD(rsp->dma));\r\nicb->response_q_address[1] = cpu_to_le32(MSD(rsp->dma));\r\nWRT_REG_DWORD(&reg->req_q_out[0], 0);\r\nWRT_REG_DWORD(&reg->rsp_q_in[0], 0);\r\nWRT_REG_DWORD(&reg->rsp_q_out[0], 0);\r\n}\r\nstatic int\r\nqla82xx_fw_load_from_blob(struct qla_hw_data *ha)\r\n{\r\nu64 *ptr64;\r\nu32 i, flashaddr, size;\r\n__le64 data;\r\nsize = (IMAGE_START - BOOTLD_START) / 8;\r\nptr64 = (u64 *)qla82xx_get_bootld_offset(ha);\r\nflashaddr = BOOTLD_START;\r\nfor (i = 0; i < size; i++) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (qla82xx_pci_mem_write_2M(ha, flashaddr, &data, 8))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nflashaddr = FLASH_ADDR_START;\r\nsize = (__force u32)qla82xx_get_fw_size(ha) / 8;\r\nptr64 = (u64 *)qla82xx_get_fw_offs(ha);\r\nfor (i = 0; i < size; i++) {\r\ndata = cpu_to_le64(ptr64[i]);\r\nif (qla82xx_pci_mem_write_2M(ha, flashaddr, &data, 8))\r\nreturn -EIO;\r\nflashaddr += 8;\r\n}\r\nudelay(100);\r\nqla82xx_wr_32(ha, QLA82XX_CAM_RAM(0x1fc), QLA82XX_BDINFO_MAGIC);\r\nread_lock(&ha->hw_lock);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\r\nread_unlock(&ha->hw_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_set_product_offset(struct qla_hw_data *ha)\r\n{\r\nstruct qla82xx_uri_table_desc *ptab_desc = NULL;\r\nconst uint8_t *unirom = ha->hablob->fw->data;\r\nuint32_t i;\r\n__le32 entries;\r\n__le32 flags, file_chiprev, offset;\r\nuint8_t chiprev = ha->chip_revision;\r\nint mn_present = 0;\r\nuint32_t flagbit;\r\nptab_desc = qla82xx_get_table_desc(unirom,\r\nQLA82XX_URI_DIR_SECT_PRODUCT_TBL);\r\nif (!ptab_desc)\r\nreturn -1;\r\nentries = cpu_to_le32(ptab_desc->num_entries);\r\nfor (i = 0; i < entries; i++) {\r\noffset = cpu_to_le32(ptab_desc->findex) +\r\n(i * cpu_to_le32(ptab_desc->entry_size));\r\nflags = cpu_to_le32(*((int *)&unirom[offset] +\r\nQLA82XX_URI_FLAGS_OFF));\r\nfile_chiprev = cpu_to_le32(*((int *)&unirom[offset] +\r\nQLA82XX_URI_CHIP_REV_OFF));\r\nflagbit = mn_present ? 1 : 2;\r\nif ((chiprev == file_chiprev) && ((1ULL << flagbit) & flags)) {\r\nha->file_prd_off = offset;\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nqla82xx_validate_firmware_blob(scsi_qla_host_t *vha, uint8_t fw_type)\r\n{\r\n__le32 val;\r\nuint32_t min_size;\r\nstruct qla_hw_data *ha = vha->hw;\r\nconst struct firmware *fw = ha->hablob->fw;\r\nha->fw_type = fw_type;\r\nif (fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\r\nif (qla82xx_set_product_offset(ha))\r\nreturn -EINVAL;\r\nmin_size = QLA82XX_URI_FW_MIN_SIZE;\r\n} else {\r\nval = cpu_to_le32(*(u32 *)&fw->data[QLA82XX_FW_MAGIC_OFFSET]);\r\nif ((__force u32)val != QLA82XX_BDINFO_MAGIC)\r\nreturn -EINVAL;\r\nmin_size = QLA82XX_FW_MIN_SIZE;\r\n}\r\nif (fw->size < min_size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nqla82xx_check_cmdpeg_state(struct qla_hw_data *ha)\r\n{\r\nu32 val = 0;\r\nint retries = 60;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\ndo {\r\nread_lock(&ha->hw_lock);\r\nval = qla82xx_rd_32(ha, CRB_CMDPEG_STATE);\r\nread_unlock(&ha->hw_lock);\r\nswitch (val) {\r\ncase PHAN_INITIALIZE_COMPLETE:\r\ncase PHAN_INITIALIZE_ACK:\r\nreturn QLA_SUCCESS;\r\ncase PHAN_INITIALIZE_FAILED:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nql_log(ql_log_info, vha, 0x00a8,\r\n"CRB_CMDPEG_STATE: 0x%x and retries:0x%x.\n",\r\nval, retries);\r\nmsleep(500);\r\n} while (--retries);\r\nql_log(ql_log_fatal, vha, 0x00a9,\r\n"Cmd Peg initialization failed: 0x%x.\n", val);\r\nval = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_PEGTUNE_DONE);\r\nread_lock(&ha->hw_lock);\r\nqla82xx_wr_32(ha, CRB_CMDPEG_STATE, PHAN_INITIALIZE_FAILED);\r\nread_unlock(&ha->hw_lock);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic int\r\nqla82xx_check_rcvpeg_state(struct qla_hw_data *ha)\r\n{\r\nu32 val = 0;\r\nint retries = 60;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\ndo {\r\nread_lock(&ha->hw_lock);\r\nval = qla82xx_rd_32(ha, CRB_RCVPEG_STATE);\r\nread_unlock(&ha->hw_lock);\r\nswitch (val) {\r\ncase PHAN_INITIALIZE_COMPLETE:\r\ncase PHAN_INITIALIZE_ACK:\r\nreturn QLA_SUCCESS;\r\ncase PHAN_INITIALIZE_FAILED:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nql_log(ql_log_info, vha, 0x00ab,\r\n"CRB_RCVPEG_STATE: 0x%x and retries: 0x%x.\n",\r\nval, retries);\r\nmsleep(500);\r\n} while (--retries);\r\nql_log(ql_log_fatal, vha, 0x00ac,\r\n"Rcv Peg initializatin failed: 0x%x.\n", val);\r\nread_lock(&ha->hw_lock);\r\nqla82xx_wr_32(ha, CRB_RCVPEG_STATE, PHAN_INITIALIZE_FAILED);\r\nread_unlock(&ha->hw_lock);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nvoid\r\nqla82xx_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)\r\n{\r\nuint16_t cnt;\r\nuint16_t __iomem *wptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_82xx __iomem *reg = &ha->iobase->isp82;\r\nwptr = (uint16_t __iomem *)&reg->mailbox_out[1];\r\nha->flags.mbox_int = 1;\r\nha->mailbox_out[0] = mb0;\r\nfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\r\nha->mailbox_out[cnt] = RD_REG_WORD(wptr);\r\nwptr++;\r\n}\r\nif (!ha->mcp)\r\nql_dbg(ql_dbg_async, vha, 0x5053,\r\n"MBX pointer ERROR.\n");\r\n}\r\nirqreturn_t\r\nqla82xx_intr_handler(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_82xx __iomem *reg;\r\nint status = 0, status1 = 0;\r\nunsigned long flags;\r\nunsigned long iter;\r\nuint32_t stat = 0;\r\nuint16_t mb[4];\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0xb053,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nif (!ha->flags.msi_enabled) {\r\nstatus = qla82xx_rd_32(ha, ISR_INT_VECTOR);\r\nif (!(status & ha->nx_legacy_intr.int_vec_bit))\r\nreturn IRQ_NONE;\r\nstatus1 = qla82xx_rd_32(ha, ISR_INT_STATE_REG);\r\nif (!ISR_IS_LEGACY_INTR_TRIGGERED(status1))\r\nreturn IRQ_NONE;\r\n}\r\nqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);\r\nqla82xx_rd_32(ha, ISR_INT_VECTOR);\r\nqla82xx_rd_32(ha, ISR_INT_VECTOR);\r\nreg = &ha->iobase->isp82;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nfor (iter = 1; iter--; ) {\r\nif (RD_REG_DWORD(&reg->host_int)) {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla82xx_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_REG_WORD(&reg->mailbox_out[1]);\r\nmb[2] = RD_REG_WORD(&reg->mailbox_out[2]);\r\nmb[3] = RD_REG_WORD(&reg->mailbox_out[3]);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5054,\r\n"Unrecognized interrupt type (%d).\n",\r\nstat & 0xff);\r\nbreak;\r\n}\r\n}\r\nWRT_REG_DWORD(&reg->host_int, 0);\r\n}\r\nqla2x00_handle_mbx_completion(ha, status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (!ha->flags.msi_enabled)\r\nqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t\r\nqla82xx_msix_default(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_82xx __iomem *reg;\r\nint status = 0;\r\nunsigned long flags;\r\nuint32_t stat = 0;\r\nuint32_t host_int = 0;\r\nuint16_t mb[4];\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nprintk(KERN_INFO\r\n"%s(): NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp82;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\ndo {\r\nhost_int = RD_REG_DWORD(&reg->host_int);\r\nif (qla2x00_check_reg32_for_disconnect(vha, host_int))\r\nbreak;\r\nif (host_int) {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla82xx_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_REG_WORD(&reg->mailbox_out[1]);\r\nmb[2] = RD_REG_WORD(&reg->mailbox_out[2]);\r\nmb[3] = RD_REG_WORD(&reg->mailbox_out[3]);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5041,\r\n"Unrecognized interrupt type (%d).\n",\r\nstat & 0xff);\r\nbreak;\r\n}\r\n}\r\nWRT_REG_DWORD(&reg->host_int, 0);\r\n} while (0);\r\nqla2x00_handle_mbx_completion(ha, status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t\r\nqla82xx_msix_rsp_q(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_82xx __iomem *reg;\r\nunsigned long flags;\r\nuint32_t host_int = 0;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nprintk(KERN_INFO\r\n"%s(): NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp82;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nhost_int = RD_REG_DWORD(&reg->host_int);\r\nif (qla2x00_check_reg32_for_disconnect(vha, host_int))\r\ngoto out;\r\nqla24xx_process_response_queue(vha, rsp);\r\nWRT_REG_DWORD(&reg->host_int, 0);\r\nout:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid\r\nqla82xx_poll(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_82xx __iomem *reg;\r\nint status = 0;\r\nuint32_t stat;\r\nuint32_t host_int = 0;\r\nuint16_t mb[4];\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nprintk(KERN_INFO\r\n"%s(): NULL response queue pointer.\n", __func__);\r\nreturn;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->isp82;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nhost_int = RD_REG_DWORD(&reg->host_int);\r\nif (qla2x00_check_reg32_for_disconnect(vha, host_int))\r\ngoto out;\r\nif (host_int) {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla82xx_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_REG_WORD(&reg->mailbox_out[1]);\r\nmb[2] = RD_REG_WORD(&reg->mailbox_out[2]);\r\nmb[3] = RD_REG_WORD(&reg->mailbox_out[3]);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_p3p, vha, 0xb013,\r\n"Unrecognized interrupt type (%d).\n",\r\nstat * 0xff);\r\nbreak;\r\n}\r\nWRT_REG_DWORD(&reg->host_int, 0);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid\r\nqla82xx_enable_intrs(struct qla_hw_data *ha)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nqla82xx_mbx_intr_enable(vha);\r\nspin_lock_irq(&ha->hardware_lock);\r\nif (IS_QLA8044(ha))\r\nqla8044_wr_reg(ha, LEG_INTR_MASK_OFFSET, 0);\r\nelse\r\nqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\r\nspin_unlock_irq(&ha->hardware_lock);\r\nha->interrupts_on = 1;\r\n}\r\nvoid\r\nqla82xx_disable_intrs(struct qla_hw_data *ha)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nqla82xx_mbx_intr_disable(vha);\r\nspin_lock_irq(&ha->hardware_lock);\r\nif (IS_QLA8044(ha))\r\nqla8044_wr_reg(ha, LEG_INTR_MASK_OFFSET, 1);\r\nelse\r\nqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);\r\nspin_unlock_irq(&ha->hardware_lock);\r\nha->interrupts_on = 0;\r\n}\r\nvoid qla82xx_init_flags(struct qla_hw_data *ha)\r\n{\r\nstruct qla82xx_legacy_intr_set *nx_legacy_intr;\r\nrwlock_init(&ha->hw_lock);\r\nha->qdr_sn_window = -1;\r\nha->ddr_mn_window = -1;\r\nha->curr_window = 255;\r\nha->portnum = PCI_FUNC(ha->pdev->devfn);\r\nnx_legacy_intr = &legacy_intr[ha->portnum];\r\nha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;\r\nha->nx_legacy_intr.tgt_status_reg = nx_legacy_intr->tgt_status_reg;\r\nha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;\r\nha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;\r\n}\r\nstatic inline void\r\nqla82xx_set_idc_version(scsi_qla_host_t *vha)\r\n{\r\nint idc_ver;\r\nuint32_t drv_active;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\nif (drv_active == (QLA82XX_DRV_ACTIVE << (ha->portnum * 4))) {\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION,\r\nQLA82XX_IDC_VERSION);\r\nql_log(ql_log_info, vha, 0xb082,\r\n"IDC version updated to %d\n", QLA82XX_IDC_VERSION);\r\n} else {\r\nidc_ver = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_IDC_VERSION);\r\nif (idc_ver != QLA82XX_IDC_VERSION)\r\nql_log(ql_log_info, vha, 0xb083,\r\n"qla2xxx driver IDC version %d is not compatible "\r\n"with IDC version %d of the other drivers\n",\r\nQLA82XX_IDC_VERSION, idc_ver);\r\n}\r\n}\r\ninline void\r\nqla82xx_set_drv_active(scsi_qla_host_t *vha)\r\n{\r\nuint32_t drv_active;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\nif (drv_active == 0xffffffff) {\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE,\r\nQLA82XX_DRV_NOT_ACTIVE);\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\n}\r\ndrv_active |= (QLA82XX_DRV_ACTIVE << (ha->portnum * 4));\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);\r\n}\r\ninline void\r\nqla82xx_clear_drv_active(struct qla_hw_data *ha)\r\n{\r\nuint32_t drv_active;\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndrv_active &= ~(QLA82XX_DRV_ACTIVE << (ha->portnum * 4));\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);\r\n}\r\nstatic inline int\r\nqla82xx_need_reset(struct qla_hw_data *ha)\r\n{\r\nuint32_t drv_state;\r\nint rval;\r\nif (ha->flags.nic_core_reset_owner)\r\nreturn 1;\r\nelse {\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\nrval = drv_state & (QLA82XX_DRVST_RST_RDY << (ha->portnum * 4));\r\nreturn rval;\r\n}\r\n}\r\nstatic inline void\r\nqla82xx_set_rst_ready(struct qla_hw_data *ha)\r\n{\r\nuint32_t drv_state;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\nif (drv_state == 0xffffffff) {\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, QLA82XX_DRVST_NOT_RDY);\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\n}\r\ndrv_state |= (QLA82XX_DRVST_RST_RDY << (ha->portnum * 4));\r\nql_dbg(ql_dbg_init, vha, 0x00bb,\r\n"drv_state = 0x%08x.\n", drv_state);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);\r\n}\r\nstatic inline void\r\nqla82xx_clear_rst_ready(struct qla_hw_data *ha)\r\n{\r\nuint32_t drv_state;\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_state &= ~(QLA82XX_DRVST_RST_RDY << (ha->portnum * 4));\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);\r\n}\r\nstatic inline void\r\nqla82xx_set_qsnt_ready(struct qla_hw_data *ha)\r\n{\r\nuint32_t qsnt_state;\r\nqsnt_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\nqsnt_state |= (QLA82XX_DRVST_QSNT_RDY << (ha->portnum * 4));\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);\r\n}\r\nvoid\r\nqla82xx_clear_qsnt_ready(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t qsnt_state;\r\nqsnt_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\nqsnt_state &= ~(QLA82XX_DRVST_QSNT_RDY << (ha->portnum * 4));\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);\r\n}\r\nstatic int\r\nqla82xx_load_fw(scsi_qla_host_t *vha)\r\n{\r\nint rst;\r\nstruct fw_blob *blob;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (qla82xx_pinit_from_rom(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0x009f,\r\n"Error during CRB initialization.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nudelay(500);\r\nrst = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);\r\nrst &= ~((1 << 28) | (1 << 24));\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);\r\nif (ql2xfwloadbin == 2)\r\ngoto try_blob_fw;\r\nql_log(ql_log_info, vha, 0x00a0,\r\n"Attempting to load firmware from flash.\n");\r\nif (qla82xx_fw_load_from_flash(ha) == QLA_SUCCESS) {\r\nql_log(ql_log_info, vha, 0x00a1,\r\n"Firmware loaded successfully from flash.\n");\r\nreturn QLA_SUCCESS;\r\n} else {\r\nql_log(ql_log_warn, vha, 0x0108,\r\n"Firmware load from flash failed.\n");\r\n}\r\ntry_blob_fw:\r\nql_log(ql_log_info, vha, 0x00a2,\r\n"Attempting to load firmware from blob.\n");\r\nblob = ha->hablob = qla2x00_request_firmware(vha);\r\nif (!blob) {\r\nql_log(ql_log_fatal, vha, 0x00a3,\r\n"Firmware image not present.\n");\r\ngoto fw_load_failed;\r\n}\r\nif (qla82xx_validate_firmware_blob(vha,\r\nQLA82XX_FLASH_ROMIMAGE)) {\r\nif (qla82xx_validate_firmware_blob(vha,\r\nQLA82XX_UNIFIED_ROMIMAGE)) {\r\nql_log(ql_log_fatal, vha, 0x00a4,\r\n"No valid firmware image found.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nif (qla82xx_fw_load_from_blob(ha) == QLA_SUCCESS) {\r\nql_log(ql_log_info, vha, 0x00a5,\r\n"Firmware loaded successfully from binary blob.\n");\r\nreturn QLA_SUCCESS;\r\n}\r\nql_log(ql_log_fatal, vha, 0x00a6,\r\n"Firmware load failed for binary blob.\n");\r\nblob->fw = NULL;\r\nblob = NULL;\r\nfw_load_failed:\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nint\r\nqla82xx_start_firmware(scsi_qla_host_t *vha)\r\n{\r\nuint16_t lnk;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla82xx_wr_32(ha, CRB_DMA_SHIFT, QLA82XX_DMA_SHIFT_VALUE);\r\nqla82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);\r\nqla82xx_wr_32(ha, CRB_RCVPEG_STATE, 0);\r\nqla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);\r\nqla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);\r\nif (qla82xx_load_fw(vha) != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0x00a7,\r\n"Error trying to start fw.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nif (qla82xx_check_cmdpeg_state(ha) != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0x00aa,\r\n"Error during card handshake.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\npcie_capability_read_word(ha->pdev, PCI_EXP_LNKSTA, &lnk);\r\nha->link_width = (lnk >> 4) & 0x3f;\r\nreturn qla82xx_check_rcvpeg_state(ha);\r\n}\r\nstatic uint32_t *\r\nqla82xx_read_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,\r\nuint32_t length)\r\n{\r\nuint32_t i;\r\nuint32_t val;\r\nstruct qla_hw_data *ha = vha->hw;\r\nfor (i = 0; i < length/4; i++, faddr += 4) {\r\nif (qla82xx_rom_fast_read(ha, faddr, &val)) {\r\nql_log(ql_log_warn, vha, 0x0106,\r\n"Do ROM fast read failed.\n");\r\ngoto done_read;\r\n}\r\ndwptr[i] = cpu_to_le32(val);\r\n}\r\ndone_read:\r\nreturn dwptr;\r\n}\r\nstatic int\r\nqla82xx_unprotect_flash(struct qla_hw_data *ha)\r\n{\r\nint ret;\r\nuint32_t val;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nret = ql82xx_rom_lock_d(ha);\r\nif (ret < 0) {\r\nql_log(ql_log_warn, vha, 0xb014,\r\n"ROM Lock failed.\n");\r\nreturn ret;\r\n}\r\nret = qla82xx_read_status_reg(ha, &val);\r\nif (ret < 0)\r\ngoto done_unprotect;\r\nval &= ~(BLOCK_PROTECT_BITS << 2);\r\nret = qla82xx_write_status_reg(ha, val);\r\nif (ret < 0) {\r\nval |= (BLOCK_PROTECT_BITS << 2);\r\nqla82xx_write_status_reg(ha, val);\r\n}\r\nif (qla82xx_write_disable_flash(ha) != 0)\r\nql_log(ql_log_warn, vha, 0xb015,\r\n"Write disable failed.\n");\r\ndone_unprotect:\r\nqla82xx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_protect_flash(struct qla_hw_data *ha)\r\n{\r\nint ret;\r\nuint32_t val;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nret = ql82xx_rom_lock_d(ha);\r\nif (ret < 0) {\r\nql_log(ql_log_warn, vha, 0xb016,\r\n"ROM Lock failed.\n");\r\nreturn ret;\r\n}\r\nret = qla82xx_read_status_reg(ha, &val);\r\nif (ret < 0)\r\ngoto done_protect;\r\nval |= (BLOCK_PROTECT_BITS << 2);\r\nret = qla82xx_write_status_reg(ha, val);\r\nif (ret < 0)\r\nql_log(ql_log_warn, vha, 0xb017,\r\n"Write status register failed.\n");\r\nif (qla82xx_write_disable_flash(ha) != 0)\r\nql_log(ql_log_warn, vha, 0xb018,\r\n"Write disable failed.\n");\r\ndone_protect:\r\nqla82xx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla82xx_erase_sector(struct qla_hw_data *ha, int addr)\r\n{\r\nint ret = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nret = ql82xx_rom_lock_d(ha);\r\nif (ret < 0) {\r\nql_log(ql_log_warn, vha, 0xb019,\r\n"ROM Lock failed.\n");\r\nreturn ret;\r\n}\r\nqla82xx_flash_set_write_enable(ha);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\r\nqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_SE);\r\nif (qla82xx_wait_rom_done(ha)) {\r\nql_log(ql_log_warn, vha, 0xb01a,\r\n"Error waiting for rom done.\n");\r\nret = -1;\r\ngoto done;\r\n}\r\nret = qla82xx_flash_wait_write_finish(ha);\r\ndone:\r\nqla82xx_rom_unlock(ha);\r\nreturn ret;\r\n}\r\nuint8_t *\r\nqla82xx_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nscsi_block_requests(vha->host);\r\nqla82xx_read_flash_data(vha, (uint32_t *)buf, offset, length);\r\nscsi_unblock_requests(vha->host);\r\nreturn buf;\r\n}\r\nstatic int\r\nqla82xx_write_flash_data(struct scsi_qla_host *vha, uint32_t *dwptr,\r\nuint32_t faddr, uint32_t dwords)\r\n{\r\nint ret;\r\nuint32_t liter;\r\nuint32_t rest_addr;\r\ndma_addr_t optrom_dma;\r\nvoid *optrom = NULL;\r\nint page_mode = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nret = -1;\r\nif (page_mode && !(faddr & 0xfff) &&\r\ndwords > OPTROM_BURST_DWORDS) {\r\noptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\r\n&optrom_dma, GFP_KERNEL);\r\nif (!optrom) {\r\nql_log(ql_log_warn, vha, 0xb01b,\r\n"Unable to allocate memory "\r\n"for optrom burst write (%x KB).\n",\r\nOPTROM_BURST_SIZE / 1024);\r\n}\r\n}\r\nrest_addr = ha->fdt_block_size - 1;\r\nret = qla82xx_unprotect_flash(ha);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0xb01c,\r\n"Unable to unprotect flash for update.\n");\r\ngoto write_done;\r\n}\r\nfor (liter = 0; liter < dwords; liter++, faddr += 4, dwptr++) {\r\nif ((faddr & rest_addr) == 0) {\r\nret = qla82xx_erase_sector(ha, faddr);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0xb01d,\r\n"Unable to erase sector: address=%x.\n",\r\nfaddr);\r\nbreak;\r\n}\r\n}\r\nif (optrom && (liter + OPTROM_BURST_DWORDS) <= dwords) {\r\nmemcpy(optrom, dwptr, OPTROM_BURST_SIZE);\r\nret = qla2x00_load_ram(vha, optrom_dma,\r\n(ha->flash_data_off | faddr),\r\nOPTROM_BURST_DWORDS);\r\nif (ret != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0xb01e,\r\n"Unable to burst-write optrom segment "\r\n"(%x/%x/%llx).\n", ret,\r\n(ha->flash_data_off | faddr),\r\n(unsigned long long)optrom_dma);\r\nql_log(ql_log_warn, vha, 0xb01f,\r\n"Reverting to slow-write.\n");\r\ndma_free_coherent(&ha->pdev->dev,\r\nOPTROM_BURST_SIZE, optrom, optrom_dma);\r\noptrom = NULL;\r\n} else {\r\nliter += OPTROM_BURST_DWORDS - 1;\r\nfaddr += OPTROM_BURST_DWORDS - 1;\r\ndwptr += OPTROM_BURST_DWORDS - 1;\r\ncontinue;\r\n}\r\n}\r\nret = qla82xx_write_flash_dword(ha, faddr,\r\ncpu_to_le32(*dwptr));\r\nif (ret) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb020,\r\n"Unable to program flash address=%x data=%x.\n",\r\nfaddr, *dwptr);\r\nbreak;\r\n}\r\n}\r\nret = qla82xx_protect_flash(ha);\r\nif (ret)\r\nql_log(ql_log_warn, vha, 0xb021,\r\n"Unable to protect flash after update.\n");\r\nwrite_done:\r\nif (optrom)\r\ndma_free_coherent(&ha->pdev->dev,\r\nOPTROM_BURST_SIZE, optrom, optrom_dma);\r\nreturn ret;\r\n}\r\nint\r\nqla82xx_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nint rval;\r\nscsi_block_requests(vha->host);\r\nrval = qla82xx_write_flash_data(vha, (uint32_t *)buf, offset,\r\nlength >> 2);\r\nscsi_unblock_requests(vha->host);\r\nif (rval)\r\nrval = QLA_FUNCTION_FAILED;\r\nelse\r\nrval = QLA_SUCCESS;\r\nreturn rval;\r\n}\r\nvoid\r\nqla82xx_start_iocbs(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nuint32_t dbval;\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\ndbval = 0x04 | (ha->portnum << 5);\r\ndbval = dbval | (req->id << 8) | (req->ring_index << 16);\r\nif (ql2xdbwr)\r\nqla82xx_wr_32(ha, (unsigned long)ha->nxdb_wr_ptr, dbval);\r\nelse {\r\nWRT_REG_DWORD(ha->nxdb_wr_ptr, dbval);\r\nwmb();\r\nwhile (RD_REG_DWORD(ha->nxdb_rd_ptr) != dbval) {\r\nWRT_REG_DWORD(ha->nxdb_wr_ptr, dbval);\r\nwmb();\r\n}\r\n}\r\n}\r\nstatic void\r\nqla82xx_rom_lock_recovery(struct qla_hw_data *ha)\r\n{\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nuint32_t lock_owner = 0;\r\nif (qla82xx_rom_lock(ha)) {\r\nlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\r\nql_log(ql_log_info, vha, 0xb022,\r\n"Resetting rom_lock, Lock Owner %u.\n", lock_owner);\r\n}\r\nqla82xx_rom_unlock(ha);\r\n}\r\nstatic int\r\nqla82xx_device_bootstrap(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nint i;\r\nuint32_t old_count, count;\r\nstruct qla_hw_data *ha = vha->hw;\r\nint need_reset = 0;\r\nneed_reset = qla82xx_need_reset(ha);\r\nif (need_reset) {\r\nif (ha->flags.isp82xx_fw_hung)\r\nqla82xx_rom_lock_recovery(ha);\r\n} else {\r\nold_count = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(200);\r\ncount = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\r\nif (count != old_count) {\r\nrval = QLA_SUCCESS;\r\ngoto dev_ready;\r\n}\r\n}\r\nqla82xx_rom_lock_recovery(ha);\r\n}\r\nql_log(ql_log_info, vha, 0x009e,\r\n"HW State: INITIALIZING.\n");\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_INITIALIZING);\r\nqla82xx_idc_unlock(ha);\r\nrval = qla82xx_start_firmware(vha);\r\nqla82xx_idc_lock(ha);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0x00ad,\r\n"HW State: FAILED.\n");\r\nqla82xx_clear_drv_active(ha);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_FAILED);\r\nreturn rval;\r\n}\r\ndev_ready:\r\nql_log(ql_log_info, vha, 0x00ae,\r\n"HW State: READY.\n");\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_READY);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla82xx_need_qsnt_handler(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t dev_state, drv_state, drv_active;\r\nunsigned long reset_timeout;\r\nif (vha->flags.online) {\r\nqla2x00_quiesce_io(vha);\r\n}\r\nqla82xx_set_qsnt_ready(ha);\r\nreset_timeout = jiffies + (30 * HZ);\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndrv_active = drv_active << 0x01;\r\nwhile (drv_state != drv_active) {\r\nif (time_after_eq(jiffies, reset_timeout)) {\r\nql_log(ql_log_info, vha, 0xb023,\r\n"%s : QUIESCENT TIMEOUT DRV_ACTIVE:%d "\r\n"DRV_STATE:%d.\n", QLA2XXX_DRIVER_NAME,\r\ndrv_active, drv_state);\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_READY);\r\nql_log(ql_log_info, vha, 0xb025,\r\n"HW State: DEV_READY.\n");\r\nqla82xx_idc_unlock(ha);\r\nqla2x00_perform_loop_resync(vha);\r\nqla82xx_idc_lock(ha);\r\nqla82xx_clear_qsnt_ready(vha);\r\nreturn;\r\n}\r\nqla82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndrv_active = drv_active << 0x01;\r\n}\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (dev_state == QLA8XXX_DEV_NEED_QUIESCENT) {\r\nql_log(ql_log_info, vha, 0xb026,\r\n"HW State: DEV_QUIESCENT.\n");\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_QUIESCENT);\r\n}\r\n}\r\nuint32_t\r\nqla82xx_wait_for_state_change(scsi_qla_host_t *vha, uint32_t curr_state)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t dev_state;\r\ndo {\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nqla82xx_idc_unlock(ha);\r\n} while (dev_state == curr_state);\r\nreturn dev_state;\r\n}\r\nvoid\r\nqla8xxx_dev_failed_handler(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_log(ql_log_fatal, vha, 0x00b8,\r\n"Disabling the board.\n");\r\nif (IS_QLA82XX(ha)) {\r\nqla82xx_clear_drv_active(ha);\r\nqla82xx_idc_unlock(ha);\r\n} else if (IS_QLA8044(ha)) {\r\nqla8044_clear_drv_active(ha);\r\nqla8044_idc_unlock(ha);\r\n}\r\nvha->device_flags |= DFLG_DEV_FAILED;\r\nqla2x00_abort_all_cmds(vha, DID_NO_CONNECT << 16);\r\nqla2x00_mark_all_devices_lost(vha, 0);\r\nvha->flags.online = 0;\r\nvha->flags.init_done = 0;\r\n}\r\nstatic void\r\nqla82xx_need_reset_handler(scsi_qla_host_t *vha)\r\n{\r\nuint32_t dev_state, drv_state, drv_active;\r\nuint32_t active_mask = 0;\r\nunsigned long reset_timeout;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nif (vha->flags.online) {\r\nqla82xx_idc_unlock(ha);\r\nqla2x00_abort_isp_cleanup(vha);\r\nha->isp_ops->get_flash_version(vha, req->ring);\r\nha->isp_ops->nvram_config(vha);\r\nqla82xx_idc_lock(ha);\r\n}\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\nif (!ha->flags.nic_core_reset_owner) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb028,\r\n"reset_acknowledged by 0x%x\n", ha->portnum);\r\nqla82xx_set_rst_ready(ha);\r\n} else {\r\nactive_mask = ~(QLA82XX_DRV_ACTIVE << (ha->portnum * 4));\r\ndrv_active &= active_mask;\r\nql_dbg(ql_dbg_p3p, vha, 0xb029,\r\n"active_mask: 0x%08x\n", active_mask);\r\n}\r\nreset_timeout = jiffies + (ha->fcoe_reset_timeout * HZ);\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nql_dbg(ql_dbg_p3p, vha, 0xb02a,\r\n"drv_state: 0x%08x, drv_active: 0x%08x, "\r\n"dev_state: 0x%08x, active_mask: 0x%08x\n",\r\ndrv_state, drv_active, dev_state, active_mask);\r\nwhile (drv_state != drv_active &&\r\ndev_state != QLA8XXX_DEV_INITIALIZING) {\r\nif (time_after_eq(jiffies, reset_timeout)) {\r\nql_log(ql_log_warn, vha, 0x00b5,\r\n"Reset timeout.\n");\r\nbreak;\r\n}\r\nqla82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\ndrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\r\ndrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\r\nif (ha->flags.nic_core_reset_owner)\r\ndrv_active &= active_mask;\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb02b,\r\n"drv_state: 0x%08x, drv_active: 0x%08x, "\r\n"dev_state: 0x%08x, active_mask: 0x%08x\n",\r\ndrv_state, drv_active, dev_state, active_mask);\r\nql_log(ql_log_info, vha, 0x00b6,\r\n"Device state is 0x%x = %s.\n",\r\ndev_state,\r\ndev_state < MAX_STATES ? qdev_state(dev_state) : "Unknown");\r\nif (dev_state != QLA8XXX_DEV_INITIALIZING &&\r\ndev_state != QLA8XXX_DEV_COLD) {\r\nql_log(ql_log_info, vha, 0x00b7,\r\n"HW State: COLD/RE-INIT.\n");\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_COLD);\r\nqla82xx_set_rst_ready(ha);\r\nif (ql2xmdenable) {\r\nif (qla82xx_md_collect(vha))\r\nql_log(ql_log_warn, vha, 0xb02c,\r\n"Minidump not collected.\n");\r\n} else\r\nql_log(ql_log_warn, vha, 0xb04f,\r\n"Minidump disabled.\n");\r\n}\r\n}\r\nint\r\nqla82xx_check_md_needed(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t fw_major_version, fw_minor_version, fw_subminor_version;\r\nint rval = QLA_SUCCESS;\r\nfw_major_version = ha->fw_major_version;\r\nfw_minor_version = ha->fw_minor_version;\r\nfw_subminor_version = ha->fw_subminor_version;\r\nrval = qla2x00_get_fw_version(vha);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nif (ql2xmdenable) {\r\nif (!ha->fw_dumped) {\r\nif ((fw_major_version != ha->fw_major_version ||\r\nfw_minor_version != ha->fw_minor_version ||\r\nfw_subminor_version != ha->fw_subminor_version) ||\r\n(ha->prev_minidump_failed)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb02d,\r\n"Firmware version differs Previous version: %d:%d:%d - New version: %d:%d:%d, prev_minidump_failed: %d.\n",\r\nfw_major_version, fw_minor_version,\r\nfw_subminor_version,\r\nha->fw_major_version,\r\nha->fw_minor_version,\r\nha->fw_subminor_version,\r\nha->prev_minidump_failed);\r\nqla82xx_md_free(vha);\r\nqla82xx_md_prep(vha);\r\n}\r\n} else\r\nql_log(ql_log_info, vha, 0xb02e,\r\n"Firmware dump available to retrieve\n");\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqla82xx_check_fw_alive(scsi_qla_host_t *vha)\r\n{\r\nuint32_t fw_heartbeat_counter;\r\nint status = 0;\r\nfw_heartbeat_counter = qla82xx_rd_32(vha->hw,\r\nQLA82XX_PEG_ALIVE_COUNTER);\r\nif (fw_heartbeat_counter == 0xffffffff) {\r\nql_dbg(ql_dbg_timer, vha, 0x6003,\r\n"FW heartbeat counter is 0xffffffff, "\r\n"returning status=%d.\n", status);\r\nreturn status;\r\n}\r\nif (vha->fw_heartbeat_counter == fw_heartbeat_counter) {\r\nvha->seconds_since_last_heartbeat++;\r\nif (vha->seconds_since_last_heartbeat == 2) {\r\nvha->seconds_since_last_heartbeat = 0;\r\nstatus = 1;\r\n}\r\n} else\r\nvha->seconds_since_last_heartbeat = 0;\r\nvha->fw_heartbeat_counter = fw_heartbeat_counter;\r\nif (status)\r\nql_dbg(ql_dbg_timer, vha, 0x6004,\r\n"Returning status=%d.\n", status);\r\nreturn status;\r\n}\r\nint\r\nqla82xx_device_state_handler(scsi_qla_host_t *vha)\r\n{\r\nuint32_t dev_state;\r\nuint32_t old_dev_state;\r\nint rval = QLA_SUCCESS;\r\nunsigned long dev_init_timeout;\r\nstruct qla_hw_data *ha = vha->hw;\r\nint loopcount = 0;\r\nqla82xx_idc_lock(ha);\r\nif (!vha->flags.init_done) {\r\nqla82xx_set_drv_active(vha);\r\nqla82xx_set_idc_version(vha);\r\n}\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nold_dev_state = dev_state;\r\nql_log(ql_log_info, vha, 0x009b,\r\n"Device state is 0x%x = %s.\n",\r\ndev_state,\r\ndev_state < MAX_STATES ? qdev_state(dev_state) : "Unknown");\r\ndev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout * HZ);\r\nwhile (1) {\r\nif (time_after_eq(jiffies, dev_init_timeout)) {\r\nql_log(ql_log_fatal, vha, 0x009c,\r\n"Device init failed.\n");\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (old_dev_state != dev_state) {\r\nloopcount = 0;\r\nold_dev_state = dev_state;\r\n}\r\nif (loopcount < 5) {\r\nql_log(ql_log_info, vha, 0x009d,\r\n"Device state is 0x%x = %s.\n",\r\ndev_state,\r\ndev_state < MAX_STATES ? qdev_state(dev_state) :\r\n"Unknown");\r\n}\r\nswitch (dev_state) {\r\ncase QLA8XXX_DEV_READY:\r\nha->flags.nic_core_reset_owner = 0;\r\ngoto rel_lock;\r\ncase QLA8XXX_DEV_COLD:\r\nrval = qla82xx_device_bootstrap(vha);\r\nbreak;\r\ncase QLA8XXX_DEV_INITIALIZING:\r\nqla82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\nbreak;\r\ncase QLA8XXX_DEV_NEED_RESET:\r\nif (!ql2xdontresethba)\r\nqla82xx_need_reset_handler(vha);\r\nelse {\r\nqla82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\n}\r\ndev_init_timeout = jiffies +\r\n(ha->fcoe_dev_init_timeout * HZ);\r\nbreak;\r\ncase QLA8XXX_DEV_NEED_QUIESCENT:\r\nqla82xx_need_qsnt_handler(vha);\r\ndev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout\\r\n* HZ);\r\nbreak;\r\ncase QLA8XXX_DEV_QUIESCENT:\r\nif (ha->flags.quiesce_owner)\r\ngoto rel_lock;\r\nqla82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\ndev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout\\r\n* HZ);\r\nbreak;\r\ncase QLA8XXX_DEV_FAILED:\r\nqla8xxx_dev_failed_handler(vha);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto exit;\r\ndefault:\r\nqla82xx_idc_unlock(ha);\r\nmsleep(1000);\r\nqla82xx_idc_lock(ha);\r\n}\r\nloopcount++;\r\n}\r\nrel_lock:\r\nqla82xx_idc_unlock(ha);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int qla82xx_check_temp(scsi_qla_host_t *vha)\r\n{\r\nuint32_t temp, temp_state, temp_val;\r\nstruct qla_hw_data *ha = vha->hw;\r\ntemp = qla82xx_rd_32(ha, CRB_TEMP_STATE);\r\ntemp_state = qla82xx_get_temp_state(temp);\r\ntemp_val = qla82xx_get_temp_val(temp);\r\nif (temp_state == QLA82XX_TEMP_PANIC) {\r\nql_log(ql_log_warn, vha, 0x600e,\r\n"Device temperature %d degrees C exceeds "\r\n" maximum allowed. Hardware has been shut down.\n",\r\ntemp_val);\r\nreturn 1;\r\n} else if (temp_state == QLA82XX_TEMP_WARN) {\r\nql_log(ql_log_warn, vha, 0x600f,\r\n"Device temperature %d degrees C exceeds "\r\n"operating range. Immediate action needed.\n",\r\ntemp_val);\r\n}\r\nreturn 0;\r\n}\r\nint qla82xx_read_temperature(scsi_qla_host_t *vha)\r\n{\r\nuint32_t temp;\r\ntemp = qla82xx_rd_32(vha->hw, CRB_TEMP_STATE);\r\nreturn qla82xx_get_temp_val(temp);\r\n}\r\nvoid qla82xx_clear_pending_mbx(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ha->flags.mbox_busy) {\r\nha->flags.mbox_int = 1;\r\nha->flags.mbox_busy = 0;\r\nql_log(ql_log_warn, vha, 0x6010,\r\n"Doing premature completion of mbx command.\n");\r\nif (test_and_clear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags))\r\ncomplete(&ha->mbx_intr_comp);\r\n}\r\n}\r\nvoid qla82xx_watchdog(scsi_qla_host_t *vha)\r\n{\r\nuint32_t dev_state, halt_status;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->flags.nic_core_reset_hdlr_active) {\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nif (qla82xx_check_temp(vha)) {\r\nset_bit(ISP_UNRECOVERABLE, &vha->dpc_flags);\r\nha->flags.isp82xx_fw_hung = 1;\r\nqla82xx_clear_pending_mbx(vha);\r\n} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\r\n!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags)) {\r\nql_log(ql_log_warn, vha, 0x6001,\r\n"Adapter reset needed.\n");\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\n} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\r\n!test_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags)) {\r\nql_log(ql_log_warn, vha, 0x6002,\r\n"Quiescent needed.\n");\r\nset_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\r\n} else if (dev_state == QLA8XXX_DEV_FAILED &&\r\n!test_bit(ISP_UNRECOVERABLE, &vha->dpc_flags) &&\r\nvha->flags.online == 1) {\r\nql_log(ql_log_warn, vha, 0xb055,\r\n"Adapter state is failed. Offlining.\n");\r\nset_bit(ISP_UNRECOVERABLE, &vha->dpc_flags);\r\nha->flags.isp82xx_fw_hung = 1;\r\nqla82xx_clear_pending_mbx(vha);\r\n} else {\r\nif (qla82xx_check_fw_alive(vha)) {\r\nql_dbg(ql_dbg_timer, vha, 0x6011,\r\n"disabling pause transmit on port 0 & 1.\n");\r\nqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\r\nCRB_NIU_XG_PAUSE_CTL_P0|CRB_NIU_XG_PAUSE_CTL_P1);\r\nhalt_status = qla82xx_rd_32(ha,\r\nQLA82XX_PEG_HALT_STATUS1);\r\nql_log(ql_log_info, vha, 0x6005,\r\n"dumping hw/fw registers:.\n "\r\n" PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,.\n "\r\n" PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,.\n "\r\n" PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,.\n "\r\n" PEG_NET_4_PC: 0x%x.\n", halt_status,\r\nqla82xx_rd_32(ha, QLA82XX_PEG_HALT_STATUS2),\r\nqla82xx_rd_32(ha,\r\nQLA82XX_CRB_PEG_NET_0 + 0x3c),\r\nqla82xx_rd_32(ha,\r\nQLA82XX_CRB_PEG_NET_1 + 0x3c),\r\nqla82xx_rd_32(ha,\r\nQLA82XX_CRB_PEG_NET_2 + 0x3c),\r\nqla82xx_rd_32(ha,\r\nQLA82XX_CRB_PEG_NET_3 + 0x3c),\r\nqla82xx_rd_32(ha,\r\nQLA82XX_CRB_PEG_NET_4 + 0x3c));\r\nif (((halt_status & 0x1fffff00) >> 8) == 0x67)\r\nql_log(ql_log_warn, vha, 0xb052,\r\n"Firmware aborted with "\r\n"error code 0x00006700. Device is "\r\n"being reset.\n");\r\nif (halt_status & HALT_STATUS_UNRECOVERABLE) {\r\nset_bit(ISP_UNRECOVERABLE,\r\n&vha->dpc_flags);\r\n} else {\r\nql_log(ql_log_info, vha, 0x6006,\r\n"Detect abort needed.\n");\r\nset_bit(ISP_ABORT_NEEDED,\r\n&vha->dpc_flags);\r\n}\r\nha->flags.isp82xx_fw_hung = 1;\r\nql_log(ql_log_warn, vha, 0x6007, "Firmware hung.\n");\r\nqla82xx_clear_pending_mbx(vha);\r\n}\r\n}\r\n}\r\n}\r\nint qla82xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\r\n{\r\nint rval = -1;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA82XX(ha))\r\nrval = qla82xx_device_state_handler(vha);\r\nelse if (IS_QLA8044(ha)) {\r\nqla8044_idc_lock(ha);\r\nqla83xx_reset_ownership(vha);\r\nqla8044_idc_unlock(ha);\r\nrval = qla8044_device_state_handler(vha);\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqla82xx_set_reset_owner(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t dev_state = 0;\r\nif (IS_QLA82XX(ha))\r\ndev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\r\nelse if (IS_QLA8044(ha))\r\ndev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\r\nif (dev_state == QLA8XXX_DEV_READY) {\r\nql_log(ql_log_info, vha, 0xb02f,\r\n"HW State: NEED RESET\n");\r\nif (IS_QLA82XX(ha)) {\r\nqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_NEED_RESET);\r\nha->flags.nic_core_reset_owner = 1;\r\nql_dbg(ql_dbg_p3p, vha, 0xb030,\r\n"reset_owner is 0x%x\n", ha->portnum);\r\n} else if (IS_QLA8044(ha))\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_NEED_RESET);\r\n} else\r\nql_log(ql_log_info, vha, 0xb031,\r\n"Device state is 0x%x = %s.\n",\r\ndev_state,\r\ndev_state < MAX_STATES ? qdev_state(dev_state) : "Unknown");\r\n}\r\nint\r\nqla82xx_abort_isp(scsi_qla_host_t *vha)\r\n{\r\nint rval = -1;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (vha->device_flags & DFLG_DEV_FAILED) {\r\nql_log(ql_log_warn, vha, 0x8024,\r\n"Device in failed state, exiting.\n");\r\nreturn QLA_SUCCESS;\r\n}\r\nha->flags.nic_core_reset_hdlr_active = 1;\r\nqla82xx_idc_lock(ha);\r\nqla82xx_set_reset_owner(vha);\r\nqla82xx_idc_unlock(ha);\r\nif (IS_QLA82XX(ha))\r\nrval = qla82xx_device_state_handler(vha);\r\nelse if (IS_QLA8044(ha)) {\r\nqla8044_idc_lock(ha);\r\nqla83xx_reset_ownership(vha);\r\nqla8044_idc_unlock(ha);\r\nrval = qla8044_device_state_handler(vha);\r\n}\r\nqla82xx_idc_lock(ha);\r\nqla82xx_clear_rst_ready(ha);\r\nqla82xx_idc_unlock(ha);\r\nif (rval == QLA_SUCCESS) {\r\nha->flags.isp82xx_fw_hung = 0;\r\nha->flags.nic_core_reset_hdlr_active = 0;\r\nqla82xx_restart_isp(vha);\r\n}\r\nif (rval) {\r\nvha->flags.online = 1;\r\nif (test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\r\nif (ha->isp_abort_cnt == 0) {\r\nql_log(ql_log_warn, vha, 0x8027,\r\n"ISP error recover failed - board "\r\n"disabled.\n");\r\nha->isp_ops->reset_adapter(vha);\r\nvha->flags.online = 0;\r\nclear_bit(ISP_ABORT_RETRY,\r\n&vha->dpc_flags);\r\nrval = QLA_SUCCESS;\r\n} else {\r\nha->isp_abort_cnt--;\r\nql_log(ql_log_warn, vha, 0x8036,\r\n"ISP abort - retry remaining %d.\n",\r\nha->isp_abort_cnt);\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\n} else {\r\nha->isp_abort_cnt = MAX_RETRIES_OF_ISP_ABORT;\r\nql_dbg(ql_dbg_taskm, vha, 0x8029,\r\n"ISP error recovery - retrying (%d) more times.\n",\r\nha->isp_abort_cnt);\r\nset_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nreturn rval;\r\n}\r\nint qla82xx_fcoe_ctx_reset(scsi_qla_host_t *vha)\r\n{\r\nint rval = QLA_FUNCTION_FAILED;\r\nif (vha->flags.online) {\r\nqla2x00_abort_isp_cleanup(vha);\r\n}\r\nqla2x00_try_to_stop_firmware(vha);\r\nrval = qla82xx_restart_isp(vha);\r\nreturn rval;\r\n}\r\nint qla2x00_wait_for_fcoe_ctx_reset(scsi_qla_host_t *vha)\r\n{\r\nint status = QLA_FUNCTION_FAILED;\r\nunsigned long wait_reset;\r\nwait_reset = jiffies + (MAX_LOOP_TIMEOUT * HZ);\r\nwhile ((test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags) ||\r\ntest_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))\r\n&& time_before(jiffies, wait_reset)) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\nif (!test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags) &&\r\n!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) {\r\nstatus = QLA_SUCCESS;\r\nbreak;\r\n}\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb027,\r\n"%s: status=%d.\n", __func__, status);\r\nreturn status;\r\n}\r\nvoid\r\nqla82xx_chip_reset_cleanup(scsi_qla_host_t *vha)\r\n{\r\nint i, fw_state = 0;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->flags.isp82xx_fw_hung) {\r\nfor (i = 0; i < 2; i++) {\r\nmsleep(1000);\r\nif (IS_QLA82XX(ha))\r\nfw_state = qla82xx_check_fw_alive(vha);\r\nelse if (IS_QLA8044(ha))\r\nfw_state = qla8044_check_fw_alive(vha);\r\nif (fw_state) {\r\nha->flags.isp82xx_fw_hung = 1;\r\nqla82xx_clear_pending_mbx(vha);\r\nbreak;\r\n}\r\n}\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x00b0,\r\n"Entered %s fw_hung=%d.\n",\r\n__func__, ha->flags.isp82xx_fw_hung);\r\nif (!ha->flags.isp82xx_fw_hung) {\r\nint cnt, que;\r\nsrb_t *sp;\r\nstruct req_que *req;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (que = 0; que < ha->max_req_queues; que++) {\r\nreq = ha->req_q_map[que];\r\nif (!req)\r\ncontinue;\r\nfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {\r\nsp = req->outstanding_cmds[cnt];\r\nif (sp) {\r\nif ((!sp->u.scmd.ctx ||\r\n(sp->flags &\r\nSRB_FCP_CMND_DMA_VALID)) &&\r\n!ha->flags.isp82xx_fw_hung) {\r\nspin_unlock_irqrestore(\r\n&ha->hardware_lock, flags);\r\nif (ha->isp_ops->abort_command(sp)) {\r\nql_log(ql_log_info, vha,\r\n0x00b1,\r\n"mbx abort failed.\n");\r\n} else {\r\nql_log(ql_log_info, vha,\r\n0x00b2,\r\n"mbx abort success.\n");\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (!qla2x00_eh_wait_for_pending_commands(vha, 0, 0,\r\nWAIT_HOST) == QLA_SUCCESS) {\r\nql_dbg(ql_dbg_init, vha, 0x00b3,\r\n"Done wait for "\r\n"pending commands.\n");\r\n}\r\n}\r\n}\r\nstatic int\r\nqla82xx_minidump_process_control(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla82xx_md_entry_crb *crb_entry;\r\nuint32_t read_value, opcode, poll_time;\r\nuint32_t addr, index, crb_addr;\r\nunsigned long wtime;\r\nstruct qla82xx_md_template_hdr *tmplt_hdr;\r\nuint32_t rval = QLA_SUCCESS;\r\nint i;\r\ntmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;\r\ncrb_entry = (struct qla82xx_md_entry_crb *)entry_hdr;\r\ncrb_addr = crb_entry->addr;\r\nfor (i = 0; i < crb_entry->op_count; i++) {\r\nopcode = crb_entry->crb_ctrl.opcode;\r\nif (opcode & QLA82XX_DBG_OPCODE_WR) {\r\nqla82xx_md_rw_32(ha, crb_addr,\r\ncrb_entry->value_1, 1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_WR;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_RW) {\r\nread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\r\nqla82xx_md_rw_32(ha, crb_addr, read_value, 1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_RW;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_AND) {\r\nread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\r\nread_value &= crb_entry->value_2;\r\nopcode &= ~QLA82XX_DBG_OPCODE_AND;\r\nif (opcode & QLA82XX_DBG_OPCODE_OR) {\r\nread_value |= crb_entry->value_3;\r\nopcode &= ~QLA82XX_DBG_OPCODE_OR;\r\n}\r\nqla82xx_md_rw_32(ha, crb_addr, read_value, 1);\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_OR) {\r\nread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\r\nread_value |= crb_entry->value_3;\r\nqla82xx_md_rw_32(ha, crb_addr, read_value, 1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_OR;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_POLL) {\r\npoll_time = crb_entry->crb_strd.poll_timeout;\r\nwtime = jiffies + poll_time;\r\nread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\r\ndo {\r\nif ((read_value & crb_entry->value_2)\r\n== crb_entry->value_1)\r\nbreak;\r\nelse if (time_after_eq(jiffies, wtime)) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n} else\r\nread_value = qla82xx_md_rw_32(ha,\r\ncrb_addr, 0, 0);\r\n} while (1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_POLL;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_RDSTATE) {\r\nif (crb_entry->crb_strd.state_index_a) {\r\nindex = crb_entry->crb_strd.state_index_a;\r\naddr = tmplt_hdr->saved_state_array[index];\r\n} else\r\naddr = crb_addr;\r\nread_value = qla82xx_md_rw_32(ha, addr, 0, 0);\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\ntmplt_hdr->saved_state_array[index] = read_value;\r\nopcode &= ~QLA82XX_DBG_OPCODE_RDSTATE;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_WRSTATE) {\r\nif (crb_entry->crb_strd.state_index_a) {\r\nindex = crb_entry->crb_strd.state_index_a;\r\naddr = tmplt_hdr->saved_state_array[index];\r\n} else\r\naddr = crb_addr;\r\nif (crb_entry->crb_ctrl.state_index_v) {\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\nread_value =\r\ntmplt_hdr->saved_state_array[index];\r\n} else\r\nread_value = crb_entry->value_1;\r\nqla82xx_md_rw_32(ha, addr, read_value, 1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_WRSTATE;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_MDSTATE) {\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\nread_value = tmplt_hdr->saved_state_array[index];\r\nread_value <<= crb_entry->crb_ctrl.shl;\r\nread_value >>= crb_entry->crb_ctrl.shr;\r\nif (crb_entry->value_2)\r\nread_value &= crb_entry->value_2;\r\nread_value |= crb_entry->value_3;\r\nread_value += crb_entry->value_1;\r\ntmplt_hdr->saved_state_array[index] = read_value;\r\nopcode &= ~QLA82XX_DBG_OPCODE_MDSTATE;\r\n}\r\ncrb_addr += crb_entry->crb_strd.addr_stride;\r\n}\r\nreturn rval;\r\n}\r\nstatic void\r\nqla82xx_minidump_process_rdocm(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t r_addr, r_stride, loop_cnt, i, r_value;\r\nstruct qla82xx_md_entry_rdocm *ocm_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nocm_hdr = (struct qla82xx_md_entry_rdocm *)entry_hdr;\r\nr_addr = ocm_hdr->read_addr;\r\nr_stride = ocm_hdr->read_addr_stride;\r\nloop_cnt = ocm_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nr_value = RD_REG_DWORD(r_addr + ha->nx_pcibase);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += r_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla82xx_minidump_process_rdmux(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value;\r\nstruct qla82xx_md_entry_mux *mux_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nmux_hdr = (struct qla82xx_md_entry_mux *)entry_hdr;\r\nr_addr = mux_hdr->read_addr;\r\ns_addr = mux_hdr->select_addr;\r\ns_stride = mux_hdr->select_value_stride;\r\ns_value = mux_hdr->select_value;\r\nloop_cnt = mux_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla82xx_md_rw_32(ha, s_addr, s_value, 1);\r\nr_value = qla82xx_md_rw_32(ha, r_addr, 0, 0);\r\n*data_ptr++ = cpu_to_le32(s_value);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\ns_value += s_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla82xx_minidump_process_rdcrb(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t r_addr, r_stride, loop_cnt, i, r_value;\r\nstruct qla82xx_md_entry_crb *crb_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\ncrb_hdr = (struct qla82xx_md_entry_crb *)entry_hdr;\r\nr_addr = crb_hdr->addr;\r\nr_stride = crb_hdr->crb_strd.addr_stride;\r\nloop_cnt = crb_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nr_value = qla82xx_md_rw_32(ha, r_addr, 0, 0);\r\n*data_ptr++ = cpu_to_le32(r_addr);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += r_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic int\r\nqla82xx_minidump_process_l2tag(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t addr, r_addr, c_addr, t_r_addr;\r\nuint32_t i, k, loop_count, t_value, r_cnt, r_value;\r\nunsigned long p_wait, w_time, p_mask;\r\nuint32_t c_value_w, c_value_r;\r\nstruct qla82xx_md_entry_cache *cache_hdr;\r\nint rval = QLA_FUNCTION_FAILED;\r\nuint32_t *data_ptr = *d_ptr;\r\ncache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;\r\nloop_count = cache_hdr->op_count;\r\nr_addr = cache_hdr->read_addr;\r\nc_addr = cache_hdr->control_addr;\r\nc_value_w = cache_hdr->cache_ctrl.write_value;\r\nt_r_addr = cache_hdr->tag_reg_addr;\r\nt_value = cache_hdr->addr_ctrl.init_tag_value;\r\nr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\r\np_wait = cache_hdr->cache_ctrl.poll_wait;\r\np_mask = cache_hdr->cache_ctrl.poll_mask;\r\nfor (i = 0; i < loop_count; i++) {\r\nqla82xx_md_rw_32(ha, t_r_addr, t_value, 1);\r\nif (c_value_w)\r\nqla82xx_md_rw_32(ha, c_addr, c_value_w, 1);\r\nif (p_mask) {\r\nw_time = jiffies + p_wait;\r\ndo {\r\nc_value_r = qla82xx_md_rw_32(ha, c_addr, 0, 0);\r\nif ((c_value_r & p_mask) == 0)\r\nbreak;\r\nelse if (time_after_eq(jiffies, w_time)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb032,\r\n"c_value_r: 0x%x, poll_mask: 0x%lx, "\r\n"w_time: 0x%lx\n",\r\nc_value_r, p_mask, w_time);\r\nreturn rval;\r\n}\r\n} while (1);\r\n}\r\naddr = r_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nr_value = qla82xx_md_rw_32(ha, addr, 0, 0);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\naddr += cache_hdr->read_ctrl.read_addr_stride;\r\n}\r\nt_value += cache_hdr->addr_ctrl.tag_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla82xx_minidump_process_l1cache(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t addr, r_addr, c_addr, t_r_addr;\r\nuint32_t i, k, loop_count, t_value, r_cnt, r_value;\r\nuint32_t c_value_w;\r\nstruct qla82xx_md_entry_cache *cache_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\ncache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;\r\nloop_count = cache_hdr->op_count;\r\nr_addr = cache_hdr->read_addr;\r\nc_addr = cache_hdr->control_addr;\r\nc_value_w = cache_hdr->cache_ctrl.write_value;\r\nt_r_addr = cache_hdr->tag_reg_addr;\r\nt_value = cache_hdr->addr_ctrl.init_tag_value;\r\nr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\r\nfor (i = 0; i < loop_count; i++) {\r\nqla82xx_md_rw_32(ha, t_r_addr, t_value, 1);\r\nqla82xx_md_rw_32(ha, c_addr, c_value_w, 1);\r\naddr = r_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nr_value = qla82xx_md_rw_32(ha, addr, 0, 0);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\naddr += cache_hdr->read_ctrl.read_addr_stride;\r\n}\r\nt_value += cache_hdr->addr_ctrl.tag_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla82xx_minidump_process_queue(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t s_addr, r_addr;\r\nuint32_t r_stride, r_value, r_cnt, qid = 0;\r\nuint32_t i, k, loop_cnt;\r\nstruct qla82xx_md_entry_queue *q_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nq_hdr = (struct qla82xx_md_entry_queue *)entry_hdr;\r\ns_addr = q_hdr->select_addr;\r\nr_cnt = q_hdr->rd_strd.read_addr_cnt;\r\nr_stride = q_hdr->rd_strd.read_addr_stride;\r\nloop_cnt = q_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla82xx_md_rw_32(ha, s_addr, qid, 1);\r\nr_addr = q_hdr->read_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nr_value = qla82xx_md_rw_32(ha, r_addr, 0, 0);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += r_stride;\r\n}\r\nqid += q_hdr->q_strd.queue_id_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla82xx_minidump_process_rdrom(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t r_addr, r_value;\r\nuint32_t i, loop_cnt;\r\nstruct qla82xx_md_entry_rdrom *rom_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nrom_hdr = (struct qla82xx_md_entry_rdrom *)entry_hdr;\r\nr_addr = rom_hdr->read_addr;\r\nloop_cnt = rom_hdr->read_data_size/sizeof(uint32_t);\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla82xx_md_rw_32(ha, MD_DIRECT_ROM_WINDOW,\r\n(r_addr & 0xFFFF0000), 1);\r\nr_value = qla82xx_md_rw_32(ha,\r\nMD_DIRECT_ROM_READ_BASE +\r\n(r_addr & 0x0000FFFF), 0, 0);\r\n*data_ptr++ = cpu_to_le32(r_value);\r\nr_addr += sizeof(uint32_t);\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic int\r\nqla82xx_minidump_process_rdmem(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t r_addr, r_value, r_data;\r\nuint32_t i, j, loop_cnt;\r\nstruct qla82xx_md_entry_rdmem *m_hdr;\r\nunsigned long flags;\r\nint rval = QLA_FUNCTION_FAILED;\r\nuint32_t *data_ptr = *d_ptr;\r\nm_hdr = (struct qla82xx_md_entry_rdmem *)entry_hdr;\r\nr_addr = m_hdr->read_addr;\r\nloop_cnt = m_hdr->read_data_size/16;\r\nif (r_addr & 0xf) {\r\nql_log(ql_log_warn, vha, 0xb033,\r\n"Read addr 0x%x not 16 bytes aligned\n", r_addr);\r\nreturn rval;\r\n}\r\nif (m_hdr->read_data_size % 16) {\r\nql_log(ql_log_warn, vha, 0xb034,\r\n"Read data[0x%x] not multiple of 16 bytes\n",\r\nm_hdr->read_data_size);\r\nreturn rval;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb035,\r\n"[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",\r\n__func__, r_addr, m_hdr->read_data_size, loop_cnt);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_ADDR_LO, r_addr, 1);\r\nr_value = 0;\r\nqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_ADDR_HI, r_value, 1);\r\nr_value = MIU_TA_CTL_ENABLE;\r\nqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_CTRL, r_value, 1);\r\nr_value = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;\r\nqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_CTRL, r_value, 1);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\nr_value = qla82xx_md_rw_32(ha,\r\nMD_MIU_TEST_AGT_CTRL, 0, 0);\r\nif ((r_value & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nprintk_ratelimited(KERN_ERR\r\n"failed to read through agent\n");\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nreturn rval;\r\n}\r\nfor (j = 0; j < 4; j++) {\r\nr_data = qla82xx_md_rw_32(ha,\r\nMD_MIU_TEST_AGT_RDDATA[j], 0, 0);\r\n*data_ptr++ = cpu_to_le32(r_data);\r\n}\r\nr_addr += 16;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla82xx_validate_template_chksum(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint64_t chksum = 0;\r\nuint32_t *d_ptr = (uint32_t *)ha->md_tmplt_hdr;\r\nint count = ha->md_template_size/sizeof(uint32_t);\r\nwhile (count-- > 0)\r\nchksum += *d_ptr++;\r\nwhile (chksum >> 32)\r\nchksum = (chksum & 0xFFFFFFFF) + (chksum >> 32);\r\nreturn ~chksum;\r\n}\r\nstatic void\r\nqla82xx_mark_entry_skipped(scsi_qla_host_t *vha,\r\nqla82xx_md_entry_hdr_t *entry_hdr, int index)\r\n{\r\nentry_hdr->d_ctrl.driver_flags |= QLA82XX_DBG_SKIPPED_FLAG;\r\nql_dbg(ql_dbg_p3p, vha, 0xb036,\r\n"Skipping entry[%d]: "\r\n"ETYPE[0x%x]-ELEVEL[0x%x]\n",\r\nindex, entry_hdr->entry_type,\r\nentry_hdr->d_ctrl.entry_capture_mask);\r\n}\r\nint\r\nqla82xx_md_collect(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint no_entry_hdr = 0;\r\nqla82xx_md_entry_hdr_t *entry_hdr;\r\nstruct qla82xx_md_template_hdr *tmplt_hdr;\r\nuint32_t *data_ptr;\r\nuint32_t total_data_size = 0, f_capture_mask, data_collected = 0;\r\nint i = 0, rval = QLA_FUNCTION_FAILED;\r\ntmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;\r\ndata_ptr = (uint32_t *)ha->md_dump;\r\nif (ha->fw_dumped) {\r\nql_log(ql_log_warn, vha, 0xb037,\r\n"Firmware has been previously dumped (%p) "\r\n"-- ignoring request.\n", ha->fw_dump);\r\ngoto md_failed;\r\n}\r\nha->fw_dumped = 0;\r\nif (!ha->md_tmplt_hdr || !ha->md_dump) {\r\nql_log(ql_log_warn, vha, 0xb038,\r\n"Memory not allocated for minidump capture\n");\r\ngoto md_failed;\r\n}\r\nif (ha->flags.isp82xx_no_md_cap) {\r\nql_log(ql_log_warn, vha, 0xb054,\r\n"Forced reset from application, "\r\n"ignore minidump capture\n");\r\nha->flags.isp82xx_no_md_cap = 0;\r\ngoto md_failed;\r\n}\r\nif (qla82xx_validate_template_chksum(vha)) {\r\nql_log(ql_log_info, vha, 0xb039,\r\n"Template checksum validation error\n");\r\ngoto md_failed;\r\n}\r\nno_entry_hdr = tmplt_hdr->num_of_entries;\r\nql_dbg(ql_dbg_p3p, vha, 0xb03a,\r\n"No of entry headers in Template: 0x%x\n", no_entry_hdr);\r\nql_dbg(ql_dbg_p3p, vha, 0xb03b,\r\n"Capture Mask obtained: 0x%x\n", tmplt_hdr->capture_debug_level);\r\nf_capture_mask = tmplt_hdr->capture_debug_level & 0xFF;\r\nif ((f_capture_mask & 0x3) != 0x3) {\r\nql_log(ql_log_warn, vha, 0xb03c,\r\n"Minimum required capture mask[0x%x] level not set\n",\r\nf_capture_mask);\r\ngoto md_failed;\r\n}\r\ntmplt_hdr->driver_capture_mask = ql2xmdcapmask;\r\ntmplt_hdr->driver_info[0] = vha->host_no;\r\ntmplt_hdr->driver_info[1] = (QLA_DRIVER_MAJOR_VER << 24) |\r\n(QLA_DRIVER_MINOR_VER << 16) | (QLA_DRIVER_PATCH_VER << 8) |\r\nQLA_DRIVER_BETA_VER;\r\ntotal_data_size = ha->md_dump_size;\r\nql_dbg(ql_dbg_p3p, vha, 0xb03d,\r\n"Total minidump data_size 0x%x to be captured\n", total_data_size);\r\nif (tmplt_hdr->entry_type != QLA82XX_TLHDR) {\r\nql_log(ql_log_warn, vha, 0xb04e,\r\n"Bad template header entry type: 0x%x obtained\n",\r\ntmplt_hdr->entry_type);\r\ngoto md_failed;\r\n}\r\nentry_hdr = (qla82xx_md_entry_hdr_t *) \\r\n(((uint8_t *)ha->md_tmplt_hdr) + tmplt_hdr->first_entry_offset);\r\nfor (i = 0; i < no_entry_hdr; i++) {\r\nif (data_collected > total_data_size) {\r\nql_log(ql_log_warn, vha, 0xb03e,\r\n"More MiniDump data collected: [0x%x]\n",\r\ndata_collected);\r\ngoto md_failed;\r\n}\r\nif (!(entry_hdr->d_ctrl.entry_capture_mask &\r\nql2xmdcapmask)) {\r\nentry_hdr->d_ctrl.driver_flags |=\r\nQLA82XX_DBG_SKIPPED_FLAG;\r\nql_dbg(ql_dbg_p3p, vha, 0xb03f,\r\n"Skipping entry[%d]: "\r\n"ETYPE[0x%x]-ELEVEL[0x%x]\n",\r\ni, entry_hdr->entry_type,\r\nentry_hdr->d_ctrl.entry_capture_mask);\r\ngoto skip_nxt_entry;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb040,\r\n"[%s]: data ptr[%d]: %p, entry_hdr: %p\n"\r\n"entry_type: 0x%x, captrue_mask: 0x%x\n",\r\n__func__, i, data_ptr, entry_hdr,\r\nentry_hdr->entry_type,\r\nentry_hdr->d_ctrl.entry_capture_mask);\r\nql_dbg(ql_dbg_p3p, vha, 0xb041,\r\n"Data collected: [0x%x], Dump size left:[0x%x]\n",\r\ndata_collected, (ha->md_dump_size - data_collected));\r\nswitch (entry_hdr->entry_type) {\r\ncase QLA82XX_RDEND:\r\nqla82xx_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA82XX_CNTRL:\r\nrval = qla82xx_minidump_process_control(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla82xx_mark_entry_skipped(vha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA82XX_RDCRB:\r\nqla82xx_minidump_process_rdcrb(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDMEM:\r\nrval = qla82xx_minidump_process_rdmem(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla82xx_mark_entry_skipped(vha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA82XX_BOARD:\r\ncase QLA82XX_RDROM:\r\nqla82xx_minidump_process_rdrom(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_L2DTG:\r\ncase QLA82XX_L2ITG:\r\ncase QLA82XX_L2DAT:\r\ncase QLA82XX_L2INS:\r\nrval = qla82xx_minidump_process_l2tag(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla82xx_mark_entry_skipped(vha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA82XX_L1DAT:\r\ncase QLA82XX_L1INS:\r\nqla82xx_minidump_process_l1cache(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDOCM:\r\nqla82xx_minidump_process_rdocm(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDMUX:\r\nqla82xx_minidump_process_rdmux(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_QUEUE:\r\nqla82xx_minidump_process_queue(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDNOP:\r\ndefault:\r\nqla82xx_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb042,\r\n"[%s]: data ptr[%d]: %p\n", __func__, i, data_ptr);\r\ndata_collected = (uint8_t *)data_ptr -\r\n(uint8_t *)ha->md_dump;\r\nskip_nxt_entry:\r\nentry_hdr = (qla82xx_md_entry_hdr_t *) \\r\n(((uint8_t *)entry_hdr) + entry_hdr->entry_size);\r\n}\r\nif (data_collected != total_data_size) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb043,\r\n"MiniDump data mismatch: Data collected: [0x%x],"\r\n"total_data_size:[0x%x]\n",\r\ndata_collected, total_data_size);\r\ngoto md_failed;\r\n}\r\nql_log(ql_log_info, vha, 0xb044,\r\n"Firmware dump saved to temp buffer (%ld/%p %ld/%p).\n",\r\nvha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);\r\nha->fw_dumped = 1;\r\nqla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);\r\nmd_failed:\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_md_alloc(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint i, k;\r\nstruct qla82xx_md_template_hdr *tmplt_hdr;\r\ntmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;\r\nif (ql2xmdcapmask < 0x3 || ql2xmdcapmask > 0x7F) {\r\nql2xmdcapmask = tmplt_hdr->capture_debug_level & 0xFF;\r\nql_log(ql_log_info, vha, 0xb045,\r\n"Forcing driver capture mask to firmware default capture mask: 0x%x.\n",\r\nql2xmdcapmask);\r\n}\r\nfor (i = 0x2, k = 1; (i & QLA82XX_DEFAULT_CAP_MASK); i <<= 1, k++) {\r\nif (i & ql2xmdcapmask)\r\nha->md_dump_size += tmplt_hdr->capture_size_array[k];\r\n}\r\nif (ha->md_dump) {\r\nql_log(ql_log_warn, vha, 0xb046,\r\n"Firmware dump previously allocated.\n");\r\nreturn 1;\r\n}\r\nha->md_dump = vmalloc(ha->md_dump_size);\r\nif (ha->md_dump == NULL) {\r\nql_log(ql_log_warn, vha, 0xb047,\r\n"Unable to allocate memory for Minidump size "\r\n"(0x%x).\n", ha->md_dump_size);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nqla82xx_md_free(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ha->md_tmplt_hdr) {\r\nql_log(ql_log_info, vha, 0xb048,\r\n"Free MiniDump template: %p, size (%d KB)\n",\r\nha->md_tmplt_hdr, ha->md_template_size / 1024);\r\ndma_free_coherent(&ha->pdev->dev, ha->md_template_size,\r\nha->md_tmplt_hdr, ha->md_tmplt_hdr_dma);\r\nha->md_tmplt_hdr = NULL;\r\n}\r\nif (ha->md_dump) {\r\nql_log(ql_log_info, vha, 0xb049,\r\n"Free MiniDump memory: %p, size (%d KB)\n",\r\nha->md_dump, ha->md_dump_size / 1024);\r\nvfree(ha->md_dump);\r\nha->md_dump_size = 0;\r\nha->md_dump = NULL;\r\n}\r\n}\r\nvoid\r\nqla82xx_md_prep(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval;\r\nrval = qla82xx_md_get_template_size(vha);\r\nif (rval == QLA_SUCCESS) {\r\nql_log(ql_log_info, vha, 0xb04a,\r\n"MiniDump Template size obtained (%d KB)\n",\r\nha->md_template_size / 1024);\r\nif (IS_QLA8044(ha))\r\nrval = qla8044_md_get_template(vha);\r\nelse\r\nrval = qla82xx_md_get_template(vha);\r\nif (rval == QLA_SUCCESS) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb04b,\r\n"MiniDump Template obtained\n");\r\nrval = qla82xx_md_alloc(vha);\r\nif (rval == QLA_SUCCESS)\r\nql_log(ql_log_info, vha, 0xb04c,\r\n"MiniDump memory allocated (%d KB)\n",\r\nha->md_dump_size / 1024);\r\nelse {\r\nql_log(ql_log_info, vha, 0xb04d,\r\n"Free MiniDump template: %p, size: (%d KB)\n",\r\nha->md_tmplt_hdr,\r\nha->md_template_size / 1024);\r\ndma_free_coherent(&ha->pdev->dev,\r\nha->md_template_size,\r\nha->md_tmplt_hdr, ha->md_tmplt_hdr_dma);\r\nha->md_tmplt_hdr = NULL;\r\n}\r\n}\r\n}\r\n}\r\nint\r\nqla82xx_beacon_on(struct scsi_qla_host *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla82xx_idc_lock(ha);\r\nrval = qla82xx_mbx_beacon_ctl(vha, 1);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0xb050,\r\n"mbx set led config failed in %s\n", __func__);\r\ngoto exit;\r\n}\r\nha->beacon_blink_led = 1;\r\nexit:\r\nqla82xx_idc_unlock(ha);\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_beacon_off(struct scsi_qla_host *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla82xx_idc_lock(ha);\r\nrval = qla82xx_mbx_beacon_ctl(vha, 0);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0xb051,\r\n"mbx set led config failed in %s\n", __func__);\r\ngoto exit;\r\n}\r\nha->beacon_blink_led = 0;\r\nexit:\r\nqla82xx_idc_unlock(ha);\r\nreturn rval;\r\n}\r\nvoid\r\nqla82xx_fw_dump(scsi_qla_host_t *vha, int hardware_locked)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->allow_cna_fw_dump)\r\nreturn;\r\nscsi_block_requests(vha->host);\r\nha->flags.isp82xx_no_md_cap = 1;\r\nqla82xx_idc_lock(ha);\r\nqla82xx_set_reset_owner(vha);\r\nqla82xx_idc_unlock(ha);\r\nqla2x00_wait_for_chip_reset(vha);\r\nscsi_unblock_requests(vha->host);\r\n}
