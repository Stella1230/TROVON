static int tse_pcs_reset(void __iomem *base, struct tse_pcs *pcs)\r\n{\r\nint counter = 0;\r\nu16 val;\r\nval = readw(base + TSE_PCS_CONTROL_REG);\r\nval |= TSE_PCS_SW_RST_MASK;\r\nwritew(val, base + TSE_PCS_CONTROL_REG);\r\nwhile (counter < TSE_PCS_SW_RESET_TIMEOUT) {\r\nval = readw(base + TSE_PCS_CONTROL_REG);\r\nval &= TSE_PCS_SW_RST_MASK;\r\nif (val == 0)\r\nbreak;\r\ncounter++;\r\nudelay(1);\r\n}\r\nif (counter >= TSE_PCS_SW_RESET_TIMEOUT) {\r\ndev_err(pcs->dev, "PCS could not get out of sw reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint tse_pcs_init(void __iomem *base, struct tse_pcs *pcs)\r\n{\r\nint ret = 0;\r\nwritew(TSE_PCS_USE_SGMII_ENA, base + TSE_PCS_IF_MODE_REG);\r\nwritew(TSE_PCS_SGMII_LINK_TIMER_0, base + TSE_PCS_LINK_TIMER_0_REG);\r\nwritew(TSE_PCS_SGMII_LINK_TIMER_1, base + TSE_PCS_LINK_TIMER_1_REG);\r\nret = tse_pcs_reset(base, pcs);\r\nif (ret == 0)\r\nwritew(SGMII_ADAPTER_ENABLE,\r\npcs->sgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\r\nreturn ret;\r\n}\r\nstatic void pcs_link_timer_callback(unsigned long data)\r\n{\r\nu16 val = 0;\r\nstruct tse_pcs *pcs = (struct tse_pcs *)data;\r\nvoid __iomem *tse_pcs_base = pcs->tse_pcs_base;\r\nvoid __iomem *sgmii_adapter_base = pcs->sgmii_adapter_base;\r\nval = readw(tse_pcs_base + TSE_PCS_STATUS_REG);\r\nval &= TSE_PCS_STATUS_LINK_MASK;\r\nif (val != 0) {\r\ndev_dbg(pcs->dev, "Adapter: Link is established\n");\r\nwritew(SGMII_ADAPTER_ENABLE,\r\nsgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\r\n} else {\r\nmod_timer(&pcs->aneg_link_timer, jiffies +\r\nmsecs_to_jiffies(AUTONEGO_LINK_TIMER));\r\n}\r\n}\r\nstatic void auto_nego_timer_callback(unsigned long data)\r\n{\r\nu16 val = 0;\r\nu16 speed = 0;\r\nu16 duplex = 0;\r\nstruct tse_pcs *pcs = (struct tse_pcs *)data;\r\nvoid __iomem *tse_pcs_base = pcs->tse_pcs_base;\r\nvoid __iomem *sgmii_adapter_base = pcs->sgmii_adapter_base;\r\nval = readw(tse_pcs_base + TSE_PCS_STATUS_REG);\r\nval &= TSE_PCS_STATUS_AN_COMPLETED_MASK;\r\nif (val != 0) {\r\ndev_dbg(pcs->dev, "Adapter: Auto Negotiation is completed\n");\r\nval = readw(tse_pcs_base + TSE_PCS_PARTNER_ABILITY_REG);\r\nspeed = val & TSE_PCS_PARTNER_SPEED_MASK;\r\nduplex = val & TSE_PCS_PARTNER_DUPLEX_MASK;\r\nif (speed == TSE_PCS_PARTNER_SPEED_10 &&\r\nduplex == TSE_PCS_PARTNER_DUPLEX_FULL)\r\ndev_dbg(pcs->dev,\r\n"Adapter: Link Partner is Up - 10/Full\n");\r\nelse if (speed == TSE_PCS_PARTNER_SPEED_100 &&\r\nduplex == TSE_PCS_PARTNER_DUPLEX_FULL)\r\ndev_dbg(pcs->dev,\r\n"Adapter: Link Partner is Up - 100/Full\n");\r\nelse if (speed == TSE_PCS_PARTNER_SPEED_1000 &&\r\nduplex == TSE_PCS_PARTNER_DUPLEX_FULL)\r\ndev_dbg(pcs->dev,\r\n"Adapter: Link Partner is Up - 1000/Full\n");\r\nelse if (speed == TSE_PCS_PARTNER_SPEED_10 &&\r\nduplex == TSE_PCS_PARTNER_DUPLEX_HALF)\r\ndev_err(pcs->dev,\r\n"Adapter does not support Half Duplex\n");\r\nelse if (speed == TSE_PCS_PARTNER_SPEED_100 &&\r\nduplex == TSE_PCS_PARTNER_DUPLEX_HALF)\r\ndev_err(pcs->dev,\r\n"Adapter does not support Half Duplex\n");\r\nelse if (speed == TSE_PCS_PARTNER_SPEED_1000 &&\r\nduplex == TSE_PCS_PARTNER_DUPLEX_HALF)\r\ndev_err(pcs->dev,\r\n"Adapter does not support Half Duplex\n");\r\nelse\r\ndev_err(pcs->dev,\r\n"Adapter: Invalid Partner Speed and Duplex\n");\r\nif (duplex == TSE_PCS_PARTNER_DUPLEX_FULL &&\r\n(speed == TSE_PCS_PARTNER_SPEED_10 ||\r\nspeed == TSE_PCS_PARTNER_SPEED_100 ||\r\nspeed == TSE_PCS_PARTNER_SPEED_1000))\r\nwritew(SGMII_ADAPTER_ENABLE,\r\nsgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\r\n} else {\r\nval = readw(tse_pcs_base + TSE_PCS_CONTROL_REG);\r\nval |= TSE_PCS_CONTROL_RESTART_AN_MASK;\r\nwritew(val, tse_pcs_base + TSE_PCS_CONTROL_REG);\r\ntse_pcs_reset(tse_pcs_base, pcs);\r\nmod_timer(&pcs->aneg_link_timer, jiffies +\r\nmsecs_to_jiffies(AUTONEGO_LINK_TIMER));\r\n}\r\n}\r\nstatic void aneg_link_timer_callback(unsigned long data)\r\n{\r\nstruct tse_pcs *pcs = (struct tse_pcs *)data;\r\nif (pcs->autoneg == AUTONEG_ENABLE)\r\nauto_nego_timer_callback(data);\r\nelse if (pcs->autoneg == AUTONEG_DISABLE)\r\npcs_link_timer_callback(data);\r\n}\r\nvoid tse_pcs_fix_mac_speed(struct tse_pcs *pcs, struct phy_device *phy_dev,\r\nunsigned int speed)\r\n{\r\nvoid __iomem *tse_pcs_base = pcs->tse_pcs_base;\r\nvoid __iomem *sgmii_adapter_base = pcs->sgmii_adapter_base;\r\nu32 val;\r\nwritew(SGMII_ADAPTER_ENABLE,\r\nsgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);\r\npcs->autoneg = phy_dev->autoneg;\r\nif (phy_dev->autoneg == AUTONEG_ENABLE) {\r\nval = readw(tse_pcs_base + TSE_PCS_CONTROL_REG);\r\nval |= TSE_PCS_CONTROL_AN_EN_MASK;\r\nwritew(val, tse_pcs_base + TSE_PCS_CONTROL_REG);\r\nval = readw(tse_pcs_base + TSE_PCS_IF_MODE_REG);\r\nval |= TSE_PCS_USE_SGMII_AN_MASK;\r\nwritew(val, tse_pcs_base + TSE_PCS_IF_MODE_REG);\r\nval = readw(tse_pcs_base + TSE_PCS_CONTROL_REG);\r\nval |= TSE_PCS_CONTROL_RESTART_AN_MASK;\r\ntse_pcs_reset(tse_pcs_base, pcs);\r\nsetup_timer(&pcs->aneg_link_timer,\r\naneg_link_timer_callback, (unsigned long)pcs);\r\nmod_timer(&pcs->aneg_link_timer, jiffies +\r\nmsecs_to_jiffies(AUTONEGO_LINK_TIMER));\r\n} else if (phy_dev->autoneg == AUTONEG_DISABLE) {\r\nval = readw(tse_pcs_base + TSE_PCS_CONTROL_REG);\r\nval &= ~TSE_PCS_CONTROL_AN_EN_MASK;\r\nwritew(val, tse_pcs_base + TSE_PCS_CONTROL_REG);\r\nval = readw(tse_pcs_base + TSE_PCS_IF_MODE_REG);\r\nval &= ~TSE_PCS_USE_SGMII_AN_MASK;\r\nwritew(val, tse_pcs_base + TSE_PCS_IF_MODE_REG);\r\nval = readw(tse_pcs_base + TSE_PCS_IF_MODE_REG);\r\nval &= ~TSE_PCS_SGMII_SPEED_MASK;\r\nswitch (speed) {\r\ncase 1000:\r\nval |= TSE_PCS_SGMII_SPEED_1000;\r\nbreak;\r\ncase 100:\r\nval |= TSE_PCS_SGMII_SPEED_100;\r\nbreak;\r\ncase 10:\r\nval |= TSE_PCS_SGMII_SPEED_10;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritew(val, tse_pcs_base + TSE_PCS_IF_MODE_REG);\r\ntse_pcs_reset(tse_pcs_base, pcs);\r\nsetup_timer(&pcs->aneg_link_timer,\r\naneg_link_timer_callback, (unsigned long)pcs);\r\nmod_timer(&pcs->aneg_link_timer, jiffies +\r\nmsecs_to_jiffies(AUTONEGO_LINK_TIMER));\r\n}\r\n}
