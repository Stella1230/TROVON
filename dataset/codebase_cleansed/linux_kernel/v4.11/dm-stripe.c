static void trigger_event(struct work_struct *work)\r\n{\r\nstruct stripe_c *sc = container_of(work, struct stripe_c,\r\ntrigger_event);\r\ndm_table_event(sc->ti->table);\r\n}\r\nstatic inline struct stripe_c *alloc_context(unsigned int stripes)\r\n{\r\nsize_t len;\r\nif (dm_array_too_big(sizeof(struct stripe_c), sizeof(struct stripe),\r\nstripes))\r\nreturn NULL;\r\nlen = sizeof(struct stripe_c) + (sizeof(struct stripe) * stripes);\r\nreturn kmalloc(len, GFP_KERNEL);\r\n}\r\nstatic int get_stripe(struct dm_target *ti, struct stripe_c *sc,\r\nunsigned int stripe, char **argv)\r\n{\r\nunsigned long long start;\r\nchar dummy;\r\nint ret;\r\nif (sscanf(argv[1], "%llu%c", &start, &dummy) != 1)\r\nreturn -EINVAL;\r\nret = dm_get_device(ti, argv[0], dm_table_get_mode(ti->table),\r\n&sc->stripe[stripe].dev);\r\nif (ret)\r\nreturn ret;\r\nsc->stripe[stripe].physical_start = start;\r\nreturn 0;\r\n}\r\nstatic int stripe_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nstruct stripe_c *sc;\r\nsector_t width, tmp_len;\r\nuint32_t stripes;\r\nuint32_t chunk_size;\r\nint r;\r\nunsigned int i;\r\nif (argc < 2) {\r\nti->error = "Not enough arguments";\r\nreturn -EINVAL;\r\n}\r\nif (kstrtouint(argv[0], 10, &stripes) || !stripes) {\r\nti->error = "Invalid stripe count";\r\nreturn -EINVAL;\r\n}\r\nif (kstrtouint(argv[1], 10, &chunk_size) || !chunk_size) {\r\nti->error = "Invalid chunk_size";\r\nreturn -EINVAL;\r\n}\r\nwidth = ti->len;\r\nif (sector_div(width, stripes)) {\r\nti->error = "Target length not divisible by "\r\n"number of stripes";\r\nreturn -EINVAL;\r\n}\r\ntmp_len = width;\r\nif (sector_div(tmp_len, chunk_size)) {\r\nti->error = "Target length not divisible by "\r\n"chunk size";\r\nreturn -EINVAL;\r\n}\r\nif (argc != (2 + 2 * stripes)) {\r\nti->error = "Not enough destinations "\r\n"specified";\r\nreturn -EINVAL;\r\n}\r\nsc = alloc_context(stripes);\r\nif (!sc) {\r\nti->error = "Memory allocation for striped context "\r\n"failed";\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&sc->trigger_event, trigger_event);\r\nsc->ti = ti;\r\nsc->stripes = stripes;\r\nsc->stripe_width = width;\r\nif (stripes & (stripes - 1))\r\nsc->stripes_shift = -1;\r\nelse\r\nsc->stripes_shift = __ffs(stripes);\r\nr = dm_set_target_max_io_len(ti, chunk_size);\r\nif (r) {\r\nkfree(sc);\r\nreturn r;\r\n}\r\nti->num_flush_bios = stripes;\r\nti->num_discard_bios = stripes;\r\nti->num_write_same_bios = stripes;\r\nsc->chunk_size = chunk_size;\r\nif (chunk_size & (chunk_size - 1))\r\nsc->chunk_size_shift = -1;\r\nelse\r\nsc->chunk_size_shift = __ffs(chunk_size);\r\nfor (i = 0; i < stripes; i++) {\r\nargv += 2;\r\nr = get_stripe(ti, sc, i, argv);\r\nif (r < 0) {\r\nti->error = "Couldn't parse stripe destination";\r\nwhile (i--)\r\ndm_put_device(ti, sc->stripe[i].dev);\r\nkfree(sc);\r\nreturn r;\r\n}\r\natomic_set(&(sc->stripe[i].error_count), 0);\r\n}\r\nti->private = sc;\r\nreturn 0;\r\n}\r\nstatic void stripe_dtr(struct dm_target *ti)\r\n{\r\nunsigned int i;\r\nstruct stripe_c *sc = (struct stripe_c *) ti->private;\r\nfor (i = 0; i < sc->stripes; i++)\r\ndm_put_device(ti, sc->stripe[i].dev);\r\nflush_work(&sc->trigger_event);\r\nkfree(sc);\r\n}\r\nstatic void stripe_map_sector(struct stripe_c *sc, sector_t sector,\r\nuint32_t *stripe, sector_t *result)\r\n{\r\nsector_t chunk = dm_target_offset(sc->ti, sector);\r\nsector_t chunk_offset;\r\nif (sc->chunk_size_shift < 0)\r\nchunk_offset = sector_div(chunk, sc->chunk_size);\r\nelse {\r\nchunk_offset = chunk & (sc->chunk_size - 1);\r\nchunk >>= sc->chunk_size_shift;\r\n}\r\nif (sc->stripes_shift < 0)\r\n*stripe = sector_div(chunk, sc->stripes);\r\nelse {\r\n*stripe = chunk & (sc->stripes - 1);\r\nchunk >>= sc->stripes_shift;\r\n}\r\nif (sc->chunk_size_shift < 0)\r\nchunk *= sc->chunk_size;\r\nelse\r\nchunk <<= sc->chunk_size_shift;\r\n*result = chunk + chunk_offset;\r\n}\r\nstatic void stripe_map_range_sector(struct stripe_c *sc, sector_t sector,\r\nuint32_t target_stripe, sector_t *result)\r\n{\r\nuint32_t stripe;\r\nstripe_map_sector(sc, sector, &stripe, result);\r\nif (stripe == target_stripe)\r\nreturn;\r\nsector = *result;\r\nif (sc->chunk_size_shift < 0)\r\n*result -= sector_div(sector, sc->chunk_size);\r\nelse\r\n*result = sector & ~(sector_t)(sc->chunk_size - 1);\r\nif (target_stripe < stripe)\r\n*result += sc->chunk_size;\r\n}\r\nstatic int stripe_map_range(struct stripe_c *sc, struct bio *bio,\r\nuint32_t target_stripe)\r\n{\r\nsector_t begin, end;\r\nstripe_map_range_sector(sc, bio->bi_iter.bi_sector,\r\ntarget_stripe, &begin);\r\nstripe_map_range_sector(sc, bio_end_sector(bio),\r\ntarget_stripe, &end);\r\nif (begin < end) {\r\nbio->bi_bdev = sc->stripe[target_stripe].dev->bdev;\r\nbio->bi_iter.bi_sector = begin +\r\nsc->stripe[target_stripe].physical_start;\r\nbio->bi_iter.bi_size = to_bytes(end - begin);\r\nreturn DM_MAPIO_REMAPPED;\r\n} else {\r\nbio_endio(bio);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\n}\r\nstatic int stripe_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nuint32_t stripe;\r\nunsigned target_bio_nr;\r\nif (bio->bi_opf & REQ_PREFLUSH) {\r\ntarget_bio_nr = dm_bio_get_target_bio_nr(bio);\r\nBUG_ON(target_bio_nr >= sc->stripes);\r\nbio->bi_bdev = sc->stripe[target_bio_nr].dev->bdev;\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nif (unlikely(bio_op(bio) == REQ_OP_DISCARD) ||\r\nunlikely(bio_op(bio) == REQ_OP_WRITE_SAME)) {\r\ntarget_bio_nr = dm_bio_get_target_bio_nr(bio);\r\nBUG_ON(target_bio_nr >= sc->stripes);\r\nreturn stripe_map_range(sc, bio, target_bio_nr);\r\n}\r\nstripe_map_sector(sc, bio->bi_iter.bi_sector,\r\n&stripe, &bio->bi_iter.bi_sector);\r\nbio->bi_iter.bi_sector += sc->stripe[stripe].physical_start;\r\nbio->bi_bdev = sc->stripe[stripe].dev->bdev;\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic long stripe_direct_access(struct dm_target *ti, sector_t sector,\r\nvoid **kaddr, pfn_t *pfn, long size)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nuint32_t stripe;\r\nstruct block_device *bdev;\r\nstruct blk_dax_ctl dax = {\r\n.size = size,\r\n};\r\nlong ret;\r\nstripe_map_sector(sc, sector, &stripe, &dax.sector);\r\ndax.sector += sc->stripe[stripe].physical_start;\r\nbdev = sc->stripe[stripe].dev->bdev;\r\nret = bdev_direct_access(bdev, &dax);\r\n*kaddr = dax.addr;\r\n*pfn = dax.pfn;\r\nreturn ret;\r\n}\r\nstatic void stripe_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nstruct stripe_c *sc = (struct stripe_c *) ti->private;\r\nchar buffer[sc->stripes + 1];\r\nunsigned int sz = 0;\r\nunsigned int i;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%d ", sc->stripes);\r\nfor (i = 0; i < sc->stripes; i++) {\r\nDMEMIT("%s ", sc->stripe[i].dev->name);\r\nbuffer[i] = atomic_read(&(sc->stripe[i].error_count)) ?\r\n'D' : 'A';\r\n}\r\nbuffer[i] = '\0';\r\nDMEMIT("1 %s", buffer);\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%d %llu", sc->stripes,\r\n(unsigned long long)sc->chunk_size);\r\nfor (i = 0; i < sc->stripes; i++)\r\nDMEMIT(" %s %llu", sc->stripe[i].dev->name,\r\n(unsigned long long)sc->stripe[i].physical_start);\r\nbreak;\r\n}\r\n}\r\nstatic int stripe_end_io(struct dm_target *ti, struct bio *bio, int error)\r\n{\r\nunsigned i;\r\nchar major_minor[16];\r\nstruct stripe_c *sc = ti->private;\r\nif (!error)\r\nreturn 0;\r\nif ((error == -EWOULDBLOCK) && (bio->bi_opf & REQ_RAHEAD))\r\nreturn error;\r\nif (error == -EOPNOTSUPP)\r\nreturn error;\r\nmemset(major_minor, 0, sizeof(major_minor));\r\nsprintf(major_minor, "%d:%d",\r\nMAJOR(disk_devt(bio->bi_bdev->bd_disk)),\r\nMINOR(disk_devt(bio->bi_bdev->bd_disk)));\r\nfor (i = 0; i < sc->stripes; i++)\r\nif (!strcmp(sc->stripe[i].dev->name, major_minor)) {\r\natomic_inc(&(sc->stripe[i].error_count));\r\nif (atomic_read(&(sc->stripe[i].error_count)) <\r\nDM_IO_ERROR_THRESHOLD)\r\nschedule_work(&sc->trigger_event);\r\n}\r\nreturn error;\r\n}\r\nstatic int stripe_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nint ret = 0;\r\nunsigned i = 0;\r\ndo {\r\nret = fn(ti, sc->stripe[i].dev,\r\nsc->stripe[i].physical_start,\r\nsc->stripe_width, data);\r\n} while (!ret && ++i < sc->stripes);\r\nreturn ret;\r\n}\r\nstatic void stripe_io_hints(struct dm_target *ti,\r\nstruct queue_limits *limits)\r\n{\r\nstruct stripe_c *sc = ti->private;\r\nunsigned chunk_size = sc->chunk_size << SECTOR_SHIFT;\r\nblk_limits_io_min(limits, chunk_size);\r\nblk_limits_io_opt(limits, chunk_size * sc->stripes);\r\n}\r\nint __init dm_stripe_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&stripe_target);\r\nif (r < 0)\r\nDMWARN("target registration failed");\r\nreturn r;\r\n}\r\nvoid dm_stripe_exit(void)\r\n{\r\ndm_unregister_target(&stripe_target);\r\n}
