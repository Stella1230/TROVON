static void usage(void)\r\n{\r\nprintf("USAGE: sampleip [-F freq] [duration]\n");\r\nprintf(" -F freq # sample frequency (Hertz), default 99\n");\r\nprintf(" duration # sampling duration (seconds), default 5\n");\r\n}\r\nstatic int sampling_start(int *pmu_fd, int freq)\r\n{\r\nint i;\r\nstruct perf_event_attr pe_sample_attr = {\r\n.type = PERF_TYPE_SOFTWARE,\r\n.freq = 1,\r\n.sample_period = freq,\r\n.config = PERF_COUNT_SW_CPU_CLOCK,\r\n.inherit = 1,\r\n};\r\nfor (i = 0; i < nr_cpus; i++) {\r\npmu_fd[i] = sys_perf_event_open(&pe_sample_attr, -1 , i,\r\n-1 , 0 );\r\nif (pmu_fd[i] < 0) {\r\nfprintf(stderr, "ERROR: Initializing perf sampling\n");\r\nreturn 1;\r\n}\r\nassert(ioctl(pmu_fd[i], PERF_EVENT_IOC_SET_BPF,\r\nprog_fd[0]) == 0);\r\nassert(ioctl(pmu_fd[i], PERF_EVENT_IOC_ENABLE, 0) == 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sampling_end(int *pmu_fd)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_cpus; i++)\r\nclose(pmu_fd[i]);\r\n}\r\nstatic int count_cmp(const void *p1, const void *p2)\r\n{\r\nreturn ((struct ipcount *)p1)->count - ((struct ipcount *)p2)->count;\r\n}\r\nstatic void print_ip_map(int fd)\r\n{\r\nstruct ksym *sym;\r\n__u64 key, next_key;\r\n__u32 value;\r\nint i, max;\r\nprintf("%-19s %-32s %s\n", "ADDR", "KSYM", "COUNT");\r\nkey = 0, i = 0;\r\nwhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\r\nbpf_map_lookup_elem(fd, &next_key, &value);\r\ncounts[i].ip = next_key;\r\ncounts[i++].count = value;\r\nkey = next_key;\r\n}\r\nmax = i;\r\nqsort(counts, max, sizeof(struct ipcount), count_cmp);\r\nfor (i = 0; i < max; i++) {\r\nif (counts[i].ip > PAGE_OFFSET) {\r\nsym = ksym_search(counts[i].ip);\r\nprintf("0x%-17llx %-32s %u\n", counts[i].ip, sym->name,\r\ncounts[i].count);\r\n} else {\r\nprintf("0x%-17llx %-32s %u\n", counts[i].ip, "(user)",\r\ncounts[i].count);\r\n}\r\n}\r\nif (max == MAX_IPS) {\r\nprintf("WARNING: IP hash was full (max %d entries); ", max);\r\nprintf("may have dropped samples\n");\r\n}\r\n}\r\nstatic void int_exit(int sig)\r\n{\r\nprintf("\n");\r\nprint_ip_map(map_fd[0]);\r\nexit(0);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nchar filename[256];\r\nint *pmu_fd, opt, freq = DEFAULT_FREQ, secs = DEFAULT_SECS;\r\nwhile ((opt = getopt(argc, argv, "F:h")) != -1) {\r\nswitch (opt) {\r\ncase 'F':\r\nfreq = atoi(optarg);\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nusage();\r\nreturn 0;\r\n}\r\n}\r\nif (argc - optind == 1)\r\nsecs = atoi(argv[optind]);\r\nif (freq == 0 || secs == 0) {\r\nusage();\r\nreturn 1;\r\n}\r\nif (load_kallsyms()) {\r\nfprintf(stderr, "ERROR: loading /proc/kallsyms\n");\r\nreturn 2;\r\n}\r\nnr_cpus = sysconf(_SC_NPROCESSORS_CONF);\r\npmu_fd = malloc(nr_cpus * sizeof(int));\r\nif (pmu_fd == NULL) {\r\nfprintf(stderr, "ERROR: malloc of pmu_fd\n");\r\nreturn 1;\r\n}\r\nsnprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);\r\nif (load_bpf_file(filename)) {\r\nfprintf(stderr, "ERROR: loading BPF program (errno %d):\n",\r\nerrno);\r\nif (strcmp(bpf_log_buf, "") == 0)\r\nfprintf(stderr, "Try: ulimit -l unlimited\n");\r\nelse\r\nfprintf(stderr, "%s", bpf_log_buf);\r\nreturn 1;\r\n}\r\nsignal(SIGINT, int_exit);\r\nprintf("Sampling at %d Hertz for %d seconds. Ctrl-C also ends.\n",\r\nfreq, secs);\r\nif (sampling_start(pmu_fd, freq) != 0)\r\nreturn 1;\r\nsleep(secs);\r\nsampling_end(pmu_fd);\r\nfree(pmu_fd);\r\nprint_ip_map(map_fd[0]);\r\nreturn 0;\r\n}
