static int filter_pred_string(struct filter_pred *pred, void *event)\r\n{\r\nchar *addr = (char *)(event + pred->offset);\r\nint cmp, match;\r\ncmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\r\nmatch = cmp ^ pred->not;\r\nreturn match;\r\n}\r\nstatic int filter_pred_pchar(struct filter_pred *pred, void *event)\r\n{\r\nchar **addr = (char **)(event + pred->offset);\r\nint cmp, match;\r\nint len = strlen(*addr) + 1;\r\ncmp = pred->regex.match(*addr, &pred->regex, len);\r\nmatch = cmp ^ pred->not;\r\nreturn match;\r\n}\r\nstatic int filter_pred_strloc(struct filter_pred *pred, void *event)\r\n{\r\nu32 str_item = *(u32 *)(event + pred->offset);\r\nint str_loc = str_item & 0xffff;\r\nint str_len = str_item >> 16;\r\nchar *addr = (char *)(event + str_loc);\r\nint cmp, match;\r\ncmp = pred->regex.match(addr, &pred->regex, str_len);\r\nmatch = cmp ^ pred->not;\r\nreturn match;\r\n}\r\nstatic int filter_pred_cpu(struct filter_pred *pred, void *event)\r\n{\r\nint cpu, cmp;\r\nint match = 0;\r\ncpu = raw_smp_processor_id();\r\ncmp = pred->val;\r\nswitch (pred->op) {\r\ncase OP_EQ:\r\nmatch = cpu == cmp;\r\nbreak;\r\ncase OP_LT:\r\nmatch = cpu < cmp;\r\nbreak;\r\ncase OP_LE:\r\nmatch = cpu <= cmp;\r\nbreak;\r\ncase OP_GT:\r\nmatch = cpu > cmp;\r\nbreak;\r\ncase OP_GE:\r\nmatch = cpu >= cmp;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn !!match == !pred->not;\r\n}\r\nstatic int filter_pred_comm(struct filter_pred *pred, void *event)\r\n{\r\nint cmp, match;\r\ncmp = pred->regex.match(current->comm, &pred->regex,\r\npred->regex.field_len);\r\nmatch = cmp ^ pred->not;\r\nreturn match;\r\n}\r\nstatic int filter_pred_none(struct filter_pred *pred, void *event)\r\n{\r\nreturn 0;\r\n}\r\nstatic int regex_match_full(char *str, struct regex *r, int len)\r\n{\r\nif (strncmp(str, r->pattern, len) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int regex_match_front(char *str, struct regex *r, int len)\r\n{\r\nif (strncmp(str, r->pattern, r->len) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int regex_match_middle(char *str, struct regex *r, int len)\r\n{\r\nif (strnstr(str, r->pattern, len))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int regex_match_end(char *str, struct regex *r, int len)\r\n{\r\nint strlen = len - 1;\r\nif (strlen >= r->len &&\r\nmemcmp(str + strlen - r->len, r->pattern, r->len) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\r\n{\r\nif (glob_match(r->pattern, str))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\r\n{\r\nint type = MATCH_FULL;\r\nint i;\r\nif (buff[0] == '!') {\r\n*not = 1;\r\nbuff++;\r\nlen--;\r\n} else\r\n*not = 0;\r\n*search = buff;\r\nfor (i = 0; i < len; i++) {\r\nif (buff[i] == '*') {\r\nif (!i) {\r\n*search = buff + 1;\r\ntype = MATCH_END_ONLY;\r\n} else if (i == len - 1) {\r\nif (type == MATCH_END_ONLY)\r\ntype = MATCH_MIDDLE_ONLY;\r\nelse\r\ntype = MATCH_FRONT_ONLY;\r\nbuff[i] = 0;\r\nbreak;\r\n} else {\r\ntype = MATCH_GLOB;\r\nbreak;\r\n}\r\n} else if (strchr("[?\\", buff[i])) {\r\ntype = MATCH_GLOB;\r\nbreak;\r\n}\r\n}\r\nreturn type;\r\n}\r\nstatic void filter_build_regex(struct filter_pred *pred)\r\n{\r\nstruct regex *r = &pred->regex;\r\nchar *search;\r\nenum regex_type type = MATCH_FULL;\r\nint not = 0;\r\nif (pred->op == OP_GLOB) {\r\ntype = filter_parse_regex(r->pattern, r->len, &search, &not);\r\nr->len = strlen(search);\r\nmemmove(r->pattern, search, r->len+1);\r\n}\r\nswitch (type) {\r\ncase MATCH_FULL:\r\nr->match = regex_match_full;\r\nbreak;\r\ncase MATCH_FRONT_ONLY:\r\nr->match = regex_match_front;\r\nbreak;\r\ncase MATCH_MIDDLE_ONLY:\r\nr->match = regex_match_middle;\r\nbreak;\r\ncase MATCH_END_ONLY:\r\nr->match = regex_match_end;\r\nbreak;\r\ncase MATCH_GLOB:\r\nr->match = regex_match_glob;\r\nbreak;\r\n}\r\npred->not ^= not;\r\n}\r\nstatic struct filter_pred *\r\nget_pred_parent(struct filter_pred *pred, struct filter_pred *preds,\r\nint index, enum move_type *move)\r\n{\r\nif (pred->parent & FILTER_PRED_IS_RIGHT)\r\n*move = MOVE_UP_FROM_RIGHT;\r\nelse\r\n*move = MOVE_UP_FROM_LEFT;\r\npred = &preds[pred->parent & ~FILTER_PRED_IS_RIGHT];\r\nreturn pred;\r\n}\r\nstatic int walk_pred_tree(struct filter_pred *preds,\r\nstruct filter_pred *root,\r\nfilter_pred_walkcb_t cb, void *data)\r\n{\r\nstruct filter_pred *pred = root;\r\nenum move_type move = MOVE_DOWN;\r\nint done = 0;\r\nif (!preds)\r\nreturn -EINVAL;\r\ndo {\r\nint err = 0, ret;\r\nret = cb(move, pred, &err, data);\r\nif (ret == WALK_PRED_ABORT)\r\nreturn err;\r\nif (ret == WALK_PRED_PARENT)\r\ngoto get_parent;\r\nswitch (move) {\r\ncase MOVE_DOWN:\r\nif (pred->left != FILTER_PRED_INVALID) {\r\npred = &preds[pred->left];\r\ncontinue;\r\n}\r\ngoto get_parent;\r\ncase MOVE_UP_FROM_LEFT:\r\npred = &preds[pred->right];\r\nmove = MOVE_DOWN;\r\ncontinue;\r\ncase MOVE_UP_FROM_RIGHT:\r\nget_parent:\r\nif (pred == root)\r\nbreak;\r\npred = get_pred_parent(pred, preds,\r\npred->parent,\r\n&move);\r\ncontinue;\r\n}\r\ndone = 1;\r\n} while (!done);\r\nreturn 0;\r\n}\r\nstatic int process_ops(struct filter_pred *preds,\r\nstruct filter_pred *op, void *rec)\r\n{\r\nstruct filter_pred *pred;\r\nint match = 0;\r\nint type;\r\nint i;\r\ntype = op->op == OP_OR;\r\nfor (i = 0; i < op->val; i++) {\r\npred = &preds[op->ops[i]];\r\nif (!WARN_ON_ONCE(!pred->fn))\r\nmatch = pred->fn(pred, rec);\r\nif (!!match == type)\r\nbreak;\r\n}\r\nreturn !!match == !op->not;\r\n}\r\nstatic int filter_match_preds_cb(enum move_type move, struct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nstruct filter_match_preds_data *d = data;\r\n*err = 0;\r\nswitch (move) {\r\ncase MOVE_DOWN:\r\nif (pred->left != FILTER_PRED_INVALID) {\r\nif (!pred->ops)\r\nreturn WALK_PRED_DEFAULT;\r\nd->match = process_ops(d->preds, pred, d->rec);\r\n} else {\r\nif (!WARN_ON_ONCE(!pred->fn))\r\nd->match = pred->fn(pred, d->rec);\r\n}\r\nreturn WALK_PRED_PARENT;\r\ncase MOVE_UP_FROM_LEFT:\r\nif (!!d->match == (pred->op == OP_OR))\r\nreturn WALK_PRED_PARENT;\r\nbreak;\r\ncase MOVE_UP_FROM_RIGHT:\r\nbreak;\r\n}\r\nreturn WALK_PRED_DEFAULT;\r\n}\r\nint filter_match_preds(struct event_filter *filter, void *rec)\r\n{\r\nstruct filter_pred *preds;\r\nstruct filter_pred *root;\r\nstruct filter_match_preds_data data = {\r\n.match = -1,\r\n.rec = rec,\r\n};\r\nint n_preds, ret;\r\nif (!filter)\r\nreturn 1;\r\nn_preds = filter->n_preds;\r\nif (!n_preds)\r\nreturn 1;\r\nroot = rcu_dereference_sched(filter->root);\r\nif (!root)\r\nreturn 1;\r\ndata.preds = preds = rcu_dereference_sched(filter->preds);\r\nret = walk_pred_tree(preds, root, filter_match_preds_cb, &data);\r\nWARN_ON(ret);\r\nreturn data.match;\r\n}\r\nstatic void parse_error(struct filter_parse_state *ps, int err, int pos)\r\n{\r\nps->lasterr = err;\r\nps->lasterr_pos = pos;\r\n}\r\nstatic void remove_filter_string(struct event_filter *filter)\r\n{\r\nif (!filter)\r\nreturn;\r\nkfree(filter->filter_string);\r\nfilter->filter_string = NULL;\r\n}\r\nstatic int replace_filter_string(struct event_filter *filter,\r\nchar *filter_string)\r\n{\r\nkfree(filter->filter_string);\r\nfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\r\nif (!filter->filter_string)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int append_filter_string(struct event_filter *filter,\r\nchar *string)\r\n{\r\nint newlen;\r\nchar *new_filter_string;\r\nBUG_ON(!filter->filter_string);\r\nnewlen = strlen(filter->filter_string) + strlen(string) + 1;\r\nnew_filter_string = kmalloc(newlen, GFP_KERNEL);\r\nif (!new_filter_string)\r\nreturn -ENOMEM;\r\nstrcpy(new_filter_string, filter->filter_string);\r\nstrcat(new_filter_string, string);\r\nkfree(filter->filter_string);\r\nfilter->filter_string = new_filter_string;\r\nreturn 0;\r\n}\r\nstatic void append_filter_err(struct filter_parse_state *ps,\r\nstruct event_filter *filter)\r\n{\r\nint pos = ps->lasterr_pos;\r\nchar *buf, *pbuf;\r\nbuf = (char *)__get_free_page(GFP_TEMPORARY);\r\nif (!buf)\r\nreturn;\r\nappend_filter_string(filter, "\n");\r\nmemset(buf, ' ', PAGE_SIZE);\r\nif (pos > PAGE_SIZE - 128)\r\npos = 0;\r\nbuf[pos] = '^';\r\npbuf = &buf[pos] + 1;\r\nsprintf(pbuf, "\nparse_error: %s\n", err_text[ps->lasterr]);\r\nappend_filter_string(filter, buf);\r\nfree_page((unsigned long) buf);\r\n}\r\nstatic inline struct event_filter *event_filter(struct trace_event_file *file)\r\n{\r\nreturn file->filter;\r\n}\r\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\r\n{\r\nstruct event_filter *filter = event_filter(file);\r\nif (filter && filter->filter_string)\r\ntrace_seq_printf(s, "%s\n", filter->filter_string);\r\nelse\r\ntrace_seq_puts(s, "none\n");\r\n}\r\nvoid print_subsystem_event_filter(struct event_subsystem *system,\r\nstruct trace_seq *s)\r\n{\r\nstruct event_filter *filter;\r\nmutex_lock(&event_mutex);\r\nfilter = system->filter;\r\nif (filter && filter->filter_string)\r\ntrace_seq_printf(s, "%s\n", filter->filter_string);\r\nelse\r\ntrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE "\n");\r\nmutex_unlock(&event_mutex);\r\n}\r\nstatic int __alloc_pred_stack(struct pred_stack *stack, int n_preds)\r\n{\r\nstack->preds = kcalloc(n_preds + 1, sizeof(*stack->preds), GFP_KERNEL);\r\nif (!stack->preds)\r\nreturn -ENOMEM;\r\nstack->index = n_preds;\r\nreturn 0;\r\n}\r\nstatic void __free_pred_stack(struct pred_stack *stack)\r\n{\r\nkfree(stack->preds);\r\nstack->index = 0;\r\n}\r\nstatic int __push_pred_stack(struct pred_stack *stack,\r\nstruct filter_pred *pred)\r\n{\r\nint index = stack->index;\r\nif (WARN_ON(index == 0))\r\nreturn -ENOSPC;\r\nstack->preds[--index] = pred;\r\nstack->index = index;\r\nreturn 0;\r\n}\r\nstatic struct filter_pred *\r\n__pop_pred_stack(struct pred_stack *stack)\r\n{\r\nstruct filter_pred *pred;\r\nint index = stack->index;\r\npred = stack->preds[index++];\r\nif (!pred)\r\nreturn NULL;\r\nstack->index = index;\r\nreturn pred;\r\n}\r\nstatic int filter_set_pred(struct event_filter *filter,\r\nint idx,\r\nstruct pred_stack *stack,\r\nstruct filter_pred *src)\r\n{\r\nstruct filter_pred *dest = &filter->preds[idx];\r\nstruct filter_pred *left;\r\nstruct filter_pred *right;\r\n*dest = *src;\r\ndest->index = idx;\r\nif (dest->op == OP_OR || dest->op == OP_AND) {\r\nright = __pop_pred_stack(stack);\r\nleft = __pop_pred_stack(stack);\r\nif (!left || !right)\r\nreturn -EINVAL;\r\nif (left->index & FILTER_PRED_FOLD &&\r\n((left->op == dest->op && !left->not) ||\r\nleft->left == FILTER_PRED_INVALID) &&\r\nright->index & FILTER_PRED_FOLD &&\r\n((right->op == dest->op && !right->not) ||\r\nright->left == FILTER_PRED_INVALID))\r\ndest->index |= FILTER_PRED_FOLD;\r\ndest->left = left->index & ~FILTER_PRED_FOLD;\r\ndest->right = right->index & ~FILTER_PRED_FOLD;\r\nleft->parent = dest->index & ~FILTER_PRED_FOLD;\r\nright->parent = dest->index | FILTER_PRED_IS_RIGHT;\r\n} else {\r\ndest->left = FILTER_PRED_INVALID;\r\ndest->index |= FILTER_PRED_FOLD;\r\n}\r\nreturn __push_pred_stack(stack, dest);\r\n}\r\nstatic void __free_preds(struct event_filter *filter)\r\n{\r\nint i;\r\nif (filter->preds) {\r\nfor (i = 0; i < filter->n_preds; i++)\r\nkfree(filter->preds[i].ops);\r\nkfree(filter->preds);\r\nfilter->preds = NULL;\r\n}\r\nfilter->a_preds = 0;\r\nfilter->n_preds = 0;\r\n}\r\nstatic void filter_disable(struct trace_event_file *file)\r\n{\r\nunsigned long old_flags = file->flags;\r\nfile->flags &= ~EVENT_FILE_FL_FILTERED;\r\nif (old_flags != file->flags)\r\ntrace_buffered_event_disable();\r\n}\r\nstatic void __free_filter(struct event_filter *filter)\r\n{\r\nif (!filter)\r\nreturn;\r\n__free_preds(filter);\r\nkfree(filter->filter_string);\r\nkfree(filter);\r\n}\r\nvoid free_event_filter(struct event_filter *filter)\r\n{\r\n__free_filter(filter);\r\n}\r\nstatic struct event_filter *__alloc_filter(void)\r\n{\r\nstruct event_filter *filter;\r\nfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\r\nreturn filter;\r\n}\r\nstatic int __alloc_preds(struct event_filter *filter, int n_preds)\r\n{\r\nstruct filter_pred *pred;\r\nint i;\r\nif (filter->preds)\r\n__free_preds(filter);\r\nfilter->preds = kcalloc(n_preds, sizeof(*filter->preds), GFP_KERNEL);\r\nif (!filter->preds)\r\nreturn -ENOMEM;\r\nfilter->a_preds = n_preds;\r\nfilter->n_preds = 0;\r\nfor (i = 0; i < n_preds; i++) {\r\npred = &filter->preds[i];\r\npred->fn = filter_pred_none;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void __remove_filter(struct trace_event_file *file)\r\n{\r\nfilter_disable(file);\r\nremove_filter_string(file->filter);\r\n}\r\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\r\nstruct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nlist_for_each_entry(file, &tr->events, list) {\r\nif (file->system != dir)\r\ncontinue;\r\n__remove_filter(file);\r\n}\r\n}\r\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\r\n{\r\n__free_filter(file->filter);\r\nfile->filter = NULL;\r\n}\r\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\r\nstruct trace_array *tr)\r\n{\r\nstruct trace_event_file *file;\r\nlist_for_each_entry(file, &tr->events, list) {\r\nif (file->system != dir)\r\ncontinue;\r\n__free_subsystem_filter(file);\r\n}\r\n}\r\nstatic int filter_add_pred(struct filter_parse_state *ps,\r\nstruct event_filter *filter,\r\nstruct filter_pred *pred,\r\nstruct pred_stack *stack)\r\n{\r\nint err;\r\nif (WARN_ON(filter->n_preds == filter->a_preds)) {\r\nparse_error(ps, FILT_ERR_TOO_MANY_PREDS, 0);\r\nreturn -ENOSPC;\r\n}\r\nerr = filter_set_pred(filter, filter->n_preds, stack, pred);\r\nif (err)\r\nreturn err;\r\nfilter->n_preds++;\r\nreturn 0;\r\n}\r\nint filter_assign_type(const char *type)\r\n{\r\nif (strstr(type, "__data_loc") && strstr(type, "char"))\r\nreturn FILTER_DYN_STRING;\r\nif (strchr(type, '[') && strstr(type, "char"))\r\nreturn FILTER_STATIC_STRING;\r\nreturn FILTER_OTHER;\r\n}\r\nstatic bool is_legal_op(struct ftrace_event_field *field, enum filter_op_ids op)\r\n{\r\nif (is_string_field(field) &&\r\n(op != OP_EQ && op != OP_NE && op != OP_GLOB))\r\nreturn false;\r\nif (!is_string_field(field) && op == OP_GLOB)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\r\nint field_size, int field_is_signed)\r\n{\r\nfilter_pred_fn_t fn = NULL;\r\nswitch (field_size) {\r\ncase 8:\r\nif (op == OP_EQ || op == OP_NE)\r\nfn = filter_pred_64;\r\nelse if (field_is_signed)\r\nfn = pred_funcs_s64[op - PRED_FUNC_START];\r\nelse\r\nfn = pred_funcs_u64[op - PRED_FUNC_START];\r\nbreak;\r\ncase 4:\r\nif (op == OP_EQ || op == OP_NE)\r\nfn = filter_pred_32;\r\nelse if (field_is_signed)\r\nfn = pred_funcs_s32[op - PRED_FUNC_START];\r\nelse\r\nfn = pred_funcs_u32[op - PRED_FUNC_START];\r\nbreak;\r\ncase 2:\r\nif (op == OP_EQ || op == OP_NE)\r\nfn = filter_pred_16;\r\nelse if (field_is_signed)\r\nfn = pred_funcs_s16[op - PRED_FUNC_START];\r\nelse\r\nfn = pred_funcs_u16[op - PRED_FUNC_START];\r\nbreak;\r\ncase 1:\r\nif (op == OP_EQ || op == OP_NE)\r\nfn = filter_pred_8;\r\nelse if (field_is_signed)\r\nfn = pred_funcs_s8[op - PRED_FUNC_START];\r\nelse\r\nfn = pred_funcs_u8[op - PRED_FUNC_START];\r\nbreak;\r\n}\r\nreturn fn;\r\n}\r\nstatic int init_pred(struct filter_parse_state *ps,\r\nstruct ftrace_event_field *field,\r\nstruct filter_pred *pred)\r\n{\r\nfilter_pred_fn_t fn = filter_pred_none;\r\nunsigned long long val;\r\nint ret;\r\npred->offset = field->offset;\r\nif (!is_legal_op(field, pred->op)) {\r\nparse_error(ps, FILT_ERR_ILLEGAL_FIELD_OP, 0);\r\nreturn -EINVAL;\r\n}\r\nif (field->filter_type == FILTER_COMM) {\r\nfilter_build_regex(pred);\r\nfn = filter_pred_comm;\r\npred->regex.field_len = TASK_COMM_LEN;\r\n} else if (is_string_field(field)) {\r\nfilter_build_regex(pred);\r\nif (field->filter_type == FILTER_STATIC_STRING) {\r\nfn = filter_pred_string;\r\npred->regex.field_len = field->size;\r\n} else if (field->filter_type == FILTER_DYN_STRING)\r\nfn = filter_pred_strloc;\r\nelse\r\nfn = filter_pred_pchar;\r\n} else if (is_function_field(field)) {\r\nif (strcmp(field->name, "ip")) {\r\nparse_error(ps, FILT_ERR_IP_FIELD_ONLY, 0);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (field->is_signed)\r\nret = kstrtoll(pred->regex.pattern, 0, &val);\r\nelse\r\nret = kstrtoull(pred->regex.pattern, 0, &val);\r\nif (ret) {\r\nparse_error(ps, FILT_ERR_ILLEGAL_INTVAL, 0);\r\nreturn -EINVAL;\r\n}\r\npred->val = val;\r\nif (field->filter_type == FILTER_CPU)\r\nfn = filter_pred_cpu;\r\nelse\r\nfn = select_comparison_fn(pred->op, field->size,\r\nfield->is_signed);\r\nif (!fn) {\r\nparse_error(ps, FILT_ERR_INVALID_OP, 0);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (pred->op == OP_NE)\r\npred->not ^= 1;\r\npred->fn = fn;\r\nreturn 0;\r\n}\r\nstatic void parse_init(struct filter_parse_state *ps,\r\nstruct filter_op *ops,\r\nchar *infix_string)\r\n{\r\nmemset(ps, '\0', sizeof(*ps));\r\nps->infix.string = infix_string;\r\nps->infix.cnt = strlen(infix_string);\r\nps->ops = ops;\r\nINIT_LIST_HEAD(&ps->opstack);\r\nINIT_LIST_HEAD(&ps->postfix);\r\n}\r\nstatic char infix_next(struct filter_parse_state *ps)\r\n{\r\nif (!ps->infix.cnt)\r\nreturn 0;\r\nps->infix.cnt--;\r\nreturn ps->infix.string[ps->infix.tail++];\r\n}\r\nstatic char infix_peek(struct filter_parse_state *ps)\r\n{\r\nif (ps->infix.tail == strlen(ps->infix.string))\r\nreturn 0;\r\nreturn ps->infix.string[ps->infix.tail];\r\n}\r\nstatic void infix_advance(struct filter_parse_state *ps)\r\n{\r\nif (!ps->infix.cnt)\r\nreturn;\r\nps->infix.cnt--;\r\nps->infix.tail++;\r\n}\r\nstatic inline int is_precedence_lower(struct filter_parse_state *ps,\r\nint a, int b)\r\n{\r\nreturn ps->ops[a].precedence < ps->ops[b].precedence;\r\n}\r\nstatic inline int is_op_char(struct filter_parse_state *ps, char c)\r\n{\r\nint i;\r\nfor (i = 0; strcmp(ps->ops[i].string, "OP_NONE"); i++) {\r\nif (ps->ops[i].string[0] == c)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int infix_get_op(struct filter_parse_state *ps, char firstc)\r\n{\r\nchar nextc = infix_peek(ps);\r\nchar opstr[3];\r\nint i;\r\nopstr[0] = firstc;\r\nopstr[1] = nextc;\r\nopstr[2] = '\0';\r\nfor (i = 0; strcmp(ps->ops[i].string, "OP_NONE"); i++) {\r\nif (!strcmp(opstr, ps->ops[i].string)) {\r\ninfix_advance(ps);\r\nreturn ps->ops[i].id;\r\n}\r\n}\r\nopstr[1] = '\0';\r\nfor (i = 0; strcmp(ps->ops[i].string, "OP_NONE"); i++) {\r\nif (!strcmp(opstr, ps->ops[i].string))\r\nreturn ps->ops[i].id;\r\n}\r\nreturn OP_NONE;\r\n}\r\nstatic inline void clear_operand_string(struct filter_parse_state *ps)\r\n{\r\nmemset(ps->operand.string, '\0', MAX_FILTER_STR_VAL);\r\nps->operand.tail = 0;\r\n}\r\nstatic inline int append_operand_char(struct filter_parse_state *ps, char c)\r\n{\r\nif (ps->operand.tail == MAX_FILTER_STR_VAL - 1)\r\nreturn -EINVAL;\r\nps->operand.string[ps->operand.tail++] = c;\r\nreturn 0;\r\n}\r\nstatic int filter_opstack_push(struct filter_parse_state *ps,\r\nenum filter_op_ids op)\r\n{\r\nstruct opstack_op *opstack_op;\r\nopstack_op = kmalloc(sizeof(*opstack_op), GFP_KERNEL);\r\nif (!opstack_op)\r\nreturn -ENOMEM;\r\nopstack_op->op = op;\r\nlist_add(&opstack_op->list, &ps->opstack);\r\nreturn 0;\r\n}\r\nstatic int filter_opstack_empty(struct filter_parse_state *ps)\r\n{\r\nreturn list_empty(&ps->opstack);\r\n}\r\nstatic int filter_opstack_top(struct filter_parse_state *ps)\r\n{\r\nstruct opstack_op *opstack_op;\r\nif (filter_opstack_empty(ps))\r\nreturn OP_NONE;\r\nopstack_op = list_first_entry(&ps->opstack, struct opstack_op, list);\r\nreturn opstack_op->op;\r\n}\r\nstatic int filter_opstack_pop(struct filter_parse_state *ps)\r\n{\r\nstruct opstack_op *opstack_op;\r\nenum filter_op_ids op;\r\nif (filter_opstack_empty(ps))\r\nreturn OP_NONE;\r\nopstack_op = list_first_entry(&ps->opstack, struct opstack_op, list);\r\nop = opstack_op->op;\r\nlist_del(&opstack_op->list);\r\nkfree(opstack_op);\r\nreturn op;\r\n}\r\nstatic void filter_opstack_clear(struct filter_parse_state *ps)\r\n{\r\nwhile (!filter_opstack_empty(ps))\r\nfilter_opstack_pop(ps);\r\n}\r\nstatic char *curr_operand(struct filter_parse_state *ps)\r\n{\r\nreturn ps->operand.string;\r\n}\r\nstatic int postfix_append_operand(struct filter_parse_state *ps, char *operand)\r\n{\r\nstruct postfix_elt *elt;\r\nelt = kmalloc(sizeof(*elt), GFP_KERNEL);\r\nif (!elt)\r\nreturn -ENOMEM;\r\nelt->op = OP_NONE;\r\nelt->operand = kstrdup(operand, GFP_KERNEL);\r\nif (!elt->operand) {\r\nkfree(elt);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail(&elt->list, &ps->postfix);\r\nreturn 0;\r\n}\r\nstatic int postfix_append_op(struct filter_parse_state *ps, enum filter_op_ids op)\r\n{\r\nstruct postfix_elt *elt;\r\nelt = kmalloc(sizeof(*elt), GFP_KERNEL);\r\nif (!elt)\r\nreturn -ENOMEM;\r\nelt->op = op;\r\nelt->operand = NULL;\r\nlist_add_tail(&elt->list, &ps->postfix);\r\nreturn 0;\r\n}\r\nstatic void postfix_clear(struct filter_parse_state *ps)\r\n{\r\nstruct postfix_elt *elt;\r\nwhile (!list_empty(&ps->postfix)) {\r\nelt = list_first_entry(&ps->postfix, struct postfix_elt, list);\r\nlist_del(&elt->list);\r\nkfree(elt->operand);\r\nkfree(elt);\r\n}\r\n}\r\nstatic int filter_parse(struct filter_parse_state *ps)\r\n{\r\nenum filter_op_ids op, top_op;\r\nint in_string = 0;\r\nchar ch;\r\nwhile ((ch = infix_next(ps))) {\r\nif (ch == '"') {\r\nin_string ^= 1;\r\ncontinue;\r\n}\r\nif (in_string)\r\ngoto parse_operand;\r\nif (isspace(ch))\r\ncontinue;\r\nif (is_op_char(ps, ch)) {\r\nop = infix_get_op(ps, ch);\r\nif (op == OP_NONE) {\r\nparse_error(ps, FILT_ERR_INVALID_OP, 0);\r\nreturn -EINVAL;\r\n}\r\nif (strlen(curr_operand(ps))) {\r\npostfix_append_operand(ps, curr_operand(ps));\r\nclear_operand_string(ps);\r\n}\r\nwhile (!filter_opstack_empty(ps)) {\r\ntop_op = filter_opstack_top(ps);\r\nif (!is_precedence_lower(ps, top_op, op)) {\r\ntop_op = filter_opstack_pop(ps);\r\npostfix_append_op(ps, top_op);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nfilter_opstack_push(ps, op);\r\ncontinue;\r\n}\r\nif (ch == '(') {\r\nfilter_opstack_push(ps, OP_OPEN_PAREN);\r\ncontinue;\r\n}\r\nif (ch == ')') {\r\nif (strlen(curr_operand(ps))) {\r\npostfix_append_operand(ps, curr_operand(ps));\r\nclear_operand_string(ps);\r\n}\r\ntop_op = filter_opstack_pop(ps);\r\nwhile (top_op != OP_NONE) {\r\nif (top_op == OP_OPEN_PAREN)\r\nbreak;\r\npostfix_append_op(ps, top_op);\r\ntop_op = filter_opstack_pop(ps);\r\n}\r\nif (top_op == OP_NONE) {\r\nparse_error(ps, FILT_ERR_UNBALANCED_PAREN, 0);\r\nreturn -EINVAL;\r\n}\r\ncontinue;\r\n}\r\nparse_operand:\r\nif (append_operand_char(ps, ch)) {\r\nparse_error(ps, FILT_ERR_OPERAND_TOO_LONG, 0);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (strlen(curr_operand(ps)))\r\npostfix_append_operand(ps, curr_operand(ps));\r\nwhile (!filter_opstack_empty(ps)) {\r\ntop_op = filter_opstack_pop(ps);\r\nif (top_op == OP_NONE)\r\nbreak;\r\nif (top_op == OP_OPEN_PAREN) {\r\nparse_error(ps, FILT_ERR_UNBALANCED_PAREN, 0);\r\nreturn -EINVAL;\r\n}\r\npostfix_append_op(ps, top_op);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct filter_pred *create_pred(struct filter_parse_state *ps,\r\nstruct trace_event_call *call,\r\nenum filter_op_ids op,\r\nchar *operand1, char *operand2)\r\n{\r\nstruct ftrace_event_field *field;\r\nstatic struct filter_pred pred;\r\nmemset(&pred, 0, sizeof(pred));\r\npred.op = op;\r\nif (op == OP_AND || op == OP_OR)\r\nreturn &pred;\r\nif (!operand1 || !operand2) {\r\nparse_error(ps, FILT_ERR_MISSING_FIELD, 0);\r\nreturn NULL;\r\n}\r\nfield = trace_find_event_field(call, operand1);\r\nif (!field) {\r\nparse_error(ps, FILT_ERR_FIELD_NOT_FOUND, 0);\r\nreturn NULL;\r\n}\r\nstrcpy(pred.regex.pattern, operand2);\r\npred.regex.len = strlen(pred.regex.pattern);\r\npred.field = field;\r\nreturn init_pred(ps, field, &pred) ? NULL : &pred;\r\n}\r\nstatic int check_preds(struct filter_parse_state *ps)\r\n{\r\nint n_normal_preds = 0, n_logical_preds = 0;\r\nstruct postfix_elt *elt;\r\nint cnt = 0;\r\nlist_for_each_entry(elt, &ps->postfix, list) {\r\nif (elt->op == OP_NONE) {\r\ncnt++;\r\ncontinue;\r\n}\r\nif (elt->op == OP_AND || elt->op == OP_OR) {\r\nn_logical_preds++;\r\ncnt--;\r\ncontinue;\r\n}\r\nif (elt->op != OP_NOT)\r\ncnt--;\r\nn_normal_preds++;\r\nif (cnt < 0)\r\nbreak;\r\n}\r\nif (cnt != 1 || !n_normal_preds || n_logical_preds >= n_normal_preds) {\r\nparse_error(ps, FILT_ERR_INVALID_FILTER, 0);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int count_preds(struct filter_parse_state *ps)\r\n{\r\nstruct postfix_elt *elt;\r\nint n_preds = 0;\r\nlist_for_each_entry(elt, &ps->postfix, list) {\r\nif (elt->op == OP_NONE)\r\ncontinue;\r\nn_preds++;\r\n}\r\nreturn n_preds;\r\n}\r\nstatic int check_pred_tree_cb(enum move_type move, struct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nstruct check_pred_data *d = data;\r\nif (WARN_ON(d->count++ > d->max)) {\r\n*err = -EINVAL;\r\nreturn WALK_PRED_ABORT;\r\n}\r\nreturn WALK_PRED_DEFAULT;\r\n}\r\nstatic int check_pred_tree(struct event_filter *filter,\r\nstruct filter_pred *root)\r\n{\r\nstruct check_pred_data data = {\r\n.max = 3 * filter->n_preds,\r\n.count = 0,\r\n};\r\nreturn walk_pred_tree(filter->preds, root,\r\ncheck_pred_tree_cb, &data);\r\n}\r\nstatic int count_leafs_cb(enum move_type move, struct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nint *count = data;\r\nif ((move == MOVE_DOWN) &&\r\n(pred->left == FILTER_PRED_INVALID))\r\n(*count)++;\r\nreturn WALK_PRED_DEFAULT;\r\n}\r\nstatic int count_leafs(struct filter_pred *preds, struct filter_pred *root)\r\n{\r\nint count = 0, ret;\r\nret = walk_pred_tree(preds, root, count_leafs_cb, &count);\r\nWARN_ON(ret);\r\nreturn count;\r\n}\r\nstatic int fold_pred_cb(enum move_type move, struct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nstruct fold_pred_data *d = data;\r\nstruct filter_pred *root = d->root;\r\nif (move != MOVE_DOWN)\r\nreturn WALK_PRED_DEFAULT;\r\nif (pred->left != FILTER_PRED_INVALID)\r\nreturn WALK_PRED_DEFAULT;\r\nif (WARN_ON(d->count == d->children)) {\r\n*err = -EINVAL;\r\nreturn WALK_PRED_ABORT;\r\n}\r\npred->index &= ~FILTER_PRED_FOLD;\r\nroot->ops[d->count++] = pred->index;\r\nreturn WALK_PRED_DEFAULT;\r\n}\r\nstatic int fold_pred(struct filter_pred *preds, struct filter_pred *root)\r\n{\r\nstruct fold_pred_data data = {\r\n.root = root,\r\n.count = 0,\r\n};\r\nint children;\r\nroot->index &= ~FILTER_PRED_FOLD;\r\nif (root->left == FILTER_PRED_INVALID)\r\nreturn 0;\r\nchildren = count_leafs(preds, &preds[root->left]);\r\nchildren += count_leafs(preds, &preds[root->right]);\r\nroot->ops = kcalloc(children, sizeof(*root->ops), GFP_KERNEL);\r\nif (!root->ops)\r\nreturn -ENOMEM;\r\nroot->val = children;\r\ndata.children = children;\r\nreturn walk_pred_tree(preds, root, fold_pred_cb, &data);\r\n}\r\nstatic int fold_pred_tree_cb(enum move_type move, struct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nstruct filter_pred *preds = data;\r\nif (move != MOVE_DOWN)\r\nreturn WALK_PRED_DEFAULT;\r\nif (!(pred->index & FILTER_PRED_FOLD))\r\nreturn WALK_PRED_DEFAULT;\r\n*err = fold_pred(preds, pred);\r\nif (*err)\r\nreturn WALK_PRED_ABORT;\r\nreturn WALK_PRED_PARENT;\r\n}\r\nstatic int fold_pred_tree(struct event_filter *filter,\r\nstruct filter_pred *root)\r\n{\r\nreturn walk_pred_tree(filter->preds, root, fold_pred_tree_cb,\r\nfilter->preds);\r\n}\r\nstatic int replace_preds(struct trace_event_call *call,\r\nstruct event_filter *filter,\r\nstruct filter_parse_state *ps,\r\nbool dry_run)\r\n{\r\nchar *operand1 = NULL, *operand2 = NULL;\r\nstruct filter_pred *pred;\r\nstruct filter_pred *root;\r\nstruct postfix_elt *elt;\r\nstruct pred_stack stack = { };\r\nint err;\r\nint n_preds = 0;\r\nn_preds = count_preds(ps);\r\nif (n_preds >= MAX_FILTER_PRED) {\r\nparse_error(ps, FILT_ERR_TOO_MANY_PREDS, 0);\r\nreturn -ENOSPC;\r\n}\r\nerr = check_preds(ps);\r\nif (err)\r\nreturn err;\r\nif (!dry_run) {\r\nerr = __alloc_pred_stack(&stack, n_preds);\r\nif (err)\r\nreturn err;\r\nerr = __alloc_preds(filter, n_preds);\r\nif (err)\r\ngoto fail;\r\n}\r\nn_preds = 0;\r\nlist_for_each_entry(elt, &ps->postfix, list) {\r\nif (elt->op == OP_NONE) {\r\nif (!operand1)\r\noperand1 = elt->operand;\r\nelse if (!operand2)\r\noperand2 = elt->operand;\r\nelse {\r\nparse_error(ps, FILT_ERR_TOO_MANY_OPERANDS, 0);\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\ncontinue;\r\n}\r\nif (elt->op == OP_NOT) {\r\nif (!n_preds || operand1 || operand2) {\r\nparse_error(ps, FILT_ERR_ILLEGAL_NOT_OP, 0);\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nif (!dry_run)\r\nfilter->preds[n_preds - 1].not ^= 1;\r\ncontinue;\r\n}\r\nif (WARN_ON(n_preds++ == MAX_FILTER_PRED)) {\r\nparse_error(ps, FILT_ERR_TOO_MANY_PREDS, 0);\r\nerr = -ENOSPC;\r\ngoto fail;\r\n}\r\npred = create_pred(ps, call, elt->op, operand1, operand2);\r\nif (!pred) {\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nif (!dry_run) {\r\nerr = filter_add_pred(ps, filter, pred, &stack);\r\nif (err)\r\ngoto fail;\r\n}\r\noperand1 = operand2 = NULL;\r\n}\r\nif (!dry_run) {\r\npred = __pop_pred_stack(&stack);\r\nif (!pred)\r\nreturn -EINVAL;\r\nroot = pred;\r\npred = __pop_pred_stack(&stack);\r\nif (WARN_ON(pred)) {\r\nerr = -EINVAL;\r\nfilter->root = NULL;\r\ngoto fail;\r\n}\r\nerr = check_pred_tree(filter, root);\r\nif (err)\r\ngoto fail;\r\nerr = fold_pred_tree(filter, root);\r\nif (err)\r\ngoto fail;\r\nbarrier();\r\nfilter->root = root;\r\n}\r\nerr = 0;\r\nfail:\r\n__free_pred_stack(&stack);\r\nreturn err;\r\n}\r\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\r\n{\r\nunsigned long old_flags = file->flags;\r\nfile->flags |= EVENT_FILE_FL_FILTERED;\r\nif (old_flags != file->flags)\r\ntrace_buffered_event_enable();\r\n}\r\nstatic inline void event_set_filter(struct trace_event_file *file,\r\nstruct event_filter *filter)\r\n{\r\nrcu_assign_pointer(file->filter, filter);\r\n}\r\nstatic inline void event_clear_filter(struct trace_event_file *file)\r\n{\r\nRCU_INIT_POINTER(file->filter, NULL);\r\n}\r\nstatic inline void\r\nevent_set_no_set_filter_flag(struct trace_event_file *file)\r\n{\r\nfile->flags |= EVENT_FILE_FL_NO_SET_FILTER;\r\n}\r\nstatic inline void\r\nevent_clear_no_set_filter_flag(struct trace_event_file *file)\r\n{\r\nfile->flags &= ~EVENT_FILE_FL_NO_SET_FILTER;\r\n}\r\nstatic inline bool\r\nevent_no_set_filter_flag(struct trace_event_file *file)\r\n{\r\nif (file->flags & EVENT_FILE_FL_NO_SET_FILTER)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int replace_system_preds(struct trace_subsystem_dir *dir,\r\nstruct trace_array *tr,\r\nstruct filter_parse_state *ps,\r\nchar *filter_string)\r\n{\r\nstruct trace_event_file *file;\r\nstruct filter_list *filter_item;\r\nstruct filter_list *tmp;\r\nLIST_HEAD(filter_list);\r\nbool fail = true;\r\nint err;\r\nlist_for_each_entry(file, &tr->events, list) {\r\nif (file->system != dir)\r\ncontinue;\r\nerr = replace_preds(file->event_call, NULL, ps, true);\r\nif (err)\r\nevent_set_no_set_filter_flag(file);\r\nelse\r\nevent_clear_no_set_filter_flag(file);\r\n}\r\nlist_for_each_entry(file, &tr->events, list) {\r\nstruct event_filter *filter;\r\nif (file->system != dir)\r\ncontinue;\r\nif (event_no_set_filter_flag(file))\r\ncontinue;\r\nfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\r\nif (!filter_item)\r\ngoto fail_mem;\r\nlist_add_tail(&filter_item->list, &filter_list);\r\nfilter_item->filter = __alloc_filter();\r\nif (!filter_item->filter)\r\ngoto fail_mem;\r\nfilter = filter_item->filter;\r\nerr = replace_filter_string(filter, filter_string);\r\nif (err)\r\ngoto fail_mem;\r\nerr = replace_preds(file->event_call, filter, ps, false);\r\nif (err) {\r\nfilter_disable(file);\r\nparse_error(ps, FILT_ERR_BAD_SUBSYS_FILTER, 0);\r\nappend_filter_err(ps, filter);\r\n} else\r\nevent_set_filtered_flag(file);\r\nfilter = event_filter(file);\r\nevent_set_filter(file, filter_item->filter);\r\nfilter_item->filter = filter;\r\nfail = false;\r\n}\r\nif (fail)\r\ngoto fail;\r\nsynchronize_sched();\r\nlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\r\n__free_filter(filter_item->filter);\r\nlist_del(&filter_item->list);\r\nkfree(filter_item);\r\n}\r\nreturn 0;\r\nfail:\r\nlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\r\nlist_del(&filter_item->list);\r\nkfree(filter_item);\r\n}\r\nparse_error(ps, FILT_ERR_BAD_SUBSYS_FILTER, 0);\r\nreturn -EINVAL;\r\nfail_mem:\r\nif (!fail)\r\nsynchronize_sched();\r\nlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\r\n__free_filter(filter_item->filter);\r\nlist_del(&filter_item->list);\r\nkfree(filter_item);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int create_filter_start(char *filter_str, bool set_str,\r\nstruct filter_parse_state **psp,\r\nstruct event_filter **filterp)\r\n{\r\nstruct event_filter *filter;\r\nstruct filter_parse_state *ps = NULL;\r\nint err = 0;\r\nWARN_ON_ONCE(*psp || *filterp);\r\nfilter = __alloc_filter();\r\nif (filter && set_str)\r\nerr = replace_filter_string(filter, filter_str);\r\nps = kzalloc(sizeof(*ps), GFP_KERNEL);\r\nif (!filter || !ps || err) {\r\nkfree(ps);\r\n__free_filter(filter);\r\nreturn -ENOMEM;\r\n}\r\n*filterp = filter;\r\n*psp = ps;\r\nparse_init(ps, filter_ops, filter_str);\r\nerr = filter_parse(ps);\r\nif (err && set_str)\r\nappend_filter_err(ps, filter);\r\nreturn err;\r\n}\r\nstatic void create_filter_finish(struct filter_parse_state *ps)\r\n{\r\nif (ps) {\r\nfilter_opstack_clear(ps);\r\npostfix_clear(ps);\r\nkfree(ps);\r\n}\r\n}\r\nstatic int create_filter(struct trace_event_call *call,\r\nchar *filter_str, bool set_str,\r\nstruct event_filter **filterp)\r\n{\r\nstruct event_filter *filter = NULL;\r\nstruct filter_parse_state *ps = NULL;\r\nint err;\r\nerr = create_filter_start(filter_str, set_str, &ps, &filter);\r\nif (!err) {\r\nerr = replace_preds(call, filter, ps, false);\r\nif (err && set_str)\r\nappend_filter_err(ps, filter);\r\n}\r\ncreate_filter_finish(ps);\r\n*filterp = filter;\r\nreturn err;\r\n}\r\nint create_event_filter(struct trace_event_call *call,\r\nchar *filter_str, bool set_str,\r\nstruct event_filter **filterp)\r\n{\r\nreturn create_filter(call, filter_str, set_str, filterp);\r\n}\r\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\r\nstruct trace_array *tr,\r\nchar *filter_str, struct event_filter **filterp)\r\n{\r\nstruct event_filter *filter = NULL;\r\nstruct filter_parse_state *ps = NULL;\r\nint err;\r\nerr = create_filter_start(filter_str, true, &ps, &filter);\r\nif (!err) {\r\nerr = replace_system_preds(dir, tr, ps, filter_str);\r\nif (!err) {\r\nkfree(filter->filter_string);\r\nfilter->filter_string = NULL;\r\n} else {\r\nappend_filter_err(ps, filter);\r\n}\r\n}\r\ncreate_filter_finish(ps);\r\n*filterp = filter;\r\nreturn err;\r\n}\r\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\r\n{\r\nstruct trace_event_call *call = file->event_call;\r\nstruct event_filter *filter;\r\nint err;\r\nif (!strcmp(strstrip(filter_string), "0")) {\r\nfilter_disable(file);\r\nfilter = event_filter(file);\r\nif (!filter)\r\nreturn 0;\r\nevent_clear_filter(file);\r\nsynchronize_sched();\r\n__free_filter(filter);\r\nreturn 0;\r\n}\r\nerr = create_filter(call, filter_string, true, &filter);\r\nif (filter) {\r\nstruct event_filter *tmp;\r\ntmp = event_filter(file);\r\nif (!err)\r\nevent_set_filtered_flag(file);\r\nelse\r\nfilter_disable(file);\r\nevent_set_filter(file, filter);\r\nif (tmp) {\r\nsynchronize_sched();\r\n__free_filter(tmp);\r\n}\r\n}\r\nreturn err;\r\n}\r\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\r\nchar *filter_string)\r\n{\r\nstruct event_subsystem *system = dir->subsystem;\r\nstruct trace_array *tr = dir->tr;\r\nstruct event_filter *filter;\r\nint err = 0;\r\nmutex_lock(&event_mutex);\r\nif (!dir->nr_events) {\r\nerr = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nif (!strcmp(strstrip(filter_string), "0")) {\r\nfilter_free_subsystem_preds(dir, tr);\r\nremove_filter_string(system->filter);\r\nfilter = system->filter;\r\nsystem->filter = NULL;\r\nsynchronize_sched();\r\nfilter_free_subsystem_filters(dir, tr);\r\n__free_filter(filter);\r\ngoto out_unlock;\r\n}\r\nerr = create_system_filter(dir, tr, filter_string, &filter);\r\nif (filter) {\r\n__free_filter(system->filter);\r\nsystem->filter = filter;\r\n}\r\nout_unlock:\r\nmutex_unlock(&event_mutex);\r\nreturn err;\r\n}\r\nvoid ftrace_profile_free_filter(struct perf_event *event)\r\n{\r\nstruct event_filter *filter = event->filter;\r\nevent->filter = NULL;\r\n__free_filter(filter);\r\n}\r\nstatic char **\r\nftrace_function_filter_re(char *buf, int len, int *count)\r\n{\r\nchar *str, **re;\r\nstr = kstrndup(buf, len, GFP_KERNEL);\r\nif (!str)\r\nreturn NULL;\r\nstrreplace(str, ',', ' ');\r\nre = argv_split(GFP_KERNEL, str, count);\r\nkfree(str);\r\nreturn re;\r\n}\r\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\r\nint reset, char *re, int len)\r\n{\r\nint ret;\r\nif (filter)\r\nret = ftrace_set_filter(ops, re, len, reset);\r\nelse\r\nret = ftrace_set_notrace(ops, re, len, reset);\r\nreturn ret;\r\n}\r\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\r\nstruct function_filter_data *data)\r\n{\r\nint i, re_cnt, ret = -EINVAL;\r\nint *reset;\r\nchar **re;\r\nreset = filter ? &data->first_filter : &data->first_notrace;\r\nre = ftrace_function_filter_re(buf, len, &re_cnt);\r\nif (!re)\r\nreturn -EINVAL;\r\nfor (i = 0; i < re_cnt; i++) {\r\nret = ftrace_function_set_regexp(data->ops, filter, *reset,\r\nre[i], strlen(re[i]));\r\nif (ret)\r\nbreak;\r\nif (*reset)\r\n*reset = 0;\r\n}\r\nargv_free(re);\r\nreturn ret;\r\n}\r\nstatic int ftrace_function_check_pred(struct filter_pred *pred, int leaf)\r\n{\r\nstruct ftrace_event_field *field = pred->field;\r\nif (leaf) {\r\nif ((pred->op != OP_EQ) && (pred->op != OP_NE))\r\nreturn -EINVAL;\r\nif (strcmp(field->name, "ip"))\r\nreturn -EINVAL;\r\n} else {\r\nif (pred->op != OP_OR)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ftrace_function_set_filter_cb(enum move_type move,\r\nstruct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nif ((move != MOVE_DOWN) ||\r\n(pred->left != FILTER_PRED_INVALID)) {\r\n*err = ftrace_function_check_pred(pred, 0);\r\n} else {\r\n*err = ftrace_function_check_pred(pred, 1);\r\nif (*err)\r\nreturn WALK_PRED_ABORT;\r\n*err = __ftrace_function_set_filter(pred->op == OP_EQ,\r\npred->regex.pattern,\r\npred->regex.len,\r\ndata);\r\n}\r\nreturn (*err) ? WALK_PRED_ABORT : WALK_PRED_DEFAULT;\r\n}\r\nstatic int ftrace_function_set_filter(struct perf_event *event,\r\nstruct event_filter *filter)\r\n{\r\nstruct function_filter_data data = {\r\n.first_filter = 1,\r\n.first_notrace = 1,\r\n.ops = &event->ftrace_ops,\r\n};\r\nreturn walk_pred_tree(filter->preds, filter->root,\r\nftrace_function_set_filter_cb, &data);\r\n}\r\nstatic int ftrace_function_set_filter(struct perf_event *event,\r\nstruct event_filter *filter)\r\n{\r\nreturn -ENODEV;\r\n}\r\nint ftrace_profile_set_filter(struct perf_event *event, int event_id,\r\nchar *filter_str)\r\n{\r\nint err;\r\nstruct event_filter *filter;\r\nstruct trace_event_call *call;\r\nmutex_lock(&event_mutex);\r\ncall = event->tp_event;\r\nerr = -EINVAL;\r\nif (!call)\r\ngoto out_unlock;\r\nerr = -EEXIST;\r\nif (event->filter)\r\ngoto out_unlock;\r\nerr = create_filter(call, filter_str, false, &filter);\r\nif (err)\r\ngoto free_filter;\r\nif (ftrace_event_is_function(call))\r\nerr = ftrace_function_set_filter(event, filter);\r\nelse\r\nevent->filter = filter;\r\nfree_filter:\r\nif (err || ftrace_event_is_function(call))\r\n__free_filter(filter);\r\nout_unlock:\r\nmutex_unlock(&event_mutex);\r\nreturn err;\r\n}\r\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\r\n{\r\nstruct ftrace_event_field *field = pred->field;\r\ntest_pred_visited = 1;\r\nprintk(KERN_INFO "\npred visited %s\n", field->name);\r\nreturn 1;\r\n}\r\nstatic int test_walk_pred_cb(enum move_type move, struct filter_pred *pred,\r\nint *err, void *data)\r\n{\r\nchar *fields = data;\r\nif ((move == MOVE_DOWN) &&\r\n(pred->left == FILTER_PRED_INVALID)) {\r\nstruct ftrace_event_field *field = pred->field;\r\nif (!field) {\r\nWARN(1, "all leafs should have field defined");\r\nreturn WALK_PRED_DEFAULT;\r\n}\r\nif (!strchr(fields, *field->name))\r\nreturn WALK_PRED_DEFAULT;\r\nWARN_ON(!pred->fn);\r\npred->fn = test_pred_visited_fn;\r\n}\r\nreturn WALK_PRED_DEFAULT;\r\n}\r\nstatic __init int ftrace_test_event_filter(void)\r\n{\r\nint i;\r\nprintk(KERN_INFO "Testing ftrace filter: ");\r\nfor (i = 0; i < DATA_CNT; i++) {\r\nstruct event_filter *filter = NULL;\r\nstruct test_filter_data_t *d = &test_filter_data[i];\r\nint err;\r\nerr = create_filter(&event_ftrace_test_filter, d->filter,\r\nfalse, &filter);\r\nif (err) {\r\nprintk(KERN_INFO\r\n"Failed to get filter for '%s', err %d\n",\r\nd->filter, err);\r\n__free_filter(filter);\r\nbreak;\r\n}\r\npreempt_disable();\r\nif (*d->not_visited)\r\nwalk_pred_tree(filter->preds, filter->root,\r\ntest_walk_pred_cb,\r\nd->not_visited);\r\ntest_pred_visited = 0;\r\nerr = filter_match_preds(filter, &d->rec);\r\npreempt_enable();\r\n__free_filter(filter);\r\nif (test_pred_visited) {\r\nprintk(KERN_INFO\r\n"Failed, unwanted pred visited for filter %s\n",\r\nd->filter);\r\nbreak;\r\n}\r\nif (err != d->match) {\r\nprintk(KERN_INFO\r\n"Failed to match filter '%s', expected %d\n",\r\nd->filter, d->match);\r\nbreak;\r\n}\r\n}\r\nif (i == DATA_CNT)\r\nprintk(KERN_CONT "OK\n");\r\nreturn 0;\r\n}
