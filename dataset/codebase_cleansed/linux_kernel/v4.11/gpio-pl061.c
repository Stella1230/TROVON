static int pl061_get_direction(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nreturn !(readb(pl061->base + GPIODIR) & BIT(offset));\r\n}\r\nstatic int pl061_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nspin_lock_irqsave(&pl061->lock, flags);\r\ngpiodir = readb(pl061->base + GPIODIR);\r\ngpiodir &= ~(BIT(offset));\r\nwriteb(gpiodir, pl061->base + GPIODIR);\r\nspin_unlock_irqrestore(&pl061->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nspin_lock_irqsave(&pl061->lock, flags);\r\nwriteb(!!value << offset, pl061->base + (BIT(offset + 2)));\r\ngpiodir = readb(pl061->base + GPIODIR);\r\ngpiodir |= BIT(offset);\r\nwriteb(gpiodir, pl061->base + GPIODIR);\r\nwriteb(!!value << offset, pl061->base + (BIT(offset + 2)));\r\nspin_unlock_irqrestore(&pl061->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nreturn !!readb(pl061->base + (BIT(offset + 2)));\r\n}\r\nstatic void pl061_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nwriteb(!!value << offset, pl061->base + (BIT(offset + 2)));\r\n}\r\nstatic int pl061_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nint offset = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nu8 gpiois, gpioibe, gpioiev;\r\nu8 bit = BIT(offset);\r\nif (offset < 0 || offset >= PL061_GPIO_NR)\r\nreturn -EINVAL;\r\nif ((trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) &&\r\n(trigger & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)))\r\n{\r\ndev_err(gc->parent,\r\n"trying to configure line %d for both level and edge "\r\n"detection, choose one!\n",\r\noffset);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pl061->lock, flags);\r\ngpioiev = readb(pl061->base + GPIOIEV);\r\ngpiois = readb(pl061->base + GPIOIS);\r\ngpioibe = readb(pl061->base + GPIOIBE);\r\nif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\nbool polarity = trigger & IRQ_TYPE_LEVEL_HIGH;\r\ngpioibe &= ~bit;\r\ngpiois |= bit;\r\nif (polarity)\r\ngpioiev |= bit;\r\nelse\r\ngpioiev &= ~bit;\r\nirq_set_handler_locked(d, handle_level_irq);\r\ndev_dbg(gc->parent, "line %d: IRQ on %s level\n",\r\noffset,\r\npolarity ? "HIGH" : "LOW");\r\n} else if ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\ngpiois &= ~bit;\r\ngpioibe |= bit;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\ndev_dbg(gc->parent, "line %d: IRQ on both edges\n", offset);\r\n} else if ((trigger & IRQ_TYPE_EDGE_RISING) ||\r\n(trigger & IRQ_TYPE_EDGE_FALLING)) {\r\nbool rising = trigger & IRQ_TYPE_EDGE_RISING;\r\ngpiois &= ~bit;\r\ngpioibe &= ~bit;\r\nif (rising)\r\ngpioiev |= bit;\r\nelse\r\ngpioiev &= ~bit;\r\nirq_set_handler_locked(d, handle_edge_irq);\r\ndev_dbg(gc->parent, "line %d: IRQ on %s edge\n",\r\noffset,\r\nrising ? "RISING" : "FALLING");\r\n} else {\r\ngpiois &= ~bit;\r\ngpioibe &= ~bit;\r\ngpioiev &= ~bit;\r\nirq_set_handler_locked(d, handle_bad_irq);\r\ndev_warn(gc->parent, "no trigger selected for line %d\n",\r\noffset);\r\n}\r\nwriteb(gpiois, pl061->base + GPIOIS);\r\nwriteb(gpioibe, pl061->base + GPIOIBE);\r\nwriteb(gpioiev, pl061->base + GPIOIEV);\r\nspin_unlock_irqrestore(&pl061->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pl061_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned long pending;\r\nint offset;\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nchained_irq_enter(irqchip, desc);\r\npending = readb(pl061->base + GPIOMIS);\r\nif (pending) {\r\nfor_each_set_bit(offset, &pending, PL061_GPIO_NR)\r\ngeneric_handle_irq(irq_find_mapping(gc->irqdomain,\r\noffset));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic void pl061_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nu8 gpioie;\r\nspin_lock(&pl061->lock);\r\ngpioie = readb(pl061->base + GPIOIE) & ~mask;\r\nwriteb(gpioie, pl061->base + GPIOIE);\r\nspin_unlock(&pl061->lock);\r\n}\r\nstatic void pl061_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nu8 gpioie;\r\nspin_lock(&pl061->lock);\r\ngpioie = readb(pl061->base + GPIOIE) | mask;\r\nwriteb(gpioie, pl061->base + GPIOIE);\r\nspin_unlock(&pl061->lock);\r\n}\r\nstatic void pl061_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nu8 mask = BIT(irqd_to_hwirq(d) % PL061_GPIO_NR);\r\nspin_lock(&pl061->lock);\r\nwriteb(mask, pl061->base + GPIOIC);\r\nspin_unlock(&pl061->lock);\r\n}\r\nstatic int pl061_irq_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061 *pl061 = gpiochip_get_data(gc);\r\nreturn irq_set_irq_wake(pl061->parent_irq, state);\r\n}\r\nstatic int pl061_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nstruct device *dev = &adev->dev;\r\nstruct pl061 *pl061;\r\nint ret, irq;\r\npl061 = devm_kzalloc(dev, sizeof(*pl061), GFP_KERNEL);\r\nif (pl061 == NULL)\r\nreturn -ENOMEM;\r\npl061->base = devm_ioremap_resource(dev, &adev->res);\r\nif (IS_ERR(pl061->base))\r\nreturn PTR_ERR(pl061->base);\r\nspin_lock_init(&pl061->lock);\r\nif (of_property_read_bool(dev->of_node, "gpio-ranges")) {\r\npl061->gc.request = gpiochip_generic_request;\r\npl061->gc.free = gpiochip_generic_free;\r\n}\r\npl061->gc.base = -1;\r\npl061->gc.get_direction = pl061_get_direction;\r\npl061->gc.direction_input = pl061_direction_input;\r\npl061->gc.direction_output = pl061_direction_output;\r\npl061->gc.get = pl061_get_value;\r\npl061->gc.set = pl061_set_value;\r\npl061->gc.ngpio = PL061_GPIO_NR;\r\npl061->gc.label = dev_name(dev);\r\npl061->gc.parent = dev;\r\npl061->gc.owner = THIS_MODULE;\r\nret = gpiochip_add_data(&pl061->gc, pl061);\r\nif (ret)\r\nreturn ret;\r\nwriteb(0, pl061->base + GPIOIE);\r\nirq = adev->irq[0];\r\nif (irq < 0) {\r\ndev_err(&adev->dev, "invalid IRQ\n");\r\nreturn -ENODEV;\r\n}\r\npl061->parent_irq = irq;\r\nret = gpiochip_irqchip_add(&pl061->gc, &pl061_irqchip,\r\n0, handle_bad_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_info(&adev->dev, "could not add irqchip\n");\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&pl061->gc, &pl061_irqchip,\r\nirq, pl061_irq_handler);\r\namba_set_drvdata(adev, pl061);\r\ndev_info(&adev->dev, "PL061 GPIO chip @%pa registered\n",\r\n&adev->res.start);\r\nreturn 0;\r\n}\r\nstatic int pl061_suspend(struct device *dev)\r\n{\r\nstruct pl061 *pl061 = dev_get_drvdata(dev);\r\nint offset;\r\npl061->csave_regs.gpio_data = 0;\r\npl061->csave_regs.gpio_dir = readb(pl061->base + GPIODIR);\r\npl061->csave_regs.gpio_is = readb(pl061->base + GPIOIS);\r\npl061->csave_regs.gpio_ibe = readb(pl061->base + GPIOIBE);\r\npl061->csave_regs.gpio_iev = readb(pl061->base + GPIOIEV);\r\npl061->csave_regs.gpio_ie = readb(pl061->base + GPIOIE);\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (pl061->csave_regs.gpio_dir & (BIT(offset)))\r\npl061->csave_regs.gpio_data |=\r\npl061_get_value(&pl061->gc, offset) << offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl061_resume(struct device *dev)\r\n{\r\nstruct pl061 *pl061 = dev_get_drvdata(dev);\r\nint offset;\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (pl061->csave_regs.gpio_dir & (BIT(offset)))\r\npl061_direction_output(&pl061->gc, offset,\r\npl061->csave_regs.gpio_data &\r\n(BIT(offset)));\r\nelse\r\npl061_direction_input(&pl061->gc, offset);\r\n}\r\nwriteb(pl061->csave_regs.gpio_is, pl061->base + GPIOIS);\r\nwriteb(pl061->csave_regs.gpio_ibe, pl061->base + GPIOIBE);\r\nwriteb(pl061->csave_regs.gpio_iev, pl061->base + GPIOIEV);\r\nwriteb(pl061->csave_regs.gpio_ie, pl061->base + GPIOIE);\r\nreturn 0;\r\n}\r\nstatic int __init pl061_gpio_init(void)\r\n{\r\nreturn amba_driver_register(&pl061_gpio_driver);\r\n}
