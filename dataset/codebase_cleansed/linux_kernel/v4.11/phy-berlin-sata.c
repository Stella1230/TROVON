static inline void phy_berlin_sata_reg_setbits(void __iomem *ctrl_reg,\r\nu32 phy_base, u32 reg, u32 mask, u32 val)\r\n{\r\nu32 regval;\r\nwritel(phy_base + reg, ctrl_reg + PORT_VSR_ADDR);\r\nregval = readl(ctrl_reg + PORT_VSR_DATA);\r\nregval &= ~mask;\r\nregval |= val;\r\nwritel(regval, ctrl_reg + PORT_VSR_DATA);\r\n}\r\nstatic int phy_berlin_sata_power_on(struct phy *phy)\r\n{\r\nstruct phy_berlin_desc *desc = phy_get_drvdata(phy);\r\nstruct phy_berlin_priv *priv = dev_get_drvdata(phy->dev.parent);\r\nvoid __iomem *ctrl_reg = priv->base + 0x60 + (desc->index * 0x80);\r\nu32 regval;\r\nclk_prepare_enable(priv->clk);\r\nspin_lock(&priv->lock);\r\nwritel(CONTROL_REGISTER, priv->base + HOST_VSA_ADDR);\r\nregval = readl(priv->base + HOST_VSA_DATA);\r\nregval &= ~desc->power_bit;\r\nwritel(regval, priv->base + HOST_VSA_DATA);\r\nwritel(MBUS_SIZE_CONTROL, priv->base + HOST_VSA_ADDR);\r\nregval = readl(priv->base + HOST_VSA_DATA);\r\nregval |= MBUS_WRITE_REQUEST_SIZE_128 | MBUS_READ_REQUEST_SIZE_128;\r\nwritel(regval, priv->base + HOST_VSA_DATA);\r\nphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x01,\r\n0x00ff, REF_FREF_SEL_25 | PHY_MODE_SATA);\r\nphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x25,\r\n0x0c00, PHY_GEN_MAX_6_0);\r\nphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x23,\r\n0x0c00, DATA_BIT_WIDTH_40);\r\nphy_berlin_sata_reg_setbits(ctrl_reg, priv->phy_base, 0x02,\r\n0x0000, USE_MAX_PLL_RATE);\r\nregval = readl(ctrl_reg + PORT_SCR_CTL);\r\nregval &= ~GENMASK(7, 4);\r\nregval |= 0x30;\r\nwritel(regval, ctrl_reg + PORT_SCR_CTL);\r\nspin_unlock(&priv->lock);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int phy_berlin_sata_power_off(struct phy *phy)\r\n{\r\nstruct phy_berlin_desc *desc = phy_get_drvdata(phy);\r\nstruct phy_berlin_priv *priv = dev_get_drvdata(phy->dev.parent);\r\nu32 regval;\r\nclk_prepare_enable(priv->clk);\r\nspin_lock(&priv->lock);\r\nwritel(CONTROL_REGISTER, priv->base + HOST_VSA_ADDR);\r\nregval = readl(priv->base + HOST_VSA_DATA);\r\nregval |= desc->power_bit;\r\nwritel(regval, priv->base + HOST_VSA_DATA);\r\nspin_unlock(&priv->lock);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic struct phy *phy_berlin_sata_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct phy_berlin_priv *priv = dev_get_drvdata(dev);\r\nint i;\r\nif (WARN_ON(args->args[0] >= priv->nphys))\r\nreturn ERR_PTR(-ENODEV);\r\nfor (i = 0; i < priv->nphys; i++) {\r\nif (priv->phys[i]->index == args->args[0])\r\nbreak;\r\n}\r\nif (i == priv->nphys)\r\nreturn ERR_PTR(-ENODEV);\r\nreturn priv->phys[i]->phy;\r\n}\r\nstatic int phy_berlin_sata_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *child;\r\nstruct phy *phy;\r\nstruct phy_provider *phy_provider;\r\nstruct phy_berlin_priv *priv;\r\nstruct resource *res;\r\nint ret, i = 0;\r\nu32 phy_id;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\npriv->base = devm_ioremap(dev, res->start, resource_size(res));\r\nif (!priv->base)\r\nreturn -ENOMEM;\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk))\r\nreturn PTR_ERR(priv->clk);\r\npriv->nphys = of_get_child_count(dev->of_node);\r\nif (priv->nphys == 0)\r\nreturn -ENODEV;\r\npriv->phys = devm_kcalloc(dev, priv->nphys, sizeof(*priv->phys),\r\nGFP_KERNEL);\r\nif (!priv->phys)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(dev->of_node, "marvell,berlin2-sata-phy"))\r\npriv->phy_base = BG2_PHY_BASE;\r\nelse\r\npriv->phy_base = BG2Q_PHY_BASE;\r\ndev_set_drvdata(dev, priv);\r\nspin_lock_init(&priv->lock);\r\nfor_each_available_child_of_node(dev->of_node, child) {\r\nstruct phy_berlin_desc *phy_desc;\r\nif (of_property_read_u32(child, "reg", &phy_id)) {\r\ndev_err(dev, "missing reg property in node %s\n",\r\nchild->name);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nif (phy_id >= ARRAY_SIZE(phy_berlin_power_down_bits)) {\r\ndev_err(dev, "invalid reg in node %s\n", child->name);\r\nret = -EINVAL;\r\ngoto put_child;\r\n}\r\nphy_desc = devm_kzalloc(dev, sizeof(*phy_desc), GFP_KERNEL);\r\nif (!phy_desc) {\r\nret = -ENOMEM;\r\ngoto put_child;\r\n}\r\nphy = devm_phy_create(dev, NULL, &phy_berlin_sata_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "failed to create PHY %d\n", phy_id);\r\nret = PTR_ERR(phy);\r\ngoto put_child;\r\n}\r\nphy_desc->phy = phy;\r\nphy_desc->power_bit = phy_berlin_power_down_bits[phy_id];\r\nphy_desc->index = phy_id;\r\nphy_set_drvdata(phy, phy_desc);\r\npriv->phys[i++] = phy_desc;\r\nphy_berlin_sata_power_off(phy);\r\n}\r\nphy_provider =\r\ndevm_of_phy_provider_register(dev, phy_berlin_sata_phy_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\nput_child:\r\nof_node_put(child);\r\nreturn ret;\r\n}
