static int ab3100_get_chip_id(struct device *dev)\r\n{\r\nstruct ab3100 *ab3100 = dev_get_drvdata(dev->parent);\r\nreturn (int)ab3100->chip_id;\r\n}\r\nstatic int ab3100_set_register_interruptible(struct ab3100 *ab3100,\r\nu8 reg, u8 regval)\r\n{\r\nu8 regandval[2] = {reg, regval};\r\nint err;\r\nerr = mutex_lock_interruptible(&ab3100->access_mutex);\r\nif (err)\r\nreturn err;\r\nerr = i2c_master_send(ab3100->i2c_client, regandval, 2);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (write register): %d\n",\r\nerr);\r\n} else if (err != 2) {\r\ndev_err(ab3100->dev,\r\n"write error (write register)\n"\r\n" %d bytes transferred (expected 2)\n",\r\nerr);\r\nerr = -EIO;\r\n} else {\r\nerr = 0;\r\n}\r\nmutex_unlock(&ab3100->access_mutex);\r\nreturn err;\r\n}\r\nstatic int set_register_interruptible(struct device *dev,\r\nu8 bank, u8 reg, u8 value)\r\n{\r\nstruct ab3100 *ab3100 = dev_get_drvdata(dev->parent);\r\nreturn ab3100_set_register_interruptible(ab3100, reg, value);\r\n}\r\nstatic int ab3100_set_test_register_interruptible(struct ab3100 *ab3100,\r\nu8 reg, u8 regval)\r\n{\r\nu8 regandval[2] = {reg, regval};\r\nint err;\r\nerr = mutex_lock_interruptible(&ab3100->access_mutex);\r\nif (err)\r\nreturn err;\r\nerr = i2c_master_send(ab3100->testreg_client, regandval, 2);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (write test register): %d\n",\r\nerr);\r\n} else if (err != 2) {\r\ndev_err(ab3100->dev,\r\n"write error (write test register)\n"\r\n" %d bytes transferred (expected 2)\n",\r\nerr);\r\nerr = -EIO;\r\n} else {\r\nerr = 0;\r\n}\r\nmutex_unlock(&ab3100->access_mutex);\r\nreturn err;\r\n}\r\nstatic int ab3100_get_register_interruptible(struct ab3100 *ab3100,\r\nu8 reg, u8 *regval)\r\n{\r\nint err;\r\nerr = mutex_lock_interruptible(&ab3100->access_mutex);\r\nif (err)\r\nreturn err;\r\nerr = i2c_master_send(ab3100->i2c_client, &reg, 1);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (send register address): %d\n",\r\nerr);\r\ngoto get_reg_out_unlock;\r\n} else if (err != 1) {\r\ndev_err(ab3100->dev,\r\n"write error (send register address)\n"\r\n" %d bytes transferred (expected 1)\n",\r\nerr);\r\nerr = -EIO;\r\ngoto get_reg_out_unlock;\r\n} else {\r\nerr = 0;\r\n}\r\nerr = i2c_master_recv(ab3100->i2c_client, regval, 1);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (read register): %d\n",\r\nerr);\r\ngoto get_reg_out_unlock;\r\n} else if (err != 1) {\r\ndev_err(ab3100->dev,\r\n"write error (read register)\n"\r\n" %d bytes transferred (expected 1)\n",\r\nerr);\r\nerr = -EIO;\r\ngoto get_reg_out_unlock;\r\n} else {\r\nerr = 0;\r\n}\r\nget_reg_out_unlock:\r\nmutex_unlock(&ab3100->access_mutex);\r\nreturn err;\r\n}\r\nstatic int get_register_interruptible(struct device *dev, u8 bank, u8 reg,\r\nu8 *value)\r\n{\r\nstruct ab3100 *ab3100 = dev_get_drvdata(dev->parent);\r\nreturn ab3100_get_register_interruptible(ab3100, reg, value);\r\n}\r\nstatic int ab3100_get_register_page_interruptible(struct ab3100 *ab3100,\r\nu8 first_reg, u8 *regvals, u8 numregs)\r\n{\r\nint err;\r\nif (ab3100->chip_id == 0xa0 ||\r\nab3100->chip_id == 0xa1)\r\nreturn -EIO;\r\nerr = mutex_lock_interruptible(&ab3100->access_mutex);\r\nif (err)\r\nreturn err;\r\nerr = i2c_master_send(ab3100->i2c_client, &first_reg, 1);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (send first register address): %d\n",\r\nerr);\r\ngoto get_reg_page_out_unlock;\r\n} else if (err != 1) {\r\ndev_err(ab3100->dev,\r\n"write error (send first register address)\n"\r\n" %d bytes transferred (expected 1)\n",\r\nerr);\r\nerr = -EIO;\r\ngoto get_reg_page_out_unlock;\r\n}\r\nerr = i2c_master_recv(ab3100->i2c_client, regvals, numregs);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (read register page): %d\n",\r\nerr);\r\ngoto get_reg_page_out_unlock;\r\n} else if (err != numregs) {\r\ndev_err(ab3100->dev,\r\n"write error (read register page)\n"\r\n" %d bytes transferred (expected %d)\n",\r\nerr, numregs);\r\nerr = -EIO;\r\ngoto get_reg_page_out_unlock;\r\n}\r\nerr = 0;\r\nget_reg_page_out_unlock:\r\nmutex_unlock(&ab3100->access_mutex);\r\nreturn err;\r\n}\r\nstatic int get_register_page_interruptible(struct device *dev, u8 bank,\r\nu8 first_reg, u8 *regvals, u8 numregs)\r\n{\r\nstruct ab3100 *ab3100 = dev_get_drvdata(dev->parent);\r\nreturn ab3100_get_register_page_interruptible(ab3100,\r\nfirst_reg, regvals, numregs);\r\n}\r\nstatic int ab3100_mask_and_set_register_interruptible(struct ab3100 *ab3100,\r\nu8 reg, u8 andmask, u8 ormask)\r\n{\r\nu8 regandval[2] = {reg, 0};\r\nint err;\r\nerr = mutex_lock_interruptible(&ab3100->access_mutex);\r\nif (err)\r\nreturn err;\r\nerr = i2c_master_send(ab3100->i2c_client, &reg, 1);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (maskset send address): %d\n",\r\nerr);\r\ngoto get_maskset_unlock;\r\n} else if (err != 1) {\r\ndev_err(ab3100->dev,\r\n"write error (maskset send address)\n"\r\n" %d bytes transferred (expected 1)\n",\r\nerr);\r\nerr = -EIO;\r\ngoto get_maskset_unlock;\r\n}\r\nerr = i2c_master_recv(ab3100->i2c_client, &regandval[1], 1);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (maskset read register): %d\n",\r\nerr);\r\ngoto get_maskset_unlock;\r\n} else if (err != 1) {\r\ndev_err(ab3100->dev,\r\n"write error (maskset read register)\n"\r\n" %d bytes transferred (expected 1)\n",\r\nerr);\r\nerr = -EIO;\r\ngoto get_maskset_unlock;\r\n}\r\nregandval[1] &= andmask;\r\nregandval[1] |= ormask;\r\nerr = i2c_master_send(ab3100->i2c_client, regandval, 2);\r\nif (err < 0) {\r\ndev_err(ab3100->dev,\r\n"write error (write register): %d\n",\r\nerr);\r\ngoto get_maskset_unlock;\r\n} else if (err != 2) {\r\ndev_err(ab3100->dev,\r\n"write error (write register)\n"\r\n" %d bytes transferred (expected 2)\n",\r\nerr);\r\nerr = -EIO;\r\ngoto get_maskset_unlock;\r\n}\r\nerr = 0;\r\nget_maskset_unlock:\r\nmutex_unlock(&ab3100->access_mutex);\r\nreturn err;\r\n}\r\nstatic int mask_and_set_register_interruptible(struct device *dev, u8 bank,\r\nu8 reg, u8 bitmask, u8 bitvalues)\r\n{\r\nstruct ab3100 *ab3100 = dev_get_drvdata(dev->parent);\r\nreturn ab3100_mask_and_set_register_interruptible(ab3100,\r\nreg, bitmask, (bitmask & bitvalues));\r\n}\r\nint ab3100_event_register(struct ab3100 *ab3100,\r\nstruct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&ab3100->event_subscribers,\r\nnb);\r\n}\r\nint ab3100_event_unregister(struct ab3100 *ab3100,\r\nstruct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&ab3100->event_subscribers,\r\nnb);\r\n}\r\nstatic int ab3100_event_registers_startup_state_get(struct device *dev,\r\nu8 *event)\r\n{\r\nstruct ab3100 *ab3100 = dev_get_drvdata(dev->parent);\r\nif (!ab3100->startup_events_read)\r\nreturn -EAGAIN;\r\nmemcpy(event, ab3100->startup_events, 3);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ab3100_irq_handler(int irq, void *data)\r\n{\r\nstruct ab3100 *ab3100 = data;\r\nu8 event_regs[3];\r\nu32 fatevent;\r\nint err;\r\nerr = ab3100_get_register_page_interruptible(ab3100, AB3100_EVENTA1,\r\nevent_regs, 3);\r\nif (err)\r\ngoto err_event;\r\nfatevent = (event_regs[0] << 16) |\r\n(event_regs[1] << 8) |\r\nevent_regs[2];\r\nif (!ab3100->startup_events_read) {\r\nab3100->startup_events[0] = event_regs[0];\r\nab3100->startup_events[1] = event_regs[1];\r\nab3100->startup_events[2] = event_regs[2];\r\nab3100->startup_events_read = true;\r\n}\r\nblocking_notifier_call_chain(&ab3100->event_subscribers,\r\nfatevent, NULL);\r\ndev_dbg(ab3100->dev,\r\n"IRQ Event: 0x%08x\n", fatevent);\r\nreturn IRQ_HANDLED;\r\nerr_event:\r\ndev_dbg(ab3100->dev,\r\n"error reading event status\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ab3100_registers_print(struct seq_file *s, void *p)\r\n{\r\nstruct ab3100 *ab3100 = s->private;\r\nu8 value;\r\nu8 reg;\r\nseq_puts(s, "AB3100 registers:\n");\r\nfor (reg = 0; reg < 0xff; reg++) {\r\nab3100_get_register_interruptible(ab3100, reg, &value);\r\nseq_printf(s, "[0x%x]: 0x%x\n", reg, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab3100_registers_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ab3100_registers_print, inode->i_private);\r\n}\r\nstatic ssize_t ab3100_get_set_reg(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ab3100_get_set_reg_priv *priv = file->private_data;\r\nstruct ab3100 *ab3100 = priv->ab3100;\r\nchar buf[32];\r\nssize_t buf_size;\r\nint regp;\r\nu8 user_reg;\r\nint err;\r\nint i = 0;\r\nbuf_size = min(count, (sizeof(buf)-1));\r\nif (copy_from_user(buf, user_buf, buf_size))\r\nreturn -EFAULT;\r\nbuf[buf_size] = 0;\r\nwhile ((i < buf_size) && (buf[i] == ' '))\r\ni++;\r\nregp = i;\r\nwhile ((i < buf_size) && (buf[i] != ' '))\r\ni++;\r\nbuf[i] = '\0';\r\nerr = kstrtou8(&buf[regp], 16, &user_reg);\r\nif (err)\r\nreturn err;\r\nif (!priv->mode) {\r\nu8 regvalue;\r\nab3100_get_register_interruptible(ab3100, user_reg, &regvalue);\r\ndev_info(ab3100->dev,\r\n"debug read AB3100 reg[0x%02x]: 0x%02x\n",\r\nuser_reg, regvalue);\r\n} else {\r\nint valp;\r\nu8 user_value;\r\nu8 regvalue;\r\ni++;\r\nwhile ((i < buf_size) && (buf[i] == ' '))\r\ni++;\r\nvalp = i;\r\nwhile ((i < buf_size) && (buf[i] != ' '))\r\ni++;\r\nbuf[i] = '\0';\r\nerr = kstrtou8(&buf[valp], 16, &user_value);\r\nif (err)\r\nreturn err;\r\nab3100_set_register_interruptible(ab3100, user_reg, user_value);\r\nab3100_get_register_interruptible(ab3100, user_reg, &regvalue);\r\ndev_info(ab3100->dev,\r\n"debug write reg[0x%02x]\n"\r\n" with 0x%02x, after readback: 0x%02x\n",\r\nuser_reg, user_value, regvalue);\r\n}\r\nreturn buf_size;\r\n}\r\nstatic void ab3100_setup_debugfs(struct ab3100 *ab3100)\r\n{\r\nint err;\r\nab3100_dir = debugfs_create_dir("ab3100", NULL);\r\nif (!ab3100_dir)\r\ngoto exit_no_debugfs;\r\nab3100_reg_file = debugfs_create_file("registers",\r\nS_IRUGO, ab3100_dir, ab3100,\r\n&ab3100_registers_fops);\r\nif (!ab3100_reg_file) {\r\nerr = -ENOMEM;\r\ngoto exit_destroy_dir;\r\n}\r\nab3100_get_priv.ab3100 = ab3100;\r\nab3100_get_priv.mode = false;\r\nab3100_get_reg_file = debugfs_create_file("get_reg",\r\nS_IWUSR, ab3100_dir, &ab3100_get_priv,\r\n&ab3100_get_set_reg_fops);\r\nif (!ab3100_get_reg_file) {\r\nerr = -ENOMEM;\r\ngoto exit_destroy_reg;\r\n}\r\nab3100_set_priv.ab3100 = ab3100;\r\nab3100_set_priv.mode = true;\r\nab3100_set_reg_file = debugfs_create_file("set_reg",\r\nS_IWUSR, ab3100_dir, &ab3100_set_priv,\r\n&ab3100_get_set_reg_fops);\r\nif (!ab3100_set_reg_file) {\r\nerr = -ENOMEM;\r\ngoto exit_destroy_get_reg;\r\n}\r\nreturn;\r\nexit_destroy_get_reg:\r\ndebugfs_remove(ab3100_get_reg_file);\r\nexit_destroy_reg:\r\ndebugfs_remove(ab3100_reg_file);\r\nexit_destroy_dir:\r\ndebugfs_remove(ab3100_dir);\r\nexit_no_debugfs:\r\nreturn;\r\n}\r\nstatic inline void ab3100_setup_debugfs(struct ab3100 *ab3100)\r\n{\r\n}\r\nstatic int ab3100_setup(struct ab3100 *ab3100)\r\n{\r\nint err = 0;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ab3100_init_settings); i++) {\r\nerr = ab3100_set_register_interruptible(ab3100,\r\nab3100_init_settings[i].abreg,\r\nab3100_init_settings[i].setting);\r\nif (err)\r\ngoto exit_no_setup;\r\n}\r\nif (ab3100->chip_id == 0xc4) {\r\ndev_warn(ab3100->dev,\r\n"AB3100 P1E variant detected forcing chip to 32KHz\n");\r\nerr = ab3100_set_test_register_interruptible(ab3100,\r\n0x02, 0x08);\r\n}\r\nexit_no_setup:\r\nreturn err;\r\n}\r\nstatic int ab3100_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ab3100 *ab3100;\r\nstruct ab3100_platform_data *ab3100_plf_data =\r\ndev_get_platdata(&client->dev);\r\nint err;\r\nint i;\r\nab3100 = devm_kzalloc(&client->dev, sizeof(struct ab3100), GFP_KERNEL);\r\nif (!ab3100)\r\nreturn -ENOMEM;\r\nmutex_init(&ab3100->access_mutex);\r\nBLOCKING_INIT_NOTIFIER_HEAD(&ab3100->event_subscribers);\r\nab3100->i2c_client = client;\r\nab3100->dev = &ab3100->i2c_client->dev;\r\ni2c_set_clientdata(client, ab3100);\r\nerr = ab3100_get_register_interruptible(ab3100, AB3100_CID,\r\n&ab3100->chip_id);\r\nif (err) {\r\ndev_err(&client->dev,\r\n"failed to communicate with AB3100 chip\n");\r\ngoto exit_no_detect;\r\n}\r\nfor (i = 0; ids[i].id != 0x0; i++) {\r\nif (ids[i].id == ab3100->chip_id) {\r\nif (ids[i].name)\r\nbreak;\r\ndev_err(&client->dev, "AB3000 is not supported\n");\r\ngoto exit_no_detect;\r\n}\r\n}\r\nsnprintf(&ab3100->chip_name[0],\r\nsizeof(ab3100->chip_name) - 1, "AB3100 %s", ids[i].name);\r\nif (ids[i].id == 0x0) {\r\ndev_err(&client->dev, "unknown analog baseband chip id: 0x%x\n",\r\nab3100->chip_id);\r\ndev_err(&client->dev,\r\n"accepting it anyway. Please update the driver.\n");\r\ngoto exit_no_detect;\r\n}\r\ndev_info(&client->dev, "Detected chip: %s\n",\r\n&ab3100->chip_name[0]);\r\nab3100->testreg_client = i2c_new_dummy(client->adapter,\r\nclient->addr + 1);\r\nif (!ab3100->testreg_client) {\r\nerr = -ENOMEM;\r\ngoto exit_no_testreg_client;\r\n}\r\nerr = ab3100_setup(ab3100);\r\nif (err)\r\ngoto exit_no_setup;\r\nerr = devm_request_threaded_irq(&client->dev,\r\nclient->irq, NULL, ab3100_irq_handler,\r\nIRQF_ONESHOT, "ab3100-core", ab3100);\r\nif (err)\r\ngoto exit_no_irq;\r\nerr = abx500_register_ops(&client->dev, &ab3100_ops);\r\nif (err)\r\ngoto exit_no_ops;\r\nfor (i = 0; i < ARRAY_SIZE(ab3100_devs); i++) {\r\nab3100_devs[i].platform_data = ab3100_plf_data;\r\nab3100_devs[i].pdata_size = sizeof(struct ab3100_platform_data);\r\n}\r\nerr = mfd_add_devices(&client->dev, 0, ab3100_devs,\r\nARRAY_SIZE(ab3100_devs), NULL, 0, NULL);\r\nab3100_setup_debugfs(ab3100);\r\nreturn 0;\r\nexit_no_ops:\r\nexit_no_irq:\r\nexit_no_setup:\r\ni2c_unregister_device(ab3100->testreg_client);\r\nexit_no_testreg_client:\r\nexit_no_detect:\r\nreturn err;\r\n}\r\nstatic int __init ab3100_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&ab3100_driver);\r\n}
