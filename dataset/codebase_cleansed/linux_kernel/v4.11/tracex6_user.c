static void test_bpf_perf_event(void)\r\n{\r\nint nr_cpus = sysconf(_SC_NPROCESSORS_CONF);\r\nint *pmu_fd = malloc(nr_cpus * sizeof(int));\r\nint status, i;\r\nstruct perf_event_attr attr_insn_pmu = {\r\n.freq = 0,\r\n.sample_period = SAMPLE_PERIOD,\r\n.inherit = 0,\r\n.type = PERF_TYPE_HARDWARE,\r\n.read_format = 0,\r\n.sample_type = 0,\r\n.config = 0,\r\n};\r\nfor (i = 0; i < nr_cpus; i++) {\r\npmu_fd[i] = sys_perf_event_open(&attr_insn_pmu, -1, i, -1, 0);\r\nif (pmu_fd[i] < 0) {\r\nprintf("event syscall failed\n");\r\ngoto exit;\r\n}\r\nbpf_map_update_elem(map_fd[0], &i, &pmu_fd[i], BPF_ANY);\r\nioctl(pmu_fd[i], PERF_EVENT_IOC_ENABLE, 0);\r\n}\r\nstatus = system("ls > /dev/null");\r\nif (status)\r\ngoto exit;\r\nstatus = system("sleep 2");\r\nif (status)\r\ngoto exit;\r\nexit:\r\nfor (i = 0; i < nr_cpus; i++)\r\nclose(pmu_fd[i]);\r\nclose(map_fd[0]);\r\nfree(pmu_fd);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nchar filename[256];\r\nsnprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);\r\nif (load_bpf_file(filename)) {\r\nprintf("%s", bpf_log_buf);\r\nreturn 1;\r\n}\r\ntest_bpf_perf_event();\r\nread_trace_pipe();\r\nreturn 0;\r\n}
