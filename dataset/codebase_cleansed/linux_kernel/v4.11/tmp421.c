static int temp_from_s16(s16 reg)\r\n{\r\nint temp = reg & ~0xf;\r\nreturn (temp * 1000 + 128) / 256;\r\n}\r\nstatic int temp_from_u16(u16 reg)\r\n{\r\nint temp = reg & ~0xf;\r\ntemp -= 64 * 256;\r\nreturn (temp * 1000 + 128) / 256;\r\n}\r\nstatic struct tmp421_data *tmp421_update_device(struct device *dev)\r\n{\r\nstruct tmp421_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + 2 * HZ) || !data->valid) {\r\ndata->config = i2c_smbus_read_byte_data(client,\r\nTMP421_CONFIG_REG_1);\r\nfor (i = 0; i < data->channels; i++) {\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\nTMP421_TEMP_MSB[i]) << 8;\r\ndata->temp[i] |= i2c_smbus_read_byte_data(client,\r\nTMP421_TEMP_LSB[i]);\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic int tmp421_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nstruct tmp421_data *tmp421 = tmp421_update_device(dev);\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nif (tmp421->config & TMP421_CONFIG_RANGE)\r\n*val = temp_from_u16(tmp421->temp[channel]);\r\nelse\r\n*val = temp_from_s16(tmp421->temp[channel]);\r\nreturn 0;\r\ncase hwmon_temp_fault:\r\n*val = tmp421->temp[channel] & 0x01;\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t tmp421_is_visible(const void *data, enum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nswitch (attr) {\r\ncase hwmon_temp_fault:\r\nif (channel == 0)\r\nreturn 0;\r\nreturn S_IRUGO;\r\ncase hwmon_temp_input:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int tmp421_init_client(struct i2c_client *client)\r\n{\r\nint config, config_orig;\r\ni2c_smbus_write_byte_data(client, TMP421_CONVERSION_RATE_REG, 0x05);\r\nconfig = i2c_smbus_read_byte_data(client, TMP421_CONFIG_REG_1);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Could not read configuration register (%d)\n", config);\r\nreturn config;\r\n}\r\nconfig_orig = config;\r\nconfig &= ~TMP421_CONFIG_SHUTDOWN;\r\nif (config != config_orig) {\r\ndev_info(&client->dev, "Enable monitoring chip\n");\r\ni2c_smbus_write_byte_data(client, TMP421_CONFIG_REG_1, config);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tmp421_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nenum chips kind;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nconst char * const names[] = { "TMP421", "TMP422", "TMP423",\r\n"TMP441", "TMP442" };\r\nint addr = client->addr;\r\nu8 reg;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP421_MANUFACTURER_ID_REG);\r\nif (reg != TMP421_MANUFACTURER_ID)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP421_CONVERSION_RATE_REG);\r\nif (reg & 0xf8)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP421_STATUS_REG);\r\nif (reg & 0x7f)\r\nreturn -ENODEV;\r\nreg = i2c_smbus_read_byte_data(client, TMP421_DEVICE_ID_REG);\r\nswitch (reg) {\r\ncase TMP421_DEVICE_ID:\r\nkind = tmp421;\r\nbreak;\r\ncase TMP422_DEVICE_ID:\r\nif (addr == 0x2a)\r\nreturn -ENODEV;\r\nkind = tmp422;\r\nbreak;\r\ncase TMP423_DEVICE_ID:\r\nif (addr != 0x4c && addr != 0x4d)\r\nreturn -ENODEV;\r\nkind = tmp423;\r\nbreak;\r\ncase TMP441_DEVICE_ID:\r\nkind = tmp441;\r\nbreak;\r\ncase TMP442_DEVICE_ID:\r\nif (addr != 0x4c && addr != 0x4d)\r\nreturn -ENODEV;\r\nkind = tmp442;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, tmp421_id[kind].name, I2C_NAME_SIZE);\r\ndev_info(&adapter->dev, "Detected TI %s chip at 0x%02x\n",\r\nnames[kind], client->addr);\r\nreturn 0;\r\n}\r\nstatic int tmp421_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct tmp421_data *data;\r\nint i, err;\r\ndata = devm_kzalloc(dev, sizeof(struct tmp421_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmutex_init(&data->update_lock);\r\ndata->channels = id->driver_data;\r\ndata->client = client;\r\nerr = tmp421_init_client(client);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < data->channels; i++)\r\ndata->temp_config[i] = HWMON_T_INPUT | HWMON_T_FAULT;\r\ndata->chip.ops = &tmp421_ops;\r\ndata->chip.info = data->info;\r\ndata->info[0] = &data->temp_info;\r\ndata->temp_info.type = hwmon_temp;\r\ndata->temp_info.config = data->temp_config;\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata,\r\n&data->chip,\r\nNULL);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
