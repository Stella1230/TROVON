static inline bool has_quirk_single_word_read(struct eeprom_93xx46_dev *edev)\r\n{\r\nreturn edev->pdata->quirks & EEPROM_93XX46_QUIRK_SINGLE_WORD_READ;\r\n}\r\nstatic inline bool has_quirk_instruction_length(struct eeprom_93xx46_dev *edev)\r\n{\r\nreturn edev->pdata->quirks & EEPROM_93XX46_QUIRK_INSTRUCTION_LENGTH;\r\n}\r\nstatic int eeprom_93xx46_read(void *priv, unsigned int off,\r\nvoid *val, size_t count)\r\n{\r\nstruct eeprom_93xx46_dev *edev = priv;\r\nchar *buf = val;\r\nint err = 0;\r\nif (unlikely(off >= edev->size))\r\nreturn 0;\r\nif ((off + count) > edev->size)\r\ncount = edev->size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nwhile (count) {\r\nstruct spi_message m;\r\nstruct spi_transfer t[2] = { { 0 } };\r\nu16 cmd_addr = OP_READ << edev->addrlen;\r\nsize_t nbytes = count;\r\nint bits;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= off & 0x7f;\r\nbits = 10;\r\nif (has_quirk_single_word_read(edev))\r\nnbytes = 1;\r\n} else {\r\ncmd_addr |= (off >> 1) & 0x3f;\r\nbits = 9;\r\nif (has_quirk_single_word_read(edev))\r\nnbytes = 2;\r\n}\r\ndev_dbg(&edev->spi->dev, "read cmd 0x%x, %d Hz\n",\r\ncmd_addr, edev->spi->max_speed_hz);\r\nspi_message_init(&m);\r\nt[0].tx_buf = (char *)&cmd_addr;\r\nt[0].len = 2;\r\nt[0].bits_per_word = bits;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = count;\r\nt[1].bits_per_word = 8;\r\nspi_message_add_tail(&t[1], &m);\r\nerr = spi_sync(edev->spi, &m);\r\nndelay(250);\r\nif (err) {\r\ndev_err(&edev->spi->dev, "read %zu bytes at %d: err. %d\n",\r\nnbytes, (int)off, err);\r\nbreak;\r\n}\r\nbuf += nbytes;\r\noff += nbytes;\r\ncount -= nbytes;\r\n}\r\nif (edev->pdata->finish)\r\nedev->pdata->finish(edev);\r\nmutex_unlock(&edev->lock);\r\nreturn err;\r\n}\r\nstatic int eeprom_93xx46_ew(struct eeprom_93xx46_dev *edev, int is_on)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nint bits, ret;\r\nu16 cmd_addr;\r\ncmd_addr = OP_START << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= (is_on ? ADDR_EWEN : ADDR_EWDS) << 1;\r\nbits = 10;\r\n} else {\r\ncmd_addr |= (is_on ? ADDR_EWEN : ADDR_EWDS);\r\nbits = 9;\r\n}\r\nif (has_quirk_instruction_length(edev)) {\r\ncmd_addr <<= 2;\r\nbits += 2;\r\n}\r\ndev_dbg(&edev->spi->dev, "ew%s cmd 0x%04x, %d bits\n",\r\nis_on ? "en" : "ds", cmd_addr, bits);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt.tx_buf = &cmd_addr;\r\nt.len = 2;\r\nt.bits_per_word = bits;\r\nspi_message_add_tail(&t, &m);\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nret = spi_sync(edev->spi, &m);\r\nndelay(250);\r\nif (ret)\r\ndev_err(&edev->spi->dev, "erase/write %sable error %d\n",\r\nis_on ? "en" : "dis", ret);\r\nif (edev->pdata->finish)\r\nedev->pdata->finish(edev);\r\nmutex_unlock(&edev->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\neeprom_93xx46_write_word(struct eeprom_93xx46_dev *edev,\r\nconst char *buf, unsigned off)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer t[2];\r\nint bits, data_len, ret;\r\nu16 cmd_addr;\r\ncmd_addr = OP_WRITE << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= off & 0x7f;\r\nbits = 10;\r\ndata_len = 1;\r\n} else {\r\ncmd_addr |= (off >> 1) & 0x3f;\r\nbits = 9;\r\ndata_len = 2;\r\n}\r\ndev_dbg(&edev->spi->dev, "write cmd 0x%x\n", cmd_addr);\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = (char *)&cmd_addr;\r\nt[0].len = 2;\r\nt[0].bits_per_word = bits;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nt[1].len = data_len;\r\nt[1].bits_per_word = 8;\r\nspi_message_add_tail(&t[1], &m);\r\nret = spi_sync(edev->spi, &m);\r\nmdelay(6);\r\nreturn ret;\r\n}\r\nstatic int eeprom_93xx46_write(void *priv, unsigned int off,\r\nvoid *val, size_t count)\r\n{\r\nstruct eeprom_93xx46_dev *edev = priv;\r\nchar *buf = val;\r\nint i, ret, step = 1;\r\nif (unlikely(off >= edev->size))\r\nreturn -EFBIG;\r\nif ((off + count) > edev->size)\r\ncount = edev->size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nif (edev->addrlen == 6) {\r\nstep = 2;\r\ncount &= ~1;\r\n}\r\nret = eeprom_93xx46_ew(edev, 1);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nfor (i = 0; i < count; i += step) {\r\nret = eeprom_93xx46_write_word(edev, &buf[i], off + i);\r\nif (ret) {\r\ndev_err(&edev->spi->dev, "write failed at %d: %d\n",\r\n(int)off + i, ret);\r\nbreak;\r\n}\r\n}\r\nif (edev->pdata->finish)\r\nedev->pdata->finish(edev);\r\nmutex_unlock(&edev->lock);\r\neeprom_93xx46_ew(edev, 0);\r\nreturn ret;\r\n}\r\nstatic int eeprom_93xx46_eral(struct eeprom_93xx46_dev *edev)\r\n{\r\nstruct eeprom_93xx46_platform_data *pd = edev->pdata;\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nint bits, ret;\r\nu16 cmd_addr;\r\ncmd_addr = OP_START << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= ADDR_ERAL << 1;\r\nbits = 10;\r\n} else {\r\ncmd_addr |= ADDR_ERAL;\r\nbits = 9;\r\n}\r\nif (has_quirk_instruction_length(edev)) {\r\ncmd_addr <<= 2;\r\nbits += 2;\r\n}\r\ndev_dbg(&edev->spi->dev, "eral cmd 0x%04x, %d bits\n", cmd_addr, bits);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt.tx_buf = &cmd_addr;\r\nt.len = 2;\r\nt.bits_per_word = bits;\r\nspi_message_add_tail(&t, &m);\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nret = spi_sync(edev->spi, &m);\r\nif (ret)\r\ndev_err(&edev->spi->dev, "erase error %d\n", ret);\r\nmdelay(6);\r\nif (pd->finish)\r\npd->finish(edev);\r\nmutex_unlock(&edev->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t eeprom_93xx46_store_erase(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct eeprom_93xx46_dev *edev = dev_get_drvdata(dev);\r\nint erase = 0, ret;\r\nsscanf(buf, "%d", &erase);\r\nif (erase) {\r\nret = eeprom_93xx46_ew(edev, 1);\r\nif (ret)\r\nreturn ret;\r\nret = eeprom_93xx46_eral(edev);\r\nif (ret)\r\nreturn ret;\r\nret = eeprom_93xx46_ew(edev, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic void select_assert(void *context)\r\n{\r\nstruct eeprom_93xx46_dev *edev = context;\r\ngpiod_set_value_cansleep(edev->pdata->select, 1);\r\n}\r\nstatic void select_deassert(void *context)\r\n{\r\nstruct eeprom_93xx46_dev *edev = context;\r\ngpiod_set_value_cansleep(edev->pdata->select, 0);\r\n}\r\nstatic int eeprom_93xx46_probe_dt(struct spi_device *spi)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(eeprom_93xx46_of_table, &spi->dev);\r\nstruct device_node *np = spi->dev.of_node;\r\nstruct eeprom_93xx46_platform_data *pd;\r\nu32 tmp;\r\nint gpio;\r\nenum of_gpio_flags of_flags;\r\nint ret;\r\npd = devm_kzalloc(&spi->dev, sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\nret = of_property_read_u32(np, "data-size", &tmp);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "data-size property not found\n");\r\nreturn ret;\r\n}\r\nif (tmp == 8) {\r\npd->flags |= EE_ADDR8;\r\n} else if (tmp == 16) {\r\npd->flags |= EE_ADDR16;\r\n} else {\r\ndev_err(&spi->dev, "invalid data-size (%d)\n", tmp);\r\nreturn -EINVAL;\r\n}\r\nif (of_property_read_bool(np, "read-only"))\r\npd->flags |= EE_READONLY;\r\ngpio = of_get_named_gpio_flags(np, "select-gpios", 0, &of_flags);\r\nif (gpio_is_valid(gpio)) {\r\nunsigned long flags =\r\nof_flags == OF_GPIO_ACTIVE_LOW ? GPIOF_ACTIVE_LOW : 0;\r\nret = devm_gpio_request_one(&spi->dev, gpio, flags,\r\n"eeprom_93xx46_select");\r\nif (ret)\r\nreturn ret;\r\npd->select = gpio_to_desc(gpio);\r\npd->prepare = select_assert;\r\npd->finish = select_deassert;\r\ngpiod_direction_output(pd->select, 0);\r\n}\r\nif (of_id->data) {\r\nconst struct eeprom_93xx46_devtype_data *data = of_id->data;\r\npd->quirks = data->quirks;\r\n}\r\nspi->dev.platform_data = pd;\r\nreturn 0;\r\n}\r\nstatic int eeprom_93xx46_probe(struct spi_device *spi)\r\n{\r\nstruct eeprom_93xx46_platform_data *pd;\r\nstruct eeprom_93xx46_dev *edev;\r\nint err;\r\nif (spi->dev.of_node) {\r\nerr = eeprom_93xx46_probe_dt(spi);\r\nif (err < 0)\r\nreturn err;\r\n}\r\npd = spi->dev.platform_data;\r\nif (!pd) {\r\ndev_err(&spi->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev)\r\nreturn -ENOMEM;\r\nif (pd->flags & EE_ADDR8)\r\nedev->addrlen = 7;\r\nelse if (pd->flags & EE_ADDR16)\r\nedev->addrlen = 6;\r\nelse {\r\ndev_err(&spi->dev, "unspecified address type\n");\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nmutex_init(&edev->lock);\r\nedev->spi = spi;\r\nedev->pdata = pd;\r\nedev->size = 128;\r\nedev->nvmem_config.name = dev_name(&spi->dev);\r\nedev->nvmem_config.dev = &spi->dev;\r\nedev->nvmem_config.read_only = pd->flags & EE_READONLY;\r\nedev->nvmem_config.root_only = true;\r\nedev->nvmem_config.owner = THIS_MODULE;\r\nedev->nvmem_config.compat = true;\r\nedev->nvmem_config.base_dev = &spi->dev;\r\nedev->nvmem_config.reg_read = eeprom_93xx46_read;\r\nedev->nvmem_config.reg_write = eeprom_93xx46_write;\r\nedev->nvmem_config.priv = edev;\r\nedev->nvmem_config.stride = 4;\r\nedev->nvmem_config.word_size = 1;\r\nedev->nvmem_config.size = edev->size;\r\nedev->nvmem = nvmem_register(&edev->nvmem_config);\r\nif (IS_ERR(edev->nvmem)) {\r\nerr = PTR_ERR(edev->nvmem);\r\ngoto fail;\r\n}\r\ndev_info(&spi->dev, "%d-bit eeprom %s\n",\r\n(pd->flags & EE_ADDR8) ? 8 : 16,\r\n(pd->flags & EE_READONLY) ? "(readonly)" : "");\r\nif (!(pd->flags & EE_READONLY)) {\r\nif (device_create_file(&spi->dev, &dev_attr_erase))\r\ndev_err(&spi->dev, "can't create erase interface\n");\r\n}\r\nspi_set_drvdata(spi, edev);\r\nreturn 0;\r\nfail:\r\nkfree(edev);\r\nreturn err;\r\n}\r\nstatic int eeprom_93xx46_remove(struct spi_device *spi)\r\n{\r\nstruct eeprom_93xx46_dev *edev = spi_get_drvdata(spi);\r\nnvmem_unregister(edev->nvmem);\r\nif (!(edev->pdata->flags & EE_READONLY))\r\ndevice_remove_file(&spi->dev, &dev_attr_erase);\r\nkfree(edev);\r\nreturn 0;\r\n}
