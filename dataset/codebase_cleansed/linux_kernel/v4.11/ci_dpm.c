static struct ci_power_info *ci_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic struct ci_ps *ci_get_ps(struct radeon_ps *rps)\r\n{\r\nstruct ci_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstatic void ci_initialize_powertune_defaults(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nswitch (rdev->pdev->device) {\r\ncase 0x6649:\r\ncase 0x6650:\r\ncase 0x6651:\r\ncase 0x6658:\r\ncase 0x665C:\r\ncase 0x665D:\r\ndefault:\r\npi->powertune_defaults = &defaults_bonaire_xt;\r\nbreak;\r\ncase 0x6640:\r\ncase 0x6641:\r\ncase 0x6646:\r\ncase 0x6647:\r\npi->powertune_defaults = &defaults_saturn_xt;\r\nbreak;\r\ncase 0x67B8:\r\ncase 0x67B0:\r\npi->powertune_defaults = &defaults_hawaii_xt;\r\nbreak;\r\ncase 0x67BA:\r\ncase 0x67B1:\r\npi->powertune_defaults = &defaults_hawaii_pro;\r\nbreak;\r\ncase 0x67A0:\r\ncase 0x67A1:\r\ncase 0x67A2:\r\ncase 0x67A8:\r\ncase 0x67A9:\r\ncase 0x67AA:\r\ncase 0x67B9:\r\ncase 0x67BE:\r\npi->powertune_defaults = &defaults_bonaire_xt;\r\nbreak;\r\n}\r\npi->dte_tj_offset = 0;\r\npi->caps_power_containment = true;\r\npi->caps_cac = false;\r\npi->caps_sq_ramping = false;\r\npi->caps_db_ramping = false;\r\npi->caps_td_ramping = false;\r\npi->caps_tcp_ramping = false;\r\nif (pi->caps_power_containment) {\r\npi->caps_cac = true;\r\nif (rdev->family == CHIP_HAWAII)\r\npi->enable_bapm_feature = false;\r\nelse\r\npi->enable_bapm_feature = true;\r\npi->enable_tdc_limit_feature = true;\r\npi->enable_pkg_pwr_tracking_feature = true;\r\n}\r\n}\r\nstatic u8 ci_convert_to_vid(u16 vddc)\r\n{\r\nreturn (6200 - (vddc * VOLTAGE_SCALE)) / 25;\r\n}\r\nstatic int ci_populate_bapm_vddc_vid_sidd(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu8 *hi_vid = pi->smc_powertune_table.BapmVddCVidHiSidd;\r\nu8 *lo_vid = pi->smc_powertune_table.BapmVddCVidLoSidd;\r\nu8 *hi2_vid = pi->smc_powertune_table.BapmVddCVidHiSidd2;\r\nu32 i;\r\nif (rdev->pm.dpm.dyn_state.cac_leakage_table.entries == NULL)\r\nreturn -EINVAL;\r\nif (rdev->pm.dpm.dyn_state.cac_leakage_table.count > 8)\r\nreturn -EINVAL;\r\nif (rdev->pm.dpm.dyn_state.cac_leakage_table.count !=\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count)\r\nreturn -EINVAL;\r\nfor (i = 0; i < rdev->pm.dpm.dyn_state.cac_leakage_table.count; i++) {\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\r\nlo_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc1);\r\nhi_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc2);\r\nhi2_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc3);\r\n} else {\r\nlo_vid[i] = ci_convert_to_vid(rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc);\r\nhi_vid[i] = ci_convert_to_vid((u16)rdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].leakage);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_populate_vddc_vid(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu8 *vid = pi->smc_powertune_table.VddCVid;\r\nu32 i;\r\nif (pi->vddc_voltage_table.count > 8)\r\nreturn -EINVAL;\r\nfor (i = 0; i < pi->vddc_voltage_table.count; i++)\r\nvid[i] = ci_convert_to_vid(pi->vddc_voltage_table.entries[i].value);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_svi_load_line(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\npi->smc_powertune_table.SviLoadLineEn = pt_defaults->svi_load_line_en;\r\npi->smc_powertune_table.SviLoadLineVddC = pt_defaults->svi_load_line_vddc;\r\npi->smc_powertune_table.SviLoadLineTrimVddC = 3;\r\npi->smc_powertune_table.SviLoadLineOffsetVddC = 0;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_tdc_limit(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\nu16 tdc_limit;\r\ntdc_limit = rdev->pm.dpm.dyn_state.cac_tdp_table->tdc * 256;\r\npi->smc_powertune_table.TDC_VDDC_PkgLimit = cpu_to_be16(tdc_limit);\r\npi->smc_powertune_table.TDC_VDDC_ThrottleReleaseLimitPerc =\r\npt_defaults->tdc_vddc_throttle_release_limit_perc;\r\npi->smc_powertune_table.TDC_MAWt = pt_defaults->tdc_mawt;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_dw8(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\nint ret;\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, PmFuseTable) +\r\noffsetof(SMU7_Discrete_PmFuses, TdcWaterfallCtl),\r\n(u32 *)&pi->smc_powertune_table.TdcWaterfallCtl,\r\npi->sram_end);\r\nif (ret)\r\nreturn -EINVAL;\r\nelse\r\npi->smc_powertune_table.TdcWaterfallCtl = pt_defaults->tdc_waterfall_ctl;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_fuzzy_fan(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif ((rdev->pm.dpm.fan.fan_output_sensitivity & (1 << 15)) ||\r\n(rdev->pm.dpm.fan.fan_output_sensitivity == 0))\r\nrdev->pm.dpm.fan.fan_output_sensitivity =\r\nrdev->pm.dpm.fan.default_fan_output_sensitivity;\r\npi->smc_powertune_table.FuzzyFan_PwmSetDelta =\r\ncpu_to_be16(rdev->pm.dpm.fan.fan_output_sensitivity);\r\nreturn 0;\r\n}\r\nstatic int ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu8 *hi_vid = pi->smc_powertune_table.BapmVddCVidHiSidd;\r\nu8 *lo_vid = pi->smc_powertune_table.BapmVddCVidLoSidd;\r\nint i, min, max;\r\nmin = max = hi_vid[0];\r\nfor (i = 0; i < 8; i++) {\r\nif (0 != hi_vid[i]) {\r\nif (min > hi_vid[i])\r\nmin = hi_vid[i];\r\nif (max < hi_vid[i])\r\nmax = hi_vid[i];\r\n}\r\nif (0 != lo_vid[i]) {\r\nif (min > lo_vid[i])\r\nmin = lo_vid[i];\r\nif (max < lo_vid[i])\r\nmax = lo_vid[i];\r\n}\r\n}\r\nif ((min == 0) || (max == 0))\r\nreturn -EINVAL;\r\npi->smc_powertune_table.GnbLPMLMaxVid = (u8)max;\r\npi->smc_powertune_table.GnbLPMLMinVid = (u8)min;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_bapm_vddc_base_leakage_sidd(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu16 hi_sidd = pi->smc_powertune_table.BapmVddCBaseLeakageHiSidd;\r\nu16 lo_sidd = pi->smc_powertune_table.BapmVddCBaseLeakageLoSidd;\r\nstruct radeon_cac_tdp_table *cac_tdp_table =\r\nrdev->pm.dpm.dyn_state.cac_tdp_table;\r\nhi_sidd = cac_tdp_table->high_cac_leakage / 100 * 256;\r\nlo_sidd = cac_tdp_table->low_cac_leakage / 100 * 256;\r\npi->smc_powertune_table.BapmVddCBaseLeakageHiSidd = cpu_to_be16(hi_sidd);\r\npi->smc_powertune_table.BapmVddCBaseLeakageLoSidd = cpu_to_be16(lo_sidd);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_bapm_parameters_in_dpm_table(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nconst struct ci_pt_defaults *pt_defaults = pi->powertune_defaults;\r\nSMU7_Discrete_DpmTable *dpm_table = &pi->smc_state_table;\r\nstruct radeon_cac_tdp_table *cac_tdp_table =\r\nrdev->pm.dpm.dyn_state.cac_tdp_table;\r\nstruct radeon_ppm_table *ppm = rdev->pm.dpm.dyn_state.ppm_table;\r\nint i, j, k;\r\nconst u16 *def1;\r\nconst u16 *def2;\r\ndpm_table->DefaultTdp = cac_tdp_table->tdp * 256;\r\ndpm_table->TargetTdp = cac_tdp_table->configurable_tdp * 256;\r\ndpm_table->DTETjOffset = (u8)pi->dte_tj_offset;\r\ndpm_table->GpuTjMax =\r\n(u8)(pi->thermal_temp_setting.temperature_high / 1000);\r\ndpm_table->GpuTjHyst = 8;\r\ndpm_table->DTEAmbientTempBase = pt_defaults->dte_ambient_temp_base;\r\nif (ppm) {\r\ndpm_table->PPM_PkgPwrLimit = cpu_to_be16((u16)ppm->dgpu_tdp * 256 / 1000);\r\ndpm_table->PPM_TemperatureLimit = cpu_to_be16((u16)ppm->tj_max * 256);\r\n} else {\r\ndpm_table->PPM_PkgPwrLimit = cpu_to_be16(0);\r\ndpm_table->PPM_TemperatureLimit = cpu_to_be16(0);\r\n}\r\ndpm_table->BAPM_TEMP_GRADIENT = cpu_to_be32(pt_defaults->bapm_temp_gradient);\r\ndef1 = pt_defaults->bapmti_r;\r\ndef2 = pt_defaults->bapmti_rc;\r\nfor (i = 0; i < SMU7_DTE_ITERATIONS; i++) {\r\nfor (j = 0; j < SMU7_DTE_SOURCES; j++) {\r\nfor (k = 0; k < SMU7_DTE_SINKS; k++) {\r\ndpm_table->BAPMTI_R[i][j][k] = cpu_to_be16(*def1);\r\ndpm_table->BAPMTI_RC[i][j][k] = cpu_to_be16(*def2);\r\ndef1++;\r\ndef2++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_populate_pm_base(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 pm_fuse_table_offset;\r\nint ret;\r\nif (pi->caps_power_containment) {\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, PmFuseTable),\r\n&pm_fuse_table_offset, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_bapm_vddc_vid_sidd(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_vddc_vid(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_svi_load_line(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_tdc_limit(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_dw8(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_fuzzy_fan(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_min_max_v_gnbl_pm_lid_from_bapm_vddc(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_bapm_vddc_base_leakage_sidd(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_copy_bytes_to_smc(rdev, pm_fuse_table_offset,\r\n(u8 *)&pi->smc_powertune_table,\r\nsizeof(SMU7_Discrete_PmFuses), pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_do_enable_didt(struct radeon_device *rdev, const bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 data;\r\nif (pi->caps_sq_ramping) {\r\ndata = RREG32_DIDT(DIDT_SQ_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_SQ_CTRL0, data);\r\n}\r\nif (pi->caps_db_ramping) {\r\ndata = RREG32_DIDT(DIDT_DB_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_DB_CTRL0, data);\r\n}\r\nif (pi->caps_td_ramping) {\r\ndata = RREG32_DIDT(DIDT_TD_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_TD_CTRL0, data);\r\n}\r\nif (pi->caps_tcp_ramping) {\r\ndata = RREG32_DIDT(DIDT_TCP_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_TCP_CTRL0, data);\r\n}\r\n}\r\nstatic int ci_program_pt_config_registers(struct radeon_device *rdev,\r\nconst struct ci_pt_config_reg *cac_config_regs)\r\n{\r\nconst struct ci_pt_config_reg *config_regs = cac_config_regs;\r\nu32 data;\r\nu32 cache = 0;\r\nif (config_regs == NULL)\r\nreturn -EINVAL;\r\nwhile (config_regs->offset != 0xFFFFFFFF) {\r\nif (config_regs->type == CISLANDS_CONFIGREG_CACHE) {\r\ncache |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\n} else {\r\nswitch (config_regs->type) {\r\ncase CISLANDS_CONFIGREG_SMC_IND:\r\ndata = RREG32_SMC(config_regs->offset);\r\nbreak;\r\ncase CISLANDS_CONFIGREG_DIDT_IND:\r\ndata = RREG32_DIDT(config_regs->offset);\r\nbreak;\r\ndefault:\r\ndata = RREG32(config_regs->offset << 2);\r\nbreak;\r\n}\r\ndata &= ~config_regs->mask;\r\ndata |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\ndata |= cache;\r\nswitch (config_regs->type) {\r\ncase CISLANDS_CONFIGREG_SMC_IND:\r\nWREG32_SMC(config_regs->offset, data);\r\nbreak;\r\ncase CISLANDS_CONFIGREG_DIDT_IND:\r\nWREG32_DIDT(config_regs->offset, data);\r\nbreak;\r\ndefault:\r\nWREG32(config_regs->offset << 2, data);\r\nbreak;\r\n}\r\ncache = 0;\r\n}\r\nconfig_regs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_enable_didt(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret;\r\nif (pi->caps_sq_ramping || pi->caps_db_ramping ||\r\npi->caps_td_ramping || pi->caps_tcp_ramping) {\r\ncik_enter_rlc_safe_mode(rdev);\r\nif (enable) {\r\nret = ci_program_pt_config_registers(rdev, didt_config_ci);\r\nif (ret) {\r\ncik_exit_rlc_safe_mode(rdev);\r\nreturn ret;\r\n}\r\n}\r\nci_do_enable_didt(rdev, enable);\r\ncik_exit_rlc_safe_mode(rdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_enable_power_containment(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nint ret = 0;\r\nif (enable) {\r\npi->power_containment_features = 0;\r\nif (pi->caps_power_containment) {\r\nif (pi->enable_bapm_feature) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableDTE);\r\nif (smc_result != PPSMC_Result_OK)\r\nret = -EINVAL;\r\nelse\r\npi->power_containment_features |= POWERCONTAINMENT_FEATURE_BAPM;\r\n}\r\nif (pi->enable_tdc_limit_feature) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_TDCLimitEnable);\r\nif (smc_result != PPSMC_Result_OK)\r\nret = -EINVAL;\r\nelse\r\npi->power_containment_features |= POWERCONTAINMENT_FEATURE_TDCLimit;\r\n}\r\nif (pi->enable_pkg_pwr_tracking_feature) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_PkgPwrLimitEnable);\r\nif (smc_result != PPSMC_Result_OK) {\r\nret = -EINVAL;\r\n} else {\r\nstruct radeon_cac_tdp_table *cac_tdp_table =\r\nrdev->pm.dpm.dyn_state.cac_tdp_table;\r\nu32 default_pwr_limit =\r\n(u32)(cac_tdp_table->maximum_power_delivery_limit * 256);\r\npi->power_containment_features |= POWERCONTAINMENT_FEATURE_PkgPwrLimit;\r\nci_set_power_limit(rdev, default_pwr_limit);\r\n}\r\n}\r\n}\r\n} else {\r\nif (pi->caps_power_containment && pi->power_containment_features) {\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_TDCLimit)\r\nci_send_msg_to_smc(rdev, PPSMC_MSG_TDCLimitDisable);\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_BAPM)\r\nci_send_msg_to_smc(rdev, PPSMC_MSG_DisableDTE);\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_PkgPwrLimit)\r\nci_send_msg_to_smc(rdev, PPSMC_MSG_PkgPwrLimitDisable);\r\npi->power_containment_features = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_enable_smc_cac(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nint ret = 0;\r\nif (pi->caps_cac) {\r\nif (enable) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableCac);\r\nif (smc_result != PPSMC_Result_OK) {\r\nret = -EINVAL;\r\npi->cac_enabled = false;\r\n} else {\r\npi->cac_enabled = true;\r\n}\r\n} else if (pi->cac_enabled) {\r\nci_send_msg_to_smc(rdev, PPSMC_MSG_DisableCac);\r\npi->cac_enabled = false;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_enable_thermal_based_sclk_dpm(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result = PPSMC_Result_OK;\r\nif (pi->thermal_sclk_dpm_enabled) {\r\nif (enable)\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_ENABLE_THERMAL_DPM);\r\nelse\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_DISABLE_THERMAL_DPM);\r\n}\r\nif (smc_result == PPSMC_Result_OK)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_power_control_set_level(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_cac_tdp_table *cac_tdp_table =\r\nrdev->pm.dpm.dyn_state.cac_tdp_table;\r\ns32 adjust_percent;\r\ns32 target_tdp;\r\nint ret = 0;\r\nbool adjust_polarity = false;\r\nif (pi->caps_power_containment) {\r\nadjust_percent = adjust_polarity ?\r\nrdev->pm.dpm.tdp_adjustment : (-1 * rdev->pm.dpm.tdp_adjustment);\r\ntarget_tdp = ((100 + adjust_percent) *\r\n(s32)cac_tdp_table->configurable_tdp) / 100;\r\nret = ci_set_overdrive_target_tdp(rdev, (u32)target_tdp);\r\n}\r\nreturn ret;\r\n}\r\nvoid ci_dpm_powergate_uvd(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (pi->uvd_power_gated == gate)\r\nreturn;\r\npi->uvd_power_gated = gate;\r\nci_update_uvd_dpm(rdev, gate);\r\n}\r\nbool ci_dpm_vblank_too_short(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 vblank_time = r600_dpm_get_vblank_time(rdev);\r\nu32 switch_limit = pi->mem_gddr5 ? 450 : 300;\r\nif (vblank_time < switch_limit)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void ci_apply_state_adjust_rules(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct ci_ps *ps = ci_get_ps(rps);\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_clock_and_voltage_limits *max_limits;\r\nbool disable_mclk_switching;\r\nu32 sclk, mclk;\r\nint i;\r\nif (rps->vce_active) {\r\nrps->evclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].evclk;\r\nrps->ecclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].ecclk;\r\n} else {\r\nrps->evclk = 0;\r\nrps->ecclk = 0;\r\n}\r\nif ((rdev->pm.dpm.new_active_crtc_count > 1) ||\r\nci_dpm_vblank_too_short(rdev))\r\ndisable_mclk_switching = true;\r\nelse\r\ndisable_mclk_switching = false;\r\nif ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY)\r\npi->battery_state = true;\r\nelse\r\npi->battery_state = false;\r\nif (rdev->pm.dpm.ac_power)\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (rdev->pm.dpm.ac_power == false) {\r\nfor (i = 0; i < ps->performance_level_count; i++) {\r\nif (ps->performance_levels[i].mclk > max_limits->mclk)\r\nps->performance_levels[i].mclk = max_limits->mclk;\r\nif (ps->performance_levels[i].sclk > max_limits->sclk)\r\nps->performance_levels[i].sclk = max_limits->sclk;\r\n}\r\n}\r\nif (disable_mclk_switching) {\r\nmclk = ps->performance_levels[ps->performance_level_count - 1].mclk;\r\nsclk = ps->performance_levels[0].sclk;\r\n} else {\r\nmclk = ps->performance_levels[0].mclk;\r\nsclk = ps->performance_levels[0].sclk;\r\n}\r\nif (rps->vce_active) {\r\nif (sclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk)\r\nsclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk;\r\nif (mclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk)\r\nmclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].mclk;\r\n}\r\nps->performance_levels[0].sclk = sclk;\r\nps->performance_levels[0].mclk = mclk;\r\nif (ps->performance_levels[1].sclk < ps->performance_levels[0].sclk)\r\nps->performance_levels[1].sclk = ps->performance_levels[0].sclk;\r\nif (disable_mclk_switching) {\r\nif (ps->performance_levels[0].mclk < ps->performance_levels[1].mclk)\r\nps->performance_levels[0].mclk = ps->performance_levels[1].mclk;\r\n} else {\r\nif (ps->performance_levels[1].mclk < ps->performance_levels[0].mclk)\r\nps->performance_levels[1].mclk = ps->performance_levels[0].mclk;\r\n}\r\n}\r\nstatic int ci_thermal_set_temperature_range(struct radeon_device *rdev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nu32 tmp;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\ntmp = RREG32_SMC(CG_THERMAL_INT);\r\ntmp &= ~(CI_DIG_THERM_INTH_MASK | CI_DIG_THERM_INTL_MASK);\r\ntmp |= CI_DIG_THERM_INTH(high_temp / 1000) |\r\nCI_DIG_THERM_INTL(low_temp / 1000);\r\nWREG32_SMC(CG_THERMAL_INT, tmp);\r\n#if 0\r\ntmp = RREG32_SMC(CG_THERMAL_CTRL);\r\ntmp &= DIG_THERM_DPM_MASK;\r\ntmp |= DIG_THERM_DPM(high_temp / 1000);\r\nWREG32_SMC(CG_THERMAL_CTRL, tmp);\r\n#endif\r\nrdev->pm.dpm.thermal.min_temp = low_temp;\r\nrdev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nstatic int ci_thermal_enable_alert(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 thermal_int = RREG32_SMC(CG_THERMAL_INT);\r\nPPSMC_Result result;\r\nif (enable) {\r\nthermal_int &= ~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\r\nWREG32_SMC(CG_THERMAL_INT, thermal_int);\r\nrdev->irq.dpm_thermal = false;\r\nresult = ci_send_msg_to_smc(rdev, PPSMC_MSG_Thermal_Cntl_Enable);\r\nif (result != PPSMC_Result_OK) {\r\nDRM_DEBUG_KMS("Could not enable thermal interrupts.\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nthermal_int |= THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW;\r\nWREG32_SMC(CG_THERMAL_INT, thermal_int);\r\nrdev->irq.dpm_thermal = true;\r\nresult = ci_send_msg_to_smc(rdev, PPSMC_MSG_Thermal_Cntl_Disable);\r\nif (result != PPSMC_Result_OK) {\r\nDRM_DEBUG_KMS("Could not disable thermal interrupts.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_fan_ctrl_set_static_mode(struct radeon_device *rdev, u32 mode)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nif (pi->fan_ctrl_is_in_default_mode) {\r\ntmp = (RREG32_SMC(CG_FDO_CTRL2) & FDO_PWM_MODE_MASK) >> FDO_PWM_MODE_SHIFT;\r\npi->fan_ctrl_default_mode = tmp;\r\ntmp = (RREG32_SMC(CG_FDO_CTRL2) & TMIN_MASK) >> TMIN_SHIFT;\r\npi->t_min = tmp;\r\npi->fan_ctrl_is_in_default_mode = false;\r\n}\r\ntmp = RREG32_SMC(CG_FDO_CTRL2) & ~TMIN_MASK;\r\ntmp |= TMIN(0);\r\nWREG32_SMC(CG_FDO_CTRL2, tmp);\r\ntmp = RREG32_SMC(CG_FDO_CTRL2) & ~FDO_PWM_MODE_MASK;\r\ntmp |= FDO_PWM_MODE(mode);\r\nWREG32_SMC(CG_FDO_CTRL2, tmp);\r\n}\r\nstatic int ci_thermal_setup_fan_table(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nSMU7_Discrete_FanTable fan_table = { FDO_MODE_HARDWARE };\r\nu32 duty100;\r\nu32 t_diff1, t_diff2, pwm_diff1, pwm_diff2;\r\nu16 fdo_min, slope1, slope2;\r\nu32 reference_clock, tmp;\r\nint ret;\r\nu64 tmp64;\r\nif (!pi->fan_table_start) {\r\nrdev->pm.dpm.fan.ucode_fan_control = false;\r\nreturn 0;\r\n}\r\nduty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;\r\nif (duty100 == 0) {\r\nrdev->pm.dpm.fan.ucode_fan_control = false;\r\nreturn 0;\r\n}\r\ntmp64 = (u64)rdev->pm.dpm.fan.pwm_min * duty100;\r\ndo_div(tmp64, 10000);\r\nfdo_min = (u16)tmp64;\r\nt_diff1 = rdev->pm.dpm.fan.t_med - rdev->pm.dpm.fan.t_min;\r\nt_diff2 = rdev->pm.dpm.fan.t_high - rdev->pm.dpm.fan.t_med;\r\npwm_diff1 = rdev->pm.dpm.fan.pwm_med - rdev->pm.dpm.fan.pwm_min;\r\npwm_diff2 = rdev->pm.dpm.fan.pwm_high - rdev->pm.dpm.fan.pwm_med;\r\nslope1 = (u16)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\r\nslope2 = (u16)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\r\nfan_table.TempMin = cpu_to_be16((50 + rdev->pm.dpm.fan.t_min) / 100);\r\nfan_table.TempMed = cpu_to_be16((50 + rdev->pm.dpm.fan.t_med) / 100);\r\nfan_table.TempMax = cpu_to_be16((50 + rdev->pm.dpm.fan.t_max) / 100);\r\nfan_table.Slope1 = cpu_to_be16(slope1);\r\nfan_table.Slope2 = cpu_to_be16(slope2);\r\nfan_table.FdoMin = cpu_to_be16(fdo_min);\r\nfan_table.HystDown = cpu_to_be16(rdev->pm.dpm.fan.t_hyst);\r\nfan_table.HystUp = cpu_to_be16(1);\r\nfan_table.HystSlope = cpu_to_be16(1);\r\nfan_table.TempRespLim = cpu_to_be16(5);\r\nreference_clock = radeon_get_xclk(rdev);\r\nfan_table.RefreshPeriod = cpu_to_be32((rdev->pm.dpm.fan.cycle_delay *\r\nreference_clock) / 1600);\r\nfan_table.FdoMax = cpu_to_be16((u16)duty100);\r\ntmp = (RREG32_SMC(CG_MULT_THERMAL_CTRL) & TEMP_SEL_MASK) >> TEMP_SEL_SHIFT;\r\nfan_table.TempSrc = (uint8_t)tmp;\r\nret = ci_copy_bytes_to_smc(rdev,\r\npi->fan_table_start,\r\n(u8 *)(&fan_table),\r\nsizeof(fan_table),\r\npi->sram_end);\r\nif (ret) {\r\nDRM_ERROR("Failed to load fan table to the SMC.");\r\nrdev->pm.dpm.fan.ucode_fan_control = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_fan_ctrl_start_smc_fan_control(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result ret;\r\nif (pi->caps_od_fuzzy_fan_control_support) {\r\nret = ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_StartFanControl,\r\nFAN_CONTROL_FUZZY);\r\nif (ret != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nret = ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_SetFanPwmMax,\r\nrdev->pm.dpm.fan.default_max_fan_pwm);\r\nif (ret != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n} else {\r\nret = ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_StartFanControl,\r\nFAN_CONTROL_TABLE);\r\nif (ret != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\npi->fan_is_controlled_by_smc = true;\r\nreturn 0;\r\n}\r\nstatic int ci_fan_ctrl_stop_smc_fan_control(struct radeon_device *rdev)\r\n{\r\nPPSMC_Result ret;\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nret = ci_send_msg_to_smc(rdev, PPSMC_StopFanControl);\r\nif (ret == PPSMC_Result_OK) {\r\npi->fan_is_controlled_by_smc = false;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nint ci_fan_ctrl_get_fan_speed_percent(struct radeon_device *rdev,\r\nu32 *speed)\r\n{\r\nu32 duty, duty100;\r\nu64 tmp64;\r\nif (rdev->pm.no_fan)\r\nreturn -ENOENT;\r\nduty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;\r\nduty = (RREG32_SMC(CG_THERMAL_STATUS) & FDO_PWM_DUTY_MASK) >> FDO_PWM_DUTY_SHIFT;\r\nif (duty100 == 0)\r\nreturn -EINVAL;\r\ntmp64 = (u64)duty * 100;\r\ndo_div(tmp64, duty100);\r\n*speed = (u32)tmp64;\r\nif (*speed > 100)\r\n*speed = 100;\r\nreturn 0;\r\n}\r\nint ci_fan_ctrl_set_fan_speed_percent(struct radeon_device *rdev,\r\nu32 speed)\r\n{\r\nu32 tmp;\r\nu32 duty, duty100;\r\nu64 tmp64;\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (rdev->pm.no_fan)\r\nreturn -ENOENT;\r\nif (pi->fan_is_controlled_by_smc)\r\nreturn -EINVAL;\r\nif (speed > 100)\r\nreturn -EINVAL;\r\nduty100 = (RREG32_SMC(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;\r\nif (duty100 == 0)\r\nreturn -EINVAL;\r\ntmp64 = (u64)speed * duty100;\r\ndo_div(tmp64, 100);\r\nduty = (u32)tmp64;\r\ntmp = RREG32_SMC(CG_FDO_CTRL0) & ~FDO_STATIC_DUTY_MASK;\r\ntmp |= FDO_STATIC_DUTY(duty);\r\nWREG32_SMC(CG_FDO_CTRL0, tmp);\r\nreturn 0;\r\n}\r\nvoid ci_fan_ctrl_set_mode(struct radeon_device *rdev, u32 mode)\r\n{\r\nif (mode) {\r\nif (rdev->pm.dpm.fan.ucode_fan_control)\r\nci_fan_ctrl_stop_smc_fan_control(rdev);\r\nci_fan_ctrl_set_static_mode(rdev, mode);\r\n} else {\r\nif (rdev->pm.dpm.fan.ucode_fan_control)\r\nci_thermal_start_smc_fan_control(rdev);\r\nelse\r\nci_fan_ctrl_set_default_mode(rdev);\r\n}\r\n}\r\nu32 ci_fan_ctrl_get_mode(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nif (pi->fan_is_controlled_by_smc)\r\nreturn 0;\r\ntmp = RREG32_SMC(CG_FDO_CTRL2) & FDO_PWM_MODE_MASK;\r\nreturn (tmp >> FDO_PWM_MODE_SHIFT);\r\n}\r\nstatic void ci_fan_ctrl_set_default_mode(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nif (!pi->fan_ctrl_is_in_default_mode) {\r\ntmp = RREG32_SMC(CG_FDO_CTRL2) & ~FDO_PWM_MODE_MASK;\r\ntmp |= FDO_PWM_MODE(pi->fan_ctrl_default_mode);\r\nWREG32_SMC(CG_FDO_CTRL2, tmp);\r\ntmp = RREG32_SMC(CG_FDO_CTRL2) & ~TMIN_MASK;\r\ntmp |= TMIN(pi->t_min);\r\nWREG32_SMC(CG_FDO_CTRL2, tmp);\r\npi->fan_ctrl_is_in_default_mode = true;\r\n}\r\n}\r\nstatic void ci_thermal_start_smc_fan_control(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.dpm.fan.ucode_fan_control) {\r\nci_fan_ctrl_start_smc_fan_control(rdev);\r\nci_fan_ctrl_set_static_mode(rdev, FDO_PWM_MODE_STATIC);\r\n}\r\n}\r\nstatic void ci_thermal_initialize(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nif (rdev->pm.fan_pulses_per_revolution) {\r\ntmp = RREG32_SMC(CG_TACH_CTRL) & ~EDGE_PER_REV_MASK;\r\ntmp |= EDGE_PER_REV(rdev->pm.fan_pulses_per_revolution -1);\r\nWREG32_SMC(CG_TACH_CTRL, tmp);\r\n}\r\ntmp = RREG32_SMC(CG_FDO_CTRL2) & ~TACH_PWM_RESP_RATE_MASK;\r\ntmp |= TACH_PWM_RESP_RATE(0x28);\r\nWREG32_SMC(CG_FDO_CTRL2, tmp);\r\n}\r\nstatic int ci_thermal_start_thermal_controller(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nci_thermal_initialize(rdev);\r\nret = ci_thermal_set_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nret = ci_thermal_enable_alert(rdev, true);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->pm.dpm.fan.ucode_fan_control) {\r\nret = ci_thermal_setup_fan_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nci_thermal_start_smc_fan_control(rdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_thermal_stop_thermal_controller(struct radeon_device *rdev)\r\n{\r\nif (!rdev->pm.no_fan)\r\nci_fan_ctrl_set_default_mode(rdev);\r\n}\r\nstatic int ci_write_smc_soft_register(struct radeon_device *rdev,\r\nu16 reg_offset, u32 value)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nreturn ci_write_smc_sram_dword(rdev,\r\npi->soft_regs_start + reg_offset,\r\nvalue, pi->sram_end);\r\n}\r\nstatic void ci_init_fps_limits(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nSMU7_Discrete_DpmTable *table = &pi->smc_state_table;\r\nif (pi->caps_fps) {\r\nu16 tmp;\r\ntmp = 45;\r\ntable->FpsHighT = cpu_to_be16(tmp);\r\ntmp = 30;\r\ntable->FpsLowT = cpu_to_be16(tmp);\r\n}\r\n}\r\nstatic int ci_update_sclk_t(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret = 0;\r\nu32 low_sclk_interrupt_t = 0;\r\nif (pi->caps_sclk_throttle_low_notification) {\r\nlow_sclk_interrupt_t = cpu_to_be32(pi->low_sclk_interrupt_t);\r\nret = ci_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, LowSclkInterruptT),\r\n(u8 *)&low_sclk_interrupt_t,\r\nsizeof(u32), pi->sram_end);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ci_get_leakage_voltages(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu16 leakage_id, virtual_voltage_id;\r\nu16 vddc, vddci;\r\nint i;\r\npi->vddc_leakage.count = 0;\r\npi->vddci_leakage.count = 0;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\r\nfor (i = 0; i < CISLANDS_MAX_LEAKAGE_COUNT; i++) {\r\nvirtual_voltage_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;\r\nif (radeon_atom_get_voltage_evv(rdev, virtual_voltage_id, &vddc) != 0)\r\ncontinue;\r\nif (vddc != 0 && vddc != virtual_voltage_id) {\r\npi->vddc_leakage.actual_voltage[pi->vddc_leakage.count] = vddc;\r\npi->vddc_leakage.leakage_id[pi->vddc_leakage.count] = virtual_voltage_id;\r\npi->vddc_leakage.count++;\r\n}\r\n}\r\n} else if (radeon_atom_get_leakage_id_from_vbios(rdev, &leakage_id) == 0) {\r\nfor (i = 0; i < CISLANDS_MAX_LEAKAGE_COUNT; i++) {\r\nvirtual_voltage_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;\r\nif (radeon_atom_get_leakage_vddc_based_on_leakage_params(rdev, &vddc, &vddci,\r\nvirtual_voltage_id,\r\nleakage_id) == 0) {\r\nif (vddc != 0 && vddc != virtual_voltage_id) {\r\npi->vddc_leakage.actual_voltage[pi->vddc_leakage.count] = vddc;\r\npi->vddc_leakage.leakage_id[pi->vddc_leakage.count] = virtual_voltage_id;\r\npi->vddc_leakage.count++;\r\n}\r\nif (vddci != 0 && vddci != virtual_voltage_id) {\r\npi->vddci_leakage.actual_voltage[pi->vddci_leakage.count] = vddci;\r\npi->vddci_leakage.leakage_id[pi->vddci_leakage.count] = virtual_voltage_id;\r\npi->vddci_leakage.count++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void ci_set_dpm_event_sources(struct radeon_device *rdev, u32 sources)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nbool want_thermal_protection;\r\nenum radeon_dpm_event_src dpm_event_src;\r\nu32 tmp;\r\nswitch (sources) {\r\ncase 0:\r\ndefault:\r\nwant_thermal_protection = false;\r\nbreak;\r\ncase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_DIGITAL;\r\nbreak;\r\ncase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_EXTERNAL;\r\nbreak;\r\ncase ((1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\r\n(1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL)):\r\nwant_thermal_protection = true;\r\ndpm_event_src = RADEON_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\r\nbreak;\r\n}\r\nif (want_thermal_protection) {\r\n#if 0\r\ntmp = RREG32_SMC(CG_THERMAL_CTRL);\r\ntmp &= DPM_EVENT_SRC_MASK;\r\ntmp |= DPM_EVENT_SRC(dpm_event_src);\r\nWREG32_SMC(CG_THERMAL_CTRL, tmp);\r\n#endif\r\ntmp = RREG32_SMC(GENERAL_PWRMGT);\r\nif (pi->thermal_protection)\r\ntmp &= ~THERMAL_PROTECTION_DIS;\r\nelse\r\ntmp |= THERMAL_PROTECTION_DIS;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n} else {\r\ntmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp |= THERMAL_PROTECTION_DIS;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n}\r\n}\r\nstatic void ci_enable_auto_throttle_source(struct radeon_device *rdev,\r\nenum radeon_dpm_auto_throttle_src source,\r\nbool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (enable) {\r\nif (!(pi->active_auto_throttle_sources & (1 << source))) {\r\npi->active_auto_throttle_sources |= 1 << source;\r\nci_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\r\n}\r\n} else {\r\nif (pi->active_auto_throttle_sources & (1 << source)) {\r\npi->active_auto_throttle_sources &= ~(1 << source);\r\nci_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\r\n}\r\n}\r\n}\r\nstatic void ci_enable_vr_hot_gpio_interrupt(struct radeon_device *rdev)\r\n{\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)\r\nci_send_msg_to_smc(rdev, PPSMC_MSG_EnableVRHotGPIOInterrupt);\r\n}\r\nstatic int ci_unfreeze_sclk_mclk_dpm(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nif (!pi->need_update_smu7_dpm_table)\r\nreturn 0;\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK))) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_SCLKDPM_UnfreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_UnfreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\npi->need_update_smu7_dpm_table = 0;\r\nreturn 0;\r\n}\r\nstatic int ci_enable_sclk_mclk_dpm(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nif (enable) {\r\nif (!pi->sclk_dpm_key_disabled) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_DPM_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif (!pi->mclk_dpm_key_disabled) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nWREG32_P(MC_SEQ_CNTL_3, CAC_EN, ~CAC_EN);\r\nWREG32_SMC(LCAC_MC0_CNTL, 0x05);\r\nWREG32_SMC(LCAC_MC1_CNTL, 0x05);\r\nWREG32_SMC(LCAC_CPL_CNTL, 0x100005);\r\nudelay(10);\r\nWREG32_SMC(LCAC_MC0_CNTL, 0x400005);\r\nWREG32_SMC(LCAC_MC1_CNTL, 0x400005);\r\nWREG32_SMC(LCAC_CPL_CNTL, 0x500005);\r\n}\r\n} else {\r\nif (!pi->sclk_dpm_key_disabled) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_DPM_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif (!pi->mclk_dpm_key_disabled) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_start_dpm(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nint ret;\r\nu32 tmp;\r\ntmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp |= GLOBAL_PWRMGT_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\ntmp = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\ntmp |= DYNAMIC_PM_EN;\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, tmp);\r\nci_write_smc_soft_register(rdev, offsetof(SMU7_SoftRegisters, VoltageChangeTimeout), 0x1000);\r\nWREG32_P(BIF_LNCNT_RESET, 0, ~RESET_LNCNT_EN);\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_Voltage_Cntl_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nret = ci_enable_sclk_mclk_dpm(rdev, true);\r\nif (ret)\r\nreturn ret;\r\nif (!pi->pcie_dpm_key_disabled) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_PCIeDPM_Enable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_freeze_sclk_mclk_dpm(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nif (!pi->need_update_smu7_dpm_table)\r\nreturn 0;\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK))) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_SCLKDPM_FreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\n(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_MCLKDPM_FreezeLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_stop_dpm(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result smc_result;\r\nint ret;\r\nu32 tmp;\r\ntmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp &= ~GLOBAL_PWRMGT_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\ntmp = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\ntmp &= ~DYNAMIC_PM_EN;\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, tmp);\r\nif (!pi->pcie_dpm_key_disabled) {\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_PCIeDPM_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nret = ci_enable_sclk_mclk_dpm(rdev, false);\r\nif (ret)\r\nreturn ret;\r\nsmc_result = ci_send_msg_to_smc(rdev, PPSMC_MSG_Voltage_Cntl_Disable);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ci_enable_sclk_control(struct radeon_device *rdev, bool enable)\r\n{\r\nu32 tmp = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\nif (enable)\r\ntmp &= ~SCLK_PWRMGT_OFF;\r\nelse\r\ntmp |= SCLK_PWRMGT_OFF;\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, tmp);\r\n}\r\nstatic PPSMC_Result ci_send_msg_to_smc_with_parameter(struct radeon_device *rdev,\r\nPPSMC_Msg msg, u32 parameter)\r\n{\r\nWREG32(SMC_MSG_ARG_0, parameter);\r\nreturn ci_send_msg_to_smc(rdev, msg);\r\n}\r\nstatic PPSMC_Result ci_send_msg_to_smc_return_parameter(struct radeon_device *rdev,\r\nPPSMC_Msg msg, u32 *parameter)\r\n{\r\nPPSMC_Result smc_result;\r\nsmc_result = ci_send_msg_to_smc(rdev, msg);\r\nif ((smc_result == PPSMC_Result_OK) && parameter)\r\n*parameter = RREG32(SMC_MSG_ARG_0);\r\nreturn smc_result;\r\n}\r\nstatic int ci_dpm_force_state_sclk(struct radeon_device *rdev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (!pi->sclk_dpm_key_disabled) {\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SCLKDPM_SetEnabledMask, 1 << n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_force_state_mclk(struct radeon_device *rdev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (!pi->mclk_dpm_key_disabled) {\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_MCLKDPM_SetEnabledMask, 1 << n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_dpm_force_state_pcie(struct radeon_device *rdev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (!pi->pcie_dpm_key_disabled) {\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_PCIeDPM_ForceLevel, n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_set_power_limit(struct radeon_device *rdev, u32 n)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (pi->power_containment_features & POWERCONTAINMENT_FEATURE_PkgPwrLimit) {\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_PkgPwrSetLimit, n);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_set_overdrive_target_tdp(struct radeon_device *rdev,\r\nu32 target_tdp)\r\n{\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_OverDriveSetTargetTdp, target_tdp);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic u32 ci_get_average_sclk_freq(struct radeon_device *rdev)\r\n{\r\nu32 sclk_freq;\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_return_parameter(rdev,\r\nPPSMC_MSG_API_GetSclkFrequency,\r\n&sclk_freq);\r\nif (smc_result != PPSMC_Result_OK)\r\nsclk_freq = 0;\r\nreturn sclk_freq;\r\n}\r\nstatic u32 ci_get_average_mclk_freq(struct radeon_device *rdev)\r\n{\r\nu32 mclk_freq;\r\nPPSMC_Result smc_result =\r\nci_send_msg_to_smc_return_parameter(rdev,\r\nPPSMC_MSG_API_GetMclkFrequency,\r\n&mclk_freq);\r\nif (smc_result != PPSMC_Result_OK)\r\nmclk_freq = 0;\r\nreturn mclk_freq;\r\n}\r\nstatic void ci_dpm_start_smc(struct radeon_device *rdev)\r\n{\r\nint i;\r\nci_program_jump_on_start(rdev);\r\nci_start_smc_clock(rdev);\r\nci_start_smc(rdev);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32_SMC(FIRMWARE_FLAGS) & INTERRUPTS_ENABLED)\r\nbreak;\r\n}\r\n}\r\nstatic void ci_dpm_stop_smc(struct radeon_device *rdev)\r\n{\r\nci_reset_smc(rdev);\r\nci_stop_smc_clock(rdev);\r\n}\r\nstatic int ci_process_firmware_header(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nint ret;\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, DpmTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->dpm_table_start = tmp;\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, SoftRegisters),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->soft_regs_start = tmp;\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, mcRegisterTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->mc_reg_table_start = tmp;\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, FanTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->fan_table_start = tmp;\r\nret = ci_read_smc_sram_dword(rdev,\r\nSMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, mcArbDramTimingTable),\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->arb_table_start = tmp;\r\nreturn 0;\r\n}\r\nstatic void ci_read_clock_registers(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\npi->clock_registers.cg_spll_func_cntl =\r\nRREG32_SMC(CG_SPLL_FUNC_CNTL);\r\npi->clock_registers.cg_spll_func_cntl_2 =\r\nRREG32_SMC(CG_SPLL_FUNC_CNTL_2);\r\npi->clock_registers.cg_spll_func_cntl_3 =\r\nRREG32_SMC(CG_SPLL_FUNC_CNTL_3);\r\npi->clock_registers.cg_spll_func_cntl_4 =\r\nRREG32_SMC(CG_SPLL_FUNC_CNTL_4);\r\npi->clock_registers.cg_spll_spread_spectrum =\r\nRREG32_SMC(CG_SPLL_SPREAD_SPECTRUM);\r\npi->clock_registers.cg_spll_spread_spectrum_2 =\r\nRREG32_SMC(CG_SPLL_SPREAD_SPECTRUM_2);\r\npi->clock_registers.dll_cntl = RREG32(DLL_CNTL);\r\npi->clock_registers.mclk_pwrmgt_cntl = RREG32(MCLK_PWRMGT_CNTL);\r\npi->clock_registers.mpll_ad_func_cntl = RREG32(MPLL_AD_FUNC_CNTL);\r\npi->clock_registers.mpll_dq_func_cntl = RREG32(MPLL_DQ_FUNC_CNTL);\r\npi->clock_registers.mpll_func_cntl = RREG32(MPLL_FUNC_CNTL);\r\npi->clock_registers.mpll_func_cntl_1 = RREG32(MPLL_FUNC_CNTL_1);\r\npi->clock_registers.mpll_func_cntl_2 = RREG32(MPLL_FUNC_CNTL_2);\r\npi->clock_registers.mpll_ss1 = RREG32(MPLL_SS1);\r\npi->clock_registers.mpll_ss2 = RREG32(MPLL_SS2);\r\n}\r\nstatic void ci_init_sclk_t(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\npi->low_sclk_interrupt_t = 0;\r\n}\r\nstatic void ci_enable_thermal_protection(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nu32 tmp = RREG32_SMC(GENERAL_PWRMGT);\r\nif (enable)\r\ntmp &= ~THERMAL_PROTECTION_DIS;\r\nelse\r\ntmp |= THERMAL_PROTECTION_DIS;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n}\r\nstatic void ci_enable_acpi_power_management(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp |= STATIC_PM_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n}\r\nstatic int ci_notify_smc_display_change(struct radeon_device *rdev,\r\nbool has_display)\r\n{\r\nPPSMC_Msg msg = has_display ? PPSMC_MSG_HasDisplay : PPSMC_MSG_NoDisplay;\r\nreturn (ci_send_msg_to_smc(rdev, msg) == PPSMC_Result_OK) ? 0 : -EINVAL;\r\n}\r\nstatic int ci_enable_ds_master_switch(struct radeon_device *rdev,\r\nbool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (enable) {\r\nif (pi->caps_sclk_ds) {\r\nif (ci_send_msg_to_smc(rdev, PPSMC_MSG_MASTER_DeepSleep_ON) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n} else {\r\nif (ci_send_msg_to_smc(rdev, PPSMC_MSG_MASTER_DeepSleep_OFF) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (pi->caps_sclk_ds) {\r\nif (ci_send_msg_to_smc(rdev, PPSMC_MSG_MASTER_DeepSleep_OFF) != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_program_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(CG_DISPLAY_GAP_CNTL);\r\nu32 pre_vbi_time_in_us;\r\nu32 frame_time_in_us;\r\nu32 ref_clock = rdev->clock.spll.reference_freq;\r\nu32 refresh_rate = r600_dpm_get_vrefresh(rdev);\r\nu32 vblank_time = r600_dpm_get_vblank_time(rdev);\r\ntmp &= ~DISP_GAP_MASK;\r\nif (rdev->pm.dpm.new_active_crtc_count > 0)\r\ntmp |= DISP_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\r\nelse\r\ntmp |= DISP_GAP(R600_PM_DISPLAY_GAP_IGNORE);\r\nWREG32_SMC(CG_DISPLAY_GAP_CNTL, tmp);\r\nif (refresh_rate == 0)\r\nrefresh_rate = 60;\r\nif (vblank_time == 0xffffffff)\r\nvblank_time = 500;\r\nframe_time_in_us = 1000000 / refresh_rate;\r\npre_vbi_time_in_us =\r\nframe_time_in_us - 200 - vblank_time;\r\ntmp = pre_vbi_time_in_us * (ref_clock / 100);\r\nWREG32_SMC(CG_DISPLAY_GAP_CNTL2, tmp);\r\nci_write_smc_soft_register(rdev, offsetof(SMU7_SoftRegisters, PreVBlankGap), 0x64);\r\nci_write_smc_soft_register(rdev, offsetof(SMU7_SoftRegisters, VBlankTimeout), (frame_time_in_us - pre_vbi_time_in_us));\r\nci_notify_smc_display_change(rdev, (rdev->pm.dpm.new_active_crtc_count == 1));\r\n}\r\nstatic void ci_enable_spread_spectrum(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nif (enable) {\r\nif (pi->caps_sclk_ss_support) {\r\ntmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp |= DYN_SPREAD_SPECTRUM_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n}\r\n} else {\r\ntmp = RREG32_SMC(CG_SPLL_SPREAD_SPECTRUM);\r\ntmp &= ~SSEN;\r\nWREG32_SMC(CG_SPLL_SPREAD_SPECTRUM, tmp);\r\ntmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp &= ~DYN_SPREAD_SPECTRUM_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n}\r\n}\r\nstatic void ci_program_sstp(struct radeon_device *rdev)\r\n{\r\nWREG32_SMC(CG_SSP, (SSTU(R600_SSTU_DFLT) | SST(R600_SST_DFLT)));\r\n}\r\nstatic void ci_enable_display_gap(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(CG_DISPLAY_GAP_CNTL);\r\ntmp &= ~(DISP_GAP_MASK | DISP_GAP_MCHG_MASK);\r\ntmp |= (DISP_GAP(R600_PM_DISPLAY_GAP_IGNORE) |\r\nDISP_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK));\r\nWREG32_SMC(CG_DISPLAY_GAP_CNTL, tmp);\r\n}\r\nstatic void ci_program_vc(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\ntmp &= ~(RESET_SCLK_CNT | RESET_BUSY_CNT);\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, tmp);\r\nWREG32_SMC(CG_FTV_0, CISLANDS_VRC_DFLT0);\r\nWREG32_SMC(CG_FTV_1, CISLANDS_VRC_DFLT1);\r\nWREG32_SMC(CG_FTV_2, CISLANDS_VRC_DFLT2);\r\nWREG32_SMC(CG_FTV_3, CISLANDS_VRC_DFLT3);\r\nWREG32_SMC(CG_FTV_4, CISLANDS_VRC_DFLT4);\r\nWREG32_SMC(CG_FTV_5, CISLANDS_VRC_DFLT5);\r\nWREG32_SMC(CG_FTV_6, CISLANDS_VRC_DFLT6);\r\nWREG32_SMC(CG_FTV_7, CISLANDS_VRC_DFLT7);\r\n}\r\nstatic void ci_clear_vc(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\ntmp |= (RESET_SCLK_CNT | RESET_BUSY_CNT);\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, tmp);\r\nWREG32_SMC(CG_FTV_0, 0);\r\nWREG32_SMC(CG_FTV_1, 0);\r\nWREG32_SMC(CG_FTV_2, 0);\r\nWREG32_SMC(CG_FTV_3, 0);\r\nWREG32_SMC(CG_FTV_4, 0);\r\nWREG32_SMC(CG_FTV_5, 0);\r\nWREG32_SMC(CG_FTV_6, 0);\r\nWREG32_SMC(CG_FTV_7, 0);\r\n}\r\nstatic int ci_upload_firmware(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint i, ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32_SMC(RCU_UC_EVENTS) & BOOT_SEQ_DONE)\r\nbreak;\r\n}\r\nWREG32_SMC(SMC_SYSCON_MISC_CNTL, 1);\r\nci_stop_smc_clock(rdev);\r\nci_reset_smc(rdev);\r\nret = ci_load_smc_ucode(rdev, pi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int ci_get_svi2_voltage_table(struct radeon_device *rdev,\r\nstruct radeon_clock_voltage_dependency_table *voltage_dependency_table,\r\nstruct atom_voltage_table *voltage_table)\r\n{\r\nu32 i;\r\nif (voltage_dependency_table == NULL)\r\nreturn -EINVAL;\r\nvoltage_table->mask_low = 0;\r\nvoltage_table->phase_delay = 0;\r\nvoltage_table->count = voltage_dependency_table->count;\r\nfor (i = 0; i < voltage_table->count; i++) {\r\nvoltage_table->entries[i].value = voltage_dependency_table->entries[i].v;\r\nvoltage_table->entries[i].smio_low = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_construct_voltage_tables(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret;\r\nif (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) {\r\nret = radeon_atom_get_voltage_table(rdev, VOLTAGE_TYPE_VDDC,\r\nVOLTAGE_OBJ_GPIO_LUT,\r\n&pi->vddc_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n} else if (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nret = ci_get_svi2_voltage_table(rdev,\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\n&pi->vddc_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->vddc_voltage_table.count > SMU7_MAX_LEVELS_VDDC)\r\nsi_trim_voltage_table_to_fit_state_table(rdev, SMU7_MAX_LEVELS_VDDC,\r\n&pi->vddc_voltage_table);\r\nif (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) {\r\nret = radeon_atom_get_voltage_table(rdev, VOLTAGE_TYPE_VDDCI,\r\nVOLTAGE_OBJ_GPIO_LUT,\r\n&pi->vddci_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n} else if (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nret = ci_get_svi2_voltage_table(rdev,\r\n&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\n&pi->vddci_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->vddci_voltage_table.count > SMU7_MAX_LEVELS_VDDCI)\r\nsi_trim_voltage_table_to_fit_state_table(rdev, SMU7_MAX_LEVELS_VDDCI,\r\n&pi->vddci_voltage_table);\r\nif (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO) {\r\nret = radeon_atom_get_voltage_table(rdev, VOLTAGE_TYPE_MVDDC,\r\nVOLTAGE_OBJ_GPIO_LUT,\r\n&pi->mvdd_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n} else if (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nret = ci_get_svi2_voltage_table(rdev,\r\n&rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\r\n&pi->mvdd_voltage_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->mvdd_voltage_table.count > SMU7_MAX_LEVELS_MVDD)\r\nsi_trim_voltage_table_to_fit_state_table(rdev, SMU7_MAX_LEVELS_MVDD,\r\n&pi->mvdd_voltage_table);\r\nreturn 0;\r\n}\r\nstatic void ci_populate_smc_voltage_table(struct radeon_device *rdev,\r\nstruct atom_voltage_table_entry *voltage_table,\r\nSMU7_Discrete_VoltageLevel *smc_voltage_table)\r\n{\r\nint ret;\r\nret = ci_get_std_voltage_value_sidd(rdev, voltage_table,\r\n&smc_voltage_table->StdVoltageHiSidd,\r\n&smc_voltage_table->StdVoltageLoSidd);\r\nif (ret) {\r\nsmc_voltage_table->StdVoltageHiSidd = voltage_table->value * VOLTAGE_SCALE;\r\nsmc_voltage_table->StdVoltageLoSidd = voltage_table->value * VOLTAGE_SCALE;\r\n}\r\nsmc_voltage_table->Voltage = cpu_to_be16(voltage_table->value * VOLTAGE_SCALE);\r\nsmc_voltage_table->StdVoltageHiSidd =\r\ncpu_to_be16(smc_voltage_table->StdVoltageHiSidd);\r\nsmc_voltage_table->StdVoltageLoSidd =\r\ncpu_to_be16(smc_voltage_table->StdVoltageLoSidd);\r\n}\r\nstatic int ci_populate_smc_vddc_table(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nunsigned int count;\r\ntable->VddcLevelCount = pi->vddc_voltage_table.count;\r\nfor (count = 0; count < table->VddcLevelCount; count++) {\r\nci_populate_smc_voltage_table(rdev,\r\n&pi->vddc_voltage_table.entries[count],\r\n&table->VddcLevel[count]);\r\nif (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)\r\ntable->VddcLevel[count].Smio |=\r\npi->vddc_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->VddcLevel[count].Smio = 0;\r\n}\r\ntable->VddcLevelCount = cpu_to_be32(table->VddcLevelCount);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_vddci_table(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nunsigned int count;\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\ntable->VddciLevelCount = pi->vddci_voltage_table.count;\r\nfor (count = 0; count < table->VddciLevelCount; count++) {\r\nci_populate_smc_voltage_table(rdev,\r\n&pi->vddci_voltage_table.entries[count],\r\n&table->VddciLevel[count]);\r\nif (pi->vddci_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)\r\ntable->VddciLevel[count].Smio |=\r\npi->vddci_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->VddciLevel[count].Smio = 0;\r\n}\r\ntable->VddciLevelCount = cpu_to_be32(table->VddciLevelCount);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_mvdd_table(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nunsigned int count;\r\ntable->MvddLevelCount = pi->mvdd_voltage_table.count;\r\nfor (count = 0; count < table->MvddLevelCount; count++) {\r\nci_populate_smc_voltage_table(rdev,\r\n&pi->mvdd_voltage_table.entries[count],\r\n&table->MvddLevel[count]);\r\nif (pi->mvdd_control == CISLANDS_VOLTAGE_CONTROL_BY_GPIO)\r\ntable->MvddLevel[count].Smio |=\r\npi->mvdd_voltage_table.entries[count].smio_low;\r\nelse\r\ntable->MvddLevel[count].Smio = 0;\r\n}\r\ntable->MvddLevelCount = cpu_to_be32(table->MvddLevelCount);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_voltage_tables(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nint ret;\r\nret = ci_populate_smc_vddc_table(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_vddci_table(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_mvdd_table(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_mvdd_value(struct radeon_device *rdev, u32 mclk,\r\nSMU7_Discrete_VoltageLevel *voltage)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 i = 0;\r\nif (pi->mvdd_control != CISLANDS_VOLTAGE_CONTROL_NONE) {\r\nfor (i = 0; i < rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.count; i++) {\r\nif (mclk <= rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.entries[i].clk) {\r\nvoltage->Voltage = pi->mvdd_voltage_table.entries[i].value;\r\nbreak;\r\n}\r\n}\r\nif (i >= rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.count)\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_get_std_voltage_value_sidd(struct radeon_device *rdev,\r\nstruct atom_voltage_table_entry *voltage_table,\r\nu16 *std_voltage_hi_sidd, u16 *std_voltage_lo_sidd)\r\n{\r\nu16 v_index, idx;\r\nbool voltage_found = false;\r\n*std_voltage_hi_sidd = voltage_table->value * VOLTAGE_SCALE;\r\n*std_voltage_lo_sidd = voltage_table->value * VOLTAGE_SCALE;\r\nif (rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries == NULL)\r\nreturn -EINVAL;\r\nif (rdev->pm.dpm.dyn_state.cac_leakage_table.entries) {\r\nfor (v_index = 0; (u32)v_index < rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) {\r\nif (voltage_table->value ==\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) {\r\nvoltage_found = true;\r\nif ((u32)v_index < rdev->pm.dpm.dyn_state.cac_leakage_table.count)\r\nidx = v_index;\r\nelse\r\nidx = rdev->pm.dpm.dyn_state.cac_leakage_table.count - 1;\r\n*std_voltage_lo_sidd =\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].vddc * VOLTAGE_SCALE;\r\n*std_voltage_hi_sidd =\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].leakage * VOLTAGE_SCALE;\r\nbreak;\r\n}\r\n}\r\nif (!voltage_found) {\r\nfor (v_index = 0; (u32)v_index < rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) {\r\nif (voltage_table->value <=\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) {\r\nvoltage_found = true;\r\nif ((u32)v_index < rdev->pm.dpm.dyn_state.cac_leakage_table.count)\r\nidx = v_index;\r\nelse\r\nidx = rdev->pm.dpm.dyn_state.cac_leakage_table.count - 1;\r\n*std_voltage_lo_sidd =\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].vddc * VOLTAGE_SCALE;\r\n*std_voltage_hi_sidd =\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[idx].leakage * VOLTAGE_SCALE;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ci_populate_phase_value_based_on_sclk(struct radeon_device *rdev,\r\nconst struct radeon_phase_shedding_limits_table *limits,\r\nu32 sclk,\r\nu32 *phase_shedding)\r\n{\r\nunsigned int i;\r\n*phase_shedding = 1;\r\nfor (i = 0; i < limits->count; i++) {\r\nif (sclk < limits->entries[i].sclk) {\r\n*phase_shedding = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ci_populate_phase_value_based_on_mclk(struct radeon_device *rdev,\r\nconst struct radeon_phase_shedding_limits_table *limits,\r\nu32 mclk,\r\nu32 *phase_shedding)\r\n{\r\nunsigned int i;\r\n*phase_shedding = 1;\r\nfor (i = 0; i < limits->count; i++) {\r\nif (mclk < limits->entries[i].mclk) {\r\n*phase_shedding = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int ci_init_arb_table_index(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nint ret;\r\nret = ci_read_smc_sram_dword(rdev, pi->arb_table_start,\r\n&tmp, pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\ntmp &= 0x00FFFFFF;\r\ntmp |= MC_CG_ARB_FREQ_F1 << 24;\r\nreturn ci_write_smc_sram_dword(rdev, pi->arb_table_start,\r\ntmp, pi->sram_end);\r\n}\r\nstatic int ci_get_dependency_volt_by_clk(struct radeon_device *rdev,\r\nstruct radeon_clock_voltage_dependency_table *allowed_clock_voltage_table,\r\nu32 clock, u32 *voltage)\r\n{\r\nu32 i = 0;\r\nif (allowed_clock_voltage_table->count == 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < allowed_clock_voltage_table->count; i++) {\r\nif (allowed_clock_voltage_table->entries[i].clk >= clock) {\r\n*voltage = allowed_clock_voltage_table->entries[i].v;\r\nreturn 0;\r\n}\r\n}\r\n*voltage = allowed_clock_voltage_table->entries[i-1].v;\r\nreturn 0;\r\n}\r\nstatic u8 ci_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\r\nu32 sclk, u32 min_sclk_in_sr)\r\n{\r\nu32 i;\r\nu32 tmp;\r\nu32 min = (min_sclk_in_sr > CISLAND_MINIMUM_ENGINE_CLOCK) ?\r\nmin_sclk_in_sr : CISLAND_MINIMUM_ENGINE_CLOCK;\r\nif (sclk < min)\r\nreturn 0;\r\nfor (i = CISLAND_MAX_DEEPSLEEP_DIVIDER_ID; ; i--) {\r\ntmp = sclk / (1 << i);\r\nif (tmp >= min || i == 0)\r\nbreak;\r\n}\r\nreturn (u8)i;\r\n}\r\nstatic int ci_initial_switch_from_arb_f0_to_f1(struct radeon_device *rdev)\r\n{\r\nreturn ni_copy_and_switch_arb_sets(rdev, MC_CG_ARB_FREQ_F0, MC_CG_ARB_FREQ_F1);\r\n}\r\nstatic int ci_reset_to_default(struct radeon_device *rdev)\r\n{\r\nreturn (ci_send_msg_to_smc(rdev, PPSMC_MSG_ResetToDefaults) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nstatic int ci_force_switch_to_arb_f0(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = (RREG32_SMC(SMC_SCRATCH9) & 0x0000ff00) >> 8;\r\nif (tmp == MC_CG_ARB_FREQ_F0)\r\nreturn 0;\r\nreturn ni_copy_and_switch_arb_sets(rdev, tmp, MC_CG_ARB_FREQ_F0);\r\n}\r\nstatic void ci_register_patching_mc_arb(struct radeon_device *rdev,\r\nconst u32 engine_clock,\r\nconst u32 memory_clock,\r\nu32 *dram_timimg2)\r\n{\r\nbool patch;\r\nu32 tmp, tmp2;\r\ntmp = RREG32(MC_SEQ_MISC0);\r\npatch = ((tmp & 0x0000f00) == 0x300) ? true : false;\r\nif (patch &&\r\n((rdev->pdev->device == 0x67B0) ||\r\n(rdev->pdev->device == 0x67B1))) {\r\nif ((memory_clock > 100000) && (memory_clock <= 125000)) {\r\ntmp2 = (((0x31 * engine_clock) / 125000) - 1) & 0xff;\r\n*dram_timimg2 &= ~0x00ff0000;\r\n*dram_timimg2 |= tmp2 << 16;\r\n} else if ((memory_clock > 125000) && (memory_clock <= 137500)) {\r\ntmp2 = (((0x36 * engine_clock) / 137500) - 1) & 0xff;\r\n*dram_timimg2 &= ~0x00ff0000;\r\n*dram_timimg2 |= tmp2 << 16;\r\n}\r\n}\r\n}\r\nstatic int ci_populate_memory_timing_parameters(struct radeon_device *rdev,\r\nu32 sclk,\r\nu32 mclk,\r\nSMU7_Discrete_MCArbDramTimingTableEntry *arb_regs)\r\n{\r\nu32 dram_timing;\r\nu32 dram_timing2;\r\nu32 burst_time;\r\nradeon_atom_set_engine_dram_timings(rdev, sclk, mclk);\r\ndram_timing = RREG32(MC_ARB_DRAM_TIMING);\r\ndram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);\r\nburst_time = RREG32(MC_ARB_BURST_TIME) & STATE0_MASK;\r\nci_register_patching_mc_arb(rdev, sclk, mclk, &dram_timing2);\r\narb_regs->McArbDramTiming = cpu_to_be32(dram_timing);\r\narb_regs->McArbDramTiming2 = cpu_to_be32(dram_timing2);\r\narb_regs->McArbBurstTime = (u8)burst_time;\r\nreturn 0;\r\n}\r\nstatic int ci_do_program_memory_timing_parameters(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nSMU7_Discrete_MCArbDramTimingTable arb_regs;\r\nu32 i, j;\r\nint ret = 0;\r\nmemset(&arb_regs, 0, sizeof(SMU7_Discrete_MCArbDramTimingTable));\r\nfor (i = 0; i < pi->dpm_table.sclk_table.count; i++) {\r\nfor (j = 0; j < pi->dpm_table.mclk_table.count; j++) {\r\nret = ci_populate_memory_timing_parameters(rdev,\r\npi->dpm_table.sclk_table.dpm_levels[i].value,\r\npi->dpm_table.mclk_table.dpm_levels[j].value,\r\n&arb_regs.entries[i][j]);\r\nif (ret)\r\nbreak;\r\n}\r\n}\r\nif (ret == 0)\r\nret = ci_copy_bytes_to_smc(rdev,\r\npi->arb_table_start,\r\n(u8 *)&arb_regs,\r\nsizeof(SMU7_Discrete_MCArbDramTimingTable),\r\npi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int ci_program_memory_timing_parameters(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (pi->need_update_smu7_dpm_table == 0)\r\nreturn 0;\r\nreturn ci_do_program_memory_timing_parameters(rdev);\r\n}\r\nstatic void ci_populate_smc_initial_state(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_boot_state)\r\n{\r\nstruct ci_ps *boot_state = ci_get_ps(radeon_boot_state);\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 level = 0;\r\nfor (level = 0; level < rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; level++) {\r\nif (rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[level].clk >=\r\nboot_state->performance_levels[0].sclk) {\r\npi->smc_state_table.GraphicsBootLevel = level;\r\nbreak;\r\n}\r\n}\r\nfor (level = 0; level < rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.count; level++) {\r\nif (rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries[level].clk >=\r\nboot_state->performance_levels[0].mclk) {\r\npi->smc_state_table.MemoryBootLevel = level;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u32 ci_get_dpm_level_enable_mask_value(struct ci_single_dpm_table *dpm_table)\r\n{\r\nu32 i;\r\nu32 mask_value = 0;\r\nfor (i = dpm_table->count; i > 0; i--) {\r\nmask_value = mask_value << 1;\r\nif (dpm_table->dpm_levels[i-1].enabled)\r\nmask_value |= 0x1;\r\nelse\r\nmask_value &= 0xFFFFFFFE;\r\n}\r\nreturn mask_value;\r\n}\r\nstatic void ci_populate_smc_link_level(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nu32 i;\r\nfor (i = 0; i < dpm_table->pcie_speed_table.count; i++) {\r\ntable->LinkLevel[i].PcieGenSpeed =\r\n(u8)dpm_table->pcie_speed_table.dpm_levels[i].value;\r\ntable->LinkLevel[i].PcieLaneCount =\r\nr600_encode_pci_lane_width(dpm_table->pcie_speed_table.dpm_levels[i].param1);\r\ntable->LinkLevel[i].EnabledForActivity = 1;\r\ntable->LinkLevel[i].DownT = cpu_to_be32(5);\r\ntable->LinkLevel[i].UpT = cpu_to_be32(30);\r\n}\r\npi->smc_state_table.LinkLevelCount = (u8)dpm_table->pcie_speed_table.count;\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&dpm_table->pcie_speed_table);\r\n}\r\nstatic int ci_populate_smc_uvd_level(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->UvdLevelCount =\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count;\r\nfor (count = 0; count < table->UvdLevelCount; count++) {\r\ntable->UvdLevel[count].VclkFrequency =\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[count].vclk;\r\ntable->UvdLevel[count].DclkFrequency =\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[count].dclk;\r\ntable->UvdLevel[count].MinVddc =\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;\r\ntable->UvdLevel[count].MinVddcPhases = 1;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->UvdLevel[count].VclkFrequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->UvdLevel[count].VclkDivider = (u8)dividers.post_divider;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->UvdLevel[count].DclkFrequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->UvdLevel[count].DclkDivider = (u8)dividers.post_divider;\r\ntable->UvdLevel[count].VclkFrequency = cpu_to_be32(table->UvdLevel[count].VclkFrequency);\r\ntable->UvdLevel[count].DclkFrequency = cpu_to_be32(table->UvdLevel[count].DclkFrequency);\r\ntable->UvdLevel[count].MinVddc = cpu_to_be16(table->UvdLevel[count].MinVddc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_populate_smc_vce_level(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->VceLevelCount =\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count;\r\nfor (count = 0; count < table->VceLevelCount; count++) {\r\ntable->VceLevel[count].Frequency =\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[count].evclk;\r\ntable->VceLevel[count].MinVoltage =\r\n(u16)rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;\r\ntable->VceLevel[count].MinPhases = 1;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->VceLevel[count].Frequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->VceLevel[count].Divider = (u8)dividers.post_divider;\r\ntable->VceLevel[count].Frequency = cpu_to_be32(table->VceLevel[count].Frequency);\r\ntable->VceLevel[count].MinVoltage = cpu_to_be16(table->VceLevel[count].MinVoltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_populate_smc_acp_level(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->AcpLevelCount = (u8)\r\n(rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.count);\r\nfor (count = 0; count < table->AcpLevelCount; count++) {\r\ntable->AcpLevel[count].Frequency =\r\nrdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[count].clk;\r\ntable->AcpLevel[count].MinVoltage =\r\nrdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[count].v;\r\ntable->AcpLevel[count].MinPhases = 1;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->AcpLevel[count].Frequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->AcpLevel[count].Divider = (u8)dividers.post_divider;\r\ntable->AcpLevel[count].Frequency = cpu_to_be32(table->AcpLevel[count].Frequency);\r\ntable->AcpLevel[count].MinVoltage = cpu_to_be16(table->AcpLevel[count].MinVoltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_populate_smc_samu_level(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nu32 count;\r\nstruct atom_clock_dividers dividers;\r\nint ret = -EINVAL;\r\ntable->SamuLevelCount =\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.count;\r\nfor (count = 0; count < table->SamuLevelCount; count++) {\r\ntable->SamuLevel[count].Frequency =\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[count].clk;\r\ntable->SamuLevel[count].MinVoltage =\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[count].v * VOLTAGE_SCALE;\r\ntable->SamuLevel[count].MinPhases = 1;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\r\ntable->SamuLevel[count].Frequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->SamuLevel[count].Divider = (u8)dividers.post_divider;\r\ntable->SamuLevel[count].Frequency = cpu_to_be32(table->SamuLevel[count].Frequency);\r\ntable->SamuLevel[count].MinVoltage = cpu_to_be16(table->SamuLevel[count].MinVoltage);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_calculate_mclk_params(struct radeon_device *rdev,\r\nu32 memory_clock,\r\nSMU7_Discrete_MemoryLevel *mclk,\r\nbool strobe_mode,\r\nbool dll_state_on)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 dll_cntl = pi->clock_registers.dll_cntl;\r\nu32 mclk_pwrmgt_cntl = pi->clock_registers.mclk_pwrmgt_cntl;\r\nu32 mpll_ad_func_cntl = pi->clock_registers.mpll_ad_func_cntl;\r\nu32 mpll_dq_func_cntl = pi->clock_registers.mpll_dq_func_cntl;\r\nu32 mpll_func_cntl = pi->clock_registers.mpll_func_cntl;\r\nu32 mpll_func_cntl_1 = pi->clock_registers.mpll_func_cntl_1;\r\nu32 mpll_func_cntl_2 = pi->clock_registers.mpll_func_cntl_2;\r\nu32 mpll_ss1 = pi->clock_registers.mpll_ss1;\r\nu32 mpll_ss2 = pi->clock_registers.mpll_ss2;\r\nstruct atom_mpll_param mpll_param;\r\nint ret;\r\nret = radeon_atom_get_memory_pll_dividers(rdev, memory_clock, strobe_mode, &mpll_param);\r\nif (ret)\r\nreturn ret;\r\nmpll_func_cntl &= ~BWCTRL_MASK;\r\nmpll_func_cntl |= BWCTRL(mpll_param.bwcntl);\r\nmpll_func_cntl_1 &= ~(CLKF_MASK | CLKFRAC_MASK | VCO_MODE_MASK);\r\nmpll_func_cntl_1 |= CLKF(mpll_param.clkf) |\r\nCLKFRAC(mpll_param.clkfrac) | VCO_MODE(mpll_param.vco_mode);\r\nmpll_ad_func_cntl &= ~YCLK_POST_DIV_MASK;\r\nmpll_ad_func_cntl |= YCLK_POST_DIV(mpll_param.post_div);\r\nif (pi->mem_gddr5) {\r\nmpll_dq_func_cntl &= ~(YCLK_SEL_MASK | YCLK_POST_DIV_MASK);\r\nmpll_dq_func_cntl |= YCLK_SEL(mpll_param.yclk_sel) |\r\nYCLK_POST_DIV(mpll_param.post_div);\r\n}\r\nif (pi->caps_mclk_ss_support) {\r\nstruct radeon_atom_ss ss;\r\nu32 freq_nom;\r\nu32 tmp;\r\nu32 reference_clock = rdev->clock.mpll.reference_freq;\r\nif (mpll_param.qdr == 1)\r\nfreq_nom = memory_clock * 4 * (1 << mpll_param.post_div);\r\nelse\r\nfreq_nom = memory_clock * 2 * (1 << mpll_param.post_div);\r\ntmp = (freq_nom / reference_clock);\r\ntmp = tmp * tmp;\r\nif (radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_MEMORY_SS, freq_nom)) {\r\nu32 clks = reference_clock * 5 / ss.rate;\r\nu32 clkv = (u32)((((131 * ss.percentage * ss.rate) / 100) * tmp) / freq_nom);\r\nmpll_ss1 &= ~CLKV_MASK;\r\nmpll_ss1 |= CLKV(clkv);\r\nmpll_ss2 &= ~CLKS_MASK;\r\nmpll_ss2 |= CLKS(clks);\r\n}\r\n}\r\nmclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;\r\nmclk_pwrmgt_cntl |= DLL_SPEED(mpll_param.dll_speed);\r\nif (dll_state_on)\r\nmclk_pwrmgt_cntl |= MRDCK0_PDNB | MRDCK1_PDNB;\r\nelse\r\nmclk_pwrmgt_cntl &= ~(MRDCK0_PDNB | MRDCK1_PDNB);\r\nmclk->MclkFrequency = memory_clock;\r\nmclk->MpllFuncCntl = mpll_func_cntl;\r\nmclk->MpllFuncCntl_1 = mpll_func_cntl_1;\r\nmclk->MpllFuncCntl_2 = mpll_func_cntl_2;\r\nmclk->MpllAdFuncCntl = mpll_ad_func_cntl;\r\nmclk->MpllDqFuncCntl = mpll_dq_func_cntl;\r\nmclk->MclkPwrmgtCntl = mclk_pwrmgt_cntl;\r\nmclk->DllCntl = dll_cntl;\r\nmclk->MpllSs1 = mpll_ss1;\r\nmclk->MpllSs2 = mpll_ss2;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_single_memory_level(struct radeon_device *rdev,\r\nu32 memory_clock,\r\nSMU7_Discrete_MemoryLevel *memory_level)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret;\r\nbool dll_state_on;\r\nif (rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries) {\r\nret = ci_get_dependency_volt_by_clk(rdev,\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\nmemory_clock, &memory_level->MinVddc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk.entries) {\r\nret = ci_get_dependency_volt_by_clk(rdev,\r\n&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\nmemory_clock, &memory_level->MinVddci);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk.entries) {\r\nret = ci_get_dependency_volt_by_clk(rdev,\r\n&rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\r\nmemory_clock, &memory_level->MinMvdd);\r\nif (ret)\r\nreturn ret;\r\n}\r\nmemory_level->MinVddcPhases = 1;\r\nif (pi->vddc_phase_shed_control)\r\nci_populate_phase_value_based_on_mclk(rdev,\r\n&rdev->pm.dpm.dyn_state.phase_shedding_limits_table,\r\nmemory_clock,\r\n&memory_level->MinVddcPhases);\r\nmemory_level->EnabledForThrottle = 1;\r\nmemory_level->UpH = 0;\r\nmemory_level->DownH = 100;\r\nmemory_level->VoltageDownH = 0;\r\nmemory_level->ActivityLevel = (u16)pi->mclk_activity_target;\r\nmemory_level->StutterEnable = false;\r\nmemory_level->StrobeEnable = false;\r\nmemory_level->EdcReadEnable = false;\r\nmemory_level->EdcWriteEnable = false;\r\nmemory_level->RttEnable = false;\r\nmemory_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\nif (pi->mclk_stutter_mode_threshold &&\r\n(memory_clock <= pi->mclk_stutter_mode_threshold) &&\r\n(pi->uvd_enabled == false) &&\r\n(RREG32(DPG_PIPE_STUTTER_CONTROL) & STUTTER_ENABLE) &&\r\n(rdev->pm.dpm.new_active_crtc_count <= 2))\r\nmemory_level->StutterEnable = true;\r\nif (pi->mclk_strobe_mode_threshold &&\r\n(memory_clock <= pi->mclk_strobe_mode_threshold))\r\nmemory_level->StrobeEnable = 1;\r\nif (pi->mem_gddr5) {\r\nmemory_level->StrobeRatio =\r\nsi_get_mclk_frequency_ratio(memory_clock, memory_level->StrobeEnable);\r\nif (pi->mclk_edc_enable_threshold &&\r\n(memory_clock > pi->mclk_edc_enable_threshold))\r\nmemory_level->EdcReadEnable = true;\r\nif (pi->mclk_edc_wr_enable_threshold &&\r\n(memory_clock > pi->mclk_edc_wr_enable_threshold))\r\nmemory_level->EdcWriteEnable = true;\r\nif (memory_level->StrobeEnable) {\r\nif (si_get_mclk_frequency_ratio(memory_clock, true) >=\r\n((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))\r\ndll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\r\nelse\r\ndll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;\r\n} else {\r\ndll_state_on = pi->dll_default_on;\r\n}\r\n} else {\r\nmemory_level->StrobeRatio = si_get_ddr3_mclk_frequency_ratio(memory_clock);\r\ndll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\r\n}\r\nret = ci_calculate_mclk_params(rdev, memory_clock, memory_level, memory_level->StrobeEnable, dll_state_on);\r\nif (ret)\r\nreturn ret;\r\nmemory_level->MinVddc = cpu_to_be32(memory_level->MinVddc * VOLTAGE_SCALE);\r\nmemory_level->MinVddcPhases = cpu_to_be32(memory_level->MinVddcPhases);\r\nmemory_level->MinVddci = cpu_to_be32(memory_level->MinVddci * VOLTAGE_SCALE);\r\nmemory_level->MinMvdd = cpu_to_be32(memory_level->MinMvdd * VOLTAGE_SCALE);\r\nmemory_level->MclkFrequency = cpu_to_be32(memory_level->MclkFrequency);\r\nmemory_level->ActivityLevel = cpu_to_be16(memory_level->ActivityLevel);\r\nmemory_level->MpllFuncCntl = cpu_to_be32(memory_level->MpllFuncCntl);\r\nmemory_level->MpllFuncCntl_1 = cpu_to_be32(memory_level->MpllFuncCntl_1);\r\nmemory_level->MpllFuncCntl_2 = cpu_to_be32(memory_level->MpllFuncCntl_2);\r\nmemory_level->MpllAdFuncCntl = cpu_to_be32(memory_level->MpllAdFuncCntl);\r\nmemory_level->MpllDqFuncCntl = cpu_to_be32(memory_level->MpllDqFuncCntl);\r\nmemory_level->MclkPwrmgtCntl = cpu_to_be32(memory_level->MclkPwrmgtCntl);\r\nmemory_level->DllCntl = cpu_to_be32(memory_level->DllCntl);\r\nmemory_level->MpllSs1 = cpu_to_be32(memory_level->MpllSs1);\r\nmemory_level->MpllSs2 = cpu_to_be32(memory_level->MpllSs2);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_smc_acpi_level(struct radeon_device *rdev,\r\nSMU7_Discrete_DpmTable *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct atom_clock_dividers dividers;\r\nSMU7_Discrete_VoltageLevel voltage_level;\r\nu32 spll_func_cntl = pi->clock_registers.cg_spll_func_cntl;\r\nu32 spll_func_cntl_2 = pi->clock_registers.cg_spll_func_cntl_2;\r\nu32 dll_cntl = pi->clock_registers.dll_cntl;\r\nu32 mclk_pwrmgt_cntl = pi->clock_registers.mclk_pwrmgt_cntl;\r\nint ret;\r\ntable->ACPILevel.Flags &= ~PPSMC_SWSTATE_FLAG_DC;\r\nif (pi->acpi_vddc)\r\ntable->ACPILevel.MinVddc = cpu_to_be32(pi->acpi_vddc * VOLTAGE_SCALE);\r\nelse\r\ntable->ACPILevel.MinVddc = cpu_to_be32(pi->min_vddc_in_pp_table * VOLTAGE_SCALE);\r\ntable->ACPILevel.MinVddcPhases = pi->vddc_phase_shed_control ? 0 : 1;\r\ntable->ACPILevel.SclkFrequency = rdev->clock.spll.reference_freq;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_SCLK,\r\ntable->ACPILevel.SclkFrequency, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\ntable->ACPILevel.SclkDid = (u8)dividers.post_divider;\r\ntable->ACPILevel.DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ntable->ACPILevel.DeepSleepDivId = 0;\r\nspll_func_cntl &= ~SPLL_PWRON;\r\nspll_func_cntl |= SPLL_RESET;\r\nspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\r\nspll_func_cntl_2 |= SCLK_MUX_SEL(4);\r\ntable->ACPILevel.CgSpllFuncCntl = spll_func_cntl;\r\ntable->ACPILevel.CgSpllFuncCntl2 = spll_func_cntl_2;\r\ntable->ACPILevel.CgSpllFuncCntl3 = pi->clock_registers.cg_spll_func_cntl_3;\r\ntable->ACPILevel.CgSpllFuncCntl4 = pi->clock_registers.cg_spll_func_cntl_4;\r\ntable->ACPILevel.SpllSpreadSpectrum = pi->clock_registers.cg_spll_spread_spectrum;\r\ntable->ACPILevel.SpllSpreadSpectrum2 = pi->clock_registers.cg_spll_spread_spectrum_2;\r\ntable->ACPILevel.CcPwrDynRm = 0;\r\ntable->ACPILevel.CcPwrDynRm1 = 0;\r\ntable->ACPILevel.Flags = cpu_to_be32(table->ACPILevel.Flags);\r\ntable->ACPILevel.MinVddcPhases = cpu_to_be32(table->ACPILevel.MinVddcPhases);\r\ntable->ACPILevel.SclkFrequency = cpu_to_be32(table->ACPILevel.SclkFrequency);\r\ntable->ACPILevel.CgSpllFuncCntl = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl);\r\ntable->ACPILevel.CgSpllFuncCntl2 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl2);\r\ntable->ACPILevel.CgSpllFuncCntl3 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl3);\r\ntable->ACPILevel.CgSpllFuncCntl4 = cpu_to_be32(table->ACPILevel.CgSpllFuncCntl4);\r\ntable->ACPILevel.SpllSpreadSpectrum = cpu_to_be32(table->ACPILevel.SpllSpreadSpectrum);\r\ntable->ACPILevel.SpllSpreadSpectrum2 = cpu_to_be32(table->ACPILevel.SpllSpreadSpectrum2);\r\ntable->ACPILevel.CcPwrDynRm = cpu_to_be32(table->ACPILevel.CcPwrDynRm);\r\ntable->ACPILevel.CcPwrDynRm1 = cpu_to_be32(table->ACPILevel.CcPwrDynRm1);\r\ntable->MemoryACPILevel.MinVddc = table->ACPILevel.MinVddc;\r\ntable->MemoryACPILevel.MinVddcPhases = table->ACPILevel.MinVddcPhases;\r\nif (pi->vddci_control != CISLANDS_VOLTAGE_CONTROL_NONE) {\r\nif (pi->acpi_vddci)\r\ntable->MemoryACPILevel.MinVddci =\r\ncpu_to_be32(pi->acpi_vddci * VOLTAGE_SCALE);\r\nelse\r\ntable->MemoryACPILevel.MinVddci =\r\ncpu_to_be32(pi->min_vddci_in_pp_table * VOLTAGE_SCALE);\r\n}\r\nif (ci_populate_mvdd_value(rdev, 0, &voltage_level))\r\ntable->MemoryACPILevel.MinMvdd = 0;\r\nelse\r\ntable->MemoryACPILevel.MinMvdd =\r\ncpu_to_be32(voltage_level.Voltage * VOLTAGE_SCALE);\r\nmclk_pwrmgt_cntl |= MRDCK0_RESET | MRDCK1_RESET;\r\nmclk_pwrmgt_cntl &= ~(MRDCK0_PDNB | MRDCK1_PDNB);\r\ndll_cntl &= ~(MRDCK0_BYPASS | MRDCK1_BYPASS);\r\ntable->MemoryACPILevel.DllCntl = cpu_to_be32(dll_cntl);\r\ntable->MemoryACPILevel.MclkPwrmgtCntl = cpu_to_be32(mclk_pwrmgt_cntl);\r\ntable->MemoryACPILevel.MpllAdFuncCntl =\r\ncpu_to_be32(pi->clock_registers.mpll_ad_func_cntl);\r\ntable->MemoryACPILevel.MpllDqFuncCntl =\r\ncpu_to_be32(pi->clock_registers.mpll_dq_func_cntl);\r\ntable->MemoryACPILevel.MpllFuncCntl =\r\ncpu_to_be32(pi->clock_registers.mpll_func_cntl);\r\ntable->MemoryACPILevel.MpllFuncCntl_1 =\r\ncpu_to_be32(pi->clock_registers.mpll_func_cntl_1);\r\ntable->MemoryACPILevel.MpllFuncCntl_2 =\r\ncpu_to_be32(pi->clock_registers.mpll_func_cntl_2);\r\ntable->MemoryACPILevel.MpllSs1 = cpu_to_be32(pi->clock_registers.mpll_ss1);\r\ntable->MemoryACPILevel.MpllSs2 = cpu_to_be32(pi->clock_registers.mpll_ss2);\r\ntable->MemoryACPILevel.EnabledForThrottle = 0;\r\ntable->MemoryACPILevel.EnabledForActivity = 0;\r\ntable->MemoryACPILevel.UpH = 0;\r\ntable->MemoryACPILevel.DownH = 100;\r\ntable->MemoryACPILevel.VoltageDownH = 0;\r\ntable->MemoryACPILevel.ActivityLevel =\r\ncpu_to_be16((u16)pi->mclk_activity_target);\r\ntable->MemoryACPILevel.StutterEnable = false;\r\ntable->MemoryACPILevel.StrobeEnable = false;\r\ntable->MemoryACPILevel.EdcReadEnable = false;\r\ntable->MemoryACPILevel.EdcWriteEnable = false;\r\ntable->MemoryACPILevel.RttEnable = false;\r\nreturn 0;\r\n}\r\nstatic int ci_enable_ulv(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ulv_parm *ulv = &pi->ulv;\r\nif (ulv->supported) {\r\nif (enable)\r\nreturn (ci_send_msg_to_smc(rdev, PPSMC_MSG_EnableULV) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\nelse\r\nreturn (ci_send_msg_to_smc(rdev, PPSMC_MSG_DisableULV) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_populate_ulv_level(struct radeon_device *rdev,\r\nSMU7_Discrete_Ulv *state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu16 ulv_voltage = rdev->pm.dpm.backbias_response_time;\r\nstate->CcPwrDynRm = 0;\r\nstate->CcPwrDynRm1 = 0;\r\nif (ulv_voltage == 0) {\r\npi->ulv.supported = false;\r\nreturn 0;\r\n}\r\nif (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_BY_SVID2) {\r\nif (ulv_voltage > rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v)\r\nstate->VddcOffset = 0;\r\nelse\r\nstate->VddcOffset =\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v - ulv_voltage;\r\n} else {\r\nif (ulv_voltage > rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v)\r\nstate->VddcOffsetVid = 0;\r\nelse\r\nstate->VddcOffsetVid = (u8)\r\n((rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[0].v - ulv_voltage) *\r\nVOLTAGE_VID_OFFSET_SCALE2 / VOLTAGE_VID_OFFSET_SCALE1);\r\n}\r\nstate->VddcPhase = pi->vddc_phase_shed_control ? 0 : 1;\r\nstate->CcPwrDynRm = cpu_to_be32(state->CcPwrDynRm);\r\nstate->CcPwrDynRm1 = cpu_to_be32(state->CcPwrDynRm1);\r\nstate->VddcOffset = cpu_to_be16(state->VddcOffset);\r\nreturn 0;\r\n}\r\nstatic int ci_calculate_sclk_params(struct radeon_device *rdev,\r\nu32 engine_clock,\r\nSMU7_Discrete_GraphicsLevel *sclk)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct atom_clock_dividers dividers;\r\nu32 spll_func_cntl_3 = pi->clock_registers.cg_spll_func_cntl_3;\r\nu32 spll_func_cntl_4 = pi->clock_registers.cg_spll_func_cntl_4;\r\nu32 cg_spll_spread_spectrum = pi->clock_registers.cg_spll_spread_spectrum;\r\nu32 cg_spll_spread_spectrum_2 = pi->clock_registers.cg_spll_spread_spectrum_2;\r\nu32 reference_clock = rdev->clock.spll.reference_freq;\r\nu32 reference_divider;\r\nu32 fbdiv;\r\nint ret;\r\nret = radeon_atom_get_clock_dividers(rdev,\r\nCOMPUTE_GPUCLK_INPUT_FLAG_SCLK,\r\nengine_clock, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\nreference_divider = 1 + dividers.ref_div;\r\nfbdiv = dividers.fb_div & 0x3FFFFFF;\r\nspll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;\r\nspll_func_cntl_3 |= SPLL_FB_DIV(fbdiv);\r\nspll_func_cntl_3 |= SPLL_DITHEN;\r\nif (pi->caps_sclk_ss_support) {\r\nstruct radeon_atom_ss ss;\r\nu32 vco_freq = engine_clock * dividers.post_div;\r\nif (radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_ENGINE_SS, vco_freq)) {\r\nu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\r\nu32 clk_v = 4 * ss.percentage * fbdiv / (clk_s * 10000);\r\ncg_spll_spread_spectrum &= ~CLK_S_MASK;\r\ncg_spll_spread_spectrum |= CLK_S(clk_s);\r\ncg_spll_spread_spectrum |= SSEN;\r\ncg_spll_spread_spectrum_2 &= ~CLK_V_MASK;\r\ncg_spll_spread_spectrum_2 |= CLK_V(clk_v);\r\n}\r\n}\r\nsclk->SclkFrequency = engine_clock;\r\nsclk->CgSpllFuncCntl3 = spll_func_cntl_3;\r\nsclk->CgSpllFuncCntl4 = spll_func_cntl_4;\r\nsclk->SpllSpreadSpectrum = cg_spll_spread_spectrum;\r\nsclk->SpllSpreadSpectrum2 = cg_spll_spread_spectrum_2;\r\nsclk->SclkDid = (u8)dividers.post_divider;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_single_graphic_level(struct radeon_device *rdev,\r\nu32 engine_clock,\r\nu16 sclk_activity_level_t,\r\nSMU7_Discrete_GraphicsLevel *graphic_level)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret;\r\nret = ci_calculate_sclk_params(rdev, engine_clock, graphic_level);\r\nif (ret)\r\nreturn ret;\r\nret = ci_get_dependency_volt_by_clk(rdev,\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\nengine_clock, &graphic_level->MinVddc);\r\nif (ret)\r\nreturn ret;\r\ngraphic_level->SclkFrequency = engine_clock;\r\ngraphic_level->Flags = 0;\r\ngraphic_level->MinVddcPhases = 1;\r\nif (pi->vddc_phase_shed_control)\r\nci_populate_phase_value_based_on_sclk(rdev,\r\n&rdev->pm.dpm.dyn_state.phase_shedding_limits_table,\r\nengine_clock,\r\n&graphic_level->MinVddcPhases);\r\ngraphic_level->ActivityLevel = sclk_activity_level_t;\r\ngraphic_level->CcPwrDynRm = 0;\r\ngraphic_level->CcPwrDynRm1 = 0;\r\ngraphic_level->EnabledForThrottle = 1;\r\ngraphic_level->UpH = 0;\r\ngraphic_level->DownH = 0;\r\ngraphic_level->VoltageDownH = 0;\r\ngraphic_level->PowerThrottle = 0;\r\nif (pi->caps_sclk_ds)\r\ngraphic_level->DeepSleepDivId = ci_get_sleep_divider_id_from_clock(rdev,\r\nengine_clock,\r\nCISLAND_MINIMUM_ENGINE_CLOCK);\r\ngraphic_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;\r\ngraphic_level->Flags = cpu_to_be32(graphic_level->Flags);\r\ngraphic_level->MinVddc = cpu_to_be32(graphic_level->MinVddc * VOLTAGE_SCALE);\r\ngraphic_level->MinVddcPhases = cpu_to_be32(graphic_level->MinVddcPhases);\r\ngraphic_level->SclkFrequency = cpu_to_be32(graphic_level->SclkFrequency);\r\ngraphic_level->ActivityLevel = cpu_to_be16(graphic_level->ActivityLevel);\r\ngraphic_level->CgSpllFuncCntl3 = cpu_to_be32(graphic_level->CgSpllFuncCntl3);\r\ngraphic_level->CgSpllFuncCntl4 = cpu_to_be32(graphic_level->CgSpllFuncCntl4);\r\ngraphic_level->SpllSpreadSpectrum = cpu_to_be32(graphic_level->SpllSpreadSpectrum);\r\ngraphic_level->SpllSpreadSpectrum2 = cpu_to_be32(graphic_level->SpllSpreadSpectrum2);\r\ngraphic_level->CcPwrDynRm = cpu_to_be32(graphic_level->CcPwrDynRm);\r\ngraphic_level->CcPwrDynRm1 = cpu_to_be32(graphic_level->CcPwrDynRm1);\r\nreturn 0;\r\n}\r\nstatic int ci_populate_all_graphic_levels(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nu32 level_array_address = pi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, GraphicsLevel);\r\nu32 level_array_size = sizeof(SMU7_Discrete_GraphicsLevel) *\r\nSMU7_MAX_LEVELS_GRAPHICS;\r\nSMU7_Discrete_GraphicsLevel *levels = pi->smc_state_table.GraphicsLevel;\r\nu32 i, ret;\r\nmemset(levels, 0, level_array_size);\r\nfor (i = 0; i < dpm_table->sclk_table.count; i++) {\r\nret = ci_populate_single_graphic_level(rdev,\r\ndpm_table->sclk_table.dpm_levels[i].value,\r\n(u16)pi->activity_target[i],\r\n&pi->smc_state_table.GraphicsLevel[i]);\r\nif (ret)\r\nreturn ret;\r\nif (i > 1)\r\npi->smc_state_table.GraphicsLevel[i].DeepSleepDivId = 0;\r\nif (i == (dpm_table->sclk_table.count - 1))\r\npi->smc_state_table.GraphicsLevel[i].DisplayWatermark =\r\nPPSMC_DISPLAY_WATERMARK_HIGH;\r\n}\r\npi->smc_state_table.GraphicsLevel[0].EnabledForActivity = 1;\r\npi->smc_state_table.GraphicsDpmLevelCount = (u8)dpm_table->sclk_table.count;\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&dpm_table->sclk_table);\r\nret = ci_copy_bytes_to_smc(rdev, level_array_address,\r\n(u8 *)levels, level_array_size,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ci_populate_ulv_state(struct radeon_device *rdev,\r\nSMU7_Discrete_Ulv *ulv_level)\r\n{\r\nreturn ci_populate_ulv_level(rdev, ulv_level);\r\n}\r\nstatic int ci_populate_all_memory_levels(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nu32 level_array_address = pi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, MemoryLevel);\r\nu32 level_array_size = sizeof(SMU7_Discrete_MemoryLevel) *\r\nSMU7_MAX_LEVELS_MEMORY;\r\nSMU7_Discrete_MemoryLevel *levels = pi->smc_state_table.MemoryLevel;\r\nu32 i, ret;\r\nmemset(levels, 0, level_array_size);\r\nfor (i = 0; i < dpm_table->mclk_table.count; i++) {\r\nif (dpm_table->mclk_table.dpm_levels[i].value == 0)\r\nreturn -EINVAL;\r\nret = ci_populate_single_memory_level(rdev,\r\ndpm_table->mclk_table.dpm_levels[i].value,\r\n&pi->smc_state_table.MemoryLevel[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\npi->smc_state_table.MemoryLevel[0].EnabledForActivity = 1;\r\nif ((dpm_table->mclk_table.count >= 2) &&\r\n((rdev->pdev->device == 0x67B0) || (rdev->pdev->device == 0x67B1))) {\r\npi->smc_state_table.MemoryLevel[1].MinVddc =\r\npi->smc_state_table.MemoryLevel[0].MinVddc;\r\npi->smc_state_table.MemoryLevel[1].MinVddcPhases =\r\npi->smc_state_table.MemoryLevel[0].MinVddcPhases;\r\n}\r\npi->smc_state_table.MemoryLevel[0].ActivityLevel = cpu_to_be16(0x1F);\r\npi->smc_state_table.MemoryDpmLevelCount = (u8)dpm_table->mclk_table.count;\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&dpm_table->mclk_table);\r\npi->smc_state_table.MemoryLevel[dpm_table->mclk_table.count - 1].DisplayWatermark =\r\nPPSMC_DISPLAY_WATERMARK_HIGH;\r\nret = ci_copy_bytes_to_smc(rdev, level_array_address,\r\n(u8 *)levels, level_array_size,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void ci_reset_single_dpm_table(struct radeon_device *rdev,\r\nstruct ci_single_dpm_table* dpm_table,\r\nu32 count)\r\n{\r\nu32 i;\r\ndpm_table->count = count;\r\nfor (i = 0; i < MAX_REGULAR_DPM_NUMBER; i++)\r\ndpm_table->dpm_levels[i].enabled = false;\r\n}\r\nstatic void ci_setup_pcie_table_entry(struct ci_single_dpm_table* dpm_table,\r\nu32 index, u32 pcie_gen, u32 pcie_lanes)\r\n{\r\ndpm_table->dpm_levels[index].value = pcie_gen;\r\ndpm_table->dpm_levels[index].param1 = pcie_lanes;\r\ndpm_table->dpm_levels[index].enabled = true;\r\n}\r\nstatic int ci_setup_default_pcie_tables(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (!pi->use_pcie_performance_levels && !pi->use_pcie_powersaving_levels)\r\nreturn -EINVAL;\r\nif (pi->use_pcie_performance_levels && !pi->use_pcie_powersaving_levels) {\r\npi->pcie_gen_powersaving = pi->pcie_gen_performance;\r\npi->pcie_lane_powersaving = pi->pcie_lane_performance;\r\n} else if (!pi->use_pcie_performance_levels && pi->use_pcie_powersaving_levels) {\r\npi->pcie_gen_performance = pi->pcie_gen_powersaving;\r\npi->pcie_lane_performance = pi->pcie_lane_powersaving;\r\n}\r\nci_reset_single_dpm_table(rdev,\r\n&pi->dpm_table.pcie_speed_table,\r\nSMU7_MAX_LEVELS_LINK);\r\nif (rdev->family == CHIP_BONAIRE)\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 0,\r\npi->pcie_gen_powersaving.min,\r\npi->pcie_lane_powersaving.max);\r\nelse\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 0,\r\npi->pcie_gen_powersaving.min,\r\npi->pcie_lane_powersaving.min);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 1,\r\npi->pcie_gen_performance.min,\r\npi->pcie_lane_performance.min);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 2,\r\npi->pcie_gen_powersaving.min,\r\npi->pcie_lane_powersaving.max);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 3,\r\npi->pcie_gen_performance.min,\r\npi->pcie_lane_performance.max);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 4,\r\npi->pcie_gen_powersaving.max,\r\npi->pcie_lane_powersaving.max);\r\nci_setup_pcie_table_entry(&pi->dpm_table.pcie_speed_table, 5,\r\npi->pcie_gen_performance.max,\r\npi->pcie_lane_performance.max);\r\npi->dpm_table.pcie_speed_table.count = 6;\r\nreturn 0;\r\n}\r\nstatic int ci_setup_default_dpm_tables(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *allowed_sclk_vddc_table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nstruct radeon_clock_voltage_dependency_table *allowed_mclk_table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk;\r\nstruct radeon_cac_leakage_table *std_voltage_table =\r\n&rdev->pm.dpm.dyn_state.cac_leakage_table;\r\nu32 i;\r\nif (allowed_sclk_vddc_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_sclk_vddc_table->count < 1)\r\nreturn -EINVAL;\r\nif (allowed_mclk_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_mclk_table->count < 1)\r\nreturn -EINVAL;\r\nmemset(&pi->dpm_table, 0, sizeof(struct ci_dpm_table));\r\nci_reset_single_dpm_table(rdev,\r\n&pi->dpm_table.sclk_table,\r\nSMU7_MAX_LEVELS_GRAPHICS);\r\nci_reset_single_dpm_table(rdev,\r\n&pi->dpm_table.mclk_table,\r\nSMU7_MAX_LEVELS_MEMORY);\r\nci_reset_single_dpm_table(rdev,\r\n&pi->dpm_table.vddc_table,\r\nSMU7_MAX_LEVELS_VDDC);\r\nci_reset_single_dpm_table(rdev,\r\n&pi->dpm_table.vddci_table,\r\nSMU7_MAX_LEVELS_VDDCI);\r\nci_reset_single_dpm_table(rdev,\r\n&pi->dpm_table.mvdd_table,\r\nSMU7_MAX_LEVELS_MVDD);\r\npi->dpm_table.sclk_table.count = 0;\r\nfor (i = 0; i < allowed_sclk_vddc_table->count; i++) {\r\nif ((i == 0) ||\r\n(pi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count-1].value !=\r\nallowed_sclk_vddc_table->entries[i].clk)) {\r\npi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count].value =\r\nallowed_sclk_vddc_table->entries[i].clk;\r\npi->dpm_table.sclk_table.dpm_levels[pi->dpm_table.sclk_table.count].enabled =\r\n(i == 0) ? true : false;\r\npi->dpm_table.sclk_table.count++;\r\n}\r\n}\r\npi->dpm_table.mclk_table.count = 0;\r\nfor (i = 0; i < allowed_mclk_table->count; i++) {\r\nif ((i == 0) ||\r\n(pi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count-1].value !=\r\nallowed_mclk_table->entries[i].clk)) {\r\npi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count].value =\r\nallowed_mclk_table->entries[i].clk;\r\npi->dpm_table.mclk_table.dpm_levels[pi->dpm_table.mclk_table.count].enabled =\r\n(i == 0) ? true : false;\r\npi->dpm_table.mclk_table.count++;\r\n}\r\n}\r\nfor (i = 0; i < allowed_sclk_vddc_table->count; i++) {\r\npi->dpm_table.vddc_table.dpm_levels[i].value =\r\nallowed_sclk_vddc_table->entries[i].v;\r\npi->dpm_table.vddc_table.dpm_levels[i].param1 =\r\nstd_voltage_table->entries[i].leakage;\r\npi->dpm_table.vddc_table.dpm_levels[i].enabled = true;\r\n}\r\npi->dpm_table.vddc_table.count = allowed_sclk_vddc_table->count;\r\nallowed_mclk_table = &rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk;\r\nif (allowed_mclk_table) {\r\nfor (i = 0; i < allowed_mclk_table->count; i++) {\r\npi->dpm_table.vddci_table.dpm_levels[i].value =\r\nallowed_mclk_table->entries[i].v;\r\npi->dpm_table.vddci_table.dpm_levels[i].enabled = true;\r\n}\r\npi->dpm_table.vddci_table.count = allowed_mclk_table->count;\r\n}\r\nallowed_mclk_table = &rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk;\r\nif (allowed_mclk_table) {\r\nfor (i = 0; i < allowed_mclk_table->count; i++) {\r\npi->dpm_table.mvdd_table.dpm_levels[i].value =\r\nallowed_mclk_table->entries[i].v;\r\npi->dpm_table.mvdd_table.dpm_levels[i].enabled = true;\r\n}\r\npi->dpm_table.mvdd_table.count = allowed_mclk_table->count;\r\n}\r\nci_setup_default_pcie_tables(rdev);\r\nreturn 0;\r\n}\r\nstatic int ci_find_boot_level(struct ci_single_dpm_table *table,\r\nu32 value, u32 *boot_level)\r\n{\r\nu32 i;\r\nint ret = -EINVAL;\r\nfor(i = 0; i < table->count; i++) {\r\nif (value == table->dpm_levels[i].value) {\r\n*boot_level = i;\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_init_smc_table(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ulv_parm *ulv = &pi->ulv;\r\nstruct radeon_ps *radeon_boot_state = rdev->pm.dpm.boot_ps;\r\nSMU7_Discrete_DpmTable *table = &pi->smc_state_table;\r\nint ret;\r\nret = ci_setup_default_dpm_tables(rdev);\r\nif (ret)\r\nreturn ret;\r\nif (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_NONE)\r\nci_populate_smc_voltage_tables(rdev, table);\r\nci_init_fps_limits(rdev);\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\r\nif (pi->mem_gddr5)\r\ntable->SystemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\r\nif (ulv->supported) {\r\nret = ci_populate_ulv_state(rdev, &pi->smc_state_table.Ulv);\r\nif (ret)\r\nreturn ret;\r\nWREG32_SMC(CG_ULV_PARAMETER, ulv->cg_ulv_parameter);\r\n}\r\nret = ci_populate_all_graphic_levels(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_all_memory_levels(rdev);\r\nif (ret)\r\nreturn ret;\r\nci_populate_smc_link_level(rdev, table);\r\nret = ci_populate_smc_acpi_level(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_vce_level(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_acp_level(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_samu_level(rdev, table);\r\nif (ret)\r\nreturn ret;\r\nret = ci_do_program_memory_timing_parameters(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = ci_populate_smc_uvd_level(rdev, table);\r\nif (ret)\r\nreturn ret;\r\ntable->UvdBootLevel = 0;\r\ntable->VceBootLevel = 0;\r\ntable->AcpBootLevel = 0;\r\ntable->SamuBootLevel = 0;\r\ntable->GraphicsBootLevel = 0;\r\ntable->MemoryBootLevel = 0;\r\nret = ci_find_boot_level(&pi->dpm_table.sclk_table,\r\npi->vbios_boot_state.sclk_bootup_value,\r\n(u32 *)&pi->smc_state_table.GraphicsBootLevel);\r\nret = ci_find_boot_level(&pi->dpm_table.mclk_table,\r\npi->vbios_boot_state.mclk_bootup_value,\r\n(u32 *)&pi->smc_state_table.MemoryBootLevel);\r\ntable->BootVddc = pi->vbios_boot_state.vddc_bootup_value;\r\ntable->BootVddci = pi->vbios_boot_state.vddci_bootup_value;\r\ntable->BootMVdd = pi->vbios_boot_state.mvdd_bootup_value;\r\nci_populate_smc_initial_state(rdev, radeon_boot_state);\r\nret = ci_populate_bapm_parameters_in_dpm_table(rdev);\r\nif (ret)\r\nreturn ret;\r\ntable->UVDInterval = 1;\r\ntable->VCEInterval = 1;\r\ntable->ACPInterval = 1;\r\ntable->SAMUInterval = 1;\r\ntable->GraphicsVoltageChangeEnable = 1;\r\ntable->GraphicsThermThrottleEnable = 1;\r\ntable->GraphicsInterval = 1;\r\ntable->VoltageInterval = 1;\r\ntable->ThermalInterval = 1;\r\ntable->TemperatureLimitHigh = (u16)((pi->thermal_temp_setting.temperature_high *\r\nCISLANDS_Q88_FORMAT_CONVERSION_UNIT) / 1000);\r\ntable->TemperatureLimitLow = (u16)((pi->thermal_temp_setting.temperature_low *\r\nCISLANDS_Q88_FORMAT_CONVERSION_UNIT) / 1000);\r\ntable->MemoryVoltageChangeEnable = 1;\r\ntable->MemoryInterval = 1;\r\ntable->VoltageResponseTime = 0;\r\ntable->VddcVddciDelta = 4000;\r\ntable->PhaseResponseTime = 0;\r\ntable->MemoryThermThrottleEnable = 1;\r\ntable->PCIeBootLinkLevel = pi->dpm_table.pcie_speed_table.count - 1;\r\ntable->PCIeGenInterval = 1;\r\nif (pi->voltage_control == CISLANDS_VOLTAGE_CONTROL_BY_SVID2)\r\ntable->SVI2Enable = 1;\r\nelse\r\ntable->SVI2Enable = 0;\r\ntable->ThermGpio = 17;\r\ntable->SclkStepSize = 0x4000;\r\ntable->SystemFlags = cpu_to_be32(table->SystemFlags);\r\ntable->SmioMaskVddcVid = cpu_to_be32(table->SmioMaskVddcVid);\r\ntable->SmioMaskVddcPhase = cpu_to_be32(table->SmioMaskVddcPhase);\r\ntable->SmioMaskVddciVid = cpu_to_be32(table->SmioMaskVddciVid);\r\ntable->SmioMaskMvddVid = cpu_to_be32(table->SmioMaskMvddVid);\r\ntable->SclkStepSize = cpu_to_be32(table->SclkStepSize);\r\ntable->TemperatureLimitHigh = cpu_to_be16(table->TemperatureLimitHigh);\r\ntable->TemperatureLimitLow = cpu_to_be16(table->TemperatureLimitLow);\r\ntable->VddcVddciDelta = cpu_to_be16(table->VddcVddciDelta);\r\ntable->VoltageResponseTime = cpu_to_be16(table->VoltageResponseTime);\r\ntable->PhaseResponseTime = cpu_to_be16(table->PhaseResponseTime);\r\ntable->BootVddc = cpu_to_be16(table->BootVddc * VOLTAGE_SCALE);\r\ntable->BootVddci = cpu_to_be16(table->BootVddci * VOLTAGE_SCALE);\r\ntable->BootMVdd = cpu_to_be16(table->BootMVdd * VOLTAGE_SCALE);\r\nret = ci_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Discrete_DpmTable, SystemFlags),\r\n(u8 *)&table->SystemFlags,\r\nsizeof(SMU7_Discrete_DpmTable) - 3 * sizeof(SMU7_PIDController),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void ci_trim_single_dpm_states(struct radeon_device *rdev,\r\nstruct ci_single_dpm_table *dpm_table,\r\nu32 low_limit, u32 high_limit)\r\n{\r\nu32 i;\r\nfor (i = 0; i < dpm_table->count; i++) {\r\nif ((dpm_table->dpm_levels[i].value < low_limit) ||\r\n(dpm_table->dpm_levels[i].value > high_limit))\r\ndpm_table->dpm_levels[i].enabled = false;\r\nelse\r\ndpm_table->dpm_levels[i].enabled = true;\r\n}\r\n}\r\nstatic void ci_trim_pcie_dpm_states(struct radeon_device *rdev,\r\nu32 speed_low, u32 lanes_low,\r\nu32 speed_high, u32 lanes_high)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_single_dpm_table *pcie_table = &pi->dpm_table.pcie_speed_table;\r\nu32 i, j;\r\nfor (i = 0; i < pcie_table->count; i++) {\r\nif ((pcie_table->dpm_levels[i].value < speed_low) ||\r\n(pcie_table->dpm_levels[i].param1 < lanes_low) ||\r\n(pcie_table->dpm_levels[i].value > speed_high) ||\r\n(pcie_table->dpm_levels[i].param1 > lanes_high))\r\npcie_table->dpm_levels[i].enabled = false;\r\nelse\r\npcie_table->dpm_levels[i].enabled = true;\r\n}\r\nfor (i = 0; i < pcie_table->count; i++) {\r\nif (pcie_table->dpm_levels[i].enabled) {\r\nfor (j = i + 1; j < pcie_table->count; j++) {\r\nif (pcie_table->dpm_levels[j].enabled) {\r\nif ((pcie_table->dpm_levels[i].value == pcie_table->dpm_levels[j].value) &&\r\n(pcie_table->dpm_levels[i].param1 == pcie_table->dpm_levels[j].param1))\r\npcie_table->dpm_levels[j].enabled = false;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int ci_trim_dpm_states(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct ci_ps *state = ci_get_ps(radeon_state);\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 high_limit_count;\r\nif (state->performance_level_count < 1)\r\nreturn -EINVAL;\r\nif (state->performance_level_count == 1)\r\nhigh_limit_count = 0;\r\nelse\r\nhigh_limit_count = 1;\r\nci_trim_single_dpm_states(rdev,\r\n&pi->dpm_table.sclk_table,\r\nstate->performance_levels[0].sclk,\r\nstate->performance_levels[high_limit_count].sclk);\r\nci_trim_single_dpm_states(rdev,\r\n&pi->dpm_table.mclk_table,\r\nstate->performance_levels[0].mclk,\r\nstate->performance_levels[high_limit_count].mclk);\r\nci_trim_pcie_dpm_states(rdev,\r\nstate->performance_levels[0].pcie_gen,\r\nstate->performance_levels[0].pcie_lane,\r\nstate->performance_levels[high_limit_count].pcie_gen,\r\nstate->performance_levels[high_limit_count].pcie_lane);\r\nreturn 0;\r\n}\r\nstatic int ci_apply_disp_minimum_voltage_request(struct radeon_device *rdev)\r\n{\r\nstruct radeon_clock_voltage_dependency_table *disp_voltage_table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk;\r\nstruct radeon_clock_voltage_dependency_table *vddc_table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nu32 requested_voltage = 0;\r\nu32 i;\r\nif (disp_voltage_table == NULL)\r\nreturn -EINVAL;\r\nif (!disp_voltage_table->count)\r\nreturn -EINVAL;\r\nfor (i = 0; i < disp_voltage_table->count; i++) {\r\nif (rdev->clock.current_dispclk == disp_voltage_table->entries[i].clk)\r\nrequested_voltage = disp_voltage_table->entries[i].v;\r\n}\r\nfor (i = 0; i < vddc_table->count; i++) {\r\nif (requested_voltage <= vddc_table->entries[i].v) {\r\nrequested_voltage = vddc_table->entries[i].v;\r\nreturn (ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_VddC_Request,\r\nrequested_voltage * VOLTAGE_SCALE) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ci_upload_dpm_level_enable_mask(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nPPSMC_Result result;\r\nci_apply_disp_minimum_voltage_request(rdev);\r\nif (!pi->sclk_dpm_key_disabled) {\r\nif (pi->dpm_level_enable_mask.sclk_dpm_enable_mask) {\r\nresult = ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_SCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask);\r\nif (result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!pi->mclk_dpm_key_disabled) {\r\nif (pi->dpm_level_enable_mask.mclk_dpm_enable_mask) {\r\nresult = ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\nif (result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\n#if 0\r\nif (!pi->pcie_dpm_key_disabled) {\r\nif (pi->dpm_level_enable_mask.pcie_dpm_enable_mask) {\r\nresult = ci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_PCIeDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask);\r\nif (result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ci_find_dpm_states_clocks_in_dpm_table(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ps *state = ci_get_ps(radeon_state);\r\nstruct ci_single_dpm_table *sclk_table = &pi->dpm_table.sclk_table;\r\nu32 sclk = state->performance_levels[state->performance_level_count-1].sclk;\r\nstruct ci_single_dpm_table *mclk_table = &pi->dpm_table.mclk_table;\r\nu32 mclk = state->performance_levels[state->performance_level_count-1].mclk;\r\nu32 i;\r\npi->need_update_smu7_dpm_table = 0;\r\nfor (i = 0; i < sclk_table->count; i++) {\r\nif (sclk == sclk_table->dpm_levels[i].value)\r\nbreak;\r\n}\r\nif (i >= sclk_table->count) {\r\npi->need_update_smu7_dpm_table |= DPMTABLE_OD_UPDATE_SCLK;\r\n} else {\r\nif (CISLAND_MINIMUM_ENGINE_CLOCK != CISLAND_MINIMUM_ENGINE_CLOCK)\r\npi->need_update_smu7_dpm_table |= DPMTABLE_UPDATE_SCLK;\r\n}\r\nfor (i = 0; i < mclk_table->count; i++) {\r\nif (mclk == mclk_table->dpm_levels[i].value)\r\nbreak;\r\n}\r\nif (i >= mclk_table->count)\r\npi->need_update_smu7_dpm_table |= DPMTABLE_OD_UPDATE_MCLK;\r\nif (rdev->pm.dpm.current_active_crtc_count !=\r\nrdev->pm.dpm.new_active_crtc_count)\r\npi->need_update_smu7_dpm_table |= DPMTABLE_UPDATE_MCLK;\r\n}\r\nstatic int ci_populate_and_upload_sclk_mclk_dpm_levels(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ps *state = ci_get_ps(radeon_state);\r\nu32 sclk = state->performance_levels[state->performance_level_count-1].sclk;\r\nu32 mclk = state->performance_levels[state->performance_level_count-1].mclk;\r\nstruct ci_dpm_table *dpm_table = &pi->dpm_table;\r\nint ret;\r\nif (!pi->need_update_smu7_dpm_table)\r\nreturn 0;\r\nif (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_SCLK)\r\ndpm_table->sclk_table.dpm_levels[dpm_table->sclk_table.count-1].value = sclk;\r\nif (pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK)\r\ndpm_table->mclk_table.dpm_levels[dpm_table->mclk_table.count-1].value = mclk;\r\nif (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK)) {\r\nret = ci_populate_all_graphic_levels(rdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (pi->need_update_smu7_dpm_table & (DPMTABLE_OD_UPDATE_MCLK | DPMTABLE_UPDATE_MCLK)) {\r\nret = ci_populate_all_memory_levels(rdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_enable_uvd_dpm(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nconst struct radeon_clock_and_voltage_limits *max_limits;\r\nint i;\r\nif (rdev->pm.dpm.ac_power)\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (enable) {\r\npi->dpm_level_enable_mask.uvd_dpm_enable_mask = 0;\r\nfor (i = rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count - 1; i >= 0; i--) {\r\nif (rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].v <= max_limits->vddc) {\r\npi->dpm_level_enable_mask.uvd_dpm_enable_mask |= 1 << i;\r\nif (!pi->caps_uvd_dpm)\r\nbreak;\r\n}\r\n}\r\nci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_UVDDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.uvd_dpm_enable_mask);\r\nif (pi->last_mclk_dpm_enable_mask & 0x1) {\r\npi->uvd_enabled = true;\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask &= 0xFFFFFFFE;\r\nci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\n}\r\n} else {\r\nif (pi->last_mclk_dpm_enable_mask & 0x1) {\r\npi->uvd_enabled = false;\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask |= 1;\r\nci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_MCLKDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\n}\r\n}\r\nreturn (ci_send_msg_to_smc(rdev, enable ?\r\nPPSMC_MSG_UVDDPM_Enable : PPSMC_MSG_UVDDPM_Disable) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nstatic int ci_enable_vce_dpm(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nconst struct radeon_clock_and_voltage_limits *max_limits;\r\nint i;\r\nif (rdev->pm.dpm.ac_power)\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nelse\r\nmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\r\nif (enable) {\r\npi->dpm_level_enable_mask.vce_dpm_enable_mask = 0;\r\nfor (i = rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count - 1; i >= 0; i--) {\r\nif (rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].v <= max_limits->vddc) {\r\npi->dpm_level_enable_mask.vce_dpm_enable_mask |= 1 << i;\r\nif (!pi->caps_vce_dpm)\r\nbreak;\r\n}\r\n}\r\nci_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_VCEDPM_SetEnabledMask,\r\npi->dpm_level_enable_mask.vce_dpm_enable_mask);\r\n}\r\nreturn (ci_send_msg_to_smc(rdev, enable ?\r\nPPSMC_MSG_VCEDPM_Enable : PPSMC_MSG_VCEDPM_Disable) == PPSMC_Result_OK) ?\r\n0 : -EINVAL;\r\n}\r\nstatic int ci_update_uvd_dpm(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\nif (!gate) {\r\nif (pi->caps_uvd_dpm ||\r\n(rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count <= 0))\r\npi->smc_state_table.UvdBootLevel = 0;\r\nelse\r\npi->smc_state_table.UvdBootLevel =\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count - 1;\r\ntmp = RREG32_SMC(DPM_TABLE_475);\r\ntmp &= ~UvdBootLevel_MASK;\r\ntmp |= UvdBootLevel(pi->smc_state_table.UvdBootLevel);\r\nWREG32_SMC(DPM_TABLE_475, tmp);\r\n}\r\nreturn ci_enable_uvd_dpm(rdev, !gate);\r\n}\r\nstatic u8 ci_get_vce_boot_level(struct radeon_device *rdev)\r\n{\r\nu8 i;\r\nu32 min_evclk = 30000;\r\nstruct radeon_vce_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\r\nfor (i = 0; i < table->count; i++) {\r\nif (table->entries[i].evclk >= min_evclk)\r\nreturn i;\r\n}\r\nreturn table->count - 1;\r\n}\r\nstatic int ci_update_vce_dpm(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret = 0;\r\nu32 tmp;\r\nif (radeon_current_state->evclk != radeon_new_state->evclk) {\r\nif (radeon_new_state->evclk) {\r\ncik_update_cg(rdev, RADEON_CG_BLOCK_VCE, false);\r\npi->smc_state_table.VceBootLevel = ci_get_vce_boot_level(rdev);\r\ntmp = RREG32_SMC(DPM_TABLE_475);\r\ntmp &= ~VceBootLevel_MASK;\r\ntmp |= VceBootLevel(pi->smc_state_table.VceBootLevel);\r\nWREG32_SMC(DPM_TABLE_475, tmp);\r\nret = ci_enable_vce_dpm(rdev, true);\r\n} else {\r\ncik_update_cg(rdev, RADEON_CG_BLOCK_VCE, true);\r\nret = ci_enable_vce_dpm(rdev, false);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ci_generate_dpm_level_enable_mask(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret;\r\nret = ci_trim_dpm_states(rdev, radeon_state);\r\nif (ret)\r\nreturn ret;\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&pi->dpm_table.sclk_table);\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&pi->dpm_table.mclk_table);\r\npi->last_mclk_dpm_enable_mask =\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask;\r\nif (pi->uvd_enabled) {\r\nif (pi->dpm_level_enable_mask.mclk_dpm_enable_mask & 1)\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask &= 0xFFFFFFFE;\r\n}\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask =\r\nci_get_dpm_level_enable_mask_value(&pi->dpm_table.pcie_speed_table);\r\nreturn 0;\r\n}\r\nstatic u32 ci_get_lowest_enabled_level(struct radeon_device *rdev,\r\nu32 level_mask)\r\n{\r\nu32 level = 0;\r\nwhile ((level_mask & (1 << level)) == 0)\r\nlevel++;\r\nreturn level;\r\n}\r\nint ci_dpm_force_performance_level(struct radeon_device *rdev,\r\nenum radeon_dpm_forced_level level)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp, levels, i;\r\nint ret;\r\nif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\r\nif ((!pi->pcie_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask) {\r\nlevels = 0;\r\ntmp = pi->dpm_level_enable_mask.pcie_dpm_enable_mask;\r\nwhile (tmp >>= 1)\r\nlevels++;\r\nif (levels) {\r\nret = ci_dpm_force_state_pcie(rdev, level);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX_1) &\r\nCURR_PCIE_INDEX_MASK) >> CURR_PCIE_INDEX_SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask) {\r\nlevels = 0;\r\ntmp = pi->dpm_level_enable_mask.sclk_dpm_enable_mask;\r\nwhile (tmp >>= 1)\r\nlevels++;\r\nif (levels) {\r\nret = ci_dpm_force_state_sclk(rdev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) &\r\nCURR_SCLK_INDEX_MASK) >> CURR_SCLK_INDEX_SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask) {\r\nlevels = 0;\r\ntmp = pi->dpm_level_enable_mask.mclk_dpm_enable_mask;\r\nwhile (tmp >>= 1)\r\nlevels++;\r\nif (levels) {\r\nret = ci_dpm_force_state_mclk(rdev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) &\r\nCURR_MCLK_INDEX_MASK) >> CURR_MCLK_INDEX_SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\r\nif ((!pi->sclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask) {\r\nlevels = ci_get_lowest_enabled_level(rdev,\r\npi->dpm_level_enable_mask.sclk_dpm_enable_mask);\r\nret = ci_dpm_force_state_sclk(rdev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) &\r\nCURR_SCLK_INDEX_MASK) >> CURR_SCLK_INDEX_SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nif ((!pi->mclk_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask) {\r\nlevels = ci_get_lowest_enabled_level(rdev,\r\npi->dpm_level_enable_mask.mclk_dpm_enable_mask);\r\nret = ci_dpm_force_state_mclk(rdev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) &\r\nCURR_MCLK_INDEX_MASK) >> CURR_MCLK_INDEX_SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nif ((!pi->pcie_dpm_key_disabled) &&\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask) {\r\nlevels = ci_get_lowest_enabled_level(rdev,\r\npi->dpm_level_enable_mask.pcie_dpm_enable_mask);\r\nret = ci_dpm_force_state_pcie(rdev, levels);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = (RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX_1) &\r\nCURR_PCIE_INDEX_MASK) >> CURR_PCIE_INDEX_SHIFT;\r\nif (tmp == levels)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_AUTO) {\r\nif (!pi->pcie_dpm_key_disabled) {\r\nPPSMC_Result smc_result;\r\nsmc_result = ci_send_msg_to_smc(rdev,\r\nPPSMC_MSG_PCIeDPM_UnForceLevel);\r\nif (smc_result != PPSMC_Result_OK)\r\nreturn -EINVAL;\r\n}\r\nret = ci_upload_dpm_level_enable_mask(rdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nrdev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}\r\nstatic int ci_set_mc_special_registers(struct radeon_device *rdev,\r\nstruct ci_mc_reg_table *table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu8 i, j, k;\r\nu32 temp_reg;\r\nfor (i = 0, j = table->last; i < table->last; i++) {\r\nif (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nswitch(table->mc_reg_address[i].s1 << 2) {\r\ncase MC_SEQ_MISC1:\r\ntemp_reg = RREG32(MC_PMG_CMD_EMRS);\r\ntable->mc_reg_address[j].s1 = MC_PMG_CMD_EMRS >> 2;\r\ntable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n((temp_reg & 0xffff0000)) | ((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\r\n}\r\nj++;\r\nif (j >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\ntemp_reg = RREG32(MC_PMG_CMD_MRS);\r\ntable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS >> 2;\r\ntable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) | (table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\nif (!pi->mem_gddr5)\r\ntable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\r\n}\r\nj++;\r\nif (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nif (!pi->mem_gddr5) {\r\ntable->mc_reg_address[j].s1 = MC_PMG_AUTO_CMD >> 2;\r\ntable->mc_reg_address[j].s0 = MC_PMG_AUTO_CMD >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;\r\n}\r\nj++;\r\nif (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase MC_SEQ_RESERVE_M:\r\ntemp_reg = RREG32(MC_PMG_CMD_MRS1);\r\ntable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS1 >> 2;\r\ntable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\r\nfor (k = 0; k < table->num_entries; k++) {\r\ntable->mc_reg_table_entry[k].mc_data[j] =\r\n(temp_reg & 0xffff0000) | (table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\r\n}\r\nj++;\r\nif (j > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ntable->last = j;\r\nreturn 0;\r\n}\r\nstatic bool ci_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)\r\n{\r\nbool result = true;\r\nswitch(in_reg) {\r\ncase MC_SEQ_RAS_TIMING >> 2:\r\n*out_reg = MC_SEQ_RAS_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_DLL_STBY >> 2:\r\n*out_reg = MC_SEQ_DLL_STBY_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_G5PDX_CMD0 >> 2:\r\n*out_reg = MC_SEQ_G5PDX_CMD0_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_G5PDX_CMD1 >> 2:\r\n*out_reg = MC_SEQ_G5PDX_CMD1_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_G5PDX_CTRL >> 2:\r\n*out_reg = MC_SEQ_G5PDX_CTRL_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_CAS_TIMING >> 2:\r\n*out_reg = MC_SEQ_CAS_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_MISC_TIMING >> 2:\r\n*out_reg = MC_SEQ_MISC_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_MISC_TIMING2 >> 2:\r\n*out_reg = MC_SEQ_MISC_TIMING2_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_PMG_DVS_CMD >> 2:\r\n*out_reg = MC_SEQ_PMG_DVS_CMD_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_PMG_DVS_CTL >> 2:\r\n*out_reg = MC_SEQ_PMG_DVS_CTL_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_RD_CTL_D0 >> 2:\r\n*out_reg = MC_SEQ_RD_CTL_D0_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_RD_CTL_D1 >> 2:\r\n*out_reg = MC_SEQ_RD_CTL_D1_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_WR_CTL_D0 >> 2:\r\n*out_reg = MC_SEQ_WR_CTL_D0_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_WR_CTL_D1 >> 2:\r\n*out_reg = MC_SEQ_WR_CTL_D1_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_EMRS >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_MRS >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_MRS_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_MRS1 >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_PMG_TIMING >> 2:\r\n*out_reg = MC_SEQ_PMG_TIMING_LP >> 2;\r\nbreak;\r\ncase MC_PMG_CMD_MRS2 >> 2:\r\n*out_reg = MC_SEQ_PMG_CMD_MRS2_LP >> 2;\r\nbreak;\r\ncase MC_SEQ_WR_CTL_2 >> 2:\r\n*out_reg = MC_SEQ_WR_CTL_2_LP >> 2;\r\nbreak;\r\ndefault:\r\nresult = false;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void ci_set_valid_flag(struct ci_mc_reg_table *table)\r\n{\r\nu8 i, j;\r\nfor (i = 0; i < table->last; i++) {\r\nfor (j = 1; j < table->num_entries; j++) {\r\nif (table->mc_reg_table_entry[j-1].mc_data[i] !=\r\ntable->mc_reg_table_entry[j].mc_data[i]) {\r\ntable->valid_flag |= 1 << i;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void ci_set_s0_mc_reg_index(struct ci_mc_reg_table *table)\r\n{\r\nu32 i;\r\nu16 address;\r\nfor (i = 0; i < table->last; i++) {\r\ntable->mc_reg_address[i].s0 =\r\nci_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?\r\naddress : table->mc_reg_address[i].s1;\r\n}\r\n}\r\nstatic int ci_copy_vbios_mc_reg_table(const struct atom_mc_reg_table *table,\r\nstruct ci_mc_reg_table *ci_table)\r\n{\r\nu8 i, j;\r\nif (table->last > SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nif (table->num_entries > MAX_AC_TIMING_ENTRIES)\r\nreturn -EINVAL;\r\nfor (i = 0; i < table->last; i++)\r\nci_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\r\nci_table->last = table->last;\r\nfor (i = 0; i < table->num_entries; i++) {\r\nci_table->mc_reg_table_entry[i].mclk_max =\r\ntable->mc_reg_table_entry[i].mclk_max;\r\nfor (j = 0; j < table->last; j++)\r\nci_table->mc_reg_table_entry[i].mc_data[j] =\r\ntable->mc_reg_table_entry[i].mc_data[j];\r\n}\r\nci_table->num_entries = table->num_entries;\r\nreturn 0;\r\n}\r\nstatic int ci_register_patching_mc_seq(struct radeon_device *rdev,\r\nstruct ci_mc_reg_table *table)\r\n{\r\nu8 i, k;\r\nu32 tmp;\r\nbool patch;\r\ntmp = RREG32(MC_SEQ_MISC0);\r\npatch = ((tmp & 0x0000f00) == 0x300) ? true : false;\r\nif (patch &&\r\n((rdev->pdev->device == 0x67B0) ||\r\n(rdev->pdev->device == 0x67B1))) {\r\nfor (i = 0; i < table->last; i++) {\r\nif (table->last >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nswitch(table->mc_reg_address[i].s1 >> 2) {\r\ncase MC_SEQ_MISC1:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFF8) |\r\n0x00000007;\r\n}\r\nbreak;\r\ncase MC_SEQ_WR_CTL_D0:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFF0F00) |\r\n0x0000D0DD;\r\n}\r\nbreak;\r\ncase MC_SEQ_WR_CTL_D1:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFF0F00) |\r\n0x0000D0DD;\r\n}\r\nbreak;\r\ncase MC_SEQ_WR_CTL_2:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif ((table->mc_reg_table_entry[k].mclk_max == 125000) ||\r\n(table->mc_reg_table_entry[k].mclk_max == 137500))\r\ntable->mc_reg_table_entry[k].mc_data[i] = 0;\r\n}\r\nbreak;\r\ncase MC_SEQ_CAS_TIMING:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif (table->mc_reg_table_entry[k].mclk_max == 125000)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFE0FE0F) |\r\n0x000C0140;\r\nelse if (table->mc_reg_table_entry[k].mclk_max == 137500)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFE0FE0F) |\r\n0x000C0150;\r\n}\r\nbreak;\r\ncase MC_SEQ_MISC_TIMING:\r\nfor (k = 0; k < table->num_entries; k++) {\r\nif (table->mc_reg_table_entry[k].mclk_max == 125000)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFE0) |\r\n0x00000030;\r\nelse if (table->mc_reg_table_entry[k].mclk_max == 137500)\r\ntable->mc_reg_table_entry[k].mc_data[i] =\r\n(table->mc_reg_table_entry[k].mc_data[i] & 0xFFFFFFE0) |\r\n0x00000035;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nWREG32(MC_SEQ_IO_DEBUG_INDEX, 3);\r\ntmp = RREG32(MC_SEQ_IO_DEBUG_DATA);\r\ntmp = (tmp & 0xFFF8FFFF) | (1 << 16);\r\nWREG32(MC_SEQ_IO_DEBUG_INDEX, 3);\r\nWREG32(MC_SEQ_IO_DEBUG_DATA, tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_initialize_mc_reg_table(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct atom_mc_reg_table *table;\r\nstruct ci_mc_reg_table *ci_table = &pi->mc_reg_table;\r\nu8 module_index = rv770_get_memory_module_index(rdev);\r\nint ret;\r\ntable = kzalloc(sizeof(struct atom_mc_reg_table), GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nWREG32(MC_SEQ_RAS_TIMING_LP, RREG32(MC_SEQ_RAS_TIMING));\r\nWREG32(MC_SEQ_CAS_TIMING_LP, RREG32(MC_SEQ_CAS_TIMING));\r\nWREG32(MC_SEQ_DLL_STBY_LP, RREG32(MC_SEQ_DLL_STBY));\r\nWREG32(MC_SEQ_G5PDX_CMD0_LP, RREG32(MC_SEQ_G5PDX_CMD0));\r\nWREG32(MC_SEQ_G5PDX_CMD1_LP, RREG32(MC_SEQ_G5PDX_CMD1));\r\nWREG32(MC_SEQ_G5PDX_CTRL_LP, RREG32(MC_SEQ_G5PDX_CTRL));\r\nWREG32(MC_SEQ_PMG_DVS_CMD_LP, RREG32(MC_SEQ_PMG_DVS_CMD));\r\nWREG32(MC_SEQ_PMG_DVS_CTL_LP, RREG32(MC_SEQ_PMG_DVS_CTL));\r\nWREG32(MC_SEQ_MISC_TIMING_LP, RREG32(MC_SEQ_MISC_TIMING));\r\nWREG32(MC_SEQ_MISC_TIMING2_LP, RREG32(MC_SEQ_MISC_TIMING2));\r\nWREG32(MC_SEQ_PMG_CMD_EMRS_LP, RREG32(MC_PMG_CMD_EMRS));\r\nWREG32(MC_SEQ_PMG_CMD_MRS_LP, RREG32(MC_PMG_CMD_MRS));\r\nWREG32(MC_SEQ_PMG_CMD_MRS1_LP, RREG32(MC_PMG_CMD_MRS1));\r\nWREG32(MC_SEQ_WR_CTL_D0_LP, RREG32(MC_SEQ_WR_CTL_D0));\r\nWREG32(MC_SEQ_WR_CTL_D1_LP, RREG32(MC_SEQ_WR_CTL_D1));\r\nWREG32(MC_SEQ_RD_CTL_D0_LP, RREG32(MC_SEQ_RD_CTL_D0));\r\nWREG32(MC_SEQ_RD_CTL_D1_LP, RREG32(MC_SEQ_RD_CTL_D1));\r\nWREG32(MC_SEQ_PMG_TIMING_LP, RREG32(MC_SEQ_PMG_TIMING));\r\nWREG32(MC_SEQ_PMG_CMD_MRS2_LP, RREG32(MC_PMG_CMD_MRS2));\r\nWREG32(MC_SEQ_WR_CTL_2_LP, RREG32(MC_SEQ_WR_CTL_2));\r\nret = radeon_atom_init_mc_reg_table(rdev, module_index, table);\r\nif (ret)\r\ngoto init_mc_done;\r\nret = ci_copy_vbios_mc_reg_table(table, ci_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nci_set_s0_mc_reg_index(ci_table);\r\nret = ci_register_patching_mc_seq(rdev, ci_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nret = ci_set_mc_special_registers(rdev, ci_table);\r\nif (ret)\r\ngoto init_mc_done;\r\nci_set_valid_flag(ci_table);\r\ninit_mc_done:\r\nkfree(table);\r\nreturn ret;\r\n}\r\nstatic int ci_populate_mc_reg_addresses(struct radeon_device *rdev,\r\nSMU7_Discrete_MCRegisters *mc_reg_table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 i, j;\r\nfor (i = 0, j = 0; j < pi->mc_reg_table.last; j++) {\r\nif (pi->mc_reg_table.valid_flag & (1 << j)) {\r\nif (i >= SMU7_DISCRETE_MC_REGISTER_ARRAY_SIZE)\r\nreturn -EINVAL;\r\nmc_reg_table->address[i].s0 = cpu_to_be16(pi->mc_reg_table.mc_reg_address[j].s0);\r\nmc_reg_table->address[i].s1 = cpu_to_be16(pi->mc_reg_table.mc_reg_address[j].s1);\r\ni++;\r\n}\r\n}\r\nmc_reg_table->last = (u8)i;\r\nreturn 0;\r\n}\r\nstatic void ci_convert_mc_registers(const struct ci_mc_reg_entry *entry,\r\nSMU7_Discrete_MCRegisterSet *data,\r\nu32 num_entries, u32 valid_flag)\r\n{\r\nu32 i, j;\r\nfor (i = 0, j = 0; j < num_entries; j++) {\r\nif (valid_flag & (1 << j)) {\r\ndata->value[i] = cpu_to_be32(entry->mc_data[j]);\r\ni++;\r\n}\r\n}\r\n}\r\nstatic void ci_convert_mc_reg_table_entry_to_smc(struct radeon_device *rdev,\r\nconst u32 memory_clock,\r\nSMU7_Discrete_MCRegisterSet *mc_reg_table_data)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 i = 0;\r\nfor(i = 0; i < pi->mc_reg_table.num_entries; i++) {\r\nif (memory_clock <= pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)\r\nbreak;\r\n}\r\nif ((i == pi->mc_reg_table.num_entries) && (i > 0))\r\n--i;\r\nci_convert_mc_registers(&pi->mc_reg_table.mc_reg_table_entry[i],\r\nmc_reg_table_data, pi->mc_reg_table.last,\r\npi->mc_reg_table.valid_flag);\r\n}\r\nstatic void ci_convert_mc_reg_table_to_smc(struct radeon_device *rdev,\r\nSMU7_Discrete_MCRegisters *mc_reg_table)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 i;\r\nfor (i = 0; i < pi->dpm_table.mclk_table.count; i++)\r\nci_convert_mc_reg_table_entry_to_smc(rdev,\r\npi->dpm_table.mclk_table.dpm_levels[i].value,\r\n&mc_reg_table->data[i]);\r\n}\r\nstatic int ci_populate_initial_mc_reg_table(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nint ret;\r\nmemset(&pi->smc_mc_reg_table, 0, sizeof(SMU7_Discrete_MCRegisters));\r\nret = ci_populate_mc_reg_addresses(rdev, &pi->smc_mc_reg_table);\r\nif (ret)\r\nreturn ret;\r\nci_convert_mc_reg_table_to_smc(rdev, &pi->smc_mc_reg_table);\r\nreturn ci_copy_bytes_to_smc(rdev,\r\npi->mc_reg_table_start,\r\n(u8 *)&pi->smc_mc_reg_table,\r\nsizeof(SMU7_Discrete_MCRegisters),\r\npi->sram_end);\r\n}\r\nstatic int ci_update_and_upload_mc_reg_table(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nif (!(pi->need_update_smu7_dpm_table & DPMTABLE_OD_UPDATE_MCLK))\r\nreturn 0;\r\nmemset(&pi->smc_mc_reg_table, 0, sizeof(SMU7_Discrete_MCRegisters));\r\nci_convert_mc_reg_table_to_smc(rdev, &pi->smc_mc_reg_table);\r\nreturn ci_copy_bytes_to_smc(rdev,\r\npi->mc_reg_table_start +\r\noffsetof(SMU7_Discrete_MCRegisters, data[0]),\r\n(u8 *)&pi->smc_mc_reg_table.data[0],\r\nsizeof(SMU7_Discrete_MCRegisterSet) *\r\npi->dpm_table.mclk_table.count,\r\npi->sram_end);\r\n}\r\nstatic void ci_enable_voltage_control(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp |= VOLT_PWRMGT_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\n}\r\nstatic enum radeon_pcie_gen ci_get_maximum_link_speed(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_state)\r\n{\r\nstruct ci_ps *state = ci_get_ps(radeon_state);\r\nint i;\r\nu16 pcie_speed, max_speed = 0;\r\nfor (i = 0; i < state->performance_level_count; i++) {\r\npcie_speed = state->performance_levels[i].pcie_gen;\r\nif (max_speed < pcie_speed)\r\nmax_speed = pcie_speed;\r\n}\r\nreturn max_speed;\r\n}\r\nstatic u16 ci_get_current_pcie_speed(struct radeon_device *rdev)\r\n{\r\nu32 speed_cntl = 0;\r\nspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & LC_CURRENT_DATA_RATE_MASK;\r\nspeed_cntl >>= LC_CURRENT_DATA_RATE_SHIFT;\r\nreturn (u16)speed_cntl;\r\n}\r\nstatic int ci_get_current_pcie_lane_number(struct radeon_device *rdev)\r\n{\r\nu32 link_width = 0;\r\nlink_width = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL) & LC_LINK_WIDTH_RD_MASK;\r\nlink_width >>= LC_LINK_WIDTH_RD_SHIFT;\r\nswitch (link_width) {\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X1:\r\nreturn 1;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X2:\r\nreturn 2;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X4:\r\nreturn 4;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X8:\r\nreturn 8;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X12:\r\nreturn 12;\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X0:\r\ncase RADEON_PCIE_LC_LINK_WIDTH_X16:\r\ndefault:\r\nreturn 16;\r\n}\r\n}\r\nstatic void ci_request_link_speed_change_before_state_change(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nenum radeon_pcie_gen target_link_speed =\r\nci_get_maximum_link_speed(rdev, radeon_new_state);\r\nenum radeon_pcie_gen current_link_speed;\r\nif (pi->force_pcie_gen == RADEON_PCIE_GEN_INVALID)\r\ncurrent_link_speed = ci_get_maximum_link_speed(rdev, radeon_current_state);\r\nelse\r\ncurrent_link_speed = pi->force_pcie_gen;\r\npi->force_pcie_gen = RADEON_PCIE_GEN_INVALID;\r\npi->pspp_notify_required = false;\r\nif (target_link_speed > current_link_speed) {\r\nswitch (target_link_speed) {\r\n#ifdef CONFIG_ACPI\r\ncase RADEON_PCIE_GEN3:\r\nif (radeon_acpi_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN3, false) == 0)\r\nbreak;\r\npi->force_pcie_gen = RADEON_PCIE_GEN2;\r\nif (current_link_speed == RADEON_PCIE_GEN2)\r\nbreak;\r\ncase RADEON_PCIE_GEN2:\r\nif (radeon_acpi_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)\r\nbreak;\r\n#endif\r\ndefault:\r\npi->force_pcie_gen = ci_get_current_pcie_speed(rdev);\r\nbreak;\r\n}\r\n} else {\r\nif (target_link_speed < current_link_speed)\r\npi->pspp_notify_required = true;\r\n}\r\n}\r\nstatic void ci_notify_link_speed_change_after_state_change(struct radeon_device *rdev,\r\nstruct radeon_ps *radeon_new_state,\r\nstruct radeon_ps *radeon_current_state)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nenum radeon_pcie_gen target_link_speed =\r\nci_get_maximum_link_speed(rdev, radeon_new_state);\r\nu8 request;\r\nif (pi->pspp_notify_required) {\r\nif (target_link_speed == RADEON_PCIE_GEN3)\r\nrequest = PCIE_PERF_REQ_PECI_GEN3;\r\nelse if (target_link_speed == RADEON_PCIE_GEN2)\r\nrequest = PCIE_PERF_REQ_PECI_GEN2;\r\nelse\r\nrequest = PCIE_PERF_REQ_PECI_GEN1;\r\nif ((request == PCIE_PERF_REQ_PECI_GEN1) &&\r\n(ci_get_current_pcie_speed(rdev) > 0))\r\nreturn;\r\n#ifdef CONFIG_ACPI\r\nradeon_acpi_pcie_performance_request(rdev, request, false);\r\n#endif\r\n}\r\n}\r\nstatic int ci_set_private_data_variables_based_on_pptable(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *allowed_sclk_vddc_table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nstruct radeon_clock_voltage_dependency_table *allowed_mclk_vddc_table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk;\r\nstruct radeon_clock_voltage_dependency_table *allowed_mclk_vddci_table =\r\n&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk;\r\nif (allowed_sclk_vddc_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_sclk_vddc_table->count < 1)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddc_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddc_table->count < 1)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddci_table == NULL)\r\nreturn -EINVAL;\r\nif (allowed_mclk_vddci_table->count < 1)\r\nreturn -EINVAL;\r\npi->min_vddc_in_pp_table = allowed_sclk_vddc_table->entries[0].v;\r\npi->max_vddc_in_pp_table =\r\nallowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].v;\r\npi->min_vddci_in_pp_table = allowed_mclk_vddci_table->entries[0].v;\r\npi->max_vddci_in_pp_table =\r\nallowed_mclk_vddci_table->entries[allowed_mclk_vddci_table->count - 1].v;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk =\r\nallowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].clk;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.mclk =\r\nallowed_mclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].clk;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddc =\r\nallowed_sclk_vddc_table->entries[allowed_sclk_vddc_table->count - 1].v;\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddci =\r\nallowed_mclk_vddci_table->entries[allowed_mclk_vddci_table->count - 1].v;\r\nreturn 0;\r\n}\r\nstatic void ci_patch_with_vddc_leakage(struct radeon_device *rdev, u16 *vddc)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_leakage_voltage *leakage_table = &pi->vddc_leakage;\r\nu32 leakage_index;\r\nfor (leakage_index = 0; leakage_index < leakage_table->count; leakage_index++) {\r\nif (leakage_table->leakage_id[leakage_index] == *vddc) {\r\n*vddc = leakage_table->actual_voltage[leakage_index];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ci_patch_with_vddci_leakage(struct radeon_device *rdev, u16 *vddci)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_leakage_voltage *leakage_table = &pi->vddci_leakage;\r\nu32 leakage_index;\r\nfor (leakage_index = 0; leakage_index < leakage_table->count; leakage_index++) {\r\nif (leakage_table->leakage_id[leakage_index] == *vddci) {\r\n*vddci = leakage_table->actual_voltage[leakage_index];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ci_patch_clock_voltage_dependency_table_with_vddc_leakage(struct radeon_device *rdev,\r\nstruct radeon_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(rdev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_clock_voltage_dependency_table_with_vddci_leakage(struct radeon_device *rdev,\r\nstruct radeon_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddci_leakage(rdev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_vce_clock_voltage_dependency_table_with_vddc_leakage(struct radeon_device *rdev,\r\nstruct radeon_vce_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(rdev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_uvd_clock_voltage_dependency_table_with_vddc_leakage(struct radeon_device *rdev,\r\nstruct radeon_uvd_clock_voltage_dependency_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(rdev, &table->entries[i].v);\r\n}\r\n}\r\nstatic void ci_patch_vddc_phase_shed_limit_table_with_vddc_leakage(struct radeon_device *rdev,\r\nstruct radeon_phase_shedding_limits_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(rdev, &table->entries[i].voltage);\r\n}\r\n}\r\nstatic void ci_patch_clock_voltage_limits_with_vddc_leakage(struct radeon_device *rdev,\r\nstruct radeon_clock_and_voltage_limits *table)\r\n{\r\nif (table) {\r\nci_patch_with_vddc_leakage(rdev, (u16 *)&table->vddc);\r\nci_patch_with_vddci_leakage(rdev, (u16 *)&table->vddci);\r\n}\r\n}\r\nstatic void ci_patch_cac_leakage_table_with_vddc_leakage(struct radeon_device *rdev,\r\nstruct radeon_cac_leakage_table *table)\r\n{\r\nu32 i;\r\nif (table) {\r\nfor (i = 0; i < table->count; i++)\r\nci_patch_with_vddc_leakage(rdev, &table->entries[i].vddc);\r\n}\r\n}\r\nstatic void ci_patch_dependency_tables_with_leakage(struct radeon_device *rdev)\r\n{\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk);\r\nci_patch_clock_voltage_dependency_table_with_vddci_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk);\r\nci_patch_vce_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table);\r\nci_patch_uvd_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table);\r\nci_patch_clock_voltage_dependency_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table);\r\nci_patch_vddc_phase_shed_limit_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.phase_shedding_limits_table);\r\nci_patch_clock_voltage_limits_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac);\r\nci_patch_clock_voltage_limits_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc);\r\nci_patch_cac_leakage_table_with_vddc_leakage(rdev,\r\n&rdev->pm.dpm.dyn_state.cac_leakage_table);\r\n}\r\nstatic void ci_get_memory_type(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nu32 tmp;\r\ntmp = RREG32(MC_SEQ_MISC0);\r\nif (((tmp & MC_SEQ_MISC0_GDDR5_MASK) >> MC_SEQ_MISC0_GDDR5_SHIFT) ==\r\nMC_SEQ_MISC0_GDDR5_VALUE)\r\npi->mem_gddr5 = true;\r\nelse\r\npi->mem_gddr5 = false;\r\n}\r\nstatic void ci_update_current_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct ci_ps *new_ps = ci_get_ps(rps);\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\npi->current_rps = *rps;\r\npi->current_ps = *new_ps;\r\npi->current_rps.ps_priv = &pi->current_ps;\r\n}\r\nstatic void ci_update_requested_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct ci_ps *new_ps = ci_get_ps(rps);\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\npi->requested_rps = *rps;\r\npi->requested_ps = *new_ps;\r\npi->requested_rps.ps_priv = &pi->requested_ps;\r\n}\r\nint ci_dpm_pre_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *new_ps = &requested_ps;\r\nci_update_requested_ps(rdev, new_ps);\r\nci_apply_state_adjust_rules(rdev, &pi->requested_rps);\r\nreturn 0;\r\n}\r\nvoid ci_dpm_post_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nci_update_current_ps(rdev, new_ps);\r\n}\r\nvoid ci_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr = ci_mc_load_microcode(rdev);\r\nif (r)\r\nDRM_ERROR("Failed to load MC firmware!\n");\r\nci_read_clock_registers(rdev);\r\nci_get_memory_type(rdev);\r\nci_enable_acpi_power_management(rdev);\r\nci_init_sclk_t(rdev);\r\n}\r\nint ci_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nint ret;\r\nif (ci_is_smc_running(rdev))\r\nreturn -EINVAL;\r\nif (pi->voltage_control != CISLANDS_VOLTAGE_CONTROL_NONE) {\r\nci_enable_voltage_control(rdev);\r\nret = ci_construct_voltage_tables(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_construct_voltage_tables failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (pi->caps_dynamic_ac_timing) {\r\nret = ci_initialize_mc_reg_table(rdev);\r\nif (ret)\r\npi->caps_dynamic_ac_timing = false;\r\n}\r\nif (pi->dynamic_ss)\r\nci_enable_spread_spectrum(rdev, true);\r\nif (pi->thermal_protection)\r\nci_enable_thermal_protection(rdev, true);\r\nci_program_sstp(rdev);\r\nci_enable_display_gap(rdev);\r\nci_program_vc(rdev);\r\nret = ci_upload_firmware(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_upload_firmware failed\n");\r\nreturn ret;\r\n}\r\nret = ci_process_firmware_header(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_process_firmware_header failed\n");\r\nreturn ret;\r\n}\r\nret = ci_initial_switch_from_arb_f0_to_f1(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_initial_switch_from_arb_f0_to_f1 failed\n");\r\nreturn ret;\r\n}\r\nret = ci_init_smc_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_init_smc_table failed\n");\r\nreturn ret;\r\n}\r\nret = ci_init_arb_table_index(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_init_arb_table_index failed\n");\r\nreturn ret;\r\n}\r\nif (pi->caps_dynamic_ac_timing) {\r\nret = ci_populate_initial_mc_reg_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_populate_initial_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = ci_populate_pm_base(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_populate_pm_base failed\n");\r\nreturn ret;\r\n}\r\nci_dpm_start_smc(rdev);\r\nci_enable_vr_hot_gpio_interrupt(rdev);\r\nret = ci_notify_smc_display_change(rdev, false);\r\nif (ret) {\r\nDRM_ERROR("ci_notify_smc_display_change failed\n");\r\nreturn ret;\r\n}\r\nci_enable_sclk_control(rdev, true);\r\nret = ci_enable_ulv(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_ulv failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_ds_master_switch(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_ds_master_switch failed\n");\r\nreturn ret;\r\n}\r\nret = ci_start_dpm(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_start_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_didt(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_didt failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_smc_cac(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_smc_cac failed\n");\r\nreturn ret;\r\n}\r\nret = ci_enable_power_containment(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_power_containment failed\n");\r\nreturn ret;\r\n}\r\nret = ci_power_control_set_level(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_power_control_set_level failed\n");\r\nreturn ret;\r\n}\r\nci_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\r\nret = ci_enable_thermal_based_sclk_dpm(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("ci_enable_thermal_based_sclk_dpm failed\n");\r\nreturn ret;\r\n}\r\nci_thermal_start_thermal_controller(rdev);\r\nci_update_current_ps(rdev, boot_ps);\r\nreturn 0;\r\n}\r\nstatic int ci_set_temperature_range(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nret = ci_thermal_enable_alert(rdev, false);\r\nif (ret)\r\nreturn ret;\r\nret = ci_thermal_set_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nret = ci_thermal_enable_alert(rdev, true);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nint ci_dpm_late_enable(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nret = ci_set_temperature_range(rdev);\r\nif (ret)\r\nreturn ret;\r\nci_dpm_powergate_uvd(rdev, true);\r\nreturn 0;\r\n}\r\nvoid ci_dpm_disable(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\r\nci_dpm_powergate_uvd(rdev, false);\r\nif (!ci_is_smc_running(rdev))\r\nreturn;\r\nci_thermal_stop_thermal_controller(rdev);\r\nif (pi->thermal_protection)\r\nci_enable_thermal_protection(rdev, false);\r\nci_enable_power_containment(rdev, false);\r\nci_enable_smc_cac(rdev, false);\r\nci_enable_didt(rdev, false);\r\nci_enable_spread_spectrum(rdev, false);\r\nci_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, false);\r\nci_stop_dpm(rdev);\r\nci_enable_ds_master_switch(rdev, false);\r\nci_enable_ulv(rdev, false);\r\nci_clear_vc(rdev);\r\nci_reset_to_default(rdev);\r\nci_dpm_stop_smc(rdev);\r\nci_force_switch_to_arb_f0(rdev);\r\nci_enable_thermal_based_sclk_dpm(rdev, false);\r\nci_update_current_ps(rdev, boot_ps);\r\n}\r\nint ci_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nstruct radeon_ps *old_ps = &pi->current_rps;\r\nint ret;\r\nci_find_dpm_states_clocks_in_dpm_table(rdev, new_ps);\r\nif (pi->pcie_performance_request)\r\nci_request_link_speed_change_before_state_change(rdev, new_ps, old_ps);\r\nret = ci_freeze_sclk_mclk_dpm(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_freeze_sclk_mclk_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_populate_and_upload_sclk_mclk_dpm_levels(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("ci_populate_and_upload_sclk_mclk_dpm_levels failed\n");\r\nreturn ret;\r\n}\r\nret = ci_generate_dpm_level_enable_mask(rdev, new_ps);\r\nif (ret) {\r\nDRM_ERROR("ci_generate_dpm_level_enable_mask failed\n");\r\nreturn ret;\r\n}\r\nret = ci_update_vce_dpm(rdev, new_ps, old_ps);\r\nif (ret) {\r\nDRM_ERROR("ci_update_vce_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_update_sclk_t(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_update_sclk_t failed\n");\r\nreturn ret;\r\n}\r\nif (pi->caps_dynamic_ac_timing) {\r\nret = ci_update_and_upload_mc_reg_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_update_and_upload_mc_reg_table failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = ci_program_memory_timing_parameters(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_program_memory_timing_parameters failed\n");\r\nreturn ret;\r\n}\r\nret = ci_unfreeze_sclk_mclk_dpm(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_unfreeze_sclk_mclk_dpm failed\n");\r\nreturn ret;\r\n}\r\nret = ci_upload_dpm_level_enable_mask(rdev);\r\nif (ret) {\r\nDRM_ERROR("ci_upload_dpm_level_enable_mask failed\n");\r\nreturn ret;\r\n}\r\nif (pi->pcie_performance_request)\r\nci_notify_link_speed_change_after_state_change(rdev, new_ps, old_ps);\r\nreturn 0;\r\n}\r\nvoid ci_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\nci_program_display_gap(rdev);\r\n}\r\nstatic void ci_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\r\nu8 table_rev)\r\n{\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\r\nrps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\r\nrps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nrdev->pm.dpm.boot_ps = rps;\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nrdev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void ci_parse_pplib_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ps *ps = ci_get_ps(rps);\r\nstruct ci_pl *pl = &ps->performance_levels[index];\r\nps->performance_level_count = index + 1;\r\npl->sclk = le16_to_cpu(clock_info->ci.usEngineClockLow);\r\npl->sclk |= clock_info->ci.ucEngineClockHigh << 16;\r\npl->mclk = le16_to_cpu(clock_info->ci.usMemoryClockLow);\r\npl->mclk |= clock_info->ci.ucMemoryClockHigh << 16;\r\npl->pcie_gen = r600_get_pcie_gen_support(rdev,\r\npi->sys_pcie_mask,\r\npi->vbios_boot_state.pcie_gen_bootup_value,\r\nclock_info->ci.ucPCIEGen);\r\npl->pcie_lane = r600_get_pcie_lane_support(rdev,\r\npi->vbios_boot_state.pcie_lane_bootup_value,\r\nle16_to_cpu(clock_info->ci.usPCIELane));\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) {\r\npi->acpi_pcie_gen = pl->pcie_gen;\r\n}\r\nif (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) {\r\npi->ulv.supported = true;\r\npi->ulv.pl = *pl;\r\npi->ulv.cg_ulv_parameter = CISLANDS_CGULVPARAMETER_DFLT;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\npl->mclk = pi->vbios_boot_state.mclk_bootup_value;\r\npl->sclk = pi->vbios_boot_state.sclk_bootup_value;\r\npl->pcie_gen = pi->vbios_boot_state.pcie_gen_bootup_value;\r\npl->pcie_lane = pi->vbios_boot_state.pcie_lane_bootup_value;\r\n}\r\nswitch (rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\r\npi->use_pcie_powersaving_levels = true;\r\nif (pi->pcie_gen_powersaving.max < pl->pcie_gen)\r\npi->pcie_gen_powersaving.max = pl->pcie_gen;\r\nif (pi->pcie_gen_powersaving.min > pl->pcie_gen)\r\npi->pcie_gen_powersaving.min = pl->pcie_gen;\r\nif (pi->pcie_lane_powersaving.max < pl->pcie_lane)\r\npi->pcie_lane_powersaving.max = pl->pcie_lane;\r\nif (pi->pcie_lane_powersaving.min > pl->pcie_lane)\r\npi->pcie_lane_powersaving.min = pl->pcie_lane;\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\r\npi->use_pcie_performance_levels = true;\r\nif (pi->pcie_gen_performance.max < pl->pcie_gen)\r\npi->pcie_gen_performance.max = pl->pcie_gen;\r\nif (pi->pcie_gen_performance.min > pl->pcie_gen)\r\npi->pcie_gen_performance.min = pl->pcie_gen;\r\nif (pi->pcie_lane_performance.max < pl->pcie_lane)\r\npi->pcie_lane_performance.max = pl->pcie_lane;\r\nif (pi->pcie_lane_performance.min > pl->pcie_lane)\r\npi->pcie_lane_performance.min = pl->pcie_lane;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int ci_parse_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j, k, non_clock_array_index, clock_array_index;\r\nunion pplib_clock_info *clock_info;\r\nstruct _StateArray *state_array;\r\nstruct _ClockInfoArray *clock_info_array;\r\nstruct _NonClockInfoArray *non_clock_info_array;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nu8 *power_state_offset;\r\nstruct ci_ps *ps;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nstate_array = (struct _StateArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset));\r\nclock_info_array = (struct _ClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\r\nnon_clock_info_array = (struct _NonClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\r\nrdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *\r\nstate_array->ucNumEntries, GFP_KERNEL);\r\nif (!rdev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\npower_state_offset = (u8 *)state_array->states;\r\nfor (i = 0; i < state_array->ucNumEntries; i++) {\r\nu8 *idx;\r\npower_state = (union pplib_power_state *)power_state_offset;\r\nnon_clock_array_index = power_state->v2.nonClockInfoIndex;\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n&non_clock_info_array->nonClockInfo[non_clock_array_index];\r\nif (!rdev->pm.power_state[i].clock_info)\r\nreturn -EINVAL;\r\nps = kzalloc(sizeof(struct ci_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(rdev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.ps[i].ps_priv = ps;\r\nci_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\r\nnon_clock_info,\r\nnon_clock_info_array->ucEntrySize);\r\nk = 0;\r\nidx = (u8 *)&power_state->v2.clockInfoIndex[0];\r\nfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\r\nclock_array_index = idx[j];\r\nif (clock_array_index >= clock_info_array->ucNumEntries)\r\ncontinue;\r\nif (k >= CISLANDS_MAX_HARDWARE_POWERLEVELS)\r\nbreak;\r\nclock_info = (union pplib_clock_info *)\r\n((u8 *)&clock_info_array->clockInfo[0] +\r\n(clock_array_index * clock_info_array->ucEntrySize));\r\nci_parse_pplib_clock_info(rdev,\r\n&rdev->pm.dpm.ps[i], k,\r\nclock_info);\r\nk++;\r\n}\r\npower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\r\n}\r\nrdev->pm.dpm.num_ps = state_array->ucNumEntries;\r\nfor (i = 0; i < RADEON_MAX_VCE_LEVELS; i++) {\r\nu32 sclk, mclk;\r\nclock_array_index = rdev->pm.dpm.vce_states[i].clk_idx;\r\nclock_info = (union pplib_clock_info *)\r\n&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\r\nsclk = le16_to_cpu(clock_info->ci.usEngineClockLow);\r\nsclk |= clock_info->ci.ucEngineClockHigh << 16;\r\nmclk = le16_to_cpu(clock_info->ci.usMemoryClockLow);\r\nmclk |= clock_info->ci.ucMemoryClockHigh << 16;\r\nrdev->pm.dpm.vce_states[i].sclk = sclk;\r\nrdev->pm.dpm.vce_states[i].mclk = mclk;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_get_vbios_boot_values(struct radeon_device *rdev,\r\nstruct ci_vbios_boot_state *boot_state)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\r\nATOM_FIRMWARE_INFO_V2_2 *firmware_info;\r\nu8 frev, crev;\r\nu16 data_offset;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nfirmware_info =\r\n(ATOM_FIRMWARE_INFO_V2_2 *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nboot_state->mvdd_bootup_value = le16_to_cpu(firmware_info->usBootUpMVDDCVoltage);\r\nboot_state->vddc_bootup_value = le16_to_cpu(firmware_info->usBootUpVDDCVoltage);\r\nboot_state->vddci_bootup_value = le16_to_cpu(firmware_info->usBootUpVDDCIVoltage);\r\nboot_state->pcie_gen_bootup_value = ci_get_current_pcie_speed(rdev);\r\nboot_state->pcie_lane_bootup_value = ci_get_current_pcie_lane_number(rdev);\r\nboot_state->sclk_bootup_value = le32_to_cpu(firmware_info->ulDefaultEngineClock);\r\nboot_state->mclk_bootup_value = le32_to_cpu(firmware_info->ulDefaultMemoryClock);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid ci_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\nkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);\r\nr600_free_extended_power_table(rdev);\r\n}\r\nint ci_dpm_init(struct radeon_device *rdev)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info);\r\nSMU7_Discrete_DpmTable *dpm_table;\r\nstruct radeon_gpio_rec gpio;\r\nu16 data_offset, size;\r\nu8 frev, crev;\r\nstruct ci_power_info *pi;\r\nint ret;\r\nu32 mask;\r\npi = kzalloc(sizeof(struct ci_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = pi;\r\nret = drm_pcie_get_speed_cap_mask(rdev->ddev, &mask);\r\nif (ret)\r\npi->sys_pcie_mask = 0;\r\nelse\r\npi->sys_pcie_mask = mask;\r\npi->force_pcie_gen = RADEON_PCIE_GEN_INVALID;\r\npi->pcie_gen_performance.max = RADEON_PCIE_GEN1;\r\npi->pcie_gen_performance.min = RADEON_PCIE_GEN3;\r\npi->pcie_gen_powersaving.max = RADEON_PCIE_GEN1;\r\npi->pcie_gen_powersaving.min = RADEON_PCIE_GEN3;\r\npi->pcie_lane_performance.max = 0;\r\npi->pcie_lane_performance.min = 16;\r\npi->pcie_lane_powersaving.max = 0;\r\npi->pcie_lane_powersaving.min = 16;\r\nret = ci_get_vbios_boot_values(rdev, &pi->vbios_boot_state);\r\nif (ret) {\r\nci_dpm_fini(rdev);\r\nreturn ret;\r\n}\r\nret = r600_get_platform_caps(rdev);\r\nif (ret) {\r\nci_dpm_fini(rdev);\r\nreturn ret;\r\n}\r\nret = r600_parse_extended_power_table(rdev);\r\nif (ret) {\r\nci_dpm_fini(rdev);\r\nreturn ret;\r\n}\r\nret = ci_parse_power_table(rdev);\r\nif (ret) {\r\nci_dpm_fini(rdev);\r\nreturn ret;\r\n}\r\npi->dll_default_on = false;\r\npi->sram_end = SMC_RAM_END;\r\npi->activity_target[0] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[1] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[2] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[3] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[4] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[5] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[6] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->activity_target[7] = CISLAND_TARGETACTIVITY_DFLT;\r\npi->mclk_activity_target = CISLAND_MCLK_TARGETACTIVITY_DFLT;\r\npi->sclk_dpm_key_disabled = 0;\r\npi->mclk_dpm_key_disabled = 0;\r\npi->pcie_dpm_key_disabled = 0;\r\npi->thermal_sclk_dpm_enabled = 0;\r\nif ((rdev->pdev->device == 0x6658) &&\r\n(rdev->mc_fw->size == (BONAIRE_MC_UCODE_SIZE * 4))) {\r\npi->mclk_dpm_key_disabled = 1;\r\n}\r\npi->caps_sclk_ds = true;\r\npi->mclk_strobe_mode_threshold = 40000;\r\npi->mclk_stutter_mode_threshold = 40000;\r\npi->mclk_edc_enable_threshold = 40000;\r\npi->mclk_edc_wr_enable_threshold = 40000;\r\nci_initialize_powertune_defaults(rdev);\r\npi->caps_fps = false;\r\npi->caps_sclk_throttle_low_notification = false;\r\npi->caps_uvd_dpm = true;\r\npi->caps_vce_dpm = true;\r\nci_get_leakage_voltages(rdev);\r\nci_patch_dependency_tables_with_leakage(rdev);\r\nci_set_private_data_variables_based_on_pptable(rdev);\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =\r\nkzalloc(4 * sizeof(struct radeon_clock_voltage_dependency_entry), GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {\r\nci_dpm_fini(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 720;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 810;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;\r\nrdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 900;\r\nrdev->pm.dpm.dyn_state.mclk_sclk_ratio = 4;\r\nrdev->pm.dpm.dyn_state.sclk_mclk_delta = 15000;\r\nrdev->pm.dpm.dyn_state.vddc_vddci_delta = 200;\r\nrdev->pm.dpm.dyn_state.valid_sclk_values.count = 0;\r\nrdev->pm.dpm.dyn_state.valid_sclk_values.values = NULL;\r\nrdev->pm.dpm.dyn_state.valid_mclk_values.count = 0;\r\nrdev->pm.dpm.dyn_state.valid_mclk_values.values = NULL;\r\nif (rdev->family == CHIP_HAWAII) {\r\npi->thermal_temp_setting.temperature_low = 94500;\r\npi->thermal_temp_setting.temperature_high = 95000;\r\npi->thermal_temp_setting.temperature_shutdown = 104000;\r\n} else {\r\npi->thermal_temp_setting.temperature_low = 99500;\r\npi->thermal_temp_setting.temperature_high = 100000;\r\npi->thermal_temp_setting.temperature_shutdown = 104000;\r\n}\r\npi->uvd_enabled = false;\r\ndpm_table = &pi->smc_state_table;\r\ngpio = radeon_atombios_lookup_gpio(rdev, VDDC_VRHOT_GPIO_PINID);\r\nif (gpio.valid) {\r\ndpm_table->VRHotGpio = gpio.shift;\r\nrdev->pm.dpm.platform_caps |= ATOM_PP_PLATFORM_CAP_REGULATOR_HOT;\r\n} else {\r\ndpm_table->VRHotGpio = CISLANDS_UNUSED_GPIO_PIN;\r\nrdev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_REGULATOR_HOT;\r\n}\r\ngpio = radeon_atombios_lookup_gpio(rdev, PP_AC_DC_SWITCH_GPIO_PINID);\r\nif (gpio.valid) {\r\ndpm_table->AcDcGpio = gpio.shift;\r\nrdev->pm.dpm.platform_caps |= ATOM_PP_PLATFORM_CAP_HARDWAREDC;\r\n} else {\r\ndpm_table->AcDcGpio = CISLANDS_UNUSED_GPIO_PIN;\r\nrdev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_HARDWAREDC;\r\n}\r\ngpio = radeon_atombios_lookup_gpio(rdev, VDDC_PCC_GPIO_PINID);\r\nif (gpio.valid) {\r\nu32 tmp = RREG32_SMC(CNB_PWRMGT_CNTL);\r\nswitch (gpio.shift) {\r\ncase 0:\r\ntmp &= ~GNB_SLOW_MODE_MASK;\r\ntmp |= GNB_SLOW_MODE(1);\r\nbreak;\r\ncase 1:\r\ntmp &= ~GNB_SLOW_MODE_MASK;\r\ntmp |= GNB_SLOW_MODE(2);\r\nbreak;\r\ncase 2:\r\ntmp |= GNB_SLOW;\r\nbreak;\r\ncase 3:\r\ntmp |= FORCE_NB_PS1;\r\nbreak;\r\ncase 4:\r\ntmp |= DPM_ENABLED;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG("Invalid PCC GPIO: %u!\n", gpio.shift);\r\nbreak;\r\n}\r\nWREG32_SMC(CNB_PWRMGT_CNTL, tmp);\r\n}\r\npi->voltage_control = CISLANDS_VOLTAGE_CONTROL_NONE;\r\npi->vddci_control = CISLANDS_VOLTAGE_CONTROL_NONE;\r\npi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_NONE;\r\nif (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_GPIO_LUT))\r\npi->voltage_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;\r\nelse if (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_SVID2))\r\npi->voltage_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL) {\r\nif (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_GPIO_LUT))\r\npi->vddci_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;\r\nelse if (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_SVID2))\r\npi->vddci_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;\r\nelse\r\nrdev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL;\r\n}\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_MVDDCONTROL) {\r\nif (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_GPIO_LUT))\r\npi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_BY_GPIO;\r\nelse if (radeon_atom_is_voltage_gpio(rdev, VOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_SVID2))\r\npi->mvdd_control = CISLANDS_VOLTAGE_CONTROL_BY_SVID2;\r\nelse\r\nrdev->pm.dpm.platform_caps &= ~ATOM_PP_PLATFORM_CAP_MVDDCONTROL;\r\n}\r\npi->vddc_phase_shed_control = true;\r\n#if defined(CONFIG_ACPI)\r\npi->pcie_performance_request =\r\nradeon_acpi_is_pcie_performance_request_supported(rdev);\r\n#else\r\npi->pcie_performance_request = false;\r\n#endif\r\nif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\r\n&frev, &crev, &data_offset)) {\r\npi->caps_sclk_ss_support = true;\r\npi->caps_mclk_ss_support = true;\r\npi->dynamic_ss = true;\r\n} else {\r\npi->caps_sclk_ss_support = false;\r\npi->caps_mclk_ss_support = false;\r\npi->dynamic_ss = true;\r\n}\r\nif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\r\npi->thermal_protection = true;\r\nelse\r\npi->thermal_protection = false;\r\npi->caps_dynamic_ac_timing = true;\r\npi->uvd_power_gated = false;\r\nif ((rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk == 0) ||\r\n(rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk == 0))\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_dc =\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\npi->fan_ctrl_is_in_default_mode = true;\r\nreturn 0;\r\n}\r\nvoid ci_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct radeon_ps *rps = &pi->current_rps;\r\nu32 sclk = ci_get_average_sclk_freq(rdev);\r\nu32 mclk = ci_get_average_mclk_freq(rdev);\r\nseq_printf(m, "uvd %sabled\n", pi->uvd_enabled ? "en" : "dis");\r\nseq_printf(m, "vce %sabled\n", rps->vce_active ? "en" : "dis");\r\nseq_printf(m, "power level avg sclk: %u mclk: %u\n",\r\nsclk, mclk);\r\n}\r\nvoid ci_dpm_print_power_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct ci_ps *ps = ci_get_ps(rps);\r\nstruct ci_pl *pl;\r\nint i;\r\nr600_dpm_print_class_info(rps->class, rps->class2);\r\nr600_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nfor (i = 0; i < ps->performance_level_count; i++) {\r\npl = &ps->performance_levels[i];\r\nprintk("\t\tpower level %d sclk: %u mclk: %u pcie gen: %u pcie lanes: %u\n",\r\ni, pl->sclk, pl->mclk, pl->pcie_gen + 1, pl->pcie_lane);\r\n}\r\nr600_dpm_print_ps_status(rdev, rps);\r\n}\r\nu32 ci_dpm_get_current_sclk(struct radeon_device *rdev)\r\n{\r\nu32 sclk = ci_get_average_sclk_freq(rdev);\r\nreturn sclk;\r\n}\r\nu32 ci_dpm_get_current_mclk(struct radeon_device *rdev)\r\n{\r\nu32 mclk = ci_get_average_mclk_freq(rdev);\r\nreturn mclk;\r\n}\r\nu32 ci_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ps *requested_state = ci_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->performance_levels[0].sclk;\r\nelse\r\nreturn requested_state->performance_levels[requested_state->performance_level_count - 1].sclk;\r\n}\r\nu32 ci_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct ci_power_info *pi = ci_get_pi(rdev);\r\nstruct ci_ps *requested_state = ci_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->performance_levels[0].mclk;\r\nelse\r\nreturn requested_state->performance_levels[requested_state->performance_level_count - 1].mclk;\r\n}
