static int f81534_logic_to_phy_port(struct usb_serial *serial,\r\nstruct usb_serial_port *port)\r\n{\r\nstruct f81534_serial_private *serial_priv =\r\nusb_get_serial_data(port->serial);\r\nint count = 0;\r\nint i;\r\nfor (i = 0; i < F81534_NUM_PORT; ++i) {\r\nif (serial_priv->conf_data[i] & F81534_PORT_UNAVAILABLE)\r\ncontinue;\r\nif (port->port_number == count)\r\nreturn i;\r\n++count;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int f81534_set_register(struct usb_serial *serial, u16 reg, u8 data)\r\n{\r\nstruct usb_interface *interface = serial->interface;\r\nstruct usb_device *dev = serial->dev;\r\nsize_t count = F81534_USB_MAX_RETRY;\r\nint status;\r\nu8 *tmp;\r\ntmp = kmalloc(sizeof(u8), GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\n*tmp = data;\r\nwhile (count--) {\r\nstatus = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nF81534_SET_GET_REGISTER,\r\nUSB_TYPE_VENDOR | USB_DIR_OUT,\r\nreg, 0, tmp, sizeof(u8),\r\nF81534_USB_TIMEOUT);\r\nif (status > 0) {\r\nstatus = 0;\r\nbreak;\r\n} else if (status == 0) {\r\nstatus = -EIO;\r\n}\r\n}\r\nif (status < 0) {\r\ndev_err(&interface->dev, "%s: reg: %x data: %x failed: %d\n",\r\n__func__, reg, data, status);\r\n}\r\nkfree(tmp);\r\nreturn status;\r\n}\r\nstatic int f81534_get_register(struct usb_serial *serial, u16 reg, u8 *data)\r\n{\r\nstruct usb_interface *interface = serial->interface;\r\nstruct usb_device *dev = serial->dev;\r\nsize_t count = F81534_USB_MAX_RETRY;\r\nint status;\r\nu8 *tmp;\r\ntmp = kmalloc(sizeof(u8), GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nwhile (count--) {\r\nstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nF81534_SET_GET_REGISTER,\r\nUSB_TYPE_VENDOR | USB_DIR_IN,\r\nreg, 0, tmp, sizeof(u8),\r\nF81534_USB_TIMEOUT);\r\nif (status > 0) {\r\nstatus = 0;\r\nbreak;\r\n} else if (status == 0) {\r\nstatus = -EIO;\r\n}\r\n}\r\nif (status < 0) {\r\ndev_err(&interface->dev, "%s: reg: %x failed: %d\n", __func__,\r\nreg, status);\r\ngoto end;\r\n}\r\n*data = *tmp;\r\nend:\r\nkfree(tmp);\r\nreturn status;\r\n}\r\nstatic int f81534_set_port_register(struct usb_serial_port *port, u16 reg,\r\nu8 data)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nreturn f81534_set_register(port->serial,\r\nreg + port_priv->phy_num * F81534_UART_OFFSET, data);\r\n}\r\nstatic int f81534_get_port_register(struct usb_serial_port *port, u16 reg,\r\nu8 *data)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nreturn f81534_get_register(port->serial,\r\nreg + port_priv->phy_num * F81534_UART_OFFSET, data);\r\n}\r\nstatic int f81534_wait_for_spi_idle(struct usb_serial *serial)\r\n{\r\nsize_t count = F81534_MAX_BUS_RETRY;\r\nu8 tmp;\r\nint status;\r\ndo {\r\nstatus = f81534_get_register(serial, F81534_BUS_REG_STATUS,\r\n&tmp);\r\nif (status)\r\nreturn status;\r\nif (tmp & F81534_BUS_BUSY)\r\ncontinue;\r\nif (tmp & F81534_BUS_IDLE)\r\nbreak;\r\n} while (--count);\r\nif (!count) {\r\ndev_err(&serial->interface->dev,\r\n"%s: timed out waiting for idle SPI bus\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nreturn f81534_set_register(serial, F81534_BUS_REG_STATUS,\r\ntmp & ~F81534_BUS_IDLE);\r\n}\r\nstatic int f81534_get_spi_register(struct usb_serial *serial, u16 reg,\r\nu8 *data)\r\n{\r\nint status;\r\nstatus = f81534_get_register(serial, reg, data);\r\nif (status)\r\nreturn status;\r\nreturn f81534_wait_for_spi_idle(serial);\r\n}\r\nstatic int f81534_set_spi_register(struct usb_serial *serial, u16 reg, u8 data)\r\n{\r\nint status;\r\nstatus = f81534_set_register(serial, reg, data);\r\nif (status)\r\nreturn status;\r\nreturn f81534_wait_for_spi_idle(serial);\r\n}\r\nstatic int f81534_read_flash(struct usb_serial *serial, u32 address,\r\nsize_t size, u8 *buf)\r\n{\r\nu8 tmp_buf[F81534_MAX_DATA_BLOCK];\r\nsize_t block = 0;\r\nsize_t read_size;\r\nsize_t count;\r\nint status;\r\nint offset;\r\nu16 reg_tmp;\r\nstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\r\nF81534_CMD_READ);\r\nif (status)\r\nreturn status;\r\nstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\r\n(address >> 16) & 0xff);\r\nif (status)\r\nreturn status;\r\nstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\r\n(address >> 8) & 0xff);\r\nif (status)\r\nreturn status;\r\nstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\r\n(address >> 0) & 0xff);\r\nif (status)\r\nreturn status;\r\ndo {\r\nread_size = min_t(size_t, F81534_MAX_DATA_BLOCK, size);\r\nfor (count = 0; count < read_size; ++count) {\r\nif (size <= F81534_MAX_DATA_BLOCK &&\r\nread_size == count + 1)\r\nreg_tmp = F81534_BUS_REG_END;\r\nelse\r\nreg_tmp = F81534_BUS_REG_START;\r\nstatus = f81534_set_spi_register(serial, reg_tmp,\r\n0xf1);\r\nif (status)\r\nreturn status;\r\nstatus = f81534_get_spi_register(serial,\r\nF81534_BUS_READ_DATA,\r\n&tmp_buf[count]);\r\nif (status)\r\nreturn status;\r\noffset = count + block * F81534_MAX_DATA_BLOCK;\r\nbuf[offset] = tmp_buf[count];\r\n}\r\nsize -= read_size;\r\n++block;\r\n} while (size);\r\nreturn 0;\r\n}\r\nstatic void f81534_prepare_write_buffer(struct usb_serial_port *port, u8 *buf)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nint phy_num = port_priv->phy_num;\r\nu8 tx_len;\r\nint i;\r\nfor (i = 0; i < F81534_NUM_PORT; ++i) {\r\nbuf[i * F81534_RECEIVE_BLOCK_SIZE] = i;\r\nbuf[i * F81534_RECEIVE_BLOCK_SIZE + 1] = F81534_TOKEN_WRITE;\r\nbuf[i * F81534_RECEIVE_BLOCK_SIZE + 2] = 0;\r\nbuf[i * F81534_RECEIVE_BLOCK_SIZE + 3] = 0;\r\n}\r\ntx_len = kfifo_out_locked(&port->write_fifo,\r\n&buf[phy_num * F81534_RECEIVE_BLOCK_SIZE + 4],\r\nF81534_MAX_TX_SIZE, &port->lock);\r\nbuf[phy_num * F81534_RECEIVE_BLOCK_SIZE + 2] = tx_len;\r\n}\r\nstatic int f81534_submit_writer(struct usb_serial_port *port, gfp_t mem_flags)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nstruct urb *urb;\r\nunsigned long flags;\r\nint result;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (kfifo_is_empty(&port->write_fifo)) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (!test_and_clear_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty))\r\nreturn 0;\r\nurb = port->write_urbs[0];\r\nf81534_prepare_write_buffer(port, port->bulk_out_buffers[0]);\r\nurb->transfer_buffer_length = F81534_WRITE_BUFFER_SIZE;\r\nresult = usb_submit_urb(urb, mem_flags);\r\nif (result) {\r\nset_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\r\ndev_err(&port->dev, "%s: submit failed: %d\n", __func__,\r\nresult);\r\nreturn result;\r\n}\r\nusb_serial_port_softint(port);\r\nreturn 0;\r\n}\r\nstatic u32 f81534_calc_baud_divisor(u32 baudrate, u32 clockrate)\r\n{\r\nif (!baudrate)\r\nreturn 0;\r\nreturn DIV_ROUND_CLOSEST(clockrate, baudrate);\r\n}\r\nstatic int f81534_set_port_config(struct usb_serial_port *port, u32 baudrate,\r\nu8 lcr)\r\n{\r\nu32 divisor;\r\nint status;\r\nu8 value;\r\nif (baudrate <= 1200)\r\nvalue = F81534_1X_RXTRIGGER;\r\nelse\r\nvalue = F81534_8X_RXTRIGGER;\r\nstatus = f81534_set_port_register(port, F81534_CONFIG1_REG, value);\r\nif (status) {\r\ndev_err(&port->dev, "%s: CONFIG1 setting failed\n", __func__);\r\nreturn status;\r\n}\r\nif (baudrate <= 1200)\r\nvalue = UART_FCR_TRIGGER_1 | UART_FCR_ENABLE_FIFO;\r\nelse\r\nvalue = UART_FCR_R_TRIG_11 | UART_FCR_ENABLE_FIFO;\r\nstatus = f81534_set_port_register(port, F81534_FIFO_CONTROL_REG,\r\nvalue);\r\nif (status) {\r\ndev_err(&port->dev, "%s: FCR setting failed\n", __func__);\r\nreturn status;\r\n}\r\ndivisor = f81534_calc_baud_divisor(baudrate, F81534_MAX_BAUDRATE);\r\nvalue = UART_LCR_DLAB;\r\nstatus = f81534_set_port_register(port, F81534_LINE_CONTROL_REG,\r\nvalue);\r\nif (status) {\r\ndev_err(&port->dev, "%s: set LCR failed\n", __func__);\r\nreturn status;\r\n}\r\nvalue = divisor & 0xff;\r\nstatus = f81534_set_port_register(port, F81534_DIVISOR_LSB_REG, value);\r\nif (status) {\r\ndev_err(&port->dev, "%s: set DLAB LSB failed\n", __func__);\r\nreturn status;\r\n}\r\nvalue = (divisor >> 8) & 0xff;\r\nstatus = f81534_set_port_register(port, F81534_DIVISOR_MSB_REG, value);\r\nif (status) {\r\ndev_err(&port->dev, "%s: set DLAB MSB failed\n", __func__);\r\nreturn status;\r\n}\r\nstatus = f81534_set_port_register(port, F81534_LINE_CONTROL_REG, lcr);\r\nif (status) {\r\ndev_err(&port->dev, "%s: set LCR failed\n", __func__);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int f81534_update_mctrl(struct usb_serial_port *port, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nint status;\r\nu8 tmp;\r\nif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0)\r\nreturn 0;\r\nmutex_lock(&port_priv->mcr_mutex);\r\nclear &= ~set;\r\ntmp = UART_MCR_OUT2 | port_priv->shadow_mcr;\r\nif (clear & TIOCM_DTR)\r\ntmp &= ~UART_MCR_DTR;\r\nif (clear & TIOCM_RTS)\r\ntmp &= ~UART_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\ntmp |= UART_MCR_DTR;\r\nif (set & TIOCM_RTS)\r\ntmp |= UART_MCR_RTS;\r\nstatus = f81534_set_port_register(port, F81534_MODEM_CONTROL_REG, tmp);\r\nif (status < 0) {\r\ndev_err(&port->dev, "%s: MCR write failed\n", __func__);\r\nmutex_unlock(&port_priv->mcr_mutex);\r\nreturn status;\r\n}\r\nport_priv->shadow_mcr = tmp;\r\nmutex_unlock(&port_priv->mcr_mutex);\r\nreturn 0;\r\n}\r\nstatic int f81534_find_config_idx(struct usb_serial *serial, u8 *index)\r\n{\r\nu8 tmp;\r\nint status;\r\nstatus = f81534_read_flash(serial, F81534_CUSTOM_ADDRESS_START, 1,\r\n&tmp);\r\nif (status) {\r\ndev_err(&serial->interface->dev, "%s: read failed: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nif (tmp == F81534_CUSTOM_VALID_TOKEN)\r\n*index = 0;\r\nelse\r\n*index = F81534_CUSTOM_NO_CUSTOM_DATA;\r\nreturn 0;\r\n}\r\nstatic int f81534_calc_num_ports(struct usb_serial *serial)\r\n{\r\nu8 setting[F81534_CUSTOM_DATA_SIZE];\r\nu8 setting_idx;\r\nu8 num_port = 0;\r\nint status;\r\nsize_t i;\r\nstatus = f81534_find_config_idx(serial, &setting_idx);\r\nif (status) {\r\ndev_err(&serial->interface->dev, "%s: find idx failed: %d\n",\r\n__func__, status);\r\nreturn 0;\r\n}\r\nif (setting_idx != F81534_CUSTOM_NO_CUSTOM_DATA) {\r\nstatus = f81534_read_flash(serial,\r\nF81534_CUSTOM_ADDRESS_START +\r\nF81534_CONF_OFFSET,\r\nsizeof(setting), setting);\r\nif (status) {\r\ndev_err(&serial->interface->dev,\r\n"%s: get custom data failed: %d\n",\r\n__func__, status);\r\nreturn 0;\r\n}\r\ndev_dbg(&serial->interface->dev,\r\n"%s: read config from block: %d\n", __func__,\r\nsetting_idx);\r\n} else {\r\nstatus = f81534_read_flash(serial,\r\nF81534_DEF_CONF_ADDRESS_START, F81534_NUM_PORT,\r\nsetting);\r\nif (status) {\r\ndev_err(&serial->interface->dev,\r\n"%s: read failed: %d\n", __func__,\r\nstatus);\r\nreturn 0;\r\n}\r\ndev_dbg(&serial->interface->dev, "%s: read default config\n",\r\n__func__);\r\n}\r\nfor (i = 0; i < F81534_NUM_PORT; ++i) {\r\nif (setting[i] & F81534_PORT_UNAVAILABLE)\r\ncontinue;\r\n++num_port;\r\n}\r\nif (num_port)\r\nreturn num_port;\r\ndev_warn(&serial->interface->dev, "%s: Read Failed. default 4 ports\n",\r\n__func__);\r\nreturn 4;\r\n}\r\nstatic void f81534_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nu8 new_lcr = 0;\r\nint status;\r\nu32 baud;\r\nif (C_BAUD(tty) == B0)\r\nf81534_update_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\r\nelse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\r\nf81534_update_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\r\nif (C_PARENB(tty)) {\r\nnew_lcr |= UART_LCR_PARITY;\r\nif (!C_PARODD(tty))\r\nnew_lcr |= UART_LCR_EPAR;\r\nif (C_CMSPAR(tty))\r\nnew_lcr |= UART_LCR_SPAR;\r\n}\r\nif (C_CSTOPB(tty))\r\nnew_lcr |= UART_LCR_STOP;\r\nswitch (C_CSIZE(tty)) {\r\ncase CS5:\r\nnew_lcr |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nnew_lcr |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nnew_lcr |= UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nnew_lcr |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nreturn;\r\nif (baud > F81534_MAX_BAUDRATE) {\r\nif (old_termios)\r\nbaud = tty_termios_baud_rate(old_termios);\r\nelse\r\nbaud = F81534_DEFAULT_BAUD_RATE;\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\ndev_dbg(&port->dev, "%s: baud: %d\n", __func__, baud);\r\nstatus = f81534_set_port_config(port, baud, new_lcr);\r\nif (status < 0) {\r\ndev_err(&port->dev, "%s: set port config failed: %d\n",\r\n__func__, status);\r\n}\r\n}\r\nstatic int f81534_submit_read_urb(struct usb_serial *serial, gfp_t flags)\r\n{\r\nreturn usb_serial_generic_submit_read_urbs(serial->port[0], flags);\r\n}\r\nstatic void f81534_msr_changed(struct usb_serial_port *port, u8 msr)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nu8 old_msr;\r\nif (!(msr & UART_MSR_ANY_DELTA))\r\nreturn;\r\nspin_lock_irqsave(&port_priv->msr_lock, flags);\r\nold_msr = port_priv->shadow_msr;\r\nport_priv->shadow_msr = msr;\r\nspin_unlock_irqrestore(&port_priv->msr_lock, flags);\r\ndev_dbg(&port->dev, "%s: MSR from %02x to %02x\n", __func__, old_msr,\r\nmsr);\r\nif (msr & UART_MSR_DCTS)\r\nport->icount.cts++;\r\nif (msr & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (msr & UART_MSR_DDCD)\r\nport->icount.dcd++;\r\nif (msr & UART_MSR_TERI)\r\nport->icount.rng++;\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\nif (!(msr & UART_MSR_DDCD))\r\nreturn;\r\ndev_dbg(&port->dev, "%s: DCD Changed: phy_num: %d from %x to %x\n",\r\n__func__, port_priv->phy_num, old_msr, msr);\r\ntty = tty_port_tty_get(&port->port);\r\nif (!tty)\r\nreturn;\r\nusb_serial_handle_dcd_change(port, tty, msr & UART_MSR_DCD);\r\ntty_kref_put(tty);\r\n}\r\nstatic int f81534_read_msr(struct usb_serial_port *port)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nint status;\r\nu8 msr;\r\nstatus = f81534_get_port_register(port, F81534_MODEM_STATUS_REG, &msr);\r\nif (status)\r\nreturn status;\r\nspin_lock_irqsave(&port_priv->msr_lock, flags);\r\nport_priv->shadow_msr = msr;\r\nspin_unlock_irqrestore(&port_priv->msr_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int f81534_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct f81534_serial_private *serial_priv =\r\nusb_get_serial_data(port->serial);\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nint status;\r\nstatus = f81534_set_port_register(port,\r\nF81534_FIFO_CONTROL_REG, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nif (status) {\r\ndev_err(&port->dev, "%s: Clear FIFO failed: %d\n", __func__,\r\nstatus);\r\nreturn status;\r\n}\r\nif (tty)\r\nf81534_set_termios(tty, port, NULL);\r\nstatus = f81534_read_msr(port);\r\nif (status)\r\nreturn status;\r\nmutex_lock(&serial_priv->urb_mutex);\r\nif (!serial_priv->opened_port) {\r\nstatus = f81534_submit_read_urb(port->serial, GFP_KERNEL);\r\nif (status)\r\ngoto exit;\r\n}\r\nserial_priv->opened_port++;\r\nexit:\r\nmutex_unlock(&serial_priv->urb_mutex);\r\nset_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\r\nreturn status;\r\n}\r\nstatic void f81534_close(struct usb_serial_port *port)\r\n{\r\nstruct f81534_serial_private *serial_priv =\r\nusb_get_serial_data(port->serial);\r\nstruct usb_serial_port *port0 = port->serial->port[0];\r\nunsigned long flags;\r\nsize_t i;\r\nusb_kill_urb(port->write_urbs[0]);\r\nspin_lock_irqsave(&port->lock, flags);\r\nkfifo_reset_out(&port->write_fifo);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nmutex_lock(&serial_priv->urb_mutex);\r\nserial_priv->opened_port--;\r\nif (!serial_priv->opened_port) {\r\nfor (i = 0; i < ARRAY_SIZE(port0->read_urbs); ++i)\r\nusb_kill_urb(port0->read_urbs[i]);\r\n}\r\nmutex_unlock(&serial_priv->urb_mutex);\r\n}\r\nstatic int f81534_get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct f81534_port_private *port_priv;\r\nstruct serial_struct tmp;\r\nport_priv = usb_get_serial_port_data(port);\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.port = port->port_number;\r\ntmp.line = port->minor;\r\ntmp.baud_base = F81534_MAX_BAUDRATE;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int f81534_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct serial_struct __user *buf = (struct serial_struct __user *)arg;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn f81534_get_serial_info(port, buf);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void f81534_process_per_serial_block(struct usb_serial_port *port,\r\nu8 *data)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nint phy_num = data[0];\r\nsize_t read_size = 0;\r\nsize_t i;\r\nchar tty_flag;\r\nint status;\r\nu8 lsr;\r\nswitch (data[1]) {\r\ncase F81534_TOKEN_TX_EMPTY:\r\nset_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\r\nstatus = f81534_submit_writer(port, GFP_ATOMIC);\r\nif (status)\r\ndev_err(&port->dev, "%s: submit failed\n", __func__);\r\nreturn;\r\ncase F81534_TOKEN_MSR_CHANGE:\r\nf81534_msr_changed(port, data[3]);\r\nreturn;\r\ncase F81534_TOKEN_RECEIVE:\r\nread_size = data[2];\r\nif (read_size > F81534_MAX_RX_SIZE) {\r\ndev_err(&port->dev,\r\n"%s: phy: %d read_size: %zu larger than: %d\n",\r\n__func__, phy_num, read_size,\r\nF81534_MAX_RX_SIZE);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(&port->dev, "%s: unknown token: %02x\n", __func__,\r\ndata[1]);\r\nreturn;\r\n}\r\nfor (i = 4; i < 4 + read_size; i += 2) {\r\ntty_flag = TTY_NORMAL;\r\nlsr = data[i + 1];\r\nif (lsr & UART_LSR_BRK_ERROR_BITS) {\r\nif (lsr & UART_LSR_BI) {\r\ntty_flag = TTY_BREAK;\r\nport->icount.brk++;\r\nusb_serial_handle_break(port);\r\n} else if (lsr & UART_LSR_PE) {\r\ntty_flag = TTY_PARITY;\r\nport->icount.parity++;\r\n} else if (lsr & UART_LSR_FE) {\r\ntty_flag = TTY_FRAME;\r\nport->icount.frame++;\r\n}\r\nif (lsr & UART_LSR_OE) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(&port->port, 0,\r\nTTY_OVERRUN);\r\n}\r\n}\r\nif (port->port.console && port->sysrq) {\r\nif (usb_serial_handle_sysrq_char(port, data[i]))\r\ncontinue;\r\n}\r\ntty_insert_flip_char(&port->port, data[i], tty_flag);\r\n}\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void f81534_process_read_urb(struct urb *urb)\r\n{\r\nstruct f81534_serial_private *serial_priv;\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial;\r\nu8 *buf;\r\nint phy_port_num;\r\nint tty_port_num;\r\nsize_t i;\r\nif (!urb->actual_length ||\r\nurb->actual_length % F81534_RECEIVE_BLOCK_SIZE) {\r\nreturn;\r\n}\r\nport = urb->context;\r\nserial = port->serial;\r\nbuf = urb->transfer_buffer;\r\nserial_priv = usb_get_serial_data(serial);\r\nfor (i = 0; i < urb->actual_length; i += F81534_RECEIVE_BLOCK_SIZE) {\r\nphy_port_num = buf[i];\r\nif (phy_port_num >= F81534_NUM_PORT) {\r\ndev_err(&port->dev,\r\n"%s: phy_port_num: %d larger than: %d\n",\r\n__func__, phy_port_num, F81534_NUM_PORT);\r\ncontinue;\r\n}\r\ntty_port_num = serial_priv->tty_idx[phy_port_num];\r\nport = serial->port[tty_port_num];\r\nif (tty_port_initialized(&port->port))\r\nf81534_process_per_serial_block(port, &buf[i]);\r\n}\r\n}\r\nstatic void f81534_write_usb_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb stopped: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\ncase -EPIPE:\r\ndev_err(&port->dev, "%s - urb stopped: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status: %d\n",\r\n__func__, urb->status);\r\nbreak;\r\n}\r\n}\r\nstatic int f81534_setup_ports(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nu8 port0_out_address;\r\nint buffer_size;\r\nsize_t i;\r\nfor (i = 1; i < serial->num_ports; ++i) {\r\nport0_out_address = serial->port[0]->bulk_out_endpointAddress;\r\nbuffer_size = serial->port[0]->bulk_out_size;\r\nport = serial->port[i];\r\nif (kfifo_alloc(&port->write_fifo, PAGE_SIZE, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nport->bulk_out_size = buffer_size;\r\nport->bulk_out_endpointAddress = port0_out_address;\r\nport->write_urbs[0] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!port->write_urbs[0])\r\nreturn -ENOMEM;\r\nport->bulk_out_buffers[0] = kzalloc(buffer_size, GFP_KERNEL);\r\nif (!port->bulk_out_buffers[0])\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(port->write_urbs[0], serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nport0_out_address),\r\nport->bulk_out_buffers[0], buffer_size,\r\nserial->type->write_bulk_callback, port);\r\nport->write_urb = port->write_urbs[0];\r\nport->bulk_out_buffer = port->bulk_out_buffers[0];\r\n}\r\nreturn 0;\r\n}\r\nstatic int f81534_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_host_interface *iface_desc;\r\nstruct device *dev;\r\nint num_bulk_in = 0;\r\nint num_bulk_out = 0;\r\nint size_bulk_in = 0;\r\nint size_bulk_out = 0;\r\nint i;\r\ndev = &serial->interface->dev;\r\niface_desc = serial->interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\n++num_bulk_in;\r\nsize_bulk_in = usb_endpoint_maxp(endpoint);\r\n}\r\nif (usb_endpoint_is_bulk_out(endpoint)) {\r\n++num_bulk_out;\r\nsize_bulk_out = usb_endpoint_maxp(endpoint);\r\n}\r\n}\r\nif (num_bulk_in != 1 || num_bulk_out != 1) {\r\ndev_err(dev, "expected endpoints not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (size_bulk_out != F81534_WRITE_BUFFER_SIZE ||\r\nsize_bulk_in != F81534_MAX_RECEIVE_BLOCK_SIZE) {\r\ndev_err(dev, "unsupported endpoint max packet size\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int f81534_attach(struct usb_serial *serial)\r\n{\r\nstruct f81534_serial_private *serial_priv;\r\nint index = 0;\r\nint status;\r\nint i;\r\nserial_priv = devm_kzalloc(&serial->interface->dev,\r\nsizeof(*serial_priv), GFP_KERNEL);\r\nif (!serial_priv)\r\nreturn -ENOMEM;\r\nusb_set_serial_data(serial, serial_priv);\r\nmutex_init(&serial_priv->urb_mutex);\r\nstatus = f81534_setup_ports(serial);\r\nif (status)\r\nreturn status;\r\nstatus = f81534_find_config_idx(serial, &serial_priv->setting_idx);\r\nif (status) {\r\ndev_err(&serial->interface->dev, "%s: find idx failed: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nif (serial_priv->setting_idx == F81534_CUSTOM_NO_CUSTOM_DATA) {\r\nstatus = f81534_read_flash(serial,\r\nF81534_DEF_CONF_ADDRESS_START,\r\nF81534_DEF_CONF_SIZE,\r\nserial_priv->conf_data);\r\nif (status) {\r\ndev_err(&serial->interface->dev,\r\n"%s: read reserve data failed: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\n} else {\r\nstatus = f81534_read_flash(serial,\r\nF81534_CUSTOM_ADDRESS_START +\r\nF81534_CONF_OFFSET,\r\nsizeof(serial_priv->conf_data),\r\nserial_priv->conf_data);\r\nif (status) {\r\ndev_err(&serial->interface->dev,\r\n"%s: idx: %d get data failed: %d\n",\r\n__func__, serial_priv->setting_idx,\r\nstatus);\r\nreturn status;\r\n}\r\n}\r\nfor (i = 0; i < F81534_NUM_PORT; ++i) {\r\nif (serial_priv->conf_data[i] & F81534_PORT_UNAVAILABLE)\r\ncontinue;\r\nserial_priv->tty_idx[i] = index++;\r\ndev_dbg(&serial->interface->dev,\r\n"%s: phy_num: %d, tty_idx: %d\n", __func__, i,\r\nserial_priv->tty_idx[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int f81534_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct f81534_port_private *port_priv;\r\nint ret;\r\nport_priv = devm_kzalloc(&port->dev, sizeof(*port_priv), GFP_KERNEL);\r\nif (!port_priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&port_priv->msr_lock);\r\nmutex_init(&port_priv->mcr_mutex);\r\nret = f81534_logic_to_phy_port(port->serial, port);\r\nif (ret < 0)\r\nreturn ret;\r\nport_priv->phy_num = ret;\r\nusb_set_serial_port_data(port, port_priv);\r\ndev_dbg(&port->dev, "%s: port_number: %d, phy_num: %d\n", __func__,\r\nport->port_number, port_priv->phy_num);\r\nreturn 0;\r\n}\r\nstatic int f81534_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nint status;\r\nint r;\r\nu8 msr;\r\nu8 mcr;\r\nstatus = f81534_get_port_register(port, F81534_MODEM_STATUS_REG, &msr);\r\nif (status)\r\nreturn status;\r\nmutex_lock(&port_priv->mcr_mutex);\r\nmcr = port_priv->shadow_mcr;\r\nmutex_unlock(&port_priv->mcr_mutex);\r\nr = (mcr & UART_MCR_DTR ? TIOCM_DTR : 0) |\r\n(mcr & UART_MCR_RTS ? TIOCM_RTS : 0) |\r\n(msr & UART_MSR_CTS ? TIOCM_CTS : 0) |\r\n(msr & UART_MSR_DCD ? TIOCM_CAR : 0) |\r\n(msr & UART_MSR_RI ? TIOCM_RI : 0) |\r\n(msr & UART_MSR_DSR ? TIOCM_DSR : 0);\r\nreturn r;\r\n}\r\nstatic int f81534_tiocmset(struct tty_struct *tty, unsigned int set,\r\nunsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nreturn f81534_update_mctrl(port, set, clear);\r\n}\r\nstatic void f81534_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nif (on)\r\nf81534_update_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\r\nelse\r\nf81534_update_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nstatic int f81534_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst u8 *buf, int count)\r\n{\r\nint bytes_out, status;\r\nif (!count)\r\nreturn 0;\r\nbytes_out = kfifo_in_locked(&port->write_fifo, buf, count,\r\n&port->lock);\r\nstatus = f81534_submit_writer(port, GFP_ATOMIC);\r\nif (status) {\r\ndev_err(&port->dev, "%s: submit failed\n", __func__);\r\nreturn status;\r\n}\r\nreturn bytes_out;\r\n}\r\nstatic bool f81534_tx_empty(struct usb_serial_port *port)\r\n{\r\nstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\r\nreturn test_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\r\n}\r\nstatic int f81534_resume(struct usb_serial *serial)\r\n{\r\nstruct f81534_serial_private *serial_priv =\r\nusb_get_serial_data(serial);\r\nstruct usb_serial_port *port;\r\nint error = 0;\r\nint status;\r\nsize_t i;\r\nmutex_lock(&serial_priv->urb_mutex);\r\nif (serial_priv->opened_port) {\r\nstatus = f81534_submit_read_urb(serial, GFP_NOIO);\r\nif (status) {\r\nmutex_unlock(&serial_priv->urb_mutex);\r\nreturn status;\r\n}\r\n}\r\nmutex_unlock(&serial_priv->urb_mutex);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!tty_port_initialized(&port->port))\r\ncontinue;\r\nstatus = f81534_submit_writer(port, GFP_NOIO);\r\nif (status) {\r\ndev_err(&port->dev, "%s: submit failed\n", __func__);\r\n++error;\r\n}\r\n}\r\nif (error)\r\nreturn -EIO;\r\nreturn 0;\r\n}
