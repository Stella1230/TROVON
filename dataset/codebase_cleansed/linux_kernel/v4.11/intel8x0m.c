static inline u8 igetbyte(struct intel8x0m *chip, u32 offset)\r\n{\r\nreturn ioread8(chip->bmaddr + offset);\r\n}\r\nstatic inline u16 igetword(struct intel8x0m *chip, u32 offset)\r\n{\r\nreturn ioread16(chip->bmaddr + offset);\r\n}\r\nstatic inline u32 igetdword(struct intel8x0m *chip, u32 offset)\r\n{\r\nreturn ioread32(chip->bmaddr + offset);\r\n}\r\nstatic inline void iputbyte(struct intel8x0m *chip, u32 offset, u8 val)\r\n{\r\niowrite8(val, chip->bmaddr + offset);\r\n}\r\nstatic inline void iputword(struct intel8x0m *chip, u32 offset, u16 val)\r\n{\r\niowrite16(val, chip->bmaddr + offset);\r\n}\r\nstatic inline void iputdword(struct intel8x0m *chip, u32 offset, u32 val)\r\n{\r\niowrite32(val, chip->bmaddr + offset);\r\n}\r\nstatic inline u16 iagetword(struct intel8x0m *chip, u32 offset)\r\n{\r\nreturn ioread16(chip->addr + offset);\r\n}\r\nstatic inline void iaputword(struct intel8x0m *chip, u32 offset, u16 val)\r\n{\r\niowrite16(val, chip->addr + offset);\r\n}\r\nstatic unsigned int get_ich_codec_bit(struct intel8x0m *chip, unsigned int codec)\r\n{\r\nstatic unsigned int codec_bit[3] = {\r\nICH_PCR, ICH_SCR, ICH_TCR\r\n};\r\nif (snd_BUG_ON(codec >= 3))\r\nreturn ICH_PCR;\r\nreturn codec_bit[codec];\r\n}\r\nstatic int snd_intel8x0m_codec_semaphore(struct intel8x0m *chip, unsigned int codec)\r\n{\r\nint time;\r\nif (codec > 1)\r\nreturn -EIO;\r\ncodec = get_ich_codec_bit(chip, codec);\r\nif ((igetdword(chip, ICHREG(GLOB_STA)) & codec) == 0)\r\nreturn -EIO;\r\ntime = 100;\r\ndo {\r\nif (!(igetbyte(chip, ICHREG(ACC_SEMA)) & ICH_CAS))\r\nreturn 0;\r\nudelay(10);\r\n} while (time--);\r\ndev_err(chip->card->dev,\r\n"codec_semaphore: semaphore is not ready [0x%x][0x%x]\n",\r\nigetbyte(chip, ICHREG(ACC_SEMA)), igetdword(chip, ICHREG(GLOB_STA)));\r\niagetword(chip, 0);\r\nreturn -EBUSY;\r\n}\r\nstatic void snd_intel8x0m_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct intel8x0m *chip = ac97->private_data;\r\nif (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {\r\nif (! chip->in_ac97_init)\r\ndev_err(chip->card->dev,\r\n"codec_write %d: semaphore is not ready for register 0x%x\n",\r\nac97->num, reg);\r\n}\r\niaputword(chip, reg + ac97->num * 0x80, val);\r\n}\r\nstatic unsigned short snd_intel8x0m_codec_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct intel8x0m *chip = ac97->private_data;\r\nunsigned short res;\r\nunsigned int tmp;\r\nif (snd_intel8x0m_codec_semaphore(chip, ac97->num) < 0) {\r\nif (! chip->in_ac97_init)\r\ndev_err(chip->card->dev,\r\n"codec_read %d: semaphore is not ready for register 0x%x\n",\r\nac97->num, reg);\r\nres = 0xffff;\r\n} else {\r\nres = iagetword(chip, reg + ac97->num * 0x80);\r\nif ((tmp = igetdword(chip, ICHREG(GLOB_STA))) & ICH_RCS) {\r\niputdword(chip, ICHREG(GLOB_STA),\r\ntmp & ~(ICH_SRI|ICH_PRI|ICH_TRI|ICH_GSCI));\r\nif (! chip->in_ac97_init)\r\ndev_err(chip->card->dev,\r\n"codec_read %d: read timeout for register 0x%x\n",\r\nac97->num, reg);\r\nres = 0xffff;\r\n}\r\n}\r\nif (reg == AC97_GPIO_STATUS)\r\niagetword(chip, 0);\r\nreturn res;\r\n}\r\nstatic void snd_intel8x0m_setup_periods(struct intel8x0m *chip, struct ichdev *ichdev)\r\n{\r\nint idx;\r\nu32 *bdbar = ichdev->bdbar;\r\nunsigned long port = ichdev->reg_offset;\r\niputdword(chip, port + ICH_REG_OFF_BDBAR, ichdev->bdbar_addr);\r\nif (ichdev->size == ichdev->fragsize) {\r\nichdev->ack_reload = ichdev->ack = 2;\r\nichdev->fragsize1 = ichdev->fragsize >> 1;\r\nfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 4) {\r\nbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf);\r\nbdbar[idx + 1] = cpu_to_le32(0x80000000 |\r\nichdev->fragsize1 >> chip->pcm_pos_shift);\r\nbdbar[idx + 2] = cpu_to_le32(ichdev->physbuf + (ichdev->size >> 1));\r\nbdbar[idx + 3] = cpu_to_le32(0x80000000 |\r\nichdev->fragsize1 >> chip->pcm_pos_shift);\r\n}\r\nichdev->frags = 2;\r\n} else {\r\nichdev->ack_reload = ichdev->ack = 1;\r\nichdev->fragsize1 = ichdev->fragsize;\r\nfor (idx = 0; idx < (ICH_REG_LVI_MASK + 1) * 2; idx += 2) {\r\nbdbar[idx + 0] = cpu_to_le32(ichdev->physbuf + (((idx >> 1) * ichdev->fragsize) % ichdev->size));\r\nbdbar[idx + 1] = cpu_to_le32(0x80000000 |\r\nichdev->fragsize >> chip->pcm_pos_shift);\r\n}\r\nichdev->frags = ichdev->size / ichdev->fragsize;\r\n}\r\niputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi = ICH_REG_LVI_MASK);\r\nichdev->civ = 0;\r\niputbyte(chip, port + ICH_REG_OFF_CIV, 0);\r\nichdev->lvi_frag = ICH_REG_LVI_MASK % ichdev->frags;\r\nichdev->position = 0;\r\n#if 0\r\ndev_dbg(chip->card->dev,\r\n"lvi_frag = %i, frags = %i, period_size = 0x%x, period_size1 = 0x%x\n",\r\nichdev->lvi_frag, ichdev->frags, ichdev->fragsize,\r\nichdev->fragsize1);\r\n#endif\r\niputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\r\n}\r\nstatic inline void snd_intel8x0m_update(struct intel8x0m *chip, struct ichdev *ichdev)\r\n{\r\nunsigned long port = ichdev->reg_offset;\r\nint civ, i, step;\r\nint ack = 0;\r\nciv = igetbyte(chip, port + ICH_REG_OFF_CIV);\r\nif (civ == ichdev->civ) {\r\nstep = 1;\r\nichdev->civ++;\r\nichdev->civ &= ICH_REG_LVI_MASK;\r\n} else {\r\nstep = civ - ichdev->civ;\r\nif (step < 0)\r\nstep += ICH_REG_LVI_MASK + 1;\r\nichdev->civ = civ;\r\n}\r\nichdev->position += step * ichdev->fragsize1;\r\nichdev->position %= ichdev->size;\r\nichdev->lvi += step;\r\nichdev->lvi &= ICH_REG_LVI_MASK;\r\niputbyte(chip, port + ICH_REG_OFF_LVI, ichdev->lvi);\r\nfor (i = 0; i < step; i++) {\r\nichdev->lvi_frag++;\r\nichdev->lvi_frag %= ichdev->frags;\r\nichdev->bdbar[ichdev->lvi * 2] = cpu_to_le32(ichdev->physbuf +\r\nichdev->lvi_frag *\r\nichdev->fragsize1);\r\n#if 0\r\ndev_dbg(chip->card->dev,\r\n"new: bdbar[%i] = 0x%x [0x%x], prefetch = %i, all = 0x%x, 0x%x\n",\r\nichdev->lvi * 2, ichdev->bdbar[ichdev->lvi * 2],\r\nichdev->bdbar[ichdev->lvi * 2 + 1], inb(ICH_REG_OFF_PIV + port),\r\ninl(port + 4), inb(port + ICH_REG_OFF_CR));\r\n#endif\r\nif (--ichdev->ack == 0) {\r\nichdev->ack = ichdev->ack_reload;\r\nack = 1;\r\n}\r\n}\r\nif (ack && ichdev->substream) {\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(ichdev->substream);\r\nspin_lock(&chip->reg_lock);\r\n}\r\niputbyte(chip, port + ichdev->roff_sr, ICH_FIFOE | ICH_BCIS | ICH_LVBCI);\r\n}\r\nstatic irqreturn_t snd_intel8x0m_interrupt(int irq, void *dev_id)\r\n{\r\nstruct intel8x0m *chip = dev_id;\r\nstruct ichdev *ichdev;\r\nunsigned int status;\r\nunsigned int i;\r\nspin_lock(&chip->reg_lock);\r\nstatus = igetdword(chip, chip->int_sta_reg);\r\nif (status == 0xffffffff) {\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_NONE;\r\n}\r\nif ((status & chip->int_sta_mask) == 0) {\r\nif (status)\r\niputdword(chip, chip->int_sta_reg, status);\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_NONE;\r\n}\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nichdev = &chip->ichd[i];\r\nif (status & ichdev->int_sta_mask)\r\nsnd_intel8x0m_update(chip, ichdev);\r\n}\r\niputdword(chip, chip->int_sta_reg, status & chip->int_sta_mask);\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_intel8x0m_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nunsigned char val = 0;\r\nunsigned long port = ichdev->reg_offset;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nval = ICH_IOCE | ICH_STARTBM;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nval = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nval = ICH_IOCE;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nval = ICH_IOCE | ICH_STARTBM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\niputbyte(chip, port + ICH_REG_OFF_CR, val);\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nwhile (!(igetbyte(chip, port + ichdev->roff_sr) & ICH_DCH)) ;\r\niputbyte(chip, port + ICH_REG_OFF_CR, ICH_RESETREGS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_intel8x0m_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic snd_pcm_uframes_t snd_intel8x0m_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nsize_t ptr1, ptr;\r\nptr1 = igetword(chip, ichdev->reg_offset + ichdev->roff_picb) << chip->pcm_pos_shift;\r\nif (ptr1 != 0)\r\nptr = ichdev->fragsize1 - ptr1;\r\nelse\r\nptr = 0;\r\nptr += ichdev->position;\r\nif (ptr >= ichdev->size)\r\nreturn 0;\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_intel8x0m_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct ichdev *ichdev = get_ichdev(substream);\r\nichdev->physbuf = runtime->dma_addr;\r\nichdev->size = snd_pcm_lib_buffer_bytes(substream);\r\nichdev->fragsize = snd_pcm_lib_period_bytes(substream);\r\nsnd_ac97_write(ichdev->ac97, AC97_LINE1_RATE, runtime->rate);\r\nsnd_ac97_write(ichdev->ac97, AC97_LINE1_LEVEL, 0);\r\nsnd_intel8x0m_setup_periods(chip, ichdev);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_pcm_open(struct snd_pcm_substream *substream, struct ichdev *ichdev)\r\n{\r\nstatic unsigned int rates[] = { 8000, 9600, 12000, 16000 };\r\nstatic struct snd_pcm_hw_constraint_list hw_constraints_rates = {\r\n.count = ARRAY_SIZE(rates),\r\n.list = rates,\r\n.mask = 0,\r\n};\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nichdev->substream = substream;\r\nruntime->hw = snd_intel8x0m_stream;\r\nerr = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_rates);\r\nif ( err < 0 )\r\nreturn err;\r\nruntime->private_data = ichdev;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_intel8x0m_pcm_open(substream, &chip->ichd[ICHD_MDMOUT]);\r\n}\r\nstatic int snd_intel8x0m_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_MDMOUT].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nreturn snd_intel8x0m_pcm_open(substream, &chip->ichd[ICHD_MDMIN]);\r\n}\r\nstatic int snd_intel8x0m_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct intel8x0m *chip = snd_pcm_substream_chip(substream);\r\nchip->ichd[ICHD_MDMIN].substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_pcm1(struct intel8x0m *chip, int device,\r\nstruct ich_pcm_table *rec)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nchar name[32];\r\nif (rec->suffix)\r\nsprintf(name, "Intel ICH - %s", rec->suffix);\r\nelse\r\nstrcpy(name, "Intel ICH");\r\nerr = snd_pcm_new(chip->card, name, device,\r\nrec->playback_ops ? 1 : 0,\r\nrec->capture_ops ? 1 : 0, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (rec->playback_ops)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, rec->playback_ops);\r\nif (rec->capture_ops)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, rec->capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\npcm->dev_class = SNDRV_PCM_CLASS_MODEM;\r\nif (rec->suffix)\r\nsprintf(pcm->name, "%s - %s", chip->card->shortname, rec->suffix);\r\nelse\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm[device] = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nrec->prealloc_size,\r\nrec->prealloc_max_size);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_pcm(struct intel8x0m *chip)\r\n{\r\nint i, tblsize, device, err;\r\nstruct ich_pcm_table *tbl, *rec;\r\n#if 1\r\ntbl = intel_pcms;\r\ntblsize = 1;\r\n#else\r\nswitch (chip->device_type) {\r\ncase DEVICE_NFORCE:\r\ntbl = nforce_pcms;\r\ntblsize = ARRAY_SIZE(nforce_pcms);\r\nbreak;\r\ncase DEVICE_ALI:\r\ntbl = ali_pcms;\r\ntblsize = ARRAY_SIZE(ali_pcms);\r\nbreak;\r\ndefault:\r\ntbl = intel_pcms;\r\ntblsize = 2;\r\nbreak;\r\n}\r\n#endif\r\ndevice = 0;\r\nfor (i = 0; i < tblsize; i++) {\r\nrec = tbl + i;\r\nif (i > 0 && rec->ac97_idx) {\r\nif (! chip->ichd[rec->ac97_idx].ac97)\r\ncontinue;\r\n}\r\nerr = snd_intel8x0m_pcm1(chip, device, rec);\r\nif (err < 0)\r\nreturn err;\r\ndevice++;\r\n}\r\nchip->pcm_devs = device;\r\nreturn 0;\r\n}\r\nstatic void snd_intel8x0m_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct intel8x0m *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_intel8x0m_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct intel8x0m *chip = ac97->private_data;\r\nchip->ac97 = NULL;\r\n}\r\nstatic int snd_intel8x0m_mixer(struct intel8x0m *chip, int ac97_clock)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nstruct snd_ac97 *x97;\r\nint err;\r\nunsigned int glob_sta = 0;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_intel8x0m_codec_write,\r\n.read = snd_intel8x0m_codec_read,\r\n};\r\nchip->in_ac97_init = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_intel8x0m_mixer_free_ac97;\r\nac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;\r\nglob_sta = igetdword(chip, ICHREG(GLOB_STA));\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)\r\ngoto __err;\r\npbus->private_free = snd_intel8x0m_mixer_free_ac97_bus;\r\nif (ac97_clock >= 8000 && ac97_clock <= 48000)\r\npbus->clock = ac97_clock;\r\nchip->ac97_bus = pbus;\r\nac97.pci = chip->pci;\r\nac97.num = glob_sta & ICH_SCR ? 1 : 0;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &x97)) < 0) {\r\ndev_err(chip->card->dev,\r\n"Unable to initialize codec #%d\n", ac97.num);\r\nif (ac97.num == 0)\r\ngoto __err;\r\nreturn err;\r\n}\r\nchip->ac97 = x97;\r\nif(ac97_is_modem(x97) && !chip->ichd[ICHD_MDMIN].ac97) {\r\nchip->ichd[ICHD_MDMIN].ac97 = x97;\r\nchip->ichd[ICHD_MDMOUT].ac97 = x97;\r\n}\r\nchip->in_ac97_init = 0;\r\nreturn 0;\r\n__err:\r\nif (chip->device_type != DEVICE_ALI)\r\niputdword(chip, ICHREG(GLOB_CNT),\r\nigetdword(chip, ICHREG(GLOB_CNT)) & ~ICH_AC97COLD);\r\nreturn err;\r\n}\r\nstatic int snd_intel8x0m_ich_chip_init(struct intel8x0m *chip, int probing)\r\n{\r\nunsigned long end_time;\r\nunsigned int cnt, status, nstatus;\r\nstatus = ICH_RCS | ICH_MIINT | ICH_MOINT;\r\ncnt = igetdword(chip, ICHREG(GLOB_STA));\r\niputdword(chip, ICHREG(GLOB_STA), cnt & status);\r\ncnt = igetdword(chip, ICHREG(GLOB_CNT));\r\ncnt &= ~(ICH_ACLINK);\r\ncnt |= (cnt & ICH_AC97COLD) == 0 ? ICH_AC97COLD : ICH_AC97WARM;\r\niputdword(chip, ICHREG(GLOB_CNT), cnt);\r\nusleep_range(500, 1000);\r\nend_time = jiffies + HZ / 4;\r\ndo {\r\nif ((igetdword(chip, ICHREG(GLOB_CNT)) & ICH_AC97WARM) == 0)\r\ngoto __ok;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\ndev_err(chip->card->dev, "AC'97 warm reset still in progress? [0x%x]\n",\r\nigetdword(chip, ICHREG(GLOB_CNT)));\r\nreturn -EIO;\r\n__ok:\r\nif (probing) {\r\nend_time = jiffies + HZ;\r\ndo {\r\nstatus = igetdword(chip, ICHREG(GLOB_STA)) &\r\n(ICH_PCR | ICH_SCR | ICH_TCR);\r\nif (status)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\nif (! status) {\r\ndev_err(chip->card->dev,\r\n"codec_ready: codec is not ready [0x%x]\n",\r\nigetdword(chip, ICHREG(GLOB_STA)));\r\nreturn -EIO;\r\n}\r\nnstatus = ICH_PCR | ICH_SCR;\r\nend_time = jiffies + HZ / 4;\r\nwhile (status != nstatus && time_after_eq(end_time, jiffies)) {\r\nschedule_timeout_uninterruptible(1);\r\nstatus |= igetdword(chip, ICHREG(GLOB_STA)) & nstatus;\r\n}\r\n} else {\r\nstatus = 0;\r\nif (chip->ac97)\r\nstatus |= get_ich_codec_bit(chip, chip->ac97->num);\r\nend_time = jiffies + HZ;\r\ndo {\r\nnstatus = igetdword(chip, ICHREG(GLOB_STA)) &\r\n(ICH_PCR | ICH_SCR | ICH_TCR);\r\nif (status == nstatus)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after_eq(end_time, jiffies));\r\n}\r\nif (chip->device_type == DEVICE_SIS) {\r\niputword(chip, 0x4c, igetword(chip, 0x4c) | 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_chip_init(struct intel8x0m *chip, int probing)\r\n{\r\nunsigned int i;\r\nint err;\r\nif ((err = snd_intel8x0m_ich_chip_init(chip, probing)) < 0)\r\nreturn err;\r\niagetword(chip, 0);\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputdword(chip, ICH_REG_OFF_BDBAR + chip->ichd[i].reg_offset, chip->ichd[i].bdbar_addr);\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_free(struct intel8x0m *chip)\r\n{\r\nunsigned int i;\r\nif (chip->irq < 0)\r\ngoto __hw_end;\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, 0x00);\r\nfor (i = 0; i < chip->bdbars_count; i++)\r\niputbyte(chip, ICH_REG_OFF_CR + chip->ichd[i].reg_offset, ICH_RESETREGS);\r\n__hw_end:\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nif (chip->bdbars.area)\r\nsnd_dma_free_pages(&chip->bdbars);\r\nif (chip->addr)\r\npci_iounmap(chip->pci, chip->addr);\r\nif (chip->bmaddr)\r\npci_iounmap(chip->pci, chip->bmaddr);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int intel8x0m_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct intel8x0m *chip = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = 0; i < chip->pcm_devs; i++)\r\nsnd_pcm_suspend_all(chip->pcm[i]);\r\nsnd_ac97_suspend(chip->ac97);\r\nif (chip->irq >= 0) {\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel8x0m_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct intel8x0m *chip = card->private_data;\r\nif (request_irq(pci->irq, snd_intel8x0m_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\ndev_err(dev, "unable to grab IRQ %d, disabling device\n",\r\npci->irq);\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nchip->irq = pci->irq;\r\nsnd_intel8x0m_chip_init(chip, 0);\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic void snd_intel8x0m_proc_read(struct snd_info_entry * entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct intel8x0m *chip = entry->private_data;\r\nunsigned int tmp;\r\nsnd_iprintf(buffer, "Intel8x0m\n\n");\r\nif (chip->device_type == DEVICE_ALI)\r\nreturn;\r\ntmp = igetdword(chip, ICHREG(GLOB_STA));\r\nsnd_iprintf(buffer, "Global control : 0x%08x\n",\r\nigetdword(chip, ICHREG(GLOB_CNT)));\r\nsnd_iprintf(buffer, "Global status : 0x%08x\n", tmp);\r\nsnd_iprintf(buffer, "AC'97 codecs ready :%s%s%s%s\n",\r\ntmp & ICH_PCR ? " primary" : "",\r\ntmp & ICH_SCR ? " secondary" : "",\r\ntmp & ICH_TCR ? " tertiary" : "",\r\n(tmp & (ICH_PCR | ICH_SCR | ICH_TCR)) == 0 ? " none" : "");\r\n}\r\nstatic void snd_intel8x0m_proc_init(struct intel8x0m *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "intel8x0m", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_intel8x0m_proc_read);\r\n}\r\nstatic int snd_intel8x0m_dev_free(struct snd_device *device)\r\n{\r\nstruct intel8x0m *chip = device->device_data;\r\nreturn snd_intel8x0m_free(chip);\r\n}\r\nstatic int snd_intel8x0m_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nunsigned long device_type,\r\nstruct intel8x0m **r_intel8x0m)\r\n{\r\nstruct intel8x0m *chip;\r\nint err;\r\nunsigned int i;\r\nunsigned int int_sta_masks;\r\nstruct ichdev *ichdev;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_intel8x0m_dev_free,\r\n};\r\nstatic struct ich_reg_info intel_regs[2] = {\r\n{ ICH_MIINT, 0 },\r\n{ ICH_MOINT, 0x10 },\r\n};\r\nstruct ich_reg_info *tbl;\r\n*r_intel8x0m = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nchip->device_type = device_type;\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nif ((err = pci_request_regions(pci, card->shortname)) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nif (device_type == DEVICE_ALI) {\r\nchip->bmaddr = pci_iomap(pci, 0, 0);\r\ngoto port_inited;\r\n}\r\nif (pci_resource_flags(pci, 2) & IORESOURCE_MEM)\r\nchip->addr = pci_iomap(pci, 2, 0);\r\nelse\r\nchip->addr = pci_iomap(pci, 0, 0);\r\nif (!chip->addr) {\r\ndev_err(card->dev, "AC'97 space ioremap problem\n");\r\nsnd_intel8x0m_free(chip);\r\nreturn -EIO;\r\n}\r\nif (pci_resource_flags(pci, 3) & IORESOURCE_MEM)\r\nchip->bmaddr = pci_iomap(pci, 3, 0);\r\nelse\r\nchip->bmaddr = pci_iomap(pci, 1, 0);\r\nif (!chip->bmaddr) {\r\ndev_err(card->dev, "Controller space ioremap problem\n");\r\nsnd_intel8x0m_free(chip);\r\nreturn -EIO;\r\n}\r\nport_inited:\r\nif (request_irq(pci->irq, snd_intel8x0m_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(card->dev, "unable to grab IRQ %d\n", pci->irq);\r\nsnd_intel8x0m_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\npci_set_master(pci);\r\nsynchronize_irq(chip->irq);\r\nchip->bdbars_count = 2;\r\ntbl = intel_regs;\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nichdev = &chip->ichd[i];\r\nichdev->ichd = i;\r\nichdev->reg_offset = tbl[i].offset;\r\nichdev->int_sta_mask = tbl[i].int_sta_mask;\r\nif (device_type == DEVICE_SIS) {\r\nichdev->roff_sr = ICH_REG_OFF_PICB;\r\nichdev->roff_picb = ICH_REG_OFF_SR;\r\n} else {\r\nichdev->roff_sr = ICH_REG_OFF_SR;\r\nichdev->roff_picb = ICH_REG_OFF_PICB;\r\n}\r\nif (device_type == DEVICE_ALI)\r\nichdev->ali_slot = (ichdev->reg_offset - 0x40) / 0x10;\r\n}\r\nchip->pcm_pos_shift = (device_type == DEVICE_SIS) ? 0 : 1;\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nchip->bdbars_count * sizeof(u32) * ICH_MAX_FRAGS * 2,\r\n&chip->bdbars) < 0) {\r\nsnd_intel8x0m_free(chip);\r\nreturn -ENOMEM;\r\n}\r\nint_sta_masks = 0;\r\nfor (i = 0; i < chip->bdbars_count; i++) {\r\nichdev = &chip->ichd[i];\r\nichdev->bdbar = ((u32 *)chip->bdbars.area) + (i * ICH_MAX_FRAGS * 2);\r\nichdev->bdbar_addr = chip->bdbars.addr + (i * sizeof(u32) * ICH_MAX_FRAGS * 2);\r\nint_sta_masks |= ichdev->int_sta_mask;\r\n}\r\nchip->int_sta_reg = ICH_REG_GLOB_STA;\r\nchip->int_sta_mask = int_sta_masks;\r\nif ((err = snd_intel8x0m_chip_init(chip, 1)) < 0) {\r\nsnd_intel8x0m_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_intel8x0m_free(chip);\r\nreturn err;\r\n}\r\n*r_intel8x0m = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_intel8x0m_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nstruct intel8x0m *chip;\r\nint err;\r\nstruct shortname_table *name;\r\nerr = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "ICH-MODEM");\r\nstrcpy(card->shortname, "Intel ICH");\r\nfor (name = shortnames; name->id; name++) {\r\nif (pci->device == name->id) {\r\nstrcpy(card->shortname, name->s);\r\nbreak;\r\n}\r\n}\r\nstrcat(card->shortname," Modem");\r\nif ((err = snd_intel8x0m_create(card, pci, pci_id->driver_data, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nif ((err = snd_intel8x0m_mixer(chip, ac97_clock)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_intel8x0m_pcm(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_intel8x0m_proc_init(chip);\r\nsprintf(card->longname, "%s at irq %i",\r\ncard->shortname, chip->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\n}\r\nstatic void snd_intel8x0m_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
