static void int_exit(int sig)\r\n{\r\nif (ifindex > -1)\r\nset_link_xdp_fd(ifindex, -1);\r\nexit(0);\r\n}\r\nstatic void poll_stats(unsigned int kill_after_s)\r\n{\r\nconst unsigned int nr_protos = 256;\r\nunsigned int nr_cpus = bpf_num_possible_cpus();\r\ntime_t started_at = time(NULL);\r\n__u64 values[nr_cpus], prev[nr_protos][nr_cpus];\r\n__u32 proto;\r\nint i;\r\nmemset(prev, 0, sizeof(prev));\r\nwhile (!kill_after_s || time(NULL) - started_at <= kill_after_s) {\r\nsleep(STATS_INTERVAL_S);\r\nfor (proto = 0; proto < nr_protos; proto++) {\r\n__u64 sum = 0;\r\nassert(bpf_map_lookup_elem(map_fd[0], &proto, values) == 0);\r\nfor (i = 0; i < nr_cpus; i++)\r\nsum += (values[i] - prev[proto][i]);\r\nif (sum)\r\nprintf("proto %u: sum:%10llu pkts, rate:%10llu pkts/s\n",\r\nproto, sum, sum / STATS_INTERVAL_S);\r\nmemcpy(prev[proto], values, sizeof(values));\r\n}\r\n}\r\n}\r\nstatic void usage(const char *cmd)\r\n{\r\nprintf("Start a XDP prog which encapsulates incoming packets\n"\r\n"in an IPv4/v6 header and XDP_TX it out. The dst <VIP:PORT>\n"\r\n"is used to select packets to encapsulate\n\n");\r\nprintf("Usage: %s [...]\n", cmd);\r\nprintf(" -i <ifindex> Interface Index\n");\r\nprintf(" -a <vip-service-address> IPv4 or IPv6\n");\r\nprintf(" -p <vip-service-port> A port range (e.g. 433-444) is also allowed\n");\r\nprintf(" -s <source-ip> Used in the IPTunnel header\n");\r\nprintf(" -d <dest-ip> Used in the IPTunnel header\n");\r\nprintf(" -m <dest-MAC> Used in sending the IP Tunneled pkt\n");\r\nprintf(" -T <stop-after-X-seconds> Default: 0 (forever)\n");\r\nprintf(" -P <IP-Protocol> Default is TCP\n");\r\nprintf(" -h Display this help\n");\r\n}\r\nstatic int parse_ipstr(const char *ipstr, unsigned int *addr)\r\n{\r\nif (inet_pton(AF_INET6, ipstr, addr) == 1) {\r\nreturn AF_INET6;\r\n} else if (inet_pton(AF_INET, ipstr, addr) == 1) {\r\naddr[1] = addr[2] = addr[3] = 0;\r\nreturn AF_INET;\r\n}\r\nfprintf(stderr, "%s is an invalid IP\n", ipstr);\r\nreturn AF_UNSPEC;\r\n}\r\nstatic int parse_ports(const char *port_str, int *min_port, int *max_port)\r\n{\r\nchar *end;\r\nlong tmp_min_port;\r\nlong tmp_max_port;\r\ntmp_min_port = strtol(optarg, &end, 10);\r\nif (tmp_min_port < 1 || tmp_min_port > 65535) {\r\nfprintf(stderr, "Invalid port(s):%s\n", optarg);\r\nreturn 1;\r\n}\r\nif (*end == '-') {\r\nend++;\r\ntmp_max_port = strtol(end, NULL, 10);\r\nif (tmp_max_port < 1 || tmp_max_port > 65535) {\r\nfprintf(stderr, "Invalid port(s):%s\n", optarg);\r\nreturn 1;\r\n}\r\n} else {\r\ntmp_max_port = tmp_min_port;\r\n}\r\nif (tmp_min_port > tmp_max_port) {\r\nfprintf(stderr, "Invalid port(s):%s\n", optarg);\r\nreturn 1;\r\n}\r\nif (tmp_max_port - tmp_min_port + 1 > MAX_IPTNL_ENTRIES) {\r\nfprintf(stderr, "Port range (%s) is larger than %u\n",\r\nport_str, MAX_IPTNL_ENTRIES);\r\nreturn 1;\r\n}\r\n*min_port = tmp_min_port;\r\n*max_port = tmp_max_port;\r\nreturn 0;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nunsigned char opt_flags[256] = {};\r\nunsigned int kill_after_s = 0;\r\nconst char *optstr = "i:a:p:s:d:m:T:P:h";\r\nint min_port = 0, max_port = 0;\r\nstruct iptnl_info tnl = {};\r\nstruct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};\r\nstruct vip vip = {};\r\nchar filename[256];\r\nint opt;\r\nint i;\r\ntnl.family = AF_UNSPEC;\r\nvip.protocol = IPPROTO_TCP;\r\nfor (i = 0; i < strlen(optstr); i++)\r\nif (optstr[i] != 'h' && 'a' <= optstr[i] && optstr[i] <= 'z')\r\nopt_flags[(unsigned char)optstr[i]] = 1;\r\nwhile ((opt = getopt(argc, argv, optstr)) != -1) {\r\nunsigned short family;\r\nunsigned int *v6;\r\nswitch (opt) {\r\ncase 'i':\r\nifindex = atoi(optarg);\r\nbreak;\r\ncase 'a':\r\nvip.family = parse_ipstr(optarg, vip.daddr.v6);\r\nif (vip.family == AF_UNSPEC)\r\nreturn 1;\r\nbreak;\r\ncase 'p':\r\nif (parse_ports(optarg, &min_port, &max_port))\r\nreturn 1;\r\nbreak;\r\ncase 'P':\r\nvip.protocol = atoi(optarg);\r\nbreak;\r\ncase 's':\r\ncase 'd':\r\nif (opt == 's')\r\nv6 = tnl.saddr.v6;\r\nelse\r\nv6 = tnl.daddr.v6;\r\nfamily = parse_ipstr(optarg, v6);\r\nif (family == AF_UNSPEC)\r\nreturn 1;\r\nif (tnl.family == AF_UNSPEC) {\r\ntnl.family = family;\r\n} else if (tnl.family != family) {\r\nfprintf(stderr,\r\n"The IP version of the src and dst addresses used in the IP encapsulation does not match\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase 'm':\r\nif (!ether_aton_r(optarg,\r\n(struct ether_addr *)tnl.dmac)) {\r\nfprintf(stderr, "Invalid mac address:%s\n",\r\noptarg);\r\nreturn 1;\r\n}\r\nbreak;\r\ncase 'T':\r\nkill_after_s = atoi(optarg);\r\nbreak;\r\ndefault:\r\nusage(argv[0]);\r\nreturn 1;\r\n}\r\nopt_flags[opt] = 0;\r\n}\r\nfor (i = 0; i < strlen(optstr); i++) {\r\nif (opt_flags[(unsigned int)optstr[i]]) {\r\nfprintf(stderr, "Missing argument -%c\n", optstr[i]);\r\nusage(argv[0]);\r\nreturn 1;\r\n}\r\n}\r\nif (setrlimit(RLIMIT_MEMLOCK, &r)) {\r\nperror("setrlimit(RLIMIT_MEMLOCK, RLIM_INFINITY)");\r\nreturn 1;\r\n}\r\nsnprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);\r\nif (load_bpf_file(filename)) {\r\nprintf("%s", bpf_log_buf);\r\nreturn 1;\r\n}\r\nif (!prog_fd[0]) {\r\nprintf("load_bpf_file: %s\n", strerror(errno));\r\nreturn 1;\r\n}\r\nsignal(SIGINT, int_exit);\r\nwhile (min_port <= max_port) {\r\nvip.dport = htons(min_port++);\r\nif (bpf_map_update_elem(map_fd[1], &vip, &tnl, BPF_NOEXIST)) {\r\nperror("bpf_map_update_elem(&vip2tnl)");\r\nreturn 1;\r\n}\r\n}\r\nif (set_link_xdp_fd(ifindex, prog_fd[0]) < 0) {\r\nprintf("link set xdp fd failed\n");\r\nreturn 1;\r\n}\r\npoll_stats(kill_after_s);\r\nset_link_xdp_fd(ifindex, -1);\r\nreturn 0;\r\n}
