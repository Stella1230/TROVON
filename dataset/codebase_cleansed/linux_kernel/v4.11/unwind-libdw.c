static int __report_module(struct addr_location *al, u64 ip,\r\nstruct unwind_info *ui)\r\n{\r\nDwfl_Module *mod;\r\nstruct dso *dso = NULL;\r\nthread__find_addr_location(ui->thread,\r\nPERF_RECORD_MISC_USER,\r\nMAP__FUNCTION, ip, al);\r\nif (al->map)\r\ndso = al->map->dso;\r\nif (!dso)\r\nreturn 0;\r\nmod = dwfl_addrmodule(ui->dwfl, ip);\r\nif (!mod)\r\nmod = dwfl_report_elf(ui->dwfl, dso->short_name,\r\ndso->long_name, -1, al->map->start,\r\nfalse);\r\nreturn mod && dwfl_addrmodule(ui->dwfl, ip) == mod ? 0 : -1;\r\n}\r\nstatic int report_module(u64 ip, struct unwind_info *ui)\r\n{\r\nstruct addr_location al;\r\nreturn __report_module(&al, ip, ui);\r\n}\r\nstatic int entry(u64 ip, struct unwind_info *ui)\r\n{\r\nstruct unwind_entry *e = &ui->entries[ui->idx++];\r\nstruct addr_location al;\r\nif (__report_module(&al, ip, ui))\r\nreturn -1;\r\ne->ip = al.addr;\r\ne->map = al.map;\r\ne->sym = al.sym;\r\npr_debug("unwind: %s:ip = 0x%" PRIx64 " (0x%" PRIx64 ")\n",\r\nal.sym ? al.sym->name : "''",\r\nip,\r\nal.map ? al.map->map_ip(al.map, ip) : (u64) 0);\r\nreturn 0;\r\n}\r\nstatic pid_t next_thread(Dwfl *dwfl, void *arg, void **thread_argp)\r\n{\r\nif (*thread_argp != NULL)\r\nreturn 0;\r\n*thread_argp = arg;\r\nreturn dwfl_pid(dwfl);\r\n}\r\nstatic int access_dso_mem(struct unwind_info *ui, Dwarf_Addr addr,\r\nDwarf_Word *data)\r\n{\r\nstruct addr_location al;\r\nssize_t size;\r\nthread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,\r\nMAP__FUNCTION, addr, &al);\r\nif (!al.map) {\r\nthread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,\r\nMAP__VARIABLE, addr, &al);\r\n}\r\nif (!al.map) {\r\npr_debug("unwind: no map for %lx\n", (unsigned long)addr);\r\nreturn -1;\r\n}\r\nif (!al.map->dso)\r\nreturn -1;\r\nsize = dso__data_read_addr(al.map->dso, al.map, ui->machine,\r\naddr, (u8 *) data, sizeof(*data));\r\nreturn !(size == sizeof(*data));\r\n}\r\nstatic bool memory_read(Dwfl *dwfl __maybe_unused, Dwarf_Addr addr, Dwarf_Word *result,\r\nvoid *arg)\r\n{\r\nstruct unwind_info *ui = arg;\r\nstruct stack_dump *stack = &ui->sample->user_stack;\r\nu64 start, end;\r\nint offset;\r\nint ret;\r\nret = perf_reg_value(&start, &ui->sample->user_regs, PERF_REG_SP);\r\nif (ret)\r\nreturn false;\r\nend = start + stack->size;\r\nif (addr + sizeof(Dwarf_Word) < addr)\r\nreturn false;\r\nif (addr < start || addr + sizeof(Dwarf_Word) > end) {\r\nret = access_dso_mem(ui, addr, result);\r\nif (ret) {\r\npr_debug("unwind: access_mem 0x%" PRIx64 " not inside range"\r\n" 0x%" PRIx64 "-0x%" PRIx64 "\n",\r\naddr, start, end);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\noffset = addr - start;\r\n*result = *(Dwarf_Word *)&stack->data[offset];\r\npr_debug("unwind: access_mem addr 0x%" PRIx64 ", val %lx, offset %d\n",\r\naddr, (unsigned long)*result, offset);\r\nreturn true;\r\n}\r\nstatic int\r\nframe_callback(Dwfl_Frame *state, void *arg)\r\n{\r\nstruct unwind_info *ui = arg;\r\nDwarf_Addr pc;\r\nif (!dwfl_frame_pc(state, &pc, NULL)) {\r\npr_err("%s", dwfl_errmsg(-1));\r\nreturn DWARF_CB_ABORT;\r\n}\r\nreturn entry(pc, ui) || !(--ui->max_stack) ?\r\nDWARF_CB_ABORT : DWARF_CB_OK;\r\n}\r\nint unwind__get_entries(unwind_entry_cb_t cb, void *arg,\r\nstruct thread *thread,\r\nstruct perf_sample *data,\r\nint max_stack)\r\n{\r\nstruct unwind_info *ui, ui_buf = {\r\n.sample = data,\r\n.thread = thread,\r\n.machine = thread->mg->machine,\r\n.cb = cb,\r\n.arg = arg,\r\n.max_stack = max_stack,\r\n};\r\nDwarf_Word ip;\r\nint err = -EINVAL, i;\r\nif (!data->user_regs.regs)\r\nreturn -EINVAL;\r\nui = zalloc(sizeof(ui_buf) + sizeof(ui_buf.entries[0]) * max_stack);\r\nif (!ui)\r\nreturn -ENOMEM;\r\n*ui = ui_buf;\r\nui->dwfl = dwfl_begin(&offline_callbacks);\r\nif (!ui->dwfl)\r\ngoto out;\r\nerr = perf_reg_value(&ip, &data->user_regs, PERF_REG_IP);\r\nif (err)\r\ngoto out;\r\nerr = report_module(ip, ui);\r\nif (err)\r\ngoto out;\r\nif (!dwfl_attach_state(ui->dwfl, EM_NONE, thread->tid, &callbacks, ui))\r\ngoto out;\r\nerr = dwfl_getthread_frames(ui->dwfl, thread->tid, frame_callback, ui);\r\nif (err && !ui->max_stack)\r\nerr = 0;\r\nfor (i = 0; i < ui->idx && !err; i++) {\r\nint j = i;\r\nif (callchain_param.order == ORDER_CALLER)\r\nj = ui->idx - i - 1;\r\nerr = ui->entries[j].ip ? ui->cb(&ui->entries[j], ui->arg) : 0;\r\n}\r\nout:\r\nif (err)\r\npr_debug("unwind: failed with '%s'\n", dwfl_errmsg(-1));\r\ndwfl_end(ui->dwfl);\r\nfree(ui);\r\nreturn 0;\r\n}
