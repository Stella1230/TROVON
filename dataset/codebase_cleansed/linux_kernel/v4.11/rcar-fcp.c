struct rcar_fcp_device *rcar_fcp_get(const struct device_node *np)\r\n{\r\nstruct rcar_fcp_device *fcp;\r\nmutex_lock(&fcp_lock);\r\nlist_for_each_entry(fcp, &fcp_devices, list) {\r\nif (fcp->dev->of_node != np)\r\ncontinue;\r\nif (!try_module_get(fcp->dev->driver->owner))\r\nfcp = NULL;\r\ngoto done;\r\n}\r\nfcp = ERR_PTR(-EPROBE_DEFER);\r\ndone:\r\nmutex_unlock(&fcp_lock);\r\nreturn fcp;\r\n}\r\nvoid rcar_fcp_put(struct rcar_fcp_device *fcp)\r\n{\r\nif (fcp)\r\nmodule_put(fcp->dev->driver->owner);\r\n}\r\nint rcar_fcp_enable(struct rcar_fcp_device *fcp)\r\n{\r\nint ret;\r\nif (!fcp)\r\nreturn 0;\r\nret = pm_runtime_get_sync(fcp->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid rcar_fcp_disable(struct rcar_fcp_device *fcp)\r\n{\r\nif (fcp)\r\npm_runtime_put(fcp->dev);\r\n}\r\nstatic int rcar_fcp_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_fcp_device *fcp;\r\nfcp = devm_kzalloc(&pdev->dev, sizeof(*fcp), GFP_KERNEL);\r\nif (fcp == NULL)\r\nreturn -ENOMEM;\r\nfcp->dev = &pdev->dev;\r\npm_runtime_enable(&pdev->dev);\r\nmutex_lock(&fcp_lock);\r\nlist_add_tail(&fcp->list, &fcp_devices);\r\nmutex_unlock(&fcp_lock);\r\nplatform_set_drvdata(pdev, fcp);\r\nreturn 0;\r\n}\r\nstatic int rcar_fcp_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_fcp_device *fcp = platform_get_drvdata(pdev);\r\nmutex_lock(&fcp_lock);\r\nlist_del(&fcp->list);\r\nmutex_unlock(&fcp_lock);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
