static void xgene_enet_wr_csr(struct xgene_enet_pdata *p, u32 offset, u32 val)\r\n{\r\niowrite32(val, p->eth_csr_addr + offset);\r\n}\r\nstatic void xgene_enet_wr_clkrst_csr(struct xgene_enet_pdata *p, u32 offset,\r\nu32 val)\r\n{\r\niowrite32(val, p->base_addr + offset);\r\n}\r\nstatic void xgene_enet_wr_ring_if(struct xgene_enet_pdata *p,\r\nu32 offset, u32 val)\r\n{\r\niowrite32(val, p->eth_ring_if_addr + offset);\r\n}\r\nstatic void xgene_enet_wr_diag_csr(struct xgene_enet_pdata *p,\r\nu32 offset, u32 val)\r\n{\r\niowrite32(val, p->eth_diag_csr_addr + offset);\r\n}\r\nstatic void xgene_enet_wr_mcx_csr(struct xgene_enet_pdata *pdata,\r\nu32 offset, u32 val)\r\n{\r\nvoid __iomem *addr = pdata->mcx_mac_csr_addr + offset;\r\niowrite32(val, addr);\r\n}\r\nstatic bool xgene_enet_wr_indirect(struct xgene_indirect_ctl *ctl,\r\nu32 wr_addr, u32 wr_data)\r\n{\r\nint i;\r\niowrite32(wr_addr, ctl->addr);\r\niowrite32(wr_data, ctl->ctl);\r\niowrite32(XGENE_ENET_WR_CMD, ctl->cmd);\r\nfor (i = 0; i < 10; i++) {\r\nif (ioread32(ctl->cmd_done)) {\r\niowrite32(0, ctl->cmd);\r\nreturn true;\r\n}\r\nudelay(1);\r\n}\r\nreturn false;\r\n}\r\nstatic void xgene_enet_wr_mac(struct xgene_enet_pdata *p,\r\nu32 wr_addr, u32 wr_data)\r\n{\r\nstruct xgene_indirect_ctl ctl = {\r\n.addr = p->mcx_mac_addr + MAC_ADDR_REG_OFFSET,\r\n.ctl = p->mcx_mac_addr + MAC_WRITE_REG_OFFSET,\r\n.cmd = p->mcx_mac_addr + MAC_COMMAND_REG_OFFSET,\r\n.cmd_done = p->mcx_mac_addr + MAC_COMMAND_DONE_REG_OFFSET\r\n};\r\nif (!xgene_enet_wr_indirect(&ctl, wr_addr, wr_data))\r\nnetdev_err(p->ndev, "mac write failed, addr: %04x\n", wr_addr);\r\n}\r\nstatic u32 xgene_enet_rd_csr(struct xgene_enet_pdata *p, u32 offset)\r\n{\r\nreturn ioread32(p->eth_csr_addr + offset);\r\n}\r\nstatic u32 xgene_enet_rd_diag_csr(struct xgene_enet_pdata *p, u32 offset)\r\n{\r\nreturn ioread32(p->eth_diag_csr_addr + offset);\r\n}\r\nstatic u32 xgene_enet_rd_mcx_csr(struct xgene_enet_pdata *p, u32 offset)\r\n{\r\nreturn ioread32(p->mcx_mac_csr_addr + offset);\r\n}\r\nstatic u32 xgene_enet_rd_indirect(struct xgene_indirect_ctl *ctl, u32 rd_addr)\r\n{\r\nu32 rd_data;\r\nint i;\r\niowrite32(rd_addr, ctl->addr);\r\niowrite32(XGENE_ENET_RD_CMD, ctl->cmd);\r\nfor (i = 0; i < 10; i++) {\r\nif (ioread32(ctl->cmd_done)) {\r\nrd_data = ioread32(ctl->ctl);\r\niowrite32(0, ctl->cmd);\r\nreturn rd_data;\r\n}\r\nudelay(1);\r\n}\r\npr_err("%s: mac read failed, addr: %04x\n", __func__, rd_addr);\r\nreturn 0;\r\n}\r\nstatic u32 xgene_enet_rd_mac(struct xgene_enet_pdata *p, u32 rd_addr)\r\n{\r\nstruct xgene_indirect_ctl ctl = {\r\n.addr = p->mcx_mac_addr + MAC_ADDR_REG_OFFSET,\r\n.ctl = p->mcx_mac_addr + MAC_READ_REG_OFFSET,\r\n.cmd = p->mcx_mac_addr + MAC_COMMAND_REG_OFFSET,\r\n.cmd_done = p->mcx_mac_addr + MAC_COMMAND_DONE_REG_OFFSET\r\n};\r\nreturn xgene_enet_rd_indirect(&ctl, rd_addr);\r\n}\r\nstatic int xgene_enet_ecc_init(struct xgene_enet_pdata *p)\r\n{\r\nstruct net_device *ndev = p->ndev;\r\nu32 data, shutdown;\r\nint i = 0;\r\nshutdown = xgene_enet_rd_diag_csr(p, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR);\r\ndata = xgene_enet_rd_diag_csr(p, ENET_BLOCK_MEM_RDY_ADDR);\r\nif (!shutdown && data == ~0U) {\r\nnetdev_dbg(ndev, "+ ecc_init done, skipping\n");\r\nreturn 0;\r\n}\r\nxgene_enet_wr_diag_csr(p, ENET_CFG_MEM_RAM_SHUTDOWN_ADDR, 0);\r\ndo {\r\nusleep_range(100, 110);\r\ndata = xgene_enet_rd_diag_csr(p, ENET_BLOCK_MEM_RDY_ADDR);\r\nif (data == ~0U)\r\nreturn 0;\r\n} while (++i < 10);\r\nnetdev_err(ndev, "Failed to release memory from shutdown\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void xgene_enet_config_ring_if_assoc(struct xgene_enet_pdata *p)\r\n{\r\nu32 val;\r\nval = (p->enet_id == XGENE_ENET1) ? 0xffffffff : 0;\r\nxgene_enet_wr_ring_if(p, ENET_CFGSSQMIWQASSOC_ADDR, val);\r\nxgene_enet_wr_ring_if(p, ENET_CFGSSQMIFPQASSOC_ADDR, val);\r\n}\r\nstatic void xgene_mii_phy_write(struct xgene_enet_pdata *p, u8 phy_id,\r\nu32 reg, u16 data)\r\n{\r\nu32 addr, wr_data, done;\r\nint i;\r\naddr = PHY_ADDR(phy_id) | REG_ADDR(reg);\r\nxgene_enet_wr_mac(p, MII_MGMT_ADDRESS_ADDR, addr);\r\nwr_data = PHY_CONTROL(data);\r\nxgene_enet_wr_mac(p, MII_MGMT_CONTROL_ADDR, wr_data);\r\nfor (i = 0; i < 10; i++) {\r\ndone = xgene_enet_rd_mac(p, MII_MGMT_INDICATORS_ADDR);\r\nif (!(done & BUSY_MASK))\r\nreturn;\r\nusleep_range(10, 20);\r\n}\r\nnetdev_err(p->ndev, "MII_MGMT write failed\n");\r\n}\r\nstatic u32 xgene_mii_phy_read(struct xgene_enet_pdata *p, u8 phy_id, u32 reg)\r\n{\r\nu32 addr, data, done;\r\nint i;\r\naddr = PHY_ADDR(phy_id) | REG_ADDR(reg);\r\nxgene_enet_wr_mac(p, MII_MGMT_ADDRESS_ADDR, addr);\r\nxgene_enet_wr_mac(p, MII_MGMT_COMMAND_ADDR, READ_CYCLE_MASK);\r\nfor (i = 0; i < 10; i++) {\r\ndone = xgene_enet_rd_mac(p, MII_MGMT_INDICATORS_ADDR);\r\nif (!(done & BUSY_MASK)) {\r\ndata = xgene_enet_rd_mac(p, MII_MGMT_STATUS_ADDR);\r\nxgene_enet_wr_mac(p, MII_MGMT_COMMAND_ADDR, 0);\r\nreturn data;\r\n}\r\nusleep_range(10, 20);\r\n}\r\nnetdev_err(p->ndev, "MII_MGMT read failed\n");\r\nreturn 0;\r\n}\r\nstatic void xgene_sgmac_reset(struct xgene_enet_pdata *p)\r\n{\r\nxgene_enet_wr_mac(p, MAC_CONFIG_1_ADDR, SOFT_RESET1);\r\nxgene_enet_wr_mac(p, MAC_CONFIG_1_ADDR, 0);\r\n}\r\nstatic void xgene_sgmac_set_mac_addr(struct xgene_enet_pdata *p)\r\n{\r\nu32 addr0, addr1;\r\nu8 *dev_addr = p->ndev->dev_addr;\r\naddr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |\r\n(dev_addr[1] << 8) | dev_addr[0];\r\nxgene_enet_wr_mac(p, STATION_ADDR0_ADDR, addr0);\r\naddr1 = xgene_enet_rd_mac(p, STATION_ADDR1_ADDR);\r\naddr1 |= (dev_addr[5] << 24) | (dev_addr[4] << 16);\r\nxgene_enet_wr_mac(p, STATION_ADDR1_ADDR, addr1);\r\n}\r\nstatic u32 xgene_enet_link_status(struct xgene_enet_pdata *p)\r\n{\r\nu32 data;\r\ndata = xgene_mii_phy_read(p, INT_PHY_ADDR,\r\nSGMII_BASE_PAGE_ABILITY_ADDR >> 2);\r\nif (LINK_SPEED(data) == PHY_SPEED_1000)\r\np->phy_speed = SPEED_1000;\r\nelse if (LINK_SPEED(data) == PHY_SPEED_100)\r\np->phy_speed = SPEED_100;\r\nelse\r\np->phy_speed = SPEED_10;\r\nreturn data & LINK_UP;\r\n}\r\nstatic void xgene_sgmii_configure(struct xgene_enet_pdata *p)\r\n{\r\nxgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2,\r\n0x8000);\r\nxgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_CONTROL_ADDR >> 2, 0x9000);\r\nxgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2, 0);\r\n}\r\nstatic void xgene_sgmii_tbi_control_reset(struct xgene_enet_pdata *p)\r\n{\r\nxgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2,\r\n0x8000);\r\nxgene_mii_phy_write(p, INT_PHY_ADDR, SGMII_TBI_CONTROL_ADDR >> 2, 0);\r\n}\r\nstatic void xgene_sgmii_reset(struct xgene_enet_pdata *p)\r\n{\r\nu32 value;\r\nif (p->phy_speed == SPEED_UNKNOWN)\r\nreturn;\r\nvalue = xgene_mii_phy_read(p, INT_PHY_ADDR,\r\nSGMII_BASE_PAGE_ABILITY_ADDR >> 2);\r\nif (!(value & LINK_UP))\r\nxgene_sgmii_tbi_control_reset(p);\r\n}\r\nstatic void xgene_sgmac_set_speed(struct xgene_enet_pdata *p)\r\n{\r\nu32 icm0_addr, icm2_addr, debug_addr;\r\nu32 icm0, icm2, intf_ctl;\r\nu32 mc2, value;\r\nxgene_sgmii_reset(p);\r\nif (p->enet_id == XGENE_ENET1) {\r\nicm0_addr = ICM_CONFIG0_REG_0_ADDR + p->port_id * OFFSET_8;\r\nicm2_addr = ICM_CONFIG2_REG_0_ADDR + p->port_id * OFFSET_4;\r\ndebug_addr = DEBUG_REG_ADDR;\r\n} else {\r\nicm0_addr = XG_MCX_ICM_CONFIG0_REG_0_ADDR;\r\nicm2_addr = XG_MCX_ICM_CONFIG2_REG_0_ADDR;\r\ndebug_addr = XG_DEBUG_REG_ADDR;\r\n}\r\nicm0 = xgene_enet_rd_mcx_csr(p, icm0_addr);\r\nicm2 = xgene_enet_rd_mcx_csr(p, icm2_addr);\r\nmc2 = xgene_enet_rd_mac(p, MAC_CONFIG_2_ADDR);\r\nintf_ctl = xgene_enet_rd_mac(p, INTERFACE_CONTROL_ADDR);\r\nswitch (p->phy_speed) {\r\ncase SPEED_10:\r\nENET_INTERFACE_MODE2_SET(&mc2, 1);\r\nintf_ctl &= ~(ENET_LHD_MODE | ENET_GHD_MODE);\r\nCFG_MACMODE_SET(&icm0, 0);\r\nCFG_WAITASYNCRD_SET(&icm2, 500);\r\nbreak;\r\ncase SPEED_100:\r\nENET_INTERFACE_MODE2_SET(&mc2, 1);\r\nintf_ctl &= ~ENET_GHD_MODE;\r\nintf_ctl |= ENET_LHD_MODE;\r\nCFG_MACMODE_SET(&icm0, 1);\r\nCFG_WAITASYNCRD_SET(&icm2, 80);\r\nbreak;\r\ndefault:\r\nENET_INTERFACE_MODE2_SET(&mc2, 2);\r\nintf_ctl &= ~ENET_LHD_MODE;\r\nintf_ctl |= ENET_GHD_MODE;\r\nCFG_MACMODE_SET(&icm0, 2);\r\nCFG_WAITASYNCRD_SET(&icm2, 16);\r\nvalue = xgene_enet_rd_csr(p, debug_addr);\r\nvalue |= CFG_BYPASS_UNISEC_TX | CFG_BYPASS_UNISEC_RX;\r\nxgene_enet_wr_csr(p, debug_addr, value);\r\nbreak;\r\n}\r\nmc2 |= FULL_DUPLEX2 | PAD_CRC;\r\nxgene_enet_wr_mac(p, MAC_CONFIG_2_ADDR, mc2);\r\nxgene_enet_wr_mac(p, INTERFACE_CONTROL_ADDR, intf_ctl);\r\nxgene_enet_wr_mcx_csr(p, icm0_addr, icm0);\r\nxgene_enet_wr_mcx_csr(p, icm2_addr, icm2);\r\n}\r\nstatic void xgene_sgmac_set_frame_size(struct xgene_enet_pdata *pdata, int size)\r\n{\r\nxgene_enet_wr_mac(pdata, MAX_FRAME_LEN_ADDR, size);\r\n}\r\nstatic void xgene_sgmii_enable_autoneg(struct xgene_enet_pdata *p)\r\n{\r\nu32 data, loop = 10;\r\nxgene_sgmii_configure(p);\r\nwhile (loop--) {\r\ndata = xgene_mii_phy_read(p, INT_PHY_ADDR,\r\nSGMII_STATUS_ADDR >> 2);\r\nif ((data & AUTO_NEG_COMPLETE) && (data & LINK_STATUS))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (!(data & AUTO_NEG_COMPLETE) || !(data & LINK_STATUS))\r\nnetdev_err(p->ndev, "Auto-negotiation failed\n");\r\n}\r\nstatic void xgene_sgmac_rxtx(struct xgene_enet_pdata *p, u32 bits, bool set)\r\n{\r\nu32 data;\r\ndata = xgene_enet_rd_mac(p, MAC_CONFIG_1_ADDR);\r\nif (set)\r\ndata |= bits;\r\nelse\r\ndata &= ~bits;\r\nxgene_enet_wr_mac(p, MAC_CONFIG_1_ADDR, data);\r\n}\r\nstatic void xgene_sgmac_flowctl_tx(struct xgene_enet_pdata *p, bool enable)\r\n{\r\nxgene_sgmac_rxtx(p, TX_FLOW_EN, enable);\r\np->mac_ops->enable_tx_pause(p, enable);\r\n}\r\nstatic void xgene_sgmac_flowctl_rx(struct xgene_enet_pdata *pdata, bool enable)\r\n{\r\nxgene_sgmac_rxtx(pdata, RX_FLOW_EN, enable);\r\n}\r\nstatic void xgene_sgmac_init(struct xgene_enet_pdata *p)\r\n{\r\nu32 pause_thres_reg, pause_off_thres_reg;\r\nu32 enet_spare_cfg_reg, rsif_config_reg;\r\nu32 cfg_bypass_reg, rx_dv_gate_reg;\r\nu32 data, data1, data2, offset;\r\nu32 multi_dpf_reg;\r\nif (!(p->enet_id == XGENE_ENET2 && p->mdio_driver))\r\nxgene_sgmac_reset(p);\r\nxgene_sgmii_enable_autoneg(p);\r\nxgene_sgmac_set_speed(p);\r\nxgene_sgmac_set_mac_addr(p);\r\nif (p->enet_id == XGENE_ENET1) {\r\nenet_spare_cfg_reg = ENET_SPARE_CFG_REG_ADDR;\r\nrsif_config_reg = RSIF_CONFIG_REG_ADDR;\r\ncfg_bypass_reg = CFG_BYPASS_ADDR;\r\noffset = p->port_id * OFFSET_4;\r\nrx_dv_gate_reg = SG_RX_DV_GATE_REG_0_ADDR + offset;\r\n} else {\r\nenet_spare_cfg_reg = XG_ENET_SPARE_CFG_REG_ADDR;\r\nrsif_config_reg = XG_RSIF_CONFIG_REG_ADDR;\r\ncfg_bypass_reg = XG_CFG_BYPASS_ADDR;\r\nrx_dv_gate_reg = XG_MCX_RX_DV_GATE_REG_0_ADDR;\r\n}\r\ndata = xgene_enet_rd_csr(p, enet_spare_cfg_reg);\r\ndata |= MPA_IDLE_WITH_QMI_EMPTY;\r\nxgene_enet_wr_csr(p, enet_spare_cfg_reg, data);\r\ndata = xgene_enet_rd_mac(p, MII_MGMT_CONFIG_ADDR);\r\nMGMT_CLOCK_SEL_SET(&data, 7);\r\nxgene_enet_wr_mac(p, MII_MGMT_CONFIG_ADDR, data);\r\ndata = xgene_enet_rd_csr(p, rsif_config_reg);\r\ndata |= CFG_RSIF_FPBUFF_TIMEOUT_EN;\r\nxgene_enet_wr_csr(p, rsif_config_reg, data);\r\nmulti_dpf_reg = (p->enet_id == XGENE_ENET1) ? CSR_MULTI_DPF0_ADDR :\r\nXG_MCX_MULTI_DPF0_ADDR;\r\ndata = xgene_enet_rd_mcx_csr(p, multi_dpf_reg);\r\ndata = (DEF_QUANTA << 16) | (data & 0xffff);\r\nxgene_enet_wr_mcx_csr(p, multi_dpf_reg, data);\r\nif (p->enet_id != XGENE_ENET1) {\r\ndata = xgene_enet_rd_mcx_csr(p, XG_MCX_MULTI_DPF1_ADDR);\r\ndata = (NORM_PAUSE_OPCODE << 16) | (data & 0xFFFF);\r\nxgene_enet_wr_mcx_csr(p, XG_MCX_MULTI_DPF1_ADDR, data);\r\n}\r\npause_thres_reg = (p->enet_id == XGENE_ENET1) ? RXBUF_PAUSE_THRESH :\r\nXG_RXBUF_PAUSE_THRESH;\r\npause_off_thres_reg = (p->enet_id == XGENE_ENET1) ?\r\nRXBUF_PAUSE_OFF_THRESH : 0;\r\nif (p->enet_id == XGENE_ENET1) {\r\ndata1 = xgene_enet_rd_csr(p, pause_thres_reg);\r\ndata2 = xgene_enet_rd_csr(p, pause_off_thres_reg);\r\nif (!(p->port_id % 2)) {\r\ndata1 = (data1 & 0xffff0000) | DEF_PAUSE_THRES;\r\ndata2 = (data2 & 0xffff0000) | DEF_PAUSE_OFF_THRES;\r\n} else {\r\ndata1 = (data1 & 0xffff) | (DEF_PAUSE_THRES << 16);\r\ndata2 = (data2 & 0xffff) | (DEF_PAUSE_OFF_THRES << 16);\r\n}\r\nxgene_enet_wr_csr(p, pause_thres_reg, data1);\r\nxgene_enet_wr_csr(p, pause_off_thres_reg, data2);\r\n} else {\r\ndata = (DEF_PAUSE_OFF_THRES << 16) | DEF_PAUSE_THRES;\r\nxgene_enet_wr_csr(p, pause_thres_reg, data);\r\n}\r\nxgene_sgmac_flowctl_tx(p, p->tx_pause);\r\nxgene_sgmac_flowctl_rx(p, p->rx_pause);\r\nxgene_enet_wr_csr(p, XG_ENET_SPARE_CFG_REG_1_ADDR, 0x84);\r\nxgene_enet_wr_csr(p, cfg_bypass_reg, RESUME_TX);\r\nxgene_enet_wr_mcx_csr(p, rx_dv_gate_reg, RESUME_RX0);\r\n}\r\nstatic void xgene_sgmac_rx_enable(struct xgene_enet_pdata *p)\r\n{\r\nxgene_sgmac_rxtx(p, RX_EN, true);\r\n}\r\nstatic void xgene_sgmac_tx_enable(struct xgene_enet_pdata *p)\r\n{\r\nxgene_sgmac_rxtx(p, TX_EN, true);\r\n}\r\nstatic void xgene_sgmac_rx_disable(struct xgene_enet_pdata *p)\r\n{\r\nxgene_sgmac_rxtx(p, RX_EN, false);\r\n}\r\nstatic void xgene_sgmac_tx_disable(struct xgene_enet_pdata *p)\r\n{\r\nxgene_sgmac_rxtx(p, TX_EN, false);\r\n}\r\nstatic int xgene_enet_reset(struct xgene_enet_pdata *p)\r\n{\r\nstruct device *dev = &p->pdev->dev;\r\nif (!xgene_ring_mgr_init(p))\r\nreturn -ENODEV;\r\nif (p->mdio_driver && p->enet_id == XGENE_ENET2) {\r\nxgene_enet_config_ring_if_assoc(p);\r\nreturn 0;\r\n}\r\nif (p->enet_id == XGENE_ENET2)\r\nxgene_enet_wr_clkrst_csr(p, XGENET_CONFIG_REG_ADDR, SGMII_EN);\r\nif (dev->of_node) {\r\nif (!IS_ERR(p->clk)) {\r\nclk_prepare_enable(p->clk);\r\nudelay(5);\r\nclk_disable_unprepare(p->clk);\r\nudelay(5);\r\nclk_prepare_enable(p->clk);\r\nudelay(5);\r\n}\r\n} else {\r\n#ifdef CONFIG_ACPI\r\nif (acpi_has_method(ACPI_HANDLE(&p->pdev->dev), "_RST"))\r\nacpi_evaluate_object(ACPI_HANDLE(&p->pdev->dev),\r\n"_RST", NULL, NULL);\r\nelse if (acpi_has_method(ACPI_HANDLE(&p->pdev->dev), "_INI"))\r\nacpi_evaluate_object(ACPI_HANDLE(&p->pdev->dev),\r\n"_INI", NULL, NULL);\r\n#endif\r\n}\r\nif (!p->port_id) {\r\nxgene_enet_ecc_init(p);\r\nxgene_enet_config_ring_if_assoc(p);\r\n}\r\nreturn 0;\r\n}\r\nstatic void xgene_enet_cle_bypass(struct xgene_enet_pdata *p,\r\nu32 dst_ring_num, u16 bufpool_id,\r\nu16 nxtbufpool_id)\r\n{\r\nu32 cle_bypass_reg0, cle_bypass_reg1;\r\nu32 offset = p->port_id * MAC_OFFSET;\r\nu32 data, fpsel, nxtfpsel;\r\nif (p->enet_id == XGENE_ENET1) {\r\ncle_bypass_reg0 = CLE_BYPASS_REG0_0_ADDR;\r\ncle_bypass_reg1 = CLE_BYPASS_REG1_0_ADDR;\r\n} else {\r\ncle_bypass_reg0 = XCLE_BYPASS_REG0_ADDR;\r\ncle_bypass_reg1 = XCLE_BYPASS_REG1_ADDR;\r\n}\r\ndata = CFG_CLE_BYPASS_EN0;\r\nxgene_enet_wr_csr(p, cle_bypass_reg0 + offset, data);\r\nfpsel = xgene_enet_get_fpsel(bufpool_id);\r\nnxtfpsel = xgene_enet_get_fpsel(nxtbufpool_id);\r\ndata = CFG_CLE_DSTQID0(dst_ring_num) | CFG_CLE_FPSEL0(fpsel) |\r\nCFG_CLE_NXTFPSEL0(nxtfpsel);\r\nxgene_enet_wr_csr(p, cle_bypass_reg1 + offset, data);\r\n}\r\nstatic void xgene_enet_clear(struct xgene_enet_pdata *pdata,\r\nstruct xgene_enet_desc_ring *ring)\r\n{\r\nu32 addr, data;\r\nif (xgene_enet_is_bufpool(ring->id)) {\r\naddr = ENET_CFGSSQMIFPRESET_ADDR;\r\ndata = BIT(xgene_enet_get_fpsel(ring->id));\r\n} else {\r\naddr = ENET_CFGSSQMIWQRESET_ADDR;\r\ndata = BIT(xgene_enet_ring_bufnum(ring->id));\r\n}\r\nxgene_enet_wr_ring_if(pdata, addr, data);\r\n}\r\nstatic void xgene_enet_shutdown(struct xgene_enet_pdata *p)\r\n{\r\nstruct device *dev = &p->pdev->dev;\r\nstruct xgene_enet_desc_ring *ring;\r\nu32 pb;\r\nint i;\r\npb = 0;\r\nfor (i = 0; i < p->rxq_cnt; i++) {\r\nring = p->rx_ring[i]->buf_pool;\r\npb |= BIT(xgene_enet_get_fpsel(ring->id));\r\nring = p->rx_ring[i]->page_pool;\r\nif (ring)\r\npb |= BIT(xgene_enet_get_fpsel(ring->id));\r\n}\r\nxgene_enet_wr_ring_if(p, ENET_CFGSSQMIFPRESET_ADDR, pb);\r\npb = 0;\r\nfor (i = 0; i < p->txq_cnt; i++) {\r\nring = p->tx_ring[i];\r\npb |= BIT(xgene_enet_ring_bufnum(ring->id));\r\n}\r\nxgene_enet_wr_ring_if(p, ENET_CFGSSQMIWQRESET_ADDR, pb);\r\nif (dev->of_node) {\r\nif (!IS_ERR(p->clk))\r\nclk_disable_unprepare(p->clk);\r\n}\r\n}\r\nstatic void xgene_enet_link_state(struct work_struct *work)\r\n{\r\nstruct xgene_enet_pdata *p = container_of(to_delayed_work(work),\r\nstruct xgene_enet_pdata, link_work);\r\nstruct net_device *ndev = p->ndev;\r\nu32 link, poll_interval;\r\nlink = xgene_enet_link_status(p);\r\nif (link) {\r\nif (!netif_carrier_ok(ndev)) {\r\nnetif_carrier_on(ndev);\r\nxgene_sgmac_set_speed(p);\r\nxgene_sgmac_rx_enable(p);\r\nxgene_sgmac_tx_enable(p);\r\nnetdev_info(ndev, "Link is Up - %dMbps\n",\r\np->phy_speed);\r\n}\r\npoll_interval = PHY_POLL_LINK_ON;\r\n} else {\r\nif (netif_carrier_ok(ndev)) {\r\nxgene_sgmac_rx_disable(p);\r\nxgene_sgmac_tx_disable(p);\r\nnetif_carrier_off(ndev);\r\nnetdev_info(ndev, "Link is Down\n");\r\n}\r\npoll_interval = PHY_POLL_LINK_OFF;\r\n}\r\nschedule_delayed_work(&p->link_work, poll_interval);\r\n}\r\nstatic void xgene_sgmac_enable_tx_pause(struct xgene_enet_pdata *p, bool enable)\r\n{\r\nu32 data, ecm_cfg_addr;\r\nif (p->enet_id == XGENE_ENET1) {\r\necm_cfg_addr = (!(p->port_id % 2)) ? CSR_ECM_CFG_0_ADDR :\r\nCSR_ECM_CFG_1_ADDR;\r\n} else {\r\necm_cfg_addr = XG_MCX_ECM_CFG_0_ADDR;\r\n}\r\ndata = xgene_enet_rd_mcx_csr(p, ecm_cfg_addr);\r\nif (enable)\r\ndata |= MULTI_DPF_AUTOCTRL | PAUSE_XON_EN;\r\nelse\r\ndata &= ~(MULTI_DPF_AUTOCTRL | PAUSE_XON_EN);\r\nxgene_enet_wr_mcx_csr(p, ecm_cfg_addr, data);\r\n}
