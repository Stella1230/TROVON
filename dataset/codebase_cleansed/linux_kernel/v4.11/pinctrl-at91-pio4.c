static unsigned int atmel_gpio_read(struct atmel_pioctrl *atmel_pioctrl,\r\nunsigned int bank, unsigned int reg)\r\n{\r\nreturn readl_relaxed(atmel_pioctrl->reg_base\r\n+ ATMEL_PIO_BANK_OFFSET * bank + reg);\r\n}\r\nstatic void atmel_gpio_write(struct atmel_pioctrl *atmel_pioctrl,\r\nunsigned int bank, unsigned int reg,\r\nunsigned int val)\r\n{\r\nwritel_relaxed(val, atmel_pioctrl->reg_base\r\n+ ATMEL_PIO_BANK_OFFSET * bank + reg);\r\n}\r\nstatic void atmel_gpio_irq_ack(struct irq_data *d)\r\n{\r\n}\r\nstatic int atmel_gpio_irq_set_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[d->hwirq];\r\nunsigned reg;\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_MSKR,\r\nBIT(pin->line));\r\nreg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR);\r\nreg &= (~ATMEL_PIO_CFGR_EVTSEL_MASK);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreg |= ATMEL_PIO_CFGR_EVTSEL_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreg |= ATMEL_PIO_CFGR_EVTSEL_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreg |= ATMEL_PIO_CFGR_EVTSEL_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nirq_set_handler_locked(d, handle_level_irq);\r\nreg |= ATMEL_PIO_CFGR_EVTSEL_LOW;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nirq_set_handler_locked(d, handle_level_irq);\r\nreg |= ATMEL_PIO_CFGR_EVTSEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_NONE:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR, reg);\r\nreturn 0;\r\n}\r\nstatic void atmel_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[d->hwirq];\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_IDR,\r\nBIT(pin->line));\r\n}\r\nstatic void atmel_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[d->hwirq];\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_IER,\r\nBIT(pin->line));\r\n}\r\nstatic int atmel_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\r\nint bank = ATMEL_PIO_BANK(d->hwirq);\r\nint line = ATMEL_PIO_LINE(d->hwirq);\r\nirq_set_irq_wake(atmel_pioctrl->irqs[bank], on);\r\nif (on)\r\natmel_pioctrl->pm_wakeup_sources[bank] |= BIT(line);\r\nelse\r\natmel_pioctrl->pm_wakeup_sources[bank] &= ~(BIT(line));\r\nreturn 0;\r\n}\r\nstatic void atmel_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nstruct atmel_pioctrl *atmel_pioctrl = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned long isr;\r\nint n, bank = -1;\r\nfor (n = 0; n < atmel_pioctrl->nbanks; n++) {\r\nif (atmel_pioctrl->irqs[n] == irq) {\r\nbank = n;\r\nbreak;\r\n}\r\n}\r\nif (bank < 0) {\r\ndev_err(atmel_pioctrl->dev,\r\n"no bank associated to irq %u\n", irq);\r\nreturn;\r\n}\r\nchained_irq_enter(chip, desc);\r\nfor (;;) {\r\nisr = (unsigned long)atmel_gpio_read(atmel_pioctrl, bank,\r\nATMEL_PIO_ISR);\r\nisr &= (unsigned long)atmel_gpio_read(atmel_pioctrl, bank,\r\nATMEL_PIO_IMR);\r\nif (!isr)\r\nbreak;\r\nfor_each_set_bit(n, &isr, BITS_PER_LONG)\r\ngeneric_handle_irq(gpio_to_irq(bank *\r\nATMEL_PIO_NPINS_PER_BANK + n));\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int atmel_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\r\nunsigned reg;\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_MSKR,\r\nBIT(pin->line));\r\nreg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR);\r\nreg &= ~ATMEL_PIO_DIR_MASK;\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR, reg);\r\nreturn 0;\r\n}\r\nstatic int atmel_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\r\nunsigned reg;\r\nreg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_PDSR);\r\nreturn !!(reg & BIT(pin->line));\r\n}\r\nstatic int atmel_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\r\nunsigned reg;\r\natmel_gpio_write(atmel_pioctrl, pin->bank,\r\nvalue ? ATMEL_PIO_SODR : ATMEL_PIO_CODR,\r\nBIT(pin->line));\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_MSKR,\r\nBIT(pin->line));\r\nreg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR);\r\nreg |= ATMEL_PIO_DIR_MASK;\r\natmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR, reg);\r\nreturn 0;\r\n}\r\nstatic void atmel_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\r\nstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\r\natmel_gpio_write(atmel_pioctrl, pin->bank,\r\nval ? ATMEL_PIO_SODR : ATMEL_PIO_CODR,\r\nBIT(pin->line));\r\n}\r\nstatic int atmel_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\r\nreturn irq_find_mapping(atmel_pioctrl->irq_domain, offset);\r\n}\r\nstatic unsigned int atmel_pin_config_read(struct pinctrl_dev *pctldev,\r\nunsigned pin_id)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned bank = atmel_pioctrl->pins[pin_id]->bank;\r\nunsigned line = atmel_pioctrl->pins[pin_id]->line;\r\nvoid __iomem *addr = atmel_pioctrl->reg_base\r\n+ bank * ATMEL_PIO_BANK_OFFSET;\r\nwritel_relaxed(BIT(line), addr + ATMEL_PIO_MSKR);\r\nwmb();\r\nreturn readl_relaxed(addr + ATMEL_PIO_CFGR);\r\n}\r\nstatic void atmel_pin_config_write(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, u32 conf)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned bank = atmel_pioctrl->pins[pin_id]->bank;\r\nunsigned line = atmel_pioctrl->pins[pin_id]->line;\r\nvoid __iomem *addr = atmel_pioctrl->reg_base\r\n+ bank * ATMEL_PIO_BANK_OFFSET;\r\nwritel_relaxed(BIT(line), addr + ATMEL_PIO_MSKR);\r\nwmb();\r\nwritel_relaxed(conf, addr + ATMEL_PIO_CFGR);\r\n}\r\nstatic int atmel_pctl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn atmel_pioctrl->npins;\r\n}\r\nstatic const char *atmel_pctl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn atmel_pioctrl->groups[selector].name;\r\n}\r\nstatic int atmel_pctl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector, const unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = (unsigned *)&atmel_pioctrl->groups[selector].pin;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic struct atmel_group *\r\natmel_pctl_find_group_by_pin(struct pinctrl_dev *pctldev, unsigned pin)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nint i;\r\nfor (i = 0; i < atmel_pioctrl->npins; i++) {\r\nstruct atmel_group *grp = atmel_pioctrl->groups + i;\r\nif (grp->pin == pin)\r\nreturn grp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int atmel_pctl_xlate_pinfunc(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nu32 pinfunc, const char **grp_name,\r\nconst char **func_name)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned pin_id, func_id;\r\nstruct atmel_group *grp;\r\npin_id = ATMEL_GET_PIN_NO(pinfunc);\r\nfunc_id = ATMEL_GET_PIN_FUNC(pinfunc);\r\nif (func_id >= ARRAY_SIZE(atmel_functions))\r\nreturn -EINVAL;\r\n*func_name = atmel_functions[func_id];\r\ngrp = atmel_pctl_find_group_by_pin(pctldev, pin_id);\r\nif (!grp)\r\nreturn -EINVAL;\r\n*grp_name = grp->name;\r\natmel_pioctrl->pins[pin_id]->mux = func_id;\r\natmel_pioctrl->pins[pin_id]->ioset = ATMEL_GET_PIN_IOSET(pinfunc);\r\nif (np->parent == atmel_pioctrl->node)\r\natmel_pioctrl->pins[pin_id]->device = np->name;\r\nelse\r\natmel_pioctrl->pins[pin_id]->device = np->parent->name;\r\nreturn 0;\r\n}\r\nstatic int atmel_pctl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nunsigned num_pins, num_configs, reserve;\r\nunsigned long *configs;\r\nstruct property *pins;\r\nbool has_config;\r\nu32 pinfunc;\r\nint ret, i;\r\npins = of_find_property(np, "pinmux", NULL);\r\nif (!pins)\r\nreturn -EINVAL;\r\nret = pinconf_generic_parse_dt_config(np, pctldev, &configs,\r\n&num_configs);\r\nif (ret < 0) {\r\ndev_err(pctldev->dev, "%s: could not parse node property\n",\r\nof_node_full_name(np));\r\nreturn ret;\r\n}\r\nif (num_configs)\r\nhas_config = true;\r\nnum_pins = pins->length / sizeof(u32);\r\nif (!num_pins) {\r\ndev_err(pctldev->dev, "no pins found in node %s\n",\r\nof_node_full_name(np));\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nreserve = 1;\r\nif (has_config && num_pins >= 1)\r\nreserve++;\r\nreserve *= num_pins;\r\nret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps, num_maps,\r\nreserve);\r\nif (ret < 0)\r\ngoto exit;\r\nfor (i = 0; i < num_pins; i++) {\r\nconst char *group, *func;\r\nret = of_property_read_u32_index(np, "pinmux", i, &pinfunc);\r\nif (ret)\r\ngoto exit;\r\nret = atmel_pctl_xlate_pinfunc(pctldev, np, pinfunc, &group,\r\n&func);\r\nif (ret)\r\ngoto exit;\r\npinctrl_utils_add_map_mux(pctldev, map, reserved_maps, num_maps,\r\ngroup, func);\r\nif (has_config) {\r\nret = pinctrl_utils_add_map_configs(pctldev, map,\r\nreserved_maps, num_maps, group,\r\nconfigs, num_configs,\r\nPIN_MAP_TYPE_CONFIGS_GROUP);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic int atmel_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct device_node *np;\r\nunsigned reserved_maps;\r\nint ret;\r\n*map = NULL;\r\n*num_maps = 0;\r\nreserved_maps = 0;\r\nret = atmel_pctl_dt_subnode_to_map(pctldev, np_config, map,\r\n&reserved_maps, num_maps);\r\nif (ret) {\r\nfor_each_child_of_node(np_config, np) {\r\nret = atmel_pctl_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\npinctrl_utils_free_map(pctldev, *map, *num_maps);\r\ndev_err(pctldev->dev, "can't create maps for node %s\n",\r\nnp_config->full_name);\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_pmx_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(atmel_functions);\r\n}\r\nstatic const char *atmel_pmx_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nreturn atmel_functions[selector];\r\n}\r\nstatic int atmel_pmx_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = atmel_pioctrl->group_names;\r\n*num_groups = atmel_pioctrl->npins;\r\nreturn 0;\r\n}\r\nstatic int atmel_pmx_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned pin;\r\nu32 conf;\r\ndev_dbg(pctldev->dev, "enable function %s group %s\n",\r\natmel_functions[function], atmel_pioctrl->groups[group].name);\r\npin = atmel_pioctrl->groups[group].pin;\r\nconf = atmel_pin_config_read(pctldev, pin);\r\nconf &= (~ATMEL_PIO_CFGR_FUNC_MASK);\r\nconf |= (function & ATMEL_PIO_CFGR_FUNC_MASK);\r\ndev_dbg(pctldev->dev, "pin: %u, conf: 0x%08x\n", pin, conf);\r\natmel_pin_config_write(pctldev, pin, conf);\r\nreturn 0;\r\n}\r\nstatic int atmel_conf_pin_config_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *config)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned param = pinconf_to_config_param(*config), arg = 0;\r\nstruct atmel_group *grp = atmel_pioctrl->groups + group;\r\nunsigned pin_id = grp->pin;\r\nu32 res;\r\nres = atmel_pin_config_read(pctldev, pin_id);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (!(res & ATMEL_PIO_PUEN_MASK))\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif ((res & ATMEL_PIO_PUEN_MASK) ||\r\n(!(res & ATMEL_PIO_PDEN_MASK)))\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif ((res & ATMEL_PIO_PUEN_MASK) ||\r\n((res & ATMEL_PIO_PDEN_MASK)))\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (!(res & ATMEL_PIO_OPD_MASK))\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (!(res & ATMEL_PIO_SCHMITT_MASK))\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int atmel_conf_pin_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct atmel_group *grp = atmel_pioctrl->groups + group;\r\nunsigned bank, pin, pin_id = grp->pin;\r\nu32 mask, conf = 0;\r\nint i;\r\nconf = atmel_pin_config_read(pctldev, pin_id);\r\nfor (i = 0; i < num_configs; i++) {\r\nunsigned param = pinconf_to_config_param(configs[i]);\r\nunsigned arg = pinconf_to_config_argument(configs[i]);\r\ndev_dbg(pctldev->dev, "%s: pin=%u, config=0x%lx\n",\r\n__func__, pin_id, configs[i]);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nconf &= (~ATMEL_PIO_PUEN_MASK);\r\nconf &= (~ATMEL_PIO_PDEN_MASK);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nconf |= ATMEL_PIO_PUEN_MASK;\r\nconf &= (~ATMEL_PIO_PDEN_MASK);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nconf |= ATMEL_PIO_PDEN_MASK;\r\nconf &= (~ATMEL_PIO_PUEN_MASK);\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nif (arg == 0)\r\nconf &= (~ATMEL_PIO_OPD_MASK);\r\nelse\r\nconf |= ATMEL_PIO_OPD_MASK;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\r\nif (arg == 0)\r\nconf |= ATMEL_PIO_SCHMITT_MASK;\r\nelse\r\nconf &= (~ATMEL_PIO_SCHMITT_MASK);\r\nbreak;\r\ncase PIN_CONFIG_INPUT_DEBOUNCE:\r\nif (arg == 0) {\r\nconf &= (~ATMEL_PIO_IFEN_MASK);\r\nconf &= (~ATMEL_PIO_IFSCEN_MASK);\r\n} else {\r\nconf |= ATMEL_PIO_IFEN_MASK;\r\nconf |= ATMEL_PIO_IFSCEN_MASK;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nconf |= ATMEL_PIO_DIR_MASK;\r\nbank = ATMEL_PIO_BANK(pin_id);\r\npin = ATMEL_PIO_LINE(pin_id);\r\nmask = 1 << pin;\r\nif (arg == 0) {\r\nwritel_relaxed(mask, atmel_pioctrl->reg_base +\r\nbank * ATMEL_PIO_BANK_OFFSET +\r\nATMEL_PIO_CODR);\r\n} else {\r\nwritel_relaxed(mask, atmel_pioctrl->reg_base +\r\nbank * ATMEL_PIO_BANK_OFFSET +\r\nATMEL_PIO_SODR);\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(pctldev->dev,\r\n"unsupported configuration parameter: %u\n",\r\nparam);\r\ncontinue;\r\n}\r\n}\r\ndev_dbg(pctldev->dev, "%s: reg=0x%08x\n", __func__, conf);\r\natmel_pin_config_write(pctldev, pin_id, conf);\r\nreturn 0;\r\n}\r\nstatic void atmel_conf_pin_config_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin_id)\r\n{\r\nstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\r\nu32 conf;\r\nif (!atmel_pioctrl->pins[pin_id]->device)\r\nreturn;\r\nif (atmel_pioctrl->pins[pin_id])\r\nseq_printf(s, " (%s, ioset %u) ",\r\natmel_pioctrl->pins[pin_id]->device,\r\natmel_pioctrl->pins[pin_id]->ioset);\r\nconf = atmel_pin_config_read(pctldev, pin_id);\r\nif (conf & ATMEL_PIO_PUEN_MASK)\r\nseq_printf(s, "%s ", "pull-up");\r\nif (conf & ATMEL_PIO_PDEN_MASK)\r\nseq_printf(s, "%s ", "pull-down");\r\nif (conf & ATMEL_PIO_IFEN_MASK)\r\nseq_printf(s, "%s ", "debounce");\r\nif (conf & ATMEL_PIO_OPD_MASK)\r\nseq_printf(s, "%s ", "open-drain");\r\nif (conf & ATMEL_PIO_SCHMITT_MASK)\r\nseq_printf(s, "%s ", "schmitt");\r\n}\r\nstatic int __maybe_unused atmel_pctrl_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct atmel_pioctrl *atmel_pioctrl = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < atmel_pioctrl->nbanks; i++) {\r\natmel_pioctrl->pm_suspend_backup[i] =\r\natmel_gpio_read(atmel_pioctrl, i, ATMEL_PIO_IMR);\r\natmel_gpio_write(atmel_pioctrl, i, ATMEL_PIO_IDR,\r\n~atmel_pioctrl->pm_wakeup_sources[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused atmel_pctrl_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct atmel_pioctrl *atmel_pioctrl = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < atmel_pioctrl->nbanks; i++)\r\natmel_gpio_write(atmel_pioctrl, i, ATMEL_PIO_IER,\r\natmel_pioctrl->pm_suspend_backup[i]);\r\nreturn 0;\r\n}\r\nstatic int atmel_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pinctrl_pin_desc *pin_desc;\r\nconst char **group_names;\r\nconst struct of_device_id *match;\r\nint i, ret;\r\nstruct resource *res;\r\nstruct atmel_pioctrl *atmel_pioctrl;\r\nstruct atmel_pioctrl_data *atmel_pioctrl_data;\r\natmel_pioctrl = devm_kzalloc(dev, sizeof(*atmel_pioctrl), GFP_KERNEL);\r\nif (!atmel_pioctrl)\r\nreturn -ENOMEM;\r\natmel_pioctrl->dev = dev;\r\natmel_pioctrl->node = dev->of_node;\r\nplatform_set_drvdata(pdev, atmel_pioctrl);\r\nmatch = of_match_node(atmel_pctrl_of_match, dev->of_node);\r\nif (!match) {\r\ndev_err(dev, "unknown compatible string\n");\r\nreturn -ENODEV;\r\n}\r\natmel_pioctrl_data = (struct atmel_pioctrl_data *)match->data;\r\natmel_pioctrl->nbanks = atmel_pioctrl_data->nbanks;\r\natmel_pioctrl->npins = atmel_pioctrl->nbanks * ATMEL_PIO_NPINS_PER_BANK;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "unable to get atmel pinctrl resource\n");\r\nreturn -EINVAL;\r\n}\r\natmel_pioctrl->reg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(atmel_pioctrl->reg_base))\r\nreturn -EINVAL;\r\natmel_pioctrl->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(atmel_pioctrl->clk)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(atmel_pioctrl->clk);\r\n}\r\natmel_pioctrl->pins = devm_kzalloc(dev, sizeof(*atmel_pioctrl->pins)\r\n* atmel_pioctrl->npins, GFP_KERNEL);\r\nif (!atmel_pioctrl->pins)\r\nreturn -ENOMEM;\r\npin_desc = devm_kzalloc(dev, sizeof(*pin_desc)\r\n* atmel_pioctrl->npins, GFP_KERNEL);\r\nif (!pin_desc)\r\nreturn -ENOMEM;\r\natmel_pinctrl_desc.pins = pin_desc;\r\natmel_pinctrl_desc.npins = atmel_pioctrl->npins;\r\ngroup_names = devm_kzalloc(dev, sizeof(*group_names)\r\n* atmel_pioctrl->npins, GFP_KERNEL);\r\nif (!group_names)\r\nreturn -ENOMEM;\r\natmel_pioctrl->group_names = group_names;\r\natmel_pioctrl->groups = devm_kzalloc(&pdev->dev,\r\nsizeof(*atmel_pioctrl->groups) * atmel_pioctrl->npins,\r\nGFP_KERNEL);\r\nif (!atmel_pioctrl->groups)\r\nreturn -ENOMEM;\r\nfor (i = 0 ; i < atmel_pioctrl->npins; i++) {\r\nstruct atmel_group *group = atmel_pioctrl->groups + i;\r\nunsigned bank = ATMEL_PIO_BANK(i);\r\nunsigned line = ATMEL_PIO_LINE(i);\r\natmel_pioctrl->pins[i] = devm_kzalloc(dev,\r\nsizeof(**atmel_pioctrl->pins), GFP_KERNEL);\r\nif (!atmel_pioctrl->pins[i])\r\nreturn -ENOMEM;\r\natmel_pioctrl->pins[i]->pin_id = i;\r\natmel_pioctrl->pins[i]->bank = bank;\r\natmel_pioctrl->pins[i]->line = line;\r\npin_desc[i].number = i;\r\npin_desc[i].name = kasprintf(GFP_KERNEL, "P%c%d",\r\nbank + 'A', line);\r\ngroup->name = group_names[i] = pin_desc[i].name;\r\ngroup->pin = pin_desc[i].number;\r\ndev_dbg(dev, "pin_id=%u, bank=%u, line=%u", i, bank, line);\r\n}\r\natmel_pioctrl->gpio_chip = &atmel_gpio_chip;\r\natmel_pioctrl->gpio_chip->of_node = dev->of_node;\r\natmel_pioctrl->gpio_chip->ngpio = atmel_pioctrl->npins;\r\natmel_pioctrl->gpio_chip->label = dev_name(dev);\r\natmel_pioctrl->gpio_chip->parent = dev;\r\natmel_pioctrl->gpio_chip->names = atmel_pioctrl->group_names;\r\natmel_pioctrl->pm_wakeup_sources = devm_kzalloc(dev,\r\nsizeof(*atmel_pioctrl->pm_wakeup_sources)\r\n* atmel_pioctrl->nbanks, GFP_KERNEL);\r\nif (!atmel_pioctrl->pm_wakeup_sources)\r\nreturn -ENOMEM;\r\natmel_pioctrl->pm_suspend_backup = devm_kzalloc(dev,\r\nsizeof(*atmel_pioctrl->pm_suspend_backup)\r\n* atmel_pioctrl->nbanks, GFP_KERNEL);\r\nif (!atmel_pioctrl->pm_suspend_backup)\r\nreturn -ENOMEM;\r\natmel_pioctrl->irqs = devm_kzalloc(dev, sizeof(*atmel_pioctrl->irqs)\r\n* atmel_pioctrl->nbanks, GFP_KERNEL);\r\nif (!atmel_pioctrl->irqs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < atmel_pioctrl->nbanks; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, i);\r\nif (!res) {\r\ndev_err(dev, "missing irq resource for group %c\n",\r\n'A' + i);\r\nreturn -EINVAL;\r\n}\r\natmel_pioctrl->irqs[i] = res->start;\r\nirq_set_chained_handler(res->start, atmel_gpio_irq_handler);\r\nirq_set_handler_data(res->start, atmel_pioctrl);\r\ndev_dbg(dev, "bank %i: irq=%pr\n", i, res);\r\n}\r\natmel_pioctrl->irq_domain = irq_domain_add_linear(dev->of_node,\r\natmel_pioctrl->gpio_chip->ngpio,\r\n&irq_domain_simple_ops, NULL);\r\nif (!atmel_pioctrl->irq_domain) {\r\ndev_err(dev, "can't add the irq domain\n");\r\nreturn -ENODEV;\r\n}\r\natmel_pioctrl->irq_domain->name = "atmel gpio";\r\nfor (i = 0; i < atmel_pioctrl->npins; i++) {\r\nint irq = irq_create_mapping(atmel_pioctrl->irq_domain, i);\r\nirq_set_chip_and_handler(irq, &atmel_gpio_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(irq, atmel_pioctrl);\r\ndev_dbg(dev,\r\n"atmel gpio irq domain: hwirq: %d, linux irq: %d\n",\r\ni, irq);\r\n}\r\nret = clk_prepare_enable(atmel_pioctrl->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to prepare and enable clock\n");\r\ngoto clk_prepare_enable_error;\r\n}\r\natmel_pioctrl->pinctrl_dev = devm_pinctrl_register(&pdev->dev,\r\n&atmel_pinctrl_desc,\r\natmel_pioctrl);\r\nif (IS_ERR(atmel_pioctrl->pinctrl_dev)) {\r\nret = PTR_ERR(atmel_pioctrl->pinctrl_dev);\r\ndev_err(dev, "pinctrl registration failed\n");\r\ngoto clk_unprep;\r\n}\r\nret = gpiochip_add_data(atmel_pioctrl->gpio_chip, atmel_pioctrl);\r\nif (ret) {\r\ndev_err(dev, "failed to add gpiochip\n");\r\ngoto clk_unprep;\r\n}\r\nret = gpiochip_add_pin_range(atmel_pioctrl->gpio_chip, dev_name(dev),\r\n0, 0, atmel_pioctrl->gpio_chip->ngpio);\r\nif (ret) {\r\ndev_err(dev, "failed to add gpio pin range\n");\r\ngoto gpiochip_add_pin_range_error;\r\n}\r\ndev_info(&pdev->dev, "atmel pinctrl initialized\n");\r\nreturn 0;\r\ngpiochip_add_pin_range_error:\r\ngpiochip_remove(atmel_pioctrl->gpio_chip);\r\nclk_unprep:\r\nclk_disable_unprepare(atmel_pioctrl->clk);\r\nclk_prepare_enable_error:\r\nirq_domain_remove(atmel_pioctrl->irq_domain);\r\nreturn ret;\r\n}
