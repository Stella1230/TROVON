static inline void mdss_write(struct msm_mdss *mdss, u32 reg, u32 data)\r\n{\r\nmsm_writel(data, mdss->mmio + reg);\r\n}\r\nstatic inline u32 mdss_read(struct msm_mdss *mdss, u32 reg)\r\n{\r\nreturn msm_readl(mdss->mmio + reg);\r\n}\r\nstatic irqreturn_t mdss_irq(int irq, void *arg)\r\n{\r\nstruct msm_mdss *mdss = arg;\r\nu32 intr;\r\nintr = mdss_read(mdss, REG_MDSS_HW_INTR_STATUS);\r\nVERB("intr=%08x", intr);\r\nwhile (intr) {\r\nirq_hw_number_t hwirq = fls(intr) - 1;\r\ngeneric_handle_irq(irq_find_mapping(\r\nmdss->irqcontroller.domain, hwirq));\r\nintr &= ~(1 << hwirq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mdss_hw_mask_irq(struct irq_data *irqd)\r\n{\r\nstruct msm_mdss *mdss = irq_data_get_irq_chip_data(irqd);\r\nsmp_mb__before_atomic();\r\nclear_bit(irqd->hwirq, &mdss->irqcontroller.enabled_mask);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic void mdss_hw_unmask_irq(struct irq_data *irqd)\r\n{\r\nstruct msm_mdss *mdss = irq_data_get_irq_chip_data(irqd);\r\nsmp_mb__before_atomic();\r\nset_bit(irqd->hwirq, &mdss->irqcontroller.enabled_mask);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic int mdss_hw_irqdomain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct msm_mdss *mdss = d->host_data;\r\nif (!(VALID_IRQS & (1 << hwirq)))\r\nreturn -EPERM;\r\nirq_set_chip_and_handler(irq, &mdss_hw_irq_chip, handle_level_irq);\r\nirq_set_chip_data(irq, mdss);\r\nreturn 0;\r\n}\r\nstatic int mdss_irq_domain_init(struct msm_mdss *mdss)\r\n{\r\nstruct device *dev = mdss->dev->dev;\r\nstruct irq_domain *d;\r\nd = irq_domain_add_linear(dev->of_node, 32, &mdss_hw_irqdomain_ops,\r\nmdss);\r\nif (!d) {\r\ndev_err(dev, "mdss irq domain add failed\n");\r\nreturn -ENXIO;\r\n}\r\nmdss->irqcontroller.enabled_mask = 0;\r\nmdss->irqcontroller.domain = d;\r\nreturn 0;\r\n}\r\nvoid msm_mdss_destroy(struct drm_device *dev)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_mdss *mdss = priv->mdss;\r\nif (!mdss)\r\nreturn;\r\nirq_domain_remove(mdss->irqcontroller.domain);\r\nmdss->irqcontroller.domain = NULL;\r\nregulator_disable(mdss->vdd);\r\npm_runtime_put_sync(dev->dev);\r\npm_runtime_disable(dev->dev);\r\n}\r\nint msm_mdss_init(struct drm_device *dev)\r\n{\r\nstruct platform_device *pdev = dev->platformdev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_mdss *mdss;\r\nint ret;\r\nDBG("");\r\nif (!of_device_is_compatible(dev->dev->of_node, "qcom,mdss"))\r\nreturn 0;\r\nmdss = devm_kzalloc(dev->dev, sizeof(*mdss), GFP_KERNEL);\r\nif (!mdss) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmdss->dev = dev;\r\nmdss->mmio = msm_ioremap(pdev, "mdss_phys", "MDSS");\r\nif (IS_ERR(mdss->mmio)) {\r\nret = PTR_ERR(mdss->mmio);\r\ngoto fail;\r\n}\r\nmdss->vbif = msm_ioremap(pdev, "vbif_phys", "VBIF");\r\nif (IS_ERR(mdss->vbif)) {\r\nret = PTR_ERR(mdss->vbif);\r\ngoto fail;\r\n}\r\nmdss->vdd = devm_regulator_get(dev->dev, "vdd");\r\nif (IS_ERR(mdss->vdd)) {\r\nret = PTR_ERR(mdss->vdd);\r\ngoto fail;\r\n}\r\nret = regulator_enable(mdss->vdd);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to enable regulator vdd: %d\n",\r\nret);\r\ngoto fail;\r\n}\r\nret = devm_request_irq(dev->dev, platform_get_irq(pdev, 0),\r\nmdss_irq, 0, "mdss_isr", mdss);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to init irq: %d\n", ret);\r\ngoto fail_irq;\r\n}\r\nret = mdss_irq_domain_init(mdss);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to init sub-block irqs: %d\n", ret);\r\ngoto fail_irq;\r\n}\r\npriv->mdss = mdss;\r\npm_runtime_enable(dev->dev);\r\npm_runtime_get_sync(dev->dev);\r\nreturn 0;\r\nfail_irq:\r\nregulator_disable(mdss->vdd);\r\nfail:\r\nreturn ret;\r\n}
