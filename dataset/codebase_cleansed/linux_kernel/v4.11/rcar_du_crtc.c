static u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nreturn rcar_du_read(rcdu, rcrtc->mmio_offset + reg);\r\n}\r\nstatic void rcar_du_crtc_write(struct rcar_du_crtc *rcrtc, u32 reg, u32 data)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg, data);\r\n}\r\nstatic void rcar_du_crtc_clr(struct rcar_du_crtc *rcrtc, u32 reg, u32 clr)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg,\r\nrcar_du_read(rcdu, rcrtc->mmio_offset + reg) & ~clr);\r\n}\r\nstatic void rcar_du_crtc_set(struct rcar_du_crtc *rcrtc, u32 reg, u32 set)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg,\r\nrcar_du_read(rcdu, rcrtc->mmio_offset + reg) | set);\r\n}\r\nstatic void rcar_du_crtc_clr_set(struct rcar_du_crtc *rcrtc, u32 reg,\r\nu32 clr, u32 set)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nu32 value = rcar_du_read(rcdu, rcrtc->mmio_offset + reg);\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg, (value & ~clr) | set);\r\n}\r\nstatic int rcar_du_crtc_get(struct rcar_du_crtc *rcrtc)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(rcrtc->clock);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(rcrtc->extclock);\r\nif (ret < 0)\r\ngoto error_clock;\r\nret = rcar_du_group_get(rcrtc->group);\r\nif (ret < 0)\r\ngoto error_group;\r\nreturn 0;\r\nerror_group:\r\nclk_disable_unprepare(rcrtc->extclock);\r\nerror_clock:\r\nclk_disable_unprepare(rcrtc->clock);\r\nreturn ret;\r\n}\r\nstatic void rcar_du_crtc_put(struct rcar_du_crtc *rcrtc)\r\n{\r\nrcar_du_group_put(rcrtc->group);\r\nclk_disable_unprepare(rcrtc->extclock);\r\nclk_disable_unprepare(rcrtc->clock);\r\n}\r\nstatic void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)\r\n{\r\nconst struct drm_display_mode *mode = &rcrtc->crtc.state->adjusted_mode;\r\nunsigned long mode_clock = mode->clock * 1000;\r\nunsigned long clk;\r\nu32 value;\r\nu32 escr;\r\nu32 div;\r\nclk = clk_get_rate(rcrtc->clock);\r\ndiv = DIV_ROUND_CLOSEST(clk, mode_clock);\r\ndiv = clamp(div, 1U, 64U) - 1;\r\nescr = div | ESCR_DCLKSEL_CLKS;\r\nif (rcrtc->extclock) {\r\nunsigned long extclk;\r\nunsigned long extrate;\r\nunsigned long rate;\r\nu32 extdiv;\r\nextclk = clk_get_rate(rcrtc->extclock);\r\nextdiv = DIV_ROUND_CLOSEST(extclk, mode_clock);\r\nextdiv = clamp(extdiv, 1U, 64U) - 1;\r\nrate = clk / (div + 1);\r\nextrate = extclk / (extdiv + 1);\r\nif (abs((long)extrate - (long)mode_clock) <\r\nabs((long)rate - (long)mode_clock)) {\r\ndev_dbg(rcrtc->group->dev->dev,\r\n"crtc%u: using external clock\n", rcrtc->index);\r\nescr = extdiv | ESCR_DCLKSEL_DCLKIN;\r\n}\r\n}\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? ESCR2 : ESCR,\r\nescr);\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? OTAR2 : OTAR, 0);\r\nvalue = ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? DSMR_VSL : 0)\r\n| ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? DSMR_HSL : 0)\r\n| DSMR_DIPM_DISP | DSMR_CSPM;\r\nrcar_du_crtc_write(rcrtc, DSMR, value);\r\nrcar_du_crtc_write(rcrtc, HDSR, mode->htotal - mode->hsync_start - 19);\r\nrcar_du_crtc_write(rcrtc, HDER, mode->htotal - mode->hsync_start +\r\nmode->hdisplay - 19);\r\nrcar_du_crtc_write(rcrtc, HSWR, mode->hsync_end -\r\nmode->hsync_start - 1);\r\nrcar_du_crtc_write(rcrtc, HCR, mode->htotal - 1);\r\nrcar_du_crtc_write(rcrtc, VDSR, mode->crtc_vtotal -\r\nmode->crtc_vsync_end - 2);\r\nrcar_du_crtc_write(rcrtc, VDER, mode->crtc_vtotal -\r\nmode->crtc_vsync_end +\r\nmode->crtc_vdisplay - 2);\r\nrcar_du_crtc_write(rcrtc, VSPR, mode->crtc_vtotal -\r\nmode->crtc_vsync_end +\r\nmode->crtc_vsync_start - 1);\r\nrcar_du_crtc_write(rcrtc, VCR, mode->crtc_vtotal - 1);\r\nrcar_du_crtc_write(rcrtc, DESR, mode->htotal - mode->hsync_start - 1);\r\nrcar_du_crtc_write(rcrtc, DEWR, mode->hdisplay);\r\n}\r\nvoid rcar_du_crtc_route_output(struct drm_crtc *crtc,\r\nenum rcar_du_output output)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcrtc->outputs |= BIT(output);\r\nif (output == RCAR_DU_OUTPUT_DPAD0)\r\nrcdu->dpad0_source = rcrtc->index;\r\n}\r\nstatic unsigned int plane_zpos(struct rcar_du_plane *plane)\r\n{\r\nreturn plane->plane.state->normalized_zpos;\r\n}\r\nstatic const struct rcar_du_format_info *\r\nplane_format(struct rcar_du_plane *plane)\r\n{\r\nreturn to_rcar_plane_state(plane->plane.state)->format;\r\n}\r\nstatic void rcar_du_crtc_update_planes(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct rcar_du_plane *planes[RCAR_DU_NUM_HW_PLANES];\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nunsigned int num_planes = 0;\r\nunsigned int dptsr_planes;\r\nunsigned int hwplanes = 0;\r\nunsigned int prio = 0;\r\nunsigned int i;\r\nu32 dspr = 0;\r\nfor (i = 0; i < rcrtc->group->num_planes; ++i) {\r\nstruct rcar_du_plane *plane = &rcrtc->group->planes[i];\r\nunsigned int j;\r\nif (plane->plane.state->crtc != &rcrtc->crtc)\r\ncontinue;\r\nfor (j = num_planes++; j > 0; --j) {\r\nif (plane_zpos(planes[j-1]) <= plane_zpos(plane))\r\nbreak;\r\nplanes[j] = planes[j-1];\r\n}\r\nplanes[j] = plane;\r\nprio += plane_format(plane)->planes * 4;\r\n}\r\nfor (i = 0; i < num_planes; ++i) {\r\nstruct rcar_du_plane *plane = planes[i];\r\nstruct drm_plane_state *state = plane->plane.state;\r\nunsigned int index = to_rcar_plane_state(state)->hwindex;\r\nprio -= 4;\r\ndspr |= (index + 1) << prio;\r\nhwplanes |= 1 << index;\r\nif (plane_format(plane)->planes == 2) {\r\nindex = (index + 1) % 8;\r\nprio -= 4;\r\ndspr |= (index + 1) << prio;\r\nhwplanes |= 1 << index;\r\n}\r\n}\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {\r\nif (rcdu->info->gen < 3) {\r\ndspr = (rcrtc->index % 2) + 1;\r\nhwplanes = 1 << (rcrtc->index % 2);\r\n} else {\r\ndspr = (rcrtc->index % 2) ? 3 : 1;\r\nhwplanes = 1 << ((rcrtc->index % 2) ? 2 : 0);\r\n}\r\n}\r\nmutex_lock(&rcrtc->group->lock);\r\ndptsr_planes = rcrtc->index % 2 ? rcrtc->group->dptsr_planes | hwplanes\r\n: rcrtc->group->dptsr_planes & ~hwplanes;\r\nif (dptsr_planes != rcrtc->group->dptsr_planes) {\r\nrcar_du_group_write(rcrtc->group, DPTSR,\r\n(dptsr_planes << 16) | dptsr_planes);\r\nrcrtc->group->dptsr_planes = dptsr_planes;\r\nif (rcrtc->group->used_crtcs)\r\nrcar_du_group_restart(rcrtc->group);\r\n}\r\nif (rcrtc->group->need_restart)\r\nrcar_du_group_restart(rcrtc->group);\r\nmutex_unlock(&rcrtc->group->lock);\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR,\r\ndspr);\r\n}\r\nstatic void rcar_du_crtc_finish_page_flip(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = rcrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = rcrtc->event;\r\nrcrtc->event = NULL;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nif (event == NULL)\r\nreturn;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\ndrm_crtc_send_vblank_event(&rcrtc->crtc, event);\r\nwake_up(&rcrtc->flip_wait);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ndrm_crtc_vblank_put(&rcrtc->crtc);\r\n}\r\nstatic bool rcar_du_crtc_page_flip_pending(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_device *dev = rcrtc->crtc.dev;\r\nunsigned long flags;\r\nbool pending;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\npending = rcrtc->event != NULL;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn pending;\r\n}\r\nstatic void rcar_du_crtc_wait_page_flip(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nif (wait_event_timeout(rcrtc->flip_wait,\r\n!rcar_du_crtc_page_flip_pending(rcrtc),\r\nmsecs_to_jiffies(50)))\r\nreturn;\r\ndev_warn(rcdu->dev, "page flip timeout\n");\r\nrcar_du_crtc_finish_page_flip(rcrtc);\r\n}\r\nstatic void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nbool interlaced;\r\nif (rcrtc->started)\r\nreturn;\r\nrcar_du_crtc_write(rcrtc, DOOR, DOOR_RGB(0, 0, 0));\r\nrcar_du_crtc_write(rcrtc, BPOR, BPOR_RGB(0, 0, 0));\r\nrcar_du_crtc_set_display_timing(rcrtc);\r\nrcar_du_group_set_routing(rcrtc->group);\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR, 0);\r\ninterlaced = rcrtc->crtc.mode.flags & DRM_MODE_FLAG_INTERLACE;\r\nrcar_du_crtc_clr_set(rcrtc, DSYSR, DSYSR_TVM_MASK | DSYSR_SCM_MASK,\r\n(interlaced ? DSYSR_SCM_INT_VIDEO : 0) |\r\nDSYSR_TVM_MASTER);\r\nrcar_du_group_start_stop(rcrtc->group, true);\r\nif (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\r\nrcar_du_vsp_enable(rcrtc);\r\ndrm_crtc_vblank_on(crtc);\r\nrcrtc->started = true;\r\n}\r\nstatic void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nif (!rcrtc->started)\r\nreturn;\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR, 0);\r\ndrm_crtc_wait_one_vblank(crtc);\r\nrcar_du_crtc_wait_page_flip(rcrtc);\r\ndrm_crtc_vblank_off(crtc);\r\nif (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\r\nrcar_du_vsp_disable(rcrtc);\r\nrcar_du_crtc_clr_set(rcrtc, DSYSR, DSYSR_TVM_MASK, DSYSR_TVM_SWITCH);\r\nrcar_du_group_start_stop(rcrtc->group, false);\r\nrcrtc->started = false;\r\n}\r\nvoid rcar_du_crtc_suspend(struct rcar_du_crtc *rcrtc)\r\n{\r\nif (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\r\nrcar_du_vsp_disable(rcrtc);\r\nrcar_du_crtc_stop(rcrtc);\r\nrcar_du_crtc_put(rcrtc);\r\n}\r\nvoid rcar_du_crtc_resume(struct rcar_du_crtc *rcrtc)\r\n{\r\nunsigned int i;\r\nif (!rcrtc->crtc.state->active)\r\nreturn;\r\nrcar_du_crtc_get(rcrtc);\r\nrcar_du_crtc_start(rcrtc);\r\nif (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE)) {\r\nrcar_du_vsp_enable(rcrtc);\r\n} else {\r\nfor (i = 0; i < rcrtc->group->num_planes; ++i) {\r\nstruct rcar_du_plane *plane = &rcrtc->group->planes[i];\r\nif (plane->plane.state->crtc != &rcrtc->crtc)\r\ncontinue;\r\nrcar_du_plane_setup(plane);\r\n}\r\n}\r\nrcar_du_crtc_update_planes(rcrtc);\r\n}\r\nstatic void rcar_du_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcar_du_crtc_get(rcrtc);\r\nrcar_du_crtc_start(rcrtc);\r\n}\r\nstatic void rcar_du_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcar_du_crtc_stop(rcrtc);\r\nrcar_du_crtc_put(rcrtc);\r\nrcrtc->outputs = 0;\r\n}\r\nstatic void rcar_du_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct drm_pending_vblank_event *event = crtc->state->event;\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nstruct drm_device *dev = rcrtc->crtc.dev;\r\nunsigned long flags;\r\nif (event) {\r\nWARN_ON(drm_crtc_vblank_get(crtc) != 0);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nrcrtc->event = event;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nif (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\r\nrcar_du_vsp_atomic_begin(rcrtc);\r\n}\r\nstatic void rcar_du_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcar_du_crtc_update_planes(rcrtc);\r\nif (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))\r\nrcar_du_vsp_atomic_flush(rcrtc);\r\n}\r\nstatic irqreturn_t rcar_du_crtc_irq(int irq, void *arg)\r\n{\r\nstruct rcar_du_crtc *rcrtc = arg;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 status;\r\nstatus = rcar_du_crtc_read(rcrtc, DSSR);\r\nrcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);\r\nif (status & DSSR_FRM) {\r\ndrm_crtc_handle_vblank(&rcrtc->crtc);\r\nrcar_du_crtc_finish_page_flip(rcrtc);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nint rcar_du_crtc_create(struct rcar_du_group *rgrp, unsigned int index)\r\n{\r\nstatic const unsigned int mmio_offsets[] = {\r\nDU0_REG_OFFSET, DU1_REG_OFFSET, DU2_REG_OFFSET, DU3_REG_OFFSET\r\n};\r\nstruct rcar_du_device *rcdu = rgrp->dev;\r\nstruct platform_device *pdev = to_platform_device(rcdu->dev);\r\nstruct rcar_du_crtc *rcrtc = &rcdu->crtcs[index];\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nstruct drm_plane *primary;\r\nunsigned int irqflags;\r\nstruct clk *clk;\r\nchar clk_name[9];\r\nchar *name;\r\nint irq;\r\nint ret;\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ_CLOCK)) {\r\nsprintf(clk_name, "du.%u", index);\r\nname = clk_name;\r\n} else {\r\nname = NULL;\r\n}\r\nrcrtc->clock = devm_clk_get(rcdu->dev, name);\r\nif (IS_ERR(rcrtc->clock)) {\r\ndev_err(rcdu->dev, "no clock for CRTC %u\n", index);\r\nreturn PTR_ERR(rcrtc->clock);\r\n}\r\nsprintf(clk_name, "dclkin.%u", index);\r\nclk = devm_clk_get(rcdu->dev, clk_name);\r\nif (!IS_ERR(clk)) {\r\nrcrtc->extclock = clk;\r\n} else if (PTR_ERR(rcrtc->clock) == -EPROBE_DEFER) {\r\ndev_info(rcdu->dev, "can't get external clock %u\n", index);\r\nreturn -EPROBE_DEFER;\r\n}\r\ninit_waitqueue_head(&rcrtc->flip_wait);\r\nrcrtc->group = rgrp;\r\nrcrtc->mmio_offset = mmio_offsets[index];\r\nrcrtc->index = index;\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE))\r\nprimary = &rcrtc->vsp->planes[0].plane;\r\nelse\r\nprimary = &rgrp->planes[index % 2].plane;\r\nret = drm_crtc_init_with_planes(rcdu->ddev, crtc, primary,\r\nNULL, &crtc_funcs, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_crtc_helper_add(crtc, &crtc_helper_funcs);\r\ndrm_crtc_vblank_off(crtc);\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ_CLOCK)) {\r\nirq = platform_get_irq(pdev, index);\r\nirqflags = 0;\r\n} else {\r\nirq = platform_get_irq(pdev, 0);\r\nirqflags = IRQF_SHARED;\r\n}\r\nif (irq < 0) {\r\ndev_err(rcdu->dev, "no IRQ for CRTC %u\n", index);\r\nreturn irq;\r\n}\r\nret = devm_request_irq(rcdu->dev, irq, rcar_du_crtc_irq, irqflags,\r\ndev_name(rcdu->dev), rcrtc);\r\nif (ret < 0) {\r\ndev_err(rcdu->dev,\r\n"failed to register IRQ for CRTC %u\n", index);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid rcar_du_crtc_enable_vblank(struct rcar_du_crtc *rcrtc, bool enable)\r\n{\r\nif (enable) {\r\nrcar_du_crtc_write(rcrtc, DSRCR, DSRCR_VBCL);\r\nrcar_du_crtc_set(rcrtc, DIER, DIER_VBE);\r\n} else {\r\nrcar_du_crtc_clr(rcrtc, DIER, DIER_VBE);\r\n}\r\n}
