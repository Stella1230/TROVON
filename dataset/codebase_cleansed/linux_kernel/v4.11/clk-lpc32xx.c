static inline bool pll_is_valid(u64 val0, u64 val1, u64 min, u64 max)\r\n{\r\nreturn (val0 >= (val1 * min) && val0 <= (val1 * max));\r\n}\r\nstatic inline u32 lpc32xx_usb_clk_read(struct lpc32xx_usb_clk *clk)\r\n{\r\nreturn readl(usb_clk_vbase + LPC32XX_USB_CLK_STS);\r\n}\r\nstatic inline void lpc32xx_usb_clk_write(struct lpc32xx_usb_clk *clk, u32 val)\r\n{\r\nwritel(val, usb_clk_vbase + LPC32XX_USB_CLK_CTRL);\r\n}\r\nstatic int clk_mask_enable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nu32 val;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nif (clk->busy_mask && (val & clk->busy_mask) == clk->busy)\r\nreturn -EBUSY;\r\nreturn regmap_update_bits(clk_regmap, clk->reg,\r\nclk->enable_mask, clk->enable);\r\n}\r\nstatic void clk_mask_disable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nregmap_update_bits(clk_regmap, clk->reg,\r\nclk->disable_mask, clk->disable);\r\n}\r\nstatic int clk_mask_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nu32 val;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nreturn ((val & clk->enable_mask) == clk->enable);\r\n}\r\nstatic int clk_pll_enable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nu32 val, count;\r\nregmap_update_bits(clk_regmap, clk->reg, clk->enable, clk->enable);\r\nfor (count = 0; count < 1000; count++) {\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nif (val & PLL_CTRL_LOCK)\r\nbreak;\r\n}\r\nif (val & PLL_CTRL_LOCK)\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void clk_pll_disable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nregmap_update_bits(clk_regmap, clk->reg, clk->enable, 0x0);\r\n}\r\nstatic int clk_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nu32 val;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nval &= clk->enable | PLL_CTRL_LOCK;\r\nif (val == (clk->enable | PLL_CTRL_LOCK))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_pll_397x_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn parent_rate * 397;\r\n}\r\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nbool is_direct, is_bypass, is_feedback;\r\nunsigned long rate, cco_rate, ref_rate;\r\nu32 val;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nis_direct = val & PLL_CTRL_DIRECT;\r\nis_bypass = val & PLL_CTRL_BYPASS;\r\nis_feedback = val & PLL_CTRL_FEEDBACK;\r\nclk->m_div = ((val & PLL_CTRL_FEEDDIV) >> 1) + 1;\r\nclk->n_div = ((val & PLL_CTRL_PREDIV) >> 9) + 1;\r\nclk->p_div = ((val & PLL_CTRL_POSTDIV) >> 11) + 1;\r\nif (is_direct && is_bypass) {\r\nclk->p_div = 0;\r\nclk->mode = PLL_DIRECT_BYPASS;\r\nreturn parent_rate;\r\n}\r\nif (is_bypass) {\r\nclk->mode = PLL_BYPASS;\r\nreturn parent_rate / (1 << clk->p_div);\r\n}\r\nif (is_direct) {\r\nclk->p_div = 0;\r\nclk->mode = PLL_DIRECT;\r\n}\r\nref_rate = parent_rate / clk->n_div;\r\nrate = cco_rate = ref_rate * clk->m_div;\r\nif (!is_direct) {\r\nif (is_feedback) {\r\ncco_rate *= (1 << clk->p_div);\r\nclk->mode = PLL_INTEGER;\r\n} else {\r\nrate /= (1 << clk->p_div);\r\nclk->mode = PLL_NON_INTEGER;\r\n}\r\n}\r\npr_debug("%s: %lu: 0x%x: %d/%d/%d, %lu/%lu/%d => %lu\n",\r\nclk_hw_get_name(hw),\r\nparent_rate, val, is_direct, is_bypass, is_feedback,\r\nclk->n_div, clk->m_div, (1 << clk->p_div), rate);\r\nif (clk_pll_is_enabled(hw) &&\r\n!(pll_is_valid(parent_rate, 1, 1000000, 20000000)\r\n&& pll_is_valid(cco_rate, 1, 156000000, 320000000)\r\n&& pll_is_valid(ref_rate, 1, 1000000, 27000000)))\r\npr_err("%s: PLL clocks are not in valid ranges: %lu/%lu/%lu",\r\nclk_hw_get_name(hw),\r\nparent_rate, cco_rate, ref_rate);\r\nreturn rate;\r\n}\r\nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nu32 val;\r\nunsigned long new_rate;\r\nswitch (clk->mode) {\r\ncase PLL_DIRECT:\r\nval = PLL_CTRL_DIRECT;\r\nval |= (clk->m_div - 1) << 1;\r\nval |= (clk->n_div - 1) << 9;\r\nnew_rate = (parent_rate * clk->m_div) / clk->n_div;\r\nbreak;\r\ncase PLL_BYPASS:\r\nval = PLL_CTRL_BYPASS;\r\nval |= (clk->p_div - 1) << 11;\r\nnew_rate = parent_rate / (1 << (clk->p_div));\r\nbreak;\r\ncase PLL_DIRECT_BYPASS:\r\nval = PLL_CTRL_DIRECT | PLL_CTRL_BYPASS;\r\nnew_rate = parent_rate;\r\nbreak;\r\ncase PLL_INTEGER:\r\nval = PLL_CTRL_FEEDBACK;\r\nval |= (clk->m_div - 1) << 1;\r\nval |= (clk->n_div - 1) << 9;\r\nval |= (clk->p_div - 1) << 11;\r\nnew_rate = (parent_rate * clk->m_div) / clk->n_div;\r\nbreak;\r\ncase PLL_NON_INTEGER:\r\nval = 0x0;\r\nval |= (clk->m_div - 1) << 1;\r\nval |= (clk->n_div - 1) << 9;\r\nval |= (clk->p_div - 1) << 11;\r\nnew_rate = (parent_rate * clk->m_div) /\r\n(clk->n_div * (1 << clk->p_div));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (new_rate != rate)\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(clk_regmap, clk->reg, 0x1FFFF, val);\r\n}\r\nstatic long clk_hclk_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nu64 m_i, o = rate, i = *parent_rate, d = (u64)rate << 6;\r\nu64 m = 0, n = 0, p = 0;\r\nint p_i, n_i;\r\npr_debug("%s: %lu/%lu\n", clk_hw_get_name(hw), *parent_rate, rate);\r\nif (rate > 266500000)\r\nreturn -EINVAL;\r\nfor (p_i = 4; p_i >= 0; p_i--) {\r\nfor (n_i = 4; n_i > 0; n_i--) {\r\nm_i = div64_u64(o * n_i * (1 << p_i), i);\r\nif (!(m_i && m_i <= 256\r\n&& pll_is_valid(i, n_i, 1000000, 27000000)\r\n&& pll_is_valid(i * m_i * (1 << p_i), n_i,\r\n156000000, 320000000)))\r\ncontinue;\r\nif (o * n_i * (1 << p_i) - i * m_i <= d) {\r\nm = m_i;\r\nn = n_i;\r\np = p_i;\r\nd = o * n_i * (1 << p_i) - i * m_i;\r\n}\r\n}\r\n}\r\nif (d == (u64)rate << 6) {\r\npr_err("%s: %lu: no valid PLL parameters are found\n",\r\nclk_hw_get_name(hw), rate);\r\nreturn -EINVAL;\r\n}\r\nclk->m_div = m;\r\nclk->n_div = n;\r\nclk->p_div = p;\r\nif (!p)\r\nclk->mode = PLL_DIRECT;\r\nelse\r\nclk->mode = PLL_NON_INTEGER;\r\no = div64_u64(i * m, n * (1 << p));\r\nif (!d)\r\npr_debug("%s: %lu: found exact match: %llu/%llu/%llu\n",\r\nclk_hw_get_name(hw), rate, m, n, p);\r\nelse\r\npr_debug("%s: %lu: found closest: %llu/%llu/%llu - %llu\n",\r\nclk_hw_get_name(hw), rate, m, n, p, o);\r\nreturn o;\r\n}\r\nstatic long clk_usb_pll_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct lpc32xx_pll_clk *clk = to_lpc32xx_pll_clk(hw);\r\nstruct clk_hw *usb_div_hw, *osc_hw;\r\nu64 d_i, n_i, m, o;\r\npr_debug("%s: %lu/%lu\n", clk_hw_get_name(hw), *parent_rate, rate);\r\nif (rate != 48000000)\r\nreturn -EINVAL;\r\nusb_div_hw = clk_hw_get_parent_by_index(hw, 0);\r\nif (!usb_div_hw)\r\nreturn -EINVAL;\r\nosc_hw = clk_hw_get_parent_by_index(usb_div_hw, 0);\r\nif (!osc_hw)\r\nreturn -EINVAL;\r\no = clk_hw_get_rate(osc_hw);\r\nfor (d_i = 16; d_i >= 1; d_i--) {\r\nfor (n_i = 1; n_i <= 4; n_i++) {\r\nm = div64_u64(192000000 * d_i * n_i, o);\r\nif (!(m && m <= 256\r\n&& m * o == 192000000 * d_i * n_i\r\n&& pll_is_valid(o, d_i, 1000000, 20000000)\r\n&& pll_is_valid(o, d_i * n_i, 1000000, 27000000)))\r\ncontinue;\r\nclk->n_div = n_i;\r\nclk->m_div = m;\r\nclk->p_div = 2;\r\nclk->mode = PLL_NON_INTEGER;\r\n*parent_rate = div64_u64(o, d_i);\r\nreturn rate;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int clk_ddram_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nu32 val;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nval &= clk->enable_mask | clk->busy_mask;\r\nreturn (val == (BIT(7) | BIT(0)) ||\r\nval == (BIT(8) | BIT(1)));\r\n}\r\nstatic int clk_ddram_enable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nu32 val, hclk_div;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nhclk_div = val & clk->busy_mask;\r\nif (hclk_div == 0x0 || hclk_div == (BIT(1) | BIT(0)))\r\nreturn -EINVAL;\r\nreturn regmap_update_bits(clk_regmap, clk->reg,\r\nclk->enable_mask, hclk_div << 7);\r\n}\r\nstatic unsigned long clk_ddram_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nu32 val;\r\nif (!clk_ddram_is_enabled(hw))\r\nreturn 0;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nval &= clk->enable_mask;\r\nreturn parent_rate / (val >> 7);\r\n}\r\nstatic unsigned long lpc32xx_clk_uart_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc32xx_clk *clk = to_lpc32xx_clk(hw);\r\nu32 val, x, y;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nx = (val & 0xFF00) >> 8;\r\ny = val & 0xFF;\r\nif (x && y)\r\nreturn (parent_rate * x) / y;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int clk_usb_enable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_usb_clk *clk = to_lpc32xx_usb_clk(hw);\r\nu32 val, ctrl_val, count;\r\npr_debug("%s: 0x%x\n", clk_hw_get_name(hw), clk->enable);\r\nif (clk->ctrl_mask) {\r\nregmap_read(clk_regmap, LPC32XX_CLKPWR_USB_CTRL, &ctrl_val);\r\nregmap_update_bits(clk_regmap, LPC32XX_CLKPWR_USB_CTRL,\r\nclk->ctrl_mask, clk->ctrl_enable);\r\n}\r\nval = lpc32xx_usb_clk_read(clk);\r\nif (clk->busy && (val & clk->busy) == clk->busy) {\r\nif (clk->ctrl_mask)\r\nregmap_write(clk_regmap, LPC32XX_CLKPWR_USB_CTRL,\r\nctrl_val);\r\nreturn -EBUSY;\r\n}\r\nval |= clk->enable;\r\nlpc32xx_usb_clk_write(clk, val);\r\nfor (count = 0; count < 1000; count++) {\r\nval = lpc32xx_usb_clk_read(clk);\r\nif ((val & clk->enable) == clk->enable)\r\nbreak;\r\n}\r\nif ((val & clk->enable) == clk->enable)\r\nreturn 0;\r\nif (clk->ctrl_mask)\r\nregmap_write(clk_regmap, LPC32XX_CLKPWR_USB_CTRL, ctrl_val);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void clk_usb_disable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_usb_clk *clk = to_lpc32xx_usb_clk(hw);\r\nu32 val = lpc32xx_usb_clk_read(clk);\r\nval &= ~clk->enable;\r\nlpc32xx_usb_clk_write(clk, val);\r\nif (clk->ctrl_mask)\r\nregmap_update_bits(clk_regmap, LPC32XX_CLKPWR_USB_CTRL,\r\nclk->ctrl_mask, clk->ctrl_disable);\r\n}\r\nstatic int clk_usb_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_usb_clk *clk = to_lpc32xx_usb_clk(hw);\r\nu32 ctrl_val, val;\r\nif (clk->ctrl_mask) {\r\nregmap_read(clk_regmap, LPC32XX_CLKPWR_USB_CTRL, &ctrl_val);\r\nif ((ctrl_val & clk->ctrl_mask) != clk->ctrl_enable)\r\nreturn 0;\r\n}\r\nval = lpc32xx_usb_clk_read(clk);\r\nreturn ((val & clk->enable) == clk->enable);\r\n}\r\nstatic unsigned long clk_usb_i2c_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn clk_get_rate(clk[LPC32XX_CLK_PERIPH]);\r\n}\r\nstatic int clk_gate_enable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk_gate *clk = to_lpc32xx_gate(hw);\r\nu32 mask = BIT(clk->bit_idx);\r\nu32 val = (clk->flags & CLK_GATE_SET_TO_DISABLE ? 0x0 : mask);\r\nreturn regmap_update_bits(clk_regmap, clk->reg, mask, val);\r\n}\r\nstatic void clk_gate_disable(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk_gate *clk = to_lpc32xx_gate(hw);\r\nu32 mask = BIT(clk->bit_idx);\r\nu32 val = (clk->flags & CLK_GATE_SET_TO_DISABLE ? mask : 0x0);\r\nregmap_update_bits(clk_regmap, clk->reg, mask, val);\r\n}\r\nstatic int clk_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk_gate *clk = to_lpc32xx_gate(hw);\r\nu32 val;\r\nbool is_set;\r\nregmap_read(clk_regmap, clk->reg, &val);\r\nis_set = val & BIT(clk->bit_idx);\r\nreturn (clk->flags & CLK_GATE_SET_TO_DISABLE ? !is_set : is_set);\r\n}\r\nstatic unsigned int _get_table_div(const struct clk_div_table *table,\r\nunsigned int val)\r\n{\r\nconst struct clk_div_table *clkt;\r\nfor (clkt = table; clkt->div; clkt++)\r\nif (clkt->val == val)\r\nreturn clkt->div;\r\nreturn 0;\r\n}\r\nstatic unsigned int _get_div(const struct clk_div_table *table,\r\nunsigned int val, unsigned long flags, u8 width)\r\n{\r\nif (flags & CLK_DIVIDER_ONE_BASED)\r\nreturn val;\r\nif (table)\r\nreturn _get_table_div(table, val);\r\nreturn val + 1;\r\n}\r\nstatic unsigned long clk_divider_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc32xx_clk_div *divider = to_lpc32xx_div(hw);\r\nunsigned int val;\r\nregmap_read(clk_regmap, divider->reg, &val);\r\nval >>= divider->shift;\r\nval &= div_mask(divider->width);\r\nreturn divider_recalc_rate(hw, parent_rate, val, divider->table,\r\ndivider->flags);\r\n}\r\nstatic long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct lpc32xx_clk_div *divider = to_lpc32xx_div(hw);\r\nunsigned int bestdiv;\r\nif (divider->flags & CLK_DIVIDER_READ_ONLY) {\r\nregmap_read(clk_regmap, divider->reg, &bestdiv);\r\nbestdiv >>= divider->shift;\r\nbestdiv &= div_mask(divider->width);\r\nbestdiv = _get_div(divider->table, bestdiv, divider->flags,\r\ndivider->width);\r\nreturn DIV_ROUND_UP(*prate, bestdiv);\r\n}\r\nreturn divider_round_rate(hw, rate, prate, divider->table,\r\ndivider->width, divider->flags);\r\n}\r\nstatic int clk_divider_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct lpc32xx_clk_div *divider = to_lpc32xx_div(hw);\r\nunsigned int value;\r\nvalue = divider_get_val(rate, parent_rate, divider->table,\r\ndivider->width, divider->flags);\r\nreturn regmap_update_bits(clk_regmap, divider->reg,\r\ndiv_mask(divider->width) << divider->shift,\r\nvalue << divider->shift);\r\n}\r\nstatic u8 clk_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct lpc32xx_clk_mux *mux = to_lpc32xx_mux(hw);\r\nu32 num_parents = clk_hw_get_num_parents(hw);\r\nu32 val;\r\nregmap_read(clk_regmap, mux->reg, &val);\r\nval >>= mux->shift;\r\nval &= mux->mask;\r\nif (mux->table) {\r\nu32 i;\r\nfor (i = 0; i < num_parents; i++)\r\nif (mux->table[i] == val)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nif (val >= num_parents)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nstatic int clk_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct lpc32xx_clk_mux *mux = to_lpc32xx_mux(hw);\r\nif (mux->table)\r\nindex = mux->table[index];\r\nreturn regmap_update_bits(clk_regmap, mux->reg,\r\nmux->mask << mux->shift, index << mux->shift);\r\n}\r\nstatic struct clk * __init lpc32xx_clk_register(u32 id)\r\n{\r\nconst struct clk_proto_t *lpc32xx_clk = &clk_proto[id];\r\nstruct clk_hw_proto *clk_hw = &clk_hw_proto[id];\r\nconst char *parents[LPC32XX_CLK_PARENTS_MAX];\r\nstruct clk *clk;\r\nunsigned int i;\r\nfor (i = 0; i < lpc32xx_clk->num_parents; i++)\r\nparents[i] = clk_proto[lpc32xx_clk->parents[i]].name;\r\npr_debug("%s: derived from '%s', clock type %d\n", lpc32xx_clk->name,\r\nparents[0], clk_hw->type);\r\nswitch (clk_hw->type) {\r\ncase CLK_LPC32XX:\r\ncase CLK_LPC32XX_PLL:\r\ncase CLK_LPC32XX_USB:\r\ncase CLK_MUX:\r\ncase CLK_DIV:\r\ncase CLK_GATE:\r\n{\r\nstruct clk_init_data clk_init = {\r\n.name = lpc32xx_clk->name,\r\n.parent_names = parents,\r\n.num_parents = lpc32xx_clk->num_parents,\r\n.flags = lpc32xx_clk->flags,\r\n.ops = clk_hw->hw0.ops,\r\n};\r\nstruct clk_hw *hw;\r\nif (clk_hw->type == CLK_LPC32XX)\r\nhw = &clk_hw->hw0.clk.hw;\r\nelse if (clk_hw->type == CLK_LPC32XX_PLL)\r\nhw = &clk_hw->hw0.pll.hw;\r\nelse if (clk_hw->type == CLK_LPC32XX_USB)\r\nhw = &clk_hw->hw0.usb_clk.hw;\r\nelse if (clk_hw->type == CLK_MUX)\r\nhw = &clk_hw->hw0.mux.hw;\r\nelse if (clk_hw->type == CLK_DIV)\r\nhw = &clk_hw->hw0.div.hw;\r\nelse if (clk_hw->type == CLK_GATE)\r\nhw = &clk_hw->hw0.gate.hw;\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\nhw->init = &clk_init;\r\nclk = clk_register(NULL, hw);\r\nbreak;\r\n}\r\ncase CLK_COMPOSITE:\r\n{\r\nstruct clk_hw *mux_hw = NULL, *div_hw = NULL, *gate_hw = NULL;\r\nconst struct clk_ops *mops = NULL, *dops = NULL, *gops = NULL;\r\nstruct clk_hw_proto0 *mux0, *div0, *gate0;\r\nmux0 = clk_hw->hw1.mux;\r\ndiv0 = clk_hw->hw1.div;\r\ngate0 = clk_hw->hw1.gate;\r\nif (mux0) {\r\nmops = mux0->ops;\r\nmux_hw = &mux0->clk.hw;\r\n}\r\nif (div0) {\r\ndops = div0->ops;\r\ndiv_hw = &div0->clk.hw;\r\n}\r\nif (gate0) {\r\ngops = gate0->ops;\r\ngate_hw = &gate0->clk.hw;\r\n}\r\nclk = clk_register_composite(NULL, lpc32xx_clk->name,\r\nparents, lpc32xx_clk->num_parents,\r\nmux_hw, mops, div_hw, dops,\r\ngate_hw, gops, lpc32xx_clk->flags);\r\nbreak;\r\n}\r\ncase CLK_FIXED:\r\n{\r\nstruct clk_fixed_rate *fixed = &clk_hw->f;\r\nclk = clk_register_fixed_rate(NULL, lpc32xx_clk->name,\r\nparents[0], fixed->flags, fixed->fixed_rate);\r\nbreak;\r\n}\r\ndefault:\r\nclk = ERR_PTR(-EINVAL);\r\n}\r\nreturn clk;\r\n}\r\nstatic void __init lpc32xx_clk_div_quirk(u32 reg, u32 div_mask, u32 gate)\r\n{\r\nu32 val;\r\nregmap_read(clk_regmap, reg, &val);\r\nif (!(val & div_mask)) {\r\nval &= ~gate;\r\nval |= BIT(__ffs(div_mask));\r\n}\r\nregmap_update_bits(clk_regmap, reg, gate | div_mask, val);\r\n}\r\nstatic void __init lpc32xx_clk_init(struct device_node *np)\r\n{\r\nunsigned int i;\r\nstruct clk *clk_osc, *clk_32k;\r\nvoid __iomem *base = NULL;\r\nclk_32k = of_clk_get_by_name(np, clk_proto[LPC32XX_CLK_XTAL_32K].name);\r\nif (IS_ERR(clk_32k)) {\r\npr_err("failed to find external 32KHz clock: %ld\n",\r\nPTR_ERR(clk_32k));\r\nreturn;\r\n}\r\nif (clk_get_rate(clk_32k) != 32768) {\r\npr_err("invalid clock rate of external 32KHz oscillator");\r\nreturn;\r\n}\r\nclk_osc = of_clk_get_by_name(np, clk_proto[LPC32XX_CLK_XTAL].name);\r\nif (IS_ERR(clk_osc)) {\r\npr_err("failed to find external main oscillator clock: %ld\n",\r\nPTR_ERR(clk_osc));\r\nreturn;\r\n}\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("failed to map system control block registers\n");\r\nreturn;\r\n}\r\nclk_regmap = regmap_init_mmio(NULL, base, &lpc32xx_scb_regmap_config);\r\nif (IS_ERR(clk_regmap)) {\r\npr_err("failed to regmap system control block: %ld\n",\r\nPTR_ERR(clk_regmap));\r\niounmap(base);\r\nreturn;\r\n}\r\nlpc32xx_clk_div_quirk(LPC32XX_CLKPWR_PWMCLK_CTRL, 0xf0, BIT(0));\r\nlpc32xx_clk_div_quirk(LPC32XX_CLKPWR_PWMCLK_CTRL, 0xf00, BIT(2));\r\nlpc32xx_clk_div_quirk(LPC32XX_CLKPWR_MS_CTRL, 0xf, BIT(5) | BIT(9));\r\nfor (i = 1; i < LPC32XX_CLK_MAX; i++) {\r\nclk[i] = lpc32xx_clk_register(i);\r\nif (IS_ERR(clk[i])) {\r\npr_err("failed to register %s clock: %ld\n",\r\nclk_proto[i].name, PTR_ERR(clk[i]));\r\nclk[i] = NULL;\r\n}\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\r\nclk_set_rate(clk[LPC32XX_CLK_USB_PLL], 48000000);\r\nclk_prepare_enable(clk[LPC32XX_CLK_ARM]);\r\nclk_prepare_enable(clk[LPC32XX_CLK_HCLK]);\r\nclk_prepare_enable(clk[LPC32XX_CLK_ARM_VFP]);\r\nclk_mask_disable(&clk_hw_proto[LPC32XX_CLK_SLC].hw0.clk.hw);\r\nclk_mask_disable(&clk_hw_proto[LPC32XX_CLK_MLC].hw0.clk.hw);\r\n}\r\nstatic void __init lpc32xx_usb_clk_init(struct device_node *np)\r\n{\r\nunsigned int i;\r\nusb_clk_vbase = of_iomap(np, 0);\r\nif (!usb_clk_vbase) {\r\npr_err("failed to map address range\n");\r\nreturn;\r\n}\r\nfor (i = 1; i < LPC32XX_USB_CLK_MAX; i++) {\r\nusb_clk[i] = lpc32xx_clk_register(i + LPC32XX_CLK_USB_OFFSET);\r\nif (IS_ERR(usb_clk[i])) {\r\npr_err("failed to register %s clock: %ld\n",\r\nclk_proto[i].name, PTR_ERR(usb_clk[i]));\r\nusb_clk[i] = NULL;\r\n}\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &usb_clk_data);\r\n}
