static void tmc_etb_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_wait_for_tmcready(drvdata);\r\nwritel_relaxed(TMC_MODE_CIRCULAR_BUFFER, drvdata->base + TMC_MODE);\r\nwritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI |\r\nTMC_FFCR_FON_FLIN | TMC_FFCR_FON_TRIG_EVT |\r\nTMC_FFCR_TRIGON_TRIGIN,\r\ndrvdata->base + TMC_FFCR);\r\nwritel_relaxed(drvdata->trigger_cntr, drvdata->base + TMC_TRG);\r\ntmc_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etb_dump_hw(struct tmc_drvdata *drvdata)\r\n{\r\nchar *bufp;\r\nu32 read_data;\r\nint i;\r\nbufp = drvdata->buf;\r\ndrvdata->len = 0;\r\nwhile (1) {\r\nfor (i = 0; i < drvdata->memwidth; i++) {\r\nread_data = readl_relaxed(drvdata->base + TMC_RRD);\r\nif (read_data == 0xFFFFFFFF)\r\nreturn;\r\nmemcpy(bufp, &read_data, 4);\r\nbufp += 4;\r\ndrvdata->len += 4;\r\n}\r\n}\r\n}\r\nstatic void tmc_etb_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\nif (drvdata->mode == CS_MODE_SYSFS)\r\ntmc_etb_dump_hw(drvdata);\r\ntmc_disable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etf_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_wait_for_tmcready(drvdata);\r\nwritel_relaxed(TMC_MODE_HARDWARE_FIFO, drvdata->base + TMC_MODE);\r\nwritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI,\r\ndrvdata->base + TMC_FFCR);\r\nwritel_relaxed(0x0, drvdata->base + TMC_BUFWM);\r\ntmc_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etf_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\ntmc_disable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic int tmc_enable_etf_sink_sysfs(struct coresight_device *csdev)\r\n{\r\nint ret = 0;\r\nbool used = false;\r\nchar *buf = NULL;\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (!drvdata->buf) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nbuf = kzalloc(drvdata->size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\n}\r\nif (drvdata->reading) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (drvdata->mode == CS_MODE_SYSFS)\r\ngoto out;\r\nif (drvdata->buf) {\r\nmemset(drvdata->buf, 0, drvdata->size);\r\n} else {\r\nused = true;\r\ndrvdata->buf = buf;\r\n}\r\ndrvdata->mode = CS_MODE_SYSFS;\r\ntmc_etb_enable_hw(drvdata);\r\nout:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nif (!used)\r\nkfree(buf);\r\nif (!ret)\r\ndev_info(drvdata->dev, "TMC-ETB/ETF enabled\n");\r\nreturn ret;\r\n}\r\nstatic int tmc_enable_etf_sink_perf(struct coresight_device *csdev)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->mode != CS_MODE_DISABLED) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndrvdata->mode = CS_MODE_PERF;\r\ntmc_etb_enable_hw(drvdata);\r\nout:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int tmc_enable_etf_sink(struct coresight_device *csdev, u32 mode)\r\n{\r\nswitch (mode) {\r\ncase CS_MODE_SYSFS:\r\nreturn tmc_enable_etf_sink_sysfs(csdev);\r\ncase CS_MODE_PERF:\r\nreturn tmc_enable_etf_sink_perf(csdev);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void tmc_disable_etf_sink(struct coresight_device *csdev)\r\n{\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn;\r\n}\r\nif (drvdata->mode != CS_MODE_DISABLED) {\r\ntmc_etb_disable_hw(drvdata);\r\ndrvdata->mode = CS_MODE_DISABLED;\r\n}\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC-ETB/ETF disabled\n");\r\n}\r\nstatic int tmc_enable_etf_link(struct coresight_device *csdev,\r\nint inport, int outport)\r\n{\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn -EBUSY;\r\n}\r\ntmc_etf_enable_hw(drvdata);\r\ndrvdata->mode = CS_MODE_SYSFS;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC-ETF enabled\n");\r\nreturn 0;\r\n}\r\nstatic void tmc_disable_etf_link(struct coresight_device *csdev,\r\nint inport, int outport)\r\n{\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn;\r\n}\r\ntmc_etf_disable_hw(drvdata);\r\ndrvdata->mode = CS_MODE_DISABLED;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC disabled\n");\r\n}\r\nstatic void *tmc_alloc_etf_buffer(struct coresight_device *csdev, int cpu,\r\nvoid **pages, int nr_pages, bool overwrite)\r\n{\r\nint node;\r\nstruct cs_buffers *buf;\r\nif (cpu == -1)\r\ncpu = smp_processor_id();\r\nnode = cpu_to_node(cpu);\r\nbuf = kzalloc_node(sizeof(struct cs_buffers), GFP_KERNEL, node);\r\nif (!buf)\r\nreturn NULL;\r\nbuf->snapshot = overwrite;\r\nbuf->nr_pages = nr_pages;\r\nbuf->data_pages = pages;\r\nreturn buf;\r\n}\r\nstatic void tmc_free_etf_buffer(void *config)\r\n{\r\nstruct cs_buffers *buf = config;\r\nkfree(buf);\r\n}\r\nstatic int tmc_set_etf_buffer(struct coresight_device *csdev,\r\nstruct perf_output_handle *handle,\r\nvoid *sink_config)\r\n{\r\nint ret = 0;\r\nunsigned long head;\r\nstruct cs_buffers *buf = sink_config;\r\nhead = handle->head & ((buf->nr_pages << PAGE_SHIFT) - 1);\r\nbuf->cur = head / PAGE_SIZE;\r\nbuf->offset = head % PAGE_SIZE;\r\nlocal_set(&buf->data_size, 0);\r\nreturn ret;\r\n}\r\nstatic unsigned long tmc_reset_etf_buffer(struct coresight_device *csdev,\r\nstruct perf_output_handle *handle,\r\nvoid *sink_config, bool *lost)\r\n{\r\nlong size = 0;\r\nstruct cs_buffers *buf = sink_config;\r\nif (buf) {\r\nif (buf->snapshot)\r\nhandle->head = local_xchg(&buf->data_size,\r\nbuf->nr_pages << PAGE_SHIFT);\r\n*lost = !!local_xchg(&buf->lost, 0);\r\nsize = local_xchg(&buf->data_size, 0);\r\n}\r\nreturn size;\r\n}\r\nstatic void tmc_update_etf_buffer(struct coresight_device *csdev,\r\nstruct perf_output_handle *handle,\r\nvoid *sink_config)\r\n{\r\nint i, cur;\r\nu32 *buf_ptr;\r\nu32 read_ptr, write_ptr;\r\nu32 status, to_read;\r\nunsigned long offset;\r\nstruct cs_buffers *buf = sink_config;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (!buf)\r\nreturn;\r\nif (WARN_ON_ONCE(drvdata->mode != CS_MODE_PERF))\r\nreturn;\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\nread_ptr = readl_relaxed(drvdata->base + TMC_RRP);\r\nwrite_ptr = readl_relaxed(drvdata->base + TMC_RWP);\r\nstatus = readl_relaxed(drvdata->base + TMC_STS);\r\nif (status & TMC_STS_FULL) {\r\nlocal_inc(&buf->lost);\r\nto_read = drvdata->size;\r\n} else {\r\nto_read = CIRC_CNT(write_ptr, read_ptr, drvdata->size);\r\n}\r\nif (to_read > handle->size) {\r\nu32 mask = 0;\r\nswitch (drvdata->memwidth) {\r\ncase TMC_MEM_INTF_WIDTH_32BITS:\r\ncase TMC_MEM_INTF_WIDTH_64BITS:\r\ncase TMC_MEM_INTF_WIDTH_128BITS:\r\nmask = GENMASK(31, 5);\r\nbreak;\r\ncase TMC_MEM_INTF_WIDTH_256BITS:\r\nmask = GENMASK(31, 6);\r\nbreak;\r\n}\r\nto_read = handle->size & mask;\r\nread_ptr = (write_ptr + drvdata->size) - to_read;\r\nif (read_ptr > (drvdata->size - 1))\r\nread_ptr -= drvdata->size;\r\nwritel_relaxed(read_ptr, drvdata->base + TMC_RRP);\r\nlocal_inc(&buf->lost);\r\n}\r\ncur = buf->cur;\r\noffset = buf->offset;\r\nfor (i = 0; i < to_read; i += 4) {\r\nbuf_ptr = buf->data_pages[cur] + offset;\r\n*buf_ptr = readl_relaxed(drvdata->base + TMC_RRD);\r\noffset += 4;\r\nif (offset >= PAGE_SIZE) {\r\noffset = 0;\r\ncur++;\r\ncur &= buf->nr_pages - 1;\r\n}\r\n}\r\nif (buf->snapshot)\r\nlocal_set(&buf->data_size, (cur * PAGE_SIZE) + offset);\r\nelse\r\nlocal_add(to_read, &buf->data_size);\r\nCS_LOCK(drvdata->base);\r\n}\r\nint tmc_read_prepare_etb(struct tmc_drvdata *drvdata)\r\n{\r\nenum tmc_mode mode;\r\nint ret = 0;\r\nunsigned long flags;\r\nif (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETB &&\r\ndrvdata->config_type != TMC_CONFIG_TYPE_ETF))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmode = readl_relaxed(drvdata->base + TMC_MODE);\r\nif (mode != TMC_MODE_CIRCULAR_BUFFER) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->mode == CS_MODE_PERF) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->buf == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->mode == CS_MODE_SYSFS)\r\ntmc_etb_disable_hw(drvdata);\r\ndrvdata->reading = true;\r\nout:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn ret;\r\n}\r\nint tmc_read_unprepare_etb(struct tmc_drvdata *drvdata)\r\n{\r\nchar *buf = NULL;\r\nenum tmc_mode mode;\r\nunsigned long flags;\r\nif (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETB &&\r\ndrvdata->config_type != TMC_CONFIG_TYPE_ETF))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nmode = readl_relaxed(drvdata->base + TMC_MODE);\r\nif (mode != TMC_MODE_CIRCULAR_BUFFER) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (drvdata->mode == CS_MODE_SYSFS) {\r\nmemset(drvdata->buf, 0, drvdata->size);\r\ntmc_etb_enable_hw(drvdata);\r\n} else {\r\nbuf = drvdata->buf;\r\ndrvdata->buf = NULL;\r\n}\r\ndrvdata->reading = false;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nkfree(buf);\r\nreturn 0;\r\n}
