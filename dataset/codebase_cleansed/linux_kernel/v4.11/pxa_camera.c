static s32 pxa_mbus_bytes_per_line(u32 width, const struct pxa_mbus_pixelfmt *mf)\r\n{\r\nif (mf->layout != PXA_MBUS_LAYOUT_PACKED)\r\nreturn width * mf->bits_per_sample / 8;\r\nswitch (mf->packing) {\r\ncase PXA_MBUS_PACKING_NONE:\r\nreturn width * mf->bits_per_sample / 8;\r\ncase PXA_MBUS_PACKING_2X8_PADHI:\r\ncase PXA_MBUS_PACKING_EXTEND16:\r\nreturn width * 2;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic s32 pxa_mbus_image_size(const struct pxa_mbus_pixelfmt *mf,\r\nu32 bytes_per_line, u32 height)\r\n{\r\nswitch (mf->packing) {\r\ncase PXA_MBUS_PACKING_2X8_PADHI:\r\nreturn bytes_per_line * height * 2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic const struct pxa_mbus_pixelfmt *pxa_mbus_find_fmtdesc(\r\nu32 code,\r\nconst struct pxa_mbus_lookup *lookup,\r\nint n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nif (lookup[i].code == code)\r\nreturn &lookup[i].fmt;\r\nreturn NULL;\r\n}\r\nstatic const struct pxa_mbus_pixelfmt *pxa_mbus_get_fmtdesc(\r\nu32 code)\r\n{\r\nreturn pxa_mbus_find_fmtdesc(code, mbus_fmt, ARRAY_SIZE(mbus_fmt));\r\n}\r\nstatic unsigned int pxa_mbus_config_compatible(const struct v4l2_mbus_config *cfg,\r\nunsigned int flags)\r\n{\r\nunsigned long common_flags;\r\nbool hsync = true, vsync = true, pclk, data, mode;\r\nbool mipi_lanes, mipi_clock;\r\ncommon_flags = cfg->flags & flags;\r\nswitch (cfg->type) {\r\ncase V4L2_MBUS_PARALLEL:\r\nhsync = common_flags & (V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW);\r\nvsync = common_flags & (V4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW);\r\ncase V4L2_MBUS_BT656:\r\npclk = common_flags & (V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING);\r\ndata = common_flags & (V4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_LOW);\r\nmode = common_flags & (V4L2_MBUS_MASTER | V4L2_MBUS_SLAVE);\r\nreturn (!hsync || !vsync || !pclk || !data || !mode) ?\r\n0 : common_flags;\r\ncase V4L2_MBUS_CSI2:\r\nmipi_lanes = common_flags & V4L2_MBUS_CSI2_LANES;\r\nmipi_clock = common_flags & (V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK |\r\nV4L2_MBUS_CSI2_CONTINUOUS_CLOCK);\r\nreturn (!mipi_lanes || !mipi_clock) ? 0 : common_flags;\r\n}\r\nreturn 0;\r\n}\r\nstatic const struct soc_camera_format_xlate\r\n*pxa_mbus_xlate_by_fourcc(struct soc_camera_format_xlate *user_formats,\r\nunsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; user_formats[i].code; i++)\r\nif (user_formats[i].host_fmt->fourcc == fourcc)\r\nreturn user_formats + i;\r\nreturn NULL;\r\n}\r\nstatic struct soc_camera_format_xlate *pxa_mbus_build_fmts_xlate(\r\nstruct v4l2_device *v4l2_dev, struct v4l2_subdev *subdev,\r\nint (*get_formats)(struct v4l2_device *, unsigned int,\r\nstruct soc_camera_format_xlate *xlate))\r\n{\r\nunsigned int i, fmts = 0, raw_fmts = 0;\r\nint ret;\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct soc_camera_format_xlate *user_formats;\r\nwhile (!v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &code)) {\r\nraw_fmts++;\r\ncode.index++;\r\n}\r\nfor (i = 0; i < raw_fmts; i++) {\r\nret = get_formats(v4l2_dev, i, NULL);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nfmts += ret;\r\n}\r\nif (!fmts)\r\nreturn ERR_PTR(-ENXIO);\r\nuser_formats = kcalloc(fmts + 1, sizeof(*user_formats), GFP_KERNEL);\r\nif (!user_formats)\r\nreturn ERR_PTR(-ENOMEM);\r\nfmts = 0;\r\nfor (i = 0; i < raw_fmts; i++) {\r\nret = get_formats(v4l2_dev, i, user_formats + fmts);\r\nif (ret < 0)\r\ngoto egfmt;\r\nfmts += ret;\r\n}\r\nuser_formats[fmts].code = 0;\r\nreturn user_formats;\r\negfmt:\r\nkfree(user_formats);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct pxa_buffer *vb2_to_pxa_buffer(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nreturn container_of(vbuf, struct pxa_buffer, vbuf);\r\n}\r\nstatic struct device *pcdev_to_dev(struct pxa_camera_dev *pcdev)\r\n{\r\nreturn pcdev->v4l2_dev.dev;\r\n}\r\nstatic struct pxa_camera_dev *v4l2_dev_to_pcdev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct pxa_camera_dev, v4l2_dev);\r\n}\r\nstatic void pxa_camera_dma_irq_y(void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(pcdev, DMA_Y);\r\n}\r\nstatic void pxa_camera_dma_irq_u(void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(pcdev, DMA_U);\r\n}\r\nstatic void pxa_camera_dma_irq_v(void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(pcdev, DMA_V);\r\n}\r\nstatic int pxa_init_dma_channel(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf, int channel,\r\nstruct scatterlist *sg, int sglen)\r\n{\r\nstruct dma_chan *dma_chan = pcdev->dma_chans[channel];\r\nstruct dma_async_tx_descriptor *tx;\r\ntx = dmaengine_prep_slave_sg(dma_chan, sg, sglen, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_REUSE);\r\nif (!tx) {\r\ndev_err(pcdev_to_dev(pcdev),\r\n"dmaengine_prep_slave_sg failed\n");\r\ngoto fail;\r\n}\r\ntx->callback_param = pcdev;\r\nswitch (channel) {\r\ncase 0:\r\ntx->callback = pxa_camera_dma_irq_y;\r\nbreak;\r\ncase 1:\r\ntx->callback = pxa_camera_dma_irq_u;\r\nbreak;\r\ncase 2:\r\ntx->callback = pxa_camera_dma_irq_v;\r\nbreak;\r\n}\r\nbuf->descs[channel] = tx;\r\nreturn 0;\r\nfail:\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s (vb=%p) dma_tx=%p\n",\r\n__func__, buf, tx);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pxa_videobuf_set_actdma(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nbuf->active_dma = DMA_Y;\r\nif (buf->nb_planes == 3)\r\nbuf->active_dma |= DMA_U | DMA_V;\r\n}\r\nstatic void pxa_dma_start_channels(struct pxa_camera_dev *pcdev)\r\n{\r\nint i;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s (channel=%d)\n", __func__, i);\r\ndma_async_issue_pending(pcdev->dma_chans[i]);\r\n}\r\n}\r\nstatic void pxa_dma_stop_channels(struct pxa_camera_dev *pcdev)\r\n{\r\nint i;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s (channel=%d)\n", __func__, i);\r\ndmaengine_terminate_all(pcdev->dma_chans[i]);\r\n}\r\n}\r\nstatic void pxa_dma_add_tail_buf(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\nbuf->cookie[i] = dmaengine_submit(buf->descs[i]);\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s (channel=%d) : submit vb=%p cookie=%d\n",\r\n__func__, i, buf, buf->descs[i]->cookie);\r\n}\r\n}\r\nstatic void pxa_camera_start_capture(struct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long cicr0;\r\ndev_dbg(pcdev_to_dev(pcdev), "%s\n", __func__);\r\n__raw_writel(__raw_readl(pcdev->base + CISR), pcdev->base + CISR);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_ENB;\r\ncicr0 &= ~CICR0_EOFM;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nstatic void pxa_camera_stop_capture(struct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long cicr0;\r\npxa_dma_stop_channels(pcdev);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) & ~CICR0_ENB;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\npcdev->active = NULL;\r\ndev_dbg(pcdev_to_dev(pcdev), "%s\n", __func__);\r\n}\r\nstatic void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nlist_del_init(&buf->queue);\r\nvb->timestamp = ktime_get_ns();\r\nvbuf->sequence = pcdev->buf_sequence++;\r\nvbuf->field = V4L2_FIELD_NONE;\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\ndev_dbg(pcdev_to_dev(pcdev), "%s dequeued buffer (buf=0x%p)\n",\r\n__func__, buf);\r\nif (list_empty(&pcdev->capture)) {\r\npxa_camera_stop_capture(pcdev);\r\nreturn;\r\n}\r\npcdev->active = list_entry(pcdev->capture.next,\r\nstruct pxa_buffer, queue);\r\n}\r\nstatic void pxa_camera_check_link_miss(struct pxa_camera_dev *pcdev,\r\ndma_cookie_t last_submitted,\r\ndma_cookie_t last_issued)\r\n{\r\nbool is_dma_stopped = last_submitted != last_issued;\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s : top queued buffer=%p, is_dma_stopped=%d\n",\r\n__func__, pcdev->active, is_dma_stopped);\r\nif (pcdev->active && is_dma_stopped)\r\npxa_camera_start_capture(pcdev);\r\n}\r\nstatic void pxa_camera_dma_irq(struct pxa_camera_dev *pcdev,\r\nenum pxa_camera_active_dma act_dma)\r\n{\r\nstruct pxa_buffer *buf, *last_buf;\r\nunsigned long flags;\r\nu32 camera_status, overrun;\r\nint chan;\r\nenum dma_status last_status;\r\ndma_cookie_t last_issued;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\ncamera_status = __raw_readl(pcdev->base + CISR);\r\ndev_dbg(pcdev_to_dev(pcdev), "camera dma irq, cisr=0x%x dma=%d\n",\r\ncamera_status, act_dma);\r\noverrun = CISR_IFO_0;\r\nif (pcdev->channels == 3)\r\noverrun |= CISR_IFO_1 | CISR_IFO_2;\r\nif (!pcdev->active)\r\ngoto out;\r\nbuf = pcdev->active;\r\nWARN_ON(buf->inwork || list_empty(&buf->queue));\r\nswitch (act_dma) {\r\ncase DMA_U:\r\nchan = 1;\r\nbreak;\r\ncase DMA_V:\r\nchan = 2;\r\nbreak;\r\ndefault:\r\nchan = 0;\r\nbreak;\r\n}\r\nlast_buf = list_entry(pcdev->capture.prev,\r\nstruct pxa_buffer, queue);\r\nlast_status = dma_async_is_tx_complete(pcdev->dma_chans[chan],\r\nlast_buf->cookie[chan],\r\nNULL, &last_issued);\r\nif (camera_status & overrun &&\r\nlast_status != DMA_COMPLETE) {\r\ndev_dbg(pcdev_to_dev(pcdev), "FIFO overrun! CISR: %x\n",\r\ncamera_status);\r\npxa_camera_stop_capture(pcdev);\r\nlist_for_each_entry(buf, &pcdev->capture, queue)\r\npxa_dma_add_tail_buf(pcdev, buf);\r\npxa_camera_start_capture(pcdev);\r\ngoto out;\r\n}\r\nbuf->active_dma &= ~act_dma;\r\nif (!buf->active_dma) {\r\npxa_camera_wakeup(pcdev, buf, VB2_BUF_STATE_DONE);\r\npxa_camera_check_link_miss(pcdev, last_buf->cookie[chan],\r\nlast_issued);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\n}\r\nstatic u32 mclk_get_divisor(struct platform_device *pdev,\r\nstruct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long mclk = pcdev->mclk;\r\nu32 div;\r\nunsigned long lcdclk;\r\nlcdclk = clk_get_rate(pcdev->clk);\r\npcdev->ciclk = lcdclk;\r\nif (mclk > lcdclk / 4) {\r\nmclk = lcdclk / 4;\r\ndev_warn(pcdev_to_dev(pcdev),\r\n"Limiting master clock to %lu\n", mclk);\r\n}\r\ndiv = (lcdclk + 2 * mclk - 1) / (2 * mclk) - 1;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\npcdev->mclk = lcdclk / (2 * (div + 1));\r\ndev_dbg(pcdev_to_dev(pcdev), "LCD clock %luHz, target freq %luHz, divisor %u\n",\r\nlcdclk, mclk, div);\r\nreturn div;\r\n}\r\nstatic void recalculate_fifo_timeout(struct pxa_camera_dev *pcdev,\r\nunsigned long pclk)\r\n{\r\nu32 ciclk_per_pixel = pcdev->ciclk / pclk + 1;\r\n__raw_writel(ciclk_per_pixel, pcdev->base + CITOR);\r\n}\r\nstatic void pxa_camera_activate(struct pxa_camera_dev *pcdev)\r\n{\r\nu32 cicr4 = 0;\r\n__raw_writel(0x3ff, pcdev->base + CICR0);\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\ncicr4 |= CICR4_PCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\ncicr4 |= CICR4_MCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_PCP)\r\ncicr4 |= CICR4_PCP;\r\nif (pcdev->platform_flags & PXA_CAMERA_HSP)\r\ncicr4 |= CICR4_HSP;\r\nif (pcdev->platform_flags & PXA_CAMERA_VSP)\r\ncicr4 |= CICR4_VSP;\r\n__raw_writel(pcdev->mclk_divisor | cicr4, pcdev->base + CICR4);\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\nrecalculate_fifo_timeout(pcdev, pcdev->mclk);\r\nelse\r\nrecalculate_fifo_timeout(pcdev, 13000000);\r\nclk_prepare_enable(pcdev->clk);\r\n}\r\nstatic void pxa_camera_deactivate(struct pxa_camera_dev *pcdev)\r\n{\r\nclk_disable_unprepare(pcdev->clk);\r\n}\r\nstatic void pxa_camera_eof(unsigned long arg)\r\n{\r\nstruct pxa_camera_dev *pcdev = (struct pxa_camera_dev *)arg;\r\nunsigned long cifr;\r\nstruct pxa_buffer *buf;\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"Camera interrupt status 0x%x\n",\r\n__raw_readl(pcdev->base + CISR));\r\ncifr = __raw_readl(pcdev->base + CIFR) | CIFR_RESET_F;\r\n__raw_writel(cifr, pcdev->base + CIFR);\r\npcdev->active = list_first_entry(&pcdev->capture,\r\nstruct pxa_buffer, queue);\r\nbuf = pcdev->active;\r\npxa_videobuf_set_actdma(pcdev, buf);\r\npxa_dma_start_channels(pcdev);\r\n}\r\nstatic irqreturn_t pxa_camera_irq(int irq, void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\nunsigned long status, cicr0;\r\nstatus = __raw_readl(pcdev->base + CISR);\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"Camera interrupt status 0x%lx\n", status);\r\nif (!status)\r\nreturn IRQ_NONE;\r\n__raw_writel(status, pcdev->base + CISR);\r\nif (status & CISR_EOF) {\r\ncicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_EOFM;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\ntasklet_schedule(&pcdev->task_eof);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int test_platform_param(struct pxa_camera_dev *pcdev,\r\nunsigned char buswidth, unsigned long *flags)\r\n{\r\n*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?\r\nV4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING;\r\nif ((1 << (buswidth - 1)) & pcdev->width_flags)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void pxa_camera_setup_cicr(struct pxa_camera_dev *pcdev,\r\nunsigned long flags, __u32 pixfmt)\r\n{\r\nunsigned long dw, bpp;\r\nu32 cicr0, cicr1, cicr2, cicr3, cicr4 = 0, y_skip_top;\r\nint ret = sensor_call(pcdev, sensor, g_skip_top_lines, &y_skip_top);\r\nif (ret < 0)\r\ny_skip_top = 0;\r\nswitch (pcdev->current_fmt->host_fmt->bits_per_sample) {\r\ncase 10:\r\ndw = 4;\r\nbpp = 0x40;\r\nbreak;\r\ncase 9:\r\ndw = 3;\r\nbpp = 0x20;\r\nbreak;\r\ndefault:\r\ncase 8:\r\ndw = 2;\r\nbpp = 0;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\ncicr4 |= CICR4_PCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\ncicr4 |= CICR4_MCLK_EN;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncicr4 |= CICR4_PCP;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncicr4 |= CICR4_HSP;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncicr4 |= CICR4_VSP;\r\ncicr0 = __raw_readl(pcdev->base + CICR0);\r\nif (cicr0 & CICR0_ENB)\r\n__raw_writel(cicr0 & ~CICR0_ENB, pcdev->base + CICR0);\r\ncicr1 = CICR1_PPL_VAL(pcdev->current_pix.width - 1) | bpp | dw;\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_YUV422P:\r\npcdev->channels = 3;\r\ncicr1 |= CICR1_YCBCR_F;\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_VYUY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncicr1 |= CICR1_COLOR_SP_VAL(2);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncicr1 |= CICR1_RGB_BPP_VAL(1) | CICR1_RGBT_CONV_VAL(2) |\r\nCICR1_TBIT | CICR1_COLOR_SP_VAL(1);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncicr1 |= CICR1_COLOR_SP_VAL(1) | CICR1_RGB_BPP_VAL(2);\r\nbreak;\r\n}\r\ncicr2 = 0;\r\ncicr3 = CICR3_LPF_VAL(pcdev->current_pix.height - 1) |\r\nCICR3_BFW_VAL(min((u32)255, y_skip_top));\r\ncicr4 |= pcdev->mclk_divisor;\r\n__raw_writel(cicr1, pcdev->base + CICR1);\r\n__raw_writel(cicr2, pcdev->base + CICR2);\r\n__raw_writel(cicr3, pcdev->base + CICR3);\r\n__raw_writel(cicr4, pcdev->base + CICR4);\r\ncicr0 = (cicr0 & CICR0_ENB) | (pcdev->platform_flags & PXA_CAMERA_MASTER ?\r\nCICR0_SIM_MP : (CICR0_SL_CAP_EN | CICR0_SIM_SP));\r\ncicr0 |= CICR0_DMAEN | CICR0_IRQ_MASK;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nstatic void pxa_buffer_cleanup(struct pxa_buffer *buf)\r\n{\r\nint i;\r\nfor (i = 0; i < 3 && buf->descs[i]; i++) {\r\ndmaengine_desc_free(buf->descs[i]);\r\nkfree(buf->sg[i]);\r\nbuf->descs[i] = NULL;\r\nbuf->sg[i] = NULL;\r\nbuf->sg_len[i] = 0;\r\nbuf->plane_sizes[i] = 0;\r\n}\r\nbuf->nb_planes = 0;\r\n}\r\nstatic int pxa_buffer_init(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nstruct vb2_buffer *vb = &buf->vbuf.vb2_buf;\r\nstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\r\nint nb_channels = pcdev->channels;\r\nint i, ret = 0;\r\nunsigned long size = vb2_plane_size(vb, 0);\r\nswitch (nb_channels) {\r\ncase 1:\r\nbuf->plane_sizes[0] = size;\r\nbreak;\r\ncase 3:\r\nbuf->plane_sizes[0] = size / 2;\r\nbuf->plane_sizes[1] = size / 4;\r\nbuf->plane_sizes[2] = size / 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nbuf->nb_planes = nb_channels;\r\nret = sg_split(sgt->sgl, sgt->nents, 0, nb_channels,\r\nbuf->plane_sizes, buf->sg, buf->sg_len, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(pcdev_to_dev(pcdev),\r\n"sg_split failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < nb_channels; i++) {\r\nret = pxa_init_dma_channel(pcdev, buf, i,\r\nbuf->sg[i], buf->sg_len[i]);\r\nif (ret) {\r\npxa_buffer_cleanup(buf);\r\nreturn ret;\r\n}\r\n}\r\nINIT_LIST_HEAD(&buf->queue);\r\nreturn ret;\r\n}\r\nstatic void pxac_vb2_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s(vb=%p)\n", __func__, vb);\r\npxa_buffer_cleanup(buf);\r\n}\r\nstatic void pxac_vb2_queue(struct vb2_buffer *vb)\r\n{\r\nstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s(vb=%p) nb_channels=%d size=%lu active=%p\n",\r\n__func__, vb, pcdev->channels, vb2_get_plane_payload(vb, 0),\r\npcdev->active);\r\nlist_add_tail(&buf->queue, &pcdev->capture);\r\npxa_dma_add_tail_buf(pcdev, buf);\r\n}\r\nstatic int pxac_vb2_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\r\nint ret = 0;\r\nswitch (pcdev->channels) {\r\ncase 1:\r\ncase 3:\r\nvb2_set_plane_payload(vb, 0, pcdev->current_pix.sizeimage);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s (vb=%p) nb_channels=%d size=%lu\n",\r\n__func__, vb, pcdev->channels, vb2_get_plane_payload(vb, 0));\r\nWARN_ON(!pcdev->current_fmt);\r\n#ifdef DEBUG\r\nfor (i = 0; i < vb->num_planes; i++)\r\nmemset((void *)vb2_plane_vaddr(vb, i),\r\n0xaa, vb2_get_plane_payload(vb, i));\r\n#endif\r\nbuf->inwork = 0;\r\npxa_videobuf_set_actdma(pcdev, buf);\r\nreturn ret;\r\n}\r\nstatic int pxac_vb2_init(struct vb2_buffer *vb)\r\n{\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct pxa_buffer *buf = vb2_to_pxa_buffer(vb);\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s(nb_channels=%d)\n",\r\n__func__, pcdev->channels);\r\nreturn pxa_buffer_init(pcdev, buf);\r\n}\r\nstatic int pxac_vb2_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbufs,\r\nunsigned int *num_planes, unsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vq);\r\nint size = pcdev->current_pix.sizeimage;\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"%s(vq=%p nbufs=%d num_planes=%d size=%d)\n",\r\n__func__, vq, *nbufs, *num_planes, size);\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nswitch (pcdev->channels) {\r\ncase 1:\r\ncase 3:\r\nsizes[0] = size;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!*nbufs)\r\n*nbufs = 1;\r\nreturn 0;\r\n}\r\nstatic int pxac_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vq);\r\ndev_dbg(pcdev_to_dev(pcdev), "%s(count=%d) active=%p\n",\r\n__func__, count, pcdev->active);\r\npcdev->buf_sequence = 0;\r\nif (!pcdev->active)\r\npxa_camera_start_capture(pcdev);\r\nreturn 0;\r\n}\r\nstatic void pxac_vb2_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct pxa_camera_dev *pcdev = vb2_get_drv_priv(vq);\r\nstruct pxa_buffer *buf, *tmp;\r\ndev_dbg(pcdev_to_dev(pcdev), "%s active=%p\n",\r\n__func__, pcdev->active);\r\npxa_camera_stop_capture(pcdev);\r\nlist_for_each_entry_safe(buf, tmp, &pcdev->capture, queue)\r\npxa_camera_wakeup(pcdev, buf, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic int pxa_camera_init_videobuf2(struct pxa_camera_dev *pcdev)\r\n{\r\nint ret;\r\nstruct vb2_queue *vq = &pcdev->vb2_vq;\r\nmemset(vq, 0, sizeof(*vq));\r\nvq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nvq->drv_priv = pcdev;\r\nvq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nvq->buf_struct_size = sizeof(struct pxa_buffer);\r\nvq->dev = pcdev->v4l2_dev.dev;\r\nvq->ops = &pxac_vb2_ops;\r\nvq->mem_ops = &vb2_dma_sg_memops;\r\nvq->lock = &pcdev->mlock;\r\nret = vb2_queue_init(vq);\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"vb2_queue_init(vq=%p): %d\n", vq, ret);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_set_bus_param(struct pxa_camera_dev *pcdev)\r\n{\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nu32 pixfmt = pcdev->current_fmt->host_fmt->fourcc;\r\nunsigned long bus_flags, common_flags;\r\nint ret;\r\nret = test_platform_param(pcdev,\r\npcdev->current_fmt->host_fmt->bits_per_sample,\r\n&bus_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sensor_call(pcdev, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = pxa_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(pcdev_to_dev(pcdev),\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = bus_flags;\r\n}\r\npcdev->channels = 1;\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_HSP)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_VSP)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_PCP)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\ncfg.flags = common_flags;\r\nret = sensor_call(pcdev, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\npxa_camera_setup_cicr(pcdev, common_flags, pixfmt);\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_try_bus_param(struct pxa_camera_dev *pcdev,\r\nunsigned char buswidth)\r\n{\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long bus_flags, common_flags;\r\nint ret = test_platform_param(pcdev, buswidth, &bus_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sensor_call(pcdev, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = pxa_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(pcdev_to_dev(pcdev),\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret == -ENOIOCTLCMD) {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool pxa_camera_packing_supported(const struct pxa_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == PXA_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == PXA_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == PXA_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic int pxa_camera_get_formats(struct v4l2_device *v4l2_dev,\r\nunsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct pxa_camera_dev *pcdev = v4l2_dev_to_pcdev(v4l2_dev);\r\nint formats = 0, ret;\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n.index = idx,\r\n};\r\nconst struct pxa_mbus_pixelfmt *fmt;\r\nret = sensor_call(pcdev, pad, enum_mbus_code, NULL, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = pxa_mbus_get_fmtdesc(code.code);\r\nif (!fmt) {\r\ndev_err(pcdev_to_dev(pcdev),\r\n"Invalid format code #%u: %d\n", idx, code.code);\r\nreturn 0;\r\n}\r\nret = pxa_camera_try_bus_param(pcdev, fmt->bits_per_sample);\r\nif (ret < 0)\r\nreturn 0;\r\nswitch (code.code) {\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = &pxa_camera_formats[0];\r\nxlate->code = code.code;\r\nxlate++;\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"Providing format %s using code %d\n",\r\npxa_camera_formats[0].name, code.code);\r\n}\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ncase MEDIA_BUS_FMT_RGB565_2X8_LE:\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\r\nif (xlate)\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"Providing format %s packed\n",\r\nfmt->name);\r\nbreak;\r\ndefault:\r\nif (!pxa_camera_packing_supported(fmt))\r\nreturn 0;\r\nif (xlate)\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"Providing format %s in pass-through mode\n",\r\nfmt->name);\r\nbreak;\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code.code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic int pxa_camera_build_formats(struct pxa_camera_dev *pcdev)\r\n{\r\nstruct soc_camera_format_xlate *xlate;\r\nxlate = pxa_mbus_build_fmts_xlate(&pcdev->v4l2_dev, pcdev->sensor,\r\npxa_camera_get_formats);\r\nif (IS_ERR(xlate))\r\nreturn PTR_ERR(xlate);\r\npcdev->user_formats = xlate;\r\nreturn 0;\r\n}\r\nstatic void pxa_camera_destroy_formats(struct pxa_camera_dev *pcdev)\r\n{\r\nkfree(pcdev->user_formats);\r\n}\r\nstatic int pxa_camera_check_frame(u32 width, u32 height)\r\n{\r\nreturn height < 32 || height > 2048 || width < 48 || width > 2048 ||\r\n(width & 0x01);\r\n}\r\nstatic int pxac_vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(file);\r\nif (reg->reg > CIBR2)\r\nreturn -ERANGE;\r\nreg->val = __raw_readl(pcdev->base + reg->reg);\r\nreg->size = sizeof(__u32);\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_s_register(struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(file);\r\nif (reg->reg > CIBR2)\r\nreturn -ERANGE;\r\nif (reg->size != sizeof(__u32))\r\nreturn -EINVAL;\r\n__raw_writel(reg->val, pcdev->base + reg->reg);\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_enum_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(filp);\r\nconst struct pxa_mbus_pixelfmt *format;\r\nunsigned int idx;\r\nfor (idx = 0; pcdev->user_formats[idx].code; idx++);\r\nif (f->index >= idx)\r\nreturn -EINVAL;\r\nformat = pcdev->user_formats[f->index].host_fmt;\r\nf->pixelformat = format->fourcc;\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_g_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(filp);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\npix->width = pcdev->current_pix.width;\r\npix->height = pcdev->current_pix.height;\r\npix->bytesperline = pcdev->current_pix.bytesperline;\r\npix->sizeimage = pcdev->current_pix.sizeimage;\r\npix->field = pcdev->current_pix.field;\r\npix->pixelformat = pcdev->current_fmt->host_fmt->fourcc;\r\npix->colorspace = pcdev->current_pix.colorspace;\r\ndev_dbg(pcdev_to_dev(pcdev), "current_fmt->fourcc: 0x%08x\n",\r\npcdev->current_fmt->host_fmt->fourcc);\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_try_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(filp);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_pad_config pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\n__u32 pixfmt = pix->pixelformat;\r\nint ret;\r\nxlate = pxa_mbus_xlate_by_fourcc(pcdev->user_formats, pixfmt);\r\nif (!xlate) {\r\ndev_warn(pcdev_to_dev(pcdev), "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&pix->width, 48, 2048, 1,\r\n&pix->height, 32, 2048, 0,\r\npixfmt == V4L2_PIX_FMT_YUV422P ? 4 : 0);\r\nv4l2_fill_mbus_format(mf, pix, xlate->code);\r\nret = sensor_call(pcdev, pad, set_fmt, &pad_cfg, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_fill_pix_format(pix, mf);\r\nswitch (mf->field) {\r\ncase V4L2_FIELD_ANY:\r\ncase V4L2_FIELD_NONE:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\ndefault:\r\ndev_err(pcdev_to_dev(pcdev), "Field type %d unsupported.\n",\r\nmf->field);\r\nreturn -EINVAL;\r\n}\r\nret = pxa_mbus_bytes_per_line(pix->width, xlate->host_fmt);\r\nif (ret < 0)\r\nreturn ret;\r\npix->bytesperline = ret;\r\nret = pxa_mbus_image_size(xlate->host_fmt, pix->bytesperline,\r\npix->height);\r\nif (ret < 0)\r\nreturn ret;\r\npix->sizeimage = ret;\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_s_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(filp);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nunsigned long flags;\r\nint ret, is_busy;\r\ndev_dbg(pcdev_to_dev(pcdev),\r\n"s_fmt_vid_cap(pix=%dx%d:%x)\n",\r\npix->width, pix->height, pix->pixelformat);\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nis_busy = pcdev->active || vb2_is_busy(&pcdev->vb2_vq);\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\nif (is_busy)\r\nreturn -EBUSY;\r\nret = pxac_vidioc_try_fmt_vid_cap(filp, priv, f);\r\nif (ret)\r\nreturn ret;\r\nxlate = pxa_mbus_xlate_by_fourcc(pcdev->user_formats,\r\npix->pixelformat);\r\nv4l2_fill_mbus_format(&format.format, pix, xlate->code);\r\nret = sensor_call(pcdev, pad, set_fmt, NULL, &format);\r\nif (ret < 0) {\r\ndev_warn(pcdev_to_dev(pcdev),\r\n"Failed to configure for format %x\n",\r\npix->pixelformat);\r\n} else if (pxa_camera_check_frame(pix->width, pix->height)) {\r\ndev_warn(pcdev_to_dev(pcdev),\r\n"Camera driver produced an unsupported frame %dx%d\n",\r\npix->width, pix->height);\r\nreturn -EINVAL;\r\n}\r\npcdev->current_fmt = xlate;\r\npcdev->current_pix = *pix;\r\nret = pxa_camera_set_bus_param(pcdev);\r\nreturn ret;\r\n}\r\nstatic int pxac_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->bus_info, "platform:pxa-camera", sizeof(cap->bus_info));\r\nstrlcpy(cap->driver, PXA_CAM_DRV_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, pxa_cam_driver_description, sizeof(cap->card));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index > 0)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrlcpy(i->name, "Camera", sizeof(i->name));\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int pxac_vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pxac_fops_camera_open(struct file *filp)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(filp);\r\nint ret;\r\nmutex_lock(&pcdev->mlock);\r\nret = v4l2_fh_open(filp);\r\nif (ret < 0)\r\ngoto out;\r\nret = sensor_call(pcdev, core, s_power, 1);\r\nif (ret)\r\nv4l2_fh_release(filp);\r\nout:\r\nmutex_unlock(&pcdev->mlock);\r\nreturn ret;\r\n}\r\nstatic int pxac_fops_camera_release(struct file *filp)\r\n{\r\nstruct pxa_camera_dev *pcdev = video_drvdata(filp);\r\nint ret;\r\nret = vb2_fop_release(filp);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&pcdev->mlock);\r\nret = sensor_call(pcdev, core, s_power, 0);\r\nmutex_unlock(&pcdev->mlock);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_sensor_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nint err;\r\nstruct v4l2_device *v4l2_dev = notifier->v4l2_dev;\r\nstruct pxa_camera_dev *pcdev = v4l2_dev_to_pcdev(v4l2_dev);\r\nstruct video_device *vdev = &pcdev->vdev;\r\nstruct v4l2_pix_format *pix = &pcdev->current_pix;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct v4l2_mbus_framefmt *mf = &format.format;\r\ndev_info(pcdev_to_dev(pcdev), "%s(): trying to bind a device\n",\r\n__func__);\r\nmutex_lock(&pcdev->mlock);\r\n*vdev = pxa_camera_videodev_template;\r\nvdev->v4l2_dev = v4l2_dev;\r\nvdev->lock = &pcdev->mlock;\r\npcdev->sensor = subdev;\r\npcdev->vdev.queue = &pcdev->vb2_vq;\r\npcdev->vdev.v4l2_dev = &pcdev->v4l2_dev;\r\npcdev->vdev.ctrl_handler = subdev->ctrl_handler;\r\nvideo_set_drvdata(&pcdev->vdev, pcdev);\r\nerr = pxa_camera_build_formats(pcdev);\r\nif (err) {\r\ndev_err(pcdev_to_dev(pcdev), "building formats failed: %d\n",\r\nerr);\r\ngoto out;\r\n}\r\npcdev->current_fmt = pcdev->user_formats;\r\npix->field = V4L2_FIELD_NONE;\r\npix->width = DEFAULT_WIDTH;\r\npix->height = DEFAULT_HEIGHT;\r\npix->bytesperline =\r\npxa_mbus_bytes_per_line(pix->width,\r\npcdev->current_fmt->host_fmt);\r\npix->sizeimage =\r\npxa_mbus_image_size(pcdev->current_fmt->host_fmt,\r\npix->bytesperline, pix->height);\r\npix->pixelformat = pcdev->current_fmt->host_fmt->fourcc;\r\nv4l2_fill_mbus_format(mf, pix, pcdev->current_fmt->code);\r\nerr = sensor_call(pcdev, core, s_power, 1);\r\nif (err)\r\ngoto out;\r\nerr = sensor_call(pcdev, pad, set_fmt, NULL, &format);\r\nif (err)\r\ngoto out_sensor_poweroff;\r\nv4l2_fill_pix_format(pix, mf);\r\npr_info("%s(): colorspace=0x%x pixfmt=0x%x\n",\r\n__func__, pix->colorspace, pix->pixelformat);\r\nerr = pxa_camera_init_videobuf2(pcdev);\r\nif (err)\r\ngoto out_sensor_poweroff;\r\nerr = video_register_device(&pcdev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (err) {\r\nv4l2_err(v4l2_dev, "register video device failed: %d\n", err);\r\npcdev->sensor = NULL;\r\n} else {\r\ndev_info(pcdev_to_dev(pcdev),\r\n"PXA Camera driver attached to camera %s\n",\r\nsubdev->name);\r\n}\r\nout_sensor_poweroff:\r\nerr = sensor_call(pcdev, core, s_power, 0);\r\nout:\r\nmutex_unlock(&pcdev->mlock);\r\nreturn err;\r\n}\r\nstatic void pxa_camera_sensor_unbind(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct pxa_camera_dev *pcdev = v4l2_dev_to_pcdev(notifier->v4l2_dev);\r\nmutex_lock(&pcdev->mlock);\r\ndev_info(pcdev_to_dev(pcdev),\r\n"PXA Camera driver detached from camera %s\n",\r\nsubdev->name);\r\n__raw_writel(0x3ff, pcdev->base + CICR0);\r\npxa_dma_stop_channels(pcdev);\r\npxa_camera_destroy_formats(pcdev);\r\nvideo_unregister_device(&pcdev->vdev);\r\npcdev->sensor = NULL;\r\nmutex_unlock(&pcdev->mlock);\r\n}\r\nstatic int pxa_camera_suspend(struct device *dev)\r\n{\r\nstruct pxa_camera_dev *pcdev = dev_get_drvdata(dev);\r\nint i = 0, ret = 0;\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR0);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR1);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR2);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR3);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR4);\r\nif (pcdev->sensor) {\r\nret = sensor_call(pcdev, core, s_power, 0);\r\nif (ret == -ENOIOCTLCMD)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_resume(struct device *dev)\r\n{\r\nstruct pxa_camera_dev *pcdev = dev_get_drvdata(dev);\r\nint i = 0, ret = 0;\r\n__raw_writel(pcdev->save_cicr[i++] & ~CICR0_ENB, pcdev->base + CICR0);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR1);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR2);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR3);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR4);\r\nif (pcdev->sensor) {\r\nret = sensor_call(pcdev, core, s_power, 1);\r\nif (ret == -ENOIOCTLCMD)\r\nret = 0;\r\n}\r\nif (!ret && pcdev->active)\r\npxa_camera_start_capture(pcdev);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_pdata_from_dt(struct device *dev,\r\nstruct pxa_camera_dev *pcdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nu32 mclk_rate;\r\nstruct device_node *remote, *np = dev->of_node;\r\nstruct v4l2_of_endpoint ep;\r\nint err = of_property_read_u32(np, "clock-frequency",\r\n&mclk_rate);\r\nif (!err) {\r\npcdev->platform_flags |= PXA_CAMERA_MCLK_EN;\r\npcdev->mclk = mclk_rate;\r\n}\r\nnp = of_graph_get_next_endpoint(np, NULL);\r\nif (!np) {\r\ndev_err(dev, "could not find endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nerr = v4l2_of_parse_endpoint(np, &ep);\r\nif (err) {\r\ndev_err(dev, "could not parse endpoint\n");\r\ngoto out;\r\n}\r\nswitch (ep.bus.parallel.bus_width) {\r\ncase 4:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_4;\r\nbreak;\r\ncase 5:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_5;\r\nbreak;\r\ncase 8:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_8;\r\nbreak;\r\ncase 9:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_9;\r\nbreak;\r\ncase 10:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ep.bus.parallel.flags & V4L2_MBUS_MASTER)\r\npcdev->platform_flags |= PXA_CAMERA_MASTER;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\npcdev->platform_flags |= PXA_CAMERA_HSP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\npcdev->platform_flags |= PXA_CAMERA_VSP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\npcdev->platform_flags |= PXA_CAMERA_PCLK_EN | PXA_CAMERA_PCP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\npcdev->platform_flags |= PXA_CAMERA_PCLK_EN;\r\nasd->match_type = V4L2_ASYNC_MATCH_OF;\r\nremote = of_graph_get_remote_port(np);\r\nif (remote) {\r\nasd->match.of.node = remote;\r\nof_node_put(remote);\r\n} else {\r\ndev_notice(dev, "no remote for %s\n", of_node_full_name(np));\r\n}\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic int pxa_camera_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa_camera_dev *pcdev;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct dma_slave_config config = {\r\n.src_addr_width = 0,\r\n.src_maxburst = 8,\r\n.direction = DMA_DEV_TO_MEM,\r\n};\r\ndma_cap_mask_t mask;\r\nstruct pxad_param params;\r\nchar clk_name[V4L2_CLK_NAME_SIZE];\r\nint irq;\r\nint err = 0, i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || irq < 0)\r\nreturn -ENODEV;\r\npcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nreturn -ENOMEM;\r\n}\r\npcdev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pcdev->clk))\r\nreturn PTR_ERR(pcdev->clk);\r\npcdev->res = res;\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (&pdev->dev.of_node && !pcdev->pdata) {\r\nerr = pxa_camera_pdata_from_dt(&pdev->dev, pcdev, &pcdev->asd);\r\n} else {\r\npcdev->platform_flags = pcdev->pdata->flags;\r\npcdev->mclk = pcdev->pdata->mclk_10khz * 10000;\r\npcdev->asd.match_type = V4L2_ASYNC_MATCH_I2C;\r\npcdev->asd.match.i2c.adapter_id =\r\npcdev->pdata->sensor_i2c_adapter_id;\r\npcdev->asd.match.i2c.address = pcdev->pdata->sensor_i2c_address;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (!(pcdev->platform_flags & (PXA_CAMERA_DATAWIDTH_8 |\r\nPXA_CAMERA_DATAWIDTH_9 | PXA_CAMERA_DATAWIDTH_10))) {\r\ndev_warn(&pdev->dev, "WARNING! Platform hasn't set available data widths, using default 10 bit\n");\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_8)\r\npcdev->width_flags = 1 << 7;\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_9)\r\npcdev->width_flags |= 1 << 8;\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_10)\r\npcdev->width_flags |= 1 << 9;\r\nif (!pcdev->mclk) {\r\ndev_warn(&pdev->dev,\r\n"mclk == 0! Please, fix your platform data. Using default 20MHz\n");\r\npcdev->mclk = 20000000;\r\n}\r\npcdev->mclk_divisor = mclk_get_divisor(pdev, pcdev);\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nspin_lock_init(&pcdev->lock);\r\nmutex_init(&pcdev->mlock);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\npcdev->irq = irq;\r\npcdev->base = base;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_PRIVATE, mask);\r\nparams.prio = 0;\r\nparams.drcmr = 68;\r\npcdev->dma_chans[0] =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&params, &pdev->dev, "CI_Y");\r\nif (!pcdev->dma_chans[0]) {\r\ndev_err(&pdev->dev, "Can't request DMA for Y\n");\r\nreturn -ENODEV;\r\n}\r\nparams.drcmr = 69;\r\npcdev->dma_chans[1] =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&params, &pdev->dev, "CI_U");\r\nif (!pcdev->dma_chans[1]) {\r\ndev_err(&pdev->dev, "Can't request DMA for Y\n");\r\nerr = -ENODEV;\r\ngoto exit_free_dma_y;\r\n}\r\nparams.drcmr = 70;\r\npcdev->dma_chans[2] =\r\ndma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&params, &pdev->dev, "CI_V");\r\nif (!pcdev->dma_chans[2]) {\r\ndev_err(&pdev->dev, "Can't request DMA for V\n");\r\nerr = -ENODEV;\r\ngoto exit_free_dma_u;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nconfig.src_addr = pcdev->res->start + CIBR0 + i * 8;\r\nerr = dmaengine_slave_config(pcdev->dma_chans[i], &config);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "dma slave config failed: %d\n",\r\nerr);\r\ngoto exit_free_dma;\r\n}\r\n}\r\nerr = devm_request_irq(&pdev->dev, pcdev->irq, pxa_camera_irq, 0,\r\nPXA_CAM_DRV_NAME, pcdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Camera interrupt register failed\n");\r\ngoto exit_free_dma;\r\n}\r\ntasklet_init(&pcdev->task_eof, pxa_camera_eof, (unsigned long)pcdev);\r\npxa_camera_activate(pcdev);\r\ndev_set_drvdata(&pdev->dev, pcdev);\r\nerr = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);\r\nif (err)\r\ngoto exit_free_dma;\r\npcdev->asds[0] = &pcdev->asd;\r\npcdev->notifier.subdevs = pcdev->asds;\r\npcdev->notifier.num_subdevs = 1;\r\npcdev->notifier.bound = pxa_camera_sensor_bound;\r\npcdev->notifier.unbind = pxa_camera_sensor_unbind;\r\nif (!of_have_populated_dt())\r\npcdev->asd.match_type = V4L2_ASYNC_MATCH_I2C;\r\nerr = pxa_camera_init_videobuf2(pcdev);\r\nif (err)\r\ngoto exit_free_v4l2dev;\r\nif (pcdev->mclk) {\r\nv4l2_clk_name_i2c(clk_name, sizeof(clk_name),\r\npcdev->asd.match.i2c.adapter_id,\r\npcdev->asd.match.i2c.address);\r\npcdev->mclk_clk = v4l2_clk_register(&pxa_camera_mclk_ops,\r\nclk_name, NULL);\r\nif (IS_ERR(pcdev->mclk_clk)) {\r\nerr = PTR_ERR(pcdev->mclk_clk);\r\ngoto exit_free_v4l2dev;\r\n}\r\n}\r\nerr = v4l2_async_notifier_register(&pcdev->v4l2_dev, &pcdev->notifier);\r\nif (err)\r\ngoto exit_free_clk;\r\nreturn 0;\r\nexit_free_clk:\r\nv4l2_clk_unregister(pcdev->mclk_clk);\r\nexit_free_v4l2dev:\r\nv4l2_device_unregister(&pcdev->v4l2_dev);\r\nexit_free_dma:\r\ndma_release_channel(pcdev->dma_chans[2]);\r\nexit_free_dma_u:\r\ndma_release_channel(pcdev->dma_chans[1]);\r\nexit_free_dma_y:\r\ndma_release_channel(pcdev->dma_chans[0]);\r\nreturn err;\r\n}\r\nstatic int pxa_camera_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa_camera_dev *pcdev = dev_get_drvdata(&pdev->dev);\r\npxa_camera_deactivate(pcdev);\r\ndma_release_channel(pcdev->dma_chans[0]);\r\ndma_release_channel(pcdev->dma_chans[1]);\r\ndma_release_channel(pcdev->dma_chans[2]);\r\nv4l2_clk_unregister(pcdev->mclk_clk);\r\nv4l2_device_unregister(&pcdev->v4l2_dev);\r\ndev_info(&pdev->dev, "PXA Camera driver unloaded\n");\r\nreturn 0;\r\n}
