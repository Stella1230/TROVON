static int __init set_smp_ops_by_method(struct device_node *node)\r\n{\r\nconst char *method;\r\nstruct of_cpu_method *m = __cpu_method_of_table;\r\nif (of_property_read_string(node, "enable-method", &method))\r\nreturn 0;\r\nfor (; m->method; m++)\r\nif (!strcmp(m->method, method)) {\r\nsmp_set_ops(m->ops);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int set_smp_ops_by_method(struct device_node *node)\r\n{\r\nreturn 1;\r\n}\r\nvoid __init arm_dt_init_cpu_maps(void)\r\n{\r\nstruct device_node *cpu, *cpus;\r\nint found_method = 0;\r\nu32 i, j, cpuidx = 1;\r\nu32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;\r\nu32 tmp_map[NR_CPUS] = { [0 ... NR_CPUS-1] = MPIDR_INVALID };\r\nbool bootcpu_valid = false;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (!cpus)\r\nreturn;\r\nfor_each_child_of_node(cpus, cpu) {\r\nconst __be32 *cell;\r\nint prop_bytes;\r\nu32 hwid;\r\nif (of_node_cmp(cpu->type, "cpu"))\r\ncontinue;\r\npr_debug(" * %s...\n", cpu->full_name);\r\ncell = of_get_property(cpu, "reg", &prop_bytes);\r\nif (!cell || prop_bytes < sizeof(*cell)) {\r\npr_debug(" * %s missing reg property\n",\r\ncpu->full_name);\r\nof_node_put(cpu);\r\nreturn;\r\n}\r\ndo {\r\nhwid = be32_to_cpu(*cell++);\r\nprop_bytes -= sizeof(*cell);\r\n} while (!hwid && prop_bytes > 0);\r\nif (prop_bytes || (hwid & ~MPIDR_HWID_BITMASK)) {\r\nof_node_put(cpu);\r\nreturn;\r\n}\r\nfor (j = 0; j < cpuidx; j++)\r\nif (WARN(tmp_map[j] == hwid,\r\n"Duplicate /cpu reg properties in the DT\n")) {\r\nof_node_put(cpu);\r\nreturn;\r\n}\r\nif (hwid == mpidr) {\r\ni = 0;\r\nbootcpu_valid = true;\r\n} else {\r\ni = cpuidx++;\r\n}\r\nif (WARN(cpuidx > nr_cpu_ids, "DT /cpu %u nodes greater than "\r\n"max cores %u, capping them\n",\r\ncpuidx, nr_cpu_ids)) {\r\ncpuidx = nr_cpu_ids;\r\nof_node_put(cpu);\r\nbreak;\r\n}\r\ntmp_map[i] = hwid;\r\nif (!found_method)\r\nfound_method = set_smp_ops_by_method(cpu);\r\n}\r\nif (!found_method)\r\nset_smp_ops_by_method(cpus);\r\nif (!bootcpu_valid) {\r\npr_warn("DT missing boot CPU MPIDR[23:0], fall back to default cpu_logical_map\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < cpuidx; i++) {\r\nset_cpu_possible(i, true);\r\ncpu_logical_map(i) = tmp_map[i];\r\npr_debug("cpu logical map 0x%x\n", cpu_logical_map(i));\r\n}\r\n}\r\nbool arch_match_cpu_phys_id(int cpu, u64 phys_id)\r\n{\r\nreturn phys_id == cpu_logical_map(cpu);\r\n}\r\nstatic const void * __init arch_get_next_mach(const char *const **match)\r\n{\r\nstatic const struct machine_desc *mdesc = __arch_info_begin;\r\nconst struct machine_desc *m = mdesc;\r\nif (m >= __arch_info_end)\r\nreturn NULL;\r\nmdesc++;\r\n*match = m->dt_compat;\r\nreturn m;\r\n}\r\nconst struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)\r\n{\r\nconst struct machine_desc *mdesc, *mdesc_best = NULL;\r\n#if defined(CONFIG_ARCH_MULTIPLATFORM) || defined(CONFIG_ARM_SINGLE_ARMV7M)\r\nDT_MACHINE_START(GENERIC_DT, "Generic DT based system")\r\n.l2c_aux_val = 0x0,\r\n.l2c_aux_mask = ~0x0,\r\nMACHINE_END\r\nmdesc_best = &__mach_desc_GENERIC_DT;\r\n#endif\r\nif (!dt_phys || !early_init_dt_verify(phys_to_virt(dt_phys)))\r\nreturn NULL;\r\nmdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);\r\nif (!mdesc) {\r\nconst char *prop;\r\nint size;\r\nunsigned long dt_root;\r\nearly_print("\nError: unrecognized/unsupported "\r\n"device tree compatible list:\n[ ");\r\ndt_root = of_get_flat_dt_root();\r\nprop = of_get_flat_dt_prop(dt_root, "compatible", &size);\r\nwhile (size > 0) {\r\nearly_print("'%s' ", prop);\r\nsize -= strlen(prop) + 1;\r\nprop += strlen(prop) + 1;\r\n}\r\nearly_print("]\n\n");\r\ndump_machine_table();\r\n}\r\nif (mdesc->dt_fixup)\r\nmdesc->dt_fixup();\r\nearly_init_dt_scan_nodes();\r\n__machine_arch_type = mdesc->nr;\r\nreturn mdesc;\r\n}
