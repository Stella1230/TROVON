static u32 hix5hd2_i2c_clr_pend_irq(struct hix5hd2_i2c_priv *priv)\r\n{\r\nu32 val = readl_relaxed(priv->regs + HIX5I2C_SR);\r\nwritel_relaxed(val, priv->regs + HIX5I2C_ICR);\r\nreturn val;\r\n}\r\nstatic void hix5hd2_i2c_clr_all_irq(struct hix5hd2_i2c_priv *priv)\r\n{\r\nwritel_relaxed(I2C_CLEAR_ALL, priv->regs + HIX5I2C_ICR);\r\n}\r\nstatic void hix5hd2_i2c_disable_irq(struct hix5hd2_i2c_priv *priv)\r\n{\r\nwritel_relaxed(0, priv->regs + HIX5I2C_CTRL);\r\n}\r\nstatic void hix5hd2_i2c_enable_irq(struct hix5hd2_i2c_priv *priv)\r\n{\r\nwritel_relaxed(I2C_ENABLE | I2C_UNMASK_TOTAL | I2C_UNMASK_ALL,\r\npriv->regs + HIX5I2C_CTRL);\r\n}\r\nstatic void hix5hd2_i2c_drv_setrate(struct hix5hd2_i2c_priv *priv)\r\n{\r\nu32 rate, val;\r\nu32 scl, sysclock;\r\nval = readl_relaxed(priv->regs + HIX5I2C_CTRL);\r\nwritel_relaxed(val & (~I2C_UNMASK_TOTAL), priv->regs + HIX5I2C_CTRL);\r\nrate = priv->freq;\r\nsysclock = clk_get_rate(priv->clk);\r\nscl = (sysclock / (rate * 2)) / 2 - 1;\r\nwritel_relaxed(scl, priv->regs + HIX5I2C_SCL_H);\r\nwritel_relaxed(scl, priv->regs + HIX5I2C_SCL_L);\r\nwritel_relaxed(val, priv->regs + HIX5I2C_CTRL);\r\ndev_dbg(priv->dev, "%s: sysclock=%d, rate=%d, scl=%d\n",\r\n__func__, sysclock, rate, scl);\r\n}\r\nstatic void hix5hd2_i2c_init(struct hix5hd2_i2c_priv *priv)\r\n{\r\nhix5hd2_i2c_disable_irq(priv);\r\nhix5hd2_i2c_drv_setrate(priv);\r\nhix5hd2_i2c_clr_all_irq(priv);\r\nhix5hd2_i2c_enable_irq(priv);\r\n}\r\nstatic void hix5hd2_i2c_reset(struct hix5hd2_i2c_priv *priv)\r\n{\r\nclk_disable_unprepare(priv->clk);\r\nmsleep(20);\r\nclk_prepare_enable(priv->clk);\r\nhix5hd2_i2c_init(priv);\r\n}\r\nstatic int hix5hd2_i2c_wait_bus_idle(struct hix5hd2_i2c_priv *priv)\r\n{\r\nunsigned long stop_time;\r\nu32 int_status;\r\nstop_time = jiffies + msecs_to_jiffies(100);\r\ndo {\r\nint_status = hix5hd2_i2c_clr_pend_irq(priv);\r\nif (!(int_status & I2C_BUSY))\r\nreturn 0;\r\nusleep_range(50, 200);\r\n} while (time_before(jiffies, stop_time));\r\nreturn -EBUSY;\r\n}\r\nstatic void hix5hd2_rw_over(struct hix5hd2_i2c_priv *priv)\r\n{\r\nif (priv->state == HIX5I2C_STAT_SND_STOP)\r\ndev_dbg(priv->dev, "%s: rw and send stop over\n", __func__);\r\nelse\r\ndev_dbg(priv->dev, "%s: have not data to send\n", __func__);\r\npriv->state = HIX5I2C_STAT_RW_SUCCESS;\r\npriv->err = 0;\r\n}\r\nstatic void hix5hd2_rw_handle_stop(struct hix5hd2_i2c_priv *priv)\r\n{\r\nif (priv->stop) {\r\npriv->state = HIX5I2C_STAT_SND_STOP;\r\nwritel_relaxed(I2C_STOP, priv->regs + HIX5I2C_COM);\r\n} else {\r\nhix5hd2_rw_over(priv);\r\n}\r\n}\r\nstatic void hix5hd2_read_handle(struct hix5hd2_i2c_priv *priv)\r\n{\r\nif (priv->msg_len == 1) {\r\nwritel_relaxed(I2C_READ | I2C_NO_ACK, priv->regs + HIX5I2C_COM);\r\n} else if (priv->msg_len > 1) {\r\nwritel_relaxed(I2C_READ, priv->regs + HIX5I2C_COM);\r\n} else {\r\nhix5hd2_rw_handle_stop(priv);\r\n}\r\n}\r\nstatic void hix5hd2_write_handle(struct hix5hd2_i2c_priv *priv)\r\n{\r\nu8 data;\r\nif (priv->msg_len > 0) {\r\ndata = priv->msg->buf[priv->msg_idx++];\r\nwritel_relaxed(data, priv->regs + HIX5I2C_TXR);\r\nwritel_relaxed(I2C_WRITE, priv->regs + HIX5I2C_COM);\r\n} else {\r\nhix5hd2_rw_handle_stop(priv);\r\n}\r\n}\r\nstatic int hix5hd2_rw_preprocess(struct hix5hd2_i2c_priv *priv)\r\n{\r\nu8 data;\r\nif (priv->state == HIX5I2C_STAT_INIT) {\r\npriv->state = HIX5I2C_STAT_RW;\r\n} else if (priv->state == HIX5I2C_STAT_RW) {\r\nif (priv->msg->flags & I2C_M_RD) {\r\ndata = readl_relaxed(priv->regs + HIX5I2C_RXR);\r\npriv->msg->buf[priv->msg_idx++] = data;\r\n}\r\npriv->msg_len--;\r\n} else {\r\ndev_dbg(priv->dev, "%s: error: priv->state = %d, msg_len = %d\n",\r\n__func__, priv->state, priv->msg_len);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t hix5hd2_i2c_irq(int irqno, void *dev_id)\r\n{\r\nstruct hix5hd2_i2c_priv *priv = dev_id;\r\nu32 int_status;\r\nint ret;\r\nspin_lock(&priv->lock);\r\nint_status = hix5hd2_i2c_clr_pend_irq(priv);\r\nif (int_status & I2C_ARBITRATE_INTR) {\r\ndev_dbg(priv->dev, "ARB bus loss\n");\r\npriv->err = -EAGAIN;\r\npriv->state = HIX5I2C_STAT_RW_ERR;\r\ngoto stop;\r\n} else if (int_status & I2C_ACK_INTR) {\r\ndev_dbg(priv->dev, "No ACK from device\n");\r\npriv->err = -ENXIO;\r\npriv->state = HIX5I2C_STAT_RW_ERR;\r\ngoto stop;\r\n}\r\nif (int_status & I2C_OVER_INTR) {\r\nif (priv->msg_len > 0) {\r\nret = hix5hd2_rw_preprocess(priv);\r\nif (ret) {\r\npriv->err = ret;\r\npriv->state = HIX5I2C_STAT_RW_ERR;\r\ngoto stop;\r\n}\r\nif (priv->msg->flags & I2C_M_RD)\r\nhix5hd2_read_handle(priv);\r\nelse\r\nhix5hd2_write_handle(priv);\r\n} else {\r\nhix5hd2_rw_over(priv);\r\n}\r\n}\r\nstop:\r\nif ((priv->state == HIX5I2C_STAT_RW_SUCCESS &&\r\npriv->msg->len == priv->msg_idx) ||\r\n(priv->state == HIX5I2C_STAT_RW_ERR)) {\r\nhix5hd2_i2c_disable_irq(priv);\r\nhix5hd2_i2c_clr_pend_irq(priv);\r\ncomplete(&priv->msg_complete);\r\n}\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hix5hd2_i2c_message_start(struct hix5hd2_i2c_priv *priv, int stop)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nhix5hd2_i2c_clr_all_irq(priv);\r\nhix5hd2_i2c_enable_irq(priv);\r\nif (priv->msg->flags & I2C_M_RD)\r\nwritel_relaxed((priv->msg->addr << 1) | HIX5I2C_READ_OPERATION,\r\npriv->regs + HIX5I2C_TXR);\r\nelse\r\nwritel_relaxed(priv->msg->addr << 1,\r\npriv->regs + HIX5I2C_TXR);\r\nwritel_relaxed(I2C_WRITE | I2C_START, priv->regs + HIX5I2C_COM);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int hix5hd2_i2c_xfer_msg(struct hix5hd2_i2c_priv *priv,\r\nstruct i2c_msg *msgs, int stop)\r\n{\r\nunsigned long timeout;\r\nint ret;\r\npriv->msg = msgs;\r\npriv->msg_idx = 0;\r\npriv->msg_len = priv->msg->len;\r\npriv->stop = stop;\r\npriv->err = 0;\r\npriv->state = HIX5I2C_STAT_INIT;\r\nreinit_completion(&priv->msg_complete);\r\nhix5hd2_i2c_message_start(priv, stop);\r\ntimeout = wait_for_completion_timeout(&priv->msg_complete,\r\npriv->adap.timeout);\r\nif (timeout == 0) {\r\npriv->state = HIX5I2C_STAT_RW_ERR;\r\npriv->err = -ETIMEDOUT;\r\ndev_warn(priv->dev, "%s timeout=%d\n",\r\nmsgs->flags & I2C_M_RD ? "rx" : "tx",\r\npriv->adap.timeout);\r\n}\r\nret = priv->state;\r\nif (priv->state == HIX5I2C_STAT_RW_SUCCESS && stop)\r\nret = hix5hd2_i2c_wait_bus_idle(priv);\r\nif (ret < 0)\r\nhix5hd2_i2c_reset(priv);\r\nreturn priv->err;\r\n}\r\nstatic int hix5hd2_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct hix5hd2_i2c_priv *priv = i2c_get_adapdata(adap);\r\nint i, ret, stop;\r\npm_runtime_get_sync(priv->dev);\r\nfor (i = 0; i < num; i++, msgs++) {\r\nstop = (i == num - 1);\r\nret = hix5hd2_i2c_xfer_msg(priv, msgs, stop);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (i == num) {\r\nret = num;\r\n} else {\r\nif (i == 1)\r\nret = -EREMOTEIO;\r\nelse\r\nret = i;\r\ndev_warn(priv->dev, "xfer message failed\n");\r\n}\r\nout:\r\npm_runtime_mark_last_busy(priv->dev);\r\npm_runtime_put_autosuspend(priv->dev);\r\nreturn ret;\r\n}\r\nstatic u32 hix5hd2_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic int hix5hd2_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct hix5hd2_i2c_priv *priv;\r\nstruct resource *mem;\r\nunsigned int freq;\r\nint irq, ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(np, "clock-frequency", &freq)) {\r\npriv->freq = 100000;\r\n} else {\r\nif (freq > HIX5I2C_MAX_FREQ) {\r\npriv->freq = HIX5I2C_MAX_FREQ;\r\ndev_warn(priv->dev, "use max freq %d instead\n",\r\nHIX5I2C_MAX_FREQ);\r\n} else {\r\npriv->freq = freq;\r\n}\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(priv->regs))\r\nreturn PTR_ERR(priv->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev, "cannot find HS-I2C IRQ\n");\r\nreturn irq;\r\n}\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nclk_prepare_enable(priv->clk);\r\nstrlcpy(priv->adap.name, "hix5hd2-i2c", sizeof(priv->adap.name));\r\npriv->dev = &pdev->dev;\r\npriv->adap.owner = THIS_MODULE;\r\npriv->adap.algo = &hix5hd2_i2c_algorithm;\r\npriv->adap.retries = 3;\r\npriv->adap.dev.of_node = np;\r\npriv->adap.algo_data = priv;\r\npriv->adap.dev.parent = &pdev->dev;\r\ni2c_set_adapdata(&priv->adap, priv);\r\nplatform_set_drvdata(pdev, priv);\r\nspin_lock_init(&priv->lock);\r\ninit_completion(&priv->msg_complete);\r\nhix5hd2_i2c_init(priv);\r\nret = devm_request_irq(&pdev->dev, irq, hix5hd2_i2c_irq,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\ndev_name(&pdev->dev), priv);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot request HS-I2C IRQ %d\n", irq);\r\ngoto err_clk;\r\n}\r\npm_suspend_ignore_children(&pdev->dev, true);\r\npm_runtime_set_autosuspend_delay(priv->dev, MSEC_PER_SEC);\r\npm_runtime_use_autosuspend(priv->dev);\r\npm_runtime_set_active(priv->dev);\r\npm_runtime_enable(priv->dev);\r\nret = i2c_add_adapter(&priv->adap);\r\nif (ret < 0)\r\ngoto err_runtime;\r\nreturn ret;\r\nerr_runtime:\r\npm_runtime_disable(priv->dev);\r\npm_runtime_set_suspended(priv->dev);\r\nerr_clk:\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nstatic int hix5hd2_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct hix5hd2_i2c_priv *priv = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adap);\r\npm_runtime_disable(priv->dev);\r\npm_runtime_set_suspended(priv->dev);\r\nreturn 0;\r\n}\r\nstatic int hix5hd2_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct hix5hd2_i2c_priv *priv = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int hix5hd2_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct hix5hd2_i2c_priv *priv = platform_get_drvdata(pdev);\r\nclk_prepare_enable(priv->clk);\r\nhix5hd2_i2c_init(priv);\r\nreturn 0;\r\n}
