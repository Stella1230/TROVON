static int alt_hps2fpga_enable_show(struct fpga_bridge *bridge)\r\n{\r\nstruct altera_hps2fpga_data *priv = bridge->priv;\r\nreturn reset_control_status(priv->bridge_reset);\r\n}\r\nstatic int _alt_hps2fpga_enable_set(struct altera_hps2fpga_data *priv,\r\nbool enable)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nif (enable)\r\nret = reset_control_deassert(priv->bridge_reset);\r\nelse\r\nret = reset_control_assert(priv->bridge_reset);\r\nif (ret)\r\nreturn ret;\r\nif (priv->remap_mask) {\r\nspin_lock_irqsave(&l3_remap_lock, flags);\r\nl3_remap_shadow |= ALT_L3_REMAP_MPUZERO_MSK;\r\nif (enable)\r\nl3_remap_shadow |= priv->remap_mask;\r\nelse\r\nl3_remap_shadow &= ~priv->remap_mask;\r\nret = regmap_write(priv->l3reg, ALT_L3_REMAP_OFST,\r\nl3_remap_shadow);\r\nspin_unlock_irqrestore(&l3_remap_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int alt_hps2fpga_enable_set(struct fpga_bridge *bridge, bool enable)\r\n{\r\nreturn _alt_hps2fpga_enable_set(bridge->priv, enable);\r\n}\r\nstatic int alt_fpga_bridge_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct altera_hps2fpga_data *priv;\r\nconst struct of_device_id *of_id;\r\nu32 enable;\r\nint ret;\r\nof_id = of_match_device(altera_fpga_of_match, dev);\r\npriv = (struct altera_hps2fpga_data *)of_id->data;\r\npriv->bridge_reset = of_reset_control_get_by_index(dev->of_node, 0);\r\nif (IS_ERR(priv->bridge_reset)) {\r\ndev_err(dev, "Could not get %s reset control\n", priv->name);\r\nreturn PTR_ERR(priv->bridge_reset);\r\n}\r\nif (priv->remap_mask) {\r\npriv->l3reg = syscon_regmap_lookup_by_compatible("altr,l3regs");\r\nif (IS_ERR(priv->l3reg)) {\r\ndev_err(dev, "regmap for altr,l3regs lookup failed\n");\r\nreturn PTR_ERR(priv->l3reg);\r\n}\r\n}\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "no clock specified\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret) {\r\ndev_err(dev, "could not enable clock\n");\r\nreturn -EBUSY;\r\n}\r\nspin_lock_init(&l3_remap_lock);\r\nif (!of_property_read_u32(dev->of_node, "bridge-enable", &enable)) {\r\nif (enable > 1) {\r\ndev_warn(dev, "invalid bridge-enable %u > 1\n", enable);\r\n} else {\r\ndev_info(dev, "%s bridge\n",\r\n(enable ? "enabling" : "disabling"));\r\nret = _alt_hps2fpga_enable_set(priv, enable);\r\nif (ret) {\r\nfpga_bridge_unregister(&pdev->dev);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn fpga_bridge_register(dev, priv->name, &altera_hps2fpga_br_ops,\r\npriv);\r\n}\r\nstatic int alt_fpga_bridge_remove(struct platform_device *pdev)\r\n{\r\nstruct fpga_bridge *bridge = platform_get_drvdata(pdev);\r\nstruct altera_hps2fpga_data *priv = bridge->priv;\r\nfpga_bridge_unregister(&pdev->dev);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
