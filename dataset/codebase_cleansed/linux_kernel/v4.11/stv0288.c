static int stv0288_writeregI(struct stv0288_state *state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: writereg error (reg == 0x%02x, val == 0x%02x, ret == %i)\n",\r\n__func__, reg, data, ret);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic int stv0288_write(struct dvb_frontend *fe, const u8 buf[], int len)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nif (len != 2)\r\nreturn -EINVAL;\r\nreturn stv0288_writeregI(state, buf[0], buf[1]);\r\n}\r\nstatic u8 stv0288_readreg(struct stv0288_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = state->config->demod_address,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n}, {\r\n.addr = state->config->demod_address,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\ndprintk("%s: readreg error (reg == 0x%02x, ret == %i)\n",\r\n__func__, reg, ret);\r\nreturn b1[0];\r\n}\r\nstatic int stv0288_set_symbolrate(struct dvb_frontend *fe, u32 srate)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nunsigned int temp;\r\nunsigned char b[3];\r\nif ((srate < 1000000) || (srate > 45000000))\r\nreturn -EINVAL;\r\nstv0288_writeregI(state, 0x22, 0);\r\nstv0288_writeregI(state, 0x23, 0);\r\nstv0288_writeregI(state, 0x2b, 0xff);\r\nstv0288_writeregI(state, 0x2c, 0xf7);\r\ntemp = (unsigned int)srate / 1000;\r\ntemp = temp * 32768;\r\ntemp = temp / 25;\r\ntemp = temp / 125;\r\nb[0] = (unsigned char)((temp >> 12) & 0xff);\r\nb[1] = (unsigned char)((temp >> 4) & 0xff);\r\nb[2] = (unsigned char)((temp << 4) & 0xf0);\r\nstv0288_writeregI(state, 0x28, 0x80);\r\nstv0288_writeregI(state, 0x29, 0);\r\nstv0288_writeregI(state, 0x2a, 0);\r\nstv0288_writeregI(state, 0x28, b[0]);\r\nstv0288_writeregI(state, 0x29, b[1]);\r\nstv0288_writeregI(state, 0x2a, b[2]);\r\ndprintk("stv0288: stv0288_set_symbolrate\n");\r\nreturn 0;\r\n}\r\nstatic int stv0288_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *m)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nint i;\r\ndprintk("%s\n", __func__);\r\nstv0288_writeregI(state, 0x09, 0);\r\nmsleep(30);\r\nstv0288_writeregI(state, 0x05, 0x12);\r\nfor (i = 0; i < m->msg_len; i++) {\r\nif (stv0288_writeregI(state, 0x06, m->msg[i]))\r\nreturn -EREMOTEIO;\r\n}\r\nmsleep(m->msg_len*12);\r\nreturn 0;\r\n}\r\nstatic int stv0288_send_diseqc_burst(struct dvb_frontend *fe,\r\nenum fe_sec_mini_cmd burst)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (stv0288_writeregI(state, 0x05, 0x03))\r\nreturn -EREMOTEIO;\r\nif (stv0288_writeregI(state, 0x06, burst == SEC_MINI_A ? 0x00 : 0xff))\r\nreturn -EREMOTEIO;\r\nmsleep(15);\r\nif (stv0288_writeregI(state, 0x05, 0x12))\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int stv0288_set_tone(struct dvb_frontend *fe, enum fe_sec_tone_mode tone)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nif (stv0288_writeregI(state, 0x05, 0x10))\r\nreturn -EREMOTEIO;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nif (stv0288_writeregI(state, 0x05, 0x12))\r\nreturn -EREMOTEIO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0288_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage volt)\r\n{\r\ndprintk("%s: %s\n", __func__,\r\nvolt == SEC_VOLTAGE_13 ? "SEC_VOLTAGE_13" :\r\nvolt == SEC_VOLTAGE_18 ? "SEC_VOLTAGE_18" : "??");\r\nreturn 0;\r\n}\r\nstatic int stv0288_init(struct dvb_frontend *fe)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 reg;\r\nu8 val;\r\ndprintk("stv0288: init chip\n");\r\nstv0288_writeregI(state, 0x41, 0x04);\r\nmsleep(50);\r\nif (state->config->inittab == NULL) {\r\nfor (i = 0; !(stv0288_inittab[i] == 0xff &&\r\nstv0288_inittab[i + 1] == 0xff); i += 2)\r\nstv0288_writeregI(state, stv0288_inittab[i],\r\nstv0288_inittab[i + 1]);\r\n} else {\r\nfor (i = 0; ; i += 2) {\r\nreg = state->config->inittab[i];\r\nval = state->config->inittab[i+1];\r\nif (reg == 0xff && val == 0xff)\r\nbreak;\r\nstv0288_writeregI(state, reg, val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0288_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nu8 sync = stv0288_readreg(state, 0x24);\r\nif (sync == 255)\r\nsync = 0;\r\ndprintk("%s : FE_READ_STATUS : VSTATUS: 0x%02x\n", __func__, sync);\r\n*status = 0;\r\nif (sync & 0x80)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nif (sync & 0x10)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x08) {\r\n*status |= FE_HAS_LOCK;\r\ndprintk("stv0288 has locked\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0288_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nif (state->errmode != STATUS_BER)\r\nreturn 0;\r\n*ber = (stv0288_readreg(state, 0x26) << 8) |\r\nstv0288_readreg(state, 0x27);\r\ndprintk("stv0288_read_ber %d\n", *ber);\r\nreturn 0;\r\n}\r\nstatic int stv0288_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\ns32 signal = 0xffff - ((stv0288_readreg(state, 0x10) << 8));\r\nsignal = signal * 5 / 4;\r\n*strength = (signal > 0xffff) ? 0xffff : (signal < 0) ? 0 : signal;\r\ndprintk("stv0288_read_signal_strength %d\n", *strength);\r\nreturn 0;\r\n}\r\nstatic int stv0288_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nstv0288_writeregI(state, 0x41, 0x84);\r\nstate->initialised = 0;\r\nreturn 0;\r\n}\r\nstatic int stv0288_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\ns32 xsnr = 0xffff - ((stv0288_readreg(state, 0x2d) << 8)\r\n| stv0288_readreg(state, 0x2e));\r\nxsnr = 3 * (xsnr - 0xa100);\r\n*snr = (xsnr > 0xffff) ? 0xffff : (xsnr < 0) ? 0 : xsnr;\r\ndprintk("stv0288_read_snr %d\n", *snr);\r\nreturn 0;\r\n}\r\nstatic int stv0288_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nif (state->errmode != STATUS_BER)\r\nreturn 0;\r\n*ucblocks = (stv0288_readreg(state, 0x26) << 8) |\r\nstv0288_readreg(state, 0x27);\r\ndprintk("stv0288_read_ber %d\n", *ucblocks);\r\nreturn 0;\r\n}\r\nstatic int stv0288_set_property(struct dvb_frontend *fe, struct dtv_property *p)\r\n{\r\ndprintk("%s(..)\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int stv0288_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nchar tm;\r\nunsigned char tda[3];\r\nu8 reg, time_out = 0;\r\ndprintk("%s : FE_SET_FRONTEND\n", __func__);\r\nif (c->delivery_system != SYS_DVBS) {\r\ndprintk("%s: unsupported delivery system selected (%d)\n",\r\n__func__, c->delivery_system);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nudelay(10);\r\nstv0288_set_symbolrate(fe, c->symbol_rate);\r\nstv0288_writeregI(state, 0x15, 0xc5);\r\ntda[2] = 0x0;\r\nfor (tm = -9; tm < 7;) {\r\nreg = stv0288_readreg(state, 0x24);\r\nif (reg & 0x8)\r\nbreak;\r\nif (reg & 0x80) {\r\ntime_out++;\r\nif (time_out > 10)\r\nbreak;\r\ntda[2] += 40;\r\nif (tda[2] < 40)\r\ntm++;\r\n} else {\r\ntm++;\r\ntda[2] = 0;\r\ntime_out = 0;\r\n}\r\ntda[1] = (unsigned char)tm;\r\nstv0288_writeregI(state, 0x2b, tda[1]);\r\nstv0288_writeregI(state, 0x2c, tda[2]);\r\nmsleep(30);\r\n}\r\nstate->tuner_frequency = c->frequency;\r\nstate->fec_inner = FEC_AUTO;\r\nstate->symbol_rate = c->symbol_rate;\r\nreturn 0;\r\n}\r\nstatic int stv0288_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nif (enable)\r\nstv0288_writeregI(state, 0x01, 0xb5);\r\nelse\r\nstv0288_writeregI(state, 0x01, 0x35);\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic void stv0288_release(struct dvb_frontend *fe)\r\n{\r\nstruct stv0288_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *stv0288_attach(const struct stv0288_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct stv0288_state *state = NULL;\r\nint id;\r\nstate = kzalloc(sizeof(struct stv0288_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->initialised = 0;\r\nstate->tuner_frequency = 0;\r\nstate->symbol_rate = 0;\r\nstate->fec_inner = 0;\r\nstate->errmode = STATUS_BER;\r\nstv0288_writeregI(state, 0x41, 0x04);\r\nmsleep(200);\r\nid = stv0288_readreg(state, 0x00);\r\ndprintk("stv0288 id %x\n", id);\r\nif (id != 0x11)\r\ngoto error;\r\nmemcpy(&state->frontend.ops, &stv0288_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
