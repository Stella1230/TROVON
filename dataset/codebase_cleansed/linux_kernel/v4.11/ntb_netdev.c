static void ntb_netdev_event_handler(void *data, int link_is_up)\r\n{\r\nstruct net_device *ndev = data;\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nnetdev_dbg(ndev, "Event %x, Link %x\n", link_is_up,\r\nntb_transport_link_query(dev->qp));\r\nif (link_is_up) {\r\nif (ntb_transport_link_query(dev->qp))\r\nnetif_carrier_on(ndev);\r\n} else {\r\nnetif_carrier_off(ndev);\r\n}\r\n}\r\nstatic void ntb_netdev_rx_handler(struct ntb_transport_qp *qp, void *qp_data,\r\nvoid *data, int len)\r\n{\r\nstruct net_device *ndev = qp_data;\r\nstruct sk_buff *skb;\r\nint rc;\r\nskb = data;\r\nif (!skb)\r\nreturn;\r\nnetdev_dbg(ndev, "%s: %d byte payload received\n", __func__, len);\r\nif (len < 0) {\r\nndev->stats.rx_errors++;\r\nndev->stats.rx_length_errors++;\r\ngoto enqueue_again;\r\n}\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nskb->ip_summed = CHECKSUM_NONE;\r\nif (netif_rx(skb) == NET_RX_DROP) {\r\nndev->stats.rx_errors++;\r\nndev->stats.rx_dropped++;\r\n} else {\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += len;\r\n}\r\nskb = netdev_alloc_skb(ndev, ndev->mtu + ETH_HLEN);\r\nif (!skb) {\r\nndev->stats.rx_errors++;\r\nndev->stats.rx_frame_errors++;\r\nreturn;\r\n}\r\nenqueue_again:\r\nrc = ntb_transport_rx_enqueue(qp, skb, skb->data, ndev->mtu + ETH_HLEN);\r\nif (rc) {\r\ndev_kfree_skb(skb);\r\nndev->stats.rx_errors++;\r\nndev->stats.rx_fifo_errors++;\r\n}\r\n}\r\nstatic int __ntb_netdev_maybe_stop_tx(struct net_device *netdev,\r\nstruct ntb_transport_qp *qp, int size)\r\n{\r\nstruct ntb_netdev *dev = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nsmp_mb();\r\nif (likely(ntb_transport_tx_free_entry(qp) < size)) {\r\nmod_timer(&dev->tx_timer, jiffies + usecs_to_jiffies(tx_time));\r\nreturn -EBUSY;\r\n}\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic int ntb_netdev_maybe_stop_tx(struct net_device *ndev,\r\nstruct ntb_transport_qp *qp, int size)\r\n{\r\nif (netif_queue_stopped(ndev) ||\r\n(ntb_transport_tx_free_entry(qp) >= size))\r\nreturn 0;\r\nreturn __ntb_netdev_maybe_stop_tx(ndev, qp, size);\r\n}\r\nstatic void ntb_netdev_tx_handler(struct ntb_transport_qp *qp, void *qp_data,\r\nvoid *data, int len)\r\n{\r\nstruct net_device *ndev = qp_data;\r\nstruct sk_buff *skb;\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nskb = data;\r\nif (!skb || !ndev)\r\nreturn;\r\nif (len > 0) {\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += skb->len;\r\n} else {\r\nndev->stats.tx_errors++;\r\nndev->stats.tx_aborted_errors++;\r\n}\r\ndev_kfree_skb(skb);\r\nif (ntb_transport_tx_free_entry(dev->qp) >= tx_start) {\r\nsmp_mb();\r\nif (netif_queue_stopped(ndev))\r\nnetif_wake_queue(ndev);\r\n}\r\n}\r\nstatic netdev_tx_t ntb_netdev_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nint rc;\r\nntb_netdev_maybe_stop_tx(ndev, dev->qp, tx_stop);\r\nrc = ntb_transport_tx_enqueue(dev->qp, skb, skb->data, skb->len);\r\nif (rc)\r\ngoto err;\r\nntb_netdev_maybe_stop_tx(ndev, dev->qp, tx_stop);\r\nreturn NETDEV_TX_OK;\r\nerr:\r\nndev->stats.tx_dropped++;\r\nndev->stats.tx_errors++;\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic void ntb_netdev_tx_timer(unsigned long data)\r\n{\r\nstruct net_device *ndev = (struct net_device *)data;\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nif (ntb_transport_tx_free_entry(dev->qp) < tx_stop) {\r\nmod_timer(&dev->tx_timer, jiffies + msecs_to_jiffies(tx_time));\r\n} else {\r\nsmp_mb();\r\nif (netif_queue_stopped(ndev))\r\nnetif_wake_queue(ndev);\r\n}\r\n}\r\nstatic int ntb_netdev_open(struct net_device *ndev)\r\n{\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nstruct sk_buff *skb;\r\nint rc, i, len;\r\nfor (i = 0; i < NTB_RXQ_SIZE; i++) {\r\nskb = netdev_alloc_skb(ndev, ndev->mtu + ETH_HLEN);\r\nif (!skb) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nrc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,\r\nndev->mtu + ETH_HLEN);\r\nif (rc) {\r\ndev_kfree_skb(skb);\r\ngoto err;\r\n}\r\n}\r\nsetup_timer(&dev->tx_timer, ntb_netdev_tx_timer, (unsigned long)ndev);\r\nnetif_carrier_off(ndev);\r\nntb_transport_link_up(dev->qp);\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\nerr:\r\nwhile ((skb = ntb_transport_rx_remove(dev->qp, &len)))\r\ndev_kfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic int ntb_netdev_close(struct net_device *ndev)\r\n{\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nstruct sk_buff *skb;\r\nint len;\r\nntb_transport_link_down(dev->qp);\r\nwhile ((skb = ntb_transport_rx_remove(dev->qp, &len)))\r\ndev_kfree_skb(skb);\r\ndel_timer_sync(&dev->tx_timer);\r\nreturn 0;\r\n}\r\nstatic int ntb_netdev_change_mtu(struct net_device *ndev, int new_mtu)\r\n{\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nstruct sk_buff *skb;\r\nint len, rc;\r\nif (new_mtu > ntb_transport_max_size(dev->qp) - ETH_HLEN)\r\nreturn -EINVAL;\r\nif (!netif_running(ndev)) {\r\nndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nntb_transport_link_down(dev->qp);\r\nif (ndev->mtu < new_mtu) {\r\nint i;\r\nfor (i = 0; (skb = ntb_transport_rx_remove(dev->qp, &len)); i++)\r\ndev_kfree_skb(skb);\r\nfor (; i; i--) {\r\nskb = netdev_alloc_skb(ndev, new_mtu + ETH_HLEN);\r\nif (!skb) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nrc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,\r\nnew_mtu + ETH_HLEN);\r\nif (rc) {\r\ndev_kfree_skb(skb);\r\ngoto err;\r\n}\r\n}\r\n}\r\nndev->mtu = new_mtu;\r\nntb_transport_link_up(dev->qp);\r\nreturn 0;\r\nerr:\r\nntb_transport_link_down(dev->qp);\r\nwhile ((skb = ntb_transport_rx_remove(dev->qp, &len)))\r\ndev_kfree_skb(skb);\r\nnetdev_err(ndev, "Error changing MTU, device inoperable\n");\r\nreturn rc;\r\n}\r\nstatic void ntb_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ntb_netdev *dev = netdev_priv(ndev);\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nstrlcpy(info->version, NTB_NETDEV_VER, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(dev->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int ntb_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->supported = SUPPORTED_Backplane;\r\ncmd->advertising = ADVERTISED_Backplane;\r\nethtool_cmd_speed_set(cmd, SPEED_UNKNOWN);\r\ncmd->duplex = DUPLEX_FULL;\r\ncmd->port = PORT_OTHER;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_DUMMY1;\r\ncmd->autoneg = AUTONEG_ENABLE;\r\ncmd->maxtxpkt = 0;\r\ncmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic int ntb_netdev_probe(struct device *client_dev)\r\n{\r\nstruct ntb_dev *ntb;\r\nstruct net_device *ndev;\r\nstruct pci_dev *pdev;\r\nstruct ntb_netdev *dev;\r\nint rc;\r\nntb = dev_ntb(client_dev->parent);\r\npdev = ntb->pdev;\r\nif (!pdev)\r\nreturn -ENODEV;\r\nndev = alloc_etherdev(sizeof(*dev));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\ndev = netdev_priv(ndev);\r\ndev->ndev = ndev;\r\ndev->pdev = pdev;\r\nndev->features = NETIF_F_HIGHDMA;\r\nndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\r\nndev->hw_features = ndev->features;\r\nndev->watchdog_timeo = msecs_to_jiffies(NTB_TX_TIMEOUT_MS);\r\nrandom_ether_addr(ndev->perm_addr);\r\nmemcpy(ndev->dev_addr, ndev->perm_addr, ndev->addr_len);\r\nndev->netdev_ops = &ntb_netdev_ops;\r\nndev->ethtool_ops = &ntb_ethtool_ops;\r\nndev->min_mtu = 0;\r\nndev->max_mtu = ETH_MAX_MTU;\r\ndev->qp = ntb_transport_create_queue(ndev, client_dev,\r\n&ntb_netdev_handlers);\r\nif (!dev->qp) {\r\nrc = -EIO;\r\ngoto err;\r\n}\r\nndev->mtu = ntb_transport_max_size(dev->qp) - ETH_HLEN;\r\nrc = register_netdev(ndev);\r\nif (rc)\r\ngoto err1;\r\nlist_add(&dev->list, &dev_list);\r\ndev_info(&pdev->dev, "%s created\n", ndev->name);\r\nreturn 0;\r\nerr1:\r\nntb_transport_free_queue(dev->qp);\r\nerr:\r\nfree_netdev(ndev);\r\nreturn rc;\r\n}\r\nstatic void ntb_netdev_remove(struct device *client_dev)\r\n{\r\nstruct ntb_dev *ntb;\r\nstruct net_device *ndev;\r\nstruct pci_dev *pdev;\r\nstruct ntb_netdev *dev;\r\nbool found = false;\r\nntb = dev_ntb(client_dev->parent);\r\npdev = ntb->pdev;\r\nlist_for_each_entry(dev, &dev_list, list) {\r\nif (dev->pdev == pdev) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn;\r\nlist_del(&dev->list);\r\nndev = dev->ndev;\r\nunregister_netdev(ndev);\r\nntb_transport_free_queue(dev->qp);\r\nfree_netdev(ndev);\r\n}\r\nstatic int __init ntb_netdev_init_module(void)\r\n{\r\nint rc;\r\nrc = ntb_transport_register_client_dev(KBUILD_MODNAME);\r\nif (rc)\r\nreturn rc;\r\nreturn ntb_transport_register_client(&ntb_netdev_client);\r\n}\r\nstatic void __exit ntb_netdev_exit_module(void)\r\n{\r\nntb_transport_unregister_client(&ntb_netdev_client);\r\nntb_transport_unregister_client_dev(KBUILD_MODNAME);\r\n}
