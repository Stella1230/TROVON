static inline unsigned int hinfc_read(struct hinfc_host *host, unsigned int reg)\r\n{\r\nreturn readl(host->iobase + reg);\r\n}\r\nstatic inline void hinfc_write(struct hinfc_host *host, unsigned int value,\r\nunsigned int reg)\r\n{\r\nwritel(value, host->iobase + reg);\r\n}\r\nstatic void wait_controller_finished(struct hinfc_host *host)\r\n{\r\nunsigned long timeout = jiffies + HINFC504_NFC_TIMEOUT;\r\nint val;\r\nwhile (time_before(jiffies, timeout)) {\r\nval = hinfc_read(host, HINFC504_STATUS);\r\nif (host->command == NAND_CMD_ERASE2) {\r\nwhile (!(val & HINFC504_READY)) {\r\nusleep_range(500, 1000);\r\nval = hinfc_read(host, HINFC504_STATUS);\r\n}\r\nreturn;\r\n}\r\nif (val & HINFC504_READY)\r\nreturn;\r\n}\r\ndev_err(host->dev, "Wait NAND controller exec cmd timeout.\n");\r\n}\r\nstatic void hisi_nfc_dma_transfer(struct hinfc_host *host, int todev)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nunsigned long val;\r\nint ret;\r\nhinfc_write(host, host->dma_buffer, HINFC504_DMA_ADDR_DATA);\r\nhinfc_write(host, host->dma_oob, HINFC504_DMA_ADDR_OOB);\r\nif (chip->ecc.mode == NAND_ECC_NONE) {\r\nhinfc_write(host, ((mtd->oobsize & HINFC504_DMA_LEN_OOB_MASK)\r\n<< HINFC504_DMA_LEN_OOB_SHIFT), HINFC504_DMA_LEN);\r\nhinfc_write(host, HINFC504_DMA_PARA_DATA_RW_EN\r\n| HINFC504_DMA_PARA_OOB_RW_EN, HINFC504_DMA_PARA);\r\n} else {\r\nif (host->command == NAND_CMD_READOOB)\r\nhinfc_write(host, HINFC504_DMA_PARA_OOB_RW_EN\r\n| HINFC504_DMA_PARA_OOB_EDC_EN\r\n| HINFC504_DMA_PARA_OOB_ECC_EN, HINFC504_DMA_PARA);\r\nelse\r\nhinfc_write(host, HINFC504_DMA_PARA_DATA_RW_EN\r\n| HINFC504_DMA_PARA_OOB_RW_EN\r\n| HINFC504_DMA_PARA_DATA_EDC_EN\r\n| HINFC504_DMA_PARA_OOB_EDC_EN\r\n| HINFC504_DMA_PARA_DATA_ECC_EN\r\n| HINFC504_DMA_PARA_OOB_ECC_EN, HINFC504_DMA_PARA);\r\n}\r\nval = (HINFC504_DMA_CTRL_DMA_START | HINFC504_DMA_CTRL_BURST4_EN\r\n| HINFC504_DMA_CTRL_BURST8_EN | HINFC504_DMA_CTRL_BURST16_EN\r\n| HINFC504_DMA_CTRL_DATA_AREA_EN | HINFC504_DMA_CTRL_OOB_AREA_EN\r\n| ((host->addr_cycle == 4 ? 1 : 0)\r\n<< HINFC504_DMA_CTRL_ADDR_NUM_SHIFT)\r\n| ((host->chipselect & HINFC504_DMA_CTRL_CS_MASK)\r\n<< HINFC504_DMA_CTRL_CS_SHIFT));\r\nif (todev)\r\nval |= HINFC504_DMA_CTRL_WE;\r\ninit_completion(&host->cmd_complete);\r\nhinfc_write(host, val, HINFC504_DMA_CTRL);\r\nret = wait_for_completion_timeout(&host->cmd_complete,\r\nHINFC504_NFC_DMA_TIMEOUT);\r\nif (!ret) {\r\ndev_err(host->dev, "DMA operation(irq) timeout!\n");\r\nval = hinfc_read(host, HINFC504_DMA_CTRL);\r\nif (!(val & HINFC504_DMA_CTRL_DMA_START))\r\ndev_err(host->dev, "DMA is already done but without irq ACK!\n");\r\nelse\r\ndev_err(host->dev, "DMA is really timeout!\n");\r\n}\r\n}\r\nstatic int hisi_nfc_send_cmd_pageprog(struct hinfc_host *host)\r\n{\r\nhost->addr_value[0] &= 0xffff0000;\r\nhinfc_write(host, host->addr_value[0], HINFC504_ADDRL);\r\nhinfc_write(host, host->addr_value[1], HINFC504_ADDRH);\r\nhinfc_write(host, NAND_CMD_PAGEPROG << 8 | NAND_CMD_SEQIN,\r\nHINFC504_CMD);\r\nhisi_nfc_dma_transfer(host, 1);\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_send_cmd_readstart(struct hinfc_host *host)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(&host->chip);\r\nif ((host->addr_value[0] == host->cache_addr_value[0]) &&\r\n(host->addr_value[1] == host->cache_addr_value[1]))\r\nreturn 0;\r\nhost->addr_value[0] &= 0xffff0000;\r\nhinfc_write(host, host->addr_value[0], HINFC504_ADDRL);\r\nhinfc_write(host, host->addr_value[1], HINFC504_ADDRH);\r\nhinfc_write(host, NAND_CMD_READSTART << 8 | NAND_CMD_READ0,\r\nHINFC504_CMD);\r\nhinfc_write(host, 0, HINFC504_LOG_READ_ADDR);\r\nhinfc_write(host, mtd->writesize + mtd->oobsize,\r\nHINFC504_LOG_READ_LEN);\r\nhisi_nfc_dma_transfer(host, 0);\r\nhost->cache_addr_value[0] = host->addr_value[0];\r\nhost->cache_addr_value[1] = host->addr_value[1];\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_send_cmd_erase(struct hinfc_host *host)\r\n{\r\nhinfc_write(host, host->addr_value[0], HINFC504_ADDRL);\r\nhinfc_write(host, (NAND_CMD_ERASE2 << 8) | NAND_CMD_ERASE1,\r\nHINFC504_CMD);\r\nhinfc_write(host, HINFC504_OP_WAIT_READY_EN\r\n| HINFC504_OP_CMD2_EN\r\n| HINFC504_OP_CMD1_EN\r\n| HINFC504_OP_ADDR_EN\r\n| ((host->chipselect & HINFC504_OP_NF_CS_MASK)\r\n<< HINFC504_OP_NF_CS_SHIFT)\r\n| ((host->addr_cycle & HINFC504_OP_ADDR_CYCLE_MASK)\r\n<< HINFC504_OP_ADDR_CYCLE_SHIFT),\r\nHINFC504_OP);\r\nwait_controller_finished(host);\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_send_cmd_readid(struct hinfc_host *host)\r\n{\r\nhinfc_write(host, HINFC504_NANDINFO_LEN, HINFC504_DATA_NUM);\r\nhinfc_write(host, NAND_CMD_READID, HINFC504_CMD);\r\nhinfc_write(host, 0, HINFC504_ADDRL);\r\nhinfc_write(host, HINFC504_OP_CMD1_EN | HINFC504_OP_ADDR_EN\r\n| HINFC504_OP_READ_DATA_EN\r\n| ((host->chipselect & HINFC504_OP_NF_CS_MASK)\r\n<< HINFC504_OP_NF_CS_SHIFT)\r\n| 1 << HINFC504_OP_ADDR_CYCLE_SHIFT, HINFC504_OP);\r\nwait_controller_finished(host);\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_send_cmd_status(struct hinfc_host *host)\r\n{\r\nhinfc_write(host, HINFC504_NANDINFO_LEN, HINFC504_DATA_NUM);\r\nhinfc_write(host, NAND_CMD_STATUS, HINFC504_CMD);\r\nhinfc_write(host, HINFC504_OP_CMD1_EN\r\n| HINFC504_OP_READ_DATA_EN\r\n| ((host->chipselect & HINFC504_OP_NF_CS_MASK)\r\n<< HINFC504_OP_NF_CS_SHIFT),\r\nHINFC504_OP);\r\nwait_controller_finished(host);\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_send_cmd_reset(struct hinfc_host *host, int chipselect)\r\n{\r\nhinfc_write(host, NAND_CMD_RESET, HINFC504_CMD);\r\nhinfc_write(host, HINFC504_OP_CMD1_EN\r\n| ((chipselect & HINFC504_OP_NF_CS_MASK)\r\n<< HINFC504_OP_NF_CS_SHIFT)\r\n| HINFC504_OP_WAIT_READY_EN,\r\nHINFC504_OP);\r\nwait_controller_finished(host);\r\nreturn 0;\r\n}\r\nstatic void hisi_nfc_select_chip(struct mtd_info *mtd, int chipselect)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nif (chipselect < 0)\r\nreturn;\r\nhost->chipselect = chipselect;\r\n}\r\nstatic uint8_t hisi_nfc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nif (host->command == NAND_CMD_STATUS)\r\nreturn *(uint8_t *)(host->mmio);\r\nhost->offset++;\r\nif (host->command == NAND_CMD_READID)\r\nreturn *(uint8_t *)(host->mmio + host->offset - 1);\r\nreturn *(uint8_t *)(host->buffer + host->offset - 1);\r\n}\r\nstatic u16 hisi_nfc_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nhost->offset += 2;\r\nreturn *(u16 *)(host->buffer + host->offset - 2);\r\n}\r\nstatic void\r\nhisi_nfc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nmemcpy(host->buffer + host->offset, buf, len);\r\nhost->offset += len;\r\n}\r\nstatic void hisi_nfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nmemcpy(buf, host->buffer + host->offset, len);\r\nhost->offset += len;\r\n}\r\nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nunsigned int command = host->command;\r\nhost->addr_cycle = 0;\r\nhost->addr_value[0] = 0;\r\nhost->addr_value[1] = 0;\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16 &&\r\n!nand_opcode_8bits(command))\r\ncolumn >>= 1;\r\nhost->addr_value[0] = column & 0xffff;\r\nhost->addr_cycle = 2;\r\n}\r\nif (page_addr != -1) {\r\nhost->addr_value[0] |= (page_addr & 0xffff)\r\n<< (host->addr_cycle * 8);\r\nhost->addr_cycle += 2;\r\nif (chip->chipsize > (128 << 20)) {\r\nhost->addr_cycle += 1;\r\nif (host->command == NAND_CMD_ERASE1)\r\nhost->addr_value[0] |= ((page_addr >> 16) & 0xff) << 16;\r\nelse\r\nhost->addr_value[1] |= ((page_addr >> 16) & 0xff);\r\n}\r\n}\r\n}\r\nstatic void hisi_nfc_cmdfunc(struct mtd_info *mtd, unsigned command, int column,\r\nint page_addr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nint is_cache_invalid = 1;\r\nunsigned int flag = 0;\r\nhost->command = command;\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\nif (command == NAND_CMD_READ0)\r\nhost->offset = column;\r\nelse\r\nhost->offset = column + mtd->writesize;\r\nis_cache_invalid = 0;\r\nset_addr(mtd, column, page_addr);\r\nhisi_nfc_send_cmd_readstart(host);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\nhost->offset = column;\r\nset_addr(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\nset_addr(mtd, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nhisi_nfc_send_cmd_pageprog(host);\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nhisi_nfc_send_cmd_erase(host);\r\nbreak;\r\ncase NAND_CMD_READID:\r\nhost->offset = column;\r\nmemset(host->mmio, 0, 0x10);\r\nhisi_nfc_send_cmd_readid(host);\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\nflag = hinfc_read(host, HINFC504_CON);\r\nif (chip->ecc.mode == NAND_ECC_HW)\r\nhinfc_write(host,\r\nflag & ~(HINFC504_CON_ECCTYPE_MASK <<\r\nHINFC504_CON_ECCTYPE_SHIFT), HINFC504_CON);\r\nhost->offset = 0;\r\nmemset(host->mmio, 0, 0x10);\r\nhisi_nfc_send_cmd_status(host);\r\nhinfc_write(host, flag, HINFC504_CON);\r\nbreak;\r\ncase NAND_CMD_RESET:\r\nhisi_nfc_send_cmd_reset(host, host->chipselect);\r\nbreak;\r\ndefault:\r\ndev_err(host->dev, "Error: unsupported cmd(cmd=%x, col=%x, page=%x)\n",\r\ncommand, column, page_addr);\r\n}\r\nif (is_cache_invalid) {\r\nhost->cache_addr_value[0] = ~0;\r\nhost->cache_addr_value[1] = ~0;\r\n}\r\n}\r\nstatic irqreturn_t hinfc_irq_handle(int irq, void *devid)\r\n{\r\nstruct hinfc_host *host = devid;\r\nunsigned int flag;\r\nflag = hinfc_read(host, HINFC504_INTS);\r\nhost->irq_status |= flag;\r\nif (flag & HINFC504_INTS_DMA) {\r\nhinfc_write(host, HINFC504_INTCLR_DMA, HINFC504_INTCLR);\r\ncomplete(&host->cmd_complete);\r\n} else if (flag & HINFC504_INTS_CE) {\r\nhinfc_write(host, HINFC504_INTCLR_CE, HINFC504_INTCLR);\r\n} else if (flag & HINFC504_INTS_UE) {\r\nhinfc_write(host, HINFC504_INTCLR_UE, HINFC504_INTCLR);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hisi_nand_read_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required, int page)\r\n{\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nint max_bitflips = 0, stat = 0, stat_max = 0, status_ecc;\r\nint stat_1, stat_2;\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (host->irq_status & HINFC504_INTS_UE) {\r\nmtd->ecc_stats.failed++;\r\n} else if (host->irq_status & HINFC504_INTS_CE) {\r\nswitch (chip->ecc.strength) {\r\ncase 16:\r\nstatus_ecc = hinfc_read(host, HINFC504_ECC_STATUS) >>\r\nHINFC504_ECC_16_BIT_SHIFT & 0x0fff;\r\nstat_2 = status_ecc & 0x3f;\r\nstat_1 = status_ecc >> 6 & 0x3f;\r\nstat = stat_1 + stat_2;\r\nstat_max = max_t(int, stat_1, stat_2);\r\n}\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(int, max_bitflips, stat_max);\r\n}\r\nhost->irq_status = 0;\r\nreturn max_bitflips;\r\n}\r\nstatic int hisi_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nstruct hinfc_host *host = nand_get_controller_data(chip);\r\nchip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (host->irq_status & HINFC504_INTS_UE) {\r\nhost->irq_status = 0;\r\nreturn -EBADMSG;\r\n}\r\nhost->irq_status = 0;\r\nreturn 0;\r\n}\r\nstatic int hisi_nand_write_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nif (oob_required)\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic void hisi_nfc_host_init(struct hinfc_host *host)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nunsigned int flag = 0;\r\nhost->version = hinfc_read(host, HINFC_VERSION);\r\nhost->addr_cycle = 0;\r\nhost->addr_value[0] = 0;\r\nhost->addr_value[1] = 0;\r\nhost->cache_addr_value[0] = ~0;\r\nhost->cache_addr_value[1] = ~0;\r\nhost->chipselect = 0;\r\nflag = HINFC504_CON_OP_MODE_NORMAL | HINFC504_CON_READY_BUSY_SEL\r\n| ((0x001 & HINFC504_CON_PAGESIZE_MASK)\r\n<< HINFC504_CON_PAGEISZE_SHIFT)\r\n| ((0x0 & HINFC504_CON_ECCTYPE_MASK)\r\n<< HINFC504_CON_ECCTYPE_SHIFT)\r\n| ((chip->options & NAND_BUSWIDTH_16) ?\r\nHINFC504_CON_BUS_WIDTH : 0);\r\nhinfc_write(host, flag, HINFC504_CON);\r\nmemset(host->mmio, 0xff, HINFC504_BUFFER_BASE_ADDRESS_LEN);\r\nhinfc_write(host, SET_HINFC504_PWIDTH(HINFC504_W_LATCH,\r\nHINFC504_R_LATCH, HINFC504_RW_LATCH), HINFC504_PWIDTH);\r\nhinfc_write(host, HINFC504_INTEN_DMA, HINFC504_INTEN);\r\n}\r\nstatic int hisi_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int hisi_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nif (section)\r\nreturn -ERANGE;\r\noobregion->offset = 2;\r\noobregion->length = 6;\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_ecc_probe(struct hinfc_host *host)\r\n{\r\nunsigned int flag;\r\nint size, strength, ecc_bits;\r\nstruct device *dev = host->dev;\r\nstruct nand_chip *chip = &host->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nsize = chip->ecc.size;\r\nstrength = chip->ecc.strength;\r\nif (size != 1024) {\r\ndev_err(dev, "error ecc size: %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nif ((size == 1024) && ((strength != 8) && (strength != 16) &&\r\n(strength != 24) && (strength != 40))) {\r\ndev_err(dev, "ecc size and strength do not match\n");\r\nreturn -EINVAL;\r\n}\r\nchip->ecc.size = size;\r\nchip->ecc.strength = strength;\r\nchip->ecc.read_page = hisi_nand_read_page_hwecc;\r\nchip->ecc.read_oob = hisi_nand_read_oob;\r\nchip->ecc.write_page = hisi_nand_write_page_hwecc;\r\nswitch (chip->ecc.strength) {\r\ncase 16:\r\necc_bits = 6;\r\nif (mtd->writesize == 2048)\r\nmtd_set_ooblayout(mtd, &hisi_ooblayout_ops);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "not support strength: %d\n", chip->ecc.strength);\r\nreturn -EINVAL;\r\n}\r\nflag = hinfc_read(host, HINFC504_CON);\r\nflag |= ((ecc_bits & HINFC504_CON_ECCTYPE_MASK)\r\n<< HINFC504_CON_ECCTYPE_SHIFT);\r\nhinfc_write(host, flag, HINFC504_CON);\r\nflag = hinfc_read(host, HINFC504_INTEN) & 0xfff;\r\nhinfc_write(host, flag | HINFC504_INTEN_UE | HINFC504_INTEN_CE,\r\nHINFC504_INTEN);\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0, irq, flag, max_chips = HINFC504_MAX_CHIP;\r\nstruct device *dev = &pdev->dev;\r\nstruct hinfc_host *host;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nstruct resource *res;\r\nstruct device_node *np = dev->of_node;\r\nhost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->dev = dev;\r\nplatform_set_drvdata(pdev, host);\r\nchip = &host->chip;\r\nmtd = nand_to_mtd(chip);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "no IRQ resource defined\n");\r\nret = -ENXIO;\r\ngoto err_res;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(host->iobase)) {\r\nret = PTR_ERR(host->iobase);\r\ngoto err_res;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nhost->mmio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(host->mmio)) {\r\nret = PTR_ERR(host->mmio);\r\ndev_err(dev, "devm_ioremap_resource[1] fail\n");\r\ngoto err_res;\r\n}\r\nmtd->name = "hisi_nand";\r\nmtd->dev.parent = &pdev->dev;\r\nnand_set_controller_data(chip, host);\r\nnand_set_flash_node(chip, np);\r\nchip->cmdfunc = hisi_nfc_cmdfunc;\r\nchip->select_chip = hisi_nfc_select_chip;\r\nchip->read_byte = hisi_nfc_read_byte;\r\nchip->read_word = hisi_nfc_read_word;\r\nchip->write_buf = hisi_nfc_write_buf;\r\nchip->read_buf = hisi_nfc_read_buf;\r\nchip->chip_delay = HINFC504_CHIP_DELAY;\r\nhisi_nfc_host_init(host);\r\nret = devm_request_irq(dev, irq, hinfc_irq_handle, 0x0, "nandc", host);\r\nif (ret) {\r\ndev_err(dev, "failed to request IRQ\n");\r\ngoto err_res;\r\n}\r\nret = nand_scan_ident(mtd, max_chips, NULL);\r\nif (ret)\r\ngoto err_res;\r\nhost->buffer = dmam_alloc_coherent(dev, mtd->writesize + mtd->oobsize,\r\n&host->dma_buffer, GFP_KERNEL);\r\nif (!host->buffer) {\r\nret = -ENOMEM;\r\ngoto err_res;\r\n}\r\nhost->dma_oob = host->dma_buffer + mtd->writesize;\r\nmemset(host->buffer, 0xff, mtd->writesize + mtd->oobsize);\r\nflag = hinfc_read(host, HINFC504_CON);\r\nflag &= ~(HINFC504_CON_PAGESIZE_MASK << HINFC504_CON_PAGEISZE_SHIFT);\r\nswitch (mtd->writesize) {\r\ncase 2048:\r\nflag |= (0x001 << HINFC504_CON_PAGEISZE_SHIFT); break;\r\ndefault:\r\ndev_err(dev, "NON-2KB page size nand flash\n");\r\nret = -EINVAL;\r\ngoto err_res;\r\n}\r\nhinfc_write(host, flag, HINFC504_CON);\r\nif (chip->ecc.mode == NAND_ECC_HW)\r\nhisi_nfc_ecc_probe(host);\r\nret = nand_scan_tail(mtd);\r\nif (ret) {\r\ndev_err(dev, "nand_scan_tail failed: %d\n", ret);\r\ngoto err_res;\r\n}\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret) {\r\ndev_err(dev, "Err MTD partition=%d\n", ret);\r\ngoto err_mtd;\r\n}\r\nreturn 0;\r\nerr_mtd:\r\nnand_release(mtd);\r\nerr_res:\r\nreturn ret;\r\n}\r\nstatic int hisi_nfc_remove(struct platform_device *pdev)\r\n{\r\nstruct hinfc_host *host = platform_get_drvdata(pdev);\r\nstruct mtd_info *mtd = nand_to_mtd(&host->chip);\r\nnand_release(mtd);\r\nreturn 0;\r\n}\r\nstatic int hisi_nfc_suspend(struct device *dev)\r\n{\r\nstruct hinfc_host *host = dev_get_drvdata(dev);\r\nunsigned long timeout = jiffies + HINFC504_NFC_PM_TIMEOUT;\r\nwhile (time_before(jiffies, timeout)) {\r\nif (((hinfc_read(host, HINFC504_STATUS) & 0x1) == 0x0) &&\r\n(hinfc_read(host, HINFC504_DMA_CTRL) &\r\nHINFC504_DMA_CTRL_DMA_START)) {\r\ncond_resched();\r\nreturn 0;\r\n}\r\n}\r\ndev_err(host->dev, "nand controller suspend timeout.\n");\r\nreturn -EAGAIN;\r\n}\r\nstatic int hisi_nfc_resume(struct device *dev)\r\n{\r\nint cs;\r\nstruct hinfc_host *host = dev_get_drvdata(dev);\r\nstruct nand_chip *chip = &host->chip;\r\nfor (cs = 0; cs < chip->numchips; cs++)\r\nhisi_nfc_send_cmd_reset(host, cs);\r\nhinfc_write(host, SET_HINFC504_PWIDTH(HINFC504_W_LATCH,\r\nHINFC504_R_LATCH, HINFC504_RW_LATCH), HINFC504_PWIDTH);\r\nreturn 0;\r\n}
