static\r\nstruct hdmi_audio_data *card_drvdata_substream(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = ss->private_data;\r\nreturn snd_soc_card_get_drvdata(rtd->card);\r\n}\r\nstatic void hdmi_dai_abort(struct device *dev)\r\n{\r\nstruct hdmi_audio_data *ad = dev_get_drvdata(dev);\r\nmutex_lock(&ad->current_stream_lock);\r\nif (ad->current_stream && ad->current_stream->runtime &&\r\nsnd_pcm_running(ad->current_stream)) {\r\ndev_err(dev, "HDMI display disabled, aborting playback\n");\r\nsnd_pcm_stream_lock_irq(ad->current_stream);\r\nsnd_pcm_stop(ad->current_stream, SNDRV_PCM_STATE_DISCONNECTED);\r\nsnd_pcm_stream_unlock_irq(ad->current_stream);\r\n}\r\nmutex_unlock(&ad->current_stream_lock);\r\n}\r\nstatic int hdmi_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\r\nint ret;\r\nret = snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 128);\r\nif (ret < 0) {\r\ndev_err(dai->dev, "Could not apply period constraint: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 128);\r\nif (ret < 0) {\r\ndev_err(dai->dev, "Could not apply buffer constraint: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsnd_soc_dai_set_dma_data(dai, substream, &ad->dma_data);\r\nmutex_lock(&ad->current_stream_lock);\r\nad->current_stream = substream;\r\nmutex_unlock(&ad->current_stream_lock);\r\nret = ad->ops->audio_startup(ad->dssdev, hdmi_dai_abort);\r\nif (ret) {\r\nmutex_lock(&ad->current_stream_lock);\r\nad->current_stream = NULL;\r\nmutex_unlock(&ad->current_stream_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int hdmi_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\r\nstruct snd_aes_iec958 *iec = &ad->iec;\r\nstruct snd_cea_861_aud_if *cea = &ad->cea;\r\nWARN_ON(ad->current_stream != substream);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nad->dma_data.maxburst = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nad->dma_data.maxburst = 32;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "format not supported!\n");\r\nreturn -EINVAL;\r\n}\r\nad->dss_audio.iec = iec;\r\nad->dss_audio.cea = cea;\r\nmemset(iec->status, 0, sizeof(iec->status));\r\niec->status[0] &= ~IEC958_AES0_PROFESSIONAL;\r\niec->status[0] &= ~IEC958_AES0_NONAUDIO;\r\niec->status[0] |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\niec->status[0] |= IEC958_AES0_CON_EMPHASIS_NONE;\r\niec->status[1] = IEC958_AES1_CON_GENERAL;\r\niec->status[2] |= IEC958_AES2_CON_SOURCE_UNSPEC;\r\niec->status[2] |= IEC958_AES2_CON_CHANNEL_UNSPEC;\r\nswitch (params_rate(params)) {\r\ncase 32000:\r\niec->status[3] |= IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ncase 44100:\r\niec->status[3] |= IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\niec->status[3] |= IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 88200:\r\niec->status[3] |= IEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 96000:\r\niec->status[3] |= IEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 176400:\r\niec->status[3] |= IEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 192000:\r\niec->status[3] |= IEC958_AES3_CON_FS_192000;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "rate not supported!\n");\r\nreturn -EINVAL;\r\n}\r\niec->status[3] |= IEC958_AES3_CON_CLOCK_1000PPM;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\niec->status[4] |= IEC958_AES4_CON_WORDLEN_20_16;\r\niec->status[4] &= ~IEC958_AES4_CON_MAX_WORDLEN_24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niec->status[4] |= IEC958_AES4_CON_WORDLEN_24_20;\r\niec->status[4] |= IEC958_AES4_CON_MAX_WORDLEN_24;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "format not supported!\n");\r\nreturn -EINVAL;\r\n}\r\ncea->db1_ct_cc = (params_channels(params) - 1)\r\n& CEA861_AUDIO_INFOFRAME_DB1CC;\r\ncea->db1_ct_cc |= CEA861_AUDIO_INFOFRAME_DB1CT_FROM_STREAM;\r\ncea->db2_sf_ss = CEA861_AUDIO_INFOFRAME_DB2SF_FROM_STREAM;\r\ncea->db2_sf_ss |= CEA861_AUDIO_INFOFRAME_DB2SS_FROM_STREAM;\r\ncea->db3 = 0;\r\nif (params_channels(params) == 2)\r\ncea->db4_ca = 0x0;\r\nelse if (params_channels(params) == 6)\r\ncea->db4_ca = 0xb;\r\nelse\r\ncea->db4_ca = 0x13;\r\nif (cea->db4_ca == 0x00)\r\ncea->db5_dminh_lsv = CEA861_AUDIO_INFOFRAME_DB5_DM_INH_PERMITTED;\r\nelse\r\ncea->db5_dminh_lsv = CEA861_AUDIO_INFOFRAME_DB5_DM_INH_PROHIBITED;\r\ncea->db5_dminh_lsv |= (0 & CEA861_AUDIO_INFOFRAME_DB5_LSV);\r\nreturn ad->ops->audio_config(ad->dssdev, &ad->dss_audio);\r\n}\r\nstatic int hdmi_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\r\nint err = 0;\r\nWARN_ON(ad->current_stream != substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nerr = ad->ops->audio_start(ad->dssdev);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nad->ops->audio_stop(ad->dssdev);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void hdmi_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\r\nWARN_ON(ad->current_stream != substream);\r\nad->ops->audio_shutdown(ad->dssdev);\r\nmutex_lock(&ad->current_stream_lock);\r\nad->current_stream = NULL;\r\nmutex_unlock(&ad->current_stream_lock);\r\n}\r\nstatic int omap_hdmi_audio_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_hdmi_audio_pdata *ha = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct hdmi_audio_data *ad;\r\nstruct snd_soc_dai_driver *dai_drv;\r\nstruct snd_soc_card *card;\r\nint ret;\r\nif (!ha) {\r\ndev_err(dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nad = devm_kzalloc(dev, sizeof(*ad), GFP_KERNEL);\r\nif (!ad)\r\nreturn -ENOMEM;\r\nad->dssdev = ha->dev;\r\nad->ops = ha->ops;\r\nad->dma_data.addr = ha->audio_dma_addr;\r\nad->dma_data.filter_data = "audio_tx";\r\nad->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nmutex_init(&ad->current_stream_lock);\r\nswitch (ha->dss_version) {\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\ndai_drv = &omap4_hdmi_dai;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\ncase OMAPDSS_VER_DRA7xx:\r\ndai_drv = &omap5_hdmi_dai;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_register_component(ad->dssdev, &omap_hdmi_component,\r\ndai_drv, 1);\r\nif (ret)\r\nreturn ret;\r\nret = omap_pcm_platform_register(ad->dssdev);\r\nif (ret)\r\nreturn ret;\r\ncard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\ncard->name = devm_kasprintf(dev, GFP_KERNEL,\r\n"HDMI %s", dev_name(ad->dssdev));\r\ncard->owner = THIS_MODULE;\r\ncard->dai_link =\r\ndevm_kzalloc(dev, sizeof(*(card->dai_link)), GFP_KERNEL);\r\nif (!card->dai_link)\r\nreturn -ENOMEM;\r\ncard->dai_link->name = card->name;\r\ncard->dai_link->stream_name = card->name;\r\ncard->dai_link->cpu_dai_name = dev_name(ad->dssdev);\r\ncard->dai_link->platform_name = dev_name(ad->dssdev);\r\ncard->dai_link->codec_name = "snd-soc-dummy";\r\ncard->dai_link->codec_dai_name = "snd-soc-dummy-dai";\r\ncard->num_links = 1;\r\ncard->dev = dev;\r\nret = snd_soc_register_card(card);\r\nif (ret) {\r\ndev_err(dev, "snd_soc_register_card failed (%d)\n", ret);\r\nsnd_soc_unregister_component(ad->dssdev);\r\nreturn ret;\r\n}\r\nad->card = card;\r\nsnd_soc_card_set_drvdata(card, ad);\r\ndev_set_drvdata(dev, ad);\r\nreturn 0;\r\n}\r\nstatic int omap_hdmi_audio_remove(struct platform_device *pdev)\r\n{\r\nstruct hdmi_audio_data *ad = platform_get_drvdata(pdev);\r\nsnd_soc_unregister_card(ad->card);\r\nsnd_soc_unregister_component(ad->dssdev);\r\nreturn 0;\r\n}
