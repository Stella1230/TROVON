static int mfld_setup(struct pci_dev *pdev, struct dw_pci_controller *c)\r\n{\r\nswitch (pdev->device) {\r\ncase 0x0817:\r\nc->bus_cfg &= ~DW_IC_CON_SPEED_MASK;\r\nc->bus_cfg |= DW_IC_CON_SPEED_STD;\r\ncase 0x0818:\r\ncase 0x0819:\r\nc->bus_num = pdev->device - 0x817 + 3;\r\nreturn 0;\r\ncase 0x082C:\r\ncase 0x082D:\r\ncase 0x082E:\r\nc->bus_num = pdev->device - 0x82C + 0;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int mrfld_setup(struct pci_dev *pdev, struct dw_pci_controller *c)\r\n{\r\nswitch (PCI_SLOT(pdev->devfn)) {\r\ncase 8:\r\nc->bus_num = PCI_FUNC(pdev->devfn) + 0 + 1;\r\nreturn 0;\r\ncase 9:\r\nc->bus_num = PCI_FUNC(pdev->devfn) + 4 + 1;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int i2c_dw_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\ni2c_dw_disable(pci_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int i2c_dw_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nreturn i2c_dw_init(pci_get_drvdata(pdev));\r\n}\r\nstatic u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)\r\n{\r\nreturn dev->controller->clk_khz;\r\n}\r\nstatic int i2c_dw_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct dw_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nint r;\r\nstruct dw_pci_controller *controller;\r\nstruct dw_scl_sda_cfg *cfg;\r\nif (id->driver_data >= ARRAY_SIZE(dw_pci_controllers)) {\r\ndev_err(&pdev->dev, "%s: invalid driver data %ld\n", __func__,\r\nid->driver_data);\r\nreturn -EINVAL;\r\n}\r\ncontroller = &dw_pci_controllers[id->driver_data];\r\nr = pcim_enable_device(pdev);\r\nif (r) {\r\ndev_err(&pdev->dev, "Failed to enable I2C PCI device (%d)\n",\r\nr);\r\nreturn r;\r\n}\r\nr = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));\r\nif (r) {\r\ndev_err(&pdev->dev, "I/O memory remapping failed\n");\r\nreturn r;\r\n}\r\ndev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->clk = NULL;\r\ndev->controller = controller;\r\ndev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;\r\ndev->base = pcim_iomap_table(pdev)[0];\r\ndev->dev = &pdev->dev;\r\ndev->irq = pdev->irq;\r\nif (controller->setup) {\r\nr = controller->setup(pdev, controller);\r\nif (r)\r\nreturn r;\r\n}\r\ndev->functionality = controller->functionality |\r\nDW_IC_DEFAULT_FUNCTIONALITY;\r\ndev->master_cfg = controller->bus_cfg;\r\nif (controller->scl_sda_cfg) {\r\ncfg = controller->scl_sda_cfg;\r\ndev->ss_hcnt = cfg->ss_hcnt;\r\ndev->fs_hcnt = cfg->fs_hcnt;\r\ndev->ss_lcnt = cfg->ss_lcnt;\r\ndev->fs_lcnt = cfg->fs_lcnt;\r\ndev->sda_hold_time = cfg->sda_hold;\r\n}\r\npci_set_drvdata(pdev, dev);\r\ndev->tx_fifo_depth = controller->tx_fifo_depth;\r\ndev->rx_fifo_depth = controller->rx_fifo_depth;\r\nadap = &dev->adapter;\r\nadap->owner = THIS_MODULE;\r\nadap->class = 0;\r\nACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));\r\nadap->nr = controller->bus_num;\r\nr = i2c_dw_probe(dev);\r\nif (r)\r\nreturn r;\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 1000);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\npm_runtime_allow(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void i2c_dw_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct dw_i2c_dev *dev = pci_get_drvdata(pdev);\r\ni2c_dw_disable(dev);\r\npm_runtime_forbid(&pdev->dev);\r\npm_runtime_get_noresume(&pdev->dev);\r\ni2c_del_adapter(&dev->adapter);\r\n}
