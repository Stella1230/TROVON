static int __init file_caps_disable(char *str)\r\n{\r\nfile_caps_enabled = 0;\r\nreturn 1;\r\n}\r\nstatic void warn_legacy_capability_use(void)\r\n{\r\nchar name[sizeof(current->comm)];\r\npr_info_once("warning: `%s' uses 32-bit capabilities (legacy support in use)\n",\r\nget_task_comm(name, current));\r\n}\r\nstatic void warn_deprecated_v2(void)\r\n{\r\nchar name[sizeof(current->comm)];\r\npr_info_once("warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\n",\r\nget_task_comm(name, current));\r\n}\r\nstatic int cap_validate_magic(cap_user_header_t header, unsigned *tocopy)\r\n{\r\n__u32 version;\r\nif (get_user(version, &header->version))\r\nreturn -EFAULT;\r\nswitch (version) {\r\ncase _LINUX_CAPABILITY_VERSION_1:\r\nwarn_legacy_capability_use();\r\n*tocopy = _LINUX_CAPABILITY_U32S_1;\r\nbreak;\r\ncase _LINUX_CAPABILITY_VERSION_2:\r\nwarn_deprecated_v2();\r\ncase _LINUX_CAPABILITY_VERSION_3:\r\n*tocopy = _LINUX_CAPABILITY_U32S_3;\r\nbreak;\r\ndefault:\r\nif (put_user((u32)_KERNEL_CAPABILITY_VERSION, &header->version))\r\nreturn -EFAULT;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int cap_get_target_pid(pid_t pid, kernel_cap_t *pEp,\r\nkernel_cap_t *pIp, kernel_cap_t *pPp)\r\n{\r\nint ret;\r\nif (pid && (pid != task_pid_vnr(current))) {\r\nstruct task_struct *target;\r\nrcu_read_lock();\r\ntarget = find_task_by_vpid(pid);\r\nif (!target)\r\nret = -ESRCH;\r\nelse\r\nret = security_capget(target, pEp, pIp, pPp);\r\nrcu_read_unlock();\r\n} else\r\nret = security_capget(current, pEp, pIp, pPp);\r\nreturn ret;\r\n}\r\nbool has_ns_capability(struct task_struct *t,\r\nstruct user_namespace *ns, int cap)\r\n{\r\nint ret;\r\nrcu_read_lock();\r\nret = security_capable(__task_cred(t), ns, cap);\r\nrcu_read_unlock();\r\nreturn (ret == 0);\r\n}\r\nbool has_capability(struct task_struct *t, int cap)\r\n{\r\nreturn has_ns_capability(t, &init_user_ns, cap);\r\n}\r\nbool has_ns_capability_noaudit(struct task_struct *t,\r\nstruct user_namespace *ns, int cap)\r\n{\r\nint ret;\r\nrcu_read_lock();\r\nret = security_capable_noaudit(__task_cred(t), ns, cap);\r\nrcu_read_unlock();\r\nreturn (ret == 0);\r\n}\r\nbool has_capability_noaudit(struct task_struct *t, int cap)\r\n{\r\nreturn has_ns_capability_noaudit(t, &init_user_ns, cap);\r\n}\r\nstatic bool ns_capable_common(struct user_namespace *ns, int cap, bool audit)\r\n{\r\nint capable;\r\nif (unlikely(!cap_valid(cap))) {\r\npr_crit("capable() called with invalid cap=%u\n", cap);\r\nBUG();\r\n}\r\ncapable = audit ? security_capable(current_cred(), ns, cap) :\r\nsecurity_capable_noaudit(current_cred(), ns, cap);\r\nif (capable == 0) {\r\ncurrent->flags |= PF_SUPERPRIV;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool ns_capable(struct user_namespace *ns, int cap)\r\n{\r\nreturn ns_capable_common(ns, cap, true);\r\n}\r\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\r\n{\r\nreturn ns_capable_common(ns, cap, false);\r\n}\r\nbool capable(int cap)\r\n{\r\nreturn ns_capable(&init_user_ns, cap);\r\n}\r\nbool file_ns_capable(const struct file *file, struct user_namespace *ns,\r\nint cap)\r\n{\r\nif (WARN_ON_ONCE(!cap_valid(cap)))\r\nreturn false;\r\nif (security_capable(file->f_cred, ns, cap) == 0)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool privileged_wrt_inode_uidgid(struct user_namespace *ns, const struct inode *inode)\r\n{\r\nreturn kuid_has_mapping(ns, inode->i_uid) &&\r\nkgid_has_mapping(ns, inode->i_gid);\r\n}\r\nbool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\r\n{\r\nstruct user_namespace *ns = current_user_ns();\r\nreturn ns_capable(ns, cap) && privileged_wrt_inode_uidgid(ns, inode);\r\n}\r\nbool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\r\n{\r\nint ret = 0;\r\nconst struct cred *cred;\r\nrcu_read_lock();\r\ncred = rcu_dereference(tsk->ptracer_cred);\r\nif (cred)\r\nret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\r\nrcu_read_unlock();\r\nreturn (ret == 0);\r\n}
