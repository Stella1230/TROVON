void device_queue_manager_init_cik(struct device_queue_manager_asic_ops *ops)\r\n{\r\nops->set_cache_memory_policy = set_cache_memory_policy_cik;\r\nops->register_process = register_process_cik;\r\nops->initialize = initialize_cpsch_cik;\r\nops->init_sdma_vm = init_sdma_vm;\r\n}\r\nstatic uint32_t compute_sh_mem_bases_64bit(unsigned int top_address_nybble)\r\n{\r\nBUG_ON((top_address_nybble & 1) || top_address_nybble > 0xE ||\r\ntop_address_nybble == 0);\r\nreturn PRIVATE_BASE(top_address_nybble << 12) |\r\nSHARED_BASE(top_address_nybble << 12);\r\n}\r\nstatic bool set_cache_memory_policy_cik(struct device_queue_manager *dqm,\r\nstruct qcm_process_device *qpd,\r\nenum cache_policy default_policy,\r\nenum cache_policy alternate_policy,\r\nvoid __user *alternate_aperture_base,\r\nuint64_t alternate_aperture_size)\r\n{\r\nuint32_t default_mtype;\r\nuint32_t ape1_mtype;\r\ndefault_mtype = (default_policy == cache_policy_coherent) ?\r\nMTYPE_NONCACHED :\r\nMTYPE_CACHED;\r\nape1_mtype = (alternate_policy == cache_policy_coherent) ?\r\nMTYPE_NONCACHED :\r\nMTYPE_CACHED;\r\nqpd->sh_mem_config = (qpd->sh_mem_config & PTR32)\r\n| ALIGNMENT_MODE(SH_MEM_ALIGNMENT_MODE_UNALIGNED)\r\n| DEFAULT_MTYPE(default_mtype)\r\n| APE1_MTYPE(ape1_mtype);\r\nreturn true;\r\n}\r\nstatic int register_process_cik(struct device_queue_manager *dqm,\r\nstruct qcm_process_device *qpd)\r\n{\r\nstruct kfd_process_device *pdd;\r\nunsigned int temp;\r\nBUG_ON(!dqm || !qpd);\r\npdd = qpd_to_pdd(qpd);\r\nif (qpd->sh_mem_config == 0) {\r\nqpd->sh_mem_config =\r\nALIGNMENT_MODE(SH_MEM_ALIGNMENT_MODE_UNALIGNED) |\r\nDEFAULT_MTYPE(MTYPE_NONCACHED) |\r\nAPE1_MTYPE(MTYPE_NONCACHED);\r\nqpd->sh_mem_ape1_limit = 0;\r\nqpd->sh_mem_ape1_base = 0;\r\n}\r\nif (qpd->pqm->process->is_32bit_user_mode) {\r\ntemp = get_sh_mem_bases_32(pdd);\r\nqpd->sh_mem_bases = SHARED_BASE(temp);\r\nqpd->sh_mem_config |= PTR32;\r\n} else {\r\ntemp = get_sh_mem_bases_nybble_64(pdd);\r\nqpd->sh_mem_bases = compute_sh_mem_bases_64bit(temp);\r\n}\r\npr_debug("kfd: is32bit process: %d sh_mem_bases nybble: 0x%X and register 0x%X\n",\r\nqpd->pqm->process->is_32bit_user_mode, temp, qpd->sh_mem_bases);\r\nreturn 0;\r\n}\r\nstatic void init_sdma_vm(struct device_queue_manager *dqm, struct queue *q,\r\nstruct qcm_process_device *qpd)\r\n{\r\nuint32_t value = (1 << SDMA0_RLC0_VIRTUAL_ADDR__ATC__SHIFT);\r\nif (q->process->is_32bit_user_mode)\r\nvalue |= (1 << SDMA0_RLC0_VIRTUAL_ADDR__PTR32__SHIFT) |\r\nget_sh_mem_bases_32(qpd_to_pdd(qpd));\r\nelse\r\nvalue |= ((get_sh_mem_bases_nybble_64(qpd_to_pdd(qpd))) <<\r\nSDMA0_RLC0_VIRTUAL_ADDR__SHARED_BASE__SHIFT) &\r\nSDMA0_RLC0_VIRTUAL_ADDR__SHARED_BASE_MASK;\r\nq->properties.sdma_vm_addr = value;\r\n}\r\nstatic int initialize_cpsch_cik(struct device_queue_manager *dqm)\r\n{\r\nreturn init_pipelines(dqm, get_pipes_num(dqm), get_first_pipe(dqm));\r\n}
