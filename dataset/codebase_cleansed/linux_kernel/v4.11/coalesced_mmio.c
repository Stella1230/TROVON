static inline struct kvm_coalesced_mmio_dev *to_mmio(struct kvm_io_device *dev)\r\n{\r\nreturn container_of(dev, struct kvm_coalesced_mmio_dev, dev);\r\n}\r\nstatic int coalesced_mmio_in_range(struct kvm_coalesced_mmio_dev *dev,\r\ngpa_t addr, int len)\r\n{\r\nif (len < 0)\r\nreturn 0;\r\nif (addr + len < addr)\r\nreturn 0;\r\nif (addr < dev->zone.addr)\r\nreturn 0;\r\nif (addr + len > dev->zone.addr + dev->zone.size)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev)\r\n{\r\nstruct kvm_coalesced_mmio_ring *ring;\r\nunsigned avail;\r\nring = dev->kvm->coalesced_mmio_ring;\r\navail = (ring->first - ring->last - 1) % KVM_COALESCED_MMIO_MAX;\r\nif (avail == 0) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int coalesced_mmio_write(struct kvm_vcpu *vcpu,\r\nstruct kvm_io_device *this, gpa_t addr,\r\nint len, const void *val)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\r\nstruct kvm_coalesced_mmio_ring *ring = dev->kvm->coalesced_mmio_ring;\r\nif (!coalesced_mmio_in_range(dev, addr, len))\r\nreturn -EOPNOTSUPP;\r\nspin_lock(&dev->kvm->ring_lock);\r\nif (!coalesced_mmio_has_room(dev)) {\r\nspin_unlock(&dev->kvm->ring_lock);\r\nreturn -EOPNOTSUPP;\r\n}\r\nring->coalesced_mmio[ring->last].phys_addr = addr;\r\nring->coalesced_mmio[ring->last].len = len;\r\nmemcpy(ring->coalesced_mmio[ring->last].data, val, len);\r\nsmp_wmb();\r\nring->last = (ring->last + 1) % KVM_COALESCED_MMIO_MAX;\r\nspin_unlock(&dev->kvm->ring_lock);\r\nreturn 0;\r\n}\r\nstatic void coalesced_mmio_destructor(struct kvm_io_device *this)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\r\nlist_del(&dev->list);\r\nkfree(dev);\r\n}\r\nint kvm_coalesced_mmio_init(struct kvm *kvm)\r\n{\r\nstruct page *page;\r\nint ret;\r\nret = -ENOMEM;\r\npage = alloc_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!page)\r\ngoto out_err;\r\nret = 0;\r\nkvm->coalesced_mmio_ring = page_address(page);\r\nspin_lock_init(&kvm->ring_lock);\r\nINIT_LIST_HEAD(&kvm->coalesced_zones);\r\nout_err:\r\nreturn ret;\r\n}\r\nvoid kvm_coalesced_mmio_free(struct kvm *kvm)\r\n{\r\nif (kvm->coalesced_mmio_ring)\r\nfree_page((unsigned long)kvm->coalesced_mmio_ring);\r\n}\r\nint kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm,\r\nstruct kvm_coalesced_mmio_zone *zone)\r\n{\r\nint ret;\r\nstruct kvm_coalesced_mmio_dev *dev;\r\ndev = kzalloc(sizeof(struct kvm_coalesced_mmio_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nkvm_iodevice_init(&dev->dev, &coalesced_mmio_ops);\r\ndev->kvm = kvm;\r\ndev->zone = *zone;\r\nmutex_lock(&kvm->slots_lock);\r\nret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, zone->addr,\r\nzone->size, &dev->dev);\r\nif (ret < 0)\r\ngoto out_free_dev;\r\nlist_add_tail(&dev->list, &kvm->coalesced_zones);\r\nmutex_unlock(&kvm->slots_lock);\r\nreturn 0;\r\nout_free_dev:\r\nmutex_unlock(&kvm->slots_lock);\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nint kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm,\r\nstruct kvm_coalesced_mmio_zone *zone)\r\n{\r\nstruct kvm_coalesced_mmio_dev *dev, *tmp;\r\nmutex_lock(&kvm->slots_lock);\r\nlist_for_each_entry_safe(dev, tmp, &kvm->coalesced_zones, list)\r\nif (coalesced_mmio_in_range(dev, zone->addr, zone->size)) {\r\nkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &dev->dev);\r\nkvm_iodevice_destructor(&dev->dev);\r\n}\r\nmutex_unlock(&kvm->slots_lock);\r\nreturn 0;\r\n}
