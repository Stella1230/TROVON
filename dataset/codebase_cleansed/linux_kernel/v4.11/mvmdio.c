static int orion_mdio_smi_is_done(struct orion_mdio_dev *dev)\r\n{\r\nreturn !(readl(dev->regs) & MVMDIO_SMI_BUSY);\r\n}\r\nstatic int orion_mdio_wait_ready(struct mii_bus *bus)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nunsigned long timeout = usecs_to_jiffies(MVMDIO_SMI_TIMEOUT);\r\nunsigned long end = jiffies + timeout;\r\nint timedout = 0;\r\nwhile (1) {\r\nif (orion_mdio_smi_is_done(dev))\r\nreturn 0;\r\nelse if (timedout)\r\nbreak;\r\nif (dev->err_interrupt <= 0) {\r\nusleep_range(MVMDIO_SMI_POLL_INTERVAL_MIN,\r\nMVMDIO_SMI_POLL_INTERVAL_MAX);\r\nif (time_is_before_jiffies(end))\r\n++timedout;\r\n} else {\r\nif (timeout < 2)\r\ntimeout = 2;\r\nwait_event_timeout(dev->smi_busy_wait,\r\norion_mdio_smi_is_done(dev),\r\ntimeout);\r\n++timedout;\r\n}\r\n}\r\ndev_err(bus->parent, "Timeout: SMI busy for too long\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int orion_mdio_read(struct mii_bus *bus, int mii_id,\r\nint regnum)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nu32 val;\r\nint ret;\r\nmutex_lock(&dev->lock);\r\nret = orion_mdio_wait_ready(bus);\r\nif (ret < 0)\r\ngoto out;\r\nwritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\r\n(regnum << MVMDIO_SMI_PHY_REG_SHIFT) |\r\nMVMDIO_SMI_READ_OPERATION),\r\ndev->regs);\r\nret = orion_mdio_wait_ready(bus);\r\nif (ret < 0)\r\ngoto out;\r\nval = readl(dev->regs);\r\nif (!(val & MVMDIO_SMI_READ_VALID)) {\r\ndev_err(bus->parent, "SMI bus read not valid\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = val & 0xFFFF;\r\nout:\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int orion_mdio_write(struct mii_bus *bus, int mii_id,\r\nint regnum, u16 value)\r\n{\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nint ret;\r\nmutex_lock(&dev->lock);\r\nret = orion_mdio_wait_ready(bus);\r\nif (ret < 0)\r\ngoto out;\r\nwritel(((mii_id << MVMDIO_SMI_PHY_ADDR_SHIFT) |\r\n(regnum << MVMDIO_SMI_PHY_REG_SHIFT) |\r\nMVMDIO_SMI_WRITE_OPERATION |\r\n(value << MVMDIO_SMI_DATA_SHIFT)),\r\ndev->regs);\r\nout:\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t orion_mdio_err_irq(int irq, void *dev_id)\r\n{\r\nstruct orion_mdio_dev *dev = dev_id;\r\nif (readl(dev->regs + MVMDIO_ERR_INT_CAUSE) &\r\nMVMDIO_ERR_INT_SMI_DONE) {\r\nwritel(~MVMDIO_ERR_INT_SMI_DONE,\r\ndev->regs + MVMDIO_ERR_INT_CAUSE);\r\nwake_up(&dev->smi_busy_wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int orion_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nstruct mii_bus *bus;\r\nstruct orion_mdio_dev *dev;\r\nint ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "No SMI register address given\n");\r\nreturn -ENODEV;\r\n}\r\nbus = devm_mdiobus_alloc_size(&pdev->dev,\r\nsizeof(struct orion_mdio_dev));\r\nif (!bus)\r\nreturn -ENOMEM;\r\nbus->name = "orion_mdio_bus";\r\nbus->read = orion_mdio_read;\r\nbus->write = orion_mdio_write;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",\r\ndev_name(&pdev->dev));\r\nbus->parent = &pdev->dev;\r\ndev = bus->priv;\r\ndev->regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!dev->regs) {\r\ndev_err(&pdev->dev, "Unable to remap SMI register\n");\r\nreturn -ENODEV;\r\n}\r\ninit_waitqueue_head(&dev->smi_busy_wait);\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(dev->clk))\r\nclk_prepare_enable(dev->clk);\r\ndev->err_interrupt = platform_get_irq(pdev, 0);\r\nif (dev->err_interrupt > 0) {\r\nret = devm_request_irq(&pdev->dev, dev->err_interrupt,\r\norion_mdio_err_irq,\r\nIRQF_SHARED, pdev->name, dev);\r\nif (ret)\r\ngoto out_mdio;\r\nwritel(MVMDIO_ERR_INT_SMI_DONE,\r\ndev->regs + MVMDIO_ERR_INT_MASK);\r\n} else if (dev->err_interrupt == -EPROBE_DEFER) {\r\nreturn -EPROBE_DEFER;\r\n}\r\nmutex_init(&dev->lock);\r\nif (pdev->dev.of_node)\r\nret = of_mdiobus_register(bus, pdev->dev.of_node);\r\nelse\r\nret = mdiobus_register(bus);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Cannot register MDIO bus (%d)\n", ret);\r\ngoto out_mdio;\r\n}\r\nplatform_set_drvdata(pdev, bus);\r\nreturn 0;\r\nout_mdio:\r\nif (!IS_ERR(dev->clk))\r\nclk_disable_unprepare(dev->clk);\r\nreturn ret;\r\n}\r\nstatic int orion_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus = platform_get_drvdata(pdev);\r\nstruct orion_mdio_dev *dev = bus->priv;\r\nwritel(0, dev->regs + MVMDIO_ERR_INT_MASK);\r\nmdiobus_unregister(bus);\r\nif (!IS_ERR(dev->clk))\r\nclk_disable_unprepare(dev->clk);\r\nreturn 0;\r\n}
