static void its_mask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_mask_irq(d);\r\nirq_chip_mask_parent(d);\r\n}\r\nstatic void its_unmask_msi_irq(struct irq_data *d)\r\n{\r\npci_msi_unmask_irq(d);\r\nirq_chip_unmask_parent(d);\r\n}\r\nstatic int its_pci_msi_vec_count(struct pci_dev *pdev)\r\n{\r\nint msi, msix;\r\nmsi = max(pci_msi_vec_count(pdev), 0);\r\nmsix = max(pci_msix_vec_count(pdev), 0);\r\nreturn max(msi, msix);\r\n}\r\nstatic int its_get_pci_alias(struct pci_dev *pdev, u16 alias, void *data)\r\n{\r\nstruct its_pci_alias *dev_alias = data;\r\nif (pdev != dev_alias->pdev)\r\ndev_alias->count += its_pci_msi_vec_count(pdev);\r\nreturn 0;\r\n}\r\nstatic int its_pci_msi_prepare(struct irq_domain *domain, struct device *dev,\r\nint nvec, msi_alloc_info_t *info)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct its_pci_alias dev_alias;\r\nstruct msi_domain_info *msi_info;\r\nif (!dev_is_pci(dev))\r\nreturn -EINVAL;\r\nmsi_info = msi_get_domain_info(domain->parent);\r\npdev = to_pci_dev(dev);\r\ndev_alias.pdev = pdev;\r\ndev_alias.count = nvec;\r\npci_for_each_dma_alias(pdev, its_get_pci_alias, &dev_alias);\r\ninfo->scratchpad[0].ul = pci_msi_domain_get_msi_rid(domain, pdev);\r\nreturn msi_info->ops->msi_prepare(domain->parent,\r\ndev, dev_alias.count, info);\r\n}\r\nstatic int __init its_pci_msi_init_one(struct fwnode_handle *handle,\r\nconst char *name)\r\n{\r\nstruct irq_domain *parent;\r\nparent = irq_find_matching_fwnode(handle, DOMAIN_BUS_NEXUS);\r\nif (!parent || !msi_get_domain_info(parent)) {\r\npr_err("%s: Unable to locate ITS domain\n", name);\r\nreturn -ENXIO;\r\n}\r\nif (!pci_msi_create_irq_domain(handle, &its_pci_msi_domain_info,\r\nparent)) {\r\npr_err("%s: Unable to create PCI domain\n", name);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init its_pci_of_msi_init(void)\r\n{\r\nstruct device_node *np;\r\nfor (np = of_find_matching_node(NULL, its_device_id); np;\r\nnp = of_find_matching_node(np, its_device_id)) {\r\nif (!of_property_read_bool(np, "msi-controller"))\r\ncontinue;\r\nif (its_pci_msi_init_one(of_node_to_fwnode(np), np->full_name))\r\ncontinue;\r\npr_info("PCI/MSI: %s domain created\n", np->full_name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nits_pci_msi_parse_madt(struct acpi_subtable_header *header,\r\nconst unsigned long end)\r\n{\r\nstruct acpi_madt_generic_translator *its_entry;\r\nstruct fwnode_handle *dom_handle;\r\nconst char *node_name;\r\nint err = -ENXIO;\r\nits_entry = (struct acpi_madt_generic_translator *)header;\r\nnode_name = kasprintf(GFP_KERNEL, "ITS@0x%lx",\r\n(long)its_entry->base_address);\r\ndom_handle = iort_find_domain_token(its_entry->translation_id);\r\nif (!dom_handle) {\r\npr_err("%s: Unable to locate ITS domain handle\n", node_name);\r\ngoto out;\r\n}\r\nerr = its_pci_msi_init_one(dom_handle, node_name);\r\nif (!err)\r\npr_info("PCI/MSI: %s domain created\n", node_name);\r\nout:\r\nkfree(node_name);\r\nreturn err;\r\n}\r\nstatic int __init its_pci_acpi_msi_init(void)\r\n{\r\nacpi_table_parse_madt(ACPI_MADT_TYPE_GENERIC_TRANSLATOR,\r\nits_pci_msi_parse_madt, 0);\r\nreturn 0;\r\n}\r\nstatic int __init its_pci_acpi_msi_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init its_pci_msi_init(void)\r\n{\r\nits_pci_of_msi_init();\r\nits_pci_acpi_msi_init();\r\nreturn 0;\r\n}
