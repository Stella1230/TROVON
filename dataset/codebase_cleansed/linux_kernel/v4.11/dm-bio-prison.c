struct dm_bio_prison *dm_bio_prison_create(void)\r\n{\r\nstruct dm_bio_prison *prison = kmalloc(sizeof(*prison), GFP_KERNEL);\r\nif (!prison)\r\nreturn NULL;\r\nspin_lock_init(&prison->lock);\r\nprison->cell_pool = mempool_create_slab_pool(MIN_CELLS, _cell_cache);\r\nif (!prison->cell_pool) {\r\nkfree(prison);\r\nreturn NULL;\r\n}\r\nprison->cells = RB_ROOT;\r\nreturn prison;\r\n}\r\nvoid dm_bio_prison_destroy(struct dm_bio_prison *prison)\r\n{\r\nmempool_destroy(prison->cell_pool);\r\nkfree(prison);\r\n}\r\nstruct dm_bio_prison_cell *dm_bio_prison_alloc_cell(struct dm_bio_prison *prison, gfp_t gfp)\r\n{\r\nreturn mempool_alloc(prison->cell_pool, gfp);\r\n}\r\nvoid dm_bio_prison_free_cell(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nmempool_free(cell, prison->cell_pool);\r\n}\r\nstatic void __setup_new_cell(struct dm_cell_key *key,\r\nstruct bio *holder,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nmemcpy(&cell->key, key, sizeof(cell->key));\r\ncell->holder = holder;\r\nbio_list_init(&cell->bios);\r\n}\r\nstatic int cmp_keys(struct dm_cell_key *lhs,\r\nstruct dm_cell_key *rhs)\r\n{\r\nif (lhs->virtual < rhs->virtual)\r\nreturn -1;\r\nif (lhs->virtual > rhs->virtual)\r\nreturn 1;\r\nif (lhs->dev < rhs->dev)\r\nreturn -1;\r\nif (lhs->dev > rhs->dev)\r\nreturn 1;\r\nif (lhs->block_end <= rhs->block_begin)\r\nreturn -1;\r\nif (lhs->block_begin >= rhs->block_end)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __bio_detain(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nint r;\r\nstruct rb_node **new = &prison->cells.rb_node, *parent = NULL;\r\nwhile (*new) {\r\nstruct dm_bio_prison_cell *cell =\r\ncontainer_of(*new, struct dm_bio_prison_cell, node);\r\nr = cmp_keys(key, &cell->key);\r\nparent = *new;\r\nif (r < 0)\r\nnew = &((*new)->rb_left);\r\nelse if (r > 0)\r\nnew = &((*new)->rb_right);\r\nelse {\r\nif (inmate)\r\nbio_list_add(&cell->bios, inmate);\r\n*cell_result = cell;\r\nreturn 1;\r\n}\r\n}\r\n__setup_new_cell(key, inmate, cell_prealloc);\r\n*cell_result = cell_prealloc;\r\nrb_link_node(&cell_prealloc->node, parent, new);\r\nrb_insert_color(&cell_prealloc->node, &prison->cells);\r\nreturn 0;\r\n}\r\nstatic int bio_detain(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nint r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __bio_detain(prison, key, inmate, cell_prealloc, cell_result);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nint dm_bio_detain(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nreturn bio_detain(prison, key, inmate, cell_prealloc, cell_result);\r\n}\r\nint dm_get_cell(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nreturn bio_detain(prison, key, NULL, cell_prealloc, cell_result);\r\n}\r\nstatic void __cell_release(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell,\r\nstruct bio_list *inmates)\r\n{\r\nrb_erase(&cell->node, &prison->cells);\r\nif (inmates) {\r\nif (cell->holder)\r\nbio_list_add(inmates, cell->holder);\r\nbio_list_merge(inmates, &cell->bios);\r\n}\r\n}\r\nvoid dm_cell_release(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell,\r\nstruct bio_list *bios)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\n__cell_release(prison, cell, bios);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\n}\r\nstatic void __cell_release_no_holder(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell,\r\nstruct bio_list *inmates)\r\n{\r\nrb_erase(&cell->node, &prison->cells);\r\nbio_list_merge(inmates, &cell->bios);\r\n}\r\nvoid dm_cell_release_no_holder(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell,\r\nstruct bio_list *inmates)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\n__cell_release_no_holder(prison, cell, inmates);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\n}\r\nvoid dm_cell_error(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell, int error)\r\n{\r\nstruct bio_list bios;\r\nstruct bio *bio;\r\nbio_list_init(&bios);\r\ndm_cell_release(prison, cell, &bios);\r\nwhile ((bio = bio_list_pop(&bios))) {\r\nbio->bi_error = error;\r\nbio_endio(bio);\r\n}\r\n}\r\nvoid dm_cell_visit_release(struct dm_bio_prison *prison,\r\nvoid (*visit_fn)(void *, struct dm_bio_prison_cell *),\r\nvoid *context,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nvisit_fn(context, cell);\r\nrb_erase(&cell->node, &prison->cells);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\n}\r\nstatic int __promote_or_release(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nif (bio_list_empty(&cell->bios)) {\r\nrb_erase(&cell->node, &prison->cells);\r\nreturn 1;\r\n}\r\ncell->holder = bio_list_pop(&cell->bios);\r\nreturn 0;\r\n}\r\nint dm_cell_promote_or_release(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nint r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prison->lock, flags);\r\nr = __promote_or_release(prison, cell);\r\nspin_unlock_irqrestore(&prison->lock, flags);\r\nreturn r;\r\n}\r\nstruct dm_deferred_set *dm_deferred_set_create(void)\r\n{\r\nint i;\r\nstruct dm_deferred_set *ds;\r\nds = kmalloc(sizeof(*ds), GFP_KERNEL);\r\nif (!ds)\r\nreturn NULL;\r\nspin_lock_init(&ds->lock);\r\nds->current_entry = 0;\r\nds->sweeper = 0;\r\nfor (i = 0; i < DEFERRED_SET_SIZE; i++) {\r\nds->entries[i].ds = ds;\r\nds->entries[i].count = 0;\r\nINIT_LIST_HEAD(&ds->entries[i].work_items);\r\n}\r\nreturn ds;\r\n}\r\nvoid dm_deferred_set_destroy(struct dm_deferred_set *ds)\r\n{\r\nkfree(ds);\r\n}\r\nstruct dm_deferred_entry *dm_deferred_entry_inc(struct dm_deferred_set *ds)\r\n{\r\nunsigned long flags;\r\nstruct dm_deferred_entry *entry;\r\nspin_lock_irqsave(&ds->lock, flags);\r\nentry = ds->entries + ds->current_entry;\r\nentry->count++;\r\nspin_unlock_irqrestore(&ds->lock, flags);\r\nreturn entry;\r\n}\r\nstatic unsigned ds_next(unsigned index)\r\n{\r\nreturn (index + 1) % DEFERRED_SET_SIZE;\r\n}\r\nstatic void __sweep(struct dm_deferred_set *ds, struct list_head *head)\r\n{\r\nwhile ((ds->sweeper != ds->current_entry) &&\r\n!ds->entries[ds->sweeper].count) {\r\nlist_splice_init(&ds->entries[ds->sweeper].work_items, head);\r\nds->sweeper = ds_next(ds->sweeper);\r\n}\r\nif ((ds->sweeper == ds->current_entry) && !ds->entries[ds->sweeper].count)\r\nlist_splice_init(&ds->entries[ds->sweeper].work_items, head);\r\n}\r\nvoid dm_deferred_entry_dec(struct dm_deferred_entry *entry, struct list_head *head)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&entry->ds->lock, flags);\r\nBUG_ON(!entry->count);\r\n--entry->count;\r\n__sweep(entry->ds, head);\r\nspin_unlock_irqrestore(&entry->ds->lock, flags);\r\n}\r\nint dm_deferred_set_add_work(struct dm_deferred_set *ds, struct list_head *work)\r\n{\r\nint r = 1;\r\nunsigned long flags;\r\nunsigned next_entry;\r\nspin_lock_irqsave(&ds->lock, flags);\r\nif ((ds->sweeper == ds->current_entry) &&\r\n!ds->entries[ds->current_entry].count)\r\nr = 0;\r\nelse {\r\nlist_add(work, &ds->entries[ds->current_entry].work_items);\r\nnext_entry = ds_next(ds->current_entry);\r\nif (!ds->entries[next_entry].count)\r\nds->current_entry = next_entry;\r\n}\r\nspin_unlock_irqrestore(&ds->lock, flags);\r\nreturn r;\r\n}\r\nstatic int __init dm_bio_prison_init(void)\r\n{\r\n_cell_cache = KMEM_CACHE(dm_bio_prison_cell, 0);\r\nif (!_cell_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit dm_bio_prison_exit(void)\r\n{\r\nkmem_cache_destroy(_cell_cache);\r\n_cell_cache = NULL;\r\n}
