static void __iomem *lx_dsp_register(struct lx6464es *chip, int port)\r\n{\r\nvoid __iomem *base_address = chip->port_dsp_bar;\r\nreturn base_address + dsp_port_offsets[port]*4;\r\n}\r\nunsigned long lx_dsp_reg_read(struct lx6464es *chip, int port)\r\n{\r\nvoid __iomem *address = lx_dsp_register(chip, port);\r\nreturn ioread32(address);\r\n}\r\nstatic void lx_dsp_reg_readbuf(struct lx6464es *chip, int port, u32 *data,\r\nu32 len)\r\n{\r\nu32 __iomem *address = lx_dsp_register(chip, port);\r\nint i;\r\nfor (i = 0; i != len; ++i)\r\ndata[i] = ioread32(address + i);\r\n}\r\nvoid lx_dsp_reg_write(struct lx6464es *chip, int port, unsigned data)\r\n{\r\nvoid __iomem *address = lx_dsp_register(chip, port);\r\niowrite32(data, address);\r\n}\r\nstatic void lx_dsp_reg_writebuf(struct lx6464es *chip, int port,\r\nconst u32 *data, u32 len)\r\n{\r\nu32 __iomem *address = lx_dsp_register(chip, port);\r\nint i;\r\nfor (i = 0; i != len; ++i)\r\niowrite32(data[i], address + i);\r\n}\r\nstatic void __iomem *lx_plx_register(struct lx6464es *chip, int port)\r\n{\r\nvoid __iomem *base_address = chip->port_plx_remapped;\r\nreturn base_address + plx_port_offsets[port];\r\n}\r\nunsigned long lx_plx_reg_read(struct lx6464es *chip, int port)\r\n{\r\nvoid __iomem *address = lx_plx_register(chip, port);\r\nreturn ioread32(address);\r\n}\r\nvoid lx_plx_reg_write(struct lx6464es *chip, int port, u32 data)\r\n{\r\nvoid __iomem *address = lx_plx_register(chip, port);\r\niowrite32(data, address);\r\n}\r\nstatic void lx_message_init(struct lx_rmh *rmh, enum cmd_mb_opcodes cmd)\r\n{\r\nsnd_BUG_ON(cmd >= CMD_14_INVALID);\r\nrmh->cmd[0] = dsp_commands[cmd].dcCodeOp;\r\nrmh->cmd_len = dsp_commands[cmd].dcCmdLength;\r\nrmh->stat_len = dsp_commands[cmd].dcStatusLength;\r\nrmh->dsp_stat = dsp_commands[cmd].dcStatusType;\r\nrmh->cmd_idx = cmd;\r\nmemset(&rmh->cmd[1], 0, (REG_CRM_NUMBER - 1) * sizeof(u32));\r\n#ifdef CONFIG_SND_DEBUG\r\nmemset(rmh->stat, 0, REG_CRM_NUMBER * sizeof(u32));\r\n#endif\r\n#ifdef RMH_DEBUG\r\nrmh->cmd_idx = cmd;\r\n#endif\r\n}\r\nstatic void lx_message_dump(struct lx_rmh *rmh)\r\n{\r\nu8 idx = rmh->cmd_idx;\r\nint i;\r\nsnd_printk(LXRMH "command %s\n", dsp_commands[idx].dcOpName);\r\nfor (i = 0; i != rmh->cmd_len; ++i)\r\nsnd_printk(LXRMH "\tcmd[%d] %08x\n", i, rmh->cmd[i]);\r\nfor (i = 0; i != rmh->stat_len; ++i)\r\nsnd_printk(LXRMH "\tstat[%d]: %08x\n", i, rmh->stat[i]);\r\nsnd_printk("\n");\r\n}\r\nstatic inline void lx_message_dump(struct lx_rmh *rmh)\r\n{}\r\nstatic int lx_message_send_atomic(struct lx6464es *chip, struct lx_rmh *rmh)\r\n{\r\nu32 reg = ED_DSP_TIMED_OUT;\r\nint dwloop;\r\nif (lx_dsp_reg_read(chip, eReg_CSM) & (Reg_CSM_MC | Reg_CSM_MR)) {\r\ndev_err(chip->card->dev, "PIOSendMessage eReg_CSM %x\n", reg);\r\nreturn -EBUSY;\r\n}\r\nlx_dsp_reg_writebuf(chip, eReg_CRM1, rmh->cmd, rmh->cmd_len);\r\nlx_dsp_reg_write(chip, eReg_CSM, Reg_CSM_MC);\r\nfor (dwloop = 0; dwloop != XILINX_TIMEOUT_MS * 1000; ++dwloop) {\r\nif (lx_dsp_reg_read(chip, eReg_CSM) & Reg_CSM_MR) {\r\nif (rmh->dsp_stat == 0)\r\nreg = lx_dsp_reg_read(chip, eReg_CRM1);\r\nelse\r\nreg = 0;\r\ngoto polling_successful;\r\n} else\r\nudelay(1);\r\n}\r\ndev_warn(chip->card->dev, "TIMEOUT lx_message_send_atomic! "\r\n"polling failed\n");\r\npolling_successful:\r\nif ((reg & ERROR_VALUE) == 0) {\r\nif (rmh->stat_len) {\r\nsnd_BUG_ON(rmh->stat_len >= (REG_CRM_NUMBER-1));\r\nlx_dsp_reg_readbuf(chip, eReg_CRM2, rmh->stat,\r\nrmh->stat_len);\r\n}\r\n} else\r\ndev_err(chip->card->dev, "rmh error: %08x\n", reg);\r\nlx_dsp_reg_write(chip, eReg_CSM, 0);\r\nswitch (reg) {\r\ncase ED_DSP_TIMED_OUT:\r\ndev_warn(chip->card->dev, "lx_message_send: dsp timeout\n");\r\nreturn -ETIMEDOUT;\r\ncase ED_DSP_CRASHED:\r\ndev_warn(chip->card->dev, "lx_message_send: dsp crashed\n");\r\nreturn -EAGAIN;\r\n}\r\nlx_message_dump(rmh);\r\nreturn reg;\r\n}\r\nint lx_dsp_get_version(struct lx6464es *chip, u32 *rdsp_version)\r\n{\r\nu16 ret;\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_01_GET_SYS_CFG);\r\nret = lx_message_send_atomic(chip, &chip->rmh);\r\n*rdsp_version = chip->rmh.stat[1];\r\nmutex_unlock(&chip->msg_lock);\r\nreturn ret;\r\n}\r\nint lx_dsp_get_clock_frequency(struct lx6464es *chip, u32 *rfreq)\r\n{\r\nu16 ret = 0;\r\nu32 freq_raw = 0;\r\nu32 freq = 0;\r\nu32 frequency = 0;\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_01_GET_SYS_CFG);\r\nret = lx_message_send_atomic(chip, &chip->rmh);\r\nif (ret == 0) {\r\nfreq_raw = chip->rmh.stat[0] >> FREQ_FIELD_OFFSET;\r\nfreq = freq_raw & XES_FREQ_COUNT8_MASK;\r\nif ((freq < XES_FREQ_COUNT8_48_MAX) ||\r\n(freq > XES_FREQ_COUNT8_44_MIN))\r\nfrequency = 0;\r\nelse if (freq >= XES_FREQ_COUNT8_44_MAX)\r\nfrequency = 44100;\r\nelse\r\nfrequency = 48000;\r\n}\r\nmutex_unlock(&chip->msg_lock);\r\n*rfreq = frequency * chip->freq_ratio;\r\nreturn ret;\r\n}\r\nint lx_dsp_get_mac(struct lx6464es *chip)\r\n{\r\nu32 macmsb, maclsb;\r\nmacmsb = lx_dsp_reg_read(chip, eReg_ADMACESMSB) & 0x00FFFFFF;\r\nmaclsb = lx_dsp_reg_read(chip, eReg_ADMACESLSB) & 0x00FFFFFF;\r\nchip->mac_address[5] = ((u8 *)(&maclsb))[0];\r\nchip->mac_address[4] = ((u8 *)(&maclsb))[1];\r\nchip->mac_address[3] = ((u8 *)(&maclsb))[2];\r\nchip->mac_address[2] = ((u8 *)(&macmsb))[0];\r\nchip->mac_address[1] = ((u8 *)(&macmsb))[1];\r\nchip->mac_address[0] = ((u8 *)(&macmsb))[2];\r\nreturn 0;\r\n}\r\nint lx_dsp_set_granularity(struct lx6464es *chip, u32 gran)\r\n{\r\nint ret;\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_02_SET_GRANULARITY);\r\nchip->rmh.cmd[0] |= gran;\r\nret = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn ret;\r\n}\r\nint lx_dsp_read_async_events(struct lx6464es *chip, u32 *data)\r\n{\r\nint ret;\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_04_GET_EVENT);\r\nchip->rmh.stat_len = 9;\r\nret = lx_message_send_atomic(chip, &chip->rmh);\r\nif (!ret)\r\nmemcpy(data, chip->rmh.stat, chip->rmh.stat_len * sizeof(u32));\r\nmutex_unlock(&chip->msg_lock);\r\nreturn ret;\r\n}\r\nint lx_pipe_allocate(struct lx6464es *chip, u32 pipe, int is_capture,\r\nint channels)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_06_ALLOCATE_PIPE);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nchip->rmh.cmd[0] |= channels;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nif (err != 0)\r\ndev_err(chip->card->dev, "could not allocate pipe\n");\r\nreturn err;\r\n}\r\nint lx_pipe_release(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_07_RELEASE_PIPE);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_buffer_ask(struct lx6464es *chip, u32 pipe, int is_capture,\r\nu32 *r_needed, u32 *r_freed, u32 *size_array)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (size_array)\r\nmemset(size_array, 0, sizeof(u32)*MAX_STREAM_BUFFER);\r\n#endif\r\n*r_needed = 0;\r\n*r_freed = 0;\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_08_ASK_BUFFERS);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nif (!err) {\r\nint i;\r\nfor (i = 0; i < MAX_STREAM_BUFFER; ++i) {\r\nu32 stat = chip->rmh.stat[i];\r\nif (stat & (BF_EOB << BUFF_FLAGS_OFFSET)) {\r\n*r_freed += 1;\r\nif (size_array)\r\nsize_array[i] = stat & MASK_DATA_SIZE;\r\n} else if ((stat & (BF_VALID << BUFF_FLAGS_OFFSET))\r\n== 0)\r\n*r_needed += 1;\r\n}\r\ndev_dbg(chip->card->dev,\r\n"CMD_08_ASK_BUFFERS: needed %d, freed %d\n",\r\n*r_needed, *r_freed);\r\nfor (i = 0; i < MAX_STREAM_BUFFER; ++i) {\r\nfor (i = 0; i != chip->rmh.stat_len; ++i)\r\ndev_dbg(chip->card->dev,\r\n" stat[%d]: %x, %x\n", i,\r\nchip->rmh.stat[i],\r\nchip->rmh.stat[i] & MASK_DATA_SIZE);\r\n}\r\n}\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_pipe_stop(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_09_STOP_PIPE);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nstatic int lx_pipe_toggle_state(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0B_TOGGLE_PIPE_STATE);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_pipe_start(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nint err;\r\nerr = lx_pipe_wait_for_idle(chip, pipe, is_capture);\r\nif (err < 0)\r\nreturn err;\r\nerr = lx_pipe_toggle_state(chip, pipe, is_capture);\r\nreturn err;\r\n}\r\nint lx_pipe_pause(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nint err = 0;\r\nerr = lx_pipe_wait_for_start(chip, pipe, is_capture);\r\nif (err < 0)\r\nreturn err;\r\nerr = lx_pipe_toggle_state(chip, pipe, is_capture);\r\nreturn err;\r\n}\r\nint lx_pipe_sample_count(struct lx6464es *chip, u32 pipe, int is_capture,\r\nu64 *rsample_count)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0A_GET_PIPE_SPL_COUNT);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nchip->rmh.stat_len = 2;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nif (err != 0)\r\ndev_err(chip->card->dev,\r\n"could not query pipe's sample count\n");\r\nelse {\r\n*rsample_count = ((u64)(chip->rmh.stat[0] & MASK_SPL_COUNT_HI)\r\n<< 24)\r\n+ chip->rmh.stat[1];\r\n}\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_pipe_state(struct lx6464es *chip, u32 pipe, int is_capture, u16 *rstate)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0A_GET_PIPE_SPL_COUNT);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nif (err != 0)\r\ndev_err(chip->card->dev, "could not query pipe's state\n");\r\nelse\r\n*rstate = (chip->rmh.stat[0] >> PSTATE_OFFSET) & 0x0F;\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nstatic int lx_pipe_wait_for_state(struct lx6464es *chip, u32 pipe,\r\nint is_capture, u16 state)\r\n{\r\nint i;\r\nfor (i = 0; i != 50; ++i) {\r\nu16 current_state;\r\nint err = lx_pipe_state(chip, pipe, is_capture, &current_state);\r\nif (err < 0)\r\nreturn err;\r\nif (!err && current_state == state)\r\nreturn 0;\r\nmdelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint lx_pipe_wait_for_start(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nreturn lx_pipe_wait_for_state(chip, pipe, is_capture, PSTATE_RUN);\r\n}\r\nint lx_pipe_wait_for_idle(struct lx6464es *chip, u32 pipe, int is_capture)\r\n{\r\nreturn lx_pipe_wait_for_state(chip, pipe, is_capture, PSTATE_IDLE);\r\n}\r\nint lx_stream_set_state(struct lx6464es *chip, u32 pipe,\r\nint is_capture, enum stream_state_t state)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_13_SET_STREAM_STATE);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nchip->rmh.cmd[0] |= state;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_stream_set_format(struct lx6464es *chip, struct snd_pcm_runtime *runtime,\r\nu32 pipe, int is_capture)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nu32 channels = runtime->channels;\r\nif (runtime->channels != channels)\r\ndev_err(chip->card->dev, "channel count mismatch: %d vs %d",\r\nruntime->channels, channels);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0C_DEF_STREAM);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nif (runtime->sample_bits == 16)\r\nchip->rmh.cmd[0] |= (STREAM_FMT_16b << STREAM_FMT_OFFSET);\r\nif (snd_pcm_format_little_endian(runtime->format))\r\nchip->rmh.cmd[0] |= (STREAM_FMT_intel << STREAM_FMT_OFFSET);\r\nchip->rmh.cmd[0] |= channels-1;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_stream_state(struct lx6464es *chip, u32 pipe, int is_capture,\r\nint *rstate)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0E_GET_STREAM_SPL_COUNT);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\n*rstate = (chip->rmh.stat[0] & SF_START) ? START_STATE : PAUSE_STATE;\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_stream_sample_position(struct lx6464es *chip, u32 pipe, int is_capture,\r\nu64 *r_bytepos)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0E_GET_STREAM_SPL_COUNT);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\n*r_bytepos = ((u64) (chip->rmh.stat[0] & MASK_SPL_COUNT_HI)\r\n<< 32)\r\n+ chip->rmh.stat[1];\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_buffer_give(struct lx6464es *chip, u32 pipe, int is_capture,\r\nu32 buffer_size, u32 buf_address_lo, u32 buf_address_hi,\r\nu32 *r_buffer_index)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0F_UPDATE_BUFFER);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nchip->rmh.cmd[0] |= BF_NOTIFY_EOB;\r\nchip->rmh.cmd[1] = buffer_size & MASK_DATA_SIZE;\r\nchip->rmh.cmd[2] = buf_address_lo;\r\nif (buf_address_hi) {\r\nchip->rmh.cmd_len = 4;\r\nchip->rmh.cmd[3] = buf_address_hi;\r\nchip->rmh.cmd[0] |= BF_64BITS_ADR;\r\n}\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nif (err == 0) {\r\n*r_buffer_index = chip->rmh.stat[0];\r\ngoto done;\r\n}\r\nif (err == EB_RBUFFERS_TABLE_OVERFLOW)\r\ndev_err(chip->card->dev,\r\n"lx_buffer_give EB_RBUFFERS_TABLE_OVERFLOW\n");\r\nif (err == EB_INVALID_STREAM)\r\ndev_err(chip->card->dev,\r\n"lx_buffer_give EB_INVALID_STREAM\n");\r\nif (err == EB_CMD_REFUSED)\r\ndev_err(chip->card->dev,\r\n"lx_buffer_give EB_CMD_REFUSED\n");\r\ndone:\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_buffer_free(struct lx6464es *chip, u32 pipe, int is_capture,\r\nu32 *r_buffer_size)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_11_CANCEL_BUFFER);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nchip->rmh.cmd[0] |= MASK_BUFFER_ID;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nif (err == 0)\r\n*r_buffer_size = chip->rmh.stat[0] & MASK_DATA_SIZE;\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_buffer_cancel(struct lx6464es *chip, u32 pipe, int is_capture,\r\nu32 buffer_index)\r\n{\r\nint err;\r\nu32 pipe_cmd = PIPE_INFO_TO_CMD(is_capture, pipe);\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_11_CANCEL_BUFFER);\r\nchip->rmh.cmd[0] |= pipe_cmd;\r\nchip->rmh.cmd[0] |= buffer_index;\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_level_unmute(struct lx6464es *chip, int is_capture, int unmute)\r\n{\r\nint err;\r\nu64 mute_mask = unmute ? 0 : 0xFFFFFFFFFFFFFFFFLLU;\r\nmutex_lock(&chip->msg_lock);\r\nlx_message_init(&chip->rmh, CMD_0D_SET_MUTE);\r\nchip->rmh.cmd[0] |= PIPE_INFO_TO_CMD(is_capture, 0);\r\nchip->rmh.cmd[1] = (u32)(mute_mask >> (u64)32);\r\nchip->rmh.cmd[2] = (u32)(mute_mask & (u64)0xFFFFFFFF);\r\ndev_dbg(chip->card->dev,\r\n"mute %x %x %x\n", chip->rmh.cmd[0], chip->rmh.cmd[1],\r\nchip->rmh.cmd[2]);\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nint lx_level_peaks(struct lx6464es *chip, int is_capture, int channels,\r\nu32 *r_levels)\r\n{\r\nint err = 0;\r\nint i;\r\nmutex_lock(&chip->msg_lock);\r\nfor (i = 0; i < channels; i += 4) {\r\nu32 s0, s1, s2, s3;\r\nlx_message_init(&chip->rmh, CMD_12_GET_PEAK);\r\nchip->rmh.cmd[0] |= PIPE_INFO_TO_CMD(is_capture, i);\r\nerr = lx_message_send_atomic(chip, &chip->rmh);\r\nif (err == 0) {\r\ns0 = peak_map[chip->rmh.stat[0] & 0x0F];\r\ns1 = peak_map[(chip->rmh.stat[0] >> 4) & 0xf];\r\ns2 = peak_map[(chip->rmh.stat[0] >> 8) & 0xf];\r\ns3 = peak_map[(chip->rmh.stat[0] >> 12) & 0xf];\r\n} else\r\ns0 = s1 = s2 = s3 = 0;\r\nr_levels[0] = s0;\r\nr_levels[1] = s1;\r\nr_levels[2] = s2;\r\nr_levels[3] = s3;\r\nr_levels += 4;\r\n}\r\nmutex_unlock(&chip->msg_lock);\r\nreturn err;\r\n}\r\nstatic u32 lx_interrupt_test_ack(struct lx6464es *chip)\r\n{\r\nu32 irqcs = lx_plx_reg_read(chip, ePLX_IRQCS);\r\nif (irqcs & IRQCS_ACTIVE_PCIDB) {\r\nu32 temp;\r\nirqcs = PCX_IRQ_NONE;\r\nwhile ((temp = lx_plx_reg_read(chip, ePLX_L2PCIDB))) {\r\nirqcs |= temp;\r\nlx_plx_reg_write(chip, ePLX_L2PCIDB, temp);\r\n}\r\nreturn irqcs;\r\n}\r\nreturn PCX_IRQ_NONE;\r\n}\r\nstatic int lx_interrupt_ack(struct lx6464es *chip, u32 *r_irqsrc,\r\nint *r_async_pending, int *r_async_escmd)\r\n{\r\nu32 irq_async;\r\nu32 irqsrc = lx_interrupt_test_ack(chip);\r\nif (irqsrc == PCX_IRQ_NONE)\r\nreturn 0;\r\n*r_irqsrc = irqsrc;\r\nirq_async = irqsrc & MASK_SYS_ASYNC_EVENTS;\r\nif (irq_async & MASK_SYS_STATUS_ESA) {\r\nirq_async &= ~MASK_SYS_STATUS_ESA;\r\n*r_async_escmd = 1;\r\n}\r\nif (irq_async) {\r\n*r_async_pending = 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lx_interrupt_handle_async_events(struct lx6464es *chip, u32 irqsrc,\r\nint *r_freq_changed,\r\nu64 *r_notified_in_pipe_mask,\r\nu64 *r_notified_out_pipe_mask)\r\n{\r\nint err;\r\nu32 stat[9];\r\nu64 orun_mask;\r\nu64 urun_mask;\r\nint eb_pending_out = (irqsrc & MASK_SYS_STATUS_EOBO) ? 1 : 0;\r\nint eb_pending_in = (irqsrc & MASK_SYS_STATUS_EOBI) ? 1 : 0;\r\n*r_freq_changed = (irqsrc & MASK_SYS_STATUS_FREQ) ? 1 : 0;\r\nerr = lx_dsp_read_async_events(chip, stat);\r\nif (err < 0)\r\nreturn err;\r\nif (eb_pending_in) {\r\n*r_notified_in_pipe_mask = ((u64)stat[3] << 32)\r\n+ stat[4];\r\ndev_dbg(chip->card->dev, "interrupt: EOBI pending %llx\n",\r\n*r_notified_in_pipe_mask);\r\n}\r\nif (eb_pending_out) {\r\n*r_notified_out_pipe_mask = ((u64)stat[1] << 32)\r\n+ stat[2];\r\ndev_dbg(chip->card->dev, "interrupt: EOBO pending %llx\n",\r\n*r_notified_out_pipe_mask);\r\n}\r\norun_mask = ((u64)stat[7] << 32) + stat[8];\r\nurun_mask = ((u64)stat[5] << 32) + stat[6];\r\nreturn err;\r\n}\r\nstatic int lx_interrupt_request_new_buffer(struct lx6464es *chip,\r\nstruct lx_stream *lx_stream)\r\n{\r\nstruct snd_pcm_substream *substream = lx_stream->stream;\r\nconst unsigned int is_capture = lx_stream->is_capture;\r\nint err;\r\nconst u32 channels = substream->runtime->channels;\r\nconst u32 bytes_per_frame = channels * 3;\r\nconst u32 period_size = substream->runtime->period_size;\r\nconst u32 period_bytes = period_size * bytes_per_frame;\r\nconst u32 pos = lx_stream->frame_pos;\r\nconst u32 next_pos = ((pos+1) == substream->runtime->periods) ?\r\n0 : pos + 1;\r\ndma_addr_t buf = substream->dma_buffer.addr + pos * period_bytes;\r\nu32 buf_hi = 0;\r\nu32 buf_lo = 0;\r\nu32 buffer_index = 0;\r\nu32 needed, freed;\r\nu32 size_array[MAX_STREAM_BUFFER];\r\ndev_dbg(chip->card->dev, "->lx_interrupt_request_new_buffer\n");\r\nmutex_lock(&chip->lock);\r\nerr = lx_buffer_ask(chip, 0, is_capture, &needed, &freed, size_array);\r\ndev_dbg(chip->card->dev,\r\n"interrupt: needed %d, freed %d\n", needed, freed);\r\nunpack_pointer(buf, &buf_lo, &buf_hi);\r\nerr = lx_buffer_give(chip, 0, is_capture, period_bytes, buf_lo, buf_hi,\r\n&buffer_index);\r\ndev_dbg(chip->card->dev,\r\n"interrupt: gave buffer index %x on 0x%lx (%d bytes)\n",\r\nbuffer_index, (unsigned long)buf, period_bytes);\r\nlx_stream->frame_pos = next_pos;\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}\r\nirqreturn_t lx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct lx6464es *chip = dev_id;\r\nint async_pending, async_escmd;\r\nu32 irqsrc;\r\nbool wake_thread = false;\r\ndev_dbg(chip->card->dev,\r\n"**************************************************\n");\r\nif (!lx_interrupt_ack(chip, &irqsrc, &async_pending, &async_escmd)) {\r\ndev_dbg(chip->card->dev, "IRQ_NONE\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (irqsrc & MASK_SYS_STATUS_CMD_DONE)\r\nreturn IRQ_HANDLED;\r\nif (irqsrc & MASK_SYS_STATUS_EOBI)\r\ndev_dbg(chip->card->dev, "interrupt: EOBI\n");\r\nif (irqsrc & MASK_SYS_STATUS_EOBO)\r\ndev_dbg(chip->card->dev, "interrupt: EOBO\n");\r\nif (irqsrc & MASK_SYS_STATUS_URUN)\r\ndev_dbg(chip->card->dev, "interrupt: URUN\n");\r\nif (irqsrc & MASK_SYS_STATUS_ORUN)\r\ndev_dbg(chip->card->dev, "interrupt: ORUN\n");\r\nif (async_pending) {\r\nwake_thread = true;\r\nchip->irqsrc = irqsrc;\r\n}\r\nif (async_escmd) {\r\ndev_dbg(chip->card->dev, "interrupt requests escmd handling\n");\r\n}\r\nreturn wake_thread ? IRQ_WAKE_THREAD : IRQ_HANDLED;\r\n}\r\nirqreturn_t lx_threaded_irq(int irq, void *dev_id)\r\n{\r\nstruct lx6464es *chip = dev_id;\r\nu64 notified_in_pipe_mask = 0;\r\nu64 notified_out_pipe_mask = 0;\r\nint freq_changed;\r\nint err;\r\nerr = lx_interrupt_handle_async_events(chip, chip->irqsrc,\r\n&freq_changed,\r\n&notified_in_pipe_mask,\r\n&notified_out_pipe_mask);\r\nif (err)\r\ndev_err(chip->card->dev, "error handling async events\n");\r\nif (notified_in_pipe_mask) {\r\nstruct lx_stream *lx_stream = &chip->capture_stream;\r\ndev_dbg(chip->card->dev,\r\n"requesting audio transfer for capture\n");\r\nerr = lx_interrupt_request_new_buffer(chip, lx_stream);\r\nif (err < 0)\r\ndev_err(chip->card->dev,\r\n"cannot request new buffer for capture\n");\r\nsnd_pcm_period_elapsed(lx_stream->stream);\r\n}\r\nif (notified_out_pipe_mask) {\r\nstruct lx_stream *lx_stream = &chip->playback_stream;\r\ndev_dbg(chip->card->dev,\r\n"requesting audio transfer for playback\n");\r\nerr = lx_interrupt_request_new_buffer(chip, lx_stream);\r\nif (err < 0)\r\ndev_err(chip->card->dev,\r\n"cannot request new buffer for playback\n");\r\nsnd_pcm_period_elapsed(lx_stream->stream);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void lx_irq_set(struct lx6464es *chip, int enable)\r\n{\r\nu32 reg = lx_plx_reg_read(chip, ePLX_IRQCS);\r\nif (enable)\r\nreg |= (IRQCS_ENABLE_PCIIRQ | IRQCS_ENABLE_PCIDB);\r\nelse\r\nreg &= ~(IRQCS_ENABLE_PCIIRQ | IRQCS_ENABLE_PCIDB);\r\nlx_plx_reg_write(chip, ePLX_IRQCS, reg);\r\n}\r\nvoid lx_irq_enable(struct lx6464es *chip)\r\n{\r\ndev_dbg(chip->card->dev, "->lx_irq_enable\n");\r\nlx_irq_set(chip, 1);\r\n}\r\nvoid lx_irq_disable(struct lx6464es *chip)\r\n{\r\ndev_dbg(chip->card->dev, "->lx_irq_disable\n");\r\nlx_irq_set(chip, 0);\r\n}
