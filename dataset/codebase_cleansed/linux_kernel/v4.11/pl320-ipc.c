static inline void set_destination(int source, int mbox)\r\n{\r\nwritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxDSET(mbox));\r\nwritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxMSET(mbox));\r\n}\r\nstatic inline void clear_destination(int source, int mbox)\r\n{\r\nwritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxDCLEAR(mbox));\r\nwritel_relaxed(CHAN_MASK(source), ipc_base + IPCMxMCLEAR(mbox));\r\n}\r\nstatic void __ipc_send(int mbox, u32 *data)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++)\r\nwritel_relaxed(data[i], ipc_base + IPCMxDR(mbox, i));\r\nwritel_relaxed(0x1, ipc_base + IPCMxSEND(mbox));\r\n}\r\nstatic u32 __ipc_rcv(int mbox, u32 *data)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; i++)\r\ndata[i] = readl_relaxed(ipc_base + IPCMxDR(mbox, i));\r\nreturn data[1];\r\n}\r\nint pl320_ipc_transmit(u32 *data)\r\n{\r\nint ret;\r\nmutex_lock(&ipc_m1_lock);\r\ninit_completion(&ipc_completion);\r\n__ipc_send(IPC_TX_MBOX, data);\r\nret = wait_for_completion_timeout(&ipc_completion,\r\nmsecs_to_jiffies(1000));\r\nif (ret == 0) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nret = __ipc_rcv(IPC_TX_MBOX, data);\r\nout:\r\nmutex_unlock(&ipc_m1_lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ipc_handler(int irq, void *dev)\r\n{\r\nu32 irq_stat;\r\nu32 data[7];\r\nirq_stat = readl_relaxed(ipc_base + IPCMMIS(1));\r\nif (irq_stat & MBOX_MASK(IPC_TX_MBOX)) {\r\nwritel_relaxed(0, ipc_base + IPCMxSEND(IPC_TX_MBOX));\r\ncomplete(&ipc_completion);\r\n}\r\nif (irq_stat & MBOX_MASK(IPC_RX_MBOX)) {\r\n__ipc_rcv(IPC_RX_MBOX, data);\r\natomic_notifier_call_chain(&ipc_notifier, data[0], data + 1);\r\nwritel_relaxed(2, ipc_base + IPCMxSEND(IPC_RX_MBOX));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint pl320_ipc_register_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&ipc_notifier, nb);\r\n}\r\nint pl320_ipc_unregister_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_unregister(&ipc_notifier, nb);\r\n}\r\nstatic int pl320_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nipc_base = ioremap(adev->res.start, resource_size(&adev->res));\r\nif (ipc_base == NULL)\r\nreturn -ENOMEM;\r\nwritel_relaxed(0, ipc_base + IPCMxSEND(IPC_TX_MBOX));\r\nipc_irq = adev->irq[0];\r\nret = request_irq(ipc_irq, ipc_handler, 0, dev_name(&adev->dev), NULL);\r\nif (ret < 0)\r\ngoto err;\r\nwritel_relaxed(CHAN_MASK(A9_SOURCE),\r\nipc_base + IPCMxSOURCE(IPC_TX_MBOX));\r\nwritel_relaxed(CHAN_MASK(M3_SOURCE),\r\nipc_base + IPCMxDSET(IPC_TX_MBOX));\r\nwritel_relaxed(CHAN_MASK(M3_SOURCE) | CHAN_MASK(A9_SOURCE),\r\nipc_base + IPCMxMSET(IPC_TX_MBOX));\r\nwritel_relaxed(CHAN_MASK(M3_SOURCE),\r\nipc_base + IPCMxSOURCE(IPC_RX_MBOX));\r\nwritel_relaxed(CHAN_MASK(A9_SOURCE),\r\nipc_base + IPCMxDSET(IPC_RX_MBOX));\r\nwritel_relaxed(CHAN_MASK(M3_SOURCE) | CHAN_MASK(A9_SOURCE),\r\nipc_base + IPCMxMSET(IPC_RX_MBOX));\r\nreturn 0;\r\nerr:\r\niounmap(ipc_base);\r\nreturn ret;\r\n}\r\nstatic int __init ipc_init(void)\r\n{\r\nreturn amba_driver_register(&pl320_driver);\r\n}
