static bool nf_generic_should_process(u8 proto)\r\n{\r\nswitch (proto) {\r\n#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\r\ncase IPPROTO_SCTP:\r\nreturn false;\r\n#endif\r\n#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\r\ncase IPPROTO_DCCP:\r\nreturn false;\r\n#endif\r\n#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\r\ncase IPPROTO_GRE:\r\nreturn false;\r\n#endif\r\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\r\ncase IPPROTO_UDPLITE:\r\nreturn false;\r\n#endif\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic inline struct nf_generic_net *generic_pernet(struct net *net)\r\n{\r\nreturn &net->ct.nf_ct_proto.generic;\r\n}\r\nstatic bool generic_pkt_to_tuple(const struct sk_buff *skb,\r\nunsigned int dataoff,\r\nstruct net *net, struct nf_conntrack_tuple *tuple)\r\n{\r\ntuple->src.u.all = 0;\r\ntuple->dst.u.all = 0;\r\nreturn true;\r\n}\r\nstatic bool generic_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.all = 0;\r\ntuple->dst.u.all = 0;\r\nreturn true;\r\n}\r\nstatic void generic_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\n}\r\nstatic unsigned int *generic_get_timeouts(struct net *net)\r\n{\r\nreturn &(generic_pernet(net)->timeout);\r\n}\r\nstatic int generic_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nunsigned int *timeout)\r\n{\r\nnf_ct_refresh_acct(ct, ctinfo, skb, *timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\nbool ret;\r\nret = nf_generic_should_process(nf_ct_protonum(ct));\r\nif (!ret)\r\npr_warn_once("conntrack: generic helper won't handle protocol %d. Please consider loading the specific helper module.\n",\r\nnf_ct_protonum(ct));\r\nreturn ret;\r\n}\r\nstatic int generic_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nunsigned int *timeout = data;\r\nstruct nf_generic_net *gn = generic_pernet(net);\r\nif (tb[CTA_TIMEOUT_GENERIC_TIMEOUT])\r\n*timeout =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_GENERIC_TIMEOUT])) * HZ;\r\nelse {\r\n*timeout = gn->timeout;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngeneric_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeout = data;\r\nif (nla_put_be32(skb, CTA_TIMEOUT_GENERIC_TIMEOUT, htonl(*timeout / HZ)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int generic_kmemdup_sysctl_table(struct nf_proto_net *pn,\r\nstruct nf_generic_net *gn)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\npn->ctl_table = kmemdup(generic_sysctl_table,\r\nsizeof(generic_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_table)\r\nreturn -ENOMEM;\r\npn->ctl_table[0].data = &gn->timeout;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int generic_init_net(struct net *net, u_int16_t proto)\r\n{\r\nstruct nf_generic_net *gn = generic_pernet(net);\r\nstruct nf_proto_net *pn = &gn->pn;\r\ngn->timeout = nf_ct_generic_timeout;\r\nreturn generic_kmemdup_sysctl_table(pn, gn);\r\n}\r\nstatic struct nf_proto_net *generic_get_net_proto(struct net *net)\r\n{\r\nreturn &net->ct.nf_ct_proto.generic.pn;\r\n}
