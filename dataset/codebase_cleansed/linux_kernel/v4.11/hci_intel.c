static u8 intel_convert_speed(unsigned int speed)\r\n{\r\nswitch (speed) {\r\ncase 9600:\r\nreturn 0x00;\r\ncase 19200:\r\nreturn 0x01;\r\ncase 38400:\r\nreturn 0x02;\r\ncase 57600:\r\nreturn 0x03;\r\ncase 115200:\r\nreturn 0x04;\r\ncase 230400:\r\nreturn 0x05;\r\ncase 460800:\r\nreturn 0x06;\r\ncase 921600:\r\nreturn 0x07;\r\ncase 1843200:\r\nreturn 0x08;\r\ncase 3250000:\r\nreturn 0x09;\r\ncase 2000000:\r\nreturn 0x0a;\r\ncase 3000000:\r\nreturn 0x0b;\r\ndefault:\r\nreturn 0xff;\r\n}\r\n}\r\nstatic int intel_wait_booting(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nint err;\r\nerr = wait_on_bit_timeout(&intel->flags, STATE_BOOTING,\r\nTASK_INTERRUPTIBLE,\r\nmsecs_to_jiffies(1000));\r\nif (err == -EINTR) {\r\nbt_dev_err(hu->hdev, "Device boot interrupted");\r\nreturn -EINTR;\r\n}\r\nif (err) {\r\nbt_dev_err(hu->hdev, "Device boot timeout");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn err;\r\n}\r\nstatic int intel_wait_lpm_transaction(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nint err;\r\nerr = wait_on_bit_timeout(&intel->flags, STATE_LPM_TRANSACTION,\r\nTASK_INTERRUPTIBLE,\r\nmsecs_to_jiffies(1000));\r\nif (err == -EINTR) {\r\nbt_dev_err(hu->hdev, "LPM transaction interrupted");\r\nreturn -EINTR;\r\n}\r\nif (err) {\r\nbt_dev_err(hu->hdev, "LPM transaction timeout");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn err;\r\n}\r\nstatic int intel_lpm_suspend(struct hci_uart *hu)\r\n{\r\nstatic const u8 suspend[] = { 0x01, 0x01, 0x01 };\r\nstruct intel_data *intel = hu->priv;\r\nstruct sk_buff *skb;\r\nif (!test_bit(STATE_LPM_ENABLED, &intel->flags) ||\r\ntest_bit(STATE_SUSPENDED, &intel->flags))\r\nreturn 0;\r\nif (test_bit(STATE_TX_ACTIVE, &intel->flags))\r\nreturn -EAGAIN;\r\nbt_dev_dbg(hu->hdev, "Suspending");\r\nskb = bt_skb_alloc(sizeof(suspend), GFP_KERNEL);\r\nif (!skb) {\r\nbt_dev_err(hu->hdev, "Failed to alloc memory for LPM packet");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(skb_put(skb, sizeof(suspend)), suspend, sizeof(suspend));\r\nhci_skb_pkt_type(skb) = HCI_LPM_PKT;\r\nset_bit(STATE_LPM_TRANSACTION, &intel->flags);\r\nskb_queue_head(&intel->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\nintel_wait_lpm_transaction(hu);\r\nclear_bit(STATE_LPM_TRANSACTION, &intel->flags);\r\nif (!test_bit(STATE_SUSPENDED, &intel->flags)) {\r\nbt_dev_err(hu->hdev, "Device suspend error");\r\nreturn -EINVAL;\r\n}\r\nbt_dev_dbg(hu->hdev, "Suspended");\r\nhci_uart_set_flow_control(hu, true);\r\nreturn 0;\r\n}\r\nstatic int intel_lpm_resume(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nstruct sk_buff *skb;\r\nif (!test_bit(STATE_LPM_ENABLED, &intel->flags) ||\r\n!test_bit(STATE_SUSPENDED, &intel->flags))\r\nreturn 0;\r\nbt_dev_dbg(hu->hdev, "Resuming");\r\nhci_uart_set_flow_control(hu, false);\r\nskb = bt_skb_alloc(0, GFP_KERNEL);\r\nif (!skb) {\r\nbt_dev_err(hu->hdev, "Failed to alloc memory for LPM packet");\r\nreturn -ENOMEM;\r\n}\r\nhci_skb_pkt_type(skb) = HCI_LPM_WAKE_PKT;\r\nset_bit(STATE_LPM_TRANSACTION, &intel->flags);\r\nskb_queue_head(&intel->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\nintel_wait_lpm_transaction(hu);\r\nclear_bit(STATE_LPM_TRANSACTION, &intel->flags);\r\nif (test_bit(STATE_SUSPENDED, &intel->flags)) {\r\nbt_dev_err(hu->hdev, "Device resume error");\r\nreturn -EINVAL;\r\n}\r\nbt_dev_dbg(hu->hdev, "Resumed");\r\nreturn 0;\r\n}\r\nstatic int intel_lpm_host_wake(struct hci_uart *hu)\r\n{\r\nstatic const u8 lpm_resume_ack[] = { LPM_OP_RESUME_ACK, 0x00 };\r\nstruct intel_data *intel = hu->priv;\r\nstruct sk_buff *skb;\r\nhci_uart_set_flow_control(hu, false);\r\nclear_bit(STATE_SUSPENDED, &intel->flags);\r\nskb = bt_skb_alloc(sizeof(lpm_resume_ack), GFP_KERNEL);\r\nif (!skb) {\r\nbt_dev_err(hu->hdev, "Failed to alloc memory for LPM packet");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(skb_put(skb, sizeof(lpm_resume_ack)), lpm_resume_ack,\r\nsizeof(lpm_resume_ack));\r\nhci_skb_pkt_type(skb) = HCI_LPM_PKT;\r\nskb_queue_head(&intel->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\nbt_dev_dbg(hu->hdev, "Resumed by controller");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t intel_irq(int irq, void *dev_id)\r\n{\r\nstruct intel_device *idev = dev_id;\r\ndev_info(&idev->pdev->dev, "hci_intel irq\n");\r\nmutex_lock(&idev->hu_lock);\r\nif (idev->hu)\r\nintel_lpm_host_wake(idev->hu);\r\nmutex_unlock(&idev->hu_lock);\r\npm_runtime_get(&idev->pdev->dev);\r\npm_runtime_mark_last_busy(&idev->pdev->dev);\r\npm_runtime_put_autosuspend(&idev->pdev->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int intel_set_power(struct hci_uart *hu, bool powered)\r\n{\r\nstruct list_head *p;\r\nint err = -ENODEV;\r\nmutex_lock(&intel_device_list_lock);\r\nlist_for_each(p, &intel_device_list) {\r\nstruct intel_device *idev = list_entry(p, struct intel_device,\r\nlist);\r\nif (hu->tty->dev->parent != idev->pdev->dev.parent)\r\ncontinue;\r\nif (!idev->reset) {\r\nerr = -ENOTSUPP;\r\nbreak;\r\n}\r\nBT_INFO("hu %p, Switching compatible pm device (%s) to %u",\r\nhu, dev_name(&idev->pdev->dev), powered);\r\ngpiod_set_value(idev->reset, powered);\r\nmutex_lock(&idev->hu_lock);\r\nidev->hu = powered ? hu : NULL;\r\nmutex_unlock(&idev->hu_lock);\r\nif (idev->irq < 0)\r\nbreak;\r\nif (powered && device_can_wakeup(&idev->pdev->dev)) {\r\nerr = devm_request_threaded_irq(&idev->pdev->dev,\r\nidev->irq, NULL,\r\nintel_irq,\r\nIRQF_ONESHOT,\r\n"bt-host-wake", idev);\r\nif (err) {\r\nBT_ERR("hu %p, unable to allocate irq-%d",\r\nhu, idev->irq);\r\nbreak;\r\n}\r\ndevice_wakeup_enable(&idev->pdev->dev);\r\npm_runtime_set_active(&idev->pdev->dev);\r\npm_runtime_use_autosuspend(&idev->pdev->dev);\r\npm_runtime_set_autosuspend_delay(&idev->pdev->dev,\r\nLPM_SUSPEND_DELAY_MS);\r\npm_runtime_enable(&idev->pdev->dev);\r\n} else if (!powered && device_may_wakeup(&idev->pdev->dev)) {\r\ndevm_free_irq(&idev->pdev->dev, idev->irq, idev);\r\ndevice_wakeup_disable(&idev->pdev->dev);\r\npm_runtime_disable(&idev->pdev->dev);\r\n}\r\n}\r\nmutex_unlock(&intel_device_list_lock);\r\nreturn err;\r\n}\r\nstatic void intel_busy_work(struct work_struct *work)\r\n{\r\nstruct list_head *p;\r\nstruct intel_data *intel = container_of(work, struct intel_data,\r\nbusy_work);\r\nmutex_lock(&intel_device_list_lock);\r\nlist_for_each(p, &intel_device_list) {\r\nstruct intel_device *idev = list_entry(p, struct intel_device,\r\nlist);\r\nif (intel->hu->tty->dev->parent == idev->pdev->dev.parent) {\r\npm_runtime_get(&idev->pdev->dev);\r\npm_runtime_mark_last_busy(&idev->pdev->dev);\r\npm_runtime_put_autosuspend(&idev->pdev->dev);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&intel_device_list_lock);\r\n}\r\nstatic int intel_open(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel;\r\nBT_DBG("hu %p", hu);\r\nintel = kzalloc(sizeof(*intel), GFP_KERNEL);\r\nif (!intel)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&intel->txq);\r\nINIT_WORK(&intel->busy_work, intel_busy_work);\r\nintel->hu = hu;\r\nhu->priv = intel;\r\nif (!intel_set_power(hu, true))\r\nset_bit(STATE_BOOTING, &intel->flags);\r\nreturn 0;\r\n}\r\nstatic int intel_close(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nBT_DBG("hu %p", hu);\r\ncancel_work_sync(&intel->busy_work);\r\nintel_set_power(hu, false);\r\nskb_queue_purge(&intel->txq);\r\nkfree_skb(intel->rx_skb);\r\nkfree(intel);\r\nhu->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int intel_flush(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&intel->txq);\r\nreturn 0;\r\n}\r\nstatic int inject_cmd_complete(struct hci_dev *hdev, __u16 opcode)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hci_event_hdr *hdr;\r\nstruct hci_ev_cmd_complete *evt;\r\nskb = bt_skb_alloc(sizeof(*hdr) + sizeof(*evt) + 1, GFP_ATOMIC);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (struct hci_event_hdr *)skb_put(skb, sizeof(*hdr));\r\nhdr->evt = HCI_EV_CMD_COMPLETE;\r\nhdr->plen = sizeof(*evt) + 1;\r\nevt = (struct hci_ev_cmd_complete *)skb_put(skb, sizeof(*evt));\r\nevt->ncmd = 0x01;\r\nevt->opcode = cpu_to_le16(opcode);\r\n*skb_put(skb, 1) = 0x00;\r\nhci_skb_pkt_type(skb) = HCI_EVENT_PKT;\r\nreturn hci_recv_frame(hdev, skb);\r\n}\r\nstatic int intel_set_baudrate(struct hci_uart *hu, unsigned int speed)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nstruct hci_dev *hdev = hu->hdev;\r\nu8 speed_cmd[] = { 0x06, 0xfc, 0x01, 0x00 };\r\nstruct sk_buff *skb;\r\nint err;\r\nerr = intel_wait_booting(hu);\r\nclear_bit(STATE_BOOTING, &intel->flags);\r\nif (err && err != -ETIMEDOUT)\r\nreturn err;\r\nbt_dev_info(hdev, "Change controller speed to %d", speed);\r\nspeed_cmd[3] = intel_convert_speed(speed);\r\nif (speed_cmd[3] == 0xff) {\r\nbt_dev_err(hdev, "Unsupported speed");\r\nreturn -EINVAL;\r\n}\r\nskb = __hci_cmd_sync(hdev, 0xfc05, 0, NULL, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Reading Intel version information failed (%ld)",\r\nPTR_ERR(skb));\r\nreturn PTR_ERR(skb);\r\n}\r\nkfree_skb(skb);\r\nskb = bt_skb_alloc(sizeof(speed_cmd), GFP_KERNEL);\r\nif (!skb) {\r\nbt_dev_err(hdev, "Failed to alloc memory for baudrate packet");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(skb_put(skb, sizeof(speed_cmd)), speed_cmd, sizeof(speed_cmd));\r\nhci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\r\nhci_uart_set_flow_control(hu, true);\r\nskb_queue_tail(&intel->txq, skb);\r\nhci_uart_tx_wakeup(hu);\r\nmsleep(100);\r\nhci_uart_set_baudrate(hu, speed);\r\nhci_uart_set_flow_control(hu, false);\r\nreturn 0;\r\n}\r\nstatic int intel_setup(struct hci_uart *hu)\r\n{\r\nstatic const u8 reset_param[] = { 0x00, 0x01, 0x00, 0x01,\r\n0x00, 0x08, 0x04, 0x00 };\r\nstruct intel_data *intel = hu->priv;\r\nstruct hci_dev *hdev = hu->hdev;\r\nstruct sk_buff *skb;\r\nstruct intel_version ver;\r\nstruct intel_boot_params *params;\r\nstruct list_head *p;\r\nconst struct firmware *fw;\r\nconst u8 *fw_ptr;\r\nchar fwname[64];\r\nu32 frag_len;\r\nktime_t calltime, delta, rettime;\r\nunsigned long long duration;\r\nunsigned int init_speed, oper_speed;\r\nint speed_change = 0;\r\nint err;\r\nbt_dev_dbg(hdev, "start intel_setup");\r\nhu->hdev->set_diag = btintel_set_diag;\r\nhu->hdev->set_bdaddr = btintel_set_bdaddr;\r\ncalltime = ktime_get();\r\nif (hu->init_speed)\r\ninit_speed = hu->init_speed;\r\nelse\r\ninit_speed = hu->proto->init_speed;\r\nif (hu->oper_speed)\r\noper_speed = hu->oper_speed;\r\nelse\r\noper_speed = hu->proto->oper_speed;\r\nif (oper_speed && init_speed && oper_speed != init_speed)\r\nspeed_change = 1;\r\nerr = intel_wait_booting(hu);\r\nclear_bit(STATE_BOOTING, &intel->flags);\r\nif (err && err != -ETIMEDOUT)\r\nreturn err;\r\nset_bit(STATE_BOOTLOADER, &intel->flags);\r\nerr = btintel_read_version(hdev, &ver);\r\nif (err)\r\nreturn err;\r\nif (ver.hw_platform != 0x37) {\r\nbt_dev_err(hdev, "Unsupported Intel hardware platform (%u)",\r\nver.hw_platform);\r\nreturn -EINVAL;\r\n}\r\nif (ver.hw_variant != 0x0b) {\r\nbt_dev_err(hdev, "Unsupported Intel hardware variant (%u)",\r\nver.hw_variant);\r\nreturn -EINVAL;\r\n}\r\nbtintel_version_info(hdev, &ver);\r\nif (ver.fw_variant == 0x23) {\r\nclear_bit(STATE_BOOTLOADER, &intel->flags);\r\nbtintel_check_bdaddr(hdev);\r\nreturn 0;\r\n}\r\nif (ver.fw_variant != 0x06) {\r\nbt_dev_err(hdev, "Unsupported Intel firmware variant (%u)",\r\nver.fw_variant);\r\nreturn -ENODEV;\r\n}\r\nskb = __hci_cmd_sync(hdev, 0xfc0d, 0, NULL, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nbt_dev_err(hdev, "Reading Intel boot parameters failed (%ld)",\r\nPTR_ERR(skb));\r\nreturn PTR_ERR(skb);\r\n}\r\nif (skb->len != sizeof(*params)) {\r\nbt_dev_err(hdev, "Intel boot parameters size mismatch");\r\nkfree_skb(skb);\r\nreturn -EILSEQ;\r\n}\r\nparams = (struct intel_boot_params *)skb->data;\r\nif (params->status) {\r\nbt_dev_err(hdev, "Intel boot parameters command failure (%02x)",\r\nparams->status);\r\nerr = -bt_to_errno(params->status);\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nbt_dev_info(hdev, "Device revision is %u",\r\nle16_to_cpu(params->dev_revid));\r\nbt_dev_info(hdev, "Secure boot is %s",\r\nparams->secure_boot ? "enabled" : "disabled");\r\nbt_dev_info(hdev, "Minimum firmware build %u week %u %u",\r\nparams->min_fw_build_nn, params->min_fw_build_cw,\r\n2000 + params->min_fw_build_yy);\r\nif (params->limited_cce != 0x00) {\r\nbt_dev_err(hdev, "Unsupported Intel firmware loading method (%u)",\r\nparams->limited_cce);\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!bacmp(&params->otp_bdaddr, BDADDR_ANY)) {\r\nbt_dev_info(hdev, "No device address configured");\r\nset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\r\n}\r\nsnprintf(fwname, sizeof(fwname), "intel/ibt-11-%u.sfi",\r\nle16_to_cpu(params->dev_revid));\r\nerr = request_firmware(&fw, fwname, &hdev->dev);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to load Intel firmware file (%d)",\r\nerr);\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nbt_dev_info(hdev, "Found device firmware: %s", fwname);\r\nsnprintf(fwname, sizeof(fwname), "intel/ibt-11-%u.ddc",\r\nle16_to_cpu(params->dev_revid));\r\nkfree_skb(skb);\r\nif (fw->size < 644) {\r\nbt_dev_err(hdev, "Invalid size of firmware file (%zu)",\r\nfw->size);\r\nerr = -EBADF;\r\ngoto done;\r\n}\r\nset_bit(STATE_DOWNLOADING, &intel->flags);\r\nerr = btintel_secure_send(hdev, 0x00, 128, fw->data);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to send firmware header (%d)", err);\r\ngoto done;\r\n}\r\nerr = btintel_secure_send(hdev, 0x03, 256, fw->data + 128);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to send firmware public key (%d)",\r\nerr);\r\ngoto done;\r\n}\r\nerr = btintel_secure_send(hdev, 0x02, 256, fw->data + 388);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to send firmware signature (%d)",\r\nerr);\r\ngoto done;\r\n}\r\nfw_ptr = fw->data + 644;\r\nfrag_len = 0;\r\nwhile (fw_ptr - fw->data < fw->size) {\r\nstruct hci_command_hdr *cmd = (void *)(fw_ptr + frag_len);\r\nfrag_len += sizeof(*cmd) + cmd->plen;\r\nbt_dev_dbg(hdev, "Patching %td/%zu", (fw_ptr - fw->data),\r\nfw->size);\r\nif (frag_len % 4)\r\ncontinue;\r\nerr = btintel_secure_send(hdev, 0x01, frag_len, fw_ptr);\r\nif (err < 0) {\r\nbt_dev_err(hdev, "Failed to send firmware data (%d)",\r\nerr);\r\ngoto done;\r\n}\r\nfw_ptr += frag_len;\r\nfrag_len = 0;\r\n}\r\nset_bit(STATE_FIRMWARE_LOADED, &intel->flags);\r\nbt_dev_info(hdev, "Waiting for firmware download to complete");\r\nerr = wait_on_bit_timeout(&intel->flags, STATE_DOWNLOADING,\r\nTASK_INTERRUPTIBLE,\r\nmsecs_to_jiffies(5000));\r\nif (err == -EINTR) {\r\nbt_dev_err(hdev, "Firmware loading interrupted");\r\nerr = -EINTR;\r\ngoto done;\r\n}\r\nif (err) {\r\nbt_dev_err(hdev, "Firmware loading timeout");\r\nerr = -ETIMEDOUT;\r\ngoto done;\r\n}\r\nif (test_bit(STATE_FIRMWARE_FAILED, &intel->flags)) {\r\nbt_dev_err(hdev, "Firmware loading failed");\r\nerr = -ENOEXEC;\r\ngoto done;\r\n}\r\nrettime = ktime_get();\r\ndelta = ktime_sub(rettime, calltime);\r\nduration = (unsigned long long) ktime_to_ns(delta) >> 10;\r\nbt_dev_info(hdev, "Firmware loaded in %llu usecs", duration);\r\ndone:\r\nrelease_firmware(fw);\r\nif (err < 0)\r\nreturn err;\r\nif (speed_change) {\r\nerr = intel_set_baudrate(hu, init_speed);\r\nif (err)\r\nreturn err;\r\n}\r\ncalltime = ktime_get();\r\nset_bit(STATE_BOOTING, &intel->flags);\r\nskb = __hci_cmd_sync(hdev, 0xfc01, sizeof(reset_param), reset_param,\r\nHCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nkfree_skb(skb);\r\nbt_dev_info(hdev, "Waiting for device to boot");\r\nerr = intel_wait_booting(hu);\r\nif (err)\r\nreturn err;\r\nclear_bit(STATE_BOOTING, &intel->flags);\r\nrettime = ktime_get();\r\ndelta = ktime_sub(rettime, calltime);\r\nduration = (unsigned long long) ktime_to_ns(delta) >> 10;\r\nbt_dev_info(hdev, "Device booted in %llu usecs", duration);\r\nmutex_lock(&intel_device_list_lock);\r\nlist_for_each(p, &intel_device_list) {\r\nstruct intel_device *dev = list_entry(p, struct intel_device,\r\nlist);\r\nif (hu->tty->dev->parent == dev->pdev->dev.parent) {\r\nif (device_may_wakeup(&dev->pdev->dev)) {\r\nset_bit(STATE_LPM_ENABLED, &intel->flags);\r\nset_bit(STATE_TX_ACTIVE, &intel->flags);\r\n}\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&intel_device_list_lock);\r\nbtintel_load_ddc_config(hdev, fwname);\r\nskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_CMD_TIMEOUT);\r\nif (IS_ERR(skb))\r\nreturn PTR_ERR(skb);\r\nkfree_skb(skb);\r\nif (speed_change) {\r\nerr = intel_set_baudrate(hu, oper_speed);\r\nif (err)\r\nreturn err;\r\n}\r\nbt_dev_info(hdev, "Setup complete");\r\nclear_bit(STATE_BOOTLOADER, &intel->flags);\r\nreturn 0;\r\n}\r\nstatic int intel_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct intel_data *intel = hu->priv;\r\nstruct hci_event_hdr *hdr;\r\nif (!test_bit(STATE_BOOTLOADER, &intel->flags) &&\r\n!test_bit(STATE_BOOTING, &intel->flags))\r\ngoto recv;\r\nhdr = (void *)skb->data;\r\nif (skb->len == 7 && hdr->evt == 0xff && hdr->plen == 0x05 &&\r\nskb->data[2] == 0x06) {\r\nif (skb->data[3] != 0x00)\r\nset_bit(STATE_FIRMWARE_FAILED, &intel->flags);\r\nif (test_and_clear_bit(STATE_DOWNLOADING, &intel->flags) &&\r\ntest_bit(STATE_FIRMWARE_LOADED, &intel->flags)) {\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&intel->flags, STATE_DOWNLOADING);\r\n}\r\n} else if (skb->len == 9 && hdr->evt == 0xff && hdr->plen == 0x07 &&\r\nskb->data[2] == 0x02) {\r\nif (test_and_clear_bit(STATE_BOOTING, &intel->flags)) {\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&intel->flags, STATE_BOOTING);\r\n}\r\n}\r\nrecv:\r\nreturn hci_recv_frame(hdev, skb);\r\n}\r\nstatic void intel_recv_lpm_notify(struct hci_dev *hdev, int value)\r\n{\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct intel_data *intel = hu->priv;\r\nbt_dev_dbg(hdev, "TX idle notification (%d)", value);\r\nif (value) {\r\nset_bit(STATE_TX_ACTIVE, &intel->flags);\r\nschedule_work(&intel->busy_work);\r\n} else {\r\nclear_bit(STATE_TX_ACTIVE, &intel->flags);\r\n}\r\n}\r\nstatic int intel_recv_lpm(struct hci_dev *hdev, struct sk_buff *skb)\r\n{\r\nstruct hci_lpm_pkt *lpm = (void *)skb->data;\r\nstruct hci_uart *hu = hci_get_drvdata(hdev);\r\nstruct intel_data *intel = hu->priv;\r\nswitch (lpm->opcode) {\r\ncase LPM_OP_TX_NOTIFY:\r\nif (lpm->dlen < 1) {\r\nbt_dev_err(hu->hdev, "Invalid LPM notification packet");\r\nbreak;\r\n}\r\nintel_recv_lpm_notify(hdev, lpm->data[0]);\r\nbreak;\r\ncase LPM_OP_SUSPEND_ACK:\r\nset_bit(STATE_SUSPENDED, &intel->flags);\r\nif (test_and_clear_bit(STATE_LPM_TRANSACTION, &intel->flags)) {\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&intel->flags, STATE_LPM_TRANSACTION);\r\n}\r\nbreak;\r\ncase LPM_OP_RESUME_ACK:\r\nclear_bit(STATE_SUSPENDED, &intel->flags);\r\nif (test_and_clear_bit(STATE_LPM_TRANSACTION, &intel->flags)) {\r\nsmp_mb__after_atomic();\r\nwake_up_bit(&intel->flags, STATE_LPM_TRANSACTION);\r\n}\r\nbreak;\r\ndefault:\r\nbt_dev_err(hdev, "Unknown LPM opcode (%02x)", lpm->opcode);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int intel_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\r\nreturn -EUNATCH;\r\nintel->rx_skb = h4_recv_buf(hu->hdev, intel->rx_skb, data, count,\r\nintel_recv_pkts,\r\nARRAY_SIZE(intel_recv_pkts));\r\nif (IS_ERR(intel->rx_skb)) {\r\nint err = PTR_ERR(intel->rx_skb);\r\nbt_dev_err(hu->hdev, "Frame reassembly failed (%d)", err);\r\nintel->rx_skb = NULL;\r\nreturn err;\r\n}\r\nreturn count;\r\n}\r\nstatic int intel_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nstruct list_head *p;\r\nBT_DBG("hu %p skb %p", hu, skb);\r\nmutex_lock(&intel_device_list_lock);\r\nlist_for_each(p, &intel_device_list) {\r\nstruct intel_device *idev = list_entry(p, struct intel_device,\r\nlist);\r\nif (hu->tty->dev->parent == idev->pdev->dev.parent) {\r\npm_runtime_get_sync(&idev->pdev->dev);\r\npm_runtime_mark_last_busy(&idev->pdev->dev);\r\npm_runtime_put_autosuspend(&idev->pdev->dev);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&intel_device_list_lock);\r\nskb_queue_tail(&intel->txq, skb);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *intel_dequeue(struct hci_uart *hu)\r\n{\r\nstruct intel_data *intel = hu->priv;\r\nstruct sk_buff *skb;\r\nskb = skb_dequeue(&intel->txq);\r\nif (!skb)\r\nreturn skb;\r\nif (test_bit(STATE_BOOTLOADER, &intel->flags) &&\r\n(hci_skb_pkt_type(skb) == HCI_COMMAND_PKT)) {\r\nstruct hci_command_hdr *cmd = (void *)skb->data;\r\n__u16 opcode = le16_to_cpu(cmd->opcode);\r\nif (opcode == 0xfc01)\r\ninject_cmd_complete(hu->hdev, opcode);\r\n}\r\nmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\r\nreturn skb;\r\n}\r\nstatic int intel_suspend_device(struct device *dev)\r\n{\r\nstruct intel_device *idev = dev_get_drvdata(dev);\r\nmutex_lock(&idev->hu_lock);\r\nif (idev->hu)\r\nintel_lpm_suspend(idev->hu);\r\nmutex_unlock(&idev->hu_lock);\r\nreturn 0;\r\n}\r\nstatic int intel_resume_device(struct device *dev)\r\n{\r\nstruct intel_device *idev = dev_get_drvdata(dev);\r\nmutex_lock(&idev->hu_lock);\r\nif (idev->hu)\r\nintel_lpm_resume(idev->hu);\r\nmutex_unlock(&idev->hu_lock);\r\nreturn 0;\r\n}\r\nstatic int intel_suspend(struct device *dev)\r\n{\r\nstruct intel_device *idev = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(idev->irq);\r\nreturn intel_suspend_device(dev);\r\n}\r\nstatic int intel_resume(struct device *dev)\r\n{\r\nstruct intel_device *idev = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(idev->irq);\r\nreturn intel_resume_device(dev);\r\n}\r\nstatic int intel_probe(struct platform_device *pdev)\r\n{\r\nstruct intel_device *idev;\r\nidev = devm_kzalloc(&pdev->dev, sizeof(*idev), GFP_KERNEL);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nmutex_init(&idev->hu_lock);\r\nidev->pdev = pdev;\r\nidev->reset = devm_gpiod_get(&pdev->dev, "reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(idev->reset)) {\r\ndev_err(&pdev->dev, "Unable to retrieve gpio\n");\r\nreturn PTR_ERR(idev->reset);\r\n}\r\nidev->irq = platform_get_irq(pdev, 0);\r\nif (idev->irq < 0) {\r\nstruct gpio_desc *host_wake;\r\ndev_err(&pdev->dev, "No IRQ, falling back to gpio-irq\n");\r\nhost_wake = devm_gpiod_get(&pdev->dev, "host-wake", GPIOD_IN);\r\nif (IS_ERR(host_wake)) {\r\ndev_err(&pdev->dev, "Unable to retrieve IRQ\n");\r\ngoto no_irq;\r\n}\r\nidev->irq = gpiod_to_irq(host_wake);\r\nif (idev->irq < 0) {\r\ndev_err(&pdev->dev, "No corresponding irq for gpio\n");\r\ngoto no_irq;\r\n}\r\n}\r\ndevice_set_wakeup_capable(&pdev->dev, true);\r\ndevice_wakeup_disable(&pdev->dev);\r\nno_irq:\r\nplatform_set_drvdata(pdev, idev);\r\nmutex_lock(&intel_device_list_lock);\r\nlist_add_tail(&idev->list, &intel_device_list);\r\nmutex_unlock(&intel_device_list_lock);\r\ndev_info(&pdev->dev, "registered, gpio(%d)/irq(%d).\n",\r\ndesc_to_gpio(idev->reset), idev->irq);\r\nreturn 0;\r\n}\r\nstatic int intel_remove(struct platform_device *pdev)\r\n{\r\nstruct intel_device *idev = platform_get_drvdata(pdev);\r\ndevice_wakeup_disable(&pdev->dev);\r\nmutex_lock(&intel_device_list_lock);\r\nlist_del(&idev->list);\r\nmutex_unlock(&intel_device_list_lock);\r\ndev_info(&pdev->dev, "unregistered.\n");\r\nreturn 0;\r\n}\r\nint __init intel_init(void)\r\n{\r\nplatform_driver_register(&intel_driver);\r\nreturn hci_uart_register_proto(&intel_proto);\r\n}\r\nint __exit intel_deinit(void)\r\n{\r\nplatform_driver_unregister(&intel_driver);\r\nreturn hci_uart_unregister_proto(&intel_proto);\r\n}
