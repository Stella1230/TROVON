static void vsc_read(adapter_t *adapter, u32 addr, u32 *val)\r\n{\r\nu32 status, vlo, vhi;\r\nint i;\r\nspin_lock_bh(&adapter->mac_lock);\r\nt1_tpi_read(adapter, (addr << 2) + 4, &vlo);\r\ni = 0;\r\ndo {\r\nt1_tpi_read(adapter, (REG_LOCAL_STATUS << 2) + 4, &vlo);\r\nt1_tpi_read(adapter, REG_LOCAL_STATUS << 2, &vhi);\r\nstatus = (vhi << 16) | vlo;\r\ni++;\r\n} while (((status & 1) == 0) && (i < 50));\r\nif (i == 50)\r\npr_err("Invalid tpi read from MAC, breaking loop.\n");\r\nt1_tpi_read(adapter, (REG_LOCAL_DATA << 2) + 4, &vlo);\r\nt1_tpi_read(adapter, REG_LOCAL_DATA << 2, &vhi);\r\n*val = (vhi << 16) | vlo;\r\nspin_unlock_bh(&adapter->mac_lock);\r\n}\r\nstatic void vsc_write(adapter_t *adapter, u32 addr, u32 data)\r\n{\r\nspin_lock_bh(&adapter->mac_lock);\r\nt1_tpi_write(adapter, (addr << 2) + 4, data & 0xFFFF);\r\nt1_tpi_write(adapter, addr << 2, (data >> 16) & 0xFFFF);\r\nspin_unlock_bh(&adapter->mac_lock);\r\n}\r\nstatic void vsc7326_full_reset(adapter_t* adapter)\r\n{\r\nu32 val;\r\nu32 result = 0xffff;\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~1;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(2);\r\nval |= 0x1;\r\nval |= 0x800;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nmdelay(1);\r\nvsc_write(adapter, REG_SW_RESET, 0x80000001);\r\ndo {\r\nmdelay(1);\r\nvsc_read(adapter, REG_SW_RESET, &result);\r\n} while (result != 0x0);\r\n}\r\nstatic void run_table(adapter_t *adapter, struct init_table *ib, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (ib[i].addr == INITBLOCK_SLEEP) {\r\nudelay( ib[i].data );\r\npr_err("sleep %d us\n",ib[i].data);\r\n} else\r\nvsc_write( adapter, ib[i].addr, ib[i].data );\r\n}\r\n}\r\nstatic int bist_rd(adapter_t *adapter, int moduleid, int address)\r\n{\r\nint data = 0;\r\nu32 result = 0;\r\nif ((address != 0x0) &&\r\n(address != 0x1) &&\r\n(address != 0x2) &&\r\n(address != 0xd) &&\r\n(address != 0xe))\r\npr_err("No bist address: 0x%x\n", address);\r\ndata = ((0x00 << 24) | ((address & 0xff) << 16) | (0x00 << 8) |\r\n((moduleid & 0xff) << 0));\r\nvsc_write(adapter, REG_RAM_BIST_CMD, data);\r\nudelay(10);\r\nvsc_read(adapter, REG_RAM_BIST_RESULT, &result);\r\nif ((result & (1 << 9)) != 0x0)\r\npr_err("Still in bist read: 0x%x\n", result);\r\nelse if ((result & (1 << 8)) != 0x0)\r\npr_err("bist read error: 0x%x\n", result);\r\nreturn result & 0xff;\r\n}\r\nstatic int bist_wr(adapter_t *adapter, int moduleid, int address, int value)\r\n{\r\nint data = 0;\r\nu32 result = 0;\r\nif ((address != 0x0) &&\r\n(address != 0x1) &&\r\n(address != 0x2) &&\r\n(address != 0xd) &&\r\n(address != 0xe))\r\npr_err("No bist address: 0x%x\n", address);\r\nif (value > 255)\r\npr_err("Suspicious write out of range value: 0x%x\n", value);\r\ndata = ((0x01 << 24) | ((address & 0xff) << 16) | (value << 8) |\r\n((moduleid & 0xff) << 0));\r\nvsc_write(adapter, REG_RAM_BIST_CMD, data);\r\nudelay(5);\r\nvsc_read(adapter, REG_RAM_BIST_CMD, &result);\r\nif ((result & (1 << 27)) != 0x0)\r\npr_err("Still in bist write: 0x%x\n", result);\r\nelse if ((result & (1 << 26)) != 0x0)\r\npr_err("bist write error: 0x%x\n", result);\r\nreturn 0;\r\n}\r\nstatic int run_bist(adapter_t *adapter, int moduleid)\r\n{\r\n(void) bist_wr(adapter,moduleid, 0x00, 0x02);\r\n(void) bist_wr(adapter,moduleid, 0x01, 0x01);\r\nreturn 0;\r\n}\r\nstatic int check_bist(adapter_t *adapter, int moduleid)\r\n{\r\nint result=0;\r\nint column=0;\r\nresult = bist_rd(adapter,moduleid, 0x02);\r\ncolumn = ((bist_rd(adapter,moduleid, 0x0e)<<8) +\r\n(bist_rd(adapter,moduleid, 0x0d)));\r\nif ((result & 3) != 0x3)\r\npr_err("Result: 0x%x BIST error in ram %d, column: 0x%04x\n",\r\nresult, moduleid, column);\r\nreturn 0;\r\n}\r\nstatic int enable_mem(adapter_t *adapter, int moduleid)\r\n{\r\n(void) bist_wr(adapter,moduleid, 0x00, 0x00);\r\nreturn 0;\r\n}\r\nstatic int run_bist_all(adapter_t *adapter)\r\n{\r\nint port = 0;\r\nu32 val = 0;\r\nvsc_write(adapter, REG_MEM_BIST, 0x5);\r\nvsc_read(adapter, REG_MEM_BIST, &val);\r\nfor (port = 0; port < 12; port++)\r\nvsc_write(adapter, REG_DEV_SETUP(port), 0x0);\r\nudelay(300);\r\nvsc_write(adapter, REG_SPI4_MISC, 0x00040409);\r\nudelay(300);\r\n(void) run_bist(adapter,13);\r\n(void) run_bist(adapter,14);\r\n(void) run_bist(adapter,20);\r\n(void) run_bist(adapter,21);\r\nmdelay(200);\r\n(void) check_bist(adapter,13);\r\n(void) check_bist(adapter,14);\r\n(void) check_bist(adapter,20);\r\n(void) check_bist(adapter,21);\r\nudelay(100);\r\n(void) enable_mem(adapter,13);\r\n(void) enable_mem(adapter,14);\r\n(void) enable_mem(adapter,20);\r\n(void) enable_mem(adapter,21);\r\nudelay(300);\r\nvsc_write(adapter, REG_SPI4_MISC, 0x60040400);\r\nudelay(300);\r\nfor (port = 0; port < 12; port++)\r\nvsc_write(adapter, REG_DEV_SETUP(port), 0x1);\r\nudelay(300);\r\nvsc_write(adapter, REG_MEM_BIST, 0x0);\r\nmdelay(10);\r\nreturn 0;\r\n}\r\nstatic int mac_intr_handler(struct cmac *mac)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mac_intr_enable(struct cmac *mac)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mac_intr_disable(struct cmac *mac)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mac_intr_clear(struct cmac *mac)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mac_set_address(struct cmac* mac, u8 addr[6])\r\n{\r\nu32 val;\r\nint port = mac->instance->index;\r\nvsc_write(mac->adapter, REG_MAC_LOW_ADDR(port),\r\n(addr[3] << 16) | (addr[4] << 8) | addr[5]);\r\nvsc_write(mac->adapter, REG_MAC_HIGH_ADDR(port),\r\n(addr[0] << 16) | (addr[1] << 8) | addr[2]);\r\nvsc_read(mac->adapter, REG_ING_FFILT_UM_EN, &val);\r\nval &= ~0xf0000000;\r\nvsc_write(mac->adapter, REG_ING_FFILT_UM_EN, val | (port << 28));\r\nvsc_write(mac->adapter, REG_ING_FFILT_MASK0,\r\n0xffff0000 | (addr[4] << 8) | addr[5]);\r\nvsc_write(mac->adapter, REG_ING_FFILT_MASK1,\r\n0xffff0000 | (addr[2] << 8) | addr[3]);\r\nvsc_write(mac->adapter, REG_ING_FFILT_MASK2,\r\n0xffff0000 | (addr[0] << 8) | addr[1]);\r\nreturn 0;\r\n}\r\nstatic int mac_get_address(struct cmac *mac, u8 addr[6])\r\n{\r\nu32 addr_lo, addr_hi;\r\nint port = mac->instance->index;\r\nvsc_read(mac->adapter, REG_MAC_LOW_ADDR(port), &addr_lo);\r\nvsc_read(mac->adapter, REG_MAC_HIGH_ADDR(port), &addr_hi);\r\naddr[0] = (u8) (addr_hi >> 16);\r\naddr[1] = (u8) (addr_hi >> 8);\r\naddr[2] = (u8) addr_hi;\r\naddr[3] = (u8) (addr_lo >> 16);\r\naddr[4] = (u8) (addr_lo >> 8);\r\naddr[5] = (u8) addr_lo;\r\nreturn 0;\r\n}\r\nstatic int mac_reset(struct cmac *mac)\r\n{\r\nint index = mac->instance->index;\r\nrun_table(mac->adapter, vsc7326_portinit[index],\r\nARRAY_SIZE(vsc7326_portinit[index]));\r\nreturn 0;\r\n}\r\nstatic int mac_set_rx_mode(struct cmac *mac, struct t1_rx_mode *rm)\r\n{\r\nu32 v;\r\nint port = mac->instance->index;\r\nvsc_read(mac->adapter, REG_ING_FFILT_UM_EN, &v);\r\nv |= 1 << 12;\r\nif (t1_rx_mode_promisc(rm))\r\nv &= ~(1 << (port + 16));\r\nelse\r\nv |= 1 << (port + 16);\r\nvsc_write(mac->adapter, REG_ING_FFILT_UM_EN, v);\r\nreturn 0;\r\n}\r\nstatic int mac_set_mtu(struct cmac *mac, int mtu)\r\n{\r\nint port = mac->instance->index;\r\nvsc_write(mac->adapter, REG_MAX_LEN(port), mtu + 14 + 4);\r\nreturn 0;\r\n}\r\nstatic int mac_set_speed_duplex_fc(struct cmac *mac, int speed, int duplex,\r\nint fc)\r\n{\r\nu32 v;\r\nint enable, port = mac->instance->index;\r\nif (speed >= 0 && speed != SPEED_10 && speed != SPEED_100 &&\r\nspeed != SPEED_1000)\r\nreturn -1;\r\nif (duplex > 0 && duplex != DUPLEX_FULL)\r\nreturn -1;\r\nif (speed >= 0) {\r\nvsc_read(mac->adapter, REG_MODE_CFG(port), &v);\r\nenable = v & 3;\r\nv &= ~0xf;\r\nv |= 4;\r\nif (speed == SPEED_1000)\r\nv |= 8;\r\nenable |= v;\r\nvsc_write(mac->adapter, REG_MODE_CFG(port), v);\r\nif (speed == SPEED_1000)\r\nv = 0x82;\r\nelse if (speed == SPEED_100)\r\nv = 0x84;\r\nelse\r\nv = 0x86;\r\nvsc_write(mac->adapter, REG_DEV_SETUP(port), v | 1);\r\nvsc_write(mac->adapter, REG_DEV_SETUP(port), v);\r\nvsc_read(mac->adapter, REG_DBG(port), &v);\r\nv &= ~0xff00;\r\nif (speed == SPEED_1000)\r\nv |= 0x400;\r\nelse if (speed == SPEED_100)\r\nv |= 0x2000;\r\nelse\r\nv |= 0xff00;\r\nvsc_write(mac->adapter, REG_DBG(port), v);\r\nvsc_write(mac->adapter, REG_TX_IFG(port),\r\nspeed == SPEED_1000 ? 5 : 0x11);\r\nif (duplex == DUPLEX_HALF)\r\nenable = 0x0;\r\nelse if (speed == SPEED_1000)\r\nenable = 0xc;\r\nelse\r\nenable = 0x4;\r\nenable |= 0x9 << 10;\r\nenable |= 0x6 << 6;\r\nenable |= 0x1 << 4;\r\nenable |= 0x3;\r\nvsc_write(mac->adapter, REG_MODE_CFG(port), enable);\r\n}\r\nvsc_read(mac->adapter, REG_PAUSE_CFG(port), &v);\r\nv &= 0xfff0ffff;\r\nv |= 0x20000;\r\nif (fc & PAUSE_RX)\r\nv |= 0x40000;\r\nif (fc & PAUSE_TX)\r\nv |= 0x80000;\r\nif (fc == (PAUSE_RX | PAUSE_TX))\r\nv |= 0x10000;\r\nvsc_write(mac->adapter, REG_PAUSE_CFG(port), v);\r\nreturn 0;\r\n}\r\nstatic int mac_enable(struct cmac *mac, int which)\r\n{\r\nu32 val;\r\nint port = mac->instance->index;\r\nvsc_write(mac->adapter, REG_HIGH_LOW_WM(1,port), WM_ENABLE);\r\nvsc_read(mac->adapter, REG_MODE_CFG(port), &val);\r\nif (which & MAC_DIRECTION_RX)\r\nval |= 0x2;\r\nif (which & MAC_DIRECTION_TX)\r\nval |= 1;\r\nvsc_write(mac->adapter, REG_MODE_CFG(port), val);\r\nreturn 0;\r\n}\r\nstatic int mac_disable(struct cmac *mac, int which)\r\n{\r\nu32 val;\r\nint i, port = mac->instance->index;\r\nmac_reset(mac);\r\nvsc_read(mac->adapter, REG_MODE_CFG(port), &val);\r\nif (which & MAC_DIRECTION_RX)\r\nval &= ~0x2;\r\nif (which & MAC_DIRECTION_TX)\r\nval &= ~0x1;\r\nvsc_write(mac->adapter, REG_MODE_CFG(port), val);\r\nvsc_read(mac->adapter, REG_MODE_CFG(port), &val);\r\nfor (i = 0; i <= 0x3a; ++i)\r\nvsc_write(mac->adapter, CRA(4, port, i), 0);\r\nmemset(&mac->stats, 0, sizeof(struct cmac_statistics));\r\nreturn 0;\r\n}\r\nstatic void rmon_update(struct cmac *mac, unsigned int addr, u64 *stat)\r\n{\r\nu32 v, lo;\r\nvsc_read(mac->adapter, addr, &v);\r\nlo = *stat;\r\n*stat = *stat - lo + v;\r\nif (v == 0)\r\nreturn;\r\nif (v < lo)\r\n*stat += (1ULL << 32);\r\n}\r\nstatic void port_stats_update(struct cmac *mac)\r\n{\r\nstruct {\r\nunsigned int reg;\r\nunsigned int offset;\r\n} hw_stats[] = {\r\n#define HW_STAT(reg, stat_name) \\r\n{ reg, (&((struct cmac_statistics *)NULL)->stat_name) - (u64 *)NULL }\r\nHW_STAT(RxUnicast, RxUnicastFramesOK),\r\nHW_STAT(RxMulticast, RxMulticastFramesOK),\r\nHW_STAT(RxBroadcast, RxBroadcastFramesOK),\r\nHW_STAT(Crc, RxFCSErrors),\r\nHW_STAT(RxAlignment, RxAlignErrors),\r\nHW_STAT(RxOversize, RxFrameTooLongErrors),\r\nHW_STAT(RxPause, RxPauseFrames),\r\nHW_STAT(RxJabbers, RxJabberErrors),\r\nHW_STAT(RxFragments, RxRuntErrors),\r\nHW_STAT(RxUndersize, RxRuntErrors),\r\nHW_STAT(RxSymbolCarrier, RxSymbolErrors),\r\nHW_STAT(RxSize1519ToMax, RxJumboFramesOK),\r\nHW_STAT(TxUnicast, TxUnicastFramesOK),\r\nHW_STAT(TxMulticast, TxMulticastFramesOK),\r\nHW_STAT(TxBroadcast, TxBroadcastFramesOK),\r\nHW_STAT(TxPause, TxPauseFrames),\r\nHW_STAT(TxUnderrun, TxUnderrun),\r\nHW_STAT(TxSize1519ToMax, TxJumboFramesOK),\r\n}, *p = hw_stats;\r\nunsigned int port = mac->instance->index;\r\nu64 *stats = (u64 *)&mac->stats;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(hw_stats); i++)\r\nrmon_update(mac, CRA(0x4, port, p->reg), stats + p->offset);\r\nrmon_update(mac, REG_TX_OK_BYTES(port), &mac->stats.TxOctetsOK);\r\nrmon_update(mac, REG_RX_OK_BYTES(port), &mac->stats.RxOctetsOK);\r\nrmon_update(mac, REG_RX_BAD_BYTES(port), &mac->stats.RxOctetsBad);\r\n}\r\nstatic const struct cmac_statistics *mac_update_statistics(struct cmac *mac,\r\nint flag)\r\n{\r\nif (flag == MAC_STATS_UPDATE_FULL ||\r\nmac->instance->ticks >= MAJOR_UPDATE_TICKS) {\r\nport_stats_update(mac);\r\nmac->instance->ticks = 0;\r\n} else {\r\nint port = mac->instance->index;\r\nrmon_update(mac, REG_RX_OK_BYTES(port),\r\n&mac->stats.RxOctetsOK);\r\nrmon_update(mac, REG_RX_BAD_BYTES(port),\r\n&mac->stats.RxOctetsBad);\r\nrmon_update(mac, REG_TX_OK_BYTES(port),\r\n&mac->stats.TxOctetsOK);\r\nmac->instance->ticks++;\r\n}\r\nreturn &mac->stats;\r\n}\r\nstatic void mac_destroy(struct cmac *mac)\r\n{\r\nkfree(mac);\r\n}\r\nstatic struct cmac *vsc7326_mac_create(adapter_t *adapter, int index)\r\n{\r\nstruct cmac *mac;\r\nu32 val;\r\nint i;\r\nmac = kzalloc(sizeof(*mac) + sizeof(cmac_instance), GFP_KERNEL);\r\nif (!mac)\r\nreturn NULL;\r\nmac->ops = &vsc7326_ops;\r\nmac->instance = (cmac_instance *)(mac + 1);\r\nmac->adapter = adapter;\r\nmac->instance->index = index;\r\nmac->instance->ticks = 0;\r\ni = 0;\r\ndo {\r\nu32 vhi, vlo;\r\nvhi = vlo = 0;\r\nt1_tpi_read(adapter, (REG_LOCAL_STATUS << 2) + 4, &vlo);\r\nudelay(1);\r\nt1_tpi_read(adapter, REG_LOCAL_STATUS << 2, &vhi);\r\nudelay(5);\r\nval = (vhi << 16) | vlo;\r\n} while ((++i < 10000) && (val == 0xffffffff));\r\nreturn mac;\r\n}\r\nstatic int vsc7326_mac_reset(adapter_t *adapter)\r\n{\r\nvsc7326_full_reset(adapter);\r\n(void) run_bist_all(adapter);\r\nrun_table(adapter, vsc7326_reset, ARRAY_SIZE(vsc7326_reset));\r\nreturn 0;\r\n}
