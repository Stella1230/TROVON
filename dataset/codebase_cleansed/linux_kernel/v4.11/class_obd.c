int lustre_get_jobid(char *jobid)\r\n{\r\nmemset(jobid, 0, LUSTRE_JOBID_SIZE);\r\nif (strcmp(obd_jobid_var, JOBSTATS_DISABLE) == 0)\r\nreturn 0;\r\nif (strcmp(obd_jobid_var, JOBSTATS_PROCNAME_UID) == 0) {\r\nsnprintf(jobid, LUSTRE_JOBID_SIZE, "%s.%u",\r\ncurrent_comm(),\r\nfrom_kuid(&init_user_ns, current_fsuid()));\r\nreturn 0;\r\n}\r\nif (strcmp(obd_jobid_var, JOBSTATS_NODELOCAL) == 0) {\r\nstrcpy(jobid, obd_jobid_node);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int class_resolve_dev_name(__u32 len, const char *name)\r\n{\r\nint rc;\r\nint dev;\r\nif (!len || !name) {\r\nCERROR("No name passed,!\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (name[len - 1] != 0) {\r\nCERROR("Name not nul terminated!\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nCDEBUG(D_IOCTL, "device name %s\n", name);\r\ndev = class_name2dev(name);\r\nif (dev == -1) {\r\nCDEBUG(D_IOCTL, "No device for name %s!\n", name);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nCDEBUG(D_IOCTL, "device name %s, dev %d\n", name, dev);\r\nrc = dev;\r\nout:\r\nreturn rc;\r\n}\r\nint class_handle_ioctl(unsigned int cmd, unsigned long arg)\r\n{\r\nchar *buf = NULL;\r\nstruct obd_ioctl_data *data;\r\nstruct libcfs_debug_ioctl_data *debug_data;\r\nstruct obd_device *obd = NULL;\r\nint err = 0, len = 0;\r\nif (cmd == LIBCFS_IOC_DEBUG_MASK) {\r\ndebug_data = (struct libcfs_debug_ioctl_data *)arg;\r\nlibcfs_subsystem_debug = debug_data->subs;\r\nlibcfs_debug = debug_data->debug;\r\nreturn 0;\r\n}\r\nCDEBUG(D_IOCTL, "cmd = %x\n", cmd);\r\nif (obd_ioctl_getdata(&buf, &len, (void __user *)arg)) {\r\nCERROR("OBD ioctl: data error\n");\r\nreturn -EINVAL;\r\n}\r\ndata = (struct obd_ioctl_data *)buf;\r\nswitch (cmd) {\r\ncase OBD_IOC_PROCESS_CFG: {\r\nstruct lustre_cfg *lcfg;\r\nif (!data->ioc_plen1 || !data->ioc_pbuf1) {\r\nCERROR("No config buffer passed!\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nlcfg = kzalloc(data->ioc_plen1, GFP_NOFS);\r\nif (!lcfg) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = copy_from_user(lcfg, data->ioc_pbuf1, data->ioc_plen1);\r\nif (!err)\r\nerr = lustre_cfg_sanity_check(lcfg, data->ioc_plen1);\r\nif (!err)\r\nerr = class_process_config(lcfg);\r\nkfree(lcfg);\r\ngoto out;\r\n}\r\ncase OBD_GET_VERSION:\r\nif (!data->ioc_inlbuf1) {\r\nCERROR("No buffer passed in ioctl\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (strlen(LUSTRE_VERSION_STRING) + 1 > data->ioc_inllen1) {\r\nCERROR("ioctl buffer too small to hold version\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(data->ioc_bulk, LUSTRE_VERSION_STRING,\r\nstrlen(LUSTRE_VERSION_STRING) + 1);\r\nerr = obd_ioctl_popdata((void __user *)arg, data, len);\r\nif (err)\r\nerr = -EFAULT;\r\ngoto out;\r\ncase OBD_IOC_NAME2DEV: {\r\nint dev;\r\ndev = class_resolve_dev_name(data->ioc_inllen1,\r\ndata->ioc_inlbuf1);\r\ndata->ioc_dev = dev;\r\nif (dev < 0) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = obd_ioctl_popdata((void __user *)arg, data,\r\nsizeof(*data));\r\nif (err)\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\ncase OBD_IOC_UUID2DEV: {\r\nint dev;\r\nstruct obd_uuid uuid;\r\nif (!data->ioc_inllen1 || !data->ioc_inlbuf1) {\r\nCERROR("No UUID passed!\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (data->ioc_inlbuf1[data->ioc_inllen1 - 1] != 0) {\r\nCERROR("UUID not NUL terminated!\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nCDEBUG(D_IOCTL, "device name %s\n", data->ioc_inlbuf1);\r\nobd_str2uuid(&uuid, data->ioc_inlbuf1);\r\ndev = class_uuid2dev(&uuid);\r\ndata->ioc_dev = dev;\r\nif (dev == -1) {\r\nCDEBUG(D_IOCTL, "No device for UUID %s!\n",\r\ndata->ioc_inlbuf1);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nCDEBUG(D_IOCTL, "device name %s, dev %d\n", data->ioc_inlbuf1,\r\ndev);\r\nerr = obd_ioctl_popdata((void __user *)arg, data,\r\nsizeof(*data));\r\nif (err)\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\ncase OBD_IOC_GETDEVICE: {\r\nint index = data->ioc_count;\r\nchar *status, *str;\r\nif (!data->ioc_inlbuf1) {\r\nCERROR("No buffer passed in ioctl\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (data->ioc_inllen1 < 128) {\r\nCERROR("ioctl buffer too small to hold version\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nobd = class_num2obd(index);\r\nif (!obd) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nif (obd->obd_stopping)\r\nstatus = "ST";\r\nelse if (obd->obd_set_up)\r\nstatus = "UP";\r\nelse if (obd->obd_attached)\r\nstatus = "AT";\r\nelse\r\nstatus = "--";\r\nstr = (char *)data->ioc_bulk;\r\nsnprintf(str, len - sizeof(*data), "%3d %s %s %s %s %d",\r\n(int)index, status, obd->obd_type->typ_name,\r\nobd->obd_name, obd->obd_uuid.uuid,\r\natomic_read(&obd->obd_refcount));\r\nerr = obd_ioctl_popdata((void __user *)arg, data, len);\r\nerr = 0;\r\ngoto out;\r\n}\r\n}\r\nif (data->ioc_dev == OBD_DEV_BY_DEVNAME) {\r\nif (data->ioc_inllen4 <= 0 || !data->ioc_inlbuf4) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (strnlen(data->ioc_inlbuf4, MAX_OBD_NAME) >= MAX_OBD_NAME) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nobd = class_name2obd(data->ioc_inlbuf4);\r\n} else if (data->ioc_dev < class_devno_max()) {\r\nobd = class_num2obd(data->ioc_dev);\r\n} else {\r\nCERROR("OBD ioctl: No device\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!obd) {\r\nCERROR("OBD ioctl : No Device %d\n", data->ioc_dev);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nif (!obd->obd_set_up || obd->obd_stopping) {\r\nCERROR("OBD ioctl: device not setup %d\n", data->ioc_dev);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase OBD_IOC_NO_TRANSNO: {\r\nif (!obd->obd_attached) {\r\nCERROR("Device %d not attached\n", obd->obd_minor);\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nCDEBUG(D_HA, "%s: disabling committed-transno notification\n",\r\nobd->obd_name);\r\nobd->obd_no_transno = 1;\r\nerr = 0;\r\ngoto out;\r\n}\r\ndefault: {\r\nerr = obd_iocontrol(cmd, obd->obd_self_export, len, data, NULL);\r\nif (err)\r\ngoto out;\r\nerr = obd_ioctl_popdata((void __user *)arg, data, len);\r\nif (err)\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (buf)\r\nobd_ioctl_freedata(buf, len);\r\nreturn err;\r\n}\r\nstatic int obd_init_checks(void)\r\n{\r\n__u64 u64val, div64val;\r\nchar buf[64];\r\nint len, ret = 0;\r\nCDEBUG(D_INFO, "LPU64=%s, LPD64=%s, LPX64=%s\n", "%llu", "%lld", "%#llx");\r\nCDEBUG(D_INFO, "OBD_OBJECT_EOF = %#llx\n", (__u64)OBD_OBJECT_EOF);\r\nu64val = OBD_OBJECT_EOF;\r\nCDEBUG(D_INFO, "u64val OBD_OBJECT_EOF = %#llx\n", u64val);\r\nif (u64val != OBD_OBJECT_EOF) {\r\nCERROR("__u64 %#llx(%d) != 0xffffffffffffffff\n",\r\nu64val, (int)sizeof(u64val));\r\nret = -EINVAL;\r\n}\r\nlen = snprintf(buf, sizeof(buf), "%#llx", u64val);\r\nif (len != 18) {\r\nCWARN("LPX64 wrong length! strlen(%s)=%d != 18\n", buf, len);\r\nret = -EINVAL;\r\n}\r\ndiv64val = OBD_OBJECT_EOF;\r\nCDEBUG(D_INFO, "u64val OBD_OBJECT_EOF = %#llx\n", u64val);\r\nif (u64val != OBD_OBJECT_EOF) {\r\nCERROR("__u64 %#llx(%d) != 0xffffffffffffffff\n",\r\nu64val, (int)sizeof(u64val));\r\nret = -EOVERFLOW;\r\n}\r\nif (u64val >> 8 != OBD_OBJECT_EOF >> 8) {\r\nCERROR("__u64 %#llx(%d) != 0xffffffffffffffff\n",\r\nu64val, (int)sizeof(u64val));\r\nreturn -EOVERFLOW;\r\n}\r\nif (do_div(div64val, 256) != (u64val & 255)) {\r\nCERROR("do_div(%#llx,256) != %llu\n", u64val, u64val & 255);\r\nreturn -EOVERFLOW;\r\n}\r\nif (u64val >> 8 != div64val) {\r\nCERROR("do_div(%#llx,256) %llu != %llu\n",\r\nu64val, div64val, u64val >> 8);\r\nreturn -EOVERFLOW;\r\n}\r\nlen = snprintf(buf, sizeof(buf), "%#llx", u64val);\r\nif (len != 18) {\r\nCWARN("LPX64 wrong length! strlen(%s)=%d != 18\n", buf, len);\r\nret = -EINVAL;\r\n}\r\nlen = snprintf(buf, sizeof(buf), "%llu", u64val);\r\nif (len != 20) {\r\nCWARN("LPU64 wrong length! strlen(%s)=%d != 20\n", buf, len);\r\nret = -EINVAL;\r\n}\r\nlen = snprintf(buf, sizeof(buf), "%lld", u64val);\r\nif (len != 2) {\r\nCWARN("LPD64 wrong length! strlen(%s)=%d != 2\n", buf, len);\r\nret = -EINVAL;\r\n}\r\nif ((u64val & ~PAGE_MASK) >= PAGE_SIZE) {\r\nCWARN("mask failed: u64val %llu >= %llu\n", u64val,\r\n(__u64)PAGE_SIZE);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init obdclass_init(void)\r\n{\r\nint i, err;\r\nLCONSOLE_INFO("Lustre: Build Version: " LUSTRE_VERSION_STRING "\n");\r\nspin_lock_init(&obd_types_lock);\r\nobd_zombie_impexp_init();\r\nerr = obd_init_checks();\r\nif (err == -EOVERFLOW)\r\nreturn err;\r\nclass_init_uuidlist();\r\nerr = class_handle_init();\r\nif (err)\r\nreturn err;\r\nINIT_LIST_HEAD(&obd_types);\r\nerr = misc_register(&obd_psdev);\r\nif (err) {\r\nCERROR("cannot register %d err %d\n", OBD_DEV_MINOR, err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < class_devno_max(); i++)\r\nobd_devs[i] = NULL;\r\nif (totalram_pages <= 512 << (20 - PAGE_SHIFT))\r\nobd_max_dirty_pages = totalram_pages / 4;\r\nelse\r\nobd_max_dirty_pages = totalram_pages / 2;\r\nerr = obd_init_caches();\r\nif (err)\r\nreturn err;\r\nerr = class_procfs_init();\r\nif (err)\r\nreturn err;\r\nerr = obd_sysctl_init();\r\nif (err)\r\nreturn err;\r\nerr = lu_global_init();\r\nif (err)\r\nreturn err;\r\nerr = cl_global_init();\r\nif (err != 0)\r\nreturn err;\r\nerr = llog_info_init();\r\nif (err)\r\nreturn err;\r\nerr = lustre_register_fs();\r\nreturn err;\r\n}\r\nstatic void obdclass_exit(void)\r\n{\r\nlustre_unregister_fs();\r\nmisc_deregister(&obd_psdev);\r\nllog_info_fini();\r\ncl_global_fini();\r\nlu_global_fini();\r\nobd_cleanup_caches();\r\nclass_procfs_clean();\r\nclass_handle_cleanup();\r\nclass_exit_uuidlist();\r\nobd_zombie_impexp_stop();\r\n}
