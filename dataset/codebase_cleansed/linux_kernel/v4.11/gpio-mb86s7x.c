static int mb86s70_gpio_request(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&gchip->lock, flags);\r\nval = readl(gchip->base + PFR(gpio));\r\nif (!(val & OFFSET(gpio))) {\r\nspin_unlock_irqrestore(&gchip->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nval &= ~OFFSET(gpio);\r\nwritel(val, gchip->base + PFR(gpio));\r\nspin_unlock_irqrestore(&gchip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mb86s70_gpio_free(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&gchip->lock, flags);\r\nval = readl(gchip->base + PFR(gpio));\r\nval |= OFFSET(gpio);\r\nwritel(val, gchip->base + PFR(gpio));\r\nspin_unlock_irqrestore(&gchip->lock, flags);\r\n}\r\nstatic int mb86s70_gpio_direction_input(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char val;\r\nspin_lock_irqsave(&gchip->lock, flags);\r\nval = readl(gchip->base + DDR(gpio));\r\nval &= ~OFFSET(gpio);\r\nwritel(val, gchip->base + DDR(gpio));\r\nspin_unlock_irqrestore(&gchip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mb86s70_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned gpio, int value)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char val;\r\nspin_lock_irqsave(&gchip->lock, flags);\r\nval = readl(gchip->base + PDR(gpio));\r\nif (value)\r\nval |= OFFSET(gpio);\r\nelse\r\nval &= ~OFFSET(gpio);\r\nwritel(val, gchip->base + PDR(gpio));\r\nval = readl(gchip->base + DDR(gpio));\r\nval |= OFFSET(gpio);\r\nwritel(val, gchip->base + DDR(gpio));\r\nspin_unlock_irqrestore(&gchip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mb86s70_gpio_get(struct gpio_chip *gc, unsigned gpio)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\r\nreturn !!(readl(gchip->base + PDR(gpio)) & OFFSET(gpio));\r\n}\r\nstatic void mb86s70_gpio_set(struct gpio_chip *gc, unsigned gpio, int value)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nunsigned char val;\r\nspin_lock_irqsave(&gchip->lock, flags);\r\nval = readl(gchip->base + PDR(gpio));\r\nif (value)\r\nval |= OFFSET(gpio);\r\nelse\r\nval &= ~OFFSET(gpio);\r\nwritel(val, gchip->base + PDR(gpio));\r\nspin_unlock_irqrestore(&gchip->lock, flags);\r\n}\r\nstatic int mb86s70_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct mb86s70_gpio_chip *gchip;\r\nstruct resource *res;\r\nint ret;\r\ngchip = devm_kzalloc(&pdev->dev, sizeof(*gchip), GFP_KERNEL);\r\nif (gchip == NULL)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, gchip);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngchip->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(gchip->base))\r\nreturn PTR_ERR(gchip->base);\r\ngchip->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(gchip->clk))\r\nreturn PTR_ERR(gchip->clk);\r\nclk_prepare_enable(gchip->clk);\r\nspin_lock_init(&gchip->lock);\r\ngchip->gc.direction_output = mb86s70_gpio_direction_output;\r\ngchip->gc.direction_input = mb86s70_gpio_direction_input;\r\ngchip->gc.request = mb86s70_gpio_request;\r\ngchip->gc.free = mb86s70_gpio_free;\r\ngchip->gc.get = mb86s70_gpio_get;\r\ngchip->gc.set = mb86s70_gpio_set;\r\ngchip->gc.label = dev_name(&pdev->dev);\r\ngchip->gc.ngpio = 32;\r\ngchip->gc.owner = THIS_MODULE;\r\ngchip->gc.parent = &pdev->dev;\r\ngchip->gc.base = -1;\r\nret = gpiochip_add_data(&gchip->gc, gchip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "couldn't register gpio driver\n");\r\nclk_disable_unprepare(gchip->clk);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mb86s70_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct mb86s70_gpio_chip *gchip = platform_get_drvdata(pdev);\r\ngpiochip_remove(&gchip->gc);\r\nclk_disable_unprepare(gchip->clk);\r\nreturn 0;\r\n}
