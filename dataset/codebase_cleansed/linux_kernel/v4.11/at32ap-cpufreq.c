static int at32_set_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nunsigned int old_freq, new_freq;\r\nold_freq = policy->cur;\r\nnew_freq = freq_table[index].frequency;\r\nif (!ref_freq) {\r\nref_freq = old_freq;\r\nloops_per_jiffy_ref = boot_cpu_data.loops_per_jiffy;\r\n}\r\nif (old_freq < new_freq)\r\nboot_cpu_data.loops_per_jiffy = cpufreq_scale(\r\nloops_per_jiffy_ref, ref_freq, new_freq);\r\nclk_set_rate(policy->clk, new_freq * 1000);\r\nif (new_freq < old_freq)\r\nboot_cpu_data.loops_per_jiffy = cpufreq_scale(\r\nloops_per_jiffy_ref, ref_freq, new_freq);\r\nreturn 0;\r\n}\r\nstatic int at32_cpufreq_driver_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int frequency, rate, min_freq;\r\nstruct clk *cpuclk;\r\nint retval, steps, i;\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\ncpuclk = clk_get(NULL, "cpu");\r\nif (IS_ERR(cpuclk)) {\r\npr_debug("cpufreq: could not get CPU clk\n");\r\nretval = PTR_ERR(cpuclk);\r\ngoto out_err;\r\n}\r\nmin_freq = (clk_round_rate(cpuclk, 1) + 500) / 1000;\r\nfrequency = (clk_round_rate(cpuclk, ~0UL) + 500) / 1000;\r\npolicy->cpuinfo.transition_latency = 0;\r\nsteps = fls(frequency / min_freq) + 1;\r\nfreq_table = kzalloc(steps * sizeof(struct cpufreq_frequency_table),\r\nGFP_KERNEL);\r\nif (!freq_table) {\r\nretval = -ENOMEM;\r\ngoto out_err_put_clk;\r\n}\r\nfor (i = 0; i < (steps - 1); i++) {\r\nrate = clk_round_rate(cpuclk, frequency * 1000) / 1000;\r\nif (rate != frequency)\r\nfreq_table[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\nfreq_table[i].frequency = frequency;\r\nfrequency /= 2;\r\n}\r\npolicy->clk = cpuclk;\r\nfreq_table[steps - 1].frequency = CPUFREQ_TABLE_END;\r\nretval = cpufreq_table_validate_and_show(policy, freq_table);\r\nif (!retval) {\r\nprintk("cpufreq: AT32AP CPU frequency driver\n");\r\nreturn 0;\r\n}\r\nkfree(freq_table);\r\nout_err_put_clk:\r\nclk_put(cpuclk);\r\nout_err:\r\nreturn retval;\r\n}\r\nstatic int __init at32_cpufreq_init(void)\r\n{\r\nreturn cpufreq_register_driver(&at32_driver);\r\n}
