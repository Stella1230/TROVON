int\r\ntapechar_setup_device(struct tape_device * device)\r\n{\r\nchar device_name[20];\r\nsprintf(device_name, "ntibm%i", device->first_minor / 2);\r\ndevice->nt = register_tape_dev(\r\n&device->cdev->dev,\r\nMKDEV(tapechar_major, device->first_minor),\r\n&tape_fops,\r\ndevice_name,\r\n"non-rewinding"\r\n);\r\ndevice_name[0] = 'r';\r\ndevice->rt = register_tape_dev(\r\n&device->cdev->dev,\r\nMKDEV(tapechar_major, device->first_minor + 1),\r\n&tape_fops,\r\ndevice_name,\r\n"rewinding"\r\n);\r\nreturn 0;\r\n}\r\nvoid\r\ntapechar_cleanup_device(struct tape_device *device)\r\n{\r\nunregister_tape_dev(&device->cdev->dev, device->rt);\r\ndevice->rt = NULL;\r\nunregister_tape_dev(&device->cdev->dev, device->nt);\r\ndevice->nt = NULL;\r\n}\r\nstatic int\r\ntapechar_check_idalbuffer(struct tape_device *device, size_t block_size)\r\n{\r\nstruct idal_buffer *new;\r\nif (device->char_data.idal_buf != NULL &&\r\ndevice->char_data.idal_buf->size == block_size)\r\nreturn 0;\r\nif (block_size > MAX_BLOCKSIZE) {\r\nDBF_EVENT(3, "Invalid blocksize (%zd > %d)\n",\r\nblock_size, MAX_BLOCKSIZE);\r\nreturn -EINVAL;\r\n}\r\nnew = idal_buffer_alloc(block_size, 0);\r\nif (IS_ERR(new))\r\nreturn -ENOMEM;\r\nif (device->char_data.idal_buf != NULL)\r\nidal_buffer_free(device->char_data.idal_buf);\r\ndevice->char_data.idal_buf = new;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ntapechar_read(struct file *filp, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct tape_device *device;\r\nstruct tape_request *request;\r\nsize_t block_size;\r\nint rc;\r\nDBF_EVENT(6, "TCHAR:read\n");\r\ndevice = (struct tape_device *) filp->private_data;\r\nif(device->required_tapemarks) {\r\nreturn tape_std_terminate_write(device);\r\n}\r\nif (device->char_data.block_size != 0) {\r\nif (count < device->char_data.block_size) {\r\nDBF_EVENT(3, "TCHAR:read smaller than block "\r\n"size was requested\n");\r\nreturn -EINVAL;\r\n}\r\nblock_size = device->char_data.block_size;\r\n} else {\r\nblock_size = count;\r\n}\r\nrc = tapechar_check_idalbuffer(device, block_size);\r\nif (rc)\r\nreturn rc;\r\nDBF_EVENT(6, "TCHAR:nbytes: %lx\n", block_size);\r\nrequest = device->discipline->read_block(device, block_size);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrc = tape_do_io(device, request);\r\nif (rc == 0) {\r\nrc = block_size - request->rescnt;\r\nDBF_EVENT(6, "TCHAR:rbytes: %x\n", rc);\r\nif (idal_buffer_to_user(device->char_data.idal_buf,\r\ndata, rc) != 0)\r\nrc = -EFAULT;\r\n}\r\ntape_free_request(request);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ntapechar_write(struct file *filp, const char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct tape_device *device;\r\nstruct tape_request *request;\r\nsize_t block_size;\r\nsize_t written;\r\nint nblocks;\r\nint i, rc;\r\nDBF_EVENT(6, "TCHAR:write\n");\r\ndevice = (struct tape_device *) filp->private_data;\r\nif (device->char_data.block_size != 0) {\r\nif (count < device->char_data.block_size) {\r\nDBF_EVENT(3, "TCHAR:write smaller than block "\r\n"size was requested\n");\r\nreturn -EINVAL;\r\n}\r\nblock_size = device->char_data.block_size;\r\nnblocks = count / block_size;\r\n} else {\r\nblock_size = count;\r\nnblocks = 1;\r\n}\r\nrc = tapechar_check_idalbuffer(device, block_size);\r\nif (rc)\r\nreturn rc;\r\nDBF_EVENT(6,"TCHAR:nbytes: %lx\n", block_size);\r\nDBF_EVENT(6, "TCHAR:nblocks: %x\n", nblocks);\r\nrequest = device->discipline->write_block(device, block_size);\r\nif (IS_ERR(request))\r\nreturn PTR_ERR(request);\r\nrc = 0;\r\nwritten = 0;\r\nfor (i = 0; i < nblocks; i++) {\r\nif (idal_buffer_from_user(device->char_data.idal_buf,\r\ndata, block_size)) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nrc = tape_do_io(device, request);\r\nif (rc)\r\nbreak;\r\nDBF_EVENT(6, "TCHAR:wbytes: %lx\n",\r\nblock_size - request->rescnt);\r\nwritten += block_size - request->rescnt;\r\nif (request->rescnt != 0)\r\nbreak;\r\ndata += block_size;\r\n}\r\ntape_free_request(request);\r\nif (rc == -ENOSPC) {\r\nif (device->discipline->process_eov)\r\ndevice->discipline->process_eov(device);\r\nif (written > 0)\r\nrc = 0;\r\n}\r\nif (!rc)\r\ndevice->required_tapemarks = 2;\r\nreturn rc ? rc : written;\r\n}\r\nstatic int\r\ntapechar_open (struct inode *inode, struct file *filp)\r\n{\r\nstruct tape_device *device;\r\nint minor, rc;\r\nDBF_EVENT(6, "TCHAR:open: %i:%i\n",\r\nimajor(file_inode(filp)),\r\niminor(file_inode(filp)));\r\nif (imajor(file_inode(filp)) != tapechar_major)\r\nreturn -ENODEV;\r\nminor = iminor(file_inode(filp));\r\ndevice = tape_find_device(minor / TAPE_MINORS_PER_DEV);\r\nif (IS_ERR(device)) {\r\nDBF_EVENT(3, "TCHAR:open: tape_find_device() failed\n");\r\nreturn PTR_ERR(device);\r\n}\r\nrc = tape_open(device);\r\nif (rc == 0) {\r\nfilp->private_data = device;\r\nnonseekable_open(inode, filp);\r\n} else\r\ntape_put_device(device);\r\nreturn rc;\r\n}\r\nstatic int\r\ntapechar_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct tape_device *device;\r\nDBF_EVENT(6, "TCHAR:release: %x\n", iminor(inode));\r\ndevice = (struct tape_device *) filp->private_data;\r\nif ((iminor(inode) & 1) != 0) {\r\nif (device->required_tapemarks)\r\ntape_std_terminate_write(device);\r\ntape_mtop(device, MTREW, 1);\r\n} else {\r\nif (device->required_tapemarks > 1) {\r\nif (tape_mtop(device, MTWEOF, 1) == 0)\r\ndevice->required_tapemarks--;\r\n}\r\n}\r\nif (device->char_data.idal_buf != NULL) {\r\nidal_buffer_free(device->char_data.idal_buf);\r\ndevice->char_data.idal_buf = NULL;\r\n}\r\ntape_release(device);\r\nfilp->private_data = NULL;\r\ntape_put_device(device);\r\nreturn 0;\r\n}\r\nstatic int\r\n__tapechar_ioctl(struct tape_device *device,\r\nunsigned int no, unsigned long data)\r\n{\r\nint rc;\r\nif (no == MTIOCTOP) {\r\nstruct mtop op;\r\nif (copy_from_user(&op, (char __user *) data, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\nif (op.mt_count < 0)\r\nreturn -EINVAL;\r\nswitch (op.mt_op) {\r\ncase MTFSF:\r\ncase MTBSF:\r\ncase MTFSR:\r\ncase MTBSR:\r\ncase MTREW:\r\ncase MTOFFL:\r\ncase MTEOM:\r\ncase MTRETEN:\r\ncase MTBSFM:\r\ncase MTFSFM:\r\ncase MTSEEK:\r\nif (device->required_tapemarks)\r\ntape_std_terminate_write(device);\r\ndefault:\r\n;\r\n}\r\nrc = tape_mtop(device, op.mt_op, op.mt_count);\r\nif (op.mt_op == MTWEOF && rc == 0) {\r\nif (op.mt_count > device->required_tapemarks)\r\ndevice->required_tapemarks = 0;\r\nelse\r\ndevice->required_tapemarks -= op.mt_count;\r\n}\r\nreturn rc;\r\n}\r\nif (no == MTIOCPOS) {\r\nstruct mtpos pos;\r\nrc = tape_mtop(device, MTTELL, 1);\r\nif (rc < 0)\r\nreturn rc;\r\npos.mt_blkno = rc;\r\nif (copy_to_user((char __user *) data, &pos, sizeof(pos)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (no == MTIOCGET) {\r\nstruct mtget get;\r\nmemset(&get, 0, sizeof(get));\r\nget.mt_type = MT_ISUNKNOWN;\r\nget.mt_resid = 0 ;\r\nget.mt_dsreg =\r\n((device->char_data.block_size << MT_ST_BLKSIZE_SHIFT)\r\n& MT_ST_BLKSIZE_MASK);\r\nget.mt_gstat = 0;\r\nget.mt_erreg = 0;\r\nget.mt_fileno = 0;\r\nget.mt_gstat = device->tape_generic_status;\r\nif (device->medium_state == MS_LOADED) {\r\nrc = tape_mtop(device, MTTELL, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc == 0)\r\nget.mt_gstat |= GMT_BOT(~0);\r\nget.mt_blkno = rc;\r\n}\r\nif (copy_to_user((char __user *) data, &get, sizeof(get)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (device->discipline->ioctl_fn == NULL)\r\nreturn -EINVAL;\r\nreturn device->discipline->ioctl_fn(device, no, data);\r\n}\r\nstatic long\r\ntapechar_ioctl(struct file *filp, unsigned int no, unsigned long data)\r\n{\r\nstruct tape_device *device;\r\nlong rc;\r\nDBF_EVENT(6, "TCHAR:ioct\n");\r\ndevice = (struct tape_device *) filp->private_data;\r\nmutex_lock(&device->mutex);\r\nrc = __tapechar_ioctl(device, no, data);\r\nmutex_unlock(&device->mutex);\r\nreturn rc;\r\n}\r\nstatic long\r\ntapechar_compat_ioctl(struct file *filp, unsigned int no, unsigned long data)\r\n{\r\nstruct tape_device *device = filp->private_data;\r\nint rval = -ENOIOCTLCMD;\r\nunsigned long argp;\r\nargp = (unsigned long) compat_ptr(data);\r\nif (device->discipline->ioctl_fn) {\r\nmutex_lock(&device->mutex);\r\nrval = device->discipline->ioctl_fn(device, no, argp);\r\nmutex_unlock(&device->mutex);\r\nif (rval == -EINVAL)\r\nrval = -ENOIOCTLCMD;\r\n}\r\nreturn rval;\r\n}\r\nint\r\ntapechar_init (void)\r\n{\r\ndev_t dev;\r\nif (alloc_chrdev_region(&dev, 0, 256, "tape") != 0)\r\nreturn -1;\r\ntapechar_major = MAJOR(dev);\r\nreturn 0;\r\n}\r\nvoid\r\ntapechar_exit(void)\r\n{\r\nunregister_chrdev_region(MKDEV(tapechar_major, 0), 256);\r\n}
