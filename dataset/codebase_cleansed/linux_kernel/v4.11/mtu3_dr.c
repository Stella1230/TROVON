static void toggle_opstate(struct ssusb_mtk *ssusb)\r\n{\r\nif (!ssusb->otg_switch.is_u3_drd) {\r\nmtu3_setbits(ssusb->mac_base, U3D_DEVICE_CONTROL, DC_SESSION);\r\nmtu3_setbits(ssusb->mac_base, U3D_POWER_MANAGEMENT, SOFT_CONN);\r\n}\r\n}\r\nstatic int ssusb_port0_switch(struct ssusb_mtk *ssusb,\r\nint version, bool tohost)\r\n{\r\nvoid __iomem *ibase = ssusb->ippc_base;\r\nu32 value;\r\ndev_dbg(ssusb->dev, "%s (switch u%d port0 to %s)\n", __func__,\r\nversion, tohost ? "host" : "device");\r\nif (version == USB2_PORT) {\r\nvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(0));\r\nvalue |= SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS;\r\nmtu3_writel(ibase, SSUSB_U2_CTRL(0), value);\r\nvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(0));\r\nvalue &= ~(SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS);\r\nvalue = tohost ? (value | SSUSB_U2_PORT_HOST_SEL) :\r\n(value & (~SSUSB_U2_PORT_HOST_SEL));\r\nmtu3_writel(ibase, SSUSB_U2_CTRL(0), value);\r\n} else {\r\nvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(0));\r\nvalue |= SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS;\r\nmtu3_writel(ibase, SSUSB_U3_CTRL(0), value);\r\nvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(0));\r\nvalue &= ~(SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS);\r\nvalue = tohost ? (value | SSUSB_U3_PORT_HOST_SEL) :\r\n(value & (~SSUSB_U3_PORT_HOST_SEL));\r\nmtu3_writel(ibase, SSUSB_U3_CTRL(0), value);\r\n}\r\nreturn 0;\r\n}\r\nstatic void switch_port_to_host(struct ssusb_mtk *ssusb)\r\n{\r\nu32 check_clk = 0;\r\ndev_dbg(ssusb->dev, "%s\n", __func__);\r\nssusb_port0_switch(ssusb, USB2_PORT, true);\r\nif (ssusb->otg_switch.is_u3_drd) {\r\nssusb_port0_switch(ssusb, USB3_PORT, true);\r\ncheck_clk = SSUSB_U3_MAC_RST_B_STS;\r\n}\r\nssusb_check_clocks(ssusb, check_clk);\r\ntoggle_opstate(ssusb);\r\n}\r\nstatic void switch_port_to_device(struct ssusb_mtk *ssusb)\r\n{\r\nu32 check_clk = 0;\r\ndev_dbg(ssusb->dev, "%s\n", __func__);\r\nssusb_port0_switch(ssusb, USB2_PORT, false);\r\nif (ssusb->otg_switch.is_u3_drd) {\r\nssusb_port0_switch(ssusb, USB3_PORT, false);\r\ncheck_clk = SSUSB_U3_MAC_RST_B_STS;\r\n}\r\nssusb_check_clocks(ssusb, check_clk);\r\n}\r\nint ssusb_set_vbus(struct otg_switch_mtk *otg_sx, int is_on)\r\n{\r\nstruct ssusb_mtk *ssusb =\r\ncontainer_of(otg_sx, struct ssusb_mtk, otg_switch);\r\nstruct regulator *vbus = otg_sx->vbus;\r\nint ret;\r\nif (!vbus)\r\nreturn 0;\r\ndev_dbg(ssusb->dev, "%s: turn %s\n", __func__, is_on ? "on" : "off");\r\nif (is_on) {\r\nret = regulator_enable(vbus);\r\nif (ret) {\r\ndev_err(ssusb->dev, "vbus regulator enable failed\n");\r\nreturn ret;\r\n}\r\n} else {\r\nregulator_disable(vbus);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ssusb_set_mailbox(struct otg_switch_mtk *otg_sx,\r\nenum mtu3_vbus_id_state status)\r\n{\r\nstruct ssusb_mtk *ssusb =\r\ncontainer_of(otg_sx, struct ssusb_mtk, otg_switch);\r\nstruct mtu3 *mtu = ssusb->u3d;\r\ndev_dbg(ssusb->dev, "mailbox state(%d)\n", status);\r\nswitch (status) {\r\ncase MTU3_ID_GROUND:\r\nswitch_port_to_host(ssusb);\r\nssusb_set_vbus(otg_sx, 1);\r\nssusb->is_host = true;\r\nbreak;\r\ncase MTU3_ID_FLOAT:\r\nssusb->is_host = false;\r\nssusb_set_vbus(otg_sx, 0);\r\nswitch_port_to_device(ssusb);\r\nbreak;\r\ncase MTU3_VBUS_OFF:\r\nmtu3_stop(mtu);\r\npm_relax(ssusb->dev);\r\nbreak;\r\ncase MTU3_VBUS_VALID:\r\npm_stay_awake(ssusb->dev);\r\nmtu3_start(mtu);\r\nbreak;\r\ndefault:\r\ndev_err(ssusb->dev, "invalid state\n");\r\n}\r\n}\r\nstatic int ssusb_id_notifier(struct notifier_block *nb,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct otg_switch_mtk *otg_sx =\r\ncontainer_of(nb, struct otg_switch_mtk, id_nb);\r\nif (event)\r\nssusb_set_mailbox(otg_sx, MTU3_ID_GROUND);\r\nelse\r\nssusb_set_mailbox(otg_sx, MTU3_ID_FLOAT);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ssusb_vbus_notifier(struct notifier_block *nb,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct otg_switch_mtk *otg_sx =\r\ncontainer_of(nb, struct otg_switch_mtk, vbus_nb);\r\nif (event)\r\nssusb_set_mailbox(otg_sx, MTU3_VBUS_VALID);\r\nelse\r\nssusb_set_mailbox(otg_sx, MTU3_VBUS_OFF);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ssusb_extcon_register(struct otg_switch_mtk *otg_sx)\r\n{\r\nstruct ssusb_mtk *ssusb =\r\ncontainer_of(otg_sx, struct ssusb_mtk, otg_switch);\r\nstruct extcon_dev *edev = otg_sx->edev;\r\nint ret;\r\nif (!edev)\r\nreturn 0;\r\notg_sx->vbus_nb.notifier_call = ssusb_vbus_notifier;\r\nret = extcon_register_notifier(edev, EXTCON_USB,\r\n&otg_sx->vbus_nb);\r\nif (ret < 0)\r\ndev_err(ssusb->dev, "failed to register notifier for USB\n");\r\notg_sx->id_nb.notifier_call = ssusb_id_notifier;\r\nret = extcon_register_notifier(edev, EXTCON_USB_HOST,\r\n&otg_sx->id_nb);\r\nif (ret < 0)\r\ndev_err(ssusb->dev, "failed to register notifier for USB-HOST\n");\r\ndev_dbg(ssusb->dev, "EXTCON_USB: %d, EXTCON_USB_HOST: %d\n",\r\nextcon_get_cable_state_(edev, EXTCON_USB),\r\nextcon_get_cable_state_(edev, EXTCON_USB_HOST));\r\nif (extcon_get_cable_state_(edev, EXTCON_USB_HOST) == false)\r\nssusb_set_mailbox(otg_sx, MTU3_ID_FLOAT);\r\nif (extcon_get_cable_state_(edev, EXTCON_USB) == true)\r\nssusb_set_mailbox(otg_sx, MTU3_VBUS_VALID);\r\nreturn 0;\r\n}\r\nstatic void extcon_register_dwork(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct otg_switch_mtk *otg_sx =\r\ncontainer_of(dwork, struct otg_switch_mtk, extcon_reg_dwork);\r\nssusb_extcon_register(otg_sx);\r\n}\r\nstatic void ssusb_mode_manual_switch(struct ssusb_mtk *ssusb, int to_host)\r\n{\r\nstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\r\nif (to_host)\r\npinctrl_select_state(otg_sx->id_pinctrl, otg_sx->id_ground);\r\nelse\r\npinctrl_select_state(otg_sx->id_pinctrl, otg_sx->id_float);\r\n}\r\nstatic int ssusb_mode_show(struct seq_file *sf, void *unused)\r\n{\r\nstruct ssusb_mtk *ssusb = sf->private;\r\nseq_printf(sf, "current mode: %s(%s drd)\n(echo device/host)\n",\r\nssusb->is_host ? "host" : "device",\r\nssusb->otg_switch.manual_drd_enabled ? "manual" : "auto");\r\nreturn 0;\r\n}\r\nstatic int ssusb_mode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ssusb_mode_show, inode->i_private);\r\n}\r\nstatic ssize_t ssusb_mode_write(struct file *file,\r\nconst char __user *ubuf, size_t count, loff_t *ppos)\r\n{\r\nstruct seq_file *sf = file->private_data;\r\nstruct ssusb_mtk *ssusb = sf->private;\r\nchar buf[16];\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nif (!strncmp(buf, "host", 4) && !ssusb->is_host) {\r\nssusb_mode_manual_switch(ssusb, 1);\r\n} else if (!strncmp(buf, "device", 6) && ssusb->is_host) {\r\nssusb_mode_manual_switch(ssusb, 0);\r\n} else {\r\ndev_err(ssusb->dev, "wrong or duplicated setting\n");\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic void ssusb_debugfs_init(struct ssusb_mtk *ssusb)\r\n{\r\nstruct dentry *root;\r\nstruct dentry *file;\r\nroot = debugfs_create_dir(dev_name(ssusb->dev), usb_debug_root);\r\nif (IS_ERR_OR_NULL(root)) {\r\nif (!root)\r\ndev_err(ssusb->dev, "create debugfs root failed\n");\r\nreturn;\r\n}\r\nssusb->dbgfs_root = root;\r\nfile = debugfs_create_file("mode", S_IRUGO | S_IWUSR, root,\r\nssusb, &ssusb_mode_fops);\r\nif (!file)\r\ndev_dbg(ssusb->dev, "create debugfs mode failed\n");\r\n}\r\nstatic void ssusb_debugfs_exit(struct ssusb_mtk *ssusb)\r\n{\r\ndebugfs_remove_recursive(ssusb->dbgfs_root);\r\n}\r\nint ssusb_otg_switch_init(struct ssusb_mtk *ssusb)\r\n{\r\nstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\r\nINIT_DELAYED_WORK(&otg_sx->extcon_reg_dwork, extcon_register_dwork);\r\nif (otg_sx->manual_drd_enabled)\r\nssusb_debugfs_init(ssusb);\r\nschedule_delayed_work(&otg_sx->extcon_reg_dwork, HZ);\r\nreturn 0;\r\n}\r\nvoid ssusb_otg_switch_exit(struct ssusb_mtk *ssusb)\r\n{\r\nstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\r\ncancel_delayed_work(&otg_sx->extcon_reg_dwork);\r\nif (otg_sx->edev) {\r\nextcon_unregister_notifier(otg_sx->edev,\r\nEXTCON_USB, &otg_sx->vbus_nb);\r\nextcon_unregister_notifier(otg_sx->edev,\r\nEXTCON_USB_HOST, &otg_sx->id_nb);\r\n}\r\nif (otg_sx->manual_drd_enabled)\r\nssusb_debugfs_exit(ssusb);\r\n}
