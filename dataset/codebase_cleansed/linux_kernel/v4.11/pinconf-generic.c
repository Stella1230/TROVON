static void pinconf_generic_dump_one(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, const char *gname,\r\nunsigned pin,\r\nconst struct pin_config_item *items,\r\nint nitems, int *print_sep)\r\n{\r\nint i;\r\nfor (i = 0; i < nitems; i++) {\r\nunsigned long config;\r\nint ret;\r\nconfig = pinconf_to_config_packed(items[i].param, 0);\r\nif (gname)\r\nret = pin_config_group_get(dev_name(pctldev->dev),\r\ngname, &config);\r\nelse\r\nret = pin_config_get_for_pin(pctldev, pin, &config);\r\nif (ret == -EINVAL || ret == -ENOTSUPP)\r\ncontinue;\r\nif (ret) {\r\nseq_printf(s, "ERROR READING CONFIG SETTING %d ", i);\r\ncontinue;\r\n}\r\nif (*print_sep)\r\nseq_puts(s, ", ");\r\n*print_sep = 1;\r\nseq_puts(s, items[i].display);\r\nif (items[i].has_arg) {\r\nseq_printf(s, " (%u",\r\npinconf_to_config_argument(config));\r\nif (items[i].format)\r\nseq_printf(s, " %s)", items[i].format);\r\nelse\r\nseq_puts(s, ")");\r\n}\r\n}\r\n}\r\nvoid pinconf_generic_dump_pins(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nconst char *gname, unsigned pin)\r\n{\r\nconst struct pinconf_ops *ops = pctldev->desc->confops;\r\nint print_sep = 0;\r\nif (!ops->is_generic)\r\nreturn;\r\npinconf_generic_dump_one(pctldev, s, gname, pin, conf_items,\r\nARRAY_SIZE(conf_items), &print_sep);\r\nif (pctldev->desc->num_custom_params &&\r\npctldev->desc->custom_conf_items)\r\npinconf_generic_dump_one(pctldev, s, gname, pin,\r\npctldev->desc->custom_conf_items,\r\npctldev->desc->num_custom_params,\r\n&print_sep);\r\n}\r\nvoid pinconf_generic_dump_config(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned long config)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(conf_items); i++) {\r\nif (pinconf_to_config_param(config) != conf_items[i].param)\r\ncontinue;\r\nseq_printf(s, "%s: 0x%x", conf_items[i].display,\r\npinconf_to_config_argument(config));\r\n}\r\nif (!pctldev->desc->num_custom_params ||\r\n!pctldev->desc->custom_conf_items)\r\nreturn;\r\nfor (i = 0; i < pctldev->desc->num_custom_params; i++) {\r\nif (pinconf_to_config_param(config) !=\r\npctldev->desc->custom_conf_items[i].param)\r\ncontinue;\r\nseq_printf(s, "%s: 0x%x",\r\npctldev->desc->custom_conf_items[i].display,\r\npinconf_to_config_argument(config));\r\n}\r\n}\r\nstatic void parse_dt_cfg(struct device_node *np,\r\nconst struct pinconf_generic_params *params,\r\nunsigned int count, unsigned long *cfg,\r\nunsigned int *ncfg)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nu32 val;\r\nint ret;\r\nconst struct pinconf_generic_params *par = &params[i];\r\nret = of_property_read_u32(np, par->property, &val);\r\nif (ret == -EINVAL)\r\ncontinue;\r\nif (ret)\r\nval = par->default_value;\r\npr_debug("found %s with value %u\n", par->property, val);\r\ncfg[*ncfg] = pinconf_to_config_packed(par->param, val);\r\n(*ncfg)++;\r\n}\r\n}\r\nint pinconf_generic_parse_dt_config(struct device_node *np,\r\nstruct pinctrl_dev *pctldev,\r\nunsigned long **configs,\r\nunsigned int *nconfigs)\r\n{\r\nunsigned long *cfg;\r\nunsigned int max_cfg, ncfg = 0;\r\nint ret;\r\nif (!np)\r\nreturn -EINVAL;\r\nmax_cfg = ARRAY_SIZE(dt_params);\r\nif (pctldev)\r\nmax_cfg += pctldev->desc->num_custom_params;\r\ncfg = kcalloc(max_cfg, sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn -ENOMEM;\r\nparse_dt_cfg(np, dt_params, ARRAY_SIZE(dt_params), cfg, &ncfg);\r\nif (pctldev && pctldev->desc->num_custom_params &&\r\npctldev->desc->custom_params)\r\nparse_dt_cfg(np, pctldev->desc->custom_params,\r\npctldev->desc->num_custom_params, cfg, &ncfg);\r\nret = 0;\r\nif (ncfg == 0) {\r\n*configs = NULL;\r\n*nconfigs = 0;\r\ngoto out;\r\n}\r\n*configs = kmemdup(cfg, ncfg * sizeof(unsigned long), GFP_KERNEL);\r\nif (!*configs) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n*nconfigs = ncfg;\r\nout:\r\nkfree(cfg);\r\nreturn ret;\r\n}\r\nint pinconf_generic_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np, struct pinctrl_map **map,\r\nunsigned *reserved_maps, unsigned *num_maps,\r\nenum pinctrl_map_type type)\r\n{\r\nint ret;\r\nconst char *function;\r\nstruct device *dev = pctldev->dev;\r\nunsigned long *configs = NULL;\r\nunsigned num_configs = 0;\r\nunsigned reserve, strings_count;\r\nstruct property *prop;\r\nconst char *group;\r\nconst char *subnode_target_type = "pins";\r\nret = of_property_count_strings(np, "pins");\r\nif (ret < 0) {\r\nret = of_property_count_strings(np, "groups");\r\nif (ret < 0)\r\nreturn 0;\r\nif (type == PIN_MAP_TYPE_INVALID)\r\ntype = PIN_MAP_TYPE_CONFIGS_GROUP;\r\nsubnode_target_type = "groups";\r\n} else {\r\nif (type == PIN_MAP_TYPE_INVALID)\r\ntype = PIN_MAP_TYPE_CONFIGS_PIN;\r\n}\r\nstrings_count = ret;\r\nret = of_property_read_string(np, "function", &function);\r\nif (ret < 0) {\r\nif (ret != -EINVAL)\r\ndev_err(dev, "%s: could not parse property function\n",\r\nof_node_full_name(np));\r\nfunction = NULL;\r\n}\r\nret = pinconf_generic_parse_dt_config(np, pctldev, &configs,\r\n&num_configs);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: could not parse node property\n",\r\nof_node_full_name(np));\r\nreturn ret;\r\n}\r\nreserve = 0;\r\nif (function != NULL)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nreserve *= strings_count;\r\nret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\r\nnum_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, subnode_target_type, prop, group) {\r\nif (function) {\r\nret = pinctrl_utils_add_map_mux(pctldev, map,\r\nreserved_maps, num_maps, group,\r\nfunction);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = pinctrl_utils_add_map_configs(pctldev, map,\r\nreserved_maps, num_maps, group, configs,\r\nnum_configs, type);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nint pinconf_generic_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config, struct pinctrl_map **map,\r\nunsigned *num_maps, enum pinctrl_map_type type)\r\n{\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nret = pinconf_generic_dt_subnode_to_map(pctldev, np_config, map,\r\n&reserved_maps, num_maps, type);\r\nif (ret < 0)\r\ngoto exit;\r\nfor_each_available_child_of_node(np_config, np) {\r\nret = pinconf_generic_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps, type);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nreturn 0;\r\nexit:\r\npinctrl_utils_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\nvoid pinconf_generic_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned num_maps)\r\n{\r\npinctrl_utils_free_map(pctldev, map, num_maps);\r\n}
