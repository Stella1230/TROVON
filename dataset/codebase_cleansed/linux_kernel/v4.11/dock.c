static int add_dock_dependent_device(struct dock_station *ds,\r\nstruct acpi_device *adev)\r\n{\r\nstruct dock_dependent_device *dd;\r\ndd = kzalloc(sizeof(*dd), GFP_KERNEL);\r\nif (!dd)\r\nreturn -ENOMEM;\r\ndd->adev = adev;\r\nINIT_LIST_HEAD(&dd->list);\r\nlist_add_tail(&dd->list, &ds->dependent_devices);\r\nreturn 0;\r\n}\r\nstatic void dock_hotplug_event(struct dock_dependent_device *dd, u32 event,\r\nenum dock_callback_type cb_type)\r\n{\r\nstruct acpi_device *adev = dd->adev;\r\nacpi_lock_hp_context();\r\nif (!adev->hp)\r\ngoto out;\r\nif (cb_type == DOCK_CALL_FIXUP) {\r\nvoid (*fixup)(struct acpi_device *);\r\nfixup = adev->hp->fixup;\r\nif (fixup) {\r\nacpi_unlock_hp_context();\r\nfixup(adev);\r\nreturn;\r\n}\r\n} else if (cb_type == DOCK_CALL_UEVENT) {\r\nvoid (*uevent)(struct acpi_device *, u32);\r\nuevent = adev->hp->uevent;\r\nif (uevent) {\r\nacpi_unlock_hp_context();\r\nuevent(adev, event);\r\nreturn;\r\n}\r\n} else {\r\nint (*notify)(struct acpi_device *, u32);\r\nnotify = adev->hp->notify;\r\nif (notify) {\r\nacpi_unlock_hp_context();\r\nnotify(adev, event);\r\nreturn;\r\n}\r\n}\r\nout:\r\nacpi_unlock_hp_context();\r\n}\r\nstatic struct dock_station *find_dock_station(acpi_handle handle)\r\n{\r\nstruct dock_station *ds;\r\nlist_for_each_entry(ds, &dock_stations, sibling)\r\nif (ds->handle == handle)\r\nreturn ds;\r\nreturn NULL;\r\n}\r\nstatic struct dock_dependent_device *\r\nfind_dock_dependent_device(struct dock_station *ds, struct acpi_device *adev)\r\n{\r\nstruct dock_dependent_device *dd;\r\nlist_for_each_entry(dd, &ds->dependent_devices, list)\r\nif (adev == dd->adev)\r\nreturn dd;\r\nreturn NULL;\r\n}\r\nvoid register_dock_dependent_device(struct acpi_device *adev,\r\nacpi_handle dshandle)\r\n{\r\nstruct dock_station *ds = find_dock_station(dshandle);\r\nif (ds && !find_dock_dependent_device(ds, adev))\r\nadd_dock_dependent_device(ds, adev);\r\n}\r\nint is_dock_device(struct acpi_device *adev)\r\n{\r\nstruct dock_station *dock_station;\r\nif (!dock_station_count)\r\nreturn 0;\r\nif (acpi_dock_match(adev->handle))\r\nreturn 1;\r\nlist_for_each_entry(dock_station, &dock_stations, sibling)\r\nif (find_dock_dependent_device(dock_station, adev))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int dock_present(struct dock_station *ds)\r\n{\r\nunsigned long long sta;\r\nacpi_status status;\r\nif (ds) {\r\nstatus = acpi_evaluate_integer(ds->handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && sta)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hot_remove_dock_devices(struct dock_station *ds)\r\n{\r\nstruct dock_dependent_device *dd;\r\nlist_for_each_entry_reverse(dd, &ds->dependent_devices, list)\r\ndock_hotplug_event(dd, ACPI_NOTIFY_EJECT_REQUEST, false);\r\nlist_for_each_entry_reverse(dd, &ds->dependent_devices, list)\r\nacpi_bus_trim(dd->adev);\r\n}\r\nstatic void hotplug_dock_devices(struct dock_station *ds, u32 event)\r\n{\r\nstruct dock_dependent_device *dd;\r\nlist_for_each_entry(dd, &ds->dependent_devices, list)\r\ndock_hotplug_event(dd, event, DOCK_CALL_FIXUP);\r\nlist_for_each_entry(dd, &ds->dependent_devices, list)\r\ndock_hotplug_event(dd, event, DOCK_CALL_HANDLER);\r\nlist_for_each_entry(dd, &ds->dependent_devices, list) {\r\nstruct acpi_device *adev = dd->adev;\r\nif (!acpi_device_enumerated(adev)) {\r\nint ret = acpi_bus_scan(adev->handle);\r\nif (ret)\r\ndev_dbg(&adev->dev, "scan error %d\n", -ret);\r\n}\r\n}\r\n}\r\nstatic void dock_event(struct dock_station *ds, u32 event, int num)\r\n{\r\nstruct device *dev = &ds->dock_device->dev;\r\nchar event_string[13];\r\nchar *envp[] = { event_string, NULL };\r\nstruct dock_dependent_device *dd;\r\nif (num == UNDOCK_EVENT)\r\nsprintf(event_string, "EVENT=undock");\r\nelse\r\nsprintf(event_string, "EVENT=dock");\r\nif (num == DOCK_EVENT)\r\nkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\r\nlist_for_each_entry(dd, &ds->dependent_devices, list)\r\ndock_hotplug_event(dd, event, DOCK_CALL_UEVENT);\r\nif (num != DOCK_EVENT)\r\nkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\r\n}\r\nstatic void handle_dock(struct dock_station *ds, int dock)\r\n{\r\nacpi_status status;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nunsigned long long value;\r\nacpi_handle_info(ds->handle, "%s\n", dock ? "docking" : "undocking");\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = dock;\r\nstatus = acpi_evaluate_integer(ds->handle, "_DCK", &arg_list, &value);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND)\r\nacpi_handle_err(ds->handle, "Failed to execute _DCK (0x%x)\n",\r\nstatus);\r\n}\r\nstatic inline void dock(struct dock_station *ds)\r\n{\r\nhandle_dock(ds, 1);\r\n}\r\nstatic inline void undock(struct dock_station *ds)\r\n{\r\nhandle_dock(ds, 0);\r\n}\r\nstatic inline void begin_dock(struct dock_station *ds)\r\n{\r\nds->flags |= DOCK_DOCKING;\r\n}\r\nstatic inline void complete_dock(struct dock_station *ds)\r\n{\r\nds->flags &= ~(DOCK_DOCKING);\r\nds->last_dock_time = jiffies;\r\n}\r\nstatic inline void begin_undock(struct dock_station *ds)\r\n{\r\nds->flags |= DOCK_UNDOCKING;\r\n}\r\nstatic inline void complete_undock(struct dock_station *ds)\r\n{\r\nds->flags &= ~(DOCK_UNDOCKING);\r\n}\r\nstatic int dock_in_progress(struct dock_station *ds)\r\n{\r\nif ((ds->flags & DOCK_DOCKING) ||\r\ntime_before(jiffies, (ds->last_dock_time + HZ)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int handle_eject_request(struct dock_station *ds, u32 event)\r\n{\r\nif (dock_in_progress(ds))\r\nreturn -EBUSY;\r\ndock_event(ds, event, UNDOCK_EVENT);\r\nhot_remove_dock_devices(ds);\r\nundock(ds);\r\nacpi_evaluate_lck(ds->handle, 0);\r\nacpi_evaluate_ej0(ds->handle);\r\nif (dock_present(ds)) {\r\nacpi_handle_err(ds->handle, "Unable to undock!\n");\r\nreturn -EBUSY;\r\n}\r\ncomplete_undock(ds);\r\nreturn 0;\r\n}\r\nint dock_notify(struct acpi_device *adev, u32 event)\r\n{\r\nacpi_handle handle = adev->handle;\r\nstruct dock_station *ds = find_dock_station(handle);\r\nint surprise_removal = 0;\r\nif (!ds)\r\nreturn -ENODEV;\r\nif ((ds->flags & DOCK_IS_DOCK) && event == ACPI_NOTIFY_DEVICE_CHECK)\r\nevent = ACPI_NOTIFY_EJECT_REQUEST;\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nif (!dock_in_progress(ds) && !acpi_device_enumerated(adev)) {\r\nbegin_dock(ds);\r\ndock(ds);\r\nif (!dock_present(ds)) {\r\nacpi_handle_err(handle, "Unable to dock!\n");\r\ncomplete_dock(ds);\r\nbreak;\r\n}\r\nhotplug_dock_devices(ds, event);\r\ncomplete_dock(ds);\r\ndock_event(ds, event, DOCK_EVENT);\r\nacpi_evaluate_lck(ds->handle, 1);\r\nacpi_update_all_gpes();\r\nbreak;\r\n}\r\nif (dock_present(ds) || dock_in_progress(ds))\r\nbreak;\r\nsurprise_removal = 1;\r\nevent = ACPI_NOTIFY_EJECT_REQUEST;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nbegin_undock(ds);\r\nif ((immediate_undock && !(ds->flags & DOCK_IS_ATA))\r\n|| surprise_removal)\r\nhandle_eject_request(ds, event);\r\nelse\r\ndock_event(ds, event, UNDOCK_EVENT);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t show_docked(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dock_station *dock_station = dev->platform_data;\r\nstruct acpi_device *adev = NULL;\r\nacpi_bus_get_device(dock_station->handle, &adev);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", acpi_device_enumerated(adev));\r\n}\r\nstatic ssize_t show_flags(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dock_station *dock_station = dev->platform_data;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", dock_station->flags);\r\n}\r\nstatic ssize_t write_undock(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nstruct dock_station *dock_station = dev->platform_data;\r\nif (!count)\r\nreturn -EINVAL;\r\nacpi_scan_lock_acquire();\r\nbegin_undock(dock_station);\r\nret = handle_eject_request(dock_station, ACPI_NOTIFY_EJECT_REQUEST);\r\nacpi_scan_lock_release();\r\nreturn ret ? ret: count;\r\n}\r\nstatic ssize_t show_dock_uid(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long long lbuf;\r\nstruct dock_station *dock_station = dev->platform_data;\r\nacpi_status status = acpi_evaluate_integer(dock_station->handle,\r\n"_UID", NULL, &lbuf);\r\nif (ACPI_FAILURE(status))\r\nreturn 0;\r\nreturn snprintf(buf, PAGE_SIZE, "%llx\n", lbuf);\r\n}\r\nstatic ssize_t show_dock_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dock_station *dock_station = dev->platform_data;\r\nchar *type;\r\nif (dock_station->flags & DOCK_IS_DOCK)\r\ntype = "dock_station";\r\nelse if (dock_station->flags & DOCK_IS_ATA)\r\ntype = "ata_bay";\r\nelse if (dock_station->flags & DOCK_IS_BAT)\r\ntype = "battery_bay";\r\nelse\r\ntype = "unknown";\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", type);\r\n}\r\nvoid acpi_dock_add(struct acpi_device *adev)\r\n{\r\nstruct dock_station *dock_station, ds = { NULL, };\r\nstruct platform_device_info pdevinfo;\r\nacpi_handle handle = adev->handle;\r\nstruct platform_device *dd;\r\nint ret;\r\nmemset(&pdevinfo, 0, sizeof(pdevinfo));\r\npdevinfo.name = "dock";\r\npdevinfo.id = dock_station_count;\r\npdevinfo.fwnode = acpi_fwnode_handle(adev);\r\npdevinfo.data = &ds;\r\npdevinfo.size_data = sizeof(ds);\r\ndd = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(dd))\r\nreturn;\r\ndock_station = dd->dev.platform_data;\r\ndock_station->handle = handle;\r\ndock_station->dock_device = dd;\r\ndock_station->last_dock_time = jiffies - HZ;\r\nINIT_LIST_HEAD(&dock_station->sibling);\r\nINIT_LIST_HEAD(&dock_station->dependent_devices);\r\ndev_set_uevent_suppress(&dd->dev, 0);\r\nif (acpi_dock_match(handle))\r\ndock_station->flags |= DOCK_IS_DOCK;\r\nif (acpi_ata_match(handle))\r\ndock_station->flags |= DOCK_IS_ATA;\r\nif (acpi_device_is_battery(adev))\r\ndock_station->flags |= DOCK_IS_BAT;\r\nret = sysfs_create_group(&dd->dev.kobj, &dock_attribute_group);\r\nif (ret)\r\ngoto err_unregister;\r\nret = add_dock_dependent_device(dock_station, adev);\r\nif (ret)\r\ngoto err_rmgroup;\r\ndock_station_count++;\r\nlist_add(&dock_station->sibling, &dock_stations);\r\nadev->flags.is_dock_station = true;\r\ndev_info(&adev->dev, "ACPI dock station (docks/bays count: %d)\n",\r\ndock_station_count);\r\nreturn;\r\nerr_rmgroup:\r\nsysfs_remove_group(&dd->dev.kobj, &dock_attribute_group);\r\nerr_unregister:\r\nplatform_device_unregister(dd);\r\nacpi_handle_err(handle, "%s encountered error %d\n", __func__, ret);\r\n}
