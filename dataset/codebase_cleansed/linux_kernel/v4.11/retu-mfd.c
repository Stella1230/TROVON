int retu_read(struct retu_dev *rdev, u8 reg)\r\n{\r\nint ret;\r\nint value;\r\nmutex_lock(&rdev->mutex);\r\nret = regmap_read(rdev->regmap, reg, &value);\r\nmutex_unlock(&rdev->mutex);\r\nreturn ret ? ret : value;\r\n}\r\nint retu_write(struct retu_dev *rdev, u8 reg, u16 data)\r\n{\r\nint ret;\r\nmutex_lock(&rdev->mutex);\r\nret = regmap_write(rdev->regmap, reg, data);\r\nmutex_unlock(&rdev->mutex);\r\nreturn ret;\r\n}\r\nstatic void retu_power_off(void)\r\n{\r\nstruct retu_dev *rdev = retu_pm_power_off;\r\nint reg;\r\nmutex_lock(&retu_pm_power_off->mutex);\r\nregmap_read(rdev->regmap, RETU_REG_CC1, &reg);\r\nregmap_write(rdev->regmap, RETU_REG_CC1, reg | 2);\r\nregmap_write(rdev->regmap, RETU_REG_WATCHDOG, 0);\r\nfor (;;)\r\ncpu_relax();\r\nmutex_unlock(&retu_pm_power_off->mutex);\r\n}\r\nstatic int retu_regmap_read(void *context, const void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nint ret;\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nBUG_ON(reg_size != 1 || val_size != 2);\r\nret = i2c_smbus_read_word_data(i2c, *(u8 const *)reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*(u16 *)val = ret;\r\nreturn 0;\r\n}\r\nstatic int retu_regmap_write(void *context, const void *data, size_t count)\r\n{\r\nu8 reg;\r\nu16 val;\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nBUG_ON(count != sizeof(reg) + sizeof(val));\r\nmemcpy(&reg, data, sizeof(reg));\r\nmemcpy(&val, data + sizeof(reg), sizeof(val));\r\nreturn i2c_smbus_write_word_data(i2c, reg, val);\r\n}\r\nstatic int retu_probe(struct i2c_client *i2c, const struct i2c_device_id *id)\r\n{\r\nstruct retu_data const *rdat;\r\nstruct retu_dev *rdev;\r\nint ret;\r\nif (i2c->addr > ARRAY_SIZE(retu_data))\r\nreturn -ENODEV;\r\nrdat = &retu_data[i2c->addr - 1];\r\nrdev = devm_kzalloc(&i2c->dev, sizeof(*rdev), GFP_KERNEL);\r\nif (rdev == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, rdev);\r\nrdev->dev = &i2c->dev;\r\nmutex_init(&rdev->mutex);\r\nrdev->regmap = devm_regmap_init(&i2c->dev, &retu_bus, &i2c->dev,\r\n&retu_config);\r\nif (IS_ERR(rdev->regmap))\r\nreturn PTR_ERR(rdev->regmap);\r\nret = retu_read(rdev, RETU_REG_ASICR);\r\nif (ret < 0) {\r\ndev_err(rdev->dev, "could not read %s revision: %d\n",\r\nrdat->chip_name, ret);\r\nreturn ret;\r\n}\r\ndev_info(rdev->dev, "%s%s%s v%d.%d found\n", rdat->chip_name,\r\n(ret & RETU_REG_ASICR_VILMA) ? " & " : "",\r\n(ret & RETU_REG_ASICR_VILMA) ? rdat->companion_name : "",\r\n(ret >> 4) & 0x7, ret & 0xf);\r\nret = retu_write(rdev, rdat->irq_chip->mask_base, 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_add_irq_chip(rdev->regmap, i2c->irq, IRQF_ONESHOT, -1,\r\nrdat->irq_chip, &rdev->irq_data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mfd_add_devices(rdev->dev, -1, rdat->children, rdat->nchildren,\r\nNULL, regmap_irq_chip_get_base(rdev->irq_data),\r\nNULL);\r\nif (ret < 0) {\r\nregmap_del_irq_chip(i2c->irq, rdev->irq_data);\r\nreturn ret;\r\n}\r\nif (i2c->addr == 1 && !pm_power_off) {\r\nretu_pm_power_off = rdev;\r\npm_power_off = retu_power_off;\r\n}\r\nreturn 0;\r\n}\r\nstatic int retu_remove(struct i2c_client *i2c)\r\n{\r\nstruct retu_dev *rdev = i2c_get_clientdata(i2c);\r\nif (retu_pm_power_off == rdev) {\r\npm_power_off = NULL;\r\nretu_pm_power_off = NULL;\r\n}\r\nmfd_remove_devices(rdev->dev);\r\nregmap_del_irq_chip(i2c->irq, rdev->irq_data);\r\nreturn 0;\r\n}
