static int berlin2_avpll_vco_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\r\nu32 reg;\r\nreg = readl_relaxed(vco->base + VCO_CTRL0);\r\nif (vco->flags & BERLIN2_AVPLL_BIT_QUIRK)\r\nreg >>= 4;\r\nreturn !!(reg & VCO_POWERUP);\r\n}\r\nstatic int berlin2_avpll_vco_enable(struct clk_hw *hw)\r\n{\r\nstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\r\nu32 reg;\r\nreg = readl_relaxed(vco->base + VCO_CTRL0);\r\nif (vco->flags & BERLIN2_AVPLL_BIT_QUIRK)\r\nreg |= VCO_POWERUP << 4;\r\nelse\r\nreg |= VCO_POWERUP;\r\nwritel_relaxed(reg, vco->base + VCO_CTRL0);\r\nreturn 0;\r\n}\r\nstatic void berlin2_avpll_vco_disable(struct clk_hw *hw)\r\n{\r\nstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\r\nu32 reg;\r\nreg = readl_relaxed(vco->base + VCO_CTRL0);\r\nif (vco->flags & BERLIN2_AVPLL_BIT_QUIRK)\r\nreg &= ~(VCO_POWERUP << 4);\r\nelse\r\nreg &= ~VCO_POWERUP;\r\nwritel_relaxed(reg, vco->base + VCO_CTRL0);\r\n}\r\nstatic unsigned long\r\nberlin2_avpll_vco_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct berlin2_avpll_vco *vco = to_avpll_vco(hw);\r\nu32 reg, refdiv, fbdiv;\r\nu64 freq = parent_rate;\r\nreg = readl_relaxed(vco->base + VCO_CTRL1);\r\nrefdiv = (reg & VCO_REFDIV_MASK) >> VCO_REFDIV_SHIFT;\r\nrefdiv = vco_refdiv[refdiv];\r\nfbdiv = (reg & VCO_FBDIV_MASK) >> VCO_FBDIV_SHIFT;\r\nfreq *= fbdiv;\r\ndo_div(freq, refdiv);\r\nreturn (unsigned long)freq;\r\n}\r\nint __init berlin2_avpll_vco_register(void __iomem *base,\r\nconst char *name, const char *parent_name,\r\nu8 vco_flags, unsigned long flags)\r\n{\r\nstruct berlin2_avpll_vco *vco;\r\nstruct clk_init_data init;\r\nvco = kzalloc(sizeof(*vco), GFP_KERNEL);\r\nif (!vco)\r\nreturn -ENOMEM;\r\nvco->base = base;\r\nvco->flags = vco_flags;\r\nvco->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = &berlin2_avpll_vco_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = flags;\r\nreturn clk_hw_register(NULL, &vco->hw);\r\n}\r\nstatic int berlin2_avpll_channel_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\r\nu32 reg;\r\nif (ch->index == 7)\r\nreturn 1;\r\nreg = readl_relaxed(ch->base + VCO_CTRL10);\r\nreg &= VCO_POWERUP_CH1 << ch->index;\r\nreturn !!reg;\r\n}\r\nstatic int berlin2_avpll_channel_enable(struct clk_hw *hw)\r\n{\r\nstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\r\nu32 reg;\r\nreg = readl_relaxed(ch->base + VCO_CTRL10);\r\nreg |= VCO_POWERUP_CH1 << ch->index;\r\nwritel_relaxed(reg, ch->base + VCO_CTRL10);\r\nreturn 0;\r\n}\r\nstatic void berlin2_avpll_channel_disable(struct clk_hw *hw)\r\n{\r\nstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\r\nu32 reg;\r\nreg = readl_relaxed(ch->base + VCO_CTRL10);\r\nreg &= ~(VCO_POWERUP_CH1 << ch->index);\r\nwritel_relaxed(reg, ch->base + VCO_CTRL10);\r\n}\r\nstatic unsigned long\r\nberlin2_avpll_channel_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nstruct berlin2_avpll_channel *ch = to_avpll_channel(hw);\r\nu32 reg, div_av2, div_av3, divider = 1;\r\nu64 freq = parent_rate;\r\nreg = readl_relaxed(ch->base + VCO_CTRL30);\r\nif ((reg & (VCO_DPLL_CH1_ENABLE << ch->index)) == 0)\r\ngoto skip_div;\r\nreg = readl_relaxed(ch->base + VCO_SYNC1n(ch->index));\r\nif (ch->flags & BERLIN2_AVPLL_BIT_QUIRK && ch->index == 0)\r\nreg >>= 4;\r\ndivider = reg & VCO_SYNC1_MASK;\r\nreg = readl_relaxed(ch->base + VCO_SYNC2n(ch->index));\r\nfreq *= reg & VCO_SYNC2_MASK;\r\nif (ch->index == 7)\r\ngoto skip_div;\r\nreg = readl_relaxed(ch->base + VCO_CTRL11) >> 7;\r\nreg = (reg >> (ch->index * 3));\r\nif (reg & BIT(2))\r\ndivider *= div_hdmi[reg & 0x3];\r\nif (ch->index == 0) {\r\nreg = readl_relaxed(ch->base + VCO_CTRL11);\r\nreg >>= 28;\r\n} else {\r\nreg = readl_relaxed(ch->base + VCO_CTRL12);\r\nreg >>= (ch->index-1) * 3;\r\n}\r\nif (reg & BIT(2))\r\ndivider *= div_av1[reg & 0x3];\r\nif (ch->index < 2) {\r\nreg = readl_relaxed(ch->base + VCO_CTRL12);\r\nreg >>= 18 + (ch->index * 7);\r\n} else if (ch->index < 7) {\r\nreg = readl_relaxed(ch->base + VCO_CTRL13);\r\nreg >>= (ch->index - 2) * 7;\r\n} else {\r\nreg = readl_relaxed(ch->base + VCO_CTRL14);\r\n}\r\ndiv_av2 = reg & 0x7f;\r\nif (div_av2)\r\ndivider *= div_av2;\r\nif (ch->index < 6) {\r\nreg = readl_relaxed(ch->base + VCO_CTRL14);\r\nreg >>= 7 + (ch->index * 4);\r\n} else {\r\nreg = readl_relaxed(ch->base + VCO_CTRL15);\r\n}\r\ndiv_av3 = reg & 0xf;\r\nif (div_av2 && div_av3)\r\nfreq *= 2;\r\nskip_div:\r\ndo_div(freq, divider);\r\nreturn (unsigned long)freq;\r\n}\r\nint __init berlin2_avpll_channel_register(void __iomem *base,\r\nconst char *name, u8 index, const char *parent_name,\r\nu8 ch_flags, unsigned long flags)\r\n{\r\nstruct berlin2_avpll_channel *ch;\r\nstruct clk_init_data init;\r\nch = kzalloc(sizeof(*ch), GFP_KERNEL);\r\nif (!ch)\r\nreturn -ENOMEM;\r\nch->base = base;\r\nif (ch_flags & BERLIN2_AVPLL_SCRAMBLE_QUIRK)\r\nch->index = quirk_index[index];\r\nelse\r\nch->index = index;\r\nch->flags = ch_flags;\r\nch->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = &berlin2_avpll_channel_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = flags;\r\nreturn clk_hw_register(NULL, &ch->hw);\r\n}
