static int atyfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu16 xoff, yoff;\r\nint x, y, h;\r\n#ifdef __sparc__\r\nif (par->mmaped)\r\nreturn -EPERM;\r\n#endif\r\nif (par->asleep)\r\nreturn -EPERM;\r\nwait_for_fifo(1, par);\r\nif (cursor->enable)\r\naty_st_le32(GEN_TEST_CNTL, aty_ld_le32(GEN_TEST_CNTL, par)\r\n| HWCURSOR_ENABLE, par);\r\nelse\r\naty_st_le32(GEN_TEST_CNTL, aty_ld_le32(GEN_TEST_CNTL, par)\r\n& ~HWCURSOR_ENABLE, par);\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nx = cursor->image.dx - cursor->hot.x - info->var.xoffset;\r\nif (x < 0) {\r\nxoff = -x;\r\nx = 0;\r\n} else {\r\nxoff = 0;\r\n}\r\ny = cursor->image.dy - cursor->hot.y - info->var.yoffset;\r\nif (y < 0) {\r\nyoff = -y;\r\ny = 0;\r\n} else {\r\nyoff = 0;\r\n}\r\nh = cursor->image.height;\r\nif (par->crtc.gen_cntl & CRTC_DBL_SCAN_EN) {\r\ny<<=1;\r\nh<<=1;\r\n}\r\nwait_for_fifo(3, par);\r\naty_st_le32(CUR_OFFSET, (info->fix.smem_len >> 3) + (yoff << 1), par);\r\naty_st_le32(CUR_HORZ_VERT_OFF,\r\n((u32) (64 - h + yoff) << 16) | xoff, par);\r\naty_st_le32(CUR_HORZ_VERT_POSN, ((u32) y << 16) | x, par);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nu32 fg_idx, bg_idx, fg, bg;\r\nfg_idx = cursor->image.fg_color;\r\nbg_idx = cursor->image.bg_color;\r\nfg = ((info->cmap.red[fg_idx] & 0xff) << 24) |\r\n((info->cmap.green[fg_idx] & 0xff) << 16) |\r\n((info->cmap.blue[fg_idx] & 0xff) << 8) | 0xff;\r\nbg = ((info->cmap.red[bg_idx] & 0xff) << 24) |\r\n((info->cmap.green[bg_idx] & 0xff) << 16) |\r\n((info->cmap.blue[bg_idx] & 0xff) << 8);\r\nwait_for_fifo(2, par);\r\naty_st_le32(CUR_CLR0, bg, par);\r\naty_st_le32(CUR_CLR1, fg, par);\r\n}\r\nif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nu8 *src = (u8 *)cursor->image.data;\r\nu8 *msk = (u8 *)cursor->mask;\r\nu8 __iomem *dst = (u8 __iomem *)info->sprite.addr;\r\nunsigned int width = (cursor->image.width + 7) >> 3;\r\nunsigned int height = cursor->image.height;\r\nunsigned int align = info->sprite.scan_align;\r\nunsigned int i, j, offset;\r\nu8 m, b;\r\nfb_memset(dst, 0xaa, 1024);\r\noffset = align - width*2;\r\nfor (i = 0; i < height; i++) {\r\nfor (j = 0; j < width; j++) {\r\nu16 l = 0xaaaa;\r\nb = *src++;\r\nm = *msk++;\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nl = cursor_bits_lookup[(b ^ m) >> 4] |\r\n(cursor_bits_lookup[(b ^ m) & 0x0f] << 8);\r\nbreak;\r\ncase ROP_COPY:\r\nl = cursor_bits_lookup[(b & m) >> 4] |\r\n(cursor_bits_lookup[(b & m) & 0x0f] << 8);\r\nbreak;\r\n}\r\nif ((j + 1) * 8 > cursor->image.width) {\r\nl = comp(l, 0xaaaa,\r\n(1 << ((cursor->image.width & 7) * 2)) - 1);\r\n}\r\nfb_writeb(l & 0xff, dst++);\r\nfb_writeb(l >> 8, dst++);\r\n}\r\ndst += offset;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint aty_init_cursor(struct fb_info *info)\r\n{\r\nunsigned long addr;\r\ninfo->fix.smem_len -= PAGE_SIZE;\r\n#ifdef __sparc__\r\naddr = (unsigned long) info->screen_base - 0x800000 + info->fix.smem_len;\r\ninfo->sprite.addr = (u8 *) addr;\r\n#else\r\n#ifdef __BIG_ENDIAN\r\naddr = info->fix.smem_start - 0x800000 + info->fix.smem_len;\r\ninfo->sprite.addr = (u8 *) ioremap(addr, 1024);\r\n#else\r\naddr = (unsigned long) info->screen_base + info->fix.smem_len;\r\ninfo->sprite.addr = (u8 *) addr;\r\n#endif\r\n#endif\r\nif (!info->sprite.addr)\r\nreturn -ENXIO;\r\ninfo->sprite.size = PAGE_SIZE;\r\ninfo->sprite.scan_align = 16;\r\ninfo->sprite.buf_align = 16;\r\ninfo->sprite.flags = FB_PIXMAP_IO;\r\ninfo->fbops->fb_cursor = atyfb_cursor;\r\nreturn 0;\r\n}
