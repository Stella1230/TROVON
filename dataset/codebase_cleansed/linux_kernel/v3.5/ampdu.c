static void brcms_c_scb_ampdu_update_max_txlen(struct ampdu_info *ampdu, u8 dur)\r\n{\r\nu32 rate, mcs;\r\nfor (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {\r\nrate = mcs_2_rate(mcs, false, false);\r\nampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;\r\nrate = mcs_2_rate(mcs, true, false);\r\nampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;\r\nrate = mcs_2_rate(mcs, false, true);\r\nampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;\r\nrate = mcs_2_rate(mcs, true, true);\r\nampdu->max_txlen[mcs][1][1] = (rate * dur) >> 3;\r\n}\r\n}\r\nstatic bool brcms_c_ampdu_cap(struct ampdu_info *ampdu)\r\n{\r\nif (BRCMS_PHY_11N_CAP(ampdu->wlc->band))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int brcms_c_ampdu_set(struct ampdu_info *ampdu, bool on)\r\n{\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nwlc->pub->_ampdu = false;\r\nif (on) {\r\nif (!(wlc->pub->_n_enab & SUPPORT_11N)) {\r\nwiphy_err(ampdu->wlc->wiphy, "wl%d: driver not "\r\n"nmode enabled\n", wlc->pub->unit);\r\nreturn -ENOTSUPP;\r\n}\r\nif (!brcms_c_ampdu_cap(ampdu)) {\r\nwiphy_err(ampdu->wlc->wiphy, "wl%d: device not "\r\n"ampdu capable\n", wlc->pub->unit);\r\nreturn -ENOTSUPP;\r\n}\r\nwlc->pub->_ampdu = on;\r\n}\r\nreturn 0;\r\n}\r\nstatic void brcms_c_ffpld_init(struct ampdu_info *ampdu)\r\n{\r\nint i, j;\r\nstruct brcms_fifo_info *fifo;\r\nfor (j = 0; j < NUM_FFPLD_FIFO; j++) {\r\nfifo = (ampdu->fifo_tb + j);\r\nfifo->ampdu_pld_size = 0;\r\nfor (i = 0; i <= FFPLD_MAX_MCS; i++)\r\nfifo->mcs2ampdu_table[i] = 255;\r\nfifo->dmaxferrate = 0;\r\nfifo->accum_txampdu = 0;\r\nfifo->prev_txfunfl = 0;\r\nfifo->accum_txfunfl = 0;\r\n}\r\n}\r\nstruct ampdu_info *brcms_c_ampdu_attach(struct brcms_c_info *wlc)\r\n{\r\nstruct ampdu_info *ampdu;\r\nint i;\r\nampdu = kzalloc(sizeof(struct ampdu_info), GFP_ATOMIC);\r\nif (!ampdu)\r\nreturn NULL;\r\nampdu->wlc = wlc;\r\nfor (i = 0; i < AMPDU_MAX_SCB_TID; i++)\r\nampdu->ini_enable[i] = true;\r\nampdu->ini_enable[PRIO_8021D_VO] = false;\r\nampdu->ini_enable[PRIO_8021D_NC] = false;\r\nampdu->ini_enable[PRIO_8021D_NONE] = false;\r\nampdu->ini_enable[PRIO_8021D_BK] = false;\r\nampdu->ba_tx_wsize = AMPDU_TX_BA_DEF_WSIZE;\r\nampdu->ba_rx_wsize = AMPDU_RX_BA_DEF_WSIZE;\r\nampdu->mpdu_density = AMPDU_DEF_MPDU_DENSITY;\r\nampdu->max_pdu = AUTO;\r\nampdu->dur = AMPDU_MAX_DUR;\r\nampdu->txpkt_weight = AMPDU_DEF_TXPKT_WEIGHT;\r\nampdu->ffpld_rsvd = AMPDU_DEF_FFPLD_RSVD;\r\nif (BRCMS_ISNPHY(wlc->band) && NREV_LT(wlc->band->phyrev, 2))\r\nampdu->rx_factor = IEEE80211_HT_MAX_AMPDU_32K;\r\nelse\r\nampdu->rx_factor = IEEE80211_HT_MAX_AMPDU_64K;\r\nampdu->retry_limit = AMPDU_DEF_RETRY_LIMIT;\r\nampdu->rr_retry_limit = AMPDU_DEF_RR_RETRY_LIMIT;\r\nfor (i = 0; i < AMPDU_MAX_SCB_TID; i++) {\r\nampdu->retry_limit_tid[i] = ampdu->retry_limit;\r\nampdu->rr_retry_limit_tid[i] = ampdu->rr_retry_limit;\r\n}\r\nbrcms_c_scb_ampdu_update_max_txlen(ampdu, ampdu->dur);\r\nampdu->mfbr = false;\r\nbrcms_c_ampdu_set(ampdu, wlc->pub->_ampdu);\r\nampdu->tx_max_funl = FFPLD_TX_MAX_UNFL;\r\nbrcms_c_ffpld_init(ampdu);\r\nreturn ampdu;\r\n}\r\nvoid brcms_c_ampdu_detach(struct ampdu_info *ampdu)\r\n{\r\nkfree(ampdu);\r\n}\r\nstatic void brcms_c_scb_ampdu_update_config(struct ampdu_info *ampdu,\r\nstruct scb *scb)\r\n{\r\nstruct scb_ampdu *scb_ampdu = &scb->scb_ampdu;\r\nint i;\r\nscb_ampdu->max_pdu = AMPDU_NUM_MPDU;\r\nfor (i = 0; i < NUM_FFPLD_FIFO; i++) {\r\nif (ampdu->fifo_tb[i].ampdu_pld_size > FFPLD_PLD_INCR)\r\nscb_ampdu->max_pdu = AMPDU_NUM_MPDU_LEGACY;\r\n}\r\nif (ampdu->max_pdu != AUTO)\r\nscb_ampdu->max_pdu = (u8) ampdu->max_pdu;\r\nscb_ampdu->release = min_t(u8, scb_ampdu->max_pdu,\r\nAMPDU_SCB_MAX_RELEASE);\r\nif (scb_ampdu->max_rx_ampdu_bytes)\r\nscb_ampdu->release = min_t(u8, scb_ampdu->release,\r\nscb_ampdu->max_rx_ampdu_bytes / 1600);\r\nscb_ampdu->release = min(scb_ampdu->release,\r\nampdu->fifo_tb[TX_AC_BE_FIFO].\r\nmcs2ampdu_table[FFPLD_MAX_MCS]);\r\n}\r\nstatic void brcms_c_scb_ampdu_update_config_all(struct ampdu_info *ampdu)\r\n{\r\nbrcms_c_scb_ampdu_update_config(ampdu, &ampdu->wlc->pri_scb);\r\n}\r\nstatic void brcms_c_ffpld_calc_mcs2ampdu_table(struct ampdu_info *ampdu, int f)\r\n{\r\nint i;\r\nu32 phy_rate, dma_rate, tmp;\r\nu8 max_mpdu;\r\nstruct brcms_fifo_info *fifo = (ampdu->fifo_tb + f);\r\nmax_mpdu = min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS],\r\nAMPDU_NUM_MPDU_LEGACY);\r\nphy_rate = mcs_2_rate(FFPLD_MAX_MCS, true, false);\r\ndma_rate =\r\n(((phy_rate / 100) *\r\n(max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))\r\n/ (max_mpdu * FFPLD_MPDU_SIZE)) * 100;\r\nfifo->dmaxferrate = dma_rate;\r\ndma_rate = dma_rate >> 7;\r\nfor (i = 0; i < FFPLD_MAX_MCS; i++) {\r\nphy_rate = mcs_2_rate(i, true, false) >> 7;\r\nif (phy_rate > dma_rate) {\r\ntmp = ((fifo->ampdu_pld_size * phy_rate) /\r\n((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;\r\ntmp = min_t(u32, tmp, 255);\r\nfifo->mcs2ampdu_table[i] = (u8) tmp;\r\n}\r\n}\r\n}\r\nstatic int brcms_c_ffpld_check_txfunfl(struct brcms_c_info *wlc, int fid)\r\n{\r\nstruct ampdu_info *ampdu = wlc->ampdu;\r\nu32 phy_rate = mcs_2_rate(FFPLD_MAX_MCS, true, false);\r\nu32 txunfl_ratio;\r\nu8 max_mpdu;\r\nu32 current_ampdu_cnt = 0;\r\nu16 max_pld_size;\r\nu32 new_txunfl;\r\nstruct brcms_fifo_info *fifo = (ampdu->fifo_tb + fid);\r\nuint xmtfifo_sz;\r\nu16 cur_txunfl;\r\ncur_txunfl = brcms_b_read_shm(wlc->hw,\r\nM_UCODE_MACSTAT +\r\noffsetof(struct macstat, txfunfl[fid]));\r\nnew_txunfl = (u16) (cur_txunfl - fifo->prev_txfunfl);\r\nif (new_txunfl == 0) {\r\nBCMMSG(wlc->wiphy, "TX status FRAG set but no tx underflows\n");\r\nreturn -1;\r\n}\r\nfifo->prev_txfunfl = cur_txunfl;\r\nif (!ampdu->tx_max_funl)\r\nreturn 1;\r\nif (brcms_b_xmtfifo_sz_get(wlc->hw, fid, &xmtfifo_sz))\r\nreturn -1;\r\nif ((TXFIFO_SIZE_UNIT * (u32) xmtfifo_sz) <= ampdu->ffpld_rsvd)\r\nreturn 1;\r\nmax_pld_size = TXFIFO_SIZE_UNIT * xmtfifo_sz - ampdu->ffpld_rsvd;\r\nfifo->accum_txfunfl += new_txunfl;\r\nif (fifo->accum_txfunfl < 10)\r\nreturn 0;\r\nBCMMSG(wlc->wiphy, "ampdu_count %d tx_underflows %d\n",\r\ncurrent_ampdu_cnt, fifo->accum_txfunfl);\r\ntxunfl_ratio = current_ampdu_cnt / fifo->accum_txfunfl;\r\nif (txunfl_ratio > ampdu->tx_max_funl) {\r\nif (current_ampdu_cnt >= FFPLD_MAX_AMPDU_CNT)\r\nfifo->accum_txfunfl = 0;\r\nreturn 0;\r\n}\r\nmax_mpdu = min_t(u8, fifo->mcs2ampdu_table[FFPLD_MAX_MCS],\r\nAMPDU_NUM_MPDU_LEGACY);\r\nif (fifo->ampdu_pld_size >= max_mpdu * FFPLD_MPDU_SIZE) {\r\nfifo->accum_txfunfl = 0;\r\nreturn 0;\r\n}\r\nif (fifo->ampdu_pld_size < max_pld_size) {\r\nfifo->ampdu_pld_size += FFPLD_PLD_INCR;\r\nif (fifo->ampdu_pld_size > max_pld_size)\r\nfifo->ampdu_pld_size = max_pld_size;\r\nbrcms_c_scb_ampdu_update_config_all(ampdu);\r\nfifo->dmaxferrate =\r\n(((phy_rate / 100) *\r\n(max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))\r\n/ (max_mpdu * FFPLD_MPDU_SIZE)) * 100;\r\nBCMMSG(wlc->wiphy, "DMA estimated transfer rate %d; "\r\n"pre-load size %d\n",\r\nfifo->dmaxferrate, fifo->ampdu_pld_size);\r\n} else {\r\nif (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] > 1) {\r\nif (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] == 255)\r\nfifo->mcs2ampdu_table[FFPLD_MAX_MCS] =\r\nAMPDU_NUM_MPDU_LEGACY - 1;\r\nelse\r\nfifo->mcs2ampdu_table[FFPLD_MAX_MCS] -= 1;\r\nbrcms_c_ffpld_calc_mcs2ampdu_table(ampdu, fid);\r\nbrcms_c_scb_ampdu_update_config_all(ampdu);\r\n}\r\n}\r\nfifo->accum_txfunfl = 0;\r\nreturn 0;\r\n}\r\nvoid\r\nbrcms_c_ampdu_tx_operational(struct brcms_c_info *wlc, u8 tid,\r\nu8 ba_wsize,\r\nuint max_rx_ampdu_bytes)\r\n{\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct scb_ampdu_tid_ini *ini;\r\nstruct ampdu_info *ampdu = wlc->ampdu;\r\nstruct scb *scb = &wlc->pri_scb;\r\nscb_ampdu = &scb->scb_ampdu;\r\nif (!ampdu->ini_enable[tid]) {\r\nwiphy_err(ampdu->wlc->wiphy, "%s: Rejecting tid %d\n",\r\n__func__, tid);\r\nreturn;\r\n}\r\nini = &scb_ampdu->ini[tid];\r\nini->tid = tid;\r\nini->scb = scb_ampdu->scb;\r\nini->ba_wsize = ba_wsize;\r\nscb_ampdu->max_rx_ampdu_bytes = max_rx_ampdu_bytes;\r\n}\r\nint\r\nbrcms_c_sendampdu(struct ampdu_info *ampdu, struct brcms_txq_info *qi,\r\nstruct sk_buff **pdu, int prec)\r\n{\r\nstruct brcms_c_info *wlc;\r\nstruct sk_buff *p, *pkt[AMPDU_MAX_MPDU];\r\nu8 tid, ndelim;\r\nint err = 0;\r\nu8 preamble_type = BRCMS_GF_PREAMBLE;\r\nu8 fbr_preamble_type = BRCMS_GF_PREAMBLE;\r\nu8 rts_preamble_type = BRCMS_LONG_PREAMBLE;\r\nu8 rts_fbr_preamble_type = BRCMS_LONG_PREAMBLE;\r\nbool rr = true, fbr = false;\r\nuint i, count = 0, fifo, seg_cnt = 0;\r\nu16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;\r\nu32 ampdu_len, max_ampdu_bytes = 0;\r\nstruct d11txh *txh = NULL;\r\nu8 *plcp;\r\nstruct ieee80211_hdr *h;\r\nstruct scb *scb;\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct scb_ampdu_tid_ini *ini;\r\nu8 mcs = 0;\r\nbool use_rts = false, use_cts = false;\r\nu32 rspec = 0, rspec_fallback = 0;\r\nu32 rts_rspec = 0, rts_rspec_fallback = 0;\r\nu16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;\r\nstruct ieee80211_rts *rts;\r\nu8 rr_retry_limit;\r\nstruct brcms_fifo_info *f;\r\nbool fbr_iscck;\r\nstruct ieee80211_tx_info *tx_info;\r\nu16 qlen;\r\nstruct wiphy *wiphy;\r\nwlc = ampdu->wlc;\r\nwiphy = wlc->wiphy;\r\np = *pdu;\r\ntid = (u8) (p->priority);\r\nf = ampdu->fifo_tb + prio2fifo[tid];\r\nscb = &wlc->pri_scb;\r\nscb_ampdu = &scb->scb_ampdu;\r\nini = &scb_ampdu->ini[tid];\r\nqlen = pktq_plen(&qi->q, prec);\r\nif (ini->tx_in_transit > 0 &&\r\nqlen < min(scb_ampdu->max_pdu, ini->ba_wsize))\r\nreturn -EBUSY;\r\nrr_retry_limit = ampdu->rr_retry_limit_tid[tid];\r\nampdu_len = 0;\r\ndma_len = 0;\r\nwhile (p) {\r\nstruct ieee80211_tx_rate *txrate;\r\ntx_info = IEEE80211_SKB_CB(p);\r\ntxrate = tx_info->status.rates;\r\nif (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\r\nerr = brcms_c_prep_pdu(wlc, p, &fifo);\r\n} else {\r\nwiphy_err(wiphy, "%s: AMPDU flag is off!\n", __func__);\r\n*pdu = NULL;\r\nerr = 0;\r\nbreak;\r\n}\r\nif (err) {\r\nif (err == -EBUSY) {\r\nwiphy_err(wiphy, "wl%d: sendampdu: "\r\n"prep_xdu retry; seq 0x%x\n",\r\nwlc->pub->unit, seq);\r\n*pdu = p;\r\nbreak;\r\n}\r\nwiphy_err(wiphy, "wl%d: sendampdu: prep_xdu "\r\n"rejected; seq 0x%x\n", wlc->pub->unit, seq);\r\n*pdu = NULL;\r\nbreak;\r\n}\r\ntxh = (struct d11txh *) p->data;\r\nplcp = (u8 *) (txh + 1);\r\nh = (struct ieee80211_hdr *)(plcp + D11_PHY_HDR_LEN);\r\nseq = le16_to_cpu(h->seq_ctrl) >> SEQNUM_SHIFT;\r\nindex = TX_SEQ_TO_INDEX(seq);\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nmcl &= ~TXC_AMPDU_MASK;\r\nfbr_iscck = !(le16_to_cpu(txh->XtraFrameTypes) & 0x3);\r\ntxh->PreloadSize = 0;\r\nif (txrate[0].count <= rr_retry_limit) {\r\ntxrate[0].count++;\r\nrr = true;\r\nfbr = false;\r\n} else {\r\nfbr = true;\r\nrr = false;\r\ntxrate[1].count++;\r\n}\r\nlen = fbr_iscck ? BRCMS_GET_CCK_PLCP_LEN(txh->FragPLCPFallback)\r\n: BRCMS_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);\r\nndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];\r\nseg_cnt += 1;\r\nBCMMSG(wlc->wiphy, "wl%d: mpdu %d plcp_len %d\n",\r\nwlc->pub->unit, count, len);\r\nif (count == 0) {\r\nmcl |= (TXC_AMPDU_FIRST << TXC_AMPDU_SHIFT);\r\nmcl |= TXC_STARTMSDU;\r\nrts = (struct ieee80211_rts *)&txh->rts_frame;\r\nif (ieee80211_is_rts(rts->frame_control)) {\r\nmcl |= TXC_SENDRTS;\r\nuse_rts = true;\r\n}\r\nif (ieee80211_is_cts(rts->frame_control)) {\r\nmcl |= TXC_SENDCTS;\r\nuse_cts = true;\r\n}\r\n} else {\r\nmcl |= (TXC_AMPDU_MIDDLE << TXC_AMPDU_SHIFT);\r\nmcl &= ~(TXC_STARTMSDU | TXC_SENDRTS | TXC_SENDCTS);\r\n}\r\nlen = roundup(len, 4);\r\nampdu_len += (len + (ndelim + 1) * AMPDU_DELIMITER_LEN);\r\ndma_len += (u16) p->len;\r\nBCMMSG(wlc->wiphy, "wl%d: ampdu_len %d"\r\n" seg_cnt %d null delim %d\n",\r\nwlc->pub->unit, ampdu_len, seg_cnt, ndelim);\r\ntxh->MacTxControlLow = cpu_to_le16(mcl);\r\npkt[count++] = p;\r\nif (count == 1) {\r\nu8 plcp0, plcp3, is40, sgi;\r\nstruct ieee80211_sta *sta;\r\nsta = tx_info->control.sta;\r\nif (rr) {\r\nplcp0 = plcp[0];\r\nplcp3 = plcp[3];\r\n} else {\r\nplcp0 = txh->FragPLCPFallback[0];\r\nplcp3 = txh->FragPLCPFallback[3];\r\n}\r\nis40 = (plcp0 & MIMO_PLCP_40MHZ) ? 1 : 0;\r\nsgi = plcp3_issgi(plcp3) ? 1 : 0;\r\nmcs = plcp0 & ~MIMO_PLCP_40MHZ;\r\nmax_ampdu_bytes =\r\nmin(scb_ampdu->max_rx_ampdu_bytes,\r\nampdu->max_txlen[mcs][is40][sgi]);\r\nif (is40)\r\nmimo_ctlchbw =\r\nCHSPEC_SB_UPPER(wlc_phy_chanspec_get(\r\nwlc->band->pi))\r\n? PHY_TXC1_BW_20MHZ_UP : PHY_TXC1_BW_20MHZ;\r\nrspec = RSPEC_MIMORATE;\r\nrspec |= plcp[0] & ~MIMO_PLCP_40MHZ;\r\nif (plcp[0] & MIMO_PLCP_40MHZ)\r\nrspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);\r\nif (fbr_iscck)\r\nrspec_fallback = cck_rspec(cck_phy2mac_rate\r\n(txh->FragPLCPFallback[0]));\r\nelse {\r\nrspec_fallback = RSPEC_MIMORATE;\r\nrspec_fallback |=\r\ntxh->FragPLCPFallback[0] & ~MIMO_PLCP_40MHZ;\r\nif (txh->FragPLCPFallback[0] & MIMO_PLCP_40MHZ)\r\nrspec_fallback |=\r\n(PHY_TXC1_BW_40MHZ <<\r\nRSPEC_BW_SHIFT);\r\n}\r\nif (use_rts || use_cts) {\r\nrts_rspec =\r\nbrcms_c_rspec_to_rts_rspec(wlc,\r\nrspec, false, mimo_ctlchbw);\r\nrts_rspec_fallback =\r\nbrcms_c_rspec_to_rts_rspec(wlc,\r\nrspec_fallback, false, mimo_ctlchbw);\r\n}\r\n}\r\nif ((mcs_2_rate(mcs, true, false) >= f->dmaxferrate) &&\r\n(count == f->mcs2ampdu_table[mcs])) {\r\nBCMMSG(wlc->wiphy, "wl%d: PR 37644: stopping"\r\n" ampdu at %d for mcs %d\n",\r\nwlc->pub->unit, count, mcs);\r\nbreak;\r\n}\r\nif (count == scb_ampdu->max_pdu)\r\nbreak;\r\np = pktq_ppeek(&qi->q, prec);\r\ntx_info = IEEE80211_SKB_CB(p);\r\nif (p) {\r\nif ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n((u8) (p->priority) == tid)) {\r\nplen = p->len + AMPDU_MAX_MPDU_OVERHEAD;\r\nplen = max(scb_ampdu->min_len, plen);\r\nif ((plen + ampdu_len) > max_ampdu_bytes) {\r\np = NULL;\r\ncontinue;\r\n}\r\nif (*wlc->core->txavail[fifo] <= seg_cnt + 1) {\r\nwiphy_err(wiphy, "%s: No fifo space "\r\n"!!\n", __func__);\r\np = NULL;\r\ncontinue;\r\n}\r\np = brcmu_pktq_pdeq(&qi->q, prec);\r\n} else {\r\np = NULL;\r\n}\r\n}\r\n}\r\nini->tx_in_transit += count;\r\nif (count) {\r\ntxh = (struct d11txh *) pkt[count - 1]->data;\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nmcl &= ~TXC_AMPDU_MASK;\r\nmcl |= (TXC_AMPDU_LAST << TXC_AMPDU_SHIFT);\r\ntxh->MacTxControlLow = cpu_to_le16(mcl);\r\nndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];\r\ntxh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] = 0;\r\nampdu_len -= ndelim * AMPDU_DELIMITER_LEN;\r\nfbr_iscck = ((le16_to_cpu(txh->XtraFrameTypes) & 0x3) == 0);\r\nlen = fbr_iscck ? BRCMS_GET_CCK_PLCP_LEN(txh->FragPLCPFallback)\r\n: BRCMS_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);\r\nampdu_len -= roundup(len, 4) - len;\r\ntxh = (struct d11txh *) pkt[0]->data;\r\nplcp = (u8 *) (txh + 1);\r\nBRCMS_SET_MIMO_PLCP_LEN(plcp, ampdu_len);\r\nBRCMS_SET_MIMO_PLCP_AMPDU(plcp);\r\nif (txh->MModeLen) {\r\nu16 mmodelen =\r\nbrcms_c_calc_lsig_len(wlc, rspec, ampdu_len);\r\ntxh->MModeLen = cpu_to_le16(mmodelen);\r\npreamble_type = BRCMS_MM_PREAMBLE;\r\n}\r\nif (txh->MModeFbrLen) {\r\nu16 mmfbrlen =\r\nbrcms_c_calc_lsig_len(wlc, rspec_fallback,\r\nampdu_len);\r\ntxh->MModeFbrLen = cpu_to_le16(mmfbrlen);\r\nfbr_preamble_type = BRCMS_MM_PREAMBLE;\r\n}\r\nif (mcs_2_rate(mcs, true, false) >= f->dmaxferrate) {\r\ndma_len = min(dma_len, f->ampdu_pld_size);\r\ntxh->PreloadSize = cpu_to_le16(dma_len);\r\n} else\r\ntxh->PreloadSize = 0;\r\nmch = le16_to_cpu(txh->MacTxControlHigh);\r\nif (use_rts || use_cts) {\r\nu16 durid;\r\nrts = (struct ieee80211_rts *)&txh->rts_frame;\r\nif ((mch & TXC_PREAMBLE_RTS_MAIN_SHORT) ==\r\nTXC_PREAMBLE_RTS_MAIN_SHORT)\r\nrts_preamble_type = BRCMS_SHORT_PREAMBLE;\r\nif ((mch & TXC_PREAMBLE_RTS_FB_SHORT) ==\r\nTXC_PREAMBLE_RTS_FB_SHORT)\r\nrts_fbr_preamble_type = BRCMS_SHORT_PREAMBLE;\r\ndurid =\r\nbrcms_c_compute_rtscts_dur(wlc, use_cts, rts_rspec,\r\nrspec, rts_preamble_type,\r\npreamble_type, ampdu_len,\r\ntrue);\r\nrts->duration = cpu_to_le16(durid);\r\ndurid = brcms_c_compute_rtscts_dur(wlc, use_cts,\r\nrts_rspec_fallback,\r\nrspec_fallback,\r\nrts_fbr_preamble_type,\r\nfbr_preamble_type,\r\nampdu_len, true);\r\ntxh->RTSDurFallback = cpu_to_le16(durid);\r\ntxh->TxFesTimeNormal = rts->duration;\r\ntxh->TxFesTimeFallback = txh->RTSDurFallback;\r\n}\r\nif (fbr) {\r\nmch |= TXC_AMPDU_FBR;\r\ntxh->MacTxControlHigh = cpu_to_le16(mch);\r\nBRCMS_SET_MIMO_PLCP_AMPDU(plcp);\r\nBRCMS_SET_MIMO_PLCP_AMPDU(txh->FragPLCPFallback);\r\n}\r\nBCMMSG(wlc->wiphy, "wl%d: count %d ampdu_len %d\n",\r\nwlc->pub->unit, count, ampdu_len);\r\nframeid = le16_to_cpu(txh->TxFrameID);\r\nif (frameid & TXFID_RATE_PROBE_MASK)\r\nwiphy_err(wiphy, "%s: XXX what to do with "\r\n"TXFID_RATE_PROBE_MASK!?\n", __func__);\r\nfor (i = 0; i < count; i++)\r\nbrcms_c_txfifo(wlc, fifo, pkt[i], i == (count - 1),\r\nampdu->txpkt_weight);\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nbrcms_c_ampdu_rate_status(struct brcms_c_info *wlc,\r\nstruct ieee80211_tx_info *tx_info,\r\nstruct tx_status *txs, u8 mcs)\r\n{\r\nstruct ieee80211_tx_rate *txrate = tx_info->status.rates;\r\nint i;\r\nfor (i = 2; i < IEEE80211_TX_MAX_RATES; i++) {\r\ntxrate[i].idx = -1;\r\ntxrate[i].count = 0;\r\n}\r\n}\r\nstatic void\r\nbrcms_c_ampdu_dotxstatus_complete(struct ampdu_info *ampdu, struct scb *scb,\r\nstruct sk_buff *p, struct tx_status *txs,\r\nu32 s1, u32 s2)\r\n{\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nstruct scb_ampdu_tid_ini *ini;\r\nu8 bitmap[8], queue, tid;\r\nstruct d11txh *txh;\r\nu8 *plcp;\r\nstruct ieee80211_hdr *h;\r\nu16 seq, start_seq = 0, bindex, index, mcl;\r\nu8 mcs = 0;\r\nbool ba_recd = false, ack_recd = false;\r\nu8 suc_mpdu = 0, tot_mpdu = 0;\r\nuint supr_status;\r\nbool update_rate = true, retry = true, tx_error = false;\r\nu16 mimoantsel = 0;\r\nu8 antselid = 0;\r\nu8 retry_limit, rr_retry_limit;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);\r\nstruct wiphy *wiphy = wlc->wiphy;\r\n#ifdef DEBUG\r\nu8 hole[AMPDU_MAX_MPDU];\r\nmemset(hole, 0, sizeof(hole));\r\n#endif\r\nscb_ampdu = &scb->scb_ampdu;\r\ntid = (u8) (p->priority);\r\nini = &scb_ampdu->ini[tid];\r\nretry_limit = ampdu->retry_limit_tid[tid];\r\nrr_retry_limit = ampdu->rr_retry_limit_tid[tid];\r\nmemset(bitmap, 0, sizeof(bitmap));\r\nqueue = txs->frameid & TXFID_QUEUE_MASK;\r\nsupr_status = txs->status & TX_STATUS_SUPR_MASK;\r\nif (txs->status & TX_STATUS_ACK_RCV) {\r\nif (TX_STATUS_SUPR_UF == supr_status)\r\nupdate_rate = false;\r\nWARN_ON(!(txs->status & TX_STATUS_INTERMEDIATE));\r\nstart_seq = txs->sequence >> SEQNUM_SHIFT;\r\nbitmap[0] = (txs->status & TX_STATUS_BA_BMAP03_MASK) >>\r\nTX_STATUS_BA_BMAP03_SHIFT;\r\nWARN_ON(s1 & TX_STATUS_INTERMEDIATE);\r\nWARN_ON(!(s1 & TX_STATUS_AMPDU));\r\nbitmap[0] |=\r\n(s1 & TX_STATUS_BA_BMAP47_MASK) <<\r\nTX_STATUS_BA_BMAP47_SHIFT;\r\nbitmap[1] = (s1 >> 8) & 0xff;\r\nbitmap[2] = (s1 >> 16) & 0xff;\r\nbitmap[3] = (s1 >> 24) & 0xff;\r\nbitmap[4] = s2 & 0xff;\r\nbitmap[5] = (s2 >> 8) & 0xff;\r\nbitmap[6] = (s2 >> 16) & 0xff;\r\nbitmap[7] = (s2 >> 24) & 0xff;\r\nba_recd = true;\r\n} else {\r\nif (supr_status) {\r\nupdate_rate = false;\r\nif (supr_status == TX_STATUS_SUPR_BADCH) {\r\nwiphy_err(wiphy,\r\n"%s: Pkt tx suppressed, illegal channel possibly %d\n",\r\n__func__, CHSPEC_CHANNEL(\r\nwlc->default_bss->chanspec));\r\n} else {\r\nif (supr_status != TX_STATUS_SUPR_FRAG)\r\nwiphy_err(wiphy, "%s: supr_status 0x%x\n",\r\n__func__, supr_status);\r\n}\r\nif (supr_status == TX_STATUS_SUPR_BADCH ||\r\nsupr_status == TX_STATUS_SUPR_EXPTIME) {\r\nretry = false;\r\n} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {\r\n} else if (supr_status == TX_STATUS_SUPR_FRAG) {\r\nif (brcms_c_ffpld_check_txfunfl(wlc,\r\nprio2fifo[tid]) > 0)\r\ntx_error = true;\r\n}\r\n} else if (txs->phyerr) {\r\nupdate_rate = false;\r\nwiphy_err(wiphy, "%s: ampdu tx phy error (0x%x)\n",\r\n__func__, txs->phyerr);\r\nif (brcm_msg_level & LOG_ERROR_VAL) {\r\nbrcmu_prpkt("txpkt (AMPDU)", p);\r\nbrcms_c_print_txdesc((struct d11txh *) p->data);\r\n}\r\nbrcms_c_print_txstatus(txs);\r\n}\r\n}\r\nwhile (p) {\r\ntx_info = IEEE80211_SKB_CB(p);\r\ntxh = (struct d11txh *) p->data;\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nplcp = (u8 *) (txh + 1);\r\nh = (struct ieee80211_hdr *)(plcp + D11_PHY_HDR_LEN);\r\nseq = le16_to_cpu(h->seq_ctrl) >> SEQNUM_SHIFT;\r\nif (tot_mpdu == 0) {\r\nmcs = plcp[0] & MIMO_PLCP_MCS_MASK;\r\nmimoantsel = le16_to_cpu(txh->ABI_MimoAntSel);\r\n}\r\nindex = TX_SEQ_TO_INDEX(seq);\r\nack_recd = false;\r\nif (ba_recd) {\r\nbindex = MODSUB_POW2(seq, start_seq, SEQNUM_MAX);\r\nBCMMSG(wiphy,\r\n"tid %d seq %d, start_seq %d, bindex %d set %d, index %d\n",\r\ntid, seq, start_seq, bindex,\r\nisset(bitmap, bindex), index);\r\nif ((bindex < AMPDU_TX_BA_MAX_WSIZE)\r\n&& isset(bitmap, bindex)) {\r\nini->tx_in_transit--;\r\nini->txretry[index] = 0;\r\nbrcms_c_ampdu_rate_status(wlc, tx_info, txs,\r\nmcs);\r\ntx_info->flags |= IEEE80211_TX_STAT_ACK;\r\ntx_info->flags |= IEEE80211_TX_STAT_AMPDU;\r\ntx_info->status.ampdu_ack_len =\r\ntx_info->status.ampdu_len = 1;\r\nskb_pull(p, D11_PHY_HDR_LEN);\r\nskb_pull(p, D11_TXH_LEN);\r\nieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,\r\np);\r\nack_recd = true;\r\nsuc_mpdu++;\r\n}\r\n}\r\nif (!ack_recd) {\r\nif (retry && (ini->txretry[index] < (int)retry_limit)) {\r\nini->txretry[index]++;\r\nini->tx_in_transit--;\r\nbrcms_c_txq_enq(wlc, scb, p,\r\nBRCMS_PRIO_TO_HI_PREC(tid));\r\n} else {\r\nini->tx_in_transit--;\r\nieee80211_tx_info_clear_status(tx_info);\r\ntx_info->status.ampdu_ack_len = 0;\r\ntx_info->status.ampdu_len = 1;\r\ntx_info->flags |=\r\nIEEE80211_TX_STAT_AMPDU_NO_BACK;\r\nskb_pull(p, D11_PHY_HDR_LEN);\r\nskb_pull(p, D11_TXH_LEN);\r\nBCMMSG(wiphy,\r\n"BA Timeout, seq %d, in_transit %d\n",\r\nseq, ini->tx_in_transit);\r\nieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,\r\np);\r\n}\r\n}\r\ntot_mpdu++;\r\nif (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==\r\nTXC_AMPDU_LAST)\r\nbreak;\r\np = dma_getnexttxp(wlc->hw->di[queue], DMA_RANGE_TRANSMITTED);\r\n}\r\nbrcms_c_send_q(wlc);\r\nantselid = brcms_c_antsel_antsel2id(wlc->asi, mimoantsel);\r\nbrcms_c_txfifo_complete(wlc, queue, ampdu->txpkt_weight);\r\n}\r\nvoid\r\nbrcms_c_ampdu_dotxstatus(struct ampdu_info *ampdu, struct scb *scb,\r\nstruct sk_buff *p, struct tx_status *txs)\r\n{\r\nstruct scb_ampdu *scb_ampdu;\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nstruct scb_ampdu_tid_ini *ini;\r\nu32 s1 = 0, s2 = 0;\r\nstruct ieee80211_tx_info *tx_info;\r\ntx_info = IEEE80211_SKB_CB(p);\r\nif (txs->status & TX_STATUS_ACK_RCV) {\r\nu8 status_delay = 0;\r\ns1 = bcma_read32(wlc->hw->d11core, D11REGOFFS(frmtxstatus));\r\nwhile ((s1 & TXS_V) == 0) {\r\nudelay(1);\r\nstatus_delay++;\r\nif (status_delay > 10)\r\nreturn;\r\ns1 = bcma_read32(wlc->hw->d11core,\r\nD11REGOFFS(frmtxstatus));\r\n}\r\ns2 = bcma_read32(wlc->hw->d11core, D11REGOFFS(frmtxstatus2));\r\n}\r\nif (scb) {\r\nscb_ampdu = &scb->scb_ampdu;\r\nini = &scb_ampdu->ini[p->priority];\r\nbrcms_c_ampdu_dotxstatus_complete(ampdu, scb, p, txs, s1, s2);\r\n} else {\r\nu8 queue = txs->frameid & TXFID_QUEUE_MASK;\r\nstruct d11txh *txh;\r\nu16 mcl;\r\nwhile (p) {\r\ntx_info = IEEE80211_SKB_CB(p);\r\ntxh = (struct d11txh *) p->data;\r\nmcl = le16_to_cpu(txh->MacTxControlLow);\r\nbrcmu_pkt_buf_free_skb(p);\r\nif (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==\r\nTXC_AMPDU_LAST)\r\nbreak;\r\np = dma_getnexttxp(wlc->hw->di[queue],\r\nDMA_RANGE_TRANSMITTED);\r\n}\r\nbrcms_c_txfifo_complete(wlc, queue, ampdu->txpkt_weight);\r\n}\r\n}\r\nvoid brcms_c_ampdu_macaddr_upd(struct brcms_c_info *wlc)\r\n{\r\nchar template[T_RAM_ACCESS_SZ * 2];\r\nmemset(template, 0, sizeof(template));\r\nmemcpy(template, wlc->pub->cur_etheraddr, ETH_ALEN);\r\nbrcms_b_write_template_ram(wlc->hw, (T_BA_TPL_BASE + 16),\r\n(T_RAM_ACCESS_SZ * 2),\r\ntemplate);\r\n}\r\nbool brcms_c_aggregatable(struct brcms_c_info *wlc, u8 tid)\r\n{\r\nreturn wlc->ampdu->ini_enable[tid];\r\n}\r\nvoid brcms_c_ampdu_shm_upd(struct ampdu_info *ampdu)\r\n{\r\nstruct brcms_c_info *wlc = ampdu->wlc;\r\nif ((ampdu->rx_factor & IEEE80211_HT_AMPDU_PARM_FACTOR) ==\r\nIEEE80211_HT_MAX_AMPDU_64K) {\r\nbrcms_b_write_shm(wlc->hw, M_MIMO_MAXSYM, MIMO_MAXSYM_MAX);\r\nbrcms_b_write_shm(wlc->hw, M_WATCHDOG_8TU, WATCHDOG_8TU_MAX);\r\n} else {\r\nbrcms_b_write_shm(wlc->hw, M_MIMO_MAXSYM, MIMO_MAXSYM_DEF);\r\nbrcms_b_write_shm(wlc->hw, M_WATCHDOG_8TU, WATCHDOG_8TU_DEF);\r\n}\r\n}\r\nstatic bool cb_del_ampdu_pkt(struct sk_buff *mpdu, void *arg_a)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(mpdu);\r\nstruct cb_del_ampdu_pars *ampdu_pars =\r\n(struct cb_del_ampdu_pars *)arg_a;\r\nbool rc;\r\nrc = tx_info->flags & IEEE80211_TX_CTL_AMPDU ? true : false;\r\nrc = rc && (tx_info->control.sta == NULL || ampdu_pars->sta == NULL ||\r\ntx_info->control.sta == ampdu_pars->sta);\r\nrc = rc && ((u8)(mpdu->priority) == ampdu_pars->tid);\r\nreturn rc;\r\n}\r\nstatic void dma_cb_fn_ampdu(void *txi, void *arg_a)\r\n{\r\nstruct ieee80211_sta *sta = arg_a;\r\nstruct ieee80211_tx_info *tx_info = (struct ieee80211_tx_info *)txi;\r\nif ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n(tx_info->control.sta == sta || sta == NULL))\r\ntx_info->control.sta = NULL;\r\n}\r\nvoid brcms_c_ampdu_flush(struct brcms_c_info *wlc,\r\nstruct ieee80211_sta *sta, u16 tid)\r\n{\r\nstruct brcms_txq_info *qi = wlc->pkt_queue;\r\nstruct pktq *pq = &qi->q;\r\nint prec;\r\nstruct cb_del_ampdu_pars ampdu_pars;\r\nampdu_pars.sta = sta;\r\nampdu_pars.tid = tid;\r\nfor (prec = 0; prec < pq->num_prec; prec++)\r\nbrcmu_pktq_pflush(pq, prec, true, cb_del_ampdu_pkt,\r\n(void *)&ampdu_pars);\r\nbrcms_c_inval_dma_pkts(wlc->hw, sta, dma_cb_fn_ampdu);\r\n}
