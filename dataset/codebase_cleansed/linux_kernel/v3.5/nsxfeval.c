acpi_status\r\nacpi_evaluate_object_typed(acpi_handle handle,\r\nacpi_string pathname,\r\nstruct acpi_object_list *external_params,\r\nstruct acpi_buffer *return_buffer,\r\nacpi_object_type return_type)\r\n{\r\nacpi_status status;\r\nu8 must_free = FALSE;\r\nACPI_FUNCTION_TRACE(acpi_evaluate_object_typed);\r\nif (!return_buffer) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (return_buffer->length == ACPI_ALLOCATE_BUFFER) {\r\nmust_free = TRUE;\r\n}\r\nstatus =\r\nacpi_evaluate_object(handle, pathname, external_params,\r\nreturn_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (return_type == ACPI_TYPE_ANY) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nif (return_buffer->length == 0) {\r\nACPI_ERROR((AE_INFO, "No return value"));\r\nreturn_ACPI_STATUS(AE_NULL_OBJECT);\r\n}\r\nif (((union acpi_object *)return_buffer->pointer)->type == return_type) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nACPI_ERROR((AE_INFO,\r\n"Incorrect return type [%s] requested [%s]",\r\nacpi_ut_get_type_name(((union acpi_object *)return_buffer->\r\npointer)->type),\r\nacpi_ut_get_type_name(return_type)));\r\nif (must_free) {\r\nACPI_FREE(return_buffer->pointer);\r\nreturn_buffer->pointer = NULL;\r\n}\r\nreturn_buffer->length = 0;\r\nreturn_ACPI_STATUS(AE_TYPE);\r\n}\r\nacpi_status\r\nacpi_evaluate_object(acpi_handle handle,\r\nacpi_string pathname,\r\nstruct acpi_object_list *external_params,\r\nstruct acpi_buffer *return_buffer)\r\n{\r\nacpi_status status;\r\nstruct acpi_evaluate_info *info;\r\nacpi_size buffer_space_needed;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(acpi_evaluate_object);\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo->pathname = pathname;\r\ninfo->prefix_node = acpi_ns_validate_handle(handle);\r\nif (!info->prefix_node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto cleanup;\r\n}\r\nif (external_params && external_params->count) {\r\ninfo->parameters = ACPI_ALLOCATE_ZEROED(((acpi_size)\r\nexternal_params->\r\ncount +\r\n1) * sizeof(void *));\r\nif (!info->parameters) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup;\r\n}\r\nfor (i = 0; i < external_params->count; i++) {\r\nstatus =\r\nacpi_ut_copy_eobject_to_iobject(&external_params->\r\npointer[i],\r\n&info->\r\nparameters[i]);\r\nif (ACPI_FAILURE(status)) {\r\ngoto cleanup;\r\n}\r\n}\r\ninfo->parameters[external_params->count] = NULL;\r\n}\r\nif ((pathname) && (acpi_ns_valid_root_prefix(pathname[0]))) {\r\ninfo->prefix_node = NULL;\r\nstatus = acpi_ns_evaluate(info);\r\n} else if (!handle) {\r\nif (!pathname) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Both Handle and Pathname are NULL"));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Null Handle with relative pathname [%s]",\r\npathname));\r\n}\r\nstatus = AE_BAD_PARAMETER;\r\n} else {\r\nstatus = acpi_ns_evaluate(info);\r\n}\r\nif (return_buffer) {\r\nif (!info->return_object) {\r\nreturn_buffer->length = 0;\r\n} else {\r\nif (ACPI_GET_DESCRIPTOR_TYPE(info->return_object) ==\r\nACPI_DESC_TYPE_NAMED) {\r\nstatus = AE_TYPE;\r\ninfo->return_object = NULL;\r\nreturn_buffer->length = 0;\r\n}\r\nif (ACPI_SUCCESS(status)) {\r\nacpi_ns_resolve_references(info);\r\nstatus =\r\nacpi_ut_get_object_size(info->return_object,\r\n&buffer_space_needed);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus =\r\nacpi_ut_initialize_buffer\r\n(return_buffer,\r\nbuffer_space_needed);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Needed buffer size %X, %s\n",\r\n(u32)\r\nbuffer_space_needed,\r\nacpi_format_exception\r\n(status)));\r\n} else {\r\nstatus =\r\nacpi_ut_copy_iobject_to_eobject\r\n(info->return_object,\r\nreturn_buffer);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (info->return_object) {\r\nacpi_ex_enter_interpreter();\r\nacpi_ut_remove_reference(info->return_object);\r\nacpi_ex_exit_interpreter();\r\n}\r\ncleanup:\r\nif (info->parameters) {\r\nacpi_ut_delete_internal_object_list(info->parameters);\r\n}\r\nACPI_FREE(info);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic void acpi_ns_resolve_references(struct acpi_evaluate_info *info)\r\n{\r\nunion acpi_operand_object *obj_desc = NULL;\r\nstruct acpi_namespace_node *node;\r\nif ((info->return_object)->common.type != ACPI_TYPE_LOCAL_REFERENCE) {\r\nreturn;\r\n}\r\nswitch (info->return_object->reference.class) {\r\ncase ACPI_REFCLASS_INDEX:\r\nobj_desc = *(info->return_object->reference.where);\r\nbreak;\r\ncase ACPI_REFCLASS_REFOF:\r\nnode = info->return_object->reference.object;\r\nif (node) {\r\nobj_desc = node->object;\r\n}\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (obj_desc) {\r\nacpi_ut_add_reference(obj_desc);\r\nacpi_ut_remove_reference(info->return_object);\r\ninfo->return_object = obj_desc;\r\n}\r\nreturn;\r\n}\r\nacpi_status\r\nacpi_walk_namespace(acpi_object_type type,\r\nacpi_handle start_object,\r\nu32 max_depth,\r\nacpi_walk_callback pre_order_visit,\r\nacpi_walk_callback post_order_visit,\r\nvoid *context, void **return_value)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_walk_namespace);\r\nif ((type > ACPI_TYPE_LOCAL_MAX) ||\r\n(!max_depth) || (!pre_order_visit && !post_order_visit)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_read_lock(&acpi_gbl_namespace_rw_lock);\r\nif (ACPI_FAILURE(status)) {\r\nreturn status;\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ns_walk_namespace(type, start_object, max_depth,\r\nACPI_NS_WALK_UNLOCK, pre_order_visit,\r\npost_order_visit, context,\r\nreturn_value);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_read_lock(&acpi_gbl_namespace_rw_lock);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ns_get_device_callback(acpi_handle obj_handle,\r\nu32 nesting_level,\r\nvoid *context, void **return_value)\r\n{\r\nstruct acpi_get_devices_info *info = context;\r\nacpi_status status;\r\nstruct acpi_namespace_node *node;\r\nu32 flags;\r\nstruct acpica_device_id *hid;\r\nstruct acpica_device_id_list *cid;\r\nu32 i;\r\nu8 found;\r\nint no_match;\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (!node) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif (info->hid != NULL) {\r\nstatus = acpi_ut_execute_HID(node, &hid);\r\nif (status == AE_NOT_FOUND) {\r\nreturn (AE_OK);\r\n} else if (ACPI_FAILURE(status)) {\r\nreturn (AE_CTRL_DEPTH);\r\n}\r\nno_match = ACPI_STRCMP(hid->string, info->hid);\r\nACPI_FREE(hid);\r\nif (no_match) {\r\nstatus = acpi_ut_execute_CID(node, &cid);\r\nif (status == AE_NOT_FOUND) {\r\nreturn (AE_OK);\r\n} else if (ACPI_FAILURE(status)) {\r\nreturn (AE_CTRL_DEPTH);\r\n}\r\nfound = 0;\r\nfor (i = 0; i < cid->count; i++) {\r\nif (ACPI_STRCMP(cid->ids[i].string, info->hid)\r\n== 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nACPI_FREE(cid);\r\nif (!found)\r\nreturn (AE_OK);\r\n}\r\n}\r\nstatus = acpi_ut_execute_STA(node, &flags);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (AE_CTRL_DEPTH);\r\n}\r\nif (!(flags & ACPI_STA_DEVICE_PRESENT) &&\r\n!(flags & ACPI_STA_DEVICE_FUNCTIONING)) {\r\nreturn (AE_CTRL_DEPTH);\r\n}\r\nstatus = info->user_function(obj_handle, nesting_level, info->context,\r\nreturn_value);\r\nreturn (status);\r\n}\r\nacpi_status\r\nacpi_get_devices(const char *HID,\r\nacpi_walk_callback user_function,\r\nvoid *context, void **return_value)\r\n{\r\nacpi_status status;\r\nstruct acpi_get_devices_info info;\r\nACPI_FUNCTION_TRACE(acpi_get_devices);\r\nif (!user_function) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\ninfo.hid = HID;\r\ninfo.context = context;\r\ninfo.user_function = user_function;\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ACPI_NS_WALK_UNLOCK,\r\nacpi_ns_get_device_callback, NULL,\r\n&info, return_value);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_attach_data(acpi_handle obj_handle,\r\nacpi_object_handler handler, void *data)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nif (!obj_handle || !handler || !data) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ns_attach_data(node, handler, data);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn (status);\r\n}\r\nacpi_status\r\nacpi_detach_data(acpi_handle obj_handle, acpi_object_handler handler)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nif (!obj_handle || !handler) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ns_detach_data(node, handler);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn (status);\r\n}\r\nacpi_status\r\nacpi_get_data(acpi_handle obj_handle, acpi_object_handler handler, void **data)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nif (!obj_handle || !handler || !data) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus = acpi_ns_get_attached_data(node, handler, data);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn (status);\r\n}
