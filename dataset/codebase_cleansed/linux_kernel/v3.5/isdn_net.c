static __inline__ int isdn_net_device_started(isdn_net_dev *n)\r\n{\r\nisdn_net_local *lp = n->local;\r\nstruct net_device *dev;\r\nif (lp->master)\r\ndev = lp->master;\r\nelse\r\ndev = n->dev;\r\nreturn netif_running(dev);\r\n}\r\nstatic __inline__ void isdn_net_device_wake_queue(isdn_net_local *lp)\r\n{\r\nif (lp->master)\r\nnetif_wake_queue(lp->master);\r\nelse\r\nnetif_wake_queue(lp->netdev->dev);\r\n}\r\nstatic __inline__ void isdn_net_device_stop_queue(isdn_net_local *lp)\r\n{\r\nif (lp->master)\r\nnetif_stop_queue(lp->master);\r\nelse\r\nnetif_stop_queue(lp->netdev->dev);\r\n}\r\nstatic __inline__ int isdn_net_device_busy(isdn_net_local *lp)\r\n{\r\nisdn_net_local *nlp;\r\nisdn_net_dev *nd;\r\nunsigned long flags;\r\nif (!isdn_net_lp_busy(lp))\r\nreturn 0;\r\nif (lp->master)\r\nnd = ISDN_MASTER_PRIV(lp)->netdev;\r\nelse\r\nnd = lp->netdev;\r\nspin_lock_irqsave(&nd->queue_lock, flags);\r\nnlp = lp->next;\r\nwhile (nlp != lp) {\r\nif (!isdn_net_lp_busy(nlp)) {\r\nspin_unlock_irqrestore(&nd->queue_lock, flags);\r\nreturn 0;\r\n}\r\nnlp = nlp->next;\r\n}\r\nspin_unlock_irqrestore(&nd->queue_lock, flags);\r\nreturn 1;\r\n}\r\nstatic __inline__ void isdn_net_inc_frame_cnt(isdn_net_local *lp)\r\n{\r\natomic_inc(&lp->frame_cnt);\r\nif (isdn_net_device_busy(lp))\r\nisdn_net_device_stop_queue(lp);\r\n}\r\nstatic __inline__ void isdn_net_dec_frame_cnt(isdn_net_local *lp)\r\n{\r\natomic_dec(&lp->frame_cnt);\r\nif (!(isdn_net_device_busy(lp))) {\r\nif (!skb_queue_empty(&lp->super_tx_queue)) {\r\nschedule_work(&lp->tqueue);\r\n} else {\r\nisdn_net_device_wake_queue(lp);\r\n}\r\n}\r\n}\r\nstatic __inline__ void isdn_net_zero_frame_cnt(isdn_net_local *lp)\r\n{\r\natomic_set(&lp->frame_cnt, 0);\r\n}\r\nstatic void\r\nisdn_net_unreachable(struct net_device *dev, struct sk_buff *skb, char *reason)\r\n{\r\nif (skb) {\r\nu_short proto = ntohs(skb->protocol);\r\nprintk(KERN_DEBUG "isdn_net: %s: %s, signalling dst_link_failure %s\n",\r\ndev->name,\r\n(reason != NULL) ? reason : "unknown",\r\n(proto != ETH_P_IP) ? "Protocol != ETH_P_IP" : "");\r\ndst_link_failure(skb);\r\n}\r\nelse {\r\nprintk(KERN_DEBUG "isdn_net: %s: %s\n",\r\ndev->name,\r\n(reason != NULL) ? reason : "reason unknown");\r\n}\r\n}\r\nstatic void\r\nisdn_net_reset(struct net_device *dev)\r\n{\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_device_ops *dops =\r\n((isdn_net_local *)netdev_priv(dev))->dops;\r\nstruct concap_proto *cprot =\r\n((isdn_net_local *)netdev_priv(dev))->netdev->cprot;\r\n#endif\r\n#ifdef CONFIG_ISDN_X25\r\nif (cprot && cprot->pops && dops)\r\ncprot->pops->restart(cprot, dev, dops);\r\n#endif\r\n}\r\nstatic int\r\nisdn_net_open(struct net_device *dev)\r\n{\r\nint i;\r\nstruct net_device *p;\r\nstruct in_device *in_dev;\r\nnetif_start_queue(dev);\r\nisdn_net_reset(dev);\r\nfor (i = 0; i < ETH_ALEN - sizeof(u32); i++)\r\ndev->dev_addr[i] = 0xfc;\r\nif ((in_dev = dev->ip_ptr) != NULL) {\r\nstruct in_ifaddr *ifa = in_dev->ifa_list;\r\nif (ifa != NULL)\r\nmemcpy(dev->dev_addr + 2, &ifa->ifa_local, 4);\r\n}\r\np = MASTER_TO_SLAVE(dev);\r\nif (p) {\r\nwhile (p) {\r\nisdn_net_reset(p);\r\np = MASTER_TO_SLAVE(p);\r\n}\r\n}\r\nisdn_lock_drivers();\r\nreturn 0;\r\n}\r\nstatic void\r\nisdn_net_bind_channel(isdn_net_local *lp, int idx)\r\n{\r\nlp->flags |= ISDN_NET_CONNECTED;\r\nlp->isdn_device = dev->drvmap[idx];\r\nlp->isdn_channel = dev->chanmap[idx];\r\ndev->rx_netdev[idx] = lp->netdev;\r\ndev->st_netdev[idx] = lp->netdev;\r\n}\r\nstatic void\r\nisdn_net_unbind_channel(isdn_net_local *lp)\r\n{\r\nskb_queue_purge(&lp->super_tx_queue);\r\nif (!lp->master) {\r\nqdisc_reset_all_tx(lp->netdev->dev);\r\n}\r\nlp->dialstate = 0;\r\ndev->rx_netdev[isdn_dc2minor(lp->isdn_device, lp->isdn_channel)] = NULL;\r\ndev->st_netdev[isdn_dc2minor(lp->isdn_device, lp->isdn_channel)] = NULL;\r\nif (lp->isdn_device != -1 && lp->isdn_channel != -1)\r\nisdn_free_channel(lp->isdn_device, lp->isdn_channel,\r\nISDN_USAGE_NET);\r\nlp->flags &= ~ISDN_NET_CONNECTED;\r\nlp->isdn_device = -1;\r\nlp->isdn_channel = -1;\r\n}\r\nvoid\r\nisdn_net_autohup(void)\r\n{\r\nisdn_net_dev *p = dev->netdev;\r\nint anymore;\r\nanymore = 0;\r\nwhile (p) {\r\nisdn_net_local *l = p->local;\r\nif (jiffies == last_jiffies)\r\nl->cps = l->transcount;\r\nelse\r\nl->cps = (l->transcount * HZ) / (jiffies - last_jiffies);\r\nl->transcount = 0;\r\nif (dev->net_verbose > 3)\r\nprintk(KERN_DEBUG "%s: %d bogocps\n", p->dev->name, l->cps);\r\nif ((l->flags & ISDN_NET_CONNECTED) && (!l->dialstate)) {\r\nanymore = 1;\r\nl->huptimer++;\r\nif ((l->onhtime) &&\r\n(l->huptimer > l->onhtime))\r\n{\r\nif (l->hupflags & ISDN_MANCHARGE &&\r\nl->hupflags & ISDN_CHARGEHUP) {\r\nwhile (time_after(jiffies, l->chargetime + l->chargeint))\r\nl->chargetime += l->chargeint;\r\nif (time_after(jiffies, l->chargetime + l->chargeint - 2 * HZ))\r\nif (l->outgoing || l->hupflags & ISDN_INHUP)\r\nisdn_net_hangup(p->dev);\r\n} else if (l->outgoing) {\r\nif (l->hupflags & ISDN_CHARGEHUP) {\r\nif (l->hupflags & ISDN_WAITCHARGE) {\r\nprintk(KERN_DEBUG "isdn_net: Hupflags of %s are %X\n",\r\np->dev->name, l->hupflags);\r\nisdn_net_hangup(p->dev);\r\n} else if (time_after(jiffies, l->chargetime + l->chargeint)) {\r\nprintk(KERN_DEBUG\r\n"isdn_net: %s: chtime = %lu, chint = %d\n",\r\np->dev->name, l->chargetime, l->chargeint);\r\nisdn_net_hangup(p->dev);\r\n}\r\n} else\r\nisdn_net_hangup(p->dev);\r\n} else if (l->hupflags & ISDN_INHUP)\r\nisdn_net_hangup(p->dev);\r\n}\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED || (ISDN_NET_DIALMODE(*l) == ISDN_NET_DM_OFF)) {\r\nisdn_net_hangup(p->dev);\r\nbreak;\r\n}\r\n}\r\np = (isdn_net_dev *) p->next;\r\n}\r\nlast_jiffies = jiffies;\r\nisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, anymore);\r\n}\r\nstatic void isdn_net_lp_disconnected(isdn_net_local *lp)\r\n{\r\nisdn_net_rm_from_bundle(lp);\r\n}\r\nint\r\nisdn_net_stat_callback(int idx, isdn_ctrl *c)\r\n{\r\nisdn_net_dev *p = dev->st_netdev[idx];\r\nint cmd = c->command;\r\nif (p) {\r\nisdn_net_local *lp = p->local;\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_proto *cprot = lp->netdev->cprot;\r\nstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\r\n#endif\r\nswitch (cmd) {\r\ncase ISDN_STAT_BSENT:\r\nif ((lp->flags & ISDN_NET_CONNECTED) &&\r\n(!lp->dialstate)) {\r\nisdn_net_dec_frame_cnt(lp);\r\nlp->stats.tx_packets++;\r\nlp->stats.tx_bytes += c->parm.length;\r\n}\r\nreturn 1;\r\ncase ISDN_STAT_DCONN:\r\nswitch (lp->dialstate) {\r\ncase 4:\r\ncase 7:\r\ncase 8:\r\nlp->dialstate++;\r\nreturn 1;\r\ncase 12:\r\nlp->dialstate = 5;\r\nreturn 1;\r\n}\r\nbreak;\r\ncase ISDN_STAT_DHUP:\r\n#ifdef CONFIG_ISDN_X25\r\nif (!(lp->flags & ISDN_NET_CONNECTED)\r\n&& pops && pops->disconn_ind)\r\npops->disconn_ind(cprot);\r\n#endif\r\nif ((!lp->dialstate) && (lp->flags & ISDN_NET_CONNECTED)) {\r\nif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\r\nisdn_net_ciscohdlck_disconnected(lp);\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\nisdn_ppp_free(lp);\r\n#endif\r\nisdn_net_lp_disconnected(lp);\r\nisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\r\nprintk(KERN_INFO "%s: remote hangup\n", p->dev->name);\r\nprintk(KERN_INFO "%s: Chargesum is %d\n", p->dev->name,\r\nlp->charge);\r\nisdn_net_unbind_channel(lp);\r\nreturn 1;\r\n}\r\nbreak;\r\n#ifdef CONFIG_ISDN_X25\r\ncase ISDN_STAT_BHUP:\r\nif (pops && pops->disconn_ind) {\r\npops->disconn_ind(cprot);\r\nreturn 1;\r\n}\r\nbreak;\r\n#endif\r\ncase ISDN_STAT_BCONN:\r\nisdn_net_zero_frame_cnt(lp);\r\nswitch (lp->dialstate) {\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ncase 8:\r\ncase 9:\r\ncase 10:\r\ncase 12:\r\nif (lp->dialstate <= 6) {\r\ndev->usage[idx] |= ISDN_USAGE_OUTGOING;\r\nisdn_info_update();\r\n} else\r\ndev->rx_netdev[idx] = p;\r\nlp->dialstate = 0;\r\nisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 1);\r\nif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\r\nisdn_net_ciscohdlck_connected(lp);\r\nif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP) {\r\nif (lp->master) {\r\nisdn_net_dev *nd = ISDN_MASTER_PRIV(lp)->netdev;\r\nisdn_net_add_to_bundle(nd, lp);\r\n}\r\n}\r\nprintk(KERN_INFO "isdn_net: %s connected\n", p->dev->name);\r\nlp->chargetime = jiffies;\r\nlp->dialstarted = 0;\r\nlp->dialwait_timer = 0;\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\nisdn_ppp_wakeup_daemon(lp);\r\n#endif\r\n#ifdef CONFIG_ISDN_X25\r\nif (pops)\r\nif (pops->connect_ind)\r\npops->connect_ind(cprot);\r\n#endif\r\nif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP)\r\nisdn_net_device_wake_queue(lp);\r\nreturn 1;\r\n}\r\nbreak;\r\ncase ISDN_STAT_NODCH:\r\nif (lp->dialstate == 4) {\r\nlp->dialstate--;\r\nreturn 1;\r\n}\r\nbreak;\r\ncase ISDN_STAT_CINF:\r\nlp->charge++;\r\nif (lp->hupflags & ISDN_HAVECHARGE) {\r\nlp->hupflags &= ~ISDN_WAITCHARGE;\r\nlp->chargeint = jiffies - lp->chargetime - (2 * HZ);\r\n}\r\nif (lp->hupflags & ISDN_WAITCHARGE)\r\nlp->hupflags |= ISDN_HAVECHARGE;\r\nlp->chargetime = jiffies;\r\nprintk(KERN_DEBUG "isdn_net: Got CINF chargetime of %s now %lu\n",\r\np->dev->name, lp->chargetime);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nisdn_net_dial(void)\r\n{\r\nisdn_net_dev *p = dev->netdev;\r\nint anymore = 0;\r\nint i;\r\nisdn_ctrl cmd;\r\nu_char *phone_number;\r\nwhile (p) {\r\nisdn_net_local *lp = p->local;\r\n#ifdef ISDN_DEBUG_NET_DIAL\r\nif (lp->dialstate)\r\nprintk(KERN_DEBUG "%s: dialstate=%d\n", p->dev->name, lp->dialstate);\r\n#endif\r\nswitch (lp->dialstate) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nlp->dial = lp->phone[1];\r\nif (!lp->dial) {\r\nprintk(KERN_WARNING "%s: phone number deleted?\n",\r\np->dev->name);\r\nisdn_net_hangup(p->dev);\r\nbreak;\r\n}\r\nanymore = 1;\r\nif (lp->dialtimeout > 0)\r\nif (lp->dialstarted == 0 || time_after(jiffies, lp->dialstarted + lp->dialtimeout + lp->dialwait)) {\r\nlp->dialstarted = jiffies;\r\nlp->dialwait_timer = 0;\r\n}\r\nlp->dialstate++;\r\ncase 2:\r\ncmd.driver = lp->isdn_device;\r\ncmd.arg = lp->isdn_channel;\r\ncmd.command = ISDN_CMD_CLREAZ;\r\nisdn_command(&cmd);\r\nsprintf(cmd.parm.num, "%s", isdn_map_eaz2msn(lp->msn, cmd.driver));\r\ncmd.command = ISDN_CMD_SETEAZ;\r\nisdn_command(&cmd);\r\nlp->dialretry = 0;\r\nanymore = 1;\r\nlp->dialstate++;\r\ncase 3:\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED || (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF)) {\r\nchar *s;\r\nif (dev->global_flags & ISDN_GLOBAL_STOPPED)\r\ns = "dial suppressed: isdn system stopped";\r\nelse\r\ns = "dial suppressed: dialmode `off'";\r\nisdn_net_unreachable(p->dev, NULL, s);\r\nisdn_net_hangup(p->dev);\r\nbreak;\r\n}\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_SETL2;\r\ncmd.arg = lp->isdn_channel + (lp->l2_proto << 8);\r\nisdn_command(&cmd);\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_SETL3;\r\ncmd.arg = lp->isdn_channel + (lp->l3_proto << 8);\r\nisdn_command(&cmd);\r\ncmd.driver = lp->isdn_device;\r\ncmd.arg = lp->isdn_channel;\r\nif (!lp->dial) {\r\nprintk(KERN_WARNING "%s: phone number deleted?\n",\r\np->dev->name);\r\nisdn_net_hangup(p->dev);\r\nbreak;\r\n}\r\nif (!strncmp(lp->dial->num, "LEASED", strlen("LEASED"))) {\r\nlp->dialstate = 4;\r\nprintk(KERN_INFO "%s: Open leased line ...\n", p->dev->name);\r\n} else {\r\nif (lp->dialtimeout > 0)\r\nif (time_after(jiffies, lp->dialstarted + lp->dialtimeout)) {\r\nlp->dialwait_timer = jiffies + lp->dialwait;\r\nlp->dialstarted = 0;\r\nisdn_net_unreachable(p->dev, NULL, "dial: timed out");\r\nisdn_net_hangup(p->dev);\r\nbreak;\r\n}\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_DIAL;\r\ncmd.parm.setup.si2 = 0;\r\nphone_number = lp->dial->num;\r\nif ((*phone_number == 'v') ||\r\n(*phone_number == 'V')) {\r\ncmd.parm.setup.si1 = 1;\r\n} else {\r\ncmd.parm.setup.si1 = 7;\r\n}\r\nstrcpy(cmd.parm.setup.phone, phone_number);\r\nif (!(lp->dial = (isdn_net_phone *) lp->dial->next)) {\r\nlp->dial = lp->phone[1];\r\nlp->dialretry++;\r\nif (lp->dialretry > lp->dialmax) {\r\nif (lp->dialtimeout == 0) {\r\nlp->dialwait_timer = jiffies + lp->dialwait;\r\nlp->dialstarted = 0;\r\nisdn_net_unreachable(p->dev, NULL, "dial: tried all numbers dialmax times");\r\n}\r\nisdn_net_hangup(p->dev);\r\nbreak;\r\n}\r\n}\r\nsprintf(cmd.parm.setup.eazmsn, "%s",\r\nisdn_map_eaz2msn(lp->msn, cmd.driver));\r\ni = isdn_dc2minor(lp->isdn_device, lp->isdn_channel);\r\nif (i >= 0) {\r\nstrcpy(dev->num[i], cmd.parm.setup.phone);\r\ndev->usage[i] |= ISDN_USAGE_OUTGOING;\r\nisdn_info_update();\r\n}\r\nprintk(KERN_INFO "%s: dialing %d %s... %s\n", p->dev->name,\r\nlp->dialretry, cmd.parm.setup.phone,\r\n(cmd.parm.setup.si1 == 1) ? "DOV" : "");\r\nlp->dtimer = 0;\r\n#ifdef ISDN_DEBUG_NET_DIAL\r\nprintk(KERN_DEBUG "dial: d=%d c=%d\n", lp->isdn_device,\r\nlp->isdn_channel);\r\n#endif\r\nisdn_command(&cmd);\r\n}\r\nlp->huptimer = 0;\r\nlp->outgoing = 1;\r\nif (lp->chargeint) {\r\nlp->hupflags |= ISDN_HAVECHARGE;\r\nlp->hupflags &= ~ISDN_WAITCHARGE;\r\n} else {\r\nlp->hupflags |= ISDN_WAITCHARGE;\r\nlp->hupflags &= ~ISDN_HAVECHARGE;\r\n}\r\nanymore = 1;\r\nlp->dialstate =\r\n(lp->cbdelay &&\r\n(lp->flags & ISDN_NET_CBOUT)) ? 12 : 4;\r\nbreak;\r\ncase 4:\r\nif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\r\nlp->dialstate = 3;\r\nanymore = 1;\r\nbreak;\r\ncase 5:\r\ncmd.driver = lp->isdn_device;\r\ncmd.arg = lp->isdn_channel;\r\ncmd.command = ISDN_CMD_ACCEPTB;\r\nanymore = 1;\r\nlp->dtimer = 0;\r\nlp->dialstate++;\r\nisdn_command(&cmd);\r\nbreak;\r\ncase 6:\r\n#ifdef ISDN_DEBUG_NET_DIAL\r\nprintk(KERN_DEBUG "dialtimer2: %d\n", lp->dtimer);\r\n#endif\r\nif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\r\nlp->dialstate = 3;\r\nanymore = 1;\r\nbreak;\r\ncase 7:\r\n#ifdef ISDN_DEBUG_NET_DIAL\r\nprintk(KERN_DEBUG "dialtimer4: %d\n", lp->dtimer);\r\n#endif\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_SETL2;\r\ncmd.arg = lp->isdn_channel + (lp->l2_proto << 8);\r\nisdn_command(&cmd);\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_SETL3;\r\ncmd.arg = lp->isdn_channel + (lp->l3_proto << 8);\r\nisdn_command(&cmd);\r\nif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT15)\r\nisdn_net_hangup(p->dev);\r\nelse {\r\nanymore = 1;\r\nlp->dialstate++;\r\n}\r\nbreak;\r\ncase 9:\r\ncmd.driver = lp->isdn_device;\r\ncmd.arg = lp->isdn_channel;\r\ncmd.command = ISDN_CMD_ACCEPTB;\r\nisdn_command(&cmd);\r\nanymore = 1;\r\nlp->dtimer = 0;\r\nlp->dialstate++;\r\nbreak;\r\ncase 8:\r\ncase 10:\r\n#ifdef ISDN_DEBUG_NET_DIAL\r\nprintk(KERN_DEBUG "dialtimer4: %d\n", lp->dtimer);\r\n#endif\r\nif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\r\nisdn_net_hangup(p->dev);\r\nelse\r\nanymore = 1;\r\nbreak;\r\ncase 11:\r\nif (lp->dtimer++ > lp->cbdelay)\r\nlp->dialstate = 1;\r\nanymore = 1;\r\nbreak;\r\ncase 12:\r\nif (lp->dtimer++ > lp->cbdelay)\r\n{\r\nprintk(KERN_INFO "%s: hangup waiting for callback ...\n", p->dev->name);\r\nlp->dtimer = 0;\r\nlp->dialstate = 4;\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_HANGUP;\r\ncmd.arg = lp->isdn_channel;\r\nisdn_command(&cmd);\r\nisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\r\n}\r\nanymore = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "isdn_net: Illegal dialstate %d for device %s\n",\r\nlp->dialstate, p->dev->name);\r\n}\r\np = (isdn_net_dev *) p->next;\r\n}\r\nisdn_timer_ctrl(ISDN_TIMER_NETDIAL, anymore);\r\n}\r\nvoid\r\nisdn_net_hangup(struct net_device *d)\r\n{\r\nisdn_net_local *lp = netdev_priv(d);\r\nisdn_ctrl cmd;\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_proto *cprot = lp->netdev->cprot;\r\nstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\r\n#endif\r\nif (lp->flags & ISDN_NET_CONNECTED) {\r\nif (lp->slave != NULL) {\r\nisdn_net_local *slp = ISDN_SLAVE_PRIV(lp);\r\nif (slp->flags & ISDN_NET_CONNECTED) {\r\nprintk(KERN_INFO\r\n"isdn_net: hang up slave %s before %s\n",\r\nlp->slave->name, d->name);\r\nisdn_net_hangup(lp->slave);\r\n}\r\n}\r\nprintk(KERN_INFO "isdn_net: local hangup %s\n", d->name);\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\nisdn_ppp_free(lp);\r\n#endif\r\nisdn_net_lp_disconnected(lp);\r\n#ifdef CONFIG_ISDN_X25\r\nif (pops && pops->disconn_ind)\r\npops->disconn_ind(cprot);\r\n#endif\r\ncmd.driver = lp->isdn_device;\r\ncmd.command = ISDN_CMD_HANGUP;\r\ncmd.arg = lp->isdn_channel;\r\nisdn_command(&cmd);\r\nprintk(KERN_INFO "%s: Chargesum is %d\n", d->name, lp->charge);\r\nisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\r\n}\r\nisdn_net_unbind_channel(lp);\r\n}\r\nstatic void\r\nisdn_net_log_skb(struct sk_buff *skb, isdn_net_local *lp)\r\n{\r\nconst u_char *p = skb_network_header(skb);\r\nunsigned short proto = ntohs(skb->protocol);\r\nint data_ofs;\r\nip_ports *ipp;\r\nchar addinfo[100];\r\naddinfo[0] = '\0';\r\nif (p < skb->data || skb->network_header >= skb->tail) {\r\nchar *buf = skb->data;\r\nprintk(KERN_DEBUG "isdn_net: protocol %04x is buggy, dev %s\n", skb->protocol, lp->netdev->dev->name);\r\np = buf;\r\nproto = ETH_P_IP;\r\nswitch (lp->p_encap) {\r\ncase ISDN_NET_ENCAP_IPTYP:\r\nproto = ntohs(*(__be16 *)&buf[0]);\r\np = &buf[2];\r\nbreak;\r\ncase ISDN_NET_ENCAP_ETHER:\r\nproto = ntohs(*(__be16 *)&buf[12]);\r\np = &buf[14];\r\nbreak;\r\ncase ISDN_NET_ENCAP_CISCOHDLC:\r\nproto = ntohs(*(__be16 *)&buf[2]);\r\np = &buf[4];\r\nbreak;\r\n#ifdef CONFIG_ISDN_PPP\r\ncase ISDN_NET_ENCAP_SYNCPPP:\r\nproto = ntohs(skb->protocol);\r\np = &buf[IPPP_MAX_HEADER];\r\nbreak;\r\n#endif\r\n}\r\n}\r\ndata_ofs = ((p[0] & 15) * 4);\r\nswitch (proto) {\r\ncase ETH_P_IP:\r\nswitch (p[9]) {\r\ncase 1:\r\nstrcpy(addinfo, " ICMP");\r\nbreak;\r\ncase 2:\r\nstrcpy(addinfo, " IGMP");\r\nbreak;\r\ncase 4:\r\nstrcpy(addinfo, " IPIP");\r\nbreak;\r\ncase 6:\r\nipp = (ip_ports *) (&p[data_ofs]);\r\nsprintf(addinfo, " TCP, port: %d -> %d", ntohs(ipp->source),\r\nntohs(ipp->dest));\r\nbreak;\r\ncase 8:\r\nstrcpy(addinfo, " EGP");\r\nbreak;\r\ncase 12:\r\nstrcpy(addinfo, " PUP");\r\nbreak;\r\ncase 17:\r\nipp = (ip_ports *) (&p[data_ofs]);\r\nsprintf(addinfo, " UDP, port: %d -> %d", ntohs(ipp->source),\r\nntohs(ipp->dest));\r\nbreak;\r\ncase 22:\r\nstrcpy(addinfo, " IDP");\r\nbreak;\r\n}\r\nprintk(KERN_INFO "OPEN: %pI4 -> %pI4%s\n",\r\np + 12, p + 16, addinfo);\r\nbreak;\r\ncase ETH_P_ARP:\r\nprintk(KERN_INFO "OPEN: ARP %pI4 -> *.*.*.* ?%pI4\n",\r\np + 14, p + 24);\r\nbreak;\r\n}\r\n}\r\nvoid isdn_net_write_super(isdn_net_local *lp, struct sk_buff *skb)\r\n{\r\nif (in_irq()) {\r\nskb_queue_tail(&lp->super_tx_queue, skb);\r\nschedule_work(&lp->tqueue);\r\nreturn;\r\n}\r\nspin_lock_bh(&lp->xmit_lock);\r\nif (!isdn_net_lp_busy(lp)) {\r\nisdn_net_writebuf_skb(lp, skb);\r\n} else {\r\nskb_queue_tail(&lp->super_tx_queue, skb);\r\n}\r\nspin_unlock_bh(&lp->xmit_lock);\r\n}\r\nstatic void isdn_net_softint(struct work_struct *work)\r\n{\r\nisdn_net_local *lp = container_of(work, isdn_net_local, tqueue);\r\nstruct sk_buff *skb;\r\nspin_lock_bh(&lp->xmit_lock);\r\nwhile (!isdn_net_lp_busy(lp)) {\r\nskb = skb_dequeue(&lp->super_tx_queue);\r\nif (!skb)\r\nbreak;\r\nisdn_net_writebuf_skb(lp, skb);\r\n}\r\nspin_unlock_bh(&lp->xmit_lock);\r\n}\r\nvoid isdn_net_writebuf_skb(isdn_net_local *lp, struct sk_buff *skb)\r\n{\r\nint ret;\r\nint len = skb->len;\r\nif (isdn_net_lp_busy(lp)) {\r\nprintk("isdn BUG at %s:%d!\n", __FILE__, __LINE__);\r\ngoto error;\r\n}\r\nif (!(lp->flags & ISDN_NET_CONNECTED)) {\r\nprintk("isdn BUG at %s:%d!\n", __FILE__, __LINE__);\r\ngoto error;\r\n}\r\nret = isdn_writebuf_skb_stub(lp->isdn_device, lp->isdn_channel, 1, skb);\r\nif (ret != len) {\r\nprintk(KERN_WARNING "%s: HL driver queue full\n", lp->netdev->dev->name);\r\ngoto error;\r\n}\r\nlp->transcount += len;\r\nisdn_net_inc_frame_cnt(lp);\r\nreturn;\r\nerror:\r\ndev_kfree_skb(skb);\r\nlp->stats.tx_errors++;\r\n}\r\nstatic int\r\nisdn_net_xmit(struct net_device *ndev, struct sk_buff *skb)\r\n{\r\nisdn_net_dev *nd;\r\nisdn_net_local *slp;\r\nisdn_net_local *lp = netdev_priv(ndev);\r\nint retv = NETDEV_TX_OK;\r\nif (((isdn_net_local *) netdev_priv(ndev))->master) {\r\nprintk("isdn BUG at %s:%d!\n", __FILE__, __LINE__);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\r\nreturn isdn_ppp_xmit(skb, ndev);\r\n}\r\n#endif\r\nnd = ((isdn_net_local *) netdev_priv(ndev))->netdev;\r\nlp = isdn_net_get_locked_lp(nd);\r\nif (!lp) {\r\nprintk(KERN_WARNING "%s: all channels busy - requeuing!\n", ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nlp->huptimer = 0;\r\nisdn_net_writebuf_skb(lp, skb);\r\nspin_unlock_bh(&lp->xmit_lock);\r\nif (lp->cps > lp->triggercps) {\r\nif (lp->slave) {\r\nif (!lp->sqfull) {\r\nlp->sqfull = 1;\r\nlp->sqfull_stamp = jiffies;\r\n} else {\r\nif (time_after(jiffies, lp->sqfull_stamp + lp->slavedelay)) {\r\nslp = ISDN_SLAVE_PRIV(lp);\r\nif (!(slp->flags & ISDN_NET_CONNECTED)) {\r\nisdn_net_force_dial_lp(ISDN_SLAVE_PRIV(lp));\r\n}\r\n}\r\n}\r\n}\r\n} else {\r\nif (lp->sqfull && time_after(jiffies, lp->sqfull_stamp + lp->slavedelay + (10 * HZ))) {\r\nlp->sqfull = 0;\r\n}\r\nnd->queue = nd->local;\r\n}\r\nreturn retv;\r\n}\r\nstatic void\r\nisdn_net_adjust_hdr(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nif (!skb)\r\nreturn;\r\nif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\r\nconst int pullsize = skb_network_offset(skb) - ETH_HLEN;\r\nif (pullsize > 0) {\r\nprintk(KERN_DEBUG "isdn_net: Pull junk %d\n", pullsize);\r\nskb_pull(skb, pullsize);\r\n}\r\n}\r\n}\r\nstatic void isdn_net_tx_timeout(struct net_device *ndev)\r\n{\r\nisdn_net_local *lp = netdev_priv(ndev);\r\nprintk(KERN_WARNING "isdn_tx_timeout dev %s dialstate %d\n", ndev->name, lp->dialstate);\r\nif (!lp->dialstate) {\r\nlp->stats.tx_errors++;\r\n}\r\nndev->trans_start = jiffies;\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic netdev_tx_t\r\nisdn_net_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nisdn_net_local *lp = netdev_priv(ndev);\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_proto *cprot = lp->netdev->cprot;\r\nif (cprot && cprot->pops) {\r\nint ret = cprot->pops->encap_and_xmit(cprot, skb);\r\nif (ret)\r\nnetif_stop_queue(ndev);\r\nreturn ret;\r\n} else\r\n#endif\r\n{\r\n#ifdef ISDN_DEBUG_NET_DUMP\r\nu_char *buf;\r\n#endif\r\nisdn_net_adjust_hdr(skb, ndev);\r\n#ifdef ISDN_DEBUG_NET_DUMP\r\nbuf = skb->data;\r\nisdn_dumppkt("S:", buf, skb->len, 40);\r\n#endif\r\nif (!(lp->flags & ISDN_NET_CONNECTED)) {\r\nint chi;\r\nif (!(ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_AUTO)) {\r\nisdn_net_unreachable(ndev, skb, "dial rejected: interface not in dialmode `auto'");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (lp->phone[1]) {\r\nulong flags;\r\nif (lp->dialwait_timer <= 0)\r\nif (lp->dialstarted > 0 && lp->dialtimeout > 0 && time_before(jiffies, lp->dialstarted + lp->dialtimeout + lp->dialwait))\r\nlp->dialwait_timer = lp->dialstarted + lp->dialtimeout + lp->dialwait;\r\nif (lp->dialwait_timer > 0) {\r\nif (time_before(jiffies, lp->dialwait_timer)) {\r\nisdn_net_unreachable(ndev, skb, "dial rejected: retry-time not reached");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else\r\nlp->dialwait_timer = 0;\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (((chi =\r\nisdn_get_free_channel(\r\nISDN_USAGE_NET,\r\nlp->l2_proto,\r\nlp->l3_proto,\r\nlp->pre_device,\r\nlp->pre_channel,\r\nlp->msn)\r\n) < 0) &&\r\n((chi =\r\nisdn_get_free_channel(\r\nISDN_USAGE_NET,\r\nlp->l2_proto,\r\nlp->l3_proto,\r\nlp->pre_device,\r\nlp->pre_channel^1,\r\nlp->msn)\r\n) < 0)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_unreachable(ndev, skb,\r\n"No channel");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (dev->net_verbose)\r\nisdn_net_log_skb(skb, lp);\r\nlp->dialstate = 1;\r\nisdn_net_bind_channel(lp, chi);\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\r\nif (isdn_ppp_bind(lp) < 0) {\r\ndev_kfree_skb(skb);\r\nisdn_net_unbind_channel(lp);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\n#ifdef CONFIG_IPPP_FILTER\r\nif (isdn_ppp_autodial_filter(skb, lp)) {\r\nisdn_ppp_free(lp);\r\nisdn_net_unbind_channel(lp);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_unreachable(ndev, skb, "dial rejected: packet filtered");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_dial();\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_dial();\r\nisdn_net_device_stop_queue(lp);\r\nreturn NETDEV_TX_BUSY;\r\n} else {\r\nisdn_net_unreachable(ndev, skb,\r\n"No phone number");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n} else {\r\nndev->trans_start = jiffies;\r\nif (!lp->dialstate) {\r\nint ret;\r\nret = (isdn_net_xmit(ndev, skb));\r\nif (ret) netif_stop_queue(ndev);\r\nreturn ret;\r\n} else\r\nnetif_stop_queue(ndev);\r\n}\r\n}\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic int\r\nisdn_net_close(struct net_device *dev)\r\n{\r\nstruct net_device *p;\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_proto *cprot =\r\n((isdn_net_local *)netdev_priv(dev))->netdev->cprot;\r\n#endif\r\n#ifdef CONFIG_ISDN_X25\r\nif (cprot && cprot->pops) cprot->pops->close(cprot);\r\n#endif\r\nnetif_stop_queue(dev);\r\np = MASTER_TO_SLAVE(dev);\r\nif (p) {\r\nwhile (p) {\r\n#ifdef CONFIG_ISDN_X25\r\ncprot = ((isdn_net_local *)netdev_priv(p))\r\n->netdev->cprot;\r\nif (cprot && cprot->pops)\r\ncprot->pops->close(cprot);\r\n#endif\r\nisdn_net_hangup(p);\r\np = MASTER_TO_SLAVE(p);\r\n}\r\n}\r\nisdn_net_hangup(dev);\r\nisdn_unlock_drivers();\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *\r\nisdn_net_get_stats(struct net_device *dev)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nreturn &lp->stats;\r\n}\r\nstatic __be16\r\nisdn_net_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ethhdr *eth;\r\nunsigned char *rawp;\r\nskb_reset_mac_header(skb);\r\nskb_pull(skb, ETH_HLEN);\r\neth = eth_hdr(skb);\r\nif (*eth->h_dest & 1) {\r\nif (memcmp(eth->h_dest, dev->broadcast, ETH_ALEN) == 0)\r\nskb->pkt_type = PACKET_BROADCAST;\r\nelse\r\nskb->pkt_type = PACKET_MULTICAST;\r\n}\r\nelse if (dev->flags & (IFF_PROMISC )) {\r\nif (memcmp(eth->h_dest, dev->dev_addr, ETH_ALEN))\r\nskb->pkt_type = PACKET_OTHERHOST;\r\n}\r\nif (ntohs(eth->h_proto) >= 1536)\r\nreturn eth->h_proto;\r\nrawp = skb->data;\r\nif (*(unsigned short *) rawp == 0xFFFF)\r\nreturn htons(ETH_P_802_3);\r\nreturn htons(ETH_P_802_2);\r\n}\r\nstatic struct sk_buff*\r\nisdn_net_ciscohdlck_alloc_skb(isdn_net_local *lp, int len)\r\n{\r\nunsigned short hl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(hl + len, GFP_ATOMIC);\r\nif (skb)\r\nskb_reserve(skb, hl);\r\nelse\r\nprintk("isdn out of mem at %s:%d!\n", __FILE__, __LINE__);\r\nreturn skb;\r\n}\r\nstatic int\r\nisdn_ciscohdlck_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nunsigned long len = 0;\r\nunsigned long expires = 0;\r\nint tmp = 0;\r\nint period = lp->cisco_keepalive_period;\r\ns8 debserint = lp->cisco_debserint;\r\nint rc = 0;\r\nif (lp->p_encap != ISDN_NET_ENCAP_CISCOHDLCK)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCGKEEPPERIOD:\r\nlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\r\nif (copy_to_user(ifr->ifr_data,\r\n&lp->cisco_keepalive_period, len))\r\nrc = -EFAULT;\r\nbreak;\r\ncase SIOCSKEEPPERIOD:\r\ntmp = lp->cisco_keepalive_period;\r\nlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\r\nif (copy_from_user(&period, ifr->ifr_data, len))\r\nrc = -EFAULT;\r\nif ((period > 0) && (period <= 32767))\r\nlp->cisco_keepalive_period = period;\r\nelse\r\nrc = -EINVAL;\r\nif (!rc && (tmp != lp->cisco_keepalive_period)) {\r\nexpires = (unsigned long)(jiffies +\r\nlp->cisco_keepalive_period * HZ);\r\nmod_timer(&lp->cisco_timer, expires);\r\nprintk(KERN_INFO "%s: Keepalive period set "\r\n"to %d seconds.\n",\r\ndev->name, lp->cisco_keepalive_period);\r\n}\r\nbreak;\r\ncase SIOCGDEBSERINT:\r\nlen = (unsigned long)sizeof(lp->cisco_debserint);\r\nif (copy_to_user(ifr->ifr_data,\r\n&lp->cisco_debserint, len))\r\nrc = -EFAULT;\r\nbreak;\r\ncase SIOCSDEBSERINT:\r\nlen = (unsigned long)sizeof(lp->cisco_debserint);\r\nif (copy_from_user(&debserint,\r\nifr->ifr_data, len))\r\nrc = -EFAULT;\r\nif ((debserint >= 0) && (debserint <= 64))\r\nlp->cisco_debserint = debserint;\r\nelse\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn (rc);\r\n}\r\nstatic int isdn_net_ioctl(struct net_device *dev,\r\nstruct ifreq *ifr, int cmd)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nswitch (lp->p_encap) {\r\n#ifdef CONFIG_ISDN_PPP\r\ncase ISDN_NET_ENCAP_SYNCPPP:\r\nreturn isdn_ppp_dev_ioctl(dev, ifr, cmd);\r\n#endif\r\ncase ISDN_NET_ENCAP_CISCOHDLCK:\r\nreturn isdn_ciscohdlck_dev_ioctl(dev, ifr, cmd);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_slarp_send_keepalive(unsigned long data)\r\n{\r\nisdn_net_local *lp = (isdn_net_local *) data;\r\nstruct sk_buff *skb;\r\nunsigned char *p;\r\nunsigned long last_cisco_myseq = lp->cisco_myseq;\r\nint myseq_diff = 0;\r\nif (!(lp->flags & ISDN_NET_CONNECTED) || lp->dialstate) {\r\nprintk("isdn BUG at %s:%d!\n", __FILE__, __LINE__);\r\nreturn;\r\n}\r\nlp->cisco_myseq++;\r\nmyseq_diff = (lp->cisco_myseq - lp->cisco_mineseen);\r\nif ((lp->cisco_line_state) && ((myseq_diff >= 3) || (myseq_diff <= -3))) {\r\nlp->cisco_line_state = 0;\r\nprintk(KERN_WARNING\r\n"UPDOWN: Line protocol on Interface %s,"\r\n" changed state to down\n", lp->netdev->dev->name);\r\n} else if ((!lp->cisco_line_state) &&\r\n(myseq_diff >= 0) && (myseq_diff <= 2)) {\r\nlp->cisco_line_state = 1;\r\nprintk(KERN_WARNING\r\n"UPDOWN: Line protocol on Interface %s,"\r\n" changed state to up\n", lp->netdev->dev->name);\r\n}\r\nif (lp->cisco_debserint)\r\nprintk(KERN_DEBUG "%s: HDLC "\r\n"myseq %lu, mineseen %lu%c, yourseen %lu, %s\n",\r\nlp->netdev->dev->name, last_cisco_myseq, lp->cisco_mineseen,\r\n((last_cisco_myseq == lp->cisco_mineseen) ? '*' : 040),\r\nlp->cisco_yourseq,\r\n((lp->cisco_line_state) ? "line up" : "line down"));\r\nskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\r\nif (!skb)\r\nreturn;\r\np = skb_put(skb, 4 + 14);\r\n*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\r\n*(u8 *)(p + 1) = CISCO_CTRL;\r\n*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\r\n*(__be32 *)(p + 4) = cpu_to_be32(CISCO_SLARP_KEEPALIVE);\r\n*(__be32 *)(p + 8) = cpu_to_be32(lp->cisco_myseq);\r\n*(__be32 *)(p + 12) = cpu_to_be32(lp->cisco_yourseq);\r\n*(__be16 *)(p + 16) = cpu_to_be16(0xffff);\r\np += 18;\r\nisdn_net_write_super(lp, skb);\r\nlp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;\r\nadd_timer(&lp->cisco_timer);\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *p;\r\nskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\r\nif (!skb)\r\nreturn;\r\np = skb_put(skb, 4 + 14);\r\n*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\r\n*(u8 *)(p + 1) = CISCO_CTRL;\r\n*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\r\n*(__be32 *)(p + 4) = cpu_to_be32(CISCO_SLARP_REQUEST);\r\n*(__be32 *)(p + 8) = cpu_to_be32(0);\r\n*(__be32 *)(p + 12) = cpu_to_be32(0);\r\n*(__be16 *)(p + 16) = cpu_to_be16(0);\r\np += 18;\r\nisdn_net_write_super(lp, skb);\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_connected(isdn_net_local *lp)\r\n{\r\nlp->cisco_myseq = 0;\r\nlp->cisco_mineseen = 0;\r\nlp->cisco_yourseq = 0;\r\nlp->cisco_keepalive_period = ISDN_TIMER_KEEPINT;\r\nlp->cisco_last_slarp_in = 0;\r\nlp->cisco_line_state = 0;\r\nlp->cisco_debserint = 0;\r\nisdn_net_ciscohdlck_slarp_send_request(lp);\r\ninit_timer(&lp->cisco_timer);\r\nlp->cisco_timer.data = (unsigned long) lp;\r\nlp->cisco_timer.function = isdn_net_ciscohdlck_slarp_send_keepalive;\r\nlp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;\r\nadd_timer(&lp->cisco_timer);\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_disconnected(isdn_net_local *lp)\r\n{\r\ndel_timer(&lp->cisco_timer);\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_slarp_send_reply(isdn_net_local *lp)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *p;\r\nstruct in_device *in_dev = NULL;\r\n__be32 addr = 0;\r\n__be32 mask = 0;\r\nif ((in_dev = lp->netdev->dev->ip_ptr) != NULL) {\r\nstruct in_ifaddr *ifa = in_dev->ifa_list;\r\nif (ifa != NULL) {\r\naddr = ifa->ifa_local;\r\nmask = ifa->ifa_mask;\r\n}\r\n}\r\nskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\r\nif (!skb)\r\nreturn;\r\np = skb_put(skb, 4 + 14);\r\n*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\r\n*(u8 *)(p + 1) = CISCO_CTRL;\r\n*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\r\n*(__be32 *)(p + 4) = cpu_to_be32(CISCO_SLARP_REPLY);\r\n*(__be32 *)(p + 8) = addr;\r\n*(__be32 *)(p + 12) = mask;\r\n*(__be16 *)(p + 16) = cpu_to_be16(0);\r\np += 18;\r\nisdn_net_write_super(lp, skb);\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_slarp_in(isdn_net_local *lp, struct sk_buff *skb)\r\n{\r\nunsigned char *p;\r\nint period;\r\nu32 code;\r\nu32 my_seq;\r\nu32 your_seq;\r\n__be32 local;\r\n__be32 *addr, *mask;\r\nif (skb->len < 14)\r\nreturn;\r\np = skb->data;\r\ncode = be32_to_cpup((__be32 *)p);\r\np += 4;\r\nswitch (code) {\r\ncase CISCO_SLARP_REQUEST:\r\nlp->cisco_yourseq = 0;\r\nisdn_net_ciscohdlck_slarp_send_reply(lp);\r\nbreak;\r\ncase CISCO_SLARP_REPLY:\r\naddr = (__be32 *)p;\r\nmask = (__be32 *)(p + 4);\r\nif (*mask != cpu_to_be32(0xfffffffc))\r\ngoto slarp_reply_out;\r\nif ((*addr & cpu_to_be32(3)) == cpu_to_be32(0) ||\r\n(*addr & cpu_to_be32(3)) == cpu_to_be32(3))\r\ngoto slarp_reply_out;\r\nlocal = *addr ^ cpu_to_be32(3);\r\nprintk(KERN_INFO "%s: got slarp reply: remote ip: %pI4, local ip: %pI4 mask: %pI4\n",\r\nlp->netdev->dev->name, addr, &local, mask);\r\nbreak;\r\nslarp_reply_out:\r\nprintk(KERN_INFO "%s: got invalid slarp reply (%pI4/%pI4) - ignored\n",\r\nlp->netdev->dev->name, addr, mask);\r\nbreak;\r\ncase CISCO_SLARP_KEEPALIVE:\r\nperiod = (int)((jiffies - lp->cisco_last_slarp_in\r\n+ HZ / 2 - 1) / HZ);\r\nif (lp->cisco_debserint &&\r\n(period != lp->cisco_keepalive_period) &&\r\nlp->cisco_last_slarp_in) {\r\nprintk(KERN_DEBUG "%s: Keepalive period mismatch - "\r\n"is %d but should be %d.\n",\r\nlp->netdev->dev->name, period,\r\nlp->cisco_keepalive_period);\r\n}\r\nlp->cisco_last_slarp_in = jiffies;\r\nmy_seq = be32_to_cpup((__be32 *)(p + 0));\r\nyour_seq = be32_to_cpup((__be32 *)(p + 4));\r\np += 10;\r\nlp->cisco_yourseq = my_seq;\r\nlp->cisco_mineseen = your_seq;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisdn_net_ciscohdlck_receive(isdn_net_local *lp, struct sk_buff *skb)\r\n{\r\nunsigned char *p;\r\nu8 addr;\r\nu8 ctrl;\r\nu16 type;\r\nif (skb->len < 4)\r\ngoto out_free;\r\np = skb->data;\r\naddr = *(u8 *)(p + 0);\r\nctrl = *(u8 *)(p + 1);\r\ntype = be16_to_cpup((__be16 *)(p + 2));\r\np += 4;\r\nskb_pull(skb, 4);\r\nif (addr != CISCO_ADDR_UNICAST && addr != CISCO_ADDR_BROADCAST) {\r\nprintk(KERN_WARNING "%s: Unknown Cisco addr 0x%02x\n",\r\nlp->netdev->dev->name, addr);\r\ngoto out_free;\r\n}\r\nif (ctrl != CISCO_CTRL) {\r\nprintk(KERN_WARNING "%s: Unknown Cisco ctrl 0x%02x\n",\r\nlp->netdev->dev->name, ctrl);\r\ngoto out_free;\r\n}\r\nswitch (type) {\r\ncase CISCO_TYPE_SLARP:\r\nisdn_net_ciscohdlck_slarp_in(lp, skb);\r\ngoto out_free;\r\ncase CISCO_TYPE_CDP:\r\nif (lp->cisco_debserint)\r\nprintk(KERN_DEBUG "%s: Received CDP packet. use "\r\n"\"no cdp enable\" on cisco.\n",\r\nlp->netdev->dev->name);\r\ngoto out_free;\r\ndefault:\r\nskb->protocol = htons(type);\r\nnetif_rx(skb);\r\nreturn;\r\n}\r\nout_free:\r\nkfree_skb(skb);\r\n}\r\nstatic void\r\nisdn_net_receive(struct net_device *ndev, struct sk_buff *skb)\r\n{\r\nisdn_net_local *lp = netdev_priv(ndev);\r\nisdn_net_local *olp = lp;\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_proto *cprot = lp->netdev->cprot;\r\n#endif\r\nlp->transcount += skb->len;\r\nlp->stats.rx_packets++;\r\nlp->stats.rx_bytes += skb->len;\r\nif (lp->master) {\r\nndev = lp->master;\r\nlp = netdev_priv(ndev);\r\nlp->stats.rx_packets++;\r\nlp->stats.rx_bytes += skb->len;\r\n}\r\nskb->dev = ndev;\r\nskb->pkt_type = PACKET_HOST;\r\nskb_reset_mac_header(skb);\r\n#ifdef ISDN_DEBUG_NET_DUMP\r\nisdn_dumppkt("R:", skb->data, skb->len, 40);\r\n#endif\r\nswitch (lp->p_encap) {\r\ncase ISDN_NET_ENCAP_ETHER:\r\nolp->huptimer = 0;\r\nlp->huptimer = 0;\r\nskb->protocol = isdn_net_type_trans(skb, ndev);\r\nbreak;\r\ncase ISDN_NET_ENCAP_UIHDLC:\r\nolp->huptimer = 0;\r\nlp->huptimer = 0;\r\nskb_pull(skb, 2);\r\ncase ISDN_NET_ENCAP_RAWIP:\r\nolp->huptimer = 0;\r\nlp->huptimer = 0;\r\nskb->protocol = htons(ETH_P_IP);\r\nbreak;\r\ncase ISDN_NET_ENCAP_CISCOHDLCK:\r\nisdn_net_ciscohdlck_receive(lp, skb);\r\nreturn;\r\ncase ISDN_NET_ENCAP_CISCOHDLC:\r\nskb_pull(skb, 2);\r\ncase ISDN_NET_ENCAP_IPTYP:\r\nolp->huptimer = 0;\r\nlp->huptimer = 0;\r\nskb->protocol = *(__be16 *)&(skb->data[0]);\r\nskb_pull(skb, 2);\r\nif (*(unsigned short *) skb->data == 0xFFFF)\r\nskb->protocol = htons(ETH_P_802_3);\r\nbreak;\r\n#ifdef CONFIG_ISDN_PPP\r\ncase ISDN_NET_ENCAP_SYNCPPP:\r\nisdn_ppp_receive(lp->netdev, olp, skb);\r\nreturn;\r\n#endif\r\ndefault:\r\n#ifdef CONFIG_ISDN_X25\r\nif (cprot) if (cprot->pops)\r\nif (cprot->pops->data_ind) {\r\ncprot->pops->data_ind(cprot, skb);\r\nreturn;\r\n};\r\n#endif\r\nprintk(KERN_WARNING "%s: unknown encapsulation, dropping\n",\r\nlp->netdev->dev->name);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nnetif_rx(skb);\r\nreturn;\r\n}\r\nint\r\nisdn_net_rcv_skb(int idx, struct sk_buff *skb)\r\n{\r\nisdn_net_dev *p = dev->rx_netdev[idx];\r\nif (p) {\r\nisdn_net_local *lp = p->local;\r\nif ((lp->flags & ISDN_NET_CONNECTED) &&\r\n(!lp->dialstate)) {\r\nisdn_net_receive(p->dev, skb);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int isdn_net_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned plen)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nunsigned char *p;\r\nint len = 0;\r\nswitch (lp->p_encap) {\r\ncase ISDN_NET_ENCAP_ETHER:\r\nlen = eth_header(skb, dev, type, daddr, saddr, plen);\r\nbreak;\r\n#ifdef CONFIG_ISDN_PPP\r\ncase ISDN_NET_ENCAP_SYNCPPP:\r\nlen = IPPP_MAX_HEADER;\r\nskb_push(skb, len);\r\nbreak;\r\n#endif\r\ncase ISDN_NET_ENCAP_RAWIP:\r\nprintk(KERN_WARNING "isdn_net_header called with RAW_IP!\n");\r\nlen = 0;\r\nbreak;\r\ncase ISDN_NET_ENCAP_IPTYP:\r\n*((__be16 *)skb_push(skb, 2)) = htons(type);\r\nlen = 2;\r\nbreak;\r\ncase ISDN_NET_ENCAP_UIHDLC:\r\n*((__be16 *)skb_push(skb, 2)) = htons(0x0103);\r\nlen = 2;\r\nbreak;\r\ncase ISDN_NET_ENCAP_CISCOHDLC:\r\ncase ISDN_NET_ENCAP_CISCOHDLCK:\r\np = skb_push(skb, 4);\r\n*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\r\n*(u8 *)(p + 1) = CISCO_CTRL;\r\n*(__be16 *)(p + 2) = cpu_to_be16(type);\r\np += 4;\r\nlen = 4;\r\nbreak;\r\n#ifdef CONFIG_ISDN_X25\r\ndefault:\r\nif (lp->netdev->cprot) {\r\nprintk(KERN_WARNING "isdn_net_header called with concap_proto!\n");\r\nlen = 0;\r\nbreak;\r\n}\r\nbreak;\r\n#endif\r\n}\r\nreturn len;\r\n}\r\nstatic int\r\nisdn_net_rebuild_header(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nisdn_net_local *lp = netdev_priv(dev);\r\nint ret = 0;\r\nif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\r\nstruct ethhdr *eth = (struct ethhdr *) skb->data;\r\nif (eth->h_proto != htons(ETH_P_IP)) {\r\nprintk(KERN_WARNING\r\n"isdn_net: %s don't know how to resolve type %d addresses?\n",\r\ndev->name, (int) eth->h_proto);\r\nmemcpy(eth->h_source, dev->dev_addr, dev->addr_len);\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_INET\r\nret = arp_find(eth->h_dest, skb);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int isdn_header_cache(const struct neighbour *neigh, struct hh_cache *hh,\r\n__be16 type)\r\n{\r\nconst struct net_device *dev = neigh->dev;\r\nisdn_net_local *lp = netdev_priv(dev);\r\nif (lp->p_encap == ISDN_NET_ENCAP_ETHER)\r\nreturn eth_header_cache(neigh, hh, type);\r\nreturn -1;\r\n}\r\nstatic void isdn_header_cache_update(struct hh_cache *hh,\r\nconst struct net_device *dev,\r\nconst unsigned char *haddr)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nif (lp->p_encap == ISDN_NET_ENCAP_ETHER)\r\neth_header_cache_update(hh, dev, haddr);\r\n}\r\nstatic int\r\nisdn_net_init(struct net_device *ndev)\r\n{\r\nushort max_hlhdr_len = 0;\r\nint drvidx;\r\nfor (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++)\r\nif (dev->drv[drvidx])\r\nif (max_hlhdr_len < dev->drv[drvidx]->interface->hl_hdrlen)\r\nmax_hlhdr_len = dev->drv[drvidx]->interface->hl_hdrlen;\r\nndev->hard_header_len = ETH_HLEN + max_hlhdr_len;\r\nreturn 0;\r\n}\r\nstatic void\r\nisdn_net_swapbind(int drvidx)\r\n{\r\nisdn_net_dev *p;\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: swapping ch of %d\n", drvidx);\r\n#endif\r\np = dev->netdev;\r\nwhile (p) {\r\nif (p->local->pre_device == drvidx)\r\nswitch (p->local->pre_channel) {\r\ncase 0:\r\np->local->pre_channel = 1;\r\nbreak;\r\ncase 1:\r\np->local->pre_channel = 0;\r\nbreak;\r\n}\r\np = (isdn_net_dev *) p->next;\r\n}\r\n}\r\nstatic void\r\nisdn_net_swap_usage(int i1, int i2)\r\n{\r\nint u1 = dev->usage[i1] & ISDN_USAGE_EXCLUSIVE;\r\nint u2 = dev->usage[i2] & ISDN_USAGE_EXCLUSIVE;\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: usage of %d and %d\n", i1, i2);\r\n#endif\r\ndev->usage[i1] &= ~ISDN_USAGE_EXCLUSIVE;\r\ndev->usage[i1] |= u2;\r\ndev->usage[i2] &= ~ISDN_USAGE_EXCLUSIVE;\r\ndev->usage[i2] |= u1;\r\nisdn_info_update();\r\n}\r\nint\r\nisdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\r\n{\r\nchar *eaz;\r\nint si1;\r\nint si2;\r\nint ematch;\r\nint wret;\r\nint swapped;\r\nint sidx = 0;\r\nu_long flags;\r\nisdn_net_dev *p;\r\nisdn_net_phone *n;\r\nchar nr[ISDN_MSNLEN];\r\nchar *my_eaz;\r\nif (!setup->phone[0]) {\r\nnr[0] = '0';\r\nnr[1] = '\0';\r\nprintk(KERN_INFO "isdn_net: Incoming call without OAD, assuming '0'\n");\r\n} else\r\nstrlcpy(nr, setup->phone, ISDN_MSNLEN);\r\nsi1 = (int) setup->si1;\r\nsi2 = (int) setup->si2;\r\nif (!setup->eazmsn[0]) {\r\nprintk(KERN_WARNING "isdn_net: Incoming call without CPN, assuming '0'\n");\r\neaz = "0";\r\n} else\r\neaz = setup->eazmsn;\r\nif (dev->net_verbose > 1)\r\nprintk(KERN_INFO "isdn_net: call from %s,%d,%d -> %s\n", nr, si1, si2, eaz);\r\nif ((si1 != 7) && (si1 != 1)) {\r\nif (dev->net_verbose > 1)\r\nprintk(KERN_INFO "isdn_net: Service-Indicator not 1 or 7, ignored\n");\r\nreturn 0;\r\n}\r\nn = (isdn_net_phone *) 0;\r\np = dev->netdev;\r\nematch = wret = swapped = 0;\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: di=%d ch=%d idx=%d usg=%d\n", di, ch, idx,\r\ndev->usage[idx]);\r\n#endif\r\nwhile (p) {\r\nint matchret;\r\nisdn_net_local *lp = p->local;\r\nswitch (swapped) {\r\ncase 2:\r\nisdn_net_swap_usage(idx, sidx);\r\ncase 1:\r\nisdn_net_swapbind(di);\r\nbreak;\r\n}\r\nswapped = 0;\r\nmy_eaz = isdn_map_eaz2msn(lp->msn, di);\r\nif (si1 == 1) {\r\nif (*my_eaz == 'v' || *my_eaz == 'V' ||\r\n*my_eaz == 'b' || *my_eaz == 'B')\r\nmy_eaz++;\r\nelse\r\nmy_eaz = NULL;\r\n} else {\r\nif (*my_eaz == 'b' || *my_eaz == 'B')\r\nmy_eaz++;\r\n}\r\nif (my_eaz)\r\nmatchret = isdn_msncmp(eaz, my_eaz);\r\nelse\r\nmatchret = 1;\r\nif (!matchret)\r\nematch = 1;\r\nif (matchret > wret)\r\nwret = matchret;\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\n",\r\np->dev->name, lp->msn, lp->flags, lp->dialstate);\r\n#endif\r\nif ((!matchret) &&\r\n(((!(lp->flags & ISDN_NET_CONNECTED)) &&\r\n(USG_NONE(dev->usage[idx]))) ||\r\n((((lp->dialstate == 4) || (lp->dialstate == 12)) &&\r\n(!(lp->flags & ISDN_NET_CALLBACK)))\r\n)))\r\n{\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: match1, pdev=%d pch=%d\n",\r\nlp->pre_device, lp->pre_channel);\r\n#endif\r\nif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\r\nif ((lp->pre_channel != ch) ||\r\n(lp->pre_device != di)) {\r\nif (ch == 0) {\r\nsidx = isdn_dc2minor(di, 1);\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: ch is 0\n");\r\n#endif\r\nif (USG_NONE(dev->usage[sidx])) {\r\nif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: 2nd channel is down and bound\n");\r\n#endif\r\nif ((lp->pre_device == di) &&\r\n(lp->pre_channel == 1)) {\r\nisdn_net_swapbind(di);\r\nswapped = 1;\r\n} else {\r\np = (isdn_net_dev *) p->next;\r\ncontinue;\r\n}\r\n} else {\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: 2nd channel is down and unbound\n");\r\n#endif\r\nisdn_net_swap_usage(idx, sidx);\r\nisdn_net_swapbind(di);\r\nswapped = 2;\r\n}\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: final check\n");\r\n#endif\r\nif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\r\n((lp->pre_channel != ch) ||\r\n(lp->pre_device != di))) {\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: final check failed\n");\r\n#endif\r\np = (isdn_net_dev *) p->next;\r\ncontinue;\r\n}\r\n}\r\n} else {\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: already on 2nd channel\n");\r\n#endif\r\n}\r\n}\r\n}\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: match2\n");\r\n#endif\r\nn = lp->phone[0];\r\nif (lp->flags & ISDN_NET_SECURE) {\r\nwhile (n) {\r\nif (!isdn_msncmp(nr, n->num))\r\nbreak;\r\nn = (isdn_net_phone *) n->next;\r\n}\r\n}\r\nif (n || (!(lp->flags & ISDN_NET_SECURE))) {\r\n#ifdef ISDN_DEBUG_NET_ICALL\r\nprintk(KERN_DEBUG "n_fi: match3\n");\r\n#endif\r\nif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\r\nprintk(KERN_INFO "incoming call, interface %s `stopped' -> rejected\n",\r\np->dev->name);\r\nreturn 3;\r\n}\r\nif (!isdn_net_device_started(p)) {\r\nprintk(KERN_INFO "%s: incoming call, interface down -> rejected\n",\r\np->dev->name);\r\nreturn 3;\r\n}\r\nif (lp->master) {\r\nisdn_net_local *mlp = ISDN_MASTER_PRIV(lp);\r\nprintk(KERN_DEBUG "ICALLslv: %s\n", p->dev->name);\r\nprintk(KERN_DEBUG "master=%s\n", lp->master->name);\r\nif (mlp->flags & ISDN_NET_CONNECTED) {\r\nprintk(KERN_DEBUG "master online\n");\r\nwhile (mlp->slave) {\r\nif (ISDN_SLAVE_PRIV(mlp) == lp)\r\nbreak;\r\nmlp = ISDN_SLAVE_PRIV(mlp);\r\n}\r\n} else\r\nprintk(KERN_DEBUG "master offline\n");\r\nprintk(KERN_DEBUG "mlpf: %d\n", mlp->flags & ISDN_NET_CONNECTED);\r\nif (!(mlp->flags & ISDN_NET_CONNECTED)) {\r\np = (isdn_net_dev *) p->next;\r\ncontinue;\r\n}\r\n}\r\nif (lp->flags & ISDN_NET_CALLBACK) {\r\nint chi;\r\nif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\r\nprintk(KERN_INFO "incoming call for callback, interface %s `off' -> rejected\n",\r\np->dev->name);\r\nreturn 3;\r\n}\r\nprintk(KERN_DEBUG "%s: call from %s -> %s, start callback\n",\r\np->dev->name, nr, eaz);\r\nif (lp->phone[1]) {\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif ((chi =\r\nisdn_get_free_channel(\r\nISDN_USAGE_NET,\r\nlp->l2_proto,\r\nlp->l3_proto,\r\nlp->pre_device,\r\nlp->pre_channel,\r\nlp->msn)\r\n) < 0) {\r\nprintk(KERN_WARNING "isdn_net_find_icall: No channel for %s\n",\r\np->dev->name);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nlp->dtimer = 0;\r\nlp->dialstate = 11;\r\nisdn_net_bind_channel(lp, chi);\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\nif (isdn_ppp_bind(lp) < 0) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_unbind_channel(lp);\r\nreturn 0;\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\r\n} else\r\nprintk(KERN_WARNING "isdn_net: %s: No phone number\n",\r\np->dev->name);\r\nreturn 0;\r\n} else {\r\nprintk(KERN_DEBUG "%s: call from %s -> %s accepted\n",\r\np->dev->name, nr, eaz);\r\nif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\nisdn_ppp_free(lp);\r\n#endif\r\nisdn_net_lp_disconnected(lp);\r\nisdn_free_channel(lp->isdn_device, lp->isdn_channel,\r\nISDN_USAGE_NET);\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\r\ndev->usage[idx] |= ISDN_USAGE_NET;\r\nstrcpy(dev->num[idx], nr);\r\nisdn_info_update();\r\ndev->st_netdev[idx] = lp->netdev;\r\nlp->isdn_device = di;\r\nlp->isdn_channel = ch;\r\nlp->ppp_slot = -1;\r\nlp->flags |= ISDN_NET_CONNECTED;\r\nlp->dialstate = 7;\r\nlp->dtimer = 0;\r\nlp->outgoing = 0;\r\nlp->huptimer = 0;\r\nlp->hupflags |= ISDN_WAITCHARGE;\r\nlp->hupflags &= ~ISDN_HAVECHARGE;\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\r\nif (isdn_ppp_bind(lp) < 0) {\r\nisdn_net_unbind_channel(lp);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 1;\r\n}\r\n}\r\n}\r\np = (isdn_net_dev *) p->next;\r\n}\r\nif (!ematch || dev->net_verbose)\r\nprintk(KERN_INFO "isdn_net: call from %s -> %d %s ignored\n", nr, di, eaz);\r\nreturn (wret == 2) ? 5 : 0;\r\n}\r\nisdn_net_dev *\r\nisdn_net_findif(char *name)\r\n{\r\nisdn_net_dev *p = dev->netdev;\r\nwhile (p) {\r\nif (!strcmp(p->dev->name, name))\r\nreturn p;\r\np = (isdn_net_dev *) p->next;\r\n}\r\nreturn (isdn_net_dev *) NULL;\r\n}\r\nstatic int\r\nisdn_net_force_dial_lp(isdn_net_local *lp)\r\n{\r\nif ((!(lp->flags & ISDN_NET_CONNECTED)) && !lp->dialstate) {\r\nint chi;\r\nif (lp->phone[1]) {\r\nulong flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif ((chi = isdn_get_free_channel(\r\nISDN_USAGE_NET,\r\nlp->l2_proto,\r\nlp->l3_proto,\r\nlp->pre_device,\r\nlp->pre_channel,\r\nlp->msn)) < 0) {\r\nprintk(KERN_WARNING "isdn_net_force_dial: No channel for %s\n",\r\nlp->netdev->dev->name);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nlp->dialstate = 1;\r\nisdn_net_bind_channel(lp, chi);\r\n#ifdef CONFIG_ISDN_PPP\r\nif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\r\nif (isdn_ppp_bind(lp) < 0) {\r\nisdn_net_unbind_channel(lp);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_dial();\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\n} else\r\nreturn -EBUSY;\r\n}\r\nint\r\nisdn_net_dial_req(isdn_net_local *lp)\r\n{\r\nif (!(ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_AUTO)) return -EBUSY;\r\nreturn isdn_net_force_dial_lp(lp);\r\n}\r\nint\r\nisdn_net_force_dial(char *name)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(name);\r\nif (!p)\r\nreturn -ENODEV;\r\nreturn (isdn_net_force_dial_lp(p->local));\r\n}\r\nstatic void _isdn_setup(struct net_device *dev)\r\n{\r\nisdn_net_local *lp = netdev_priv(dev);\r\nether_setup(dev);\r\ndev->flags = IFF_NOARP | IFF_POINTOPOINT;\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\ndev->header_ops = NULL;\r\ndev->netdev_ops = &isdn_netdev_ops;\r\ndev->tx_queue_len = 30;\r\nlp->p_encap = ISDN_NET_ENCAP_RAWIP;\r\nlp->magic = ISDN_NET_MAGIC;\r\nlp->last = lp;\r\nlp->next = lp;\r\nlp->isdn_device = -1;\r\nlp->isdn_channel = -1;\r\nlp->pre_device = -1;\r\nlp->pre_channel = -1;\r\nlp->exclusive = -1;\r\nlp->ppp_slot = -1;\r\nlp->pppbind = -1;\r\nskb_queue_head_init(&lp->super_tx_queue);\r\nlp->l2_proto = ISDN_PROTO_L2_X75I;\r\nlp->l3_proto = ISDN_PROTO_L3_TRANS;\r\nlp->triggercps = 6000;\r\nlp->slavedelay = 10 * HZ;\r\nlp->hupflags = ISDN_INHUP;\r\nlp->onhtime = 10;\r\nlp->dialmax = 1;\r\nlp->flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL;\r\nlp->cbdelay = 25;\r\nlp->dialtimeout = -1;\r\nlp->dialwait = 5 * HZ;\r\nlp->dialstarted = 0;\r\nlp->dialwait_timer = 0;\r\n}\r\nchar *\r\nisdn_net_new(char *name, struct net_device *master)\r\n{\r\nisdn_net_dev *netdev;\r\nif (isdn_net_findif(name)) {\r\nprintk(KERN_WARNING "isdn_net: interface %s already exists\n", name);\r\nreturn NULL;\r\n}\r\nif (name == NULL)\r\nreturn NULL;\r\nif (!(netdev = kzalloc(sizeof(isdn_net_dev), GFP_KERNEL))) {\r\nprintk(KERN_WARNING "isdn_net: Could not allocate net-device\n");\r\nreturn NULL;\r\n}\r\nnetdev->dev = alloc_netdev(sizeof(isdn_net_local), name, _isdn_setup);\r\nif (!netdev->dev) {\r\nprintk(KERN_WARNING "isdn_net: Could not allocate network device\n");\r\nkfree(netdev);\r\nreturn NULL;\r\n}\r\nnetdev->local = netdev_priv(netdev->dev);\r\nif (master) {\r\nstruct net_device *p = MASTER_TO_SLAVE(master);\r\nstruct net_device *q = master;\r\nnetdev->local->master = master;\r\nwhile (p) {\r\nq = p;\r\np = MASTER_TO_SLAVE(p);\r\n}\r\nMASTER_TO_SLAVE(q) = netdev->dev;\r\n} else {\r\nnetdev->dev->watchdog_timeo = ISDN_NET_TX_TIMEOUT;\r\nif (register_netdev(netdev->dev) != 0) {\r\nprintk(KERN_WARNING "isdn_net: Could not register net-device\n");\r\nfree_netdev(netdev->dev);\r\nkfree(netdev);\r\nreturn NULL;\r\n}\r\n}\r\nnetdev->queue = netdev->local;\r\nspin_lock_init(&netdev->queue_lock);\r\nnetdev->local->netdev = netdev;\r\nINIT_WORK(&netdev->local->tqueue, isdn_net_softint);\r\nspin_lock_init(&netdev->local->xmit_lock);\r\nnetdev->next = (void *) dev->netdev;\r\ndev->netdev = netdev;\r\nreturn netdev->dev->name;\r\n}\r\nchar *\r\nisdn_net_newslave(char *parm)\r\n{\r\nchar *p = strchr(parm, ',');\r\nisdn_net_dev *n;\r\nchar newname[10];\r\nif (p) {\r\nif (!strlen(p + 1))\r\nreturn NULL;\r\nstrcpy(newname, p + 1);\r\n*p = 0;\r\nif (!(n = isdn_net_findif(parm)))\r\nreturn NULL;\r\nif (n->local->master)\r\nreturn NULL;\r\nif (isdn_net_device_started(n))\r\nreturn NULL;\r\nreturn (isdn_net_new(newname, n->dev));\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nisdn_net_setcfg(isdn_net_ioctl_cfg *cfg)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(cfg->name);\r\nulong features;\r\nint i;\r\nint drvidx;\r\nint chidx;\r\nchar drvid[25];\r\nif (p) {\r\nisdn_net_local *lp = p->local;\r\nfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\r\n((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\r\nif (dev->drv[i])\r\nif ((dev->drv[i]->interface->features & features) == features)\r\nbreak;\r\nif (i == ISDN_MAX_DRIVERS) {\r\nprintk(KERN_WARNING "isdn_net: No driver with selected features\n");\r\nreturn -ENODEV;\r\n}\r\nif (lp->p_encap != cfg->p_encap) {\r\n#ifdef CONFIG_ISDN_X25\r\nstruct concap_proto *cprot = p->cprot;\r\n#endif\r\nif (isdn_net_device_started(p)) {\r\nprintk(KERN_WARNING "%s: cannot change encap when if is up\n",\r\np->dev->name);\r\nreturn -EBUSY;\r\n}\r\n#ifdef CONFIG_ISDN_X25\r\nif (cprot && cprot->pops)\r\ncprot->pops->proto_del(cprot);\r\np->cprot = NULL;\r\nlp->dops = NULL;\r\nswitch (cfg->p_encap) {\r\ncase ISDN_NET_ENCAP_X25IFACE:\r\nlp->dops = &isdn_concap_reliable_dl_dops;\r\n}\r\np->cprot = isdn_concap_new(cfg->p_encap);\r\n#endif\r\n}\r\nswitch (cfg->p_encap) {\r\ncase ISDN_NET_ENCAP_SYNCPPP:\r\n#ifndef CONFIG_ISDN_PPP\r\nprintk(KERN_WARNING "%s: SyncPPP support not configured\n",\r\np->dev->name);\r\nreturn -EINVAL;\r\n#else\r\np->dev->type = ARPHRD_PPP;\r\np->dev->addr_len = 0;\r\n#endif\r\nbreak;\r\ncase ISDN_NET_ENCAP_X25IFACE:\r\n#ifndef CONFIG_ISDN_X25\r\nprintk(KERN_WARNING "%s: isdn-x25 support not configured\n",\r\np->dev->name);\r\nreturn -EINVAL;\r\n#else\r\np->dev->type = ARPHRD_X25;\r\np->dev->addr_len = 0;\r\n#endif\r\nbreak;\r\ncase ISDN_NET_ENCAP_CISCOHDLCK:\r\nbreak;\r\ndefault:\r\nif (cfg->p_encap >= 0 &&\r\ncfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP)\r\nbreak;\r\nprintk(KERN_WARNING\r\n"%s: encapsulation protocol %d not supported\n",\r\np->dev->name, cfg->p_encap);\r\nreturn -EINVAL;\r\n}\r\nif (strlen(cfg->drvid)) {\r\nchar *c,\r\n*e;\r\nif (strnlen(cfg->drvid, sizeof(cfg->drvid)) ==\r\nsizeof(cfg->drvid))\r\nreturn -EINVAL;\r\ndrvidx = -1;\r\nchidx = -1;\r\nstrcpy(drvid, cfg->drvid);\r\nif ((c = strchr(drvid, ','))) {\r\nchidx = (int) simple_strtoul(c + 1, &e, 10);\r\nif (e == c)\r\nchidx = -1;\r\n*c = '\0';\r\n}\r\nfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\r\nif (!(strcmp(dev->drvid[i], drvid))) {\r\ndrvidx = i;\r\nbreak;\r\n}\r\nif ((drvidx == -1) || (chidx == -1))\r\nreturn -ENODEV;\r\n} else {\r\ndrvidx = lp->pre_device;\r\nchidx = lp->pre_channel;\r\n}\r\nif (cfg->exclusive > 0) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\r\nlp->l2_proto, lp->l3_proto, drvidx,\r\nchidx, lp->msn)) < 0) {\r\nlp->exclusive = -1;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndev->usage[i] = ISDN_USAGE_EXCLUSIVE;\r\nisdn_info_update();\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nlp->exclusive = i;\r\n} else {\r\nlp->exclusive = -1;\r\nif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\r\nisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\r\nisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\r\ndrvidx = -1;\r\nchidx = -1;\r\n}\r\n}\r\nstrlcpy(lp->msn, cfg->eaz, sizeof(lp->msn));\r\nlp->pre_device = drvidx;\r\nlp->pre_channel = chidx;\r\nlp->onhtime = cfg->onhtime;\r\nlp->charge = cfg->charge;\r\nlp->l2_proto = cfg->l2_proto;\r\nlp->l3_proto = cfg->l3_proto;\r\nlp->cbdelay = cfg->cbdelay;\r\nlp->dialmax = cfg->dialmax;\r\nlp->triggercps = cfg->triggercps;\r\nlp->slavedelay = cfg->slavedelay * HZ;\r\nlp->pppbind = cfg->pppbind;\r\nlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\r\nlp->dialwait = cfg->dialwait * HZ;\r\nif (cfg->secure)\r\nlp->flags |= ISDN_NET_SECURE;\r\nelse\r\nlp->flags &= ~ISDN_NET_SECURE;\r\nif (cfg->cbhup)\r\nlp->flags |= ISDN_NET_CBHUP;\r\nelse\r\nlp->flags &= ~ISDN_NET_CBHUP;\r\nswitch (cfg->callback) {\r\ncase 0:\r\nlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\r\nbreak;\r\ncase 1:\r\nlp->flags |= ISDN_NET_CALLBACK;\r\nlp->flags &= ~ISDN_NET_CBOUT;\r\nbreak;\r\ncase 2:\r\nlp->flags |= ISDN_NET_CBOUT;\r\nlp->flags &= ~ISDN_NET_CALLBACK;\r\nbreak;\r\n}\r\nlp->flags &= ~ISDN_NET_DIALMODE_MASK;\r\nif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\r\nprintk(KERN_WARNING\r\n"Old isdnctrl version detected! Please update.\n");\r\nlp->flags |= ISDN_NET_DM_OFF;\r\n}\r\nelse {\r\nlp->flags |= cfg->dialmode;\r\n}\r\nif (cfg->chargehup)\r\nlp->hupflags |= ISDN_CHARGEHUP;\r\nelse\r\nlp->hupflags &= ~ISDN_CHARGEHUP;\r\nif (cfg->ihup)\r\nlp->hupflags |= ISDN_INHUP;\r\nelse\r\nlp->hupflags &= ~ISDN_INHUP;\r\nif (cfg->chargeint > 10) {\r\nlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\r\nlp->chargeint = cfg->chargeint * HZ;\r\n}\r\nif (cfg->p_encap != lp->p_encap) {\r\nif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\r\np->dev->header_ops = NULL;\r\np->dev->flags = IFF_NOARP | IFF_POINTOPOINT;\r\n} else {\r\np->dev->header_ops = &isdn_header_ops;\r\nif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\r\np->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\r\nelse\r\np->dev->flags = IFF_NOARP | IFF_POINTOPOINT;\r\n}\r\n}\r\nlp->p_encap = cfg->p_encap;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint\r\nisdn_net_getcfg(isdn_net_ioctl_cfg *cfg)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(cfg->name);\r\nif (p) {\r\nisdn_net_local *lp = p->local;\r\nstrcpy(cfg->eaz, lp->msn);\r\ncfg->exclusive = lp->exclusive;\r\nif (lp->pre_device >= 0) {\r\nsprintf(cfg->drvid, "%s,%d", dev->drvid[lp->pre_device],\r\nlp->pre_channel);\r\n} else\r\ncfg->drvid[0] = '\0';\r\ncfg->onhtime = lp->onhtime;\r\ncfg->charge = lp->charge;\r\ncfg->l2_proto = lp->l2_proto;\r\ncfg->l3_proto = lp->l3_proto;\r\ncfg->p_encap = lp->p_encap;\r\ncfg->secure = (lp->flags & ISDN_NET_SECURE) ? 1 : 0;\r\ncfg->callback = 0;\r\nif (lp->flags & ISDN_NET_CALLBACK)\r\ncfg->callback = 1;\r\nif (lp->flags & ISDN_NET_CBOUT)\r\ncfg->callback = 2;\r\ncfg->cbhup = (lp->flags & ISDN_NET_CBHUP) ? 1 : 0;\r\ncfg->dialmode = lp->flags & ISDN_NET_DIALMODE_MASK;\r\ncfg->chargehup = (lp->hupflags & 4) ? 1 : 0;\r\ncfg->ihup = (lp->hupflags & 8) ? 1 : 0;\r\ncfg->cbdelay = lp->cbdelay;\r\ncfg->dialmax = lp->dialmax;\r\ncfg->triggercps = lp->triggercps;\r\ncfg->slavedelay = lp->slavedelay / HZ;\r\ncfg->chargeint = (lp->hupflags & ISDN_CHARGEHUP) ?\r\n(lp->chargeint / HZ) : 0;\r\ncfg->pppbind = lp->pppbind;\r\ncfg->dialtimeout = lp->dialtimeout >= 0 ? lp->dialtimeout / HZ : -1;\r\ncfg->dialwait = lp->dialwait / HZ;\r\nif (lp->slave) {\r\nif (strlen(lp->slave->name) >= 10)\r\nstrcpy(cfg->slave, "too-long");\r\nelse\r\nstrcpy(cfg->slave, lp->slave->name);\r\n} else\r\ncfg->slave[0] = '\0';\r\nif (lp->master) {\r\nif (strlen(lp->master->name) >= 10)\r\nstrcpy(cfg->master, "too-long");\r\nelse\r\nstrcpy(cfg->master, lp->master->name);\r\n} else\r\ncfg->master[0] = '\0';\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint\r\nisdn_net_addphone(isdn_net_ioctl_phone *phone)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(phone->name);\r\nisdn_net_phone *n;\r\nif (p) {\r\nif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nstrlcpy(n->num, phone->phone, sizeof(n->num));\r\nn->next = p->local->phone[phone->outgoing & 1];\r\np->local->phone[phone->outgoing & 1] = n;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint\r\nisdn_net_getphones(isdn_net_ioctl_phone *phone, char __user *phones)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(phone->name);\r\nint inout = phone->outgoing & 1;\r\nint more = 0;\r\nint count = 0;\r\nisdn_net_phone *n;\r\nif (!p)\r\nreturn -ENODEV;\r\ninout &= 1;\r\nfor (n = p->local->phone[inout]; n; n = n->next) {\r\nif (more) {\r\nput_user(' ', phones++);\r\ncount++;\r\n}\r\nif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\r\nreturn -EFAULT;\r\n}\r\nphones += strlen(n->num);\r\ncount += strlen(n->num);\r\nmore = 1;\r\n}\r\nput_user(0, phones);\r\ncount++;\r\nreturn count;\r\n}\r\nint\r\nisdn_net_getpeer(isdn_net_ioctl_phone *phone, isdn_net_ioctl_phone __user *peer)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(phone->name);\r\nint ch, dv, idx;\r\nif (!p)\r\nreturn -ENODEV;\r\nch = p->local->isdn_channel;\r\ndv = p->local->isdn_device;\r\nif (ch < 0 && dv < 0)\r\nreturn -ENOTCONN;\r\nidx = isdn_dc2minor(dv, ch);\r\nif (idx < 0)\r\nreturn -ENODEV;\r\nif (strncmp(dev->num[idx], "???", 3) == 0)\r\nreturn -ENOTCONN;\r\nstrncpy(phone->phone, dev->num[idx], ISDN_MSNLEN);\r\nphone->outgoing = USG_OUTGOING(dev->usage[idx]);\r\nif (copy_to_user(peer, phone, sizeof(*peer)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint\r\nisdn_net_delphone(isdn_net_ioctl_phone *phone)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(phone->name);\r\nint inout = phone->outgoing & 1;\r\nisdn_net_phone *n;\r\nisdn_net_phone *m;\r\nif (p) {\r\nn = p->local->phone[inout];\r\nm = NULL;\r\nwhile (n) {\r\nif (!strcmp(n->num, phone->phone)) {\r\nif (p->local->dial == n)\r\np->local->dial = n->next;\r\nif (m)\r\nm->next = n->next;\r\nelse\r\np->local->phone[inout] = n->next;\r\nkfree(n);\r\nreturn 0;\r\n}\r\nm = n;\r\nn = (isdn_net_phone *) n->next;\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nisdn_net_rmallphone(isdn_net_dev *p)\r\n{\r\nisdn_net_phone *n;\r\nisdn_net_phone *m;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nn = p->local->phone[i];\r\nwhile (n) {\r\nm = n->next;\r\nkfree(n);\r\nn = m;\r\n}\r\np->local->phone[i] = NULL;\r\n}\r\np->local->dial = NULL;\r\nreturn 0;\r\n}\r\nint\r\nisdn_net_force_hangup(char *name)\r\n{\r\nisdn_net_dev *p = isdn_net_findif(name);\r\nstruct net_device *q;\r\nif (p) {\r\nif (p->local->isdn_device < 0)\r\nreturn 1;\r\nq = p->local->slave;\r\nwhile (q) {\r\nisdn_net_hangup(q);\r\nq = MASTER_TO_SLAVE(q);\r\n}\r\nisdn_net_hangup(p->dev);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nisdn_net_realrm(isdn_net_dev *p, isdn_net_dev *q)\r\n{\r\nu_long flags;\r\nif (isdn_net_device_started(p)) {\r\nreturn -EBUSY;\r\n}\r\n#ifdef CONFIG_ISDN_X25\r\nif (p->cprot && p->cprot->pops)\r\np->cprot->pops->proto_del(p->cprot);\r\n#endif\r\nisdn_net_rmallphone(p);\r\nif (p->local->exclusive != -1)\r\nisdn_unexclusive_channel(p->local->pre_device, p->local->pre_channel);\r\nif (p->local->master) {\r\nif (((isdn_net_local *) ISDN_MASTER_PRIV(p->local))->slave ==\r\np->dev)\r\n((isdn_net_local *)ISDN_MASTER_PRIV(p->local))->slave =\r\np->local->slave;\r\n} else {\r\nunregister_netdev(p->dev);\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (q)\r\nq->next = p->next;\r\nelse\r\ndev->netdev = p->next;\r\nif (p->local->slave) {\r\nchar *slavename = p->local->slave->name;\r\nisdn_net_dev *n = dev->netdev;\r\nq = NULL;\r\nwhile (n) {\r\nif (!strcmp(n->dev->name, slavename)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nisdn_net_realrm(n, q);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nbreak;\r\n}\r\nq = n;\r\nn = (isdn_net_dev *)n->next;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (dev->netdev == NULL)\r\nisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 0);\r\nfree_netdev(p->dev);\r\nkfree(p);\r\nreturn 0;\r\n}\r\nint\r\nisdn_net_rm(char *name)\r\n{\r\nu_long flags;\r\nisdn_net_dev *p;\r\nisdn_net_dev *q;\r\nspin_lock_irqsave(&dev->lock, flags);\r\np = dev->netdev;\r\nq = NULL;\r\nwhile (p) {\r\nif (!strcmp(p->dev->name, name)) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn (isdn_net_realrm(p, q));\r\n}\r\nq = p;\r\np = (isdn_net_dev *) p->next;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (dev->netdev == NULL)\r\nisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 0);\r\nreturn -ENODEV;\r\n}\r\nint\r\nisdn_net_rmall(void)\r\n{\r\nu_long flags;\r\nint ret;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nwhile (dev->netdev) {\r\nif (!dev->netdev->local->master) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif ((ret = isdn_net_realrm(dev->netdev, NULL))) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&dev->lock, flags);\r\n}\r\n}\r\ndev->netdev = NULL;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}
