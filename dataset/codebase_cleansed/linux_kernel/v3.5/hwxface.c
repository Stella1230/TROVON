acpi_status acpi_reset(void)\r\n{\r\nstruct acpi_generic_address *reset_reg;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_reset);\r\nreset_reg = &acpi_gbl_FADT.reset_register;\r\nif (!(acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) ||\r\n!reset_reg->address) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nif (reset_reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\r\nstatus =\r\nacpi_os_write_port((acpi_io_address) reset_reg->address,\r\nacpi_gbl_FADT.reset_value, 8);\r\n} else {\r\nstatus = acpi_hw_write(acpi_gbl_FADT.reset_value, reset_reg);\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_read(u64 *return_value, struct acpi_generic_address *reg)\r\n{\r\nu32 value;\r\nu32 width;\r\nu64 address;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(acpi_read);\r\nif (!return_value) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_hw_validate_register(reg, 64, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*return_value = 0;\r\nvalue = 0;\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_read_memory((acpi_physical_address)\r\naddress, return_value,\r\nreg->bit_width);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nwidth = reg->bit_width;\r\nif (width == 64) {\r\nwidth = 32;\r\n}\r\nstatus = acpi_hw_read_port((acpi_io_address)\r\naddress, &value, width);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*return_value = value;\r\nif (reg->bit_width == 64) {\r\nstatus = acpi_hw_read_port((acpi_io_address)\r\n(address + 4), &value, 32);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n*return_value |= ((u64)value << 32);\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Read: %8.8X%8.8X width %2d from %8.8X%8.8X (%s)\n",\r\nACPI_FORMAT_UINT64(*return_value), reg->bit_width,\r\nACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_write(u64 value, struct acpi_generic_address *reg)\r\n{\r\nu32 width;\r\nu64 address;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(acpi_write);\r\nstatus = acpi_hw_validate_register(reg, 64, &address);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\r\nstatus = acpi_os_write_memory((acpi_physical_address)\r\naddress, value, reg->bit_width);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n} else {\r\nwidth = reg->bit_width;\r\nif (width == 64) {\r\nwidth = 32;\r\n}\r\nstatus = acpi_hw_write_port((acpi_io_address)\r\naddress, ACPI_LODWORD(value),\r\nwidth);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (reg->bit_width == 64) {\r\nstatus = acpi_hw_write_port((acpi_io_address)\r\n(address + 4),\r\nACPI_HIDWORD(value), 32);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"Wrote: %8.8X%8.8X width %2d to %8.8X%8.8X (%s)\n",\r\nACPI_FORMAT_UINT64(value), reg->bit_width,\r\nACPI_FORMAT_UINT64(address),\r\nacpi_ut_get_region_name(reg->space_id)));\r\nreturn (status);\r\n}\r\nacpi_status acpi_read_bit_register(u32 register_id, u32 *return_value)\r\n{\r\nstruct acpi_bit_register_info *bit_reg_info;\r\nu32 register_value;\r\nu32 value;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE_U32(acpi_read_bit_register, register_id);\r\nbit_reg_info = acpi_hw_get_bit_register_info(register_id);\r\nif (!bit_reg_info) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_hw_register_read(bit_reg_info->parent_register,\r\n&register_value);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvalue = ((register_value & bit_reg_info->access_bit_mask)\r\n>> bit_reg_info->bit_position);\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"BitReg %X, ParentReg %X, Actual %8.8X, ReturnValue %8.8X\n",\r\nregister_id, bit_reg_info->parent_register,\r\nregister_value, value));\r\n*return_value = value;\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status acpi_write_bit_register(u32 register_id, u32 value)\r\n{\r\nstruct acpi_bit_register_info *bit_reg_info;\r\nacpi_cpu_flags lock_flags;\r\nu32 register_value;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_U32(acpi_write_bit_register, register_id);\r\nbit_reg_info = acpi_hw_get_bit_register_info(register_id);\r\nif (!bit_reg_info) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nlock_flags = acpi_os_acquire_lock(acpi_gbl_hardware_lock);\r\nif (bit_reg_info->parent_register != ACPI_REGISTER_PM1_STATUS) {\r\nstatus = acpi_hw_register_read(bit_reg_info->parent_register,\r\n&register_value);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\nACPI_REGISTER_INSERT_VALUE(register_value,\r\nbit_reg_info->bit_position,\r\nbit_reg_info->access_bit_mask,\r\nvalue);\r\nstatus = acpi_hw_register_write(bit_reg_info->parent_register,\r\nregister_value);\r\n} else {\r\nregister_value = ACPI_REGISTER_PREPARE_BITS(value,\r\nbit_reg_info->\r\nbit_position,\r\nbit_reg_info->\r\naccess_bit_mask);\r\nif (register_value) {\r\nstatus =\r\nacpi_hw_register_write(ACPI_REGISTER_PM1_STATUS,\r\nregister_value);\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_IO,\r\n"BitReg %X, ParentReg %X, Value %8.8X, Actual %8.8X\n",\r\nregister_id, bit_reg_info->parent_register, value,\r\nregister_value));\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_hardware_lock, lock_flags);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)\r\n{\r\nacpi_status status = AE_OK;\r\nstruct acpi_evaluate_info *info;\r\nACPI_FUNCTION_TRACE(acpi_get_sleep_type_data);\r\nif ((sleep_state > ACPI_S_STATES_MAX) || !sleep_type_a || !sleep_type_b) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo->pathname =\r\nACPI_CAST_PTR(char, acpi_gbl_sleep_state_names[sleep_state]);\r\nstatus = acpi_ns_evaluate(info);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"%s while evaluating SleepState [%s]\n",\r\nacpi_format_exception(status),\r\ninfo->pathname));\r\ngoto cleanup;\r\n}\r\nif (!info->return_object) {\r\nACPI_ERROR((AE_INFO, "No Sleep State object returned from [%s]",\r\ninfo->pathname));\r\nstatus = AE_NOT_EXIST;\r\n}\r\nelse if (info->return_object->common.type != ACPI_TYPE_PACKAGE) {\r\nACPI_ERROR((AE_INFO,\r\n"Sleep State return object is not a Package"));\r\nstatus = AE_AML_OPERAND_TYPE;\r\n}\r\nelse if (info->return_object->package.count < 2) {\r\nACPI_ERROR((AE_INFO,\r\n"Sleep State return package does not have at least two elements"));\r\nstatus = AE_AML_NO_OPERAND;\r\n}\r\nelse if (((info->return_object->package.elements[0])->common.type\r\n!= ACPI_TYPE_INTEGER) ||\r\n((info->return_object->package.elements[1])->common.type\r\n!= ACPI_TYPE_INTEGER)) {\r\nACPI_ERROR((AE_INFO,\r\n"Sleep State return package elements are not both Integers "\r\n"(%s, %s)",\r\nacpi_ut_get_object_type_name(info->return_object->\r\npackage.elements[0]),\r\nacpi_ut_get_object_type_name(info->return_object->\r\npackage.elements[1])));\r\nstatus = AE_AML_OPERAND_TYPE;\r\n} else {\r\n*sleep_type_a = (u8)\r\n(info->return_object->package.elements[0])->integer.value;\r\n*sleep_type_b = (u8)\r\n(info->return_object->package.elements[1])->integer.value;\r\n}\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"While evaluating SleepState [%s], bad Sleep object %p type %s",\r\ninfo->pathname, info->return_object,\r\nacpi_ut_get_object_type_name(info->\r\nreturn_object)));\r\n}\r\nacpi_ut_remove_reference(info->return_object);\r\ncleanup:\r\nACPI_FREE(info);\r\nreturn_ACPI_STATUS(status);\r\n}
