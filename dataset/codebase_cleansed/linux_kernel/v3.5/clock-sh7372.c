static unsigned long div2_recalc(struct clk *clk)\r\n{\r\nreturn clk->parent->rate / 2;\r\n}\r\nstatic unsigned long pllc01_recalc(struct clk *clk)\r\n{\r\nunsigned long mult = 1;\r\nif (__raw_readl(PLLC01CR) & (1 << 14))\r\nmult = (((__raw_readl(clk->enable_reg) >> 24) & 0x3f) + 1) * 2;\r\nreturn clk->parent->rate * mult;\r\n}\r\nstatic void pllc2_table_rebuild(struct clk *clk)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pllc2_freq_table) - 2; i++) {\r\npllc2_freq_table[i].frequency = clk->parent->rate * (i + 20) * 2;\r\npllc2_freq_table[i].index = i;\r\n}\r\npllc2_freq_table[i].frequency = clk->parent->rate;\r\npllc2_freq_table[i].index = i;\r\npllc2_freq_table[++i].frequency = CPUFREQ_TABLE_END;\r\npllc2_freq_table[i].index = i;\r\n}\r\nstatic unsigned long pllc2_recalc(struct clk *clk)\r\n{\r\nunsigned long mult = 1;\r\npllc2_table_rebuild(clk);\r\nif (__raw_readl(PLLC2CR) & (1 << 31))\r\nmult = (((__raw_readl(PLLC2CR) >> 24) & 0x3f) + 1) * 2;\r\nreturn clk->parent->rate * mult;\r\n}\r\nstatic long pllc2_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk_rate_table_round(clk, clk->freq_table, rate);\r\n}\r\nstatic int pllc2_enable(struct clk *clk)\r\n{\r\nint i;\r\n__raw_writel(__raw_readl(PLLC2CR) | 0x80000000, PLLC2CR);\r\nfor (i = 0; i < 100; i++)\r\nif (__raw_readl(PLLC2CR) & 0x80000000) {\r\nclk->rate = pllc2_recalc(clk);\r\nreturn 0;\r\n}\r\npr_err("%s(): timeout!\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void pllc2_disable(struct clk *clk)\r\n{\r\n__raw_writel(__raw_readl(PLLC2CR) & ~0x80000000, PLLC2CR);\r\n}\r\nstatic int pllc2_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long value;\r\nint idx;\r\nidx = clk_rate_table_find(clk, clk->freq_table, rate);\r\nif (idx < 0)\r\nreturn idx;\r\nif (rate == clk->parent->rate)\r\nreturn -EINVAL;\r\nvalue = __raw_readl(PLLC2CR) & ~(0x3f << 24);\r\n__raw_writel(value | ((idx + 19) << 24), PLLC2CR);\r\nclk->rate = clk->freq_table[idx].frequency;\r\nreturn 0;\r\n}\r\nstatic int pllc2_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 value;\r\nint ret, i;\r\nif (!clk->parent_table || !clk->parent_num)\r\nreturn -EINVAL;\r\nfor (i = 0; i < clk->parent_num; i++)\r\nif (clk->parent_table[i] == parent)\r\nbreak;\r\nif (i == clk->parent_num)\r\nreturn -ENODEV;\r\nret = clk_reparent(clk, parent);\r\nif (ret < 0)\r\nreturn ret;\r\nvalue = __raw_readl(PLLC2CR) & ~(3 << 6);\r\n__raw_writel(value | (i << 6), PLLC2CR);\r\npllc2_table_rebuild(clk);\r\nreturn 0;\r\n}\r\nstatic void div4_kick(struct clk *clk)\r\n{\r\nunsigned long value;\r\nvalue = __raw_readl(FRQCRB);\r\nvalue |= (1 << 31);\r\n__raw_writel(value, FRQCRB);\r\n}\r\nstatic unsigned long fsidiv_recalc(struct clk *clk)\r\n{\r\nunsigned long value;\r\nvalue = __raw_readl(clk->mapping->base);\r\nvalue >>= 16;\r\nif (value < 2)\r\nreturn 0;\r\nreturn clk->parent->rate / value;\r\n}\r\nstatic long fsidiv_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk_rate_div_range_round(clk, 2, 0xffff, rate);\r\n}\r\nstatic void fsidiv_disable(struct clk *clk)\r\n{\r\n__raw_writel(0, clk->mapping->base);\r\n}\r\nstatic int fsidiv_enable(struct clk *clk)\r\n{\r\nunsigned long value;\r\nvalue = __raw_readl(clk->mapping->base) >> 16;\r\nif (value < 2)\r\nreturn -EIO;\r\n__raw_writel((value << 16) | 0x3, clk->mapping->base);\r\nreturn 0;\r\n}\r\nstatic int fsidiv_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nint idx;\r\nidx = (clk->parent->rate / rate) & 0xffff;\r\nif (idx < 2)\r\nreturn -EINVAL;\r\n__raw_writel(idx << 16, clk->mapping->base);\r\nreturn 0;\r\n}\r\nvoid __init sh7372_clock_init(void)\r\n{\r\nint k, ret = 0;\r\n__raw_writel(0xe4ef8087, RMSTPCR0);\r\n__raw_writel(0xffffffff, RMSTPCR1);\r\n__raw_writel(0x37c7f7ff, RMSTPCR2);\r\n__raw_writel(0xffffffff, RMSTPCR3);\r\n__raw_writel(0xffe0fffd, RMSTPCR4);\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)\r\nret = clk_register(main_clks[k]);\r\nif (!ret)\r\nret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);\r\nif (!ret)\r\nret = sh_clk_div6_register(div6_clks, DIV6_NR);\r\nif (!ret)\r\nret = sh_clk_div6_reparent_register(div6_reparent_clks, DIV6_REPARENT_NR);\r\nif (!ret)\r\nret = sh_clk_mstp32_register(mstp_clks, MSTP_NR);\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(late_main_clks)); k++)\r\nret = clk_register(late_main_clks[k]);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nif (!ret)\r\nshmobile_clk_init();\r\nelse\r\npanic("failed to setup sh7372 clocks\n");\r\n}
