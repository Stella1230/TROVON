static inline unsigned long FAN_FROM_REG(u16 val)\r\n{\r\nif ((val >= 0xfff) || (val == 0))\r\nreturn 0;\r\nreturn 1350000UL / val;\r\n}\r\nstatic inline u16 FAN_TO_REG(long rpm)\r\n{\r\nif (rpm <= 0)\r\nreturn 0x0fff;\r\nreturn SENSORS_LIMIT((1350000 + (rpm >> 1)) / rpm, 1, 0xffe);\r\n}\r\nstatic inline unsigned long TIME_FROM_REG(u8 reg)\r\n{\r\nreturn reg * 100;\r\n}\r\nstatic inline u8 TIME_TO_REG(unsigned long val)\r\n{\r\nreturn SENSORS_LIMIT((val + 50) / 100, 0, 0xff);\r\n}\r\nstatic inline long TEMP_FROM_REG(s8 reg)\r\n{\r\nreturn reg * 1000;\r\n}\r\nstatic inline s8 TEMP_TO_REG(long val, s8 min, s8 max)\r\n{\r\nreturn SENSORS_LIMIT((val + (val < 0 ? -500 : 500)) / 1000, min, max);\r\n}\r\nstatic void w83793_release_resources(struct kref *ref)\r\n{\r\nstruct w83793_data *data = container_of(ref, struct w83793_data, kref);\r\nkfree(data);\r\n}\r\nstatic ssize_t\r\nshow_vrm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83793_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->vrm);\r\n}\r\nstatic ssize_t\r\nshow_vid(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid[index], data->vrm));\r\n}\r\nstatic ssize_t\r\nstore_vrm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w83793_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_alarm_beep(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index >> 3;\r\nint bit = sensor_attr->index & 0x07;\r\nu8 val;\r\nif (nr == ALARM_STATUS) {\r\nval = (data->alarms[index] >> (bit)) & 1;\r\n} else {\r\nval = (data->beeps[index] >> (bit)) & 1;\r\n}\r\nreturn sprintf(buf, "%u\n", val);\r\n}\r\nstatic ssize_t\r\nstore_beep(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index >> 3;\r\nint shift = sensor_attr->index & 0x07;\r\nu8 beep_bit = 1 << shift;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->beeps[index] = w83793_read_value(client, W83793_REG_BEEP(index));\r\ndata->beeps[index] &= ~beep_bit;\r\ndata->beeps[index] |= val << shift;\r\nw83793_write_value(client, W83793_REG_BEEP(index), data->beeps[index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_beep_enable(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->beep_enable >> 1) & 0x01);\r\n}\r\nstatic ssize_t\r\nstore_beep_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->beep_enable = w83793_read_value(client, W83793_REG_OVT_BEEP)\r\n& 0xfd;\r\ndata->beep_enable |= val << 1;\r\nw83793_write_value(client, W83793_REG_OVT_BEEP, data->beep_enable);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_chassis_clear_legacy(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nu8 val;\r\ndev_warn(dev, "Attribute chassis is deprecated, "\r\n"use intrusion0_alarm instead\n");\r\nmutex_lock(&data->update_lock);\r\nval = w83793_read_value(client, W83793_REG_CLR_CHASSIS);\r\nval |= 0x80;\r\nw83793_write_value(client, W83793_REG_CLR_CHASSIS, val);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_chassis_clear(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nu8 reg;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nreg = w83793_read_value(client, W83793_REG_CLR_CHASSIS);\r\nw83793_write_value(client, W83793_REG_CLR_CHASSIS, reg | 0x80);\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_fan(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nu16 val;\r\nif (nr == FAN_INPUT)\r\nval = data->fan[index] & 0x0fff;\r\nelse\r\nval = data->fan_min[index] & 0x0fff;\r\nreturn sprintf(buf, "%lu\n", FAN_FROM_REG(val));\r\n}\r\nstatic ssize_t\r\nstore_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = FAN_TO_REG(val);\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[index] = val;\r\nw83793_write_value(client, W83793_REG_FAN_MIN(index),\r\n(val >> 8) & 0xff);\r\nw83793_write_value(client, W83793_REG_FAN_MIN(index) + 1, val & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nu16 val;\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nif (nr == PWM_STOP_TIME)\r\nval = TIME_FROM_REG(data->pwm_stop_time[index]);\r\nelse\r\nval = (data->pwm[index][nr] & 0x3f) << 2;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t\r\nstore_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (nr == PWM_STOP_TIME) {\r\nval = TIME_TO_REG(val);\r\ndata->pwm_stop_time[index] = val;\r\nw83793_write_value(client, W83793_REG_PWM_STOP_TIME(index),\r\nval);\r\n} else {\r\nval = SENSORS_LIMIT(val, 0, 0xff) >> 2;\r\ndata->pwm[index][nr] =\r\nw83793_read_value(client, W83793_REG_PWM(index, nr)) & 0xc0;\r\ndata->pwm[index][nr] |= val;\r\nw83793_write_value(client, W83793_REG_PWM(index, nr),\r\ndata->pwm[index][nr]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nlong temp = TEMP_FROM_REG(data->temp[index][nr]);\r\nif (nr == TEMP_READ && index < 4) {\r\nint low = ((data->temp_low_bits >> (index * 2)) & 0x03) * 250;\r\ntemp += temp > 0 ? low : -low;\r\n}\r\nreturn sprintf(buf, "%ld\n", temp);\r\n}\r\nstatic ssize_t\r\nstore_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nlong tmp;\r\nint err;\r\nerr = kstrtol(buf, 10, &tmp);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp[index][nr] = TEMP_TO_REG(tmp, -128, 127);\r\nw83793_write_value(client, W83793_REG_TEMP[index][nr],\r\ndata->temp[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_temp_mode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nu8 mask = (index < 4) ? 0x03 : 0x01;\r\nu8 shift = (index < 4) ? (2 * index) : (index - 4);\r\nu8 tmp;\r\nindex = (index < 4) ? 0 : 1;\r\ntmp = (data->temp_mode[index] >> shift) & mask;\r\nif (tmp == 1)\r\ntmp = index == 0 ? 3 : 4;\r\nelse\r\ntmp = TO_TEMP_MODE[tmp];\r\nreturn sprintf(buf, "%d\n", tmp);\r\n}\r\nstatic ssize_t\r\nstore_temp_mode(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint index = sensor_attr->index;\r\nu8 mask = (index < 4) ? 0x03 : 0x01;\r\nu8 shift = (index < 4) ? (2 * index) : (index - 4);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif ((val == 6) && (index < 4)) {\r\nval -= 3;\r\n} else if ((val == 3 && index < 4)\r\n|| (val == 4 && index >= 4)) {\r\nval = !!val;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nindex = (index < 4) ? 0 : 1;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_mode[index] =\r\nw83793_read_value(client, W83793_REG_TEMP_MODE[index]);\r\ndata->temp_mode[index] &= ~(mask << shift);\r\ndata->temp_mode[index] |= val << shift;\r\nw83793_write_value(client, W83793_REG_TEMP_MODE[index],\r\ndata->temp_mode[index]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf_setup(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nu32 val = 0;\r\nif (nr == SETUP_PWM_DEFAULT)\r\nval = (data->pwm_default & 0x3f) << 2;\r\nelse if (nr == SETUP_PWM_UPTIME)\r\nval = TIME_FROM_REG(data->pwm_uptime);\r\nelse if (nr == SETUP_PWM_DOWNTIME)\r\nval = TIME_FROM_REG(data->pwm_downtime);\r\nelse if (nr == SETUP_TEMP_CRITICAL)\r\nval = TEMP_FROM_REG(data->temp_critical & 0x7f);\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t\r\nstore_sf_setup(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (nr == SETUP_PWM_DEFAULT) {\r\ndata->pwm_default =\r\nw83793_read_value(client, W83793_REG_PWM_DEFAULT) & 0xc0;\r\ndata->pwm_default |= SENSORS_LIMIT(val, 0, 0xff) >> 2;\r\nw83793_write_value(client, W83793_REG_PWM_DEFAULT,\r\ndata->pwm_default);\r\n} else if (nr == SETUP_PWM_UPTIME) {\r\ndata->pwm_uptime = TIME_TO_REG(val);\r\ndata->pwm_uptime += data->pwm_uptime == 0 ? 1 : 0;\r\nw83793_write_value(client, W83793_REG_PWM_UPTIME,\r\ndata->pwm_uptime);\r\n} else if (nr == SETUP_PWM_DOWNTIME) {\r\ndata->pwm_downtime = TIME_TO_REG(val);\r\ndata->pwm_downtime += data->pwm_downtime == 0 ? 1 : 0;\r\nw83793_write_value(client, W83793_REG_PWM_DOWNTIME,\r\ndata->pwm_downtime);\r\n} else {\r\ndata->temp_critical =\r\nw83793_read_value(client, W83793_REG_TEMP_CRITICAL) & 0x80;\r\ndata->temp_critical |= TEMP_TO_REG(val, 0, 0x7f);\r\nw83793_write_value(client, W83793_REG_TEMP_CRITICAL,\r\ndata->temp_critical);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf_ctrl(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nu32 val;\r\nif (nr == TEMP_FAN_MAP) {\r\nval = data->temp_fan_map[index];\r\n} else if (nr == TEMP_PWM_ENABLE) {\r\nval = ((data->pwm_enable >> index) & 0x01) + 2;\r\n} else if (nr == TEMP_CRUISE) {\r\nval = TEMP_FROM_REG(data->temp_cruise[index] & 0x7f);\r\n} else {\r\nval = data->tolerance[index >> 1] >> ((index & 0x01) ? 4 : 0);\r\nval = TEMP_FROM_REG(val & 0x0f);\r\n}\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t\r\nstore_sf_ctrl(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (nr == TEMP_FAN_MAP) {\r\nval = SENSORS_LIMIT(val, 0, 255);\r\nw83793_write_value(client, W83793_REG_TEMP_FAN_MAP(index), val);\r\ndata->temp_fan_map[index] = val;\r\n} else if (nr == TEMP_PWM_ENABLE) {\r\nif (val == 2 || val == 3) {\r\ndata->pwm_enable =\r\nw83793_read_value(client, W83793_REG_PWM_ENABLE);\r\nif (val - 2)\r\ndata->pwm_enable |= 1 << index;\r\nelse\r\ndata->pwm_enable &= ~(1 << index);\r\nw83793_write_value(client, W83793_REG_PWM_ENABLE,\r\ndata->pwm_enable);\r\n} else {\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\n} else if (nr == TEMP_CRUISE) {\r\ndata->temp_cruise[index] =\r\nw83793_read_value(client, W83793_REG_TEMP_CRUISE(index));\r\ndata->temp_cruise[index] &= 0x80;\r\ndata->temp_cruise[index] |= TEMP_TO_REG(val, 0, 0x7f);\r\nw83793_write_value(client, W83793_REG_TEMP_CRUISE(index),\r\ndata->temp_cruise[index]);\r\n} else {\r\nint i = index >> 1;\r\nu8 shift = (index & 0x01) ? 4 : 0;\r\ndata->tolerance[i] =\r\nw83793_read_value(client, W83793_REG_TEMP_TOL(i));\r\ndata->tolerance[i] &= ~(0x0f << shift);\r\ndata->tolerance[i] |= TEMP_TO_REG(val, 0, 0x0f) << shift;\r\nw83793_write_value(client, W83793_REG_TEMP_TOL(i),\r\ndata->tolerance[i]);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf2_pwm(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->sf2_pwm[index][nr] & 0x3f) << 2);\r\n}\r\nstatic ssize_t\r\nstore_sf2_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = SENSORS_LIMIT(val, 0, 0xff) >> 2;\r\nmutex_lock(&data->update_lock);\r\ndata->sf2_pwm[index][nr] =\r\nw83793_read_value(client, W83793_REG_SF2_PWM(index, nr)) & 0xc0;\r\ndata->sf2_pwm[index][nr] |= val;\r\nw83793_write_value(client, W83793_REG_SF2_PWM(index, nr),\r\ndata->sf2_pwm[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sf2_temp(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nreturn sprintf(buf, "%ld\n",\r\nTEMP_FROM_REG(data->sf2_temp[index][nr] & 0x7f));\r\n}\r\nstatic ssize_t\r\nstore_sf2_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = TEMP_TO_REG(val, 0, 0x7f);\r\nmutex_lock(&data->update_lock);\r\ndata->sf2_temp[index][nr] =\r\nw83793_read_value(client, W83793_REG_SF2_TEMP(index, nr)) & 0x80;\r\ndata->sf2_temp[index][nr] |= val;\r\nw83793_write_value(client, W83793_REG_SF2_TEMP(index, nr),\r\ndata->sf2_temp[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_in(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct w83793_data *data = w83793_update_device(dev);\r\nu16 val = data->in[index][nr];\r\nif (index < 3) {\r\nval <<= 2;\r\nval += (data->in_low_bits[nr] >> (index * 2)) & 0x3;\r\n}\r\nval = val * scale_in[index] + scale_in_add[index];\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t\r\nstore_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sensor_attr =\r\nto_sensor_dev_attr_2(attr);\r\nint nr = sensor_attr->nr;\r\nint index = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nval = (val + scale_in[index] / 2) / scale_in[index];\r\nmutex_lock(&data->update_lock);\r\nif (index > 2) {\r\nif (nr == 1 || nr == 2)\r\nval -= scale_in_add[index] / scale_in[index];\r\nval = SENSORS_LIMIT(val, 0, 255);\r\n} else {\r\nval = SENSORS_LIMIT(val, 0, 0x3FF);\r\ndata->in_low_bits[nr] =\r\nw83793_read_value(client, W83793_REG_IN_LOW_BITS[nr]);\r\ndata->in_low_bits[nr] &= ~(0x03 << (2 * index));\r\ndata->in_low_bits[nr] |= (val & 0x03) << (2 * index);\r\nw83793_write_value(client, W83793_REG_IN_LOW_BITS[nr],\r\ndata->in_low_bits[nr]);\r\nval >>= 2;\r\n}\r\ndata->in[index][nr] = val;\r\nw83793_write_value(client, W83793_REG_IN[index][nr],\r\ndata->in[index][nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void w83793_init_client(struct i2c_client *client)\r\n{\r\nif (reset)\r\nw83793_write_value(client, W83793_REG_CONFIG, 0x80);\r\nw83793_write_value(client, W83793_REG_CONFIG,\r\nw83793_read_value(client, W83793_REG_CONFIG) | 0x01);\r\n}\r\nstatic int watchdog_set_timeout(struct w83793_data *data, int timeout)\r\n{\r\nint ret, mtimeout;\r\nmtimeout = DIV_ROUND_UP(timeout, 60);\r\nif (mtimeout > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\ndata->watchdog_timeout = mtimeout;\r\nw83793_write_value(data->client, W83793_REG_WDT_TIMEOUT,\r\ndata->watchdog_timeout);\r\nret = mtimeout * 60;\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_get_timeout(struct w83793_data *data)\r\n{\r\nint timeout;\r\nmutex_lock(&data->watchdog_lock);\r\ntimeout = data->watchdog_timeout * 60;\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn timeout;\r\n}\r\nstatic int watchdog_trigger(struct w83793_data *data)\r\n{\r\nint ret = 0;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\nw83793_write_value(data->client, W83793_REG_WDT_TIMEOUT,\r\ndata->watchdog_timeout);\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_enable(struct w83793_data *data)\r\n{\r\nint ret = 0;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\nw83793_write_value(data->client, W83793_REG_WDT_TIMEOUT,\r\ndata->watchdog_timeout);\r\nw83793_write_value(data->client, W83793_REG_WDT_LOCK, 0x55);\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_disable(struct w83793_data *data)\r\n{\r\nint ret = 0;\r\nmutex_lock(&data->watchdog_lock);\r\nif (!data->client) {\r\nret = -ENODEV;\r\ngoto leave;\r\n}\r\nw83793_write_value(data->client, W83793_REG_WDT_LOCK, 0xAA);\r\nleave:\r\nmutex_unlock(&data->watchdog_lock);\r\nreturn ret;\r\n}\r\nstatic int watchdog_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct w83793_data *pos, *data = NULL;\r\nint watchdog_is_open;\r\nif (!mutex_trylock(&watchdog_data_mutex))\r\nreturn -ERESTARTSYS;\r\nlist_for_each_entry(pos, &watchdog_data_list, list) {\r\nif (pos->watchdog_miscdev.minor == iminor(inode)) {\r\ndata = pos;\r\nbreak;\r\n}\r\n}\r\nwatchdog_is_open = test_and_set_bit(0, &data->watchdog_is_open);\r\nif (!watchdog_is_open)\r\nkref_get(&data->kref);\r\nmutex_unlock(&watchdog_data_mutex);\r\nif (watchdog_is_open)\r\nreturn -EBUSY;\r\nwatchdog_enable(data);\r\nfilp->private_data = data;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int watchdog_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct w83793_data *data = filp->private_data;\r\nif (data->watchdog_expect_close) {\r\nwatchdog_disable(data);\r\ndata->watchdog_expect_close = 0;\r\n} else {\r\nwatchdog_trigger(data);\r\ndev_crit(&data->client->dev,\r\n"unexpected close, not stopping watchdog!\n");\r\n}\r\nclear_bit(0, &data->watchdog_is_open);\r\nmutex_lock(&watchdog_data_mutex);\r\nkref_put(&data->kref, w83793_release_resources);\r\nmutex_unlock(&watchdog_data_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t watchdog_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nssize_t ret;\r\nstruct w83793_data *data = filp->private_data;\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t i;\r\ndata->watchdog_expect_close = 0;\r\nfor (i = 0; i != count; i++) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\ndata->watchdog_expect_close = 1;\r\n}\r\n}\r\nret = watchdog_trigger(data);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic long watchdog_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING |\r\nWDIOF_SETTIMEOUT |\r\nWDIOF_CARDRESET,\r\n.identity = "w83793 watchdog"\r\n};\r\nint val, ret = 0;\r\nstruct w83793_data *data = filp->private_data;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nif (!nowayout)\r\nident.options |= WDIOF_MAGICCLOSE;\r\nif (copy_to_user((void __user *)arg, &ident, sizeof(ident)))\r\nret = -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nval = data->watchdog_caused_reboot ? WDIOF_CARDRESET : 0;\r\nret = put_user(val, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(0, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nret = watchdog_trigger(data);\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nval = watchdog_get_timeout(data);\r\nret = put_user(val, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(val, (int __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = watchdog_set_timeout(data, val);\r\nif (ret > 0)\r\nret = put_user(ret, (int __user *)arg);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(val, (int __user *)arg)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (val & WDIOS_DISABLECARD)\r\nret = watchdog_disable(data);\r\nelse if (val & WDIOS_ENABLECARD)\r\nret = watchdog_enable(data);\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int watchdog_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nstruct w83793_data *data = NULL;\r\nif (code == SYS_DOWN || code == SYS_HALT) {\r\nmutex_lock(&watchdog_data_mutex);\r\nlist_for_each_entry(data, &watchdog_data_list, list) {\r\nif (data->watchdog_miscdev.minor)\r\nwatchdog_disable(data);\r\n}\r\nmutex_unlock(&watchdog_data_mutex);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int w83793_remove(struct i2c_client *client)\r\n{\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nstruct device *dev = &client->dev;\r\nint i, tmp;\r\nif (data->watchdog_miscdev.minor) {\r\nmisc_deregister(&data->watchdog_miscdev);\r\nif (data->watchdog_is_open) {\r\ndev_warn(&client->dev,\r\n"i2c client detached with watchdog open! "\r\n"Stopping watchdog.\n");\r\nwatchdog_disable(data);\r\n}\r\nmutex_lock(&watchdog_data_mutex);\r\nlist_del(&data->list);\r\nmutex_unlock(&watchdog_data_mutex);\r\nmutex_lock(&data->watchdog_lock);\r\ndata->client = NULL;\r\nmutex_unlock(&data->watchdog_lock);\r\n}\r\ntmp = w83793_read_value(client, W83793_REG_CONFIG);\r\nw83793_write_value(client, W83793_REG_CONFIG, tmp & ~0x04);\r\nunregister_reboot_notifier(&watchdog_notifier);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_sensor_attr_2); i++)\r\ndevice_remove_file(dev,\r\n&w83793_sensor_attr_2[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++)\r\ndevice_remove_file(dev, &sda_single_files[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_vid); i++)\r\ndevice_remove_file(dev, &w83793_vid[i].dev_attr);\r\ndevice_remove_file(dev, &dev_attr_vrm);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_left_fan); i++)\r\ndevice_remove_file(dev, &w83793_left_fan[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_left_pwm); i++)\r\ndevice_remove_file(dev, &w83793_left_pwm[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_temp); i++)\r\ndevice_remove_file(dev, &w83793_temp[i].dev_attr);\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1] != NULL)\r\ni2c_unregister_device(data->lm75[1]);\r\nmutex_lock(&watchdog_data_mutex);\r\nkref_put(&data->kref, w83793_release_resources);\r\nmutex_unlock(&watchdog_data_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nw83793_detect_subclients(struct i2c_client *client)\r\n{\r\nint i, id, err;\r\nint address = client->addr;\r\nu8 tmp;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nid = i2c_adapter_id(adapter);\r\nif (force_subclients[0] == id && force_subclients[1] == address) {\r\nfor (i = 2; i <= 3; i++) {\r\nif (force_subclients[i] < 0x48\r\n|| force_subclients[i] > 0x4f) {\r\ndev_err(&client->dev,\r\n"invalid subclient "\r\n"address %d; must be 0x48-0x4f\n",\r\nforce_subclients[i]);\r\nerr = -EINVAL;\r\ngoto ERROR_SC_0;\r\n}\r\n}\r\nw83793_write_value(client, W83793_REG_I2C_SUBADDR,\r\n(force_subclients[2] & 0x07) |\r\n((force_subclients[3] & 0x07) << 4));\r\n}\r\ntmp = w83793_read_value(client, W83793_REG_I2C_SUBADDR);\r\nif (!(tmp & 0x08))\r\ndata->lm75[0] = i2c_new_dummy(adapter, 0x48 + (tmp & 0x7));\r\nif (!(tmp & 0x80)) {\r\nif ((data->lm75[0] != NULL)\r\n&& ((tmp & 0x7) == ((tmp >> 4) & 0x7))) {\r\ndev_err(&client->dev,\r\n"duplicate addresses 0x%x, "\r\n"use force_subclients\n", data->lm75[0]->addr);\r\nerr = -ENODEV;\r\ngoto ERROR_SC_1;\r\n}\r\ndata->lm75[1] = i2c_new_dummy(adapter,\r\n0x48 + ((tmp >> 4) & 0x7));\r\n}\r\nreturn 0;\r\nERROR_SC_1:\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nERROR_SC_0:\r\nreturn err;\r\n}\r\nstatic int w83793_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nu8 tmp, bank, chip_id;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nunsigned short address = client->addr;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nbank = i2c_smbus_read_byte_data(client, W83793_REG_BANKSEL);\r\ntmp = bank & 0x80 ? 0x5c : 0xa3;\r\nif (tmp != i2c_smbus_read_byte_data(client, W83793_REG_VENDORID)) {\r\npr_debug("w83793: Detection failed at check vendor id\n");\r\nreturn -ENODEV;\r\n}\r\nif ((bank & 0x07) == 0\r\n&& i2c_smbus_read_byte_data(client, W83793_REG_I2C_ADDR) !=\r\n(address << 1)) {\r\npr_debug("w83793: Detection failed at check i2c addr\n");\r\nreturn -ENODEV;\r\n}\r\nchip_id = i2c_smbus_read_byte_data(client, W83793_REG_CHIPID);\r\nif (chip_id != 0x7b)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "w83793", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int w83793_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nconst int watchdog_minors[] = { WATCHDOG_MINOR, 212, 213, 214, 215 };\r\nstruct w83793_data *data;\r\nint i, tmp, val, err;\r\nint files_fan = ARRAY_SIZE(w83793_left_fan) / 7;\r\nint files_pwm = ARRAY_SIZE(w83793_left_pwm) / 5;\r\nint files_temp = ARRAY_SIZE(w83793_temp) / 6;\r\ndata = kzalloc(sizeof(struct w83793_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(client, data);\r\ndata->bank = i2c_smbus_read_byte_data(client, W83793_REG_BANKSEL);\r\nmutex_init(&data->update_lock);\r\nmutex_init(&data->watchdog_lock);\r\nINIT_LIST_HEAD(&data->list);\r\nkref_init(&data->kref);\r\ndata->client = client;\r\nerr = w83793_detect_subclients(client);\r\nif (err)\r\ngoto free_mem;\r\nw83793_init_client(client);\r\ndata->has_fan = 0x1f;\r\ndata->has_pwm = 0x07;\r\ntmp = w83793_read_value(client, W83793_REG_MFC);\r\nval = w83793_read_value(client, W83793_REG_FANIN_CTRL);\r\nif (tmp & 0x80) {\r\ndata->has_vid |= 0x2;\r\n} else {\r\ndata->has_pwm |= 0x18;\r\nif (val & 0x01) {\r\ndata->has_fan |= 0x20;\r\ndata->has_pwm |= 0x20;\r\n}\r\nif (val & 0x02) {\r\ndata->has_fan |= 0x40;\r\ndata->has_pwm |= 0x40;\r\n}\r\nif (!(tmp & 0x40) && (val & 0x04)) {\r\ndata->has_fan |= 0x80;\r\ndata->has_pwm |= 0x80;\r\n}\r\n}\r\nif (!(tmp & 0x29))\r\ndata->has_vid |= 0x1;\r\nif (0x08 == (tmp & 0x0c)) {\r\nif (val & 0x08)\r\ndata->has_fan |= 0x100;\r\nif (val & 0x10)\r\ndata->has_fan |= 0x200;\r\n}\r\nif (0x20 == (tmp & 0x30)) {\r\nif (val & 0x20)\r\ndata->has_fan |= 0x400;\r\nif (val & 0x40)\r\ndata->has_fan |= 0x800;\r\n}\r\nif ((tmp & 0x01) && (val & 0x04)) {\r\ndata->has_fan |= 0x80;\r\ndata->has_pwm |= 0x80;\r\n}\r\ntmp = w83793_read_value(client, W83793_REG_FANIN_SEL);\r\nif ((tmp & 0x01) && (val & 0x08)) {\r\ndata->has_fan |= 0x100;\r\n}\r\nif ((tmp & 0x02) && (val & 0x10)) {\r\ndata->has_fan |= 0x200;\r\n}\r\nif ((tmp & 0x04) && (val & 0x20)) {\r\ndata->has_fan |= 0x400;\r\n}\r\nif ((tmp & 0x08) && (val & 0x40)) {\r\ndata->has_fan |= 0x800;\r\n}\r\ntmp = w83793_read_value(client, W83793_REG_TEMP_MODE[0]);\r\nif (tmp & 0x01)\r\ndata->has_temp |= 0x01;\r\nif (tmp & 0x04)\r\ndata->has_temp |= 0x02;\r\nif (tmp & 0x10)\r\ndata->has_temp |= 0x04;\r\nif (tmp & 0x40)\r\ndata->has_temp |= 0x08;\r\ntmp = w83793_read_value(client, W83793_REG_TEMP_MODE[1]);\r\nif (tmp & 0x01)\r\ndata->has_temp |= 0x10;\r\nif (tmp & 0x02)\r\ndata->has_temp |= 0x20;\r\nfor (i = 0; i < ARRAY_SIZE(w83793_sensor_attr_2); i++) {\r\nerr = device_create_file(dev,\r\n&w83793_sensor_attr_2[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(w83793_vid); i++) {\r\nif (!(data->has_vid & (1 << i)))\r\ncontinue;\r\nerr = device_create_file(dev, &w83793_vid[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (data->has_vid) {\r\ndata->vrm = vid_which_vrm();\r\nerr = device_create_file(dev, &dev_attr_vrm);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++) {\r\nerr = device_create_file(dev, &sda_single_files[i].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nint j;\r\nif (!(data->has_temp & (1 << i)))\r\ncontinue;\r\nfor (j = 0; j < files_temp; j++) {\r\nerr = device_create_file(dev,\r\n&w83793_temp[(i) * files_temp\r\n+ j].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\nfor (i = 5; i < 12; i++) {\r\nint j;\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\nfor (j = 0; j < files_fan; j++) {\r\nerr = device_create_file(dev,\r\n&w83793_left_fan[(i - 5) * files_fan\r\n+ j].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\nfor (i = 3; i < 8; i++) {\r\nint j;\r\nif (!(data->has_pwm & (1 << i)))\r\ncontinue;\r\nfor (j = 0; j < files_pwm; j++) {\r\nerr = device_create_file(dev,\r\n&w83793_left_pwm[(i - 3) * files_pwm\r\n+ j].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nerr = register_reboot_notifier(&watchdog_notifier);\r\nif (err != 0) {\r\ndev_err(&client->dev,\r\n"cannot register reboot notifier (err=%d)\n", err);\r\ngoto exit_devunreg;\r\n}\r\ntmp = w83793_read_value(client, W83793_REG_CONFIG);\r\nw83793_write_value(client, W83793_REG_CONFIG, tmp | 0x04);\r\ndata->watchdog_timeout = timeout;\r\ndata->watchdog_caused_reboot =\r\nw83793_read_value(data->client, W83793_REG_WDT_STATUS) & 0x01;\r\nwatchdog_disable(data);\r\nmutex_lock(&watchdog_data_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(watchdog_minors); i++) {\r\nsnprintf(data->watchdog_name, sizeof(data->watchdog_name),\r\n"watchdog%c", (i == 0) ? '\0' : ('0' + i));\r\ndata->watchdog_miscdev.name = data->watchdog_name;\r\ndata->watchdog_miscdev.fops = &watchdog_fops;\r\ndata->watchdog_miscdev.minor = watchdog_minors[i];\r\nerr = misc_register(&data->watchdog_miscdev);\r\nif (err == -EBUSY)\r\ncontinue;\r\nif (err) {\r\ndata->watchdog_miscdev.minor = 0;\r\ndev_err(&client->dev,\r\n"Registering watchdog chardev: %d\n", err);\r\nbreak;\r\n}\r\nlist_add(&data->list, &watchdog_data_list);\r\ndev_info(&client->dev,\r\n"Registered watchdog chardev major 10, minor: %d\n",\r\nwatchdog_minors[i]);\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(watchdog_minors)) {\r\ndata->watchdog_miscdev.minor = 0;\r\ndev_warn(&client->dev, "Couldn't register watchdog chardev "\r\n"(due to no free minor)\n");\r\n}\r\nmutex_unlock(&watchdog_data_mutex);\r\nreturn 0;\r\nexit_devunreg:\r\nhwmon_device_unregister(data->hwmon_dev);\r\nexit_remove:\r\nfor (i = 0; i < ARRAY_SIZE(w83793_sensor_attr_2); i++)\r\ndevice_remove_file(dev, &w83793_sensor_attr_2[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(sda_single_files); i++)\r\ndevice_remove_file(dev, &sda_single_files[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_vid); i++)\r\ndevice_remove_file(dev, &w83793_vid[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_left_fan); i++)\r\ndevice_remove_file(dev, &w83793_left_fan[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_left_pwm); i++)\r\ndevice_remove_file(dev, &w83793_left_pwm[i].dev_attr);\r\nfor (i = 0; i < ARRAY_SIZE(w83793_temp); i++)\r\ndevice_remove_file(dev, &w83793_temp[i].dev_attr);\r\nif (data->lm75[0] != NULL)\r\ni2c_unregister_device(data->lm75[0]);\r\nif (data->lm75[1] != NULL)\r\ni2c_unregister_device(data->lm75[1]);\r\nfree_mem:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void w83793_update_nonvolatile(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nint i, j;\r\nif (!(time_after(jiffies, data->last_nonvolatile + HZ * 300)\r\n|| !data->valid))\r\nreturn;\r\nfor (i = 1; i < 3; i++) {\r\nfor (j = 0; j < ARRAY_SIZE(data->in); j++) {\r\ndata->in[j][i] =\r\nw83793_read_value(client, W83793_REG_IN[j][i]);\r\n}\r\ndata->in_low_bits[i] =\r\nw83793_read_value(client, W83793_REG_IN_LOW_BITS[i]);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->fan_min); i++) {\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\ndata->fan_min[i] =\r\nw83793_read_value(client, W83793_REG_FAN_MIN(i)) << 8;\r\ndata->fan_min[i] |=\r\nw83793_read_value(client, W83793_REG_FAN_MIN(i) + 1);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_fan_map); i++) {\r\nif (!(data->has_temp & (1 << i)))\r\ncontinue;\r\ndata->temp_fan_map[i] =\r\nw83793_read_value(client, W83793_REG_TEMP_FAN_MAP(i));\r\nfor (j = 1; j < 5; j++) {\r\ndata->temp[i][j] =\r\nw83793_read_value(client, W83793_REG_TEMP[i][j]);\r\n}\r\ndata->temp_cruise[i] =\r\nw83793_read_value(client, W83793_REG_TEMP_CRUISE(i));\r\nfor (j = 0; j < 7; j++) {\r\ndata->sf2_pwm[i][j] =\r\nw83793_read_value(client, W83793_REG_SF2_PWM(i, j));\r\ndata->sf2_temp[i][j] =\r\nw83793_read_value(client,\r\nW83793_REG_SF2_TEMP(i, j));\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_mode); i++)\r\ndata->temp_mode[i] =\r\nw83793_read_value(client, W83793_REG_TEMP_MODE[i]);\r\nfor (i = 0; i < ARRAY_SIZE(data->tolerance); i++) {\r\ndata->tolerance[i] =\r\nw83793_read_value(client, W83793_REG_TEMP_TOL(i));\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->pwm); i++) {\r\nif (!(data->has_pwm & (1 << i)))\r\ncontinue;\r\ndata->pwm[i][PWM_NONSTOP] =\r\nw83793_read_value(client, W83793_REG_PWM(i, PWM_NONSTOP));\r\ndata->pwm[i][PWM_START] =\r\nw83793_read_value(client, W83793_REG_PWM(i, PWM_START));\r\ndata->pwm_stop_time[i] =\r\nw83793_read_value(client, W83793_REG_PWM_STOP_TIME(i));\r\n}\r\ndata->pwm_default = w83793_read_value(client, W83793_REG_PWM_DEFAULT);\r\ndata->pwm_enable = w83793_read_value(client, W83793_REG_PWM_ENABLE);\r\ndata->pwm_uptime = w83793_read_value(client, W83793_REG_PWM_UPTIME);\r\ndata->pwm_downtime = w83793_read_value(client, W83793_REG_PWM_DOWNTIME);\r\ndata->temp_critical =\r\nw83793_read_value(client, W83793_REG_TEMP_CRITICAL);\r\ndata->beep_enable = w83793_read_value(client, W83793_REG_OVT_BEEP);\r\nfor (i = 0; i < ARRAY_SIZE(data->beeps); i++)\r\ndata->beeps[i] = w83793_read_value(client, W83793_REG_BEEP(i));\r\ndata->last_nonvolatile = jiffies;\r\n}\r\nstatic struct w83793_data *w83793_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (!(time_after(jiffies, data->last_updated + HZ * 2)\r\n|| !data->valid))\r\ngoto END;\r\nfor (i = 0; i < ARRAY_SIZE(data->in); i++)\r\ndata->in[i][IN_READ] =\r\nw83793_read_value(client, W83793_REG_IN[i][IN_READ]);\r\ndata->in_low_bits[IN_READ] =\r\nw83793_read_value(client, W83793_REG_IN_LOW_BITS[IN_READ]);\r\nfor (i = 0; i < ARRAY_SIZE(data->fan); i++) {\r\nif (!(data->has_fan & (1 << i)))\r\ncontinue;\r\ndata->fan[i] =\r\nw83793_read_value(client, W83793_REG_FAN(i)) << 8;\r\ndata->fan[i] |=\r\nw83793_read_value(client, W83793_REG_FAN(i) + 1);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->temp); i++) {\r\nif (!(data->has_temp & (1 << i)))\r\ncontinue;\r\ndata->temp[i][TEMP_READ] =\r\nw83793_read_value(client, W83793_REG_TEMP[i][TEMP_READ]);\r\n}\r\ndata->temp_low_bits =\r\nw83793_read_value(client, W83793_REG_TEMP_LOW_BITS);\r\nfor (i = 0; i < ARRAY_SIZE(data->pwm); i++) {\r\nif (data->has_pwm & (1 << i))\r\ndata->pwm[i][PWM_DUTY] =\r\nw83793_read_value(client,\r\nW83793_REG_PWM(i, PWM_DUTY));\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->alarms); i++)\r\ndata->alarms[i] =\r\nw83793_read_value(client, W83793_REG_ALARM(i));\r\nif (data->has_vid & 0x01)\r\ndata->vid[0] = w83793_read_value(client, W83793_REG_VID_INA);\r\nif (data->has_vid & 0x02)\r\ndata->vid[1] = w83793_read_value(client, W83793_REG_VID_INB);\r\nw83793_update_nonvolatile(dev);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\nEND:\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic u8 w83793_read_value(struct i2c_client *client, u16 reg)\r\n{\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nu8 res = 0xff;\r\nu8 new_bank = reg >> 8;\r\nnew_bank |= data->bank & 0xfc;\r\nif (data->bank != new_bank) {\r\nif (i2c_smbus_write_byte_data\r\n(client, W83793_REG_BANKSEL, new_bank) >= 0)\r\ndata->bank = new_bank;\r\nelse {\r\ndev_err(&client->dev,\r\n"set bank to %d failed, fall back "\r\n"to bank %d, read reg 0x%x error\n",\r\nnew_bank, data->bank, reg);\r\nres = 0x0;\r\ngoto END;\r\n}\r\n}\r\nres = i2c_smbus_read_byte_data(client, reg & 0xff);\r\nEND:\r\nreturn res;\r\n}\r\nstatic int w83793_write_value(struct i2c_client *client, u16 reg, u8 value)\r\n{\r\nstruct w83793_data *data = i2c_get_clientdata(client);\r\nint res;\r\nu8 new_bank = reg >> 8;\r\nnew_bank |= data->bank & 0xfc;\r\nif (data->bank != new_bank) {\r\nres = i2c_smbus_write_byte_data(client, W83793_REG_BANKSEL,\r\nnew_bank);\r\nif (res < 0) {\r\ndev_err(&client->dev,\r\n"set bank to %d failed, fall back "\r\n"to bank %d, write reg 0x%x error\n",\r\nnew_bank, data->bank, reg);\r\ngoto END;\r\n}\r\ndata->bank = new_bank;\r\n}\r\nres = i2c_smbus_write_byte_data(client, reg & 0xff, value);\r\nEND:\r\nreturn res;\r\n}
