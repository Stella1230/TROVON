static irqreturn_t mcs5000_ts_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mcs5000_ts_data *data = dev_id;\r\nstruct i2c_client *client = data->client;\r\nu8 buffer[READ_BLOCK_SIZE];\r\nint err;\r\nint x;\r\nint y;\r\nerr = i2c_smbus_read_i2c_block_data(client, MCS5000_TS_INPUT_INFO,\r\nREAD_BLOCK_SIZE, buffer);\r\nif (err < 0) {\r\ndev_err(&client->dev, "%s, err[%d]\n", __func__, err);\r\ngoto out;\r\n}\r\nswitch (buffer[READ_INPUT_INFO]) {\r\ncase INPUT_TYPE_NONTOUCH:\r\ninput_report_key(data->input_dev, BTN_TOUCH, 0);\r\ninput_sync(data->input_dev);\r\nbreak;\r\ncase INPUT_TYPE_SINGLE:\r\nx = (buffer[READ_X_POS_UPPER] << 8) | buffer[READ_X_POS_LOWER];\r\ny = (buffer[READ_Y_POS_UPPER] << 8) | buffer[READ_Y_POS_LOWER];\r\ninput_report_key(data->input_dev, BTN_TOUCH, 1);\r\ninput_report_abs(data->input_dev, ABS_X, x);\r\ninput_report_abs(data->input_dev, ABS_Y, y);\r\ninput_sync(data->input_dev);\r\nbreak;\r\ncase INPUT_TYPE_DUAL:\r\nbreak;\r\ncase INPUT_TYPE_PALM:\r\nbreak;\r\ncase INPUT_TYPE_PROXIMITY:\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "Unknown ts input type %d\n",\r\nbuffer[READ_INPUT_INFO]);\r\nbreak;\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mcs5000_ts_phys_init(struct mcs5000_ts_data *data)\r\n{\r\nconst struct mcs_platform_data *platform_data =\r\ndata->platform_data;\r\nstruct i2c_client *client = data->client;\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_OP_MODE,\r\nRESET_EXT_SOFT | OP_MODE_SLEEP);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_X_SIZE_UPPER,\r\nplatform_data->x_size >> 8);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_X_SIZE_LOWER,\r\nplatform_data->x_size & 0xff);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_Y_SIZE_UPPER,\r\nplatform_data->y_size >> 8);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_Y_SIZE_LOWER,\r\nplatform_data->y_size & 0xff);\r\ni2c_smbus_write_byte_data(data->client, MCS5000_TS_OP_MODE,\r\nOP_MODE_ACTIVE | REPORT_RATE_80);\r\n}\r\nstatic int __devinit mcs5000_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mcs5000_ts_data *data;\r\nstruct input_dev *input_dev;\r\nint ret;\r\nif (!client->dev.platform_data)\r\nreturn -EINVAL;\r\ndata = kzalloc(sizeof(struct mcs5000_ts_data), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!data || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ndata->client = client;\r\ndata->input_dev = input_dev;\r\ndata->platform_data = client->dev.platform_data;\r\ninput_dev->name = "MELPAS MCS-5000 Touchscreen";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X, 0, MCS5000_MAX_XC, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, MCS5000_MAX_YC, 0, 0);\r\ninput_set_drvdata(input_dev, data);\r\nif (data->platform_data->cfg_pin)\r\ndata->platform_data->cfg_pin();\r\nret = request_threaded_irq(client->irq, NULL, mcs5000_ts_interrupt,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT, "mcs5000_ts", data);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_mem;\r\n}\r\nret = input_register_device(data->input_dev);\r\nif (ret < 0)\r\ngoto err_free_irq;\r\nmcs5000_ts_phys_init(data);\r\ni2c_set_clientdata(client, data);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, data);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int __devexit mcs5000_ts_remove(struct i2c_client *client)\r\n{\r\nstruct mcs5000_ts_data *data = i2c_get_clientdata(client);\r\nfree_irq(client->irq, data);\r\ninput_unregister_device(data->input_dev);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int mcs5000_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\ni2c_smbus_write_byte_data(client, MCS5000_TS_OP_MODE, OP_MODE_SLEEP);\r\nreturn 0;\r\n}\r\nstatic int mcs5000_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mcs5000_ts_data *data = i2c_get_clientdata(client);\r\nmcs5000_ts_phys_init(data);\r\nreturn 0;\r\n}
