int wep_change_key(wlandevice_t *wlandev, int keynum, u8 *key, int keylen)\r\n{\r\nif (keylen < 0)\r\nreturn -1;\r\nif (keylen >= MAX_KEYLEN)\r\nreturn -1;\r\nif (key == NULL)\r\nreturn -1;\r\nif (keynum < 0)\r\nreturn -1;\r\nif (keynum >= NUM_WEPKEYS)\r\nreturn -1;\r\n#ifdef WEP_DEBUG\r\nprintk(KERN_DEBUG\r\n"WEP key %d len %d = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",\r\nkeynum, keylen, key[0], key[1], key[2], key[3], key[4], key[5],\r\nkey[6], key[7]);\r\n#endif\r\nwlandev->wep_keylens[keynum] = keylen;\r\nmemcpy(wlandev->wep_keys[keynum], key, keylen);\r\nreturn 0;\r\n}\r\nint wep_decrypt(wlandevice_t *wlandev, u8 *buf, u32 len, int key_override,\r\nu8 *iv, u8 *icv)\r\n{\r\nu32 i, j, k, crc, keylen;\r\nu8 s[256], key[64], c_crc[4];\r\nu8 keyidx;\r\nif (len <= 0)\r\nreturn -1;\r\nkey[0] = iv[0];\r\nkey[1] = iv[1];\r\nkey[2] = iv[2];\r\nkeyidx = WEP_KEY(iv[3]);\r\nif (key_override >= 0)\r\nkeyidx = key_override;\r\nif (keyidx >= NUM_WEPKEYS)\r\nreturn -2;\r\nkeylen = wlandev->wep_keylens[keyidx];\r\nif (keylen == 0)\r\nreturn -3;\r\nmemcpy(key + 3, wlandev->wep_keys[keyidx], keylen);\r\nkeylen += 3;\r\n#ifdef WEP_DEBUG\r\nprintk(KERN_DEBUG\r\n"D %d: %02x %02x %02x (%d %d) %02x:%02x:%02x:%02x:%02x\n", len,\r\nkey[0], key[1], key[2], keyidx, keylen, key[3], key[4], key[5],\r\nkey[6], key[7]);\r\n#endif\r\nfor (i = 0; i < 256; i++)\r\ns[i] = i;\r\nj = 0;\r\nfor (i = 0; i < 256; i++) {\r\nj = (j + s[i] + key[i % keylen]) & 0xff;\r\nswap(i, j);\r\n}\r\ncrc = ~0;\r\ni = j = 0;\r\nfor (k = 0; k < len; k++) {\r\ni = (i + 1) & 0xff;\r\nj = (j + s[i]) & 0xff;\r\nswap(i, j);\r\nbuf[k] ^= s[(s[i] + s[j]) & 0xff];\r\ncrc = wep_crc32_table[(crc ^ buf[k]) & 0xff] ^ (crc >> 8);\r\n}\r\ncrc = ~crc;\r\nc_crc[0] = crc;\r\nc_crc[1] = crc >> 8;\r\nc_crc[2] = crc >> 16;\r\nc_crc[3] = crc >> 24;\r\nfor (k = 0; k < 4; k++) {\r\ni = (i + 1) & 0xff;\r\nj = (j + s[i]) & 0xff;\r\nswap(i, j);\r\nif ((c_crc[k] ^ s[(s[i] + s[j]) & 0xff]) != icv[k])\r\nreturn -(4 | (k << 4));\r\n}\r\nreturn 0;\r\n}\r\nint wep_encrypt(wlandevice_t *wlandev, u8 *buf, u8 *dst, u32 len, int keynum,\r\nu8 *iv, u8 *icv)\r\n{\r\nu32 i, j, k, crc, keylen;\r\nu8 s[256], key[64];\r\nif (len <= 0)\r\nreturn -1;\r\nif (keynum >= NUM_WEPKEYS)\r\nreturn -2;\r\nkeylen = wlandev->wep_keylens[keynum];\r\nif (keylen <= 0)\r\nreturn -3;\r\nget_random_bytes(iv, 3);\r\nwhile ((iv[1] == 0xff) && (iv[0] >= 3) && (iv[0] < keylen))\r\nget_random_bytes(iv, 3);\r\niv[3] = (keynum & 0x03) << 6;\r\nkey[0] = iv[0];\r\nkey[1] = iv[1];\r\nkey[2] = iv[2];\r\nmemcpy(key + 3, wlandev->wep_keys[keynum], keylen);\r\nkeylen += 3;\r\n#ifdef WEP_DEBUG\r\nprintk(KERN_DEBUG\r\n"E %d (%d/%d %d) %02x %02x %02x %02x:%02x:%02x:%02x:%02x\n", len,\r\niv[3], keynum, keylen, key[0], key[1], key[2], key[3], key[4],\r\nkey[5], key[6], key[7]);\r\n#endif\r\nfor (i = 0; i < 256; i++)\r\ns[i] = i;\r\nj = 0;\r\nfor (i = 0; i < 256; i++) {\r\nj = (j + s[i] + key[i % keylen]) & 0xff;\r\nswap(i, j);\r\n}\r\ncrc = ~0;\r\ni = j = 0;\r\nfor (k = 0; k < len; k++) {\r\ncrc = wep_crc32_table[(crc ^ buf[k]) & 0xff] ^ (crc >> 8);\r\ni = (i + 1) & 0xff;\r\nj = (j + s[i]) & 0xff;\r\nswap(i, j);\r\ndst[k] = buf[k] ^ s[(s[i] + s[j]) & 0xff];\r\n}\r\ncrc = ~crc;\r\nicv[0] = crc;\r\nicv[1] = crc >> 8;\r\nicv[2] = crc >> 16;\r\nicv[3] = crc >> 24;\r\nfor (k = 0; k < 4; k++) {\r\ni = (i + 1) & 0xff;\r\nj = (j + s[i]) & 0xff;\r\nswap(i, j);\r\nicv[k] ^= s[(s[i] + s[j]) & 0xff];\r\n}\r\nreturn 0;\r\n}
