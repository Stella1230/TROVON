static struct radio_isa_card *rtrack_alloc(void)\r\n{\r\nstruct rtrack *rt = kzalloc(sizeof(struct rtrack), GFP_KERNEL);\r\nif (rt)\r\nrt->curvol = 0xff;\r\nreturn rt ? &rt->isa : NULL;\r\n}\r\nstatic void send_0_byte(struct radio_isa_card *isa, int on)\r\n{\r\noutb_p(128+64+16+on+1, isa->io);\r\noutb_p(128+64+16+on+2+1, isa->io);\r\nmsleep(1);\r\n}\r\nstatic void send_1_byte(struct radio_isa_card *isa, int on)\r\n{\r\noutb_p(128+64+16+on+4+1, isa->io);\r\noutb_p(128+64+16+on+4+2+1, isa->io);\r\nmsleep(1);\r\n}\r\nstatic int rtrack_s_frequency(struct radio_isa_card *isa, u32 freq)\r\n{\r\nint on = v4l2_ctrl_g_ctrl(isa->mute) ? 0 : 8;\r\nint i;\r\nfreq += 171200;\r\nfreq /= 800;\r\nsend_0_byte(isa, on);\r\nfor (i = 0; i < 13; i++)\r\nif (freq & (1 << i))\r\nsend_1_byte(isa, on);\r\nelse\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_1_byte(isa, on);\r\nsend_0_byte(isa, on);\r\nsend_1_byte(isa, on);\r\noutb(0xd0 + on, isa->io);\r\nreturn 0;\r\n}\r\nstatic u32 rtrack_g_signal(struct radio_isa_card *isa)\r\n{\r\nreturn 0xffff * !(inb(isa->io) & 2);\r\n}\r\nstatic int rtrack_s_mute_volume(struct radio_isa_card *isa, bool mute, int vol)\r\n{\r\nstruct rtrack *rt = container_of(isa, struct rtrack, isa);\r\nint curvol = rt->curvol;\r\nif (mute) {\r\noutb(0xd0, isa->io);\r\nreturn 0;\r\n}\r\nif (vol == 0) {\r\noutb(0x48, isa->io);\r\nmsleep(curvol * 3);\r\n} else if (curvol < vol) {\r\noutb(0x98, isa->io);\r\nfor (; curvol < vol; curvol++)\r\nudelay(3000);\r\n} else if (curvol > vol) {\r\noutb(0x58, isa->io);\r\nfor (; curvol > vol; curvol--)\r\nudelay(3000);\r\n}\r\noutb(0xd8, isa->io);\r\nrt->curvol = vol;\r\nreturn 0;\r\n}\r\nstatic int rtrack_initialize(struct radio_isa_card *isa)\r\n{\r\noutb(0x90, isa->io);\r\nmsleep(3000);\r\noutb(0xc0, isa->io);\r\nreturn 0;\r\n}\r\nstatic int __init rtrack_init(void)\r\n{\r\nreturn isa_register_driver(&rtrack_driver.driver, RTRACK_MAX);\r\n}\r\nstatic void __exit rtrack_exit(void)\r\n{\r\nisa_unregister_driver(&rtrack_driver.driver);\r\n}
