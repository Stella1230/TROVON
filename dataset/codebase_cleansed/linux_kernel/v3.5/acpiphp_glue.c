static acpi_status\r\nis_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint *count = (int *)context;\r\nif (is_dock_device(handle)) {\r\n(*count)++;\r\nreturn AE_CTRL_TERMINATE;\r\n} else {\r\nreturn AE_OK;\r\n}\r\n}\r\nstatic int post_dock_fixups(struct notifier_block *nb, unsigned long val,\r\nvoid *v)\r\n{\r\nstruct acpiphp_func *func = container_of(nb, struct acpiphp_func, nb);\r\nstruct pci_bus *bus = func->slot->bridge->pci_bus;\r\nu32 buses;\r\nif (!bus->self)\r\nreturn NOTIFY_OK;\r\npci_read_config_dword(bus->self,\r\nPCI_PRIMARY_BUS,\r\n&buses);\r\nif (((buses >> 8) & 0xff) != bus->secondary) {\r\nbuses = (buses & 0xff000000)\r\n| ((unsigned int)(bus->primary) << 0)\r\n| ((unsigned int)(bus->secondary) << 8)\r\n| ((unsigned int)(bus->subordinate) << 16);\r\npci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic acpi_status\r\nregister_slot(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nstruct acpiphp_bridge *bridge = (struct acpiphp_bridge *)context;\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *newfunc;\r\nacpi_handle tmp;\r\nacpi_status status = AE_OK;\r\nunsigned long long adr, sun;\r\nint device, function, retval;\r\nstruct pci_bus *pbus = bridge->pci_bus;\r\nstruct pci_dev *pdev;\r\nif (!acpi_pci_check_ejectable(pbus, handle) && !is_dock_device(handle))\r\nreturn AE_OK;\r\npdev = pbus->self;\r\nif (pdev && pci_is_pcie(pdev)) {\r\ntmp = acpi_find_root_bridge_handle(pdev);\r\nif (tmp) {\r\nstruct acpi_pci_root *root = acpi_pci_find_root(tmp);\r\nif (root && (root->osc_control_set &\r\nOSC_PCI_EXPRESS_NATIVE_HP_CONTROL))\r\nreturn AE_OK;\r\n}\r\n}\r\nacpi_evaluate_integer(handle, "_ADR", NULL, &adr);\r\ndevice = (adr >> 16) & 0xffff;\r\nfunction = adr & 0xffff;\r\nnewfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);\r\nif (!newfunc)\r\nreturn AE_NO_MEMORY;\r\nINIT_LIST_HEAD(&newfunc->sibling);\r\nnewfunc->handle = handle;\r\nnewfunc->function = function;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))\r\nnewfunc->flags = FUNC_HAS_EJ0;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_STA;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_PS0;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_PS3;\r\nif (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))\r\nnewfunc->flags |= FUNC_HAS_DCK;\r\nstatus = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);\r\nif (ACPI_FAILURE(status)) {\r\nsun = bridge->nr_slots+1;\r\n}\r\nfor (slot = bridge->slots; slot; slot = slot->next)\r\nif (slot->device == device) {\r\nif (slot->sun != sun)\r\nwarn("sibling found, but _SUN doesn't match!\n");\r\nbreak;\r\n}\r\nif (!slot) {\r\nslot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);\r\nif (!slot) {\r\nkfree(newfunc);\r\nreturn AE_NO_MEMORY;\r\n}\r\nslot->bridge = bridge;\r\nslot->device = device;\r\nslot->sun = sun;\r\nINIT_LIST_HEAD(&slot->funcs);\r\nmutex_init(&slot->crit_sect);\r\nslot->next = bridge->slots;\r\nbridge->slots = slot;\r\nbridge->nr_slots++;\r\ndbg("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",\r\nslot->sun, pci_domain_nr(pbus), pbus->number, device);\r\nretval = acpiphp_register_hotplug_slot(slot);\r\nif (retval) {\r\nif (retval == -EBUSY)\r\nwarn("Slot %llu already registered by another "\r\n"hotplug driver\n", slot->sun);\r\nelse\r\nwarn("acpiphp_register_hotplug_slot failed "\r\n"(err code = 0x%x)\n", retval);\r\ngoto err_exit;\r\n}\r\n}\r\nnewfunc->slot = slot;\r\nlist_add_tail(&newfunc->sibling, &slot->funcs);\r\npdev = pci_get_slot(pbus, PCI_DEVFN(device, function));\r\nif (pdev) {\r\nslot->flags |= (SLOT_ENABLED | SLOT_POWEREDON);\r\npci_dev_put(pdev);\r\n}\r\nif (is_dock_device(handle)) {\r\nnewfunc->flags &= ~FUNC_HAS_EJ0;\r\nif (register_hotplug_dock_device(handle,\r\n&acpiphp_dock_ops, newfunc))\r\ndbg("failed to register dock device\n");\r\nnewfunc->nb.notifier_call = post_dock_fixups;\r\nif (register_dock_notifier(&newfunc->nb))\r\ndbg("failed to register a dock notifier");\r\n}\r\nif (!(newfunc->flags & FUNC_HAS_DCK)) {\r\nstatus = acpi_install_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func,\r\nnewfunc);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to register interrupt notify handler\n");\r\n} else\r\nstatus = AE_OK;\r\nreturn status;\r\nerr_exit:\r\nbridge->nr_slots--;\r\nbridge->slots = slot->next;\r\nkfree(slot);\r\nkfree(newfunc);\r\nreturn AE_OK;\r\n}\r\nstatic int detect_ejectable_slots(acpi_handle handle)\r\n{\r\nint found = acpi_pci_detect_ejectable(handle);\r\nif (!found) {\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nis_pci_dock_device, NULL, (void *)&found, NULL);\r\n}\r\nreturn found;\r\n}\r\nstatic void init_bridge_misc(struct acpiphp_bridge *bridge)\r\n{\r\nacpi_status status;\r\nlist_add(&bridge->list, &bridge_list);\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, (u32)1,\r\nregister_slot, NULL, bridge, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nlist_del(&bridge->list);\r\nreturn;\r\n}\r\nif (bridge->type != BRIDGE_TYPE_HOST) {\r\nif ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {\r\nstatus = acpi_remove_notify_handler(bridge->func->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to remove notify handler\n");\r\n}\r\nstatus = acpi_install_notify_handler(bridge->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_bridge,\r\nbridge);\r\nif (ACPI_FAILURE(status)) {\r\nerr("failed to register interrupt notify handler\n");\r\n}\r\n}\r\n}\r\nstatic struct acpiphp_func *acpiphp_bridge_handle_to_function(acpi_handle handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nstruct acpiphp_slot *slot;\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry(bridge, &bridge_list, list) {\r\nfor (slot = bridge->slots; slot; slot = slot->next) {\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->handle == handle)\r\nreturn func;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void config_p2p_bridge_flags(struct acpiphp_bridge *bridge)\r\n{\r\nacpi_handle dummy_handle;\r\nif (ACPI_SUCCESS(acpi_get_handle(bridge->handle,\r\n"_STA", &dummy_handle)))\r\nbridge->flags |= BRIDGE_HAS_STA;\r\nif (ACPI_SUCCESS(acpi_get_handle(bridge->handle,\r\n"_EJ0", &dummy_handle)))\r\nbridge->flags |= BRIDGE_HAS_EJ0;\r\nif (ACPI_SUCCESS(acpi_get_handle(bridge->handle,\r\n"_PS0", &dummy_handle)))\r\nbridge->flags |= BRIDGE_HAS_PS0;\r\nif (ACPI_SUCCESS(acpi_get_handle(bridge->handle,\r\n"_PS3", &dummy_handle)))\r\nbridge->flags |= BRIDGE_HAS_PS3;\r\nif (bridge->flags & BRIDGE_HAS_EJ0) {\r\nstruct acpiphp_func *func;\r\ndbg("found ejectable p2p bridge\n");\r\nfunc = acpiphp_bridge_handle_to_function(bridge->handle);\r\nif (!func)\r\nreturn;\r\nbridge->func = func;\r\nfunc->bridge = bridge;\r\n}\r\n}\r\nstatic void add_host_bridge(acpi_handle *handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nstruct acpi_pci_root *root = acpi_pci_find_root(handle);\r\nbridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);\r\nif (bridge == NULL)\r\nreturn;\r\nbridge->type = BRIDGE_TYPE_HOST;\r\nbridge->handle = handle;\r\nbridge->pci_bus = root->bus;\r\nspin_lock_init(&bridge->res_lock);\r\ninit_bridge_misc(bridge);\r\n}\r\nstatic void add_p2p_bridge(acpi_handle *handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nbridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);\r\nif (bridge == NULL) {\r\nerr("out of memory\n");\r\nreturn;\r\n}\r\nbridge->type = BRIDGE_TYPE_P2P;\r\nbridge->handle = handle;\r\nconfig_p2p_bridge_flags(bridge);\r\nbridge->pci_dev = acpi_get_pci_dev(handle);\r\nbridge->pci_bus = bridge->pci_dev->subordinate;\r\nif (!bridge->pci_bus) {\r\nerr("This is not a PCI-to-PCI bridge!\n");\r\ngoto err;\r\n}\r\nget_device(&bridge->pci_bus->dev);\r\nspin_lock_init(&bridge->res_lock);\r\ninit_bridge_misc(bridge);\r\nreturn;\r\nerr:\r\npci_dev_put(bridge->pci_dev);\r\nkfree(bridge);\r\nreturn;\r\n}\r\nstatic acpi_status\r\nfind_p2p_bridge(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nacpi_status status;\r\nstruct pci_dev *dev;\r\ndev = acpi_get_pci_dev(handle);\r\nif (!dev || !dev->subordinate)\r\ngoto out;\r\nif ((detect_ejectable_slots(handle) > 0)) {\r\ndbg("found PCI-to-PCI bridge at PCI %s\n", pci_name(dev));\r\nadd_p2p_bridge(handle);\r\n}\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nfind_p2p_bridge, NULL, NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nwarn("find_p2p_bridge failed (error code = 0x%x)\n", status);\r\nout:\r\npci_dev_put(dev);\r\nreturn AE_OK;\r\n}\r\nstatic int add_bridge(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nunsigned long long tmp;\r\nacpi_handle dummy_handle;\r\nstatus = acpi_get_handle(handle, "_STA", &dummy_handle);\r\nif (ACPI_SUCCESS(status)) {\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL, &tmp);\r\nif (ACPI_FAILURE(status)) {\r\ndbg("%s: _STA evaluation failure\n", __func__);\r\nreturn 0;\r\n}\r\nif ((tmp & ACPI_STA_FUNCTIONING) == 0)\r\nreturn 0;\r\n}\r\nif (detect_ejectable_slots(handle) > 0) {\r\ndbg("found PCI host-bus bridge with hot-pluggable slots\n");\r\nadd_host_bridge(handle);\r\n}\r\nstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\nfind_p2p_bridge, NULL, NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nwarn("find_p2p_bridge failed (error code = 0x%x)\n", status);\r\nreturn 0;\r\n}\r\nstatic struct acpiphp_bridge *acpiphp_handle_to_bridge(acpi_handle handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nlist_for_each_entry(bridge, &bridge_list, list)\r\nif (bridge->handle == handle)\r\nreturn bridge;\r\nreturn NULL;\r\n}\r\nstatic void cleanup_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nstruct acpiphp_slot *slot, *next;\r\nstruct acpiphp_func *func, *tmp;\r\nacpi_status status;\r\nacpi_handle handle = bridge->handle;\r\nstatus = acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_bridge);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to remove notify handler\n");\r\nif ((bridge->type != BRIDGE_TYPE_HOST) &&\r\n((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func)) {\r\nstatus = acpi_install_notify_handler(bridge->func->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func,\r\nbridge->func);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to install interrupt notify handler\n");\r\n}\r\nslot = bridge->slots;\r\nwhile (slot) {\r\nnext = slot->next;\r\nlist_for_each_entry_safe(func, tmp, &slot->funcs, sibling) {\r\nif (is_dock_device(func->handle)) {\r\nunregister_hotplug_dock_device(func->handle);\r\nunregister_dock_notifier(&func->nb);\r\n}\r\nif (!(func->flags & FUNC_HAS_DCK)) {\r\nstatus = acpi_remove_notify_handler(func->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_func);\r\nif (ACPI_FAILURE(status))\r\nerr("failed to remove notify handler\n");\r\n}\r\nlist_del(&func->sibling);\r\nkfree(func);\r\n}\r\nacpiphp_unregister_hotplug_slot(slot);\r\nlist_del(&slot->funcs);\r\nkfree(slot);\r\nslot = next;\r\n}\r\nif (bridge->pci_dev)\r\nput_device(&bridge->pci_bus->dev);\r\npci_dev_put(bridge->pci_dev);\r\nlist_del(&bridge->list);\r\nkfree(bridge);\r\n}\r\nstatic acpi_status\r\ncleanup_p2p_bridge(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,\r\ncleanup_p2p_bridge, NULL, NULL, NULL);\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (bridge)\r\ncleanup_bridge(bridge);\r\nreturn AE_OK;\r\n}\r\nstatic void remove_bridge(acpi_handle handle)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle,\r\n(u32)1, cleanup_p2p_bridge, NULL, NULL, NULL);\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (bridge)\r\ncleanup_bridge(bridge);\r\nelse\r\nacpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_bridge);\r\n}\r\nstatic int power_on_slot(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nstruct acpiphp_func *func;\r\nint retval = 0;\r\nif (slot->flags & SLOT_POWEREDON)\r\ngoto err_exit;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_PS0) {\r\ndbg("%s: executing _PS0\n", __func__);\r\nstatus = acpi_evaluate_object(func->handle, "_PS0", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("%s: _PS0 failed\n", __func__);\r\nretval = -1;\r\ngoto err_exit;\r\n} else\r\nbreak;\r\n}\r\n}\r\nslot->flags |= SLOT_POWEREDON;\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic int power_off_slot(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nstruct acpiphp_func *func;\r\nint retval = 0;\r\nif ((slot->flags & SLOT_POWEREDON) == 0)\r\ngoto err_exit;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_PS3) {\r\nstatus = acpi_evaluate_object(func->handle, "_PS3", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("%s: _PS3 failed\n", __func__);\r\nretval = -1;\r\ngoto err_exit;\r\n} else\r\nbreak;\r\n}\r\n}\r\nslot->flags &= (~SLOT_POWEREDON);\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic unsigned char acpiphp_max_busnr(struct pci_bus *bus)\r\n{\r\nstruct list_head *tmp;\r\nunsigned char max, n;\r\nmax = bus->secondary;\r\nlist_for_each(tmp, &bus->children) {\r\nn = pci_bus_max_busnr(pci_bus_b(tmp));\r\nif (n > max)\r\nmax = n;\r\n}\r\nreturn max;\r\n}\r\nstatic int acpiphp_bus_add(struct acpiphp_func *func)\r\n{\r\nacpi_handle phandle;\r\nstruct acpi_device *device, *pdevice;\r\nint ret_val;\r\nacpi_get_parent(func->handle, &phandle);\r\nif (acpi_bus_get_device(phandle, &pdevice)) {\r\ndbg("no parent device, assuming NULL\n");\r\npdevice = NULL;\r\n}\r\nif (!acpi_bus_get_device(func->handle, &device)) {\r\ndbg("bus exists... trim\n");\r\nret_val = acpi_bus_trim(device, 1);\r\ndbg("acpi_bus_trim return %x\n", ret_val);\r\n}\r\nret_val = acpi_bus_add(&device, pdevice, func->handle,\r\nACPI_BUS_TYPE_DEVICE);\r\nif (ret_val) {\r\ndbg("error adding bus, %x\n",\r\n-ret_val);\r\ngoto acpiphp_bus_add_out;\r\n}\r\nret_val = acpi_bus_start(device);\r\nacpiphp_bus_add_out:\r\nreturn ret_val;\r\n}\r\nstatic int acpiphp_bus_trim(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nint retval;\r\nretval = acpi_bus_get_device(handle, &device);\r\nif (retval) {\r\ndbg("acpi_device not found\n");\r\nreturn retval;\r\n}\r\nretval = acpi_bus_trim(device, 1);\r\nif (retval)\r\nerr("cannot remove from acpi list\n");\r\nreturn retval;\r\n}\r\nstatic void acpiphp_set_acpi_region(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nunion acpi_object params[2];\r\nstruct acpi_object_list arg_list;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\narg_list.count = 2;\r\narg_list.pointer = params;\r\nparams[0].type = ACPI_TYPE_INTEGER;\r\nparams[0].integer.value = ACPI_ADR_SPACE_PCI_CONFIG;\r\nparams[1].type = ACPI_TYPE_INTEGER;\r\nparams[1].integer.value = 1;\r\nacpi_evaluate_object(func->handle, "_REG", &arg_list, NULL);\r\n}\r\n}\r\nstatic int __ref enable_device(struct acpiphp_slot *slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *bus = slot->bridge->pci_bus;\r\nstruct acpiphp_func *func;\r\nint retval = 0;\r\nint num, max, pass;\r\nacpi_status status;\r\nif (slot->flags & SLOT_ENABLED)\r\ngoto err_exit;\r\nnum = pci_scan_slot(bus, PCI_DEVFN(slot->device, 0));\r\nif (num == 0) {\r\ndbg("No new device found\n");\r\ngoto err_exit;\r\n}\r\nmax = acpiphp_max_busnr(bus);\r\nfor (pass = 0; pass < 2; pass++) {\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (PCI_SLOT(dev->devfn) != slot->device)\r\ncontinue;\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||\r\ndev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {\r\nmax = pci_scan_bridge(bus, dev, max, pass);\r\nif (pass && dev->subordinate)\r\npci_bus_size_bridges(dev->subordinate);\r\n}\r\n}\r\n}\r\nlist_for_each_entry(func, &slot->funcs, sibling)\r\nacpiphp_bus_add(func);\r\npci_bus_assign_resources(bus);\r\nacpiphp_sanitize_bus(bus);\r\nacpiphp_set_hpp_values(bus);\r\nacpiphp_set_acpi_region(slot);\r\npci_enable_bridges(bus);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (!dev->is_added)\r\ndev->current_state = PCI_D0;\r\n}\r\npci_bus_add_devices(bus);\r\nslot->flags |= SLOT_ENABLED;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\ndev = pci_get_slot(bus, PCI_DEVFN(slot->device,\r\nfunc->function));\r\nif (!dev) {\r\nslot->flags &= (~SLOT_ENABLED);\r\ncontinue;\r\n}\r\nif (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE &&\r\ndev->hdr_type != PCI_HEADER_TYPE_CARDBUS) {\r\npci_dev_put(dev);\r\ncontinue;\r\n}\r\nstatus = find_p2p_bridge(func->handle, (u32)1, bus, NULL);\r\nif (ACPI_FAILURE(status))\r\nwarn("find_p2p_bridge failed (error code = 0x%x)\n",\r\nstatus);\r\npci_dev_put(dev);\r\n}\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic void disable_bridges(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (dev->subordinate) {\r\ndisable_bridges(dev->subordinate);\r\npci_disable_device(dev);\r\n}\r\n}\r\n}\r\nstatic int disable_device(struct acpiphp_slot *slot)\r\n{\r\nstruct acpiphp_func *func;\r\nstruct pci_dev *pdev;\r\nstruct pci_bus *bus = slot->bridge->pci_bus;\r\npdev = pci_get_slot(bus, PCI_DEVFN(slot->device, 0));\r\nif (!pdev)\r\ngoto err_exit;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->bridge) {\r\ncleanup_p2p_bridge(func->bridge->handle,\r\n(u32)1, NULL, NULL);\r\nfunc->bridge = NULL;\r\n}\r\npdev = pci_get_slot(slot->bridge->pci_bus,\r\nPCI_DEVFN(slot->device, func->function));\r\nif (pdev) {\r\npci_stop_bus_device(pdev);\r\nif (pdev->subordinate) {\r\ndisable_bridges(pdev->subordinate);\r\npci_disable_device(pdev);\r\n}\r\n__pci_remove_bus_device(pdev);\r\npci_dev_put(pdev);\r\n}\r\n}\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nacpiphp_bus_trim(func->handle);\r\n}\r\nslot->flags &= (~SLOT_ENABLED);\r\nerr_exit:\r\nreturn 0;\r\n}\r\nstatic unsigned int get_slot_status(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nunsigned long long sta = 0;\r\nu32 dvid;\r\nstruct acpiphp_func *func;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif (func->flags & FUNC_HAS_STA) {\r\nstatus = acpi_evaluate_integer(func->handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && sta)\r\nbreak;\r\n} else {\r\npci_bus_read_config_dword(slot->bridge->pci_bus,\r\nPCI_DEVFN(slot->device,\r\nfunc->function),\r\nPCI_VENDOR_ID, &dvid);\r\nif (dvid != 0xffffffff) {\r\nsta = ACPI_STA_ALL;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn (unsigned int)sta;\r\n}\r\nint acpiphp_eject_slot(struct acpiphp_slot *slot)\r\n{\r\nacpi_status status;\r\nstruct acpiphp_func *func;\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nlist_for_each_entry(func, &slot->funcs, sibling) {\r\nif ((func->flags & FUNC_HAS_EJ0)) {\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = 1;\r\nstatus = acpi_evaluate_object(func->handle, "_EJ0", &arg_list, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nwarn("%s: _EJ0 failed\n", __func__);\r\nreturn -1;\r\n} else\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpiphp_check_bridge(struct acpiphp_bridge *bridge)\r\n{\r\nstruct acpiphp_slot *slot;\r\nint retval = 0;\r\nint enabled, disabled;\r\nenabled = disabled = 0;\r\nfor (slot = bridge->slots; slot; slot = slot->next) {\r\nunsigned int status = get_slot_status(slot);\r\nif (slot->flags & SLOT_ENABLED) {\r\nif (status == ACPI_STA_ALL)\r\ncontinue;\r\nretval = acpiphp_disable_slot(slot);\r\nif (retval) {\r\nerr("Error occurred in disabling\n");\r\ngoto err_exit;\r\n} else {\r\nacpiphp_eject_slot(slot);\r\n}\r\ndisabled++;\r\n} else {\r\nif (status != ACPI_STA_ALL)\r\ncontinue;\r\nretval = acpiphp_enable_slot(slot);\r\nif (retval) {\r\nerr("Error occurred in enabling\n");\r\ngoto err_exit;\r\n}\r\nenabled++;\r\n}\r\n}\r\ndbg("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);\r\nerr_exit:\r\nreturn retval;\r\n}\r\nstatic void acpiphp_set_hpp_values(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\npci_configure_slot(dev);\r\n}\r\nstatic void acpiphp_sanitize_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nint i;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nfor (i=0; i<PCI_BRIDGE_RESOURCES; i++) {\r\nstruct resource *res = &dev->resource[i];\r\nif ((res->flags & type_mask) && !res->start &&\r\nres->end) {\r\npci_stop_and_remove_bus_device(dev);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int acpiphp_configure_bridge (acpi_handle handle)\r\n{\r\nstruct pci_bus *bus;\r\nif (acpi_is_root_bridge(handle)) {\r\nstruct acpi_pci_root *root = acpi_pci_find_root(handle);\r\nbus = root->bus;\r\n} else {\r\nstruct pci_dev *pdev = acpi_get_pci_dev(handle);\r\nbus = pdev->subordinate;\r\npci_dev_put(pdev);\r\n}\r\npci_bus_size_bridges(bus);\r\npci_bus_assign_resources(bus);\r\nacpiphp_sanitize_bus(bus);\r\nacpiphp_set_hpp_values(bus);\r\npci_enable_bridges(bus);\r\nreturn 0;\r\n}\r\nstatic void handle_bridge_insertion(acpi_handle handle, u32 type)\r\n{\r\nstruct acpi_device *device, *pdevice;\r\nacpi_handle phandle;\r\nif ((type != ACPI_NOTIFY_BUS_CHECK) &&\r\n(type != ACPI_NOTIFY_DEVICE_CHECK)) {\r\nerr("unexpected notification type %d\n", type);\r\nreturn;\r\n}\r\nacpi_get_parent(handle, &phandle);\r\nif (acpi_bus_get_device(phandle, &pdevice)) {\r\ndbg("no parent device, assuming NULL\n");\r\npdevice = NULL;\r\n}\r\nif (acpi_bus_add(&device, pdevice, handle, ACPI_BUS_TYPE_DEVICE)) {\r\nerr("cannot add bridge to acpi list\n");\r\nreturn;\r\n}\r\nif (!acpiphp_configure_bridge(handle) &&\r\n!acpi_bus_start(device))\r\nadd_bridge(handle);\r\nelse\r\nerr("cannot configure and start bridge\n");\r\n}\r\nstatic acpi_status\r\ncount_sub_bridges(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint *count = (int *)context;\r\nstruct acpiphp_bridge *bridge;\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (bridge)\r\n(*count)++;\r\nreturn AE_OK ;\r\n}\r\nstatic acpi_status\r\ncheck_sub_bridges(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nchar objname[64];\r\nstruct acpi_buffer buffer = { .length = sizeof(objname),\r\n.pointer = objname };\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (bridge) {\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\ndbg("%s: re-enumerating slots under %s\n",\r\n__func__, objname);\r\nacpiphp_check_bridge(bridge);\r\n}\r\nreturn AE_OK ;\r\n}\r\nstatic void alloc_acpiphp_hp_work(acpi_handle handle, u32 type,\r\nvoid *context,\r\nvoid (*func)(struct work_struct *work))\r\n{\r\nstruct acpiphp_hp_work *hp_work;\r\nint ret;\r\nhp_work = kmalloc(sizeof(*hp_work), GFP_KERNEL);\r\nif (!hp_work)\r\nreturn;\r\nhp_work->handle = handle;\r\nhp_work->type = type;\r\nhp_work->context = context;\r\nINIT_WORK(&hp_work->work, func);\r\nret = queue_work(kacpi_hotplug_wq, &hp_work->work);\r\nif (!ret)\r\nkfree(hp_work);\r\n}\r\nstatic void _handle_hotplug_event_bridge(struct work_struct *work)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nchar objname[64];\r\nstruct acpi_buffer buffer = { .length = sizeof(objname),\r\n.pointer = objname };\r\nstruct acpi_device *device;\r\nint num_sub_bridges = 0;\r\nstruct acpiphp_hp_work *hp_work;\r\nacpi_handle handle;\r\nu32 type;\r\nhp_work = container_of(work, struct acpiphp_hp_work, work);\r\nhandle = hp_work->handle;\r\ntype = hp_work->type;\r\nif (acpi_bus_get_device(handle, &device)) {\r\nhandle_bridge_insertion(handle, type);\r\ngoto out;\r\n}\r\nbridge = acpiphp_handle_to_bridge(handle);\r\nif (type == ACPI_NOTIFY_BUS_CHECK) {\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, ACPI_UINT32_MAX,\r\ncount_sub_bridges, NULL, &num_sub_bridges, NULL);\r\n}\r\nif (!bridge && !num_sub_bridges) {\r\nerr("cannot get bridge info\n");\r\ngoto out;\r\n}\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\nswitch (type) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ndbg("%s: Bus check notify on %s\n", __func__, objname);\r\nif (bridge) {\r\ndbg("%s: re-enumerating slots under %s\n",\r\n__func__, objname);\r\nacpiphp_check_bridge(bridge);\r\n}\r\nif (num_sub_bridges)\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle,\r\nACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\ndbg("%s: Device check notify on %s\n", __func__, objname);\r\nacpiphp_check_bridge(bridge);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_WAKE:\r\ndbg("%s: Device wake notify on %s\n", __func__, objname);\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\ndbg("%s: Device eject notify on %s\n", __func__, objname);\r\nif ((bridge->type != BRIDGE_TYPE_HOST) &&\r\n(bridge->flags & BRIDGE_HAS_EJ0)) {\r\nstruct acpiphp_slot *slot;\r\nslot = bridge->func->slot;\r\nif (!acpiphp_disable_slot(slot))\r\nacpiphp_eject_slot(slot);\r\n}\r\nbreak;\r\ncase ACPI_NOTIFY_FREQUENCY_MISMATCH:\r\nprintk(KERN_ERR "Device %s cannot be configured due"\r\n" to a frequency mismatch\n", objname);\r\nbreak;\r\ncase ACPI_NOTIFY_BUS_MODE_MISMATCH:\r\nprintk(KERN_ERR "Device %s cannot be configured due"\r\n" to a bus mode mismatch\n", objname);\r\nbreak;\r\ncase ACPI_NOTIFY_POWER_FAULT:\r\nprintk(KERN_ERR "Device %s has suffered a power fault\n",\r\nobjname);\r\nbreak;\r\ndefault:\r\nwarn("notify_handler: unknown event type 0x%x for %s\n", type, objname);\r\nbreak;\r\n}\r\nout:\r\nkfree(hp_work);\r\n}\r\nstatic void handle_hotplug_event_bridge(acpi_handle handle, u32 type,\r\nvoid *context)\r\n{\r\nalloc_acpiphp_hp_work(handle, type, context,\r\n_handle_hotplug_event_bridge);\r\n}\r\nstatic void _handle_hotplug_event_func(struct work_struct *work)\r\n{\r\nstruct acpiphp_func *func;\r\nchar objname[64];\r\nstruct acpi_buffer buffer = { .length = sizeof(objname),\r\n.pointer = objname };\r\nstruct acpiphp_hp_work *hp_work;\r\nacpi_handle handle;\r\nu32 type;\r\nvoid *context;\r\nhp_work = container_of(work, struct acpiphp_hp_work, work);\r\nhandle = hp_work->handle;\r\ntype = hp_work->type;\r\ncontext = hp_work->context;\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\nfunc = (struct acpiphp_func *)context;\r\nswitch (type) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ndbg("%s: Bus check notify on %s\n", __func__, objname);\r\nacpiphp_enable_slot(func->slot);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\ndbg("%s: Device check notify on %s\n", __func__, objname);\r\nacpiphp_check_bridge(func->slot->bridge);\r\nbreak;\r\ncase ACPI_NOTIFY_DEVICE_WAKE:\r\ndbg("%s: Device wake notify on %s\n", __func__, objname);\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\ndbg("%s: Device eject notify on %s\n", __func__, objname);\r\nif (!(acpiphp_disable_slot(func->slot)))\r\nacpiphp_eject_slot(func->slot);\r\nbreak;\r\ndefault:\r\nwarn("notify_handler: unknown event type 0x%x for %s\n", type, objname);\r\nbreak;\r\n}\r\nkfree(hp_work);\r\n}\r\nstatic void handle_hotplug_event_func(acpi_handle handle, u32 type,\r\nvoid *context)\r\n{\r\nalloc_acpiphp_hp_work(handle, type, context,\r\n_handle_hotplug_event_func);\r\n}\r\nstatic acpi_status\r\nfind_root_bridges(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint *count = (int *)context;\r\nif (!acpi_is_root_bridge(handle))\r\nreturn AE_OK;\r\n(*count)++;\r\nacpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,\r\nhandle_hotplug_event_bridge, NULL);\r\nreturn AE_OK ;\r\n}\r\nint __init acpiphp_glue_init(void)\r\n{\r\nint num = 0;\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, find_root_bridges, NULL, &num, NULL);\r\nif (num <= 0)\r\nreturn -1;\r\nelse\r\nacpi_pci_register_driver(&acpi_pci_hp_driver);\r\nreturn 0;\r\n}\r\nvoid acpiphp_glue_exit(void)\r\n{\r\nacpi_pci_unregister_driver(&acpi_pci_hp_driver);\r\n}\r\nint __init acpiphp_get_num_slots(void)\r\n{\r\nstruct acpiphp_bridge *bridge;\r\nint num_slots = 0;\r\nlist_for_each_entry(bridge, &bridge_list, list) {\r\ndbg("Bus %04x:%02x has %d slot%s\n",\r\npci_domain_nr(bridge->pci_bus),\r\nbridge->pci_bus->number, bridge->nr_slots,\r\nbridge->nr_slots == 1 ? "" : "s");\r\nnum_slots += bridge->nr_slots;\r\n}\r\ndbg("Total %d slots\n", num_slots);\r\nreturn num_slots;\r\n}\r\nint acpiphp_enable_slot(struct acpiphp_slot *slot)\r\n{\r\nint retval;\r\nmutex_lock(&slot->crit_sect);\r\nretval = power_on_slot(slot);\r\nif (retval)\r\ngoto err_exit;\r\nif (get_slot_status(slot) == ACPI_STA_ALL) {\r\nretval = enable_device(slot);\r\nif (retval)\r\npower_off_slot(slot);\r\n} else {\r\ndbg("%s: Slot status is not ACPI_STA_ALL\n", __func__);\r\npower_off_slot(slot);\r\n}\r\nerr_exit:\r\nmutex_unlock(&slot->crit_sect);\r\nreturn retval;\r\n}\r\nint acpiphp_disable_slot(struct acpiphp_slot *slot)\r\n{\r\nint retval = 0;\r\nmutex_lock(&slot->crit_sect);\r\nretval = disable_device(slot);\r\nif (retval)\r\ngoto err_exit;\r\nretval = power_off_slot(slot);\r\nif (retval)\r\ngoto err_exit;\r\nerr_exit:\r\nmutex_unlock(&slot->crit_sect);\r\nreturn retval;\r\n}\r\nu8 acpiphp_get_power_status(struct acpiphp_slot *slot)\r\n{\r\nreturn (slot->flags & SLOT_POWEREDON);\r\n}\r\nu8 acpiphp_get_latch_status(struct acpiphp_slot *slot)\r\n{\r\nunsigned int sta;\r\nsta = get_slot_status(slot);\r\nreturn (sta & ACPI_STA_SHOW_IN_UI) ? 0 : 1;\r\n}\r\nu8 acpiphp_get_adapter_status(struct acpiphp_slot *slot)\r\n{\r\nunsigned int sta;\r\nsta = get_slot_status(slot);\r\nreturn (sta == 0) ? 0 : 1;\r\n}
