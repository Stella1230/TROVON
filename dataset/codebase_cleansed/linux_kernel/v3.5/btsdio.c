static int btsdio_tx_packet(struct btsdio_data *data, struct sk_buff *skb)\r\n{\r\nint err;\r\nBT_DBG("%s", data->hdev->name);\r\nskb_push(skb, 4);\r\nskb->data[0] = (skb->len & 0x0000ff);\r\nskb->data[1] = (skb->len & 0x00ff00) >> 8;\r\nskb->data[2] = (skb->len & 0xff0000) >> 16;\r\nskb->data[3] = bt_cb(skb)->pkt_type;\r\nerr = sdio_writesb(data->func, REG_TDAT, skb->data, skb->len);\r\nif (err < 0) {\r\nskb_pull(skb, 4);\r\nsdio_writeb(data->func, 0x01, REG_PC_WRT, NULL);\r\nreturn err;\r\n}\r\ndata->hdev->stat.byte_tx += skb->len;\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void btsdio_work(struct work_struct *work)\r\n{\r\nstruct btsdio_data *data = container_of(work, struct btsdio_data, work);\r\nstruct sk_buff *skb;\r\nint err;\r\nBT_DBG("%s", data->hdev->name);\r\nsdio_claim_host(data->func);\r\nwhile ((skb = skb_dequeue(&data->txq))) {\r\nerr = btsdio_tx_packet(data, skb);\r\nif (err < 0) {\r\ndata->hdev->stat.err_tx++;\r\nskb_queue_head(&data->txq, skb);\r\nbreak;\r\n}\r\n}\r\nsdio_release_host(data->func);\r\n}\r\nstatic int btsdio_rx_packet(struct btsdio_data *data)\r\n{\r\nu8 hdr[4] __attribute__ ((aligned(4)));\r\nstruct sk_buff *skb;\r\nint err, len;\r\nBT_DBG("%s", data->hdev->name);\r\nerr = sdio_readsb(data->func, hdr, REG_RDAT, 4);\r\nif (err < 0)\r\nreturn err;\r\nlen = hdr[0] | (hdr[1] << 8) | (hdr[2] << 16);\r\nif (len < 4 || len > 65543)\r\nreturn -EILSEQ;\r\nskb = bt_skb_alloc(len - 4, GFP_KERNEL);\r\nif (!skb) {\r\nreturn -ENOMEM;\r\n}\r\nskb_put(skb, len - 4);\r\nerr = sdio_readsb(data->func, skb->data, REG_RDAT, len - 4);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\ndata->hdev->stat.byte_rx += len;\r\nskb->dev = (void *) data->hdev;\r\nbt_cb(skb)->pkt_type = hdr[3];\r\nerr = hci_recv_frame(skb);\r\nif (err < 0)\r\nreturn err;\r\nsdio_writeb(data->func, 0x00, REG_PC_RRT, NULL);\r\nreturn 0;\r\n}\r\nstatic void btsdio_interrupt(struct sdio_func *func)\r\n{\r\nstruct btsdio_data *data = sdio_get_drvdata(func);\r\nint intrd;\r\nBT_DBG("%s", data->hdev->name);\r\nintrd = sdio_readb(func, REG_INTRD, NULL);\r\nif (intrd & 0x01) {\r\nsdio_writeb(func, 0x01, REG_CL_INTRD, NULL);\r\nif (btsdio_rx_packet(data) < 0) {\r\ndata->hdev->stat.err_rx++;\r\nsdio_writeb(data->func, 0x01, REG_PC_RRT, NULL);\r\n}\r\n}\r\n}\r\nstatic int btsdio_open(struct hci_dev *hdev)\r\n{\r\nstruct btsdio_data *data = hci_get_drvdata(hdev);\r\nint err;\r\nBT_DBG("%s", hdev->name);\r\nif (test_and_set_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nsdio_claim_host(data->func);\r\nerr = sdio_enable_func(data->func);\r\nif (err < 0) {\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\ngoto release;\r\n}\r\nerr = sdio_claim_irq(data->func, btsdio_interrupt);\r\nif (err < 0) {\r\nsdio_disable_func(data->func);\r\nclear_bit(HCI_RUNNING, &hdev->flags);\r\ngoto release;\r\n}\r\nif (data->func->class == SDIO_CLASS_BT_B)\r\nsdio_writeb(data->func, 0x00, REG_MD_STAT, NULL);\r\nsdio_writeb(data->func, 0x01, REG_EN_INTRD, NULL);\r\nrelease:\r\nsdio_release_host(data->func);\r\nreturn err;\r\n}\r\nstatic int btsdio_close(struct hci_dev *hdev)\r\n{\r\nstruct btsdio_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nif (!test_and_clear_bit(HCI_RUNNING, &hdev->flags))\r\nreturn 0;\r\nsdio_claim_host(data->func);\r\nsdio_writeb(data->func, 0x00, REG_EN_INTRD, NULL);\r\nsdio_release_irq(data->func);\r\nsdio_disable_func(data->func);\r\nsdio_release_host(data->func);\r\nreturn 0;\r\n}\r\nstatic int btsdio_flush(struct hci_dev *hdev)\r\n{\r\nstruct btsdio_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nskb_queue_purge(&data->txq);\r\nreturn 0;\r\n}\r\nstatic int btsdio_send_frame(struct sk_buff *skb)\r\n{\r\nstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\r\nstruct btsdio_data *data = hci_get_drvdata(hdev);\r\nBT_DBG("%s", hdev->name);\r\nif (!test_bit(HCI_RUNNING, &hdev->flags))\r\nreturn -EBUSY;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\ndefault:\r\nreturn -EILSEQ;\r\n}\r\nskb_queue_tail(&data->txq, skb);\r\nschedule_work(&data->work);\r\nreturn 0;\r\n}\r\nstatic int btsdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nstruct btsdio_data *data;\r\nstruct hci_dev *hdev;\r\nstruct sdio_func_tuple *tuple = func->tuples;\r\nint err;\r\nBT_DBG("func %p id %p class 0x%04x", func, id, func->class);\r\nwhile (tuple) {\r\nBT_DBG("code 0x%x size %d", tuple->code, tuple->size);\r\ntuple = tuple->next;\r\n}\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->func = func;\r\nINIT_WORK(&data->work, btsdio_work);\r\nskb_queue_head_init(&data->txq);\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\nhdev->bus = HCI_SDIO;\r\nhci_set_drvdata(hdev, data);\r\nif (id->class == SDIO_CLASS_BT_AMP)\r\nhdev->dev_type = HCI_AMP;\r\nelse\r\nhdev->dev_type = HCI_BREDR;\r\ndata->hdev = hdev;\r\nSET_HCIDEV_DEV(hdev, &func->dev);\r\nhdev->open = btsdio_open;\r\nhdev->close = btsdio_close;\r\nhdev->flush = btsdio_flush;\r\nhdev->send = btsdio_send_frame;\r\nerr = hci_register_dev(hdev);\r\nif (err < 0) {\r\nhci_free_dev(hdev);\r\nkfree(data);\r\nreturn err;\r\n}\r\nsdio_set_drvdata(func, data);\r\nreturn 0;\r\n}\r\nstatic void btsdio_remove(struct sdio_func *func)\r\n{\r\nstruct btsdio_data *data = sdio_get_drvdata(func);\r\nstruct hci_dev *hdev;\r\nBT_DBG("func %p", func);\r\nif (!data)\r\nreturn;\r\nhdev = data->hdev;\r\nsdio_set_drvdata(func, NULL);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nkfree(data);\r\n}\r\nstatic int __init btsdio_init(void)\r\n{\r\nBT_INFO("Generic Bluetooth SDIO driver ver %s", VERSION);\r\nreturn sdio_register_driver(&btsdio_driver);\r\n}\r\nstatic void __exit btsdio_exit(void)\r\n{\r\nsdio_unregister_driver(&btsdio_driver);\r\n}
