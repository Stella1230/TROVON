static int hfs_get_last_session(struct super_block *sb,\r\nsector_t *start, sector_t *size)\r\n{\r\nstruct cdrom_multisession ms_info;\r\nstruct cdrom_tocentry te;\r\nint res;\r\n*start = 0;\r\n*size = sb->s_bdev->bd_inode->i_size >> 9;\r\nif (HFS_SB(sb)->session >= 0) {\r\nte.cdte_track = HFS_SB(sb)->session;\r\nte.cdte_format = CDROM_LBA;\r\nres = ioctl_by_bdev(sb->s_bdev, CDROMREADTOCENTRY, (unsigned long)&te);\r\nif (!res && (te.cdte_ctrl & CDROM_DATA_TRACK) == 4) {\r\n*start = (sector_t)te.cdte_addr.lba << 2;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "hfs: invalid session number or type of track\n");\r\nreturn -EINVAL;\r\n}\r\nms_info.addr_format = CDROM_LBA;\r\nres = ioctl_by_bdev(sb->s_bdev, CDROMMULTISESSION, (unsigned long)&ms_info);\r\nif (!res && ms_info.xa_flag)\r\n*start = (sector_t)ms_info.addr.lba << 2;\r\nreturn 0;\r\n}\r\nint hfs_mdb_get(struct super_block *sb)\r\n{\r\nstruct buffer_head *bh;\r\nstruct hfs_mdb *mdb, *mdb2;\r\nunsigned int block;\r\nchar *ptr;\r\nint off2, len, size, sect;\r\nsector_t part_start, part_size;\r\nloff_t off;\r\n__be16 attrib;\r\nsize = sb_min_blocksize(sb, HFS_SECTOR_SIZE);\r\nif (!size)\r\nreturn -EINVAL;\r\nif (hfs_get_last_session(sb, &part_start, &part_size))\r\nreturn -EINVAL;\r\nwhile (1) {\r\nbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\r\nif (!bh)\r\ngoto out;\r\nif (mdb->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC))\r\nbreak;\r\nbrelse(bh);\r\nif (hfs_part_find(sb, &part_start, &part_size))\r\ngoto out;\r\n}\r\nHFS_SB(sb)->alloc_blksz = size = be32_to_cpu(mdb->drAlBlkSiz);\r\nif (!size || (size & (HFS_SECTOR_SIZE - 1))) {\r\nprintk(KERN_ERR "hfs: bad allocation block size %d\n", size);\r\ngoto out_bh;\r\n}\r\nsize = min(HFS_SB(sb)->alloc_blksz, (u32)PAGE_SIZE);\r\nwhile (size & (size - 1))\r\nsize -= HFS_SECTOR_SIZE;\r\nsect = be16_to_cpu(mdb->drAlBlSt) + part_start;\r\nwhile (sect & ((size - 1) >> HFS_SECTOR_SIZE_BITS))\r\nsize >>= 1;\r\nwhile (HFS_SB(sb)->alloc_blksz & (size - 1))\r\nsize >>= 1;\r\nbrelse(bh);\r\nif (!sb_set_blocksize(sb, size)) {\r\nprintk(KERN_ERR "hfs: unable to set blocksize to %u\n", size);\r\ngoto out;\r\n}\r\nbh = sb_bread512(sb, part_start + HFS_MDB_BLK, mdb);\r\nif (!bh)\r\ngoto out;\r\nif (mdb->drSigWord != cpu_to_be16(HFS_SUPER_MAGIC))\r\ngoto out_bh;\r\nHFS_SB(sb)->mdb_bh = bh;\r\nHFS_SB(sb)->mdb = mdb;\r\nHFS_SB(sb)->part_start = part_start;\r\nHFS_SB(sb)->fs_ablocks = be16_to_cpu(mdb->drNmAlBlks);\r\nHFS_SB(sb)->fs_div = HFS_SB(sb)->alloc_blksz >> sb->s_blocksize_bits;\r\nHFS_SB(sb)->clumpablks = be32_to_cpu(mdb->drClpSiz) /\r\nHFS_SB(sb)->alloc_blksz;\r\nif (!HFS_SB(sb)->clumpablks)\r\nHFS_SB(sb)->clumpablks = 1;\r\nHFS_SB(sb)->fs_start = (be16_to_cpu(mdb->drAlBlSt) + part_start) >>\r\n(sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS);\r\nHFS_SB(sb)->free_ablocks = be16_to_cpu(mdb->drFreeBks);\r\nHFS_SB(sb)->next_id = be32_to_cpu(mdb->drNxtCNID);\r\nHFS_SB(sb)->root_files = be16_to_cpu(mdb->drNmFls);\r\nHFS_SB(sb)->root_dirs = be16_to_cpu(mdb->drNmRtDirs);\r\nHFS_SB(sb)->file_count = be32_to_cpu(mdb->drFilCnt);\r\nHFS_SB(sb)->folder_count = be32_to_cpu(mdb->drDirCnt);\r\nsect = part_start + part_size - 2;\r\nbh = sb_bread512(sb, sect, mdb2);\r\nif (bh) {\r\nif (mdb2->drSigWord == cpu_to_be16(HFS_SUPER_MAGIC)) {\r\nHFS_SB(sb)->alt_mdb_bh = bh;\r\nHFS_SB(sb)->alt_mdb = mdb2;\r\n} else\r\nbrelse(bh);\r\n}\r\nif (!HFS_SB(sb)->alt_mdb) {\r\nprintk(KERN_WARNING "hfs: unable to locate alternate MDB\n");\r\nprintk(KERN_WARNING "hfs: continuing without an alternate MDB\n");\r\n}\r\nHFS_SB(sb)->bitmap = (__be32 *)__get_free_pages(GFP_KERNEL, PAGE_SIZE < 8192 ? 1 : 0);\r\nif (!HFS_SB(sb)->bitmap)\r\ngoto out;\r\nblock = be16_to_cpu(mdb->drVBMSt) + part_start;\r\noff = (loff_t)block << HFS_SECTOR_SIZE_BITS;\r\nsize = (HFS_SB(sb)->fs_ablocks + 8) / 8;\r\nptr = (u8 *)HFS_SB(sb)->bitmap;\r\nwhile (size) {\r\nbh = sb_bread(sb, off >> sb->s_blocksize_bits);\r\nif (!bh) {\r\nprintk(KERN_ERR "hfs: unable to read volume bitmap\n");\r\ngoto out;\r\n}\r\noff2 = off & (sb->s_blocksize - 1);\r\nlen = min((int)sb->s_blocksize - off2, size);\r\nmemcpy(ptr, bh->b_data + off2, len);\r\nbrelse(bh);\r\nptr += len;\r\noff += len;\r\nsize -= len;\r\n}\r\nHFS_SB(sb)->ext_tree = hfs_btree_open(sb, HFS_EXT_CNID, hfs_ext_keycmp);\r\nif (!HFS_SB(sb)->ext_tree) {\r\nprintk(KERN_ERR "hfs: unable to open extent tree\n");\r\ngoto out;\r\n}\r\nHFS_SB(sb)->cat_tree = hfs_btree_open(sb, HFS_CAT_CNID, hfs_cat_keycmp);\r\nif (!HFS_SB(sb)->cat_tree) {\r\nprintk(KERN_ERR "hfs: unable to open catalog tree\n");\r\ngoto out;\r\n}\r\nattrib = mdb->drAtrb;\r\nif (!(attrib & cpu_to_be16(HFS_SB_ATTRIB_UNMNT))) {\r\nprintk(KERN_WARNING "hfs: filesystem was not cleanly unmounted, "\r\n"running fsck.hfs is recommended. mounting read-only.\n");\r\nsb->s_flags |= MS_RDONLY;\r\n}\r\nif ((attrib & cpu_to_be16(HFS_SB_ATTRIB_SLOCK))) {\r\nprintk(KERN_WARNING "hfs: filesystem is marked locked, mounting read-only.\n");\r\nsb->s_flags |= MS_RDONLY;\r\n}\r\nif (!(sb->s_flags & MS_RDONLY)) {\r\nattrib &= cpu_to_be16(~HFS_SB_ATTRIB_UNMNT);\r\nattrib |= cpu_to_be16(HFS_SB_ATTRIB_INCNSTNT);\r\nmdb->drAtrb = attrib;\r\nbe32_add_cpu(&mdb->drWrCnt, 1);\r\nmdb->drLsMod = hfs_mtime();\r\nmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\r\nsync_dirty_buffer(HFS_SB(sb)->mdb_bh);\r\n}\r\nreturn 0;\r\nout_bh:\r\nbrelse(bh);\r\nout:\r\nhfs_mdb_put(sb);\r\nreturn -EIO;\r\n}\r\nvoid hfs_mdb_commit(struct super_block *sb)\r\n{\r\nstruct hfs_mdb *mdb = HFS_SB(sb)->mdb;\r\nif (test_and_clear_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags)) {\r\nmdb->drLsMod = hfs_mtime();\r\nmdb->drFreeBks = cpu_to_be16(HFS_SB(sb)->free_ablocks);\r\nmdb->drNxtCNID = cpu_to_be32(HFS_SB(sb)->next_id);\r\nmdb->drNmFls = cpu_to_be16(HFS_SB(sb)->root_files);\r\nmdb->drNmRtDirs = cpu_to_be16(HFS_SB(sb)->root_dirs);\r\nmdb->drFilCnt = cpu_to_be32(HFS_SB(sb)->file_count);\r\nmdb->drDirCnt = cpu_to_be32(HFS_SB(sb)->folder_count);\r\nmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\r\n}\r\nif (test_and_clear_bit(HFS_FLG_ALT_MDB_DIRTY, &HFS_SB(sb)->flags) &&\r\nHFS_SB(sb)->alt_mdb) {\r\nhfs_inode_write_fork(HFS_SB(sb)->ext_tree->inode, mdb->drXTExtRec,\r\n&mdb->drXTFlSize, NULL);\r\nhfs_inode_write_fork(HFS_SB(sb)->cat_tree->inode, mdb->drCTExtRec,\r\n&mdb->drCTFlSize, NULL);\r\nmemcpy(HFS_SB(sb)->alt_mdb, HFS_SB(sb)->mdb, HFS_SECTOR_SIZE);\r\nHFS_SB(sb)->alt_mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\r\nHFS_SB(sb)->alt_mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\r\nmark_buffer_dirty(HFS_SB(sb)->alt_mdb_bh);\r\nsync_dirty_buffer(HFS_SB(sb)->alt_mdb_bh);\r\n}\r\nif (test_and_clear_bit(HFS_FLG_BITMAP_DIRTY, &HFS_SB(sb)->flags)) {\r\nstruct buffer_head *bh;\r\nsector_t block;\r\nchar *ptr;\r\nint off, size, len;\r\nblock = be16_to_cpu(HFS_SB(sb)->mdb->drVBMSt) + HFS_SB(sb)->part_start;\r\noff = (block << HFS_SECTOR_SIZE_BITS) & (sb->s_blocksize - 1);\r\nblock >>= sb->s_blocksize_bits - HFS_SECTOR_SIZE_BITS;\r\nsize = (HFS_SB(sb)->fs_ablocks + 7) / 8;\r\nptr = (u8 *)HFS_SB(sb)->bitmap;\r\nwhile (size) {\r\nbh = sb_bread(sb, block);\r\nif (!bh) {\r\nprintk(KERN_ERR "hfs: unable to read volume bitmap\n");\r\nbreak;\r\n}\r\nlen = min((int)sb->s_blocksize - off, size);\r\nmemcpy(bh->b_data + off, ptr, len);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nblock++;\r\noff = 0;\r\nptr += len;\r\nsize -= len;\r\n}\r\n}\r\n}\r\nvoid hfs_mdb_close(struct super_block *sb)\r\n{\r\nif (sb->s_flags & MS_RDONLY)\r\nreturn;\r\nHFS_SB(sb)->mdb->drAtrb |= cpu_to_be16(HFS_SB_ATTRIB_UNMNT);\r\nHFS_SB(sb)->mdb->drAtrb &= cpu_to_be16(~HFS_SB_ATTRIB_INCNSTNT);\r\nmark_buffer_dirty(HFS_SB(sb)->mdb_bh);\r\n}\r\nvoid hfs_mdb_put(struct super_block *sb)\r\n{\r\nif (!HFS_SB(sb))\r\nreturn;\r\nhfs_btree_close(HFS_SB(sb)->ext_tree);\r\nhfs_btree_close(HFS_SB(sb)->cat_tree);\r\nbrelse(HFS_SB(sb)->mdb_bh);\r\nbrelse(HFS_SB(sb)->alt_mdb_bh);\r\nunload_nls(HFS_SB(sb)->nls_io);\r\nunload_nls(HFS_SB(sb)->nls_disk);\r\nfree_pages((unsigned long)HFS_SB(sb)->bitmap, PAGE_SIZE < 8192 ? 1 : 0);\r\nkfree(HFS_SB(sb));\r\nsb->s_fs_info = NULL;\r\n}
