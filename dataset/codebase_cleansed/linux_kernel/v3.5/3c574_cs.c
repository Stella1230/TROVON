static int tc574_probe(struct pcmcia_device *link)\r\n{\r\nstruct el3_private *lp;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "3c574_attach()\n");\r\ndev = alloc_etherdev(sizeof(struct el3_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlink->priv = dev;\r\nlp->p_dev = link;\r\nspin_lock_init(&lp->window_lock);\r\nlink->resource[0]->end = 32;\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nlink->config_index = 1;\r\ndev->netdev_ops = &el3_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nreturn tc574_config(link);\r\n}\r\nstatic void tc574_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "3c574_detach()\n");\r\nunregister_netdev(dev);\r\ntc574_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int tc574_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint ret, i, j;\r\nunsigned int ioaddr;\r\n__be16 *phys_addr;\r\nchar *cardname;\r\n__u32 config;\r\nu8 *buf;\r\nsize_t len;\r\nphys_addr = (__be16 *)dev->dev_addr;\r\ndev_dbg(&link->dev, "3c574_config()\n");\r\nlink->io_lines = 16;\r\nfor (i = j = 0; j < 0x400; j += 0x20) {\r\nlink->resource[0]->start = j ^ 0x300;\r\ni = pcmcia_request_io(link);\r\nif (i == 0)\r\nbreak;\r\n}\r\nif (i != 0)\r\ngoto failed;\r\nret = pcmcia_request_irq(link, el3_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nioaddr = dev->base_addr;\r\nlen = pcmcia_get_tuple(link, 0x88, &buf);\r\nif (buf && len >= 6) {\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(le16_to_cpu(buf[i * 2]));\r\nkfree(buf);\r\n} else {\r\nkfree(buf);\r\nEL3WINDOW(0);\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(read_eeprom(ioaddr, i + 10));\r\nif (phys_addr[0] == htons(0x6060)) {\r\npr_notice("IO port conflict at 0x%03lx-0x%03lx\n",\r\ndev->base_addr, dev->base_addr+15);\r\ngoto failed;\r\n}\r\n}\r\nif (link->prod_id[1])\r\ncardname = link->prod_id[1];\r\nelse\r\ncardname = "3Com 3c574";\r\n{\r\nu_char mcr;\r\noutw(2<<11, ioaddr + RunnerRdCtrl);\r\nmcr = inb(ioaddr + 2);\r\noutw(0<<11, ioaddr + RunnerRdCtrl);\r\npr_info(" ASIC rev %d,", mcr>>3);\r\nEL3WINDOW(3);\r\nconfig = inl(ioaddr + Wn3_Config);\r\nlp->default_media = (config & Xcvr) >> Xcvr_shift;\r\nlp->autoselect = config & Autoselect ? 1 : 0;\r\n}\r\ninit_timer(&lp->media);\r\n{\r\nint phy;\r\noutw(0x8040, ioaddr + Wn3_Options);\r\nmdelay(1);\r\noutw(0xc040, ioaddr + Wn3_Options);\r\ntc574_wait_for_completion(dev, TxReset);\r\ntc574_wait_for_completion(dev, RxReset);\r\nmdelay(1);\r\noutw(0x8040, ioaddr + Wn3_Options);\r\nEL3WINDOW(4);\r\nfor (phy = 1; phy <= 32; phy++) {\r\nint mii_status;\r\nmdio_sync(ioaddr, 32);\r\nmii_status = mdio_read(ioaddr, phy & 0x1f, 1);\r\nif (mii_status != 0xffff) {\r\nlp->phys = phy & 0x1f;\r\ndev_dbg(&link->dev, " MII transceiver at "\r\n"index %d, status %x.\n",\r\nphy, mii_status);\r\nif ((mii_status & 0x0040) == 0)\r\nmii_preamble_required = 1;\r\nbreak;\r\n}\r\n}\r\nif (phy > 32) {\r\npr_notice(" No MII transceivers found!\n");\r\ngoto failed;\r\n}\r\ni = mdio_read(ioaddr, lp->phys, 16) | 0x40;\r\nmdio_write(ioaddr, lp->phys, 16, i);\r\nlp->advertising = mdio_read(ioaddr, lp->phys, 4);\r\nif (full_duplex) {\r\nlp->advertising &= ~0x02a0;\r\nmdio_write(ioaddr, lp->phys, 4, lp->advertising);\r\n}\r\n}\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif (register_netdev(dev) != 0) {\r\npr_notice("register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nnetdev_info(dev, "%s at io %#3lx, irq %d, hw_addr %pM\n",\r\ncardname, dev->base_addr, dev->irq, dev->dev_addr);\r\nnetdev_info(dev, " %dK FIFO split %s Rx:Tx, %sMII interface.\n",\r\n8 << config & Ram_size,\r\nram_split[(config & Ram_split) >> Ram_split_shift],\r\nconfig & Autoselect ? "autoselect " : "");\r\nreturn 0;\r\nfailed:\r\ntc574_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void tc574_release(struct pcmcia_device *link)\r\n{\r\npcmcia_disable_device(link);\r\n}\r\nstatic int tc574_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int tc574_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\ntc574_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dump_status(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nEL3WINDOW(1);\r\nnetdev_info(dev, " irq status %04x, rx status %04x, tx status %02x, tx free %04x\n",\r\ninw(ioaddr+EL3_STATUS),\r\ninw(ioaddr+RxStatus), inb(ioaddr+TxStatus),\r\ninw(ioaddr+TxFree));\r\nEL3WINDOW(4);\r\nnetdev_info(dev, " diagnostics: fifo %04x net %04x ethernet %04x media %04x\n",\r\ninw(ioaddr+0x04), inw(ioaddr+0x06),\r\ninw(ioaddr+0x08), inw(ioaddr+0x0a));\r\nEL3WINDOW(1);\r\n}\r\nstatic void tc574_wait_for_completion(struct net_device *dev, int cmd)\r\n{\r\nint i = 1500;\r\noutw(cmd, dev->base_addr + EL3_CMD);\r\nwhile (--i > 0)\r\nif (!(inw(dev->base_addr + EL3_STATUS) & 0x1000)) break;\r\nif (i == 0)\r\nnetdev_notice(dev, "command 0x%04x did not complete!\n", cmd);\r\n}\r\nstatic unsigned short read_eeprom(unsigned int ioaddr, int index)\r\n{\r\nint timer;\r\noutw(EEPROM_Read + index, ioaddr + Wn0EepromCmd);\r\nfor (timer = 1620; timer >= 0; timer--) {\r\nif ((inw(ioaddr + Wn0EepromCmd) & 0x8000) == 0)\r\nbreak;\r\n}\r\nreturn inw(ioaddr + Wn0EepromData);\r\n}\r\nstatic void mdio_sync(unsigned int ioaddr, int bits)\r\n{\r\nunsigned int mdio_addr = ioaddr + Wn4_PhysicalMgmt;\r\nwhile (-- bits >= 0) {\r\noutw(MDIO_DATA_WRITE1, mdio_addr);\r\noutw(MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);\r\n}\r\n}\r\nstatic int mdio_read(unsigned int ioaddr, int phy_id, int location)\r\n{\r\nint i;\r\nint read_cmd = (0xf6 << 10) | (phy_id << 5) | location;\r\nunsigned int retval = 0;\r\nunsigned int mdio_addr = ioaddr + Wn4_PhysicalMgmt;\r\nif (mii_preamble_required)\r\nmdio_sync(ioaddr, 32);\r\nfor (i = 14; i >= 0; i--) {\r\nint dataval = (read_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutw(dataval, mdio_addr);\r\noutw(dataval | MDIO_SHIFT_CLK, mdio_addr);\r\n}\r\nfor (i = 19; i > 0; i--) {\r\noutw(MDIO_ENB_IN, mdio_addr);\r\nretval = (retval << 1) | ((inw(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);\r\noutw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\r\n}\r\nreturn (retval>>1) & 0xffff;\r\n}\r\nstatic void mdio_write(unsigned int ioaddr, int phy_id, int location, int value)\r\n{\r\nint write_cmd = 0x50020000 | (phy_id << 23) | (location << 18) | value;\r\nunsigned int mdio_addr = ioaddr + Wn4_PhysicalMgmt;\r\nint i;\r\nif (mii_preamble_required)\r\nmdio_sync(ioaddr, 32);\r\nfor (i = 31; i >= 0; i--) {\r\nint dataval = (write_cmd&(1<<i)) ? MDIO_DATA_WRITE1 : MDIO_DATA_WRITE0;\r\noutw(dataval, mdio_addr);\r\noutw(dataval | MDIO_SHIFT_CLK, mdio_addr);\r\n}\r\nfor (i = 1; i >= 0; i--) {\r\noutw(MDIO_ENB_IN, mdio_addr);\r\noutw(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\r\n}\r\n}\r\nstatic void tc574_reset(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nint i;\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned long flags;\r\ntc574_wait_for_completion(dev, TotalReset|0x10);\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\noutw(0, ioaddr + RunnerWrCtrl);\r\noutw(0, ioaddr + RunnerRdCtrl);\r\nEL3WINDOW(2);\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + i);\r\nfor (; i < 12; i+=2)\r\noutw(0, ioaddr + i);\r\nEL3WINDOW(3);\r\noutb((dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);\r\noutl((lp->autoselect ? 0x01000000 : 0) | 0x0062001b,\r\nioaddr + Wn3_Config);\r\noutw(0x8040, ioaddr + Wn3_Options);\r\nmdelay(1);\r\noutw(0xc040, ioaddr + Wn3_Options);\r\nEL3WINDOW(1);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\ntc574_wait_for_completion(dev, TxReset);\r\ntc574_wait_for_completion(dev, RxReset);\r\nmdelay(1);\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nEL3WINDOW(3);\r\noutw(0x8040, ioaddr + Wn3_Options);\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(6);\r\nfor (i = 0; i < 10; i++)\r\ninb(ioaddr + i);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(4);\r\ninb(ioaddr + 12);\r\ninb(ioaddr + 13);\r\noutw(0x0040, ioaddr + Wn4_NetDiag);\r\nEL3WINDOW(1);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\nmdio_sync(ioaddr, 32);\r\nmdio_write(ioaddr, lp->phys, 4, lp->advertising);\r\nif (!auto_polarity) {\r\ni = mdio_read(ioaddr, lp->phys, 16) | 0x20;\r\nmdio_write(ioaddr, lp->phys, 16, i);\r\n}\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nset_rx_mode(dev);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\noutw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);\r\noutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\r\nioaddr + EL3_CMD);\r\noutw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull\r\n| AdapterFailure | RxEarly, ioaddr + EL3_CMD);\r\n}\r\nstatic int el3_open(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nlink->open++;\r\nnetif_start_queue(dev);\r\ntc574_reset(dev);\r\nlp->media.function = media_check;\r\nlp->media.data = (unsigned long) dev;\r\nlp->media.expires = jiffies + HZ;\r\nadd_timer(&lp->media);\r\ndev_dbg(&link->dev, "%s: opened, status %4.4x.\n",\r\ndev->name, inw(dev->base_addr + EL3_STATUS));\r\nreturn 0;\r\n}\r\nstatic void el3_tx_timeout(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nnetdev_notice(dev, "Transmit timed out!\n");\r\ndump_status(dev);\r\ndev->stats.tx_errors++;\r\ndev->trans_start = jiffies;\r\ntc574_wait_for_completion(dev, TxReset);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void pop_tx_status(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nint i;\r\nfor (i = 32; i > 0; i--) {\r\nu_char tx_status = inb(ioaddr + TxStatus);\r\nif (!(tx_status & 0x84))\r\nbreak;\r\nif (tx_status & 0x30)\r\ntc574_wait_for_completion(dev, TxReset);\r\nif (tx_status & 0x38) {\r\npr_debug("%s: transmit error: status 0x%02x\n",\r\ndev->name, tx_status);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\ndev->stats.tx_aborted_errors++;\r\n}\r\noutb(0x00, ioaddr + TxStatus);\r\n}\r\n}\r\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\npr_debug("%s: el3_start_xmit(length = %ld) called, "\r\n"status %4.4x.\n", dev->name, (long)skb->len,\r\ninw(ioaddr + EL3_STATUS));\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\ndev->stats.tx_bytes += skb->len;\r\noutw(skb->len, ioaddr + TX_FIFO);\r\noutw(0, ioaddr + TX_FIFO);\r\noutsl(ioaddr + TX_FIFO, skb->data, (skb->len+3)>>2);\r\nif (inw(ioaddr + TxFree) <= 1536) {\r\nnetif_stop_queue(dev);\r\noutw(SetTxThreshold + (1536>>2), ioaddr + EL3_CMD);\r\n}\r\npop_tx_status(dev);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t el3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr;\r\nunsigned status;\r\nint work_budget = max_interrupt_work;\r\nint handled = 0;\r\nif (!netif_device_present(dev))\r\nreturn IRQ_NONE;\r\nioaddr = dev->base_addr;\r\npr_debug("%s: interrupt, status %4.4x.\n",\r\ndev->name, inw(ioaddr + EL3_STATUS));\r\nspin_lock(&lp->window_lock);\r\nwhile ((status = inw(ioaddr + EL3_STATUS)) &\r\n(IntLatch | RxComplete | RxEarly | StatsFull)) {\r\nif (!netif_device_present(dev) ||\r\n((status & 0xe000) != 0x2000)) {\r\npr_debug("%s: Interrupt from dead card\n", dev->name);\r\nbreak;\r\n}\r\nhandled = 1;\r\nif (status & RxComplete)\r\nwork_budget = el3_rx(dev, work_budget);\r\nif (status & TxAvailable) {\r\npr_debug(" TX room bit was handled.\n");\r\noutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & TxComplete)\r\npop_tx_status(dev);\r\nif (status & (AdapterFailure | RxEarly | StatsFull)) {\r\nif (status & StatsFull)\r\nupdate_stats(dev);\r\nif (status & RxEarly) {\r\nwork_budget = el3_rx(dev, work_budget);\r\noutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\r\n}\r\nif (status & AdapterFailure) {\r\nu16 fifo_diag;\r\nEL3WINDOW(4);\r\nfifo_diag = inw(ioaddr + Wn4_FIFODiag);\r\nEL3WINDOW(1);\r\nnetdev_notice(dev, "adapter failure, FIFO diagnostic register %04x\n",\r\nfifo_diag);\r\nif (fifo_diag & 0x0400) {\r\ntc574_wait_for_completion(dev, TxReset);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\n}\r\nif (fifo_diag & 0x2000) {\r\ntc574_wait_for_completion(dev, RxReset);\r\nset_rx_mode(dev);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\n}\r\noutw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);\r\n}\r\n}\r\nif (--work_budget < 0) {\r\npr_debug("%s: Too much work in interrupt, "\r\n"status %4.4x.\n", dev->name, status);\r\noutw(AckIntr | 0xFF, ioaddr + EL3_CMD);\r\nbreak;\r\n}\r\noutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\r\n}\r\npr_debug("%s: exiting interrupt, status %4.4x.\n",\r\ndev->name, inw(ioaddr + EL3_STATUS));\r\nspin_unlock(&lp->window_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void media_check(unsigned long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *) arg;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nunsigned short media, partner;\r\nif (!netif_device_present(dev))\r\ngoto reschedule;\r\nif ((inw(ioaddr + EL3_STATUS) & IntLatch) && (inb(ioaddr + Timer) == 0xff)) {\r\nif (!lp->fast_poll)\r\nnetdev_info(dev, "interrupt(s) dropped!\n");\r\nlocal_irq_save(flags);\r\nel3_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\nlp->fast_poll = HZ;\r\n}\r\nif (lp->fast_poll) {\r\nlp->fast_poll--;\r\nlp->media.expires = jiffies + 2*HZ/100;\r\nadd_timer(&lp->media);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nEL3WINDOW(4);\r\nmedia = mdio_read(ioaddr, lp->phys, 1);\r\npartner = mdio_read(ioaddr, lp->phys, 5);\r\nEL3WINDOW(1);\r\nif (media != lp->media_status) {\r\nif ((media ^ lp->media_status) & 0x0004)\r\nnetdev_info(dev, "%s link beat\n",\r\n(lp->media_status & 0x0004) ? "lost" : "found");\r\nif ((media ^ lp->media_status) & 0x0020) {\r\nlp->partner = 0;\r\nif (lp->media_status & 0x0020) {\r\nnetdev_info(dev, "autonegotiation restarted\n");\r\n} else if (partner) {\r\npartner &= lp->advertising;\r\nlp->partner = partner;\r\nnetdev_info(dev, "autonegotiation complete: "\r\n"%dbaseT-%cD selected\n",\r\n(partner & 0x0180) ? 100 : 10,\r\n(partner & 0x0140) ? 'F' : 'H');\r\n} else {\r\nnetdev_info(dev, "link partner did not autonegotiate\n");\r\n}\r\nEL3WINDOW(3);\r\noutb((partner & 0x0140 ? 0x20 : 0) |\r\n(dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);\r\nEL3WINDOW(1);\r\n}\r\nif (media & 0x0010)\r\nnetdev_info(dev, "remote fault detected\n");\r\nif (media & 0x0002)\r\nnetdev_info(dev, "jabber detected\n");\r\nlp->media_status = media;\r\n}\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\nreschedule:\r\nlp->media.expires = jiffies + HZ;\r\nadd_timer(&lp->media);\r\n}\r\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nif (netif_device_present(dev)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nupdate_stats(dev);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void update_stats(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nu8 rx, tx, up;\r\npr_debug("%s: updating the statistics.\n", dev->name);\r\nif (inw(ioaddr+EL3_STATUS) == 0xffff)\r\nreturn;\r\nEL3WINDOW(6);\r\ndev->stats.tx_carrier_errors += inb(ioaddr + 0);\r\ndev->stats.tx_heartbeat_errors += inb(ioaddr + 1);\r\ninb(ioaddr + 2);\r\ndev->stats.collisions += inb(ioaddr + 3);\r\ndev->stats.tx_window_errors += inb(ioaddr + 4);\r\ndev->stats.rx_fifo_errors += inb(ioaddr + 5);\r\ndev->stats.tx_packets += inb(ioaddr + 6);\r\nup = inb(ioaddr + 9);\r\ndev->stats.tx_packets += (up&0x30) << 4;\r\ninb(ioaddr + 7);\r\ninb(ioaddr + 8);\r\nrx = inw(ioaddr + 10);\r\ntx = inw(ioaddr + 12);\r\nEL3WINDOW(4);\r\ninb(ioaddr + 12);\r\nup = inb(ioaddr + 13);\r\nEL3WINDOW(1);\r\n}\r\nstatic int el3_rx(struct net_device *dev, int worklimit)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nshort rx_status;\r\npr_debug("%s: in rx_packet(), status %4.4x, rx_status %4.4x.\n",\r\ndev->name, inw(ioaddr+EL3_STATUS), inw(ioaddr+RxStatus));\r\nwhile (!((rx_status = inw(ioaddr + RxStatus)) & 0x8000) &&\r\nworklimit > 0) {\r\nworklimit--;\r\nif (rx_status & 0x4000) {\r\nshort error = rx_status & 0x3800;\r\ndev->stats.rx_errors++;\r\nswitch (error) {\r\ncase 0x0000: dev->stats.rx_over_errors++; break;\r\ncase 0x0800: dev->stats.rx_length_errors++; break;\r\ncase 0x1000: dev->stats.rx_frame_errors++; break;\r\ncase 0x1800: dev->stats.rx_length_errors++; break;\r\ncase 0x2000: dev->stats.rx_frame_errors++; break;\r\ncase 0x2800: dev->stats.rx_crc_errors++; break;\r\n}\r\n} else {\r\nshort pkt_len = rx_status & 0x7ff;\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, pkt_len + 5);\r\npr_debug(" Receiving packet size %d status %4.4x.\n",\r\npkt_len, rx_status);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\ninsl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),\r\n((pkt_len+3)>>2));\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n} else {\r\npr_debug("%s: couldn't allocate a sk_buff of"\r\n" size %d.\n", dev->name, pkt_len);\r\ndev->stats.rx_dropped++;\r\n}\r\n}\r\ntc574_wait_for_completion(dev, RxDiscard);\r\n}\r\nreturn worklimit;\r\n}\r\nstatic int el3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct mii_ioctl_data *data = if_mii(rq);\r\nint phy = lp->phys & 0x1f;\r\npr_debug("%s: In ioct(%-.6s, %#4.4x) %4.4x %4.4x %4.4x %4.4x.\n",\r\ndev->name, rq->ifr_ifrn.ifrn_name, cmd,\r\ndata->phy_id, data->reg_num, data->val_in, data->val_out);\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = phy;\r\ncase SIOCGMIIREG:\r\n{\r\nint saved_window;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nsaved_window = inw(ioaddr + EL3_CMD) >> 13;\r\nEL3WINDOW(4);\r\ndata->val_out = mdio_read(ioaddr, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f);\r\nEL3WINDOW(saved_window);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\nreturn 0;\r\n}\r\ncase SIOCSMIIREG:\r\n{\r\nint saved_window;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nsaved_window = inw(ioaddr + EL3_CMD) >> 13;\r\nEL3WINDOW(4);\r\nmdio_write(ioaddr, data->phy_id & 0x1f,\r\ndata->reg_num & 0x1f, data->val_in);\r\nEL3WINDOW(saved_window);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nif (dev->flags & IFF_PROMISC)\r\noutw(SetRxFilter | RxStation | RxMulticast | RxBroadcast | RxProm,\r\nioaddr + EL3_CMD);\r\nelse if (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI))\r\noutw(SetRxFilter|RxStation|RxMulticast|RxBroadcast, ioaddr + EL3_CMD);\r\nelse\r\noutw(SetRxFilter | RxStation | RxBroadcast, ioaddr + EL3_CMD);\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nset_rx_mode(dev);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\n}\r\nstatic int el3_close(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\ndev_dbg(&link->dev, "%s: shutting down ethercard.\n", dev->name);\r\nif (pcmcia_dev_present(link)) {\r\nunsigned long flags;\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\noutw(RxDisable, ioaddr + EL3_CMD);\r\noutw(TxDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(0);\r\nspin_lock_irqsave(&lp->window_lock, flags);\r\nupdate_stats(dev);\r\nspin_unlock_irqrestore(&lp->window_lock, flags);\r\noutw(SetIntrEnb | 0x0000, ioaddr + EL3_CMD);\r\n}\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&lp->media);\r\nreturn 0;\r\n}\r\nstatic int __init init_tc574(void)\r\n{\r\nreturn pcmcia_register_driver(&tc574_driver);\r\n}\r\nstatic void __exit exit_tc574(void)\r\n{\r\npcmcia_unregister_driver(&tc574_driver);\r\n}
