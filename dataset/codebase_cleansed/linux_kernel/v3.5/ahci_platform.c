static int __init ahci_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_platform_data *pdata = dev_get_platdata(dev);\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nstruct ata_port_info pi = ahci_port_info[id ? id->driver_data : 0];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct ahci_host_priv *hpriv;\r\nstruct ata_host *host;\r\nstruct resource *mem;\r\nint irq;\r\nint n_ports;\r\nint i;\r\nint rc;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(dev, "no mmio space\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "no irq\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata && pdata->ata_port_info)\r\npi = *pdata->ata_port_info;\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv) {\r\ndev_err(dev, "can't alloc ahci_host_priv\n");\r\nreturn -ENOMEM;\r\n}\r\nhpriv->flags |= (unsigned long)pi.private_data;\r\nhpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));\r\nif (!hpriv->mmio) {\r\ndev_err(dev, "can't map %pR\n", mem);\r\nreturn -ENOMEM;\r\n}\r\nif (pdata && pdata->init) {\r\nrc = pdata->init(dev, hpriv->mmio);\r\nif (rc)\r\nreturn rc;\r\n}\r\nahci_save_initial_config(dev, hpriv,\r\npdata ? pdata->force_port_map : 0,\r\npdata ? pdata->mask_port_map : 0);\r\nif (hpriv->cap & HOST_CAP_NCQ)\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nahci_set_em_messages(hpriv, &pi);\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\nhost = ata_host_alloc_pinfo(dev, ppi, n_ports);\r\nif (!host) {\r\nrc = -ENOMEM;\r\ngoto err0;\r\n}\r\nhost->private_data = hpriv;\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nelse\r\nprintk(KERN_INFO "ahci: SSS flag set, parallel bus scan disabled\n");\r\nif (pi.flags & ATA_FLAG_EM)\r\nahci_reset_em(host);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_desc(ap, "mmio %pR", mem);\r\nata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);\r\nif (ap->flags & ATA_FLAG_EM)\r\nap->em_message_type = hpriv->em_msg_type;\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\ngoto err0;\r\nahci_init_controller(host);\r\nahci_print_info(host, "platform");\r\nrc = ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,\r\n&ahci_platform_sht);\r\nif (rc)\r\ngoto err0;\r\nreturn 0;\r\nerr0:\r\nif (pdata && pdata->exit)\r\npdata->exit(dev);\r\nreturn rc;\r\n}\r\nstatic int __devexit ahci_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_platform_data *pdata = dev_get_platdata(dev);\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nata_host_detach(host);\r\nif (pdata && pdata->exit)\r\npdata->exit(dev);\r\nreturn 0;\r\n}\r\nstatic int ahci_suspend(struct device *dev)\r\n{\r\nstruct ahci_platform_data *pdata = dev_get_platdata(dev);\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nint rc;\r\nif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(dev, "firmware update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\nrc = ata_host_suspend(host, PMSG_SUSPEND);\r\nif (rc)\r\nreturn rc;\r\nif (pdata && pdata->suspend)\r\nreturn pdata->suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int ahci_resume(struct device *dev)\r\n{\r\nstruct ahci_platform_data *pdata = dev_get_platdata(dev);\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nint rc;\r\nif (pdata && pdata->resume) {\r\nrc = pdata->resume(dev);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (dev->power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int __init ahci_init(void)\r\n{\r\nreturn platform_driver_probe(&ahci_driver, ahci_probe);\r\n}\r\nstatic void __exit ahci_exit(void)\r\n{\r\nplatform_driver_unregister(&ahci_driver);\r\n}
