static struct i2c_client *taos_instantiate_device(struct i2c_adapter *adapter)\r\n{\r\nif (!strncmp(adapter->name, "TAOS TSL2550 EVM", 16)) {\r\ndev_info(&adapter->dev, "Instantiating device %s at 0x%02x\n",\r\ntsl2550_info.type, tsl2550_info.addr);\r\nreturn i2c_new_device(adapter, &tsl2550_info);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int taos_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\r\nunsigned short flags, char read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nstruct serio *serio = adapter->algo_data;\r\nstruct taos_data *taos = serio_get_drvdata(serio);\r\nchar *p;\r\np = taos->buffer;\r\nif (addr != taos->addr)\r\np += sprintf(p, "@%02X", addr);\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_WRITE)\r\nsprintf(p, "$#%02X", command);\r\nelse\r\nsprintf(p, "$");\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nif (read_write == I2C_SMBUS_WRITE)\r\nsprintf(p, "$%02X#%02X", command, data->byte);\r\nelse\r\nsprintf(p, "$%02X", command);\r\nbreak;\r\ndefault:\r\ndev_warn(&adapter->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\ndev_dbg(&adapter->dev, "Command buffer: %s\n", taos->buffer);\r\nfor (p = taos->buffer; *p; p++)\r\nserio_write(serio, *p);\r\ntaos->addr = addr;\r\ntaos->pos = 0;\r\ntaos->state = TAOS_STATE_RECV;\r\nserio_write(serio, read_write == I2C_SMBUS_WRITE ? '>' : '<');\r\nwait_event_interruptible_timeout(wq, taos->state == TAOS_STATE_IDLE,\r\nmsecs_to_jiffies(150));\r\nif (taos->state != TAOS_STATE_IDLE\r\n|| taos->pos != 5) {\r\ndev_err(&adapter->dev, "Transaction timeout (pos=%d)\n",\r\ntaos->pos);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&adapter->dev, "Answer buffer: %s\n", taos->buffer);\r\np = taos->buffer + 1;\r\np[3] = '\0';\r\nif (!strcmp(p, "NAK"))\r\nreturn -ENODEV;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nif (!strcmp(p, "ACK"))\r\nreturn 0;\r\n} else {\r\nif (p[0] == 'x') {\r\ndata->byte = simple_strtol(p + 1, NULL, 16);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic u32 taos_smbus_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA;\r\n}\r\nstatic irqreturn_t taos_interrupt(struct serio *serio, unsigned char data,\r\nunsigned int flags)\r\n{\r\nstruct taos_data *taos = serio_get_drvdata(serio);\r\nswitch (taos->state) {\r\ncase TAOS_STATE_INIT:\r\ntaos->buffer[taos->pos++] = data;\r\nif (data == ':'\r\n|| taos->pos == TAOS_BUFFER_SIZE - 1) {\r\ntaos->buffer[taos->pos] = '\0';\r\ntaos->state = TAOS_STATE_IDLE;\r\nwake_up_interruptible(&wq);\r\n}\r\nbreak;\r\ncase TAOS_STATE_EOFF:\r\ntaos->state = TAOS_STATE_IDLE;\r\nwake_up_interruptible(&wq);\r\nbreak;\r\ncase TAOS_STATE_RECV:\r\ntaos->buffer[taos->pos++] = data;\r\nif (data == ']') {\r\ntaos->buffer[taos->pos] = '\0';\r\ntaos->state = TAOS_STATE_IDLE;\r\nwake_up_interruptible(&wq);\r\n}\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic char *taos_adapter_name(char *buffer)\r\n{\r\nchar *start, *end;\r\nstart = strstr(buffer, "TAOS ");\r\nif (!start)\r\nreturn NULL;\r\nend = strchr(start, '\r');\r\nif (!end)\r\nreturn NULL;\r\n*end = '\0';\r\nreturn start;\r\n}\r\nstatic int taos_connect(struct serio *serio, struct serio_driver *drv)\r\n{\r\nstruct taos_data *taos;\r\nstruct i2c_adapter *adapter;\r\nchar *name;\r\nint err;\r\ntaos = kzalloc(sizeof(struct taos_data), GFP_KERNEL);\r\nif (!taos) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ntaos->state = TAOS_STATE_INIT;\r\nserio_set_drvdata(serio, taos);\r\nerr = serio_open(serio, drv);\r\nif (err)\r\ngoto exit_kfree;\r\nadapter = &taos->adapter;\r\nadapter->owner = THIS_MODULE;\r\nadapter->algo = &taos_algorithm;\r\nadapter->algo_data = serio;\r\nadapter->dev.parent = &serio->dev;\r\nserio_write(serio, TAOS_CMD_RESET);\r\nwait_event_interruptible_timeout(wq, taos->state == TAOS_STATE_IDLE,\r\nmsecs_to_jiffies(2000));\r\nif (taos->state != TAOS_STATE_IDLE) {\r\nerr = -ENODEV;\r\ndev_err(&serio->dev, "TAOS EVM reset failed (state=%d, "\r\n"pos=%d)\n", taos->state, taos->pos);\r\ngoto exit_close;\r\n}\r\nname = taos_adapter_name(taos->buffer);\r\nif (!name) {\r\nerr = -ENODEV;\r\ndev_err(&serio->dev, "TAOS EVM identification failed\n");\r\ngoto exit_close;\r\n}\r\nstrlcpy(adapter->name, name, sizeof(adapter->name));\r\ntaos->state = TAOS_STATE_EOFF;\r\nserio_write(serio, TAOS_CMD_ECHO_OFF);\r\nwait_event_interruptible_timeout(wq, taos->state == TAOS_STATE_IDLE,\r\nmsecs_to_jiffies(250));\r\nif (taos->state != TAOS_STATE_IDLE) {\r\nerr = -ENODEV;\r\ndev_err(&serio->dev, "TAOS EVM echo off failed "\r\n"(state=%d)\n", taos->state);\r\ngoto exit_close;\r\n}\r\nerr = i2c_add_adapter(adapter);\r\nif (err)\r\ngoto exit_close;\r\ndev_info(&serio->dev, "Connected to TAOS EVM\n");\r\ntaos->client = taos_instantiate_device(adapter);\r\nreturn 0;\r\nexit_close:\r\nserio_close(serio);\r\nexit_kfree:\r\nserio_set_drvdata(serio, NULL);\r\nkfree(taos);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void taos_disconnect(struct serio *serio)\r\n{\r\nstruct taos_data *taos = serio_get_drvdata(serio);\r\nif (taos->client)\r\ni2c_unregister_device(taos->client);\r\ni2c_del_adapter(&taos->adapter);\r\nserio_close(serio);\r\nserio_set_drvdata(serio, NULL);\r\nkfree(taos);\r\ndev_info(&serio->dev, "Disconnected from TAOS EVM\n");\r\n}\r\nstatic int __init taos_init(void)\r\n{\r\nreturn serio_register_driver(&taos_drv);\r\n}\r\nstatic void __exit taos_exit(void)\r\n{\r\nserio_unregister_driver(&taos_drv);\r\n}
