static inline void _mpic_msgr_mer_write(struct mpic_msgr *msgr, u32 value)\r\n{\r\nout_be32(msgr->mer, value);\r\n}\r\nstatic inline u32 _mpic_msgr_mer_read(struct mpic_msgr *msgr)\r\n{\r\nreturn in_be32(msgr->mer);\r\n}\r\nstatic inline void _mpic_msgr_disable(struct mpic_msgr *msgr)\r\n{\r\nu32 mer = _mpic_msgr_mer_read(msgr);\r\n_mpic_msgr_mer_write(msgr, mer & ~(1 << msgr->num));\r\n}\r\nstruct mpic_msgr *mpic_msgr_get(unsigned int reg_num)\r\n{\r\nunsigned long flags;\r\nstruct mpic_msgr *msgr;\r\nmsgr = ERR_PTR(-EBUSY);\r\nif (reg_num >= mpic_msgr_count)\r\nreturn ERR_PTR(-ENODEV);\r\nraw_spin_lock_irqsave(&msgrs_lock, flags);\r\nmsgr = mpic_msgrs[reg_num];\r\nif (msgr->in_use == MSGR_FREE)\r\nmsgr->in_use = MSGR_INUSE;\r\nraw_spin_unlock_irqrestore(&msgrs_lock, flags);\r\nreturn msgr;\r\n}\r\nvoid mpic_msgr_put(struct mpic_msgr *msgr)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&msgr->lock, flags);\r\nmsgr->in_use = MSGR_FREE;\r\n_mpic_msgr_disable(msgr);\r\nraw_spin_unlock_irqrestore(&msgr->lock, flags);\r\n}\r\nvoid mpic_msgr_enable(struct mpic_msgr *msgr)\r\n{\r\nunsigned long flags;\r\nu32 mer;\r\nraw_spin_lock_irqsave(&msgr->lock, flags);\r\nmer = _mpic_msgr_mer_read(msgr);\r\n_mpic_msgr_mer_write(msgr, mer | (1 << msgr->num));\r\nraw_spin_unlock_irqrestore(&msgr->lock, flags);\r\n}\r\nvoid mpic_msgr_disable(struct mpic_msgr *msgr)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&msgr->lock, flags);\r\n_mpic_msgr_disable(msgr);\r\nraw_spin_unlock_irqrestore(&msgr->lock, flags);\r\n}\r\nstatic unsigned int mpic_msgr_number_of_blocks(void)\r\n{\r\nunsigned int count;\r\nstruct device_node *aliases;\r\ncount = 0;\r\naliases = of_find_node_by_name(NULL, "aliases");\r\nif (aliases) {\r\nchar buf[32];\r\nfor (;;) {\r\nsnprintf(buf, sizeof(buf), "mpic-msgr-block%d", count);\r\nif (!of_find_property(aliases, buf, NULL))\r\nbreak;\r\ncount += 1;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned int mpic_msgr_number_of_registers(void)\r\n{\r\nreturn mpic_msgr_number_of_blocks() * MPIC_MSGR_REGISTERS_PER_BLOCK;\r\n}\r\nstatic int mpic_msgr_block_number(struct device_node *node)\r\n{\r\nstruct device_node *aliases;\r\nunsigned int index, number_of_blocks;\r\nchar buf[64];\r\nnumber_of_blocks = mpic_msgr_number_of_blocks();\r\naliases = of_find_node_by_name(NULL, "aliases");\r\nif (!aliases)\r\nreturn -1;\r\nfor (index = 0; index < number_of_blocks; ++index) {\r\nstruct property *prop;\r\nsnprintf(buf, sizeof(buf), "mpic-msgr-block%d", index);\r\nprop = of_find_property(aliases, buf, NULL);\r\nif (node == of_find_node_by_path(prop->value))\r\nbreak;\r\n}\r\nreturn index == number_of_blocks ? -1 : index;\r\n}\r\nstatic __devinit int mpic_msgr_probe(struct platform_device *dev)\r\n{\r\nvoid __iomem *msgr_block_addr;\r\nint block_number;\r\nstruct resource rsrc;\r\nunsigned int i;\r\nunsigned int irq_index;\r\nstruct device_node *np = dev->dev.of_node;\r\nunsigned int receive_mask;\r\nconst unsigned int *prop;\r\nif (!np) {\r\ndev_err(&dev->dev, "Device OF-Node is NULL");\r\nreturn -EFAULT;\r\n}\r\nif (!mpic_msgrs) {\r\nmpic_msgr_count = mpic_msgr_number_of_registers();\r\ndev_info(&dev->dev, "Found %d message registers\n",\r\nmpic_msgr_count);\r\nmpic_msgrs = kzalloc(sizeof(struct mpic_msgr) * mpic_msgr_count,\r\nGFP_KERNEL);\r\nif (!mpic_msgrs) {\r\ndev_err(&dev->dev,\r\n"No memory for message register blocks\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndev_info(&dev->dev, "Of-device full name %s\n", np->full_name);\r\nof_address_to_resource(np, 0, &rsrc);\r\nmsgr_block_addr = ioremap(rsrc.start, rsrc.end - rsrc.start);\r\nif (!msgr_block_addr) {\r\ndev_err(&dev->dev, "Failed to iomap MPIC message registers");\r\nreturn -EFAULT;\r\n}\r\nblock_number = mpic_msgr_block_number(np);\r\nif (block_number < 0) {\r\ndev_err(&dev->dev,\r\n"Failed to find message register block alias\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(&dev->dev, "Setting up message register block %d\n",\r\nblock_number);\r\nprop = of_get_property(np, "mpic-msgr-receive-mask", NULL);\r\nreceive_mask = (prop) ? *prop : 0xF;\r\nfor (i = 0, irq_index = 0; i < MPIC_MSGR_REGISTERS_PER_BLOCK; ++i) {\r\nstruct mpic_msgr *msgr;\r\nunsigned int reg_number;\r\nmsgr = kzalloc(sizeof(struct mpic_msgr), GFP_KERNEL);\r\nif (!msgr) {\r\ndev_err(&dev->dev, "No memory for message register\n");\r\nreturn -ENOMEM;\r\n}\r\nreg_number = block_number * MPIC_MSGR_REGISTERS_PER_BLOCK + i;\r\nmsgr->base = msgr_block_addr + i * MPIC_MSGR_STRIDE;\r\nmsgr->mer = (u32 *)((u8 *)msgr->base + MPIC_MSGR_MER_OFFSET);\r\nmsgr->in_use = MSGR_FREE;\r\nmsgr->num = i;\r\nraw_spin_lock_init(&msgr->lock);\r\nif (receive_mask & (1 << i)) {\r\nstruct resource irq;\r\nif (of_irq_to_resource(np, irq_index, &irq) == NO_IRQ) {\r\ndev_err(&dev->dev,\r\n"Missing interrupt specifier");\r\nkfree(msgr);\r\nreturn -EFAULT;\r\n}\r\nmsgr->irq = irq.start;\r\nirq_index += 1;\r\n} else {\r\nmsgr->irq = NO_IRQ;\r\n}\r\nmpic_msgrs[reg_number] = msgr;\r\nmpic_msgr_disable(msgr);\r\ndev_info(&dev->dev, "Register %d initialized: irq %d\n",\r\nreg_number, msgr->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int mpic_msgr_init(void)\r\n{\r\nreturn platform_driver_register(&mpic_msgr_driver);\r\n}
