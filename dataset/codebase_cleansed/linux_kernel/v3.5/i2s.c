static inline bool is_secondary(struct i2s_dai *i2s)\r\n{\r\nreturn i2s->pri_dai ? true : false;\r\n}\r\nstatic inline bool is_slave(struct i2s_dai *i2s)\r\n{\r\nreturn (readl(i2s->addr + I2SMOD) & MOD_SLAVE) ? true : false;\r\n}\r\nstatic inline bool tx_active(struct i2s_dai *i2s)\r\n{\r\nu32 active;\r\nif (!i2s)\r\nreturn false;\r\nactive = readl(i2s->addr + I2SCON);\r\nif (is_secondary(i2s))\r\nactive &= CON_TXSDMA_ACTIVE;\r\nelse\r\nactive &= CON_TXDMA_ACTIVE;\r\nreturn active ? true : false;\r\n}\r\nstatic inline bool other_tx_active(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nreturn tx_active(other);\r\n}\r\nstatic inline bool any_tx_active(struct i2s_dai *i2s)\r\n{\r\nreturn tx_active(i2s) || other_tx_active(i2s);\r\n}\r\nstatic inline bool rx_active(struct i2s_dai *i2s)\r\n{\r\nu32 active;\r\nif (!i2s)\r\nreturn false;\r\nactive = readl(i2s->addr + I2SCON) & CON_RXDMA_ACTIVE;\r\nreturn active ? true : false;\r\n}\r\nstatic inline bool other_rx_active(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nreturn rx_active(other);\r\n}\r\nstatic inline bool any_rx_active(struct i2s_dai *i2s)\r\n{\r\nreturn rx_active(i2s) || other_rx_active(i2s);\r\n}\r\nstatic inline bool other_active(struct i2s_dai *i2s)\r\n{\r\nreturn other_rx_active(i2s) || other_tx_active(i2s);\r\n}\r\nstatic inline bool this_active(struct i2s_dai *i2s)\r\n{\r\nreturn tx_active(i2s) || rx_active(i2s);\r\n}\r\nstatic inline bool any_active(struct i2s_dai *i2s)\r\n{\r\nreturn this_active(i2s) || other_active(i2s);\r\n}\r\nstatic inline struct i2s_dai *to_info(struct snd_soc_dai *dai)\r\n{\r\nreturn snd_soc_dai_get_drvdata(dai);\r\n}\r\nstatic inline bool is_opened(struct i2s_dai *i2s)\r\n{\r\nif (i2s && (i2s->mode & DAI_OPENED))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline bool is_manager(struct i2s_dai *i2s)\r\n{\r\nif (is_opened(i2s) && (i2s->mode & DAI_MANAGER))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic inline unsigned get_rfs(struct i2s_dai *i2s)\r\n{\r\nu32 rfs = (readl(i2s->addr + I2SMOD) >> 3) & 0x3;\r\nswitch (rfs) {\r\ncase 3: return 768;\r\ncase 2: return 384;\r\ncase 1: return 512;\r\ndefault: return 256;\r\n}\r\n}\r\nstatic inline void set_rfs(struct i2s_dai *i2s, unsigned rfs)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nmod &= ~MOD_RCLK_MASK;\r\nswitch (rfs) {\r\ncase 768:\r\nmod |= MOD_RCLK_768FS;\r\nbreak;\r\ncase 512:\r\nmod |= MOD_RCLK_512FS;\r\nbreak;\r\ncase 384:\r\nmod |= MOD_RCLK_384FS;\r\nbreak;\r\ndefault:\r\nmod |= MOD_RCLK_256FS;\r\nbreak;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\n}\r\nstatic inline unsigned get_bfs(struct i2s_dai *i2s)\r\n{\r\nu32 bfs = (readl(i2s->addr + I2SMOD) >> 1) & 0x3;\r\nswitch (bfs) {\r\ncase 3: return 24;\r\ncase 2: return 16;\r\ncase 1: return 48;\r\ndefault: return 32;\r\n}\r\n}\r\nstatic inline void set_bfs(struct i2s_dai *i2s, unsigned bfs)\r\n{\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nmod &= ~MOD_BCLK_MASK;\r\nswitch (bfs) {\r\ncase 48:\r\nmod |= MOD_BCLK_48FS;\r\nbreak;\r\ncase 32:\r\nmod |= MOD_BCLK_32FS;\r\nbreak;\r\ncase 24:\r\nmod |= MOD_BCLK_24FS;\r\nbreak;\r\ncase 16:\r\nmod |= MOD_BCLK_16FS;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Wrong BCLK Divider!\n");\r\nreturn;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\n}\r\nstatic inline int get_blc(struct i2s_dai *i2s)\r\n{\r\nint blc = readl(i2s->addr + I2SMOD);\r\nblc = (blc >> 13) & 0x3;\r\nswitch (blc) {\r\ncase 2: return 24;\r\ncase 1: return 8;\r\ndefault: return 16;\r\n}\r\n}\r\nstatic void i2s_txctrl(struct i2s_dai *i2s, int on)\r\n{\r\nvoid __iomem *addr = i2s->addr;\r\nu32 con = readl(addr + I2SCON);\r\nu32 mod = readl(addr + I2SMOD) & ~MOD_MASK;\r\nif (on) {\r\ncon |= CON_ACTIVE;\r\ncon &= ~CON_TXCH_PAUSE;\r\nif (is_secondary(i2s)) {\r\ncon |= CON_TXSDMA_ACTIVE;\r\ncon &= ~CON_TXSDMA_PAUSE;\r\n} else {\r\ncon |= CON_TXDMA_ACTIVE;\r\ncon &= ~CON_TXDMA_PAUSE;\r\n}\r\nif (any_rx_active(i2s))\r\nmod |= MOD_TXRX;\r\nelse\r\nmod |= MOD_TXONLY;\r\n} else {\r\nif (is_secondary(i2s)) {\r\ncon |= CON_TXSDMA_PAUSE;\r\ncon &= ~CON_TXSDMA_ACTIVE;\r\n} else {\r\ncon |= CON_TXDMA_PAUSE;\r\ncon &= ~CON_TXDMA_ACTIVE;\r\n}\r\nif (other_tx_active(i2s)) {\r\nwritel(con, addr + I2SCON);\r\nreturn;\r\n}\r\ncon |= CON_TXCH_PAUSE;\r\nif (any_rx_active(i2s))\r\nmod |= MOD_RXONLY;\r\nelse\r\ncon &= ~CON_ACTIVE;\r\n}\r\nwritel(mod, addr + I2SMOD);\r\nwritel(con, addr + I2SCON);\r\n}\r\nstatic void i2s_rxctrl(struct i2s_dai *i2s, int on)\r\n{\r\nvoid __iomem *addr = i2s->addr;\r\nu32 con = readl(addr + I2SCON);\r\nu32 mod = readl(addr + I2SMOD) & ~MOD_MASK;\r\nif (on) {\r\ncon |= CON_RXDMA_ACTIVE | CON_ACTIVE;\r\ncon &= ~(CON_RXDMA_PAUSE | CON_RXCH_PAUSE);\r\nif (any_tx_active(i2s))\r\nmod |= MOD_TXRX;\r\nelse\r\nmod |= MOD_RXONLY;\r\n} else {\r\ncon |= CON_RXDMA_PAUSE | CON_RXCH_PAUSE;\r\ncon &= ~CON_RXDMA_ACTIVE;\r\nif (any_tx_active(i2s))\r\nmod |= MOD_TXONLY;\r\nelse\r\ncon &= ~CON_ACTIVE;\r\n}\r\nwritel(mod, addr + I2SMOD);\r\nwritel(con, addr + I2SCON);\r\n}\r\nstatic inline void i2s_fifo(struct i2s_dai *i2s, u32 flush)\r\n{\r\nvoid __iomem *fic;\r\nu32 val;\r\nif (!i2s)\r\nreturn;\r\nif (is_secondary(i2s))\r\nfic = i2s->addr + I2SFICS;\r\nelse\r\nfic = i2s->addr + I2SFIC;\r\nwritel(readl(fic) | flush, fic);\r\nval = msecs_to_loops(1) / 1000;\r\nwhile (--val)\r\ncpu_relax();\r\nwritel(readl(fic) & ~flush, fic);\r\n}\r\nstatic int i2s_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int rfs, int dir)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nswitch (clk_id) {\r\ncase SAMSUNG_I2S_CDCLK:\r\nif (dir == SND_SOC_CLOCK_IN)\r\nrfs = 0;\r\nif ((rfs && other->rfs && (other->rfs != rfs)) ||\r\n(any_active(i2s) &&\r\n(((dir == SND_SOC_CLOCK_IN)\r\n&& !(mod & MOD_CDCLKCON)) ||\r\n((dir == SND_SOC_CLOCK_OUT)\r\n&& (mod & MOD_CDCLKCON))))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nif (dir == SND_SOC_CLOCK_IN)\r\nmod |= MOD_CDCLKCON;\r\nelse\r\nmod &= ~MOD_CDCLKCON;\r\ni2s->rfs = rfs;\r\nbreak;\r\ncase SAMSUNG_I2S_RCLKSRC_0:\r\ncase SAMSUNG_I2S_RCLKSRC_1:\r\nif ((i2s->quirks & QUIRK_NO_MUXPSR)\r\n|| (clk_id == SAMSUNG_I2S_RCLKSRC_0))\r\nclk_id = 0;\r\nelse\r\nclk_id = 1;\r\nif (!any_active(i2s)) {\r\nif (i2s->op_clk) {\r\nif ((clk_id && !(mod & MOD_IMS_SYSMUX)) ||\r\n(!clk_id && (mod & MOD_IMS_SYSMUX))) {\r\nclk_disable(i2s->op_clk);\r\nclk_put(i2s->op_clk);\r\n} else {\r\ni2s->rclk_srcrate =\r\nclk_get_rate(i2s->op_clk);\r\nreturn 0;\r\n}\r\n}\r\ni2s->op_clk = clk_get(&i2s->pdev->dev,\r\ni2s->src_clk[clk_id]);\r\nclk_enable(i2s->op_clk);\r\ni2s->rclk_srcrate = clk_get_rate(i2s->op_clk);\r\nif (other) {\r\nother->op_clk = i2s->op_clk;\r\nother->rclk_srcrate = i2s->rclk_srcrate;\r\n}\r\n} else if ((!clk_id && (mod & MOD_IMS_SYSMUX))\r\n|| (clk_id && !(mod & MOD_IMS_SYSMUX))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n} else {\r\ni2s->op_clk = other->op_clk;\r\ni2s->rclk_srcrate = other->rclk_srcrate;\r\nreturn 0;\r\n}\r\nif (clk_id == 0)\r\nmod &= ~MOD_IMS_SYSMUX;\r\nelse\r\nmod |= MOD_IMS_SYSMUX;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "We don't serve that!\n");\r\nreturn -EINVAL;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\nreturn 0;\r\n}\r\nstatic int i2s_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nu32 tmp = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ntmp |= MOD_LR_RLOW;\r\ntmp |= MOD_SDF_MSB;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ntmp |= MOD_LR_RLOW;\r\ntmp |= MOD_SDF_LSB;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ntmp |= MOD_SDF_IIS;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nif (tmp & MOD_LR_RLOW)\r\ntmp &= ~MOD_LR_RLOW;\r\nelse\r\ntmp |= MOD_LR_RLOW;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Polarity not supported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ntmp |= MOD_SLAVE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (i2s->rclk_srcrate == 0)\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_RCLKSRC_0,\r\n0, SND_SOC_CLOCK_IN);\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "master/slave format not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (any_active(i2s) &&\r\n((mod & (MOD_SDF_MASK | MOD_LR_RLOW\r\n| MOD_SLAVE)) != tmp)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nmod &= ~(MOD_SDF_MASK | MOD_LR_RLOW | MOD_SLAVE);\r\nmod |= tmp;\r\nwritel(mod, i2s->addr + I2SMOD);\r\nreturn 0;\r\n}\r\nstatic int i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 mod = readl(i2s->addr + I2SMOD);\r\nif (!is_secondary(i2s))\r\nmod &= ~(MOD_DC2_EN | MOD_DC1_EN);\r\nswitch (params_channels(params)) {\r\ncase 6:\r\nmod |= MOD_DC2_EN;\r\ncase 4:\r\nmod |= MOD_DC1_EN;\r\nbreak;\r\ncase 2:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s->dma_playback.dma_size = 4;\r\nelse\r\ni2s->dma_capture.dma_size = 4;\r\nbreak;\r\ncase 1:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s->dma_playback.dma_size = 2;\r\nelse\r\ni2s->dma_capture.dma_size = 2;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "%d channels not supported\n",\r\nparams_channels(params));\r\nreturn -EINVAL;\r\n}\r\nif (is_secondary(i2s))\r\nmod &= ~MOD_BLCS_MASK;\r\nelse\r\nmod &= ~MOD_BLCP_MASK;\r\nif (is_manager(i2s))\r\nmod &= ~MOD_BLC_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8:\r\nif (is_secondary(i2s))\r\nmod |= MOD_BLCS_8BIT;\r\nelse\r\nmod |= MOD_BLCP_8BIT;\r\nif (is_manager(i2s))\r\nmod |= MOD_BLC_8BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nif (is_secondary(i2s))\r\nmod |= MOD_BLCS_16BIT;\r\nelse\r\nmod |= MOD_BLCP_16BIT;\r\nif (is_manager(i2s))\r\nmod |= MOD_BLC_16BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nif (is_secondary(i2s))\r\nmod |= MOD_BLCS_24BIT;\r\nelse\r\nmod |= MOD_BLCP_24BIT;\r\nif (is_manager(i2s))\r\nmod |= MOD_BLC_24BIT;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev, "Format(%d) not supported\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nwritel(mod, i2s->addr + I2SMOD);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_soc_dai_set_dma_data(dai, substream,\r\n(void *)&i2s->dma_playback);\r\nelse\r\nsnd_soc_dai_set_dma_data(dai, substream,\r\n(void *)&i2s->dma_capture);\r\ni2s->frmclk = params_rate(params);\r\nreturn 0;\r\n}\r\nstatic int i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\ni2s->mode |= DAI_OPENED;\r\nif (is_manager(other))\r\ni2s->mode &= ~DAI_MANAGER;\r\nelse\r\ni2s->mode |= DAI_MANAGER;\r\ni2s->rclk_srcrate = 0;\r\nspin_unlock_irqrestore(&lock, flags);\r\nreturn 0;\r\n}\r\nstatic void i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\ni2s->mode &= ~DAI_OPENED;\r\ni2s->mode &= ~DAI_MANAGER;\r\nif (is_opened(other))\r\nother->mode |= DAI_MANAGER;\r\ni2s->rfs = 0;\r\ni2s->bfs = 0;\r\nspin_unlock_irqrestore(&lock, flags);\r\nif (!is_opened(other))\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\r\n0, SND_SOC_CLOCK_IN);\r\n}\r\nstatic int config_setup(struct i2s_dai *i2s)\r\n{\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nunsigned rfs, bfs, blc;\r\nu32 psr;\r\nblc = get_blc(i2s);\r\nbfs = i2s->bfs;\r\nif (!bfs && other)\r\nbfs = other->bfs;\r\nif (!bfs)\r\nbfs = blc * 2;\r\nrfs = i2s->rfs;\r\nif (!rfs && other)\r\nrfs = other->rfs;\r\nif ((rfs == 256 || rfs == 512) && (blc == 24)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%d-RFS not supported for 24-blc\n", rfs);\r\nreturn -EINVAL;\r\n}\r\nif (!rfs) {\r\nif (bfs == 16 || bfs == 32)\r\nrfs = 256;\r\nelse\r\nrfs = 384;\r\n}\r\nif (any_active(i2s) && (get_rfs(i2s) != rfs || get_bfs(i2s) != bfs)) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\nif (is_slave(i2s))\r\nreturn 0;\r\nset_bfs(i2s, bfs);\r\nset_rfs(i2s, rfs);\r\nif (!(i2s->quirks & QUIRK_NO_MUXPSR)) {\r\npsr = i2s->rclk_srcrate / i2s->frmclk / rfs;\r\nwritel(((psr - 1) << 8) | PSR_PSREN, i2s->addr + I2SPSR);\r\ndev_dbg(&i2s->pdev->dev,\r\n"RCLK_SRC=%luHz PSR=%u, RCLK=%dfs, BCLK=%dfs\n",\r\ni2s->rclk_srcrate, psr, rfs, bfs);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nint capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct i2s_dai *i2s = to_info(rtd->cpu_dai);\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nlocal_irq_save(flags);\r\nif (config_setup(i2s)) {\r\nlocal_irq_restore(flags);\r\nreturn -EINVAL;\r\n}\r\nif (capture)\r\ni2s_rxctrl(i2s, 1);\r\nelse\r\ni2s_txctrl(i2s, 1);\r\nlocal_irq_restore(flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nlocal_irq_save(flags);\r\nif (capture) {\r\ni2s_rxctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_RXFLUSH);\r\n} else {\r\ni2s_txctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_TXFLUSH);\r\n}\r\nlocal_irq_restore(flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_set_clkdiv(struct snd_soc_dai *dai,\r\nint div_id, int div)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nswitch (div_id) {\r\ncase SAMSUNG_I2S_DIV_BCLK:\r\nif ((any_active(i2s) && div && (get_bfs(i2s) != div))\r\n|| (other && other->bfs && (other->bfs != div))) {\r\ndev_err(&i2s->pdev->dev,\r\n"%s:%d Other DAI busy\n", __func__, __LINE__);\r\nreturn -EAGAIN;\r\n}\r\ni2s->bfs = div;\r\nbreak;\r\ndefault:\r\ndev_err(&i2s->pdev->dev,\r\n"Invalid clock divider(%d)\n", div_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_sframes_t\r\ni2s_delay(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nu32 reg = readl(i2s->addr + I2SFIC);\r\nsnd_pcm_sframes_t delay;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ndelay = FIC_RXCOUNT(reg);\r\nelse if (is_secondary(i2s))\r\ndelay = FICS_TXCOUNT(readl(i2s->addr + I2SFICS));\r\nelse\r\ndelay = FIC_TXCOUNT(reg);\r\nreturn delay;\r\n}\r\nstatic int i2s_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nif (dai->active) {\r\ni2s->suspend_i2smod = readl(i2s->addr + I2SMOD);\r\ni2s->suspend_i2scon = readl(i2s->addr + I2SCON);\r\ni2s->suspend_i2spsr = readl(i2s->addr + I2SPSR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2s_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nif (dai->active) {\r\nwritel(i2s->suspend_i2scon, i2s->addr + I2SCON);\r\nwritel(i2s->suspend_i2smod, i2s->addr + I2SMOD);\r\nwritel(i2s->suspend_i2spsr, i2s->addr + I2SPSR);\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = to_info(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nif (other && other->clk)\r\ngoto probe_exit;\r\ni2s->addr = ioremap(i2s->base, 0x100);\r\nif (i2s->addr == NULL) {\r\ndev_err(&i2s->pdev->dev, "cannot ioremap registers\n");\r\nreturn -ENXIO;\r\n}\r\ni2s->clk = clk_get(&i2s->pdev->dev, "iis");\r\nif (IS_ERR(i2s->clk)) {\r\ndev_err(&i2s->pdev->dev, "failed to get i2s_clock\n");\r\niounmap(i2s->addr);\r\nreturn -ENOENT;\r\n}\r\nclk_enable(i2s->clk);\r\nif (other) {\r\nother->addr = i2s->addr;\r\nother->clk = i2s->clk;\r\n}\r\nif (i2s->quirks & QUIRK_NEED_RSTCLR)\r\nwritel(CON_RSTCLR, i2s->addr + I2SCON);\r\nif (i2s->quirks & QUIRK_SEC_DAI)\r\nidma_reg_addr_init(i2s->addr,\r\ni2s->sec_dai->idma_playback.dma_addr);\r\nprobe_exit:\r\ni2s->rfs = 0;\r\ni2s->bfs = 0;\r\ni2s_txctrl(i2s, 0);\r\ni2s_rxctrl(i2s, 0);\r\ni2s_fifo(i2s, FIC_TXFLUSH);\r\ni2s_fifo(other, FIC_TXFLUSH);\r\ni2s_fifo(i2s, FIC_RXFLUSH);\r\nif (!is_opened(other))\r\ni2s_set_sysclk(dai, SAMSUNG_I2S_CDCLK,\r\n0, SND_SOC_CLOCK_IN);\r\nreturn 0;\r\n}\r\nstatic int samsung_i2s_dai_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct i2s_dai *i2s = snd_soc_dai_get_drvdata(dai);\r\nstruct i2s_dai *other = i2s->pri_dai ? : i2s->sec_dai;\r\nif (!other || !other->clk) {\r\nif (i2s->quirks & QUIRK_NEED_RSTCLR)\r\nwritel(0, i2s->addr + I2SCON);\r\nclk_disable(i2s->clk);\r\nclk_put(i2s->clk);\r\niounmap(i2s->addr);\r\n}\r\ni2s->clk = NULL;\r\nreturn 0;\r\n}\r\n__devinit int samsung_i2s_probe(struct platform_device *pdev)\r\n{\r\nu32 dma_pl_chan, dma_cp_chan, dma_pl_sec_chan;\r\nstruct i2s_dai *pri_dai, *sec_dai = NULL;\r\nstruct s3c_audio_pdata *i2s_pdata;\r\nstruct samsung_i2s *i2s_cfg;\r\nstruct resource *res;\r\nu32 regs_base, quirks;\r\nint ret = 0;\r\nif (pdev->id >= SAMSUNG_I2S_SECOFF) {\r\nsec_dai = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_register_dai(&sec_dai->pdev->dev,\r\n&sec_dai->i2s_dai_drv);\r\nreturn 0;\r\n}\r\ni2s_pdata = pdev->dev.platform_data;\r\nif (i2s_pdata == NULL) {\r\ndev_err(&pdev->dev, "Can't work without s3c_audio_pdata\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Unable to get I2S-TX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndma_pl_chan = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Unable to get I2S-RX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndma_cp_chan = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 2);\r\nif (res)\r\ndma_pl_sec_chan = res->start;\r\nelse\r\ndma_pl_sec_chan = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Unable to get I2S SFR address\n");\r\nreturn -ENXIO;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\n"samsung-i2s")) {\r\ndev_err(&pdev->dev, "Unable to request SFR region\n");\r\nreturn -EBUSY;\r\n}\r\nregs_base = res->start;\r\ni2s_cfg = &i2s_pdata->type.i2s;\r\nquirks = i2s_cfg->quirks;\r\npri_dai = i2s_alloc_dai(pdev, false);\r\nif (!pri_dai) {\r\ndev_err(&pdev->dev, "Unable to alloc I2S_pri\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npri_dai->dma_playback.dma_addr = regs_base + I2STXD;\r\npri_dai->dma_capture.dma_addr = regs_base + I2SRXD;\r\npri_dai->dma_playback.client =\r\n(struct s3c2410_dma_client *)&pri_dai->dma_playback;\r\npri_dai->dma_capture.client =\r\n(struct s3c2410_dma_client *)&pri_dai->dma_capture;\r\npri_dai->dma_playback.channel = dma_pl_chan;\r\npri_dai->dma_capture.channel = dma_cp_chan;\r\npri_dai->src_clk = i2s_cfg->src_clk;\r\npri_dai->dma_playback.dma_size = 4;\r\npri_dai->dma_capture.dma_size = 4;\r\npri_dai->base = regs_base;\r\npri_dai->quirks = quirks;\r\nif (quirks & QUIRK_PRI_6CHAN)\r\npri_dai->i2s_dai_drv.playback.channels_max = 6;\r\nif (quirks & QUIRK_SEC_DAI) {\r\nsec_dai = i2s_alloc_dai(pdev, true);\r\nif (!sec_dai) {\r\ndev_err(&pdev->dev, "Unable to alloc I2S_sec\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsec_dai->dma_playback.dma_addr = regs_base + I2STXDS;\r\nsec_dai->dma_playback.client =\r\n(struct s3c2410_dma_client *)&sec_dai->dma_playback;\r\nsec_dai->dma_playback.channel = dma_pl_sec_chan ? : -1;\r\nsec_dai->src_clk = i2s_cfg->src_clk;\r\nsec_dai->dma_playback.dma_size = 4;\r\nsec_dai->base = regs_base;\r\nsec_dai->quirks = quirks;\r\nsec_dai->idma_playback.dma_addr = i2s_cfg->idma_addr;\r\nsec_dai->pri_dai = pri_dai;\r\npri_dai->sec_dai = sec_dai;\r\n}\r\nif (i2s_pdata->cfg_gpio && i2s_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure gpio\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nsnd_soc_register_dai(&pri_dai->pdev->dev, &pri_dai->i2s_dai_drv);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nerr:\r\nrelease_mem_region(regs_base, resource_size(res));\r\nreturn ret;\r\n}\r\nstatic __devexit int samsung_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct i2s_dai *i2s, *other;\r\nstruct resource *res;\r\ni2s = dev_get_drvdata(&pdev->dev);\r\nother = i2s->pri_dai ? : i2s->sec_dai;\r\nif (other) {\r\nother->pri_dai = NULL;\r\nother->sec_dai = NULL;\r\n} else {\r\npm_runtime_disable(&pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\n}\r\ni2s->pri_dai = NULL;\r\ni2s->sec_dai = NULL;\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nreturn 0;\r\n}
