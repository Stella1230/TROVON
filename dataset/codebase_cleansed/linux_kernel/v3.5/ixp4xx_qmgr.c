void qmgr_set_irq(unsigned int queue, int src,\r\nvoid (*handler)(void *pdev), void *pdev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&qmgr_lock, flags);\r\nif (queue < HALF_QUEUES) {\r\nu32 __iomem *reg;\r\nint bit;\r\nBUG_ON(src > QUEUE_IRQ_SRC_NOT_FULL);\r\nreg = &qmgr_regs->irqsrc[queue >> 3];\r\nbit = (queue % 8) * 4;\r\n__raw_writel((__raw_readl(reg) & ~(7 << bit)) | (src << bit),\r\nreg);\r\n} else\r\nBUG_ON(src != QUEUE_IRQ_SRC_NOT_NEARLY_EMPTY);\r\nirq_handlers[queue] = handler;\r\nirq_pdevs[queue] = pdev;\r\nspin_unlock_irqrestore(&qmgr_lock, flags);\r\n}\r\nstatic irqreturn_t qmgr_irq1_a0(int irq, void *pdev)\r\n{\r\nint i, ret = 0;\r\nu32 en_bitmap, src, stat;\r\n__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[0]);\r\nen_bitmap = qmgr_regs->irqen[0];\r\nwhile (en_bitmap) {\r\ni = __fls(en_bitmap);\r\nen_bitmap &= ~BIT(i);\r\nsrc = qmgr_regs->irqsrc[i >> 3];\r\nstat = qmgr_regs->stat1[i >> 3];\r\nif (src & 4)\r\nstat = ~stat;\r\nif (stat & BIT(src & 3)) {\r\nirq_handlers[i](irq_pdevs[i]);\r\nret = IRQ_HANDLED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t qmgr_irq2_a0(int irq, void *pdev)\r\n{\r\nint i, ret = 0;\r\nu32 req_bitmap;\r\n__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[1]);\r\nreq_bitmap = qmgr_regs->irqen[1] & qmgr_regs->statne_h;\r\nwhile (req_bitmap) {\r\ni = __fls(req_bitmap);\r\nreq_bitmap &= ~BIT(i);\r\nirq_handlers[HALF_QUEUES + i](irq_pdevs[HALF_QUEUES + i]);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t qmgr_irq(int irq, void *pdev)\r\n{\r\nint i, half = (irq == IRQ_IXP4XX_QM1 ? 0 : 1);\r\nu32 req_bitmap = __raw_readl(&qmgr_regs->irqstat[half]);\r\nif (!req_bitmap)\r\nreturn 0;\r\n__raw_writel(req_bitmap, &qmgr_regs->irqstat[half]);\r\nwhile (req_bitmap) {\r\ni = __fls(req_bitmap);\r\nreq_bitmap &= ~BIT(i);\r\ni += half * HALF_QUEUES;\r\nirq_handlers[i](irq_pdevs[i]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid qmgr_enable_irq(unsigned int queue)\r\n{\r\nunsigned long flags;\r\nint half = queue / 32;\r\nu32 mask = 1 << (queue & (HALF_QUEUES - 1));\r\nspin_lock_irqsave(&qmgr_lock, flags);\r\n__raw_writel(__raw_readl(&qmgr_regs->irqen[half]) | mask,\r\n&qmgr_regs->irqen[half]);\r\nspin_unlock_irqrestore(&qmgr_lock, flags);\r\n}\r\nvoid qmgr_disable_irq(unsigned int queue)\r\n{\r\nunsigned long flags;\r\nint half = queue / 32;\r\nu32 mask = 1 << (queue & (HALF_QUEUES - 1));\r\nspin_lock_irqsave(&qmgr_lock, flags);\r\n__raw_writel(__raw_readl(&qmgr_regs->irqen[half]) & ~mask,\r\n&qmgr_regs->irqen[half]);\r\n__raw_writel(mask, &qmgr_regs->irqstat[half]);\r\nspin_unlock_irqrestore(&qmgr_lock, flags);\r\n}\r\nstatic inline void shift_mask(u32 *mask)\r\n{\r\nmask[3] = mask[3] << 1 | mask[2] >> 31;\r\nmask[2] = mask[2] << 1 | mask[1] >> 31;\r\nmask[1] = mask[1] << 1 | mask[0] >> 31;\r\nmask[0] <<= 1;\r\n}\r\nvoid qmgr_release_queue(unsigned int queue)\r\n{\r\nu32 cfg, addr, mask[4];\r\nBUG_ON(queue >= QUEUES);\r\nspin_lock_irq(&qmgr_lock);\r\ncfg = __raw_readl(&qmgr_regs->sram[queue]);\r\naddr = (cfg >> 14) & 0xFF;\r\nBUG_ON(!addr);\r\nswitch ((cfg >> 24) & 3) {\r\ncase 0: mask[0] = 0x1; break;\r\ncase 1: mask[0] = 0x3; break;\r\ncase 2: mask[0] = 0xF; break;\r\ncase 3: mask[0] = 0xFF; break;\r\n}\r\nmask[1] = mask[2] = mask[3] = 0;\r\nwhile (addr--)\r\nshift_mask(mask);\r\n#if DEBUG_QMGR\r\nprintk(KERN_DEBUG "qmgr: releasing queue %s(%i)\n",\r\nqmgr_queue_descs[queue], queue);\r\nqmgr_queue_descs[queue][0] = '\x0';\r\n#endif\r\nwhile ((addr = qmgr_get_entry(queue)))\r\nprintk(KERN_ERR "qmgr: released queue %i not empty: 0x%08X\n",\r\nqueue, addr);\r\n__raw_writel(0, &qmgr_regs->sram[queue]);\r\nused_sram_bitmap[0] &= ~mask[0];\r\nused_sram_bitmap[1] &= ~mask[1];\r\nused_sram_bitmap[2] &= ~mask[2];\r\nused_sram_bitmap[3] &= ~mask[3];\r\nirq_handlers[queue] = NULL;\r\nspin_unlock_irq(&qmgr_lock);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int qmgr_init(void)\r\n{\r\nint i, err;\r\nirq_handler_t handler1, handler2;\r\nmem_res = request_mem_region(IXP4XX_QMGR_BASE_PHYS,\r\nIXP4XX_QMGR_REGION_SIZE,\r\n"IXP4xx Queue Manager");\r\nif (mem_res == NULL)\r\nreturn -EBUSY;\r\nqmgr_regs = ioremap(IXP4XX_QMGR_BASE_PHYS, IXP4XX_QMGR_REGION_SIZE);\r\nif (qmgr_regs == NULL) {\r\nerr = -ENOMEM;\r\ngoto error_map;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\n__raw_writel(0x33333333, &qmgr_regs->stat1[i]);\r\n__raw_writel(0, &qmgr_regs->irqsrc[i]);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\n__raw_writel(0, &qmgr_regs->stat2[i]);\r\n__raw_writel(0xFFFFFFFF, &qmgr_regs->irqstat[i]);\r\n__raw_writel(0, &qmgr_regs->irqen[i]);\r\n}\r\n__raw_writel(0xFFFFFFFF, &qmgr_regs->statne_h);\r\n__raw_writel(0, &qmgr_regs->statf_h);\r\nfor (i = 0; i < QUEUES; i++)\r\n__raw_writel(0, &qmgr_regs->sram[i]);\r\nif (cpu_is_ixp42x_rev_a0()) {\r\nhandler1 = qmgr_irq1_a0;\r\nhandler2 = qmgr_irq2_a0;\r\n} else\r\nhandler1 = handler2 = qmgr_irq;\r\nerr = request_irq(IRQ_IXP4XX_QM1, handler1, 0, "IXP4xx Queue Manager",\r\nNULL);\r\nif (err) {\r\nprintk(KERN_ERR "qmgr: failed to request IRQ%i (%i)\n",\r\nIRQ_IXP4XX_QM1, err);\r\ngoto error_irq;\r\n}\r\nerr = request_irq(IRQ_IXP4XX_QM2, handler2, 0, "IXP4xx Queue Manager",\r\nNULL);\r\nif (err) {\r\nprintk(KERN_ERR "qmgr: failed to request IRQ%i (%i)\n",\r\nIRQ_IXP4XX_QM2, err);\r\ngoto error_irq2;\r\n}\r\nused_sram_bitmap[0] = 0xF;\r\nspin_lock_init(&qmgr_lock);\r\nprintk(KERN_INFO "IXP4xx Queue Manager initialized.\n");\r\nreturn 0;\r\nerror_irq2:\r\nfree_irq(IRQ_IXP4XX_QM1, NULL);\r\nerror_irq:\r\niounmap(qmgr_regs);\r\nerror_map:\r\nrelease_mem_region(IXP4XX_QMGR_BASE_PHYS, IXP4XX_QMGR_REGION_SIZE);\r\nreturn err;\r\n}\r\nstatic void qmgr_remove(void)\r\n{\r\nfree_irq(IRQ_IXP4XX_QM1, NULL);\r\nfree_irq(IRQ_IXP4XX_QM2, NULL);\r\nsynchronize_irq(IRQ_IXP4XX_QM1);\r\nsynchronize_irq(IRQ_IXP4XX_QM2);\r\niounmap(qmgr_regs);\r\nrelease_mem_region(IXP4XX_QMGR_BASE_PHYS, IXP4XX_QMGR_REGION_SIZE);\r\n}
