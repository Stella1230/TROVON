static struct sh_mipi *sh_mipi_by_handle(int handle)\r\n{\r\nif (handle >= ARRAY_SIZE(mipi_dsi) || handle < 0)\r\nreturn NULL;\r\nreturn mipi_dsi[handle];\r\n}\r\nstatic int sh_mipi_send_short(struct sh_mipi *mipi, u8 dsi_cmd,\r\nu8 cmd, u8 param)\r\n{\r\nu32 data = (dsi_cmd << 24) | (cmd << 16) | (param << 8);\r\nint cnt = 100;\r\niowrite32(1 | data, mipi->linkbase + CMTSRTCTR);\r\niowrite32(1, mipi->linkbase + CMTSRTREQ);\r\nwhile ((ioread32(mipi->linkbase + CMTSRTREQ) & 1) && --cnt)\r\nudelay(1);\r\nreturn cnt ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int sh_mipi_dcs(int handle, u8 cmd)\r\n{\r\nstruct sh_mipi *mipi = sh_mipi_by_handle(LCD_CHAN2MIPI(handle));\r\nif (!mipi)\r\nreturn -ENODEV;\r\nreturn sh_mipi_send_short(mipi, MIPI_DSI_DCS_SHORT_WRITE, cmd, 0);\r\n}\r\nstatic int sh_mipi_dcs_param(int handle, u8 cmd, u8 param)\r\n{\r\nstruct sh_mipi *mipi = sh_mipi_by_handle(LCD_CHAN2MIPI(handle));\r\nif (!mipi)\r\nreturn -ENODEV;\r\nreturn sh_mipi_send_short(mipi, MIPI_DSI_DCS_SHORT_WRITE_PARAM, cmd,\r\nparam);\r\n}\r\nstatic void sh_mipi_dsi_enable(struct sh_mipi *mipi, bool enable)\r\n{\r\niowrite32(0x00000002 | enable, mipi->linkbase + DTCTR);\r\n}\r\nstatic void sh_mipi_shutdown(struct platform_device *pdev)\r\n{\r\nstruct sh_mipi *mipi = to_sh_mipi(platform_get_drvdata(pdev));\r\nsh_mipi_dsi_enable(mipi, false);\r\n}\r\nstatic int __init sh_mipi_setup(struct sh_mipi *mipi,\r\nstruct sh_mipi_dsi_info *pdata)\r\n{\r\nvoid __iomem *base = mipi->base;\r\nstruct sh_mobile_lcdc_chan_cfg *ch = pdata->lcd_chan;\r\nu32 pctype, datatype, pixfmt, linelength, vmctr2;\r\nu32 tmp, top, bottom, delay, div;\r\nbool yuv;\r\nint bpp;\r\nswitch (pdata->data_format) {\r\ncase MIPI_RGB888:\r\npctype = 0;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_24;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_modes[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_RGB565:\r\npctype = 1;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_modes[0].xres * 2;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_RGB666_LP:\r\npctype = 2;\r\ndatatype = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_modes[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_RGB666:\r\npctype = 3;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_18BIT;\r\nlinelength = (ch->lcd_modes[0].xres * 18 + 7) / 8;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR888:\r\npctype = 8;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_24;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_modes[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR565:\r\npctype = 9;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_modes[0].xres * 2;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR666_LP:\r\npctype = 0xa;\r\ndatatype = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_24BIT;\r\nlinelength = ch->lcd_modes[0].xres * 3;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_BGR666:\r\npctype = 0xb;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_18;\r\npixfmt = MIPI_DCS_PIXEL_FMT_18BIT;\r\nlinelength = (ch->lcd_modes[0].xres * 18 + 7) / 8;\r\nyuv = false;\r\nbreak;\r\ncase MIPI_YUYV:\r\npctype = 4;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_modes[0].xres * 2;\r\nyuv = true;\r\nbreak;\r\ncase MIPI_UYVY:\r\npctype = 5;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16;\r\npixfmt = MIPI_DCS_PIXEL_FMT_16BIT;\r\nlinelength = ch->lcd_modes[0].xres * 2;\r\nyuv = true;\r\nbreak;\r\ncase MIPI_YUV420_L:\r\npctype = 6;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12;\r\npixfmt = MIPI_DCS_PIXEL_FMT_12BIT;\r\nlinelength = (ch->lcd_modes[0].xres * 12 + 7) / 8;\r\nyuv = true;\r\nbreak;\r\ncase MIPI_YUV420:\r\npctype = 7;\r\ndatatype = MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12;\r\npixfmt = MIPI_DCS_PIXEL_FMT_12BIT;\r\nlinelength = (ch->lcd_modes[0].xres + 1) / 2;\r\nyuv = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((yuv && ch->interface_type != YUV422) ||\r\n(!yuv && ch->interface_type != RGB24))\r\nreturn -EINVAL;\r\nif (!pdata->lane)\r\nreturn -EINVAL;\r\niowrite32(0x00000001, base + SYSCTRL);\r\nudelay(50);\r\niowrite32(0x00000000, base + SYSCTRL);\r\niowrite32(0x70003332, base + TIMSET);\r\niowrite32(0x00000000, base + RESREQSET0);\r\niowrite32(0x00000100, base + RESREQSET1);\r\niowrite32(0x0fffffff, base + HSTTOVSET);\r\niowrite32(0x0fffffff, base + LPRTOVSET);\r\niowrite32(0x0fffffff, base + TATOVSET);\r\niowrite32(0x0fffffff, base + PRTOVSET);\r\niowrite32(0, base + DSIINTE);\r\niowrite32(0x00000001, base + PHYCTRL);\r\nudelay(200);\r\niowrite32(0x03070001 | pdata->phyctrl, base + PHYCTRL);\r\nbitmap_fill((unsigned long *)&tmp, pdata->lane);\r\ntmp |= 0x00003700;\r\niowrite32(tmp, base + SYSCONF);\r\niowrite32(0x00000006, mipi->linkbase + DTCTR);\r\niowrite32((ch->lcd_modes[0].vsync_len << pdata->vsynw_offset) |\r\n(pdata->clksrc << 16) | (pctype << 12) | datatype,\r\nmipi->linkbase + VMCTR1);\r\nvmctr2 = 0;\r\nif (pdata->flags & SH_MIPI_DSI_VSEE)\r\nvmctr2 |= 1 << 23;\r\nif (pdata->flags & SH_MIPI_DSI_HSEE)\r\nvmctr2 |= 1 << 22;\r\nif (pdata->flags & SH_MIPI_DSI_HSAE)\r\nvmctr2 |= 1 << 21;\r\nif (pdata->flags & SH_MIPI_DSI_BL2E)\r\nvmctr2 |= 1 << 17;\r\nif (pdata->flags & SH_MIPI_DSI_HSABM)\r\nvmctr2 |= 1 << 5;\r\nif (pdata->flags & SH_MIPI_DSI_HBPBM)\r\nvmctr2 |= 1 << 4;\r\nif (pdata->flags & SH_MIPI_DSI_HFPBM)\r\nvmctr2 |= 1 << 3;\r\niowrite32(vmctr2, mipi->linkbase + VMCTR2);\r\ntop = linelength << 16;\r\nbottom = 0x00000001;\r\nif (pdata->flags & SH_MIPI_DSI_HSABM)\r\nbottom = (pdata->lane * ch->lcd_modes[0].hsync_len) - 10;\r\niowrite32(top | bottom , mipi->linkbase + VMLEN1);\r\ntop = 0x00010000;\r\nbottom = 0x00000001;\r\ndelay = 0;\r\ndiv = 1;\r\nif (pdata->flags & SH_MIPI_DSI_HS4divCLK)\r\ndiv = 2;\r\nif (pdata->flags & SH_MIPI_DSI_HFPBM) {\r\ntop = ch->lcd_modes[0].hsync_len + ch->lcd_modes[0].left_margin;\r\ntop = ((pdata->lane * top / div) - 10) << 16;\r\n}\r\nif (pdata->flags & SH_MIPI_DSI_HBPBM) {\r\nbottom = ch->lcd_modes[0].right_margin;\r\nbottom = (pdata->lane * bottom / div) - 12;\r\n}\r\nbpp = linelength / ch->lcd_modes[0].xres;\r\nif ((pdata->lane / div) > bpp) {\r\ntmp = ch->lcd_modes[0].xres / bpp;\r\ntmp = ch->lcd_modes[0].xres - tmp;\r\ndelay = (pdata->lane * tmp);\r\n}\r\niowrite32(top | (bottom + delay) , mipi->linkbase + VMLEN2);\r\nmsleep(5);\r\nsh_mipi_dcs(ch->chan, MIPI_DCS_EXIT_SLEEP_MODE);\r\nmsleep(120);\r\nsh_mipi_dcs_param(ch->chan, MIPI_DCS_SET_ADDRESS_MODE, 0x00);\r\nsh_mipi_dcs_param(ch->chan, MIPI_DCS_SET_PIXEL_FORMAT,\r\npixfmt << 4);\r\nsh_mipi_dcs(ch->chan, MIPI_DCS_SET_DISPLAY_ON);\r\niowrite32(0x00000f00, base + DSICTRL);\r\nreturn 0;\r\n}\r\nstatic int mipi_display_on(struct sh_mobile_lcdc_entity *entity)\r\n{\r\nstruct sh_mipi *mipi = to_sh_mipi(entity);\r\nstruct sh_mipi_dsi_info *pdata = mipi->pdev->dev.platform_data;\r\nint ret;\r\npm_runtime_get_sync(&mipi->pdev->dev);\r\nret = pdata->set_dot_clock(mipi->pdev, mipi->base, 1);\r\nif (ret < 0)\r\ngoto mipi_display_on_fail1;\r\nret = sh_mipi_setup(mipi, pdata);\r\nif (ret < 0)\r\ngoto mipi_display_on_fail2;\r\nsh_mipi_dsi_enable(mipi, true);\r\nreturn SH_MOBILE_LCDC_DISPLAY_CONNECTED;\r\nmipi_display_on_fail1:\r\npm_runtime_put_sync(&mipi->pdev->dev);\r\nmipi_display_on_fail2:\r\npdata->set_dot_clock(mipi->pdev, mipi->base, 0);\r\nreturn ret;\r\n}\r\nstatic void mipi_display_off(struct sh_mobile_lcdc_entity *entity)\r\n{\r\nstruct sh_mipi *mipi = to_sh_mipi(entity);\r\nstruct sh_mipi_dsi_info *pdata = mipi->pdev->dev.platform_data;\r\nsh_mipi_dsi_enable(mipi, false);\r\npdata->set_dot_clock(mipi->pdev, mipi->base, 0);\r\npm_runtime_put_sync(&mipi->pdev->dev);\r\n}\r\nstatic int __init sh_mipi_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mipi *mipi;\r\nstruct sh_mipi_dsi_info *pdata = pdev->dev.platform_data;\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *res2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nunsigned long rate, f_current;\r\nint idx = pdev->id, ret;\r\nif (!res || !res2 || idx >= ARRAY_SIZE(mipi_dsi) || !pdata)\r\nreturn -ENODEV;\r\nif (!pdata->set_dot_clock)\r\nreturn -EINVAL;\r\nmutex_lock(&array_lock);\r\nif (idx < 0)\r\nfor (idx = 0; idx < ARRAY_SIZE(mipi_dsi) && mipi_dsi[idx]; idx++)\r\n;\r\nif (idx == ARRAY_SIZE(mipi_dsi)) {\r\nret = -EBUSY;\r\ngoto efindslot;\r\n}\r\nmipi = kzalloc(sizeof(*mipi), GFP_KERNEL);\r\nif (!mipi) {\r\nret = -ENOMEM;\r\ngoto ealloc;\r\n}\r\nmipi->entity.owner = THIS_MODULE;\r\nmipi->entity.ops = &mipi_ops;\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "MIPI register region already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqreg;\r\n}\r\nmipi->base = ioremap(res->start, resource_size(res));\r\nif (!mipi->base) {\r\nret = -ENOMEM;\r\ngoto emap;\r\n}\r\nif (!request_mem_region(res2->start, resource_size(res2), pdev->name)) {\r\ndev_err(&pdev->dev, "MIPI register region 2 already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqreg2;\r\n}\r\nmipi->linkbase = ioremap(res2->start, resource_size(res2));\r\nif (!mipi->linkbase) {\r\nret = -ENOMEM;\r\ngoto emap2;\r\n}\r\nmipi->pdev = pdev;\r\nmipi->dsit_clk = clk_get(&pdev->dev, "dsit_clk");\r\nif (IS_ERR(mipi->dsit_clk)) {\r\nret = PTR_ERR(mipi->dsit_clk);\r\ngoto eclktget;\r\n}\r\nf_current = clk_get_rate(mipi->dsit_clk);\r\nrate = clk_round_rate(mipi->dsit_clk, 80000000);\r\nif (rate > 0 && rate != f_current)\r\nret = clk_set_rate(mipi->dsit_clk, rate);\r\nelse\r\nret = rate;\r\nif (ret < 0)\r\ngoto esettrate;\r\ndev_dbg(&pdev->dev, "DSI-T clk %lu -> %lu\n", f_current, rate);\r\nret = clk_enable(mipi->dsit_clk);\r\nif (ret < 0)\r\ngoto eclkton;\r\nmipi_dsi[idx] = mipi;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_resume(&pdev->dev);\r\nmutex_unlock(&array_lock);\r\nplatform_set_drvdata(pdev, &mipi->entity);\r\nreturn 0;\r\neclkton:\r\nesettrate:\r\nclk_put(mipi->dsit_clk);\r\neclktget:\r\niounmap(mipi->linkbase);\r\nemap2:\r\nrelease_mem_region(res2->start, resource_size(res2));\r\nereqreg2:\r\niounmap(mipi->base);\r\nemap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nereqreg:\r\nkfree(mipi);\r\nealloc:\r\nefindslot:\r\nmutex_unlock(&array_lock);\r\nreturn ret;\r\n}\r\nstatic int __exit sh_mipi_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *res2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nstruct sh_mipi *mipi = to_sh_mipi(platform_get_drvdata(pdev));\r\nint i, ret;\r\nmutex_lock(&array_lock);\r\nfor (i = 0; i < ARRAY_SIZE(mipi_dsi) && mipi_dsi[i] != mipi; i++)\r\n;\r\nif (i == ARRAY_SIZE(mipi_dsi)) {\r\nret = -EINVAL;\r\n} else {\r\nret = 0;\r\nmipi_dsi[i] = NULL;\r\n}\r\nmutex_unlock(&array_lock);\r\nif (ret < 0)\r\nreturn ret;\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable(mipi->dsit_clk);\r\nclk_put(mipi->dsit_clk);\r\niounmap(mipi->linkbase);\r\nif (res2)\r\nrelease_mem_region(res2->start, resource_size(res2));\r\niounmap(mipi->base);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(mipi);\r\nreturn 0;\r\n}\r\nstatic int __init sh_mipi_init(void)\r\n{\r\nreturn platform_driver_probe(&sh_mipi_driver, sh_mipi_probe);\r\n}\r\nstatic void __exit sh_mipi_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mipi_driver);\r\n}
