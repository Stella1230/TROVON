static inline void\r\ncyber2000_crtcw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\r\n{\r\ncyber2000fb_writew((reg & 255) | val << 8, 0x3d4, cfb);\r\n}\r\nstatic inline void\r\ncyber2000_grphw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\r\n{\r\ncyber2000fb_writew((reg & 255) | val << 8, 0x3ce, cfb);\r\n}\r\nstatic inline unsigned int\r\ncyber2000_grphr(unsigned int reg, struct cfb_info *cfb)\r\n{\r\ncyber2000fb_writeb(reg, 0x3ce, cfb);\r\nreturn cyber2000fb_readb(0x3cf, cfb);\r\n}\r\nstatic inline void\r\ncyber2000_attrw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\r\n{\r\ncyber2000fb_readb(0x3da, cfb);\r\ncyber2000fb_writeb(reg, 0x3c0, cfb);\r\ncyber2000fb_readb(0x3c1, cfb);\r\ncyber2000fb_writeb(val, 0x3c0, cfb);\r\n}\r\nstatic inline void\r\ncyber2000_seqw(unsigned int reg, unsigned int val, struct cfb_info *cfb)\r\n{\r\ncyber2000fb_writew((reg & 255) | val << 8, 0x3c4, cfb);\r\n}\r\nstatic void\r\ncyber2000fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nunsigned long dst, col;\r\nif (!(cfb->fb.var.accel_flags & FB_ACCELF_TEXT)) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\ncyber2000fb_writeb(0, CO_REG_CONTROL, cfb);\r\ncyber2000fb_writew(rect->width - 1, CO_REG_PIXWIDTH, cfb);\r\ncyber2000fb_writew(rect->height - 1, CO_REG_PIXHEIGHT, cfb);\r\ncol = rect->color;\r\nif (cfb->fb.var.bits_per_pixel > 8)\r\ncol = ((u32 *)cfb->fb.pseudo_palette)[col];\r\ncyber2000fb_writel(col, CO_REG_FGCOLOUR, cfb);\r\ndst = rect->dx + rect->dy * cfb->fb.var.xres_virtual;\r\nif (cfb->fb.var.bits_per_pixel == 24) {\r\ncyber2000fb_writeb(dst, CO_REG_X_PHASE, cfb);\r\ndst *= 3;\r\n}\r\ncyber2000fb_writel(dst, CO_REG_DEST_PTR, cfb);\r\ncyber2000fb_writeb(CO_FG_MIX_SRC, CO_REG_FGMIX, cfb);\r\ncyber2000fb_writew(CO_CMD_L_PATTERN_FGCOL, CO_REG_CMD_L, cfb);\r\ncyber2000fb_writew(CO_CMD_H_BLITTER, CO_REG_CMD_H, cfb);\r\n}\r\nstatic void\r\ncyber2000fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nunsigned int cmd = CO_CMD_L_PATTERN_FGCOL;\r\nunsigned long src, dst;\r\nif (!(cfb->fb.var.accel_flags & FB_ACCELF_TEXT)) {\r\ncfb_copyarea(info, region);\r\nreturn;\r\n}\r\ncyber2000fb_writeb(0, CO_REG_CONTROL, cfb);\r\ncyber2000fb_writew(region->width - 1, CO_REG_PIXWIDTH, cfb);\r\ncyber2000fb_writew(region->height - 1, CO_REG_PIXHEIGHT, cfb);\r\nsrc = region->sx + region->sy * cfb->fb.var.xres_virtual;\r\ndst = region->dx + region->dy * cfb->fb.var.xres_virtual;\r\nif (region->sx < region->dx) {\r\nsrc += region->width - 1;\r\ndst += region->width - 1;\r\ncmd |= CO_CMD_L_INC_LEFT;\r\n}\r\nif (region->sy < region->dy) {\r\nsrc += (region->height - 1) * cfb->fb.var.xres_virtual;\r\ndst += (region->height - 1) * cfb->fb.var.xres_virtual;\r\ncmd |= CO_CMD_L_INC_UP;\r\n}\r\nif (cfb->fb.var.bits_per_pixel == 24) {\r\ncyber2000fb_writeb(dst, CO_REG_X_PHASE, cfb);\r\nsrc *= 3;\r\ndst *= 3;\r\n}\r\ncyber2000fb_writel(src, CO_REG_SRC1_PTR, cfb);\r\ncyber2000fb_writel(dst, CO_REG_DEST_PTR, cfb);\r\ncyber2000fb_writew(CO_FG_MIX_SRC, CO_REG_FGMIX, cfb);\r\ncyber2000fb_writew(cmd, CO_REG_CMD_L, cfb);\r\ncyber2000fb_writew(CO_CMD_H_FGSRCMAP | CO_CMD_H_BLITTER,\r\nCO_REG_CMD_H, cfb);\r\n}\r\nstatic void\r\ncyber2000fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nstatic int cyber2000fb_sync(struct fb_info *info)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nint count = 100000;\r\nif (!(cfb->fb.var.accel_flags & FB_ACCELF_TEXT))\r\nreturn 0;\r\nwhile (cyber2000fb_readb(CO_REG_CONTROL, cfb) & CO_CTRL_BUSY) {\r\nif (!count--) {\r\ndebug_printf("accel_wait timed out\n");\r\ncyber2000fb_writeb(0, CO_REG_CONTROL, cfb);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 convert_bitfield(u_int val, struct fb_bitfield *bf)\r\n{\r\nu_int mask = (1 << bf->length) - 1;\r\nreturn (val >> (16 - bf->length) & mask) << bf->offset;\r\n}\r\nstatic int\r\ncyber2000fb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nstruct fb_var_screeninfo *var = &cfb->fb.var;\r\nu32 pseudo_val;\r\nint ret = 1;\r\nswitch (cfb->fb.fix.visual) {\r\ndefault:\r\nreturn 1;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno >= NR_PALETTE)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\ncfb->palette[regno].red = red;\r\ncfb->palette[regno].green = green;\r\ncfb->palette[regno].blue = blue;\r\ncyber2000fb_writeb(regno, 0x3c8, cfb);\r\ncyber2000fb_writeb(red, 0x3c9, cfb);\r\ncyber2000fb_writeb(green, 0x3c9, cfb);\r\ncyber2000fb_writeb(blue, 0x3c9, cfb);\r\nreturn 0;\r\ncase FB_VISUAL_DIRECTCOLOR:\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nif (var->green.length == 6 && regno < 64) {\r\ncfb->palette[regno << 2].green = green;\r\ncyber2000fb_writeb(regno << 2, 0x3c8, cfb);\r\ncyber2000fb_writeb(cfb->palette[regno >> 1].red,\r\n0x3c9, cfb);\r\ncyber2000fb_writeb(green, 0x3c9, cfb);\r\ncyber2000fb_writeb(cfb->palette[regno >> 1].blue,\r\n0x3c9, cfb);\r\ngreen = cfb->palette[regno << 3].green;\r\nret = 0;\r\n}\r\nif (var->green.length >= 5 && regno < 32) {\r\ncfb->palette[regno << 3].red = red;\r\ncfb->palette[regno << 3].green = green;\r\ncfb->palette[regno << 3].blue = blue;\r\ncyber2000fb_writeb(regno << 3, 0x3c8, cfb);\r\ncyber2000fb_writeb(red, 0x3c9, cfb);\r\ncyber2000fb_writeb(green, 0x3c9, cfb);\r\ncyber2000fb_writeb(blue, 0x3c9, cfb);\r\nret = 0;\r\n}\r\nif (var->green.length == 4 && regno < 16) {\r\ncfb->palette[regno << 4].red = red;\r\ncfb->palette[regno << 4].green = green;\r\ncfb->palette[regno << 4].blue = blue;\r\ncyber2000fb_writeb(regno << 4, 0x3c8, cfb);\r\ncyber2000fb_writeb(red, 0x3c9, cfb);\r\ncyber2000fb_writeb(green, 0x3c9, cfb);\r\ncyber2000fb_writeb(blue, 0x3c9, cfb);\r\nret = 0;\r\n}\r\npseudo_val = regno << var->red.offset |\r\nregno << var->green.offset |\r\nregno << var->blue.offset;\r\nbreak;\r\ncase FB_VISUAL_TRUECOLOR:\r\npseudo_val = convert_bitfield(transp ^ 0xffff, &var->transp);\r\npseudo_val |= convert_bitfield(red, &var->red);\r\npseudo_val |= convert_bitfield(green, &var->green);\r\npseudo_val |= convert_bitfield(blue, &var->blue);\r\nret = 0;\r\nbreak;\r\n}\r\nif (regno < 16)\r\n((u32 *)cfb->fb.pseudo_palette)[regno] = pseudo_val;\r\nreturn ret;\r\n}\r\nstatic void cyber2000fb_write_ramdac_ctrl(struct cfb_info *cfb)\r\n{\r\nunsigned int i;\r\nunsigned int val = cfb->ramdac_ctrl | cfb->ramdac_powerdown;\r\ncyber2000fb_writeb(0x56, 0x3ce, cfb);\r\ni = cyber2000fb_readb(0x3cf, cfb);\r\ncyber2000fb_writeb(i | 4, 0x3cf, cfb);\r\ncyber2000fb_writeb(val, 0x3c6, cfb);\r\ncyber2000fb_writeb(i, 0x3cf, cfb);\r\ncyber2000fb_readb(0x3cf, cfb);\r\n}\r\nstatic void cyber2000fb_set_timing(struct cfb_info *cfb, struct par_info *hw)\r\n{\r\nu_int i;\r\nfor (i = 0; i < NR_PALETTE; i++) {\r\ncyber2000fb_writeb(i, 0x3c8, cfb);\r\ncyber2000fb_writeb(0, 0x3c9, cfb);\r\ncyber2000fb_writeb(0, 0x3c9, cfb);\r\ncyber2000fb_writeb(0, 0x3c9, cfb);\r\n}\r\ncyber2000fb_writeb(0xef, 0x3c2, cfb);\r\ncyber2000_crtcw(0x11, 0x0b, cfb);\r\ncyber2000_attrw(0x11, 0x00, cfb);\r\ncyber2000_seqw(0x00, 0x01, cfb);\r\ncyber2000_seqw(0x01, 0x01, cfb);\r\ncyber2000_seqw(0x02, 0x0f, cfb);\r\ncyber2000_seqw(0x03, 0x00, cfb);\r\ncyber2000_seqw(0x04, 0x0e, cfb);\r\ncyber2000_seqw(0x00, 0x03, cfb);\r\nfor (i = 0; i < sizeof(crtc_idx); i++)\r\ncyber2000_crtcw(crtc_idx[i], hw->crtc[i], cfb);\r\nfor (i = 0x0a; i < 0x10; i++)\r\ncyber2000_crtcw(i, 0, cfb);\r\ncyber2000_grphw(EXT_CRT_VRTOFL, hw->crtc_ofl, cfb);\r\ncyber2000_grphw(0x00, 0x00, cfb);\r\ncyber2000_grphw(0x01, 0x00, cfb);\r\ncyber2000_grphw(0x02, 0x00, cfb);\r\ncyber2000_grphw(0x03, 0x00, cfb);\r\ncyber2000_grphw(0x04, 0x00, cfb);\r\ncyber2000_grphw(0x05, 0x60, cfb);\r\ncyber2000_grphw(0x06, 0x05, cfb);\r\ncyber2000_grphw(0x07, 0x0f, cfb);\r\ncyber2000_grphw(0x08, 0xff, cfb);\r\nfor (i = 0; i < 16; i++)\r\ncyber2000_attrw(i, i, cfb);\r\ncyber2000_attrw(0x10, 0x01, cfb);\r\ncyber2000_attrw(0x11, 0x00, cfb);\r\ncyber2000_attrw(0x12, 0x0f, cfb);\r\ncyber2000_attrw(0x13, 0x00, cfb);\r\ncyber2000_attrw(0x14, 0x00, cfb);\r\nspin_lock(&cfb->reg_b0_lock);\r\ncyber2000_grphw(EXT_DCLK_MULT, hw->clock_mult, cfb);\r\ncyber2000_grphw(EXT_DCLK_DIV, hw->clock_div, cfb);\r\ncyber2000_grphw(EXT_MCLK_MULT, cfb->mclk_mult, cfb);\r\ncyber2000_grphw(EXT_MCLK_DIV, cfb->mclk_div, cfb);\r\ncyber2000_grphw(0x90, 0x01, cfb);\r\ncyber2000_grphw(0xb9, 0x80, cfb);\r\ncyber2000_grphw(0xb9, 0x00, cfb);\r\nspin_unlock(&cfb->reg_b0_lock);\r\ncfb->ramdac_ctrl = hw->ramdac;\r\ncyber2000fb_write_ramdac_ctrl(cfb);\r\ncyber2000fb_writeb(0x20, 0x3c0, cfb);\r\ncyber2000fb_writeb(0xff, 0x3c6, cfb);\r\ncyber2000_grphw(0x14, hw->fetch, cfb);\r\ncyber2000_grphw(0x15, ((hw->fetch >> 8) & 0x03) |\r\n((hw->pitch >> 4) & 0x30), cfb);\r\ncyber2000_grphw(EXT_SEQ_MISC, hw->extseqmisc, cfb);\r\ncyber2000fb_writew(hw->width, CO_REG_SRC_WIDTH, cfb);\r\ncyber2000fb_writew(hw->width, CO_REG_DEST_WIDTH, cfb);\r\ncyber2000fb_writeb(hw->co_pixfmt, CO_REG_PIXFMT, cfb);\r\n}\r\nstatic inline int\r\ncyber2000fb_update_start(struct cfb_info *cfb, struct fb_var_screeninfo *var)\r\n{\r\nu_int base = var->yoffset * var->xres_virtual + var->xoffset;\r\nbase *= var->bits_per_pixel;\r\nbase >>= 5;\r\nif (base >= 1 << 20)\r\nreturn -EINVAL;\r\ncyber2000_grphw(0x10, base >> 16 | 0x10, cfb);\r\ncyber2000_crtcw(0x0c, base >> 8, cfb);\r\ncyber2000_crtcw(0x0d, base, cfb);\r\nreturn 0;\r\n}\r\nstatic int\r\ncyber2000fb_decode_crtc(struct par_info *hw, struct cfb_info *cfb,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nu_int Htotal, Hblankend, Hsyncend;\r\nu_int Vtotal, Vdispend, Vblankstart, Vblankend, Vsyncstart, Vsyncend;\r\n#define ENCODE_BIT(v, b1, m, b2) ((((v) >> (b1)) & (m)) << (b2))\r\nhw->crtc[13] = hw->pitch;\r\nhw->crtc[17] = 0xe3;\r\nhw->crtc[14] = 0;\r\nhw->crtc[8] = 0;\r\nHtotal = var->xres + var->right_margin +\r\nvar->hsync_len + var->left_margin;\r\nif (Htotal > 2080)\r\nreturn -EINVAL;\r\nhw->crtc[0] = (Htotal >> 3) - 5;\r\nhw->crtc[1] = (var->xres >> 3) - 1;\r\nhw->crtc[2] = var->xres >> 3;\r\nhw->crtc[4] = (var->xres + var->right_margin) >> 3;\r\nHblankend = (Htotal - 4 * 8) >> 3;\r\nhw->crtc[3] = ENCODE_BIT(Hblankend, 0, 0x1f, 0) |\r\nENCODE_BIT(1, 0, 0x01, 7);\r\nHsyncend = (var->xres + var->right_margin + var->hsync_len) >> 3;\r\nhw->crtc[5] = ENCODE_BIT(Hsyncend, 0, 0x1f, 0) |\r\nENCODE_BIT(Hblankend, 5, 0x01, 7);\r\nVdispend = var->yres - 1;\r\nVsyncstart = var->yres + var->lower_margin;\r\nVsyncend = var->yres + var->lower_margin + var->vsync_len;\r\nVtotal = var->yres + var->lower_margin + var->vsync_len +\r\nvar->upper_margin - 2;\r\nif (Vtotal > 2047)\r\nreturn -EINVAL;\r\nVblankstart = var->yres + 6;\r\nVblankend = Vtotal - 10;\r\nhw->crtc[6] = Vtotal;\r\nhw->crtc[7] = ENCODE_BIT(Vtotal, 8, 0x01, 0) |\r\nENCODE_BIT(Vdispend, 8, 0x01, 1) |\r\nENCODE_BIT(Vsyncstart, 8, 0x01, 2) |\r\nENCODE_BIT(Vblankstart, 8, 0x01, 3) |\r\nENCODE_BIT(1, 0, 0x01, 4) |\r\nENCODE_BIT(Vtotal, 9, 0x01, 5) |\r\nENCODE_BIT(Vdispend, 9, 0x01, 6) |\r\nENCODE_BIT(Vsyncstart, 9, 0x01, 7);\r\nhw->crtc[9] = ENCODE_BIT(0, 0, 0x1f, 0) |\r\nENCODE_BIT(Vblankstart, 9, 0x01, 5) |\r\nENCODE_BIT(1, 0, 0x01, 6);\r\nhw->crtc[10] = Vsyncstart;\r\nhw->crtc[11] = ENCODE_BIT(Vsyncend, 0, 0x0f, 0) |\r\nENCODE_BIT(1, 0, 0x01, 7);\r\nhw->crtc[12] = Vdispend;\r\nhw->crtc[15] = Vblankstart;\r\nhw->crtc[16] = Vblankend;\r\nhw->crtc[18] = 0xff;\r\nhw->crtc_ofl =\r\nENCODE_BIT(Vtotal, 10, 0x01, 0) |\r\nENCODE_BIT(Vdispend, 10, 0x01, 1) |\r\nENCODE_BIT(Vsyncstart, 10, 0x01, 2) |\r\nENCODE_BIT(Vblankstart, 10, 0x01, 3) |\r\nEXT_CRT_VRTOFL_LINECOMP10;\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\r\nhw->crtc_ofl |= EXT_CRT_VRTOFL_INTERLACE;\r\nreturn 0;\r\n}\r\nstatic int\r\ncyber2000fb_decode_clock(struct par_info *hw, struct cfb_info *cfb,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nu_long pll_ps = var->pixclock;\r\nconst u_long ref_ps = cfb->ref_ps;\r\nu_int div2, t_div1, best_div1, best_mult;\r\nint best_diff;\r\nint vco;\r\nfor (div2 = 0; div2 < 4; div2++) {\r\nu_long new_pll;\r\nnew_pll = pll_ps / cfb->divisors[div2];\r\nif (8696 > new_pll && new_pll > 3846) {\r\npll_ps = new_pll;\r\nbreak;\r\n}\r\n}\r\nif (div2 == 4)\r\nreturn -EINVAL;\r\nbest_diff = 0x7fffffff;\r\nbest_mult = 2;\r\nbest_div1 = 32;\r\nfor (t_div1 = 2; t_div1 < 32; t_div1 += 1) {\r\nu_int rr, t_mult, t_pll_ps;\r\nint diff;\r\nrr = ref_ps * t_div1;\r\nt_mult = (rr + pll_ps / 2) / pll_ps;\r\nif (t_mult > 256 || t_mult < 2)\r\ncontinue;\r\nt_pll_ps = (rr + t_mult / 2) / t_mult;\r\ndiff = pll_ps - t_pll_ps;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff < best_diff) {\r\nbest_diff = diff;\r\nbest_mult = t_mult;\r\nbest_div1 = t_div1;\r\n}\r\nif (diff == 0)\r\nbreak;\r\n}\r\nhw->clock_mult = best_mult - 1;\r\nhw->clock_div = div2 << 6 | (best_div1 - 1);\r\nvco = ref_ps * best_div1 / best_mult;\r\nif ((ref_ps == 40690) && (vco < 5556))\r\nhw->clock_div |= EXT_DCLK_DIV_VFSEL;\r\nreturn 0;\r\n}\r\nstatic int\r\ncyber2000fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nstruct par_info hw;\r\nunsigned int mem;\r\nint err;\r\nvar->transp.msb_right = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.offset = 0;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 16:\r\nswitch (var->green.length) {\r\ncase 6:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ndefault:\r\ncase 5:\r\nvar->red.offset = 10;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 4:\r\nvar->transp.offset = 12;\r\nvar->transp.length = 4;\r\nvar->red.offset = 8;\r\nvar->red.length = 4;\r\nvar->green.offset = 4;\r\nvar->green.length = 4;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 4;\r\nbreak;\r\n}\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmem = var->xres_virtual * var->yres_virtual * (var->bits_per_pixel / 8);\r\nif (mem > cfb->fb.fix.smem_len)\r\nvar->yres_virtual = cfb->fb.fix.smem_len * 8 /\r\n(var->bits_per_pixel * var->xres_virtual);\r\nif (var->yres > var->yres_virtual)\r\nvar->yres = var->yres_virtual;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres = var->xres_virtual;\r\nerr = cyber2000fb_decode_clock(&hw, cfb, var);\r\nif (err)\r\nreturn err;\r\nerr = cyber2000fb_decode_crtc(&hw, cfb, var);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int cyber2000fb_set_par(struct fb_info *info)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nstruct fb_var_screeninfo *var = &cfb->fb.var;\r\nstruct par_info hw;\r\nunsigned int mem;\r\nhw.width = var->xres_virtual;\r\nhw.ramdac = RAMDAC_VREFEN | RAMDAC_DAC8BIT;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nhw.co_pixfmt = CO_PIXFMT_8BPP;\r\nhw.pitch = hw.width >> 3;\r\nhw.extseqmisc = EXT_SEQ_MISC_8;\r\nbreak;\r\ncase 16:\r\nhw.co_pixfmt = CO_PIXFMT_16BPP;\r\nhw.pitch = hw.width >> 2;\r\nswitch (var->green.length) {\r\ncase 6:\r\nhw.extseqmisc = EXT_SEQ_MISC_16_RGB565;\r\nbreak;\r\ncase 5:\r\nhw.extseqmisc = EXT_SEQ_MISC_16_RGB555;\r\nbreak;\r\ncase 4:\r\nhw.extseqmisc = EXT_SEQ_MISC_16_RGB444;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase 24:\r\nhw.co_pixfmt = CO_PIXFMT_24BPP;\r\nhw.width *= 3;\r\nhw.pitch = hw.width >> 3;\r\nhw.ramdac |= (RAMDAC_BYPASS | RAMDAC_RAMPWRDN);\r\nhw.extseqmisc = EXT_SEQ_MISC_24_RGB888;\r\nbreak;\r\ncase 32:\r\nhw.co_pixfmt = CO_PIXFMT_32BPP;\r\nhw.pitch = hw.width >> 1;\r\nhw.ramdac |= (RAMDAC_BYPASS | RAMDAC_RAMPWRDN);\r\nhw.extseqmisc = EXT_SEQ_MISC_32;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nBUG_ON(cyber2000fb_decode_clock(&hw, cfb, var) != 0);\r\nBUG_ON(cyber2000fb_decode_crtc(&hw, cfb, var) != 0);\r\nhw.width -= 1;\r\nhw.fetch = hw.pitch;\r\nif (!(cfb->mem_ctl2 & MEM_CTL2_64BIT))\r\nhw.fetch <<= 1;\r\nhw.fetch += 1;\r\ncfb->fb.fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nmem = cfb->fb.fix.line_length * var->yres_virtual;\r\nBUG_ON(mem > cfb->fb.fix.smem_len);\r\nif (var->bits_per_pixel == 8)\r\ncfb->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse if (hw.ramdac & RAMDAC_BYPASS)\r\ncfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse\r\ncfb->fb.fix.visual = FB_VISUAL_DIRECTCOLOR;\r\ncyber2000fb_set_timing(cfb, &hw);\r\ncyber2000fb_update_start(cfb, var);\r\nreturn 0;\r\n}\r\nstatic int\r\ncyber2000fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nif (cyber2000fb_update_start(cfb, var))\r\nreturn -EINVAL;\r\ncfb->fb.var.xoffset = var->xoffset;\r\ncfb->fb.var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\ncfb->fb.var.vmode |= FB_VMODE_YWRAP;\r\n} else {\r\ncfb->fb.var.vmode &= ~FB_VMODE_YWRAP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyber2000fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct cfb_info *cfb = (struct cfb_info *)info;\r\nunsigned int sync = 0;\r\nint i;\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\nsync = EXT_SYNC_CTL_VS_0 | EXT_SYNC_CTL_HS_0;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nsync = EXT_SYNC_CTL_VS_NORMAL | EXT_SYNC_CTL_HS_0;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nsync = EXT_SYNC_CTL_VS_0 | EXT_SYNC_CTL_HS_NORMAL;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ndefault:\r\nbreak;\r\n}\r\ncyber2000_grphw(EXT_SYNC_CTL, sync, cfb);\r\nif (blank <= 1) {\r\ncfb->ramdac_powerdown &= ~(RAMDAC_DACPWRDN | RAMDAC_BYPASS |\r\nRAMDAC_RAMPWRDN);\r\ncyber2000fb_write_ramdac_ctrl(cfb);\r\n}\r\nif (blank) {\r\nfor (i = 0; i < NR_PALETTE; i++) {\r\ncyber2000fb_writeb(i, 0x3c8, cfb);\r\ncyber2000fb_writeb(0, 0x3c9, cfb);\r\ncyber2000fb_writeb(0, 0x3c9, cfb);\r\ncyber2000fb_writeb(0, 0x3c9, cfb);\r\n}\r\n} else {\r\nfor (i = 0; i < NR_PALETTE; i++) {\r\ncyber2000fb_writeb(i, 0x3c8, cfb);\r\ncyber2000fb_writeb(cfb->palette[i].red, 0x3c9, cfb);\r\ncyber2000fb_writeb(cfb->palette[i].green, 0x3c9, cfb);\r\ncyber2000fb_writeb(cfb->palette[i].blue, 0x3c9, cfb);\r\n}\r\n}\r\nif (blank >= 2) {\r\ncfb->ramdac_powerdown |= RAMDAC_DACPWRDN | RAMDAC_BYPASS |\r\nRAMDAC_RAMPWRDN;\r\ncyber2000fb_write_ramdac_ctrl(cfb);\r\n}\r\nreturn 0;\r\n}\r\nvoid cyber2000fb_enable_extregs(struct cfb_info *cfb)\r\n{\r\ncfb->func_use_count += 1;\r\nif (cfb->func_use_count == 1) {\r\nint old;\r\nold = cyber2000_grphr(EXT_FUNC_CTL, cfb);\r\nold |= EXT_FUNC_CTL_EXTREGENBL;\r\ncyber2000_grphw(EXT_FUNC_CTL, old, cfb);\r\n}\r\n}\r\nvoid cyber2000fb_disable_extregs(struct cfb_info *cfb)\r\n{\r\nif (cfb->func_use_count == 1) {\r\nint old;\r\nold = cyber2000_grphr(EXT_FUNC_CTL, cfb);\r\nold &= ~EXT_FUNC_CTL_EXTREGENBL;\r\ncyber2000_grphw(EXT_FUNC_CTL, old, cfb);\r\n}\r\nif (cfb->func_use_count == 0)\r\nprintk(KERN_ERR "disable_extregs: count = 0\n");\r\nelse\r\ncfb->func_use_count -= 1;\r\n}\r\nint cyber2000fb_attach(struct cyberpro_info *info, int idx)\r\n{\r\nif (int_cfb_info != NULL) {\r\ninfo->dev = int_cfb_info->fb.device;\r\n#ifdef CONFIG_FB_CYBER2000_I2C\r\ninfo->i2c = &int_cfb_info->i2c_adapter;\r\n#else\r\ninfo->i2c = NULL;\r\n#endif\r\ninfo->regs = int_cfb_info->regs;\r\ninfo->irq = int_cfb_info->irq;\r\ninfo->fb = int_cfb_info->fb.screen_base;\r\ninfo->fb_size = int_cfb_info->fb.fix.smem_len;\r\ninfo->info = int_cfb_info;\r\nstrlcpy(info->dev_name, int_cfb_info->fb.fix.id,\r\nsizeof(info->dev_name));\r\n}\r\nreturn int_cfb_info != NULL;\r\n}\r\nvoid cyber2000fb_detach(int idx)\r\n{\r\n}\r\nstatic void cyber2000fb_enable_ddc(struct cfb_info *cfb)\r\n{\r\nspin_lock(&cfb->reg_b0_lock);\r\ncyber2000fb_writew(0x1bf, 0x3ce, cfb);\r\n}\r\nstatic void cyber2000fb_disable_ddc(struct cfb_info *cfb)\r\n{\r\ncyber2000fb_writew(0x0bf, 0x3ce, cfb);\r\nspin_unlock(&cfb->reg_b0_lock);\r\n}\r\nstatic void cyber2000fb_ddc_setscl(void *data, int val)\r\n{\r\nstruct cfb_info *cfb = data;\r\nunsigned char reg;\r\ncyber2000fb_enable_ddc(cfb);\r\nreg = cyber2000_grphr(DDC_REG, cfb);\r\nif (!val)\r\nreg |= DDC_SCL_OUT;\r\nelse\r\nreg &= ~DDC_SCL_OUT;\r\ncyber2000_grphw(DDC_REG, reg, cfb);\r\ncyber2000fb_disable_ddc(cfb);\r\n}\r\nstatic void cyber2000fb_ddc_setsda(void *data, int val)\r\n{\r\nstruct cfb_info *cfb = data;\r\nunsigned char reg;\r\ncyber2000fb_enable_ddc(cfb);\r\nreg = cyber2000_grphr(DDC_REG, cfb);\r\nif (!val)\r\nreg |= DDC_SDA_OUT;\r\nelse\r\nreg &= ~DDC_SDA_OUT;\r\ncyber2000_grphw(DDC_REG, reg, cfb);\r\ncyber2000fb_disable_ddc(cfb);\r\n}\r\nstatic int cyber2000fb_ddc_getscl(void *data)\r\n{\r\nstruct cfb_info *cfb = data;\r\nint retval;\r\ncyber2000fb_enable_ddc(cfb);\r\nretval = !!(cyber2000_grphr(DDC_REG, cfb) & DDC_SCL_IN);\r\ncyber2000fb_disable_ddc(cfb);\r\nreturn retval;\r\n}\r\nstatic int cyber2000fb_ddc_getsda(void *data)\r\n{\r\nstruct cfb_info *cfb = data;\r\nint retval;\r\ncyber2000fb_enable_ddc(cfb);\r\nretval = !!(cyber2000_grphr(DDC_REG, cfb) & DDC_SDA_IN);\r\ncyber2000fb_disable_ddc(cfb);\r\nreturn retval;\r\n}\r\nstatic int __devinit cyber2000fb_setup_ddc_bus(struct cfb_info *cfb)\r\n{\r\nstrlcpy(cfb->ddc_adapter.name, cfb->fb.fix.id,\r\nsizeof(cfb->ddc_adapter.name));\r\ncfb->ddc_adapter.owner = THIS_MODULE;\r\ncfb->ddc_adapter.class = I2C_CLASS_DDC;\r\ncfb->ddc_adapter.algo_data = &cfb->ddc_algo;\r\ncfb->ddc_adapter.dev.parent = cfb->fb.device;\r\ncfb->ddc_algo.setsda = cyber2000fb_ddc_setsda;\r\ncfb->ddc_algo.setscl = cyber2000fb_ddc_setscl;\r\ncfb->ddc_algo.getsda = cyber2000fb_ddc_getsda;\r\ncfb->ddc_algo.getscl = cyber2000fb_ddc_getscl;\r\ncfb->ddc_algo.udelay = 10;\r\ncfb->ddc_algo.timeout = 20;\r\ncfb->ddc_algo.data = cfb;\r\ni2c_set_adapdata(&cfb->ddc_adapter, cfb);\r\nreturn i2c_bit_add_bus(&cfb->ddc_adapter);\r\n}\r\nstatic void cyber2000fb_i2c_setsda(void *data, int state)\r\n{\r\nstruct cfb_info *cfb = data;\r\nunsigned int latch2;\r\nspin_lock(&cfb->reg_b0_lock);\r\nlatch2 = cyber2000_grphr(EXT_LATCH2, cfb);\r\nlatch2 &= EXT_LATCH2_I2C_CLKEN;\r\nif (state)\r\nlatch2 |= EXT_LATCH2_I2C_DATEN;\r\ncyber2000_grphw(EXT_LATCH2, latch2, cfb);\r\nspin_unlock(&cfb->reg_b0_lock);\r\n}\r\nstatic void cyber2000fb_i2c_setscl(void *data, int state)\r\n{\r\nstruct cfb_info *cfb = data;\r\nunsigned int latch2;\r\nspin_lock(&cfb->reg_b0_lock);\r\nlatch2 = cyber2000_grphr(EXT_LATCH2, cfb);\r\nlatch2 &= EXT_LATCH2_I2C_DATEN;\r\nif (state)\r\nlatch2 |= EXT_LATCH2_I2C_CLKEN;\r\ncyber2000_grphw(EXT_LATCH2, latch2, cfb);\r\nspin_unlock(&cfb->reg_b0_lock);\r\n}\r\nstatic int cyber2000fb_i2c_getsda(void *data)\r\n{\r\nstruct cfb_info *cfb = data;\r\nint ret;\r\nspin_lock(&cfb->reg_b0_lock);\r\nret = !!(cyber2000_grphr(EXT_LATCH2, cfb) & EXT_LATCH2_I2C_DAT);\r\nspin_unlock(&cfb->reg_b0_lock);\r\nreturn ret;\r\n}\r\nstatic int cyber2000fb_i2c_getscl(void *data)\r\n{\r\nstruct cfb_info *cfb = data;\r\nint ret;\r\nspin_lock(&cfb->reg_b0_lock);\r\nret = !!(cyber2000_grphr(EXT_LATCH2, cfb) & EXT_LATCH2_I2C_CLK);\r\nspin_unlock(&cfb->reg_b0_lock);\r\nreturn ret;\r\n}\r\nstatic int __devinit cyber2000fb_i2c_register(struct cfb_info *cfb)\r\n{\r\nstrlcpy(cfb->i2c_adapter.name, cfb->fb.fix.id,\r\nsizeof(cfb->i2c_adapter.name));\r\ncfb->i2c_adapter.owner = THIS_MODULE;\r\ncfb->i2c_adapter.algo_data = &cfb->i2c_algo;\r\ncfb->i2c_adapter.dev.parent = cfb->fb.device;\r\ncfb->i2c_algo.setsda = cyber2000fb_i2c_setsda;\r\ncfb->i2c_algo.setscl = cyber2000fb_i2c_setscl;\r\ncfb->i2c_algo.getsda = cyber2000fb_i2c_getsda;\r\ncfb->i2c_algo.getscl = cyber2000fb_i2c_getscl;\r\ncfb->i2c_algo.udelay = 5;\r\ncfb->i2c_algo.timeout = msecs_to_jiffies(100);\r\ncfb->i2c_algo.data = cfb;\r\nreturn i2c_bit_add_bus(&cfb->i2c_adapter);\r\n}\r\nstatic void cyber2000fb_i2c_unregister(struct cfb_info *cfb)\r\n{\r\ni2c_del_adapter(&cfb->i2c_adapter);\r\n}\r\nstatic void cyberpro_init_hw(struct cfb_info *cfb)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(igs_regs); i += 2)\r\ncyber2000_grphw(igs_regs[i], igs_regs[i + 1], cfb);\r\nif (cfb->id == ID_CYBERPRO_5000) {\r\nunsigned char val;\r\ncyber2000fb_writeb(0xba, 0x3ce, cfb);\r\nval = cyber2000fb_readb(0x3cf, cfb) & 0x80;\r\ncyber2000fb_writeb(val, 0x3cf, cfb);\r\n}\r\n}\r\nstatic struct cfb_info __devinit *cyberpro_alloc_fb_info(unsigned int id,\r\nchar *name)\r\n{\r\nstruct cfb_info *cfb;\r\ncfb = kzalloc(sizeof(struct cfb_info), GFP_KERNEL);\r\nif (!cfb)\r\nreturn NULL;\r\ncfb->id = id;\r\nif (id == ID_CYBERPRO_5000)\r\ncfb->ref_ps = 40690;\r\nelse\r\ncfb->ref_ps = 69842;\r\ncfb->divisors[0] = 1;\r\ncfb->divisors[1] = 2;\r\ncfb->divisors[2] = 4;\r\nif (id == ID_CYBERPRO_2000)\r\ncfb->divisors[3] = 8;\r\nelse\r\ncfb->divisors[3] = 6;\r\nstrcpy(cfb->fb.fix.id, name);\r\ncfb->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\ncfb->fb.fix.type_aux = 0;\r\ncfb->fb.fix.xpanstep = 0;\r\ncfb->fb.fix.ypanstep = 1;\r\ncfb->fb.fix.ywrapstep = 0;\r\nswitch (id) {\r\ncase ID_IGA_1682:\r\ncfb->fb.fix.accel = 0;\r\nbreak;\r\ncase ID_CYBERPRO_2000:\r\ncfb->fb.fix.accel = FB_ACCEL_IGS_CYBER2000;\r\nbreak;\r\ncase ID_CYBERPRO_2010:\r\ncfb->fb.fix.accel = FB_ACCEL_IGS_CYBER2010;\r\nbreak;\r\ncase ID_CYBERPRO_5000:\r\ncfb->fb.fix.accel = FB_ACCEL_IGS_CYBER5000;\r\nbreak;\r\n}\r\ncfb->fb.var.nonstd = 0;\r\ncfb->fb.var.activate = FB_ACTIVATE_NOW;\r\ncfb->fb.var.height = -1;\r\ncfb->fb.var.width = -1;\r\ncfb->fb.var.accel_flags = FB_ACCELF_TEXT;\r\ncfb->fb.fbops = &cyber2000fb_ops;\r\ncfb->fb.flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\ncfb->fb.pseudo_palette = cfb->pseudo_palette;\r\nspin_lock_init(&cfb->reg_b0_lock);\r\nfb_alloc_cmap(&cfb->fb.cmap, NR_PALETTE, 0);\r\nreturn cfb;\r\n}\r\nstatic void cyberpro_free_fb_info(struct cfb_info *cfb)\r\n{\r\nif (cfb) {\r\nfb_alloc_cmap(&cfb->fb.cmap, 0, 0);\r\nkfree(cfb);\r\n}\r\n}\r\nstatic int cyber2000fb_setup(char *options)\r\n{\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nif (strncmp(opt, "font:", 5) == 0) {\r\nstatic char default_font_storage[40];\r\nstrlcpy(default_font_storage, opt + 5,\r\nsizeof(default_font_storage));\r\ndefault_font = default_font_storage;\r\ncontinue;\r\n}\r\nprintk(KERN_ERR "CyberPro20x0: unknown parameter: %s\n", opt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit cyberpro_common_probe(struct cfb_info *cfb)\r\n{\r\nu_long smem_size;\r\nu_int h_sync, v_sync;\r\nint err;\r\ncyberpro_init_hw(cfb);\r\ncfb->mem_ctl1 = cyber2000_grphr(EXT_MEM_CTL1, cfb);\r\ncfb->mem_ctl2 = cyber2000_grphr(EXT_MEM_CTL2, cfb);\r\nswitch (cfb->mem_ctl2 & MEM_CTL2_SIZE_MASK) {\r\ncase MEM_CTL2_SIZE_4MB:\r\nsmem_size = 0x00400000;\r\nbreak;\r\ncase MEM_CTL2_SIZE_2MB:\r\nsmem_size = 0x00200000;\r\nbreak;\r\ncase MEM_CTL2_SIZE_1MB:\r\nsmem_size = 0x00100000;\r\nbreak;\r\ndefault:\r\nsmem_size = 0x00100000;\r\nbreak;\r\n}\r\ncfb->fb.fix.smem_len = smem_size;\r\ncfb->fb.fix.mmio_len = MMIO_SIZE;\r\ncfb->fb.screen_base = cfb->region;\r\n#ifdef CONFIG_FB_CYBER2000_DDC\r\nif (cyber2000fb_setup_ddc_bus(cfb) == 0)\r\ncfb->ddc_registered = true;\r\n#endif\r\nerr = -EINVAL;\r\nif (!fb_find_mode(&cfb->fb.var, &cfb->fb, NULL, NULL, 0,\r\n&cyber2000fb_default_mode, 8)) {\r\nprintk(KERN_ERR "%s: no valid mode found\n", cfb->fb.fix.id);\r\ngoto failed;\r\n}\r\ncfb->fb.var.yres_virtual = cfb->fb.fix.smem_len * 8 /\r\n(cfb->fb.var.bits_per_pixel * cfb->fb.var.xres_virtual);\r\nif (cfb->fb.var.yres_virtual < cfb->fb.var.yres)\r\ncfb->fb.var.yres_virtual = cfb->fb.var.yres;\r\nh_sync = 1953125000 / cfb->fb.var.pixclock;\r\nh_sync = h_sync * 512 / (cfb->fb.var.xres + cfb->fb.var.left_margin +\r\ncfb->fb.var.right_margin + cfb->fb.var.hsync_len);\r\nv_sync = h_sync / (cfb->fb.var.yres + cfb->fb.var.upper_margin +\r\ncfb->fb.var.lower_margin + cfb->fb.var.vsync_len);\r\nprintk(KERN_INFO "%s: %dKiB VRAM, using %dx%d, %d.%03dkHz, %dHz\n",\r\ncfb->fb.fix.id, cfb->fb.fix.smem_len >> 10,\r\ncfb->fb.var.xres, cfb->fb.var.yres,\r\nh_sync / 1000, h_sync % 1000, v_sync);\r\nerr = cyber2000fb_i2c_register(cfb);\r\nif (err)\r\ngoto failed;\r\nerr = register_framebuffer(&cfb->fb);\r\nif (err)\r\ncyber2000fb_i2c_unregister(cfb);\r\nfailed:\r\n#ifdef CONFIG_FB_CYBER2000_DDC\r\nif (err && cfb->ddc_registered)\r\ni2c_del_adapter(&cfb->ddc_adapter);\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __devexit cyberpro_common_remove(struct cfb_info *cfb)\r\n{\r\nunregister_framebuffer(&cfb->fb);\r\n#ifdef CONFIG_FB_CYBER2000_DDC\r\nif (cfb->ddc_registered)\r\ni2c_del_adapter(&cfb->ddc_adapter);\r\n#endif\r\ncyber2000fb_i2c_unregister(cfb);\r\n}\r\nstatic void cyberpro_common_resume(struct cfb_info *cfb)\r\n{\r\ncyberpro_init_hw(cfb);\r\ncyber2000_grphw(EXT_MEM_CTL1, cfb->mem_ctl1, cfb);\r\ncyber2000_grphw(EXT_MEM_CTL2, cfb->mem_ctl2, cfb);\r\ncyber2000fb_set_par(&cfb->fb);\r\n}\r\nstatic int __devinit cyberpro_vl_probe(void)\r\n{\r\nstruct cfb_info *cfb;\r\nint err = -ENOMEM;\r\nif (!request_mem_region(FB_START, FB_SIZE, "CyberPro2010"))\r\nreturn err;\r\ncfb = cyberpro_alloc_fb_info(ID_CYBERPRO_2010, "CyberPro2010");\r\nif (!cfb)\r\ngoto failed_release;\r\ncfb->irq = -1;\r\ncfb->region = ioremap(FB_START, FB_SIZE);\r\nif (!cfb->region)\r\ngoto failed_ioremap;\r\ncfb->regs = cfb->region + MMIO_OFFSET;\r\ncfb->fb.device = NULL;\r\ncfb->fb.fix.mmio_start = FB_START + MMIO_OFFSET;\r\ncfb->fb.fix.smem_start = FB_START;\r\ncyber2000fb_writeb(0x18, 0x46e8, cfb);\r\ncyber2000fb_writeb(0x01, 0x102, cfb);\r\ncyber2000fb_writeb(0x08, 0x46e8, cfb);\r\ncyber2000fb_writeb(EXT_BIU_MISC, 0x3ce, cfb);\r\ncyber2000fb_writeb(EXT_BIU_MISC_LIN_ENABLE, 0x3cf, cfb);\r\ncfb->mclk_mult = 0xdb;\r\ncfb->mclk_div = 0x54;\r\nerr = cyberpro_common_probe(cfb);\r\nif (err)\r\ngoto failed;\r\nif (int_cfb_info == NULL)\r\nint_cfb_info = cfb;\r\nreturn 0;\r\nfailed:\r\niounmap(cfb->region);\r\nfailed_ioremap:\r\ncyberpro_free_fb_info(cfb);\r\nfailed_release:\r\nrelease_mem_region(FB_START, FB_SIZE);\r\nreturn err;\r\n}\r\nstatic int cyberpro_pci_enable_mmio(struct cfb_info *cfb)\r\n{\r\nunsigned char val;\r\n#if defined(__sparc_v9__)\r\n#error "You lose, consult DaveM."\r\n#elif defined(__sparc__)\r\nunsigned char __iomem *iop;\r\niop = ioremap(0x3000000, 0x5000);\r\nif (iop == NULL) {\r\nprintk(KERN_ERR "iga5000: cannot map I/O\n");\r\nreturn -ENOMEM;\r\n}\r\nwriteb(0x18, iop + 0x46e8);\r\nwriteb(0x01, iop + 0x102);\r\nwriteb(0x08, iop + 0x46e8);\r\nwriteb(EXT_BIU_MISC, iop + 0x3ce);\r\nwriteb(EXT_BIU_MISC_LIN_ENABLE, iop + 0x3cf);\r\niounmap(iop);\r\n#else\r\noutb(0x18, 0x46e8);\r\noutb(0x01, 0x102);\r\noutb(0x08, 0x46e8);\r\noutb(EXT_BIU_MISC, 0x3ce);\r\noutb(EXT_BIU_MISC_LIN_ENABLE, 0x3cf);\r\n#endif\r\nif (cfb->id == ID_CYBERPRO_2010) {\r\nprintk(KERN_INFO "%s: NOT enabling PCI bursts\n",\r\ncfb->fb.fix.id);\r\n} else {\r\nval = cyber2000_grphr(EXT_BUS_CTL, cfb);\r\nif (!(val & EXT_BUS_CTL_PCIBURST_WRITE)) {\r\nprintk(KERN_INFO "%s: enabling PCI bursts\n",\r\ncfb->fb.fix.id);\r\nval |= EXT_BUS_CTL_PCIBURST_WRITE;\r\nif (cfb->id == ID_CYBERPRO_5000)\r\nval |= EXT_BUS_CTL_PCIBURST_READ;\r\ncyber2000_grphw(EXT_BUS_CTL, val, cfb);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\ncyberpro_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct cfb_info *cfb;\r\nchar name[16];\r\nint err;\r\nsprintf(name, "CyberPro%4X", id->device);\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nreturn err;\r\nerr = -ENOMEM;\r\ncfb = cyberpro_alloc_fb_info(id->driver_data, name);\r\nif (!cfb)\r\ngoto failed_release;\r\nerr = pci_request_regions(dev, cfb->fb.fix.id);\r\nif (err)\r\ngoto failed_regions;\r\ncfb->irq = dev->irq;\r\ncfb->region = pci_ioremap_bar(dev, 0);\r\nif (!cfb->region)\r\ngoto failed_ioremap;\r\ncfb->regs = cfb->region + MMIO_OFFSET;\r\ncfb->fb.device = &dev->dev;\r\ncfb->fb.fix.mmio_start = pci_resource_start(dev, 0) + MMIO_OFFSET;\r\ncfb->fb.fix.smem_start = pci_resource_start(dev, 0);\r\nerr = cyberpro_pci_enable_mmio(cfb);\r\nif (err)\r\ngoto failed;\r\ncfb->mclk_mult = cyber2000_grphr(EXT_MCLK_MULT, cfb);\r\ncfb->mclk_div = cyber2000_grphr(EXT_MCLK_DIV, cfb);\r\n#ifdef __arm__\r\nif (machine_is_netwinder()) {\r\ncfb->mclk_mult = 0xdb;\r\ncfb->mclk_div = 0x54;\r\n}\r\n#endif\r\nerr = cyberpro_common_probe(cfb);\r\nif (err)\r\ngoto failed;\r\npci_set_drvdata(dev, cfb);\r\nif (int_cfb_info == NULL)\r\nint_cfb_info = cfb;\r\nreturn 0;\r\nfailed:\r\niounmap(cfb->region);\r\nfailed_ioremap:\r\npci_release_regions(dev);\r\nfailed_regions:\r\ncyberpro_free_fb_info(cfb);\r\nfailed_release:\r\nreturn err;\r\n}\r\nstatic void __devexit cyberpro_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct cfb_info *cfb = pci_get_drvdata(dev);\r\nif (cfb) {\r\ncyberpro_common_remove(cfb);\r\niounmap(cfb->region);\r\ncyberpro_free_fb_info(cfb);\r\npci_set_drvdata(dev, NULL);\r\nif (cfb == int_cfb_info)\r\nint_cfb_info = NULL;\r\npci_release_regions(dev);\r\n}\r\n}\r\nstatic int cyberpro_pci_suspend(struct pci_dev *dev, pm_message_t state)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cyberpro_pci_resume(struct pci_dev *dev)\r\n{\r\nstruct cfb_info *cfb = pci_get_drvdata(dev);\r\nif (cfb) {\r\ncyberpro_pci_enable_mmio(cfb);\r\ncyberpro_common_resume(cfb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cyber2000fb_init(void)\r\n{\r\nint ret = -1, err;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("cyber2000fb", &option))\r\nreturn -ENODEV;\r\ncyber2000fb_setup(option);\r\n#endif\r\n#ifdef CONFIG_ARCH_SHARK\r\nerr = cyberpro_vl_probe();\r\nif (!err)\r\nret = 0;\r\n#endif\r\n#ifdef CONFIG_PCI\r\nerr = pci_register_driver(&cyberpro_driver);\r\nif (!err)\r\nret = 0;\r\n#endif\r\nreturn ret ? err : 0;\r\n}\r\nstatic void __exit cyberpro_exit(void)\r\n{\r\npci_unregister_driver(&cyberpro_driver);\r\n}
