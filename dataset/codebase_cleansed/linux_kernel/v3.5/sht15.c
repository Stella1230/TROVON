static u8 sht15_reverse(u8 byte)\r\n{\r\nu8 i, c;\r\nfor (c = 0, i = 0; i < 8; i++)\r\nc |= (!!(byte & (1 << i))) << (7 - i);\r\nreturn c;\r\n}\r\nstatic u8 sht15_crc8(struct sht15_data *data,\r\nconst u8 *value,\r\nint len)\r\n{\r\nu8 crc = sht15_reverse(data->val_status & 0x0F);\r\nwhile (len--) {\r\ncrc = sht15_crc8_table[*value ^ crc];\r\nvalue++;\r\n}\r\nreturn crc;\r\n}\r\nstatic void sht15_connection_reset(struct sht15_data *data)\r\n{\r\nint i;\r\ngpio_direction_output(data->pdata->gpio_data, 1);\r\nndelay(SHT15_TSCKL);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\nfor (i = 0; i < 9; ++i) {\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\n}\r\n}\r\nstatic inline void sht15_send_bit(struct sht15_data *data, int val)\r\n{\r\ngpio_set_value(data->pdata->gpio_data, val);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\n}\r\nstatic void sht15_transmission_start(struct sht15_data *data)\r\n{\r\ngpio_direction_output(data->pdata->gpio_data, 1);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\ngpio_set_value(data->pdata->gpio_data, 0);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\ngpio_set_value(data->pdata->gpio_data, 1);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\n}\r\nstatic void sht15_send_byte(struct sht15_data *data, u8 byte)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nsht15_send_bit(data, !!(byte & 0x80));\r\nbyte <<= 1;\r\n}\r\n}\r\nstatic int sht15_wait_for_response(struct sht15_data *data)\r\n{\r\ngpio_direction_input(data->pdata->gpio_data);\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\nif (gpio_get_value(data->pdata->gpio_data)) {\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\ndev_err(data->dev, "Command not acknowledged\n");\r\nsht15_connection_reset(data);\r\nreturn -EIO;\r\n}\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\nreturn 0;\r\n}\r\nstatic int sht15_send_cmd(struct sht15_data *data, u8 cmd)\r\n{\r\nint ret = 0;\r\nsht15_transmission_start(data);\r\nsht15_send_byte(data, cmd);\r\nret = sht15_wait_for_response(data);\r\nreturn ret;\r\n}\r\nstatic int sht15_soft_reset(struct sht15_data *data)\r\n{\r\nint ret;\r\nret = sht15_send_cmd(data, SHT15_SOFT_RESET);\r\nif (ret)\r\nreturn ret;\r\nmsleep(SHT15_TSRST);\r\ndata->val_status = 0;\r\nreturn ret;\r\n}\r\nstatic void sht15_ack(struct sht15_data *data)\r\n{\r\ngpio_direction_output(data->pdata->gpio_data, 0);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_data, 1);\r\ngpio_direction_input(data->pdata->gpio_data);\r\n}\r\nstatic void sht15_end_transmission(struct sht15_data *data)\r\n{\r\ngpio_direction_output(data->pdata->gpio_data, 1);\r\nndelay(SHT15_TSU);\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\n}\r\nstatic u8 sht15_read_byte(struct sht15_data *data)\r\n{\r\nint i;\r\nu8 byte = 0;\r\nfor (i = 0; i < 8; ++i) {\r\nbyte <<= 1;\r\ngpio_set_value(data->pdata->gpio_sck, 1);\r\nndelay(SHT15_TSCKH);\r\nbyte |= !!gpio_get_value(data->pdata->gpio_data);\r\ngpio_set_value(data->pdata->gpio_sck, 0);\r\nndelay(SHT15_TSCKL);\r\n}\r\nreturn byte;\r\n}\r\nstatic int sht15_send_status(struct sht15_data *data, u8 status)\r\n{\r\nint ret;\r\nret = sht15_send_cmd(data, SHT15_WRITE_STATUS);\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_output(data->pdata->gpio_data, 1);\r\nndelay(SHT15_TSU);\r\nsht15_send_byte(data, status);\r\nret = sht15_wait_for_response(data);\r\nif (ret)\r\nreturn ret;\r\ndata->val_status = status;\r\nreturn 0;\r\n}\r\nstatic int sht15_update_status(struct sht15_data *data)\r\n{\r\nint ret = 0;\r\nu8 status;\r\nu8 previous_config;\r\nu8 dev_checksum = 0;\r\nu8 checksum_vals[2];\r\nint timeout = HZ;\r\nmutex_lock(&data->read_lock);\r\nif (time_after(jiffies, data->last_status + timeout)\r\n|| !data->status_valid) {\r\nret = sht15_send_cmd(data, SHT15_READ_STATUS);\r\nif (ret)\r\ngoto error_ret;\r\nstatus = sht15_read_byte(data);\r\nif (data->checksumming) {\r\nsht15_ack(data);\r\ndev_checksum = sht15_reverse(sht15_read_byte(data));\r\nchecksum_vals[0] = SHT15_READ_STATUS;\r\nchecksum_vals[1] = status;\r\ndata->checksum_ok = (sht15_crc8(data, checksum_vals, 2)\r\n== dev_checksum);\r\n}\r\nsht15_end_transmission(data);\r\nif (data->checksumming && !data->checksum_ok) {\r\nprevious_config = data->val_status & 0x07;\r\nret = sht15_soft_reset(data);\r\nif (ret)\r\ngoto error_ret;\r\nif (previous_config) {\r\nret = sht15_send_status(data, previous_config);\r\nif (ret) {\r\ndev_err(data->dev,\r\n"CRC validation failed, unable "\r\n"to restore device settings\n");\r\ngoto error_ret;\r\n}\r\n}\r\nret = -EAGAIN;\r\ngoto error_ret;\r\n}\r\ndata->val_status = status;\r\ndata->status_valid = true;\r\ndata->last_status = jiffies;\r\n}\r\nerror_ret:\r\nmutex_unlock(&data->read_lock);\r\nreturn ret;\r\n}\r\nstatic int sht15_measurement(struct sht15_data *data,\r\nint command,\r\nint timeout_msecs)\r\n{\r\nint ret;\r\nu8 previous_config;\r\nret = sht15_send_cmd(data, command);\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_input(data->pdata->gpio_data);\r\natomic_set(&data->interrupt_handled, 0);\r\nenable_irq(gpio_to_irq(data->pdata->gpio_data));\r\nif (gpio_get_value(data->pdata->gpio_data) == 0) {\r\ndisable_irq_nosync(gpio_to_irq(data->pdata->gpio_data));\r\nif (!atomic_read(&data->interrupt_handled))\r\nschedule_work(&data->read_work);\r\n}\r\nret = wait_event_timeout(data->wait_queue,\r\n(data->state == SHT15_READING_NOTHING),\r\nmsecs_to_jiffies(timeout_msecs));\r\nif (ret == 0) {\r\ndisable_irq_nosync(gpio_to_irq(data->pdata->gpio_data));\r\nsht15_connection_reset(data);\r\nreturn -ETIME;\r\n}\r\nif (data->checksumming && !data->checksum_ok) {\r\nprevious_config = data->val_status & 0x07;\r\nret = sht15_soft_reset(data);\r\nif (ret)\r\nreturn ret;\r\nif (previous_config) {\r\nret = sht15_send_status(data, previous_config);\r\nif (ret) {\r\ndev_err(data->dev,\r\n"CRC validation failed, unable "\r\n"to restore device settings\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sht15_update_measurements(struct sht15_data *data)\r\n{\r\nint ret = 0;\r\nint timeout = HZ;\r\nmutex_lock(&data->read_lock);\r\nif (time_after(jiffies, data->last_measurement + timeout)\r\n|| !data->measurements_valid) {\r\ndata->state = SHT15_READING_HUMID;\r\nret = sht15_measurement(data, SHT15_MEASURE_RH, 160);\r\nif (ret)\r\ngoto error_ret;\r\ndata->state = SHT15_READING_TEMP;\r\nret = sht15_measurement(data, SHT15_MEASURE_TEMP, 400);\r\nif (ret)\r\ngoto error_ret;\r\ndata->measurements_valid = true;\r\ndata->last_measurement = jiffies;\r\n}\r\nerror_ret:\r\nmutex_unlock(&data->read_lock);\r\nreturn ret;\r\n}\r\nstatic inline int sht15_calc_temp(struct sht15_data *data)\r\n{\r\nint d1 = temppoints[0].d1;\r\nint d2 = (data->val_status & SHT15_STATUS_LOW_RESOLUTION) ? 40 : 10;\r\nint i;\r\nfor (i = ARRAY_SIZE(temppoints) - 1; i > 0; i--)\r\nif (data->supply_uV > temppoints[i - 1].vdd) {\r\nd1 = (data->supply_uV - temppoints[i - 1].vdd)\r\n* (temppoints[i].d1 - temppoints[i - 1].d1)\r\n/ (temppoints[i].vdd - temppoints[i - 1].vdd)\r\n+ temppoints[i - 1].d1;\r\nbreak;\r\n}\r\nreturn data->val_temp * d2 + d1;\r\n}\r\nstatic inline int sht15_calc_humid(struct sht15_data *data)\r\n{\r\nint rh_linear;\r\nint temp = sht15_calc_temp(data);\r\nint c2, c3;\r\nint t2;\r\nconst int c1 = -4;\r\nif (data->val_status & SHT15_STATUS_LOW_RESOLUTION) {\r\nc2 = 648000;\r\nc3 = -7200;\r\nt2 = 1280;\r\n} else {\r\nc2 = 40500;\r\nc3 = -28;\r\nt2 = 80;\r\n}\r\nrh_linear = c1 * 1000\r\n+ c2 * data->val_humid / 1000\r\n+ (data->val_humid * data->val_humid * c3) / 10000;\r\nreturn (temp - 25000) * (10000 + t2 * data->val_humid)\r\n/ 1000000 + rh_linear;\r\n}\r\nstatic ssize_t sht15_show_status(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nstruct sht15_data *data = dev_get_drvdata(dev);\r\nu8 bit = to_sensor_dev_attr(attr)->index;\r\nret = sht15_update_status(data);\r\nreturn ret ? ret : sprintf(buf, "%d\n", !!(data->val_status & bit));\r\n}\r\nstatic ssize_t sht15_store_heater(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nstruct sht15_data *data = dev_get_drvdata(dev);\r\nlong value;\r\nu8 status;\r\nif (kstrtol(buf, 10, &value))\r\nreturn -EINVAL;\r\nmutex_lock(&data->read_lock);\r\nstatus = data->val_status & 0x07;\r\nif (!!value)\r\nstatus |= SHT15_STATUS_HEATER;\r\nelse\r\nstatus &= ~SHT15_STATUS_HEATER;\r\nret = sht15_send_status(data, status);\r\nmutex_unlock(&data->read_lock);\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t sht15_show_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nstruct sht15_data *data = dev_get_drvdata(dev);\r\nret = sht15_update_measurements(data);\r\nreturn ret ? ret : sprintf(buf, "%d\n",\r\nsht15_calc_temp(data));\r\n}\r\nstatic ssize_t sht15_show_humidity(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nstruct sht15_data *data = dev_get_drvdata(dev);\r\nret = sht15_update_measurements(data);\r\nreturn ret ? ret : sprintf(buf, "%d\n", sht15_calc_humid(data));\r\n}\r\nstatic ssize_t show_name(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nreturn sprintf(buf, "%s\n", pdev->name);\r\n}\r\nstatic irqreturn_t sht15_interrupt_fired(int irq, void *d)\r\n{\r\nstruct sht15_data *data = d;\r\ndisable_irq_nosync(irq);\r\natomic_inc(&data->interrupt_handled);\r\nif (data->state != SHT15_READING_NOTHING)\r\nschedule_work(&data->read_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sht15_bh_read_data(struct work_struct *work_s)\r\n{\r\nuint16_t val = 0;\r\nu8 dev_checksum = 0;\r\nu8 checksum_vals[3];\r\nstruct sht15_data *data\r\n= container_of(work_s, struct sht15_data,\r\nread_work);\r\nif (gpio_get_value(data->pdata->gpio_data)) {\r\natomic_set(&data->interrupt_handled, 0);\r\nenable_irq(gpio_to_irq(data->pdata->gpio_data));\r\nif (gpio_get_value(data->pdata->gpio_data)\r\n|| atomic_read(&data->interrupt_handled))\r\nreturn;\r\n}\r\nval = sht15_read_byte(data);\r\nval <<= 8;\r\nsht15_ack(data);\r\nval |= sht15_read_byte(data);\r\nif (data->checksumming) {\r\nsht15_ack(data);\r\ndev_checksum = sht15_reverse(sht15_read_byte(data));\r\nchecksum_vals[0] = (data->state == SHT15_READING_TEMP) ?\r\nSHT15_MEASURE_TEMP : SHT15_MEASURE_RH;\r\nchecksum_vals[1] = (u8) (val >> 8);\r\nchecksum_vals[2] = (u8) val;\r\ndata->checksum_ok\r\n= (sht15_crc8(data, checksum_vals, 3) == dev_checksum);\r\n}\r\nsht15_end_transmission(data);\r\nswitch (data->state) {\r\ncase SHT15_READING_TEMP:\r\ndata->val_temp = val;\r\nbreak;\r\ncase SHT15_READING_HUMID:\r\ndata->val_humid = val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndata->state = SHT15_READING_NOTHING;\r\nwake_up(&data->wait_queue);\r\n}\r\nstatic void sht15_update_voltage(struct work_struct *work_s)\r\n{\r\nstruct sht15_data *data\r\n= container_of(work_s, struct sht15_data,\r\nupdate_supply_work);\r\ndata->supply_uV = regulator_get_voltage(data->reg);\r\n}\r\nstatic int sht15_invalidate_voltage(struct notifier_block *nb,\r\nunsigned long event,\r\nvoid *ignored)\r\n{\r\nstruct sht15_data *data = container_of(nb, struct sht15_data, nb);\r\nif (event == REGULATOR_EVENT_VOLTAGE_CHANGE)\r\ndata->supply_uV_valid = false;\r\nschedule_work(&data->update_supply_work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __devinit sht15_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct sht15_data *data = kzalloc(sizeof(*data), GFP_KERNEL);\r\nu8 status = 0;\r\nif (!data) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "kzalloc failed\n");\r\ngoto error_ret;\r\n}\r\nINIT_WORK(&data->read_work, sht15_bh_read_data);\r\nINIT_WORK(&data->update_supply_work, sht15_update_voltage);\r\nplatform_set_drvdata(pdev, data);\r\nmutex_init(&data->read_lock);\r\ndata->dev = &pdev->dev;\r\ninit_waitqueue_head(&data->wait_queue);\r\nif (pdev->dev.platform_data == NULL) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "no platform data supplied\n");\r\ngoto err_free_data;\r\n}\r\ndata->pdata = pdev->dev.platform_data;\r\ndata->supply_uV = data->pdata->supply_mv * 1000;\r\nif (data->pdata->checksum)\r\ndata->checksumming = true;\r\nif (data->pdata->no_otp_reload)\r\nstatus |= SHT15_STATUS_NO_OTP_RELOAD;\r\nif (data->pdata->low_resolution)\r\nstatus |= SHT15_STATUS_LOW_RESOLUTION;\r\ndata->reg = regulator_get(data->dev, "vcc");\r\nif (!IS_ERR(data->reg)) {\r\nint voltage;\r\nvoltage = regulator_get_voltage(data->reg);\r\nif (voltage)\r\ndata->supply_uV = voltage;\r\nregulator_enable(data->reg);\r\ndata->nb.notifier_call = &sht15_invalidate_voltage;\r\nret = regulator_register_notifier(data->reg, &data->nb);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"regulator notifier request failed\n");\r\nregulator_disable(data->reg);\r\nregulator_put(data->reg);\r\ngoto err_free_data;\r\n}\r\n}\r\nret = gpio_request(data->pdata->gpio_sck, "SHT15 sck");\r\nif (ret) {\r\ndev_err(&pdev->dev, "gpio request failed\n");\r\ngoto err_release_reg;\r\n}\r\ngpio_direction_output(data->pdata->gpio_sck, 0);\r\nret = gpio_request(data->pdata->gpio_data, "SHT15 data");\r\nif (ret) {\r\ndev_err(&pdev->dev, "gpio request failed\n");\r\ngoto err_release_gpio_sck;\r\n}\r\nret = request_irq(gpio_to_irq(data->pdata->gpio_data),\r\nsht15_interrupt_fired,\r\nIRQF_TRIGGER_FALLING,\r\n"sht15 data",\r\ndata);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get irq for data line\n");\r\ngoto err_release_gpio_data;\r\n}\r\ndisable_irq_nosync(gpio_to_irq(data->pdata->gpio_data));\r\nsht15_connection_reset(data);\r\nret = sht15_soft_reset(data);\r\nif (ret)\r\ngoto err_release_irq;\r\nif (status) {\r\nret = sht15_send_status(data, status);\r\nif (ret)\r\ngoto err_release_irq;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &sht15_attr_group);\r\nif (ret) {\r\ndev_err(&pdev->dev, "sysfs create failed\n");\r\ngoto err_release_irq;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(data->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto err_release_sysfs_group;\r\n}\r\nreturn 0;\r\nerr_release_sysfs_group:\r\nsysfs_remove_group(&pdev->dev.kobj, &sht15_attr_group);\r\nerr_release_irq:\r\nfree_irq(gpio_to_irq(data->pdata->gpio_data), data);\r\nerr_release_gpio_data:\r\ngpio_free(data->pdata->gpio_data);\r\nerr_release_gpio_sck:\r\ngpio_free(data->pdata->gpio_sck);\r\nerr_release_reg:\r\nif (!IS_ERR(data->reg)) {\r\nregulator_unregister_notifier(data->reg, &data->nb);\r\nregulator_disable(data->reg);\r\nregulator_put(data->reg);\r\n}\r\nerr_free_data:\r\nkfree(data);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int __devexit sht15_remove(struct platform_device *pdev)\r\n{\r\nstruct sht15_data *data = platform_get_drvdata(pdev);\r\nmutex_lock(&data->read_lock);\r\nif (sht15_soft_reset(data)) {\r\nmutex_unlock(&data->read_lock);\r\nreturn -EFAULT;\r\n}\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &sht15_attr_group);\r\nif (!IS_ERR(data->reg)) {\r\nregulator_unregister_notifier(data->reg, &data->nb);\r\nregulator_disable(data->reg);\r\nregulator_put(data->reg);\r\n}\r\nfree_irq(gpio_to_irq(data->pdata->gpio_data), data);\r\ngpio_free(data->pdata->gpio_data);\r\ngpio_free(data->pdata->gpio_sck);\r\nmutex_unlock(&data->read_lock);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init sht15_init(void)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sht_drivers); i++) {\r\nret = platform_driver_register(&sht_drivers[i]);\r\nif (ret)\r\ngoto error_unreg;\r\n}\r\nreturn 0;\r\nerror_unreg:\r\nwhile (--i >= 0)\r\nplatform_driver_unregister(&sht_drivers[i]);\r\nreturn ret;\r\n}\r\nstatic void __exit sht15_exit(void)\r\n{\r\nint i;\r\nfor (i = ARRAY_SIZE(sht_drivers) - 1; i >= 0; i--)\r\nplatform_driver_unregister(&sht_drivers[i]);\r\n}
