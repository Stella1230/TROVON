static inline u8 byte(const u32 x, const unsigned n)\r\n{\r\nreturn x >> (n << 3);\r\n}\r\nint crypto_aes_expand_key(struct crypto_aes_ctx *ctx, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nconst __le32 *key = (const __le32 *)in_key;\r\nu32 i, t, u, v, w, j;\r\nif (key_len != AES_KEYSIZE_128 && key_len != AES_KEYSIZE_192 &&\r\nkey_len != AES_KEYSIZE_256)\r\nreturn -EINVAL;\r\nctx->key_length = key_len;\r\nctx->key_dec[key_len + 24] = ctx->key_enc[0] = le32_to_cpu(key[0]);\r\nctx->key_dec[key_len + 25] = ctx->key_enc[1] = le32_to_cpu(key[1]);\r\nctx->key_dec[key_len + 26] = ctx->key_enc[2] = le32_to_cpu(key[2]);\r\nctx->key_dec[key_len + 27] = ctx->key_enc[3] = le32_to_cpu(key[3]);\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\nt = ctx->key_enc[3];\r\nfor (i = 0; i < 10; ++i)\r\nloop4(i);\r\nbreak;\r\ncase AES_KEYSIZE_192:\r\nctx->key_enc[4] = le32_to_cpu(key[4]);\r\nt = ctx->key_enc[5] = le32_to_cpu(key[5]);\r\nfor (i = 0; i < 8; ++i)\r\nloop6(i);\r\nbreak;\r\ncase AES_KEYSIZE_256:\r\nctx->key_enc[4] = le32_to_cpu(key[4]);\r\nctx->key_enc[5] = le32_to_cpu(key[5]);\r\nctx->key_enc[6] = le32_to_cpu(key[6]);\r\nt = ctx->key_enc[7] = le32_to_cpu(key[7]);\r\nfor (i = 0; i < 6; ++i)\r\nloop8(i);\r\nloop8tophalf(i);\r\nbreak;\r\n}\r\nctx->key_dec[0] = ctx->key_enc[key_len + 24];\r\nctx->key_dec[1] = ctx->key_enc[key_len + 25];\r\nctx->key_dec[2] = ctx->key_enc[key_len + 26];\r\nctx->key_dec[3] = ctx->key_enc[key_len + 27];\r\nfor (i = 4; i < key_len + 24; ++i) {\r\nj = key_len + 24 - (i & ~3) + (i & 3);\r\nimix_col(ctx->key_dec[j], ctx->key_enc[i]);\r\n}\r\nreturn 0;\r\n}\r\nint crypto_aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct crypto_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 *flags = &tfm->crt_flags;\r\nint ret;\r\nret = crypto_aes_expand_key(ctx, in_key, key_len);\r\nif (!ret)\r\nreturn 0;\r\n*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nstatic void aes_encrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nconst struct crypto_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *src = (const __le32 *)in;\r\n__le32 *dst = (__le32 *)out;\r\nu32 b0[4], b1[4];\r\nconst u32 *kp = ctx->key_enc + 4;\r\nconst int key_len = ctx->key_length;\r\nb0[0] = le32_to_cpu(src[0]) ^ ctx->key_enc[0];\r\nb0[1] = le32_to_cpu(src[1]) ^ ctx->key_enc[1];\r\nb0[2] = le32_to_cpu(src[2]) ^ ctx->key_enc[2];\r\nb0[3] = le32_to_cpu(src[3]) ^ ctx->key_enc[3];\r\nif (key_len > 24) {\r\nf_nround(b1, b0, kp);\r\nf_nround(b0, b1, kp);\r\n}\r\nif (key_len > 16) {\r\nf_nround(b1, b0, kp);\r\nf_nround(b0, b1, kp);\r\n}\r\nf_nround(b1, b0, kp);\r\nf_nround(b0, b1, kp);\r\nf_nround(b1, b0, kp);\r\nf_nround(b0, b1, kp);\r\nf_nround(b1, b0, kp);\r\nf_nround(b0, b1, kp);\r\nf_nround(b1, b0, kp);\r\nf_nround(b0, b1, kp);\r\nf_nround(b1, b0, kp);\r\nf_lround(b0, b1, kp);\r\ndst[0] = cpu_to_le32(b0[0]);\r\ndst[1] = cpu_to_le32(b0[1]);\r\ndst[2] = cpu_to_le32(b0[2]);\r\ndst[3] = cpu_to_le32(b0[3]);\r\n}\r\nstatic void aes_decrypt(struct crypto_tfm *tfm, u8 *out, const u8 *in)\r\n{\r\nconst struct crypto_aes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *src = (const __le32 *)in;\r\n__le32 *dst = (__le32 *)out;\r\nu32 b0[4], b1[4];\r\nconst int key_len = ctx->key_length;\r\nconst u32 *kp = ctx->key_dec + 4;\r\nb0[0] = le32_to_cpu(src[0]) ^ ctx->key_dec[0];\r\nb0[1] = le32_to_cpu(src[1]) ^ ctx->key_dec[1];\r\nb0[2] = le32_to_cpu(src[2]) ^ ctx->key_dec[2];\r\nb0[3] = le32_to_cpu(src[3]) ^ ctx->key_dec[3];\r\nif (key_len > 24) {\r\ni_nround(b1, b0, kp);\r\ni_nround(b0, b1, kp);\r\n}\r\nif (key_len > 16) {\r\ni_nround(b1, b0, kp);\r\ni_nround(b0, b1, kp);\r\n}\r\ni_nround(b1, b0, kp);\r\ni_nround(b0, b1, kp);\r\ni_nround(b1, b0, kp);\r\ni_nround(b0, b1, kp);\r\ni_nround(b1, b0, kp);\r\ni_nround(b0, b1, kp);\r\ni_nround(b1, b0, kp);\r\ni_nround(b0, b1, kp);\r\ni_nround(b1, b0, kp);\r\ni_lround(b0, b1, kp);\r\ndst[0] = cpu_to_le32(b0[0]);\r\ndst[1] = cpu_to_le32(b0[1]);\r\ndst[2] = cpu_to_le32(b0[2]);\r\ndst[3] = cpu_to_le32(b0[3]);\r\n}\r\nstatic int __init aes_init(void)\r\n{\r\nreturn crypto_register_alg(&aes_alg);\r\n}\r\nstatic void __exit aes_fini(void)\r\n{\r\ncrypto_unregister_alg(&aes_alg);\r\n}
