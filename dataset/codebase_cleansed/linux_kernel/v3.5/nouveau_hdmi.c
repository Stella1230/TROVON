static bool\r\nhdmi_sor(struct drm_encoder *encoder)\r\n{\r\nstruct drm_nouveau_private *dev_priv = encoder->dev->dev_private;\r\nif (dev_priv->chipset < 0xa3 ||\r\ndev_priv->chipset == 0xaa ||\r\ndev_priv->chipset == 0xac)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline u32\r\nhdmi_base(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(nv_encoder->crtc);\r\nif (!hdmi_sor(encoder))\r\nreturn 0x616500 + (nv_crtc->index * 0x800);\r\nreturn 0x61c500 + (nv_encoder->or * 0x800);\r\n}\r\nstatic void\r\nhdmi_wr32(struct drm_encoder *encoder, u32 reg, u32 val)\r\n{\r\nnv_wr32(encoder->dev, hdmi_base(encoder) + reg, val);\r\n}\r\nstatic u32\r\nhdmi_rd32(struct drm_encoder *encoder, u32 reg)\r\n{\r\nreturn nv_rd32(encoder->dev, hdmi_base(encoder) + reg);\r\n}\r\nstatic u32\r\nhdmi_mask(struct drm_encoder *encoder, u32 reg, u32 mask, u32 val)\r\n{\r\nu32 tmp = hdmi_rd32(encoder, reg);\r\nhdmi_wr32(encoder, reg, (tmp & ~mask) | val);\r\nreturn tmp;\r\n}\r\nstatic void\r\nnouveau_audio_disconnect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nu32 or = nv_encoder->or * 0x800;\r\nif (hdmi_sor(encoder)) {\r\nnv_mask(dev, 0x61c448 + or, 0x00000003, 0x00000000);\r\n}\r\n}\r\nstatic void\r\nnouveau_audio_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_connector *nv_connector;\r\nstruct drm_device *dev = encoder->dev;\r\nu32 or = nv_encoder->or * 0x800;\r\nint i;\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!drm_detect_monitor_audio(nv_connector->edid)) {\r\nnouveau_audio_disconnect(encoder);\r\nreturn;\r\n}\r\nif (hdmi_sor(encoder)) {\r\nnv_mask(dev, 0x61c448 + or, 0x00000001, 0x00000001);\r\ndrm_edid_to_eld(&nv_connector->base, nv_connector->edid);\r\nif (nv_connector->base.eld[0]) {\r\nu8 *eld = nv_connector->base.eld;\r\nfor (i = 0; i < eld[2] * 4; i++)\r\nnv_wr32(dev, 0x61c440 + or, (i << 8) | eld[i]);\r\nfor (i = eld[2] * 4; i < 0x60; i++)\r\nnv_wr32(dev, 0x61c440 + or, (i << 8) | 0x00);\r\nnv_mask(dev, 0x61c448 + or, 0x00000002, 0x00000002);\r\n}\r\n}\r\n}\r\nstatic void\r\nnouveau_hdmi_infoframe(struct drm_encoder *encoder, u32 ctrl, u8 *frame)\r\n{\r\nu8 sum = 0, i;\r\nfor (i = 0; i < frame[2]; i++)\r\nsum += frame[i];\r\nframe[3] = 256 - sum;\r\nhdmi_mask(encoder, ctrl + 0x00, 0x00000001, 0x00000000);\r\nhdmi_wr32(encoder, ctrl + 0x08, *(u32 *)frame & 0xffffff);\r\nif (ctrl == 0x020)\r\nframe[2] = 6;\r\nfor (i = 0; i < frame[2] + 1; i += 7) {\r\nu32 rsubpack = ctrl + 0x0c + ((i / 7) * 8);\r\nu32 *subpack = (u32 *)&frame[3 + i];\r\nhdmi_wr32(encoder, rsubpack + 0, subpack[0]);\r\nhdmi_wr32(encoder, rsubpack + 4, subpack[1] & 0xffffff);\r\n}\r\nhdmi_mask(encoder, ctrl, 0x00000001, 0x00000001);\r\n}\r\nstatic void\r\nnouveau_hdmi_video_infoframe(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nconst u8 Y = 0, A = 0, B = 0, S = 0, C = 0, M = 0, R = 0;\r\nconst u8 ITC = 0, EC = 0, Q = 0, SC = 0, VIC = 0, PR = 0;\r\nconst u8 bar_top = 0, bar_bottom = 0, bar_left = 0, bar_right = 0;\r\nu8 frame[20];\r\nframe[0x00] = 0x82;\r\nframe[0x01] = 0x02;\r\nframe[0x02] = 0x0d;\r\nframe[0x03] = 0x00;\r\nframe[0x04] = (Y << 5) | (A << 4) | (B << 2) | S;\r\nframe[0x05] = (C << 6) | (M << 4) | R;\r\nframe[0x06] = (ITC << 7) | (EC << 4) | (Q << 2) | SC;\r\nframe[0x07] = VIC;\r\nframe[0x08] = PR;\r\nframe[0x09] = bar_top & 0xff;\r\nframe[0x0a] = bar_top >> 8;\r\nframe[0x0b] = bar_bottom & 0xff;\r\nframe[0x0c] = bar_bottom >> 8;\r\nframe[0x0d] = bar_left & 0xff;\r\nframe[0x0e] = bar_left >> 8;\r\nframe[0x0f] = bar_right & 0xff;\r\nframe[0x10] = bar_right >> 8;\r\nframe[0x11] = 0x00;\r\nframe[0x12] = 0x00;\r\nframe[0x13] = 0x00;\r\nnouveau_hdmi_infoframe(encoder, 0x020, frame);\r\n}\r\nstatic void\r\nnouveau_hdmi_audio_infoframe(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nconst u8 CT = 0x00, CC = 0x01, ceaSS = 0x00, SF = 0x00, FMT = 0x00;\r\nconst u8 CA = 0x00, DM_INH = 0, LSV = 0x00;\r\nu8 frame[12];\r\nframe[0x00] = 0x84;\r\nframe[0x01] = 0x01;\r\nframe[0x02] = 0x0a;\r\nframe[0x03] = 0x00;\r\nframe[0x04] = (CT << 4) | CC;\r\nframe[0x05] = (SF << 2) | ceaSS;\r\nframe[0x06] = FMT;\r\nframe[0x07] = CA;\r\nframe[0x08] = (DM_INH << 7) | (LSV << 3);\r\nframe[0x09] = 0x00;\r\nframe[0x0a] = 0x00;\r\nframe[0x0b] = 0x00;\r\nnouveau_hdmi_infoframe(encoder, 0x000, frame);\r\n}\r\nstatic void\r\nnouveau_hdmi_disconnect(struct drm_encoder *encoder)\r\n{\r\nnouveau_audio_disconnect(encoder);\r\nhdmi_mask(encoder, 0x000, 0x00000001, 0x00000000);\r\nhdmi_mask(encoder, 0x020, 0x00000001, 0x00000000);\r\nhdmi_mask(encoder, 0x0a4, 0x40000000, 0x00000000);\r\n}\r\nvoid\r\nnouveau_hdmi_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_connector *nv_connector;\r\nstruct drm_device *dev = encoder->dev;\r\nu32 max_ac_packet, rekey;\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!mode || !nv_connector || !nv_connector->edid ||\r\n!drm_detect_hdmi_monitor(nv_connector->edid)) {\r\nnouveau_hdmi_disconnect(encoder);\r\nreturn;\r\n}\r\nnouveau_hdmi_video_infoframe(encoder, mode);\r\nnouveau_hdmi_audio_infoframe(encoder, mode);\r\nhdmi_mask(encoder, 0x0d0, 0x00070001, 0x00010001);\r\nhdmi_mask(encoder, 0x068, 0x00010101, 0x00000000);\r\nhdmi_mask(encoder, 0x078, 0x80000000, 0x80000000);\r\nnv_mask(dev, 0x61733c, 0x00100000, 0x00100000);\r\nnv_mask(dev, 0x61733c, 0x10000000, 0x10000000);\r\nnv_mask(dev, 0x61733c, 0x00100000, 0x00000000);\r\nrekey = 56;\r\nmax_ac_packet = mode->htotal - mode->hdisplay;\r\nmax_ac_packet -= rekey;\r\nmax_ac_packet -= 18;\r\nmax_ac_packet /= 32;\r\nhdmi_mask(encoder, 0x0a4, 0x5f1f003f, 0x40000000 |\r\n0x1f000000 |\r\nmax_ac_packet << 16 |\r\nrekey);\r\nnouveau_audio_mode_set(encoder, mode);\r\n}
