static inline u16 temp2reg(struct adt7475_data *data, long val)\r\n{\r\nu16 ret;\r\nif (!(data->config5 & CONFIG5_TWOSCOMP)) {\r\nval = SENSORS_LIMIT(val, -64000, 191000);\r\nret = (val + 64500) / 1000;\r\n} else {\r\nval = SENSORS_LIMIT(val, -128000, 127000);\r\nif (val < -500)\r\nret = (256500 + val) / 1000;\r\nelse\r\nret = (val + 500) / 1000;\r\n}\r\nreturn ret << 2;\r\n}\r\nstatic inline int reg2temp(struct adt7475_data *data, u16 reg)\r\n{\r\nif (data->config5 & CONFIG5_TWOSCOMP) {\r\nif (reg >= 512)\r\nreturn (reg - 1024) * 250;\r\nelse\r\nreturn reg * 250;\r\n} else\r\nreturn (reg - 256) * 250;\r\n}\r\nstatic inline int tach2rpm(u16 tach)\r\n{\r\nif (tach == 0 || tach == 0xFFFF)\r\nreturn 0;\r\nreturn (90000 * 60) / tach;\r\n}\r\nstatic inline u16 rpm2tach(unsigned long rpm)\r\n{\r\nif (rpm == 0)\r\nreturn 0;\r\nreturn SENSORS_LIMIT((90000 * 60) / rpm, 1, 0xFFFF);\r\n}\r\nstatic inline int reg2volt(int channel, u16 reg, u8 bypass_attn)\r\n{\r\nconst int *r = adt7473_in_scaling[channel];\r\nif (bypass_attn & (1 << channel))\r\nreturn DIV_ROUND_CLOSEST(reg * 2250, 1024);\r\nreturn DIV_ROUND_CLOSEST(reg * (r[0] + r[1]) * 2250, r[1] * 1024);\r\n}\r\nstatic inline u16 volt2reg(int channel, long volt, u8 bypass_attn)\r\n{\r\nconst int *r = adt7473_in_scaling[channel];\r\nlong reg;\r\nif (bypass_attn & (1 << channel))\r\nreg = (volt * 1024) / 2250;\r\nelse\r\nreg = (volt * r[1] * 1024) / ((r[0] + r[1]) * 2250);\r\nreturn SENSORS_LIMIT(reg, 0, 1023) & (0xff << 2);\r\n}\r\nstatic u16 adt7475_read_word(struct i2c_client *client, int reg)\r\n{\r\nu16 val;\r\nval = i2c_smbus_read_byte_data(client, reg);\r\nval |= (i2c_smbus_read_byte_data(client, reg + 1) << 8);\r\nreturn val;\r\n}\r\nstatic void adt7475_write_word(struct i2c_client *client, int reg, u16 val)\r\n{\r\ni2c_smbus_write_byte_data(client, reg + 1, val >> 8);\r\ni2c_smbus_write_byte_data(client, reg, val & 0xFF);\r\n}\r\nstatic int find_nearest(long val, const int *array, int size)\r\n{\r\nint i;\r\nif (val < array[0])\r\nreturn 0;\r\nif (val > array[size - 1])\r\nreturn size - 1;\r\nfor (i = 0; i < size - 1; i++) {\r\nint a, b;\r\nif (val > array[i + 1])\r\ncontinue;\r\na = val - array[i];\r\nb = array[i + 1] - val;\r\nreturn (a <= b) ? i : i + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t show_voltage(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nunsigned short val;\r\nswitch (sattr->nr) {\r\ncase ALARM:\r\nreturn sprintf(buf, "%d\n",\r\n(data->alarms >> sattr->index) & 1);\r\ndefault:\r\nval = data->voltage[sattr->nr][sattr->index];\r\nreturn sprintf(buf, "%d\n",\r\nreg2volt(sattr->index, val, data->bypass_attn));\r\n}\r\n}\r\nstatic ssize_t set_voltage(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nunsigned char reg;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->voltage[sattr->nr][sattr->index] =\r\nvolt2reg(sattr->index, val, data->bypass_attn);\r\nif (sattr->index < ADT7475_VOLTAGE_COUNT) {\r\nif (sattr->nr == MIN)\r\nreg = VOLTAGE_MIN_REG(sattr->index);\r\nelse\r\nreg = VOLTAGE_MAX_REG(sattr->index);\r\n} else {\r\nif (sattr->nr == MIN)\r\nreg = REG_VTT_MIN;\r\nelse\r\nreg = REG_VTT_MAX;\r\n}\r\ni2c_smbus_write_byte_data(client, reg,\r\ndata->voltage[sattr->nr][sattr->index] >> 2);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint out;\r\nswitch (sattr->nr) {\r\ncase HYSTERSIS:\r\nmutex_lock(&data->lock);\r\nout = data->temp[sattr->nr][sattr->index];\r\nif (sattr->index != 1)\r\nout = (out >> 4) & 0xF;\r\nelse\r\nout = (out & 0xF);\r\nout = reg2temp(data, data->temp[THERM][sattr->index]) -\r\nout * 1000;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ncase OFFSET:\r\nmutex_lock(&data->lock);\r\nout = (s8)data->temp[sattr->nr][sattr->index];\r\nif (data->config5 & CONFIG5_TEMPOFFSET)\r\nout *= 1000;\r\nelse\r\nout *= 500;\r\nmutex_unlock(&data->lock);\r\nbreak;\r\ncase ALARM:\r\nout = (data->alarms >> (sattr->index + 4)) & 1;\r\nbreak;\r\ncase FAULT:\r\nout = !!(data->alarms & (sattr->index ? 0x8000 : 0x4000));\r\nbreak;\r\ndefault:\r\nout = reg2temp(data, data->temp[sattr->nr][sattr->index]);\r\n}\r\nreturn sprintf(buf, "%d\n", out);\r\n}\r\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nunsigned char reg = 0;\r\nu8 out;\r\nint temp;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->config5 = adt7475_read(REG_CONFIG5);\r\nswitch (sattr->nr) {\r\ncase OFFSET:\r\nif (data->config5 & CONFIG5_TEMPOFFSET) {\r\nval = SENSORS_LIMIT(val, -63000, 127000);\r\nout = data->temp[OFFSET][sattr->index] = val / 1000;\r\n} else {\r\nval = SENSORS_LIMIT(val, -63000, 64000);\r\nout = data->temp[OFFSET][sattr->index] = val / 500;\r\n}\r\nbreak;\r\ncase HYSTERSIS:\r\ndata->temp[THERM][sattr->index] =\r\nadt7475_read(TEMP_THERM_REG(sattr->index)) << 2;\r\nadt7475_read_hystersis(client);\r\ntemp = reg2temp(data, data->temp[THERM][sattr->index]);\r\nval = SENSORS_LIMIT(val, temp - 15000, temp);\r\nval = (temp - val) / 1000;\r\nif (sattr->index != 1) {\r\ndata->temp[HYSTERSIS][sattr->index] &= 0xF0;\r\ndata->temp[HYSTERSIS][sattr->index] |= (val & 0xF) << 4;\r\n} else {\r\ndata->temp[HYSTERSIS][sattr->index] &= 0x0F;\r\ndata->temp[HYSTERSIS][sattr->index] |= (val & 0xF);\r\n}\r\nout = data->temp[HYSTERSIS][sattr->index];\r\nbreak;\r\ndefault:\r\ndata->temp[sattr->nr][sattr->index] = temp2reg(data, val);\r\nout = (u8) (data->temp[sattr->nr][sattr->index] >> 2);\r\n}\r\nswitch (sattr->nr) {\r\ncase MIN:\r\nreg = TEMP_MIN_REG(sattr->index);\r\nbreak;\r\ncase MAX:\r\nreg = TEMP_MAX_REG(sattr->index);\r\nbreak;\r\ncase OFFSET:\r\nreg = TEMP_OFFSET_REG(sattr->index);\r\nbreak;\r\ncase AUTOMIN:\r\nreg = TEMP_TMIN_REG(sattr->index);\r\nbreak;\r\ncase THERM:\r\nreg = TEMP_THERM_REG(sattr->index);\r\nbreak;\r\ncase HYSTERSIS:\r\nif (sattr->index != 2)\r\nreg = REG_REMOTE1_HYSTERSIS;\r\nelse\r\nreg = REG_REMOTE2_HYSTERSIS;\r\nbreak;\r\n}\r\ni2c_smbus_write_byte_data(client, reg, out);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_point2(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint out, val;\r\nmutex_lock(&data->lock);\r\nout = (data->range[sattr->index] >> 4) & 0x0F;\r\nval = reg2temp(data, data->temp[AUTOMIN][sattr->index]);\r\nmutex_unlock(&data->lock);\r\nreturn sprintf(buf, "%d\n", val + autorange_table[out]);\r\n}\r\nstatic ssize_t set_point2(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint temp;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->config5 = adt7475_read(REG_CONFIG5);\r\ndata->temp[AUTOMIN][sattr->index] =\r\nadt7475_read(TEMP_TMIN_REG(sattr->index)) << 2;\r\ndata->range[sattr->index] =\r\nadt7475_read(TEMP_TRANGE_REG(sattr->index));\r\ntemp = reg2temp(data, data->temp[AUTOMIN][sattr->index]);\r\nval = SENSORS_LIMIT(val, temp + autorange_table[0],\r\ntemp + autorange_table[ARRAY_SIZE(autorange_table) - 1]);\r\nval -= temp;\r\nval = find_nearest(val, autorange_table, ARRAY_SIZE(autorange_table));\r\ndata->range[sattr->index] &= ~0xF0;\r\ndata->range[sattr->index] |= val << 4;\r\ni2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),\r\ndata->range[sattr->index]);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_tach(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nint out;\r\nif (sattr->nr == ALARM)\r\nout = (data->alarms >> (sattr->index + 10)) & 1;\r\nelse\r\nout = tach2rpm(data->tach[sattr->nr][sattr->index]);\r\nreturn sprintf(buf, "%d\n", out);\r\n}\r\nstatic ssize_t set_tach(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nif (kstrtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->tach[MIN][sattr->index] = rpm2tach(val);\r\nadt7475_write_word(client, TACH_MIN_REG(sattr->index),\r\ndata->tach[MIN][sattr->index]);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nreturn sprintf(buf, "%d\n", data->pwm[sattr->nr][sattr->index]);\r\n}\r\nstatic ssize_t show_pwmchan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nreturn sprintf(buf, "%d\n", data->pwmchan[sattr->index]);\r\n}\r\nstatic ssize_t show_pwmctrl(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nreturn sprintf(buf, "%d\n", data->pwmctl[sattr->index]);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nunsigned char reg = 0;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nswitch (sattr->nr) {\r\ncase INPUT:\r\ndata->pwm[CONTROL][sattr->index] =\r\nadt7475_read(PWM_CONFIG_REG(sattr->index));\r\nif (((data->pwm[CONTROL][sattr->index] >> 5) & 7) != 7) {\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nreg = PWM_REG(sattr->index);\r\nbreak;\r\ncase MIN:\r\nreg = PWM_MIN_REG(sattr->index);\r\nbreak;\r\ncase MAX:\r\nreg = PWM_MAX_REG(sattr->index);\r\nbreak;\r\n}\r\ndata->pwm[sattr->nr][sattr->index] = SENSORS_LIMIT(val, 0, 0xFF);\r\ni2c_smbus_write_byte_data(client, reg,\r\ndata->pwm[sattr->nr][sattr->index]);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic int hw_set_pwm(struct i2c_client *client, int index,\r\nunsigned int pwmctl, unsigned int pwmchan)\r\n{\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nlong val = 0;\r\nswitch (pwmctl) {\r\ncase 0:\r\nval = 0x03;\r\nbreak;\r\ncase 1:\r\nval = 0x07;\r\nbreak;\r\ncase 2:\r\nswitch (pwmchan) {\r\ncase 1:\r\nval = 0x00;\r\nbreak;\r\ncase 2:\r\nval = 0x01;\r\nbreak;\r\ncase 4:\r\nval = 0x02;\r\nbreak;\r\ncase 6:\r\nval = 0x05;\r\nbreak;\r\ncase 7:\r\nval = 0x06;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndata->pwmctl[index] = pwmctl;\r\ndata->pwmchan[index] = pwmchan;\r\ndata->pwm[CONTROL][index] &= ~0xE0;\r\ndata->pwm[CONTROL][index] |= (val & 7) << 5;\r\ni2c_smbus_write_byte_data(client, PWM_CONFIG_REG(index),\r\ndata->pwm[CONTROL][index]);\r\nreturn 0;\r\n}\r\nstatic ssize_t set_pwmchan(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nint r;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nadt7475_read_pwm(client, sattr->index);\r\nr = hw_set_pwm(client, sattr->index, data->pwmctl[sattr->index], val);\r\nif (r)\r\ncount = r;\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwmctrl(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nint r;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\nadt7475_read_pwm(client, sattr->index);\r\nr = hw_set_pwm(client, sattr->index, val, data->pwmchan[sattr->index]);\r\nif (r)\r\ncount = r;\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwmfreq(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nreturn sprintf(buf, "%d\n",\r\npwmfreq_table[data->range[sattr->index] & 7]);\r\n}\r\nstatic ssize_t set_pwmfreq(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nint out;\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nout = find_nearest(val, pwmfreq_table, ARRAY_SIZE(pwmfreq_table));\r\nmutex_lock(&data->lock);\r\ndata->range[sattr->index] =\r\nadt7475_read(TEMP_TRANGE_REG(sattr->index));\r\ndata->range[sattr->index] &= ~7;\r\ndata->range[sattr->index] |= out;\r\ni2c_smbus_write_byte_data(client, TEMP_TRANGE_REG(sattr->index),\r\ndata->range[sattr->index]);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_at_crit(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nreturn sprintf(buf, "%d\n", !!(data->config4 & CONFIG4_MAXDUTY));\r\n}\r\nstatic ssize_t set_pwm_at_crit(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->config4 = i2c_smbus_read_byte_data(client, REG_CONFIG4);\r\nif (val)\r\ndata->config4 |= CONFIG4_MAXDUTY;\r\nelse\r\ndata->config4 &= ~CONFIG4_MAXDUTY;\r\ni2c_smbus_write_byte_data(client, REG_CONFIG4, data->config4);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vrm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", (int)data->vrm);\r\n}\r\nstatic ssize_t set_vrm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adt7475_data *data = dev_get_drvdata(dev);\r\nlong val;\r\nif (kstrtol(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7475_data *data = adt7475_update_device(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic int adt7475_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint vendid, devid, devid2;\r\nconst char *name;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nvendid = adt7475_read(REG_VENDID);\r\ndevid2 = adt7475_read(REG_DEVID2);\r\nif (vendid != 0x41 ||\r\n(devid2 & 0xf8) != 0x68)\r\nreturn -ENODEV;\r\ndevid = adt7475_read(REG_DEVID);\r\nif (devid == 0x73)\r\nname = "adt7473";\r\nelse if (devid == 0x75 && client->addr == 0x2e)\r\nname = "adt7475";\r\nelse if (devid == 0x76)\r\nname = "adt7476";\r\nelse if ((devid2 & 0xfc) == 0x6c)\r\nname = "adt7490";\r\nelse {\r\ndev_dbg(&adapter->dev,\r\n"Couldn't detect an ADT7473/75/76/90 part at "\r\n"0x%02x\n", (unsigned int)client->addr);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void adt7475_remove_files(struct i2c_client *client,\r\nstruct adt7475_data *data)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &adt7475_attr_group);\r\nif (data->has_fan4)\r\nsysfs_remove_group(&client->dev.kobj, &fan4_attr_group);\r\nif (data->has_pwm2)\r\nsysfs_remove_group(&client->dev.kobj, &pwm2_attr_group);\r\nif (data->has_voltage & (1 << 0))\r\nsysfs_remove_group(&client->dev.kobj, &in0_attr_group);\r\nif (data->has_voltage & (1 << 3))\r\nsysfs_remove_group(&client->dev.kobj, &in3_attr_group);\r\nif (data->has_voltage & (1 << 4))\r\nsysfs_remove_group(&client->dev.kobj, &in4_attr_group);\r\nif (data->has_voltage & (1 << 5))\r\nsysfs_remove_group(&client->dev.kobj, &in5_attr_group);\r\nif (data->has_vid)\r\nsysfs_remove_group(&client->dev.kobj, &vid_attr_group);\r\n}\r\nstatic int adt7475_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstatic const char * const names[] = {\r\n[adt7473] = "ADT7473",\r\n[adt7475] = "ADT7475",\r\n[adt7476] = "ADT7476",\r\n[adt7490] = "ADT7490",\r\n};\r\nstruct adt7475_data *data;\r\nint i, ret = 0, revision;\r\nu8 config2, config3;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&data->lock);\r\ni2c_set_clientdata(client, data);\r\nswitch (id->driver_data) {\r\ncase adt7476:\r\ndata->has_voltage = 0x0e;\r\nrevision = adt7475_read(REG_DEVID2) & 0x07;\r\nbreak;\r\ncase adt7490:\r\ndata->has_voltage = 0x3e;\r\nrevision = adt7475_read(REG_DEVID2) & 0x03;\r\nif (revision == 0x03)\r\nrevision += adt7475_read(REG_DEVREV2);\r\nbreak;\r\ndefault:\r\ndata->has_voltage = 0x06;\r\nrevision = adt7475_read(REG_DEVID2) & 0x07;\r\n}\r\nconfig3 = adt7475_read(REG_CONFIG3);\r\nif (!(config3 & CONFIG3_SMBALERT))\r\ndata->has_pwm2 = 1;\r\nif (id->driver_data == adt7473 && revision >= 1)\r\ndata->has_pwm2 = !data->has_pwm2;\r\ndata->config4 = adt7475_read(REG_CONFIG4);\r\nif ((data->config4 & CONFIG4_PINFUNC) == 0x0)\r\ndata->has_fan4 = 1;\r\nif (id->driver_data == adt7490) {\r\nif ((data->config4 & CONFIG4_PINFUNC) == 0x1 &&\r\n!(config3 & CONFIG3_THERM))\r\ndata->has_fan4 = 1;\r\n}\r\nif (id->driver_data == adt7476 || id->driver_data == adt7490) {\r\nif (!(config3 & CONFIG3_THERM) ||\r\n(data->config4 & CONFIG4_PINFUNC) == 0x1)\r\ndata->has_voltage |= (1 << 0);\r\n}\r\nif (id->driver_data == adt7476) {\r\nu8 vid = adt7475_read(REG_VID);\r\nif (!(vid & VID_VIDSEL))\r\ndata->has_voltage |= (1 << 4);\r\ndata->has_vid = !(adt7475_read(REG_CONFIG5) & CONFIG5_VIDGPIO);\r\n}\r\nconfig2 = adt7475_read(REG_CONFIG2);\r\nif (config2 & CONFIG2_ATTN) {\r\ndata->bypass_attn = (0x3 << 3) | 0x3;\r\n} else {\r\ndata->bypass_attn = ((data->config4 & CONFIG4_ATTN_IN10) >> 4) |\r\n((data->config4 & CONFIG4_ATTN_IN43) >> 3);\r\n}\r\ndata->bypass_attn &= data->has_voltage;\r\nfor (i = 0; i < ADT7475_PWM_COUNT; i++)\r\nadt7475_read_pwm(client, i);\r\nret = sysfs_create_group(&client->dev.kobj, &adt7475_attr_group);\r\nif (ret)\r\ngoto efree;\r\nif (data->has_fan4) {\r\nret = sysfs_create_group(&client->dev.kobj, &fan4_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\nif (data->has_pwm2) {\r\nret = sysfs_create_group(&client->dev.kobj, &pwm2_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\nif (data->has_voltage & (1 << 0)) {\r\nret = sysfs_create_group(&client->dev.kobj, &in0_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\nif (data->has_voltage & (1 << 3)) {\r\nret = sysfs_create_group(&client->dev.kobj, &in3_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\nif (data->has_voltage & (1 << 4)) {\r\nret = sysfs_create_group(&client->dev.kobj, &in4_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\nif (data->has_voltage & (1 << 5)) {\r\nret = sysfs_create_group(&client->dev.kobj, &in5_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\nif (data->has_vid) {\r\ndata->vrm = vid_which_vrm();\r\nret = sysfs_create_group(&client->dev.kobj, &vid_attr_group);\r\nif (ret)\r\ngoto eremove;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto eremove;\r\n}\r\ndev_info(&client->dev, "%s device, revision %d\n",\r\nnames[id->driver_data], revision);\r\nif ((data->has_voltage & 0x11) || data->has_fan4 || data->has_pwm2)\r\ndev_info(&client->dev, "Optional features:%s%s%s%s%s\n",\r\n(data->has_voltage & (1 << 0)) ? " in0" : "",\r\n(data->has_voltage & (1 << 4)) ? " in4" : "",\r\ndata->has_fan4 ? " fan4" : "",\r\ndata->has_pwm2 ? " pwm2" : "",\r\ndata->has_vid ? " vid" : "");\r\nif (data->bypass_attn)\r\ndev_info(&client->dev, "Bypassing attenuators on:%s%s%s%s\n",\r\n(data->bypass_attn & (1 << 0)) ? " in0" : "",\r\n(data->bypass_attn & (1 << 1)) ? " in1" : "",\r\n(data->bypass_attn & (1 << 3)) ? " in3" : "",\r\n(data->bypass_attn & (1 << 4)) ? " in4" : "");\r\nreturn 0;\r\neremove:\r\nadt7475_remove_files(client, data);\r\nefree:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int adt7475_remove(struct i2c_client *client)\r\n{\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nadt7475_remove_files(client, data);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void adt7475_read_hystersis(struct i2c_client *client)\r\n{\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\ndata->temp[HYSTERSIS][0] = (u16) adt7475_read(REG_REMOTE1_HYSTERSIS);\r\ndata->temp[HYSTERSIS][1] = data->temp[HYSTERSIS][0];\r\ndata->temp[HYSTERSIS][2] = (u16) adt7475_read(REG_REMOTE2_HYSTERSIS);\r\n}\r\nstatic void adt7475_read_pwm(struct i2c_client *client, int index)\r\n{\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nunsigned int v;\r\ndata->pwm[CONTROL][index] = adt7475_read(PWM_CONFIG_REG(index));\r\nv = (data->pwm[CONTROL][index] >> 5) & 7;\r\nif (v == 3)\r\ndata->pwmctl[index] = 0;\r\nelse if (v == 7)\r\ndata->pwmctl[index] = 1;\r\nelse if (v == 4) {\r\ndata->pwm[INPUT][index] = 0;\r\ndata->pwm[CONTROL][index] &= ~0xE0;\r\ndata->pwm[CONTROL][index] |= (7 << 5);\r\ni2c_smbus_write_byte_data(client, PWM_CONFIG_REG(index),\r\ndata->pwm[INPUT][index]);\r\ni2c_smbus_write_byte_data(client, PWM_CONFIG_REG(index),\r\ndata->pwm[CONTROL][index]);\r\ndata->pwmctl[index] = 1;\r\n} else {\r\ndata->pwmctl[index] = 2;\r\nswitch (v) {\r\ncase 0:\r\ndata->pwmchan[index] = 1;\r\nbreak;\r\ncase 1:\r\ndata->pwmchan[index] = 2;\r\nbreak;\r\ncase 2:\r\ndata->pwmchan[index] = 4;\r\nbreak;\r\ncase 5:\r\ndata->pwmchan[index] = 6;\r\nbreak;\r\ncase 6:\r\ndata->pwmchan[index] = 7;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic struct adt7475_data *adt7475_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adt7475_data *data = i2c_get_clientdata(client);\r\nu16 ext;\r\nint i;\r\nmutex_lock(&data->lock);\r\nif (time_after(jiffies, data->measure_updated + HZ * 2) ||\r\n!data->valid) {\r\ndata->alarms = adt7475_read(REG_STATUS2) << 8;\r\ndata->alarms |= adt7475_read(REG_STATUS1);\r\next = (adt7475_read(REG_EXTEND2) << 8) |\r\nadt7475_read(REG_EXTEND1);\r\nfor (i = 0; i < ADT7475_VOLTAGE_COUNT; i++) {\r\nif (!(data->has_voltage & (1 << i)))\r\ncontinue;\r\ndata->voltage[INPUT][i] =\r\n(adt7475_read(VOLTAGE_REG(i)) << 2) |\r\n((ext >> (i * 2)) & 3);\r\n}\r\nfor (i = 0; i < ADT7475_TEMP_COUNT; i++)\r\ndata->temp[INPUT][i] =\r\n(adt7475_read(TEMP_REG(i)) << 2) |\r\n((ext >> ((i + 5) * 2)) & 3);\r\nif (data->has_voltage & (1 << 5)) {\r\ndata->alarms |= adt7475_read(REG_STATUS4) << 24;\r\next = adt7475_read(REG_EXTEND3);\r\ndata->voltage[INPUT][5] = adt7475_read(REG_VTT) << 2 |\r\n((ext >> 4) & 3);\r\n}\r\nfor (i = 0; i < ADT7475_TACH_COUNT; i++) {\r\nif (i == 3 && !data->has_fan4)\r\ncontinue;\r\ndata->tach[INPUT][i] =\r\nadt7475_read_word(client, TACH_REG(i));\r\n}\r\nfor (i = 0; i < ADT7475_PWM_COUNT; i++) {\r\nif (i == 1 && !data->has_pwm2)\r\ncontinue;\r\ndata->pwm[INPUT][i] = adt7475_read(PWM_REG(i));\r\n}\r\nif (data->has_vid)\r\ndata->vid = adt7475_read(REG_VID) & 0x3f;\r\ndata->measure_updated = jiffies;\r\n}\r\nif (time_after(jiffies, data->limits_updated + HZ * 60) ||\r\n!data->valid) {\r\ndata->config4 = adt7475_read(REG_CONFIG4);\r\ndata->config5 = adt7475_read(REG_CONFIG5);\r\nfor (i = 0; i < ADT7475_VOLTAGE_COUNT; i++) {\r\nif (!(data->has_voltage & (1 << i)))\r\ncontinue;\r\ndata->voltage[MIN][i] =\r\nadt7475_read(VOLTAGE_MIN_REG(i)) << 2;\r\ndata->voltage[MAX][i] =\r\nadt7475_read(VOLTAGE_MAX_REG(i)) << 2;\r\n}\r\nif (data->has_voltage & (1 << 5)) {\r\ndata->voltage[MIN][5] = adt7475_read(REG_VTT_MIN) << 2;\r\ndata->voltage[MAX][5] = adt7475_read(REG_VTT_MAX) << 2;\r\n}\r\nfor (i = 0; i < ADT7475_TEMP_COUNT; i++) {\r\ndata->temp[MIN][i] =\r\nadt7475_read(TEMP_MIN_REG(i)) << 2;\r\ndata->temp[MAX][i] =\r\nadt7475_read(TEMP_MAX_REG(i)) << 2;\r\ndata->temp[AUTOMIN][i] =\r\nadt7475_read(TEMP_TMIN_REG(i)) << 2;\r\ndata->temp[THERM][i] =\r\nadt7475_read(TEMP_THERM_REG(i)) << 2;\r\ndata->temp[OFFSET][i] =\r\nadt7475_read(TEMP_OFFSET_REG(i));\r\n}\r\nadt7475_read_hystersis(client);\r\nfor (i = 0; i < ADT7475_TACH_COUNT; i++) {\r\nif (i == 3 && !data->has_fan4)\r\ncontinue;\r\ndata->tach[MIN][i] =\r\nadt7475_read_word(client, TACH_MIN_REG(i));\r\n}\r\nfor (i = 0; i < ADT7475_PWM_COUNT; i++) {\r\nif (i == 1 && !data->has_pwm2)\r\ncontinue;\r\ndata->pwm[MAX][i] = adt7475_read(PWM_MAX_REG(i));\r\ndata->pwm[MIN][i] = adt7475_read(PWM_MIN_REG(i));\r\nadt7475_read_pwm(client, i);\r\n}\r\ndata->range[0] = adt7475_read(TEMP_TRANGE_REG(0));\r\ndata->range[1] = adt7475_read(TEMP_TRANGE_REG(1));\r\ndata->range[2] = adt7475_read(TEMP_TRANGE_REG(2));\r\ndata->limits_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn data;\r\n}
