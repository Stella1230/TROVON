static void\r\nshrink_idmap_tree(struct rb_root *root, int nr_to_scan, int *nr_rem,\r\nint *nr_del)\r\n{\r\nstruct rb_node *node;\r\nstruct rb_node *tmp;\r\nstruct cifs_sid_id *psidid;\r\nnode = rb_first(root);\r\nwhile (node) {\r\ntmp = node;\r\nnode = rb_next(tmp);\r\npsidid = rb_entry(tmp, struct cifs_sid_id, rbnode);\r\nif (nr_to_scan == 0 || *nr_del == nr_to_scan)\r\n++(*nr_rem);\r\nelse {\r\nif (time_after(jiffies, psidid->time + SID_MAP_EXPIRE)\r\n&& psidid->refcount == 0) {\r\nrb_erase(tmp, root);\r\n++(*nr_del);\r\n} else\r\n++(*nr_rem);\r\n}\r\n}\r\n}\r\nstatic int\r\ncifs_idmap_shrinker(struct shrinker *shrink, struct shrink_control *sc)\r\n{\r\nint nr_to_scan = sc->nr_to_scan;\r\nint nr_del = 0;\r\nint nr_rem = 0;\r\nstruct rb_root *root;\r\nroot = &uidtree;\r\nspin_lock(&siduidlock);\r\nshrink_idmap_tree(root, nr_to_scan, &nr_rem, &nr_del);\r\nspin_unlock(&siduidlock);\r\nroot = &gidtree;\r\nspin_lock(&sidgidlock);\r\nshrink_idmap_tree(root, nr_to_scan, &nr_rem, &nr_del);\r\nspin_unlock(&sidgidlock);\r\nroot = &siduidtree;\r\nspin_lock(&uidsidlock);\r\nshrink_idmap_tree(root, nr_to_scan, &nr_rem, &nr_del);\r\nspin_unlock(&uidsidlock);\r\nroot = &sidgidtree;\r\nspin_lock(&gidsidlock);\r\nshrink_idmap_tree(root, nr_to_scan, &nr_rem, &nr_del);\r\nspin_unlock(&gidsidlock);\r\nreturn nr_rem;\r\n}\r\nstatic void\r\nsid_rb_insert(struct rb_root *root, unsigned long cid,\r\nstruct cifs_sid_id **psidid, char *typestr)\r\n{\r\nchar *strptr;\r\nstruct rb_node *node = root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct rb_node **linkto = &(root->rb_node);\r\nstruct cifs_sid_id *lsidid;\r\nwhile (node) {\r\nlsidid = rb_entry(node, struct cifs_sid_id, rbnode);\r\nparent = node;\r\nif (cid > lsidid->id) {\r\nlinkto = &(node->rb_left);\r\nnode = node->rb_left;\r\n}\r\nif (cid < lsidid->id) {\r\nlinkto = &(node->rb_right);\r\nnode = node->rb_right;\r\n}\r\n}\r\n(*psidid)->id = cid;\r\n(*psidid)->time = jiffies - (SID_MAP_RETRY + 1);\r\n(*psidid)->refcount = 0;\r\nsprintf((*psidid)->sidstr, "%s", typestr);\r\nstrptr = (*psidid)->sidstr + strlen((*psidid)->sidstr);\r\nsprintf(strptr, "%ld", cid);\r\nclear_bit(SID_ID_PENDING, &(*psidid)->state);\r\nclear_bit(SID_ID_MAPPED, &(*psidid)->state);\r\nrb_link_node(&(*psidid)->rbnode, parent, linkto);\r\nrb_insert_color(&(*psidid)->rbnode, root);\r\n}\r\nstatic struct cifs_sid_id *\r\nsid_rb_search(struct rb_root *root, unsigned long cid)\r\n{\r\nstruct rb_node *node = root->rb_node;\r\nstruct cifs_sid_id *lsidid;\r\nwhile (node) {\r\nlsidid = rb_entry(node, struct cifs_sid_id, rbnode);\r\nif (cid > lsidid->id)\r\nnode = node->rb_left;\r\nelse if (cid < lsidid->id)\r\nnode = node->rb_right;\r\nelse\r\nreturn lsidid;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\ncifs_idmap_key_instantiate(struct key *key, const void *data, size_t datalen)\r\n{\r\nchar *payload;\r\npayload = kmalloc(datalen, GFP_KERNEL);\r\nif (!payload)\r\nreturn -ENOMEM;\r\nmemcpy(payload, data, datalen);\r\nkey->payload.data = payload;\r\nkey->datalen = datalen;\r\nreturn 0;\r\n}\r\nstatic inline void\r\ncifs_idmap_key_destroy(struct key *key)\r\n{\r\nkfree(key->payload.data);\r\n}\r\nstatic void\r\nsid_to_str(struct cifs_sid *sidptr, char *sidstr)\r\n{\r\nint i;\r\nunsigned long saval;\r\nchar *strptr;\r\nstrptr = sidstr;\r\nsprintf(strptr, "%s", "S");\r\nstrptr = sidstr + strlen(sidstr);\r\nsprintf(strptr, "-%d", sidptr->revision);\r\nstrptr = sidstr + strlen(sidstr);\r\nfor (i = 0; i < 6; ++i) {\r\nif (sidptr->authority[i]) {\r\nsprintf(strptr, "-%d", sidptr->authority[i]);\r\nstrptr = sidstr + strlen(sidstr);\r\n}\r\n}\r\nfor (i = 0; i < sidptr->num_subauth; ++i) {\r\nsaval = le32_to_cpu(sidptr->sub_auth[i]);\r\nsprintf(strptr, "-%ld", saval);\r\nstrptr = sidstr + strlen(sidstr);\r\n}\r\n}\r\nstatic void\r\nid_rb_insert(struct rb_root *root, struct cifs_sid *sidptr,\r\nstruct cifs_sid_id **psidid, char *typestr)\r\n{\r\nint rc;\r\nchar *strptr;\r\nstruct rb_node *node = root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct rb_node **linkto = &(root->rb_node);\r\nstruct cifs_sid_id *lsidid;\r\nwhile (node) {\r\nlsidid = rb_entry(node, struct cifs_sid_id, rbnode);\r\nparent = node;\r\nrc = compare_sids(sidptr, &((lsidid)->sid));\r\nif (rc > 0) {\r\nlinkto = &(node->rb_left);\r\nnode = node->rb_left;\r\n} else if (rc < 0) {\r\nlinkto = &(node->rb_right);\r\nnode = node->rb_right;\r\n}\r\n}\r\nmemcpy(&(*psidid)->sid, sidptr, sizeof(struct cifs_sid));\r\n(*psidid)->time = jiffies - (SID_MAP_RETRY + 1);\r\n(*psidid)->refcount = 0;\r\nsprintf((*psidid)->sidstr, "%s", typestr);\r\nstrptr = (*psidid)->sidstr + strlen((*psidid)->sidstr);\r\nsid_to_str(&(*psidid)->sid, strptr);\r\nclear_bit(SID_ID_PENDING, &(*psidid)->state);\r\nclear_bit(SID_ID_MAPPED, &(*psidid)->state);\r\nrb_link_node(&(*psidid)->rbnode, parent, linkto);\r\nrb_insert_color(&(*psidid)->rbnode, root);\r\n}\r\nstatic struct cifs_sid_id *\r\nid_rb_search(struct rb_root *root, struct cifs_sid *sidptr)\r\n{\r\nint rc;\r\nstruct rb_node *node = root->rb_node;\r\nstruct cifs_sid_id *lsidid;\r\nwhile (node) {\r\nlsidid = rb_entry(node, struct cifs_sid_id, rbnode);\r\nrc = compare_sids(sidptr, &((lsidid)->sid));\r\nif (rc > 0) {\r\nnode = node->rb_left;\r\n} else if (rc < 0) {\r\nnode = node->rb_right;\r\n} else\r\nreturn lsidid;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nsidid_pending_wait(void *unused)\r\n{\r\nschedule();\r\nreturn signal_pending(current) ? -ERESTARTSYS : 0;\r\n}\r\nstatic int\r\nid_to_sid(unsigned long cid, uint sidtype, struct cifs_sid *ssid)\r\n{\r\nint rc = 0;\r\nstruct key *sidkey;\r\nconst struct cred *saved_cred;\r\nstruct cifs_sid *lsid;\r\nstruct cifs_sid_id *psidid, *npsidid;\r\nstruct rb_root *cidtree;\r\nspinlock_t *cidlock;\r\nif (sidtype == SIDOWNER) {\r\ncidlock = &siduidlock;\r\ncidtree = &uidtree;\r\n} else if (sidtype == SIDGROUP) {\r\ncidlock = &sidgidlock;\r\ncidtree = &gidtree;\r\n} else\r\nreturn -EINVAL;\r\nspin_lock(cidlock);\r\npsidid = sid_rb_search(cidtree, cid);\r\nif (!psidid) {\r\nspin_unlock(cidlock);\r\nnpsidid = kzalloc(sizeof(struct cifs_sid_id), GFP_KERNEL);\r\nif (!npsidid)\r\nreturn -ENOMEM;\r\nnpsidid->sidstr = kmalloc(SIDLEN, GFP_KERNEL);\r\nif (!npsidid->sidstr) {\r\nkfree(npsidid);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(cidlock);\r\npsidid = sid_rb_search(cidtree, cid);\r\nif (psidid) {\r\n++psidid->refcount;\r\nspin_unlock(cidlock);\r\nkfree(npsidid->sidstr);\r\nkfree(npsidid);\r\n} else {\r\npsidid = npsidid;\r\nsid_rb_insert(cidtree, cid, &psidid,\r\nsidtype == SIDOWNER ? "oi:" : "gi:");\r\n++psidid->refcount;\r\nspin_unlock(cidlock);\r\n}\r\n} else {\r\n++psidid->refcount;\r\nspin_unlock(cidlock);\r\n}\r\nif (test_bit(SID_ID_MAPPED, &psidid->state)) {\r\nmemcpy(ssid, &psidid->sid, sizeof(struct cifs_sid));\r\npsidid->time = jiffies;\r\ngoto id_sid_out;\r\n}\r\nif (time_after(psidid->time + SID_MAP_RETRY, jiffies)) {\r\nrc = -EINVAL;\r\ngoto id_sid_out;\r\n}\r\nif (!test_and_set_bit(SID_ID_PENDING, &psidid->state)) {\r\nsaved_cred = override_creds(root_cred);\r\nsidkey = request_key(&cifs_idmap_key_type, psidid->sidstr, "");\r\nif (IS_ERR(sidkey)) {\r\nrc = -EINVAL;\r\ncFYI(1, "%s: Can't map and id to a SID", __func__);\r\n} else {\r\nlsid = (struct cifs_sid *)sidkey->payload.data;\r\nmemcpy(&psidid->sid, lsid,\r\nsidkey->datalen < sizeof(struct cifs_sid) ?\r\nsidkey->datalen : sizeof(struct cifs_sid));\r\nmemcpy(ssid, &psidid->sid,\r\nsidkey->datalen < sizeof(struct cifs_sid) ?\r\nsidkey->datalen : sizeof(struct cifs_sid));\r\nset_bit(SID_ID_MAPPED, &psidid->state);\r\nkey_put(sidkey);\r\nkfree(psidid->sidstr);\r\n}\r\npsidid->time = jiffies;\r\nrevert_creds(saved_cred);\r\nclear_bit(SID_ID_PENDING, &psidid->state);\r\nwake_up_bit(&psidid->state, SID_ID_PENDING);\r\n} else {\r\nrc = wait_on_bit(&psidid->state, SID_ID_PENDING,\r\nsidid_pending_wait, TASK_INTERRUPTIBLE);\r\nif (rc) {\r\ncFYI(1, "%s: sidid_pending_wait interrupted %d",\r\n__func__, rc);\r\n--psidid->refcount;\r\nreturn rc;\r\n}\r\nif (test_bit(SID_ID_MAPPED, &psidid->state))\r\nmemcpy(ssid, &psidid->sid, sizeof(struct cifs_sid));\r\nelse\r\nrc = -EINVAL;\r\n}\r\nid_sid_out:\r\n--psidid->refcount;\r\nreturn rc;\r\n}\r\nstatic int\r\nsid_to_id(struct cifs_sb_info *cifs_sb, struct cifs_sid *psid,\r\nstruct cifs_fattr *fattr, uint sidtype)\r\n{\r\nint rc;\r\nunsigned long cid;\r\nstruct key *idkey;\r\nconst struct cred *saved_cred;\r\nstruct cifs_sid_id *psidid, *npsidid;\r\nstruct rb_root *cidtree;\r\nspinlock_t *cidlock;\r\nif (sidtype == SIDOWNER) {\r\ncid = cifs_sb->mnt_uid;\r\ncidlock = &siduidlock;\r\ncidtree = &uidtree;\r\n} else if (sidtype == SIDGROUP) {\r\ncid = cifs_sb->mnt_gid;\r\ncidlock = &sidgidlock;\r\ncidtree = &gidtree;\r\n} else\r\nreturn -ENOENT;\r\nspin_lock(cidlock);\r\npsidid = id_rb_search(cidtree, psid);\r\nif (!psidid) {\r\nspin_unlock(cidlock);\r\nnpsidid = kzalloc(sizeof(struct cifs_sid_id), GFP_KERNEL);\r\nif (!npsidid)\r\nreturn -ENOMEM;\r\nnpsidid->sidstr = kmalloc(SIDLEN, GFP_KERNEL);\r\nif (!npsidid->sidstr) {\r\nkfree(npsidid);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(cidlock);\r\npsidid = id_rb_search(cidtree, psid);\r\nif (psidid) {\r\n++psidid->refcount;\r\nspin_unlock(cidlock);\r\nkfree(npsidid->sidstr);\r\nkfree(npsidid);\r\n} else {\r\npsidid = npsidid;\r\nid_rb_insert(cidtree, psid, &psidid,\r\nsidtype == SIDOWNER ? "os:" : "gs:");\r\n++psidid->refcount;\r\nspin_unlock(cidlock);\r\n}\r\n} else {\r\n++psidid->refcount;\r\nspin_unlock(cidlock);\r\n}\r\nif (test_bit(SID_ID_MAPPED, &psidid->state)) {\r\ncid = psidid->id;\r\npsidid->time = jiffies;\r\ngoto sid_to_id_out;\r\n}\r\nif (time_after(psidid->time + SID_MAP_RETRY, jiffies))\r\ngoto sid_to_id_out;\r\nif (!test_and_set_bit(SID_ID_PENDING, &psidid->state)) {\r\nsaved_cred = override_creds(root_cred);\r\nidkey = request_key(&cifs_idmap_key_type, psidid->sidstr, "");\r\nif (IS_ERR(idkey))\r\ncFYI(1, "%s: Can't map SID to an id", __func__);\r\nelse {\r\ncid = *(unsigned long *)idkey->payload.value;\r\npsidid->id = cid;\r\nset_bit(SID_ID_MAPPED, &psidid->state);\r\nkey_put(idkey);\r\nkfree(psidid->sidstr);\r\n}\r\nrevert_creds(saved_cred);\r\npsidid->time = jiffies;\r\nclear_bit(SID_ID_PENDING, &psidid->state);\r\nwake_up_bit(&psidid->state, SID_ID_PENDING);\r\n} else {\r\nrc = wait_on_bit(&psidid->state, SID_ID_PENDING,\r\nsidid_pending_wait, TASK_INTERRUPTIBLE);\r\nif (rc) {\r\ncFYI(1, "%s: sidid_pending_wait interrupted %d",\r\n__func__, rc);\r\n--psidid->refcount;\r\nreturn rc;\r\n}\r\nif (test_bit(SID_ID_MAPPED, &psidid->state))\r\ncid = psidid->id;\r\n}\r\nsid_to_id_out:\r\n--psidid->refcount;\r\nif (sidtype == SIDOWNER)\r\nfattr->cf_uid = cid;\r\nelse\r\nfattr->cf_gid = cid;\r\nreturn 0;\r\n}\r\nint\r\ninit_cifs_idmap(void)\r\n{\r\nstruct cred *cred;\r\nstruct key *keyring;\r\nint ret;\r\ncFYI(1, "Registering the %s key type\n", cifs_idmap_key_type.name);\r\ncred = prepare_kernel_cred(NULL);\r\nif (!cred)\r\nreturn -ENOMEM;\r\nkeyring = key_alloc(&key_type_keyring, ".cifs_idmap", 0, 0, cred,\r\n(KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ,\r\nKEY_ALLOC_NOT_IN_QUOTA);\r\nif (IS_ERR(keyring)) {\r\nret = PTR_ERR(keyring);\r\ngoto failed_put_cred;\r\n}\r\nret = key_instantiate_and_link(keyring, NULL, 0, NULL, NULL);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nret = register_key_type(&cifs_idmap_key_type);\r\nif (ret < 0)\r\ngoto failed_put_key;\r\nset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\r\ncred->thread_keyring = keyring;\r\ncred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\r\nroot_cred = cred;\r\nspin_lock_init(&siduidlock);\r\nuidtree = RB_ROOT;\r\nspin_lock_init(&sidgidlock);\r\ngidtree = RB_ROOT;\r\nspin_lock_init(&uidsidlock);\r\nsiduidtree = RB_ROOT;\r\nspin_lock_init(&gidsidlock);\r\nsidgidtree = RB_ROOT;\r\nregister_shrinker(&cifs_shrinker);\r\ncFYI(1, "cifs idmap keyring: %d\n", key_serial(keyring));\r\nreturn 0;\r\nfailed_put_key:\r\nkey_put(keyring);\r\nfailed_put_cred:\r\nput_cred(cred);\r\nreturn ret;\r\n}\r\nvoid\r\nexit_cifs_idmap(void)\r\n{\r\nkey_revoke(root_cred->thread_keyring);\r\nunregister_key_type(&cifs_idmap_key_type);\r\nput_cred(root_cred);\r\nunregister_shrinker(&cifs_shrinker);\r\ncFYI(1, "Unregistered %s key type\n", cifs_idmap_key_type.name);\r\n}\r\nvoid\r\ncifs_destroy_idmaptrees(void)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *node;\r\nroot = &uidtree;\r\nspin_lock(&siduidlock);\r\nwhile ((node = rb_first(root)))\r\nrb_erase(node, root);\r\nspin_unlock(&siduidlock);\r\nroot = &gidtree;\r\nspin_lock(&sidgidlock);\r\nwhile ((node = rb_first(root)))\r\nrb_erase(node, root);\r\nspin_unlock(&sidgidlock);\r\nroot = &siduidtree;\r\nspin_lock(&uidsidlock);\r\nwhile ((node = rb_first(root)))\r\nrb_erase(node, root);\r\nspin_unlock(&uidsidlock);\r\nroot = &sidgidtree;\r\nspin_lock(&gidsidlock);\r\nwhile ((node = rb_first(root)))\r\nrb_erase(node, root);\r\nspin_unlock(&gidsidlock);\r\n}\r\nint compare_sids(const struct cifs_sid *ctsid, const struct cifs_sid *cwsid)\r\n{\r\nint i;\r\nint num_subauth, num_sat, num_saw;\r\nif ((!ctsid) || (!cwsid))\r\nreturn 1;\r\nif (ctsid->revision != cwsid->revision) {\r\nif (ctsid->revision > cwsid->revision)\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\nfor (i = 0; i < 6; ++i) {\r\nif (ctsid->authority[i] != cwsid->authority[i]) {\r\nif (ctsid->authority[i] > cwsid->authority[i])\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\n}\r\nnum_sat = ctsid->num_subauth;\r\nnum_saw = cwsid->num_subauth;\r\nnum_subauth = num_sat < num_saw ? num_sat : num_saw;\r\nif (num_subauth) {\r\nfor (i = 0; i < num_subauth; ++i) {\r\nif (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {\r\nif (le32_to_cpu(ctsid->sub_auth[i]) >\r\nle32_to_cpu(cwsid->sub_auth[i]))\r\nreturn 1;\r\nelse\r\nreturn -1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void copy_sec_desc(const struct cifs_ntsd *pntsd,\r\nstruct cifs_ntsd *pnntsd, __u32 sidsoffset)\r\n{\r\nint i;\r\nstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\r\nstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\r\npnntsd->revision = pntsd->revision;\r\npnntsd->type = pntsd->type;\r\npnntsd->dacloffset = cpu_to_le32(sizeof(struct cifs_ntsd));\r\npnntsd->sacloffset = 0;\r\npnntsd->osidoffset = cpu_to_le32(sidsoffset);\r\npnntsd->gsidoffset = cpu_to_le32(sidsoffset + sizeof(struct cifs_sid));\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->osidoffset));\r\nnowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset);\r\nnowner_sid_ptr->revision = owner_sid_ptr->revision;\r\nnowner_sid_ptr->num_subauth = owner_sid_ptr->num_subauth;\r\nfor (i = 0; i < 6; i++)\r\nnowner_sid_ptr->authority[i] = owner_sid_ptr->authority[i];\r\nfor (i = 0; i < 5; i++)\r\nnowner_sid_ptr->sub_auth[i] = owner_sid_ptr->sub_auth[i];\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->gsidoffset));\r\nngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd + sidsoffset +\r\nsizeof(struct cifs_sid));\r\nngroup_sid_ptr->revision = group_sid_ptr->revision;\r\nngroup_sid_ptr->num_subauth = group_sid_ptr->num_subauth;\r\nfor (i = 0; i < 6; i++)\r\nngroup_sid_ptr->authority[i] = group_sid_ptr->authority[i];\r\nfor (i = 0; i < 5; i++)\r\nngroup_sid_ptr->sub_auth[i] = group_sid_ptr->sub_auth[i];\r\nreturn;\r\n}\r\nstatic void access_flags_to_mode(__le32 ace_flags, int type, umode_t *pmode,\r\numode_t *pbits_to_set)\r\n{\r\n__u32 flags = le32_to_cpu(ace_flags);\r\nif (type == ACCESS_DENIED) {\r\nif (flags & GENERIC_ALL)\r\n*pbits_to_set &= ~S_IRWXUGO;\r\nif ((flags & GENERIC_WRITE) ||\r\n((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\r\n*pbits_to_set &= ~S_IWUGO;\r\nif ((flags & GENERIC_READ) ||\r\n((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\r\n*pbits_to_set &= ~S_IRUGO;\r\nif ((flags & GENERIC_EXECUTE) ||\r\n((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\r\n*pbits_to_set &= ~S_IXUGO;\r\nreturn;\r\n} else if (type != ACCESS_ALLOWED) {\r\ncERROR(1, "unknown access control type %d", type);\r\nreturn;\r\n}\r\nif (flags & GENERIC_ALL) {\r\n*pmode |= (S_IRWXUGO & (*pbits_to_set));\r\ncFYI(DBG2, "all perms");\r\nreturn;\r\n}\r\nif ((flags & GENERIC_WRITE) ||\r\n((flags & FILE_WRITE_RIGHTS) == FILE_WRITE_RIGHTS))\r\n*pmode |= (S_IWUGO & (*pbits_to_set));\r\nif ((flags & GENERIC_READ) ||\r\n((flags & FILE_READ_RIGHTS) == FILE_READ_RIGHTS))\r\n*pmode |= (S_IRUGO & (*pbits_to_set));\r\nif ((flags & GENERIC_EXECUTE) ||\r\n((flags & FILE_EXEC_RIGHTS) == FILE_EXEC_RIGHTS))\r\n*pmode |= (S_IXUGO & (*pbits_to_set));\r\ncFYI(DBG2, "access flags 0x%x mode now 0x%x", flags, *pmode);\r\nreturn;\r\n}\r\nstatic void mode_to_access_flags(umode_t mode, umode_t bits_to_use,\r\n__u32 *pace_flags)\r\n{\r\n*pace_flags = 0x0;\r\nmode &= bits_to_use;\r\nif (mode & S_IRUGO)\r\n*pace_flags |= SET_FILE_READ_RIGHTS;\r\nif (mode & S_IWUGO)\r\n*pace_flags |= SET_FILE_WRITE_RIGHTS;\r\nif (mode & S_IXUGO)\r\n*pace_flags |= SET_FILE_EXEC_RIGHTS;\r\ncFYI(DBG2, "mode: 0x%x, access flags now 0x%x", mode, *pace_flags);\r\nreturn;\r\n}\r\nstatic __u16 fill_ace_for_sid(struct cifs_ace *pntace,\r\nconst struct cifs_sid *psid, __u64 nmode, umode_t bits)\r\n{\r\nint i;\r\n__u16 size = 0;\r\n__u32 access_req = 0;\r\npntace->type = ACCESS_ALLOWED;\r\npntace->flags = 0x0;\r\nmode_to_access_flags(nmode, bits, &access_req);\r\nif (!access_req)\r\naccess_req = SET_MINIMUM_RIGHTS;\r\npntace->access_req = cpu_to_le32(access_req);\r\npntace->sid.revision = psid->revision;\r\npntace->sid.num_subauth = psid->num_subauth;\r\nfor (i = 0; i < 6; i++)\r\npntace->sid.authority[i] = psid->authority[i];\r\nfor (i = 0; i < psid->num_subauth; i++)\r\npntace->sid.sub_auth[i] = psid->sub_auth[i];\r\nsize = 1 + 1 + 2 + 4 + 1 + 1 + 6 + (psid->num_subauth * 4);\r\npntace->size = cpu_to_le16(size);\r\nreturn size;\r\n}\r\nstatic void dump_ace(struct cifs_ace *pace, char *end_of_acl)\r\n{\r\nint num_subauth;\r\nif (le16_to_cpu(pace->size) < 16) {\r\ncERROR(1, "ACE too small %d", le16_to_cpu(pace->size));\r\nreturn;\r\n}\r\nif (end_of_acl < (char *)pace + le16_to_cpu(pace->size)) {\r\ncERROR(1, "ACL too small to parse ACE");\r\nreturn;\r\n}\r\nnum_subauth = pace->sid.num_subauth;\r\nif (num_subauth) {\r\nint i;\r\ncFYI(1, "ACE revision %d num_auth %d type %d flags %d size %d",\r\npace->sid.revision, pace->sid.num_subauth, pace->type,\r\npace->flags, le16_to_cpu(pace->size));\r\nfor (i = 0; i < num_subauth; ++i) {\r\ncFYI(1, "ACE sub_auth[%d]: 0x%x", i,\r\nle32_to_cpu(pace->sid.sub_auth[i]));\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic void parse_dacl(struct cifs_acl *pdacl, char *end_of_acl,\r\nstruct cifs_sid *pownersid, struct cifs_sid *pgrpsid,\r\nstruct cifs_fattr *fattr)\r\n{\r\nint i;\r\nint num_aces = 0;\r\nint acl_size;\r\nchar *acl_base;\r\nstruct cifs_ace **ppace;\r\nif (!pdacl) {\r\nfattr->cf_mode |= S_IRWXUGO;\r\nreturn;\r\n}\r\nif (end_of_acl < (char *)pdacl + le16_to_cpu(pdacl->size)) {\r\ncERROR(1, "ACL too small to parse DACL");\r\nreturn;\r\n}\r\ncFYI(DBG2, "DACL revision %d size %d num aces %d",\r\nle16_to_cpu(pdacl->revision), le16_to_cpu(pdacl->size),\r\nle32_to_cpu(pdacl->num_aces));\r\nfattr->cf_mode &= ~(S_IRWXUGO);\r\nacl_base = (char *)pdacl;\r\nacl_size = sizeof(struct cifs_acl);\r\nnum_aces = le32_to_cpu(pdacl->num_aces);\r\nif (num_aces > 0) {\r\numode_t user_mask = S_IRWXU;\r\numode_t group_mask = S_IRWXG;\r\numode_t other_mask = S_IRWXU | S_IRWXG | S_IRWXO;\r\nif (num_aces > ULONG_MAX / sizeof(struct cifs_ace *))\r\nreturn;\r\nppace = kmalloc(num_aces * sizeof(struct cifs_ace *),\r\nGFP_KERNEL);\r\nif (!ppace) {\r\ncERROR(1, "DACL memory allocation error");\r\nreturn;\r\n}\r\nfor (i = 0; i < num_aces; ++i) {\r\nppace[i] = (struct cifs_ace *) (acl_base + acl_size);\r\n#ifdef CONFIG_CIFS_DEBUG2\r\ndump_ace(ppace[i], end_of_acl);\r\n#endif\r\nif (compare_sids(&(ppace[i]->sid), pownersid) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&user_mask);\r\nif (compare_sids(&(ppace[i]->sid), pgrpsid) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&group_mask);\r\nif (compare_sids(&(ppace[i]->sid), &sid_everyone) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&other_mask);\r\nif (compare_sids(&(ppace[i]->sid), &sid_authusers) == 0)\r\naccess_flags_to_mode(ppace[i]->access_req,\r\nppace[i]->type,\r\n&fattr->cf_mode,\r\n&other_mask);\r\nacl_base = (char *)ppace[i];\r\nacl_size = le16_to_cpu(ppace[i]->size);\r\n}\r\nkfree(ppace);\r\n}\r\nreturn;\r\n}\r\nstatic int set_chmod_dacl(struct cifs_acl *pndacl, struct cifs_sid *pownersid,\r\nstruct cifs_sid *pgrpsid, __u64 nmode)\r\n{\r\nu16 size = 0;\r\nstruct cifs_acl *pnndacl;\r\npnndacl = (struct cifs_acl *)((char *)pndacl + sizeof(struct cifs_acl));\r\nsize += fill_ace_for_sid((struct cifs_ace *) ((char *)pnndacl + size),\r\npownersid, nmode, S_IRWXU);\r\nsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\r\npgrpsid, nmode, S_IRWXG);\r\nsize += fill_ace_for_sid((struct cifs_ace *)((char *)pnndacl + size),\r\n&sid_everyone, nmode, S_IRWXO);\r\npndacl->size = cpu_to_le16(size + sizeof(struct cifs_acl));\r\npndacl->num_aces = cpu_to_le32(3);\r\nreturn 0;\r\n}\r\nstatic int parse_sid(struct cifs_sid *psid, char *end_of_acl)\r\n{\r\nif (end_of_acl < (char *)psid + 8) {\r\ncERROR(1, "ACL too small to parse SID %p", psid);\r\nreturn -EINVAL;\r\n}\r\nif (psid->num_subauth) {\r\n#ifdef CONFIG_CIFS_DEBUG2\r\nint i;\r\ncFYI(1, "SID revision %d num_auth %d",\r\npsid->revision, psid->num_subauth);\r\nfor (i = 0; i < psid->num_subauth; i++) {\r\ncFYI(1, "SID sub_auth[%d]: 0x%x ", i,\r\nle32_to_cpu(psid->sub_auth[i]));\r\n}\r\ncFYI(1, "RID 0x%x",\r\nle32_to_cpu(psid->sub_auth[psid->num_subauth-1]));\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_sec_desc(struct cifs_sb_info *cifs_sb,\r\nstruct cifs_ntsd *pntsd, int acl_len, struct cifs_fattr *fattr)\r\n{\r\nint rc = 0;\r\nstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\r\nstruct cifs_acl *dacl_ptr;\r\nchar *end_of_acl = ((char *)pntsd) + acl_len;\r\n__u32 dacloffset;\r\nif (pntsd == NULL)\r\nreturn -EIO;\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->osidoffset));\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->gsidoffset));\r\ndacloffset = le32_to_cpu(pntsd->dacloffset);\r\ndacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\r\ncFYI(DBG2, "revision %d type 0x%x ooffset 0x%x goffset 0x%x "\r\n"sacloffset 0x%x dacloffset 0x%x",\r\npntsd->revision, pntsd->type, le32_to_cpu(pntsd->osidoffset),\r\nle32_to_cpu(pntsd->gsidoffset),\r\nle32_to_cpu(pntsd->sacloffset), dacloffset);\r\nrc = parse_sid(owner_sid_ptr, end_of_acl);\r\nif (rc) {\r\ncFYI(1, "%s: Error %d parsing Owner SID", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = sid_to_id(cifs_sb, owner_sid_ptr, fattr, SIDOWNER);\r\nif (rc) {\r\ncFYI(1, "%s: Error %d mapping Owner SID to uid", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = parse_sid(group_sid_ptr, end_of_acl);\r\nif (rc) {\r\ncFYI(1, "%s: Error %d mapping Owner SID to gid", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = sid_to_id(cifs_sb, group_sid_ptr, fattr, SIDGROUP);\r\nif (rc) {\r\ncFYI(1, "%s: Error %d mapping Group SID to gid", __func__, rc);\r\nreturn rc;\r\n}\r\nif (dacloffset)\r\nparse_dacl(dacl_ptr, end_of_acl, owner_sid_ptr,\r\ngroup_sid_ptr, fattr);\r\nelse\r\ncFYI(1, "no ACL");\r\nreturn rc;\r\n}\r\nstatic int build_sec_desc(struct cifs_ntsd *pntsd, struct cifs_ntsd *pnntsd,\r\n__u32 secdesclen, __u64 nmode, uid_t uid, gid_t gid, int *aclflag)\r\n{\r\nint rc = 0;\r\n__u32 dacloffset;\r\n__u32 ndacloffset;\r\n__u32 sidsoffset;\r\nstruct cifs_sid *owner_sid_ptr, *group_sid_ptr;\r\nstruct cifs_sid *nowner_sid_ptr, *ngroup_sid_ptr;\r\nstruct cifs_acl *dacl_ptr = NULL;\r\nstruct cifs_acl *ndacl_ptr = NULL;\r\nif (nmode != NO_CHANGE_64) {\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->osidoffset));\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pntsd +\r\nle32_to_cpu(pntsd->gsidoffset));\r\ndacloffset = le32_to_cpu(pntsd->dacloffset);\r\ndacl_ptr = (struct cifs_acl *)((char *)pntsd + dacloffset);\r\nndacloffset = sizeof(struct cifs_ntsd);\r\nndacl_ptr = (struct cifs_acl *)((char *)pnntsd + ndacloffset);\r\nndacl_ptr->revision = dacl_ptr->revision;\r\nndacl_ptr->size = 0;\r\nndacl_ptr->num_aces = 0;\r\nrc = set_chmod_dacl(ndacl_ptr, owner_sid_ptr, group_sid_ptr,\r\nnmode);\r\nsidsoffset = ndacloffset + le16_to_cpu(ndacl_ptr->size);\r\ncopy_sec_desc(pntsd, pnntsd, sidsoffset);\r\n*aclflag = CIFS_ACL_DACL;\r\n} else {\r\nmemcpy(pnntsd, pntsd, secdesclen);\r\nif (uid != NO_CHANGE_32) {\r\nowner_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\r\nle32_to_cpu(pnntsd->osidoffset));\r\nnowner_sid_ptr = kmalloc(sizeof(struct cifs_sid),\r\nGFP_KERNEL);\r\nif (!nowner_sid_ptr)\r\nreturn -ENOMEM;\r\nrc = id_to_sid(uid, SIDOWNER, nowner_sid_ptr);\r\nif (rc) {\r\ncFYI(1, "%s: Mapping error %d for owner id %d",\r\n__func__, rc, uid);\r\nkfree(nowner_sid_ptr);\r\nreturn rc;\r\n}\r\nmemcpy(owner_sid_ptr, nowner_sid_ptr,\r\nsizeof(struct cifs_sid));\r\nkfree(nowner_sid_ptr);\r\n*aclflag = CIFS_ACL_OWNER;\r\n}\r\nif (gid != NO_CHANGE_32) {\r\ngroup_sid_ptr = (struct cifs_sid *)((char *)pnntsd +\r\nle32_to_cpu(pnntsd->gsidoffset));\r\nngroup_sid_ptr = kmalloc(sizeof(struct cifs_sid),\r\nGFP_KERNEL);\r\nif (!ngroup_sid_ptr)\r\nreturn -ENOMEM;\r\nrc = id_to_sid(gid, SIDGROUP, ngroup_sid_ptr);\r\nif (rc) {\r\ncFYI(1, "%s: Mapping error %d for group id %d",\r\n__func__, rc, gid);\r\nkfree(ngroup_sid_ptr);\r\nreturn rc;\r\n}\r\nmemcpy(group_sid_ptr, ngroup_sid_ptr,\r\nsizeof(struct cifs_sid));\r\nkfree(ngroup_sid_ptr);\r\n*aclflag = CIFS_ACL_GROUP;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic struct cifs_ntsd *get_cifs_acl_by_fid(struct cifs_sb_info *cifs_sb,\r\n__u16 fid, u32 *pacllen)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nint xid, rc;\r\nstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn ERR_CAST(tlink);\r\nxid = GetXid();\r\nrc = CIFSSMBGetCIFSACL(xid, tlink_tcon(tlink), fid, &pntsd, pacllen);\r\nFreeXid(xid);\r\ncifs_put_tlink(tlink);\r\ncFYI(1, "%s: rc = %d ACL len %d", __func__, rc, *pacllen);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn pntsd;\r\n}\r\nstatic struct cifs_ntsd *get_cifs_acl_by_path(struct cifs_sb_info *cifs_sb,\r\nconst char *path, u32 *pacllen)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nint oplock = 0;\r\nint xid, rc, create_options = 0;\r\n__u16 fid;\r\nstruct cifs_tcon *tcon;\r\nstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn ERR_CAST(tlink);\r\ntcon = tlink_tcon(tlink);\r\nxid = GetXid();\r\nif (backup_cred(cifs_sb))\r\ncreate_options |= CREATE_OPEN_BACKUP_INTENT;\r\nrc = CIFSSMBOpen(xid, tcon, path, FILE_OPEN, READ_CONTROL,\r\ncreate_options, &fid, &oplock, NULL, cifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif (!rc) {\r\nrc = CIFSSMBGetCIFSACL(xid, tcon, fid, &pntsd, pacllen);\r\nCIFSSMBClose(xid, tcon, fid);\r\n}\r\ncifs_put_tlink(tlink);\r\nFreeXid(xid);\r\ncFYI(1, "%s: rc = %d ACL len %d", __func__, rc, *pacllen);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nreturn pntsd;\r\n}\r\nstruct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\r\nstruct inode *inode, const char *path,\r\nu32 *pacllen)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nstruct cifsFileInfo *open_file = NULL;\r\nif (inode)\r\nopen_file = find_readable_file(CIFS_I(inode), true);\r\nif (!open_file)\r\nreturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\r\npntsd = get_cifs_acl_by_fid(cifs_sb, open_file->netfid, pacllen);\r\ncifsFileInfo_put(open_file);\r\nreturn pntsd;\r\n}\r\nint set_cifs_acl(struct cifs_ntsd *pnntsd, __u32 acllen,\r\nstruct inode *inode, const char *path, int aclflag)\r\n{\r\nint oplock = 0;\r\nint xid, rc, access_flags, create_options = 0;\r\n__u16 fid;\r\nstruct cifs_tcon *tcon;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\ntcon = tlink_tcon(tlink);\r\nxid = GetXid();\r\nif (backup_cred(cifs_sb))\r\ncreate_options |= CREATE_OPEN_BACKUP_INTENT;\r\nif (aclflag == CIFS_ACL_OWNER || aclflag == CIFS_ACL_GROUP)\r\naccess_flags = WRITE_OWNER;\r\nelse\r\naccess_flags = WRITE_DAC;\r\nrc = CIFSSMBOpen(xid, tcon, path, FILE_OPEN, access_flags,\r\ncreate_options, &fid, &oplock, NULL, cifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif (rc) {\r\ncERROR(1, "Unable to open file to set ACL");\r\ngoto out;\r\n}\r\nrc = CIFSSMBSetCIFSACL(xid, tcon, fid, pnntsd, acllen, aclflag);\r\ncFYI(DBG2, "SetCIFSACL rc = %d", rc);\r\nCIFSSMBClose(xid, tcon, fid);\r\nout:\r\nFreeXid(xid);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nint\r\ncifs_acl_to_fattr(struct cifs_sb_info *cifs_sb, struct cifs_fattr *fattr,\r\nstruct inode *inode, const char *path, const __u16 *pfid)\r\n{\r\nstruct cifs_ntsd *pntsd = NULL;\r\nu32 acllen = 0;\r\nint rc = 0;\r\ncFYI(DBG2, "converting ACL to mode for %s", path);\r\nif (pfid)\r\npntsd = get_cifs_acl_by_fid(cifs_sb, *pfid, &acllen);\r\nelse\r\npntsd = get_cifs_acl(cifs_sb, inode, path, &acllen);\r\nif (IS_ERR(pntsd)) {\r\nrc = PTR_ERR(pntsd);\r\ncERROR(1, "%s: error %d getting sec desc", __func__, rc);\r\n} else {\r\nrc = parse_sec_desc(cifs_sb, pntsd, acllen, fattr);\r\nkfree(pntsd);\r\nif (rc)\r\ncERROR(1, "parse sec desc failed rc = %d", rc);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nid_mode_to_cifs_acl(struct inode *inode, const char *path, __u64 nmode,\r\nuid_t uid, gid_t gid)\r\n{\r\nint rc = 0;\r\nint aclflag = CIFS_ACL_DACL;\r\n__u32 secdesclen = 0;\r\nstruct cifs_ntsd *pntsd = NULL;\r\nstruct cifs_ntsd *pnntsd = NULL;\r\ncFYI(DBG2, "set ACL from mode for %s", path);\r\npntsd = get_cifs_acl(CIFS_SB(inode->i_sb), inode, path, &secdesclen);\r\nif (IS_ERR(pntsd)) {\r\nrc = PTR_ERR(pntsd);\r\ncERROR(1, "%s: error %d getting sec desc", __func__, rc);\r\n} else {\r\nsecdesclen = secdesclen < DEFSECDESCLEN ?\r\nDEFSECDESCLEN : secdesclen;\r\npnntsd = kmalloc(secdesclen, GFP_KERNEL);\r\nif (!pnntsd) {\r\ncERROR(1, "Unable to allocate security descriptor");\r\nkfree(pntsd);\r\nreturn -ENOMEM;\r\n}\r\nrc = build_sec_desc(pntsd, pnntsd, secdesclen, nmode, uid, gid,\r\n&aclflag);\r\ncFYI(DBG2, "build_sec_desc rc: %d", rc);\r\nif (!rc) {\r\nrc = set_cifs_acl(pnntsd, secdesclen, inode,\r\npath, aclflag);\r\ncFYI(DBG2, "set_cifs_acl rc: %d", rc);\r\n}\r\nkfree(pnntsd);\r\nkfree(pntsd);\r\n}\r\nreturn rc;\r\n}
