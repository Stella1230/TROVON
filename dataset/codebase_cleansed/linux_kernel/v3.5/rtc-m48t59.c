static void\r\nm48t59_mem_writeb(struct device *dev, u32 ofs, u8 val)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nwriteb(val, m48t59->ioaddr+ofs);\r\n}\r\nstatic u8\r\nm48t59_mem_readb(struct device *dev, u32 ofs)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nreturn readb(m48t59->ioaddr+ofs);\r\n}\r\nstatic int m48t59_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nu8 val;\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nM48T59_SET_BITS(M48T59_CNTL_READ, M48T59_CNTL);\r\ntm->tm_year = bcd2bin(M48T59_READ(M48T59_YEAR));\r\ntm->tm_mon = bcd2bin(M48T59_READ(M48T59_MONTH)) - 1;\r\ntm->tm_mday = bcd2bin(M48T59_READ(M48T59_MDAY));\r\nval = M48T59_READ(M48T59_WDAY);\r\nif ((pdata->type == M48T59RTC_TYPE_M48T59) &&\r\n(val & M48T59_WDAY_CEB) && (val & M48T59_WDAY_CB)) {\r\ndev_dbg(dev, "Century bit is enabled\n");\r\ntm->tm_year += 100;\r\n}\r\n#ifdef CONFIG_SPARC\r\ntm->tm_year += 68;\r\n#endif\r\ntm->tm_wday = bcd2bin(val & 0x07);\r\ntm->tm_hour = bcd2bin(M48T59_READ(M48T59_HOUR) & 0x3F);\r\ntm->tm_min = bcd2bin(M48T59_READ(M48T59_MIN) & 0x7F);\r\ntm->tm_sec = bcd2bin(M48T59_READ(M48T59_SEC) & 0x7F);\r\nM48T59_CLEAR_BITS(M48T59_CNTL_READ, M48T59_CNTL);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\ndev_dbg(dev, "RTC read time %04d-%02d-%02d %02d/%02d/%02d\n",\r\ntm->tm_year + 1900, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int m48t59_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nu8 val = 0;\r\nint year = tm->tm_year;\r\n#ifdef CONFIG_SPARC\r\nyear -= 68;\r\n#endif\r\ndev_dbg(dev, "RTC set time %04d-%02d-%02d %02d/%02d/%02d\n",\r\nyear + 1900, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nif (year < 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nM48T59_SET_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\r\nM48T59_WRITE((bin2bcd(tm->tm_sec) & 0x7F), M48T59_SEC);\r\nM48T59_WRITE((bin2bcd(tm->tm_min) & 0x7F), M48T59_MIN);\r\nM48T59_WRITE((bin2bcd(tm->tm_hour) & 0x3F), M48T59_HOUR);\r\nM48T59_WRITE((bin2bcd(tm->tm_mday) & 0x3F), M48T59_MDAY);\r\nM48T59_WRITE((bin2bcd(tm->tm_mon + 1) & 0x1F), M48T59_MONTH);\r\nM48T59_WRITE(bin2bcd(year % 100), M48T59_YEAR);\r\nif (pdata->type == M48T59RTC_TYPE_M48T59 && (year / 100))\r\nval = (M48T59_WDAY_CEB | M48T59_WDAY_CB);\r\nval |= (bin2bcd(tm->tm_wday) & 0x07);\r\nM48T59_WRITE(val, M48T59_WDAY);\r\nM48T59_CLEAR_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int m48t59_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nstruct rtc_time *tm = &alrm->time;\r\nunsigned long flags;\r\nu8 val;\r\nif (m48t59->irq == NO_IRQ)\r\nreturn -EIO;\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nM48T59_SET_BITS(M48T59_CNTL_READ, M48T59_CNTL);\r\ntm->tm_year = bcd2bin(M48T59_READ(M48T59_YEAR));\r\n#ifdef CONFIG_SPARC\r\ntm->tm_year += 68;\r\n#endif\r\ntm->tm_mon = bcd2bin(M48T59_READ(M48T59_MONTH)) - 1;\r\nval = M48T59_READ(M48T59_WDAY);\r\nif ((val & M48T59_WDAY_CEB) && (val & M48T59_WDAY_CB))\r\ntm->tm_year += 100;\r\ntm->tm_mday = bcd2bin(M48T59_READ(M48T59_ALARM_DATE));\r\ntm->tm_hour = bcd2bin(M48T59_READ(M48T59_ALARM_HOUR));\r\ntm->tm_min = bcd2bin(M48T59_READ(M48T59_ALARM_MIN));\r\ntm->tm_sec = bcd2bin(M48T59_READ(M48T59_ALARM_SEC));\r\nM48T59_CLEAR_BITS(M48T59_CNTL_READ, M48T59_CNTL);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\ndev_dbg(dev, "RTC read alarm time %04d-%02d-%02d %02d/%02d/%02d\n",\r\ntm->tm_year + 1900, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int m48t59_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nstruct rtc_time *tm = &alrm->time;\r\nu8 mday, hour, min, sec;\r\nunsigned long flags;\r\nint year = tm->tm_year;\r\n#ifdef CONFIG_SPARC\r\nyear -= 68;\r\n#endif\r\nif (m48t59->irq == NO_IRQ)\r\nreturn -EIO;\r\nif (year < 0)\r\nreturn -EINVAL;\r\nmday = tm->tm_mday;\r\nmday = (mday >= 1 && mday <= 31) ? bin2bcd(mday) : 0xff;\r\nif (mday == 0xff)\r\nmday = M48T59_READ(M48T59_MDAY);\r\nhour = tm->tm_hour;\r\nhour = (hour < 24) ? bin2bcd(hour) : 0x00;\r\nmin = tm->tm_min;\r\nmin = (min < 60) ? bin2bcd(min) : 0x00;\r\nsec = tm->tm_sec;\r\nsec = (sec < 60) ? bin2bcd(sec) : 0x00;\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nM48T59_SET_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\r\nM48T59_WRITE(mday, M48T59_ALARM_DATE);\r\nM48T59_WRITE(hour, M48T59_ALARM_HOUR);\r\nM48T59_WRITE(min, M48T59_ALARM_MIN);\r\nM48T59_WRITE(sec, M48T59_ALARM_SEC);\r\nM48T59_CLEAR_BITS(M48T59_CNTL_WRITE, M48T59_CNTL);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\ndev_dbg(dev, "RTC set alarm time %04d-%02d-%02d %02d/%02d/%02d\n",\r\nyear + 1900, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nreturn 0;\r\n}\r\nstatic int m48t59_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nif (enabled)\r\nM48T59_WRITE(M48T59_INTR_AFE, M48T59_INTR);\r\nelse\r\nM48T59_WRITE(0x00, M48T59_INTR);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int m48t59_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nu8 val;\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nval = M48T59_READ(M48T59_FLAGS);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\nseq_printf(seq, "battery\t\t: %s\n",\r\n(val & M48T59_FLAGS_BF) ? "low" : "normal");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t m48t59_rtc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct device *dev = (struct device *)dev_id;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nu8 event;\r\nspin_lock(&m48t59->lock);\r\nevent = M48T59_READ(M48T59_FLAGS);\r\nspin_unlock(&m48t59->lock);\r\nif (event & M48T59_FLAGS_AF) {\r\nrtc_update_irq(m48t59->rtc, 1, (RTC_AF | RTC_IRQF));\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic ssize_t m48t59_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nssize_t cnt = 0;\r\nunsigned long flags;\r\nfor (; size > 0 && pos < pdata->offset; cnt++, size--) {\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\n*buf++ = M48T59_READ(cnt);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\n}\r\nreturn cnt;\r\n}\r\nstatic ssize_t m48t59_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t size)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nssize_t cnt = 0;\r\nunsigned long flags;\r\nfor (; size > 0 && pos < pdata->offset; cnt++, size--) {\r\nspin_lock_irqsave(&m48t59->lock, flags);\r\nM48T59_WRITE(*buf++, cnt);\r\nspin_unlock_irqrestore(&m48t59->lock, flags);\r\n}\r\nreturn cnt;\r\n}\r\nstatic int __devinit m48t59_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nstruct m48t59_private *m48t59 = NULL;\r\nstruct resource *res;\r\nint ret = -ENOMEM;\r\nchar *name;\r\nconst struct rtc_class_ops *ops;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\n}\r\nif (res->flags & IORESOURCE_IO) {\r\nif (!pdata || !pdata->write_byte || !pdata->read_byte)\r\nreturn -EINVAL;\r\n} else if (res->flags & IORESOURCE_MEM) {\r\nif (!pdata) {\r\npdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdev->dev.platform_data = pdata;\r\n}\r\nif (!pdata->type)\r\npdata->type = M48T59RTC_TYPE_M48T59;\r\nif (!pdata->write_byte)\r\npdata->write_byte = m48t59_mem_writeb;\r\nif (!pdata->read_byte)\r\npdata->read_byte = m48t59_mem_readb;\r\n}\r\nm48t59 = kzalloc(sizeof(*m48t59), GFP_KERNEL);\r\nif (!m48t59)\r\nreturn -ENOMEM;\r\nm48t59->ioaddr = pdata->ioaddr;\r\nif (!m48t59->ioaddr) {\r\nm48t59->ioaddr = ioremap(res->start, resource_size(res));\r\nif (!m48t59->ioaddr)\r\ngoto out;\r\n}\r\nm48t59->irq = platform_get_irq(pdev, 0);\r\nif (m48t59->irq <= 0)\r\nm48t59->irq = NO_IRQ;\r\nif (m48t59->irq != NO_IRQ) {\r\nret = request_irq(m48t59->irq, m48t59_rtc_interrupt,\r\nIRQF_SHARED, "rtc-m48t59", &pdev->dev);\r\nif (ret)\r\ngoto out;\r\n}\r\nswitch (pdata->type) {\r\ncase M48T59RTC_TYPE_M48T59:\r\nname = "m48t59";\r\nops = &m48t59_rtc_ops;\r\npdata->offset = 0x1ff0;\r\nbreak;\r\ncase M48T59RTC_TYPE_M48T02:\r\nname = "m48t02";\r\nops = &m48t02_rtc_ops;\r\npdata->offset = 0x7f0;\r\nbreak;\r\ncase M48T59RTC_TYPE_M48T08:\r\nname = "m48t08";\r\nops = &m48t02_rtc_ops;\r\npdata->offset = 0x1ff0;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unknown RTC type\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nspin_lock_init(&m48t59->lock);\r\nplatform_set_drvdata(pdev, m48t59);\r\nm48t59->rtc = rtc_device_register(name, &pdev->dev, ops, THIS_MODULE);\r\nif (IS_ERR(m48t59->rtc)) {\r\nret = PTR_ERR(m48t59->rtc);\r\ngoto out;\r\n}\r\nm48t59_nvram_attr.size = pdata->offset;\r\nret = sysfs_create_bin_file(&pdev->dev.kobj, &m48t59_nvram_attr);\r\nif (ret) {\r\nrtc_device_unregister(m48t59->rtc);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nif (m48t59->irq != NO_IRQ)\r\nfree_irq(m48t59->irq, &pdev->dev);\r\nif (m48t59->ioaddr)\r\niounmap(m48t59->ioaddr);\r\nkfree(m48t59);\r\nreturn ret;\r\n}\r\nstatic int __devexit m48t59_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct m48t59_private *m48t59 = platform_get_drvdata(pdev);\r\nstruct m48t59_plat_data *pdata = pdev->dev.platform_data;\r\nsysfs_remove_bin_file(&pdev->dev.kobj, &m48t59_nvram_attr);\r\nif (!IS_ERR(m48t59->rtc))\r\nrtc_device_unregister(m48t59->rtc);\r\nif (m48t59->ioaddr && !pdata->ioaddr)\r\niounmap(m48t59->ioaddr);\r\nif (m48t59->irq != NO_IRQ)\r\nfree_irq(m48t59->irq, &pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(m48t59);\r\nreturn 0;\r\n}
