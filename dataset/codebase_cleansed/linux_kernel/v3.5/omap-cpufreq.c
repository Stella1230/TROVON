static int omap_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nif (!freq_table)\r\nreturn -EINVAL;\r\nreturn cpufreq_frequency_table_verify(policy, freq_table);\r\n}\r\nstatic unsigned int omap_getspeed(unsigned int cpu)\r\n{\r\nunsigned long rate;\r\nif (cpu >= NR_CPUS)\r\nreturn 0;\r\nrate = clk_get_rate(mpu_clk) / 1000;\r\nreturn rate;\r\n}\r\nstatic int omap_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int i;\r\nint r, ret = 0;\r\nstruct cpufreq_freqs freqs;\r\nstruct opp *opp;\r\nunsigned long freq, volt = 0, volt_old = 0, tol = 0;\r\nif (!freq_table) {\r\ndev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,\r\npolicy->cpu);\r\nreturn -EINVAL;\r\n}\r\nret = cpufreq_frequency_table_target(policy, freq_table, target_freq,\r\nrelation, &i);\r\nif (ret) {\r\ndev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",\r\n__func__, policy->cpu, target_freq, ret);\r\nreturn ret;\r\n}\r\nfreqs.new = freq_table[i].frequency;\r\nif (!freqs.new) {\r\ndev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,\r\npolicy->cpu, target_freq);\r\nreturn -EINVAL;\r\n}\r\nfreqs.old = omap_getspeed(policy->cpu);\r\nfreqs.cpu = policy->cpu;\r\nif (freqs.old == freqs.new && policy->cur == freqs.new)\r\nreturn ret;\r\nfor_each_cpu(i, policy->cpus) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\n}\r\nfreq = freqs.new * 1000;\r\nif (mpu_reg) {\r\nopp = opp_find_freq_ceil(mpu_dev, &freq);\r\nif (IS_ERR(opp)) {\r\ndev_err(mpu_dev, "%s: unable to find MPU OPP for %d\n",\r\n__func__, freqs.new);\r\nreturn -EINVAL;\r\n}\r\nvolt = opp_get_voltage(opp);\r\ntol = volt * OPP_TOLERANCE / 100;\r\nvolt_old = regulator_get_voltage(mpu_reg);\r\n}\r\ndev_dbg(mpu_dev, "cpufreq-omap: %u MHz, %ld mV --> %u MHz, %ld mV\n",\r\nfreqs.old / 1000, volt_old ? volt_old / 1000 : -1,\r\nfreqs.new / 1000, volt ? volt / 1000 : -1);\r\nif (mpu_reg && (freqs.new > freqs.old)) {\r\nr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\r\nif (r < 0) {\r\ndev_warn(mpu_dev, "%s: unable to scale voltage up.\n",\r\n__func__);\r\nfreqs.new = freqs.old;\r\ngoto done;\r\n}\r\n}\r\nret = clk_set_rate(mpu_clk, freqs.new * 1000);\r\nif (mpu_reg && (freqs.new < freqs.old)) {\r\nr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\r\nif (r < 0) {\r\ndev_warn(mpu_dev, "%s: unable to scale voltage down.\n",\r\n__func__);\r\nret = clk_set_rate(mpu_clk, freqs.old * 1000);\r\nfreqs.new = freqs.old;\r\ngoto done;\r\n}\r\n}\r\nfreqs.new = omap_getspeed(policy->cpu);\r\n#ifdef CONFIG_SMP\r\nfor_each_cpu(i, policy->cpus) {\r\nstruct lpj_info *lpj = &per_cpu(lpj_ref, i);\r\nif (!lpj->freq) {\r\nlpj->ref = per_cpu(cpu_data, i).loops_per_jiffy;\r\nlpj->freq = freqs.old;\r\n}\r\nper_cpu(cpu_data, i).loops_per_jiffy =\r\ncpufreq_scale(lpj->ref, lpj->freq, freqs.new);\r\n}\r\nif (!global_lpj_ref.freq) {\r\nglobal_lpj_ref.ref = loops_per_jiffy;\r\nglobal_lpj_ref.freq = freqs.old;\r\n}\r\nloops_per_jiffy = cpufreq_scale(global_lpj_ref.ref, global_lpj_ref.freq,\r\nfreqs.new);\r\n#endif\r\ndone:\r\nfor_each_cpu(i, policy->cpus) {\r\nfreqs.cpu = i;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void freq_table_free(void)\r\n{\r\nif (atomic_dec_and_test(&freq_table_users))\r\nopp_free_cpufreq_table(mpu_dev, &freq_table);\r\n}\r\nstatic int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nint result = 0;\r\nmpu_clk = clk_get(NULL, mpu_clk_name);\r\nif (IS_ERR(mpu_clk))\r\nreturn PTR_ERR(mpu_clk);\r\nif (policy->cpu >= NR_CPUS) {\r\nresult = -EINVAL;\r\ngoto fail_ck;\r\n}\r\npolicy->cur = policy->min = policy->max = omap_getspeed(policy->cpu);\r\nif (atomic_inc_return(&freq_table_users) == 1)\r\nresult = opp_init_cpufreq_table(mpu_dev, &freq_table);\r\nif (result) {\r\ndev_err(mpu_dev, "%s: cpu%d: failed creating freq table[%d]\n",\r\n__func__, policy->cpu, result);\r\ngoto fail_ck;\r\n}\r\nresult = cpufreq_frequency_table_cpuinfo(policy, freq_table);\r\nif (result)\r\ngoto fail_table;\r\ncpufreq_frequency_table_get_attr(freq_table, policy->cpu);\r\npolicy->min = policy->cpuinfo.min_freq;\r\npolicy->max = policy->cpuinfo.max_freq;\r\npolicy->cur = omap_getspeed(policy->cpu);\r\nif (is_smp()) {\r\npolicy->shared_type = CPUFREQ_SHARED_TYPE_ANY;\r\ncpumask_setall(policy->cpus);\r\n}\r\npolicy->cpuinfo.transition_latency = 300 * 1000;\r\nreturn 0;\r\nfail_table:\r\nfreq_table_free();\r\nfail_ck:\r\nclk_put(mpu_clk);\r\nreturn result;\r\n}\r\nstatic int omap_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nfreq_table_free();\r\nclk_put(mpu_clk);\r\nreturn 0;\r\n}\r\nstatic int __init omap_cpufreq_init(void)\r\n{\r\nif (cpu_is_omap24xx())\r\nmpu_clk_name = "virt_prcm_set";\r\nelse if (cpu_is_omap34xx())\r\nmpu_clk_name = "dpll1_ck";\r\nelse if (cpu_is_omap44xx())\r\nmpu_clk_name = "dpll_mpu_ck";\r\nif (!mpu_clk_name) {\r\npr_err("%s: unsupported Silicon?\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmpu_dev = omap_device_get_by_hwmod_name("mpu");\r\nif (!mpu_dev) {\r\npr_warning("%s: unable to get the mpu device\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmpu_reg = regulator_get(mpu_dev, "vcc");\r\nif (IS_ERR(mpu_reg)) {\r\npr_warning("%s: unable to get MPU regulator\n", __func__);\r\nmpu_reg = NULL;\r\n} else {\r\nif (regulator_get_voltage(mpu_reg) < 0) {\r\npr_warn("%s: physical regulator not present for MPU\n",\r\n__func__);\r\nregulator_put(mpu_reg);\r\nmpu_reg = NULL;\r\n}\r\n}\r\nreturn cpufreq_register_driver(&omap_driver);\r\n}\r\nstatic void __exit omap_cpufreq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&omap_driver);\r\n}
