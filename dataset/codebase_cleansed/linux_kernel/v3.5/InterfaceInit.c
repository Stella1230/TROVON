static void InterfaceAdapterFree(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nint i = 0;\r\nif (psIntfAdapter->psAdapter->LEDInfo.led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY) {\r\npsIntfAdapter->psAdapter->DriverState = DRIVER_HALT;\r\nwake_up(&psIntfAdapter->psAdapter->LEDInfo.notify_led_event);\r\n}\r\nreset_card_proc(psIntfAdapter->psAdapter);\r\nwhile (psIntfAdapter->psAdapter->DeviceAccess) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Device is being accessed.\n");\r\nmsleep(100);\r\n}\r\nusb_free_urb(psIntfAdapter->psInterruptUrb);\r\nfor (i = 0; i < MAXIMUM_USB_TCB; i++) {\r\nif (psIntfAdapter->asUsbTcb[i].urb != NULL) {\r\nusb_free_urb(psIntfAdapter->asUsbTcb[i].urb);\r\npsIntfAdapter->asUsbTcb[i].urb = NULL;\r\n}\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_RCB; i++) {\r\nif (psIntfAdapter->asUsbRcb[i].urb != NULL) {\r\nkfree(psIntfAdapter->asUsbRcb[i].urb->transfer_buffer);\r\nusb_free_urb(psIntfAdapter->asUsbRcb[i].urb);\r\npsIntfAdapter->asUsbRcb[i].urb = NULL;\r\n}\r\n}\r\nAdapterFree(psIntfAdapter->psAdapter);\r\n}\r\nstatic void ConfigureEndPointTypesThroughEEPROM(PMINI_ADAPTER Adapter)\r\n{\r\nunsigned long ulReg = 0;\r\nint bytes;\r\nulReg = ntohl(EP2_MPS_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x128, 4, TRUE);\r\nulReg = ntohl(EP2_MPS);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x12C, 4, TRUE);\r\nulReg = ntohl(EP2_CFG_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x132, 4, TRUE);\r\nif (((PS_INTERFACE_ADAPTER)(Adapter->pvInterfaceAdapter))->bHighSpeedDevice == TRUE) {\r\nulReg = ntohl(EP2_CFG_INT);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x136, 4, TRUE);\r\n} else {\r\nulReg = ntohl(EP2_CFG_BULK);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x136, 4, TRUE);\r\n}\r\nulReg = ntohl(EP4_MPS_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x13C, 4, TRUE);\r\nulReg = ntohl(EP4_MPS);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x140, 4, TRUE);\r\nbytes = rdmalt(Adapter, 0x0F0110F8, (u32 *)&ulReg, sizeof(u32));\r\nif (bytes < 0) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"reading of Tx EP failed\n");\r\nreturn;\r\n}\r\nulReg |= 0x6;\r\nulReg = ntohl(ulReg);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1CC, 4, TRUE);\r\nulReg = ntohl(EP4_CFG_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1C8, 4, TRUE);\r\nulReg = ntohl(ISO_MPS_REG);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1D2, 4, TRUE);\r\nulReg = ntohl(ISO_MPS);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1D6, 4, TRUE);\r\nReadBeceemEEPROM(Adapter, 0x1FC, (PUINT)&ulReg);\r\nulReg &= 0x0101FFFF;\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1FC, 4, TRUE);\r\nReadBeceemEEPROM(Adapter, 0xA8, (PUINT)&ulReg);\r\nif ((ulReg&0x00FF0000)>>16 > 0x30) {\r\nulReg = (ulReg&0xFF00FFFF)|(0x30<<16);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0xA8, 4, TRUE);\r\n}\r\nReadBeceemEEPROM(Adapter, 0x148, (PUINT)&ulReg);\r\nif ((ulReg&0x00FF0000)>>16 > 0x30) {\r\nulReg = (ulReg&0xFF00FFFF)|(0x30<<16);\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x148, 4, TRUE);\r\n}\r\nulReg = 0;\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x122, 4, TRUE);\r\nulReg = 0;\r\nBeceemEEPROMBulkWrite(Adapter, (PUCHAR)&ulReg, 0x1C2, 4, TRUE);\r\n}\r\nstatic int usbbcm_device_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint retval;\r\nPMINI_ADAPTER psAdapter;\r\nPS_INTERFACE_ADAPTER psIntfAdapter;\r\nstruct net_device *ndev;\r\nndev = alloc_etherdev_mq(sizeof(MINI_ADAPTER), NO_OF_QUEUES+1);\r\nif (ndev == NULL) {\r\ndev_err(&udev->dev, DRV_NAME ": no memory for device\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(ndev, &intf->dev);\r\npsAdapter = netdev_priv(ndev);\r\npsAdapter->dev = ndev;\r\npsAdapter->msg_enable = netif_msg_init(debug, default_msg);\r\npsAdapter->stDebugState.debug_level = DBG_LVL_CURR;\r\npsAdapter->stDebugState.type = DBG_TYPE_INITEXIT;\r\npsAdapter->stDebugState.subtype[DBG_TYPE_INITEXIT] = 0xff;\r\nBCM_SHOW_DEBUG_BITMAP(psAdapter);\r\nretval = InitAdapter(psAdapter);\r\nif (retval) {\r\ndev_err(&udev->dev, DRV_NAME ": InitAdapter Failed\n");\r\nAdapterFree(psAdapter);\r\nreturn retval;\r\n}\r\npsIntfAdapter = kzalloc(sizeof(S_INTERFACE_ADAPTER), GFP_KERNEL);\r\nif (psIntfAdapter == NULL) {\r\ndev_err(&udev->dev, DRV_NAME ": no memory for Interface adapter\n");\r\nAdapterFree(psAdapter);\r\nreturn -ENOMEM;\r\n}\r\npsAdapter->pvInterfaceAdapter = psIntfAdapter;\r\npsIntfAdapter->psAdapter = psAdapter;\r\npsIntfAdapter->interface = intf;\r\nusb_set_intfdata(intf, psIntfAdapter);\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"psIntfAdapter 0x%p\n", psIntfAdapter);\r\nretval = InterfaceAdapterInit(psIntfAdapter);\r\nif (retval) {\r\nif (-ENOENT == retval) {\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"File Not Found. Use app to download.\n");\r\nreturn STATUS_SUCCESS;\r\n}\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"InterfaceAdapterInit failed.\n");\r\nusb_set_intfdata(intf, NULL);\r\nudev = interface_to_usbdev(intf);\r\nusb_put_dev(udev);\r\nInterfaceAdapterFree(psIntfAdapter);\r\nreturn retval;\r\n}\r\nif (psAdapter->chip_id > T3) {\r\nuint32_t uiNackZeroLengthInt = 4;\r\nretval = wrmalt(psAdapter, DISABLE_USB_ZERO_LEN_INT, &uiNackZeroLengthInt, sizeof(uiNackZeroLengthInt));\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (USB_CONFIG_ATT_WAKEUP & udev->actconfig->desc.bmAttributes) {\r\nif (psAdapter->bDoSuspend) {\r\n#ifdef CONFIG_PM\r\npm_runtime_set_autosuspend_delay(&udev->dev, 0);\r\nintf->needs_remote_wakeup = 1;\r\nusb_enable_autosuspend(udev);\r\ndevice_init_wakeup(&intf->dev, 1);\r\nINIT_WORK(&psIntfAdapter->usbSuspendWork, putUsbSuspend);\r\nBCM_DEBUG_PRINT(psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Enabling USB Auto-Suspend\n");\r\n#endif\r\n} else {\r\nintf->needs_remote_wakeup = 0;\r\nusb_disable_autosuspend(udev);\r\n}\r\n}\r\npsAdapter->stDebugState.subtype[DBG_TYPE_INITEXIT] = 0x0;\r\nreturn retval;\r\n}\r\nstatic void usbbcm_disconnect(struct usb_interface *intf)\r\n{\r\nPS_INTERFACE_ADAPTER psIntfAdapter = usb_get_intfdata(intf);\r\nPMINI_ADAPTER psAdapter;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (psIntfAdapter == NULL)\r\nreturn;\r\npsAdapter = psIntfAdapter->psAdapter;\r\nnetif_device_detach(psAdapter->dev);\r\nif (psAdapter->bDoSuspend)\r\nintf->needs_remote_wakeup = 0;\r\npsAdapter->device_removed = TRUE ;\r\nusb_set_intfdata(intf, NULL);\r\nInterfaceAdapterFree(psIntfAdapter);\r\nusb_put_dev(udev);\r\n}\r\nstatic int AllocUsbCb(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < MAXIMUM_USB_TCB; i++) {\r\npsIntfAdapter->asUsbTcb[i].urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (psIntfAdapter->asUsbTcb[i].urb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Can't allocate Tx urb for index %d\n", i);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_RCB; i++) {\r\npsIntfAdapter->asUsbRcb[i].urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (psIntfAdapter->asUsbRcb[i].urb == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Can't allocate Rx urb for index %d\n", i);\r\nreturn -ENOMEM;\r\n}\r\npsIntfAdapter->asUsbRcb[i].urb->transfer_buffer = kmalloc(MAX_DATA_BUFFER_SIZE, GFP_KERNEL);\r\nif (psIntfAdapter->asUsbRcb[i].urb->transfer_buffer == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Can't allocate Rx buffer for index %d\n", i);\r\nreturn -ENOMEM;\r\n}\r\npsIntfAdapter->asUsbRcb[i].urb->transfer_buffer_length = MAX_DATA_BUFFER_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_run(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nint value = 0;\r\nUINT status = STATUS_SUCCESS;\r\nstatus = InitCardAndDownloadFirmware(psIntfAdapter->psAdapter);\r\nif (status != STATUS_SUCCESS) {\r\npr_err(DRV_NAME "InitCardAndDownloadFirmware failed.\n");\r\nreturn status;\r\n}\r\nif (TRUE == psIntfAdapter->psAdapter->fw_download_done) {\r\nif (StartInterruptUrb(psIntfAdapter)) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Cannot send interrupt in URB\n");\r\n}\r\npsIntfAdapter->psAdapter->waiting_to_fw_download_done = FALSE;\r\nvalue = wait_event_timeout(psIntfAdapter->psAdapter->ioctl_fw_dnld_wait_queue,\r\npsIntfAdapter->psAdapter->waiting_to_fw_download_done, 5*HZ);\r\nif (value == 0)\r\npr_err(DRV_NAME ": Timeout waiting for mailbox interrupt.\n");\r\nif (register_control_device_interface(psIntfAdapter->psAdapter) < 0) {\r\npr_err(DRV_NAME ": Register Control Device failed.\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int bcm_usb_endpoint_num(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\r\n}\r\nstatic inline int bcm_usb_endpoint_type(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\n}\r\nstatic inline int bcm_usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);\r\n}\r\nstatic inline int bcm_usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);\r\n}\r\nstatic inline int bcm_usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_BULK);\r\n}\r\nstatic inline int bcm_usb_endpoint_xfer_control(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_CONTROL);\r\n}\r\nstatic inline int bcm_usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_INT);\r\n}\r\nstatic inline int bcm_usb_endpoint_xfer_isoc(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\r\nUSB_ENDPOINT_XFER_ISOC);\r\n}\r\nstatic inline int bcm_usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn bcm_usb_endpoint_xfer_bulk(epd) && bcm_usb_endpoint_dir_in(epd);\r\n}\r\nstatic inline int bcm_usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn bcm_usb_endpoint_xfer_bulk(epd) && bcm_usb_endpoint_dir_out(epd);\r\n}\r\nstatic inline int bcm_usb_endpoint_is_int_in(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn bcm_usb_endpoint_xfer_int(epd) && bcm_usb_endpoint_dir_in(epd);\r\n}\r\nstatic inline int bcm_usb_endpoint_is_int_out(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn bcm_usb_endpoint_xfer_int(epd) && bcm_usb_endpoint_dir_out(epd);\r\n}\r\nstatic inline int bcm_usb_endpoint_is_isoc_in(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn bcm_usb_endpoint_xfer_isoc(epd) && bcm_usb_endpoint_dir_in(epd);\r\n}\r\nstatic inline int bcm_usb_endpoint_is_isoc_out(const struct usb_endpoint_descriptor *epd)\r\n{\r\nreturn bcm_usb_endpoint_xfer_isoc(epd) && bcm_usb_endpoint_dir_out(epd);\r\n}\r\nstatic int InterfaceAdapterInit(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nsize_t buffer_size;\r\nunsigned long value;\r\nint retval = 0;\r\nint usedIntOutForBulkTransfer = 0 ;\r\nBOOLEAN bBcm16 = FALSE;\r\nUINT uiData = 0;\r\nint bytes;\r\npsIntfAdapter->udev = usb_get_dev(interface_to_usbdev(psIntfAdapter->interface));\r\npsIntfAdapter->bHighSpeedDevice = (psIntfAdapter->udev->speed == USB_SPEED_HIGH);\r\npsIntfAdapter->psAdapter->interface_rdm = BcmRDM;\r\npsIntfAdapter->psAdapter->interface_wrm = BcmWRM;\r\nbytes = rdmalt(psIntfAdapter->psAdapter, CHIP_ID_REG,\r\n(u32 *)&(psIntfAdapter->psAdapter->chip_id), sizeof(u32));\r\nif (bytes < 0) {\r\nretval = bytes;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0, "CHIP ID Read Failed\n");\r\nreturn retval;\r\n}\r\nif (0xbece3200 == (psIntfAdapter->psAdapter->chip_id & ~(0xF0)))\r\npsIntfAdapter->psAdapter->chip_id &= ~0xF0;\r\ndev_info(&psIntfAdapter->udev->dev, "RDM Chip ID 0x%lx\n",\r\npsIntfAdapter->psAdapter->chip_id);\r\niface_desc = psIntfAdapter->interface->cur_altsetting;\r\nif (psIntfAdapter->psAdapter->chip_id == T3B) {\r\nBeceemEEPROMBulkRead(psIntfAdapter->psAdapter, &uiData, 0x0, 4);\r\nif (uiData == BECM)\r\nbBcm16 = TRUE;\r\ndev_info(&psIntfAdapter->udev->dev, "number of alternate setting %d\n",\r\npsIntfAdapter->interface->num_altsetting);\r\nif (bBcm16 == TRUE) {\r\nif (psIntfAdapter->bHighSpeedDevice)\r\nretval = usb_set_interface(psIntfAdapter->udev, DEFAULT_SETTING_0, ALTERNATE_SETTING_1);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"BCM16 is applicable on this dongle\n");\r\nif (retval || (psIntfAdapter->bHighSpeedDevice == FALSE)) {\r\nusedIntOutForBulkTransfer = EP2 ;\r\nendpoint = &iface_desc->endpoint[EP2].desc;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Interface altsetting failed or modem is configured to Full Speed, hence will work on default setting 0\n");\r\nif (((psIntfAdapter->bHighSpeedDevice == TRUE) && (bcm_usb_endpoint_is_int_out(endpoint) == FALSE))\r\n|| ((psIntfAdapter->bHighSpeedDevice == FALSE) && (bcm_usb_endpoint_is_bulk_out(endpoint) == FALSE))) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Configuring the EEPROM\n");\r\nConfigureEndPointTypesThroughEEPROM(psIntfAdapter->psAdapter);\r\nretval = usb_reset_device(psIntfAdapter->udev);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"reset failed. Re-enumerating the device.\n");\r\nreturn retval ;\r\n}\r\n}\r\nif ((psIntfAdapter->bHighSpeedDevice == FALSE) && bcm_usb_endpoint_is_bulk_out(endpoint)) {\r\nUINT _uiData = ntohl(EP2_CFG_INT);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Reverting Bulk to INT as it is in Full Speed mode.\n");\r\nBeceemEEPROMBulkWrite(psIntfAdapter->psAdapter, (PUCHAR)&_uiData, 0x136, 4, TRUE);\r\n}\r\n} else {\r\nusedIntOutForBulkTransfer = EP4 ;\r\nendpoint = &iface_desc->endpoint[EP4].desc;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Choosing AltSetting as a default setting.\n");\r\nif (bcm_usb_endpoint_is_int_out(endpoint) == FALSE) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Dongle does not have BCM16 Fix.\n");\r\nConfigureEndPointTypesThroughEEPROM(psIntfAdapter->psAdapter);\r\nretval = usb_reset_device(psIntfAdapter->udev);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"reset failed. Re-enumerating the device.\n");\r\nreturn retval;\r\n}\r\n}\r\n}\r\n}\r\n}\r\niface_desc = psIntfAdapter->interface->cur_altsetting;\r\nfor (value = 0; value < iface_desc->desc.bNumEndpoints; ++value) {\r\nendpoint = &iface_desc->endpoint[value].desc;\r\nif (!psIntfAdapter->sBulkIn.bulk_in_endpointAddr && bcm_usb_endpoint_is_bulk_in(endpoint)) {\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sBulkIn.bulk_in_size = buffer_size;\r\npsIntfAdapter->sBulkIn.bulk_in_endpointAddr = endpoint->bEndpointAddress;\r\npsIntfAdapter->sBulkIn.bulk_in_pipe =\r\nusb_rcvbulkpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkIn.bulk_in_endpointAddr);\r\n}\r\nif (!psIntfAdapter->sBulkOut.bulk_out_endpointAddr && bcm_usb_endpoint_is_bulk_out(endpoint)) {\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr = endpoint->bEndpointAddress;\r\npsIntfAdapter->sBulkOut.bulk_out_pipe =\r\nusb_sndbulkpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr);\r\n}\r\nif (!psIntfAdapter->sIntrIn.int_in_endpointAddr && bcm_usb_endpoint_is_int_in(endpoint)) {\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sIntrIn.int_in_size = buffer_size;\r\npsIntfAdapter->sIntrIn.int_in_endpointAddr = endpoint->bEndpointAddress;\r\npsIntfAdapter->sIntrIn.int_in_interval = endpoint->bInterval;\r\npsIntfAdapter->sIntrIn.int_in_buffer =\r\nkmalloc(buffer_size, GFP_KERNEL);\r\nif (!psIntfAdapter->sIntrIn.int_in_buffer) {\r\ndev_err(&psIntfAdapter->udev->dev,\r\n"could not allocate interrupt_in_buffer\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!psIntfAdapter->sIntrOut.int_out_endpointAddr && bcm_usb_endpoint_is_int_out(endpoint)) {\r\nif (!psIntfAdapter->sBulkOut.bulk_out_endpointAddr &&\r\n(psIntfAdapter->psAdapter->chip_id == T3B) && (value == usedIntOutForBulkTransfer)) {\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sBulkOut.bulk_out_size = buffer_size;\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr = endpoint->bEndpointAddress;\r\npsIntfAdapter->sBulkOut.bulk_out_pipe = usb_sndintpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sBulkOut.bulk_out_endpointAddr);\r\npsIntfAdapter->sBulkOut.int_out_interval = endpoint->bInterval;\r\n} else if (value == EP6) {\r\nbuffer_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\npsIntfAdapter->sIntrOut.int_out_size = buffer_size;\r\npsIntfAdapter->sIntrOut.int_out_endpointAddr = endpoint->bEndpointAddress;\r\npsIntfAdapter->sIntrOut.int_out_interval = endpoint->bInterval;\r\npsIntfAdapter->sIntrOut.int_out_buffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!psIntfAdapter->sIntrOut.int_out_buffer) {\r\ndev_err(&psIntfAdapter->udev->dev,\r\n"could not allocate interrupt_out_buffer\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\n}\r\nusb_set_intfdata(psIntfAdapter->interface, psIntfAdapter);\r\npsIntfAdapter->psAdapter->bcm_file_download = InterfaceFileDownload;\r\npsIntfAdapter->psAdapter->bcm_file_readback_from_chip =\r\nInterfaceFileReadbackFromChip;\r\npsIntfAdapter->psAdapter->interface_transmit = InterfaceTransmitPacket;\r\nretval = CreateInterruptUrb(psIntfAdapter);\r\nif (retval) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0,\r\n"Cannot create interrupt urb\n");\r\nreturn retval;\r\n}\r\nretval = AllocUsbCb(psIntfAdapter);\r\nif (retval)\r\nreturn retval;\r\nreturn device_run(psIntfAdapter);\r\n}\r\nstatic int InterfaceSuspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nPS_INTERFACE_ADAPTER psIntfAdapter = usb_get_intfdata(intf);\r\npsIntfAdapter->bSuspended = TRUE;\r\nif (TRUE == psIntfAdapter->bPreparingForBusSuspend) {\r\npsIntfAdapter->bPreparingForBusSuspend = FALSE;\r\nif (psIntfAdapter->psAdapter->LinkStatus == LINKUP_DONE) {\r\npsIntfAdapter->psAdapter->IdleMode = TRUE ;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Host Entered in PMU Idle Mode.\n");\r\n} else {\r\npsIntfAdapter->psAdapter->bShutStatus = TRUE;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_INITEXIT, DRV_ENTRY, DBG_LVL_ALL,\r\n"Host Entered in PMU Shutdown Mode.\n");\r\n}\r\n}\r\npsIntfAdapter->psAdapter->bPreparingForLowPowerMode = FALSE;\r\nwake_up(&psIntfAdapter->psAdapter->lowpower_mode_wait_queue);\r\nreturn 0;\r\n}\r\nstatic int InterfaceResume(struct usb_interface *intf)\r\n{\r\nPS_INTERFACE_ADAPTER psIntfAdapter = usb_get_intfdata(intf);\r\nmdelay(100);\r\npsIntfAdapter->bSuspended = FALSE;\r\nStartInterruptUrb(psIntfAdapter);\r\nInterfaceRx(psIntfAdapter);\r\nreturn 0;\r\n}\r\nstatic __init int bcm_init(void)\r\n{\r\nprintk(KERN_INFO "%s: %s, %s\n", DRV_NAME, DRV_DESCRIPTION, DRV_VERSION);\r\nprintk(KERN_INFO "%s\n", DRV_COPYRIGHT);\r\nbcm_class = class_create(THIS_MODULE, DRV_NAME);\r\nif (IS_ERR(bcm_class)) {\r\nprintk(KERN_ERR DRV_NAME ": could not create class\n");\r\nreturn PTR_ERR(bcm_class);\r\n}\r\nreturn usb_register(&usbbcm_driver);\r\n}\r\nstatic __exit void bcm_exit(void)\r\n{\r\nusb_deregister(&usbbcm_driver);\r\nclass_destroy(bcm_class);\r\n}
