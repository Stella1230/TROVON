static void xs_pktdump(char *msg, u32 *packet, unsigned int count)\r\n{\r\nu8 *buf = (u8 *) packet;\r\nint j;\r\ndprintk("RPC: %s\n", msg);\r\nfor (j = 0; j < count && j < 128; j += 4) {\r\nif (!(j & 31)) {\r\nif (j)\r\ndprintk("\n");\r\ndprintk("0x%04x ", j);\r\n}\r\ndprintk("%02x%02x%02x%02x ",\r\nbuf[j], buf[j+1], buf[j+2], buf[j+3]);\r\n}\r\ndprintk("\n");\r\n}\r\nstatic inline void xs_pktdump(char *msg, u32 *packet, unsigned int count)\r\n{\r\n}\r\nstatic inline struct sockaddr *xs_addr(struct rpc_xprt *xprt)\r\n{\r\nreturn (struct sockaddr *) &xprt->addr;\r\n}\r\nstatic inline struct sockaddr_un *xs_addr_un(struct rpc_xprt *xprt)\r\n{\r\nreturn (struct sockaddr_un *) &xprt->addr;\r\n}\r\nstatic inline struct sockaddr_in *xs_addr_in(struct rpc_xprt *xprt)\r\n{\r\nreturn (struct sockaddr_in *) &xprt->addr;\r\n}\r\nstatic inline struct sockaddr_in6 *xs_addr_in6(struct rpc_xprt *xprt)\r\n{\r\nreturn (struct sockaddr_in6 *) &xprt->addr;\r\n}\r\nstatic void xs_format_common_peer_addresses(struct rpc_xprt *xprt)\r\n{\r\nstruct sockaddr *sap = xs_addr(xprt);\r\nstruct sockaddr_in6 *sin6;\r\nstruct sockaddr_in *sin;\r\nstruct sockaddr_un *sun;\r\nchar buf[128];\r\nswitch (sap->sa_family) {\r\ncase AF_LOCAL:\r\nsun = xs_addr_un(xprt);\r\nstrlcpy(buf, sun->sun_path, sizeof(buf));\r\nxprt->address_strings[RPC_DISPLAY_ADDR] =\r\nkstrdup(buf, GFP_KERNEL);\r\nbreak;\r\ncase AF_INET:\r\n(void)rpc_ntop(sap, buf, sizeof(buf));\r\nxprt->address_strings[RPC_DISPLAY_ADDR] =\r\nkstrdup(buf, GFP_KERNEL);\r\nsin = xs_addr_in(xprt);\r\nsnprintf(buf, sizeof(buf), "%08x", ntohl(sin->sin_addr.s_addr));\r\nbreak;\r\ncase AF_INET6:\r\n(void)rpc_ntop(sap, buf, sizeof(buf));\r\nxprt->address_strings[RPC_DISPLAY_ADDR] =\r\nkstrdup(buf, GFP_KERNEL);\r\nsin6 = xs_addr_in6(xprt);\r\nsnprintf(buf, sizeof(buf), "%pi6", &sin6->sin6_addr);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nxprt->address_strings[RPC_DISPLAY_HEX_ADDR] = kstrdup(buf, GFP_KERNEL);\r\n}\r\nstatic void xs_format_common_peer_ports(struct rpc_xprt *xprt)\r\n{\r\nstruct sockaddr *sap = xs_addr(xprt);\r\nchar buf[128];\r\nsnprintf(buf, sizeof(buf), "%u", rpc_get_port(sap));\r\nxprt->address_strings[RPC_DISPLAY_PORT] = kstrdup(buf, GFP_KERNEL);\r\nsnprintf(buf, sizeof(buf), "%4hx", rpc_get_port(sap));\r\nxprt->address_strings[RPC_DISPLAY_HEX_PORT] = kstrdup(buf, GFP_KERNEL);\r\n}\r\nstatic void xs_format_peer_addresses(struct rpc_xprt *xprt,\r\nconst char *protocol,\r\nconst char *netid)\r\n{\r\nxprt->address_strings[RPC_DISPLAY_PROTO] = protocol;\r\nxprt->address_strings[RPC_DISPLAY_NETID] = netid;\r\nxs_format_common_peer_addresses(xprt);\r\nxs_format_common_peer_ports(xprt);\r\n}\r\nstatic void xs_update_peer_port(struct rpc_xprt *xprt)\r\n{\r\nkfree(xprt->address_strings[RPC_DISPLAY_HEX_PORT]);\r\nkfree(xprt->address_strings[RPC_DISPLAY_PORT]);\r\nxs_format_common_peer_ports(xprt);\r\n}\r\nstatic void xs_free_peer_addresses(struct rpc_xprt *xprt)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < RPC_DISPLAY_MAX; i++)\r\nswitch (i) {\r\ncase RPC_DISPLAY_PROTO:\r\ncase RPC_DISPLAY_NETID:\r\ncontinue;\r\ndefault:\r\nkfree(xprt->address_strings[i]);\r\n}\r\n}\r\nstatic int xs_send_kvec(struct socket *sock, struct sockaddr *addr, int addrlen, struct kvec *vec, unsigned int base, int more)\r\n{\r\nstruct msghdr msg = {\r\n.msg_name = addr,\r\n.msg_namelen = addrlen,\r\n.msg_flags = XS_SENDMSG_FLAGS | (more ? MSG_MORE : 0),\r\n};\r\nstruct kvec iov = {\r\n.iov_base = vec->iov_base + base,\r\n.iov_len = vec->iov_len - base,\r\n};\r\nif (iov.iov_len != 0)\r\nreturn kernel_sendmsg(sock, &msg, &iov, 1, iov.iov_len);\r\nreturn kernel_sendmsg(sock, &msg, NULL, 0, 0);\r\n}\r\nstatic int xs_send_pagedata(struct socket *sock, struct xdr_buf *xdr, unsigned int base, int more)\r\n{\r\nstruct page **ppage;\r\nunsigned int remainder;\r\nint err, sent = 0;\r\nremainder = xdr->page_len - base;\r\nbase += xdr->page_base;\r\nppage = xdr->pages + (base >> PAGE_SHIFT);\r\nbase &= ~PAGE_MASK;\r\nfor(;;) {\r\nunsigned int len = min_t(unsigned int, PAGE_SIZE - base, remainder);\r\nint flags = XS_SENDMSG_FLAGS;\r\nremainder -= len;\r\nif (remainder != 0 || more)\r\nflags |= MSG_MORE;\r\nerr = sock->ops->sendpage(sock, *ppage, base, len, flags);\r\nif (remainder == 0 || err != len)\r\nbreak;\r\nsent += err;\r\nppage++;\r\nbase = 0;\r\n}\r\nif (sent == 0)\r\nreturn err;\r\nif (err > 0)\r\nsent += err;\r\nreturn sent;\r\n}\r\nstatic int xs_sendpages(struct socket *sock, struct sockaddr *addr, int addrlen, struct xdr_buf *xdr, unsigned int base)\r\n{\r\nunsigned int remainder = xdr->len - base;\r\nint err, sent = 0;\r\nif (unlikely(!sock))\r\nreturn -ENOTSOCK;\r\nclear_bit(SOCK_ASYNC_NOSPACE, &sock->flags);\r\nif (base != 0) {\r\naddr = NULL;\r\naddrlen = 0;\r\n}\r\nif (base < xdr->head[0].iov_len || addr != NULL) {\r\nunsigned int len = xdr->head[0].iov_len - base;\r\nremainder -= len;\r\nerr = xs_send_kvec(sock, addr, addrlen, &xdr->head[0], base, remainder != 0);\r\nif (remainder == 0 || err != len)\r\ngoto out;\r\nsent += err;\r\nbase = 0;\r\n} else\r\nbase -= xdr->head[0].iov_len;\r\nif (base < xdr->page_len) {\r\nunsigned int len = xdr->page_len - base;\r\nremainder -= len;\r\nerr = xs_send_pagedata(sock, xdr, base, remainder != 0);\r\nif (remainder == 0 || err != len)\r\ngoto out;\r\nsent += err;\r\nbase = 0;\r\n} else\r\nbase -= xdr->page_len;\r\nif (base >= xdr->tail[0].iov_len)\r\nreturn sent;\r\nerr = xs_send_kvec(sock, NULL, 0, &xdr->tail[0], base, 0);\r\nout:\r\nif (sent == 0)\r\nreturn err;\r\nif (err > 0)\r\nsent += err;\r\nreturn sent;\r\n}\r\nstatic void xs_nospace_callback(struct rpc_task *task)\r\n{\r\nstruct sock_xprt *transport = container_of(task->tk_rqstp->rq_xprt, struct sock_xprt, xprt);\r\ntransport->inet->sk_write_pending--;\r\nclear_bit(SOCK_ASYNC_NOSPACE, &transport->sock->flags);\r\n}\r\nstatic int xs_nospace(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nint ret = -EAGAIN;\r\ndprintk("RPC: %5u xmit incomplete (%u left of %u)\n",\r\ntask->tk_pid, req->rq_slen - req->rq_bytes_sent,\r\nreq->rq_slen);\r\nspin_lock_bh(&xprt->transport_lock);\r\nif (xprt_connected(xprt)) {\r\nif (test_bit(SOCK_ASYNC_NOSPACE, &transport->sock->flags)) {\r\nset_bit(SOCK_NOSPACE, &transport->sock->flags);\r\ntransport->inet->sk_write_pending++;\r\nxprt_wait_for_buffer_space(task, xs_nospace_callback);\r\n}\r\n} else {\r\nclear_bit(SOCK_ASYNC_NOSPACE, &transport->sock->flags);\r\nret = -ENOTCONN;\r\n}\r\nspin_unlock_bh(&xprt->transport_lock);\r\nreturn ret;\r\n}\r\nstatic inline void xs_encode_stream_record_marker(struct xdr_buf *buf)\r\n{\r\nu32 reclen = buf->len - sizeof(rpc_fraghdr);\r\nrpc_fraghdr *base = buf->head[0].iov_base;\r\n*base = cpu_to_be32(RPC_LAST_STREAM_FRAGMENT | reclen);\r\n}\r\nstatic int xs_local_send_request(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nstruct xdr_buf *xdr = &req->rq_snd_buf;\r\nint status;\r\nxs_encode_stream_record_marker(&req->rq_snd_buf);\r\nxs_pktdump("packet data:",\r\nreq->rq_svec->iov_base, req->rq_svec->iov_len);\r\nstatus = xs_sendpages(transport->sock, NULL, 0,\r\nxdr, req->rq_bytes_sent);\r\ndprintk("RPC: %s(%u) = %d\n",\r\n__func__, xdr->len - req->rq_bytes_sent, status);\r\nif (likely(status >= 0)) {\r\nreq->rq_bytes_sent += status;\r\nreq->rq_xmit_bytes_sent += status;\r\nif (likely(req->rq_bytes_sent >= req->rq_slen)) {\r\nreq->rq_bytes_sent = 0;\r\nreturn 0;\r\n}\r\nstatus = -EAGAIN;\r\n}\r\nswitch (status) {\r\ncase -EAGAIN:\r\nstatus = xs_nospace(task);\r\nbreak;\r\ndefault:\r\ndprintk("RPC: sendmsg returned unrecognized error %d\n",\r\n-status);\r\ncase -EPIPE:\r\nxs_close(xprt);\r\nstatus = -ENOTCONN;\r\n}\r\nreturn status;\r\n}\r\nstatic int xs_udp_send_request(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nstruct xdr_buf *xdr = &req->rq_snd_buf;\r\nint status;\r\nxs_pktdump("packet data:",\r\nreq->rq_svec->iov_base,\r\nreq->rq_svec->iov_len);\r\nif (!xprt_bound(xprt))\r\nreturn -ENOTCONN;\r\nstatus = xs_sendpages(transport->sock,\r\nxs_addr(xprt),\r\nxprt->addrlen, xdr,\r\nreq->rq_bytes_sent);\r\ndprintk("RPC: xs_udp_send_request(%u) = %d\n",\r\nxdr->len - req->rq_bytes_sent, status);\r\nif (status >= 0) {\r\nreq->rq_xmit_bytes_sent += status;\r\nif (status >= req->rq_slen)\r\nreturn 0;\r\nstatus = -EAGAIN;\r\n}\r\nswitch (status) {\r\ncase -ENOTSOCK:\r\nstatus = -ENOTCONN;\r\nbreak;\r\ncase -EAGAIN:\r\nstatus = xs_nospace(task);\r\nbreak;\r\ndefault:\r\ndprintk("RPC: sendmsg returned unrecognized error %d\n",\r\n-status);\r\ncase -ENETUNREACH:\r\ncase -EPIPE:\r\ncase -ECONNREFUSED:\r\nclear_bit(SOCK_ASYNC_NOSPACE, &transport->sock->flags);\r\n}\r\nreturn status;\r\n}\r\nstatic void xs_tcp_shutdown(struct rpc_xprt *xprt)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nstruct socket *sock = transport->sock;\r\nif (sock != NULL)\r\nkernel_sock_shutdown(sock, SHUT_WR);\r\n}\r\nstatic int xs_tcp_send_request(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nstruct xdr_buf *xdr = &req->rq_snd_buf;\r\nint status;\r\nxs_encode_stream_record_marker(&req->rq_snd_buf);\r\nxs_pktdump("packet data:",\r\nreq->rq_svec->iov_base,\r\nreq->rq_svec->iov_len);\r\nwhile (1) {\r\nstatus = xs_sendpages(transport->sock,\r\nNULL, 0, xdr, req->rq_bytes_sent);\r\ndprintk("RPC: xs_tcp_send_request(%u) = %d\n",\r\nxdr->len - req->rq_bytes_sent, status);\r\nif (unlikely(status < 0))\r\nbreak;\r\nreq->rq_bytes_sent += status;\r\nreq->rq_xmit_bytes_sent += status;\r\nif (likely(req->rq_bytes_sent >= req->rq_slen)) {\r\nreq->rq_bytes_sent = 0;\r\nreturn 0;\r\n}\r\nif (status != 0)\r\ncontinue;\r\nstatus = -EAGAIN;\r\nbreak;\r\n}\r\nswitch (status) {\r\ncase -ENOTSOCK:\r\nstatus = -ENOTCONN;\r\nbreak;\r\ncase -EAGAIN:\r\nstatus = xs_nospace(task);\r\nbreak;\r\ndefault:\r\ndprintk("RPC: sendmsg returned unrecognized error %d\n",\r\n-status);\r\ncase -ECONNRESET:\r\ncase -EPIPE:\r\nxs_tcp_shutdown(xprt);\r\ncase -ECONNREFUSED:\r\ncase -ENOTCONN:\r\nclear_bit(SOCK_ASYNC_NOSPACE, &transport->sock->flags);\r\n}\r\nreturn status;\r\n}\r\nstatic void xs_tcp_release_xprt(struct rpc_xprt *xprt, struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req;\r\nif (task != xprt->snd_task)\r\nreturn;\r\nif (task == NULL)\r\ngoto out_release;\r\nreq = task->tk_rqstp;\r\nif (req == NULL)\r\ngoto out_release;\r\nif (req->rq_bytes_sent == 0)\r\ngoto out_release;\r\nif (req->rq_bytes_sent == req->rq_snd_buf.len)\r\ngoto out_release;\r\nset_bit(XPRT_CLOSE_WAIT, &task->tk_xprt->state);\r\nout_release:\r\nxprt_release_xprt(xprt, task);\r\n}\r\nstatic void xs_save_old_callbacks(struct sock_xprt *transport, struct sock *sk)\r\n{\r\ntransport->old_data_ready = sk->sk_data_ready;\r\ntransport->old_state_change = sk->sk_state_change;\r\ntransport->old_write_space = sk->sk_write_space;\r\ntransport->old_error_report = sk->sk_error_report;\r\n}\r\nstatic void xs_restore_old_callbacks(struct sock_xprt *transport, struct sock *sk)\r\n{\r\nsk->sk_data_ready = transport->old_data_ready;\r\nsk->sk_state_change = transport->old_state_change;\r\nsk->sk_write_space = transport->old_write_space;\r\nsk->sk_error_report = transport->old_error_report;\r\n}\r\nstatic void xs_reset_transport(struct sock_xprt *transport)\r\n{\r\nstruct socket *sock = transport->sock;\r\nstruct sock *sk = transport->inet;\r\nif (sk == NULL)\r\nreturn;\r\ntransport->srcport = 0;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\ntransport->inet = NULL;\r\ntransport->sock = NULL;\r\nsk->sk_user_data = NULL;\r\nxs_restore_old_callbacks(transport, sk);\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nsk->sk_no_check = 0;\r\nsock_release(sock);\r\n}\r\nstatic void xs_close(struct rpc_xprt *xprt)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\ndprintk("RPC: xs_close xprt %p\n", xprt);\r\nxs_reset_transport(transport);\r\nxprt->reestablish_timeout = 0;\r\nsmp_mb__before_clear_bit();\r\nclear_bit(XPRT_CONNECTION_ABORT, &xprt->state);\r\nclear_bit(XPRT_CLOSE_WAIT, &xprt->state);\r\nclear_bit(XPRT_CLOSING, &xprt->state);\r\nsmp_mb__after_clear_bit();\r\nxprt_disconnect_done(xprt);\r\n}\r\nstatic void xs_tcp_close(struct rpc_xprt *xprt)\r\n{\r\nif (test_and_clear_bit(XPRT_CONNECTION_CLOSE, &xprt->state))\r\nxs_close(xprt);\r\nelse\r\nxs_tcp_shutdown(xprt);\r\n}\r\nstatic void xs_destroy(struct rpc_xprt *xprt)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\ndprintk("RPC: xs_destroy xprt %p\n", xprt);\r\ncancel_delayed_work_sync(&transport->connect_worker);\r\nxs_close(xprt);\r\nxs_free_peer_addresses(xprt);\r\nxprt_free(xprt);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic inline struct rpc_xprt *xprt_from_sock(struct sock *sk)\r\n{\r\nreturn (struct rpc_xprt *) sk->sk_user_data;\r\n}\r\nstatic int xs_local_copy_to_xdr(struct xdr_buf *xdr, struct sk_buff *skb)\r\n{\r\nstruct xdr_skb_reader desc = {\r\n.skb = skb,\r\n.offset = sizeof(rpc_fraghdr),\r\n.count = skb->len - sizeof(rpc_fraghdr),\r\n};\r\nif (xdr_partial_copy_from_skb(xdr, 0, &desc, xdr_skb_read_bits) < 0)\r\nreturn -1;\r\nif (desc.count)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void xs_local_data_ready(struct sock *sk, int len)\r\n{\r\nstruct rpc_task *task;\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_rqst *rovr;\r\nstruct sk_buff *skb;\r\nint err, repsize, copied;\r\nu32 _xid;\r\n__be32 *xp;\r\nread_lock_bh(&sk->sk_callback_lock);\r\ndprintk("RPC: %s...\n", __func__);\r\nxprt = xprt_from_sock(sk);\r\nif (xprt == NULL)\r\ngoto out;\r\nskb = skb_recv_datagram(sk, 0, 1, &err);\r\nif (skb == NULL)\r\ngoto out;\r\nif (xprt->shutdown)\r\ngoto dropit;\r\nrepsize = skb->len - sizeof(rpc_fraghdr);\r\nif (repsize < 4) {\r\ndprintk("RPC: impossible RPC reply size %d\n", repsize);\r\ngoto dropit;\r\n}\r\nxp = skb_header_pointer(skb, sizeof(rpc_fraghdr), sizeof(_xid), &_xid);\r\nif (xp == NULL)\r\ngoto dropit;\r\nspin_lock(&xprt->transport_lock);\r\nrovr = xprt_lookup_rqst(xprt, *xp);\r\nif (!rovr)\r\ngoto out_unlock;\r\ntask = rovr->rq_task;\r\ncopied = rovr->rq_private_buf.buflen;\r\nif (copied > repsize)\r\ncopied = repsize;\r\nif (xs_local_copy_to_xdr(&rovr->rq_private_buf, skb)) {\r\ndprintk("RPC: sk_buff copy failed\n");\r\ngoto out_unlock;\r\n}\r\nxprt_complete_rqst(task, copied);\r\nout_unlock:\r\nspin_unlock(&xprt->transport_lock);\r\ndropit:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void xs_udp_data_ready(struct sock *sk, int len)\r\n{\r\nstruct rpc_task *task;\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_rqst *rovr;\r\nstruct sk_buff *skb;\r\nint err, repsize, copied;\r\nu32 _xid;\r\n__be32 *xp;\r\nread_lock_bh(&sk->sk_callback_lock);\r\ndprintk("RPC: xs_udp_data_ready...\n");\r\nif (!(xprt = xprt_from_sock(sk)))\r\ngoto out;\r\nif ((skb = skb_recv_datagram(sk, 0, 1, &err)) == NULL)\r\ngoto out;\r\nif (xprt->shutdown)\r\ngoto dropit;\r\nrepsize = skb->len - sizeof(struct udphdr);\r\nif (repsize < 4) {\r\ndprintk("RPC: impossible RPC reply size %d!\n", repsize);\r\ngoto dropit;\r\n}\r\nxp = skb_header_pointer(skb, sizeof(struct udphdr),\r\nsizeof(_xid), &_xid);\r\nif (xp == NULL)\r\ngoto dropit;\r\nspin_lock(&xprt->transport_lock);\r\nrovr = xprt_lookup_rqst(xprt, *xp);\r\nif (!rovr)\r\ngoto out_unlock;\r\ntask = rovr->rq_task;\r\nif ((copied = rovr->rq_private_buf.buflen) > repsize)\r\ncopied = repsize;\r\nif (csum_partial_copy_to_xdr(&rovr->rq_private_buf, skb)) {\r\nUDPX_INC_STATS_BH(sk, UDP_MIB_INERRORS);\r\ngoto out_unlock;\r\n}\r\nUDPX_INC_STATS_BH(sk, UDP_MIB_INDATAGRAMS);\r\ndst_confirm(skb_dst(skb));\r\nxprt_adjust_cwnd(task, copied);\r\nxprt_complete_rqst(task, copied);\r\nout_unlock:\r\nspin_unlock(&xprt->transport_lock);\r\ndropit:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic inline void xs_tcp_read_fraghdr(struct rpc_xprt *xprt, struct xdr_skb_reader *desc)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nsize_t len, used;\r\nchar *p;\r\np = ((char *) &transport->tcp_fraghdr) + transport->tcp_offset;\r\nlen = sizeof(transport->tcp_fraghdr) - transport->tcp_offset;\r\nused = xdr_skb_read_bits(desc, p, len);\r\ntransport->tcp_offset += used;\r\nif (used != len)\r\nreturn;\r\ntransport->tcp_reclen = ntohl(transport->tcp_fraghdr);\r\nif (transport->tcp_reclen & RPC_LAST_STREAM_FRAGMENT)\r\ntransport->tcp_flags |= TCP_RCV_LAST_FRAG;\r\nelse\r\ntransport->tcp_flags &= ~TCP_RCV_LAST_FRAG;\r\ntransport->tcp_reclen &= RPC_FRAGMENT_SIZE_MASK;\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_FRAGHDR;\r\ntransport->tcp_offset = 0;\r\nif (unlikely(transport->tcp_reclen < 8)) {\r\ndprintk("RPC: invalid TCP record fragment length\n");\r\nxprt_force_disconnect(xprt);\r\nreturn;\r\n}\r\ndprintk("RPC: reading TCP record fragment of length %d\n",\r\ntransport->tcp_reclen);\r\n}\r\nstatic void xs_tcp_check_fraghdr(struct sock_xprt *transport)\r\n{\r\nif (transport->tcp_offset == transport->tcp_reclen) {\r\ntransport->tcp_flags |= TCP_RCV_COPY_FRAGHDR;\r\ntransport->tcp_offset = 0;\r\nif (transport->tcp_flags & TCP_RCV_LAST_FRAG) {\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_DATA;\r\ntransport->tcp_flags |= TCP_RCV_COPY_XID;\r\ntransport->tcp_copied = 0;\r\n}\r\n}\r\n}\r\nstatic inline void xs_tcp_read_xid(struct sock_xprt *transport, struct xdr_skb_reader *desc)\r\n{\r\nsize_t len, used;\r\nchar *p;\r\nlen = sizeof(transport->tcp_xid) - transport->tcp_offset;\r\ndprintk("RPC: reading XID (%Zu bytes)\n", len);\r\np = ((char *) &transport->tcp_xid) + transport->tcp_offset;\r\nused = xdr_skb_read_bits(desc, p, len);\r\ntransport->tcp_offset += used;\r\nif (used != len)\r\nreturn;\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_XID;\r\ntransport->tcp_flags |= TCP_RCV_READ_CALLDIR;\r\ntransport->tcp_copied = 4;\r\ndprintk("RPC: reading %s XID %08x\n",\r\n(transport->tcp_flags & TCP_RPC_REPLY) ? "reply for"\r\n: "request with",\r\nntohl(transport->tcp_xid));\r\nxs_tcp_check_fraghdr(transport);\r\n}\r\nstatic inline void xs_tcp_read_calldir(struct sock_xprt *transport,\r\nstruct xdr_skb_reader *desc)\r\n{\r\nsize_t len, used;\r\nu32 offset;\r\nchar *p;\r\noffset = transport->tcp_offset - sizeof(transport->tcp_xid);\r\nlen = sizeof(transport->tcp_calldir) - offset;\r\ndprintk("RPC: reading CALL/REPLY flag (%Zu bytes)\n", len);\r\np = ((char *) &transport->tcp_calldir) + offset;\r\nused = xdr_skb_read_bits(desc, p, len);\r\ntransport->tcp_offset += used;\r\nif (used != len)\r\nreturn;\r\ntransport->tcp_flags &= ~TCP_RCV_READ_CALLDIR;\r\nswitch (ntohl(transport->tcp_calldir)) {\r\ncase RPC_REPLY:\r\ntransport->tcp_flags |= TCP_RCV_COPY_CALLDIR;\r\ntransport->tcp_flags |= TCP_RCV_COPY_DATA;\r\ntransport->tcp_flags |= TCP_RPC_REPLY;\r\nbreak;\r\ncase RPC_CALL:\r\ntransport->tcp_flags |= TCP_RCV_COPY_CALLDIR;\r\ntransport->tcp_flags |= TCP_RCV_COPY_DATA;\r\ntransport->tcp_flags &= ~TCP_RPC_REPLY;\r\nbreak;\r\ndefault:\r\ndprintk("RPC: invalid request message type\n");\r\nxprt_force_disconnect(&transport->xprt);\r\n}\r\nxs_tcp_check_fraghdr(transport);\r\n}\r\nstatic inline void xs_tcp_read_common(struct rpc_xprt *xprt,\r\nstruct xdr_skb_reader *desc,\r\nstruct rpc_rqst *req)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nstruct xdr_buf *rcvbuf;\r\nsize_t len;\r\nssize_t r;\r\nrcvbuf = &req->rq_private_buf;\r\nif (transport->tcp_flags & TCP_RCV_COPY_CALLDIR) {\r\nmemcpy(rcvbuf->head[0].iov_base + transport->tcp_copied,\r\n&transport->tcp_calldir,\r\nsizeof(transport->tcp_calldir));\r\ntransport->tcp_copied += sizeof(transport->tcp_calldir);\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_CALLDIR;\r\n}\r\nlen = desc->count;\r\nif (len > transport->tcp_reclen - transport->tcp_offset) {\r\nstruct xdr_skb_reader my_desc;\r\nlen = transport->tcp_reclen - transport->tcp_offset;\r\nmemcpy(&my_desc, desc, sizeof(my_desc));\r\nmy_desc.count = len;\r\nr = xdr_partial_copy_from_skb(rcvbuf, transport->tcp_copied,\r\n&my_desc, xdr_skb_read_bits);\r\ndesc->count -= r;\r\ndesc->offset += r;\r\n} else\r\nr = xdr_partial_copy_from_skb(rcvbuf, transport->tcp_copied,\r\ndesc, xdr_skb_read_bits);\r\nif (r > 0) {\r\ntransport->tcp_copied += r;\r\ntransport->tcp_offset += r;\r\n}\r\nif (r != len) {\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_DATA;\r\ndprintk("RPC: XID %08x truncated request\n",\r\nntohl(transport->tcp_xid));\r\ndprintk("RPC: xprt = %p, tcp_copied = %lu, "\r\n"tcp_offset = %u, tcp_reclen = %u\n",\r\nxprt, transport->tcp_copied,\r\ntransport->tcp_offset, transport->tcp_reclen);\r\nreturn;\r\n}\r\ndprintk("RPC: XID %08x read %Zd bytes\n",\r\nntohl(transport->tcp_xid), r);\r\ndprintk("RPC: xprt = %p, tcp_copied = %lu, tcp_offset = %u, "\r\n"tcp_reclen = %u\n", xprt, transport->tcp_copied,\r\ntransport->tcp_offset, transport->tcp_reclen);\r\nif (transport->tcp_copied == req->rq_private_buf.buflen)\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_DATA;\r\nelse if (transport->tcp_offset == transport->tcp_reclen) {\r\nif (transport->tcp_flags & TCP_RCV_LAST_FRAG)\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_DATA;\r\n}\r\n}\r\nstatic inline int xs_tcp_read_reply(struct rpc_xprt *xprt,\r\nstruct xdr_skb_reader *desc)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nstruct rpc_rqst *req;\r\ndprintk("RPC: read reply XID %08x\n", ntohl(transport->tcp_xid));\r\nspin_lock(&xprt->transport_lock);\r\nreq = xprt_lookup_rqst(xprt, transport->tcp_xid);\r\nif (!req) {\r\ndprintk("RPC: XID %08x request not found!\n",\r\nntohl(transport->tcp_xid));\r\nspin_unlock(&xprt->transport_lock);\r\nreturn -1;\r\n}\r\nxs_tcp_read_common(xprt, desc, req);\r\nif (!(transport->tcp_flags & TCP_RCV_COPY_DATA))\r\nxprt_complete_rqst(req->rq_task, transport->tcp_copied);\r\nspin_unlock(&xprt->transport_lock);\r\nreturn 0;\r\n}\r\nstatic inline int xs_tcp_read_callback(struct rpc_xprt *xprt,\r\nstruct xdr_skb_reader *desc)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nstruct rpc_rqst *req;\r\nreq = xprt_alloc_bc_request(xprt);\r\nif (req == NULL) {\r\nprintk(KERN_WARNING "Callback slot table overflowed\n");\r\nxprt_force_disconnect(xprt);\r\nreturn -1;\r\n}\r\nreq->rq_xid = transport->tcp_xid;\r\ndprintk("RPC: read callback XID %08x\n", ntohl(req->rq_xid));\r\nxs_tcp_read_common(xprt, desc, req);\r\nif (!(transport->tcp_flags & TCP_RCV_COPY_DATA)) {\r\nstruct svc_serv *bc_serv = xprt->bc_serv;\r\ndprintk("RPC: add callback request to list\n");\r\nspin_lock(&bc_serv->sv_cb_lock);\r\nlist_add(&req->rq_bc_list, &bc_serv->sv_cb_list);\r\nspin_unlock(&bc_serv->sv_cb_lock);\r\nwake_up(&bc_serv->sv_cb_waitq);\r\n}\r\nreq->rq_private_buf.len = transport->tcp_copied;\r\nreturn 0;\r\n}\r\nstatic inline int _xs_tcp_read_data(struct rpc_xprt *xprt,\r\nstruct xdr_skb_reader *desc)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nreturn (transport->tcp_flags & TCP_RPC_REPLY) ?\r\nxs_tcp_read_reply(xprt, desc) :\r\nxs_tcp_read_callback(xprt, desc);\r\n}\r\nstatic inline int _xs_tcp_read_data(struct rpc_xprt *xprt,\r\nstruct xdr_skb_reader *desc)\r\n{\r\nreturn xs_tcp_read_reply(xprt, desc);\r\n}\r\nstatic void xs_tcp_read_data(struct rpc_xprt *xprt,\r\nstruct xdr_skb_reader *desc)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nif (_xs_tcp_read_data(xprt, desc) == 0)\r\nxs_tcp_check_fraghdr(transport);\r\nelse {\r\ntransport->tcp_flags &= ~TCP_RCV_COPY_DATA;\r\n}\r\n}\r\nstatic inline void xs_tcp_read_discard(struct sock_xprt *transport, struct xdr_skb_reader *desc)\r\n{\r\nsize_t len;\r\nlen = transport->tcp_reclen - transport->tcp_offset;\r\nif (len > desc->count)\r\nlen = desc->count;\r\ndesc->count -= len;\r\ndesc->offset += len;\r\ntransport->tcp_offset += len;\r\ndprintk("RPC: discarded %Zu bytes\n", len);\r\nxs_tcp_check_fraghdr(transport);\r\n}\r\nstatic int xs_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb, unsigned int offset, size_t len)\r\n{\r\nstruct rpc_xprt *xprt = rd_desc->arg.data;\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nstruct xdr_skb_reader desc = {\r\n.skb = skb,\r\n.offset = offset,\r\n.count = len,\r\n};\r\ndprintk("RPC: xs_tcp_data_recv started\n");\r\ndo {\r\nif (transport->tcp_flags & TCP_RCV_COPY_FRAGHDR) {\r\nxs_tcp_read_fraghdr(xprt, &desc);\r\ncontinue;\r\n}\r\nif (transport->tcp_flags & TCP_RCV_COPY_XID) {\r\nxs_tcp_read_xid(transport, &desc);\r\ncontinue;\r\n}\r\nif (transport->tcp_flags & TCP_RCV_READ_CALLDIR) {\r\nxs_tcp_read_calldir(transport, &desc);\r\ncontinue;\r\n}\r\nif (transport->tcp_flags & TCP_RCV_COPY_DATA) {\r\nxs_tcp_read_data(xprt, &desc);\r\ncontinue;\r\n}\r\nxs_tcp_read_discard(transport, &desc);\r\n} while (desc.count);\r\ndprintk("RPC: xs_tcp_data_recv done\n");\r\nreturn len - desc.count;\r\n}\r\nstatic void xs_tcp_data_ready(struct sock *sk, int bytes)\r\n{\r\nstruct rpc_xprt *xprt;\r\nread_descriptor_t rd_desc;\r\nint read;\r\ndprintk("RPC: xs_tcp_data_ready...\n");\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (!(xprt = xprt_from_sock(sk)))\r\ngoto out;\r\nif (xprt->shutdown)\r\ngoto out;\r\nif (xprt->reestablish_timeout)\r\nxprt->reestablish_timeout = 0;\r\nrd_desc.arg.data = xprt;\r\ndo {\r\nrd_desc.count = 65536;\r\nread = tcp_read_sock(sk, &rd_desc, xs_tcp_data_recv);\r\n} while (read > 0);\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void xs_tcp_schedule_linger_timeout(struct rpc_xprt *xprt,\r\nunsigned long timeout)\r\n{\r\nstruct sock_xprt *transport;\r\nif (xprt_test_and_set_connecting(xprt))\r\nreturn;\r\nset_bit(XPRT_CONNECTION_ABORT, &xprt->state);\r\ntransport = container_of(xprt, struct sock_xprt, xprt);\r\nqueue_delayed_work(rpciod_workqueue, &transport->connect_worker,\r\ntimeout);\r\n}\r\nstatic void xs_tcp_cancel_linger_timeout(struct rpc_xprt *xprt)\r\n{\r\nstruct sock_xprt *transport;\r\ntransport = container_of(xprt, struct sock_xprt, xprt);\r\nif (!test_bit(XPRT_CONNECTION_ABORT, &xprt->state) ||\r\n!cancel_delayed_work(&transport->connect_worker))\r\nreturn;\r\nclear_bit(XPRT_CONNECTION_ABORT, &xprt->state);\r\nxprt_clear_connecting(xprt);\r\n}\r\nstatic void xs_sock_mark_closed(struct rpc_xprt *xprt)\r\n{\r\nsmp_mb__before_clear_bit();\r\nclear_bit(XPRT_CLOSE_WAIT, &xprt->state);\r\nclear_bit(XPRT_CLOSING, &xprt->state);\r\nsmp_mb__after_clear_bit();\r\nxprt_disconnect_done(xprt);\r\n}\r\nstatic void xs_tcp_state_change(struct sock *sk)\r\n{\r\nstruct rpc_xprt *xprt;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (!(xprt = xprt_from_sock(sk)))\r\ngoto out;\r\ndprintk("RPC: xs_tcp_state_change client %p...\n", xprt);\r\ndprintk("RPC: state %x conn %d dead %d zapped %d sk_shutdown %d\n",\r\nsk->sk_state, xprt_connected(xprt),\r\nsock_flag(sk, SOCK_DEAD),\r\nsock_flag(sk, SOCK_ZAPPED),\r\nsk->sk_shutdown);\r\nswitch (sk->sk_state) {\r\ncase TCP_ESTABLISHED:\r\nspin_lock(&xprt->transport_lock);\r\nif (!xprt_test_and_set_connected(xprt)) {\r\nstruct sock_xprt *transport = container_of(xprt,\r\nstruct sock_xprt, xprt);\r\ntransport->tcp_offset = 0;\r\ntransport->tcp_reclen = 0;\r\ntransport->tcp_copied = 0;\r\ntransport->tcp_flags =\r\nTCP_RCV_COPY_FRAGHDR | TCP_RCV_COPY_XID;\r\nxprt_wake_pending_tasks(xprt, -EAGAIN);\r\n}\r\nspin_unlock(&xprt->transport_lock);\r\nbreak;\r\ncase TCP_FIN_WAIT1:\r\nxprt->connect_cookie++;\r\nxprt->reestablish_timeout = 0;\r\nset_bit(XPRT_CLOSING, &xprt->state);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(XPRT_CONNECTED, &xprt->state);\r\nclear_bit(XPRT_CLOSE_WAIT, &xprt->state);\r\nsmp_mb__after_clear_bit();\r\nxs_tcp_schedule_linger_timeout(xprt, xs_tcp_fin_timeout);\r\nbreak;\r\ncase TCP_CLOSE_WAIT:\r\nxprt_force_disconnect(xprt);\r\nxprt->connect_cookie++;\r\ncase TCP_CLOSING:\r\nif (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)\r\nxprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\r\nbreak;\r\ncase TCP_LAST_ACK:\r\nset_bit(XPRT_CLOSING, &xprt->state);\r\nxs_tcp_schedule_linger_timeout(xprt, xs_tcp_fin_timeout);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(XPRT_CONNECTED, &xprt->state);\r\nsmp_mb__after_clear_bit();\r\nbreak;\r\ncase TCP_CLOSE:\r\nxs_tcp_cancel_linger_timeout(xprt);\r\nxs_sock_mark_closed(xprt);\r\n}\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void xs_error_report(struct sock *sk)\r\n{\r\nstruct rpc_xprt *xprt;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (!(xprt = xprt_from_sock(sk)))\r\ngoto out;\r\ndprintk("RPC: %s client %p...\n"\r\n"RPC: error %d\n",\r\n__func__, xprt, sk->sk_err);\r\nxprt_wake_pending_tasks(xprt, -EAGAIN);\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void xs_write_space(struct sock *sk)\r\n{\r\nstruct socket *sock;\r\nstruct rpc_xprt *xprt;\r\nif (unlikely(!(sock = sk->sk_socket)))\r\nreturn;\r\nclear_bit(SOCK_NOSPACE, &sock->flags);\r\nif (unlikely(!(xprt = xprt_from_sock(sk))))\r\nreturn;\r\nif (test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sock->flags) == 0)\r\nreturn;\r\nxprt_write_space(xprt);\r\n}\r\nstatic void xs_udp_write_space(struct sock *sk)\r\n{\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (sock_writeable(sk))\r\nxs_write_space(sk);\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void xs_tcp_write_space(struct sock *sk)\r\n{\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (sk_stream_wspace(sk) >= sk_stream_min_wspace(sk))\r\nxs_write_space(sk);\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void xs_udp_do_set_buffer_size(struct rpc_xprt *xprt)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nstruct sock *sk = transport->inet;\r\nif (transport->rcvsize) {\r\nsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\r\nsk->sk_rcvbuf = transport->rcvsize * xprt->max_reqs * 2;\r\n}\r\nif (transport->sndsize) {\r\nsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\r\nsk->sk_sndbuf = transport->sndsize * xprt->max_reqs * 2;\r\nsk->sk_write_space(sk);\r\n}\r\n}\r\nstatic void xs_udp_set_buffer_size(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\ntransport->sndsize = 0;\r\nif (sndsize)\r\ntransport->sndsize = sndsize + 1024;\r\ntransport->rcvsize = 0;\r\nif (rcvsize)\r\ntransport->rcvsize = rcvsize + 1024;\r\nxs_udp_do_set_buffer_size(xprt);\r\n}\r\nstatic void xs_udp_timer(struct rpc_task *task)\r\n{\r\nxprt_adjust_cwnd(task, -ETIMEDOUT);\r\n}\r\nstatic unsigned short xs_get_random_port(void)\r\n{\r\nunsigned short range = xprt_max_resvport - xprt_min_resvport;\r\nunsigned short rand = (unsigned short) net_random() % range;\r\nreturn rand + xprt_min_resvport;\r\n}\r\nstatic void xs_set_port(struct rpc_xprt *xprt, unsigned short port)\r\n{\r\ndprintk("RPC: setting port for xprt %p to %u\n", xprt, port);\r\nrpc_set_port(xs_addr(xprt), port);\r\nxs_update_peer_port(xprt);\r\n}\r\nstatic unsigned short xs_get_srcport(struct sock_xprt *transport)\r\n{\r\nunsigned short port = transport->srcport;\r\nif (port == 0 && transport->xprt.resvport)\r\nport = xs_get_random_port();\r\nreturn port;\r\n}\r\nstatic unsigned short xs_next_srcport(struct sock_xprt *transport, unsigned short port)\r\n{\r\nif (transport->srcport != 0)\r\ntransport->srcport = 0;\r\nif (!transport->xprt.resvport)\r\nreturn 0;\r\nif (port <= xprt_min_resvport || port > xprt_max_resvport)\r\nreturn xprt_max_resvport;\r\nreturn --port;\r\n}\r\nstatic int xs_bind(struct sock_xprt *transport, struct socket *sock)\r\n{\r\nstruct sockaddr_storage myaddr;\r\nint err, nloop = 0;\r\nunsigned short port = xs_get_srcport(transport);\r\nunsigned short last;\r\nmemcpy(&myaddr, &transport->srcaddr, transport->xprt.addrlen);\r\ndo {\r\nrpc_set_port((struct sockaddr *)&myaddr, port);\r\nerr = kernel_bind(sock, (struct sockaddr *)&myaddr,\r\ntransport->xprt.addrlen);\r\nif (port == 0)\r\nbreak;\r\nif (err == 0) {\r\ntransport->srcport = port;\r\nbreak;\r\n}\r\nlast = port;\r\nport = xs_next_srcport(transport, port);\r\nif (port > last)\r\nnloop++;\r\n} while (err == -EADDRINUSE && nloop != 2);\r\nif (myaddr.ss_family == AF_INET)\r\ndprintk("RPC: %s %pI4:%u: %s (%d)\n", __func__,\r\n&((struct sockaddr_in *)&myaddr)->sin_addr,\r\nport, err ? "failed" : "ok", err);\r\nelse\r\ndprintk("RPC: %s %pI6:%u: %s (%d)\n", __func__,\r\n&((struct sockaddr_in6 *)&myaddr)->sin6_addr,\r\nport, err ? "failed" : "ok", err);\r\nreturn err;\r\n}\r\nstatic void xs_local_rpcbind(struct rpc_task *task)\r\n{\r\nxprt_set_bound(task->tk_xprt);\r\n}\r\nstatic void xs_local_set_port(struct rpc_xprt *xprt, unsigned short port)\r\n{\r\n}\r\nstatic inline void xs_reclassify_socketu(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBUG_ON(sock_owned_by_user(sk));\r\nsock_lock_init_class_and_name(sk, "slock-AF_LOCAL-RPC",\r\n&xs_slock_key[1], "sk_lock-AF_LOCAL-RPC", &xs_key[1]);\r\n}\r\nstatic inline void xs_reclassify_socket4(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBUG_ON(sock_owned_by_user(sk));\r\nsock_lock_init_class_and_name(sk, "slock-AF_INET-RPC",\r\n&xs_slock_key[0], "sk_lock-AF_INET-RPC", &xs_key[0]);\r\n}\r\nstatic inline void xs_reclassify_socket6(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nBUG_ON(sock_owned_by_user(sk));\r\nsock_lock_init_class_and_name(sk, "slock-AF_INET6-RPC",\r\n&xs_slock_key[1], "sk_lock-AF_INET6-RPC", &xs_key[1]);\r\n}\r\nstatic inline void xs_reclassify_socket(int family, struct socket *sock)\r\n{\r\nswitch (family) {\r\ncase AF_LOCAL:\r\nxs_reclassify_socketu(sock);\r\nbreak;\r\ncase AF_INET:\r\nxs_reclassify_socket4(sock);\r\nbreak;\r\ncase AF_INET6:\r\nxs_reclassify_socket6(sock);\r\nbreak;\r\n}\r\n}\r\nstatic inline void xs_reclassify_socketu(struct socket *sock)\r\n{\r\n}\r\nstatic inline void xs_reclassify_socket4(struct socket *sock)\r\n{\r\n}\r\nstatic inline void xs_reclassify_socket6(struct socket *sock)\r\n{\r\n}\r\nstatic inline void xs_reclassify_socket(int family, struct socket *sock)\r\n{\r\n}\r\nstatic struct socket *xs_create_sock(struct rpc_xprt *xprt,\r\nstruct sock_xprt *transport, int family, int type, int protocol)\r\n{\r\nstruct socket *sock;\r\nint err;\r\nerr = __sock_create(xprt->xprt_net, family, type, protocol, &sock, 1);\r\nif (err < 0) {\r\ndprintk("RPC: can't create %d transport socket (%d).\n",\r\nprotocol, -err);\r\ngoto out;\r\n}\r\nxs_reclassify_socket(family, sock);\r\nerr = xs_bind(transport, sock);\r\nif (err) {\r\nsock_release(sock);\r\ngoto out;\r\n}\r\nreturn sock;\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int xs_local_finish_connecting(struct rpc_xprt *xprt,\r\nstruct socket *sock)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt,\r\nxprt);\r\nif (!transport->inet) {\r\nstruct sock *sk = sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nxs_save_old_callbacks(transport, sk);\r\nsk->sk_user_data = xprt;\r\nsk->sk_data_ready = xs_local_data_ready;\r\nsk->sk_write_space = xs_udp_write_space;\r\nsk->sk_error_report = xs_error_report;\r\nsk->sk_allocation = GFP_ATOMIC;\r\nxprt_clear_connected(xprt);\r\ntransport->sock = sock;\r\ntransport->inet = sk;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nxprt->stat.connect_count++;\r\nxprt->stat.connect_start = jiffies;\r\nreturn kernel_connect(sock, xs_addr(xprt), xprt->addrlen, 0);\r\n}\r\nstatic void xs_local_setup_socket(struct work_struct *work)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(work, struct sock_xprt, connect_worker.work);\r\nstruct rpc_xprt *xprt = &transport->xprt;\r\nstruct socket *sock;\r\nint status = -EIO;\r\nif (xprt->shutdown)\r\ngoto out;\r\nclear_bit(XPRT_CONNECTION_ABORT, &xprt->state);\r\nstatus = __sock_create(xprt->xprt_net, AF_LOCAL,\r\nSOCK_STREAM, 0, &sock, 1);\r\nif (status < 0) {\r\ndprintk("RPC: can't create AF_LOCAL "\r\n"transport socket (%d).\n", -status);\r\ngoto out;\r\n}\r\nxs_reclassify_socketu(sock);\r\ndprintk("RPC: worker connecting xprt %p via AF_LOCAL to %s\n",\r\nxprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\r\nstatus = xs_local_finish_connecting(xprt, sock);\r\nswitch (status) {\r\ncase 0:\r\ndprintk("RPC: xprt %p connected to %s\n",\r\nxprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\r\nxprt_set_connected(xprt);\r\nbreak;\r\ncase -ENOENT:\r\ndprintk("RPC: xprt %p: socket %s does not exist\n",\r\nxprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unhandled error (%d) connecting to %s\n",\r\n__func__, -status,\r\nxprt->address_strings[RPC_DISPLAY_ADDR]);\r\n}\r\nout:\r\nxprt_clear_connecting(xprt);\r\nxprt_wake_pending_tasks(xprt, status);\r\n}\r\nstatic void xs_udp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nif (!transport->inet) {\r\nstruct sock *sk = sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nxs_save_old_callbacks(transport, sk);\r\nsk->sk_user_data = xprt;\r\nsk->sk_data_ready = xs_udp_data_ready;\r\nsk->sk_write_space = xs_udp_write_space;\r\nsk->sk_error_report = xs_error_report;\r\nsk->sk_no_check = UDP_CSUM_NORCV;\r\nsk->sk_allocation = GFP_ATOMIC;\r\nxprt_set_connected(xprt);\r\ntransport->sock = sock;\r\ntransport->inet = sk;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nxs_udp_do_set_buffer_size(xprt);\r\n}\r\nstatic void xs_udp_setup_socket(struct work_struct *work)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(work, struct sock_xprt, connect_worker.work);\r\nstruct rpc_xprt *xprt = &transport->xprt;\r\nstruct socket *sock = transport->sock;\r\nint status = -EIO;\r\nif (xprt->shutdown)\r\ngoto out;\r\nxs_reset_transport(transport);\r\nsock = xs_create_sock(xprt, transport,\r\nxs_addr(xprt)->sa_family, SOCK_DGRAM, IPPROTO_UDP);\r\nif (IS_ERR(sock))\r\ngoto out;\r\ndprintk("RPC: worker connecting xprt %p via %s to "\r\n"%s (port %s)\n", xprt,\r\nxprt->address_strings[RPC_DISPLAY_PROTO],\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PORT]);\r\nxs_udp_finish_connecting(xprt, sock);\r\nstatus = 0;\r\nout:\r\nxprt_clear_connecting(xprt);\r\nxprt_wake_pending_tasks(xprt, status);\r\n}\r\nstatic void xs_abort_connection(struct sock_xprt *transport)\r\n{\r\nint result;\r\nstruct sockaddr any;\r\ndprintk("RPC: disconnecting xprt %p to reuse port\n", transport);\r\nmemset(&any, 0, sizeof(any));\r\nany.sa_family = AF_UNSPEC;\r\nresult = kernel_connect(transport->sock, &any, sizeof(any), 0);\r\nif (!result)\r\nxs_sock_mark_closed(&transport->xprt);\r\nelse\r\ndprintk("RPC: AF_UNSPEC connect return code %d\n",\r\nresult);\r\n}\r\nstatic void xs_tcp_reuse_connection(struct sock_xprt *transport)\r\n{\r\nunsigned int state = transport->inet->sk_state;\r\nif (state == TCP_CLOSE && transport->sock->state == SS_UNCONNECTED) {\r\nif (transport->inet->sk_shutdown == 0)\r\nreturn;\r\ndprintk("RPC: %s: TCP_CLOSEd and sk_shutdown set to %d\n",\r\n__func__, transport->inet->sk_shutdown);\r\n}\r\nif ((1 << state) & (TCPF_ESTABLISHED|TCPF_SYN_SENT)) {\r\nif (transport->inet->sk_shutdown == 0)\r\nreturn;\r\ndprintk("RPC: %s: ESTABLISHED/SYN_SENT "\r\n"sk_shutdown set to %d\n",\r\n__func__, transport->inet->sk_shutdown);\r\n}\r\nxs_abort_connection(transport);\r\n}\r\nstatic int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nint ret = -ENOTCONN;\r\nif (!transport->inet) {\r\nstruct sock *sk = sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nxs_save_old_callbacks(transport, sk);\r\nsk->sk_user_data = xprt;\r\nsk->sk_data_ready = xs_tcp_data_ready;\r\nsk->sk_state_change = xs_tcp_state_change;\r\nsk->sk_write_space = xs_tcp_write_space;\r\nsk->sk_error_report = xs_error_report;\r\nsk->sk_allocation = GFP_ATOMIC;\r\nsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\r\nsock_reset_flag(sk, SOCK_LINGER);\r\ntcp_sk(sk)->linger2 = 0;\r\ntcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;\r\nxprt_clear_connected(xprt);\r\ntransport->sock = sock;\r\ntransport->inet = sk;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nif (!xprt_bound(xprt))\r\ngoto out;\r\nxprt->stat.connect_count++;\r\nxprt->stat.connect_start = jiffies;\r\nret = kernel_connect(sock, xs_addr(xprt), xprt->addrlen, O_NONBLOCK);\r\nswitch (ret) {\r\ncase 0:\r\ncase -EINPROGRESS:\r\nxprt->connect_cookie++;\r\nif (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)\r\nxprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void xs_tcp_setup_socket(struct work_struct *work)\r\n{\r\nstruct sock_xprt *transport =\r\ncontainer_of(work, struct sock_xprt, connect_worker.work);\r\nstruct socket *sock = transport->sock;\r\nstruct rpc_xprt *xprt = &transport->xprt;\r\nint status = -EIO;\r\nif (xprt->shutdown)\r\ngoto out;\r\nif (!sock) {\r\nclear_bit(XPRT_CONNECTION_ABORT, &xprt->state);\r\nsock = xs_create_sock(xprt, transport,\r\nxs_addr(xprt)->sa_family, SOCK_STREAM, IPPROTO_TCP);\r\nif (IS_ERR(sock)) {\r\nstatus = PTR_ERR(sock);\r\ngoto out;\r\n}\r\n} else {\r\nint abort_and_exit;\r\nabort_and_exit = test_and_clear_bit(XPRT_CONNECTION_ABORT,\r\n&xprt->state);\r\nxs_tcp_reuse_connection(transport);\r\nif (abort_and_exit)\r\ngoto out_eagain;\r\n}\r\ndprintk("RPC: worker connecting xprt %p via %s to "\r\n"%s (port %s)\n", xprt,\r\nxprt->address_strings[RPC_DISPLAY_PROTO],\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PORT]);\r\nstatus = xs_tcp_finish_connecting(xprt, sock);\r\ndprintk("RPC: %p connect status %d connected %d sock state %d\n",\r\nxprt, -status, xprt_connected(xprt),\r\nsock->sk->sk_state);\r\nswitch (status) {\r\ndefault:\r\nprintk("%s: connect returned unhandled error %d\n",\r\n__func__, status);\r\ncase -EADDRNOTAVAIL:\r\nset_bit(XPRT_CONNECTION_CLOSE, &xprt->state);\r\nxprt_force_disconnect(xprt);\r\nbreak;\r\ncase -ECONNREFUSED:\r\ncase -ECONNRESET:\r\ncase -ENETUNREACH:\r\ncase 0:\r\ncase -EINPROGRESS:\r\ncase -EALREADY:\r\nxprt_clear_connecting(xprt);\r\nreturn;\r\ncase -EINVAL:\r\ngoto out;\r\n}\r\nout_eagain:\r\nstatus = -EAGAIN;\r\nout:\r\nxprt_clear_connecting(xprt);\r\nxprt_wake_pending_tasks(xprt, status);\r\n}\r\nstatic void xs_connect(struct rpc_task *task)\r\n{\r\nstruct rpc_xprt *xprt = task->tk_xprt;\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nif (transport->sock != NULL && !RPC_IS_SOFTCONN(task)) {\r\ndprintk("RPC: xs_connect delayed xprt %p for %lu "\r\n"seconds\n",\r\nxprt, xprt->reestablish_timeout / HZ);\r\nqueue_delayed_work(rpciod_workqueue,\r\n&transport->connect_worker,\r\nxprt->reestablish_timeout);\r\nxprt->reestablish_timeout <<= 1;\r\nif (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)\r\nxprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\r\nif (xprt->reestablish_timeout > XS_TCP_MAX_REEST_TO)\r\nxprt->reestablish_timeout = XS_TCP_MAX_REEST_TO;\r\n} else {\r\ndprintk("RPC: xs_connect scheduled xprt %p\n", xprt);\r\nqueue_delayed_work(rpciod_workqueue,\r\n&transport->connect_worker, 0);\r\n}\r\n}\r\nstatic void xs_local_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\r\n{\r\nlong idle_time = 0;\r\nif (xprt_connected(xprt))\r\nidle_time = (long)(jiffies - xprt->last_used) / HZ;\r\nseq_printf(seq, "\txprt:\tlocal %lu %lu %lu %ld %lu %lu %lu "\r\n"%llu %llu %lu %llu %llu\n",\r\nxprt->stat.bind_count,\r\nxprt->stat.connect_count,\r\nxprt->stat.connect_time,\r\nidle_time,\r\nxprt->stat.sends,\r\nxprt->stat.recvs,\r\nxprt->stat.bad_xids,\r\nxprt->stat.req_u,\r\nxprt->stat.bklog_u,\r\nxprt->stat.max_slots,\r\nxprt->stat.sending_u,\r\nxprt->stat.pending_u);\r\n}\r\nstatic void xs_udp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nseq_printf(seq, "\txprt:\tudp %u %lu %lu %lu %lu %llu %llu "\r\n"%lu %llu %llu\n",\r\ntransport->srcport,\r\nxprt->stat.bind_count,\r\nxprt->stat.sends,\r\nxprt->stat.recvs,\r\nxprt->stat.bad_xids,\r\nxprt->stat.req_u,\r\nxprt->stat.bklog_u,\r\nxprt->stat.max_slots,\r\nxprt->stat.sending_u,\r\nxprt->stat.pending_u);\r\n}\r\nstatic void xs_tcp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\r\n{\r\nstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\r\nlong idle_time = 0;\r\nif (xprt_connected(xprt))\r\nidle_time = (long)(jiffies - xprt->last_used) / HZ;\r\nseq_printf(seq, "\txprt:\ttcp %u %lu %lu %lu %ld %lu %lu %lu "\r\n"%llu %llu %lu %llu %llu\n",\r\ntransport->srcport,\r\nxprt->stat.bind_count,\r\nxprt->stat.connect_count,\r\nxprt->stat.connect_time,\r\nidle_time,\r\nxprt->stat.sends,\r\nxprt->stat.recvs,\r\nxprt->stat.bad_xids,\r\nxprt->stat.req_u,\r\nxprt->stat.bklog_u,\r\nxprt->stat.max_slots,\r\nxprt->stat.sending_u,\r\nxprt->stat.pending_u);\r\n}\r\nstatic void *bc_malloc(struct rpc_task *task, size_t size)\r\n{\r\nstruct page *page;\r\nstruct rpc_buffer *buf;\r\nBUG_ON(size > PAGE_SIZE - sizeof(struct rpc_buffer));\r\npage = alloc_page(GFP_KERNEL);\r\nif (!page)\r\nreturn NULL;\r\nbuf = page_address(page);\r\nbuf->len = PAGE_SIZE;\r\nreturn buf->data;\r\n}\r\nstatic void bc_free(void *buffer)\r\n{\r\nstruct rpc_buffer *buf;\r\nif (!buffer)\r\nreturn;\r\nbuf = container_of(buffer, struct rpc_buffer, data);\r\nfree_page((unsigned long)buf);\r\n}\r\nstatic int bc_sendto(struct rpc_rqst *req)\r\n{\r\nint len;\r\nstruct xdr_buf *xbufp = &req->rq_snd_buf;\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\nstruct sock_xprt *transport =\r\ncontainer_of(xprt, struct sock_xprt, xprt);\r\nstruct socket *sock = transport->sock;\r\nunsigned long headoff;\r\nunsigned long tailoff;\r\nxs_encode_stream_record_marker(xbufp);\r\ntailoff = (unsigned long)xbufp->tail[0].iov_base & ~PAGE_MASK;\r\nheadoff = (unsigned long)xbufp->head[0].iov_base & ~PAGE_MASK;\r\nlen = svc_send_common(sock, xbufp,\r\nvirt_to_page(xbufp->head[0].iov_base), headoff,\r\nxbufp->tail[0].iov_base, tailoff);\r\nif (len != xbufp->len) {\r\nprintk(KERN_NOTICE "Error sending entire callback!\n");\r\nlen = -EAGAIN;\r\n}\r\nreturn len;\r\n}\r\nstatic int bc_send_request(struct rpc_task *task)\r\n{\r\nstruct rpc_rqst *req = task->tk_rqstp;\r\nstruct svc_xprt *xprt;\r\nstruct svc_sock *svsk;\r\nu32 len;\r\ndprintk("sending request with xid: %08x\n", ntohl(req->rq_xid));\r\nxprt = req->rq_xprt->bc_xprt;\r\nsvsk = container_of(xprt, struct svc_sock, sk_xprt);\r\nif (!mutex_trylock(&xprt->xpt_mutex)) {\r\nrpc_sleep_on(&xprt->xpt_bc_pending, task, NULL);\r\nif (!mutex_trylock(&xprt->xpt_mutex))\r\nreturn -EAGAIN;\r\nrpc_wake_up_queued_task(&xprt->xpt_bc_pending, task);\r\n}\r\nif (test_bit(XPT_DEAD, &xprt->xpt_flags))\r\nlen = -ENOTCONN;\r\nelse\r\nlen = bc_sendto(req);\r\nmutex_unlock(&xprt->xpt_mutex);\r\nif (len > 0)\r\nlen = 0;\r\nreturn len;\r\n}\r\nstatic void bc_close(struct rpc_xprt *xprt)\r\n{\r\n}\r\nstatic void bc_destroy(struct rpc_xprt *xprt)\r\n{\r\n}\r\nstatic int xs_init_anyaddr(const int family, struct sockaddr *sap)\r\n{\r\nstatic const struct sockaddr_in sin = {\r\n.sin_family = AF_INET,\r\n.sin_addr.s_addr = htonl(INADDR_ANY),\r\n};\r\nstatic const struct sockaddr_in6 sin6 = {\r\n.sin6_family = AF_INET6,\r\n.sin6_addr = IN6ADDR_ANY_INIT,\r\n};\r\nswitch (family) {\r\ncase AF_LOCAL:\r\nbreak;\r\ncase AF_INET:\r\nmemcpy(sap, &sin, sizeof(sin));\r\nbreak;\r\ncase AF_INET6:\r\nmemcpy(sap, &sin6, sizeof(sin6));\r\nbreak;\r\ndefault:\r\ndprintk("RPC: %s: Bad address family\n", __func__);\r\nreturn -EAFNOSUPPORT;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct rpc_xprt *xs_setup_xprt(struct xprt_create *args,\r\nunsigned int slot_table_size,\r\nunsigned int max_slot_table_size)\r\n{\r\nstruct rpc_xprt *xprt;\r\nstruct sock_xprt *new;\r\nif (args->addrlen > sizeof(xprt->addr)) {\r\ndprintk("RPC: xs_setup_xprt: address too large\n");\r\nreturn ERR_PTR(-EBADF);\r\n}\r\nxprt = xprt_alloc(args->net, sizeof(*new), slot_table_size,\r\nmax_slot_table_size);\r\nif (xprt == NULL) {\r\ndprintk("RPC: xs_setup_xprt: couldn't allocate "\r\n"rpc_xprt\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnew = container_of(xprt, struct sock_xprt, xprt);\r\nmemcpy(&xprt->addr, args->dstaddr, args->addrlen);\r\nxprt->addrlen = args->addrlen;\r\nif (args->srcaddr)\r\nmemcpy(&new->srcaddr, args->srcaddr, args->addrlen);\r\nelse {\r\nint err;\r\nerr = xs_init_anyaddr(args->dstaddr->sa_family,\r\n(struct sockaddr *)&new->srcaddr);\r\nif (err != 0) {\r\nxprt_free(xprt);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nreturn xprt;\r\n}\r\nstatic struct rpc_xprt *xs_setup_local(struct xprt_create *args)\r\n{\r\nstruct sockaddr_un *sun = (struct sockaddr_un *)args->dstaddr;\r\nstruct sock_xprt *transport;\r\nstruct rpc_xprt *xprt;\r\nstruct rpc_xprt *ret;\r\nxprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\r\nxprt_max_tcp_slot_table_entries);\r\nif (IS_ERR(xprt))\r\nreturn xprt;\r\ntransport = container_of(xprt, struct sock_xprt, xprt);\r\nxprt->prot = 0;\r\nxprt->tsh_size = sizeof(rpc_fraghdr) / sizeof(u32);\r\nxprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\r\nxprt->bind_timeout = XS_BIND_TO;\r\nxprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\r\nxprt->idle_timeout = XS_IDLE_DISC_TO;\r\nxprt->ops = &xs_local_ops;\r\nxprt->timeout = &xs_local_default_timeout;\r\nswitch (sun->sun_family) {\r\ncase AF_LOCAL:\r\nif (sun->sun_path[0] != '/') {\r\ndprintk("RPC: bad AF_LOCAL address: %s\n",\r\nsun->sun_path);\r\nret = ERR_PTR(-EINVAL);\r\ngoto out_err;\r\n}\r\nxprt_set_bound(xprt);\r\nINIT_DELAYED_WORK(&transport->connect_worker,\r\nxs_local_setup_socket);\r\nxs_format_peer_addresses(xprt, "local", RPCBIND_NETID_LOCAL);\r\nbreak;\r\ndefault:\r\nret = ERR_PTR(-EAFNOSUPPORT);\r\ngoto out_err;\r\n}\r\ndprintk("RPC: set up xprt to %s via AF_LOCAL\n",\r\nxprt->address_strings[RPC_DISPLAY_ADDR]);\r\nif (try_module_get(THIS_MODULE))\r\nreturn xprt;\r\nret = ERR_PTR(-EINVAL);\r\nout_err:\r\nxprt_free(xprt);\r\nreturn ret;\r\n}\r\nstatic struct rpc_xprt *xs_setup_udp(struct xprt_create *args)\r\n{\r\nstruct sockaddr *addr = args->dstaddr;\r\nstruct rpc_xprt *xprt;\r\nstruct sock_xprt *transport;\r\nstruct rpc_xprt *ret;\r\nxprt = xs_setup_xprt(args, xprt_udp_slot_table_entries,\r\nxprt_udp_slot_table_entries);\r\nif (IS_ERR(xprt))\r\nreturn xprt;\r\ntransport = container_of(xprt, struct sock_xprt, xprt);\r\nxprt->prot = IPPROTO_UDP;\r\nxprt->tsh_size = 0;\r\nxprt->max_payload = (1U << 16) - (MAX_HEADER << 3);\r\nxprt->bind_timeout = XS_BIND_TO;\r\nxprt->reestablish_timeout = XS_UDP_REEST_TO;\r\nxprt->idle_timeout = XS_IDLE_DISC_TO;\r\nxprt->ops = &xs_udp_ops;\r\nxprt->timeout = &xs_udp_default_timeout;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nif (((struct sockaddr_in *)addr)->sin_port != htons(0))\r\nxprt_set_bound(xprt);\r\nINIT_DELAYED_WORK(&transport->connect_worker,\r\nxs_udp_setup_socket);\r\nxs_format_peer_addresses(xprt, "udp", RPCBIND_NETID_UDP);\r\nbreak;\r\ncase AF_INET6:\r\nif (((struct sockaddr_in6 *)addr)->sin6_port != htons(0))\r\nxprt_set_bound(xprt);\r\nINIT_DELAYED_WORK(&transport->connect_worker,\r\nxs_udp_setup_socket);\r\nxs_format_peer_addresses(xprt, "udp", RPCBIND_NETID_UDP6);\r\nbreak;\r\ndefault:\r\nret = ERR_PTR(-EAFNOSUPPORT);\r\ngoto out_err;\r\n}\r\nif (xprt_bound(xprt))\r\ndprintk("RPC: set up xprt to %s (port %s) via %s\n",\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PORT],\r\nxprt->address_strings[RPC_DISPLAY_PROTO]);\r\nelse\r\ndprintk("RPC: set up xprt to %s (autobind) via %s\n",\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PROTO]);\r\nif (try_module_get(THIS_MODULE))\r\nreturn xprt;\r\nret = ERR_PTR(-EINVAL);\r\nout_err:\r\nxprt_free(xprt);\r\nreturn ret;\r\n}\r\nstatic struct rpc_xprt *xs_setup_tcp(struct xprt_create *args)\r\n{\r\nstruct sockaddr *addr = args->dstaddr;\r\nstruct rpc_xprt *xprt;\r\nstruct sock_xprt *transport;\r\nstruct rpc_xprt *ret;\r\nxprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\r\nxprt_max_tcp_slot_table_entries);\r\nif (IS_ERR(xprt))\r\nreturn xprt;\r\ntransport = container_of(xprt, struct sock_xprt, xprt);\r\nxprt->prot = IPPROTO_TCP;\r\nxprt->tsh_size = sizeof(rpc_fraghdr) / sizeof(u32);\r\nxprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\r\nxprt->bind_timeout = XS_BIND_TO;\r\nxprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\r\nxprt->idle_timeout = XS_IDLE_DISC_TO;\r\nxprt->ops = &xs_tcp_ops;\r\nxprt->timeout = &xs_tcp_default_timeout;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nif (((struct sockaddr_in *)addr)->sin_port != htons(0))\r\nxprt_set_bound(xprt);\r\nINIT_DELAYED_WORK(&transport->connect_worker,\r\nxs_tcp_setup_socket);\r\nxs_format_peer_addresses(xprt, "tcp", RPCBIND_NETID_TCP);\r\nbreak;\r\ncase AF_INET6:\r\nif (((struct sockaddr_in6 *)addr)->sin6_port != htons(0))\r\nxprt_set_bound(xprt);\r\nINIT_DELAYED_WORK(&transport->connect_worker,\r\nxs_tcp_setup_socket);\r\nxs_format_peer_addresses(xprt, "tcp", RPCBIND_NETID_TCP6);\r\nbreak;\r\ndefault:\r\nret = ERR_PTR(-EAFNOSUPPORT);\r\ngoto out_err;\r\n}\r\nif (xprt_bound(xprt))\r\ndprintk("RPC: set up xprt to %s (port %s) via %s\n",\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PORT],\r\nxprt->address_strings[RPC_DISPLAY_PROTO]);\r\nelse\r\ndprintk("RPC: set up xprt to %s (autobind) via %s\n",\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PROTO]);\r\nif (try_module_get(THIS_MODULE))\r\nreturn xprt;\r\nret = ERR_PTR(-EINVAL);\r\nout_err:\r\nxprt_free(xprt);\r\nreturn ret;\r\n}\r\nstatic struct rpc_xprt *xs_setup_bc_tcp(struct xprt_create *args)\r\n{\r\nstruct sockaddr *addr = args->dstaddr;\r\nstruct rpc_xprt *xprt;\r\nstruct sock_xprt *transport;\r\nstruct svc_sock *bc_sock;\r\nstruct rpc_xprt *ret;\r\nif (args->bc_xprt->xpt_bc_xprt) {\r\nreturn args->bc_xprt->xpt_bc_xprt;\r\n}\r\nxprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\r\nxprt_tcp_slot_table_entries);\r\nif (IS_ERR(xprt))\r\nreturn xprt;\r\ntransport = container_of(xprt, struct sock_xprt, xprt);\r\nxprt->prot = IPPROTO_TCP;\r\nxprt->tsh_size = sizeof(rpc_fraghdr) / sizeof(u32);\r\nxprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\r\nxprt->timeout = &xs_tcp_default_timeout;\r\nxprt_set_bound(xprt);\r\nxprt->bind_timeout = 0;\r\nxprt->reestablish_timeout = 0;\r\nxprt->idle_timeout = 0;\r\nxprt->ops = &bc_tcp_ops;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nxs_format_peer_addresses(xprt, "tcp",\r\nRPCBIND_NETID_TCP);\r\nbreak;\r\ncase AF_INET6:\r\nxs_format_peer_addresses(xprt, "tcp",\r\nRPCBIND_NETID_TCP6);\r\nbreak;\r\ndefault:\r\nret = ERR_PTR(-EAFNOSUPPORT);\r\ngoto out_err;\r\n}\r\ndprintk("RPC: set up xprt to %s (port %s) via %s\n",\r\nxprt->address_strings[RPC_DISPLAY_ADDR],\r\nxprt->address_strings[RPC_DISPLAY_PORT],\r\nxprt->address_strings[RPC_DISPLAY_PROTO]);\r\nxprt_get(xprt);\r\nargs->bc_xprt->xpt_bc_xprt = xprt;\r\nxprt->bc_xprt = args->bc_xprt;\r\nbc_sock = container_of(args->bc_xprt, struct svc_sock, sk_xprt);\r\ntransport->sock = bc_sock->sk_sock;\r\ntransport->inet = bc_sock->sk_sk;\r\nxprt_set_connected(xprt);\r\nif (try_module_get(THIS_MODULE))\r\nreturn xprt;\r\nxprt_put(xprt);\r\nret = ERR_PTR(-EINVAL);\r\nout_err:\r\nxprt_free(xprt);\r\nreturn ret;\r\n}\r\nint init_socket_xprt(void)\r\n{\r\n#ifdef RPC_DEBUG\r\nif (!sunrpc_table_header)\r\nsunrpc_table_header = register_sysctl_table(sunrpc_table);\r\n#endif\r\nxprt_register_transport(&xs_local_transport);\r\nxprt_register_transport(&xs_udp_transport);\r\nxprt_register_transport(&xs_tcp_transport);\r\nxprt_register_transport(&xs_bc_tcp_transport);\r\nreturn 0;\r\n}\r\nvoid cleanup_socket_xprt(void)\r\n{\r\n#ifdef RPC_DEBUG\r\nif (sunrpc_table_header) {\r\nunregister_sysctl_table(sunrpc_table_header);\r\nsunrpc_table_header = NULL;\r\n}\r\n#endif\r\nxprt_unregister_transport(&xs_local_transport);\r\nxprt_unregister_transport(&xs_udp_transport);\r\nxprt_unregister_transport(&xs_tcp_transport);\r\nxprt_unregister_transport(&xs_bc_tcp_transport);\r\n}\r\nstatic int param_set_uint_minmax(const char *val,\r\nconst struct kernel_param *kp,\r\nunsigned int min, unsigned int max)\r\n{\r\nunsigned long num;\r\nint ret;\r\nif (!val)\r\nreturn -EINVAL;\r\nret = strict_strtoul(val, 0, &num);\r\nif (ret == -EINVAL || num < min || num > max)\r\nreturn -EINVAL;\r\n*((unsigned int *)kp->arg) = num;\r\nreturn 0;\r\n}\r\nstatic int param_set_portnr(const char *val, const struct kernel_param *kp)\r\n{\r\nreturn param_set_uint_minmax(val, kp,\r\nRPC_MIN_RESVPORT,\r\nRPC_MAX_RESVPORT);\r\n}\r\nstatic int param_set_slot_table_size(const char *val,\r\nconst struct kernel_param *kp)\r\n{\r\nreturn param_set_uint_minmax(val, kp,\r\nRPC_MIN_SLOT_TABLE,\r\nRPC_MAX_SLOT_TABLE);\r\n}\r\nstatic int param_set_max_slot_table_size(const char *val,\r\nconst struct kernel_param *kp)\r\n{\r\nreturn param_set_uint_minmax(val, kp,\r\nRPC_MIN_SLOT_TABLE,\r\nRPC_MAX_SLOT_TABLE_LIMIT);\r\n}
