static inline u64 Ch(u64 x, u64 y, u64 z)\r\n{\r\nreturn z ^ (x & (y ^ z));\r\n}\r\nstatic inline u64 Maj(u64 x, u64 y, u64 z)\r\n{\r\nreturn (x & y) | (z & (x | y));\r\n}\r\nstatic inline void LOAD_OP(int I, u64 *W, const u8 *input)\r\n{\r\nW[I] = __be64_to_cpu( ((__be64*)(input))[I] );\r\n}\r\nstatic inline void BLEND_OP(int I, u64 *W)\r\n{\r\nW[I & 15] += s1(W[(I-2) & 15]) + W[(I-7) & 15] + s0(W[(I-15) & 15]);\r\n}\r\nstatic void\r\nsha512_transform(u64 *state, const u8 *input)\r\n{\r\nu64 a, b, c, d, e, f, g, h, t1, t2;\r\nint i;\r\nu64 W[16];\r\na=state[0]; b=state[1]; c=state[2]; d=state[3];\r\ne=state[4]; f=state[5]; g=state[6]; h=state[7];\r\nfor (i=0; i<80; i+=8) {\r\nif (!(i & 8)) {\r\nint j;\r\nif (i < 16) {\r\nfor (j = 0; j < 16; j++)\r\nLOAD_OP(i + j, W, input);\r\n} else {\r\nfor (j = 0; j < 16; j++) {\r\nBLEND_OP(i + j, W);\r\n}\r\n}\r\n}\r\nt1 = h + e1(e) + Ch(e,f,g) + sha512_K[i ] + W[(i & 15)];\r\nt2 = e0(a) + Maj(a,b,c); d+=t1; h=t1+t2;\r\nt1 = g + e1(d) + Ch(d,e,f) + sha512_K[i+1] + W[(i & 15) + 1];\r\nt2 = e0(h) + Maj(h,a,b); c+=t1; g=t1+t2;\r\nt1 = f + e1(c) + Ch(c,d,e) + sha512_K[i+2] + W[(i & 15) + 2];\r\nt2 = e0(g) + Maj(g,h,a); b+=t1; f=t1+t2;\r\nt1 = e + e1(b) + Ch(b,c,d) + sha512_K[i+3] + W[(i & 15) + 3];\r\nt2 = e0(f) + Maj(f,g,h); a+=t1; e=t1+t2;\r\nt1 = d + e1(a) + Ch(a,b,c) + sha512_K[i+4] + W[(i & 15) + 4];\r\nt2 = e0(e) + Maj(e,f,g); h+=t1; d=t1+t2;\r\nt1 = c + e1(h) + Ch(h,a,b) + sha512_K[i+5] + W[(i & 15) + 5];\r\nt2 = e0(d) + Maj(d,e,f); g+=t1; c=t1+t2;\r\nt1 = b + e1(g) + Ch(g,h,a) + sha512_K[i+6] + W[(i & 15) + 6];\r\nt2 = e0(c) + Maj(c,d,e); f+=t1; b=t1+t2;\r\nt1 = a + e1(f) + Ch(f,g,h) + sha512_K[i+7] + W[(i & 15) + 7];\r\nt2 = e0(b) + Maj(b,c,d); e+=t1; a=t1+t2;\r\n}\r\nstate[0] += a; state[1] += b; state[2] += c; state[3] += d;\r\nstate[4] += e; state[5] += f; state[6] += g; state[7] += h;\r\na = b = c = d = e = f = g = h = t1 = t2 = 0;\r\n}\r\nstatic int\r\nsha512_init(struct shash_desc *desc)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nsctx->state[0] = SHA512_H0;\r\nsctx->state[1] = SHA512_H1;\r\nsctx->state[2] = SHA512_H2;\r\nsctx->state[3] = SHA512_H3;\r\nsctx->state[4] = SHA512_H4;\r\nsctx->state[5] = SHA512_H5;\r\nsctx->state[6] = SHA512_H6;\r\nsctx->state[7] = SHA512_H7;\r\nsctx->count[0] = sctx->count[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nsha384_init(struct shash_desc *desc)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nsctx->state[0] = SHA384_H0;\r\nsctx->state[1] = SHA384_H1;\r\nsctx->state[2] = SHA384_H2;\r\nsctx->state[3] = SHA384_H3;\r\nsctx->state[4] = SHA384_H4;\r\nsctx->state[5] = SHA384_H5;\r\nsctx->state[6] = SHA384_H6;\r\nsctx->state[7] = SHA384_H7;\r\nsctx->count[0] = sctx->count[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nsha512_update(struct shash_desc *desc, const u8 *data, unsigned int len)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nunsigned int i, index, part_len;\r\nindex = sctx->count[0] & 0x7f;\r\nif ((sctx->count[0] += len) < len)\r\nsctx->count[1]++;\r\npart_len = 128 - index;\r\nif (len >= part_len) {\r\nmemcpy(&sctx->buf[index], data, part_len);\r\nsha512_transform(sctx->state, sctx->buf);\r\nfor (i = part_len; i + 127 < len; i+=128)\r\nsha512_transform(sctx->state, &data[i]);\r\nindex = 0;\r\n} else {\r\ni = 0;\r\n}\r\nmemcpy(&sctx->buf[index], &data[i], len - i);\r\nreturn 0;\r\n}\r\nstatic int\r\nsha512_final(struct shash_desc *desc, u8 *hash)\r\n{\r\nstruct sha512_state *sctx = shash_desc_ctx(desc);\r\nstatic u8 padding[128] = { 0x80, };\r\n__be64 *dst = (__be64 *)hash;\r\n__be64 bits[2];\r\nunsigned int index, pad_len;\r\nint i;\r\nbits[1] = cpu_to_be64(sctx->count[0] << 3);\r\nbits[0] = cpu_to_be64(sctx->count[1] << 3 | sctx->count[0] >> 61);\r\nindex = sctx->count[0] & 0x7f;\r\npad_len = (index < 112) ? (112 - index) : ((128+112) - index);\r\nsha512_update(desc, padding, pad_len);\r\nsha512_update(desc, (const u8 *)bits, sizeof(bits));\r\nfor (i = 0; i < 8; i++)\r\ndst[i] = cpu_to_be64(sctx->state[i]);\r\nmemset(sctx, 0, sizeof(struct sha512_state));\r\nreturn 0;\r\n}\r\nstatic int sha384_final(struct shash_desc *desc, u8 *hash)\r\n{\r\nu8 D[64];\r\nsha512_final(desc, D);\r\nmemcpy(hash, D, 48);\r\nmemset(D, 0, 64);\r\nreturn 0;\r\n}\r\nstatic int __init sha512_generic_mod_init(void)\r\n{\r\nint ret = 0;\r\nif ((ret = crypto_register_shash(&sha384)) < 0)\r\ngoto out;\r\nif ((ret = crypto_register_shash(&sha512)) < 0)\r\ncrypto_unregister_shash(&sha384);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit sha512_generic_mod_fini(void)\r\n{\r\ncrypto_unregister_shash(&sha384);\r\ncrypto_unregister_shash(&sha512);\r\n}
