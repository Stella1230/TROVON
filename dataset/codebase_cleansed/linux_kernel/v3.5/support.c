int pnp_is_active(struct pnp_dev *dev)\r\n{\r\nif (!pnp_port_start(dev, 0) && pnp_port_len(dev, 0) <= 1 &&\r\n!pnp_mem_start(dev, 0) && pnp_mem_len(dev, 0) <= 1 &&\r\npnp_irq(dev, 0) == -1 && pnp_dma(dev, 0) == -1)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nvoid pnp_eisa_id_to_string(u32 id, char *str)\r\n{\r\nid = be32_to_cpu(id);\r\nstr[0] = 'A' + ((id >> 26) & 0x3f) - 1;\r\nstr[1] = 'A' + ((id >> 21) & 0x1f) - 1;\r\nstr[2] = 'A' + ((id >> 16) & 0x1f) - 1;\r\nstr[3] = hex_asc_hi(id >> 8);\r\nstr[4] = hex_asc_lo(id >> 8);\r\nstr[5] = hex_asc_hi(id);\r\nstr[6] = hex_asc_lo(id);\r\nstr[7] = '\0';\r\n}\r\nchar *pnp_resource_type_name(struct resource *res)\r\n{\r\nswitch (pnp_resource_type(res)) {\r\ncase IORESOURCE_IO:\r\nreturn "io";\r\ncase IORESOURCE_MEM:\r\nreturn "mem";\r\ncase IORESOURCE_IRQ:\r\nreturn "irq";\r\ncase IORESOURCE_DMA:\r\nreturn "dma";\r\ncase IORESOURCE_BUS:\r\nreturn "bus";\r\n}\r\nreturn "unknown";\r\n}\r\nvoid dbg_pnp_show_resources(struct pnp_dev *dev, char *desc)\r\n{\r\nstruct pnp_resource *pnp_res;\r\nif (list_empty(&dev->resources))\r\npnp_dbg(&dev->dev, "%s: no current resources\n", desc);\r\nelse {\r\npnp_dbg(&dev->dev, "%s: current resources:\n", desc);\r\nlist_for_each_entry(pnp_res, &dev->resources, list)\r\npnp_dbg(&dev->dev, "%pr\n", &pnp_res->res);\r\n}\r\n}\r\nchar *pnp_option_priority_name(struct pnp_option *option)\r\n{\r\nswitch (pnp_option_priority(option)) {\r\ncase PNP_RES_PRIORITY_PREFERRED:\r\nreturn "preferred";\r\ncase PNP_RES_PRIORITY_ACCEPTABLE:\r\nreturn "acceptable";\r\ncase PNP_RES_PRIORITY_FUNCTIONAL:\r\nreturn "functional";\r\n}\r\nreturn "invalid";\r\n}\r\nvoid dbg_pnp_show_option(struct pnp_dev *dev, struct pnp_option *option)\r\n{\r\nchar buf[128];\r\nint len = 0, i;\r\nstruct pnp_port *port;\r\nstruct pnp_mem *mem;\r\nstruct pnp_irq *irq;\r\nstruct pnp_dma *dma;\r\nif (pnp_option_is_dependent(option))\r\nlen += scnprintf(buf + len, sizeof(buf) - len,\r\n" dependent set %d (%s) ",\r\npnp_option_set(option),\r\npnp_option_priority_name(option));\r\nelse\r\nlen += scnprintf(buf + len, sizeof(buf) - len,\r\n" independent ");\r\nswitch (option->type) {\r\ncase IORESOURCE_IO:\r\nport = &option->u.port;\r\nlen += scnprintf(buf + len, sizeof(buf) - len, "io min %#llx "\r\n"max %#llx align %lld size %lld flags %#x",\r\n(unsigned long long) port->min,\r\n(unsigned long long) port->max,\r\n(unsigned long long) port->align,\r\n(unsigned long long) port->size, port->flags);\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nmem = &option->u.mem;\r\nlen += scnprintf(buf + len, sizeof(buf) - len, "mem min %#llx "\r\n"max %#llx align %lld size %lld flags %#x",\r\n(unsigned long long) mem->min,\r\n(unsigned long long) mem->max,\r\n(unsigned long long) mem->align,\r\n(unsigned long long) mem->size, mem->flags);\r\nbreak;\r\ncase IORESOURCE_IRQ:\r\nirq = &option->u.irq;\r\nlen += scnprintf(buf + len, sizeof(buf) - len, "irq");\r\nif (bitmap_empty(irq->map.bits, PNP_IRQ_NR))\r\nlen += scnprintf(buf + len, sizeof(buf) - len,\r\n" <none>");\r\nelse {\r\nfor (i = 0; i < PNP_IRQ_NR; i++)\r\nif (test_bit(i, irq->map.bits))\r\nlen += scnprintf(buf + len,\r\nsizeof(buf) - len,\r\n" %d", i);\r\n}\r\nlen += scnprintf(buf + len, sizeof(buf) - len, " flags %#x",\r\nirq->flags);\r\nif (irq->flags & IORESOURCE_IRQ_OPTIONAL)\r\nlen += scnprintf(buf + len, sizeof(buf) - len,\r\n" (optional)");\r\nbreak;\r\ncase IORESOURCE_DMA:\r\ndma = &option->u.dma;\r\nlen += scnprintf(buf + len, sizeof(buf) - len, "dma");\r\nif (!dma->map)\r\nlen += scnprintf(buf + len, sizeof(buf) - len,\r\n" <none>");\r\nelse {\r\nfor (i = 0; i < 8; i++)\r\nif (dma->map & (1 << i))\r\nlen += scnprintf(buf + len,\r\nsizeof(buf) - len,\r\n" %d", i);\r\n}\r\nlen += scnprintf(buf + len, sizeof(buf) - len, " (bitmask %#x) "\r\n"flags %#x", dma->map, dma->flags);\r\nbreak;\r\n}\r\npnp_dbg(&dev->dev, "%s\n", buf);\r\n}
