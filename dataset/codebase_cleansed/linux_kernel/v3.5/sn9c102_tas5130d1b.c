static int tas5130d1b_init(struct sn9c102_device* cam)\r\n{\r\nint err;\r\nerr = sn9c102_write_const_regs(cam, {0x01, 0x01}, {0x20, 0x17},\r\n{0x04, 0x01}, {0x01, 0x10},\r\n{0x00, 0x11}, {0x00, 0x14},\r\n{0x60, 0x17}, {0x07, 0x18});\r\nreturn err;\r\n}\r\nstatic int tas5130d1b_set_ctrl(struct sn9c102_device* cam,\r\nconst struct v4l2_control* ctrl)\r\n{\r\nint err = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\nerr += sn9c102_i2c_write(cam, 0x20, 0xf6 - ctrl->value);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nerr += sn9c102_i2c_write(cam, 0x40, 0x47 - ctrl->value);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int tas5130d1b_set_crop(struct sn9c102_device* cam,\r\nconst struct v4l2_rect* rect)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nu8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 104,\r\nv_start = (u8)(rect->top - s->cropcap.bounds.top) + 12;\r\nint err = 0;\r\nerr += sn9c102_write_reg(cam, h_start, 0x12);\r\nerr += sn9c102_write_reg(cam, v_start, 0x13);\r\nerr += sn9c102_write_reg(cam, 0x1f, 0x1a);\r\nerr += sn9c102_write_reg(cam, 0x1a, 0x1b);\r\nerr += sn9c102_write_reg(cam, sn9c102_pread_reg(cam, 0x19), 0x19);\r\nreturn err;\r\n}\r\nstatic int tas5130d1b_set_pix_format(struct sn9c102_device* cam,\r\nconst struct v4l2_pix_format* pix)\r\n{\r\nint err = 0;\r\nif (pix->pixelformat == V4L2_PIX_FMT_SN9C10X)\r\nerr += sn9c102_write_reg(cam, 0x63, 0x19);\r\nelse\r\nerr += sn9c102_write_reg(cam, 0xf3, 0x19);\r\nreturn err;\r\n}\r\nint sn9c102_probe_tas5130d1b(struct sn9c102_device* cam)\r\n{\r\nconst struct usb_device_id tas5130d1b_id_table[] = {\r\n{ USB_DEVICE(0x0c45, 0x6024), },\r\n{ USB_DEVICE(0x0c45, 0x6025), },\r\n{ USB_DEVICE(0x0c45, 0x60aa), },\r\n{ }\r\n};\r\nif (!sn9c102_match_id(cam, tas5130d1b_id_table))\r\nreturn -ENODEV;\r\nsn9c102_attach_sensor(cam, &tas5130d1b);\r\nreturn 0;\r\n}
