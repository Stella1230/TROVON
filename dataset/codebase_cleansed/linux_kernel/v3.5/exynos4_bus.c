static int exynos4210_set_busclk(struct busfreq_data *data, struct opp *opp)\r\n{\r\nunsigned int index;\r\nunsigned int tmp;\r\nfor (index = LV_0; index < EX4210_LV_NUM; index++)\r\nif (opp_get_freq(opp) == exynos4210_busclk_table[index].clk)\r\nbreak;\r\nif (index == EX4210_LV_NUM)\r\nreturn -EINVAL;\r\ntmp = data->dmc_divtable[index];\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_DMC0);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_DMC0);\r\n} while (tmp & 0x11111111);\r\ntmp = data->top_divtable[index];\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_TOP);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_TOP);\r\n} while (tmp & 0x11111);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_LEFTBUS);\r\ntmp &= ~(EXYNOS4_CLKDIV_BUS_GDLR_MASK | EXYNOS4_CLKDIV_BUS_GPLR_MASK);\r\ntmp |= ((exynos4210_clkdiv_lr_bus[index][0] <<\r\nEXYNOS4_CLKDIV_BUS_GDLR_SHIFT) |\r\n(exynos4210_clkdiv_lr_bus[index][1] <<\r\nEXYNOS4_CLKDIV_BUS_GPLR_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_LEFTBUS);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_LEFTBUS);\r\n} while (tmp & 0x11);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_RIGHTBUS);\r\ntmp &= ~(EXYNOS4_CLKDIV_BUS_GDLR_MASK | EXYNOS4_CLKDIV_BUS_GPLR_MASK);\r\ntmp |= ((exynos4210_clkdiv_lr_bus[index][0] <<\r\nEXYNOS4_CLKDIV_BUS_GDLR_SHIFT) |\r\n(exynos4210_clkdiv_lr_bus[index][1] <<\r\nEXYNOS4_CLKDIV_BUS_GPLR_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_RIGHTBUS);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_RIGHTBUS);\r\n} while (tmp & 0x11);\r\nreturn 0;\r\n}\r\nstatic int exynos4x12_set_busclk(struct busfreq_data *data, struct opp *opp)\r\n{\r\nunsigned int index;\r\nunsigned int tmp;\r\nfor (index = LV_0; index < EX4x12_LV_NUM; index++)\r\nif (opp_get_freq(opp) == exynos4x12_mifclk_table[index].clk)\r\nbreak;\r\nif (index == EX4x12_LV_NUM)\r\nreturn -EINVAL;\r\ntmp = data->dmc_divtable[index];\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_DMC0);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_DMC0);\r\n} while (tmp & 0x11111111);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_DMC1);\r\ntmp &= ~(EXYNOS4_CLKDIV_DMC1_G2D_ACP_MASK |\r\nEXYNOS4_CLKDIV_DMC1_C2C_MASK |\r\nEXYNOS4_CLKDIV_DMC1_C2CACLK_MASK);\r\ntmp |= ((exynos4x12_clkdiv_dmc1[index][0] <<\r\nEXYNOS4_CLKDIV_DMC1_G2D_ACP_SHIFT) |\r\n(exynos4x12_clkdiv_dmc1[index][1] <<\r\nEXYNOS4_CLKDIV_DMC1_C2C_SHIFT) |\r\n(exynos4x12_clkdiv_dmc1[index][2] <<\r\nEXYNOS4_CLKDIV_DMC1_C2CACLK_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_DMC1);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_DMC1);\r\n} while (tmp & 0x111111);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_TOP);\r\ntmp &= ~(EXYNOS4_CLKDIV_TOP_ACLK266_GPS_MASK |\r\nEXYNOS4_CLKDIV_TOP_ACLK100_MASK |\r\nEXYNOS4_CLKDIV_TOP_ACLK160_MASK |\r\nEXYNOS4_CLKDIV_TOP_ACLK133_MASK |\r\nEXYNOS4_CLKDIV_TOP_ONENAND_MASK);\r\ntmp |= ((exynos4x12_clkdiv_top[index][0] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK266_GPS_SHIFT) |\r\n(exynos4x12_clkdiv_top[index][1] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK100_SHIFT) |\r\n(exynos4x12_clkdiv_top[index][2] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK160_SHIFT) |\r\n(exynos4x12_clkdiv_top[index][3] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK133_SHIFT) |\r\n(exynos4x12_clkdiv_top[index][4] <<\r\nEXYNOS4_CLKDIV_TOP_ONENAND_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_TOP);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_TOP);\r\n} while (tmp & 0x11111);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_LEFTBUS);\r\ntmp &= ~(EXYNOS4_CLKDIV_BUS_GDLR_MASK | EXYNOS4_CLKDIV_BUS_GPLR_MASK);\r\ntmp |= ((exynos4x12_clkdiv_lr_bus[index][0] <<\r\nEXYNOS4_CLKDIV_BUS_GDLR_SHIFT) |\r\n(exynos4x12_clkdiv_lr_bus[index][1] <<\r\nEXYNOS4_CLKDIV_BUS_GPLR_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_LEFTBUS);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_LEFTBUS);\r\n} while (tmp & 0x11);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_RIGHTBUS);\r\ntmp &= ~(EXYNOS4_CLKDIV_BUS_GDLR_MASK | EXYNOS4_CLKDIV_BUS_GPLR_MASK);\r\ntmp |= ((exynos4x12_clkdiv_lr_bus[index][0] <<\r\nEXYNOS4_CLKDIV_BUS_GDLR_SHIFT) |\r\n(exynos4x12_clkdiv_lr_bus[index][1] <<\r\nEXYNOS4_CLKDIV_BUS_GPLR_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_RIGHTBUS);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_RIGHTBUS);\r\n} while (tmp & 0x11);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_MFC);\r\ntmp &= ~(EXYNOS4_CLKDIV_MFC_MASK);\r\ntmp |= ((exynos4x12_clkdiv_sclkip[index][0] <<\r\nEXYNOS4_CLKDIV_MFC_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_MFC);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_MFC);\r\n} while (tmp & 0x1);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_CAM1);\r\ntmp &= ~(EXYNOS4_CLKDIV_CAM1_JPEG_MASK);\r\ntmp |= ((exynos4x12_clkdiv_sclkip[index][1] <<\r\nEXYNOS4_CLKDIV_CAM1_JPEG_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_CAM1);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_CAM1);\r\n} while (tmp & 0x1);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_CAM);\r\ntmp &= ~(EXYNOS4_CLKDIV_CAM_FIMC0_MASK | EXYNOS4_CLKDIV_CAM_FIMC1_MASK |\r\nEXYNOS4_CLKDIV_CAM_FIMC2_MASK | EXYNOS4_CLKDIV_CAM_FIMC3_MASK);\r\ntmp |= ((exynos4x12_clkdiv_sclkip[index][2] <<\r\nEXYNOS4_CLKDIV_CAM_FIMC0_SHIFT) |\r\n(exynos4x12_clkdiv_sclkip[index][2] <<\r\nEXYNOS4_CLKDIV_CAM_FIMC1_SHIFT) |\r\n(exynos4x12_clkdiv_sclkip[index][2] <<\r\nEXYNOS4_CLKDIV_CAM_FIMC2_SHIFT) |\r\n(exynos4x12_clkdiv_sclkip[index][2] <<\r\nEXYNOS4_CLKDIV_CAM_FIMC3_SHIFT));\r\n__raw_writel(tmp, EXYNOS4_CLKDIV_CAM);\r\ndo {\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_STAT_CAM1);\r\n} while (tmp & 0x1111);\r\nreturn 0;\r\n}\r\nstatic void busfreq_mon_reset(struct busfreq_data *data)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < 2; i++) {\r\nvoid __iomem *ppmu_base = data->dmc[i].hw_base;\r\n__raw_writel(0x8000000f, ppmu_base + 0xf010);\r\n__raw_writel(0x8000000f, ppmu_base + 0xf050);\r\n__raw_writel(0x6, ppmu_base + 0xf000);\r\n__raw_writel(0x0, ppmu_base + 0xf100);\r\ndata->dmc[i].event = 0x6;\r\n__raw_writel(((data->dmc[i].event << 12) | 0x1),\r\nppmu_base + 0xfc);\r\n__raw_writel(0x1, ppmu_base + 0xf000);\r\n}\r\n}\r\nstatic void exynos4_read_ppmu(struct busfreq_data *data)\r\n{\r\nint i, j;\r\nfor (i = 0; i < 2; i++) {\r\nvoid __iomem *ppmu_base = data->dmc[i].hw_base;\r\nu32 overflow;\r\n__raw_writel(0x0, ppmu_base + 0xf000);\r\noverflow = __raw_readl(ppmu_base + 0xf050);\r\ndata->dmc[i].ccnt = __raw_readl(ppmu_base + 0xf100);\r\ndata->dmc[i].ccnt_overflow = overflow & (1 << 31);\r\nfor (j = 0; j < PPMU_PMNCNT_MAX; j++) {\r\ndata->dmc[i].count[j] = __raw_readl(\r\nppmu_base + (0xf110 + (0x10 * j)));\r\ndata->dmc[i].count_overflow[j] = overflow & (1 << j);\r\n}\r\n}\r\nbusfreq_mon_reset(data);\r\n}\r\nstatic int exynos4x12_get_intspec(unsigned long mifclk)\r\n{\r\nint i = 0;\r\nwhile (exynos4x12_intclk_table[i].clk) {\r\nif (exynos4x12_intclk_table[i].clk <= mifclk)\r\nreturn i;\r\ni++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int exynos4_bus_setvolt(struct busfreq_data *data, struct opp *opp,\r\nstruct opp *oldopp)\r\n{\r\nint err = 0, tmp;\r\nunsigned long volt = opp_get_voltage(opp);\r\nswitch (data->type) {\r\ncase TYPE_BUSF_EXYNOS4210:\r\nerr = regulator_set_voltage(data->vdd_int, volt,\r\nMAX_SAFEVOLT);\r\nbreak;\r\ncase TYPE_BUSF_EXYNOS4x12:\r\nerr = regulator_set_voltage(data->vdd_mif, volt,\r\nMAX_SAFEVOLT);\r\nif (err)\r\nbreak;\r\ntmp = exynos4x12_get_intspec(opp_get_freq(opp));\r\nif (tmp < 0) {\r\nerr = tmp;\r\nregulator_set_voltage(data->vdd_mif,\r\nopp_get_voltage(oldopp),\r\nMAX_SAFEVOLT);\r\nbreak;\r\n}\r\nerr = regulator_set_voltage(data->vdd_int,\r\nexynos4x12_intclk_table[tmp].volt,\r\nMAX_SAFEVOLT);\r\nif (err)\r\nregulator_set_voltage(data->vdd_mif,\r\nopp_get_voltage(oldopp),\r\nMAX_SAFEVOLT);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int exynos4_bus_target(struct device *dev, unsigned long *_freq,\r\nu32 flags)\r\n{\r\nint err = 0;\r\nstruct platform_device *pdev = container_of(dev, struct platform_device,\r\ndev);\r\nstruct busfreq_data *data = platform_get_drvdata(pdev);\r\nstruct opp *opp = devfreq_recommended_opp(dev, _freq, flags);\r\nunsigned long freq = opp_get_freq(opp);\r\nunsigned long old_freq = opp_get_freq(data->curr_opp);\r\nif (IS_ERR(opp))\r\nreturn PTR_ERR(opp);\r\nif (old_freq == freq)\r\nreturn 0;\r\ndev_dbg(dev, "targetting %lukHz %luuV\n", freq, opp_get_voltage(opp));\r\nmutex_lock(&data->lock);\r\nif (data->disabled)\r\ngoto out;\r\nif (old_freq < freq)\r\nerr = exynos4_bus_setvolt(data, opp, data->curr_opp);\r\nif (err)\r\ngoto out;\r\nif (old_freq != freq) {\r\nswitch (data->type) {\r\ncase TYPE_BUSF_EXYNOS4210:\r\nerr = exynos4210_set_busclk(data, opp);\r\nbreak;\r\ncase TYPE_BUSF_EXYNOS4x12:\r\nerr = exynos4x12_set_busclk(data, opp);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nif (old_freq > freq)\r\nerr = exynos4_bus_setvolt(data, opp, data->curr_opp);\r\nif (err)\r\ngoto out;\r\ndata->curr_opp = opp;\r\nout:\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int exynos4_get_busier_dmc(struct busfreq_data *data)\r\n{\r\nu64 p0 = data->dmc[0].count[0];\r\nu64 p1 = data->dmc[1].count[0];\r\np0 *= data->dmc[1].ccnt;\r\np1 *= data->dmc[0].ccnt;\r\nif (data->dmc[1].ccnt == 0)\r\nreturn 0;\r\nif (p0 > p1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int exynos4_bus_get_dev_status(struct device *dev,\r\nstruct devfreq_dev_status *stat)\r\n{\r\nstruct busfreq_data *data = dev_get_drvdata(dev);\r\nint busier_dmc;\r\nint cycles_x2 = 2;\r\nvoid __iomem *addr;\r\nu32 timing;\r\nu32 memctrl;\r\nexynos4_read_ppmu(data);\r\nbusier_dmc = exynos4_get_busier_dmc(data);\r\nstat->current_frequency = opp_get_freq(data->curr_opp);\r\nif (busier_dmc)\r\naddr = S5P_VA_DMC1;\r\nelse\r\naddr = S5P_VA_DMC0;\r\nmemctrl = __raw_readl(addr + 0x04);\r\ntiming = __raw_readl(addr + 0x38);\r\nswitch ((memctrl >> 8) & 0xf) {\r\ncase 0x4:\r\ncycles_x2 = ((timing >> 16) & 0xf) * 2;\r\nbreak;\r\ncase 0x5:\r\ncase 0x6:\r\ncycles_x2 = ((timing >> 8) & 0xf) + ((timing >> 0) & 0xf);\r\nbreak;\r\ndefault:\r\npr_err("%s: Unknown Memory Type(%d).\n", __func__,\r\n(memctrl >> 8) & 0xf);\r\nreturn -EINVAL;\r\n}\r\nstat->busy_time = data->dmc[busier_dmc].count[0] / 2 * (cycles_x2 + 2);\r\nstat->busy_time *= 100 / BUS_SATURATION_RATIO;\r\nstat->total_time = data->dmc[busier_dmc].ccnt;\r\nif (data->dmc[busier_dmc].ccnt_overflow ||\r\ndata->dmc[busier_dmc].count_overflow[0])\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic void exynos4_bus_exit(struct device *dev)\r\n{\r\nstruct busfreq_data *data = dev_get_drvdata(dev);\r\ndevfreq_unregister_opp_notifier(dev, data->devfreq);\r\n}\r\nstatic int exynos4210_init_tables(struct busfreq_data *data)\r\n{\r\nu32 tmp;\r\nint mgrp;\r\nint i, err = 0;\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_DMC0);\r\nfor (i = LV_0; i < EX4210_LV_NUM; i++) {\r\ntmp &= ~(EXYNOS4_CLKDIV_DMC0_ACP_MASK |\r\nEXYNOS4_CLKDIV_DMC0_ACPPCLK_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DPHY_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DMC_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DMCD_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DMCP_MASK |\r\nEXYNOS4_CLKDIV_DMC0_COPY2_MASK |\r\nEXYNOS4_CLKDIV_DMC0_CORETI_MASK);\r\ntmp |= ((exynos4210_clkdiv_dmc0[i][0] <<\r\nEXYNOS4_CLKDIV_DMC0_ACP_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][1] <<\r\nEXYNOS4_CLKDIV_DMC0_ACPPCLK_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][2] <<\r\nEXYNOS4_CLKDIV_DMC0_DPHY_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][3] <<\r\nEXYNOS4_CLKDIV_DMC0_DMC_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][4] <<\r\nEXYNOS4_CLKDIV_DMC0_DMCD_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][5] <<\r\nEXYNOS4_CLKDIV_DMC0_DMCP_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][6] <<\r\nEXYNOS4_CLKDIV_DMC0_COPY2_SHIFT) |\r\n(exynos4210_clkdiv_dmc0[i][7] <<\r\nEXYNOS4_CLKDIV_DMC0_CORETI_SHIFT));\r\ndata->dmc_divtable[i] = tmp;\r\n}\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_TOP);\r\nfor (i = LV_0; i < EX4210_LV_NUM; i++) {\r\ntmp &= ~(EXYNOS4_CLKDIV_TOP_ACLK200_MASK |\r\nEXYNOS4_CLKDIV_TOP_ACLK100_MASK |\r\nEXYNOS4_CLKDIV_TOP_ACLK160_MASK |\r\nEXYNOS4_CLKDIV_TOP_ACLK133_MASK |\r\nEXYNOS4_CLKDIV_TOP_ONENAND_MASK);\r\ntmp |= ((exynos4210_clkdiv_top[i][0] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK200_SHIFT) |\r\n(exynos4210_clkdiv_top[i][1] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK100_SHIFT) |\r\n(exynos4210_clkdiv_top[i][2] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK160_SHIFT) |\r\n(exynos4210_clkdiv_top[i][3] <<\r\nEXYNOS4_CLKDIV_TOP_ACLK133_SHIFT) |\r\n(exynos4210_clkdiv_top[i][4] <<\r\nEXYNOS4_CLKDIV_TOP_ONENAND_SHIFT));\r\ndata->top_divtable[i] = tmp;\r\n}\r\n#ifdef CONFIG_EXYNOS_ASV\r\ntmp = exynos4_result_of_asv;\r\n#else\r\ntmp = 0;\r\n#endif\r\npr_debug("ASV Group of Exynos4 is %d\n", tmp);\r\nswitch (tmp) {\r\ncase 0:\r\nmgrp = 0;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nmgrp = 1;\r\nbreak;\r\ncase 3:\r\ncase 4:\r\nmgrp = 2;\r\nbreak;\r\ncase 5:\r\ncase 6:\r\nmgrp = 3;\r\nbreak;\r\ncase 7:\r\nmgrp = 4;\r\nbreak;\r\ndefault:\r\npr_warn("Unknown ASV Group. Use max voltage.\n");\r\nmgrp = 0;\r\n}\r\nfor (i = LV_0; i < EX4210_LV_NUM; i++)\r\nexynos4210_busclk_table[i].volt = exynos4210_asv_volt[mgrp][i];\r\nfor (i = LV_0; i < EX4210_LV_NUM; i++) {\r\nerr = opp_add(data->dev, exynos4210_busclk_table[i].clk,\r\nexynos4210_busclk_table[i].volt);\r\nif (err) {\r\ndev_err(data->dev, "Cannot add opp entries.\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos4x12_init_tables(struct busfreq_data *data)\r\n{\r\nunsigned int i;\r\nunsigned int tmp;\r\nint ret;\r\ntmp = __raw_readl(EXYNOS4_DMC_PAUSE_CTRL);\r\ntmp |= EXYNOS4_DMC_PAUSE_ENABLE;\r\n__raw_writel(tmp, EXYNOS4_DMC_PAUSE_CTRL);\r\ntmp = __raw_readl(EXYNOS4_CLKDIV_DMC0);\r\nfor (i = 0; i < EX4x12_LV_NUM; i++) {\r\ntmp &= ~(EXYNOS4_CLKDIV_DMC0_ACP_MASK |\r\nEXYNOS4_CLKDIV_DMC0_ACPPCLK_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DPHY_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DMC_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DMCD_MASK |\r\nEXYNOS4_CLKDIV_DMC0_DMCP_MASK);\r\ntmp |= ((exynos4x12_clkdiv_dmc0[i][0] <<\r\nEXYNOS4_CLKDIV_DMC0_ACP_SHIFT) |\r\n(exynos4x12_clkdiv_dmc0[i][1] <<\r\nEXYNOS4_CLKDIV_DMC0_ACPPCLK_SHIFT) |\r\n(exynos4x12_clkdiv_dmc0[i][2] <<\r\nEXYNOS4_CLKDIV_DMC0_DPHY_SHIFT) |\r\n(exynos4x12_clkdiv_dmc0[i][3] <<\r\nEXYNOS4_CLKDIV_DMC0_DMC_SHIFT) |\r\n(exynos4x12_clkdiv_dmc0[i][4] <<\r\nEXYNOS4_CLKDIV_DMC0_DMCD_SHIFT) |\r\n(exynos4x12_clkdiv_dmc0[i][5] <<\r\nEXYNOS4_CLKDIV_DMC0_DMCP_SHIFT));\r\ndata->dmc_divtable[i] = tmp;\r\n}\r\n#ifdef CONFIG_EXYNOS_ASV\r\ntmp = exynos4_result_of_asv;\r\n#else\r\ntmp = 0;\r\n#endif\r\nif (tmp > 8)\r\ntmp = 0;\r\npr_debug("ASV Group of Exynos4x12 is %d\n", tmp);\r\nfor (i = 0; i < EX4x12_LV_NUM; i++) {\r\nexynos4x12_mifclk_table[i].volt =\r\nexynos4x12_mif_step_50[tmp][i];\r\nexynos4x12_intclk_table[i].volt =\r\nexynos4x12_int_volt[tmp][i];\r\n}\r\nfor (i = 0; i < EX4x12_LV_NUM; i++) {\r\nret = opp_add(data->dev, exynos4x12_mifclk_table[i].clk,\r\nexynos4x12_mifclk_table[i].volt);\r\nif (ret) {\r\ndev_err(data->dev, "Fail to add opp entries.\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos4_busfreq_pm_notifier_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct busfreq_data *data = container_of(this, struct busfreq_data,\r\npm_notifier);\r\nstruct opp *opp;\r\nunsigned long maxfreq = ULONG_MAX;\r\nint err = 0;\r\nswitch (event) {\r\ncase PM_SUSPEND_PREPARE:\r\nmutex_lock(&data->lock);\r\ndata->disabled = true;\r\nopp = opp_find_freq_floor(data->dev, &maxfreq);\r\nerr = exynos4_bus_setvolt(data, opp, data->curr_opp);\r\nif (err)\r\ngoto unlock;\r\nswitch (data->type) {\r\ncase TYPE_BUSF_EXYNOS4210:\r\nerr = exynos4210_set_busclk(data, opp);\r\nbreak;\r\ncase TYPE_BUSF_EXYNOS4x12:\r\nerr = exynos4x12_set_busclk(data, opp);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (err)\r\ngoto unlock;\r\ndata->curr_opp = opp;\r\nunlock:\r\nmutex_unlock(&data->lock);\r\nif (err)\r\nreturn err;\r\nreturn NOTIFY_OK;\r\ncase PM_POST_RESTORE:\r\ncase PM_POST_SUSPEND:\r\nmutex_lock(&data->lock);\r\ndata->disabled = false;\r\nmutex_unlock(&data->lock);\r\nreturn NOTIFY_OK;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __devinit int exynos4_busfreq_probe(struct platform_device *pdev)\r\n{\r\nstruct busfreq_data *data;\r\nstruct opp *opp;\r\nstruct device *dev = &pdev->dev;\r\nint err = 0;\r\ndata = kzalloc(sizeof(struct busfreq_data), GFP_KERNEL);\r\nif (data == NULL) {\r\ndev_err(dev, "Cannot allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->type = pdev->id_entry->driver_data;\r\ndata->dmc[0].hw_base = S5P_VA_DMC0;\r\ndata->dmc[1].hw_base = S5P_VA_DMC1;\r\ndata->pm_notifier.notifier_call = exynos4_busfreq_pm_notifier_event;\r\ndata->dev = dev;\r\nmutex_init(&data->lock);\r\nswitch (data->type) {\r\ncase TYPE_BUSF_EXYNOS4210:\r\nerr = exynos4210_init_tables(data);\r\nbreak;\r\ncase TYPE_BUSF_EXYNOS4x12:\r\nerr = exynos4x12_init_tables(data);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Cannot determine the device id %d\n", data->type);\r\nerr = -EINVAL;\r\n}\r\nif (err)\r\ngoto err_regulator;\r\ndata->vdd_int = regulator_get(dev, "vdd_int");\r\nif (IS_ERR(data->vdd_int)) {\r\ndev_err(dev, "Cannot get the regulator \"vdd_int\"\n");\r\nerr = PTR_ERR(data->vdd_int);\r\ngoto err_regulator;\r\n}\r\nif (data->type == TYPE_BUSF_EXYNOS4x12) {\r\ndata->vdd_mif = regulator_get(dev, "vdd_mif");\r\nif (IS_ERR(data->vdd_mif)) {\r\ndev_err(dev, "Cannot get the regulator \"vdd_mif\"\n");\r\nerr = PTR_ERR(data->vdd_mif);\r\nregulator_put(data->vdd_int);\r\ngoto err_regulator;\r\n}\r\n}\r\nopp = opp_find_freq_floor(dev, &exynos4_devfreq_profile.initial_freq);\r\nif (IS_ERR(opp)) {\r\ndev_err(dev, "Invalid initial frequency %lu kHz.\n",\r\nexynos4_devfreq_profile.initial_freq);\r\nerr = PTR_ERR(opp);\r\ngoto err_opp_add;\r\n}\r\ndata->curr_opp = opp;\r\nplatform_set_drvdata(pdev, data);\r\nbusfreq_mon_reset(data);\r\ndata->devfreq = devfreq_add_device(dev, &exynos4_devfreq_profile,\r\n&devfreq_simple_ondemand, NULL);\r\nif (IS_ERR(data->devfreq)) {\r\nerr = PTR_ERR(data->devfreq);\r\ngoto err_opp_add;\r\n}\r\ndevfreq_register_opp_notifier(dev, data->devfreq);\r\nerr = register_pm_notifier(&data->pm_notifier);\r\nif (err) {\r\ndev_err(dev, "Failed to setup pm notifier\n");\r\ngoto err_devfreq_add;\r\n}\r\nreturn 0;\r\nerr_devfreq_add:\r\ndevfreq_remove_device(data->devfreq);\r\nerr_opp_add:\r\nif (data->vdd_mif)\r\nregulator_put(data->vdd_mif);\r\nregulator_put(data->vdd_int);\r\nerr_regulator:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic __devexit int exynos4_busfreq_remove(struct platform_device *pdev)\r\n{\r\nstruct busfreq_data *data = platform_get_drvdata(pdev);\r\nunregister_pm_notifier(&data->pm_notifier);\r\ndevfreq_remove_device(data->devfreq);\r\nregulator_put(data->vdd_int);\r\nif (data->vdd_mif)\r\nregulator_put(data->vdd_mif);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int exynos4_busfreq_resume(struct device *dev)\r\n{\r\nstruct busfreq_data *data = dev_get_drvdata(dev);\r\nbusfreq_mon_reset(data);\r\nreturn 0;\r\n}\r\nstatic int __init exynos4_busfreq_init(void)\r\n{\r\nreturn platform_driver_register(&exynos4_busfreq_driver);\r\n}\r\nstatic void __exit exynos4_busfreq_exit(void)\r\n{\r\nplatform_driver_unregister(&exynos4_busfreq_driver);\r\n}
