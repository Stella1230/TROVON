static void dispc_isr(void *arg, uint32_t mask)\r\n{\r\nstruct drm_plane *plane = arg;\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nomap_dispc_unregister_isr(dispc_isr, plane,\r\nid2irq[omap_plane->ovl->id]);\r\nqueue_work(priv->wq, &omap_plane->work);\r\n}\r\nstatic void unpin_worker(struct work_struct *work)\r\n{\r\nstruct omap_plane *omap_plane =\r\ncontainer_of(work, struct omap_plane, work);\r\nstruct callback endwin;\r\nmutex_lock(&omap_plane->unpin_mutex);\r\nDBG("unpinning %d of %d", omap_plane->num_unpins,\r\nomap_plane->num_unpins + omap_plane->pending_num_unpins);\r\nwhile (omap_plane->num_unpins > 0) {\r\nstruct drm_gem_object *bo = NULL;\r\nint ret = kfifo_get(&omap_plane->unpin_fifo, &bo);\r\nWARN_ON(!ret);\r\nomap_gem_put_paddr(bo);\r\ndrm_gem_object_unreference_unlocked(bo);\r\nomap_plane->num_unpins--;\r\n}\r\nendwin = omap_plane->endwin;\r\nomap_plane->endwin.fxn = NULL;\r\nmutex_unlock(&omap_plane->unpin_mutex);\r\nif (endwin.fxn)\r\nendwin.fxn(endwin.arg);\r\n}\r\nstatic void install_irq(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_overlay *ovl = omap_plane->ovl;\r\nint ret;\r\nret = omap_dispc_register_isr(dispc_isr, plane, id2irq[ovl->id]);\r\nWARN_ON(ret == -EBUSY);\r\n}\r\nstatic int commit(struct drm_plane *plane)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_overlay *ovl = omap_plane->ovl;\r\nstruct omap_overlay_info *info = &omap_plane->info;\r\nint ret;\r\nDBG("%s", ovl->name);\r\nDBG("%dx%d -> %dx%d (%d)", info->width, info->height, info->out_width,\r\ninfo->out_height, info->screen_width);\r\nDBG("%d,%d %08x %08x", info->pos_x, info->pos_y,\r\ninfo->paddr, info->p_uv_addr);\r\nret = ovl->set_overlay_info(ovl, info);\r\nif (ret) {\r\ndev_err(dev->dev, "could not set overlay info\n");\r\nreturn ret;\r\n}\r\nmutex_lock(&omap_plane->unpin_mutex);\r\nomap_plane->num_unpins += omap_plane->pending_num_unpins;\r\nomap_plane->pending_num_unpins = 0;\r\nmutex_unlock(&omap_plane->unpin_mutex);\r\nif (ovl->manager) {\r\nret = ovl->manager->apply(ovl->manager);\r\nif (ret) {\r\ndev_err(dev->dev, "could not apply settings\n");\r\nreturn ret;\r\n}\r\nif (omap_plane->num_unpins > 0)\r\ninstall_irq(plane);\r\n} else {\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nqueue_work(priv->wq, &omap_plane->work);\r\n}\r\nif (ovl->is_enabled(ovl)) {\r\nomap_framebuffer_flush(plane->fb, info->pos_x, info->pos_y,\r\ninfo->out_width, info->out_height);\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_manager(struct drm_plane *plane)\r\n{\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_overlay *ovl = omap_plane->ovl;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nint i;\r\nif (plane->crtc) {\r\nfor (i = 0; i < priv->num_encoders; i++) {\r\nstruct drm_encoder *encoder = priv->encoders[i];\r\nif (encoder->crtc == plane->crtc) {\r\nmgr = omap_encoder_get_manager(encoder);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (ovl->manager != mgr) {\r\nbool enabled = ovl->is_enabled(ovl);\r\nif (enabled)\r\nomap_plane_dpms(plane, DRM_MODE_DPMS_OFF);\r\nif (ovl->manager) {\r\nDBG("disconnecting %s from %s", ovl->name,\r\novl->manager->name);\r\novl->unset_manager(ovl);\r\n}\r\nif (mgr) {\r\nDBG("connecting %s to %s", ovl->name, mgr->name);\r\novl->set_manager(ovl, mgr);\r\n}\r\nif (enabled && mgr)\r\nomap_plane_dpms(plane, DRM_MODE_DPMS_ON);\r\n}\r\n}\r\nstatic void unpin(void *arg, struct drm_gem_object *bo)\r\n{\r\nstruct drm_plane *plane = arg;\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nif (kfifo_put(&omap_plane->unpin_fifo,\r\n(const struct drm_gem_object **)&bo)) {\r\nomap_plane->pending_num_unpins++;\r\ndrm_gem_object_reference(bo);\r\n} else {\r\ndev_err(plane->dev->dev, "unpin fifo full!\n");\r\nomap_gem_put_paddr(bo);\r\n}\r\n}\r\nstatic int update_pin(struct drm_plane *plane, struct drm_framebuffer *fb)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;\r\nif (pinned_fb != fb) {\r\nint ret;\r\nDBG("%p -> %p", pinned_fb, fb);\r\nmutex_lock(&omap_plane->unpin_mutex);\r\nret = omap_framebuffer_replace(pinned_fb, fb, plane, unpin);\r\nmutex_unlock(&omap_plane->unpin_mutex);\r\nif (ret) {\r\ndev_err(plane->dev->dev, "could not swap %p -> %p\n",\r\nomap_plane->pinned_fb, fb);\r\nomap_plane->pinned_fb = NULL;\r\nreturn ret;\r\n}\r\nomap_plane->pinned_fb = fb;\r\n}\r\nreturn 0;\r\n}\r\nstatic void update_scanout(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_overlay_info *info = &omap_plane->info;\r\nint ret;\r\nret = update_pin(plane, plane->fb);\r\nif (ret) {\r\ndev_err(plane->dev->dev,\r\n"could not pin fb: %d\n", ret);\r\nomap_plane_dpms(plane, DRM_MODE_DPMS_OFF);\r\nreturn;\r\n}\r\nomap_framebuffer_update_scanout(plane->fb,\r\nomap_plane->src_x, omap_plane->src_y, info);\r\nDBG("%s: %d,%d: %08x %08x (%d)", omap_plane->ovl->name,\r\nomap_plane->src_x, omap_plane->src_y,\r\n(u32)info->paddr, (u32)info->p_uv_addr,\r\ninfo->screen_width);\r\n}\r\nint omap_plane_mode_set(struct drm_plane *plane,\r\nstruct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nsrc_x = src_x >> 16;\r\nsrc_y = src_y >> 16;\r\nsrc_w = src_w >> 16;\r\nsrc_h = src_h >> 16;\r\nomap_plane->info.pos_x = crtc_x;\r\nomap_plane->info.pos_y = crtc_y;\r\nomap_plane->info.out_width = crtc_w;\r\nomap_plane->info.out_height = crtc_h;\r\nomap_plane->info.width = src_w;\r\nomap_plane->info.height = src_h;\r\nomap_plane->src_x = src_x;\r\nomap_plane->src_y = src_y;\r\nplane->fb = fb;\r\nplane->crtc = crtc;\r\nupdate_scanout(plane);\r\nupdate_manager(plane);\r\nreturn 0;\r\n}\r\nstatic int omap_plane_update(struct drm_plane *plane,\r\nstruct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nomap_plane_mode_set(plane, crtc, fb, crtc_x, crtc_y, crtc_w, crtc_h,\r\nsrc_x, src_y, src_w, src_h);\r\nreturn omap_plane_dpms(plane, DRM_MODE_DPMS_ON);\r\n}\r\nstatic int omap_plane_disable(struct drm_plane *plane)\r\n{\r\nreturn omap_plane_dpms(plane, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void omap_plane_destroy(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nDBG("%s", omap_plane->ovl->name);\r\nomap_plane_disable(plane);\r\ndrm_plane_cleanup(plane);\r\nWARN_ON(omap_plane->pending_num_unpins + omap_plane->num_unpins > 0);\r\nkfifo_free(&omap_plane->unpin_fifo);\r\nkfree(omap_plane);\r\n}\r\nint omap_plane_dpms(struct drm_plane *plane, int mode)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_overlay *ovl = omap_plane->ovl;\r\nint r;\r\nDBG("%s: %d", omap_plane->ovl->name, mode);\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nupdate_scanout(plane);\r\nr = commit(plane);\r\nif (!r)\r\nr = ovl->enable(ovl);\r\n} else {\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nr = ovl->disable(ovl);\r\nupdate_pin(plane, NULL);\r\nqueue_work(priv->wq, &omap_plane->work);\r\n}\r\nreturn r;\r\n}\r\nvoid omap_plane_on_endwin(struct drm_plane *plane,\r\nvoid (*fxn)(void *), void *arg)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nmutex_lock(&omap_plane->unpin_mutex);\r\nomap_plane->endwin.fxn = fxn;\r\nomap_plane->endwin.arg = arg;\r\nmutex_unlock(&omap_plane->unpin_mutex);\r\ninstall_irq(plane);\r\n}\r\nstruct drm_plane *omap_plane_init(struct drm_device *dev,\r\nstruct omap_overlay *ovl, unsigned int possible_crtcs,\r\nbool priv)\r\n{\r\nstruct drm_plane *plane = NULL;\r\nstruct omap_plane *omap_plane;\r\nint ret;\r\nDBG("%s: possible_crtcs=%08x, priv=%d", ovl->name,\r\npossible_crtcs, priv);\r\nWARN_ON(ovl->id >= ARRAY_SIZE(id2irq));\r\nomap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);\r\nif (!omap_plane) {\r\ndev_err(dev->dev, "could not allocate plane\n");\r\ngoto fail;\r\n}\r\nmutex_init(&omap_plane->unpin_mutex);\r\nret = kfifo_alloc(&omap_plane->unpin_fifo, 16, GFP_KERNEL);\r\nif (ret) {\r\ndev_err(dev->dev, "could not allocate unpin FIFO\n");\r\ngoto fail;\r\n}\r\nINIT_WORK(&omap_plane->work, unpin_worker);\r\nomap_plane->nformats = omap_framebuffer_get_formats(\r\nomap_plane->formats, ARRAY_SIZE(omap_plane->formats),\r\novl->supported_modes);\r\nomap_plane->ovl = ovl;\r\nplane = &omap_plane->base;\r\ndrm_plane_init(dev, plane, possible_crtcs, &omap_plane_funcs,\r\nomap_plane->formats, omap_plane->nformats, priv);\r\novl->get_overlay_info(ovl, &omap_plane->info);\r\nomap_plane->info.rotation_type = OMAP_DSS_ROT_DMA;\r\nomap_plane->info.rotation = OMAP_DSS_ROT_0;\r\nomap_plane->info.global_alpha = 0xff;\r\nomap_plane->info.mirror = 0;\r\nomap_plane->info.mirror = 0;\r\nif (priv)\r\nomap_plane->info.zorder = 0;\r\nelse\r\nomap_plane->info.zorder = ovl->id;\r\nupdate_manager(plane);\r\nreturn plane;\r\nfail:\r\nif (plane) {\r\nomap_plane_destroy(plane);\r\n}\r\nreturn NULL;\r\n}
