static int mi0343_init(struct sn9c102_device* cam)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nint err = 0;\r\nerr = sn9c102_write_const_regs(cam, {0x00, 0x10}, {0x00, 0x11},\r\n{0x0a, 0x14}, {0x40, 0x01},\r\n{0x20, 0x17}, {0x07, 0x18},\r\n{0xa0, 0x19});\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x0d,\r\n0x00, 0x01, 0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x0d,\r\n0x00, 0x00, 0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x03,\r\n0x01, 0xe1, 0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x04,\r\n0x02, 0x81, 0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x05,\r\n0x00, 0x17, 0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x06,\r\n0x00, 0x11, 0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id, 0x62,\r\n0x04, 0x9a, 0, 0);\r\nreturn err;\r\n}\r\nstatic int mi0343_get_ctrl(struct sn9c102_device* cam,\r\nstruct v4l2_control* ctrl)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nu8 data[2];\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x09, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nctrl->value = data[0];\r\nreturn 0;\r\ncase V4L2_CID_GAIN:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x35, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x20, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nctrl->value = data[1] & 0x20 ? 1 : 0;\r\nreturn 0;\r\ncase V4L2_CID_VFLIP:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x20, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nctrl->value = data[1] & 0x80 ? 1 : 0;\r\nreturn 0;\r\ncase V4L2_CID_RED_BALANCE:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x2d, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x2c, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nbreak;\r\ncase SN9C102_V4L2_CID_GREEN_BALANCE:\r\nif (sn9c102_i2c_try_raw_read(cam, s, s->i2c_slave_id, 0x2e, 2,\r\ndata) < 0)\r\nreturn -EIO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\ncase V4L2_CID_RED_BALANCE:\r\ncase V4L2_CID_BLUE_BALANCE:\r\ncase SN9C102_V4L2_CID_GREEN_BALANCE:\r\nctrl->value = data[1] | (data[0] << 8);\r\nif (ctrl->value >= 0x10 && ctrl->value <= 0x3f)\r\nctrl->value -= 0x10;\r\nelse if (ctrl->value >= 0x60 && ctrl->value <= 0x7f)\r\nctrl->value -= 0x60;\r\nelse if (ctrl->value >= 0xe0 && ctrl->value <= 0xff)\r\nctrl->value -= 0xe0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mi0343_set_ctrl(struct sn9c102_device* cam,\r\nconst struct v4l2_control* ctrl)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nu16 reg = 0;\r\nint err = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\ncase V4L2_CID_RED_BALANCE:\r\ncase V4L2_CID_BLUE_BALANCE:\r\ncase SN9C102_V4L2_CID_GREEN_BALANCE:\r\nif (ctrl->value <= (0x3f-0x10))\r\nreg = 0x10 + ctrl->value;\r\nelse if (ctrl->value <= ((0x3f-0x10) + (0x7f-0x60)))\r\nreg = 0x60 + (ctrl->value - (0x3f-0x10));\r\nelse\r\nreg = 0xe0 + (ctrl->value - (0x3f-0x10) - (0x7f-0x60));\r\nbreak;\r\n}\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x09, ctrl->value, 0x00,\r\n0, 0);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x35, reg >> 8, reg & 0xff,\r\n0, 0);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x20, ctrl->value ? 0x40:0x00,\r\nctrl->value ? 0x20:0x00,\r\n0, 0);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x20, ctrl->value ? 0x80:0x00,\r\nctrl->value ? 0x80:0x00,\r\n0, 0);\r\nbreak;\r\ncase V4L2_CID_RED_BALANCE:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x2d, reg >> 8, reg & 0xff,\r\n0, 0);\r\nbreak;\r\ncase V4L2_CID_BLUE_BALANCE:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x2c, reg >> 8, reg & 0xff,\r\n0, 0);\r\nbreak;\r\ncase SN9C102_V4L2_CID_GREEN_BALANCE:\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x2b, reg >> 8, reg & 0xff,\r\n0, 0);\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x2e, reg >> 8, reg & 0xff,\r\n0, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int mi0343_set_crop(struct sn9c102_device* cam,\r\nconst struct v4l2_rect* rect)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nint err = 0;\r\nu8 h_start = (u8)(rect->left - s->cropcap.bounds.left) + 0,\r\nv_start = (u8)(rect->top - s->cropcap.bounds.top) + 2;\r\nerr += sn9c102_write_reg(cam, h_start, 0x12);\r\nerr += sn9c102_write_reg(cam, v_start, 0x13);\r\nreturn err;\r\n}\r\nstatic int mi0343_set_pix_format(struct sn9c102_device* cam,\r\nconst struct v4l2_pix_format* pix)\r\n{\r\nstruct sn9c102_sensor* s = sn9c102_get_sensor(cam);\r\nint err = 0;\r\nif (pix->pixelformat == V4L2_PIX_FMT_SN9C10X) {\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x0a, 0x00, 0x03, 0, 0);\r\nerr += sn9c102_write_reg(cam, 0x20, 0x19);\r\n} else {\r\nerr += sn9c102_i2c_try_raw_write(cam, s, 4, s->i2c_slave_id,\r\n0x0a, 0x00, 0x05, 0, 0);\r\nerr += sn9c102_write_reg(cam, 0xa0, 0x19);\r\n}\r\nreturn err;\r\n}\r\nint sn9c102_probe_mi0343(struct sn9c102_device* cam)\r\n{\r\nu8 data[2];\r\nif (sn9c102_write_const_regs(cam, {0x01, 0x01}, {0x00, 0x01},\r\n{0x28, 0x17}))\r\nreturn -EIO;\r\nif (sn9c102_i2c_try_raw_read(cam, &mi0343, mi0343.i2c_slave_id, 0x00,\r\n2, data) < 0)\r\nreturn -EIO;\r\nif (data[1] != 0x42 || data[0] != 0xe3)\r\nreturn -ENODEV;\r\nsn9c102_attach_sensor(cam, &mi0343);\r\nreturn 0;\r\n}
