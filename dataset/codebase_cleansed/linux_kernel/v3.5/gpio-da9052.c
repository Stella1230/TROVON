static inline struct da9052_gpio *to_da9052_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct da9052_gpio, gp);\r\n}\r\nstatic unsigned char da9052_gpio_port_odd(unsigned offset)\r\n{\r\nreturn offset % 2;\r\n}\r\nstatic int da9052_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct da9052_gpio *gpio = to_da9052_gpio(gc);\r\nint da9052_port_direction = 0;\r\nint ret;\r\nret = da9052_reg_read(gpio->da9052,\r\nDA9052_GPIO_0_1_REG + (offset >> 1));\r\nif (ret < 0)\r\nreturn ret;\r\nif (da9052_gpio_port_odd(offset)) {\r\nda9052_port_direction = ret & DA9052_GPIO_ODD_PORT_PIN;\r\nda9052_port_direction >>= 4;\r\n} else {\r\nda9052_port_direction = ret & DA9052_GPIO_EVEN_PORT_PIN;\r\n}\r\nswitch (da9052_port_direction) {\r\ncase DA9052_INPUT:\r\nif (offset < DA9052_GPIO_MAX_PORTS_PER_REGISTER)\r\nret = da9052_reg_read(gpio->da9052,\r\nDA9052_STATUS_C_REG);\r\nelse\r\nret = da9052_reg_read(gpio->da9052,\r\nDA9052_STATUS_D_REG);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & (1 << DA9052_GPIO_SHIFT_COUNT(offset)))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\ncase DA9052_OUTPUT_PUSHPULL:\r\nif (da9052_gpio_port_odd(offset))\r\nreturn ret & DA9052_GPIO_ODD_PORT_MODE;\r\nelse\r\nreturn ret & DA9052_GPIO_EVEN_PORT_MODE;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void da9052_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct da9052_gpio *gpio = to_da9052_gpio(gc);\r\nint ret;\r\nif (da9052_gpio_port_odd(offset)) {\r\nret = da9052_reg_update(gpio->da9052, (offset >> 1) +\r\nDA9052_GPIO_0_1_REG,\r\nDA9052_GPIO_ODD_PORT_MODE,\r\nvalue << DA9052_GPIO_ODD_SHIFT);\r\nif (ret != 0)\r\ndev_err(gpio->da9052->dev,\r\n"Failed to updated gpio odd reg,%d",\r\nret);\r\n} else {\r\nret = da9052_reg_update(gpio->da9052, (offset >> 1) +\r\nDA9052_GPIO_0_1_REG,\r\nDA9052_GPIO_EVEN_PORT_MODE,\r\nvalue << DA9052_GPIO_EVEN_SHIFT);\r\nif (ret != 0)\r\ndev_err(gpio->da9052->dev,\r\n"Failed to updated gpio even reg,%d",\r\nret);\r\n}\r\n}\r\nstatic int da9052_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct da9052_gpio *gpio = to_da9052_gpio(gc);\r\nunsigned char register_value;\r\nint ret;\r\nregister_value = DA9052_INPUT | DA9052_ACTIVE_LOW << 2 |\r\nDA9052_DEBOUNCING_ON << 3;\r\nif (da9052_gpio_port_odd(offset))\r\nret = da9052_reg_update(gpio->da9052, (offset >> 1) +\r\nDA9052_GPIO_0_1_REG,\r\nDA9052_GPIO_MASK_UPPER_NIBBLE,\r\n(register_value <<\r\nDA9052_GPIO_NIBBLE_SHIFT));\r\nelse\r\nret = da9052_reg_update(gpio->da9052, (offset >> 1) +\r\nDA9052_GPIO_0_1_REG,\r\nDA9052_GPIO_MASK_LOWER_NIBBLE,\r\nregister_value);\r\nreturn ret;\r\n}\r\nstatic int da9052_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int value)\r\n{\r\nstruct da9052_gpio *gpio = to_da9052_gpio(gc);\r\nunsigned char register_value;\r\nint ret;\r\nregister_value = DA9052_OUTPUT_PUSHPULL | DA9052_SUPPLY_VDD_IO1 << 2 |\r\nvalue << 3;\r\nif (da9052_gpio_port_odd(offset))\r\nret = da9052_reg_update(gpio->da9052, (offset >> 1) +\r\nDA9052_GPIO_0_1_REG,\r\nDA9052_GPIO_MASK_UPPER_NIBBLE,\r\n(register_value <<\r\nDA9052_GPIO_NIBBLE_SHIFT));\r\nelse\r\nret = da9052_reg_update(gpio->da9052, (offset >> 1) +\r\nDA9052_GPIO_0_1_REG,\r\nDA9052_GPIO_MASK_LOWER_NIBBLE,\r\nregister_value);\r\nreturn ret;\r\n}\r\nstatic int da9052_gpio_to_irq(struct gpio_chip *gc, u32 offset)\r\n{\r\nstruct da9052_gpio *gpio = to_da9052_gpio(gc);\r\nstruct da9052 *da9052 = gpio->da9052;\r\nreturn da9052->irq_base + DA9052_IRQ_GPI0 + offset;\r\n}\r\nstatic int __devinit da9052_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct da9052_gpio *gpio;\r\nstruct da9052_pdata *pdata;\r\nint ret;\r\ngpio = kzalloc(sizeof(*gpio), GFP_KERNEL);\r\nif (gpio == NULL)\r\nreturn -ENOMEM;\r\ngpio->da9052 = dev_get_drvdata(pdev->dev.parent);\r\npdata = gpio->da9052->dev->platform_data;\r\ngpio->gp = reference_gp;\r\nif (pdata && pdata->gpio_base)\r\ngpio->gp.base = pdata->gpio_base;\r\nret = gpiochip_add(&gpio->gp);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);\r\ngoto err_mem;\r\n}\r\nplatform_set_drvdata(pdev, gpio);\r\nreturn 0;\r\nerr_mem:\r\nkfree(gpio);\r\nreturn ret;\r\n}\r\nstatic int __devexit da9052_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct da9052_gpio *gpio = platform_get_drvdata(pdev);\r\nint ret;\r\nret = gpiochip_remove(&gpio->gp);\r\nif (ret == 0)\r\nkfree(gpio);\r\nreturn ret;\r\n}
