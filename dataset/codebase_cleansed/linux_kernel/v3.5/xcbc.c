static int crypto_xcbc_digest_setkey(struct crypto_shash *parent,\r\nconst u8 *inkey, unsigned int keylen)\r\n{\r\nunsigned long alignmask = crypto_shash_alignmask(parent);\r\nstruct xcbc_tfm_ctx *ctx = crypto_shash_ctx(parent);\r\nint bs = crypto_shash_blocksize(parent);\r\nu8 *consts = PTR_ALIGN(&ctx->ctx[0], alignmask + 1);\r\nint err = 0;\r\nu8 key1[bs];\r\nif ((err = crypto_cipher_setkey(ctx->child, inkey, keylen)))\r\nreturn err;\r\ncrypto_cipher_encrypt_one(ctx->child, consts, (u8 *)ks + bs);\r\ncrypto_cipher_encrypt_one(ctx->child, consts + bs, (u8 *)ks + bs * 2);\r\ncrypto_cipher_encrypt_one(ctx->child, key1, (u8 *)ks);\r\nreturn crypto_cipher_setkey(ctx->child, key1, bs);\r\n}\r\nstatic int crypto_xcbc_digest_init(struct shash_desc *pdesc)\r\n{\r\nunsigned long alignmask = crypto_shash_alignmask(pdesc->tfm);\r\nstruct xcbc_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nint bs = crypto_shash_blocksize(pdesc->tfm);\r\nu8 *prev = PTR_ALIGN(&ctx->ctx[0], alignmask + 1) + bs;\r\nctx->len = 0;\r\nmemset(prev, 0, bs);\r\nreturn 0;\r\n}\r\nstatic int crypto_xcbc_digest_update(struct shash_desc *pdesc, const u8 *p,\r\nunsigned int len)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nunsigned long alignmask = crypto_shash_alignmask(parent);\r\nstruct xcbc_tfm_ctx *tctx = crypto_shash_ctx(parent);\r\nstruct xcbc_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nstruct crypto_cipher *tfm = tctx->child;\r\nint bs = crypto_shash_blocksize(parent);\r\nu8 *odds = PTR_ALIGN(&ctx->ctx[0], alignmask + 1);\r\nu8 *prev = odds + bs;\r\nif ((ctx->len + len) <= bs) {\r\nmemcpy(odds + ctx->len, p, len);\r\nctx->len += len;\r\nreturn 0;\r\n}\r\nmemcpy(odds + ctx->len, p, bs - ctx->len);\r\nlen -= bs - ctx->len;\r\np += bs - ctx->len;\r\ncrypto_xor(prev, odds, bs);\r\ncrypto_cipher_encrypt_one(tfm, prev, prev);\r\nctx->len = 0;\r\nwhile (len > bs) {\r\ncrypto_xor(prev, p, bs);\r\ncrypto_cipher_encrypt_one(tfm, prev, prev);\r\np += bs;\r\nlen -= bs;\r\n}\r\nif (len) {\r\nmemcpy(odds, p, len);\r\nctx->len = len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_xcbc_digest_final(struct shash_desc *pdesc, u8 *out)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nunsigned long alignmask = crypto_shash_alignmask(parent);\r\nstruct xcbc_tfm_ctx *tctx = crypto_shash_ctx(parent);\r\nstruct xcbc_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nstruct crypto_cipher *tfm = tctx->child;\r\nint bs = crypto_shash_blocksize(parent);\r\nu8 *consts = PTR_ALIGN(&tctx->ctx[0], alignmask + 1);\r\nu8 *odds = PTR_ALIGN(&ctx->ctx[0], alignmask + 1);\r\nu8 *prev = odds + bs;\r\nunsigned int offset = 0;\r\nif (ctx->len != bs) {\r\nunsigned int rlen;\r\nu8 *p = odds + ctx->len;\r\n*p = 0x80;\r\np++;\r\nrlen = bs - ctx->len -1;\r\nif (rlen)\r\nmemset(p, 0, rlen);\r\noffset += bs;\r\n}\r\ncrypto_xor(prev, odds, bs);\r\ncrypto_xor(prev, consts + offset, bs);\r\ncrypto_cipher_encrypt_one(tfm, out, prev);\r\nreturn 0;\r\n}\r\nstatic int xcbc_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct xcbc_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void xcbc_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct xcbc_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic int xcbc_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct shash_instance *inst;\r\nstruct crypto_alg *alg;\r\nunsigned long alignmask;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\r\nif (err)\r\nreturn err;\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\nswitch(alg->cra_blocksize) {\r\ncase 16:\r\nbreak;\r\ndefault:\r\ngoto out_put_alg;\r\n}\r\ninst = shash_alloc_instance("xcbc", alg);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nerr = crypto_init_spawn(shash_instance_ctx(inst), alg,\r\nshash_crypto_instance(inst),\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto out_free_inst;\r\nalignmask = alg->cra_alignmask | 3;\r\ninst->alg.base.cra_alignmask = alignmask;\r\ninst->alg.base.cra_priority = alg->cra_priority;\r\ninst->alg.base.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.digestsize = alg->cra_blocksize;\r\ninst->alg.descsize = ALIGN(sizeof(struct xcbc_desc_ctx),\r\ncrypto_tfm_ctx_alignment()) +\r\n(alignmask &\r\n~(crypto_tfm_ctx_alignment() - 1)) +\r\nalg->cra_blocksize * 2;\r\ninst->alg.base.cra_ctxsize = ALIGN(sizeof(struct xcbc_tfm_ctx),\r\nalignmask + 1) +\r\nalg->cra_blocksize * 2;\r\ninst->alg.base.cra_init = xcbc_init_tfm;\r\ninst->alg.base.cra_exit = xcbc_exit_tfm;\r\ninst->alg.init = crypto_xcbc_digest_init;\r\ninst->alg.update = crypto_xcbc_digest_update;\r\ninst->alg.final = crypto_xcbc_digest_final;\r\ninst->alg.setkey = crypto_xcbc_digest_setkey;\r\nerr = shash_register_instance(tmpl, inst);\r\nif (err) {\r\nout_free_inst:\r\nshash_free_instance(shash_crypto_instance(inst));\r\n}\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int __init crypto_xcbc_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_xcbc_tmpl);\r\n}\r\nstatic void __exit crypto_xcbc_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_xcbc_tmpl);\r\n}
