static struct sctp_endpoint *sctp_endpoint_init(struct sctp_endpoint *ep,\r\nstruct sock *sk,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_hmac_algo_param *auth_hmacs = NULL;\r\nstruct sctp_chunks_param *auth_chunks = NULL;\r\nstruct sctp_shared_key *null_key;\r\nint err;\r\nep->digest = kzalloc(SCTP_SIGNATURE_SIZE, gfp);\r\nif (!ep->digest)\r\nreturn NULL;\r\nif (sctp_auth_enable) {\r\nauth_hmacs = kzalloc(sizeof(sctp_hmac_algo_param_t) +\r\nsizeof(__u16) * SCTP_AUTH_NUM_HMACS, gfp);\r\nif (!auth_hmacs)\r\ngoto nomem;\r\nauth_chunks = kzalloc(sizeof(sctp_chunks_param_t) +\r\nSCTP_NUM_CHUNK_TYPES, gfp);\r\nif (!auth_chunks)\r\ngoto nomem;\r\nauth_hmacs->param_hdr.type = SCTP_PARAM_HMAC_ALGO;\r\nauth_hmacs->param_hdr.length =\r\nhtons(sizeof(sctp_paramhdr_t) + 2);\r\nauth_hmacs->hmac_ids[0] = htons(SCTP_AUTH_HMAC_ID_SHA1);\r\nauth_chunks->param_hdr.type = SCTP_PARAM_CHUNKS;\r\nauth_chunks->param_hdr.length = htons(sizeof(sctp_paramhdr_t));\r\nif (sctp_addip_enable) {\r\nauth_chunks->chunks[0] = SCTP_CID_ASCONF;\r\nauth_chunks->chunks[1] = SCTP_CID_ASCONF_ACK;\r\nauth_chunks->param_hdr.length =\r\nhtons(sizeof(sctp_paramhdr_t) + 2);\r\n}\r\n}\r\nep->base.type = SCTP_EP_TYPE_SOCKET;\r\natomic_set(&ep->base.refcnt, 1);\r\nep->base.dead = 0;\r\nep->base.malloced = 1;\r\nsctp_inq_init(&ep->base.inqueue);\r\nsctp_inq_set_th_handler(&ep->base.inqueue, sctp_endpoint_bh_rcv);\r\nsctp_bind_addr_init(&ep->base.bind_addr, 0);\r\nep->base.sk = sk;\r\nsock_hold(ep->base.sk);\r\nINIT_LIST_HEAD(&ep->asocs);\r\nep->sndbuf_policy = sctp_sndbuf_policy;\r\nsk->sk_data_ready = sctp_data_ready;\r\nsk->sk_write_space = sctp_write_space;\r\nsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\r\nep->rcvbuf_policy = sctp_rcvbuf_policy;\r\nget_random_bytes(&ep->secret_key[0], SCTP_SECRET_SIZE);\r\nep->last_key = ep->current_key = 0;\r\nep->key_changed_at = jiffies;\r\nINIT_LIST_HEAD(&ep->endpoint_shared_keys);\r\nnull_key = sctp_auth_shkey_create(0, GFP_KERNEL);\r\nif (!null_key)\r\ngoto nomem;\r\nlist_add(&null_key->key_list, &ep->endpoint_shared_keys);\r\nerr = sctp_auth_init_hmacs(ep, gfp);\r\nif (err)\r\ngoto nomem_hmacs;\r\nep->auth_hmacs_list = auth_hmacs;\r\nep->auth_chunk_list = auth_chunks;\r\nreturn ep;\r\nnomem_hmacs:\r\nsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\r\nnomem:\r\nkfree(auth_hmacs);\r\nkfree(auth_chunks);\r\nkfree(ep->digest);\r\nreturn NULL;\r\n}\r\nstruct sctp_endpoint *sctp_endpoint_new(struct sock *sk, gfp_t gfp)\r\n{\r\nstruct sctp_endpoint *ep;\r\nep = t_new(struct sctp_endpoint, gfp);\r\nif (!ep)\r\ngoto fail;\r\nif (!sctp_endpoint_init(ep, sk, gfp))\r\ngoto fail_init;\r\nep->base.malloced = 1;\r\nSCTP_DBG_OBJCNT_INC(ep);\r\nreturn ep;\r\nfail_init:\r\nkfree(ep);\r\nfail:\r\nreturn NULL;\r\n}\r\nvoid sctp_endpoint_add_asoc(struct sctp_endpoint *ep,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sock *sk = ep->base.sk;\r\nif (asoc->temp)\r\nreturn;\r\nlist_add_tail(&asoc->asocs, &ep->asocs);\r\nif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\r\nsk->sk_ack_backlog++;\r\n}\r\nvoid sctp_endpoint_free(struct sctp_endpoint *ep)\r\n{\r\nep->base.dead = 1;\r\nep->base.sk->sk_state = SCTP_SS_CLOSED;\r\nsctp_unhash_endpoint(ep);\r\nsctp_endpoint_put(ep);\r\n}\r\nstatic void sctp_endpoint_destroy(struct sctp_endpoint *ep)\r\n{\r\nSCTP_ASSERT(ep->base.dead, "Endpoint is not dead", return);\r\ncrypto_free_hash(sctp_sk(ep->base.sk)->hmac);\r\nkfree(ep->digest);\r\nsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\r\nkfree(ep->auth_hmacs_list);\r\nkfree(ep->auth_chunk_list);\r\nsctp_auth_destroy_hmacs(ep->auth_hmacs);\r\nsctp_inq_free(&ep->base.inqueue);\r\nsctp_bind_addr_free(&ep->base.bind_addr);\r\nif (sctp_sk(ep->base.sk)->bind_hash)\r\nsctp_put_port(ep->base.sk);\r\nif (ep->base.sk)\r\nsock_put(ep->base.sk);\r\nif (ep->base.malloced) {\r\nkfree(ep);\r\nSCTP_DBG_OBJCNT_DEC(ep);\r\n}\r\n}\r\nvoid sctp_endpoint_hold(struct sctp_endpoint *ep)\r\n{\r\natomic_inc(&ep->base.refcnt);\r\n}\r\nvoid sctp_endpoint_put(struct sctp_endpoint *ep)\r\n{\r\nif (atomic_dec_and_test(&ep->base.refcnt))\r\nsctp_endpoint_destroy(ep);\r\n}\r\nstruct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *ep,\r\nconst union sctp_addr *laddr)\r\n{\r\nstruct sctp_endpoint *retval = NULL;\r\nif (htons(ep->base.bind_addr.port) == laddr->v4.sin_port) {\r\nif (sctp_bind_addr_match(&ep->base.bind_addr, laddr,\r\nsctp_sk(ep->base.sk)))\r\nretval = ep;\r\n}\r\nreturn retval;\r\n}\r\nstatic struct sctp_association *__sctp_endpoint_lookup_assoc(\r\nconst struct sctp_endpoint *ep,\r\nconst union sctp_addr *paddr,\r\nstruct sctp_transport **transport)\r\n{\r\nstruct sctp_association *asoc = NULL;\r\nstruct sctp_association *tmp;\r\nstruct sctp_transport *t = NULL;\r\nstruct sctp_hashbucket *head;\r\nstruct sctp_ep_common *epb;\r\nstruct hlist_node *node;\r\nint hash;\r\nint rport;\r\n*transport = NULL;\r\nif (!ep->base.bind_addr.port)\r\ngoto out;\r\nrport = ntohs(paddr->v4.sin_port);\r\nhash = sctp_assoc_hashfn(ep->base.bind_addr.port, rport);\r\nhead = &sctp_assoc_hashtable[hash];\r\nread_lock(&head->lock);\r\nsctp_for_each_hentry(epb, node, &head->chain) {\r\ntmp = sctp_assoc(epb);\r\nif (tmp->ep != ep || rport != tmp->peer.port)\r\ncontinue;\r\nt = sctp_assoc_lookup_paddr(tmp, paddr);\r\nif (t) {\r\nasoc = tmp;\r\n*transport = t;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&head->lock);\r\nout:\r\nreturn asoc;\r\n}\r\nstruct sctp_association *sctp_endpoint_lookup_assoc(\r\nconst struct sctp_endpoint *ep,\r\nconst union sctp_addr *paddr,\r\nstruct sctp_transport **transport)\r\n{\r\nstruct sctp_association *asoc;\r\nsctp_local_bh_disable();\r\nasoc = __sctp_endpoint_lookup_assoc(ep, paddr, transport);\r\nsctp_local_bh_enable();\r\nreturn asoc;\r\n}\r\nint sctp_endpoint_is_peeled_off(struct sctp_endpoint *ep,\r\nconst union sctp_addr *paddr)\r\n{\r\nstruct sctp_sockaddr_entry *addr;\r\nstruct sctp_bind_addr *bp;\r\nbp = &ep->base.bind_addr;\r\nlist_for_each_entry(addr, &bp->address_list, list) {\r\nif (sctp_has_association(&addr->a, paddr))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sctp_endpoint_bh_rcv(struct work_struct *work)\r\n{\r\nstruct sctp_endpoint *ep =\r\ncontainer_of(work, struct sctp_endpoint,\r\nbase.inqueue.immediate);\r\nstruct sctp_association *asoc;\r\nstruct sock *sk;\r\nstruct sctp_transport *transport;\r\nstruct sctp_chunk *chunk;\r\nstruct sctp_inq *inqueue;\r\nsctp_subtype_t subtype;\r\nsctp_state_t state;\r\nint error = 0;\r\nint first_time = 1;\r\nif (ep->base.dead)\r\nreturn;\r\nasoc = NULL;\r\ninqueue = &ep->base.inqueue;\r\nsk = ep->base.sk;\r\nwhile (NULL != (chunk = sctp_inq_pop(inqueue))) {\r\nsubtype = SCTP_ST_CHUNK(chunk->chunk_hdr->type);\r\nif (first_time && (subtype.chunk == SCTP_CID_AUTH)) {\r\nstruct sctp_chunkhdr *next_hdr;\r\nnext_hdr = sctp_inq_peek(inqueue);\r\nif (!next_hdr)\r\ngoto normal;\r\nif (next_hdr->type == SCTP_CID_COOKIE_ECHO) {\r\nchunk->auth_chunk = skb_clone(chunk->skb,\r\nGFP_ATOMIC);\r\nchunk->auth = 1;\r\ncontinue;\r\n}\r\n}\r\nnormal:\r\nif (NULL == chunk->asoc) {\r\nasoc = sctp_endpoint_lookup_assoc(ep,\r\nsctp_source(chunk),\r\n&transport);\r\nchunk->asoc = asoc;\r\nchunk->transport = transport;\r\n}\r\nstate = asoc ? asoc->state : SCTP_STATE_CLOSED;\r\nif (sctp_auth_recv_cid(subtype.chunk, asoc) && !chunk->auth)\r\ncontinue;\r\nif (asoc && sctp_chunk_is_data(chunk))\r\nasoc->peer.last_data_from = chunk->transport;\r\nelse\r\nSCTP_INC_STATS(SCTP_MIB_INCTRLCHUNKS);\r\nif (chunk->transport)\r\nchunk->transport->last_time_heard = jiffies;\r\nerror = sctp_do_sm(SCTP_EVENT_T_CHUNK, subtype, state,\r\nep, asoc, chunk, GFP_ATOMIC);\r\nif (error && chunk)\r\nchunk->pdiscard = 1;\r\nif (!sctp_sk(sk)->ep)\r\nbreak;\r\nif (first_time)\r\nfirst_time = 0;\r\n}\r\n}
