static void wm8350_led_enable(struct wm8350_led *led)\r\n{\r\nint ret;\r\nif (led->enabled)\r\nreturn;\r\nret = regulator_enable(led->isink);\r\nif (ret != 0) {\r\ndev_err(led->cdev.dev, "Failed to enable ISINK: %d\n", ret);\r\nreturn;\r\n}\r\nret = regulator_enable(led->dcdc);\r\nif (ret != 0) {\r\ndev_err(led->cdev.dev, "Failed to enable DCDC: %d\n", ret);\r\nregulator_disable(led->isink);\r\nreturn;\r\n}\r\nled->enabled = 1;\r\n}\r\nstatic void wm8350_led_disable(struct wm8350_led *led)\r\n{\r\nint ret;\r\nif (!led->enabled)\r\nreturn;\r\nret = regulator_disable(led->dcdc);\r\nif (ret != 0) {\r\ndev_err(led->cdev.dev, "Failed to disable DCDC: %d\n", ret);\r\nreturn;\r\n}\r\nret = regulator_disable(led->isink);\r\nif (ret != 0) {\r\ndev_err(led->cdev.dev, "Failed to disable ISINK: %d\n", ret);\r\nregulator_enable(led->dcdc);\r\nreturn;\r\n}\r\nled->enabled = 0;\r\n}\r\nstatic void led_work(struct work_struct *work)\r\n{\r\nstruct wm8350_led *led = container_of(work, struct wm8350_led, work);\r\nint ret;\r\nint uA;\r\nunsigned long flags;\r\nmutex_lock(&led->mutex);\r\nspin_lock_irqsave(&led->value_lock, flags);\r\nif (led->value == LED_OFF) {\r\nspin_unlock_irqrestore(&led->value_lock, flags);\r\nwm8350_led_disable(led);\r\ngoto out;\r\n}\r\nuA = (led->max_uA_index * led->value) / LED_FULL;\r\nspin_unlock_irqrestore(&led->value_lock, flags);\r\nBUG_ON(uA >= ARRAY_SIZE(isink_cur));\r\nret = regulator_set_current_limit(led->isink, isink_cur[uA],\r\nisink_cur[uA]);\r\nif (ret != 0)\r\ndev_err(led->cdev.dev, "Failed to set %duA: %d\n",\r\nisink_cur[uA], ret);\r\nwm8350_led_enable(led);\r\nout:\r\nmutex_unlock(&led->mutex);\r\n}\r\nstatic void wm8350_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct wm8350_led *led = to_wm8350_led(led_cdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&led->value_lock, flags);\r\nled->value = value;\r\nschedule_work(&led->work);\r\nspin_unlock_irqrestore(&led->value_lock, flags);\r\n}\r\nstatic void wm8350_led_shutdown(struct platform_device *pdev)\r\n{\r\nstruct wm8350_led *led = platform_get_drvdata(pdev);\r\nmutex_lock(&led->mutex);\r\nled->value = LED_OFF;\r\nwm8350_led_disable(led);\r\nmutex_unlock(&led->mutex);\r\n}\r\nstatic int wm8350_led_probe(struct platform_device *pdev)\r\n{\r\nstruct regulator *isink, *dcdc;\r\nstruct wm8350_led *led;\r\nstruct wm8350_led_platform_data *pdata = pdev->dev.platform_data;\r\nint ret, i;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "no platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata->max_uA < isink_cur[0]) {\r\ndev_err(&pdev->dev, "Invalid maximum current %duA\n",\r\npdata->max_uA);\r\nreturn -EINVAL;\r\n}\r\nisink = regulator_get(&pdev->dev, "led_isink");\r\nif (IS_ERR(isink)) {\r\nprintk(KERN_ERR "%s: can't get ISINK\n", __func__);\r\nreturn PTR_ERR(isink);\r\n}\r\ndcdc = regulator_get(&pdev->dev, "led_vcc");\r\nif (IS_ERR(dcdc)) {\r\nprintk(KERN_ERR "%s: can't get DCDC\n", __func__);\r\nret = PTR_ERR(dcdc);\r\ngoto err_isink;\r\n}\r\nled = devm_kzalloc(&pdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (led == NULL) {\r\nret = -ENOMEM;\r\ngoto err_dcdc;\r\n}\r\nled->cdev.brightness_set = wm8350_led_set;\r\nled->cdev.default_trigger = pdata->default_trigger;\r\nled->cdev.name = pdata->name;\r\nled->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled->enabled = regulator_is_enabled(isink);\r\nled->isink = isink;\r\nled->dcdc = dcdc;\r\nfor (i = 0; i < ARRAY_SIZE(isink_cur) - 1; i++)\r\nif (isink_cur[i] >= pdata->max_uA)\r\nbreak;\r\nled->max_uA_index = i;\r\nif (pdata->max_uA != isink_cur[i])\r\ndev_warn(&pdev->dev,\r\n"Maximum current %duA is not directly supported,"\r\n" check platform data\n",\r\npdata->max_uA);\r\nspin_lock_init(&led->value_lock);\r\nmutex_init(&led->mutex);\r\nINIT_WORK(&led->work, led_work);\r\nled->value = LED_OFF;\r\nplatform_set_drvdata(pdev, led);\r\nret = led_classdev_register(&pdev->dev, &led->cdev);\r\nif (ret < 0)\r\ngoto err_dcdc;\r\nreturn 0;\r\nerr_dcdc:\r\nregulator_put(dcdc);\r\nerr_isink:\r\nregulator_put(isink);\r\nreturn ret;\r\n}\r\nstatic int wm8350_led_remove(struct platform_device *pdev)\r\n{\r\nstruct wm8350_led *led = platform_get_drvdata(pdev);\r\nled_classdev_unregister(&led->cdev);\r\nflush_work_sync(&led->work);\r\nwm8350_led_disable(led);\r\nregulator_put(led->dcdc);\r\nregulator_put(led->isink);\r\nreturn 0;\r\n}
