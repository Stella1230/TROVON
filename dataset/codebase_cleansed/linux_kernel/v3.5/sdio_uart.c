static int sdio_uart_add_port(struct sdio_uart_port *port)\r\n{\r\nint index, ret = -EBUSY;\r\nkref_init(&port->kref);\r\nmutex_init(&port->func_lock);\r\nspin_lock_init(&port->write_lock);\r\nif (kfifo_alloc(&port->xmit_fifo, FIFO_SIZE, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nspin_lock(&sdio_uart_table_lock);\r\nfor (index = 0; index < UART_NR; index++) {\r\nif (!sdio_uart_table[index]) {\r\nport->index = index;\r\nsdio_uart_table[index] = port;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&sdio_uart_table_lock);\r\nreturn ret;\r\n}\r\nstatic struct sdio_uart_port *sdio_uart_port_get(unsigned index)\r\n{\r\nstruct sdio_uart_port *port;\r\nif (index >= UART_NR)\r\nreturn NULL;\r\nspin_lock(&sdio_uart_table_lock);\r\nport = sdio_uart_table[index];\r\nif (port)\r\nkref_get(&port->kref);\r\nspin_unlock(&sdio_uart_table_lock);\r\nreturn port;\r\n}\r\nstatic void sdio_uart_port_destroy(struct kref *kref)\r\n{\r\nstruct sdio_uart_port *port =\r\ncontainer_of(kref, struct sdio_uart_port, kref);\r\nkfifo_free(&port->xmit_fifo);\r\nkfree(port);\r\n}\r\nstatic void sdio_uart_port_put(struct sdio_uart_port *port)\r\n{\r\nkref_put(&port->kref, sdio_uart_port_destroy);\r\n}\r\nstatic void sdio_uart_port_remove(struct sdio_uart_port *port)\r\n{\r\nstruct sdio_func *func;\r\nstruct tty_struct *tty;\r\nBUG_ON(sdio_uart_table[port->index] != port);\r\nspin_lock(&sdio_uart_table_lock);\r\nsdio_uart_table[port->index] = NULL;\r\nspin_unlock(&sdio_uart_table_lock);\r\nmutex_lock(&port->port.mutex);\r\nmutex_lock(&port->func_lock);\r\nfunc = port->func;\r\nsdio_claim_host(func);\r\nport->func = NULL;\r\nmutex_unlock(&port->func_lock);\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nmutex_unlock(&port->port.mutex);\r\nsdio_release_irq(func);\r\nsdio_disable_func(func);\r\nsdio_release_host(func);\r\nsdio_uart_port_put(port);\r\n}\r\nstatic int sdio_uart_claim_func(struct sdio_uart_port *port)\r\n{\r\nmutex_lock(&port->func_lock);\r\nif (unlikely(!port->func)) {\r\nmutex_unlock(&port->func_lock);\r\nreturn -ENODEV;\r\n}\r\nif (likely(port->in_sdio_uart_irq != current))\r\nsdio_claim_host(port->func);\r\nmutex_unlock(&port->func_lock);\r\nreturn 0;\r\n}\r\nstatic inline void sdio_uart_release_func(struct sdio_uart_port *port)\r\n{\r\nif (likely(port->in_sdio_uart_irq != current))\r\nsdio_release_host(port->func);\r\n}\r\nstatic inline unsigned int sdio_in(struct sdio_uart_port *port, int offset)\r\n{\r\nunsigned char c;\r\nc = sdio_readb(port->func, port->regs_offset + offset, NULL);\r\nreturn c;\r\n}\r\nstatic inline void sdio_out(struct sdio_uart_port *port, int offset, int value)\r\n{\r\nsdio_writeb(port->func, value, port->regs_offset + offset, NULL);\r\n}\r\nstatic unsigned int sdio_uart_get_mctrl(struct sdio_uart_port *port)\r\n{\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = sdio_in(port, UART_MSR);\r\nret = 0;\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void sdio_uart_write_mctrl(struct sdio_uart_port *port,\r\nunsigned int mctrl)\r\n{\r\nunsigned char mcr = 0;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nsdio_out(port, UART_MCR, mcr);\r\n}\r\nstatic inline void sdio_uart_update_mctrl(struct sdio_uart_port *port,\r\nunsigned int set, unsigned int clear)\r\n{\r\nunsigned int old;\r\nold = port->mctrl;\r\nport->mctrl = (old & ~clear) | set;\r\nif (old != port->mctrl)\r\nsdio_uart_write_mctrl(port, port->mctrl);\r\n}\r\nstatic void sdio_uart_change_speed(struct sdio_uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned char cval, fcr = 0;\r\nunsigned int baud, quot;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nfor (;;) {\r\nbaud = tty_termios_baud_rate(termios);\r\nif (baud == 0)\r\nbaud = 9600;\r\nif (baud <= port->uartclk)\r\nbreak;\r\ntermios->c_cflag &= ~CBAUD;\r\nif (old) {\r\ntermios->c_cflag |= old->c_cflag & CBAUD;\r\nold = NULL;\r\n} else\r\ntermios->c_cflag |= B9600;\r\n}\r\nquot = (2 * port->uartclk + baud) / (2 * baud);\r\nif (baud < 2400)\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\r\nelse\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10;\r\nport->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= UART_LSR_BI;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_LSR_DR;\r\nport->ier &= ~UART_IER_MSI;\r\nif ((termios->c_cflag & CRTSCTS) || !(termios->c_cflag & CLOCAL))\r\nport->ier |= UART_IER_MSI;\r\nport->lcr = cval;\r\nsdio_out(port, UART_IER, port->ier);\r\nsdio_out(port, UART_LCR, cval | UART_LCR_DLAB);\r\nsdio_out(port, UART_DLL, quot & 0xff);\r\nsdio_out(port, UART_DLM, quot >> 8);\r\nsdio_out(port, UART_LCR, cval);\r\nsdio_out(port, UART_FCR, fcr);\r\nsdio_uart_write_mctrl(port, port->mctrl);\r\n}\r\nstatic void sdio_uart_start_tx(struct sdio_uart_port *port)\r\n{\r\nif (!(port->ier & UART_IER_THRI)) {\r\nport->ier |= UART_IER_THRI;\r\nsdio_out(port, UART_IER, port->ier);\r\n}\r\n}\r\nstatic void sdio_uart_stop_tx(struct sdio_uart_port *port)\r\n{\r\nif (port->ier & UART_IER_THRI) {\r\nport->ier &= ~UART_IER_THRI;\r\nsdio_out(port, UART_IER, port->ier);\r\n}\r\n}\r\nstatic void sdio_uart_stop_rx(struct sdio_uart_port *port)\r\n{\r\nport->ier &= ~UART_IER_RLSI;\r\nport->read_status_mask &= ~UART_LSR_DR;\r\nsdio_out(port, UART_IER, port->ier);\r\n}\r\nstatic void sdio_uart_receive_chars(struct sdio_uart_port *port,\r\nunsigned int *status)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nunsigned int ch, flag;\r\nint max_count = 256;\r\ndo {\r\nch = sdio_in(port, UART_RX);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE))) {\r\nif (*status & UART_LSR_BI) {\r\n*status &= ~(UART_LSR_FE | UART_LSR_PE);\r\nport->icount.brk++;\r\n} else if (*status & UART_LSR_PE)\r\nport->icount.parity++;\r\nelse if (*status & UART_LSR_FE)\r\nport->icount.frame++;\r\nif (*status & UART_LSR_OE)\r\nport->icount.overrun++;\r\n*status &= port->read_status_mask;\r\nif (*status & UART_LSR_BI)\r\nflag = TTY_BREAK;\r\nelse if (*status & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (*status & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif ((*status & port->ignore_status_mask & ~UART_LSR_OE) == 0)\r\nif (tty)\r\ntty_insert_flip_char(tty, ch, flag);\r\nif (*status & ~port->ignore_status_mask & UART_LSR_OE)\r\nif (tty)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\n*status = sdio_in(port, UART_LSR);\r\n} while ((*status & UART_LSR_DR) && (max_count-- > 0));\r\nif (tty) {\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void sdio_uart_transmit_chars(struct sdio_uart_port *port)\r\n{\r\nstruct kfifo *xmit = &port->xmit_fifo;\r\nint count;\r\nstruct tty_struct *tty;\r\nu8 iobuf[16];\r\nint len;\r\nif (port->x_char) {\r\nsdio_out(port, UART_TX, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty == NULL || !kfifo_len(xmit) ||\r\ntty->stopped || tty->hw_stopped) {\r\nsdio_uart_stop_tx(port);\r\ntty_kref_put(tty);\r\nreturn;\r\n}\r\nlen = kfifo_out_locked(xmit, iobuf, 16, &port->write_lock);\r\nfor (count = 0; count < len; count++) {\r\nsdio_out(port, UART_TX, iobuf[count]);\r\nport->icount.tx++;\r\n}\r\nlen = kfifo_len(xmit);\r\nif (len < WAKEUP_CHARS) {\r\ntty_wakeup(tty);\r\nif (len == 0)\r\nsdio_uart_stop_tx(port);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nstatic void sdio_uart_check_modem_status(struct sdio_uart_port *port)\r\n{\r\nint status;\r\nstruct tty_struct *tty;\r\nstatus = sdio_in(port, UART_MSR);\r\nif ((status & UART_MSR_ANY_DELTA) == 0)\r\nreturn;\r\nif (status & UART_MSR_TERI)\r\nport->icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (status & UART_MSR_DDCD) {\r\nport->icount.dcd++;\r\nif (status & UART_MSR_DCD)\r\nwake_up_interruptible(&port->port.open_wait);\r\nelse {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\n}\r\nif (status & UART_MSR_DCTS) {\r\nport->icount.cts++;\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty && (tty->termios->c_cflag & CRTSCTS)) {\r\nint cts = (status & UART_MSR_CTS);\r\nif (tty->hw_stopped) {\r\nif (cts) {\r\ntty->hw_stopped = 0;\r\nsdio_uart_start_tx(port);\r\ntty_wakeup(tty);\r\n}\r\n} else {\r\nif (!cts) {\r\ntty->hw_stopped = 1;\r\nsdio_uart_stop_tx(port);\r\n}\r\n}\r\n}\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void sdio_uart_irq(struct sdio_func *func)\r\n{\r\nstruct sdio_uart_port *port = sdio_get_drvdata(func);\r\nunsigned int iir, lsr;\r\nif (unlikely(port->in_sdio_uart_irq == current))\r\nreturn;\r\niir = sdio_in(port, UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nreturn;\r\nport->in_sdio_uart_irq = current;\r\nlsr = sdio_in(port, UART_LSR);\r\nif (lsr & UART_LSR_DR)\r\nsdio_uart_receive_chars(port, &lsr);\r\nsdio_uart_check_modem_status(port);\r\nif (lsr & UART_LSR_THRE)\r\nsdio_uart_transmit_chars(port);\r\nport->in_sdio_uart_irq = NULL;\r\n}\r\nstatic int uart_carrier_raised(struct tty_port *tport)\r\n{\r\nstruct sdio_uart_port *port =\r\ncontainer_of(tport, struct sdio_uart_port, port);\r\nunsigned int ret = sdio_uart_claim_func(port);\r\nif (ret)\r\nreturn 1;\r\nret = sdio_uart_get_mctrl(port);\r\nsdio_uart_release_func(port);\r\nif (ret & TIOCM_CAR)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void uart_dtr_rts(struct tty_port *tport, int onoff)\r\n{\r\nstruct sdio_uart_port *port =\r\ncontainer_of(tport, struct sdio_uart_port, port);\r\nint ret = sdio_uart_claim_func(port);\r\nif (ret)\r\nreturn;\r\nif (onoff == 0)\r\nsdio_uart_clear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\r\nelse\r\nsdio_uart_set_mctrl(port, TIOCM_DTR | TIOCM_RTS);\r\nsdio_uart_release_func(port);\r\n}\r\nstatic int sdio_uart_activate(struct tty_port *tport, struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port =\r\ncontainer_of(tport, struct sdio_uart_port, port);\r\nint ret;\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nkfifo_reset(&port->xmit_fifo);\r\nret = sdio_uart_claim_func(port);\r\nif (ret)\r\nreturn ret;\r\nret = sdio_enable_func(port->func);\r\nif (ret)\r\ngoto err1;\r\nret = sdio_claim_irq(port->func, sdio_uart_irq);\r\nif (ret)\r\ngoto err2;\r\nsdio_out(port, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nsdio_out(port, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nsdio_out(port, UART_FCR, 0);\r\n(void) sdio_in(port, UART_LSR);\r\n(void) sdio_in(port, UART_RX);\r\n(void) sdio_in(port, UART_IIR);\r\n(void) sdio_in(port, UART_MSR);\r\nsdio_out(port, UART_LCR, UART_LCR_WLEN8);\r\nport->ier = UART_IER_RLSI|UART_IER_RDI|UART_IER_RTOIE|UART_IER_UUE;\r\nport->mctrl = TIOCM_OUT2;\r\nsdio_uart_change_speed(port, tty->termios, NULL);\r\nif (tty->termios->c_cflag & CBAUD)\r\nsdio_uart_set_mctrl(port, TIOCM_RTS | TIOCM_DTR);\r\nif (tty->termios->c_cflag & CRTSCTS)\r\nif (!(sdio_uart_get_mctrl(port) & TIOCM_CTS))\r\ntty->hw_stopped = 1;\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\nsdio_uart_irq(port->func);\r\nsdio_uart_release_func(port);\r\nreturn 0;\r\nerr2:\r\nsdio_disable_func(port->func);\r\nerr1:\r\nsdio_uart_release_func(port);\r\nreturn ret;\r\n}\r\nstatic void sdio_uart_shutdown(struct tty_port *tport)\r\n{\r\nstruct sdio_uart_port *port =\r\ncontainer_of(tport, struct sdio_uart_port, port);\r\nint ret;\r\nret = sdio_uart_claim_func(port);\r\nif (ret)\r\nreturn;\r\nsdio_uart_stop_rx(port);\r\nsdio_release_irq(port->func);\r\nport->ier = 0;\r\nsdio_out(port, UART_IER, 0);\r\nsdio_uart_clear_mctrl(port, TIOCM_OUT2);\r\nport->lcr &= ~UART_LCR_SBC;\r\nsdio_out(port, UART_LCR, port->lcr);\r\nsdio_out(port, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT);\r\nsdio_out(port, UART_FCR, 0);\r\nsdio_disable_func(port->func);\r\nsdio_uart_release_func(port);\r\n}\r\nstatic int sdio_uart_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nint idx = tty->index;\r\nstruct sdio_uart_port *port = sdio_uart_port_get(idx);\r\nint ret = tty_standard_install(driver, tty);\r\nif (ret == 0)\r\ntty->driver_data = port;\r\nelse\r\nsdio_uart_port_put(port);\r\nreturn ret;\r\n}\r\nstatic void sdio_uart_cleanup(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\ntty->driver_data = NULL;\r\nsdio_uart_port_put(port);\r\n}\r\nstatic int sdio_uart_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nreturn tty_port_open(&port->port, tty, filp);\r\n}\r\nstatic void sdio_uart_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\ntty_port_close(&port->port, tty, filp);\r\n}\r\nstatic void sdio_uart_hangup(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\ntty_port_hangup(&port->port);\r\n}\r\nstatic int sdio_uart_write(struct tty_struct *tty, const unsigned char *buf,\r\nint count)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nint ret;\r\nif (!port->func)\r\nreturn -ENODEV;\r\nret = kfifo_in_locked(&port->xmit_fifo, buf, count, &port->write_lock);\r\nif (!(port->ier & UART_IER_THRI)) {\r\nint err = sdio_uart_claim_func(port);\r\nif (!err) {\r\nsdio_uart_start_tx(port);\r\nsdio_uart_irq(port->func);\r\nsdio_uart_release_func(port);\r\n} else\r\nret = err;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sdio_uart_write_room(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nreturn FIFO_SIZE - kfifo_len(&port->xmit_fifo);\r\n}\r\nstatic int sdio_uart_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nreturn kfifo_len(&port->xmit_fifo);\r\n}\r\nstatic void sdio_uart_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nport->x_char = ch;\r\nif (ch && !(port->ier & UART_IER_THRI)) {\r\nif (sdio_uart_claim_func(port) != 0)\r\nreturn;\r\nsdio_uart_start_tx(port);\r\nsdio_uart_irq(port->func);\r\nsdio_uart_release_func(port);\r\n}\r\n}\r\nstatic void sdio_uart_throttle(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nif (!I_IXOFF(tty) && !(tty->termios->c_cflag & CRTSCTS))\r\nreturn;\r\nif (sdio_uart_claim_func(port) != 0)\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nport->x_char = STOP_CHAR(tty);\r\nsdio_uart_start_tx(port);\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS)\r\nsdio_uart_clear_mctrl(port, TIOCM_RTS);\r\nsdio_uart_irq(port->func);\r\nsdio_uart_release_func(port);\r\n}\r\nstatic void sdio_uart_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nif (!I_IXOFF(tty) && !(tty->termios->c_cflag & CRTSCTS))\r\nreturn;\r\nif (sdio_uart_claim_func(port) != 0)\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nif (port->x_char) {\r\nport->x_char = 0;\r\n} else {\r\nport->x_char = START_CHAR(tty);\r\nsdio_uart_start_tx(port);\r\n}\r\n}\r\nif (tty->termios->c_cflag & CRTSCTS)\r\nsdio_uart_set_mctrl(port, TIOCM_RTS);\r\nsdio_uart_irq(port->func);\r\nsdio_uart_release_func(port);\r\n}\r\nstatic void sdio_uart_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nunsigned int cflag = tty->termios->c_cflag;\r\nif (sdio_uart_claim_func(port) != 0)\r\nreturn;\r\nsdio_uart_change_speed(port, tty->termios, old_termios);\r\nif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD))\r\nsdio_uart_clear_mctrl(port, TIOCM_RTS | TIOCM_DTR);\r\nif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\r\nunsigned int mask = TIOCM_DTR;\r\nif (!(cflag & CRTSCTS) || !test_bit(TTY_THROTTLED, &tty->flags))\r\nmask |= TIOCM_RTS;\r\nsdio_uart_set_mctrl(port, mask);\r\n}\r\nif ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\nsdio_uart_start_tx(port);\r\n}\r\nif (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {\r\nif (!(sdio_uart_get_mctrl(port) & TIOCM_CTS)) {\r\ntty->hw_stopped = 1;\r\nsdio_uart_stop_tx(port);\r\n}\r\n}\r\nsdio_uart_release_func(port);\r\n}\r\nstatic int sdio_uart_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nint result;\r\nresult = sdio_uart_claim_func(port);\r\nif (result != 0)\r\nreturn result;\r\nif (break_state == -1)\r\nport->lcr |= UART_LCR_SBC;\r\nelse\r\nport->lcr &= ~UART_LCR_SBC;\r\nsdio_out(port, UART_LCR, port->lcr);\r\nsdio_uart_release_func(port);\r\nreturn 0;\r\n}\r\nstatic int sdio_uart_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nint result;\r\nresult = sdio_uart_claim_func(port);\r\nif (!result) {\r\nresult = port->mctrl | sdio_uart_get_mctrl(port);\r\nsdio_uart_release_func(port);\r\n}\r\nreturn result;\r\n}\r\nstatic int sdio_uart_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct sdio_uart_port *port = tty->driver_data;\r\nint result;\r\nresult = sdio_uart_claim_func(port);\r\nif (!result) {\r\nsdio_uart_update_mctrl(port, set, clear);\r\nsdio_uart_release_func(port);\r\n}\r\nreturn result;\r\n}\r\nstatic int sdio_uart_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nseq_printf(m, "serinfo:1.0 driver%s%s revision:%s\n",\r\n"", "", "");\r\nfor (i = 0; i < UART_NR; i++) {\r\nstruct sdio_uart_port *port = sdio_uart_port_get(i);\r\nif (port) {\r\nseq_printf(m, "%d: uart:SDIO", i);\r\nif (capable(CAP_SYS_ADMIN)) {\r\nseq_printf(m, " tx:%d rx:%d",\r\nport->icount.tx, port->icount.rx);\r\nif (port->icount.frame)\r\nseq_printf(m, " fe:%d",\r\nport->icount.frame);\r\nif (port->icount.parity)\r\nseq_printf(m, " pe:%d",\r\nport->icount.parity);\r\nif (port->icount.brk)\r\nseq_printf(m, " brk:%d",\r\nport->icount.brk);\r\nif (port->icount.overrun)\r\nseq_printf(m, " oe:%d",\r\nport->icount.overrun);\r\nif (port->icount.cts)\r\nseq_printf(m, " cts:%d",\r\nport->icount.cts);\r\nif (port->icount.dsr)\r\nseq_printf(m, " dsr:%d",\r\nport->icount.dsr);\r\nif (port->icount.rng)\r\nseq_printf(m, " rng:%d",\r\nport->icount.rng);\r\nif (port->icount.dcd)\r\nseq_printf(m, " dcd:%d",\r\nport->icount.dcd);\r\n}\r\nsdio_uart_port_put(port);\r\nseq_putc(m, '\n');\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdio_uart_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sdio_uart_proc_show, NULL);\r\n}\r\nstatic int sdio_uart_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nstruct sdio_uart_port *port;\r\nint ret;\r\nport = kzalloc(sizeof(struct sdio_uart_port), GFP_KERNEL);\r\nif (!port)\r\nreturn -ENOMEM;\r\nif (func->class == SDIO_CLASS_UART) {\r\npr_warning("%s: need info on UART class basic setup\n",\r\nsdio_func_id(func));\r\nkfree(port);\r\nreturn -ENOSYS;\r\n} else if (func->class == SDIO_CLASS_GPS) {\r\nstruct sdio_func_tuple *tpl;\r\nfor (tpl = func->tuples; tpl; tpl = tpl->next) {\r\nif (tpl->code != 0x91)\r\ncontinue;\r\nif (tpl->size < 10)\r\ncontinue;\r\nif (tpl->data[1] == 0)\r\nbreak;\r\n}\r\nif (!tpl) {\r\npr_warning(\r\n"%s: can't find tuple 0x91 subtuple 0 (SUBTPL_SIOREG) for GPS class\n",\r\nsdio_func_id(func));\r\nkfree(port);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s: Register ID = 0x%02x, Exp ID = 0x%02x\n",\r\nsdio_func_id(func), tpl->data[2], tpl->data[3]);\r\nport->regs_offset = (tpl->data[4] << 0) |\r\n(tpl->data[5] << 8) |\r\n(tpl->data[6] << 16);\r\npr_debug("%s: regs offset = 0x%x\n",\r\nsdio_func_id(func), port->regs_offset);\r\nport->uartclk = tpl->data[7] * 115200;\r\nif (port->uartclk == 0)\r\nport->uartclk = 115200;\r\npr_debug("%s: clk %d baudcode %u 4800-div %u\n",\r\nsdio_func_id(func), port->uartclk,\r\ntpl->data[7], tpl->data[8] | (tpl->data[9] << 8));\r\n} else {\r\nkfree(port);\r\nreturn -EINVAL;\r\n}\r\nport->func = func;\r\nsdio_set_drvdata(func, port);\r\ntty_port_init(&port->port);\r\nport->port.ops = &sdio_uart_port_ops;\r\nret = sdio_uart_add_port(port);\r\nif (ret) {\r\nkfree(port);\r\n} else {\r\nstruct device *dev;\r\ndev = tty_register_device(sdio_uart_tty_driver,\r\nport->index, &func->dev);\r\nif (IS_ERR(dev)) {\r\nsdio_uart_port_remove(port);\r\nret = PTR_ERR(dev);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void sdio_uart_remove(struct sdio_func *func)\r\n{\r\nstruct sdio_uart_port *port = sdio_get_drvdata(func);\r\ntty_unregister_device(sdio_uart_tty_driver, port->index);\r\nsdio_uart_port_remove(port);\r\n}\r\nstatic int __init sdio_uart_init(void)\r\n{\r\nint ret;\r\nstruct tty_driver *tty_drv;\r\nsdio_uart_tty_driver = tty_drv = alloc_tty_driver(UART_NR);\r\nif (!tty_drv)\r\nreturn -ENOMEM;\r\ntty_drv->driver_name = "sdio_uart";\r\ntty_drv->name = "ttySDIO";\r\ntty_drv->major = 0;\r\ntty_drv->minor_start = 0;\r\ntty_drv->type = TTY_DRIVER_TYPE_SERIAL;\r\ntty_drv->subtype = SERIAL_TYPE_NORMAL;\r\ntty_drv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_drv->init_termios = tty_std_termios;\r\ntty_drv->init_termios.c_cflag = B4800 | CS8 | CREAD | HUPCL | CLOCAL;\r\ntty_drv->init_termios.c_ispeed = 4800;\r\ntty_drv->init_termios.c_ospeed = 4800;\r\ntty_set_operations(tty_drv, &sdio_uart_ops);\r\nret = tty_register_driver(tty_drv);\r\nif (ret)\r\ngoto err1;\r\nret = sdio_register_driver(&sdio_uart_driver);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\ntty_unregister_driver(tty_drv);\r\nerr1:\r\nput_tty_driver(tty_drv);\r\nreturn ret;\r\n}\r\nstatic void __exit sdio_uart_exit(void)\r\n{\r\nsdio_unregister_driver(&sdio_uart_driver);\r\ntty_unregister_driver(sdio_uart_tty_driver);\r\nput_tty_driver(sdio_uart_tty_driver);\r\n}
