static int sd_bytes_number(struct item_head *ih, int block_size)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sd_decrement_key(struct cpu_key *key)\r\n{\r\nkey->on_disk_key.k_objectid--;\r\nset_cpu_key_k_type(key, TYPE_ANY);\r\nset_cpu_key_k_offset(key, (loff_t)(~0ULL >> 1));\r\n}\r\nstatic int sd_is_left_mergeable(struct reiserfs_key *key, unsigned long bsize)\r\n{\r\nreturn 0;\r\n}\r\nstatic char *print_time(time_t t)\r\n{\r\nstatic char timebuf[256];\r\nsprintf(timebuf, "%ld", t);\r\nreturn timebuf;\r\n}\r\nstatic void sd_print_item(struct item_head *ih, char *item)\r\n{\r\nprintk("\tmode | size | nlinks | first direct | mtime\n");\r\nif (stat_data_v1(ih)) {\r\nstruct stat_data_v1 *sd = (struct stat_data_v1 *)item;\r\nprintk("\t0%-6o | %6u | %2u | %d | %s\n", sd_v1_mode(sd),\r\nsd_v1_size(sd), sd_v1_nlink(sd),\r\nsd_v1_first_direct_byte(sd),\r\nprint_time(sd_v1_mtime(sd)));\r\n} else {\r\nstruct stat_data *sd = (struct stat_data *)item;\r\nprintk("\t0%-6o | %6Lu | %2u | %d | %s\n", sd_v2_mode(sd),\r\n(unsigned long long)sd_v2_size(sd), sd_v2_nlink(sd),\r\nsd_v2_rdev(sd), print_time(sd_v2_mtime(sd)));\r\n}\r\n}\r\nstatic void sd_check_item(struct item_head *ih, char *item)\r\n{\r\n}\r\nstatic int sd_create_vi(struct virtual_node *vn,\r\nstruct virtual_item *vi,\r\nint is_affected, int insert_size)\r\n{\r\nvi->vi_index = TYPE_STAT_DATA;\r\nreturn 0;\r\n}\r\nstatic int sd_check_left(struct virtual_item *vi, int free,\r\nint start_skip, int end_skip)\r\n{\r\nBUG_ON(start_skip || end_skip);\r\nreturn -1;\r\n}\r\nstatic int sd_check_right(struct virtual_item *vi, int free)\r\n{\r\nreturn -1;\r\n}\r\nstatic int sd_part_size(struct virtual_item *vi, int first, int count)\r\n{\r\nBUG_ON(count);\r\nreturn 0;\r\n}\r\nstatic int sd_unit_num(struct virtual_item *vi)\r\n{\r\nreturn vi->vi_item_len - IH_SIZE;\r\n}\r\nstatic void sd_print_vi(struct virtual_item *vi)\r\n{\r\nreiserfs_warning(NULL, "reiserfs-16100",\r\n"STATDATA, index %d, type 0x%x, %h",\r\nvi->vi_index, vi->vi_type, vi->vi_ih);\r\n}\r\nstatic int direct_bytes_number(struct item_head *ih, int block_size)\r\n{\r\nreturn ih_item_len(ih);\r\n}\r\nstatic void direct_decrement_key(struct cpu_key *key)\r\n{\r\ncpu_key_k_offset_dec(key);\r\nif (cpu_key_k_offset(key) == 0)\r\nset_cpu_key_k_type(key, TYPE_STAT_DATA);\r\n}\r\nstatic int direct_is_left_mergeable(struct reiserfs_key *key,\r\nunsigned long bsize)\r\n{\r\nint version = le_key_version(key);\r\nreturn ((le_key_k_offset(version, key) & (bsize - 1)) != 1);\r\n}\r\nstatic void direct_print_item(struct item_head *ih, char *item)\r\n{\r\nint j = 0;\r\nprintk("\"");\r\nwhile (j < ih_item_len(ih))\r\nprintk("%c", item[j++]);\r\nprintk("\"\n");\r\n}\r\nstatic void direct_check_item(struct item_head *ih, char *item)\r\n{\r\n}\r\nstatic int direct_create_vi(struct virtual_node *vn,\r\nstruct virtual_item *vi,\r\nint is_affected, int insert_size)\r\n{\r\nvi->vi_index = TYPE_DIRECT;\r\nreturn 0;\r\n}\r\nstatic int direct_check_left(struct virtual_item *vi, int free,\r\nint start_skip, int end_skip)\r\n{\r\nint bytes;\r\nbytes = free - free % 8;\r\nreturn bytes ? : -1;\r\n}\r\nstatic int direct_check_right(struct virtual_item *vi, int free)\r\n{\r\nreturn direct_check_left(vi, free, 0, 0);\r\n}\r\nstatic int direct_part_size(struct virtual_item *vi, int first, int count)\r\n{\r\nreturn count;\r\n}\r\nstatic int direct_unit_num(struct virtual_item *vi)\r\n{\r\nreturn vi->vi_item_len - IH_SIZE;\r\n}\r\nstatic void direct_print_vi(struct virtual_item *vi)\r\n{\r\nreiserfs_warning(NULL, "reiserfs-16101",\r\n"DIRECT, index %d, type 0x%x, %h",\r\nvi->vi_index, vi->vi_type, vi->vi_ih);\r\n}\r\nstatic int indirect_bytes_number(struct item_head *ih, int block_size)\r\n{\r\nreturn ih_item_len(ih) / UNFM_P_SIZE * block_size;\r\n}\r\nstatic void indirect_decrement_key(struct cpu_key *key)\r\n{\r\ncpu_key_k_offset_dec(key);\r\nif (cpu_key_k_offset(key) == 0)\r\nset_cpu_key_k_type(key, TYPE_STAT_DATA);\r\n}\r\nstatic int indirect_is_left_mergeable(struct reiserfs_key *key,\r\nunsigned long bsize)\r\n{\r\nint version = le_key_version(key);\r\nreturn (le_key_k_offset(version, key) != 1);\r\n}\r\nstatic void start_new_sequence(__u32 * start, int *len, __u32 new)\r\n{\r\n*start = new;\r\n*len = 1;\r\n}\r\nstatic int sequence_finished(__u32 start, int *len, __u32 new)\r\n{\r\nif (start == INT_MAX)\r\nreturn 1;\r\nif (start == 0 && new == 0) {\r\n(*len)++;\r\nreturn 0;\r\n}\r\nif (start != 0 && (start + *len) == new) {\r\n(*len)++;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void print_sequence(__u32 start, int len)\r\n{\r\nif (start == INT_MAX)\r\nreturn;\r\nif (len == 1)\r\nprintk(" %d", start);\r\nelse\r\nprintk(" %d(%d)", start, len);\r\n}\r\nstatic void indirect_print_item(struct item_head *ih, char *item)\r\n{\r\nint j;\r\n__le32 *unp;\r\n__u32 prev = INT_MAX;\r\nint num = 0;\r\nunp = (__le32 *) item;\r\nif (ih_item_len(ih) % UNFM_P_SIZE)\r\nreiserfs_warning(NULL, "reiserfs-16102", "invalid item len");\r\nprintk("%d pointers\n[ ", (int)I_UNFM_NUM(ih));\r\nfor (j = 0; j < I_UNFM_NUM(ih); j++) {\r\nif (sequence_finished(prev, &num, get_block_num(unp, j))) {\r\nprint_sequence(prev, num);\r\nstart_new_sequence(&prev, &num, get_block_num(unp, j));\r\n}\r\n}\r\nprint_sequence(prev, num);\r\nprintk("]\n");\r\n}\r\nstatic void indirect_check_item(struct item_head *ih, char *item)\r\n{\r\n}\r\nstatic int indirect_create_vi(struct virtual_node *vn,\r\nstruct virtual_item *vi,\r\nint is_affected, int insert_size)\r\n{\r\nvi->vi_index = TYPE_INDIRECT;\r\nreturn 0;\r\n}\r\nstatic int indirect_check_left(struct virtual_item *vi, int free,\r\nint start_skip, int end_skip)\r\n{\r\nint bytes;\r\nbytes = free - free % UNFM_P_SIZE;\r\nreturn bytes ? : -1;\r\n}\r\nstatic int indirect_check_right(struct virtual_item *vi, int free)\r\n{\r\nreturn indirect_check_left(vi, free, 0, 0);\r\n}\r\nstatic int indirect_part_size(struct virtual_item *vi, int first, int units)\r\n{\r\nreturn units;\r\n}\r\nstatic int indirect_unit_num(struct virtual_item *vi)\r\n{\r\nreturn vi->vi_item_len - IH_SIZE;\r\n}\r\nstatic void indirect_print_vi(struct virtual_item *vi)\r\n{\r\nreiserfs_warning(NULL, "reiserfs-16103",\r\n"INDIRECT, index %d, type 0x%x, %h",\r\nvi->vi_index, vi->vi_type, vi->vi_ih);\r\n}\r\nstatic int direntry_bytes_number(struct item_head *ih, int block_size)\r\n{\r\nreiserfs_warning(NULL, "vs-16090",\r\n"bytes number is asked for direntry");\r\nreturn 0;\r\n}\r\nstatic void direntry_decrement_key(struct cpu_key *key)\r\n{\r\ncpu_key_k_offset_dec(key);\r\nif (cpu_key_k_offset(key) == 0)\r\nset_cpu_key_k_type(key, TYPE_STAT_DATA);\r\n}\r\nstatic int direntry_is_left_mergeable(struct reiserfs_key *key,\r\nunsigned long bsize)\r\n{\r\nif (le32_to_cpu(key->u.k_offset_v1.k_offset) == DOT_OFFSET)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void direntry_print_item(struct item_head *ih, char *item)\r\n{\r\nint i;\r\nint namelen;\r\nstruct reiserfs_de_head *deh;\r\nchar *name;\r\nstatic char namebuf[80];\r\nprintk("\n # %-15s%-30s%-15s%-15s%-15s\n", "Name",\r\n"Key of pointed object", "Hash", "Gen number", "Status");\r\ndeh = (struct reiserfs_de_head *)item;\r\nfor (i = 0; i < I_ENTRY_COUNT(ih); i++, deh++) {\r\nnamelen =\r\n(i ? (deh_location(deh - 1)) : ih_item_len(ih)) -\r\ndeh_location(deh);\r\nname = item + deh_location(deh);\r\nif (name[namelen - 1] == 0)\r\nnamelen = strlen(name);\r\nnamebuf[0] = '"';\r\nif (namelen > sizeof(namebuf) - 3) {\r\nstrncpy(namebuf + 1, name, sizeof(namebuf) - 3);\r\nnamebuf[sizeof(namebuf) - 2] = '"';\r\nnamebuf[sizeof(namebuf) - 1] = 0;\r\n} else {\r\nmemcpy(namebuf + 1, name, namelen);\r\nnamebuf[namelen + 1] = '"';\r\nnamebuf[namelen + 2] = 0;\r\n}\r\nprintk("%d: %-15s%-15d%-15d%-15Ld%-15Ld(%s)\n",\r\ni, namebuf,\r\ndeh_dir_id(deh), deh_objectid(deh),\r\nGET_HASH_VALUE(deh_offset(deh)),\r\nGET_GENERATION_NUMBER((deh_offset(deh))),\r\n(de_hidden(deh)) ? "HIDDEN" : "VISIBLE");\r\n}\r\n}\r\nstatic void direntry_check_item(struct item_head *ih, char *item)\r\n{\r\nint i;\r\nstruct reiserfs_de_head *deh;\r\ndeh = (struct reiserfs_de_head *)item;\r\nfor (i = 0; i < I_ENTRY_COUNT(ih); i++, deh++) {\r\n;\r\n}\r\n}\r\nstatic inline int old_entry_num(int is_affected, int virtual_entry_num,\r\nint pos_in_item, int mode)\r\n{\r\nif (mode == M_INSERT || mode == M_DELETE)\r\nreturn virtual_entry_num;\r\nif (!is_affected)\r\nreturn virtual_entry_num;\r\nif (virtual_entry_num < pos_in_item)\r\nreturn virtual_entry_num;\r\nif (mode == M_CUT)\r\nreturn virtual_entry_num + 1;\r\nRFALSE(mode != M_PASTE || virtual_entry_num == 0,\r\n"vs-8015: old_entry_num: mode must be M_PASTE (mode = \'%c\'",\r\nmode);\r\nreturn virtual_entry_num - 1;\r\n}\r\nstatic int direntry_create_vi(struct virtual_node *vn,\r\nstruct virtual_item *vi,\r\nint is_affected, int insert_size)\r\n{\r\nstruct direntry_uarea *dir_u = vi->vi_uarea;\r\nint i, j;\r\nint size = sizeof(struct direntry_uarea);\r\nstruct reiserfs_de_head *deh;\r\nvi->vi_index = TYPE_DIRENTRY;\r\nBUG_ON(!(vi->vi_ih) || !vi->vi_item);\r\ndir_u->flags = 0;\r\nif (le_ih_k_offset(vi->vi_ih) == DOT_OFFSET)\r\ndir_u->flags |= DIRENTRY_VI_FIRST_DIRENTRY_ITEM;\r\ndeh = (struct reiserfs_de_head *)(vi->vi_item);\r\ndir_u->entry_count = ih_entry_count(vi->vi_ih) +\r\n((is_affected) ? ((vn->vn_mode == M_CUT) ? -1 :\r\n(vn->vn_mode == M_PASTE ? 1 : 0)) : 0);\r\nfor (i = 0; i < dir_u->entry_count; i++) {\r\nj = old_entry_num(is_affected, i, vn->vn_pos_in_item,\r\nvn->vn_mode);\r\ndir_u->entry_sizes[i] =\r\n(j ? deh_location(&(deh[j - 1])) : ih_item_len(vi->vi_ih)) -\r\ndeh_location(&(deh[j])) + DEH_SIZE;\r\n}\r\nsize += (dir_u->entry_count * sizeof(short));\r\nif (is_affected && vn->vn_mode == M_PASTE)\r\ndir_u->entry_sizes[vn->vn_pos_in_item] = insert_size;\r\n#ifdef CONFIG_REISERFS_CHECK\r\n{\r\nint k, l;\r\nl = 0;\r\nfor (k = 0; k < dir_u->entry_count; k++)\r\nl += dir_u->entry_sizes[k];\r\nif (l + IH_SIZE != vi->vi_item_len +\r\n((is_affected\r\n&& (vn->vn_mode == M_PASTE\r\n|| vn->vn_mode == M_CUT)) ? insert_size : 0)) {\r\nreiserfs_panic(NULL, "vs-8025", "(mode==%c, "\r\n"insert_size==%d), invalid length of "\r\n"directory item",\r\nvn->vn_mode, insert_size);\r\n}\r\n}\r\n#endif\r\nreturn size;\r\n}\r\nstatic int direntry_check_left(struct virtual_item *vi, int free,\r\nint start_skip, int end_skip)\r\n{\r\nint i;\r\nint entries = 0;\r\nstruct direntry_uarea *dir_u = vi->vi_uarea;\r\nfor (i = start_skip; i < dir_u->entry_count - end_skip; i++) {\r\nif (dir_u->entry_sizes[i] > free)\r\nbreak;\r\nfree -= dir_u->entry_sizes[i];\r\nentries++;\r\n}\r\nif (entries == dir_u->entry_count) {\r\nreiserfs_panic(NULL, "item_ops-1",\r\n"free space %d, entry_count %d", free,\r\ndir_u->entry_count);\r\n}\r\nif (start_skip == 0 && (dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)\r\n&& entries < 2)\r\nentries = 0;\r\nreturn entries ? : -1;\r\n}\r\nstatic int direntry_check_right(struct virtual_item *vi, int free)\r\n{\r\nint i;\r\nint entries = 0;\r\nstruct direntry_uarea *dir_u = vi->vi_uarea;\r\nfor (i = dir_u->entry_count - 1; i >= 0; i--) {\r\nif (dir_u->entry_sizes[i] > free)\r\nbreak;\r\nfree -= dir_u->entry_sizes[i];\r\nentries++;\r\n}\r\nBUG_ON(entries == dir_u->entry_count);\r\nif ((dir_u->flags & DIRENTRY_VI_FIRST_DIRENTRY_ITEM)\r\n&& entries > dir_u->entry_count - 2)\r\nentries = dir_u->entry_count - 2;\r\nreturn entries ? : -1;\r\n}\r\nstatic int direntry_part_size(struct virtual_item *vi, int first, int count)\r\n{\r\nint i, retval;\r\nint from, to;\r\nstruct direntry_uarea *dir_u = vi->vi_uarea;\r\nretval = 0;\r\nif (first == 0)\r\nfrom = 0;\r\nelse\r\nfrom = dir_u->entry_count - count;\r\nto = from + count - 1;\r\nfor (i = from; i <= to; i++)\r\nretval += dir_u->entry_sizes[i];\r\nreturn retval;\r\n}\r\nstatic int direntry_unit_num(struct virtual_item *vi)\r\n{\r\nstruct direntry_uarea *dir_u = vi->vi_uarea;\r\nreturn dir_u->entry_count;\r\n}\r\nstatic void direntry_print_vi(struct virtual_item *vi)\r\n{\r\nint i;\r\nstruct direntry_uarea *dir_u = vi->vi_uarea;\r\nreiserfs_warning(NULL, "reiserfs-16104",\r\n"DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",\r\nvi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);\r\nprintk("%d entries: ", dir_u->entry_count);\r\nfor (i = 0; i < dir_u->entry_count; i++)\r\nprintk("%d ", dir_u->entry_sizes[i]);\r\nprintk("\n");\r\n}\r\nstatic int errcatch_bytes_number(struct item_head *ih, int block_size)\r\n{\r\nreiserfs_warning(NULL, "green-16001",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn 0;\r\n}\r\nstatic void errcatch_decrement_key(struct cpu_key *key)\r\n{\r\nreiserfs_warning(NULL, "green-16002",\r\n"Invalid item type observed, run fsck ASAP");\r\n}\r\nstatic int errcatch_is_left_mergeable(struct reiserfs_key *key,\r\nunsigned long bsize)\r\n{\r\nreiserfs_warning(NULL, "green-16003",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn 0;\r\n}\r\nstatic void errcatch_print_item(struct item_head *ih, char *item)\r\n{\r\nreiserfs_warning(NULL, "green-16004",\r\n"Invalid item type observed, run fsck ASAP");\r\n}\r\nstatic void errcatch_check_item(struct item_head *ih, char *item)\r\n{\r\nreiserfs_warning(NULL, "green-16005",\r\n"Invalid item type observed, run fsck ASAP");\r\n}\r\nstatic int errcatch_create_vi(struct virtual_node *vn,\r\nstruct virtual_item *vi,\r\nint is_affected, int insert_size)\r\n{\r\nreiserfs_warning(NULL, "green-16006",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn 0;\r\n}\r\nstatic int errcatch_check_left(struct virtual_item *vi, int free,\r\nint start_skip, int end_skip)\r\n{\r\nreiserfs_warning(NULL, "green-16007",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn -1;\r\n}\r\nstatic int errcatch_check_right(struct virtual_item *vi, int free)\r\n{\r\nreiserfs_warning(NULL, "green-16008",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn -1;\r\n}\r\nstatic int errcatch_part_size(struct virtual_item *vi, int first, int count)\r\n{\r\nreiserfs_warning(NULL, "green-16009",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn 0;\r\n}\r\nstatic int errcatch_unit_num(struct virtual_item *vi)\r\n{\r\nreiserfs_warning(NULL, "green-16010",\r\n"Invalid item type observed, run fsck ASAP");\r\nreturn 0;\r\n}\r\nstatic void errcatch_print_vi(struct virtual_item *vi)\r\n{\r\nreiserfs_warning(NULL, "green-16011",\r\n"Invalid item type observed, run fsck ASAP");\r\n}
