static inline void set_cpu_wakeup_addr(unsigned int cpu_id, u32 addr)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\n__raw_writel(addr, pm_info->wkup_sar_addr);\r\n}\r\nstatic inline void set_cpu_next_pwrst(unsigned int cpu_id,\r\nunsigned int power_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, power_state);\r\n}\r\nstatic inline unsigned int read_cpu_prev_pwrst(unsigned int cpu_id)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\nreturn pwrdm_read_prev_pwrst(pm_info->pwrdm);\r\n}\r\nstatic inline void clear_cpu_prev_pwrst(unsigned int cpu_id)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\npwrdm_clear_all_prev_pwrst(pm_info->pwrdm);\r\n}\r\nstatic void scu_pwrst_prepare(unsigned int cpu_id, unsigned int cpu_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\nu32 scu_pwr_st;\r\nswitch (cpu_state) {\r\ncase PWRDM_POWER_RET:\r\nscu_pwr_st = SCU_PM_DORMANT;\r\nbreak;\r\ncase PWRDM_POWER_OFF:\r\nscu_pwr_st = SCU_PM_POWEROFF;\r\nbreak;\r\ncase PWRDM_POWER_ON:\r\ncase PWRDM_POWER_INACTIVE:\r\ndefault:\r\nscu_pwr_st = SCU_PM_NORMAL;\r\nbreak;\r\n}\r\n__raw_writel(scu_pwr_st, pm_info->scu_sar_addr);\r\n}\r\nstatic inline void mpuss_clear_prev_logic_pwrst(void)\r\n{\r\nu32 reg;\r\nreg = omap4_prminst_read_inst_reg(OMAP4430_PRM_PARTITION,\r\nOMAP4430_PRM_MPU_INST, OMAP4_RM_MPU_MPU_CONTEXT_OFFSET);\r\nomap4_prminst_write_inst_reg(reg, OMAP4430_PRM_PARTITION,\r\nOMAP4430_PRM_MPU_INST, OMAP4_RM_MPU_MPU_CONTEXT_OFFSET);\r\n}\r\nstatic inline void cpu_clear_prev_logic_pwrst(unsigned int cpu_id)\r\n{\r\nu32 reg;\r\nif (cpu_id) {\r\nreg = omap4_prcm_mpu_read_inst_reg(OMAP4430_PRCM_MPU_CPU1_INST,\r\nOMAP4_RM_CPU1_CPU1_CONTEXT_OFFSET);\r\nomap4_prcm_mpu_write_inst_reg(reg, OMAP4430_PRCM_MPU_CPU1_INST,\r\nOMAP4_RM_CPU1_CPU1_CONTEXT_OFFSET);\r\n} else {\r\nreg = omap4_prcm_mpu_read_inst_reg(OMAP4430_PRCM_MPU_CPU0_INST,\r\nOMAP4_RM_CPU0_CPU0_CONTEXT_OFFSET);\r\nomap4_prcm_mpu_write_inst_reg(reg, OMAP4430_PRCM_MPU_CPU0_INST,\r\nOMAP4_RM_CPU0_CPU0_CONTEXT_OFFSET);\r\n}\r\n}\r\nu32 omap4_mpuss_read_prev_context_state(void)\r\n{\r\nu32 reg;\r\nreg = omap4_prminst_read_inst_reg(OMAP4430_PRM_PARTITION,\r\nOMAP4430_PRM_MPU_INST, OMAP4_RM_MPU_MPU_CONTEXT_OFFSET);\r\nreg &= OMAP4430_LOSTCONTEXT_DFF_MASK;\r\nreturn reg;\r\n}\r\nstatic void l2x0_pwrst_prepare(unsigned int cpu_id, unsigned int save_state)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\r\n__raw_writel(save_state, pm_info->l2x0_sar_addr);\r\n}\r\nstatic void save_l2x0_context(void)\r\n{\r\nu32 val;\r\nvoid __iomem *l2x0_base = omap4_get_l2cache_base();\r\nval = __raw_readl(l2x0_base + L2X0_AUX_CTRL);\r\n__raw_writel(val, sar_base + L2X0_AUXCTRL_OFFSET);\r\nval = __raw_readl(l2x0_base + L2X0_PREFETCH_CTRL);\r\n__raw_writel(val, sar_base + L2X0_PREFETCH_CTRL_OFFSET);\r\n}\r\nstatic void save_l2x0_context(void)\r\n{}\r\nint omap4_enter_lowpower(unsigned int cpu, unsigned int power_state)\r\n{\r\nunsigned int save_state = 0;\r\nunsigned int wakeup_cpu;\r\nif (omap_rev() == OMAP4430_REV_ES1_0)\r\nreturn -ENXIO;\r\nswitch (power_state) {\r\ncase PWRDM_POWER_ON:\r\ncase PWRDM_POWER_INACTIVE:\r\nsave_state = 0;\r\nbreak;\r\ncase PWRDM_POWER_OFF:\r\nsave_state = 1;\r\nbreak;\r\ncase PWRDM_POWER_RET:\r\ndefault:\r\nWARN_ON(1);\r\nreturn -ENXIO;\r\n}\r\npwrdm_pre_transition();\r\nmpuss_clear_prev_logic_pwrst();\r\nif ((pwrdm_read_next_pwrst(mpuss_pd) == PWRDM_POWER_RET) &&\r\n(pwrdm_read_logic_retst(mpuss_pd) == PWRDM_POWER_OFF))\r\nsave_state = 2;\r\ncpu_clear_prev_logic_pwrst(cpu);\r\nset_cpu_next_pwrst(cpu, power_state);\r\nset_cpu_wakeup_addr(cpu, virt_to_phys(omap4_cpu_resume));\r\nscu_pwrst_prepare(cpu, power_state);\r\nl2x0_pwrst_prepare(cpu, save_state);\r\ncpu_suspend(save_state, omap4_finish_suspend);\r\nwakeup_cpu = smp_processor_id();\r\nset_cpu_next_pwrst(wakeup_cpu, PWRDM_POWER_ON);\r\npwrdm_post_transition();\r\nreturn 0;\r\n}\r\nint __cpuinit omap4_hotplug_cpu(unsigned int cpu, unsigned int power_state)\r\n{\r\nunsigned int cpu_state = 0;\r\nif (omap_rev() == OMAP4430_REV_ES1_0)\r\nreturn -ENXIO;\r\nif (power_state == PWRDM_POWER_OFF)\r\ncpu_state = 1;\r\nclear_cpu_prev_pwrst(cpu);\r\nset_cpu_next_pwrst(cpu, power_state);\r\nset_cpu_wakeup_addr(cpu, virt_to_phys(omap_secondary_startup));\r\nscu_pwrst_prepare(cpu, power_state);\r\nomap4_finish_suspend(cpu_state);\r\nset_cpu_next_pwrst(cpu, PWRDM_POWER_ON);\r\nreturn 0;\r\n}\r\nint __init omap4_mpuss_init(void)\r\n{\r\nstruct omap4_cpu_pm_info *pm_info;\r\nif (omap_rev() == OMAP4430_REV_ES1_0) {\r\nWARN(1, "Power Management not supported on OMAP4430 ES1.0\n");\r\nreturn -ENODEV;\r\n}\r\nsar_base = omap4_get_sar_ram_base();\r\npm_info = &per_cpu(omap4_pm_info, 0x0);\r\npm_info->scu_sar_addr = sar_base + SCU_OFFSET0;\r\npm_info->wkup_sar_addr = sar_base + CPU0_WAKEUP_NS_PA_ADDR_OFFSET;\r\npm_info->l2x0_sar_addr = sar_base + L2X0_SAVE_OFFSET0;\r\npm_info->pwrdm = pwrdm_lookup("cpu0_pwrdm");\r\nif (!pm_info->pwrdm) {\r\npr_err("Lookup failed for CPU0 pwrdm\n");\r\nreturn -ENODEV;\r\n}\r\npwrdm_clear_all_prev_pwrst(pm_info->pwrdm);\r\ncpu_clear_prev_logic_pwrst(0);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, PWRDM_POWER_ON);\r\npm_info = &per_cpu(omap4_pm_info, 0x1);\r\npm_info->scu_sar_addr = sar_base + SCU_OFFSET1;\r\npm_info->wkup_sar_addr = sar_base + CPU1_WAKEUP_NS_PA_ADDR_OFFSET;\r\npm_info->l2x0_sar_addr = sar_base + L2X0_SAVE_OFFSET1;\r\npm_info->pwrdm = pwrdm_lookup("cpu1_pwrdm");\r\nif (!pm_info->pwrdm) {\r\npr_err("Lookup failed for CPU1 pwrdm\n");\r\nreturn -ENODEV;\r\n}\r\npwrdm_clear_all_prev_pwrst(pm_info->pwrdm);\r\ncpu_clear_prev_logic_pwrst(1);\r\npwrdm_set_next_pwrst(pm_info->pwrdm, PWRDM_POWER_ON);\r\nmpuss_pd = pwrdm_lookup("mpu_pwrdm");\r\nif (!mpuss_pd) {\r\npr_err("Failed to lookup MPUSS power domain\n");\r\nreturn -ENODEV;\r\n}\r\npwrdm_clear_all_prev_pwrst(mpuss_pd);\r\nmpuss_clear_prev_logic_pwrst();\r\nif (omap_type() != OMAP2_DEVICE_TYPE_GP)\r\n__raw_writel(1, sar_base + OMAP_TYPE_OFFSET);\r\nelse\r\n__raw_writel(0, sar_base + OMAP_TYPE_OFFSET);\r\nsave_l2x0_context();\r\nreturn 0;\r\n}
