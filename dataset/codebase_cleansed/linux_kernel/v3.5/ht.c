static __inline__ int check_titan_htlink(void)\r\n{\r\nu32 val;\r\nval = *(volatile uint32_t *)(RM9000x2_HTLINK_REG);\r\nif (val & 0x00000020)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int titan_ht_config_read_dword(struct pci_dev *device,\r\nint offset, u32* val)\r\n{\r\nint dev, bus, func;\r\nuint32_t address_reg, data_reg;\r\nuint32_t address;\r\nbus = device->bus->number;\r\ndev = PCI_SLOT(device->devfn);\r\nfunc = PCI_FUNC(device->devfn);\r\nif (bus > 2)\r\naddress = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |\r\n0x80000000 | 0x1;\r\nelse\r\naddress = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;\r\naddress_reg = RM9000x2_OCD_HTCFGA;\r\ndata_reg = RM9000x2_OCD_HTCFGD;\r\nRM9K_WRITE(address_reg, address);\r\nRM9K_READ(data_reg, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int titan_ht_config_read_word(struct pci_dev *device,\r\nint offset, u16* val)\r\n{\r\nint dev, bus, func;\r\nuint32_t address_reg, data_reg;\r\nuint32_t address;\r\nbus = device->bus->number;\r\ndev = PCI_SLOT(device->devfn);\r\nfunc = PCI_FUNC(device->devfn);\r\nif (bus > 2)\r\naddress = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |\r\n0x80000000 | 0x1;\r\nelse\r\naddress = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;\r\naddress_reg = RM9000x2_OCD_HTCFGA;\r\ndata_reg = RM9000x2_OCD_HTCFGD;\r\nif ((offset & 0x3) == 0)\r\noffset = 0x2;\r\nelse\r\noffset = 0x0;\r\nRM9K_WRITE(address_reg, address);\r\nRM9K_READ_16(data_reg + offset, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nu32 longswap(unsigned long l)\r\n{\r\nunsigned char b1, b2, b3, b4;\r\nb1 = l&255;\r\nb2 = (l>>8)&255;\r\nb3 = (l>>16)&255;\r\nb4 = (l>>24)&255;\r\nreturn ((b1<<24) + (b2<<16) + (b3<<8) + b4);\r\n}\r\nstatic int titan_ht_config_read_byte(struct pci_dev *device,\r\nint offset, u8* val)\r\n{\r\nint dev, bus, func;\r\nuint32_t address_reg, data_reg;\r\nuint32_t address;\r\nint offset1;\r\nbus = device->bus->number;\r\ndev = PCI_SLOT(device->devfn);\r\nfunc = PCI_FUNC(device->devfn);\r\nif (bus > 2)\r\naddress = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |\r\n0x80000000 | 0x1;\r\nelse\r\naddress = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;\r\naddress_reg = RM9000x2_OCD_HTCFGA;\r\ndata_reg = RM9000x2_OCD_HTCFGD;\r\nRM9K_WRITE(address_reg, address);\r\nif ((offset & 0x3) == 0) {\r\noffset1 = 0x3;\r\n}\r\nif ((offset & 0x3) == 1) {\r\noffset1 = 0x2;\r\n}\r\nif ((offset & 0x3) == 2) {\r\noffset1 = 0x1;\r\n}\r\nif ((offset & 0x3) == 3) {\r\noffset1 = 0x0;\r\n}\r\nRM9K_READ_8(data_reg + offset1, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int titan_ht_config_write_dword(struct pci_dev *device,\r\nint offset, u8 val)\r\n{\r\nint dev, bus, func;\r\nuint32_t address_reg, data_reg;\r\nuint32_t address;\r\nbus = device->bus->number;\r\ndev = PCI_SLOT(device->devfn);\r\nfunc = PCI_FUNC(device->devfn);\r\nif (bus > 2)\r\naddress = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |\r\n0x80000000 | 0x1;\r\nelse\r\naddress = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;\r\naddress_reg = RM9000x2_OCD_HTCFGA;\r\ndata_reg = RM9000x2_OCD_HTCFGD;\r\nRM9K_WRITE(address_reg, address);\r\nRM9K_WRITE(data_reg, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int titan_ht_config_write_word(struct pci_dev *device,\r\nint offset, u8 val)\r\n{\r\nint dev, bus, func;\r\nuint32_t address_reg, data_reg;\r\nuint32_t address;\r\nbus = device->bus->number;\r\ndev = PCI_SLOT(device->devfn);\r\nfunc = PCI_FUNC(device->devfn);\r\nif (bus > 2)\r\naddress = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |\r\n0x80000000 | 0x1;\r\nelse\r\naddress = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;\r\naddress_reg = RM9000x2_OCD_HTCFGA;\r\ndata_reg = RM9000x2_OCD_HTCFGD;\r\nif ((offset & 0x3) == 0)\r\noffset = 0x2;\r\nelse\r\noffset = 0x0;\r\nRM9K_WRITE(address_reg, address);\r\nRM9K_WRITE_16(data_reg + offset, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int titan_ht_config_write_byte(struct pci_dev *device,\r\nint offset, u8 val)\r\n{\r\nint dev, bus, func;\r\nuint32_t address_reg, data_reg;\r\nuint32_t address;\r\nint offset1;\r\nbus = device->bus->number;\r\ndev = PCI_SLOT(device->devfn);\r\nfunc = PCI_FUNC(device->devfn);\r\nif (bus > 2)\r\naddress = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |\r\n0x80000000 | 0x1;\r\nelse\r\naddress = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;\r\naddress_reg = RM9000x2_OCD_HTCFGA;\r\ndata_reg = RM9000x2_OCD_HTCFGD;\r\nRM9K_WRITE(address_reg, address);\r\nif ((offset & 0x3) == 0) {\r\noffset1 = 0x3;\r\n}\r\nif ((offset & 0x3) == 1) {\r\noffset1 = 0x2;\r\n}\r\nif ((offset & 0x3) == 2) {\r\noffset1 = 0x1;\r\n}\r\nif ((offset & 0x3) == 3) {\r\noffset1 = 0x0;\r\n}\r\nRM9K_WRITE_8(data_reg + offset1, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void titan_pcibios_set_master(struct pci_dev *dev)\r\n{\r\nu16 cmd;\r\nint bus = dev->bus->number;\r\nif (check_titan_htlink())\r\ntitan_ht_config_read_word(dev, PCI_COMMAND, &cmd);\r\ncmd |= PCI_COMMAND_MASTER;\r\nif (check_titan_htlink())\r\ntitan_ht_config_write_word(dev, PCI_COMMAND, cmd);\r\n}\r\nint pcibios_enable_resources(struct pci_dev *dev)\r\n{\r\nu16 cmd, old_cmd;\r\nu8 tmp1;\r\nint idx;\r\nstruct resource *r;\r\nint bus = dev->bus->number;\r\nif (check_titan_htlink())\r\ntitan_ht_config_read_word(dev, PCI_COMMAND, &cmd);\r\nold_cmd = cmd;\r\nfor (idx = 0; idx < 6; idx++) {\r\nr = &dev->resource[idx];\r\nif (!r->start && r->end) {\r\nprintk(KERN_ERR\r\n"PCI: Device %s not available because of "\r\n"resource collisions\n", pci_name(dev));\r\nreturn -EINVAL;\r\n}\r\nif (r->flags & IORESOURCE_IO)\r\ncmd |= PCI_COMMAND_IO;\r\nif (r->flags & IORESOURCE_MEM)\r\ncmd |= PCI_COMMAND_MEMORY;\r\n}\r\nif (cmd != old_cmd) {\r\nif (check_titan_htlink())\r\ntitan_ht_config_write_word(dev, PCI_COMMAND, cmd);\r\n}\r\nif (check_titan_htlink())\r\ntitan_ht_config_read_byte(dev, PCI_CACHE_LINE_SIZE, &tmp1);\r\nif (tmp1 != 8) {\r\nprintk(KERN_WARNING "PCI setting cache line size to 8 from "\r\n"%d\n", tmp1);\r\n}\r\nif (check_titan_htlink())\r\ntitan_ht_config_write_byte(dev, PCI_CACHE_LINE_SIZE, 8);\r\nif (check_titan_htlink())\r\ntitan_ht_config_read_byte(dev, PCI_LATENCY_TIMER, &tmp1);\r\nif (tmp1 < 32 || tmp1 == 0xff) {\r\nprintk(KERN_WARNING "PCI setting latency timer to 32 from %d\n",\r\ntmp1);\r\n}\r\nif (check_titan_htlink())\r\ntitan_ht_config_write_byte(dev, PCI_LATENCY_TIMER, 32);\r\nreturn 0;\r\n}\r\nint pcibios_enable_device(struct pci_dev *dev, int mask)\r\n{\r\nreturn pcibios_enable_resources(dev);\r\n}\r\nresource_size_t pcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nstruct pci_dev *dev = data;\r\nresource_size_t start = res->start;\r\nif (res->flags & IORESOURCE_IO) {\r\nif (size > 0x100) {\r\nprintk(KERN_ERR "PCI: I/O Region %s/%d too large"\r\n" (%ld bytes)\n", pci_name(dev),\r\ndev->resource - res, size);\r\n}\r\nstart = (start + 1024 - 1) & ~(1024 - 1);\r\n}\r\nreturn start;\r\n}\r\nvoid __init pcibios_fixup_bus(struct pci_bus *c)\r\n{\r\ntitan_ht_pcibios_fixup_bus(c);\r\n}\r\nvoid __init pcibios_init(void)\r\n{\r\nioport_resource.start = 0xe0000000;\r\nioport_resource.end = 0xe0000000 + 0x20000000 - 1;\r\niomem_resource.start = 0xc0000000;\r\niomem_resource.end = 0xc0000000 + 0x20000000 - 1;\r\npci_scan_bus(2, &titan_pci_ops, NULL);\r\npci_scan_bus(3, &titan_pci_ops, NULL);\r\n}\r\nchar *pcibios_setup(char *str)\r\n{\r\nprintk(KERN_INFO "rr: pcibios_setup\n");\r\nreturn str;\r\n}\r\nunsigned __init int pcibios_assign_all_busses(void)\r\n{\r\nreturn 0;\r\n}
