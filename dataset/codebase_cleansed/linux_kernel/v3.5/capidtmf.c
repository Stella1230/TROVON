static void capidtmf_goertzel_loop(long *buffer, long *coeffs, short *sample, long count)\r\n{\r\nint i, j;\r\nlong c, d, q0, q1, q2;\r\nfor (i = 0; i < CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT - 1; i++)\r\n{\r\nq1 = buffer[i];\r\nq2 = buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT];\r\nd = coeffs[i] >> 1;\r\nc = d << 1;\r\nif (c >= 0)\r\n{\r\nfor (j = 0; j < count; j++)\r\n{\r\nq0 = sample[j] - q2 + (c * (q1 >> 16)) + (((dword)(((dword) d) * ((dword)(q1 & 0xffff)))) >> 15);\r\nq2 = q1;\r\nq1 = q0;\r\n}\r\n}\r\nelse\r\n{\r\nc = -c;\r\nd = -d;\r\nfor (j = 0; j < count; j++)\r\n{\r\nq0 = sample[j] - q2 - ((c * (q1 >> 16)) + (((dword)(((dword) d) * ((dword)(q1 & 0xffff)))) >> 15));\r\nq2 = q1;\r\nq1 = q0;\r\n}\r\n}\r\nbuffer[i] = q1;\r\nbuffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT] = q2;\r\n}\r\nq1 = buffer[i];\r\nq2 = buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT];\r\nc = (coeffs[i] >> 1) << 1;\r\nif (c >= 0)\r\n{\r\nfor (j = 0; j < count; j++)\r\n{\r\nq0 = sample[j] - q2 + (c * (q1 >> 16)) + (((dword)(((dword)(c >> 1)) * ((dword)(q1 & 0xffff)))) >> 15);\r\nq2 = q1;\r\nq1 = q0;\r\nc -= CAPIDTMF_RECV_FUNDAMENTAL_DECREMENT;\r\n}\r\n}\r\nelse\r\n{\r\nc = -c;\r\nfor (j = 0; j < count; j++)\r\n{\r\nq0 = sample[j] - q2 - ((c * (q1 >> 16)) + (((dword)(((dword)(c >> 1)) * ((dword)(q1 & 0xffff)))) >> 15));\r\nq2 = q1;\r\nq1 = q0;\r\nc += CAPIDTMF_RECV_FUNDAMENTAL_DECREMENT;\r\n}\r\n}\r\ncoeffs[i] = c;\r\nbuffer[i] = q1;\r\nbuffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT] = q2;\r\n}\r\nstatic void capidtmf_goertzel_result(long *buffer, long *coeffs)\r\n{\r\nint i;\r\nlong d, e, q1, q2, lo, mid, hi;\r\ndword k;\r\nfor (i = 0; i < CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT; i++)\r\n{\r\nq1 = buffer[i];\r\nq2 = buffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT];\r\nd = coeffs[i] >> 1;\r\nif (d >= 0)\r\nd = ((d << 1) * (-q1 >> 16)) + (((dword)(((dword) d) * ((dword)(-q1 & 0xffff)))) >> 15);\r\nelse\r\nd = ((-d << 1) * (-q1 >> 16)) + (((dword)(((dword) -d) * ((dword)(-q1 & 0xffff)))) >> 15);\r\ne = (q2 >= 0) ? q2 : -q2;\r\nif (d >= 0)\r\n{\r\nk = ((dword)(d & 0xffff)) * ((dword)(e & 0xffff));\r\nlo = k & 0xffff;\r\nmid = k >> 16;\r\nk = ((dword)(d >> 16)) * ((dword)(e & 0xffff));\r\nmid += k & 0xffff;\r\nhi = k >> 16;\r\nk = ((dword)(d & 0xffff)) * ((dword)(e >> 16));\r\nmid += k & 0xffff;\r\nhi += k >> 16;\r\nhi += ((dword)(d >> 16)) * ((dword)(e >> 16));\r\n}\r\nelse\r\n{\r\nd = -d;\r\nk = ((dword)(d & 0xffff)) * ((dword)(e & 0xffff));\r\nlo = -((long)(k & 0xffff));\r\nmid = -((long)(k >> 16));\r\nk = ((dword)(d >> 16)) * ((dword)(e & 0xffff));\r\nmid -= k & 0xffff;\r\nhi = -((long)(k >> 16));\r\nk = ((dword)(d & 0xffff)) * ((dword)(e >> 16));\r\nmid -= k & 0xffff;\r\nhi -= k >> 16;\r\nhi -= ((dword)(d >> 16)) * ((dword)(e >> 16));\r\n}\r\nif (q2 < 0)\r\n{\r\nlo = -lo;\r\nmid = -mid;\r\nhi = -hi;\r\n}\r\nd = (q1 >= 0) ? q1 : -q1;\r\nk = ((dword)(d & 0xffff)) * ((dword)(d & 0xffff));\r\nlo += k & 0xffff;\r\nmid += k >> 16;\r\nk = ((dword)(d >> 16)) * ((dword)(d & 0xffff));\r\nmid += (k & 0xffff) << 1;\r\nhi += (k >> 16) << 1;\r\nhi += ((dword)(d >> 16)) * ((dword)(d >> 16));\r\nd = (q2 >= 0) ? q2 : -q2;\r\nk = ((dword)(d & 0xffff)) * ((dword)(d & 0xffff));\r\nlo += k & 0xffff;\r\nmid += k >> 16;\r\nk = ((dword)(d >> 16)) * ((dword)(d & 0xffff));\r\nmid += (k & 0xffff) << 1;\r\nhi += (k >> 16) << 1;\r\nhi += ((dword)(d >> 16)) * ((dword)(d >> 16));\r\nmid += lo >> 16;\r\nhi += mid >> 16;\r\nbuffer[i] = (lo & 0xffff) | (mid << 16);\r\nbuffer[i + CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT] = hi;\r\n}\r\n}\r\nstatic void capidtmf_recv_init(t_capidtmf_state *p_state)\r\n{\r\np_state->recv.min_gap_duration = 1;\r\np_state->recv.min_digit_duration = 1;\r\np_state->recv.cycle_counter = 0;\r\np_state->recv.current_digit_on_time = 0;\r\np_state->recv.current_digit_off_time = 0;\r\np_state->recv.current_digit_value = CAPIDTMF_RECV_NO_DIGIT;\r\np_state->recv.digit_write_pos = 0;\r\np_state->recv.digit_read_pos = 0;\r\np_state->recv.indication_state = 0;\r\np_state->recv.indication_state_ack = 0;\r\np_state->recv.state = CAPIDTMF_RECV_STATE_IDLE;\r\n}\r\nvoid capidtmf_recv_enable(t_capidtmf_state *p_state, word min_digit_duration, word min_gap_duration)\r\n{\r\np_state->recv.indication_state_ack &= CAPIDTMF_RECV_INDICATION_DIGIT;\r\np_state->recv.min_digit_duration = (word)(((((dword) min_digit_duration) * 8) +\r\n((dword)(CAPIDTMF_RECV_TIME_GRANULARITY / 2))) / ((dword) CAPIDTMF_RECV_TIME_GRANULARITY));\r\nif (p_state->recv.min_digit_duration <= 1)\r\np_state->recv.min_digit_duration = 1;\r\nelse\r\n(p_state->recv.min_digit_duration)--;\r\np_state->recv.min_gap_duration =\r\n(word)((((dword) min_gap_duration) * 8) / ((dword) CAPIDTMF_RECV_TIME_GRANULARITY));\r\nif (p_state->recv.min_gap_duration <= 1)\r\np_state->recv.min_gap_duration = 1;\r\nelse\r\n(p_state->recv.min_gap_duration)--;\r\np_state->recv.state |= CAPIDTMF_RECV_STATE_DTMF_ACTIVE;\r\n}\r\nvoid capidtmf_recv_disable(t_capidtmf_state *p_state)\r\n{\r\np_state->recv.state &= ~CAPIDTMF_RECV_STATE_DTMF_ACTIVE;\r\nif (p_state->recv.state == CAPIDTMF_RECV_STATE_IDLE)\r\ncapidtmf_recv_init(p_state);\r\nelse\r\n{\r\np_state->recv.cycle_counter = 0;\r\np_state->recv.current_digit_on_time = 0;\r\np_state->recv.current_digit_off_time = 0;\r\np_state->recv.current_digit_value = CAPIDTMF_RECV_NO_DIGIT;\r\n}\r\n}\r\nword capidtmf_recv_indication(t_capidtmf_state *p_state, byte *buffer)\r\n{\r\nword i, j, k, flags;\r\nflags = p_state->recv.indication_state ^ p_state->recv.indication_state_ack;\r\np_state->recv.indication_state_ack ^= flags & CAPIDTMF_RECV_INDICATION_DIGIT;\r\nif (p_state->recv.digit_write_pos != p_state->recv.digit_read_pos)\r\n{\r\ni = 0;\r\nk = p_state->recv.digit_write_pos;\r\nj = p_state->recv.digit_read_pos;\r\ndo\r\n{\r\nbuffer[i++] = p_state->recv.digit_buffer[j];\r\nj = (j == CAPIDTMF_RECV_DIGIT_BUFFER_SIZE - 1) ? 0 : j + 1;\r\n} while (j != k);\r\np_state->recv.digit_read_pos = k;\r\nreturn (i);\r\n}\r\np_state->recv.indication_state_ack ^= flags;\r\nreturn (0);\r\n}\r\nvoid capidtmf_recv_block(t_capidtmf_state *p_state, byte *buffer, word length)\r\n{\r\nbyte result_digit;\r\nword sample_number, cycle_counter, n, i;\r\nword low_peak, high_peak;\r\ndword lo, hi;\r\nbyte *p;\r\nshort *q;\r\nbyte goertzel_result_buffer[CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT];\r\nshort windowed_sample_buffer[CAPIDTMF_RECV_WINDOWED_SAMPLES];\r\nif (p_state->recv.state & CAPIDTMF_RECV_STATE_DTMF_ACTIVE)\r\n{\r\ncycle_counter = p_state->recv.cycle_counter;\r\nsample_number = 0;\r\nwhile (sample_number < length)\r\n{\r\nif (cycle_counter < CAPIDTMF_RECV_ACCUMULATE_CYCLES)\r\n{\r\nif (cycle_counter == 0)\r\n{\r\nfor (i = 0; i < CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT; i++)\r\n{\r\np_state->recv.goertzel_buffer[0][i] = 0;\r\np_state->recv.goertzel_buffer[1][i] = 0;\r\n}\r\n}\r\nn = CAPIDTMF_RECV_ACCUMULATE_CYCLES - cycle_counter;\r\nif (n > length - sample_number)\r\nn = length - sample_number;\r\nif (n > CAPIDTMF_RECV_WINDOWED_SAMPLES)\r\nn = CAPIDTMF_RECV_WINDOWED_SAMPLES;\r\np = buffer + sample_number;\r\nq = capidtmf_recv_window_function + cycle_counter;\r\nif (p_state->ulaw)\r\n{\r\nfor (i = 0; i < n; i++)\r\n{\r\nwindowed_sample_buffer[i] =\r\n(short)((capidtmf_expand_table_ulaw[p[i]] * ((long)(q[i]))) >> 15);\r\n}\r\n}\r\nelse\r\n{\r\nfor (i = 0; i < n; i++)\r\n{\r\nwindowed_sample_buffer[i] =\r\n(short)((capidtmf_expand_table_alaw[p[i]] * ((long)(q[i]))) >> 15);\r\n}\r\n}\r\ncapidtmf_recv_goertzel_coef_table[CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT - 1] = CAPIDTMF_RECV_FUNDAMENTAL_OFFSET;\r\ncapidtmf_goertzel_loop(p_state->recv.goertzel_buffer[0],\r\ncapidtmf_recv_goertzel_coef_table, windowed_sample_buffer, n);\r\ncycle_counter += n;\r\nsample_number += n;\r\n}\r\nelse\r\n{\r\ncapidtmf_goertzel_result(p_state->recv.goertzel_buffer[0],\r\ncapidtmf_recv_goertzel_coef_table);\r\nfor (i = 0; i < CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT; i++)\r\n{\r\nlo = (dword)(p_state->recv.goertzel_buffer[0][i]);\r\nhi = (dword)(p_state->recv.goertzel_buffer[1][i]);\r\nif (hi != 0)\r\n{\r\nn = capidtmf_dword_leading_zeroes(hi);\r\nhi = (hi << n) | (lo >> (32 - n));\r\n}\r\nelse\r\n{\r\nn = capidtmf_dword_leading_zeroes(lo);\r\nhi = lo << n;\r\nn += 32;\r\n}\r\nn = 195 - 3 * n;\r\nif (hi >= 0xcb300000L)\r\nn += 2;\r\nelse if (hi >= 0xa1450000L)\r\nn++;\r\ngoertzel_result_buffer[i] = (byte) n;\r\n}\r\nlow_peak = DSPDTMF_RX_SENSITIVITY_LOW_DEFAULT;\r\nresult_digit = CAPIDTMF_RECV_NO_DIGIT;\r\nfor (i = 0; i < CAPIDTMF_LOW_GROUP_FREQUENCIES; i++)\r\n{\r\nif (goertzel_result_buffer[i] > low_peak)\r\n{\r\nlow_peak = goertzel_result_buffer[i];\r\nresult_digit = (byte) i;\r\n}\r\n}\r\nhigh_peak = DSPDTMF_RX_SENSITIVITY_HIGH_DEFAULT;\r\nn = CAPIDTMF_RECV_NO_DIGIT;\r\nfor (i = CAPIDTMF_LOW_GROUP_FREQUENCIES; i < CAPIDTMF_RECV_BASE_FREQUENCY_COUNT; i++)\r\n{\r\nif (goertzel_result_buffer[i] > high_peak)\r\n{\r\nhigh_peak = goertzel_result_buffer[i];\r\nn = (i - CAPIDTMF_LOW_GROUP_FREQUENCIES) << 2;\r\n}\r\n}\r\nresult_digit |= (byte) n;\r\nif (low_peak + DSPDTMF_RX_HIGH_EXCEEDING_LOW_DEFAULT < high_peak)\r\nresult_digit = CAPIDTMF_RECV_NO_DIGIT;\r\nif (high_peak + DSPDTMF_RX_LOW_EXCEEDING_HIGH_DEFAULT < low_peak)\r\nresult_digit = CAPIDTMF_RECV_NO_DIGIT;\r\nn = 0;\r\nfor (i = 0; i < CAPIDTMF_RECV_TOTAL_FREQUENCY_COUNT; i++)\r\n{\r\nif ((((short)(low_peak - goertzel_result_buffer[i] - capidtmf_recv_guard_snr_low_table[i])) < 0)\r\n|| (((short)(high_peak - goertzel_result_buffer[i] - capidtmf_recv_guard_snr_high_table[i])) < 0))\r\n{\r\nn++;\r\n}\r\n}\r\nif (n != 2)\r\nresult_digit = CAPIDTMF_RECV_NO_DIGIT;\r\nif (result_digit == CAPIDTMF_RECV_NO_DIGIT)\r\n{\r\nif (p_state->recv.current_digit_on_time != 0)\r\n{\r\nif (++(p_state->recv.current_digit_off_time) >= p_state->recv.min_gap_duration)\r\n{\r\np_state->recv.current_digit_on_time = 0;\r\np_state->recv.current_digit_off_time = 0;\r\n}\r\n}\r\nelse\r\n{\r\nif (p_state->recv.current_digit_off_time != 0)\r\n(p_state->recv.current_digit_off_time)--;\r\n}\r\n}\r\nelse\r\n{\r\nif ((p_state->recv.current_digit_on_time == 0)\r\n&& (p_state->recv.current_digit_off_time != 0))\r\n{\r\n(p_state->recv.current_digit_off_time)--;\r\n}\r\nelse\r\n{\r\nn = p_state->recv.current_digit_off_time;\r\nif ((p_state->recv.current_digit_on_time != 0)\r\n&& (result_digit != p_state->recv.current_digit_value))\r\n{\r\np_state->recv.current_digit_on_time = 0;\r\nn = 0;\r\n}\r\np_state->recv.current_digit_value = result_digit;\r\np_state->recv.current_digit_off_time = 0;\r\nif (p_state->recv.current_digit_on_time != 0xffff)\r\n{\r\np_state->recv.current_digit_on_time += n + 1;\r\nif (p_state->recv.current_digit_on_time >= p_state->recv.min_digit_duration)\r\n{\r\np_state->recv.current_digit_on_time = 0xffff;\r\ni = (p_state->recv.digit_write_pos == CAPIDTMF_RECV_DIGIT_BUFFER_SIZE - 1) ?\r\n0 : p_state->recv.digit_write_pos + 1;\r\nif (i == p_state->recv.digit_read_pos)\r\n{\r\ntrace(dprintf("%s,%d: Receive digit overrun",\r\n(char *)(FILE_), __LINE__));\r\n}\r\nelse\r\n{\r\np_state->recv.digit_buffer[p_state->recv.digit_write_pos] = result_digit;\r\np_state->recv.digit_write_pos = i;\r\np_state->recv.indication_state =\r\n(p_state->recv.indication_state & ~CAPIDTMF_RECV_INDICATION_DIGIT) |\r\n(~p_state->recv.indication_state_ack & CAPIDTMF_RECV_INDICATION_DIGIT);\r\n}\r\n}\r\n}\r\n}\r\n}\r\ncycle_counter = 0;\r\nsample_number++;\r\n}\r\n}\r\np_state->recv.cycle_counter = cycle_counter;\r\n}\r\n}\r\nvoid capidtmf_init(t_capidtmf_state *p_state, byte ulaw)\r\n{\r\np_state->ulaw = ulaw;\r\ncapidtmf_recv_init(p_state);\r\n}
