static inline u32 chipco_write32_masked(struct ssb_chipcommon *cc, u16 offset,\r\nu32 mask, u32 value)\r\n{\r\nvalue &= mask;\r\nvalue |= chipco_read32(cc, offset) & ~mask;\r\nchipco_write32(cc, offset, value);\r\nreturn value;\r\n}\r\nvoid ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,\r\nenum ssb_clkmode mode)\r\n{\r\nstruct ssb_device *ccdev = cc->dev;\r\nstruct ssb_bus *bus;\r\nu32 tmp;\r\nif (!ccdev)\r\nreturn;\r\nbus = ccdev->bus;\r\nif (ccdev->id.revision >= 10 && mode == SSB_CLKMODE_SLOW)\r\nmode = SSB_CLKMODE_DYNAMIC;\r\nif (cc->capabilities & SSB_CHIPCO_CAP_PMU)\r\nreturn;\r\nSSB_WARN_ON(ccdev->id.revision >= 20);\r\nif (ccdev->id.revision < 6)\r\nreturn;\r\nif (ccdev->id.revision >= 10)\r\nreturn;\r\nif (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))\r\nreturn;\r\nswitch (mode) {\r\ncase SSB_CLKMODE_SLOW:\r\ntmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\r\ntmp |= SSB_CHIPCO_SLOWCLKCTL_FSLOW;\r\nchipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);\r\nbreak;\r\ncase SSB_CLKMODE_FAST:\r\nif (ccdev->id.revision < 10) {\r\nssb_pci_xtal(bus, SSB_GPIO_XTAL, 1);\r\ntmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\r\ntmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;\r\ntmp |= SSB_CHIPCO_SLOWCLKCTL_IPLL;\r\nchipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);\r\n} else {\r\nchipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,\r\n(chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) |\r\nSSB_CHIPCO_SYSCLKCTL_FORCEHT));\r\n}\r\nbreak;\r\ncase SSB_CLKMODE_DYNAMIC:\r\nif (ccdev->id.revision < 10) {\r\ntmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\r\ntmp &= ~SSB_CHIPCO_SLOWCLKCTL_FSLOW;\r\ntmp &= ~SSB_CHIPCO_SLOWCLKCTL_IPLL;\r\ntmp &= ~SSB_CHIPCO_SLOWCLKCTL_ENXTAL;\r\nif ((tmp & SSB_CHIPCO_SLOWCLKCTL_SRC) !=\r\nSSB_CHIPCO_SLOWCLKCTL_SRC_XTAL)\r\ntmp |= SSB_CHIPCO_SLOWCLKCTL_ENXTAL;\r\nchipco_write32(cc, SSB_CHIPCO_SLOWCLKCTL, tmp);\r\nif (tmp & SSB_CHIPCO_SLOWCLKCTL_ENXTAL)\r\nssb_pci_xtal(bus, SSB_GPIO_XTAL, 0);\r\n} else {\r\nchipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,\r\n(chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &\r\n~SSB_CHIPCO_SYSCLKCTL_FORCEHT));\r\n}\r\nbreak;\r\ndefault:\r\nSSB_WARN_ON(1);\r\n}\r\n}\r\nstatic enum ssb_clksrc chipco_pctl_get_slowclksrc(struct ssb_chipcommon *cc)\r\n{\r\nstruct ssb_bus *bus = cc->dev->bus;\r\nu32 uninitialized_var(tmp);\r\nif (cc->dev->id.revision < 6) {\r\nif (bus->bustype == SSB_BUSTYPE_SSB ||\r\nbus->bustype == SSB_BUSTYPE_PCMCIA)\r\nreturn SSB_CHIPCO_CLKSRC_XTALOS;\r\nif (bus->bustype == SSB_BUSTYPE_PCI) {\r\npci_read_config_dword(bus->host_pci, SSB_GPIO_OUT, &tmp);\r\nif (tmp & 0x10)\r\nreturn SSB_CHIPCO_CLKSRC_PCI;\r\nreturn SSB_CHIPCO_CLKSRC_XTALOS;\r\n}\r\n}\r\nif (cc->dev->id.revision < 10) {\r\ntmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\r\ntmp &= 0x7;\r\nif (tmp == 0)\r\nreturn SSB_CHIPCO_CLKSRC_LOPWROS;\r\nif (tmp == 1)\r\nreturn SSB_CHIPCO_CLKSRC_XTALOS;\r\nif (tmp == 2)\r\nreturn SSB_CHIPCO_CLKSRC_PCI;\r\n}\r\nreturn SSB_CHIPCO_CLKSRC_XTALOS;\r\n}\r\nstatic int chipco_pctl_clockfreqlimit(struct ssb_chipcommon *cc, int get_max)\r\n{\r\nint uninitialized_var(limit);\r\nenum ssb_clksrc clocksrc;\r\nint divisor = 1;\r\nu32 tmp;\r\nclocksrc = chipco_pctl_get_slowclksrc(cc);\r\nif (cc->dev->id.revision < 6) {\r\nswitch (clocksrc) {\r\ncase SSB_CHIPCO_CLKSRC_PCI:\r\ndivisor = 64;\r\nbreak;\r\ncase SSB_CHIPCO_CLKSRC_XTALOS:\r\ndivisor = 32;\r\nbreak;\r\ndefault:\r\nSSB_WARN_ON(1);\r\n}\r\n} else if (cc->dev->id.revision < 10) {\r\nswitch (clocksrc) {\r\ncase SSB_CHIPCO_CLKSRC_LOPWROS:\r\nbreak;\r\ncase SSB_CHIPCO_CLKSRC_XTALOS:\r\ncase SSB_CHIPCO_CLKSRC_PCI:\r\ntmp = chipco_read32(cc, SSB_CHIPCO_SLOWCLKCTL);\r\ndivisor = (tmp >> 16) + 1;\r\ndivisor *= 4;\r\nbreak;\r\n}\r\n} else {\r\ntmp = chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL);\r\ndivisor = (tmp >> 16) + 1;\r\ndivisor *= 4;\r\n}\r\nswitch (clocksrc) {\r\ncase SSB_CHIPCO_CLKSRC_LOPWROS:\r\nif (get_max)\r\nlimit = 43000;\r\nelse\r\nlimit = 25000;\r\nbreak;\r\ncase SSB_CHIPCO_CLKSRC_XTALOS:\r\nif (get_max)\r\nlimit = 20200000;\r\nelse\r\nlimit = 19800000;\r\nbreak;\r\ncase SSB_CHIPCO_CLKSRC_PCI:\r\nif (get_max)\r\nlimit = 34000000;\r\nelse\r\nlimit = 25000000;\r\nbreak;\r\n}\r\nlimit /= divisor;\r\nreturn limit;\r\n}\r\nstatic void chipco_powercontrol_init(struct ssb_chipcommon *cc)\r\n{\r\nstruct ssb_bus *bus = cc->dev->bus;\r\nif (bus->chip_id == 0x4321) {\r\nif (bus->chip_rev == 0)\r\nchipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0x3A4);\r\nelse if (bus->chip_rev == 1)\r\nchipco_write32(cc, SSB_CHIPCO_CHIPCTL, 0xA4);\r\n}\r\nif (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))\r\nreturn;\r\nif (cc->dev->id.revision >= 10) {\r\nchipco_write32(cc, SSB_CHIPCO_SYSCLKCTL,\r\n(chipco_read32(cc, SSB_CHIPCO_SYSCLKCTL) &\r\n0x0000FFFF) | 0x00040000);\r\n} else {\r\nint maxfreq;\r\nmaxfreq = chipco_pctl_clockfreqlimit(cc, 1);\r\nchipco_write32(cc, SSB_CHIPCO_PLLONDELAY,\r\n(maxfreq * 150 + 999999) / 1000000);\r\nchipco_write32(cc, SSB_CHIPCO_FREFSELDELAY,\r\n(maxfreq * 15 + 999999) / 1000000);\r\n}\r\n}\r\nstatic u16 pmu_fast_powerup_delay(struct ssb_chipcommon *cc)\r\n{\r\nstruct ssb_bus *bus = cc->dev->bus;\r\nswitch (bus->chip_id) {\r\ncase 0x4312:\r\ncase 0x4322:\r\ncase 0x4328:\r\nreturn 7000;\r\ncase 0x4325:\r\ndefault:\r\nreturn 15000;\r\n}\r\n}\r\nstatic void calc_fast_powerup_delay(struct ssb_chipcommon *cc)\r\n{\r\nstruct ssb_bus *bus = cc->dev->bus;\r\nint minfreq;\r\nunsigned int tmp;\r\nu32 pll_on_delay;\r\nif (bus->bustype != SSB_BUSTYPE_PCI)\r\nreturn;\r\nif (cc->capabilities & SSB_CHIPCO_CAP_PMU) {\r\ncc->fast_pwrup_delay = pmu_fast_powerup_delay(cc);\r\nreturn;\r\n}\r\nif (!(cc->capabilities & SSB_CHIPCO_CAP_PCTL))\r\nreturn;\r\nminfreq = chipco_pctl_clockfreqlimit(cc, 0);\r\npll_on_delay = chipco_read32(cc, SSB_CHIPCO_PLLONDELAY);\r\ntmp = (((pll_on_delay + 2) * 1000000) + (minfreq - 1)) / minfreq;\r\nSSB_WARN_ON(tmp & ~0xFFFF);\r\ncc->fast_pwrup_delay = tmp;\r\n}\r\nvoid ssb_chipcommon_init(struct ssb_chipcommon *cc)\r\n{\r\nif (!cc->dev)\r\nreturn;\r\nif (cc->dev->id.revision >= 11)\r\ncc->status = chipco_read32(cc, SSB_CHIPCO_CHIPSTAT);\r\nssb_dprintk(KERN_INFO PFX "chipcommon status is 0x%x\n", cc->status);\r\nif (cc->dev->id.revision >= 20) {\r\nchipco_write32(cc, SSB_CHIPCO_GPIOPULLUP, 0);\r\nchipco_write32(cc, SSB_CHIPCO_GPIOPULLDOWN, 0);\r\n}\r\nssb_pmu_init(cc);\r\nchipco_powercontrol_init(cc);\r\nssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);\r\ncalc_fast_powerup_delay(cc);\r\n}\r\nvoid ssb_chipco_suspend(struct ssb_chipcommon *cc)\r\n{\r\nif (!cc->dev)\r\nreturn;\r\nssb_chipco_set_clockmode(cc, SSB_CLKMODE_SLOW);\r\n}\r\nvoid ssb_chipco_resume(struct ssb_chipcommon *cc)\r\n{\r\nif (!cc->dev)\r\nreturn;\r\nchipco_powercontrol_init(cc);\r\nssb_chipco_set_clockmode(cc, SSB_CLKMODE_FAST);\r\n}\r\nvoid ssb_chipco_get_clockcpu(struct ssb_chipcommon *cc,\r\nu32 *plltype, u32 *n, u32 *m)\r\n{\r\n*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);\r\n*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);\r\nswitch (*plltype) {\r\ncase SSB_PLLTYPE_2:\r\ncase SSB_PLLTYPE_4:\r\ncase SSB_PLLTYPE_6:\r\ncase SSB_PLLTYPE_7:\r\n*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);\r\nbreak;\r\ncase SSB_PLLTYPE_3:\r\n*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);\r\nbreak;\r\ndefault:\r\n*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);\r\nbreak;\r\n}\r\n}\r\nvoid ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,\r\nu32 *plltype, u32 *n, u32 *m)\r\n{\r\n*n = chipco_read32(cc, SSB_CHIPCO_CLOCK_N);\r\n*plltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);\r\nswitch (*plltype) {\r\ncase SSB_PLLTYPE_6:\r\n*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_MIPS);\r\nbreak;\r\ncase SSB_PLLTYPE_3:\r\nif (cc->dev->bus->chip_id != 0x5365) {\r\n*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_M2);\r\nbreak;\r\n}\r\ndefault:\r\n*m = chipco_read32(cc, SSB_CHIPCO_CLOCK_SB);\r\n}\r\n}\r\nvoid ssb_chipco_timing_init(struct ssb_chipcommon *cc,\r\nunsigned long ns)\r\n{\r\nstruct ssb_device *dev = cc->dev;\r\nstruct ssb_bus *bus = dev->bus;\r\nu32 tmp;\r\nchipco_write32(cc, SSB_CHIPCO_PROG_CFG, 0x11);\r\ntmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;\r\ntmp |= DIV_ROUND_UP(40, ns) << SSB_PROG_WCNT_1_SHIFT;\r\ntmp |= DIV_ROUND_UP(240, ns);\r\nchipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);\r\ntmp = DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_3_SHIFT;\r\ntmp |= DIV_ROUND_UP(10, ns) << SSB_FLASH_WCNT_1_SHIFT;\r\ntmp |= DIV_ROUND_UP(120, ns);\r\nif ((bus->chip_id == 0x5365) ||\r\n(dev->id.revision < 9))\r\nchipco_write32(cc, SSB_CHIPCO_FLASH_WAITCNT, tmp);\r\nif ((bus->chip_id == 0x5365) ||\r\n(dev->id.revision < 9) ||\r\n((bus->chip_id == 0x5350) && (bus->chip_rev == 0)))\r\nchipco_write32(cc, SSB_CHIPCO_PCMCIA_MEMWAIT, tmp);\r\nif (bus->chip_id == 0x5350) {\r\ntmp = DIV_ROUND_UP(10, ns) << SSB_PROG_WCNT_3_SHIFT;\r\ntmp |= DIV_ROUND_UP(20, ns) << SSB_PROG_WCNT_2_SHIFT;\r\ntmp |= DIV_ROUND_UP(100, ns) << SSB_PROG_WCNT_1_SHIFT;\r\ntmp |= DIV_ROUND_UP(120, ns);\r\nchipco_write32(cc, SSB_CHIPCO_PROG_WAITCNT, tmp);\r\n}\r\n}\r\nvoid ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks)\r\n{\r\nchipco_write32(cc, SSB_CHIPCO_WATCHDOG, ticks);\r\n}\r\nvoid ssb_chipco_irq_mask(struct ssb_chipcommon *cc, u32 mask, u32 value)\r\n{\r\nchipco_write32_masked(cc, SSB_CHIPCO_IRQMASK, mask, value);\r\n}\r\nu32 ssb_chipco_irq_status(struct ssb_chipcommon *cc, u32 mask)\r\n{\r\nreturn chipco_read32(cc, SSB_CHIPCO_IRQSTAT) & mask;\r\n}\r\nu32 ssb_chipco_gpio_in(struct ssb_chipcommon *cc, u32 mask)\r\n{\r\nreturn chipco_read32(cc, SSB_CHIPCO_GPIOIN) & mask;\r\n}\r\nu32 ssb_chipco_gpio_out(struct ssb_chipcommon *cc, u32 mask, u32 value)\r\n{\r\nreturn chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUT, mask, value);\r\n}\r\nu32 ssb_chipco_gpio_outen(struct ssb_chipcommon *cc, u32 mask, u32 value)\r\n{\r\nreturn chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUTEN, mask, value);\r\n}\r\nu32 ssb_chipco_gpio_control(struct ssb_chipcommon *cc, u32 mask, u32 value)\r\n{\r\nreturn chipco_write32_masked(cc, SSB_CHIPCO_GPIOCTL, mask, value);\r\n}\r\nu32 ssb_chipco_gpio_intmask(struct ssb_chipcommon *cc, u32 mask, u32 value)\r\n{\r\nreturn chipco_write32_masked(cc, SSB_CHIPCO_GPIOIRQ, mask, value);\r\n}\r\nu32 ssb_chipco_gpio_polarity(struct ssb_chipcommon *cc, u32 mask, u32 value)\r\n{\r\nreturn chipco_write32_masked(cc, SSB_CHIPCO_GPIOPOL, mask, value);\r\n}\r\nint ssb_chipco_serial_init(struct ssb_chipcommon *cc,\r\nstruct ssb_serial_port *ports)\r\n{\r\nstruct ssb_bus *bus = cc->dev->bus;\r\nint nr_ports = 0;\r\nu32 plltype;\r\nunsigned int irq;\r\nu32 baud_base, div;\r\nu32 i, n;\r\nunsigned int ccrev = cc->dev->id.revision;\r\nplltype = (cc->capabilities & SSB_CHIPCO_CAP_PLLT);\r\nirq = ssb_mips_irq(cc->dev);\r\nif (plltype == SSB_PLLTYPE_1) {\r\nbaud_base = ssb_calc_clock_rate(plltype,\r\nchipco_read32(cc, SSB_CHIPCO_CLOCK_N),\r\nchipco_read32(cc, SSB_CHIPCO_CLOCK_M2));\r\ndiv = 1;\r\n} else {\r\nif (ccrev == 20) {\r\nbaud_base = 25000000;\r\ndiv = 48;\r\nchipco_write32(cc, SSB_CHIPCO_CORECTL,\r\nchipco_read32(cc, SSB_CHIPCO_CORECTL)\r\n| SSB_CHIPCO_CORECTL_UARTCLK0);\r\n} else if ((ccrev >= 11) && (ccrev != 15)) {\r\nbaud_base = 20000000;\r\nif (cc->capabilities & SSB_CHIPCO_CAP_PMU) {\r\nSSB_WARN_ON(1);\r\n}\r\ndiv = 1;\r\nif (ccrev >= 21) {\r\nchipco_write32(cc, SSB_CHIPCO_CORECTL,\r\nchipco_read32(cc, SSB_CHIPCO_CORECTL)\r\n& ~SSB_CHIPCO_CORECTL_UARTCLKEN);\r\n}\r\nchipco_write32(cc, SSB_CHIPCO_CORECTL,\r\nchipco_read32(cc, SSB_CHIPCO_CORECTL)\r\n| SSB_CHIPCO_CORECTL_UARTCLK0);\r\nif (ccrev >= 21) {\r\nchipco_write32(cc, SSB_CHIPCO_CORECTL,\r\nchipco_read32(cc, SSB_CHIPCO_CORECTL)\r\n| SSB_CHIPCO_CORECTL_UARTCLKEN);\r\n}\r\n} else if (ccrev >= 3) {\r\nbaud_base = ssb_clockspeed(bus);\r\ndiv = chipco_read32(cc, SSB_CHIPCO_CLKDIV)\r\n& SSB_CHIPCO_CLKDIV_UART;\r\n} else {\r\nbaud_base = 88000000;\r\ndiv = 48;\r\n}\r\nif ((ccrev > 0) &&\r\n!(chipco_read32(cc, SSB_CHIPCO_CORECTL) & SSB_CHIPCO_CORECTL_UARTCLK0)) {\r\nif ((cc->capabilities & SSB_CHIPCO_CAP_UARTCLK) ==\r\nSSB_CHIPCO_CAP_UARTCLK_INT) {\r\nbaud_base /= div;\r\n} else {\r\nbaud_base = 1843200;\r\n}\r\n}\r\n}\r\nn = (cc->capabilities & SSB_CHIPCO_CAP_NRUART);\r\nfor (i = 0; i < n; i++) {\r\nvoid __iomem *cc_mmio;\r\nvoid __iomem *uart_regs;\r\ncc_mmio = cc->dev->bus->mmio + (cc->dev->core_index * SSB_CORE_SIZE);\r\nuart_regs = cc_mmio + SSB_CHIPCO_UART0_DATA;\r\nif (ccrev == 0)\r\nuart_regs += (i * 8);\r\nelse\r\nuart_regs += (i * 256);\r\nnr_ports++;\r\nports[i].regs = uart_regs;\r\nports[i].irq = irq;\r\nports[i].baud_base = baud_base;\r\nports[i].reg_shift = 0;\r\n}\r\nreturn nr_ports;\r\n}
