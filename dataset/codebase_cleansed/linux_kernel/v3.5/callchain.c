static int valid_next_sp(unsigned long sp, unsigned long prev_sp)\r\n{\r\nif (sp & 0xf)\r\nreturn 0;\r\nif (!validate_sp(sp, current, STACK_FRAME_OVERHEAD))\r\nreturn 0;\r\nif (sp >= prev_sp + STACK_FRAME_OVERHEAD)\r\nreturn 1;\r\nif ((sp & ~(THREAD_SIZE - 1)) != (prev_sp & ~(THREAD_SIZE - 1)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid\r\nperf_callchain_kernel(struct perf_callchain_entry *entry, struct pt_regs *regs)\r\n{\r\nunsigned long sp, next_sp;\r\nunsigned long next_ip;\r\nunsigned long lr;\r\nlong level = 0;\r\nunsigned long *fp;\r\nlr = regs->link;\r\nsp = regs->gpr[1];\r\nperf_callchain_store(entry, regs->nip);\r\nif (!validate_sp(sp, current, STACK_FRAME_OVERHEAD))\r\nreturn;\r\nfor (;;) {\r\nfp = (unsigned long *) sp;\r\nnext_sp = fp[0];\r\nif (next_sp == sp + STACK_INT_FRAME_SIZE &&\r\nfp[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\r\nregs = (struct pt_regs *)(sp + STACK_FRAME_OVERHEAD);\r\nnext_ip = regs->nip;\r\nlr = regs->link;\r\nlevel = 0;\r\nperf_callchain_store(entry, PERF_CONTEXT_KERNEL);\r\n} else {\r\nif (level == 0)\r\nnext_ip = lr;\r\nelse\r\nnext_ip = fp[STACK_FRAME_LR_SAVE];\r\nif ((level == 1 && next_ip == lr) ||\r\n(level <= 1 && !kernel_text_address(next_ip)))\r\nnext_ip = 0;\r\n++level;\r\n}\r\nperf_callchain_store(entry, next_ip);\r\nif (!valid_next_sp(next_sp, sp))\r\nreturn;\r\nsp = next_sp;\r\n}\r\n}\r\nstatic int read_user_stack_slow(void __user *ptr, void *ret, int nb)\r\n{\r\npgd_t *pgdir;\r\npte_t *ptep, pte;\r\nunsigned shift;\r\nunsigned long addr = (unsigned long) ptr;\r\nunsigned long offset;\r\nunsigned long pfn;\r\nvoid *kaddr;\r\npgdir = current->mm->pgd;\r\nif (!pgdir)\r\nreturn -EFAULT;\r\nptep = find_linux_pte_or_hugepte(pgdir, addr, &shift);\r\nif (!shift)\r\nshift = PAGE_SHIFT;\r\noffset = addr & ((1UL << shift) - 1);\r\naddr -= offset;\r\nif (ptep == NULL)\r\nreturn -EFAULT;\r\npte = *ptep;\r\nif (!pte_present(pte) || !(pte_val(pte) & _PAGE_USER))\r\nreturn -EFAULT;\r\npfn = pte_pfn(pte);\r\nif (!page_is_ram(pfn))\r\nreturn -EFAULT;\r\nkaddr = pfn_to_kaddr(pfn);\r\nmemcpy(ret, kaddr + offset, nb);\r\nreturn 0;\r\n}\r\nstatic int read_user_stack_64(unsigned long __user *ptr, unsigned long *ret)\r\n{\r\nif ((unsigned long)ptr > TASK_SIZE - sizeof(unsigned long) ||\r\n((unsigned long)ptr & 7))\r\nreturn -EFAULT;\r\npagefault_disable();\r\nif (!__get_user_inatomic(*ret, ptr)) {\r\npagefault_enable();\r\nreturn 0;\r\n}\r\npagefault_enable();\r\nreturn read_user_stack_slow(ptr, ret, 8);\r\n}\r\nstatic int read_user_stack_32(unsigned int __user *ptr, unsigned int *ret)\r\n{\r\nif ((unsigned long)ptr > TASK_SIZE - sizeof(unsigned int) ||\r\n((unsigned long)ptr & 3))\r\nreturn -EFAULT;\r\npagefault_disable();\r\nif (!__get_user_inatomic(*ret, ptr)) {\r\npagefault_enable();\r\nreturn 0;\r\n}\r\npagefault_enable();\r\nreturn read_user_stack_slow(ptr, ret, 4);\r\n}\r\nstatic inline int valid_user_sp(unsigned long sp, int is_64)\r\n{\r\nif (!sp || (sp & 7) || sp > (is_64 ? TASK_SIZE : 0x100000000UL) - 32)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int is_sigreturn_64_address(unsigned long nip, unsigned long fp)\r\n{\r\nif (nip == fp + offsetof(struct signal_frame_64, tramp))\r\nreturn 1;\r\nif (vdso64_rt_sigtramp && current->mm->context.vdso_base &&\r\nnip == current->mm->context.vdso_base + vdso64_rt_sigtramp)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sane_signal_64_frame(unsigned long sp)\r\n{\r\nstruct signal_frame_64 __user *sf;\r\nunsigned long pinfo, puc;\r\nsf = (struct signal_frame_64 __user *) sp;\r\nif (read_user_stack_64((unsigned long __user *) &sf->pinfo, &pinfo) ||\r\nread_user_stack_64((unsigned long __user *) &sf->puc, &puc))\r\nreturn 0;\r\nreturn pinfo == (unsigned long) &sf->info &&\r\npuc == (unsigned long) &sf->uc;\r\n}\r\nstatic void perf_callchain_user_64(struct perf_callchain_entry *entry,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long sp, next_sp;\r\nunsigned long next_ip;\r\nunsigned long lr;\r\nlong level = 0;\r\nstruct signal_frame_64 __user *sigframe;\r\nunsigned long __user *fp, *uregs;\r\nnext_ip = regs->nip;\r\nlr = regs->link;\r\nsp = regs->gpr[1];\r\nperf_callchain_store(entry, next_ip);\r\nfor (;;) {\r\nfp = (unsigned long __user *) sp;\r\nif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\r\nreturn;\r\nif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\r\nreturn;\r\nif (next_sp - sp >= sizeof(struct signal_frame_64) &&\r\n(is_sigreturn_64_address(next_ip, sp) ||\r\n(level <= 1 && is_sigreturn_64_address(lr, sp))) &&\r\nsane_signal_64_frame(sp)) {\r\nsigframe = (struct signal_frame_64 __user *) sp;\r\nuregs = sigframe->uc.uc_mcontext.gp_regs;\r\nif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\r\nread_user_stack_64(&uregs[PT_LNK], &lr) ||\r\nread_user_stack_64(&uregs[PT_R1], &sp))\r\nreturn;\r\nlevel = 0;\r\nperf_callchain_store(entry, PERF_CONTEXT_USER);\r\nperf_callchain_store(entry, next_ip);\r\ncontinue;\r\n}\r\nif (level == 0)\r\nnext_ip = lr;\r\nperf_callchain_store(entry, next_ip);\r\n++level;\r\nsp = next_sp;\r\n}\r\n}\r\nstatic inline int current_is_64bit(void)\r\n{\r\nreturn !test_ti_thread_flag(task_thread_info(current), TIF_32BIT);\r\n}\r\nstatic int read_user_stack_32(unsigned int __user *ptr, unsigned int *ret)\r\n{\r\nint rc;\r\nif ((unsigned long)ptr > TASK_SIZE - sizeof(unsigned int) ||\r\n((unsigned long)ptr & 3))\r\nreturn -EFAULT;\r\npagefault_disable();\r\nrc = __get_user_inatomic(*ret, ptr);\r\npagefault_enable();\r\nreturn rc;\r\n}\r\nstatic inline void perf_callchain_user_64(struct perf_callchain_entry *entry,\r\nstruct pt_regs *regs)\r\n{\r\n}\r\nstatic inline int current_is_64bit(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int valid_user_sp(unsigned long sp, int is_64)\r\n{\r\nif (!sp || (sp & 7) || sp > TASK_SIZE - 32)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int is_sigreturn_32_address(unsigned int nip, unsigned int fp)\r\n{\r\nif (nip == fp + offsetof(struct signal_frame_32, mctx.mc_pad))\r\nreturn 1;\r\nif (vdso32_sigtramp && current->mm->context.vdso_base &&\r\nnip == current->mm->context.vdso_base + vdso32_sigtramp)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int is_rt_sigreturn_32_address(unsigned int nip, unsigned int fp)\r\n{\r\nif (nip == fp + offsetof(struct rt_signal_frame_32,\r\nuc.uc_mcontext.mc_pad))\r\nreturn 1;\r\nif (vdso32_rt_sigtramp && current->mm->context.vdso_base &&\r\nnip == current->mm->context.vdso_base + vdso32_rt_sigtramp)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int sane_signal_32_frame(unsigned int sp)\r\n{\r\nstruct signal_frame_32 __user *sf;\r\nunsigned int regs;\r\nsf = (struct signal_frame_32 __user *) (unsigned long) sp;\r\nif (read_user_stack_32((unsigned int __user *) &sf->sctx.regs, &regs))\r\nreturn 0;\r\nreturn regs == (unsigned long) &sf->mctx;\r\n}\r\nstatic int sane_rt_signal_32_frame(unsigned int sp)\r\n{\r\nstruct rt_signal_frame_32 __user *sf;\r\nunsigned int regs;\r\nsf = (struct rt_signal_frame_32 __user *) (unsigned long) sp;\r\nif (read_user_stack_32((unsigned int __user *) &sf->uc.uc_regs, &regs))\r\nreturn 0;\r\nreturn regs == (unsigned long) &sf->uc.uc_mcontext;\r\n}\r\nstatic unsigned int __user *signal_frame_32_regs(unsigned int sp,\r\nunsigned int next_sp, unsigned int next_ip)\r\n{\r\nstruct mcontext32 __user *mctx = NULL;\r\nstruct signal_frame_32 __user *sf;\r\nstruct rt_signal_frame_32 __user *rt_sf;\r\nif (next_sp - sp >= sizeof(struct signal_frame_32) &&\r\nis_sigreturn_32_address(next_ip, sp) &&\r\nsane_signal_32_frame(sp)) {\r\nsf = (struct signal_frame_32 __user *) (unsigned long) sp;\r\nmctx = &sf->mctx;\r\n}\r\nif (!mctx && next_sp - sp >= sizeof(struct rt_signal_frame_32) &&\r\nis_rt_sigreturn_32_address(next_ip, sp) &&\r\nsane_rt_signal_32_frame(sp)) {\r\nrt_sf = (struct rt_signal_frame_32 __user *) (unsigned long) sp;\r\nmctx = &rt_sf->uc.uc_mcontext;\r\n}\r\nif (!mctx)\r\nreturn NULL;\r\nreturn mctx->mc_gregs;\r\n}\r\nstatic void perf_callchain_user_32(struct perf_callchain_entry *entry,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned int sp, next_sp;\r\nunsigned int next_ip;\r\nunsigned int lr;\r\nlong level = 0;\r\nunsigned int __user *fp, *uregs;\r\nnext_ip = regs->nip;\r\nlr = regs->link;\r\nsp = regs->gpr[1];\r\nperf_callchain_store(entry, next_ip);\r\nwhile (entry->nr < PERF_MAX_STACK_DEPTH) {\r\nfp = (unsigned int __user *) (unsigned long) sp;\r\nif (!valid_user_sp(sp, 0) || read_user_stack_32(fp, &next_sp))\r\nreturn;\r\nif (level > 0 && read_user_stack_32(&fp[1], &next_ip))\r\nreturn;\r\nuregs = signal_frame_32_regs(sp, next_sp, next_ip);\r\nif (!uregs && level <= 1)\r\nuregs = signal_frame_32_regs(sp, next_sp, lr);\r\nif (uregs) {\r\nif (read_user_stack_32(&uregs[PT_NIP], &next_ip) ||\r\nread_user_stack_32(&uregs[PT_LNK], &lr) ||\r\nread_user_stack_32(&uregs[PT_R1], &sp))\r\nreturn;\r\nlevel = 0;\r\nperf_callchain_store(entry, PERF_CONTEXT_USER);\r\nperf_callchain_store(entry, next_ip);\r\ncontinue;\r\n}\r\nif (level == 0)\r\nnext_ip = lr;\r\nperf_callchain_store(entry, next_ip);\r\n++level;\r\nsp = next_sp;\r\n}\r\n}\r\nvoid\r\nperf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)\r\n{\r\nif (current_is_64bit())\r\nperf_callchain_user_64(entry, regs);\r\nelse\r\nperf_callchain_user_32(entry, regs);\r\n}
