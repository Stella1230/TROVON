static irqreturn_t psif_interrupt(int irq, void *_ptr)\r\n{\r\nstruct psif *psif = _ptr;\r\nint retval = IRQ_NONE;\r\nunsigned int io_flags = 0;\r\nunsigned long status;\r\nstatus = psif_readl(psif, SR);\r\nif (status & PSIF_BIT(RXRDY)) {\r\nunsigned char val = (unsigned char) psif_readl(psif, RHR);\r\nif (status & PSIF_BIT(PARITY))\r\nio_flags |= SERIO_PARITY;\r\nif (status & PSIF_BIT(OVRUN))\r\ndev_err(&psif->pdev->dev, "overrun read error\n");\r\nserio_interrupt(psif->io, val, io_flags);\r\nretval = IRQ_HANDLED;\r\n}\r\nreturn retval;\r\n}\r\nstatic int psif_write(struct serio *io, unsigned char val)\r\n{\r\nstruct psif *psif = io->port_data;\r\nunsigned long flags;\r\nint timeout = 10;\r\nint retval = 0;\r\nspin_lock_irqsave(&psif->lock, flags);\r\nwhile (!(psif_readl(psif, SR) & PSIF_BIT(TXEMPTY)) && timeout--)\r\nudelay(50);\r\nif (timeout >= 0) {\r\npsif_writel(psif, THR, val);\r\n} else {\r\ndev_dbg(&psif->pdev->dev, "timeout writing to THR\n");\r\nretval = -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&psif->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int psif_open(struct serio *io)\r\n{\r\nstruct psif *psif = io->port_data;\r\nint retval;\r\nretval = clk_enable(psif->pclk);\r\nif (retval)\r\ngoto out;\r\npsif_writel(psif, CR, PSIF_BIT(CR_TXEN) | PSIF_BIT(CR_RXEN));\r\npsif_writel(psif, IER, PSIF_BIT(RXRDY));\r\npsif->open = true;\r\nout:\r\nreturn retval;\r\n}\r\nstatic void psif_close(struct serio *io)\r\n{\r\nstruct psif *psif = io->port_data;\r\npsif->open = false;\r\npsif_writel(psif, IDR, ~0UL);\r\npsif_writel(psif, CR, PSIF_BIT(CR_TXDIS) | PSIF_BIT(CR_RXDIS));\r\nclk_disable(psif->pclk);\r\n}\r\nstatic void psif_set_prescaler(struct psif *psif)\r\n{\r\nunsigned long prscv;\r\nunsigned long rate = clk_get_rate(psif->pclk);\r\nprscv = 100 * (rate / 1000000UL);\r\nif (prscv > ((1<<PSIF_PSR_PRSCV_SIZE) - 1)) {\r\nprscv = (1<<PSIF_PSR_PRSCV_SIZE) - 1;\r\ndev_dbg(&psif->pdev->dev, "pclk too fast, "\r\n"prescaler set to max\n");\r\n}\r\nclk_enable(psif->pclk);\r\npsif_writel(psif, PSR, prscv);\r\nclk_disable(psif->pclk);\r\n}\r\nstatic int __init psif_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nstruct psif *psif;\r\nstruct serio *io;\r\nstruct clk *pclk;\r\nint irq;\r\nint ret;\r\npsif = kzalloc(sizeof(struct psif), GFP_KERNEL);\r\nif (!psif) {\r\ndev_dbg(&pdev->dev, "out of memory\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npsif->pdev = pdev;\r\nio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!io) {\r\ndev_dbg(&pdev->dev, "out of memory\n");\r\nret = -ENOMEM;\r\ngoto out_free_psif;\r\n}\r\npsif->io = io;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_dbg(&pdev->dev, "no mmio resources defined\n");\r\nret = -ENOMEM;\r\ngoto out_free_io;\r\n}\r\npsif->regs = ioremap(regs->start, resource_size(regs));\r\nif (!psif->regs) {\r\nret = -ENOMEM;\r\ndev_dbg(&pdev->dev, "could not map I/O memory\n");\r\ngoto out_free_io;\r\n}\r\npclk = clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(pclk)) {\r\ndev_dbg(&pdev->dev, "could not get peripheral clock\n");\r\nret = PTR_ERR(pclk);\r\ngoto out_iounmap;\r\n}\r\npsif->pclk = pclk;\r\nret = clk_enable(pclk);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "could not enable pclk\n");\r\ngoto out_put_clk;\r\n}\r\npsif_writel(psif, CR, PSIF_BIT(CR_SWRST));\r\nclk_disable(pclk);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_dbg(&pdev->dev, "could not get irq\n");\r\nret = -ENXIO;\r\ngoto out_put_clk;\r\n}\r\nret = request_irq(irq, psif_interrupt, IRQF_SHARED, "at32psif", psif);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "could not request irq %d\n", irq);\r\ngoto out_put_clk;\r\n}\r\npsif->irq = irq;\r\nio->id.type = SERIO_8042;\r\nio->write = psif_write;\r\nio->open = psif_open;\r\nio->close = psif_close;\r\nsnprintf(io->name, sizeof(io->name), "AVR32 PS/2 port%d", pdev->id);\r\nsnprintf(io->phys, sizeof(io->phys), "at32psif/serio%d", pdev->id);\r\nio->port_data = psif;\r\nio->dev.parent = &pdev->dev;\r\npsif_set_prescaler(psif);\r\nspin_lock_init(&psif->lock);\r\nserio_register_port(psif->io);\r\nplatform_set_drvdata(pdev, psif);\r\ndev_info(&pdev->dev, "Atmel AVR32 PSIF PS/2 driver on 0x%08x irq %d\n",\r\n(int)psif->regs, psif->irq);\r\nreturn 0;\r\nout_put_clk:\r\nclk_put(psif->pclk);\r\nout_iounmap:\r\niounmap(psif->regs);\r\nout_free_io:\r\nkfree(io);\r\nout_free_psif:\r\nkfree(psif);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __exit psif_remove(struct platform_device *pdev)\r\n{\r\nstruct psif *psif = platform_get_drvdata(pdev);\r\npsif_writel(psif, IDR, ~0UL);\r\npsif_writel(psif, CR, PSIF_BIT(CR_TXDIS) | PSIF_BIT(CR_RXDIS));\r\nserio_unregister_port(psif->io);\r\niounmap(psif->regs);\r\nfree_irq(psif->irq, psif);\r\nclk_put(psif->pclk);\r\nkfree(psif);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int psif_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct psif *psif = platform_get_drvdata(pdev);\r\nif (psif->open) {\r\npsif_writel(psif, CR, PSIF_BIT(CR_RXDIS) | PSIF_BIT(CR_TXDIS));\r\nclk_disable(psif->pclk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int psif_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct psif *psif = platform_get_drvdata(pdev);\r\nif (psif->open) {\r\nclk_enable(psif->pclk);\r\npsif_set_prescaler(psif);\r\npsif_writel(psif, CR, PSIF_BIT(CR_RXEN) | PSIF_BIT(CR_TXEN));\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init psif_init(void)\r\n{\r\nreturn platform_driver_probe(&psif_driver, psif_probe);\r\n}\r\nstatic void __exit psif_exit(void)\r\n{\r\nplatform_driver_unregister(&psif_driver);\r\n}
