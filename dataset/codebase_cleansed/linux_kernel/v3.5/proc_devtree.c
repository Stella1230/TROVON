static inline void set_node_proc_entry(struct device_node *np,\r\nstruct proc_dir_entry *de)\r\n{\r\n#ifdef HAVE_ARCH_DEVTREE_FIXUPS\r\nnp->pde = de;\r\n#endif\r\n}\r\nstatic int property_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct property *pp = m->private;\r\nseq_write(m, pp->value, pp->length);\r\nreturn 0;\r\n}\r\nstatic int property_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, property_proc_show, PDE(inode)->data);\r\n}\r\nstatic struct proc_dir_entry *\r\n__proc_device_tree_add_prop(struct proc_dir_entry *de, struct property *pp,\r\nconst char *name)\r\n{\r\nstruct proc_dir_entry *ent;\r\nent = proc_create_data(name,\r\nstrncmp(name, "security-", 9) ? S_IRUGO : S_IRUSR,\r\nde, &property_proc_fops, pp);\r\nif (ent == NULL)\r\nreturn NULL;\r\nif (!strncmp(name, "security-", 9))\r\nent->size = 0;\r\nelse\r\nent->size = pp->length;\r\nreturn ent;\r\n}\r\nvoid proc_device_tree_add_prop(struct proc_dir_entry *pde, struct property *prop)\r\n{\r\n__proc_device_tree_add_prop(pde, prop, prop->name);\r\n}\r\nvoid proc_device_tree_remove_prop(struct proc_dir_entry *pde,\r\nstruct property *prop)\r\n{\r\nremove_proc_entry(prop->name, pde);\r\n}\r\nvoid proc_device_tree_update_prop(struct proc_dir_entry *pde,\r\nstruct property *newprop,\r\nstruct property *oldprop)\r\n{\r\nstruct proc_dir_entry *ent;\r\nfor (ent = pde->subdir; ent != NULL; ent = ent->next)\r\nif (ent->data == oldprop)\r\nbreak;\r\nif (ent == NULL) {\r\nprintk(KERN_WARNING "device-tree: property \"%s\" "\r\n" does not exist\n", oldprop->name);\r\n} else {\r\nent->data = newprop;\r\nent->size = newprop->length;\r\n}\r\n}\r\nstatic int duplicate_name(struct proc_dir_entry *de, const char *name)\r\n{\r\nstruct proc_dir_entry *ent;\r\nint found = 0;\r\nspin_lock(&proc_subdir_lock);\r\nfor (ent = de->subdir; ent != NULL; ent = ent->next) {\r\nif (strcmp(ent->name, name) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&proc_subdir_lock);\r\nreturn found;\r\n}\r\nstatic const char *fixup_name(struct device_node *np, struct proc_dir_entry *de,\r\nconst char *name)\r\n{\r\nchar *fixed_name;\r\nint fixup_len = strlen(name) + 2 + 1;\r\nint i = 1, size;\r\nrealloc:\r\nfixed_name = kmalloc(fixup_len, GFP_KERNEL);\r\nif (fixed_name == NULL) {\r\nprintk(KERN_ERR "device-tree: Out of memory trying to fixup "\r\n"name \"%s\"\n", name);\r\nreturn name;\r\n}\r\nretry:\r\nsize = snprintf(fixed_name, fixup_len, "%s#%d", name, i);\r\nsize++;\r\nif (size > fixup_len) {\r\nkfree(fixed_name);\r\nfixup_len = size;\r\ngoto realloc;\r\n}\r\nif (duplicate_name(de, fixed_name)) {\r\ni++;\r\ngoto retry;\r\n}\r\nprintk(KERN_WARNING "device-tree: Duplicate name in %s, "\r\n"renamed to \"%s\"\n", np->full_name, fixed_name);\r\nreturn fixed_name;\r\n}\r\nvoid proc_device_tree_add_node(struct device_node *np,\r\nstruct proc_dir_entry *de)\r\n{\r\nstruct property *pp;\r\nstruct proc_dir_entry *ent;\r\nstruct device_node *child;\r\nconst char *p;\r\nset_node_proc_entry(np, de);\r\nfor (child = NULL; (child = of_get_next_child(np, child));) {\r\np = strrchr(child->full_name, '/');\r\nif (!p)\r\np = child->full_name;\r\nelse\r\n++p;\r\nif (duplicate_name(de, p))\r\np = fixup_name(np, de, p);\r\nent = proc_mkdir(p, de);\r\nif (ent == NULL)\r\nbreak;\r\nproc_device_tree_add_node(child, ent);\r\n}\r\nof_node_put(child);\r\nfor (pp = np->properties; pp != NULL; pp = pp->next) {\r\np = pp->name;\r\nif (strchr(p, '/'))\r\ncontinue;\r\nif (duplicate_name(de, p))\r\np = fixup_name(np, de, p);\r\nent = __proc_device_tree_add_prop(de, pp, p);\r\nif (ent == NULL)\r\nbreak;\r\n}\r\n}\r\nvoid __init proc_device_tree_init(void)\r\n{\r\nstruct device_node *root;\r\nproc_device_tree = proc_mkdir("device-tree", NULL);\r\nif (proc_device_tree == NULL)\r\nreturn;\r\nroot = of_find_node_by_path("/");\r\nif (root == NULL) {\r\npr_debug("/proc/device-tree: can't find root\n");\r\nreturn;\r\n}\r\nproc_device_tree_add_node(root, proc_device_tree);\r\nof_node_put(root);\r\n}
