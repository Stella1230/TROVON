static struct ath_mci_profile_info*\r\nath_mci_find_profile(struct ath_mci_profile *mci,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_mci_profile_info *entry;\r\nlist_for_each_entry(entry, &mci->info, list) {\r\nif (entry->conn_handle == info->conn_handle)\r\nbreak;\r\n}\r\nreturn entry;\r\n}\r\nstatic bool ath_mci_add_profile(struct ath_common *common,\r\nstruct ath_mci_profile *mci,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_mci_profile_info *entry;\r\nif ((mci->num_sco == ATH_MCI_MAX_SCO_PROFILE) &&\r\n(info->type == MCI_GPM_COEX_PROFILE_VOICE))\r\nreturn false;\r\nif (((NUM_PROF(mci) - mci->num_sco) == ATH_MCI_MAX_ACL_PROFILE) &&\r\n(info->type != MCI_GPM_COEX_PROFILE_VOICE))\r\nreturn false;\r\nentry = ath_mci_find_profile(mci, info);\r\nif (entry) {\r\nmemcpy(entry, info, 10);\r\n} else {\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn false;\r\nmemcpy(entry, info, 10);\r\nINC_PROF(mci, info);\r\nlist_add_tail(&info->list, &mci->info);\r\n}\r\nreturn true;\r\n}\r\nstatic void ath_mci_del_profile(struct ath_common *common,\r\nstruct ath_mci_profile *mci,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_mci_profile_info *entry;\r\nentry = ath_mci_find_profile(mci, info);\r\nif (!entry)\r\nreturn;\r\nDEC_PROF(mci, entry);\r\nlist_del(&entry->list);\r\nkfree(entry);\r\n}\r\nvoid ath_mci_flush_profile(struct ath_mci_profile *mci)\r\n{\r\nstruct ath_mci_profile_info *info, *tinfo;\r\nlist_for_each_entry_safe(info, tinfo, &mci->info, list) {\r\nlist_del(&info->list);\r\nDEC_PROF(mci, info);\r\nkfree(info);\r\n}\r\nmci->aggr_limit = 0;\r\n}\r\nstatic void ath_mci_adjust_aggr_limit(struct ath_btcoex *btcoex)\r\n{\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nu32 wlan_airtime = btcoex->btcoex_period *\r\n(100 - btcoex->duty_cycle) / 100;\r\nif ((wlan_airtime <= 4) &&\r\n(!mci->aggr_limit || (mci->aggr_limit > (2 * wlan_airtime))))\r\nmci->aggr_limit = 2 * wlan_airtime;\r\n}\r\nstatic void ath_mci_update_scheme(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nstruct ath_mci_profile_info *info;\r\nu32 num_profile = NUM_PROF(mci);\r\nif (num_profile == 1) {\r\ninfo = list_first_entry(&mci->info,\r\nstruct ath_mci_profile_info,\r\nlist);\r\nif (mci->num_sco && info->T == 12) {\r\nmci->aggr_limit = 8;\r\nath_dbg(common, MCI,\r\n"Single SCO, aggregation limit 2 ms\n");\r\n} else if ((info->type == MCI_GPM_COEX_PROFILE_BNEP) &&\r\n!info->master) {\r\nbtcoex->btcoex_period = 60;\r\nath_dbg(common, MCI,\r\n"Single slave PAN/FTP, bt period 60 ms\n");\r\n} else if ((info->type == MCI_GPM_COEX_PROFILE_HID) &&\r\n(info->T > 0 && info->T < 50) &&\r\n(info->A > 1 || info->W > 1)) {\r\nbtcoex->duty_cycle = 30;\r\nmci->aggr_limit = 8;\r\nath_dbg(common, MCI,\r\n"Multiple attempt/timeout single HID "\r\n"aggregation limit 2 ms dutycycle 30%%\n");\r\n}\r\n} else if ((num_profile == 2) && (mci->num_hid == 2)) {\r\nbtcoex->duty_cycle = 30;\r\nmci->aggr_limit = 8;\r\nath_dbg(common, MCI,\r\n"Two HIDs aggregation limit 2 ms dutycycle 30%%\n");\r\n} else if (num_profile > 3) {\r\nmci->aggr_limit = 6;\r\nath_dbg(common, MCI,\r\n"Three or more profiles aggregation limit 1.5 ms\n");\r\n}\r\nif (IS_CHAN_2GHZ(sc->sc_ah->curchan)) {\r\nif (IS_CHAN_HT(sc->sc_ah->curchan))\r\nath_mci_adjust_aggr_limit(btcoex);\r\nelse\r\nbtcoex->btcoex_period >>= 1;\r\n}\r\nath9k_hw_btcoex_disable(sc->sc_ah);\r\nath9k_btcoex_timer_pause(sc);\r\nif (IS_CHAN_5GHZ(sc->sc_ah->curchan))\r\nreturn;\r\nbtcoex->duty_cycle += (mci->num_bdr ? ATH_MCI_MAX_DUTY_CYCLE : 0);\r\nif (btcoex->duty_cycle > ATH_MCI_MAX_DUTY_CYCLE)\r\nbtcoex->duty_cycle = ATH_MCI_MAX_DUTY_CYCLE;\r\nbtcoex->btcoex_period *= 1000;\r\nbtcoex->btcoex_no_stomp = btcoex->btcoex_period *\r\n(100 - btcoex->duty_cycle) / 100;\r\nath9k_hw_btcoex_enable(sc->sc_ah);\r\nath9k_btcoex_timer_resume(sc);\r\n}\r\nstatic void ath_mci_cal_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 payload[4] = {0, 0, 0, 0};\r\nswitch (opcode) {\r\ncase MCI_GPM_BT_CAL_REQ:\r\nif (ar9003_mci_state(ah, MCI_STATE_BT, NULL) == MCI_BT_AWAKE) {\r\nar9003_mci_state(ah, MCI_STATE_SET_BT_CAL_START, NULL);\r\nieee80211_queue_work(sc->hw, &sc->hw_reset_work);\r\n} else {\r\nath_dbg(common, MCI, "MCI State mismatch: %d\n",\r\nar9003_mci_state(ah, MCI_STATE_BT, NULL));\r\n}\r\nbreak;\r\ncase MCI_GPM_BT_CAL_DONE:\r\nar9003_mci_state(ah, MCI_STATE_BT, NULL);\r\nbreak;\r\ncase MCI_GPM_BT_CAL_GRANT:\r\nMCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_DONE);\r\nar9003_mci_send_message(sc->sc_ah, MCI_GPM, 0, payload,\r\n16, false, true);\r\nbreak;\r\ndefault:\r\nath_dbg(common, MCI, "Unknown GPM CAL message\n");\r\nbreak;\r\n}\r\n}\r\nstatic void ath_mci_process_profile(struct ath_softc *sc,\r\nstruct ath_mci_profile_info *info)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nif (info->start) {\r\nif (!ath_mci_add_profile(common, mci, info))\r\nreturn;\r\n} else\r\nath_mci_del_profile(common, mci, info);\r\nbtcoex->btcoex_period = ATH_MCI_DEF_BT_PERIOD;\r\nmci->aggr_limit = mci->num_sco ? 6 : 0;\r\nif (NUM_PROF(mci)) {\r\nbtcoex->bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\r\nbtcoex->duty_cycle = ath_mci_duty_cycle[NUM_PROF(mci)];\r\n} else {\r\nbtcoex->bt_stomp_type = mci->num_mgmt ? ATH_BTCOEX_STOMP_ALL :\r\nATH_BTCOEX_STOMP_LOW;\r\nbtcoex->duty_cycle = ATH_BTCOEX_DEF_DUTY_CYCLE;\r\n}\r\nath_mci_update_scheme(sc);\r\n}\r\nstatic void ath_mci_process_status(struct ath_softc *sc,\r\nstruct ath_mci_profile_status *status)\r\n{\r\nstruct ath_btcoex *btcoex = &sc->btcoex;\r\nstruct ath_mci_profile *mci = &btcoex->mci;\r\nstruct ath_mci_profile_info info;\r\nint i = 0, old_num_mgmt = mci->num_mgmt;\r\nif (status->is_link)\r\nreturn;\r\nmemset(&info, 0, sizeof(struct ath_mci_profile_info));\r\ninfo.conn_handle = status->conn_handle;\r\nif (ath_mci_find_profile(mci, &info))\r\nreturn;\r\nif (status->conn_handle >= ATH_MCI_MAX_PROFILE)\r\nreturn;\r\nif (status->is_critical)\r\n__set_bit(status->conn_handle, mci->status);\r\nelse\r\n__clear_bit(status->conn_handle, mci->status);\r\nmci->num_mgmt = 0;\r\ndo {\r\nif (test_bit(i, mci->status))\r\nmci->num_mgmt++;\r\n} while (++i < ATH_MCI_MAX_PROFILE);\r\nif (old_num_mgmt != mci->num_mgmt)\r\nath_mci_update_scheme(sc);\r\n}\r\nstatic void ath_mci_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)\r\n{\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_mci_profile_info profile_info;\r\nstruct ath_mci_profile_status profile_status;\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nu32 version;\r\nu8 major;\r\nu8 minor;\r\nu32 seq_num;\r\nswitch (opcode) {\r\ncase MCI_GPM_COEX_VERSION_QUERY:\r\nversion = ar9003_mci_state(ah, MCI_STATE_SEND_WLAN_COEX_VERSION,\r\nNULL);\r\nbreak;\r\ncase MCI_GPM_COEX_VERSION_RESPONSE:\r\nmajor = *(rx_payload + MCI_GPM_COEX_B_MAJOR_VERSION);\r\nminor = *(rx_payload + MCI_GPM_COEX_B_MINOR_VERSION);\r\nversion = (major << 8) + minor;\r\nversion = ar9003_mci_state(ah, MCI_STATE_SET_BT_COEX_VERSION,\r\n&version);\r\nbreak;\r\ncase MCI_GPM_COEX_STATUS_QUERY:\r\nar9003_mci_state(ah, MCI_STATE_SEND_WLAN_CHANNELS, NULL);\r\nbreak;\r\ncase MCI_GPM_COEX_BT_PROFILE_INFO:\r\nmemcpy(&profile_info,\r\n(rx_payload + MCI_GPM_COEX_B_PROFILE_TYPE), 10);\r\nif ((profile_info.type == MCI_GPM_COEX_PROFILE_UNKNOWN) ||\r\n(profile_info.type >= MCI_GPM_COEX_PROFILE_MAX)) {\r\nath_dbg(common, MCI,\r\n"Illegal profile type = %d, state = %d\n",\r\nprofile_info.type,\r\nprofile_info.start);\r\nbreak;\r\n}\r\nath_mci_process_profile(sc, &profile_info);\r\nbreak;\r\ncase MCI_GPM_COEX_BT_STATUS_UPDATE:\r\nprofile_status.is_link = *(rx_payload +\r\nMCI_GPM_COEX_B_STATUS_TYPE);\r\nprofile_status.conn_handle = *(rx_payload +\r\nMCI_GPM_COEX_B_STATUS_LINKID);\r\nprofile_status.is_critical = *(rx_payload +\r\nMCI_GPM_COEX_B_STATUS_STATE);\r\nseq_num = *((u32 *)(rx_payload + 12));\r\nath_dbg(common, MCI,\r\n"BT_Status_Update: is_link=%d, linkId=%d, state=%d, SEQ=%d\n",\r\nprofile_status.is_link, profile_status.conn_handle,\r\nprofile_status.is_critical, seq_num);\r\nath_mci_process_status(sc, &profile_status);\r\nbreak;\r\ndefault:\r\nath_dbg(common, MCI, "Unknown GPM COEX message = 0x%02x\n", opcode);\r\nbreak;\r\n}\r\n}\r\nint ath_mci_setup(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_mci_coex *mci = &sc->mci_coex;\r\nstruct ath_mci_buf *buf = &mci->sched_buf;\r\nbuf->bf_addr = dma_alloc_coherent(sc->dev,\r\nATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE,\r\n&buf->bf_paddr, GFP_KERNEL);\r\nif (buf->bf_addr == NULL) {\r\nath_dbg(common, FATAL, "MCI buffer alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(buf->bf_addr, MCI_GPM_RSVD_PATTERN,\r\nATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE);\r\nmci->sched_buf.bf_len = ATH_MCI_SCHED_BUF_SIZE;\r\nmci->gpm_buf.bf_len = ATH_MCI_GPM_BUF_SIZE;\r\nmci->gpm_buf.bf_addr = (u8 *)mci->sched_buf.bf_addr + mci->sched_buf.bf_len;\r\nmci->gpm_buf.bf_paddr = mci->sched_buf.bf_paddr + mci->sched_buf.bf_len;\r\nar9003_mci_setup(sc->sc_ah, mci->gpm_buf.bf_paddr,\r\nmci->gpm_buf.bf_addr, (mci->gpm_buf.bf_len >> 4),\r\nmci->sched_buf.bf_paddr);\r\nath_dbg(common, MCI, "MCI Initialized\n");\r\nreturn 0;\r\n}\r\nvoid ath_mci_cleanup(struct ath_softc *sc)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_mci_coex *mci = &sc->mci_coex;\r\nstruct ath_mci_buf *buf = &mci->sched_buf;\r\nif (buf->bf_addr)\r\ndma_free_coherent(sc->dev,\r\nATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE,\r\nbuf->bf_addr, buf->bf_paddr);\r\nar9003_mci_cleanup(ah);\r\nath_dbg(common, MCI, "MCI De-Initialized\n");\r\n}\r\nvoid ath_mci_intr(struct ath_softc *sc)\r\n{\r\nstruct ath_mci_coex *mci = &sc->mci_coex;\r\nstruct ath_hw *ah = sc->sc_ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 mci_int, mci_int_rxmsg;\r\nu32 offset, subtype, opcode;\r\nu32 *pgpm;\r\nu32 more_data = MCI_GPM_MORE;\r\nbool skip_gpm = false;\r\nar9003_mci_get_interrupt(sc->sc_ah, &mci_int, &mci_int_rxmsg);\r\nif (ar9003_mci_state(ah, MCI_STATE_ENABLE, NULL) == 0) {\r\nar9003_mci_state(ah, MCI_STATE_INIT_GPM_OFFSET, NULL);\r\nreturn;\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE) {\r\nu32 payload[4] = { 0xffffffff, 0xffffffff,\r\n0xffffffff, 0xffffff00};\r\nar9003_mci_send_message(ah, MCI_REMOTE_RESET, 0,\r\npayload, 16, true, false);\r\nar9003_mci_send_message(ah, MCI_SYS_WAKING, 0,\r\nNULL, 0, true, false);\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE;\r\nar9003_mci_state(ah, MCI_STATE_RESET_REQ_WAKE, NULL);\r\nar9003_mci_state(ah, MCI_STATE_SET_BT_AWAKE, NULL);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING;\r\nif (ar9003_mci_state(ah, MCI_STATE_BT, NULL) == MCI_BT_SLEEP) {\r\nif (ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP, NULL) !=\r\nMCI_BT_SLEEP)\r\nar9003_mci_state(ah, MCI_STATE_SET_BT_AWAKE,\r\nNULL);\r\n}\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING;\r\nif (ar9003_mci_state(ah, MCI_STATE_BT, NULL) == MCI_BT_AWAKE) {\r\nif (ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP, NULL) !=\r\nMCI_BT_AWAKE)\r\nar9003_mci_state(ah, MCI_STATE_SET_BT_SLEEP,\r\nNULL);\r\n}\r\n}\r\nif ((mci_int & AR_MCI_INTERRUPT_RX_INVALID_HDR) ||\r\n(mci_int & AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT)) {\r\nar9003_mci_state(ah, MCI_STATE_RECOVER_RX, NULL);\r\nskip_gpm = true;\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SCHD_INFO) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SCHD_INFO;\r\noffset = ar9003_mci_state(ah, MCI_STATE_LAST_SCHD_MSG_OFFSET,\r\nNULL);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_GPM) {\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_GPM;\r\nwhile (more_data == MCI_GPM_MORE) {\r\npgpm = mci->gpm_buf.bf_addr;\r\noffset = ar9003_mci_state(ah, MCI_STATE_NEXT_GPM_OFFSET,\r\n&more_data);\r\nif (offset == MCI_GPM_INVALID)\r\nbreak;\r\npgpm += (offset >> 2);\r\nsubtype = MCI_GPM_TYPE(pgpm);\r\nopcode = MCI_GPM_OPCODE(pgpm);\r\nif (skip_gpm)\r\ngoto recycle;\r\nif (MCI_GPM_IS_CAL_TYPE(subtype)) {\r\nath_mci_cal_msg(sc, subtype, (u8 *)pgpm);\r\n} else {\r\nswitch (subtype) {\r\ncase MCI_GPM_COEX_AGENT:\r\nath_mci_msg(sc, opcode, (u8 *)pgpm);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nrecycle:\r\nMCI_GPM_RECYCLE(pgpm);\r\n}\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_HW_MSG_MASK) {\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_LNA_CONTROL)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_LNA_CONTROL;\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_LNA_INFO)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_LNA_INFO;\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_INFO) {\r\nint value_dbm = ar9003_mci_state(ah,\r\nMCI_STATE_CONT_RSSI_POWER, NULL);\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_INFO;\r\nif (ar9003_mci_state(ah, MCI_STATE_CONT_TXRX, NULL))\r\nath_dbg(common, MCI,\r\n"MCI CONT_INFO: (tx) pri = %d, pwr = %d dBm\n",\r\nar9003_mci_state(ah,\r\nMCI_STATE_CONT_PRIORITY, NULL),\r\nvalue_dbm);\r\nelse\r\nath_dbg(common, MCI,\r\n"MCI CONT_INFO: (rx) pri = %d,pwr = %d dBm\n",\r\nar9003_mci_state(ah,\r\nMCI_STATE_CONT_PRIORITY, NULL),\r\nvalue_dbm);\r\n}\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_NACK)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_NACK;\r\nif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_RST)\r\nmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_RST;\r\n}\r\nif ((mci_int & AR_MCI_INTERRUPT_RX_INVALID_HDR) ||\r\n(mci_int & AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT))\r\nmci_int &= ~(AR_MCI_INTERRUPT_RX_INVALID_HDR |\r\nAR_MCI_INTERRUPT_CONT_INFO_TIMEOUT);\r\n}
