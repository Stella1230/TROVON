static void\r\nacpi_populate_handler_object(struct acpi_object_notify_handler *handler_obj,\r\nu32 handler_type,\r\nacpi_notify_handler handler, void *context,\r\nstruct acpi_object_notify_handler *next)\r\n{\r\nhandler_obj->handler_type = handler_type;\r\nhandler_obj->handler = handler;\r\nhandler_obj->context = context;\r\nhandler_obj->next = next;\r\n}\r\nstatic acpi_status\r\nacpi_add_handler_object(struct acpi_object_notify_handler *parent_obj,\r\nacpi_notify_handler handler, void *context)\r\n{\r\nstruct acpi_object_notify_handler *handler_obj;\r\nif (parent_obj->handler_type & ACPI_DEVICE_NOTIFY)\r\nreturn AE_BAD_PARAMETER;\r\nhandler_obj = ACPI_ALLOCATE_ZEROED(sizeof(*handler_obj));\r\nif (!handler_obj)\r\nreturn AE_NO_MEMORY;\r\nacpi_populate_handler_object(handler_obj,\r\nACPI_SYSTEM_NOTIFY,\r\nhandler, context,\r\nparent_obj->next);\r\nparent_obj->next = handler_obj;\r\nreturn AE_OK;\r\n}\r\nacpi_status\r\nacpi_install_notify_handler(acpi_handle device,\r\nu32 handler_type,\r\nacpi_notify_handler handler, void *context)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *notify_obj;\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_notify_handler);\r\nif ((!device) ||\r\n(!handler) || (handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nnode = acpi_ns_validate_handle(device);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (device == ACPI_ROOT_OBJECT) {\r\nif (((handler_type & ACPI_SYSTEM_NOTIFY) &&\r\nacpi_gbl_system_notify.handler) ||\r\n((handler_type & ACPI_DEVICE_NOTIFY) &&\r\nacpi_gbl_device_notify.handler)) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nif (handler_type & ACPI_SYSTEM_NOTIFY) {\r\nacpi_gbl_system_notify.node = node;\r\nacpi_gbl_system_notify.handler = handler;\r\nacpi_gbl_system_notify.context = context;\r\n}\r\nif (handler_type & ACPI_DEVICE_NOTIFY) {\r\nacpi_gbl_device_notify.node = node;\r\nacpi_gbl_device_notify.handler = handler;\r\nacpi_gbl_device_notify.context = context;\r\n}\r\n}\r\nelse {\r\nif (!acpi_ev_is_notify_object(node)) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (obj_desc) {\r\nif ((handler_type & ACPI_DEVICE_NOTIFY) &&\r\nobj_desc->common_notify.device_notify) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nnotify_obj = obj_desc->common_notify.system_notify;\r\nif ((handler_type & ACPI_SYSTEM_NOTIFY) && notify_obj) {\r\nstruct acpi_object_notify_handler *parent_obj;\r\nif (handler_type & ACPI_DEVICE_NOTIFY) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto unlock_and_exit;\r\n}\r\nparent_obj = &notify_obj->notify;\r\nstatus = acpi_add_handler_object(parent_obj,\r\nhandler,\r\ncontext);\r\ngoto unlock_and_exit;\r\n}\r\n} else {\r\nobj_desc = acpi_ut_create_internal_object(node->type);\r\nif (!obj_desc) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nstatus =\r\nacpi_ns_attach_object(device, obj_desc, node->type);\r\nacpi_ut_remove_reference(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nnotify_obj =\r\nacpi_ut_create_internal_object(ACPI_TYPE_LOCAL_NOTIFY);\r\nif (!notify_obj) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nacpi_populate_handler_object(&notify_obj->notify,\r\nhandler_type,\r\nhandler, context,\r\nNULL);\r\nif (handler_type & ACPI_SYSTEM_NOTIFY) {\r\nobj_desc->common_notify.system_notify = notify_obj;\r\n}\r\nif (handler_type & ACPI_DEVICE_NOTIFY) {\r\nobj_desc->common_notify.device_notify = notify_obj;\r\n}\r\nif (handler_type == ACPI_ALL_NOTIFY) {\r\nacpi_ut_add_reference(notify_obj);\r\n}\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_remove_notify_handler(acpi_handle device,\r\nu32 handler_type, acpi_notify_handler handler)\r\n{\r\nunion acpi_operand_object *notify_obj;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_remove_notify_handler);\r\nif ((!device) ||\r\n(!handler) || (handler_type > ACPI_MAX_NOTIFY_HANDLER_TYPE)) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto exit;\r\n}\r\nacpi_os_wait_events_complete(NULL);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nnode = acpi_ns_validate_handle(device);\r\nif (!node) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (device == ACPI_ROOT_OBJECT) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Removing notify handler for namespace root object\n"));\r\nif (((handler_type & ACPI_SYSTEM_NOTIFY) &&\r\n!acpi_gbl_system_notify.handler) ||\r\n((handler_type & ACPI_DEVICE_NOTIFY) &&\r\n!acpi_gbl_device_notify.handler)) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nif (handler_type & ACPI_SYSTEM_NOTIFY) {\r\nacpi_gbl_system_notify.node = NULL;\r\nacpi_gbl_system_notify.handler = NULL;\r\nacpi_gbl_system_notify.context = NULL;\r\n}\r\nif (handler_type & ACPI_DEVICE_NOTIFY) {\r\nacpi_gbl_device_notify.node = NULL;\r\nacpi_gbl_device_notify.handler = NULL;\r\nacpi_gbl_device_notify.context = NULL;\r\n}\r\n}\r\nelse {\r\nif (!acpi_ev_is_notify_object(node)) {\r\nstatus = AE_TYPE;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nif (handler_type & ACPI_SYSTEM_NOTIFY) {\r\nstruct acpi_object_notify_handler *handler_obj;\r\nstruct acpi_object_notify_handler *parent_obj;\r\nnotify_obj = obj_desc->common_notify.system_notify;\r\nif (!notify_obj) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nhandler_obj = &notify_obj->notify;\r\nparent_obj = NULL;\r\nwhile (handler_obj->handler != handler) {\r\nif (handler_obj->next) {\r\nparent_obj = handler_obj;\r\nhandler_obj = handler_obj->next;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (handler_obj->handler != handler) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (parent_obj) {\r\nparent_obj->next = handler_obj->next;\r\nACPI_FREE(handler_obj);\r\n} else if (notify_obj->notify.next) {\r\nparent_obj = &notify_obj->notify;\r\nhandler_obj = notify_obj->notify.next;\r\n*parent_obj = *handler_obj;\r\nACPI_FREE(handler_obj);\r\n} else {\r\nobj_desc->common_notify.system_notify = NULL;\r\nacpi_ut_remove_reference(notify_obj);\r\n}\r\n}\r\nif (handler_type & ACPI_DEVICE_NOTIFY) {\r\nnotify_obj = obj_desc->common_notify.device_notify;\r\nif (!notify_obj) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nif (notify_obj->notify.handler != handler) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc->common_notify.device_notify = NULL;\r\nacpi_ut_remove_reference(notify_obj);\r\n}\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nexit:\r\nif (ACPI_FAILURE(status))\r\nACPI_EXCEPTION((AE_INFO, status, "Removing notify handler"));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_install_exception_handler(acpi_exception_handler handler)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_exception_handler);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_exception_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_exception_handler = handler;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_global_event_handler(ACPI_GBL_EVENT_HANDLER handler, void *context)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_global_event_handler);\r\nif (!handler) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_global_event_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_global_event_handler = handler;\r\nacpi_gbl_global_event_handler_context = context;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_fixed_event_handler(u32 event,\r\nacpi_event_handler handler, void *context)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_fixed_event_handler);\r\nif (event > ACPI_EVENT_MAX) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (NULL != acpi_gbl_fixed_event_handlers[event].handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_fixed_event_handlers[event].handler = handler;\r\nacpi_gbl_fixed_event_handlers[event].context = context;\r\nstatus = acpi_clear_event(event);\r\nif (ACPI_SUCCESS(status))\r\nstatus = acpi_enable_event(event, 0);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO, "Could not enable fixed event 0x%X",\r\nevent));\r\nacpi_gbl_fixed_event_handlers[event].handler = NULL;\r\nacpi_gbl_fixed_event_handlers[event].context = NULL;\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Enabled fixed event %X, Handler=%p\n", event,\r\nhandler));\r\n}\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_remove_fixed_event_handler(u32 event, acpi_event_handler handler)\r\n{\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE(acpi_remove_fixed_event_handler);\r\nif (event > ACPI_EVENT_MAX) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_disable_event(event, 0);\r\nacpi_gbl_fixed_event_handlers[event].handler = NULL;\r\nacpi_gbl_fixed_event_handlers[event].context = NULL;\r\nif (ACPI_FAILURE(status)) {\r\nACPI_WARNING((AE_INFO,\r\n"Could not write to fixed event enable register 0x%X",\r\nevent));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabled fixed event %X\n",\r\nevent));\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_gpe_handler(acpi_handle gpe_device,\r\nu32 gpe_number,\r\nu32 type, acpi_gpe_handler address, void *context)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_handler_info *handler;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_install_gpe_handler);\r\nif ((!address) || (type & ~ACPI_GPE_XRUPT_TYPE_MASK)) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nhandler = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_gpe_handler_info));\r\nif (!handler) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto free_and_exit;\r\n}\r\nif ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) ==\r\nACPI_GPE_DISPATCH_HANDLER) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto free_and_exit;\r\n}\r\nhandler->address = address;\r\nhandler->context = context;\r\nhandler->method_node = gpe_event_info->dispatch.method_node;\r\nhandler->original_flags = gpe_event_info->flags &\r\n(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\r\nif ((handler->original_flags & ACPI_GPE_DISPATCH_METHOD)\r\n&& gpe_event_info->runtime_count) {\r\nhandler->originally_enabled = 1;\r\n(void)acpi_ev_remove_gpe_reference(gpe_event_info);\r\n}\r\ngpe_event_info->dispatch.handler = handler;\r\ngpe_event_info->flags &=\r\n~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\r\ngpe_event_info->flags |= (u8) (type | ACPI_GPE_DISPATCH_HANDLER);\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\nfree_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\nACPI_FREE(handler);\r\ngoto unlock_and_exit;\r\n}\r\nacpi_status\r\nacpi_remove_gpe_handler(acpi_handle gpe_device,\r\nu32 gpe_number, acpi_gpe_handler address)\r\n{\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\nstruct acpi_gpe_handler_info *handler;\r\nacpi_status status;\r\nacpi_cpu_flags flags;\r\nACPI_FUNCTION_TRACE(acpi_remove_gpe_handler);\r\nif (!address) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nacpi_os_wait_events_complete(NULL);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nflags = acpi_os_acquire_lock(acpi_gbl_gpe_lock);\r\ngpe_event_info = acpi_ev_get_gpe_event_info(gpe_device, gpe_number);\r\nif (!gpe_event_info) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif ((gpe_event_info->flags & ACPI_GPE_DISPATCH_MASK) !=\r\nACPI_GPE_DISPATCH_HANDLER) {\r\nstatus = AE_NOT_EXIST;\r\ngoto unlock_and_exit;\r\n}\r\nif (gpe_event_info->dispatch.handler->address != address) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nhandler = gpe_event_info->dispatch.handler;\r\ngpe_event_info->dispatch.method_node = handler->method_node;\r\ngpe_event_info->flags &=\r\n~(ACPI_GPE_XRUPT_TYPE_MASK | ACPI_GPE_DISPATCH_MASK);\r\ngpe_event_info->flags |= handler->original_flags;\r\nif ((handler->original_flags & ACPI_GPE_DISPATCH_METHOD)\r\n&& handler->originally_enabled)\r\n(void)acpi_ev_add_gpe_reference(gpe_event_info);\r\nACPI_FREE(handler);\r\nunlock_and_exit:\r\nacpi_os_release_lock(acpi_gbl_gpe_lock, flags);\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_acquire_global_lock(u16 timeout, u32 * handle)\r\n{\r\nacpi_status status;\r\nif (!handle) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nacpi_ex_enter_interpreter();\r\nstatus = acpi_ex_acquire_mutex_object(timeout,\r\nacpi_gbl_global_lock_mutex,\r\nacpi_os_get_thread_id());\r\nif (ACPI_SUCCESS(status)) {\r\n*handle = acpi_gbl_global_lock_handle;\r\n}\r\nacpi_ex_exit_interpreter();\r\nreturn (status);\r\n}\r\nacpi_status acpi_release_global_lock(u32 handle)\r\n{\r\nacpi_status status;\r\nif (!handle || (handle != acpi_gbl_global_lock_handle)) {\r\nreturn (AE_NOT_ACQUIRED);\r\n}\r\nstatus = acpi_ex_release_mutex_object(acpi_gbl_global_lock_mutex);\r\nreturn (status);\r\n}
