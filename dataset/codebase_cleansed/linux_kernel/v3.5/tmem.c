void tmem_register_hostops(struct tmem_hostops *m)\r\n{\r\ntmem_objnode_tree_init();\r\ntmem_hostops = *m;\r\n}\r\nvoid tmem_register_pamops(struct tmem_pamops *m)\r\n{\r\ntmem_pamops = *m;\r\n}\r\nstatic struct tmem_obj *tmem_obj_find(struct tmem_hashbucket *hb,\r\nstruct tmem_oid *oidp)\r\n{\r\nstruct rb_node *rbnode;\r\nstruct tmem_obj *obj;\r\nrbnode = hb->obj_rb_root.rb_node;\r\nwhile (rbnode) {\r\nBUG_ON(RB_EMPTY_NODE(rbnode));\r\nobj = rb_entry(rbnode, struct tmem_obj, rb_tree_node);\r\nswitch (tmem_oid_compare(oidp, &obj->oid)) {\r\ncase 0:\r\ngoto out;\r\ncase -1:\r\nrbnode = rbnode->rb_left;\r\nbreak;\r\ncase 1:\r\nrbnode = rbnode->rb_right;\r\nbreak;\r\n}\r\n}\r\nobj = NULL;\r\nout:\r\nreturn obj;\r\n}\r\nstatic void tmem_obj_free(struct tmem_obj *obj, struct tmem_hashbucket *hb)\r\n{\r\nstruct tmem_pool *pool;\r\nBUG_ON(obj == NULL);\r\nASSERT_SENTINEL(obj, OBJ);\r\nBUG_ON(obj->pampd_count > 0);\r\npool = obj->pool;\r\nBUG_ON(pool == NULL);\r\nif (obj->objnode_tree_root != NULL)\r\ntmem_pampd_destroy_all_in_obj(obj);\r\nBUG_ON(obj->objnode_tree_root != NULL);\r\nBUG_ON((long)obj->objnode_count != 0);\r\natomic_dec(&pool->obj_count);\r\nBUG_ON(atomic_read(&pool->obj_count) < 0);\r\nINVERT_SENTINEL(obj, OBJ);\r\nobj->pool = NULL;\r\ntmem_oid_set_invalid(&obj->oid);\r\nrb_erase(&obj->rb_tree_node, &hb->obj_rb_root);\r\n}\r\nstatic void tmem_obj_init(struct tmem_obj *obj, struct tmem_hashbucket *hb,\r\nstruct tmem_pool *pool,\r\nstruct tmem_oid *oidp)\r\n{\r\nstruct rb_root *root = &hb->obj_rb_root;\r\nstruct rb_node **new = &(root->rb_node), *parent = NULL;\r\nstruct tmem_obj *this;\r\nBUG_ON(pool == NULL);\r\natomic_inc(&pool->obj_count);\r\nobj->objnode_tree_height = 0;\r\nobj->objnode_tree_root = NULL;\r\nobj->pool = pool;\r\nobj->oid = *oidp;\r\nobj->objnode_count = 0;\r\nobj->pampd_count = 0;\r\n(*tmem_pamops.new_obj)(obj);\r\nSET_SENTINEL(obj, OBJ);\r\nwhile (*new) {\r\nBUG_ON(RB_EMPTY_NODE(*new));\r\nthis = rb_entry(*new, struct tmem_obj, rb_tree_node);\r\nparent = *new;\r\nswitch (tmem_oid_compare(oidp, &this->oid)) {\r\ncase 0:\r\nBUG();\r\nbreak;\r\ncase -1:\r\nnew = &(*new)->rb_left;\r\nbreak;\r\ncase 1:\r\nnew = &(*new)->rb_right;\r\nbreak;\r\n}\r\n}\r\nrb_link_node(&obj->rb_tree_node, parent, new);\r\nrb_insert_color(&obj->rb_tree_node, root);\r\n}\r\nstatic void tmem_pool_flush(struct tmem_pool *pool, bool destroy)\r\n{\r\nstruct rb_node *rbnode;\r\nstruct tmem_obj *obj;\r\nstruct tmem_hashbucket *hb = &pool->hashbucket[0];\r\nint i;\r\nBUG_ON(pool == NULL);\r\nfor (i = 0; i < TMEM_HASH_BUCKETS; i++, hb++) {\r\nspin_lock(&hb->lock);\r\nrbnode = rb_first(&hb->obj_rb_root);\r\nwhile (rbnode != NULL) {\r\nobj = rb_entry(rbnode, struct tmem_obj, rb_tree_node);\r\nrbnode = rb_next(rbnode);\r\ntmem_pampd_destroy_all_in_obj(obj);\r\ntmem_obj_free(obj, hb);\r\n(*tmem_hostops.obj_free)(obj, pool);\r\n}\r\nspin_unlock(&hb->lock);\r\n}\r\nif (destroy)\r\nlist_del(&pool->pool_list);\r\n}\r\nstatic void tmem_objnode_tree_init(void)\r\n{\r\nunsigned int ht, tmp;\r\nfor (ht = 0; ht < ARRAY_SIZE(tmem_objnode_tree_h2max); ht++) {\r\ntmp = ht * OBJNODE_TREE_MAP_SHIFT;\r\nif (tmp >= OBJNODE_TREE_INDEX_BITS)\r\ntmem_objnode_tree_h2max[ht] = ~0UL;\r\nelse\r\ntmem_objnode_tree_h2max[ht] =\r\n(~0UL >> (OBJNODE_TREE_INDEX_BITS - tmp - 1)) >> 1;\r\n}\r\n}\r\nstatic struct tmem_objnode *tmem_objnode_alloc(struct tmem_obj *obj)\r\n{\r\nstruct tmem_objnode *objnode;\r\nASSERT_SENTINEL(obj, OBJ);\r\nBUG_ON(obj->pool == NULL);\r\nASSERT_SENTINEL(obj->pool, POOL);\r\nobjnode = (*tmem_hostops.objnode_alloc)(obj->pool);\r\nif (unlikely(objnode == NULL))\r\ngoto out;\r\nobjnode->obj = obj;\r\nSET_SENTINEL(objnode, OBJNODE);\r\nmemset(&objnode->slots, 0, sizeof(objnode->slots));\r\nobjnode->slots_in_use = 0;\r\nobj->objnode_count++;\r\nout:\r\nreturn objnode;\r\n}\r\nstatic void tmem_objnode_free(struct tmem_objnode *objnode)\r\n{\r\nstruct tmem_pool *pool;\r\nint i;\r\nBUG_ON(objnode == NULL);\r\nfor (i = 0; i < OBJNODE_TREE_MAP_SIZE; i++)\r\nBUG_ON(objnode->slots[i] != NULL);\r\nASSERT_SENTINEL(objnode, OBJNODE);\r\nINVERT_SENTINEL(objnode, OBJNODE);\r\nBUG_ON(objnode->obj == NULL);\r\nASSERT_SENTINEL(objnode->obj, OBJ);\r\npool = objnode->obj->pool;\r\nBUG_ON(pool == NULL);\r\nASSERT_SENTINEL(pool, POOL);\r\nobjnode->obj->objnode_count--;\r\nobjnode->obj = NULL;\r\n(*tmem_hostops.objnode_free)(objnode, pool);\r\n}\r\nstatic void **__tmem_pampd_lookup_in_obj(struct tmem_obj *obj, uint32_t index)\r\n{\r\nunsigned int height, shift;\r\nstruct tmem_objnode **slot = NULL;\r\nBUG_ON(obj == NULL);\r\nASSERT_SENTINEL(obj, OBJ);\r\nBUG_ON(obj->pool == NULL);\r\nASSERT_SENTINEL(obj->pool, POOL);\r\nheight = obj->objnode_tree_height;\r\nif (index > tmem_objnode_tree_h2max[obj->objnode_tree_height])\r\ngoto out;\r\nif (height == 0 && obj->objnode_tree_root) {\r\nslot = &obj->objnode_tree_root;\r\ngoto out;\r\n}\r\nshift = (height-1) * OBJNODE_TREE_MAP_SHIFT;\r\nslot = &obj->objnode_tree_root;\r\nwhile (height > 0) {\r\nif (*slot == NULL)\r\ngoto out;\r\nslot = (struct tmem_objnode **)\r\n((*slot)->slots +\r\n((index >> shift) & OBJNODE_TREE_MAP_MASK));\r\nshift -= OBJNODE_TREE_MAP_SHIFT;\r\nheight--;\r\n}\r\nout:\r\nreturn slot != NULL ? (void **)slot : NULL;\r\n}\r\nstatic void *tmem_pampd_lookup_in_obj(struct tmem_obj *obj, uint32_t index)\r\n{\r\nstruct tmem_objnode **slot;\r\nslot = (struct tmem_objnode **)__tmem_pampd_lookup_in_obj(obj, index);\r\nreturn slot != NULL ? *slot : NULL;\r\n}\r\nstatic void *tmem_pampd_replace_in_obj(struct tmem_obj *obj, uint32_t index,\r\nvoid *new_pampd, bool no_free)\r\n{\r\nstruct tmem_objnode **slot;\r\nvoid *ret = NULL;\r\nslot = (struct tmem_objnode **)__tmem_pampd_lookup_in_obj(obj, index);\r\nif ((slot != NULL) && (*slot != NULL)) {\r\nvoid *old_pampd = *(void **)slot;\r\n*(void **)slot = new_pampd;\r\nif (!no_free)\r\n(*tmem_pamops.free)(old_pampd, obj->pool,\r\nNULL, 0, false);\r\nret = new_pampd;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tmem_pampd_add_to_obj(struct tmem_obj *obj, uint32_t index,\r\nvoid *pampd)\r\n{\r\nint ret = 0;\r\nstruct tmem_objnode *objnode = NULL, *newnode, *slot;\r\nunsigned int height, shift;\r\nint offset = 0;\r\nif (index > tmem_objnode_tree_h2max[obj->objnode_tree_height]) {\r\nheight = obj->objnode_tree_height + 1;\r\nif (index > tmem_objnode_tree_h2max[height])\r\nwhile (index > tmem_objnode_tree_h2max[height])\r\nheight++;\r\nif (obj->objnode_tree_root == NULL) {\r\nobj->objnode_tree_height = height;\r\ngoto insert;\r\n}\r\ndo {\r\nnewnode = tmem_objnode_alloc(obj);\r\nif (!newnode) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnewnode->slots[0] = obj->objnode_tree_root;\r\nnewnode->slots_in_use = 1;\r\nobj->objnode_tree_root = newnode;\r\nobj->objnode_tree_height++;\r\n} while (height > obj->objnode_tree_height);\r\n}\r\ninsert:\r\nslot = obj->objnode_tree_root;\r\nheight = obj->objnode_tree_height;\r\nshift = (height-1) * OBJNODE_TREE_MAP_SHIFT;\r\nwhile (height > 0) {\r\nif (slot == NULL) {\r\nslot = tmem_objnode_alloc(obj);\r\nif (!slot) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (objnode) {\r\nobjnode->slots[offset] = slot;\r\nobjnode->slots_in_use++;\r\n} else\r\nobj->objnode_tree_root = slot;\r\n}\r\noffset = (index >> shift) & OBJNODE_TREE_MAP_MASK;\r\nobjnode = slot;\r\nslot = objnode->slots[offset];\r\nshift -= OBJNODE_TREE_MAP_SHIFT;\r\nheight--;\r\n}\r\nBUG_ON(slot != NULL);\r\nif (objnode) {\r\nobjnode->slots_in_use++;\r\nobjnode->slots[offset] = pampd;\r\n} else\r\nobj->objnode_tree_root = pampd;\r\nobj->pampd_count++;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void *tmem_pampd_delete_from_obj(struct tmem_obj *obj, uint32_t index)\r\n{\r\nstruct tmem_objnode_tree_path path[OBJNODE_TREE_MAX_PATH + 1];\r\nstruct tmem_objnode_tree_path *pathp = path;\r\nstruct tmem_objnode *slot = NULL;\r\nunsigned int height, shift;\r\nint offset;\r\nBUG_ON(obj == NULL);\r\nASSERT_SENTINEL(obj, OBJ);\r\nBUG_ON(obj->pool == NULL);\r\nASSERT_SENTINEL(obj->pool, POOL);\r\nheight = obj->objnode_tree_height;\r\nif (index > tmem_objnode_tree_h2max[height])\r\ngoto out;\r\nslot = obj->objnode_tree_root;\r\nif (height == 0 && obj->objnode_tree_root) {\r\nobj->objnode_tree_root = NULL;\r\ngoto out;\r\n}\r\nshift = (height - 1) * OBJNODE_TREE_MAP_SHIFT;\r\npathp->objnode = NULL;\r\ndo {\r\nif (slot == NULL)\r\ngoto out;\r\npathp++;\r\noffset = (index >> shift) & OBJNODE_TREE_MAP_MASK;\r\npathp->offset = offset;\r\npathp->objnode = slot;\r\nslot = slot->slots[offset];\r\nshift -= OBJNODE_TREE_MAP_SHIFT;\r\nheight--;\r\n} while (height > 0);\r\nif (slot == NULL)\r\ngoto out;\r\nwhile (pathp->objnode) {\r\npathp->objnode->slots[pathp->offset] = NULL;\r\npathp->objnode->slots_in_use--;\r\nif (pathp->objnode->slots_in_use) {\r\nif (pathp->objnode == obj->objnode_tree_root) {\r\nwhile (obj->objnode_tree_height > 0 &&\r\nobj->objnode_tree_root->slots_in_use == 1 &&\r\nobj->objnode_tree_root->slots[0]) {\r\nstruct tmem_objnode *to_free =\r\nobj->objnode_tree_root;\r\nobj->objnode_tree_root =\r\nto_free->slots[0];\r\nobj->objnode_tree_height--;\r\nto_free->slots[0] = NULL;\r\nto_free->slots_in_use = 0;\r\ntmem_objnode_free(to_free);\r\n}\r\n}\r\ngoto out;\r\n}\r\ntmem_objnode_free(pathp->objnode);\r\npathp--;\r\n}\r\nobj->objnode_tree_height = 0;\r\nobj->objnode_tree_root = NULL;\r\nout:\r\nif (slot != NULL)\r\nobj->pampd_count--;\r\nBUG_ON(obj->pampd_count < 0);\r\nreturn slot;\r\n}\r\nstatic void tmem_objnode_node_destroy(struct tmem_obj *obj,\r\nstruct tmem_objnode *objnode,\r\nunsigned int ht)\r\n{\r\nint i;\r\nif (ht == 0)\r\nreturn;\r\nfor (i = 0; i < OBJNODE_TREE_MAP_SIZE; i++) {\r\nif (objnode->slots[i]) {\r\nif (ht == 1) {\r\nobj->pampd_count--;\r\n(*tmem_pamops.free)(objnode->slots[i],\r\nobj->pool, NULL, 0, true);\r\nobjnode->slots[i] = NULL;\r\ncontinue;\r\n}\r\ntmem_objnode_node_destroy(obj, objnode->slots[i], ht-1);\r\ntmem_objnode_free(objnode->slots[i]);\r\nobjnode->slots[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void tmem_pampd_destroy_all_in_obj(struct tmem_obj *obj)\r\n{\r\nif (obj->objnode_tree_root == NULL)\r\nreturn;\r\nif (obj->objnode_tree_height == 0) {\r\nobj->pampd_count--;\r\n(*tmem_pamops.free)(obj->objnode_tree_root,\r\nobj->pool, NULL, 0, true);\r\n} else {\r\ntmem_objnode_node_destroy(obj, obj->objnode_tree_root,\r\nobj->objnode_tree_height);\r\ntmem_objnode_free(obj->objnode_tree_root);\r\nobj->objnode_tree_height = 0;\r\n}\r\nobj->objnode_tree_root = NULL;\r\n(*tmem_pamops.free_obj)(obj->pool, obj);\r\n}\r\nint tmem_put(struct tmem_pool *pool, struct tmem_oid *oidp, uint32_t index,\r\nchar *data, size_t size, bool raw, int ephemeral)\r\n{\r\nstruct tmem_obj *obj = NULL, *objfound = NULL, *objnew = NULL;\r\nvoid *pampd = NULL, *pampd_del = NULL;\r\nint ret = -ENOMEM;\r\nstruct tmem_hashbucket *hb;\r\nhb = &pool->hashbucket[tmem_oid_hash(oidp)];\r\nspin_lock(&hb->lock);\r\nobj = objfound = tmem_obj_find(hb, oidp);\r\nif (obj != NULL) {\r\npampd = tmem_pampd_lookup_in_obj(objfound, index);\r\nif (pampd != NULL) {\r\npampd_del = tmem_pampd_delete_from_obj(obj, index);\r\nBUG_ON(pampd_del != pampd);\r\n(*tmem_pamops.free)(pampd, pool, oidp, index, true);\r\nif (obj->pampd_count == 0) {\r\nobjnew = obj;\r\nobjfound = NULL;\r\n}\r\npampd = NULL;\r\n}\r\n} else {\r\nobj = objnew = (*tmem_hostops.obj_alloc)(pool);\r\nif (unlikely(obj == NULL)) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntmem_obj_init(obj, hb, pool, oidp);\r\n}\r\nBUG_ON(obj == NULL);\r\nBUG_ON(((objnew != obj) && (objfound != obj)) || (objnew == objfound));\r\npampd = (*tmem_pamops.create)(data, size, raw, ephemeral,\r\nobj->pool, &obj->oid, index);\r\nif (unlikely(pampd == NULL))\r\ngoto free;\r\nret = tmem_pampd_add_to_obj(obj, index, pampd);\r\nif (unlikely(ret == -ENOMEM))\r\ngoto delete_and_free;\r\ngoto out;\r\ndelete_and_free:\r\n(void)tmem_pampd_delete_from_obj(obj, index);\r\nfree:\r\nif (pampd)\r\n(*tmem_pamops.free)(pampd, pool, NULL, 0, true);\r\nif (objnew) {\r\ntmem_obj_free(objnew, hb);\r\n(*tmem_hostops.obj_free)(objnew, pool);\r\n}\r\nout:\r\nspin_unlock(&hb->lock);\r\nreturn ret;\r\n}\r\nvoid *tmem_localify_get_pampd(struct tmem_pool *pool, struct tmem_oid *oidp,\r\nuint32_t index, struct tmem_obj **ret_obj,\r\nvoid **saved_hb)\r\n{\r\nstruct tmem_hashbucket *hb;\r\nstruct tmem_obj *obj = NULL;\r\nvoid *pampd = NULL;\r\nhb = &pool->hashbucket[tmem_oid_hash(oidp)];\r\nspin_lock(&hb->lock);\r\nobj = tmem_obj_find(hb, oidp);\r\nif (likely(obj != NULL))\r\npampd = tmem_pampd_lookup_in_obj(obj, index);\r\n*ret_obj = obj;\r\n*saved_hb = (void *)hb;\r\nreturn pampd;\r\n}\r\nvoid tmem_localify_finish(struct tmem_obj *obj, uint32_t index,\r\nvoid *pampd, void *saved_hb, bool delete)\r\n{\r\nstruct tmem_hashbucket *hb = (struct tmem_hashbucket *)saved_hb;\r\nBUG_ON(!spin_is_locked(&hb->lock));\r\nif (pampd != NULL) {\r\nBUG_ON(obj == NULL);\r\n(void)tmem_pampd_replace_in_obj(obj, index, pampd, 1);\r\n} else if (delete) {\r\nBUG_ON(obj == NULL);\r\n(void)tmem_pampd_delete_from_obj(obj, index);\r\n}\r\nspin_unlock(&hb->lock);\r\n}\r\nstatic int tmem_repatriate(void **ppampd, struct tmem_hashbucket *hb,\r\nstruct tmem_pool *pool, struct tmem_oid *oidp,\r\nuint32_t index, bool free, char *data)\r\n{\r\nvoid *old_pampd = *ppampd, *new_pampd = NULL;\r\nbool intransit = false;\r\nint ret = 0;\r\nif (!is_ephemeral(pool))\r\nnew_pampd = (*tmem_pamops.repatriate_preload)(\r\nold_pampd, pool, oidp, index, &intransit);\r\nif (intransit)\r\nret = -EAGAIN;\r\nelse if (new_pampd != NULL)\r\n*ppampd = new_pampd;\r\nspin_unlock(&hb->lock);\r\nif (!intransit)\r\nret = (*tmem_pamops.repatriate)(old_pampd, new_pampd, pool,\r\noidp, index, free, data);\r\nreturn ret;\r\n}\r\nint tmem_get(struct tmem_pool *pool, struct tmem_oid *oidp, uint32_t index,\r\nchar *data, size_t *size, bool raw, int get_and_free)\r\n{\r\nstruct tmem_obj *obj;\r\nvoid *pampd;\r\nbool ephemeral = is_ephemeral(pool);\r\nint ret = -1;\r\nstruct tmem_hashbucket *hb;\r\nbool free = (get_and_free == 1) || ((get_and_free == 0) && ephemeral);\r\nbool lock_held = 0;\r\nvoid **ppampd;\r\nagain:\r\nhb = &pool->hashbucket[tmem_oid_hash(oidp)];\r\nspin_lock(&hb->lock);\r\nlock_held = 1;\r\nobj = tmem_obj_find(hb, oidp);\r\nif (obj == NULL)\r\ngoto out;\r\nppampd = __tmem_pampd_lookup_in_obj(obj, index);\r\nif (ppampd == NULL)\r\ngoto out;\r\nif (tmem_pamops.is_remote(*ppampd)) {\r\nret = tmem_repatriate(ppampd, hb, pool, oidp,\r\nindex, free, data);\r\nlock_held = 0;\r\nif (ret == -EAGAIN) {\r\nusleep_range(10, 1000);\r\ngoto again;\r\n} else if (ret != 0) {\r\nif (ret != -ENOENT)\r\npr_err("UNTESTED case in tmem_get, ret=%d\n",\r\nret);\r\nret = -1;\r\ngoto out;\r\n}\r\ngoto out;\r\n}\r\nif (free)\r\npampd = tmem_pampd_delete_from_obj(obj, index);\r\nelse\r\npampd = tmem_pampd_lookup_in_obj(obj, index);\r\nif (pampd == NULL)\r\ngoto out;\r\nif (free) {\r\nif (obj->pampd_count == 0) {\r\ntmem_obj_free(obj, hb);\r\n(*tmem_hostops.obj_free)(obj, pool);\r\nobj = NULL;\r\n}\r\n}\r\nif (free)\r\nret = (*tmem_pamops.get_data_and_free)(\r\ndata, size, raw, pampd, pool, oidp, index);\r\nelse\r\nret = (*tmem_pamops.get_data)(\r\ndata, size, raw, pampd, pool, oidp, index);\r\nif (ret < 0)\r\ngoto out;\r\nret = 0;\r\nout:\r\nif (lock_held)\r\nspin_unlock(&hb->lock);\r\nreturn ret;\r\n}\r\nint tmem_flush_page(struct tmem_pool *pool,\r\nstruct tmem_oid *oidp, uint32_t index)\r\n{\r\nstruct tmem_obj *obj;\r\nvoid *pampd;\r\nint ret = -1;\r\nstruct tmem_hashbucket *hb;\r\nhb = &pool->hashbucket[tmem_oid_hash(oidp)];\r\nspin_lock(&hb->lock);\r\nobj = tmem_obj_find(hb, oidp);\r\nif (obj == NULL)\r\ngoto out;\r\npampd = tmem_pampd_delete_from_obj(obj, index);\r\nif (pampd == NULL)\r\ngoto out;\r\n(*tmem_pamops.free)(pampd, pool, oidp, index, true);\r\nif (obj->pampd_count == 0) {\r\ntmem_obj_free(obj, hb);\r\n(*tmem_hostops.obj_free)(obj, pool);\r\n}\r\nret = 0;\r\nout:\r\nspin_unlock(&hb->lock);\r\nreturn ret;\r\n}\r\nint tmem_replace(struct tmem_pool *pool, struct tmem_oid *oidp,\r\nuint32_t index, void *new_pampd)\r\n{\r\nstruct tmem_obj *obj;\r\nint ret = -1;\r\nstruct tmem_hashbucket *hb;\r\nhb = &pool->hashbucket[tmem_oid_hash(oidp)];\r\nspin_lock(&hb->lock);\r\nobj = tmem_obj_find(hb, oidp);\r\nif (obj == NULL)\r\ngoto out;\r\nnew_pampd = tmem_pampd_replace_in_obj(obj, index, new_pampd, 0);\r\nret = (*tmem_pamops.replace_in_obj)(new_pampd, obj);\r\nout:\r\nspin_unlock(&hb->lock);\r\nreturn ret;\r\n}\r\nint tmem_flush_object(struct tmem_pool *pool, struct tmem_oid *oidp)\r\n{\r\nstruct tmem_obj *obj;\r\nstruct tmem_hashbucket *hb;\r\nint ret = -1;\r\nhb = &pool->hashbucket[tmem_oid_hash(oidp)];\r\nspin_lock(&hb->lock);\r\nobj = tmem_obj_find(hb, oidp);\r\nif (obj == NULL)\r\ngoto out;\r\ntmem_pampd_destroy_all_in_obj(obj);\r\ntmem_obj_free(obj, hb);\r\n(*tmem_hostops.obj_free)(obj, pool);\r\nret = 0;\r\nout:\r\nspin_unlock(&hb->lock);\r\nreturn ret;\r\n}\r\nint tmem_destroy_pool(struct tmem_pool *pool)\r\n{\r\nint ret = -1;\r\nif (pool == NULL)\r\ngoto out;\r\ntmem_pool_flush(pool, 1);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nvoid tmem_new_pool(struct tmem_pool *pool, uint32_t flags)\r\n{\r\nint persistent = flags & TMEM_POOL_PERSIST;\r\nint shared = flags & TMEM_POOL_SHARED;\r\nstruct tmem_hashbucket *hb = &pool->hashbucket[0];\r\nint i;\r\nfor (i = 0; i < TMEM_HASH_BUCKETS; i++, hb++) {\r\nhb->obj_rb_root = RB_ROOT;\r\nspin_lock_init(&hb->lock);\r\n}\r\nINIT_LIST_HEAD(&pool->pool_list);\r\natomic_set(&pool->obj_count, 0);\r\nSET_SENTINEL(pool, POOL);\r\nlist_add_tail(&pool->pool_list, &tmem_global_pool_list);\r\npool->persistent = persistent;\r\npool->shared = shared;\r\n}
