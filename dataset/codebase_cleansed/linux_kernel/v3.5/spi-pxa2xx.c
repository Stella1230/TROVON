static void cs_assert(struct driver_data *drv_data)\r\n{\r\nstruct chip_data *chip = drv_data->cur_chip;\r\nif (drv_data->ssp_type == CE4100_SSP) {\r\nwrite_SSSR(drv_data->cur_chip->frm, drv_data->ioaddr);\r\nreturn;\r\n}\r\nif (chip->cs_control) {\r\nchip->cs_control(PXA2XX_CS_ASSERT);\r\nreturn;\r\n}\r\nif (gpio_is_valid(chip->gpio_cs))\r\ngpio_set_value(chip->gpio_cs, chip->gpio_cs_inverted);\r\n}\r\nstatic void cs_deassert(struct driver_data *drv_data)\r\n{\r\nstruct chip_data *chip = drv_data->cur_chip;\r\nif (drv_data->ssp_type == CE4100_SSP)\r\nreturn;\r\nif (chip->cs_control) {\r\nchip->cs_control(PXA2XX_CS_DEASSERT);\r\nreturn;\r\n}\r\nif (gpio_is_valid(chip->gpio_cs))\r\ngpio_set_value(chip->gpio_cs, !chip->gpio_cs_inverted);\r\n}\r\nstatic void write_SSSR_CS(struct driver_data *drv_data, u32 val)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nif (drv_data->ssp_type == CE4100_SSP)\r\nval |= read_SSSR(reg) & SSSR_ALT_FRM_MASK;\r\nwrite_SSSR(val, reg);\r\n}\r\nstatic int pxa25x_ssp_comp(struct driver_data *drv_data)\r\n{\r\nif (drv_data->ssp_type == PXA25x_SSP)\r\nreturn 1;\r\nif (drv_data->ssp_type == CE4100_SSP)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int flush(struct driver_data *drv_data)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nvoid __iomem *reg = drv_data->ioaddr;\r\ndo {\r\nwhile (read_SSSR(reg) & SSSR_RNE) {\r\nread_SSDR(reg);\r\n}\r\n} while ((read_SSSR(reg) & SSSR_BSY) && --limit);\r\nwrite_SSSR_CS(drv_data, SSSR_ROR);\r\nreturn limit;\r\n}\r\nstatic int null_writer(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nu8 n_bytes = drv_data->n_bytes;\r\nif (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\nwrite_SSDR(0, reg);\r\ndrv_data->tx += n_bytes;\r\nreturn 1;\r\n}\r\nstatic int null_reader(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nu8 n_bytes = drv_data->n_bytes;\r\nwhile ((read_SSSR(reg) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\nread_SSDR(reg);\r\ndrv_data->rx += n_bytes;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic int u8_writer(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nif (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\nwrite_SSDR(*(u8 *)(drv_data->tx), reg);\r\n++drv_data->tx;\r\nreturn 1;\r\n}\r\nstatic int u8_reader(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nwhile ((read_SSSR(reg) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\n*(u8 *)(drv_data->rx) = read_SSDR(reg);\r\n++drv_data->rx;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic int u16_writer(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nif (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\nwrite_SSDR(*(u16 *)(drv_data->tx), reg);\r\ndrv_data->tx += 2;\r\nreturn 1;\r\n}\r\nstatic int u16_reader(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nwhile ((read_SSSR(reg) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\n*(u16 *)(drv_data->rx) = read_SSDR(reg);\r\ndrv_data->rx += 2;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic int u32_writer(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nif (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\nwrite_SSDR(*(u32 *)(drv_data->tx), reg);\r\ndrv_data->tx += 4;\r\nreturn 1;\r\n}\r\nstatic int u32_reader(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nwhile ((read_SSSR(reg) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\n*(u32 *)(drv_data->rx) = read_SSDR(reg);\r\ndrv_data->rx += 4;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic void *next_transfer(struct driver_data *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nstruct spi_transfer *trans = drv_data->cur_transfer;\r\nif (trans->transfer_list.next != &msg->transfers) {\r\ndrv_data->cur_transfer =\r\nlist_entry(trans->transfer_list.next,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nreturn RUNNING_STATE;\r\n} else\r\nreturn DONE_STATE;\r\n}\r\nstatic int map_dma_buffers(struct driver_data *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nstruct device *dev = &msg->spi->dev;\r\nif (!drv_data->cur_chip->enable_dma)\r\nreturn 0;\r\nif (msg->is_dma_mapped)\r\nreturn drv_data->rx_dma && drv_data->tx_dma;\r\nif (!IS_DMA_ALIGNED(drv_data->rx) || !IS_DMA_ALIGNED(drv_data->tx))\r\nreturn 0;\r\nif (drv_data->rx == NULL) {\r\n*drv_data->null_dma_buf = 0;\r\ndrv_data->rx = drv_data->null_dma_buf;\r\ndrv_data->rx_map_len = 4;\r\n} else\r\ndrv_data->rx_map_len = drv_data->len;\r\nif (drv_data->tx == NULL) {\r\n*drv_data->null_dma_buf = 0;\r\ndrv_data->tx = drv_data->null_dma_buf;\r\ndrv_data->tx_map_len = 4;\r\n} else\r\ndrv_data->tx_map_len = drv_data->len;\r\ndrv_data->tx_dma = dma_map_single(dev, drv_data->tx,\r\ndrv_data->tx_map_len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, drv_data->tx_dma))\r\nreturn 0;\r\ndrv_data->rx_dma = dma_map_single(dev, drv_data->rx,\r\ndrv_data->rx_map_len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, drv_data->rx_dma)) {\r\ndma_unmap_single(dev, drv_data->tx_dma,\r\ndrv_data->tx_map_len, DMA_TO_DEVICE);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void unmap_dma_buffers(struct driver_data *drv_data)\r\n{\r\nstruct device *dev;\r\nif (!drv_data->dma_mapped)\r\nreturn;\r\nif (!drv_data->cur_msg->is_dma_mapped) {\r\ndev = &drv_data->cur_msg->spi->dev;\r\ndma_unmap_single(dev, drv_data->rx_dma,\r\ndrv_data->rx_map_len, DMA_FROM_DEVICE);\r\ndma_unmap_single(dev, drv_data->tx_dma,\r\ndrv_data->tx_map_len, DMA_TO_DEVICE);\r\n}\r\ndrv_data->dma_mapped = 0;\r\n}\r\nstatic void giveback(struct driver_data *drv_data)\r\n{\r\nstruct spi_transfer* last_transfer;\r\nunsigned long flags;\r\nstruct spi_message *msg;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nmsg = drv_data->cur_msg;\r\ndrv_data->cur_msg = NULL;\r\ndrv_data->cur_transfer = NULL;\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nlast_transfer = list_entry(msg->transfers.prev,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (last_transfer->delay_usecs)\r\nudelay(last_transfer->delay_usecs);\r\nif (!last_transfer->cs_change)\r\ncs_deassert(drv_data);\r\nelse {\r\nstruct spi_message *next_msg;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (list_empty(&drv_data->queue))\r\nnext_msg = NULL;\r\nelse\r\nnext_msg = list_entry(drv_data->queue.next,\r\nstruct spi_message, queue);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nif (next_msg && next_msg->spi != msg->spi)\r\nnext_msg = NULL;\r\nif (!next_msg || msg->state == ERROR_STATE)\r\ncs_deassert(drv_data);\r\n}\r\nmsg->state = NULL;\r\nif (msg->complete)\r\nmsg->complete(msg->context);\r\ndrv_data->cur_chip = NULL;\r\n}\r\nstatic int wait_ssp_rx_stall(void const __iomem *ioaddr)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nwhile ((read_SSSR(ioaddr) & SSSR_BSY) && --limit)\r\ncpu_relax();\r\nreturn limit;\r\n}\r\nstatic int wait_dma_channel_stop(int channel)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\nwhile (!(DCSR(channel) & DCSR_STOPSTATE) && --limit)\r\ncpu_relax();\r\nreturn limit;\r\n}\r\nstatic void dma_error_stop(struct driver_data *drv_data, const char *msg)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nDCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;\r\nDCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nwrite_SSCR1(read_SSCR1(reg) & ~drv_data->dma_cr1, reg);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\nflush(drv_data);\r\nwrite_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);\r\nunmap_dma_buffers(drv_data);\r\ndev_err(&drv_data->pdev->dev, "%s\n", msg);\r\ndrv_data->cur_msg->state = ERROR_STATE;\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void dma_transfer_complete(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nwrite_SSCR1(read_SSCR1(reg) & ~drv_data->dma_cr1, reg);\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nDCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;\r\nDCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;\r\nif (wait_dma_channel_stop(drv_data->rx_channel) == 0)\r\ndev_err(&drv_data->pdev->dev,\r\n"dma_handler: dma rx channel stop failed\n");\r\nif (wait_ssp_rx_stall(drv_data->ioaddr) == 0)\r\ndev_err(&drv_data->pdev->dev,\r\n"dma_transfer: ssp rx stall failed\n");\r\nunmap_dma_buffers(drv_data);\r\ndrv_data->rx += drv_data->len -\r\n(DCMD(drv_data->rx_channel) & DCMD_LENGTH);\r\ndrv_data->read(drv_data);\r\nmsg->actual_length += drv_data->len -\r\n(drv_data->rx_end - drv_data->rx);\r\nmsg->state = next_transfer(drv_data);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void dma_handler(int channel, void *data)\r\n{\r\nstruct driver_data *drv_data = data;\r\nu32 irq_status = DCSR(channel) & DMA_INT_MASK;\r\nif (irq_status & DCSR_BUSERR) {\r\nif (channel == drv_data->tx_channel)\r\ndma_error_stop(drv_data,\r\n"dma_handler: "\r\n"bad bus address on tx channel");\r\nelse\r\ndma_error_stop(drv_data,\r\n"dma_handler: "\r\n"bad bus address on rx channel");\r\nreturn;\r\n}\r\nif ((channel == drv_data->tx_channel)\r\n&& (irq_status & DCSR_ENDINTR)\r\n&& (drv_data->ssp_type == PXA25x_SSP)) {\r\nif (wait_ssp_rx_stall(drv_data->ioaddr) == 0)\r\ndev_err(&drv_data->pdev->dev,\r\n"dma_handler: ssp rx stall failed\n");\r\ndma_transfer_complete(drv_data);\r\n}\r\n}\r\nstatic irqreturn_t dma_transfer(struct driver_data *drv_data)\r\n{\r\nu32 irq_status;\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nirq_status = read_SSSR(reg) & drv_data->mask_sr;\r\nif (irq_status & SSSR_ROR) {\r\ndma_error_stop(drv_data, "dma_transfer: fifo overrun");\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((irq_status & SSSR_TINT)\r\n&& (DCSR(drv_data->tx_channel) & DCSR_RUN)) {\r\nwrite_SSSR(SSSR_TINT, reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (irq_status & SSSR_TINT || drv_data->rx == drv_data->rx_end) {\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\ndma_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void reset_sccr1(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nstruct chip_data *chip = drv_data->cur_chip;\r\nu32 sccr1_reg;\r\nsccr1_reg = read_SSCR1(reg) & ~drv_data->int_cr1;\r\nsccr1_reg &= ~SSCR1_RFT;\r\nsccr1_reg |= chip->threshold;\r\nwrite_SSCR1(sccr1_reg, reg);\r\n}\r\nstatic void int_error_stop(struct driver_data *drv_data, const char* msg)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nreset_sccr1(drv_data);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\nflush(drv_data);\r\nwrite_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);\r\ndev_err(&drv_data->pdev->dev, "%s\n", msg);\r\ndrv_data->cur_msg->state = ERROR_STATE;\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void int_transfer_complete(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nreset_sccr1(drv_data);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\ndrv_data->cur_msg->actual_length += drv_data->len -\r\n(drv_data->rx_end - drv_data->rx);\r\ndrv_data->cur_msg->state = next_transfer(drv_data);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic irqreturn_t interrupt_transfer(struct driver_data *drv_data)\r\n{\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nu32 irq_mask = (read_SSCR1(reg) & SSCR1_TIE) ?\r\ndrv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;\r\nu32 irq_status = read_SSSR(reg) & irq_mask;\r\nif (irq_status & SSSR_ROR) {\r\nint_error_stop(drv_data, "interrupt_transfer: fifo overrun");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (irq_status & SSSR_TINT) {\r\nwrite_SSSR(SSSR_TINT, reg);\r\nif (drv_data->read(drv_data)) {\r\nint_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\ndo {\r\nif (drv_data->read(drv_data)) {\r\nint_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\n} while (drv_data->write(drv_data));\r\nif (drv_data->read(drv_data)) {\r\nint_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (drv_data->tx == drv_data->tx_end) {\r\nu32 bytes_left;\r\nu32 sccr1_reg;\r\nsccr1_reg = read_SSCR1(reg);\r\nsccr1_reg &= ~SSCR1_TIE;\r\nif (pxa25x_ssp_comp(drv_data)) {\r\nsccr1_reg &= ~SSCR1_RFT;\r\nbytes_left = drv_data->rx_end - drv_data->rx;\r\nswitch (drv_data->n_bytes) {\r\ncase 4:\r\nbytes_left >>= 1;\r\ncase 2:\r\nbytes_left >>= 1;\r\n}\r\nif (bytes_left > RX_THRESH_DFLT)\r\nbytes_left = RX_THRESH_DFLT;\r\nsccr1_reg |= SSCR1_RxTresh(bytes_left);\r\n}\r\nwrite_SSCR1(sccr1_reg, reg);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ssp_int(int irq, void *dev_id)\r\n{\r\nstruct driver_data *drv_data = dev_id;\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nu32 sccr1_reg = read_SSCR1(reg);\r\nu32 mask = drv_data->mask_sr;\r\nu32 status;\r\nstatus = read_SSSR(reg);\r\nif (!(sccr1_reg & SSCR1_TIE))\r\nmask &= ~SSSR_TFS;\r\nif (!(status & mask))\r\nreturn IRQ_NONE;\r\nif (!drv_data->cur_msg) {\r\nwrite_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);\r\nwrite_SSCR1(read_SSCR1(reg) & ~drv_data->int_cr1, reg);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, reg);\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\ndev_err(&drv_data->pdev->dev, "bad message state "\r\n"in interrupt handler\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn drv_data->transfer_handler(drv_data);\r\n}\r\nstatic int set_dma_burst_and_threshold(struct chip_data *chip,\r\nstruct spi_device *spi,\r\nu8 bits_per_word, u32 *burst_code,\r\nu32 *threshold)\r\n{\r\nstruct pxa2xx_spi_chip *chip_info =\r\n(struct pxa2xx_spi_chip *)spi->controller_data;\r\nint bytes_per_word;\r\nint burst_bytes;\r\nint thresh_words;\r\nint req_burst_size;\r\nint retval = 0;\r\nif (bits_per_word <= 8)\r\nbytes_per_word = 1;\r\nelse if (bits_per_word <= 16)\r\nbytes_per_word = 2;\r\nelse\r\nbytes_per_word = 4;\r\nif (chip_info)\r\nreq_burst_size = chip_info->dma_burst_size;\r\nelse {\r\nswitch (chip->dma_burst_size) {\r\ndefault:\r\nchip->dma_burst_size = DCMD_BURST8;\r\ncase DCMD_BURST8:\r\nreq_burst_size = 8;\r\nbreak;\r\ncase DCMD_BURST16:\r\nreq_burst_size = 16;\r\nbreak;\r\ncase DCMD_BURST32:\r\nreq_burst_size = 32;\r\nbreak;\r\n}\r\n}\r\nif (req_burst_size <= 8) {\r\n*burst_code = DCMD_BURST8;\r\nburst_bytes = 8;\r\n} else if (req_burst_size <= 16) {\r\nif (bytes_per_word == 1) {\r\n*burst_code = DCMD_BURST8;\r\nburst_bytes = 8;\r\nretval = 1;\r\n} else {\r\n*burst_code = DCMD_BURST16;\r\nburst_bytes = 16;\r\n}\r\n} else {\r\nif (bytes_per_word == 1) {\r\n*burst_code = DCMD_BURST8;\r\nburst_bytes = 8;\r\nretval = 1;\r\n} else if (bytes_per_word == 2) {\r\n*burst_code = DCMD_BURST16;\r\nburst_bytes = 16;\r\nretval = 1;\r\n} else {\r\n*burst_code = DCMD_BURST32;\r\nburst_bytes = 32;\r\n}\r\n}\r\nthresh_words = burst_bytes / bytes_per_word;\r\n*threshold = (SSCR1_RxTresh(thresh_words) & SSCR1_RFT)\r\n| (SSCR1_TxTresh(16-thresh_words) & SSCR1_TFT);\r\nreturn retval;\r\n}\r\nstatic unsigned int ssp_get_clk_div(struct ssp_device *ssp, int rate)\r\n{\r\nunsigned long ssp_clk = clk_get_rate(ssp->clk);\r\nif (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP)\r\nreturn ((ssp_clk / (2 * rate) - 1) & 0xff) << 8;\r\nelse\r\nreturn ((ssp_clk / rate - 1) & 0xfff) << 8;\r\n}\r\nstatic void pump_transfers(unsigned long data)\r\n{\r\nstruct driver_data *drv_data = (struct driver_data *)data;\r\nstruct spi_message *message = NULL;\r\nstruct spi_transfer *transfer = NULL;\r\nstruct spi_transfer *previous = NULL;\r\nstruct chip_data *chip = NULL;\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nvoid __iomem *reg = drv_data->ioaddr;\r\nu32 clk_div = 0;\r\nu8 bits = 0;\r\nu32 speed = 0;\r\nu32 cr0;\r\nu32 cr1;\r\nu32 dma_thresh = drv_data->cur_chip->dma_threshold;\r\nu32 dma_burst = drv_data->cur_chip->dma_burst_size;\r\nmessage = drv_data->cur_msg;\r\ntransfer = drv_data->cur_transfer;\r\nchip = drv_data->cur_chip;\r\nif (message->state == ERROR_STATE) {\r\nmessage->status = -EIO;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\nif (message->state == DONE_STATE) {\r\nmessage->status = 0;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\nif (message->state == RUNNING_STATE) {\r\nprevious = list_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\nif (previous->cs_change)\r\ncs_deassert(drv_data);\r\n}\r\nif (transfer->len > MAX_DMA_LEN && chip->enable_dma) {\r\nif (message->is_dma_mapped\r\n|| transfer->rx_dma || transfer->tx_dma) {\r\ndev_err(&drv_data->pdev->dev,\r\n"pump_transfers: mapped transfer length "\r\n"of %u is greater than %d\n",\r\ntransfer->len, MAX_DMA_LEN);\r\nmessage->status = -EINVAL;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\nif (printk_ratelimit())\r\ndev_warn(&message->spi->dev, "pump_transfers: "\r\n"DMA disabled for transfer length %ld "\r\n"greater than %d\n",\r\n(long)drv_data->len, MAX_DMA_LEN);\r\n}\r\nif (flush(drv_data) == 0) {\r\ndev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");\r\nmessage->status = -EIO;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\ndrv_data->n_bytes = chip->n_bytes;\r\ndrv_data->dma_width = chip->dma_width;\r\ndrv_data->tx = (void *)transfer->tx_buf;\r\ndrv_data->tx_end = drv_data->tx + transfer->len;\r\ndrv_data->rx = transfer->rx_buf;\r\ndrv_data->rx_end = drv_data->rx + transfer->len;\r\ndrv_data->rx_dma = transfer->rx_dma;\r\ndrv_data->tx_dma = transfer->tx_dma;\r\ndrv_data->len = transfer->len & DCMD_LENGTH;\r\ndrv_data->write = drv_data->tx ? chip->write : null_writer;\r\ndrv_data->read = drv_data->rx ? chip->read : null_reader;\r\ncr0 = chip->cr0;\r\nif (transfer->speed_hz || transfer->bits_per_word) {\r\nbits = chip->bits_per_word;\r\nspeed = chip->speed_hz;\r\nif (transfer->speed_hz)\r\nspeed = transfer->speed_hz;\r\nif (transfer->bits_per_word)\r\nbits = transfer->bits_per_word;\r\nclk_div = ssp_get_clk_div(ssp, speed);\r\nif (bits <= 8) {\r\ndrv_data->n_bytes = 1;\r\ndrv_data->dma_width = DCMD_WIDTH1;\r\ndrv_data->read = drv_data->read != null_reader ?\r\nu8_reader : null_reader;\r\ndrv_data->write = drv_data->write != null_writer ?\r\nu8_writer : null_writer;\r\n} else if (bits <= 16) {\r\ndrv_data->n_bytes = 2;\r\ndrv_data->dma_width = DCMD_WIDTH2;\r\ndrv_data->read = drv_data->read != null_reader ?\r\nu16_reader : null_reader;\r\ndrv_data->write = drv_data->write != null_writer ?\r\nu16_writer : null_writer;\r\n} else if (bits <= 32) {\r\ndrv_data->n_bytes = 4;\r\ndrv_data->dma_width = DCMD_WIDTH4;\r\ndrv_data->read = drv_data->read != null_reader ?\r\nu32_reader : null_reader;\r\ndrv_data->write = drv_data->write != null_writer ?\r\nu32_writer : null_writer;\r\n}\r\nif (chip->enable_dma) {\r\nif (set_dma_burst_and_threshold(chip, message->spi,\r\nbits, &dma_burst,\r\n&dma_thresh))\r\nif (printk_ratelimit())\r\ndev_warn(&message->spi->dev,\r\n"pump_transfers: "\r\n"DMA burst size reduced to "\r\n"match bits_per_word\n");\r\n}\r\ncr0 = clk_div\r\n| SSCR0_Motorola\r\n| SSCR0_DataSize(bits > 16 ? bits - 16 : bits)\r\n| SSCR0_SSE\r\n| (bits > 16 ? SSCR0_EDSS : 0);\r\n}\r\nmessage->state = RUNNING_STATE;\r\ndrv_data->dma_mapped = 0;\r\nif (drv_data->len > 0 && drv_data->len <= MAX_DMA_LEN)\r\ndrv_data->dma_mapped = map_dma_buffers(drv_data);\r\nif (drv_data->dma_mapped) {\r\ndrv_data->transfer_handler = dma_transfer;\r\nDCSR(drv_data->rx_channel) = RESET_DMA_CHANNEL;\r\nDSADR(drv_data->rx_channel) = drv_data->ssdr_physical;\r\nDTADR(drv_data->rx_channel) = drv_data->rx_dma;\r\nif (drv_data->rx == drv_data->null_dma_buf)\r\nDCMD(drv_data->rx_channel) = DCMD_FLOWSRC\r\n| drv_data->dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nelse\r\nDCMD(drv_data->rx_channel) = DCMD_INCTRGADDR\r\n| DCMD_FLOWSRC\r\n| drv_data->dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nDCSR(drv_data->tx_channel) = RESET_DMA_CHANNEL;\r\nDSADR(drv_data->tx_channel) = drv_data->tx_dma;\r\nDTADR(drv_data->tx_channel) = drv_data->ssdr_physical;\r\nif (drv_data->tx == drv_data->null_dma_buf)\r\nDCMD(drv_data->tx_channel) = DCMD_FLOWTRG\r\n| drv_data->dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nelse\r\nDCMD(drv_data->tx_channel) = DCMD_INCSRCADDR\r\n| DCMD_FLOWTRG\r\n| drv_data->dma_width\r\n| dma_burst\r\n| drv_data->len;\r\nif (drv_data->ssp_type == PXA25x_SSP)\r\nDCMD(drv_data->tx_channel) |= DCMD_ENDIRQEN;\r\ncr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;\r\nwrite_SSSR(drv_data->clear_sr, reg);\r\nDCSR(drv_data->rx_channel) |= DCSR_RUN;\r\nDCSR(drv_data->tx_channel) |= DCSR_RUN;\r\n} else {\r\ndrv_data->transfer_handler = interrupt_transfer;\r\ncr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\n}\r\nif ((read_SSCR0(reg) != cr0)\r\n|| (read_SSCR1(reg) & SSCR1_CHANGE_MASK) !=\r\n(cr1 & SSCR1_CHANGE_MASK)) {\r\nwrite_SSCR0(cr0 & ~SSCR0_SSE, reg);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(chip->timeout, reg);\r\nwrite_SSCR1(cr1 & SSCR1_CHANGE_MASK, reg);\r\nwrite_SSCR0(cr0, reg);\r\n} else {\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(chip->timeout, reg);\r\n}\r\ncs_assert(drv_data);\r\nwrite_SSCR1(cr1, reg);\r\n}\r\nstatic void pump_messages(struct work_struct *work)\r\n{\r\nstruct driver_data *drv_data =\r\ncontainer_of(work, struct driver_data, pump_messages);\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (list_empty(&drv_data->queue) || drv_data->run == QUEUE_STOPPED) {\r\ndrv_data->busy = 0;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn;\r\n}\r\nif (drv_data->cur_msg) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn;\r\n}\r\ndrv_data->cur_msg = list_entry(drv_data->queue.next,\r\nstruct spi_message, queue);\r\nlist_del_init(&drv_data->cur_msg->queue);\r\ndrv_data->cur_msg->state = START_STATE;\r\ndrv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,\r\nstruct spi_transfer,\r\ntransfer_list);\r\ndrv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\ndrv_data->busy = 1;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\n}\r\nstatic int transfer(struct spi_device *spi, struct spi_message *msg)\r\n{\r\nstruct driver_data *drv_data = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (drv_data->run == QUEUE_STOPPED) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nmsg->actual_length = 0;\r\nmsg->status = -EINPROGRESS;\r\nmsg->state = START_STATE;\r\nlist_add_tail(&msg->queue, &drv_data->queue);\r\nif (drv_data->run == QUEUE_RUNNING && !drv_data->busy)\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int setup_cs(struct spi_device *spi, struct chip_data *chip,\r\nstruct pxa2xx_spi_chip *chip_info)\r\n{\r\nint err = 0;\r\nif (chip == NULL || chip_info == NULL)\r\nreturn 0;\r\nif (gpio_is_valid(chip->gpio_cs))\r\ngpio_free(chip->gpio_cs);\r\nif (chip_info->cs_control) {\r\nchip->cs_control = chip_info->cs_control;\r\nreturn 0;\r\n}\r\nif (gpio_is_valid(chip_info->gpio_cs)) {\r\nerr = gpio_request(chip_info->gpio_cs, "SPI_CS");\r\nif (err) {\r\ndev_err(&spi->dev, "failed to request chip select "\r\n"GPIO%d\n", chip_info->gpio_cs);\r\nreturn err;\r\n}\r\nchip->gpio_cs = chip_info->gpio_cs;\r\nchip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;\r\nerr = gpio_direction_output(chip->gpio_cs,\r\n!chip->gpio_cs_inverted);\r\n}\r\nreturn err;\r\n}\r\nstatic int setup(struct spi_device *spi)\r\n{\r\nstruct pxa2xx_spi_chip *chip_info = NULL;\r\nstruct chip_data *chip;\r\nstruct driver_data *drv_data = spi_master_get_devdata(spi->master);\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nunsigned int clk_div;\r\nuint tx_thres = TX_THRESH_DFLT;\r\nuint rx_thres = RX_THRESH_DFLT;\r\nif (!pxa25x_ssp_comp(drv_data)\r\n&& (spi->bits_per_word < 4 || spi->bits_per_word > 32)) {\r\ndev_err(&spi->dev, "failed setup: ssp_type=%d, bits/wrd=%d "\r\n"b/w not 4-32 for type non-PXA25x_SSP\n",\r\ndrv_data->ssp_type, spi->bits_per_word);\r\nreturn -EINVAL;\r\n} else if (pxa25x_ssp_comp(drv_data)\r\n&& (spi->bits_per_word < 4\r\n|| spi->bits_per_word > 16)) {\r\ndev_err(&spi->dev, "failed setup: ssp_type=%d, bits/wrd=%d "\r\n"b/w not 4-16 for type PXA25x_SSP\n",\r\ndrv_data->ssp_type, spi->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nchip = spi_get_ctldata(spi);\r\nif (!chip) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip) {\r\ndev_err(&spi->dev,\r\n"failed setup: can't allocate chip data\n");\r\nreturn -ENOMEM;\r\n}\r\nif (drv_data->ssp_type == CE4100_SSP) {\r\nif (spi->chip_select > 4) {\r\ndev_err(&spi->dev, "failed setup: "\r\n"cs number must not be > 4.\n");\r\nkfree(chip);\r\nreturn -EINVAL;\r\n}\r\nchip->frm = spi->chip_select;\r\n} else\r\nchip->gpio_cs = -1;\r\nchip->enable_dma = 0;\r\nchip->timeout = TIMOUT_DFLT;\r\nchip->dma_burst_size = drv_data->master_info->enable_dma ?\r\nDCMD_BURST8 : 0;\r\n}\r\nchip_info = spi->controller_data;\r\nchip->cr1 = 0;\r\nif (chip_info) {\r\nif (chip_info->timeout)\r\nchip->timeout = chip_info->timeout;\r\nif (chip_info->tx_threshold)\r\ntx_thres = chip_info->tx_threshold;\r\nif (chip_info->rx_threshold)\r\nrx_thres = chip_info->rx_threshold;\r\nchip->enable_dma = drv_data->master_info->enable_dma;\r\nchip->dma_threshold = 0;\r\nif (chip_info->enable_loopback)\r\nchip->cr1 = SSCR1_LBM;\r\n}\r\nchip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |\r\n(SSCR1_TxTresh(tx_thres) & SSCR1_TFT);\r\nif (chip->enable_dma) {\r\nif (set_dma_burst_and_threshold(chip, spi, spi->bits_per_word,\r\n&chip->dma_burst_size,\r\n&chip->dma_threshold)) {\r\ndev_warn(&spi->dev, "in setup: DMA burst size reduced "\r\n"to match bits_per_word\n");\r\n}\r\n}\r\nclk_div = ssp_get_clk_div(ssp, spi->max_speed_hz);\r\nchip->speed_hz = spi->max_speed_hz;\r\nchip->cr0 = clk_div\r\n| SSCR0_Motorola\r\n| SSCR0_DataSize(spi->bits_per_word > 16 ?\r\nspi->bits_per_word - 16 : spi->bits_per_word)\r\n| SSCR0_SSE\r\n| (spi->bits_per_word > 16 ? SSCR0_EDSS : 0);\r\nchip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);\r\nchip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)\r\n| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);\r\nif (!pxa25x_ssp_comp(drv_data))\r\ndev_dbg(&spi->dev, "%ld Hz actual, %s\n",\r\nclk_get_rate(ssp->clk)\r\n/ (1 + ((chip->cr0 & SSCR0_SCR(0xfff)) >> 8)),\r\nchip->enable_dma ? "DMA" : "PIO");\r\nelse\r\ndev_dbg(&spi->dev, "%ld Hz actual, %s\n",\r\nclk_get_rate(ssp->clk) / 2\r\n/ (1 + ((chip->cr0 & SSCR0_SCR(0x0ff)) >> 8)),\r\nchip->enable_dma ? "DMA" : "PIO");\r\nif (spi->bits_per_word <= 8) {\r\nchip->n_bytes = 1;\r\nchip->dma_width = DCMD_WIDTH1;\r\nchip->read = u8_reader;\r\nchip->write = u8_writer;\r\n} else if (spi->bits_per_word <= 16) {\r\nchip->n_bytes = 2;\r\nchip->dma_width = DCMD_WIDTH2;\r\nchip->read = u16_reader;\r\nchip->write = u16_writer;\r\n} else if (spi->bits_per_word <= 32) {\r\nchip->cr0 |= SSCR0_EDSS;\r\nchip->n_bytes = 4;\r\nchip->dma_width = DCMD_WIDTH4;\r\nchip->read = u32_reader;\r\nchip->write = u32_writer;\r\n} else {\r\ndev_err(&spi->dev, "invalid wordsize\n");\r\nreturn -ENODEV;\r\n}\r\nchip->bits_per_word = spi->bits_per_word;\r\nspi_set_ctldata(spi, chip);\r\nif (drv_data->ssp_type == CE4100_SSP)\r\nreturn 0;\r\nreturn setup_cs(spi, chip, chip_info);\r\n}\r\nstatic void cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nstruct driver_data *drv_data = spi_master_get_devdata(spi->master);\r\nif (!chip)\r\nreturn;\r\nif (drv_data->ssp_type != CE4100_SSP && gpio_is_valid(chip->gpio_cs))\r\ngpio_free(chip->gpio_cs);\r\nkfree(chip);\r\n}\r\nstatic int __devinit init_queue(struct driver_data *drv_data)\r\n{\r\nINIT_LIST_HEAD(&drv_data->queue);\r\nspin_lock_init(&drv_data->lock);\r\ndrv_data->run = QUEUE_STOPPED;\r\ndrv_data->busy = 0;\r\ntasklet_init(&drv_data->pump_transfers,\r\npump_transfers, (unsigned long)drv_data);\r\nINIT_WORK(&drv_data->pump_messages, pump_messages);\r\ndrv_data->workqueue = create_singlethread_workqueue(\r\ndev_name(drv_data->master->dev.parent));\r\nif (drv_data->workqueue == NULL)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int start_queue(struct driver_data *drv_data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (drv_data->run == QUEUE_RUNNING || drv_data->busy) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndrv_data->run = QUEUE_RUNNING;\r\ndrv_data->cur_msg = NULL;\r\ndrv_data->cur_transfer = NULL;\r\ndrv_data->cur_chip = NULL;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nreturn 0;\r\n}\r\nstatic int stop_queue(struct driver_data *drv_data)\r\n{\r\nunsigned long flags;\r\nunsigned limit = 500;\r\nint status = 0;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\ndrv_data->run = QUEUE_STOPPED;\r\nwhile ((!list_empty(&drv_data->queue) || drv_data->busy) && limit--) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\n}\r\nif (!list_empty(&drv_data->queue) || drv_data->busy)\r\nstatus = -EBUSY;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn status;\r\n}\r\nstatic int destroy_queue(struct driver_data *drv_data)\r\n{\r\nint status;\r\nstatus = stop_queue(drv_data);\r\nif (status != 0)\r\nreturn status;\r\ndestroy_workqueue(drv_data->workqueue);\r\nreturn 0;\r\n}\r\nstatic int __devinit pxa2xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pxa2xx_spi_master *platform_info;\r\nstruct spi_master *master;\r\nstruct driver_data *drv_data;\r\nstruct ssp_device *ssp;\r\nint status;\r\nplatform_info = dev->platform_data;\r\nssp = pxa_ssp_request(pdev->id, pdev->name);\r\nif (ssp == NULL) {\r\ndev_err(&pdev->dev, "failed to request SSP%d\n", pdev->id);\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(struct driver_data) + 16);\r\nif (!master) {\r\ndev_err(&pdev->dev, "cannot alloc spi_master\n");\r\npxa_ssp_free(ssp);\r\nreturn -ENOMEM;\r\n}\r\ndrv_data = spi_master_get_devdata(master);\r\ndrv_data->master = master;\r\ndrv_data->master_info = platform_info;\r\ndrv_data->pdev = pdev;\r\ndrv_data->ssp = ssp;\r\nmaster->dev.parent = &pdev->dev;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = platform_info->num_chipselect;\r\nmaster->dma_alignment = DMA_ALIGNMENT;\r\nmaster->cleanup = cleanup;\r\nmaster->setup = setup;\r\nmaster->transfer = transfer;\r\ndrv_data->ssp_type = ssp->type;\r\ndrv_data->null_dma_buf = (u32 *)ALIGN((u32)(drv_data +\r\nsizeof(struct driver_data)), 8);\r\ndrv_data->ioaddr = ssp->mmio_base;\r\ndrv_data->ssdr_physical = ssp->phys_base + SSDR;\r\nif (pxa25x_ssp_comp(drv_data)) {\r\ndrv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE;\r\ndrv_data->dma_cr1 = 0;\r\ndrv_data->clear_sr = SSSR_ROR;\r\ndrv_data->mask_sr = SSSR_RFS | SSSR_TFS | SSSR_ROR;\r\n} else {\r\ndrv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE | SSCR1_TINTE;\r\ndrv_data->dma_cr1 = SSCR1_TSRE | SSCR1_RSRE | SSCR1_TINTE;\r\ndrv_data->clear_sr = SSSR_ROR | SSSR_TINT;\r\ndrv_data->mask_sr = SSSR_TINT | SSSR_RFS | SSSR_TFS | SSSR_ROR;\r\n}\r\nstatus = request_irq(ssp->irq, ssp_int, IRQF_SHARED, dev_name(dev),\r\ndrv_data);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "cannot get IRQ %d\n", ssp->irq);\r\ngoto out_error_master_alloc;\r\n}\r\ndrv_data->tx_channel = -1;\r\ndrv_data->rx_channel = -1;\r\nif (platform_info->enable_dma) {\r\ndrv_data->rx_channel = pxa_request_dma("pxa2xx_spi_ssp_rx",\r\nDMA_PRIO_HIGH,\r\ndma_handler,\r\ndrv_data);\r\nif (drv_data->rx_channel < 0) {\r\ndev_err(dev, "problem (%d) requesting rx channel\n",\r\ndrv_data->rx_channel);\r\nstatus = -ENODEV;\r\ngoto out_error_irq_alloc;\r\n}\r\ndrv_data->tx_channel = pxa_request_dma("pxa2xx_spi_ssp_tx",\r\nDMA_PRIO_MEDIUM,\r\ndma_handler,\r\ndrv_data);\r\nif (drv_data->tx_channel < 0) {\r\ndev_err(dev, "problem (%d) requesting tx channel\n",\r\ndrv_data->tx_channel);\r\nstatus = -ENODEV;\r\ngoto out_error_dma_alloc;\r\n}\r\nDRCMR(ssp->drcmr_rx) = DRCMR_MAPVLD | drv_data->rx_channel;\r\nDRCMR(ssp->drcmr_tx) = DRCMR_MAPVLD | drv_data->tx_channel;\r\n}\r\nclk_enable(ssp->clk);\r\nwrite_SSCR0(0, drv_data->ioaddr);\r\nwrite_SSCR1(SSCR1_RxTresh(RX_THRESH_DFLT) |\r\nSSCR1_TxTresh(TX_THRESH_DFLT),\r\ndrv_data->ioaddr);\r\nwrite_SSCR0(SSCR0_SCR(2)\r\n| SSCR0_Motorola\r\n| SSCR0_DataSize(8),\r\ndrv_data->ioaddr);\r\nif (!pxa25x_ssp_comp(drv_data))\r\nwrite_SSTO(0, drv_data->ioaddr);\r\nwrite_SSPSP(0, drv_data->ioaddr);\r\nstatus = init_queue(drv_data);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "problem initializing queue\n");\r\ngoto out_error_clock_enabled;\r\n}\r\nstatus = start_queue(drv_data);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "problem starting queue\n");\r\ngoto out_error_clock_enabled;\r\n}\r\nplatform_set_drvdata(pdev, drv_data);\r\nstatus = spi_register_master(master);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "problem registering spi master\n");\r\ngoto out_error_queue_alloc;\r\n}\r\nreturn status;\r\nout_error_queue_alloc:\r\ndestroy_queue(drv_data);\r\nout_error_clock_enabled:\r\nclk_disable(ssp->clk);\r\nout_error_dma_alloc:\r\nif (drv_data->tx_channel != -1)\r\npxa_free_dma(drv_data->tx_channel);\r\nif (drv_data->rx_channel != -1)\r\npxa_free_dma(drv_data->rx_channel);\r\nout_error_irq_alloc:\r\nfree_irq(ssp->irq, drv_data);\r\nout_error_master_alloc:\r\nspi_master_put(master);\r\npxa_ssp_free(ssp);\r\nreturn status;\r\n}\r\nstatic int pxa2xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct driver_data *drv_data = platform_get_drvdata(pdev);\r\nstruct ssp_device *ssp;\r\nint status = 0;\r\nif (!drv_data)\r\nreturn 0;\r\nssp = drv_data->ssp;\r\nstatus = destroy_queue(drv_data);\r\nif (status != 0)\r\ndev_err(&pdev->dev, "pxa2xx_spi_remove: workqueue will not "\r\n"complete, message memory not freed\n");\r\nwrite_SSCR0(0, drv_data->ioaddr);\r\nclk_disable(ssp->clk);\r\nif (drv_data->master_info->enable_dma) {\r\nDRCMR(ssp->drcmr_rx) = 0;\r\nDRCMR(ssp->drcmr_tx) = 0;\r\npxa_free_dma(drv_data->tx_channel);\r\npxa_free_dma(drv_data->rx_channel);\r\n}\r\nfree_irq(ssp->irq, drv_data);\r\npxa_ssp_free(ssp);\r\nspi_unregister_master(drv_data->master);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic void pxa2xx_spi_shutdown(struct platform_device *pdev)\r\n{\r\nint status = 0;\r\nif ((status = pxa2xx_spi_remove(pdev)) != 0)\r\ndev_err(&pdev->dev, "shutdown failed with %d\n", status);\r\n}\r\nstatic int pxa2xx_spi_suspend(struct device *dev)\r\n{\r\nstruct driver_data *drv_data = dev_get_drvdata(dev);\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nint status = 0;\r\nstatus = stop_queue(drv_data);\r\nif (status != 0)\r\nreturn status;\r\nwrite_SSCR0(0, drv_data->ioaddr);\r\nclk_disable(ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa2xx_spi_resume(struct device *dev)\r\n{\r\nstruct driver_data *drv_data = dev_get_drvdata(dev);\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nint status = 0;\r\nif (drv_data->rx_channel != -1)\r\nDRCMR(drv_data->ssp->drcmr_rx) =\r\nDRCMR_MAPVLD | drv_data->rx_channel;\r\nif (drv_data->tx_channel != -1)\r\nDRCMR(drv_data->ssp->drcmr_tx) =\r\nDRCMR_MAPVLD | drv_data->tx_channel;\r\nclk_enable(ssp->clk);\r\nstatus = start_queue(drv_data);\r\nif (status != 0) {\r\ndev_err(dev, "problem starting queue (%d)\n", status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pxa2xx_spi_init(void)\r\n{\r\nreturn platform_driver_register(&driver);\r\n}\r\nstatic void __exit pxa2xx_spi_exit(void)\r\n{\r\nplatform_driver_unregister(&driver);\r\n}
