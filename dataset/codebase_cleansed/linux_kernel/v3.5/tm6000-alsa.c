static int _tm6000_start_audio_dma(struct snd_tm6000_card *chip)\r\n{\r\nstruct tm6000_core *core = chip->core;\r\ndprintk(1, "Starting audio DMA\n");\r\ntm6000_set_reg_mask(core, TM6010_REQ07_RCC_ACTIVE_IF, 0x40, 0x40);\r\ntm6000_set_audio_bitrate(core, 48000);\r\nreturn 0;\r\n}\r\nstatic int _tm6000_stop_audio_dma(struct snd_tm6000_card *chip)\r\n{\r\nstruct tm6000_core *core = chip->core;\r\ndprintk(1, "Stopping audio DMA\n");\r\ntm6000_set_reg_mask(core, TM6010_REQ07_RCC_ACTIVE_IF, 0x00, 0x40);\r\nreturn 0;\r\n}\r\nstatic void dsp_buffer_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\ndprintk(2, "Freeing buffer\n");\r\nvfree(substream->runtime->dma_area);\r\nsubstream->runtime->dma_area = NULL;\r\nsubstream->runtime->dma_bytes = 0;\r\n}\r\nstatic int dsp_buffer_alloc(struct snd_pcm_substream *substream, int size)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\ndprintk(2, "Allocating buffer\n");\r\nif (substream->runtime->dma_area) {\r\nif (substream->runtime->dma_bytes > size)\r\nreturn 0;\r\ndsp_buffer_free(substream);\r\n}\r\nsubstream->runtime->dma_area = vmalloc(size);\r\nif (!substream->runtime->dma_area)\r\nreturn -ENOMEM;\r\nsubstream->runtime->dma_bytes = size;\r\nreturn 0;\r\n}\r\nstatic int snd_tm6000_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_pcm_hw_constraint_pow2(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\ngoto _error;\r\nchip->substream = substream;\r\nruntime->hw = snd_tm6000_digital_hw;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nreturn 0;\r\n_error:\r\ndprintk(1, "Error opening PCM!\n");\r\nreturn err;\r\n}\r\nstatic int snd_tm6000_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\nstruct tm6000_core *core = chip->core;\r\nif (atomic_read(&core->stream_started) > 0) {\r\natomic_set(&core->stream_started, 0);\r\nschedule_work(&core->wq_trigger);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tm6000_fillbuf(struct tm6000_core *core, char *buf, int size)\r\n{\r\nstruct snd_tm6000_card *chip = core->adev;\r\nstruct snd_pcm_substream *substream = chip->substream;\r\nstruct snd_pcm_runtime *runtime;\r\nint period_elapsed = 0;\r\nunsigned int stride, buf_pos;\r\nint length;\r\nif (atomic_read(&core->stream_started) == 0)\r\nreturn 0;\r\nif (!size || !substream) {\r\ndprintk(1, "substream was NULL\n");\r\nreturn -EINVAL;\r\n}\r\nruntime = substream->runtime;\r\nif (!runtime || !runtime->dma_area) {\r\ndprintk(1, "runtime was NULL\n");\r\nreturn -EINVAL;\r\n}\r\nbuf_pos = chip->buf_pos;\r\nstride = runtime->frame_bits >> 3;\r\nif (stride == 0) {\r\ndprintk(1, "stride is zero\n");\r\nreturn -EINVAL;\r\n}\r\nlength = size / stride;\r\nif (length == 0) {\r\ndprintk(1, "%s: length was zero\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndprintk(1, "Copying %d bytes at %p[%d] - buf size=%d x %d\n", size,\r\nruntime->dma_area, buf_pos,\r\n(unsigned int)runtime->buffer_size, stride);\r\nif (buf_pos + length >= runtime->buffer_size) {\r\nunsigned int cnt = runtime->buffer_size - buf_pos;\r\nmemcpy(runtime->dma_area + buf_pos * stride, buf, cnt * stride);\r\nmemcpy(runtime->dma_area, buf + cnt * stride,\r\nlength * stride - cnt * stride);\r\n} else\r\nmemcpy(runtime->dma_area + buf_pos * stride, buf,\r\nlength * stride);\r\nsnd_pcm_stream_lock(substream);\r\nchip->buf_pos += length;\r\nif (chip->buf_pos >= runtime->buffer_size)\r\nchip->buf_pos -= runtime->buffer_size;\r\nchip->period_pos += length;\r\nif (chip->period_pos >= runtime->period_size) {\r\nchip->period_pos -= runtime->period_size;\r\nperiod_elapsed = 1;\r\n}\r\nsnd_pcm_stream_unlock(substream);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_tm6000_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint size, rc;\r\nsize = params_period_bytes(hw_params) * params_periods(hw_params);\r\nrc = dsp_buffer_alloc(substream, size);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int snd_tm6000_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\nstruct tm6000_core *core = chip->core;\r\nif (atomic_read(&core->stream_started) > 0) {\r\natomic_set(&core->stream_started, 0);\r\nschedule_work(&core->wq_trigger);\r\n}\r\ndsp_buffer_free(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_tm6000_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\nchip->buf_pos = 0;\r\nchip->period_pos = 0;\r\nreturn 0;\r\n}\r\nstatic void audio_trigger(struct work_struct *work)\r\n{\r\nstruct tm6000_core *core = container_of(work, struct tm6000_core,\r\nwq_trigger);\r\nstruct snd_tm6000_card *chip = core->adev;\r\nif (atomic_read(&core->stream_started)) {\r\ndprintk(1, "starting capture");\r\n_tm6000_start_audio_dma(chip);\r\n} else {\r\ndprintk(1, "stopping capture");\r\n_tm6000_stop_audio_dma(chip);\r\n}\r\n}\r\nstatic int snd_tm6000_card_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\nstruct tm6000_core *core = chip->core;\r\nint err = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\natomic_set(&core->stream_started, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\natomic_set(&core->stream_started, 0);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nschedule_work(&core->wq_trigger);\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t snd_tm6000_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_tm6000_card *chip = snd_pcm_substream_chip(substream);\r\nreturn chip->buf_pos;\r\n}\r\nstatic struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs,\r\nunsigned long offset)\r\n{\r\nvoid *pageptr = subs->runtime->dma_area + offset;\r\nreturn vmalloc_to_page(pageptr);\r\n}\r\nstatic int tm6000_audio_init(struct tm6000_core *dev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_tm6000_card *chip;\r\nint rc;\r\nstatic int devnr;\r\nchar component[14];\r\nstruct snd_pcm *pcm;\r\nif (!dev)\r\nreturn 0;\r\nif (devnr >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[devnr])\r\nreturn -ENOENT;\r\nrc = snd_card_create(index[devnr], "tm6000", THIS_MODULE, 0, &card);\r\nif (rc < 0) {\r\nsnd_printk(KERN_ERR "cannot create card instance %d\n", devnr);\r\nreturn rc;\r\n}\r\nstrcpy(card->driver, "tm6000-alsa");\r\nstrcpy(card->shortname, "TM5600/60x0");\r\nsprintf(card->longname, "TM5600/60x0 Audio at bus %d device %d",\r\ndev->udev->bus->busnum, dev->udev->devnum);\r\nsprintf(component, "USB%04x:%04x",\r\nle16_to_cpu(dev->udev->descriptor.idVendor),\r\nle16_to_cpu(dev->udev->descriptor.idProduct));\r\nsnd_component_add(card, component);\r\nsnd_card_set_dev(card, &dev->udev->dev);\r\nchip = kzalloc(sizeof(struct snd_tm6000_card), GFP_KERNEL);\r\nif (!chip) {\r\nrc = -ENOMEM;\r\ngoto error;\r\n}\r\nchip->core = dev;\r\nchip->card = card;\r\ndev->adev = chip;\r\nspin_lock_init(&chip->reg_lock);\r\nrc = snd_pcm_new(card, "TM6000 Audio", 0, 0, 1, &pcm);\r\nif (rc < 0)\r\ngoto error_chip;\r\npcm->info_flags = 0;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "Trident TM5600/60x0");\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_tm6000_pcm_ops);\r\nINIT_WORK(&dev->wq_trigger, audio_trigger);\r\nrc = snd_card_register(card);\r\nif (rc < 0)\r\ngoto error_chip;\r\ndprintk(1, "Registered audio driver for %s\n", card->longname);\r\nreturn 0;\r\nerror_chip:\r\nkfree(chip);\r\ndev->adev = NULL;\r\nerror:\r\nsnd_card_free(card);\r\nreturn rc;\r\n}\r\nstatic int tm6000_audio_fini(struct tm6000_core *dev)\r\n{\r\nstruct snd_tm6000_card *chip = dev->adev;\r\nif (!dev)\r\nreturn 0;\r\nif (!chip)\r\nreturn 0;\r\nif (!chip->card)\r\nreturn 0;\r\nsnd_card_free(chip->card);\r\nchip->card = NULL;\r\nkfree(chip);\r\ndev->adev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init tm6000_alsa_register(void)\r\n{\r\nreturn tm6000_register_extension(&audio_ops);\r\n}\r\nstatic void __exit tm6000_alsa_unregister(void)\r\n{\r\ntm6000_unregister_extension(&audio_ops);\r\n}
