static int is_amd(void)\r\n{\r\nreturn cpu_vendor[0] == A32('A', 'u', 't', 'h') &&\r\ncpu_vendor[1] == A32('e', 'n', 't', 'i') &&\r\ncpu_vendor[2] == A32('c', 'A', 'M', 'D');\r\n}\r\nstatic int is_centaur(void)\r\n{\r\nreturn cpu_vendor[0] == A32('C', 'e', 'n', 't') &&\r\ncpu_vendor[1] == A32('a', 'u', 'r', 'H') &&\r\ncpu_vendor[2] == A32('a', 'u', 'l', 's');\r\n}\r\nstatic int is_transmeta(void)\r\n{\r\nreturn cpu_vendor[0] == A32('G', 'e', 'n', 'u') &&\r\ncpu_vendor[1] == A32('i', 'n', 'e', 'T') &&\r\ncpu_vendor[2] == A32('M', 'x', '8', '6');\r\n}\r\nstatic int has_fpu(void)\r\n{\r\nu16 fcw = -1, fsw = -1;\r\nu32 cr0;\r\nasm("movl %%cr0,%0" : "=r" (cr0));\r\nif (cr0 & (X86_CR0_EM|X86_CR0_TS)) {\r\ncr0 &= ~(X86_CR0_EM|X86_CR0_TS);\r\nasm volatile("movl %0,%%cr0" : : "r" (cr0));\r\n}\r\nasm volatile("fninit ; fnstsw %0 ; fnstcw %1"\r\n: "+m" (fsw), "+m" (fcw));\r\nreturn fsw == 0 && (fcw & 0x103f) == 0x003f;\r\n}\r\nstatic int has_eflag(u32 mask)\r\n{\r\nu32 f0, f1;\r\nasm("pushfl ; "\r\n"pushfl ; "\r\n"popl %0 ; "\r\n"movl %0,%1 ; "\r\n"xorl %2,%1 ; "\r\n"pushl %1 ; "\r\n"popfl ; "\r\n"pushfl ; "\r\n"popl %1 ; "\r\n"popfl"\r\n: "=&r" (f0), "=&r" (f1)\r\n: "ri" (mask));\r\nreturn !!((f0^f1) & mask);\r\n}\r\nstatic void get_flags(void)\r\n{\r\nu32 max_intel_level, max_amd_level;\r\nu32 tfms;\r\nif (has_fpu())\r\nset_bit(X86_FEATURE_FPU, cpu.flags);\r\nif (has_eflag(X86_EFLAGS_ID)) {\r\nasm("cpuid"\r\n: "=a" (max_intel_level),\r\n"=b" (cpu_vendor[0]),\r\n"=d" (cpu_vendor[1]),\r\n"=c" (cpu_vendor[2])\r\n: "a" (0));\r\nif (max_intel_level >= 0x00000001 &&\r\nmax_intel_level <= 0x0000ffff) {\r\nasm("cpuid"\r\n: "=a" (tfms),\r\n"=c" (cpu.flags[4]),\r\n"=d" (cpu.flags[0])\r\n: "a" (0x00000001)\r\n: "ebx");\r\ncpu.level = (tfms >> 8) & 15;\r\ncpu.model = (tfms >> 4) & 15;\r\nif (cpu.level >= 6)\r\ncpu.model += ((tfms >> 16) & 0xf) << 4;\r\n}\r\nasm("cpuid"\r\n: "=a" (max_amd_level)\r\n: "a" (0x80000000)\r\n: "ebx", "ecx", "edx");\r\nif (max_amd_level >= 0x80000001 &&\r\nmax_amd_level <= 0x8000ffff) {\r\nu32 eax = 0x80000001;\r\nasm("cpuid"\r\n: "+a" (eax),\r\n"=c" (cpu.flags[6]),\r\n"=d" (cpu.flags[1])\r\n: : "ebx");\r\n}\r\n}\r\n}\r\nstatic int check_flags(void)\r\n{\r\nu32 err;\r\nint i;\r\nerr = 0;\r\nfor (i = 0; i < NCAPINTS; i++) {\r\nerr_flags[i] = req_flags[i] & ~cpu.flags[i];\r\nif (err_flags[i])\r\nerr |= 1 << i;\r\n}\r\nreturn err;\r\n}\r\nint check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr)\r\n{\r\nint err;\r\nmemset(&cpu.flags, 0, sizeof cpu.flags);\r\ncpu.level = 3;\r\nif (has_eflag(X86_EFLAGS_AC))\r\ncpu.level = 4;\r\nget_flags();\r\nerr = check_flags();\r\nif (test_bit(X86_FEATURE_LM, cpu.flags))\r\ncpu.level = 64;\r\nif (err == 0x01 &&\r\n!(err_flags[0] &\r\n~((1 << X86_FEATURE_XMM)|(1 << X86_FEATURE_XMM2))) &&\r\nis_amd()) {\r\nu32 ecx = MSR_K7_HWCR;\r\nu32 eax, edx;\r\nasm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));\r\neax &= ~(1 << 15);\r\nasm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));\r\nget_flags();\r\nerr = check_flags();\r\n} else if (err == 0x01 &&\r\n!(err_flags[0] & ~(1 << X86_FEATURE_CX8)) &&\r\nis_centaur() && cpu.model >= 6) {\r\nu32 ecx = MSR_VIA_FCR;\r\nu32 eax, edx;\r\nasm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));\r\neax |= (1<<1)|(1<<7);\r\nasm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));\r\nset_bit(X86_FEATURE_CX8, cpu.flags);\r\nerr = check_flags();\r\n} else if (err == 0x01 && is_transmeta()) {\r\nu32 ecx = 0x80860004;\r\nu32 eax, edx;\r\nu32 level = 1;\r\nasm("rdmsr" : "=a" (eax), "=d" (edx) : "c" (ecx));\r\nasm("wrmsr" : : "a" (~0), "d" (edx), "c" (ecx));\r\nasm("cpuid"\r\n: "+a" (level), "=d" (cpu.flags[0])\r\n: : "ecx", "ebx");\r\nasm("wrmsr" : : "a" (eax), "d" (edx), "c" (ecx));\r\nerr = check_flags();\r\n}\r\nif (err_flags_ptr)\r\n*err_flags_ptr = err ? err_flags : NULL;\r\nif (cpu_level_ptr)\r\n*cpu_level_ptr = cpu.level;\r\nif (req_level_ptr)\r\n*req_level_ptr = req_level;\r\nreturn (cpu.level < req_level || err) ? -1 : 0;\r\n}
