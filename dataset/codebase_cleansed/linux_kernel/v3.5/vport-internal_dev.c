static struct internal_dev *internal_dev_priv(struct net_device *netdev)\r\n{\r\nreturn netdev_priv(netdev);\r\n}\r\nstatic struct rtnl_link_stats64 *internal_dev_get_stats(struct net_device *netdev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct vport *vport = ovs_internal_dev_get_vport(netdev);\r\nstruct ovs_vport_stats vport_stats;\r\novs_vport_get_stats(vport, &vport_stats);\r\nstats->rx_packets = vport_stats.tx_packets;\r\nstats->tx_packets = vport_stats.rx_packets;\r\nstats->rx_bytes = vport_stats.tx_bytes;\r\nstats->tx_bytes = vport_stats.rx_bytes;\r\nstats->rx_errors = vport_stats.tx_errors;\r\nstats->tx_errors = vport_stats.rx_errors;\r\nstats->rx_dropped = vport_stats.tx_dropped;\r\nstats->tx_dropped = vport_stats.rx_dropped;\r\nreturn stats;\r\n}\r\nstatic int internal_dev_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\ndev->addr_assign_type &= ~NET_ADDR_RANDOM;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int internal_dev_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nrcu_read_lock();\r\novs_vport_receive(internal_dev_priv(netdev)->vport, skb);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int internal_dev_open(struct net_device *netdev)\r\n{\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic int internal_dev_stop(struct net_device *netdev)\r\n{\r\nnetif_stop_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic void internal_dev_getinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, "openvswitch");\r\n}\r\nstatic int internal_dev_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nif (new_mtu < 68)\r\nreturn -EINVAL;\r\nnetdev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void internal_dev_destructor(struct net_device *dev)\r\n{\r\nstruct vport *vport = ovs_internal_dev_get_vport(dev);\r\novs_vport_free(vport);\r\nfree_netdev(dev);\r\n}\r\nstatic void do_setup(struct net_device *netdev)\r\n{\r\nether_setup(netdev);\r\nnetdev->netdev_ops = &internal_dev_netdev_ops;\r\nnetdev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\nnetdev->destructor = internal_dev_destructor;\r\nSET_ETHTOOL_OPS(netdev, &internal_dev_ethtool_ops);\r\nnetdev->tx_queue_len = 0;\r\nnetdev->features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |\r\nNETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_TSO;\r\nnetdev->vlan_features = netdev->features;\r\nnetdev->features |= NETIF_F_HW_VLAN_TX;\r\nnetdev->hw_features = netdev->features & ~NETIF_F_LLTX;\r\neth_hw_addr_random(netdev);\r\n}\r\nstatic struct vport *internal_dev_create(const struct vport_parms *parms)\r\n{\r\nstruct vport *vport;\r\nstruct netdev_vport *netdev_vport;\r\nstruct internal_dev *internal_dev;\r\nint err;\r\nvport = ovs_vport_alloc(sizeof(struct netdev_vport),\r\n&ovs_internal_vport_ops, parms);\r\nif (IS_ERR(vport)) {\r\nerr = PTR_ERR(vport);\r\ngoto error;\r\n}\r\nnetdev_vport = netdev_vport_priv(vport);\r\nnetdev_vport->dev = alloc_netdev(sizeof(struct internal_dev),\r\nparms->name, do_setup);\r\nif (!netdev_vport->dev) {\r\nerr = -ENOMEM;\r\ngoto error_free_vport;\r\n}\r\ninternal_dev = internal_dev_priv(netdev_vport->dev);\r\ninternal_dev->vport = vport;\r\nerr = register_netdevice(netdev_vport->dev);\r\nif (err)\r\ngoto error_free_netdev;\r\ndev_set_promiscuity(netdev_vport->dev, 1);\r\nnetif_start_queue(netdev_vport->dev);\r\nreturn vport;\r\nerror_free_netdev:\r\nfree_netdev(netdev_vport->dev);\r\nerror_free_vport:\r\novs_vport_free(vport);\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void internal_dev_destroy(struct vport *vport)\r\n{\r\nstruct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nnetif_stop_queue(netdev_vport->dev);\r\ndev_set_promiscuity(netdev_vport->dev, -1);\r\nunregister_netdevice(netdev_vport->dev);\r\n}\r\nstatic int internal_dev_recv(struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct net_device *netdev = netdev_vport_priv(vport)->dev;\r\nint len;\r\nlen = skb->len;\r\nskb->dev = netdev;\r\nskb->pkt_type = PACKET_HOST;\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nnetif_rx(skb);\r\nreturn len;\r\n}\r\nint ovs_is_internal_dev(const struct net_device *netdev)\r\n{\r\nreturn netdev->netdev_ops == &internal_dev_netdev_ops;\r\n}\r\nstruct vport *ovs_internal_dev_get_vport(struct net_device *netdev)\r\n{\r\nif (!ovs_is_internal_dev(netdev))\r\nreturn NULL;\r\nreturn internal_dev_priv(netdev)->vport;\r\n}
