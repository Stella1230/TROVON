static u8 sja1000_ofp_read_reg(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn in_8(priv->reg_base + reg);\r\n}\r\nstatic void sja1000_ofp_write_reg(const struct sja1000_priv *priv,\r\nint reg, u8 val)\r\n{\r\nout_8(priv->reg_base + reg, val);\r\n}\r\nstatic int __devexit sja1000_ofp_remove(struct platform_device *ofdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(&ofdev->dev);\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct resource res;\r\ndev_set_drvdata(&ofdev->dev, NULL);\r\nunregister_sja1000dev(dev);\r\nfree_sja1000dev(dev);\r\niounmap(priv->reg_base);\r\nirq_dispose_mapping(dev->irq);\r\nof_address_to_resource(np, 0, &res);\r\nrelease_mem_region(res.start, resource_size(&res));\r\nreturn 0;\r\n}\r\nstatic int __devinit sja1000_ofp_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\nstruct resource res;\r\nconst u32 *prop;\r\nint err, irq, res_size, prop_size;\r\nvoid __iomem *base;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err) {\r\ndev_err(&ofdev->dev, "invalid address\n");\r\nreturn err;\r\n}\r\nres_size = resource_size(&res);\r\nif (!request_mem_region(res.start, res_size, DRV_NAME)) {\r\ndev_err(&ofdev->dev, "couldn't request %pR\n", &res);\r\nreturn -EBUSY;\r\n}\r\nbase = ioremap_nocache(res.start, res_size);\r\nif (!base) {\r\ndev_err(&ofdev->dev, "couldn't ioremap %pR\n", &res);\r\nerr = -ENOMEM;\r\ngoto exit_release_mem;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq == NO_IRQ) {\r\ndev_err(&ofdev->dev, "no irq found\n");\r\nerr = -ENODEV;\r\ngoto exit_unmap_mem;\r\n}\r\ndev = alloc_sja1000dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_dispose_irq;\r\n}\r\npriv = netdev_priv(dev);\r\npriv->read_reg = sja1000_ofp_read_reg;\r\npriv->write_reg = sja1000_ofp_write_reg;\r\nprop = of_get_property(np, "nxp,external-clock-frequency", &prop_size);\r\nif (prop && (prop_size == sizeof(u32)))\r\npriv->can.clock.freq = *prop / 2;\r\nelse\r\npriv->can.clock.freq = SJA1000_OFP_CAN_CLOCK;\r\nprop = of_get_property(np, "nxp,tx-output-mode", &prop_size);\r\nif (prop && (prop_size == sizeof(u32)))\r\npriv->ocr |= *prop & OCR_MODE_MASK;\r\nelse\r\npriv->ocr |= OCR_MODE_NORMAL;\r\nprop = of_get_property(np, "nxp,tx-output-config", &prop_size);\r\nif (prop && (prop_size == sizeof(u32)))\r\npriv->ocr |= (*prop << OCR_TX_SHIFT) & OCR_TX_MASK;\r\nelse\r\npriv->ocr |= OCR_TX0_PULLDOWN;\r\nprop = of_get_property(np, "nxp,clock-out-frequency", &prop_size);\r\nif (prop && (prop_size == sizeof(u32)) && *prop) {\r\nu32 divider = priv->can.clock.freq * 2 / *prop;\r\nif (divider > 1)\r\npriv->cdr |= divider / 2 - 1;\r\nelse\r\npriv->cdr |= CDR_CLKOUT_MASK;\r\n} else {\r\npriv->cdr |= CDR_CLK_OFF;\r\n}\r\nprop = of_get_property(np, "nxp,no-comparator-bypass", NULL);\r\nif (!prop)\r\npriv->cdr |= CDR_CBP;\r\npriv->irq_flags = IRQF_SHARED;\r\npriv->reg_base = base;\r\ndev->irq = irq;\r\ndev_info(&ofdev->dev,\r\n"reg_base=0x%p irq=%d clock=%d ocr=0x%02x cdr=0x%02x\n",\r\npriv->reg_base, dev->irq, priv->can.clock.freq,\r\npriv->ocr, priv->cdr);\r\ndev_set_drvdata(&ofdev->dev, dev);\r\nSET_NETDEV_DEV(dev, &ofdev->dev);\r\nerr = register_sja1000dev(dev);\r\nif (err) {\r\ndev_err(&ofdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free_sja1000;\r\n}\r\nreturn 0;\r\nexit_free_sja1000:\r\nfree_sja1000dev(dev);\r\nexit_dispose_irq:\r\nirq_dispose_mapping(irq);\r\nexit_unmap_mem:\r\niounmap(base);\r\nexit_release_mem:\r\nrelease_mem_region(res.start, res_size);\r\nreturn err;\r\n}
