static void __devinit at91_twi_hwinit(void)\r\n{\r\nunsigned long cdiv, ckdiv;\r\nat91_twi_write(AT91_TWI_IDR, 0xffffffff);\r\nat91_twi_write(AT91_TWI_CR, AT91_TWI_SWRST);\r\nat91_twi_write(AT91_TWI_CR, AT91_TWI_MSEN);\r\ncdiv = (clk_get_rate(twi_clk) / (2 * TWI_CLOCK)) - 3;\r\ncdiv = cdiv + 1;\r\nckdiv = 0;\r\nwhile (cdiv > 255) {\r\nckdiv++;\r\ncdiv = cdiv >> 1;\r\n}\r\nif (cpu_is_at91rm9200()) {\r\nif (ckdiv > 5) {\r\nprintk(KERN_ERR "AT91 I2C: Invalid TWI_CLOCK value!\n");\r\nckdiv = 5;\r\n}\r\n}\r\nat91_twi_write(AT91_TWI_CWGR, (ckdiv << 16) | (cdiv << 8) | cdiv);\r\n}\r\nstatic short at91_poll_status(unsigned long bit)\r\n{\r\nint loop_cntr = 10000;\r\ndo {\r\nudelay(10);\r\n} while (!(at91_twi_read(AT91_TWI_SR) & bit) && (--loop_cntr > 0));\r\nreturn (loop_cntr > 0);\r\n}\r\nstatic int xfer_read(struct i2c_adapter *adap, unsigned char *buf, int length)\r\n{\r\nat91_twi_write(AT91_TWI_CR, AT91_TWI_START);\r\nwhile (length--) {\r\nif (!length)\r\nat91_twi_write(AT91_TWI_CR, AT91_TWI_STOP);\r\nif (!at91_poll_status(AT91_TWI_RXRDY)) {\r\ndev_dbg(&adap->dev, "RXRDY timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n*buf++ = (at91_twi_read(AT91_TWI_RHR) & 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xfer_write(struct i2c_adapter *adap, unsigned char *buf, int length)\r\n{\r\nat91_twi_write(AT91_TWI_THR, *buf++);\r\nat91_twi_write(AT91_TWI_CR, AT91_TWI_START);\r\ndo {\r\nif (!at91_poll_status(AT91_TWI_TXRDY)) {\r\ndev_dbg(&adap->dev, "TXRDY timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nlength--;\r\nif (length > 0)\r\nat91_twi_write(AT91_TWI_THR, *buf++);\r\n} while (length);\r\nat91_twi_write(AT91_TWI_CR, AT91_TWI_STOP);\r\nreturn 0;\r\n}\r\nstatic int at91_xfer(struct i2c_adapter *adap, struct i2c_msg *pmsg, int num)\r\n{\r\nint i, ret;\r\ndev_dbg(&adap->dev, "at91_xfer: processing %d messages:\n", num);\r\nfor (i = 0; i < num; i++) {\r\ndev_dbg(&adap->dev, " #%d: %sing %d byte%s %s 0x%02x\n", i,\r\npmsg->flags & I2C_M_RD ? "read" : "writ",\r\npmsg->len, pmsg->len > 1 ? "s" : "",\r\npmsg->flags & I2C_M_RD ? "from" : "to", pmsg->addr);\r\nat91_twi_write(AT91_TWI_MMR, (pmsg->addr << 16)\r\n| ((pmsg->flags & I2C_M_RD) ? AT91_TWI_MREAD : 0));\r\nif (pmsg->len && pmsg->buf) {\r\nif (pmsg->flags & I2C_M_RD)\r\nret = xfer_read(adap, pmsg->buf, pmsg->len);\r\nelse\r\nret = xfer_write(adap, pmsg->buf, pmsg->len);\r\nif (ret)\r\nreturn ret;\r\nif (!at91_poll_status(AT91_TWI_TXCOMP)) {\r\ndev_dbg(&adap->dev, "TXCOMP timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\ndev_dbg(&adap->dev, "transfer complete\n");\r\npmsg++;\r\n}\r\nreturn i;\r\n}\r\nstatic u32 at91_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int __devinit at91_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *adapter;\r\nstruct resource *res;\r\nint rc;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nif (!request_mem_region(res->start, resource_size(res), "at91_i2c"))\r\nreturn -EBUSY;\r\ntwi_base = ioremap(res->start, resource_size(res));\r\nif (!twi_base) {\r\nrc = -ENOMEM;\r\ngoto fail0;\r\n}\r\ntwi_clk = clk_get(NULL, "twi_clk");\r\nif (IS_ERR(twi_clk)) {\r\ndev_err(&pdev->dev, "no clock defined\n");\r\nrc = -ENODEV;\r\ngoto fail1;\r\n}\r\nadapter = kzalloc(sizeof(struct i2c_adapter), GFP_KERNEL);\r\nif (adapter == NULL) {\r\ndev_err(&pdev->dev, "can't allocate inteface!\n");\r\nrc = -ENOMEM;\r\ngoto fail2;\r\n}\r\nsnprintf(adapter->name, sizeof(adapter->name), "AT91");\r\nadapter->algo = &at91_algorithm;\r\nadapter->class = I2C_CLASS_HWMON;\r\nadapter->dev.parent = &pdev->dev;\r\nplatform_set_drvdata(pdev, adapter);\r\nclk_enable(twi_clk);\r\nat91_twi_hwinit();\r\nrc = i2c_add_numbered_adapter(adapter);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Adapter %s registration failed\n",\r\nadapter->name);\r\ngoto fail3;\r\n}\r\ndev_info(&pdev->dev, "AT91 i2c bus driver.\n");\r\nreturn 0;\r\nfail3:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(adapter);\r\nclk_disable(twi_clk);\r\nfail2:\r\nclk_put(twi_clk);\r\nfail1:\r\niounmap(twi_base);\r\nfail0:\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn rc;\r\n}\r\nstatic int __devexit at91_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_adapter *adapter = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nint rc;\r\nrc = i2c_del_adapter(adapter);\r\nplatform_set_drvdata(pdev, NULL);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niounmap(twi_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable(twi_clk);\r\nclk_put(twi_clk);\r\nreturn rc;\r\n}\r\nstatic int at91_i2c_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nclk_disable(twi_clk);\r\nreturn 0;\r\n}\r\nstatic int at91_i2c_resume(struct platform_device *pdev)\r\n{\r\nreturn clk_enable(twi_clk);\r\n}
