static void e1000_raise_eec_clk(struct e1000_hw *hw, u32 *eecd)\r\n{\r\n*eecd = *eecd | E1000_EECD_SK;\r\new32(EECD, *eecd);\r\ne1e_flush();\r\nudelay(hw->nvm.delay_usec);\r\n}\r\nstatic void e1000_lower_eec_clk(struct e1000_hw *hw, u32 *eecd)\r\n{\r\n*eecd = *eecd & ~E1000_EECD_SK;\r\new32(EECD, *eecd);\r\ne1e_flush();\r\nudelay(hw->nvm.delay_usec);\r\n}\r\nstatic void e1000_shift_out_eec_bits(struct e1000_hw *hw, u16 data, u16 count)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = er32(EECD);\r\nu32 mask;\r\nmask = 0x01 << (count - 1);\r\nif (nvm->type == e1000_nvm_eeprom_spi)\r\neecd |= E1000_EECD_DO;\r\ndo {\r\neecd &= ~E1000_EECD_DI;\r\nif (data & mask)\r\neecd |= E1000_EECD_DI;\r\new32(EECD, eecd);\r\ne1e_flush();\r\nudelay(nvm->delay_usec);\r\ne1000_raise_eec_clk(hw, &eecd);\r\ne1000_lower_eec_clk(hw, &eecd);\r\nmask >>= 1;\r\n} while (mask);\r\neecd &= ~E1000_EECD_DI;\r\new32(EECD, eecd);\r\n}\r\nstatic u16 e1000_shift_in_eec_bits(struct e1000_hw *hw, u16 count)\r\n{\r\nu32 eecd;\r\nu32 i;\r\nu16 data;\r\neecd = er32(EECD);\r\neecd &= ~(E1000_EECD_DO | E1000_EECD_DI);\r\ndata = 0;\r\nfor (i = 0; i < count; i++) {\r\ndata <<= 1;\r\ne1000_raise_eec_clk(hw, &eecd);\r\neecd = er32(EECD);\r\neecd &= ~E1000_EECD_DI;\r\nif (eecd & E1000_EECD_DO)\r\ndata |= 1;\r\ne1000_lower_eec_clk(hw, &eecd);\r\n}\r\nreturn data;\r\n}\r\ns32 e1000e_poll_eerd_eewr_done(struct e1000_hw *hw, int ee_reg)\r\n{\r\nu32 attempts = 100000;\r\nu32 i, reg = 0;\r\nfor (i = 0; i < attempts; i++) {\r\nif (ee_reg == E1000_NVM_POLL_READ)\r\nreg = er32(EERD);\r\nelse\r\nreg = er32(EEWR);\r\nif (reg & E1000_NVM_RW_REG_DONE)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn -E1000_ERR_NVM;\r\n}\r\ns32 e1000e_acquire_nvm(struct e1000_hw *hw)\r\n{\r\nu32 eecd = er32(EECD);\r\ns32 timeout = E1000_NVM_GRANT_ATTEMPTS;\r\new32(EECD, eecd | E1000_EECD_REQ);\r\neecd = er32(EECD);\r\nwhile (timeout) {\r\nif (eecd & E1000_EECD_GNT)\r\nbreak;\r\nudelay(5);\r\neecd = er32(EECD);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\neecd &= ~E1000_EECD_REQ;\r\new32(EECD, eecd);\r\ne_dbg("Could not acquire NVM grant\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void e1000_standby_nvm(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = er32(EECD);\r\nif (nvm->type == e1000_nvm_eeprom_spi) {\r\neecd |= E1000_EECD_CS;\r\new32(EECD, eecd);\r\ne1e_flush();\r\nudelay(nvm->delay_usec);\r\neecd &= ~E1000_EECD_CS;\r\new32(EECD, eecd);\r\ne1e_flush();\r\nudelay(nvm->delay_usec);\r\n}\r\n}\r\nstatic void e1000_stop_nvm(struct e1000_hw *hw)\r\n{\r\nu32 eecd;\r\neecd = er32(EECD);\r\nif (hw->nvm.type == e1000_nvm_eeprom_spi) {\r\neecd |= E1000_EECD_CS;\r\ne1000_lower_eec_clk(hw, &eecd);\r\n}\r\n}\r\nvoid e1000e_release_nvm(struct e1000_hw *hw)\r\n{\r\nu32 eecd;\r\ne1000_stop_nvm(hw);\r\neecd = er32(EECD);\r\neecd &= ~E1000_EECD_REQ;\r\new32(EECD, eecd);\r\n}\r\nstatic s32 e1000_ready_nvm_eeprom(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = er32(EECD);\r\nu8 spi_stat_reg;\r\nif (nvm->type == e1000_nvm_eeprom_spi) {\r\nu16 timeout = NVM_MAX_RETRY_SPI;\r\neecd &= ~(E1000_EECD_CS | E1000_EECD_SK);\r\new32(EECD, eecd);\r\ne1e_flush();\r\nudelay(1);\r\nwhile (timeout) {\r\ne1000_shift_out_eec_bits(hw, NVM_RDSR_OPCODE_SPI,\r\nhw->nvm.opcode_bits);\r\nspi_stat_reg = (u8)e1000_shift_in_eec_bits(hw, 8);\r\nif (!(spi_stat_reg & NVM_STATUS_RDY_SPI))\r\nbreak;\r\nudelay(5);\r\ne1000_standby_nvm(hw);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\ne_dbg("SPI NVM Status error\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ns32 e1000e_read_nvm_eerd(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 i, eerd = 0;\r\ns32 ret_val = 0;\r\nif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\r\n(words == 0)) {\r\ne_dbg("nvm parameter(s) out of bounds\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nfor (i = 0; i < words; i++) {\r\neerd = ((offset + i) << E1000_NVM_RW_ADDR_SHIFT) +\r\nE1000_NVM_RW_REG_START;\r\new32(EERD, eerd);\r\nret_val = e1000e_poll_eerd_eewr_done(hw, E1000_NVM_POLL_READ);\r\nif (ret_val)\r\nbreak;\r\ndata[i] = (er32(EERD) >> E1000_NVM_RW_REG_DATA);\r\n}\r\nreturn ret_val;\r\n}\r\ns32 e1000e_write_nvm_spi(struct e1000_hw *hw, u16 offset, u16 words, u16 *data)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\ns32 ret_val;\r\nu16 widx = 0;\r\nif ((offset >= nvm->word_size) || (words > (nvm->word_size - offset)) ||\r\n(words == 0)) {\r\ne_dbg("nvm parameter(s) out of bounds\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nret_val = nvm->ops.acquire(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nwhile (widx < words) {\r\nu8 write_opcode = NVM_WRITE_OPCODE_SPI;\r\nret_val = e1000_ready_nvm_eeprom(hw);\r\nif (ret_val)\r\ngoto release;\r\ne1000_standby_nvm(hw);\r\ne1000_shift_out_eec_bits(hw, NVM_WREN_OPCODE_SPI,\r\nnvm->opcode_bits);\r\ne1000_standby_nvm(hw);\r\nif ((nvm->address_bits == 8) && (offset >= 128))\r\nwrite_opcode |= NVM_A8_OPCODE_SPI;\r\ne1000_shift_out_eec_bits(hw, write_opcode, nvm->opcode_bits);\r\ne1000_shift_out_eec_bits(hw, (u16)((offset + widx) * 2),\r\nnvm->address_bits);\r\nwhile (widx < words) {\r\nu16 word_out = data[widx];\r\nword_out = (word_out >> 8) | (word_out << 8);\r\ne1000_shift_out_eec_bits(hw, word_out, 16);\r\nwidx++;\r\nif ((((offset + widx) * 2) % nvm->page_size) == 0) {\r\ne1000_standby_nvm(hw);\r\nbreak;\r\n}\r\n}\r\n}\r\nusleep_range(10000, 20000);\r\nrelease:\r\nnvm->ops.release(hw);\r\nreturn ret_val;\r\n}\r\ns32 e1000_read_pba_string_generic(struct e1000_hw *hw, u8 *pba_num,\r\nu32 pba_num_size)\r\n{\r\ns32 ret_val;\r\nu16 nvm_data;\r\nu16 pba_ptr;\r\nu16 offset;\r\nu16 length;\r\nif (pba_num == NULL) {\r\ne_dbg("PBA string buffer was null\n");\r\nreturn -E1000_ERR_INVALID_ARGUMENT;\r\n}\r\nret_val = e1000_read_nvm(hw, NVM_PBA_OFFSET_0, 1, &nvm_data);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nret_val = e1000_read_nvm(hw, NVM_PBA_OFFSET_1, 1, &pba_ptr);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nif (nvm_data != NVM_PBA_PTR_GUARD) {\r\ne_dbg("NVM PBA number is not stored as string\n");\r\nif (pba_num_size < 11) {\r\ne_dbg("PBA string buffer too small\n");\r\nreturn E1000_ERR_NO_SPACE;\r\n}\r\npba_num[0] = (nvm_data >> 12) & 0xF;\r\npba_num[1] = (nvm_data >> 8) & 0xF;\r\npba_num[2] = (nvm_data >> 4) & 0xF;\r\npba_num[3] = nvm_data & 0xF;\r\npba_num[4] = (pba_ptr >> 12) & 0xF;\r\npba_num[5] = (pba_ptr >> 8) & 0xF;\r\npba_num[6] = '-';\r\npba_num[7] = 0;\r\npba_num[8] = (pba_ptr >> 4) & 0xF;\r\npba_num[9] = pba_ptr & 0xF;\r\npba_num[10] = '\0';\r\nfor (offset = 0; offset < 10; offset++) {\r\nif (pba_num[offset] < 0xA)\r\npba_num[offset] += '0';\r\nelse if (pba_num[offset] < 0x10)\r\npba_num[offset] += 'A' - 0xA;\r\n}\r\nreturn 0;\r\n}\r\nret_val = e1000_read_nvm(hw, pba_ptr, 1, &length);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nif (length == 0xFFFF || length == 0) {\r\ne_dbg("NVM PBA number section invalid length\n");\r\nreturn -E1000_ERR_NVM_PBA_SECTION;\r\n}\r\nif (pba_num_size < (((u32)length * 2) - 1)) {\r\ne_dbg("PBA string buffer too small\n");\r\nreturn -E1000_ERR_NO_SPACE;\r\n}\r\npba_ptr++;\r\nlength--;\r\nfor (offset = 0; offset < length; offset++) {\r\nret_val = e1000_read_nvm(hw, pba_ptr + offset, 1, &nvm_data);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\npba_num[offset * 2] = (u8)(nvm_data >> 8);\r\npba_num[(offset * 2) + 1] = (u8)(nvm_data & 0xFF);\r\n}\r\npba_num[offset * 2] = '\0';\r\nreturn 0;\r\n}\r\ns32 e1000_read_mac_addr_generic(struct e1000_hw *hw)\r\n{\r\nu32 rar_high;\r\nu32 rar_low;\r\nu16 i;\r\nrar_high = er32(RAH(0));\r\nrar_low = er32(RAL(0));\r\nfor (i = 0; i < E1000_RAL_MAC_ADDR_LEN; i++)\r\nhw->mac.perm_addr[i] = (u8)(rar_low >> (i * 8));\r\nfor (i = 0; i < E1000_RAH_MAC_ADDR_LEN; i++)\r\nhw->mac.perm_addr[i + 4] = (u8)(rar_high >> (i * 8));\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nhw->mac.addr[i] = hw->mac.perm_addr[i];\r\nreturn 0;\r\n}\r\ns32 e1000e_validate_nvm_checksum_generic(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 checksum = 0;\r\nu16 i, nvm_data;\r\nfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {\r\nret_val = e1000_read_nvm(hw, i, 1, &nvm_data);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error\n");\r\nreturn ret_val;\r\n}\r\nchecksum += nvm_data;\r\n}\r\nif (checksum != (u16)NVM_SUM) {\r\ne_dbg("NVM Checksum Invalid\n");\r\nreturn -E1000_ERR_NVM;\r\n}\r\nreturn 0;\r\n}\r\ns32 e1000e_update_nvm_checksum_generic(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 checksum = 0;\r\nu16 i, nvm_data;\r\nfor (i = 0; i < NVM_CHECKSUM_REG; i++) {\r\nret_val = e1000_read_nvm(hw, i, 1, &nvm_data);\r\nif (ret_val) {\r\ne_dbg("NVM Read Error while updating checksum.\n");\r\nreturn ret_val;\r\n}\r\nchecksum += nvm_data;\r\n}\r\nchecksum = (u16)NVM_SUM - checksum;\r\nret_val = e1000_write_nvm(hw, NVM_CHECKSUM_REG, 1, &checksum);\r\nif (ret_val)\r\ne_dbg("NVM Write Error while updating checksum.\n");\r\nreturn ret_val;\r\n}\r\nvoid e1000e_reload_nvm_generic(struct e1000_hw *hw)\r\n{\r\nu32 ctrl_ext;\r\nudelay(10);\r\nctrl_ext = er32(CTRL_EXT);\r\nctrl_ext |= E1000_CTRL_EXT_EE_RST;\r\new32(CTRL_EXT, ctrl_ext);\r\ne1e_flush();\r\n}
