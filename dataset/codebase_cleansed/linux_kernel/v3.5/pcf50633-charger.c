int pcf50633_mbc_usb_curlim_set(struct pcf50633 *pcf, int ma)\r\n{\r\nstruct pcf50633_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);\r\nint ret = 0;\r\nu8 bits;\r\nint charging_start = 1;\r\nu8 mbcs2, chgmod;\r\nunsigned int mbcc5;\r\nif (ma >= 1000) {\r\nbits = PCF50633_MBCC7_USB_1000mA;\r\nma = 1000;\r\n} else if (ma >= 500) {\r\nbits = PCF50633_MBCC7_USB_500mA;\r\nma = 500;\r\n} else if (ma >= 100) {\r\nbits = PCF50633_MBCC7_USB_100mA;\r\nma = 100;\r\n} else {\r\nbits = PCF50633_MBCC7_USB_SUSPEND;\r\ncharging_start = 0;\r\nma = 0;\r\n}\r\nret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC7,\r\nPCF50633_MBCC7_USB_MASK, bits);\r\nif (ret)\r\ndev_err(pcf->dev, "error setting usb curlim to %d mA\n", ma);\r\nelse\r\ndev_info(pcf->dev, "usb curlim to %d mA\n", ma);\r\nif (mbc->pcf->pdata->charger_reference_current_ma) {\r\nmbcc5 = (ma << 8) / mbc->pcf->pdata->charger_reference_current_ma;\r\nif (mbcc5 > 255)\r\nmbcc5 = 255;\r\npcf50633_reg_write(mbc->pcf, PCF50633_REG_MBCC5, mbcc5);\r\n}\r\nmbcs2 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2);\r\nchgmod = (mbcs2 & PCF50633_MBCS2_MBC_MASK);\r\nif (chgmod != PCF50633_MBCS2_MBC_BAT_FULL)\r\npcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC1,\r\nPCF50633_MBCC1_CHGENA, PCF50633_MBCC1_CHGENA);\r\nelse {\r\npcf50633_reg_clear_bits(pcf, PCF50633_REG_MBCC1,\r\nPCF50633_MBCC1_CHGENA);\r\npcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC1,\r\nPCF50633_MBCC1_CHGENA, PCF50633_MBCC1_CHGENA);\r\n}\r\npower_supply_changed(&mbc->usb);\r\nreturn ret;\r\n}\r\nint pcf50633_mbc_get_status(struct pcf50633 *pcf)\r\n{\r\nstruct pcf50633_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);\r\nint status = 0;\r\nu8 chgmod;\r\nif (!mbc)\r\nreturn 0;\r\nchgmod = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2)\r\n& PCF50633_MBCS2_MBC_MASK;\r\nif (mbc->usb_online)\r\nstatus |= PCF50633_MBC_USB_ONLINE;\r\nif (chgmod == PCF50633_MBCS2_MBC_USB_PRE ||\r\nchgmod == PCF50633_MBCS2_MBC_USB_PRE_WAIT ||\r\nchgmod == PCF50633_MBCS2_MBC_USB_FAST ||\r\nchgmod == PCF50633_MBCS2_MBC_USB_FAST_WAIT)\r\nstatus |= PCF50633_MBC_USB_ACTIVE;\r\nif (mbc->adapter_online)\r\nstatus |= PCF50633_MBC_ADAPTER_ONLINE;\r\nif (chgmod == PCF50633_MBCS2_MBC_ADP_PRE ||\r\nchgmod == PCF50633_MBCS2_MBC_ADP_PRE_WAIT ||\r\nchgmod == PCF50633_MBCS2_MBC_ADP_FAST ||\r\nchgmod == PCF50633_MBCS2_MBC_ADP_FAST_WAIT)\r\nstatus |= PCF50633_MBC_ADAPTER_ACTIVE;\r\nreturn status;\r\n}\r\nint pcf50633_mbc_get_usb_online_status(struct pcf50633 *pcf)\r\n{\r\nstruct pcf50633_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);\r\nif (!mbc)\r\nreturn 0;\r\nreturn mbc->usb_online;\r\n}\r\nstatic ssize_t\r\nshow_chgmode(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\r\nu8 mbcs2 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2);\r\nu8 chgmod = (mbcs2 & PCF50633_MBCS2_MBC_MASK);\r\nreturn sprintf(buf, "%d\n", chgmod);\r\n}\r\nstatic ssize_t\r\nshow_usblim(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\r\nu8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &\r\nPCF50633_MBCC7_USB_MASK;\r\nunsigned int ma;\r\nif (usblim == PCF50633_MBCC7_USB_1000mA)\r\nma = 1000;\r\nelse if (usblim == PCF50633_MBCC7_USB_500mA)\r\nma = 500;\r\nelse if (usblim == PCF50633_MBCC7_USB_100mA)\r\nma = 100;\r\nelse\r\nma = 0;\r\nreturn sprintf(buf, "%u\n", ma);\r\n}\r\nstatic ssize_t set_usblim(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\r\nunsigned long ma;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &ma);\r\nif (ret)\r\nreturn -EINVAL;\r\npcf50633_mbc_usb_curlim_set(mbc->pcf, ma);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_chglim(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\r\nu8 mbcc5 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC5);\r\nunsigned int ma;\r\nif (!mbc->pcf->pdata->charger_reference_current_ma)\r\nreturn -ENODEV;\r\nma = (mbc->pcf->pdata->charger_reference_current_ma * mbcc5) >> 8;\r\nreturn sprintf(buf, "%u\n", ma);\r\n}\r\nstatic ssize_t set_chglim(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct pcf50633_mbc *mbc = dev_get_drvdata(dev);\r\nunsigned long ma;\r\nunsigned int mbcc5;\r\nint ret;\r\nif (!mbc->pcf->pdata->charger_reference_current_ma)\r\nreturn -ENODEV;\r\nret = strict_strtoul(buf, 10, &ma);\r\nif (ret)\r\nreturn -EINVAL;\r\nmbcc5 = (ma << 8) / mbc->pcf->pdata->charger_reference_current_ma;\r\nif (mbcc5 > 255)\r\nmbcc5 = 255;\r\npcf50633_reg_write(mbc->pcf, PCF50633_REG_MBCC5, mbcc5);\r\nreturn count;\r\n}\r\nstatic void\r\npcf50633_mbc_irq_handler(int irq, void *data)\r\n{\r\nstruct pcf50633_mbc *mbc = data;\r\nif (irq == PCF50633_IRQ_USBINS) {\r\nmbc->usb_online = 1;\r\n} else if (irq == PCF50633_IRQ_USBREM) {\r\nmbc->usb_online = 0;\r\npcf50633_mbc_usb_curlim_set(mbc->pcf, 0);\r\n}\r\nif (irq == PCF50633_IRQ_ADPINS)\r\nmbc->adapter_online = 1;\r\nelse if (irq == PCF50633_IRQ_ADPREM)\r\nmbc->adapter_online = 0;\r\npower_supply_changed(&mbc->ac);\r\npower_supply_changed(&mbc->usb);\r\npower_supply_changed(&mbc->adapter);\r\nif (mbc->pcf->pdata->mbc_event_callback)\r\nmbc->pcf->pdata->mbc_event_callback(mbc->pcf, irq);\r\n}\r\nstatic int adapter_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct pcf50633_mbc *mbc = container_of(psy,\r\nstruct pcf50633_mbc, adapter);\r\nint ret = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = mbc->adapter_online;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int usb_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct pcf50633_mbc *mbc = container_of(psy, struct pcf50633_mbc, usb);\r\nint ret = 0;\r\nu8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &\r\nPCF50633_MBCC7_USB_MASK;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = mbc->usb_online &&\r\n(usblim <= PCF50633_MBCC7_USB_500mA);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ac_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct pcf50633_mbc *mbc = container_of(psy, struct pcf50633_mbc, ac);\r\nint ret = 0;\r\nu8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &\r\nPCF50633_MBCC7_USB_MASK;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = mbc->usb_online &&\r\n(usblim == PCF50633_MBCC7_USB_1000mA);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit pcf50633_mbc_probe(struct platform_device *pdev)\r\n{\r\nstruct pcf50633_mbc *mbc;\r\nint ret;\r\nint i;\r\nu8 mbcs1;\r\nmbc = kzalloc(sizeof(*mbc), GFP_KERNEL);\r\nif (!mbc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mbc);\r\nmbc->pcf = dev_to_pcf50633(pdev->dev.parent);\r\nfor (i = 0; i < ARRAY_SIZE(mbc_irq_handlers); i++)\r\npcf50633_register_irq(mbc->pcf, mbc_irq_handlers[i],\r\npcf50633_mbc_irq_handler, mbc);\r\nmbc->adapter.name = "adapter";\r\nmbc->adapter.type = POWER_SUPPLY_TYPE_MAINS;\r\nmbc->adapter.properties = power_props;\r\nmbc->adapter.num_properties = ARRAY_SIZE(power_props);\r\nmbc->adapter.get_property = &adapter_get_property;\r\nmbc->adapter.supplied_to = mbc->pcf->pdata->batteries;\r\nmbc->adapter.num_supplicants = mbc->pcf->pdata->num_batteries;\r\nmbc->usb.name = "usb";\r\nmbc->usb.type = POWER_SUPPLY_TYPE_USB;\r\nmbc->usb.properties = power_props;\r\nmbc->usb.num_properties = ARRAY_SIZE(power_props);\r\nmbc->usb.get_property = usb_get_property;\r\nmbc->usb.supplied_to = mbc->pcf->pdata->batteries;\r\nmbc->usb.num_supplicants = mbc->pcf->pdata->num_batteries;\r\nmbc->ac.name = "ac";\r\nmbc->ac.type = POWER_SUPPLY_TYPE_MAINS;\r\nmbc->ac.properties = power_props;\r\nmbc->ac.num_properties = ARRAY_SIZE(power_props);\r\nmbc->ac.get_property = ac_get_property;\r\nmbc->ac.supplied_to = mbc->pcf->pdata->batteries;\r\nmbc->ac.num_supplicants = mbc->pcf->pdata->num_batteries;\r\nret = power_supply_register(&pdev->dev, &mbc->adapter);\r\nif (ret) {\r\ndev_err(mbc->pcf->dev, "failed to register adapter\n");\r\nkfree(mbc);\r\nreturn ret;\r\n}\r\nret = power_supply_register(&pdev->dev, &mbc->usb);\r\nif (ret) {\r\ndev_err(mbc->pcf->dev, "failed to register usb\n");\r\npower_supply_unregister(&mbc->adapter);\r\nkfree(mbc);\r\nreturn ret;\r\n}\r\nret = power_supply_register(&pdev->dev, &mbc->ac);\r\nif (ret) {\r\ndev_err(mbc->pcf->dev, "failed to register ac\n");\r\npower_supply_unregister(&mbc->adapter);\r\npower_supply_unregister(&mbc->usb);\r\nkfree(mbc);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &mbc_attr_group);\r\nif (ret)\r\ndev_err(mbc->pcf->dev, "failed to create sysfs entries\n");\r\nmbcs1 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS1);\r\nif (mbcs1 & PCF50633_MBCS1_USBPRES)\r\npcf50633_mbc_irq_handler(PCF50633_IRQ_USBINS, mbc);\r\nif (mbcs1 & PCF50633_MBCS1_ADAPTPRES)\r\npcf50633_mbc_irq_handler(PCF50633_IRQ_ADPINS, mbc);\r\nreturn 0;\r\n}\r\nstatic int __devexit pcf50633_mbc_remove(struct platform_device *pdev)\r\n{\r\nstruct pcf50633_mbc *mbc = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mbc_irq_handlers); i++)\r\npcf50633_free_irq(mbc->pcf, mbc_irq_handlers[i]);\r\nsysfs_remove_group(&pdev->dev.kobj, &mbc_attr_group);\r\npower_supply_unregister(&mbc->usb);\r\npower_supply_unregister(&mbc->adapter);\r\npower_supply_unregister(&mbc->ac);\r\nkfree(mbc);\r\nreturn 0;\r\n}
