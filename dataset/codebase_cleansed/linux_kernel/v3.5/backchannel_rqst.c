static inline int xprt_need_to_requeue(struct rpc_xprt *xprt)\r\n{\r\nreturn xprt->bc_alloc_count > 0;\r\n}\r\nstatic inline void xprt_inc_alloc_count(struct rpc_xprt *xprt, unsigned int n)\r\n{\r\nxprt->bc_alloc_count += n;\r\n}\r\nstatic inline int xprt_dec_alloc_count(struct rpc_xprt *xprt, unsigned int n)\r\n{\r\nreturn xprt->bc_alloc_count -= n;\r\n}\r\nstatic void xprt_free_allocation(struct rpc_rqst *req)\r\n{\r\nstruct xdr_buf *xbufp;\r\ndprintk("RPC: free allocations for req= %p\n", req);\r\nBUG_ON(test_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state));\r\nxbufp = &req->rq_private_buf;\r\nfree_page((unsigned long)xbufp->head[0].iov_base);\r\nxbufp = &req->rq_snd_buf;\r\nfree_page((unsigned long)xbufp->head[0].iov_base);\r\nlist_del(&req->rq_bc_pa_list);\r\nkfree(req);\r\n}\r\nint xprt_setup_backchannel(struct rpc_xprt *xprt, unsigned int min_reqs)\r\n{\r\nstruct page *page_rcv = NULL, *page_snd = NULL;\r\nstruct xdr_buf *xbufp = NULL;\r\nstruct rpc_rqst *req, *tmp;\r\nstruct list_head tmp_list;\r\nint i;\r\ndprintk("RPC: setup backchannel transport\n");\r\nINIT_LIST_HEAD(&tmp_list);\r\nfor (i = 0; i < min_reqs; i++) {\r\nreq = kzalloc(sizeof(struct rpc_rqst), GFP_KERNEL);\r\nif (req == NULL) {\r\nprintk(KERN_ERR "Failed to create bc rpc_rqst\n");\r\ngoto out_free;\r\n}\r\ndprintk("RPC: adding req= %p\n", req);\r\nlist_add(&req->rq_bc_pa_list, &tmp_list);\r\nreq->rq_xprt = xprt;\r\nINIT_LIST_HEAD(&req->rq_list);\r\nINIT_LIST_HEAD(&req->rq_bc_list);\r\npage_rcv = alloc_page(GFP_KERNEL);\r\nif (page_rcv == NULL) {\r\nprintk(KERN_ERR "Failed to create bc receive xbuf\n");\r\ngoto out_free;\r\n}\r\nxbufp = &req->rq_rcv_buf;\r\nxbufp->head[0].iov_base = page_address(page_rcv);\r\nxbufp->head[0].iov_len = PAGE_SIZE;\r\nxbufp->tail[0].iov_base = NULL;\r\nxbufp->tail[0].iov_len = 0;\r\nxbufp->page_len = 0;\r\nxbufp->len = PAGE_SIZE;\r\nxbufp->buflen = PAGE_SIZE;\r\npage_snd = alloc_page(GFP_KERNEL);\r\nif (page_snd == NULL) {\r\nprintk(KERN_ERR "Failed to create bc snd xbuf\n");\r\ngoto out_free;\r\n}\r\nxbufp = &req->rq_snd_buf;\r\nxbufp->head[0].iov_base = page_address(page_snd);\r\nxbufp->head[0].iov_len = 0;\r\nxbufp->tail[0].iov_base = NULL;\r\nxbufp->tail[0].iov_len = 0;\r\nxbufp->page_len = 0;\r\nxbufp->len = 0;\r\nxbufp->buflen = PAGE_SIZE;\r\n}\r\nspin_lock_bh(&xprt->bc_pa_lock);\r\nlist_splice(&tmp_list, &xprt->bc_pa_list);\r\nxprt_inc_alloc_count(xprt, min_reqs);\r\nspin_unlock_bh(&xprt->bc_pa_lock);\r\ndprintk("RPC: setup backchannel transport done\n");\r\nreturn 0;\r\nout_free:\r\nlist_for_each_entry_safe(req, tmp, &tmp_list, rq_bc_pa_list)\r\nxprt_free_allocation(req);\r\ndprintk("RPC: setup backchannel transport failed\n");\r\nreturn -1;\r\n}\r\nvoid xprt_destroy_backchannel(struct rpc_xprt *xprt, unsigned int max_reqs)\r\n{\r\nstruct rpc_rqst *req = NULL, *tmp = NULL;\r\ndprintk("RPC: destroy backchannel transport\n");\r\nBUG_ON(max_reqs == 0);\r\nspin_lock_bh(&xprt->bc_pa_lock);\r\nxprt_dec_alloc_count(xprt, max_reqs);\r\nlist_for_each_entry_safe(req, tmp, &xprt->bc_pa_list, rq_bc_pa_list) {\r\ndprintk("RPC: req=%p\n", req);\r\nxprt_free_allocation(req);\r\nif (--max_reqs == 0)\r\nbreak;\r\n}\r\nspin_unlock_bh(&xprt->bc_pa_lock);\r\ndprintk("RPC: backchannel list empty= %s\n",\r\nlist_empty(&xprt->bc_pa_list) ? "true" : "false");\r\n}\r\nstruct rpc_rqst *xprt_alloc_bc_request(struct rpc_xprt *xprt)\r\n{\r\nstruct rpc_rqst *req;\r\ndprintk("RPC: allocate a backchannel request\n");\r\nspin_lock(&xprt->bc_pa_lock);\r\nif (!list_empty(&xprt->bc_pa_list)) {\r\nreq = list_first_entry(&xprt->bc_pa_list, struct rpc_rqst,\r\nrq_bc_pa_list);\r\nlist_del(&req->rq_bc_pa_list);\r\n} else {\r\nreq = NULL;\r\n}\r\nspin_unlock(&xprt->bc_pa_lock);\r\nif (req != NULL) {\r\nset_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state);\r\nreq->rq_reply_bytes_recvd = 0;\r\nreq->rq_bytes_sent = 0;\r\nmemcpy(&req->rq_private_buf, &req->rq_rcv_buf,\r\nsizeof(req->rq_private_buf));\r\n}\r\ndprintk("RPC: backchannel req=%p\n", req);\r\nreturn req;\r\n}\r\nvoid xprt_free_bc_request(struct rpc_rqst *req)\r\n{\r\nstruct rpc_xprt *xprt = req->rq_xprt;\r\ndprintk("RPC: free backchannel req=%p\n", req);\r\nsmp_mb__before_clear_bit();\r\nBUG_ON(!test_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state));\r\nclear_bit(RPC_BC_PA_IN_USE, &req->rq_bc_pa_state);\r\nsmp_mb__after_clear_bit();\r\nif (!xprt_need_to_requeue(xprt)) {\r\ndprintk("RPC: Last session removed req=%p\n", req);\r\nxprt_free_allocation(req);\r\nreturn;\r\n}\r\nspin_lock_bh(&xprt->bc_pa_lock);\r\nlist_add(&req->rq_bc_pa_list, &xprt->bc_pa_list);\r\nspin_unlock_bh(&xprt->bc_pa_lock);\r\n}
