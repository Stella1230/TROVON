static void twd_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\nunsigned long ctrl;\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nctrl = TWD_TIMER_CONTROL_ENABLE | TWD_TIMER_CONTROL_IT_ENABLE\r\n| TWD_TIMER_CONTROL_PERIODIC;\r\n__raw_writel(twd_timer_rate / HZ, twd_base + TWD_TIMER_LOAD);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nctrl = TWD_TIMER_CONTROL_IT_ENABLE | TWD_TIMER_CONTROL_ONESHOT;\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ndefault:\r\nctrl = 0;\r\n}\r\n__raw_writel(ctrl, twd_base + TWD_TIMER_CONTROL);\r\n}\r\nstatic int twd_set_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nunsigned long ctrl = __raw_readl(twd_base + TWD_TIMER_CONTROL);\r\nctrl |= TWD_TIMER_CONTROL_ENABLE;\r\n__raw_writel(evt, twd_base + TWD_TIMER_COUNTER);\r\n__raw_writel(ctrl, twd_base + TWD_TIMER_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int twd_timer_ack(void)\r\n{\r\nif (__raw_readl(twd_base + TWD_TIMER_INTSTAT)) {\r\n__raw_writel(1, twd_base + TWD_TIMER_INTSTAT);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twd_timer_stop(struct clock_event_device *clk)\r\n{\r\ntwd_set_mode(CLOCK_EVT_MODE_UNUSED, clk);\r\ndisable_percpu_irq(clk->irq);\r\n}\r\nstatic void twd_update_frequency(void *data)\r\n{\r\ntwd_timer_rate = clk_get_rate(twd_clk);\r\nclockevents_update_freq(*__this_cpu_ptr(twd_evt), twd_timer_rate);\r\n}\r\nstatic int twd_cpufreq_transition(struct notifier_block *nb,\r\nunsigned long state, void *data)\r\n{\r\nstruct cpufreq_freqs *freqs = data;\r\nif (state == CPUFREQ_POSTCHANGE || state == CPUFREQ_RESUMECHANGE)\r\nsmp_call_function_single(freqs->cpu, twd_update_frequency,\r\nNULL, 1);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int twd_cpufreq_init(void)\r\n{\r\nif (twd_evt && *__this_cpu_ptr(twd_evt) && !IS_ERR(twd_clk))\r\nreturn cpufreq_register_notifier(&twd_cpufreq_nb,\r\nCPUFREQ_TRANSITION_NOTIFIER);\r\nreturn 0;\r\n}\r\nstatic void __cpuinit twd_calibrate_rate(void)\r\n{\r\nunsigned long count;\r\nu64 waitjiffies;\r\nif (twd_timer_rate == 0) {\r\nprintk(KERN_INFO "Calibrating local timer... ");\r\nwaitjiffies = get_jiffies_64() + 1;\r\nwhile (get_jiffies_64() < waitjiffies)\r\nudelay(10);\r\nwaitjiffies += 5;\r\n__raw_writel(0x1, twd_base + TWD_TIMER_CONTROL);\r\n__raw_writel(0xFFFFFFFFU, twd_base + TWD_TIMER_COUNTER);\r\nwhile (get_jiffies_64() < waitjiffies)\r\nudelay(10);\r\ncount = __raw_readl(twd_base + TWD_TIMER_COUNTER);\r\ntwd_timer_rate = (0xFFFFFFFFU - count) * (HZ / 5);\r\nprintk("%lu.%02luMHz.\n", twd_timer_rate / 1000000,\r\n(twd_timer_rate / 10000) % 100);\r\n}\r\n}\r\nstatic irqreturn_t twd_handler(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = *(struct clock_event_device **)dev_id;\r\nif (twd_timer_ack()) {\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic struct clk *twd_get_clock(void)\r\n{\r\nstruct clk *clk;\r\nint err;\r\nclk = clk_get_sys("smp_twd", NULL);\r\nif (IS_ERR(clk)) {\r\npr_err("smp_twd: clock not found: %d\n", (int)PTR_ERR(clk));\r\nreturn clk;\r\n}\r\nerr = clk_prepare(clk);\r\nif (err) {\r\npr_err("smp_twd: clock failed to prepare: %d\n", err);\r\nclk_put(clk);\r\nreturn ERR_PTR(err);\r\n}\r\nerr = clk_enable(clk);\r\nif (err) {\r\npr_err("smp_twd: clock failed to enable: %d\n", err);\r\nclk_unprepare(clk);\r\nclk_put(clk);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn clk;\r\n}\r\nstatic int __cpuinit twd_timer_setup(struct clock_event_device *clk)\r\n{\r\nstruct clock_event_device **this_cpu_clk;\r\nif (!twd_clk)\r\ntwd_clk = twd_get_clock();\r\nif (!IS_ERR_OR_NULL(twd_clk))\r\ntwd_timer_rate = clk_get_rate(twd_clk);\r\nelse\r\ntwd_calibrate_rate();\r\n__raw_writel(0, twd_base + TWD_TIMER_CONTROL);\r\nclk->name = "local_timer";\r\nclk->features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_C3STOP;\r\nclk->rating = 350;\r\nclk->set_mode = twd_set_mode;\r\nclk->set_next_event = twd_set_next_event;\r\nclk->irq = twd_ppi;\r\nthis_cpu_clk = __this_cpu_ptr(twd_evt);\r\n*this_cpu_clk = clk;\r\nclockevents_config_and_register(clk, twd_timer_rate,\r\n0xf, 0xffffffff);\r\nenable_percpu_irq(clk->irq, 0);\r\nreturn 0;\r\n}\r\nstatic int __init twd_local_timer_common_register(void)\r\n{\r\nint err;\r\ntwd_evt = alloc_percpu(struct clock_event_device *);\r\nif (!twd_evt) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nerr = request_percpu_irq(twd_ppi, twd_handler, "twd", twd_evt);\r\nif (err) {\r\npr_err("twd: can't register interrupt %d (%d)\n", twd_ppi, err);\r\ngoto out_free;\r\n}\r\nerr = local_timer_register(&twd_lt_ops);\r\nif (err)\r\ngoto out_irq;\r\nreturn 0;\r\nout_irq:\r\nfree_percpu_irq(twd_ppi, twd_evt);\r\nout_free:\r\niounmap(twd_base);\r\ntwd_base = NULL;\r\nfree_percpu(twd_evt);\r\nreturn err;\r\n}\r\nint __init twd_local_timer_register(struct twd_local_timer *tlt)\r\n{\r\nif (twd_base || twd_evt)\r\nreturn -EBUSY;\r\ntwd_ppi = tlt->res[1].start;\r\ntwd_base = ioremap(tlt->res[0].start, resource_size(&tlt->res[0]));\r\nif (!twd_base)\r\nreturn -ENOMEM;\r\nreturn twd_local_timer_common_register();\r\n}\r\nvoid __init twd_local_timer_of_register(void)\r\n{\r\nstruct device_node *np;\r\nint err;\r\nnp = of_find_matching_node(NULL, twd_of_match);\r\nif (!np) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ntwd_ppi = irq_of_parse_and_map(np, 0);\r\nif (!twd_ppi) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ntwd_base = of_iomap(np, 0);\r\nif (!twd_base) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = twd_local_timer_common_register();\r\nout:\r\nWARN(err, "twd_local_timer_of_register failed (%d)\n", err);\r\n}
