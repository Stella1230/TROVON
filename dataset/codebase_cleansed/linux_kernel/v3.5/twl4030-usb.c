static int twl4030_i2c_write_u8_verify(struct twl4030_usb *twl,\r\nu8 module, u8 data, u8 address)\r\n{\r\nu8 check;\r\nif ((twl_i2c_write_u8(module, data, address) >= 0) &&\r\n(twl_i2c_read_u8(module, &check, address) >= 0) &&\r\n(check == data))\r\nreturn 0;\r\ndev_dbg(twl->dev, "Write%d[%d,0x%x] wrote %02x but read %02x\n",\r\n1, module, address, check, data);\r\nif ((twl_i2c_write_u8(module, data, address) >= 0) &&\r\n(twl_i2c_read_u8(module, &check, address) >= 0) &&\r\n(check == data))\r\nreturn 0;\r\ndev_dbg(twl->dev, "Write%d[%d,0x%x] wrote %02x but read %02x\n",\r\n2, module, address, check, data);\r\nreturn -EBUSY;\r\n}\r\nstatic inline int twl4030_usb_write(struct twl4030_usb *twl,\r\nu8 address, u8 data)\r\n{\r\nint ret = 0;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_USB, data, address);\r\nif (ret < 0)\r\ndev_dbg(twl->dev,\r\n"TWL4030:USB:Write[0x%x] Error %d\n", address, ret);\r\nreturn ret;\r\n}\r\nstatic inline int twl4030_readb(struct twl4030_usb *twl, u8 module, u8 address)\r\n{\r\nu8 data;\r\nint ret = 0;\r\nret = twl_i2c_read_u8(module, &data, address);\r\nif (ret >= 0)\r\nret = data;\r\nelse\r\ndev_dbg(twl->dev,\r\n"TWL4030:readb[0x%x,0x%x] Error %d\n",\r\nmodule, address, ret);\r\nreturn ret;\r\n}\r\nstatic inline int twl4030_usb_read(struct twl4030_usb *twl, u8 address)\r\n{\r\nreturn twl4030_readb(twl, TWL4030_MODULE_USB, address);\r\n}\r\nstatic inline int\r\ntwl4030_usb_set_bits(struct twl4030_usb *twl, u8 reg, u8 bits)\r\n{\r\nreturn twl4030_usb_write(twl, ULPI_SET(reg), bits);\r\n}\r\nstatic inline int\r\ntwl4030_usb_clear_bits(struct twl4030_usb *twl, u8 reg, u8 bits)\r\n{\r\nreturn twl4030_usb_write(twl, ULPI_CLR(reg), bits);\r\n}\r\nstatic enum usb_phy_events twl4030_usb_linkstat(struct twl4030_usb *twl)\r\n{\r\nint status;\r\nint linkstat = USB_EVENT_NONE;\r\nstruct usb_otg *otg = twl->phy.otg;\r\ntwl->vbus_supplied = false;\r\nstatus = twl4030_readb(twl, TWL4030_MODULE_PM_MASTER,\r\nSTS_HW_CONDITIONS);\r\nif (status < 0)\r\ndev_err(twl->dev, "USB link status err %d\n", status);\r\nelse if (status & (BIT(7) | BIT(2))) {\r\nif (status & (BIT(7)))\r\ntwl->vbus_supplied = true;\r\nif (status & BIT(2))\r\nlinkstat = USB_EVENT_ID;\r\nelse\r\nlinkstat = USB_EVENT_VBUS;\r\n} else\r\nlinkstat = USB_EVENT_NONE;\r\ndev_dbg(twl->dev, "HW_CONDITIONS 0x%02x/%d; link %d\n",\r\nstatus, status, linkstat);\r\ntwl->phy.last_event = linkstat;\r\nspin_lock_irq(&twl->lock);\r\ntwl->linkstat = linkstat;\r\nif (linkstat == USB_EVENT_ID) {\r\notg->default_a = true;\r\ntwl->phy.state = OTG_STATE_A_IDLE;\r\n} else {\r\notg->default_a = false;\r\ntwl->phy.state = OTG_STATE_B_IDLE;\r\n}\r\nspin_unlock_irq(&twl->lock);\r\nreturn linkstat;\r\n}\r\nstatic void twl4030_usb_set_mode(struct twl4030_usb *twl, int mode)\r\n{\r\ntwl->usb_mode = mode;\r\nswitch (mode) {\r\ncase T2_USB_MODE_ULPI:\r\ntwl4030_usb_clear_bits(twl, ULPI_IFC_CTRL,\r\nULPI_IFC_CTRL_CARKITMODE);\r\ntwl4030_usb_set_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);\r\ntwl4030_usb_clear_bits(twl, ULPI_FUNC_CTRL,\r\nULPI_FUNC_CTRL_XCVRSEL_MASK |\r\nULPI_FUNC_CTRL_OPMODE_MASK);\r\nbreak;\r\ncase -1:\r\nbreak;\r\ndefault:\r\ndev_err(twl->dev, "unsupported T2 transceiver mode %d\n",\r\nmode);\r\nbreak;\r\n};\r\n}\r\nstatic void twl4030_i2c_access(struct twl4030_usb *twl, int on)\r\n{\r\nunsigned long timeout;\r\nint val = twl4030_usb_read(twl, PHY_CLK_CTRL);\r\nif (val >= 0) {\r\nif (on) {\r\nval |= REQ_PHY_DPLL_CLK;\r\nWARN_ON(twl4030_usb_write_verify(twl, PHY_CLK_CTRL,\r\n(u8)val) < 0);\r\ntimeout = jiffies + HZ;\r\nwhile (!(twl4030_usb_read(twl, PHY_CLK_CTRL_STS) &\r\nPHY_DPLL_CLK)\r\n&& time_before(jiffies, timeout))\r\nudelay(10);\r\nif (!(twl4030_usb_read(twl, PHY_CLK_CTRL_STS) &\r\nPHY_DPLL_CLK))\r\ndev_err(twl->dev, "Timeout setting T2 HSUSB "\r\n"PHY DPLL clock\n");\r\n} else {\r\nval &= ~REQ_PHY_DPLL_CLK;\r\nWARN_ON(twl4030_usb_write_verify(twl, PHY_CLK_CTRL,\r\n(u8)val) < 0);\r\n}\r\n}\r\n}\r\nstatic void __twl4030_phy_power(struct twl4030_usb *twl, int on)\r\n{\r\nu8 pwr = twl4030_usb_read(twl, PHY_PWR_CTRL);\r\nif (on)\r\npwr &= ~PHY_PWR_PHYPWD;\r\nelse\r\npwr |= PHY_PWR_PHYPWD;\r\nWARN_ON(twl4030_usb_write_verify(twl, PHY_PWR_CTRL, pwr) < 0);\r\n}\r\nstatic void twl4030_phy_power(struct twl4030_usb *twl, int on)\r\n{\r\nif (on) {\r\nregulator_enable(twl->usb3v1);\r\nregulator_enable(twl->usb1v8);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0,\r\nVUSB_DEDICATED2);\r\nregulator_enable(twl->usb1v5);\r\n__twl4030_phy_power(twl, 1);\r\ntwl4030_usb_write(twl, PHY_CLK_CTRL,\r\ntwl4030_usb_read(twl, PHY_CLK_CTRL) |\r\n(PHY_CLK_CTRL_CLOCKGATING_EN |\r\nPHY_CLK_CTRL_CLK32K_EN));\r\n} else {\r\n__twl4030_phy_power(twl, 0);\r\nregulator_disable(twl->usb1v5);\r\nregulator_disable(twl->usb1v8);\r\nregulator_disable(twl->usb3v1);\r\n}\r\n}\r\nstatic void twl4030_phy_suspend(struct twl4030_usb *twl, int controller_off)\r\n{\r\nif (twl->asleep)\r\nreturn;\r\ntwl4030_phy_power(twl, 0);\r\ntwl->asleep = 1;\r\ndev_dbg(twl->dev, "%s\n", __func__);\r\n}\r\nstatic void __twl4030_phy_resume(struct twl4030_usb *twl)\r\n{\r\ntwl4030_phy_power(twl, 1);\r\ntwl4030_i2c_access(twl, 1);\r\ntwl4030_usb_set_mode(twl, twl->usb_mode);\r\nif (twl->usb_mode == T2_USB_MODE_ULPI)\r\ntwl4030_i2c_access(twl, 0);\r\n}\r\nstatic void twl4030_phy_resume(struct twl4030_usb *twl)\r\n{\r\nif (!twl->asleep)\r\nreturn;\r\n__twl4030_phy_resume(twl);\r\ntwl->asleep = 0;\r\ndev_dbg(twl->dev, "%s\n", __func__);\r\n}\r\nstatic int twl4030_usb_ldo_init(struct twl4030_usb *twl)\r\n{\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_MASTER,\r\nTWL4030_PM_MASTER_KEY_CFG1,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_MASTER,\r\nTWL4030_PM_MASTER_KEY_CFG2,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0x14, VUSB_DEDICATED1);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0, VUSB3V1_DEV_GRP);\r\ntwl->usb3v1 = regulator_get(twl->dev, "usb3v1");\r\nif (IS_ERR(twl->usb3v1))\r\nreturn -ENODEV;\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0, VUSB3V1_TYPE);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0, VUSB1V5_DEV_GRP);\r\ntwl->usb1v5 = regulator_get(twl->dev, "usb1v5");\r\nif (IS_ERR(twl->usb1v5))\r\ngoto fail1;\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0, VUSB1V5_TYPE);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0, VUSB1V8_DEV_GRP);\r\ntwl->usb1v8 = regulator_get(twl->dev, "usb1v8");\r\nif (IS_ERR(twl->usb1v8))\r\ngoto fail2;\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER, 0, VUSB1V8_TYPE);\r\ntwl_i2c_write_u8(TWL4030_MODULE_PM_MASTER, 0,\r\nTWL4030_PM_MASTER_PROTECT_KEY);\r\nreturn 0;\r\nfail2:\r\nregulator_put(twl->usb1v5);\r\ntwl->usb1v5 = NULL;\r\nfail1:\r\nregulator_put(twl->usb3v1);\r\ntwl->usb3v1 = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic ssize_t twl4030_usb_vbus_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct twl4030_usb *twl = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&twl->lock, flags);\r\nret = sprintf(buf, "%s\n",\r\ntwl->vbus_supplied ? "on" : "off");\r\nspin_unlock_irqrestore(&twl->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t twl4030_usb_irq(int irq, void *_twl)\r\n{\r\nstruct twl4030_usb *twl = _twl;\r\nint status;\r\nstatus = twl4030_usb_linkstat(twl);\r\nif (status >= 0) {\r\nif (status == USB_EVENT_NONE)\r\ntwl4030_phy_suspend(twl, 0);\r\nelse\r\ntwl4030_phy_resume(twl);\r\natomic_notifier_call_chain(&twl->phy.notifier, status,\r\ntwl->phy.otg->gadget);\r\n}\r\nsysfs_notify(&twl->dev->kobj, NULL, "vbus");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void twl4030_usb_phy_init(struct twl4030_usb *twl)\r\n{\r\nint status;\r\nstatus = twl4030_usb_linkstat(twl);\r\nif (status >= 0) {\r\nif (status == USB_EVENT_NONE) {\r\n__twl4030_phy_power(twl, 0);\r\ntwl->asleep = 1;\r\n} else {\r\n__twl4030_phy_resume(twl);\r\ntwl->asleep = 0;\r\n}\r\natomic_notifier_call_chain(&twl->phy.notifier, status,\r\ntwl->phy.otg->gadget);\r\n}\r\nsysfs_notify(&twl->dev->kobj, NULL, "vbus");\r\n}\r\nstatic int twl4030_set_suspend(struct usb_phy *x, int suspend)\r\n{\r\nstruct twl4030_usb *twl = phy_to_twl(x);\r\nif (suspend)\r\ntwl4030_phy_suspend(twl, 1);\r\nelse\r\ntwl4030_phy_resume(twl);\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\notg->gadget = gadget;\r\nif (!gadget)\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int twl4030_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\notg->host = host;\r\nif (!host)\r\notg->phy->state = OTG_STATE_UNDEFINED;\r\nreturn 0;\r\n}\r\nstatic int __devinit twl4030_usb_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_usb_data *pdata = pdev->dev.platform_data;\r\nstruct twl4030_usb *twl;\r\nint status, err;\r\nstruct usb_otg *otg;\r\nif (!pdata) {\r\ndev_dbg(&pdev->dev, "platform_data not available\n");\r\nreturn -EINVAL;\r\n}\r\ntwl = kzalloc(sizeof *twl, GFP_KERNEL);\r\nif (!twl)\r\nreturn -ENOMEM;\r\notg = kzalloc(sizeof *otg, GFP_KERNEL);\r\nif (!otg) {\r\nkfree(twl);\r\nreturn -ENOMEM;\r\n}\r\ntwl->dev = &pdev->dev;\r\ntwl->irq = platform_get_irq(pdev, 0);\r\ntwl->usb_mode = pdata->usb_mode;\r\ntwl->vbus_supplied = false;\r\ntwl->asleep = 1;\r\ntwl->phy.dev = twl->dev;\r\ntwl->phy.label = "twl4030";\r\ntwl->phy.otg = otg;\r\ntwl->phy.set_suspend = twl4030_set_suspend;\r\notg->phy = &twl->phy;\r\notg->set_host = twl4030_set_host;\r\notg->set_peripheral = twl4030_set_peripheral;\r\nspin_lock_init(&twl->lock);\r\nerr = twl4030_usb_ldo_init(twl);\r\nif (err) {\r\ndev_err(&pdev->dev, "ldo init failed\n");\r\nkfree(otg);\r\nkfree(twl);\r\nreturn err;\r\n}\r\nusb_set_transceiver(&twl->phy);\r\nplatform_set_drvdata(pdev, twl);\r\nif (device_create_file(&pdev->dev, &dev_attr_vbus))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nATOMIC_INIT_NOTIFIER_HEAD(&twl->phy.notifier);\r\ntwl->irq_enabled = true;\r\nstatus = request_threaded_irq(twl->irq, NULL, twl4030_usb_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\r\n"twl4030_usb", twl);\r\nif (status < 0) {\r\ndev_dbg(&pdev->dev, "can't get IRQ %d, err %d\n",\r\ntwl->irq, status);\r\nkfree(otg);\r\nkfree(twl);\r\nreturn status;\r\n}\r\ntwl4030_usb_phy_init(twl);\r\ndev_info(&pdev->dev, "Initialized TWL4030 USB module\n");\r\nreturn 0;\r\n}\r\nstatic int __exit twl4030_usb_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_usb *twl = platform_get_drvdata(pdev);\r\nint val;\r\nfree_irq(twl->irq, twl);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\ntwl4030_usb_set_mode(twl, -1);\r\nval = twl4030_usb_read(twl, PHY_CLK_CTRL);\r\nif (val >= 0) {\r\nval |= PHY_CLK_CTRL_CLOCKGATING_EN;\r\nval &= ~(PHY_CLK_CTRL_CLK32K_EN | REQ_PHY_DPLL_CLK);\r\ntwl4030_usb_write(twl, PHY_CLK_CTRL, (u8)val);\r\n}\r\ntwl4030_usb_clear_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);\r\nif (!twl->asleep)\r\ntwl4030_phy_power(twl, 0);\r\nregulator_put(twl->usb1v5);\r\nregulator_put(twl->usb1v8);\r\nregulator_put(twl->usb3v1);\r\nkfree(twl->phy.otg);\r\nkfree(twl);\r\nreturn 0;\r\n}\r\nstatic int __init twl4030_usb_init(void)\r\n{\r\nreturn platform_driver_register(&twl4030_usb_driver);\r\n}\r\nstatic void __exit twl4030_usb_exit(void)\r\n{\r\nplatform_driver_unregister(&twl4030_usb_driver);\r\n}
