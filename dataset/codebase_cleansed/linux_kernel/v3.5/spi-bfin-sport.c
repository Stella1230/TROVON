static void\r\nbfin_sport_spi_enable(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nbfin_write_or(&drv_data->regs->tcr1, TSPEN);\r\nbfin_write_or(&drv_data->regs->rcr1, TSPEN);\r\nSSYNC();\r\n}\r\nstatic void\r\nbfin_sport_spi_disable(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nbfin_write_and(&drv_data->regs->tcr1, ~TSPEN);\r\nbfin_write_and(&drv_data->regs->rcr1, ~TSPEN);\r\nSSYNC();\r\n}\r\nstatic u16\r\nbfin_sport_hz_to_spi_baud(u32 speed_hz)\r\n{\r\nu_long clk, sclk = get_sclk();\r\nint div = (sclk / (2 * speed_hz)) - 1;\r\nif (div < 0)\r\ndiv = 0;\r\nclk = sclk / (2 * (div + 1));\r\nif (clk > speed_hz)\r\ndiv++;\r\nreturn div;\r\n}\r\nstatic void\r\nbfin_sport_spi_cs_active(struct bfin_sport_spi_slave_data *chip)\r\n{\r\ngpio_direction_output(chip->cs_gpio, 0);\r\n}\r\nstatic void\r\nbfin_sport_spi_cs_deactive(struct bfin_sport_spi_slave_data *chip)\r\n{\r\ngpio_direction_output(chip->cs_gpio, 1);\r\nif (chip->cs_chg_udelay)\r\nudelay(chip->cs_chg_udelay);\r\n}\r\nstatic void\r\nbfin_sport_spi_stat_poll_complete(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nwhile (!(bfin_read(&drv_data->regs->stat) & RXNE)) {\r\nif (!time_before(jiffies, timeout))\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_u8_writer(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nu16 dummy;\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tx16, *drv_data->tx8++);\r\nbfin_sport_spi_stat_poll_complete(drv_data);\r\ndummy = bfin_read(&drv_data->regs->rx16);\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_u8_reader(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nu16 tx_val = drv_data->cur_chip->idle_tx_val;\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tx16, tx_val);\r\nbfin_sport_spi_stat_poll_complete(drv_data);\r\n*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_u8_duplex(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tx16, *drv_data->tx8++);\r\nbfin_sport_spi_stat_poll_complete(drv_data);\r\n*drv_data->rx8++ = bfin_read(&drv_data->regs->rx16);\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_u16_writer(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nu16 dummy;\r\nwhile (drv_data->tx < drv_data->tx_end) {\r\nbfin_write(&drv_data->regs->tx16, *drv_data->tx16++);\r\nbfin_sport_spi_stat_poll_complete(drv_data);\r\ndummy = bfin_read(&drv_data->regs->rx16);\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_u16_reader(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nu16 tx_val = drv_data->cur_chip->idle_tx_val;\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tx16, tx_val);\r\nbfin_sport_spi_stat_poll_complete(drv_data);\r\n*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_u16_duplex(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nwhile (drv_data->rx < drv_data->rx_end) {\r\nbfin_write(&drv_data->regs->tx16, *drv_data->tx16++);\r\nbfin_sport_spi_stat_poll_complete(drv_data);\r\n*drv_data->rx16++ = bfin_read(&drv_data->regs->rx16);\r\n}\r\n}\r\nstatic void\r\nbfin_sport_spi_restore_state(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nstruct bfin_sport_spi_slave_data *chip = drv_data->cur_chip;\r\nbfin_sport_spi_disable(drv_data);\r\ndev_dbg(drv_data->dev, "restoring spi ctl state\n");\r\nbfin_write(&drv_data->regs->tcr1, chip->ctl_reg);\r\nbfin_write(&drv_data->regs->tclkdiv, chip->baud);\r\nSSYNC();\r\nbfin_write(&drv_data->regs->rcr1, chip->ctl_reg & ~(ITCLK | ITFS));\r\nSSYNC();\r\nbfin_sport_spi_cs_active(chip);\r\n}\r\nstatic enum bfin_sport_spi_state\r\nbfin_sport_spi_next_transfer(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->cur_msg;\r\nstruct spi_transfer *trans = drv_data->cur_transfer;\r\nif (trans->transfer_list.next != &msg->transfers) {\r\ndrv_data->cur_transfer =\r\nlist_entry(trans->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\nreturn RUNNING_STATE;\r\n}\r\nreturn DONE_STATE;\r\n}\r\nstatic void\r\nbfin_sport_spi_giveback(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nstruct bfin_sport_spi_slave_data *chip = drv_data->cur_chip;\r\nunsigned long flags;\r\nstruct spi_message *msg;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nmsg = drv_data->cur_msg;\r\ndrv_data->state = START_STATE;\r\ndrv_data->cur_msg = NULL;\r\ndrv_data->cur_transfer = NULL;\r\ndrv_data->cur_chip = NULL;\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nif (!drv_data->cs_change)\r\nbfin_sport_spi_cs_deactive(chip);\r\nif (msg->complete)\r\nmsg->complete(msg->context);\r\n}\r\nstatic irqreturn_t\r\nsport_err_handler(int irq, void *dev_id)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data = dev_id;\r\nu16 status;\r\ndev_dbg(drv_data->dev, "%s enter\n", __func__);\r\nstatus = bfin_read(&drv_data->regs->stat) & (TOVF | TUVF | ROVF | RUVF);\r\nif (status) {\r\nbfin_write(&drv_data->regs->stat, status);\r\nSSYNC();\r\nbfin_sport_spi_disable(drv_data);\r\ndev_err(drv_data->dev, "status error:%s%s%s%s\n",\r\nstatus & TOVF ? " TOVF" : "",\r\nstatus & TUVF ? " TUVF" : "",\r\nstatus & ROVF ? " ROVF" : "",\r\nstatus & RUVF ? " RUVF" : "");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nbfin_sport_spi_pump_transfers(unsigned long data)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data = (void *)data;\r\nstruct spi_message *message = NULL;\r\nstruct spi_transfer *transfer = NULL;\r\nstruct spi_transfer *previous = NULL;\r\nstruct bfin_sport_spi_slave_data *chip = NULL;\r\nunsigned int bits_per_word;\r\nu32 tranf_success = 1;\r\nu32 transfer_speed;\r\nu8 full_duplex = 0;\r\nmessage = drv_data->cur_msg;\r\ntransfer = drv_data->cur_transfer;\r\nchip = drv_data->cur_chip;\r\nif (transfer->speed_hz)\r\ntransfer_speed = bfin_sport_hz_to_spi_baud(transfer->speed_hz);\r\nelse\r\ntransfer_speed = chip->baud;\r\nbfin_write(&drv_data->regs->tclkdiv, transfer_speed);\r\nSSYNC();\r\nif (drv_data->state == ERROR_STATE) {\r\ndev_dbg(drv_data->dev, "transfer: we've hit an error\n");\r\nmessage->status = -EIO;\r\nbfin_sport_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif (drv_data->state == DONE_STATE) {\r\ndev_dbg(drv_data->dev, "transfer: all done!\n");\r\nmessage->status = 0;\r\nbfin_sport_spi_giveback(drv_data);\r\nreturn;\r\n}\r\nif (drv_data->state == RUNNING_STATE) {\r\ndev_dbg(drv_data->dev, "transfer: still running ...\n");\r\nprevious = list_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer, transfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\n}\r\nif (transfer->len == 0) {\r\ndrv_data->state = bfin_sport_spi_next_transfer(drv_data);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nif (transfer->tx_buf != NULL) {\r\ndrv_data->tx = (void *)transfer->tx_buf;\r\ndrv_data->tx_end = drv_data->tx + transfer->len;\r\ndev_dbg(drv_data->dev, "tx_buf is %p, tx_end is %p\n",\r\ntransfer->tx_buf, drv_data->tx_end);\r\n} else\r\ndrv_data->tx = NULL;\r\nif (transfer->rx_buf != NULL) {\r\nfull_duplex = transfer->tx_buf != NULL;\r\ndrv_data->rx = transfer->rx_buf;\r\ndrv_data->rx_end = drv_data->rx + transfer->len;\r\ndev_dbg(drv_data->dev, "rx_buf is %p, rx_end is %p\n",\r\ntransfer->rx_buf, drv_data->rx_end);\r\n} else\r\ndrv_data->rx = NULL;\r\ndrv_data->cs_change = transfer->cs_change;\r\nbits_per_word = transfer->bits_per_word ? :\r\nmessage->spi->bits_per_word ? : 8;\r\nif (bits_per_word % 16 == 0)\r\ndrv_data->ops = &bfin_sport_transfer_ops_u16;\r\nelse\r\ndrv_data->ops = &bfin_sport_transfer_ops_u8;\r\nbfin_write(&drv_data->regs->tcr2, bits_per_word - 1);\r\nbfin_write(&drv_data->regs->tfsdiv, bits_per_word - 1);\r\nbfin_write(&drv_data->regs->rcr2, bits_per_word - 1);\r\ndrv_data->state = RUNNING_STATE;\r\nif (drv_data->cs_change)\r\nbfin_sport_spi_cs_active(chip);\r\ndev_dbg(drv_data->dev,\r\n"now pumping a transfer: width is %d, len is %d\n",\r\nbits_per_word, transfer->len);\r\ndev_dbg(drv_data->dev, "doing IO transfer\n");\r\nbfin_sport_spi_enable(drv_data);\r\nif (full_duplex) {\r\nBUG_ON((drv_data->tx_end - drv_data->tx) !=\r\n(drv_data->rx_end - drv_data->rx));\r\ndrv_data->ops->duplex(drv_data);\r\nif (drv_data->tx != drv_data->tx_end)\r\ntranf_success = 0;\r\n} else if (drv_data->tx != NULL) {\r\ndrv_data->ops->write(drv_data);\r\nif (drv_data->tx != drv_data->tx_end)\r\ntranf_success = 0;\r\n} else if (drv_data->rx != NULL) {\r\ndrv_data->ops->read(drv_data);\r\nif (drv_data->rx != drv_data->rx_end)\r\ntranf_success = 0;\r\n}\r\nbfin_sport_spi_disable(drv_data);\r\nif (!tranf_success) {\r\ndev_dbg(drv_data->dev, "IO write error!\n");\r\ndrv_data->state = ERROR_STATE;\r\n} else {\r\nmessage->actual_length += transfer->len;\r\ndrv_data->state = bfin_sport_spi_next_transfer(drv_data);\r\nif (drv_data->cs_change)\r\nbfin_sport_spi_cs_deactive(chip);\r\n}\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void\r\nbfin_sport_spi_pump_messages(struct work_struct *work)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data;\r\nunsigned long flags;\r\nstruct spi_message *next_msg;\r\ndrv_data = container_of(work, struct bfin_sport_spi_master_data, pump_messages);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (list_empty(&drv_data->queue) || !drv_data->run) {\r\ndrv_data->busy = 0;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn;\r\n}\r\nif (drv_data->cur_msg) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn;\r\n}\r\nnext_msg = list_entry(drv_data->queue.next,\r\nstruct spi_message, queue);\r\ndrv_data->cur_msg = next_msg;\r\ndrv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);\r\nlist_del_init(&drv_data->cur_msg->queue);\r\ndrv_data->cur_msg->state = START_STATE;\r\ndrv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\nbfin_sport_spi_restore_state(drv_data);\r\ndev_dbg(drv_data->dev, "got a message to pump, "\r\n"state is set to: baud %d, cs_gpio %i, ctl 0x%x\n",\r\ndrv_data->cur_chip->baud, drv_data->cur_chip->cs_gpio,\r\ndrv_data->cur_chip->ctl_reg);\r\ndev_dbg(drv_data->dev,\r\n"the first transfer len is %d\n",\r\ndrv_data->cur_transfer->len);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\ndrv_data->busy = 1;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\n}\r\nstatic int\r\nbfin_sport_spi_transfer(struct spi_device *spi, struct spi_message *msg)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (!drv_data->run) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nmsg->actual_length = 0;\r\nmsg->status = -EINPROGRESS;\r\nmsg->state = START_STATE;\r\ndev_dbg(&spi->dev, "adding an msg in transfer()\n");\r\nlist_add_tail(&msg->queue, &drv_data->queue);\r\nif (drv_data->run && !drv_data->busy)\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nbfin_sport_spi_setup(struct spi_device *spi)\r\n{\r\nstruct bfin_sport_spi_slave_data *chip, *first = NULL;\r\nint ret;\r\nchip = spi_get_ctldata(spi);\r\nif (chip == NULL) {\r\nstruct bfin5xx_spi_chip *chip_info;\r\nchip = first = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip_info = spi->controller_data;\r\nif (chip_info) {\r\nif (chip_info->ctl_reg || chip_info->enable_dma) {\r\nret = -EINVAL;\r\ndev_err(&spi->dev, "don't set ctl_reg/enable_dma fields");\r\ngoto error;\r\n}\r\nchip->cs_chg_udelay = chip_info->cs_chg_udelay;\r\nchip->idle_tx_val = chip_info->idle_tx_val;\r\n}\r\n}\r\nif (spi->bits_per_word % 8) {\r\ndev_err(&spi->dev, "%d bits_per_word is not supported\n",\r\nspi->bits_per_word);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (spi->mode & SPI_CPHA)\r\nchip->ctl_reg &= ~TCKFE;\r\nelse\r\nchip->ctl_reg |= TCKFE;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nchip->ctl_reg |= TLSBIT;\r\nelse\r\nchip->ctl_reg &= ~TLSBIT;\r\nchip->ctl_reg |= ITCLK | ITFS | TFSR | LATFS | LTFS;\r\nchip->baud = bfin_sport_hz_to_spi_baud(spi->max_speed_hz);\r\nchip->cs_gpio = spi->chip_select;\r\nret = gpio_request(chip->cs_gpio, spi->modalias);\r\nif (ret)\r\ngoto error;\r\ndev_dbg(&spi->dev, "setup spi chip %s, width is %d\n",\r\nspi->modalias, spi->bits_per_word);\r\ndev_dbg(&spi->dev, "ctl_reg is 0x%x, GPIO is %i\n",\r\nchip->ctl_reg, spi->chip_select);\r\nspi_set_ctldata(spi, chip);\r\nbfin_sport_spi_cs_deactive(chip);\r\nreturn ret;\r\nerror:\r\nkfree(first);\r\nreturn ret;\r\n}\r\nstatic void\r\nbfin_sport_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct bfin_sport_spi_slave_data *chip = spi_get_ctldata(spi);\r\nif (!chip)\r\nreturn;\r\ngpio_free(chip->cs_gpio);\r\nkfree(chip);\r\n}\r\nstatic int\r\nbfin_sport_spi_init_queue(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nINIT_LIST_HEAD(&drv_data->queue);\r\nspin_lock_init(&drv_data->lock);\r\ndrv_data->run = false;\r\ndrv_data->busy = 0;\r\ntasklet_init(&drv_data->pump_transfers,\r\nbfin_sport_spi_pump_transfers, (unsigned long)drv_data);\r\nINIT_WORK(&drv_data->pump_messages, bfin_sport_spi_pump_messages);\r\ndrv_data->workqueue =\r\ncreate_singlethread_workqueue(dev_name(drv_data->master->dev.parent));\r\nif (drv_data->workqueue == NULL)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int\r\nbfin_sport_spi_start_queue(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (drv_data->run || drv_data->busy) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndrv_data->run = true;\r\ndrv_data->cur_msg = NULL;\r\ndrv_data->cur_transfer = NULL;\r\ndrv_data->cur_chip = NULL;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nqueue_work(drv_data->workqueue, &drv_data->pump_messages);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nbfin_sport_spi_stop_queue(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nunsigned long flags;\r\nunsigned limit = 500;\r\nint status = 0;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\ndrv_data->run = false;\r\nwhile (!list_empty(&drv_data->queue) && drv_data->busy && limit--) {\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\n}\r\nif (!list_empty(&drv_data->queue) || drv_data->busy)\r\nstatus = -EBUSY;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn status;\r\n}\r\nstatic inline int\r\nbfin_sport_spi_destroy_queue(struct bfin_sport_spi_master_data *drv_data)\r\n{\r\nint status;\r\nstatus = bfin_sport_spi_stop_queue(drv_data);\r\nif (status)\r\nreturn status;\r\ndestroy_workqueue(drv_data->workqueue);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nbfin_sport_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bfin5xx_spi_master *platform_info;\r\nstruct spi_master *master;\r\nstruct resource *res, *ires;\r\nstruct bfin_sport_spi_master_data *drv_data;\r\nint status;\r\nplatform_info = dev->platform_data;\r\nmaster = spi_alloc_master(dev, sizeof(*master) + 16);\r\nif (!master) {\r\ndev_err(dev, "cannot alloc spi_master\n");\r\nreturn -ENOMEM;\r\n}\r\ndrv_data = spi_master_get_devdata(master);\r\ndrv_data->master = master;\r\ndrv_data->dev = dev;\r\ndrv_data->pin_req = platform_info->pin_req;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LSB_FIRST;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = platform_info->num_chipselect;\r\nmaster->cleanup = bfin_sport_spi_cleanup;\r\nmaster->setup = bfin_sport_spi_setup;\r\nmaster->transfer = bfin_sport_spi_transfer;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "cannot get IORESOURCE_MEM\n");\r\nstatus = -ENOENT;\r\ngoto out_error_get_res;\r\n}\r\ndrv_data->regs = ioremap(res->start, resource_size(res));\r\nif (drv_data->regs == NULL) {\r\ndev_err(dev, "cannot map registers\n");\r\nstatus = -ENXIO;\r\ngoto out_error_ioremap;\r\n}\r\nires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!ires) {\r\ndev_err(dev, "cannot get IORESOURCE_IRQ\n");\r\nstatus = -ENODEV;\r\ngoto out_error_get_ires;\r\n}\r\ndrv_data->err_irq = ires->start;\r\nstatus = bfin_sport_spi_init_queue(drv_data);\r\nif (status) {\r\ndev_err(dev, "problem initializing queue\n");\r\ngoto out_error_queue_alloc;\r\n}\r\nstatus = bfin_sport_spi_start_queue(drv_data);\r\nif (status) {\r\ndev_err(dev, "problem starting queue\n");\r\ngoto out_error_queue_alloc;\r\n}\r\nstatus = request_irq(drv_data->err_irq, sport_err_handler,\r\n0, "sport_spi_err", drv_data);\r\nif (status) {\r\ndev_err(dev, "unable to request sport err irq\n");\r\ngoto out_error_irq;\r\n}\r\nstatus = peripheral_request_list(drv_data->pin_req, DRV_NAME);\r\nif (status) {\r\ndev_err(dev, "requesting peripherals failed\n");\r\ngoto out_error_peripheral;\r\n}\r\nplatform_set_drvdata(pdev, drv_data);\r\nstatus = spi_register_master(master);\r\nif (status) {\r\ndev_err(dev, "problem registering spi master\n");\r\ngoto out_error_master;\r\n}\r\ndev_info(dev, "%s, regs_base@%p\n", DRV_DESC, drv_data->regs);\r\nreturn 0;\r\nout_error_master:\r\nperipheral_free_list(drv_data->pin_req);\r\nout_error_peripheral:\r\nfree_irq(drv_data->err_irq, drv_data);\r\nout_error_irq:\r\nout_error_queue_alloc:\r\nbfin_sport_spi_destroy_queue(drv_data);\r\nout_error_get_ires:\r\niounmap(drv_data->regs);\r\nout_error_ioremap:\r\nout_error_get_res:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int __devexit\r\nbfin_sport_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data = platform_get_drvdata(pdev);\r\nint status = 0;\r\nif (!drv_data)\r\nreturn 0;\r\nstatus = bfin_sport_spi_destroy_queue(drv_data);\r\nif (status)\r\nreturn status;\r\nbfin_sport_spi_disable(drv_data);\r\nspi_unregister_master(drv_data->master);\r\nperipheral_free_list(drv_data->pin_req);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int\r\nbfin_sport_spi_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data = platform_get_drvdata(pdev);\r\nint status;\r\nstatus = bfin_sport_spi_stop_queue(drv_data);\r\nif (status)\r\nreturn status;\r\nbfin_sport_spi_disable(drv_data);\r\nreturn status;\r\n}\r\nstatic int\r\nbfin_sport_spi_resume(struct platform_device *pdev)\r\n{\r\nstruct bfin_sport_spi_master_data *drv_data = platform_get_drvdata(pdev);\r\nint status;\r\nbfin_sport_spi_enable(drv_data);\r\nstatus = bfin_sport_spi_start_queue(drv_data);\r\nif (status)\r\ndev_err(drv_data->dev, "problem resuming queue\n");\r\nreturn status;\r\n}
