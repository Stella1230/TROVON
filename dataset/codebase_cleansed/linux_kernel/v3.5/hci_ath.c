static int ath_wakeup_ar3k(struct tty_struct *tty)\r\n{\r\nstruct ktermios ktermios;\r\nint status = tty->driver->ops->tiocmget(tty);\r\nif (status & TIOCM_CTS)\r\nreturn status;\r\nmemcpy(&ktermios, tty->termios, sizeof(ktermios));\r\nktermios.c_cflag &= ~CRTSCTS;\r\ntty_set_termios(tty, &ktermios);\r\nstatus = tty->driver->ops->tiocmget(tty);\r\ntty->driver->ops->tiocmset(tty, 0x00, TIOCM_RTS);\r\nmdelay(20);\r\nstatus = tty->driver->ops->tiocmget(tty);\r\ntty->driver->ops->tiocmset(tty, TIOCM_RTS, 0x00);\r\nmdelay(20);\r\nstatus = tty->driver->ops->tiocmget(tty);\r\nktermios.c_cflag |= CRTSCTS;\r\nstatus = tty_set_termios(tty, &ktermios);\r\nreturn status;\r\n}\r\nstatic void ath_hci_uart_work(struct work_struct *work)\r\n{\r\nint status;\r\nstruct ath_struct *ath;\r\nstruct hci_uart *hu;\r\nstruct tty_struct *tty;\r\nath = container_of(work, struct ath_struct, ctxtsw);\r\nhu = ath->hu;\r\ntty = hu->tty;\r\nif (ath->cur_sleep) {\r\nstatus = ath_wakeup_ar3k(tty);\r\nif (!(status & TIOCM_CTS))\r\nreturn;\r\n}\r\nclear_bit(HCI_UART_SENDING, &hu->tx_state);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int ath_open(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath;\r\nBT_DBG("hu %p", hu);\r\nath = kzalloc(sizeof(*ath), GFP_KERNEL);\r\nif (!ath)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&ath->txq);\r\nhu->priv = ath;\r\nath->hu = hu;\r\nINIT_WORK(&ath->ctxtsw, ath_hci_uart_work);\r\nreturn 0;\r\n}\r\nstatic int ath_flush(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ath->txq);\r\nreturn 0;\r\n}\r\nstatic int ath_close(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ath->txq);\r\ncancel_work_sync(&ath->ctxtsw);\r\nhu->priv = NULL;\r\nkfree(ath);\r\nreturn 0;\r\n}\r\nstatic int ath_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nif (bt_cb(skb)->pkt_type == HCI_SCODATA_PKT) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {\r\nstruct hci_command_hdr *hdr = (void *)skb->data;\r\nif (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP)\r\nath->cur_sleep = skb->data[HCI_COMMAND_HDR_SIZE];\r\n}\r\nBT_DBG("hu %p skb %p", hu, skb);\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&ath->txq, skb);\r\nset_bit(HCI_UART_SENDING, &hu->tx_state);\r\nschedule_work(&ath->ctxtsw);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *ath_dequeue(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nreturn skb_dequeue(&ath->txq);\r\n}\r\nstatic int ath_recv(struct hci_uart *hu, void *data, int count)\r\n{\r\nint ret;\r\nret = hci_recv_stream_fragment(hu->hdev, data, count);\r\nif (ret < 0) {\r\nBT_ERR("Frame Reassembly Failed");\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nint __init ath_init(void)\r\n{\r\nint err = hci_uart_register_proto(&athp);\r\nif (!err)\r\nBT_INFO("HCIATH3K protocol initialized");\r\nelse\r\nBT_ERR("HCIATH3K protocol registration failed");\r\nreturn err;\r\n}\r\nint __exit ath_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&athp);\r\n}
