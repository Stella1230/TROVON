static int __devinit atl1e_validate_option(int *value, struct atl1e_option *opt, struct atl1e_adapter *adapter)\r\n{\r\nif (*value == OPTION_UNSET) {\r\n*value = opt->def;\r\nreturn 0;\r\n}\r\nswitch (opt->type) {\r\ncase enable_option:\r\nswitch (*value) {\r\ncase OPTION_ENABLED:\r\nnetdev_info(adapter->netdev,\r\n"%s Enabled\n", opt->name);\r\nreturn 0;\r\ncase OPTION_DISABLED:\r\nnetdev_info(adapter->netdev,\r\n"%s Disabled\n", opt->name);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase range_option:\r\nif (*value >= opt->arg.r.min && *value <= opt->arg.r.max) {\r\nnetdev_info(adapter->netdev, "%s set to %i\n",\r\nopt->name, *value);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase list_option:{\r\nint i;\r\nstruct atl1e_opt_list *ent;\r\nfor (i = 0; i < opt->arg.l.nr; i++) {\r\nent = &opt->arg.l.p[i];\r\nif (*value == ent->i) {\r\nif (ent->str[0] != '\0')\r\nnetdev_info(adapter->netdev,\r\n"%s\n", ent->str);\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nnetdev_info(adapter->netdev, "Invalid %s specified (%i) %s\n",\r\nopt->name, *value, opt->err);\r\n*value = opt->def;\r\nreturn -1;\r\n}\r\nvoid __devinit atl1e_check_options(struct atl1e_adapter *adapter)\r\n{\r\nint bd = adapter->bd_number;\r\nif (bd >= ATL1E_MAX_NIC) {\r\nnetdev_notice(adapter->netdev,\r\n"no configuration for board #%i\n", bd);\r\nnetdev_notice(adapter->netdev,\r\n"Using defaults for all values\n");\r\n}\r\n{\r\nstruct atl1e_option opt = {\r\n.type = range_option,\r\n.name = "Transmit Ddescription Count",\r\n.err = "using default of "\r\n__MODULE_STRING(ATL1E_DEFAULT_TX_DESC_CNT),\r\n.def = ATL1E_DEFAULT_TX_DESC_CNT,\r\n.arg = { .r = { .min = ATL1E_MIN_TX_DESC_CNT,\r\n.max = ATL1E_MAX_TX_DESC_CNT} }\r\n};\r\nint val;\r\nif (num_tx_desc_cnt > bd) {\r\nval = tx_desc_cnt[bd];\r\natl1e_validate_option(&val, &opt, adapter);\r\nadapter->tx_ring.count = (u16) val & 0xFFFC;\r\n} else\r\nadapter->tx_ring.count = (u16)opt.def;\r\n}\r\n{\r\nstruct atl1e_option opt = {\r\n.type = range_option,\r\n.name = "Memory size of rx buffer(KB)",\r\n.err = "using default of "\r\n__MODULE_STRING(ATL1E_DEFAULT_RX_MEM_SIZE),\r\n.def = ATL1E_DEFAULT_RX_MEM_SIZE,\r\n.arg = { .r = { .min = ATL1E_MIN_RX_MEM_SIZE,\r\n.max = ATL1E_MAX_RX_MEM_SIZE} }\r\n};\r\nint val;\r\nif (num_rx_mem_size > bd) {\r\nval = rx_mem_size[bd];\r\natl1e_validate_option(&val, &opt, adapter);\r\nadapter->rx_ring.page_size = (u32)val * 1024;\r\n} else {\r\nadapter->rx_ring.page_size = (u32)opt.def * 1024;\r\n}\r\n}\r\n{\r\nstruct atl1e_option opt = {\r\n.type = range_option,\r\n.name = "Interrupt Moderate Timer",\r\n.err = "using default of "\r\n__MODULE_STRING(INT_MOD_DEFAULT_CNT),\r\n.def = INT_MOD_DEFAULT_CNT,\r\n.arg = { .r = { .min = INT_MOD_MIN_CNT,\r\n.max = INT_MOD_MAX_CNT} }\r\n} ;\r\nint val;\r\nif (num_int_mod_timer > bd) {\r\nval = int_mod_timer[bd];\r\natl1e_validate_option(&val, &opt, adapter);\r\nadapter->hw.imt = (u16) val;\r\n} else\r\nadapter->hw.imt = (u16)(opt.def);\r\n}\r\n{\r\nstruct atl1e_option opt = {\r\n.type = range_option,\r\n.name = "Speed/Duplex Selection",\r\n.err = "using default of "\r\n__MODULE_STRING(MEDIA_TYPE_AUTO_SENSOR),\r\n.def = MEDIA_TYPE_AUTO_SENSOR,\r\n.arg = { .r = { .min = MEDIA_TYPE_AUTO_SENSOR,\r\n.max = MEDIA_TYPE_10M_HALF} }\r\n} ;\r\nint val;\r\nif (num_media_type > bd) {\r\nval = media_type[bd];\r\natl1e_validate_option(&val, &opt, adapter);\r\nadapter->hw.media_type = (u16) val;\r\n} else\r\nadapter->hw.media_type = (u16)(opt.def);\r\n}\r\n}
