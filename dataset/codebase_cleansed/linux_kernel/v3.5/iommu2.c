static void __iommu_set_twl(struct omap_iommu *obj, bool on)\r\n{\r\nu32 l = iommu_read_reg(obj, MMU_CNTL);\r\nif (on)\r\niommu_write_reg(obj, MMU_IRQ_TWL_MASK, MMU_IRQENABLE);\r\nelse\r\niommu_write_reg(obj, MMU_IRQ_TLB_MISS_MASK, MMU_IRQENABLE);\r\nl &= ~MMU_CNTL_MASK;\r\nif (on)\r\nl |= (MMU_CNTL_MMU_EN | MMU_CNTL_TWL_EN);\r\nelse\r\nl |= (MMU_CNTL_MMU_EN);\r\niommu_write_reg(obj, l, MMU_CNTL);\r\n}\r\nstatic int omap2_iommu_enable(struct omap_iommu *obj)\r\n{\r\nu32 l, pa;\r\nunsigned long timeout;\r\nif (!obj->iopgd || !IS_ALIGNED((u32)obj->iopgd, SZ_16K))\r\nreturn -EINVAL;\r\npa = virt_to_phys(obj->iopgd);\r\nif (!IS_ALIGNED(pa, SZ_16K))\r\nreturn -EINVAL;\r\niommu_write_reg(obj, MMU_SYS_SOFTRESET, MMU_SYSCONFIG);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\ndo {\r\nl = iommu_read_reg(obj, MMU_SYSSTATUS);\r\nif (l & MMU_SYS_RESETDONE)\r\nbreak;\r\n} while (!time_after(jiffies, timeout));\r\nif (!(l & MMU_SYS_RESETDONE)) {\r\ndev_err(obj->dev, "can't take mmu out of reset\n");\r\nreturn -ENODEV;\r\n}\r\nl = iommu_read_reg(obj, MMU_REVISION);\r\ndev_info(obj->dev, "%s: version %d.%d\n", obj->name,\r\n(l >> 4) & 0xf, l & 0xf);\r\nl = iommu_read_reg(obj, MMU_SYSCONFIG);\r\nl &= ~MMU_SYS_IDLE_MASK;\r\nl |= (MMU_SYS_IDLE_SMART | MMU_SYS_AUTOIDLE);\r\niommu_write_reg(obj, l, MMU_SYSCONFIG);\r\niommu_write_reg(obj, pa, MMU_TTB);\r\n__iommu_set_twl(obj, true);\r\nreturn 0;\r\n}\r\nstatic void omap2_iommu_disable(struct omap_iommu *obj)\r\n{\r\nu32 l = iommu_read_reg(obj, MMU_CNTL);\r\nl &= ~MMU_CNTL_MASK;\r\niommu_write_reg(obj, l, MMU_CNTL);\r\niommu_write_reg(obj, MMU_SYS_IDLE_FORCE, MMU_SYSCONFIG);\r\ndev_dbg(obj->dev, "%s is shutting down\n", obj->name);\r\n}\r\nstatic void omap2_iommu_set_twl(struct omap_iommu *obj, bool on)\r\n{\r\n__iommu_set_twl(obj, false);\r\n}\r\nstatic u32 omap2_iommu_fault_isr(struct omap_iommu *obj, u32 *ra)\r\n{\r\nu32 stat, da;\r\nu32 errs = 0;\r\nstat = iommu_read_reg(obj, MMU_IRQSTATUS);\r\nstat &= MMU_IRQ_MASK;\r\nif (!stat) {\r\n*ra = 0;\r\nreturn 0;\r\n}\r\nda = iommu_read_reg(obj, MMU_FAULT_AD);\r\n*ra = da;\r\nif (stat & MMU_IRQ_TLBMISS)\r\nerrs |= OMAP_IOMMU_ERR_TLB_MISS;\r\nif (stat & MMU_IRQ_TRANSLATIONFAULT)\r\nerrs |= OMAP_IOMMU_ERR_TRANS_FAULT;\r\nif (stat & MMU_IRQ_EMUMISS)\r\nerrs |= OMAP_IOMMU_ERR_EMU_MISS;\r\nif (stat & MMU_IRQ_TABLEWALKFAULT)\r\nerrs |= OMAP_IOMMU_ERR_TBLWALK_FAULT;\r\nif (stat & MMU_IRQ_MULTIHITFAULT)\r\nerrs |= OMAP_IOMMU_ERR_MULTIHIT_FAULT;\r\niommu_write_reg(obj, stat, MMU_IRQSTATUS);\r\nreturn errs;\r\n}\r\nstatic void omap2_tlb_read_cr(struct omap_iommu *obj, struct cr_regs *cr)\r\n{\r\ncr->cam = iommu_read_reg(obj, MMU_READ_CAM);\r\ncr->ram = iommu_read_reg(obj, MMU_READ_RAM);\r\n}\r\nstatic void omap2_tlb_load_cr(struct omap_iommu *obj, struct cr_regs *cr)\r\n{\r\niommu_write_reg(obj, cr->cam | MMU_CAM_V, MMU_CAM);\r\niommu_write_reg(obj, cr->ram, MMU_RAM);\r\n}\r\nstatic u32 omap2_cr_to_virt(struct cr_regs *cr)\r\n{\r\nu32 page_size = cr->cam & MMU_CAM_PGSZ_MASK;\r\nu32 mask = get_cam_va_mask(cr->cam & page_size);\r\nreturn cr->cam & mask;\r\n}\r\nstatic struct cr_regs *omap2_alloc_cr(struct omap_iommu *obj,\r\nstruct iotlb_entry *e)\r\n{\r\nstruct cr_regs *cr;\r\nif (e->da & ~(get_cam_va_mask(e->pgsz))) {\r\ndev_err(obj->dev, "%s:\twrong alignment: %08x\n", __func__,\r\ne->da);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ncr = kmalloc(sizeof(*cr), GFP_KERNEL);\r\nif (!cr)\r\nreturn ERR_PTR(-ENOMEM);\r\ncr->cam = (e->da & MMU_CAM_VATAG_MASK) | e->prsvd | e->pgsz | e->valid;\r\ncr->ram = e->pa | e->endian | e->elsz | e->mixed;\r\nreturn cr;\r\n}\r\nstatic inline int omap2_cr_valid(struct cr_regs *cr)\r\n{\r\nreturn cr->cam & MMU_CAM_V;\r\n}\r\nstatic u32 omap2_get_pte_attr(struct iotlb_entry *e)\r\n{\r\nu32 attr;\r\nattr = e->mixed << 5;\r\nattr |= e->endian;\r\nattr |= e->elsz >> 3;\r\nattr <<= (((e->pgsz == MMU_CAM_PGSZ_4K) ||\r\n(e->pgsz == MMU_CAM_PGSZ_64K)) ? 0 : 6);\r\nreturn attr;\r\n}\r\nstatic ssize_t\r\nomap2_dump_cr(struct omap_iommu *obj, struct cr_regs *cr, char *buf)\r\n{\r\nchar *p = buf;\r\np += sprintf(p, "%08x %08x %01x\n", cr->cam, cr->ram,\r\n(cr->cam & MMU_CAM_P) ? 1 : 0);\r\nreturn p - buf;\r\n}\r\nstatic ssize_t\r\nomap2_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len)\r\n{\r\nchar *p = buf;\r\npr_reg(REVISION);\r\npr_reg(SYSCONFIG);\r\npr_reg(SYSSTATUS);\r\npr_reg(IRQSTATUS);\r\npr_reg(IRQENABLE);\r\npr_reg(WALKING_ST);\r\npr_reg(CNTL);\r\npr_reg(FAULT_AD);\r\npr_reg(TTB);\r\npr_reg(LOCK);\r\npr_reg(LD_TLB);\r\npr_reg(CAM);\r\npr_reg(RAM);\r\npr_reg(GFLUSH);\r\npr_reg(FLUSH_ENTRY);\r\npr_reg(READ_CAM);\r\npr_reg(READ_RAM);\r\npr_reg(EMU_FAULT_AD);\r\nout:\r\nreturn p - buf;\r\n}\r\nstatic void omap2_iommu_save_ctx(struct omap_iommu *obj)\r\n{\r\nint i;\r\nu32 *p = obj->ctx;\r\nfor (i = 0; i < (MMU_REG_SIZE / sizeof(u32)); i++) {\r\np[i] = iommu_read_reg(obj, i * sizeof(u32));\r\ndev_dbg(obj->dev, "%s\t[%02d] %08x\n", __func__, i, p[i]);\r\n}\r\nBUG_ON(p[0] != IOMMU_ARCH_VERSION);\r\n}\r\nstatic void omap2_iommu_restore_ctx(struct omap_iommu *obj)\r\n{\r\nint i;\r\nu32 *p = obj->ctx;\r\nfor (i = 0; i < (MMU_REG_SIZE / sizeof(u32)); i++) {\r\niommu_write_reg(obj, p[i], i * sizeof(u32));\r\ndev_dbg(obj->dev, "%s\t[%02d] %08x\n", __func__, i, p[i]);\r\n}\r\nBUG_ON(p[0] != IOMMU_ARCH_VERSION);\r\n}\r\nstatic void omap2_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e)\r\n{\r\ne->da = cr->cam & MMU_CAM_VATAG_MASK;\r\ne->pa = cr->ram & MMU_RAM_PADDR_MASK;\r\ne->valid = cr->cam & MMU_CAM_V;\r\ne->pgsz = cr->cam & MMU_CAM_PGSZ_MASK;\r\ne->endian = cr->ram & MMU_RAM_ENDIAN_MASK;\r\ne->elsz = cr->ram & MMU_RAM_ELSZ_MASK;\r\ne->mixed = cr->ram & MMU_RAM_MIXED;\r\n}\r\nstatic int __init omap2_iommu_init(void)\r\n{\r\nreturn omap_install_iommu_arch(&omap2_iommu_ops);\r\n}\r\nstatic void __exit omap2_iommu_exit(void)\r\n{\r\nomap_uninstall_iommu_arch(&omap2_iommu_ops);\r\n}
