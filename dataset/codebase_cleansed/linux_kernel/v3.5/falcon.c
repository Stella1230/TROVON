static void falcon_setsda(void *data, int state)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO3_OEN, !state);\r\nefx_writeo(efx, &reg, FR_AB_GPIO_CTL);\r\n}\r\nstatic void falcon_setscl(void *data, int state)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO0_OEN, !state);\r\nefx_writeo(efx, &reg, FR_AB_GPIO_CTL);\r\n}\r\nstatic int falcon_getsda(void *data)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nreturn EFX_OWORD_FIELD(reg, FRF_AB_GPIO3_IN);\r\n}\r\nstatic int falcon_getscl(void *data)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nreturn EFX_OWORD_FIELD(reg, FRF_AB_GPIO0_IN);\r\n}\r\nstatic void falcon_push_irq_moderation(struct efx_channel *channel)\r\n{\r\nefx_dword_t timer_cmd;\r\nstruct efx_nic *efx = channel->efx;\r\nif (channel->irq_moderation) {\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_AB_TC_TIMER_MODE,\r\nFFE_BB_TIMER_MODE_INT_HLDOFF,\r\nFRF_AB_TC_TIMER_VAL,\r\nchannel->irq_moderation - 1);\r\n} else {\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_AB_TC_TIMER_MODE,\r\nFFE_BB_TIMER_MODE_DIS,\r\nFRF_AB_TC_TIMER_VAL, 0);\r\n}\r\nBUILD_BUG_ON(FR_AA_TIMER_COMMAND_KER != FR_BZ_TIMER_COMMAND_P0);\r\nefx_writed_page_locked(efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,\r\nchannel->channel);\r\n}\r\nstatic void falcon_prepare_flush(struct efx_nic *efx)\r\n{\r\nfalcon_deconfigure_mac_wrapper(efx);\r\nmsleep(10);\r\n}\r\ninline void falcon_irq_ack_a1(struct efx_nic *efx)\r\n{\r\nefx_dword_t reg;\r\nEFX_POPULATE_DWORD_1(reg, FRF_AA_INT_ACK_KER_FIELD, 0xb7eb7e);\r\nefx_writed(efx, &reg, FR_AA_INT_ACK_KER);\r\nefx_readd(efx, &reg, FR_AA_WORK_AROUND_BROKEN_PCI_READS);\r\n}\r\nirqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)\r\n{\r\nstruct efx_nic *efx = dev_id;\r\nefx_oword_t *int_ker = efx->irq_status.addr;\r\nint syserr;\r\nint queues;\r\nif (unlikely(EFX_OWORD_IS_ZERO(*int_ker))) {\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d not for me\n", irq,\r\nraw_smp_processor_id());\r\nreturn IRQ_NONE;\r\n}\r\nefx->last_irq_cpu = raw_smp_processor_id();\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",\r\nirq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));\r\nsyserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);\r\nif (unlikely(syserr))\r\nreturn efx_nic_fatal_interrupt(efx);\r\nBUILD_BUG_ON(FSF_AZ_NET_IVEC_INT_Q_WIDTH > EFX_MAX_CHANNELS);\r\nqueues = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_INT_Q);\r\nEFX_ZERO_OWORD(*int_ker);\r\nwmb();\r\nfalcon_irq_ack_a1(efx);\r\nif (queues & 1)\r\nefx_schedule_channel_irq(efx_get_channel(efx, 0));\r\nif (queues & 2)\r\nefx_schedule_channel_irq(efx_get_channel(efx, 1));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int falcon_spi_poll(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_EE_SPI_HCMD);\r\nreturn EFX_OWORD_FIELD(reg, FRF_AB_EE_SPI_HCMD_CMD_EN) ? -EBUSY : 0;\r\n}\r\nstatic int falcon_spi_wait(struct efx_nic *efx)\r\n{\r\nunsigned long timeout = jiffies + 1 + DIV_ROUND_UP(HZ, 10);\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (!falcon_spi_poll(efx))\r\nreturn 0;\r\nudelay(10);\r\n}\r\nfor (;;) {\r\nif (!falcon_spi_poll(efx))\r\nreturn 0;\r\nif (time_after_eq(jiffies, timeout)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for SPI\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nint falcon_spi_cmd(struct efx_nic *efx, const struct efx_spi_device *spi,\r\nunsigned int command, int address,\r\nconst void *in, void *out, size_t len)\r\n{\r\nbool addressed = (address >= 0);\r\nbool reading = (out != NULL);\r\nefx_oword_t reg;\r\nint rc;\r\nif (len > FALCON_SPI_MAX_LEN)\r\nreturn -EINVAL;\r\nrc = falcon_spi_poll(efx);\r\nif (rc)\r\nreturn rc;\r\nif (addressed) {\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_EE_SPI_HADR_ADR, address);\r\nefx_writeo(efx, &reg, FR_AB_EE_SPI_HADR);\r\n}\r\nif (in != NULL) {\r\nmemcpy(&reg, in, len);\r\nefx_writeo(efx, &reg, FR_AB_EE_SPI_HDATA);\r\n}\r\nEFX_POPULATE_OWORD_7(reg,\r\nFRF_AB_EE_SPI_HCMD_CMD_EN, 1,\r\nFRF_AB_EE_SPI_HCMD_SF_SEL, spi->device_id,\r\nFRF_AB_EE_SPI_HCMD_DABCNT, len,\r\nFRF_AB_EE_SPI_HCMD_READ, reading,\r\nFRF_AB_EE_SPI_HCMD_DUBCNT, 0,\r\nFRF_AB_EE_SPI_HCMD_ADBCNT,\r\n(addressed ? spi->addr_len : 0),\r\nFRF_AB_EE_SPI_HCMD_ENC, command);\r\nefx_writeo(efx, &reg, FR_AB_EE_SPI_HCMD);\r\nrc = falcon_spi_wait(efx);\r\nif (rc)\r\nreturn rc;\r\nif (out != NULL) {\r\nefx_reado(efx, &reg, FR_AB_EE_SPI_HDATA);\r\nmemcpy(out, &reg, len);\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t\r\nfalcon_spi_write_limit(const struct efx_spi_device *spi, size_t start)\r\n{\r\nreturn min(FALCON_SPI_MAX_LEN,\r\n(spi->block_size - (start & (spi->block_size - 1))));\r\n}\r\nstatic inline u8\r\nefx_spi_munge_command(const struct efx_spi_device *spi,\r\nconst u8 command, const unsigned int address)\r\n{\r\nreturn command | (((address >> 8) & spi->munge_address) << 3);\r\n}\r\nint\r\nfalcon_spi_wait_write(struct efx_nic *efx, const struct efx_spi_device *spi)\r\n{\r\nunsigned long timeout = jiffies + 1 + DIV_ROUND_UP(HZ, 100);\r\nu8 status;\r\nint rc;\r\nfor (;;) {\r\nrc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,\r\n&status, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nif (!(status & SPI_STATUS_NRDY))\r\nreturn 0;\r\nif (time_after_eq(jiffies, timeout)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SPI write timeout on device %d"\r\n" last status=0x%02x\n",\r\nspi->device_id, status);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nint falcon_spi_read(struct efx_nic *efx, const struct efx_spi_device *spi,\r\nloff_t start, size_t len, size_t *retlen, u8 *buffer)\r\n{\r\nsize_t block_len, pos = 0;\r\nunsigned int command;\r\nint rc = 0;\r\nwhile (pos < len) {\r\nblock_len = min(len - pos, FALCON_SPI_MAX_LEN);\r\ncommand = efx_spi_munge_command(spi, SPI_READ, start + pos);\r\nrc = falcon_spi_cmd(efx, spi, command, start + pos, NULL,\r\nbuffer + pos, block_len);\r\nif (rc)\r\nbreak;\r\npos += block_len;\r\ncond_resched();\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\n}\r\nif (retlen)\r\n*retlen = pos;\r\nreturn rc;\r\n}\r\nint\r\nfalcon_spi_write(struct efx_nic *efx, const struct efx_spi_device *spi,\r\nloff_t start, size_t len, size_t *retlen, const u8 *buffer)\r\n{\r\nu8 verify_buffer[FALCON_SPI_MAX_LEN];\r\nsize_t block_len, pos = 0;\r\nunsigned int command;\r\nint rc = 0;\r\nwhile (pos < len) {\r\nrc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);\r\nif (rc)\r\nbreak;\r\nblock_len = min(len - pos,\r\nfalcon_spi_write_limit(spi, start + pos));\r\ncommand = efx_spi_munge_command(spi, SPI_WRITE, start + pos);\r\nrc = falcon_spi_cmd(efx, spi, command, start + pos,\r\nbuffer + pos, NULL, block_len);\r\nif (rc)\r\nbreak;\r\nrc = falcon_spi_wait_write(efx, spi);\r\nif (rc)\r\nbreak;\r\ncommand = efx_spi_munge_command(spi, SPI_READ, start + pos);\r\nrc = falcon_spi_cmd(efx, spi, command, start + pos,\r\nNULL, verify_buffer, block_len);\r\nif (memcmp(verify_buffer, buffer + pos, block_len)) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\npos += block_len;\r\ncond_resched();\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\n}\r\nif (retlen)\r\n*retlen = pos;\r\nreturn rc;\r\n}\r\nstatic void falcon_push_multicast_hash(struct efx_nic *efx)\r\n{\r\nunion efx_multicast_hash *mc_hash = &efx->multicast_hash;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nefx_writeo(efx, &mc_hash->oword[0], FR_AB_MAC_MC_HASH_REG0);\r\nefx_writeo(efx, &mc_hash->oword[1], FR_AB_MAC_MC_HASH_REG1);\r\n}\r\nstatic void falcon_reset_macs(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg, mac_ctrl;\r\nint count;\r\nif (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_XM_CORE_RST, 1);\r\nefx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);\r\nfor (count = 0; count < 10000; count++) {\r\nefx_reado(efx, &reg, FR_AB_XM_GLB_CFG);\r\nif (EFX_OWORD_FIELD(reg, FRF_AB_XM_CORE_RST) ==\r\n0)\r\nreturn;\r\nudelay(10);\r\n}\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for XMAC core reset\n");\r\n}\r\nWARN_ON(nic_data->stats_disable_count == 0);\r\nefx_reado(efx, &mac_ctrl, FR_AB_MAC_CTRL);\r\nEFX_SET_OWORD_FIELD(mac_ctrl, FRF_BB_TXFIFO_DRAIN_EN, 1);\r\nefx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);\r\nefx_reado(efx, &reg, FR_AB_GLB_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGTX, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGRX, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_RST_EM, 1);\r\nefx_writeo(efx, &reg, FR_AB_GLB_CTL);\r\ncount = 0;\r\nwhile (1) {\r\nefx_reado(efx, &reg, FR_AB_GLB_CTL);\r\nif (!EFX_OWORD_FIELD(reg, FRF_AB_RST_XGTX) &&\r\n!EFX_OWORD_FIELD(reg, FRF_AB_RST_XGRX) &&\r\n!EFX_OWORD_FIELD(reg, FRF_AB_RST_EM)) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"Completed MAC reset after %d loops\n",\r\ncount);\r\nbreak;\r\n}\r\nif (count > 20) {\r\nnetif_err(efx, hw, efx->net_dev, "MAC reset failed\n");\r\nbreak;\r\n}\r\ncount++;\r\nudelay(10);\r\n}\r\nefx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);\r\nfalcon_setup_xaui(efx);\r\n}\r\nvoid falcon_drain_tx_fifo(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nif ((efx_nic_rev(efx) < EFX_REV_FALCON_B0) ||\r\n(efx->loopback_mode != LOOPBACK_NONE))\r\nreturn;\r\nefx_reado(efx, &reg, FR_AB_MAC_CTRL);\r\nif (EFX_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN))\r\nreturn;\r\nfalcon_reset_macs(efx);\r\n}\r\nstatic void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nif (efx_nic_rev(efx) < EFX_REV_FALCON_B0)\r\nreturn;\r\nefx_reado(efx, &reg, FR_AZ_RX_CFG);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 0);\r\nefx_writeo(efx, &reg, FR_AZ_RX_CFG);\r\nfalcon_drain_tx_fifo(efx);\r\n}\r\nvoid falcon_reconfigure_mac_wrapper(struct efx_nic *efx)\r\n{\r\nstruct efx_link_state *link_state = &efx->link_state;\r\nefx_oword_t reg;\r\nint link_speed, isolate;\r\nisolate = !!ACCESS_ONCE(efx->reset_pending);\r\nswitch (link_state->speed) {\r\ncase 10000: link_speed = 3; break;\r\ncase 1000: link_speed = 2; break;\r\ncase 100: link_speed = 1; break;\r\ndefault: link_speed = 0; break;\r\n}\r\nEFX_POPULATE_OWORD_5(reg,\r\nFRF_AB_MAC_XOFF_VAL, 0xffff ,\r\nFRF_AB_MAC_BCAD_ACPT, 1,\r\nFRF_AB_MAC_UC_PROM, efx->promiscuous,\r\nFRF_AB_MAC_LINK_STATUS, 1,\r\nFRF_AB_MAC_SPEED, link_speed);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nEFX_SET_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN,\r\n!link_state->up || isolate);\r\n}\r\nefx_writeo(efx, &reg, FR_AB_MAC_CTRL);\r\nfalcon_push_multicast_hash(efx);\r\nefx_reado(efx, &reg, FR_AZ_RX_CFG);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, !isolate);\r\nefx_writeo(efx, &reg, FR_AZ_RX_CFG);\r\n}\r\nstatic void falcon_stats_request(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nWARN_ON(nic_data->stats_pending);\r\nWARN_ON(nic_data->stats_disable_count);\r\nif (nic_data->stats_dma_done == NULL)\r\nreturn;\r\n*nic_data->stats_dma_done = FALCON_STATS_NOT_DONE;\r\nnic_data->stats_pending = true;\r\nwmb();\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MAC_STAT_DMA_CMD, 1,\r\nFRF_AB_MAC_STAT_DMA_ADR,\r\nefx->stats_buffer.dma_addr);\r\nefx_writeo(efx, &reg, FR_AB_MAC_STAT_DMA);\r\nmod_timer(&nic_data->stats_timer, round_jiffies_up(jiffies + HZ / 2));\r\n}\r\nstatic void falcon_stats_complete(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nif (!nic_data->stats_pending)\r\nreturn;\r\nnic_data->stats_pending = false;\r\nif (*nic_data->stats_dma_done == FALCON_STATS_DONE) {\r\nrmb();\r\nfalcon_update_stats_xmac(efx);\r\n} else {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for statistics\n");\r\n}\r\n}\r\nstatic void falcon_stats_timer_func(unsigned long context)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)context;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nspin_lock(&efx->stats_lock);\r\nfalcon_stats_complete(efx);\r\nif (nic_data->stats_disable_count == 0)\r\nfalcon_stats_request(efx);\r\nspin_unlock(&efx->stats_lock);\r\n}\r\nstatic bool falcon_loopback_link_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_link_state old_state = efx->link_state;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nWARN_ON(!LOOPBACK_INTERNAL(efx));\r\nefx->link_state.fd = true;\r\nefx->link_state.fc = efx->wanted_fc;\r\nefx->link_state.up = true;\r\nefx->link_state.speed = 10000;\r\nreturn !efx_link_state_equal(&efx->link_state, &old_state);\r\n}\r\nstatic int falcon_reconfigure_port(struct efx_nic *efx)\r\n{\r\nint rc;\r\nWARN_ON(efx_nic_rev(efx) > EFX_REV_FALCON_B0);\r\nif (LOOPBACK_INTERNAL(efx))\r\nfalcon_loopback_link_poll(efx);\r\nelse\r\nefx->phy_op->poll(efx);\r\nfalcon_stop_nic_stats(efx);\r\nfalcon_deconfigure_mac_wrapper(efx);\r\nfalcon_reset_macs(efx);\r\nefx->phy_op->reconfigure(efx);\r\nrc = falcon_reconfigure_xmac(efx);\r\nBUG_ON(rc);\r\nfalcon_start_nic_stats(efx);\r\nefx_link_status_changed(efx);\r\nreturn 0;\r\n}\r\nstatic int falcon_gmii_wait(struct efx_nic *efx)\r\n{\r\nefx_oword_t md_stat;\r\nint count;\r\nfor (count = 0; count < 5000; count++) {\r\nefx_reado(efx, &md_stat, FR_AB_MD_STAT);\r\nif (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSY) == 0) {\r\nif (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_LNFL) != 0 ||\r\nEFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSERR) != 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"error from GMII access "\r\nEFX_OWORD_FMT"\n",\r\nEFX_OWORD_VAL(md_stat));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nudelay(10);\r\n}\r\nnetif_err(efx, hw, efx->net_dev, "timed out waiting for GMII\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int falcon_mdio_write(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr, u16 value)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nint rc;\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"writing MDIO %d register %d.%d with 0x%04x\n",\r\nprtad, devad, addr, value);\r\nmutex_lock(&nic_data->mdio_lock);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc)\r\ngoto out;\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);\r\nefx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);\r\nEFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,\r\nFRF_AB_MD_DEV_ADR, devad);\r\nefx_writeo(efx, &reg, FR_AB_MD_ID);\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_MD_TXD, value);\r\nefx_writeo(efx, &reg, FR_AB_MD_TXD);\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MD_WRC, 1,\r\nFRF_AB_MD_GC, 0);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc) {\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MD_WRC, 0,\r\nFRF_AB_MD_GC, 1);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nudelay(10);\r\n}\r\nout:\r\nmutex_unlock(&nic_data->mdio_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mdio_read(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nint rc;\r\nmutex_lock(&nic_data->mdio_lock);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc)\r\ngoto out;\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);\r\nefx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);\r\nEFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,\r\nFRF_AB_MD_DEV_ADR, devad);\r\nefx_writeo(efx, &reg, FR_AB_MD_ID);\r\nEFX_POPULATE_OWORD_2(reg, FRF_AB_MD_RDC, 1, FRF_AB_MD_GC, 0);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc == 0) {\r\nefx_reado(efx, &reg, FR_AB_MD_RXD);\r\nrc = EFX_OWORD_FIELD(reg, FRF_AB_MD_RXD);\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"read from MDIO %d register %d.%d, got %04x\n",\r\nprtad, devad, addr, rc);\r\n} else {\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MD_RIC, 0,\r\nFRF_AB_MD_GC, 1);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"read from MDIO %d register %d.%d, got error %d\n",\r\nprtad, devad, addr, rc);\r\n}\r\nout:\r\nmutex_unlock(&nic_data->mdio_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_probe_port(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nswitch (efx->phy_type) {\r\ncase PHY_TYPE_SFX7101:\r\nefx->phy_op = &falcon_sfx7101_phy_ops;\r\nbreak;\r\ncase PHY_TYPE_QT2022C2:\r\ncase PHY_TYPE_QT2025C:\r\nefx->phy_op = &falcon_qt202x_phy_ops;\r\nbreak;\r\ncase PHY_TYPE_TXC43128:\r\nefx->phy_op = &falcon_txc_phy_ops;\r\nbreak;\r\ndefault:\r\nnetif_err(efx, probe, efx->net_dev, "Unknown PHY type %d\n",\r\nefx->phy_type);\r\nreturn -ENODEV;\r\n}\r\nmutex_init(&nic_data->mdio_lock);\r\nefx->mdio.mdio_read = falcon_mdio_read;\r\nefx->mdio.mdio_write = falcon_mdio_write;\r\nrc = efx->phy_op->probe(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nefx->link_state.speed = 10000;\r\nefx->link_state.fd = true;\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nefx->wanted_fc = EFX_FC_RX | EFX_FC_TX;\r\nelse\r\nefx->wanted_fc = EFX_FC_RX;\r\nif (efx->mdio.mmds & MDIO_DEVS_AN)\r\nefx->wanted_fc |= EFX_FC_AUTO;\r\nrc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,\r\nFALCON_MAC_STATS_SIZE);\r\nif (rc)\r\nreturn rc;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"stats buffer at %llx (virt %p phys %llx)\n",\r\n(u64)efx->stats_buffer.dma_addr,\r\nefx->stats_buffer.addr,\r\n(u64)virt_to_phys(efx->stats_buffer.addr));\r\nnic_data->stats_dma_done = efx->stats_buffer.addr + XgDmaDone_offset;\r\nreturn 0;\r\n}\r\nstatic void falcon_remove_port(struct efx_nic *efx)\r\n{\r\nefx->phy_op->remove(efx);\r\nefx_nic_free_buffer(efx, &efx->stats_buffer);\r\n}\r\nstatic bool\r\nfalcon_handle_global_event(struct efx_channel *channel, efx_qword_t *event)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nif (EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_G_PHY0_INTR) ||\r\nEFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XG_PHY0_INTR) ||\r\nEFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XFP_PHY0_INTR))\r\nreturn true;\r\nif ((efx_nic_rev(efx) == EFX_REV_FALCON_B0) &&\r\nEFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_XG_MGT_INTR)) {\r\nnic_data->xmac_poll_required = true;\r\nreturn true;\r\n}\r\nif (efx_nic_rev(efx) <= EFX_REV_FALCON_A1 ?\r\nEFX_QWORD_FIELD(*event, FSF_AA_GLB_EV_RX_RECOVERY) :\r\nEFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_RX_RECOVERY)) {\r\nnetif_err(efx, rx_err, efx->net_dev,\r\n"channel %d seen global RX_RESET event. Resetting.\n",\r\nchannel->channel);\r\natomic_inc(&efx->rx_reset);\r\nefx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?\r\nRESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int\r\nfalcon_read_nvram(struct efx_nic *efx, struct falcon_nvconfig *nvconfig_out)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_nvconfig *nvconfig;\r\nstruct efx_spi_device *spi;\r\nvoid *region;\r\nint rc, magic_num, struct_ver;\r\n__le16 *word, *limit;\r\nu32 csum;\r\nif (efx_spi_present(&nic_data->spi_flash))\r\nspi = &nic_data->spi_flash;\r\nelse if (efx_spi_present(&nic_data->spi_eeprom))\r\nspi = &nic_data->spi_eeprom;\r\nelse\r\nreturn -EINVAL;\r\nregion = kmalloc(FALCON_NVCONFIG_END, GFP_KERNEL);\r\nif (!region)\r\nreturn -ENOMEM;\r\nnvconfig = region + FALCON_NVCONFIG_OFFSET;\r\nmutex_lock(&nic_data->spi_lock);\r\nrc = falcon_spi_read(efx, spi, 0, FALCON_NVCONFIG_END, NULL, region);\r\nmutex_unlock(&nic_data->spi_lock);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev, "Failed to read %s\n",\r\nefx_spi_present(&nic_data->spi_flash) ?\r\n"flash" : "EEPROM");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmagic_num = le16_to_cpu(nvconfig->board_magic_num);\r\nstruct_ver = le16_to_cpu(nvconfig->board_struct_ver);\r\nrc = -EINVAL;\r\nif (magic_num != FALCON_NVCONFIG_BOARD_MAGIC_NUM) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"NVRAM bad magic 0x%x\n", magic_num);\r\ngoto out;\r\n}\r\nif (struct_ver < 2) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"NVRAM has ancient version 0x%x\n", struct_ver);\r\ngoto out;\r\n} else if (struct_ver < 4) {\r\nword = &nvconfig->board_magic_num;\r\nlimit = (__le16 *) (nvconfig + 1);\r\n} else {\r\nword = region;\r\nlimit = region + FALCON_NVCONFIG_END;\r\n}\r\nfor (csum = 0; word < limit; ++word)\r\ncsum += le16_to_cpu(*word);\r\nif (~csum & 0xffff) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"NVRAM has incorrect checksum\n");\r\ngoto out;\r\n}\r\nrc = 0;\r\nif (nvconfig_out)\r\nmemcpy(nvconfig_out, nvconfig, sizeof(*nvconfig));\r\nout:\r\nkfree(region);\r\nreturn rc;\r\n}\r\nstatic int falcon_test_nvram(struct efx_nic *efx)\r\n{\r\nreturn falcon_read_nvram(efx, NULL);\r\n}\r\nstatic int falcon_b0_test_registers(struct efx_nic *efx)\r\n{\r\nreturn efx_nic_test_registers(efx, falcon_b0_register_tests,\r\nARRAY_SIZE(falcon_b0_register_tests));\r\n}\r\nstatic enum reset_type falcon_map_reset_reason(enum reset_type reason)\r\n{\r\nswitch (reason) {\r\ncase RESET_TYPE_RX_RECOVERY:\r\ncase RESET_TYPE_RX_DESC_FETCH:\r\ncase RESET_TYPE_TX_DESC_FETCH:\r\ncase RESET_TYPE_TX_SKIP:\r\nreturn RESET_TYPE_INVISIBLE;\r\ndefault:\r\nreturn RESET_TYPE_ALL;\r\n}\r\n}\r\nstatic int falcon_map_reset_flags(u32 *flags)\r\n{\r\nenum {\r\nFALCON_RESET_INVISIBLE = (ETH_RESET_DMA | ETH_RESET_FILTER |\r\nETH_RESET_OFFLOAD | ETH_RESET_MAC),\r\nFALCON_RESET_ALL = FALCON_RESET_INVISIBLE | ETH_RESET_PHY,\r\nFALCON_RESET_WORLD = FALCON_RESET_ALL | ETH_RESET_IRQ,\r\n};\r\nif ((*flags & FALCON_RESET_WORLD) == FALCON_RESET_WORLD) {\r\n*flags &= ~FALCON_RESET_WORLD;\r\nreturn RESET_TYPE_WORLD;\r\n}\r\nif ((*flags & FALCON_RESET_ALL) == FALCON_RESET_ALL) {\r\n*flags &= ~FALCON_RESET_ALL;\r\nreturn RESET_TYPE_ALL;\r\n}\r\nif ((*flags & FALCON_RESET_INVISIBLE) == FALCON_RESET_INVISIBLE) {\r\n*flags &= ~FALCON_RESET_INVISIBLE;\r\nreturn RESET_TYPE_INVISIBLE;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __falcon_reset_hw(struct efx_nic *efx, enum reset_type method)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t glb_ctl_reg_ker;\r\nint rc;\r\nnetif_dbg(efx, hw, efx->net_dev, "performing %s hardware reset\n",\r\nRESET_TYPE(method));\r\nif (method == RESET_TYPE_WORLD) {\r\nrc = pci_save_state(efx->pci_dev);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to backup PCI state of primary "\r\n"function prior to hardware reset\n");\r\ngoto fail1;\r\n}\r\nif (efx_nic_is_dual_func(efx)) {\r\nrc = pci_save_state(nic_data->pci_dev2);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to backup PCI state of "\r\n"secondary function prior to "\r\n"hardware reset\n");\r\ngoto fail2;\r\n}\r\n}\r\nEFX_POPULATE_OWORD_2(glb_ctl_reg_ker,\r\nFRF_AB_EXT_PHY_RST_DUR,\r\nFFE_AB_EXT_PHY_RST_DUR_10240US,\r\nFRF_AB_SWRST, 1);\r\n} else {\r\nEFX_POPULATE_OWORD_7(glb_ctl_reg_ker,\r\nFRF_AB_EXT_PHY_RST_CTL,\r\nmethod == RESET_TYPE_INVISIBLE,\r\nFRF_AB_PCIE_CORE_RST_CTL, 1,\r\nFRF_AB_PCIE_NSTKY_RST_CTL, 1,\r\nFRF_AB_PCIE_SD_RST_CTL, 1,\r\nFRF_AB_EE_RST_CTL, 1,\r\nFRF_AB_EXT_PHY_RST_DUR,\r\nFFE_AB_EXT_PHY_RST_DUR_10240US,\r\nFRF_AB_SWRST, 1);\r\n}\r\nefx_writeo(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);\r\nnetif_dbg(efx, hw, efx->net_dev, "waiting for hardware reset\n");\r\nschedule_timeout_uninterruptible(HZ / 20);\r\nif (method == RESET_TYPE_WORLD) {\r\nif (efx_nic_is_dual_func(efx))\r\npci_restore_state(nic_data->pci_dev2);\r\npci_restore_state(efx->pci_dev);\r\nnetif_dbg(efx, drv, efx->net_dev,\r\n"successfully restored PCI config\n");\r\n}\r\nefx_reado(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);\r\nif (EFX_OWORD_FIELD(glb_ctl_reg_ker, FRF_AB_SWRST) != 0) {\r\nrc = -ETIMEDOUT;\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for hardware reset\n");\r\ngoto fail3;\r\n}\r\nnetif_dbg(efx, hw, efx->net_dev, "hardware reset complete\n");\r\nreturn 0;\r\nfail2:\r\npci_restore_state(efx->pci_dev);\r\nfail1:\r\nfail3:\r\nreturn rc;\r\n}\r\nstatic int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nmutex_lock(&nic_data->spi_lock);\r\nrc = __falcon_reset_hw(efx, method);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic void falcon_monitor(struct efx_nic *efx)\r\n{\r\nbool link_changed;\r\nint rc;\r\nBUG_ON(!mutex_is_locked(&efx->mac_lock));\r\nrc = falcon_board(efx)->type->monitor(efx);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"Board sensor %s; shutting down PHY\n",\r\n(rc == -ERANGE) ? "reported fault" : "failed");\r\nefx->phy_mode |= PHY_MODE_LOW_POWER;\r\nrc = __efx_reconfigure_port(efx);\r\nWARN_ON(rc);\r\n}\r\nif (LOOPBACK_INTERNAL(efx))\r\nlink_changed = falcon_loopback_link_poll(efx);\r\nelse\r\nlink_changed = efx->phy_op->poll(efx);\r\nif (link_changed) {\r\nfalcon_stop_nic_stats(efx);\r\nfalcon_deconfigure_mac_wrapper(efx);\r\nfalcon_reset_macs(efx);\r\nrc = falcon_reconfigure_xmac(efx);\r\nBUG_ON(rc);\r\nfalcon_start_nic_stats(efx);\r\nefx_link_status_changed(efx);\r\n}\r\nfalcon_poll_xmac(efx);\r\n}\r\nstatic int falcon_reset_sram(struct efx_nic *efx)\r\n{\r\nefx_oword_t srm_cfg_reg_ker, gpio_cfg_reg_ker;\r\nint count;\r\nefx_reado(efx, &gpio_cfg_reg_ker, FR_AB_GPIO_CTL);\r\nEFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, FRF_AB_GPIO1_OEN, 1);\r\nEFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, FRF_AB_GPIO1_OUT, 1);\r\nefx_writeo(efx, &gpio_cfg_reg_ker, FR_AB_GPIO_CTL);\r\nEFX_POPULATE_OWORD_2(srm_cfg_reg_ker,\r\nFRF_AZ_SRM_INIT_EN, 1,\r\nFRF_AZ_SRM_NB_SZ, 0);\r\nefx_writeo(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);\r\ncount = 0;\r\ndo {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"waiting for SRAM reset (attempt %d)...\n", count);\r\nschedule_timeout_uninterruptible(HZ / 50);\r\nefx_reado(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);\r\nif (!EFX_OWORD_FIELD(srm_cfg_reg_ker, FRF_AZ_SRM_INIT_EN)) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"SRAM reset complete\n");\r\nreturn 0;\r\n}\r\n} while (++count < 20);\r\nnetif_err(efx, hw, efx->net_dev, "timed out waiting for SRAM reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void falcon_spi_device_init(struct efx_nic *efx,\r\nstruct efx_spi_device *spi_device,\r\nunsigned int device_id, u32 device_type)\r\n{\r\nif (device_type != 0) {\r\nspi_device->device_id = device_id;\r\nspi_device->size =\r\n1 << SPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_SIZE);\r\nspi_device->addr_len =\r\nSPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_ADDR_LEN);\r\nspi_device->munge_address = (spi_device->size == 1 << 9 &&\r\nspi_device->addr_len == 1);\r\nspi_device->erase_command =\r\nSPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_ERASE_CMD);\r\nspi_device->erase_size =\r\n1 << SPI_DEV_TYPE_FIELD(device_type,\r\nSPI_DEV_TYPE_ERASE_SIZE);\r\nspi_device->block_size =\r\n1 << SPI_DEV_TYPE_FIELD(device_type,\r\nSPI_DEV_TYPE_BLOCK_SIZE);\r\n} else {\r\nspi_device->size = 0;\r\n}\r\n}\r\nstatic int falcon_probe_nvconfig(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_nvconfig *nvconfig;\r\nint rc;\r\nnvconfig = kmalloc(sizeof(*nvconfig), GFP_KERNEL);\r\nif (!nvconfig)\r\nreturn -ENOMEM;\r\nrc = falcon_read_nvram(efx, nvconfig);\r\nif (rc)\r\ngoto out;\r\nefx->phy_type = nvconfig->board_v2.port0_phy_type;\r\nefx->mdio.prtad = nvconfig->board_v2.port0_phy_addr;\r\nif (le16_to_cpu(nvconfig->board_struct_ver) >= 3) {\r\nfalcon_spi_device_init(\r\nefx, &nic_data->spi_flash, FFE_AB_SPI_DEVICE_FLASH,\r\nle32_to_cpu(nvconfig->board_v3\r\n.spi_device_type[FFE_AB_SPI_DEVICE_FLASH]));\r\nfalcon_spi_device_init(\r\nefx, &nic_data->spi_eeprom, FFE_AB_SPI_DEVICE_EEPROM,\r\nle32_to_cpu(nvconfig->board_v3\r\n.spi_device_type[FFE_AB_SPI_DEVICE_EEPROM]));\r\n}\r\nmemcpy(efx->net_dev->perm_addr, nvconfig->mac_address[0], ETH_ALEN);\r\nnetif_dbg(efx, probe, efx->net_dev, "PHY is %d phy_id %d\n",\r\nefx->phy_type, efx->mdio.prtad);\r\nrc = falcon_probe_board(efx,\r\nle16_to_cpu(nvconfig->board_v2.board_revision));\r\nout:\r\nkfree(nvconfig);\r\nreturn rc;\r\n}\r\nstatic void falcon_dimension_resources(struct efx_nic *efx)\r\n{\r\nefx->rx_dc_base = 0x20000;\r\nefx->tx_dc_base = 0x26000;\r\n}\r\nstatic void falcon_probe_spi_devices(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t nic_stat, gpio_ctl, ee_vpd_cfg;\r\nint boot_dev;\r\nefx_reado(efx, &gpio_ctl, FR_AB_GPIO_CTL);\r\nefx_reado(efx, &nic_stat, FR_AB_NIC_STAT);\r\nefx_reado(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);\r\nif (EFX_OWORD_FIELD(gpio_ctl, FRF_AB_GPIO3_PWRUP_VALUE)) {\r\nboot_dev = (EFX_OWORD_FIELD(nic_stat, FRF_AB_SF_PRST) ?\r\nFFE_AB_SPI_DEVICE_FLASH : FFE_AB_SPI_DEVICE_EEPROM);\r\nnetif_dbg(efx, probe, efx->net_dev, "Booted from %s\n",\r\nboot_dev == FFE_AB_SPI_DEVICE_FLASH ?\r\n"flash" : "EEPROM");\r\n} else {\r\nboot_dev = -1;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"Booted from internal ASIC settings;"\r\n" setting SPI config\n");\r\nEFX_POPULATE_OWORD_3(ee_vpd_cfg, FRF_AB_EE_VPD_EN, 0,\r\nFRF_AB_EE_SF_CLOCK_DIV, 7,\r\nFRF_AB_EE_EE_CLOCK_DIV, 63);\r\nefx_writeo(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);\r\n}\r\nmutex_init(&nic_data->spi_lock);\r\nif (boot_dev == FFE_AB_SPI_DEVICE_FLASH)\r\nfalcon_spi_device_init(efx, &nic_data->spi_flash,\r\nFFE_AB_SPI_DEVICE_FLASH,\r\ndefault_flash_type);\r\nif (boot_dev == FFE_AB_SPI_DEVICE_EEPROM)\r\nfalcon_spi_device_init(efx, &nic_data->spi_eeprom,\r\nFFE_AB_SPI_DEVICE_EEPROM,\r\nlarge_eeprom_type);\r\n}\r\nstatic int falcon_probe_nic(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data;\r\nstruct falcon_board *board;\r\nint rc;\r\nnic_data = kzalloc(sizeof(*nic_data), GFP_KERNEL);\r\nif (!nic_data)\r\nreturn -ENOMEM;\r\nefx->nic_data = nic_data;\r\nrc = -ENODEV;\r\nif (efx_nic_fpga_ver(efx) != 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon FPGA not supported\n");\r\ngoto fail1;\r\n}\r\nif (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {\r\nefx_oword_t nic_stat;\r\nstruct pci_dev *dev;\r\nu8 pci_rev = efx->pci_dev->revision;\r\nif ((pci_rev == 0xff) || (pci_rev == 0)) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon rev A0 not supported\n");\r\ngoto fail1;\r\n}\r\nefx_reado(efx, &nic_stat, FR_AB_NIC_STAT);\r\nif (EFX_OWORD_FIELD(nic_stat, FRF_AB_STRAP_10G) == 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon rev A1 1G not supported\n");\r\ngoto fail1;\r\n}\r\nif (EFX_OWORD_FIELD(nic_stat, FRF_AA_STRAP_PCIE) == 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon rev A1 PCI-X not supported\n");\r\ngoto fail1;\r\n}\r\ndev = pci_dev_get(efx->pci_dev);\r\nwhile ((dev = pci_get_device(PCI_VENDOR_ID_SOLARFLARE,\r\nPCI_DEVICE_ID_SOLARFLARE_SFC4000A_1,\r\ndev))) {\r\nif (dev->bus == efx->pci_dev->bus &&\r\ndev->devfn == efx->pci_dev->devfn + 1) {\r\nnic_data->pci_dev2 = dev;\r\nbreak;\r\n}\r\n}\r\nif (!nic_data->pci_dev2) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"failed to find secondary function\n");\r\nrc = -ENODEV;\r\ngoto fail2;\r\n}\r\n}\r\nrc = __falcon_reset_hw(efx, RESET_TYPE_ALL);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");\r\ngoto fail3;\r\n}\r\nrc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));\r\nif (rc)\r\ngoto fail4;\r\nBUG_ON(efx->irq_status.dma_addr & 0x0f);\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"INT_KER at %llx (virt %p phys %llx)\n",\r\n(u64)efx->irq_status.dma_addr,\r\nefx->irq_status.addr,\r\n(u64)virt_to_phys(efx->irq_status.addr));\r\nfalcon_probe_spi_devices(efx);\r\nrc = falcon_probe_nvconfig(efx);\r\nif (rc) {\r\nif (rc == -EINVAL)\r\nnetif_err(efx, probe, efx->net_dev, "NVRAM is invalid\n");\r\ngoto fail5;\r\n}\r\nefx->timer_quantum_ns = 4968;\r\nboard = falcon_board(efx);\r\nboard->i2c_adap.owner = THIS_MODULE;\r\nboard->i2c_data = falcon_i2c_bit_operations;\r\nboard->i2c_data.data = efx;\r\nboard->i2c_adap.algo_data = &board->i2c_data;\r\nboard->i2c_adap.dev.parent = &efx->pci_dev->dev;\r\nstrlcpy(board->i2c_adap.name, "SFC4000 GPIO",\r\nsizeof(board->i2c_adap.name));\r\nrc = i2c_bit_add_bus(&board->i2c_adap);\r\nif (rc)\r\ngoto fail5;\r\nrc = falcon_board(efx)->type->init(efx);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"failed to initialise board\n");\r\ngoto fail6;\r\n}\r\nnic_data->stats_disable_count = 1;\r\nsetup_timer(&nic_data->stats_timer, &falcon_stats_timer_func,\r\n(unsigned long)efx);\r\nreturn 0;\r\nfail6:\r\nBUG_ON(i2c_del_adapter(&board->i2c_adap));\r\nmemset(&board->i2c_adap, 0, sizeof(board->i2c_adap));\r\nfail5:\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\nfail4:\r\nfail3:\r\nif (nic_data->pci_dev2) {\r\npci_dev_put(nic_data->pci_dev2);\r\nnic_data->pci_dev2 = NULL;\r\n}\r\nfail2:\r\nfail1:\r\nkfree(efx->nic_data);\r\nreturn rc;\r\n}\r\nstatic void falcon_init_rx_cfg(struct efx_nic *efx)\r\n{\r\nconst unsigned huge_buf_size = (3 * 4096) >> 5;\r\nconst unsigned ctrl_xon_thr = 20;\r\nconst unsigned ctrl_xoff_thr = 25;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AZ_RX_CFG);\r\nif (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_DESC_PUSH_EN, 0);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_USR_BUF_SIZE,\r\nhuge_buf_size);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_MAC_TH, 512 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_MAC_TH, 2048 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_TX_TH, ctrl_xon_thr);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_TX_TH, ctrl_xoff_thr);\r\n} else {\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_DESC_PUSH_EN, 0);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_USR_BUF_SIZE,\r\nhuge_buf_size);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_MAC_TH, 27648 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_MAC_TH, 54272 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_TX_TH, ctrl_xon_thr);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_TX_TH, ctrl_xoff_thr);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_INSRT_HDR, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_ALG, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_IP_HASH, 1);\r\n}\r\nEFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);\r\nefx_writeo(efx, &reg, FR_AZ_RX_CFG);\r\n}\r\nstatic int falcon_init_nic(struct efx_nic *efx)\r\n{\r\nefx_oword_t temp;\r\nint rc;\r\nefx_reado(efx, &temp, FR_AB_NIC_STAT);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AB_ONCHIP_SRAM, 1);\r\nefx_writeo(efx, &temp, FR_AB_NIC_STAT);\r\nrc = falcon_reset_sram(efx);\r\nif (rc)\r\nreturn rc;\r\nif (EFX_WORKAROUND_5129(efx)) {\r\nefx_reado(efx, &temp, FR_AZ_CSR_SPARE);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AB_MEM_PERR_EN_TX_DATA, 0);\r\nefx_writeo(efx, &temp, FR_AZ_CSR_SPARE);\r\n}\r\nif (EFX_WORKAROUND_7244(efx)) {\r\nefx_reado(efx, &temp, FR_BZ_RX_FILTER_CTL);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_FULL_SRCH_LIMIT, 8);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_WILD_SRCH_LIMIT, 8);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_FULL_SRCH_LIMIT, 8);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_WILD_SRCH_LIMIT, 8);\r\nefx_writeo(efx, &temp, FR_BZ_RX_FILTER_CTL);\r\n}\r\nefx_reado(efx, &temp, FR_AA_RX_SELF_RST);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AA_RX_NODESC_WAIT_DIS, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AA_RX_SELF_RST_EN, 1);\r\nif (EFX_WORKAROUND_5583(efx))\r\nEFX_SET_OWORD_FIELD(temp, FRF_AA_RX_ISCSI_DIS, 1);\r\nefx_writeo(efx, &temp, FR_AA_RX_SELF_RST);\r\nefx_reado(efx, &temp, FR_AZ_TX_CFG);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);\r\nefx_writeo(efx, &temp, FR_AZ_TX_CFG);\r\nfalcon_init_rx_cfg(efx);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nmemcpy(&temp, efx->rx_hash_key, sizeof(temp));\r\nefx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);\r\nEFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);\r\nefx_writeo(efx, &temp, FR_BZ_DP_CTRL);\r\n}\r\nefx_nic_init_common(efx);\r\nreturn 0;\r\n}\r\nstatic void falcon_remove_nic(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_board *board = falcon_board(efx);\r\nint rc;\r\nboard->type->fini(efx);\r\nrc = i2c_del_adapter(&board->i2c_adap);\r\nBUG_ON(rc);\r\nmemset(&board->i2c_adap, 0, sizeof(board->i2c_adap));\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\n__falcon_reset_hw(efx, RESET_TYPE_ALL);\r\nif (nic_data->pci_dev2) {\r\npci_dev_put(nic_data->pci_dev2);\r\nnic_data->pci_dev2 = NULL;\r\n}\r\nkfree(efx->nic_data);\r\nefx->nic_data = NULL;\r\n}\r\nstatic void falcon_update_nic_stats(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t cnt;\r\nif (nic_data->stats_disable_count)\r\nreturn;\r\nefx_reado(efx, &cnt, FR_AZ_RX_NODESC_DROP);\r\nefx->n_rx_nodesc_drop_cnt +=\r\nEFX_OWORD_FIELD(cnt, FRF_AB_RX_NODESC_DROP_CNT);\r\nif (nic_data->stats_pending &&\r\n*nic_data->stats_dma_done == FALCON_STATS_DONE) {\r\nnic_data->stats_pending = false;\r\nrmb();\r\nfalcon_update_stats_xmac(efx);\r\n}\r\n}\r\nvoid falcon_start_nic_stats(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nspin_lock_bh(&efx->stats_lock);\r\nif (--nic_data->stats_disable_count == 0)\r\nfalcon_stats_request(efx);\r\nspin_unlock_bh(&efx->stats_lock);\r\n}\r\nvoid falcon_stop_nic_stats(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint i;\r\nmight_sleep();\r\nspin_lock_bh(&efx->stats_lock);\r\n++nic_data->stats_disable_count;\r\nspin_unlock_bh(&efx->stats_lock);\r\ndel_timer_sync(&nic_data->stats_timer);\r\nfor (i = 0; i < 4 && nic_data->stats_pending; i++) {\r\nif (*nic_data->stats_dma_done == FALCON_STATS_DONE)\r\nbreak;\r\nmsleep(1);\r\n}\r\nspin_lock_bh(&efx->stats_lock);\r\nfalcon_stats_complete(efx);\r\nspin_unlock_bh(&efx->stats_lock);\r\n}\r\nstatic void falcon_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nfalcon_board(efx)->type->set_id_led(efx, mode);\r\n}\r\nstatic void falcon_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)\r\n{\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int falcon_set_wol(struct efx_nic *efx, u32 type)\r\n{\r\nif (type != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
