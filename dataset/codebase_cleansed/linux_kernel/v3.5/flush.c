static void flush_pfn_alias(unsigned long pfn, unsigned long vaddr)\r\n{\r\nunsigned long to = FLUSH_ALIAS_START + (CACHE_COLOUR(vaddr) << PAGE_SHIFT);\r\nconst int zero = 0;\r\nset_top_pte(to, pfn_pte(pfn, PAGE_KERNEL));\r\nasm( "mcrr p15, 0, %1, %0, c14\n"\r\n" mcr p15, 0, %2, c7, c10, 4"\r\n:\r\n: "r" (to), "r" (to + PAGE_SIZE - L1_CACHE_BYTES), "r" (zero)\r\n: "cc");\r\n}\r\nstatic void flush_icache_alias(unsigned long pfn, unsigned long vaddr, unsigned long len)\r\n{\r\nunsigned long va = FLUSH_ALIAS_START + (CACHE_COLOUR(vaddr) << PAGE_SHIFT);\r\nunsigned long offset = vaddr & (PAGE_SIZE - 1);\r\nunsigned long to;\r\nset_top_pte(va, pfn_pte(pfn, PAGE_KERNEL));\r\nto = va + offset;\r\nflush_icache_range(to, to + len);\r\n}\r\nvoid flush_cache_mm(struct mm_struct *mm)\r\n{\r\nif (cache_is_vivt()) {\r\nvivt_flush_cache_mm(mm);\r\nreturn;\r\n}\r\nif (cache_is_vipt_aliasing()) {\r\nasm( "mcr p15, 0, %0, c7, c14, 0\n"\r\n" mcr p15, 0, %0, c7, c10, 4"\r\n:\r\n: "r" (0)\r\n: "cc");\r\n}\r\n}\r\nvoid flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)\r\n{\r\nif (cache_is_vivt()) {\r\nvivt_flush_cache_range(vma, start, end);\r\nreturn;\r\n}\r\nif (cache_is_vipt_aliasing()) {\r\nasm( "mcr p15, 0, %0, c7, c14, 0\n"\r\n" mcr p15, 0, %0, c7, c10, 4"\r\n:\r\n: "r" (0)\r\n: "cc");\r\n}\r\nif (vma->vm_flags & VM_EXEC)\r\n__flush_icache_all();\r\n}\r\nvoid flush_cache_page(struct vm_area_struct *vma, unsigned long user_addr, unsigned long pfn)\r\n{\r\nif (cache_is_vivt()) {\r\nvivt_flush_cache_page(vma, user_addr, pfn);\r\nreturn;\r\n}\r\nif (cache_is_vipt_aliasing()) {\r\nflush_pfn_alias(pfn, user_addr);\r\n__flush_icache_all();\r\n}\r\nif (vma->vm_flags & VM_EXEC && icache_is_vivt_asid_tagged())\r\n__flush_icache_all();\r\n}\r\nstatic void flush_ptrace_access_other(void *args)\r\n{\r\n__flush_icache_all();\r\n}\r\nstatic\r\nvoid flush_ptrace_access(struct vm_area_struct *vma, struct page *page,\r\nunsigned long uaddr, void *kaddr, unsigned long len)\r\n{\r\nif (cache_is_vivt()) {\r\nif (cpumask_test_cpu(smp_processor_id(), mm_cpumask(vma->vm_mm))) {\r\nunsigned long addr = (unsigned long)kaddr;\r\n__cpuc_coherent_kern_range(addr, addr + len);\r\n}\r\nreturn;\r\n}\r\nif (cache_is_vipt_aliasing()) {\r\nflush_pfn_alias(page_to_pfn(page), uaddr);\r\n__flush_icache_all();\r\nreturn;\r\n}\r\nif (vma->vm_flags & VM_EXEC) {\r\nunsigned long addr = (unsigned long)kaddr;\r\nif (icache_is_vipt_aliasing())\r\nflush_icache_alias(page_to_pfn(page), uaddr, len);\r\nelse\r\n__cpuc_coherent_kern_range(addr, addr + len);\r\nif (cache_ops_need_broadcast())\r\nsmp_call_function(flush_ptrace_access_other,\r\nNULL, 1);\r\n}\r\n}\r\nvoid copy_to_user_page(struct vm_area_struct *vma, struct page *page,\r\nunsigned long uaddr, void *dst, const void *src,\r\nunsigned long len)\r\n{\r\n#ifdef CONFIG_SMP\r\npreempt_disable();\r\n#endif\r\nmemcpy(dst, src, len);\r\nflush_ptrace_access(vma, page, uaddr, dst, len);\r\n#ifdef CONFIG_SMP\r\npreempt_enable();\r\n#endif\r\n}\r\nvoid __flush_dcache_page(struct address_space *mapping, struct page *page)\r\n{\r\nif (!PageHighMem(page)) {\r\n__cpuc_flush_dcache_area(page_address(page), PAGE_SIZE);\r\n} else {\r\nvoid *addr = kmap_high_get(page);\r\nif (addr) {\r\n__cpuc_flush_dcache_area(addr, PAGE_SIZE);\r\nkunmap_high(page);\r\n} else if (cache_is_vipt()) {\r\naddr = kmap_atomic(page);\r\n__cpuc_flush_dcache_area(addr, PAGE_SIZE);\r\nkunmap_atomic(addr);\r\n}\r\n}\r\nif (mapping && cache_is_vipt_aliasing())\r\nflush_pfn_alias(page_to_pfn(page),\r\npage->index << PAGE_CACHE_SHIFT);\r\n}\r\nstatic void __flush_dcache_aliases(struct address_space *mapping, struct page *page)\r\n{\r\nstruct mm_struct *mm = current->active_mm;\r\nstruct vm_area_struct *mpnt;\r\nstruct prio_tree_iter iter;\r\npgoff_t pgoff;\r\npgoff = page->index << (PAGE_CACHE_SHIFT - PAGE_SHIFT);\r\nflush_dcache_mmap_lock(mapping);\r\nvma_prio_tree_foreach(mpnt, &iter, &mapping->i_mmap, pgoff, pgoff) {\r\nunsigned long offset;\r\nif (mpnt->vm_mm != mm)\r\ncontinue;\r\nif (!(mpnt->vm_flags & VM_MAYSHARE))\r\ncontinue;\r\noffset = (pgoff - mpnt->vm_pgoff) << PAGE_SHIFT;\r\nflush_cache_page(mpnt, mpnt->vm_start + offset, page_to_pfn(page));\r\n}\r\nflush_dcache_mmap_unlock(mapping);\r\n}\r\nvoid __sync_icache_dcache(pte_t pteval)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nstruct address_space *mapping;\r\nif (!pte_present_user(pteval))\r\nreturn;\r\nif (cache_is_vipt_nonaliasing() && !pte_exec(pteval))\r\nreturn;\r\npfn = pte_pfn(pteval);\r\nif (!pfn_valid(pfn))\r\nreturn;\r\npage = pfn_to_page(pfn);\r\nif (cache_is_vipt_aliasing())\r\nmapping = page_mapping(page);\r\nelse\r\nmapping = NULL;\r\nif (!test_and_set_bit(PG_dcache_clean, &page->flags))\r\n__flush_dcache_page(mapping, page);\r\nif (pte_exec(pteval))\r\n__flush_icache_all();\r\n}\r\nvoid flush_dcache_page(struct page *page)\r\n{\r\nstruct address_space *mapping;\r\nif (page == ZERO_PAGE(0))\r\nreturn;\r\nmapping = page_mapping(page);\r\nif (!cache_ops_need_broadcast() &&\r\nmapping && !mapping_mapped(mapping))\r\nclear_bit(PG_dcache_clean, &page->flags);\r\nelse {\r\n__flush_dcache_page(mapping, page);\r\nif (mapping && cache_is_vivt())\r\n__flush_dcache_aliases(mapping, page);\r\nelse if (mapping)\r\n__flush_icache_all();\r\nset_bit(PG_dcache_clean, &page->flags);\r\n}\r\n}\r\nvoid __flush_anon_page(struct vm_area_struct *vma, struct page *page, unsigned long vmaddr)\r\n{\r\nunsigned long pfn;\r\nif (cache_is_vipt_nonaliasing())\r\nreturn;\r\npfn = page_to_pfn(page);\r\nif (cache_is_vivt()) {\r\nflush_cache_page(vma, vmaddr, pfn);\r\n} else {\r\nflush_pfn_alias(pfn, vmaddr);\r\n__flush_icache_all();\r\n}\r\n__cpuc_flush_dcache_area(page_address(page), PAGE_SIZE);\r\n}
