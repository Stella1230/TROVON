static inline unsigned int get_mb_rx_first(const struct at91_priv *priv)\r\n{\r\nreturn priv->devtype_data.rx_first;\r\n}\r\nstatic inline unsigned int get_mb_rx_last(const struct at91_priv *priv)\r\n{\r\nreturn priv->devtype_data.rx_last;\r\n}\r\nstatic inline unsigned int get_mb_rx_split(const struct at91_priv *priv)\r\n{\r\nreturn priv->devtype_data.rx_split;\r\n}\r\nstatic inline unsigned int get_mb_rx_num(const struct at91_priv *priv)\r\n{\r\nreturn get_mb_rx_last(priv) - get_mb_rx_first(priv) + 1;\r\n}\r\nstatic inline unsigned int get_mb_rx_low_last(const struct at91_priv *priv)\r\n{\r\nreturn get_mb_rx_split(priv) - 1;\r\n}\r\nstatic inline unsigned int get_mb_rx_low_mask(const struct at91_priv *priv)\r\n{\r\nreturn AT91_MB_MASK(get_mb_rx_split(priv)) &\r\n~AT91_MB_MASK(get_mb_rx_first(priv));\r\n}\r\nstatic inline unsigned int get_mb_tx_shift(const struct at91_priv *priv)\r\n{\r\nreturn priv->devtype_data.tx_shift;\r\n}\r\nstatic inline unsigned int get_mb_tx_num(const struct at91_priv *priv)\r\n{\r\nreturn 1 << get_mb_tx_shift(priv);\r\n}\r\nstatic inline unsigned int get_mb_tx_first(const struct at91_priv *priv)\r\n{\r\nreturn get_mb_rx_last(priv) + 1;\r\n}\r\nstatic inline unsigned int get_mb_tx_last(const struct at91_priv *priv)\r\n{\r\nreturn get_mb_tx_first(priv) + get_mb_tx_num(priv) - 1;\r\n}\r\nstatic inline unsigned int get_next_prio_shift(const struct at91_priv *priv)\r\n{\r\nreturn get_mb_tx_shift(priv);\r\n}\r\nstatic inline unsigned int get_next_prio_mask(const struct at91_priv *priv)\r\n{\r\nreturn 0xf << get_mb_tx_shift(priv);\r\n}\r\nstatic inline unsigned int get_next_mb_mask(const struct at91_priv *priv)\r\n{\r\nreturn AT91_MB_MASK(get_mb_tx_shift(priv));\r\n}\r\nstatic inline unsigned int get_next_mask(const struct at91_priv *priv)\r\n{\r\nreturn get_next_mb_mask(priv) | get_next_prio_mask(priv);\r\n}\r\nstatic inline unsigned int get_irq_mb_rx(const struct at91_priv *priv)\r\n{\r\nreturn AT91_MB_MASK(get_mb_rx_last(priv) + 1) &\r\n~AT91_MB_MASK(get_mb_rx_first(priv));\r\n}\r\nstatic inline unsigned int get_irq_mb_tx(const struct at91_priv *priv)\r\n{\r\nreturn AT91_MB_MASK(get_mb_tx_last(priv) + 1) &\r\n~AT91_MB_MASK(get_mb_tx_first(priv));\r\n}\r\nstatic inline unsigned int get_tx_next_mb(const struct at91_priv *priv)\r\n{\r\nreturn (priv->tx_next & get_next_mb_mask(priv)) + get_mb_tx_first(priv);\r\n}\r\nstatic inline unsigned int get_tx_next_prio(const struct at91_priv *priv)\r\n{\r\nreturn (priv->tx_next >> get_next_prio_shift(priv)) & 0xf;\r\n}\r\nstatic inline unsigned int get_tx_echo_mb(const struct at91_priv *priv)\r\n{\r\nreturn (priv->tx_echo & get_next_mb_mask(priv)) + get_mb_tx_first(priv);\r\n}\r\nstatic inline u32 at91_read(const struct at91_priv *priv, enum at91_reg reg)\r\n{\r\nreturn __raw_readl(priv->reg_base + reg);\r\n}\r\nstatic inline void at91_write(const struct at91_priv *priv, enum at91_reg reg,\r\nu32 value)\r\n{\r\n__raw_writel(value, priv->reg_base + reg);\r\n}\r\nstatic inline void set_mb_mode_prio(const struct at91_priv *priv,\r\nunsigned int mb, enum at91_mb_mode mode, int prio)\r\n{\r\nat91_write(priv, AT91_MMR(mb), (mode << 24) | (prio << 16));\r\n}\r\nstatic inline void set_mb_mode(const struct at91_priv *priv, unsigned int mb,\r\nenum at91_mb_mode mode)\r\n{\r\nset_mb_mode_prio(priv, mb, mode, 0);\r\n}\r\nstatic inline u32 at91_can_id_to_reg_mid(canid_t can_id)\r\n{\r\nu32 reg_mid;\r\nif (can_id & CAN_EFF_FLAG)\r\nreg_mid = (can_id & CAN_EFF_MASK) | AT91_MID_MIDE;\r\nelse\r\nreg_mid = (can_id & CAN_SFF_MASK) << 18;\r\nreturn reg_mid;\r\n}\r\nstatic void at91_transceiver_switch(const struct at91_priv *priv, int on)\r\n{\r\nif (priv->pdata && priv->pdata->transceiver_switch)\r\npriv->pdata->transceiver_switch(on);\r\n}\r\nstatic void at91_setup_mailboxes(struct net_device *dev)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nunsigned int i;\r\nu32 reg_mid;\r\nreg_mid = at91_can_id_to_reg_mid(priv->mb0_id);\r\nfor (i = 0; i < get_mb_rx_first(priv); i++) {\r\nset_mb_mode(priv, i, AT91_MB_MODE_DISABLED);\r\nat91_write(priv, AT91_MID(i), reg_mid);\r\nat91_write(priv, AT91_MCR(i), 0x0);\r\n}\r\nfor (i = get_mb_rx_first(priv); i < get_mb_rx_last(priv); i++)\r\nset_mb_mode(priv, i, AT91_MB_MODE_RX);\r\nset_mb_mode(priv, get_mb_rx_last(priv), AT91_MB_MODE_RX_OVRWR);\r\nfor (i = get_mb_rx_first(priv); i <= get_mb_rx_last(priv); i++) {\r\nat91_write(priv, AT91_MAM(i), 0x0);\r\nat91_write(priv, AT91_MID(i), AT91_MID_MIDE);\r\n}\r\nfor (i = get_mb_tx_first(priv); i <= get_mb_tx_last(priv); i++)\r\nset_mb_mode_prio(priv, i, AT91_MB_MODE_TX, 0);\r\npriv->tx_next = priv->tx_echo = 0;\r\npriv->rx_next = get_mb_rx_first(priv);\r\n}\r\nstatic int at91_set_bittiming(struct net_device *dev)\r\n{\r\nconst struct at91_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nu32 reg_br;\r\nreg_br = ((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 1 << 24 : 0) |\r\n((bt->brp - 1) << 16) | ((bt->sjw - 1) << 12) |\r\n((bt->prop_seg - 1) << 8) | ((bt->phase_seg1 - 1) << 4) |\r\n((bt->phase_seg2 - 1) << 0);\r\nnetdev_info(dev, "writing AT91_BR: 0x%08x\n", reg_br);\r\nat91_write(priv, AT91_BR, reg_br);\r\nreturn 0;\r\n}\r\nstatic int at91_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nconst struct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_ecr = at91_read(priv, AT91_ECR);\r\nbec->rxerr = reg_ecr & 0xff;\r\nbec->txerr = reg_ecr >> 16;\r\nreturn 0;\r\n}\r\nstatic void at91_chip_start(struct net_device *dev)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_mr, reg_ier;\r\nat91_write(priv, AT91_IDR, AT91_IRQ_ALL);\r\nreg_mr = at91_read(priv, AT91_MR);\r\nat91_write(priv, AT91_MR, reg_mr & ~AT91_MR_CANEN);\r\nat91_set_bittiming(dev);\r\nat91_setup_mailboxes(dev);\r\nat91_transceiver_switch(priv, 1);\r\nat91_write(priv, AT91_MR, AT91_MR_CANEN);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreg_ier = get_irq_mb_rx(priv) | AT91_IRQ_ERRP | AT91_IRQ_ERR_FRAME;\r\nat91_write(priv, AT91_IDR, AT91_IRQ_ALL);\r\nat91_write(priv, AT91_IER, reg_ier);\r\n}\r\nstatic void at91_chip_stop(struct net_device *dev, enum can_state state)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_mr;\r\nat91_write(priv, AT91_IDR, AT91_IRQ_ALL);\r\nreg_mr = at91_read(priv, AT91_MR);\r\nat91_write(priv, AT91_MR, reg_mr & ~AT91_MR_CANEN);\r\nat91_transceiver_switch(priv, 0);\r\npriv->can.state = state;\r\n}\r\nstatic netdev_tx_t at91_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nunsigned int mb, prio;\r\nu32 reg_mid, reg_mcr;\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nmb = get_tx_next_mb(priv);\r\nprio = get_tx_next_prio(priv);\r\nif (unlikely(!(at91_read(priv, AT91_MSR(mb)) & AT91_MSR_MRDY))) {\r\nnetif_stop_queue(dev);\r\nnetdev_err(dev, "BUG! TX buffer full when queue awake!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nreg_mid = at91_can_id_to_reg_mid(cf->can_id);\r\nreg_mcr = ((cf->can_id & CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0) |\r\n(cf->can_dlc << 16) | AT91_MCR_MTCR;\r\nset_mb_mode(priv, mb, AT91_MB_MODE_DISABLED);\r\nat91_write(priv, AT91_MID(mb), reg_mid);\r\nset_mb_mode_prio(priv, mb, AT91_MB_MODE_TX, prio);\r\nat91_write(priv, AT91_MDL(mb), *(u32 *)(cf->data + 0));\r\nat91_write(priv, AT91_MDH(mb), *(u32 *)(cf->data + 4));\r\nat91_write(priv, AT91_MCR(mb), reg_mcr);\r\nstats->tx_bytes += cf->can_dlc;\r\ncan_put_echo_skb(skb, dev, mb - get_mb_tx_first(priv));\r\npriv->tx_next++;\r\nif (!(at91_read(priv, AT91_MSR(get_tx_next_mb(priv))) &\r\nAT91_MSR_MRDY) ||\r\n(priv->tx_next & get_next_mask(priv)) == 0)\r\nnetif_stop_queue(dev);\r\nat91_write(priv, AT91_IER, 1 << mb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic inline void at91_activate_rx_low(const struct at91_priv *priv)\r\n{\r\nu32 mask = get_mb_rx_low_mask(priv);\r\nat91_write(priv, AT91_TCR, mask);\r\n}\r\nstatic inline void at91_activate_rx_mb(const struct at91_priv *priv,\r\nunsigned int mb)\r\n{\r\nu32 mask = 1 << mb;\r\nat91_write(priv, AT91_TCR, mask);\r\n}\r\nstatic void at91_rx_overflow_err(struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nnetdev_dbg(dev, "RX buffer overflow\n");\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic void at91_read_mb(struct net_device *dev, unsigned int mb,\r\nstruct can_frame *cf)\r\n{\r\nconst struct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_msr, reg_mid;\r\nreg_mid = at91_read(priv, AT91_MID(mb));\r\nif (reg_mid & AT91_MID_MIDE)\r\ncf->can_id = ((reg_mid >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (reg_mid >> 18) & CAN_SFF_MASK;\r\nreg_msr = at91_read(priv, AT91_MSR(mb));\r\ncf->can_dlc = get_can_dlc((reg_msr >> 16) & 0xf);\r\nif (reg_msr & AT91_MSR_MRTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse {\r\n*(u32 *)(cf->data + 0) = at91_read(priv, AT91_MDL(mb));\r\n*(u32 *)(cf->data + 4) = at91_read(priv, AT91_MDH(mb));\r\n}\r\nat91_write(priv, AT91_MID(mb), AT91_MID_MIDE);\r\nif (unlikely(mb == get_mb_rx_last(priv) && reg_msr & AT91_MSR_MMI))\r\nat91_rx_overflow_err(dev);\r\n}\r\nstatic void at91_read_msg(struct net_device *dev, unsigned int mb)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nskb = alloc_can_skb(dev, &cf);\r\nif (unlikely(!skb)) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nat91_read_mb(dev, mb, cf);\r\nnetif_receive_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\n}\r\nstatic int at91_poll_rx(struct net_device *dev, int quota)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_sr = at91_read(priv, AT91_SR);\r\nconst unsigned long *addr = (unsigned long *)&reg_sr;\r\nunsigned int mb;\r\nint received = 0;\r\nif (priv->rx_next > get_mb_rx_low_last(priv) &&\r\nreg_sr & get_mb_rx_low_mask(priv))\r\nnetdev_info(dev,\r\n"order of incoming frames cannot be guaranteed\n");\r\nagain:\r\nfor (mb = find_next_bit(addr, get_mb_tx_first(priv), priv->rx_next);\r\nmb < get_mb_tx_first(priv) && quota > 0;\r\nreg_sr = at91_read(priv, AT91_SR),\r\nmb = find_next_bit(addr, get_mb_tx_first(priv), ++priv->rx_next)) {\r\nat91_read_msg(dev, mb);\r\nif (mb == get_mb_rx_low_last(priv))\r\nat91_activate_rx_low(priv);\r\nelse if (mb > get_mb_rx_low_last(priv))\r\nat91_activate_rx_mb(priv, mb);\r\nreceived++;\r\nquota--;\r\n}\r\nif (priv->rx_next > get_mb_rx_low_last(priv) &&\r\nquota > 0 && mb > get_mb_rx_last(priv)) {\r\npriv->rx_next = get_mb_rx_first(priv);\r\ngoto again;\r\n}\r\nreturn received;\r\n}\r\nstatic void at91_poll_err_frame(struct net_device *dev,\r\nstruct can_frame *cf, u32 reg_sr)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nif (reg_sr & AT91_IRQ_CERR) {\r\nnetdev_dbg(dev, "CERR irq\n");\r\ndev->stats.rx_errors++;\r\npriv->can.can_stats.bus_error++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\n}\r\nif (reg_sr & AT91_IRQ_SERR) {\r\nnetdev_dbg(dev, "SERR irq\n");\r\ndev->stats.rx_errors++;\r\npriv->can.can_stats.bus_error++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\n}\r\nif (reg_sr & AT91_IRQ_AERR) {\r\nnetdev_dbg(dev, "AERR irq\n");\r\ndev->stats.tx_errors++;\r\ncf->can_id |= CAN_ERR_ACK;\r\n}\r\nif (reg_sr & AT91_IRQ_FERR) {\r\nnetdev_dbg(dev, "FERR irq\n");\r\ndev->stats.rx_errors++;\r\npriv->can.can_stats.bus_error++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\n}\r\nif (reg_sr & AT91_IRQ_BERR) {\r\nnetdev_dbg(dev, "BERR irq\n");\r\ndev->stats.tx_errors++;\r\npriv->can.can_stats.bus_error++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\n}\r\n}\r\nstatic int at91_poll_err(struct net_device *dev, int quota, u32 reg_sr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nif (quota == 0)\r\nreturn 0;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn 0;\r\nat91_poll_err_frame(dev, cf, reg_sr);\r\nnetif_receive_skb(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += cf->can_dlc;\r\nreturn 1;\r\n}\r\nstatic int at91_poll(struct napi_struct *napi, int quota)\r\n{\r\nstruct net_device *dev = napi->dev;\r\nconst struct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_sr = at91_read(priv, AT91_SR);\r\nint work_done = 0;\r\nif (reg_sr & get_irq_mb_rx(priv))\r\nwork_done += at91_poll_rx(dev, quota - work_done);\r\nreg_sr |= priv->reg_sr;\r\nif (reg_sr & AT91_IRQ_ERR_FRAME)\r\nwork_done += at91_poll_err(dev, quota - work_done, reg_sr);\r\nif (work_done < quota) {\r\nu32 reg_ier = AT91_IRQ_ERR_FRAME;\r\nreg_ier |= get_irq_mb_rx(priv) & ~AT91_MB_MASK(priv->rx_next);\r\nnapi_complete(napi);\r\nat91_write(priv, AT91_IER, reg_ier);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void at91_irq_tx(struct net_device *dev, u32 reg_sr)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_msr;\r\nunsigned int mb;\r\nfor (; (priv->tx_next - priv->tx_echo) > 0; priv->tx_echo++) {\r\nmb = get_tx_echo_mb(priv);\r\nif (!(reg_sr & (1 << mb)))\r\nbreak;\r\nat91_write(priv, AT91_IDR, 1 << mb);\r\nreg_msr = at91_read(priv, AT91_MSR(mb));\r\nif (likely(reg_msr & AT91_MSR_MRDY &&\r\n~reg_msr & AT91_MSR_MABT)) {\r\ncan_get_echo_skb(dev, mb - get_mb_tx_first(priv));\r\ndev->stats.tx_packets++;\r\n}\r\n}\r\nif ((priv->tx_next & get_next_mask(priv)) != 0 ||\r\n(priv->tx_echo & get_next_mask(priv)) == 0)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void at91_irq_err_state(struct net_device *dev,\r\nstruct can_frame *cf, enum can_state new_state)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nu32 reg_idr = 0, reg_ier = 0;\r\nstruct can_berr_counter bec;\r\nat91_get_berr_counter(dev, &bec);\r\nswitch (priv->can.state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nif (new_state >= CAN_STATE_ERROR_WARNING &&\r\nnew_state <= CAN_STATE_BUS_OFF) {\r\nnetdev_dbg(dev, "Error Warning IRQ\n");\r\npriv->can.can_stats.error_warning++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\n}\r\ncase CAN_STATE_ERROR_WARNING:\r\nif (new_state >= CAN_STATE_ERROR_PASSIVE &&\r\nnew_state <= CAN_STATE_BUS_OFF) {\r\nnetdev_dbg(dev, "Error Passive IRQ\n");\r\npriv->can.can_stats.error_passive++;\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = (bec.txerr > bec.rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\nif (new_state <= CAN_STATE_ERROR_PASSIVE) {\r\ncf->can_id |= CAN_ERR_RESTARTED;\r\nnetdev_dbg(dev, "restarted\n");\r\npriv->can.can_stats.restarts++;\r\nnetif_carrier_on(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (new_state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nnetdev_dbg(dev, "Error Active\n");\r\ncf->can_id |= CAN_ERR_PROT;\r\ncf->data[2] = CAN_ERR_PROT_ACTIVE;\r\ncase CAN_STATE_ERROR_WARNING:\r\nreg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;\r\nreg_ier = AT91_IRQ_ERRP;\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\nreg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_ERRP;\r\nreg_ier = AT91_IRQ_BOFF;\r\nbreak;\r\ncase CAN_STATE_BUS_OFF:\r\nreg_idr = AT91_IRQ_ERRA | AT91_IRQ_ERRP |\r\nAT91_IRQ_WARN | AT91_IRQ_BOFF;\r\nreg_ier = 0;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nnetdev_dbg(dev, "bus-off\n");\r\nnetif_carrier_off(dev);\r\npriv->can.can_stats.bus_off++;\r\nif (!priv->can.restart_ms) {\r\nat91_chip_stop(dev, CAN_STATE_BUS_OFF);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nat91_write(priv, AT91_IDR, reg_idr);\r\nat91_write(priv, AT91_IER, reg_ier);\r\n}\r\nstatic int at91_get_state_by_bec(const struct net_device *dev,\r\nenum can_state *state)\r\n{\r\nstruct can_berr_counter bec;\r\nint err;\r\nerr = at91_get_berr_counter(dev, &bec);\r\nif (err)\r\nreturn err;\r\nif (bec.txerr < 96 && bec.rxerr < 96)\r\n*state = CAN_STATE_ERROR_ACTIVE;\r\nelse if (bec.txerr < 128 && bec.rxerr < 128)\r\n*state = CAN_STATE_ERROR_WARNING;\r\nelse if (bec.txerr < 256 && bec.rxerr < 256)\r\n*state = CAN_STATE_ERROR_PASSIVE;\r\nelse\r\n*state = CAN_STATE_BUS_OFF;\r\nreturn 0;\r\n}\r\nstatic void at91_irq_err(struct net_device *dev)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nenum can_state new_state;\r\nu32 reg_sr;\r\nint err;\r\nif (at91_is_sam9263(priv)) {\r\nreg_sr = at91_read(priv, AT91_SR);\r\nif (unlikely(reg_sr & AT91_IRQ_BOFF))\r\nnew_state = CAN_STATE_BUS_OFF;\r\nelse if (unlikely(reg_sr & AT91_IRQ_ERRP))\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\nelse if (unlikely(reg_sr & AT91_IRQ_WARN))\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\nelse if (likely(reg_sr & AT91_IRQ_ERRA))\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\nelse {\r\nnetdev_err(dev, "BUG! hardware in undefined state\n");\r\nreturn;\r\n}\r\n} else {\r\nerr = at91_get_state_by_bec(dev, &new_state);\r\nif (err)\r\nreturn;\r\n}\r\nif (likely(new_state == priv->can.state))\r\nreturn;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn;\r\nat91_irq_err_state(dev, cf, new_state);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += cf->can_dlc;\r\npriv->can.state = new_state;\r\n}\r\nstatic irqreturn_t at91_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nirqreturn_t handled = IRQ_NONE;\r\nu32 reg_sr, reg_imr;\r\nreg_sr = at91_read(priv, AT91_SR);\r\nreg_imr = at91_read(priv, AT91_IMR);\r\nreg_sr &= reg_imr;\r\nif (!reg_sr)\r\ngoto exit;\r\nhandled = IRQ_HANDLED;\r\nif (reg_sr & (get_irq_mb_rx(priv) | AT91_IRQ_ERR_FRAME)) {\r\npriv->reg_sr = reg_sr;\r\nat91_write(priv, AT91_IDR,\r\nget_irq_mb_rx(priv) | AT91_IRQ_ERR_FRAME);\r\nnapi_schedule(&priv->napi);\r\n}\r\nif (reg_sr & get_irq_mb_tx(priv))\r\nat91_irq_tx(dev, reg_sr);\r\nat91_irq_err(dev);\r\nexit:\r\nreturn handled;\r\n}\r\nstatic int at91_open(struct net_device *dev)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nint err;\r\nclk_enable(priv->clk);\r\nerr = open_candev(dev);\r\nif (err)\r\ngoto out;\r\nif (request_irq(dev->irq, at91_irq, IRQF_SHARED,\r\ndev->name, dev)) {\r\nerr = -EAGAIN;\r\ngoto out_close;\r\n}\r\nat91_chip_start(dev);\r\nnapi_enable(&priv->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_close:\r\nclose_candev(dev);\r\nout:\r\nclk_disable(priv->clk);\r\nreturn err;\r\n}\r\nstatic int at91_close(struct net_device *dev)\r\n{\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nat91_chip_stop(dev, CAN_STATE_STOPPED);\r\nfree_irq(dev->irq, dev);\r\nclk_disable(priv->clk);\r\nclose_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int at91_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nat91_chip_start(dev);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t at91_sysfs_show_mb0_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct at91_priv *priv = netdev_priv(to_net_dev(dev));\r\nif (priv->mb0_id & CAN_EFF_FLAG)\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08x\n", priv->mb0_id);\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "0x%03x\n", priv->mb0_id);\r\n}\r\nstatic ssize_t at91_sysfs_set_mb0_id(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct net_device *ndev = to_net_dev(dev);\r\nstruct at91_priv *priv = netdev_priv(ndev);\r\nunsigned long can_id;\r\nssize_t ret;\r\nint err;\r\nrtnl_lock();\r\nif (ndev->flags & IFF_UP) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nerr = strict_strtoul(buf, 0, &can_id);\r\nif (err) {\r\nret = err;\r\ngoto out;\r\n}\r\nif (can_id & CAN_EFF_FLAG)\r\ncan_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\r\nelse\r\ncan_id &= CAN_SFF_MASK;\r\npriv->mb0_id = can_id;\r\nret = count;\r\nout:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic int __devinit at91_can_probe(struct platform_device *pdev)\r\n{\r\nconst struct at91_devtype_data *devtype_data;\r\nenum at91_devtype devtype;\r\nstruct net_device *dev;\r\nstruct at91_priv *priv;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nvoid __iomem *addr;\r\nint err, irq;\r\ndevtype = pdev->id_entry->driver_data;\r\ndevtype_data = &at91_devtype_data[devtype];\r\nclk = clk_get(&pdev->dev, "can_clk");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "no clock defined\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || irq <= 0) {\r\nerr = -ENODEV;\r\ngoto exit_put;\r\n}\r\nif (!request_mem_region(res->start,\r\nresource_size(res),\r\npdev->name)) {\r\nerr = -EBUSY;\r\ngoto exit_put;\r\n}\r\naddr = ioremap_nocache(res->start, resource_size(res));\r\nif (!addr) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\ndev = alloc_candev(sizeof(struct at91_priv),\r\n1 << devtype_data->tx_shift);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_iounmap;\r\n}\r\ndev->netdev_ops = &at91_netdev_ops;\r\ndev->irq = irq;\r\ndev->flags |= IFF_ECHO;\r\npriv = netdev_priv(dev);\r\npriv->can.clock.freq = clk_get_rate(clk);\r\npriv->can.bittiming_const = &at91_bittiming_const;\r\npriv->can.do_set_mode = at91_set_mode;\r\npriv->can.do_get_berr_counter = at91_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\npriv->dev = dev;\r\npriv->reg_base = addr;\r\npriv->devtype_data = *devtype_data;\r\npriv->devtype_data.type = devtype;\r\npriv->clk = clk;\r\npriv->pdata = pdev->dev.platform_data;\r\npriv->mb0_id = 0x7ff;\r\nnetif_napi_add(dev, &priv->napi, at91_poll, get_mb_rx_num(priv));\r\nif (at91_is_sam9263(priv))\r\ndev->sysfs_groups[0] = &at91_sysfs_attr_group;\r\ndev_set_drvdata(&pdev->dev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_candev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering netdev failed\n");\r\ngoto exit_free;\r\n}\r\ndev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",\r\npriv->reg_base, dev->irq);\r\nreturn 0;\r\nexit_free:\r\nfree_candev(dev);\r\nexit_iounmap:\r\niounmap(addr);\r\nexit_release:\r\nrelease_mem_region(res->start, resource_size(res));\r\nexit_put:\r\nclk_put(clk);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit at91_can_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct at91_priv *priv = netdev_priv(dev);\r\nstruct resource *res;\r\nunregister_netdev(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(priv->reg_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_put(priv->clk);\r\nfree_candev(dev);\r\nreturn 0;\r\n}
