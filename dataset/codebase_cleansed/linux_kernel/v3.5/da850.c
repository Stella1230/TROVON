static void da850_set_async3_src(int pllnum)\r\n{\r\nstruct clk *clk, *newparent = pllnum ? &pll1_sysclk2 : &pll0_sysclk2;\r\nstruct clk_lookup *c;\r\nunsigned int v;\r\nint ret;\r\nfor (c = da850_clks; c->clk; c++) {\r\nclk = c->clk;\r\nif (clk->flags & DA850_CLK_ASYNC3) {\r\nret = clk_set_parent(clk, newparent);\r\nWARN(ret, "DA850: unable to re-parent clock %s",\r\nclk->name);\r\n}\r\n}\r\nv = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\nif (pllnum)\r\nv |= CFGCHIP3_ASYNC3_CLKSRC;\r\nelse\r\nv &= ~CFGCHIP3_ASYNC3_CLKSRC;\r\n__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\n}\r\nstatic int da850_set_voltage(unsigned int index)\r\n{\r\nstruct da850_opp *opp;\r\nif (!cvdd)\r\nreturn -ENODEV;\r\nopp = (struct da850_opp *) cpufreq_info.freq_table[index].index;\r\nreturn regulator_set_voltage(cvdd, opp->cvdd_min, opp->cvdd_max);\r\n}\r\nstatic int da850_regulator_init(void)\r\n{\r\ncvdd = regulator_get(NULL, "cvdd");\r\nif (WARN(IS_ERR(cvdd), "Unable to obtain voltage regulator for CVDD;"\r\n" voltage scaling unsupported\n")) {\r\nreturn PTR_ERR(cvdd);\r\n}\r\nreturn 0;\r\n}\r\nint __init da850_register_cpufreq(char *async_clk)\r\n{\r\nint i;\r\nif (async_clk)\r\nclk_add_alias("async", da850_cpufreq_device.name,\r\nasync_clk, NULL);\r\nfor (i = 0; i < ARRAY_SIZE(da850_freq_table); i++) {\r\nif (da850_freq_table[i].frequency <= da850_max_speed) {\r\ncpufreq_info.freq_table = &da850_freq_table[i];\r\nbreak;\r\n}\r\n}\r\nreturn platform_device_register(&da850_cpufreq_device);\r\n}\r\nstatic int da850_round_armrate(struct clk *clk, unsigned long rate)\r\n{\r\nint i, ret = 0, diff;\r\nunsigned int best = (unsigned int) -1;\r\nstruct cpufreq_frequency_table *table = cpufreq_info.freq_table;\r\nrate /= 1000;\r\nfor (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {\r\ndiff = table[i].frequency - rate;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff < best) {\r\nbest = diff;\r\nret = table[i].frequency;\r\n}\r\n}\r\nreturn ret * 1000;\r\n}\r\nstatic int da850_set_armrate(struct clk *clk, unsigned long index)\r\n{\r\nstruct clk *pllclk = &pll0_clk;\r\nreturn clk_set_rate(pllclk, index);\r\n}\r\nstatic int da850_set_pll0rate(struct clk *clk, unsigned long index)\r\n{\r\nunsigned int prediv, mult, postdiv;\r\nstruct da850_opp *opp;\r\nstruct pll_data *pll = clk->pll_data;\r\nint ret;\r\nopp = (struct da850_opp *) cpufreq_info.freq_table[index].index;\r\nprediv = opp->prediv;\r\nmult = opp->mult;\r\npostdiv = opp->postdiv;\r\nret = davinci_set_pllrate(pll, prediv, mult, postdiv);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint __init da850_register_cpufreq(char *async_clk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int da850_set_armrate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int da850_set_pll0rate(struct clk *clk, unsigned long armrate)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int da850_round_armrate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->rate;\r\n}\r\nint __init da850_register_pm(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct davinci_pm_config *pdata = pdev->dev.platform_data;\r\nret = davinci_cfg_reg(DA850_RTC_ALARM);\r\nif (ret)\r\nreturn ret;\r\npdata->ddr2_ctlr_base = da8xx_get_mem_ctlr();\r\npdata->deepsleep_reg = DA8XX_SYSCFG1_VIRT(DA8XX_DEEPSLEEP_REG);\r\npdata->ddrpsc_num = DA8XX_LPSC1_EMIF3C;\r\npdata->cpupll_reg_base = ioremap(DA8XX_PLL0_BASE, SZ_4K);\r\nif (!pdata->cpupll_reg_base)\r\nreturn -ENOMEM;\r\npdata->ddrpll_reg_base = ioremap(DA850_PLL1_BASE, SZ_4K);\r\nif (!pdata->ddrpll_reg_base) {\r\nret = -ENOMEM;\r\ngoto no_ddrpll_mem;\r\n}\r\npdata->ddrpsc_reg_base = ioremap(DA8XX_PSC1_BASE, SZ_4K);\r\nif (!pdata->ddrpsc_reg_base) {\r\nret = -ENOMEM;\r\ngoto no_ddrpsc_mem;\r\n}\r\nreturn platform_device_register(pdev);\r\nno_ddrpsc_mem:\r\niounmap(pdata->ddrpll_reg_base);\r\nno_ddrpll_mem:\r\niounmap(pdata->cpupll_reg_base);\r\nreturn ret;\r\n}\r\nvoid __init da850_init(void)\r\n{\r\nunsigned int v;\r\ndavinci_common_init(&davinci_soc_info_da850);\r\nda8xx_syscfg0_base = ioremap(DA8XX_SYSCFG0_BASE, SZ_4K);\r\nif (WARN(!da8xx_syscfg0_base, "Unable to map syscfg0 module"))\r\nreturn;\r\nda8xx_syscfg1_base = ioremap(DA8XX_SYSCFG1_BASE, SZ_4K);\r\nif (WARN(!da8xx_syscfg1_base, "Unable to map syscfg1 module"))\r\nreturn;\r\nda850_set_async3_src(1);\r\nv = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));\r\nv &= ~CFGCHIP0_PLL_MASTER_LOCK;\r\n__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP0_REG));\r\nv = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\nv &= ~CFGCHIP3_PLL1_MASTER_LOCK;\r\n__raw_writel(v, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP3_REG));\r\n}
