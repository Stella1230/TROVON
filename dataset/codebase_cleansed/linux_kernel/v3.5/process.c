void cpu_idle(void)\r\n{\r\nset_thread_flag(TIF_POLLING_NRFLAG);\r\nwhile (1) {\r\nwhile (!need_resched())\r\nbarrier();\r\nschedule_preempt_disabled();\r\ncheck_pgt_cache();\r\n}\r\n}\r\nvoid machine_restart(char *cmd)\r\n{\r\n#ifdef FASTBOOT_SELFTEST_SUPPORT\r\nif (ftc_bitmap) {\r\npdc_do_firm_test_reset(ftc_bitmap);\r\n}\r\n#endif\r\npdc_chassis_send_status(PDC_CHASSIS_DIRECT_SHUTDOWN);\r\npdc_do_reset();\r\ngsc_writel(CMD_RESET, COMMAND_GLOBAL);\r\nwhile (1) ;\r\n}\r\nvoid machine_halt(void)\r\n{\r\n}\r\nvoid machine_power_off(void)\r\n{\r\nif (chassis_power_off)\r\nchassis_power_off();\r\npdc_soft_power_button(0);\r\npdc_chassis_send_status(PDC_CHASSIS_DIRECT_SHUTDOWN);\r\nprintk(KERN_EMERG "System shut down completed.\n"\r\n"Please power this system off now.");\r\n}\r\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\r\n{\r\nreturn __kernel_thread(fn, arg, flags);\r\n}\r\nvoid exit_thread(void)\r\n{\r\n}\r\nvoid flush_thread(void)\r\n{\r\n}\r\nvoid release_thread(struct task_struct *dead_task)\r\n{\r\n}\r\nint dump_fpu (struct pt_regs * regs, elf_fpregset_t *r)\r\n{\r\nif (regs == NULL)\r\nreturn 0;\r\nmemcpy(r, regs->fr, sizeof *r);\r\nreturn 1;\r\n}\r\nint dump_task_fpu (struct task_struct *tsk, elf_fpregset_t *r)\r\n{\r\nmemcpy(r, tsk->thread.regs.fr, sizeof(*r));\r\nreturn 1;\r\n}\r\nint\r\nsys_clone(unsigned long clone_flags, unsigned long usp,\r\nstruct pt_regs *regs)\r\n{\r\nint __user *parent_tidptr = (int __user *)regs->gr[24];\r\nint __user *child_tidptr = (int __user *)regs->gr[22];\r\nusp = ALIGN(usp, 4);\r\nif (usp == 0)\r\nusp = regs->gr[30];\r\nreturn do_fork(clone_flags, usp, regs, 0, parent_tidptr, child_tidptr);\r\n}\r\nint\r\nsys_vfork(struct pt_regs *regs)\r\n{\r\nreturn do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->gr[30], regs, 0, NULL, NULL);\r\n}\r\nint\r\ncopy_thread(unsigned long clone_flags, unsigned long usp,\r\nunsigned long unused,\r\nstruct task_struct * p, struct pt_regs * pregs)\r\n{\r\nstruct pt_regs * cregs = &(p->thread.regs);\r\nvoid *stack = task_stack_page(p);\r\nextern void * const ret_from_kernel_thread;\r\nextern void * const child_return;\r\n#ifdef CONFIG_HPUX\r\nextern void * const hpux_child_return;\r\n#endif\r\n*cregs = *pregs;\r\ncregs->gr[28] = 0;\r\nif (usp == 1) {\r\ncregs->ksp = (unsigned long)stack + THREAD_SZ_ALGN;\r\ncregs->kpc = (unsigned long) &ret_from_kernel_thread;\r\n#ifdef CONFIG_64BIT\r\ncregs->gr[27] = pregs->gr[27];\r\n#endif\r\ncregs->gr[26] = pregs->gr[26];\r\ncregs->gr[25] = pregs->gr[25];\r\n} else {\r\ncregs->ksp = (unsigned long)stack\r\n+ (pregs->gr[21] & (THREAD_SIZE - 1));\r\ncregs->gr[30] = usp;\r\nif (p->personality == PER_HPUX) {\r\n#ifdef CONFIG_HPUX\r\ncregs->kpc = (unsigned long) &hpux_child_return;\r\n#else\r\nBUG();\r\n#endif\r\n} else {\r\ncregs->kpc = (unsigned long) &child_return;\r\n}\r\nif (clone_flags & CLONE_SETTLS)\r\ncregs->cr27 = pregs->gr[23];\r\n}\r\nreturn 0;\r\n}\r\nunsigned long thread_saved_pc(struct task_struct *t)\r\n{\r\nreturn t->thread.regs.kpc;\r\n}\r\nasmlinkage int sys_execve(struct pt_regs *regs)\r\n{\r\nint error;\r\nchar *filename;\r\nfilename = getname((const char __user *) regs->gr[26]);\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\ngoto out;\r\nerror = do_execve(filename,\r\n(const char __user *const __user *) regs->gr[25],\r\n(const char __user *const __user *) regs->gr[24],\r\nregs);\r\nputname(filename);\r\nout:\r\nreturn error;\r\n}\r\nint kernel_execve(const char *filename,\r\nconst char *const argv[],\r\nconst char *const envp[])\r\n{\r\nreturn __execve(filename, argv, envp, current);\r\n}\r\nunsigned long\r\nget_wchan(struct task_struct *p)\r\n{\r\nstruct unwind_frame_info info;\r\nunsigned long ip;\r\nint count = 0;\r\nif (!p || p == current || p->state == TASK_RUNNING)\r\nreturn 0;\r\nunwind_frame_init_from_blocked_task(&info, p);\r\ndo {\r\nif (unwind_once(&info) < 0)\r\nreturn 0;\r\nip = info.ip;\r\nif (!in_sched_functions(ip))\r\nreturn ip;\r\n} while (count++ < 16);\r\nreturn 0;\r\n}\r\nvoid *dereference_function_descriptor(void *ptr)\r\n{\r\nElf64_Fdesc *desc = ptr;\r\nvoid *p;\r\nif (!probe_kernel_address(&desc->addr, p))\r\nptr = p;\r\nreturn ptr;\r\n}
