static unsigned long\r\nutf16_strnlen(efi_char16_t *s, size_t maxlength)\r\n{\r\nunsigned long length = 0;\r\nwhile (*s++ != 0 && length < maxlength)\r\nlength++;\r\nreturn length;\r\n}\r\nstatic inline unsigned long\r\nutf16_strlen(efi_char16_t *s)\r\n{\r\nreturn utf16_strnlen(s, ~0UL);\r\n}\r\nstatic inline unsigned long\r\nutf16_strsize(efi_char16_t *data, unsigned long maxlength)\r\n{\r\nreturn utf16_strnlen(data, maxlength/sizeof(efi_char16_t)) * sizeof(efi_char16_t);\r\n}\r\nstatic inline int\r\nutf16_strncmp(const efi_char16_t *a, const efi_char16_t *b, size_t len)\r\n{\r\nwhile (1) {\r\nif (len == 0)\r\nreturn 0;\r\nif (*a < *b)\r\nreturn -1;\r\nif (*a > *b)\r\nreturn 1;\r\nif (*a == 0)\r\nreturn 0;\r\na++;\r\nb++;\r\nlen--;\r\n}\r\n}\r\nstatic bool\r\nvalidate_device_path(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nstruct efi_generic_dev_path *node;\r\nint offset = 0;\r\nnode = (struct efi_generic_dev_path *)buffer;\r\nif (len < sizeof(*node))\r\nreturn false;\r\nwhile (offset <= len - sizeof(*node) &&\r\nnode->length >= sizeof(*node) &&\r\nnode->length <= len - offset) {\r\noffset += node->length;\r\nif ((node->type == EFI_DEV_END_PATH ||\r\nnode->type == EFI_DEV_END_PATH2) &&\r\nnode->sub_type == EFI_DEV_END_ENTIRE)\r\nreturn true;\r\nnode = (struct efi_generic_dev_path *)(buffer + offset);\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nvalidate_boot_order(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nif ((len % 2) != 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nvalidate_load_option(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nu16 filepathlength;\r\nint i, desclength = 0, namelen;\r\nnamelen = utf16_strnlen(var->VariableName, sizeof(var->VariableName));\r\nfor (i = match; i < match+4; i++) {\r\nif (var->VariableName[i] > 127 ||\r\nhex_to_bin(var->VariableName[i] & 0xff) < 0)\r\nreturn true;\r\n}\r\nif (namelen > match + 4)\r\nreturn false;\r\nif (len < 8)\r\nreturn false;\r\nfilepathlength = buffer[4] | buffer[5] << 8;\r\ndesclength = utf16_strsize((efi_char16_t *)(buffer + 6), len - 6) + 2;\r\nif (!desclength)\r\nreturn false;\r\nif ((desclength + filepathlength + 6) > len)\r\nreturn false;\r\nreturn validate_device_path(var, match, buffer + desclength + 6,\r\nfilepathlength);\r\n}\r\nstatic bool\r\nvalidate_uint16(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nif (len != 2)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nvalidate_ascii_string(struct efi_variable *var, int match, u8 *buffer,\r\nunsigned long len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nif (buffer[i] > 127)\r\nreturn false;\r\nif (buffer[i] == 0)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\nvalidate_var(struct efi_variable *var, u8 *data, unsigned long len)\r\n{\r\nint i;\r\nu16 *unicode_name = var->VariableName;\r\nfor (i = 0; variable_validate[i].validate != NULL; i++) {\r\nconst char *name = variable_validate[i].name;\r\nint match;\r\nfor (match = 0; ; match++) {\r\nchar c = name[match];\r\nu16 u = unicode_name[match];\r\nif (u > 127)\r\nreturn true;\r\nif (c == '*')\r\nreturn variable_validate[i].validate(var,\r\nmatch, data, len);\r\nif (c != u)\r\nbreak;\r\nif (!c)\r\nreturn variable_validate[i].validate(var,\r\nmatch, data, len);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic efi_status_t\r\nget_var_data_locked(struct efivars *efivars, struct efi_variable *var)\r\n{\r\nefi_status_t status;\r\nvar->DataSize = 1024;\r\nstatus = efivars->ops->get_variable(var->VariableName,\r\n&var->VendorGuid,\r\n&var->Attributes,\r\n&var->DataSize,\r\nvar->Data);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nget_var_data(struct efivars *efivars, struct efi_variable *var)\r\n{\r\nefi_status_t status;\r\nspin_lock(&efivars->lock);\r\nstatus = get_var_data_locked(efivars, var);\r\nspin_unlock(&efivars->lock);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_WARNING "efivars: get_variable() failed 0x%lx!\n",\r\nstatus);\r\n}\r\nreturn status;\r\n}\r\nstatic ssize_t\r\nefivar_guid_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nchar *str = buf;\r\nif (!entry || !buf)\r\nreturn 0;\r\nefi_guid_unparse(&var->VendorGuid, str);\r\nstr += strlen(str);\r\nstr += sprintf(str, "\n");\r\nreturn str - buf;\r\n}\r\nstatic ssize_t\r\nefivar_attr_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nchar *str = buf;\r\nefi_status_t status;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nstatus = get_var_data(entry->efivars, var);\r\nif (status != EFI_SUCCESS)\r\nreturn -EIO;\r\nif (var->Attributes & 0x1)\r\nstr += sprintf(str, "EFI_VARIABLE_NON_VOLATILE\n");\r\nif (var->Attributes & 0x2)\r\nstr += sprintf(str, "EFI_VARIABLE_BOOTSERVICE_ACCESS\n");\r\nif (var->Attributes & 0x4)\r\nstr += sprintf(str, "EFI_VARIABLE_RUNTIME_ACCESS\n");\r\nreturn str - buf;\r\n}\r\nstatic ssize_t\r\nefivar_size_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nchar *str = buf;\r\nefi_status_t status;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nstatus = get_var_data(entry->efivars, var);\r\nif (status != EFI_SUCCESS)\r\nreturn -EIO;\r\nstr += sprintf(str, "0x%lx\n", var->DataSize);\r\nreturn str - buf;\r\n}\r\nstatic ssize_t\r\nefivar_data_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nefi_status_t status;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nstatus = get_var_data(entry->efivars, var);\r\nif (status != EFI_SUCCESS)\r\nreturn -EIO;\r\nmemcpy(buf, var->Data, var->DataSize);\r\nreturn var->DataSize;\r\n}\r\nstatic ssize_t\r\nefivar_store_raw(struct efivar_entry *entry, const char *buf, size_t count)\r\n{\r\nstruct efi_variable *new_var, *var = &entry->var;\r\nstruct efivars *efivars = entry->efivars;\r\nefi_status_t status = EFI_NOT_FOUND;\r\nif (count != sizeof(struct efi_variable))\r\nreturn -EINVAL;\r\nnew_var = (struct efi_variable *)buf;\r\nif (memcmp(new_var->VariableName, var->VariableName, sizeof(var->VariableName)) ||\r\nefi_guidcmp(new_var->VendorGuid, var->VendorGuid)) {\r\nprintk(KERN_ERR "efivars: Cannot edit the wrong variable!\n");\r\nreturn -EINVAL;\r\n}\r\nif ((new_var->DataSize <= 0) || (new_var->Attributes == 0)){\r\nprintk(KERN_ERR "efivars: DataSize & Attributes must be valid!\n");\r\nreturn -EINVAL;\r\n}\r\nif ((new_var->Attributes & ~EFI_VARIABLE_MASK) != 0 ||\r\nvalidate_var(new_var, new_var->Data, new_var->DataSize) == false) {\r\nprintk(KERN_ERR "efivars: Malformed variable content\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&efivars->lock);\r\nstatus = efivars->ops->set_variable(new_var->VariableName,\r\n&new_var->VendorGuid,\r\nnew_var->Attributes,\r\nnew_var->DataSize,\r\nnew_var->Data);\r\nspin_unlock(&efivars->lock);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_WARNING "efivars: set_variable() failed: status=%lx\n",\r\nstatus);\r\nreturn -EIO;\r\n}\r\nmemcpy(&entry->var, new_var, count);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nefivar_show_raw(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nefi_status_t status;\r\nif (!entry || !buf)\r\nreturn 0;\r\nstatus = get_var_data(entry->efivars, var);\r\nif (status != EFI_SUCCESS)\r\nreturn -EIO;\r\nmemcpy(buf, var, sizeof(*var));\r\nreturn sizeof(*var);\r\n}\r\nstatic ssize_t efivar_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efivar_entry *var = to_efivar_entry(kobj);\r\nstruct efivar_attribute *efivar_attr = to_efivar_attr(attr);\r\nssize_t ret = -EIO;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (efivar_attr->show) {\r\nret = efivar_attr->show(var, buf);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t efivar_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct efivar_entry *var = to_efivar_entry(kobj);\r\nstruct efivar_attribute *efivar_attr = to_efivar_attr(attr);\r\nssize_t ret = -EIO;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (efivar_attr->store)\r\nret = efivar_attr->store(var, buf, count);\r\nreturn ret;\r\n}\r\nstatic void efivar_release(struct kobject *kobj)\r\n{\r\nstruct efivar_entry *var = container_of(kobj, struct efivar_entry, kobj);\r\nkfree(var);\r\n}\r\nstatic inline void\r\nefivar_unregister(struct efivar_entry *var)\r\n{\r\nkobject_put(&var->kobj);\r\n}\r\nstatic int efi_pstore_open(struct pstore_info *psi)\r\n{\r\nstruct efivars *efivars = psi->data;\r\nspin_lock(&efivars->lock);\r\nefivars->walk_entry = list_first_entry(&efivars->list,\r\nstruct efivar_entry, list);\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_close(struct pstore_info *psi)\r\n{\r\nstruct efivars *efivars = psi->data;\r\nspin_unlock(&efivars->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t efi_pstore_read(u64 *id, enum pstore_type_id *type,\r\nstruct timespec *timespec,\r\nchar **buf, struct pstore_info *psi)\r\n{\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nstruct efivars *efivars = psi->data;\r\nchar name[DUMP_NAME_LEN];\r\nint i;\r\nunsigned int part, size;\r\nunsigned long time;\r\nwhile (&efivars->walk_entry->list != &efivars->list) {\r\nif (!efi_guidcmp(efivars->walk_entry->var.VendorGuid,\r\nvendor)) {\r\nfor (i = 0; i < DUMP_NAME_LEN; i++) {\r\nname[i] = efivars->walk_entry->var.VariableName[i];\r\n}\r\nif (sscanf(name, "dump-type%u-%u-%lu", type, &part, &time) == 3) {\r\n*id = part;\r\ntimespec->tv_sec = time;\r\ntimespec->tv_nsec = 0;\r\nget_var_data_locked(efivars, &efivars->walk_entry->var);\r\nsize = efivars->walk_entry->var.DataSize;\r\n*buf = kmalloc(size, GFP_KERNEL);\r\nif (*buf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*buf, efivars->walk_entry->var.Data,\r\nsize);\r\nefivars->walk_entry = list_entry(efivars->walk_entry->list.next,\r\nstruct efivar_entry, list);\r\nreturn size;\r\n}\r\n}\r\nefivars->walk_entry = list_entry(efivars->walk_entry->list.next,\r\nstruct efivar_entry, list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_write(enum pstore_type_id type,\r\nenum kmsg_dump_reason reason, u64 *id,\r\nunsigned int part, size_t size, struct pstore_info *psi)\r\n{\r\nchar name[DUMP_NAME_LEN];\r\nchar stub_name[DUMP_NAME_LEN];\r\nefi_char16_t efi_name[DUMP_NAME_LEN];\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nstruct efivars *efivars = psi->data;\r\nstruct efivar_entry *entry, *found = NULL;\r\nint i, ret = 0;\r\nsprintf(stub_name, "dump-type%u-%u-", type, part);\r\nsprintf(name, "%s%lu", stub_name, get_seconds());\r\nspin_lock(&efivars->lock);\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nefi_name[i] = stub_name[i];\r\nlist_for_each_entry(entry, &efivars->list, list) {\r\nget_var_data_locked(efivars, &entry->var);\r\nif (efi_guidcmp(entry->var.VendorGuid, vendor))\r\ncontinue;\r\nif (utf16_strncmp(entry->var.VariableName, efi_name,\r\nutf16_strlen(efi_name)))\r\ncontinue;\r\nif (entry->var.VariableName[utf16_strlen(efi_name)] == 0)\r\ncontinue;\r\nfound = entry;\r\nefivars->ops->set_variable(entry->var.VariableName,\r\n&entry->var.VendorGuid,\r\nPSTORE_EFI_ATTRIBUTES,\r\n0, NULL);\r\n}\r\nif (found)\r\nlist_del(&found->list);\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nefi_name[i] = name[i];\r\nefivars->ops->set_variable(efi_name, &vendor, PSTORE_EFI_ATTRIBUTES,\r\nsize, psi->buf);\r\nspin_unlock(&efivars->lock);\r\nif (found)\r\nefivar_unregister(found);\r\nif (size)\r\nret = efivar_create_sysfs_entry(efivars,\r\nutf16_strsize(efi_name,\r\nDUMP_NAME_LEN * 2),\r\nefi_name, &vendor);\r\n*id = part;\r\nreturn ret;\r\n}\r\nstatic int efi_pstore_erase(enum pstore_type_id type, u64 id,\r\nstruct pstore_info *psi)\r\n{\r\nefi_pstore_write(type, 0, &id, (unsigned int)id, 0, psi);\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_open(struct pstore_info *psi)\r\n{\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_close(struct pstore_info *psi)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t efi_pstore_read(u64 *id, enum pstore_type_id *type,\r\nstruct timespec *timespec,\r\nchar **buf, struct pstore_info *psi)\r\n{\r\nreturn -1;\r\n}\r\nstatic int efi_pstore_write(enum pstore_type_id type,\r\nenum kmsg_dump_reason reason, u64 *id,\r\nunsigned int part, size_t size, struct pstore_info *psi)\r\n{\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_erase(enum pstore_type_id type, u64 id,\r\nstruct pstore_info *psi)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t efivar_create(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct efi_variable *new_var = (struct efi_variable *)buf;\r\nstruct efivars *efivars = bin_attr->private;\r\nstruct efivar_entry *search_efivar, *n;\r\nunsigned long strsize1, strsize2;\r\nefi_status_t status = EFI_NOT_FOUND;\r\nint found = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif ((new_var->Attributes & ~EFI_VARIABLE_MASK) != 0 ||\r\nvalidate_var(new_var, new_var->Data, new_var->DataSize) == false) {\r\nprintk(KERN_ERR "efivars: Malformed variable content\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&efivars->lock);\r\nlist_for_each_entry_safe(search_efivar, n, &efivars->list, list) {\r\nstrsize1 = utf16_strsize(search_efivar->var.VariableName, 1024);\r\nstrsize2 = utf16_strsize(new_var->VariableName, 1024);\r\nif (strsize1 == strsize2 &&\r\n!memcmp(&(search_efivar->var.VariableName),\r\nnew_var->VariableName, strsize1) &&\r\n!efi_guidcmp(search_efivar->var.VendorGuid,\r\nnew_var->VendorGuid)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nspin_unlock(&efivars->lock);\r\nreturn -EINVAL;\r\n}\r\nstatus = efivars->ops->set_variable(new_var->VariableName,\r\n&new_var->VendorGuid,\r\nnew_var->Attributes,\r\nnew_var->DataSize,\r\nnew_var->Data);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_WARNING "efivars: set_variable() failed: status=%lx\n",\r\nstatus);\r\nspin_unlock(&efivars->lock);\r\nreturn -EIO;\r\n}\r\nspin_unlock(&efivars->lock);\r\nstatus = efivar_create_sysfs_entry(efivars,\r\nutf16_strsize(new_var->VariableName,\r\n1024),\r\nnew_var->VariableName,\r\n&new_var->VendorGuid);\r\nif (status) {\r\nprintk(KERN_WARNING "efivars: variable created, but sysfs entry wasn't.\n");\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t efivar_delete(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct efi_variable *del_var = (struct efi_variable *)buf;\r\nstruct efivars *efivars = bin_attr->private;\r\nstruct efivar_entry *search_efivar, *n;\r\nunsigned long strsize1, strsize2;\r\nefi_status_t status = EFI_NOT_FOUND;\r\nint found = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nspin_lock(&efivars->lock);\r\nlist_for_each_entry_safe(search_efivar, n, &efivars->list, list) {\r\nstrsize1 = utf16_strsize(search_efivar->var.VariableName, 1024);\r\nstrsize2 = utf16_strsize(del_var->VariableName, 1024);\r\nif (strsize1 == strsize2 &&\r\n!memcmp(&(search_efivar->var.VariableName),\r\ndel_var->VariableName, strsize1) &&\r\n!efi_guidcmp(search_efivar->var.VendorGuid,\r\ndel_var->VendorGuid)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nspin_unlock(&efivars->lock);\r\nreturn -EINVAL;\r\n}\r\ndel_var->Attributes = 0;\r\ndel_var->DataSize = 0;\r\nstatus = efivars->ops->set_variable(del_var->VariableName,\r\n&del_var->VendorGuid,\r\ndel_var->Attributes,\r\ndel_var->DataSize,\r\ndel_var->Data);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_WARNING "efivars: set_variable() failed: status=%lx\n",\r\nstatus);\r\nspin_unlock(&efivars->lock);\r\nreturn -EIO;\r\n}\r\nlist_del(&search_efivar->list);\r\nspin_unlock(&efivars->lock);\r\nefivar_unregister(search_efivar);\r\nreturn count;\r\n}\r\nstatic ssize_t systab_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nchar *str = buf;\r\nif (!kobj || !buf)\r\nreturn -EINVAL;\r\nif (efi.mps != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "MPS=0x%lx\n", efi.mps);\r\nif (efi.acpi20 != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "ACPI20=0x%lx\n", efi.acpi20);\r\nif (efi.acpi != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "ACPI=0x%lx\n", efi.acpi);\r\nif (efi.smbios != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "SMBIOS=0x%lx\n", efi.smbios);\r\nif (efi.hcdp != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "HCDP=0x%lx\n", efi.hcdp);\r\nif (efi.boot_info != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "BOOTINFO=0x%lx\n", efi.boot_info);\r\nif (efi.uga != EFI_INVALID_TABLE_ADDR)\r\nstr += sprintf(str, "UGA=0x%lx\n", efi.uga);\r\nreturn str - buf;\r\n}\r\nstatic int\r\nefivar_create_sysfs_entry(struct efivars *efivars,\r\nunsigned long variable_name_size,\r\nefi_char16_t *variable_name,\r\nefi_guid_t *vendor_guid)\r\n{\r\nint i, short_name_size = variable_name_size / sizeof(efi_char16_t) + 38;\r\nchar *short_name;\r\nstruct efivar_entry *new_efivar;\r\nshort_name = kzalloc(short_name_size + 1, GFP_KERNEL);\r\nnew_efivar = kzalloc(sizeof(struct efivar_entry), GFP_KERNEL);\r\nif (!short_name || !new_efivar) {\r\nkfree(short_name);\r\nkfree(new_efivar);\r\nreturn 1;\r\n}\r\nnew_efivar->efivars = efivars;\r\nmemcpy(new_efivar->var.VariableName, variable_name,\r\nvariable_name_size);\r\nmemcpy(&(new_efivar->var.VendorGuid), vendor_guid, sizeof(efi_guid_t));\r\nfor (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {\r\nshort_name[i] = variable_name[i] & 0xFF;\r\n}\r\n*(short_name + strlen(short_name)) = '-';\r\nefi_guid_unparse(vendor_guid, short_name + strlen(short_name));\r\nnew_efivar->kobj.kset = efivars->kset;\r\ni = kobject_init_and_add(&new_efivar->kobj, &efivar_ktype, NULL,\r\n"%s", short_name);\r\nif (i) {\r\nkfree(short_name);\r\nkfree(new_efivar);\r\nreturn 1;\r\n}\r\nkobject_uevent(&new_efivar->kobj, KOBJ_ADD);\r\nkfree(short_name);\r\nshort_name = NULL;\r\nspin_lock(&efivars->lock);\r\nlist_add(&new_efivar->list, &efivars->list);\r\nspin_unlock(&efivars->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\ncreate_efivars_bin_attributes(struct efivars *efivars)\r\n{\r\nstruct bin_attribute *attr;\r\nint error;\r\nattr = kzalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nattr->attr.name = "new_var";\r\nattr->attr.mode = 0200;\r\nattr->write = efivar_create;\r\nattr->private = efivars;\r\nefivars->new_var = attr;\r\nattr = kzalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr) {\r\nerror = -ENOMEM;\r\ngoto out_free;\r\n}\r\nattr->attr.name = "del_var";\r\nattr->attr.mode = 0200;\r\nattr->write = efivar_delete;\r\nattr->private = efivars;\r\nefivars->del_var = attr;\r\nsysfs_bin_attr_init(efivars->new_var);\r\nsysfs_bin_attr_init(efivars->del_var);\r\nerror = sysfs_create_bin_file(&efivars->kset->kobj,\r\nefivars->new_var);\r\nif (error) {\r\nprintk(KERN_ERR "efivars: unable to create new_var sysfs file"\r\n" due to error %d\n", error);\r\ngoto out_free;\r\n}\r\nerror = sysfs_create_bin_file(&efivars->kset->kobj,\r\nefivars->del_var);\r\nif (error) {\r\nprintk(KERN_ERR "efivars: unable to create del_var sysfs file"\r\n" due to error %d\n", error);\r\nsysfs_remove_bin_file(&efivars->kset->kobj,\r\nefivars->new_var);\r\ngoto out_free;\r\n}\r\nreturn 0;\r\nout_free:\r\nkfree(efivars->del_var);\r\nefivars->del_var = NULL;\r\nkfree(efivars->new_var);\r\nefivars->new_var = NULL;\r\nreturn error;\r\n}\r\nvoid unregister_efivars(struct efivars *efivars)\r\n{\r\nstruct efivar_entry *entry, *n;\r\nlist_for_each_entry_safe(entry, n, &efivars->list, list) {\r\nspin_lock(&efivars->lock);\r\nlist_del(&entry->list);\r\nspin_unlock(&efivars->lock);\r\nefivar_unregister(entry);\r\n}\r\nif (efivars->new_var)\r\nsysfs_remove_bin_file(&efivars->kset->kobj, efivars->new_var);\r\nif (efivars->del_var)\r\nsysfs_remove_bin_file(&efivars->kset->kobj, efivars->del_var);\r\nkfree(efivars->new_var);\r\nkfree(efivars->del_var);\r\nkset_unregister(efivars->kset);\r\n}\r\nint register_efivars(struct efivars *efivars,\r\nconst struct efivar_operations *ops,\r\nstruct kobject *parent_kobj)\r\n{\r\nefi_status_t status = EFI_NOT_FOUND;\r\nefi_guid_t vendor_guid;\r\nefi_char16_t *variable_name;\r\nunsigned long variable_name_size = 1024;\r\nint error = 0;\r\nvariable_name = kzalloc(variable_name_size, GFP_KERNEL);\r\nif (!variable_name) {\r\nprintk(KERN_ERR "efivars: Memory allocation failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&efivars->lock);\r\nINIT_LIST_HEAD(&efivars->list);\r\nefivars->ops = ops;\r\nefivars->kset = kset_create_and_add("vars", NULL, parent_kobj);\r\nif (!efivars->kset) {\r\nprintk(KERN_ERR "efivars: Subsystem registration failed.\n");\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ndo {\r\nvariable_name_size = 1024;\r\nstatus = ops->get_next_variable(&variable_name_size,\r\nvariable_name,\r\n&vendor_guid);\r\nswitch (status) {\r\ncase EFI_SUCCESS:\r\nefivar_create_sysfs_entry(efivars,\r\nvariable_name_size,\r\nvariable_name,\r\n&vendor_guid);\r\nbreak;\r\ncase EFI_NOT_FOUND:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "efivars: get_next_variable: status=%lx\n",\r\nstatus);\r\nstatus = EFI_NOT_FOUND;\r\nbreak;\r\n}\r\n} while (status != EFI_NOT_FOUND);\r\nerror = create_efivars_bin_attributes(efivars);\r\nif (error)\r\nunregister_efivars(efivars);\r\nefivars->efi_pstore_info = efi_pstore_info;\r\nefivars->efi_pstore_info.buf = kmalloc(4096, GFP_KERNEL);\r\nif (efivars->efi_pstore_info.buf) {\r\nefivars->efi_pstore_info.bufsize = 1024;\r\nefivars->efi_pstore_info.data = efivars;\r\nspin_lock_init(&efivars->efi_pstore_info.buf_lock);\r\npstore_register(&efivars->efi_pstore_info);\r\n}\r\nout:\r\nkfree(variable_name);\r\nreturn error;\r\n}\r\nstatic int __init\r\nefivars_init(void)\r\n{\r\nint error = 0;\r\nprintk(KERN_INFO "EFI Variables Facility v%s %s\n", EFIVARS_VERSION,\r\nEFIVARS_DATE);\r\nif (!efi_enabled)\r\nreturn 0;\r\nefi_kobj = kobject_create_and_add("efi", firmware_kobj);\r\nif (!efi_kobj) {\r\nprintk(KERN_ERR "efivars: Firmware registration failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nops.get_variable = efi.get_variable;\r\nops.set_variable = efi.set_variable;\r\nops.get_next_variable = efi.get_next_variable;\r\nerror = register_efivars(&__efivars, &ops, efi_kobj);\r\nif (error)\r\ngoto err_put;\r\nerror = sysfs_create_group(efi_kobj, &efi_subsys_attr_group);\r\nif (error) {\r\nprintk(KERN_ERR\r\n"efivars: Sysfs attribute export failed with error %d.\n",\r\nerror);\r\ngoto err_unregister;\r\n}\r\nreturn 0;\r\nerr_unregister:\r\nunregister_efivars(&__efivars);\r\nerr_put:\r\nkobject_put(efi_kobj);\r\nreturn error;\r\n}\r\nstatic void __exit\r\nefivars_exit(void)\r\n{\r\nif (efi_enabled) {\r\nunregister_efivars(&__efivars);\r\nkobject_put(efi_kobj);\r\n}\r\n}
