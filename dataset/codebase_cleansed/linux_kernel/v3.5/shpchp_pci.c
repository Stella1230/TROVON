int __ref shpchp_configure_device(struct slot *p_slot)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pci_bus *parent = p_slot->ctrl->pci_dev->subordinate;\r\nint num, fn;\r\nstruct controller *ctrl = p_slot->ctrl;\r\ndev = pci_get_slot(parent, PCI_DEVFN(p_slot->device, 0));\r\nif (dev) {\r\nctrl_err(ctrl, "Device %s already exists "\r\n"at %04x:%02x:%02x, cannot hot-add\n", pci_name(dev),\r\npci_domain_nr(parent), p_slot->bus, p_slot->device);\r\npci_dev_put(dev);\r\nreturn -EINVAL;\r\n}\r\nnum = pci_scan_slot(parent, PCI_DEVFN(p_slot->device, 0));\r\nif (num == 0) {\r\nctrl_err(ctrl, "No new device found\n");\r\nreturn -ENODEV;\r\n}\r\nfor (fn = 0; fn < 8; fn++) {\r\ndev = pci_get_slot(parent, PCI_DEVFN(p_slot->device, fn));\r\nif (!dev)\r\ncontinue;\r\nif ((dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) ||\r\n(dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)) {\r\nstruct pci_bus *child;\r\nunsigned char busnr, start = parent->secondary;\r\nunsigned char end = parent->subordinate;\r\nfor (busnr = start; busnr <= end; busnr++) {\r\nif (!pci_find_bus(pci_domain_nr(parent),\r\nbusnr))\r\nbreak;\r\n}\r\nif (busnr > end) {\r\nctrl_err(ctrl,\r\n"No free bus for hot-added bridge\n");\r\npci_dev_put(dev);\r\ncontinue;\r\n}\r\nchild = pci_add_new_bus(parent, dev, busnr);\r\nif (!child) {\r\nctrl_err(ctrl, "Cannot add new bus for %s\n",\r\npci_name(dev));\r\npci_dev_put(dev);\r\ncontinue;\r\n}\r\nchild->subordinate = pci_do_scan_bus(child);\r\npci_bus_size_bridges(child);\r\n}\r\npci_configure_slot(dev);\r\npci_dev_put(dev);\r\n}\r\npci_bus_assign_resources(parent);\r\npci_bus_add_devices(parent);\r\npci_enable_bridges(parent);\r\nreturn 0;\r\n}\r\nint shpchp_unconfigure_device(struct slot *p_slot)\r\n{\r\nint rc = 0;\r\nint j;\r\nu8 bctl = 0;\r\nstruct pci_bus *parent = p_slot->ctrl->pci_dev->subordinate;\r\nstruct controller *ctrl = p_slot->ctrl;\r\nctrl_dbg(ctrl, "%s: domain:bus:dev = %04x:%02x:%02x\n",\r\n__func__, pci_domain_nr(parent), p_slot->bus, p_slot->device);\r\nfor (j = 0; j < 8 ; j++) {\r\nstruct pci_dev *temp = pci_get_slot(parent,\r\n(p_slot->device << 3) | j);\r\nif (!temp)\r\ncontinue;\r\nif (temp->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\r\npci_read_config_byte(temp, PCI_BRIDGE_CONTROL, &bctl);\r\nif (bctl & PCI_BRIDGE_CTL_VGA) {\r\nctrl_err(ctrl,\r\n"Cannot remove display device %s\n",\r\npci_name(temp));\r\npci_dev_put(temp);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\npci_stop_and_remove_bus_device(temp);\r\npci_dev_put(temp);\r\n}\r\nreturn rc;\r\n}
