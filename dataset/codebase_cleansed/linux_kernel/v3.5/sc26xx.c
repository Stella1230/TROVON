static inline u8 read_sc_port(struct uart_port *p, u8 reg)\r\n{\r\nreturn readb(p->membase + p->line * 0x20 + reg);\r\n}\r\nstatic inline void write_sc_port(struct uart_port *p, u8 reg, u8 val)\r\n{\r\nwriteb(val, p->membase + p->line * 0x20 + reg);\r\n}\r\nstatic void sc26xx_enable_irq(struct uart_port *port, int mask)\r\n{\r\nstruct uart_sc26xx_port *up;\r\nint line = port->line;\r\nport -= line;\r\nup = container_of(port, struct uart_sc26xx_port, port[0]);\r\nup->imr |= mask << (line * 4);\r\nWRITE_SC(port, IMR, up->imr);\r\n}\r\nstatic void sc26xx_disable_irq(struct uart_port *port, int mask)\r\n{\r\nstruct uart_sc26xx_port *up;\r\nint line = port->line;\r\nport -= line;\r\nup = container_of(port, struct uart_sc26xx_port, port[0]);\r\nup->imr &= ~(mask << (line * 4));\r\nWRITE_SC(port, IMR, up->imr);\r\n}\r\nstatic struct tty_struct *receive_chars(struct uart_port *port)\r\n{\r\nstruct tty_struct *tty = NULL;\r\nint limit = 10000;\r\nunsigned char ch;\r\nchar flag;\r\nu8 status;\r\nif (port->state != NULL)\r\ntty = port->state->port.tty;\r\nwhile (limit-- > 0) {\r\nstatus = READ_SC_PORT(port, SR);\r\nif (!(status & SR_RXRDY))\r\nbreak;\r\nch = READ_SC_PORT(port, RHR);\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif (unlikely(status & (SR_BREAK | SR_FRAME |\r\nSR_PARITY | SR_OVERRUN))) {\r\nif (status & SR_BREAK) {\r\nstatus &= ~(SR_PARITY | SR_FRAME);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (status & SR_PARITY)\r\nport->icount.parity++;\r\nelse if (status & SR_FRAME)\r\nport->icount.frame++;\r\nif (status & SR_OVERRUN)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & SR_BREAK)\r\nflag = TTY_BREAK;\r\nelse if (status & SR_PARITY)\r\nflag = TTY_PARITY;\r\nelse if (status & SR_FRAME)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nif (status & port->ignore_status_mask)\r\ncontinue;\r\ntty_insert_flip_char(tty, ch, flag);\r\n}\r\nreturn tty;\r\n}\r\nstatic void transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit;\r\nif (!port->state)\r\nreturn;\r\nxmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\nsc26xx_disable_irq(port, IMR_TXRDY);\r\nreturn;\r\n}\r\nwhile (!uart_circ_empty(xmit)) {\r\nif (!(READ_SC_PORT(port, SR) & SR_TXRDY))\r\nbreak;\r\nWRITE_SC_PORT(port, THR, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic irqreturn_t sc26xx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_sc26xx_port *up = dev_id;\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\nu8 isr;\r\nspin_lock_irqsave(&up->port[0].lock, flags);\r\ntty = NULL;\r\nisr = READ_SC(&up->port[0], ISR);\r\nif (isr & ISR_TXRDYA)\r\ntransmit_chars(&up->port[0]);\r\nif (isr & ISR_RXRDYA)\r\ntty = receive_chars(&up->port[0]);\r\nspin_unlock(&up->port[0].lock);\r\nif (tty)\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&up->port[1].lock);\r\ntty = NULL;\r\nif (isr & ISR_TXRDYB)\r\ntransmit_chars(&up->port[1]);\r\nif (isr & ISR_RXRDYB)\r\ntty = receive_chars(&up->port[1]);\r\nspin_unlock_irqrestore(&up->port[1].lock, flags);\r\nif (tty)\r\ntty_flip_buffer_push(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sc26xx_tx_empty(struct uart_port *port)\r\n{\r\nreturn (READ_SC_PORT(port, SR) & SR_TXRDY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void sc26xx_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_sc26xx_port *up;\r\nint line = port->line;\r\nport -= line;\r\nup = container_of(port, struct uart_sc26xx_port, port[0]);\r\nif (up->dtr_mask[line]) {\r\nif (mctrl & TIOCM_DTR)\r\nWRITE_SC(port, OPR_SET, up->dtr_mask[line]);\r\nelse\r\nWRITE_SC(port, OPR_CLR, up->dtr_mask[line]);\r\n}\r\nif (up->rts_mask[line]) {\r\nif (mctrl & TIOCM_RTS)\r\nWRITE_SC(port, OPR_SET, up->rts_mask[line]);\r\nelse\r\nWRITE_SC(port, OPR_CLR, up->rts_mask[line]);\r\n}\r\n}\r\nstatic unsigned int sc26xx_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_sc26xx_port *up;\r\nint line = port->line;\r\nunsigned int mctrl = TIOCM_DSR | TIOCM_CTS | TIOCM_CAR;\r\nu8 ipr;\r\nport -= line;\r\nup = container_of(port, struct uart_sc26xx_port, port[0]);\r\nipr = READ_SC(port, IPR) ^ 0xff;\r\nif (up->dsr_mask[line]) {\r\nmctrl &= ~TIOCM_DSR;\r\nmctrl |= ipr & up->dsr_mask[line] ? TIOCM_DSR : 0;\r\n}\r\nif (up->cts_mask[line]) {\r\nmctrl &= ~TIOCM_CTS;\r\nmctrl |= ipr & up->cts_mask[line] ? TIOCM_CTS : 0;\r\n}\r\nif (up->dcd_mask[line]) {\r\nmctrl &= ~TIOCM_CAR;\r\nmctrl |= ipr & up->dcd_mask[line] ? TIOCM_CAR : 0;\r\n}\r\nif (up->ri_mask[line]) {\r\nmctrl &= ~TIOCM_RNG;\r\nmctrl |= ipr & up->ri_mask[line] ? TIOCM_RNG : 0;\r\n}\r\nreturn mctrl;\r\n}\r\nstatic void sc26xx_stop_tx(struct uart_port *port)\r\n{\r\nreturn;\r\n}\r\nstatic void sc26xx_start_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nwhile (!uart_circ_empty(xmit)) {\r\nif (!(READ_SC_PORT(port, SR) & SR_TXRDY)) {\r\nsc26xx_enable_irq(port, IMR_TXRDY);\r\nbreak;\r\n}\r\nWRITE_SC_PORT(port, THR, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\n}\r\nstatic void sc26xx_stop_rx(struct uart_port *port)\r\n{\r\n}\r\nstatic void sc26xx_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void sc26xx_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nif (break_state == -1)\r\nWRITE_SC_PORT(port, CR, CR_STRT_BRK);\r\nelse\r\nWRITE_SC_PORT(port, CR, CR_STOP_BRK);\r\n}\r\nstatic int sc26xx_startup(struct uart_port *port)\r\n{\r\nsc26xx_disable_irq(port, IMR_TXRDY | IMR_RXRDY);\r\nWRITE_SC(port, OPCR, 0);\r\nWRITE_SC_PORT(port, CR, CR_RES_RX);\r\nWRITE_SC_PORT(port, CR, CR_RES_TX);\r\nWRITE_SC_PORT(port, CR, CR_ENA_TX | CR_ENA_RX);\r\nsc26xx_enable_irq(port, IMR_RXRDY);\r\nreturn 0;\r\n}\r\nstatic void sc26xx_shutdown(struct uart_port *port)\r\n{\r\nsc26xx_disable_irq(port, IMR_TXRDY | IMR_RXRDY);\r\nWRITE_SC_PORT(port, CR, CR_DIS_TX | CR_DIS_RX);\r\n}\r\nstatic void sc26xx_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nunsigned int quot = uart_get_divisor(port, baud);\r\nunsigned int iflag, cflag;\r\nunsigned long flags;\r\nu8 mr1, mr2, csr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile ((READ_SC_PORT(port, SR) & ((1 << 3) | (1 << 2))) != 0xc)\r\nudelay(2);\r\nWRITE_SC_PORT(port, CR, CR_DIS_TX | CR_DIS_RX);\r\niflag = termios->c_iflag;\r\ncflag = termios->c_cflag;\r\nport->read_status_mask = SR_OVERRUN;\r\nif (iflag & INPCK)\r\nport->read_status_mask |= SR_PARITY | SR_FRAME;\r\nif (iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= SR_BREAK;\r\nport->ignore_status_mask = 0;\r\nif (iflag & IGNBRK)\r\nport->ignore_status_mask |= SR_BREAK;\r\nif ((cflag & CREAD) == 0)\r\nport->ignore_status_mask |= SR_BREAK | SR_FRAME |\r\nSR_PARITY | SR_OVERRUN;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nmr1 = 0x00;\r\nbreak;\r\ncase CS6:\r\nmr1 = 0x01;\r\nbreak;\r\ncase CS7:\r\nmr1 = 0x02;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nmr1 = 0x03;\r\nbreak;\r\n}\r\nmr2 = 0x07;\r\nif (cflag & CSTOPB)\r\nmr2 = 0x0f;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\nmr1 |= (1 << 2);\r\n} else\r\nmr1 |= (2 << 3);\r\nswitch (baud) {\r\ncase 50:\r\ncsr = 0x00;\r\nbreak;\r\ncase 110:\r\ncsr = 0x11;\r\nbreak;\r\ncase 134:\r\ncsr = 0x22;\r\nbreak;\r\ncase 200:\r\ncsr = 0x33;\r\nbreak;\r\ncase 300:\r\ncsr = 0x44;\r\nbreak;\r\ncase 600:\r\ncsr = 0x55;\r\nbreak;\r\ncase 1200:\r\ncsr = 0x66;\r\nbreak;\r\ncase 2400:\r\ncsr = 0x88;\r\nbreak;\r\ncase 4800:\r\ncsr = 0x99;\r\nbreak;\r\ndefault:\r\ncase 9600:\r\ncsr = 0xbb;\r\nbreak;\r\ncase 19200:\r\ncsr = 0xcc;\r\nbreak;\r\n}\r\nWRITE_SC_PORT(port, CR, CR_RES_MR);\r\nWRITE_SC_PORT(port, MRx, mr1);\r\nWRITE_SC_PORT(port, MRx, mr2);\r\nWRITE_SC(port, ACR, 0x80);\r\nWRITE_SC_PORT(port, CSR, csr);\r\nWRITE_SC_PORT(port, CR, CR_RES_RX);\r\nWRITE_SC_PORT(port, CR, CR_RES_TX);\r\nWRITE_SC_PORT(port, CR, CR_ENA_TX | CR_ENA_RX);\r\nwhile ((READ_SC_PORT(port, SR) & ((1 << 3) | (1 << 2))) != 0xc)\r\nudelay(2);\r\nuart_update_timeout(port, cflag,\r\n(port->uartclk / (16 * quot)));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *sc26xx_type(struct uart_port *port)\r\n{\r\nreturn "SC26XX";\r\n}\r\nstatic void sc26xx_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sc26xx_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sc26xx_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int sc26xx_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void sc26xx_console_putchar(struct uart_port *port, char c)\r\n{\r\nunsigned long flags;\r\nint limit = 1000000;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (limit-- > 0) {\r\nif (READ_SC_PORT(port, SR) & SR_TXRDY) {\r\nWRITE_SC_PORT(port, THR, c);\r\nbreak;\r\n}\r\nudelay(2);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void sc26xx_console_write(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct uart_port *port = sc26xx_port;\r\nint i;\r\nfor (i = 0; i < n; i++) {\r\nif (*s == '\n')\r\nsc26xx_console_putchar(port, '\r');\r\nsc26xx_console_putchar(port, *s++);\r\n}\r\n}\r\nstatic int __init sc26xx_console_setup(struct console *con, char *options)\r\n{\r\nstruct uart_port *port = sc26xx_port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (port->type != PORT_SC26XX)\r\nreturn -1;\r\nprintk(KERN_INFO "Console: ttySC%d (SC26XX)\n", con->index);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, con, baud, parity, bits, flow);\r\n}\r\nstatic u8 sc26xx_flags2mask(unsigned int flags, unsigned int bitpos)\r\n{\r\nunsigned int bit = (flags >> bitpos) & 15;\r\nreturn bit ? (1 << (bit - 1)) : 0;\r\n}\r\nstatic void __devinit sc26xx_init_masks(struct uart_sc26xx_port *up,\r\nint line, unsigned int data)\r\n{\r\nup->dtr_mask[line] = sc26xx_flags2mask(data, 0);\r\nup->rts_mask[line] = sc26xx_flags2mask(data, 4);\r\nup->dsr_mask[line] = sc26xx_flags2mask(data, 8);\r\nup->cts_mask[line] = sc26xx_flags2mask(data, 12);\r\nup->dcd_mask[line] = sc26xx_flags2mask(data, 16);\r\nup->ri_mask[line] = sc26xx_flags2mask(data, 20);\r\n}\r\nstatic int __devinit sc26xx_probe(struct platform_device *dev)\r\n{\r\nstruct resource *res;\r\nstruct uart_sc26xx_port *up;\r\nunsigned int *sc26xx_data = dev->dev.platform_data;\r\nint err;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nup = kzalloc(sizeof *up, GFP_KERNEL);\r\nif (unlikely(!up))\r\nreturn -ENOMEM;\r\nup->port[0].line = 0;\r\nup->port[0].ops = &sc26xx_ops;\r\nup->port[0].type = PORT_SC26XX;\r\nup->port[0].uartclk = (29491200 / 16);\r\nup->port[0].mapbase = res->start;\r\nup->port[0].membase = ioremap_nocache(up->port[0].mapbase, 0x40);\r\nup->port[0].iotype = UPIO_MEM;\r\nup->port[0].irq = platform_get_irq(dev, 0);\r\nup->port[0].dev = &dev->dev;\r\nsc26xx_init_masks(up, 0, sc26xx_data[0]);\r\nsc26xx_port = &up->port[0];\r\nup->port[1].line = 1;\r\nup->port[1].ops = &sc26xx_ops;\r\nup->port[1].type = PORT_SC26XX;\r\nup->port[1].uartclk = (29491200 / 16);\r\nup->port[1].mapbase = up->port[0].mapbase;\r\nup->port[1].membase = up->port[0].membase;\r\nup->port[1].iotype = UPIO_MEM;\r\nup->port[1].irq = up->port[0].irq;\r\nup->port[1].dev = &dev->dev;\r\nsc26xx_init_masks(up, 1, sc26xx_data[1]);\r\nerr = uart_register_driver(&sc26xx_reg);\r\nif (err)\r\ngoto out_free_port;\r\nsc26xx_reg.tty_driver->name_base = sc26xx_reg.minor;\r\nerr = uart_add_one_port(&sc26xx_reg, &up->port[0]);\r\nif (err)\r\ngoto out_unregister_driver;\r\nerr = uart_add_one_port(&sc26xx_reg, &up->port[1]);\r\nif (err)\r\ngoto out_remove_port0;\r\nerr = request_irq(up->port[0].irq, sc26xx_interrupt, 0, "sc26xx", up);\r\nif (err)\r\ngoto out_remove_ports;\r\ndev_set_drvdata(&dev->dev, up);\r\nreturn 0;\r\nout_remove_ports:\r\nuart_remove_one_port(&sc26xx_reg, &up->port[1]);\r\nout_remove_port0:\r\nuart_remove_one_port(&sc26xx_reg, &up->port[0]);\r\nout_unregister_driver:\r\nuart_unregister_driver(&sc26xx_reg);\r\nout_free_port:\r\nkfree(up);\r\nsc26xx_port = NULL;\r\nreturn err;\r\n}\r\nstatic int __exit sc26xx_driver_remove(struct platform_device *dev)\r\n{\r\nstruct uart_sc26xx_port *up = dev_get_drvdata(&dev->dev);\r\nfree_irq(up->port[0].irq, up);\r\nuart_remove_one_port(&sc26xx_reg, &up->port[0]);\r\nuart_remove_one_port(&sc26xx_reg, &up->port[1]);\r\nuart_unregister_driver(&sc26xx_reg);\r\nkfree(up);\r\nsc26xx_port = NULL;\r\ndev_set_drvdata(&dev->dev, NULL);\r\nreturn 0;\r\n}
