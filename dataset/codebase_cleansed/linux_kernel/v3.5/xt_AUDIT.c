static void audit_proto(struct audit_buffer *ab, struct sk_buff *skb,\r\nunsigned int proto, unsigned int offset)\r\n{\r\nswitch (proto) {\r\ncase IPPROTO_TCP:\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE: {\r\nconst __be16 *pptr;\r\n__be16 _ports[2];\r\npptr = skb_header_pointer(skb, offset, sizeof(_ports), _ports);\r\nif (pptr == NULL) {\r\naudit_log_format(ab, " truncated=1");\r\nreturn;\r\n}\r\naudit_log_format(ab, " sport=%hu dport=%hu",\r\nntohs(pptr[0]), ntohs(pptr[1]));\r\n}\r\nbreak;\r\ncase IPPROTO_ICMP:\r\ncase IPPROTO_ICMPV6: {\r\nconst u8 *iptr;\r\nu8 _ih[2];\r\niptr = skb_header_pointer(skb, offset, sizeof(_ih), &_ih);\r\nif (iptr == NULL) {\r\naudit_log_format(ab, " truncated=1");\r\nreturn;\r\n}\r\naudit_log_format(ab, " icmptype=%hhu icmpcode=%hhu",\r\niptr[0], iptr[1]);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void audit_ip4(struct audit_buffer *ab, struct sk_buff *skb)\r\n{\r\nstruct iphdr _iph;\r\nconst struct iphdr *ih;\r\nih = skb_header_pointer(skb, 0, sizeof(_iph), &_iph);\r\nif (!ih) {\r\naudit_log_format(ab, " truncated=1");\r\nreturn;\r\n}\r\naudit_log_format(ab, " saddr=%pI4 daddr=%pI4 ipid=%hu proto=%hhu",\r\n&ih->saddr, &ih->daddr, ntohs(ih->id), ih->protocol);\r\nif (ntohs(ih->frag_off) & IP_OFFSET) {\r\naudit_log_format(ab, " frag=1");\r\nreturn;\r\n}\r\naudit_proto(ab, skb, ih->protocol, ih->ihl * 4);\r\n}\r\nstatic void audit_ip6(struct audit_buffer *ab, struct sk_buff *skb)\r\n{\r\nstruct ipv6hdr _ip6h;\r\nconst struct ipv6hdr *ih;\r\nu8 nexthdr;\r\n__be16 frag_off;\r\nint offset;\r\nih = skb_header_pointer(skb, skb_network_offset(skb), sizeof(_ip6h), &_ip6h);\r\nif (!ih) {\r\naudit_log_format(ab, " truncated=1");\r\nreturn;\r\n}\r\nnexthdr = ih->nexthdr;\r\noffset = ipv6_skip_exthdr(skb, skb_network_offset(skb) + sizeof(_ip6h),\r\n&nexthdr, &frag_off);\r\naudit_log_format(ab, " saddr=%pI6c daddr=%pI6c proto=%hhu",\r\n&ih->saddr, &ih->daddr, nexthdr);\r\nif (offset)\r\naudit_proto(ab, skb, nexthdr, offset);\r\n}\r\nstatic unsigned int\r\naudit_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_audit_info *info = par->targinfo;\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(NULL, GFP_ATOMIC, AUDIT_NETFILTER_PKT);\r\nif (ab == NULL)\r\ngoto errout;\r\naudit_log_format(ab, "action=%hhu hook=%u len=%u inif=%s outif=%s",\r\ninfo->type, par->hooknum, skb->len,\r\npar->in ? par->in->name : "?",\r\npar->out ? par->out->name : "?");\r\nif (skb->mark)\r\naudit_log_format(ab, " mark=%#x", skb->mark);\r\nif (skb->dev && skb->dev->type == ARPHRD_ETHER) {\r\naudit_log_format(ab, " smac=%pM dmac=%pM macproto=0x%04x",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nif (par->family == NFPROTO_BRIDGE) {\r\nswitch (eth_hdr(skb)->h_proto) {\r\ncase __constant_htons(ETH_P_IP):\r\naudit_ip4(ab, skb);\r\nbreak;\r\ncase __constant_htons(ETH_P_IPV6):\r\naudit_ip6(ab, skb);\r\nbreak;\r\n}\r\n}\r\n}\r\nswitch (par->family) {\r\ncase NFPROTO_IPV4:\r\naudit_ip4(ab, skb);\r\nbreak;\r\ncase NFPROTO_IPV6:\r\naudit_ip6(ab, skb);\r\nbreak;\r\n}\r\n#ifdef CONFIG_NETWORK_SECMARK\r\nif (skb->secmark)\r\naudit_log_secctx(ab, skb->secmark);\r\n#endif\r\naudit_log_end(ab);\r\nerrout:\r\nreturn XT_CONTINUE;\r\n}\r\nstatic unsigned int\r\naudit_tg_ebt(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\naudit_tg(skb, par);\r\nreturn EBT_CONTINUE;\r\n}\r\nstatic int audit_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_audit_info *info = par->targinfo;\r\nif (info->type > XT_AUDIT_TYPE_MAX) {\r\npr_info("Audit type out of range (valid range: 0..%hhu)\n",\r\nXT_AUDIT_TYPE_MAX);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init audit_tg_init(void)\r\n{\r\nreturn xt_register_targets(audit_tg_reg, ARRAY_SIZE(audit_tg_reg));\r\n}\r\nstatic void __exit audit_tg_exit(void)\r\n{\r\nxt_unregister_targets(audit_tg_reg, ARRAY_SIZE(audit_tg_reg));\r\n}
