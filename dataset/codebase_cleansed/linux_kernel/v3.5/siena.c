static void siena_push_irq_moderation(struct efx_channel *channel)\r\n{\r\nefx_dword_t timer_cmd;\r\nif (channel->irq_moderation)\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_CZ_TC_TIMER_MODE,\r\nFFE_CZ_TIMER_MODE_INT_HLDOFF,\r\nFRF_CZ_TC_TIMER_VAL,\r\nchannel->irq_moderation - 1);\r\nelse\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_CZ_TC_TIMER_MODE,\r\nFFE_CZ_TIMER_MODE_DIS,\r\nFRF_CZ_TC_TIMER_VAL, 0);\r\nefx_writed_page_locked(channel->efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,\r\nchannel->channel);\r\n}\r\nstatic int siena_mdio_write(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr, u16 value)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nuint32_t status;\r\nint rc;\r\nrc = efx_mcdi_mdio_write(efx, efx->mdio_bus, prtad, devad,\r\naddr, value, &status);\r\nif (rc)\r\nreturn rc;\r\nif (status != MC_CMD_MDIO_STATUS_GOOD)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int siena_mdio_read(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nuint16_t value;\r\nuint32_t status;\r\nint rc;\r\nrc = efx_mcdi_mdio_read(efx, efx->mdio_bus, prtad, devad,\r\naddr, &value, &status);\r\nif (rc)\r\nreturn rc;\r\nif (status != MC_CMD_MDIO_STATUS_GOOD)\r\nreturn -EIO;\r\nreturn (int)value;\r\n}\r\nstatic int siena_probe_port(struct efx_nic *efx)\r\n{\r\nint rc;\r\nefx->phy_op = &efx_mcdi_phy_ops;\r\nefx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;\r\nefx->mdio.mdio_read = siena_mdio_read;\r\nefx->mdio.mdio_write = siena_mdio_write;\r\nrc = efx->phy_op->probe(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,\r\nMC_CMD_MAC_NSTATS * sizeof(u64));\r\nif (rc)\r\nreturn rc;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"stats buffer at %llx (virt %p phys %llx)\n",\r\n(u64)efx->stats_buffer.dma_addr,\r\nefx->stats_buffer.addr,\r\n(u64)virt_to_phys(efx->stats_buffer.addr));\r\nefx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr, 0, 0, 1);\r\nreturn 0;\r\n}\r\nstatic void siena_remove_port(struct efx_nic *efx)\r\n{\r\nefx->phy_op->remove(efx);\r\nefx_nic_free_buffer(efx, &efx->stats_buffer);\r\n}\r\nstatic int siena_test_registers(struct efx_nic *efx)\r\n{\r\nreturn efx_nic_test_registers(efx, siena_register_tests,\r\nARRAY_SIZE(siena_register_tests));\r\n}\r\nstatic enum reset_type siena_map_reset_reason(enum reset_type reason)\r\n{\r\nreturn RESET_TYPE_ALL;\r\n}\r\nstatic int siena_map_reset_flags(u32 *flags)\r\n{\r\nenum {\r\nSIENA_RESET_PORT = (ETH_RESET_DMA | ETH_RESET_FILTER |\r\nETH_RESET_OFFLOAD | ETH_RESET_MAC |\r\nETH_RESET_PHY),\r\nSIENA_RESET_MC = (SIENA_RESET_PORT |\r\nETH_RESET_MGMT << ETH_RESET_SHARED_SHIFT),\r\n};\r\nif ((*flags & SIENA_RESET_MC) == SIENA_RESET_MC) {\r\n*flags &= ~SIENA_RESET_MC;\r\nreturn RESET_TYPE_WORLD;\r\n}\r\nif ((*flags & SIENA_RESET_PORT) == SIENA_RESET_PORT) {\r\n*flags &= ~SIENA_RESET_PORT;\r\nreturn RESET_TYPE_ALL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int siena_reset_hw(struct efx_nic *efx, enum reset_type method)\r\n{\r\nint rc;\r\nrc = efx_mcdi_handle_assertion(efx);\r\nif (rc)\r\nreturn rc;\r\nif (method == RESET_TYPE_WORLD)\r\nreturn efx_mcdi_reset_mc(efx);\r\nelse\r\nreturn efx_mcdi_reset_port(efx);\r\n}\r\nstatic int siena_probe_nvconfig(struct efx_nic *efx)\r\n{\r\nu32 caps = 0;\r\nint rc;\r\nrc = efx_mcdi_get_board_cfg(efx, efx->net_dev->perm_addr, NULL, &caps);\r\nefx->timer_quantum_ns =\r\n(caps & (1 << MC_CMD_CAPABILITIES_TURBO_ACTIVE_LBN)) ?\r\n3072 : 6144;\r\nreturn rc;\r\n}\r\nstatic void siena_dimension_resources(struct efx_nic *efx)\r\n{\r\nefx_nic_dimension_resources(efx, FR_CZ_BUF_FULL_TBL_ROWS / 2);\r\n}\r\nstatic int siena_probe_nic(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data;\r\nbool already_attached = false;\r\nefx_oword_t reg;\r\nint rc;\r\nnic_data = kzalloc(sizeof(struct siena_nic_data), GFP_KERNEL);\r\nif (!nic_data)\r\nreturn -ENOMEM;\r\nefx->nic_data = nic_data;\r\nif (efx_nic_fpga_ver(efx) != 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Siena FPGA not supported\n");\r\nrc = -ENODEV;\r\ngoto fail1;\r\n}\r\nefx_reado(efx, &reg, FR_AZ_CS_DEBUG);\r\nefx->net_dev->dev_id = EFX_OWORD_FIELD(reg, FRF_CZ_CS_PORT_NUM) - 1;\r\nefx_mcdi_init(efx);\r\nrc = efx_mcdi_handle_assertion(efx);\r\nif (rc)\r\ngoto fail1;\r\nrc = efx_mcdi_drv_attach(efx, true, &already_attached);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Unable to register driver with MCPU\n");\r\ngoto fail2;\r\n}\r\nif (already_attached)\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Host already registered with MCPU\n");\r\nrc = siena_reset_hw(efx, RESET_TYPE_ALL);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");\r\ngoto fail3;\r\n}\r\nsiena_init_wol(efx);\r\nrc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));\r\nif (rc)\r\ngoto fail4;\r\nBUG_ON(efx->irq_status.dma_addr & 0x0f);\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"INT_KER at %llx (virt %p phys %llx)\n",\r\n(unsigned long long)efx->irq_status.dma_addr,\r\nefx->irq_status.addr,\r\n(unsigned long long)virt_to_phys(efx->irq_status.addr));\r\nrc = siena_probe_nvconfig(efx);\r\nif (rc == -EINVAL) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"NVRAM is invalid therefore using defaults\n");\r\nefx->phy_type = PHY_TYPE_NONE;\r\nefx->mdio.prtad = MDIO_PRTAD_NONE;\r\n} else if (rc) {\r\ngoto fail5;\r\n}\r\nrc = efx_mcdi_mon_probe(efx);\r\nif (rc)\r\ngoto fail5;\r\nefx_sriov_probe(efx);\r\nreturn 0;\r\nfail5:\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\nfail4:\r\nfail3:\r\nefx_mcdi_drv_attach(efx, false, NULL);\r\nfail2:\r\nfail1:\r\nkfree(efx->nic_data);\r\nreturn rc;\r\n}\r\nstatic int siena_init_nic(struct efx_nic *efx)\r\n{\r\nefx_oword_t temp;\r\nint rc;\r\nrc = efx_mcdi_handle_assertion(efx);\r\nif (rc)\r\nreturn rc;\r\nefx_reado(efx, &temp, FR_AZ_TX_RESERVED);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);\r\nefx_writeo(efx, &temp, FR_AZ_TX_RESERVED);\r\nefx_reado(efx, &temp, FR_AZ_TX_CFG);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);\r\nEFX_SET_OWORD_FIELD(temp, FRF_CZ_TX_FILTER_EN_BIT, 1);\r\nefx_writeo(efx, &temp, FR_AZ_TX_CFG);\r\nefx_reado(efx, &temp, FR_AZ_RX_CFG);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_DESC_PUSH_EN, 0);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_INGR_EN, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_INSRT_HDR, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_ALG, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_IP_HASH, 1);\r\nefx_writeo(efx, &temp, FR_AZ_RX_CFG);\r\nmemcpy(&temp, efx->rx_hash_key, sizeof(temp));\r\nefx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);\r\nBUILD_BUG_ON(sizeof(efx->rx_hash_key) <\r\n2 * sizeof(temp) + FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8 ||\r\nFRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN != 0);\r\nmemcpy(&temp, efx->rx_hash_key, sizeof(temp));\r\nefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);\r\nmemcpy(&temp, efx->rx_hash_key + sizeof(temp), sizeof(temp));\r\nefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);\r\nEFX_POPULATE_OWORD_2(temp, FRF_CZ_RX_RSS_IPV6_THASH_ENABLE, 1,\r\nFRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE, 1);\r\nmemcpy(&temp, efx->rx_hash_key + 2 * sizeof(temp),\r\nFRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);\r\nefx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);\r\nrc = efx_mcdi_log_ctrl(efx, true, false, 0);\r\nif (rc)\r\nreturn rc;\r\nEFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);\r\nefx_writeo(efx, &temp, FR_BZ_DP_CTRL);\r\nEFX_POPULATE_OWORD_1(temp, FRF_CZ_USREV_DIS, 1);\r\nefx_writeo(efx, &temp, FR_CZ_USR_EV_CFG);\r\nefx_nic_init_common(efx);\r\nreturn 0;\r\n}\r\nstatic void siena_remove_nic(struct efx_nic *efx)\r\n{\r\nefx_mcdi_mon_remove(efx);\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\nsiena_reset_hw(efx, RESET_TYPE_ALL);\r\nefx_mcdi_drv_attach(efx, false, NULL);\r\nkfree(efx->nic_data);\r\nefx->nic_data = NULL;\r\n}\r\nstatic int siena_try_update_nic_stats(struct efx_nic *efx)\r\n{\r\n__le64 *dma_stats;\r\nstruct efx_mac_stats *mac_stats;\r\n__le64 generation_start, generation_end;\r\nmac_stats = &efx->mac_stats;\r\ndma_stats = efx->stats_buffer.addr;\r\ngeneration_end = dma_stats[MC_CMD_MAC_GENERATION_END];\r\nif (generation_end == STATS_GENERATION_INVALID)\r\nreturn 0;\r\nrmb();\r\n#define MAC_STAT(M, D) \\r\nmac_stats->M = le64_to_cpu(dma_stats[MC_CMD_MAC_ ## D])\r\nMAC_STAT(tx_bytes, TX_BYTES);\r\nMAC_STAT(tx_bad_bytes, TX_BAD_BYTES);\r\nmac_stats->tx_good_bytes = (mac_stats->tx_bytes -\r\nmac_stats->tx_bad_bytes);\r\nMAC_STAT(tx_packets, TX_PKTS);\r\nMAC_STAT(tx_bad, TX_BAD_FCS_PKTS);\r\nMAC_STAT(tx_pause, TX_PAUSE_PKTS);\r\nMAC_STAT(tx_control, TX_CONTROL_PKTS);\r\nMAC_STAT(tx_unicast, TX_UNICAST_PKTS);\r\nMAC_STAT(tx_multicast, TX_MULTICAST_PKTS);\r\nMAC_STAT(tx_broadcast, TX_BROADCAST_PKTS);\r\nMAC_STAT(tx_lt64, TX_LT64_PKTS);\r\nMAC_STAT(tx_64, TX_64_PKTS);\r\nMAC_STAT(tx_65_to_127, TX_65_TO_127_PKTS);\r\nMAC_STAT(tx_128_to_255, TX_128_TO_255_PKTS);\r\nMAC_STAT(tx_256_to_511, TX_256_TO_511_PKTS);\r\nMAC_STAT(tx_512_to_1023, TX_512_TO_1023_PKTS);\r\nMAC_STAT(tx_1024_to_15xx, TX_1024_TO_15XX_PKTS);\r\nMAC_STAT(tx_15xx_to_jumbo, TX_15XX_TO_JUMBO_PKTS);\r\nMAC_STAT(tx_gtjumbo, TX_GTJUMBO_PKTS);\r\nmac_stats->tx_collision = 0;\r\nMAC_STAT(tx_single_collision, TX_SINGLE_COLLISION_PKTS);\r\nMAC_STAT(tx_multiple_collision, TX_MULTIPLE_COLLISION_PKTS);\r\nMAC_STAT(tx_excessive_collision, TX_EXCESSIVE_COLLISION_PKTS);\r\nMAC_STAT(tx_deferred, TX_DEFERRED_PKTS);\r\nMAC_STAT(tx_late_collision, TX_LATE_COLLISION_PKTS);\r\nmac_stats->tx_collision = (mac_stats->tx_single_collision +\r\nmac_stats->tx_multiple_collision +\r\nmac_stats->tx_excessive_collision +\r\nmac_stats->tx_late_collision);\r\nMAC_STAT(tx_excessive_deferred, TX_EXCESSIVE_DEFERRED_PKTS);\r\nMAC_STAT(tx_non_tcpudp, TX_NON_TCPUDP_PKTS);\r\nMAC_STAT(tx_mac_src_error, TX_MAC_SRC_ERR_PKTS);\r\nMAC_STAT(tx_ip_src_error, TX_IP_SRC_ERR_PKTS);\r\nMAC_STAT(rx_bytes, RX_BYTES);\r\nMAC_STAT(rx_bad_bytes, RX_BAD_BYTES);\r\nmac_stats->rx_good_bytes = (mac_stats->rx_bytes -\r\nmac_stats->rx_bad_bytes);\r\nMAC_STAT(rx_packets, RX_PKTS);\r\nMAC_STAT(rx_good, RX_GOOD_PKTS);\r\nMAC_STAT(rx_bad, RX_BAD_FCS_PKTS);\r\nMAC_STAT(rx_pause, RX_PAUSE_PKTS);\r\nMAC_STAT(rx_control, RX_CONTROL_PKTS);\r\nMAC_STAT(rx_unicast, RX_UNICAST_PKTS);\r\nMAC_STAT(rx_multicast, RX_MULTICAST_PKTS);\r\nMAC_STAT(rx_broadcast, RX_BROADCAST_PKTS);\r\nMAC_STAT(rx_lt64, RX_UNDERSIZE_PKTS);\r\nMAC_STAT(rx_64, RX_64_PKTS);\r\nMAC_STAT(rx_65_to_127, RX_65_TO_127_PKTS);\r\nMAC_STAT(rx_128_to_255, RX_128_TO_255_PKTS);\r\nMAC_STAT(rx_256_to_511, RX_256_TO_511_PKTS);\r\nMAC_STAT(rx_512_to_1023, RX_512_TO_1023_PKTS);\r\nMAC_STAT(rx_1024_to_15xx, RX_1024_TO_15XX_PKTS);\r\nMAC_STAT(rx_15xx_to_jumbo, RX_15XX_TO_JUMBO_PKTS);\r\nMAC_STAT(rx_gtjumbo, RX_GTJUMBO_PKTS);\r\nmac_stats->rx_bad_lt64 = 0;\r\nmac_stats->rx_bad_64_to_15xx = 0;\r\nmac_stats->rx_bad_15xx_to_jumbo = 0;\r\nMAC_STAT(rx_bad_gtjumbo, RX_JABBER_PKTS);\r\nMAC_STAT(rx_overflow, RX_OVERFLOW_PKTS);\r\nmac_stats->rx_missed = 0;\r\nMAC_STAT(rx_false_carrier, RX_FALSE_CARRIER_PKTS);\r\nMAC_STAT(rx_symbol_error, RX_SYMBOL_ERROR_PKTS);\r\nMAC_STAT(rx_align_error, RX_ALIGN_ERROR_PKTS);\r\nMAC_STAT(rx_length_error, RX_LENGTH_ERROR_PKTS);\r\nMAC_STAT(rx_internal_error, RX_INTERNAL_ERROR_PKTS);\r\nmac_stats->rx_good_lt64 = 0;\r\nefx->n_rx_nodesc_drop_cnt =\r\nle64_to_cpu(dma_stats[MC_CMD_MAC_RX_NODESC_DROPS]);\r\n#undef MAC_STAT\r\nrmb();\r\ngeneration_start = dma_stats[MC_CMD_MAC_GENERATION_START];\r\nif (generation_end != generation_start)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic void siena_update_nic_stats(struct efx_nic *efx)\r\n{\r\nint retry;\r\nfor (retry = 0; retry < 100; ++retry) {\r\nif (siena_try_update_nic_stats(efx) == 0)\r\nreturn;\r\nudelay(100);\r\n}\r\n}\r\nstatic void siena_start_nic_stats(struct efx_nic *efx)\r\n{\r\n__le64 *dma_stats = efx->stats_buffer.addr;\r\ndma_stats[MC_CMD_MAC_GENERATION_END] = STATS_GENERATION_INVALID;\r\nefx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr,\r\nMC_CMD_MAC_NSTATS * sizeof(u64), 1, 0);\r\n}\r\nstatic void siena_stop_nic_stats(struct efx_nic *efx)\r\n{\r\nefx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr, 0, 0, 0);\r\n}\r\nstatic void siena_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nwol->supported = WAKE_MAGIC;\r\nif (nic_data->wol_filter_id != -1)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int siena_set_wol(struct efx_nic *efx, u32 type)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nif (type & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nif (type & WAKE_MAGIC) {\r\nif (nic_data->wol_filter_id != -1)\r\nefx_mcdi_wol_filter_remove(efx,\r\nnic_data->wol_filter_id);\r\nrc = efx_mcdi_wol_filter_set_magic(efx, efx->net_dev->dev_addr,\r\n&nic_data->wol_filter_id);\r\nif (rc)\r\ngoto fail;\r\npci_wake_from_d3(efx->pci_dev, true);\r\n} else {\r\nrc = efx_mcdi_wol_filter_reset(efx);\r\nnic_data->wol_filter_id = -1;\r\npci_wake_from_d3(efx->pci_dev, false);\r\nif (rc)\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s failed: type=%d rc=%d\n",\r\n__func__, type, rc);\r\nreturn rc;\r\n}\r\nstatic void siena_init_wol(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = efx_mcdi_wol_filter_get_magic(efx, &nic_data->wol_filter_id);\r\nif (rc != 0) {\r\nefx_mcdi_wol_filter_reset(efx);\r\nnic_data->wol_filter_id = -1;\r\n} else if (nic_data->wol_filter_id != -1) {\r\npci_wake_from_d3(efx->pci_dev, true);\r\n}\r\n}
