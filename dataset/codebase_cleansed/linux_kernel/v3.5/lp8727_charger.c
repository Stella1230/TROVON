static int lp8727_read_bytes(struct lp8727_chg *pchg, u8 reg, u8 *data, u8 len)\r\n{\r\ns32 ret;\r\nmutex_lock(&pchg->xfer_lock);\r\nret = i2c_smbus_read_i2c_block_data(pchg->client, reg, len, data);\r\nmutex_unlock(&pchg->xfer_lock);\r\nreturn (ret != len) ? -EIO : 0;\r\n}\r\nstatic inline int lp8727_read_byte(struct lp8727_chg *pchg, u8 reg, u8 *data)\r\n{\r\nreturn lp8727_read_bytes(pchg, reg, data, 1);\r\n}\r\nstatic int lp8727_write_byte(struct lp8727_chg *pchg, u8 reg, u8 data)\r\n{\r\nint ret;\r\nmutex_lock(&pchg->xfer_lock);\r\nret = i2c_smbus_write_byte_data(pchg->client, reg, data);\r\nmutex_unlock(&pchg->xfer_lock);\r\nreturn ret;\r\n}\r\nstatic int lp8727_is_charger_attached(const char *name, int id)\r\n{\r\nif (name) {\r\nif (!strcmp(name, "ac"))\r\nreturn (id == ID_TA || id == ID_DEDICATED_CHG) ? 1 : 0;\r\nelse if (!strcmp(name, "usb"))\r\nreturn (id == ID_USB_CHG) ? 1 : 0;\r\n}\r\nreturn (id >= ID_TA && id <= ID_USB_CHG) ? 1 : 0;\r\n}\r\nstatic int lp8727_init_device(struct lp8727_chg *pchg)\r\n{\r\nu8 val;\r\nint ret;\r\nval = ID200_EN | ADC_EN | CP_EN;\r\nret = lp8727_write_byte(pchg, CTRL1, val);\r\nif (ret)\r\nreturn ret;\r\nval = INT_EN | CHGDET_EN;\r\nret = lp8727_write_byte(pchg, CTRL2, val);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int lp8727_is_dedicated_charger(struct lp8727_chg *pchg)\r\n{\r\nu8 val;\r\nlp8727_read_byte(pchg, STATUS1, &val);\r\nreturn val & DCPORT;\r\n}\r\nstatic int lp8727_is_usb_charger(struct lp8727_chg *pchg)\r\n{\r\nu8 val;\r\nlp8727_read_byte(pchg, STATUS1, &val);\r\nreturn val & CHPORT;\r\n}\r\nstatic void lp8727_ctrl_switch(struct lp8727_chg *pchg, u8 sw)\r\n{\r\nlp8727_write_byte(pchg, SWCTRL, sw);\r\n}\r\nstatic void lp8727_id_detection(struct lp8727_chg *pchg, u8 id, int vbusin)\r\n{\r\nu8 devid = ID_NONE;\r\nu8 swctrl = SW_DM1_HiZ | SW_DP2_HiZ;\r\nswitch (id) {\r\ncase 0x5:\r\ndevid = ID_TA;\r\npchg->chg_parm = &pchg->pdata->ac;\r\nbreak;\r\ncase 0xB:\r\nif (lp8727_is_dedicated_charger(pchg)) {\r\npchg->chg_parm = &pchg->pdata->ac;\r\ndevid = ID_DEDICATED_CHG;\r\n} else if (lp8727_is_usb_charger(pchg)) {\r\npchg->chg_parm = &pchg->pdata->usb;\r\ndevid = ID_USB_CHG;\r\nswctrl = SW_DM1_DM | SW_DP2_DP;\r\n} else if (vbusin) {\r\ndevid = ID_USB_DS;\r\nswctrl = SW_DM1_DM | SW_DP2_DP;\r\n}\r\nbreak;\r\ndefault:\r\ndevid = ID_NONE;\r\npchg->chg_parm = NULL;\r\nbreak;\r\n}\r\npchg->devid = devid;\r\nlp8727_ctrl_switch(pchg, swctrl);\r\n}\r\nstatic void lp8727_enable_chgdet(struct lp8727_chg *pchg)\r\n{\r\nu8 val;\r\nlp8727_read_byte(pchg, CTRL2, &val);\r\nval |= CHGDET_EN;\r\nlp8727_write_byte(pchg, CTRL2, val);\r\n}\r\nstatic void lp8727_delayed_func(struct work_struct *_work)\r\n{\r\nu8 intstat[2], idno, vbus;\r\nstruct lp8727_chg *pchg =\r\ncontainer_of(_work, struct lp8727_chg, work.work);\r\nif (lp8727_read_bytes(pchg, INT1, intstat, 2)) {\r\ndev_err(pchg->dev, "can not read INT registers\n");\r\nreturn;\r\n}\r\nidno = intstat[0] & IDNO;\r\nvbus = intstat[0] & VBUS;\r\nlp8727_id_detection(pchg, idno, vbus);\r\nlp8727_enable_chgdet(pchg);\r\npower_supply_changed(&pchg->psy->ac);\r\npower_supply_changed(&pchg->psy->usb);\r\npower_supply_changed(&pchg->psy->batt);\r\n}\r\nstatic irqreturn_t lp8727_isr_func(int irq, void *ptr)\r\n{\r\nstruct lp8727_chg *pchg = ptr;\r\nunsigned long delay = msecs_to_jiffies(DEBOUNCE_MSEC);\r\nqueue_delayed_work(pchg->irqthread, &pchg->work, delay);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lp8727_intr_config(struct lp8727_chg *pchg)\r\n{\r\nINIT_DELAYED_WORK(&pchg->work, lp8727_delayed_func);\r\npchg->irqthread = create_singlethread_workqueue("lp8727-irqthd");\r\nif (!pchg->irqthread) {\r\ndev_err(pchg->dev, "can not create thread for lp8727\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn request_threaded_irq(pchg->client->irq,\r\nNULL,\r\nlp8727_isr_func,\r\nIRQF_TRIGGER_FALLING,\r\n"lp8727_irq",\r\npchg);\r\n}\r\nstatic int lp8727_charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct lp8727_chg *pchg = dev_get_drvdata(psy->dev->parent);\r\nif (psp == POWER_SUPPLY_PROP_ONLINE)\r\nval->intval = lp8727_is_charger_attached(psy->name,\r\npchg->devid);\r\nreturn 0;\r\n}\r\nstatic int lp8727_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct lp8727_chg *pchg = dev_get_drvdata(psy->dev->parent);\r\nu8 read;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (lp8727_is_charger_attached(psy->name, pchg->devid)) {\r\nlp8727_read_byte(pchg, STATUS1, &read);\r\nif (((read & CHGSTAT) >> 4) == EOC)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\n} else {\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nlp8727_read_byte(pchg, STATUS2, &read);\r\nread = (read & TEMP_STAT) >> 5;\r\nif (read >= 0x1 && read <= 0x3)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nif (pchg->pdata->get_batt_present)\r\nval->intval = pchg->pdata->get_batt_present();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (pchg->pdata->get_batt_level)\r\nval->intval = pchg->pdata->get_batt_level();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nif (pchg->pdata->get_batt_capacity)\r\nval->intval = pchg->pdata->get_batt_capacity();\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nif (pchg->pdata->get_batt_temp)\r\nval->intval = pchg->pdata->get_batt_temp();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lp8727_charger_changed(struct power_supply *psy)\r\n{\r\nstruct lp8727_chg *pchg = dev_get_drvdata(psy->dev->parent);\r\nu8 val;\r\nu8 eoc_level, ichg;\r\nif (lp8727_is_charger_attached(psy->name, pchg->devid)) {\r\nif (pchg->chg_parm) {\r\neoc_level = pchg->chg_parm->eoc_level;\r\nichg = pchg->chg_parm->ichg;\r\nval = (ichg << 4) | eoc_level;\r\nlp8727_write_byte(pchg, CHGCTRL2, val);\r\n}\r\n}\r\n}\r\nstatic int lp8727_register_psy(struct lp8727_chg *pchg)\r\n{\r\nstruct lp8727_psy *psy;\r\npsy = kzalloc(sizeof(*psy), GFP_KERNEL);\r\nif (!psy)\r\ngoto err_mem;\r\npchg->psy = psy;\r\npsy->ac.name = "ac";\r\npsy->ac.type = POWER_SUPPLY_TYPE_MAINS;\r\npsy->ac.properties = lp8727_charger_prop;\r\npsy->ac.num_properties = ARRAY_SIZE(lp8727_charger_prop);\r\npsy->ac.get_property = lp8727_charger_get_property;\r\npsy->ac.supplied_to = battery_supplied_to;\r\npsy->ac.num_supplicants = ARRAY_SIZE(battery_supplied_to);\r\nif (power_supply_register(pchg->dev, &psy->ac))\r\ngoto err_psy;\r\npsy->usb.name = "usb";\r\npsy->usb.type = POWER_SUPPLY_TYPE_USB;\r\npsy->usb.properties = lp8727_charger_prop;\r\npsy->usb.num_properties = ARRAY_SIZE(lp8727_charger_prop);\r\npsy->usb.get_property = lp8727_charger_get_property;\r\npsy->usb.supplied_to = battery_supplied_to;\r\npsy->usb.num_supplicants = ARRAY_SIZE(battery_supplied_to);\r\nif (power_supply_register(pchg->dev, &psy->usb))\r\ngoto err_psy;\r\npsy->batt.name = "main_batt";\r\npsy->batt.type = POWER_SUPPLY_TYPE_BATTERY;\r\npsy->batt.properties = lp8727_battery_prop;\r\npsy->batt.num_properties = ARRAY_SIZE(lp8727_battery_prop);\r\npsy->batt.get_property = lp8727_battery_get_property;\r\npsy->batt.external_power_changed = lp8727_charger_changed;\r\nif (power_supply_register(pchg->dev, &psy->batt))\r\ngoto err_psy;\r\nreturn 0;\r\nerr_mem:\r\nreturn -ENOMEM;\r\nerr_psy:\r\nkfree(psy);\r\nreturn -EPERM;\r\n}\r\nstatic void lp8727_unregister_psy(struct lp8727_chg *pchg)\r\n{\r\nstruct lp8727_psy *psy = pchg->psy;\r\nif (!psy)\r\nreturn;\r\npower_supply_unregister(&psy->ac);\r\npower_supply_unregister(&psy->usb);\r\npower_supply_unregister(&psy->batt);\r\nkfree(psy);\r\n}\r\nstatic int lp8727_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct lp8727_chg *pchg;\r\nint ret;\r\nif (!i2c_check_functionality(cl->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EIO;\r\npchg = kzalloc(sizeof(*pchg), GFP_KERNEL);\r\nif (!pchg)\r\nreturn -ENOMEM;\r\npchg->client = cl;\r\npchg->dev = &cl->dev;\r\npchg->pdata = cl->dev.platform_data;\r\ni2c_set_clientdata(cl, pchg);\r\nmutex_init(&pchg->xfer_lock);\r\nret = lp8727_init_device(pchg);\r\nif (ret) {\r\ndev_err(pchg->dev, "i2c communication err: %d", ret);\r\ngoto error;\r\n}\r\nret = lp8727_intr_config(pchg);\r\nif (ret) {\r\ndev_err(pchg->dev, "irq handler err: %d", ret);\r\ngoto error;\r\n}\r\nret = lp8727_register_psy(pchg);\r\nif (ret) {\r\ndev_err(pchg->dev, "power supplies register err: %d", ret);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nkfree(pchg);\r\nreturn ret;\r\n}\r\nstatic int __devexit lp8727_remove(struct i2c_client *cl)\r\n{\r\nstruct lp8727_chg *pchg = i2c_get_clientdata(cl);\r\nlp8727_unregister_psy(pchg);\r\nfree_irq(pchg->client->irq, pchg);\r\nflush_workqueue(pchg->irqthread);\r\ndestroy_workqueue(pchg->irqthread);\r\nkfree(pchg);\r\nreturn 0;\r\n}
