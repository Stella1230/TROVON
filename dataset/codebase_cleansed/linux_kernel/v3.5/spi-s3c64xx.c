static void flush_fifo(struct s3c64xx_spi_driver_data *sdd)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned long loops;\r\nu32 val;\r\nwritel(0, regs + S3C64XX_SPI_PACKET_CNT);\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval |= S3C64XX_SPI_CH_SW_RST;\r\nval &= ~S3C64XX_SPI_CH_HS_EN;\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nloops = msecs_to_loops(1);\r\ndo {\r\nval = readl(regs + S3C64XX_SPI_STATUS);\r\n} while (TX_FIFO_LVL(val, sci) && loops--);\r\nif (loops == 0)\r\ndev_warn(&sdd->pdev->dev, "Timed out flushing TX FIFO\n");\r\nloops = msecs_to_loops(1);\r\ndo {\r\nval = readl(regs + S3C64XX_SPI_STATUS);\r\nif (RX_FIFO_LVL(val, sci))\r\nreadl(regs + S3C64XX_SPI_RX_DATA);\r\nelse\r\nbreak;\r\n} while (loops--);\r\nif (loops == 0)\r\ndev_warn(&sdd->pdev->dev, "Timed out flushing RX FIFO\n");\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval &= ~S3C64XX_SPI_CH_SW_RST;\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nval = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nval &= ~(S3C64XX_SPI_MODE_TXDMA_ON | S3C64XX_SPI_MODE_RXDMA_ON);\r\nwritel(val, regs + S3C64XX_SPI_MODE_CFG);\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval &= ~(S3C64XX_SPI_CH_RXCH_ON | S3C64XX_SPI_CH_TXCH_ON);\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\n}\r\nstatic void s3c64xx_spi_dmacb(void *data)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct s3c64xx_spi_dma_data *dma = data;\r\nunsigned long flags;\r\nif (dma->direction == DMA_DEV_TO_MEM)\r\nsdd = container_of(data,\r\nstruct s3c64xx_spi_driver_data, rx_dma);\r\nelse\r\nsdd = container_of(data,\r\nstruct s3c64xx_spi_driver_data, tx_dma);\r\nspin_lock_irqsave(&sdd->lock, flags);\r\nif (dma->direction == DMA_DEV_TO_MEM) {\r\nsdd->state &= ~RXBUSY;\r\nif (!(sdd->state & TXBUSY))\r\ncomplete(&sdd->xfer_completion);\r\n} else {\r\nsdd->state &= ~TXBUSY;\r\nif (!(sdd->state & RXBUSY))\r\ncomplete(&sdd->xfer_completion);\r\n}\r\nspin_unlock_irqrestore(&sdd->lock, flags);\r\n}\r\nstatic void prepare_dma(struct s3c64xx_spi_dma_data *dma,\r\nunsigned len, dma_addr_t buf)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct samsung_dma_prep_info info;\r\nif (dma->direction == DMA_DEV_TO_MEM)\r\nsdd = container_of((void *)dma,\r\nstruct s3c64xx_spi_driver_data, rx_dma);\r\nelse\r\nsdd = container_of((void *)dma,\r\nstruct s3c64xx_spi_driver_data, tx_dma);\r\ninfo.cap = DMA_SLAVE;\r\ninfo.len = len;\r\ninfo.fp = s3c64xx_spi_dmacb;\r\ninfo.fp_param = dma;\r\ninfo.direction = dma->direction;\r\ninfo.buf = buf;\r\nsdd->ops->prepare(dma->ch, &info);\r\nsdd->ops->trigger(dma->ch);\r\n}\r\nstatic int acquire_dma(struct s3c64xx_spi_driver_data *sdd)\r\n{\r\nstruct samsung_dma_info info;\r\nsdd->ops = samsung_dma_get_ops();\r\ninfo.cap = DMA_SLAVE;\r\ninfo.client = &s3c64xx_spi_dma_client;\r\ninfo.width = sdd->cur_bpw / 8;\r\ninfo.direction = sdd->rx_dma.direction;\r\ninfo.fifo = sdd->sfr_start + S3C64XX_SPI_RX_DATA;\r\nsdd->rx_dma.ch = sdd->ops->request(sdd->rx_dma.dmach, &info);\r\ninfo.direction = sdd->tx_dma.direction;\r\ninfo.fifo = sdd->sfr_start + S3C64XX_SPI_TX_DATA;\r\nsdd->tx_dma.ch = sdd->ops->request(sdd->tx_dma.dmach, &info);\r\nreturn 1;\r\n}\r\nstatic void enable_datapath(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer, int dma_mode)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nvoid __iomem *regs = sdd->regs;\r\nu32 modecfg, chcfg;\r\nmodecfg = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nmodecfg &= ~(S3C64XX_SPI_MODE_TXDMA_ON | S3C64XX_SPI_MODE_RXDMA_ON);\r\nchcfg = readl(regs + S3C64XX_SPI_CH_CFG);\r\nchcfg &= ~S3C64XX_SPI_CH_TXCH_ON;\r\nif (dma_mode) {\r\nchcfg &= ~S3C64XX_SPI_CH_RXCH_ON;\r\n} else {\r\nchcfg |= S3C64XX_SPI_CH_RXCH_ON;\r\nwritel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)\r\n| S3C64XX_SPI_PACKET_CNT_EN,\r\nregs + S3C64XX_SPI_PACKET_CNT);\r\n}\r\nif (xfer->tx_buf != NULL) {\r\nsdd->state |= TXBUSY;\r\nchcfg |= S3C64XX_SPI_CH_TXCH_ON;\r\nif (dma_mode) {\r\nmodecfg |= S3C64XX_SPI_MODE_TXDMA_ON;\r\nprepare_dma(&sdd->tx_dma, xfer->len, xfer->tx_dma);\r\n} else {\r\nswitch (sdd->cur_bpw) {\r\ncase 32:\r\niowrite32_rep(regs + S3C64XX_SPI_TX_DATA,\r\nxfer->tx_buf, xfer->len / 4);\r\nbreak;\r\ncase 16:\r\niowrite16_rep(regs + S3C64XX_SPI_TX_DATA,\r\nxfer->tx_buf, xfer->len / 2);\r\nbreak;\r\ndefault:\r\niowrite8_rep(regs + S3C64XX_SPI_TX_DATA,\r\nxfer->tx_buf, xfer->len);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (xfer->rx_buf != NULL) {\r\nsdd->state |= RXBUSY;\r\nif (sci->high_speed && sdd->cur_speed >= 30000000UL\r\n&& !(sdd->cur_mode & SPI_CPHA))\r\nchcfg |= S3C64XX_SPI_CH_HS_EN;\r\nif (dma_mode) {\r\nmodecfg |= S3C64XX_SPI_MODE_RXDMA_ON;\r\nchcfg |= S3C64XX_SPI_CH_RXCH_ON;\r\nwritel(((xfer->len * 8 / sdd->cur_bpw) & 0xffff)\r\n| S3C64XX_SPI_PACKET_CNT_EN,\r\nregs + S3C64XX_SPI_PACKET_CNT);\r\nprepare_dma(&sdd->rx_dma, xfer->len, xfer->rx_dma);\r\n}\r\n}\r\nwritel(modecfg, regs + S3C64XX_SPI_MODE_CFG);\r\nwritel(chcfg, regs + S3C64XX_SPI_CH_CFG);\r\n}\r\nstatic inline void enable_cs(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_device *spi)\r\n{\r\nstruct s3c64xx_spi_csinfo *cs;\r\nif (sdd->tgl_spi != NULL) {\r\nif (sdd->tgl_spi != spi) {\r\ncs = sdd->tgl_spi->controller_data;\r\ncs->set_level(cs->line,\r\nspi->mode & SPI_CS_HIGH ? 0 : 1);\r\n}\r\nsdd->tgl_spi = NULL;\r\n}\r\ncs = spi->controller_data;\r\ncs->set_level(cs->line, spi->mode & SPI_CS_HIGH ? 1 : 0);\r\n}\r\nstatic int wait_for_xfer(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_transfer *xfer, int dma_mode)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned long val;\r\nint ms;\r\nms = xfer->len * 8 * 1000 / sdd->cur_speed;\r\nms += 10;\r\nif (dma_mode) {\r\nval = msecs_to_jiffies(ms) + 10;\r\nval = wait_for_completion_timeout(&sdd->xfer_completion, val);\r\n} else {\r\nu32 status;\r\nval = msecs_to_loops(ms);\r\ndo {\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\n} while (RX_FIFO_LVL(status, sci) < xfer->len && --val);\r\n}\r\nif (!val)\r\nreturn -EIO;\r\nif (dma_mode) {\r\nu32 status;\r\nif (xfer->rx_buf == NULL) {\r\nval = msecs_to_loops(10);\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\nwhile ((TX_FIFO_LVL(status, sci)\r\n|| !S3C64XX_SPI_ST_TX_DONE(status, sci))\r\n&& --val) {\r\ncpu_relax();\r\nstatus = readl(regs + S3C64XX_SPI_STATUS);\r\n}\r\nif (!val)\r\nreturn -EIO;\r\n}\r\n} else {\r\nif (xfer->rx_buf == NULL) {\r\nsdd->state &= ~TXBUSY;\r\nreturn 0;\r\n}\r\nswitch (sdd->cur_bpw) {\r\ncase 32:\r\nioread32_rep(regs + S3C64XX_SPI_RX_DATA,\r\nxfer->rx_buf, xfer->len / 4);\r\nbreak;\r\ncase 16:\r\nioread16_rep(regs + S3C64XX_SPI_RX_DATA,\r\nxfer->rx_buf, xfer->len / 2);\r\nbreak;\r\ndefault:\r\nioread8_rep(regs + S3C64XX_SPI_RX_DATA,\r\nxfer->rx_buf, xfer->len);\r\nbreak;\r\n}\r\nsdd->state &= ~RXBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void disable_cs(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_device *spi)\r\n{\r\nstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\r\nif (sdd->tgl_spi == spi)\r\nsdd->tgl_spi = NULL;\r\ncs->set_level(cs->line, spi->mode & SPI_CS_HIGH ? 0 : 1);\r\n}\r\nstatic void s3c64xx_spi_config(struct s3c64xx_spi_driver_data *sdd)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nvoid __iomem *regs = sdd->regs;\r\nu32 val;\r\nif (sci->clk_from_cmu) {\r\nclk_disable(sdd->src_clk);\r\n} else {\r\nval = readl(regs + S3C64XX_SPI_CLK_CFG);\r\nval &= ~S3C64XX_SPI_ENCLK_ENABLE;\r\nwritel(val, regs + S3C64XX_SPI_CLK_CFG);\r\n}\r\nval = readl(regs + S3C64XX_SPI_CH_CFG);\r\nval &= ~(S3C64XX_SPI_CH_SLAVE |\r\nS3C64XX_SPI_CPOL_L |\r\nS3C64XX_SPI_CPHA_B);\r\nif (sdd->cur_mode & SPI_CPOL)\r\nval |= S3C64XX_SPI_CPOL_L;\r\nif (sdd->cur_mode & SPI_CPHA)\r\nval |= S3C64XX_SPI_CPHA_B;\r\nwritel(val, regs + S3C64XX_SPI_CH_CFG);\r\nval = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nval &= ~(S3C64XX_SPI_MODE_BUS_TSZ_MASK\r\n| S3C64XX_SPI_MODE_CH_TSZ_MASK);\r\nswitch (sdd->cur_bpw) {\r\ncase 32:\r\nval |= S3C64XX_SPI_MODE_BUS_TSZ_WORD;\r\nval |= S3C64XX_SPI_MODE_CH_TSZ_WORD;\r\nbreak;\r\ncase 16:\r\nval |= S3C64XX_SPI_MODE_BUS_TSZ_HALFWORD;\r\nval |= S3C64XX_SPI_MODE_CH_TSZ_HALFWORD;\r\nbreak;\r\ndefault:\r\nval |= S3C64XX_SPI_MODE_BUS_TSZ_BYTE;\r\nval |= S3C64XX_SPI_MODE_CH_TSZ_BYTE;\r\nbreak;\r\n}\r\nwritel(val, regs + S3C64XX_SPI_MODE_CFG);\r\nif (sci->clk_from_cmu) {\r\nclk_set_rate(sdd->src_clk, sdd->cur_speed * 2);\r\nclk_enable(sdd->src_clk);\r\n} else {\r\nval = readl(regs + S3C64XX_SPI_CLK_CFG);\r\nval &= ~S3C64XX_SPI_PSR_MASK;\r\nval |= ((clk_get_rate(sdd->src_clk) / sdd->cur_speed / 2 - 1)\r\n& S3C64XX_SPI_PSR_MASK);\r\nwritel(val, regs + S3C64XX_SPI_CLK_CFG);\r\nval = readl(regs + S3C64XX_SPI_CLK_CFG);\r\nval |= S3C64XX_SPI_ENCLK_ENABLE;\r\nwritel(val, regs + S3C64XX_SPI_CLK_CFG);\r\n}\r\n}\r\nstatic int s3c64xx_spi_map_mssg(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_message *msg)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nstruct device *dev = &sdd->pdev->dev;\r\nstruct spi_transfer *xfer;\r\nif (msg->is_dma_mapped)\r\nreturn 0;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nxfer->rx_dma = XFER_DMAADDR_INVALID;\r\nxfer->tx_dma = XFER_DMAADDR_INVALID;\r\n}\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nif (xfer->len <= ((sci->fifo_lvl_mask >> 1) + 1))\r\ncontinue;\r\nif (xfer->tx_buf != NULL) {\r\nxfer->tx_dma = dma_map_single(dev,\r\n(void *)xfer->tx_buf, xfer->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, xfer->tx_dma)) {\r\ndev_err(dev, "dma_map_single Tx failed\n");\r\nxfer->tx_dma = XFER_DMAADDR_INVALID;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (xfer->rx_buf != NULL) {\r\nxfer->rx_dma = dma_map_single(dev, xfer->rx_buf,\r\nxfer->len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, xfer->rx_dma)) {\r\ndev_err(dev, "dma_map_single Rx failed\n");\r\ndma_unmap_single(dev, xfer->tx_dma,\r\nxfer->len, DMA_TO_DEVICE);\r\nxfer->tx_dma = XFER_DMAADDR_INVALID;\r\nxfer->rx_dma = XFER_DMAADDR_INVALID;\r\nreturn -ENOMEM;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c64xx_spi_unmap_mssg(struct s3c64xx_spi_driver_data *sdd,\r\nstruct spi_message *msg)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nstruct device *dev = &sdd->pdev->dev;\r\nstruct spi_transfer *xfer;\r\nif (msg->is_dma_mapped)\r\nreturn;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nif (xfer->len <= ((sci->fifo_lvl_mask >> 1) + 1))\r\ncontinue;\r\nif (xfer->rx_buf != NULL\r\n&& xfer->rx_dma != XFER_DMAADDR_INVALID)\r\ndma_unmap_single(dev, xfer->rx_dma,\r\nxfer->len, DMA_FROM_DEVICE);\r\nif (xfer->tx_buf != NULL\r\n&& xfer->tx_dma != XFER_DMAADDR_INVALID)\r\ndma_unmap_single(dev, xfer->tx_dma,\r\nxfer->len, DMA_TO_DEVICE);\r\n}\r\n}\r\nstatic int s3c64xx_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nstruct spi_device *spi = msg->spi;\r\nstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\r\nstruct spi_transfer *xfer;\r\nint status = 0, cs_toggle = 0;\r\nu32 speed;\r\nu8 bpw;\r\nif (sdd->cur_speed != spi->max_speed_hz\r\n|| sdd->cur_mode != spi->mode\r\n|| sdd->cur_bpw != spi->bits_per_word) {\r\nsdd->cur_bpw = spi->bits_per_word;\r\nsdd->cur_speed = spi->max_speed_hz;\r\nsdd->cur_mode = spi->mode;\r\ns3c64xx_spi_config(sdd);\r\n}\r\nif (s3c64xx_spi_map_mssg(sdd, msg)) {\r\ndev_err(&spi->dev,\r\n"Xfer: Unable to map message buffers!\n");\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nwritel(cs->fb_delay & 0x3, sdd->regs + S3C64XX_SPI_FB_CLK);\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nunsigned long flags;\r\nint use_dma;\r\nINIT_COMPLETION(sdd->xfer_completion);\r\nbpw = xfer->bits_per_word ? : spi->bits_per_word;\r\nspeed = xfer->speed_hz ? : spi->max_speed_hz;\r\nif (xfer->len % (bpw / 8)) {\r\ndev_err(&spi->dev,\r\n"Xfer length(%u) not a multiple of word size(%u)\n",\r\nxfer->len, bpw / 8);\r\nstatus = -EIO;\r\ngoto out;\r\n}\r\nif (bpw != sdd->cur_bpw || speed != sdd->cur_speed) {\r\nsdd->cur_bpw = bpw;\r\nsdd->cur_speed = speed;\r\ns3c64xx_spi_config(sdd);\r\n}\r\nif (xfer->len <= ((sci->fifo_lvl_mask >> 1) + 1))\r\nuse_dma = 0;\r\nelse\r\nuse_dma = 1;\r\nspin_lock_irqsave(&sdd->lock, flags);\r\nsdd->state &= ~RXBUSY;\r\nsdd->state &= ~TXBUSY;\r\nenable_datapath(sdd, spi, xfer, use_dma);\r\nenable_cs(sdd, spi);\r\nS3C64XX_SPI_ACT(sdd);\r\nspin_unlock_irqrestore(&sdd->lock, flags);\r\nstatus = wait_for_xfer(sdd, xfer, use_dma);\r\nS3C64XX_SPI_DEACT(sdd);\r\nif (status) {\r\ndev_err(&spi->dev, "I/O Error: "\r\n"rx-%d tx-%d res:rx-%c tx-%c len-%d\n",\r\nxfer->rx_buf ? 1 : 0, xfer->tx_buf ? 1 : 0,\r\n(sdd->state & RXBUSY) ? 'f' : 'p',\r\n(sdd->state & TXBUSY) ? 'f' : 'p',\r\nxfer->len);\r\nif (use_dma) {\r\nif (xfer->tx_buf != NULL\r\n&& (sdd->state & TXBUSY))\r\nsdd->ops->stop(sdd->tx_dma.ch);\r\nif (xfer->rx_buf != NULL\r\n&& (sdd->state & RXBUSY))\r\nsdd->ops->stop(sdd->rx_dma.ch);\r\n}\r\ngoto out;\r\n}\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nif (xfer->cs_change) {\r\nif (list_is_last(&xfer->transfer_list,\r\n&msg->transfers))\r\ncs_toggle = 1;\r\nelse\r\ndisable_cs(sdd, spi);\r\n}\r\nmsg->actual_length += xfer->len;\r\nflush_fifo(sdd);\r\n}\r\nout:\r\nif (!cs_toggle || status)\r\ndisable_cs(sdd, spi);\r\nelse\r\nsdd->tgl_spi = spi;\r\ns3c64xx_spi_unmap_mssg(sdd, msg);\r\nmsg->status = status;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_prepare_transfer(struct spi_master *spi)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(spi);\r\nwhile (!acquire_dma(sdd))\r\nmsleep(10);\r\npm_runtime_get_sync(&sdd->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_unprepare_transfer(struct spi_master *spi)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(spi);\r\nsdd->ops->release(sdd->rx_dma.ch, &s3c64xx_spi_dma_client);\r\nsdd->ops->release(sdd->tx_dma.ch, &s3c64xx_spi_dma_client);\r\npm_runtime_put(&sdd->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_setup(struct spi_device *spi)\r\n{\r\nstruct s3c64xx_spi_csinfo *cs = spi->controller_data;\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct s3c64xx_spi_info *sci;\r\nstruct spi_message *msg;\r\nunsigned long flags;\r\nint err = 0;\r\nif (cs == NULL || cs->set_level == NULL) {\r\ndev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);\r\nreturn -ENODEV;\r\n}\r\nsdd = spi_master_get_devdata(spi->master);\r\nsci = sdd->cntrlr_info;\r\nspin_lock_irqsave(&sdd->lock, flags);\r\nlist_for_each_entry(msg, &sdd->queue, queue) {\r\nif (msg->spi == spi) {\r\ndev_err(&spi->dev,\r\n"setup: attempt while mssg in queue!\n");\r\nspin_unlock_irqrestore(&sdd->lock, flags);\r\nreturn -EBUSY;\r\n}\r\n}\r\nspin_unlock_irqrestore(&sdd->lock, flags);\r\nif (spi->bits_per_word != 8\r\n&& spi->bits_per_word != 16\r\n&& spi->bits_per_word != 32) {\r\ndev_err(&spi->dev, "setup: %dbits/wrd not supported!\n",\r\nspi->bits_per_word);\r\nerr = -EINVAL;\r\ngoto setup_exit;\r\n}\r\npm_runtime_get_sync(&sdd->pdev->dev);\r\nif (!sci->clk_from_cmu) {\r\nu32 psr, speed;\r\nspeed = clk_get_rate(sdd->src_clk) / 2 / (0 + 1);\r\nif (spi->max_speed_hz > speed)\r\nspi->max_speed_hz = speed;\r\npsr = clk_get_rate(sdd->src_clk) / 2 / spi->max_speed_hz - 1;\r\npsr &= S3C64XX_SPI_PSR_MASK;\r\nif (psr == S3C64XX_SPI_PSR_MASK)\r\npsr--;\r\nspeed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);\r\nif (spi->max_speed_hz < speed) {\r\nif (psr+1 < S3C64XX_SPI_PSR_MASK) {\r\npsr++;\r\n} else {\r\nerr = -EINVAL;\r\ngoto setup_exit;\r\n}\r\n}\r\nspeed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);\r\nif (spi->max_speed_hz >= speed)\r\nspi->max_speed_hz = speed;\r\nelse\r\nerr = -EINVAL;\r\n}\r\npm_runtime_put(&sdd->pdev->dev);\r\nsetup_exit:\r\ndisable_cs(sdd, spi);\r\nreturn err;\r\n}\r\nstatic irqreturn_t s3c64xx_spi_irq(int irq, void *data)\r\n{\r\nstruct s3c64xx_spi_driver_data *sdd = data;\r\nstruct spi_master *spi = sdd->master;\r\nunsigned int val;\r\nval = readl(sdd->regs + S3C64XX_SPI_PENDING_CLR);\r\nval &= S3C64XX_SPI_PND_RX_OVERRUN_CLR |\r\nS3C64XX_SPI_PND_RX_UNDERRUN_CLR |\r\nS3C64XX_SPI_PND_TX_OVERRUN_CLR |\r\nS3C64XX_SPI_PND_TX_UNDERRUN_CLR;\r\nwritel(val, sdd->regs + S3C64XX_SPI_PENDING_CLR);\r\nif (val & S3C64XX_SPI_PND_RX_OVERRUN_CLR)\r\ndev_err(&spi->dev, "RX overrun\n");\r\nif (val & S3C64XX_SPI_PND_RX_UNDERRUN_CLR)\r\ndev_err(&spi->dev, "RX underrun\n");\r\nif (val & S3C64XX_SPI_PND_TX_OVERRUN_CLR)\r\ndev_err(&spi->dev, "TX overrun\n");\r\nif (val & S3C64XX_SPI_PND_TX_UNDERRUN_CLR)\r\ndev_err(&spi->dev, "TX underrun\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void s3c64xx_spi_hwinit(struct s3c64xx_spi_driver_data *sdd, int channel)\r\n{\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nvoid __iomem *regs = sdd->regs;\r\nunsigned int val;\r\nsdd->cur_speed = 0;\r\nS3C64XX_SPI_DEACT(sdd);\r\nwritel(0, regs + S3C64XX_SPI_INT_EN);\r\nif (!sci->clk_from_cmu)\r\nwritel(sci->src_clk_nr << S3C64XX_SPI_CLKSEL_SRCSHFT,\r\nregs + S3C64XX_SPI_CLK_CFG);\r\nwritel(0, regs + S3C64XX_SPI_MODE_CFG);\r\nwritel(0, regs + S3C64XX_SPI_PACKET_CNT);\r\nwritel(readl(regs + S3C64XX_SPI_PENDING_CLR),\r\nregs + S3C64XX_SPI_PENDING_CLR);\r\nwritel(0, regs + S3C64XX_SPI_SWAP_CFG);\r\nval = readl(regs + S3C64XX_SPI_MODE_CFG);\r\nval &= ~S3C64XX_SPI_MODE_4BURST;\r\nval &= ~(S3C64XX_SPI_MAX_TRAILCNT << S3C64XX_SPI_TRAILCNT_OFF);\r\nval |= (S3C64XX_SPI_TRAILCNT << S3C64XX_SPI_TRAILCNT_OFF);\r\nwritel(val, regs + S3C64XX_SPI_MODE_CFG);\r\nflush_fifo(sdd);\r\n}\r\nstatic int __init s3c64xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem_res, *dmatx_res, *dmarx_res;\r\nstruct s3c64xx_spi_driver_data *sdd;\r\nstruct s3c64xx_spi_info *sci;\r\nstruct spi_master *master;\r\nint ret, irq;\r\nchar clk_name[16];\r\nif (pdev->id < 0) {\r\ndev_err(&pdev->dev,\r\n"Invalid platform device id-%d\n", pdev->id);\r\nreturn -ENODEV;\r\n}\r\nif (pdev->dev.platform_data == NULL) {\r\ndev_err(&pdev->dev, "platform_data missing!\n");\r\nreturn -ENODEV;\r\n}\r\nsci = pdev->dev.platform_data;\r\ndmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (dmatx_res == NULL) {\r\ndev_err(&pdev->dev, "Unable to get SPI-Tx dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (dmarx_res == NULL) {\r\ndev_err(&pdev->dev, "Unable to get SPI-Rx dma resource\n");\r\nreturn -ENXIO;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem_res == NULL) {\r\ndev_err(&pdev->dev, "Unable to get SPI MEM resource\n");\r\nreturn -ENXIO;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_warn(&pdev->dev, "Failed to get IRQ: %d\n", irq);\r\nreturn irq;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev,\r\nsizeof(struct s3c64xx_spi_driver_data));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "Unable to allocate SPI Master\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nsdd = spi_master_get_devdata(master);\r\nsdd->master = master;\r\nsdd->cntrlr_info = sci;\r\nsdd->pdev = pdev;\r\nsdd->sfr_start = mem_res->start;\r\nsdd->tx_dma.dmach = dmatx_res->start;\r\nsdd->tx_dma.direction = DMA_MEM_TO_DEV;\r\nsdd->rx_dma.dmach = dmarx_res->start;\r\nsdd->rx_dma.direction = DMA_DEV_TO_MEM;\r\nsdd->cur_bpw = 8;\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = s3c64xx_spi_setup;\r\nmaster->prepare_transfer_hardware = s3c64xx_spi_prepare_transfer;\r\nmaster->transfer_one_message = s3c64xx_spi_transfer_one_message;\r\nmaster->unprepare_transfer_hardware = s3c64xx_spi_unprepare_transfer;\r\nmaster->num_chipselect = sci->num_cs;\r\nmaster->dma_alignment = 8;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nif (request_mem_region(mem_res->start,\r\nresource_size(mem_res), pdev->name) == NULL) {\r\ndev_err(&pdev->dev, "Req mem region failed\n");\r\nret = -ENXIO;\r\ngoto err0;\r\n}\r\nsdd->regs = ioremap(mem_res->start, resource_size(mem_res));\r\nif (sdd->regs == NULL) {\r\ndev_err(&pdev->dev, "Unable to remap IO\n");\r\nret = -ENXIO;\r\ngoto err1;\r\n}\r\nif (sci->cfg_gpio == NULL || sci->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to config gpio\n");\r\nret = -EBUSY;\r\ngoto err2;\r\n}\r\nsdd->clk = clk_get(&pdev->dev, "spi");\r\nif (IS_ERR(sdd->clk)) {\r\ndev_err(&pdev->dev, "Unable to acquire clock 'spi'\n");\r\nret = PTR_ERR(sdd->clk);\r\ngoto err3;\r\n}\r\nif (clk_enable(sdd->clk)) {\r\ndev_err(&pdev->dev, "Couldn't enable clock 'spi'\n");\r\nret = -EBUSY;\r\ngoto err4;\r\n}\r\nsprintf(clk_name, "spi_busclk%d", sci->src_clk_nr);\r\nsdd->src_clk = clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(sdd->src_clk)) {\r\ndev_err(&pdev->dev,\r\n"Unable to acquire clock '%s'\n", clk_name);\r\nret = PTR_ERR(sdd->src_clk);\r\ngoto err5;\r\n}\r\nif (clk_enable(sdd->src_clk)) {\r\ndev_err(&pdev->dev, "Couldn't enable clock '%s'\n", clk_name);\r\nret = -EBUSY;\r\ngoto err6;\r\n}\r\ns3c64xx_spi_hwinit(sdd, pdev->id);\r\nspin_lock_init(&sdd->lock);\r\ninit_completion(&sdd->xfer_completion);\r\nINIT_LIST_HEAD(&sdd->queue);\r\nret = request_irq(irq, s3c64xx_spi_irq, 0, "spi-s3c64xx", sdd);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Failed to request IRQ %d: %d\n",\r\nirq, ret);\r\ngoto err7;\r\n}\r\nwritel(S3C64XX_SPI_INT_RX_OVERRUN_EN | S3C64XX_SPI_INT_RX_UNDERRUN_EN |\r\nS3C64XX_SPI_INT_TX_OVERRUN_EN | S3C64XX_SPI_INT_TX_UNDERRUN_EN,\r\nsdd->regs + S3C64XX_SPI_INT_EN);\r\nif (spi_register_master(master)) {\r\ndev_err(&pdev->dev, "cannot register SPI master\n");\r\nret = -EBUSY;\r\ngoto err8;\r\n}\r\ndev_dbg(&pdev->dev, "Samsung SoC SPI Driver loaded for Bus SPI-%d "\r\n"with %d Slaves attached\n",\r\npdev->id, master->num_chipselect);\r\ndev_dbg(&pdev->dev, "\tIOmem=[0x%x-0x%x]\tDMA=[Rx-%d, Tx-%d]\n",\r\nmem_res->end, mem_res->start,\r\nsdd->rx_dma.dmach, sdd->tx_dma.dmach);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nerr8:\r\nfree_irq(irq, sdd);\r\nerr7:\r\nclk_disable(sdd->src_clk);\r\nerr6:\r\nclk_put(sdd->src_clk);\r\nerr5:\r\nclk_disable(sdd->clk);\r\nerr4:\r\nclk_put(sdd->clk);\r\nerr3:\r\nerr2:\r\niounmap((void *) sdd->regs);\r\nerr1:\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nerr0:\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int s3c64xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = spi_master_get(platform_get_drvdata(pdev));\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nstruct resource *mem_res;\r\npm_runtime_disable(&pdev->dev);\r\nspi_unregister_master(master);\r\nwritel(0, sdd->regs + S3C64XX_SPI_INT_EN);\r\nfree_irq(platform_get_irq(pdev, 0), sdd);\r\nclk_disable(sdd->src_clk);\r\nclk_put(sdd->src_clk);\r\nclk_disable(sdd->clk);\r\nclk_put(sdd->clk);\r\niounmap((void *) sdd->regs);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (mem_res != NULL)\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(master);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = spi_master_get(dev_get_drvdata(dev));\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\nclk_disable(sdd->src_clk);\r\nclk_disable(sdd->clk);\r\nsdd->cur_speed = 0;\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct spi_master *master = spi_master_get(dev_get_drvdata(dev));\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nstruct s3c64xx_spi_info *sci = sdd->cntrlr_info;\r\nsci->cfg_gpio(pdev);\r\nclk_enable(sdd->src_clk);\r\nclk_enable(sdd->clk);\r\ns3c64xx_spi_hwinit(sdd, pdev->id);\r\nspi_master_resume(master);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = spi_master_get(dev_get_drvdata(dev));\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nclk_disable(sdd->clk);\r\nclk_disable(sdd->src_clk);\r\nreturn 0;\r\n}\r\nstatic int s3c64xx_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = spi_master_get(dev_get_drvdata(dev));\r\nstruct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);\r\nclk_enable(sdd->src_clk);\r\nclk_enable(sdd->clk);\r\nreturn 0;\r\n}\r\nstatic int __init s3c64xx_spi_init(void)\r\n{\r\nreturn platform_driver_probe(&s3c64xx_spi_driver, s3c64xx_spi_probe);\r\n}\r\nstatic void __exit s3c64xx_spi_exit(void)\r\n{\r\nplatform_driver_unregister(&s3c64xx_spi_driver);\r\n}
