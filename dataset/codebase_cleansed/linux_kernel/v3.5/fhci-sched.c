static void recycle_frame(struct fhci_usb *usb, struct packet *pkt)\r\n{\r\npkt->data = NULL;\r\npkt->len = 0;\r\npkt->status = USB_TD_OK;\r\npkt->info = 0;\r\npkt->priv_data = NULL;\r\ncq_put(&usb->ep0->empty_frame_Q, pkt);\r\n}\r\nvoid fhci_transaction_confirm(struct fhci_usb *usb, struct packet *pkt)\r\n{\r\nstruct td *td;\r\nstruct packet *td_pkt;\r\nstruct ed *ed;\r\nu32 trans_len;\r\nbool td_done = false;\r\ntd = fhci_remove_td_from_frame(usb->actual_frame);\r\ntd_pkt = td->pkt;\r\ntrans_len = pkt->len;\r\ntd->status = pkt->status;\r\nif (td->type == FHCI_TA_IN && td_pkt->info & PKT_DUMMY_PACKET) {\r\nif ((td->data + td->actual_len) && trans_len)\r\nmemcpy(td->data + td->actual_len, pkt->data,\r\ntrans_len);\r\ncq_put(&usb->ep0->dummy_packets_Q, pkt->data);\r\n}\r\nrecycle_frame(usb, pkt);\r\ned = td->ed;\r\nif (ed->mode == FHCI_TF_ISO) {\r\nif (ed->td_list.next->next != &ed->td_list) {\r\nstruct td *td_next =\r\nlist_entry(ed->td_list.next->next, struct td,\r\nnode);\r\ntd_next->start_frame = usb->actual_frame->frame_num;\r\n}\r\ntd->actual_len = trans_len;\r\ntd_done = true;\r\n} else if ((td->status & USB_TD_ERROR) &&\r\n!(td->status & USB_TD_TX_ER_NAK)) {\r\nif ((td->status & USB_TD_RX_DATA_UNDERUN) ||\r\n(td->status & USB_TD_TX_ER_STALL) ||\r\n(td->status & USB_TD_RX_ER_PID) ||\r\n(++td->error_cnt >= 3)) {\r\ned->state = FHCI_ED_HALTED;\r\ntd_done = true;\r\nif (td->status & USB_TD_RX_DATA_UNDERUN) {\r\nfhci_dbg(usb->fhci, "td err fu\n");\r\ntd->toggle = !td->toggle;\r\ntd->actual_len += trans_len;\r\n} else {\r\nfhci_dbg(usb->fhci, "td err f!u\n");\r\n}\r\n} else {\r\nfhci_dbg(usb->fhci, "td err !f\n");\r\ntd->nak_cnt = 0;\r\ntd->error_cnt++;\r\ntd->status = USB_TD_OK;\r\n}\r\n} else if (td->status & USB_TD_TX_ER_NAK) {\r\nfhci_vdbg(usb->fhci, "td nack\n");\r\ntd->nak_cnt++;\r\ntd->error_cnt = 0;\r\ntd->status = USB_TD_OK;\r\n} else {\r\ntd->error_cnt = 0;\r\ntd->nak_cnt = 0;\r\ntd->toggle = !td->toggle;\r\ntd->actual_len += trans_len;\r\nif (td->len == td->actual_len)\r\ntd_done = true;\r\n}\r\nif (td_done)\r\nfhci_move_td_from_ed_to_done_list(usb, ed);\r\n}\r\nvoid fhci_flush_all_transmissions(struct fhci_usb *usb)\r\n{\r\nu8 mode;\r\nstruct td *td;\r\nmode = in_8(&usb->fhci->regs->usb_mod);\r\nclrbits8(&usb->fhci->regs->usb_mod, USB_MODE_EN);\r\nfhci_flush_bds(usb);\r\nwhile ((td = fhci_peek_td_from_frame(usb->actual_frame)) != NULL) {\r\nstruct packet *pkt = td->pkt;\r\npkt->status = USB_TD_TX_ER_TIMEOUT;\r\nfhci_transaction_confirm(usb, pkt);\r\n}\r\nusb->actual_frame->frame_status = FRAME_END_TRANSMISSION;\r\nout_be16(&usb->fhci->regs->usb_event, 0xffff);\r\nout_8(&usb->fhci->regs->usb_mod, mode | USB_MODE_EN);\r\n}\r\nstatic int add_packet(struct fhci_usb *usb, struct ed *ed, struct td *td)\r\n{\r\nu32 fw_transaction_time, len = 0;\r\nstruct packet *pkt;\r\nu8 *data = NULL;\r\nif (td->toggle == USB_TD_TOGGLE_CARRY)\r\ntd->toggle = ed->toggle_carry;\r\nswitch (ed->mode) {\r\ncase FHCI_TF_ISO:\r\nlen = td->len;\r\nif (td->type != FHCI_TA_IN)\r\ndata = td->data;\r\nbreak;\r\ncase FHCI_TF_CTRL:\r\ncase FHCI_TF_BULK:\r\nlen = min(td->len - td->actual_len, ed->max_pkt_size);\r\nif (!((td->type == FHCI_TA_IN) &&\r\n((len + td->actual_len) == td->len)))\r\ndata = td->data + td->actual_len;\r\nbreak;\r\ncase FHCI_TF_INTR:\r\nlen = min(td->len, ed->max_pkt_size);\r\nif (!((td->type == FHCI_TA_IN) &&\r\n((td->len + CRC_SIZE) >= ed->max_pkt_size)))\r\ndata = td->data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (usb->port_status == FHCI_PORT_FULL)\r\nfw_transaction_time = (((len + PROTOCOL_OVERHEAD) * 11) >> 4);\r\nelse\r\nfw_transaction_time = ((len + PROTOCOL_OVERHEAD) * 6);\r\nif (usb->actual_frame->total_bytes + len + PROTOCOL_OVERHEAD >=\r\nusb->max_bytes_per_frame) {\r\nfhci_vdbg(usb->fhci, "not enough space in this frame: "\r\n"%d %d %d\n", usb->actual_frame->total_bytes, len,\r\nusb->max_bytes_per_frame);\r\nreturn -1;\r\n}\r\nif (usb->actual_frame->frame_status != FRAME_IS_PREPARED &&\r\n(usb->actual_frame->frame_status & FRAME_END_TRANSMISSION ||\r\n(fw_transaction_time + usb->sw_transaction_time >=\r\n1000 - fhci_get_sof_timer_count(usb)))) {\r\nfhci_dbg(usb->fhci, "not enough time in this frame\n");\r\nreturn -1;\r\n}\r\npkt = cq_get(&usb->ep0->empty_frame_Q);\r\nif (!pkt) {\r\nfhci_dbg(usb->fhci, "there is no empty frame\n");\r\nreturn -1;\r\n}\r\ntd->pkt = pkt;\r\npkt->info = 0;\r\nif (data == NULL) {\r\ndata = cq_get(&usb->ep0->dummy_packets_Q);\r\nBUG_ON(!data);\r\npkt->info = PKT_DUMMY_PACKET;\r\n}\r\npkt->data = data;\r\npkt->len = len;\r\npkt->status = USB_TD_OK;\r\ntd->status = USB_TD_INPROGRESS;\r\nusb->actual_frame->total_bytes += (len + PROTOCOL_OVERHEAD);\r\nfhci_add_td_to_frame(usb->actual_frame, td);\r\nif (usb->port_status != FHCI_PORT_FULL &&\r\nusb->port_status != FHCI_PORT_LOW) {\r\npkt->status = USB_TD_TX_ER_TIMEOUT;\r\npkt->len = 0;\r\nfhci_transaction_confirm(usb, pkt);\r\n} else if (fhci_host_transaction(usb, pkt, td->type, ed->dev_addr,\r\ned->ep_addr, ed->mode, ed->speed, td->toggle)) {\r\nlist_del_init(&td->frame_lh);\r\ntd->status = USB_TD_OK;\r\nif (pkt->info & PKT_DUMMY_PACKET)\r\ncq_put(&usb->ep0->dummy_packets_Q, pkt->data);\r\nrecycle_frame(usb, pkt);\r\nusb->actual_frame->total_bytes -= (len + PROTOCOL_OVERHEAD);\r\nfhci_err(usb->fhci, "host transaction failed\n");\r\nreturn -1;\r\n}\r\nreturn len;\r\n}\r\nstatic void move_head_to_tail(struct list_head *list)\r\n{\r\nstruct list_head *node = list->next;\r\nif (!list_empty(list)) {\r\nlist_del(node);\r\nlist_add_tail(node, list);\r\n}\r\n}\r\nstatic int scan_ed_list(struct fhci_usb *usb,\r\nstruct list_head *list, enum fhci_tf_mode list_type)\r\n{\r\nstatic const int frame_part[4] = {\r\n[FHCI_TF_CTRL] = MAX_BYTES_PER_FRAME,\r\n[FHCI_TF_ISO] = (MAX_BYTES_PER_FRAME *\r\nMAX_PERIODIC_FRAME_USAGE) / 100,\r\n[FHCI_TF_BULK] = MAX_BYTES_PER_FRAME,\r\n[FHCI_TF_INTR] = (MAX_BYTES_PER_FRAME *\r\nMAX_PERIODIC_FRAME_USAGE) / 100\r\n};\r\nstruct ed *ed;\r\nstruct td *td;\r\nint ans = 1;\r\nu32 save_transaction_time = usb->sw_transaction_time;\r\nlist_for_each_entry(ed, list, node) {\r\ntd = ed->td_head;\r\nif (!td || (td && td->status == USB_TD_INPROGRESS))\r\ncontinue;\r\nif (ed->state != FHCI_ED_OPER) {\r\nif (ed->state == FHCI_ED_URB_DEL) {\r\ntd->status = USB_TD_OK;\r\nfhci_move_td_from_ed_to_done_list(usb, ed);\r\ned->state = FHCI_ED_SKIP;\r\n}\r\ncontinue;\r\n}\r\nif ((list_type == FHCI_TF_INTR || list_type == FHCI_TF_ISO) &&\r\n(((usb->actual_frame->frame_num -\r\ntd->start_frame) & 0x7ff) < td->interval))\r\ncontinue;\r\nif (add_packet(usb, ed, td) < 0)\r\ncontinue;\r\ntd->start_frame = usb->actual_frame->frame_num;\r\nusb->sw_transaction_time += save_transaction_time;\r\nif (usb->actual_frame->total_bytes >=\r\nusb->max_bytes_per_frame) {\r\nusb->actual_frame->frame_status =\r\nFRAME_DATA_END_TRANSMISSION;\r\nfhci_push_dummy_bd(usb->ep0);\r\nans = 0;\r\nbreak;\r\n}\r\nif (usb->actual_frame->total_bytes >= frame_part[list_type])\r\nbreak;\r\n}\r\nmove_head_to_tail(list);\r\nusb->sw_transaction_time = save_transaction_time;\r\nreturn ans;\r\n}\r\nstatic u32 rotate_frames(struct fhci_usb *usb)\r\n{\r\nstruct fhci_hcd *fhci = usb->fhci;\r\nif (!list_empty(&usb->actual_frame->tds_list)) {\r\nif ((((in_be16(&fhci->pram->frame_num) & 0x07ff) -\r\nusb->actual_frame->frame_num) & 0x7ff) > 5)\r\nfhci_flush_actual_frame(usb);\r\nelse\r\nreturn -EINVAL;\r\n}\r\nusb->actual_frame->frame_status = FRAME_IS_PREPARED;\r\nusb->actual_frame->frame_num = in_be16(&fhci->pram->frame_num) & 0x7ff;\r\nusb->actual_frame->total_bytes = 0;\r\nreturn 0;\r\n}\r\nvoid fhci_schedule_transactions(struct fhci_usb *usb)\r\n{\r\nint left = 1;\r\nif (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)\r\nif (rotate_frames(usb) != 0)\r\nreturn;\r\nif (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)\r\nreturn;\r\nif (usb->actual_frame->total_bytes == 0) {\r\nscan_ed_list(usb, &usb->hc_list->iso_list, FHCI_TF_ISO);\r\nscan_ed_list(usb, &usb->hc_list->intr_list, FHCI_TF_INTR);\r\nleft = scan_ed_list(usb, &usb->hc_list->ctrl_list,\r\nFHCI_TF_CTRL);\r\n}\r\nif (left > 0)\r\nscan_ed_list(usb, &usb->hc_list->bulk_list, FHCI_TF_BULK);\r\n}\r\nstatic void sof_interrupt(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nif ((usb->port_status == FHCI_PORT_DISABLED) &&\r\n(usb->vroot_hub->port.wPortStatus & USB_PORT_STAT_CONNECTION) &&\r\n!(usb->vroot_hub->port.wPortChange & USB_PORT_STAT_C_CONNECTION)) {\r\nif (usb->vroot_hub->port.wPortStatus & USB_PORT_STAT_LOW_SPEED)\r\nusb->port_status = FHCI_PORT_LOW;\r\nelse\r\nusb->port_status = FHCI_PORT_FULL;\r\nusb->saved_msk &= ~USB_E_IDLE_MASK;\r\nout_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);\r\n}\r\ngtm_set_exact_timer16(fhci->timer, usb->max_frame_usage, false);\r\nfhci_host_transmit_actual_frame(usb);\r\nusb->actual_frame->frame_status = FRAME_IS_TRANSMITTED;\r\nfhci_schedule_transactions(usb);\r\n}\r\nvoid fhci_device_disconnected_interrupt(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nfhci_usb_disable_interrupt(usb);\r\nclrbits8(&usb->fhci->regs->usb_mod, USB_MODE_LSS);\r\nusb->port_status = FHCI_PORT_DISABLED;\r\nfhci_stop_sof_timer(fhci);\r\nusb->saved_msk |= USB_E_IDLE_MASK;\r\nout_be16(&usb->fhci->regs->usb_mask, usb->saved_msk);\r\nusb->vroot_hub->port.wPortStatus &= ~USB_PORT_STAT_CONNECTION;\r\nusb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_CONNECTION;\r\nusb->max_bytes_per_frame = 0;\r\nfhci_usb_enable_interrupt(usb);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nvoid fhci_device_connected_interrupt(struct fhci_hcd *fhci)\r\n{\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nint state;\r\nint ret;\r\nfhci_dbg(fhci, "-> %s\n", __func__);\r\nfhci_usb_disable_interrupt(usb);\r\nstate = fhci_ioports_check_bus_state(fhci);\r\nif (state == 1) {\r\nret = qe_usb_clock_set(fhci->lowspeed_clk, USB_CLOCK >> 3);\r\nif (ret) {\r\nfhci_warn(fhci, "Low-Speed device is not supported, "\r\n"try use BRGx\n");\r\ngoto out;\r\n}\r\nusb->port_status = FHCI_PORT_LOW;\r\nsetbits8(&usb->fhci->regs->usb_mod, USB_MODE_LSS);\r\nusb->vroot_hub->port.wPortStatus |=\r\n(USB_PORT_STAT_LOW_SPEED |\r\nUSB_PORT_STAT_CONNECTION);\r\nusb->vroot_hub->port.wPortChange |=\r\nUSB_PORT_STAT_C_CONNECTION;\r\nusb->max_bytes_per_frame =\r\n(MAX_BYTES_PER_FRAME >> 3) - 7;\r\nfhci_port_enable(usb);\r\n} else if (state == 2) {\r\nret = qe_usb_clock_set(fhci->fullspeed_clk, USB_CLOCK);\r\nif (ret) {\r\nfhci_warn(fhci, "Full-Speed device is not supported, "\r\n"try use CLKx\n");\r\ngoto out;\r\n}\r\nusb->port_status = FHCI_PORT_FULL;\r\nclrbits8(&usb->fhci->regs->usb_mod, USB_MODE_LSS);\r\nusb->vroot_hub->port.wPortStatus &=\r\n~USB_PORT_STAT_LOW_SPEED;\r\nusb->vroot_hub->port.wPortStatus |=\r\nUSB_PORT_STAT_CONNECTION;\r\nusb->vroot_hub->port.wPortChange |=\r\nUSB_PORT_STAT_C_CONNECTION;\r\nusb->max_bytes_per_frame = (MAX_BYTES_PER_FRAME - 15);\r\nfhci_port_enable(usb);\r\n}\r\nout:\r\nfhci_usb_enable_interrupt(usb);\r\nfhci_dbg(fhci, "<- %s\n", __func__);\r\n}\r\nirqreturn_t fhci_frame_limit_timer_irq(int irq, void *_hcd)\r\n{\r\nstruct usb_hcd *hcd = _hcd;\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nstruct fhci_usb *usb = fhci->usb_lld;\r\nspin_lock(&fhci->lock);\r\ngtm_set_exact_timer16(fhci->timer, 1000, false);\r\nif (usb->actual_frame->frame_status == FRAME_IS_TRANSMITTED) {\r\nusb->actual_frame->frame_status = FRAME_TIMER_END_TRANSMISSION;\r\nfhci_push_dummy_bd(usb->ep0);\r\n}\r\nfhci_schedule_transactions(usb);\r\nspin_unlock(&fhci->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void abort_transmission(struct fhci_usb *usb)\r\n{\r\nfhci_dbg(usb->fhci, "-> %s\n", __func__);\r\nqe_issue_cmd(QE_USB_STOP_TX, QE_CR_SUBBLOCK_USB, EP_ZERO, 0);\r\nout_8(&usb->fhci->regs->usb_comm, USB_CMD_FLUSH_FIFO | EP_ZERO);\r\nudelay(1000);\r\nfhci_flush_bds(usb);\r\nqe_issue_cmd(QE_USB_RESTART_TX, QE_CR_SUBBLOCK_USB, EP_ZERO, 0);\r\nfhci_dbg(usb->fhci, "<- %s\n", __func__);\r\n}\r\nirqreturn_t fhci_irq(struct usb_hcd *hcd)\r\n{\r\nstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\r\nstruct fhci_usb *usb;\r\nu16 usb_er = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fhci->lock, flags);\r\nusb = fhci->usb_lld;\r\nusb_er |= in_be16(&usb->fhci->regs->usb_event) &\r\nin_be16(&usb->fhci->regs->usb_mask);\r\nout_be16(&usb->fhci->regs->usb_event, usb_er);\r\nfhci_dbg_isr(fhci, usb_er);\r\nif (usb_er & USB_E_RESET_MASK) {\r\nif ((usb->port_status == FHCI_PORT_FULL) ||\r\n(usb->port_status == FHCI_PORT_LOW)) {\r\nfhci_device_disconnected_interrupt(fhci);\r\nusb_er &= ~USB_E_IDLE_MASK;\r\n} else if (usb->port_status == FHCI_PORT_WAITING) {\r\nusb->port_status = FHCI_PORT_DISCONNECTING;\r\nusb->saved_msk |= USB_E_IDLE_MASK;\r\nout_be16(&usb->fhci->regs->usb_event,\r\nusb->saved_msk);\r\n} else if (usb->port_status == FHCI_PORT_DISABLED) {\r\nif (fhci_ioports_check_bus_state(fhci) == 1)\r\nfhci_device_connected_interrupt(fhci);\r\n}\r\nusb_er &= ~USB_E_RESET_MASK;\r\n}\r\nif (usb_er & USB_E_MSF_MASK) {\r\nabort_transmission(fhci->usb_lld);\r\nusb_er &= ~USB_E_MSF_MASK;\r\n}\r\nif (usb_er & (USB_E_SOF_MASK | USB_E_SFT_MASK)) {\r\nsof_interrupt(fhci);\r\nusb_er &= ~(USB_E_SOF_MASK | USB_E_SFT_MASK);\r\n}\r\nif (usb_er & USB_E_TXB_MASK) {\r\nfhci_tx_conf_interrupt(fhci->usb_lld);\r\nusb_er &= ~USB_E_TXB_MASK;\r\n}\r\nif (usb_er & USB_E_TXE1_MASK) {\r\nfhci_tx_conf_interrupt(fhci->usb_lld);\r\nusb_er &= ~USB_E_TXE1_MASK;\r\n}\r\nif (usb_er & USB_E_IDLE_MASK) {\r\nif (usb->port_status == FHCI_PORT_DISABLED) {\r\nusb_er &= ~USB_E_RESET_MASK;\r\nfhci_device_connected_interrupt(fhci);\r\n} else if (usb->port_status ==\r\nFHCI_PORT_DISCONNECTING) {\r\nusb->saved_msk &= ~USB_E_IDLE_MASK;\r\nout_be16(&usb->fhci->regs->usb_mask,\r\nusb->saved_msk);\r\n} else {\r\nfhci_dbg_isr(fhci, -1);\r\n}\r\nusb_er &= ~USB_E_IDLE_MASK;\r\n}\r\nspin_unlock_irqrestore(&fhci->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void process_done_list(unsigned long data)\r\n{\r\nstruct urb *urb;\r\nstruct ed *ed;\r\nstruct td *td;\r\nstruct urb_priv *urb_priv;\r\nstruct fhci_hcd *fhci = (struct fhci_hcd *)data;\r\ndisable_irq(fhci->timer->irq);\r\ndisable_irq(fhci_to_hcd(fhci)->irq);\r\nspin_lock(&fhci->lock);\r\ntd = fhci_remove_td_from_done_list(fhci->hc_list);\r\nwhile (td != NULL) {\r\nurb = td->urb;\r\nurb_priv = urb->hcpriv;\r\ned = td->ed;\r\nfhci_done_td(urb, td);\r\nurb_priv->tds_cnt++;\r\nif (urb_priv->tds_cnt == urb_priv->num_of_tds) {\r\nfhci_urb_complete_free(fhci, urb);\r\n} else if (urb_priv->state == URB_DEL &&\r\ned->state == FHCI_ED_SKIP) {\r\nfhci_del_ed_list(fhci, ed);\r\ned->state = FHCI_ED_OPER;\r\n} else if (ed->state == FHCI_ED_HALTED) {\r\nurb_priv->state = URB_DEL;\r\ned->state = FHCI_ED_URB_DEL;\r\nfhci_del_ed_list(fhci, ed);\r\ned->state = FHCI_ED_OPER;\r\n}\r\ntd = fhci_remove_td_from_done_list(fhci->hc_list);\r\n}\r\nspin_unlock(&fhci->lock);\r\nenable_irq(fhci->timer->irq);\r\nenable_irq(fhci_to_hcd(fhci)->irq);\r\n}\r\nu32 fhci_transfer_confirm_callback(struct fhci_hcd *fhci)\r\n{\r\nif (!fhci->process_done_task->state)\r\ntasklet_schedule(fhci->process_done_task);\r\nreturn 0;\r\n}\r\nvoid fhci_queue_urb(struct fhci_hcd *fhci, struct urb *urb)\r\n{\r\nstruct ed *ed = urb->ep->hcpriv;\r\nstruct urb_priv *urb_priv = urb->hcpriv;\r\nu32 data_len = urb->transfer_buffer_length;\r\nint urb_state = 0;\r\nint toggle = 0;\r\nstruct td *td;\r\nu8 *data;\r\nu16 cnt = 0;\r\nif (ed == NULL) {\r\ned = fhci_get_empty_ed(fhci);\r\ned->dev_addr = usb_pipedevice(urb->pipe);\r\ned->ep_addr = usb_pipeendpoint(urb->pipe);\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_CONTROL:\r\ned->mode = FHCI_TF_CTRL;\r\nbreak;\r\ncase PIPE_BULK:\r\ned->mode = FHCI_TF_BULK;\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\ned->mode = FHCI_TF_INTR;\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\ned->mode = FHCI_TF_ISO;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ned->speed = (urb->dev->speed == USB_SPEED_LOW) ?\r\nFHCI_LOW_SPEED : FHCI_FULL_SPEED;\r\ned->max_pkt_size = usb_maxpacket(urb->dev,\r\nurb->pipe, usb_pipeout(urb->pipe));\r\nurb->ep->hcpriv = ed;\r\nfhci_dbg(fhci, "new ep speed=%d max_pkt_size=%d\n",\r\ned->speed, ed->max_pkt_size);\r\n}\r\nif (ed->mode == FHCI_TF_ISO && urb->transfer_flags & URB_ISO_ASAP)\r\nurb->start_frame = ed->td_head ? ed->last_iso + 1 :\r\nget_frame_num(fhci);\r\nif (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe)))\r\ntoggle = USB_TD_TOGGLE_CARRY;\r\nelse {\r\ntoggle = USB_TD_TOGGLE_DATA0;\r\nusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\r\nusb_pipeout(urb->pipe), 1);\r\n}\r\nurb_priv->tds_cnt = 0;\r\nurb_priv->ed = ed;\r\nif (data_len > 0)\r\ndata = urb->transfer_buffer;\r\nelse\r\ndata = NULL;\r\nswitch (ed->mode) {\r\ncase FHCI_TF_BULK:\r\nif (urb->transfer_flags & URB_ZERO_PACKET &&\r\nurb->transfer_buffer_length > 0 &&\r\n((urb->transfer_buffer_length %\r\nusb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe))) == 0))\r\nurb_state = US_BULK0;\r\nwhile (data_len > 4096) {\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,\r\nusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\r\nFHCI_TA_IN,\r\ncnt ? USB_TD_TOGGLE_CARRY :\r\ntoggle,\r\ndata, 4096, 0, 0, true);\r\ndata += 4096;\r\ndata_len -= 4096;\r\ncnt++;\r\n}\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,\r\nusb_pipeout(urb->pipe) ? FHCI_TA_OUT : FHCI_TA_IN,\r\ncnt ? USB_TD_TOGGLE_CARRY : toggle,\r\ndata, data_len, 0, 0, true);\r\ncnt++;\r\nif (urb->transfer_flags & URB_ZERO_PACKET &&\r\ncnt < urb_priv->num_of_tds) {\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,\r\nusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\r\nFHCI_TA_IN,\r\nUSB_TD_TOGGLE_CARRY, NULL, 0, 0, 0, true);\r\ncnt++;\r\n}\r\nbreak;\r\ncase FHCI_TF_INTR:\r\nurb->start_frame = get_frame_num(fhci) + 1;\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\r\nusb_pipeout(urb->pipe) ? FHCI_TA_OUT : FHCI_TA_IN,\r\nUSB_TD_TOGGLE_DATA0, data, data_len,\r\nurb->interval, urb->start_frame, true);\r\nbreak;\r\ncase FHCI_TF_CTRL:\r\ned->dev_addr = usb_pipedevice(urb->pipe);\r\ned->max_pkt_size = usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe));\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++, FHCI_TA_SETUP,\r\nUSB_TD_TOGGLE_DATA0, urb->setup_packet, 8, 0, 0, true);\r\nif (data_len > 0) {\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\r\nusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\r\nFHCI_TA_IN,\r\nUSB_TD_TOGGLE_DATA1, data, data_len, 0, 0,\r\ntrue);\r\n}\r\nif (data_len > 0)\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\r\n(usb_pipeout(urb->pipe) ? FHCI_TA_IN :\r\nFHCI_TA_OUT),\r\nUSB_TD_TOGGLE_DATA1, data, 0, 0, 0, true);\r\nelse\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\r\nFHCI_TA_IN,\r\nUSB_TD_TOGGLE_DATA1, data, 0, 0, 0, true);\r\nurb_state = US_CTRL_SETUP;\r\nbreak;\r\ncase FHCI_TF_ISO:\r\nfor (cnt = 0; cnt < urb->number_of_packets; cnt++) {\r\nu16 frame = urb->start_frame;\r\nframe += cnt * urb->interval;\r\nframe &= 0x07ff;\r\ntd = fhci_td_fill(fhci, urb, urb_priv, ed, cnt,\r\nusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\r\nFHCI_TA_IN,\r\nUSB_TD_TOGGLE_DATA0,\r\ndata + urb->iso_frame_desc[cnt].offset,\r\nurb->iso_frame_desc[cnt].length,\r\nurb->interval, frame, true);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nurb->pipe &= ~0x1f;\r\nurb->pipe |= urb_state & 0x1f;\r\nurb_priv->state = URB_INPROGRESS;\r\nif (!ed->td_head) {\r\ned->state = FHCI_ED_OPER;\r\nswitch (ed->mode) {\r\ncase FHCI_TF_CTRL:\r\nlist_add(&ed->node, &fhci->hc_list->ctrl_list);\r\nbreak;\r\ncase FHCI_TF_BULK:\r\nlist_add(&ed->node, &fhci->hc_list->bulk_list);\r\nbreak;\r\ncase FHCI_TF_INTR:\r\nlist_add(&ed->node, &fhci->hc_list->intr_list);\r\nbreak;\r\ncase FHCI_TF_ISO:\r\nlist_add(&ed->node, &fhci->hc_list->iso_list);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfhci_add_tds_to_ed(ed, urb_priv->tds, urb_priv->num_of_tds);\r\nfhci->active_urbs++;\r\n}
