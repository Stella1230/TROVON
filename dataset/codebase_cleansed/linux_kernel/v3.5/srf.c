void smt_init_evc(struct s_smc *smc)\r\n{\r\nstruct s_srf_evc *evc ;\r\nconst struct evc_init *init ;\r\nint i ;\r\nint index ;\r\nint offset ;\r\nstatic u_char fail_safe = FALSE ;\r\nmemset((char *)smc->evcs,0,sizeof(smc->evcs)) ;\r\nevc = smc->evcs ;\r\ninit = evc_inits ;\r\nfor (i = 0 ; (unsigned) i < MAX_INIT_EVC ; i++) {\r\nfor (index = 0 ; index < init->n ; index++) {\r\nevc->evc_code = init->code ;\r\nevc->evc_para = init->para ;\r\nevc->evc_index = init->index + index ;\r\n#ifndef DEBUG\r\nevc->evc_multiple = &fail_safe ;\r\nevc->evc_cond_state = &fail_safe ;\r\n#endif\r\nevc++ ;\r\n}\r\ninit++ ;\r\n}\r\nif ((unsigned) (evc - smc->evcs) > MAX_EVCS) {\r\nSMT_PANIC(smc,SMT_E0127, SMT_E0127_MSG) ;\r\n}\r\nsmc->evcs[0].evc_cond_state = &smc->mib.fddiSMTPeerWrapFlag ;\r\nsmc->evcs[1].evc_cond_state =\r\n&smc->mib.m[MAC0].fddiMACDuplicateAddressCond ;\r\nsmc->evcs[2].evc_cond_state =\r\n&smc->mib.m[MAC0].fddiMACFrameErrorFlag ;\r\nsmc->evcs[3].evc_cond_state =\r\n&smc->mib.m[MAC0].fddiMACNotCopiedFlag ;\r\nsmc->evcs[4].evc_multiple = &smc->mib.m[MAC0].fddiMACMultiple_N ;\r\nsmc->evcs[5].evc_multiple = &smc->mib.m[MAC0].fddiMACMultiple_P ;\r\noffset = 6 ;\r\nfor (i = 0 ; i < NUMPHYS ; i++) {\r\nsmc->evcs[offset + 0*NUMPHYS].evc_cond_state =\r\n&smc->mib.p[i].fddiPORTLerFlag ;\r\nsmc->evcs[offset + 1*NUMPHYS].evc_cond_state =\r\n&smc->mib.p[i].fddiPORTEB_Condition ;\r\nsmc->evcs[offset + 2*NUMPHYS].evc_multiple =\r\n&smc->mib.p[i].fddiPORTMultiple_U ;\r\nsmc->evcs[offset + 3*NUMPHYS].evc_multiple =\r\n&smc->mib.p[i].fddiPORTMultiple_P ;\r\noffset++ ;\r\n}\r\n#ifdef DEBUG\r\nfor (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {\r\nif (SMT_IS_CONDITION(evc->evc_code)) {\r\nif (!evc->evc_cond_state) {\r\nSMT_PANIC(smc,SMT_E0128, SMT_E0128_MSG) ;\r\n}\r\nevc->evc_multiple = &fail_safe ;\r\n}\r\nelse {\r\nif (!evc->evc_multiple) {\r\nSMT_PANIC(smc,SMT_E0129, SMT_E0129_MSG) ;\r\n}\r\nevc->evc_cond_state = &fail_safe ;\r\n}\r\n}\r\n#endif\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmc->srf.sr_state = SR0_WAIT ;\r\n}\r\nstatic struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index)\r\n{\r\nint i ;\r\nstruct s_srf_evc *evc ;\r\nfor (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {\r\nif (evc->evc_code == code && evc->evc_index == index)\r\nreturn evc;\r\n}\r\nreturn NULL;\r\n}\r\nvoid smt_srf_event(struct s_smc *smc, int code, int index, int cond)\r\n{\r\nstruct s_srf_evc *evc ;\r\nint cond_asserted = 0 ;\r\nint cond_deasserted = 0 ;\r\nint event_occurred = 0 ;\r\nint tsr ;\r\nint T_Limit = 2*TICKS_PER_SECOND ;\r\nif (code == SMT_COND_MAC_DUP_ADDR && cond) {\r\nRS_SET(smc,RS_DUPADDR) ;\r\n}\r\nif (code) {\r\nDB_SMT("SRF: %s index %d\n",srf_names[code],index) ;\r\nif (!(evc = smt_get_evc(smc,code,index))) {\r\nDB_SMT("SRF : smt_get_evc() failed\n",0,0) ;\r\nreturn ;\r\n}\r\nif (SMT_IS_CONDITION(code)) {\r\nif (*evc->evc_cond_state == cond)\r\nreturn ;\r\n}\r\nsmt_set_timestamp(smc,smc->mib.fddiSMTTransitionTimeStamp) ;\r\nif (SMT_IS_CONDITION(code)) {\r\nDB_SMT("SRF: condition is %s\n",cond ? "ON":"OFF",0) ;\r\nif (cond) {\r\n*evc->evc_cond_state = TRUE ;\r\nevc->evc_rep_required = TRUE ;\r\nsmc->srf.any_report = TRUE ;\r\ncond_asserted = TRUE ;\r\n}\r\nelse {\r\n*evc->evc_cond_state = FALSE ;\r\ncond_deasserted = TRUE ;\r\n}\r\n}\r\nelse {\r\nif (evc->evc_rep_required) {\r\n*evc->evc_multiple = TRUE ;\r\n}\r\nelse {\r\nevc->evc_rep_required = TRUE ;\r\n*evc->evc_multiple = FALSE ;\r\n}\r\nsmc->srf.any_report = TRUE ;\r\nevent_occurred = TRUE ;\r\n}\r\n#ifdef FDDI_MIB\r\nsnmp_srf_event(smc,evc) ;\r\n#endif\r\n}\r\ntsr = smt_get_time() - smc->srf.TSR ;\r\nswitch (smc->srf.sr_state) {\r\ncase SR0_WAIT :\r\nif (cond_asserted && tsr < T_Limit) {\r\nsmc->srf.SRThreshold = THRESHOLD_2 ;\r\nsmc->srf.sr_state = SR1_HOLDOFF ;\r\nbreak ;\r\n}\r\nif (cond_deasserted && tsr < T_Limit) {\r\nsmc->srf.sr_state = SR1_HOLDOFF ;\r\nbreak ;\r\n}\r\nif (event_occurred && tsr < T_Limit) {\r\nsmc->srf.sr_state = SR1_HOLDOFF ;\r\nbreak ;\r\n}\r\nif (cond_asserted && tsr >= T_Limit) {\r\nsmc->srf.SRThreshold = THRESHOLD_2 ;\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmt_send_srf(smc) ;\r\nbreak ;\r\n}\r\nif (cond_deasserted && tsr >= T_Limit) {\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmt_send_srf(smc) ;\r\nbreak ;\r\n}\r\nif (event_occurred && tsr >= T_Limit) {\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmt_send_srf(smc) ;\r\nbreak ;\r\n}\r\nif (smc->srf.any_report && (u_long) tsr >=\r\nsmc->srf.SRThreshold) {\r\nsmc->srf.SRThreshold *= 2 ;\r\nif (smc->srf.SRThreshold > THRESHOLD_32)\r\nsmc->srf.SRThreshold = THRESHOLD_32 ;\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmt_send_srf(smc) ;\r\nbreak ;\r\n}\r\nif (!smc->mib.fddiSMTStatRptPolicy) {\r\nsmc->srf.sr_state = SR2_DISABLED ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SR1_HOLDOFF :\r\nif (tsr >= T_Limit) {\r\nsmc->srf.sr_state = SR0_WAIT ;\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmt_send_srf(smc) ;\r\nbreak ;\r\n}\r\nif (cond_asserted) {\r\nsmc->srf.SRThreshold = THRESHOLD_2 ;\r\n}\r\nif (!smc->mib.fddiSMTStatRptPolicy) {\r\nsmc->srf.sr_state = SR2_DISABLED ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SR2_DISABLED :\r\nif (smc->mib.fddiSMTStatRptPolicy) {\r\nsmc->srf.sr_state = SR0_WAIT ;\r\nsmc->srf.TSR = smt_get_time() ;\r\nsmc->srf.SRThreshold = THRESHOLD_2 ;\r\nclear_all_rep(smc) ;\r\nbreak ;\r\n}\r\nbreak ;\r\n}\r\n}\r\nstatic void clear_all_rep(struct s_smc *smc)\r\n{\r\nstruct s_srf_evc *evc ;\r\nint i ;\r\nfor (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {\r\nevc->evc_rep_required = FALSE ;\r\nif (SMT_IS_CONDITION(evc->evc_code))\r\n*evc->evc_cond_state = FALSE ;\r\n}\r\nsmc->srf.any_report = FALSE ;\r\n}\r\nstatic void clear_reported(struct s_smc *smc)\r\n{\r\nstruct s_srf_evc *evc ;\r\nint i ;\r\nsmc->srf.any_report = FALSE ;\r\nfor (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {\r\nif (SMT_IS_CONDITION(evc->evc_code)) {\r\nif (*evc->evc_cond_state == FALSE)\r\nevc->evc_rep_required = FALSE ;\r\nelse\r\nsmc->srf.any_report = TRUE ;\r\n}\r\nelse {\r\nevc->evc_rep_required = FALSE ;\r\n*evc->evc_multiple = FALSE ;\r\n}\r\n}\r\n}\r\nstatic void smt_send_srf(struct s_smc *smc)\r\n{\r\nstruct smt_header *smt ;\r\nstruct s_srf_evc *evc ;\r\nSK_LOC_DECL(struct s_pcon,pcon) ;\r\nSMbuf *mb ;\r\nint i ;\r\nstatic const struct fddi_addr SMT_SRF_DA = {\r\n{ 0x80, 0x01, 0x43, 0x00, 0x80, 0x08 }\r\n} ;\r\nif (!smc->r.sm_ma_avail)\r\nreturn ;\r\nif (!(mb = smt_build_frame(smc,SMT_SRF,SMT_ANNOUNCE,0)))\r\nreturn ;\r\nRS_SET(smc,RS_SOFTERROR) ;\r\nsmt = smtod(mb, struct smt_header *) ;\r\nsmt->smt_dest = SMT_SRF_DA ;\r\npcon.pc_len = SMT_MAX_INFO_LEN ;\r\npcon.pc_err = 0 ;\r\npcon.pc_badset = 0 ;\r\npcon.pc_p = (void *) (smt + 1) ;\r\nsmt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;\r\nsmt_add_para(smc,&pcon,(u_short) SMT_P1034,0,0) ;\r\nfor (i = 0, evc = smc->evcs ; (unsigned) i < MAX_EVCS ; i++, evc++) {\r\nif (evc->evc_rep_required) {\r\nsmt_add_para(smc,&pcon,evc->evc_para,\r\n(int)evc->evc_index,0) ;\r\n}\r\n}\r\nsmt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;\r\nmb->sm_len = smt->smt_len + sizeof(struct smt_header) ;\r\nDB_SMT("SRF: sending SRF at %x, len %d\n",smt,mb->sm_len) ;\r\nDB_SMT("SRF: state SR%d Threshold %d\n",\r\nsmc->srf.sr_state,smc->srf.SRThreshold/TICKS_PER_SECOND) ;\r\n#ifdef DEBUG\r\ndump_smt(smc,smt,"SRF Send") ;\r\n#endif\r\nsmt_send_frame(smc,mb,FC_SMT_INFO,0) ;\r\nclear_reported(smc) ;\r\n}
