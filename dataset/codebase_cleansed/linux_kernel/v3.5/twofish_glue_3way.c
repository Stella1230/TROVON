static inline void twofish_enc_blk_3way(struct twofish_ctx *ctx, u8 *dst,\r\nconst u8 *src)\r\n{\r\n__twofish_enc_blk_3way(ctx, dst, src, false);\r\n}\r\nstatic inline void twofish_enc_blk_xor_3way(struct twofish_ctx *ctx, u8 *dst,\r\nconst u8 *src)\r\n{\r\n__twofish_enc_blk_3way(ctx, dst, src, true);\r\n}\r\nstatic int ecb_crypt(struct blkcipher_desc *desc, struct blkcipher_walk *walk,\r\nvoid (*fn)(struct twofish_ctx *, u8 *, const u8 *),\r\nvoid (*fn_3way)(struct twofish_ctx *, u8 *, const u8 *))\r\n{\r\nstruct twofish_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int bsize = TF_BLOCK_SIZE;\r\nunsigned int nbytes;\r\nint err;\r\nerr = blkcipher_walk_virt(desc, walk);\r\nwhile ((nbytes = walk->nbytes)) {\r\nu8 *wsrc = walk->src.virt.addr;\r\nu8 *wdst = walk->dst.virt.addr;\r\nif (nbytes >= bsize * 3) {\r\ndo {\r\nfn_3way(ctx, wdst, wsrc);\r\nwsrc += bsize * 3;\r\nwdst += bsize * 3;\r\nnbytes -= bsize * 3;\r\n} while (nbytes >= bsize * 3);\r\nif (nbytes < bsize)\r\ngoto done;\r\n}\r\ndo {\r\nfn(ctx, wdst, wsrc);\r\nwsrc += bsize;\r\nwdst += bsize;\r\nnbytes -= bsize;\r\n} while (nbytes >= bsize);\r\ndone:\r\nerr = blkcipher_walk_done(desc, walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int ecb_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn ecb_crypt(desc, &walk, twofish_enc_blk, twofish_enc_blk_3way);\r\n}\r\nstatic int ecb_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nreturn ecb_crypt(desc, &walk, twofish_dec_blk, twofish_dec_blk_3way);\r\n}\r\nstatic unsigned int __cbc_encrypt(struct blkcipher_desc *desc,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct twofish_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int bsize = TF_BLOCK_SIZE;\r\nunsigned int nbytes = walk->nbytes;\r\nu128 *src = (u128 *)walk->src.virt.addr;\r\nu128 *dst = (u128 *)walk->dst.virt.addr;\r\nu128 *iv = (u128 *)walk->iv;\r\ndo {\r\nu128_xor(dst, src, iv);\r\ntwofish_enc_blk(ctx, (u8 *)dst, (u8 *)dst);\r\niv = dst;\r\nsrc += 1;\r\ndst += 1;\r\nnbytes -= bsize;\r\n} while (nbytes >= bsize);\r\nu128_xor((u128 *)walk->iv, (u128 *)walk->iv, iv);\r\nreturn nbytes;\r\n}\r\nstatic int cbc_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nwhile ((nbytes = walk.nbytes)) {\r\nnbytes = __cbc_encrypt(desc, &walk);\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned int __cbc_decrypt(struct blkcipher_desc *desc,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct twofish_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int bsize = TF_BLOCK_SIZE;\r\nunsigned int nbytes = walk->nbytes;\r\nu128 *src = (u128 *)walk->src.virt.addr;\r\nu128 *dst = (u128 *)walk->dst.virt.addr;\r\nu128 ivs[3 - 1];\r\nu128 last_iv;\r\nsrc += nbytes / bsize - 1;\r\ndst += nbytes / bsize - 1;\r\nlast_iv = *src;\r\nif (nbytes >= bsize * 3) {\r\ndo {\r\nnbytes -= bsize * (3 - 1);\r\nsrc -= 3 - 1;\r\ndst -= 3 - 1;\r\nivs[0] = src[0];\r\nivs[1] = src[1];\r\ntwofish_dec_blk_3way(ctx, (u8 *)dst, (u8 *)src);\r\nu128_xor(dst + 1, dst + 1, ivs + 0);\r\nu128_xor(dst + 2, dst + 2, ivs + 1);\r\nnbytes -= bsize;\r\nif (nbytes < bsize)\r\ngoto done;\r\nu128_xor(dst, dst, src - 1);\r\nsrc -= 1;\r\ndst -= 1;\r\n} while (nbytes >= bsize * 3);\r\nif (nbytes < bsize)\r\ngoto done;\r\n}\r\nfor (;;) {\r\ntwofish_dec_blk(ctx, (u8 *)dst, (u8 *)src);\r\nnbytes -= bsize;\r\nif (nbytes < bsize)\r\nbreak;\r\nu128_xor(dst, dst, src - 1);\r\nsrc -= 1;\r\ndst -= 1;\r\n}\r\ndone:\r\nu128_xor(dst, dst, (u128 *)walk->iv);\r\n*(u128 *)walk->iv = last_iv;\r\nreturn nbytes;\r\n}\r\nstatic int cbc_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt(desc, &walk);\r\nwhile ((nbytes = walk.nbytes)) {\r\nnbytes = __cbc_decrypt(desc, &walk);\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic inline void u128_to_be128(be128 *dst, const u128 *src)\r\n{\r\ndst->a = cpu_to_be64(src->a);\r\ndst->b = cpu_to_be64(src->b);\r\n}\r\nstatic inline void be128_to_u128(u128 *dst, const be128 *src)\r\n{\r\ndst->a = be64_to_cpu(src->a);\r\ndst->b = be64_to_cpu(src->b);\r\n}\r\nstatic inline void u128_inc(u128 *i)\r\n{\r\ni->b++;\r\nif (!i->b)\r\ni->a++;\r\n}\r\nstatic void ctr_crypt_final(struct blkcipher_desc *desc,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct twofish_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nu8 *ctrblk = walk->iv;\r\nu8 keystream[TF_BLOCK_SIZE];\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nunsigned int nbytes = walk->nbytes;\r\ntwofish_enc_blk(ctx, keystream, ctrblk);\r\ncrypto_xor(keystream, src, nbytes);\r\nmemcpy(dst, keystream, nbytes);\r\ncrypto_inc(ctrblk, TF_BLOCK_SIZE);\r\n}\r\nstatic unsigned int __ctr_crypt(struct blkcipher_desc *desc,\r\nstruct blkcipher_walk *walk)\r\n{\r\nstruct twofish_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nunsigned int bsize = TF_BLOCK_SIZE;\r\nunsigned int nbytes = walk->nbytes;\r\nu128 *src = (u128 *)walk->src.virt.addr;\r\nu128 *dst = (u128 *)walk->dst.virt.addr;\r\nu128 ctrblk;\r\nbe128 ctrblocks[3];\r\nbe128_to_u128(&ctrblk, (be128 *)walk->iv);\r\nif (nbytes >= bsize * 3) {\r\ndo {\r\nif (dst != src) {\r\ndst[0] = src[0];\r\ndst[1] = src[1];\r\ndst[2] = src[2];\r\n}\r\nu128_to_be128(&ctrblocks[0], &ctrblk);\r\nu128_inc(&ctrblk);\r\nu128_to_be128(&ctrblocks[1], &ctrblk);\r\nu128_inc(&ctrblk);\r\nu128_to_be128(&ctrblocks[2], &ctrblk);\r\nu128_inc(&ctrblk);\r\ntwofish_enc_blk_xor_3way(ctx, (u8 *)dst,\r\n(u8 *)ctrblocks);\r\nsrc += 3;\r\ndst += 3;\r\nnbytes -= bsize * 3;\r\n} while (nbytes >= bsize * 3);\r\nif (nbytes < bsize)\r\ngoto done;\r\n}\r\ndo {\r\nif (dst != src)\r\n*dst = *src;\r\nu128_to_be128(&ctrblocks[0], &ctrblk);\r\nu128_inc(&ctrblk);\r\ntwofish_enc_blk(ctx, (u8 *)ctrblocks, (u8 *)ctrblocks);\r\nu128_xor(dst, dst, (u128 *)ctrblocks);\r\nsrc += 1;\r\ndst += 1;\r\nnbytes -= bsize;\r\n} while (nbytes >= bsize);\r\ndone:\r\nu128_to_be128((be128 *)walk->iv, &ctrblk);\r\nreturn nbytes;\r\n}\r\nstatic int ctr_crypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct blkcipher_walk walk;\r\nint err;\r\nblkcipher_walk_init(&walk, dst, src, nbytes);\r\nerr = blkcipher_walk_virt_block(desc, &walk, TF_BLOCK_SIZE);\r\nwhile ((nbytes = walk.nbytes) >= TF_BLOCK_SIZE) {\r\nnbytes = __ctr_crypt(desc, &walk);\r\nerr = blkcipher_walk_done(desc, &walk, nbytes);\r\n}\r\nif (walk.nbytes) {\r\nctr_crypt_final(desc, &walk);\r\nerr = blkcipher_walk_done(desc, &walk, 0);\r\n}\r\nreturn err;\r\n}\r\nstatic void encrypt_callback(void *priv, u8 *srcdst, unsigned int nbytes)\r\n{\r\nconst unsigned int bsize = TF_BLOCK_SIZE;\r\nstruct twofish_ctx *ctx = priv;\r\nint i;\r\nif (nbytes == 3 * bsize) {\r\ntwofish_enc_blk_3way(ctx, srcdst, srcdst);\r\nreturn;\r\n}\r\nfor (i = 0; i < nbytes / bsize; i++, srcdst += bsize)\r\ntwofish_enc_blk(ctx, srcdst, srcdst);\r\n}\r\nstatic void decrypt_callback(void *priv, u8 *srcdst, unsigned int nbytes)\r\n{\r\nconst unsigned int bsize = TF_BLOCK_SIZE;\r\nstruct twofish_ctx *ctx = priv;\r\nint i;\r\nif (nbytes == 3 * bsize) {\r\ntwofish_dec_blk_3way(ctx, srcdst, srcdst);\r\nreturn;\r\n}\r\nfor (i = 0; i < nbytes / bsize; i++, srcdst += bsize)\r\ntwofish_dec_blk(ctx, srcdst, srcdst);\r\n}\r\nstatic int lrw_twofish_setkey(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct twofish_lrw_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint err;\r\nerr = __twofish_setkey(&ctx->twofish_ctx, key, keylen - TF_BLOCK_SIZE,\r\n&tfm->crt_flags);\r\nif (err)\r\nreturn err;\r\nreturn lrw_init_table(&ctx->lrw_table, key + keylen - TF_BLOCK_SIZE);\r\n}\r\nstatic int lrw_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_lrw_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[3];\r\nstruct lrw_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.table_ctx = &ctx->lrw_table,\r\n.crypt_ctx = &ctx->twofish_ctx,\r\n.crypt_fn = encrypt_callback,\r\n};\r\nreturn lrw_crypt(desc, dst, src, nbytes, &req);\r\n}\r\nstatic int lrw_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_lrw_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[3];\r\nstruct lrw_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.table_ctx = &ctx->lrw_table,\r\n.crypt_ctx = &ctx->twofish_ctx,\r\n.crypt_fn = decrypt_callback,\r\n};\r\nreturn lrw_crypt(desc, dst, src, nbytes, &req);\r\n}\r\nstatic void lrw_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct twofish_lrw_ctx *ctx = crypto_tfm_ctx(tfm);\r\nlrw_free_table(&ctx->lrw_table);\r\n}\r\nstatic int xts_twofish_setkey(struct crypto_tfm *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct twofish_xts_ctx *ctx = crypto_tfm_ctx(tfm);\r\nu32 *flags = &tfm->crt_flags;\r\nint err;\r\nif (keylen % 2) {\r\n*flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n}\r\nerr = __twofish_setkey(&ctx->crypt_ctx, key, keylen / 2, flags);\r\nif (err)\r\nreturn err;\r\nreturn __twofish_setkey(&ctx->tweak_ctx, key + keylen / 2, keylen / 2,\r\nflags);\r\n}\r\nstatic int xts_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[3];\r\nstruct xts_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.tweak_ctx = &ctx->tweak_ctx,\r\n.tweak_fn = XTS_TWEAK_CAST(twofish_enc_blk),\r\n.crypt_ctx = &ctx->crypt_ctx,\r\n.crypt_fn = encrypt_callback,\r\n};\r\nreturn xts_crypt(desc, dst, src, nbytes, &req);\r\n}\r\nstatic int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[3];\r\nstruct xts_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.tweak_ctx = &ctx->tweak_ctx,\r\n.tweak_fn = XTS_TWEAK_CAST(twofish_enc_blk),\r\n.crypt_ctx = &ctx->crypt_ctx,\r\n.crypt_fn = decrypt_callback,\r\n};\r\nreturn xts_crypt(desc, dst, src, nbytes, &req);\r\n}\r\nstatic bool is_blacklisted_cpu(void)\r\n{\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\r\nreturn false;\r\nif (boot_cpu_data.x86 == 0x06 &&\r\n(boot_cpu_data.x86_model == 0x1c ||\r\nboot_cpu_data.x86_model == 0x26 ||\r\nboot_cpu_data.x86_model == 0x36)) {\r\nreturn true;\r\n}\r\nif (boot_cpu_data.x86 == 0x0f) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int __init init(void)\r\n{\r\nif (!force && is_blacklisted_cpu()) {\r\nprintk(KERN_INFO\r\n"twofish-x86_64-3way: performance on this CPU "\r\n"would be suboptimal: disabling "\r\n"twofish-x86_64-3way.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn crypto_register_algs(tf_algs, ARRAY_SIZE(tf_algs));\r\n}\r\nstatic void __exit fini(void)\r\n{\r\ncrypto_unregister_algs(tf_algs, ARRAY_SIZE(tf_algs));\r\n}
