int fdt_check_header(const void *fdt)\r\n{\r\nif (fdt_magic(fdt) == FDT_MAGIC) {\r\nif (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)\r\nreturn -FDT_ERR_BADVERSION;\r\nif (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)\r\nreturn -FDT_ERR_BADVERSION;\r\n} else if (fdt_magic(fdt) == FDT_SW_MAGIC) {\r\nif (fdt_size_dt_struct(fdt) == 0)\r\nreturn -FDT_ERR_BADSTATE;\r\n} else {\r\nreturn -FDT_ERR_BADMAGIC;\r\n}\r\nreturn 0;\r\n}\r\nconst void *fdt_offset_ptr(const void *fdt, int offset, int len)\r\n{\r\nconst char *p;\r\nif (fdt_version(fdt) >= 0x11)\r\nif (((offset + len) < offset)\r\n|| ((offset + len) > fdt_size_dt_struct(fdt)))\r\nreturn NULL;\r\np = _fdt_offset_ptr(fdt, offset);\r\nif (p + len < p)\r\nreturn NULL;\r\nreturn p;\r\n}\r\nuint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset)\r\n{\r\nconst uint32_t *tagp, *lenp;\r\nuint32_t tag;\r\nconst char *p;\r\nif (offset % FDT_TAGSIZE)\r\nreturn -1;\r\ntagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);\r\nif (! tagp)\r\nreturn FDT_END;\r\ntag = fdt32_to_cpu(*tagp);\r\noffset += FDT_TAGSIZE;\r\nswitch (tag) {\r\ncase FDT_BEGIN_NODE:\r\ndo {\r\np = fdt_offset_ptr(fdt, offset++, 1);\r\n} while (p && (*p != '\0'));\r\nif (! p)\r\nreturn FDT_END;\r\nbreak;\r\ncase FDT_PROP:\r\nlenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));\r\nif (! lenp)\r\nreturn FDT_END;\r\noffset += 2*FDT_TAGSIZE + fdt32_to_cpu(*lenp);\r\nbreak;\r\n}\r\nif (nextoffset)\r\n*nextoffset = FDT_TAGALIGN(offset);\r\nreturn tag;\r\n}\r\nint _fdt_check_node_offset(const void *fdt, int offset)\r\n{\r\nif ((offset < 0) || (offset % FDT_TAGSIZE)\r\n|| (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))\r\nreturn -FDT_ERR_BADOFFSET;\r\nreturn offset;\r\n}\r\nint fdt_next_node(const void *fdt, int offset, int *depth)\r\n{\r\nint nextoffset = 0;\r\nuint32_t tag;\r\nif (offset >= 0)\r\nif ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)\r\nreturn nextoffset;\r\ndo {\r\noffset = nextoffset;\r\ntag = fdt_next_tag(fdt, offset, &nextoffset);\r\nswitch (tag) {\r\ncase FDT_PROP:\r\ncase FDT_NOP:\r\nbreak;\r\ncase FDT_BEGIN_NODE:\r\nif (depth)\r\n(*depth)++;\r\nbreak;\r\ncase FDT_END_NODE:\r\nif (depth)\r\n(*depth)--;\r\nbreak;\r\ncase FDT_END:\r\nreturn -FDT_ERR_NOTFOUND;\r\ndefault:\r\nreturn -FDT_ERR_BADSTRUCTURE;\r\n}\r\n} while (tag != FDT_BEGIN_NODE);\r\nreturn offset;\r\n}\r\nconst char *_fdt_find_string(const char *strtab, int tabsize, const char *s)\r\n{\r\nint len = strlen(s) + 1;\r\nconst char *last = strtab + tabsize - len;\r\nconst char *p;\r\nfor (p = strtab; p <= last; p++)\r\nif (memcmp(p, s, len) == 0)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nint fdt_move(const void *fdt, void *buf, int bufsize)\r\n{\r\nFDT_CHECK_HEADER(fdt);\r\nif (fdt_totalsize(fdt) > bufsize)\r\nreturn -FDT_ERR_NOSPACE;\r\nmemmove(buf, fdt, fdt_totalsize(fdt));\r\nreturn 0;\r\n}
