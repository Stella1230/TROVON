static void brcmf_set_drvdata(struct brcmf_cfg80211_dev *dev, void *data)\r\n{\r\ndev->driver_data = data;\r\n}\r\nstatic void *brcmf_get_drvdata(struct brcmf_cfg80211_dev *dev)\r\n{\r\nvoid *data = NULL;\r\nif (dev)\r\ndata = dev->driver_data;\r\nreturn data;\r\n}\r\nstatic\r\nstruct brcmf_cfg80211_priv *brcmf_priv_get(struct brcmf_cfg80211_dev *cfg_dev)\r\n{\r\nstruct brcmf_cfg80211_iface *ci = brcmf_get_drvdata(cfg_dev);\r\nreturn ci->cfg_priv;\r\n}\r\nstatic bool check_sys_up(struct wiphy *wiphy)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nif (!test_bit(WL_STATUS_READY, &cfg_priv->status)) {\r\nWL_INFO("device is not ready : status (%d)\n",\r\n(int)cfg_priv->status);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic u16 brcmf_qdbm_to_mw(u8 qdbm)\r\n{\r\nuint factor = 1;\r\nint idx = qdbm - QDBM_OFFSET;\r\nif (idx >= QDBM_TABLE_LEN)\r\nreturn 0xFFFF;\r\nwhile (idx < 0) {\r\nidx += 40;\r\nfactor *= 10;\r\n}\r\nreturn (nqdBm_to_mW_map[idx] + factor / 2) / factor;\r\n}\r\nstatic u8 brcmf_mw_to_qdbm(u16 mw)\r\n{\r\nu8 qdbm;\r\nint offset;\r\nuint mw_uint = mw;\r\nuint boundary;\r\nif (mw_uint <= 1)\r\nreturn 0;\r\noffset = QDBM_OFFSET;\r\nwhile (mw_uint < QDBM_TABLE_LOW_BOUND) {\r\nmw_uint *= 10;\r\noffset -= 40;\r\n}\r\nfor (qdbm = 0; qdbm < QDBM_TABLE_LEN - 1; qdbm++) {\r\nboundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm + 1] -\r\nnqdBm_to_mW_map[qdbm]) / 2;\r\nif (mw_uint < boundary)\r\nbreak;\r\n}\r\nqdbm += (u8) offset;\r\nreturn qdbm;\r\n}\r\nstatic int\r\nbrcmf_exec_dcmd_u32(struct net_device *ndev, u32 cmd, u32 *par)\r\n{\r\nint err;\r\n__le32 par_le = cpu_to_le32(*par);\r\nerr = brcmf_exec_dcmd(ndev, cmd, &par_le, sizeof(__le32));\r\n*par = le32_to_cpu(par_le);\r\nreturn err;\r\n}\r\nstatic void convert_key_from_CPU(struct brcmf_wsec_key *key,\r\nstruct brcmf_wsec_key_le *key_le)\r\n{\r\nkey_le->index = cpu_to_le32(key->index);\r\nkey_le->len = cpu_to_le32(key->len);\r\nkey_le->algo = cpu_to_le32(key->algo);\r\nkey_le->flags = cpu_to_le32(key->flags);\r\nkey_le->rxiv.hi = cpu_to_le32(key->rxiv.hi);\r\nkey_le->rxiv.lo = cpu_to_le16(key->rxiv.lo);\r\nkey_le->iv_initialized = cpu_to_le32(key->iv_initialized);\r\nmemcpy(key_le->data, key->data, sizeof(key->data));\r\nmemcpy(key_le->ea, key->ea, sizeof(key->ea));\r\n}\r\nstatic int send_key_to_dongle(struct net_device *ndev,\r\nstruct brcmf_wsec_key *key)\r\n{\r\nint err;\r\nstruct brcmf_wsec_key_le key_le;\r\nconvert_key_from_CPU(key, &key_le);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_KEY, &key_le, sizeof(key_le));\r\nif (err)\r\nWL_ERR("WLC_SET_KEY error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct wireless_dev *wdev;\r\ns32 infra = 0;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nswitch (type) {\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_WDS:\r\nWL_ERR("type (%d) : currently we do not support this type\n",\r\ntype);\r\nreturn -EOPNOTSUPP;\r\ncase NL80211_IFTYPE_ADHOC:\r\ncfg_priv->conf->mode = WL_MODE_IBSS;\r\ninfra = 0;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\ncfg_priv->conf->mode = WL_MODE_BSS;\r\ninfra = 1;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_INFRA, &infra);\r\nif (err) {\r\nWL_ERR("WLC_SET_INFRA error (%d)\n", err);\r\nerr = -EAGAIN;\r\n} else {\r\nwdev = ndev->ieee80211_ptr;\r\nwdev->iftype = type;\r\n}\r\nWL_INFO("IF Type = %s\n",\r\n(cfg_priv->conf->mode == WL_MODE_IBSS) ? "Adhoc" : "Infra");\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_dev_intvar_set(struct net_device *ndev, s8 *name, s32 val)\r\n{\r\ns8 buf[BRCMF_DCMD_SMLEN];\r\nu32 len;\r\ns32 err = 0;\r\n__le32 val_le;\r\nval_le = cpu_to_le32(val);\r\nlen = brcmf_c_mkiovar(name, (char *)(&val_le), sizeof(val_le), buf,\r\nsizeof(buf));\r\nBUG_ON(!len);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_VAR, buf, len);\r\nif (err)\r\nWL_ERR("error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_dev_intvar_get(struct net_device *ndev, s8 *name, s32 *retval)\r\n{\r\nunion {\r\ns8 buf[BRCMF_DCMD_SMLEN];\r\n__le32 val;\r\n} var;\r\nu32 len;\r\nu32 data_null;\r\ns32 err = 0;\r\nlen =\r\nbrcmf_c_mkiovar(name, (char *)(&data_null), 0, (char *)(&var),\r\nsizeof(var.buf));\r\nBUG_ON(!len);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_GET_VAR, &var, len);\r\nif (err)\r\nWL_ERR("error (%d)\n", err);\r\n*retval = le32_to_cpu(var.val);\r\nreturn err;\r\n}\r\nstatic void brcmf_set_mpc(struct net_device *ndev, int mpc)\r\n{\r\ns32 err = 0;\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nif (test_bit(WL_STATUS_READY, &cfg_priv->status)) {\r\nerr = brcmf_dev_intvar_set(ndev, "mpc", mpc);\r\nif (err) {\r\nWL_ERR("fail to set mpc\n");\r\nreturn;\r\n}\r\nWL_INFO("MPC : %d\n", mpc);\r\n}\r\n}\r\nstatic void wl_iscan_prep(struct brcmf_scan_params_le *params_le,\r\nstruct brcmf_ssid *ssid)\r\n{\r\nmemcpy(params_le->bssid, ether_bcast, ETH_ALEN);\r\nparams_le->bss_type = DOT11_BSSTYPE_ANY;\r\nparams_le->scan_type = 0;\r\nparams_le->channel_num = 0;\r\nparams_le->nprobes = cpu_to_le32(-1);\r\nparams_le->active_time = cpu_to_le32(-1);\r\nparams_le->passive_time = cpu_to_le32(-1);\r\nparams_le->home_time = cpu_to_le32(-1);\r\nif (ssid && ssid->SSID_len)\r\nmemcpy(&params_le->ssid_le, ssid, sizeof(struct brcmf_ssid));\r\n}\r\nstatic s32\r\nbrcmf_dev_iovar_setbuf(struct net_device *ndev, s8 * iovar, void *param,\r\ns32 paramlen, void *bufptr, s32 buflen)\r\n{\r\ns32 iolen;\r\niolen = brcmf_c_mkiovar(iovar, param, paramlen, bufptr, buflen);\r\nBUG_ON(!iolen);\r\nreturn brcmf_exec_dcmd(ndev, BRCMF_C_SET_VAR, bufptr, iolen);\r\n}\r\nstatic s32\r\nbrcmf_dev_iovar_getbuf(struct net_device *ndev, s8 * iovar, void *param,\r\ns32 paramlen, void *bufptr, s32 buflen)\r\n{\r\ns32 iolen;\r\niolen = brcmf_c_mkiovar(iovar, param, paramlen, bufptr, buflen);\r\nBUG_ON(!iolen);\r\nreturn brcmf_exec_dcmd(ndev, BRCMF_C_GET_VAR, bufptr, buflen);\r\n}\r\nstatic s32\r\nbrcmf_run_iscan(struct brcmf_cfg80211_iscan_ctrl *iscan,\r\nstruct brcmf_ssid *ssid, u16 action)\r\n{\r\ns32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +\r\noffsetof(struct brcmf_iscan_params_le, params_le);\r\nstruct brcmf_iscan_params_le *params;\r\ns32 err = 0;\r\nif (ssid && ssid->SSID_len)\r\nparams_size += sizeof(struct brcmf_ssid);\r\nparams = kzalloc(params_size, GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\nBUG_ON(params_size >= BRCMF_DCMD_SMLEN);\r\nwl_iscan_prep(&params->params_le, ssid);\r\nparams->version = cpu_to_le32(BRCMF_ISCAN_REQ_VERSION);\r\nparams->action = cpu_to_le16(action);\r\nparams->scan_duration = cpu_to_le16(0);\r\nerr = brcmf_dev_iovar_setbuf(iscan->ndev, "iscan", params, params_size,\r\niscan->dcmd_buf, BRCMF_DCMD_SMLEN);\r\nif (err) {\r\nif (err == -EBUSY)\r\nWL_INFO("system busy : iscan canceled\n");\r\nelse\r\nWL_ERR("error (%d)\n", err);\r\n}\r\nkfree(params);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_do_iscan(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_to_iscan(cfg_priv);\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\nstruct brcmf_ssid ssid;\r\n__le32 passive_scan;\r\ns32 err = 0;\r\nmemset(&ssid, 0, sizeof(ssid));\r\niscan->state = WL_ISCAN_STATE_SCANING;\r\npassive_scan = cfg_priv->active_scan ? 0 : cpu_to_le32(1);\r\nerr = brcmf_exec_dcmd(cfg_to_ndev(cfg_priv), BRCMF_C_SET_PASSIVE_SCAN,\r\n&passive_scan, sizeof(passive_scan));\r\nif (err) {\r\nWL_ERR("error (%d)\n", err);\r\nreturn err;\r\n}\r\nbrcmf_set_mpc(ndev, 0);\r\ncfg_priv->iscan_kickstart = true;\r\nerr = brcmf_run_iscan(iscan, &ssid, BRCMF_SCAN_ACTION_START);\r\nif (err) {\r\nbrcmf_set_mpc(ndev, 1);\r\ncfg_priv->iscan_kickstart = false;\r\nreturn err;\r\n}\r\nmod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);\r\niscan->timer_on = 1;\r\nreturn err;\r\n}\r\nstatic s32\r\n__brcmf_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_scan_request *request,\r\nstruct cfg80211_ssid *this_ssid)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nstruct cfg80211_ssid *ssids;\r\nstruct brcmf_cfg80211_scan_req *sr = cfg_priv->scan_req_int;\r\n__le32 passive_scan;\r\nbool iscan_req;\r\nbool spec_scan;\r\ns32 err = 0;\r\nu32 SSID_len;\r\nif (test_bit(WL_STATUS_SCANNING, &cfg_priv->status)) {\r\nWL_ERR("Scanning already : status (%lu)\n", cfg_priv->status);\r\nreturn -EAGAIN;\r\n}\r\nif (test_bit(WL_STATUS_SCAN_ABORTING, &cfg_priv->status)) {\r\nWL_ERR("Scanning being aborted : status (%lu)\n",\r\ncfg_priv->status);\r\nreturn -EAGAIN;\r\n}\r\nif (test_bit(WL_STATUS_CONNECTING, &cfg_priv->status)) {\r\nWL_ERR("Connecting : status (%lu)\n",\r\ncfg_priv->status);\r\nreturn -EAGAIN;\r\n}\r\niscan_req = false;\r\nspec_scan = false;\r\nif (request) {\r\nssids = request->ssids;\r\nif (cfg_priv->iscan_on && (!ssids || !ssids->ssid_len))\r\niscan_req = true;\r\n} else {\r\nssids = this_ssid;\r\n}\r\ncfg_priv->scan_request = request;\r\nset_bit(WL_STATUS_SCANNING, &cfg_priv->status);\r\nif (iscan_req) {\r\nerr = brcmf_do_iscan(cfg_priv);\r\nif (!err)\r\nreturn err;\r\nelse\r\ngoto scan_out;\r\n} else {\r\nWL_SCAN("ssid \"%s\", ssid_len (%d)\n",\r\nssids->ssid, ssids->ssid_len);\r\nmemset(&sr->ssid_le, 0, sizeof(sr->ssid_le));\r\nSSID_len = min_t(u8, sizeof(sr->ssid_le.SSID), ssids->ssid_len);\r\nsr->ssid_le.SSID_len = cpu_to_le32(0);\r\nif (SSID_len) {\r\nmemcpy(sr->ssid_le.SSID, ssids->ssid, SSID_len);\r\nsr->ssid_le.SSID_len = cpu_to_le32(SSID_len);\r\nspec_scan = true;\r\n} else {\r\nWL_SCAN("Broadcast scan\n");\r\n}\r\npassive_scan = cfg_priv->active_scan ? 0 : cpu_to_le32(1);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_PASSIVE_SCAN,\r\n&passive_scan, sizeof(passive_scan));\r\nif (err) {\r\nWL_ERR("WLC_SET_PASSIVE_SCAN error (%d)\n", err);\r\ngoto scan_out;\r\n}\r\nbrcmf_set_mpc(ndev, 0);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SCAN, &sr->ssid_le,\r\nsizeof(sr->ssid_le));\r\nif (err) {\r\nif (err == -EBUSY)\r\nWL_INFO("system busy : scan for \"%s\" "\r\n"canceled\n", sr->ssid_le.SSID);\r\nelse\r\nWL_ERR("WLC_SCAN error (%d)\n", err);\r\nbrcmf_set_mpc(ndev, 1);\r\ngoto scan_out;\r\n}\r\n}\r\nreturn 0;\r\nscan_out:\r\nclear_bit(WL_STATUS_SCANNING, &cfg_priv->status);\r\ncfg_priv->scan_request = NULL;\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_scan_request *request)\r\n{\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nerr = __brcmf_cfg80211_scan(wiphy, ndev, request, NULL);\r\nif (err)\r\nWL_ERR("scan error (%d)\n", err);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)\r\n{\r\ns32 err = 0;\r\nerr = brcmf_dev_intvar_set(ndev, "rtsthresh", rts_threshold);\r\nif (err)\r\nWL_ERR("Error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)\r\n{\r\ns32 err = 0;\r\nerr = brcmf_dev_intvar_set(ndev, "fragthresh", frag_threshold);\r\nif (err)\r\nWL_ERR("Error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)\r\n{\r\ns32 err = 0;\r\nu32 cmd = (l ? BRCM_SET_LRL : BRCM_SET_SRL);\r\nerr = brcmf_exec_dcmd_u32(ndev, cmd, &retry);\r\nif (err) {\r\nWL_ERR("cmd (%d) , error (%d)\n", cmd, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic s32 brcmf_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nif (changed & WIPHY_PARAM_RTS_THRESHOLD &&\r\n(cfg_priv->conf->rts_threshold != wiphy->rts_threshold)) {\r\ncfg_priv->conf->rts_threshold = wiphy->rts_threshold;\r\nerr = brcmf_set_rts(ndev, cfg_priv->conf->rts_threshold);\r\nif (!err)\r\ngoto done;\r\n}\r\nif (changed & WIPHY_PARAM_FRAG_THRESHOLD &&\r\n(cfg_priv->conf->frag_threshold != wiphy->frag_threshold)) {\r\ncfg_priv->conf->frag_threshold = wiphy->frag_threshold;\r\nerr = brcmf_set_frag(ndev, cfg_priv->conf->frag_threshold);\r\nif (!err)\r\ngoto done;\r\n}\r\nif (changed & WIPHY_PARAM_RETRY_LONG\r\n&& (cfg_priv->conf->retry_long != wiphy->retry_long)) {\r\ncfg_priv->conf->retry_long = wiphy->retry_long;\r\nerr = brcmf_set_retry(ndev, cfg_priv->conf->retry_long, true);\r\nif (!err)\r\ngoto done;\r\n}\r\nif (changed & WIPHY_PARAM_RETRY_SHORT\r\n&& (cfg_priv->conf->retry_short != wiphy->retry_short)) {\r\ncfg_priv->conf->retry_short = wiphy->retry_short;\r\nerr = brcmf_set_retry(ndev, cfg_priv->conf->retry_short, false);\r\nif (!err)\r\ngoto done;\r\n}\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic void *brcmf_read_prof(struct brcmf_cfg80211_priv *cfg_priv, s32 item)\r\n{\r\nswitch (item) {\r\ncase WL_PROF_SEC:\r\nreturn &cfg_priv->profile->sec;\r\ncase WL_PROF_BSSID:\r\nreturn &cfg_priv->profile->bssid;\r\ncase WL_PROF_SSID:\r\nreturn &cfg_priv->profile->ssid;\r\n}\r\nWL_ERR("invalid item (%d)\n", item);\r\nreturn NULL;\r\n}\r\nstatic s32\r\nbrcmf_update_prof(struct brcmf_cfg80211_priv *cfg_priv,\r\nconst struct brcmf_event_msg *e, void *data, s32 item)\r\n{\r\ns32 err = 0;\r\nstruct brcmf_ssid *ssid;\r\nswitch (item) {\r\ncase WL_PROF_SSID:\r\nssid = (struct brcmf_ssid *) data;\r\nmemset(cfg_priv->profile->ssid.SSID, 0,\r\nsizeof(cfg_priv->profile->ssid.SSID));\r\nmemcpy(cfg_priv->profile->ssid.SSID,\r\nssid->SSID, ssid->SSID_len);\r\ncfg_priv->profile->ssid.SSID_len = ssid->SSID_len;\r\nbreak;\r\ncase WL_PROF_BSSID:\r\nif (data)\r\nmemcpy(cfg_priv->profile->bssid, data, ETH_ALEN);\r\nelse\r\nmemset(cfg_priv->profile->bssid, 0, ETH_ALEN);\r\nbreak;\r\ncase WL_PROF_SEC:\r\nmemcpy(&cfg_priv->profile->sec, data,\r\nsizeof(cfg_priv->profile->sec));\r\nbreak;\r\ncase WL_PROF_BEACONINT:\r\ncfg_priv->profile->beacon_interval = *(u16 *)data;\r\nbreak;\r\ncase WL_PROF_DTIMPERIOD:\r\ncfg_priv->profile->dtim_period = *(u8 *)data;\r\nbreak;\r\ndefault:\r\nWL_ERR("unsupported item (%d)\n", item);\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void brcmf_init_prof(struct brcmf_cfg80211_profile *prof)\r\n{\r\nmemset(prof, 0, sizeof(*prof));\r\n}\r\nstatic void brcmf_ch_to_chanspec(int ch, struct brcmf_join_params *join_params,\r\nsize_t *join_params_size)\r\n{\r\nu16 chanspec = 0;\r\nif (ch != 0) {\r\nif (ch <= CH_MAX_2G_CHANNEL)\r\nchanspec |= WL_CHANSPEC_BAND_2G;\r\nelse\r\nchanspec |= WL_CHANSPEC_BAND_5G;\r\nchanspec |= WL_CHANSPEC_BW_20;\r\nchanspec |= WL_CHANSPEC_CTL_SB_NONE;\r\n*join_params_size += BRCMF_ASSOC_PARAMS_FIXED_SIZE +\r\nsizeof(u16);\r\nchanspec |= (ch & WL_CHANSPEC_CHAN_MASK);\r\njoin_params->params_le.chanspec_list[0] = cpu_to_le16(chanspec);\r\njoin_params->params_le.chanspec_num = cpu_to_le32(1);\r\nWL_CONN("join_params->params.chanspec_list[0]= %#X,"\r\n"channel %d, chanspec %#X\n",\r\nchanspec, ch, chanspec);\r\n}\r\n}\r\nstatic void brcmf_link_down(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct net_device *ndev = NULL;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (cfg_priv->link_up) {\r\nndev = cfg_to_ndev(cfg_priv);\r\nWL_INFO("Call WLC_DISASSOC to stop excess roaming\n ");\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_DISASSOC, NULL, 0);\r\nif (err)\r\nWL_ERR("WLC_DISASSOC failed (%d)\n", err);\r\ncfg_priv->link_up = false;\r\n}\r\nWL_TRACE("Exit\n");\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ibss_params *params)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct brcmf_join_params join_params;\r\nsize_t join_params_size = 0;\r\ns32 err = 0;\r\ns32 wsec = 0;\r\ns32 bcnprd;\r\nstruct brcmf_ssid ssid;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nif (params->ssid)\r\nWL_CONN("SSID: %s\n", params->ssid);\r\nelse {\r\nWL_CONN("SSID: NULL, Not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nset_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nif (params->bssid)\r\nWL_CONN("BSSID: %02X %02X %02X %02X %02X %02X\n",\r\nparams->bssid[0], params->bssid[1], params->bssid[2],\r\nparams->bssid[3], params->bssid[4], params->bssid[5]);\r\nelse\r\nWL_CONN("No BSSID specified\n");\r\nif (params->channel)\r\nWL_CONN("channel: %d\n", params->channel->center_freq);\r\nelse\r\nWL_CONN("no channel specified\n");\r\nif (params->channel_fixed)\r\nWL_CONN("fixed channel required\n");\r\nelse\r\nWL_CONN("no fixed channel required\n");\r\nif (params->ie && params->ie_len)\r\nWL_CONN("ie len: %d\n", params->ie_len);\r\nelse\r\nWL_CONN("no ie specified\n");\r\nif (params->beacon_interval)\r\nWL_CONN("beacon interval: %d\n", params->beacon_interval);\r\nelse\r\nWL_CONN("no beacon interval specified\n");\r\nif (params->basic_rates)\r\nWL_CONN("basic rates: %08X\n", params->basic_rates);\r\nelse\r\nWL_CONN("no basic rates specified\n");\r\nif (params->privacy)\r\nWL_CONN("privacy required\n");\r\nelse\r\nWL_CONN("no privacy required\n");\r\nif (params->privacy)\r\nwsec |= WEP_ENABLED;\r\nerr = brcmf_dev_intvar_set(ndev, "wsec", wsec);\r\nif (err) {\r\nWL_ERR("wsec failed (%d)\n", err);\r\ngoto done;\r\n}\r\nif (params->beacon_interval)\r\nbcnprd = params->beacon_interval;\r\nelse\r\nbcnprd = 100;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCM_SET_BCNPRD, &bcnprd);\r\nif (err) {\r\nWL_ERR("WLC_SET_BCNPRD failed (%d)\n", err);\r\ngoto done;\r\n}\r\nmemset(&join_params, 0, sizeof(struct brcmf_join_params));\r\nssid.SSID_len = min_t(u32, params->ssid_len, 32);\r\nmemcpy(ssid.SSID, params->ssid, ssid.SSID_len);\r\nmemcpy(join_params.ssid_le.SSID, params->ssid, ssid.SSID_len);\r\njoin_params.ssid_le.SSID_len = cpu_to_le32(ssid.SSID_len);\r\njoin_params_size = sizeof(join_params.ssid_le);\r\nbrcmf_update_prof(cfg_priv, NULL, &ssid, WL_PROF_SSID);\r\nif (params->bssid) {\r\nmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\r\njoin_params_size = sizeof(join_params.ssid_le) +\r\nBRCMF_ASSOC_PARAMS_FIXED_SIZE;\r\n} else {\r\nmemcpy(join_params.params_le.bssid, ether_bcast, ETH_ALEN);\r\n}\r\nbrcmf_update_prof(cfg_priv, NULL,\r\n&join_params.params_le.bssid, WL_PROF_BSSID);\r\nif (params->channel) {\r\nu32 target_channel;\r\ncfg_priv->channel =\r\nieee80211_frequency_to_channel(\r\nparams->channel->center_freq);\r\nif (params->channel_fixed) {\r\nbrcmf_ch_to_chanspec(cfg_priv->channel,\r\n&join_params, &join_params_size);\r\n}\r\ntarget_channel = cfg_priv->channel;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCM_SET_CHANNEL,\r\n&target_channel);\r\nif (err) {\r\nWL_ERR("WLC_SET_CHANNEL failed (%d)\n", err);\r\ngoto done;\r\n}\r\n} else\r\ncfg_priv->channel = 0;\r\ncfg_priv->ibss_starter = false;\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_SSID,\r\n&join_params, join_params_size);\r\nif (err) {\r\nWL_ERR("WLC_SET_SSID failed (%d)\n", err);\r\ngoto done;\r\n}\r\ndone:\r\nif (err)\r\nclear_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nbrcmf_link_down(cfg_priv);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_wpa_version(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 val = 0;\r\ns32 err = 0;\r\nif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)\r\nval = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;\r\nelse if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)\r\nval = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;\r\nelse\r\nval = WPA_AUTH_DISABLED;\r\nWL_CONN("setting wpa_auth to 0x%0x\n", val);\r\nerr = brcmf_dev_intvar_set(ndev, "wpa_auth", val);\r\nif (err) {\r\nWL_ERR("set wpa_auth failed (%d)\n", err);\r\nreturn err;\r\n}\r\nsec = brcmf_read_prof(cfg_priv, WL_PROF_SEC);\r\nsec->wpa_versions = sme->crypto.wpa_versions;\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_auth_type(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 val = 0;\r\ns32 err = 0;\r\nswitch (sme->auth_type) {\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\nval = 0;\r\nWL_CONN("open system\n");\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\nval = 1;\r\nWL_CONN("shared key\n");\r\nbreak;\r\ncase NL80211_AUTHTYPE_AUTOMATIC:\r\nval = 2;\r\nWL_CONN("automatic\n");\r\nbreak;\r\ncase NL80211_AUTHTYPE_NETWORK_EAP:\r\nWL_CONN("network eap\n");\r\ndefault:\r\nval = 2;\r\nWL_ERR("invalid auth type (%d)\n", sme->auth_type);\r\nbreak;\r\n}\r\nerr = brcmf_dev_intvar_set(ndev, "auth", val);\r\nif (err) {\r\nWL_ERR("set auth failed (%d)\n", err);\r\nreturn err;\r\n}\r\nsec = brcmf_read_prof(cfg_priv, WL_PROF_SEC);\r\nsec->auth_type = sme->auth_type;\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_set_set_cipher(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 pval = 0;\r\ns32 gval = 0;\r\ns32 err = 0;\r\nif (sme->crypto.n_ciphers_pairwise) {\r\nswitch (sme->crypto.ciphers_pairwise[0]) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\npval = WEP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\npval = TKIP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\npval = AES_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\npval = AES_ENABLED;\r\nbreak;\r\ndefault:\r\nWL_ERR("invalid cipher pairwise (%d)\n",\r\nsme->crypto.ciphers_pairwise[0]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sme->crypto.cipher_group) {\r\nswitch (sme->crypto.cipher_group) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ngval = WEP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ngval = TKIP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ngval = AES_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\ngval = AES_ENABLED;\r\nbreak;\r\ndefault:\r\nWL_ERR("invalid cipher group (%d)\n",\r\nsme->crypto.cipher_group);\r\nreturn -EINVAL;\r\n}\r\n}\r\nWL_CONN("pval (%d) gval (%d)\n", pval, gval);\r\nerr = brcmf_dev_intvar_set(ndev, "wsec", pval | gval);\r\nif (err) {\r\nWL_ERR("error (%d)\n", err);\r\nreturn err;\r\n}\r\nsec = brcmf_read_prof(cfg_priv, WL_PROF_SEC);\r\nsec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];\r\nsec->cipher_group = sme->crypto.cipher_group;\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 val = 0;\r\ns32 err = 0;\r\nif (sme->crypto.n_akm_suites) {\r\nerr = brcmf_dev_intvar_get(ndev, "wpa_auth", &val);\r\nif (err) {\r\nWL_ERR("could not get wpa_auth (%d)\n", err);\r\nreturn err;\r\n}\r\nif (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {\r\nswitch (sme->crypto.akm_suites[0]) {\r\ncase WLAN_AKM_SUITE_8021X:\r\nval = WPA_AUTH_UNSPECIFIED;\r\nbreak;\r\ncase WLAN_AKM_SUITE_PSK:\r\nval = WPA_AUTH_PSK;\r\nbreak;\r\ndefault:\r\nWL_ERR("invalid cipher group (%d)\n",\r\nsme->crypto.cipher_group);\r\nreturn -EINVAL;\r\n}\r\n} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {\r\nswitch (sme->crypto.akm_suites[0]) {\r\ncase WLAN_AKM_SUITE_8021X:\r\nval = WPA2_AUTH_UNSPECIFIED;\r\nbreak;\r\ncase WLAN_AKM_SUITE_PSK:\r\nval = WPA2_AUTH_PSK;\r\nbreak;\r\ndefault:\r\nWL_ERR("invalid cipher group (%d)\n",\r\nsme->crypto.cipher_group);\r\nreturn -EINVAL;\r\n}\r\n}\r\nWL_CONN("setting wpa_auth to %d\n", val);\r\nerr = brcmf_dev_intvar_set(ndev, "wpa_auth", val);\r\nif (err) {\r\nWL_ERR("could not set wpa_auth (%d)\n", err);\r\nreturn err;\r\n}\r\n}\r\nsec = brcmf_read_prof(cfg_priv, WL_PROF_SEC);\r\nsec->wpa_auth = sme->crypto.akm_suites[0];\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_set_wep_sharedkey(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\nstruct brcmf_wsec_key key;\r\ns32 val;\r\ns32 err = 0;\r\nWL_CONN("key len (%d)\n", sme->key_len);\r\nif (sme->key_len == 0)\r\nreturn 0;\r\nsec = brcmf_read_prof(cfg_priv, WL_PROF_SEC);\r\nWL_CONN("wpa_versions 0x%x cipher_pairwise 0x%x\n",\r\nsec->wpa_versions, sec->cipher_pairwise);\r\nif (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\r\nreturn 0;\r\nif (sec->cipher_pairwise &\r\n(WLAN_CIPHER_SUITE_WEP40 | WLAN_CIPHER_SUITE_WEP104)) {\r\nmemset(&key, 0, sizeof(key));\r\nkey.len = (u32) sme->key_len;\r\nkey.index = (u32) sme->key_idx;\r\nif (key.len > sizeof(key.data)) {\r\nWL_ERR("Too long key length (%u)\n", key.len);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(key.data, sme->key, key.len);\r\nkey.flags = BRCMF_PRIMARY_KEY;\r\nswitch (sec->cipher_pairwise) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nkey.algo = CRYPTO_ALGO_WEP1;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey.algo = CRYPTO_ALGO_WEP128;\r\nbreak;\r\ndefault:\r\nWL_ERR("Invalid algorithm (%d)\n",\r\nsme->crypto.ciphers_pairwise[0]);\r\nreturn -EINVAL;\r\n}\r\nWL_CONN("key length (%d) key index (%d) algo (%d)\n",\r\nkey.len, key.index, key.algo);\r\nWL_CONN("key \"%s\"\n", key.data);\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\nreturn err;\r\nif (sec->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {\r\nWL_CONN("set auth_type to shared key\n");\r\nval = 1;\r\nerr = brcmf_dev_intvar_set(ndev, "auth", val);\r\nif (err) {\r\nWL_ERR("set auth failed (%d)\n", err);\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct ieee80211_channel *chan = sme->channel;\r\nstruct brcmf_join_params join_params;\r\nsize_t join_params_size;\r\nstruct brcmf_ssid ssid;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nif (!sme->ssid) {\r\nWL_ERR("Invalid ssid\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nset_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nif (chan) {\r\ncfg_priv->channel =\r\nieee80211_frequency_to_channel(chan->center_freq);\r\nWL_CONN("channel (%d), center_req (%d)\n",\r\ncfg_priv->channel, chan->center_freq);\r\n} else\r\ncfg_priv->channel = 0;\r\nWL_INFO("ie (%p), ie_len (%zd)\n", sme->ie, sme->ie_len);\r\nerr = brcmf_set_wpa_version(ndev, sme);\r\nif (err) {\r\nWL_ERR("wl_set_wpa_version failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_auth_type(ndev, sme);\r\nif (err) {\r\nWL_ERR("wl_set_auth_type failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_set_cipher(ndev, sme);\r\nif (err) {\r\nWL_ERR("wl_set_set_cipher failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_key_mgmt(ndev, sme);\r\nif (err) {\r\nWL_ERR("wl_set_key_mgmt failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_wep_sharedkey(ndev, sme);\r\nif (err) {\r\nWL_ERR("brcmf_set_wep_sharedkey failed (%d)\n", err);\r\ngoto done;\r\n}\r\nmemset(&join_params, 0, sizeof(join_params));\r\njoin_params_size = sizeof(join_params.ssid_le);\r\nssid.SSID_len = min_t(u32, sizeof(ssid.SSID), (u32)sme->ssid_len);\r\nmemcpy(&join_params.ssid_le.SSID, sme->ssid, ssid.SSID_len);\r\nmemcpy(&ssid.SSID, sme->ssid, ssid.SSID_len);\r\njoin_params.ssid_le.SSID_len = cpu_to_le32(ssid.SSID_len);\r\nbrcmf_update_prof(cfg_priv, NULL, &ssid, WL_PROF_SSID);\r\nmemcpy(join_params.params_le.bssid, ether_bcast, ETH_ALEN);\r\nif (ssid.SSID_len < IEEE80211_MAX_SSID_LEN)\r\nWL_CONN("ssid \"%s\", len (%d)\n",\r\nssid.SSID, ssid.SSID_len);\r\nbrcmf_ch_to_chanspec(cfg_priv->channel,\r\n&join_params, &join_params_size);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_SSID,\r\n&join_params, join_params_size);\r\nif (err)\r\nWL_ERR("WLC_SET_SSID failed (%d)\n", err);\r\ndone:\r\nif (err)\r\nclear_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,\r\nu16 reason_code)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct brcmf_scb_val_le scbval;\r\ns32 err = 0;\r\nWL_TRACE("Enter. Reason code = %d\n", reason_code);\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nclear_bit(WL_STATUS_CONNECTED, &cfg_priv->status);\r\nmemcpy(&scbval.ea, brcmf_read_prof(cfg_priv, WL_PROF_BSSID), ETH_ALEN);\r\nscbval.val = cpu_to_le32(reason_code);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_DISASSOC, &scbval,\r\nsizeof(struct brcmf_scb_val_le));\r\nif (err)\r\nWL_ERR("error (%d)\n", err);\r\ncfg_priv->link_up = false;\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_tx_power(struct wiphy *wiphy,\r\nenum nl80211_tx_power_setting type, s32 mbm)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\nu16 txpwrmw;\r\ns32 err = 0;\r\ns32 disable = 0;\r\ns32 dbm = MBM_TO_DBM(mbm);\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nswitch (type) {\r\ncase NL80211_TX_POWER_AUTOMATIC:\r\nbreak;\r\ncase NL80211_TX_POWER_LIMITED:\r\ncase NL80211_TX_POWER_FIXED:\r\nif (dbm < 0) {\r\nWL_ERR("TX_POWER_FIXED - dbm is negative\n");\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\n}\r\ndisable = WL_RADIO_SW_DISABLE << 16;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_RADIO, &disable);\r\nif (err)\r\nWL_ERR("WLC_SET_RADIO error (%d)\n", err);\r\nif (dbm > 0xffff)\r\ntxpwrmw = 0xffff;\r\nelse\r\ntxpwrmw = (u16) dbm;\r\nerr = brcmf_dev_intvar_set(ndev, "qtxpower",\r\n(s32) (brcmf_mw_to_qdbm(txpwrmw)));\r\nif (err)\r\nWL_ERR("qtxpower error (%d)\n", err);\r\ncfg_priv->conf->tx_power = dbm;\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_cfg80211_get_tx_power(struct wiphy *wiphy, s32 *dbm)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\ns32 txpwrdbm;\r\nu8 result;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nerr = brcmf_dev_intvar_get(ndev, "qtxpower", &txpwrdbm);\r\nif (err) {\r\nWL_ERR("error (%d)\n", err);\r\ngoto done;\r\n}\r\nresult = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);\r\n*dbm = (s32) brcmf_qdbm_to_mw(result);\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool unicast, bool multicast)\r\n{\r\nu32 index;\r\nu32 wsec;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nWL_CONN("key index (%d)\n", key_idx);\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_GET_WSEC, &wsec);\r\nif (err) {\r\nWL_ERR("WLC_GET_WSEC error (%d)\n", err);\r\ngoto done;\r\n}\r\nif (wsec & WEP_ENABLED) {\r\nindex = key_idx;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_KEY_PRIMARY,\r\n&index);\r\nif (err)\r\nWL_ERR("error (%d)\n", err);\r\n}\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_add_keyext(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, const u8 *mac_addr, struct key_params *params)\r\n{\r\nstruct brcmf_wsec_key key;\r\nstruct brcmf_wsec_key_le key_le;\r\ns32 err = 0;\r\nmemset(&key, 0, sizeof(key));\r\nkey.index = (u32) key_idx;\r\nif (!is_multicast_ether_addr(mac_addr))\r\nmemcpy((char *)&key.ea, (void *)mac_addr, ETH_ALEN);\r\nkey.len = (u32) params->key_len;\r\nif (key.len == 0) {\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\nreturn err;\r\n} else {\r\nif (key.len > sizeof(key.data)) {\r\nWL_ERR("Invalid key length (%d)\n", key.len);\r\nreturn -EINVAL;\r\n}\r\nWL_CONN("Setting the key index %d\n", key.index);\r\nmemcpy(key.data, params->key, key.len);\r\nif (params->cipher == WLAN_CIPHER_SUITE_TKIP) {\r\nu8 keybuf[8];\r\nmemcpy(keybuf, &key.data[24], sizeof(keybuf));\r\nmemcpy(&key.data[24], &key.data[16], sizeof(keybuf));\r\nmemcpy(&key.data[16], keybuf, sizeof(keybuf));\r\n}\r\nif (params->seq && params->seq_len == 6) {\r\nu8 *ivptr;\r\nivptr = (u8 *) params->seq;\r\nkey.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |\r\n(ivptr[3] << 8) | ivptr[2];\r\nkey.rxiv.lo = (ivptr[1] << 8) | ivptr[0];\r\nkey.iv_initialized = true;\r\n}\r\nswitch (params->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nkey.algo = CRYPTO_ALGO_WEP1;\r\nWL_CONN("WLAN_CIPHER_SUITE_WEP40\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey.algo = CRYPTO_ALGO_WEP128;\r\nWL_CONN("WLAN_CIPHER_SUITE_WEP104\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nkey.algo = CRYPTO_ALGO_TKIP;\r\nWL_CONN("WLAN_CIPHER_SUITE_TKIP\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nWL_CONN("WLAN_CIPHER_SUITE_AES_CMAC\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nWL_CONN("WLAN_CIPHER_SUITE_CCMP\n");\r\nbreak;\r\ndefault:\r\nWL_ERR("Invalid cipher (0x%x)\n", params->cipher);\r\nreturn -EINVAL;\r\n}\r\nconvert_key_from_CPU(&key, &key_le);\r\nbrcmf_netdev_wait_pend8021x(ndev);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_KEY, &key_le,\r\nsizeof(key_le));\r\nif (err) {\r\nWL_ERR("WLC_SET_KEY error (%d)\n", err);\r\nreturn err;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool pairwise, const u8 *mac_addr,\r\nstruct key_params *params)\r\n{\r\nstruct brcmf_wsec_key key;\r\ns32 val;\r\ns32 wsec;\r\ns32 err = 0;\r\nu8 keybuf[8];\r\nWL_TRACE("Enter\n");\r\nWL_CONN("key index (%d)\n", key_idx);\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nif (mac_addr) {\r\nWL_TRACE("Exit");\r\nreturn brcmf_add_keyext(wiphy, ndev, key_idx, mac_addr, params);\r\n}\r\nmemset(&key, 0, sizeof(key));\r\nkey.len = (u32) params->key_len;\r\nkey.index = (u32) key_idx;\r\nif (key.len > sizeof(key.data)) {\r\nWL_ERR("Too long key length (%u)\n", key.len);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nmemcpy(key.data, params->key, key.len);\r\nkey.flags = BRCMF_PRIMARY_KEY;\r\nswitch (params->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nkey.algo = CRYPTO_ALGO_WEP1;\r\nWL_CONN("WLAN_CIPHER_SUITE_WEP40\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey.algo = CRYPTO_ALGO_WEP128;\r\nWL_CONN("WLAN_CIPHER_SUITE_WEP104\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nmemcpy(keybuf, &key.data[24], sizeof(keybuf));\r\nmemcpy(&key.data[24], &key.data[16], sizeof(keybuf));\r\nmemcpy(&key.data[16], keybuf, sizeof(keybuf));\r\nkey.algo = CRYPTO_ALGO_TKIP;\r\nWL_CONN("WLAN_CIPHER_SUITE_TKIP\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nWL_CONN("WLAN_CIPHER_SUITE_AES_CMAC\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nWL_CONN("WLAN_CIPHER_SUITE_CCMP\n");\r\nbreak;\r\ndefault:\r\nWL_ERR("Invalid cipher (0x%x)\n", params->cipher);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\ngoto done;\r\nval = WEP_ENABLED;\r\nerr = brcmf_dev_intvar_get(ndev, "wsec", &wsec);\r\nif (err) {\r\nWL_ERR("get wsec error (%d)\n", err);\r\ngoto done;\r\n}\r\nwsec &= ~(WEP_ENABLED);\r\nwsec |= val;\r\nerr = brcmf_dev_intvar_set(ndev, "wsec", wsec);\r\nif (err) {\r\nWL_ERR("set wsec error (%d)\n", err);\r\ngoto done;\r\n}\r\nval = 1;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_AUTH, &val);\r\nif (err)\r\nWL_ERR("WLC_SET_AUTH error (%d)\n", err);\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool pairwise, const u8 *mac_addr)\r\n{\r\nstruct brcmf_wsec_key key;\r\ns32 err = 0;\r\ns32 val;\r\ns32 wsec;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nmemset(&key, 0, sizeof(key));\r\nkey.index = (u32) key_idx;\r\nkey.flags = BRCMF_PRIMARY_KEY;\r\nkey.algo = CRYPTO_ALGO_OFF;\r\nWL_CONN("key index (%d)\n", key_idx);\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err) {\r\nif (err == -EINVAL) {\r\nif (key.index >= DOT11_MAX_DEFAULT_KEYS)\r\nWL_ERR("invalid key index (%d)\n", key_idx);\r\n}\r\nerr = -EAGAIN;\r\ngoto done;\r\n}\r\nval = 0;\r\nerr = brcmf_dev_intvar_get(ndev, "wsec", &wsec);\r\nif (err) {\r\nWL_ERR("get wsec error (%d)\n", err);\r\nerr = -EAGAIN;\r\ngoto done;\r\n}\r\nwsec &= ~(WEP_ENABLED);\r\nwsec |= val;\r\nerr = brcmf_dev_intvar_set(ndev, "wsec", wsec);\r\nif (err) {\r\nWL_ERR("set wsec error (%d)\n", err);\r\nerr = -EAGAIN;\r\ngoto done;\r\n}\r\nval = 0;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_AUTH, &val);\r\nif (err) {\r\nWL_ERR("WLC_SET_AUTH error (%d)\n", err);\r\nerr = -EAGAIN;\r\n}\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool pairwise, const u8 *mac_addr, void *cookie,\r\nvoid (*callback) (void *cookie, struct key_params * params))\r\n{\r\nstruct key_params params;\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 wsec;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nWL_CONN("key index (%d)\n", key_idx);\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nmemset(&params, 0, sizeof(params));\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_GET_WSEC, &wsec);\r\nif (err) {\r\nWL_ERR("WLC_GET_WSEC error (%d)\n", err);\r\nerr = -EAGAIN;\r\ngoto done;\r\n}\r\nswitch (wsec) {\r\ncase WEP_ENABLED:\r\nsec = brcmf_read_prof(cfg_priv, WL_PROF_SEC);\r\nif (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP40;\r\nWL_CONN("WLAN_CIPHER_SUITE_WEP40\n");\r\n} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP104;\r\nWL_CONN("WLAN_CIPHER_SUITE_WEP104\n");\r\n}\r\nbreak;\r\ncase TKIP_ENABLED:\r\nparams.cipher = WLAN_CIPHER_SUITE_TKIP;\r\nWL_CONN("WLAN_CIPHER_SUITE_TKIP\n");\r\nbreak;\r\ncase AES_ENABLED:\r\nparams.cipher = WLAN_CIPHER_SUITE_AES_CMAC;\r\nWL_CONN("WLAN_CIPHER_SUITE_AES_CMAC\n");\r\nbreak;\r\ndefault:\r\nWL_ERR("Invalid algo (0x%x)\n", wsec);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\ncallback(cookie, &params);\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,\r\nstruct net_device *ndev, u8 key_idx)\r\n{\r\nWL_INFO("Not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 *mac, struct station_info *sinfo)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct brcmf_scb_val_le scb_val;\r\nint rssi;\r\ns32 rate;\r\ns32 err = 0;\r\nu8 *bssid = brcmf_read_prof(cfg_priv, WL_PROF_BSSID);\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nif (memcmp(mac, bssid, ETH_ALEN)) {\r\nWL_ERR("Wrong Mac address cfg_mac-%X:%X:%X:%X:%X:%X"\r\n"wl_bssid-%X:%X:%X:%X:%X:%X\n",\r\nmac[0], mac[1], mac[2], mac[3], mac[4], mac[5],\r\nbssid[0], bssid[1], bssid[2], bssid[3],\r\nbssid[4], bssid[5]);\r\nerr = -ENOENT;\r\ngoto done;\r\n}\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_GET_RATE, &rate);\r\nif (err) {\r\nWL_ERR("Could not get rate (%d)\n", err);\r\n} else {\r\nsinfo->filled |= STATION_INFO_TX_BITRATE;\r\nsinfo->txrate.legacy = rate * 5;\r\nWL_CONN("Rate %d Mbps\n", rate / 2);\r\n}\r\nif (test_bit(WL_STATUS_CONNECTED, &cfg_priv->status)) {\r\nscb_val.val = cpu_to_le32(0);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_GET_RSSI, &scb_val,\r\nsizeof(struct brcmf_scb_val_le));\r\nif (err)\r\nWL_ERR("Could not get rssi (%d)\n", err);\r\nrssi = le32_to_cpu(scb_val.val);\r\nsinfo->filled |= STATION_INFO_SIGNAL;\r\nsinfo->signal = rssi;\r\nWL_CONN("RSSI %d dBm\n", rssi);\r\n}\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,\r\nbool enabled, s32 timeout)\r\n{\r\ns32 pm;\r\ns32 err = 0;\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nWL_TRACE("Enter\n");\r\ncfg_priv->pwr_save = enabled;\r\nif (!test_bit(WL_STATUS_READY, &cfg_priv->status)) {\r\nWL_INFO("Device is not ready,"\r\n"storing the value in cfg_priv struct\n");\r\ngoto done;\r\n}\r\npm = enabled ? PM_FAST : PM_OFF;\r\nWL_INFO("power save %s\n", (pm ? "enabled" : "disabled"));\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_PM, &pm);\r\nif (err) {\r\nif (err == -ENODEV)\r\nWL_ERR("net_device is not ready yet\n");\r\nelse\r\nWL_ERR("error (%d)\n", err);\r\n}\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_bitrate_mask(struct wiphy *wiphy, struct net_device *ndev,\r\nconst u8 *addr,\r\nconst struct cfg80211_bitrate_mask *mask)\r\n{\r\nstruct brcm_rateset_le rateset_le;\r\ns32 rate;\r\ns32 val;\r\ns32 err_bg;\r\ns32 err_a;\r\nu32 legacy;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nerr = brcmf_exec_dcmd(ndev, BRCM_GET_CURR_RATESET, &rateset_le,\r\nsizeof(rateset_le));\r\nif (err) {\r\nWL_ERR("could not get current rateset (%d)\n", err);\r\ngoto done;\r\n}\r\nlegacy = ffs(mask->control[IEEE80211_BAND_2GHZ].legacy & 0xFFFF);\r\nif (!legacy)\r\nlegacy = ffs(mask->control[IEEE80211_BAND_5GHZ].legacy &\r\n0xFFFF);\r\nval = wl_g_rates[legacy - 1].bitrate * 100000;\r\nif (val < le32_to_cpu(rateset_le.count))\r\nrate = rateset_le.rates[val] & 0x7f;\r\nelse\r\nrate = val / 500000;\r\nWL_CONN("rate %d mbps\n", rate / 2);\r\nerr_bg = brcmf_dev_intvar_set(ndev, "bg_rate", rate);\r\nerr_a = brcmf_dev_intvar_set(ndev, "a_rate", rate);\r\nif (err_bg && err_a) {\r\nWL_ERR("could not set fixed rate (%d) (%d)\n", err_bg, err_a);\r\nerr = err_bg | err_a;\r\n}\r\ndone:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_inform_single_bss(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct brcmf_bss_info_le *bi)\r\n{\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg_priv);\r\nstruct ieee80211_channel *notify_channel;\r\nstruct cfg80211_bss *bss;\r\nstruct ieee80211_supported_band *band;\r\ns32 err = 0;\r\nu16 channel;\r\nu32 freq;\r\nu16 notify_capability;\r\nu16 notify_interval;\r\nu8 *notify_ie;\r\nsize_t notify_ielen;\r\ns32 notify_signal;\r\nif (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {\r\nWL_ERR("Bss info is larger than buffer. Discarding\n");\r\nreturn 0;\r\n}\r\nchannel = bi->ctl_ch ? bi->ctl_ch :\r\nCHSPEC_CHANNEL(le16_to_cpu(bi->chanspec));\r\nif (channel <= CH_MAX_2G_CHANNEL)\r\nband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfreq = ieee80211_channel_to_frequency(channel, band->band);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nnotify_capability = le16_to_cpu(bi->capability);\r\nnotify_interval = le16_to_cpu(bi->beacon_period);\r\nnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\r\nnotify_ielen = le32_to_cpu(bi->ie_length);\r\nnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\r\nWL_CONN("bssid: %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",\r\nbi->BSSID[0], bi->BSSID[1], bi->BSSID[2],\r\nbi->BSSID[3], bi->BSSID[4], bi->BSSID[5]);\r\nWL_CONN("Channel: %d(%d)\n", channel, freq);\r\nWL_CONN("Capability: %X\n", notify_capability);\r\nWL_CONN("Beacon interval: %d\n", notify_interval);\r\nWL_CONN("Signal: %d\n", notify_signal);\r\nbss = cfg80211_inform_bss(wiphy, notify_channel, (const u8 *)bi->BSSID,\r\n0, notify_capability, notify_interval, notify_ie,\r\nnotify_ielen, notify_signal, GFP_KERNEL);\r\nif (!bss)\r\nreturn -ENOMEM;\r\ncfg80211_put_bss(bss);\r\nreturn err;\r\n}\r\nstatic struct brcmf_bss_info_le *\r\nnext_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\r\n{\r\nif (bss == NULL)\r\nreturn list->bss_info_le;\r\nreturn (struct brcmf_bss_info_le *)((unsigned long)bss +\r\nle32_to_cpu(bss->length));\r\n}\r\nstatic s32 brcmf_inform_bss(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_scan_results *bss_list;\r\nstruct brcmf_bss_info_le *bi = NULL;\r\ns32 err = 0;\r\nint i;\r\nbss_list = cfg_priv->bss_list;\r\nif (bss_list->version != BRCMF_BSS_INFO_VERSION) {\r\nWL_ERR("Version %d != WL_BSS_INFO_VERSION\n",\r\nbss_list->version);\r\nreturn -EOPNOTSUPP;\r\n}\r\nWL_SCAN("scanned AP count (%d)\n", bss_list->count);\r\nfor (i = 0; i < bss_list->count && i < WL_AP_MAX; i++) {\r\nbi = next_bss_le(bss_list, bi);\r\nerr = brcmf_inform_single_bss(cfg_priv, bi);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic s32 wl_inform_ibss(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev, const u8 *bssid)\r\n{\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg_priv);\r\nstruct ieee80211_channel *notify_channel;\r\nstruct brcmf_bss_info_le *bi = NULL;\r\nstruct ieee80211_supported_band *band;\r\nstruct cfg80211_bss *bss;\r\nu8 *buf = NULL;\r\ns32 err = 0;\r\nu16 channel;\r\nu32 freq;\r\nu16 notify_capability;\r\nu16 notify_interval;\r\nu8 *notify_ie;\r\nsize_t notify_ielen;\r\ns32 notify_signal;\r\nWL_TRACE("Enter\n");\r\nbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\r\nif (buf == NULL) {\r\nerr = -ENOMEM;\r\ngoto CleanUp;\r\n}\r\n*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_GET_BSS_INFO, buf, WL_BSS_INFO_MAX);\r\nif (err) {\r\nWL_ERR("WLC_GET_BSS_INFO failed: %d\n", err);\r\ngoto CleanUp;\r\n}\r\nbi = (struct brcmf_bss_info_le *)(buf + 4);\r\nchannel = bi->ctl_ch ? bi->ctl_ch :\r\nCHSPEC_CHANNEL(le16_to_cpu(bi->chanspec));\r\nif (channel <= CH_MAX_2G_CHANNEL)\r\nband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfreq = ieee80211_channel_to_frequency(channel, band->band);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nnotify_capability = le16_to_cpu(bi->capability);\r\nnotify_interval = le16_to_cpu(bi->beacon_period);\r\nnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\r\nnotify_ielen = le32_to_cpu(bi->ie_length);\r\nnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\r\nWL_CONN("channel: %d(%d)\n", channel, freq);\r\nWL_CONN("capability: %X\n", notify_capability);\r\nWL_CONN("beacon interval: %d\n", notify_interval);\r\nWL_CONN("signal: %d\n", notify_signal);\r\nbss = cfg80211_inform_bss(wiphy, notify_channel, bssid,\r\n0, notify_capability, notify_interval,\r\nnotify_ie, notify_ielen, notify_signal, GFP_KERNEL);\r\nif (!bss) {\r\nerr = -ENOMEM;\r\ngoto CleanUp;\r\n}\r\ncfg80211_put_bss(bss);\r\nCleanUp:\r\nkfree(buf);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic bool brcmf_is_ibssmode(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nreturn cfg_priv->conf->mode == WL_MODE_IBSS;\r\n}\r\nstatic struct brcmf_tlv *brcmf_parse_tlvs(void *buf, int buflen, uint key)\r\n{\r\nstruct brcmf_tlv *elt;\r\nint totlen;\r\nelt = (struct brcmf_tlv *) buf;\r\ntotlen = buflen;\r\nwhile (totlen >= 2) {\r\nint len = elt->len;\r\nif ((elt->id == key) && (totlen >= (len + 2)))\r\nreturn elt;\r\nelt = (struct brcmf_tlv *) ((u8 *) elt + (len + 2));\r\ntotlen -= (len + 2);\r\n}\r\nreturn NULL;\r\n}\r\nstatic s32 brcmf_update_bss_info(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_bss_info_le *bi;\r\nstruct brcmf_ssid *ssid;\r\nstruct brcmf_tlv *tim;\r\nu16 beacon_interval;\r\nu8 dtim_period;\r\nsize_t ie_len;\r\nu8 *ie;\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (brcmf_is_ibssmode(cfg_priv))\r\nreturn err;\r\nssid = (struct brcmf_ssid *)brcmf_read_prof(cfg_priv, WL_PROF_SSID);\r\n*(__le32 *)cfg_priv->extra_buf = cpu_to_le32(WL_EXTRA_BUF_MAX);\r\nerr = brcmf_exec_dcmd(cfg_to_ndev(cfg_priv), BRCMF_C_GET_BSS_INFO,\r\ncfg_priv->extra_buf, WL_EXTRA_BUF_MAX);\r\nif (err) {\r\nWL_ERR("Could not get bss info %d\n", err);\r\ngoto update_bss_info_out;\r\n}\r\nbi = (struct brcmf_bss_info_le *)(cfg_priv->extra_buf + 4);\r\nerr = brcmf_inform_single_bss(cfg_priv, bi);\r\nif (err)\r\ngoto update_bss_info_out;\r\nie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\r\nie_len = le32_to_cpu(bi->ie_length);\r\nbeacon_interval = le16_to_cpu(bi->beacon_period);\r\ntim = brcmf_parse_tlvs(ie, ie_len, WLAN_EID_TIM);\r\nif (tim)\r\ndtim_period = tim->data[1];\r\nelse {\r\nu32 var;\r\nerr = brcmf_dev_intvar_get(cfg_to_ndev(cfg_priv),\r\n"dtim_assoc", &var);\r\nif (err) {\r\nWL_ERR("wl dtim_assoc failed (%d)\n", err);\r\ngoto update_bss_info_out;\r\n}\r\ndtim_period = (u8)var;\r\n}\r\nbrcmf_update_prof(cfg_priv, NULL, &beacon_interval, WL_PROF_BEACONINT);\r\nbrcmf_update_prof(cfg_priv, NULL, &dtim_period, WL_PROF_DTIMPERIOD);\r\nupdate_bss_info_out:\r\nWL_TRACE("Exit");\r\nreturn err;\r\n}\r\nstatic void brcmf_term_iscan(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_to_iscan(cfg_priv);\r\nstruct brcmf_ssid ssid;\r\nif (cfg_priv->iscan_on) {\r\niscan->state = WL_ISCAN_STATE_IDLE;\r\nif (iscan->timer_on) {\r\ndel_timer_sync(&iscan->timer);\r\niscan->timer_on = 0;\r\n}\r\ncancel_work_sync(&iscan->work);\r\nmemset(&ssid, 0, sizeof(ssid));\r\nbrcmf_run_iscan(iscan, &ssid, WL_SCAN_ACTION_ABORT);\r\n}\r\n}\r\nstatic void brcmf_notify_iscan_complete(struct brcmf_cfg80211_iscan_ctrl *iscan,\r\nbool aborted)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = iscan_to_cfg(iscan);\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\nif (!test_and_clear_bit(WL_STATUS_SCANNING, &cfg_priv->status)) {\r\nWL_ERR("Scan complete while device not scanning\n");\r\nreturn;\r\n}\r\nif (cfg_priv->scan_request) {\r\nWL_SCAN("ISCAN Completed scan: %s\n",\r\naborted ? "Aborted" : "Done");\r\ncfg80211_scan_done(cfg_priv->scan_request, aborted);\r\nbrcmf_set_mpc(ndev, 1);\r\ncfg_priv->scan_request = NULL;\r\n}\r\ncfg_priv->iscan_kickstart = false;\r\n}\r\nstatic s32 brcmf_wakeup_iscan(struct brcmf_cfg80211_iscan_ctrl *iscan)\r\n{\r\nif (iscan->state != WL_ISCAN_STATE_IDLE) {\r\nWL_SCAN("wake up iscan\n");\r\nschedule_work(&iscan->work);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic s32\r\nbrcmf_get_iscan_results(struct brcmf_cfg80211_iscan_ctrl *iscan, u32 *status,\r\nstruct brcmf_scan_results **bss_list)\r\n{\r\nstruct brcmf_iscan_results list;\r\nstruct brcmf_scan_results *results;\r\nstruct brcmf_scan_results_le *results_le;\r\nstruct brcmf_iscan_results *list_buf;\r\ns32 err = 0;\r\nmemset(iscan->scan_buf, 0, WL_ISCAN_BUF_MAX);\r\nlist_buf = (struct brcmf_iscan_results *)iscan->scan_buf;\r\nresults = &list_buf->results;\r\nresults_le = &list_buf->results_le;\r\nresults->buflen = BRCMF_ISCAN_RESULTS_FIXED_SIZE;\r\nresults->version = 0;\r\nresults->count = 0;\r\nmemset(&list, 0, sizeof(list));\r\nlist.results_le.buflen = cpu_to_le32(WL_ISCAN_BUF_MAX);\r\nerr = brcmf_dev_iovar_getbuf(iscan->ndev, "iscanresults", &list,\r\nBRCMF_ISCAN_RESULTS_FIXED_SIZE,\r\niscan->scan_buf, WL_ISCAN_BUF_MAX);\r\nif (err) {\r\nWL_ERR("error (%d)\n", err);\r\nreturn err;\r\n}\r\nresults->buflen = le32_to_cpu(results_le->buflen);\r\nresults->version = le32_to_cpu(results_le->version);\r\nresults->count = le32_to_cpu(results_le->count);\r\nWL_SCAN("results->count = %d\n", results_le->count);\r\nWL_SCAN("results->buflen = %d\n", results_le->buflen);\r\n*status = le32_to_cpu(list_buf->status_le);\r\nWL_SCAN("status = %d\n", *status);\r\n*bss_list = results;\r\nreturn err;\r\n}\r\nstatic s32 brcmf_iscan_done(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_priv->iscan;\r\ns32 err = 0;\r\niscan->state = WL_ISCAN_STATE_IDLE;\r\nbrcmf_inform_bss(cfg_priv);\r\nbrcmf_notify_iscan_complete(iscan, false);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_iscan_pending(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_priv->iscan;\r\ns32 err = 0;\r\nmod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);\r\niscan->timer_on = 1;\r\nreturn err;\r\n}\r\nstatic s32 brcmf_iscan_inprogress(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_priv->iscan;\r\ns32 err = 0;\r\nbrcmf_inform_bss(cfg_priv);\r\nbrcmf_run_iscan(iscan, NULL, BRCMF_SCAN_ACTION_CONTINUE);\r\nmod_timer(&iscan->timer, jiffies + iscan->timer_ms * HZ / 1000);\r\niscan->timer_on = 1;\r\nreturn err;\r\n}\r\nstatic s32 brcmf_iscan_aborted(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_priv->iscan;\r\ns32 err = 0;\r\niscan->state = WL_ISCAN_STATE_IDLE;\r\nbrcmf_notify_iscan_complete(iscan, true);\r\nreturn err;\r\n}\r\nstatic void brcmf_cfg80211_iscan_handler(struct work_struct *work)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan =\r\ncontainer_of(work, struct brcmf_cfg80211_iscan_ctrl,\r\nwork);\r\nstruct brcmf_cfg80211_priv *cfg_priv = iscan_to_cfg(iscan);\r\nstruct brcmf_cfg80211_iscan_eloop *el = &iscan->el;\r\nu32 status = BRCMF_SCAN_RESULTS_PARTIAL;\r\nif (iscan->timer_on) {\r\ndel_timer_sync(&iscan->timer);\r\niscan->timer_on = 0;\r\n}\r\nif (brcmf_get_iscan_results(iscan, &status, &cfg_priv->bss_list)) {\r\nstatus = BRCMF_SCAN_RESULTS_ABORTED;\r\nWL_ERR("Abort iscan\n");\r\n}\r\nel->handler[status](cfg_priv);\r\n}\r\nstatic void brcmf_iscan_timer(unsigned long data)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan =\r\n(struct brcmf_cfg80211_iscan_ctrl *)data;\r\nif (iscan) {\r\niscan->timer_on = 0;\r\nWL_SCAN("timer expired\n");\r\nbrcmf_wakeup_iscan(iscan);\r\n}\r\n}\r\nstatic s32 brcmf_invoke_iscan(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_to_iscan(cfg_priv);\r\nif (cfg_priv->iscan_on) {\r\niscan->state = WL_ISCAN_STATE_IDLE;\r\nINIT_WORK(&iscan->work, brcmf_cfg80211_iscan_handler);\r\n}\r\nreturn 0;\r\n}\r\nstatic void brcmf_init_iscan_eloop(struct brcmf_cfg80211_iscan_eloop *el)\r\n{\r\nmemset(el, 0, sizeof(*el));\r\nel->handler[BRCMF_SCAN_RESULTS_SUCCESS] = brcmf_iscan_done;\r\nel->handler[BRCMF_SCAN_RESULTS_PARTIAL] = brcmf_iscan_inprogress;\r\nel->handler[BRCMF_SCAN_RESULTS_PENDING] = brcmf_iscan_pending;\r\nel->handler[BRCMF_SCAN_RESULTS_ABORTED] = brcmf_iscan_aborted;\r\nel->handler[BRCMF_SCAN_RESULTS_NO_MEM] = brcmf_iscan_aborted;\r\n}\r\nstatic s32 brcmf_init_iscan(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_iscan_ctrl *iscan = cfg_to_iscan(cfg_priv);\r\nint err = 0;\r\nif (cfg_priv->iscan_on) {\r\niscan->ndev = cfg_to_ndev(cfg_priv);\r\nbrcmf_init_iscan_eloop(&iscan->el);\r\niscan->timer_ms = WL_ISCAN_TIMER_INTERVAL_MS;\r\ninit_timer(&iscan->timer);\r\niscan->timer.data = (unsigned long) iscan;\r\niscan->timer.function = brcmf_iscan_timer;\r\nerr = brcmf_invoke_iscan(cfg_priv);\r\nif (!err)\r\niscan->data = cfg_priv;\r\n}\r\nreturn err;\r\n}\r\nstatic __always_inline void brcmf_delay(u32 ms)\r\n{\r\nif (ms < 1000 / HZ) {\r\ncond_resched();\r\nmdelay(ms);\r\n} else {\r\nmsleep(ms);\r\n}\r\n}\r\nstatic s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nWL_TRACE("Enter\n");\r\nif (test_bit(WL_STATUS_READY, &cfg_priv->status))\r\nbrcmf_invoke_iscan(wiphy_to_cfg(wiphy));\r\nWL_TRACE("Exit\n");\r\nreturn 0;\r\n}\r\nstatic s32 brcmf_cfg80211_suspend(struct wiphy *wiphy,\r\nstruct cfg80211_wowlan *wow)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\nWL_TRACE("Enter\n");\r\nif ((test_bit(WL_STATUS_CONNECTED, &cfg_priv->status) ||\r\ntest_bit(WL_STATUS_CONNECTING, &cfg_priv->status)) &&\r\ntest_bit(WL_STATUS_READY, &cfg_priv->status)) {\r\nWL_INFO("Disassociating from AP"\r\n" while entering suspend state\n");\r\nbrcmf_link_down(cfg_priv);\r\nbrcmf_delay(500);\r\n}\r\nset_bit(WL_STATUS_SCAN_ABORTING, &cfg_priv->status);\r\nif (test_bit(WL_STATUS_READY, &cfg_priv->status))\r\nbrcmf_term_iscan(cfg_priv);\r\nif (cfg_priv->scan_request) {\r\nWL_INFO("Terminating scan in progress\n");\r\ncfg80211_scan_done(cfg_priv->scan_request, true);\r\ncfg_priv->scan_request = NULL;\r\n}\r\nclear_bit(WL_STATUS_SCANNING, &cfg_priv->status);\r\nclear_bit(WL_STATUS_SCAN_ABORTING, &cfg_priv->status);\r\nif (test_bit(WL_STATUS_READY, &cfg_priv->status)) {\r\nWL_INFO("Enable MPC\n");\r\nbrcmf_set_mpc(ndev, 1);\r\n}\r\nWL_TRACE("Exit\n");\r\nreturn 0;\r\n}\r\nstatic __used s32\r\nbrcmf_dev_bufvar_set(struct net_device *ndev, s8 *name, s8 *buf, s32 len)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nu32 buflen;\r\nbuflen = brcmf_c_mkiovar(name, buf, len, cfg_priv->dcmd_buf,\r\nWL_DCMD_LEN_MAX);\r\nBUG_ON(!buflen);\r\nreturn brcmf_exec_dcmd(ndev, BRCMF_C_SET_VAR, cfg_priv->dcmd_buf,\r\nbuflen);\r\n}\r\nstatic s32\r\nbrcmf_dev_bufvar_get(struct net_device *ndev, s8 *name, s8 *buf,\r\ns32 buf_len)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nu32 len;\r\ns32 err = 0;\r\nlen = brcmf_c_mkiovar(name, NULL, 0, cfg_priv->dcmd_buf,\r\nWL_DCMD_LEN_MAX);\r\nBUG_ON(!len);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_GET_VAR, cfg_priv->dcmd_buf,\r\nWL_DCMD_LEN_MAX);\r\nif (err) {\r\nWL_ERR("error (%d)\n", err);\r\nreturn err;\r\n}\r\nmemcpy(buf, cfg_priv->dcmd_buf, buf_len);\r\nreturn err;\r\n}\r\nstatic __used s32\r\nbrcmf_update_pmklist(struct net_device *ndev,\r\nstruct brcmf_cfg80211_pmk_list *pmk_list, s32 err)\r\n{\r\nint i, j;\r\nint pmkid_len;\r\npmkid_len = le32_to_cpu(pmk_list->pmkids.npmkid);\r\nWL_CONN("No of elements %d\n", pmkid_len);\r\nfor (i = 0; i < pmkid_len; i++) {\r\nWL_CONN("PMKID[%d]: %pM =\n", i,\r\n&pmk_list->pmkids.pmkid[i].BSSID);\r\nfor (j = 0; j < WLAN_PMKID_LEN; j++)\r\nWL_CONN("%02x\n", pmk_list->pmkids.pmkid[i].PMKID[j]);\r\n}\r\nif (!err)\r\nbrcmf_dev_bufvar_set(ndev, "pmkid_info", (char *)pmk_list,\r\nsizeof(*pmk_list));\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct pmkid_list *pmkids = &cfg_priv->pmk_list->pmkids;\r\ns32 err = 0;\r\nint i;\r\nint pmkid_len;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\npmkid_len = le32_to_cpu(pmkids->npmkid);\r\nfor (i = 0; i < pmkid_len; i++)\r\nif (!memcmp(pmksa->bssid, pmkids->pmkid[i].BSSID, ETH_ALEN))\r\nbreak;\r\nif (i < WL_NUM_PMKIDS_MAX) {\r\nmemcpy(pmkids->pmkid[i].BSSID, pmksa->bssid, ETH_ALEN);\r\nmemcpy(pmkids->pmkid[i].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);\r\nif (i == pmkid_len) {\r\npmkid_len++;\r\npmkids->npmkid = cpu_to_le32(pmkid_len);\r\n}\r\n} else\r\nerr = -EINVAL;\r\nWL_CONN("set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",\r\npmkids->pmkid[pmkid_len].BSSID);\r\nfor (i = 0; i < WLAN_PMKID_LEN; i++)\r\nWL_CONN("%02x\n", pmkids->pmkid[pmkid_len].PMKID[i]);\r\nerr = brcmf_update_pmklist(ndev, cfg_priv->pmk_list, err);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\nstruct pmkid_list pmkid;\r\ns32 err = 0;\r\nint i, pmkid_len;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nmemcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETH_ALEN);\r\nmemcpy(&pmkid.pmkid[0].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);\r\nWL_CONN("del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",\r\n&pmkid.pmkid[0].BSSID);\r\nfor (i = 0; i < WLAN_PMKID_LEN; i++)\r\nWL_CONN("%02x\n", pmkid.pmkid[0].PMKID[i]);\r\npmkid_len = le32_to_cpu(cfg_priv->pmk_list->pmkids.npmkid);\r\nfor (i = 0; i < pmkid_len; i++)\r\nif (!memcmp\r\n(pmksa->bssid, &cfg_priv->pmk_list->pmkids.pmkid[i].BSSID,\r\nETH_ALEN))\r\nbreak;\r\nif ((pmkid_len > 0)\r\n&& (i < pmkid_len)) {\r\nmemset(&cfg_priv->pmk_list->pmkids.pmkid[i], 0,\r\nsizeof(struct pmkid));\r\nfor (; i < (pmkid_len - 1); i++) {\r\nmemcpy(&cfg_priv->pmk_list->pmkids.pmkid[i].BSSID,\r\n&cfg_priv->pmk_list->pmkids.pmkid[i + 1].BSSID,\r\nETH_ALEN);\r\nmemcpy(&cfg_priv->pmk_list->pmkids.pmkid[i].PMKID,\r\n&cfg_priv->pmk_list->pmkids.pmkid[i + 1].PMKID,\r\nWLAN_PMKID_LEN);\r\n}\r\ncfg_priv->pmk_list->pmkids.npmkid = cpu_to_le32(pmkid_len - 1);\r\n} else\r\nerr = -EINVAL;\r\nerr = brcmf_update_pmklist(ndev, cfg_priv->pmk_list, err);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv = wiphy_to_cfg(wiphy);\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (!check_sys_up(wiphy))\r\nreturn -EIO;\r\nmemset(cfg_priv->pmk_list, 0, sizeof(*cfg_priv->pmk_list));\r\nerr = brcmf_update_pmklist(ndev, cfg_priv->pmk_list, err);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_mode_to_nl80211_iftype(s32 mode)\r\n{\r\ns32 err = 0;\r\nswitch (mode) {\r\ncase WL_MODE_BSS:\r\nreturn NL80211_IFTYPE_STATION;\r\ncase WL_MODE_IBSS:\r\nreturn NL80211_IFTYPE_ADHOC;\r\ndefault:\r\nreturn NL80211_IFTYPE_UNSPECIFIED;\r\n}\r\nreturn err;\r\n}\r\nstatic struct wireless_dev *brcmf_alloc_wdev(s32 sizeof_iface,\r\nstruct device *ndev)\r\n{\r\nstruct wireless_dev *wdev;\r\ns32 err = 0;\r\nwdev = kzalloc(sizeof(*wdev), GFP_KERNEL);\r\nif (!wdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nwdev->wiphy =\r\nwiphy_new(&wl_cfg80211_ops,\r\nsizeof(struct brcmf_cfg80211_priv) + sizeof_iface);\r\nif (!wdev->wiphy) {\r\nWL_ERR("Could not allocate wiphy device\n");\r\nerr = -ENOMEM;\r\ngoto wiphy_new_out;\r\n}\r\nset_wiphy_dev(wdev->wiphy, ndev);\r\nwdev->wiphy->max_scan_ssids = WL_NUM_SCAN_MAX;\r\nwdev->wiphy->max_num_pmkids = WL_NUM_PMKIDS_MAX;\r\nwdev->wiphy->interface_modes =\r\nBIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);\r\nwdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;\r\nwdev->wiphy->bands[IEEE80211_BAND_5GHZ] = &__wl_band_5ghz_a;\r\nwdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwdev->wiphy->cipher_suites = __wl_cipher_suites;\r\nwdev->wiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);\r\nwdev->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nerr = wiphy_register(wdev->wiphy);\r\nif (err < 0) {\r\nWL_ERR("Could not register wiphy device (%d)\n", err);\r\ngoto wiphy_register_out;\r\n}\r\nreturn wdev;\r\nwiphy_register_out:\r\nwiphy_free(wdev->wiphy);\r\nwiphy_new_out:\r\nkfree(wdev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void brcmf_free_wdev(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct wireless_dev *wdev = cfg_priv->wdev;\r\nif (!wdev) {\r\nWL_ERR("wdev is invalid\n");\r\nreturn;\r\n}\r\nwiphy_unregister(wdev->wiphy);\r\nwiphy_free(wdev->wiphy);\r\nkfree(wdev);\r\ncfg_priv->wdev = NULL;\r\n}\r\nstatic bool brcmf_is_linkup(struct brcmf_cfg80211_priv *cfg_priv,\r\nconst struct brcmf_event_msg *e)\r\n{\r\nu32 event = be32_to_cpu(e->event_type);\r\nu32 status = be32_to_cpu(e->status);\r\nif (event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS) {\r\nWL_CONN("Processing set ssid\n");\r\ncfg_priv->link_up = true;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool brcmf_is_linkdown(struct brcmf_cfg80211_priv *cfg_priv,\r\nconst struct brcmf_event_msg *e)\r\n{\r\nu32 event = be32_to_cpu(e->event_type);\r\nu16 flags = be16_to_cpu(e->flags);\r\nif (event == BRCMF_E_LINK && (!(flags & BRCMF_EVENT_MSG_LINK))) {\r\nWL_CONN("Processing link down\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool brcmf_is_nonetwork(struct brcmf_cfg80211_priv *cfg_priv,\r\nconst struct brcmf_event_msg *e)\r\n{\r\nu32 event = be32_to_cpu(e->event_type);\r\nu32 status = be32_to_cpu(e->status);\r\nif (event == BRCMF_E_LINK && status == BRCMF_E_STATUS_NO_NETWORKS) {\r\nWL_CONN("Processing Link %s & no network found\n",\r\nbe16_to_cpu(e->flags) & BRCMF_EVENT_MSG_LINK ?\r\n"up" : "down");\r\nreturn true;\r\n}\r\nif (event == BRCMF_E_SET_SSID && status != BRCMF_E_STATUS_SUCCESS) {\r\nWL_CONN("Processing connecting & no network found\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void brcmf_clear_assoc_ies(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg_priv);\r\nkfree(conn_info->req_ie);\r\nconn_info->req_ie = NULL;\r\nconn_info->req_ie_len = 0;\r\nkfree(conn_info->resp_ie);\r\nconn_info->resp_ie = NULL;\r\nconn_info->resp_ie_len = 0;\r\n}\r\nstatic s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct net_device *ndev = cfg_to_ndev(cfg_priv);\r\nstruct brcmf_cfg80211_assoc_ielen_le *assoc_info;\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg_priv);\r\nu32 req_len;\r\nu32 resp_len;\r\ns32 err = 0;\r\nbrcmf_clear_assoc_ies(cfg_priv);\r\nerr = brcmf_dev_bufvar_get(ndev, "assoc_info", cfg_priv->extra_buf,\r\nWL_ASSOC_INFO_MAX);\r\nif (err) {\r\nWL_ERR("could not get assoc info (%d)\n", err);\r\nreturn err;\r\n}\r\nassoc_info =\r\n(struct brcmf_cfg80211_assoc_ielen_le *)cfg_priv->extra_buf;\r\nreq_len = le32_to_cpu(assoc_info->req_len);\r\nresp_len = le32_to_cpu(assoc_info->resp_len);\r\nif (req_len) {\r\nerr = brcmf_dev_bufvar_get(ndev, "assoc_req_ies",\r\ncfg_priv->extra_buf,\r\nWL_ASSOC_INFO_MAX);\r\nif (err) {\r\nWL_ERR("could not get assoc req (%d)\n", err);\r\nreturn err;\r\n}\r\nconn_info->req_ie_len = req_len;\r\nconn_info->req_ie =\r\nkmemdup(cfg_priv->extra_buf, conn_info->req_ie_len,\r\nGFP_KERNEL);\r\n} else {\r\nconn_info->req_ie_len = 0;\r\nconn_info->req_ie = NULL;\r\n}\r\nif (resp_len) {\r\nerr = brcmf_dev_bufvar_get(ndev, "assoc_resp_ies",\r\ncfg_priv->extra_buf,\r\nWL_ASSOC_INFO_MAX);\r\nif (err) {\r\nWL_ERR("could not get assoc resp (%d)\n", err);\r\nreturn err;\r\n}\r\nconn_info->resp_ie_len = resp_len;\r\nconn_info->resp_ie =\r\nkmemdup(cfg_priv->extra_buf, conn_info->resp_ie_len,\r\nGFP_KERNEL);\r\n} else {\r\nconn_info->resp_ie_len = 0;\r\nconn_info->resp_ie = NULL;\r\n}\r\nWL_CONN("req len (%d) resp len (%d)\n",\r\nconn_info->req_ie_len, conn_info->resp_ie_len);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_bss_roaming_done(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e)\r\n{\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg_priv);\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg_priv);\r\nstruct brcmf_channel_info_le channel_le;\r\nstruct ieee80211_channel *notify_channel;\r\nstruct ieee80211_supported_band *band;\r\nu32 freq;\r\ns32 err = 0;\r\nu32 target_channel;\r\nWL_TRACE("Enter\n");\r\nbrcmf_get_assoc_ies(cfg_priv);\r\nbrcmf_update_prof(cfg_priv, NULL, &e->addr, WL_PROF_BSSID);\r\nbrcmf_update_bss_info(cfg_priv);\r\nbrcmf_exec_dcmd(ndev, BRCMF_C_GET_CHANNEL, &channel_le,\r\nsizeof(channel_le));\r\ntarget_channel = le32_to_cpu(channel_le.target_channel);\r\nWL_CONN("Roamed to channel %d\n", target_channel);\r\nif (target_channel <= CH_MAX_2G_CHANNEL)\r\nband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfreq = ieee80211_channel_to_frequency(target_channel, band->band);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\ncfg80211_roamed(ndev, notify_channel,\r\n(u8 *)brcmf_read_prof(cfg_priv, WL_PROF_BSSID),\r\nconn_info->req_ie, conn_info->req_ie_len,\r\nconn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);\r\nWL_CONN("Report roaming result\n");\r\nset_bit(WL_STATUS_CONNECTED, &cfg_priv->status);\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_bss_connect_done(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev, const struct brcmf_event_msg *e,\r\nbool completed)\r\n{\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg_priv);\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nif (test_and_clear_bit(WL_STATUS_CONNECTING, &cfg_priv->status)) {\r\nif (completed) {\r\nbrcmf_get_assoc_ies(cfg_priv);\r\nbrcmf_update_prof(cfg_priv, NULL, &e->addr,\r\nWL_PROF_BSSID);\r\nbrcmf_update_bss_info(cfg_priv);\r\n}\r\ncfg80211_connect_result(ndev,\r\n(u8 *)brcmf_read_prof(cfg_priv,\r\nWL_PROF_BSSID),\r\nconn_info->req_ie,\r\nconn_info->req_ie_len,\r\nconn_info->resp_ie,\r\nconn_info->resp_ie_len,\r\ncompleted ? WLAN_STATUS_SUCCESS :\r\nWLAN_STATUS_AUTH_TIMEOUT,\r\nGFP_KERNEL);\r\nif (completed)\r\nset_bit(WL_STATUS_CONNECTED, &cfg_priv->status);\r\nWL_CONN("Report connect result - connection %s\n",\r\ncompleted ? "succeeded" : "failed");\r\n}\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_connect_status(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\ns32 err = 0;\r\nif (brcmf_is_linkup(cfg_priv, e)) {\r\nWL_CONN("Linkup\n");\r\nif (brcmf_is_ibssmode(cfg_priv)) {\r\nbrcmf_update_prof(cfg_priv, NULL, (void *)e->addr,\r\nWL_PROF_BSSID);\r\nwl_inform_ibss(cfg_priv, ndev, e->addr);\r\ncfg80211_ibss_joined(ndev, e->addr, GFP_KERNEL);\r\nclear_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nset_bit(WL_STATUS_CONNECTED, &cfg_priv->status);\r\n} else\r\nbrcmf_bss_connect_done(cfg_priv, ndev, e, true);\r\n} else if (brcmf_is_linkdown(cfg_priv, e)) {\r\nWL_CONN("Linkdown\n");\r\nif (brcmf_is_ibssmode(cfg_priv)) {\r\nclear_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nif (test_and_clear_bit(WL_STATUS_CONNECTED,\r\n&cfg_priv->status))\r\nbrcmf_link_down(cfg_priv);\r\n} else {\r\nbrcmf_bss_connect_done(cfg_priv, ndev, e, false);\r\nif (test_and_clear_bit(WL_STATUS_CONNECTED,\r\n&cfg_priv->status)) {\r\ncfg80211_disconnected(ndev, 0, NULL, 0,\r\nGFP_KERNEL);\r\nbrcmf_link_down(cfg_priv);\r\n}\r\n}\r\nbrcmf_init_prof(cfg_priv->profile);\r\n} else if (brcmf_is_nonetwork(cfg_priv, e)) {\r\nif (brcmf_is_ibssmode(cfg_priv))\r\nclear_bit(WL_STATUS_CONNECTING, &cfg_priv->status);\r\nelse\r\nbrcmf_bss_connect_done(cfg_priv, ndev, e, false);\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_roaming_status(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\ns32 err = 0;\r\nu32 event = be32_to_cpu(e->event_type);\r\nu32 status = be32_to_cpu(e->status);\r\nif (event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS) {\r\nif (test_bit(WL_STATUS_CONNECTED, &cfg_priv->status))\r\nbrcmf_bss_roaming_done(cfg_priv, ndev, e);\r\nelse\r\nbrcmf_bss_connect_done(cfg_priv, ndev, e, true);\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_mic_status(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nu16 flags = be16_to_cpu(e->flags);\r\nenum nl80211_key_type key_type;\r\nif (flags & BRCMF_EVENT_MSG_GROUP)\r\nkey_type = NL80211_KEYTYPE_GROUP;\r\nelse\r\nkey_type = NL80211_KEYTYPE_PAIRWISE;\r\ncfg80211_michael_mic_failure(ndev, (u8 *)&e->addr, key_type, -1,\r\nNULL, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nstatic s32\r\nbrcmf_notify_scan_status(struct brcmf_cfg80211_priv *cfg_priv,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstruct brcmf_channel_info_le channel_inform_le;\r\nstruct brcmf_scan_results_le *bss_list_le;\r\nu32 len = WL_SCAN_BUF_MAX;\r\ns32 err = 0;\r\nbool scan_abort = false;\r\nu32 scan_channel;\r\nWL_TRACE("Enter\n");\r\nif (cfg_priv->iscan_on && cfg_priv->iscan_kickstart) {\r\nWL_TRACE("Exit\n");\r\nreturn brcmf_wakeup_iscan(cfg_to_iscan(cfg_priv));\r\n}\r\nif (!test_and_clear_bit(WL_STATUS_SCANNING, &cfg_priv->status)) {\r\nWL_ERR("Scan complete while device not scanning\n");\r\nscan_abort = true;\r\nerr = -EINVAL;\r\ngoto scan_done_out;\r\n}\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_GET_CHANNEL, &channel_inform_le,\r\nsizeof(channel_inform_le));\r\nif (err) {\r\nWL_ERR("scan busy (%d)\n", err);\r\nscan_abort = true;\r\ngoto scan_done_out;\r\n}\r\nscan_channel = le32_to_cpu(channel_inform_le.scan_channel);\r\nif (scan_channel)\r\nWL_CONN("channel_inform.scan_channel (%d)\n", scan_channel);\r\ncfg_priv->bss_list = cfg_priv->scan_results;\r\nbss_list_le = (struct brcmf_scan_results_le *) cfg_priv->bss_list;\r\nmemset(cfg_priv->scan_results, 0, len);\r\nbss_list_le->buflen = cpu_to_le32(len);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SCAN_RESULTS,\r\ncfg_priv->scan_results, len);\r\nif (err) {\r\nWL_ERR("%s Scan_results error (%d)\n", ndev->name, err);\r\nerr = -EINVAL;\r\nscan_abort = true;\r\ngoto scan_done_out;\r\n}\r\ncfg_priv->scan_results->buflen = le32_to_cpu(bss_list_le->buflen);\r\ncfg_priv->scan_results->version = le32_to_cpu(bss_list_le->version);\r\ncfg_priv->scan_results->count = le32_to_cpu(bss_list_le->count);\r\nerr = brcmf_inform_bss(cfg_priv);\r\nif (err) {\r\nscan_abort = true;\r\ngoto scan_done_out;\r\n}\r\nscan_done_out:\r\nif (cfg_priv->scan_request) {\r\nWL_SCAN("calling cfg80211_scan_done\n");\r\ncfg80211_scan_done(cfg_priv->scan_request, scan_abort);\r\nbrcmf_set_mpc(ndev, 1);\r\ncfg_priv->scan_request = NULL;\r\n}\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic void brcmf_init_conf(struct brcmf_cfg80211_conf *conf)\r\n{\r\nconf->mode = (u32)-1;\r\nconf->frag_threshold = (u32)-1;\r\nconf->rts_threshold = (u32)-1;\r\nconf->retry_short = (u32)-1;\r\nconf->retry_long = (u32)-1;\r\nconf->tx_power = -1;\r\n}\r\nstatic void brcmf_init_eloop_handler(struct brcmf_cfg80211_event_loop *el)\r\n{\r\nmemset(el, 0, sizeof(*el));\r\nel->handler[BRCMF_E_SCAN_COMPLETE] = brcmf_notify_scan_status;\r\nel->handler[BRCMF_E_LINK] = brcmf_notify_connect_status;\r\nel->handler[BRCMF_E_ROAM] = brcmf_notify_roaming_status;\r\nel->handler[BRCMF_E_MIC_ERROR] = brcmf_notify_mic_status;\r\nel->handler[BRCMF_E_SET_SSID] = brcmf_notify_connect_status;\r\n}\r\nstatic void brcmf_deinit_priv_mem(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nkfree(cfg_priv->scan_results);\r\ncfg_priv->scan_results = NULL;\r\nkfree(cfg_priv->bss_info);\r\ncfg_priv->bss_info = NULL;\r\nkfree(cfg_priv->conf);\r\ncfg_priv->conf = NULL;\r\nkfree(cfg_priv->profile);\r\ncfg_priv->profile = NULL;\r\nkfree(cfg_priv->scan_req_int);\r\ncfg_priv->scan_req_int = NULL;\r\nkfree(cfg_priv->dcmd_buf);\r\ncfg_priv->dcmd_buf = NULL;\r\nkfree(cfg_priv->extra_buf);\r\ncfg_priv->extra_buf = NULL;\r\nkfree(cfg_priv->iscan);\r\ncfg_priv->iscan = NULL;\r\nkfree(cfg_priv->pmk_list);\r\ncfg_priv->pmk_list = NULL;\r\n}\r\nstatic s32 brcmf_init_priv_mem(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\ncfg_priv->scan_results = kzalloc(WL_SCAN_BUF_MAX, GFP_KERNEL);\r\nif (!cfg_priv->scan_results)\r\ngoto init_priv_mem_out;\r\ncfg_priv->conf = kzalloc(sizeof(*cfg_priv->conf), GFP_KERNEL);\r\nif (!cfg_priv->conf)\r\ngoto init_priv_mem_out;\r\ncfg_priv->profile = kzalloc(sizeof(*cfg_priv->profile), GFP_KERNEL);\r\nif (!cfg_priv->profile)\r\ngoto init_priv_mem_out;\r\ncfg_priv->bss_info = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\r\nif (!cfg_priv->bss_info)\r\ngoto init_priv_mem_out;\r\ncfg_priv->scan_req_int = kzalloc(sizeof(*cfg_priv->scan_req_int),\r\nGFP_KERNEL);\r\nif (!cfg_priv->scan_req_int)\r\ngoto init_priv_mem_out;\r\ncfg_priv->dcmd_buf = kzalloc(WL_DCMD_LEN_MAX, GFP_KERNEL);\r\nif (!cfg_priv->dcmd_buf)\r\ngoto init_priv_mem_out;\r\ncfg_priv->extra_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\r\nif (!cfg_priv->extra_buf)\r\ngoto init_priv_mem_out;\r\ncfg_priv->iscan = kzalloc(sizeof(*cfg_priv->iscan), GFP_KERNEL);\r\nif (!cfg_priv->iscan)\r\ngoto init_priv_mem_out;\r\ncfg_priv->pmk_list = kzalloc(sizeof(*cfg_priv->pmk_list), GFP_KERNEL);\r\nif (!cfg_priv->pmk_list)\r\ngoto init_priv_mem_out;\r\nreturn 0;\r\ninit_priv_mem_out:\r\nbrcmf_deinit_priv_mem(cfg_priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic struct brcmf_cfg80211_event_q *brcmf_deq_event(\r\nstruct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_event_q *e = NULL;\r\nspin_lock_irq(&cfg_priv->evt_q_lock);\r\nif (!list_empty(&cfg_priv->evt_q_list)) {\r\ne = list_first_entry(&cfg_priv->evt_q_list,\r\nstruct brcmf_cfg80211_event_q, evt_q_list);\r\nlist_del(&e->evt_q_list);\r\n}\r\nspin_unlock_irq(&cfg_priv->evt_q_lock);\r\nreturn e;\r\n}\r\nstatic s32\r\nbrcmf_enq_event(struct brcmf_cfg80211_priv *cfg_priv, u32 event,\r\nconst struct brcmf_event_msg *msg)\r\n{\r\nstruct brcmf_cfg80211_event_q *e;\r\ns32 err = 0;\r\nulong flags;\r\ne = kzalloc(sizeof(struct brcmf_cfg80211_event_q), GFP_ATOMIC);\r\nif (!e)\r\nreturn -ENOMEM;\r\ne->etype = event;\r\nmemcpy(&e->emsg, msg, sizeof(struct brcmf_event_msg));\r\nspin_lock_irqsave(&cfg_priv->evt_q_lock, flags);\r\nlist_add_tail(&e->evt_q_list, &cfg_priv->evt_q_list);\r\nspin_unlock_irqrestore(&cfg_priv->evt_q_lock, flags);\r\nreturn err;\r\n}\r\nstatic void brcmf_put_event(struct brcmf_cfg80211_event_q *e)\r\n{\r\nkfree(e);\r\n}\r\nstatic void brcmf_cfg80211_event_handler(struct work_struct *work)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv =\r\ncontainer_of(work, struct brcmf_cfg80211_priv,\r\nevent_work);\r\nstruct brcmf_cfg80211_event_q *e;\r\ne = brcmf_deq_event(cfg_priv);\r\nif (unlikely(!e)) {\r\nWL_ERR("event queue empty...\n");\r\nreturn;\r\n}\r\ndo {\r\nWL_INFO("event type (%d)\n", e->etype);\r\nif (cfg_priv->el.handler[e->etype])\r\ncfg_priv->el.handler[e->etype](cfg_priv,\r\ncfg_to_ndev(cfg_priv),\r\n&e->emsg, e->edata);\r\nelse\r\nWL_INFO("Unknown Event (%d): ignoring\n", e->etype);\r\nbrcmf_put_event(e);\r\n} while ((e = brcmf_deq_event(cfg_priv)));\r\n}\r\nstatic void brcmf_init_eq(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nspin_lock_init(&cfg_priv->evt_q_lock);\r\nINIT_LIST_HEAD(&cfg_priv->evt_q_list);\r\n}\r\nstatic void brcmf_flush_eq(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct brcmf_cfg80211_event_q *e;\r\nspin_lock_irq(&cfg_priv->evt_q_lock);\r\nwhile (!list_empty(&cfg_priv->evt_q_list)) {\r\ne = list_first_entry(&cfg_priv->evt_q_list,\r\nstruct brcmf_cfg80211_event_q, evt_q_list);\r\nlist_del(&e->evt_q_list);\r\nkfree(e);\r\n}\r\nspin_unlock_irq(&cfg_priv->evt_q_lock);\r\n}\r\nstatic s32 wl_init_priv(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\ns32 err = 0;\r\ncfg_priv->scan_request = NULL;\r\ncfg_priv->pwr_save = true;\r\ncfg_priv->iscan_on = true;\r\ncfg_priv->roam_on = true;\r\ncfg_priv->iscan_kickstart = false;\r\ncfg_priv->active_scan = true;\r\ncfg_priv->dongle_up = false;\r\nbrcmf_init_eq(cfg_priv);\r\nerr = brcmf_init_priv_mem(cfg_priv);\r\nif (err)\r\nreturn err;\r\nINIT_WORK(&cfg_priv->event_work, brcmf_cfg80211_event_handler);\r\nbrcmf_init_eloop_handler(&cfg_priv->el);\r\nmutex_init(&cfg_priv->usr_sync);\r\nerr = brcmf_init_iscan(cfg_priv);\r\nif (err)\r\nreturn err;\r\nbrcmf_init_conf(cfg_priv->conf);\r\nbrcmf_init_prof(cfg_priv->profile);\r\nbrcmf_link_down(cfg_priv);\r\nreturn err;\r\n}\r\nstatic void wl_deinit_priv(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\ncancel_work_sync(&cfg_priv->event_work);\r\ncfg_priv->dongle_up = false;\r\nbrcmf_flush_eq(cfg_priv);\r\nbrcmf_link_down(cfg_priv);\r\nbrcmf_term_iscan(cfg_priv);\r\nbrcmf_deinit_priv_mem(cfg_priv);\r\n}\r\nstruct brcmf_cfg80211_dev *brcmf_cfg80211_attach(struct net_device *ndev,\r\nstruct device *busdev,\r\nvoid *data)\r\n{\r\nstruct wireless_dev *wdev;\r\nstruct brcmf_cfg80211_priv *cfg_priv;\r\nstruct brcmf_cfg80211_iface *ci;\r\nstruct brcmf_cfg80211_dev *cfg_dev;\r\ns32 err = 0;\r\nif (!ndev) {\r\nWL_ERR("ndev is invalid\n");\r\nreturn NULL;\r\n}\r\ncfg_dev = kzalloc(sizeof(struct brcmf_cfg80211_dev), GFP_KERNEL);\r\nif (!cfg_dev)\r\nreturn NULL;\r\nwdev = brcmf_alloc_wdev(sizeof(struct brcmf_cfg80211_iface), busdev);\r\nif (IS_ERR(wdev)) {\r\nkfree(cfg_dev);\r\nreturn NULL;\r\n}\r\nwdev->iftype = brcmf_mode_to_nl80211_iftype(WL_MODE_BSS);\r\ncfg_priv = wdev_to_cfg(wdev);\r\ncfg_priv->wdev = wdev;\r\ncfg_priv->pub = data;\r\nci = (struct brcmf_cfg80211_iface *)&cfg_priv->ci;\r\nci->cfg_priv = cfg_priv;\r\nndev->ieee80211_ptr = wdev;\r\nSET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));\r\nwdev->netdev = ndev;\r\nerr = wl_init_priv(cfg_priv);\r\nif (err) {\r\nWL_ERR("Failed to init iwm_priv (%d)\n", err);\r\ngoto cfg80211_attach_out;\r\n}\r\nbrcmf_set_drvdata(cfg_dev, ci);\r\nreturn cfg_dev;\r\ncfg80211_attach_out:\r\nbrcmf_free_wdev(cfg_priv);\r\nkfree(cfg_dev);\r\nreturn NULL;\r\n}\r\nvoid brcmf_cfg80211_detach(struct brcmf_cfg80211_dev *cfg_dev)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv;\r\ncfg_priv = brcmf_priv_get(cfg_dev);\r\nwl_deinit_priv(cfg_priv);\r\nbrcmf_free_wdev(cfg_priv);\r\nbrcmf_set_drvdata(cfg_dev, NULL);\r\nkfree(cfg_dev);\r\n}\r\nvoid\r\nbrcmf_cfg80211_event(struct net_device *ndev,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nu32 event_type = be32_to_cpu(e->event_type);\r\nstruct brcmf_cfg80211_priv *cfg_priv = ndev_to_cfg(ndev);\r\nif (!brcmf_enq_event(cfg_priv, event_type, e))\r\nschedule_work(&cfg_priv->event_work);\r\n}\r\nstatic s32 brcmf_dongle_mode(struct net_device *ndev, s32 iftype)\r\n{\r\ns32 infra = 0;\r\ns32 err = 0;\r\nswitch (iftype) {\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_WDS:\r\nWL_ERR("type (%d) : currently we do not support this mode\n",\r\niftype);\r\nerr = -EINVAL;\r\nreturn err;\r\ncase NL80211_IFTYPE_ADHOC:\r\ninfra = 0;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\ninfra = 1;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nWL_ERR("invalid type (%d)\n", iftype);\r\nreturn err;\r\n}\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_INFRA, &infra);\r\nif (err) {\r\nWL_ERR("WLC_SET_INFRA error (%d)\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 brcmf_dongle_eventmsg(struct net_device *ndev)\r\n{\r\ns8 iovbuf[BRCMF_EVENTING_MASK_LEN + 12];\r\ns8 eventmask[BRCMF_EVENTING_MASK_LEN];\r\ns32 err = 0;\r\nWL_TRACE("Enter\n");\r\nbrcmf_c_mkiovar("event_msgs", eventmask, BRCMF_EVENTING_MASK_LEN,\r\niovbuf, sizeof(iovbuf));\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_GET_VAR, iovbuf, sizeof(iovbuf));\r\nif (err) {\r\nWL_ERR("Get event_msgs error (%d)\n", err);\r\ngoto dongle_eventmsg_out;\r\n}\r\nmemcpy(eventmask, iovbuf, BRCMF_EVENTING_MASK_LEN);\r\nsetbit(eventmask, BRCMF_E_SET_SSID);\r\nsetbit(eventmask, BRCMF_E_ROAM);\r\nsetbit(eventmask, BRCMF_E_PRUNE);\r\nsetbit(eventmask, BRCMF_E_AUTH);\r\nsetbit(eventmask, BRCMF_E_REASSOC);\r\nsetbit(eventmask, BRCMF_E_REASSOC_IND);\r\nsetbit(eventmask, BRCMF_E_DEAUTH_IND);\r\nsetbit(eventmask, BRCMF_E_DISASSOC_IND);\r\nsetbit(eventmask, BRCMF_E_DISASSOC);\r\nsetbit(eventmask, BRCMF_E_JOIN);\r\nsetbit(eventmask, BRCMF_E_ASSOC_IND);\r\nsetbit(eventmask, BRCMF_E_PSK_SUP);\r\nsetbit(eventmask, BRCMF_E_LINK);\r\nsetbit(eventmask, BRCMF_E_NDIS_LINK);\r\nsetbit(eventmask, BRCMF_E_MIC_ERROR);\r\nsetbit(eventmask, BRCMF_E_PMKID_CACHE);\r\nsetbit(eventmask, BRCMF_E_TXFAIL);\r\nsetbit(eventmask, BRCMF_E_JOIN_START);\r\nsetbit(eventmask, BRCMF_E_SCAN_COMPLETE);\r\nbrcmf_c_mkiovar("event_msgs", eventmask, BRCMF_EVENTING_MASK_LEN,\r\niovbuf, sizeof(iovbuf));\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_VAR, iovbuf, sizeof(iovbuf));\r\nif (err) {\r\nWL_ERR("Set event_msgs error (%d)\n", err);\r\ngoto dongle_eventmsg_out;\r\n}\r\ndongle_eventmsg_out:\r\nWL_TRACE("Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_dongle_roam(struct net_device *ndev, u32 roamvar, u32 bcn_timeout)\r\n{\r\ns8 iovbuf[32];\r\ns32 err = 0;\r\n__le32 roamtrigger[2];\r\n__le32 roam_delta[2];\r\n__le32 bcn_to_le;\r\n__le32 roamvar_le;\r\nif (roamvar) {\r\nbcn_to_le = cpu_to_le32(bcn_timeout);\r\nbrcmf_c_mkiovar("bcn_timeout", (char *)&bcn_to_le,\r\nsizeof(bcn_to_le), iovbuf, sizeof(iovbuf));\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_VAR,\r\niovbuf, sizeof(iovbuf));\r\nif (err) {\r\nWL_ERR("bcn_timeout error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\n}\r\nWL_INFO("Internal Roaming = %s\n", roamvar ? "Off" : "On");\r\nroamvar_le = cpu_to_le32(roamvar);\r\nbrcmf_c_mkiovar("roam_off", (char *)&roamvar_le,\r\nsizeof(roamvar_le), iovbuf, sizeof(iovbuf));\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_VAR, iovbuf, sizeof(iovbuf));\r\nif (err) {\r\nWL_ERR("roam_off error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\nroamtrigger[0] = cpu_to_le32(WL_ROAM_TRIGGER_LEVEL);\r\nroamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_ROAM_TRIGGER,\r\n(void *)roamtrigger, sizeof(roamtrigger));\r\nif (err) {\r\nWL_ERR("WLC_SET_ROAM_TRIGGER error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\nroam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);\r\nroam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_ROAM_DELTA,\r\n(void *)roam_delta, sizeof(roam_delta));\r\nif (err) {\r\nWL_ERR("WLC_SET_ROAM_DELTA error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\ndongle_rom_out:\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_dongle_scantime(struct net_device *ndev, s32 scan_assoc_time,\r\ns32 scan_unassoc_time, s32 scan_passive_time)\r\n{\r\ns32 err = 0;\r\n__le32 scan_assoc_tm_le = cpu_to_le32(scan_assoc_time);\r\n__le32 scan_unassoc_tm_le = cpu_to_le32(scan_unassoc_time);\r\n__le32 scan_passive_tm_le = cpu_to_le32(scan_passive_time);\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_SCAN_CHANNEL_TIME,\r\n&scan_assoc_tm_le, sizeof(scan_assoc_tm_le));\r\nif (err) {\r\nif (err == -EOPNOTSUPP)\r\nWL_INFO("Scan assoc time is not supported\n");\r\nelse\r\nWL_ERR("Scan assoc time error (%d)\n", err);\r\ngoto dongle_scantime_out;\r\n}\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_SCAN_UNASSOC_TIME,\r\n&scan_unassoc_tm_le, sizeof(scan_unassoc_tm_le));\r\nif (err) {\r\nif (err == -EOPNOTSUPP)\r\nWL_INFO("Scan unassoc time is not supported\n");\r\nelse\r\nWL_ERR("Scan unassoc time error (%d)\n", err);\r\ngoto dongle_scantime_out;\r\n}\r\nerr = brcmf_exec_dcmd(ndev, BRCMF_C_SET_SCAN_PASSIVE_TIME,\r\n&scan_passive_tm_le, sizeof(scan_passive_tm_le));\r\nif (err) {\r\nif (err == -EOPNOTSUPP)\r\nWL_INFO("Scan passive time is not supported\n");\r\nelse\r\nWL_ERR("Scan passive time error (%d)\n", err);\r\ngoto dongle_scantime_out;\r\n}\r\ndongle_scantime_out:\r\nreturn err;\r\n}\r\nstatic s32 wl_update_wiphybands(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct wiphy *wiphy;\r\ns32 phy_list;\r\ns8 phy;\r\ns32 err = 0;\r\nerr = brcmf_exec_dcmd(cfg_to_ndev(cfg_priv), BRCM_GET_PHYLIST,\r\n&phy_list, sizeof(phy_list));\r\nif (err) {\r\nWL_ERR("error (%d)\n", err);\r\nreturn err;\r\n}\r\nphy = ((char *)&phy_list)[1];\r\nWL_INFO("%c phy\n", phy);\r\nif (phy == 'n' || phy == 'a') {\r\nwiphy = cfg_to_wiphy(cfg_priv);\r\nwiphy->bands[IEEE80211_BAND_5GHZ] = &__wl_band_5ghz_n;\r\n}\r\nreturn err;\r\n}\r\nstatic s32 brcmf_dongle_probecap(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nreturn wl_update_wiphybands(cfg_priv);\r\n}\r\nstatic s32 brcmf_config_dongle(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nstruct net_device *ndev;\r\nstruct wireless_dev *wdev;\r\ns32 power_mode;\r\ns32 err = 0;\r\nif (cfg_priv->dongle_up)\r\nreturn err;\r\nndev = cfg_to_ndev(cfg_priv);\r\nwdev = ndev->ieee80211_ptr;\r\nbrcmf_dongle_scantime(ndev, WL_SCAN_CHANNEL_TIME,\r\nWL_SCAN_UNASSOC_TIME, WL_SCAN_PASSIVE_TIME);\r\nerr = brcmf_dongle_eventmsg(ndev);\r\nif (err)\r\ngoto default_conf_out;\r\npower_mode = cfg_priv->pwr_save ? PM_FAST : PM_OFF;\r\nerr = brcmf_exec_dcmd_u32(ndev, BRCMF_C_SET_PM, &power_mode);\r\nif (err)\r\ngoto default_conf_out;\r\nWL_INFO("power save set to %s\n",\r\n(power_mode ? "enabled" : "disabled"));\r\nerr = brcmf_dongle_roam(ndev, (cfg_priv->roam_on ? 0 : 1),\r\nWL_BEACON_TIMEOUT);\r\nif (err)\r\ngoto default_conf_out;\r\nerr = brcmf_dongle_mode(ndev, wdev->iftype);\r\nif (err && err != -EINPROGRESS)\r\ngoto default_conf_out;\r\nerr = brcmf_dongle_probecap(cfg_priv);\r\nif (err)\r\ngoto default_conf_out;\r\ndefault_conf_out:\r\ncfg_priv->dongle_up = true;\r\nreturn err;\r\n}\r\nstatic int brcmf_debugfs_add_netdev_params(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nchar buf[10+IFNAMSIZ];\r\nstruct dentry *fd;\r\ns32 err = 0;\r\nsprintf(buf, "netdev:%s", cfg_to_ndev(cfg_priv)->name);\r\ncfg_priv->debugfsdir = debugfs_create_dir(buf,\r\ncfg_to_wiphy(cfg_priv)->debugfsdir);\r\nfd = debugfs_create_u16("beacon_int", S_IRUGO, cfg_priv->debugfsdir,\r\n(u16 *)&cfg_priv->profile->beacon_interval);\r\nif (!fd) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nfd = debugfs_create_u8("dtim_period", S_IRUGO, cfg_priv->debugfsdir,\r\n(u8 *)&cfg_priv->profile->dtim_period);\r\nif (!fd) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void brcmf_debugfs_remove_netdev(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\ndebugfs_remove_recursive(cfg_priv->debugfsdir);\r\ncfg_priv->debugfsdir = NULL;\r\n}\r\nstatic s32 __brcmf_cfg80211_up(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\ns32 err = 0;\r\nset_bit(WL_STATUS_READY, &cfg_priv->status);\r\nbrcmf_debugfs_add_netdev_params(cfg_priv);\r\nerr = brcmf_config_dongle(cfg_priv);\r\nif (err)\r\nreturn err;\r\nbrcmf_invoke_iscan(cfg_priv);\r\nreturn err;\r\n}\r\nstatic s32 __brcmf_cfg80211_down(struct brcmf_cfg80211_priv *cfg_priv)\r\n{\r\nif ((test_bit(WL_STATUS_CONNECTED, &cfg_priv->status) ||\r\ntest_bit(WL_STATUS_CONNECTING, &cfg_priv->status)) &&\r\ntest_bit(WL_STATUS_READY, &cfg_priv->status)) {\r\nWL_INFO("Disassociating from AP");\r\nbrcmf_link_down(cfg_priv);\r\nbrcmf_delay(500);\r\n}\r\nset_bit(WL_STATUS_SCAN_ABORTING, &cfg_priv->status);\r\nbrcmf_term_iscan(cfg_priv);\r\nif (cfg_priv->scan_request) {\r\ncfg80211_scan_done(cfg_priv->scan_request, true);\r\ncfg_priv->scan_request = NULL;\r\n}\r\nclear_bit(WL_STATUS_READY, &cfg_priv->status);\r\nclear_bit(WL_STATUS_SCANNING, &cfg_priv->status);\r\nclear_bit(WL_STATUS_SCAN_ABORTING, &cfg_priv->status);\r\nbrcmf_debugfs_remove_netdev(cfg_priv);\r\nreturn 0;\r\n}\r\ns32 brcmf_cfg80211_up(struct brcmf_cfg80211_dev *cfg_dev)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv;\r\ns32 err = 0;\r\ncfg_priv = brcmf_priv_get(cfg_dev);\r\nmutex_lock(&cfg_priv->usr_sync);\r\nerr = __brcmf_cfg80211_up(cfg_priv);\r\nmutex_unlock(&cfg_priv->usr_sync);\r\nreturn err;\r\n}\r\ns32 brcmf_cfg80211_down(struct brcmf_cfg80211_dev *cfg_dev)\r\n{\r\nstruct brcmf_cfg80211_priv *cfg_priv;\r\ns32 err = 0;\r\ncfg_priv = brcmf_priv_get(cfg_dev);\r\nmutex_lock(&cfg_priv->usr_sync);\r\nerr = __brcmf_cfg80211_down(cfg_priv);\r\nmutex_unlock(&cfg_priv->usr_sync);\r\nreturn err;\r\n}\r\nstatic __used s32 brcmf_add_ie(struct brcmf_cfg80211_priv *cfg_priv,\r\nu8 t, u8 l, u8 *v)\r\n{\r\nstruct brcmf_cfg80211_ie *ie = &cfg_priv->ie;\r\ns32 err = 0;\r\nif (ie->offset + l + 2 > WL_TLV_INFO_MAX) {\r\nWL_ERR("ei crosses buffer boundary\n");\r\nreturn -ENOSPC;\r\n}\r\nie->buf[ie->offset] = t;\r\nie->buf[ie->offset + 1] = l;\r\nmemcpy(&ie->buf[ie->offset + 2], v, l);\r\nie->offset += l + 2;\r\nreturn err;\r\n}
