int bcm63xx_get_fallback_sprom(struct ssb_bus *bus, struct ssb_sprom *out)\r\n{\r\nif (bus->bustype == SSB_BUSTYPE_PCI) {\r\nmemcpy(out, &bcm63xx_sprom, sizeof(struct ssb_sprom));\r\nreturn 0;\r\n} else {\r\nprintk(KERN_ERR PFX "unable to fill SPROM for given bustype.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nconst char *board_get_name(void)\r\n{\r\nreturn board.name;\r\n}\r\nstatic int board_get_mac_address(u8 *mac)\r\n{\r\nu8 *p;\r\nint count;\r\nif (mac_addr_used >= nvram.mac_addr_count) {\r\nprintk(KERN_ERR PFX "not enough mac address\n");\r\nreturn -ENODEV;\r\n}\r\nmemcpy(mac, nvram.mac_addr_base, ETH_ALEN);\r\np = mac + ETH_ALEN - 1;\r\ncount = mac_addr_used;\r\nwhile (count--) {\r\ndo {\r\n(*p)++;\r\nif (*p != 0)\r\nbreak;\r\np--;\r\n} while (p != mac);\r\n}\r\nif (p == mac) {\r\nprintk(KERN_ERR PFX "unable to fetch mac address\n");\r\nreturn -ENODEV;\r\n}\r\nmac_addr_used++;\r\nreturn 0;\r\n}\r\nvoid __init board_prom_init(void)\r\n{\r\nunsigned int check_len, i;\r\nu8 *boot_addr, *cfe, *p;\r\nchar cfe_version[32];\r\nu32 val;\r\nval = bcm_mpi_readl(MPI_CSBASE_REG(0));\r\nval &= MPI_CSBASE_BASE_MASK;\r\nboot_addr = (u8 *)KSEG1ADDR(val);\r\ncfe = boot_addr + BCM963XX_CFE_VERSION_OFFSET;\r\nif (!memcmp(cfe, "cfe-v", 5))\r\nsnprintf(cfe_version, sizeof(cfe_version), "%u.%u.%u-%u.%u",\r\ncfe[5], cfe[6], cfe[7], cfe[8], cfe[9]);\r\nelse\r\nstrcpy(cfe_version, "unknown");\r\nprintk(KERN_INFO PFX "CFE version: %s\n", cfe_version);\r\nmemcpy(&nvram, boot_addr + BCM963XX_NVRAM_OFFSET, sizeof(nvram));\r\nif (nvram.version <= 4)\r\ncheck_len = offsetof(struct bcm963xx_nvram, checksum_old);\r\nelse\r\ncheck_len = sizeof(nvram);\r\nval = 0;\r\np = (u8 *)&nvram;\r\nwhile (check_len--)\r\nval += *p;\r\nif (val) {\r\nprintk(KERN_ERR PFX "invalid nvram checksum\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(bcm963xx_boards); i++) {\r\nif (strncmp(nvram.name, bcm963xx_boards[i]->name,\r\nsizeof(nvram.name)))\r\ncontinue;\r\nmemcpy(&board, bcm963xx_boards[i], sizeof(board));\r\nbreak;\r\n}\r\nif (!board.name[0]) {\r\nchar name[17];\r\nmemcpy(name, nvram.name, 16);\r\nname[16] = 0;\r\nprintk(KERN_ERR PFX "unknown bcm963xx board: %s\n",\r\nname);\r\nreturn;\r\n}\r\nval = 0;\r\n#ifdef CONFIG_PCI\r\nif (board.has_pci) {\r\nbcm63xx_pci_enabled = 1;\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G2_PCI;\r\n}\r\n#endif\r\nif (board.has_pccard) {\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G1_MII_PCCARD;\r\n}\r\nif (board.has_enet0 && !board.enet0.use_internal_phy) {\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G3_EXT_MII |\r\nGPIO_MODE_6348_G0_EXT_MII;\r\n}\r\nif (board.has_enet1 && !board.enet1.use_internal_phy) {\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G3_EXT_MII |\r\nGPIO_MODE_6348_G0_EXT_MII;\r\n}\r\nbcm_gpio_writel(val, GPIO_MODE_REG);\r\n}\r\nvoid __init board_setup(void)\r\n{\r\nif (!board.name[0])\r\npanic("unable to detect bcm963xx board");\r\nprintk(KERN_INFO PFX "board name: %s\n", board.name);\r\nif (bcm63xx_get_cpu_id() != board.expected_cpu_id)\r\npanic("unexpected CPU for bcm963xx board");\r\n}\r\nint __init board_register_devices(void)\r\n{\r\nu32 val;\r\nif (board.has_uart0)\r\nbcm63xx_uart_register(0);\r\nif (board.has_uart1)\r\nbcm63xx_uart_register(1);\r\nif (board.has_pccard)\r\nbcm63xx_pcmcia_register();\r\nif (board.has_enet0 &&\r\n!board_get_mac_address(board.enet0.mac_addr))\r\nbcm63xx_enet_register(0, &board.enet0);\r\nif (board.has_enet1 &&\r\n!board_get_mac_address(board.enet1.mac_addr))\r\nbcm63xx_enet_register(1, &board.enet1);\r\nif (board.has_dsp)\r\nbcm63xx_dsp_register(&board.dsp);\r\n#ifdef CONFIG_SSB_PCIHOST\r\nif (!board_get_mac_address(bcm63xx_sprom.il0mac)) {\r\nmemcpy(bcm63xx_sprom.et0mac, bcm63xx_sprom.il0mac, ETH_ALEN);\r\nmemcpy(bcm63xx_sprom.et1mac, bcm63xx_sprom.il0mac, ETH_ALEN);\r\nif (ssb_arch_register_fallback_sprom(\r\n&bcm63xx_get_fallback_sprom) < 0)\r\npr_err(PFX "failed to register fallback SPROM\n");\r\n}\r\n#endif\r\nval = bcm_mpi_readl(MPI_CSBASE_REG(0));\r\nval &= MPI_CSBASE_BASE_MASK;\r\nmtd_resources[0].start = val;\r\nmtd_resources[0].end = 0x1FFFFFFF;\r\nplatform_device_register(&mtd_dev);\r\nbcm63xx_led_data.num_leds = ARRAY_SIZE(board.leds);\r\nbcm63xx_led_data.leds = board.leds;\r\nplatform_device_register(&bcm63xx_gpio_leds);\r\nreturn 0;\r\n}
