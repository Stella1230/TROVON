static void hr222_config_akm(struct pcxhr_mgr *mgr, unsigned short data)\r\n{\r\nunsigned short mask = 0x8000;\r\nPCXHR_INPB(mgr, PCXHR_XLX_HIFREQ);\r\nwhile (mask) {\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_DATA,\r\ndata & mask ? PCXHR_DATA_CODEC : 0);\r\nmask >>= 1;\r\n}\r\nPCXHR_INPB(mgr, PCXHR_XLX_RUER);\r\n}\r\nstatic int hr222_set_hw_playback_level(struct pcxhr_mgr *mgr,\r\nint idx, int level)\r\n{\r\nunsigned short cmd;\r\nif (idx > 1 ||\r\nlevel < 0 ||\r\nlevel >= ARRAY_SIZE(g_hr222_p_level))\r\nreturn -EINVAL;\r\nif (idx == 0)\r\ncmd = AKM_LEFT_LEVEL_CMD;\r\nelse\r\ncmd = AKM_RIGHT_LEVEL_CMD;\r\ncmd += g_hr222_p_level[level];\r\nhr222_config_akm(mgr, cmd);\r\nreturn 0;\r\n}\r\nstatic int hr222_set_hw_capture_level(struct pcxhr_mgr *mgr,\r\nint level_l, int level_r, int level_mic)\r\n{\r\nunsigned int data;\r\nint i;\r\nif (!mgr->capture_chips)\r\nreturn -EINVAL;\r\ndata = ((level_mic & 0xff) << 24);\r\ndata |= ((level_mic & 0xff) << 16);\r\ndata |= ((level_r & 0xff) << 8);\r\ndata |= (level_l & 0xff);\r\nPCXHR_INPB(mgr, PCXHR_XLX_DATA);\r\nfor (i = 0; i < 32; i++, data <<= 1) {\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_DATA,\r\n(data & 0x80000000) ? PCXHR_DATA_CODEC : 0);\r\n}\r\nPCXHR_INPB(mgr, PCXHR_XLX_RUER);\r\nreturn 0;\r\n}\r\nint hr222_sub_init(struct pcxhr_mgr *mgr)\r\n{\r\nunsigned char reg;\r\nmgr->board_has_analog = 1;\r\nmgr->xlx_cfg = PCXHR_CFG_SYNCDSP_MASK;\r\nreg = PCXHR_INPB(mgr, PCXHR_XLX_STATUS);\r\nif (reg & PCXHR_STAT_MIC_CAPS)\r\nmgr->board_has_mic = 1;\r\nsnd_printdd("MIC input available = %d\n", mgr->board_has_mic);\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_RESET,\r\nPCXHR_DSP_RESET_DSP);\r\nmsleep(5);\r\nmgr->dsp_reset = PCXHR_DSP_RESET_DSP |\r\nPCXHR_DSP_RESET_MUTE |\r\nPCXHR_DSP_RESET_CODEC;\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, mgr->dsp_reset);\r\nmsleep(5);\r\nhr222_config_akm(mgr, AKM_POWER_CONTROL_CMD);\r\nhr222_config_akm(mgr, AKM_CLOCK_INF_55K_CMD);\r\nhr222_config_akm(mgr, AKM_UNMUTE_CMD);\r\nhr222_config_akm(mgr, AKM_RESET_OFF_CMD);\r\nhr222_micro_boost(mgr, 0);\r\nreturn 0;\r\n}\r\nstatic int hr222_pll_freq_register(unsigned int freq,\r\nunsigned int *pllreg,\r\nunsigned int *realfreq)\r\n{\r\nunsigned int reg;\r\nif (freq < 6900 || freq > 219000)\r\nreturn -EINVAL;\r\nreg = (28224000 * 2) / freq;\r\nreg = (reg - 1) / 2;\r\nif (reg < 0x100)\r\n*pllreg = reg + 0xC00;\r\nelse if (reg < 0x200)\r\n*pllreg = reg + 0x800;\r\nelse if (reg < 0x400)\r\n*pllreg = reg & 0x1ff;\r\nelse if (reg < 0x800) {\r\n*pllreg = ((reg >> 1) & 0x1ff) + 0x200;\r\nreg &= ~1;\r\n} else {\r\n*pllreg = ((reg >> 2) & 0x1ff) + 0x400;\r\nreg &= ~3;\r\n}\r\nif (realfreq)\r\n*realfreq = (28224000 / (reg + 1));\r\nreturn 0;\r\n}\r\nint hr222_sub_set_clock(struct pcxhr_mgr *mgr,\r\nunsigned int rate,\r\nint *changed)\r\n{\r\nunsigned int speed, pllreg = 0;\r\nint err;\r\nunsigned realfreq = rate;\r\nswitch (mgr->use_clock_type) {\r\ncase HR22_CLOCK_TYPE_INTERNAL:\r\nerr = hr222_pll_freq_register(rate, &pllreg, &realfreq);\r\nif (err)\r\nreturn err;\r\nmgr->xlx_cfg &= ~(PCXHR_CFG_CLOCKIN_SEL_MASK |\r\nPCXHR_CFG_CLOCK_UER1_SEL_MASK);\r\nbreak;\r\ncase HR22_CLOCK_TYPE_AES_SYNC:\r\nmgr->xlx_cfg |= PCXHR_CFG_CLOCKIN_SEL_MASK;\r\nmgr->xlx_cfg &= ~PCXHR_CFG_CLOCK_UER1_SEL_MASK;\r\nbreak;\r\ncase HR22_CLOCK_TYPE_AES_1:\r\nif (!mgr->board_has_aes1)\r\nreturn -EINVAL;\r\nmgr->xlx_cfg |= (PCXHR_CFG_CLOCKIN_SEL_MASK |\r\nPCXHR_CFG_CLOCK_UER1_SEL_MASK);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nhr222_config_akm(mgr, AKM_MUTE_CMD);\r\nif (mgr->use_clock_type == HR22_CLOCK_TYPE_INTERNAL) {\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_HIFREQ, pllreg >> 8);\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_LOFREQ, pllreg & 0xff);\r\n}\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_CFG, mgr->xlx_cfg);\r\nspeed = rate < 55000 ? 0 : 1;\r\nif (mgr->codec_speed != speed) {\r\nmgr->codec_speed = speed;\r\nif (speed == 0)\r\nhr222_config_akm(mgr, AKM_CLOCK_INF_55K_CMD);\r\nelse\r\nhr222_config_akm(mgr, AKM_CLOCK_SUP_55K_CMD);\r\n}\r\nmgr->sample_rate_real = realfreq;\r\nmgr->cur_clock_type = mgr->use_clock_type;\r\nif (changed)\r\n*changed = 1;\r\nhr222_config_akm(mgr, AKM_UNMUTE_CMD);\r\nsnd_printdd("set_clock to %dHz (realfreq=%d pllreg=%x)\n",\r\nrate, realfreq, pllreg);\r\nreturn 0;\r\n}\r\nint hr222_get_external_clock(struct pcxhr_mgr *mgr,\r\nenum pcxhr_clock_type clock_type,\r\nint *sample_rate)\r\n{\r\nint rate, calc_rate = 0;\r\nunsigned int ticks;\r\nunsigned char mask, reg;\r\nif (clock_type == HR22_CLOCK_TYPE_AES_SYNC) {\r\nmask = (PCXHR_SUER_CLOCK_PRESENT_MASK |\r\nPCXHR_SUER_DATA_PRESENT_MASK);\r\nreg = PCXHR_STAT_FREQ_SYNC_MASK;\r\n} else if (clock_type == HR22_CLOCK_TYPE_AES_1 && mgr->board_has_aes1) {\r\nmask = (PCXHR_SUER1_CLOCK_PRESENT_MASK |\r\nPCXHR_SUER1_DATA_PRESENT_MASK);\r\nreg = PCXHR_STAT_FREQ_UER1_MASK;\r\n} else {\r\nsnd_printdd("get_external_clock : type %d not supported\n",\r\nclock_type);\r\nreturn -EINVAL;\r\n}\r\nif ((PCXHR_INPB(mgr, PCXHR_XLX_CSUER) & mask) != mask) {\r\nsnd_printdd("get_external_clock(%d) = 0 Hz\n", clock_type);\r\n*sample_rate = 0;\r\nreturn 0;\r\n}\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_STATUS, reg);\r\nreg |= PCXHR_STAT_FREQ_SAVE_MASK;\r\nif (mgr->last_reg_stat != reg) {\r\nudelay(500);\r\nmgr->last_reg_stat = reg;\r\n}\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_STATUS, reg);\r\nticks = (unsigned int)PCXHR_INPB(mgr, PCXHR_XLX_CFG);\r\nticks = (ticks & 0x03) << 8;\r\nticks |= (unsigned int)PCXHR_INPB(mgr, PCXHR_DSP_RESET);\r\nif (ticks != 0)\r\ncalc_rate = 28224000 / ticks;\r\nif (calc_rate > 184200)\r\nrate = 192000;\r\nelse if (calc_rate > 152200)\r\nrate = 176400;\r\nelse if (calc_rate > 112000)\r\nrate = 128000;\r\nelse if (calc_rate > 92100)\r\nrate = 96000;\r\nelse if (calc_rate > 76100)\r\nrate = 88200;\r\nelse if (calc_rate > 56000)\r\nrate = 64000;\r\nelse if (calc_rate > 46050)\r\nrate = 48000;\r\nelse if (calc_rate > 38050)\r\nrate = 44100;\r\nelse if (calc_rate > 28000)\r\nrate = 32000;\r\nelse if (calc_rate > 23025)\r\nrate = 24000;\r\nelse if (calc_rate > 19025)\r\nrate = 22050;\r\nelse if (calc_rate > 14000)\r\nrate = 16000;\r\nelse if (calc_rate > 11512)\r\nrate = 12000;\r\nelse if (calc_rate > 9512)\r\nrate = 11025;\r\nelse if (calc_rate > 7000)\r\nrate = 8000;\r\nelse\r\nrate = 0;\r\nsnd_printdd("External clock is at %d Hz (measured %d Hz)\n",\r\nrate, calc_rate);\r\n*sample_rate = rate;\r\nreturn 0;\r\n}\r\nint hr222_read_gpio(struct pcxhr_mgr *mgr, int is_gpi, int *value)\r\n{\r\nif (is_gpi) {\r\nunsigned char reg = PCXHR_INPB(mgr, PCXHR_XLX_STATUS);\r\n*value = (int)(reg & PCXHR_STAT_GPI_MASK) >>\r\nPCXHR_STAT_GPI_OFFSET;\r\n} else {\r\n*value = (int)(mgr->dsp_reset & PCXHR_DSP_RESET_GPO_MASK) >>\r\nPCXHR_DSP_RESET_GPO_OFFSET;\r\n}\r\nreturn 0;\r\n}\r\nint hr222_write_gpo(struct pcxhr_mgr *mgr, int value)\r\n{\r\nunsigned char reg = mgr->dsp_reset & ~PCXHR_DSP_RESET_GPO_MASK;\r\nreg |= (unsigned char)(value << PCXHR_DSP_RESET_GPO_OFFSET) &\r\nPCXHR_DSP_RESET_GPO_MASK;\r\nPCXHR_OUTPB(mgr, PCXHR_DSP_RESET, reg);\r\nmgr->dsp_reset = reg;\r\nreturn 0;\r\n}\r\nint hr222_update_analog_audio_level(struct snd_pcxhr *chip,\r\nint is_capture, int channel)\r\n{\r\nsnd_printdd("hr222_update_analog_audio_level(%s chan=%d)\n",\r\nis_capture ? "capture" : "playback", channel);\r\nif (is_capture) {\r\nint level_l, level_r, level_mic;\r\nif (chip->analog_capture_active) {\r\nlevel_l = chip->analog_capture_volume[0];\r\nlevel_r = chip->analog_capture_volume[1];\r\n} else {\r\nlevel_l = HR222_LINE_CAPTURE_LEVEL_MIN;\r\nlevel_r = HR222_LINE_CAPTURE_LEVEL_MIN;\r\n}\r\nif (chip->mic_active)\r\nlevel_mic = chip->mic_volume;\r\nelse\r\nlevel_mic = HR222_MICRO_CAPTURE_LEVEL_MIN;\r\nreturn hr222_set_hw_capture_level(chip->mgr,\r\nlevel_l, level_r, level_mic);\r\n} else {\r\nint vol;\r\nif (chip->analog_playback_active[channel])\r\nvol = chip->analog_playback_volume[channel];\r\nelse\r\nvol = HR222_LINE_PLAYBACK_LEVEL_MIN;\r\nreturn hr222_set_hw_playback_level(chip->mgr, channel, vol);\r\n}\r\n}\r\nint hr222_set_audio_source(struct snd_pcxhr *chip)\r\n{\r\nint digital = 0;\r\nchip->mgr->xlx_cfg &= ~(PCXHR_CFG_SRC_MASK |\r\nPCXHR_CFG_DATAIN_SEL_MASK |\r\nPCXHR_CFG_DATA_UER1_SEL_MASK);\r\nif (chip->audio_capture_source == SOURCE_DIGISRC) {\r\nchip->mgr->xlx_cfg |= PCXHR_CFG_SRC_MASK;\r\ndigital = 1;\r\n} else {\r\nif (chip->audio_capture_source == SOURCE_DIGITAL)\r\ndigital = 1;\r\n}\r\nif (digital) {\r\nchip->mgr->xlx_cfg |= PCXHR_CFG_DATAIN_SEL_MASK;\r\nif (chip->mgr->board_has_aes1) {\r\nchip->mgr->xlx_cfg |= PCXHR_CFG_DATA_UER1_SEL_MASK;\r\n}\r\n} else {\r\nint update_lvl = 0;\r\nchip->analog_capture_active = 0;\r\nchip->mic_active = 0;\r\nif (chip->audio_capture_source == SOURCE_LINE ||\r\nchip->audio_capture_source == SOURCE_LINEMIC) {\r\nif (chip->analog_capture_active == 0)\r\nupdate_lvl = 1;\r\nchip->analog_capture_active = 1;\r\n}\r\nif (chip->audio_capture_source == SOURCE_MIC ||\r\nchip->audio_capture_source == SOURCE_LINEMIC) {\r\nif (chip->mic_active == 0)\r\nupdate_lvl = 1;\r\nchip->mic_active = 1;\r\n}\r\nif (update_lvl) {\r\nhr222_update_analog_audio_level(chip, 1, 0);\r\n}\r\n}\r\nPCXHR_OUTPB(chip->mgr, PCXHR_XLX_CFG, chip->mgr->xlx_cfg);\r\nreturn 0;\r\n}\r\nint hr222_iec958_capture_byte(struct snd_pcxhr *chip,\r\nint aes_idx, unsigned char *aes_bits)\r\n{\r\nunsigned char idx = (unsigned char)(aes_idx * 8);\r\nunsigned char temp = 0;\r\nunsigned char mask = chip->mgr->board_has_aes1 ?\r\nPCXHR_SUER1_BIT_C_READ_MASK : PCXHR_SUER_BIT_C_READ_MASK;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nPCXHR_OUTPB(chip->mgr, PCXHR_XLX_RUER, idx++);\r\ntemp <<= 1;\r\nif (PCXHR_INPB(chip->mgr, PCXHR_XLX_CSUER) & mask)\r\ntemp |= 1;\r\n}\r\nsnd_printdd("read iec958 AES %d byte %d = 0x%x\n",\r\nchip->chip_idx, aes_idx, temp);\r\n*aes_bits = temp;\r\nreturn 0;\r\n}\r\nint hr222_iec958_update_byte(struct snd_pcxhr *chip,\r\nint aes_idx, unsigned char aes_bits)\r\n{\r\nint i;\r\nunsigned char new_bits = aes_bits;\r\nunsigned char old_bits = chip->aes_bits[aes_idx];\r\nunsigned char idx = (unsigned char)(aes_idx * 8);\r\nfor (i = 0; i < 8; i++) {\r\nif ((old_bits & 0x01) != (new_bits & 0x01)) {\r\nPCXHR_OUTPB(chip->mgr, PCXHR_XLX_RUER, idx);\r\nPCXHR_OUTPB(chip->mgr, PCXHR_XLX_CSUER, new_bits&0x01 ?\r\nPCXHR_SUER_BIT_C_WRITE_MASK : 0);\r\n}\r\nidx++;\r\nold_bits >>= 1;\r\nnew_bits >>= 1;\r\n}\r\nchip->aes_bits[aes_idx] = aes_bits;\r\nreturn 0;\r\n}\r\nstatic void hr222_micro_boost(struct pcxhr_mgr *mgr, int level)\r\n{\r\nunsigned char boost_mask;\r\nboost_mask = (unsigned char) (level << PCXHR_SELMIC_PREAMPLI_OFFSET);\r\nif (boost_mask & (~PCXHR_SELMIC_PREAMPLI_MASK))\r\nreturn;\r\nmgr->xlx_selmic &= ~PCXHR_SELMIC_PREAMPLI_MASK;\r\nmgr->xlx_selmic |= boost_mask;\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_SELMIC, mgr->xlx_selmic);\r\nsnd_printdd("hr222_micro_boost : set %x\n", boost_mask);\r\n}\r\nstatic void hr222_phantom_power(struct pcxhr_mgr *mgr, int power)\r\n{\r\nif (power)\r\nmgr->xlx_selmic |= PCXHR_SELMIC_PHANTOM_ALIM;\r\nelse\r\nmgr->xlx_selmic &= ~PCXHR_SELMIC_PHANTOM_ALIM;\r\nPCXHR_OUTPB(mgr, PCXHR_XLX_SELMIC, mgr->xlx_selmic);\r\nsnd_printdd("hr222_phantom_power : set %d\n", power);\r\n}\r\nstatic int hr222_mic_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = HR222_MICRO_CAPTURE_LEVEL_MIN;\r\nuinfo->value.integer.max = HR222_MICRO_CAPTURE_LEVEL_MAX;\r\nreturn 0;\r\n}\r\nstatic int hr222_mic_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->mic_volume;\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int hr222_mic_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (chip->mic_volume != ucontrol->value.integer.value[0]) {\r\nchanged = 1;\r\nchip->mic_volume = ucontrol->value.integer.value[0];\r\nhr222_update_analog_audio_level(chip, 1, 0);\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int hr222_mic_boost_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 3;\r\nreturn 0;\r\n}\r\nstatic int hr222_mic_boost_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->mic_boost;\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int hr222_mic_boost_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (chip->mic_boost != ucontrol->value.integer.value[0]) {\r\nchanged = 1;\r\nchip->mic_boost = ucontrol->value.integer.value[0];\r\nhr222_micro_boost(chip->mgr, chip->mic_boost);\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int hr222_phantom_power_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->phantom_power;\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int hr222_phantom_power_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint power, changed = 0;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\npower = !!ucontrol->value.integer.value[0];\r\nif (chip->phantom_power != power) {\r\nhr222_phantom_power(chip->mgr, power);\r\nchip->phantom_power = power;\r\nchanged = 1;\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nint hr222_add_mic_controls(struct snd_pcxhr *chip)\r\n{\r\nint err;\r\nif (!chip->mgr->board_has_mic)\r\nreturn 0;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_control_mic_level,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_control_mic_boost,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&hr222_phantom_power_switch,\r\nchip));\r\nreturn err;\r\n}
