static void musb_do_idle(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nunsigned long flags;\r\nu8 power;\r\nu8 devctl;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->state) {\r\ncase OTG_STATE_A_WAIT_BCON:\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\n} else {\r\nmusb->xceiv->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\n}\r\nbreak;\r\ncase OTG_STATE_A_SUSPEND:\r\nif (musb->port1_status & MUSB_PORT_STAT_RESUME) {\r\npower = musb_readb(musb->mregs, MUSB_POWER);\r\npower &= ~MUSB_POWER_RESUME;\r\ndev_dbg(musb->controller, "root port resume stopped, power %02x\n", power);\r\nmusb_writeb(musb->mregs, MUSB_POWER, power);\r\nmusb->is_active = 1;\r\nmusb->port1_status &= ~(USB_PORT_STAT_SUSPEND\r\n| MUSB_PORT_STAT_RESUME);\r\nmusb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;\r\nusb_hcd_poll_rh_status(musb_to_hcd(musb));\r\nmusb->xceiv->state = OTG_STATE_A_HOST;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE)\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\nelse\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_BCON;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic void omap2430_musb_try_idle(struct musb *musb, unsigned long timeout)\r\n{\r\nunsigned long default_timeout = jiffies + msecs_to_jiffies(3);\r\nstatic unsigned long last_timer;\r\nif (timeout == 0)\r\ntimeout = default_timeout;\r\nif (musb->is_active || ((musb->a_wait_bcon == 0)\r\n&& (musb->xceiv->state == OTG_STATE_A_WAIT_BCON))) {\r\ndev_dbg(musb->controller, "%s active, deleting timer\n",\r\notg_state_string(musb->xceiv->state));\r\ndel_timer(&musb_idle_timer);\r\nlast_timer = jiffies;\r\nreturn;\r\n}\r\nif (time_after(last_timer, timeout)) {\r\nif (!timer_pending(&musb_idle_timer))\r\nlast_timer = timeout;\r\nelse {\r\ndev_dbg(musb->controller, "Longer idle timer already pending, ignoring\n");\r\nreturn;\r\n}\r\n}\r\nlast_timer = timeout;\r\ndev_dbg(musb->controller, "%s inactive, for idle timer for %lu ms\n",\r\notg_state_string(musb->xceiv->state),\r\n(unsigned long)jiffies_to_msecs(timeout - jiffies));\r\nmod_timer(&musb_idle_timer, timeout);\r\n}\r\nstatic void omap2430_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nu8 devctl;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nint ret = 1;\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (is_on) {\r\nif (musb->xceiv->state == OTG_STATE_A_IDLE) {\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nwhile (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(musb->controller,\r\n"configured as A device timeout");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (ret && otg->set_vbus)\r\notg_set_vbus(otg, 1);\r\n} else {\r\nmusb->is_active = 1;\r\notg->default_a = 1;\r\nmusb->xceiv->state = OTG_STATE_A_WAIT_VRISE;\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nMUSB_HST_MODE(musb);\r\n}\r\n} else {\r\nmusb->is_active = 0;\r\notg->default_a = 0;\r\nmusb->xceiv->state = OTG_STATE_B_IDLE;\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\nMUSB_DEV_MODE(musb);\r\n}\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\ndev_dbg(musb->controller, "VBUS %s, devctl %02x "\r\n"\n",\r\notg_state_string(musb->xceiv->state),\r\nmusb_readb(musb->mregs, MUSB_DEVCTL));\r\n}\r\nstatic int omap2430_musb_set_mode(struct musb *musb, u8 musb_mode)\r\n{\r\nu8 devctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nreturn 0;\r\n}\r\nstatic inline void omap2430_low_level_exit(struct musb *musb)\r\n{\r\nu32 l;\r\nl = musb_readl(musb->mregs, OTG_FORCESTDBY);\r\nl |= ENABLEFORCE;\r\nmusb_writel(musb->mregs, OTG_FORCESTDBY, l);\r\n}\r\nstatic inline void omap2430_low_level_init(struct musb *musb)\r\n{\r\nu32 l;\r\nl = musb_readl(musb->mregs, OTG_FORCESTDBY);\r\nl &= ~ENABLEFORCE;\r\nmusb_writel(musb->mregs, OTG_FORCESTDBY, l);\r\n}\r\nstatic int musb_otg_notifications(struct notifier_block *nb,\r\nunsigned long event, void *unused)\r\n{\r\nstruct musb *musb = container_of(nb, struct musb, nb);\r\nmusb->xceiv_event = event;\r\nschedule_work(&musb->otg_notifier_work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void musb_otg_notifier_work(struct work_struct *data_notifier_work)\r\n{\r\nstruct musb *musb = container_of(data_notifier_work, struct musb, otg_notifier_work);\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *pdata = dev->platform_data;\r\nstruct omap_musb_board_data *data = pdata->board_data;\r\nswitch (musb->xceiv_event) {\r\ncase USB_EVENT_ID:\r\ndev_dbg(musb->controller, "ID GND\n");\r\nif (!is_otg_enabled(musb) || musb->gadget_driver) {\r\npm_runtime_get_sync(musb->controller);\r\nusb_phy_init(musb->xceiv);\r\nomap2430_musb_set_vbus(musb, 1);\r\n}\r\nbreak;\r\ncase USB_EVENT_VBUS:\r\ndev_dbg(musb->controller, "VBUS Connect\n");\r\nif (musb->gadget_driver)\r\npm_runtime_get_sync(musb->controller);\r\nusb_phy_init(musb->xceiv);\r\nbreak;\r\ncase USB_EVENT_NONE:\r\ndev_dbg(musb->controller, "VBUS Disconnect\n");\r\nif (is_otg_enabled(musb) || is_peripheral_enabled(musb))\r\nif (musb->gadget_driver) {\r\npm_runtime_mark_last_busy(musb->controller);\r\npm_runtime_put_autosuspend(musb->controller);\r\n}\r\nif (data->interface_type == MUSB_INTERFACE_UTMI) {\r\nif (musb->xceiv->otg->set_vbus)\r\notg_set_vbus(musb->xceiv->otg, 0);\r\n}\r\nusb_phy_shutdown(musb->xceiv);\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "ID float\n");\r\n}\r\n}\r\nstatic int omap2430_musb_init(struct musb *musb)\r\n{\r\nu32 l;\r\nint status = 0;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *plat = dev->platform_data;\r\nstruct omap_musb_board_data *data = plat->board_data;\r\nmusb->xceiv = usb_get_transceiver();\r\nif (!musb->xceiv) {\r\npr_err("HS USB OTG: no transceiver configured\n");\r\nreturn -ENODEV;\r\n}\r\nINIT_WORK(&musb->otg_notifier_work, musb_otg_notifier_work);\r\nstatus = pm_runtime_get_sync(dev);\r\nif (status < 0) {\r\ndev_err(dev, "pm_runtime_get_sync FAILED %d\n", status);\r\ngoto err1;\r\n}\r\nl = musb_readl(musb->mregs, OTG_INTERFSEL);\r\nif (data->interface_type == MUSB_INTERFACE_UTMI) {\r\nl &= ~ULPI_12PIN;\r\nl |= UTMI_8BIT;\r\n} else {\r\nl |= ULPI_12PIN;\r\n}\r\nmusb_writel(musb->mregs, OTG_INTERFSEL, l);\r\npr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "\r\n"sysstatus 0x%x, intrfsel 0x%x, simenable 0x%x\n",\r\nmusb_readl(musb->mregs, OTG_REVISION),\r\nmusb_readl(musb->mregs, OTG_SYSCONFIG),\r\nmusb_readl(musb->mregs, OTG_SYSSTATUS),\r\nmusb_readl(musb->mregs, OTG_INTERFSEL),\r\nmusb_readl(musb->mregs, OTG_SIMENABLE));\r\nmusb->nb.notifier_call = musb_otg_notifications;\r\nstatus = usb_register_notifier(musb->xceiv, &musb->nb);\r\nif (status)\r\ndev_dbg(musb->controller, "notification register failed\n");\r\nsetup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);\r\npm_runtime_put_noidle(musb->controller);\r\nreturn 0;\r\nerr1:\r\nreturn status;\r\n}\r\nstatic void omap2430_musb_enable(struct musb *musb)\r\n{\r\nu8 devctl;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *pdata = dev->platform_data;\r\nstruct omap_musb_board_data *data = pdata->board_data;\r\nswitch (musb->xceiv->last_event) {\r\ncase USB_EVENT_ID:\r\nusb_phy_init(musb->xceiv);\r\nif (data->interface_type != MUSB_INTERFACE_UTMI)\r\nbreak;\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\r\nwhile (musb_readb(musb->mregs, MUSB_DEVCTL) &\r\nMUSB_DEVCTL_BDEVICE) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(dev, "configured as A device timeout");\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase USB_EVENT_VBUS:\r\nusb_phy_init(musb->xceiv);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void omap2430_musb_disable(struct musb *musb)\r\n{\r\nif (musb->xceiv->last_event)\r\nusb_phy_shutdown(musb->xceiv);\r\n}\r\nstatic int omap2430_musb_exit(struct musb *musb)\r\n{\r\ndel_timer_sync(&musb_idle_timer);\r\ncancel_work_sync(&musb->otg_notifier_work);\r\nomap2430_low_level_exit(musb);\r\nusb_put_transceiver(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic int __devinit omap2430_probe(struct platform_device *pdev)\r\n{\r\nstruct musb_hdrc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct platform_device *musb;\r\nstruct omap2430_glue *glue;\r\nint ret = -ENOMEM;\r\nglue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nif (!glue) {\r\ndev_err(&pdev->dev, "failed to allocate glue context\n");\r\ngoto err0;\r\n}\r\nmusb = platform_device_alloc("musb-hdrc", -1);\r\nif (!musb) {\r\ndev_err(&pdev->dev, "failed to allocate musb device\n");\r\ngoto err1;\r\n}\r\nmusb->dev.parent = &pdev->dev;\r\nmusb->dev.dma_mask = &omap2430_dmamask;\r\nmusb->dev.coherent_dma_mask = omap2430_dmamask;\r\nglue->dev = &pdev->dev;\r\nglue->musb = musb;\r\npdata->platform_ops = &omap2430_ops;\r\nplatform_set_drvdata(pdev, glue);\r\nret = platform_device_add_resources(musb, pdev->resource,\r\npdev->num_resources);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add resources\n");\r\ngoto err2;\r\n}\r\nret = platform_device_add_data(musb, pdata, sizeof(*pdata));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add platform_data\n");\r\ngoto err2;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device\n");\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nplatform_device_put(musb);\r\nerr1:\r\nkfree(glue);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int __devexit omap2430_remove(struct platform_device *pdev)\r\n{\r\nstruct omap2430_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_del(glue->musb);\r\nplatform_device_put(glue->musb);\r\nkfree(glue);\r\nreturn 0;\r\n}\r\nstatic int omap2430_runtime_suspend(struct device *dev)\r\n{\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nif (musb) {\r\nmusb->context.otg_interfsel = musb_readl(musb->mregs,\r\nOTG_INTERFSEL);\r\nomap2430_low_level_exit(musb);\r\nusb_phy_set_suspend(musb->xceiv, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap2430_runtime_resume(struct device *dev)\r\n{\r\nstruct omap2430_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nif (musb) {\r\nomap2430_low_level_init(musb);\r\nmusb_writel(musb->mregs, OTG_INTERFSEL,\r\nmusb->context.otg_interfsel);\r\nusb_phy_set_suspend(musb->xceiv, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init omap2430_init(void)\r\n{\r\nreturn platform_driver_register(&omap2430_driver);\r\n}\r\nstatic void __exit omap2430_exit(void)\r\n{\r\nplatform_driver_unregister(&omap2430_driver);\r\n}
