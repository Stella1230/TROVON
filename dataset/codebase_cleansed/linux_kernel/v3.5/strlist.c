static struct str_node *str_node__new(const char *s, bool dupstr)\r\n{\r\nstruct str_node *self = malloc(sizeof(*self));\r\nif (self != NULL) {\r\nif (dupstr) {\r\ns = strdup(s);\r\nif (s == NULL)\r\ngoto out_delete;\r\n}\r\nself->s = s;\r\n}\r\nreturn self;\r\nout_delete:\r\nfree(self);\r\nreturn NULL;\r\n}\r\nstatic void str_node__delete(struct str_node *self, bool dupstr)\r\n{\r\nif (dupstr)\r\nfree((void *)self->s);\r\nfree(self);\r\n}\r\nint strlist__add(struct strlist *self, const char *new_entry)\r\n{\r\nstruct rb_node **p = &self->entries.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct str_node *sn;\r\nwhile (*p != NULL) {\r\nint rc;\r\nparent = *p;\r\nsn = rb_entry(parent, struct str_node, rb_node);\r\nrc = strcmp(sn->s, new_entry);\r\nif (rc > 0)\r\np = &(*p)->rb_left;\r\nelse if (rc < 0)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nsn = str_node__new(new_entry, self->dupstr);\r\nif (sn == NULL)\r\nreturn -ENOMEM;\r\nrb_link_node(&sn->rb_node, parent, p);\r\nrb_insert_color(&sn->rb_node, &self->entries);\r\n++self->nr_entries;\r\nreturn 0;\r\n}\r\nint strlist__load(struct strlist *self, const char *filename)\r\n{\r\nchar entry[1024];\r\nint err;\r\nFILE *fp = fopen(filename, "r");\r\nif (fp == NULL)\r\nreturn errno;\r\nwhile (fgets(entry, sizeof(entry), fp) != NULL) {\r\nconst size_t len = strlen(entry);\r\nif (len == 0)\r\ncontinue;\r\nentry[len - 1] = '\0';\r\nerr = strlist__add(self, entry);\r\nif (err != 0)\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nfclose(fp);\r\nreturn err;\r\n}\r\nvoid strlist__remove(struct strlist *self, struct str_node *sn)\r\n{\r\nrb_erase(&sn->rb_node, &self->entries);\r\nstr_node__delete(sn, self->dupstr);\r\n}\r\nstruct str_node *strlist__find(struct strlist *self, const char *entry)\r\n{\r\nstruct rb_node **p = &self->entries.rb_node;\r\nstruct rb_node *parent = NULL;\r\nwhile (*p != NULL) {\r\nstruct str_node *sn;\r\nint rc;\r\nparent = *p;\r\nsn = rb_entry(parent, struct str_node, rb_node);\r\nrc = strcmp(sn->s, entry);\r\nif (rc > 0)\r\np = &(*p)->rb_left;\r\nelse if (rc < 0)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn sn;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int strlist__parse_list_entry(struct strlist *self, const char *s)\r\n{\r\nif (strncmp(s, "file://", 7) == 0)\r\nreturn strlist__load(self, s + 7);\r\nreturn strlist__add(self, s);\r\n}\r\nint strlist__parse_list(struct strlist *self, const char *s)\r\n{\r\nchar *sep;\r\nint err;\r\nwhile ((sep = strchr(s, ',')) != NULL) {\r\n*sep = '\0';\r\nerr = strlist__parse_list_entry(self, s);\r\n*sep = ',';\r\nif (err != 0)\r\nreturn err;\r\ns = sep + 1;\r\n}\r\nreturn *s ? strlist__parse_list_entry(self, s) : 0;\r\n}\r\nstruct strlist *strlist__new(bool dupstr, const char *slist)\r\n{\r\nstruct strlist *self = malloc(sizeof(*self));\r\nif (self != NULL) {\r\nself->entries = RB_ROOT;\r\nself->dupstr = dupstr;\r\nself->nr_entries = 0;\r\nif (slist && strlist__parse_list(self, slist) != 0)\r\ngoto out_error;\r\n}\r\nreturn self;\r\nout_error:\r\nfree(self);\r\nreturn NULL;\r\n}\r\nvoid strlist__delete(struct strlist *self)\r\n{\r\nif (self != NULL) {\r\nstruct str_node *pos;\r\nstruct rb_node *next = rb_first(&self->entries);\r\nwhile (next) {\r\npos = rb_entry(next, struct str_node, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nstrlist__remove(self, pos);\r\n}\r\nself->entries = RB_ROOT;\r\nfree(self);\r\n}\r\n}\r\nstruct str_node *strlist__entry(const struct strlist *self, unsigned int idx)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&self->entries); nd; nd = rb_next(nd)) {\r\nstruct str_node *pos = rb_entry(nd, struct str_node, rb_node);\r\nif (!idx--)\r\nreturn pos;\r\n}\r\nreturn NULL;\r\n}
