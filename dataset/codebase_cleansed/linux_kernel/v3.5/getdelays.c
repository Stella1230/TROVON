static void usage(void)\r\n{\r\nfprintf(stderr, "getdelays [-dilv] [-w logfile] [-r bufsize] "\r\n"[-m cpumask] [-t tgid] [-p pid]\n");\r\nfprintf(stderr, " -d: print delayacct stats\n");\r\nfprintf(stderr, " -i: print IO accounting (works only with -p)\n");\r\nfprintf(stderr, " -l: listen forever\n");\r\nfprintf(stderr, " -v: debug on\n");\r\nfprintf(stderr, " -C: container path\n");\r\n}\r\nstatic int create_nl_socket(int protocol)\r\n{\r\nint fd;\r\nstruct sockaddr_nl local;\r\nfd = socket(AF_NETLINK, SOCK_RAW, protocol);\r\nif (fd < 0)\r\nreturn -1;\r\nif (rcvbufsz)\r\nif (setsockopt(fd, SOL_SOCKET, SO_RCVBUF,\r\n&rcvbufsz, sizeof(rcvbufsz)) < 0) {\r\nfprintf(stderr, "Unable to set socket rcv buf size "\r\n"to %d\n",\r\nrcvbufsz);\r\nreturn -1;\r\n}\r\nmemset(&local, 0, sizeof(local));\r\nlocal.nl_family = AF_NETLINK;\r\nif (bind(fd, (struct sockaddr *) &local, sizeof(local)) < 0)\r\ngoto error;\r\nreturn fd;\r\nerror:\r\nclose(fd);\r\nreturn -1;\r\n}\r\nstatic int send_cmd(int sd, __u16 nlmsg_type, __u32 nlmsg_pid,\r\n__u8 genl_cmd, __u16 nla_type,\r\nvoid *nla_data, int nla_len)\r\n{\r\nstruct nlattr *na;\r\nstruct sockaddr_nl nladdr;\r\nint r, buflen;\r\nchar *buf;\r\nstruct msgtemplate msg;\r\nmsg.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);\r\nmsg.n.nlmsg_type = nlmsg_type;\r\nmsg.n.nlmsg_flags = NLM_F_REQUEST;\r\nmsg.n.nlmsg_seq = 0;\r\nmsg.n.nlmsg_pid = nlmsg_pid;\r\nmsg.g.cmd = genl_cmd;\r\nmsg.g.version = 0x1;\r\nna = (struct nlattr *) GENLMSG_DATA(&msg);\r\nna->nla_type = nla_type;\r\nna->nla_len = nla_len + 1 + NLA_HDRLEN;\r\nmemcpy(NLA_DATA(na), nla_data, nla_len);\r\nmsg.n.nlmsg_len += NLMSG_ALIGN(na->nla_len);\r\nbuf = (char *) &msg;\r\nbuflen = msg.n.nlmsg_len ;\r\nmemset(&nladdr, 0, sizeof(nladdr));\r\nnladdr.nl_family = AF_NETLINK;\r\nwhile ((r = sendto(sd, buf, buflen, 0, (struct sockaddr *) &nladdr,\r\nsizeof(nladdr))) < buflen) {\r\nif (r > 0) {\r\nbuf += r;\r\nbuflen -= r;\r\n} else if (errno != EAGAIN)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_family_id(int sd)\r\n{\r\nstruct {\r\nstruct nlmsghdr n;\r\nstruct genlmsghdr g;\r\nchar buf[256];\r\n} ans;\r\nint id = 0, rc;\r\nstruct nlattr *na;\r\nint rep_len;\r\nstrcpy(name, TASKSTATS_GENL_NAME);\r\nrc = send_cmd(sd, GENL_ID_CTRL, getpid(), CTRL_CMD_GETFAMILY,\r\nCTRL_ATTR_FAMILY_NAME, (void *)name,\r\nstrlen(TASKSTATS_GENL_NAME)+1);\r\nif (rc < 0)\r\nreturn 0;\r\nrep_len = recv(sd, &ans, sizeof(ans), 0);\r\nif (ans.n.nlmsg_type == NLMSG_ERROR ||\r\n(rep_len < 0) || !NLMSG_OK((&ans.n), rep_len))\r\nreturn 0;\r\nna = (struct nlattr *) GENLMSG_DATA(&ans);\r\nna = (struct nlattr *) ((char *) na + NLA_ALIGN(na->nla_len));\r\nif (na->nla_type == CTRL_ATTR_FAMILY_ID) {\r\nid = *(__u16 *) NLA_DATA(na);\r\n}\r\nreturn id;\r\n}\r\nstatic void print_delayacct(struct taskstats *t)\r\n{\r\nprintf("\n\nCPU %15s%15s%15s%15s%15s\n"\r\n" %15llu%15llu%15llu%15llu%15.3fms\n"\r\n"IO %15s%15s%15s\n"\r\n" %15llu%15llu%15llums\n"\r\n"SWAP %15s%15s%15s\n"\r\n" %15llu%15llu%15llums\n"\r\n"RECLAIM %12s%15s%15s\n"\r\n" %15llu%15llu%15llums\n",\r\n"count", "real total", "virtual total",\r\n"delay total", "delay average",\r\n(unsigned long long)t->cpu_count,\r\n(unsigned long long)t->cpu_run_real_total,\r\n(unsigned long long)t->cpu_run_virtual_total,\r\n(unsigned long long)t->cpu_delay_total,\r\naverage_ms((double)t->cpu_delay_total, t->cpu_count),\r\n"count", "delay total", "delay average",\r\n(unsigned long long)t->blkio_count,\r\n(unsigned long long)t->blkio_delay_total,\r\naverage_ms(t->blkio_delay_total, t->blkio_count),\r\n"count", "delay total", "delay average",\r\n(unsigned long long)t->swapin_count,\r\n(unsigned long long)t->swapin_delay_total,\r\naverage_ms(t->swapin_delay_total, t->swapin_count),\r\n"count", "delay total", "delay average",\r\n(unsigned long long)t->freepages_count,\r\n(unsigned long long)t->freepages_delay_total,\r\naverage_ms(t->freepages_delay_total, t->freepages_count));\r\n}\r\nstatic void task_context_switch_counts(struct taskstats *t)\r\n{\r\nprintf("\n\nTask %15s%15s\n"\r\n" %15llu%15llu\n",\r\n"voluntary", "nonvoluntary",\r\n(unsigned long long)t->nvcsw, (unsigned long long)t->nivcsw);\r\n}\r\nstatic void print_cgroupstats(struct cgroupstats *c)\r\n{\r\nprintf("sleeping %llu, blocked %llu, running %llu, stopped %llu, "\r\n"uninterruptible %llu\n", (unsigned long long)c->nr_sleeping,\r\n(unsigned long long)c->nr_io_wait,\r\n(unsigned long long)c->nr_running,\r\n(unsigned long long)c->nr_stopped,\r\n(unsigned long long)c->nr_uninterruptible);\r\n}\r\nstatic void print_ioacct(struct taskstats *t)\r\n{\r\nprintf("%s: read=%llu, write=%llu, cancelled_write=%llu\n",\r\nt->ac_comm,\r\n(unsigned long long)t->read_bytes,\r\n(unsigned long long)t->write_bytes,\r\n(unsigned long long)t->cancelled_write_bytes);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint c, rc, rep_len, aggr_len, len2;\r\nint cmd_type = TASKSTATS_CMD_ATTR_UNSPEC;\r\n__u16 id;\r\n__u32 mypid;\r\nstruct nlattr *na;\r\nint nl_sd = -1;\r\nint len = 0;\r\npid_t tid = 0;\r\npid_t rtid = 0;\r\nint fd = 0;\r\nint count = 0;\r\nint write_file = 0;\r\nint maskset = 0;\r\nchar *logfile = NULL;\r\nint loop = 0;\r\nint containerset = 0;\r\nchar containerpath[1024];\r\nint cfd = 0;\r\nint forking = 0;\r\nsigset_t sigset;\r\nstruct msgtemplate msg;\r\nwhile (!forking) {\r\nc = getopt(argc, argv, "qdiw:r:m:t:p:vlC:c:");\r\nif (c < 0)\r\nbreak;\r\nswitch (c) {\r\ncase 'd':\r\nprintf("print delayacct stats ON\n");\r\nprint_delays = 1;\r\nbreak;\r\ncase 'i':\r\nprintf("printing IO accounting\n");\r\nprint_io_accounting = 1;\r\nbreak;\r\ncase 'q':\r\nprintf("printing task/process context switch rates\n");\r\nprint_task_context_switch_counts = 1;\r\nbreak;\r\ncase 'C':\r\ncontainerset = 1;\r\nstrncpy(containerpath, optarg, strlen(optarg) + 1);\r\nbreak;\r\ncase 'w':\r\nlogfile = strdup(optarg);\r\nprintf("write to file %s\n", logfile);\r\nwrite_file = 1;\r\nbreak;\r\ncase 'r':\r\nrcvbufsz = atoi(optarg);\r\nprintf("receive buf size %d\n", rcvbufsz);\r\nif (rcvbufsz < 0)\r\nerr(1, "Invalid rcv buf size\n");\r\nbreak;\r\ncase 'm':\r\nstrncpy(cpumask, optarg, sizeof(cpumask));\r\nmaskset = 1;\r\nprintf("cpumask %s maskset %d\n", cpumask, maskset);\r\nbreak;\r\ncase 't':\r\ntid = atoi(optarg);\r\nif (!tid)\r\nerr(1, "Invalid tgid\n");\r\ncmd_type = TASKSTATS_CMD_ATTR_TGID;\r\nbreak;\r\ncase 'p':\r\ntid = atoi(optarg);\r\nif (!tid)\r\nerr(1, "Invalid pid\n");\r\ncmd_type = TASKSTATS_CMD_ATTR_PID;\r\nbreak;\r\ncase 'c':\r\nif (sigemptyset(&sigset) == -1)\r\nerr(1, "Failed to empty sigset");\r\nif (sigaddset(&sigset, SIGCHLD))\r\nerr(1, "Failed to set sigchld in sigset");\r\nsigprocmask(SIG_BLOCK, &sigset, NULL);\r\ntid = fork();\r\nif (tid < 0)\r\nerr(1, "Fork failed\n");\r\nif (tid == 0)\r\nif (execvp(argv[optind - 1],\r\n&argv[optind - 1]) < 0)\r\nexit(-1);\r\ncmd_type = TASKSTATS_CMD_ATTR_PID;\r\nforking = 1;\r\nbreak;\r\ncase 'v':\r\nprintf("debug on\n");\r\ndbg = 1;\r\nbreak;\r\ncase 'l':\r\nprintf("listen forever\n");\r\nloop = 1;\r\nbreak;\r\ndefault:\r\nusage();\r\nexit(-1);\r\n}\r\n}\r\nif (write_file) {\r\nfd = open(logfile, O_WRONLY | O_CREAT | O_TRUNC,\r\nS_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\r\nif (fd == -1) {\r\nperror("Cannot open output file\n");\r\nexit(1);\r\n}\r\n}\r\nif ((nl_sd = create_nl_socket(NETLINK_GENERIC)) < 0)\r\nerr(1, "error creating Netlink socket\n");\r\nmypid = getpid();\r\nid = get_family_id(nl_sd);\r\nif (!id) {\r\nfprintf(stderr, "Error getting family id, errno %d\n", errno);\r\ngoto err;\r\n}\r\nPRINTF("family id %d\n", id);\r\nif (maskset) {\r\nrc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\r\nTASKSTATS_CMD_ATTR_REGISTER_CPUMASK,\r\n&cpumask, strlen(cpumask) + 1);\r\nPRINTF("Sent register cpumask, retval %d\n", rc);\r\nif (rc < 0) {\r\nfprintf(stderr, "error sending register cpumask\n");\r\ngoto err;\r\n}\r\n}\r\nif (tid && containerset) {\r\nfprintf(stderr, "Select either -t or -C, not both\n");\r\ngoto err;\r\n}\r\nif (tid && forking) {\r\nint sig_received;\r\nsigwait(&sigset, &sig_received);\r\n}\r\nif (tid) {\r\nrc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\r\ncmd_type, &tid, sizeof(__u32));\r\nPRINTF("Sent pid/tgid, retval %d\n", rc);\r\nif (rc < 0) {\r\nfprintf(stderr, "error sending tid/tgid cmd\n");\r\ngoto done;\r\n}\r\n}\r\nif (containerset) {\r\ncfd = open(containerpath, O_RDONLY);\r\nif (cfd < 0) {\r\nperror("error opening container file");\r\ngoto err;\r\n}\r\nrc = send_cmd(nl_sd, id, mypid, CGROUPSTATS_CMD_GET,\r\nCGROUPSTATS_CMD_ATTR_FD, &cfd, sizeof(__u32));\r\nif (rc < 0) {\r\nperror("error sending cgroupstats command");\r\ngoto err;\r\n}\r\n}\r\nif (!maskset && !tid && !containerset) {\r\nusage();\r\ngoto err;\r\n}\r\ndo {\r\nrep_len = recv(nl_sd, &msg, sizeof(msg), 0);\r\nPRINTF("received %d bytes\n", rep_len);\r\nif (rep_len < 0) {\r\nfprintf(stderr, "nonfatal reply error: errno %d\n",\r\nerrno);\r\ncontinue;\r\n}\r\nif (msg.n.nlmsg_type == NLMSG_ERROR ||\r\n!NLMSG_OK((&msg.n), rep_len)) {\r\nstruct nlmsgerr *err = NLMSG_DATA(&msg);\r\nfprintf(stderr, "fatal reply error, errno %d\n",\r\nerr->error);\r\ngoto done;\r\n}\r\nPRINTF("nlmsghdr size=%zu, nlmsg_len=%d, rep_len=%d\n",\r\nsizeof(struct nlmsghdr), msg.n.nlmsg_len, rep_len);\r\nrep_len = GENLMSG_PAYLOAD(&msg.n);\r\nna = (struct nlattr *) GENLMSG_DATA(&msg);\r\nlen = 0;\r\nwhile (len < rep_len) {\r\nlen += NLA_ALIGN(na->nla_len);\r\nswitch (na->nla_type) {\r\ncase TASKSTATS_TYPE_AGGR_TGID:\r\ncase TASKSTATS_TYPE_AGGR_PID:\r\naggr_len = NLA_PAYLOAD(na->nla_len);\r\nlen2 = 0;\r\nna = (struct nlattr *) NLA_DATA(na);\r\ndone = 0;\r\nwhile (len2 < aggr_len) {\r\nswitch (na->nla_type) {\r\ncase TASKSTATS_TYPE_PID:\r\nrtid = *(int *) NLA_DATA(na);\r\nif (print_delays)\r\nprintf("PID\t%d\n", rtid);\r\nbreak;\r\ncase TASKSTATS_TYPE_TGID:\r\nrtid = *(int *) NLA_DATA(na);\r\nif (print_delays)\r\nprintf("TGID\t%d\n", rtid);\r\nbreak;\r\ncase TASKSTATS_TYPE_STATS:\r\ncount++;\r\nif (print_delays)\r\nprint_delayacct((struct taskstats *) NLA_DATA(na));\r\nif (print_io_accounting)\r\nprint_ioacct((struct taskstats *) NLA_DATA(na));\r\nif (print_task_context_switch_counts)\r\ntask_context_switch_counts((struct taskstats *) NLA_DATA(na));\r\nif (fd) {\r\nif (write(fd, NLA_DATA(na), na->nla_len) < 0) {\r\nerr(1,"write error\n");\r\n}\r\n}\r\nif (!loop)\r\ngoto done;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "Unknown nested"\r\n" nla_type %d\n",\r\nna->nla_type);\r\nbreak;\r\n}\r\nlen2 += NLA_ALIGN(na->nla_len);\r\nna = (struct nlattr *) ((char *) na + len2);\r\n}\r\nbreak;\r\ncase CGROUPSTATS_TYPE_CGROUP_STATS:\r\nprint_cgroupstats(NLA_DATA(na));\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "Unknown nla_type %d\n",\r\nna->nla_type);\r\ncase TASKSTATS_TYPE_NULL:\r\nbreak;\r\n}\r\nna = (struct nlattr *) (GENLMSG_DATA(&msg) + len);\r\n}\r\n} while (loop);\r\ndone:\r\nif (maskset) {\r\nrc = send_cmd(nl_sd, id, mypid, TASKSTATS_CMD_GET,\r\nTASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK,\r\n&cpumask, strlen(cpumask) + 1);\r\nprintf("Sent deregister mask, retval %d\n", rc);\r\nif (rc < 0)\r\nerr(rc, "error sending deregister cpumask\n");\r\n}\r\nerr:\r\nclose(nl_sd);\r\nif (fd)\r\nclose(fd);\r\nif (cfd)\r\nclose(cfd);\r\nreturn 0;\r\n}
