static inline void ipc_command(u32 cmd)\r\n{\r\nwritel(cmd, ipcdev.ipc_base);\r\n}\r\nstatic inline void ipc_data_writel(u32 data, u32 offset)\r\n{\r\nwritel(data, ipcdev.ipc_base + 0x80 + offset);\r\n}\r\nstatic inline u8 ipc_read_status(void)\r\n{\r\nreturn __raw_readl(ipcdev.ipc_base + 0x04);\r\n}\r\nstatic inline u8 ipc_data_readb(u32 offset)\r\n{\r\nreturn readb(ipcdev.ipc_base + IPC_READ_BUFFER + offset);\r\n}\r\nstatic inline u32 ipc_data_readl(u32 offset)\r\n{\r\nreturn readl(ipcdev.ipc_base + IPC_READ_BUFFER + offset);\r\n}\r\nstatic inline int busy_loop(void)\r\n{\r\nu32 status = 0;\r\nu32 loop_count = 0;\r\nstatus = ipc_read_status();\r\nwhile (status & 1) {\r\nudelay(1);\r\nstatus = ipc_read_status();\r\nloop_count++;\r\nif (loop_count > 100000) {\r\ndev_err(&ipcdev.pdev->dev, "IPC timed out");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nif ((status >> 1) & 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int pwr_reg_rdwr(u16 *addr, u8 *data, u32 count, u32 op, u32 id)\r\n{\r\nint nc;\r\nu32 offset = 0;\r\nint err;\r\nu8 cbuf[IPC_WWBUF_SIZE] = { };\r\nu32 *wbuf = (u32 *)&cbuf;\r\nmutex_lock(&ipclock);\r\nmemset(cbuf, 0, sizeof(cbuf));\r\nif (ipcdev.pdev == NULL) {\r\nmutex_unlock(&ipclock);\r\nreturn -ENODEV;\r\n}\r\nfor (nc = 0; nc < count; nc++, offset += 2) {\r\ncbuf[offset] = addr[nc];\r\ncbuf[offset + 1] = addr[nc] >> 8;\r\n}\r\nif (id == IPC_CMD_PCNTRL_R) {\r\nfor (nc = 0, offset = 0; nc < count; nc++, offset += 4)\r\nipc_data_writel(wbuf[nc], offset);\r\nipc_command((count*2) << 16 | id << 12 | 0 << 8 | op);\r\n} else if (id == IPC_CMD_PCNTRL_W) {\r\nfor (nc = 0; nc < count; nc++, offset += 1)\r\ncbuf[offset] = data[nc];\r\nfor (nc = 0, offset = 0; nc < count; nc++, offset += 4)\r\nipc_data_writel(wbuf[nc], offset);\r\nipc_command((count*3) << 16 | id << 12 | 0 << 8 | op);\r\n} else if (id == IPC_CMD_PCNTRL_M) {\r\ncbuf[offset] = data[0];\r\ncbuf[offset + 1] = data[1];\r\nipc_data_writel(wbuf[0], 0);\r\nipc_command(4 << 16 | id << 12 | 0 << 8 | op);\r\n}\r\nerr = busy_loop();\r\nif (id == IPC_CMD_PCNTRL_R) {\r\nmemcpy_fromio(cbuf, ipcdev.ipc_base + 0x90, 16);\r\nfor (nc = 0; nc < count; nc++)\r\ndata[nc] = ipc_data_readb(nc);\r\n}\r\nmutex_unlock(&ipclock);\r\nreturn err;\r\n}\r\nint intel_scu_ipc_ioread8(u16 addr, u8 *data)\r\n{\r\nreturn pwr_reg_rdwr(&addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);\r\n}\r\nint intel_scu_ipc_ioread16(u16 addr, u16 *data)\r\n{\r\nu16 x[2] = {addr, addr + 1 };\r\nreturn pwr_reg_rdwr(x, (u8 *)data, 2, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);\r\n}\r\nint intel_scu_ipc_ioread32(u16 addr, u32 *data)\r\n{\r\nu16 x[4] = {addr, addr + 1, addr + 2, addr + 3};\r\nreturn pwr_reg_rdwr(x, (u8 *)data, 4, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);\r\n}\r\nint intel_scu_ipc_iowrite8(u16 addr, u8 data)\r\n{\r\nreturn pwr_reg_rdwr(&addr, &data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);\r\n}\r\nint intel_scu_ipc_iowrite16(u16 addr, u16 data)\r\n{\r\nu16 x[2] = {addr, addr + 1 };\r\nreturn pwr_reg_rdwr(x, (u8 *)&data, 2, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);\r\n}\r\nint intel_scu_ipc_iowrite32(u16 addr, u32 data)\r\n{\r\nu16 x[4] = {addr, addr + 1, addr + 2, addr + 3};\r\nreturn pwr_reg_rdwr(x, (u8 *)&data, 4, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);\r\n}\r\nint intel_scu_ipc_readv(u16 *addr, u8 *data, int len)\r\n{\r\nreturn pwr_reg_rdwr(addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);\r\n}\r\nint intel_scu_ipc_writev(u16 *addr, u8 *data, int len)\r\n{\r\nreturn pwr_reg_rdwr(addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);\r\n}\r\nint intel_scu_ipc_update_register(u16 addr, u8 bits, u8 mask)\r\n{\r\nu8 data[2] = { bits, mask };\r\nreturn pwr_reg_rdwr(&addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_M);\r\n}\r\nint intel_scu_ipc_simple_command(int cmd, int sub)\r\n{\r\nint err;\r\nmutex_lock(&ipclock);\r\nif (ipcdev.pdev == NULL) {\r\nmutex_unlock(&ipclock);\r\nreturn -ENODEV;\r\n}\r\nipc_command(sub << 12 | cmd);\r\nerr = busy_loop();\r\nmutex_unlock(&ipclock);\r\nreturn err;\r\n}\r\nint intel_scu_ipc_command(int cmd, int sub, u32 *in, int inlen,\r\nu32 *out, int outlen)\r\n{\r\nint i, err;\r\nmutex_lock(&ipclock);\r\nif (ipcdev.pdev == NULL) {\r\nmutex_unlock(&ipclock);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < inlen; i++)\r\nipc_data_writel(*in++, 4 * i);\r\nipc_command((inlen << 16) | (sub << 12) | cmd);\r\nerr = busy_loop();\r\nfor (i = 0; i < outlen; i++)\r\n*out++ = ipc_data_readl(4 * i);\r\nmutex_unlock(&ipclock);\r\nreturn err;\r\n}\r\nint intel_scu_ipc_i2c_cntrl(u32 addr, u32 *data)\r\n{\r\nu32 cmd = 0;\r\nmutex_lock(&ipclock);\r\nif (ipcdev.pdev == NULL) {\r\nmutex_unlock(&ipclock);\r\nreturn -ENODEV;\r\n}\r\ncmd = (addr >> 24) & 0xFF;\r\nif (cmd == IPC_I2C_READ) {\r\nwritel(addr, ipcdev.i2c_base + IPC_I2C_CNTRL_ADDR);\r\nmdelay(1);\r\n*data = readl(ipcdev.i2c_base + I2C_DATA_ADDR);\r\n} else if (cmd == IPC_I2C_WRITE) {\r\nwritel(*data, ipcdev.i2c_base + I2C_DATA_ADDR);\r\nmdelay(1);\r\nwritel(addr, ipcdev.i2c_base + IPC_I2C_CNTRL_ADDR);\r\n} else {\r\ndev_err(&ipcdev.pdev->dev,\r\n"intel_scu_ipc: I2C INVALID_CMD = 0x%x\n", cmd);\r\nmutex_unlock(&ipclock);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&ipclock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ioc(int irq, void *dev_id)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ipc_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint err;\r\nresource_size_t pci_resource;\r\nif (ipcdev.pdev)\r\nreturn -EBUSY;\r\nipcdev.pdev = pci_dev_get(dev);\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nreturn err;\r\nerr = pci_request_regions(dev, "intel_scu_ipc");\r\nif (err)\r\nreturn err;\r\npci_resource = pci_resource_start(dev, 0);\r\nif (!pci_resource)\r\nreturn -ENOMEM;\r\nif (request_irq(dev->irq, ioc, 0, "intel_scu_ipc", &ipcdev))\r\nreturn -EBUSY;\r\nipcdev.ipc_base = ioremap_nocache(IPC_BASE_ADDR, IPC_MAX_ADDR);\r\nif (!ipcdev.ipc_base)\r\nreturn -ENOMEM;\r\nipcdev.i2c_base = ioremap_nocache(IPC_I2C_BASE, IPC_I2C_MAX_ADDR);\r\nif (!ipcdev.i2c_base) {\r\niounmap(ipcdev.ipc_base);\r\nreturn -ENOMEM;\r\n}\r\nintel_scu_devices_create();\r\nreturn 0;\r\n}\r\nstatic void ipc_remove(struct pci_dev *pdev)\r\n{\r\nfree_irq(pdev->irq, &ipcdev);\r\npci_release_regions(pdev);\r\npci_dev_put(ipcdev.pdev);\r\niounmap(ipcdev.ipc_base);\r\niounmap(ipcdev.i2c_base);\r\nipcdev.pdev = NULL;\r\nintel_scu_devices_destroy();\r\n}\r\nstatic int __init intel_scu_ipc_init(void)\r\n{\r\nplatform = mrst_identify_cpu();\r\nif (platform == 0)\r\nreturn -ENODEV;\r\nreturn pci_register_driver(&ipc_driver);\r\n}\r\nstatic void __exit intel_scu_ipc_exit(void)\r\n{\r\npci_unregister_driver(&ipc_driver);\r\n}
