static uint32_t nv42_tv_sample_load(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nuint32_t testval, regoffset = nv04_dac_output_offset(encoder);\r\nuint32_t gpio0, gpio1, fp_htotal, fp_hsync_start, fp_hsync_end,\r\nfp_control, test_ctrl, dacclk, ctv_14, ctv_1c, ctv_6c;\r\nuint32_t sample = 0;\r\nint head;\r\n#define RGB_TEST_DATA(r, g, b) (r << 0 | g << 10 | b << 20)\r\ntestval = RGB_TEST_DATA(0x82, 0xeb, 0x82);\r\nif (dev_priv->vbios.tvdactestval)\r\ntestval = dev_priv->vbios.tvdactestval;\r\ndacclk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);\r\nhead = (dacclk & 0x100) >> 8;\r\ngpio1 = nouveau_gpio_func_get(dev, DCB_GPIO_TVDAC1);\r\ngpio0 = nouveau_gpio_func_get(dev, DCB_GPIO_TVDAC0);\r\nfp_htotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_HTOTAL);\r\nfp_hsync_start = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_START);\r\nfp_hsync_end = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_END);\r\nfp_control = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\r\ntest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\r\nctv_1c = NVReadRAMDAC(dev, head, 0x680c1c);\r\nctv_14 = NVReadRAMDAC(dev, head, 0x680c14);\r\nctv_6c = NVReadRAMDAC(dev, head, 0x680c6c);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, true);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, true);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HTOTAL, 1343);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_START, 1047);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_END, 1183);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL,\r\nNV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\r\nNV_PRAMDAC_FP_TG_CONTROL_WIDTH_12 |\r\nNV_PRAMDAC_FP_TG_CONTROL_READ_PROG |\r\nNV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS |\r\nNV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset, 0);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset,\r\n(dacclk & ~0xff) | 0x22);\r\nmsleep(1);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset,\r\n(dacclk & ~0xff) | 0x21);\r\nNVWriteRAMDAC(dev, head, 0x680c1c, 1 << 20);\r\nNVWriteRAMDAC(dev, head, 0x680c14, 4 << 16);\r\nNVWriteRAMDAC(dev, head, 0x680c6c, testval >> 10 & 0x3ff);\r\nmsleep(20);\r\nsample |= NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset)\r\n& 0x4 << 28;\r\nNVWriteRAMDAC(dev, head, 0x680c6c, testval & 0x3ff);\r\nmsleep(20);\r\nsample |= NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset)\r\n& 0xa << 28;\r\nNVWriteRAMDAC(dev, head, 0x680c1c, ctv_1c);\r\nNVWriteRAMDAC(dev, head, 0x680c14, ctv_14);\r\nNVWriteRAMDAC(dev, head, 0x680c6c, ctv_6c);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, dacclk);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset, test_ctrl);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL, fp_control);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_END, fp_hsync_end);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_START, fp_hsync_start);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HTOTAL, fp_htotal);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, gpio1);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, gpio0);\r\nreturn sample;\r\n}\r\nstatic bool\r\nget_tv_detect_quirks(struct drm_device *dev, uint32_t *pin_mask)\r\n{\r\nif (nv_match_device(dev, 0x0322, 0x19da, 0x1035) ||\r\nnv_match_device(dev, 0x0322, 0x19da, 0x2035)) {\r\n*pin_mask = 0xc;\r\nreturn false;\r\n}\r\nif (nv_match_device(dev, 0x01f0, 0x1462, 0x5710)) {\r\n*pin_mask = 0xc;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic enum drm_connector_status\r\nnv17_tv_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct drm_mode_config *conf = &dev->mode_config;\r\nstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\r\nstruct dcb_entry *dcb = tv_enc->base.dcb;\r\nbool reliable = get_tv_detect_quirks(dev, &tv_enc->pin_mask);\r\nif (nv04_dac_in_use(encoder))\r\nreturn connector_status_disconnected;\r\nif (reliable) {\r\nif (dev_priv->chipset == 0x42 ||\r\ndev_priv->chipset == 0x43)\r\ntv_enc->pin_mask =\r\nnv42_tv_sample_load(encoder) >> 28 & 0xe;\r\nelse\r\ntv_enc->pin_mask =\r\nnv17_dac_sample_load(encoder) >> 28 & 0xe;\r\n}\r\nswitch (tv_enc->pin_mask) {\r\ncase 0x2:\r\ncase 0x4:\r\ntv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Composite;\r\nbreak;\r\ncase 0xc:\r\ntv_enc->subconnector = DRM_MODE_SUBCONNECTOR_SVIDEO;\r\nbreak;\r\ncase 0xe:\r\nif (dcb->tvconf.has_component_output)\r\ntv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Component;\r\nelse\r\ntv_enc->subconnector = DRM_MODE_SUBCONNECTOR_SCART;\r\nbreak;\r\ndefault:\r\ntv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\r\nbreak;\r\n}\r\ndrm_connector_property_set_value(connector,\r\nconf->tv_subconnector_property,\r\ntv_enc->subconnector);\r\nif (!reliable) {\r\nreturn connector_status_unknown;\r\n} else if (tv_enc->subconnector) {\r\nNV_INFO(dev, "Load detected on output %c\n",\r\n'@' + ffs(dcb->or));\r\nreturn connector_status_connected;\r\n} else {\r\nreturn connector_status_disconnected;\r\n}\r\n}\r\nstatic int nv17_tv_get_ld_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nconst struct drm_display_mode *tv_mode;\r\nint n = 0;\r\nfor (tv_mode = nv17_tv_modes; tv_mode->hdisplay; tv_mode++) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(encoder->dev, tv_mode);\r\nmode->clock = tv_norm->tv_enc_mode.vrefresh *\r\nmode->htotal / 1000 *\r\nmode->vtotal / 1000;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nmode->clock *= 2;\r\nif (mode->hdisplay == tv_norm->tv_enc_mode.hdisplay &&\r\nmode->vdisplay == tv_norm->tv_enc_mode.vdisplay)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic int nv17_tv_get_hd_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nstruct drm_display_mode *output_mode = &tv_norm->ctv_enc_mode.mode;\r\nstruct drm_display_mode *mode;\r\nconst struct {\r\nint hdisplay;\r\nint vdisplay;\r\n} modes[] = {\r\n{ 640, 400 },\r\n{ 640, 480 },\r\n{ 720, 480 },\r\n{ 720, 576 },\r\n{ 800, 600 },\r\n{ 1024, 768 },\r\n{ 1280, 720 },\r\n{ 1280, 1024 },\r\n{ 1920, 1080 }\r\n};\r\nint i, n = 0;\r\nfor (i = 0; i < ARRAY_SIZE(modes); i++) {\r\nif (modes[i].hdisplay > output_mode->hdisplay ||\r\nmodes[i].vdisplay > output_mode->vdisplay)\r\ncontinue;\r\nif (modes[i].hdisplay == output_mode->hdisplay &&\r\nmodes[i].vdisplay == output_mode->vdisplay) {\r\nmode = drm_mode_duplicate(encoder->dev, output_mode);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\n} else {\r\nmode = drm_cvt_mode(encoder->dev, modes[i].hdisplay,\r\nmodes[i].vdisplay, 60, false,\r\n(output_mode->flags &\r\nDRM_MODE_FLAG_INTERLACE), false);\r\n}\r\nif (output_mode->hdisplay <= 720\r\n|| output_mode->hdisplay >= 1920) {\r\nmode->htotal = output_mode->htotal;\r\nmode->hsync_start = (mode->hdisplay + (mode->htotal\r\n- mode->hdisplay) * 9 / 10) & ~7;\r\nmode->hsync_end = mode->hsync_start + 8;\r\n}\r\nif (output_mode->vdisplay >= 1024) {\r\nmode->vtotal = output_mode->vtotal;\r\nmode->vsync_start = output_mode->vsync_start;\r\nmode->vsync_end = output_mode->vsync_end;\r\n}\r\nmode->type |= DRM_MODE_TYPE_DRIVER;\r\ndrm_mode_probed_add(connector, mode);\r\nn++;\r\n}\r\nreturn n;\r\n}\r\nstatic int nv17_tv_get_modes(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nif (tv_norm->kind == CTV_ENC_MODE)\r\nreturn nv17_tv_get_hd_modes(encoder, connector);\r\nelse\r\nreturn nv17_tv_get_ld_modes(encoder, connector);\r\n}\r\nstatic int nv17_tv_mode_valid(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nif (tv_norm->kind == CTV_ENC_MODE) {\r\nstruct drm_display_mode *output_mode =\r\n&tv_norm->ctv_enc_mode.mode;\r\nif (mode->clock > 400000)\r\nreturn MODE_CLOCK_HIGH;\r\nif (mode->hdisplay > output_mode->hdisplay ||\r\nmode->vdisplay > output_mode->vdisplay)\r\nreturn MODE_BAD;\r\nif ((mode->flags & DRM_MODE_FLAG_INTERLACE) !=\r\n(output_mode->flags & DRM_MODE_FLAG_INTERLACE))\r\nreturn MODE_NO_INTERLACE;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\n} else {\r\nconst int vsync_tolerance = 600;\r\nif (mode->clock > 70000)\r\nreturn MODE_CLOCK_HIGH;\r\nif (abs(drm_mode_vrefresh(mode) * 1000 -\r\ntv_norm->tv_enc_mode.vrefresh) > vsync_tolerance)\r\nreturn MODE_VSYNC;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nreturn MODE_NO_INTERLACE;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic bool nv17_tv_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nif (nv04_dac_in_use(encoder))\r\nreturn false;\r\nif (tv_norm->kind == CTV_ENC_MODE)\r\nadjusted_mode->clock = tv_norm->ctv_enc_mode.mode.clock;\r\nelse\r\nadjusted_mode->clock = 90000;\r\nreturn true;\r\n}\r\nstatic void nv17_tv_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nv17_tv_state *regs = &to_tv_enc(encoder)->state;\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nif (nouveau_encoder(encoder)->last_dpms == mode)\r\nreturn;\r\nnouveau_encoder(encoder)->last_dpms = mode;\r\nNV_INFO(dev, "Setting dpms mode %d on TV encoder (output %d)\n",\r\nmode, nouveau_encoder(encoder)->dcb->index);\r\nregs->ptv_200 &= ~1;\r\nif (tv_norm->kind == CTV_ENC_MODE) {\r\nnv04_dfp_update_fp_control(encoder, mode);\r\n} else {\r\nnv04_dfp_update_fp_control(encoder, DRM_MODE_DPMS_OFF);\r\nif (mode == DRM_MODE_DPMS_ON)\r\nregs->ptv_200 |= 1;\r\n}\r\nnv_load_ptv(dev, regs, 200);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, mode == DRM_MODE_DPMS_ON);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, mode == DRM_MODE_DPMS_ON);\r\nnv04_dac_update_dacclk(encoder, mode == DRM_MODE_DPMS_ON);\r\n}\r\nstatic void nv17_tv_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nuint8_t *cr_lcd = &dev_priv->mode_reg.crtc_reg[head].CRTC[\r\nNV_CIO_CRE_LCD__INDEX];\r\nuint32_t dacclk_off = NV_PRAMDAC_DACCLK +\r\nnv04_dac_output_offset(encoder);\r\nuint32_t dacclk;\r\nhelper->dpms(encoder, DRM_MODE_DPMS_OFF);\r\nnv04_dfp_disable(dev, head);\r\nif (tv_norm->kind == CTV_ENC_MODE) {\r\nstruct drm_encoder *enc;\r\nlist_for_each_entry(enc, &dev->mode_config.encoder_list, head) {\r\nstruct dcb_entry *dcb = nouveau_encoder(enc)->dcb;\r\nif ((dcb->type == OUTPUT_TMDS ||\r\ndcb->type == OUTPUT_LVDS) &&\r\n!enc->crtc &&\r\nnv04_dfp_get_bound_head(dev, dcb) == head) {\r\nnv04_dfp_bind_head(dev, dcb, head ^ 1,\r\ndev_priv->vbios.fp.dual_link);\r\n}\r\n}\r\n}\r\nif (tv_norm->kind == CTV_ENC_MODE)\r\n*cr_lcd |= 0x1 | (head ? 0x0 : 0x8);\r\ndacclk = (NVReadRAMDAC(dev, 0, dacclk_off) & ~0x30) | 0x1;\r\nif (dev_priv->card_type == NV_40)\r\ndacclk |= 0x1a << 16;\r\nif (tv_norm->kind == CTV_ENC_MODE) {\r\ndacclk |= 0x20;\r\nif (head)\r\ndacclk |= 0x100;\r\nelse\r\ndacclk &= ~0x100;\r\n} else {\r\ndacclk |= 0x10;\r\n}\r\nNVWriteRAMDAC(dev, 0, dacclk_off, dacclk);\r\n}\r\nstatic void nv17_tv_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *drm_mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nstruct nv04_crtc_reg *regs = &dev_priv->mode_reg.crtc_reg[head];\r\nstruct nv17_tv_state *tv_regs = &to_tv_enc(encoder)->state;\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nint i;\r\nregs->CRTC[NV_CIO_CRE_53] = 0x40;\r\nregs->CRTC[NV_CIO_CRE_54] = 0;\r\nregs->ramdac_630 = 0x2;\r\nregs->tv_setup = 1;\r\nregs->ramdac_8c0 = 0x0;\r\nif (tv_norm->kind == TV_ENC_MODE) {\r\ntv_regs->ptv_200 = 0x13111100;\r\nif (head)\r\ntv_regs->ptv_200 |= 0x10;\r\ntv_regs->ptv_20c = 0x808010;\r\ntv_regs->ptv_304 = 0x2d00000;\r\ntv_regs->ptv_600 = 0x0;\r\ntv_regs->ptv_60c = 0x0;\r\ntv_regs->ptv_610 = 0x1e00000;\r\nif (tv_norm->tv_enc_mode.vdisplay == 576) {\r\ntv_regs->ptv_508 = 0x1200000;\r\ntv_regs->ptv_614 = 0x33;\r\n} else if (tv_norm->tv_enc_mode.vdisplay == 480) {\r\ntv_regs->ptv_508 = 0xf00000;\r\ntv_regs->ptv_614 = 0x13;\r\n}\r\nif (dev_priv->card_type >= NV_30) {\r\ntv_regs->ptv_500 = 0xe8e0;\r\ntv_regs->ptv_504 = 0x1710;\r\ntv_regs->ptv_604 = 0x0;\r\ntv_regs->ptv_608 = 0x0;\r\n} else {\r\nif (tv_norm->tv_enc_mode.vdisplay == 576) {\r\ntv_regs->ptv_604 = 0x20;\r\ntv_regs->ptv_608 = 0x10;\r\ntv_regs->ptv_500 = 0x19710;\r\ntv_regs->ptv_504 = 0x68f0;\r\n} else if (tv_norm->tv_enc_mode.vdisplay == 480) {\r\ntv_regs->ptv_604 = 0x10;\r\ntv_regs->ptv_608 = 0x20;\r\ntv_regs->ptv_500 = 0x4b90;\r\ntv_regs->ptv_504 = 0x1b480;\r\n}\r\n}\r\nfor (i = 0; i < 0x40; i++)\r\ntv_regs->tv_enc[i] = tv_norm->tv_enc_mode.tv_enc[i];\r\n} else {\r\nstruct drm_display_mode *output_mode =\r\n&tv_norm->ctv_enc_mode.mode;\r\nfor (i = 0; i < 38; i++)\r\nregs->ctv_regs[i] = tv_norm->ctv_enc_mode.ctv_regs[i];\r\nregs->fp_horiz_regs[FP_DISPLAY_END] = output_mode->hdisplay - 1;\r\nregs->fp_horiz_regs[FP_TOTAL] = output_mode->htotal - 1;\r\nregs->fp_horiz_regs[FP_SYNC_START] =\r\noutput_mode->hsync_start - 1;\r\nregs->fp_horiz_regs[FP_SYNC_END] = output_mode->hsync_end - 1;\r\nregs->fp_horiz_regs[FP_CRTC] = output_mode->hdisplay +\r\nmax((output_mode->hdisplay-600)/40 - 1, 1);\r\nregs->fp_vert_regs[FP_DISPLAY_END] = output_mode->vdisplay - 1;\r\nregs->fp_vert_regs[FP_TOTAL] = output_mode->vtotal - 1;\r\nregs->fp_vert_regs[FP_SYNC_START] =\r\noutput_mode->vsync_start - 1;\r\nregs->fp_vert_regs[FP_SYNC_END] = output_mode->vsync_end - 1;\r\nregs->fp_vert_regs[FP_CRTC] = output_mode->vdisplay - 1;\r\nregs->fp_control = NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\r\nNV_PRAMDAC_FP_TG_CONTROL_READ_PROG |\r\nNV_PRAMDAC_FP_TG_CONTROL_WIDTH_12;\r\nif (output_mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nregs->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS;\r\nif (output_mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nregs->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS;\r\nregs->fp_debug_0 = NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_ROUND |\r\nNV_PRAMDAC_FP_DEBUG_0_XWEIGHT_ROUND |\r\nNV_PRAMDAC_FP_DEBUG_0_YINTERP_BILINEAR |\r\nNV_PRAMDAC_FP_DEBUG_0_XINTERP_BILINEAR |\r\nNV_RAMDAC_FP_DEBUG_0_TMDS_ENABLED |\r\nNV_PRAMDAC_FP_DEBUG_0_YSCALE_ENABLE |\r\nNV_PRAMDAC_FP_DEBUG_0_XSCALE_ENABLE;\r\nregs->fp_debug_2 = 0;\r\nregs->fp_margin_color = 0x801080;\r\n}\r\n}\r\nstatic void nv17_tv_commit(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nif (get_tv_norm(encoder)->kind == TV_ENC_MODE) {\r\nnv17_tv_update_rescaler(encoder);\r\nnv17_tv_update_properties(encoder);\r\n} else {\r\nnv17_ctv_update_rescaler(encoder);\r\n}\r\nnv17_tv_state_load(dev, &to_tv_enc(encoder)->state);\r\nif (dev_priv->chipset < 0x44)\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL +\r\nnv04_dac_output_offset(encoder),\r\n0xf0000000);\r\nelse\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL +\r\nnv04_dac_output_offset(encoder),\r\n0x00100000);\r\nhelper->dpms(encoder, DRM_MODE_DPMS_ON);\r\nNV_INFO(dev, "Output %s is running on CRTC %d using output %c\n",\r\ndrm_get_connector_name(\r\n&nouveau_encoder_connector_get(nv_encoder)->base),\r\nnv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\r\n}\r\nstatic void nv17_tv_save(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\r\nnouveau_encoder(encoder)->restore.output =\r\nNVReadRAMDAC(dev, 0,\r\nNV_PRAMDAC_DACCLK +\r\nnv04_dac_output_offset(encoder));\r\nnv17_tv_state_save(dev, &tv_enc->saved_state);\r\ntv_enc->state.ptv_200 = tv_enc->saved_state.ptv_200;\r\n}\r\nstatic void nv17_tv_restore(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK +\r\nnv04_dac_output_offset(encoder),\r\nnouveau_encoder(encoder)->restore.output);\r\nnv17_tv_state_load(dev, &to_tv_enc(encoder)->saved_state);\r\nnouveau_encoder(encoder)->last_dpms = NV_DPMS_CLEARED;\r\n}\r\nstatic int nv17_tv_create_resources(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_mode_config *conf = &dev->mode_config;\r\nstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\r\nstruct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;\r\nint num_tv_norms = dcb->tvconf.has_component_output ? NUM_TV_NORMS :\r\nNUM_LD_TV_NORMS;\r\nint i;\r\nif (nouveau_tv_norm) {\r\nfor (i = 0; i < num_tv_norms; i++) {\r\nif (!strcmp(nv17_tv_norm_names[i], nouveau_tv_norm)) {\r\ntv_enc->tv_norm = i;\r\nbreak;\r\n}\r\n}\r\nif (i == num_tv_norms)\r\nNV_WARN(dev, "Invalid TV norm setting \"%s\"\n",\r\nnouveau_tv_norm);\r\n}\r\ndrm_mode_create_tv_properties(dev, num_tv_norms, nv17_tv_norm_names);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_select_subconnector_property,\r\ntv_enc->select_subconnector);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_subconnector_property,\r\ntv_enc->subconnector);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_mode_property,\r\ntv_enc->tv_norm);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_flicker_reduction_property,\r\ntv_enc->flicker);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_saturation_property,\r\ntv_enc->saturation);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_hue_property,\r\ntv_enc->hue);\r\ndrm_connector_attach_property(connector,\r\nconf->tv_overscan_property,\r\ntv_enc->overscan);\r\nreturn 0;\r\n}\r\nstatic int nv17_tv_set_property(struct drm_encoder *encoder,\r\nstruct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_mode_config *conf = &encoder->dev->mode_config;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\r\nstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\r\nbool modes_changed = false;\r\nif (property == conf->tv_overscan_property) {\r\ntv_enc->overscan = val;\r\nif (encoder->crtc) {\r\nif (tv_norm->kind == CTV_ENC_MODE)\r\nnv17_ctv_update_rescaler(encoder);\r\nelse\r\nnv17_tv_update_rescaler(encoder);\r\n}\r\n} else if (property == conf->tv_saturation_property) {\r\nif (tv_norm->kind != TV_ENC_MODE)\r\nreturn -EINVAL;\r\ntv_enc->saturation = val;\r\nnv17_tv_update_properties(encoder);\r\n} else if (property == conf->tv_hue_property) {\r\nif (tv_norm->kind != TV_ENC_MODE)\r\nreturn -EINVAL;\r\ntv_enc->hue = val;\r\nnv17_tv_update_properties(encoder);\r\n} else if (property == conf->tv_flicker_reduction_property) {\r\nif (tv_norm->kind != TV_ENC_MODE)\r\nreturn -EINVAL;\r\ntv_enc->flicker = val;\r\nif (encoder->crtc)\r\nnv17_tv_update_rescaler(encoder);\r\n} else if (property == conf->tv_mode_property) {\r\nif (connector->dpms != DRM_MODE_DPMS_OFF)\r\nreturn -EINVAL;\r\ntv_enc->tv_norm = val;\r\nmodes_changed = true;\r\n} else if (property == conf->tv_select_subconnector_property) {\r\nif (tv_norm->kind != TV_ENC_MODE)\r\nreturn -EINVAL;\r\ntv_enc->select_subconnector = val;\r\nnv17_tv_update_properties(encoder);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (modes_changed) {\r\ndrm_helper_probe_single_connector_modes(connector, 0, 0);\r\nif (crtc) {\r\nstruct drm_mode_set modeset = {\r\n.crtc = crtc,\r\n};\r\ncrtc->funcs->set_config(&modeset);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void nv17_tv_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\r\nNV_DEBUG_KMS(encoder->dev, "\n");\r\ndrm_encoder_cleanup(encoder);\r\nkfree(tv_enc);\r\n}\r\nint\r\nnv17_tv_create(struct drm_connector *connector, struct dcb_entry *entry)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_encoder *encoder;\r\nstruct nv17_tv_encoder *tv_enc = NULL;\r\ntv_enc = kzalloc(sizeof(*tv_enc), GFP_KERNEL);\r\nif (!tv_enc)\r\nreturn -ENOMEM;\r\ntv_enc->overscan = 50;\r\ntv_enc->flicker = 50;\r\ntv_enc->saturation = 50;\r\ntv_enc->hue = 0;\r\ntv_enc->tv_norm = TV_NORM_PAL;\r\ntv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\r\ntv_enc->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;\r\ntv_enc->pin_mask = 0;\r\nencoder = to_drm_encoder(&tv_enc->base);\r\ntv_enc->base.dcb = entry;\r\ntv_enc->base.or = ffs(entry->or) - 1;\r\ndrm_encoder_init(dev, encoder, &nv17_tv_funcs, DRM_MODE_ENCODER_TVDAC);\r\ndrm_encoder_helper_add(encoder, &nv17_tv_helper_funcs);\r\nto_encoder_slave(encoder)->slave_funcs = &nv17_tv_slave_funcs;\r\nencoder->possible_crtcs = entry->heads;\r\nencoder->possible_clones = 0;\r\nnv17_tv_create_resources(encoder, connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}
