static int temp_to_code(struct exynos4_tmu_data *data, u8 temp)\r\n{\r\nstruct exynos4_tmu_platform_data *pdata = data->pdata;\r\nint temp_code;\r\nif (temp < 25 || temp > 125) {\r\ntemp_code = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ntemp_code = (temp - 25) *\r\n(data->temp_error2 - data->temp_error1) /\r\n(85 - 25) + data->temp_error1;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING:\r\ntemp_code = temp + data->temp_error1 - 25;\r\nbreak;\r\ndefault:\r\ntemp_code = temp + EXYNOS4_TMU_DEF_CODE_TO_TEMP_OFFSET;\r\nbreak;\r\n}\r\nout:\r\nreturn temp_code;\r\n}\r\nstatic int code_to_temp(struct exynos4_tmu_data *data, u8 temp_code)\r\n{\r\nstruct exynos4_tmu_platform_data *pdata = data->pdata;\r\nint temp;\r\nif (temp_code < 75 || temp_code > 175) {\r\ntemp = -ENODATA;\r\ngoto out;\r\n}\r\nswitch (pdata->cal_type) {\r\ncase TYPE_TWO_POINT_TRIMMING:\r\ntemp = (temp_code - data->temp_error1) * (85 - 25) /\r\n(data->temp_error2 - data->temp_error1) + 25;\r\nbreak;\r\ncase TYPE_ONE_POINT_TRIMMING:\r\ntemp = temp_code - data->temp_error1 + 25;\r\nbreak;\r\ndefault:\r\ntemp = temp_code - EXYNOS4_TMU_DEF_CODE_TO_TEMP_OFFSET;\r\nbreak;\r\n}\r\nout:\r\nreturn temp;\r\n}\r\nstatic int exynos4_tmu_initialize(struct platform_device *pdev)\r\n{\r\nstruct exynos4_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos4_tmu_platform_data *pdata = data->pdata;\r\nunsigned int status, trim_info;\r\nint ret = 0, threshold_code;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\nstatus = readb(data->base + EXYNOS4_TMU_REG_STATUS);\r\nif (!status) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ntrim_info = readl(data->base + EXYNOS4_TMU_REG_TRIMINFO);\r\ndata->temp_error1 = trim_info & EXYNOS4_TMU_TRIM_TEMP_MASK;\r\ndata->temp_error2 = ((trim_info >> 8) & EXYNOS4_TMU_TRIM_TEMP_MASK);\r\nthreshold_code = temp_to_code(data, pdata->threshold);\r\nif (threshold_code < 0) {\r\nret = threshold_code;\r\ngoto out;\r\n}\r\nwriteb(threshold_code,\r\ndata->base + EXYNOS4_TMU_REG_THRESHOLD_TEMP);\r\nwriteb(pdata->trigger_levels[0],\r\ndata->base + EXYNOS4_TMU_REG_TRIG_LEVEL0);\r\nwriteb(pdata->trigger_levels[1],\r\ndata->base + EXYNOS4_TMU_REG_TRIG_LEVEL1);\r\nwriteb(pdata->trigger_levels[2],\r\ndata->base + EXYNOS4_TMU_REG_TRIG_LEVEL2);\r\nwriteb(pdata->trigger_levels[3],\r\ndata->base + EXYNOS4_TMU_REG_TRIG_LEVEL3);\r\nwritel(EXYNOS4_TMU_INTCLEAR_VAL,\r\ndata->base + EXYNOS4_TMU_REG_INTCLEAR);\r\nout:\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic void exynos4_tmu_control(struct platform_device *pdev, bool on)\r\n{\r\nstruct exynos4_tmu_data *data = platform_get_drvdata(pdev);\r\nstruct exynos4_tmu_platform_data *pdata = data->pdata;\r\nunsigned int con, interrupt_en;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ncon = pdata->reference_voltage << EXYNOS4_TMU_REF_VOLTAGE_SHIFT |\r\npdata->gain << EXYNOS4_TMU_GAIN_SHIFT;\r\nif (on) {\r\ncon |= EXYNOS4_TMU_CORE_ON;\r\ninterrupt_en = pdata->trigger_level3_en << 12 |\r\npdata->trigger_level2_en << 8 |\r\npdata->trigger_level1_en << 4 |\r\npdata->trigger_level0_en;\r\n} else {\r\ncon |= EXYNOS4_TMU_CORE_OFF;\r\ninterrupt_en = 0;\r\n}\r\nwritel(interrupt_en, data->base + EXYNOS4_TMU_REG_INTEN);\r\nwritel(con, data->base + EXYNOS4_TMU_REG_CONTROL);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic int exynos4_tmu_read(struct exynos4_tmu_data *data)\r\n{\r\nu8 temp_code;\r\nint temp;\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\ntemp_code = readb(data->base + EXYNOS4_TMU_REG_CURRENT_TEMP);\r\ntemp = code_to_temp(data, temp_code);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\nreturn temp;\r\n}\r\nstatic void exynos4_tmu_work(struct work_struct *work)\r\n{\r\nstruct exynos4_tmu_data *data = container_of(work,\r\nstruct exynos4_tmu_data, irq_work);\r\nmutex_lock(&data->lock);\r\nclk_enable(data->clk);\r\nwritel(EXYNOS4_TMU_INTCLEAR_VAL, data->base + EXYNOS4_TMU_REG_INTCLEAR);\r\nkobject_uevent(&data->hwmon_dev->kobj, KOBJ_CHANGE);\r\nenable_irq(data->irq);\r\nclk_disable(data->clk);\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic irqreturn_t exynos4_tmu_irq(int irq, void *id)\r\n{\r\nstruct exynos4_tmu_data *data = id;\r\ndisable_irq_nosync(irq);\r\nschedule_work(&data->irq_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t exynos4_tmu_show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "exynos4-tmu\n");\r\n}\r\nstatic ssize_t exynos4_tmu_show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct exynos4_tmu_data *data = dev_get_drvdata(dev);\r\nint ret;\r\nret = exynos4_tmu_read(data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret * 1000);\r\n}\r\nstatic ssize_t exynos4_tmu_show_alarm(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct exynos4_tmu_data *data = dev_get_drvdata(dev);\r\nstruct exynos4_tmu_platform_data *pdata = data->pdata;\r\nint temp;\r\nunsigned int trigger_level;\r\ntemp = exynos4_tmu_read(data);\r\nif (temp < 0)\r\nreturn temp;\r\ntrigger_level = pdata->threshold + pdata->trigger_levels[attr->index];\r\nreturn sprintf(buf, "%d\n", !!(temp > trigger_level));\r\n}\r\nstatic ssize_t exynos4_tmu_show_level(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct exynos4_tmu_data *data = dev_get_drvdata(dev);\r\nstruct exynos4_tmu_platform_data *pdata = data->pdata;\r\nunsigned int temp = pdata->threshold +\r\npdata->trigger_levels[attr->index];\r\nreturn sprintf(buf, "%u\n", temp * 1000);\r\n}\r\nstatic int __devinit exynos4_tmu_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos4_tmu_data *data;\r\nstruct exynos4_tmu_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform init data supplied.\n");\r\nreturn -ENODEV;\r\n}\r\ndata = kzalloc(sizeof(struct exynos4_tmu_data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&pdev->dev, "Failed to allocate driver structure\n");\r\nreturn -ENOMEM;\r\n}\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (data->irq < 0) {\r\nret = data->irq;\r\ndev_err(&pdev->dev, "Failed to get platform irq\n");\r\ngoto err_free;\r\n}\r\nINIT_WORK(&data->irq_work, exynos4_tmu_work);\r\ndata->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!data->mem) {\r\nret = -ENOENT;\r\ndev_err(&pdev->dev, "Failed to get platform resource\n");\r\ngoto err_free;\r\n}\r\ndata->mem = request_mem_region(data->mem->start,\r\nresource_size(data->mem), pdev->name);\r\nif (!data->mem) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "Failed to request memory region\n");\r\ngoto err_free;\r\n}\r\ndata->base = ioremap(data->mem->start, resource_size(data->mem));\r\nif (!data->base) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "Failed to ioremap memory\n");\r\ngoto err_mem_region;\r\n}\r\nret = request_irq(data->irq, exynos4_tmu_irq,\r\nIRQF_TRIGGER_RISING,\r\n"exynos4-tmu", data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq: %d\n", data->irq);\r\ngoto err_io_remap;\r\n}\r\ndata->clk = clk_get(NULL, "tmu_apbif");\r\nif (IS_ERR(data->clk)) {\r\nret = PTR_ERR(data->clk);\r\ndev_err(&pdev->dev, "Failed to get clock\n");\r\ngoto err_irq;\r\n}\r\ndata->pdata = pdata;\r\nplatform_set_drvdata(pdev, data);\r\nmutex_init(&data->lock);\r\nret = exynos4_tmu_initialize(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to initialize TMU\n");\r\ngoto err_clk;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &exynos4_tmu_attr_group);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to create sysfs group\n");\r\ngoto err_clk;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nret = PTR_ERR(data->hwmon_dev);\r\ndev_err(&pdev->dev, "Failed to register hwmon device\n");\r\ngoto err_create_group;\r\n}\r\nexynos4_tmu_control(pdev, true);\r\nreturn 0;\r\nerr_create_group:\r\nsysfs_remove_group(&pdev->dev.kobj, &exynos4_tmu_attr_group);\r\nerr_clk:\r\nplatform_set_drvdata(pdev, NULL);\r\nclk_put(data->clk);\r\nerr_irq:\r\nfree_irq(data->irq, data);\r\nerr_io_remap:\r\niounmap(data->base);\r\nerr_mem_region:\r\nrelease_mem_region(data->mem->start, resource_size(data->mem));\r\nerr_free:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int __devexit exynos4_tmu_remove(struct platform_device *pdev)\r\n{\r\nstruct exynos4_tmu_data *data = platform_get_drvdata(pdev);\r\nexynos4_tmu_control(pdev, false);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &exynos4_tmu_attr_group);\r\nclk_put(data->clk);\r\nfree_irq(data->irq, data);\r\niounmap(data->base);\r\nrelease_mem_region(data->mem->start, resource_size(data->mem));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int exynos4_tmu_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nexynos4_tmu_control(pdev, false);\r\nreturn 0;\r\n}\r\nstatic int exynos4_tmu_resume(struct platform_device *pdev)\r\n{\r\nexynos4_tmu_initialize(pdev);\r\nexynos4_tmu_control(pdev, true);\r\nreturn 0;\r\n}
