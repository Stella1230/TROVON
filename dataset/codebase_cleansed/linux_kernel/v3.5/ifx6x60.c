static inline void mrdy_set_high(struct ifx_spi_device *ifx)\r\n{\r\ngpio_set_value(ifx->gpio.mrdy, 1);\r\n}\r\nstatic inline void mrdy_set_low(struct ifx_spi_device *ifx)\r\n{\r\ngpio_set_value(ifx->gpio.mrdy, 0);\r\n}\r\nstatic void\r\nifx_spi_power_state_set(struct ifx_spi_device *ifx_dev, unsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ifx_dev->power_lock, flags);\r\nif (!ifx_dev->power_status)\r\npm_runtime_get(&ifx_dev->spi_dev->dev);\r\nifx_dev->power_status |= val;\r\nspin_unlock_irqrestore(&ifx_dev->power_lock, flags);\r\n}\r\nstatic void\r\nifx_spi_power_state_clear(struct ifx_spi_device *ifx_dev, unsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ifx_dev->power_lock, flags);\r\nif (ifx_dev->power_status) {\r\nifx_dev->power_status &= ~val;\r\nif (!ifx_dev->power_status)\r\npm_runtime_put(&ifx_dev->spi_dev->dev);\r\n}\r\nspin_unlock_irqrestore(&ifx_dev->power_lock, flags);\r\n}\r\nstatic inline void swap_buf(u16 *buf, int len, void *end)\r\n{\r\nint n;\r\nlen = ((len + 1) >> 1);\r\nif ((void *)&buf[len] > end) {\r\npr_err("swap_buf: swap exceeds boundary (%p > %p)!",\r\n&buf[len], end);\r\nreturn;\r\n}\r\nfor (n = 0; n < len; n++) {\r\n*buf = cpu_to_be16(*buf);\r\nbuf++;\r\n}\r\n}\r\nstatic void mrdy_assert(struct ifx_spi_device *ifx_dev)\r\n{\r\nint val = gpio_get_value(ifx_dev->gpio.srdy);\r\nif (!val) {\r\nif (!test_and_set_bit(IFX_SPI_STATE_TIMER_PENDING,\r\n&ifx_dev->flags)) {\r\nifx_dev->spi_timer.expires =\r\njiffies + IFX_SPI_TIMEOUT_SEC*HZ;\r\nadd_timer(&ifx_dev->spi_timer);\r\n}\r\n}\r\nifx_spi_power_state_set(ifx_dev, IFX_SPI_POWER_DATA_PENDING);\r\nmrdy_set_high(ifx_dev);\r\n}\r\nstatic void ifx_spi_ttyhangup(struct ifx_spi_device *ifx_dev)\r\n{\r\nstruct tty_port *pport = &ifx_dev->tty_port;\r\nstruct tty_struct *tty = tty_port_tty_get(pport);\r\nif (tty) {\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void ifx_spi_timeout(unsigned long arg)\r\n{\r\nstruct ifx_spi_device *ifx_dev = (struct ifx_spi_device *)arg;\r\ndev_warn(&ifx_dev->spi_dev->dev, "*** SPI Timeout ***");\r\nifx_spi_ttyhangup(ifx_dev);\r\nmrdy_set_low(ifx_dev);\r\nclear_bit(IFX_SPI_STATE_TIMER_PENDING, &ifx_dev->flags);\r\n}\r\nstatic int ifx_spi_tiocmget(struct tty_struct *tty)\r\n{\r\nunsigned int value;\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\nvalue =\r\n(test_bit(IFX_SPI_RTS, &ifx_dev->signal_state) ? TIOCM_RTS : 0) |\r\n(test_bit(IFX_SPI_DTR, &ifx_dev->signal_state) ? TIOCM_DTR : 0) |\r\n(test_bit(IFX_SPI_CTS, &ifx_dev->signal_state) ? TIOCM_CTS : 0) |\r\n(test_bit(IFX_SPI_DSR, &ifx_dev->signal_state) ? TIOCM_DSR : 0) |\r\n(test_bit(IFX_SPI_DCD, &ifx_dev->signal_state) ? TIOCM_CAR : 0) |\r\n(test_bit(IFX_SPI_RI, &ifx_dev->signal_state) ? TIOCM_RNG : 0);\r\nreturn value;\r\n}\r\nstatic int ifx_spi_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\nif (set & TIOCM_RTS)\r\nset_bit(IFX_SPI_RTS, &ifx_dev->signal_state);\r\nif (set & TIOCM_DTR)\r\nset_bit(IFX_SPI_DTR, &ifx_dev->signal_state);\r\nif (clear & TIOCM_RTS)\r\nclear_bit(IFX_SPI_RTS, &ifx_dev->signal_state);\r\nif (clear & TIOCM_DTR)\r\nclear_bit(IFX_SPI_DTR, &ifx_dev->signal_state);\r\nset_bit(IFX_SPI_UPDATE, &ifx_dev->signal_state);\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn tty_port_open(&saved_ifx_dev->tty_port, tty, filp);\r\n}\r\nstatic void ifx_spi_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\ntty_port_close(&ifx_dev->tty_port, tty, filp);\r\n}\r\nstatic int ifx_spi_decode_spi_header(unsigned char *buffer, int *length,\r\nunsigned char *more, unsigned char *received_cts)\r\n{\r\nu16 h1;\r\nu16 h2;\r\nu16 *in_buffer = (u16 *)buffer;\r\nh1 = *in_buffer;\r\nh2 = *(in_buffer+1);\r\nif (h1 == 0 && h2 == 0) {\r\n*received_cts = 0;\r\nreturn IFX_SPI_HEADER_0;\r\n} else if (h1 == 0xffff && h2 == 0xffff) {\r\nreturn IFX_SPI_HEADER_F;\r\n}\r\n*length = h1 & 0xfff;\r\n*more = (buffer[1] >> IFX_SPI_MORE_BIT) & 1;\r\n*received_cts = (buffer[3] >> IFX_SPI_CTS_BIT) & 1;\r\nreturn 0;\r\n}\r\nstatic void ifx_spi_setup_spi_header(unsigned char *txbuffer, int tx_count,\r\nunsigned char more)\r\n{\r\n*(u16 *)(txbuffer) = tx_count;\r\n*(u16 *)(txbuffer+2) = IFX_SPI_PAYLOAD_SIZE;\r\ntxbuffer[1] |= (more << IFX_SPI_MORE_BIT) & IFX_SPI_MORE_MASK;\r\n}\r\nstatic void ifx_spi_wakeup_serial(struct ifx_spi_device *ifx_dev)\r\n{\r\nstruct tty_struct *tty;\r\ntty = tty_port_tty_get(&ifx_dev->tty_port);\r\nif (!tty)\r\nreturn;\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int ifx_spi_prepare_tx_buffer(struct ifx_spi_device *ifx_dev)\r\n{\r\nint temp_count;\r\nint queue_length;\r\nint tx_count;\r\nunsigned char *tx_buffer;\r\ntx_buffer = ifx_dev->tx_buffer;\r\nmemset(tx_buffer, 0, IFX_SPI_TRANSFER_SIZE);\r\ntx_buffer += IFX_SPI_HEADER_OVERHEAD;\r\ntx_count = IFX_SPI_HEADER_OVERHEAD;\r\nifx_dev->spi_more = 0;\r\nif (!ifx_dev->spi_slave_cts) {\r\nqueue_length = kfifo_len(&ifx_dev->tx_fifo);\r\nif (queue_length != 0) {\r\ntemp_count = min(queue_length, IFX_SPI_PAYLOAD_SIZE);\r\ntemp_count = kfifo_out_locked(&ifx_dev->tx_fifo,\r\ntx_buffer, temp_count,\r\n&ifx_dev->fifo_lock);\r\ntx_buffer += temp_count;\r\ntx_count += temp_count;\r\nif (temp_count == queue_length)\r\nifx_spi_wakeup_serial(ifx_dev);\r\nelse\r\nifx_dev->spi_more = 1;\r\n}\r\n}\r\nifx_spi_setup_spi_header(ifx_dev->tx_buffer,\r\ntx_count-IFX_SPI_HEADER_OVERHEAD,\r\nifx_dev->spi_more);\r\nswap_buf((u16 *)(ifx_dev->tx_buffer), tx_count,\r\n&ifx_dev->tx_buffer[IFX_SPI_TRANSFER_SIZE]);\r\nreturn tx_count;\r\n}\r\nstatic int ifx_spi_write(struct tty_struct *tty, const unsigned char *buf,\r\nint count)\r\n{\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\nunsigned char *tmp_buf = (unsigned char *)buf;\r\nint tx_count = kfifo_in_locked(&ifx_dev->tx_fifo, tmp_buf, count,\r\n&ifx_dev->fifo_lock);\r\nmrdy_assert(ifx_dev);\r\nreturn tx_count;\r\n}\r\nstatic int ifx_spi_write_room(struct tty_struct *tty)\r\n{\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\nreturn IFX_SPI_FIFO_SIZE - kfifo_len(&ifx_dev->tx_fifo);\r\n}\r\nstatic int ifx_spi_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\nreturn kfifo_len(&ifx_dev->tx_fifo);\r\n}\r\nstatic void ifx_spi_hangup(struct tty_struct *tty)\r\n{\r\nstruct ifx_spi_device *ifx_dev = tty->driver_data;\r\ntty_port_hangup(&ifx_dev->tty_port);\r\n}\r\nstatic int ifx_port_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct ifx_spi_device *ifx_dev =\r\ncontainer_of(port, struct ifx_spi_device, tty_port);\r\nkfifo_reset(&ifx_dev->tx_fifo);\r\ntty->driver_data = ifx_dev;\r\ntty->low_latency = 1;\r\nreturn 0;\r\n}\r\nstatic void ifx_port_shutdown(struct tty_port *port)\r\n{\r\nstruct ifx_spi_device *ifx_dev =\r\ncontainer_of(port, struct ifx_spi_device, tty_port);\r\nmrdy_set_low(ifx_dev);\r\nclear_bit(IFX_SPI_STATE_TIMER_PENDING, &ifx_dev->flags);\r\ntasklet_kill(&ifx_dev->io_work_tasklet);\r\n}\r\nstatic void ifx_spi_insert_flip_string(struct ifx_spi_device *ifx_dev,\r\nunsigned char *chars, size_t size)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&ifx_dev->tty_port);\r\nif (!tty)\r\nreturn;\r\ntty_insert_flip_string(tty, chars, size);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic void ifx_spi_complete(void *ctx)\r\n{\r\nstruct ifx_spi_device *ifx_dev = ctx;\r\nstruct tty_struct *tty;\r\nstruct tty_ldisc *ldisc = NULL;\r\nint length;\r\nint actual_length;\r\nunsigned char more;\r\nunsigned char cts;\r\nint local_write_pending = 0;\r\nint queue_length;\r\nint srdy;\r\nint decode_result;\r\nmrdy_set_low(ifx_dev);\r\nif (!ifx_dev->spi_msg.status) {\r\nswap_buf((u16 *)ifx_dev->rx_buffer, IFX_SPI_HEADER_OVERHEAD,\r\n&ifx_dev->rx_buffer[IFX_SPI_HEADER_OVERHEAD]);\r\ndecode_result = ifx_spi_decode_spi_header(ifx_dev->rx_buffer,\r\n&length, &more, &cts);\r\nif (decode_result == IFX_SPI_HEADER_0) {\r\ndev_dbg(&ifx_dev->spi_dev->dev,\r\n"ignore input: invalid header 0");\r\nifx_dev->spi_slave_cts = 0;\r\ngoto complete_exit;\r\n} else if (decode_result == IFX_SPI_HEADER_F) {\r\ndev_dbg(&ifx_dev->spi_dev->dev,\r\n"ignore input: invalid header F");\r\ngoto complete_exit;\r\n}\r\nifx_dev->spi_slave_cts = cts;\r\nactual_length = min((unsigned int)length,\r\nifx_dev->spi_msg.actual_length);\r\nswap_buf((u16 *)(ifx_dev->rx_buffer + IFX_SPI_HEADER_OVERHEAD),\r\nactual_length,\r\n&ifx_dev->rx_buffer[IFX_SPI_TRANSFER_SIZE]);\r\nifx_spi_insert_flip_string(\r\nifx_dev,\r\nifx_dev->rx_buffer + IFX_SPI_HEADER_OVERHEAD,\r\n(size_t)actual_length);\r\n} else {\r\ndev_dbg(&ifx_dev->spi_dev->dev, "SPI transfer error %d",\r\nifx_dev->spi_msg.status);\r\n}\r\ncomplete_exit:\r\nif (ifx_dev->write_pending) {\r\nifx_dev->write_pending = 0;\r\nlocal_write_pending = 1;\r\n}\r\nclear_bit(IFX_SPI_STATE_IO_IN_PROGRESS, &(ifx_dev->flags));\r\nqueue_length = kfifo_len(&ifx_dev->tx_fifo);\r\nsrdy = gpio_get_value(ifx_dev->gpio.srdy);\r\nif (!srdy)\r\nifx_spi_power_state_clear(ifx_dev, IFX_SPI_POWER_SRDY);\r\nif (test_and_clear_bit(IFX_SPI_STATE_IO_READY, &ifx_dev->flags))\r\ntasklet_schedule(&ifx_dev->io_work_tasklet);\r\nelse {\r\nif (more || ifx_dev->spi_more || queue_length > 0 ||\r\nlocal_write_pending) {\r\nif (ifx_dev->spi_slave_cts) {\r\nif (more)\r\nmrdy_assert(ifx_dev);\r\n} else\r\nmrdy_assert(ifx_dev);\r\n} else {\r\nifx_spi_power_state_clear(ifx_dev,\r\nIFX_SPI_POWER_DATA_PENDING);\r\ntty = tty_port_tty_get(&ifx_dev->tty_port);\r\nif (tty) {\r\nldisc = tty_ldisc_ref(tty);\r\nif (ldisc) {\r\nldisc->ops->write_wakeup(tty);\r\ntty_ldisc_deref(ldisc);\r\n}\r\ntty_kref_put(tty);\r\n}\r\n}\r\n}\r\n}\r\nstatic void ifx_spi_io(unsigned long data)\r\n{\r\nint retval;\r\nstruct ifx_spi_device *ifx_dev = (struct ifx_spi_device *) data;\r\nif (!test_and_set_bit(IFX_SPI_STATE_IO_IN_PROGRESS, &ifx_dev->flags)) {\r\nif (ifx_dev->gpio.unack_srdy_int_nb > 0)\r\nifx_dev->gpio.unack_srdy_int_nb--;\r\nifx_spi_prepare_tx_buffer(ifx_dev);\r\nspi_message_init(&ifx_dev->spi_msg);\r\nINIT_LIST_HEAD(&ifx_dev->spi_msg.queue);\r\nifx_dev->spi_msg.context = ifx_dev;\r\nifx_dev->spi_msg.complete = ifx_spi_complete;\r\nifx_dev->spi_xfer.len = IFX_SPI_TRANSFER_SIZE;\r\nifx_dev->spi_xfer.cs_change = 0;\r\nifx_dev->spi_xfer.speed_hz = ifx_dev->spi_dev->max_speed_hz;\r\nifx_dev->spi_xfer.bits_per_word = spi_bpw;\r\nifx_dev->spi_xfer.tx_buf = ifx_dev->tx_buffer;\r\nifx_dev->spi_xfer.rx_buf = ifx_dev->rx_buffer;\r\nif (ifx_dev->use_dma) {\r\nifx_dev->spi_msg.is_dma_mapped = 1;\r\nifx_dev->tx_dma = ifx_dev->tx_bus;\r\nifx_dev->rx_dma = ifx_dev->rx_bus;\r\nifx_dev->spi_xfer.tx_dma = ifx_dev->tx_dma;\r\nifx_dev->spi_xfer.rx_dma = ifx_dev->rx_dma;\r\n} else {\r\nifx_dev->spi_msg.is_dma_mapped = 0;\r\nifx_dev->tx_dma = (dma_addr_t)0;\r\nifx_dev->rx_dma = (dma_addr_t)0;\r\nifx_dev->spi_xfer.tx_dma = (dma_addr_t)0;\r\nifx_dev->spi_xfer.rx_dma = (dma_addr_t)0;\r\n}\r\nspi_message_add_tail(&ifx_dev->spi_xfer, &ifx_dev->spi_msg);\r\nmrdy_assert(ifx_dev);\r\nretval = spi_async(ifx_dev->spi_dev, &ifx_dev->spi_msg);\r\nif (retval) {\r\nclear_bit(IFX_SPI_STATE_IO_IN_PROGRESS,\r\n&ifx_dev->flags);\r\ntasklet_schedule(&ifx_dev->io_work_tasklet);\r\nreturn;\r\n}\r\n} else\r\nifx_dev->write_pending = 1;\r\n}\r\nstatic void ifx_spi_free_port(struct ifx_spi_device *ifx_dev)\r\n{\r\nif (ifx_dev->tty_dev)\r\ntty_unregister_device(tty_drv, ifx_dev->minor);\r\nkfifo_free(&ifx_dev->tx_fifo);\r\n}\r\nstatic int ifx_spi_create_port(struct ifx_spi_device *ifx_dev)\r\n{\r\nint ret = 0;\r\nstruct tty_port *pport = &ifx_dev->tty_port;\r\nspin_lock_init(&ifx_dev->fifo_lock);\r\nlockdep_set_class_and_subclass(&ifx_dev->fifo_lock,\r\n&ifx_spi_key, 0);\r\nif (kfifo_alloc(&ifx_dev->tx_fifo, IFX_SPI_FIFO_SIZE, GFP_KERNEL)) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ntty_port_init(pport);\r\npport->ops = &ifx_tty_port_ops;\r\nifx_dev->minor = IFX_SPI_TTY_ID;\r\nifx_dev->tty_dev = tty_register_device(tty_drv, ifx_dev->minor,\r\n&ifx_dev->spi_dev->dev);\r\nif (IS_ERR(ifx_dev->tty_dev)) {\r\ndev_dbg(&ifx_dev->spi_dev->dev,\r\n"%s: registering tty device failed", __func__);\r\nret = PTR_ERR(ifx_dev->tty_dev);\r\ngoto error_ret;\r\n}\r\nreturn 0;\r\nerror_ret:\r\nifx_spi_free_port(ifx_dev);\r\nreturn ret;\r\n}\r\nstatic void ifx_spi_handle_srdy(struct ifx_spi_device *ifx_dev)\r\n{\r\nif (test_bit(IFX_SPI_STATE_TIMER_PENDING, &ifx_dev->flags)) {\r\ndel_timer_sync(&ifx_dev->spi_timer);\r\nclear_bit(IFX_SPI_STATE_TIMER_PENDING, &ifx_dev->flags);\r\n}\r\nifx_spi_power_state_set(ifx_dev, IFX_SPI_POWER_SRDY);\r\nif (!test_bit(IFX_SPI_STATE_IO_IN_PROGRESS, &ifx_dev->flags))\r\ntasklet_schedule(&ifx_dev->io_work_tasklet);\r\nelse\r\nset_bit(IFX_SPI_STATE_IO_READY, &ifx_dev->flags);\r\n}\r\nstatic irqreturn_t ifx_spi_srdy_interrupt(int irq, void *dev)\r\n{\r\nstruct ifx_spi_device *ifx_dev = dev;\r\nifx_dev->gpio.unack_srdy_int_nb++;\r\nifx_spi_handle_srdy(ifx_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ifx_spi_reset_interrupt(int irq, void *dev)\r\n{\r\nstruct ifx_spi_device *ifx_dev = dev;\r\nint val = gpio_get_value(ifx_dev->gpio.reset_out);\r\nint solreset = test_bit(MR_START, &ifx_dev->mdm_reset_state);\r\nif (val == 0) {\r\nset_bit(MR_INPROGRESS, &ifx_dev->mdm_reset_state);\r\nif (!solreset) {\r\nifx_spi_ttyhangup(ifx_dev);\r\n}\r\n} else {\r\nclear_bit(MR_INPROGRESS, &ifx_dev->mdm_reset_state);\r\nif (solreset) {\r\nset_bit(MR_COMPLETE, &ifx_dev->mdm_reset_state);\r\nwake_up(&ifx_dev->mdm_reset_wait);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ifx_spi_free_device(struct ifx_spi_device *ifx_dev)\r\n{\r\nifx_spi_free_port(ifx_dev);\r\ndma_free_coherent(&ifx_dev->spi_dev->dev,\r\nIFX_SPI_TRANSFER_SIZE,\r\nifx_dev->tx_buffer,\r\nifx_dev->tx_bus);\r\ndma_free_coherent(&ifx_dev->spi_dev->dev,\r\nIFX_SPI_TRANSFER_SIZE,\r\nifx_dev->rx_buffer,\r\nifx_dev->rx_bus);\r\n}\r\nstatic int ifx_spi_reset(struct ifx_spi_device *ifx_dev)\r\n{\r\nint ret;\r\nset_bit(MR_START, &ifx_dev->mdm_reset_state);\r\ngpio_set_value(ifx_dev->gpio.po, 0);\r\ngpio_set_value(ifx_dev->gpio.reset, 0);\r\nmsleep(25);\r\ngpio_set_value(ifx_dev->gpio.reset, 1);\r\nmsleep(1);\r\ngpio_set_value(ifx_dev->gpio.po, 1);\r\nmsleep(1);\r\ngpio_set_value(ifx_dev->gpio.po, 0);\r\nret = wait_event_timeout(ifx_dev->mdm_reset_wait,\r\ntest_bit(MR_COMPLETE,\r\n&ifx_dev->mdm_reset_state),\r\nIFX_RESET_TIMEOUT);\r\nif (!ret)\r\ndev_warn(&ifx_dev->spi_dev->dev, "Modem reset timeout: (state:%lx)",\r\nifx_dev->mdm_reset_state);\r\nifx_dev->mdm_reset_state = 0;\r\nreturn ret;\r\n}\r\nstatic int ifx_spi_spi_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nint srdy;\r\nstruct ifx_modem_platform_data *pl_data;\r\nstruct ifx_spi_device *ifx_dev;\r\nif (saved_ifx_dev) {\r\ndev_dbg(&spi->dev, "ignoring subsequent detection");\r\nreturn -ENODEV;\r\n}\r\npl_data = (struct ifx_modem_platform_data *)spi->dev.platform_data;\r\nif (!pl_data) {\r\ndev_err(&spi->dev, "missing platform data!");\r\nreturn -ENODEV;\r\n}\r\nifx_dev = kzalloc(sizeof(struct ifx_spi_device), GFP_KERNEL);\r\nif (!ifx_dev) {\r\ndev_err(&spi->dev, "spi device allocation failed");\r\nreturn -ENOMEM;\r\n}\r\nsaved_ifx_dev = ifx_dev;\r\nifx_dev->spi_dev = spi;\r\nclear_bit(IFX_SPI_STATE_IO_IN_PROGRESS, &ifx_dev->flags);\r\nspin_lock_init(&ifx_dev->write_lock);\r\nspin_lock_init(&ifx_dev->power_lock);\r\nifx_dev->power_status = 0;\r\ninit_timer(&ifx_dev->spi_timer);\r\nifx_dev->spi_timer.function = ifx_spi_timeout;\r\nifx_dev->spi_timer.data = (unsigned long)ifx_dev;\r\nifx_dev->modem = pl_data->modem_type;\r\nifx_dev->use_dma = pl_data->use_dma;\r\nifx_dev->max_hz = pl_data->max_hz;\r\nspi->max_speed_hz = ifx_dev->max_hz;\r\nspi->mode = IFX_SPI_MODE | (SPI_LOOP & spi->mode);\r\nspi->bits_per_word = spi_bpw;\r\nret = spi_setup(spi);\r\nif (ret) {\r\ndev_err(&spi->dev, "SPI setup wasn't successful %d", ret);\r\nreturn -ENODEV;\r\n}\r\nifx_dev->spi_more = 0;\r\nifx_dev->spi_slave_cts = 0;\r\nifx_dev->tx_buffer = dma_alloc_coherent(ifx_dev->spi_dev->dev.parent,\r\nIFX_SPI_TRANSFER_SIZE,\r\n&ifx_dev->tx_bus,\r\nGFP_KERNEL);\r\nif (!ifx_dev->tx_buffer) {\r\ndev_err(&spi->dev, "DMA-TX buffer allocation failed");\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nifx_dev->rx_buffer = dma_alloc_coherent(ifx_dev->spi_dev->dev.parent,\r\nIFX_SPI_TRANSFER_SIZE,\r\n&ifx_dev->rx_bus,\r\nGFP_KERNEL);\r\nif (!ifx_dev->rx_buffer) {\r\ndev_err(&spi->dev, "DMA-RX buffer allocation failed");\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\ninit_waitqueue_head(&ifx_dev->mdm_reset_wait);\r\nspi_set_drvdata(spi, ifx_dev);\r\ntasklet_init(&ifx_dev->io_work_tasklet, ifx_spi_io,\r\n(unsigned long)ifx_dev);\r\nset_bit(IFX_SPI_STATE_PRESENT, &ifx_dev->flags);\r\nret = ifx_spi_create_port(ifx_dev);\r\nif (ret != 0) {\r\ndev_err(&spi->dev, "create default tty port failed");\r\ngoto error_ret;\r\n}\r\nifx_dev->gpio.reset = pl_data->rst_pmu;\r\nifx_dev->gpio.po = pl_data->pwr_on;\r\nifx_dev->gpio.mrdy = pl_data->mrdy;\r\nifx_dev->gpio.srdy = pl_data->srdy;\r\nifx_dev->gpio.reset_out = pl_data->rst_out;\r\ndev_info(&spi->dev, "gpios %d, %d, %d, %d, %d",\r\nifx_dev->gpio.reset, ifx_dev->gpio.po, ifx_dev->gpio.mrdy,\r\nifx_dev->gpio.srdy, ifx_dev->gpio.reset_out);\r\nret = gpio_request(ifx_dev->gpio.reset, "ifxModem");\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Unable to allocate GPIO%d (RESET)",\r\nifx_dev->gpio.reset);\r\ngoto error_ret;\r\n}\r\nret += gpio_direction_output(ifx_dev->gpio.reset, 0);\r\nret += gpio_export(ifx_dev->gpio.reset, 1);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to configure GPIO%d (RESET)",\r\nifx_dev->gpio.reset);\r\nret = -EBUSY;\r\ngoto error_ret2;\r\n}\r\nret = gpio_request(ifx_dev->gpio.po, "ifxModem");\r\nret += gpio_direction_output(ifx_dev->gpio.po, 0);\r\nret += gpio_export(ifx_dev->gpio.po, 1);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to configure GPIO%d (ON)",\r\nifx_dev->gpio.po);\r\nret = -EBUSY;\r\ngoto error_ret3;\r\n}\r\nret = gpio_request(ifx_dev->gpio.mrdy, "ifxModem");\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Unable to allocate GPIO%d (MRDY)",\r\nifx_dev->gpio.mrdy);\r\ngoto error_ret3;\r\n}\r\nret += gpio_export(ifx_dev->gpio.mrdy, 1);\r\nret += gpio_direction_output(ifx_dev->gpio.mrdy, 0);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to configure GPIO%d (MRDY)",\r\nifx_dev->gpio.mrdy);\r\nret = -EBUSY;\r\ngoto error_ret4;\r\n}\r\nret = gpio_request(ifx_dev->gpio.srdy, "ifxModem");\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Unable to allocate GPIO%d (SRDY)",\r\nifx_dev->gpio.srdy);\r\nret = -EBUSY;\r\ngoto error_ret4;\r\n}\r\nret += gpio_export(ifx_dev->gpio.srdy, 1);\r\nret += gpio_direction_input(ifx_dev->gpio.srdy);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to configure GPIO%d (SRDY)",\r\nifx_dev->gpio.srdy);\r\nret = -EBUSY;\r\ngoto error_ret5;\r\n}\r\nret = gpio_request(ifx_dev->gpio.reset_out, "ifxModem");\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "Unable to allocate GPIO%d (RESET_OUT)",\r\nifx_dev->gpio.reset_out);\r\ngoto error_ret5;\r\n}\r\nret += gpio_export(ifx_dev->gpio.reset_out, 1);\r\nret += gpio_direction_input(ifx_dev->gpio.reset_out);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to configure GPIO%d (RESET_OUT)",\r\nifx_dev->gpio.reset_out);\r\nret = -EBUSY;\r\ngoto error_ret6;\r\n}\r\nret = request_irq(gpio_to_irq(ifx_dev->gpio.reset_out),\r\nifx_spi_reset_interrupt,\r\nIRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, DRVNAME,\r\n(void *)ifx_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to get irq %x\n",\r\ngpio_to_irq(ifx_dev->gpio.reset_out));\r\ngoto error_ret6;\r\n}\r\nret = ifx_spi_reset(ifx_dev);\r\nret = request_irq(gpio_to_irq(ifx_dev->gpio.srdy),\r\nifx_spi_srdy_interrupt,\r\nIRQF_TRIGGER_RISING, DRVNAME,\r\n(void *)ifx_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "Unable to get irq %x",\r\ngpio_to_irq(ifx_dev->gpio.srdy));\r\ngoto error_ret7;\r\n}\r\npm_runtime_set_active(&spi->dev);\r\npm_runtime_enable(&spi->dev);\r\nsrdy = gpio_get_value(ifx_dev->gpio.srdy);\r\nif (srdy) {\r\nmrdy_assert(ifx_dev);\r\nifx_spi_handle_srdy(ifx_dev);\r\n} else\r\nmrdy_set_low(ifx_dev);\r\nreturn 0;\r\nerror_ret7:\r\nfree_irq(gpio_to_irq(ifx_dev->gpio.reset_out), (void *)ifx_dev);\r\nerror_ret6:\r\ngpio_free(ifx_dev->gpio.srdy);\r\nerror_ret5:\r\ngpio_free(ifx_dev->gpio.mrdy);\r\nerror_ret4:\r\ngpio_free(ifx_dev->gpio.reset);\r\nerror_ret3:\r\ngpio_free(ifx_dev->gpio.po);\r\nerror_ret2:\r\ngpio_free(ifx_dev->gpio.reset_out);\r\nerror_ret:\r\nifx_spi_free_device(ifx_dev);\r\nsaved_ifx_dev = NULL;\r\nreturn ret;\r\n}\r\nstatic int ifx_spi_spi_remove(struct spi_device *spi)\r\n{\r\nstruct ifx_spi_device *ifx_dev = spi_get_drvdata(spi);\r\ntasklet_kill(&ifx_dev->io_work_tasklet);\r\nfree_irq(gpio_to_irq(ifx_dev->gpio.reset_out), (void *)ifx_dev);\r\nfree_irq(gpio_to_irq(ifx_dev->gpio.srdy), (void *)ifx_dev);\r\ngpio_free(ifx_dev->gpio.srdy);\r\ngpio_free(ifx_dev->gpio.mrdy);\r\ngpio_free(ifx_dev->gpio.reset);\r\ngpio_free(ifx_dev->gpio.po);\r\ngpio_free(ifx_dev->gpio.reset_out);\r\nifx_spi_free_device(ifx_dev);\r\nsaved_ifx_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic void ifx_spi_spi_shutdown(struct spi_device *spi)\r\n{\r\n}\r\nstatic int ifx_spi_spi_suspend(struct spi_device *spi, pm_message_t msg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_spi_resume(struct spi_device *spi)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_pm_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_pm_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_pm_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_pm_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ifx_spi_pm_runtime_idle(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct ifx_spi_device *ifx_dev = spi_get_drvdata(spi);\r\nif (!ifx_dev->power_status)\r\npm_runtime_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic void __exit ifx_spi_exit(void)\r\n{\r\ntty_unregister_driver(tty_drv);\r\nspi_unregister_driver((void *)&ifx_spi_driver);\r\n}\r\nstatic int __init ifx_spi_init(void)\r\n{\r\nint result;\r\ntty_drv = alloc_tty_driver(1);\r\nif (!tty_drv) {\r\npr_err("%s: alloc_tty_driver failed", DRVNAME);\r\nreturn -ENOMEM;\r\n}\r\ntty_drv->driver_name = DRVNAME;\r\ntty_drv->name = TTYNAME;\r\ntty_drv->minor_start = IFX_SPI_TTY_ID;\r\ntty_drv->type = TTY_DRIVER_TYPE_SERIAL;\r\ntty_drv->subtype = SERIAL_TYPE_NORMAL;\r\ntty_drv->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\ntty_drv->init_termios = tty_std_termios;\r\ntty_set_operations(tty_drv, &ifx_spi_serial_ops);\r\nresult = tty_register_driver(tty_drv);\r\nif (result) {\r\npr_err("%s: tty_register_driver failed(%d)",\r\nDRVNAME, result);\r\nput_tty_driver(tty_drv);\r\nreturn result;\r\n}\r\nresult = spi_register_driver((void *)&ifx_spi_driver);\r\nif (result) {\r\npr_err("%s: spi_register_driver failed(%d)",\r\nDRVNAME, result);\r\ntty_unregister_driver(tty_drv);\r\n}\r\nreturn result;\r\n}
