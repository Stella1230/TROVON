static int shannon_pcmcia_hw_init(struct soc_pcmcia_socket *skt)\r\n{\r\nGAFR &= ~(GPIO_GPIO(SHANNON_GPIO_EJECT_0) |\r\nGPIO_GPIO(SHANNON_GPIO_EJECT_1) |\r\nGPIO_GPIO(SHANNON_GPIO_RDY_0) |\r\nGPIO_GPIO(SHANNON_GPIO_RDY_1));\r\nif (skt->nr == 0) {\r\nskt->stat[SOC_STAT_CD].gpio = SHANNON_GPIO_EJECT_0;\r\nskt->stat[SOC_STAT_CD].name = "PCMCIA_CD_0";\r\nskt->stat[SOC_STAT_RDY].gpio = SHANNON_GPIO_RDY_0;\r\nskt->stat[SOC_STAT_RDY].name = "PCMCIA_RDY_0";\r\n} else {\r\nskt->stat[SOC_STAT_CD].gpio = SHANNON_GPIO_EJECT_1;\r\nskt->stat[SOC_STAT_CD].name = "PCMCIA_CD_1";\r\nskt->stat[SOC_STAT_RDY].gpio = SHANNON_GPIO_RDY_1;\r\nskt->stat[SOC_STAT_RDY].name = "PCMCIA_RDY_1";\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nshannon_pcmcia_socket_state(struct soc_pcmcia_socket *skt,\r\nstruct pcmcia_state *state)\r\n{\r\nswitch (skt->nr) {\r\ncase 0:\r\nstate->bvd1 = 1;\r\nstate->bvd2 = 1;\r\nstate->vs_3v = 1;\r\nstate->vs_Xv = 0;\r\nbreak;\r\ncase 1:\r\nstate->bvd1 = 1;\r\nstate->bvd2 = 1;\r\nstate->vs_3v = 1;\r\nstate->vs_Xv = 0;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nshannon_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,\r\nconst socket_state_t *state)\r\n{\r\nswitch (state->Vcc) {\r\ncase 0:\r\nprintk(KERN_WARNING "%s(): CS asked for 0V, still applying 3.3V..\n", __func__);\r\nbreak;\r\ncase 50:\r\nprintk(KERN_WARNING "%s(): CS asked for 5V, applying 3.3V..\n", __func__);\r\ncase 33:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s(): unrecognized Vcc %u\n",\r\n__func__, state->Vcc);\r\nreturn -1;\r\n}\r\nprintk(KERN_WARNING "%s(): Warning, Can't perform reset\n", __func__);\r\nreturn 0;\r\n}\r\nint __devinit pcmcia_shannon_init(struct device *dev)\r\n{\r\nint ret = -ENODEV;\r\nif (machine_is_shannon())\r\nret = sa11xx_drv_pcmcia_probe(dev, &shannon_pcmcia_ops, 0, 2);\r\nreturn ret;\r\n}
