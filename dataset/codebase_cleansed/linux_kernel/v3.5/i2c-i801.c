static int i801_check_pre(struct i801_priv *priv)\r\n{\r\nint status;\r\nstatus = inb_p(SMBHSTSTS(priv));\r\nif (status & SMBHSTSTS_HOST_BUSY) {\r\ndev_err(&priv->pci_dev->dev, "SMBus is busy, can't use it!\n");\r\nreturn -EBUSY;\r\n}\r\nstatus &= STATUS_FLAGS;\r\nif (status) {\r\ndev_dbg(&priv->pci_dev->dev, "Clearing status flags (%02x)\n",\r\nstatus);\r\noutb_p(status, SMBHSTSTS(priv));\r\nstatus = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;\r\nif (status) {\r\ndev_err(&priv->pci_dev->dev,\r\n"Failed clearing status flags (%02x)\n",\r\nstatus);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i801_check_post(struct i801_priv *priv, int status, int timeout)\r\n{\r\nint result = 0;\r\nif (timeout) {\r\ndev_err(&priv->pci_dev->dev, "Transaction timeout\n");\r\ndev_dbg(&priv->pci_dev->dev, "Terminating the current operation\n");\r\noutb_p(inb_p(SMBHSTCNT(priv)) | SMBHSTCNT_KILL,\r\nSMBHSTCNT(priv));\r\nusleep_range(1000, 2000);\r\noutb_p(inb_p(SMBHSTCNT(priv)) & (~SMBHSTCNT_KILL),\r\nSMBHSTCNT(priv));\r\nstatus = inb_p(SMBHSTSTS(priv));\r\nif ((status & SMBHSTSTS_HOST_BUSY) ||\r\n!(status & SMBHSTSTS_FAILED))\r\ndev_err(&priv->pci_dev->dev,\r\n"Failed terminating the transaction\n");\r\noutb_p(STATUS_FLAGS, SMBHSTSTS(priv));\r\nreturn -ETIMEDOUT;\r\n}\r\nif (status & SMBHSTSTS_FAILED) {\r\nresult = -EIO;\r\ndev_err(&priv->pci_dev->dev, "Transaction failed\n");\r\n}\r\nif (status & SMBHSTSTS_DEV_ERR) {\r\nresult = -ENXIO;\r\ndev_dbg(&priv->pci_dev->dev, "No response\n");\r\n}\r\nif (status & SMBHSTSTS_BUS_ERR) {\r\nresult = -EAGAIN;\r\ndev_dbg(&priv->pci_dev->dev, "Lost arbitration\n");\r\n}\r\nif (result) {\r\noutb_p(status & STATUS_FLAGS, SMBHSTSTS(priv));\r\nstatus = inb_p(SMBHSTSTS(priv)) & STATUS_FLAGS;\r\nif (status) {\r\ndev_warn(&priv->pci_dev->dev, "Failed clearing status "\r\n"flags at end of transaction (%02x)\n",\r\nstatus);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int i801_transaction(struct i801_priv *priv, int xact)\r\n{\r\nint status;\r\nint result;\r\nint timeout = 0;\r\nresult = i801_check_pre(priv);\r\nif (result < 0)\r\nreturn result;\r\noutb_p(xact | I801_START, SMBHSTCNT(priv));\r\ndo {\r\nusleep_range(250, 500);\r\nstatus = inb_p(SMBHSTSTS(priv));\r\n} while ((status & SMBHSTSTS_HOST_BUSY) && (timeout++ < MAX_RETRIES));\r\nresult = i801_check_post(priv, status, timeout > MAX_RETRIES);\r\nif (result < 0)\r\nreturn result;\r\noutb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));\r\nreturn 0;\r\n}\r\nstatic void i801_wait_hwpec(struct i801_priv *priv)\r\n{\r\nint timeout = 0;\r\nint status;\r\ndo {\r\nusleep_range(250, 500);\r\nstatus = inb_p(SMBHSTSTS(priv));\r\n} while ((!(status & SMBHSTSTS_INTR))\r\n&& (timeout++ < MAX_RETRIES));\r\nif (timeout > MAX_RETRIES)\r\ndev_dbg(&priv->pci_dev->dev, "PEC Timeout!\n");\r\noutb_p(status, SMBHSTSTS(priv));\r\n}\r\nstatic int i801_block_transaction_by_block(struct i801_priv *priv,\r\nunion i2c_smbus_data *data,\r\nchar read_write, int hwpec)\r\n{\r\nint i, len;\r\nint status;\r\ninb_p(SMBHSTCNT(priv));\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\noutb_p(len, SMBHSTDAT0(priv));\r\nfor (i = 0; i < len; i++)\r\noutb_p(data->block[i+1], SMBBLKDAT(priv));\r\n}\r\nstatus = i801_transaction(priv, I801_BLOCK_DATA | ENABLE_INT9 |\r\nI801_PEC_EN * hwpec);\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_READ) {\r\nlen = inb_p(SMBHSTDAT0(priv));\r\nif (len < 1 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EPROTO;\r\ndata->block[0] = len;\r\nfor (i = 0; i < len; i++)\r\ndata->block[i + 1] = inb_p(SMBBLKDAT(priv));\r\n}\r\nreturn 0;\r\n}\r\nstatic int i801_block_transaction_byte_by_byte(struct i801_priv *priv,\r\nunion i2c_smbus_data *data,\r\nchar read_write, int command,\r\nint hwpec)\r\n{\r\nint i, len;\r\nint smbcmd;\r\nint status;\r\nint result;\r\nint timeout;\r\nresult = i801_check_pre(priv);\r\nif (result < 0)\r\nreturn result;\r\nlen = data->block[0];\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb_p(len, SMBHSTDAT0(priv));\r\noutb_p(data->block[1], SMBBLKDAT(priv));\r\n}\r\nfor (i = 1; i <= len; i++) {\r\nif (i == len && read_write == I2C_SMBUS_READ) {\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA)\r\nsmbcmd = I801_I2C_BLOCK_LAST;\r\nelse\r\nsmbcmd = I801_BLOCK_LAST;\r\n} else {\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA\r\n&& read_write == I2C_SMBUS_READ)\r\nsmbcmd = I801_I2C_BLOCK_DATA;\r\nelse\r\nsmbcmd = I801_BLOCK_DATA;\r\n}\r\noutb_p(smbcmd | ENABLE_INT9, SMBHSTCNT(priv));\r\nif (i == 1)\r\noutb_p(inb(SMBHSTCNT(priv)) | I801_START,\r\nSMBHSTCNT(priv));\r\ntimeout = 0;\r\ndo {\r\nusleep_range(250, 500);\r\nstatus = inb_p(SMBHSTSTS(priv));\r\n} while ((!(status & SMBHSTSTS_BYTE_DONE))\r\n&& (timeout++ < MAX_RETRIES));\r\nresult = i801_check_post(priv, status, timeout > MAX_RETRIES);\r\nif (result < 0)\r\nreturn result;\r\nif (i == 1 && read_write == I2C_SMBUS_READ\r\n&& command != I2C_SMBUS_I2C_BLOCK_DATA) {\r\nlen = inb_p(SMBHSTDAT0(priv));\r\nif (len < 1 || len > I2C_SMBUS_BLOCK_MAX) {\r\ndev_err(&priv->pci_dev->dev,\r\n"Illegal SMBus block read size %d\n",\r\nlen);\r\nwhile (inb_p(SMBHSTSTS(priv)) &\r\nSMBHSTSTS_HOST_BUSY)\r\noutb_p(SMBHSTSTS_BYTE_DONE,\r\nSMBHSTSTS(priv));\r\noutb_p(SMBHSTSTS_INTR, SMBHSTSTS(priv));\r\nreturn -EPROTO;\r\n}\r\ndata->block[0] = len;\r\n}\r\nif (read_write == I2C_SMBUS_READ)\r\ndata->block[i] = inb_p(SMBBLKDAT(priv));\r\nif (read_write == I2C_SMBUS_WRITE && i+1 <= len)\r\noutb_p(data->block[i+1], SMBBLKDAT(priv));\r\noutb_p(SMBHSTSTS_BYTE_DONE | SMBHSTSTS_INTR, SMBHSTSTS(priv));\r\n}\r\nreturn 0;\r\n}\r\nstatic int i801_set_block_buffer_mode(struct i801_priv *priv)\r\n{\r\noutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_E32B, SMBAUXCTL(priv));\r\nif ((inb_p(SMBAUXCTL(priv)) & SMBAUXCTL_E32B) == 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int i801_block_transaction(struct i801_priv *priv,\r\nunion i2c_smbus_data *data, char read_write,\r\nint command, int hwpec)\r\n{\r\nint result = 0;\r\nunsigned char hostc;\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA) {\r\nif (read_write == I2C_SMBUS_WRITE) {\r\npci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);\r\npci_write_config_byte(priv->pci_dev, SMBHSTCFG,\r\nhostc | SMBHSTCFG_I2C_EN);\r\n} else if (!(priv->features & FEATURE_I2C_BLOCK_READ)) {\r\ndev_err(&priv->pci_dev->dev,\r\n"I2C block read is unsupported!\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nif (read_write == I2C_SMBUS_WRITE\r\n|| command == I2C_SMBUS_I2C_BLOCK_DATA) {\r\nif (data->block[0] < 1)\r\ndata->block[0] = 1;\r\nif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\r\ndata->block[0] = I2C_SMBUS_BLOCK_MAX;\r\n} else {\r\ndata->block[0] = 32;\r\n}\r\nif ((priv->features & FEATURE_BLOCK_BUFFER)\r\n&& command != I2C_SMBUS_I2C_BLOCK_DATA\r\n&& i801_set_block_buffer_mode(priv) == 0)\r\nresult = i801_block_transaction_by_block(priv, data,\r\nread_write, hwpec);\r\nelse\r\nresult = i801_block_transaction_byte_by_byte(priv, data,\r\nread_write,\r\ncommand, hwpec);\r\nif (result == 0 && hwpec)\r\ni801_wait_hwpec(priv);\r\nif (command == I2C_SMBUS_I2C_BLOCK_DATA\r\n&& read_write == I2C_SMBUS_WRITE) {\r\npci_write_config_byte(priv->pci_dev, SMBHSTCFG, hostc);\r\n}\r\nreturn result;\r\n}\r\nstatic s32 i801_access(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write, u8 command,\r\nint size, union i2c_smbus_data *data)\r\n{\r\nint hwpec;\r\nint block = 0;\r\nint ret, xact = 0;\r\nstruct i801_priv *priv = i2c_get_adapdata(adap);\r\nhwpec = (priv->features & FEATURE_SMBUS_PEC) && (flags & I2C_CLIENT_PEC)\r\n&& size != I2C_SMBUS_QUICK\r\n&& size != I2C_SMBUS_I2C_BLOCK_DATA;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\nxact = I801_QUICK;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(command, SMBHSTCMD(priv));\r\nxact = I801_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\noutb_p(command, SMBHSTCMD(priv));\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(data->byte, SMBHSTDAT0(priv));\r\nxact = I801_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\noutb_p(command, SMBHSTCMD(priv));\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb_p(data->word & 0xff, SMBHSTDAT0(priv));\r\noutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1(priv));\r\n}\r\nxact = I801_WORD_DATA;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\noutb_p(((addr & 0x7f) << 1) | (read_write & 0x01),\r\nSMBHSTADD(priv));\r\noutb_p(command, SMBHSTCMD(priv));\r\nblock = 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\noutb_p((addr & 0x7f) << 1, SMBHSTADD(priv));\r\nif (read_write == I2C_SMBUS_READ) {\r\noutb_p(command, SMBHSTDAT1(priv));\r\n} else\r\noutb_p(command, SMBHSTCMD(priv));\r\nblock = 1;\r\nbreak;\r\ndefault:\r\ndev_err(&priv->pci_dev->dev, "Unsupported transaction %d\n",\r\nsize);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (hwpec)\r\noutb_p(inb_p(SMBAUXCTL(priv)) | SMBAUXCTL_CRC, SMBAUXCTL(priv));\r\nelse\r\noutb_p(inb_p(SMBAUXCTL(priv)) & (~SMBAUXCTL_CRC),\r\nSMBAUXCTL(priv));\r\nif (block)\r\nret = i801_block_transaction(priv, data, read_write, size,\r\nhwpec);\r\nelse\r\nret = i801_transaction(priv, xact | ENABLE_INT9);\r\nif (hwpec || block)\r\noutb_p(inb_p(SMBAUXCTL(priv)) &\r\n~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));\r\nif (block)\r\nreturn ret;\r\nif (ret)\r\nreturn ret;\r\nif ((read_write == I2C_SMBUS_WRITE) || (xact == I801_QUICK))\r\nreturn 0;\r\nswitch (xact & 0x7f) {\r\ncase I801_BYTE:\r\ncase I801_BYTE_DATA:\r\ndata->byte = inb_p(SMBHSTDAT0(priv));\r\nbreak;\r\ncase I801_WORD_DATA:\r\ndata->word = inb_p(SMBHSTDAT0(priv)) +\r\n(inb_p(SMBHSTDAT1(priv)) << 8);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 i801_func(struct i2c_adapter *adapter)\r\n{\r\nstruct i801_priv *priv = i2c_get_adapdata(adapter);\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_WRITE_I2C_BLOCK |\r\n((priv->features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) |\r\n((priv->features & FEATURE_I2C_BLOCK_READ) ?\r\nI2C_FUNC_SMBUS_READ_I2C_BLOCK : 0);\r\n}\r\nstatic __init const void __iomem *bios_signature(const void __iomem *bios)\r\n{\r\nssize_t offset;\r\nconst unsigned char signature[] = "FJKEYINF";\r\nfor (offset = 0; offset < 0x10000; offset += 0x10) {\r\nif (check_signature(bios + offset, signature,\r\nsizeof(signature)-1))\r\nreturn bios + offset;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __init input_apanel_init(void)\r\n{\r\nvoid __iomem *bios;\r\nconst void __iomem *p;\r\nbios = ioremap(0xF0000, 0x10000);\r\np = bios_signature(bios);\r\nif (p) {\r\napanel_addr = readb(p + 8 + 3) >> 1;\r\n}\r\niounmap(bios);\r\n}\r\nstatic void __devinit dmi_check_onboard_device(u8 type, const char *name,\r\nstruct i2c_adapter *adap)\r\n{\r\nint i;\r\nstruct i2c_board_info info;\r\nfor (i = 0; i < ARRAY_SIZE(dmi_devices); i++) {\r\nif ((type & ~0x80) != dmi_devices[i].type)\r\ncontinue;\r\nif (strcasecmp(name, dmi_devices[i].name))\r\ncontinue;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = dmi_devices[i].i2c_addr;\r\nstrlcpy(info.type, dmi_devices[i].i2c_type, I2C_NAME_SIZE);\r\ni2c_new_device(adap, &info);\r\nbreak;\r\n}\r\n}\r\nstatic void __devinit dmi_check_onboard_devices(const struct dmi_header *dm,\r\nvoid *adap)\r\n{\r\nint i, count;\r\nif (dm->type != 10)\r\nreturn;\r\ncount = (dm->length - sizeof(struct dmi_header)) / 2;\r\nfor (i = 0; i < count; i++) {\r\nconst u8 *d = (char *)(dm + 1) + (i * 2);\r\nconst char *name = ((char *) dm) + dm->length;\r\nu8 type = d[0];\r\nu8 s = d[1];\r\nif (!s)\r\ncontinue;\r\ns--;\r\nwhile (s > 0 && name[0]) {\r\nname += strlen(name) + 1;\r\ns--;\r\n}\r\nif (name[0] == 0)\r\ncontinue;\r\ndmi_check_onboard_device(type, name, adap);\r\n}\r\n}\r\nstatic void __devinit i801_probe_optional_slaves(struct i801_priv *priv)\r\n{\r\nif (priv->features & FEATURE_IDF)\r\nreturn;\r\nif (apanel_addr) {\r\nstruct i2c_board_info info;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ninfo.addr = apanel_addr;\r\nstrlcpy(info.type, "fujitsu_apanel", I2C_NAME_SIZE);\r\ni2c_new_device(&priv->adapter, &info);\r\n}\r\nif (dmi_name_in_vendors("FUJITSU"))\r\ndmi_walk(dmi_check_onboard_devices, &priv->adapter);\r\n}\r\nstatic void __init input_apanel_init(void) {}\r\nstatic void __devinit i801_probe_optional_slaves(struct i801_priv *priv) {}\r\nstatic int __devinit i801_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned char temp;\r\nint err, i;\r\nstruct i801_priv *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ni2c_set_adapdata(&priv->adapter, priv);\r\npriv->adapter.owner = THIS_MODULE;\r\npriv->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\npriv->adapter.algo = &smbus_algorithm;\r\npriv->pci_dev = dev;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF0:\r\ncase PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF1:\r\ncase PCI_DEVICE_ID_INTEL_PATSBURG_SMBUS_IDF2:\r\npriv->features |= FEATURE_IDF;\r\ndefault:\r\npriv->features |= FEATURE_I2C_BLOCK_READ;\r\ncase PCI_DEVICE_ID_INTEL_82801DB_3:\r\npriv->features |= FEATURE_SMBUS_PEC;\r\npriv->features |= FEATURE_BLOCK_BUFFER;\r\ncase PCI_DEVICE_ID_INTEL_82801CA_3:\r\ncase PCI_DEVICE_ID_INTEL_82801BA_2:\r\ncase PCI_DEVICE_ID_INTEL_82801AB_3:\r\ncase PCI_DEVICE_ID_INTEL_82801AA_3:\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(i801_feature_names); i++) {\r\nif (priv->features & disable_features & (1 << i))\r\ndev_notice(&dev->dev, "%s disabled by user\n",\r\ni801_feature_names[i]);\r\n}\r\npriv->features &= ~disable_features;\r\nerr = pci_enable_device(dev);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to enable SMBus PCI device (%d)\n",\r\nerr);\r\ngoto exit;\r\n}\r\npriv->smba = pci_resource_start(dev, SMBBAR);\r\nif (!priv->smba) {\r\ndev_err(&dev->dev, "SMBus base address uninitialized, "\r\n"upgrade BIOS\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nerr = acpi_check_resource_conflict(&dev->resource[SMBBAR]);\r\nif (err) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nerr = pci_request_region(dev, SMBBAR, i801_driver.name);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to request SMBus region "\r\n"0x%lx-0x%Lx\n", priv->smba,\r\n(unsigned long long)pci_resource_end(dev, SMBBAR));\r\ngoto exit;\r\n}\r\npci_read_config_byte(priv->pci_dev, SMBHSTCFG, &temp);\r\npriv->original_hstcfg = temp;\r\ntemp &= ~SMBHSTCFG_I2C_EN;\r\nif (!(temp & SMBHSTCFG_HST_EN)) {\r\ndev_info(&dev->dev, "Enabling SMBus device\n");\r\ntemp |= SMBHSTCFG_HST_EN;\r\n}\r\npci_write_config_byte(priv->pci_dev, SMBHSTCFG, temp);\r\nif (temp & SMBHSTCFG_SMB_SMI_EN)\r\ndev_dbg(&dev->dev, "SMBus using interrupt SMI#\n");\r\nelse\r\ndev_dbg(&dev->dev, "SMBus using PCI Interrupt\n");\r\nif (priv->features & (FEATURE_SMBUS_PEC | FEATURE_BLOCK_BUFFER))\r\noutb_p(inb_p(SMBAUXCTL(priv)) &\r\n~(SMBAUXCTL_CRC | SMBAUXCTL_E32B), SMBAUXCTL(priv));\r\npriv->adapter.dev.parent = &dev->dev;\r\npriv->adapter.retries = 3;\r\nsnprintf(priv->adapter.name, sizeof(priv->adapter.name),\r\n"SMBus I801 adapter at %04lx", priv->smba);\r\nerr = i2c_add_adapter(&priv->adapter);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to add SMBus adapter\n");\r\ngoto exit_release;\r\n}\r\ni801_probe_optional_slaves(priv);\r\npci_set_drvdata(dev, priv);\r\nreturn 0;\r\nexit_release:\r\npci_release_region(dev, SMBBAR);\r\nexit:\r\nkfree(priv);\r\nreturn err;\r\n}\r\nstatic void __devexit i801_remove(struct pci_dev *dev)\r\n{\r\nstruct i801_priv *priv = pci_get_drvdata(dev);\r\ni2c_del_adapter(&priv->adapter);\r\npci_write_config_byte(dev, SMBHSTCFG, priv->original_hstcfg);\r\npci_release_region(dev, SMBBAR);\r\npci_set_drvdata(dev, NULL);\r\nkfree(priv);\r\n}\r\nstatic int i801_suspend(struct pci_dev *dev, pm_message_t mesg)\r\n{\r\nstruct i801_priv *priv = pci_get_drvdata(dev);\r\npci_save_state(dev);\r\npci_write_config_byte(dev, SMBHSTCFG, priv->original_hstcfg);\r\npci_set_power_state(dev, pci_choose_state(dev, mesg));\r\nreturn 0;\r\n}\r\nstatic int i801_resume(struct pci_dev *dev)\r\n{\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nreturn pci_enable_device(dev);\r\n}\r\nstatic int __init i2c_i801_init(void)\r\n{\r\nif (dmi_name_in_vendors("FUJITSU"))\r\ninput_apanel_init();\r\nreturn pci_register_driver(&i801_driver);\r\n}\r\nstatic void __exit i2c_i801_exit(void)\r\n{\r\npci_unregister_driver(&i801_driver);\r\n}
