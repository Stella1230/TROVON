int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,\r\nunsigned int dw_PCIBoardEepromAddress,\r\nunsigned short w_EepromStartAddress, unsigned short *pw_DataRead)\r\n{\r\nunsigned int dw_eeprom_busy = 0;\r\nint i_Counter = 0;\r\nint i_WordCounter;\r\nint i;\r\nunsigned char pb_ReadByte[1];\r\nunsigned char b_ReadLowByte = 0;\r\nunsigned char b_ReadHighByte = 0;\r\nunsigned char b_SelectedAddressLow = 0;\r\nunsigned char b_SelectedAddressHigh = 0;\r\nunsigned short w_ReadWord = 0;\r\nfor (i_WordCounter = 0; i_WordCounter < i_NbOfWordsToRead;\r\ni_WordCounter++) {\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\nfor (i_Counter = 0; i_Counter < 2; i_Counter++) {\r\nb_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;\r\nb_SelectedAddressHigh = (w_EepromStartAddress + i_Counter) / 256;\r\noutb(NVCMD_LOAD_LOW,\r\ndw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +\r\n3);\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\noutb(b_SelectedAddressLow,\r\ndw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +\r\n2);\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\noutb(NVCMD_LOAD_HIGH,\r\ndw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +\r\n3);\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\noutb(b_SelectedAddressHigh,\r\ndw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +\r\n2);\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\noutb(NVCMD_BEGIN_READ,\r\ndw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +\r\n3);\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\n*pb_ReadByte =\r\ninb(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR + 2);\r\ndo {\r\ndw_eeprom_busy =\r\ninl(dw_PCIBoardEepromAddress +\r\nAMCC_OP_REG_MCSR);\r\ndw_eeprom_busy = dw_eeprom_busy & EEPROM_BUSY;\r\n} while (dw_eeprom_busy == EEPROM_BUSY);\r\nif (i_Counter == 0)\r\nb_ReadLowByte = pb_ReadByte[0];\r\nelse\r\nb_ReadHighByte = pb_ReadByte[0];\r\nmsleep(1);\r\n}\r\nw_ReadWord =\r\n(b_ReadLowByte | (((unsigned short)b_ReadHighByte) *\r\n256));\r\npw_DataRead[i_WordCounter] = w_ReadWord;\r\nw_EepromStartAddress += 2;\r\n}\r\nreturn 0;\r\n}\r\nvoid v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,\r\nstruct str_BoardInfos *BoardInformations)\r\n{\r\nunsigned short w_AnalogInputMainHeaderAddress;\r\nunsigned short w_AnalogInputComponentAddress;\r\nunsigned short w_NumberOfModuls = 0;\r\nunsigned short w_CurrentSources[2];\r\nunsigned short w_ModulCounter = 0;\r\nunsigned short w_FirstHeaderSize = 0;\r\nunsigned short w_NumberOfInputs = 0;\r\nunsigned short w_CJCFlag = 0;\r\nunsigned short w_NumberOfGainValue = 0;\r\nunsigned short w_SingleHeaderAddress = 0;\r\nunsigned short w_SingleHeaderSize = 0;\r\nunsigned short w_Input = 0;\r\nunsigned short w_GainFactorAddress = 0;\r\nunsigned short w_GainFactorValue[2];\r\nunsigned short w_GainIndex = 0;\r\nunsigned short w_GainValue = 0;\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, 0x116,\r\n&w_AnalogInputMainHeaderAddress);\r\nw_AnalogInputMainHeaderAddress = w_AnalogInputMainHeaderAddress + 0x100;\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_AnalogInputMainHeaderAddress + 0x02,\r\n&w_NumberOfModuls);\r\nfor (w_ModulCounter = 0; w_ModulCounter < w_NumberOfModuls;\r\nw_ModulCounter++) {\r\nw_AnalogInputComponentAddress =\r\nw_AnalogInputMainHeaderAddress +\r\n(w_FirstHeaderSize * w_ModulCounter) + 0x04;\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_AnalogInputComponentAddress,\r\n&w_FirstHeaderSize);\r\nw_FirstHeaderSize = w_FirstHeaderSize >> 4;\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x06,\r\n&w_NumberOfInputs);\r\nw_NumberOfInputs = w_NumberOfInputs >> 4;\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x08,\r\n&w_CJCFlag);\r\nw_CJCFlag = (w_CJCFlag >> 3) & 0x1;\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x44,\r\n&w_NumberOfGainValue);\r\nw_NumberOfGainValue = w_NumberOfGainValue & 0xFF;\r\nw_SingleHeaderAddress =\r\nw_AnalogInputComponentAddress + 0x46 +\r\n(((w_NumberOfGainValue / 16) + 1) * 2) +\r\n(6 * w_NumberOfGainValue) +\r\n(4 * (((w_NumberOfGainValue / 16) + 1) * 2));\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_SingleHeaderAddress,\r\n&w_SingleHeaderSize);\r\nw_SingleHeaderSize = w_SingleHeaderSize >> 4;\r\nw_GainFactorAddress = w_AnalogInputComponentAddress;\r\nfor (w_GainIndex = 0; w_GainIndex < w_NumberOfGainValue;\r\nw_GainIndex++) {\r\ni_AddiHeaderRW_ReadEeprom(1,\r\ndw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 70 + (2 * (1 + (w_NumberOfGainValue / 16))) + (0x02 * w_GainIndex),\r\n&w_GainValue);\r\nBoardInformations->s_Module[w_ModulCounter].\r\nw_GainValue[w_GainIndex] = w_GainValue;\r\n# ifdef PRINT_INFO\r\nprintk("\n Gain value = %d",\r\nBoardInformations->s_Module[w_ModulCounter].\r\nw_GainValue[w_GainIndex]);\r\n# endif\r\ni_AddiHeaderRW_ReadEeprom(2,\r\ndw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 70 + ((2 * w_NumberOfGainValue) + (2 * (1 + (w_NumberOfGainValue / 16)))) + (0x04 * w_GainIndex),\r\nw_GainFactorValue);\r\nBoardInformations->s_Module[w_ModulCounter].\r\nul_GainFactor[w_GainIndex] =\r\n(w_GainFactorValue[1] << 16) +\r\nw_GainFactorValue[0];\r\n# ifdef PRINT_INFO\r\nprintk("\n w_GainFactorValue [%d] = %lu", w_GainIndex,\r\nBoardInformations->s_Module[w_ModulCounter].\r\nul_GainFactor[w_GainIndex]);\r\n# endif\r\n}\r\nfor (w_Input = 0; w_Input < w_NumberOfInputs; w_Input++) {\r\ni_AddiHeaderRW_ReadEeprom(2,\r\ndw_PCIBoardEepromAddress,\r\n(w_Input * w_SingleHeaderSize) +\r\nw_SingleHeaderAddress + 0x0C, w_CurrentSources);\r\nBoardInformations->s_Module[w_ModulCounter].\r\nul_CurrentSource[w_Input] =\r\n(w_CurrentSources[0] +\r\n((w_CurrentSources[1] & 0xFFF) << 16));\r\n# ifdef PRINT_INFO\r\nprintk("\n Current sources [%d] = %lu", w_Input,\r\nBoardInformations->s_Module[w_ModulCounter].\r\nul_CurrentSource[w_Input]);\r\n# endif\r\n}\r\ni_AddiHeaderRW_ReadEeprom(2,\r\ndw_PCIBoardEepromAddress,\r\n(w_Input * w_SingleHeaderSize) + w_SingleHeaderAddress +\r\n0x0C, w_CurrentSources);\r\nBoardInformations->s_Module[w_ModulCounter].\r\nul_CurrentSourceCJC =\r\n(w_CurrentSources[0] +\r\n((w_CurrentSources[1] & 0xFFF) << 16));\r\n# ifdef PRINT_INFO\r\nprintk("\n Current sources CJC = %lu",\r\nBoardInformations->s_Module[w_ModulCounter].\r\nul_CurrentSourceCJC);\r\n# endif\r\n}\r\n}\r\nint i_APCI3200_GetChannelCalibrationValue(struct comedi_device *dev,\r\nunsigned int ui_Channel_num, unsigned int *CJCCurrentSource,\r\nunsigned int *ChannelCurrentSource, unsigned int *ChannelGainFactor)\r\n{\r\nint i_DiffChannel = 0;\r\nint i_Module = 0;\r\n#ifdef PRINT_INFO\r\nprintk("\n Channel = %u", ui_Channel_num);\r\n#endif\r\nif (s_BoardInfos[dev->minor].i_ConnectionType == 1) {\r\nif (ui_Channel_num <= 1)\r\ni_DiffChannel = ui_Channel_num, i_Module = 0;\r\nelse if ((ui_Channel_num >= 2) && (ui_Channel_num <= 3))\r\ni_DiffChannel = ui_Channel_num - 2, i_Module = 1;\r\nelse if ((ui_Channel_num >= 4) && (ui_Channel_num <= 5))\r\ni_DiffChannel = ui_Channel_num - 4, i_Module = 2;\r\nelse if ((ui_Channel_num >= 6) && (ui_Channel_num <= 7))\r\ni_DiffChannel = ui_Channel_num - 6, i_Module = 3;\r\n} else {\r\nif ((ui_Channel_num == 0) || (ui_Channel_num == 1))\r\ni_DiffChannel = 0, i_Module = 0;\r\nelse if ((ui_Channel_num == 2) || (ui_Channel_num == 3))\r\ni_DiffChannel = 1, i_Module = 0;\r\nelse if ((ui_Channel_num == 4) || (ui_Channel_num == 5))\r\ni_DiffChannel = 0, i_Module = 1;\r\nelse if ((ui_Channel_num == 6) || (ui_Channel_num == 7))\r\ni_DiffChannel = 1, i_Module = 1;\r\nelse if ((ui_Channel_num == 8) || (ui_Channel_num == 9))\r\ni_DiffChannel = 0, i_Module = 2;\r\nelse if ((ui_Channel_num == 10) || (ui_Channel_num == 11))\r\ni_DiffChannel = 1, i_Module = 2;\r\nelse if ((ui_Channel_num == 12) || (ui_Channel_num == 13))\r\ni_DiffChannel = 0, i_Module = 3;\r\nelse if ((ui_Channel_num == 14) || (ui_Channel_num == 15))\r\ni_DiffChannel = 1, i_Module = 3;\r\n}\r\n*CJCCurrentSource =\r\ns_BoardInfos[dev->minor].s_Module[i_Module].ul_CurrentSourceCJC;\r\n#ifdef PRINT_INFO\r\nprintk("\n CJCCurrentSource = %lu", *CJCCurrentSource);\r\n#endif\r\n*ChannelCurrentSource =\r\ns_BoardInfos[dev->minor].s_Module[i_Module].\r\nul_CurrentSource[i_DiffChannel];\r\n#ifdef PRINT_INFO\r\nprintk("\n ChannelCurrentSource = %lu", *ChannelCurrentSource);\r\n#endif\r\n*ChannelGainFactor =\r\ns_BoardInfos[dev->minor].s_Module[i_Module].\r\nul_GainFactor[s_BoardInfos[dev->minor].i_ADDIDATAGain];\r\n#ifdef PRINT_INFO\r\nprintk("\n ChannelGainFactor = %lu", *ChannelGainFactor);\r\n#endif\r\nreturn 0;\r\n}\r\nint i_APCI3200_ReadDigitalInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Temp = 0;\r\nunsigned int ui_NoOfChannel = 0;\r\nui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nui_Temp = data[0];\r\n*data = inl(devpriv->i_IobaseReserved);\r\nif (ui_Temp == 0) {\r\n*data = (*data >> ui_NoOfChannel) & 0x1;\r\n}\r\nelse {\r\nif (ui_Temp == 1) {\r\nif (data[1] < 0 || data[1] > 1) {\r\nprintk("\nThe port number is in error\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\n*data = (*data >> (2 * data[1])) & 0x3;\r\nbreak;\r\ncase 3:\r\n*data = (*data & 15);\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, " chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported \n");\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_ConfigDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif ((data[0] != 0) && (data[0] != 1)) {\r\ncomedi_error(dev,\r\n"Not a valid Data !!! ,Data should be 1 or 0\n");\r\nreturn -EINVAL;\r\n}\r\nif (data[0]) {\r\ndevpriv->b_OutputMemoryStatus = ADDIDATA_ENABLE;\r\n}\r\nelse {\r\ndevpriv->b_OutputMemoryStatus = ADDIDATA_DISABLE;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_WriteDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Temp = 0, ui_Temp1 = 0;\r\nunsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nif (devpriv->b_OutputMemoryStatus) {\r\nui_Temp = inl(devpriv->i_IobaseAddon);\r\n}\r\nelse {\r\nui_Temp = 0;\r\n}\r\nif (data[3] == 0) {\r\nif (data[1] == 0) {\r\ndata[0] = (data[0] << ui_NoOfChannel) | ui_Temp;\r\noutl(data[0], devpriv->i_IobaseAddon);\r\n}\r\nelse {\r\nif (data[1] == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\ndata[0] =\r\n(data[0] << (2 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 3:\r\ndata[0] = (data[0] | ui_Temp);\r\nbreak;\r\n}\r\noutl(data[0], devpriv->i_IobaseAddon);\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported\n");\r\n}\r\n}\r\n}\r\nelse {\r\nif (data[3] == 1) {\r\nif (data[1] == 0) {\r\ndata[0] = ~data[0] & 0x1;\r\nui_Temp1 = 1;\r\nui_Temp1 = ui_Temp1 << ui_NoOfChannel;\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] = (data[0] << ui_NoOfChannel) ^ 0xf;\r\ndata[0] = data[0] & ui_Temp;\r\noutl(data[0], devpriv->i_IobaseAddon);\r\n}\r\nelse {\r\nif (data[1] == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\ndata[0] = ~data[0] & 0x3;\r\nui_Temp1 = 3;\r\nui_Temp1 =\r\nui_Temp1 << 2 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (2 *\r\ndata\r\n[2])) ^\r\n0xf) & ui_Temp;\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\ncomedi_error(dev,\r\n" chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\noutl(data[0], devpriv->i_IobaseAddon);\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported\n");\r\n}\r\n}\r\n}\r\nelse {\r\nprintk("\nSpecified functionality does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_ReadDigitalOutput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Temp;\r\nunsigned int ui_NoOfChannel;\r\nui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nui_Temp = data[0];\r\n*data = inl(devpriv->i_IobaseAddon);\r\nif (ui_Temp == 0) {\r\n*data = (*data >> ui_NoOfChannel) & 0x1;\r\n}\r\nelse {\r\nif (ui_Temp == 1) {\r\nif (data[1] < 0 || data[1] > 1) {\r\nprintk("\nThe port selection is in error\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\n*data = (*data >> (2 * data[1])) & 3;\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, " chan spec wrong");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported \n");\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_ConfigAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ul_Config = 0, ul_Temp = 0;\r\nunsigned int ui_ChannelNo = 0;\r\nunsigned int ui_Dummy = 0;\r\nint i_err = 0;\r\n#ifdef PRINT_INFO\r\nint i = 0, i2 = 0;\r\n#endif\r\nif (s_BoardInfos[dev->minor].b_StructInitialized != 1) {\r\ns_BoardInfos[dev->minor].i_CJCAvailable = 1;\r\ns_BoardInfos[dev->minor].i_CJCPolarity = 0;\r\ns_BoardInfos[dev->minor].i_CJCGain = 2;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 0;\r\ns_BoardInfos[dev->minor].i_AutoCalibration = 0;\r\ns_BoardInfos[dev->minor].i_ChannelCount = 0;\r\ns_BoardInfos[dev->minor].i_Sum = 0;\r\ns_BoardInfos[dev->minor].ui_Channel_num = 0;\r\ns_BoardInfos[dev->minor].i_Count = 0;\r\ns_BoardInfos[dev->minor].i_Initialised = 0;\r\ns_BoardInfos[dev->minor].b_StructInitialized = 1;\r\ns_BoardInfos[dev->minor].i_ConnectionType = 0;\r\nmemset(s_BoardInfos[dev->minor].s_Module, 0,\r\nsizeof(s_BoardInfos[dev->minor].s_Module[MAX_MODULE]));\r\nv_GetAPCI3200EepromCalibrationValue(devpriv->i_IobaseAmcc,\r\n&s_BoardInfos[dev->minor]);\r\n#ifdef PRINT_INFO\r\nfor (i = 0; i < MAX_MODULE; i++) {\r\nprintk("\n s_Module[%i].ul_CurrentSourceCJC = %lu", i,\r\ns_BoardInfos[dev->minor].s_Module[i].\r\nul_CurrentSourceCJC);\r\nfor (i2 = 0; i2 < 5; i2++) {\r\nprintk("\n s_Module[%i].ul_CurrentSource [%i] = %lu", i, i2, s_BoardInfos[dev->minor].s_Module[i].ul_CurrentSource[i2]);\r\n}\r\nfor (i2 = 0; i2 < 8; i2++) {\r\nprintk("\n s_Module[%i].ul_GainFactor [%i] = %lu", i, i2, s_BoardInfos[dev->minor].s_Module[i].ul_GainFactor[i2]);\r\n}\r\nfor (i2 = 0; i2 < 8; i2++) {\r\nprintk("\n s_Module[%i].w_GainValue [%i] = %u",\r\ni, i2,\r\ns_BoardInfos[dev->minor].s_Module[i].\r\nw_GainValue[i2]);\r\n}\r\n}\r\n#endif\r\n}\r\nif (data[0] != 0 && data[0] != 1 && data[0] != 2) {\r\nprintk("\nThe selection of acquisition type is in error\n");\r\ni_err++;\r\n}\r\nif (data[0] == 1) {\r\nif (data[14] != 0 && data[14] != 1 && data[14] != 2\r\n&& data[14] != 4) {\r\nprintk("\n Error in selection of RTD connection type\n");\r\ni_err++;\r\n}\r\n}\r\nif (data[1] < 0 || data[1] > 7) {\r\nprintk("\nThe selection of gain is in error\n");\r\ni_err++;\r\n}\r\nif (data[2] != 0 && data[2] != 1) {\r\nprintk("\nThe selection of polarity is in error\n");\r\ni_err++;\r\n}\r\nif (data[3] != 0) {\r\nprintk("\nThe selection of offset range is in error\n");\r\ni_err++;\r\n}\r\nif (data[4] != 0 && data[4] != 1) {\r\nprintk("\nThe selection of coupling is in error\n");\r\ni_err++;\r\n}\r\nif (data[5] != 0 && data[5] != 1) {\r\nprintk("\nThe selection of single/differential mode is in error\n");\r\ni_err++;\r\n}\r\nif (data[8] != 0 && data[8] != 1 && data[2] != 2) {\r\nprintk("\nError in selection of functionality\n");\r\n}\r\nif (data[12] == 0 || data[12] == 1) {\r\nif (data[6] != 20 && data[6] != 40 && data[6] != 80\r\n&& data[6] != 160) {\r\nprintk("\nThe selection of conversion time reload value is in error\n");\r\ni_err++;\r\n}\r\nif (data[7] != 2) {\r\nprintk("\nThe selection of conversion time unit is in error\n");\r\ni_err++;\r\n}\r\n}\r\nif (data[9] != 0 && data[9] != 1) {\r\nprintk("\nThe selection of interrupt enable is in error\n");\r\ni_err++;\r\n}\r\nif (data[11] < 0 || data[11] > 4) {\r\nprintk("\nThe selection of module is in error\n");\r\ni_err++;\r\n}\r\nif (data[12] < 0 || data[12] > 3) {\r\nprintk("\nThe selection of singlechannel/scan selection is in error\n");\r\ni_err++;\r\n}\r\nif (data[13] < 0 || data[13] > 16) {\r\nprintk("\nThe selection of number of channels is in error\n");\r\ni_err++;\r\n}\r\ns_BoardInfos[dev->minor].i_ChannelCount = data[13];\r\ns_BoardInfos[dev->minor].i_ScanType = data[12];\r\ns_BoardInfos[dev->minor].i_ADDIDATAPolarity = data[2];\r\ns_BoardInfos[dev->minor].i_ADDIDATAGain = data[1];\r\ns_BoardInfos[dev->minor].i_ADDIDATAConversionTime = data[6];\r\ns_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit = data[7];\r\ns_BoardInfos[dev->minor].i_ADDIDATAType = data[0];\r\ns_BoardInfos[dev->minor].i_ConnectionType = data[5];\r\nmemset(s_BoardInfos[dev->minor].ui_ScanValueArray, 0, (7 + 12) * sizeof(unsigned int));\r\nwhile (s_BoardInfos[dev->minor].i_InterruptFlag == 1) {\r\n#ifndef MSXBOX\r\nudelay(1);\r\n#else\r\nprintk("");\r\n#endif\r\n}\r\nui_ChannelNo = CR_CHAN(insn->chanspec);\r\ns_BoardInfos[dev->minor].i_ChannelNo = ui_ChannelNo;\r\ns_BoardInfos[dev->minor].ui_Channel_num = ui_ChannelNo;\r\nif (data[5] == 0) {\r\nif (ui_ChannelNo < 0 || ui_ChannelNo > 15) {\r\nprintk("\nThe Selection of the channel is in error\n");\r\ni_err++;\r\n}\r\n}\r\nelse {\r\nif (data[14] == 2) {\r\nif (ui_ChannelNo < 0 || ui_ChannelNo > 3) {\r\nprintk("\nThe Selection of the channel is in error\n");\r\ni_err++;\r\n}\r\n}\r\nelse {\r\nif (ui_ChannelNo < 0 || ui_ChannelNo > 7) {\r\nprintk("\nThe Selection of the channel is in error\n");\r\ni_err++;\r\n}\r\n}\r\n}\r\nif (data[12] == 0 || data[12] == 1) {\r\nswitch (data[5]) {\r\ncase 0:\r\nif (ui_ChannelNo >= 0 && ui_ChannelNo <= 3) {\r\ns_BoardInfos[dev->minor].i_Offset = 0;\r\n}\r\nif (ui_ChannelNo >= 4 && ui_ChannelNo <= 7) {\r\ns_BoardInfos[dev->minor].i_Offset = 64;\r\n}\r\nif (ui_ChannelNo >= 8 && ui_ChannelNo <= 11) {\r\ns_BoardInfos[dev->minor].i_Offset = 128;\r\n}\r\nif (ui_ChannelNo >= 12 && ui_ChannelNo <= 15) {\r\ns_BoardInfos[dev->minor].i_Offset = 192;\r\n}\r\nbreak;\r\ncase 1:\r\nif (data[14] == 2) {\r\nif (ui_ChannelNo == 0) {\r\ns_BoardInfos[dev->minor].i_Offset = 0;\r\n}\r\nif (ui_ChannelNo == 1) {\r\ns_BoardInfos[dev->minor].i_Offset = 64;\r\n}\r\nif (ui_ChannelNo == 2) {\r\ns_BoardInfos[dev->minor].i_Offset = 128;\r\n}\r\nif (ui_ChannelNo == 3) {\r\ns_BoardInfos[dev->minor].i_Offset = 192;\r\n}\r\ns_BoardInfos[dev->minor].i_ChannelNo = 0;\r\nui_ChannelNo = 0;\r\nbreak;\r\n}\r\nif (ui_ChannelNo >= 0 && ui_ChannelNo <= 1) {\r\ns_BoardInfos[dev->minor].i_Offset = 0;\r\n}\r\nif (ui_ChannelNo >= 2 && ui_ChannelNo <= 3) {\r\ns_BoardInfos[dev->minor].i_ChannelNo =\r\ns_BoardInfos[dev->minor].i_ChannelNo -\r\n2;\r\ns_BoardInfos[dev->minor].i_Offset = 64;\r\nui_ChannelNo = ui_ChannelNo - 2;\r\n}\r\nif (ui_ChannelNo >= 4 && ui_ChannelNo <= 5) {\r\ns_BoardInfos[dev->minor].i_ChannelNo =\r\ns_BoardInfos[dev->minor].i_ChannelNo -\r\n4;\r\ns_BoardInfos[dev->minor].i_Offset = 128;\r\nui_ChannelNo = ui_ChannelNo - 4;\r\n}\r\nif (ui_ChannelNo >= 6 && ui_ChannelNo <= 7) {\r\ns_BoardInfos[dev->minor].i_ChannelNo =\r\ns_BoardInfos[dev->minor].i_ChannelNo -\r\n6;\r\ns_BoardInfos[dev->minor].i_Offset = 192;\r\nui_ChannelNo = ui_ChannelNo - 6;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\n This selection of polarity does not exist\n");\r\ni_err++;\r\n}\r\n}\r\nelse {\r\nswitch (data[11]) {\r\ncase 1:\r\ns_BoardInfos[dev->minor].i_Offset = 0;\r\nbreak;\r\ncase 2:\r\ns_BoardInfos[dev->minor].i_Offset = 64;\r\nbreak;\r\ncase 3:\r\ns_BoardInfos[dev->minor].i_Offset = 128;\r\nbreak;\r\ncase 4:\r\ns_BoardInfos[dev->minor].i_Offset = 192;\r\nbreak;\r\ndefault:\r\nprintk("\nError in module selection\n");\r\ni_err++;\r\n}\r\n}\r\nif (i_err) {\r\ni_APCI3200_Reset(dev);\r\nreturn -EINVAL;\r\n}\r\nif (s_BoardInfos[dev->minor].i_ScanType != 1) {\r\ns_BoardInfos[dev->minor].i_Count = 0;\r\ns_BoardInfos[dev->minor].i_Sum = 0;\r\n}\r\nul_Config =\r\ndata[1] | (data[2] << 6) | (data[5] << 7) | (data[3] << 8) |\r\n(data[4] << 9);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0 | ui_ChannelNo,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 0x4);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0, devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 0x0);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ul_Config,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 0x0);\r\nul_Temp = inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((ul_Temp & 0xFFF9FFFF),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nif (data[9] == 1) {\r\ndevpriv->tsk_Current = current;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 1;\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 0;\r\n}\r\ns_BoardInfos[dev->minor].i_Initialised = 1;\r\nif (s_BoardInfos[dev->minor].i_ScanType == 1)\r\n{\r\ns_BoardInfos[dev->minor].i_Sum =\r\ns_BoardInfos[dev->minor].i_Sum + 1;\r\ninsn->unused[0] = 0;\r\ni_APCI3200_ReadAnalogInput(dev, s, insn, &ui_Dummy);\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_ReadAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_DummyValue = 0;\r\nint i_ConvertCJCCalibration;\r\nint i = 0;\r\nif (s_BoardInfos[dev->minor].i_Initialised == 0)\r\n{\r\ni_APCI3200_Reset(dev);\r\nreturn -EINVAL;\r\n}\r\n#ifdef PRINT_INFO\r\nprintk("\n insn->unused[0] = %i", insn->unused[0]);\r\n#endif\r\nswitch (insn->unused[0]) {\r\ncase 0:\r\ni_APCI3200_Read1AnalogInputChannel(dev, s, insn,\r\n&ui_DummyValue);\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->minor].\r\ni_Count + 0] = ui_DummyValue;\r\ni_APCI3200_GetChannelCalibrationValue(dev,\r\ns_BoardInfos[dev->minor].ui_Channel_num,\r\n&s_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->minor].\r\ni_Count + 6],\r\n&s_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->minor].\r\ni_Count + 7],\r\n&s_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->minor].\r\ni_Count + 8]);\r\n#ifdef PRINT_INFO\r\nprintk("\n s_BoardInfos [dev->minor].ui_InterruptChannelValue[s_BoardInfos [dev->minor].i_Count+6] = %lu", s_BoardInfos[dev->minor].ui_InterruptChannelValue[s_BoardInfos[dev->minor].i_Count + 6]);\r\nprintk("\n s_BoardInfos [dev->minor].ui_InterruptChannelValue[s_BoardInfos [dev->minor].i_Count+7] = %lu", s_BoardInfos[dev->minor].ui_InterruptChannelValue[s_BoardInfos[dev->minor].i_Count + 7]);\r\nprintk("\n s_BoardInfos [dev->minor].ui_InterruptChannelValue[s_BoardInfos [dev->minor].i_Count+8] = %lu", s_BoardInfos[dev->minor].ui_InterruptChannelValue[s_BoardInfos[dev->minor].i_Count + 8]);\r\n#endif\r\nif ((s_BoardInfos[dev->minor].i_ADDIDATAType == 2)\r\n&& (s_BoardInfos[dev->minor].i_InterruptFlag == FALSE)\r\n&& (s_BoardInfos[dev->minor].i_CJCAvailable == 1))\r\n{\r\ni_APCI3200_ReadCJCValue(dev, &ui_DummyValue);\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->\r\nminor].i_Count + 3] = ui_DummyValue;\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->\r\nminor].i_Count + 3] = 0;\r\n}\r\nif ((s_BoardInfos[dev->minor].i_AutoCalibration == FALSE)\r\n&& (s_BoardInfos[dev->minor].i_InterruptFlag == FALSE))\r\n{\r\ni_APCI3200_ReadCalibrationOffsetValue(dev,\r\n&ui_DummyValue);\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->\r\nminor].i_Count + 1] = ui_DummyValue;\r\ni_APCI3200_ReadCalibrationGainValue(dev,\r\n&ui_DummyValue);\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos[dev->\r\nminor].i_Count + 2] = ui_DummyValue;\r\n}\r\nif ((s_BoardInfos[dev->minor].i_ADDIDATAType == 2)\r\n&& (s_BoardInfos[dev->minor].i_InterruptFlag == FALSE)\r\n&& (s_BoardInfos[dev->minor].i_CJCAvailable == 1))\r\n{\r\nif (s_BoardInfos[dev->minor].i_CJCPolarity !=\r\ns_BoardInfos[dev->minor].i_ADDIDATAPolarity)\r\n{\r\ni_ConvertCJCCalibration = 1;\r\n}\r\nelse {\r\nif (s_BoardInfos[dev->minor].i_CJCGain ==\r\ns_BoardInfos[dev->minor].i_ADDIDATAGain)\r\n{\r\ni_ConvertCJCCalibration = 0;\r\n}\r\nelse {\r\ni_ConvertCJCCalibration = 1;\r\n}\r\n}\r\nif (i_ConvertCJCCalibration == 1) {\r\ni_APCI3200_ReadCJCCalOffset(dev,\r\n&ui_DummyValue);\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos\r\n[dev->minor].i_Count + 4] =\r\nui_DummyValue;\r\ni_APCI3200_ReadCJCCalGain(dev, &ui_DummyValue);\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos\r\n[dev->minor].i_Count + 5] =\r\nui_DummyValue;\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos\r\n[dev->minor].i_Count + 4] = 0;\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[s_BoardInfos\r\n[dev->minor].i_Count + 5] = 0;\r\n}\r\n}\r\nif (s_BoardInfos[dev->minor].i_ScanType != 1) {\r\ns_BoardInfos[dev->minor].i_Count = 0;\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].i_Count =\r\ns_BoardInfos[dev->minor].i_Count + 9;\r\n}\r\nif ((s_BoardInfos[dev->minor].i_ScanType == 1)\r\n&& (s_BoardInfos[dev->minor].i_InterruptFlag == 1)) {\r\ns_BoardInfos[dev->minor].i_Count =\r\ns_BoardInfos[dev->minor].i_Count - 9;\r\n}\r\nif (s_BoardInfos[dev->minor].i_ScanType == 0) {\r\n#ifdef PRINT_INFO\r\nprintk("\n data[0]= s_BoardInfos [dev->minor].ui_InterruptChannelValue[0];");\r\n#endif\r\ndata[0] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[0];\r\ndata[1] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[1];\r\ndata[2] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[2];\r\ndata[3] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[3];\r\ndata[4] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[4];\r\ndata[5] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[5];\r\ni_APCI3200_GetChannelCalibrationValue(dev,\r\ns_BoardInfos[dev->minor].ui_Channel_num,\r\n&data[6], &data[7], &data[8]);\r\n}\r\nbreak;\r\ncase 1:\r\nfor (i = 0; i < insn->n; i++) {\r\ndata[i] =\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue[i];\r\n}\r\ns_BoardInfos[dev->minor].i_Count = 0;\r\ns_BoardInfos[dev->minor].i_Sum = 0;\r\nif (s_BoardInfos[dev->minor].i_ScanType == 1) {\r\ns_BoardInfos[dev->minor].i_Initialised = 0;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 0;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe parameters passed are in error\n");\r\ni_APCI3200_Reset(dev);\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_Read1AnalogInputChannel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_EOC = 0;\r\nunsigned int ui_ChannelNo = 0;\r\nunsigned int ui_CommandRegister = 0;\r\nui_ChannelNo = s_BoardInfos[dev->minor].i_ChannelNo;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0 | s_BoardInfos[dev->minor].i_ChannelNo,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 0x4);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nui_CommandRegister = ui_ChannelNo | (ui_ChannelNo << 8) | 0x80000;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_ENABLE) {\r\nui_CommandRegister = ui_CommandRegister | 0x00100000;\r\n}\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_CommandRegister,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_DISABLE) {\r\ndo {\r\nui_EOC = inl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 20) & 1;\r\n} while (ui_EOC != 1);\r\ndata[0] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int ui_Temp = 0, ui_EOC = 0;\r\nunsigned int ui_CommandRegister = 0;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nui_Temp = inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((ui_Temp | 0x00020000),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nui_CommandRegister = 0;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_ENABLE) {\r\nui_CommandRegister = ui_CommandRegister | 0x00100000;\r\n}\r\nui_CommandRegister = ui_CommandRegister | 0x00080000;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_CommandRegister,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_DISABLE) {\r\ndo {\r\nui_EOC = inl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 20) & 1;\r\n} while (ui_EOC != 1);\r\ndata[0] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_ReadCalibrationGainValue(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int ui_EOC = 0;\r\nint ui_CommandRegister = 0;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0x00040000,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nui_CommandRegister = 0;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_ENABLE) {\r\nui_CommandRegister = ui_CommandRegister | 0x00100000;\r\n}\r\nui_CommandRegister = ui_CommandRegister | 0x00080000;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_CommandRegister,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_DISABLE) {\r\ndo {\r\nui_EOC = inl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 20) & 1;\r\n} while (ui_EOC != 1);\r\ndata[0] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_ReadCJCValue(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int ui_EOC = 0;\r\nint ui_CommandRegister = 0;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0x00000400,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 4);\r\nui_CommandRegister = 0;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_ENABLE) {\r\nui_CommandRegister = ui_CommandRegister | 0x00100000;\r\n}\r\nui_CommandRegister = ui_CommandRegister | 0x00080000;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_CommandRegister,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_DISABLE) {\r\ndo {\r\nui_EOC = inl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 20) & 1;\r\n} while (ui_EOC != 1);\r\ndata[0] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_ReadCJCCalOffset(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int ui_EOC = 0;\r\nint ui_CommandRegister = 0;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0x00000400,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 4);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0x00020000,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nui_CommandRegister = 0;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_ENABLE) {\r\nui_CommandRegister = ui_CommandRegister | 0x00100000;\r\n}\r\nui_CommandRegister = ui_CommandRegister | 0x00080000;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_CommandRegister,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_DISABLE) {\r\ndo {\r\nui_EOC = inl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 20) & 1;\r\n} while (ui_EOC != 1);\r\ndata[0] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_ReadCJCCalGain(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int ui_EOC = 0;\r\nint ui_CommandRegister = 0;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTimeUnit,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(s_BoardInfos[dev->minor].i_ADDIDATAConversionTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0x00000400,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 4);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(0x00040000,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nui_CommandRegister = 0;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_ENABLE) {\r\nui_CommandRegister = ui_CommandRegister | 0x00100000;\r\n}\r\nui_CommandRegister = ui_CommandRegister | 0x00080000;\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_CommandRegister,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == ADDIDATA_DISABLE) {\r\ndo {\r\nui_EOC = inl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 20) & 1;\r\n} while (ui_EOC != 1);\r\ndata[0] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_InsnBits_AnalogInput_Test(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int ui_Configuration = 0;\r\nint i_Temp;\r\nif (s_BoardInfos[dev->minor].i_Initialised == 0) {\r\ni_APCI3200_Reset(dev);\r\nreturn -EINVAL;\r\n}\r\nif (data[0] != 0 && data[0] != 1) {\r\nprintk("\nError in selection of functionality\n");\r\ni_APCI3200_Reset(dev);\r\nreturn -EINVAL;\r\n}\r\nif (data[0] == 1)\r\n{\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].\r\ni_Offset + 12) >> 19) & 1) !=\r\n1) ;\r\noutl((0x00001000 | s_BoardInfos[dev->minor].i_ChannelNo),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n4);\r\ni_Temp = s_BoardInfos[dev->minor].i_InterruptFlag;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = ADDIDATA_DISABLE;\r\ni_APCI3200_Read1AnalogInputChannel(dev, s, insn, data);\r\nif (s_BoardInfos[dev->minor].i_AutoCalibration == FALSE) {\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].\r\ni_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((0x00001000 | s_BoardInfos[dev->minor].\r\ni_ChannelNo),\r\ndevpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 4);\r\ndata++;\r\ni_APCI3200_ReadCalibrationOffsetValue(dev, data);\r\ndata++;\r\ni_APCI3200_ReadCalibrationGainValue(dev, data);\r\n}\r\n} else {\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].\r\ni_Offset + 12) >> 19) & 1) !=\r\n1) ;\r\noutl((0x00000800 | s_BoardInfos[dev->minor].i_ChannelNo),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n4);\r\nui_Configuration =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 0);\r\ni_Temp = s_BoardInfos[dev->minor].i_InterruptFlag;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = ADDIDATA_DISABLE;\r\ni_APCI3200_Read1AnalogInputChannel(dev, s, insn, data);\r\nif (s_BoardInfos[dev->minor].i_AutoCalibration == FALSE) {\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].\r\ni_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((0x00000800 | s_BoardInfos[dev->minor].\r\ni_ChannelNo),\r\ndevpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 4);\r\ndata++;\r\ni_APCI3200_ReadCalibrationOffsetValue(dev, data);\r\ndata++;\r\ni_APCI3200_ReadCalibrationGainValue(dev, data);\r\n}\r\n}\r\ns_BoardInfos[dev->minor].i_InterruptFlag = i_Temp;\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_InsnWriteReleaseAnalogInput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)\r\n{\r\ni_APCI3200_Reset(dev);\r\nreturn insn->n;\r\n}\r\nint i_APCI3200_CommandTestAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nunsigned int ui_ConvertTime = 0;\r\nunsigned int ui_ConvertTimeBase = 0;\r\nunsigned int ui_DelayTime = 0;\r\nunsigned int ui_DelayTimeBase = 0;\r\nint i_Triggermode = 0;\r\nint i_TriggerEdge = 0;\r\nint i_NbrOfChannel = 0;\r\nint i_Cpt = 0;\r\ndouble d_ConversionTimeForAllChannels = 0.0;\r\ndouble d_SCANTimeNewUnit = 0.0;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (s_BoardInfos[dev->minor].i_InterruptFlag == 0) {\r\nerr++;\r\n}\r\nif (err) {\r\ni_APCI3200_Reset(dev);\r\nreturn 1;\r\n}\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT) {\r\nerr++;\r\n}\r\nif (cmd->start_src == TRIG_EXT) {\r\ni_TriggerEdge = cmd->start_arg & 0xFFFF;\r\ni_Triggermode = cmd->start_arg >> 16;\r\nif (i_TriggerEdge < 1 || i_TriggerEdge > 3) {\r\nerr++;\r\nprintk("\nThe trigger edge selection is in error\n");\r\n}\r\nif (i_Triggermode != 2) {\r\nerr++;\r\nprintk("\nThe trigger mode selection is in error\n");\r\n}\r\n}\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_FOLLOW)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER)\r\nerr++;\r\nif (cmd->scan_end_src != TRIG_COUNT) {\r\ncmd->scan_end_src = TRIG_COUNT;\r\nerr++;\r\n}\r\nif (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)\r\nerr++;\r\nif (err) {\r\ni_APCI3200_Reset(dev);\r\nreturn 2;\r\n}\r\ns_BoardInfos[dev->minor].i_FirstChannel = cmd->chanlist[0];\r\ns_BoardInfos[dev->minor].i_LastChannel = cmd->chanlist[1];\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nui_ConvertTime = cmd->convert_arg & 0xFFFF;\r\nui_ConvertTimeBase = cmd->convert_arg >> 16;\r\nif (ui_ConvertTime != 20 && ui_ConvertTime != 40\r\n&& ui_ConvertTime != 80 && ui_ConvertTime != 160)\r\n{\r\nprintk("\nThe selection of conversion time reload value is in error\n");\r\nerr++;\r\n}\r\nif (ui_ConvertTimeBase != 2) {\r\nprintk("\nThe selection of conversion time unit is in error\n");\r\nerr++;\r\n}\r\n} else {\r\nui_ConvertTime = 0;\r\nui_ConvertTimeBase = 0;\r\n}\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nui_DelayTime = 0;\r\nui_DelayTimeBase = 0;\r\n}\r\nelse {\r\nui_DelayTime = cmd->scan_begin_arg & 0xFFFF;\r\nui_DelayTimeBase = cmd->scan_begin_arg >> 16;\r\nif (ui_DelayTimeBase != 2 && ui_DelayTimeBase != 3) {\r\nerr++;\r\nprintk("\nThe Delay time base selection is in error\n");\r\n}\r\nif (ui_DelayTime < 1 || ui_DelayTime > 1023) {\r\nerr++;\r\nprintk("\nThe Delay time value is in error\n");\r\n}\r\nif (err) {\r\ni_APCI3200_Reset(dev);\r\nreturn 3;\r\n}\r\nfpu_begin();\r\nd_SCANTimeNewUnit = (double)ui_DelayTime;\r\ni_NbrOfChannel =\r\ns_BoardInfos[dev->minor].i_LastChannel -\r\ns_BoardInfos[dev->minor].i_FirstChannel + 4;\r\nd_ConversionTimeForAllChannels =\r\n(double)((double)ui_ConvertTime /\r\n(double)i_NbrOfChannel);\r\nd_ConversionTimeForAllChannels =\r\n(double)1.0 / d_ConversionTimeForAllChannels;\r\nui_ConvertTimeBase = 3;\r\nif (ui_DelayTimeBase <= ui_ConvertTimeBase) {\r\nfor (i_Cpt = 0;\r\ni_Cpt < (ui_ConvertTimeBase - ui_DelayTimeBase);\r\ni_Cpt++) {\r\nd_ConversionTimeForAllChannels =\r\nd_ConversionTimeForAllChannels * 1000;\r\nd_ConversionTimeForAllChannels =\r\nd_ConversionTimeForAllChannels + 1;\r\n}\r\n} else {\r\nfor (i_Cpt = 0;\r\ni_Cpt < (ui_DelayTimeBase - ui_ConvertTimeBase);\r\ni_Cpt++) {\r\nd_SCANTimeNewUnit = d_SCANTimeNewUnit * 1000;\r\n}\r\n}\r\nif (d_ConversionTimeForAllChannels >= d_SCANTimeNewUnit) {\r\nprintk("\nSCAN Delay value cannot be used\n");\r\nerr++;\r\n}\r\nfpu_end();\r\n}\r\nif (err) {\r\ni_APCI3200_Reset(dev);\r\nreturn 4;\r\n}\r\nreturn 0;\r\n}\r\nint i_APCI3200_StopCyclicAcquisition(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned int ui_Configuration = 0;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 0;\r\ns_BoardInfos[dev->minor].i_Initialised = 0;\r\ns_BoardInfos[dev->minor].i_Count = 0;\r\ns_BoardInfos[dev->minor].i_Sum = 0;\r\nui_Configuration =\r\ninl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((ui_Configuration & 0xFFE7FFFF),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nreturn 0;\r\n}\r\nint i_APCI3200_CommandAnalogInput(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int ui_Configuration = 0;\r\nunsigned int ui_Trigger = 0;\r\nunsigned int ui_TriggerEdge = 0;\r\nunsigned int ui_Triggermode = 0;\r\nunsigned int ui_ScanMode = 0;\r\nunsigned int ui_ConvertTime = 0;\r\nunsigned int ui_ConvertTimeBase = 0;\r\nunsigned int ui_DelayTime = 0;\r\nunsigned int ui_DelayTimeBase = 0;\r\nunsigned int ui_DelayMode = 0;\r\ns_BoardInfos[dev->minor].i_FirstChannel = cmd->chanlist[0];\r\ns_BoardInfos[dev->minor].i_LastChannel = cmd->chanlist[1];\r\nif (cmd->start_src == TRIG_EXT) {\r\nui_Trigger = 1;\r\nui_TriggerEdge = cmd->start_arg & 0xFFFF;\r\nui_Triggermode = cmd->start_arg >> 16;\r\n}\r\nelse {\r\nui_Trigger = 0;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nui_ScanMode = 0;\r\n}\r\nelse {\r\nui_ScanMode = 2;\r\n}\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nui_DelayTime = 0;\r\nui_DelayTimeBase = 0;\r\nui_DelayMode = 0;\r\n}\r\nelse {\r\nui_DelayTime = cmd->scan_begin_arg & 0xFFFF;\r\nui_DelayTimeBase = cmd->scan_begin_arg >> 16;\r\nui_DelayMode = 1;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nui_ConvertTime = cmd->convert_arg & 0xFFFF;\r\nui_ConvertTimeBase = cmd->convert_arg >> 16;\r\n} else {\r\nui_ConvertTime = 0;\r\nui_ConvertTimeBase = 0;\r\n}\r\nui_Configuration =\r\ninl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((ui_Configuration & 0xFFC00000),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 12);\r\nui_Configuration = 0;\r\nui_Configuration =\r\ns_BoardInfos[dev->minor].i_FirstChannel | (s_BoardInfos[dev->\r\nminor].\r\ni_LastChannel << 8) | 0x00100000 | (ui_Trigger << 24) |\r\n(ui_TriggerEdge << 25) | (ui_Triggermode << 27) | (ui_DelayMode\r\n<< 18) | (ui_ScanMode << 16);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_Configuration,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 0x8);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_DelayTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 40);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_DelayTimeBase,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 44);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_ConvertTime,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 32);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(ui_ConvertTimeBase,\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 36);\r\nui_Configuration =\r\ninl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 4);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl(((ui_Configuration & 0x1E0FF) | 0x00002000),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 4);\r\nui_Configuration = 0;\r\nui_Configuration =\r\ninl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nwhile (((inl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset +\r\n12) >> 19) & 1) != 1) ;\r\noutl((ui_Configuration | 0x00080000),\r\ndevpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 8);\r\nreturn 0;\r\n}\r\nint i_APCI3200_Reset(struct comedi_device *dev)\r\n{\r\nint i_Temp;\r\nunsigned int dw_Dummy;\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 0;\r\ns_BoardInfos[dev->minor].i_Initialised = 0;\r\ns_BoardInfos[dev->minor].i_Count = 0;\r\ns_BoardInfos[dev->minor].i_Sum = 0;\r\ns_BoardInfos[dev->minor].b_StructInitialized = 0;\r\noutl(0x83838383, devpriv->i_IobaseAmcc + 0x60);\r\ndw_Dummy = inl(devpriv->i_IobaseAmcc + 0x38);\r\noutl(dw_Dummy | 0x2000, devpriv->i_IobaseAmcc + 0x38);\r\noutl(0, devpriv->i_IobaseAddon);\r\nfor (i_Temp = 0; i_Temp <= 95; i_Temp++) {\r\ns_BoardInfos[dev->minor].ui_InterruptChannelValue[i_Temp] = 0;\r\n}\r\nfor (i_Temp = 0; i_Temp <= 192;) {\r\nwhile (((inl(devpriv->iobase + i_Temp + 12) >> 19) & 1) != 1) ;\r\noutl(0, devpriv->iobase + i_Temp + 8);\r\ni_Temp = i_Temp + 64;\r\n}\r\nreturn 0;\r\n}\r\nvoid v_APCI3200_Interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned int ui_StatusRegister = 0;\r\nunsigned int ui_ChannelNumber = 0;\r\nint i_CalibrationFlag = 0;\r\nint i_CJCFlag = 0;\r\nunsigned int ui_DummyValue = 0;\r\nunsigned int ui_DigitalTemperature = 0;\r\nunsigned int ui_DigitalInput = 0;\r\nint i_ConvertCJCCalibration;\r\nint i_ReturnValue = 0;\r\nswitch (s_BoardInfos[dev->minor].i_ScanType) {\r\ncase 0:\r\ncase 1:\r\nswitch (s_BoardInfos[dev->minor].i_ADDIDATAType) {\r\ncase 0:\r\ncase 1:\r\nui_StatusRegister =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 16);\r\nif ((ui_StatusRegister & 0x2) == 0x2) {\r\ni_CalibrationFlag =\r\n((inl(devpriv->iobase +\r\ns_BoardInfos[dev->\r\nminor].\r\ni_Offset +\r\n12) & 0x00060000) >>\r\n17);\r\nui_DigitalInput =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\nif (i_CalibrationFlag == 0) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 0] = ui_DigitalInput;\r\ni_APCI3200_ReadCalibrationOffsetValue\r\n(dev, &ui_DummyValue);\r\n}\r\nif (i_CalibrationFlag == 1) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 1] = ui_DigitalInput;\r\ni_APCI3200_ReadCalibrationGainValue(dev,\r\n&ui_DummyValue);\r\n}\r\nif (i_CalibrationFlag == 2) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 2] = ui_DigitalInput;\r\nif (s_BoardInfos[dev->minor].\r\ni_ScanType == 1) {\r\ns_BoardInfos[dev->minor].\r\ni_InterruptFlag = 0;\r\ns_BoardInfos[dev->minor].\r\ni_Count =\r\ns_BoardInfos[dev->\r\nminor].i_Count + 9;\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].\r\ni_Count = 0;\r\n}\r\nif (s_BoardInfos[dev->minor].\r\ni_ScanType != 1) {\r\ni_ReturnValue = send_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\nelse {\r\nif (s_BoardInfos[dev->minor].\r\ni_ChannelCount ==\r\ns_BoardInfos[dev->\r\nminor].i_Sum) {\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase 2:\r\nui_StatusRegister =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 16);\r\nif ((ui_StatusRegister & 0x2) == 0x2) {\r\ni_CJCFlag =\r\n((inl(devpriv->iobase +\r\ns_BoardInfos[dev->\r\nminor].\r\ni_Offset +\r\n4) & 0x00000400) >> 10);\r\ni_CalibrationFlag =\r\n((inl(devpriv->iobase +\r\ns_BoardInfos[dev->\r\nminor].\r\ni_Offset +\r\n12) & 0x00060000) >>\r\n17);\r\nui_ChannelNumber =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 24);\r\ns_BoardInfos[dev->minor].ui_Channel_num =\r\nui_ChannelNumber;\r\nui_DigitalTemperature =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\nif ((i_CalibrationFlag == 0)\r\n&& (i_CJCFlag == 0)) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 0] =\r\nui_DigitalTemperature;\r\ni_APCI3200_ReadCJCValue(dev,\r\n&ui_DummyValue);\r\n}\r\nif ((i_CJCFlag == 1)\r\n&& (i_CalibrationFlag == 0)) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 3] =\r\nui_DigitalTemperature;\r\ni_APCI3200_ReadCalibrationOffsetValue\r\n(dev, &ui_DummyValue);\r\n}\r\nif ((i_CalibrationFlag == 1)\r\n&& (i_CJCFlag == 0)) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 1] =\r\nui_DigitalTemperature;\r\ni_APCI3200_ReadCalibrationGainValue(dev,\r\n&ui_DummyValue);\r\n}\r\nif ((i_CalibrationFlag == 2)\r\n&& (i_CJCFlag == 0)) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 2] =\r\nui_DigitalTemperature;\r\nif (s_BoardInfos[dev->minor].\r\ni_CJCPolarity !=\r\ns_BoardInfos[dev->minor].\r\ni_ADDIDATAPolarity) {\r\ni_ConvertCJCCalibration = 1;\r\n}\r\nelse {\r\nif (s_BoardInfos[dev->minor].\r\ni_CJCGain ==\r\ns_BoardInfos[dev->\r\nminor].\r\ni_ADDIDATAGain) {\r\ni_ConvertCJCCalibration\r\n= 0;\r\n}\r\nelse {\r\ni_ConvertCJCCalibration\r\n= 1;\r\n}\r\n}\r\nif (i_ConvertCJCCalibration == 1) {\r\ni_APCI3200_ReadCJCCalOffset(dev,\r\n&ui_DummyValue);\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->\r\nminor].i_Count +\r\n4] = 0;\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->\r\nminor].i_Count +\r\n5] = 0;\r\n}\r\n}\r\nif ((i_CalibrationFlag == 1)\r\n&& (i_CJCFlag == 1)) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 4] =\r\nui_DigitalTemperature;\r\ni_APCI3200_ReadCJCCalGain(dev,\r\n&ui_DummyValue);\r\n}\r\nif ((i_CalibrationFlag == 2)\r\n&& (i_CJCFlag == 1)) {\r\ns_BoardInfos[dev->minor].\r\nui_InterruptChannelValue\r\n[s_BoardInfos[dev->minor].\r\ni_Count + 5] =\r\nui_DigitalTemperature;\r\nif (s_BoardInfos[dev->minor].\r\ni_ScanType == 1) {\r\ns_BoardInfos[dev->minor].\r\ni_InterruptFlag = 0;\r\ns_BoardInfos[dev->minor].\r\ni_Count =\r\ns_BoardInfos[dev->\r\nminor].i_Count + 9;\r\n}\r\nelse {\r\ns_BoardInfos[dev->minor].\r\ni_Count = 0;\r\n}\r\nif (s_BoardInfos[dev->minor].\r\ni_ScanType != 1) {\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\nelse {\r\nif (s_BoardInfos[dev->minor].\r\ni_ChannelCount ==\r\ns_BoardInfos[dev->\r\nminor].i_Sum) {\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\ncase 3:\r\ni_APCI3200_InterruptHandleEos(dev);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nint i_APCI3200_InterruptHandleEos(struct comedi_device *dev)\r\n{\r\nunsigned int ui_StatusRegister = 0;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nint n = 0, i = 0;\r\nui_StatusRegister =\r\ninl(devpriv->iobase + s_BoardInfos[dev->minor].i_Offset + 16);\r\nif ((ui_StatusRegister & 0x2) == 0x2) {\r\ns->async->events = 0;\r\ns_BoardInfos[dev->minor].ui_ScanValueArray[s_BoardInfos[dev->\r\nminor].i_Count] =\r\ninl(devpriv->iobase +\r\ns_BoardInfos[dev->minor].i_Offset + 28);\r\nif ((s_BoardInfos[dev->minor].i_Count ==\r\n(s_BoardInfos[dev->minor].i_LastChannel -\r\ns_BoardInfos[dev->minor].\r\ni_FirstChannel + 3))) {\r\ns_BoardInfos[dev->minor].i_Count++;\r\nfor (i = s_BoardInfos[dev->minor].i_FirstChannel;\r\ni <= s_BoardInfos[dev->minor].i_LastChannel;\r\ni++) {\r\ni_APCI3200_GetChannelCalibrationValue(dev, i,\r\n&s_BoardInfos[dev->minor].\r\nui_ScanValueArray[s_BoardInfos[dev->\r\nminor].i_Count + ((i -\r\ns_BoardInfos\r\n[dev->minor].\r\ni_FirstChannel)\r\n* 3)],\r\n&s_BoardInfos[dev->minor].\r\nui_ScanValueArray[s_BoardInfos[dev->\r\nminor].i_Count + ((i -\r\ns_BoardInfos\r\n[dev->minor].\r\ni_FirstChannel)\r\n* 3) + 1],\r\n&s_BoardInfos[dev->minor].\r\nui_ScanValueArray[s_BoardInfos[dev->\r\nminor].i_Count + ((i -\r\ns_BoardInfos\r\n[dev->minor].\r\ni_FirstChannel)\r\n* 3) + 2]);\r\n}\r\ns_BoardInfos[dev->minor].i_Count = -1;\r\ns->async->events |= COMEDI_CB_EOS;\r\nn = comedi_buf_write_alloc(s->async,\r\n(7 + 12) * sizeof(unsigned int));\r\nif (n > ((7 + 12) * sizeof(unsigned int))) {\r\nprintk("\ncomedi_buf_write_alloc n = %i", n);\r\ns->async->events |= COMEDI_CB_ERROR;\r\n}\r\ncomedi_buf_memcpy_to(s->async, 0,\r\n(unsigned int *) s_BoardInfos[dev->minor].\r\nui_ScanValueArray, (7 + 12) * sizeof(unsigned int));\r\ncomedi_buf_write_free(s->async,\r\n(7 + 12) * sizeof(unsigned int));\r\ncomedi_event(dev, s);\r\n*/\r\n}\r\ns_BoardInfos[dev->minor].i_Count++;\r\n}\r\ns_BoardInfos[dev->minor].i_InterruptFlag = 0;\r\nreturn 0;\r\n}
