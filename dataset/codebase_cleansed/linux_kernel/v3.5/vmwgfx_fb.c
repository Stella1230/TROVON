static int vmw_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nu32 *pal = par->pseudo_palette;\r\nif (regno > 15) {\r\nDRM_ERROR("Bad regno %u.\n", regno);\r\nreturn 1;\r\n}\r\nswitch (par->depth) {\r\ncase 24:\r\ncase 32:\r\npal[regno] = ((red & 0xff00) << 8) |\r\n(green & 0xff00) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad depth %u, bpp %u.\n", par->depth, par->bpp);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint depth = var->bits_per_pixel;\r\nstruct vmw_fb_par *par = info->par;\r\nstruct vmw_private *vmw_priv = par->vmw_priv;\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\ndepth = (var->transp.length > 0) ? 32 : 24;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad bpp %u.\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nswitch (depth) {\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad depth %u.\n", depth);\r\nreturn -EINVAL;\r\n}\r\nif (!(vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY) &&\r\n(var->xoffset != 0 || var->yoffset != 0)) {\r\nDRM_ERROR("Can not handle panning without display topology\n");\r\nreturn -EINVAL;\r\n}\r\nif ((var->xoffset + var->xres) > par->max_width ||\r\n(var->yoffset + var->yres) > par->max_height) {\r\nDRM_ERROR("Requested geom can not fit in framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vmw_kms_validate_mode_vram(vmw_priv,\r\ninfo->fix.line_length,\r\nvar->yoffset + var->yres)) {\r\nDRM_ERROR("Requested geom can not fit in framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_set_par(struct fb_info *info)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nstruct vmw_private *vmw_priv = par->vmw_priv;\r\nint ret;\r\nret = vmw_kms_write_svga(vmw_priv, info->var.xres, info->var.yres,\r\ninfo->fix.line_length,\r\npar->bpp, par->depth);\r\nif (ret)\r\nreturn ret;\r\nif (vmw_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY) {\r\nvmw_write(vmw_priv, SVGA_REG_NUM_GUEST_DISPLAYS, 1);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, 0);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_IS_PRIMARY, true);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_X, info->var.xoffset);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_POSITION_Y, info->var.yoffset);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_WIDTH, info->var.xres);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_HEIGHT, info->var.yres);\r\nvmw_write(vmw_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\n}\r\nWARN_ON(vmw_read(vmw_priv, SVGA_REG_FB_OFFSET) != 0);\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vmw_fb_blank(int blank, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vmw_fb_dirty_flush(struct vmw_fb_par *par)\r\n{\r\nstruct vmw_private *vmw_priv = par->vmw_priv;\r\nstruct fb_info *info = vmw_priv->fb_info;\r\nint stride = (info->fix.line_length / 4);\r\nint *src = (int *)info->screen_base;\r\n__le32 __iomem *vram_mem = par->bo_ptr;\r\nunsigned long flags;\r\nunsigned x, y, w, h;\r\nint i, k;\r\nstruct {\r\nuint32_t header;\r\nSVGAFifoCmdUpdate body;\r\n} *cmd;\r\nif (vmw_priv->suspended)\r\nreturn;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\nif (!par->dirty.active) {\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\nreturn;\r\n}\r\nx = par->dirty.x1;\r\ny = par->dirty.y1;\r\nw = min(par->dirty.x2, info->var.xres) - x;\r\nh = min(par->dirty.y2, info->var.yres) - y;\r\npar->dirty.x1 = par->dirty.x2 = 0;\r\npar->dirty.y1 = par->dirty.y2 = 0;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\nfor (i = y * stride; i < info->fix.smem_len / 4; i += stride) {\r\nfor (k = i+x; k < i+x+w && k < info->fix.smem_len / 4; k++)\r\niowrite32(src[k], vram_mem + k);\r\n}\r\n#if 0\r\nDRM_INFO("%s, (%u, %u) (%ux%u)\n", __func__, x, y, w, h);\r\n#endif\r\ncmd = vmw_fifo_reserve(vmw_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn;\r\n}\r\ncmd->header = cpu_to_le32(SVGA_CMD_UPDATE);\r\ncmd->body.x = cpu_to_le32(x);\r\ncmd->body.y = cpu_to_le32(y);\r\ncmd->body.width = cpu_to_le32(w);\r\ncmd->body.height = cpu_to_le32(h);\r\nvmw_fifo_commit(vmw_priv, sizeof(*cmd));\r\n}\r\nstatic void vmw_fb_dirty_mark(struct vmw_fb_par *par,\r\nunsigned x1, unsigned y1,\r\nunsigned width, unsigned height)\r\n{\r\nstruct fb_info *info = par->vmw_priv->fb_info;\r\nunsigned long flags;\r\nunsigned x2 = x1 + width;\r\nunsigned y2 = y1 + height;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\nif (par->dirty.x1 == par->dirty.x2) {\r\npar->dirty.x1 = x1;\r\npar->dirty.y1 = y1;\r\npar->dirty.x2 = x2;\r\npar->dirty.y2 = y2;\r\nif (par->dirty.active)\r\nschedule_delayed_work(&info->deferred_work, VMW_DIRTY_DELAY);\r\n} else {\r\nif (x1 < par->dirty.x1)\r\npar->dirty.x1 = x1;\r\nif (y1 < par->dirty.y1)\r\npar->dirty.y1 = y1;\r\nif (x2 > par->dirty.x2)\r\npar->dirty.x2 = x2;\r\nif (y2 > par->dirty.y2)\r\npar->dirty.y2 = y2;\r\n}\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\n}\r\nstatic void vmw_deferred_io(struct fb_info *info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct vmw_fb_par *par = info->par;\r\nunsigned long start, end, min, max;\r\nunsigned long flags;\r\nstruct page *page;\r\nint y1, y2;\r\nmin = ULONG_MAX;\r\nmax = 0;\r\nlist_for_each_entry(page, pagelist, lru) {\r\nstart = page->index << PAGE_SHIFT;\r\nend = start + PAGE_SIZE - 1;\r\nmin = min(min, start);\r\nmax = max(max, end);\r\n}\r\nif (min < max) {\r\ny1 = min / info->fix.line_length;\r\ny2 = (max / info->fix.line_length) + 1;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\npar->dirty.x1 = 0;\r\npar->dirty.y1 = y1;\r\npar->dirty.x2 = info->var.xres;\r\npar->dirty.y2 = y2;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\n}\r\nvmw_fb_dirty_flush(par);\r\n}\r\nstatic void vmw_fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\ncfb_fillrect(info, rect);\r\nvmw_fb_dirty_mark(info->par, rect->dx, rect->dy,\r\nrect->width, rect->height);\r\n}\r\nstatic void vmw_fb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\ncfb_copyarea(info, region);\r\nvmw_fb_dirty_mark(info->par, region->dx, region->dy,\r\nregion->width, region->height);\r\n}\r\nstatic void vmw_fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\ncfb_imageblit(info, image);\r\nvmw_fb_dirty_mark(info->par, image->dx, image->dy,\r\nimage->width, image->height);\r\n}\r\nstatic int vmw_fb_create_bo(struct vmw_private *vmw_priv,\r\nsize_t size, struct vmw_dma_buffer **out)\r\n{\r\nstruct vmw_dma_buffer *vmw_bo;\r\nstruct ttm_placement ne_placement = vmw_vram_ne_placement;\r\nint ret;\r\nne_placement.lpfn = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nret = ttm_write_lock(&vmw_priv->fbdev_master.lock, false);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_bo = kmalloc(sizeof(*vmw_bo), GFP_KERNEL);\r\nif (!vmw_bo)\r\ngoto err_unlock;\r\nret = vmw_dmabuf_init(vmw_priv, vmw_bo, size,\r\n&ne_placement,\r\nfalse,\r\n&vmw_dmabuf_bo_free);\r\nif (unlikely(ret != 0))\r\ngoto err_unlock;\r\n*out = vmw_bo;\r\nttm_write_unlock(&vmw_priv->fbdev_master.lock);\r\nreturn 0;\r\nerr_unlock:\r\nttm_write_unlock(&vmw_priv->fbdev_master.lock);\r\nreturn ret;\r\n}\r\nint vmw_fb_init(struct vmw_private *vmw_priv)\r\n{\r\nstruct device *device = &vmw_priv->dev->pdev->dev;\r\nstruct vmw_fb_par *par;\r\nstruct fb_info *info;\r\nunsigned initial_width, initial_height;\r\nunsigned fb_width, fb_height;\r\nunsigned fb_bpp, fb_depth, fb_offset, fb_pitch, fb_size;\r\nint ret;\r\nfb_bpp = 32;\r\nfb_depth = 24;\r\nfb_width = min(vmw_priv->fb_max_width, (unsigned)2048);\r\nfb_height = min(vmw_priv->fb_max_height, (unsigned)2048);\r\ninitial_width = min(vmw_priv->initial_width, fb_width);\r\ninitial_height = min(vmw_priv->initial_height, fb_height);\r\nfb_pitch = fb_width * fb_bpp / 8;\r\nfb_size = fb_pitch * fb_height;\r\nfb_offset = vmw_read(vmw_priv, SVGA_REG_FB_OFFSET);\r\ninfo = framebuffer_alloc(sizeof(*par), device);\r\nif (!info)\r\nreturn -ENOMEM;\r\nvmw_priv->fb_info = info;\r\npar = info->par;\r\npar->vmw_priv = vmw_priv;\r\npar->depth = fb_depth;\r\npar->bpp = fb_bpp;\r\npar->vmalloc = NULL;\r\npar->max_width = fb_width;\r\npar->max_height = fb_height;\r\npar->vmalloc = vmalloc(fb_size);\r\nif (unlikely(par->vmalloc == NULL)) {\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\nret = vmw_fb_create_bo(vmw_priv, fb_size, &par->vmw_bo);\r\nif (unlikely(ret != 0))\r\ngoto err_free;\r\nret = ttm_bo_kmap(&par->vmw_bo->base,\r\n0,\r\npar->vmw_bo->base.num_pages,\r\n&par->map);\r\nif (unlikely(ret != 0))\r\ngoto err_unref;\r\npar->bo_ptr = ttm_kmap_obj_virtual(&par->map, &par->bo_iowrite);\r\npar->bo_size = fb_size;\r\nstrcpy(info->fix.id, "svgadrmfb");\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 1;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->fix.line_length = fb_pitch;\r\ninfo->fix.smem_start = 0;\r\ninfo->fix.smem_len = fb_size;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->screen_base = par->vmalloc;\r\ninfo->screen_size = fb_size;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->fbops = &vmw_fb_ops;\r\ninfo->var.red.offset = 16;\r\ninfo->var.green.offset = 8;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\ninfo->var.transp.offset = 0;\r\ninfo->var.transp.length = 0;\r\ninfo->var.xres_virtual = fb_width;\r\ninfo->var.yres_virtual = fb_height;\r\ninfo->var.bits_per_pixel = par->bpp;\r\ninfo->var.xoffset = 0;\r\ninfo->var.yoffset = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.xres = initial_width;\r\ninfo->var.yres = initial_height;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto err_aper;\r\n}\r\ninfo->apertures->ranges[0].base = vmw_priv->vram_start;\r\ninfo->apertures->ranges[0].size = vmw_priv->vram_size;\r\npar->dirty.x1 = par->dirty.x2 = 0;\r\npar->dirty.y1 = par->dirty.y2 = 0;\r\npar->dirty.active = true;\r\nspin_lock_init(&par->dirty.lock);\r\ninfo->fbdefio = &vmw_defio;\r\nfb_deferred_io_init(info);\r\nret = register_framebuffer(info);\r\nif (unlikely(ret != 0))\r\ngoto err_defio;\r\nreturn 0;\r\nerr_defio:\r\nfb_deferred_io_cleanup(info);\r\nerr_aper:\r\nttm_bo_kunmap(&par->map);\r\nerr_unref:\r\nttm_bo_unref((struct ttm_buffer_object **)&par->vmw_bo);\r\nerr_free:\r\nvfree(par->vmalloc);\r\nframebuffer_release(info);\r\nvmw_priv->fb_info = NULL;\r\nreturn ret;\r\n}\r\nint vmw_fb_close(struct vmw_private *vmw_priv)\r\n{\r\nstruct fb_info *info;\r\nstruct vmw_fb_par *par;\r\nstruct ttm_buffer_object *bo;\r\nif (!vmw_priv->fb_info)\r\nreturn 0;\r\ninfo = vmw_priv->fb_info;\r\npar = info->par;\r\nbo = &par->vmw_bo->base;\r\npar->vmw_bo = NULL;\r\nfb_deferred_io_cleanup(info);\r\nunregister_framebuffer(info);\r\nttm_bo_kunmap(&par->map);\r\nttm_bo_unref(&bo);\r\nvfree(par->vmalloc);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nint vmw_fb_off(struct vmw_private *vmw_priv)\r\n{\r\nstruct fb_info *info;\r\nstruct vmw_fb_par *par;\r\nunsigned long flags;\r\nif (!vmw_priv->fb_info)\r\nreturn -EINVAL;\r\ninfo = vmw_priv->fb_info;\r\npar = info->par;\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\npar->dirty.active = false;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\nflush_delayed_work_sync(&info->deferred_work);\r\npar->bo_ptr = NULL;\r\nttm_bo_kunmap(&par->map);\r\nvmw_dmabuf_unpin(vmw_priv, par->vmw_bo, false);\r\nreturn 0;\r\n}\r\nint vmw_fb_on(struct vmw_private *vmw_priv)\r\n{\r\nstruct fb_info *info;\r\nstruct vmw_fb_par *par;\r\nunsigned long flags;\r\nbool dummy;\r\nint ret;\r\nif (!vmw_priv->fb_info)\r\nreturn -EINVAL;\r\ninfo = vmw_priv->fb_info;\r\npar = info->par;\r\nif (par->bo_ptr != NULL)\r\nreturn 0;\r\nvmw_overlay_stop_all(vmw_priv);\r\nret = vmw_dmabuf_to_start_of_vram(vmw_priv, par->vmw_bo, true, false);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("could not move buffer to start of VRAM\n");\r\ngoto err_no_buffer;\r\n}\r\nret = ttm_bo_kmap(&par->vmw_bo->base,\r\n0,\r\npar->vmw_bo->base.num_pages,\r\n&par->map);\r\nBUG_ON(ret != 0);\r\npar->bo_ptr = ttm_kmap_obj_virtual(&par->map, &dummy);\r\nspin_lock_irqsave(&par->dirty.lock, flags);\r\npar->dirty.active = true;\r\nspin_unlock_irqrestore(&par->dirty.lock, flags);\r\nerr_no_buffer:\r\nvmw_fb_set_par(info);\r\nvmw_fb_dirty_mark(par, 0, 0, info->var.xres, info->var.yres);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\nreturn 0;\r\n}
