int fsl_pq_local_mdio_write(struct fsl_pq_mdio __iomem *regs, int mii_id,\r\nint regnum, u16 value)\r\n{\r\nout_be32(&regs->miimadd, (mii_id << 8) | regnum);\r\nout_be32(&regs->miimcon, value);\r\nwhile (in_be32(&regs->miimind) & MIIMIND_BUSY)\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nint fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs,\r\nint mii_id, int regnum)\r\n{\r\nu16 value;\r\nout_be32(&regs->miimadd, (mii_id << 8) | regnum);\r\nout_be32(&regs->miimcom, 0);\r\nout_be32(&regs->miimcom, MII_READ_COMMAND);\r\nwhile (in_be32(&regs->miimind) & (MIIMIND_NOTVALID | MIIMIND_BUSY))\r\ncpu_relax();\r\nvalue = in_be32(&regs->miimstat);\r\nreturn value;\r\n}\r\nstatic struct fsl_pq_mdio __iomem *fsl_pq_mdio_get_regs(struct mii_bus *bus)\r\n{\r\nstruct fsl_pq_mdio_priv *priv = bus->priv;\r\nreturn priv->regs;\r\n}\r\nint fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value)\r\n{\r\nstruct fsl_pq_mdio __iomem *regs = fsl_pq_mdio_get_regs(bus);\r\nreturn fsl_pq_local_mdio_write(regs, mii_id, regnum, value);\r\n}\r\nint fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct fsl_pq_mdio __iomem *regs = fsl_pq_mdio_get_regs(bus);\r\nreturn fsl_pq_local_mdio_read(regs, mii_id, regnum);\r\n}\r\nstatic int fsl_pq_mdio_reset(struct mii_bus *bus)\r\n{\r\nstruct fsl_pq_mdio __iomem *regs = fsl_pq_mdio_get_regs(bus);\r\nint timeout = PHY_INIT_TIMEOUT;\r\nmutex_lock(&bus->mdio_lock);\r\nout_be32(&regs->miimcfg, MIIMCFG_RESET);\r\nout_be32(&regs->miimcfg, MIIMCFG_INIT_VALUE);\r\nwhile ((in_be32(&regs->miimind) & MIIMIND_BUSY) && timeout--)\r\ncpu_relax();\r\nmutex_unlock(&bus->mdio_lock);\r\nif (timeout < 0) {\r\nprintk(KERN_ERR "%s: The MII Bus is stuck!\n",\r\nbus->name);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nvoid fsl_pq_mdio_bus_name(char *name, struct device_node *np)\r\n{\r\nconst u32 *addr;\r\nu64 taddr = OF_BAD_ADDR;\r\naddr = of_get_address(np, 0, NULL, NULL);\r\nif (addr)\r\ntaddr = of_translate_address(np, addr);\r\nsnprintf(name, MII_BUS_ID_SIZE, "%s@%llx", np->name,\r\n(unsigned long long)taddr);\r\n}\r\nstatic u32 __iomem *get_gfar_tbipa(struct fsl_pq_mdio __iomem *regs, struct device_node *np)\r\n{\r\n#if defined(CONFIG_GIANFAR) || defined(CONFIG_GIANFAR_MODULE)\r\nstruct gfar __iomem *enet_regs;\r\nif(of_device_is_compatible(np, "fsl,gianfar-mdio") ||\r\nof_device_is_compatible(np, "fsl,gianfar-tbi") ||\r\nof_device_is_compatible(np, "gianfar")) {\r\nenet_regs = (struct gfar __iomem *)regs;\r\nreturn &enet_regs->tbipa;\r\n} else if (of_device_is_compatible(np, "fsl,etsec2-mdio") ||\r\nof_device_is_compatible(np, "fsl,etsec2-tbi")) {\r\nreturn of_iomap(np, 1);\r\n}\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic int get_ucc_id_for_range(u64 start, u64 end, u32 *ucc_id)\r\n{\r\n#if defined(CONFIG_UCC_GETH) || defined(CONFIG_UCC_GETH_MODULE)\r\nstruct device_node *np = NULL;\r\nint err = 0;\r\nfor_each_compatible_node(np, NULL, "ucc_geth") {\r\nstruct resource tempres;\r\nerr = of_address_to_resource(np, 0, &tempres);\r\nif (err)\r\ncontinue;\r\nif ((start >= tempres.start) && (end <= tempres.end)) {\r\nconst u32 *id;\r\nid = of_get_property(np, "cell-index", NULL);\r\nif (!id) {\r\nid = of_get_property(np, "device-id", NULL);\r\nif (!id)\r\ncontinue;\r\n}\r\n*ucc_id = *id;\r\nreturn 0;\r\n}\r\n}\r\nif (err)\r\nreturn err;\r\nelse\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENODEV;\r\n#endif\r\n}\r\nstatic int fsl_pq_mdio_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct device_node *tbi;\r\nstruct fsl_pq_mdio_priv *priv;\r\nstruct fsl_pq_mdio __iomem *regs = NULL;\r\nvoid __iomem *map;\r\nu32 __iomem *tbipa;\r\nstruct mii_bus *new_bus;\r\nint tbiaddr = -1;\r\nconst u32 *addrp;\r\nu64 addr = 0, size = 0;\r\nint err;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nnew_bus = mdiobus_alloc();\r\nif (!new_bus) {\r\nerr = -ENOMEM;\r\ngoto err_free_priv;\r\n}\r\nnew_bus->name = "Freescale PowerQUICC MII Bus",\r\nnew_bus->read = &fsl_pq_mdio_read,\r\nnew_bus->write = &fsl_pq_mdio_write,\r\nnew_bus->reset = &fsl_pq_mdio_reset,\r\nnew_bus->priv = priv;\r\nfsl_pq_mdio_bus_name(new_bus->id, np);\r\naddrp = of_get_address(np, 0, &size, NULL);\r\nif (!addrp) {\r\nerr = -EINVAL;\r\ngoto err_free_bus;\r\n}\r\naddr = of_translate_address(np, addrp);\r\nif (addr == OF_BAD_ADDR) {\r\nerr = -EINVAL;\r\ngoto err_free_bus;\r\n}\r\nmap = ioremap(addr, size);\r\nif (!map) {\r\nerr = -ENOMEM;\r\ngoto err_free_bus;\r\n}\r\npriv->map = map;\r\nif (of_device_is_compatible(np, "fsl,gianfar-mdio") ||\r\nof_device_is_compatible(np, "fsl,gianfar-tbi") ||\r\nof_device_is_compatible(np, "fsl,ucc-mdio") ||\r\nof_device_is_compatible(np, "ucc_geth_phy"))\r\nmap -= offsetof(struct fsl_pq_mdio, miimcfg);\r\nregs = map;\r\npriv->regs = regs;\r\nnew_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);\r\nif (NULL == new_bus->irq) {\r\nerr = -ENOMEM;\r\ngoto err_unmap_regs;\r\n}\r\nnew_bus->parent = &ofdev->dev;\r\ndev_set_drvdata(&ofdev->dev, new_bus);\r\nif (of_device_is_compatible(np, "fsl,gianfar-mdio") ||\r\nof_device_is_compatible(np, "fsl,gianfar-tbi") ||\r\nof_device_is_compatible(np, "fsl,etsec2-mdio") ||\r\nof_device_is_compatible(np, "fsl,etsec2-tbi") ||\r\nof_device_is_compatible(np, "gianfar")) {\r\ntbipa = get_gfar_tbipa(regs, np);\r\nif (!tbipa) {\r\nerr = -EINVAL;\r\ngoto err_free_irqs;\r\n}\r\n} else if (of_device_is_compatible(np, "fsl,ucc-mdio") ||\r\nof_device_is_compatible(np, "ucc_geth_phy")) {\r\nu32 id;\r\nstatic u32 mii_mng_master;\r\ntbipa = &regs->utbipar;\r\nif ((err = get_ucc_id_for_range(addr, addr + size, &id)))\r\ngoto err_free_irqs;\r\nif (!mii_mng_master) {\r\nmii_mng_master = id;\r\nucc_set_qe_mux_mii_mng(id - 1);\r\n}\r\n} else {\r\nerr = -ENODEV;\r\ngoto err_free_irqs;\r\n}\r\nfor_each_child_of_node(np, tbi) {\r\nif (!strncmp(tbi->type, "tbi-phy", 8))\r\nbreak;\r\n}\r\nif (tbi) {\r\nconst u32 *prop = of_get_property(tbi, "reg", NULL);\r\nif (prop)\r\ntbiaddr = *prop;\r\nif (tbiaddr == -1) {\r\nerr = -EBUSY;\r\ngoto err_free_irqs;\r\n} else {\r\nout_be32(tbipa, tbiaddr);\r\n}\r\n}\r\nerr = of_mdiobus_register(new_bus, np);\r\nif (err) {\r\nprintk (KERN_ERR "%s: Cannot register as MDIO bus\n",\r\nnew_bus->name);\r\ngoto err_free_irqs;\r\n}\r\nreturn 0;\r\nerr_free_irqs:\r\nkfree(new_bus->irq);\r\nerr_unmap_regs:\r\niounmap(priv->map);\r\nerr_free_bus:\r\nkfree(new_bus);\r\nerr_free_priv:\r\nkfree(priv);\r\nreturn err;\r\n}\r\nstatic int fsl_pq_mdio_remove(struct platform_device *ofdev)\r\n{\r\nstruct device *device = &ofdev->dev;\r\nstruct mii_bus *bus = dev_get_drvdata(device);\r\nstruct fsl_pq_mdio_priv *priv = bus->priv;\r\nmdiobus_unregister(bus);\r\ndev_set_drvdata(device, NULL);\r\niounmap(priv->map);\r\nbus->priv = NULL;\r\nmdiobus_free(bus);\r\nkfree(priv);\r\nreturn 0;\r\n}
