int wusbhc_mmcie_create(struct wusbhc *wusbhc)\r\n{\r\nu8 mmcies = wusbhc->mmcies_max;\r\nwusbhc->mmcie = kcalloc(mmcies, sizeof(wusbhc->mmcie[0]), GFP_KERNEL);\r\nif (wusbhc->mmcie == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&wusbhc->mmcie_mutex);\r\nreturn 0;\r\n}\r\nvoid wusbhc_mmcie_destroy(struct wusbhc *wusbhc)\r\n{\r\nkfree(wusbhc->mmcie);\r\n}\r\nint wusbhc_mmcie_set(struct wusbhc *wusbhc, u8 interval, u8 repeat_cnt,\r\nstruct wuie_hdr *wuie)\r\n{\r\nint result = -ENOBUFS;\r\nunsigned handle, itr;\r\nmutex_lock(&wusbhc->mmcie_mutex);\r\nswitch (wuie->bIEIdentifier) {\r\ncase WUIE_ID_HOST_INFO:\r\nhandle = wusbhc->mmcies_max - 1;\r\nbreak;\r\ncase WUIE_ID_ISOCH_DISCARD:\r\ndev_err(wusbhc->dev, "Special ordering case for WUIE ID 0x%x "\r\n"unimplemented\n", wuie->bIEIdentifier);\r\nresult = -ENOSYS;\r\ngoto error_unlock;\r\ndefault:\r\nhandle = ~0;\r\nfor (itr = 0; itr < wusbhc->mmcies_max - 1; itr++) {\r\nif (wusbhc->mmcie[itr] == wuie) {\r\nhandle = itr;\r\nbreak;\r\n}\r\nif (wusbhc->mmcie[itr] == NULL)\r\nhandle = itr;\r\n}\r\nif (handle == ~0)\r\ngoto error_unlock;\r\n}\r\nresult = (wusbhc->mmcie_add)(wusbhc, interval, repeat_cnt, handle,\r\nwuie);\r\nif (result >= 0)\r\nwusbhc->mmcie[handle] = wuie;\r\nerror_unlock:\r\nmutex_unlock(&wusbhc->mmcie_mutex);\r\nreturn result;\r\n}\r\nvoid wusbhc_mmcie_rm(struct wusbhc *wusbhc, struct wuie_hdr *wuie)\r\n{\r\nint result;\r\nunsigned handle, itr;\r\nmutex_lock(&wusbhc->mmcie_mutex);\r\nfor (itr = 0; itr < wusbhc->mmcies_max; itr++) {\r\nif (wusbhc->mmcie[itr] == wuie) {\r\nhandle = itr;\r\ngoto found;\r\n}\r\n}\r\nmutex_unlock(&wusbhc->mmcie_mutex);\r\nreturn;\r\nfound:\r\nresult = (wusbhc->mmcie_rm)(wusbhc, handle);\r\nif (result == 0)\r\nwusbhc->mmcie[itr] = NULL;\r\nmutex_unlock(&wusbhc->mmcie_mutex);\r\n}\r\nstatic int wusbhc_mmc_start(struct wusbhc *wusbhc)\r\n{\r\nint ret;\r\nmutex_lock(&wusbhc->mutex);\r\nret = wusbhc->start(wusbhc);\r\nif (ret >= 0)\r\nwusbhc->active = 1;\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn ret;\r\n}\r\nstatic void wusbhc_mmc_stop(struct wusbhc *wusbhc)\r\n{\r\nmutex_lock(&wusbhc->mutex);\r\nwusbhc->active = 0;\r\nwusbhc->stop(wusbhc, WUSB_CHANNEL_STOP_DELAY_MS);\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nint wusbhc_start(struct wusbhc *wusbhc)\r\n{\r\nint result;\r\nstruct device *dev = wusbhc->dev;\r\nWARN_ON(wusbhc->wuie_host_info != NULL);\r\nresult = wusbhc_rsv_establish(wusbhc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot establish cluster reservation: %d\n",\r\nresult);\r\ngoto error_rsv_establish;\r\n}\r\nresult = wusbhc_devconnect_start(wusbhc);\r\nif (result < 0) {\r\ndev_err(dev, "error enabling device connections: %d\n", result);\r\ngoto error_devconnect_start;\r\n}\r\nresult = wusbhc_sec_start(wusbhc);\r\nif (result < 0) {\r\ndev_err(dev, "error starting security in the HC: %d\n", result);\r\ngoto error_sec_start;\r\n}\r\nresult = wusbhc->set_num_dnts(wusbhc, 0, 15);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot set DNTS parameters: %d\n", result);\r\ngoto error_set_num_dnts;\r\n}\r\nresult = wusbhc_mmc_start(wusbhc);\r\nif (result < 0) {\r\ndev_err(dev, "error starting wusbch: %d\n", result);\r\ngoto error_wusbhc_start;\r\n}\r\nreturn 0;\r\nerror_wusbhc_start:\r\nwusbhc_sec_stop(wusbhc);\r\nerror_set_num_dnts:\r\nerror_sec_start:\r\nwusbhc_devconnect_stop(wusbhc);\r\nerror_devconnect_start:\r\nwusbhc_rsv_terminate(wusbhc);\r\nerror_rsv_establish:\r\nreturn result;\r\n}\r\nvoid wusbhc_stop(struct wusbhc *wusbhc)\r\n{\r\nwusbhc_mmc_stop(wusbhc);\r\nwusbhc_sec_stop(wusbhc);\r\nwusbhc_devconnect_stop(wusbhc);\r\nwusbhc_rsv_terminate(wusbhc);\r\n}\r\nint wusbhc_chid_set(struct wusbhc *wusbhc, const struct wusb_ckhdid *chid)\r\n{\r\nint result = 0;\r\nif (memcmp(chid, &wusb_ckhdid_zero, sizeof(*chid)) == 0)\r\nchid = NULL;\r\nmutex_lock(&wusbhc->mutex);\r\nif (chid) {\r\nif (wusbhc->active) {\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn -EBUSY;\r\n}\r\nwusbhc->chid = *chid;\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\nif (chid)\r\nresult = uwb_radio_start(&wusbhc->pal);\r\nelse\r\nuwb_radio_stop(&wusbhc->pal);\r\nreturn result;\r\n}
