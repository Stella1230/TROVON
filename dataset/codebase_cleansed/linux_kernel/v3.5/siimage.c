static int pdev_is_sata(struct pci_dev *pdev)\r\n{\r\n#ifdef CONFIG_BLK_DEV_IDE_SATA\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_SII_3112:\r\ncase PCI_DEVICE_ID_SII_1210SA:\r\nreturn 1;\r\ncase PCI_DEVICE_ID_SII_680:\r\nreturn 0;\r\n}\r\nBUG();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline int is_sata(ide_hwif_t *hwif)\r\n{\r\nreturn pdev_is_sata(to_pci_dev(hwif->dev));\r\n}\r\nstatic unsigned long siimage_selreg(ide_hwif_t *hwif, int r)\r\n{\r\nunsigned long base = (unsigned long)hwif->hwif_data;\r\nbase += 0xA0 + r;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO)\r\nbase += hwif->channel << 6;\r\nelse\r\nbase += hwif->channel << 4;\r\nreturn base;\r\n}\r\nstatic inline unsigned long siimage_seldev(ide_drive_t *drive, int r)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nunsigned long base = (unsigned long)hwif->hwif_data;\r\nu8 unit = drive->dn & 1;\r\nbase += 0xA0 + r;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO)\r\nbase += hwif->channel << 6;\r\nelse\r\nbase += hwif->channel << 4;\r\nbase |= unit << unit;\r\nreturn base;\r\n}\r\nstatic u8 sil_ioread8(struct pci_dev *dev, unsigned long addr)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nu8 tmp = 0;\r\nif (host->host_priv)\r\ntmp = readb((void __iomem *)addr);\r\nelse\r\npci_read_config_byte(dev, addr, &tmp);\r\nreturn tmp;\r\n}\r\nstatic u16 sil_ioread16(struct pci_dev *dev, unsigned long addr)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nu16 tmp = 0;\r\nif (host->host_priv)\r\ntmp = readw((void __iomem *)addr);\r\nelse\r\npci_read_config_word(dev, addr, &tmp);\r\nreturn tmp;\r\n}\r\nstatic void sil_iowrite8(struct pci_dev *dev, u8 val, unsigned long addr)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nif (host->host_priv)\r\nwriteb(val, (void __iomem *)addr);\r\nelse\r\npci_write_config_byte(dev, addr, val);\r\n}\r\nstatic void sil_iowrite16(struct pci_dev *dev, u16 val, unsigned long addr)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nif (host->host_priv)\r\nwritew(val, (void __iomem *)addr);\r\nelse\r\npci_write_config_word(dev, addr, val);\r\n}\r\nstatic void sil_iowrite32(struct pci_dev *dev, u32 val, unsigned long addr)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nif (host->host_priv)\r\nwritel(val, (void __iomem *)addr);\r\nelse\r\npci_write_config_dword(dev, addr, val);\r\n}\r\nstatic u8 sil_pata_udma_filter(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long base = (unsigned long)hwif->hwif_data;\r\nu8 scsc, mask = 0;\r\nbase += (hwif->host_flags & IDE_HFLAG_MMIO) ? 0x4A : 0x8A;\r\nscsc = sil_ioread8(dev, base);\r\nswitch (scsc & 0x30) {\r\ncase 0x10:\r\nmask = ATA_UDMA6;\r\nbreak;\r\ncase 0x20:\r\nmask = ATA_UDMA6;\r\nbreak;\r\ncase 0x00:\r\nmask = ATA_UDMA5;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn mask;\r\n}\r\nstatic u8 sil_sata_udma_filter(ide_drive_t *drive)\r\n{\r\nchar *m = (char *)&drive->id[ATA_ID_PROD];\r\nreturn strstr(m, "Maxtor") ? ATA_UDMA5 : ATA_UDMA6;\r\n}\r\nstatic void sil_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstatic const u16 tf_speed[] = { 0x328a, 0x2283, 0x1281, 0x10c3, 0x10c1 };\r\nstatic const u16 data_speed[] = { 0x328a, 0x2283, 0x1104, 0x10c3, 0x10c1 };\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nide_drive_t *pair = ide_get_pair_dev(drive);\r\nu32 speedt = 0;\r\nu16 speedp = 0;\r\nunsigned long addr = siimage_seldev(drive, 0x04);\r\nunsigned long tfaddr = siimage_selreg(hwif, 0x02);\r\nunsigned long base = (unsigned long)hwif->hwif_data;\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nu8 tf_pio = pio;\r\nu8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;\r\nu8 addr_mask = hwif->channel ? (mmio ? 0xF4 : 0x84)\r\n: (mmio ? 0xB4 : 0x80);\r\nu8 mode = 0;\r\nu8 unit = drive->dn & 1;\r\nif (pair) {\r\nu8 pair_pio = pair->pio_mode - XFER_PIO_0;\r\nif (pair_pio < tf_pio)\r\ntf_pio = pair_pio;\r\n}\r\nspeedp = data_speed[pio];\r\nspeedt = tf_speed[tf_pio];\r\nsil_iowrite16(dev, speedp, addr);\r\nsil_iowrite16(dev, speedt, tfaddr);\r\nspeedp = sil_ioread16(dev, tfaddr - 2);\r\nspeedp &= ~0x200;\r\nmode = sil_ioread8(dev, base + addr_mask);\r\nmode &= ~(unit ? 0x30 : 0x03);\r\nif (ide_pio_need_iordy(drive, pio)) {\r\nspeedp |= 0x200;\r\nmode |= unit ? 0x10 : 0x01;\r\n}\r\nsil_iowrite16(dev, speedp, tfaddr - 2);\r\nsil_iowrite8(dev, mode, base + addr_mask);\r\n}\r\nstatic void sil_set_dma_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nstatic const u8 ultra6[] = { 0x0F, 0x0B, 0x07, 0x05, 0x03, 0x02, 0x01 };\r\nstatic const u8 ultra5[] = { 0x0C, 0x07, 0x05, 0x04, 0x02, 0x01 };\r\nstatic const u16 dma[] = { 0x2208, 0x10C2, 0x10C1 };\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long base = (unsigned long)hwif->hwif_data;\r\nu16 ultra = 0, multi = 0;\r\nu8 mode = 0, unit = drive->dn & 1;\r\nu8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;\r\nu8 scsc = 0, addr_mask = hwif->channel ? (mmio ? 0xF4 : 0x84)\r\n: (mmio ? 0xB4 : 0x80);\r\nunsigned long ma = siimage_seldev(drive, 0x08);\r\nunsigned long ua = siimage_seldev(drive, 0x0C);\r\nconst u8 speed = drive->dma_mode;\r\nscsc = sil_ioread8 (dev, base + (mmio ? 0x4A : 0x8A));\r\nmode = sil_ioread8 (dev, base + addr_mask);\r\nmulti = sil_ioread16(dev, ma);\r\nultra = sil_ioread16(dev, ua);\r\nmode &= ~(unit ? 0x30 : 0x03);\r\nultra &= ~0x3F;\r\nscsc = ((scsc & 0x30) == 0x00) ? 0 : 1;\r\nscsc = is_sata(hwif) ? 1 : scsc;\r\nif (speed >= XFER_UDMA_0) {\r\nmulti = dma[2];\r\nultra |= scsc ? ultra6[speed - XFER_UDMA_0] :\r\nultra5[speed - XFER_UDMA_0];\r\nmode |= unit ? 0x30 : 0x03;\r\n} else {\r\nmulti = dma[speed - XFER_MW_DMA_0];\r\nmode |= unit ? 0x20 : 0x02;\r\n}\r\nsil_iowrite8 (dev, mode, base + addr_mask);\r\nsil_iowrite16(dev, multi, ma);\r\nsil_iowrite16(dev, ultra, ua);\r\n}\r\nstatic int sil_test_irq(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long addr = siimage_selreg(hwif, 1);\r\nu8 val = sil_ioread8(dev, addr);\r\nreturn (val & 8) ? 1 : 0;\r\n}\r\nstatic int siimage_mmio_dma_test_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nvoid __iomem *sata_error_addr\r\n= (void __iomem *)hwif->sata_scr[SATA_ERROR_OFFSET];\r\nif (sata_error_addr) {\r\nunsigned long base = (unsigned long)hwif->hwif_data;\r\nu32 ext_stat = readl((void __iomem *)(base + 0x10));\r\nu8 watchdog = 0;\r\nif (ext_stat & ((hwif->channel) ? 0x40 : 0x10)) {\r\nu32 sata_error = readl(sata_error_addr);\r\nwritel(sata_error, sata_error_addr);\r\nwatchdog = (sata_error & 0x00680000) ? 1 : 0;\r\nprintk(KERN_WARNING "%s: sata_error = 0x%08x, "\r\n"watchdog = %d, %s\n",\r\ndrive->name, sata_error, watchdog, __func__);\r\n} else\r\nwatchdog = (ext_stat & 0x8000) ? 1 : 0;\r\next_stat >>= 16;\r\nif (!(ext_stat & 0x0404) && !watchdog)\r\nreturn 0;\r\n}\r\nif (readb((void __iomem *)(hwif->dma_base + ATA_DMA_STATUS)) & 4)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int siimage_dma_test_irq(ide_drive_t *drive)\r\n{\r\nif (drive->hwif->host_flags & IDE_HFLAG_MMIO)\r\nreturn siimage_mmio_dma_test_irq(drive);\r\nelse\r\nreturn ide_dma_test_irq(drive);\r\n}\r\nstatic int sil_sata_reset_poll(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nvoid __iomem *sata_status_addr\r\n= (void __iomem *)hwif->sata_scr[SATA_STATUS_OFFSET];\r\nif (sata_status_addr) {\r\nu32 sata_stat = readl(sata_status_addr);\r\nif ((sata_stat & 0x03) != 0x03) {\r\nprintk(KERN_WARNING "%s: reset phy dead, status=0x%08x\n",\r\nhwif->name, sata_stat);\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sil_sata_pre_reset(ide_drive_t *drive)\r\n{\r\nif (drive->media == ide_disk) {\r\ndrive->special_flags &=\r\n~(IDE_SFLAG_SET_GEOMETRY | IDE_SFLAG_RECALIBRATE);\r\n}\r\n}\r\nstatic int init_chipset_siimage(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nvoid __iomem *ioaddr = host->host_priv;\r\nunsigned long base, scsc_addr;\r\nu8 rev = dev->revision, tmp;\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, rev ? 1 : 255);\r\nif (ioaddr)\r\npci_set_master(dev);\r\nbase = (unsigned long)ioaddr;\r\nif (ioaddr && pdev_is_sata(dev)) {\r\nu32 tmp32, irq_mask;\r\nirq_mask = (1 << 22) | (1 << 23);\r\ntmp32 = readl(ioaddr + 0x48);\r\nif (tmp32 & irq_mask) {\r\ntmp32 &= ~irq_mask;\r\nwritel(tmp32, ioaddr + 0x48);\r\nreadl(ioaddr + 0x48);\r\n}\r\nwritel(0, ioaddr + 0x148);\r\nwritel(0, ioaddr + 0x1C8);\r\n}\r\nsil_iowrite8(dev, 0, base ? (base + 0xB4) : 0x80);\r\nsil_iowrite8(dev, 0, base ? (base + 0xF4) : 0x84);\r\nscsc_addr = base ? (base + 0x4A) : 0x8A;\r\ntmp = sil_ioread8(dev, scsc_addr);\r\nswitch (tmp & 0x30) {\r\ncase 0x00:\r\nsil_iowrite8(dev, tmp | 0x10, scsc_addr);\r\nbreak;\r\ncase 0x30:\r\nsil_iowrite8(dev, tmp & ~0x20, scsc_addr);\r\ncase 0x10:\r\nbreak;\r\ncase 0x20:\r\nbreak;\r\n}\r\ntmp = sil_ioread8(dev, scsc_addr);\r\nsil_iowrite8 (dev, 0x72, base + 0xA1);\r\nsil_iowrite16(dev, 0x328A, base + 0xA2);\r\nsil_iowrite32(dev, 0x62DD62DD, base + 0xA4);\r\nsil_iowrite32(dev, 0x43924392, base + 0xA8);\r\nsil_iowrite32(dev, 0x40094009, base + 0xAC);\r\nsil_iowrite8 (dev, 0x72, base ? (base + 0xE1) : 0xB1);\r\nsil_iowrite16(dev, 0x328A, base ? (base + 0xE2) : 0xB2);\r\nsil_iowrite32(dev, 0x62DD62DD, base ? (base + 0xE4) : 0xB4);\r\nsil_iowrite32(dev, 0x43924392, base ? (base + 0xE8) : 0xB8);\r\nsil_iowrite32(dev, 0x40094009, base ? (base + 0xEC) : 0xBC);\r\nif (base && pdev_is_sata(dev)) {\r\nwritel(0xFFFF0000, ioaddr + 0x108);\r\nwritel(0xFFFF0000, ioaddr + 0x188);\r\nwritel(0x00680000, ioaddr + 0x148);\r\nwritel(0x00680000, ioaddr + 0x1C8);\r\n}\r\nif (!pdev_is_sata(dev)) {\r\nstatic const char *clk_str[] =\r\n{ "== 100", "== 133", "== 2X PCI", "DISABLED!" };\r\ntmp >>= 4;\r\nprintk(KERN_INFO DRV_NAME " %s: BASE CLOCK %s\n",\r\npci_name(dev), clk_str[tmp & 3]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit init_mmio_iops_siimage(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nvoid *addr = host->host_priv;\r\nu8 ch = hwif->channel;\r\nstruct ide_io_ports *io_ports = &hwif->io_ports;\r\nunsigned long base;\r\nhwif->host_flags |= IDE_HFLAG_MMIO;\r\nhwif->hwif_data = addr;\r\nmemset(io_ports, 0, sizeof(*io_ports));\r\nbase = (unsigned long)addr;\r\nif (ch)\r\nbase += 0xC0;\r\nelse\r\nbase += 0x80;\r\nio_ports->data_addr = base;\r\nio_ports->error_addr = base + 1;\r\nio_ports->nsect_addr = base + 2;\r\nio_ports->lbal_addr = base + 3;\r\nio_ports->lbam_addr = base + 4;\r\nio_ports->lbah_addr = base + 5;\r\nio_ports->device_addr = base + 6;\r\nio_ports->status_addr = base + 7;\r\nio_ports->ctl_addr = base + 10;\r\nif (pdev_is_sata(dev)) {\r\nbase = (unsigned long)addr;\r\nif (ch)\r\nbase += 0x80;\r\nhwif->sata_scr[SATA_STATUS_OFFSET] = base + 0x104;\r\nhwif->sata_scr[SATA_ERROR_OFFSET] = base + 0x108;\r\nhwif->sata_scr[SATA_CONTROL_OFFSET] = base + 0x100;\r\n}\r\nhwif->irq = dev->irq;\r\nhwif->dma_base = (unsigned long)addr + (ch ? 0x08 : 0x00);\r\n}\r\nstatic int is_dev_seagate_sata(ide_drive_t *drive)\r\n{\r\nconst char *s = (const char *)&drive->id[ATA_ID_PROD];\r\nunsigned len = strnlen(s, ATA_ID_PROD_LEN);\r\nif ((len > 4) && (!memcmp(s, "ST", 2)))\r\nif ((!memcmp(s + len - 2, "AS", 2)) ||\r\n(!memcmp(s + len - 3, "ASL", 3))) {\r\nprintk(KERN_INFO "%s: applying pessimistic Seagate "\r\n"errata fix\n", drive->name);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sil_quirkproc(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nif (!is_sata(hwif) || !is_dev_seagate_sata(drive))\r\nhwif->rqsize = 128;\r\n}\r\nstatic void __devinit init_iops_siimage(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nhwif->hwif_data = NULL;\r\nhwif->rqsize = 15;\r\nif (host->host_priv)\r\ninit_mmio_iops_siimage(hwif);\r\n}\r\nstatic u8 sil_cable_detect(ide_hwif_t *hwif)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(hwif->dev);\r\nunsigned long addr = siimage_selreg(hwif, 0);\r\nu8 ata66 = sil_ioread8(dev, addr);\r\nreturn (ata66 & 0x01) ? ATA_CBL_PATA80 : ATA_CBL_PATA40;\r\n}\r\nstatic int __devinit siimage_init_one(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nvoid __iomem *ioaddr = NULL;\r\nresource_size_t bar5 = pci_resource_start(dev, 5);\r\nunsigned long barsize = pci_resource_len(dev, 5);\r\nint rc;\r\nstruct ide_port_info d;\r\nu8 idx = id->driver_data;\r\nu8 BA5_EN;\r\nd = siimage_chipsets[idx];\r\nif (idx) {\r\nstatic int first = 1;\r\nif (first) {\r\nprintk(KERN_INFO DRV_NAME ": For full SATA support you "\r\n"should use the libata sata_sil module.\n");\r\nfirst = 0;\r\n}\r\nd.host_flags |= IDE_HFLAG_NO_ATAPI_DMA;\r\n}\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\npci_read_config_byte(dev, 0x8A, &BA5_EN);\r\nif ((BA5_EN & 0x01) || bar5) {\r\nif (!request_mem_region(bar5, barsize, d.name)) {\r\nprintk(KERN_WARNING DRV_NAME " %s: MMIO ports not "\r\n"available\n", pci_name(dev));\r\n} else {\r\nioaddr = pci_ioremap_bar(dev, 5);\r\nif (ioaddr == NULL)\r\nrelease_mem_region(bar5, barsize);\r\n}\r\n}\r\nrc = ide_pci_init_one(dev, &d, ioaddr);\r\nif (rc) {\r\nif (ioaddr) {\r\niounmap(ioaddr);\r\nrelease_mem_region(bar5, barsize);\r\n}\r\npci_disable_device(dev);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __devexit siimage_remove(struct pci_dev *dev)\r\n{\r\nstruct ide_host *host = pci_get_drvdata(dev);\r\nvoid __iomem *ioaddr = host->host_priv;\r\nide_pci_remove(dev);\r\nif (ioaddr) {\r\nresource_size_t bar5 = pci_resource_start(dev, 5);\r\nunsigned long barsize = pci_resource_len(dev, 5);\r\niounmap(ioaddr);\r\nrelease_mem_region(bar5, barsize);\r\n}\r\npci_disable_device(dev);\r\n}\r\nstatic int __init siimage_ide_init(void)\r\n{\r\nreturn ide_pci_register_driver(&siimage_pci_driver);\r\n}\r\nstatic void __exit siimage_ide_exit(void)\r\n{\r\npci_unregister_driver(&siimage_pci_driver);\r\n}
