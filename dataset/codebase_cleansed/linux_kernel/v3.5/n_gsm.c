static inline u8 gsm_fcs_add(u8 fcs, u8 c)\r\n{\r\nreturn gsm_fcs8[fcs ^ c];\r\n}\r\nstatic inline u8 gsm_fcs_add_block(u8 fcs, u8 *c, int len)\r\n{\r\nwhile (len--)\r\nfcs = gsm_fcs8[fcs ^ *c++];\r\nreturn fcs;\r\n}\r\nstatic int gsm_read_ea(unsigned int *val, u8 c)\r\n{\r\n*val <<= 7;\r\n*val |= c >> 1;\r\nreturn c & EA;\r\n}\r\nstatic u8 gsm_encode_modem(const struct gsm_dlci *dlci)\r\n{\r\nu8 modembits = 0;\r\nif (dlci->throttled)\r\nmodembits |= MDM_FC;\r\nif (dlci->modem_tx & TIOCM_DTR)\r\nmodembits |= MDM_RTC;\r\nif (dlci->modem_tx & TIOCM_RTS)\r\nmodembits |= MDM_RTR;\r\nif (dlci->modem_tx & TIOCM_RI)\r\nmodembits |= MDM_IC;\r\nif (dlci->modem_tx & TIOCM_CD)\r\nmodembits |= MDM_DV;\r\nreturn modembits;\r\n}\r\nstatic void gsm_print_packet(const char *hdr, int addr, int cr,\r\nu8 control, const u8 *data, int dlen)\r\n{\r\nif (!(debug & 1))\r\nreturn;\r\npr_info("%s %d) %c: ", hdr, addr, "RC"[cr]);\r\nswitch (control & ~PF) {\r\ncase SABM:\r\npr_cont("SABM");\r\nbreak;\r\ncase UA:\r\npr_cont("UA");\r\nbreak;\r\ncase DISC:\r\npr_cont("DISC");\r\nbreak;\r\ncase DM:\r\npr_cont("DM");\r\nbreak;\r\ncase UI:\r\npr_cont("UI");\r\nbreak;\r\ncase UIH:\r\npr_cont("UIH");\r\nbreak;\r\ndefault:\r\nif (!(control & 0x01)) {\r\npr_cont("I N(S)%d N(R)%d",\r\n(control & 0x0E) >> 1, (control & 0xE) >> 5);\r\n} else switch (control & 0x0F) {\r\ncase RR:\r\npr_cont("RR(%d)", (control & 0xE0) >> 5);\r\nbreak;\r\ncase RNR:\r\npr_cont("RNR(%d)", (control & 0xE0) >> 5);\r\nbreak;\r\ncase REJ:\r\npr_cont("REJ(%d)", (control & 0xE0) >> 5);\r\nbreak;\r\ndefault:\r\npr_cont("[%02X]", control);\r\n}\r\n}\r\nif (control & PF)\r\npr_cont("(P)");\r\nelse\r\npr_cont("(F)");\r\nif (dlen) {\r\nint ct = 0;\r\nwhile (dlen--) {\r\nif (ct % 8 == 0) {\r\npr_cont("\n");\r\npr_debug(" ");\r\n}\r\npr_cont("%02X ", *data++);\r\nct++;\r\n}\r\n}\r\npr_cont("\n");\r\n}\r\nstatic int gsm_stuff_frame(const u8 *input, u8 *output, int len)\r\n{\r\nint olen = 0;\r\nwhile (len--) {\r\nif (*input == GSM1_SOF || *input == GSM1_ESCAPE\r\n|| *input == XON || *input == XOFF) {\r\n*output++ = GSM1_ESCAPE;\r\n*output++ = *input++ ^ GSM1_ESCAPE_BITS;\r\nolen++;\r\n} else\r\n*output++ = *input++;\r\nolen++;\r\n}\r\nreturn olen;\r\n}\r\nstatic void gsm_send(struct gsm_mux *gsm, int addr, int cr, int control)\r\n{\r\nint len;\r\nu8 cbuf[10];\r\nu8 ibuf[3];\r\nswitch (gsm->encoding) {\r\ncase 0:\r\ncbuf[0] = GSM0_SOF;\r\ncbuf[1] = (addr << 2) | (cr << 1) | EA;\r\ncbuf[2] = control;\r\ncbuf[3] = EA;\r\ncbuf[4] = 0xFF - gsm_fcs_add_block(INIT_FCS, cbuf + 1, 3);\r\ncbuf[5] = GSM0_SOF;\r\nlen = 6;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nibuf[0] = (addr << 2) | (cr << 1) | EA;\r\nibuf[1] = control;\r\nibuf[2] = 0xFF - gsm_fcs_add_block(INIT_FCS, ibuf, 2);\r\nlen = gsm_stuff_frame(ibuf, cbuf + 1, 3);\r\ncbuf[0] = GSM1_SOF;\r\ncbuf[len + 1] = GSM1_SOF;\r\nlen += 2;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ngsm->output(gsm, cbuf, len);\r\ngsm_print_packet("-->", addr, cr, control, NULL, 0);\r\n}\r\nstatic inline void gsm_response(struct gsm_mux *gsm, int addr, int control)\r\n{\r\ngsm_send(gsm, addr, 0, control);\r\n}\r\nstatic inline void gsm_command(struct gsm_mux *gsm, int addr, int control)\r\n{\r\ngsm_send(gsm, addr, 1, control);\r\n}\r\nstatic struct gsm_msg *gsm_data_alloc(struct gsm_mux *gsm, u8 addr, int len,\r\nu8 ctrl)\r\n{\r\nstruct gsm_msg *m = kmalloc(sizeof(struct gsm_msg) + len + HDR_LEN,\r\nGFP_ATOMIC);\r\nif (m == NULL)\r\nreturn NULL;\r\nm->data = m->buffer + HDR_LEN - 1;\r\nm->len = len;\r\nm->addr = addr;\r\nm->ctrl = ctrl;\r\nm->next = NULL;\r\nreturn m;\r\n}\r\nstatic void gsm_data_kick(struct gsm_mux *gsm)\r\n{\r\nstruct gsm_msg *msg = gsm->tx_head;\r\nint len;\r\nint skip_sof = 0;\r\nif (gsm->constipated)\r\nreturn;\r\nwhile (gsm->tx_head != NULL) {\r\nmsg = gsm->tx_head;\r\nif (gsm->encoding != 0) {\r\ngsm->txframe[0] = GSM1_SOF;\r\nlen = gsm_stuff_frame(msg->data,\r\ngsm->txframe + 1, msg->len);\r\ngsm->txframe[len + 1] = GSM1_SOF;\r\nlen += 2;\r\n} else {\r\ngsm->txframe[0] = GSM0_SOF;\r\nmemcpy(gsm->txframe + 1 , msg->data, msg->len);\r\ngsm->txframe[msg->len + 1] = GSM0_SOF;\r\nlen = msg->len + 2;\r\n}\r\nif (debug & 4)\r\nprint_hex_dump_bytes("gsm_data_kick: ",\r\nDUMP_PREFIX_OFFSET,\r\ngsm->txframe, len);\r\nif (gsm->output(gsm, gsm->txframe + skip_sof,\r\nlen - skip_sof) < 0)\r\nbreak;\r\ngsm->tx_head = msg->next;\r\nif (gsm->tx_head == NULL)\r\ngsm->tx_tail = NULL;\r\ngsm->tx_bytes -= msg->len;\r\nkfree(msg);\r\nskip_sof = 1;\r\n}\r\n}\r\nstatic void __gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\r\n{\r\nstruct gsm_mux *gsm = dlci->gsm;\r\nu8 *dp = msg->data;\r\nu8 *fcs = dp + msg->len;\r\nif (gsm->encoding == 0) {\r\nif (msg->len < 128)\r\n*--dp = (msg->len << 1) | EA;\r\nelse {\r\n*--dp = (msg->len >> 7);\r\n*--dp = (msg->len & 127) << 1;\r\n}\r\n}\r\n*--dp = msg->ctrl;\r\nif (gsm->initiator)\r\n*--dp = (msg->addr << 2) | 2 | EA;\r\nelse\r\n*--dp = (msg->addr << 2) | EA;\r\n*fcs = gsm_fcs_add_block(INIT_FCS, dp , msg->data - dp);\r\nif (msg->ctrl == UI || msg->ctrl == (UI|PF))\r\n*fcs = gsm_fcs_add_block(*fcs, msg->data, msg->len);\r\n*fcs = 0xFF - *fcs;\r\ngsm_print_packet("Q> ", msg->addr, gsm->initiator, msg->ctrl,\r\nmsg->data, msg->len);\r\nmsg->len += (msg->data - dp) + 1;\r\nmsg->data = dp;\r\nif (gsm->tx_tail)\r\ngsm->tx_tail->next = msg;\r\nelse\r\ngsm->tx_head = msg;\r\ngsm->tx_tail = msg;\r\ngsm->tx_bytes += msg->len;\r\ngsm_data_kick(gsm);\r\n}\r\nstatic void gsm_data_queue(struct gsm_dlci *dlci, struct gsm_msg *msg)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\r\n__gsm_data_queue(dlci, msg);\r\nspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\r\n}\r\nstatic int gsm_dlci_data_output(struct gsm_mux *gsm, struct gsm_dlci *dlci)\r\n{\r\nstruct gsm_msg *msg;\r\nu8 *dp;\r\nint len, total_size, size;\r\nint h = dlci->adaption - 1;\r\ntotal_size = 0;\r\nwhile(1) {\r\nlen = kfifo_len(dlci->fifo);\r\nif (len == 0)\r\nreturn total_size;\r\nif (len > gsm->mtu)\r\nlen = gsm->mtu;\r\nsize = len + h;\r\nmsg = gsm_data_alloc(gsm, dlci->addr, size, gsm->ftype);\r\nif (msg == NULL)\r\nreturn -ENOMEM;\r\ndp = msg->data;\r\nswitch (dlci->adaption) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\n*dp++ = gsm_encode_modem(dlci);\r\nbreak;\r\n}\r\nWARN_ON(kfifo_out_locked(dlci->fifo, dp , len, &dlci->lock) != len);\r\n__gsm_data_queue(dlci, msg);\r\ntotal_size += size;\r\n}\r\nreturn total_size;\r\n}\r\nstatic int gsm_dlci_data_output_framed(struct gsm_mux *gsm,\r\nstruct gsm_dlci *dlci)\r\n{\r\nstruct gsm_msg *msg;\r\nu8 *dp;\r\nint len, size;\r\nint last = 0, first = 0;\r\nint overhead = 0;\r\nif (dlci->adaption == 4)\r\noverhead = 1;\r\nif (dlci->skb == NULL) {\r\ndlci->skb = skb_dequeue(&dlci->skb_list);\r\nif (dlci->skb == NULL)\r\nreturn 0;\r\nfirst = 1;\r\n}\r\nlen = dlci->skb->len + overhead;\r\nif (len > gsm->mtu) {\r\nif (dlci->adaption == 3) {\r\nkfree_skb(dlci->skb);\r\ndlci->skb = NULL;\r\nreturn 0;\r\n}\r\nlen = gsm->mtu;\r\n} else\r\nlast = 1;\r\nsize = len + overhead;\r\nmsg = gsm_data_alloc(gsm, dlci->addr, size, gsm->ftype);\r\nif (msg == NULL)\r\nreturn -ENOMEM;\r\ndp = msg->data;\r\nif (dlci->adaption == 4) {\r\n*dp++ = last << 7 | first << 6 | 1;\r\nlen--;\r\n}\r\nmemcpy(dp, dlci->skb->data, len);\r\nskb_pull(dlci->skb, len);\r\n__gsm_data_queue(dlci, msg);\r\nif (last) {\r\nkfree_skb(dlci->skb);\r\ndlci->skb = NULL;\r\n}\r\nreturn size;\r\n}\r\nstatic void gsm_dlci_data_sweep(struct gsm_mux *gsm)\r\n{\r\nint len;\r\nint i = 1;\r\nwhile (i < NUM_DLCI) {\r\nstruct gsm_dlci *dlci;\r\nif (gsm->tx_bytes > TX_THRESH_HI)\r\nbreak;\r\ndlci = gsm->dlci[i];\r\nif (dlci == NULL || dlci->constipated) {\r\ni++;\r\ncontinue;\r\n}\r\nif (dlci->adaption < 3 && !dlci->net)\r\nlen = gsm_dlci_data_output(gsm, dlci);\r\nelse\r\nlen = gsm_dlci_data_output_framed(gsm, dlci);\r\nif (len < 0)\r\nbreak;\r\nif (len == 0)\r\ni++;\r\n}\r\n}\r\nstatic void gsm_dlci_data_kick(struct gsm_dlci *dlci)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dlci->gsm->tx_lock, flags);\r\nif (dlci->gsm->tx_bytes == 0) {\r\nif (dlci->net)\r\ngsm_dlci_data_output_framed(dlci->gsm, dlci);\r\nelse\r\ngsm_dlci_data_output(dlci->gsm, dlci);\r\n} else if (dlci->gsm->tx_bytes < TX_THRESH_LO)\r\ngsm_dlci_data_sweep(dlci->gsm);\r\nspin_unlock_irqrestore(&dlci->gsm->tx_lock, flags);\r\n}\r\nstatic void gsm_control_reply(struct gsm_mux *gsm, int cmd, u8 *data,\r\nint dlen)\r\n{\r\nstruct gsm_msg *msg;\r\nmsg = gsm_data_alloc(gsm, 0, dlen + 2, gsm->ftype);\r\nif (msg == NULL)\r\nreturn;\r\nmsg->data[0] = (cmd & 0xFE) << 1 | EA;\r\nmsg->data[1] = (dlen << 1) | EA;\r\nmemcpy(msg->data + 2, data, dlen);\r\ngsm_data_queue(gsm->dlci[0], msg);\r\n}\r\nstatic void gsm_process_modem(struct tty_struct *tty, struct gsm_dlci *dlci,\r\nu32 modem, int clen)\r\n{\r\nint mlines = 0;\r\nu8 brk = 0;\r\nif (clen == 2)\r\nmodem = modem & 0x7f;\r\nelse {\r\nbrk = modem & 0x7f;\r\nmodem = (modem >> 7) & 0x7f;\r\n};\r\nif (modem & MDM_FC) {\r\ndlci->constipated = 1;\r\n}\r\nif (modem & MDM_RTC) {\r\nmlines |= TIOCM_DSR | TIOCM_DTR;\r\ndlci->constipated = 0;\r\ngsm_dlci_data_kick(dlci);\r\n}\r\nif (modem & MDM_RTR)\r\nmlines |= TIOCM_RTS | TIOCM_CTS;\r\nif (modem & MDM_IC)\r\nmlines |= TIOCM_RI;\r\nif (modem & MDM_DV)\r\nmlines |= TIOCM_CD;\r\nif (tty) {\r\nif ((mlines & TIOCM_CD) == 0 && (dlci->modem_rx & TIOCM_CD))\r\nif (!(tty->termios->c_cflag & CLOCAL))\r\ntty_hangup(tty);\r\nif (brk & 0x01)\r\ntty_insert_flip_char(tty, 0, TTY_BREAK);\r\n}\r\ndlci->modem_rx = mlines;\r\n}\r\nstatic void gsm_control_modem(struct gsm_mux *gsm, u8 *data, int clen)\r\n{\r\nunsigned int addr = 0;\r\nunsigned int modem = 0;\r\nstruct gsm_dlci *dlci;\r\nint len = clen;\r\nu8 *dp = data;\r\nstruct tty_struct *tty;\r\nwhile (gsm_read_ea(&addr, *dp++) == 0) {\r\nlen--;\r\nif (len == 0)\r\nreturn;\r\n}\r\nlen--;\r\nif (len <= 0)\r\nreturn;\r\naddr >>= 1;\r\nif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\r\nreturn;\r\ndlci = gsm->dlci[addr];\r\nwhile (gsm_read_ea(&modem, *dp++) == 0) {\r\nlen--;\r\nif (len == 0)\r\nreturn;\r\n}\r\ntty = tty_port_tty_get(&dlci->port);\r\ngsm_process_modem(tty, dlci, modem, clen);\r\nif (tty) {\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\ngsm_control_reply(gsm, CMD_MSC, data, clen);\r\n}\r\nstatic void gsm_control_rls(struct gsm_mux *gsm, u8 *data, int clen)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned int addr = 0 ;\r\nu8 bits;\r\nint len = clen;\r\nu8 *dp = data;\r\nwhile (gsm_read_ea(&addr, *dp++) == 0) {\r\nlen--;\r\nif (len == 0)\r\nreturn;\r\n}\r\nlen--;\r\nif (len <= 0)\r\nreturn;\r\naddr >>= 1;\r\nif (addr == 0 || addr >= NUM_DLCI || gsm->dlci[addr] == NULL)\r\nreturn;\r\nbits = *dp;\r\nif ((bits & 1) == 0)\r\nreturn;\r\ntty = tty_port_tty_get(&gsm->dlci[addr]->port);\r\nif (tty) {\r\nif (bits & 2)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nif (bits & 4)\r\ntty_insert_flip_char(tty, 0, TTY_PARITY);\r\nif (bits & 8)\r\ntty_insert_flip_char(tty, 0, TTY_FRAME);\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\n}\r\ngsm_control_reply(gsm, CMD_RLS, data, clen);\r\n}\r\nstatic void gsm_control_message(struct gsm_mux *gsm, unsigned int command,\r\nu8 *data, int clen)\r\n{\r\nu8 buf[1];\r\nswitch (command) {\r\ncase CMD_CLD: {\r\nstruct gsm_dlci *dlci = gsm->dlci[0];\r\nif (dlci) {\r\ndlci->dead = 1;\r\ngsm->dead = 1;\r\ngsm_dlci_begin_close(dlci);\r\n}\r\n}\r\nbreak;\r\ncase CMD_TEST:\r\ngsm_control_reply(gsm, CMD_TEST, data, clen);\r\nbreak;\r\ncase CMD_FCON:\r\ngsm->constipated = 1;\r\ngsm_control_reply(gsm, CMD_FCON, NULL, 0);\r\nbreak;\r\ncase CMD_FCOFF:\r\ngsm->constipated = 0;\r\ngsm_control_reply(gsm, CMD_FCOFF, NULL, 0);\r\ngsm_data_kick(gsm);\r\nbreak;\r\ncase CMD_MSC:\r\ngsm_control_modem(gsm, data, clen);\r\nbreak;\r\ncase CMD_RLS:\r\ngsm_control_rls(gsm, data, clen);\r\nbreak;\r\ncase CMD_PSC:\r\ngsm_control_reply(gsm, CMD_PSC, NULL, 0);\r\nbreak;\r\ncase CMD_PN:\r\ncase CMD_RPN:\r\ncase CMD_SNC:\r\ndefault:\r\nbuf[0] = command;\r\ngsm_control_reply(gsm, CMD_NSC, buf, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void gsm_control_response(struct gsm_mux *gsm, unsigned int command,\r\nu8 *data, int clen)\r\n{\r\nstruct gsm_control *ctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gsm->control_lock, flags);\r\nctrl = gsm->pending_cmd;\r\ncommand |= 1;\r\nif (ctrl != NULL && (command == ctrl->cmd || command == CMD_NSC)) {\r\ndel_timer(&gsm->t2_timer);\r\ngsm->pending_cmd = NULL;\r\nif (command == CMD_NSC)\r\nctrl->error = -EOPNOTSUPP;\r\nctrl->done = 1;\r\nwake_up(&gsm->event);\r\n}\r\nspin_unlock_irqrestore(&gsm->control_lock, flags);\r\n}\r\nstatic void gsm_control_transmit(struct gsm_mux *gsm, struct gsm_control *ctrl)\r\n{\r\nstruct gsm_msg *msg = gsm_data_alloc(gsm, 0, ctrl->len + 1, gsm->ftype);\r\nif (msg == NULL)\r\nreturn;\r\nmsg->data[0] = (ctrl->cmd << 1) | 2 | EA;\r\nmemcpy(msg->data + 1, ctrl->data, ctrl->len);\r\ngsm_data_queue(gsm->dlci[0], msg);\r\n}\r\nstatic void gsm_control_retransmit(unsigned long data)\r\n{\r\nstruct gsm_mux *gsm = (struct gsm_mux *)data;\r\nstruct gsm_control *ctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gsm->control_lock, flags);\r\nctrl = gsm->pending_cmd;\r\nif (ctrl) {\r\ngsm->cretries--;\r\nif (gsm->cretries == 0) {\r\ngsm->pending_cmd = NULL;\r\nctrl->error = -ETIMEDOUT;\r\nctrl->done = 1;\r\nspin_unlock_irqrestore(&gsm->control_lock, flags);\r\nwake_up(&gsm->event);\r\nreturn;\r\n}\r\ngsm_control_transmit(gsm, ctrl);\r\nmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\r\n}\r\nspin_unlock_irqrestore(&gsm->control_lock, flags);\r\n}\r\nstatic struct gsm_control *gsm_control_send(struct gsm_mux *gsm,\r\nunsigned int command, u8 *data, int clen)\r\n{\r\nstruct gsm_control *ctrl = kzalloc(sizeof(struct gsm_control),\r\nGFP_KERNEL);\r\nunsigned long flags;\r\nif (ctrl == NULL)\r\nreturn NULL;\r\nretry:\r\nwait_event(gsm->event, gsm->pending_cmd == NULL);\r\nspin_lock_irqsave(&gsm->control_lock, flags);\r\nif (gsm->pending_cmd != NULL) {\r\nspin_unlock_irqrestore(&gsm->control_lock, flags);\r\ngoto retry;\r\n}\r\nctrl->cmd = command;\r\nctrl->data = data;\r\nctrl->len = clen;\r\ngsm->pending_cmd = ctrl;\r\ngsm->cretries = gsm->n2;\r\nmod_timer(&gsm->t2_timer, jiffies + gsm->t2 * HZ / 100);\r\ngsm_control_transmit(gsm, ctrl);\r\nspin_unlock_irqrestore(&gsm->control_lock, flags);\r\nreturn ctrl;\r\n}\r\nstatic int gsm_control_wait(struct gsm_mux *gsm, struct gsm_control *control)\r\n{\r\nint err;\r\nwait_event(gsm->event, control->done == 1);\r\nerr = control->error;\r\nkfree(control);\r\nreturn err;\r\n}\r\nstatic void gsm_dlci_close(struct gsm_dlci *dlci)\r\n{\r\ndel_timer(&dlci->t1);\r\nif (debug & 8)\r\npr_debug("DLCI %d goes closed.\n", dlci->addr);\r\ndlci->state = DLCI_CLOSED;\r\nif (dlci->addr != 0) {\r\nstruct tty_struct *tty = tty_port_tty_get(&dlci->port);\r\nif (tty) {\r\ntty_hangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nkfifo_reset(dlci->fifo);\r\n} else\r\ndlci->gsm->dead = 1;\r\nwake_up(&dlci->gsm->event);\r\n}\r\nstatic void gsm_dlci_open(struct gsm_dlci *dlci)\r\n{\r\ndel_timer(&dlci->t1);\r\ndlci->state = DLCI_OPEN;\r\nif (debug & 8)\r\npr_debug("DLCI %d goes open.\n", dlci->addr);\r\nwake_up(&dlci->gsm->event);\r\n}\r\nstatic void gsm_dlci_t1(unsigned long data)\r\n{\r\nstruct gsm_dlci *dlci = (struct gsm_dlci *)data;\r\nstruct gsm_mux *gsm = dlci->gsm;\r\nswitch (dlci->state) {\r\ncase DLCI_OPENING:\r\ndlci->retries--;\r\nif (dlci->retries) {\r\ngsm_command(dlci->gsm, dlci->addr, SABM|PF);\r\nmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\r\n} else\r\ngsm_dlci_close(dlci);\r\nbreak;\r\ncase DLCI_CLOSING:\r\ndlci->retries--;\r\nif (dlci->retries) {\r\ngsm_command(dlci->gsm, dlci->addr, DISC|PF);\r\nmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\r\n} else\r\ngsm_dlci_close(dlci);\r\nbreak;\r\n}\r\n}\r\nstatic void gsm_dlci_begin_open(struct gsm_dlci *dlci)\r\n{\r\nstruct gsm_mux *gsm = dlci->gsm;\r\nif (dlci->state == DLCI_OPEN || dlci->state == DLCI_OPENING)\r\nreturn;\r\ndlci->retries = gsm->n2;\r\ndlci->state = DLCI_OPENING;\r\ngsm_command(dlci->gsm, dlci->addr, SABM|PF);\r\nmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\r\n}\r\nstatic void gsm_dlci_begin_close(struct gsm_dlci *dlci)\r\n{\r\nstruct gsm_mux *gsm = dlci->gsm;\r\nif (dlci->state == DLCI_CLOSED || dlci->state == DLCI_CLOSING)\r\nreturn;\r\ndlci->retries = gsm->n2;\r\ndlci->state = DLCI_CLOSING;\r\ngsm_command(dlci->gsm, dlci->addr, DISC|PF);\r\nmod_timer(&dlci->t1, jiffies + gsm->t1 * HZ / 100);\r\n}\r\nstatic void gsm_dlci_data(struct gsm_dlci *dlci, u8 *data, int clen)\r\n{\r\nstruct tty_port *port = &dlci->port;\r\nstruct tty_struct *tty = tty_port_tty_get(port);\r\nunsigned int modem = 0;\r\nint len = clen;\r\nif (debug & 16)\r\npr_debug("%d bytes for tty %p\n", len, tty);\r\nif (tty) {\r\nswitch (dlci->adaption) {\r\ncase 4:\r\nbreak;\r\ncase 3:\r\nbreak;\r\ncase 2:\r\nwhile (gsm_read_ea(&modem, *data++) == 0) {\r\nlen--;\r\nif (len == 0)\r\nreturn;\r\n}\r\ngsm_process_modem(tty, dlci, modem, clen);\r\ncase 1:\r\ndefault:\r\ntty_insert_flip_string(tty, data, len);\r\ntty_flip_buffer_push(tty);\r\n}\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void gsm_dlci_command(struct gsm_dlci *dlci, u8 *data, int len)\r\n{\r\nunsigned int command = 0;\r\nwhile (len-- > 0) {\r\nif (gsm_read_ea(&command, *data++) == 1) {\r\nint clen = *data++;\r\nlen--;\r\nclen >>= 1;\r\nif (clen > len)\r\nreturn;\r\nif (command & 1)\r\ngsm_control_message(dlci->gsm, command,\r\ndata, clen);\r\nelse\r\ngsm_control_response(dlci->gsm, command,\r\ndata, clen);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic struct gsm_dlci *gsm_dlci_alloc(struct gsm_mux *gsm, int addr)\r\n{\r\nstruct gsm_dlci *dlci = kzalloc(sizeof(struct gsm_dlci), GFP_ATOMIC);\r\nif (dlci == NULL)\r\nreturn NULL;\r\nspin_lock_init(&dlci->lock);\r\nkref_init(&dlci->ref);\r\nmutex_init(&dlci->mutex);\r\ndlci->fifo = &dlci->_fifo;\r\nif (kfifo_alloc(&dlci->_fifo, 4096, GFP_KERNEL) < 0) {\r\nkfree(dlci);\r\nreturn NULL;\r\n}\r\nskb_queue_head_init(&dlci->skb_list);\r\ninit_timer(&dlci->t1);\r\ndlci->t1.function = gsm_dlci_t1;\r\ndlci->t1.data = (unsigned long)dlci;\r\ntty_port_init(&dlci->port);\r\ndlci->port.ops = &gsm_port_ops;\r\ndlci->gsm = gsm;\r\ndlci->addr = addr;\r\ndlci->adaption = gsm->adaption;\r\ndlci->state = DLCI_CLOSED;\r\nif (addr)\r\ndlci->data = gsm_dlci_data;\r\nelse\r\ndlci->data = gsm_dlci_command;\r\ngsm->dlci[addr] = dlci;\r\nreturn dlci;\r\n}\r\nstatic void gsm_dlci_free(struct kref *ref)\r\n{\r\nstruct gsm_dlci *dlci = container_of(ref, struct gsm_dlci, ref);\r\ndel_timer_sync(&dlci->t1);\r\ndlci->gsm->dlci[dlci->addr] = NULL;\r\nkfifo_free(dlci->fifo);\r\nwhile ((dlci->skb = skb_dequeue(&dlci->skb_list)))\r\nkfree_skb(dlci->skb);\r\nkfree(dlci);\r\n}\r\nstatic inline void dlci_get(struct gsm_dlci *dlci)\r\n{\r\nkref_get(&dlci->ref);\r\n}\r\nstatic inline void dlci_put(struct gsm_dlci *dlci)\r\n{\r\nkref_put(&dlci->ref, gsm_dlci_free);\r\n}\r\nstatic void gsm_dlci_release(struct gsm_dlci *dlci)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&dlci->port);\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\ndlci_put(dlci);\r\n}\r\nstatic void gsm_queue(struct gsm_mux *gsm)\r\n{\r\nstruct gsm_dlci *dlci;\r\nu8 cr;\r\nint address;\r\nif ((gsm->control & ~PF) == UI)\r\ngsm->fcs = gsm_fcs_add_block(gsm->fcs, gsm->buf, gsm->len);\r\nif (gsm->encoding == 0){\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, gsm->received_fcs);\r\n}\r\nif (gsm->fcs != GOOD_FCS) {\r\ngsm->bad_fcs++;\r\nif (debug & 4)\r\npr_debug("BAD FCS %02x\n", gsm->fcs);\r\nreturn;\r\n}\r\naddress = gsm->address >> 1;\r\nif (address >= NUM_DLCI)\r\ngoto invalid;\r\ncr = gsm->address & 1;\r\ngsm_print_packet("<--", address, cr, gsm->control, gsm->buf, gsm->len);\r\ncr ^= 1 - gsm->initiator;\r\ndlci = gsm->dlci[address];\r\nswitch (gsm->control) {\r\ncase SABM|PF:\r\nif (cr == 0)\r\ngoto invalid;\r\nif (dlci == NULL)\r\ndlci = gsm_dlci_alloc(gsm, address);\r\nif (dlci == NULL)\r\nreturn;\r\nif (dlci->dead)\r\ngsm_response(gsm, address, DM);\r\nelse {\r\ngsm_response(gsm, address, UA);\r\ngsm_dlci_open(dlci);\r\n}\r\nbreak;\r\ncase DISC|PF:\r\nif (cr == 0)\r\ngoto invalid;\r\nif (dlci == NULL || dlci->state == DLCI_CLOSED) {\r\ngsm_response(gsm, address, DM);\r\nreturn;\r\n}\r\ngsm_response(gsm, address, UA);\r\ngsm_dlci_close(dlci);\r\nbreak;\r\ncase UA:\r\ncase UA|PF:\r\nif (cr == 0 || dlci == NULL)\r\nbreak;\r\nswitch (dlci->state) {\r\ncase DLCI_CLOSING:\r\ngsm_dlci_close(dlci);\r\nbreak;\r\ncase DLCI_OPENING:\r\ngsm_dlci_open(dlci);\r\nbreak;\r\n}\r\nbreak;\r\ncase DM:\r\ncase DM|PF:\r\nif (cr)\r\ngoto invalid;\r\nif (dlci == NULL)\r\nreturn;\r\ngsm_dlci_close(dlci);\r\nbreak;\r\ncase UI:\r\ncase UI|PF:\r\ncase UIH:\r\ncase UIH|PF:\r\n#if 0\r\nif (cr)\r\ngoto invalid;\r\n#endif\r\nif (dlci == NULL || dlci->state != DLCI_OPEN) {\r\ngsm_command(gsm, address, DM|PF);\r\nreturn;\r\n}\r\ndlci->data(dlci, gsm->buf, gsm->len);\r\nbreak;\r\ndefault:\r\ngoto invalid;\r\n}\r\nreturn;\r\ninvalid:\r\ngsm->malformed++;\r\nreturn;\r\n}\r\nstatic void gsm0_receive(struct gsm_mux *gsm, unsigned char c)\r\n{\r\nunsigned int len;\r\nswitch (gsm->state) {\r\ncase GSM_SEARCH:\r\nif (c == GSM0_SOF) {\r\ngsm->state = GSM_ADDRESS;\r\ngsm->address = 0;\r\ngsm->len = 0;\r\ngsm->fcs = INIT_FCS;\r\n}\r\nbreak;\r\ncase GSM_ADDRESS:\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, c);\r\nif (gsm_read_ea(&gsm->address, c))\r\ngsm->state = GSM_CONTROL;\r\nbreak;\r\ncase GSM_CONTROL:\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, c);\r\ngsm->control = c;\r\ngsm->state = GSM_LEN0;\r\nbreak;\r\ncase GSM_LEN0:\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, c);\r\nif (gsm_read_ea(&gsm->len, c)) {\r\nif (gsm->len > gsm->mru) {\r\ngsm->bad_size++;\r\ngsm->state = GSM_SEARCH;\r\nbreak;\r\n}\r\ngsm->count = 0;\r\nif (!gsm->len)\r\ngsm->state = GSM_FCS;\r\nelse\r\ngsm->state = GSM_DATA;\r\nbreak;\r\n}\r\ngsm->state = GSM_LEN1;\r\nbreak;\r\ncase GSM_LEN1:\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, c);\r\nlen = c;\r\ngsm->len |= len << 7;\r\nif (gsm->len > gsm->mru) {\r\ngsm->bad_size++;\r\ngsm->state = GSM_SEARCH;\r\nbreak;\r\n}\r\ngsm->count = 0;\r\nif (!gsm->len)\r\ngsm->state = GSM_FCS;\r\nelse\r\ngsm->state = GSM_DATA;\r\nbreak;\r\ncase GSM_DATA:\r\ngsm->buf[gsm->count++] = c;\r\nif (gsm->count == gsm->len)\r\ngsm->state = GSM_FCS;\r\nbreak;\r\ncase GSM_FCS:\r\ngsm->received_fcs = c;\r\ngsm_queue(gsm);\r\ngsm->state = GSM_SSOF;\r\nbreak;\r\ncase GSM_SSOF:\r\nif (c == GSM0_SOF) {\r\ngsm->state = GSM_SEARCH;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void gsm1_receive(struct gsm_mux *gsm, unsigned char c)\r\n{\r\nif (c == GSM1_SOF) {\r\nif (gsm->state == GSM_DATA && gsm->count) {\r\ngsm->count--;\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, gsm->buf[gsm->count]);\r\ngsm->len = gsm->count;\r\ngsm_queue(gsm);\r\ngsm->state = GSM_START;\r\nreturn;\r\n}\r\nif (gsm->state != GSM_START) {\r\ngsm->malformed++;\r\ngsm->state = GSM_START;\r\n}\r\nreturn;\r\n}\r\nif (c == GSM1_ESCAPE) {\r\ngsm->escape = 1;\r\nreturn;\r\n}\r\nif (gsm->state == GSM_SEARCH)\r\nreturn;\r\nif (gsm->escape) {\r\nc ^= GSM1_ESCAPE_BITS;\r\ngsm->escape = 0;\r\n}\r\nswitch (gsm->state) {\r\ncase GSM_START:\r\ngsm->address = 0;\r\ngsm->state = GSM_ADDRESS;\r\ngsm->fcs = INIT_FCS;\r\ncase GSM_ADDRESS:\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, c);\r\nif (gsm_read_ea(&gsm->address, c))\r\ngsm->state = GSM_CONTROL;\r\nbreak;\r\ncase GSM_CONTROL:\r\ngsm->fcs = gsm_fcs_add(gsm->fcs, c);\r\ngsm->control = c;\r\ngsm->count = 0;\r\ngsm->state = GSM_DATA;\r\nbreak;\r\ncase GSM_DATA:\r\nif (gsm->count > gsm->mru) {\r\ngsm->state = GSM_OVERRUN;\r\ngsm->bad_size++;\r\n} else\r\ngsm->buf[gsm->count++] = c;\r\nbreak;\r\ncase GSM_OVERRUN:\r\nbreak;\r\n}\r\n}\r\nstatic void gsm_error(struct gsm_mux *gsm,\r\nunsigned char data, unsigned char flag)\r\n{\r\ngsm->state = GSM_SEARCH;\r\ngsm->io_error++;\r\n}\r\nvoid gsm_cleanup_mux(struct gsm_mux *gsm)\r\n{\r\nint i;\r\nstruct gsm_dlci *dlci = gsm->dlci[0];\r\nstruct gsm_msg *txq;\r\nstruct gsm_control *gc;\r\ngsm->dead = 1;\r\nspin_lock(&gsm_mux_lock);\r\nfor (i = 0; i < MAX_MUX; i++) {\r\nif (gsm_mux[i] == gsm) {\r\ngsm_mux[i] = NULL;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&gsm_mux_lock);\r\nWARN_ON(i == MAX_MUX);\r\nif (dlci) {\r\ngc = gsm_control_send(gsm, CMD_CLD, NULL, 0);\r\nif (gc)\r\ngsm_control_wait(gsm, gc);\r\n}\r\ndel_timer_sync(&gsm->t2_timer);\r\nif (dlci) {\r\ndlci->dead = 1;\r\ngsm_dlci_begin_close(dlci);\r\nwait_event_interruptible(gsm->event,\r\ndlci->state == DLCI_CLOSED);\r\n}\r\nfor (i = 0; i < NUM_DLCI; i++)\r\nif (gsm->dlci[i])\r\ngsm_dlci_release(gsm->dlci[i]);\r\nfor (txq = gsm->tx_head; txq != NULL; txq = gsm->tx_head) {\r\ngsm->tx_head = txq->next;\r\nkfree(txq);\r\n}\r\ngsm->tx_tail = NULL;\r\n}\r\nint gsm_activate_mux(struct gsm_mux *gsm)\r\n{\r\nstruct gsm_dlci *dlci;\r\nint i = 0;\r\ninit_timer(&gsm->t2_timer);\r\ngsm->t2_timer.function = gsm_control_retransmit;\r\ngsm->t2_timer.data = (unsigned long)gsm;\r\ninit_waitqueue_head(&gsm->event);\r\nspin_lock_init(&gsm->control_lock);\r\nspin_lock_init(&gsm->tx_lock);\r\nif (gsm->encoding == 0)\r\ngsm->receive = gsm0_receive;\r\nelse\r\ngsm->receive = gsm1_receive;\r\ngsm->error = gsm_error;\r\nspin_lock(&gsm_mux_lock);\r\nfor (i = 0; i < MAX_MUX; i++) {\r\nif (gsm_mux[i] == NULL) {\r\ngsm->num = i;\r\ngsm_mux[i] = gsm;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&gsm_mux_lock);\r\nif (i == MAX_MUX)\r\nreturn -EBUSY;\r\ndlci = gsm_dlci_alloc(gsm, 0);\r\nif (dlci == NULL)\r\nreturn -ENOMEM;\r\ngsm->dead = 0;\r\nreturn 0;\r\n}\r\nvoid gsm_free_mux(struct gsm_mux *gsm)\r\n{\r\nkfree(gsm->txframe);\r\nkfree(gsm->buf);\r\nkfree(gsm);\r\n}\r\nstatic void gsm_free_muxr(struct kref *ref)\r\n{\r\nstruct gsm_mux *gsm = container_of(ref, struct gsm_mux, ref);\r\ngsm_free_mux(gsm);\r\n}\r\nstatic inline void mux_get(struct gsm_mux *gsm)\r\n{\r\nkref_get(&gsm->ref);\r\n}\r\nstatic inline void mux_put(struct gsm_mux *gsm)\r\n{\r\nkref_put(&gsm->ref, gsm_free_muxr);\r\n}\r\nstruct gsm_mux *gsm_alloc_mux(void)\r\n{\r\nstruct gsm_mux *gsm = kzalloc(sizeof(struct gsm_mux), GFP_KERNEL);\r\nif (gsm == NULL)\r\nreturn NULL;\r\ngsm->buf = kmalloc(MAX_MRU + 1, GFP_KERNEL);\r\nif (gsm->buf == NULL) {\r\nkfree(gsm);\r\nreturn NULL;\r\n}\r\ngsm->txframe = kmalloc(2 * MAX_MRU + 2, GFP_KERNEL);\r\nif (gsm->txframe == NULL) {\r\nkfree(gsm->buf);\r\nkfree(gsm);\r\nreturn NULL;\r\n}\r\nspin_lock_init(&gsm->lock);\r\nkref_init(&gsm->ref);\r\ngsm->t1 = T1;\r\ngsm->t2 = T2;\r\ngsm->n2 = N2;\r\ngsm->ftype = UIH;\r\ngsm->adaption = 1;\r\ngsm->encoding = 1;\r\ngsm->mru = 64;\r\ngsm->mtu = 64;\r\ngsm->dead = 1;\r\nreturn gsm;\r\n}\r\nstatic int gsmld_output(struct gsm_mux *gsm, u8 *data, int len)\r\n{\r\nif (tty_write_room(gsm->tty) < len) {\r\nset_bit(TTY_DO_WRITE_WAKEUP, &gsm->tty->flags);\r\nreturn -ENOSPC;\r\n}\r\nif (debug & 4)\r\nprint_hex_dump_bytes("gsmld_output: ", DUMP_PREFIX_OFFSET,\r\ndata, len);\r\ngsm->tty->ops->write(gsm->tty, data, len);\r\nreturn len;\r\n}\r\nstatic int gsmld_attach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\r\n{\r\nint ret, i;\r\nint base = gsm->num << 6;\r\ngsm->tty = tty_kref_get(tty);\r\ngsm->output = gsmld_output;\r\nret = gsm_activate_mux(gsm);\r\nif (ret != 0)\r\ntty_kref_put(gsm->tty);\r\nelse {\r\nfor (i = 1; i < NUM_DLCI; i++)\r\ntty_register_device(gsm_tty_driver, base + i, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void gsmld_detach_gsm(struct tty_struct *tty, struct gsm_mux *gsm)\r\n{\r\nint i;\r\nint base = gsm->num << 6;\r\nWARN_ON(tty != gsm->tty);\r\nfor (i = 1; i < NUM_DLCI; i++)\r\ntty_unregister_device(gsm_tty_driver, base + i);\r\ngsm_cleanup_mux(gsm);\r\ntty_kref_put(gsm->tty);\r\ngsm->tty = NULL;\r\n}\r\nstatic void gsmld_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct gsm_mux *gsm = tty->disc_data;\r\nconst unsigned char *dp;\r\nchar *f;\r\nint i;\r\nchar buf[64];\r\nchar flags;\r\nif (debug & 4)\r\nprint_hex_dump_bytes("gsmld_receive: ", DUMP_PREFIX_OFFSET,\r\ncp, count);\r\nfor (i = count, dp = cp, f = fp; i; i--, dp++) {\r\nflags = *f++;\r\nswitch (flags) {\r\ncase TTY_NORMAL:\r\ngsm->receive(gsm, *dp);\r\nbreak;\r\ncase TTY_OVERRUN:\r\ncase TTY_BREAK:\r\ncase TTY_PARITY:\r\ncase TTY_FRAME:\r\ngsm->error(gsm, *dp, flags);\r\nbreak;\r\ndefault:\r\nWARN_ONCE("%s: unknown flag %d\n",\r\ntty_name(tty, buf), flags);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic ssize_t gsmld_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic void gsmld_flush_buffer(struct tty_struct *tty)\r\n{\r\n}\r\nstatic void gsmld_close(struct tty_struct *tty)\r\n{\r\nstruct gsm_mux *gsm = tty->disc_data;\r\ngsmld_detach_gsm(tty, gsm);\r\ngsmld_flush_buffer(tty);\r\nmux_put(gsm);\r\n}\r\nstatic int gsmld_open(struct tty_struct *tty)\r\n{\r\nstruct gsm_mux *gsm;\r\nif (tty->ops->write == NULL)\r\nreturn -EINVAL;\r\ngsm = gsm_alloc_mux();\r\nif (gsm == NULL)\r\nreturn -ENOMEM;\r\ntty->disc_data = gsm;\r\ntty->receive_room = 65536;\r\ngsm->encoding = 1;\r\nreturn gsmld_attach_gsm(tty, gsm);\r\n}\r\nstatic void gsmld_write_wakeup(struct tty_struct *tty)\r\n{\r\nstruct gsm_mux *gsm = tty->disc_data;\r\nunsigned long flags;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\ngsm_data_kick(gsm);\r\nif (gsm->tx_bytes < TX_THRESH_LO) {\r\nspin_lock_irqsave(&gsm->tx_lock, flags);\r\ngsm_dlci_data_sweep(gsm);\r\nspin_unlock_irqrestore(&gsm->tx_lock, flags);\r\n}\r\n}\r\nstatic ssize_t gsmld_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t nr)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic ssize_t gsmld_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *buf, size_t nr)\r\n{\r\nint space = tty_write_room(tty);\r\nif (space >= nr)\r\nreturn tty->ops->write(tty, buf, nr);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nreturn -ENOBUFS;\r\n}\r\nstatic unsigned int gsmld_poll(struct tty_struct *tty, struct file *file,\r\npoll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nstruct gsm_mux *gsm = tty->disc_data;\r\npoll_wait(file, &tty->read_wait, wait);\r\npoll_wait(file, &tty->write_wait, wait);\r\nif (tty_hung_up_p(file))\r\nmask |= POLLHUP;\r\nif (!tty_is_writelocked(tty) && tty_write_room(tty) > 0)\r\nmask |= POLLOUT | POLLWRNORM;\r\nif (gsm->dead)\r\nmask |= POLLHUP;\r\nreturn mask;\r\n}\r\nstatic int gsmld_config(struct tty_struct *tty, struct gsm_mux *gsm,\r\nstruct gsm_config *c)\r\n{\r\nint need_close = 0;\r\nint need_restart = 0;\r\nif ((c->adaption != 1 && c->adaption != 2) || c->k)\r\nreturn -EOPNOTSUPP;\r\nif (c->mru > MAX_MRU || c->mtu > MAX_MTU || c->mru < 8 || c->mtu < 8)\r\nreturn -EINVAL;\r\nif (c->n2 < 3)\r\nreturn -EINVAL;\r\nif (c->encapsulation > 1)\r\nreturn -EINVAL;\r\nif (c->initiator > 1)\r\nreturn -EINVAL;\r\nif (c->i == 0 || c->i > 2)\r\nreturn -EINVAL;\r\nif (c->t1 != 0 && c->t1 != gsm->t1)\r\nneed_restart = 1;\r\nif (c->t2 != 0 && c->t2 != gsm->t2)\r\nneed_restart = 1;\r\nif (c->encapsulation != gsm->encoding)\r\nneed_restart = 1;\r\nif (c->adaption != gsm->adaption)\r\nneed_restart = 1;\r\nif (c->initiator != gsm->initiator)\r\nneed_close = 1;\r\nif (c->mru != gsm->mru)\r\nneed_restart = 1;\r\nif (c->mtu != gsm->mtu)\r\nneed_restart = 1;\r\nif (need_close || need_restart) {\r\ngsm_dlci_begin_close(gsm->dlci[0]);\r\nwait_event_interruptible(gsm->event,\r\ngsm->dlci[0]->state == DLCI_CLOSED);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\nif (need_restart)\r\ngsm_cleanup_mux(gsm);\r\ngsm->initiator = c->initiator;\r\ngsm->mru = c->mru;\r\ngsm->mtu = c->mtu;\r\ngsm->encoding = c->encapsulation;\r\ngsm->adaption = c->adaption;\r\ngsm->n2 = c->n2;\r\nif (c->i == 1)\r\ngsm->ftype = UIH;\r\nelse if (c->i == 2)\r\ngsm->ftype = UI;\r\nif (c->t1)\r\ngsm->t1 = c->t1;\r\nif (c->t2)\r\ngsm->t2 = c->t2;\r\nif (need_restart)\r\ngsm_activate_mux(gsm);\r\nif (gsm->initiator && need_close)\r\ngsm_dlci_begin_open(gsm->dlci[0]);\r\nreturn 0;\r\n}\r\nstatic int gsmld_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct gsm_config c;\r\nstruct gsm_mux *gsm = tty->disc_data;\r\nswitch (cmd) {\r\ncase GSMIOC_GETCONF:\r\nmemset(&c, 0, sizeof(c));\r\nc.adaption = gsm->adaption;\r\nc.encapsulation = gsm->encoding;\r\nc.initiator = gsm->initiator;\r\nc.t1 = gsm->t1;\r\nc.t2 = gsm->t2;\r\nc.t3 = 0;\r\nc.n2 = gsm->n2;\r\nif (gsm->ftype == UIH)\r\nc.i = 1;\r\nelse\r\nc.i = 2;\r\npr_debug("Ftype %d i %d\n", gsm->ftype, c.i);\r\nc.mru = gsm->mru;\r\nc.mtu = gsm->mtu;\r\nc.k = 0;\r\nif (copy_to_user((void *)arg, &c, sizeof(c)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase GSMIOC_SETCONF:\r\nif (copy_from_user(&c, (void *)arg, sizeof(c)))\r\nreturn -EFAULT;\r\nreturn gsmld_config(tty, gsm, &c);\r\ndefault:\r\nreturn n_tty_ioctl_helper(tty, file, cmd, arg);\r\n}\r\n}\r\nstatic int gsm_mux_net_open(struct net_device *net)\r\n{\r\npr_debug("%s called\n", __func__);\r\nnetif_start_queue(net);\r\nreturn 0;\r\n}\r\nstatic int gsm_mux_net_close(struct net_device *net)\r\n{\r\nnetif_stop_queue(net);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *gsm_mux_net_get_stats(struct net_device *net)\r\n{\r\nreturn &((struct gsm_mux_net *)netdev_priv(net))->stats;\r\n}\r\nstatic void dlci_net_free(struct gsm_dlci *dlci)\r\n{\r\nif (!dlci->net) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ndlci->adaption = dlci->prev_adaption;\r\ndlci->data = dlci->prev_data;\r\nfree_netdev(dlci->net);\r\ndlci->net = NULL;\r\n}\r\nstatic void net_free(struct kref *ref)\r\n{\r\nstruct gsm_mux_net *mux_net;\r\nstruct gsm_dlci *dlci;\r\nmux_net = container_of(ref, struct gsm_mux_net, ref);\r\ndlci = mux_net->dlci;\r\nif (dlci->net) {\r\nunregister_netdev(dlci->net);\r\ndlci_net_free(dlci);\r\n}\r\n}\r\nstatic inline void muxnet_get(struct gsm_mux_net *mux_net)\r\n{\r\nkref_get(&mux_net->ref);\r\n}\r\nstatic inline void muxnet_put(struct gsm_mux_net *mux_net)\r\n{\r\nkref_put(&mux_net->ref, net_free);\r\n}\r\nstatic int gsm_mux_net_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct gsm_mux_net *mux_net = (struct gsm_mux_net *)netdev_priv(net);\r\nstruct gsm_dlci *dlci = mux_net->dlci;\r\nmuxnet_get(mux_net);\r\nskb_queue_head(&dlci->skb_list, skb);\r\nSTATS(net).tx_packets++;\r\nSTATS(net).tx_bytes += skb->len;\r\ngsm_dlci_data_kick(dlci);\r\nnet->trans_start = jiffies;\r\nmuxnet_put(mux_net);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void gsm_mux_net_tx_timeout(struct net_device *net)\r\n{\r\ndev_dbg(&net->dev, "Tx timed out.\n");\r\nSTATS(net).tx_errors++;\r\n}\r\nstatic void gsm_mux_rx_netchar(struct gsm_dlci *dlci,\r\nunsigned char *in_buf, int size)\r\n{\r\nstruct net_device *net = dlci->net;\r\nstruct sk_buff *skb;\r\nstruct gsm_mux_net *mux_net = (struct gsm_mux_net *)netdev_priv(net);\r\nmuxnet_get(mux_net);\r\nskb = dev_alloc_skb(size + NET_IP_ALIGN);\r\nif (!skb) {\r\nSTATS(net).rx_dropped++;\r\nmuxnet_put(mux_net);\r\nreturn;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nmemcpy(skb_put(skb, size), in_buf, size);\r\nskb->dev = net;\r\nskb->protocol = __constant_htons(ETH_P_IP);\r\nnetif_rx(skb);\r\nSTATS(net).rx_packets++;\r\nSTATS(net).rx_bytes += size;\r\nmuxnet_put(mux_net);\r\nreturn;\r\n}\r\nint gsm_change_mtu(struct net_device *net, int new_mtu)\r\n{\r\nstruct gsm_mux_net *mux_net = (struct gsm_mux_net *)netdev_priv(net);\r\nif ((new_mtu < 8) || (new_mtu > mux_net->dlci->gsm->mtu))\r\nreturn -EINVAL;\r\nnet->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void gsm_mux_net_init(struct net_device *net)\r\n{\r\nstatic const struct net_device_ops gsm_netdev_ops = {\r\n.ndo_open = gsm_mux_net_open,\r\n.ndo_stop = gsm_mux_net_close,\r\n.ndo_start_xmit = gsm_mux_net_start_xmit,\r\n.ndo_tx_timeout = gsm_mux_net_tx_timeout,\r\n.ndo_get_stats = gsm_mux_net_get_stats,\r\n.ndo_change_mtu = gsm_change_mtu,\r\n};\r\nnet->netdev_ops = &gsm_netdev_ops;\r\nnet->watchdog_timeo = GSM_NET_TX_TIMEOUT;\r\nnet->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\r\nnet->type = ARPHRD_NONE;\r\nnet->tx_queue_len = 10;\r\n}\r\nstatic void gsm_destroy_network(struct gsm_dlci *dlci)\r\n{\r\nstruct gsm_mux_net *mux_net;\r\npr_debug("destroy network interface");\r\nif (!dlci->net)\r\nreturn;\r\nmux_net = (struct gsm_mux_net *)netdev_priv(dlci->net);\r\nmuxnet_put(mux_net);\r\n}\r\nstatic int gsm_create_network(struct gsm_dlci *dlci, struct gsm_netconfig *nc)\r\n{\r\nchar *netname;\r\nint retval = 0;\r\nstruct net_device *net;\r\nstruct gsm_mux_net *mux_net;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dlci->adaption > 2)\r\nreturn -EBUSY;\r\nif (nc->protocol != htons(ETH_P_IP))\r\nreturn -EPROTONOSUPPORT;\r\nif (nc->adaption != 3 && nc->adaption != 4)\r\nreturn -EPROTONOSUPPORT;\r\npr_debug("create network interface");\r\nnetname = "gsm%d";\r\nif (nc->if_name[0] != '\0')\r\nnetname = nc->if_name;\r\nnet = alloc_netdev(sizeof(struct gsm_mux_net),\r\nnetname,\r\ngsm_mux_net_init);\r\nif (!net) {\r\npr_err("alloc_netdev failed");\r\nreturn -ENOMEM;\r\n}\r\nnet->mtu = dlci->gsm->mtu;\r\nmux_net = (struct gsm_mux_net *)netdev_priv(net);\r\nmux_net->dlci = dlci;\r\nkref_init(&mux_net->ref);\r\nstrncpy(nc->if_name, net->name, IFNAMSIZ);\r\ndlci->prev_adaption = dlci->adaption;\r\ndlci->prev_data = dlci->data;\r\ndlci->adaption = nc->adaption;\r\ndlci->data = gsm_mux_rx_netchar;\r\ndlci->net = net;\r\npr_debug("register netdev");\r\nretval = register_netdev(net);\r\nif (retval) {\r\npr_err("network register fail %d\n", retval);\r\ndlci_net_free(dlci);\r\nreturn retval;\r\n}\r\nreturn net->ifindex;\r\n}\r\nstatic int gsmtty_modem_update(struct gsm_dlci *dlci, u8 brk)\r\n{\r\nu8 modembits[5];\r\nstruct gsm_control *ctrl;\r\nint len = 2;\r\nif (brk)\r\nlen++;\r\nmodembits[0] = len << 1 | EA;\r\nmodembits[1] = dlci->addr << 2 | 3;\r\nmodembits[2] = gsm_encode_modem(dlci) << 1 | EA;\r\nif (brk)\r\nmodembits[3] = brk << 4 | 2 | EA;\r\nctrl = gsm_control_send(dlci->gsm, CMD_MSC, modembits, len + 1);\r\nif (ctrl == NULL)\r\nreturn -ENOMEM;\r\nreturn gsm_control_wait(dlci->gsm, ctrl);\r\n}\r\nstatic int gsm_carrier_raised(struct tty_port *port)\r\n{\r\nstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\r\nif (dlci->state != DLCI_OPEN)\r\nreturn 0;\r\nif (debug & 2)\r\nreturn 1;\r\nreturn dlci->modem_rx & TIOCM_CD;\r\n}\r\nstatic void gsm_dtr_rts(struct tty_port *port, int onoff)\r\n{\r\nstruct gsm_dlci *dlci = container_of(port, struct gsm_dlci, port);\r\nunsigned int modem_tx = dlci->modem_tx;\r\nif (onoff)\r\nmodem_tx |= TIOCM_DTR | TIOCM_RTS;\r\nelse\r\nmodem_tx &= ~(TIOCM_DTR | TIOCM_RTS);\r\nif (modem_tx != dlci->modem_tx) {\r\ndlci->modem_tx = modem_tx;\r\ngsmtty_modem_update(dlci, 0);\r\n}\r\n}\r\nstatic int gsmtty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct gsm_mux *gsm;\r\nstruct gsm_dlci *dlci;\r\nstruct tty_port *port;\r\nunsigned int line = tty->index;\r\nunsigned int mux = line >> 6;\r\nline = line & 0x3F;\r\nif (mux >= MAX_MUX)\r\nreturn -ENXIO;\r\nif (gsm_mux[mux] == NULL)\r\nreturn -EUNATCH;\r\nif (line == 0 || line > 61)\r\nreturn -ECHRNG;\r\ngsm = gsm_mux[mux];\r\nif (gsm->dead)\r\nreturn -EL2HLT;\r\ndlci = gsm->dlci[line];\r\nif (dlci == NULL)\r\ndlci = gsm_dlci_alloc(gsm, line);\r\nif (dlci == NULL)\r\nreturn -ENOMEM;\r\nport = &dlci->port;\r\nport->count++;\r\ntty->driver_data = dlci;\r\ndlci_get(dlci);\r\ndlci_get(dlci->gsm->dlci[0]);\r\nmux_get(dlci->gsm);\r\ntty_port_tty_set(port, tty);\r\ndlci->modem_rx = 0;\r\nset_bit(ASYNCB_INITIALIZED, &port->flags);\r\ngsm_dlci_begin_open(dlci);\r\nreturn tty_port_block_til_ready(port, tty, filp);\r\n}\r\nstatic void gsmtty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nstruct gsm_mux *gsm;\r\nif (dlci == NULL)\r\nreturn;\r\nmutex_lock(&dlci->mutex);\r\ngsm_destroy_network(dlci);\r\nmutex_unlock(&dlci->mutex);\r\ngsm = dlci->gsm;\r\nif (tty_port_close_start(&dlci->port, tty, filp) == 0)\r\ngoto out;\r\ngsm_dlci_begin_close(dlci);\r\ntty_port_close_end(&dlci->port, tty);\r\ntty_port_tty_set(&dlci->port, NULL);\r\nout:\r\ndlci_put(dlci);\r\ndlci_put(gsm->dlci[0]);\r\nmux_put(gsm);\r\n}\r\nstatic void gsmtty_hangup(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\ntty_port_hangup(&dlci->port);\r\ngsm_dlci_begin_close(dlci);\r\n}\r\nstatic int gsmtty_write(struct tty_struct *tty, const unsigned char *buf,\r\nint len)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nint sent = kfifo_in_locked(dlci->fifo, buf, len, &dlci->lock);\r\ngsm_dlci_data_kick(dlci);\r\nreturn sent;\r\n}\r\nstatic int gsmtty_write_room(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nreturn TX_SIZE - kfifo_len(dlci->fifo);\r\n}\r\nstatic int gsmtty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nreturn kfifo_len(dlci->fifo);\r\n}\r\nstatic void gsmtty_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nkfifo_reset(dlci->fifo);\r\n}\r\nstatic void gsmtty_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\n}\r\nstatic int gsmtty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nreturn dlci->modem_rx;\r\n}\r\nstatic int gsmtty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nunsigned int modem_tx = dlci->modem_tx;\r\nmodem_tx &= ~clear;\r\nmodem_tx |= set;\r\nif (modem_tx != dlci->modem_tx) {\r\ndlci->modem_tx = modem_tx;\r\nreturn gsmtty_modem_update(dlci, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gsmtty_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nstruct gsm_netconfig nc;\r\nint index;\r\nswitch (cmd) {\r\ncase GSMIOC_ENABLE_NET:\r\nif (copy_from_user(&nc, (void __user *)arg, sizeof(nc)))\r\nreturn -EFAULT;\r\nnc.if_name[IFNAMSIZ-1] = '\0';\r\nmutex_lock(&dlci->mutex);\r\nindex = gsm_create_network(dlci, &nc);\r\nmutex_unlock(&dlci->mutex);\r\nif (copy_to_user((void __user *)arg, &nc, sizeof(nc)))\r\nreturn -EFAULT;\r\nreturn index;\r\ncase GSMIOC_DISABLE_NET:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nmutex_lock(&dlci->mutex);\r\ngsm_destroy_network(dlci);\r\nmutex_unlock(&dlci->mutex);\r\nreturn 0;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic void gsmtty_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\ntty_termios_copy_hw(tty->termios, old);\r\n}\r\nstatic void gsmtty_throttle(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nif (tty->termios->c_cflag & CRTSCTS)\r\ndlci->modem_tx &= ~TIOCM_DTR;\r\ndlci->throttled = 1;\r\ngsmtty_modem_update(dlci, 0);\r\n}\r\nstatic void gsmtty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nif (tty->termios->c_cflag & CRTSCTS)\r\ndlci->modem_tx |= TIOCM_DTR;\r\ndlci->throttled = 0;\r\ngsmtty_modem_update(dlci, 0);\r\n}\r\nstatic int gsmtty_break_ctl(struct tty_struct *tty, int state)\r\n{\r\nstruct gsm_dlci *dlci = tty->driver_data;\r\nint encode = 0;\r\nif (state == -1)\r\nencode = 0x0F;\r\nelse if (state > 0) {\r\nencode = state / 200;\r\nif (encode > 0x0F)\r\nencode = 0x0F;\r\n}\r\nreturn gsmtty_modem_update(dlci, encode);\r\n}\r\nstatic int __init gsm_init(void)\r\n{\r\nint status = tty_register_ldisc(N_GSM0710, &tty_ldisc_packet);\r\nif (status != 0) {\r\npr_err("n_gsm: can't register line discipline (err = %d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\ngsm_tty_driver = alloc_tty_driver(256);\r\nif (!gsm_tty_driver) {\r\ntty_unregister_ldisc(N_GSM0710);\r\npr_err("gsm_init: tty allocation failed.\n");\r\nreturn -EINVAL;\r\n}\r\ngsm_tty_driver->driver_name = "gsmtty";\r\ngsm_tty_driver->name = "gsmtty";\r\ngsm_tty_driver->major = 0;\r\ngsm_tty_driver->minor_start = 0;\r\ngsm_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\ngsm_tty_driver->subtype = SERIAL_TYPE_NORMAL;\r\ngsm_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV\r\n| TTY_DRIVER_HARDWARE_BREAK;\r\ngsm_tty_driver->init_termios = tty_std_termios;\r\ngsm_tty_driver->init_termios.c_lflag &= ~ECHO;\r\ntty_set_operations(gsm_tty_driver, &gsmtty_ops);\r\nspin_lock_init(&gsm_mux_lock);\r\nif (tty_register_driver(gsm_tty_driver)) {\r\nput_tty_driver(gsm_tty_driver);\r\ntty_unregister_ldisc(N_GSM0710);\r\npr_err("gsm_init: tty registration failed.\n");\r\nreturn -EBUSY;\r\n}\r\npr_debug("gsm_init: loaded as %d,%d.\n",\r\ngsm_tty_driver->major, gsm_tty_driver->minor_start);\r\nreturn 0;\r\n}\r\nstatic void __exit gsm_exit(void)\r\n{\r\nint status = tty_unregister_ldisc(N_GSM0710);\r\nif (status != 0)\r\npr_err("n_gsm: can't unregister line discipline (err = %d)\n",\r\nstatus);\r\ntty_unregister_driver(gsm_tty_driver);\r\nput_tty_driver(gsm_tty_driver);\r\n}
