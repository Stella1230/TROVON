static const struct rj54n1_datafmt *rj54n1_find_datafmt(\r\nenum v4l2_mbus_pixelcode code, const struct rj54n1_datafmt *fmt,\r\nint n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nif (fmt[i].code == code)\r\nreturn fmt + i;\r\nreturn NULL;\r\n}\r\nstatic struct rj54n1 *to_rj54n1(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct rj54n1, subdev);\r\n}\r\nstatic int reg_read(struct i2c_client *client, const u16 reg)\r\n{\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nint ret;\r\nif (rj54n1->bank != reg >> 8) {\r\ndev_dbg(&client->dev, "[0x%x] = 0x%x\n", 0xff, reg >> 8);\r\nret = i2c_smbus_write_byte_data(client, 0xff, reg >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\nrj54n1->bank = reg >> 8;\r\n}\r\nreturn i2c_smbus_read_byte_data(client, reg & 0xff);\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u16 reg,\r\nconst u8 data)\r\n{\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nint ret;\r\nif (rj54n1->bank != reg >> 8) {\r\ndev_dbg(&client->dev, "[0x%x] = 0x%x\n", 0xff, reg >> 8);\r\nret = i2c_smbus_write_byte_data(client, 0xff, reg >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\nrj54n1->bank = reg >> 8;\r\n}\r\ndev_dbg(&client->dev, "[0x%x] = 0x%x\n", reg & 0xff, data);\r\nreturn i2c_smbus_write_byte_data(client, reg & 0xff, data);\r\n}\r\nstatic int reg_set(struct i2c_client *client, const u16 reg,\r\nconst u8 data, const u8 mask)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, (ret & ~mask) | (data & mask));\r\n}\r\nstatic int reg_write_multiple(struct i2c_client *client,\r\nconst struct rj54n1_reg_val *rv, const int n)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < n; i++) {\r\nret = reg_write(client, rv->reg, rv->val);\r\nif (ret < 0)\r\nreturn ret;\r\nrv++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rj54n1_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index >= ARRAY_SIZE(rj54n1_colour_fmts))\r\nreturn -EINVAL;\r\n*code = rj54n1_colour_fmts[index].code;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn reg_set(client, RJ54N1_STILL_CONTROL, (!enable) << 7, 0x80);\r\n}\r\nstatic int rj54n1_set_rect(struct i2c_client *client,\r\nu16 reg_x, u16 reg_y, u16 reg_xy,\r\nu32 width, u32 height)\r\n{\r\nint ret;\r\nret = reg_write(client, reg_xy,\r\n((width >> 4) & 0x70) |\r\n((height >> 8) & 7));\r\nif (!ret)\r\nret = reg_write(client, reg_x, width & 0xff);\r\nif (!ret)\r\nret = reg_write(client, reg_y, height & 0xff);\r\nreturn ret;\r\n}\r\nstatic int rj54n1_commit(struct i2c_client *client)\r\n{\r\nint ret = reg_write(client, RJ54N1_INIT_START, 1);\r\nmsleep(10);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_INIT_START, 0);\r\nreturn ret;\r\n}\r\nstatic int rj54n1_s_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nstruct v4l2_rect *rect = &a->c;\r\nint dummy = 0, output_w, output_h,\r\ninput_w = rect->width, input_h = rect->height;\r\nint ret;\r\nsoc_camera_limit_side(&dummy, &input_w,\r\nRJ54N1_COLUMN_SKIP, 8, RJ54N1_MAX_WIDTH);\r\nsoc_camera_limit_side(&dummy, &input_h,\r\nRJ54N1_ROW_SKIP, 8, RJ54N1_MAX_HEIGHT);\r\noutput_w = (input_w * 1024 + rj54n1->resize / 2) / rj54n1->resize;\r\noutput_h = (input_h * 1024 + rj54n1->resize / 2) / rj54n1->resize;\r\ndev_dbg(&client->dev, "Scaling for %dx%d : %u = %dx%d\n",\r\ninput_w, input_h, rj54n1->resize, output_w, output_h);\r\nret = rj54n1_sensor_scale(sd, &input_w, &input_h, &output_w, &output_h);\r\nif (ret < 0)\r\nreturn ret;\r\nrj54n1->width = output_w;\r\nrj54n1->height = output_h;\r\nrj54n1->resize = ret;\r\nrj54n1->rect.width = input_w;\r\nrj54n1->rect.height = input_h;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\na->c = rj54n1->rect;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = RJ54N1_COLUMN_SKIP;\r\na->bounds.top = RJ54N1_ROW_SKIP;\r\na->bounds.width = RJ54N1_MAX_WIDTH;\r\na->bounds.height = RJ54N1_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nmf->code = rj54n1->fmt->code;\r\nmf->colorspace = rj54n1->fmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->width = rj54n1->width;\r\nmf->height = rj54n1->height;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_sensor_scale(struct v4l2_subdev *sd, s32 *in_w, s32 *in_h,\r\ns32 *out_w, s32 *out_h)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nunsigned int skip, resize, input_w = *in_w, input_h = *in_h,\r\noutput_w = *out_w, output_h = *out_h;\r\nu16 inc_sel, wb_bit8, wb_left, wb_right, wb_top, wb_bottom;\r\nunsigned int peak, peak_50, peak_60;\r\nint ret;\r\nif (output_w > max(512U, input_w / 2)) {\r\nif (2 * output_w > RJ54N1_MAX_WIDTH) {\r\ninput_w = RJ54N1_MAX_WIDTH;\r\noutput_w = RJ54N1_MAX_WIDTH / 2;\r\n} else {\r\ninput_w = output_w * 2;\r\n}\r\ndev_dbg(&client->dev, "Adjusted output width: in %u, out %u\n",\r\ninput_w, output_w);\r\n}\r\nif (output_h > max(384U, input_h / 2)) {\r\nif (2 * output_h > RJ54N1_MAX_HEIGHT) {\r\ninput_h = RJ54N1_MAX_HEIGHT;\r\noutput_h = RJ54N1_MAX_HEIGHT / 2;\r\n} else {\r\ninput_h = output_h * 2;\r\n}\r\ndev_dbg(&client->dev, "Adjusted output height: in %u, out %u\n",\r\ninput_h, output_h);\r\n}\r\nret = rj54n1_set_rect(client, RJ54N1_X_OUTPUT_SIZE_S_L,\r\nRJ54N1_Y_OUTPUT_SIZE_S_L,\r\nRJ54N1_XY_OUTPUT_SIZE_S_H, output_w, output_h);\r\nif (!ret)\r\nret = rj54n1_set_rect(client, RJ54N1_X_OUTPUT_SIZE_P_L,\r\nRJ54N1_Y_OUTPUT_SIZE_P_L,\r\nRJ54N1_XY_OUTPUT_SIZE_P_H, output_w, output_h);\r\nif (ret < 0)\r\nreturn ret;\r\nif (output_w > input_w && output_h > input_h) {\r\ninput_w = output_w;\r\ninput_h = output_h;\r\nresize = 1024;\r\n} else {\r\nunsigned int resize_x, resize_y;\r\nresize_x = (input_w * 1024 + output_w / 2) / output_w;\r\nresize_y = (input_h * 1024 + output_h / 2) / output_h;\r\nif (resize_x > resize_y &&\r\n(output_h * resize_x + 512) / 1024 > RJ54N1_MAX_HEIGHT)\r\nresize = (RJ54N1_MAX_HEIGHT * 1024 + output_h / 2) /\r\noutput_h;\r\nelse if (resize_y > resize_x &&\r\n(output_w * resize_y + 512) / 1024 > RJ54N1_MAX_WIDTH)\r\nresize = (RJ54N1_MAX_WIDTH * 1024 + output_w / 2) /\r\noutput_w;\r\nelse\r\nresize = max(resize_x, resize_y);\r\nswitch (resize) {\r\ncase 2040 ... 2047:\r\nresize = 2039;\r\nbreak;\r\ncase 4080 ... 4095:\r\nresize = 4079;\r\nbreak;\r\ncase 8160 ... 8191:\r\nresize = 8159;\r\nbreak;\r\ncase 16320 ... 16384:\r\nresize = 16319;\r\n}\r\n}\r\nret = reg_write(client, RJ54N1_RESIZE_HOLD_L, resize & 0xff);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESIZE_HOLD_H, resize >> 8);\r\nif (ret < 0)\r\nreturn ret;\r\nskip = min(resize / 1024, 15U);\r\ninc_sel = 1 << skip;\r\nif (inc_sel <= 2)\r\ninc_sel = 0xc;\r\nelse if (resize & 1023 && skip < 15)\r\ninc_sel |= 1 << (skip + 1);\r\nret = reg_write(client, RJ54N1_INC_USE_SEL_L, inc_sel & 0xfc);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_INC_USE_SEL_H, inc_sel >> 8);\r\nif (!rj54n1->auto_wb) {\r\nwb_left = output_w / 16;\r\nwb_right = (3 * output_w / 4 - 3) / 4;\r\nwb_top = output_h / 16;\r\nwb_bottom = (3 * output_h / 4 - 3) / 4;\r\nwb_bit8 = ((wb_left >> 2) & 0x40) | ((wb_top >> 4) & 0x10) |\r\n((wb_right >> 6) & 4) | ((wb_bottom >> 8) & 1);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_BIT8_WB, wb_bit8);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_HCAPS_WB, wb_left);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_VCAPS_WB, wb_top);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_HCAPE_WB, wb_right);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_VCAPE_WB, wb_bottom);\r\n}\r\npeak = 12 * RJ54N1_MAX_WIDTH * (1 << 14) * resize / rj54n1->tgclk_mhz /\r\n10000;\r\npeak_50 = peak / 6;\r\npeak_60 = peak / 5;\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PEAK_H,\r\n((peak_50 >> 4) & 0xf0) | (peak_60 >> 8));\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PEAK_50, peak_50);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PEAK_60, peak_60);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PEAK_DIFF, peak / 150);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESIZE_CONTROL,\r\nRESIZE_HOLD_SEL | RESIZE_GO | 1);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(230);\r\nret = reg_write(client, RJ54N1_RESIZE_CONTROL, RESIZE_HOLD_SEL | 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*in_w = (output_w * resize + 512) / 1024;\r\n*in_h = (output_h * resize + 512) / 1024;\r\n*out_w = output_w;\r\n*out_h = output_h;\r\ndev_dbg(&client->dev, "Scaled for %dx%d : %u = %ux%u, skip %u\n",\r\n*in_w, *in_h, resize, output_w, output_h, skip);\r\nreturn resize;\r\n}\r\nstatic int rj54n1_set_clock(struct i2c_client *client)\r\n{\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nint ret;\r\nret = reg_write(client, RJ54N1_RESET_STANDBY, E_EXCLK | SOFT_STDBY);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESET_STANDBY, E_EXCLK);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PLL_L, PLL_L);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PLL_N, PLL_N);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RATIO_TG,\r\nrj54n1->clk_div.ratio_tg);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RATIO_T,\r\nrj54n1->clk_div.ratio_t);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RATIO_R,\r\nrj54n1->clk_div.ratio_r);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RAMP_TGCLK_EN, 3);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_OCLK_DSP, 0);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RATIO_OP,\r\nrj54n1->clk_div.ratio_op);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RATIO_O,\r\nrj54n1->clk_div.ratio_o);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_OCLK_SEL_EN, 1);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_TG_BYPASS, 2);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESET_STANDBY,\r\nE_EXCLK | SEN_RSTX);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_PLL_EN, 1);\r\nmsleep(10);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_CLK_RST, 1);\r\nif (!ret)\r\nret = reg_read(client, RJ54N1_CLK_RST);\r\nif (ret != 1) {\r\ndev_err(&client->dev,\r\n"Resetting RJ54N1CB0C clock failed: %d!\n", ret);\r\nreturn -EIO;\r\n}\r\nret = reg_set(client, RJ54N1_OCLK_DSP, 1, 1);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_OCLK_SEL_EN, 1);\r\nreturn ret;\r\n}\r\nstatic int rj54n1_reg_init(struct i2c_client *client)\r\n{\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nint ret = rj54n1_set_clock(client);\r\nif (!ret)\r\nret = reg_write_multiple(client, bank_7, ARRAY_SIZE(bank_7));\r\nif (!ret)\r\nret = reg_write_multiple(client, bank_10, ARRAY_SIZE(bank_10));\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_SCALE_1_2_LEV, 3 | (7 << 4));\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_SCALE_4_LEV, 0xf);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESIZE_CONTROL,\r\nRESIZE_HOLD_SEL | 1);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_Y_GAIN, 0x84);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_MIRROR_STILL_MODE, 0x27);\r\nif (!ret)\r\nret = reg_write_multiple(client, bank_4, ARRAY_SIZE(bank_4));\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_EXPOSURE_CONTROL, 0x80);\r\nif (!ret)\r\nret = reg_read(client, RJ54N1_WB_SEL_WEIGHT_I);\r\nif (ret >= 0) {\r\nrj54n1->auto_wb = ret & 0x80;\r\nret = reg_write_multiple(client, bank_5, ARRAY_SIZE(bank_5));\r\n}\r\nif (!ret)\r\nret = reg_write_multiple(client, bank_8, ARRAY_SIZE(bank_8));\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESET_STANDBY,\r\nE_EXCLK | DSP_RSTX | SEN_RSTX);\r\nif (!ret)\r\nret = rj54n1_commit(client);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RESET_STANDBY,\r\nE_EXCLK | DSP_RSTX | TG_RSTX | SEN_RSTX);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_FWFLG, 2);\r\nmsleep(700);\r\nreturn ret;\r\n}\r\nstatic int rj54n1_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nconst struct rj54n1_datafmt *fmt;\r\nint align = mf->code == V4L2_MBUS_FMT_SBGGR10_1X10 ||\r\nmf->code == V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE ||\r\nmf->code == V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE ||\r\nmf->code == V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE ||\r\nmf->code == V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE;\r\ndev_dbg(&client->dev, "%s: code = %d, width = %u, height = %u\n",\r\n__func__, mf->code, mf->width, mf->height);\r\nfmt = rj54n1_find_datafmt(mf->code, rj54n1_colour_fmts,\r\nARRAY_SIZE(rj54n1_colour_fmts));\r\nif (!fmt) {\r\nfmt = rj54n1->fmt;\r\nmf->code = fmt->code;\r\n}\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->colorspace = fmt->colorspace;\r\nv4l_bound_align_image(&mf->width, 112, RJ54N1_MAX_WIDTH, align,\r\n&mf->height, 84, RJ54N1_MAX_HEIGHT, align, 0);\r\nreturn 0;\r\n}\r\nstatic int rj54n1_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nconst struct rj54n1_datafmt *fmt;\r\nint output_w, output_h, max_w, max_h,\r\ninput_w = rj54n1->rect.width, input_h = rj54n1->rect.height;\r\nint ret;\r\nrj54n1_try_fmt(sd, mf);\r\nret = reg_read(client, RJ54N1_RESET_STANDBY);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & E_EXCLK)) {\r\nret = rj54n1_reg_init(client);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ndev_dbg(&client->dev, "%s: code = %d, width = %u, height = %u\n",\r\n__func__, mf->code, mf->width, mf->height);\r\nswitch (mf->code) {\r\ncase V4L2_MBUS_FMT_YUYV8_2X8:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 0);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\r\nbreak;\r\ncase V4L2_MBUS_FMT_YVYU8_2X8:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 0);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB565_2X8_LE:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 0x11);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\r\nbreak;\r\ncase V4L2_MBUS_FMT_RGB565_2X8_BE:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 0x11);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\r\nbreak;\r\ncase V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 4);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RA_SEL_UL, 0);\r\nbreak;\r\ncase V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 4);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 8, 8);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RA_SEL_UL, 8);\r\nbreak;\r\ncase V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 4);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RA_SEL_UL, 0);\r\nbreak;\r\ncase V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 4);\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_BYTE_SWAP, 0, 8);\r\nif (!ret)\r\nret = reg_write(client, RJ54N1_RA_SEL_UL, 8);\r\nbreak;\r\ncase V4L2_MBUS_FMT_SBGGR10_1X10:\r\nret = reg_write(client, RJ54N1_OUT_SEL, 5);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\nret = reg_set(client, RJ54N1_OCLK_SEL_EN,\r\n(mf->code == V4L2_MBUS_FMT_SBGGR10_1X10) << 1, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nmax_w = mf->width * (16 * 1024 - 1) / 1024;\r\nif (input_w > max_w)\r\ninput_w = max_w;\r\nmax_h = mf->height * (16 * 1024 - 1) / 1024;\r\nif (input_h > max_h)\r\ninput_h = max_h;\r\noutput_w = mf->width;\r\noutput_h = mf->height;\r\nret = rj54n1_sensor_scale(sd, &input_w, &input_h, &output_w, &output_h);\r\nif (ret < 0)\r\nreturn ret;\r\nfmt = rj54n1_find_datafmt(mf->code, rj54n1_colour_fmts,\r\nARRAY_SIZE(rj54n1_colour_fmts));\r\nrj54n1->fmt = fmt;\r\nrj54n1->resize = ret;\r\nrj54n1->rect.width = input_w;\r\nrj54n1->rect.height = input_h;\r\nrj54n1->width = output_w;\r\nrj54n1->height = output_h;\r\nmf->width = output_w;\r\nmf->height = output_h;\r\nmf->field = V4L2_FIELD_NONE;\r\nmf->colorspace = fmt->colorspace;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)\r\nreturn -EINVAL;\r\nif (id->match.addr != client->addr)\r\nreturn -ENODEV;\r\nid->ident = V4L2_IDENT_RJ54N1CB0C;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR ||\r\nreg->reg < 0x400 || reg->reg > 0x1fff)\r\nreturn -EINVAL;\r\nif (reg->match.addr != client->addr)\r\nreturn -ENODEV;\r\nreg->size = 1;\r\nreg->val = reg_read(client, reg->reg);\r\nif (reg->val > 0xff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR ||\r\nreg->reg < 0x400 || reg->reg > 0x1fff)\r\nreturn -EINVAL;\r\nif (reg->match.addr != client->addr)\r\nreturn -ENODEV;\r\nif (reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int rj54n1_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct rj54n1 *rj54n1 = container_of(ctrl->handler, struct rj54n1, hdl);\r\nstruct v4l2_subdev *sd = &rj54n1->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 0, 1);\r\nelse\r\ndata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 1, 1);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 0, 2);\r\nelse\r\ndata = reg_set(client, RJ54N1_MIRROR_STILL_MODE, 2, 2);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_GAIN:\r\nif (reg_write(client, RJ54N1_Y_GAIN, ctrl->val * 2) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nif (reg_set(client, RJ54N1_WB_SEL_WEIGHT_I, ctrl->val << 7,\r\n0x80) < 0)\r\nreturn -EIO;\r\nrj54n1->auto_wb = ctrl->val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int rj54n1_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags =\r\nV4L2_MBUS_PCLK_SAMPLE_RISING | V4L2_MBUS_PCLK_SAMPLE_FALLING |\r\nV4L2_MBUS_MASTER | V4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int rj54n1_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nif (soc_camera_apply_board_flags(icl, cfg) &\r\nV4L2_MBUS_PCLK_SAMPLE_RISING)\r\nreturn reg_write(client, RJ54N1_OUT_SIGPO, 1 << 4);\r\nelse\r\nreturn reg_write(client, RJ54N1_OUT_SIGPO, 0);\r\n}\r\nstatic int rj54n1_video_probe(struct i2c_client *client,\r\nstruct rj54n1_pdata *priv)\r\n{\r\nint data1, data2;\r\nint ret;\r\ndata1 = reg_read(client, RJ54N1_DEV_CODE);\r\ndata2 = reg_read(client, RJ54N1_DEV_CODE2);\r\nif (data1 != 0x51 || data2 != 0x10) {\r\nret = -ENODEV;\r\ndev_info(&client->dev, "No RJ54N1CB0C found, read 0x%x:0x%x\n",\r\ndata1, data2);\r\ngoto ei2c;\r\n}\r\nret = reg_write(client, RJ54N1_IOC, priv->ioctl_high << 7);\r\nif (ret < 0)\r\ngoto ei2c;\r\ndev_info(&client->dev, "Detected a RJ54N1CB0C chip ID 0x%x:0x%x\n",\r\ndata1, data2);\r\nei2c:\r\nreturn ret;\r\n}\r\nstatic int rj54n1_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct rj54n1 *rj54n1;\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct rj54n1_pdata *rj54n1_priv;\r\nint ret;\r\nif (!icl || !icl->priv) {\r\ndev_err(&client->dev, "RJ54N1CB0C: missing platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nrj54n1_priv = icl->priv;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");\r\nreturn -EIO;\r\n}\r\nrj54n1 = kzalloc(sizeof(struct rj54n1), GFP_KERNEL);\r\nif (!rj54n1)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&rj54n1->subdev, client, &rj54n1_subdev_ops);\r\nv4l2_ctrl_handler_init(&rj54n1->hdl, 4);\r\nv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 66);\r\nv4l2_ctrl_new_std(&rj54n1->hdl, &rj54n1_ctrl_ops,\r\nV4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);\r\nrj54n1->subdev.ctrl_handler = &rj54n1->hdl;\r\nif (rj54n1->hdl.error) {\r\nint err = rj54n1->hdl.error;\r\nkfree(rj54n1);\r\nreturn err;\r\n}\r\nrj54n1->clk_div = clk_div;\r\nrj54n1->rect.left = RJ54N1_COLUMN_SKIP;\r\nrj54n1->rect.top = RJ54N1_ROW_SKIP;\r\nrj54n1->rect.width = RJ54N1_MAX_WIDTH;\r\nrj54n1->rect.height = RJ54N1_MAX_HEIGHT;\r\nrj54n1->width = RJ54N1_MAX_WIDTH;\r\nrj54n1->height = RJ54N1_MAX_HEIGHT;\r\nrj54n1->fmt = &rj54n1_colour_fmts[0];\r\nrj54n1->resize = 1024;\r\nrj54n1->tgclk_mhz = (rj54n1_priv->mclk_freq / PLL_L * PLL_N) /\r\n(clk_div.ratio_tg + 1) / (clk_div.ratio_t + 1);\r\nret = rj54n1_video_probe(client, rj54n1_priv);\r\nif (ret < 0) {\r\nv4l2_ctrl_handler_free(&rj54n1->hdl);\r\nkfree(rj54n1);\r\nreturn ret;\r\n}\r\nreturn v4l2_ctrl_handler_setup(&rj54n1->hdl);\r\n}\r\nstatic int rj54n1_remove(struct i2c_client *client)\r\n{\r\nstruct rj54n1 *rj54n1 = to_rj54n1(client);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nv4l2_device_unregister_subdev(&rj54n1->subdev);\r\nif (icl->free_bus)\r\nicl->free_bus(icl);\r\nv4l2_ctrl_handler_free(&rj54n1->hdl);\r\nkfree(rj54n1);\r\nreturn 0;\r\n}
