static void hil_mlc_clear_di_map(hil_mlc *mlc, int val)\r\n{\r\nint j;\r\nfor (j = val; j < 7 ; j++)\r\nmlc->di_map[j] = -1;\r\n}\r\nstatic void hil_mlc_clear_di_scratch(hil_mlc *mlc)\r\n{\r\nmemset(&mlc->di_scratch, 0, sizeof(mlc->di_scratch));\r\n}\r\nstatic void hil_mlc_copy_di_scratch(hil_mlc *mlc, int idx)\r\n{\r\nmemcpy(&mlc->di[idx], &mlc->di_scratch, sizeof(mlc->di_scratch));\r\n}\r\nstatic int hil_mlc_match_di_scratch(hil_mlc *mlc)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {\r\nint j, found = 0;\r\nfor (j = 0; j < 7 ; j++)\r\nif (mlc->di_map[j] == idx)\r\nfound++;\r\nif (found)\r\ncontinue;\r\nif (!memcmp(mlc->di + idx, &mlc->di_scratch,\r\nsizeof(mlc->di_scratch)))\r\nbreak;\r\n}\r\nreturn idx >= HIL_MLC_DEVMEM ? -1 : idx;\r\n}\r\nstatic int hil_mlc_find_free_di(hil_mlc *mlc)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {\r\nint j, found = 0;\r\nfor (j = 0; j < 7 ; j++)\r\nif (mlc->di_map[j] == idx)\r\nfound++;\r\nif (!found)\r\nbreak;\r\n}\r\nreturn idx;\r\n}\r\nstatic inline void hil_mlc_clean_serio_map(hil_mlc *mlc)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < HIL_MLC_DEVMEM; idx++) {\r\nint j, found = 0;\r\nfor (j = 0; j < 7 ; j++)\r\nif (mlc->di_map[j] == idx)\r\nfound++;\r\nif (!found)\r\nmlc->serio_map[idx].di_revmap = -1;\r\n}\r\n}\r\nstatic void hil_mlc_send_polls(hil_mlc *mlc)\r\n{\r\nint did, i, cnt;\r\nstruct serio *serio;\r\nstruct serio_driver *drv;\r\ni = cnt = 0;\r\ndid = (mlc->ipacket[0] & HIL_PKT_ADDR_MASK) >> 8;\r\nserio = did ? mlc->serio[mlc->di_map[did - 1]] : NULL;\r\ndrv = (serio != NULL) ? serio->drv : NULL;\r\nwhile (mlc->icount < 15 - i) {\r\nhil_packet p;\r\np = mlc->ipacket[i];\r\nif (did != (p & HIL_PKT_ADDR_MASK) >> 8) {\r\nif (drv && drv->interrupt) {\r\ndrv->interrupt(serio, 0, 0);\r\ndrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\r\ndrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\r\ndrv->interrupt(serio, HIL_CMD_POL + cnt, 0);\r\n}\r\ndid = (p & HIL_PKT_ADDR_MASK) >> 8;\r\nserio = did ? mlc->serio[mlc->di_map[did-1]] : NULL;\r\ndrv = (serio != NULL) ? serio->drv : NULL;\r\ncnt = 0;\r\n}\r\ncnt++;\r\ni++;\r\nif (drv && drv->interrupt) {\r\ndrv->interrupt(serio, (p >> 24), 0);\r\ndrv->interrupt(serio, (p >> 16) & 0xff, 0);\r\ndrv->interrupt(serio, (p >> 8) & ~HIL_PKT_ADDR_MASK, 0);\r\ndrv->interrupt(serio, p & 0xff, 0);\r\n}\r\n}\r\n}\r\nstatic int hilse_match(hil_mlc *mlc, int unused)\r\n{\r\nint rc;\r\nrc = hil_mlc_match_di_scratch(mlc);\r\nif (rc == -1) {\r\nrc = hil_mlc_find_free_di(mlc);\r\nif (rc == -1)\r\ngoto err;\r\n#ifdef HIL_MLC_DEBUG\r\nprintk(KERN_DEBUG PREFIX "new in slot %i\n", rc);\r\n#endif\r\nhil_mlc_copy_di_scratch(mlc, rc);\r\nmlc->di_map[mlc->ddi] = rc;\r\nmlc->serio_map[rc].di_revmap = mlc->ddi;\r\nhil_mlc_clean_serio_map(mlc);\r\nserio_rescan(mlc->serio[rc]);\r\nreturn -1;\r\n}\r\nmlc->di_map[mlc->ddi] = rc;\r\n#ifdef HIL_MLC_DEBUG\r\nprintk(KERN_DEBUG PREFIX "same in slot %i\n", rc);\r\n#endif\r\nmlc->serio_map[rc].di_revmap = mlc->ddi;\r\nhil_mlc_clean_serio_map(mlc);\r\nreturn 0;\r\nerr:\r\nprintk(KERN_ERR PREFIX "Residual device slots exhausted, close some serios!\n");\r\nreturn 1;\r\n}\r\nstatic int hilse_init_lcv(hil_mlc *mlc, int unused)\r\n{\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nif (mlc->lcv && (tv.tv_sec - mlc->lcv_tv.tv_sec) < 5)\r\nreturn -1;\r\nmlc->lcv_tv = tv;\r\nmlc->lcv = 0;\r\nreturn 0;\r\n}\r\nstatic int hilse_inc_lcv(hil_mlc *mlc, int lim)\r\n{\r\nreturn mlc->lcv++ >= lim ? -1 : 0;\r\n}\r\nstatic int hilse_set_ddi(hil_mlc *mlc, int val)\r\n{\r\nmlc->ddi = val;\r\nhil_mlc_clear_di_map(mlc, val + 1);\r\nreturn 0;\r\n}\r\nstatic int hilse_dec_ddi(hil_mlc *mlc, int unused)\r\n{\r\nmlc->ddi--;\r\nif (mlc->ddi <= -1) {\r\nmlc->ddi = -1;\r\nhil_mlc_clear_di_map(mlc, 0);\r\nreturn -1;\r\n}\r\nhil_mlc_clear_di_map(mlc, mlc->ddi + 1);\r\nreturn 0;\r\n}\r\nstatic int hilse_inc_ddi(hil_mlc *mlc, int unused)\r\n{\r\nBUG_ON(mlc->ddi >= 6);\r\nmlc->ddi++;\r\nreturn 0;\r\n}\r\nstatic int hilse_take_idd(hil_mlc *mlc, int unused)\r\n{\r\nint i;\r\nif (mlc->ipacket[0] & HIL_PKT_CMD)\r\ngoto bail;\r\nfor (i = 1; i < 16; i++) {\r\nif (((mlc->ipacket[i] & HIL_PKT_ADDR_MASK) ==\r\n(mlc->ipacket[0] & HIL_PKT_ADDR_MASK)) &&\r\n(mlc->ipacket[i] & HIL_PKT_CMD) &&\r\n((mlc->ipacket[i] & HIL_PKT_DATA_MASK) == HIL_CMD_IDD))\r\nbreak;\r\n}\r\nif (i > 15)\r\ngoto bail;\r\nwhile (++i < 16)\r\nif (mlc->ipacket[i])\r\nbreak;\r\nif (i < 16)\r\ngoto bail;\r\nfor (i = 0; i < 16; i++)\r\nmlc->di_scratch.idd[i] =\r\nmlc->ipacket[i] & HIL_PKT_DATA_MASK;\r\nif (mlc->di_scratch.idd[1] & HIL_IDD_HEADER_RSC)\r\nreturn HILSEN_NEXT;\r\nif (mlc->di_scratch.idd[1] & HIL_IDD_HEADER_EXD)\r\nreturn HILSEN_DOWN | 4;\r\nreturn 0;\r\nbail:\r\nmlc->ddi--;\r\nreturn -1;\r\n}\r\nstatic int hilse_take_rsc(hil_mlc *mlc, int unused)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nmlc->di_scratch.rsc[i] =\r\nmlc->ipacket[i] & HIL_PKT_DATA_MASK;\r\nif (mlc->di_scratch.idd[1] & HIL_IDD_HEADER_EXD)\r\nreturn HILSEN_NEXT;\r\nreturn 0;\r\n}\r\nstatic int hilse_take_exd(hil_mlc *mlc, int unused)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nmlc->di_scratch.exd[i] =\r\nmlc->ipacket[i] & HIL_PKT_DATA_MASK;\r\nif (mlc->di_scratch.exd[0] & HIL_EXD_HEADER_RNM)\r\nreturn HILSEN_NEXT;\r\nreturn 0;\r\n}\r\nstatic int hilse_take_rnm(hil_mlc *mlc, int unused)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\nmlc->di_scratch.rnm[i] =\r\nmlc->ipacket[i] & HIL_PKT_DATA_MASK;\r\nprintk(KERN_INFO PREFIX "Device name gotten: %16s\n",\r\nmlc->di_scratch.rnm);\r\nreturn 0;\r\n}\r\nstatic int hilse_operate(hil_mlc *mlc, int repoll)\r\n{\r\nif (mlc->opercnt == 0)\r\nhil_mlcs_probe = 0;\r\nmlc->opercnt = 1;\r\nhil_mlc_send_polls(mlc);\r\nif (!hil_mlcs_probe)\r\nreturn 0;\r\nhil_mlcs_probe = 0;\r\nmlc->opercnt = 0;\r\nreturn 1;\r\n}\r\nstatic inline void hilse_setup_input(hil_mlc *mlc, const struct hilse_node *node)\r\n{\r\nswitch (node->act) {\r\ncase HILSE_EXPECT_DISC:\r\nmlc->imatch = node->object.packet;\r\nmlc->imatch |= ((mlc->ddi + 2) << HIL_PKT_ADDR_SHIFT);\r\nbreak;\r\ncase HILSE_EXPECT_LAST:\r\nmlc->imatch = node->object.packet;\r\nmlc->imatch |= ((mlc->ddi + 1) << HIL_PKT_ADDR_SHIFT);\r\nbreak;\r\ncase HILSE_EXPECT:\r\nmlc->imatch = node->object.packet;\r\nbreak;\r\ncase HILSE_IN:\r\nmlc->imatch = 0;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmlc->istarted = 1;\r\nmlc->intimeout = node->arg;\r\ndo_gettimeofday(&(mlc->instart));\r\nmlc->icount = 15;\r\nmemset(mlc->ipacket, 0, 16 * sizeof(hil_packet));\r\nBUG_ON(down_trylock(&mlc->isem));\r\n}\r\nstatic int hilse_donode(hil_mlc *mlc)\r\n{\r\nconst struct hilse_node *node;\r\nint nextidx = 0;\r\nint sched_long = 0;\r\nunsigned long flags;\r\n#ifdef HIL_MLC_DEBUG\r\nif (mlc->seidx && mlc->seidx != seidx &&\r\nmlc->seidx != 41 && mlc->seidx != 42 && mlc->seidx != 43) {\r\nprintk(KERN_DEBUG PREFIX "z%i \n {%i}", doze, mlc->seidx);\r\ndoze = 0;\r\n}\r\nseidx = mlc->seidx;\r\n#endif\r\nnode = hil_mlc_se + mlc->seidx;\r\nswitch (node->act) {\r\nint rc;\r\nhil_packet pack;\r\ncase HILSE_FUNC:\r\nBUG_ON(node->object.func == NULL);\r\nrc = node->object.func(mlc, node->arg);\r\nnextidx = (rc > 0) ? node->ugly :\r\n((rc < 0) ? node->bad : node->good);\r\nif (nextidx == HILSEN_FOLLOW)\r\nnextidx = rc;\r\nbreak;\r\ncase HILSE_EXPECT_LAST:\r\ncase HILSE_EXPECT_DISC:\r\ncase HILSE_EXPECT:\r\ncase HILSE_IN:\r\nwrite_lock_irqsave(&mlc->lock, flags);\r\nrc = mlc->in(mlc, node->arg);\r\nif (rc == 2) {\r\nnextidx = HILSEN_DOZE;\r\nsched_long = 1;\r\nwrite_unlock_irqrestore(&mlc->lock, flags);\r\nbreak;\r\n}\r\nif (rc == 1)\r\nnextidx = node->ugly;\r\nelse if (rc == 0)\r\nnextidx = node->good;\r\nelse\r\nnextidx = node->bad;\r\nmlc->istarted = 0;\r\nwrite_unlock_irqrestore(&mlc->lock, flags);\r\nbreak;\r\ncase HILSE_OUT_LAST:\r\nwrite_lock_irqsave(&mlc->lock, flags);\r\npack = node->object.packet;\r\npack |= ((mlc->ddi + 1) << HIL_PKT_ADDR_SHIFT);\r\ngoto out;\r\ncase HILSE_OUT_DISC:\r\nwrite_lock_irqsave(&mlc->lock, flags);\r\npack = node->object.packet;\r\npack |= ((mlc->ddi + 2) << HIL_PKT_ADDR_SHIFT);\r\ngoto out;\r\ncase HILSE_OUT:\r\nwrite_lock_irqsave(&mlc->lock, flags);\r\npack = node->object.packet;\r\nout:\r\nif (mlc->istarted)\r\ngoto out2;\r\nif ((node + 1)->act & HILSE_IN)\r\nhilse_setup_input(mlc, node + 1);\r\nout2:\r\nwrite_unlock_irqrestore(&mlc->lock, flags);\r\nif (down_trylock(&mlc->osem)) {\r\nnextidx = HILSEN_DOZE;\r\nbreak;\r\n}\r\nup(&mlc->osem);\r\nwrite_lock_irqsave(&mlc->lock, flags);\r\nif (!mlc->ostarted) {\r\nmlc->ostarted = 1;\r\nmlc->opacket = pack;\r\nmlc->out(mlc);\r\nnextidx = HILSEN_DOZE;\r\nwrite_unlock_irqrestore(&mlc->lock, flags);\r\nbreak;\r\n}\r\nmlc->ostarted = 0;\r\ndo_gettimeofday(&(mlc->instart));\r\nwrite_unlock_irqrestore(&mlc->lock, flags);\r\nnextidx = HILSEN_NEXT;\r\nbreak;\r\ncase HILSE_CTS:\r\nwrite_lock_irqsave(&mlc->lock, flags);\r\nnextidx = mlc->cts(mlc) ? node->bad : node->good;\r\nwrite_unlock_irqrestore(&mlc->lock, flags);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n#ifdef HIL_MLC_DEBUG\r\nif (nextidx == HILSEN_DOZE)\r\ndoze++;\r\n#endif\r\nwhile (nextidx & HILSEN_SCHED) {\r\nstruct timeval tv;\r\nif (!sched_long)\r\ngoto sched;\r\ndo_gettimeofday(&tv);\r\ntv.tv_usec += USEC_PER_SEC * (tv.tv_sec - mlc->instart.tv_sec);\r\ntv.tv_usec -= mlc->instart.tv_usec;\r\nif (tv.tv_usec >= mlc->intimeout) goto sched;\r\ntv.tv_usec = (mlc->intimeout - tv.tv_usec) * HZ / USEC_PER_SEC;\r\nif (!tv.tv_usec) goto sched;\r\nmod_timer(&hil_mlcs_kicker, jiffies + tv.tv_usec);\r\nbreak;\r\nsched:\r\ntasklet_schedule(&hil_mlcs_tasklet);\r\nbreak;\r\n}\r\nif (nextidx & HILSEN_DOWN)\r\nmlc->seidx += nextidx & HILSEN_MASK;\r\nelse if (nextidx & HILSEN_UP)\r\nmlc->seidx -= nextidx & HILSEN_MASK;\r\nelse\r\nmlc->seidx = nextidx & HILSEN_MASK;\r\nif (nextidx & HILSEN_BREAK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void hil_mlcs_process(unsigned long unused)\r\n{\r\nstruct list_head *tmp;\r\nread_lock(&hil_mlcs_lock);\r\nlist_for_each(tmp, &hil_mlcs) {\r\nstruct hil_mlc *mlc = list_entry(tmp, hil_mlc, list);\r\nwhile (hilse_donode(mlc) == 0) {\r\n#ifdef HIL_MLC_DEBUG\r\nif (mlc->seidx != 41 &&\r\nmlc->seidx != 42 &&\r\nmlc->seidx != 43)\r\nprintk(KERN_DEBUG PREFIX " + ");\r\n#endif\r\n}\r\n}\r\nread_unlock(&hil_mlcs_lock);\r\n}\r\nstatic void hil_mlcs_timer(unsigned long data)\r\n{\r\nhil_mlcs_probe = 1;\r\ntasklet_schedule(&hil_mlcs_tasklet);\r\nif (!timer_pending(&hil_mlcs_kicker))\r\nmod_timer(&hil_mlcs_kicker, jiffies + HZ);\r\n}\r\nstatic int hil_mlc_serio_write(struct serio *serio, unsigned char c)\r\n{\r\nstruct hil_mlc_serio_map *map;\r\nstruct hil_mlc *mlc;\r\nstruct serio_driver *drv;\r\nuint8_t *idx, *last;\r\nmap = serio->port_data;\r\nBUG_ON(map == NULL);\r\nmlc = map->mlc;\r\nBUG_ON(mlc == NULL);\r\nmlc->serio_opacket[map->didx] |=\r\n((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\r\nif (mlc->serio_oidx[map->didx] >= 3) {\r\nif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\r\nreturn -EIO;\r\nswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\r\ncase HIL_CMD_IDD:\r\nidx = mlc->di[map->didx].idd;\r\ngoto emu;\r\ncase HIL_CMD_RSC:\r\nidx = mlc->di[map->didx].rsc;\r\ngoto emu;\r\ncase HIL_CMD_EXD:\r\nidx = mlc->di[map->didx].exd;\r\ngoto emu;\r\ncase HIL_CMD_RNM:\r\nidx = mlc->di[map->didx].rnm;\r\ngoto emu;\r\ndefault:\r\nbreak;\r\n}\r\nmlc->serio_oidx[map->didx] = 0;\r\nmlc->serio_opacket[map->didx] = 0;\r\n}\r\nmlc->serio_oidx[map->didx]++;\r\nreturn -EIO;\r\nemu:\r\ndrv = serio->drv;\r\nBUG_ON(drv == NULL);\r\nlast = idx + 15;\r\nwhile ((last != idx) && (*last == 0))\r\nlast--;\r\nwhile (idx != last) {\r\ndrv->interrupt(serio, 0, 0);\r\ndrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\r\ndrv->interrupt(serio, 0, 0);\r\ndrv->interrupt(serio, *idx, 0);\r\nidx++;\r\n}\r\ndrv->interrupt(serio, 0, 0);\r\ndrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\r\ndrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\r\ndrv->interrupt(serio, *idx, 0);\r\nmlc->serio_oidx[map->didx] = 0;\r\nmlc->serio_opacket[map->didx] = 0;\r\nreturn 0;\r\n}\r\nstatic int hil_mlc_serio_open(struct serio *serio)\r\n{\r\nstruct hil_mlc_serio_map *map;\r\nstruct hil_mlc *mlc;\r\nif (serio_get_drvdata(serio) != NULL)\r\nreturn -EBUSY;\r\nmap = serio->port_data;\r\nBUG_ON(map == NULL);\r\nmlc = map->mlc;\r\nBUG_ON(mlc == NULL);\r\nreturn 0;\r\n}\r\nstatic void hil_mlc_serio_close(struct serio *serio)\r\n{\r\nstruct hil_mlc_serio_map *map;\r\nstruct hil_mlc *mlc;\r\nmap = serio->port_data;\r\nBUG_ON(map == NULL);\r\nmlc = map->mlc;\r\nBUG_ON(mlc == NULL);\r\nserio_set_drvdata(serio, NULL);\r\nserio->drv = NULL;\r\n}\r\nint hil_mlc_register(hil_mlc *mlc)\r\n{\r\nint i;\r\nunsigned long flags;\r\nBUG_ON(mlc == NULL);\r\nmlc->istarted = 0;\r\nmlc->ostarted = 0;\r\nrwlock_init(&mlc->lock);\r\nsema_init(&mlc->osem, 1);\r\nsema_init(&mlc->isem, 1);\r\nmlc->icount = -1;\r\nmlc->imatch = 0;\r\nmlc->opercnt = 0;\r\nsema_init(&(mlc->csem), 0);\r\nhil_mlc_clear_di_scratch(mlc);\r\nhil_mlc_clear_di_map(mlc, 0);\r\nfor (i = 0; i < HIL_MLC_DEVMEM; i++) {\r\nstruct serio *mlc_serio;\r\nhil_mlc_copy_di_scratch(mlc, i);\r\nmlc_serio = kzalloc(sizeof(*mlc_serio), GFP_KERNEL);\r\nmlc->serio[i] = mlc_serio;\r\nif (!mlc->serio[i]) {\r\nfor (; i >= 0; i--)\r\nkfree(mlc->serio[i]);\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(mlc_serio->name, sizeof(mlc_serio->name)-1, "HIL_SERIO%d", i);\r\nsnprintf(mlc_serio->phys, sizeof(mlc_serio->phys)-1, "HIL%d", i);\r\nmlc_serio->id = hil_mlc_serio_id;\r\nmlc_serio->id.id = i;\r\nmlc_serio->write = hil_mlc_serio_write;\r\nmlc_serio->open = hil_mlc_serio_open;\r\nmlc_serio->close = hil_mlc_serio_close;\r\nmlc_serio->port_data = &(mlc->serio_map[i]);\r\nmlc->serio_map[i].mlc = mlc;\r\nmlc->serio_map[i].didx = i;\r\nmlc->serio_map[i].di_revmap = -1;\r\nmlc->serio_opacket[i] = 0;\r\nmlc->serio_oidx[i] = 0;\r\nserio_register_port(mlc_serio);\r\n}\r\nmlc->tasklet = &hil_mlcs_tasklet;\r\nwrite_lock_irqsave(&hil_mlcs_lock, flags);\r\nlist_add_tail(&mlc->list, &hil_mlcs);\r\nmlc->seidx = HILSEN_START;\r\nwrite_unlock_irqrestore(&hil_mlcs_lock, flags);\r\ntasklet_schedule(&hil_mlcs_tasklet);\r\nreturn 0;\r\n}\r\nint hil_mlc_unregister(hil_mlc *mlc)\r\n{\r\nstruct list_head *tmp;\r\nunsigned long flags;\r\nint i;\r\nBUG_ON(mlc == NULL);\r\nwrite_lock_irqsave(&hil_mlcs_lock, flags);\r\nlist_for_each(tmp, &hil_mlcs)\r\nif (list_entry(tmp, hil_mlc, list) == mlc)\r\ngoto found;\r\nwrite_unlock_irqrestore(&hil_mlcs_lock, flags);\r\ntasklet_schedule(&hil_mlcs_tasklet);\r\nreturn -ENODEV;\r\nfound:\r\nlist_del(tmp);\r\nwrite_unlock_irqrestore(&hil_mlcs_lock, flags);\r\nfor (i = 0; i < HIL_MLC_DEVMEM; i++) {\r\nserio_unregister_port(mlc->serio[i]);\r\nmlc->serio[i] = NULL;\r\n}\r\ntasklet_schedule(&hil_mlcs_tasklet);\r\nreturn 0;\r\n}\r\nstatic int __init hil_mlc_init(void)\r\n{\r\nsetup_timer(&hil_mlcs_kicker, &hil_mlcs_timer, 0);\r\nmod_timer(&hil_mlcs_kicker, jiffies + HZ);\r\ntasklet_enable(&hil_mlcs_tasklet);\r\nreturn 0;\r\n}\r\nstatic void __exit hil_mlc_exit(void)\r\n{\r\ndel_timer_sync(&hil_mlcs_kicker);\r\ntasklet_disable(&hil_mlcs_tasklet);\r\ntasklet_kill(&hil_mlcs_tasklet);\r\n}
