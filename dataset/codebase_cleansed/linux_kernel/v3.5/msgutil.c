struct msg_msg *load_msg(const void __user *src, int len)\r\n{\r\nstruct msg_msg *msg;\r\nstruct msg_msgseg **pseg;\r\nint err;\r\nint alen;\r\nalen = len;\r\nif (alen > DATALEN_MSG)\r\nalen = DATALEN_MSG;\r\nmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL);\r\nif (msg == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nmsg->next = NULL;\r\nmsg->security = NULL;\r\nif (copy_from_user(msg + 1, src, alen)) {\r\nerr = -EFAULT;\r\ngoto out_err;\r\n}\r\nlen -= alen;\r\nsrc = ((char __user *)src) + alen;\r\npseg = &msg->next;\r\nwhile (len > 0) {\r\nstruct msg_msgseg *seg;\r\nalen = len;\r\nif (alen > DATALEN_SEG)\r\nalen = DATALEN_SEG;\r\nseg = kmalloc(sizeof(*seg) + alen,\r\nGFP_KERNEL);\r\nif (seg == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\n*pseg = seg;\r\nseg->next = NULL;\r\nif (copy_from_user(seg + 1, src, alen)) {\r\nerr = -EFAULT;\r\ngoto out_err;\r\n}\r\npseg = &seg->next;\r\nlen -= alen;\r\nsrc = ((char __user *)src) + alen;\r\n}\r\nerr = security_msg_msg_alloc(msg);\r\nif (err)\r\ngoto out_err;\r\nreturn msg;\r\nout_err:\r\nfree_msg(msg);\r\nreturn ERR_PTR(err);\r\n}\r\nint store_msg(void __user *dest, struct msg_msg *msg, int len)\r\n{\r\nint alen;\r\nstruct msg_msgseg *seg;\r\nalen = len;\r\nif (alen > DATALEN_MSG)\r\nalen = DATALEN_MSG;\r\nif (copy_to_user(dest, msg + 1, alen))\r\nreturn -1;\r\nlen -= alen;\r\ndest = ((char __user *)dest) + alen;\r\nseg = msg->next;\r\nwhile (len > 0) {\r\nalen = len;\r\nif (alen > DATALEN_SEG)\r\nalen = DATALEN_SEG;\r\nif (copy_to_user(dest, seg + 1, alen))\r\nreturn -1;\r\nlen -= alen;\r\ndest = ((char __user *)dest) + alen;\r\nseg = seg->next;\r\n}\r\nreturn 0;\r\n}\r\nvoid free_msg(struct msg_msg *msg)\r\n{\r\nstruct msg_msgseg *seg;\r\nsecurity_msg_msg_free(msg);\r\nseg = msg->next;\r\nkfree(msg);\r\nwhile (seg != NULL) {\r\nstruct msg_msgseg *tmp = seg->next;\r\nkfree(seg);\r\nseg = tmp;\r\n}\r\n}
