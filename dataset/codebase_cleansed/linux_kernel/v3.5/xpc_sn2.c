static int\r\nxpc_setup_partitions_sn2(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\nxpc_teardown_partitions_sn2(void)\r\n{\r\n}\r\nstatic void\r\nxpc_allow_IPI_ops_sn2(void)\r\n{\r\nint node;\r\nint nasid;\r\nif (is_shub2()) {\r\nxpc_sh2_IPI_access0_sn2 =\r\n(u64)HUB_L((u64 *)LOCAL_MMR_ADDR(SH2_IPI_ACCESS0));\r\nxpc_sh2_IPI_access1_sn2 =\r\n(u64)HUB_L((u64 *)LOCAL_MMR_ADDR(SH2_IPI_ACCESS1));\r\nxpc_sh2_IPI_access2_sn2 =\r\n(u64)HUB_L((u64 *)LOCAL_MMR_ADDR(SH2_IPI_ACCESS2));\r\nxpc_sh2_IPI_access3_sn2 =\r\n(u64)HUB_L((u64 *)LOCAL_MMR_ADDR(SH2_IPI_ACCESS3));\r\nfor_each_online_node(node) {\r\nnasid = cnodeid_to_nasid(node);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS0),\r\n-1UL);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS1),\r\n-1UL);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS2),\r\n-1UL);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS3),\r\n-1UL);\r\n}\r\n} else {\r\nxpc_sh1_IPI_access_sn2 =\r\n(u64)HUB_L((u64 *)LOCAL_MMR_ADDR(SH1_IPI_ACCESS));\r\nfor_each_online_node(node) {\r\nnasid = cnodeid_to_nasid(node);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH1_IPI_ACCESS),\r\n-1UL);\r\n}\r\n}\r\n}\r\nstatic void\r\nxpc_disallow_IPI_ops_sn2(void)\r\n{\r\nint node;\r\nint nasid;\r\nif (is_shub2()) {\r\nfor_each_online_node(node) {\r\nnasid = cnodeid_to_nasid(node);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS0),\r\nxpc_sh2_IPI_access0_sn2);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS1),\r\nxpc_sh2_IPI_access1_sn2);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS2),\r\nxpc_sh2_IPI_access2_sn2);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH2_IPI_ACCESS3),\r\nxpc_sh2_IPI_access3_sn2);\r\n}\r\n} else {\r\nfor_each_online_node(node) {\r\nnasid = cnodeid_to_nasid(node);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid, SH1_IPI_ACCESS),\r\nxpc_sh1_IPI_access_sn2);\r\n}\r\n}\r\n}\r\nstatic u64\r\nxpc_receive_IRQ_amo_sn2(struct amo *amo)\r\n{\r\nreturn FETCHOP_LOAD_OP(TO_AMO((u64)&amo->variable), FETCHOP_CLEAR);\r\n}\r\nstatic enum xp_retval\r\nxpc_send_IRQ_sn2(struct amo *amo, u64 flag, int nasid, int phys_cpuid,\r\nint vector)\r\n{\r\nint ret = 0;\r\nunsigned long irq_flags;\r\nlocal_irq_save(irq_flags);\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amo->variable), FETCHOP_OR, flag);\r\nsn_send_IPI_phys(nasid, phys_cpuid, vector, 0);\r\nret = xp_nofault_PIOR((u64 *)GLOBAL_MMR_ADDR(NASID_GET(&amo->variable),\r\nxp_nofault_PIOR_target));\r\nlocal_irq_restore(irq_flags);\r\nreturn (ret == 0) ? xpSuccess : xpPioReadError;\r\n}\r\nstatic struct amo *\r\nxpc_init_IRQ_amo_sn2(int index)\r\n{\r\nstruct amo *amo = xpc_vars_sn2->amos_page + index;\r\n(void)xpc_receive_IRQ_amo_sn2(amo);\r\nreturn amo;\r\n}\r\nstatic irqreturn_t\r\nxpc_handle_activate_IRQ_sn2(int irq, void *dev_id)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&xpc_activate_IRQ_rcvd_lock, irq_flags);\r\nxpc_activate_IRQ_rcvd++;\r\nspin_unlock_irqrestore(&xpc_activate_IRQ_rcvd_lock, irq_flags);\r\nwake_up_interruptible(&xpc_activate_IRQ_wq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nxpc_send_activate_IRQ_sn2(unsigned long amos_page_pa, int from_nasid,\r\nint to_nasid, int to_phys_cpuid)\r\n{\r\nstruct amo *amos = (struct amo *)__va(amos_page_pa +\r\n(XPC_ACTIVATE_IRQ_AMOS_SN2 *\r\nsizeof(struct amo)));\r\n(void)xpc_send_IRQ_sn2(&amos[BIT_WORD(from_nasid / 2)],\r\nBIT_MASK(from_nasid / 2), to_nasid,\r\nto_phys_cpuid, SGI_XPC_ACTIVATE);\r\n}\r\nstatic void\r\nxpc_send_local_activate_IRQ_sn2(int from_nasid)\r\n{\r\nunsigned long irq_flags;\r\nstruct amo *amos = (struct amo *)__va(xpc_vars_sn2->amos_page_pa +\r\n(XPC_ACTIVATE_IRQ_AMOS_SN2 *\r\nsizeof(struct amo)));\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amos[BIT_WORD(from_nasid / 2)].variable),\r\nFETCHOP_OR, BIT_MASK(from_nasid / 2));\r\nspin_lock_irqsave(&xpc_activate_IRQ_rcvd_lock, irq_flags);\r\nxpc_activate_IRQ_rcvd++;\r\nspin_unlock_irqrestore(&xpc_activate_IRQ_rcvd_lock, irq_flags);\r\nwake_up_interruptible(&xpc_activate_IRQ_wq);\r\n}\r\nstatic void\r\nxpc_check_for_sent_chctl_flags_sn2(struct xpc_partition *part)\r\n{\r\nunion xpc_channel_ctl_flags chctl;\r\nunsigned long irq_flags;\r\nchctl.all_flags = xpc_receive_IRQ_amo_sn2(part->sn.sn2.\r\nlocal_chctl_amo_va);\r\nif (chctl.all_flags == 0)\r\nreturn;\r\nspin_lock_irqsave(&part->chctl_lock, irq_flags);\r\npart->chctl.all_flags |= chctl.all_flags;\r\nspin_unlock_irqrestore(&part->chctl_lock, irq_flags);\r\ndev_dbg(xpc_chan, "received notify IRQ from partid=%d, chctl.all_flags="\r\n"0x%llx\n", XPC_PARTID(part), chctl.all_flags);\r\nxpc_wakeup_channel_mgr(part);\r\n}\r\nstatic irqreturn_t\r\nxpc_handle_notify_IRQ_sn2(int irq, void *dev_id)\r\n{\r\nshort partid = (short)(u64)dev_id;\r\nstruct xpc_partition *part = &xpc_partitions[partid];\r\nDBUG_ON(partid < 0 || partid >= XP_MAX_NPARTITIONS_SN2);\r\nif (xpc_part_ref(part)) {\r\nxpc_check_for_sent_chctl_flags_sn2(part);\r\nxpc_part_deref(part);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nxpc_check_for_dropped_notify_IRQ_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nif (xpc_part_ref(part)) {\r\nxpc_check_for_sent_chctl_flags_sn2(part);\r\npart_sn2->dropped_notify_IRQ_timer.expires = jiffies +\r\nXPC_DROPPED_NOTIFY_IRQ_WAIT_INTERVAL;\r\nadd_timer(&part_sn2->dropped_notify_IRQ_timer);\r\nxpc_part_deref(part);\r\n}\r\n}\r\nstatic void\r\nxpc_send_notify_IRQ_sn2(struct xpc_channel *ch, u8 chctl_flag,\r\nchar *chctl_flag_string, unsigned long *irq_flags)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[ch->partid];\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nunion xpc_channel_ctl_flags chctl = { 0 };\r\nenum xp_retval ret;\r\nif (likely(part->act_state != XPC_P_AS_DEACTIVATING)) {\r\nchctl.flags[ch->number] = chctl_flag;\r\nret = xpc_send_IRQ_sn2(part_sn2->remote_chctl_amo_va,\r\nchctl.all_flags,\r\npart_sn2->notify_IRQ_nasid,\r\npart_sn2->notify_IRQ_phys_cpuid,\r\nSGI_XPC_NOTIFY);\r\ndev_dbg(xpc_chan, "%s sent to partid=%d, channel=%d, ret=%d\n",\r\nchctl_flag_string, ch->partid, ch->number, ret);\r\nif (unlikely(ret != xpSuccess)) {\r\nif (irq_flags != NULL)\r\nspin_unlock_irqrestore(&ch->lock, *irq_flags);\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\nif (irq_flags != NULL)\r\nspin_lock_irqsave(&ch->lock, *irq_flags);\r\n}\r\n}\r\n}\r\nstatic void\r\nxpc_send_local_notify_IRQ_sn2(struct xpc_channel *ch, u8 chctl_flag,\r\nchar *chctl_flag_string)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[ch->partid];\r\nunion xpc_channel_ctl_flags chctl = { 0 };\r\nchctl.flags[ch->number] = chctl_flag;\r\nFETCHOP_STORE_OP(TO_AMO((u64)&part->sn.sn2.local_chctl_amo_va->\r\nvariable), FETCHOP_OR, chctl.all_flags);\r\ndev_dbg(xpc_chan, "%s sent local from partid=%d, channel=%d\n",\r\nchctl_flag_string, ch->partid, ch->number);\r\n}\r\nstatic void\r\nxpc_send_chctl_closerequest_sn2(struct xpc_channel *ch,\r\nunsigned long *irq_flags)\r\n{\r\nstruct xpc_openclose_args *args = ch->sn.sn2.local_openclose_args;\r\nargs->reason = ch->reason;\r\nXPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_CLOSEREQUEST, irq_flags);\r\n}\r\nstatic void\r\nxpc_send_chctl_closereply_sn2(struct xpc_channel *ch, unsigned long *irq_flags)\r\n{\r\nXPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_CLOSEREPLY, irq_flags);\r\n}\r\nstatic void\r\nxpc_send_chctl_openrequest_sn2(struct xpc_channel *ch, unsigned long *irq_flags)\r\n{\r\nstruct xpc_openclose_args *args = ch->sn.sn2.local_openclose_args;\r\nargs->entry_size = ch->entry_size;\r\nargs->local_nentries = ch->local_nentries;\r\nXPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_OPENREQUEST, irq_flags);\r\n}\r\nstatic void\r\nxpc_send_chctl_openreply_sn2(struct xpc_channel *ch, unsigned long *irq_flags)\r\n{\r\nstruct xpc_openclose_args *args = ch->sn.sn2.local_openclose_args;\r\nargs->remote_nentries = ch->remote_nentries;\r\nargs->local_nentries = ch->local_nentries;\r\nargs->local_msgqueue_pa = xp_pa(ch->sn.sn2.local_msgqueue);\r\nXPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_OPENREPLY, irq_flags);\r\n}\r\nstatic void\r\nxpc_send_chctl_opencomplete_sn2(struct xpc_channel *ch,\r\nunsigned long *irq_flags)\r\n{\r\nXPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_OPENCOMPLETE, irq_flags);\r\n}\r\nstatic void\r\nxpc_send_chctl_msgrequest_sn2(struct xpc_channel *ch)\r\n{\r\nXPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_MSGREQUEST, NULL);\r\n}\r\nstatic void\r\nxpc_send_chctl_local_msgrequest_sn2(struct xpc_channel *ch)\r\n{\r\nXPC_SEND_LOCAL_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_MSGREQUEST);\r\n}\r\nstatic enum xp_retval\r\nxpc_save_remote_msgqueue_pa_sn2(struct xpc_channel *ch,\r\nunsigned long msgqueue_pa)\r\n{\r\nch->sn.sn2.remote_msgqueue_pa = msgqueue_pa;\r\nreturn xpSuccess;\r\n}\r\nstatic void\r\nxpc_indicate_partition_engaged_sn2(struct xpc_partition *part)\r\n{\r\nunsigned long irq_flags;\r\nstruct amo *amo = (struct amo *)__va(part->sn.sn2.remote_amos_page_pa +\r\n(XPC_ENGAGED_PARTITIONS_AMO_SN2 *\r\nsizeof(struct amo)));\r\nlocal_irq_save(irq_flags);\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amo->variable), FETCHOP_OR,\r\nBIT(sn_partition_id));\r\n(void)xp_nofault_PIOR((u64 *)GLOBAL_MMR_ADDR(NASID_GET(&amo->\r\nvariable),\r\nxp_nofault_PIOR_target));\r\nlocal_irq_restore(irq_flags);\r\n}\r\nstatic void\r\nxpc_indicate_partition_disengaged_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nunsigned long irq_flags;\r\nstruct amo *amo = (struct amo *)__va(part_sn2->remote_amos_page_pa +\r\n(XPC_ENGAGED_PARTITIONS_AMO_SN2 *\r\nsizeof(struct amo)));\r\nlocal_irq_save(irq_flags);\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amo->variable), FETCHOP_AND,\r\n~BIT(sn_partition_id));\r\n(void)xp_nofault_PIOR((u64 *)GLOBAL_MMR_ADDR(NASID_GET(&amo->\r\nvariable),\r\nxp_nofault_PIOR_target));\r\nlocal_irq_restore(irq_flags);\r\nxpc_send_activate_IRQ_sn2(part_sn2->remote_amos_page_pa,\r\ncnodeid_to_nasid(0),\r\npart_sn2->activate_IRQ_nasid,\r\npart_sn2->activate_IRQ_phys_cpuid);\r\n}\r\nstatic void\r\nxpc_assume_partition_disengaged_sn2(short partid)\r\n{\r\nstruct amo *amo = xpc_vars_sn2->amos_page +\r\nXPC_ENGAGED_PARTITIONS_AMO_SN2;\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amo->variable), FETCHOP_AND,\r\n~BIT(partid));\r\n}\r\nstatic int\r\nxpc_partition_engaged_sn2(short partid)\r\n{\r\nstruct amo *amo = xpc_vars_sn2->amos_page +\r\nXPC_ENGAGED_PARTITIONS_AMO_SN2;\r\nreturn (FETCHOP_LOAD_OP(TO_AMO((u64)&amo->variable), FETCHOP_LOAD) &\r\nBIT(partid)) != 0;\r\n}\r\nstatic int\r\nxpc_any_partition_engaged_sn2(void)\r\n{\r\nstruct amo *amo = xpc_vars_sn2->amos_page +\r\nXPC_ENGAGED_PARTITIONS_AMO_SN2;\r\nreturn FETCHOP_LOAD_OP(TO_AMO((u64)&amo->variable), FETCHOP_LOAD) != 0;\r\n}\r\nstatic enum xp_retval\r\nxpc_allow_amo_ops_sn2(struct amo *amos_page)\r\n{\r\nenum xp_retval ret = xpSuccess;\r\nif (!enable_shub_wars_1_1())\r\nret = xp_expand_memprotect(ia64_tpa((u64)amos_page), PAGE_SIZE);\r\nreturn ret;\r\n}\r\nstatic void\r\nxpc_allow_amo_ops_shub_wars_1_1_sn2(void)\r\n{\r\nint node;\r\nint nasid;\r\nif (!enable_shub_wars_1_1())\r\nreturn;\r\nfor_each_online_node(node) {\r\nnasid = cnodeid_to_nasid(node);\r\nxpc_prot_vec_sn2[node] =\r\n(u64)HUB_L((u64 *)GLOBAL_MMR_ADDR(nasid,\r\nSH1_MD_DQLP_MMR_DIR_PRIVEC0));\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid,\r\nSH1_MD_DQLP_MMR_DIR_PRIVEC0),\r\n-1UL);\r\nHUB_S((u64 *)GLOBAL_MMR_ADDR(nasid,\r\nSH1_MD_DQRP_MMR_DIR_PRIVEC0),\r\n-1UL);\r\n}\r\n}\r\nstatic enum xp_retval\r\nxpc_get_partition_rsvd_page_pa_sn2(void *buf, u64 *cookie, unsigned long *rp_pa,\r\nsize_t *len)\r\n{\r\ns64 status;\r\nenum xp_retval ret;\r\nstatus = sn_partition_reserved_page_pa((u64)buf, cookie,\r\n(u64 *)rp_pa, (u64 *)len);\r\nif (status == SALRET_OK)\r\nret = xpSuccess;\r\nelse if (status == SALRET_MORE_PASSES)\r\nret = xpNeedMoreInfo;\r\nelse\r\nret = xpSalError;\r\nreturn ret;\r\n}\r\nstatic int\r\nxpc_setup_rsvd_page_sn2(struct xpc_rsvd_page *rp)\r\n{\r\nstruct amo *amos_page;\r\nint i;\r\nint ret;\r\nxpc_vars_sn2 = XPC_RP_VARS(rp);\r\nrp->sn.sn2.vars_pa = xp_pa(xpc_vars_sn2);\r\nxpc_vars_part_sn2 = (struct xpc_vars_part_sn2 *)((u8 *)XPC_RP_VARS(rp) +\r\nXPC_RP_VARS_SIZE);\r\namos_page = xpc_vars_sn2->amos_page;\r\nif (amos_page == NULL) {\r\namos_page = (struct amo *)TO_AMO(uncached_alloc_page(0, 1));\r\nif (amos_page == NULL) {\r\ndev_err(xpc_part, "can't allocate page of amos\n");\r\nreturn -ENOMEM;\r\n}\r\nret = xpc_allow_amo_ops_sn2(amos_page);\r\nif (ret != xpSuccess) {\r\ndev_err(xpc_part, "can't allow amo operations\n");\r\nuncached_free_page(__IA64_UNCACHED_OFFSET |\r\nTO_PHYS((u64)amos_page), 1);\r\nreturn -EPERM;\r\n}\r\n}\r\nmemset(xpc_vars_sn2, 0, sizeof(struct xpc_vars_sn2));\r\nxpc_vars_sn2->version = XPC_V_VERSION;\r\nxpc_vars_sn2->activate_IRQ_nasid = cpuid_to_nasid(0);\r\nxpc_vars_sn2->activate_IRQ_phys_cpuid = cpu_physical_id(0);\r\nxpc_vars_sn2->vars_part_pa = xp_pa(xpc_vars_part_sn2);\r\nxpc_vars_sn2->amos_page_pa = ia64_tpa((u64)amos_page);\r\nxpc_vars_sn2->amos_page = amos_page;\r\nmemset((u64 *)xpc_vars_part_sn2, 0, sizeof(struct xpc_vars_part_sn2) *\r\nXP_MAX_NPARTITIONS_SN2);\r\nfor (i = 0; i < xpc_nasid_mask_nlongs; i++)\r\n(void)xpc_init_IRQ_amo_sn2(XPC_ACTIVATE_IRQ_AMOS_SN2 + i);\r\n(void)xpc_init_IRQ_amo_sn2(XPC_ENGAGED_PARTITIONS_AMO_SN2);\r\n(void)xpc_init_IRQ_amo_sn2(XPC_DEACTIVATE_REQUEST_AMO_SN2);\r\nreturn 0;\r\n}\r\nstatic int\r\nxpc_hb_allowed_sn2(short partid, void *heartbeating_to_mask)\r\n{\r\nreturn test_bit(partid, heartbeating_to_mask);\r\n}\r\nstatic void\r\nxpc_allow_hb_sn2(short partid)\r\n{\r\nDBUG_ON(xpc_vars_sn2 == NULL);\r\nset_bit(partid, xpc_vars_sn2->heartbeating_to_mask);\r\n}\r\nstatic void\r\nxpc_disallow_hb_sn2(short partid)\r\n{\r\nDBUG_ON(xpc_vars_sn2 == NULL);\r\nclear_bit(partid, xpc_vars_sn2->heartbeating_to_mask);\r\n}\r\nstatic void\r\nxpc_disallow_all_hbs_sn2(void)\r\n{\r\nDBUG_ON(xpc_vars_sn2 == NULL);\r\nbitmap_zero(xpc_vars_sn2->heartbeating_to_mask, xp_max_npartitions);\r\n}\r\nstatic void\r\nxpc_increment_heartbeat_sn2(void)\r\n{\r\nxpc_vars_sn2->heartbeat++;\r\n}\r\nstatic void\r\nxpc_offline_heartbeat_sn2(void)\r\n{\r\nxpc_increment_heartbeat_sn2();\r\nxpc_vars_sn2->heartbeat_offline = 1;\r\n}\r\nstatic void\r\nxpc_online_heartbeat_sn2(void)\r\n{\r\nxpc_increment_heartbeat_sn2();\r\nxpc_vars_sn2->heartbeat_offline = 0;\r\n}\r\nstatic void\r\nxpc_heartbeat_init_sn2(void)\r\n{\r\nDBUG_ON(xpc_vars_sn2 == NULL);\r\nbitmap_zero(xpc_vars_sn2->heartbeating_to_mask, XP_MAX_NPARTITIONS_SN2);\r\nxpc_online_heartbeat_sn2();\r\n}\r\nstatic void\r\nxpc_heartbeat_exit_sn2(void)\r\n{\r\nxpc_offline_heartbeat_sn2();\r\n}\r\nstatic enum xp_retval\r\nxpc_get_remote_heartbeat_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_vars_sn2 *remote_vars;\r\nenum xp_retval ret;\r\nremote_vars = (struct xpc_vars_sn2 *)xpc_remote_copy_buffer_sn2;\r\nret = xp_remote_memcpy(xp_pa(remote_vars),\r\npart->sn.sn2.remote_vars_pa,\r\nXPC_RP_VARS_SIZE);\r\nif (ret != xpSuccess)\r\nreturn ret;\r\ndev_dbg(xpc_part, "partid=%d, heartbeat=%lld, last_heartbeat=%lld, "\r\n"heartbeat_offline=%lld, HB_mask[0]=0x%lx\n", XPC_PARTID(part),\r\nremote_vars->heartbeat, part->last_heartbeat,\r\nremote_vars->heartbeat_offline,\r\nremote_vars->heartbeating_to_mask[0]);\r\nif ((remote_vars->heartbeat == part->last_heartbeat &&\r\n!remote_vars->heartbeat_offline) ||\r\n!xpc_hb_allowed_sn2(sn_partition_id,\r\nremote_vars->heartbeating_to_mask)) {\r\nret = xpNoHeartbeat;\r\n} else {\r\npart->last_heartbeat = remote_vars->heartbeat;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum xp_retval\r\nxpc_get_remote_vars_sn2(unsigned long remote_vars_pa,\r\nstruct xpc_vars_sn2 *remote_vars)\r\n{\r\nenum xp_retval ret;\r\nif (remote_vars_pa == 0)\r\nreturn xpVarsNotSet;\r\nret = xp_remote_memcpy(xp_pa(remote_vars), remote_vars_pa,\r\nXPC_RP_VARS_SIZE);\r\nif (ret != xpSuccess)\r\nreturn ret;\r\nif (XPC_VERSION_MAJOR(remote_vars->version) !=\r\nXPC_VERSION_MAJOR(XPC_V_VERSION)) {\r\nreturn xpBadVersion;\r\n}\r\nreturn xpSuccess;\r\n}\r\nstatic void\r\nxpc_request_partition_activation_sn2(struct xpc_rsvd_page *remote_rp,\r\nunsigned long remote_rp_pa, int nasid)\r\n{\r\nxpc_send_local_activate_IRQ_sn2(nasid);\r\n}\r\nstatic void\r\nxpc_request_partition_reactivation_sn2(struct xpc_partition *part)\r\n{\r\nxpc_send_local_activate_IRQ_sn2(part->sn.sn2.activate_IRQ_nasid);\r\n}\r\nstatic void\r\nxpc_request_partition_deactivation_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nunsigned long irq_flags;\r\nstruct amo *amo = (struct amo *)__va(part_sn2->remote_amos_page_pa +\r\n(XPC_DEACTIVATE_REQUEST_AMO_SN2 *\r\nsizeof(struct amo)));\r\nlocal_irq_save(irq_flags);\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amo->variable), FETCHOP_OR,\r\nBIT(sn_partition_id));\r\n(void)xp_nofault_PIOR((u64 *)GLOBAL_MMR_ADDR(NASID_GET(&amo->\r\nvariable),\r\nxp_nofault_PIOR_target));\r\nlocal_irq_restore(irq_flags);\r\nxpc_send_activate_IRQ_sn2(part_sn2->remote_amos_page_pa,\r\ncnodeid_to_nasid(0),\r\npart_sn2->activate_IRQ_nasid,\r\npart_sn2->activate_IRQ_phys_cpuid);\r\n}\r\nstatic void\r\nxpc_cancel_partition_deactivation_request_sn2(struct xpc_partition *part)\r\n{\r\nunsigned long irq_flags;\r\nstruct amo *amo = (struct amo *)__va(part->sn.sn2.remote_amos_page_pa +\r\n(XPC_DEACTIVATE_REQUEST_AMO_SN2 *\r\nsizeof(struct amo)));\r\nlocal_irq_save(irq_flags);\r\nFETCHOP_STORE_OP(TO_AMO((u64)&amo->variable), FETCHOP_AND,\r\n~BIT(sn_partition_id));\r\n(void)xp_nofault_PIOR((u64 *)GLOBAL_MMR_ADDR(NASID_GET(&amo->\r\nvariable),\r\nxp_nofault_PIOR_target));\r\nlocal_irq_restore(irq_flags);\r\n}\r\nstatic int\r\nxpc_partition_deactivation_requested_sn2(short partid)\r\n{\r\nstruct amo *amo = xpc_vars_sn2->amos_page +\r\nXPC_DEACTIVATE_REQUEST_AMO_SN2;\r\nreturn (FETCHOP_LOAD_OP(TO_AMO((u64)&amo->variable), FETCHOP_LOAD) &\r\nBIT(partid)) != 0;\r\n}\r\nstatic void\r\nxpc_update_partition_info_sn2(struct xpc_partition *part, u8 remote_rp_version,\r\nunsigned long *remote_rp_ts_jiffies,\r\nunsigned long remote_rp_pa,\r\nunsigned long remote_vars_pa,\r\nstruct xpc_vars_sn2 *remote_vars)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\npart->remote_rp_version = remote_rp_version;\r\ndev_dbg(xpc_part, " remote_rp_version = 0x%016x\n",\r\npart->remote_rp_version);\r\npart->remote_rp_ts_jiffies = *remote_rp_ts_jiffies;\r\ndev_dbg(xpc_part, " remote_rp_ts_jiffies = 0x%016lx\n",\r\npart->remote_rp_ts_jiffies);\r\npart->remote_rp_pa = remote_rp_pa;\r\ndev_dbg(xpc_part, " remote_rp_pa = 0x%016lx\n", part->remote_rp_pa);\r\npart_sn2->remote_vars_pa = remote_vars_pa;\r\ndev_dbg(xpc_part, " remote_vars_pa = 0x%016lx\n",\r\npart_sn2->remote_vars_pa);\r\npart->last_heartbeat = remote_vars->heartbeat - 1;\r\ndev_dbg(xpc_part, " last_heartbeat = 0x%016llx\n",\r\npart->last_heartbeat);\r\npart_sn2->remote_vars_part_pa = remote_vars->vars_part_pa;\r\ndev_dbg(xpc_part, " remote_vars_part_pa = 0x%016lx\n",\r\npart_sn2->remote_vars_part_pa);\r\npart_sn2->activate_IRQ_nasid = remote_vars->activate_IRQ_nasid;\r\ndev_dbg(xpc_part, " activate_IRQ_nasid = 0x%x\n",\r\npart_sn2->activate_IRQ_nasid);\r\npart_sn2->activate_IRQ_phys_cpuid =\r\nremote_vars->activate_IRQ_phys_cpuid;\r\ndev_dbg(xpc_part, " activate_IRQ_phys_cpuid = 0x%x\n",\r\npart_sn2->activate_IRQ_phys_cpuid);\r\npart_sn2->remote_amos_page_pa = remote_vars->amos_page_pa;\r\ndev_dbg(xpc_part, " remote_amos_page_pa = 0x%lx\n",\r\npart_sn2->remote_amos_page_pa);\r\npart_sn2->remote_vars_version = remote_vars->version;\r\ndev_dbg(xpc_part, " remote_vars_version = 0x%x\n",\r\npart_sn2->remote_vars_version);\r\n}\r\nstatic void\r\nxpc_identify_activate_IRQ_req_sn2(int nasid)\r\n{\r\nstruct xpc_rsvd_page *remote_rp;\r\nstruct xpc_vars_sn2 *remote_vars;\r\nunsigned long remote_rp_pa;\r\nunsigned long remote_vars_pa;\r\nint remote_rp_version;\r\nint reactivate = 0;\r\nunsigned long remote_rp_ts_jiffies = 0;\r\nshort partid;\r\nstruct xpc_partition *part;\r\nstruct xpc_partition_sn2 *part_sn2;\r\nenum xp_retval ret;\r\nremote_rp = (struct xpc_rsvd_page *)xpc_remote_copy_buffer_sn2;\r\nret = xpc_get_remote_rp(nasid, NULL, remote_rp, &remote_rp_pa);\r\nif (ret != xpSuccess) {\r\ndev_warn(xpc_part, "unable to get reserved page from nasid %d, "\r\n"which sent interrupt, reason=%d\n", nasid, ret);\r\nreturn;\r\n}\r\nremote_vars_pa = remote_rp->sn.sn2.vars_pa;\r\nremote_rp_version = remote_rp->version;\r\nremote_rp_ts_jiffies = remote_rp->ts_jiffies;\r\npartid = remote_rp->SAL_partid;\r\npart = &xpc_partitions[partid];\r\npart_sn2 = &part->sn.sn2;\r\nremote_vars = (struct xpc_vars_sn2 *)xpc_remote_copy_buffer_sn2;\r\nret = xpc_get_remote_vars_sn2(remote_vars_pa, remote_vars);\r\nif (ret != xpSuccess) {\r\ndev_warn(xpc_part, "unable to get XPC variables from nasid %d, "\r\n"which sent interrupt, reason=%d\n", nasid, ret);\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\nreturn;\r\n}\r\npart->activate_IRQ_rcvd++;\r\ndev_dbg(xpc_part, "partid for nasid %d is %d; IRQs = %d; HB = "\r\n"%lld:0x%lx\n", (int)nasid, (int)partid,\r\npart->activate_IRQ_rcvd,\r\nremote_vars->heartbeat, remote_vars->heartbeating_to_mask[0]);\r\nif (xpc_partition_disengaged(part) &&\r\npart->act_state == XPC_P_AS_INACTIVE) {\r\nxpc_update_partition_info_sn2(part, remote_rp_version,\r\n&remote_rp_ts_jiffies,\r\nremote_rp_pa, remote_vars_pa,\r\nremote_vars);\r\nif (xpc_partition_deactivation_requested_sn2(partid)) {\r\nreturn;\r\n}\r\nxpc_activate_partition(part);\r\nreturn;\r\n}\r\nDBUG_ON(part->remote_rp_version == 0);\r\nDBUG_ON(part_sn2->remote_vars_version == 0);\r\nif (remote_rp_ts_jiffies != part->remote_rp_ts_jiffies) {\r\nDBUG_ON(xpc_partition_engaged_sn2(partid));\r\nDBUG_ON(xpc_partition_deactivation_requested_sn2(partid));\r\nxpc_update_partition_info_sn2(part, remote_rp_version,\r\n&remote_rp_ts_jiffies,\r\nremote_rp_pa, remote_vars_pa,\r\nremote_vars);\r\nreactivate = 1;\r\n}\r\nif (part->disengage_timeout > 0 && !xpc_partition_disengaged(part)) {\r\nreturn;\r\n}\r\nif (reactivate)\r\nXPC_DEACTIVATE_PARTITION(part, xpReactivating);\r\nelse if (xpc_partition_deactivation_requested_sn2(partid))\r\nXPC_DEACTIVATE_PARTITION(part, xpOtherGoingDown);\r\n}\r\nint\r\nxpc_identify_activate_IRQ_sender_sn2(void)\r\n{\r\nint l;\r\nint b;\r\nunsigned long nasid_mask_long;\r\nu64 nasid;\r\nint n_IRQs_detected = 0;\r\nstruct amo *act_amos;\r\nact_amos = xpc_vars_sn2->amos_page + XPC_ACTIVATE_IRQ_AMOS_SN2;\r\nfor (l = 0; l < xpc_nasid_mask_nlongs; l++) {\r\nif (xpc_exiting)\r\nbreak;\r\nnasid_mask_long = xpc_receive_IRQ_amo_sn2(&act_amos[l]);\r\nb = find_first_bit(&nasid_mask_long, BITS_PER_LONG);\r\nif (b >= BITS_PER_LONG) {\r\ncontinue;\r\n}\r\ndev_dbg(xpc_part, "amo[%d] gave back 0x%lx\n", l,\r\nnasid_mask_long);\r\nxpc_mach_nasids[l] |= nasid_mask_long;\r\ndo {\r\nn_IRQs_detected++;\r\nnasid = (l * BITS_PER_LONG + b) * 2;\r\ndev_dbg(xpc_part, "interrupt from nasid %lld\n", nasid);\r\nxpc_identify_activate_IRQ_req_sn2(nasid);\r\nb = find_next_bit(&nasid_mask_long, BITS_PER_LONG,\r\nb + 1);\r\n} while (b < BITS_PER_LONG);\r\n}\r\nreturn n_IRQs_detected;\r\n}\r\nstatic void\r\nxpc_process_activate_IRQ_rcvd_sn2(void)\r\n{\r\nunsigned long irq_flags;\r\nint n_IRQs_expected;\r\nint n_IRQs_detected;\r\nspin_lock_irqsave(&xpc_activate_IRQ_rcvd_lock, irq_flags);\r\nn_IRQs_expected = xpc_activate_IRQ_rcvd;\r\nxpc_activate_IRQ_rcvd = 0;\r\nspin_unlock_irqrestore(&xpc_activate_IRQ_rcvd_lock, irq_flags);\r\nn_IRQs_detected = xpc_identify_activate_IRQ_sender_sn2();\r\nif (n_IRQs_detected < n_IRQs_expected) {\r\n(void)xpc_identify_activate_IRQ_sender_sn2();\r\n}\r\n}\r\nstatic enum xp_retval\r\nxpc_setup_ch_structures_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nstruct xpc_channel_sn2 *ch_sn2;\r\nenum xp_retval retval;\r\nint ret;\r\nint cpuid;\r\nint ch_number;\r\nstruct timer_list *timer;\r\nshort partid = XPC_PARTID(part);\r\npart_sn2->local_GPs =\r\nxpc_kzalloc_cacheline_aligned(XPC_GP_SIZE, GFP_KERNEL,\r\n&part_sn2->local_GPs_base);\r\nif (part_sn2->local_GPs == NULL) {\r\ndev_err(xpc_chan, "can't get memory for local get/put "\r\n"values\n");\r\nreturn xpNoMemory;\r\n}\r\npart_sn2->remote_GPs =\r\nxpc_kzalloc_cacheline_aligned(XPC_GP_SIZE, GFP_KERNEL,\r\n&part_sn2->remote_GPs_base);\r\nif (part_sn2->remote_GPs == NULL) {\r\ndev_err(xpc_chan, "can't get memory for remote get/put "\r\n"values\n");\r\nretval = xpNoMemory;\r\ngoto out_1;\r\n}\r\npart_sn2->remote_GPs_pa = 0;\r\npart_sn2->local_openclose_args =\r\nxpc_kzalloc_cacheline_aligned(XPC_OPENCLOSE_ARGS_SIZE,\r\nGFP_KERNEL, &part_sn2->\r\nlocal_openclose_args_base);\r\nif (part_sn2->local_openclose_args == NULL) {\r\ndev_err(xpc_chan, "can't get memory for local connect args\n");\r\nretval = xpNoMemory;\r\ngoto out_2;\r\n}\r\npart_sn2->remote_openclose_args_pa = 0;\r\npart_sn2->local_chctl_amo_va = xpc_init_IRQ_amo_sn2(partid);\r\npart_sn2->notify_IRQ_nasid = 0;\r\npart_sn2->notify_IRQ_phys_cpuid = 0;\r\npart_sn2->remote_chctl_amo_va = NULL;\r\nsprintf(part_sn2->notify_IRQ_owner, "xpc%02d", partid);\r\nret = request_irq(SGI_XPC_NOTIFY, xpc_handle_notify_IRQ_sn2,\r\nIRQF_SHARED, part_sn2->notify_IRQ_owner,\r\n(void *)(u64)partid);\r\nif (ret != 0) {\r\ndev_err(xpc_chan, "can't register NOTIFY IRQ handler, "\r\n"errno=%d\n", -ret);\r\nretval = xpLackOfResources;\r\ngoto out_3;\r\n}\r\ntimer = &part_sn2->dropped_notify_IRQ_timer;\r\ninit_timer(timer);\r\ntimer->function =\r\n(void (*)(unsigned long))xpc_check_for_dropped_notify_IRQ_sn2;\r\ntimer->data = (unsigned long)part;\r\ntimer->expires = jiffies + XPC_DROPPED_NOTIFY_IRQ_WAIT_INTERVAL;\r\nadd_timer(timer);\r\nfor (ch_number = 0; ch_number < part->nchannels; ch_number++) {\r\nch_sn2 = &part->channels[ch_number].sn.sn2;\r\nch_sn2->local_GP = &part_sn2->local_GPs[ch_number];\r\nch_sn2->local_openclose_args =\r\n&part_sn2->local_openclose_args[ch_number];\r\nmutex_init(&ch_sn2->msg_to_pull_mutex);\r\n}\r\nxpc_vars_part_sn2[partid].GPs_pa = xp_pa(part_sn2->local_GPs);\r\nxpc_vars_part_sn2[partid].openclose_args_pa =\r\nxp_pa(part_sn2->local_openclose_args);\r\nxpc_vars_part_sn2[partid].chctl_amo_pa =\r\nxp_pa(part_sn2->local_chctl_amo_va);\r\ncpuid = raw_smp_processor_id();\r\nxpc_vars_part_sn2[partid].notify_IRQ_nasid = cpuid_to_nasid(cpuid);\r\nxpc_vars_part_sn2[partid].notify_IRQ_phys_cpuid =\r\ncpu_physical_id(cpuid);\r\nxpc_vars_part_sn2[partid].nchannels = part->nchannels;\r\nxpc_vars_part_sn2[partid].magic = XPC_VP_MAGIC1_SN2;\r\nreturn xpSuccess;\r\nout_3:\r\nkfree(part_sn2->local_openclose_args_base);\r\npart_sn2->local_openclose_args = NULL;\r\nout_2:\r\nkfree(part_sn2->remote_GPs_base);\r\npart_sn2->remote_GPs = NULL;\r\nout_1:\r\nkfree(part_sn2->local_GPs_base);\r\npart_sn2->local_GPs = NULL;\r\nreturn retval;\r\n}\r\nstatic void\r\nxpc_teardown_ch_structures_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nshort partid = XPC_PARTID(part);\r\nxpc_vars_part_sn2[partid].magic = 0;\r\ndel_timer_sync(&part_sn2->dropped_notify_IRQ_timer);\r\nfree_irq(SGI_XPC_NOTIFY, (void *)(u64)partid);\r\nkfree(part_sn2->local_openclose_args_base);\r\npart_sn2->local_openclose_args = NULL;\r\nkfree(part_sn2->remote_GPs_base);\r\npart_sn2->remote_GPs = NULL;\r\nkfree(part_sn2->local_GPs_base);\r\npart_sn2->local_GPs = NULL;\r\npart_sn2->local_chctl_amo_va = NULL;\r\n}\r\nstatic enum xp_retval\r\nxpc_pull_remote_cachelines_sn2(struct xpc_partition *part, void *dst,\r\nconst unsigned long src_pa, size_t cnt)\r\n{\r\nenum xp_retval ret;\r\nDBUG_ON(src_pa != L1_CACHE_ALIGN(src_pa));\r\nDBUG_ON((unsigned long)dst != L1_CACHE_ALIGN((unsigned long)dst));\r\nDBUG_ON(cnt != L1_CACHE_ALIGN(cnt));\r\nif (part->act_state == XPC_P_AS_DEACTIVATING)\r\nreturn part->reason;\r\nret = xp_remote_memcpy(xp_pa(dst), src_pa, cnt);\r\nif (ret != xpSuccess) {\r\ndev_dbg(xpc_chan, "xp_remote_memcpy() from partition %d failed,"\r\n" ret=%d\n", XPC_PARTID(part), ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic enum xp_retval\r\nxpc_pull_remote_vars_part_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nu8 buffer[L1_CACHE_BYTES * 2];\r\nstruct xpc_vars_part_sn2 *pulled_entry_cacheline =\r\n(struct xpc_vars_part_sn2 *)L1_CACHE_ALIGN((u64)buffer);\r\nstruct xpc_vars_part_sn2 *pulled_entry;\r\nunsigned long remote_entry_cacheline_pa;\r\nunsigned long remote_entry_pa;\r\nshort partid = XPC_PARTID(part);\r\nenum xp_retval ret;\r\nDBUG_ON(part_sn2->remote_vars_part_pa !=\r\nL1_CACHE_ALIGN(part_sn2->remote_vars_part_pa));\r\nDBUG_ON(sizeof(struct xpc_vars_part_sn2) != L1_CACHE_BYTES / 2);\r\nremote_entry_pa = part_sn2->remote_vars_part_pa +\r\nsn_partition_id * sizeof(struct xpc_vars_part_sn2);\r\nremote_entry_cacheline_pa = (remote_entry_pa & ~(L1_CACHE_BYTES - 1));\r\npulled_entry = (struct xpc_vars_part_sn2 *)((u64)pulled_entry_cacheline\r\n+ (remote_entry_pa &\r\n(L1_CACHE_BYTES - 1)));\r\nret = xpc_pull_remote_cachelines_sn2(part, pulled_entry_cacheline,\r\nremote_entry_cacheline_pa,\r\nL1_CACHE_BYTES);\r\nif (ret != xpSuccess) {\r\ndev_dbg(xpc_chan, "failed to pull XPC vars_part from "\r\n"partition %d, ret=%d\n", partid, ret);\r\nreturn ret;\r\n}\r\nif (pulled_entry->magic != XPC_VP_MAGIC1_SN2 &&\r\npulled_entry->magic != XPC_VP_MAGIC2_SN2) {\r\nif (pulled_entry->magic != 0) {\r\ndev_dbg(xpc_chan, "partition %d's XPC vars_part for "\r\n"partition %d has bad magic value (=0x%llx)\n",\r\npartid, sn_partition_id, pulled_entry->magic);\r\nreturn xpBadMagic;\r\n}\r\nreturn xpRetry;\r\n}\r\nif (xpc_vars_part_sn2[partid].magic == XPC_VP_MAGIC1_SN2) {\r\nif (pulled_entry->GPs_pa == 0 ||\r\npulled_entry->openclose_args_pa == 0 ||\r\npulled_entry->chctl_amo_pa == 0) {\r\ndev_err(xpc_chan, "partition %d's XPC vars_part for "\r\n"partition %d are not valid\n", partid,\r\nsn_partition_id);\r\nreturn xpInvalidAddress;\r\n}\r\npart_sn2->remote_GPs_pa = pulled_entry->GPs_pa;\r\npart_sn2->remote_openclose_args_pa =\r\npulled_entry->openclose_args_pa;\r\npart_sn2->remote_chctl_amo_va =\r\n(struct amo *)__va(pulled_entry->chctl_amo_pa);\r\npart_sn2->notify_IRQ_nasid = pulled_entry->notify_IRQ_nasid;\r\npart_sn2->notify_IRQ_phys_cpuid =\r\npulled_entry->notify_IRQ_phys_cpuid;\r\nif (part->nchannels > pulled_entry->nchannels)\r\npart->nchannels = pulled_entry->nchannels;\r\nxpc_vars_part_sn2[partid].magic = XPC_VP_MAGIC2_SN2;\r\n}\r\nif (pulled_entry->magic == XPC_VP_MAGIC1_SN2)\r\nreturn xpRetry;\r\nreturn xpSuccess;\r\n}\r\nstatic enum xp_retval\r\nxpc_make_first_contact_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nenum xp_retval ret;\r\nif (sn_register_xp_addr_region(part_sn2->remote_amos_page_pa,\r\nPAGE_SIZE, 1) < 0) {\r\ndev_warn(xpc_part, "xpc_activating(%d) failed to register "\r\n"xp_addr region\n", XPC_PARTID(part));\r\nret = xpPhysAddrRegFailed;\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\nreturn ret;\r\n}\r\nxpc_send_activate_IRQ_sn2(part_sn2->remote_amos_page_pa,\r\ncnodeid_to_nasid(0),\r\npart_sn2->activate_IRQ_nasid,\r\npart_sn2->activate_IRQ_phys_cpuid);\r\nwhile ((ret = xpc_pull_remote_vars_part_sn2(part)) != xpSuccess) {\r\nif (ret != xpRetry) {\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(xpc_part, "waiting to make first contact with "\r\n"partition %d\n", XPC_PARTID(part));\r\n(void)msleep_interruptible(250);\r\nif (part->act_state == XPC_P_AS_DEACTIVATING)\r\nreturn part->reason;\r\n}\r\nreturn xpSuccess;\r\n}\r\nstatic u64\r\nxpc_get_chctl_all_flags_sn2(struct xpc_partition *part)\r\n{\r\nstruct xpc_partition_sn2 *part_sn2 = &part->sn.sn2;\r\nunsigned long irq_flags;\r\nunion xpc_channel_ctl_flags chctl;\r\nenum xp_retval ret;\r\nspin_lock_irqsave(&part->chctl_lock, irq_flags);\r\nchctl = part->chctl;\r\nif (chctl.all_flags != 0)\r\npart->chctl.all_flags = 0;\r\nspin_unlock_irqrestore(&part->chctl_lock, irq_flags);\r\nif (xpc_any_openclose_chctl_flags_set(&chctl)) {\r\nret = xpc_pull_remote_cachelines_sn2(part, part->\r\nremote_openclose_args,\r\npart_sn2->\r\nremote_openclose_args_pa,\r\nXPC_OPENCLOSE_ARGS_SIZE);\r\nif (ret != xpSuccess) {\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\ndev_dbg(xpc_chan, "failed to pull openclose args from "\r\n"partition %d, ret=%d\n", XPC_PARTID(part),\r\nret);\r\nchctl.all_flags = 0;\r\n}\r\n}\r\nif (xpc_any_msg_chctl_flags_set(&chctl)) {\r\nret = xpc_pull_remote_cachelines_sn2(part, part_sn2->remote_GPs,\r\npart_sn2->remote_GPs_pa,\r\nXPC_GP_SIZE);\r\nif (ret != xpSuccess) {\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\ndev_dbg(xpc_chan, "failed to pull GPs from partition "\r\n"%d, ret=%d\n", XPC_PARTID(part), ret);\r\nchctl.all_flags = 0;\r\n}\r\n}\r\nreturn chctl.all_flags;\r\n}\r\nstatic enum xp_retval\r\nxpc_allocate_local_msgqueue_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nunsigned long irq_flags;\r\nint nentries;\r\nsize_t nbytes;\r\nfor (nentries = ch->local_nentries; nentries > 0; nentries--) {\r\nnbytes = nentries * ch->entry_size;\r\nch_sn2->local_msgqueue =\r\nxpc_kzalloc_cacheline_aligned(nbytes, GFP_KERNEL,\r\n&ch_sn2->local_msgqueue_base);\r\nif (ch_sn2->local_msgqueue == NULL)\r\ncontinue;\r\nnbytes = nentries * sizeof(struct xpc_notify_sn2);\r\nch_sn2->notify_queue = kzalloc(nbytes, GFP_KERNEL);\r\nif (ch_sn2->notify_queue == NULL) {\r\nkfree(ch_sn2->local_msgqueue_base);\r\nch_sn2->local_msgqueue = NULL;\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nif (nentries < ch->local_nentries) {\r\ndev_dbg(xpc_chan, "nentries=%d local_nentries=%d, "\r\n"partid=%d, channel=%d\n", nentries,\r\nch->local_nentries, ch->partid, ch->number);\r\nch->local_nentries = nentries;\r\n}\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nreturn xpSuccess;\r\n}\r\ndev_dbg(xpc_chan, "can't get memory for local message queue and notify "\r\n"queue, partid=%d, channel=%d\n", ch->partid, ch->number);\r\nreturn xpNoMemory;\r\n}\r\nstatic enum xp_retval\r\nxpc_allocate_remote_msgqueue_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nunsigned long irq_flags;\r\nint nentries;\r\nsize_t nbytes;\r\nDBUG_ON(ch->remote_nentries <= 0);\r\nfor (nentries = ch->remote_nentries; nentries > 0; nentries--) {\r\nnbytes = nentries * ch->entry_size;\r\nch_sn2->remote_msgqueue =\r\nxpc_kzalloc_cacheline_aligned(nbytes, GFP_KERNEL, &ch_sn2->\r\nremote_msgqueue_base);\r\nif (ch_sn2->remote_msgqueue == NULL)\r\ncontinue;\r\nspin_lock_irqsave(&ch->lock, irq_flags);\r\nif (nentries < ch->remote_nentries) {\r\ndev_dbg(xpc_chan, "nentries=%d remote_nentries=%d, "\r\n"partid=%d, channel=%d\n", nentries,\r\nch->remote_nentries, ch->partid, ch->number);\r\nch->remote_nentries = nentries;\r\n}\r\nspin_unlock_irqrestore(&ch->lock, irq_flags);\r\nreturn xpSuccess;\r\n}\r\ndev_dbg(xpc_chan, "can't get memory for cached remote message queue, "\r\n"partid=%d, channel=%d\n", ch->partid, ch->number);\r\nreturn xpNoMemory;\r\n}\r\nstatic enum xp_retval\r\nxpc_setup_msg_structures_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nenum xp_retval ret;\r\nDBUG_ON(ch->flags & XPC_C_SETUP);\r\nret = xpc_allocate_local_msgqueue_sn2(ch);\r\nif (ret == xpSuccess) {\r\nret = xpc_allocate_remote_msgqueue_sn2(ch);\r\nif (ret != xpSuccess) {\r\nkfree(ch_sn2->local_msgqueue_base);\r\nch_sn2->local_msgqueue = NULL;\r\nkfree(ch_sn2->notify_queue);\r\nch_sn2->notify_queue = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nxpc_teardown_msg_structures_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nDBUG_ON(!spin_is_locked(&ch->lock));\r\nch_sn2->remote_msgqueue_pa = 0;\r\nch_sn2->local_GP->get = 0;\r\nch_sn2->local_GP->put = 0;\r\nch_sn2->remote_GP.get = 0;\r\nch_sn2->remote_GP.put = 0;\r\nch_sn2->w_local_GP.get = 0;\r\nch_sn2->w_local_GP.put = 0;\r\nch_sn2->w_remote_GP.get = 0;\r\nch_sn2->w_remote_GP.put = 0;\r\nch_sn2->next_msg_to_pull = 0;\r\nif (ch->flags & XPC_C_SETUP) {\r\ndev_dbg(xpc_chan, "ch->flags=0x%x, partid=%d, channel=%d\n",\r\nch->flags, ch->partid, ch->number);\r\nkfree(ch_sn2->local_msgqueue_base);\r\nch_sn2->local_msgqueue = NULL;\r\nkfree(ch_sn2->remote_msgqueue_base);\r\nch_sn2->remote_msgqueue = NULL;\r\nkfree(ch_sn2->notify_queue);\r\nch_sn2->notify_queue = NULL;\r\n}\r\n}\r\nstatic void\r\nxpc_notify_senders_sn2(struct xpc_channel *ch, enum xp_retval reason, s64 put)\r\n{\r\nstruct xpc_notify_sn2 *notify;\r\nu8 notify_type;\r\ns64 get = ch->sn.sn2.w_remote_GP.get - 1;\r\nwhile (++get < put && atomic_read(&ch->n_to_notify) > 0) {\r\nnotify = &ch->sn.sn2.notify_queue[get % ch->local_nentries];\r\nnotify_type = notify->type;\r\nif (notify_type == 0 ||\r\ncmpxchg(&notify->type, notify_type, 0) != notify_type) {\r\ncontinue;\r\n}\r\nDBUG_ON(notify_type != XPC_N_CALL);\r\natomic_dec(&ch->n_to_notify);\r\nif (notify->func != NULL) {\r\ndev_dbg(xpc_chan, "notify->func() called, notify=0x%p "\r\n"msg_number=%lld partid=%d channel=%d\n",\r\n(void *)notify, get, ch->partid, ch->number);\r\nnotify->func(reason, ch->partid, ch->number,\r\nnotify->key);\r\ndev_dbg(xpc_chan, "notify->func() returned, notify=0x%p"\r\n" msg_number=%lld partid=%d channel=%d\n",\r\n(void *)notify, get, ch->partid, ch->number);\r\n}\r\n}\r\n}\r\nstatic void\r\nxpc_notify_senders_of_disconnect_sn2(struct xpc_channel *ch)\r\n{\r\nxpc_notify_senders_sn2(ch, ch->reason, ch->sn.sn2.w_local_GP.put);\r\n}\r\nstatic inline void\r\nxpc_clear_local_msgqueue_flags_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg;\r\ns64 get;\r\nget = ch_sn2->w_remote_GP.get;\r\ndo {\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->local_msgqueue +\r\n(get % ch->local_nentries) *\r\nch->entry_size);\r\nDBUG_ON(!(msg->flags & XPC_M_SN2_READY));\r\nmsg->flags = 0;\r\n} while (++get < ch_sn2->remote_GP.get);\r\n}\r\nstatic inline void\r\nxpc_clear_remote_msgqueue_flags_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg;\r\ns64 put, remote_nentries = ch->remote_nentries;\r\nif (ch_sn2->remote_GP.put < remote_nentries)\r\nreturn;\r\nput = max(ch_sn2->w_remote_GP.put, remote_nentries);\r\ndo {\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->remote_msgqueue +\r\n(put % remote_nentries) *\r\nch->entry_size);\r\nDBUG_ON(!(msg->flags & XPC_M_SN2_READY));\r\nDBUG_ON(!(msg->flags & XPC_M_SN2_DONE));\r\nDBUG_ON(msg->number != put - remote_nentries);\r\nmsg->flags = 0;\r\n} while (++put < ch_sn2->remote_GP.put);\r\n}\r\nstatic int\r\nxpc_n_of_deliverable_payloads_sn2(struct xpc_channel *ch)\r\n{\r\nreturn ch->sn.sn2.w_remote_GP.put - ch->sn.sn2.w_local_GP.get;\r\n}\r\nstatic void\r\nxpc_process_msg_chctl_flags_sn2(struct xpc_partition *part, int ch_number)\r\n{\r\nstruct xpc_channel *ch = &part->channels[ch_number];\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nint npayloads_sent;\r\nch_sn2->remote_GP = part->sn.sn2.remote_GPs[ch_number];\r\nxpc_msgqueue_ref(ch);\r\nif (ch_sn2->w_remote_GP.get == ch_sn2->remote_GP.get &&\r\nch_sn2->w_remote_GP.put == ch_sn2->remote_GP.put) {\r\nxpc_msgqueue_deref(ch);\r\nreturn;\r\n}\r\nif (!(ch->flags & XPC_C_CONNECTED)) {\r\nxpc_msgqueue_deref(ch);\r\nreturn;\r\n}\r\nif (ch_sn2->w_remote_GP.get != ch_sn2->remote_GP.get) {\r\nif (atomic_read(&ch->n_to_notify) > 0) {\r\nxpc_notify_senders_sn2(ch, xpMsgDelivered,\r\nch_sn2->remote_GP.get);\r\n}\r\nxpc_clear_local_msgqueue_flags_sn2(ch);\r\nch_sn2->w_remote_GP.get = ch_sn2->remote_GP.get;\r\ndev_dbg(xpc_chan, "w_remote_GP.get changed to %lld, partid=%d, "\r\n"channel=%d\n", ch_sn2->w_remote_GP.get, ch->partid,\r\nch->number);\r\nif (atomic_read(&ch->n_on_msg_allocate_wq) > 0)\r\nwake_up(&ch->msg_allocate_wq);\r\n}\r\nif (ch_sn2->w_remote_GP.put != ch_sn2->remote_GP.put) {\r\nxpc_clear_remote_msgqueue_flags_sn2(ch);\r\nsmp_wmb();\r\nch_sn2->w_remote_GP.put = ch_sn2->remote_GP.put;\r\ndev_dbg(xpc_chan, "w_remote_GP.put changed to %lld, partid=%d, "\r\n"channel=%d\n", ch_sn2->w_remote_GP.put, ch->partid,\r\nch->number);\r\nnpayloads_sent = xpc_n_of_deliverable_payloads_sn2(ch);\r\nif (npayloads_sent > 0) {\r\ndev_dbg(xpc_chan, "msgs waiting to be copied and "\r\n"delivered=%d, partid=%d, channel=%d\n",\r\nnpayloads_sent, ch->partid, ch->number);\r\nif (ch->flags & XPC_C_CONNECTEDCALLOUT_MADE)\r\nxpc_activate_kthreads(ch, npayloads_sent);\r\n}\r\n}\r\nxpc_msgqueue_deref(ch);\r\n}\r\nstatic struct xpc_msg_sn2 *\r\nxpc_pull_remote_msg_sn2(struct xpc_channel *ch, s64 get)\r\n{\r\nstruct xpc_partition *part = &xpc_partitions[ch->partid];\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nunsigned long remote_msg_pa;\r\nstruct xpc_msg_sn2 *msg;\r\nu32 msg_index;\r\nu32 nmsgs;\r\nu64 msg_offset;\r\nenum xp_retval ret;\r\nif (mutex_lock_interruptible(&ch_sn2->msg_to_pull_mutex) != 0) {\r\nreturn NULL;\r\n}\r\nwhile (get >= ch_sn2->next_msg_to_pull) {\r\nmsg_index = ch_sn2->next_msg_to_pull % ch->remote_nentries;\r\nDBUG_ON(ch_sn2->next_msg_to_pull >= ch_sn2->w_remote_GP.put);\r\nnmsgs = ch_sn2->w_remote_GP.put - ch_sn2->next_msg_to_pull;\r\nif (msg_index + nmsgs > ch->remote_nentries) {\r\nnmsgs = ch->remote_nentries - msg_index;\r\n}\r\nmsg_offset = msg_index * ch->entry_size;\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->remote_msgqueue +\r\nmsg_offset);\r\nremote_msg_pa = ch_sn2->remote_msgqueue_pa + msg_offset;\r\nret = xpc_pull_remote_cachelines_sn2(part, msg, remote_msg_pa,\r\nnmsgs * ch->entry_size);\r\nif (ret != xpSuccess) {\r\ndev_dbg(xpc_chan, "failed to pull %d msgs starting with"\r\n" msg %lld from partition %d, channel=%d, "\r\n"ret=%d\n", nmsgs, ch_sn2->next_msg_to_pull,\r\nch->partid, ch->number, ret);\r\nXPC_DEACTIVATE_PARTITION(part, ret);\r\nmutex_unlock(&ch_sn2->msg_to_pull_mutex);\r\nreturn NULL;\r\n}\r\nch_sn2->next_msg_to_pull += nmsgs;\r\n}\r\nmutex_unlock(&ch_sn2->msg_to_pull_mutex);\r\nmsg_offset = (get % ch->remote_nentries) * ch->entry_size;\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->remote_msgqueue + msg_offset);\r\nreturn msg;\r\n}\r\nstatic void *\r\nxpc_get_deliverable_payload_sn2(struct xpc_channel *ch)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg;\r\nvoid *payload = NULL;\r\ns64 get;\r\ndo {\r\nif (ch->flags & XPC_C_DISCONNECTING)\r\nbreak;\r\nget = ch_sn2->w_local_GP.get;\r\nsmp_rmb();\r\nif (get == ch_sn2->w_remote_GP.put)\r\nbreak;\r\nif (cmpxchg(&ch_sn2->w_local_GP.get, get, get + 1) == get) {\r\ndev_dbg(xpc_chan, "w_local_GP.get changed to %lld, "\r\n"partid=%d, channel=%d\n", get + 1,\r\nch->partid, ch->number);\r\nmsg = xpc_pull_remote_msg_sn2(ch, get);\r\nif (msg != NULL) {\r\nDBUG_ON(msg->number != get);\r\nDBUG_ON(msg->flags & XPC_M_SN2_DONE);\r\nDBUG_ON(!(msg->flags & XPC_M_SN2_READY));\r\npayload = &msg->payload;\r\n}\r\nbreak;\r\n}\r\n} while (1);\r\nreturn payload;\r\n}\r\nstatic void\r\nxpc_send_msgs_sn2(struct xpc_channel *ch, s64 initial_put)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg;\r\ns64 put = initial_put + 1;\r\nint send_msgrequest = 0;\r\nwhile (1) {\r\nwhile (1) {\r\nif (put == ch_sn2->w_local_GP.put)\r\nbreak;\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->\r\nlocal_msgqueue + (put %\r\nch->local_nentries) *\r\nch->entry_size);\r\nif (!(msg->flags & XPC_M_SN2_READY))\r\nbreak;\r\nput++;\r\n}\r\nif (put == initial_put) {\r\nbreak;\r\n}\r\nif (cmpxchg_rel(&ch_sn2->local_GP->put, initial_put, put) !=\r\ninitial_put) {\r\nDBUG_ON(ch_sn2->local_GP->put < initial_put);\r\nbreak;\r\n}\r\ndev_dbg(xpc_chan, "local_GP->put changed to %lld, partid=%d, "\r\n"channel=%d\n", put, ch->partid, ch->number);\r\nsend_msgrequest = 1;\r\ninitial_put = put;\r\n}\r\nif (send_msgrequest)\r\nxpc_send_chctl_msgrequest_sn2(ch);\r\n}\r\nstatic enum xp_retval\r\nxpc_allocate_msg_sn2(struct xpc_channel *ch, u32 flags,\r\nstruct xpc_msg_sn2 **address_of_msg)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg;\r\nenum xp_retval ret;\r\ns64 put;\r\nret = xpTimeout;\r\nwhile (1) {\r\nput = ch_sn2->w_local_GP.put;\r\nsmp_rmb();\r\nif (put - ch_sn2->w_remote_GP.get < ch->local_nentries) {\r\nif (cmpxchg(&ch_sn2->w_local_GP.put, put, put + 1) ==\r\nput) {\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (ret == xpTimeout)\r\nxpc_send_chctl_local_msgrequest_sn2(ch);\r\nif (flags & XPC_NOWAIT)\r\nreturn xpNoWait;\r\nret = xpc_allocate_msg_wait(ch);\r\nif (ret != xpInterrupted && ret != xpTimeout)\r\nreturn ret;\r\n}\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->local_msgqueue +\r\n(put % ch->local_nentries) *\r\nch->entry_size);\r\nDBUG_ON(msg->flags != 0);\r\nmsg->number = put;\r\ndev_dbg(xpc_chan, "w_local_GP.put changed to %lld; msg=0x%p, "\r\n"msg_number=%lld, partid=%d, channel=%d\n", put + 1,\r\n(void *)msg, msg->number, ch->partid, ch->number);\r\n*address_of_msg = msg;\r\nreturn xpSuccess;\r\n}\r\nstatic enum xp_retval\r\nxpc_send_payload_sn2(struct xpc_channel *ch, u32 flags, void *payload,\r\nu16 payload_size, u8 notify_type, xpc_notify_func func,\r\nvoid *key)\r\n{\r\nenum xp_retval ret = xpSuccess;\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg = msg;\r\nstruct xpc_notify_sn2 *notify = notify;\r\ns64 msg_number;\r\ns64 put;\r\nDBUG_ON(notify_type == XPC_N_CALL && func == NULL);\r\nif (XPC_MSG_SIZE(payload_size) > ch->entry_size)\r\nreturn xpPayloadTooBig;\r\nxpc_msgqueue_ref(ch);\r\nif (ch->flags & XPC_C_DISCONNECTING) {\r\nret = ch->reason;\r\ngoto out_1;\r\n}\r\nif (!(ch->flags & XPC_C_CONNECTED)) {\r\nret = xpNotConnected;\r\ngoto out_1;\r\n}\r\nret = xpc_allocate_msg_sn2(ch, flags, &msg);\r\nif (ret != xpSuccess)\r\ngoto out_1;\r\nmsg_number = msg->number;\r\nif (notify_type != 0) {\r\nmsg->flags |= XPC_M_SN2_INTERRUPT;\r\natomic_inc(&ch->n_to_notify);\r\nnotify = &ch_sn2->notify_queue[msg_number % ch->local_nentries];\r\nnotify->func = func;\r\nnotify->key = key;\r\nnotify->type = notify_type;\r\nif (ch->flags & XPC_C_DISCONNECTING) {\r\nif (cmpxchg(&notify->type, notify_type, 0) ==\r\nnotify_type) {\r\natomic_dec(&ch->n_to_notify);\r\nret = ch->reason;\r\n}\r\ngoto out_1;\r\n}\r\n}\r\nmemcpy(&msg->payload, payload, payload_size);\r\nmsg->flags |= XPC_M_SN2_READY;\r\nsmp_mb();\r\nput = ch_sn2->local_GP->put;\r\nif (put == msg_number)\r\nxpc_send_msgs_sn2(ch, put);\r\nout_1:\r\nxpc_msgqueue_deref(ch);\r\nreturn ret;\r\n}\r\nstatic void\r\nxpc_acknowledge_msgs_sn2(struct xpc_channel *ch, s64 initial_get, u8 msg_flags)\r\n{\r\nstruct xpc_channel_sn2 *ch_sn2 = &ch->sn.sn2;\r\nstruct xpc_msg_sn2 *msg;\r\ns64 get = initial_get + 1;\r\nint send_msgrequest = 0;\r\nwhile (1) {\r\nwhile (1) {\r\nif (get == ch_sn2->w_local_GP.get)\r\nbreak;\r\nmsg = (struct xpc_msg_sn2 *)((u64)ch_sn2->\r\nremote_msgqueue + (get %\r\nch->remote_nentries) *\r\nch->entry_size);\r\nif (!(msg->flags & XPC_M_SN2_DONE))\r\nbreak;\r\nmsg_flags |= msg->flags;\r\nget++;\r\n}\r\nif (get == initial_get) {\r\nbreak;\r\n}\r\nif (cmpxchg_rel(&ch_sn2->local_GP->get, initial_get, get) !=\r\ninitial_get) {\r\nDBUG_ON(ch_sn2->local_GP->get <= initial_get);\r\nbreak;\r\n}\r\ndev_dbg(xpc_chan, "local_GP->get changed to %lld, partid=%d, "\r\n"channel=%d\n", get, ch->partid, ch->number);\r\nsend_msgrequest = (msg_flags & XPC_M_SN2_INTERRUPT);\r\ninitial_get = get;\r\n}\r\nif (send_msgrequest)\r\nxpc_send_chctl_msgrequest_sn2(ch);\r\n}\r\nstatic void\r\nxpc_received_payload_sn2(struct xpc_channel *ch, void *payload)\r\n{\r\nstruct xpc_msg_sn2 *msg;\r\ns64 msg_number;\r\ns64 get;\r\nmsg = container_of(payload, struct xpc_msg_sn2, payload);\r\nmsg_number = msg->number;\r\ndev_dbg(xpc_chan, "msg=0x%p, msg_number=%lld, partid=%d, channel=%d\n",\r\n(void *)msg, msg_number, ch->partid, ch->number);\r\nDBUG_ON((((u64)msg - (u64)ch->sn.sn2.remote_msgqueue) / ch->entry_size) !=\r\nmsg_number % ch->remote_nentries);\r\nDBUG_ON(!(msg->flags & XPC_M_SN2_READY));\r\nDBUG_ON(msg->flags & XPC_M_SN2_DONE);\r\nmsg->flags |= XPC_M_SN2_DONE;\r\nsmp_mb();\r\nget = ch->sn.sn2.local_GP->get;\r\nif (get == msg_number)\r\nxpc_acknowledge_msgs_sn2(ch, get, msg->flags);\r\n}\r\nint\r\nxpc_init_sn2(void)\r\n{\r\nint ret;\r\nsize_t buf_size;\r\nxpc_arch_ops = xpc_arch_ops_sn2;\r\nif (offsetof(struct xpc_msg_sn2, payload) > XPC_MSG_HDR_MAX_SIZE) {\r\ndev_err(xpc_part, "header portion of struct xpc_msg_sn2 is "\r\n"larger than %d\n", XPC_MSG_HDR_MAX_SIZE);\r\nreturn -E2BIG;\r\n}\r\nbuf_size = max(XPC_RP_VARS_SIZE,\r\nXPC_RP_HEADER_SIZE + XP_NASID_MASK_BYTES_SN2);\r\nxpc_remote_copy_buffer_sn2 = xpc_kmalloc_cacheline_aligned(buf_size,\r\nGFP_KERNEL,\r\n&xpc_remote_copy_buffer_base_sn2);\r\nif (xpc_remote_copy_buffer_sn2 == NULL) {\r\ndev_err(xpc_part, "can't get memory for remote copy buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nxpc_allow_IPI_ops_sn2();\r\nxpc_allow_amo_ops_shub_wars_1_1_sn2();\r\nret = request_irq(SGI_XPC_ACTIVATE, xpc_handle_activate_IRQ_sn2, 0,\r\n"xpc hb", NULL);\r\nif (ret != 0) {\r\ndev_err(xpc_part, "can't register ACTIVATE IRQ handler, "\r\n"errno=%d\n", -ret);\r\nxpc_disallow_IPI_ops_sn2();\r\nkfree(xpc_remote_copy_buffer_base_sn2);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nxpc_exit_sn2(void)\r\n{\r\nfree_irq(SGI_XPC_ACTIVATE, NULL);\r\nxpc_disallow_IPI_ops_sn2();\r\nkfree(xpc_remote_copy_buffer_base_sn2);\r\n}
