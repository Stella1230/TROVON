static const struct mt9m001_datafmt *mt9m001_find_datafmt(\r\nenum v4l2_mbus_pixelcode code, const struct mt9m001_datafmt *fmt,\r\nint n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; i++)\r\nif (fmt[i].code == code)\r\nreturn fmt + i;\r\nreturn NULL;\r\n}\r\nstatic struct mt9m001 *to_mt9m001(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct mt9m001, subdev);\r\n}\r\nstatic int reg_read(struct i2c_client *client, const u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic int reg_set(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, ret | data);\r\n}\r\nstatic int reg_clear(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, ret & ~data);\r\n}\r\nstatic int mt9m001_init(struct i2c_client *client)\r\n{\r\nint ret;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nret = reg_write(client, MT9M001_RESET, 1);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_RESET, 0);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_OUTPUT_CONTROL, 0);\r\nreturn ret;\r\n}\r\nstatic int mt9m001_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg_write(client, MT9M001_OUTPUT_CONTROL, enable ? 2 : 0) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_s_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nstruct v4l2_rect rect = a->c;\r\nint ret;\r\nconst u16 hblank = 9, vblank = 25;\r\nif (mt9m001->fmts == mt9m001_colour_fmts)\r\nrect.height = ALIGN(rect.height, 2);\r\nrect.width = ALIGN(rect.width, 2);\r\nrect.left = ALIGN(rect.left, 2);\r\nsoc_camera_limit_side(&rect.left, &rect.width,\r\nMT9M001_COLUMN_SKIP, MT9M001_MIN_WIDTH, MT9M001_MAX_WIDTH);\r\nsoc_camera_limit_side(&rect.top, &rect.height,\r\nMT9M001_ROW_SKIP, MT9M001_MIN_HEIGHT, MT9M001_MAX_HEIGHT);\r\nmt9m001->total_h = rect.height + mt9m001->y_skip_top + vblank;\r\nret = reg_write(client, MT9M001_HORIZONTAL_BLANKING, hblank);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_VERTICAL_BLANKING, vblank);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_COLUMN_START, rect.left);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_ROW_START, rect.top);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_WINDOW_WIDTH, rect.width - 1);\r\nif (!ret)\r\nret = reg_write(client, MT9M001_WINDOW_HEIGHT,\r\nrect.height + mt9m001->y_skip_top - 1);\r\nif (!ret && v4l2_ctrl_g_ctrl(mt9m001->autoexposure) == V4L2_EXPOSURE_AUTO)\r\nret = reg_write(client, MT9M001_SHUTTER_WIDTH, mt9m001->total_h);\r\nif (!ret)\r\nmt9m001->rect = rect;\r\nreturn ret;\r\n}\r\nstatic int mt9m001_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\na->c = mt9m001->rect;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = MT9M001_COLUMN_SKIP;\r\na->bounds.top = MT9M001_ROW_SKIP;\r\na->bounds.width = MT9M001_MAX_WIDTH;\r\na->bounds.height = MT9M001_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_g_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nmf->width = mt9m001->rect.width;\r\nmf->height = mt9m001->rect.height;\r\nmf->code = mt9m001->fmt->code;\r\nmf->colorspace = mt9m001->fmt->colorspace;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_s_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nstruct v4l2_crop a = {\r\n.c = {\r\n.left = mt9m001->rect.left,\r\n.top = mt9m001->rect.top,\r\n.width = mf->width,\r\n.height = mf->height,\r\n},\r\n};\r\nint ret;\r\nret = mt9m001_s_crop(sd, &a);\r\nif (!ret) {\r\nmf->width = mt9m001->rect.width;\r\nmf->height = mt9m001->rect.height;\r\nmt9m001->fmt = mt9m001_find_datafmt(mf->code,\r\nmt9m001->fmts, mt9m001->num_fmts);\r\nmf->colorspace = mt9m001->fmt->colorspace;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9m001_try_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nconst struct mt9m001_datafmt *fmt;\r\nv4l_bound_align_image(&mf->width, MT9M001_MIN_WIDTH,\r\nMT9M001_MAX_WIDTH, 1,\r\n&mf->height, MT9M001_MIN_HEIGHT + mt9m001->y_skip_top,\r\nMT9M001_MAX_HEIGHT + mt9m001->y_skip_top, 0, 0);\r\nif (mt9m001->fmts == mt9m001_colour_fmts)\r\nmf->height = ALIGN(mf->height - 1, 2);\r\nfmt = mt9m001_find_datafmt(mf->code, mt9m001->fmts,\r\nmt9m001->num_fmts);\r\nif (!fmt) {\r\nfmt = mt9m001->fmt;\r\nmf->code = fmt->code;\r\n}\r\nmf->colorspace = fmt->colorspace;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *id)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nif (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)\r\nreturn -EINVAL;\r\nif (id->match.addr != client->addr)\r\nreturn -ENODEV;\r\nid->ident = mt9m001->model;\r\nid->revision = 0;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR || reg->reg > 0xff)\r\nreturn -EINVAL;\r\nif (reg->match.addr != client->addr)\r\nreturn -ENODEV;\r\nreg->size = 2;\r\nreg->val = reg_read(client, reg->reg);\r\nif (reg->val > 0xffff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->match.type != V4L2_CHIP_MATCH_I2C_ADDR || reg->reg > 0xff)\r\nreturn -EINVAL;\r\nif (reg->match.addr != client->addr)\r\nreturn -ENODEV;\r\nif (reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9m001 *mt9m001 = container_of(ctrl->handler,\r\nstruct mt9m001, hdl);\r\ns32 min, max;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nmin = mt9m001->exposure->minimum;\r\nmax = mt9m001->exposure->maximum;\r\nmt9m001->exposure->val =\r\n(524 + (mt9m001->total_h - 1) * (max - min)) / 1048 + min;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9m001_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9m001 *mt9m001 = container_of(ctrl->handler,\r\nstruct mt9m001, hdl);\r\nstruct v4l2_subdev *sd = &mt9m001->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct v4l2_ctrl *exp = mt9m001->exposure;\r\nint data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, MT9M001_READ_OPTIONS2, 0x8000);\r\nelse\r\ndata = reg_clear(client, MT9M001_READ_OPTIONS2, 0x8000);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_GAIN:\r\nif (ctrl->val <= ctrl->default_value) {\r\nunsigned long range = ctrl->default_value - ctrl->minimum;\r\ndata = ((ctrl->val - ctrl->minimum) * 8 + range / 2) / range;\r\ndev_dbg(&client->dev, "Setting gain %d\n", data);\r\ndata = reg_write(client, MT9M001_GLOBAL_GAIN, data);\r\nif (data < 0)\r\nreturn -EIO;\r\n} else {\r\nunsigned long range = ctrl->maximum - ctrl->default_value - 1;\r\nunsigned long gain = ((ctrl->val - ctrl->default_value - 1) *\r\n111 + range / 2) / range + 9;\r\nif (gain <= 32)\r\ndata = gain;\r\nelse if (gain <= 64)\r\ndata = ((gain - 32) * 16 + 16) / 32 + 80;\r\nelse\r\ndata = ((gain - 64) * 7 + 28) / 56 + 96;\r\ndev_dbg(&client->dev, "Setting gain from %d to %d\n",\r\nreg_read(client, MT9M001_GLOBAL_GAIN), data);\r\ndata = reg_write(client, MT9M001_GLOBAL_GAIN, data);\r\nif (data < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nif (ctrl->val == V4L2_EXPOSURE_MANUAL) {\r\nunsigned long range = exp->maximum - exp->minimum;\r\nunsigned long shutter = ((exp->val - exp->minimum) * 1048 +\r\nrange / 2) / range + 1;\r\ndev_dbg(&client->dev,\r\n"Setting shutter width from %d to %lu\n",\r\nreg_read(client, MT9M001_SHUTTER_WIDTH), shutter);\r\nif (reg_write(client, MT9M001_SHUTTER_WIDTH, shutter) < 0)\r\nreturn -EIO;\r\n} else {\r\nconst u16 vblank = 25;\r\nmt9m001->total_h = mt9m001->rect.height +\r\nmt9m001->y_skip_top + vblank;\r\nif (reg_write(client, MT9M001_SHUTTER_WIDTH, mt9m001->total_h) < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mt9m001_video_probe(struct soc_camera_link *icl,\r\nstruct i2c_client *client)\r\n{\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\ns32 data;\r\nunsigned long flags;\r\nint ret;\r\ndata = reg_write(client, MT9M001_CHIP_ENABLE, 1);\r\ndev_dbg(&client->dev, "write: %d\n", data);\r\ndata = reg_read(client, MT9M001_CHIP_VERSION);\r\nswitch (data) {\r\ncase 0x8411:\r\ncase 0x8421:\r\nmt9m001->model = V4L2_IDENT_MT9M001C12ST;\r\nmt9m001->fmts = mt9m001_colour_fmts;\r\nbreak;\r\ncase 0x8431:\r\nmt9m001->model = V4L2_IDENT_MT9M001C12STM;\r\nmt9m001->fmts = mt9m001_monochrome_fmts;\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"No MT9M001 chip detected, register read %x\n", data);\r\nreturn -ENODEV;\r\n}\r\nmt9m001->num_fmts = 0;\r\nif (icl->query_bus_param)\r\nflags = icl->query_bus_param(icl);\r\nelse\r\nflags = SOCAM_DATAWIDTH_10;\r\nif (flags & SOCAM_DATAWIDTH_10)\r\nmt9m001->num_fmts++;\r\nelse\r\nmt9m001->fmts++;\r\nif (flags & SOCAM_DATAWIDTH_8)\r\nmt9m001->num_fmts++;\r\nmt9m001->fmt = &mt9m001->fmts[0];\r\ndev_info(&client->dev, "Detected a MT9M001 chip ID %x (%s)\n", data,\r\ndata == 0x8431 ? "C12STM" : "C12ST");\r\nret = mt9m001_init(client);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failed to initialise the camera\n");\r\nreturn v4l2_ctrl_handler_setup(&mt9m001->hdl);\r\n}\r\nstatic void mt9m001_video_remove(struct soc_camera_link *icl)\r\n{\r\nif (icl->free_bus)\r\nicl->free_bus(icl);\r\n}\r\nstatic int mt9m001_g_skip_top_lines(struct v4l2_subdev *sd, u32 *lines)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\n*lines = mt9m001->y_skip_top;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_enum_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nif (index >= mt9m001->num_fmts)\r\nreturn -EINVAL;\r\n*code = mt9m001->fmts[index].code;\r\nreturn 0;\r\n}\r\nstatic int mt9m001_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\ncfg->flags = V4L2_MBUS_PCLK_SAMPLE_FALLING |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH | V4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH | V4L2_MBUS_MASTER;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(icl, cfg);\r\nreturn 0;\r\n}\r\nstatic int mt9m001_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nconst struct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nunsigned int bps = soc_mbus_get_fmtdesc(mt9m001->fmt->code)->bits_per_sample;\r\nif (icl->set_bus_param)\r\nreturn icl->set_bus_param(icl, 1 << (bps - 1));\r\nreturn bps == 10 ? 0 : -EINVAL;\r\n}\r\nstatic int mt9m001_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9m001 *mt9m001;\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nint ret;\r\nif (!icl) {\r\ndev_err(&client->dev, "MT9M001 driver needs platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9m001 = kzalloc(sizeof(struct mt9m001), GFP_KERNEL);\r\nif (!mt9m001)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&mt9m001->subdev, client, &mt9m001_subdev_ops);\r\nv4l2_ctrl_handler_init(&mt9m001->hdl, 4);\r\nv4l2_ctrl_new_std(&mt9m001->hdl, &mt9m001_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9m001->hdl, &mt9m001_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 64);\r\nmt9m001->exposure = v4l2_ctrl_new_std(&mt9m001->hdl, &mt9m001_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 1, 255, 1, 255);\r\nmt9m001->autoexposure = v4l2_ctrl_new_std_menu(&mt9m001->hdl,\r\n&mt9m001_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nmt9m001->subdev.ctrl_handler = &mt9m001->hdl;\r\nif (mt9m001->hdl.error) {\r\nint err = mt9m001->hdl.error;\r\nkfree(mt9m001);\r\nreturn err;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &mt9m001->autoexposure,\r\nV4L2_EXPOSURE_MANUAL, true);\r\nmt9m001->y_skip_top = 0;\r\nmt9m001->rect.left = MT9M001_COLUMN_SKIP;\r\nmt9m001->rect.top = MT9M001_ROW_SKIP;\r\nmt9m001->rect.width = MT9M001_MAX_WIDTH;\r\nmt9m001->rect.height = MT9M001_MAX_HEIGHT;\r\nret = mt9m001_video_probe(icl, client);\r\nif (ret) {\r\nv4l2_ctrl_handler_free(&mt9m001->hdl);\r\nkfree(mt9m001);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9m001_remove(struct i2c_client *client)\r\n{\r\nstruct mt9m001 *mt9m001 = to_mt9m001(client);\r\nstruct soc_camera_link *icl = soc_camera_i2c_to_link(client);\r\nv4l2_device_unregister_subdev(&mt9m001->subdev);\r\nv4l2_ctrl_handler_free(&mt9m001->hdl);\r\nmt9m001_video_remove(icl);\r\nkfree(mt9m001);\r\nreturn 0;\r\n}
