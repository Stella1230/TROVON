static inline void setup_num_counters(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nif (smp_num_siblings == 2) {\r\nnum_counters = NUM_COUNTERS_HT2;\r\nnum_controls = NUM_CONTROLS_HT2;\r\n}\r\n#endif\r\n}\r\nstatic inline int addr_increment(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nreturn smp_num_siblings == 2 ? 2 : 1;\r\n#else\r\nreturn 1;\r\n#endif\r\n}\r\nstatic unsigned int get_stagger(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nint cpu = smp_processor_id();\r\nreturn cpu != cpumask_first(__get_cpu_var(cpu_sibling_map));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void p4_shutdown(struct op_msrs const * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (msrs->counters[i].addr)\r\nrelease_perfctr_nmi(msrs->counters[i].addr);\r\n}\r\nfor (i = num_counters; i < num_controls; ++i) {\r\nif (msrs->controls[i].addr)\r\nrelease_evntsel_nmi(msrs->controls[i].addr);\r\n}\r\n}\r\nstatic int p4_fill_in_addresses(struct op_msrs * const msrs)\r\n{\r\nunsigned int i;\r\nunsigned int addr, cccraddr, stag;\r\nsetup_num_counters();\r\nstag = get_stagger();\r\nfor (i = 0; i < num_counters; ++i) {\r\naddr = p4_counters[VIRT_CTR(stag, i)].counter_address;\r\ncccraddr = p4_counters[VIRT_CTR(stag, i)].cccr_address;\r\nif (reserve_perfctr_nmi(addr)) {\r\nmsrs->counters[i].addr = addr;\r\nmsrs->controls[i].addr = cccraddr;\r\n}\r\n}\r\nfor (addr = MSR_P4_BSU_ESCR0 + stag;\r\naddr < MSR_P4_IQ_ESCR0; ++i, addr += addr_increment()) {\r\nif (reserve_evntsel_nmi(addr))\r\nmsrs->controls[i].addr = addr;\r\n}\r\nif (boot_cpu_data.x86_model >= 0x3) {\r\nfor (addr = MSR_P4_BSU_ESCR0 + stag;\r\naddr <= MSR_P4_BSU_ESCR1; ++i, addr += addr_increment()) {\r\nif (reserve_evntsel_nmi(addr))\r\nmsrs->controls[i].addr = addr;\r\n}\r\n} else {\r\nfor (addr = MSR_P4_IQ_ESCR0 + stag;\r\naddr <= MSR_P4_IQ_ESCR1; ++i, addr += addr_increment()) {\r\nif (reserve_evntsel_nmi(addr))\r\nmsrs->controls[i].addr = addr;\r\n}\r\n}\r\nfor (addr = MSR_P4_RAT_ESCR0 + stag;\r\naddr <= MSR_P4_SSU_ESCR0; ++i, addr += addr_increment()) {\r\nif (reserve_evntsel_nmi(addr))\r\nmsrs->controls[i].addr = addr;\r\n}\r\nfor (addr = MSR_P4_MS_ESCR0 + stag;\r\naddr <= MSR_P4_TC_ESCR1; ++i, addr += addr_increment()) {\r\nif (reserve_evntsel_nmi(addr))\r\nmsrs->controls[i].addr = addr;\r\n}\r\nfor (addr = MSR_P4_IX_ESCR0 + stag;\r\naddr <= MSR_P4_CRU_ESCR3; ++i, addr += addr_increment()) {\r\nif (reserve_evntsel_nmi(addr))\r\nmsrs->controls[i].addr = addr;\r\n}\r\nif (num_counters == NUM_COUNTERS_NON_HT) {\r\nif (reserve_evntsel_nmi(MSR_P4_CRU_ESCR5))\r\nmsrs->controls[i++].addr = MSR_P4_CRU_ESCR5;\r\nif (reserve_evntsel_nmi(MSR_P4_CRU_ESCR4))\r\nmsrs->controls[i++].addr = MSR_P4_CRU_ESCR4;\r\n} else if (stag == 0) {\r\nif (reserve_evntsel_nmi(MSR_P4_CRU_ESCR4))\r\nmsrs->controls[i++].addr = MSR_P4_CRU_ESCR4;\r\n} else {\r\nif (reserve_evntsel_nmi(MSR_P4_CRU_ESCR5)) {\r\nmsrs->controls[i++].addr = MSR_P4_CRU_ESCR5;\r\nmsrs->controls[i++].addr = MSR_P4_CRU_ESCR5;\r\n}\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!counter_config[i].enabled)\r\ncontinue;\r\nif (msrs->controls[i].addr)\r\ncontinue;\r\nop_x86_warn_reserved(i);\r\np4_shutdown(msrs);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pmc_setup_one_p4_counter(unsigned int ctr)\r\n{\r\nint i;\r\nint const maxbind = 2;\r\nunsigned int cccr = 0;\r\nunsigned int escr = 0;\r\nunsigned int high = 0;\r\nunsigned int counter_bit;\r\nstruct p4_event_binding *ev = NULL;\r\nunsigned int stag;\r\nstag = get_stagger();\r\ncounter_bit = 1 << VIRT_CTR(stag, ctr);\r\nif (counter_config[ctr].event <= 0 || counter_config[ctr].event > NUM_EVENTS) {\r\nprintk(KERN_ERR\r\n"oprofile: P4 event code 0x%lx out of range\n",\r\ncounter_config[ctr].event);\r\nreturn;\r\n}\r\nev = &(p4_events[counter_config[ctr].event - 1]);\r\nfor (i = 0; i < maxbind; i++) {\r\nif (ev->bindings[i].virt_counter & counter_bit) {\r\nrdmsr(ev->bindings[i].escr_address, escr, high);\r\nESCR_CLEAR(escr);\r\nif (stag == 0) {\r\nESCR_SET_USR_0(escr, counter_config[ctr].user);\r\nESCR_SET_OS_0(escr, counter_config[ctr].kernel);\r\n} else {\r\nESCR_SET_USR_1(escr, counter_config[ctr].user);\r\nESCR_SET_OS_1(escr, counter_config[ctr].kernel);\r\n}\r\nESCR_SET_EVENT_SELECT(escr, ev->event_select);\r\nESCR_SET_EVENT_MASK(escr, counter_config[ctr].unit_mask);\r\nwrmsr(ev->bindings[i].escr_address, escr, high);\r\nrdmsr(p4_counters[VIRT_CTR(stag, ctr)].cccr_address,\r\ncccr, high);\r\nCCCR_CLEAR(cccr);\r\nCCCR_SET_REQUIRED_BITS(cccr);\r\nCCCR_SET_ESCR_SELECT(cccr, ev->escr_select);\r\nif (stag == 0)\r\nCCCR_SET_PMI_OVF_0(cccr);\r\nelse\r\nCCCR_SET_PMI_OVF_1(cccr);\r\nwrmsr(p4_counters[VIRT_CTR(stag, ctr)].cccr_address,\r\ncccr, high);\r\nreturn;\r\n}\r\n}\r\nprintk(KERN_ERR\r\n"oprofile: P4 event code 0x%lx no binding, stag %d ctr %d\n",\r\ncounter_config[ctr].event, stag, ctr);\r\n}\r\nstatic void p4_setup_ctrs(struct op_x86_model_spec const *model,\r\nstruct op_msrs const * const msrs)\r\n{\r\nunsigned int i;\r\nunsigned int low, high;\r\nunsigned int stag;\r\nstag = get_stagger();\r\nrdmsr(MSR_IA32_MISC_ENABLE, low, high);\r\nif (!MISC_PMC_ENABLED_P(low)) {\r\nprintk(KERN_ERR "oprofile: P4 PMC not available\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < num_counters; i++) {\r\nif (unlikely(!msrs->controls[i].addr))\r\ncontinue;\r\nrdmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);\r\nCCCR_CLEAR(low);\r\nCCCR_SET_REQUIRED_BITS(low);\r\nwrmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);\r\n}\r\nfor (i = num_counters; i < num_controls; i++) {\r\nif (unlikely(!msrs->controls[i].addr))\r\ncontinue;\r\nwrmsr(msrs->controls[i].addr, 0, 0);\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (counter_config[i].enabled && msrs->controls[i].addr) {\r\nreset_value[i] = counter_config[i].count;\r\npmc_setup_one_p4_counter(i);\r\nwrmsrl(p4_counters[VIRT_CTR(stag, i)].counter_address,\r\n-(u64)counter_config[i].count);\r\n} else {\r\nreset_value[i] = 0;\r\n}\r\n}\r\n}\r\nstatic int p4_check_ctrs(struct pt_regs * const regs,\r\nstruct op_msrs const * const msrs)\r\n{\r\nunsigned long ctr, low, high, stag, real;\r\nint i;\r\nstag = get_stagger();\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[i])\r\ncontinue;\r\nreal = VIRT_CTR(stag, i);\r\nrdmsr(p4_counters[real].cccr_address, low, high);\r\nrdmsr(p4_counters[real].counter_address, ctr, high);\r\nif (CCCR_OVF_P(low) || !(ctr & OP_CTR_OVERFLOW)) {\r\noprofile_add_sample(regs, i);\r\nwrmsrl(p4_counters[real].counter_address,\r\n-(u64)reset_value[i]);\r\nCCCR_CLEAR_OVF(low);\r\nwrmsr(p4_counters[real].cccr_address, low, high);\r\nwrmsrl(p4_counters[real].counter_address,\r\n-(u64)reset_value[i]);\r\n}\r\n}\r\napic_write(APIC_LVTPC, apic_read(APIC_LVTPC) & ~APIC_LVT_MASKED);\r\nreturn 1;\r\n}\r\nstatic void p4_start(struct op_msrs const * const msrs)\r\n{\r\nunsigned int low, high, stag;\r\nint i;\r\nstag = get_stagger();\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[i])\r\ncontinue;\r\nrdmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);\r\nCCCR_SET_ENABLE(low);\r\nwrmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);\r\n}\r\n}\r\nstatic void p4_stop(struct op_msrs const * const msrs)\r\n{\r\nunsigned int low, high, stag;\r\nint i;\r\nstag = get_stagger();\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[i])\r\ncontinue;\r\nrdmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);\r\nCCCR_SET_DISABLE(low);\r\nwrmsr(p4_counters[VIRT_CTR(stag, i)].cccr_address, low, high);\r\n}\r\n}
