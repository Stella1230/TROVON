static inline void i2c_set_bit(void __iomem *reg, u32 mask)\r\n{\r\nwritel(readl(reg) | mask, reg);\r\n}\r\nstatic inline void i2c_clr_bit(void __iomem *reg, u32 mask)\r\n{\r\nwritel(readl(reg) & ~mask, reg);\r\n}\r\nstatic int flush_i2c_fifo(struct nmk_i2c_dev *dev)\r\n{\r\n#define LOOP_ATTEMPTS 10\r\nint i;\r\nunsigned long timeout;\r\nwritel((I2C_CR_FTX | I2C_CR_FRX), dev->virtbase + I2C_CR);\r\nfor (i = 0; i < LOOP_ATTEMPTS; i++) {\r\ntimeout = jiffies + dev->adap.timeout;\r\nwhile (!time_after(jiffies, timeout)) {\r\nif ((readl(dev->virtbase + I2C_CR) &\r\n(I2C_CR_FTX | I2C_CR_FRX)) == 0)\r\nreturn 0;\r\n}\r\n}\r\ndev_err(&dev->pdev->dev,\r\n"flushing operation timed out giving up after %d attempts",\r\nLOOP_ATTEMPTS);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void disable_all_interrupts(struct nmk_i2c_dev *dev)\r\n{\r\nu32 mask = IRQ_MASK(0);\r\nwritel(mask, dev->virtbase + I2C_IMSCR);\r\n}\r\nstatic void clear_all_interrupts(struct nmk_i2c_dev *dev)\r\n{\r\nu32 mask;\r\nmask = IRQ_MASK(I2C_CLEAR_ALL_INTS);\r\nwritel(mask, dev->virtbase + I2C_ICR);\r\n}\r\nstatic int init_hw(struct nmk_i2c_dev *dev)\r\n{\r\nint stat;\r\nstat = flush_i2c_fifo(dev);\r\nif (stat)\r\ngoto exit;\r\ni2c_clr_bit(dev->virtbase + I2C_CR , I2C_CR_PE);\r\ndisable_all_interrupts(dev);\r\nclear_all_interrupts(dev);\r\ndev->cli.operation = I2C_NO_OPERATION;\r\nexit:\r\nreturn stat;\r\n}\r\nstatic u32 load_i2c_mcr_reg(struct nmk_i2c_dev *dev)\r\n{\r\nu32 mcr = 0;\r\nmcr |= GEN_MASK(1, I2C_MCR_AM, 12);\r\nmcr |= GEN_MASK(dev->cli.slave_adr, I2C_MCR_A7, 1);\r\nmcr |= GEN_MASK(0, I2C_MCR_SB, 11);\r\nif (dev->cli.operation == I2C_WRITE)\r\nmcr |= GEN_MASK(I2C_WRITE, I2C_MCR_OP, 0);\r\nelse\r\nmcr |= GEN_MASK(I2C_READ, I2C_MCR_OP, 0);\r\nif (dev->stop)\r\nmcr |= GEN_MASK(1, I2C_MCR_STOP, 14);\r\nelse\r\nmcr &= ~(GEN_MASK(1, I2C_MCR_STOP, 14));\r\nmcr |= GEN_MASK(dev->cli.count, I2C_MCR_LENGTH, 15);\r\nreturn mcr;\r\n}\r\nstatic void setup_i2c_controller(struct nmk_i2c_dev *dev)\r\n{\r\nu32 brcr1, brcr2;\r\nu32 i2c_clk, div;\r\nwritel(0x0, dev->virtbase + I2C_CR);\r\nwritel(0x0, dev->virtbase + I2C_HSMCR);\r\nwritel(0x0, dev->virtbase + I2C_TFTR);\r\nwritel(0x0, dev->virtbase + I2C_RFTR);\r\nwritel(0x0, dev->virtbase + I2C_DMAR);\r\nwritel(dev->cfg.slsu << 16, dev->virtbase + I2C_SCR);\r\ni2c_clk = clk_get_rate(dev->clk);\r\nif (dev->cfg.clk_freq == 0)\r\ndev->cfg.clk_freq = 100000;\r\ndiv = (dev->cfg.clk_freq > 100000) ? 3 : 2;\r\nbrcr1 = 0 << 16;\r\nbrcr2 = (i2c_clk/(dev->cfg.clk_freq * div)) & 0xffff;\r\nwritel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);\r\nif (dev->cfg.sm > I2C_FREQ_MODE_FAST) {\r\ndev_err(&dev->pdev->dev,\r\n"do not support this mode defaulting to std. mode\n");\r\nbrcr2 = i2c_clk/(100000 * 2) & 0xffff;\r\nwritel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);\r\nwritel(I2C_FREQ_MODE_STANDARD << 4,\r\ndev->virtbase + I2C_CR);\r\n}\r\nwritel(dev->cfg.sm << 4, dev->virtbase + I2C_CR);\r\nwritel(dev->cfg.tft, dev->virtbase + I2C_TFTR);\r\nwritel(dev->cfg.rft, dev->virtbase + I2C_RFTR);\r\n}\r\nstatic int read_i2c(struct nmk_i2c_dev *dev)\r\n{\r\nu32 status = 0;\r\nu32 mcr;\r\nu32 irq_mask = 0;\r\nint timeout;\r\nmcr = load_i2c_mcr_reg(dev);\r\nwritel(mcr, dev->virtbase + I2C_MCR);\r\nwritel(readl(dev->virtbase + I2C_CR) | DEFAULT_I2C_REG_CR,\r\ndev->virtbase + I2C_CR);\r\ni2c_set_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\r\ninit_completion(&dev->xfer_complete);\r\nirq_mask = (I2C_IT_RXFNF | I2C_IT_RXFF |\r\nI2C_IT_MAL | I2C_IT_BERR);\r\nif (dev->stop)\r\nirq_mask |= I2C_IT_MTD;\r\nelse\r\nirq_mask |= I2C_IT_MTDWS;\r\nirq_mask = I2C_CLEAR_ALL_INTS & IRQ_MASK(irq_mask);\r\nwritel(readl(dev->virtbase + I2C_IMSCR) | irq_mask,\r\ndev->virtbase + I2C_IMSCR);\r\ntimeout = wait_for_completion_timeout(\r\n&dev->xfer_complete, dev->adap.timeout);\r\nif (timeout < 0) {\r\ndev_err(&dev->pdev->dev,\r\n"wait_for_completion_timeout "\r\n"returned %d waiting for event\n", timeout);\r\nstatus = timeout;\r\n}\r\nif (timeout == 0) {\r\ndev_err(&dev->pdev->dev, "read from slave 0x%x timed out\n",\r\ndev->cli.slave_adr);\r\nstatus = -ETIMEDOUT;\r\n}\r\nreturn status;\r\n}\r\nstatic void fill_tx_fifo(struct nmk_i2c_dev *dev, int no_bytes)\r\n{\r\nint count;\r\nfor (count = (no_bytes - 2);\r\n(count > 0) &&\r\n(dev->cli.count != 0);\r\ncount--) {\r\nwriteb(*dev->cli.buffer,\r\ndev->virtbase + I2C_TFR);\r\ndev->cli.buffer++;\r\ndev->cli.count--;\r\ndev->cli.xfer_bytes++;\r\n}\r\n}\r\nstatic int write_i2c(struct nmk_i2c_dev *dev)\r\n{\r\nu32 status = 0;\r\nu32 mcr;\r\nu32 irq_mask = 0;\r\nint timeout;\r\nmcr = load_i2c_mcr_reg(dev);\r\nwritel(mcr, dev->virtbase + I2C_MCR);\r\nwritel(readl(dev->virtbase + I2C_CR) | DEFAULT_I2C_REG_CR,\r\ndev->virtbase + I2C_CR);\r\ni2c_set_bit(dev->virtbase + I2C_CR , I2C_CR_PE);\r\ninit_completion(&dev->xfer_complete);\r\nirq_mask = (I2C_IT_TXFOVR | I2C_IT_MAL | I2C_IT_BERR);\r\nfill_tx_fifo(dev, MAX_I2C_FIFO_THRESHOLD);\r\nif (dev->cli.count != 0)\r\nirq_mask |= I2C_IT_TXFNE;\r\nif (dev->stop)\r\nirq_mask |= I2C_IT_MTD;\r\nelse\r\nirq_mask |= I2C_IT_MTDWS;\r\nirq_mask = I2C_CLEAR_ALL_INTS & IRQ_MASK(irq_mask);\r\nwritel(readl(dev->virtbase + I2C_IMSCR) | irq_mask,\r\ndev->virtbase + I2C_IMSCR);\r\ntimeout = wait_for_completion_timeout(\r\n&dev->xfer_complete, dev->adap.timeout);\r\nif (timeout < 0) {\r\ndev_err(&dev->pdev->dev,\r\n"wait_for_completion_timeout "\r\n"returned %d waiting for event\n", timeout);\r\nstatus = timeout;\r\n}\r\nif (timeout == 0) {\r\ndev_err(&dev->pdev->dev, "write to slave 0x%x timed out\n",\r\ndev->cli.slave_adr);\r\nstatus = -ETIMEDOUT;\r\n}\r\nreturn status;\r\n}\r\nstatic int nmk_i2c_xfer_one(struct nmk_i2c_dev *dev, u16 flags)\r\n{\r\nint status;\r\nif (flags & I2C_M_RD) {\r\ndev->cli.operation = I2C_READ;\r\nstatus = read_i2c(dev);\r\n} else {\r\ndev->cli.operation = I2C_WRITE;\r\nstatus = write_i2c(dev);\r\n}\r\nif (status || (dev->result)) {\r\nu32 i2c_sr;\r\nu32 cause;\r\ni2c_sr = readl(dev->virtbase + I2C_SR);\r\nif (((i2c_sr >> 2) & 0x3) == 0x3) {\r\ncause = (i2c_sr >> 4) & 0x7;\r\ndev_err(&dev->pdev->dev, "%s\n",\r\ncause >= ARRAY_SIZE(abort_causes) ?\r\n"unknown reason" :\r\nabort_causes[cause]);\r\n}\r\n(void) init_hw(dev);\r\nstatus = status ? status : dev->result;\r\n}\r\nreturn status;\r\n}\r\nstatic int nmk_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num_msgs)\r\n{\r\nint status;\r\nint i;\r\nstruct nmk_i2c_dev *dev = i2c_get_adapdata(i2c_adap);\r\nint j;\r\ndev->busy = true;\r\nif (dev->regulator)\r\nregulator_enable(dev->regulator);\r\npm_runtime_get_sync(&dev->pdev->dev);\r\nclk_enable(dev->clk);\r\nstatus = init_hw(dev);\r\nif (status)\r\ngoto out;\r\nfor (j = 0; j < 3; j++) {\r\nsetup_i2c_controller(dev);\r\nfor (i = 0; i < num_msgs; i++) {\r\nif (unlikely(msgs[i].flags & I2C_M_TEN)) {\r\ndev_err(&dev->pdev->dev,\r\n"10 bit addressing not supported\n");\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\ndev->cli.slave_adr = msgs[i].addr;\r\ndev->cli.buffer = msgs[i].buf;\r\ndev->cli.count = msgs[i].len;\r\ndev->stop = (i < (num_msgs - 1)) ? 0 : 1;\r\ndev->result = 0;\r\nstatus = nmk_i2c_xfer_one(dev, msgs[i].flags);\r\nif (status != 0)\r\nbreak;\r\n}\r\nif (status == 0)\r\nbreak;\r\n}\r\nout:\r\nclk_disable(dev->clk);\r\npm_runtime_put_sync(&dev->pdev->dev);\r\nif (dev->regulator)\r\nregulator_disable(dev->regulator);\r\ndev->busy = false;\r\nif (status)\r\nreturn status;\r\nelse\r\nreturn num_msgs;\r\n}\r\nstatic int disable_interrupts(struct nmk_i2c_dev *dev, u32 irq)\r\n{\r\nirq = IRQ_MASK(irq);\r\nwritel(readl(dev->virtbase + I2C_IMSCR) & ~(I2C_CLEAR_ALL_INTS & irq),\r\ndev->virtbase + I2C_IMSCR);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t i2c_irq_handler(int irq, void *arg)\r\n{\r\nstruct nmk_i2c_dev *dev = arg;\r\nu32 tft, rft;\r\nu32 count;\r\nu32 misr;\r\nu32 src = 0;\r\ntft = readl(dev->virtbase + I2C_TFTR);\r\nrft = readl(dev->virtbase + I2C_RFTR);\r\nmisr = readl(dev->virtbase + I2C_MISR);\r\nsrc = __ffs(misr);\r\nswitch ((1 << src)) {\r\ncase I2C_IT_TXFNE:\r\n{\r\nif (dev->cli.operation == I2C_READ) {\r\ndisable_interrupts(dev, I2C_IT_TXFNE);\r\n} else {\r\nfill_tx_fifo(dev, (MAX_I2C_FIFO_THRESHOLD - tft));\r\nif (dev->cli.count == 0)\r\ndisable_interrupts(dev, I2C_IT_TXFNE);\r\n}\r\n}\r\nbreak;\r\ncase I2C_IT_RXFNF:\r\nfor (count = rft; count > 0; count--) {\r\n*dev->cli.buffer = readb(dev->virtbase + I2C_RFR);\r\ndev->cli.buffer++;\r\n}\r\ndev->cli.count -= rft;\r\ndev->cli.xfer_bytes += rft;\r\nbreak;\r\ncase I2C_IT_RXFF:\r\nfor (count = MAX_I2C_FIFO_THRESHOLD; count > 0; count--) {\r\n*dev->cli.buffer = readb(dev->virtbase + I2C_RFR);\r\ndev->cli.buffer++;\r\n}\r\ndev->cli.count -= MAX_I2C_FIFO_THRESHOLD;\r\ndev->cli.xfer_bytes += MAX_I2C_FIFO_THRESHOLD;\r\nbreak;\r\ncase I2C_IT_MTD:\r\ncase I2C_IT_MTDWS:\r\nif (dev->cli.operation == I2C_READ) {\r\nwhile (!(readl(dev->virtbase + I2C_RISR)\r\n& I2C_IT_RXFE)) {\r\nif (dev->cli.count == 0)\r\nbreak;\r\n*dev->cli.buffer =\r\nreadb(dev->virtbase + I2C_RFR);\r\ndev->cli.buffer++;\r\ndev->cli.count--;\r\ndev->cli.xfer_bytes++;\r\n}\r\n}\r\ndisable_all_interrupts(dev);\r\nclear_all_interrupts(dev);\r\nif (dev->cli.count) {\r\ndev->result = -EIO;\r\ndev_err(&dev->pdev->dev,\r\n"%lu bytes still remain to be xfered\n",\r\ndev->cli.count);\r\n(void) init_hw(dev);\r\n}\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_MAL:\r\ndev->result = -EIO;\r\n(void) init_hw(dev);\r\ni2c_set_bit(dev->virtbase + I2C_ICR, I2C_IT_MAL);\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_BERR:\r\ndev->result = -EIO;\r\nif (((readl(dev->virtbase + I2C_SR) >> 2) & 0x3) == I2C_ABORT)\r\n(void) init_hw(dev);\r\ni2c_set_bit(dev->virtbase + I2C_ICR, I2C_IT_BERR);\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_TXFOVR:\r\ndev->result = -EIO;\r\n(void) init_hw(dev);\r\ndev_err(&dev->pdev->dev, "Tx Fifo Over run\n");\r\ncomplete(&dev->xfer_complete);\r\nbreak;\r\ncase I2C_IT_TXFE:\r\ncase I2C_IT_TXFF:\r\ncase I2C_IT_RXFE:\r\ncase I2C_IT_RFSR:\r\ncase I2C_IT_RFSE:\r\ncase I2C_IT_WTSR:\r\ncase I2C_IT_STD:\r\ndev_err(&dev->pdev->dev, "unhandled Interrupt\n");\r\nbreak;\r\ndefault:\r\ndev_err(&dev->pdev->dev, "spurious Interrupt..\n");\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nmk_i2c_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct nmk_i2c_dev *nmk_i2c = platform_get_drvdata(pdev);\r\nif (nmk_i2c->busy)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int nmk_i2c_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int nmk_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int __devinit nmk_i2c_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct resource *res;\r\nstruct nmk_i2c_controller *pdata =\r\npdev->dev.platform_data;\r\nstruct nmk_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\ndev = kzalloc(sizeof(struct nmk_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "cannot allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_no_mem;\r\n}\r\ndev->busy = false;\r\ndev->pdev = pdev;\r\nplatform_set_drvdata(pdev, dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENOENT;\r\ngoto err_no_resource;\r\n}\r\nif (request_mem_region(res->start, resource_size(res),\r\nDRIVER_NAME "I/O region") == NULL) {\r\nret = -EBUSY;\r\ngoto err_no_region;\r\n}\r\ndev->virtbase = ioremap(res->start, resource_size(res));\r\nif (!dev->virtbase) {\r\nret = -ENOMEM;\r\ngoto err_no_ioremap;\r\n}\r\ndev->irq = platform_get_irq(pdev, 0);\r\nret = request_irq(dev->irq, i2c_irq_handler, 0,\r\nDRIVER_NAME, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot claim the irq %d\n", dev->irq);\r\ngoto err_irq;\r\n}\r\ndev->regulator = regulator_get(&pdev->dev, "v-i2c");\r\nif (IS_ERR(dev->regulator)) {\r\ndev_warn(&pdev->dev, "could not get i2c regulator\n");\r\ndev->regulator = NULL;\r\n}\r\npm_suspend_ignore_children(&pdev->dev, true);\r\npm_runtime_enable(&pdev->dev);\r\ndev->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\ndev_err(&pdev->dev, "could not get i2c clock\n");\r\nret = PTR_ERR(dev->clk);\r\ngoto err_no_clk;\r\n}\r\nadap = &dev->adap;\r\nadap->dev.parent = &pdev->dev;\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nadap->algo = &nmk_i2c_algo;\r\nadap->timeout = pdata->timeout ? msecs_to_jiffies(pdata->timeout) :\r\nmsecs_to_jiffies(20000);\r\nsnprintf(adap->name, sizeof(adap->name),\r\n"Nomadik I2C%d at %lx", pdev->id, (unsigned long)res->start);\r\nadap->nr = pdev->id;\r\ndev->cfg.clk_freq = pdata->clk_freq;\r\ndev->cfg.slsu = pdata->slsu;\r\ndev->cfg.tft = pdata->tft;\r\ndev->cfg.rft = pdata->rft;\r\ndev->cfg.sm = pdata->sm;\r\ni2c_set_adapdata(adap, dev);\r\ndev_info(&pdev->dev,\r\n"initialize %s on virtual base %p\n",\r\nadap->name, dev->virtbase);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add adapter\n");\r\ngoto err_add_adap;\r\n}\r\nreturn 0;\r\nerr_add_adap:\r\nclk_put(dev->clk);\r\nerr_no_clk:\r\nif (dev->regulator)\r\nregulator_put(dev->regulator);\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(dev->irq, dev);\r\nerr_irq:\r\niounmap(dev->virtbase);\r\nerr_no_ioremap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_no_region:\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_no_resource:\r\nkfree(dev);\r\nerr_no_mem:\r\nreturn ret;\r\n}\r\nstatic int __devexit nmk_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct nmk_i2c_dev *dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&dev->adap);\r\nflush_i2c_fifo(dev);\r\ndisable_all_interrupts(dev);\r\nclear_all_interrupts(dev);\r\ni2c_clr_bit(dev->virtbase + I2C_CR, I2C_CR_PE);\r\nfree_irq(dev->irq, dev);\r\niounmap(dev->virtbase);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_put(dev->clk);\r\nif (dev->regulator)\r\nregulator_put(dev->regulator);\r\npm_runtime_disable(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic int __init nmk_i2c_init(void)\r\n{\r\nreturn platform_driver_register(&nmk_i2c_driver);\r\n}\r\nstatic void __exit nmk_i2c_exit(void)\r\n{\r\nplatform_driver_unregister(&nmk_i2c_driver);\r\n}
