static inline void efx_write_buf_tbl(struct efx_nic *efx, efx_qword_t *value,\r\nunsigned int index)\r\n{\r\nefx_sram_writeq(efx, efx->membase + efx->type->buf_tbl_base,\r\nvalue, index);\r\n}\r\nstatic inline efx_qword_t *efx_event(struct efx_channel *channel,\r\nunsigned int index)\r\n{\r\nreturn ((efx_qword_t *) (channel->eventq.addr)) +\r\n(index & channel->eventq_mask);\r\n}\r\nstatic inline int efx_event_present(efx_qword_t *event)\r\n{\r\nreturn !(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |\r\nEFX_DWORD_IS_ALL_ONES(event->dword[1]));\r\n}\r\nstatic bool efx_masked_compare_oword(const efx_oword_t *a, const efx_oword_t *b,\r\nconst efx_oword_t *mask)\r\n{\r\nreturn ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||\r\n((a->u64[1] ^ b->u64[1]) & mask->u64[1]);\r\n}\r\nint efx_nic_test_registers(struct efx_nic *efx,\r\nconst struct efx_nic_register_test *regs,\r\nsize_t n_regs)\r\n{\r\nunsigned address = 0, i, j;\r\nefx_oword_t mask, imask, original, reg, buf;\r\nWARN_ON(!LOOPBACK_INTERNAL(efx));\r\nfor (i = 0; i < n_regs; ++i) {\r\naddress = regs[i].address;\r\nmask = imask = regs[i].mask;\r\nEFX_INVERT_OWORD(imask);\r\nefx_reado(efx, &original, address);\r\nfor (j = 0; j < 128; j++) {\r\nif (!EFX_EXTRACT_OWORD32(mask, j, j))\r\ncontinue;\r\nEFX_AND_OWORD(reg, original, mask);\r\nEFX_SET_OWORD32(reg, j, j, 1);\r\nefx_writeo(efx, &reg, address);\r\nefx_reado(efx, &buf, address);\r\nif (efx_masked_compare_oword(&reg, &buf, &mask))\r\ngoto fail;\r\nEFX_OR_OWORD(reg, original, mask);\r\nEFX_SET_OWORD32(reg, j, j, 0);\r\nefx_writeo(efx, &reg, address);\r\nefx_reado(efx, &buf, address);\r\nif (efx_masked_compare_oword(&reg, &buf, &mask))\r\ngoto fail;\r\n}\r\nefx_writeo(efx, &original, address);\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"wrote "EFX_OWORD_FMT" read "EFX_OWORD_FMT\r\n" at address 0x%x mask "EFX_OWORD_FMT"\n", EFX_OWORD_VAL(reg),\r\nEFX_OWORD_VAL(buf), address, EFX_OWORD_VAL(mask));\r\nreturn -EIO;\r\n}\r\nstatic void\r\nefx_init_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)\r\n{\r\nefx_qword_t buf_desc;\r\nunsigned int index;\r\ndma_addr_t dma_addr;\r\nint i;\r\nEFX_BUG_ON_PARANOID(!buffer->addr);\r\nfor (i = 0; i < buffer->entries; i++) {\r\nindex = buffer->index + i;\r\ndma_addr = buffer->dma_addr + (i * EFX_BUF_SIZE);\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"mapping special buffer %d at %llx\n",\r\nindex, (unsigned long long)dma_addr);\r\nEFX_POPULATE_QWORD_3(buf_desc,\r\nFRF_AZ_BUF_ADR_REGION, 0,\r\nFRF_AZ_BUF_ADR_FBUF, dma_addr >> 12,\r\nFRF_AZ_BUF_OWNER_ID_FBUF, 0);\r\nefx_write_buf_tbl(efx, &buf_desc, index);\r\n}\r\n}\r\nstatic void\r\nefx_fini_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)\r\n{\r\nefx_oword_t buf_tbl_upd;\r\nunsigned int start = buffer->index;\r\nunsigned int end = (buffer->index + buffer->entries - 1);\r\nif (!buffer->entries)\r\nreturn;\r\nnetif_dbg(efx, hw, efx->net_dev, "unmapping special buffers %d-%d\n",\r\nbuffer->index, buffer->index + buffer->entries - 1);\r\nEFX_POPULATE_OWORD_4(buf_tbl_upd,\r\nFRF_AZ_BUF_UPD_CMD, 0,\r\nFRF_AZ_BUF_CLR_CMD, 1,\r\nFRF_AZ_BUF_CLR_END_ID, end,\r\nFRF_AZ_BUF_CLR_START_ID, start);\r\nefx_writeo(efx, &buf_tbl_upd, FR_AZ_BUF_TBL_UPD);\r\n}\r\nstatic int efx_alloc_special_buffer(struct efx_nic *efx,\r\nstruct efx_special_buffer *buffer,\r\nunsigned int len)\r\n{\r\nlen = ALIGN(len, EFX_BUF_SIZE);\r\nbuffer->addr = dma_alloc_coherent(&efx->pci_dev->dev, len,\r\n&buffer->dma_addr, GFP_KERNEL);\r\nif (!buffer->addr)\r\nreturn -ENOMEM;\r\nbuffer->len = len;\r\nbuffer->entries = len / EFX_BUF_SIZE;\r\nBUG_ON(buffer->dma_addr & (EFX_BUF_SIZE - 1));\r\nmemset(buffer->addr, 0xff, len);\r\nbuffer->index = efx->next_buffer_table;\r\nefx->next_buffer_table += buffer->entries;\r\n#ifdef CONFIG_SFC_SRIOV\r\nBUG_ON(efx_sriov_enabled(efx) &&\r\nefx->vf_buftbl_base < efx->next_buffer_table);\r\n#endif\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"allocating special buffers %d-%d at %llx+%x "\r\n"(virt %p phys %llx)\n", buffer->index,\r\nbuffer->index + buffer->entries - 1,\r\n(u64)buffer->dma_addr, len,\r\nbuffer->addr, (u64)virt_to_phys(buffer->addr));\r\nreturn 0;\r\n}\r\nstatic void\r\nefx_free_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)\r\n{\r\nif (!buffer->addr)\r\nreturn;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"deallocating special buffers %d-%d at %llx+%x "\r\n"(virt %p phys %llx)\n", buffer->index,\r\nbuffer->index + buffer->entries - 1,\r\n(u64)buffer->dma_addr, buffer->len,\r\nbuffer->addr, (u64)virt_to_phys(buffer->addr));\r\ndma_free_coherent(&efx->pci_dev->dev, buffer->len, buffer->addr,\r\nbuffer->dma_addr);\r\nbuffer->addr = NULL;\r\nbuffer->entries = 0;\r\n}\r\nint efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer,\r\nunsigned int len)\r\n{\r\nbuffer->addr = pci_alloc_consistent(efx->pci_dev, len,\r\n&buffer->dma_addr);\r\nif (!buffer->addr)\r\nreturn -ENOMEM;\r\nbuffer->len = len;\r\nmemset(buffer->addr, 0, len);\r\nreturn 0;\r\n}\r\nvoid efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer)\r\n{\r\nif (buffer->addr) {\r\npci_free_consistent(efx->pci_dev, buffer->len,\r\nbuffer->addr, buffer->dma_addr);\r\nbuffer->addr = NULL;\r\n}\r\n}\r\nstatic inline efx_qword_t *\r\nefx_tx_desc(struct efx_tx_queue *tx_queue, unsigned int index)\r\n{\r\nreturn ((efx_qword_t *) (tx_queue->txd.addr)) + index;\r\n}\r\nstatic inline void efx_notify_tx_desc(struct efx_tx_queue *tx_queue)\r\n{\r\nunsigned write_ptr;\r\nefx_dword_t reg;\r\nwrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\r\nEFX_POPULATE_DWORD_1(reg, FRF_AZ_TX_DESC_WPTR_DWORD, write_ptr);\r\nefx_writed_page(tx_queue->efx, &reg,\r\nFR_AZ_TX_DESC_UPD_DWORD_P0, tx_queue->queue);\r\n}\r\nstatic inline void efx_push_tx_desc(struct efx_tx_queue *tx_queue,\r\nconst efx_qword_t *txd)\r\n{\r\nunsigned write_ptr;\r\nefx_oword_t reg;\r\nBUILD_BUG_ON(FRF_AZ_TX_DESC_LBN != 0);\r\nBUILD_BUG_ON(FR_AA_TX_DESC_UPD_KER != FR_BZ_TX_DESC_UPD_P0);\r\nwrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\r\nEFX_POPULATE_OWORD_2(reg, FRF_AZ_TX_DESC_PUSH_CMD, true,\r\nFRF_AZ_TX_DESC_WPTR, write_ptr);\r\nreg.qword[0] = *txd;\r\nefx_writeo_page(tx_queue->efx, &reg,\r\nFR_BZ_TX_DESC_UPD_P0, tx_queue->queue);\r\n}\r\nstatic inline bool\r\nefx_may_push_tx_desc(struct efx_tx_queue *tx_queue, unsigned int write_count)\r\n{\r\nunsigned empty_read_count = ACCESS_ONCE(tx_queue->empty_read_count);\r\nif (empty_read_count == 0)\r\nreturn false;\r\ntx_queue->empty_read_count = 0;\r\nreturn ((empty_read_count ^ write_count) & ~EFX_EMPTY_COUNT_VALID) == 0;\r\n}\r\nvoid efx_nic_push_buffers(struct efx_tx_queue *tx_queue)\r\n{\r\nstruct efx_tx_buffer *buffer;\r\nefx_qword_t *txd;\r\nunsigned write_ptr;\r\nunsigned old_write_count = tx_queue->write_count;\r\nBUG_ON(tx_queue->write_count == tx_queue->insert_count);\r\ndo {\r\nwrite_ptr = tx_queue->write_count & tx_queue->ptr_mask;\r\nbuffer = &tx_queue->buffer[write_ptr];\r\ntxd = efx_tx_desc(tx_queue, write_ptr);\r\n++tx_queue->write_count;\r\nEFX_POPULATE_QWORD_4(*txd,\r\nFSF_AZ_TX_KER_CONT, buffer->continuation,\r\nFSF_AZ_TX_KER_BYTE_COUNT, buffer->len,\r\nFSF_AZ_TX_KER_BUF_REGION, 0,\r\nFSF_AZ_TX_KER_BUF_ADDR, buffer->dma_addr);\r\n} while (tx_queue->write_count != tx_queue->insert_count);\r\nwmb();\r\nif (efx_may_push_tx_desc(tx_queue, old_write_count)) {\r\ntxd = efx_tx_desc(tx_queue,\r\nold_write_count & tx_queue->ptr_mask);\r\nefx_push_tx_desc(tx_queue, txd);\r\n++tx_queue->pushes;\r\n} else {\r\nefx_notify_tx_desc(tx_queue);\r\n}\r\n}\r\nint efx_nic_probe_tx(struct efx_tx_queue *tx_queue)\r\n{\r\nstruct efx_nic *efx = tx_queue->efx;\r\nunsigned entries;\r\nentries = tx_queue->ptr_mask + 1;\r\nreturn efx_alloc_special_buffer(efx, &tx_queue->txd,\r\nentries * sizeof(efx_qword_t));\r\n}\r\nvoid efx_nic_init_tx(struct efx_tx_queue *tx_queue)\r\n{\r\nstruct efx_nic *efx = tx_queue->efx;\r\nefx_oword_t reg;\r\nefx_init_special_buffer(efx, &tx_queue->txd);\r\nEFX_POPULATE_OWORD_10(reg,\r\nFRF_AZ_TX_DESCQ_EN, 1,\r\nFRF_AZ_TX_ISCSI_DDIG_EN, 0,\r\nFRF_AZ_TX_ISCSI_HDIG_EN, 0,\r\nFRF_AZ_TX_DESCQ_BUF_BASE_ID, tx_queue->txd.index,\r\nFRF_AZ_TX_DESCQ_EVQ_ID,\r\ntx_queue->channel->channel,\r\nFRF_AZ_TX_DESCQ_OWNER_ID, 0,\r\nFRF_AZ_TX_DESCQ_LABEL, tx_queue->queue,\r\nFRF_AZ_TX_DESCQ_SIZE,\r\n__ffs(tx_queue->txd.entries),\r\nFRF_AZ_TX_DESCQ_TYPE, 0,\r\nFRF_BZ_TX_NON_IP_DROP_DIS, 1);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nint csum = tx_queue->queue & EFX_TXQ_TYPE_OFFLOAD;\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_TX_IP_CHKSM_DIS, !csum);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_TX_TCP_CHKSM_DIS,\r\n!csum);\r\n}\r\nefx_writeo_table(efx, &reg, efx->type->txd_ptr_tbl_base,\r\ntx_queue->queue);\r\nif (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {\r\nBUILD_BUG_ON(EFX_MAX_TX_QUEUES > 128);\r\nefx_reado(efx, &reg, FR_AA_TX_CHKSM_CFG);\r\nif (tx_queue->queue & EFX_TXQ_TYPE_OFFLOAD)\r\nclear_bit_le(tx_queue->queue, (void *)&reg);\r\nelse\r\nset_bit_le(tx_queue->queue, (void *)&reg);\r\nefx_writeo(efx, &reg, FR_AA_TX_CHKSM_CFG);\r\n}\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nEFX_POPULATE_OWORD_1(reg,\r\nFRF_BZ_TX_PACE,\r\n(tx_queue->queue & EFX_TXQ_TYPE_HIGHPRI) ?\r\nFFE_BZ_TX_PACE_OFF :\r\nFFE_BZ_TX_PACE_RESERVED);\r\nefx_writeo_table(efx, &reg, FR_BZ_TX_PACE_TBL,\r\ntx_queue->queue);\r\n}\r\n}\r\nstatic void efx_flush_tx_queue(struct efx_tx_queue *tx_queue)\r\n{\r\nstruct efx_nic *efx = tx_queue->efx;\r\nefx_oword_t tx_flush_descq;\r\nEFX_POPULATE_OWORD_2(tx_flush_descq,\r\nFRF_AZ_TX_FLUSH_DESCQ_CMD, 1,\r\nFRF_AZ_TX_FLUSH_DESCQ, tx_queue->queue);\r\nefx_writeo(efx, &tx_flush_descq, FR_AZ_TX_FLUSH_DESCQ);\r\n}\r\nvoid efx_nic_fini_tx(struct efx_tx_queue *tx_queue)\r\n{\r\nstruct efx_nic *efx = tx_queue->efx;\r\nefx_oword_t tx_desc_ptr;\r\nEFX_ZERO_OWORD(tx_desc_ptr);\r\nefx_writeo_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,\r\ntx_queue->queue);\r\nefx_fini_special_buffer(efx, &tx_queue->txd);\r\n}\r\nvoid efx_nic_remove_tx(struct efx_tx_queue *tx_queue)\r\n{\r\nefx_free_special_buffer(tx_queue->efx, &tx_queue->txd);\r\n}\r\nstatic inline efx_qword_t *\r\nefx_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)\r\n{\r\nreturn ((efx_qword_t *) (rx_queue->rxd.addr)) + index;\r\n}\r\nstatic inline void\r\nefx_build_rx_desc(struct efx_rx_queue *rx_queue, unsigned index)\r\n{\r\nstruct efx_rx_buffer *rx_buf;\r\nefx_qword_t *rxd;\r\nrxd = efx_rx_desc(rx_queue, index);\r\nrx_buf = efx_rx_buffer(rx_queue, index);\r\nEFX_POPULATE_QWORD_3(*rxd,\r\nFSF_AZ_RX_KER_BUF_SIZE,\r\nrx_buf->len -\r\nrx_queue->efx->type->rx_buffer_padding,\r\nFSF_AZ_RX_KER_BUF_REGION, 0,\r\nFSF_AZ_RX_KER_BUF_ADDR, rx_buf->dma_addr);\r\n}\r\nvoid efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue)\r\n{\r\nstruct efx_nic *efx = rx_queue->efx;\r\nefx_dword_t reg;\r\nunsigned write_ptr;\r\nwhile (rx_queue->notified_count != rx_queue->added_count) {\r\nefx_build_rx_desc(\r\nrx_queue,\r\nrx_queue->notified_count & rx_queue->ptr_mask);\r\n++rx_queue->notified_count;\r\n}\r\nwmb();\r\nwrite_ptr = rx_queue->added_count & rx_queue->ptr_mask;\r\nEFX_POPULATE_DWORD_1(reg, FRF_AZ_RX_DESC_WPTR_DWORD, write_ptr);\r\nefx_writed_page(efx, &reg, FR_AZ_RX_DESC_UPD_DWORD_P0,\r\nefx_rx_queue_index(rx_queue));\r\n}\r\nint efx_nic_probe_rx(struct efx_rx_queue *rx_queue)\r\n{\r\nstruct efx_nic *efx = rx_queue->efx;\r\nunsigned entries;\r\nentries = rx_queue->ptr_mask + 1;\r\nreturn efx_alloc_special_buffer(efx, &rx_queue->rxd,\r\nentries * sizeof(efx_qword_t));\r\n}\r\nvoid efx_nic_init_rx(struct efx_rx_queue *rx_queue)\r\n{\r\nefx_oword_t rx_desc_ptr;\r\nstruct efx_nic *efx = rx_queue->efx;\r\nbool is_b0 = efx_nic_rev(efx) >= EFX_REV_FALCON_B0;\r\nbool iscsi_digest_en = is_b0;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"RX queue %d ring in special buffers %d-%d\n",\r\nefx_rx_queue_index(rx_queue), rx_queue->rxd.index,\r\nrx_queue->rxd.index + rx_queue->rxd.entries - 1);\r\nefx_init_special_buffer(efx, &rx_queue->rxd);\r\nEFX_POPULATE_OWORD_10(rx_desc_ptr,\r\nFRF_AZ_RX_ISCSI_DDIG_EN, iscsi_digest_en,\r\nFRF_AZ_RX_ISCSI_HDIG_EN, iscsi_digest_en,\r\nFRF_AZ_RX_DESCQ_BUF_BASE_ID, rx_queue->rxd.index,\r\nFRF_AZ_RX_DESCQ_EVQ_ID,\r\nefx_rx_queue_channel(rx_queue)->channel,\r\nFRF_AZ_RX_DESCQ_OWNER_ID, 0,\r\nFRF_AZ_RX_DESCQ_LABEL,\r\nefx_rx_queue_index(rx_queue),\r\nFRF_AZ_RX_DESCQ_SIZE,\r\n__ffs(rx_queue->rxd.entries),\r\nFRF_AZ_RX_DESCQ_TYPE, 0 ,\r\nFRF_AZ_RX_DESCQ_JUMBO, !is_b0,\r\nFRF_AZ_RX_DESCQ_EN, 1);\r\nefx_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,\r\nefx_rx_queue_index(rx_queue));\r\n}\r\nstatic void efx_flush_rx_queue(struct efx_rx_queue *rx_queue)\r\n{\r\nstruct efx_nic *efx = rx_queue->efx;\r\nefx_oword_t rx_flush_descq;\r\nEFX_POPULATE_OWORD_2(rx_flush_descq,\r\nFRF_AZ_RX_FLUSH_DESCQ_CMD, 1,\r\nFRF_AZ_RX_FLUSH_DESCQ,\r\nefx_rx_queue_index(rx_queue));\r\nefx_writeo(efx, &rx_flush_descq, FR_AZ_RX_FLUSH_DESCQ);\r\n}\r\nvoid efx_nic_fini_rx(struct efx_rx_queue *rx_queue)\r\n{\r\nefx_oword_t rx_desc_ptr;\r\nstruct efx_nic *efx = rx_queue->efx;\r\nEFX_ZERO_OWORD(rx_desc_ptr);\r\nefx_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,\r\nefx_rx_queue_index(rx_queue));\r\nefx_fini_special_buffer(efx, &rx_queue->rxd);\r\n}\r\nvoid efx_nic_remove_rx(struct efx_rx_queue *rx_queue)\r\n{\r\nefx_free_special_buffer(rx_queue->efx, &rx_queue->rxd);\r\n}\r\nstatic bool efx_flush_wake(struct efx_nic *efx)\r\n{\r\nsmp_mb();\r\nreturn (atomic_read(&efx->drain_pending) == 0 ||\r\n(atomic_read(&efx->rxq_flush_outstanding) < EFX_RX_FLUSH_COUNT\r\n&& atomic_read(&efx->rxq_flush_pending) > 0));\r\n}\r\nint efx_nic_flush_queues(struct efx_nic *efx)\r\n{\r\nunsigned timeout = msecs_to_jiffies(5000);\r\nstruct efx_channel *channel;\r\nstruct efx_rx_queue *rx_queue;\r\nstruct efx_tx_queue *tx_queue;\r\nint rc = 0;\r\nefx->fc_disable++;\r\nefx->type->prepare_flush(efx);\r\nefx_for_each_channel(channel, efx) {\r\nefx_for_each_channel_tx_queue(tx_queue, channel) {\r\natomic_inc(&efx->drain_pending);\r\nefx_flush_tx_queue(tx_queue);\r\n}\r\nefx_for_each_channel_rx_queue(rx_queue, channel) {\r\natomic_inc(&efx->drain_pending);\r\nrx_queue->flush_pending = true;\r\natomic_inc(&efx->rxq_flush_pending);\r\n}\r\n}\r\nwhile (timeout && atomic_read(&efx->drain_pending) > 0) {\r\nif (efx_sriov_enabled(efx)) {\r\nrc = efx_mcdi_flush_rxqs(efx);\r\nif (!rc)\r\ngoto wait;\r\n}\r\nefx_for_each_channel(channel, efx) {\r\nefx_for_each_channel_rx_queue(rx_queue, channel) {\r\nif (atomic_read(&efx->rxq_flush_outstanding) >=\r\nEFX_RX_FLUSH_COUNT)\r\nbreak;\r\nif (rx_queue->flush_pending) {\r\nrx_queue->flush_pending = false;\r\natomic_dec(&efx->rxq_flush_pending);\r\natomic_inc(&efx->rxq_flush_outstanding);\r\nefx_flush_rx_queue(rx_queue);\r\n}\r\n}\r\n}\r\nwait:\r\ntimeout = wait_event_timeout(efx->flush_wq, efx_flush_wake(efx),\r\ntimeout);\r\n}\r\nif (atomic_read(&efx->drain_pending)) {\r\nnetif_err(efx, hw, efx->net_dev, "failed to flush %d queues "\r\n"(rx %d+%d)\n", atomic_read(&efx->drain_pending),\r\natomic_read(&efx->rxq_flush_outstanding),\r\natomic_read(&efx->rxq_flush_pending));\r\nrc = -ETIMEDOUT;\r\natomic_set(&efx->drain_pending, 0);\r\natomic_set(&efx->rxq_flush_pending, 0);\r\natomic_set(&efx->rxq_flush_outstanding, 0);\r\n}\r\nefx->fc_disable--;\r\nreturn rc;\r\n}\r\nvoid efx_nic_eventq_read_ack(struct efx_channel *channel)\r\n{\r\nefx_dword_t reg;\r\nstruct efx_nic *efx = channel->efx;\r\nEFX_POPULATE_DWORD_1(reg, FRF_AZ_EVQ_RPTR,\r\nchannel->eventq_read_ptr & channel->eventq_mask);\r\nefx_writed_table(efx, &reg, efx->type->evq_rptr_tbl_base,\r\nchannel->channel);\r\n}\r\nvoid efx_generate_event(struct efx_nic *efx, unsigned int evq,\r\nefx_qword_t *event)\r\n{\r\nefx_oword_t drv_ev_reg;\r\nBUILD_BUG_ON(FRF_AZ_DRV_EV_DATA_LBN != 0 ||\r\nFRF_AZ_DRV_EV_DATA_WIDTH != 64);\r\ndrv_ev_reg.u32[0] = event->u32[0];\r\ndrv_ev_reg.u32[1] = event->u32[1];\r\ndrv_ev_reg.u32[2] = 0;\r\ndrv_ev_reg.u32[3] = 0;\r\nEFX_SET_OWORD_FIELD(drv_ev_reg, FRF_AZ_DRV_EV_QID, evq);\r\nefx_writeo(efx, &drv_ev_reg, FR_AZ_DRV_EV);\r\n}\r\nstatic void efx_magic_event(struct efx_channel *channel, u32 magic)\r\n{\r\nefx_qword_t event;\r\nEFX_POPULATE_QWORD_2(event, FSF_AZ_EV_CODE,\r\nFSE_AZ_EV_CODE_DRV_GEN_EV,\r\nFSF_AZ_DRV_GEN_EV_MAGIC, magic);\r\nefx_generate_event(channel->efx, channel->channel, &event);\r\n}\r\nstatic int\r\nefx_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)\r\n{\r\nunsigned int tx_ev_desc_ptr;\r\nunsigned int tx_ev_q_label;\r\nstruct efx_tx_queue *tx_queue;\r\nstruct efx_nic *efx = channel->efx;\r\nint tx_packets = 0;\r\nif (unlikely(ACCESS_ONCE(efx->reset_pending)))\r\nreturn 0;\r\nif (likely(EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_COMP))) {\r\ntx_ev_desc_ptr = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_DESC_PTR);\r\ntx_ev_q_label = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);\r\ntx_queue = efx_channel_get_tx_queue(\r\nchannel, tx_ev_q_label % EFX_TXQ_TYPES);\r\ntx_packets = ((tx_ev_desc_ptr - tx_queue->read_count) &\r\ntx_queue->ptr_mask);\r\nefx_xmit_done(tx_queue, tx_ev_desc_ptr);\r\n} else if (EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_WQ_FF_FULL)) {\r\ntx_ev_q_label = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);\r\ntx_queue = efx_channel_get_tx_queue(\r\nchannel, tx_ev_q_label % EFX_TXQ_TYPES);\r\nnetif_tx_lock(efx->net_dev);\r\nefx_notify_tx_desc(tx_queue);\r\nnetif_tx_unlock(efx->net_dev);\r\n} else if (EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_PKT_ERR) &&\r\nEFX_WORKAROUND_10727(efx)) {\r\nefx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);\r\n} else {\r\nnetif_err(efx, tx_err, efx->net_dev,\r\n"channel %d unexpected TX event "\r\nEFX_QWORD_FMT"\n", channel->channel,\r\nEFX_QWORD_VAL(*event));\r\n}\r\nreturn tx_packets;\r\n}\r\nstatic u16 efx_handle_rx_not_ok(struct efx_rx_queue *rx_queue,\r\nconst efx_qword_t *event)\r\n{\r\nstruct efx_channel *channel = efx_rx_queue_channel(rx_queue);\r\nstruct efx_nic *efx = rx_queue->efx;\r\nbool rx_ev_buf_owner_id_err, rx_ev_ip_hdr_chksum_err;\r\nbool rx_ev_tcp_udp_chksum_err, rx_ev_eth_crc_err;\r\nbool rx_ev_frm_trunc, rx_ev_drib_nib, rx_ev_tobe_disc;\r\nbool rx_ev_other_err, rx_ev_pause_frm;\r\nbool rx_ev_hdr_type, rx_ev_mcast_pkt;\r\nunsigned rx_ev_pkt_type;\r\nrx_ev_hdr_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);\r\nrx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);\r\nrx_ev_tobe_disc = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_TOBE_DISC);\r\nrx_ev_pkt_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_TYPE);\r\nrx_ev_buf_owner_id_err = EFX_QWORD_FIELD(*event,\r\nFSF_AZ_RX_EV_BUF_OWNER_ID_ERR);\r\nrx_ev_ip_hdr_chksum_err = EFX_QWORD_FIELD(*event,\r\nFSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR);\r\nrx_ev_tcp_udp_chksum_err = EFX_QWORD_FIELD(*event,\r\nFSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR);\r\nrx_ev_eth_crc_err = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_ETH_CRC_ERR);\r\nrx_ev_frm_trunc = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_FRM_TRUNC);\r\nrx_ev_drib_nib = ((efx_nic_rev(efx) >= EFX_REV_FALCON_B0) ?\r\n0 : EFX_QWORD_FIELD(*event, FSF_AA_RX_EV_DRIB_NIB));\r\nrx_ev_pause_frm = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PAUSE_FRM_ERR);\r\nrx_ev_other_err = (rx_ev_drib_nib | rx_ev_tcp_udp_chksum_err |\r\nrx_ev_buf_owner_id_err | rx_ev_eth_crc_err |\r\nrx_ev_frm_trunc | rx_ev_ip_hdr_chksum_err);\r\nif (rx_ev_frm_trunc)\r\n++channel->n_rx_frm_trunc;\r\nelse if (rx_ev_tobe_disc)\r\n++channel->n_rx_tobe_disc;\r\nelse if (!efx->loopback_selftest) {\r\nif (rx_ev_ip_hdr_chksum_err)\r\n++channel->n_rx_ip_hdr_chksum_err;\r\nelse if (rx_ev_tcp_udp_chksum_err)\r\n++channel->n_rx_tcp_udp_chksum_err;\r\n}\r\n#ifdef DEBUG\r\nif (rx_ev_other_err && net_ratelimit()) {\r\nnetif_dbg(efx, rx_err, efx->net_dev,\r\n" RX queue %d unexpected RX event "\r\nEFX_QWORD_FMT "%s%s%s%s%s%s%s%s\n",\r\nefx_rx_queue_index(rx_queue), EFX_QWORD_VAL(*event),\r\nrx_ev_buf_owner_id_err ? " [OWNER_ID_ERR]" : "",\r\nrx_ev_ip_hdr_chksum_err ?\r\n" [IP_HDR_CHKSUM_ERR]" : "",\r\nrx_ev_tcp_udp_chksum_err ?\r\n" [TCP_UDP_CHKSUM_ERR]" : "",\r\nrx_ev_eth_crc_err ? " [ETH_CRC_ERR]" : "",\r\nrx_ev_frm_trunc ? " [FRM_TRUNC]" : "",\r\nrx_ev_drib_nib ? " [DRIB_NIB]" : "",\r\nrx_ev_tobe_disc ? " [TOBE_DISC]" : "",\r\nrx_ev_pause_frm ? " [PAUSE]" : "");\r\n}\r\n#endif\r\nreturn (rx_ev_eth_crc_err | rx_ev_frm_trunc | rx_ev_drib_nib |\r\nrx_ev_tobe_disc | rx_ev_pause_frm) ?\r\nEFX_RX_PKT_DISCARD : 0;\r\n}\r\nstatic void\r\nefx_handle_rx_bad_index(struct efx_rx_queue *rx_queue, unsigned index)\r\n{\r\nstruct efx_nic *efx = rx_queue->efx;\r\nunsigned expected, dropped;\r\nexpected = rx_queue->removed_count & rx_queue->ptr_mask;\r\ndropped = (index - expected) & rx_queue->ptr_mask;\r\nnetif_info(efx, rx_err, efx->net_dev,\r\n"dropped %d events (index=%d expected=%d)\n",\r\ndropped, index, expected);\r\nefx_schedule_reset(efx, EFX_WORKAROUND_5676(efx) ?\r\nRESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);\r\n}\r\nstatic void\r\nefx_handle_rx_event(struct efx_channel *channel, const efx_qword_t *event)\r\n{\r\nunsigned int rx_ev_desc_ptr, rx_ev_byte_cnt;\r\nunsigned int rx_ev_hdr_type, rx_ev_mcast_pkt;\r\nunsigned expected_ptr;\r\nbool rx_ev_pkt_ok;\r\nu16 flags;\r\nstruct efx_rx_queue *rx_queue;\r\nstruct efx_nic *efx = channel->efx;\r\nif (unlikely(ACCESS_ONCE(efx->reset_pending)))\r\nreturn;\r\nrx_ev_byte_cnt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_BYTE_CNT);\r\nrx_ev_pkt_ok = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_OK);\r\nrx_ev_hdr_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);\r\nWARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_JUMBO_CONT));\r\nWARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_SOP) != 1);\r\nWARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_Q_LABEL) !=\r\nchannel->channel);\r\nrx_queue = efx_channel_get_rx_queue(channel);\r\nrx_ev_desc_ptr = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_DESC_PTR);\r\nexpected_ptr = rx_queue->removed_count & rx_queue->ptr_mask;\r\nif (unlikely(rx_ev_desc_ptr != expected_ptr))\r\nefx_handle_rx_bad_index(rx_queue, rx_ev_desc_ptr);\r\nif (likely(rx_ev_pkt_ok)) {\r\nflags = (rx_ev_hdr_type == FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP ||\r\nrx_ev_hdr_type == FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP) ?\r\nEFX_RX_PKT_CSUMMED : 0;\r\n} else {\r\nflags = efx_handle_rx_not_ok(rx_queue, event);\r\n}\r\nrx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);\r\nif (rx_ev_mcast_pkt) {\r\nunsigned int rx_ev_mcast_hash_match =\r\nEFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_HASH_MATCH);\r\nif (unlikely(!rx_ev_mcast_hash_match)) {\r\n++channel->n_rx_mcast_mismatch;\r\nflags |= EFX_RX_PKT_DISCARD;\r\n}\r\n}\r\nchannel->irq_mod_score += 2;\r\nefx_rx_packet(rx_queue, rx_ev_desc_ptr, rx_ev_byte_cnt, flags);\r\n}\r\nstatic void\r\nefx_handle_tx_flush_done(struct efx_nic *efx, efx_qword_t *event)\r\n{\r\nstruct efx_tx_queue *tx_queue;\r\nint qid;\r\nqid = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);\r\nif (qid < EFX_TXQ_TYPES * efx->n_tx_channels) {\r\ntx_queue = efx_get_tx_queue(efx, qid / EFX_TXQ_TYPES,\r\nqid % EFX_TXQ_TYPES);\r\nefx_magic_event(tx_queue->channel,\r\nEFX_CHANNEL_MAGIC_TX_DRAIN(tx_queue));\r\n}\r\n}\r\nstatic void\r\nefx_handle_rx_flush_done(struct efx_nic *efx, efx_qword_t *event)\r\n{\r\nstruct efx_channel *channel;\r\nstruct efx_rx_queue *rx_queue;\r\nint qid;\r\nbool failed;\r\nqid = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_DESCQ_ID);\r\nfailed = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL);\r\nif (qid >= efx->n_channels)\r\nreturn;\r\nchannel = efx_get_channel(efx, qid);\r\nif (!efx_channel_has_rx_queue(channel))\r\nreturn;\r\nrx_queue = efx_channel_get_rx_queue(channel);\r\nif (failed) {\r\nnetif_info(efx, hw, efx->net_dev,\r\n"RXQ %d flush retry\n", qid);\r\nrx_queue->flush_pending = true;\r\natomic_inc(&efx->rxq_flush_pending);\r\n} else {\r\nefx_magic_event(efx_rx_queue_channel(rx_queue),\r\nEFX_CHANNEL_MAGIC_RX_DRAIN(rx_queue));\r\n}\r\natomic_dec(&efx->rxq_flush_outstanding);\r\nif (efx_flush_wake(efx))\r\nwake_up(&efx->flush_wq);\r\n}\r\nstatic void\r\nefx_handle_drain_event(struct efx_channel *channel)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nWARN_ON(atomic_read(&efx->drain_pending) == 0);\r\natomic_dec(&efx->drain_pending);\r\nif (efx_flush_wake(efx))\r\nwake_up(&efx->flush_wq);\r\n}\r\nstatic void\r\nefx_handle_generated_event(struct efx_channel *channel, efx_qword_t *event)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nstruct efx_rx_queue *rx_queue =\r\nefx_channel_has_rx_queue(channel) ?\r\nefx_channel_get_rx_queue(channel) : NULL;\r\nunsigned magic, code;\r\nmagic = EFX_QWORD_FIELD(*event, FSF_AZ_DRV_GEN_EV_MAGIC);\r\ncode = _EFX_CHANNEL_MAGIC_CODE(magic);\r\nif (magic == EFX_CHANNEL_MAGIC_TEST(channel)) {\r\nchannel->event_test_cpu = raw_smp_processor_id();\r\n} else if (rx_queue && magic == EFX_CHANNEL_MAGIC_FILL(rx_queue)) {\r\nefx_fast_push_rx_descriptors(rx_queue);\r\n} else if (rx_queue && magic == EFX_CHANNEL_MAGIC_RX_DRAIN(rx_queue)) {\r\nrx_queue->enabled = false;\r\nefx_handle_drain_event(channel);\r\n} else if (code == _EFX_CHANNEL_MAGIC_TX_DRAIN) {\r\nefx_handle_drain_event(channel);\r\n} else {\r\nnetif_dbg(efx, hw, efx->net_dev, "channel %d received "\r\n"generated event "EFX_QWORD_FMT"\n",\r\nchannel->channel, EFX_QWORD_VAL(*event));\r\n}\r\n}\r\nstatic void\r\nefx_handle_driver_event(struct efx_channel *channel, efx_qword_t *event)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nunsigned int ev_sub_code;\r\nunsigned int ev_sub_data;\r\nev_sub_code = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBCODE);\r\nev_sub_data = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);\r\nswitch (ev_sub_code) {\r\ncase FSE_AZ_TX_DESCQ_FLS_DONE_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev, "channel %d TXQ %d flushed\n",\r\nchannel->channel, ev_sub_data);\r\nefx_handle_tx_flush_done(efx, event);\r\nefx_sriov_tx_flush_done(efx, event);\r\nbreak;\r\ncase FSE_AZ_RX_DESCQ_FLS_DONE_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev, "channel %d RXQ %d flushed\n",\r\nchannel->channel, ev_sub_data);\r\nefx_handle_rx_flush_done(efx, event);\r\nefx_sriov_rx_flush_done(efx, event);\r\nbreak;\r\ncase FSE_AZ_EVQ_INIT_DONE_EV:\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"channel %d EVQ %d initialised\n",\r\nchannel->channel, ev_sub_data);\r\nbreak;\r\ncase FSE_AZ_SRM_UPD_DONE_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d SRAM update done\n", channel->channel);\r\nbreak;\r\ncase FSE_AZ_WAKE_UP_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d RXQ %d wakeup event\n",\r\nchannel->channel, ev_sub_data);\r\nbreak;\r\ncase FSE_AZ_TIMER_EV:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d RX queue %d timer expired\n",\r\nchannel->channel, ev_sub_data);\r\nbreak;\r\ncase FSE_AA_RX_RECOVER_EV:\r\nnetif_err(efx, rx_err, efx->net_dev,\r\n"channel %d seen DRIVER RX_RESET event. "\r\n"Resetting.\n", channel->channel);\r\natomic_inc(&efx->rx_reset);\r\nefx_schedule_reset(efx,\r\nEFX_WORKAROUND_6555(efx) ?\r\nRESET_TYPE_RX_RECOVERY :\r\nRESET_TYPE_DISABLE);\r\nbreak;\r\ncase FSE_BZ_RX_DSC_ERROR_EV:\r\nif (ev_sub_data < EFX_VI_BASE) {\r\nnetif_err(efx, rx_err, efx->net_dev,\r\n"RX DMA Q %d reports descriptor fetch error."\r\n" RX Q %d is disabled.\n", ev_sub_data,\r\nev_sub_data);\r\nefx_schedule_reset(efx, RESET_TYPE_RX_DESC_FETCH);\r\n} else\r\nefx_sriov_desc_fetch_err(efx, ev_sub_data);\r\nbreak;\r\ncase FSE_BZ_TX_DSC_ERROR_EV:\r\nif (ev_sub_data < EFX_VI_BASE) {\r\nnetif_err(efx, tx_err, efx->net_dev,\r\n"TX DMA Q %d reports descriptor fetch error."\r\n" TX Q %d is disabled.\n", ev_sub_data,\r\nev_sub_data);\r\nefx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);\r\n} else\r\nefx_sriov_desc_fetch_err(efx, ev_sub_data);\r\nbreak;\r\ndefault:\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"channel %d unknown driver event code %d "\r\n"data %04x\n", channel->channel, ev_sub_code,\r\nev_sub_data);\r\nbreak;\r\n}\r\n}\r\nint efx_nic_process_eventq(struct efx_channel *channel, int budget)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nunsigned int read_ptr;\r\nefx_qword_t event, *p_event;\r\nint ev_code;\r\nint tx_packets = 0;\r\nint spent = 0;\r\nread_ptr = channel->eventq_read_ptr;\r\nfor (;;) {\r\np_event = efx_event(channel, read_ptr);\r\nevent = *p_event;\r\nif (!efx_event_present(&event))\r\nbreak;\r\nnetif_vdbg(channel->efx, intr, channel->efx->net_dev,\r\n"channel %d event is "EFX_QWORD_FMT"\n",\r\nchannel->channel, EFX_QWORD_VAL(event));\r\nEFX_SET_QWORD(*p_event);\r\n++read_ptr;\r\nev_code = EFX_QWORD_FIELD(event, FSF_AZ_EV_CODE);\r\nswitch (ev_code) {\r\ncase FSE_AZ_EV_CODE_RX_EV:\r\nefx_handle_rx_event(channel, &event);\r\nif (++spent == budget)\r\ngoto out;\r\nbreak;\r\ncase FSE_AZ_EV_CODE_TX_EV:\r\ntx_packets += efx_handle_tx_event(channel, &event);\r\nif (tx_packets > efx->txq_entries) {\r\nspent = budget;\r\ngoto out;\r\n}\r\nbreak;\r\ncase FSE_AZ_EV_CODE_DRV_GEN_EV:\r\nefx_handle_generated_event(channel, &event);\r\nbreak;\r\ncase FSE_AZ_EV_CODE_DRIVER_EV:\r\nefx_handle_driver_event(channel, &event);\r\nbreak;\r\ncase FSE_CZ_EV_CODE_USER_EV:\r\nefx_sriov_event(channel, &event);\r\nbreak;\r\ncase FSE_CZ_EV_CODE_MCDI_EV:\r\nefx_mcdi_process_event(channel, &event);\r\nbreak;\r\ncase FSE_AZ_EV_CODE_GLOBAL_EV:\r\nif (efx->type->handle_global_event &&\r\nefx->type->handle_global_event(channel, &event))\r\nbreak;\r\ndefault:\r\nnetif_err(channel->efx, hw, channel->efx->net_dev,\r\n"channel %d unknown event type %d (data "\r\nEFX_QWORD_FMT ")\n", channel->channel,\r\nev_code, EFX_QWORD_VAL(event));\r\n}\r\n}\r\nout:\r\nchannel->eventq_read_ptr = read_ptr;\r\nreturn spent;\r\n}\r\nbool efx_nic_event_present(struct efx_channel *channel)\r\n{\r\nreturn efx_event_present(efx_event(channel, channel->eventq_read_ptr));\r\n}\r\nint efx_nic_probe_eventq(struct efx_channel *channel)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nunsigned entries;\r\nentries = channel->eventq_mask + 1;\r\nreturn efx_alloc_special_buffer(efx, &channel->eventq,\r\nentries * sizeof(efx_qword_t));\r\n}\r\nvoid efx_nic_init_eventq(struct efx_channel *channel)\r\n{\r\nefx_oword_t reg;\r\nstruct efx_nic *efx = channel->efx;\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"channel %d event queue in special buffers %d-%d\n",\r\nchannel->channel, channel->eventq.index,\r\nchannel->eventq.index + channel->eventq.entries - 1);\r\nif (efx_nic_rev(efx) >= EFX_REV_SIENA_A0) {\r\nEFX_POPULATE_OWORD_3(reg,\r\nFRF_CZ_TIMER_Q_EN, 1,\r\nFRF_CZ_HOST_NOTIFY_MODE, 0,\r\nFRF_CZ_TIMER_MODE, FFE_CZ_TIMER_MODE_DIS);\r\nefx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, channel->channel);\r\n}\r\nefx_init_special_buffer(efx, &channel->eventq);\r\nmemset(channel->eventq.addr, 0xff, channel->eventq.len);\r\nEFX_POPULATE_OWORD_3(reg,\r\nFRF_AZ_EVQ_EN, 1,\r\nFRF_AZ_EVQ_SIZE, __ffs(channel->eventq.entries),\r\nFRF_AZ_EVQ_BUF_BASE_ID, channel->eventq.index);\r\nefx_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,\r\nchannel->channel);\r\nefx->type->push_irq_moderation(channel);\r\n}\r\nvoid efx_nic_fini_eventq(struct efx_channel *channel)\r\n{\r\nefx_oword_t reg;\r\nstruct efx_nic *efx = channel->efx;\r\nEFX_ZERO_OWORD(reg);\r\nefx_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,\r\nchannel->channel);\r\nif (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)\r\nefx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, channel->channel);\r\nefx_fini_special_buffer(efx, &channel->eventq);\r\n}\r\nvoid efx_nic_remove_eventq(struct efx_channel *channel)\r\n{\r\nefx_free_special_buffer(channel->efx, &channel->eventq);\r\n}\r\nvoid efx_nic_event_test_start(struct efx_channel *channel)\r\n{\r\nchannel->event_test_cpu = -1;\r\nsmp_wmb();\r\nefx_magic_event(channel, EFX_CHANNEL_MAGIC_TEST(channel));\r\n}\r\nvoid efx_nic_generate_fill_event(struct efx_rx_queue *rx_queue)\r\n{\r\nefx_magic_event(efx_rx_queue_channel(rx_queue),\r\nEFX_CHANNEL_MAGIC_FILL(rx_queue));\r\n}\r\nstatic inline void efx_nic_interrupts(struct efx_nic *efx,\r\nbool enabled, bool force)\r\n{\r\nefx_oword_t int_en_reg_ker;\r\nEFX_POPULATE_OWORD_3(int_en_reg_ker,\r\nFRF_AZ_KER_INT_LEVE_SEL, efx->irq_level,\r\nFRF_AZ_KER_INT_KER, force,\r\nFRF_AZ_DRV_INT_EN_KER, enabled);\r\nefx_writeo(efx, &int_en_reg_ker, FR_AZ_INT_EN_KER);\r\n}\r\nvoid efx_nic_enable_interrupts(struct efx_nic *efx)\r\n{\r\nEFX_ZERO_OWORD(*((efx_oword_t *) efx->irq_status.addr));\r\nwmb();\r\nefx_nic_interrupts(efx, true, false);\r\n}\r\nvoid efx_nic_disable_interrupts(struct efx_nic *efx)\r\n{\r\nefx_nic_interrupts(efx, false, false);\r\n}\r\nvoid efx_nic_irq_test_start(struct efx_nic *efx)\r\n{\r\nefx->last_irq_cpu = -1;\r\nsmp_wmb();\r\nefx_nic_interrupts(efx, true, true);\r\n}\r\nirqreturn_t efx_nic_fatal_interrupt(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t *int_ker = efx->irq_status.addr;\r\nefx_oword_t fatal_intr;\r\nint error, mem_perr;\r\nefx_reado(efx, &fatal_intr, FR_AZ_FATAL_INTR_KER);\r\nerror = EFX_OWORD_FIELD(fatal_intr, FRF_AZ_FATAL_INTR);\r\nnetif_err(efx, hw, efx->net_dev, "SYSTEM ERROR "EFX_OWORD_FMT" status "\r\nEFX_OWORD_FMT ": %s\n", EFX_OWORD_VAL(*int_ker),\r\nEFX_OWORD_VAL(fatal_intr),\r\nerror ? "disabling bus mastering" : "no recognised error");\r\nmem_perr = (EFX_OWORD_FIELD(fatal_intr, FRF_AZ_MEM_PERR_INT_KER) ||\r\nEFX_OWORD_FIELD(fatal_intr, FRF_AZ_SRM_PERR_INT_KER));\r\nif (mem_perr) {\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AZ_MEM_STAT);\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SYSTEM ERROR: memory parity error "EFX_OWORD_FMT"\n",\r\nEFX_OWORD_VAL(reg));\r\n}\r\npci_clear_master(efx->pci_dev);\r\nif (efx_nic_is_dual_func(efx))\r\npci_clear_master(nic_data->pci_dev2);\r\nefx_nic_disable_interrupts(efx);\r\nif (efx->int_error_count == 0 ||\r\ntime_after(jiffies, efx->int_error_expire)) {\r\nefx->int_error_count = 0;\r\nefx->int_error_expire =\r\njiffies + EFX_INT_ERROR_EXPIRE * HZ;\r\n}\r\nif (++efx->int_error_count < EFX_MAX_INT_ERRORS) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SYSTEM ERROR - reset scheduled\n");\r\nefx_schedule_reset(efx, RESET_TYPE_INT_ERROR);\r\n} else {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SYSTEM ERROR - max number of errors seen."\r\n"NIC will be disabled\n");\r\nefx_schedule_reset(efx, RESET_TYPE_DISABLE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t efx_legacy_interrupt(int irq, void *dev_id)\r\n{\r\nstruct efx_nic *efx = dev_id;\r\nefx_oword_t *int_ker = efx->irq_status.addr;\r\nirqreturn_t result = IRQ_NONE;\r\nstruct efx_channel *channel;\r\nefx_dword_t reg;\r\nu32 queues;\r\nint syserr;\r\nif (!efx->legacy_irq_enabled)\r\nreturn result;\r\nefx_readd(efx, &reg, FR_BZ_INT_ISR0);\r\nqueues = EFX_EXTRACT_DWORD(reg, 0, 31);\r\nif (queues & (1U << efx->irq_level)) {\r\nsyserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);\r\nif (unlikely(syserr))\r\nreturn efx_nic_fatal_interrupt(efx);\r\nefx->last_irq_cpu = raw_smp_processor_id();\r\n}\r\nif (queues != 0) {\r\nif (EFX_WORKAROUND_15783(efx))\r\nefx->irq_zero_count = 0;\r\nefx_for_each_channel(channel, efx) {\r\nif (queues & 1)\r\nefx_schedule_channel_irq(channel);\r\nqueues >>= 1;\r\n}\r\nresult = IRQ_HANDLED;\r\n} else if (EFX_WORKAROUND_15783(efx)) {\r\nefx_qword_t *event;\r\nif (efx->irq_zero_count++ == 0)\r\nresult = IRQ_HANDLED;\r\nefx_for_each_channel(channel, efx) {\r\nevent = efx_event(channel, channel->eventq_read_ptr);\r\nif (efx_event_present(event))\r\nefx_schedule_channel_irq(channel);\r\nelse\r\nefx_nic_eventq_read_ack(channel);\r\n}\r\n}\r\nif (result == IRQ_HANDLED)\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d status " EFX_DWORD_FMT "\n",\r\nirq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));\r\nreturn result;\r\n}\r\nstatic irqreturn_t efx_msi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct efx_channel *channel = *(struct efx_channel **)dev_id;\r\nstruct efx_nic *efx = channel->efx;\r\nefx_oword_t *int_ker = efx->irq_status.addr;\r\nint syserr;\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",\r\nirq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));\r\nif (channel->channel == efx->irq_level) {\r\nsyserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);\r\nif (unlikely(syserr))\r\nreturn efx_nic_fatal_interrupt(efx);\r\nefx->last_irq_cpu = raw_smp_processor_id();\r\n}\r\nefx_schedule_channel_irq(channel);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid efx_nic_push_rx_indir_table(struct efx_nic *efx)\r\n{\r\nsize_t i = 0;\r\nefx_dword_t dword;\r\nif (efx_nic_rev(efx) < EFX_REV_FALCON_B0)\r\nreturn;\r\nBUILD_BUG_ON(ARRAY_SIZE(efx->rx_indir_table) !=\r\nFR_BZ_RX_INDIRECTION_TBL_ROWS);\r\nfor (i = 0; i < FR_BZ_RX_INDIRECTION_TBL_ROWS; i++) {\r\nEFX_POPULATE_DWORD_1(dword, FRF_BZ_IT_QUEUE,\r\nefx->rx_indir_table[i]);\r\nefx_writed_table(efx, &dword, FR_BZ_RX_INDIRECTION_TBL, i);\r\n}\r\n}\r\nint efx_nic_init_interrupt(struct efx_nic *efx)\r\n{\r\nstruct efx_channel *channel;\r\nint rc;\r\nif (!EFX_INT_MODE_USE_MSI(efx)) {\r\nirq_handler_t handler;\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nhandler = efx_legacy_interrupt;\r\nelse\r\nhandler = falcon_legacy_interrupt_a1;\r\nrc = request_irq(efx->legacy_irq, handler, IRQF_SHARED,\r\nefx->name, efx);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to hook legacy IRQ %d\n",\r\nefx->pci_dev->irq);\r\ngoto fail1;\r\n}\r\nreturn 0;\r\n}\r\nefx_for_each_channel(channel, efx) {\r\nrc = request_irq(channel->irq, efx_msi_interrupt,\r\nIRQF_PROBE_SHARED,\r\nefx->channel_name[channel->channel],\r\n&efx->channel[channel->channel]);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to hook IRQ %d\n", channel->irq);\r\ngoto fail2;\r\n}\r\n}\r\nreturn 0;\r\nfail2:\r\nefx_for_each_channel(channel, efx)\r\nfree_irq(channel->irq, &efx->channel[channel->channel]);\r\nfail1:\r\nreturn rc;\r\n}\r\nvoid efx_nic_fini_interrupt(struct efx_nic *efx)\r\n{\r\nstruct efx_channel *channel;\r\nefx_oword_t reg;\r\nefx_for_each_channel(channel, efx) {\r\nif (channel->irq)\r\nfree_irq(channel->irq, &efx->channel[channel->channel]);\r\n}\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nefx_reado(efx, &reg, FR_BZ_INT_ISR0);\r\nelse\r\nfalcon_irq_ack_a1(efx);\r\nif (efx->legacy_irq)\r\nfree_irq(efx->legacy_irq, efx);\r\n}\r\nvoid efx_nic_dimension_resources(struct efx_nic *efx, unsigned sram_lim_qw)\r\n{\r\nunsigned vi_count, buftbl_min;\r\nbuftbl_min = ((efx->n_rx_channels * EFX_MAX_DMAQ_SIZE +\r\nefx->n_tx_channels * EFX_TXQ_TYPES * EFX_MAX_DMAQ_SIZE +\r\nefx->n_channels * EFX_MAX_EVQ_SIZE)\r\n* sizeof(efx_qword_t) / EFX_BUF_SIZE);\r\nvi_count = max(efx->n_channels, efx->n_tx_channels * EFX_TXQ_TYPES);\r\n#ifdef CONFIG_SFC_SRIOV\r\nif (efx_sriov_wanted(efx)) {\r\nunsigned vi_dc_entries, buftbl_free, entries_per_vf, vf_limit;\r\nefx->vf_buftbl_base = buftbl_min;\r\nvi_dc_entries = RX_DC_ENTRIES + TX_DC_ENTRIES;\r\nvi_count = max(vi_count, EFX_VI_BASE);\r\nbuftbl_free = (sram_lim_qw - buftbl_min -\r\nvi_count * vi_dc_entries);\r\nentries_per_vf = ((vi_dc_entries + EFX_VF_BUFTBL_PER_VI) *\r\nefx_vf_size(efx));\r\nvf_limit = min(buftbl_free / entries_per_vf,\r\n(1024U - EFX_VI_BASE) >> efx->vi_scale);\r\nif (efx->vf_count > vf_limit) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Reducing VF count from from %d to %d\n",\r\nefx->vf_count, vf_limit);\r\nefx->vf_count = vf_limit;\r\n}\r\nvi_count += efx->vf_count * efx_vf_size(efx);\r\n}\r\n#endif\r\nefx->tx_dc_base = sram_lim_qw - vi_count * TX_DC_ENTRIES;\r\nefx->rx_dc_base = efx->tx_dc_base - vi_count * RX_DC_ENTRIES;\r\n}\r\nu32 efx_nic_fpga_ver(struct efx_nic *efx)\r\n{\r\nefx_oword_t altera_build;\r\nefx_reado(efx, &altera_build, FR_AZ_ALTERA_BUILD);\r\nreturn EFX_OWORD_FIELD(altera_build, FRF_AZ_ALTERA_BUILD_VER);\r\n}\r\nvoid efx_nic_init_common(struct efx_nic *efx)\r\n{\r\nefx_oword_t temp;\r\nEFX_POPULATE_OWORD_1(temp, FRF_AZ_SRM_TX_DC_BASE_ADR, efx->tx_dc_base);\r\nefx_writeo(efx, &temp, FR_AZ_SRM_TX_DC_CFG);\r\nEFX_POPULATE_OWORD_1(temp, FRF_AZ_SRM_RX_DC_BASE_ADR, efx->rx_dc_base);\r\nefx_writeo(efx, &temp, FR_AZ_SRM_RX_DC_CFG);\r\nBUILD_BUG_ON(TX_DC_ENTRIES != (8 << TX_DC_ENTRIES_ORDER));\r\nEFX_POPULATE_OWORD_1(temp, FRF_AZ_TX_DC_SIZE, TX_DC_ENTRIES_ORDER);\r\nefx_writeo(efx, &temp, FR_AZ_TX_DC_CFG);\r\nBUILD_BUG_ON(RX_DC_ENTRIES != (8 << RX_DC_ENTRIES_ORDER));\r\nEFX_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_SIZE, RX_DC_ENTRIES_ORDER);\r\nefx_writeo(efx, &temp, FR_AZ_RX_DC_CFG);\r\nEFX_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_PF_LWM, RX_DC_ENTRIES - 8);\r\nefx_writeo(efx, &temp, FR_AZ_RX_DC_PF_WM);\r\nEFX_POPULATE_OWORD_2(temp,\r\nFRF_AZ_NORM_INT_VEC_DIS_KER,\r\nEFX_INT_MODE_USE_MSI(efx),\r\nFRF_AZ_INT_ADR_KER, efx->irq_status.dma_addr);\r\nefx_writeo(efx, &temp, FR_AZ_INT_ADR_KER);\r\nif (EFX_WORKAROUND_17213(efx) && !EFX_INT_MODE_USE_MSI(efx))\r\nefx->irq_level = 0x1f;\r\nelse\r\nefx->irq_level = 0;\r\nEFX_POPULATE_OWORD_3(temp,\r\nFRF_AZ_ILL_ADR_INT_KER_EN, 1,\r\nFRF_AZ_RBUF_OWN_INT_KER_EN, 1,\r\nFRF_AZ_TBUF_OWN_INT_KER_EN, 1);\r\nif (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)\r\nEFX_SET_OWORD_FIELD(temp, FRF_CZ_SRAM_PERR_INT_P_KER_EN, 1);\r\nEFX_INVERT_OWORD(temp);\r\nefx_writeo(efx, &temp, FR_AZ_FATAL_INTR_KER);\r\nefx_nic_push_rx_indir_table(efx);\r\nefx_reado(efx, &temp, FR_AZ_TX_RESERVED);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER, 0xfe);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER_EN, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_ONE_PKT_PER_Q, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PUSH_EN, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_DIS_NON_IP_EV, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_SOFT_EVT_EN, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_THRESHOLD, 2);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_WD_TMR, 0x3fffff);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);\r\nefx_writeo(efx, &temp, FR_AZ_TX_RESERVED);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nEFX_POPULATE_OWORD_4(temp,\r\nFRF_BZ_TX_PACE_SB_NOT_AF, 0x15,\r\nFRF_BZ_TX_PACE_SB_AF, 0xb,\r\nFRF_BZ_TX_PACE_FB_BASE, 0,\r\nFRF_BZ_TX_PACE_BIN_TH,\r\nFFE_BZ_TX_PACE_RESERVED);\r\nefx_writeo(efx, &temp, FR_BZ_TX_PACE);\r\n}\r\n}\r\nsize_t efx_nic_get_regs_len(struct efx_nic *efx)\r\n{\r\nconst struct efx_nic_reg *reg;\r\nconst struct efx_nic_reg_table *table;\r\nsize_t len = 0;\r\nfor (reg = efx_nic_regs;\r\nreg < efx_nic_regs + ARRAY_SIZE(efx_nic_regs);\r\nreg++)\r\nif (efx->type->revision >= reg->min_revision &&\r\nefx->type->revision <= reg->max_revision)\r\nlen += sizeof(efx_oword_t);\r\nfor (table = efx_nic_reg_tables;\r\ntable < efx_nic_reg_tables + ARRAY_SIZE(efx_nic_reg_tables);\r\ntable++)\r\nif (efx->type->revision >= table->min_revision &&\r\nefx->type->revision <= table->max_revision)\r\nlen += table->rows * min_t(size_t, table->step, 16);\r\nreturn len;\r\n}\r\nvoid efx_nic_get_regs(struct efx_nic *efx, void *buf)\r\n{\r\nconst struct efx_nic_reg *reg;\r\nconst struct efx_nic_reg_table *table;\r\nfor (reg = efx_nic_regs;\r\nreg < efx_nic_regs + ARRAY_SIZE(efx_nic_regs);\r\nreg++) {\r\nif (efx->type->revision >= reg->min_revision &&\r\nefx->type->revision <= reg->max_revision) {\r\nefx_reado(efx, (efx_oword_t *)buf, reg->offset);\r\nbuf += sizeof(efx_oword_t);\r\n}\r\n}\r\nfor (table = efx_nic_reg_tables;\r\ntable < efx_nic_reg_tables + ARRAY_SIZE(efx_nic_reg_tables);\r\ntable++) {\r\nsize_t size, i;\r\nif (!(efx->type->revision >= table->min_revision &&\r\nefx->type->revision <= table->max_revision))\r\ncontinue;\r\nsize = min_t(size_t, table->step, 16);\r\nfor (i = 0; i < table->rows; i++) {\r\nswitch (table->step) {\r\ncase 4:\r\nefx_readd_table(efx, buf, table->offset, i);\r\nbreak;\r\ncase 8:\r\nefx_sram_readq(efx,\r\nefx->membase + table->offset,\r\nbuf, i);\r\nbreak;\r\ncase 16:\r\nefx_reado_table(efx, buf, table->offset, i);\r\nbreak;\r\ncase 32:\r\nefx_reado_table(efx, buf, table->offset, 2 * i);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nbuf += size;\r\n}\r\n}\r\n}
