int nfs_mount(struct nfs_mount_request *info)\r\n{\r\nstruct mountres result = {\r\n.fh = info->fh,\r\n.auth_count = info->auth_flav_len,\r\n.auth_flavors = info->auth_flavs,\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_argp = info->dirpath,\r\n.rpc_resp = &result,\r\n};\r\nstruct rpc_create_args args = {\r\n.net = info->net,\r\n.protocol = info->protocol,\r\n.address = info->sap,\r\n.addrsize = info->salen,\r\n.servername = info->hostname,\r\n.program = &mnt_program,\r\n.version = info->version,\r\n.authflavor = RPC_AUTH_UNIX,\r\n};\r\nstruct rpc_clnt *mnt_clnt;\r\nint status;\r\ndprintk("NFS: sending MNT request for %s:%s\n",\r\n(info->hostname ? info->hostname : "server"),\r\ninfo->dirpath);\r\nif (info->noresvport)\r\nargs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\r\nmnt_clnt = rpc_create(&args);\r\nif (IS_ERR(mnt_clnt))\r\ngoto out_clnt_err;\r\nif (info->version == NFS_MNT3_VERSION)\r\nmsg.rpc_proc = &mnt_clnt->cl_procinfo[MOUNTPROC3_MNT];\r\nelse\r\nmsg.rpc_proc = &mnt_clnt->cl_procinfo[MOUNTPROC_MNT];\r\nstatus = rpc_call_sync(mnt_clnt, &msg, 0);\r\nrpc_shutdown_client(mnt_clnt);\r\nif (status < 0)\r\ngoto out_call_err;\r\nif (result.errno != 0)\r\ngoto out_mnt_err;\r\ndprintk("NFS: MNT request succeeded\n");\r\nstatus = 0;\r\nout:\r\nreturn status;\r\nout_clnt_err:\r\nstatus = PTR_ERR(mnt_clnt);\r\ndprintk("NFS: failed to create MNT RPC client, status=%d\n", status);\r\ngoto out;\r\nout_call_err:\r\ndprintk("NFS: MNT request failed, status=%d\n", status);\r\ngoto out;\r\nout_mnt_err:\r\ndprintk("NFS: MNT server returned result %d\n", result.errno);\r\nstatus = result.errno;\r\ngoto out;\r\n}\r\nvoid nfs_umount(const struct nfs_mount_request *info)\r\n{\r\nstatic const struct rpc_timeout nfs_umnt_timeout = {\r\n.to_initval = 1 * HZ,\r\n.to_maxval = 3 * HZ,\r\n.to_retries = 2,\r\n};\r\nstruct rpc_create_args args = {\r\n.net = info->net,\r\n.protocol = IPPROTO_UDP,\r\n.address = info->sap,\r\n.addrsize = info->salen,\r\n.timeout = &nfs_umnt_timeout,\r\n.servername = info->hostname,\r\n.program = &mnt_program,\r\n.version = info->version,\r\n.authflavor = RPC_AUTH_UNIX,\r\n.flags = RPC_CLNT_CREATE_NOPING,\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_argp = info->dirpath,\r\n};\r\nstruct rpc_clnt *clnt;\r\nint status;\r\nif (info->noresvport)\r\nargs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\r\nclnt = rpc_create(&args);\r\nif (IS_ERR(clnt))\r\ngoto out_clnt_err;\r\ndprintk("NFS: sending UMNT request for %s:%s\n",\r\n(info->hostname ? info->hostname : "server"), info->dirpath);\r\nif (info->version == NFS_MNT3_VERSION)\r\nmsg.rpc_proc = &clnt->cl_procinfo[MOUNTPROC3_UMNT];\r\nelse\r\nmsg.rpc_proc = &clnt->cl_procinfo[MOUNTPROC_UMNT];\r\nstatus = rpc_call_sync(clnt, &msg, 0);\r\nrpc_shutdown_client(clnt);\r\nif (unlikely(status < 0))\r\ngoto out_call_err;\r\nreturn;\r\nout_clnt_err:\r\ndprintk("NFS: failed to create UMNT RPC client, status=%ld\n",\r\nPTR_ERR(clnt));\r\nreturn;\r\nout_call_err:\r\ndprintk("NFS: UMNT request failed, status=%d\n", status);\r\n}\r\nstatic void encode_mntdirpath(struct xdr_stream *xdr, const char *pathname)\r\n{\r\nconst u32 pathname_len = strlen(pathname);\r\n__be32 *p;\r\nBUG_ON(pathname_len > MNTPATHLEN);\r\np = xdr_reserve_space(xdr, 4 + pathname_len);\r\nxdr_encode_opaque(p, pathname, pathname_len);\r\n}\r\nstatic void mnt_xdr_enc_dirpath(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst char *dirpath)\r\n{\r\nencode_mntdirpath(xdr, dirpath);\r\n}\r\nstatic int decode_status(struct xdr_stream *xdr, struct mountres *res)\r\n{\r\nunsigned int i;\r\nu32 status;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nstatus = be32_to_cpup(p);\r\nfor (i = 0; i < ARRAY_SIZE(mnt_errtbl); i++) {\r\nif (mnt_errtbl[i].status == status) {\r\nres->errno = mnt_errtbl[i].errno;\r\nreturn 0;\r\n}\r\n}\r\ndprintk("NFS: unrecognized MNT status code: %u\n", status);\r\nres->errno = -EACCES;\r\nreturn 0;\r\n}\r\nstatic int decode_fhandle(struct xdr_stream *xdr, struct mountres *res)\r\n{\r\nstruct nfs_fh *fh = res->fh;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, NFS2_FHSIZE);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nfh->size = NFS2_FHSIZE;\r\nmemcpy(fh->data, p, NFS2_FHSIZE);\r\nreturn 0;\r\n}\r\nstatic int mnt_xdr_dec_mountres(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct mountres *res)\r\n{\r\nint status;\r\nstatus = decode_status(xdr, res);\r\nif (unlikely(status != 0 || res->errno != 0))\r\nreturn status;\r\nreturn decode_fhandle(xdr, res);\r\n}\r\nstatic int decode_fhs_status(struct xdr_stream *xdr, struct mountres *res)\r\n{\r\nunsigned int i;\r\nu32 status;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nstatus = be32_to_cpup(p);\r\nfor (i = 0; i < ARRAY_SIZE(mnt3_errtbl); i++) {\r\nif (mnt3_errtbl[i].status == status) {\r\nres->errno = mnt3_errtbl[i].errno;\r\nreturn 0;\r\n}\r\n}\r\ndprintk("NFS: unrecognized MNT3 status code: %u\n", status);\r\nres->errno = -EACCES;\r\nreturn 0;\r\n}\r\nstatic int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\r\n{\r\nstruct nfs_fh *fh = res->fh;\r\nu32 size;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nsize = be32_to_cpup(p);\r\nif (size > NFS3_FHSIZE || size == 0)\r\nreturn -EIO;\r\np = xdr_inline_decode(xdr, size);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nfh->size = size;\r\nmemcpy(fh->data, p, size);\r\nreturn 0;\r\n}\r\nstatic int decode_auth_flavors(struct xdr_stream *xdr, struct mountres *res)\r\n{\r\nrpc_authflavor_t *flavors = res->auth_flavors;\r\nunsigned int *count = res->auth_count;\r\nu32 entries, i;\r\n__be32 *p;\r\nif (*count == 0)\r\nreturn 0;\r\np = xdr_inline_decode(xdr, 4);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nentries = be32_to_cpup(p);\r\ndprintk("NFS: received %u auth flavors\n", entries);\r\nif (entries > NFS_MAX_SECFLAVORS)\r\nentries = NFS_MAX_SECFLAVORS;\r\np = xdr_inline_decode(xdr, 4 * entries);\r\nif (unlikely(p == NULL))\r\nreturn -EIO;\r\nif (entries > *count)\r\nentries = *count;\r\nfor (i = 0; i < entries; i++) {\r\nflavors[i] = be32_to_cpup(p++);\r\ndprintk("NFS: auth flavor[%u]: %d\n", i, flavors[i]);\r\n}\r\n*count = i;\r\nreturn 0;\r\n}\r\nstatic int mnt_xdr_dec_mountres3(struct rpc_rqst *req,\r\nstruct xdr_stream *xdr,\r\nstruct mountres *res)\r\n{\r\nint status;\r\nstatus = decode_fhs_status(xdr, res);\r\nif (unlikely(status != 0 || res->errno != 0))\r\nreturn status;\r\nstatus = decode_fhandle3(xdr, res);\r\nif (unlikely(status != 0)) {\r\nres->errno = -EBADHANDLE;\r\nreturn 0;\r\n}\r\nreturn decode_auth_flavors(xdr, res);\r\n}
