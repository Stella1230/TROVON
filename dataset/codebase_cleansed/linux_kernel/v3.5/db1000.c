static const char *board_type_str(void)\r\n{\r\nswitch (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI))) {\r\ncase BCSR_WHOAMI_DB1000:\r\nreturn "DB1000";\r\ncase BCSR_WHOAMI_DB1500:\r\nreturn "DB1500";\r\ncase BCSR_WHOAMI_DB1100:\r\nreturn "DB1100";\r\ndefault:\r\nreturn "(unknown)";\r\n}\r\n}\r\nconst char *get_system_type(void)\r\n{\r\nreturn board_type_str();\r\n}\r\nvoid __init board_setup(void)\r\n{\r\nbcsr_init(DB1000_BCSR_PHYS_ADDR,\r\nDB1000_BCSR_PHYS_ADDR + DB1000_BCSR_HEXLED_OFS);\r\nprintk(KERN_INFO "AMD Alchemy %s Board\n", board_type_str());\r\n}\r\nstatic int db1500_map_pci_irq(const struct pci_dev *d, u8 slot, u8 pin)\r\n{\r\nif ((slot < 12) || (slot > 13) || pin == 0)\r\nreturn -1;\r\nif (slot == 12)\r\nreturn (pin == 1) ? AU1500_PCI_INTA : 0xff;\r\nif (slot == 13) {\r\nswitch (pin) {\r\ncase 1: return AU1500_PCI_INTA;\r\ncase 2: return AU1500_PCI_INTB;\r\ncase 3: return AU1500_PCI_INTC;\r\ncase 4: return AU1500_PCI_INTD;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init db1500_pci_init(void)\r\n{\r\nif (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI)) == BCSR_WHOAMI_DB1500)\r\nreturn platform_device_register(&db1500_pci_host_dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t db1100_mmc_cd(int irq, void *ptr)\r\n{\r\nvoid (*mmc_cd)(struct mmc_host *, unsigned long);\r\nmmc_cd = symbol_get(mmc_detect_change);\r\nmmc_cd(ptr, msecs_to_jiffies(500));\r\nsymbol_put(mmc_detect_change);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int db1100_mmc_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret = 0;\r\nif (en) {\r\nirq_set_irq_type(AU1100_GPIO19_INT, IRQ_TYPE_EDGE_BOTH);\r\nret = request_irq(AU1100_GPIO19_INT, db1100_mmc_cd, 0,\r\n"sd0_cd", mmc_host);\r\n} else\r\nfree_irq(AU1100_GPIO19_INT, mmc_host);\r\nreturn ret;\r\n}\r\nstatic int db1100_mmc1_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret = 0;\r\nif (en) {\r\nirq_set_irq_type(AU1100_GPIO20_INT, IRQ_TYPE_EDGE_BOTH);\r\nret = request_irq(AU1100_GPIO20_INT, db1100_mmc_cd, 0,\r\n"sd1_cd", mmc_host);\r\n} else\r\nfree_irq(AU1100_GPIO20_INT, mmc_host);\r\nreturn ret;\r\n}\r\nstatic int db1100_mmc_card_readonly(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_STATUS) & BCSR_STATUS_SD0WP) ? 0 : 1;\r\n}\r\nstatic int db1100_mmc_card_inserted(void *mmc_host)\r\n{\r\nreturn !alchemy_gpio_get_value(19);\r\n}\r\nstatic void db1100_mmc_set_power(void *mmc_host, int state)\r\n{\r\nif (state) {\r\nbcsr_mod(BCSR_BOARD, 0, BCSR_BOARD_SD0PWR);\r\nmsleep(400);\r\n} else\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_SD0PWR, 0);\r\n}\r\nstatic void db1100_mmcled_set(struct led_classdev *led, enum led_brightness b)\r\n{\r\nif (b != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED0, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED0);\r\n}\r\nstatic int db1100_mmc1_card_readonly(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_BOARD) & BCSR_BOARD_SD1WP) ? 1 : 0;\r\n}\r\nstatic int db1100_mmc1_card_inserted(void *mmc_host)\r\n{\r\nreturn !alchemy_gpio_get_value(20);\r\n}\r\nstatic void db1100_mmc1_set_power(void *mmc_host, int state)\r\n{\r\nif (state) {\r\nbcsr_mod(BCSR_BOARD, 0, BCSR_BOARD_SD1PWR);\r\nmsleep(400);\r\n} else\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_SD1PWR, 0);\r\n}\r\nstatic void db1100_mmc1led_set(struct led_classdev *led, enum led_brightness b)\r\n{\r\nif (b != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED1, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED1);\r\n}\r\nstatic void db1000_irda_set_phy_mode(int mode)\r\n{\r\nunsigned short mask = BCSR_RESETS_IRDA_MODE_MASK | BCSR_RESETS_FIR_SEL;\r\nswitch (mode) {\r\ncase AU1000_IRDA_PHY_MODE_OFF:\r\nbcsr_mod(BCSR_RESETS, mask, BCSR_RESETS_IRDA_MODE_OFF);\r\nbreak;\r\ncase AU1000_IRDA_PHY_MODE_SIR:\r\nbcsr_mod(BCSR_RESETS, mask, BCSR_RESETS_IRDA_MODE_FULL);\r\nbreak;\r\ncase AU1000_IRDA_PHY_MODE_FIR:\r\nbcsr_mod(BCSR_RESETS, mask, BCSR_RESETS_IRDA_MODE_FULL |\r\nBCSR_RESETS_FIR_SEL);\r\nbreak;\r\n}\r\n}\r\nstatic int __init db1000_dev_init(void)\r\n{\r\nint board = BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI));\r\nint c0, c1, d0, d1, s0, s1;\r\nunsigned long pfc;\r\nif (board == BCSR_WHOAMI_DB1500) {\r\nc0 = AU1500_GPIO2_INT;\r\nc1 = AU1500_GPIO5_INT;\r\nd0 = AU1500_GPIO0_INT;\r\nd1 = AU1500_GPIO3_INT;\r\ns0 = AU1500_GPIO1_INT;\r\ns1 = AU1500_GPIO4_INT;\r\n} else if (board == BCSR_WHOAMI_DB1100) {\r\nc0 = AU1100_GPIO2_INT;\r\nc1 = AU1100_GPIO5_INT;\r\nd0 = AU1100_GPIO0_INT;\r\nd1 = AU1100_GPIO3_INT;\r\ns0 = AU1100_GPIO1_INT;\r\ns1 = AU1100_GPIO4_INT;\r\ngpio_direction_input(19);\r\ngpio_direction_input(20);\r\ngpio_direction_input(21);\r\ngpio_direction_input(207);\r\ngpio_direction_output(208, 0);\r\ngpio_direction_output(209, 1);\r\ngpio_direction_output(210, 1);\r\npfc = __raw_readl((void __iomem *)SYS_PINFUNC);\r\npfc |= (1 << 0);\r\n__raw_writel(pfc, (void __iomem *)SYS_PINFUNC);\r\nwmb();\r\nspi_register_board_info(db1100_spi_info,\r\nARRAY_SIZE(db1100_spi_info));\r\nplatform_add_devices(db1100_devs, ARRAY_SIZE(db1100_devs));\r\n} else if (board == BCSR_WHOAMI_DB1000) {\r\nc0 = AU1000_GPIO2_INT;\r\nc1 = AU1000_GPIO5_INT;\r\nd0 = AU1000_GPIO0_INT;\r\nd1 = AU1000_GPIO3_INT;\r\ns0 = AU1000_GPIO1_INT;\r\ns1 = AU1000_GPIO4_INT;\r\nplatform_add_devices(db1000_devs, ARRAY_SIZE(db1000_devs));\r\n} else\r\nreturn 0;\r\nirq_set_irq_type(d0, IRQ_TYPE_EDGE_BOTH);\r\nirq_set_irq_type(d1, IRQ_TYPE_EDGE_BOTH);\r\nirq_set_irq_type(c0, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(c1, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(s0, IRQ_TYPE_LEVEL_LOW);\r\nirq_set_irq_type(s1, IRQ_TYPE_LEVEL_LOW);\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x000400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x000400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x000010000 - 1,\r\nc0, d0, 0, 0, 0);\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x004400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x004400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x004010000 - 1,\r\nc1, d1, 0, 0, 1);\r\nplatform_add_devices(db1x00_devs, ARRAY_SIZE(db1x00_devs));\r\ndb1x_register_norflash(32 << 20, 4 , F_SWAPPED);\r\nreturn 0;\r\n}
