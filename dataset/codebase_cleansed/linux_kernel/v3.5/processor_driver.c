static int acpi_processor_errata_piix4(struct pci_dev *dev)\r\n{\r\nu8 value1 = 0;\r\nu8 value2 = 0;\r\nif (!dev)\r\nreturn -EINVAL;\r\nswitch (dev->revision) {\r\ncase 0:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 A-step\n"));\r\nbreak;\r\ncase 1:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4 B-step\n"));\r\nbreak;\r\ncase 2:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4E\n"));\r\nbreak;\r\ncase 3:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found PIIX4M\n"));\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found unknown PIIX4\n"));\r\nbreak;\r\n}\r\nswitch (dev->revision) {\r\ncase 0:\r\ncase 1:\r\nerrata.piix4.throttle = 1;\r\ncase 2:\r\ncase 3:\r\ndev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB,\r\nPCI_ANY_ID, PCI_ANY_ID, NULL);\r\nif (dev) {\r\nerrata.piix4.bmisx = pci_resource_start(dev, 4);\r\npci_dev_put(dev);\r\n}\r\ndev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_0,\r\nPCI_ANY_ID, PCI_ANY_ID, NULL);\r\nif (dev) {\r\npci_read_config_byte(dev, 0x76, &value1);\r\npci_read_config_byte(dev, 0x77, &value2);\r\nif ((value1 & 0x80) || (value2 & 0x80))\r\nerrata.piix4.fdma = 1;\r\npci_dev_put(dev);\r\n}\r\nbreak;\r\n}\r\nif (errata.piix4.bmisx)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Bus master activity detection (BM-IDE) erratum enabled\n"));\r\nif (errata.piix4.fdma)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Type-F DMA livelock erratum (C3 disabled)\n"));\r\nreturn 0;\r\n}\r\nstatic int acpi_processor_errata(struct acpi_processor *pr)\r\n{\r\nint result = 0;\r\nstruct pci_dev *dev = NULL;\r\nif (!pr)\r\nreturn -EINVAL;\r\ndev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82371AB_3, PCI_ANY_ID,\r\nPCI_ANY_ID, NULL);\r\nif (dev) {\r\nresult = acpi_processor_errata_piix4(dev);\r\npci_dev_put(dev);\r\n}\r\nreturn result;\r\n}\r\nstatic int acpi_processor_get_info(struct acpi_device *device)\r\n{\r\nacpi_status status = 0;\r\nunion acpi_object object = { 0 };\r\nstruct acpi_buffer buffer = { sizeof(union acpi_object), &object };\r\nstruct acpi_processor *pr;\r\nint cpu_index, device_declaration = 0;\r\nstatic int cpu0_initialized;\r\npr = acpi_driver_data(device);\r\nif (!pr)\r\nreturn -EINVAL;\r\nif (num_online_cpus() > 1)\r\nerrata.smp = TRUE;\r\nacpi_processor_errata(pr);\r\nif (acpi_gbl_FADT.pm2_control_block && acpi_gbl_FADT.pm2_control_length) {\r\npr->flags.bm_control = 1;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Bus mastering arbitration control present\n"));\r\n} else\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"No bus mastering arbitration control\n"));\r\nif (!strcmp(acpi_device_hid(device), ACPI_PROCESSOR_OBJECT_HID)) {\r\nstatus = acpi_evaluate_object(pr->handle, NULL, NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX "Evaluating processor object\n");\r\nreturn -ENODEV;\r\n}\r\npr->acpi_id = object.processor.proc_id;\r\n} else {\r\nunsigned long long value;\r\nstatus = acpi_evaluate_integer(pr->handle, METHOD_NAME__UID,\r\nNULL, &value);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_ERR PREFIX\r\n"Evaluating processor _UID [%#x]\n", status);\r\nreturn -ENODEV;\r\n}\r\ndevice_declaration = 1;\r\npr->acpi_id = value;\r\n}\r\ncpu_index = acpi_get_cpuid(pr->handle, device_declaration, pr->acpi_id);\r\nif (!cpu0_initialized && (cpu_index == -1) &&\r\n(num_online_cpus() == 1)) {\r\ncpu_index = 0;\r\n}\r\ncpu0_initialized = 1;\r\npr->id = cpu_index;\r\nif (pr->id == -1) {\r\nif (ACPI_FAILURE(acpi_processor_hotadd_init(pr)))\r\nreturn -ENODEV;\r\n}\r\nsprintf(acpi_device_bid(device), "CPU%X", pr->id);\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Processor [%d:%d]\n", pr->id,\r\npr->acpi_id));\r\nif (!object.processor.pblk_address)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "No PBLK (NULL address)\n"));\r\nelse if (object.processor.pblk_length != 6)\r\nprintk(KERN_ERR PREFIX "Invalid PBLK length [%d]\n",\r\nobject.processor.pblk_length);\r\nelse {\r\npr->throttling.address = object.processor.pblk_address;\r\npr->throttling.duty_offset = acpi_gbl_FADT.duty_offset;\r\npr->throttling.duty_width = acpi_gbl_FADT.duty_width;\r\npr->pblk = object.processor.pblk_address;\r\nrequest_region(pr->throttling.address, 6, "ACPI CPU throttle");\r\n}\r\nstatus = acpi_evaluate_object(pr->handle, "_SUN", NULL, &buffer);\r\nif (ACPI_SUCCESS(status))\r\narch_fix_phys_package_id(pr->id, object.integer.value);\r\nreturn 0;\r\n}\r\nstatic void acpi_processor_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_processor *pr = acpi_driver_data(device);\r\nint saved;\r\nif (!pr)\r\nreturn;\r\nswitch (event) {\r\ncase ACPI_PROCESSOR_NOTIFY_PERFORMANCE:\r\nsaved = pr->performance_platform_limit;\r\nacpi_processor_ppc_has_changed(pr, 1);\r\nif (saved == pr->performance_platform_limit)\r\nbreak;\r\nacpi_bus_generate_proc_event(device, event,\r\npr->performance_platform_limit);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event,\r\npr->performance_platform_limit);\r\nbreak;\r\ncase ACPI_PROCESSOR_NOTIFY_POWER:\r\nacpi_processor_cst_has_changed(pr);\r\nacpi_bus_generate_proc_event(device, event, 0);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event, 0);\r\nbreak;\r\ncase ACPI_PROCESSOR_NOTIFY_THROTTLING:\r\nacpi_processor_tstate_has_changed(pr);\r\nacpi_bus_generate_proc_event(device, event, 0);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event, 0);\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int acpi_cpu_soft_notify(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nstruct acpi_processor *pr = per_cpu(processors, cpu);\r\nif (action == CPU_ONLINE && pr) {\r\nif (pr->flags.need_hotplug_init) {\r\nstruct cpuidle_driver *idle_driver =\r\ncpuidle_get_driver();\r\nprintk(KERN_INFO "Will online and init hotplugged "\r\n"CPU: %d\n", pr->id);\r\nWARN(acpi_processor_start(pr), "Failed to start CPU:"\r\n" %d\n", pr->id);\r\npr->flags.need_hotplug_init = 0;\r\nif (idle_driver && !strcmp(idle_driver->name,\r\n"intel_idle")) {\r\nintel_idle_cpu_init(pr->id);\r\n}\r\n} else {\r\nacpi_processor_ppc_has_changed(pr, 0);\r\nacpi_processor_cst_has_changed(pr);\r\nacpi_processor_reevaluate_tstate(pr, action);\r\nacpi_processor_tstate_has_changed(pr);\r\n}\r\n}\r\nif (action == CPU_DEAD && pr) {\r\nacpi_processor_reevaluate_tstate(pr, action);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic __ref int acpi_processor_start(struct acpi_processor *pr)\r\n{\r\nstruct acpi_device *device = per_cpu(processor_device_array, pr->id);\r\nint result = 0;\r\n#ifdef CONFIG_CPU_FREQ\r\nacpi_processor_ppc_has_changed(pr, 0);\r\nacpi_processor_load_module(pr);\r\n#endif\r\nacpi_processor_get_throttling_info(pr);\r\nacpi_processor_get_limit_info(pr);\r\nif (!cpuidle_get_driver() || cpuidle_get_driver() == &acpi_idle_driver)\r\nacpi_processor_power_init(pr, device);\r\npr->cdev = thermal_cooling_device_register("Processor", device,\r\n&processor_cooling_ops);\r\nif (IS_ERR(pr->cdev)) {\r\nresult = PTR_ERR(pr->cdev);\r\ngoto err_power_exit;\r\n}\r\ndev_dbg(&device->dev, "registered as cooling_device%d\n",\r\npr->cdev->id);\r\nresult = sysfs_create_link(&device->dev.kobj,\r\n&pr->cdev->device.kobj,\r\n"thermal_cooling");\r\nif (result) {\r\nprintk(KERN_ERR PREFIX "Create sysfs link\n");\r\ngoto err_thermal_unregister;\r\n}\r\nresult = sysfs_create_link(&pr->cdev->device.kobj,\r\n&device->dev.kobj,\r\n"device");\r\nif (result) {\r\nprintk(KERN_ERR PREFIX "Create sysfs link\n");\r\ngoto err_remove_sysfs_thermal;\r\n}\r\nreturn 0;\r\nerr_remove_sysfs_thermal:\r\nsysfs_remove_link(&device->dev.kobj, "thermal_cooling");\r\nerr_thermal_unregister:\r\nthermal_cooling_device_unregister(pr->cdev);\r\nerr_power_exit:\r\nacpi_processor_power_exit(pr, device);\r\nreturn result;\r\n}\r\nstatic int __cpuinit acpi_processor_add(struct acpi_device *device)\r\n{\r\nstruct acpi_processor *pr = NULL;\r\nint result = 0;\r\nstruct device *dev;\r\npr = kzalloc(sizeof(struct acpi_processor), GFP_KERNEL);\r\nif (!pr)\r\nreturn -ENOMEM;\r\nif (!zalloc_cpumask_var(&pr->throttling.shared_cpu_map, GFP_KERNEL)) {\r\nresult = -ENOMEM;\r\ngoto err_free_pr;\r\n}\r\npr->handle = device->handle;\r\nstrcpy(acpi_device_name(device), ACPI_PROCESSOR_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PROCESSOR_CLASS);\r\ndevice->driver_data = pr;\r\nresult = acpi_processor_get_info(device);\r\nif (result) {\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_SMP\r\nif (pr->id >= setup_max_cpus && pr->id != 0)\r\nreturn 0;\r\n#endif\r\nBUG_ON((pr->id >= nr_cpu_ids) || (pr->id < 0));\r\nif (per_cpu(processor_device_array, pr->id) != NULL &&\r\nper_cpu(processor_device_array, pr->id) != device) {\r\nprintk(KERN_WARNING "BIOS reported wrong ACPI id "\r\n"for the processor\n");\r\nresult = -ENODEV;\r\ngoto err_free_cpumask;\r\n}\r\nper_cpu(processor_device_array, pr->id) = device;\r\nper_cpu(processors, pr->id) = pr;\r\ndev = get_cpu_device(pr->id);\r\nif (sysfs_create_link(&device->dev.kobj, &dev->kobj, "sysdev")) {\r\nresult = -EFAULT;\r\ngoto err_clear_processor;\r\n}\r\nif (pr->flags.need_hotplug_init)\r\nreturn 0;\r\nresult = acpi_processor_start(pr);\r\nif (result)\r\ngoto err_remove_sysfs;\r\nreturn 0;\r\nerr_remove_sysfs:\r\nsysfs_remove_link(&device->dev.kobj, "sysdev");\r\nerr_clear_processor:\r\nper_cpu(processors, pr->id) = NULL;\r\nerr_free_cpumask:\r\nfree_cpumask_var(pr->throttling.shared_cpu_map);\r\nerr_free_pr:\r\nkfree(pr);\r\nreturn result;\r\n}\r\nstatic int acpi_processor_remove(struct acpi_device *device, int type)\r\n{\r\nstruct acpi_processor *pr = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\npr = acpi_driver_data(device);\r\nif (pr->id >= nr_cpu_ids)\r\ngoto free;\r\nif (type == ACPI_BUS_REMOVAL_EJECT) {\r\nif (acpi_processor_handle_eject(pr))\r\nreturn -EINVAL;\r\n}\r\nacpi_processor_power_exit(pr, device);\r\nsysfs_remove_link(&device->dev.kobj, "sysdev");\r\nif (pr->cdev) {\r\nsysfs_remove_link(&device->dev.kobj, "thermal_cooling");\r\nsysfs_remove_link(&pr->cdev->device.kobj, "device");\r\nthermal_cooling_device_unregister(pr->cdev);\r\npr->cdev = NULL;\r\n}\r\nper_cpu(processors, pr->id) = NULL;\r\nper_cpu(processor_device_array, pr->id) = NULL;\r\nfree:\r\nfree_cpumask_var(pr->throttling.shared_cpu_map);\r\nkfree(pr);\r\nreturn 0;\r\n}\r\nstatic int is_processor_present(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nunsigned long long sta = 0;\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && (sta & ACPI_STA_DEVICE_PRESENT))\r\nreturn 1;\r\nif (status == AE_NOT_FOUND)\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Processor does not support hot plug\n"));\r\nelse\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"Processor Device is not present"));\r\nreturn 0;\r\n}\r\nstatic\r\nint acpi_processor_device_add(acpi_handle handle, struct acpi_device **device)\r\n{\r\nacpi_handle phandle;\r\nstruct acpi_device *pdev;\r\nif (acpi_get_parent(handle, &phandle)) {\r\nreturn -ENODEV;\r\n}\r\nif (acpi_bus_get_device(phandle, &pdev)) {\r\nreturn -ENODEV;\r\n}\r\nif (acpi_bus_add(device, pdev, handle, ACPI_BUS_TYPE_PROCESSOR)) {\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_processor_hotplug_notify(acpi_handle handle,\r\nu32 event, void *data)\r\n{\r\nstruct acpi_processor *pr;\r\nstruct acpi_device *device = NULL;\r\nint result;\r\nswitch (event) {\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Processor driver received %s event\n",\r\n(event == ACPI_NOTIFY_BUS_CHECK) ?\r\n"ACPI_NOTIFY_BUS_CHECK" : "ACPI_NOTIFY_DEVICE_CHECK"));\r\nif (!is_processor_present(handle))\r\nbreak;\r\nif (acpi_bus_get_device(handle, &device)) {\r\nresult = acpi_processor_device_add(handle, &device);\r\nif (result)\r\nprintk(KERN_ERR PREFIX\r\n"Unable to add the device\n");\r\nbreak;\r\n}\r\nbreak;\r\ncase ACPI_NOTIFY_EJECT_REQUEST:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"received ACPI_NOTIFY_EJECT_REQUEST\n"));\r\nif (acpi_bus_get_device(handle, &device)) {\r\nprintk(KERN_ERR PREFIX\r\n"Device don't exist, dropping EJECT\n");\r\nbreak;\r\n}\r\npr = acpi_driver_data(device);\r\nif (!pr) {\r\nprintk(KERN_ERR PREFIX\r\n"Driver data is NULL, dropping EJECT\n");\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic acpi_status is_processor_device(acpi_handle handle)\r\n{\r\nstruct acpi_device_info *info;\r\nchar *hid;\r\nacpi_status status;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (info->type == ACPI_TYPE_PROCESSOR) {\r\nkfree(info);\r\nreturn AE_OK;\r\n}\r\nif (!(info->valid & ACPI_VALID_HID)) {\r\nkfree(info);\r\nreturn AE_ERROR;\r\n}\r\nhid = info->hardware_id.string;\r\nif ((hid == NULL) || strcmp(hid, ACPI_PROCESSOR_DEVICE_HID)) {\r\nkfree(info);\r\nreturn AE_ERROR;\r\n}\r\nkfree(info);\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nprocessor_walk_namespace_cb(acpi_handle handle,\r\nu32 lvl, void *context, void **rv)\r\n{\r\nacpi_status status;\r\nint *action = context;\r\nstatus = is_processor_device(handle);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nswitch (*action) {\r\ncase INSTALL_NOTIFY_HANDLER:\r\nacpi_install_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nacpi_processor_hotplug_notify,\r\nNULL);\r\nbreak;\r\ncase UNINSTALL_NOTIFY_HANDLER:\r\nacpi_remove_notify_handler(handle,\r\nACPI_SYSTEM_NOTIFY,\r\nacpi_processor_hotplug_notify);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn AE_CTRL_DEPTH;\r\n}\r\nstatic acpi_status acpi_processor_hotadd_init(struct acpi_processor *pr)\r\n{\r\nacpi_handle handle = pr->handle;\r\nif (!is_processor_present(handle)) {\r\nreturn AE_ERROR;\r\n}\r\nif (acpi_map_lsapic(handle, &pr->id))\r\nreturn AE_ERROR;\r\nif (arch_register_cpu(pr->id)) {\r\nacpi_unmap_lsapic(pr->id);\r\nreturn AE_ERROR;\r\n}\r\nprintk(KERN_INFO "CPU %d got hotplugged\n", pr->id);\r\npr->flags.need_hotplug_init = 1;\r\nreturn AE_OK;\r\n}\r\nstatic int acpi_processor_handle_eject(struct acpi_processor *pr)\r\n{\r\nif (cpu_online(pr->id))\r\ncpu_down(pr->id);\r\narch_unregister_cpu(pr->id);\r\nacpi_unmap_lsapic(pr->id);\r\nreturn (0);\r\n}\r\nstatic acpi_status acpi_processor_hotadd_init(struct acpi_processor *pr)\r\n{\r\nreturn AE_ERROR;\r\n}\r\nstatic int acpi_processor_handle_eject(struct acpi_processor *pr)\r\n{\r\nreturn (-EINVAL);\r\n}\r\nstatic\r\nvoid acpi_processor_install_hotplug_notify(void)\r\n{\r\n#ifdef CONFIG_ACPI_HOTPLUG_CPU\r\nint action = INSTALL_NOTIFY_HANDLER;\r\nacpi_walk_namespace(ACPI_TYPE_ANY,\r\nACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nprocessor_walk_namespace_cb, NULL, &action, NULL);\r\n#endif\r\nregister_hotcpu_notifier(&acpi_cpu_notifier);\r\n}\r\nstatic\r\nvoid acpi_processor_uninstall_hotplug_notify(void)\r\n{\r\n#ifdef CONFIG_ACPI_HOTPLUG_CPU\r\nint action = UNINSTALL_NOTIFY_HANDLER;\r\nacpi_walk_namespace(ACPI_TYPE_ANY,\r\nACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nprocessor_walk_namespace_cb, NULL, &action, NULL);\r\n#endif\r\nunregister_hotcpu_notifier(&acpi_cpu_notifier);\r\n}\r\nstatic int __init acpi_processor_init(void)\r\n{\r\nint result = 0;\r\nif (acpi_disabled)\r\nreturn 0;\r\nmemset(&errata, 0, sizeof(errata));\r\nresult = acpi_bus_register_driver(&acpi_processor_driver);\r\nif (result < 0)\r\nreturn result;\r\nacpi_processor_install_hotplug_notify();\r\nacpi_thermal_cpufreq_init();\r\nacpi_processor_ppc_init();\r\nacpi_processor_throttling_init();\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_processor_exit(void)\r\n{\r\nif (acpi_disabled)\r\nreturn;\r\nacpi_processor_ppc_exit();\r\nacpi_thermal_cpufreq_exit();\r\nacpi_processor_uninstall_hotplug_notify();\r\nacpi_bus_unregister_driver(&acpi_processor_driver);\r\nreturn;\r\n}
