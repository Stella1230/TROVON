static void greth_print_rx_packet(void *addr, int len)\r\n{\r\nprint_hex_dump(KERN_DEBUG, "RX: ", DUMP_PREFIX_OFFSET, 16, 1,\r\naddr, len, true);\r\n}\r\nstatic void greth_print_tx_packet(struct sk_buff *skb)\r\n{\r\nint i;\r\nint length;\r\nif (skb_shinfo(skb)->nr_frags == 0)\r\nlength = skb->len;\r\nelse\r\nlength = skb_headlen(skb);\r\nprint_hex_dump(KERN_DEBUG, "TX: ", DUMP_PREFIX_OFFSET, 16, 1,\r\nskb->data, length, true);\r\nfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\r\nprint_hex_dump(KERN_DEBUG, "TX: ", DUMP_PREFIX_OFFSET, 16, 1,\r\nskb_frag_address(&skb_shinfo(skb)->frags[i]),\r\nskb_shinfo(skb)->frags[i].size, true);\r\n}\r\n}\r\nstatic inline void greth_enable_tx(struct greth_private *greth)\r\n{\r\nwmb();\r\nGRETH_REGORIN(greth->regs->control, GRETH_TXEN);\r\n}\r\nstatic inline void greth_disable_tx(struct greth_private *greth)\r\n{\r\nGRETH_REGANDIN(greth->regs->control, ~GRETH_TXEN);\r\n}\r\nstatic inline void greth_enable_rx(struct greth_private *greth)\r\n{\r\nwmb();\r\nGRETH_REGORIN(greth->regs->control, GRETH_RXEN);\r\n}\r\nstatic inline void greth_disable_rx(struct greth_private *greth)\r\n{\r\nGRETH_REGANDIN(greth->regs->control, ~GRETH_RXEN);\r\n}\r\nstatic inline void greth_enable_irqs(struct greth_private *greth)\r\n{\r\nGRETH_REGORIN(greth->regs->control, GRETH_RXI | GRETH_TXI);\r\n}\r\nstatic inline void greth_disable_irqs(struct greth_private *greth)\r\n{\r\nGRETH_REGANDIN(greth->regs->control, ~(GRETH_RXI|GRETH_TXI));\r\n}\r\nstatic inline void greth_write_bd(u32 *bd, u32 val)\r\n{\r\n__raw_writel(cpu_to_be32(val), bd);\r\n}\r\nstatic inline u32 greth_read_bd(u32 *bd)\r\n{\r\nreturn be32_to_cpu(__raw_readl(bd));\r\n}\r\nstatic void greth_clean_rings(struct greth_private *greth)\r\n{\r\nint i;\r\nstruct greth_bd *rx_bdp = greth->rx_bd_base;\r\nstruct greth_bd *tx_bdp = greth->tx_bd_base;\r\nif (greth->gbit_mac) {\r\nfor (i = 0; i < GRETH_RXBD_NUM; i++, rx_bdp++) {\r\nif (greth->rx_skbuff[i] != NULL) {\r\ndev_kfree_skb(greth->rx_skbuff[i]);\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&rx_bdp->addr),\r\nMAX_FRAME_SIZE+NET_IP_ALIGN,\r\nDMA_FROM_DEVICE);\r\n}\r\n}\r\nwhile (greth->tx_free < GRETH_TXBD_NUM) {\r\nstruct sk_buff *skb = greth->tx_skbuff[greth->tx_last];\r\nint nr_frags = skb_shinfo(skb)->nr_frags;\r\ntx_bdp = greth->tx_bd_base + greth->tx_last;\r\ngreth->tx_last = NEXT_TX(greth->tx_last);\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&tx_bdp->addr),\r\nskb_headlen(skb),\r\nDMA_TO_DEVICE);\r\nfor (i = 0; i < nr_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\ntx_bdp = greth->tx_bd_base + greth->tx_last;\r\ndma_unmap_page(greth->dev,\r\ngreth_read_bd(&tx_bdp->addr),\r\nskb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\ngreth->tx_last = NEXT_TX(greth->tx_last);\r\n}\r\ngreth->tx_free += nr_frags+1;\r\ndev_kfree_skb(skb);\r\n}\r\n} else {\r\nfor (i = 0; i < GRETH_RXBD_NUM; i++, rx_bdp++) {\r\nkfree(greth->rx_bufs[i]);\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&rx_bdp->addr),\r\nMAX_FRAME_SIZE,\r\nDMA_FROM_DEVICE);\r\n}\r\nfor (i = 0; i < GRETH_TXBD_NUM; i++, tx_bdp++) {\r\nkfree(greth->tx_bufs[i]);\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&tx_bdp->addr),\r\nMAX_FRAME_SIZE,\r\nDMA_TO_DEVICE);\r\n}\r\n}\r\n}\r\nstatic int greth_init_rings(struct greth_private *greth)\r\n{\r\nstruct sk_buff *skb;\r\nstruct greth_bd *rx_bd, *tx_bd;\r\nu32 dma_addr;\r\nint i;\r\nrx_bd = greth->rx_bd_base;\r\ntx_bd = greth->tx_bd_base;\r\nif (greth->gbit_mac) {\r\nfor (i = 0; i < GRETH_RXBD_NUM; i++) {\r\nskb = netdev_alloc_skb(greth->netdev, MAX_FRAME_SIZE+NET_IP_ALIGN);\r\nif (skb == NULL) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(greth->dev, "Error allocating DMA ring.\n");\r\ngoto cleanup;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\ndma_addr = dma_map_single(greth->dev,\r\nskb->data,\r\nMAX_FRAME_SIZE+NET_IP_ALIGN,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(greth->dev, dma_addr)) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(greth->dev, "Could not create initial DMA mapping\n");\r\ngoto cleanup;\r\n}\r\ngreth->rx_skbuff[i] = skb;\r\ngreth_write_bd(&rx_bd[i].addr, dma_addr);\r\ngreth_write_bd(&rx_bd[i].stat, GRETH_BD_EN | GRETH_BD_IE);\r\n}\r\n} else {\r\nfor (i = 0; i < GRETH_RXBD_NUM; i++) {\r\ngreth->rx_bufs[i] = kmalloc(MAX_FRAME_SIZE, GFP_KERNEL);\r\nif (greth->rx_bufs[i] == NULL) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(greth->dev, "Error allocating DMA ring.\n");\r\ngoto cleanup;\r\n}\r\ndma_addr = dma_map_single(greth->dev,\r\ngreth->rx_bufs[i],\r\nMAX_FRAME_SIZE,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(greth->dev, dma_addr)) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(greth->dev, "Could not create initial DMA mapping\n");\r\ngoto cleanup;\r\n}\r\ngreth_write_bd(&rx_bd[i].addr, dma_addr);\r\ngreth_write_bd(&rx_bd[i].stat, GRETH_BD_EN | GRETH_BD_IE);\r\n}\r\nfor (i = 0; i < GRETH_TXBD_NUM; i++) {\r\ngreth->tx_bufs[i] = kmalloc(MAX_FRAME_SIZE, GFP_KERNEL);\r\nif (greth->tx_bufs[i] == NULL) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(greth->dev, "Error allocating DMA ring.\n");\r\ngoto cleanup;\r\n}\r\ndma_addr = dma_map_single(greth->dev,\r\ngreth->tx_bufs[i],\r\nMAX_FRAME_SIZE,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(greth->dev, dma_addr)) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(greth->dev, "Could not create initial DMA mapping\n");\r\ngoto cleanup;\r\n}\r\ngreth_write_bd(&tx_bd[i].addr, dma_addr);\r\ngreth_write_bd(&tx_bd[i].stat, 0);\r\n}\r\n}\r\ngreth_write_bd(&rx_bd[GRETH_RXBD_NUM - 1].stat,\r\ngreth_read_bd(&rx_bd[GRETH_RXBD_NUM - 1].stat) | GRETH_BD_WR);\r\ngreth->rx_cur = 0;\r\ngreth->tx_next = 0;\r\ngreth->tx_last = 0;\r\ngreth->tx_free = GRETH_TXBD_NUM;\r\nGRETH_REGSAVE(greth->regs->tx_desc_p, greth->tx_bd_base_phys);\r\nGRETH_REGSAVE(greth->regs->rx_desc_p, greth->rx_bd_base_phys);\r\nreturn 0;\r\ncleanup:\r\ngreth_clean_rings(greth);\r\nreturn -ENOMEM;\r\n}\r\nstatic int greth_open(struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nint err;\r\nerr = greth_init_rings(greth);\r\nif (err) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(&dev->dev, "Could not allocate memory for DMA rings\n");\r\nreturn err;\r\n}\r\nerr = request_irq(greth->irq, greth_interrupt, 0, "eth", (void *) dev);\r\nif (err) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(&dev->dev, "Could not allocate interrupt %d\n", dev->irq);\r\ngreth_clean_rings(greth);\r\nreturn err;\r\n}\r\nif (netif_msg_ifup(greth))\r\ndev_dbg(&dev->dev, " starting queue\n");\r\nnetif_start_queue(dev);\r\nGRETH_REGSAVE(greth->regs->status, 0xFF);\r\nnapi_enable(&greth->napi);\r\ngreth_enable_irqs(greth);\r\ngreth_enable_tx(greth);\r\ngreth_enable_rx(greth);\r\nreturn 0;\r\n}\r\nstatic int greth_close(struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nnapi_disable(&greth->napi);\r\ngreth_disable_irqs(greth);\r\ngreth_disable_tx(greth);\r\ngreth_disable_rx(greth);\r\nnetif_stop_queue(dev);\r\nfree_irq(greth->irq, (void *) dev);\r\ngreth_clean_rings(greth);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t\r\ngreth_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct greth_bd *bdp;\r\nint err = NETDEV_TX_OK;\r\nu32 status, dma_addr, ctrl;\r\nunsigned long flags;\r\ngreth_clean_tx(greth->netdev);\r\nif (unlikely(greth->tx_free <= 0)) {\r\nspin_lock_irqsave(&greth->devlock, flags);\r\nctrl = GRETH_REGLOAD(greth->regs->control);\r\nif (ctrl & GRETH_RXI)\r\nGRETH_REGSAVE(greth->regs->control, ctrl | GRETH_TXI);\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (netif_msg_pktdata(greth))\r\ngreth_print_tx_packet(skb);\r\nif (unlikely(skb->len > MAX_FRAME_SIZE)) {\r\ndev->stats.tx_errors++;\r\ngoto out;\r\n}\r\nbdp = greth->tx_bd_base + greth->tx_next;\r\ndma_addr = greth_read_bd(&bdp->addr);\r\nmemcpy((unsigned char *) phys_to_virt(dma_addr), skb->data, skb->len);\r\ndma_sync_single_for_device(greth->dev, dma_addr, skb->len, DMA_TO_DEVICE);\r\nstatus = GRETH_BD_EN | GRETH_BD_IE | (skb->len & GRETH_BD_LEN);\r\ngreth->tx_bufs_length[greth->tx_next] = skb->len & GRETH_BD_LEN;\r\nif (greth->tx_next == GRETH_TXBD_NUM_MASK) {\r\nstatus |= GRETH_BD_WR;\r\n}\r\ngreth->tx_next = NEXT_TX(greth->tx_next);\r\ngreth->tx_free--;\r\ngreth_write_bd(&bdp->stat, status);\r\nspin_lock_irqsave(&greth->devlock, flags);\r\ngreth_enable_tx(greth);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\nout:\r\ndev_kfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic netdev_tx_t\r\ngreth_start_xmit_gbit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct greth_bd *bdp;\r\nu32 status = 0, dma_addr, ctrl;\r\nint curr_tx, nr_frags, i, err = NETDEV_TX_OK;\r\nunsigned long flags;\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\ngreth_clean_tx_gbit(dev);\r\nif (greth->tx_free < nr_frags + 1) {\r\nspin_lock_irqsave(&greth->devlock, flags);\r\nctrl = GRETH_REGLOAD(greth->regs->control);\r\nif (ctrl & GRETH_RXI)\r\nGRETH_REGSAVE(greth->regs->control, ctrl | GRETH_TXI);\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\nerr = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\nif (netif_msg_pktdata(greth))\r\ngreth_print_tx_packet(skb);\r\nif (unlikely(skb->len > MAX_FRAME_SIZE)) {\r\ndev->stats.tx_errors++;\r\ngoto out;\r\n}\r\ngreth->tx_skbuff[greth->tx_next] = skb;\r\nif (nr_frags != 0)\r\nstatus = GRETH_TXBD_MORE;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nstatus |= GRETH_TXBD_CSALL;\r\nstatus |= skb_headlen(skb) & GRETH_BD_LEN;\r\nif (greth->tx_next == GRETH_TXBD_NUM_MASK)\r\nstatus |= GRETH_BD_WR;\r\nbdp = greth->tx_bd_base + greth->tx_next;\r\ngreth_write_bd(&bdp->stat, status);\r\ndma_addr = dma_map_single(greth->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(greth->dev, dma_addr)))\r\ngoto map_error;\r\ngreth_write_bd(&bdp->addr, dma_addr);\r\ncurr_tx = NEXT_TX(greth->tx_next);\r\nfor (i = 0; i < nr_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\ngreth->tx_skbuff[curr_tx] = NULL;\r\nbdp = greth->tx_bd_base + curr_tx;\r\nstatus = GRETH_BD_EN;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nstatus |= GRETH_TXBD_CSALL;\r\nstatus |= skb_frag_size(frag) & GRETH_BD_LEN;\r\nif (curr_tx == GRETH_TXBD_NUM_MASK)\r\nstatus |= GRETH_BD_WR;\r\nif (i < nr_frags - 1)\r\nstatus |= GRETH_TXBD_MORE;\r\nelse\r\nstatus |= GRETH_BD_IE;\r\ngreth_write_bd(&bdp->stat, status);\r\ndma_addr = skb_frag_dma_map(greth->dev, frag, 0, skb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(greth->dev, dma_addr)))\r\ngoto frag_map_error;\r\ngreth_write_bd(&bdp->addr, dma_addr);\r\ncurr_tx = NEXT_TX(curr_tx);\r\n}\r\nwmb();\r\nbdp = greth->tx_bd_base + greth->tx_next;\r\ngreth_write_bd(&bdp->stat, greth_read_bd(&bdp->stat) | GRETH_BD_EN);\r\ngreth->tx_next = curr_tx;\r\ngreth->tx_free -= nr_frags + 1;\r\nwmb();\r\nspin_lock_irqsave(&greth->devlock, flags);\r\ngreth_enable_tx(greth);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\nreturn NETDEV_TX_OK;\r\nfrag_map_error:\r\nfor (i = 0; greth->tx_next + i != curr_tx; i++) {\r\nbdp = greth->tx_bd_base + greth->tx_next + i;\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&bdp->addr),\r\ngreth_read_bd(&bdp->stat) & GRETH_BD_LEN,\r\nDMA_TO_DEVICE);\r\ngreth_write_bd(&bdp->stat, 0);\r\n}\r\nmap_error:\r\nif (net_ratelimit())\r\ndev_warn(greth->dev, "Could not create TX DMA mapping\n");\r\ndev_kfree_skb(skb);\r\nout:\r\nreturn err;\r\n}\r\nstatic irqreturn_t greth_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct greth_private *greth;\r\nu32 status, ctrl;\r\nirqreturn_t retval = IRQ_NONE;\r\ngreth = netdev_priv(dev);\r\nspin_lock(&greth->devlock);\r\nstatus = GRETH_REGLOAD(greth->regs->status);\r\nctrl = GRETH_REGLOAD(greth->regs->control);\r\nif (((status & (GRETH_INT_RE | GRETH_INT_RX)) && (ctrl & GRETH_RXI)) ||\r\n((status & (GRETH_INT_TE | GRETH_INT_TX)) && (ctrl & GRETH_TXI))) {\r\nretval = IRQ_HANDLED;\r\ngreth_disable_irqs(greth);\r\nnapi_schedule(&greth->napi);\r\n}\r\nmmiowb();\r\nspin_unlock(&greth->devlock);\r\nreturn retval;\r\n}\r\nstatic void greth_clean_tx(struct net_device *dev)\r\n{\r\nstruct greth_private *greth;\r\nstruct greth_bd *bdp;\r\nu32 stat;\r\ngreth = netdev_priv(dev);\r\nwhile (1) {\r\nbdp = greth->tx_bd_base + greth->tx_last;\r\nGRETH_REGSAVE(greth->regs->status, GRETH_INT_TE | GRETH_INT_TX);\r\nmb();\r\nstat = greth_read_bd(&bdp->stat);\r\nif (unlikely(stat & GRETH_BD_EN))\r\nbreak;\r\nif (greth->tx_free == GRETH_TXBD_NUM)\r\nbreak;\r\nif (unlikely(stat & GRETH_TXBD_STATUS)) {\r\ndev->stats.tx_errors++;\r\nif (stat & GRETH_TXBD_ERR_AL)\r\ndev->stats.tx_aborted_errors++;\r\nif (stat & GRETH_TXBD_ERR_UE)\r\ndev->stats.tx_fifo_errors++;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += greth->tx_bufs_length[greth->tx_last];\r\ngreth->tx_last = NEXT_TX(greth->tx_last);\r\ngreth->tx_free++;\r\n}\r\nif (greth->tx_free > 0) {\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic inline void greth_update_tx_stats(struct net_device *dev, u32 stat)\r\n{\r\nif (unlikely(stat & GRETH_TXBD_STATUS)) {\r\ndev->stats.tx_errors++;\r\nif (stat & GRETH_TXBD_ERR_AL)\r\ndev->stats.tx_aborted_errors++;\r\nif (stat & GRETH_TXBD_ERR_UE)\r\ndev->stats.tx_fifo_errors++;\r\nif (stat & GRETH_TXBD_ERR_LC)\r\ndev->stats.tx_aborted_errors++;\r\n}\r\ndev->stats.tx_packets++;\r\n}\r\nstatic void greth_clean_tx_gbit(struct net_device *dev)\r\n{\r\nstruct greth_private *greth;\r\nstruct greth_bd *bdp, *bdp_last_frag;\r\nstruct sk_buff *skb;\r\nu32 stat;\r\nint nr_frags, i;\r\ngreth = netdev_priv(dev);\r\nwhile (greth->tx_free < GRETH_TXBD_NUM) {\r\nskb = greth->tx_skbuff[greth->tx_last];\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\nbdp_last_frag = greth->tx_bd_base + SKIP_TX(greth->tx_last, nr_frags);\r\nGRETH_REGSAVE(greth->regs->status, GRETH_INT_TE | GRETH_INT_TX);\r\nmb();\r\nstat = greth_read_bd(&bdp_last_frag->stat);\r\nif (stat & GRETH_BD_EN)\r\nbreak;\r\ngreth->tx_skbuff[greth->tx_last] = NULL;\r\ngreth_update_tx_stats(dev, stat);\r\ndev->stats.tx_bytes += skb->len;\r\nbdp = greth->tx_bd_base + greth->tx_last;\r\ngreth->tx_last = NEXT_TX(greth->tx_last);\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&bdp->addr),\r\nskb_headlen(skb),\r\nDMA_TO_DEVICE);\r\nfor (i = 0; i < nr_frags; i++) {\r\nskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\r\nbdp = greth->tx_bd_base + greth->tx_last;\r\ndma_unmap_page(greth->dev,\r\ngreth_read_bd(&bdp->addr),\r\nskb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\ngreth->tx_last = NEXT_TX(greth->tx_last);\r\n}\r\ngreth->tx_free += nr_frags+1;\r\ndev_kfree_skb(skb);\r\n}\r\nif (netif_queue_stopped(dev) && (greth->tx_free > (MAX_SKB_FRAGS+1)))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int greth_rx(struct net_device *dev, int limit)\r\n{\r\nstruct greth_private *greth;\r\nstruct greth_bd *bdp;\r\nstruct sk_buff *skb;\r\nint pkt_len;\r\nint bad, count;\r\nu32 status, dma_addr;\r\nunsigned long flags;\r\ngreth = netdev_priv(dev);\r\nfor (count = 0; count < limit; ++count) {\r\nbdp = greth->rx_bd_base + greth->rx_cur;\r\nGRETH_REGSAVE(greth->regs->status, GRETH_INT_RE | GRETH_INT_RX);\r\nmb();\r\nstatus = greth_read_bd(&bdp->stat);\r\nif (unlikely(status & GRETH_BD_EN)) {\r\nbreak;\r\n}\r\ndma_addr = greth_read_bd(&bdp->addr);\r\nbad = 0;\r\nif (unlikely(status & GRETH_RXBD_STATUS)) {\r\nif (status & GRETH_RXBD_ERR_FT) {\r\ndev->stats.rx_length_errors++;\r\nbad = 1;\r\n}\r\nif (status & (GRETH_RXBD_ERR_AE | GRETH_RXBD_ERR_OE)) {\r\ndev->stats.rx_frame_errors++;\r\nbad = 1;\r\n}\r\nif (status & GRETH_RXBD_ERR_CRC) {\r\ndev->stats.rx_crc_errors++;\r\nbad = 1;\r\n}\r\n}\r\nif (unlikely(bad)) {\r\ndev->stats.rx_errors++;\r\n} else {\r\npkt_len = status & GRETH_BD_LEN;\r\nskb = netdev_alloc_skb(dev, pkt_len + NET_IP_ALIGN);\r\nif (unlikely(skb == NULL)) {\r\nif (net_ratelimit())\r\ndev_warn(&dev->dev, "low on memory - " "packet dropped\n");\r\ndev->stats.rx_dropped++;\r\n} else {\r\nskb_reserve(skb, NET_IP_ALIGN);\r\ndma_sync_single_for_cpu(greth->dev,\r\ndma_addr,\r\npkt_len,\r\nDMA_FROM_DEVICE);\r\nif (netif_msg_pktdata(greth))\r\ngreth_print_rx_packet(phys_to_virt(dma_addr), pkt_len);\r\nmemcpy(skb_put(skb, pkt_len), phys_to_virt(dma_addr), pkt_len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_bytes += pkt_len;\r\ndev->stats.rx_packets++;\r\nnetif_receive_skb(skb);\r\n}\r\n}\r\nstatus = GRETH_BD_EN | GRETH_BD_IE;\r\nif (greth->rx_cur == GRETH_RXBD_NUM_MASK) {\r\nstatus |= GRETH_BD_WR;\r\n}\r\nwmb();\r\ngreth_write_bd(&bdp->stat, status);\r\ndma_sync_single_for_device(greth->dev, dma_addr, MAX_FRAME_SIZE, DMA_FROM_DEVICE);\r\nspin_lock_irqsave(&greth->devlock, flags);\r\ngreth_enable_rx(greth);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\ngreth->rx_cur = NEXT_RX(greth->rx_cur);\r\n}\r\nreturn count;\r\n}\r\nstatic inline int hw_checksummed(u32 status)\r\n{\r\nif (status & GRETH_RXBD_IP_FRAG)\r\nreturn 0;\r\nif (status & GRETH_RXBD_IP && status & GRETH_RXBD_IP_CSERR)\r\nreturn 0;\r\nif (status & GRETH_RXBD_UDP && status & GRETH_RXBD_UDP_CSERR)\r\nreturn 0;\r\nif (status & GRETH_RXBD_TCP && status & GRETH_RXBD_TCP_CSERR)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int greth_rx_gbit(struct net_device *dev, int limit)\r\n{\r\nstruct greth_private *greth;\r\nstruct greth_bd *bdp;\r\nstruct sk_buff *skb, *newskb;\r\nint pkt_len;\r\nint bad, count = 0;\r\nu32 status, dma_addr;\r\nunsigned long flags;\r\ngreth = netdev_priv(dev);\r\nfor (count = 0; count < limit; ++count) {\r\nbdp = greth->rx_bd_base + greth->rx_cur;\r\nskb = greth->rx_skbuff[greth->rx_cur];\r\nGRETH_REGSAVE(greth->regs->status, GRETH_INT_RE | GRETH_INT_RX);\r\nmb();\r\nstatus = greth_read_bd(&bdp->stat);\r\nbad = 0;\r\nif (status & GRETH_BD_EN)\r\nbreak;\r\nif (unlikely(status & GRETH_RXBD_STATUS)) {\r\nif (status & GRETH_RXBD_ERR_FT) {\r\ndev->stats.rx_length_errors++;\r\nbad = 1;\r\n} else if (status &\r\n(GRETH_RXBD_ERR_AE | GRETH_RXBD_ERR_OE | GRETH_RXBD_ERR_LE)) {\r\ndev->stats.rx_frame_errors++;\r\nbad = 1;\r\n} else if (status & GRETH_RXBD_ERR_CRC) {\r\ndev->stats.rx_crc_errors++;\r\nbad = 1;\r\n}\r\n}\r\nif (!bad && (newskb=netdev_alloc_skb(dev, MAX_FRAME_SIZE + NET_IP_ALIGN))) {\r\nskb_reserve(newskb, NET_IP_ALIGN);\r\ndma_addr = dma_map_single(greth->dev,\r\nnewskb->data,\r\nMAX_FRAME_SIZE + NET_IP_ALIGN,\r\nDMA_FROM_DEVICE);\r\nif (!dma_mapping_error(greth->dev, dma_addr)) {\r\npkt_len = status & GRETH_BD_LEN;\r\ndma_unmap_single(greth->dev,\r\ngreth_read_bd(&bdp->addr),\r\nMAX_FRAME_SIZE + NET_IP_ALIGN,\r\nDMA_FROM_DEVICE);\r\nif (netif_msg_pktdata(greth))\r\ngreth_print_rx_packet(phys_to_virt(greth_read_bd(&bdp->addr)), pkt_len);\r\nskb_put(skb, pkt_len);\r\nif (dev->features & NETIF_F_RXCSUM && hw_checksummed(status))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb_checksum_none_assert(skb);\r\nskb->protocol = eth_type_trans(skb, dev);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\nnetif_receive_skb(skb);\r\ngreth->rx_skbuff[greth->rx_cur] = newskb;\r\ngreth_write_bd(&bdp->addr, dma_addr);\r\n} else {\r\nif (net_ratelimit())\r\ndev_warn(greth->dev, "Could not create DMA mapping, dropping packet\n");\r\ndev_kfree_skb(newskb);\r\ndev->stats.rx_dropped++;\r\n}\r\n} else if (bad) {\r\ndev->stats.rx_dropped++;\r\n} else {\r\nif (net_ratelimit())\r\ndev_warn(greth->dev, "Could not allocate SKB, dropping packet\n");\r\ndev->stats.rx_dropped++;\r\n}\r\nstatus = GRETH_BD_EN | GRETH_BD_IE;\r\nif (greth->rx_cur == GRETH_RXBD_NUM_MASK) {\r\nstatus |= GRETH_BD_WR;\r\n}\r\nwmb();\r\ngreth_write_bd(&bdp->stat, status);\r\nspin_lock_irqsave(&greth->devlock, flags);\r\ngreth_enable_rx(greth);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\ngreth->rx_cur = NEXT_RX(greth->rx_cur);\r\n}\r\nreturn count;\r\n}\r\nstatic int greth_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct greth_private *greth;\r\nint work_done = 0;\r\nunsigned long flags;\r\nu32 mask, ctrl;\r\ngreth = container_of(napi, struct greth_private, napi);\r\nrestart_txrx_poll:\r\nif (netif_queue_stopped(greth->netdev)) {\r\nif (greth->gbit_mac)\r\ngreth_clean_tx_gbit(greth->netdev);\r\nelse\r\ngreth_clean_tx(greth->netdev);\r\n}\r\nif (greth->gbit_mac) {\r\nwork_done += greth_rx_gbit(greth->netdev, budget - work_done);\r\n} else {\r\nwork_done += greth_rx(greth->netdev, budget - work_done);\r\n}\r\nif (work_done < budget) {\r\nspin_lock_irqsave(&greth->devlock, flags);\r\nctrl = GRETH_REGLOAD(greth->regs->control);\r\nif (netif_queue_stopped(greth->netdev)) {\r\nGRETH_REGSAVE(greth->regs->control,\r\nctrl | GRETH_TXI | GRETH_RXI);\r\nmask = GRETH_INT_RX | GRETH_INT_RE |\r\nGRETH_INT_TX | GRETH_INT_TE;\r\n} else {\r\nGRETH_REGSAVE(greth->regs->control, ctrl | GRETH_RXI);\r\nmask = GRETH_INT_RX | GRETH_INT_RE;\r\n}\r\nif (GRETH_REGLOAD(greth->regs->status) & mask) {\r\nGRETH_REGSAVE(greth->regs->control, ctrl);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\ngoto restart_txrx_poll;\r\n} else {\r\n__napi_complete(napi);\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\n}\r\n}\r\nreturn work_done;\r\n}\r\nstatic int greth_set_mac_add(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nstruct greth_private *greth;\r\nstruct greth_regs *regs;\r\ngreth = netdev_priv(dev);\r\nregs = (struct greth_regs *) greth->regs;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nGRETH_REGSAVE(regs->esa_msb, dev->dev_addr[0] << 8 | dev->dev_addr[1]);\r\nGRETH_REGSAVE(regs->esa_lsb, dev->dev_addr[2] << 24 | dev->dev_addr[3] << 16 |\r\ndev->dev_addr[4] << 8 | dev->dev_addr[5]);\r\nreturn 0;\r\n}\r\nstatic u32 greth_hash_get_index(__u8 *addr)\r\n{\r\nreturn (ether_crc(6, addr)) & 0x3F;\r\n}\r\nstatic void greth_set_hash_filter(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct greth_regs *regs = (struct greth_regs *) greth->regs;\r\nu32 mc_filter[2];\r\nunsigned int bitnr;\r\nmc_filter[0] = mc_filter[1] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nbitnr = greth_hash_get_index(ha->addr);\r\nmc_filter[bitnr >> 5] |= 1 << (bitnr & 31);\r\n}\r\nGRETH_REGSAVE(regs->hash_msb, mc_filter[1]);\r\nGRETH_REGSAVE(regs->hash_lsb, mc_filter[0]);\r\n}\r\nstatic void greth_set_multicast_list(struct net_device *dev)\r\n{\r\nint cfg;\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct greth_regs *regs = (struct greth_regs *) greth->regs;\r\ncfg = GRETH_REGLOAD(regs->control);\r\nif (dev->flags & IFF_PROMISC)\r\ncfg |= GRETH_CTRL_PR;\r\nelse\r\ncfg &= ~GRETH_CTRL_PR;\r\nif (greth->multicast) {\r\nif (dev->flags & IFF_ALLMULTI) {\r\nGRETH_REGSAVE(regs->hash_msb, -1);\r\nGRETH_REGSAVE(regs->hash_lsb, -1);\r\ncfg |= GRETH_CTRL_MCEN;\r\nGRETH_REGSAVE(regs->control, cfg);\r\nreturn;\r\n}\r\nif (netdev_mc_empty(dev)) {\r\ncfg &= ~GRETH_CTRL_MCEN;\r\nGRETH_REGSAVE(regs->control, cfg);\r\nreturn;\r\n}\r\ngreth_set_hash_filter(dev);\r\ncfg |= GRETH_CTRL_MCEN;\r\n}\r\nGRETH_REGSAVE(regs->control, cfg);\r\n}\r\nstatic u32 greth_get_msglevel(struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nreturn greth->msg_enable;\r\n}\r\nstatic void greth_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\ngreth->msg_enable = value;\r\n}\r\nstatic int greth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct phy_device *phy = greth->phy;\r\nif (!phy)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(phy, cmd);\r\n}\r\nstatic int greth_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct phy_device *phy = greth->phy;\r\nif (!phy)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(phy, cmd);\r\n}\r\nstatic int greth_get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(struct greth_regs);\r\n}\r\nstatic void greth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstrncpy(info->driver, dev_driver_string(greth->dev), 32);\r\nstrncpy(info->version, "revision: 1.0", 32);\r\nstrncpy(info->bus_info, greth->dev->bus->name, 32);\r\nstrncpy(info->fw_version, "N/A", 32);\r\ninfo->eedump_len = 0;\r\ninfo->regdump_len = sizeof(struct greth_regs);\r\n}\r\nstatic void greth_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\r\n{\r\nint i;\r\nstruct greth_private *greth = netdev_priv(dev);\r\nu32 __iomem *greth_regs = (u32 __iomem *) greth->regs;\r\nu32 *buff = p;\r\nfor (i = 0; i < sizeof(struct greth_regs) / sizeof(u32); i++)\r\nbuff[i] = greth_read_bd(&greth_regs[i]);\r\n}\r\nstatic inline int wait_for_mdio(struct greth_private *greth)\r\n{\r\nunsigned long timeout = jiffies + 4*HZ/100;\r\nwhile (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {\r\nif (time_after(jiffies, timeout))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int greth_mdio_read(struct mii_bus *bus, int phy, int reg)\r\n{\r\nstruct greth_private *greth = bus->priv;\r\nint data;\r\nif (!wait_for_mdio(greth))\r\nreturn -EBUSY;\r\nGRETH_REGSAVE(greth->regs->mdio, ((phy & 0x1F) << 11) | ((reg & 0x1F) << 6) | 2);\r\nif (!wait_for_mdio(greth))\r\nreturn -EBUSY;\r\nif (!(GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_NVALID)) {\r\ndata = (GRETH_REGLOAD(greth->regs->mdio) >> 16) & 0xFFFF;\r\nreturn data;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nstatic int greth_mdio_write(struct mii_bus *bus, int phy, int reg, u16 val)\r\n{\r\nstruct greth_private *greth = bus->priv;\r\nif (!wait_for_mdio(greth))\r\nreturn -EBUSY;\r\nGRETH_REGSAVE(greth->regs->mdio,\r\n((val & 0xFFFF) << 16) | ((phy & 0x1F) << 11) | ((reg & 0x1F) << 6) | 1);\r\nif (!wait_for_mdio(greth))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int greth_mdio_reset(struct mii_bus *bus)\r\n{\r\nreturn 0;\r\n}\r\nstatic void greth_link_change(struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct phy_device *phydev = greth->phy;\r\nunsigned long flags;\r\nint status_change = 0;\r\nu32 ctrl;\r\nspin_lock_irqsave(&greth->devlock, flags);\r\nif (phydev->link) {\r\nif ((greth->speed != phydev->speed) || (greth->duplex != phydev->duplex)) {\r\nctrl = GRETH_REGLOAD(greth->regs->control) &\r\n~(GRETH_CTRL_FD | GRETH_CTRL_SP | GRETH_CTRL_GB);\r\nif (phydev->duplex)\r\nctrl |= GRETH_CTRL_FD;\r\nif (phydev->speed == SPEED_100)\r\nctrl |= GRETH_CTRL_SP;\r\nelse if (phydev->speed == SPEED_1000)\r\nctrl |= GRETH_CTRL_GB;\r\nGRETH_REGSAVE(greth->regs->control, ctrl);\r\ngreth->speed = phydev->speed;\r\ngreth->duplex = phydev->duplex;\r\nstatus_change = 1;\r\n}\r\n}\r\nif (phydev->link != greth->link) {\r\nif (!phydev->link) {\r\ngreth->speed = 0;\r\ngreth->duplex = -1;\r\n}\r\ngreth->link = phydev->link;\r\nstatus_change = 1;\r\n}\r\nspin_unlock_irqrestore(&greth->devlock, flags);\r\nif (status_change) {\r\nif (phydev->link)\r\npr_debug("%s: link up (%d/%s)\n",\r\ndev->name, phydev->speed,\r\nDUPLEX_FULL == phydev->duplex ? "Full" : "Half");\r\nelse\r\npr_debug("%s: link down\n", dev->name);\r\n}\r\n}\r\nstatic int greth_mdio_probe(struct net_device *dev)\r\n{\r\nstruct greth_private *greth = netdev_priv(dev);\r\nstruct phy_device *phy = NULL;\r\nint ret;\r\nphy = phy_find_first(greth->mdio);\r\nif (!phy) {\r\nif (netif_msg_probe(greth))\r\ndev_err(&dev->dev, "no PHY found\n");\r\nreturn -ENXIO;\r\n}\r\nret = phy_connect_direct(dev, phy, &greth_link_change,\r\n0, greth->gbit_mac ?\r\nPHY_INTERFACE_MODE_GMII :\r\nPHY_INTERFACE_MODE_MII);\r\nif (ret) {\r\nif (netif_msg_ifup(greth))\r\ndev_err(&dev->dev, "could not attach to PHY\n");\r\nreturn ret;\r\n}\r\nif (greth->gbit_mac)\r\nphy->supported &= PHY_GBIT_FEATURES;\r\nelse\r\nphy->supported &= PHY_BASIC_FEATURES;\r\nphy->advertising = phy->supported;\r\ngreth->link = 0;\r\ngreth->speed = 0;\r\ngreth->duplex = -1;\r\ngreth->phy = phy;\r\nreturn 0;\r\n}\r\nstatic inline int phy_aneg_done(struct phy_device *phydev)\r\n{\r\nint retval;\r\nretval = phy_read(phydev, MII_BMSR);\r\nreturn (retval < 0) ? retval : (retval & BMSR_ANEGCOMPLETE);\r\n}\r\nstatic int greth_mdio_init(struct greth_private *greth)\r\n{\r\nint ret, phy;\r\nunsigned long timeout;\r\ngreth->mdio = mdiobus_alloc();\r\nif (!greth->mdio) {\r\nreturn -ENOMEM;\r\n}\r\ngreth->mdio->name = "greth-mdio";\r\nsnprintf(greth->mdio->id, MII_BUS_ID_SIZE, "%s-%d", greth->mdio->name, greth->irq);\r\ngreth->mdio->read = greth_mdio_read;\r\ngreth->mdio->write = greth_mdio_write;\r\ngreth->mdio->reset = greth_mdio_reset;\r\ngreth->mdio->priv = greth;\r\ngreth->mdio->irq = greth->mdio_irqs;\r\nfor (phy = 0; phy < PHY_MAX_ADDR; phy++)\r\ngreth->mdio->irq[phy] = PHY_POLL;\r\nret = mdiobus_register(greth->mdio);\r\nif (ret) {\r\ngoto error;\r\n}\r\nret = greth_mdio_probe(greth->netdev);\r\nif (ret) {\r\nif (netif_msg_probe(greth))\r\ndev_err(&greth->netdev->dev, "failed to probe MDIO bus\n");\r\ngoto unreg_mdio;\r\n}\r\nphy_start(greth->phy);\r\nif (greth->edcl && greth_edcl == 1) {\r\nphy_start_aneg(greth->phy);\r\ntimeout = jiffies + 6*HZ;\r\nwhile (!phy_aneg_done(greth->phy) && time_before(jiffies, timeout)) {\r\n}\r\ngenphy_read_status(greth->phy);\r\ngreth_link_change(greth->netdev);\r\n}\r\nreturn 0;\r\nunreg_mdio:\r\nmdiobus_unregister(greth->mdio);\r\nerror:\r\nmdiobus_free(greth->mdio);\r\nreturn ret;\r\n}\r\nstatic int __devinit greth_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct net_device *dev;\r\nstruct greth_private *greth;\r\nstruct greth_regs *regs;\r\nint i;\r\nint err;\r\nint tmp;\r\nunsigned long timeout;\r\ndev = alloc_etherdev(sizeof(struct greth_private));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ngreth = netdev_priv(dev);\r\ngreth->netdev = dev;\r\ngreth->dev = &ofdev->dev;\r\nif (greth_debug > 0)\r\ngreth->msg_enable = greth_debug;\r\nelse\r\ngreth->msg_enable = GRETH_DEF_MSG_ENABLE;\r\nspin_lock_init(&greth->devlock);\r\ngreth->regs = of_ioremap(&ofdev->resource[0], 0,\r\nresource_size(&ofdev->resource[0]),\r\n"grlib-greth regs");\r\nif (greth->regs == NULL) {\r\nif (netif_msg_probe(greth))\r\ndev_err(greth->dev, "ioremap failure.\n");\r\nerr = -EIO;\r\ngoto error1;\r\n}\r\nregs = (struct greth_regs *) greth->regs;\r\ngreth->irq = ofdev->archdata.irqs[0];\r\ndev_set_drvdata(greth->dev, dev);\r\nSET_NETDEV_DEV(dev, greth->dev);\r\nif (netif_msg_probe(greth))\r\ndev_dbg(greth->dev, "resetting controller.\n");\r\nGRETH_REGSAVE(regs->control, GRETH_RESET);\r\ntimeout = jiffies + HZ/100;\r\nwhile (GRETH_REGLOAD(regs->control) & GRETH_RESET) {\r\nif (time_after(jiffies, timeout)) {\r\nerr = -EIO;\r\nif (netif_msg_probe(greth))\r\ndev_err(greth->dev, "timeout when waiting for reset.\n");\r\ngoto error2;\r\n}\r\n}\r\ngreth->phyaddr = (GRETH_REGLOAD(regs->mdio) >> 11) & 0x1F;\r\ntmp = GRETH_REGLOAD(regs->control);\r\ngreth->gbit_mac = (tmp >> 27) & 1;\r\ngreth->multicast = (tmp >> 25) & 1;\r\ngreth->edcl = (tmp >> 31) & 1;\r\nif (greth->edcl != 0)\r\nGRETH_REGORIN(regs->control, GRETH_CTRL_DISDUPLEX);\r\ngreth->mdio_int_en = (tmp >> 26) & 1;\r\nerr = greth_mdio_init(greth);\r\nif (err) {\r\nif (netif_msg_probe(greth))\r\ndev_err(greth->dev, "failed to register MDIO bus\n");\r\ngoto error2;\r\n}\r\ngreth->tx_bd_base = (struct greth_bd *) dma_alloc_coherent(greth->dev,\r\n1024,\r\n&greth->tx_bd_base_phys,\r\nGFP_KERNEL);\r\nif (!greth->tx_bd_base) {\r\nif (netif_msg_probe(greth))\r\ndev_err(&dev->dev, "could not allocate descriptor memory.\n");\r\nerr = -ENOMEM;\r\ngoto error3;\r\n}\r\nmemset(greth->tx_bd_base, 0, 1024);\r\ngreth->rx_bd_base = (struct greth_bd *) dma_alloc_coherent(greth->dev,\r\n1024,\r\n&greth->rx_bd_base_phys,\r\nGFP_KERNEL);\r\nif (!greth->rx_bd_base) {\r\nif (netif_msg_probe(greth))\r\ndev_err(greth->dev, "could not allocate descriptor memory.\n");\r\nerr = -ENOMEM;\r\ngoto error4;\r\n}\r\nmemset(greth->rx_bd_base, 0, 1024);\r\nfor (i = 0; i < 6; i++) {\r\nif (macaddr[i] != 0)\r\nbreak;\r\n}\r\nif (i == 6) {\r\nconst unsigned char *addr;\r\nint len;\r\naddr = of_get_property(ofdev->dev.of_node, "local-mac-address",\r\n&len);\r\nif (addr != NULL && len == 6) {\r\nfor (i = 0; i < 6; i++)\r\nmacaddr[i] = (unsigned int) addr[i];\r\n} else {\r\n#ifdef CONFIG_SPARC\r\nfor (i = 0; i < 6; i++)\r\nmacaddr[i] = (unsigned int) idprom->id_ethaddr[i];\r\n#endif\r\n}\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = macaddr[i];\r\nmacaddr[5]++;\r\nif (!is_valid_ether_addr(&dev->dev_addr[0])) {\r\nif (netif_msg_probe(greth))\r\ndev_err(greth->dev, "no valid ethernet address, aborting.\n");\r\nerr = -EINVAL;\r\ngoto error5;\r\n}\r\nGRETH_REGSAVE(regs->esa_msb, dev->dev_addr[0] << 8 | dev->dev_addr[1]);\r\nGRETH_REGSAVE(regs->esa_lsb, dev->dev_addr[2] << 24 | dev->dev_addr[3] << 16 |\r\ndev->dev_addr[4] << 8 | dev->dev_addr[5]);\r\nGRETH_REGSAVE(regs->status, 0xFF);\r\nif (greth->gbit_mac) {\r\ndev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |\r\nNETIF_F_RXCSUM;\r\ndev->features = dev->hw_features | NETIF_F_HIGHDMA;\r\ngreth_netdev_ops.ndo_start_xmit = greth_start_xmit_gbit;\r\n}\r\nif (greth->multicast) {\r\ngreth_netdev_ops.ndo_set_rx_mode = greth_set_multicast_list;\r\ndev->flags |= IFF_MULTICAST;\r\n} else {\r\ndev->flags &= ~IFF_MULTICAST;\r\n}\r\ndev->netdev_ops = &greth_netdev_ops;\r\ndev->ethtool_ops = &greth_ethtool_ops;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nif (netif_msg_probe(greth))\r\ndev_err(greth->dev, "netdevice registration failed.\n");\r\ngoto error5;\r\n}\r\nnetif_napi_add(dev, &greth->napi, greth_poll, 64);\r\nreturn 0;\r\nerror5:\r\ndma_free_coherent(greth->dev, 1024, greth->rx_bd_base, greth->rx_bd_base_phys);\r\nerror4:\r\ndma_free_coherent(greth->dev, 1024, greth->tx_bd_base, greth->tx_bd_base_phys);\r\nerror3:\r\nmdiobus_unregister(greth->mdio);\r\nerror2:\r\nof_iounmap(&ofdev->resource[0], greth->regs, resource_size(&ofdev->resource[0]));\r\nerror1:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int __devexit greth_of_remove(struct platform_device *of_dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(&of_dev->dev);\r\nstruct greth_private *greth = netdev_priv(ndev);\r\ndma_free_coherent(&of_dev->dev, 1024, greth->rx_bd_base, greth->rx_bd_base_phys);\r\ndma_free_coherent(&of_dev->dev, 1024, greth->tx_bd_base, greth->tx_bd_base_phys);\r\ndev_set_drvdata(&of_dev->dev, NULL);\r\nif (greth->phy)\r\nphy_stop(greth->phy);\r\nmdiobus_unregister(greth->mdio);\r\nunregister_netdev(ndev);\r\nfree_netdev(ndev);\r\nof_iounmap(&of_dev->resource[0], greth->regs, resource_size(&of_dev->resource[0]));\r\nreturn 0;\r\n}
