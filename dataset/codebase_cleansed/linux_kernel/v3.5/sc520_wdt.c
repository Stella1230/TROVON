static void wdt_timer_ping(unsigned long data)\r\n{\r\nif (time_before(jiffies, next_heartbeat)) {\r\nspin_lock(&wdt_spinlock);\r\nwritew(0xAAAA, wdtmrctl);\r\nwritew(0x5555, wdtmrctl);\r\nspin_unlock(&wdt_spinlock);\r\nmod_timer(&timer, jiffies + WDT_INTERVAL);\r\n} else\r\npr_warn("Heartbeat lost! Will not ping the watchdog\n");\r\n}\r\nstatic void wdt_config(int writeval)\r\n{\r\n__u16 dummy;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wdt_spinlock, flags);\r\ndummy = readw(wdtmrctl);\r\nwritew(0xAAAA, wdtmrctl);\r\nwritew(0x5555, wdtmrctl);\r\nwritew(0x3333, wdtmrctl);\r\nwritew(0xCCCC, wdtmrctl);\r\nwritew(writeval, wdtmrctl);\r\nspin_unlock_irqrestore(&wdt_spinlock, flags);\r\n}\r\nstatic int wdt_startup(void)\r\n{\r\nnext_heartbeat = jiffies + (timeout * HZ);\r\nmod_timer(&timer, jiffies + WDT_INTERVAL);\r\nwdt_config(WDT_ENB | WDT_WRST_ENB | WDT_EXP_SEL_04);\r\npr_info("Watchdog timer is now enabled\n");\r\nreturn 0;\r\n}\r\nstatic int wdt_turnoff(void)\r\n{\r\ndel_timer(&timer);\r\nwdt_config(0);\r\npr_info("Watchdog timer is now disabled...\n");\r\nreturn 0;\r\n}\r\nstatic int wdt_keepalive(void)\r\n{\r\nnext_heartbeat = jiffies + (timeout * HZ);\r\nreturn 0;\r\n}\r\nstatic int wdt_set_heartbeat(int t)\r\n{\r\nif ((t < 1) || (t > 3600))\r\nreturn -EINVAL;\r\ntimeout = t;\r\nreturn 0;\r\n}\r\nstatic ssize_t fop_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nif (count) {\r\nif (!nowayout) {\r\nsize_t ofs;\r\nwdt_expect_close = 0;\r\nfor (ofs = 0; ofs != count; ofs++) {\r\nchar c;\r\nif (get_user(c, buf + ofs))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nwdt_expect_close = 42;\r\n}\r\n}\r\nwdt_keepalive();\r\n}\r\nreturn count;\r\n}\r\nstatic int fop_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &wdt_is_open))\r\nreturn -EBUSY;\r\nif (nowayout)\r\n__module_get(THIS_MODULE);\r\nwdt_startup();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int fop_close(struct inode *inode, struct file *file)\r\n{\r\nif (wdt_expect_close == 42)\r\nwdt_turnoff();\r\nelse {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\nwdt_keepalive();\r\n}\r\nclear_bit(0, &wdt_is_open);\r\nwdt_expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic long fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nstatic const struct watchdog_info ident = {\r\n.options = WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT\r\n| WDIOF_MAGICCLOSE,\r\n.firmware_version = 1,\r\n.identity = "SC520",\r\n};\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\n{\r\nint new_options, retval = -EINVAL;\r\nif (get_user(new_options, p))\r\nreturn -EFAULT;\r\nif (new_options & WDIOS_DISABLECARD) {\r\nwdt_turnoff();\r\nretval = 0;\r\n}\r\nif (new_options & WDIOS_ENABLECARD) {\r\nwdt_startup();\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\ncase WDIOC_KEEPALIVE:\r\nwdt_keepalive();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\n{\r\nint new_timeout;\r\nif (get_user(new_timeout, p))\r\nreturn -EFAULT;\r\nif (wdt_set_heartbeat(new_timeout))\r\nreturn -EINVAL;\r\nwdt_keepalive();\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timeout, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\nwdt_turnoff();\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __exit sc520_wdt_unload(void)\r\n{\r\nif (!nowayout)\r\nwdt_turnoff();\r\nmisc_deregister(&wdt_miscdev);\r\nunregister_reboot_notifier(&wdt_notifier);\r\niounmap(wdtmrctl);\r\n}\r\nstatic int __init sc520_wdt_init(void)\r\n{\r\nint rc = -EBUSY;\r\nif (wdt_set_heartbeat(timeout)) {\r\nwdt_set_heartbeat(WATCHDOG_TIMEOUT);\r\npr_info("timeout value must be 1 <= timeout <= 3600, using %d\n",\r\nWATCHDOG_TIMEOUT);\r\n}\r\nwdtmrctl = ioremap(MMCR_BASE + OFFS_WDTMRCTL, 2);\r\nif (!wdtmrctl) {\r\npr_err("Unable to remap memory\n");\r\nrc = -ENOMEM;\r\ngoto err_out_region2;\r\n}\r\nrc = register_reboot_notifier(&wdt_notifier);\r\nif (rc) {\r\npr_err("cannot register reboot notifier (err=%d)\n", rc);\r\ngoto err_out_ioremap;\r\n}\r\nrc = misc_register(&wdt_miscdev);\r\nif (rc) {\r\npr_err("cannot register miscdev on minor=%d (err=%d)\n",\r\nWATCHDOG_MINOR, rc);\r\ngoto err_out_notifier;\r\n}\r\npr_info("WDT driver for SC520 initialised. timeout=%d sec (nowayout=%d)\n",\r\ntimeout, nowayout);\r\nreturn 0;\r\nerr_out_notifier:\r\nunregister_reboot_notifier(&wdt_notifier);\r\nerr_out_ioremap:\r\niounmap(wdtmrctl);\r\nerr_out_region2:\r\nreturn rc;\r\n}
