static inline u8 epson1355_read_reg(struct epson1355_par *par, int index)\r\n{\r\nreturn __raw_readb(par->reg_addr + index);\r\n}\r\nstatic inline void epson1355_write_reg(struct epson1355_par *par, u8 data, int index)\r\n{\r\n__raw_writeb(data, par->reg_addr + index);\r\n}\r\nstatic inline u16 epson1355_read_reg16(struct epson1355_par *par, int index)\r\n{\r\nu8 lo = epson1355_read_reg(par, index);\r\nu8 hi = epson1355_read_reg(par, index + 1);\r\nreturn (hi << 8) | lo;\r\n}\r\nstatic inline void epson1355_write_reg16(struct epson1355_par *par, u16 data, int index)\r\n{\r\nu8 lo = data & 0xff;\r\nu8 hi = (data >> 8) & 0xff;\r\nepson1355_write_reg(par, lo, index);\r\nepson1355_write_reg(par, hi, index + 1);\r\n}\r\nstatic inline u32 epson1355_read_reg20(struct epson1355_par *par, int index)\r\n{\r\nu8 b0 = epson1355_read_reg(par, index);\r\nu8 b1 = epson1355_read_reg(par, index + 1);\r\nu8 b2 = epson1355_read_reg(par, index + 2);\r\nreturn (b2 & 0x0f) << 16 | (b1 << 8) | b0;\r\n}\r\nstatic inline void epson1355_write_reg20(struct epson1355_par *par, u32 data, int index)\r\n{\r\nu8 b0 = data & 0xff;\r\nu8 b1 = (data >> 8) & 0xff;\r\nu8 b2 = (data >> 16) & 0x0f;\r\nepson1355_write_reg(par, b0, index);\r\nepson1355_write_reg(par, b1, index + 1);\r\nepson1355_write_reg(par, b2, index + 2);\r\n}\r\nstatic void set_lut(struct epson1355_par *par, u8 index, u8 r, u8 g, u8 b)\r\n{\r\nepson1355_write_reg(par, index, REG_LUT_ADDR);\r\nepson1355_write_reg(par, r, REG_LUT_DATA);\r\nepson1355_write_reg(par, g, REG_LUT_DATA);\r\nepson1355_write_reg(par, b, REG_LUT_DATA);\r\n}\r\nstatic int epson1355fb_setcolreg(unsigned regno, unsigned r, unsigned g,\r\nunsigned b, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct epson1355_par *par = info->par;\r\nif (info->var.grayscale)\r\nr = g = b = (19595 * r + 38470 * g + 7471 * b) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\n((u32 *) info->pseudo_palette)[regno] =\r\n(r & 0xf800) | (g & 0xfc00) >> 5 | (b & 0xf800) >> 11;\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\nset_lut(par, regno, r >> 8, g >> 8, b >> 8);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int epson1355fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct epson1355_par *par = info->par;\r\nu32 start;\r\nif (var->xoffset != 0)\r\nreturn -EINVAL;\r\nif (var->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\nstart = (info->fix.line_length >> 1) * var->yoffset;\r\nepson1355_write_reg20(par, start, REG_SCRN1_DISP_START_ADDR0);\r\nreturn 0;\r\n}\r\nstatic void lcd_enable(struct epson1355_par *par, int enable)\r\n{\r\nu8 mode = epson1355_read_reg(par, REG_DISPLAY_MODE);\r\nif (enable)\r\nmode |= 1;\r\nelse\r\nmode &= ~1;\r\nepson1355_write_reg(par, mode, REG_DISPLAY_MODE);\r\n}\r\nstatic void backlight_enable(int enable)\r\n{\r\nu8 pddr = clps_readb(PDDR);\r\nif (enable)\r\npddr |= (1 << 5);\r\nelse\r\npddr &= ~(1 << 5);\r\nclps_writeb(pddr, PDDR);\r\n}\r\nstatic void backlight_enable(int enable)\r\n{\r\n}\r\nstatic int epson1355fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct epson1355_par *par = info->par;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nlcd_enable(par, 1);\r\nbacklight_enable(1);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nbacklight_enable(0);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nbacklight_enable(0);\r\nlcd_enable(par, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\r\n}\r\nstatic inline void epson1355fb_fb_writel(unsigned long v, unsigned long *a)\r\n{\r\nu16 *p = (u16 *) a;\r\nu16 l = v & 0xffff;\r\nu16 h = v >> 16;\r\nfb_writew(l, p);\r\nfb_writew(h, p + 1);\r\n}\r\nstatic inline unsigned long epson1355fb_fb_readl(const unsigned long *a)\r\n{\r\nconst u16 *p = (u16 *) a;\r\nu16 l = fb_readw(p);\r\nu16 h = fb_readw(p + 1);\r\nreturn (h << 16) | l;\r\n}\r\nstatic inline unsigned long copy_from_user16(void *to, const void *from,\r\nunsigned long n)\r\n{\r\nu16 *dst = (u16 *) to;\r\nu16 *src = (u16 *) from;\r\nif (!access_ok(VERIFY_READ, from, n))\r\nreturn n;\r\nwhile (n > 1) {\r\nu16 v;\r\nif (__get_user(v, src))\r\nreturn n;\r\nfb_writew(v, dst);\r\nsrc++, dst++;\r\nn -= 2;\r\n}\r\nif (n) {\r\nu8 v;\r\nif (__get_user(v, ((u8 *) src)))\r\nreturn n;\r\nfb_writeb(v, dst);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned long copy_to_user16(void *to, const void *from,\r\nunsigned long n)\r\n{\r\nu16 *dst = (u16 *) to;\r\nu16 *src = (u16 *) from;\r\nif (!access_ok(VERIFY_WRITE, to, n))\r\nreturn n;\r\nwhile (n > 1) {\r\nu16 v = fb_readw(src);\r\nif (__put_user(v, dst))\r\nreturn n;\r\nsrc++, dst++;\r\nn -= 2;\r\n}\r\nif (n) {\r\nu8 v = fb_readb(src);\r\nif (__put_user(v, ((u8 *) dst)))\r\nreturn n;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nepson1355fb_read(struct fb_info *info, char *buf, size_t count, loff_t * ppos)\r\n{\r\nunsigned long p = *ppos;\r\nif (p >= info->fix.smem_len)\r\nreturn 0;\r\nif (count >= info->fix.smem_len)\r\ncount = info->fix.smem_len;\r\nif (count + p > info->fix.smem_len)\r\ncount = info->fix.smem_len - p;\r\nif (count) {\r\nchar *base_addr;\r\nbase_addr = info->screen_base;\r\ncount -= copy_to_user16(buf, base_addr + p, count);\r\nif (!count)\r\nreturn -EFAULT;\r\n*ppos += count;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nepson1355fb_write(struct fb_info *info, const char *buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nunsigned long p = *ppos;\r\nint err;\r\nif (p > info->fix.smem_len)\r\nreturn -ENOSPC;\r\nif (count >= info->fix.smem_len)\r\ncount = info->fix.smem_len;\r\nerr = 0;\r\nif (count + p > info->fix.smem_len) {\r\ncount = info->fix.smem_len - p;\r\nerr = -ENOSPC;\r\n}\r\nif (count) {\r\nchar *base_addr;\r\nbase_addr = info->screen_base;\r\ncount -= copy_from_user16(base_addr + p, buf, count);\r\n*ppos += count;\r\nerr = -EFAULT;\r\n}\r\nif (count)\r\nreturn count;\r\nreturn err;\r\n}\r\nstatic __init unsigned int get_fb_size(struct fb_info *info)\r\n{\r\nunsigned int size = 2 * 1024 * 1024;\r\nchar *p = info->screen_base;\r\nfb_writeb(1, p);\r\nfb_writeb(0, p + 0x80000);\r\nif (!fb_readb(p))\r\nsize = 512 * 1024;\r\nfb_writeb(0, p);\r\nreturn size;\r\n}\r\nstatic void __init fetch_hw_state(struct fb_info *info, struct epson1355_par *par)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nu8 panel, display;\r\nu16 offset;\r\nu32 xres, yres;\r\nu32 xres_virtual, yres_virtual;\r\nint bpp, lcd_bpp;\r\nint is_color, is_dual, is_tft;\r\nint lcd_enabled, crt_enabled;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\ndisplay = epson1355_read_reg(par, REG_DISPLAY_MODE);\r\nbpp = epson1355_bpp_tab[(display >> 2) & 7];\r\nswitch (bpp) {\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nvar->bits_per_pixel = 8;\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ncase 16:\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nvar->bits_per_pixel = 16;\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nfb_alloc_cmap(&(info->cmap), 256, 0);\r\npanel = epson1355_read_reg(par, REG_PANEL_TYPE);\r\nis_color = (panel & 0x04) != 0;\r\nis_dual = (panel & 0x02) != 0;\r\nis_tft = (panel & 0x01) != 0;\r\ncrt_enabled = (display & 0x02) != 0;\r\nlcd_enabled = (display & 0x01) != 0;\r\nlcd_bpp = epson1355_width_tab[is_tft][(panel >> 4) & 3];\r\nxres = (epson1355_read_reg(par, REG_HORZ_DISP_WIDTH) + 1) * 8;\r\nyres = (epson1355_read_reg16(par, REG_VERT_DISP_HEIGHT0) + 1) *\r\n((is_dual && !crt_enabled) ? 2 : 1);\r\noffset = epson1355_read_reg16(par, REG_MEM_ADDR_OFFSET0) & 0x7ff;\r\nxres_virtual = offset * 16 / bpp;\r\nyres_virtual = fix->smem_len / (offset * 2);\r\nvar->xres = xres;\r\nvar->yres = yres;\r\nvar->xres_virtual = xres_virtual;\r\nvar->yres_virtual = yres_virtual;\r\nvar->xoffset = var->yoffset = 0;\r\nfix->line_length = offset * 2;\r\nfix->xpanstep = 0;\r\nfix->ypanstep = 1;\r\nfix->ywrapstep = 0;\r\nfix->accel = FB_ACCEL_NONE;\r\nvar->grayscale = !is_color;\r\n#ifdef DEBUG\r\nprintk(KERN_INFO\r\n"epson1355fb: xres=%d, yres=%d, "\r\n"is_color=%d, is_dual=%d, is_tft=%d\n",\r\nxres, yres, is_color, is_dual, is_tft);\r\nprintk(KERN_INFO\r\n"epson1355fb: bpp=%d, lcd_bpp=%d, "\r\n"crt_enabled=%d, lcd_enabled=%d\n",\r\nbpp, lcd_bpp, crt_enabled, lcd_enabled);\r\n#endif\r\n}\r\nstatic void clearfb16(struct fb_info *info)\r\n{\r\nu16 *dst = (u16 *) info->screen_base;\r\nunsigned long n = info->fix.smem_len;\r\nwhile (n > 1) {\r\nfb_writew(0, dst);\r\ndst++, n -= 2;\r\n}\r\nif (n)\r\nfb_writeb(0, dst);\r\n}\r\nstatic int epson1355fb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct epson1355_par *par = info->par;\r\nbacklight_enable(0);\r\nif (par) {\r\nlcd_enable(par, 0);\r\nif (par && par->reg_addr)\r\niounmap((void *) par->reg_addr);\r\n}\r\nif (info) {\r\nfb_dealloc_cmap(&info->cmap);\r\nif (info->screen_base)\r\niounmap(info->screen_base);\r\nframebuffer_release(info);\r\n}\r\nrelease_mem_region(EPSON1355FB_FB_PHYS, EPSON1355FB_FB_LEN);\r\nrelease_mem_region(EPSON1355FB_REGS_PHYS, EPSON1355FB_REGS_LEN);\r\nreturn 0;\r\n}\r\nint __devinit epson1355fb_probe(struct platform_device *dev)\r\n{\r\nstruct epson1355_par *default_par;\r\nstruct fb_info *info;\r\nu8 revision;\r\nint rc = 0;\r\nif (!request_mem_region(EPSON1355FB_REGS_PHYS, EPSON1355FB_REGS_LEN, "S1D13505 registers")) {\r\nprintk(KERN_ERR "epson1355fb: unable to reserve "\r\n"registers at 0x%0x\n", EPSON1355FB_REGS_PHYS);\r\nrc = -EBUSY;\r\ngoto bail;\r\n}\r\nif (!request_mem_region(EPSON1355FB_FB_PHYS, EPSON1355FB_FB_LEN,\r\n"S1D13505 framebuffer")) {\r\nprintk(KERN_ERR "epson1355fb: unable to reserve "\r\n"framebuffer at 0x%0x\n", EPSON1355FB_FB_PHYS);\r\nrc = -EBUSY;\r\ngoto bail;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct epson1355_par), &dev->dev);\r\nif (!info) {\r\nrc = -ENOMEM;\r\ngoto bail;\r\n}\r\ndefault_par = info->par;\r\ndefault_par->reg_addr = (unsigned long) ioremap(EPSON1355FB_REGS_PHYS, EPSON1355FB_REGS_LEN);\r\nif (!default_par->reg_addr) {\r\nprintk(KERN_ERR "epson1355fb: unable to map registers\n");\r\nrc = -ENOMEM;\r\ngoto bail;\r\n}\r\ninfo->pseudo_palette = default_par->pseudo_palette;\r\ninfo->screen_base = ioremap(EPSON1355FB_FB_PHYS, EPSON1355FB_FB_LEN);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "epson1355fb: unable to map framebuffer\n");\r\nrc = -ENOMEM;\r\ngoto bail;\r\n}\r\nrevision = epson1355_read_reg(default_par, REG_REVISION_CODE);\r\nif ((revision >> 2) != 3) {\r\nprintk(KERN_INFO "epson1355fb: epson1355 not found\n");\r\nrc = -ENODEV;\r\ngoto bail;\r\n}\r\ninfo->fix.mmio_start = EPSON1355FB_REGS_PHYS;\r\ninfo->fix.mmio_len = EPSON1355FB_REGS_LEN;\r\ninfo->fix.smem_start = EPSON1355FB_FB_PHYS;\r\ninfo->fix.smem_len = get_fb_size(info);\r\nprintk(KERN_INFO "epson1355fb: regs mapped at 0x%lx, fb %d KiB mapped at 0x%p\n",\r\ndefault_par->reg_addr, info->fix.smem_len / 1024, info->screen_base);\r\nstrcpy(info->fix.id, "S1D13505");\r\ninfo->par = default_par;\r\ninfo->fbops = &epson1355fb_fbops;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nfetch_hw_state(info, default_par);\r\nclearfb16(info);\r\nbacklight_enable(1);\r\nlcd_enable(default_par, 1);\r\nif (register_framebuffer(info) < 0) {\r\nrc = -EINVAL;\r\ngoto bail;\r\n}\r\nplatform_set_drvdata(dev, info);\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nreturn 0;\r\nbail:\r\nepson1355fb_remove(dev);\r\nreturn rc;\r\n}\r\nint __init epson1355fb_init(void)\r\n{\r\nint ret = 0;\r\nif (fb_get_options("epson1355fb", NULL))\r\nreturn -ENODEV;\r\nret = platform_driver_register(&epson1355fb_driver);\r\nif (!ret) {\r\nepson1355fb_device = platform_device_alloc("epson1355fb", 0);\r\nif (epson1355fb_device)\r\nret = platform_device_add(epson1355fb_device);\r\nelse\r\nret = -ENOMEM;\r\nif (ret) {\r\nplatform_device_put(epson1355fb_device);\r\nplatform_driver_unregister(&epson1355fb_driver);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit epson1355fb_exit(void)\r\n{\r\nplatform_device_unregister(epson1355fb_device);\r\nplatform_driver_unregister(&epson1355fb_driver);\r\n}
