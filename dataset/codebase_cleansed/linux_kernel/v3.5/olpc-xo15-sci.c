static int set_lid_wake_behavior(bool wake_on_close)\r\n{\r\nstruct acpi_object_list arg_list;\r\nunion acpi_object arg;\r\nacpi_status status;\r\narg_list.count = 1;\r\narg_list.pointer = &arg;\r\narg.type = ACPI_TYPE_INTEGER;\r\narg.integer.value = wake_on_close;\r\nstatus = acpi_evaluate_object(NULL, "\\_SB.PCI0.LID.LIDW", &arg_list, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_warning(PFX "failed to set lid behavior\n");\r\nreturn 1;\r\n}\r\nlid_wake_on_close = wake_on_close;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nlid_wake_on_close_show(struct kobject *s, struct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", lid_wake_on_close);\r\n}\r\nstatic ssize_t lid_wake_on_close_store(struct kobject *s,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nunsigned int val;\r\nif (sscanf(buf, "%u", &val) != 1)\r\nreturn -EINVAL;\r\nset_lid_wake_behavior(!!val);\r\nreturn n;\r\n}\r\nstatic void battery_status_changed(void)\r\n{\r\nstruct power_supply *psy = power_supply_get_by_name("olpc-battery");\r\nif (psy) {\r\npower_supply_changed(psy);\r\nput_device(psy->dev);\r\n}\r\n}\r\nstatic void ac_status_changed(void)\r\n{\r\nstruct power_supply *psy = power_supply_get_by_name("olpc-ac");\r\nif (psy) {\r\npower_supply_changed(psy);\r\nput_device(psy->dev);\r\n}\r\n}\r\nstatic void process_sci_queue(void)\r\n{\r\nu16 data;\r\nint r;\r\ndo {\r\nr = olpc_ec_sci_query(&data);\r\nif (r || !data)\r\nbreak;\r\npr_debug(PFX "SCI 0x%x received\n", data);\r\nswitch (data) {\r\ncase EC_SCI_SRC_BATERR:\r\ncase EC_SCI_SRC_BATSOC:\r\ncase EC_SCI_SRC_BATTERY:\r\ncase EC_SCI_SRC_BATCRIT:\r\nbattery_status_changed();\r\nbreak;\r\ncase EC_SCI_SRC_ACPWR:\r\nac_status_changed();\r\nbreak;\r\n}\r\n} while (data);\r\nif (r)\r\npr_err(PFX "Failed to clear SCI queue");\r\n}\r\nstatic void process_sci_queue_work(struct work_struct *work)\r\n{\r\nprocess_sci_queue();\r\n}\r\nstatic u32 xo15_sci_gpe_handler(acpi_handle gpe_device, u32 gpe, void *context)\r\n{\r\nschedule_work(&sci_work);\r\nreturn ACPI_INTERRUPT_HANDLED | ACPI_REENABLE_GPE;\r\n}\r\nstatic int xo15_sci_add(struct acpi_device *device)\r\n{\r\nunsigned long long tmp;\r\nacpi_status status;\r\nint r;\r\nif (!device)\r\nreturn -EINVAL;\r\nstrcpy(acpi_device_name(device), XO15_SCI_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), XO15_SCI_CLASS);\r\nstatus = acpi_evaluate_integer(device->handle, "_GPE", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nxo15_sci_gpe = tmp;\r\nstatus = acpi_install_gpe_handler(NULL, xo15_sci_gpe,\r\nACPI_GPE_EDGE_TRIGGERED,\r\nxo15_sci_gpe_handler, device);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\ndev_info(&device->dev, "Initialized, GPE = 0x%lx\n", xo15_sci_gpe);\r\nr = sysfs_create_file(&device->dev.kobj, &lid_wake_on_close_attr.attr);\r\nif (r)\r\ngoto err_sysfs;\r\nprocess_sci_queue();\r\nolpc_ec_mask_write(EC_SCI_SRC_ALL);\r\nacpi_enable_gpe(NULL, xo15_sci_gpe);\r\nif (device->wakeup.flags.valid)\r\ndevice_init_wakeup(&device->dev, true);\r\nreturn 0;\r\nerr_sysfs:\r\nacpi_remove_gpe_handler(NULL, xo15_sci_gpe, xo15_sci_gpe_handler);\r\ncancel_work_sync(&sci_work);\r\nreturn r;\r\n}\r\nstatic int xo15_sci_remove(struct acpi_device *device, int type)\r\n{\r\nacpi_disable_gpe(NULL, xo15_sci_gpe);\r\nacpi_remove_gpe_handler(NULL, xo15_sci_gpe, xo15_sci_gpe_handler);\r\ncancel_work_sync(&sci_work);\r\nsysfs_remove_file(&device->dev.kobj, &lid_wake_on_close_attr.attr);\r\nreturn 0;\r\n}\r\nstatic int xo15_sci_resume(struct acpi_device *device)\r\n{\r\nolpc_ec_mask_write(EC_SCI_SRC_ALL);\r\nbattery_status_changed();\r\nac_status_changed();\r\nreturn 0;\r\n}\r\nstatic int __init xo15_sci_init(void)\r\n{\r\nreturn acpi_bus_register_driver(&xo15_sci_drv);\r\n}
