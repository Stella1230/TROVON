static void wm831x_status_work(struct work_struct *work)\r\n{\r\nstruct wm831x_status *led = container_of(work, struct wm831x_status,\r\nwork);\r\nunsigned long flags;\r\nmutex_lock(&led->mutex);\r\nled->reg_val &= ~(WM831X_LED_SRC_MASK | WM831X_LED_MODE_MASK |\r\nWM831X_LED_DUTY_CYC_MASK | WM831X_LED_DUR_MASK);\r\nspin_lock_irqsave(&led->value_lock, flags);\r\nled->reg_val |= led->src << WM831X_LED_SRC_SHIFT;\r\nif (led->blink) {\r\nled->reg_val |= 2 << WM831X_LED_MODE_SHIFT;\r\nled->reg_val |= led->blink_time << WM831X_LED_DUR_SHIFT;\r\nled->reg_val |= led->blink_cyc;\r\n} else {\r\nif (led->brightness != LED_OFF)\r\nled->reg_val |= 1 << WM831X_LED_MODE_SHIFT;\r\n}\r\nspin_unlock_irqrestore(&led->value_lock, flags);\r\nwm831x_reg_write(led->wm831x, led->reg, led->reg_val);\r\nmutex_unlock(&led->mutex);\r\n}\r\nstatic void wm831x_status_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct wm831x_status *led = to_wm831x_status(led_cdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&led->value_lock, flags);\r\nled->brightness = value;\r\nif (value == LED_OFF)\r\nled->blink = 0;\r\nschedule_work(&led->work);\r\nspin_unlock_irqrestore(&led->value_lock, flags);\r\n}\r\nstatic int wm831x_status_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct wm831x_status *led = to_wm831x_status(led_cdev);\r\nunsigned long flags;\r\nint ret = 0;\r\nif (*delay_on == 0 && *delay_off == 0) {\r\n*delay_on = 250;\r\n*delay_off = 250;\r\n}\r\nspin_lock_irqsave(&led->value_lock, flags);\r\nswitch (*delay_on) {\r\ncase 1000:\r\nled->blink_time = 0;\r\nbreak;\r\ncase 250:\r\nled->blink_time = 1;\r\nbreak;\r\ncase 125:\r\nled->blink_time = 2;\r\nbreak;\r\ncase 62:\r\ncase 63:\r\nled->blink_time = 3;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0) {\r\nswitch (*delay_off / *delay_on) {\r\ncase 1:\r\nled->blink_cyc = 0;\r\nbreak;\r\ncase 3:\r\nled->blink_cyc = 1;\r\nbreak;\r\ncase 4:\r\nled->blink_cyc = 2;\r\nbreak;\r\ncase 8:\r\nled->blink_cyc = 3;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif (ret == 0)\r\nled->blink = 1;\r\nelse\r\nled->blink = 0;\r\nschedule_work(&led->work);\r\nspin_unlock_irqrestore(&led->value_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t wm831x_status_src_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct wm831x_status *led = to_wm831x_status(led_cdev);\r\nint i;\r\nssize_t ret = 0;\r\nmutex_lock(&led->mutex);\r\nfor (i = 0; i < ARRAY_SIZE(led_src_texts); i++)\r\nif (i == led->src)\r\nret += sprintf(&buf[ret], "[%s] ", led_src_texts[i]);\r\nelse\r\nret += sprintf(&buf[ret], "%s ", led_src_texts[i]);\r\nmutex_unlock(&led->mutex);\r\nret += sprintf(&buf[ret], "\n");\r\nreturn ret;\r\n}\r\nstatic ssize_t wm831x_status_src_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct wm831x_status *led = to_wm831x_status(led_cdev);\r\nchar name[20];\r\nint i;\r\nsize_t len;\r\nname[sizeof(name) - 1] = '\0';\r\nstrncpy(name, buf, sizeof(name) - 1);\r\nlen = strlen(name);\r\nif (len && name[len - 1] == '\n')\r\nname[len - 1] = '\0';\r\nfor (i = 0; i < ARRAY_SIZE(led_src_texts); i++) {\r\nif (!strcmp(name, led_src_texts[i])) {\r\nmutex_lock(&led->mutex);\r\nled->src = i;\r\nschedule_work(&led->work);\r\nmutex_unlock(&led->mutex);\r\n}\r\n}\r\nreturn size;\r\n}\r\nstatic int wm831x_status_probe(struct platform_device *pdev)\r\n{\r\nstruct wm831x *wm831x = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm831x_pdata *chip_pdata;\r\nstruct wm831x_status_pdata pdata;\r\nstruct wm831x_status *drvdata;\r\nstruct resource *res;\r\nint id = pdev->id % ARRAY_SIZE(chip_pdata->status);\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No I/O resource\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct wm831x_status),\r\nGFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, drvdata);\r\ndrvdata->wm831x = wm831x;\r\ndrvdata->reg = res->start;\r\nif (wm831x->dev->platform_data)\r\nchip_pdata = wm831x->dev->platform_data;\r\nelse\r\nchip_pdata = NULL;\r\nmemset(&pdata, 0, sizeof(pdata));\r\nif (chip_pdata && chip_pdata->status[id])\r\nmemcpy(&pdata, chip_pdata->status[id], sizeof(pdata));\r\nelse\r\npdata.name = dev_name(&pdev->dev);\r\nmutex_init(&drvdata->mutex);\r\nINIT_WORK(&drvdata->work, wm831x_status_work);\r\nspin_lock_init(&drvdata->value_lock);\r\ndrvdata->reg_val = wm831x_reg_read(wm831x, drvdata->reg);\r\nif (drvdata->reg_val & WM831X_LED_MODE_MASK)\r\ndrvdata->brightness = LED_FULL;\r\nelse\r\ndrvdata->brightness = LED_OFF;\r\nif (pdata.default_src == WM831X_STATUS_PRESERVE) {\r\ndrvdata->src = drvdata->reg_val;\r\ndrvdata->src &= WM831X_LED_SRC_MASK;\r\ndrvdata->src >>= WM831X_LED_SRC_SHIFT;\r\n} else {\r\ndrvdata->src = pdata.default_src - 1;\r\n}\r\ndrvdata->cdev.name = pdata.name;\r\ndrvdata->cdev.default_trigger = pdata.default_trigger;\r\ndrvdata->cdev.brightness_set = wm831x_status_set;\r\ndrvdata->cdev.blink_set = wm831x_status_blink_set;\r\nret = led_classdev_register(wm831x->dev, &drvdata->cdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register LED: %d\n", ret);\r\ngoto err_led;\r\n}\r\nret = device_create_file(drvdata->cdev.dev, &dev_attr_src);\r\nif (ret != 0)\r\ndev_err(&pdev->dev,\r\n"No source control for LED: %d\n", ret);\r\nreturn 0;\r\nerr_led:\r\nled_classdev_unregister(&drvdata->cdev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int wm831x_status_remove(struct platform_device *pdev)\r\n{\r\nstruct wm831x_status *drvdata = platform_get_drvdata(pdev);\r\ndevice_remove_file(drvdata->cdev.dev, &dev_attr_src);\r\nled_classdev_unregister(&drvdata->cdev);\r\nreturn 0;\r\n}
