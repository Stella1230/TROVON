static int __init option_setup(char *opt)\r\n{\r\nstrlcpy(config, opt, MAX_PARAM_LENGTH);\r\nreturn 1;\r\n}\r\nstatic int __init dynamic_netconsole_init(void)\r\n{\r\nconfig_group_init(&netconsole_subsys.su_group);\r\nmutex_init(&netconsole_subsys.su_mutex);\r\nreturn configfs_register_subsystem(&netconsole_subsys);\r\n}\r\nstatic void __exit dynamic_netconsole_exit(void)\r\n{\r\nconfigfs_unregister_subsystem(&netconsole_subsys);\r\n}\r\nstatic void netconsole_target_get(struct netconsole_target *nt)\r\n{\r\nif (config_item_name(&nt->item))\r\nconfig_item_get(&nt->item);\r\n}\r\nstatic void netconsole_target_put(struct netconsole_target *nt)\r\n{\r\nif (config_item_name(&nt->item))\r\nconfig_item_put(&nt->item);\r\n}\r\nstatic int __init dynamic_netconsole_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit dynamic_netconsole_exit(void)\r\n{\r\n}\r\nstatic void netconsole_target_get(struct netconsole_target *nt)\r\n{\r\n}\r\nstatic void netconsole_target_put(struct netconsole_target *nt)\r\n{\r\n}\r\nstatic struct netconsole_target *alloc_param_target(char *target_config)\r\n{\r\nint err = -ENOMEM;\r\nstruct netconsole_target *nt;\r\nnt = kzalloc(sizeof(*nt), GFP_KERNEL);\r\nif (!nt)\r\ngoto fail;\r\nnt->np.name = "netconsole";\r\nstrlcpy(nt->np.dev_name, "eth0", IFNAMSIZ);\r\nnt->np.local_port = 6665;\r\nnt->np.remote_port = 6666;\r\nmemset(nt->np.remote_mac, 0xff, ETH_ALEN);\r\nerr = netpoll_parse_options(&nt->np, target_config);\r\nif (err)\r\ngoto fail;\r\nerr = netpoll_setup(&nt->np);\r\nif (err)\r\ngoto fail;\r\nnt->enabled = 1;\r\nreturn nt;\r\nfail:\r\nkfree(nt);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void free_param_target(struct netconsole_target *nt)\r\n{\r\nnetpoll_cleanup(&nt->np);\r\nkfree(nt);\r\n}\r\nstatic struct netconsole_target *to_target(struct config_item *item)\r\n{\r\nreturn item ?\r\ncontainer_of(item, struct netconsole_target, item) :\r\nNULL;\r\n}\r\nstatic ssize_t show_enabled(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", nt->enabled);\r\n}\r\nstatic ssize_t show_dev_name(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", nt->np.dev_name);\r\n}\r\nstatic ssize_t show_local_port(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", nt->np.local_port);\r\n}\r\nstatic ssize_t show_remote_port(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", nt->np.remote_port);\r\n}\r\nstatic ssize_t show_local_ip(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%pI4\n", &nt->np.local_ip);\r\n}\r\nstatic ssize_t show_remote_ip(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%pI4\n", &nt->np.remote_ip);\r\n}\r\nstatic ssize_t show_local_mac(struct netconsole_target *nt, char *buf)\r\n{\r\nstruct net_device *dev = nt->np.dev;\r\nstatic const u8 bcast[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\r\nreturn snprintf(buf, PAGE_SIZE, "%pM\n", dev ? dev->dev_addr : bcast);\r\n}\r\nstatic ssize_t show_remote_mac(struct netconsole_target *nt, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%pM\n", nt->np.remote_mac);\r\n}\r\nstatic ssize_t store_enabled(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint enabled;\r\nint err;\r\nerr = kstrtoint(buf, 10, &enabled);\r\nif (err < 0)\r\nreturn err;\r\nif (enabled < 0 || enabled > 1)\r\nreturn -EINVAL;\r\nif (enabled == nt->enabled) {\r\nprintk(KERN_INFO "netconsole: network logging has already %s\n",\r\nnt->enabled ? "started" : "stopped");\r\nreturn -EINVAL;\r\n}\r\nif (enabled) {\r\nnetpoll_print_options(&nt->np);\r\nerr = netpoll_setup(&nt->np);\r\nif (err)\r\nreturn err;\r\nprintk(KERN_INFO "netconsole: network logging started\n");\r\n} else {\r\nnetpoll_cleanup(&nt->np);\r\n}\r\nnt->enabled = enabled;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_dev_name(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nsize_t len;\r\nif (nt->enabled) {\r\nprintk(KERN_ERR "netconsole: target (%s) is enabled, "\r\n"disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nreturn -EINVAL;\r\n}\r\nstrlcpy(nt->np.dev_name, buf, IFNAMSIZ);\r\nlen = strnlen(nt->np.dev_name, IFNAMSIZ);\r\nif (nt->np.dev_name[len - 1] == '\n')\r\nnt->np.dev_name[len - 1] = '\0';\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_local_port(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint rv;\r\nif (nt->enabled) {\r\nprintk(KERN_ERR "netconsole: target (%s) is enabled, "\r\n"disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nreturn -EINVAL;\r\n}\r\nrv = kstrtou16(buf, 10, &nt->np.local_port);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_remote_port(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nint rv;\r\nif (nt->enabled) {\r\nprintk(KERN_ERR "netconsole: target (%s) is enabled, "\r\n"disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nreturn -EINVAL;\r\n}\r\nrv = kstrtou16(buf, 10, &nt->np.remote_port);\r\nif (rv < 0)\r\nreturn rv;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_local_ip(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nif (nt->enabled) {\r\nprintk(KERN_ERR "netconsole: target (%s) is enabled, "\r\n"disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nreturn -EINVAL;\r\n}\r\nnt->np.local_ip = in_aton(buf);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_remote_ip(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nif (nt->enabled) {\r\nprintk(KERN_ERR "netconsole: target (%s) is enabled, "\r\n"disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nreturn -EINVAL;\r\n}\r\nnt->np.remote_ip = in_aton(buf);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t store_remote_mac(struct netconsole_target *nt,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nu8 remote_mac[ETH_ALEN];\r\nif (nt->enabled) {\r\nprintk(KERN_ERR "netconsole: target (%s) is enabled, "\r\n"disable to update parameters\n",\r\nconfig_item_name(&nt->item));\r\nreturn -EINVAL;\r\n}\r\nif (!mac_pton(buf, remote_mac))\r\nreturn -EINVAL;\r\nif (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')\r\nreturn -EINVAL;\r\nmemcpy(nt->np.remote_mac, remote_mac, ETH_ALEN);\r\nreturn strnlen(buf, count);\r\n}\r\nstatic void netconsole_target_release(struct config_item *item)\r\n{\r\nkfree(to_target(item));\r\n}\r\nstatic ssize_t netconsole_target_attr_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t ret = -EINVAL;\r\nstruct netconsole_target *nt = to_target(item);\r\nstruct netconsole_target_attr *na =\r\ncontainer_of(attr, struct netconsole_target_attr, attr);\r\nif (na->show)\r\nret = na->show(nt, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t netconsole_target_attr_store(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nssize_t ret = -EINVAL;\r\nstruct netconsole_target *nt = to_target(item);\r\nstruct netconsole_target_attr *na =\r\ncontainer_of(attr, struct netconsole_target_attr, attr);\r\nif (na->store)\r\nret = na->store(nt, buf, count);\r\nreturn ret;\r\n}\r\nstatic struct config_item *make_netconsole_target(struct config_group *group,\r\nconst char *name)\r\n{\r\nunsigned long flags;\r\nstruct netconsole_target *nt;\r\nnt = kzalloc(sizeof(*nt), GFP_KERNEL);\r\nif (!nt)\r\nreturn ERR_PTR(-ENOMEM);\r\nnt->np.name = "netconsole";\r\nstrlcpy(nt->np.dev_name, "eth0", IFNAMSIZ);\r\nnt->np.local_port = 6665;\r\nnt->np.remote_port = 6666;\r\nmemset(nt->np.remote_mac, 0xff, ETH_ALEN);\r\nconfig_item_init_type_name(&nt->item, name, &netconsole_target_type);\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_add(&nt->list, &target_list);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nreturn &nt->item;\r\n}\r\nstatic void drop_netconsole_target(struct config_group *group,\r\nstruct config_item *item)\r\n{\r\nunsigned long flags;\r\nstruct netconsole_target *nt = to_target(item);\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_del(&nt->list);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nif (nt->enabled)\r\nnetpoll_cleanup(&nt->np);\r\nconfig_item_put(&nt->item);\r\n}\r\nstatic int netconsole_netdev_event(struct notifier_block *this,\r\nunsigned long event,\r\nvoid *ptr)\r\n{\r\nunsigned long flags;\r\nstruct netconsole_target *nt;\r\nstruct net_device *dev = ptr;\r\nbool stopped = false;\r\nif (!(event == NETDEV_CHANGENAME || event == NETDEV_UNREGISTER ||\r\nevent == NETDEV_RELEASE || event == NETDEV_JOIN))\r\ngoto done;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_for_each_entry(nt, &target_list, list) {\r\nnetconsole_target_get(nt);\r\nif (nt->np.dev == dev) {\r\nswitch (event) {\r\ncase NETDEV_CHANGENAME:\r\nstrlcpy(nt->np.dev_name, dev->name, IFNAMSIZ);\r\nbreak;\r\ncase NETDEV_RELEASE:\r\ncase NETDEV_JOIN:\r\ncase NETDEV_UNREGISTER:\r\nif (nt->np.dev) {\r\nspin_unlock_irqrestore(\r\n&target_list_lock,\r\nflags);\r\n__netpoll_cleanup(&nt->np);\r\nspin_lock_irqsave(&target_list_lock,\r\nflags);\r\ndev_put(nt->np.dev);\r\nnt->np.dev = NULL;\r\nnetconsole_target_put(nt);\r\n}\r\nnt->enabled = 0;\r\nstopped = true;\r\nbreak;\r\n}\r\n}\r\nnetconsole_target_put(nt);\r\n}\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\nif (stopped) {\r\nprintk(KERN_INFO "netconsole: network logging stopped on "\r\n"interface %s as it ", dev->name);\r\nswitch (event) {\r\ncase NETDEV_UNREGISTER:\r\nprintk(KERN_CONT "unregistered\n");\r\nbreak;\r\ncase NETDEV_RELEASE:\r\nprintk(KERN_CONT "released slaves\n");\r\nbreak;\r\ncase NETDEV_JOIN:\r\nprintk(KERN_CONT "is joining a master device\n");\r\nbreak;\r\n}\r\n}\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void write_msg(struct console *con, const char *msg, unsigned int len)\r\n{\r\nint frag, left;\r\nunsigned long flags;\r\nstruct netconsole_target *nt;\r\nconst char *tmp;\r\nif (list_empty(&target_list))\r\nreturn;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_for_each_entry(nt, &target_list, list) {\r\nnetconsole_target_get(nt);\r\nif (nt->enabled && netif_running(nt->np.dev)) {\r\ntmp = msg;\r\nfor (left = len; left;) {\r\nfrag = min(left, MAX_PRINT_CHUNK);\r\nnetpoll_send_udp(&nt->np, tmp, frag);\r\ntmp += frag;\r\nleft -= frag;\r\n}\r\n}\r\nnetconsole_target_put(nt);\r\n}\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\n}\r\nstatic int __init init_netconsole(void)\r\n{\r\nint err;\r\nstruct netconsole_target *nt, *tmp;\r\nunsigned long flags;\r\nchar *target_config;\r\nchar *input = config;\r\nif (strnlen(input, MAX_PARAM_LENGTH)) {\r\nwhile ((target_config = strsep(&input, ";"))) {\r\nnt = alloc_param_target(target_config);\r\nif (IS_ERR(nt)) {\r\nerr = PTR_ERR(nt);\r\ngoto fail;\r\n}\r\nnetconsole.flags |= CON_PRINTBUFFER;\r\nspin_lock_irqsave(&target_list_lock, flags);\r\nlist_add(&nt->list, &target_list);\r\nspin_unlock_irqrestore(&target_list_lock, flags);\r\n}\r\n}\r\nerr = register_netdevice_notifier(&netconsole_netdev_notifier);\r\nif (err)\r\ngoto fail;\r\nerr = dynamic_netconsole_init();\r\nif (err)\r\ngoto undonotifier;\r\nregister_console(&netconsole);\r\nprintk(KERN_INFO "netconsole: network logging started\n");\r\nreturn err;\r\nundonotifier:\r\nunregister_netdevice_notifier(&netconsole_netdev_notifier);\r\nfail:\r\nprintk(KERN_ERR "netconsole: cleaning up\n");\r\nlist_for_each_entry_safe(nt, tmp, &target_list, list) {\r\nlist_del(&nt->list);\r\nfree_param_target(nt);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit cleanup_netconsole(void)\r\n{\r\nstruct netconsole_target *nt, *tmp;\r\nunregister_console(&netconsole);\r\ndynamic_netconsole_exit();\r\nunregister_netdevice_notifier(&netconsole_netdev_notifier);\r\nlist_for_each_entry_safe(nt, tmp, &target_list, list) {\r\nlist_del(&nt->list);\r\nfree_param_target(nt);\r\n}\r\n}
