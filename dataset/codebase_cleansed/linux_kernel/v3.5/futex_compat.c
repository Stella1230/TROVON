static inline int\r\nfetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,\r\ncompat_uptr_t __user *head, unsigned int *pi)\r\n{\r\nif (get_user(*uentry, head))\r\nreturn -EFAULT;\r\n*entry = compat_ptr((*uentry) & ~1);\r\n*pi = (unsigned int)(*uentry) & 1;\r\nreturn 0;\r\n}\r\nstatic void __user *futex_uaddr(struct robust_list __user *entry,\r\ncompat_long_t futex_offset)\r\n{\r\ncompat_uptr_t base = ptr_to_compat(entry);\r\nvoid __user *uaddr = compat_ptr(base + futex_offset);\r\nreturn uaddr;\r\n}\r\nvoid compat_exit_robust_list(struct task_struct *curr)\r\n{\r\nstruct compat_robust_list_head __user *head = curr->compat_robust_list;\r\nstruct robust_list __user *entry, *next_entry, *pending;\r\nunsigned int limit = ROBUST_LIST_LIMIT, pi, pip;\r\nunsigned int uninitialized_var(next_pi);\r\ncompat_uptr_t uentry, next_uentry, upending;\r\ncompat_long_t futex_offset;\r\nint rc;\r\nif (!futex_cmpxchg_enabled)\r\nreturn;\r\nif (fetch_robust_entry(&uentry, &entry, &head->list.next, &pi))\r\nreturn;\r\nif (get_user(futex_offset, &head->futex_offset))\r\nreturn;\r\nif (fetch_robust_entry(&upending, &pending,\r\n&head->list_op_pending, &pip))\r\nreturn;\r\nnext_entry = NULL;\r\nwhile (entry != (struct robust_list __user *) &head->list) {\r\nrc = fetch_robust_entry(&next_uentry, &next_entry,\r\n(compat_uptr_t __user *)&entry->next, &next_pi);\r\nif (entry != pending) {\r\nvoid __user *uaddr = futex_uaddr(entry, futex_offset);\r\nif (handle_futex_death(uaddr, curr, pi))\r\nreturn;\r\n}\r\nif (rc)\r\nreturn;\r\nuentry = next_uentry;\r\nentry = next_entry;\r\npi = next_pi;\r\nif (!--limit)\r\nbreak;\r\ncond_resched();\r\n}\r\nif (pending) {\r\nvoid __user *uaddr = futex_uaddr(pending, futex_offset);\r\nhandle_futex_death(uaddr, curr, pip);\r\n}\r\n}\r\nasmlinkage long\r\ncompat_sys_set_robust_list(struct compat_robust_list_head __user *head,\r\ncompat_size_t len)\r\n{\r\nif (!futex_cmpxchg_enabled)\r\nreturn -ENOSYS;\r\nif (unlikely(len != sizeof(*head)))\r\nreturn -EINVAL;\r\ncurrent->compat_robust_list = head;\r\nreturn 0;\r\n}\r\nasmlinkage long\r\ncompat_sys_get_robust_list(int pid, compat_uptr_t __user *head_ptr,\r\ncompat_size_t __user *len_ptr)\r\n{\r\nstruct compat_robust_list_head __user *head;\r\nunsigned long ret;\r\nstruct task_struct *p;\r\nif (!futex_cmpxchg_enabled)\r\nreturn -ENOSYS;\r\nWARN_ONCE(1, "deprecated: get_robust_list will be deleted in 2013.\n");\r\nrcu_read_lock();\r\nret = -ESRCH;\r\nif (!pid)\r\np = current;\r\nelse {\r\np = find_task_by_vpid(pid);\r\nif (!p)\r\ngoto err_unlock;\r\n}\r\nret = -EPERM;\r\nif (!ptrace_may_access(p, PTRACE_MODE_READ))\r\ngoto err_unlock;\r\nhead = p->compat_robust_list;\r\nrcu_read_unlock();\r\nif (put_user(sizeof(*head), len_ptr))\r\nreturn -EFAULT;\r\nreturn put_user(ptr_to_compat(head), head_ptr);\r\nerr_unlock:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nasmlinkage long compat_sys_futex(u32 __user *uaddr, int op, u32 val,\r\nstruct compat_timespec __user *utime, u32 __user *uaddr2,\r\nu32 val3)\r\n{\r\nstruct timespec ts;\r\nktime_t t, *tp = NULL;\r\nint val2 = 0;\r\nint cmd = op & FUTEX_CMD_MASK;\r\nif (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||\r\ncmd == FUTEX_WAIT_BITSET ||\r\ncmd == FUTEX_WAIT_REQUEUE_PI)) {\r\nif (get_compat_timespec(&ts, utime))\r\nreturn -EFAULT;\r\nif (!timespec_valid(&ts))\r\nreturn -EINVAL;\r\nt = timespec_to_ktime(ts);\r\nif (cmd == FUTEX_WAIT)\r\nt = ktime_add_safe(ktime_get(), t);\r\ntp = &t;\r\n}\r\nif (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||\r\ncmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)\r\nval2 = (int) (unsigned long) utime;\r\nreturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\r\n}
