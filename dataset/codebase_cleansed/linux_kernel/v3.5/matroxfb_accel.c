static inline void matrox_cfb4_pal(u_int32_t* pal) {\r\nunsigned int i;\r\nfor (i = 0; i < 16; i++) {\r\npal[i] = i * 0x11111111U;\r\n}\r\n}\r\nstatic inline void matrox_cfb8_pal(u_int32_t* pal) {\r\nunsigned int i;\r\nfor (i = 0; i < 16; i++) {\r\npal[i] = i * 0x01010101U;\r\n}\r\n}\r\nvoid matrox_cfbX_init(struct matrox_fb_info *minfo)\r\n{\r\nu_int32_t maccess;\r\nu_int32_t mpitch;\r\nu_int32_t mopmode;\r\nint accel;\r\nDBG(__func__)\r\nmpitch = minfo->fbcon.var.xres_virtual;\r\nminfo->fbops.fb_copyarea = cfb_copyarea;\r\nminfo->fbops.fb_fillrect = cfb_fillrect;\r\nminfo->fbops.fb_imageblit = cfb_imageblit;\r\nminfo->fbops.fb_cursor = NULL;\r\naccel = (minfo->fbcon.var.accel_flags & FB_ACCELF_TEXT) == FB_ACCELF_TEXT;\r\nswitch (minfo->fbcon.var.bits_per_pixel) {\r\ncase 4: maccess = 0x00000000;\r\nmpitch = (mpitch >> 1) | 0x8000;\r\nmopmode = M_OPMODE_4BPP;\r\nmatrox_cfb4_pal(minfo->cmap);\r\nif (accel && !(mpitch & 1)) {\r\nminfo->fbops.fb_copyarea = matroxfb_cfb4_copyarea;\r\nminfo->fbops.fb_fillrect = matroxfb_cfb4_fillrect;\r\n}\r\nbreak;\r\ncase 8: maccess = 0x00000000;\r\nmopmode = M_OPMODE_8BPP;\r\nmatrox_cfb8_pal(minfo->cmap);\r\nif (accel) {\r\nminfo->fbops.fb_copyarea = matroxfb_copyarea;\r\nminfo->fbops.fb_fillrect = matroxfb_fillrect;\r\nminfo->fbops.fb_imageblit = matroxfb_imageblit;\r\n}\r\nbreak;\r\ncase 16: if (minfo->fbcon.var.green.length == 5)\r\nmaccess = 0xC0000001;\r\nelse\r\nmaccess = 0x40000001;\r\nmopmode = M_OPMODE_16BPP;\r\nif (accel) {\r\nminfo->fbops.fb_copyarea = matroxfb_copyarea;\r\nminfo->fbops.fb_fillrect = matroxfb_fillrect;\r\nminfo->fbops.fb_imageblit = matroxfb_imageblit;\r\n}\r\nbreak;\r\ncase 24: maccess = 0x00000003;\r\nmopmode = M_OPMODE_24BPP;\r\nif (accel) {\r\nminfo->fbops.fb_copyarea = matroxfb_copyarea;\r\nminfo->fbops.fb_fillrect = matroxfb_fillrect;\r\nminfo->fbops.fb_imageblit = matroxfb_imageblit;\r\n}\r\nbreak;\r\ncase 32: maccess = 0x00000002;\r\nmopmode = M_OPMODE_32BPP;\r\nif (accel) {\r\nminfo->fbops.fb_copyarea = matroxfb_copyarea;\r\nminfo->fbops.fb_fillrect = matroxfb_fillrect;\r\nminfo->fbops.fb_imageblit = matroxfb_imageblit;\r\n}\r\nbreak;\r\ndefault: maccess = 0x00000000;\r\nmopmode = 0x00000000;\r\nbreak;\r\n}\r\nmga_fifo(8);\r\nmga_outl(M_PITCH, mpitch);\r\nmga_outl(M_YDSTORG, curr_ydstorg(minfo));\r\nif (minfo->capable.plnwt)\r\nmga_outl(M_PLNWT, -1);\r\nif (minfo->capable.srcorg) {\r\nmga_outl(M_SRCORG, 0);\r\nmga_outl(M_DSTORG, 0);\r\n}\r\nmga_outl(M_OPMODE, mopmode);\r\nmga_outl(M_CXBNDRY, 0xFFFF0000);\r\nmga_outl(M_YTOP, 0);\r\nmga_outl(M_YBOT, 0x01FFFFFF);\r\nmga_outl(M_MACCESS, maccess);\r\nminfo->accel.m_dwg_rect = M_DWG_TRAP | M_DWG_SOLID | M_DWG_ARZERO | M_DWG_SGNZERO | M_DWG_SHIFTZERO;\r\nif (isMilleniumII(minfo)) minfo->accel.m_dwg_rect |= M_DWG_TRANSC;\r\nminfo->accel.m_opmode = mopmode;\r\n}\r\nstatic void matrox_accel_bmove(struct matrox_fb_info *minfo, int vxres, int sy,\r\nint sx, int dy, int dx, int height, int width)\r\n{\r\nint start, end;\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\nif ((dy < sy) || ((dy == sy) && (dx <= sx))) {\r\nmga_fifo(2);\r\nmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_SGNZERO |\r\nM_DWG_BFCOL | M_DWG_REPLACE);\r\nmga_outl(M_AR5, vxres);\r\nwidth--;\r\nstart = sy*vxres+sx+curr_ydstorg(minfo);\r\nend = start+width;\r\n} else {\r\nmga_fifo(3);\r\nmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_BFCOL | M_DWG_REPLACE);\r\nmga_outl(M_SGN, 5);\r\nmga_outl(M_AR5, -vxres);\r\nwidth--;\r\nend = (sy+height-1)*vxres+sx+curr_ydstorg(minfo);\r\nstart = end+width;\r\ndy += height-1;\r\n}\r\nmga_fifo(4);\r\nmga_outl(M_AR0, end);\r\nmga_outl(M_AR3, start);\r\nmga_outl(M_FXBNDRY, ((dx+width)<<16) | dx);\r\nmga_ydstlen(dy, height);\r\nWaitTillIdle();\r\nCRITEND\r\n}\r\nstatic void matrox_accel_bmove_lin(struct matrox_fb_info *minfo, int vxres,\r\nint sy, int sx, int dy, int dx, int height,\r\nint width)\r\n{\r\nint start, end;\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\nif ((dy < sy) || ((dy == sy) && (dx <= sx))) {\r\nmga_fifo(2);\r\nmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_SGNZERO |\r\nM_DWG_BFCOL | M_DWG_REPLACE);\r\nmga_outl(M_AR5, vxres);\r\nwidth--;\r\nstart = sy*vxres+sx+curr_ydstorg(minfo);\r\nend = start+width;\r\n} else {\r\nmga_fifo(3);\r\nmga_outl(M_DWGCTL, M_DWG_BITBLT | M_DWG_SHIFTZERO | M_DWG_BFCOL | M_DWG_REPLACE);\r\nmga_outl(M_SGN, 5);\r\nmga_outl(M_AR5, -vxres);\r\nwidth--;\r\nend = (sy+height-1)*vxres+sx+curr_ydstorg(minfo);\r\nstart = end+width;\r\ndy += height-1;\r\n}\r\nmga_fifo(5);\r\nmga_outl(M_AR0, end);\r\nmga_outl(M_AR3, start);\r\nmga_outl(M_FXBNDRY, ((dx+width)<<16) | dx);\r\nmga_outl(M_YDST, dy*vxres >> 5);\r\nmga_outl(M_LEN | M_EXEC, height);\r\nWaitTillIdle();\r\nCRITEND\r\n}\r\nstatic void matroxfb_cfb4_copyarea(struct fb_info* info, const struct fb_copyarea* area) {\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nif ((area->sx | area->dx | area->width) & 1)\r\ncfb_copyarea(info, area);\r\nelse\r\nmatrox_accel_bmove_lin(minfo, minfo->fbcon.var.xres_virtual >> 1, area->sy, area->sx >> 1, area->dy, area->dx >> 1, area->height, area->width >> 1);\r\n}\r\nstatic void matroxfb_copyarea(struct fb_info* info, const struct fb_copyarea* area) {\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nmatrox_accel_bmove(minfo, minfo->fbcon.var.xres_virtual, area->sy, area->sx, area->dy, area->dx, area->height, area->width);\r\n}\r\nstatic void matroxfb_accel_clear(struct matrox_fb_info *minfo, u_int32_t color,\r\nint sy, int sx, int height, int width)\r\n{\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\nmga_fifo(5);\r\nmga_outl(M_DWGCTL, minfo->accel.m_dwg_rect | M_DWG_REPLACE);\r\nmga_outl(M_FCOL, color);\r\nmga_outl(M_FXBNDRY, ((sx + width) << 16) | sx);\r\nmga_ydstlen(sy, height);\r\nWaitTillIdle();\r\nCRITEND\r\n}\r\nstatic void matroxfb_fillrect(struct fb_info* info, const struct fb_fillrect* rect) {\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nswitch (rect->rop) {\r\ncase ROP_COPY:\r\nmatroxfb_accel_clear(minfo, ((u_int32_t *)info->pseudo_palette)[rect->color], rect->dy, rect->dx, rect->height, rect->width);\r\nbreak;\r\n}\r\n}\r\nstatic void matroxfb_cfb4_clear(struct matrox_fb_info *minfo, u_int32_t bgx,\r\nint sy, int sx, int height, int width)\r\n{\r\nint whattodo;\r\nCRITFLAGS\r\nDBG(__func__)\r\nCRITBEGIN\r\nwhattodo = 0;\r\nif (sx & 1) {\r\nsx ++;\r\nif (!width) return;\r\nwidth --;\r\nwhattodo = 1;\r\n}\r\nif (width & 1) {\r\nwhattodo |= 2;\r\n}\r\nwidth >>= 1;\r\nsx >>= 1;\r\nif (width) {\r\nmga_fifo(5);\r\nmga_outl(M_DWGCTL, minfo->accel.m_dwg_rect | M_DWG_REPLACE2);\r\nmga_outl(M_FCOL, bgx);\r\nmga_outl(M_FXBNDRY, ((sx + width) << 16) | sx);\r\nmga_outl(M_YDST, sy * minfo->fbcon.var.xres_virtual >> 6);\r\nmga_outl(M_LEN | M_EXEC, height);\r\nWaitTillIdle();\r\n}\r\nif (whattodo) {\r\nu_int32_t step = minfo->fbcon.var.xres_virtual >> 1;\r\nvaddr_t vbase = minfo->video.vbase;\r\nif (whattodo & 1) {\r\nunsigned int uaddr = sy * step + sx - 1;\r\nu_int32_t loop;\r\nu_int8_t bgx2 = bgx & 0xF0;\r\nfor (loop = height; loop > 0; loop --) {\r\nmga_writeb(vbase, uaddr, (mga_readb(vbase, uaddr) & 0x0F) | bgx2);\r\nuaddr += step;\r\n}\r\n}\r\nif (whattodo & 2) {\r\nunsigned int uaddr = sy * step + sx + width;\r\nu_int32_t loop;\r\nu_int8_t bgx2 = bgx & 0x0F;\r\nfor (loop = height; loop > 0; loop --) {\r\nmga_writeb(vbase, uaddr, (mga_readb(vbase, uaddr) & 0xF0) | bgx2);\r\nuaddr += step;\r\n}\r\n}\r\n}\r\nCRITEND\r\n}\r\nstatic void matroxfb_cfb4_fillrect(struct fb_info* info, const struct fb_fillrect* rect) {\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nswitch (rect->rop) {\r\ncase ROP_COPY:\r\nmatroxfb_cfb4_clear(minfo, ((u_int32_t *)info->pseudo_palette)[rect->color], rect->dy, rect->dx, rect->height, rect->width);\r\nbreak;\r\n}\r\n}\r\nstatic void matroxfb_1bpp_imageblit(struct matrox_fb_info *minfo, u_int32_t fgx,\r\nu_int32_t bgx, const u_int8_t *chardata,\r\nint width, int height, int yy, int xx)\r\n{\r\nu_int32_t step;\r\nu_int32_t ydstlen;\r\nu_int32_t xlen;\r\nu_int32_t ar0;\r\nu_int32_t charcell;\r\nu_int32_t fxbndry;\r\nvaddr_t mmio;\r\nint easy;\r\nCRITFLAGS\r\nDBG_HEAVY(__func__);\r\nstep = (width + 7) >> 3;\r\ncharcell = height * step;\r\nxlen = (charcell + 3) & ~3;\r\nydstlen = (yy << 16) | height;\r\nif (width == step << 3) {\r\nar0 = height * width - 1;\r\neasy = 1;\r\n} else {\r\nar0 = width - 1;\r\neasy = 0;\r\n}\r\nCRITBEGIN\r\nmga_fifo(3);\r\nif (easy)\r\nmga_outl(M_DWGCTL, M_DWG_ILOAD | M_DWG_SGNZERO | M_DWG_SHIFTZERO | M_DWG_BMONOWF | M_DWG_LINEAR | M_DWG_REPLACE);\r\nelse\r\nmga_outl(M_DWGCTL, M_DWG_ILOAD | M_DWG_SGNZERO | M_DWG_SHIFTZERO | M_DWG_BMONOWF | M_DWG_REPLACE);\r\nmga_outl(M_FCOL, fgx);\r\nmga_outl(M_BCOL, bgx);\r\nfxbndry = ((xx + width - 1) << 16) | xx;\r\nmmio = minfo->mmio.vbase;\r\nmga_fifo(6);\r\nmga_writel(mmio, M_FXBNDRY, fxbndry);\r\nmga_writel(mmio, M_AR0, ar0);\r\nmga_writel(mmio, M_AR3, 0);\r\nif (easy) {\r\nmga_writel(mmio, M_YDSTLEN | M_EXEC, ydstlen);\r\nmga_memcpy_toio(mmio, chardata, xlen);\r\n} else {\r\nmga_writel(mmio, M_AR5, 0);\r\nmga_writel(mmio, M_YDSTLEN | M_EXEC, ydstlen);\r\nif ((step & 3) == 0) {\r\nmga_memcpy_toio(mmio, chardata, charcell);\r\n} else if (step == 1) {\r\nwhile (height--) {\r\n#if defined(__BIG_ENDIAN)\r\nfb_writel((*chardata) << 24, mmio.vaddr);\r\n#else\r\nfb_writel(*chardata, mmio.vaddr);\r\n#endif\r\nchardata++;\r\n}\r\n} else if (step == 2) {\r\nwhile (height--) {\r\n#if defined(__BIG_ENDIAN)\r\nfb_writel((*(u_int16_t*)chardata) << 16, mmio.vaddr);\r\n#else\r\nfb_writel(*(u_int16_t*)chardata, mmio.vaddr);\r\n#endif\r\nchardata += 2;\r\n}\r\n} else {\r\nwhile (height--) {\r\nsize_t i;\r\nfor (i = 0; i < step; i += 4) {\r\nfb_writel(get_unaligned((u_int32_t*)(chardata + i)),mmio.vaddr);\r\n}\r\nchardata += step;\r\n}\r\n}\r\n}\r\nWaitTillIdle();\r\nCRITEND\r\n}\r\nstatic void matroxfb_imageblit(struct fb_info* info, const struct fb_image* image) {\r\nstruct matrox_fb_info *minfo = info2minfo(info);\r\nDBG_HEAVY(__func__);\r\nif (image->depth == 1) {\r\nu_int32_t fgx, bgx;\r\nfgx = ((u_int32_t*)info->pseudo_palette)[image->fg_color];\r\nbgx = ((u_int32_t*)info->pseudo_palette)[image->bg_color];\r\nmatroxfb_1bpp_imageblit(minfo, fgx, bgx, image->data, image->width, image->height, image->dy, image->dx);\r\n} else {\r\ncfb_imageblit(info, image);\r\n}\r\n}
