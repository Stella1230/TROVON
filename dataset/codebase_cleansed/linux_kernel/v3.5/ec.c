static inline u8 acpi_ec_read_status(struct acpi_ec *ec)\r\n{\r\nu8 x = inb(ec->command_addr);\r\npr_debug(PREFIX "---> status = 0x%2.2x\n", x);\r\nreturn x;\r\n}\r\nstatic inline u8 acpi_ec_read_data(struct acpi_ec *ec)\r\n{\r\nu8 x = inb(ec->data_addr);\r\npr_debug(PREFIX "---> data = 0x%2.2x\n", x);\r\nreturn x;\r\n}\r\nstatic inline void acpi_ec_write_cmd(struct acpi_ec *ec, u8 command)\r\n{\r\npr_debug(PREFIX "<--- command = 0x%2.2x\n", command);\r\noutb(command, ec->command_addr);\r\n}\r\nstatic inline void acpi_ec_write_data(struct acpi_ec *ec, u8 data)\r\n{\r\npr_debug(PREFIX "<--- data = 0x%2.2x\n", data);\r\noutb(data, ec->data_addr);\r\n}\r\nstatic int ec_transaction_done(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&ec->curr_lock, flags);\r\nif (!ec->curr || ec->curr->done)\r\nret = 1;\r\nspin_unlock_irqrestore(&ec->curr_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void start_transaction(struct acpi_ec *ec)\r\n{\r\nec->curr->irq_count = ec->curr->wi = ec->curr->ri = 0;\r\nec->curr->done = false;\r\nacpi_ec_write_cmd(ec, ec->curr->command);\r\n}\r\nstatic void advance_transaction(struct acpi_ec *ec, u8 status)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ec->curr_lock, flags);\r\nif (!ec->curr)\r\ngoto unlock;\r\nif (ec->curr->wlen > ec->curr->wi) {\r\nif ((status & ACPI_EC_FLAG_IBF) == 0)\r\nacpi_ec_write_data(ec,\r\nec->curr->wdata[ec->curr->wi++]);\r\nelse\r\ngoto err;\r\n} else if (ec->curr->rlen > ec->curr->ri) {\r\nif ((status & ACPI_EC_FLAG_OBF) == 1) {\r\nec->curr->rdata[ec->curr->ri++] = acpi_ec_read_data(ec);\r\nif (ec->curr->rlen == ec->curr->ri)\r\nec->curr->done = true;\r\n} else\r\ngoto err;\r\n} else if (ec->curr->wlen == ec->curr->wi &&\r\n(status & ACPI_EC_FLAG_IBF) == 0)\r\nec->curr->done = true;\r\ngoto unlock;\r\nerr:\r\nif (in_interrupt())\r\n++ec->curr->irq_count;\r\nunlock:\r\nspin_unlock_irqrestore(&ec->curr_lock, flags);\r\n}\r\nstatic int ec_check_sci_sync(struct acpi_ec *ec, u8 state)\r\n{\r\nif (state & ACPI_EC_FLAG_SCI) {\r\nif (!test_and_set_bit(EC_FLAGS_QUERY_PENDING, &ec->flags))\r\nreturn acpi_ec_sync_query(ec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ec_poll(struct acpi_ec *ec)\r\n{\r\nunsigned long flags;\r\nint repeat = 2;\r\nwhile (repeat--) {\r\nunsigned long delay = jiffies +\r\nmsecs_to_jiffies(ec_delay);\r\ndo {\r\nif (EC_FLAGS_MSI || irqs_disabled()) {\r\nudelay(ACPI_EC_MSI_UDELAY);\r\nif (ec_transaction_done(ec))\r\nreturn 0;\r\n} else {\r\nif (wait_event_timeout(ec->wait,\r\nec_transaction_done(ec),\r\nmsecs_to_jiffies(1)))\r\nreturn 0;\r\n}\r\nadvance_transaction(ec, acpi_ec_read_status(ec));\r\n} while (time_before(jiffies, delay));\r\nif (acpi_ec_read_status(ec) & ACPI_EC_FLAG_IBF)\r\nbreak;\r\npr_debug(PREFIX "controller reset, restart transaction\n");\r\nspin_lock_irqsave(&ec->curr_lock, flags);\r\nstart_transaction(ec);\r\nspin_unlock_irqrestore(&ec->curr_lock, flags);\r\n}\r\nreturn -ETIME;\r\n}\r\nstatic int acpi_ec_transaction_unlocked(struct acpi_ec *ec,\r\nstruct transaction *t)\r\n{\r\nunsigned long tmp;\r\nint ret = 0;\r\nif (EC_FLAGS_MSI)\r\nudelay(ACPI_EC_MSI_UDELAY);\r\nspin_lock_irqsave(&ec->curr_lock, tmp);\r\nec->curr = t;\r\nstart_transaction(ec);\r\nif (ec->curr->command == ACPI_EC_COMMAND_QUERY)\r\nclear_bit(EC_FLAGS_QUERY_PENDING, &ec->flags);\r\nspin_unlock_irqrestore(&ec->curr_lock, tmp);\r\nret = ec_poll(ec);\r\nspin_lock_irqsave(&ec->curr_lock, tmp);\r\nec->curr = NULL;\r\nspin_unlock_irqrestore(&ec->curr_lock, tmp);\r\nreturn ret;\r\n}\r\nstatic int ec_check_ibf0(struct acpi_ec *ec)\r\n{\r\nu8 status = acpi_ec_read_status(ec);\r\nreturn (status & ACPI_EC_FLAG_IBF) == 0;\r\n}\r\nstatic int ec_wait_ibf0(struct acpi_ec *ec)\r\n{\r\nunsigned long delay = jiffies + msecs_to_jiffies(ec_delay);\r\nwhile (time_before(jiffies, delay))\r\nif (wait_event_timeout(ec->wait, ec_check_ibf0(ec),\r\nmsecs_to_jiffies(1)))\r\nreturn 0;\r\nreturn -ETIME;\r\n}\r\nstatic int acpi_ec_transaction(struct acpi_ec *ec, struct transaction *t)\r\n{\r\nint status;\r\nu32 glk;\r\nif (!ec || (!t) || (t->wlen && !t->wdata) || (t->rlen && !t->rdata))\r\nreturn -EINVAL;\r\nif (t->rdata)\r\nmemset(t->rdata, 0, t->rlen);\r\nmutex_lock(&ec->lock);\r\nif (test_bit(EC_FLAGS_BLOCKED, &ec->flags)) {\r\nstatus = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (ec->global_lock) {\r\nstatus = acpi_acquire_global_lock(ACPI_EC_UDELAY_GLK, &glk);\r\nif (ACPI_FAILURE(status)) {\r\nstatus = -ENODEV;\r\ngoto unlock;\r\n}\r\n}\r\nif (ec_wait_ibf0(ec)) {\r\npr_err(PREFIX "input buffer is not empty, "\r\n"aborting transaction\n");\r\nstatus = -ETIME;\r\ngoto end;\r\n}\r\npr_debug(PREFIX "transaction start\n");\r\nif (test_bit(EC_FLAGS_GPE_STORM, &ec->flags)) {\r\nacpi_disable_gpe(NULL, ec->gpe);\r\n}\r\nstatus = acpi_ec_transaction_unlocked(ec, t);\r\nec_check_sci_sync(ec, acpi_ec_read_status(ec));\r\nif (test_bit(EC_FLAGS_GPE_STORM, &ec->flags)) {\r\nmsleep(1);\r\nacpi_enable_gpe(NULL, ec->gpe);\r\n} else if (t->irq_count > ACPI_EC_STORM_THRESHOLD) {\r\npr_info(PREFIX "GPE storm detected, "\r\n"transactions will use polling mode\n");\r\nset_bit(EC_FLAGS_GPE_STORM, &ec->flags);\r\n}\r\npr_debug(PREFIX "transaction end\n");\r\nend:\r\nif (ec->global_lock)\r\nacpi_release_global_lock(glk);\r\nunlock:\r\nmutex_unlock(&ec->lock);\r\nreturn status;\r\n}\r\nstatic int acpi_ec_burst_enable(struct acpi_ec *ec)\r\n{\r\nu8 d;\r\nstruct transaction t = {.command = ACPI_EC_BURST_ENABLE,\r\n.wdata = NULL, .rdata = &d,\r\n.wlen = 0, .rlen = 1};\r\nreturn acpi_ec_transaction(ec, &t);\r\n}\r\nstatic int acpi_ec_burst_disable(struct acpi_ec *ec)\r\n{\r\nstruct transaction t = {.command = ACPI_EC_BURST_DISABLE,\r\n.wdata = NULL, .rdata = NULL,\r\n.wlen = 0, .rlen = 0};\r\nreturn (acpi_ec_read_status(ec) & ACPI_EC_FLAG_BURST) ?\r\nacpi_ec_transaction(ec, &t) : 0;\r\n}\r\nstatic int acpi_ec_read(struct acpi_ec *ec, u8 address, u8 * data)\r\n{\r\nint result;\r\nu8 d;\r\nstruct transaction t = {.command = ACPI_EC_COMMAND_READ,\r\n.wdata = &address, .rdata = &d,\r\n.wlen = 1, .rlen = 1};\r\nresult = acpi_ec_transaction(ec, &t);\r\n*data = d;\r\nreturn result;\r\n}\r\nstatic int acpi_ec_write(struct acpi_ec *ec, u8 address, u8 data)\r\n{\r\nu8 wdata[2] = { address, data };\r\nstruct transaction t = {.command = ACPI_EC_COMMAND_WRITE,\r\n.wdata = wdata, .rdata = NULL,\r\n.wlen = 2, .rlen = 0};\r\nreturn acpi_ec_transaction(ec, &t);\r\n}\r\nint ec_burst_enable(void)\r\n{\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nreturn acpi_ec_burst_enable(first_ec);\r\n}\r\nint ec_burst_disable(void)\r\n{\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nreturn acpi_ec_burst_disable(first_ec);\r\n}\r\nint ec_read(u8 addr, u8 * val)\r\n{\r\nint err;\r\nu8 temp_data;\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nerr = acpi_ec_read(first_ec, addr, &temp_data);\r\nif (!err) {\r\n*val = temp_data;\r\nreturn 0;\r\n} else\r\nreturn err;\r\n}\r\nint ec_write(u8 addr, u8 val)\r\n{\r\nint err;\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nerr = acpi_ec_write(first_ec, addr, val);\r\nreturn err;\r\n}\r\nint ec_transaction(u8 command,\r\nconst u8 * wdata, unsigned wdata_len,\r\nu8 * rdata, unsigned rdata_len)\r\n{\r\nstruct transaction t = {.command = command,\r\n.wdata = wdata, .rdata = rdata,\r\n.wlen = wdata_len, .rlen = rdata_len};\r\nif (!first_ec)\r\nreturn -ENODEV;\r\nreturn acpi_ec_transaction(first_ec, &t);\r\n}\r\nacpi_handle ec_get_handle(void)\r\n{\r\nif (!first_ec)\r\nreturn NULL;\r\nreturn first_ec->handle;\r\n}\r\nvoid acpi_ec_block_transactions(void)\r\n{\r\nstruct acpi_ec *ec = first_ec;\r\nif (!ec)\r\nreturn;\r\nmutex_lock(&ec->lock);\r\nset_bit(EC_FLAGS_BLOCKED, &ec->flags);\r\nmutex_unlock(&ec->lock);\r\n}\r\nvoid acpi_ec_unblock_transactions(void)\r\n{\r\nstruct acpi_ec *ec = first_ec;\r\nif (!ec)\r\nreturn;\r\nmutex_lock(&ec->lock);\r\nclear_bit(EC_FLAGS_BLOCKED, &ec->flags);\r\nmutex_unlock(&ec->lock);\r\n}\r\nvoid acpi_ec_unblock_transactions_early(void)\r\n{\r\nif (first_ec)\r\nclear_bit(EC_FLAGS_BLOCKED, &first_ec->flags);\r\n}\r\nstatic int acpi_ec_query_unlocked(struct acpi_ec *ec, u8 * data)\r\n{\r\nint result;\r\nu8 d;\r\nstruct transaction t = {.command = ACPI_EC_COMMAND_QUERY,\r\n.wdata = NULL, .rdata = &d,\r\n.wlen = 0, .rlen = 1};\r\nif (!ec || !data)\r\nreturn -EINVAL;\r\nresult = acpi_ec_transaction_unlocked(ec, &t);\r\nif (result)\r\nreturn result;\r\nif (!d)\r\nreturn -ENODATA;\r\n*data = d;\r\nreturn 0;\r\n}\r\nint acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,\r\nacpi_handle handle, acpi_ec_query_func func,\r\nvoid *data)\r\n{\r\nstruct acpi_ec_query_handler *handler =\r\nkzalloc(sizeof(struct acpi_ec_query_handler), GFP_KERNEL);\r\nif (!handler)\r\nreturn -ENOMEM;\r\nhandler->query_bit = query_bit;\r\nhandler->handle = handle;\r\nhandler->func = func;\r\nhandler->data = data;\r\nmutex_lock(&ec->lock);\r\nlist_add(&handler->node, &ec->list);\r\nmutex_unlock(&ec->lock);\r\nreturn 0;\r\n}\r\nvoid acpi_ec_remove_query_handler(struct acpi_ec *ec, u8 query_bit)\r\n{\r\nstruct acpi_ec_query_handler *handler, *tmp;\r\nmutex_lock(&ec->lock);\r\nlist_for_each_entry_safe(handler, tmp, &ec->list, node) {\r\nif (query_bit == handler->query_bit) {\r\nlist_del(&handler->node);\r\nkfree(handler);\r\n}\r\n}\r\nmutex_unlock(&ec->lock);\r\n}\r\nstatic void acpi_ec_run(void *cxt)\r\n{\r\nstruct acpi_ec_query_handler *handler = cxt;\r\nif (!handler)\r\nreturn;\r\npr_debug(PREFIX "start query execution\n");\r\nif (handler->func)\r\nhandler->func(handler->data);\r\nelse if (handler->handle)\r\nacpi_evaluate_object(handler->handle, NULL, NULL, NULL);\r\npr_debug(PREFIX "stop query execution\n");\r\nkfree(handler);\r\n}\r\nstatic int acpi_ec_sync_query(struct acpi_ec *ec)\r\n{\r\nu8 value = 0;\r\nint status;\r\nstruct acpi_ec_query_handler *handler, *copy;\r\nif ((status = acpi_ec_query_unlocked(ec, &value)))\r\nreturn status;\r\nlist_for_each_entry(handler, &ec->list, node) {\r\nif (value == handler->query_bit) {\r\ncopy = kmalloc(sizeof(*handler), GFP_KERNEL);\r\nif (!copy)\r\nreturn -ENOMEM;\r\nmemcpy(copy, handler, sizeof(*copy));\r\npr_debug(PREFIX "push query execution (0x%2x) on queue\n", value);\r\nreturn acpi_os_execute((copy->func) ?\r\nOSL_NOTIFY_HANDLER : OSL_GPE_HANDLER,\r\nacpi_ec_run, copy);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_ec_gpe_query(void *ec_cxt)\r\n{\r\nstruct acpi_ec *ec = ec_cxt;\r\nif (!ec)\r\nreturn;\r\nmutex_lock(&ec->lock);\r\nacpi_ec_sync_query(ec);\r\nmutex_unlock(&ec->lock);\r\n}\r\nstatic int ec_check_sci(struct acpi_ec *ec, u8 state)\r\n{\r\nif (state & ACPI_EC_FLAG_SCI) {\r\nif (!test_and_set_bit(EC_FLAGS_QUERY_PENDING, &ec->flags)) {\r\npr_debug(PREFIX "push gpe query to the queue\n");\r\nreturn acpi_os_execute(OSL_NOTIFY_HANDLER,\r\nacpi_ec_gpe_query, ec);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 acpi_ec_gpe_handler(acpi_handle gpe_device,\r\nu32 gpe_number, void *data)\r\n{\r\nstruct acpi_ec *ec = data;\r\npr_debug(PREFIX "~~~> interrupt\n");\r\nadvance_transaction(ec, acpi_ec_read_status(ec));\r\nif (ec_transaction_done(ec) &&\r\n(acpi_ec_read_status(ec) & ACPI_EC_FLAG_IBF) == 0) {\r\nwake_up(&ec->wait);\r\nec_check_sci(ec, acpi_ec_read_status(ec));\r\n}\r\nreturn ACPI_INTERRUPT_HANDLED | ACPI_REENABLE_GPE;\r\n}\r\nstatic acpi_status\r\nacpi_ec_space_handler(u32 function, acpi_physical_address address,\r\nu32 bits, u64 *value64,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct acpi_ec *ec = handler_context;\r\nint result = 0, i, bytes = bits / 8;\r\nu8 *value = (u8 *)value64;\r\nif ((address > 0xFF) || !value || !handler_context)\r\nreturn AE_BAD_PARAMETER;\r\nif (function != ACPI_READ && function != ACPI_WRITE)\r\nreturn AE_BAD_PARAMETER;\r\nif (EC_FLAGS_MSI || bits > 8)\r\nacpi_ec_burst_enable(ec);\r\nfor (i = 0; i < bytes; ++i, ++address, ++value)\r\nresult = (function == ACPI_READ) ?\r\nacpi_ec_read(ec, address, value) :\r\nacpi_ec_write(ec, address, *value);\r\nif (EC_FLAGS_MSI || bits > 8)\r\nacpi_ec_burst_disable(ec);\r\nswitch (result) {\r\ncase -EINVAL:\r\nreturn AE_BAD_PARAMETER;\r\nbreak;\r\ncase -ENODEV:\r\nreturn AE_NOT_FOUND;\r\nbreak;\r\ncase -ETIME:\r\nreturn AE_TIME;\r\nbreak;\r\ndefault:\r\nreturn AE_OK;\r\n}\r\n}\r\nstatic struct acpi_ec *make_acpi_ec(void)\r\n{\r\nstruct acpi_ec *ec = kzalloc(sizeof(struct acpi_ec), GFP_KERNEL);\r\nif (!ec)\r\nreturn NULL;\r\nec->flags = 1 << EC_FLAGS_QUERY_PENDING;\r\nmutex_init(&ec->lock);\r\ninit_waitqueue_head(&ec->wait);\r\nINIT_LIST_HEAD(&ec->list);\r\nspin_lock_init(&ec->curr_lock);\r\nreturn ec;\r\n}\r\nstatic acpi_status\r\nacpi_ec_register_query_methods(acpi_handle handle, u32 level,\r\nvoid *context, void **return_value)\r\n{\r\nchar node_name[5];\r\nstruct acpi_buffer buffer = { sizeof(node_name), node_name };\r\nstruct acpi_ec *ec = context;\r\nint value = 0;\r\nacpi_status status;\r\nstatus = acpi_get_name(handle, ACPI_SINGLE_NAME, &buffer);\r\nif (ACPI_SUCCESS(status) && sscanf(node_name, "_Q%x", &value) == 1) {\r\nacpi_ec_add_query_handler(ec, value, handle, NULL, NULL);\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status\r\nec_parse_device(acpi_handle handle, u32 Level, void *context, void **retval)\r\n{\r\nacpi_status status;\r\nunsigned long long tmp = 0;\r\nstruct acpi_ec *ec = context;\r\nec->command_addr = ec->data_addr = 0;\r\nstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\r\nec_parse_io_ports, ec);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nstatus = acpi_evaluate_integer(handle, "_GPE", NULL, &tmp);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nec->gpe = tmp;\r\ntmp = 0;\r\nacpi_evaluate_integer(handle, "_GLK", NULL, &tmp);\r\nec->global_lock = tmp;\r\nec->handle = handle;\r\nreturn AE_CTRL_TERMINATE;\r\n}\r\nstatic int ec_install_handlers(struct acpi_ec *ec)\r\n{\r\nacpi_status status;\r\nif (test_bit(EC_FLAGS_HANDLERS_INSTALLED, &ec->flags))\r\nreturn 0;\r\nstatus = acpi_install_gpe_handler(NULL, ec->gpe,\r\nACPI_GPE_EDGE_TRIGGERED,\r\n&acpi_ec_gpe_handler, ec);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nacpi_enable_gpe(NULL, ec->gpe);\r\nstatus = acpi_install_address_space_handler(ec->handle,\r\nACPI_ADR_SPACE_EC,\r\n&acpi_ec_space_handler,\r\nNULL, ec);\r\nif (ACPI_FAILURE(status)) {\r\nif (status == AE_NOT_FOUND) {\r\nprintk(KERN_ERR "Fail in evaluating the _REG object"\r\n" of EC device. Broken bios is suspected.\n");\r\n} else {\r\nacpi_remove_gpe_handler(NULL, ec->gpe,\r\n&acpi_ec_gpe_handler);\r\nacpi_disable_gpe(NULL, ec->gpe);\r\nreturn -ENODEV;\r\n}\r\n}\r\nset_bit(EC_FLAGS_HANDLERS_INSTALLED, &ec->flags);\r\nreturn 0;\r\n}\r\nstatic void ec_remove_handlers(struct acpi_ec *ec)\r\n{\r\nacpi_disable_gpe(NULL, ec->gpe);\r\nif (ACPI_FAILURE(acpi_remove_address_space_handler(ec->handle,\r\nACPI_ADR_SPACE_EC, &acpi_ec_space_handler)))\r\npr_err(PREFIX "failed to remove space handler\n");\r\nif (ACPI_FAILURE(acpi_remove_gpe_handler(NULL, ec->gpe,\r\n&acpi_ec_gpe_handler)))\r\npr_err(PREFIX "failed to remove gpe handler\n");\r\nclear_bit(EC_FLAGS_HANDLERS_INSTALLED, &ec->flags);\r\n}\r\nstatic int acpi_ec_add(struct acpi_device *device)\r\n{\r\nstruct acpi_ec *ec = NULL;\r\nint ret;\r\nstrcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_EC_CLASS);\r\nif (boot_ec &&\r\n(boot_ec->handle == device->handle ||\r\nboot_ec->handle == ACPI_ROOT_OBJECT)) {\r\nec = boot_ec;\r\nboot_ec = NULL;\r\n} else {\r\nec = make_acpi_ec();\r\nif (!ec)\r\nreturn -ENOMEM;\r\n}\r\nif (ec_parse_device(device->handle, 0, ec, NULL) !=\r\nAE_CTRL_TERMINATE) {\r\nkfree(ec);\r\nreturn -EINVAL;\r\n}\r\nacpi_walk_namespace(ACPI_TYPE_METHOD, ec->handle, 1,\r\nacpi_ec_register_query_methods, NULL, ec, NULL);\r\nif (!first_ec)\r\nfirst_ec = ec;\r\ndevice->driver_data = ec;\r\nret = !!request_region(ec->data_addr, 1, "EC data");\r\nWARN(!ret, "Could not request EC data io port 0x%lx", ec->data_addr);\r\nret = !!request_region(ec->command_addr, 1, "EC cmd");\r\nWARN(!ret, "Could not request EC cmd io port 0x%lx", ec->command_addr);\r\npr_info(PREFIX "GPE = 0x%lx, I/O: command/status = 0x%lx, data = 0x%lx\n",\r\nec->gpe, ec->command_addr, ec->data_addr);\r\nret = ec_install_handlers(ec);\r\nclear_bit(EC_FLAGS_QUERY_PENDING, &ec->flags);\r\nreturn ret;\r\n}\r\nstatic int acpi_ec_remove(struct acpi_device *device, int type)\r\n{\r\nstruct acpi_ec *ec;\r\nstruct acpi_ec_query_handler *handler, *tmp;\r\nif (!device)\r\nreturn -EINVAL;\r\nec = acpi_driver_data(device);\r\nec_remove_handlers(ec);\r\nmutex_lock(&ec->lock);\r\nlist_for_each_entry_safe(handler, tmp, &ec->list, node) {\r\nlist_del(&handler->node);\r\nkfree(handler);\r\n}\r\nmutex_unlock(&ec->lock);\r\nrelease_region(ec->data_addr, 1);\r\nrelease_region(ec->command_addr, 1);\r\ndevice->driver_data = NULL;\r\nif (ec == first_ec)\r\nfirst_ec = NULL;\r\nkfree(ec);\r\nreturn 0;\r\n}\r\nstatic acpi_status\r\nec_parse_io_ports(struct acpi_resource *resource, void *context)\r\n{\r\nstruct acpi_ec *ec = context;\r\nif (resource->type != ACPI_RESOURCE_TYPE_IO)\r\nreturn AE_OK;\r\nif (ec->data_addr == 0)\r\nec->data_addr = resource->data.io.minimum;\r\nelse if (ec->command_addr == 0)\r\nec->command_addr = resource->data.io.minimum;\r\nelse\r\nreturn AE_CTRL_TERMINATE;\r\nreturn AE_OK;\r\n}\r\nint __init acpi_boot_ec_enable(void)\r\n{\r\nif (!boot_ec || test_bit(EC_FLAGS_HANDLERS_INSTALLED, &boot_ec->flags))\r\nreturn 0;\r\nif (!ec_install_handlers(boot_ec)) {\r\nfirst_ec = boot_ec;\r\nreturn 0;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int ec_skip_dsdt_scan(const struct dmi_system_id *id)\r\n{\r\nEC_FLAGS_SKIP_DSDT_SCAN = 1;\r\nreturn 0;\r\n}\r\nstatic int ec_validate_ecdt(const struct dmi_system_id *id)\r\n{\r\nEC_FLAGS_VALIDATE_ECDT = 1;\r\nreturn 0;\r\n}\r\nstatic int ec_flag_msi(const struct dmi_system_id *id)\r\n{\r\nprintk(KERN_DEBUG PREFIX "Detected MSI hardware, enabling workarounds.\n");\r\nEC_FLAGS_MSI = 1;\r\nEC_FLAGS_VALIDATE_ECDT = 1;\r\nreturn 0;\r\n}\r\nint __init acpi_ec_ecdt_probe(void)\r\n{\r\nacpi_status status;\r\nstruct acpi_ec *saved_ec = NULL;\r\nstruct acpi_table_ecdt *ecdt_ptr;\r\nboot_ec = make_acpi_ec();\r\nif (!boot_ec)\r\nreturn -ENOMEM;\r\ndmi_check_system(ec_dmi_table);\r\nstatus = acpi_get_table(ACPI_SIG_ECDT, 1,\r\n(struct acpi_table_header **)&ecdt_ptr);\r\nif (ACPI_SUCCESS(status)) {\r\npr_info(PREFIX "EC description table is found, configuring boot EC\n");\r\nboot_ec->command_addr = ecdt_ptr->control.address;\r\nboot_ec->data_addr = ecdt_ptr->data.address;\r\nboot_ec->gpe = ecdt_ptr->gpe;\r\nboot_ec->handle = ACPI_ROOT_OBJECT;\r\nacpi_get_handle(ACPI_ROOT_OBJECT, ecdt_ptr->id, &boot_ec->handle);\r\nif (!EC_FLAGS_VALIDATE_ECDT)\r\ngoto install;\r\nsaved_ec = kmemdup(boot_ec, sizeof(struct acpi_ec), GFP_KERNEL);\r\nif (!saved_ec)\r\nreturn -ENOMEM;\r\n}\r\nif (EC_FLAGS_SKIP_DSDT_SCAN)\r\nreturn -ENODEV;\r\nprintk(KERN_DEBUG PREFIX "Look up EC in DSDT\n");\r\nstatus = acpi_get_devices(ec_device_ids[0].id, ec_parse_device,\r\nboot_ec, NULL);\r\nif (ACPI_FAILURE(status) || !boot_ec->handle)\r\ngoto error;\r\nif (saved_ec) {\r\nif (saved_ec->command_addr != boot_ec->command_addr ||\r\nsaved_ec->data_addr != boot_ec->data_addr ||\r\nsaved_ec->gpe != boot_ec->gpe ||\r\nsaved_ec->handle != boot_ec->handle)\r\npr_info(PREFIX "ASUSTek keeps feeding us with broken "\r\n"ECDT tables, which are very hard to workaround. "\r\n"Trying to use DSDT EC info instead. Please send "\r\n"output of acpidump to linux-acpi@vger.kernel.org\n");\r\nkfree(saved_ec);\r\nsaved_ec = NULL;\r\n} else {\r\nacpi_handle dummy;\r\nif (!dmi_name_in_vendors("ASUS") ||\r\nACPI_FAILURE(acpi_get_handle(boot_ec->handle, "_INI",\r\n&dummy)))\r\nreturn -ENODEV;\r\n}\r\ninstall:\r\nif (!ec_install_handlers(boot_ec)) {\r\nfirst_ec = boot_ec;\r\nreturn 0;\r\n}\r\nerror:\r\nkfree(boot_ec);\r\nboot_ec = NULL;\r\nreturn -ENODEV;\r\n}\r\nint __init acpi_ec_init(void)\r\n{\r\nint result = 0;\r\nresult = acpi_bus_register_driver(&acpi_ec_driver);\r\nif (result < 0)\r\nreturn -ENODEV;\r\nreturn result;\r\n}
