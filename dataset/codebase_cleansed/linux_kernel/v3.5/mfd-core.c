int mfd_cell_enable(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nint err = 0;\r\nif (atomic_inc_return(cell->usage_count) == 1)\r\nerr = cell->enable(pdev);\r\nif (err)\r\natomic_dec(cell->usage_count);\r\nreturn err;\r\n}\r\nint mfd_cell_disable(struct platform_device *pdev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\nint err = 0;\r\nif (atomic_dec_return(cell->usage_count) == 0)\r\nerr = cell->disable(pdev);\r\nif (err)\r\natomic_inc(cell->usage_count);\r\nWARN_ON(atomic_read(cell->usage_count) < 0);\r\nreturn err;\r\n}\r\nstatic int mfd_platform_add_cell(struct platform_device *pdev,\r\nconst struct mfd_cell *cell)\r\n{\r\nif (!cell)\r\nreturn 0;\r\npdev->mfd_cell = kmemdup(cell, sizeof(*cell), GFP_KERNEL);\r\nif (!pdev->mfd_cell)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int mfd_add_device(struct device *parent, int id,\r\nconst struct mfd_cell *cell,\r\nstruct resource *mem_base,\r\nint irq_base)\r\n{\r\nstruct resource *res;\r\nstruct platform_device *pdev;\r\nint ret = -ENOMEM;\r\nint r;\r\npdev = platform_device_alloc(cell->name, id + cell->id);\r\nif (!pdev)\r\ngoto fail_alloc;\r\nres = kzalloc(sizeof(*res) * cell->num_resources, GFP_KERNEL);\r\nif (!res)\r\ngoto fail_device;\r\npdev->dev.parent = parent;\r\nif (cell->pdata_size) {\r\nret = platform_device_add_data(pdev,\r\ncell->platform_data, cell->pdata_size);\r\nif (ret)\r\ngoto fail_res;\r\n}\r\nret = mfd_platform_add_cell(pdev, cell);\r\nif (ret)\r\ngoto fail_res;\r\nfor (r = 0; r < cell->num_resources; r++) {\r\nres[r].name = cell->resources[r].name;\r\nres[r].flags = cell->resources[r].flags;\r\nif ((cell->resources[r].flags & IORESOURCE_MEM) && mem_base) {\r\nres[r].parent = mem_base;\r\nres[r].start = mem_base->start +\r\ncell->resources[r].start;\r\nres[r].end = mem_base->start +\r\ncell->resources[r].end;\r\n} else if (cell->resources[r].flags & IORESOURCE_IRQ) {\r\nres[r].start = irq_base +\r\ncell->resources[r].start;\r\nres[r].end = irq_base +\r\ncell->resources[r].end;\r\n} else {\r\nres[r].parent = cell->resources[r].parent;\r\nres[r].start = cell->resources[r].start;\r\nres[r].end = cell->resources[r].end;\r\n}\r\nif (!cell->ignore_resource_conflicts) {\r\nret = acpi_check_resource_conflict(&res[r]);\r\nif (ret)\r\ngoto fail_res;\r\n}\r\n}\r\nret = platform_device_add_resources(pdev, res, cell->num_resources);\r\nif (ret)\r\ngoto fail_res;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto fail_res;\r\nif (cell->pm_runtime_no_callbacks)\r\npm_runtime_no_callbacks(&pdev->dev);\r\nkfree(res);\r\nreturn 0;\r\nfail_res:\r\nkfree(res);\r\nfail_device:\r\nplatform_device_put(pdev);\r\nfail_alloc:\r\nreturn ret;\r\n}\r\nint mfd_add_devices(struct device *parent, int id,\r\nstruct mfd_cell *cells, int n_devs,\r\nstruct resource *mem_base,\r\nint irq_base)\r\n{\r\nint i;\r\nint ret = 0;\r\natomic_t *cnts;\r\ncnts = kcalloc(n_devs, sizeof(*cnts), GFP_KERNEL);\r\nif (!cnts)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n_devs; i++) {\r\natomic_set(&cnts[i], 0);\r\ncells[i].usage_count = &cnts[i];\r\nret = mfd_add_device(parent, id, cells + i, mem_base, irq_base);\r\nif (ret)\r\nbreak;\r\n}\r\nif (ret)\r\nmfd_remove_devices(parent);\r\nreturn ret;\r\n}\r\nstatic int mfd_remove_devices_fn(struct device *dev, void *c)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nconst struct mfd_cell *cell = mfd_get_cell(pdev);\r\natomic_t **usage_count = c;\r\nif (!*usage_count || (cell->usage_count < *usage_count))\r\n*usage_count = cell->usage_count;\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nvoid mfd_remove_devices(struct device *parent)\r\n{\r\natomic_t *cnts = NULL;\r\ndevice_for_each_child(parent, &cnts, mfd_remove_devices_fn);\r\nkfree(cnts);\r\n}\r\nint mfd_clone_cell(const char *cell, const char **clones, size_t n_clones)\r\n{\r\nstruct mfd_cell cell_entry;\r\nstruct device *dev;\r\nstruct platform_device *pdev;\r\nint i;\r\ndev = bus_find_device_by_name(&platform_bus_type, NULL, cell);\r\nif (!dev) {\r\nprintk(KERN_ERR "failed to find device for cell %s\n", cell);\r\nreturn -ENODEV;\r\n}\r\npdev = to_platform_device(dev);\r\nmemcpy(&cell_entry, mfd_get_cell(pdev), sizeof(cell_entry));\r\nWARN_ON(!cell_entry.enable);\r\nfor (i = 0; i < n_clones; i++) {\r\ncell_entry.name = clones[i];\r\nif (mfd_add_device(pdev->dev.parent, -1, &cell_entry, NULL, 0))\r\ndev_err(dev, "failed to create platform device '%s'\n",\r\nclones[i]);\r\n}\r\nreturn 0;\r\n}
