static ssize_t\r\neeprom_93xx46_bin_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct eeprom_93xx46_dev *edev;\r\nstruct device *dev;\r\nstruct spi_message m;\r\nstruct spi_transfer t[2];\r\nint bits, ret;\r\nu16 cmd_addr;\r\ndev = container_of(kobj, struct device, kobj);\r\nedev = dev_get_drvdata(dev);\r\nif (unlikely(off >= edev->bin.size))\r\nreturn 0;\r\nif ((off + count) > edev->bin.size)\r\ncount = edev->bin.size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\ncmd_addr = OP_READ << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= off & 0x7f;\r\nbits = 10;\r\n} else {\r\ncmd_addr |= off & 0x3f;\r\nbits = 9;\r\n}\r\ndev_dbg(&edev->spi->dev, "read cmd 0x%x, %d Hz\n",\r\ncmd_addr, edev->spi->max_speed_hz);\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = (char *)&cmd_addr;\r\nt[0].len = 2;\r\nt[0].bits_per_word = bits;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = count;\r\nt[1].bits_per_word = 8;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nret = spi_sync(edev->spi, &m);\r\nndelay(250);\r\nif (ret) {\r\ndev_err(&edev->spi->dev, "read %zu bytes at %d: err. %d\n",\r\ncount, (int)off, ret);\r\n}\r\nif (edev->pdata->finish)\r\nedev->pdata->finish(edev);\r\nmutex_unlock(&edev->lock);\r\nreturn ret ? : count;\r\n}\r\nstatic int eeprom_93xx46_ew(struct eeprom_93xx46_dev *edev, int is_on)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nint bits, ret;\r\nu16 cmd_addr;\r\ncmd_addr = OP_START << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= (is_on ? ADDR_EWEN : ADDR_EWDS) << 1;\r\nbits = 10;\r\n} else {\r\ncmd_addr |= (is_on ? ADDR_EWEN : ADDR_EWDS);\r\nbits = 9;\r\n}\r\ndev_dbg(&edev->spi->dev, "ew cmd 0x%04x\n", cmd_addr);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt.tx_buf = &cmd_addr;\r\nt.len = 2;\r\nt.bits_per_word = bits;\r\nspi_message_add_tail(&t, &m);\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nret = spi_sync(edev->spi, &m);\r\nndelay(250);\r\nif (ret)\r\ndev_err(&edev->spi->dev, "erase/write %sable error %d\n",\r\nis_on ? "en" : "dis", ret);\r\nif (edev->pdata->finish)\r\nedev->pdata->finish(edev);\r\nmutex_unlock(&edev->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\neeprom_93xx46_write_word(struct eeprom_93xx46_dev *edev,\r\nconst char *buf, unsigned off)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer t[2];\r\nint bits, data_len, ret;\r\nu16 cmd_addr;\r\ncmd_addr = OP_WRITE << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= off & 0x7f;\r\nbits = 10;\r\ndata_len = 1;\r\n} else {\r\ncmd_addr |= off & 0x3f;\r\nbits = 9;\r\ndata_len = 2;\r\n}\r\ndev_dbg(&edev->spi->dev, "write cmd 0x%x\n", cmd_addr);\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof(t));\r\nt[0].tx_buf = (char *)&cmd_addr;\r\nt[0].len = 2;\r\nt[0].bits_per_word = bits;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].tx_buf = buf;\r\nt[1].len = data_len;\r\nt[1].bits_per_word = 8;\r\nspi_message_add_tail(&t[1], &m);\r\nret = spi_sync(edev->spi, &m);\r\nmdelay(6);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\neeprom_93xx46_bin_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct eeprom_93xx46_dev *edev;\r\nstruct device *dev;\r\nint i, ret, step = 1;\r\ndev = container_of(kobj, struct device, kobj);\r\nedev = dev_get_drvdata(dev);\r\nif (unlikely(off >= edev->bin.size))\r\nreturn 0;\r\nif ((off + count) > edev->bin.size)\r\ncount = edev->bin.size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nif (edev->addrlen == 6) {\r\nstep = 2;\r\ncount &= ~1;\r\n}\r\nret = eeprom_93xx46_ew(edev, 1);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nfor (i = 0; i < count; i += step) {\r\nret = eeprom_93xx46_write_word(edev, &buf[i], off + i);\r\nif (ret) {\r\ndev_err(&edev->spi->dev, "write failed at %d: %d\n",\r\n(int)off + i, ret);\r\nbreak;\r\n}\r\n}\r\nif (edev->pdata->finish)\r\nedev->pdata->finish(edev);\r\nmutex_unlock(&edev->lock);\r\neeprom_93xx46_ew(edev, 0);\r\nreturn ret ? : count;\r\n}\r\nstatic int eeprom_93xx46_eral(struct eeprom_93xx46_dev *edev)\r\n{\r\nstruct eeprom_93xx46_platform_data *pd = edev->pdata;\r\nstruct spi_message m;\r\nstruct spi_transfer t;\r\nint bits, ret;\r\nu16 cmd_addr;\r\ncmd_addr = OP_START << edev->addrlen;\r\nif (edev->addrlen == 7) {\r\ncmd_addr |= ADDR_ERAL << 1;\r\nbits = 10;\r\n} else {\r\ncmd_addr |= ADDR_ERAL;\r\nbits = 9;\r\n}\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof(t));\r\nt.tx_buf = &cmd_addr;\r\nt.len = 2;\r\nt.bits_per_word = bits;\r\nspi_message_add_tail(&t, &m);\r\nmutex_lock(&edev->lock);\r\nif (edev->pdata->prepare)\r\nedev->pdata->prepare(edev);\r\nret = spi_sync(edev->spi, &m);\r\nif (ret)\r\ndev_err(&edev->spi->dev, "erase error %d\n", ret);\r\nmdelay(6);\r\nif (pd->finish)\r\npd->finish(edev);\r\nmutex_unlock(&edev->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t eeprom_93xx46_store_erase(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct eeprom_93xx46_dev *edev = dev_get_drvdata(dev);\r\nint erase = 0, ret;\r\nsscanf(buf, "%d", &erase);\r\nif (erase) {\r\nret = eeprom_93xx46_ew(edev, 1);\r\nif (ret)\r\nreturn ret;\r\nret = eeprom_93xx46_eral(edev);\r\nif (ret)\r\nreturn ret;\r\nret = eeprom_93xx46_ew(edev, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn count;\r\n}\r\nstatic int __devinit eeprom_93xx46_probe(struct spi_device *spi)\r\n{\r\nstruct eeprom_93xx46_platform_data *pd;\r\nstruct eeprom_93xx46_dev *edev;\r\nint err;\r\npd = spi->dev.platform_data;\r\nif (!pd) {\r\ndev_err(&spi->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev)\r\nreturn -ENOMEM;\r\nif (pd->flags & EE_ADDR8)\r\nedev->addrlen = 7;\r\nelse if (pd->flags & EE_ADDR16)\r\nedev->addrlen = 6;\r\nelse {\r\ndev_err(&spi->dev, "unspecified address type\n");\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nmutex_init(&edev->lock);\r\nedev->spi = spi_dev_get(spi);\r\nedev->pdata = pd;\r\nsysfs_bin_attr_init(&edev->bin);\r\nedev->bin.attr.name = "eeprom";\r\nedev->bin.attr.mode = S_IRUSR;\r\nedev->bin.read = eeprom_93xx46_bin_read;\r\nedev->bin.size = 128;\r\nif (!(pd->flags & EE_READONLY)) {\r\nedev->bin.write = eeprom_93xx46_bin_write;\r\nedev->bin.attr.mode |= S_IWUSR;\r\n}\r\nerr = sysfs_create_bin_file(&spi->dev.kobj, &edev->bin);\r\nif (err)\r\ngoto fail;\r\ndev_info(&spi->dev, "%d-bit eeprom %s\n",\r\n(pd->flags & EE_ADDR8) ? 8 : 16,\r\n(pd->flags & EE_READONLY) ? "(readonly)" : "");\r\nif (!(pd->flags & EE_READONLY)) {\r\nif (device_create_file(&spi->dev, &dev_attr_erase))\r\ndev_err(&spi->dev, "can't create erase interface\n");\r\n}\r\ndev_set_drvdata(&spi->dev, edev);\r\nreturn 0;\r\nfail:\r\nkfree(edev);\r\nreturn err;\r\n}\r\nstatic int __devexit eeprom_93xx46_remove(struct spi_device *spi)\r\n{\r\nstruct eeprom_93xx46_dev *edev = dev_get_drvdata(&spi->dev);\r\nif (!(edev->pdata->flags & EE_READONLY))\r\ndevice_remove_file(&spi->dev, &dev_attr_erase);\r\nsysfs_remove_bin_file(&spi->dev.kobj, &edev->bin);\r\ndev_set_drvdata(&spi->dev, NULL);\r\nkfree(edev);\r\nreturn 0;\r\n}
