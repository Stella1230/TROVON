int ieee754dp_class(ieee754dp x)\r\n{\r\nCOMPXDP;\r\nEXPLODEXDP;\r\nreturn xc;\r\n}\r\nint ieee754dp_isnan(ieee754dp x)\r\n{\r\nreturn ieee754dp_class(x) >= IEEE754_CLASS_SNAN;\r\n}\r\nint ieee754dp_issnan(ieee754dp x)\r\n{\r\nassert(ieee754dp_isnan(x));\r\nreturn ((DPMANT(x) & DP_MBIT(DP_MBITS-1)) == DP_MBIT(DP_MBITS-1));\r\n}\r\nieee754dp ieee754dp_xcpt(ieee754dp r, const char *op, ...)\r\n{\r\nstruct ieee754xctx ax;\r\nif (!TSTX())\r\nreturn r;\r\nax.op = op;\r\nax.rt = IEEE754_RT_DP;\r\nax.rv.dp = r;\r\nva_start(ax.ap, op);\r\nieee754_xcpt(&ax);\r\nva_end(ax.ap);\r\nreturn ax.rv.dp;\r\n}\r\nieee754dp ieee754dp_nanxcpt(ieee754dp r, const char *op, ...)\r\n{\r\nstruct ieee754xctx ax;\r\nassert(ieee754dp_isnan(r));\r\nif (!ieee754dp_issnan(r))\r\nreturn r;\r\nif (!SETANDTESTCX(IEEE754_INVALID_OPERATION)) {\r\nDPMANT(r) &= (~DP_MBIT(DP_MBITS-1));\r\nif (ieee754dp_isnan(r))\r\nreturn r;\r\nelse\r\nreturn ieee754dp_indef();\r\n}\r\nax.op = op;\r\nax.rt = 0;\r\nax.rv.dp = r;\r\nva_start(ax.ap, op);\r\nieee754_xcpt(&ax);\r\nva_end(ax.ap);\r\nreturn ax.rv.dp;\r\n}\r\nieee754dp ieee754dp_bestnan(ieee754dp x, ieee754dp y)\r\n{\r\nassert(ieee754dp_isnan(x));\r\nassert(ieee754dp_isnan(y));\r\nif (DPMANT(x) > DPMANT(y))\r\nreturn x;\r\nelse\r\nreturn y;\r\n}\r\nstatic u64 get_rounding(int sn, u64 xm)\r\n{\r\nif (xm & (DP_MBIT(3) - 1)) {\r\nswitch (ieee754_csr.rm) {\r\ncase IEEE754_RZ:\r\nbreak;\r\ncase IEEE754_RN:\r\nxm += 0x3 + ((xm >> 3) & 1);\r\nbreak;\r\ncase IEEE754_RU:\r\nif (!sn)\r\nxm += 0x8;\r\nbreak;\r\ncase IEEE754_RD:\r\nif (sn)\r\nxm += 0x8;\r\nbreak;\r\n}\r\n}\r\nreturn xm;\r\n}\r\nieee754dp ieee754dp_format(int sn, int xe, u64 xm)\r\n{\r\nassert(xm);\r\nassert((xm >> (DP_MBITS + 1 + 3)) == 0);\r\nassert(xm & (DP_HIDDEN_BIT << 3));\r\nif (xe < DP_EMIN) {\r\nint es = DP_EMIN - xe;\r\nif (ieee754_csr.nod) {\r\nSETCX(IEEE754_UNDERFLOW);\r\nSETCX(IEEE754_INEXACT);\r\nswitch(ieee754_csr.rm) {\r\ncase IEEE754_RN:\r\ncase IEEE754_RZ:\r\nreturn ieee754dp_zero(sn);\r\ncase IEEE754_RU:\r\nif(sn == 0)\r\nreturn ieee754dp_min(0);\r\nelse\r\nreturn ieee754dp_zero(1);\r\ncase IEEE754_RD:\r\nif(sn == 0)\r\nreturn ieee754dp_zero(0);\r\nelse\r\nreturn ieee754dp_min(1);\r\n}\r\n}\r\nif (xe == DP_EMIN - 1\r\n&& get_rounding(sn, xm) >> (DP_MBITS + 1 + 3))\r\n{\r\nSETCX(IEEE754_INEXACT);\r\nxm = get_rounding(sn, xm);\r\nxm >>= 1;\r\nxm &= ~(DP_MBIT(3) - 1);\r\nxe++;\r\n}\r\nelse {\r\nxm = XDPSRS(xm, es);\r\nxe += es;\r\nassert((xm & (DP_HIDDEN_BIT << 3)) == 0);\r\nassert(xe == DP_EMIN);\r\n}\r\n}\r\nif (xm & (DP_MBIT(3) - 1)) {\r\nSETCX(IEEE754_INEXACT);\r\nif ((xm & (DP_HIDDEN_BIT << 3)) == 0) {\r\nSETCX(IEEE754_UNDERFLOW);\r\n}\r\nxm = get_rounding(sn, xm);\r\nif (xm >> (DP_MBITS + 3 + 1)) {\r\nxm >>= 1;\r\nxe++;\r\n}\r\n}\r\nxm >>= 3;\r\nassert((xm >> (DP_MBITS + 1)) == 0);\r\nassert(xe >= DP_EMIN);\r\nif (xe > DP_EMAX) {\r\nSETCX(IEEE754_OVERFLOW);\r\nSETCX(IEEE754_INEXACT);\r\nswitch (ieee754_csr.rm) {\r\ncase IEEE754_RN:\r\nreturn ieee754dp_inf(sn);\r\ncase IEEE754_RZ:\r\nreturn ieee754dp_max(sn);\r\ncase IEEE754_RU:\r\nif (sn == 0)\r\nreturn ieee754dp_inf(0);\r\nelse\r\nreturn ieee754dp_max(1);\r\ncase IEEE754_RD:\r\nif (sn == 0)\r\nreturn ieee754dp_max(0);\r\nelse\r\nreturn ieee754dp_inf(1);\r\n}\r\n}\r\nif ((xm & DP_HIDDEN_BIT) == 0) {\r\nassert(xe == DP_EMIN);\r\nif (ieee754_csr.mx & IEEE754_UNDERFLOW)\r\nSETCX(IEEE754_UNDERFLOW);\r\nreturn builddp(sn, DP_EMIN - 1 + DP_EBIAS, xm);\r\n} else {\r\nassert((xm >> (DP_MBITS + 1)) == 0);\r\nassert(xm & DP_HIDDEN_BIT);\r\nreturn builddp(sn, xe + DP_EBIAS, xm & ~DP_HIDDEN_BIT);\r\n}\r\n}
