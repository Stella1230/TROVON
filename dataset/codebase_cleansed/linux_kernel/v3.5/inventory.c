void __init setup_pdc(void)\r\n{\r\nlong status;\r\nunsigned int bus_id;\r\nstruct pdc_system_map_mod_info module_result;\r\nstruct pdc_module_path module_path;\r\nstruct pdc_model model;\r\n#ifdef CONFIG_64BIT\r\nstruct pdc_pat_cell_num cell_info;\r\n#endif\r\nprintk(KERN_INFO "Determining PDC firmware type: ");\r\nstatus = pdc_system_map_find_mods(&module_result, &module_path, 0);\r\nif (status == PDC_OK) {\r\npdc_type = PDC_TYPE_SYSTEM_MAP;\r\nprintk("System Map.\n");\r\nreturn;\r\n}\r\n#ifdef CONFIG_64BIT\r\nstatus = pdc_pat_cell_get_number(&cell_info);\r\nif (status == PDC_OK) {\r\npdc_type = PDC_TYPE_PAT;\r\nprintk("64 bit PAT.\n");\r\nreturn;\r\n}\r\n#endif\r\nstatus = pdc_model_info(&model);\r\nbus_id = (model.hversion >> (4 + 7)) & 0x1f;\r\nswitch (bus_id) {\r\ncase 0x4:\r\ncase 0x6:\r\ncase 0x7:\r\ncase 0x8:\r\ncase 0xA:\r\ncase 0xC:\r\npdc_type = PDC_TYPE_SNAKE;\r\nprintk("Snake.\n");\r\nreturn;\r\ndefault:\r\nprintk("Unsupported.\n");\r\npanic("If this is a 64-bit machine, please try a 64-bit kernel.\n");\r\n}\r\n}\r\nstatic void __init\r\nset_pmem_entry(physmem_range_t *pmem_ptr, unsigned long start,\r\nunsigned long pages4k)\r\n{\r\nif (unlikely( ((start & (PAGE_SIZE - 1)) != 0)\r\n|| ((pages4k & ((1UL << PDC_PAGE_ADJ_SHIFT) - 1)) != 0) )) {\r\npanic("Memory range doesn't align with page size!\n");\r\n}\r\npmem_ptr->start_pfn = (start >> PAGE_SHIFT);\r\npmem_ptr->pages = (pages4k >> PDC_PAGE_ADJ_SHIFT);\r\n}\r\nstatic void __init pagezero_memconfig(void)\r\n{\r\nunsigned long npages;\r\nnpages = (PAGE_ALIGN(PAGE0->imm_max_mem) >> PAGE_SHIFT);\r\nset_pmem_entry(pmem_ranges,0UL,npages);\r\nnpmem_ranges = 1;\r\n}\r\nstatic int __init\r\npat_query_module(ulong pcell_loc, ulong mod_index)\r\n{\r\npdc_pat_cell_mod_maddr_block_t *pa_pdc_cell;\r\nunsigned long bytecnt;\r\nunsigned long temp;\r\nlong status;\r\nstruct parisc_device *dev;\r\npa_pdc_cell = kmalloc(sizeof (*pa_pdc_cell), GFP_KERNEL);\r\nif (!pa_pdc_cell)\r\npanic("couldn't allocate memory for PDC_PAT_CELL!");\r\nstatus = pdc_pat_cell_module(&bytecnt, pcell_loc, mod_index,\r\nPA_VIEW, pa_pdc_cell);\r\nif (status != PDC_OK) {\r\nreturn status;\r\n}\r\ntemp = pa_pdc_cell->cba;\r\ndev = alloc_pa_dev(PAT_GET_CBA(temp), &(pa_pdc_cell->mod_path));\r\nif (!dev) {\r\nreturn PDC_OK;\r\n}\r\ndev->pcell_loc = pcell_loc;\r\ndev->mod_index = mod_index;\r\ndev->mod_info = pa_pdc_cell->mod_info;\r\ndev->pmod_loc = pa_pdc_cell->mod_location;\r\nregister_parisc_device(dev);\r\n#ifdef DEBUG_PAT\r\npdc_pat_cell_mod_maddr_block_t io_pdc_cell;\r\nswitch (PAT_GET_ENTITY(dev->mod_info)) {\r\nunsigned long i;\r\ncase PAT_ENTITY_PROC:\r\nprintk(KERN_DEBUG "PAT_ENTITY_PROC: id_eid 0x%lx\n",\r\npa_pdc_cell->mod[0]);\r\nbreak;\r\ncase PAT_ENTITY_MEM:\r\nprintk(KERN_DEBUG\r\n"PAT_ENTITY_MEM: amount 0x%lx min_gni_base 0x%lx min_gni_len 0x%lx\n",\r\npa_pdc_cell->mod[0], pa_pdc_cell->mod[1],\r\npa_pdc_cell->mod[2]);\r\nbreak;\r\ncase PAT_ENTITY_CA:\r\nprintk(KERN_DEBUG "PAT_ENTITY_CA: %ld\n", pcell_loc);\r\nbreak;\r\ncase PAT_ENTITY_PBC:\r\nprintk(KERN_DEBUG "PAT_ENTITY_PBC: ");\r\ngoto print_ranges;\r\ncase PAT_ENTITY_SBA:\r\nprintk(KERN_DEBUG "PAT_ENTITY_SBA: ");\r\ngoto print_ranges;\r\ncase PAT_ENTITY_LBA:\r\nprintk(KERN_DEBUG "PAT_ENTITY_LBA: ");\r\nprint_ranges:\r\npdc_pat_cell_module(&bytecnt, pcell_loc, mod_index,\r\nIO_VIEW, &io_pdc_cell);\r\nprintk(KERN_DEBUG "ranges %ld\n", pa_pdc_cell->mod[1]);\r\nfor (i = 0; i < pa_pdc_cell->mod[1]; i++) {\r\nprintk(KERN_DEBUG\r\n" PA_VIEW %ld: 0x%016lx 0x%016lx 0x%016lx\n",\r\ni, pa_pdc_cell->mod[2 + i * 3],\r\npa_pdc_cell->mod[3 + i * 3],\r\npa_pdc_cell->mod[4 + i * 3]);\r\nprintk(KERN_DEBUG\r\n" IO_VIEW %ld: 0x%016lx 0x%016lx 0x%016lx\n",\r\ni, io_pdc_cell->mod[2 + i * 3],\r\nio_pdc_cell->mod[3 + i * 3],\r\nio_pdc_cell->mod[4 + i * 3]);\r\n}\r\nprintk(KERN_DEBUG "\n");\r\nbreak;\r\n}\r\n#endif\r\nkfree(pa_pdc_cell);\r\nreturn PDC_OK;\r\n}\r\nstatic void __init pat_memconfig(void)\r\n{\r\nunsigned long actual_len;\r\nstruct pdc_pat_pd_addr_map_entry mem_table[PAT_MAX_RANGES+1];\r\nstruct pdc_pat_pd_addr_map_entry *mtbl_ptr;\r\nphysmem_range_t *pmem_ptr;\r\nlong status;\r\nint entries;\r\nunsigned long length;\r\nint i;\r\nlength = (PAT_MAX_RANGES + 1) * sizeof(struct pdc_pat_pd_addr_map_entry);\r\nstatus = pdc_pat_pd_get_addr_map(&actual_len, mem_table, length, 0L);\r\nif ((status != PDC_OK)\r\n|| ((actual_len % sizeof(struct pdc_pat_pd_addr_map_entry)) != 0)) {\r\nprintk("\n\n\n");\r\nprintk(KERN_WARNING "WARNING! Could not get full memory configuration. "\r\n"All memory may not be used!\n\n\n");\r\npagezero_memconfig();\r\nreturn;\r\n}\r\nentries = actual_len / sizeof(struct pdc_pat_pd_addr_map_entry);\r\nif (entries > PAT_MAX_RANGES) {\r\nprintk(KERN_WARNING "This Machine has more memory ranges than we support!\n");\r\nprintk(KERN_WARNING "Some memory may not be used!\n");\r\n}\r\nnpmem_ranges = 0;\r\nmtbl_ptr = mem_table;\r\npmem_ptr = pmem_ranges;\r\nfor (i = 0; i < entries; i++,mtbl_ptr++) {\r\nif ( (mtbl_ptr->entry_type != PAT_MEMORY_DESCRIPTOR)\r\n|| (mtbl_ptr->memory_type != PAT_MEMTYPE_MEMORY)\r\n|| (mtbl_ptr->pages == 0)\r\n|| ( (mtbl_ptr->memory_usage != PAT_MEMUSE_GENERAL)\r\n&& (mtbl_ptr->memory_usage != PAT_MEMUSE_GI)\r\n&& (mtbl_ptr->memory_usage != PAT_MEMUSE_GNI) ) ) {\r\ncontinue;\r\n}\r\nif (npmem_ranges == MAX_PHYSMEM_RANGES) {\r\nprintk(KERN_WARNING "This Machine has more memory ranges than we support!\n");\r\nprintk(KERN_WARNING "Some memory will not be used!\n");\r\nbreak;\r\n}\r\nset_pmem_entry(pmem_ptr++,mtbl_ptr->paddr,mtbl_ptr->pages);\r\nnpmem_ranges++;\r\n}\r\n}\r\nstatic int __init pat_inventory(void)\r\n{\r\nint status;\r\nulong mod_index = 0;\r\nstruct pdc_pat_cell_num cell_info;\r\nstatus = pdc_pat_cell_get_number(&cell_info);\r\nif (status != PDC_OK) {\r\nreturn 0;\r\n}\r\n#ifdef DEBUG_PAT\r\nprintk(KERN_DEBUG "CELL_GET_NUMBER: 0x%lx 0x%lx\n", cell_info.cell_num,\r\ncell_info.cell_loc);\r\n#endif\r\nwhile (PDC_OK == pat_query_module(cell_info.cell_loc, mod_index)) {\r\nmod_index++;\r\n}\r\nreturn mod_index;\r\n}\r\nstatic void __init sprockets_memconfig(void)\r\n{\r\nstruct pdc_memory_table_raddr r_addr;\r\nstruct pdc_memory_table mem_table[MAX_PHYSMEM_RANGES];\r\nstruct pdc_memory_table *mtbl_ptr;\r\nphysmem_range_t *pmem_ptr;\r\nlong status;\r\nint entries;\r\nint i;\r\nstatus = pdc_mem_mem_table(&r_addr,mem_table,\r\n(unsigned long)MAX_PHYSMEM_RANGES);\r\nif (status != PDC_OK) {\r\npagezero_memconfig();\r\nreturn;\r\n}\r\nif (r_addr.entries_total > MAX_PHYSMEM_RANGES) {\r\nprintk(KERN_WARNING "This Machine has more memory ranges than we support!\n");\r\nprintk(KERN_WARNING "Some memory will not be used!\n");\r\n}\r\nentries = (int)r_addr.entries_returned;\r\nnpmem_ranges = 0;\r\nmtbl_ptr = mem_table;\r\npmem_ptr = pmem_ranges;\r\nfor (i = 0; i < entries; i++,mtbl_ptr++) {\r\nset_pmem_entry(pmem_ptr++,mtbl_ptr->paddr,mtbl_ptr->pages);\r\nnpmem_ranges++;\r\n}\r\n}\r\nstatic struct parisc_device * __init\r\nlegacy_create_device(struct pdc_memory_map *r_addr,\r\nstruct pdc_module_path *module_path)\r\n{\r\nstruct parisc_device *dev;\r\nint status = pdc_mem_map_hpa(r_addr, module_path);\r\nif (status != PDC_OK)\r\nreturn NULL;\r\ndev = alloc_pa_dev(r_addr->hpa, &module_path->path);\r\nif (dev == NULL)\r\nreturn NULL;\r\nregister_parisc_device(dev);\r\nreturn dev;\r\n}\r\nstatic void __init snake_inventory(void)\r\n{\r\nint mod;\r\nfor (mod = 0; mod < 16; mod++) {\r\nstruct parisc_device *dev;\r\nstruct pdc_module_path module_path;\r\nstruct pdc_memory_map r_addr;\r\nunsigned int func;\r\nmemset(module_path.path.bc, 0xff, 6);\r\nmodule_path.path.mod = mod;\r\ndev = legacy_create_device(&r_addr, &module_path);\r\nif ((!dev) || (dev->id.hw_type != HPHW_BA))\r\ncontinue;\r\nmemset(module_path.path.bc, 0xff, 4);\r\nmodule_path.path.bc[4] = mod;\r\nfor (func = 0; func < 16; func++) {\r\nmodule_path.path.bc[5] = 0;\r\nmodule_path.path.mod = func;\r\nlegacy_create_device(&r_addr, &module_path);\r\n}\r\n}\r\n}\r\nstatic void __init\r\nadd_system_map_addresses(struct parisc_device *dev, int num_addrs,\r\nint module_instance)\r\n{\r\nint i;\r\nlong status;\r\nstruct pdc_system_map_addr_info addr_result;\r\ndev->addr = kmalloc(num_addrs * sizeof(unsigned long), GFP_KERNEL);\r\nif(!dev->addr) {\r\nprintk(KERN_ERR "%s %s(): memory allocation failure\n",\r\n__FILE__, __func__);\r\nreturn;\r\n}\r\nfor(i = 1; i <= num_addrs; ++i) {\r\nstatus = pdc_system_map_find_addrs(&addr_result,\r\nmodule_instance, i);\r\nif(PDC_OK == status) {\r\ndev->addr[dev->num_addrs] = (unsigned long)addr_result.mod_addr;\r\ndev->num_addrs++;\r\n} else {\r\nprintk(KERN_WARNING\r\n"Bad PDC_FIND_ADDRESS status return (%ld) for index %d\n",\r\nstatus, i);\r\n}\r\n}\r\n}\r\nstatic void __init system_map_inventory(void)\r\n{\r\nint i;\r\nlong status = PDC_OK;\r\nfor (i = 0; i < 256; i++) {\r\nstruct parisc_device *dev;\r\nstruct pdc_system_map_mod_info module_result;\r\nstruct pdc_module_path module_path;\r\nstatus = pdc_system_map_find_mods(&module_result,\r\n&module_path, i);\r\nif ((status == PDC_BAD_PROC) || (status == PDC_NE_MOD))\r\nbreak;\r\nif (status != PDC_OK)\r\ncontinue;\r\ndev = alloc_pa_dev(module_result.mod_addr, &module_path.path);\r\nif (!dev)\r\ncontinue;\r\nregister_parisc_device(dev);\r\nif (!module_result.add_addrs)\r\ncontinue;\r\nadd_system_map_addresses(dev, module_result.add_addrs, i);\r\n}\r\nwalk_central_bus();\r\nreturn;\r\n}\r\nvoid __init do_memory_inventory(void)\r\n{\r\nswitch (pdc_type) {\r\ncase PDC_TYPE_PAT:\r\npat_memconfig();\r\nbreak;\r\ncase PDC_TYPE_SYSTEM_MAP:\r\nsprockets_memconfig();\r\nbreak;\r\ncase PDC_TYPE_SNAKE:\r\npagezero_memconfig();\r\nreturn;\r\ndefault:\r\npanic("Unknown PDC type!\n");\r\n}\r\nif (npmem_ranges == 0 || pmem_ranges[0].start_pfn != 0) {\r\nprintk(KERN_WARNING "Bad memory configuration returned!\n");\r\nprintk(KERN_WARNING "Some memory may not be used!\n");\r\npagezero_memconfig();\r\n}\r\n}\r\nvoid __init do_device_inventory(void)\r\n{\r\nprintk(KERN_INFO "Searching for devices...\n");\r\ninit_parisc_bus();\r\nswitch (pdc_type) {\r\ncase PDC_TYPE_PAT:\r\npat_inventory();\r\nbreak;\r\ncase PDC_TYPE_SYSTEM_MAP:\r\nsystem_map_inventory();\r\nbreak;\r\ncase PDC_TYPE_SNAKE:\r\nsnake_inventory();\r\nbreak;\r\ndefault:\r\npanic("Unknown PDC type!\n");\r\n}\r\nprintk(KERN_INFO "Found devices:\n");\r\nprint_parisc_devices();\r\n}
