static int veth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->supported = 0;\r\ncmd->advertising = 0;\r\nethtool_cmd_speed_set(cmd, SPEED_10000);\r\ncmd->duplex = DUPLEX_FULL;\r\ncmd->port = PORT_TP;\r\ncmd->phy_address = 0;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->maxtxpkt = 0;\r\ncmd->maxrxpkt = 0;\r\nreturn 0;\r\n}\r\nstatic void veth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\n}\r\nstatic void veth_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\r\n{\r\nswitch(stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\r\nbreak;\r\n}\r\n}\r\nstatic int veth_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(ethtool_stats_keys);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void veth_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct veth_priv *priv;\r\npriv = netdev_priv(dev);\r\ndata[0] = priv->peer->ifindex;\r\n}\r\nstatic netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_device *rcv = NULL;\r\nstruct veth_priv *priv, *rcv_priv;\r\nstruct veth_net_stats *stats, *rcv_stats;\r\nint length;\r\npriv = netdev_priv(dev);\r\nrcv = priv->peer;\r\nrcv_priv = netdev_priv(rcv);\r\nstats = this_cpu_ptr(priv->stats);\r\nrcv_stats = this_cpu_ptr(rcv_priv->stats);\r\nif (skb->ip_summed == CHECKSUM_NONE &&\r\nrcv->features & NETIF_F_RXCSUM)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nlength = skb->len;\r\nif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\r\ngoto rx_drop;\r\nu64_stats_update_begin(&stats->syncp);\r\nstats->tx_bytes += length;\r\nstats->tx_packets++;\r\nu64_stats_update_end(&stats->syncp);\r\nu64_stats_update_begin(&rcv_stats->syncp);\r\nrcv_stats->rx_bytes += length;\r\nrcv_stats->rx_packets++;\r\nu64_stats_update_end(&rcv_stats->syncp);\r\nreturn NETDEV_TX_OK;\r\nrx_drop:\r\nu64_stats_update_begin(&rcv_stats->syncp);\r\nrcv_stats->rx_dropped++;\r\nu64_stats_update_end(&rcv_stats->syncp);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct rtnl_link_stats64 *veth_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *tot)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nstruct veth_net_stats *stats = per_cpu_ptr(priv->stats, cpu);\r\nu64 rx_packets, rx_bytes, rx_dropped;\r\nu64 tx_packets, tx_bytes;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&stats->syncp);\r\nrx_packets = stats->rx_packets;\r\ntx_packets = stats->tx_packets;\r\nrx_bytes = stats->rx_bytes;\r\ntx_bytes = stats->tx_bytes;\r\nrx_dropped = stats->rx_dropped;\r\n} while (u64_stats_fetch_retry_bh(&stats->syncp, start));\r\ntot->rx_packets += rx_packets;\r\ntot->tx_packets += tx_packets;\r\ntot->rx_bytes += rx_bytes;\r\ntot->tx_bytes += tx_bytes;\r\ntot->rx_dropped += rx_dropped;\r\n}\r\nreturn tot;\r\n}\r\nstatic int veth_open(struct net_device *dev)\r\n{\r\nstruct veth_priv *priv;\r\npriv = netdev_priv(dev);\r\nif (priv->peer == NULL)\r\nreturn -ENOTCONN;\r\nif (priv->peer->flags & IFF_UP) {\r\nnetif_carrier_on(dev);\r\nnetif_carrier_on(priv->peer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int veth_close(struct net_device *dev)\r\n{\r\nstruct veth_priv *priv = netdev_priv(dev);\r\nnetif_carrier_off(dev);\r\nnetif_carrier_off(priv->peer);\r\nreturn 0;\r\n}\r\nstatic int is_valid_veth_mtu(int new_mtu)\r\n{\r\nreturn new_mtu >= MIN_MTU && new_mtu <= MAX_MTU;\r\n}\r\nstatic int veth_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (!is_valid_veth_mtu(new_mtu))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int veth_dev_init(struct net_device *dev)\r\n{\r\nstruct veth_net_stats __percpu *stats;\r\nstruct veth_priv *priv;\r\nstats = alloc_percpu(struct veth_net_stats);\r\nif (stats == NULL)\r\nreturn -ENOMEM;\r\npriv = netdev_priv(dev);\r\npriv->stats = stats;\r\nreturn 0;\r\n}\r\nstatic void veth_dev_free(struct net_device *dev)\r\n{\r\nstruct veth_priv *priv;\r\npriv = netdev_priv(dev);\r\nfree_percpu(priv->stats);\r\nfree_netdev(dev);\r\n}\r\nstatic void veth_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->priv_flags &= ~IFF_TX_SKB_SHARING;\r\ndev->netdev_ops = &veth_netdev_ops;\r\ndev->ethtool_ops = &veth_ethtool_ops;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->destructor = veth_dev_free;\r\ndev->hw_features = NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\r\n}\r\nstatic int veth_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (tb[IFLA_MTU]) {\r\nif (!is_valid_veth_mtu(nla_get_u32(tb[IFLA_MTU])))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nint err;\r\nstruct net_device *peer;\r\nstruct veth_priv *priv;\r\nchar ifname[IFNAMSIZ];\r\nstruct nlattr *peer_tb[IFLA_MAX + 1], **tbp;\r\nstruct ifinfomsg *ifmp;\r\nstruct net *net;\r\nif (data != NULL && data[VETH_INFO_PEER] != NULL) {\r\nstruct nlattr *nla_peer;\r\nnla_peer = data[VETH_INFO_PEER];\r\nifmp = nla_data(nla_peer);\r\nerr = nla_parse(peer_tb, IFLA_MAX,\r\nnla_data(nla_peer) + sizeof(struct ifinfomsg),\r\nnla_len(nla_peer) - sizeof(struct ifinfomsg),\r\nifla_policy);\r\nif (err < 0)\r\nreturn err;\r\nerr = veth_validate(peer_tb, NULL);\r\nif (err < 0)\r\nreturn err;\r\ntbp = peer_tb;\r\n} else {\r\nifmp = NULL;\r\ntbp = tb;\r\n}\r\nif (tbp[IFLA_IFNAME])\r\nnla_strlcpy(ifname, tbp[IFLA_IFNAME], IFNAMSIZ);\r\nelse\r\nsnprintf(ifname, IFNAMSIZ, DRV_NAME "%%d");\r\nnet = rtnl_link_get_net(src_net, tbp);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\npeer = rtnl_create_link(src_net, net, ifname, &veth_link_ops, tbp);\r\nif (IS_ERR(peer)) {\r\nput_net(net);\r\nreturn PTR_ERR(peer);\r\n}\r\nif (tbp[IFLA_ADDRESS] == NULL)\r\neth_hw_addr_random(peer);\r\nerr = register_netdevice(peer);\r\nput_net(net);\r\nnet = NULL;\r\nif (err < 0)\r\ngoto err_register_peer;\r\nnetif_carrier_off(peer);\r\nerr = rtnl_configure_link(peer, ifmp);\r\nif (err < 0)\r\ngoto err_configure_peer;\r\nif (tb[IFLA_ADDRESS] == NULL)\r\neth_hw_addr_random(dev);\r\nif (tb[IFLA_IFNAME])\r\nnla_strlcpy(dev->name, tb[IFLA_IFNAME], IFNAMSIZ);\r\nelse\r\nsnprintf(dev->name, IFNAMSIZ, DRV_NAME "%%d");\r\nif (strchr(dev->name, '%')) {\r\nerr = dev_alloc_name(dev, dev->name);\r\nif (err < 0)\r\ngoto err_alloc_name;\r\n}\r\nerr = register_netdevice(dev);\r\nif (err < 0)\r\ngoto err_register_dev;\r\nnetif_carrier_off(dev);\r\npriv = netdev_priv(dev);\r\npriv->peer = peer;\r\npriv = netdev_priv(peer);\r\npriv->peer = dev;\r\nreturn 0;\r\nerr_register_dev:\r\nerr_alloc_name:\r\nerr_configure_peer:\r\nunregister_netdevice(peer);\r\nreturn err;\r\nerr_register_peer:\r\nfree_netdev(peer);\r\nreturn err;\r\n}\r\nstatic void veth_dellink(struct net_device *dev, struct list_head *head)\r\n{\r\nstruct veth_priv *priv;\r\nstruct net_device *peer;\r\npriv = netdev_priv(dev);\r\npeer = priv->peer;\r\nunregister_netdevice_queue(dev, head);\r\nunregister_netdevice_queue(peer, head);\r\n}\r\nstatic __init int veth_init(void)\r\n{\r\nreturn rtnl_link_register(&veth_link_ops);\r\n}\r\nstatic __exit void veth_exit(void)\r\n{\r\nrtnl_link_unregister(&veth_link_ops);\r\n}
