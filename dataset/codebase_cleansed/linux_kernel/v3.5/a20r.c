static u32 a20r_ack_hwint(void)\r\n{\r\nu32 status = read_c0_status();\r\nwrite_c0_status(status | 0x00010000);\r\nasm volatile(\r\n" .set push \n"\r\n" .set noat \n"\r\n" .set noreorder \n"\r\n" lw $1, 0(%0) \n"\r\n" sb $0, 0(%1) \n"\r\n" sync \n"\r\n" lb %1, 0(%1) \n"\r\n" b 1f \n"\r\n" ori %1, $1, 2 \n"\r\n" .align 8 \n"\r\n"1: \n"\r\n" nop \n"\r\n" sw %1, 0(%0) \n"\r\n" sync \n"\r\n" li %1, 0x20 \n"\r\n"2: \n"\r\n" nop \n"\r\n" bnez %1,2b \n"\r\n" addiu %1, -1 \n"\r\n" sw $1, 0(%0) \n"\r\n" sync \n"\r\n".set pop \n"\r\n:\r\n: "Jr" (PCIMT_UCONF), "Jr" (0xbc000000));\r\nwrite_c0_status(status);\r\nreturn status;\r\n}\r\nstatic inline void unmask_a20r_irq(struct irq_data *d)\r\n{\r\nset_c0_status(0x100 << (d->irq - SNI_A20R_IRQ_BASE));\r\nirq_enable_hazard();\r\n}\r\nstatic inline void mask_a20r_irq(struct irq_data *d)\r\n{\r\nclear_c0_status(0x100 << (d->irq - SNI_A20R_IRQ_BASE));\r\nirq_disable_hazard();\r\n}\r\nstatic void a20r_hwint(void)\r\n{\r\nu32 cause, status;\r\nint irq;\r\nclear_c0_status(IE_IRQ0);\r\nstatus = a20r_ack_hwint();\r\ncause = read_c0_cause();\r\nirq = ffs(((cause & status) >> 8) & 0xf8);\r\nif (likely(irq > 0))\r\ndo_IRQ(SNI_A20R_IRQ_BASE + irq - 1);\r\nset_c0_status(IE_IRQ0);\r\n}\r\nvoid __init sni_a20r_irq_init(void)\r\n{\r\nint i;\r\nfor (i = SNI_A20R_IRQ_BASE + 2 ; i < SNI_A20R_IRQ_BASE + 8; i++)\r\nirq_set_chip_and_handler(i, &a20r_irq_type, handle_level_irq);\r\nsni_hwint = a20r_hwint;\r\nchange_c0_status(ST0_IM, IE_IRQ0);\r\nsetup_irq(SNI_A20R_IRQ_BASE + 3, &sni_isa_irq);\r\n}\r\nvoid sni_a20r_init(void)\r\n{\r\n}\r\nstatic int __init snirm_a20r_setup_devinit(void)\r\n{\r\nswitch (sni_brd_type) {\r\ncase SNI_BRD_TOWER_OASIC:\r\ncase SNI_BRD_MINITOWER:\r\nplatform_device_register(&snirm_82596_pdev);\r\nplatform_device_register(&snirm_53c710_pdev);\r\nplatform_device_register(&sc26xx_pdev);\r\nplatform_device_register(&a20r_serial8250_device);\r\nplatform_device_register(&a20r_ds1216_device);\r\nsni_eisa_root_init();\r\nbreak;\r\n}\r\nreturn 0;\r\n}
