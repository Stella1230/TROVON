int usb_gadget_map_request(struct usb_gadget *gadget,\r\nstruct usb_request *req, int is_in)\r\n{\r\nif (req->length == 0)\r\nreturn 0;\r\nif (req->num_sgs) {\r\nint mapped;\r\nmapped = dma_map_sg(&gadget->dev, req->sg, req->num_sgs,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (mapped == 0) {\r\ndev_err(&gadget->dev, "failed to map SGs\n");\r\nreturn -EFAULT;\r\n}\r\nreq->num_mapped_sgs = mapped;\r\n} else {\r\nreq->dma = dma_map_single(&gadget->dev, req->buf, req->length,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&gadget->dev, req->dma)) {\r\ndev_err(&gadget->dev, "failed to map buffer\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid usb_gadget_unmap_request(struct usb_gadget *gadget,\r\nstruct usb_request *req, int is_in)\r\n{\r\nif (req->length == 0)\r\nreturn;\r\nif (req->num_mapped_sgs) {\r\ndma_unmap_sg(&gadget->dev, req->sg, req->num_mapped_sgs,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nreq->num_mapped_sgs = 0;\r\n} else {\r\ndma_unmap_single(&gadget->dev, req->dma, req->length,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\n}\r\n}\r\nstatic inline int usb_gadget_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver,\r\nint (*bind)(struct usb_gadget *))\r\n{\r\nreturn gadget->ops->start(driver, bind);\r\n}\r\nstatic inline int usb_gadget_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nreturn gadget->ops->udc_start(gadget, driver);\r\n}\r\nstatic inline void usb_gadget_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\ngadget->ops->stop(driver);\r\n}\r\nstatic inline void usb_gadget_udc_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\ngadget->ops->udc_stop(gadget, driver);\r\n}\r\nstatic void usb_udc_release(struct device *dev)\r\n{\r\nstruct usb_udc *udc;\r\nudc = container_of(dev, struct usb_udc, dev);\r\ndev_dbg(dev, "releasing '%s'\n", dev_name(dev));\r\nkfree(udc);\r\n}\r\nint usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)\r\n{\r\nstruct usb_udc *udc;\r\nint ret = -ENOMEM;\r\nudc = kzalloc(sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\ngoto err1;\r\ndevice_initialize(&udc->dev);\r\nudc->dev.release = usb_udc_release;\r\nudc->dev.class = udc_class;\r\nudc->dev.groups = usb_udc_attr_groups;\r\nudc->dev.parent = parent;\r\nret = dev_set_name(&udc->dev, "%s", kobject_name(&parent->kobj));\r\nif (ret)\r\ngoto err2;\r\nudc->gadget = gadget;\r\nmutex_lock(&udc_lock);\r\nlist_add_tail(&udc->list, &udc_list);\r\nret = device_add(&udc->dev);\r\nif (ret)\r\ngoto err3;\r\nmutex_unlock(&udc_lock);\r\nreturn 0;\r\nerr3:\r\nlist_del(&udc->list);\r\nmutex_unlock(&udc_lock);\r\nerr2:\r\nput_device(&udc->dev);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic int udc_is_newstyle(struct usb_udc *udc)\r\n{\r\nif (udc->gadget->ops->udc_start && udc->gadget->ops->udc_stop)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void usb_gadget_remove_driver(struct usb_udc *udc)\r\n{\r\ndev_dbg(&udc->dev, "unregistering UDC driver [%s]\n",\r\nudc->gadget->name);\r\nkobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\r\nif (udc_is_newstyle(udc)) {\r\nudc->driver->disconnect(udc->gadget);\r\nusb_gadget_disconnect(udc->gadget);\r\nudc->driver->unbind(udc->gadget);\r\nusb_gadget_udc_stop(udc->gadget, udc->driver);\r\n} else {\r\nusb_gadget_stop(udc->gadget, udc->driver);\r\n}\r\nudc->driver = NULL;\r\nudc->dev.driver = NULL;\r\n}\r\nvoid usb_del_gadget_udc(struct usb_gadget *gadget)\r\n{\r\nstruct usb_udc *udc = NULL;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list)\r\nif (udc->gadget == gadget)\r\ngoto found;\r\ndev_err(gadget->dev.parent, "gadget not registered.\n");\r\nmutex_unlock(&udc_lock);\r\nreturn;\r\nfound:\r\ndev_vdbg(gadget->dev.parent, "unregistering gadget\n");\r\nlist_del(&udc->list);\r\nmutex_unlock(&udc_lock);\r\nif (udc->driver)\r\nusb_gadget_remove_driver(udc);\r\nkobject_uevent(&udc->dev.kobj, KOBJ_REMOVE);\r\ndevice_unregister(&udc->dev);\r\n}\r\nint usb_gadget_probe_driver(struct usb_gadget_driver *driver,\r\nint (*bind)(struct usb_gadget *))\r\n{\r\nstruct usb_udc *udc = NULL;\r\nint ret;\r\nif (!driver || !bind || !driver->setup)\r\nreturn -EINVAL;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list) {\r\nif (!udc->driver)\r\ngoto found;\r\n}\r\npr_debug("couldn't find an available UDC\n");\r\nmutex_unlock(&udc_lock);\r\nreturn -ENODEV;\r\nfound:\r\ndev_dbg(&udc->dev, "registering UDC driver [%s]\n",\r\ndriver->function);\r\nudc->driver = driver;\r\nudc->dev.driver = &driver->driver;\r\nif (udc_is_newstyle(udc)) {\r\nret = bind(udc->gadget);\r\nif (ret)\r\ngoto err1;\r\nret = usb_gadget_udc_start(udc->gadget, driver);\r\nif (ret) {\r\ndriver->unbind(udc->gadget);\r\ngoto err1;\r\n}\r\nusb_gadget_connect(udc->gadget);\r\n} else {\r\nret = usb_gadget_start(udc->gadget, driver, bind);\r\nif (ret)\r\ngoto err1;\r\n}\r\nkobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\r\nmutex_unlock(&udc_lock);\r\nreturn 0;\r\nerr1:\r\ndev_err(&udc->dev, "failed to start %s: %d\n",\r\nudc->driver->function, ret);\r\nudc->driver = NULL;\r\nudc->dev.driver = NULL;\r\nmutex_unlock(&udc_lock);\r\nreturn ret;\r\n}\r\nint usb_gadget_unregister_driver(struct usb_gadget_driver *driver)\r\n{\r\nstruct usb_udc *udc = NULL;\r\nint ret = -ENODEV;\r\nif (!driver || !driver->unbind)\r\nreturn -EINVAL;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list)\r\nif (udc->driver == driver) {\r\nusb_gadget_remove_driver(udc);\r\nret = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&udc_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t usb_udc_srp_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t n)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nif (sysfs_streq(buf, "1"))\r\nusb_gadget_wakeup(udc->gadget);\r\nreturn n;\r\n}\r\nstatic ssize_t usb_udc_softconn_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t n)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nif (sysfs_streq(buf, "connect")) {\r\nif (udc_is_newstyle(udc))\r\nusb_gadget_udc_start(udc->gadget, udc->driver);\r\nusb_gadget_connect(udc->gadget);\r\n} else if (sysfs_streq(buf, "disconnect")) {\r\nusb_gadget_disconnect(udc->gadget);\r\nif (udc_is_newstyle(udc))\r\nusb_gadget_udc_stop(udc->gadget, udc->driver);\r\n} else {\r\ndev_err(dev, "unsupported command '%s'\n", buf);\r\nreturn -EINVAL;\r\n}\r\nreturn n;\r\n}\r\nstatic ssize_t usb_udc_is_dualspeed_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ngadget_is_dualspeed(udc->gadget));\r\n}\r\nstatic int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nint ret;\r\nret = add_uevent_var(env, "USB_UDC_NAME=%s", udc->gadget->name);\r\nif (ret) {\r\ndev_err(dev, "failed to add uevent USB_UDC_NAME\n");\r\nreturn ret;\r\n}\r\nif (udc->driver) {\r\nret = add_uevent_var(env, "USB_UDC_DRIVER=%s",\r\nudc->driver->function);\r\nif (ret) {\r\ndev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init usb_udc_init(void)\r\n{\r\nudc_class = class_create(THIS_MODULE, "udc");\r\nif (IS_ERR(udc_class)) {\r\npr_err("failed to create udc class --> %ld\n",\r\nPTR_ERR(udc_class));\r\nreturn PTR_ERR(udc_class);\r\n}\r\nudc_class->dev_uevent = usb_udc_uevent;\r\nreturn 0;\r\n}\r\nstatic void __exit usb_udc_exit(void)\r\n{\r\nclass_destroy(udc_class);\r\n}
