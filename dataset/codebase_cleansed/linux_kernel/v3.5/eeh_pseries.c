static int pseries_eeh_init(void)\r\n{\r\nibm_set_eeh_option = rtas_token("ibm,set-eeh-option");\r\nibm_set_slot_reset = rtas_token("ibm,set-slot-reset");\r\nibm_read_slot_reset_state2 = rtas_token("ibm,read-slot-reset-state2");\r\nibm_read_slot_reset_state = rtas_token("ibm,read-slot-reset-state");\r\nibm_slot_error_detail = rtas_token("ibm,slot-error-detail");\r\nibm_get_config_addr_info2 = rtas_token("ibm,get-config-addr-info2");\r\nibm_get_config_addr_info = rtas_token("ibm,get-config-addr-info");\r\nibm_configure_pe = rtas_token("ibm,configure-pe");\r\nibm_configure_bridge = rtas_token ("ibm,configure-bridge");\r\nif (ibm_set_eeh_option == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,set-eeh-option> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_set_slot_reset == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm, set-slot-reset> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_read_slot_reset_state2 == RTAS_UNKNOWN_SERVICE &&\r\nibm_read_slot_reset_state == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,read-slot-reset-state2> and "\r\n"<ibm,read-slot-reset-state> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_slot_error_detail == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,slot-error-detail> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_get_config_addr_info2 == RTAS_UNKNOWN_SERVICE &&\r\nibm_get_config_addr_info == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,get-config-addr-info2> and "\r\n"<ibm,get-config-addr-info> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_configure_pe == RTAS_UNKNOWN_SERVICE &&\r\nibm_configure_bridge == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,configure-pe> and "\r\n"<ibm,configure-bridge> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_init(&slot_errbuf_lock);\r\neeh_error_buf_size = rtas_token("rtas-error-log-max");\r\nif (eeh_error_buf_size == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: unknown EEH error log size\n",\r\n__func__);\r\neeh_error_buf_size = 1024;\r\n} else if (eeh_error_buf_size > RTAS_ERROR_LOG_MAX) {\r\npr_warning("%s: EEH error log size %d exceeds the maximal %d\n",\r\n__func__, eeh_error_buf_size, RTAS_ERROR_LOG_MAX);\r\neeh_error_buf_size = RTAS_ERROR_LOG_MAX;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pseries_eeh_set_option(struct device_node *dn, int option)\r\n{\r\nint ret = 0;\r\nstruct eeh_dev *edev;\r\nconst u32 *reg;\r\nint config_addr;\r\nedev = of_node_to_eeh_dev(dn);\r\nswitch (option) {\r\ncase EEH_OPT_DISABLE:\r\ncase EEH_OPT_ENABLE:\r\nreg = of_get_property(dn, "reg", NULL);\r\nconfig_addr = reg[0];\r\nbreak;\r\ncase EEH_OPT_THAW_MMIO:\r\ncase EEH_OPT_THAW_DMA:\r\nconfig_addr = edev->config_addr;\r\nif (edev->pe_config_addr)\r\nconfig_addr = edev->pe_config_addr;\r\nbreak;\r\ndefault:\r\npr_err("%s: Invalid option %d\n",\r\n__func__, option);\r\nreturn -EINVAL;\r\n}\r\nret = rtas_call(ibm_set_eeh_option, 4, 1, NULL,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid), option);\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_get_pe_addr(struct device_node *dn)\r\n{\r\nstruct eeh_dev *edev;\r\nint ret = 0;\r\nint rets[3];\r\nedev = of_node_to_eeh_dev(dn);\r\nif (ibm_get_config_addr_info2 != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_get_config_addr_info2, 4, 2, rets,\r\nedev->config_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid), 1);\r\nif (ret || (rets[0] == 0))\r\nreturn 0;\r\nret = rtas_call(ibm_get_config_addr_info2, 4, 2, rets,\r\nedev->config_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid), 0);\r\nif (ret) {\r\npr_warning("%s: Failed to get PE address for %s\n",\r\n__func__, dn->full_name);\r\nreturn 0;\r\n}\r\nreturn rets[0];\r\n}\r\nif (ibm_get_config_addr_info != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_get_config_addr_info, 4, 2, rets,\r\nedev->config_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid), 0);\r\nif (ret) {\r\npr_warning("%s: Failed to get PE address for %s\n",\r\n__func__, dn->full_name);\r\nreturn 0;\r\n}\r\nreturn rets[0];\r\n}\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_get_state(struct device_node *dn, int *state)\r\n{\r\nstruct eeh_dev *edev;\r\nint config_addr;\r\nint ret;\r\nint rets[4];\r\nint result;\r\nedev = of_node_to_eeh_dev(dn);\r\nconfig_addr = edev->config_addr;\r\nif (edev->pe_config_addr)\r\nconfig_addr = edev->pe_config_addr;\r\nif (ibm_read_slot_reset_state2 != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_read_slot_reset_state2, 3, 4, rets,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid));\r\n} else if (ibm_read_slot_reset_state != RTAS_UNKNOWN_SERVICE) {\r\nrets[2] = 0;\r\nret = rtas_call(ibm_read_slot_reset_state, 3, 3, rets,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid));\r\n} else {\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (ret)\r\nreturn ret;\r\nresult = 0;\r\nif (rets[1]) {\r\nswitch(rets[0]) {\r\ncase 0:\r\nresult &= ~EEH_STATE_RESET_ACTIVE;\r\nresult |= EEH_STATE_MMIO_ACTIVE;\r\nresult |= EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase 1:\r\nresult |= EEH_STATE_RESET_ACTIVE;\r\nresult |= EEH_STATE_MMIO_ACTIVE;\r\nresult |= EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase 2:\r\nresult &= ~EEH_STATE_RESET_ACTIVE;\r\nresult &= ~EEH_STATE_MMIO_ACTIVE;\r\nresult &= ~EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase 4:\r\nresult &= ~EEH_STATE_RESET_ACTIVE;\r\nresult &= ~EEH_STATE_MMIO_ACTIVE;\r\nresult &= ~EEH_STATE_DMA_ACTIVE;\r\nresult |= EEH_STATE_MMIO_ENABLED;\r\nbreak;\r\ncase 5:\r\nif (rets[2]) {\r\nif (state) *state = rets[2];\r\nresult = EEH_STATE_UNAVAILABLE;\r\n} else {\r\nresult = EEH_STATE_NOT_SUPPORT;\r\n}\r\ndefault:\r\nresult = EEH_STATE_NOT_SUPPORT;\r\n}\r\n} else {\r\nresult = EEH_STATE_NOT_SUPPORT;\r\n}\r\nreturn result;\r\n}\r\nstatic int pseries_eeh_reset(struct device_node *dn, int option)\r\n{\r\nstruct eeh_dev *edev;\r\nint config_addr;\r\nint ret;\r\nedev = of_node_to_eeh_dev(dn);\r\nconfig_addr = edev->config_addr;\r\nif (edev->pe_config_addr)\r\nconfig_addr = edev->pe_config_addr;\r\nret = rtas_call(ibm_set_slot_reset, 4, 1, NULL,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid), option);\r\nif (option == EEH_RESET_FUNDAMENTAL &&\r\nret == -8) {\r\nret = rtas_call(ibm_set_slot_reset, 4, 1, NULL,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid), EEH_RESET_HOT);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_wait_state(struct device_node *dn, int max_wait)\r\n{\r\nint ret;\r\nint mwait;\r\n#define EEH_STATE_MIN_WAIT_TIME (1000)\r\n#define EEH_STATE_MAX_WAIT_TIME (300 * 1000)\r\nwhile (1) {\r\nret = pseries_eeh_get_state(dn, &mwait);\r\nif (ret != EEH_STATE_UNAVAILABLE)\r\nreturn ret;\r\nif (max_wait <= 0) {\r\npr_warning("%s: Timeout when getting PE's state (%d)\n",\r\n__func__, max_wait);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (mwait <= 0) {\r\npr_warning("%s: Firmware returned bad wait value %d\n",\r\n__func__, mwait);\r\nmwait = EEH_STATE_MIN_WAIT_TIME;\r\n} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\r\npr_warning("%s: Firmware returned too long wait value %d\n",\r\n__func__, mwait);\r\nmwait = EEH_STATE_MAX_WAIT_TIME;\r\n}\r\nmax_wait -= mwait;\r\nmsleep(mwait);\r\n}\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nstatic int pseries_eeh_get_log(struct device_node *dn, int severity, char *drv_log, unsigned long len)\r\n{\r\nstruct eeh_dev *edev;\r\nint config_addr;\r\nunsigned long flags;\r\nint ret;\r\nedev = of_node_to_eeh_dev(dn);\r\nspin_lock_irqsave(&slot_errbuf_lock, flags);\r\nmemset(slot_errbuf, 0, eeh_error_buf_size);\r\nconfig_addr = edev->config_addr;\r\nif (edev->pe_config_addr)\r\nconfig_addr = edev->pe_config_addr;\r\nret = rtas_call(ibm_slot_error_detail, 8, 1, NULL, config_addr,\r\nBUID_HI(edev->phb->buid), BUID_LO(edev->phb->buid),\r\nvirt_to_phys(drv_log), len,\r\nvirt_to_phys(slot_errbuf), eeh_error_buf_size,\r\nseverity);\r\nif (!ret)\r\nlog_error(slot_errbuf, ERR_TYPE_RTAS_LOG, 0);\r\nspin_unlock_irqrestore(&slot_errbuf_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_configure_bridge(struct device_node *dn)\r\n{\r\nstruct eeh_dev *edev;\r\nint config_addr;\r\nint ret;\r\nedev = of_node_to_eeh_dev(dn);\r\nconfig_addr = edev->config_addr;\r\nif (edev->pe_config_addr)\r\nconfig_addr = edev->pe_config_addr;\r\nif (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_configure_pe, 3, 1, NULL,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid));\r\n} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_configure_bridge, 3, 1, NULL,\r\nconfig_addr, BUID_HI(edev->phb->buid),\r\nBUID_LO(edev->phb->buid));\r\n} else {\r\nreturn -EFAULT;\r\n}\r\nif (ret)\r\npr_warning("%s: Unable to configure bridge %d for %s\n",\r\n__func__, ret, dn->full_name);\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_read_config(struct device_node *dn, int where, int size, u32 *val)\r\n{\r\nstruct pci_dn *pdn;\r\npdn = PCI_DN(dn);\r\nreturn rtas_read_config(pdn, where, size, val);\r\n}\r\nstatic int pseries_eeh_write_config(struct device_node *dn, int where, int size, u32 val)\r\n{\r\nstruct pci_dn *pdn;\r\npdn = PCI_DN(dn);\r\nreturn rtas_write_config(pdn, where, size, val);\r\n}\r\nint __init eeh_pseries_init(void)\r\n{\r\nreturn eeh_ops_register(&pseries_eeh_ops);\r\n}
