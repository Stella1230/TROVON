static void gpio_ext_set_addr(struct netxbig_gpio_ext *gpio_ext, int addr)\r\n{\r\nint pin;\r\nfor (pin = 0; pin < gpio_ext->num_addr; pin++)\r\ngpio_set_value(gpio_ext->addr[pin], (addr >> pin) & 1);\r\n}\r\nstatic void gpio_ext_set_data(struct netxbig_gpio_ext *gpio_ext, int data)\r\n{\r\nint pin;\r\nfor (pin = 0; pin < gpio_ext->num_data; pin++)\r\ngpio_set_value(gpio_ext->data[pin], (data >> pin) & 1);\r\n}\r\nstatic void gpio_ext_enable_select(struct netxbig_gpio_ext *gpio_ext)\r\n{\r\ngpio_set_value(gpio_ext->enable, 0);\r\ngpio_set_value(gpio_ext->enable, 1);\r\n}\r\nstatic void gpio_ext_set_value(struct netxbig_gpio_ext *gpio_ext,\r\nint addr, int value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&gpio_ext_lock, flags);\r\ngpio_ext_set_addr(gpio_ext, addr);\r\ngpio_ext_set_data(gpio_ext, value);\r\ngpio_ext_enable_select(gpio_ext);\r\nspin_unlock_irqrestore(&gpio_ext_lock, flags);\r\n}\r\nstatic int __devinit gpio_ext_init(struct netxbig_gpio_ext *gpio_ext)\r\n{\r\nint err;\r\nint i;\r\nif (unlikely(!gpio_ext))\r\nreturn -EINVAL;\r\nfor (i = 0; i < gpio_ext->num_addr; i++) {\r\nerr = gpio_request_one(gpio_ext->addr[i], GPIOF_OUT_INIT_LOW,\r\n"GPIO extension addr");\r\nif (err)\r\ngoto err_free_addr;\r\n}\r\nfor (i = 0; i < gpio_ext->num_data; i++) {\r\nerr = gpio_request_one(gpio_ext->data[i], GPIOF_OUT_INIT_LOW,\r\n"GPIO extension data");\r\nif (err)\r\ngoto err_free_data;\r\n}\r\nerr = gpio_request_one(gpio_ext->enable, GPIOF_OUT_INIT_LOW,\r\n"GPIO extension enable");\r\nif (err)\r\ngoto err_free_data;\r\nreturn 0;\r\nerr_free_data:\r\nfor (i = i - 1; i >= 0; i--)\r\ngpio_free(gpio_ext->data[i]);\r\ni = gpio_ext->num_addr;\r\nerr_free_addr:\r\nfor (i = i - 1; i >= 0; i--)\r\ngpio_free(gpio_ext->addr[i]);\r\nreturn err;\r\n}\r\nstatic void gpio_ext_free(struct netxbig_gpio_ext *gpio_ext)\r\n{\r\nint i;\r\ngpio_free(gpio_ext->enable);\r\nfor (i = gpio_ext->num_addr - 1; i >= 0; i--)\r\ngpio_free(gpio_ext->addr[i]);\r\nfor (i = gpio_ext->num_data - 1; i >= 0; i--)\r\ngpio_free(gpio_ext->data[i]);\r\n}\r\nstatic int netxbig_led_get_timer_mode(enum netxbig_led_mode *mode,\r\nunsigned long delay_on,\r\nunsigned long delay_off,\r\nstruct netxbig_led_timer *timer,\r\nint num_timer)\r\n{\r\nint i;\r\nfor (i = 0; i < num_timer; i++) {\r\nif (timer[i].delay_on == delay_on &&\r\ntimer[i].delay_off == delay_off) {\r\n*mode = timer[i].mode;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int netxbig_led_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nenum netxbig_led_mode mode;\r\nint mode_val;\r\nint ret;\r\nret = netxbig_led_get_timer_mode(&mode, *delay_on, *delay_off,\r\nled_dat->timer, led_dat->num_timer);\r\nif (ret < 0)\r\nreturn ret;\r\nmode_val = led_dat->mode_val[mode];\r\nif (mode_val == NETXBIG_LED_INVALID_MODE)\r\nreturn -EINVAL;\r\nspin_lock_irq(&led_dat->lock);\r\ngpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\r\nled_dat->mode = mode;\r\nspin_unlock_irq(&led_dat->lock);\r\nreturn 0;\r\n}\r\nstatic void netxbig_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nenum netxbig_led_mode mode;\r\nint mode_val, bright_val;\r\nint set_brightness = 1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_dat->lock, flags);\r\nif (value == LED_OFF) {\r\nmode = NETXBIG_LED_OFF;\r\nset_brightness = 0;\r\n} else {\r\nif (led_dat->sata)\r\nmode = NETXBIG_LED_SATA;\r\nelse if (led_dat->mode == NETXBIG_LED_OFF)\r\nmode = NETXBIG_LED_ON;\r\nelse\r\nmode = led_dat->mode;\r\n}\r\nmode_val = led_dat->mode_val[mode];\r\ngpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\r\nled_dat->mode = mode;\r\nif (set_brightness) {\r\nbright_val = DIV_ROUND_UP(value * led_dat->bright_max,\r\nLED_FULL);\r\ngpio_ext_set_value(led_dat->gpio_ext,\r\nled_dat->bright_addr, bright_val);\r\n}\r\nspin_unlock_irqrestore(&led_dat->lock, flags);\r\n}\r\nstatic ssize_t netxbig_led_sata_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buff, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nunsigned long enable;\r\nenum netxbig_led_mode mode;\r\nint mode_val;\r\nint ret;\r\nret = strict_strtoul(buff, 10, &enable);\r\nif (ret < 0)\r\nreturn ret;\r\nenable = !!enable;\r\nspin_lock_irq(&led_dat->lock);\r\nif (led_dat->sata == enable) {\r\nret = count;\r\ngoto exit_unlock;\r\n}\r\nif (led_dat->mode != NETXBIG_LED_ON &&\r\nled_dat->mode != NETXBIG_LED_SATA)\r\nmode = led_dat->mode;\r\nelse if (enable)\r\nmode = NETXBIG_LED_SATA;\r\nelse\r\nmode = NETXBIG_LED_ON;\r\nmode_val = led_dat->mode_val[mode];\r\nif (mode_val == NETXBIG_LED_INVALID_MODE) {\r\nret = -EINVAL;\r\ngoto exit_unlock;\r\n}\r\ngpio_ext_set_value(led_dat->gpio_ext, led_dat->mode_addr, mode_val);\r\nled_dat->mode = mode;\r\nled_dat->sata = enable;\r\nret = count;\r\nexit_unlock:\r\nspin_unlock_irq(&led_dat->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t netxbig_led_sata_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct netxbig_led_data *led_dat =\r\ncontainer_of(led_cdev, struct netxbig_led_data, cdev);\r\nreturn sprintf(buf, "%d\n", led_dat->sata);\r\n}\r\nstatic void delete_netxbig_led(struct netxbig_led_data *led_dat)\r\n{\r\nif (led_dat->mode_val[NETXBIG_LED_SATA] != NETXBIG_LED_INVALID_MODE)\r\ndevice_remove_file(led_dat->cdev.dev, &dev_attr_sata);\r\nled_classdev_unregister(&led_dat->cdev);\r\n}\r\nstatic int __devinit\r\ncreate_netxbig_led(struct platform_device *pdev,\r\nstruct netxbig_led_data *led_dat,\r\nconst struct netxbig_led *template)\r\n{\r\nstruct netxbig_led_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nspin_lock_init(&led_dat->lock);\r\nled_dat->gpio_ext = pdata->gpio_ext;\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->cdev.blink_set = netxbig_led_blink_set;\r\nled_dat->cdev.brightness_set = netxbig_led_set;\r\nled_dat->sata = 0;\r\nled_dat->cdev.brightness = LED_OFF;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->mode_addr = template->mode_addr;\r\nled_dat->mode_val = template->mode_val;\r\nled_dat->bright_addr = template->bright_addr;\r\nled_dat->bright_max = (1 << pdata->gpio_ext->num_data) - 1;\r\nled_dat->timer = pdata->timer;\r\nled_dat->num_timer = pdata->num_timer;\r\nret = led_classdev_register(&pdev->dev, &led_dat->cdev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (led_dat->mode_val[NETXBIG_LED_SATA] != NETXBIG_LED_INVALID_MODE) {\r\nret = device_create_file(led_dat->cdev.dev, &dev_attr_sata);\r\nif (ret)\r\nled_classdev_unregister(&led_dat->cdev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __devinit netxbig_led_probe(struct platform_device *pdev)\r\n{\r\nstruct netxbig_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct netxbig_led_data *leds_data;\r\nint i;\r\nint ret;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nleds_data = kzalloc(sizeof(struct netxbig_led_data) * pdata->num_leds,\r\nGFP_KERNEL);\r\nif (!leds_data)\r\nreturn -ENOMEM;\r\nret = gpio_ext_init(pdata->gpio_ext);\r\nif (ret < 0)\r\ngoto err_free_data;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nret = create_netxbig_led(pdev, &leds_data[i], &pdata->leds[i]);\r\nif (ret < 0)\r\ngoto err_free_leds;\r\n}\r\nplatform_set_drvdata(pdev, leds_data);\r\nreturn 0;\r\nerr_free_leds:\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_netxbig_led(&leds_data[i]);\r\ngpio_ext_free(pdata->gpio_ext);\r\nerr_free_data:\r\nkfree(leds_data);\r\nreturn ret;\r\n}\r\nstatic int __devexit netxbig_led_remove(struct platform_device *pdev)\r\n{\r\nstruct netxbig_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct netxbig_led_data *leds_data;\r\nint i;\r\nleds_data = platform_get_drvdata(pdev);\r\nfor (i = 0; i < pdata->num_leds; i++)\r\ndelete_netxbig_led(&leds_data[i]);\r\ngpio_ext_free(pdata->gpio_ext);\r\nkfree(leds_data);\r\nreturn 0;\r\n}
