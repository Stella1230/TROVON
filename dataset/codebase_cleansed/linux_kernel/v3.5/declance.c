static inline void writereg(volatile unsigned short *regptr, short value)\r\n{\r\n*regptr = value;\r\niob();\r\n}\r\nstatic void load_csrs(struct lance_private *lp)\r\n{\r\nvolatile struct lance_regs *ll = lp->ll;\r\nuint leptr;\r\nleptr = 0;\r\nwritereg(&ll->rap, LE_CSR1);\r\nwritereg(&ll->rdp, (leptr & 0xFFFF));\r\nwritereg(&ll->rap, LE_CSR2);\r\nwritereg(&ll->rdp, leptr >> 16);\r\nwritereg(&ll->rap, LE_CSR3);\r\nwritereg(&ll->rdp, lp->busmaster_regval);\r\nwritereg(&ll->rap, LE_CSR0);\r\n}\r\nstatic void cp_to_buf(const int type, void *to, const void *from, int len)\r\n{\r\nunsigned short *tp;\r\nconst unsigned short *fp;\r\nunsigned short clen;\r\nunsigned char *rtp;\r\nconst unsigned char *rfp;\r\nif (type == PMAD_LANCE) {\r\nmemcpy(to, from, len);\r\n} else if (type == PMAX_LANCE) {\r\nclen = len >> 1;\r\ntp = to;\r\nfp = from;\r\nwhile (clen--) {\r\n*tp++ = *fp++;\r\ntp++;\r\n}\r\nclen = len & 1;\r\nrtp = tp;\r\nrfp = fp;\r\nwhile (clen--) {\r\n*rtp++ = *rfp++;\r\n}\r\n} else {\r\nclen = len >> 4;\r\ntp = to;\r\nfp = from;\r\nwhile (clen--) {\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\ntp += 8;\r\n}\r\nclen = len & 15;\r\nrtp = (unsigned char *) tp;\r\nrfp = (unsigned char *) fp;\r\nwhile (clen--) {\r\n*rtp++ = *rfp++;\r\n}\r\n}\r\niob();\r\n}\r\nstatic void cp_from_buf(const int type, void *to, const void *from, int len)\r\n{\r\nunsigned short *tp;\r\nconst unsigned short *fp;\r\nunsigned short clen;\r\nunsigned char *rtp;\r\nconst unsigned char *rfp;\r\nif (type == PMAD_LANCE) {\r\nmemcpy(to, from, len);\r\n} else if (type == PMAX_LANCE) {\r\nclen = len >> 1;\r\ntp = to;\r\nfp = from;\r\nwhile (clen--) {\r\n*tp++ = *fp++;\r\nfp++;\r\n}\r\nclen = len & 1;\r\nrtp = tp;\r\nrfp = fp;\r\nwhile (clen--) {\r\n*rtp++ = *rfp++;\r\n}\r\n} else {\r\nclen = len >> 4;\r\ntp = to;\r\nfp = from;\r\nwhile (clen--) {\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\n*tp++ = *fp++;\r\nfp += 8;\r\n}\r\nclen = len & 15;\r\nrtp = (unsigned char *) tp;\r\nrfp = (unsigned char *) fp;\r\nwhile (clen--) {\r\n*rtp++ = *rfp++;\r\n}\r\n}\r\n}\r\nstatic void lance_init_ring(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nuint leptr;\r\nint i;\r\nnetif_stop_queue(dev);\r\nlp->rx_new = lp->tx_new = 0;\r\nlp->rx_old = lp->tx_old = 0;\r\n*lib_ptr(ib, phys_addr[0], lp->type) = (dev->dev_addr[1] << 8) |\r\ndev->dev_addr[0];\r\n*lib_ptr(ib, phys_addr[1], lp->type) = (dev->dev_addr[3] << 8) |\r\ndev->dev_addr[2];\r\n*lib_ptr(ib, phys_addr[2], lp->type) = (dev->dev_addr[5] << 8) |\r\ndev->dev_addr[4];\r\nleptr = offsetof(struct lance_init_block, brx_ring);\r\n*lib_ptr(ib, rx_len, lp->type) = (LANCE_LOG_RX_BUFFERS << 13) |\r\n(leptr >> 16);\r\n*lib_ptr(ib, rx_ptr, lp->type) = leptr;\r\nif (ZERO)\r\nprintk("RX ptr: %8.8x(%8.8x)\n",\r\nleptr, lib_off(brx_ring, lp->type));\r\nleptr = offsetof(struct lance_init_block, btx_ring);\r\n*lib_ptr(ib, tx_len, lp->type) = (LANCE_LOG_TX_BUFFERS << 13) |\r\n(leptr >> 16);\r\n*lib_ptr(ib, tx_ptr, lp->type) = leptr;\r\nif (ZERO)\r\nprintk("TX ptr: %8.8x(%8.8x)\n",\r\nleptr, lib_off(btx_ring, lp->type));\r\nif (ZERO)\r\nprintk("TX rings:\n");\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nleptr = lp->tx_buf_ptr_lnc[i];\r\n*lib_ptr(ib, btx_ring[i].tmd0, lp->type) = leptr;\r\n*lib_ptr(ib, btx_ring[i].tmd1, lp->type) = (leptr >> 16) &\r\n0xff;\r\n*lib_ptr(ib, btx_ring[i].length, lp->type) = 0xf000;\r\n*lib_ptr(ib, btx_ring[i].misc, lp->type) = 0;\r\nif (i < 3 && ZERO)\r\nprintk("%d: 0x%8.8x(0x%8.8x)\n",\r\ni, leptr, (uint)lp->tx_buf_ptr_cpu[i]);\r\n}\r\nif (ZERO)\r\nprintk("RX rings:\n");\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nleptr = lp->rx_buf_ptr_lnc[i];\r\n*lib_ptr(ib, brx_ring[i].rmd0, lp->type) = leptr;\r\n*lib_ptr(ib, brx_ring[i].rmd1, lp->type) = ((leptr >> 16) &\r\n0xff) |\r\nLE_R1_OWN;\r\n*lib_ptr(ib, brx_ring[i].length, lp->type) = -RX_BUFF_SIZE |\r\n0xf000;\r\n*lib_ptr(ib, brx_ring[i].mblength, lp->type) = 0;\r\nif (i < 3 && ZERO)\r\nprintk("%d: 0x%8.8x(0x%8.8x)\n",\r\ni, leptr, (uint)lp->rx_buf_ptr_cpu[i]);\r\n}\r\niob();\r\n}\r\nstatic int init_restart_lance(struct lance_private *lp)\r\n{\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint i;\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_INIT);\r\nfor (i = 0; (i < 100) && !(ll->rdp & LE_C0_IDON); i++) {\r\nudelay(10);\r\n}\r\nif ((i == 100) || (ll->rdp & LE_C0_ERR)) {\r\nprintk("LANCE unopened after %d ticks, csr0=%4.4x.\n",\r\ni, ll->rdp);\r\nreturn -1;\r\n}\r\nif ((ll->rdp & LE_C0_ERR)) {\r\nprintk("LANCE unopened after %d ticks, csr0=%4.4x.\n",\r\ni, ll->rdp);\r\nreturn -1;\r\n}\r\nwritereg(&ll->rdp, LE_C0_IDON);\r\nwritereg(&ll->rdp, LE_C0_STRT);\r\nwritereg(&ll->rdp, LE_C0_INEA);\r\nreturn 0;\r\n}\r\nstatic int lance_rx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nvolatile u16 *rd;\r\nunsigned short bits;\r\nint entry, len;\r\nstruct sk_buff *skb;\r\n#ifdef TEST_HITS\r\n{\r\nint i;\r\nprintk("[");\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nif (i == lp->rx_new)\r\nprintk("%s", *lib_ptr(ib, brx_ring[i].rmd1,\r\nlp->type) &\r\nLE_R1_OWN ? "_" : "X");\r\nelse\r\nprintk("%s", *lib_ptr(ib, brx_ring[i].rmd1,\r\nlp->type) &\r\nLE_R1_OWN ? "." : "1");\r\n}\r\nprintk("]");\r\n}\r\n#endif\r\nfor (rd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type);\r\n!((bits = *rds_ptr(rd, rmd1, lp->type)) & LE_R1_OWN);\r\nrd = lib_ptr(ib, brx_ring[lp->rx_new], lp->type)) {\r\nentry = lp->rx_new;\r\nif ((bits & LE_R1_POK) != LE_R1_POK) {\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\n} else if (bits & LE_R1_ERR) {\r\nif (bits & LE_R1_BUF)\r\ndev->stats.rx_fifo_errors++;\r\nif (bits & LE_R1_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (bits & LE_R1_OFL)\r\ndev->stats.rx_over_errors++;\r\nif (bits & LE_R1_FRA)\r\ndev->stats.rx_frame_errors++;\r\nif (bits & LE_R1_EOP)\r\ndev->stats.rx_errors++;\r\n} else {\r\nlen = (*rds_ptr(rd, mblength, lp->type) & 0xfff) - 4;\r\nskb = netdev_alloc_skb(dev, len + 2);\r\nif (skb == 0) {\r\nprintk("%s: Memory squeeze, deferring packet.\n",\r\ndev->name);\r\ndev->stats.rx_dropped++;\r\n*rds_ptr(rd, mblength, lp->type) = 0;\r\n*rds_ptr(rd, rmd1, lp->type) =\r\n((lp->rx_buf_ptr_lnc[entry] >> 16) &\r\n0xff) | LE_R1_OWN;\r\nlp->rx_new = (entry + 1) & RX_RING_MOD_MASK;\r\nreturn 0;\r\n}\r\ndev->stats.rx_bytes += len;\r\nskb_reserve(skb, 2);\r\nskb_put(skb, len);\r\ncp_from_buf(lp->type, skb->data,\r\n(char *)lp->rx_buf_ptr_cpu[entry], len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\n}\r\n*rds_ptr(rd, mblength, lp->type) = 0;\r\n*rds_ptr(rd, length, lp->type) = -RX_BUFF_SIZE | 0xf000;\r\n*rds_ptr(rd, rmd1, lp->type) =\r\n((lp->rx_buf_ptr_lnc[entry] >> 16) & 0xff) | LE_R1_OWN;\r\nlp->rx_new = (entry + 1) & RX_RING_MOD_MASK;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lance_tx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nvolatile struct lance_regs *ll = lp->ll;\r\nvolatile u16 *td;\r\nint i, j;\r\nint status;\r\nj = lp->tx_old;\r\nspin_lock(&lp->lock);\r\nfor (i = j; i != lp->tx_new; i = j) {\r\ntd = lib_ptr(ib, btx_ring[i], lp->type);\r\nif (*tds_ptr(td, tmd1, lp->type) & LE_T1_OWN)\r\nbreak;\r\nif (*tds_ptr(td, tmd1, lp->type) & LE_T1_ERR) {\r\nstatus = *tds_ptr(td, misc, lp->type);\r\ndev->stats.tx_errors++;\r\nif (status & LE_T3_RTY)\r\ndev->stats.tx_aborted_errors++;\r\nif (status & LE_T3_LCOL)\r\ndev->stats.tx_window_errors++;\r\nif (status & LE_T3_CLOS) {\r\ndev->stats.tx_carrier_errors++;\r\nprintk("%s: Carrier Lost\n", dev->name);\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\ngoto out;\r\n}\r\nif (status & (LE_T3_BUF | LE_T3_UFL)) {\r\ndev->stats.tx_fifo_errors++;\r\nprintk("%s: Tx: ERR_BUF|ERR_UFL, restarting\n",\r\ndev->name);\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\ngoto out;\r\n}\r\n} else if ((*tds_ptr(td, tmd1, lp->type) & LE_T1_POK) ==\r\nLE_T1_POK) {\r\n*tds_ptr(td, tmd1, lp->type) &= ~(LE_T1_POK);\r\nif (*tds_ptr(td, tmd1, lp->type) & LE_T1_EONE)\r\ndev->stats.collisions++;\r\nif (*tds_ptr(td, tmd1, lp->type) & LE_T1_EMORE)\r\ndev->stats.collisions += 2;\r\ndev->stats.tx_packets++;\r\n}\r\nj = (j + 1) & TX_RING_MOD_MASK;\r\n}\r\nlp->tx_old = j;\r\nout:\r\nif (netif_queue_stopped(dev) &&\r\nTX_BUFFS_AVAIL > 0)\r\nnetif_wake_queue(dev);\r\nspin_unlock(&lp->lock);\r\n}\r\nstatic irqreturn_t lance_dma_merr_int(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nprintk(KERN_ERR "%s: DMA error\n", dev->name);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint csr0;\r\nwritereg(&ll->rap, LE_CSR0);\r\ncsr0 = ll->rdp;\r\nwritereg(&ll->rdp, csr0 & (LE_C0_INTR | LE_C0_TINT | LE_C0_RINT));\r\nif ((csr0 & LE_C0_ERR)) {\r\nwritereg(&ll->rdp, LE_C0_BABL | LE_C0_ERR | LE_C0_MISS |\r\nLE_C0_CERR | LE_C0_MERR);\r\n}\r\nif (csr0 & LE_C0_RINT)\r\nlance_rx(dev);\r\nif (csr0 & LE_C0_TINT)\r\nlance_tx(dev);\r\nif (csr0 & LE_C0_BABL)\r\ndev->stats.tx_errors++;\r\nif (csr0 & LE_C0_MISS)\r\ndev->stats.rx_errors++;\r\nif (csr0 & LE_C0_MERR) {\r\nprintk("%s: Memory error, status %04x\n", dev->name, csr0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nnetif_wake_queue(dev);\r\n}\r\nwritereg(&ll->rdp, LE_C0_INEA);\r\nwritereg(&ll->rdp, LE_C0_INEA);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lance_open(struct net_device *dev)\r\n{\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint status = 0;\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\n*lib_ptr(ib, mode, lp->type) = 0;\r\n*lib_ptr(ib, filter[0], lp->type) = 0;\r\n*lib_ptr(ib, filter[1], lp->type) = 0;\r\n*lib_ptr(ib, filter[2], lp->type) = 0;\r\n*lib_ptr(ib, filter[3], lp->type) = 0;\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\nnetif_start_queue(dev);\r\nif (request_irq(dev->irq, lance_interrupt, 0, "lance", dev)) {\r\nprintk("%s: Can't get IRQ %d\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nif (lp->dma_irq >= 0) {\r\nunsigned long flags;\r\nif (request_irq(lp->dma_irq, lance_dma_merr_int, 0,\r\n"lance error", dev)) {\r\nfree_irq(dev->irq, dev);\r\nprintk("%s: Can't get DMA IRQ %d\n", dev->name,\r\nlp->dma_irq);\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_irqsave(&ioasic_ssr_lock, flags);\r\nfast_mb();\r\nioasic_write(IO_REG_SSR,\r\nioasic_read(IO_REG_SSR) | IO_SSR_LANCE_DMA_EN);\r\nfast_mb();\r\nspin_unlock_irqrestore(&ioasic_ssr_lock, flags);\r\n}\r\nstatus = init_restart_lance(lp);\r\nreturn status;\r\n}\r\nstatic int lance_close(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&lp->multicast_timer);\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\nif (lp->dma_irq >= 0) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioasic_ssr_lock, flags);\r\nfast_mb();\r\nioasic_write(IO_REG_SSR,\r\nioasic_read(IO_REG_SSR) & ~IO_SSR_LANCE_DMA_EN);\r\nfast_iob();\r\nspin_unlock_irqrestore(&ioasic_ssr_lock, flags);\r\nfree_irq(lp->dma_irq, dev);\r\n}\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic inline int lance_reset(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint status;\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ndev->trans_start = jiffies;\r\nstatus = init_restart_lance(lp);\r\nreturn status;\r\n}\r\nstatic void lance_tx_timeout(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nprintk(KERN_ERR "%s: transmit timed out, status %04x, reset\n",\r\ndev->name, ll->rdp);\r\nlance_reset(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int lance_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nunsigned long flags;\r\nint entry, len;\r\nlen = skb->len;\r\nif (len < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlen = ETH_ZLEN;\r\n}\r\ndev->stats.tx_bytes += len;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nentry = lp->tx_new;\r\n*lib_ptr(ib, btx_ring[entry].length, lp->type) = (-len);\r\n*lib_ptr(ib, btx_ring[entry].misc, lp->type) = 0;\r\ncp_to_buf(lp->type, (char *)lp->tx_buf_ptr_cpu[entry], skb->data, len);\r\n*lib_ptr(ib, btx_ring[entry].tmd1, lp->type) =\r\n((lp->tx_buf_ptr_lnc[entry] >> 16) & 0xff) |\r\n(LE_T1_POK | LE_T1_OWN);\r\nlp->tx_new = (entry + 1) & TX_RING_MOD_MASK;\r\nif (TX_BUFFS_AVAIL <= 0)\r\nnetif_stop_queue(dev);\r\nwritereg(&ll->rdp, LE_C0_INEA | LE_C0_TDMD);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void lance_load_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nif (dev->flags & IFF_ALLMULTI) {\r\n*lib_ptr(ib, filter[0], lp->type) = 0xffff;\r\n*lib_ptr(ib, filter[1], lp->type) = 0xffff;\r\n*lib_ptr(ib, filter[2], lp->type) = 0xffff;\r\n*lib_ptr(ib, filter[3], lp->type) = 0xffff;\r\nreturn;\r\n}\r\n*lib_ptr(ib, filter[0], lp->type) = 0;\r\n*lib_ptr(ib, filter[1], lp->type) = 0;\r\n*lib_ptr(ib, filter[2], lp->type) = 0;\r\n*lib_ptr(ib, filter[3], lp->type) = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(ETH_ALEN, ha->addr);\r\ncrc = crc >> 26;\r\n*lib_ptr(ib, filter[crc >> 4], lp->type) |= 1 << (crc & 0xf);\r\n}\r\n}\r\nstatic void lance_set_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile u16 *ib = (volatile u16 *)dev->mem_start;\r\nvolatile struct lance_regs *ll = lp->ll;\r\nif (!netif_running(dev))\r\nreturn;\r\nif (lp->tx_old != lp->tx_new) {\r\nmod_timer(&lp->multicast_timer, jiffies + 4 * HZ/100);\r\nnetif_wake_queue(dev);\r\nreturn;\r\n}\r\nnetif_stop_queue(dev);\r\nwritereg(&ll->rap, LE_CSR0);\r\nwritereg(&ll->rdp, LE_C0_STOP);\r\nlance_init_ring(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\n*lib_ptr(ib, mode, lp->type) |= LE_MO_PROM;\r\n} else {\r\n*lib_ptr(ib, mode, lp->type) &= ~LE_MO_PROM;\r\nlance_load_multicast(dev);\r\n}\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void lance_set_multicast_retry(unsigned long _opaque)\r\n{\r\nstruct net_device *dev = (struct net_device *) _opaque;\r\nlance_set_multicast(dev);\r\n}\r\nstatic int __devinit dec_lance_probe(struct device *bdev, const int type)\r\n{\r\nstatic unsigned version_printed;\r\nstatic const char fmt[] = "declance%d";\r\nchar name[10];\r\nstruct net_device *dev;\r\nstruct lance_private *lp;\r\nvolatile struct lance_regs *ll;\r\nresource_size_t start = 0, len = 0;\r\nint i, ret;\r\nunsigned long esar_base;\r\nunsigned char *esar;\r\nif (dec_lance_debug && version_printed++ == 0)\r\nprintk(version);\r\nif (bdev)\r\nsnprintf(name, sizeof(name), "%s", dev_name(bdev));\r\nelse {\r\ni = 0;\r\ndev = root_lance_dev;\r\nwhile (dev) {\r\ni++;\r\nlp = netdev_priv(dev);\r\ndev = lp->next;\r\n}\r\nsnprintf(name, sizeof(name), fmt, i);\r\n}\r\ndev = alloc_etherdev(sizeof(struct lance_private));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\nlp = netdev_priv(dev);\r\nspin_lock_init(&lp->lock);\r\nlp->type = type;\r\nswitch (type) {\r\ncase ASIC_LANCE:\r\ndev->base_addr = CKSEG1ADDR(dec_kn_slot_base + IOASIC_LANCE);\r\ndev->mem_start = CKSEG1ADDR(0x00020000);\r\ndev->mem_end = dev->mem_start + 0x00020000;\r\ndev->irq = dec_interrupt[DEC_IRQ_LANCE];\r\nesar_base = CKSEG1ADDR(dec_kn_slot_base + IOASIC_ESAR);\r\nmemset((void *)dev->mem_start, 0,\r\ndev->mem_end - dev->mem_start);\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nlp->rx_buf_ptr_cpu[i] =\r\n(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\r\n2 * i * RX_BUFF_SIZE);\r\nlp->rx_buf_ptr_lnc[i] =\r\n(BUF_OFFSET_LNC + i * RX_BUFF_SIZE);\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nlp->tx_buf_ptr_cpu[i] =\r\n(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\r\n2 * RX_RING_SIZE * RX_BUFF_SIZE +\r\n2 * i * TX_BUFF_SIZE);\r\nlp->tx_buf_ptr_lnc[i] =\r\n(BUF_OFFSET_LNC +\r\nRX_RING_SIZE * RX_BUFF_SIZE +\r\ni * TX_BUFF_SIZE);\r\n}\r\nlp->dma_irq = dec_interrupt[DEC_IRQ_LANCE_MERR];\r\nioasic_write(IO_REG_LANCE_DMA_P,\r\nCPHYSADDR(dev->mem_start) << 3);\r\nbreak;\r\n#ifdef CONFIG_TC\r\ncase PMAD_LANCE:\r\ndev_set_drvdata(bdev, dev);\r\nstart = to_tc_dev(bdev)->resource.start;\r\nlen = to_tc_dev(bdev)->resource.end - start + 1;\r\nif (!request_mem_region(start, len, dev_name(bdev))) {\r\nprintk(KERN_ERR\r\n"%s: Unable to reserve MMIO resource\n",\r\ndev_name(bdev));\r\nret = -EBUSY;\r\ngoto err_out_dev;\r\n}\r\ndev->mem_start = CKSEG1ADDR(start);\r\ndev->mem_end = dev->mem_start + 0x100000;\r\ndev->base_addr = dev->mem_start + 0x100000;\r\ndev->irq = to_tc_dev(bdev)->interrupt;\r\nesar_base = dev->mem_start + 0x1c0002;\r\nlp->dma_irq = -1;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nlp->rx_buf_ptr_cpu[i] =\r\n(char *)(dev->mem_start + BUF_OFFSET_CPU +\r\ni * RX_BUFF_SIZE);\r\nlp->rx_buf_ptr_lnc[i] =\r\n(BUF_OFFSET_LNC + i * RX_BUFF_SIZE);\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nlp->tx_buf_ptr_cpu[i] =\r\n(char *)(dev->mem_start + BUF_OFFSET_CPU +\r\nRX_RING_SIZE * RX_BUFF_SIZE +\r\ni * TX_BUFF_SIZE);\r\nlp->tx_buf_ptr_lnc[i] =\r\n(BUF_OFFSET_LNC +\r\nRX_RING_SIZE * RX_BUFF_SIZE +\r\ni * TX_BUFF_SIZE);\r\n}\r\nbreak;\r\n#endif\r\ncase PMAX_LANCE:\r\ndev->irq = dec_interrupt[DEC_IRQ_LANCE];\r\ndev->base_addr = CKSEG1ADDR(KN01_SLOT_BASE + KN01_LANCE);\r\ndev->mem_start = CKSEG1ADDR(KN01_SLOT_BASE + KN01_LANCE_MEM);\r\ndev->mem_end = dev->mem_start + KN01_SLOT_SIZE;\r\nesar_base = CKSEG1ADDR(KN01_SLOT_BASE + KN01_ESAR + 1);\r\nlp->dma_irq = -1;\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nlp->rx_buf_ptr_cpu[i] =\r\n(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\r\n2 * i * RX_BUFF_SIZE);\r\nlp->rx_buf_ptr_lnc[i] =\r\n(BUF_OFFSET_LNC + i * RX_BUFF_SIZE);\r\n}\r\nfor (i = 0; i < TX_RING_SIZE; i++) {\r\nlp->tx_buf_ptr_cpu[i] =\r\n(char *)(dev->mem_start + 2 * BUF_OFFSET_CPU +\r\n2 * RX_RING_SIZE * RX_BUFF_SIZE +\r\n2 * i * TX_BUFF_SIZE);\r\nlp->tx_buf_ptr_lnc[i] =\r\n(BUF_OFFSET_LNC +\r\nRX_RING_SIZE * RX_BUFF_SIZE +\r\ni * TX_BUFF_SIZE);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: declance_init called with unknown type\n",\r\nname);\r\nret = -ENODEV;\r\ngoto err_out_dev;\r\n}\r\nll = (struct lance_regs *) dev->base_addr;\r\nesar = (unsigned char *) esar_base;\r\nif (esar[0x60] != 0xff && esar[0x64] != 0x00 &&\r\nesar[0x68] != 0x55 && esar[0x6c] != 0xaa) {\r\nprintk(KERN_ERR\r\n"%s: Ethernet station address prom not found!\n",\r\nname);\r\nret = -ENODEV;\r\ngoto err_out_resource;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nif (esar[i * 4] != esar[0x3c - i * 4] &&\r\nesar[i * 4] != esar[0x40 + i * 4] &&\r\nesar[0x3c - i * 4] != esar[0x40 + i * 4]) {\r\nprintk(KERN_ERR "%s: Something is wrong with the "\r\n"ethernet station address prom!\n", name);\r\nret = -ENODEV;\r\ngoto err_out_resource;\r\n}\r\n}\r\nswitch (type) {\r\ncase ASIC_LANCE:\r\nprintk("%s: IOASIC onboard LANCE", name);\r\nbreak;\r\ncase PMAD_LANCE:\r\nprintk("%s: PMAD-AA", name);\r\nbreak;\r\ncase PMAX_LANCE:\r\nprintk("%s: PMAX onboard LANCE", name);\r\nbreak;\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = esar[i * 4];\r\nprintk(", addr = %pM, irq = %d\n", dev->dev_addr, dev->irq);\r\ndev->netdev_ops = &lance_netdev_ops;\r\ndev->watchdog_timeo = 5*HZ;\r\nlp->ll = ll;\r\nlp->busmaster_regval = 0;\r\ndev->dma = 0;\r\ninit_timer(&lp->multicast_timer);\r\nlp->multicast_timer.data = (unsigned long) dev;\r\nlp->multicast_timer.function = lance_set_multicast_retry;\r\nret = register_netdev(dev);\r\nif (ret) {\r\nprintk(KERN_ERR\r\n"%s: Unable to register netdev, aborting.\n", name);\r\ngoto err_out_resource;\r\n}\r\nif (!bdev) {\r\nlp->next = root_lance_dev;\r\nroot_lance_dev = dev;\r\n}\r\nprintk("%s: registered as %s.\n", name, dev->name);\r\nreturn 0;\r\nerr_out_resource:\r\nif (bdev)\r\nrelease_mem_region(start, len);\r\nerr_out_dev:\r\nfree_netdev(dev);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void __exit dec_lance_remove(struct device *bdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(bdev);\r\nresource_size_t start, len;\r\nunregister_netdev(dev);\r\nstart = to_tc_dev(bdev)->resource.start;\r\nlen = to_tc_dev(bdev)->resource.end - start + 1;\r\nrelease_mem_region(start, len);\r\nfree_netdev(dev);\r\n}\r\nstatic int __init dec_lance_platform_probe(void)\r\n{\r\nint count = 0;\r\nif (dec_interrupt[DEC_IRQ_LANCE] >= 0) {\r\nif (dec_interrupt[DEC_IRQ_LANCE_MERR] >= 0) {\r\nif (dec_lance_probe(NULL, ASIC_LANCE) >= 0)\r\ncount++;\r\n} else if (!TURBOCHANNEL) {\r\nif (dec_lance_probe(NULL, PMAX_LANCE) >= 0)\r\ncount++;\r\n}\r\n}\r\nreturn (count > 0) ? 0 : -ENODEV;\r\n}\r\nstatic void __exit dec_lance_platform_remove(void)\r\n{\r\nwhile (root_lance_dev) {\r\nstruct net_device *dev = root_lance_dev;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nroot_lance_dev = lp->next;\r\nfree_netdev(dev);\r\n}\r\n}\r\nstatic int __devinit dec_lance_tc_probe(struct device *dev)\r\n{\r\nint status = dec_lance_probe(dev, PMAD_LANCE);\r\nif (!status)\r\nget_device(dev);\r\nreturn status;\r\n}\r\nstatic int __exit dec_lance_tc_remove(struct device *dev)\r\n{\r\nput_device(dev);\r\ndec_lance_remove(dev);\r\nreturn 0;\r\n}\r\nstatic int __init dec_lance_init(void)\r\n{\r\nint status;\r\nstatus = tc_register_driver(&dec_lance_tc_driver);\r\nif (!status)\r\ndec_lance_platform_probe();\r\nreturn status;\r\n}\r\nstatic void __exit dec_lance_exit(void)\r\n{\r\ndec_lance_platform_remove();\r\ntc_unregister_driver(&dec_lance_tc_driver);\r\n}
