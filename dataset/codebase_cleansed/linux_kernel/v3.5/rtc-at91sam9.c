static int at91_rtc_readtime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 secs, secs2;\r\nu32 offset;\r\noffset = gpbr_readl(rtc);\r\nif (offset == 0)\r\nreturn -EILSEQ;\r\nsecs = rtt_readl(rtc, VR);\r\nsecs2 = rtt_readl(rtc, VR);\r\nif (secs != secs2)\r\nsecs = rtt_readl(rtc, VR);\r\nrtc_time_to_tm(offset + secs, tm);\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "readtime",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_settime(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nint err;\r\nu32 offset, alarm, mr;\r\nunsigned long secs;\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "settime",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nerr = rtc_tm_to_time(tm, &secs);\r\nif (err != 0)\r\nreturn err;\r\nmr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\r\noffset = gpbr_readl(rtc);\r\nsecs += 1;\r\ngpbr_writel(rtc, secs);\r\nalarm = rtt_readl(rtc, AR);\r\nif (alarm != ALARM_DISABLED) {\r\nif (offset > secs) {\r\nalarm += (offset - secs);\r\n} else if ((alarm + offset) > secs) {\r\nalarm -= (secs - offset);\r\n} else {\r\nalarm = ALARM_DISABLED;\r\nmr &= ~AT91_RTT_ALMIEN;\r\n}\r\nrtt_writel(rtc, AR, alarm);\r\n}\r\nrtt_writel(rtc, MR, mr | AT91_RTT_RTTRST);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_readalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nu32 alarm = rtt_readl(rtc, AR);\r\nu32 offset;\r\noffset = gpbr_readl(rtc);\r\nif (offset == 0)\r\nreturn -EILSEQ;\r\nmemset(alrm, 0, sizeof(*alrm));\r\nif (alarm != ALARM_DISABLED && offset != 0) {\r\nrtc_time_to_tm(offset + alarm, tm);\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "readalarm",\r\n1900 + tm->tm_year, tm->tm_mon, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nif (rtt_readl(rtc, MR) & AT91_RTT_ALMIEN)\r\nalrm->enabled = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_setalarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nstruct rtc_time *tm = &alrm->time;\r\nunsigned long secs;\r\nu32 offset;\r\nu32 mr;\r\nint err;\r\nerr = rtc_tm_to_time(tm, &secs);\r\nif (err != 0)\r\nreturn err;\r\noffset = gpbr_readl(rtc);\r\nif (offset == 0) {\r\nreturn -EILSEQ;\r\n}\r\nmr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\r\nif (secs <= offset) {\r\nrtt_writel(rtc, AR, ALARM_DISABLED);\r\nreturn 0;\r\n}\r\nrtt_writel(rtc, AR, secs - offset);\r\nif (alrm->enabled)\r\nrtt_writel(rtc, MR, mr | AT91_RTT_ALMIEN);\r\ndev_dbg(dev, "%s: %4d-%02d-%02d %02d:%02d:%02d\n", "setalarm",\r\ntm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,\r\ntm->tm_min, tm->tm_sec);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 mr = rtt_readl(rtc, MR);\r\ndev_dbg(dev, "alarm_irq_enable: enabled=%08x, mr %08x\n", enabled, mr);\r\nif (enabled)\r\nrtt_writel(rtc, MR, mr | AT91_RTT_ALMIEN);\r\nelse\r\nrtt_writel(rtc, MR, mr & ~AT91_RTT_ALMIEN);\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct sam9_rtc *rtc = dev_get_drvdata(dev);\r\nu32 mr = mr = rtt_readl(rtc, MR);\r\nseq_printf(seq, "update_IRQ\t: %s\n",\r\n(mr & AT91_RTT_RTTINCIEN) ? "yes" : "no");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t at91_rtc_interrupt(int irq, void *_rtc)\r\n{\r\nstruct sam9_rtc *rtc = _rtc;\r\nu32 sr, mr;\r\nunsigned long events = 0;\r\nmr = rtt_readl(rtc, MR) & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nsr = rtt_readl(rtc, SR) & (mr >> 16);\r\nif (!sr)\r\nreturn IRQ_NONE;\r\nif (sr & AT91_RTT_ALMS)\r\nevents |= (RTC_AF | RTC_IRQF);\r\nif (sr & AT91_RTT_RTTINC)\r\nevents |= (RTC_UF | RTC_IRQF);\r\nrtc_update_irq(rtc->rtcdev, 1, events);\r\npr_debug("%s: num=%ld, events=0x%02lx\n", __func__,\r\nevents >> 8, events & 0x000000FF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit at91_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r, *r_gpbr;\r\nstruct sam9_rtc *rtc;\r\nint ret;\r\nu32 mr;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nr_gpbr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r || !r_gpbr) {\r\ndev_err(&pdev->dev, "need 2 ressources\n");\r\nreturn -ENODEV;\r\n}\r\nrtc = kzalloc(sizeof *rtc, GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nif (!device_can_wakeup(&pdev->dev))\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->rtt = ioremap(r->start, resource_size(r));\r\nif (!rtc->rtt) {\r\ndev_err(&pdev->dev, "failed to map registers, aborting.\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nrtc->gpbr = ioremap(r_gpbr->start, resource_size(r_gpbr));\r\nif (!rtc->gpbr) {\r\ndev_err(&pdev->dev, "failed to map gpbr registers, aborting.\n");\r\nret = -ENOMEM;\r\ngoto fail_gpbr;\r\n}\r\nmr = rtt_readl(rtc, MR);\r\nif ((mr & AT91_RTT_RTPRES) != AT91_SLOW_CLOCK) {\r\nmr = AT91_RTT_RTTRST | (AT91_SLOW_CLOCK & AT91_RTT_RTPRES);\r\ngpbr_writel(rtc, 0);\r\n}\r\nmr &= ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nrtt_writel(rtc, MR, mr);\r\nrtc->rtcdev = rtc_device_register(pdev->name, &pdev->dev,\r\n&at91_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtcdev)) {\r\nret = PTR_ERR(rtc->rtcdev);\r\ngoto fail_register;\r\n}\r\nret = request_irq(AT91_ID_SYS, at91_rtc_interrupt,\r\nIRQF_SHARED,\r\ndev_name(&rtc->rtcdev->dev), rtc);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "can't share IRQ %d?\n", AT91_ID_SYS);\r\nrtc_device_unregister(rtc->rtcdev);\r\ngoto fail_register;\r\n}\r\nif (gpbr_readl(rtc) == 0)\r\ndev_warn(&pdev->dev, "%s: SET TIME!\n",\r\ndev_name(&rtc->rtcdev->dev));\r\nreturn 0;\r\nfail_register:\r\niounmap(rtc->gpbr);\r\nfail_gpbr:\r\niounmap(rtc->rtt);\r\nfail:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(rtc);\r\nreturn ret;\r\n}\r\nstatic int __devexit at91_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct sam9_rtc *rtc = platform_get_drvdata(pdev);\r\nu32 mr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr & ~(AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN));\r\nfree_irq(AT91_ID_SYS, rtc);\r\nrtc_device_unregister(rtc->rtcdev);\r\niounmap(rtc->gpbr);\r\niounmap(rtc->rtt);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(rtc);\r\nreturn 0;\r\n}\r\nstatic void at91_rtc_shutdown(struct platform_device *pdev)\r\n{\r\nstruct sam9_rtc *rtc = platform_get_drvdata(pdev);\r\nu32 mr = rtt_readl(rtc, MR);\r\nrtc->imr = mr & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nrtt_writel(rtc, MR, mr & ~rtc->imr);\r\n}\r\nstatic int at91_rtc_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct sam9_rtc *rtc = platform_get_drvdata(pdev);\r\nu32 mr = rtt_readl(rtc, MR);\r\nrtc->imr = mr & (AT91_RTT_ALMIEN | AT91_RTT_RTTINCIEN);\r\nif (rtc->imr) {\r\nif (device_may_wakeup(&pdev->dev) && (mr & AT91_RTT_ALMIEN)) {\r\nenable_irq_wake(AT91_ID_SYS);\r\nif (mr & AT91_RTT_RTTINCIEN)\r\nrtt_writel(rtc, MR, mr & ~AT91_RTT_RTTINCIEN);\r\n} else\r\nrtt_writel(rtc, MR, mr & ~rtc->imr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91_rtc_resume(struct platform_device *pdev)\r\n{\r\nstruct sam9_rtc *rtc = platform_get_drvdata(pdev);\r\nu32 mr;\r\nif (rtc->imr) {\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(AT91_ID_SYS);\r\nmr = rtt_readl(rtc, MR);\r\nrtt_writel(rtc, MR, mr | rtc->imr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init at91_rtc_init(void)\r\n{\r\nreturn platform_driver_register(&at91_rtc_driver);\r\n}\r\nstatic void __exit at91_rtc_exit(void)\r\n{\r\nplatform_driver_unregister(&at91_rtc_driver);\r\n}
