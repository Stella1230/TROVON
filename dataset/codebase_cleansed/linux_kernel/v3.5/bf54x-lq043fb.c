static inline u16 get_eppi_clkdiv(u32 target_ppi_clk)\r\n{\r\nu32 sclk = get_sclk();\r\nreturn (((sclk / target_ppi_clk) / 2) - 1);\r\n}\r\nstatic void config_ppi(struct bfin_bf54xfb_info *fbi)\r\n{\r\nu16 eppi_clkdiv = get_eppi_clkdiv(LCD_CLK);\r\nbfin_write_EPPI0_FS1W_HBL(EPPI_FS1W_HBL);\r\nbfin_write_EPPI0_FS1P_AVPL(EPPI_FS1P_AVPL);\r\nbfin_write_EPPI0_FS2W_LVB(EPPI_FS2W_LVB);\r\nbfin_write_EPPI0_FS2P_LAVF(EPPI_FS2P_LAVF);\r\nbfin_write_EPPI0_CLIP(EPPI_CLIP);\r\nbfin_write_EPPI0_FRAME(EPPI_FRAME);\r\nbfin_write_EPPI0_LINE(EPPI_LINE);\r\nbfin_write_EPPI0_HCOUNT(EPPI_HCOUNT);\r\nbfin_write_EPPI0_HDELAY(EPPI_HDELAY);\r\nbfin_write_EPPI0_VCOUNT(EPPI_VCOUNT);\r\nbfin_write_EPPI0_VDELAY(EPPI_VDELAY);\r\nbfin_write_EPPI0_CLKDIV(eppi_clkdiv);\r\nif (outp_rgb666)\r\nbfin_write_EPPI0_CONTROL((EPPI_CONTROL & ~DLENGTH) | DLEN_18 |\r\nRGB_FMT_EN);\r\nelse\r\nbfin_write_EPPI0_CONTROL(((EPPI_CONTROL & ~DLENGTH) | DLEN_24) &\r\n~RGB_FMT_EN);\r\n}\r\nstatic int config_dma(struct bfin_bf54xfb_info *fbi)\r\n{\r\nset_dma_config(CH_EPPI0,\r\nset_bfin_dma_config(DIR_READ, DMA_FLOW_AUTO,\r\nINTR_DISABLE, DIMENSION_2D,\r\nDATA_SIZE_32,\r\nDMA_NOSYNC_KEEP_DMA_BUF));\r\nset_dma_x_count(CH_EPPI0, (LCD_X_RES * LCD_BPP) / DMA_BUS_SIZE);\r\nset_dma_x_modify(CH_EPPI0, DMA_BUS_SIZE / 8);\r\nset_dma_y_count(CH_EPPI0, LCD_Y_RES);\r\nset_dma_y_modify(CH_EPPI0, DMA_BUS_SIZE / 8);\r\nset_dma_start_addr(CH_EPPI0, (unsigned long)fbi->fb_buffer);\r\nreturn 0;\r\n}\r\nstatic int request_ports(struct bfin_bf54xfb_info *fbi)\r\n{\r\nu16 eppi_req_18[] = EPPI0_18;\r\nu16 disp = fbi->mach_info->disp;\r\nif (gpio_request_one(disp, GPIOF_OUT_INIT_HIGH, DRIVER_NAME)) {\r\nprintk(KERN_ERR "Requesting GPIO %d failed\n", disp);\r\nreturn -EFAULT;\r\n}\r\nif (peripheral_request_list(eppi_req_18, DRIVER_NAME)) {\r\nprintk(KERN_ERR "Requesting Peripherals failed\n");\r\ngpio_free(disp);\r\nreturn -EFAULT;\r\n}\r\nif (!outp_rgb666) {\r\nu16 eppi_req_24[] = EPPI0_24;\r\nif (peripheral_request_list(eppi_req_24, DRIVER_NAME)) {\r\nprintk(KERN_ERR "Requesting Peripherals failed\n");\r\nperipheral_free_list(eppi_req_18);\r\ngpio_free(disp);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_ports(struct bfin_bf54xfb_info *fbi)\r\n{\r\nu16 eppi_req_18[] = EPPI0_18;\r\ngpio_free(fbi->mach_info->disp);\r\nperipheral_free_list(eppi_req_18);\r\nif (!outp_rgb666) {\r\nu16 eppi_req_24[] = EPPI0_24;\r\nperipheral_free_list(eppi_req_24);\r\n}\r\n}\r\nstatic int bfin_bf54x_fb_open(struct fb_info *info, int user)\r\n{\r\nstruct bfin_bf54xfb_info *fbi = info->par;\r\nspin_lock(&fbi->lock);\r\nfbi->lq043_open_cnt++;\r\nif (fbi->lq043_open_cnt <= 1) {\r\nbfin_write_EPPI0_CONTROL(0);\r\nSSYNC();\r\nconfig_dma(fbi);\r\nconfig_ppi(fbi);\r\nenable_dma(CH_EPPI0);\r\nbfin_write_EPPI0_CONTROL(bfin_read_EPPI0_CONTROL() | EPPI_EN);\r\n}\r\nspin_unlock(&fbi->lock);\r\nreturn 0;\r\n}\r\nstatic int bfin_bf54x_fb_release(struct fb_info *info, int user)\r\n{\r\nstruct bfin_bf54xfb_info *fbi = info->par;\r\nspin_lock(&fbi->lock);\r\nfbi->lq043_open_cnt--;\r\nif (fbi->lq043_open_cnt <= 0) {\r\nbfin_write_EPPI0_CONTROL(0);\r\nSSYNC();\r\ndisable_dma(CH_EPPI0);\r\n}\r\nspin_unlock(&fbi->lock);\r\nreturn 0;\r\n}\r\nstatic int bfin_bf54x_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nbreak;\r\ndefault:\r\npr_debug("%s: depth not supported: %u BPP\n", __func__,\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (info->var.xres != var->xres || info->var.yres != var->yres ||\r\ninfo->var.xres_virtual != var->xres_virtual ||\r\ninfo->var.yres_virtual != var->yres_virtual) {\r\npr_debug("%s: Resolution not supported: X%u x Y%u \n",\r\n__func__, var->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif ((info->fix.line_length * var->yres_virtual) > info->fix.smem_len) {\r\npr_debug("%s: Memory Limit requested yres_virtual = %u\n",\r\n__func__, var->yres_virtual);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint bfin_bf54x_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nif (nocursor)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int bfin_bf54x_fb_setcolreg(u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp,\r\nstruct fb_info *info)\r\n{\r\nif (regno >= BFIN_LCD_NBR_PALETTE_ENTRIES)\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 value;\r\nif (regno > 16)\r\nreturn -EINVAL;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\nvalue = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nvalue &= 0xFFFFFF;\r\n((u32 *) (info->pseudo_palette))[regno] = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bl_get_brightness(struct backlight_device *bd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_get_power(struct lcd_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_set_power(struct lcd_device *dev, int power)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_get_contrast(struct lcd_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_set_contrast(struct lcd_device *dev, int contrast)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bfin_lcd_check_fb(struct lcd_device *dev, struct fb_info *fi)\r\n{\r\nif (!fi || (fi == &bfin_bf54x_fb))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bfin_bf54x_irq_error(int irq, void *dev_id)\r\n{\r\nu16 status = bfin_read_EPPI0_STATUS();\r\nbfin_write_EPPI0_STATUS(0xFFFF);\r\nif (status) {\r\nbfin_write_EPPI0_CONTROL(bfin_read_EPPI0_CONTROL() & ~EPPI_EN);\r\ndisable_dma(CH_EPPI0);\r\nenable_dma(CH_EPPI0);\r\nbfin_write_EPPI0_CONTROL(bfin_read_EPPI0_CONTROL() | EPPI_EN);\r\nbfin_write_EPPI0_STATUS(0xFFFF);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit bfin_bf54x_probe(struct platform_device *pdev)\r\n{\r\n#ifndef NO_BL_SUPPORT\r\nstruct backlight_properties props;\r\n#endif\r\nstruct bfin_bf54xfb_info *info;\r\nstruct fb_info *fbinfo;\r\nint ret;\r\nprintk(KERN_INFO DRIVER_NAME ": FrameBuffer initializing...\n");\r\nif (request_dma(CH_EPPI0, "CH_EPPI0") < 0) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": couldn't request CH_EPPI0 DMA\n");\r\nret = -EFAULT;\r\ngoto out1;\r\n}\r\nfbinfo =\r\nframebuffer_alloc(sizeof(struct bfin_bf54xfb_info), &pdev->dev);\r\nif (!fbinfo) {\r\nret = -ENOMEM;\r\ngoto out2;\r\n}\r\ninfo = fbinfo->par;\r\ninfo->fb = fbinfo;\r\ninfo->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, fbinfo);\r\nstrcpy(fbinfo->fix.id, driver_name);\r\ninfo->mach_info = pdev->dev.platform_data;\r\nif (info->mach_info == NULL) {\r\ndev_err(&pdev->dev,\r\n"no platform data for lcd, cannot attach\n");\r\nret = -EINVAL;\r\ngoto out3;\r\n}\r\nfbinfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbinfo->fix.type_aux = 0;\r\nfbinfo->fix.xpanstep = 0;\r\nfbinfo->fix.ypanstep = 0;\r\nfbinfo->fix.ywrapstep = 0;\r\nfbinfo->fix.accel = FB_ACCEL_NONE;\r\nfbinfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfbinfo->var.nonstd = 0;\r\nfbinfo->var.activate = FB_ACTIVATE_NOW;\r\nfbinfo->var.height = info->mach_info->height;\r\nfbinfo->var.width = info->mach_info->width;\r\nfbinfo->var.accel_flags = 0;\r\nfbinfo->var.vmode = FB_VMODE_NONINTERLACED;\r\nfbinfo->fbops = &bfin_bf54x_fb_ops;\r\nfbinfo->flags = FBINFO_FLAG_DEFAULT;\r\nfbinfo->var.xres = info->mach_info->xres.defval;\r\nfbinfo->var.xres_virtual = info->mach_info->xres.defval;\r\nfbinfo->var.yres = info->mach_info->yres.defval;\r\nfbinfo->var.yres_virtual = info->mach_info->yres.defval;\r\nfbinfo->var.bits_per_pixel = info->mach_info->bpp.defval;\r\nfbinfo->var.upper_margin = 0;\r\nfbinfo->var.lower_margin = 0;\r\nfbinfo->var.vsync_len = 0;\r\nfbinfo->var.left_margin = 0;\r\nfbinfo->var.right_margin = 0;\r\nfbinfo->var.hsync_len = 0;\r\nfbinfo->var.red.offset = 16;\r\nfbinfo->var.green.offset = 8;\r\nfbinfo->var.blue.offset = 0;\r\nfbinfo->var.transp.offset = 0;\r\nfbinfo->var.red.length = 8;\r\nfbinfo->var.green.length = 8;\r\nfbinfo->var.blue.length = 8;\r\nfbinfo->var.transp.length = 0;\r\nfbinfo->fix.smem_len = info->mach_info->xres.max *\r\ninfo->mach_info->yres.max * info->mach_info->bpp.max / 8;\r\nfbinfo->fix.line_length = fbinfo->var.xres_virtual *\r\nfbinfo->var.bits_per_pixel / 8;\r\ninfo->fb_buffer =\r\ndma_alloc_coherent(NULL, fbinfo->fix.smem_len, &info->dma_handle,\r\nGFP_KERNEL);\r\nif (NULL == info->fb_buffer) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": couldn't allocate dma buffer.\n");\r\nret = -ENOMEM;\r\ngoto out3;\r\n}\r\nfbinfo->screen_base = (void *)info->fb_buffer;\r\nfbinfo->fix.smem_start = (int)info->fb_buffer;\r\nfbinfo->fbops = &bfin_bf54x_fb_ops;\r\nfbinfo->pseudo_palette = kzalloc(sizeof(u32) * 16, GFP_KERNEL);\r\nif (!fbinfo->pseudo_palette) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n"Fail to allocate pseudo_palette\n");\r\nret = -ENOMEM;\r\ngoto out4;\r\n}\r\nif (fb_alloc_cmap(&fbinfo->cmap, BFIN_LCD_NBR_PALETTE_ENTRIES, 0)\r\n< 0) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n"Fail to allocate colormap (%d entries)\n",\r\nBFIN_LCD_NBR_PALETTE_ENTRIES);\r\nret = -EFAULT;\r\ngoto out5;\r\n}\r\nif (request_ports(info)) {\r\nprintk(KERN_ERR DRIVER_NAME ": couldn't request gpio port.\n");\r\nret = -EFAULT;\r\ngoto out6;\r\n}\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (info->irq < 0) {\r\nret = -EINVAL;\r\ngoto out7;\r\n}\r\nif (request_irq(info->irq, bfin_bf54x_irq_error, 0,\r\n"PPI ERROR", info) < 0) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": unable to request PPI ERROR IRQ\n");\r\nret = -EFAULT;\r\ngoto out7;\r\n}\r\nif (register_framebuffer(fbinfo) < 0) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": unable to register framebuffer.\n");\r\nret = -EINVAL;\r\ngoto out8;\r\n}\r\n#ifndef NO_BL_SUPPORT\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 255;\r\nbl_dev = backlight_device_register("bf54x-bl", NULL, NULL,\r\n&bfin_lq043fb_bl_ops, &props);\r\nif (IS_ERR(bl_dev)) {\r\nprintk(KERN_ERR DRIVER_NAME\r\n": unable to register backlight.\n");\r\nret = -EINVAL;\r\nunregister_framebuffer(fbinfo);\r\ngoto out8;\r\n}\r\nlcd_dev = lcd_device_register(DRIVER_NAME, &pdev->dev, NULL, &bfin_lcd_ops);\r\nlcd_dev->props.max_contrast = 255, printk(KERN_INFO "Done.\n");\r\n#endif\r\nreturn 0;\r\nout8:\r\nfree_irq(info->irq, info);\r\nout7:\r\nfree_ports(info);\r\nout6:\r\nfb_dealloc_cmap(&fbinfo->cmap);\r\nout5:\r\nkfree(fbinfo->pseudo_palette);\r\nout4:\r\ndma_free_coherent(NULL, fbinfo->fix.smem_len, info->fb_buffer,\r\ninfo->dma_handle);\r\nout3:\r\nframebuffer_release(fbinfo);\r\nout2:\r\nfree_dma(CH_EPPI0);\r\nout1:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int __devexit bfin_bf54x_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(pdev);\r\nstruct bfin_bf54xfb_info *info = fbinfo->par;\r\nfree_dma(CH_EPPI0);\r\nfree_irq(info->irq, info);\r\nif (info->fb_buffer != NULL)\r\ndma_free_coherent(NULL, fbinfo->fix.smem_len, info->fb_buffer,\r\ninfo->dma_handle);\r\nkfree(fbinfo->pseudo_palette);\r\nfb_dealloc_cmap(&fbinfo->cmap);\r\n#ifndef NO_BL_SUPPORT\r\nlcd_device_unregister(lcd_dev);\r\nbacklight_device_unregister(bl_dev);\r\n#endif\r\nunregister_framebuffer(fbinfo);\r\nfree_ports(info);\r\nprintk(KERN_INFO DRIVER_NAME ": Unregister LCD driver.\n");\r\nreturn 0;\r\n}\r\nstatic int bfin_bf54x_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(pdev);\r\nbfin_write_EPPI0_CONTROL(bfin_read_EPPI0_CONTROL() & ~EPPI_EN);\r\ndisable_dma(CH_EPPI0);\r\nbfin_write_EPPI0_STATUS(0xFFFF);\r\nreturn 0;\r\n}\r\nstatic int bfin_bf54x_resume(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(pdev);\r\nstruct bfin_bf54xfb_info *info = fbinfo->par;\r\nif (info->lq043_open_cnt) {\r\nbfin_write_EPPI0_CONTROL(0);\r\nSSYNC();\r\nconfig_dma(info);\r\nconfig_ppi(info);\r\nenable_dma(CH_EPPI0);\r\nbfin_write_EPPI0_CONTROL(bfin_read_EPPI0_CONTROL() | EPPI_EN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bfin_bf54x_driver_init(void)\r\n{\r\nreturn platform_driver_register(&bfin_bf54x_driver);\r\n}\r\nstatic void __exit bfin_bf54x_driver_cleanup(void)\r\n{\r\nplatform_driver_unregister(&bfin_bf54x_driver);\r\n}
