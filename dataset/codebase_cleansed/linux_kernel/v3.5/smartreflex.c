static inline void sr_write_reg(struct omap_sr *sr, unsigned offset, u32 value)\r\n{\r\n__raw_writel(value, (sr->base + offset));\r\n}\r\nstatic inline void sr_modify_reg(struct omap_sr *sr, unsigned offset, u32 mask,\r\nu32 value)\r\n{\r\nu32 reg_val;\r\nif (sr->ip_type == SR_TYPE_V1 && offset == ERRCONFIG_V1)\r\nmask |= ERRCONFIG_STATUS_V1_MASK;\r\nelse if (sr->ip_type == SR_TYPE_V2 && offset == ERRCONFIG_V2)\r\nmask |= ERRCONFIG_VPBOUNDINTST_V2;\r\nreg_val = __raw_readl(sr->base + offset);\r\nreg_val &= ~mask;\r\nvalue &= mask;\r\nreg_val |= value;\r\n__raw_writel(reg_val, (sr->base + offset));\r\n}\r\nstatic inline u32 sr_read_reg(struct omap_sr *sr, unsigned offset)\r\n{\r\nreturn __raw_readl(sr->base + offset);\r\n}\r\nstatic struct omap_sr *_sr_lookup(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_sr *sr_info;\r\nif (!voltdm) {\r\npr_err("%s: Null voltage domain passed!\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nlist_for_each_entry(sr_info, &sr_list, node) {\r\nif (voltdm == sr_info->voltdm)\r\nreturn sr_info;\r\n}\r\nreturn ERR_PTR(-ENODATA);\r\n}\r\nstatic irqreturn_t sr_interrupt(int irq, void *data)\r\n{\r\nstruct omap_sr *sr_info = data;\r\nu32 status = 0;\r\nswitch (sr_info->ip_type) {\r\ncase SR_TYPE_V1:\r\nstatus = sr_read_reg(sr_info, ERRCONFIG_V1);\r\nsr_write_reg(sr_info, ERRCONFIG_V1, status);\r\nbreak;\r\ncase SR_TYPE_V2:\r\nstatus = sr_read_reg(sr_info, IRQSTATUS);\r\nsr_write_reg(sr_info, IRQSTATUS, status);\r\nbreak;\r\ndefault:\r\ndev_err(&sr_info->pdev->dev, "UNKNOWN IP type %d\n",\r\nsr_info->ip_type);\r\nreturn IRQ_NONE;\r\n}\r\nif (sr_class->notify)\r\nsr_class->notify(sr_info->voltdm, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sr_set_clk_length(struct omap_sr *sr)\r\n{\r\nstruct clk *sys_ck;\r\nu32 sys_clk_speed;\r\nif (cpu_is_omap34xx())\r\nsys_ck = clk_get(NULL, "sys_ck");\r\nelse\r\nsys_ck = clk_get(NULL, "sys_clkin_ck");\r\nif (IS_ERR(sys_ck)) {\r\ndev_err(&sr->pdev->dev, "%s: unable to get sys clk\n",\r\n__func__);\r\nreturn;\r\n}\r\nsys_clk_speed = clk_get_rate(sys_ck);\r\nclk_put(sys_ck);\r\nswitch (sys_clk_speed) {\r\ncase 12000000:\r\nsr->clk_length = SRCLKLENGTH_12MHZ_SYSCLK;\r\nbreak;\r\ncase 13000000:\r\nsr->clk_length = SRCLKLENGTH_13MHZ_SYSCLK;\r\nbreak;\r\ncase 19200000:\r\nsr->clk_length = SRCLKLENGTH_19MHZ_SYSCLK;\r\nbreak;\r\ncase 26000000:\r\nsr->clk_length = SRCLKLENGTH_26MHZ_SYSCLK;\r\nbreak;\r\ncase 38400000:\r\nsr->clk_length = SRCLKLENGTH_38MHZ_SYSCLK;\r\nbreak;\r\ndefault:\r\ndev_err(&sr->pdev->dev, "%s: Invalid sysclk value: %d\n",\r\n__func__, sys_clk_speed);\r\nbreak;\r\n}\r\n}\r\nstatic void sr_set_regfields(struct omap_sr *sr)\r\n{\r\nif (cpu_is_omap34xx() || cpu_is_omap44xx()) {\r\nsr->err_weight = OMAP3430_SR_ERRWEIGHT;\r\nsr->err_maxlimit = OMAP3430_SR_ERRMAXLIMIT;\r\nsr->accum_data = OMAP3430_SR_ACCUMDATA;\r\nif (!(strcmp(sr->voltdm->name, "mpu"))) {\r\nsr->senn_avgweight = OMAP3430_SR1_SENNAVGWEIGHT;\r\nsr->senp_avgweight = OMAP3430_SR1_SENPAVGWEIGHT;\r\n} else {\r\nsr->senn_avgweight = OMAP3430_SR2_SENNAVGWEIGHT;\r\nsr->senp_avgweight = OMAP3430_SR2_SENPAVGWEIGHT;\r\n}\r\n}\r\n}\r\nstatic void sr_start_vddautocomp(struct omap_sr *sr)\r\n{\r\nif (!sr_class || !(sr_class->enable) || !(sr_class->configure)) {\r\ndev_warn(&sr->pdev->dev,\r\n"%s: smartreflex class driver not registered\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (!sr_class->enable(sr->voltdm))\r\nsr->autocomp_active = true;\r\n}\r\nstatic void sr_stop_vddautocomp(struct omap_sr *sr)\r\n{\r\nif (!sr_class || !(sr_class->disable)) {\r\ndev_warn(&sr->pdev->dev,\r\n"%s: smartreflex class driver not registered\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (sr->autocomp_active) {\r\nsr_class->disable(sr->voltdm, 1);\r\nsr->autocomp_active = false;\r\n}\r\n}\r\nstatic int sr_late_init(struct omap_sr *sr_info)\r\n{\r\nchar *name;\r\nstruct omap_sr_data *pdata = sr_info->pdev->dev.platform_data;\r\nstruct resource *mem;\r\nint ret = 0;\r\nif (sr_class->notify && sr_class->notify_flags && sr_info->irq) {\r\nname = kasprintf(GFP_KERNEL, "sr_%s", sr_info->voltdm->name);\r\nif (name == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nret = request_irq(sr_info->irq, sr_interrupt,\r\n0, name, sr_info);\r\nif (ret)\r\ngoto error;\r\ndisable_irq(sr_info->irq);\r\n}\r\nif (pdata && pdata->enable_on_init)\r\nsr_start_vddautocomp(sr_info);\r\nreturn ret;\r\nerror:\r\niounmap(sr_info->base);\r\nmem = platform_get_resource(sr_info->pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nlist_del(&sr_info->node);\r\ndev_err(&sr_info->pdev->dev, "%s: ERROR in registering"\r\n"interrupt handler. Smartreflex will"\r\n"not function as desired\n", __func__);\r\nkfree(name);\r\nkfree(sr_info);\r\nreturn ret;\r\n}\r\nstatic void sr_v1_disable(struct omap_sr *sr)\r\n{\r\nint timeout = 0;\r\nint errconf_val = ERRCONFIG_MCUACCUMINTST | ERRCONFIG_MCUVALIDINTST |\r\nERRCONFIG_MCUBOUNDINTST;\r\nsr_modify_reg(sr, ERRCONFIG_V1,\r\nERRCONFIG_MCUDISACKINTEN, ERRCONFIG_MCUDISACKINTEN);\r\nsr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, 0x0);\r\nif (sr_read_reg(sr, ERRCONFIG_V1) & ERRCONFIG_VPBOUNDINTST_V1)\r\nerrconf_val |= ERRCONFIG_VPBOUNDINTST_V1;\r\nsr_modify_reg(sr, ERRCONFIG_V1,\r\n(ERRCONFIG_MCUACCUMINTEN | ERRCONFIG_MCUVALIDINTEN |\r\nERRCONFIG_MCUBOUNDINTEN | ERRCONFIG_VPBOUNDINTEN_V1),\r\nerrconf_val);\r\nomap_test_timeout((sr_read_reg(sr, ERRCONFIG_V1) &\r\nERRCONFIG_MCUDISACKINTST), SR_DISABLE_TIMEOUT,\r\ntimeout);\r\nif (timeout >= SR_DISABLE_TIMEOUT)\r\ndev_warn(&sr->pdev->dev, "%s: Smartreflex disable timedout\n",\r\n__func__);\r\nsr_modify_reg(sr, ERRCONFIG_V1, ERRCONFIG_MCUDISACKINTEN,\r\nERRCONFIG_MCUDISACKINTST);\r\n}\r\nstatic void sr_v2_disable(struct omap_sr *sr)\r\n{\r\nint timeout = 0;\r\nsr_write_reg(sr, IRQENABLE_SET, IRQENABLE_MCUDISABLEACKINT);\r\nsr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, 0x0);\r\nif (sr_read_reg(sr, ERRCONFIG_V2) & ERRCONFIG_VPBOUNDINTST_V2)\r\nsr_modify_reg(sr, ERRCONFIG_V2, ERRCONFIG_VPBOUNDINTEN_V2,\r\nERRCONFIG_VPBOUNDINTST_V2);\r\nelse\r\nsr_modify_reg(sr, ERRCONFIG_V2, ERRCONFIG_VPBOUNDINTEN_V2,\r\n0x0);\r\nsr_write_reg(sr, IRQENABLE_CLR, (IRQENABLE_MCUACCUMINT |\r\nIRQENABLE_MCUVALIDINT |\r\nIRQENABLE_MCUBOUNDSINT));\r\nsr_write_reg(sr, IRQSTATUS, (IRQSTATUS_MCUACCUMINT |\r\nIRQSTATUS_MCVALIDINT |\r\nIRQSTATUS_MCBOUNDSINT));\r\nomap_test_timeout((sr_read_reg(sr, IRQSTATUS) &\r\nIRQSTATUS_MCUDISABLEACKINT), SR_DISABLE_TIMEOUT,\r\ntimeout);\r\nif (timeout >= SR_DISABLE_TIMEOUT)\r\ndev_warn(&sr->pdev->dev, "%s: Smartreflex disable timedout\n",\r\n__func__);\r\nsr_write_reg(sr, IRQENABLE_CLR, IRQENABLE_MCUDISABLEACKINT);\r\nsr_write_reg(sr, IRQSTATUS, IRQSTATUS_MCUDISABLEACKINT);\r\n}\r\nstatic u32 sr_retrieve_nvalue(struct omap_sr *sr, u32 efuse_offs)\r\n{\r\nint i;\r\nif (!sr->nvalue_table) {\r\ndev_warn(&sr->pdev->dev, "%s: Missing ntarget value table\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < sr->nvalue_count; i++) {\r\nif (sr->nvalue_table[i].efuse_offs == efuse_offs)\r\nreturn sr->nvalue_table[i].nvalue;\r\n}\r\nreturn 0;\r\n}\r\nint sr_configure_errgen(struct voltagedomain *voltdm)\r\n{\r\nu32 sr_config, sr_errconfig, errconfig_offs;\r\nu32 vpboundint_en, vpboundint_st;\r\nu32 senp_en = 0, senn_en = 0;\r\nu8 senp_shift, senn_shift;\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn PTR_ERR(sr);\r\n}\r\nif (!sr->clk_length)\r\nsr_set_clk_length(sr);\r\nsenp_en = sr->senp_mod;\r\nsenn_en = sr->senn_mod;\r\nsr_config = (sr->clk_length << SRCONFIG_SRCLKLENGTH_SHIFT) |\r\nSRCONFIG_SENENABLE | SRCONFIG_ERRGEN_EN;\r\nswitch (sr->ip_type) {\r\ncase SR_TYPE_V1:\r\nsr_config |= SRCONFIG_DELAYCTRL;\r\nsenn_shift = SRCONFIG_SENNENABLE_V1_SHIFT;\r\nsenp_shift = SRCONFIG_SENPENABLE_V1_SHIFT;\r\nerrconfig_offs = ERRCONFIG_V1;\r\nvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V1;\r\nvpboundint_st = ERRCONFIG_VPBOUNDINTST_V1;\r\nbreak;\r\ncase SR_TYPE_V2:\r\nsenn_shift = SRCONFIG_SENNENABLE_V2_SHIFT;\r\nsenp_shift = SRCONFIG_SENPENABLE_V2_SHIFT;\r\nerrconfig_offs = ERRCONFIG_V2;\r\nvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V2;\r\nvpboundint_st = ERRCONFIG_VPBOUNDINTST_V2;\r\nbreak;\r\ndefault:\r\ndev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"\r\n"module without specifying the ip\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nsr_config |= ((senn_en << senn_shift) | (senp_en << senp_shift));\r\nsr_write_reg(sr, SRCONFIG, sr_config);\r\nsr_errconfig = (sr->err_weight << ERRCONFIG_ERRWEIGHT_SHIFT) |\r\n(sr->err_maxlimit << ERRCONFIG_ERRMAXLIMIT_SHIFT) |\r\n(sr->err_minlimit << ERRCONFIG_ERRMINLIMIT_SHIFT);\r\nsr_modify_reg(sr, errconfig_offs, (SR_ERRWEIGHT_MASK |\r\nSR_ERRMAXLIMIT_MASK | SR_ERRMINLIMIT_MASK),\r\nsr_errconfig);\r\nsr_modify_reg(sr, errconfig_offs, (vpboundint_en | vpboundint_st),\r\nvpboundint_en);\r\nreturn 0;\r\n}\r\nint sr_disable_errgen(struct voltagedomain *voltdm)\r\n{\r\nu32 errconfig_offs;\r\nu32 vpboundint_en, vpboundint_st;\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn PTR_ERR(sr);\r\n}\r\nswitch (sr->ip_type) {\r\ncase SR_TYPE_V1:\r\nerrconfig_offs = ERRCONFIG_V1;\r\nvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V1;\r\nvpboundint_st = ERRCONFIG_VPBOUNDINTST_V1;\r\nbreak;\r\ncase SR_TYPE_V2:\r\nerrconfig_offs = ERRCONFIG_V2;\r\nvpboundint_en = ERRCONFIG_VPBOUNDINTEN_V2;\r\nvpboundint_st = ERRCONFIG_VPBOUNDINTST_V2;\r\nbreak;\r\ndefault:\r\ndev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"\r\n"module without specifying the ip\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nsr_modify_reg(sr, errconfig_offs, vpboundint_en | vpboundint_st, 0);\r\nsr_modify_reg(sr, SRCONFIG, SRCONFIG_SENENABLE | SRCONFIG_ERRGEN_EN, 0);\r\nreturn 0;\r\n}\r\nint sr_configure_minmax(struct voltagedomain *voltdm)\r\n{\r\nu32 sr_config, sr_avgwt;\r\nu32 senp_en = 0, senn_en = 0;\r\nu8 senp_shift, senn_shift;\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn PTR_ERR(sr);\r\n}\r\nif (!sr->clk_length)\r\nsr_set_clk_length(sr);\r\nsenp_en = sr->senp_mod;\r\nsenn_en = sr->senn_mod;\r\nsr_config = (sr->clk_length << SRCONFIG_SRCLKLENGTH_SHIFT) |\r\nSRCONFIG_SENENABLE |\r\n(sr->accum_data << SRCONFIG_ACCUMDATA_SHIFT);\r\nswitch (sr->ip_type) {\r\ncase SR_TYPE_V1:\r\nsr_config |= SRCONFIG_DELAYCTRL;\r\nsenn_shift = SRCONFIG_SENNENABLE_V1_SHIFT;\r\nsenp_shift = SRCONFIG_SENPENABLE_V1_SHIFT;\r\nbreak;\r\ncase SR_TYPE_V2:\r\nsenn_shift = SRCONFIG_SENNENABLE_V2_SHIFT;\r\nsenp_shift = SRCONFIG_SENPENABLE_V2_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"\r\n"module without specifying the ip\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nsr_config |= ((senn_en << senn_shift) | (senp_en << senp_shift));\r\nsr_write_reg(sr, SRCONFIG, sr_config);\r\nsr_avgwt = (sr->senp_avgweight << AVGWEIGHT_SENPAVGWEIGHT_SHIFT) |\r\n(sr->senn_avgweight << AVGWEIGHT_SENNAVGWEIGHT_SHIFT);\r\nsr_write_reg(sr, AVGWEIGHT, sr_avgwt);\r\nswitch (sr->ip_type) {\r\ncase SR_TYPE_V1:\r\nsr_modify_reg(sr, ERRCONFIG_V1,\r\n(ERRCONFIG_MCUACCUMINTEN | ERRCONFIG_MCUVALIDINTEN |\r\nERRCONFIG_MCUBOUNDINTEN),\r\n(ERRCONFIG_MCUACCUMINTEN | ERRCONFIG_MCUACCUMINTST |\r\nERRCONFIG_MCUVALIDINTEN | ERRCONFIG_MCUVALIDINTST |\r\nERRCONFIG_MCUBOUNDINTEN | ERRCONFIG_MCUBOUNDINTST));\r\nbreak;\r\ncase SR_TYPE_V2:\r\nsr_write_reg(sr, IRQSTATUS,\r\nIRQSTATUS_MCUACCUMINT | IRQSTATUS_MCVALIDINT |\r\nIRQSTATUS_MCBOUNDSINT | IRQSTATUS_MCUDISABLEACKINT);\r\nsr_write_reg(sr, IRQENABLE_SET,\r\nIRQENABLE_MCUACCUMINT | IRQENABLE_MCUVALIDINT |\r\nIRQENABLE_MCUBOUNDSINT | IRQENABLE_MCUDISABLEACKINT);\r\nbreak;\r\ndefault:\r\ndev_err(&sr->pdev->dev, "%s: Trying to Configure smartreflex"\r\n"module without specifying the ip\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint sr_enable(struct voltagedomain *voltdm, unsigned long volt)\r\n{\r\nstruct omap_volt_data *volt_data;\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nu32 nvalue_reciprocal;\r\nint ret;\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn PTR_ERR(sr);\r\n}\r\nvolt_data = omap_voltage_get_voltdata(sr->voltdm, volt);\r\nif (IS_ERR(volt_data)) {\r\ndev_warn(&sr->pdev->dev, "%s: Unable to get voltage table"\r\n"for nominal voltage %ld\n", __func__, volt);\r\nreturn PTR_ERR(volt_data);\r\n}\r\nnvalue_reciprocal = sr_retrieve_nvalue(sr, volt_data->sr_efuse_offs);\r\nif (!nvalue_reciprocal) {\r\ndev_warn(&sr->pdev->dev, "%s: NVALUE = 0 at voltage %ld\n",\r\n__func__, volt);\r\nreturn -ENODATA;\r\n}\r\nsr->err_minlimit = volt_data->sr_errminlimit;\r\npm_runtime_get_sync(&sr->pdev->dev);\r\nif (sr_read_reg(sr, SRCONFIG) & SRCONFIG_SRENABLE)\r\nreturn 0;\r\nret = sr_class->configure(voltdm);\r\nif (ret)\r\nreturn ret;\r\nsr_write_reg(sr, NVALUERECIPROCAL, nvalue_reciprocal);\r\nsr_modify_reg(sr, SRCONFIG, SRCONFIG_SRENABLE, SRCONFIG_SRENABLE);\r\nreturn 0;\r\n}\r\nvoid sr_disable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (pm_runtime_suspended(&sr->pdev->dev))\r\nreturn;\r\nif (sr_read_reg(sr, SRCONFIG) & SRCONFIG_SRENABLE) {\r\nswitch (sr->ip_type) {\r\ncase SR_TYPE_V1:\r\nsr_v1_disable(sr);\r\nbreak;\r\ncase SR_TYPE_V2:\r\nsr_v2_disable(sr);\r\nbreak;\r\ndefault:\r\ndev_err(&sr->pdev->dev, "UNKNOWN IP type %d\n",\r\nsr->ip_type);\r\n}\r\n}\r\npm_runtime_put_sync_suspend(&sr->pdev->dev);\r\n}\r\nint sr_register_class(struct omap_sr_class_data *class_data)\r\n{\r\nstruct omap_sr *sr_info;\r\nif (!class_data) {\r\npr_warning("%s:, Smartreflex class data passed is NULL\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (sr_class) {\r\npr_warning("%s: Smartreflex class driver already registered\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nsr_class = class_data;\r\nlist_for_each_entry(sr_info, &sr_list, node)\r\nsr_late_init(sr_info);\r\nreturn 0;\r\n}\r\nvoid omap_sr_enable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!sr->autocomp_active)\r\nreturn;\r\nif (!sr_class || !(sr_class->enable) || !(sr_class->configure)) {\r\ndev_warn(&sr->pdev->dev, "%s: smartreflex class driver not"\r\n"registered\n", __func__);\r\nreturn;\r\n}\r\nsr_class->enable(voltdm);\r\n}\r\nvoid omap_sr_disable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!sr->autocomp_active)\r\nreturn;\r\nif (!sr_class || !(sr_class->disable)) {\r\ndev_warn(&sr->pdev->dev, "%s: smartreflex class driver not"\r\n"registered\n", __func__);\r\nreturn;\r\n}\r\nsr_class->disable(voltdm, 0);\r\n}\r\nvoid omap_sr_disable_reset_volt(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_sr *sr = _sr_lookup(voltdm);\r\nif (IS_ERR(sr)) {\r\npr_warning("%s: omap_sr struct for sr_%s not found\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!sr->autocomp_active)\r\nreturn;\r\nif (!sr_class || !(sr_class->disable)) {\r\ndev_warn(&sr->pdev->dev, "%s: smartreflex class driver not"\r\n"registered\n", __func__);\r\nreturn;\r\n}\r\nsr_class->disable(voltdm, 1);\r\n}\r\nvoid omap_sr_register_pmic(struct omap_sr_pmic_data *pmic_data)\r\n{\r\nif (!pmic_data) {\r\npr_warning("%s: Trying to register NULL PMIC data structure"\r\n"with smartreflex\n", __func__);\r\nreturn;\r\n}\r\nsr_pmic_data = pmic_data;\r\n}\r\nstatic int omap_sr_autocomp_show(void *data, u64 *val)\r\n{\r\nstruct omap_sr *sr_info = data;\r\nif (!sr_info) {\r\npr_warning("%s: omap_sr struct not found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n*val = sr_info->autocomp_active;\r\nreturn 0;\r\n}\r\nstatic int omap_sr_autocomp_store(void *data, u64 val)\r\n{\r\nstruct omap_sr *sr_info = data;\r\nif (!sr_info) {\r\npr_warning("%s: omap_sr struct not found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (val > 1) {\r\npr_warning("%s: Invalid argument %lld\n", __func__, val);\r\nreturn -EINVAL;\r\n}\r\nif (sr_info->autocomp_active != val) {\r\nif (!val)\r\nsr_stop_vddautocomp(sr_info);\r\nelse\r\nsr_start_vddautocomp(sr_info);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init omap_sr_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_sr *sr_info;\r\nstruct omap_sr_data *pdata = pdev->dev.platform_data;\r\nstruct resource *mem, *irq;\r\nstruct dentry *nvalue_dir;\r\nstruct omap_volt_data *volt_data;\r\nint i, ret = 0;\r\nchar *name;\r\nsr_info = kzalloc(sizeof(struct omap_sr), GFP_KERNEL);\r\nif (!sr_info) {\r\ndev_err(&pdev->dev, "%s: unable to allocate sr_info\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, sr_info);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "%s: platform data missing\n", __func__);\r\nret = -EINVAL;\r\ngoto err_free_devinfo;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "%s: no mem resource\n", __func__);\r\nret = -ENODEV;\r\ngoto err_free_devinfo;\r\n}\r\nmem = request_mem_region(mem->start, resource_size(mem),\r\ndev_name(&pdev->dev));\r\nif (!mem) {\r\ndev_err(&pdev->dev, "%s: no mem region\n", __func__);\r\nret = -EBUSY;\r\ngoto err_free_devinfo;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_irq_safe(&pdev->dev);\r\nsr_info->pdev = pdev;\r\nsr_info->srid = pdev->id;\r\nsr_info->voltdm = pdata->voltdm;\r\nsr_info->nvalue_table = pdata->nvalue_table;\r\nsr_info->nvalue_count = pdata->nvalue_count;\r\nsr_info->senn_mod = pdata->senn_mod;\r\nsr_info->senp_mod = pdata->senp_mod;\r\nsr_info->autocomp_active = false;\r\nsr_info->ip_type = pdata->ip_type;\r\nsr_info->base = ioremap(mem->start, resource_size(mem));\r\nif (!sr_info->base) {\r\ndev_err(&pdev->dev, "%s: ioremap fail\n", __func__);\r\nret = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\nif (irq)\r\nsr_info->irq = irq->start;\r\nsr_set_clk_length(sr_info);\r\nsr_set_regfields(sr_info);\r\nlist_add(&sr_info->node, &sr_list);\r\nif (sr_class) {\r\nret = sr_late_init(sr_info);\r\nif (ret) {\r\npr_warning("%s: Error in SR late init\n", __func__);\r\ngoto err_iounmap;\r\n}\r\n}\r\ndev_info(&pdev->dev, "%s: SmartReflex driver initialized\n", __func__);\r\nif (!sr_dbg_dir) {\r\nsr_dbg_dir = debugfs_create_dir("smartreflex", NULL);\r\nif (IS_ERR_OR_NULL(sr_dbg_dir)) {\r\nret = PTR_ERR(sr_dbg_dir);\r\npr_err("%s:sr debugfs dir creation failed(%d)\n",\r\n__func__, ret);\r\ngoto err_iounmap;\r\n}\r\n}\r\nname = kasprintf(GFP_KERNEL, "sr_%s", sr_info->voltdm->name);\r\nif (!name) {\r\ndev_err(&pdev->dev, "%s: Unable to alloc debugfs name\n",\r\n__func__);\r\nret = -ENOMEM;\r\ngoto err_iounmap;\r\n}\r\nsr_info->dbg_dir = debugfs_create_dir(name, sr_dbg_dir);\r\nkfree(name);\r\nif (IS_ERR_OR_NULL(sr_info->dbg_dir)) {\r\ndev_err(&pdev->dev, "%s: Unable to create debugfs directory\n",\r\n__func__);\r\nret = PTR_ERR(sr_info->dbg_dir);\r\ngoto err_iounmap;\r\n}\r\n(void) debugfs_create_file("autocomp", S_IRUGO | S_IWUSR,\r\nsr_info->dbg_dir, (void *)sr_info, &pm_sr_fops);\r\n(void) debugfs_create_x32("errweight", S_IRUGO, sr_info->dbg_dir,\r\n&sr_info->err_weight);\r\n(void) debugfs_create_x32("errmaxlimit", S_IRUGO, sr_info->dbg_dir,\r\n&sr_info->err_maxlimit);\r\n(void) debugfs_create_x32("errminlimit", S_IRUGO, sr_info->dbg_dir,\r\n&sr_info->err_minlimit);\r\nnvalue_dir = debugfs_create_dir("nvalue", sr_info->dbg_dir);\r\nif (IS_ERR_OR_NULL(nvalue_dir)) {\r\ndev_err(&pdev->dev, "%s: Unable to create debugfs directory"\r\n"for n-values\n", __func__);\r\nret = PTR_ERR(nvalue_dir);\r\ngoto err_debugfs;\r\n}\r\nomap_voltage_get_volttable(sr_info->voltdm, &volt_data);\r\nif (!volt_data) {\r\ndev_warn(&pdev->dev, "%s: No Voltage table for the"\r\n" corresponding vdd vdd_%s. Cannot create debugfs"\r\n"entries for n-values\n",\r\n__func__, sr_info->voltdm->name);\r\nret = -ENODATA;\r\ngoto err_debugfs;\r\n}\r\nfor (i = 0; i < sr_info->nvalue_count; i++) {\r\nchar name[NVALUE_NAME_LEN + 1];\r\nsnprintf(name, sizeof(name), "volt_%d",\r\nvolt_data[i].volt_nominal);\r\n(void) debugfs_create_x32(name, S_IRUGO | S_IWUSR, nvalue_dir,\r\n&(sr_info->nvalue_table[i].nvalue));\r\n}\r\nreturn ret;\r\nerr_debugfs:\r\ndebugfs_remove_recursive(sr_info->dbg_dir);\r\nerr_iounmap:\r\nlist_del(&sr_info->node);\r\niounmap(sr_info->base);\r\nerr_release_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nerr_free_devinfo:\r\nkfree(sr_info);\r\nreturn ret;\r\n}\r\nstatic int __devexit omap_sr_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_sr_data *pdata = pdev->dev.platform_data;\r\nstruct omap_sr *sr_info;\r\nstruct resource *mem;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "%s: platform data missing\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nsr_info = _sr_lookup(pdata->voltdm);\r\nif (IS_ERR(sr_info)) {\r\ndev_warn(&pdev->dev, "%s: omap_sr struct not found\n",\r\n__func__);\r\nreturn PTR_ERR(sr_info);\r\n}\r\nif (sr_info->autocomp_active)\r\nsr_stop_vddautocomp(sr_info);\r\nif (sr_info->dbg_dir)\r\ndebugfs_remove_recursive(sr_info->dbg_dir);\r\nlist_del(&sr_info->node);\r\niounmap(sr_info->base);\r\nkfree(sr_info);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn 0;\r\n}\r\nstatic void __devexit omap_sr_shutdown(struct platform_device *pdev)\r\n{\r\nstruct omap_sr_data *pdata = pdev->dev.platform_data;\r\nstruct omap_sr *sr_info;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "%s: platform data missing\n", __func__);\r\nreturn;\r\n}\r\nsr_info = _sr_lookup(pdata->voltdm);\r\nif (IS_ERR(sr_info)) {\r\ndev_warn(&pdev->dev, "%s: omap_sr struct not found\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (sr_info->autocomp_active)\r\nsr_stop_vddautocomp(sr_info);\r\nreturn;\r\n}\r\nstatic int __init sr_init(void)\r\n{\r\nint ret = 0;\r\nif (sr_pmic_data && sr_pmic_data->sr_pmic_init)\r\nsr_pmic_data->sr_pmic_init();\r\nelse\r\npr_warning("%s: No PMIC hook to init smartreflex\n", __func__);\r\nret = platform_driver_probe(&smartreflex_driver, omap_sr_probe);\r\nif (ret) {\r\npr_err("%s: platform driver register failed for SR\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit sr_exit(void)\r\n{\r\nplatform_driver_unregister(&smartreflex_driver);\r\n}
