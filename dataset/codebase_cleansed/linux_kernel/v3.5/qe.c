phys_addr_t get_qe_base(void)\r\n{\r\nstruct device_node *qe;\r\nint size;\r\nconst u32 *prop;\r\nif (qebase != -1)\r\nreturn qebase;\r\nqe = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!qe) {\r\nqe = of_find_node_by_type(NULL, "qe");\r\nif (!qe)\r\nreturn qebase;\r\n}\r\nprop = of_get_property(qe, "reg", &size);\r\nif (prop && size >= sizeof(*prop))\r\nqebase = of_translate_address(qe, prop);\r\nof_node_put(qe);\r\nreturn qebase;\r\n}\r\nvoid qe_reset(void)\r\n{\r\nif (qe_immr == NULL)\r\nqe_immr = ioremap(get_qe_base(), QE_IMMAP_SIZE);\r\nqe_snums_init();\r\nqe_issue_cmd(QE_RESET, QE_CR_SUBBLOCK_INVALID,\r\nQE_CR_PROTOCOL_UNSPECIFIED, 0);\r\nqe_muram_init();\r\nif (qe_sdma_init())\r\npanic("sdma init failed!");\r\n}\r\nint qe_issue_cmd(u32 cmd, u32 device, u8 mcn_protocol, u32 cmd_input)\r\n{\r\nunsigned long flags;\r\nu8 mcn_shift = 0, dev_shift = 0;\r\nu32 ret;\r\nspin_lock_irqsave(&qe_lock, flags);\r\nif (cmd == QE_RESET) {\r\nout_be32(&qe_immr->cp.cecr, (u32) (cmd | QE_CR_FLG));\r\n} else {\r\nif (cmd == QE_ASSIGN_PAGE) {\r\ndev_shift = QE_CR_SNUM_SHIFT;\r\n} else if (cmd == QE_ASSIGN_RISC) {\r\ndev_shift = QE_CR_SNUM_SHIFT;\r\nmcn_shift = QE_CR_MCN_RISC_ASSIGN_SHIFT;\r\n} else {\r\nif (device == QE_CR_SUBBLOCK_USB)\r\nmcn_shift = QE_CR_MCN_USB_SHIFT;\r\nelse\r\nmcn_shift = QE_CR_MCN_NORMAL_SHIFT;\r\n}\r\nout_be32(&qe_immr->cp.cecdr, cmd_input);\r\nout_be32(&qe_immr->cp.cecr,\r\n(cmd | QE_CR_FLG | ((u32) device << dev_shift) | (u32)\r\nmcn_protocol << mcn_shift));\r\n}\r\nret = spin_event_timeout((in_be32(&qe_immr->cp.cecr) & QE_CR_FLG) == 0,\r\n100, 0);\r\nspin_unlock_irqrestore(&qe_lock, flags);\r\nreturn ret == 1;\r\n}\r\nunsigned int qe_get_brg_clk(void)\r\n{\r\nstruct device_node *qe;\r\nint size;\r\nconst u32 *prop;\r\nif (brg_clk)\r\nreturn brg_clk;\r\nqe = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!qe) {\r\nqe = of_find_node_by_type(NULL, "qe");\r\nif (!qe)\r\nreturn brg_clk;\r\n}\r\nprop = of_get_property(qe, "brg-frequency", &size);\r\nif (prop && size == sizeof(*prop))\r\nbrg_clk = *prop;\r\nof_node_put(qe);\r\nreturn brg_clk;\r\n}\r\nint qe_setbrg(enum qe_clock brg, unsigned int rate, unsigned int multiplier)\r\n{\r\nu32 divisor, tempval;\r\nu32 div16 = 0;\r\nif ((brg < QE_BRG1) || (brg > QE_BRG16))\r\nreturn -EINVAL;\r\ndivisor = qe_get_brg_clk() / (rate * multiplier);\r\nif (divisor > QE_BRGC_DIVISOR_MAX + 1) {\r\ndiv16 = QE_BRGC_DIV16;\r\ndivisor /= 16;\r\n}\r\nif (!div16 && (divisor & 1) && (divisor > 3))\r\ndivisor++;\r\ntempval = ((divisor - 1) << QE_BRGC_DIVISOR_SHIFT) |\r\nQE_BRGC_ENABLE | div16;\r\nout_be32(&qe_immr->brg.brgc[brg - QE_BRG1], tempval);\r\nreturn 0;\r\n}\r\nenum qe_clock qe_clock_source(const char *source)\r\n{\r\nunsigned int i;\r\nif (strcasecmp(source, "none") == 0)\r\nreturn QE_CLK_NONE;\r\nif (strncasecmp(source, "brg", 3) == 0) {\r\ni = simple_strtoul(source + 3, NULL, 10);\r\nif ((i >= 1) && (i <= 16))\r\nreturn (QE_BRG1 - 1) + i;\r\nelse\r\nreturn QE_CLK_DUMMY;\r\n}\r\nif (strncasecmp(source, "clk", 3) == 0) {\r\ni = simple_strtoul(source + 3, NULL, 10);\r\nif ((i >= 1) && (i <= 24))\r\nreturn (QE_CLK1 - 1) + i;\r\nelse\r\nreturn QE_CLK_DUMMY;\r\n}\r\nreturn QE_CLK_DUMMY;\r\n}\r\nstatic void qe_snums_init(void)\r\n{\r\nint i;\r\nstatic const u8 snum_init_76[] = {\r\n0x04, 0x05, 0x0C, 0x0D, 0x14, 0x15, 0x1C, 0x1D,\r\n0x24, 0x25, 0x2C, 0x2D, 0x34, 0x35, 0x88, 0x89,\r\n0x98, 0x99, 0xA8, 0xA9, 0xB8, 0xB9, 0xC8, 0xC9,\r\n0xD8, 0xD9, 0xE8, 0xE9, 0x44, 0x45, 0x4C, 0x4D,\r\n0x54, 0x55, 0x5C, 0x5D, 0x64, 0x65, 0x6C, 0x6D,\r\n0x74, 0x75, 0x7C, 0x7D, 0x84, 0x85, 0x8C, 0x8D,\r\n0x94, 0x95, 0x9C, 0x9D, 0xA4, 0xA5, 0xAC, 0xAD,\r\n0xB4, 0xB5, 0xBC, 0xBD, 0xC4, 0xC5, 0xCC, 0xCD,\r\n0xD4, 0xD5, 0xDC, 0xDD, 0xE4, 0xE5, 0xEC, 0xED,\r\n0xF4, 0xF5, 0xFC, 0xFD,\r\n};\r\nstatic const u8 snum_init_46[] = {\r\n0x04, 0x05, 0x0C, 0x0D, 0x14, 0x15, 0x1C, 0x1D,\r\n0x24, 0x25, 0x2C, 0x2D, 0x34, 0x35, 0x88, 0x89,\r\n0x98, 0x99, 0xA8, 0xA9, 0xB8, 0xB9, 0xC8, 0xC9,\r\n0xD8, 0xD9, 0xE8, 0xE9, 0x08, 0x09, 0x18, 0x19,\r\n0x28, 0x29, 0x38, 0x39, 0x48, 0x49, 0x58, 0x59,\r\n0x68, 0x69, 0x78, 0x79, 0x80, 0x81,\r\n};\r\nstatic const u8 *snum_init;\r\nqe_num_of_snum = qe_get_num_of_snums();\r\nif (qe_num_of_snum == 76)\r\nsnum_init = snum_init_76;\r\nelse\r\nsnum_init = snum_init_46;\r\nfor (i = 0; i < qe_num_of_snum; i++) {\r\nsnums[i].num = snum_init[i];\r\nsnums[i].state = QE_SNUM_STATE_FREE;\r\n}\r\n}\r\nint qe_get_snum(void)\r\n{\r\nunsigned long flags;\r\nint snum = -EBUSY;\r\nint i;\r\nspin_lock_irqsave(&qe_lock, flags);\r\nfor (i = 0; i < qe_num_of_snum; i++) {\r\nif (snums[i].state == QE_SNUM_STATE_FREE) {\r\nsnums[i].state = QE_SNUM_STATE_USED;\r\nsnum = snums[i].num;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&qe_lock, flags);\r\nreturn snum;\r\n}\r\nvoid qe_put_snum(u8 snum)\r\n{\r\nint i;\r\nfor (i = 0; i < qe_num_of_snum; i++) {\r\nif (snums[i].num == snum) {\r\nsnums[i].state = QE_SNUM_STATE_FREE;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int qe_sdma_init(void)\r\n{\r\nstruct sdma __iomem *sdma = &qe_immr->sdma;\r\nstatic unsigned long sdma_buf_offset = (unsigned long)-ENOMEM;\r\nif (!sdma)\r\nreturn -ENODEV;\r\nif (IS_ERR_VALUE(sdma_buf_offset)) {\r\nsdma_buf_offset = qe_muram_alloc(512 * 2, 4096);\r\nif (IS_ERR_VALUE(sdma_buf_offset))\r\nreturn -ENOMEM;\r\n}\r\nout_be32(&sdma->sdebcr, (u32) sdma_buf_offset & QE_SDEBCR_BA_MASK);\r\nout_be32(&sdma->sdmr, (QE_SDMR_GLB_1_MSK |\r\n(0x1 << QE_SDMR_CEN_SHIFT)));\r\nreturn 0;\r\n}\r\nstatic void qe_upload_microcode(const void *base,\r\nconst struct qe_microcode *ucode)\r\n{\r\nconst __be32 *code = base + be32_to_cpu(ucode->code_offset);\r\nunsigned int i;\r\nif (ucode->major || ucode->minor || ucode->revision)\r\nprintk(KERN_INFO "qe-firmware: "\r\n"uploading microcode '%s' version %u.%u.%u\n",\r\nucode->id, ucode->major, ucode->minor, ucode->revision);\r\nelse\r\nprintk(KERN_INFO "qe-firmware: "\r\n"uploading microcode '%s'\n", ucode->id);\r\nout_be32(&qe_immr->iram.iadd, be32_to_cpu(ucode->iram_offset) |\r\nQE_IRAM_IADD_AIE | QE_IRAM_IADD_BADDR);\r\nfor (i = 0; i < be32_to_cpu(ucode->count); i++)\r\nout_be32(&qe_immr->iram.idata, be32_to_cpu(code[i]));\r\n}\r\nint qe_upload_firmware(const struct qe_firmware *firmware)\r\n{\r\nunsigned int i;\r\nunsigned int j;\r\nu32 crc;\r\nsize_t calc_size = sizeof(struct qe_firmware);\r\nsize_t length;\r\nconst struct qe_header *hdr;\r\nif (!firmware) {\r\nprintk(KERN_ERR "qe-firmware: invalid pointer\n");\r\nreturn -EINVAL;\r\n}\r\nhdr = &firmware->header;\r\nlength = be32_to_cpu(hdr->length);\r\nif ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||\r\n(hdr->magic[2] != 'F')) {\r\nprintk(KERN_ERR "qe-firmware: not a microcode\n");\r\nreturn -EPERM;\r\n}\r\nif (hdr->version != 1) {\r\nprintk(KERN_ERR "qe-firmware: unsupported version\n");\r\nreturn -EPERM;\r\n}\r\nif ((firmware->count < 1) || (firmware->count > MAX_QE_RISC)) {\r\nprintk(KERN_ERR "qe-firmware: invalid data\n");\r\nreturn -EINVAL;\r\n}\r\ncalc_size += (firmware->count - 1) * sizeof(struct qe_microcode);\r\nfor (i = 0; i < firmware->count; i++)\r\ncalc_size += sizeof(__be32) *\r\nbe32_to_cpu(firmware->microcode[i].count);\r\nif (length != calc_size + sizeof(__be32)) {\r\nprintk(KERN_ERR "qe-firmware: invalid length\n");\r\nreturn -EPERM;\r\n}\r\ncrc = be32_to_cpu(*(__be32 *)((void *)firmware + calc_size));\r\nif (crc != crc32(0, firmware, calc_size)) {\r\nprintk(KERN_ERR "qe-firmware: firmware CRC is invalid\n");\r\nreturn -EIO;\r\n}\r\nif (!firmware->split)\r\nsetbits16(&qe_immr->cp.cercr, QE_CP_CERCR_CIR);\r\nif (firmware->soc.model)\r\nprintk(KERN_INFO\r\n"qe-firmware: firmware '%s' for %u V%u.%u\n",\r\nfirmware->id, be16_to_cpu(firmware->soc.model),\r\nfirmware->soc.major, firmware->soc.minor);\r\nelse\r\nprintk(KERN_INFO "qe-firmware: firmware '%s'\n",\r\nfirmware->id);\r\nmemset(&qe_firmware_info, 0, sizeof(qe_firmware_info));\r\nstrcpy(qe_firmware_info.id, firmware->id);\r\nqe_firmware_info.extended_modes = firmware->extended_modes;\r\nmemcpy(qe_firmware_info.vtraps, firmware->vtraps,\r\nsizeof(firmware->vtraps));\r\nfor (i = 0; i < firmware->count; i++) {\r\nconst struct qe_microcode *ucode = &firmware->microcode[i];\r\nif (ucode->code_offset)\r\nqe_upload_microcode(firmware, ucode);\r\nfor (j = 0; j < 16; j++) {\r\nu32 trap = be32_to_cpu(ucode->traps[j]);\r\nif (trap)\r\nout_be32(&qe_immr->rsp[i].tibcr[j], trap);\r\n}\r\nout_be32(&qe_immr->rsp[i].eccr, be32_to_cpu(ucode->eccr));\r\n}\r\nqe_firmware_uploaded = 1;\r\nreturn 0;\r\n}\r\nstruct qe_firmware_info *qe_get_firmware_info(void)\r\n{\r\nstatic int initialized;\r\nstruct property *prop;\r\nstruct device_node *qe;\r\nstruct device_node *fw = NULL;\r\nconst char *sprop;\r\nunsigned int i;\r\nif (qe_firmware_uploaded)\r\nreturn &qe_firmware_info;\r\nif (initialized)\r\nreturn NULL;\r\ninitialized = 1;\r\nqe = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!qe) {\r\nqe = of_find_node_by_type(NULL, "qe");\r\nif (!qe)\r\nreturn NULL;\r\n}\r\nfor_each_child_of_node(qe, fw) {\r\nif (strcmp(fw->name, "firmware") == 0)\r\nbreak;\r\n}\r\nof_node_put(qe);\r\nif (!fw)\r\nreturn NULL;\r\nqe_firmware_uploaded = 1;\r\nsprop = of_get_property(fw, "id", NULL);\r\nif (sprop)\r\nstrncpy(qe_firmware_info.id, sprop,\r\nsizeof(qe_firmware_info.id) - 1);\r\nprop = of_find_property(fw, "extended-modes", NULL);\r\nif (prop && (prop->length == sizeof(u64))) {\r\nconst u64 *iprop = prop->value;\r\nqe_firmware_info.extended_modes = *iprop;\r\n}\r\nprop = of_find_property(fw, "virtual-traps", NULL);\r\nif (prop && (prop->length == 32)) {\r\nconst u32 *iprop = prop->value;\r\nfor (i = 0; i < ARRAY_SIZE(qe_firmware_info.vtraps); i++)\r\nqe_firmware_info.vtraps[i] = iprop[i];\r\n}\r\nof_node_put(fw);\r\nreturn &qe_firmware_info;\r\n}\r\nunsigned int qe_get_num_of_risc(void)\r\n{\r\nstruct device_node *qe;\r\nint size;\r\nunsigned int num_of_risc = 0;\r\nconst u32 *prop;\r\nqe = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!qe) {\r\nqe = of_find_node_by_type(NULL, "qe");\r\nif (!qe)\r\nreturn num_of_risc;\r\n}\r\nprop = of_get_property(qe, "fsl,qe-num-riscs", &size);\r\nif (prop && size == sizeof(*prop))\r\nnum_of_risc = *prop;\r\nof_node_put(qe);\r\nreturn num_of_risc;\r\n}\r\nunsigned int qe_get_num_of_snums(void)\r\n{\r\nstruct device_node *qe;\r\nint size;\r\nunsigned int num_of_snums;\r\nconst u32 *prop;\r\nnum_of_snums = 28;\r\nqe = of_find_compatible_node(NULL, NULL, "fsl,qe");\r\nif (!qe) {\r\nqe = of_find_node_by_type(NULL, "qe");\r\nif (!qe)\r\nreturn num_of_snums;\r\n}\r\nprop = of_get_property(qe, "fsl,qe-num-snums", &size);\r\nif (prop && size == sizeof(*prop)) {\r\nnum_of_snums = *prop;\r\nif ((num_of_snums < 28) || (num_of_snums > QE_NUM_OF_SNUM)) {\r\npr_err("QE: number of snum is invalid\n");\r\nof_node_put(qe);\r\nreturn -EINVAL;\r\n}\r\n}\r\nof_node_put(qe);\r\nreturn num_of_snums;\r\n}\r\nstatic int qe_resume(struct platform_device *ofdev)\r\n{\r\nif (!qe_alive_during_sleep())\r\nqe_reset();\r\nreturn 0;\r\n}\r\nstatic int qe_probe(struct platform_device *ofdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init qe_drv_init(void)\r\n{\r\nreturn platform_driver_register(&qe_driver);\r\n}
