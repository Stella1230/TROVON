static inline u8 bcm_spi_readb(struct bcm63xx_spi *bs,\r\nunsigned int offset)\r\n{\r\nreturn bcm_readb(bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic inline u16 bcm_spi_readw(struct bcm63xx_spi *bs,\r\nunsigned int offset)\r\n{\r\nreturn bcm_readw(bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic inline void bcm_spi_writeb(struct bcm63xx_spi *bs,\r\nu8 value, unsigned int offset)\r\n{\r\nbcm_writeb(value, bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic inline void bcm_spi_writew(struct bcm63xx_spi *bs,\r\nu16 value, unsigned int offset)\r\n{\r\nbcm_writew(value, bs->regs + bcm63xx_spireg(offset));\r\n}\r\nstatic int bcm63xx_spi_check_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nu8 bits_per_word;\r\nbits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;\r\nif (bits_per_word != 8) {\r\ndev_err(&spi->dev, "%s, unsupported bits_per_word=%d\n",\r\n__func__, bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nif (spi->chip_select > spi->master->num_chipselect) {\r\ndev_err(&spi->dev, "%s, unsupported slave %d\n",\r\n__func__, spi->chip_select);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);\r\nu32 hz;\r\nu8 clk_cfg, reg;\r\nint i;\r\nhz = (t) ? t->speed_hz : spi->max_speed_hz;\r\nfor (i = 0; i < SPI_CLK_MASK; i++) {\r\nif (hz <= bcm63xx_spi_freq_table[i][0]) {\r\nclk_cfg = bcm63xx_spi_freq_table[i][1];\r\nbreak;\r\n}\r\n}\r\nif (i == SPI_CLK_MASK)\r\nclk_cfg = SPI_CLK_0_391MHZ;\r\nreg = bcm_spi_readb(bs, SPI_CLK_CFG);\r\nreg &= ~SPI_CLK_MASK;\r\nreg |= clk_cfg;\r\nbcm_spi_writeb(bs, reg, SPI_CLK_CFG);\r\ndev_dbg(&spi->dev, "Setting clock register to %02x (hz %d)\n",\r\nclk_cfg, hz);\r\n}\r\nstatic int bcm63xx_spi_setup(struct spi_device *spi)\r\n{\r\nstruct bcm63xx_spi *bs;\r\nint ret;\r\nbs = spi_master_get_devdata(spi->master);\r\nif (!spi->bits_per_word)\r\nspi->bits_per_word = 8;\r\nif (spi->mode & ~MODEBITS) {\r\ndev_err(&spi->dev, "%s, unsupported mode bits %x\n",\r\n__func__, spi->mode & ~MODEBITS);\r\nreturn -EINVAL;\r\n}\r\nret = bcm63xx_spi_check_transfer(spi, NULL);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "setup: unsupported mode bits %x\n",\r\nspi->mode & ~MODEBITS);\r\nreturn ret;\r\n}\r\ndev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u nsec/bit\n",\r\n__func__, spi->mode & MODEBITS, spi->bits_per_word, 0);\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_spi_fill_tx_fifo(struct bcm63xx_spi *bs)\r\n{\r\nu8 size;\r\nsize = bs->remaining_bytes < bs->fifo_size ? bs->remaining_bytes :\r\nbs->fifo_size;\r\nmemcpy_toio(bs->tx_io, bs->tx_ptr, size);\r\nbs->remaining_bytes -= size;\r\n}\r\nstatic unsigned int bcm63xx_txrx_bufs(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(spi->master);\r\nu16 msg_ctl;\r\nu16 cmd;\r\nbcm_spi_writeb(bs, 0, SPI_INT_MASK);\r\ndev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",\r\nt->tx_buf, t->rx_buf, t->len);\r\nbs->tx_ptr = t->tx_buf;\r\nbs->rx_ptr = t->rx_buf;\r\nif (t->tx_buf) {\r\nbs->remaining_bytes = t->len;\r\nbcm63xx_spi_fill_tx_fifo(bs);\r\n}\r\ninit_completion(&bs->done);\r\nmsg_ctl = (t->len << SPI_BYTE_CNT_SHIFT);\r\nif (t->rx_buf && t->tx_buf)\r\nmsg_ctl |= (SPI_FD_RW << SPI_MSG_TYPE_SHIFT);\r\nelse if (t->rx_buf)\r\nmsg_ctl |= (SPI_HD_R << SPI_MSG_TYPE_SHIFT);\r\nelse if (t->tx_buf)\r\nmsg_ctl |= (SPI_HD_W << SPI_MSG_TYPE_SHIFT);\r\nbcm_spi_writew(bs, msg_ctl, SPI_MSG_CTL);\r\ncmd = SPI_CMD_START_IMMEDIATE;\r\ncmd |= (0 << SPI_CMD_PREPEND_BYTE_CNT_SHIFT);\r\ncmd |= (spi->chip_select << SPI_CMD_DEVICE_ID_SHIFT);\r\nbcm_spi_writew(bs, cmd, SPI_CMD);\r\nbcm_spi_writeb(bs, SPI_INTR_CMD_DONE, SPI_INT_MASK);\r\nreturn t->len - bs->remaining_bytes;\r\n}\r\nstatic int bcm63xx_spi_prepare_transfer(struct spi_master *master)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\npm_runtime_get_sync(&bs->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_unprepare_transfer(struct spi_master *master)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\npm_runtime_put(&bs->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_transfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nstruct spi_transfer *t;\r\nstruct spi_device *spi = m->spi;\r\nint status = 0;\r\nunsigned int timeout = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nunsigned int len = t->len;\r\nu8 rx_tail;\r\nstatus = bcm63xx_spi_check_transfer(spi, t);\r\nif (status < 0)\r\ngoto exit;\r\nbcm63xx_spi_setup_transfer(spi, t);\r\nwhile (len) {\r\nlen -= bcm63xx_txrx_bufs(spi, t);\r\ntimeout = wait_for_completion_timeout(&bs->done, HZ);\r\nif (!timeout) {\r\nstatus = -ETIMEDOUT;\r\ngoto exit;\r\n}\r\nrx_tail = bcm_spi_readb(bs, SPI_RX_TAIL);\r\nif (rx_tail)\r\nmemcpy_fromio(bs->rx_ptr, bs->rx_io, rx_tail);\r\n}\r\nm->actual_length += t->len;\r\n}\r\nexit:\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bcm63xx_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = (struct spi_master *)dev_id;\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nu8 intr;\r\nintr = bcm_spi_readb(bs, SPI_INT_STATUS);\r\nbcm_spi_writeb(bs, SPI_INTR_CLEAR_ALL, SPI_INT_STATUS);\r\nbcm_spi_writeb(bs, 0, SPI_INT_MASK);\r\nif (intr & SPI_INTR_CMD_DONE)\r\ncomplete(&bs->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit bcm63xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm63xx_spi_pdata *pdata = pdev->dev.platform_data;\r\nint irq;\r\nstruct spi_master *master;\r\nstruct clk *clk;\r\nstruct bcm63xx_spi *bs;\r\nint ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(dev, "no iomem\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "no irq\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nclk = clk_get(dev, "spi");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "no clock for device\n");\r\nret = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(*bs));\r\nif (!master) {\r\ndev_err(dev, "out of memory\n");\r\nret = -ENOMEM;\r\ngoto out_clk;\r\n}\r\nbs = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, master);\r\nbs->pdev = pdev;\r\nif (!devm_request_mem_region(&pdev->dev, r->start,\r\nresource_size(r), PFX)) {\r\ndev_err(dev, "iomem request failed\n");\r\nret = -ENXIO;\r\ngoto out_err;\r\n}\r\nbs->regs = devm_ioremap_nocache(&pdev->dev, r->start,\r\nresource_size(r));\r\nif (!bs->regs) {\r\ndev_err(dev, "unable to ioremap regs\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nbs->irq = irq;\r\nbs->clk = clk;\r\nbs->fifo_size = pdata->fifo_size;\r\nret = devm_request_irq(&pdev->dev, irq, bcm63xx_spi_interrupt, 0,\r\npdev->name, master);\r\nif (ret) {\r\ndev_err(dev, "unable to request irq\n");\r\ngoto out_err;\r\n}\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\nmaster->setup = bcm63xx_spi_setup;\r\nmaster->prepare_transfer_hardware = bcm63xx_spi_prepare_transfer;\r\nmaster->unprepare_transfer_hardware = bcm63xx_spi_unprepare_transfer;\r\nmaster->transfer_one_message = bcm63xx_spi_transfer_one;\r\nmaster->mode_bits = MODEBITS;\r\nbs->speed_hz = pdata->speed_hz;\r\nbs->tx_io = (u8 *)(bs->regs + bcm63xx_spireg(SPI_MSG_DATA));\r\nbs->rx_io = (const u8 *)(bs->regs + bcm63xx_spireg(SPI_RX_DATA));\r\nclk_enable(bs->clk);\r\nbcm_spi_writeb(bs, SPI_INTR_CLEAR_ALL, SPI_INT_STATUS);\r\nret = spi_register_master(master);\r\nif (ret) {\r\ndev_err(dev, "spi register failed\n");\r\ngoto out_clk_disable;\r\n}\r\ndev_info(dev, "at 0x%08x (irq %d, FIFOs size %d) v%s\n",\r\nr->start, irq, bs->fifo_size, DRV_VER);\r\nreturn 0;\r\nout_clk_disable:\r\nclk_disable(clk);\r\nout_err:\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(master);\r\nout_clk:\r\nclk_put(clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __devexit bcm63xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nspi_unregister_master(master);\r\nbcm_spi_writeb(bs, 0, SPI_INT_MASK);\r\nclk_disable(bs->clk);\r\nclk_put(bs->clk);\r\nplatform_set_drvdata(pdev, 0);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master =\r\nplatform_get_drvdata(to_platform_device(dev));\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nclk_disable(bs->clk);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_spi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master =\r\nplatform_get_drvdata(to_platform_device(dev));\r\nstruct bcm63xx_spi *bs = spi_master_get_devdata(master);\r\nclk_enable(bs->clk);\r\nreturn 0;\r\n}
