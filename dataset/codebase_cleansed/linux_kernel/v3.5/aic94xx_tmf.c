static int asd_enqueue_internal(struct asd_ascb *ascb,\r\nvoid (*tasklet_complete)(struct asd_ascb *,\r\nstruct done_list_struct *),\r\nvoid (*timed_out)(unsigned long))\r\n{\r\nint res;\r\nascb->tasklet_complete = tasklet_complete;\r\nascb->uldd_timer = 1;\r\nascb->timer.data = (unsigned long) ascb;\r\nascb->timer.function = timed_out;\r\nascb->timer.expires = jiffies + AIC94XX_SCB_TIMEOUT;\r\nadd_timer(&ascb->timer);\r\nres = asd_post_ascb_list(ascb->ha, ascb, 1);\r\nif (unlikely(res))\r\ndel_timer(&ascb->timer);\r\nreturn res;\r\n}\r\nstatic void asd_clear_nexus_tasklet_complete(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct tasklet_completion_status *tcs = ascb->uldd_task;\r\nASD_DPRINTK("%s: here\n", __func__);\r\nif (!del_timer(&ascb->timer)) {\r\nASD_DPRINTK("%s: couldn't delete timer\n", __func__);\r\nreturn;\r\n}\r\nASD_DPRINTK("%s: opcode: 0x%x\n", __func__, dl->opcode);\r\ntcs->dl_opcode = dl->opcode;\r\ncomplete(ascb->completion);\r\nasd_ascb_free(ascb);\r\n}\r\nstatic void asd_clear_nexus_timedout(unsigned long data)\r\n{\r\nstruct asd_ascb *ascb = (void *)data;\r\nstruct tasklet_completion_status *tcs = ascb->uldd_task;\r\nASD_DPRINTK("%s: here\n", __func__);\r\ntcs->dl_opcode = TMF_RESP_FUNC_FAILED;\r\ncomplete(ascb->completion);\r\n}\r\nint asd_clear_nexus_ha(struct sas_ha_struct *sas_ha)\r\n{\r\nstruct asd_ha_struct *asd_ha = sas_ha->lldd_ha;\r\nCLEAR_NEXUS_PRE;\r\nscb->clear_nexus.nexus = NEXUS_ADAPTER;\r\nCLEAR_NEXUS_POST;\r\n}\r\nint asd_clear_nexus_port(struct asd_sas_port *port)\r\n{\r\nstruct asd_ha_struct *asd_ha = port->ha->lldd_ha;\r\nCLEAR_NEXUS_PRE;\r\nscb->clear_nexus.nexus = NEXUS_PORT;\r\nscb->clear_nexus.conn_mask = port->phy_mask;\r\nCLEAR_NEXUS_POST;\r\n}\r\nstatic int asd_clear_nexus_I_T(struct domain_device *dev,\r\nenum clear_nexus_phase phase)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nCLEAR_NEXUS_PRE;\r\nscb->clear_nexus.nexus = NEXUS_I_T;\r\nswitch (phase) {\r\ncase NEXUS_PHASE_PRE:\r\nscb->clear_nexus.flags = EXEC_Q | SUSPEND_TX;\r\nbreak;\r\ncase NEXUS_PHASE_POST:\r\nscb->clear_nexus.flags = SEND_Q | NOTINQ;\r\nbreak;\r\ncase NEXUS_PHASE_RESUME:\r\nscb->clear_nexus.flags = RESUME_TX;\r\n}\r\nscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\r\ndev->lldd_dev);\r\nCLEAR_NEXUS_POST;\r\n}\r\nint asd_I_T_nexus_reset(struct domain_device *dev)\r\n{\r\nint res, tmp_res, i;\r\nstruct sas_phy *phy = sas_get_local_phy(dev);\r\nint reset_type = (dev->dev_type == SATA_DEV ||\r\n(dev->tproto & SAS_PROTOCOL_STP)) ? 0 : 1;\r\nasd_clear_nexus_I_T(dev, NEXUS_PHASE_PRE);\r\nASD_DPRINTK("sending %s reset to %s\n",\r\nreset_type ? "hard" : "soft", dev_name(&phy->dev));\r\nres = sas_phy_reset(phy, reset_type);\r\nif (res == TMF_RESP_FUNC_COMPLETE || res == -ENODEV) {\r\nmsleep(500);\r\nasd_clear_nexus_I_T(dev, NEXUS_PHASE_POST);\r\n}\r\nfor (i = 0 ; i < 3; i++) {\r\ntmp_res = asd_clear_nexus_I_T(dev, NEXUS_PHASE_RESUME);\r\nif (tmp_res == TC_RESUME)\r\ngoto out;\r\nmsleep(500);\r\n}\r\ndev_printk(KERN_ERR, &phy->dev,\r\n"Failed to resume nexus after reset 0x%x\n", tmp_res);\r\nres = TMF_RESP_FUNC_FAILED;\r\nout:\r\nsas_put_local_phy(phy);\r\nreturn res;\r\n}\r\nstatic int asd_clear_nexus_I_T_L(struct domain_device *dev, u8 *lun)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nCLEAR_NEXUS_PRE;\r\nscb->clear_nexus.nexus = NEXUS_I_T_L;\r\nscb->clear_nexus.flags = SEND_Q | EXEC_Q | NOTINQ;\r\nmemcpy(scb->clear_nexus.ssp_task.lun, lun, 8);\r\nscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\r\ndev->lldd_dev);\r\nCLEAR_NEXUS_POST;\r\n}\r\nstatic int asd_clear_nexus_tag(struct sas_task *task)\r\n{\r\nstruct asd_ha_struct *asd_ha = task->dev->port->ha->lldd_ha;\r\nstruct asd_ascb *tascb = task->lldd_task;\r\nCLEAR_NEXUS_PRE;\r\nscb->clear_nexus.nexus = NEXUS_TAG;\r\nmemcpy(scb->clear_nexus.ssp_task.lun, task->ssp_task.LUN, 8);\r\nscb->clear_nexus.ssp_task.tag = tascb->tag;\r\nif (task->dev->tproto)\r\nscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\r\ntask->dev->lldd_dev);\r\nCLEAR_NEXUS_POST;\r\n}\r\nstatic int asd_clear_nexus_index(struct sas_task *task)\r\n{\r\nstruct asd_ha_struct *asd_ha = task->dev->port->ha->lldd_ha;\r\nstruct asd_ascb *tascb = task->lldd_task;\r\nCLEAR_NEXUS_PRE;\r\nscb->clear_nexus.nexus = NEXUS_TRANS_CX;\r\nif (task->dev->tproto)\r\nscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\r\ntask->dev->lldd_dev);\r\nscb->clear_nexus.index = cpu_to_le16(tascb->tc_index);\r\nCLEAR_NEXUS_POST;\r\n}\r\nstatic void asd_tmf_timedout(unsigned long data)\r\n{\r\nstruct asd_ascb *ascb = (void *) data;\r\nstruct tasklet_completion_status *tcs = ascb->uldd_task;\r\nASD_DPRINTK("tmf timed out\n");\r\ntcs->tmf_state = TMF_RESP_FUNC_FAILED;\r\ncomplete(ascb->completion);\r\n}\r\nstatic int asd_get_tmf_resp_tasklet(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct asd_ha_struct *asd_ha = ascb->ha;\r\nunsigned long flags;\r\nstruct tc_resp_sb_struct {\r\n__le16 index_escb;\r\nu8 len_lsb;\r\nu8 flags;\r\n} __attribute__ ((packed)) *resp_sb = (void *) dl->status_block;\r\nint edb_id = ((resp_sb->flags & 0x70) >> 4)-1;\r\nstruct asd_ascb *escb;\r\nstruct asd_dma_tok *edb;\r\nstruct ssp_frame_hdr *fh;\r\nstruct ssp_response_iu *ru;\r\nint res = TMF_RESP_FUNC_FAILED;\r\nASD_DPRINTK("tmf resp tasklet\n");\r\nspin_lock_irqsave(&asd_ha->seq.tc_index_lock, flags);\r\nescb = asd_tc_index_find(&asd_ha->seq,\r\n(int)le16_to_cpu(resp_sb->index_escb));\r\nspin_unlock_irqrestore(&asd_ha->seq.tc_index_lock, flags);\r\nif (!escb) {\r\nASD_DPRINTK("Uh-oh! No escb for this dl?!\n");\r\nreturn res;\r\n}\r\nedb = asd_ha->seq.edb_arr[edb_id + escb->edb_index];\r\nascb->tag = *(__be16 *)(edb->vaddr+4);\r\nfh = edb->vaddr + 16;\r\nru = edb->vaddr + 16 + sizeof(*fh);\r\nres = ru->status;\r\nif (ru->datapres == 1)\r\nres = ru->resp_data[3];\r\n#if 0\r\nascb->tag = fh->tag;\r\n#endif\r\nascb->tag_valid = 1;\r\nasd_invalidate_edb(escb, edb_id);\r\nreturn res;\r\n}\r\nstatic void asd_tmf_tasklet_complete(struct asd_ascb *ascb,\r\nstruct done_list_struct *dl)\r\n{\r\nstruct tasklet_completion_status *tcs;\r\nif (!del_timer(&ascb->timer))\r\nreturn;\r\ntcs = ascb->uldd_task;\r\nASD_DPRINTK("tmf tasklet complete\n");\r\ntcs->dl_opcode = dl->opcode;\r\nif (dl->opcode == TC_SSP_RESP) {\r\ntcs->tmf_state = asd_get_tmf_resp_tasklet(ascb, dl);\r\ntcs->tag_valid = ascb->tag_valid;\r\ntcs->tag = ascb->tag;\r\n}\r\ncomplete(ascb->completion);\r\nasd_ascb_free(ascb);\r\n}\r\nstatic int asd_clear_nexus(struct sas_task *task)\r\n{\r\nint res = TMF_RESP_FUNC_FAILED;\r\nint leftover;\r\nstruct asd_ascb *tascb = task->lldd_task;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nunsigned long flags;\r\ntascb->completion = &completion;\r\nASD_DPRINTK("task not done, clearing nexus\n");\r\nif (tascb->tag_valid)\r\nres = asd_clear_nexus_tag(task);\r\nelse\r\nres = asd_clear_nexus_index(task);\r\nleftover = wait_for_completion_timeout(&completion,\r\nAIC94XX_SCB_TIMEOUT);\r\ntascb->completion = NULL;\r\nASD_DPRINTK("came back from clear nexus\n");\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (leftover < 1)\r\nres = TMF_RESP_FUNC_FAILED;\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE)\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nreturn res;\r\n}\r\nint asd_abort_task(struct sas_task *task)\r\n{\r\nstruct asd_ascb *tascb = task->lldd_task;\r\nstruct asd_ha_struct *asd_ha = tascb->ha;\r\nint res = 1;\r\nunsigned long flags;\r\nstruct asd_ascb *ascb = NULL;\r\nstruct scb *scb;\r\nint leftover;\r\nDECLARE_TCS(tcs);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nDECLARE_COMPLETION_ONSTACK(tascb_completion);\r\ntascb->completion = &tascb_completion;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nASD_DPRINTK("%s: task 0x%p done\n", __func__, task);\r\ngoto out_done;\r\n}\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL);\r\nif (!ascb)\r\nreturn -ENOMEM;\r\nascb->uldd_task = &tcs;\r\nascb->completion = &completion;\r\nscb = ascb->scb;\r\nscb->header.opcode = SCB_ABORT_TASK;\r\nswitch (task->task_proto) {\r\ncase SAS_PROTOCOL_SATA:\r\ncase SAS_PROTOCOL_STP:\r\nscb->abort_task.proto_conn_rate = (1 << 5);\r\nbreak;\r\ncase SAS_PROTOCOL_SSP:\r\nscb->abort_task.proto_conn_rate = (1 << 4);\r\nscb->abort_task.proto_conn_rate |= task->dev->linkrate;\r\nbreak;\r\ncase SAS_PROTOCOL_SMP:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (task->task_proto == SAS_PROTOCOL_SSP) {\r\nscb->abort_task.ssp_frame.frame_type = SSP_TASK;\r\nmemcpy(scb->abort_task.ssp_frame.hashed_dest_addr,\r\ntask->dev->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\r\nmemcpy(scb->abort_task.ssp_frame.hashed_src_addr,\r\ntask->dev->port->ha->hashed_sas_addr,\r\nHASHED_SAS_ADDR_SIZE);\r\nscb->abort_task.ssp_frame.tptt = cpu_to_be16(0xFFFF);\r\nmemcpy(scb->abort_task.ssp_task.lun, task->ssp_task.LUN, 8);\r\nscb->abort_task.ssp_task.tmf = TMF_ABORT_TASK;\r\nscb->abort_task.ssp_task.tag = cpu_to_be16(0xFFFF);\r\n}\r\nscb->abort_task.sister_scb = cpu_to_le16(0xFFFF);\r\nscb->abort_task.conn_handle = cpu_to_le16(\r\n(u16)(unsigned long)task->dev->lldd_dev);\r\nscb->abort_task.retry_count = 1;\r\nscb->abort_task.index = cpu_to_le16((u16)tascb->tc_index);\r\nscb->abort_task.itnl_to = cpu_to_le16(ITNL_TIMEOUT_CONST);\r\nres = asd_enqueue_internal(ascb, asd_tmf_tasklet_complete,\r\nasd_tmf_timedout);\r\nif (res)\r\ngoto out_free;\r\nwait_for_completion(&completion);\r\nASD_DPRINTK("tmf came back\n");\r\ntascb->tag = tcs.tag;\r\ntascb->tag_valid = tcs.tag_valid;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE) {\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nASD_DPRINTK("%s: task 0x%p done\n", __func__, task);\r\ngoto out_done;\r\n}\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nif (tcs.dl_opcode == TC_SSP_RESP) {\r\nif (tcs.tmf_state == TMF_RESP_FUNC_COMPLETE)\r\nres = asd_clear_nexus(task);\r\nelse\r\nres = tcs.tmf_state;\r\n} else if (tcs.dl_opcode == TC_NO_ERROR &&\r\ntcs.tmf_state == TMF_RESP_FUNC_FAILED) {\r\nres = TMF_RESP_FUNC_FAILED;\r\n} else {\r\nswitch (tcs.dl_opcode) {\r\ndefault:\r\nres = asd_clear_nexus(task);\r\ncase TC_NO_ERROR:\r\nbreak;\r\ncase TF_NAK_RECV:\r\nres = TMF_RESP_INVALID_FRAME;\r\nbreak;\r\ncase TF_TMF_TASK_DONE:\r\nres = TMF_RESP_FUNC_FAILED;\r\nleftover =\r\nwait_for_completion_timeout(&tascb_completion,\r\nAIC94XX_SCB_TIMEOUT);\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (leftover < 1)\r\nres = TMF_RESP_FUNC_FAILED;\r\nif (task->task_state_flags & SAS_TASK_STATE_DONE)\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\nbreak;\r\ncase TF_TMF_NO_TAG:\r\ncase TF_TMF_TAG_FREE:\r\ncase TF_TMF_NO_CONN_HANDLE:\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nbreak;\r\ncase TF_TMF_NO_CTX:\r\nres = TMF_RESP_FUNC_ESUPP;\r\nbreak;\r\n}\r\n}\r\nout_done:\r\ntascb->completion = NULL;\r\nif (res == TMF_RESP_FUNC_COMPLETE) {\r\ntask->lldd_task = NULL;\r\nmb();\r\nasd_ascb_free(tascb);\r\n}\r\nASD_DPRINTK("task 0x%p aborted, res: 0x%x\n", task, res);\r\nreturn res;\r\nout_free:\r\nasd_ascb_free(ascb);\r\nASD_DPRINTK("task 0x%p aborted, res: 0x%x\n", task, res);\r\nreturn res;\r\n}\r\nstatic int asd_initiate_ssp_tmf(struct domain_device *dev, u8 *lun,\r\nint tmf, int index)\r\n{\r\nstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\r\nstruct asd_ascb *ascb;\r\nint res = 1;\r\nstruct scb *scb;\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nDECLARE_TCS(tcs);\r\nif (!(dev->tproto & SAS_PROTOCOL_SSP))\r\nreturn TMF_RESP_FUNC_ESUPP;\r\nascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL);\r\nif (!ascb)\r\nreturn -ENOMEM;\r\nascb->completion = &completion;\r\nascb->uldd_task = &tcs;\r\nscb = ascb->scb;\r\nif (tmf == TMF_QUERY_TASK)\r\nscb->header.opcode = QUERY_SSP_TASK;\r\nelse\r\nscb->header.opcode = INITIATE_SSP_TMF;\r\nscb->ssp_tmf.proto_conn_rate = (1 << 4);\r\nscb->ssp_tmf.proto_conn_rate |= dev->linkrate;\r\nscb->ssp_tmf.ssp_frame.frame_type = SSP_TASK;\r\nmemcpy(scb->ssp_tmf.ssp_frame.hashed_dest_addr,\r\ndev->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\r\nmemcpy(scb->ssp_tmf.ssp_frame.hashed_src_addr,\r\ndev->port->ha->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\r\nscb->ssp_tmf.ssp_frame.tptt = cpu_to_be16(0xFFFF);\r\nmemcpy(scb->ssp_tmf.ssp_task.lun, lun, 8);\r\nscb->ssp_tmf.ssp_task.tmf = tmf;\r\nscb->ssp_tmf.sister_scb = cpu_to_le16(0xFFFF);\r\nscb->ssp_tmf.conn_handle= cpu_to_le16((u16)(unsigned long)\r\ndev->lldd_dev);\r\nscb->ssp_tmf.retry_count = 1;\r\nscb->ssp_tmf.itnl_to = cpu_to_le16(ITNL_TIMEOUT_CONST);\r\nif (tmf == TMF_QUERY_TASK)\r\nscb->ssp_tmf.index = cpu_to_le16(index);\r\nres = asd_enqueue_internal(ascb, asd_tmf_tasklet_complete,\r\nasd_tmf_timedout);\r\nif (res)\r\ngoto out_err;\r\nwait_for_completion(&completion);\r\nswitch (tcs.dl_opcode) {\r\ncase TC_NO_ERROR:\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nbreak;\r\ncase TF_NAK_RECV:\r\nres = TMF_RESP_INVALID_FRAME;\r\nbreak;\r\ncase TF_TMF_TASK_DONE:\r\nres = TMF_RESP_FUNC_FAILED;\r\nbreak;\r\ncase TF_TMF_NO_TAG:\r\ncase TF_TMF_TAG_FREE:\r\ncase TF_TMF_NO_CONN_HANDLE:\r\nres = TMF_RESP_FUNC_COMPLETE;\r\nbreak;\r\ncase TF_TMF_NO_CTX:\r\nres = TMF_RESP_FUNC_ESUPP;\r\nbreak;\r\ndefault:\r\nres = tcs.dl_opcode;\r\nbreak;\r\n}\r\nreturn res;\r\nout_err:\r\nasd_ascb_free(ascb);\r\nreturn res;\r\n}\r\nint asd_abort_task_set(struct domain_device *dev, u8 *lun)\r\n{\r\nint res = asd_initiate_ssp_tmf(dev, lun, TMF_ABORT_TASK_SET, 0);\r\nif (res == TMF_RESP_FUNC_COMPLETE)\r\nasd_clear_nexus_I_T_L(dev, lun);\r\nreturn res;\r\n}\r\nint asd_clear_aca(struct domain_device *dev, u8 *lun)\r\n{\r\nint res = asd_initiate_ssp_tmf(dev, lun, TMF_CLEAR_ACA, 0);\r\nif (res == TMF_RESP_FUNC_COMPLETE)\r\nasd_clear_nexus_I_T_L(dev, lun);\r\nreturn res;\r\n}\r\nint asd_clear_task_set(struct domain_device *dev, u8 *lun)\r\n{\r\nint res = asd_initiate_ssp_tmf(dev, lun, TMF_CLEAR_TASK_SET, 0);\r\nif (res == TMF_RESP_FUNC_COMPLETE)\r\nasd_clear_nexus_I_T_L(dev, lun);\r\nreturn res;\r\n}\r\nint asd_lu_reset(struct domain_device *dev, u8 *lun)\r\n{\r\nint res = asd_initiate_ssp_tmf(dev, lun, TMF_LU_RESET, 0);\r\nif (res == TMF_RESP_FUNC_COMPLETE)\r\nasd_clear_nexus_I_T_L(dev, lun);\r\nreturn res;\r\n}\r\nint asd_query_task(struct sas_task *task)\r\n{\r\nstruct asd_ascb *ascb = task->lldd_task;\r\nint index;\r\nif (ascb) {\r\nindex = ascb->tc_index;\r\nreturn asd_initiate_ssp_tmf(task->dev, task->ssp_task.LUN,\r\nTMF_QUERY_TASK, index);\r\n}\r\nreturn TMF_RESP_FUNC_COMPLETE;\r\n}
