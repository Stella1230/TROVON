static struct f_audio_buf *f_audio_buffer_alloc(int buf_size)\r\n{\r\nstruct f_audio_buf *copy_buf;\r\ncopy_buf = kzalloc(sizeof *copy_buf, GFP_ATOMIC);\r\nif (!copy_buf)\r\nreturn ERR_PTR(-ENOMEM);\r\ncopy_buf->buf = kzalloc(buf_size, GFP_ATOMIC);\r\nif (!copy_buf->buf) {\r\nkfree(copy_buf);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn copy_buf;\r\n}\r\nstatic void f_audio_buffer_free(struct f_audio_buf *audio_buf)\r\n{\r\nkfree(audio_buf->buf);\r\nkfree(audio_buf);\r\n}\r\nstatic inline struct f_audio *func_to_audio(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_audio, card.func);\r\n}\r\nstatic void f_audio_playback_work(struct work_struct *data)\r\n{\r\nstruct f_audio *audio = container_of(data, struct f_audio,\r\nplayback_work);\r\nstruct f_audio_buf *play_buf;\r\nspin_lock_irq(&audio->lock);\r\nif (list_empty(&audio->play_queue)) {\r\nspin_unlock_irq(&audio->lock);\r\nreturn;\r\n}\r\nplay_buf = list_first_entry(&audio->play_queue,\r\nstruct f_audio_buf, list);\r\nlist_del(&play_buf->list);\r\nspin_unlock_irq(&audio->lock);\r\nu_audio_playback(&audio->card, play_buf->buf, play_buf->actual);\r\nf_audio_buffer_free(play_buf);\r\n}\r\nstatic int f_audio_out_ep_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_audio *audio = req->context;\r\nstruct usb_composite_dev *cdev = audio->card.func.config->cdev;\r\nstruct f_audio_buf *copy_buf = audio->copy_buf;\r\nint err;\r\nif (!copy_buf)\r\nreturn -EINVAL;\r\nif (audio_buf_size - copy_buf->actual < req->actual) {\r\nlist_add_tail(&copy_buf->list, &audio->play_queue);\r\nschedule_work(&audio->playback_work);\r\ncopy_buf = f_audio_buffer_alloc(audio_buf_size);\r\nif (IS_ERR(copy_buf))\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(copy_buf->buf + copy_buf->actual, req->buf, req->actual);\r\ncopy_buf->actual += req->actual;\r\naudio->copy_buf = copy_buf;\r\nerr = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (err)\r\nERROR(cdev, "%s queue req: %d\n", ep->name, err);\r\nreturn 0;\r\n}\r\nstatic void f_audio_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_audio *audio = req->context;\r\nint status = req->status;\r\nu32 data = 0;\r\nstruct usb_ep *out_ep = audio->out_ep;\r\nswitch (status) {\r\ncase 0:\r\nif (ep == out_ep)\r\nf_audio_out_ep_complete(ep, req);\r\nelse if (audio->set_con) {\r\nmemcpy(&data, req->buf, req->length);\r\naudio->set_con->set(audio->set_con, audio->set_cmd,\r\nle16_to_cpu(data));\r\naudio->set_con = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int audio_set_intf_req(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_audio *audio = func_to_audio(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nu8 id = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\r\nu16 len = le16_to_cpu(ctrl->wLength);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu8 con_sel = (w_value >> 8) & 0xFF;\r\nu8 cmd = (ctrl->bRequest & 0x0F);\r\nstruct usb_audio_control_selector *cs;\r\nstruct usb_audio_control *con;\r\nDBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, entity %d\n",\r\nctrl->bRequest, w_value, len, id);\r\nlist_for_each_entry(cs, &audio->cs, list) {\r\nif (cs->id == id) {\r\nlist_for_each_entry(con, &cs->control, list) {\r\nif (con->type == con_sel) {\r\naudio->set_con = con;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\naudio->set_cmd = cmd;\r\nreq->context = audio;\r\nreq->complete = f_audio_complete;\r\nreturn len;\r\n}\r\nstatic int audio_get_intf_req(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_audio *audio = func_to_audio(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu8 id = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\r\nu16 len = le16_to_cpu(ctrl->wLength);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu8 con_sel = (w_value >> 8) & 0xFF;\r\nu8 cmd = (ctrl->bRequest & 0x0F);\r\nstruct usb_audio_control_selector *cs;\r\nstruct usb_audio_control *con;\r\nDBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, entity %d\n",\r\nctrl->bRequest, w_value, len, id);\r\nlist_for_each_entry(cs, &audio->cs, list) {\r\nif (cs->id == id) {\r\nlist_for_each_entry(con, &cs->control, list) {\r\nif (con->type == con_sel && con->get) {\r\nvalue = con->get(con, cmd);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nreq->context = audio;\r\nreq->complete = f_audio_complete;\r\nmemcpy(req->buf, &value, len);\r\nreturn len;\r\n}\r\nstatic int audio_set_endpoint_req(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nint value = -EOPNOTSUPP;\r\nu16 ep = le16_to_cpu(ctrl->wIndex);\r\nu16 len = le16_to_cpu(ctrl->wLength);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nDBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",\r\nctrl->bRequest, w_value, len, ep);\r\nswitch (ctrl->bRequest) {\r\ncase UAC_SET_CUR:\r\nvalue = len;\r\nbreak;\r\ncase UAC_SET_MIN:\r\nbreak;\r\ncase UAC_SET_MAX:\r\nbreak;\r\ncase UAC_SET_RES:\r\nbreak;\r\ncase UAC_SET_MEM:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int audio_get_endpoint_req(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nint value = -EOPNOTSUPP;\r\nu8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\r\nu16 len = le16_to_cpu(ctrl->wLength);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nDBG(cdev, "bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\n",\r\nctrl->bRequest, w_value, len, ep);\r\nswitch (ctrl->bRequest) {\r\ncase UAC_GET_CUR:\r\ncase UAC_GET_MIN:\r\ncase UAC_GET_MAX:\r\ncase UAC_GET_RES:\r\nvalue = len;\r\nbreak;\r\ncase UAC_GET_MEM:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nf_audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch (ctrl->bRequestType) {\r\ncase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE:\r\nvalue = audio_set_intf_req(f, ctrl);\r\nbreak;\r\ncase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE:\r\nvalue = audio_get_intf_req(f, ctrl);\r\nbreak;\r\ncase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\r\nvalue = audio_set_endpoint_req(f, ctrl);\r\nbreak;\r\ncase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\r\nvalue = audio_get_endpoint_req(f, ctrl);\r\nbreak;\r\ndefault:\r\nERROR(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "audio req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "audio response on err %d\n", value);\r\n}\r\nreturn value;\r\n}\r\nstatic int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_audio *audio = func_to_audio(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_ep *out_ep = audio->out_ep;\r\nstruct usb_request *req;\r\nint i = 0, err = 0;\r\nDBG(cdev, "intf %d, alt %d\n", intf, alt);\r\nif (intf == 1) {\r\nif (alt == 1) {\r\nusb_ep_enable(out_ep);\r\nout_ep->driver_data = audio;\r\naudio->copy_buf = f_audio_buffer_alloc(audio_buf_size);\r\nif (IS_ERR(audio->copy_buf))\r\nreturn -ENOMEM;\r\nfor (i = 0; i < req_count && err == 0; i++) {\r\nreq = usb_ep_alloc_request(out_ep, GFP_ATOMIC);\r\nif (req) {\r\nreq->buf = kzalloc(req_buf_size,\r\nGFP_ATOMIC);\r\nif (req->buf) {\r\nreq->length = req_buf_size;\r\nreq->context = audio;\r\nreq->complete =\r\nf_audio_complete;\r\nerr = usb_ep_queue(out_ep,\r\nreq, GFP_ATOMIC);\r\nif (err)\r\nERROR(cdev,\r\n"%s queue req: %d\n",\r\nout_ep->name, err);\r\n} else\r\nerr = -ENOMEM;\r\n} else\r\nerr = -ENOMEM;\r\n}\r\n} else {\r\nstruct f_audio_buf *copy_buf = audio->copy_buf;\r\nif (copy_buf) {\r\nlist_add_tail(&copy_buf->list,\r\n&audio->play_queue);\r\nschedule_work(&audio->playback_work);\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void f_audio_disable(struct usb_function *f)\r\n{\r\nreturn;\r\n}\r\nstatic void f_audio_build_desc(struct f_audio *audio)\r\n{\r\nstruct gaudio *card = &audio->card;\r\nu8 *sam_freq;\r\nint rate;\r\ninput_terminal_desc.bNrChannels = u_audio_get_playback_channels(card);\r\nas_type_i_desc.bNrChannels = u_audio_get_playback_channels(card);\r\nrate = u_audio_get_playback_rate(card);\r\nsam_freq = as_type_i_desc.tSamFreq[0];\r\nmemcpy(sam_freq, &rate, 3);\r\nreturn;\r\n}\r\nstatic int __init\r\nf_audio_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_audio *audio = func_to_audio(f);\r\nint status;\r\nstruct usb_ep *ep;\r\nf_audio_build_desc(audio);\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nac_interface_desc.bInterfaceNumber = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nas_interface_alt_0_desc.bInterfaceNumber = status;\r\nas_interface_alt_1_desc.bInterfaceNumber = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);\r\nif (!ep)\r\ngoto fail;\r\naudio->out_ep = ep;\r\naudio->out_ep->desc = &as_out_ep_desc;\r\nep->driver_data = cdev;\r\nstatus = -ENOMEM;\r\nf->descriptors = usb_copy_descriptors(f_audio_desc);\r\nif (gadget_is_dualspeed(c->cdev->gadget)) {\r\nc->highspeed = true;\r\nf->hs_descriptors = usb_copy_descriptors(f_audio_desc);\r\n}\r\nreturn 0;\r\nfail:\r\nreturn status;\r\n}\r\nstatic void\r\nf_audio_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_audio *audio = func_to_audio(f);\r\nusb_free_descriptors(f->descriptors);\r\nusb_free_descriptors(f->hs_descriptors);\r\nkfree(audio);\r\n}\r\nstatic int generic_set_cmd(struct usb_audio_control *con, u8 cmd, int value)\r\n{\r\ncon->data[cmd] = value;\r\nreturn 0;\r\n}\r\nstatic int generic_get_cmd(struct usb_audio_control *con, u8 cmd)\r\n{\r\nreturn con->data[cmd];\r\n}\r\nint __init control_selector_init(struct f_audio *audio)\r\n{\r\nINIT_LIST_HEAD(&audio->cs);\r\nlist_add(&feature_unit.list, &audio->cs);\r\nINIT_LIST_HEAD(&feature_unit.control);\r\nlist_add(&mute_control.list, &feature_unit.control);\r\nlist_add(&volume_control.list, &feature_unit.control);\r\nvolume_control.data[UAC__CUR] = 0xffc0;\r\nvolume_control.data[UAC__MIN] = 0xe3a0;\r\nvolume_control.data[UAC__MAX] = 0xfff0;\r\nvolume_control.data[UAC__RES] = 0x0030;\r\nreturn 0;\r\n}\r\nint __init audio_bind_config(struct usb_configuration *c)\r\n{\r\nstruct f_audio *audio;\r\nint status;\r\naudio = kzalloc(sizeof *audio, GFP_KERNEL);\r\nif (!audio)\r\nreturn -ENOMEM;\r\naudio->card.func.name = "g_audio";\r\naudio->card.gadget = c->cdev->gadget;\r\nINIT_LIST_HEAD(&audio->play_queue);\r\nspin_lock_init(&audio->lock);\r\nstatus = gaudio_setup(&audio->card);\r\nif (status < 0)\r\ngoto setup_fail;\r\naudio->card.func.strings = audio_strings;\r\naudio->card.func.bind = f_audio_bind;\r\naudio->card.func.unbind = f_audio_unbind;\r\naudio->card.func.set_alt = f_audio_set_alt;\r\naudio->card.func.setup = f_audio_setup;\r\naudio->card.func.disable = f_audio_disable;\r\ncontrol_selector_init(audio);\r\nINIT_WORK(&audio->playback_work, f_audio_playback_work);\r\nstatus = usb_add_function(c, &audio->card.func);\r\nif (status)\r\ngoto add_fail;\r\nINFO(c->cdev, "audio_buf_size %d, req_buf_size %d, req_count %d\n",\r\naudio_buf_size, req_buf_size, req_count);\r\nreturn status;\r\nadd_fail:\r\ngaudio_cleanup();\r\nsetup_fail:\r\nkfree(audio);\r\nreturn status;\r\n}
