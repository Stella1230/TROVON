static irqreturn_t coh901331_interrupt(int irq, void *data)\r\n{\r\nstruct coh901331_port *rtap = data;\r\nclk_enable(rtap->clk);\r\nwritel(1, rtap->virtbase + COH901331_IRQ_EVENT);\r\nwritel(0, rtap->virtbase + COH901331_IRQ_MASK);\r\nclk_disable(rtap->clk);\r\nrtc_update_irq(rtap->rtc, 1, RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int coh901331_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(dev);\r\nclk_enable(rtap->clk);\r\nif (readl(rtap->virtbase + COH901331_VALID)) {\r\nrtc_time_to_tm(readl(rtap->virtbase + COH901331_CUR_TIME), tm);\r\nclk_disable(rtap->clk);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nclk_disable(rtap->clk);\r\nreturn -EINVAL;\r\n}\r\nstatic int coh901331_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(dev);\r\nclk_enable(rtap->clk);\r\nwritel(secs, rtap->virtbase + COH901331_SET_TIME);\r\nclk_disable(rtap->clk);\r\nreturn 0;\r\n}\r\nstatic int coh901331_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(dev);\r\nclk_enable(rtap->clk);\r\nrtc_time_to_tm(readl(rtap->virtbase + COH901331_ALARM), &alarm->time);\r\nalarm->pending = readl(rtap->virtbase + COH901331_IRQ_EVENT) & 1U;\r\nalarm->enabled = readl(rtap->virtbase + COH901331_IRQ_MASK) & 1U;\r\nclk_disable(rtap->clk);\r\nreturn 0;\r\n}\r\nstatic int coh901331_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(dev);\r\nunsigned long time;\r\nrtc_tm_to_time(&alarm->time, &time);\r\nclk_enable(rtap->clk);\r\nwritel(time, rtap->virtbase + COH901331_ALARM);\r\nwritel(alarm->enabled, rtap->virtbase + COH901331_IRQ_MASK);\r\nclk_disable(rtap->clk);\r\nreturn 0;\r\n}\r\nstatic int coh901331_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(dev);\r\nclk_enable(rtap->clk);\r\nif (enabled)\r\nwritel(1, rtap->virtbase + COH901331_IRQ_MASK);\r\nelse\r\nwritel(0, rtap->virtbase + COH901331_IRQ_MASK);\r\nclk_disable(rtap->clk);\r\nreturn 0;\r\n}\r\nstatic int __exit coh901331_remove(struct platform_device *pdev)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(&pdev->dev);\r\nif (rtap) {\r\nfree_irq(rtap->irq, rtap);\r\nrtc_device_unregister(rtap->rtc);\r\nclk_put(rtap->clk);\r\niounmap(rtap->virtbase);\r\nrelease_mem_region(rtap->phybase, rtap->physize);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(rtap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init coh901331_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct coh901331_port *rtap;\r\nstruct resource *res;\r\nrtap = kzalloc(sizeof(struct coh901331_port), GFP_KERNEL);\r\nif (!rtap)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENOENT;\r\ngoto out_no_resource;\r\n}\r\nrtap->phybase = res->start;\r\nrtap->physize = resource_size(res);\r\nif (request_mem_region(rtap->phybase, rtap->physize,\r\n"rtc-coh901331") == NULL) {\r\nret = -EBUSY;\r\ngoto out_no_memregion;\r\n}\r\nrtap->virtbase = ioremap(rtap->phybase, rtap->physize);\r\nif (!rtap->virtbase) {\r\nret = -ENOMEM;\r\ngoto out_no_remap;\r\n}\r\nrtap->irq = platform_get_irq(pdev, 0);\r\nif (request_irq(rtap->irq, coh901331_interrupt, 0,\r\n"RTC COH 901 331 Alarm", rtap)) {\r\nret = -EIO;\r\ngoto out_no_irq;\r\n}\r\nrtap->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(rtap->clk)) {\r\nret = PTR_ERR(rtap->clk);\r\ndev_err(&pdev->dev, "could not get clock\n");\r\ngoto out_no_clk;\r\n}\r\nret = clk_enable(rtap->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not enable clock\n");\r\ngoto out_no_clk_enable;\r\n}\r\nclk_disable(rtap->clk);\r\nplatform_set_drvdata(pdev, rtap);\r\nrtap->rtc = rtc_device_register("coh901331", &pdev->dev, &coh901331_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtap->rtc)) {\r\nret = PTR_ERR(rtap->rtc);\r\ngoto out_no_rtc;\r\n}\r\nreturn 0;\r\nout_no_rtc:\r\nplatform_set_drvdata(pdev, NULL);\r\nout_no_clk_enable:\r\nclk_put(rtap->clk);\r\nout_no_clk:\r\nfree_irq(rtap->irq, rtap);\r\nout_no_irq:\r\niounmap(rtap->virtbase);\r\nout_no_remap:\r\nplatform_set_drvdata(pdev, NULL);\r\nout_no_memregion:\r\nrelease_mem_region(rtap->phybase, SZ_4K);\r\nout_no_resource:\r\nkfree(rtap);\r\nreturn ret;\r\n}\r\nstatic int coh901331_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(&pdev->dev);\r\nif (device_may_wakeup(&pdev->dev)) {\r\nenable_irq_wake(rtap->irq);\r\n} else {\r\nclk_enable(rtap->clk);\r\nrtap->irqmaskstore = readl(rtap->virtbase + COH901331_IRQ_MASK);\r\nwritel(0, rtap->virtbase + COH901331_IRQ_MASK);\r\nclk_disable(rtap->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int coh901331_resume(struct platform_device *pdev)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(&pdev->dev);\r\nif (device_may_wakeup(&pdev->dev)) {\r\ndisable_irq_wake(rtap->irq);\r\n} else {\r\nclk_enable(rtap->clk);\r\nwritel(rtap->irqmaskstore, rtap->virtbase + COH901331_IRQ_MASK);\r\nclk_disable(rtap->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void coh901331_shutdown(struct platform_device *pdev)\r\n{\r\nstruct coh901331_port *rtap = dev_get_drvdata(&pdev->dev);\r\nclk_enable(rtap->clk);\r\nwritel(0, rtap->virtbase + COH901331_IRQ_MASK);\r\nclk_disable(rtap->clk);\r\n}\r\nstatic int __init coh901331_init(void)\r\n{\r\nreturn platform_driver_probe(&coh901331_driver, coh901331_probe);\r\n}\r\nstatic void __exit coh901331_exit(void)\r\n{\r\nplatform_driver_unregister(&coh901331_driver);\r\n}
