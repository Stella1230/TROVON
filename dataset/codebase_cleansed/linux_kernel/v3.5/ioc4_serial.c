static inline int port_is_active(struct ioc4_port *port,\r\nstruct uart_port *uart_port)\r\n{\r\nif (port) {\r\nif ((port->ip_flags & PORT_ACTIVE)\r\n&& (port->ip_port == uart_port))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nwrite_ireg(struct ioc4_soft *ioc4_soft, uint32_t val, int which, int type)\r\n{\r\nstruct ioc4_misc_regs __iomem *mem = ioc4_soft->is_ioc4_misc_addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc4_soft->is_ir_lock, flags);\r\nswitch (type) {\r\ncase IOC4_SIO_INTR_TYPE:\r\nswitch (which) {\r\ncase IOC4_W_IES:\r\nwritel(val, &mem->sio_ies.raw);\r\nbreak;\r\ncase IOC4_W_IEC:\r\nwritel(val, &mem->sio_iec.raw);\r\nbreak;\r\n}\r\nbreak;\r\ncase IOC4_OTHER_INTR_TYPE:\r\nswitch (which) {\r\ncase IOC4_W_IES:\r\nwritel(val, &mem->other_ies.raw);\r\nbreak;\r\ncase IOC4_W_IEC:\r\nwritel(val, &mem->other_iec.raw);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ioc4_soft->is_ir_lock, flags);\r\n}\r\nstatic int set_baud(struct ioc4_port *port, int baud)\r\n{\r\nint actual_baud;\r\nint diff;\r\nint lcr;\r\nunsigned short divisor;\r\nstruct ioc4_uartregs __iomem *uart;\r\ndivisor = SER_DIVISOR(baud, port->ip_pci_bus_speed);\r\nif (!divisor)\r\nreturn 1;\r\nactual_baud = DIVISOR_TO_BAUD(divisor, port->ip_pci_bus_speed);\r\ndiff = actual_baud - baud;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff * 100 > actual_baud)\r\nreturn 1;\r\nuart = port->ip_uart_regs;\r\nlcr = readb(&uart->i4u_lcr);\r\nwriteb(lcr | UART_LCR_DLAB, &uart->i4u_lcr);\r\nwriteb((unsigned char)divisor, &uart->i4u_dll);\r\nwriteb((unsigned char)(divisor >> 8), &uart->i4u_dlm);\r\nwriteb(lcr, &uart->i4u_lcr);\r\nreturn 0;\r\n}\r\nstatic struct ioc4_port *get_ioc4_port(struct uart_port *the_port, int set)\r\n{\r\nstruct ioc4_driver_data *idd = dev_get_drvdata(the_port->dev);\r\nstruct ioc4_control *control = idd->idd_serial_data;\r\nstruct ioc4_port *port;\r\nint port_num, port_type;\r\nif (control) {\r\nfor ( port_num = 0; port_num < IOC4_NUM_SERIAL_PORTS;\r\nport_num++ ) {\r\nport = control->ic_port[port_num].icp_port;\r\nif (!port)\r\ncontinue;\r\nfor (port_type = UART_PORT_MIN;\r\nport_type < UART_PORT_COUNT;\r\nport_type++) {\r\nif (the_port == port->ip_all_ports\r\n[port_type]) {\r\nif (set) {\r\nport->ip_port = the_port;\r\n}\r\nreturn port;\r\n}\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline uint32_t\r\npending_intrs(struct ioc4_soft *soft, int type)\r\n{\r\nstruct ioc4_misc_regs __iomem *mem = soft->is_ioc4_misc_addr;\r\nunsigned long flag;\r\nuint32_t intrs = 0;\r\nBUG_ON(!((type == IOC4_SIO_INTR_TYPE)\r\n|| (type == IOC4_OTHER_INTR_TYPE)));\r\nspin_lock_irqsave(&soft->is_ir_lock, flag);\r\nswitch (type) {\r\ncase IOC4_SIO_INTR_TYPE:\r\nintrs = readl(&mem->sio_ir.raw) & readl(&mem->sio_ies.raw);\r\nbreak;\r\ncase IOC4_OTHER_INTR_TYPE:\r\nintrs = readl(&mem->other_ir.raw) & readl(&mem->other_ies.raw);\r\nintrs &= ~(IOC4_OTHER_IR_ATA_INT | IOC4_OTHER_IR_ATA_MEMERR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&soft->is_ir_lock, flag);\r\nreturn intrs;\r\n}\r\nstatic int inline port_init(struct ioc4_port *port)\r\n{\r\nuint32_t sio_cr;\r\nstruct hooks *hooks = port->ip_hooks;\r\nstruct ioc4_uartregs __iomem *uart;\r\nwritel(IOC4_SSCR_RESET, &port->ip_serial_regs->sscr);\r\ndo\r\nsio_cr = readl(&port->ip_mem->sio_cr.raw);\r\nwhile (!(sio_cr & IOC4_SIO_CR_SIO_DIAG_IDLE));\r\nwritel(0, &port->ip_serial_regs->sscr);\r\nport->ip_tx_prod = readl(&port->ip_serial_regs->stcir) & PROD_CONS_MASK;\r\nwritel(port->ip_tx_prod, &port->ip_serial_regs->stpir);\r\nport->ip_rx_cons = readl(&port->ip_serial_regs->srpir) & PROD_CONS_MASK;\r\nwritel(port->ip_rx_cons | IOC4_SRCIR_ARM, &port->ip_serial_regs->srcir);\r\nuart = port->ip_uart_regs;\r\nwriteb(0, &uart->i4u_lcr);\r\nwriteb(0, &uart->i4u_ier);\r\nset_baud(port, port->ip_baud);\r\nwriteb(UART_LCR_WLEN8 | 0, &uart->i4u_lcr);\r\nwriteb(UART_FCR_ENABLE_FIFO, &uart->i4u_fcr);\r\nwriteb(UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\r\n&uart->i4u_fcr);\r\nwriteb(0, &uart->i4u_mcr);\r\nreadb(&uart->i4u_msr);\r\nif (port->ip_hooks == &hooks_array[0]\r\n|| port->ip_hooks == &hooks_array[2]) {\r\nunsigned long ring_pci_addr;\r\nuint32_t __iomem *sbbr_l;\r\nuint32_t __iomem *sbbr_h;\r\nif (port->ip_hooks == &hooks_array[0]) {\r\nsbbr_l = &port->ip_serial->sbbr01_l;\r\nsbbr_h = &port->ip_serial->sbbr01_h;\r\n} else {\r\nsbbr_l = &port->ip_serial->sbbr23_l;\r\nsbbr_h = &port->ip_serial->sbbr23_h;\r\n}\r\nring_pci_addr = (unsigned long __iomem)port->ip_dma_ringbuf;\r\nDPRINT_CONFIG(("%s: ring_pci_addr 0x%lx\n",\r\n__func__, ring_pci_addr));\r\nwritel((unsigned int)((uint64_t)ring_pci_addr >> 32), sbbr_h);\r\nwritel((unsigned int)ring_pci_addr | IOC4_BUF_SIZE_BIT, sbbr_l);\r\n}\r\nwritel(IOC4_SRTR_HZ / 100, &port->ip_serial_regs->srtr);\r\nport->ip_sscr = (ENTRIES_PER_RING * 3 / 4);\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nwrite_ireg(port->ip_ioc4_soft, hooks->intr_clear,\r\nIOC4_W_IEC, IOC4_SIO_INTR_TYPE);\r\nport->ip_ienb &= ~hooks->intr_clear;\r\nwritel(hooks->intr_clear, &port->ip_mem->sio_ir.raw);\r\nreturn 0;\r\n}\r\nstatic void handle_dma_error_intr(void *arg, uint32_t other_ir)\r\n{\r\nstruct ioc4_port *port = (struct ioc4_port *)arg;\r\nstruct hooks *hooks = port->ip_hooks;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->ip_lock, flags);\r\nwritel(hooks->intr_dma_error, &port->ip_mem->other_ir.raw);\r\nif (readl(&port->ip_mem->pci_err_addr_l.raw) & IOC4_PCI_ERR_ADDR_VLD) {\r\nprintk(KERN_ERR\r\n"PCI error address is 0x%llx, "\r\n"master is serial port %c %s\n",\r\n(((uint64_t)readl(&port->ip_mem->pci_err_addr_h)\r\n<< 32)\r\n| readl(&port->ip_mem->pci_err_addr_l.raw))\r\n& IOC4_PCI_ERR_ADDR_ADDR_MSK, '1' +\r\n((char)(readl(&port->ip_mem->pci_err_addr_l.raw) &\r\nIOC4_PCI_ERR_ADDR_MST_NUM_MSK) >> 1),\r\n(readl(&port->ip_mem->pci_err_addr_l.raw)\r\n& IOC4_PCI_ERR_ADDR_MST_TYP_MSK)\r\n? "RX" : "TX");\r\nif (readl(&port->ip_mem->pci_err_addr_l.raw)\r\n& IOC4_PCI_ERR_ADDR_MUL_ERR) {\r\nprintk(KERN_ERR\r\n"Multiple errors occurred\n");\r\n}\r\n}\r\nspin_unlock_irqrestore(&port->ip_lock, flags);\r\nwrite_ireg(port->ip_ioc4_soft, hooks->intr_dma_error, IOC4_W_IES,\r\nIOC4_OTHER_INTR_TYPE);\r\n}\r\nstatic void\r\nintr_connect(struct ioc4_soft *soft, int type,\r\nuint32_t intrbits, ioc4_intr_func_f * intr, void *info)\r\n{\r\nint i;\r\nstruct ioc4_intr_info *intr_ptr;\r\nBUG_ON(!((type == IOC4_SIO_INTR_TYPE)\r\n|| (type == IOC4_OTHER_INTR_TYPE)));\r\ni = atomic_inc_return(&soft-> is_intr_type[type].is_num_intrs) - 1;\r\nBUG_ON(!(i < MAX_IOC4_INTR_ENTS || (printk("i %d\n", i), 0)));\r\nintr_ptr = &soft->is_intr_type[type].is_intr_info[i];\r\nintr_ptr->sd_bits = intrbits;\r\nintr_ptr->sd_intr = intr;\r\nintr_ptr->sd_info = info;\r\n}\r\nstatic irqreturn_t ioc4_intr(int irq, void *arg)\r\n{\r\nstruct ioc4_soft *soft;\r\nuint32_t this_ir, this_mir;\r\nint xx, num_intrs = 0;\r\nint intr_type;\r\nint handled = 0;\r\nstruct ioc4_intr_info *intr_info;\r\nsoft = arg;\r\nfor (intr_type = 0; intr_type < IOC4_NUM_INTR_TYPES; intr_type++) {\r\nnum_intrs = (int)atomic_read(\r\n&soft->is_intr_type[intr_type].is_num_intrs);\r\nthis_mir = this_ir = pending_intrs(soft, intr_type);\r\nfor (xx = 0; xx < num_intrs; xx++) {\r\nintr_info = &soft->is_intr_type[intr_type].is_intr_info[xx];\r\nif ((this_mir = this_ir & intr_info->sd_bits)) {\r\nhandled++;\r\nwrite_ireg(soft, intr_info->sd_bits, IOC4_W_IEC,\r\nintr_type);\r\nintr_info->sd_intr(intr_info->sd_info, this_mir);\r\nthis_ir &= ~this_mir;\r\n}\r\n}\r\n}\r\n#ifdef DEBUG_INTERRUPTS\r\n{\r\nstruct ioc4_misc_regs __iomem *mem = soft->is_ioc4_misc_addr;\r\nunsigned long flag;\r\nspin_lock_irqsave(&soft->is_ir_lock, flag);\r\nprintk ("%s : %d : mem 0x%p sio_ir 0x%x sio_ies 0x%x "\r\n"other_ir 0x%x other_ies 0x%x mask 0x%x\n",\r\n__func__, __LINE__,\r\n(void *)mem, readl(&mem->sio_ir.raw),\r\nreadl(&mem->sio_ies.raw),\r\nreadl(&mem->other_ir.raw),\r\nreadl(&mem->other_ies.raw),\r\nIOC4_OTHER_IR_ATA_INT | IOC4_OTHER_IR_ATA_MEMERR);\r\nspin_unlock_irqrestore(&soft->is_ir_lock, flag);\r\n}\r\n#endif\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int inline ioc4_attach_local(struct ioc4_driver_data *idd)\r\n{\r\nstruct ioc4_port *port;\r\nstruct ioc4_port *ports[IOC4_NUM_SERIAL_PORTS];\r\nint port_number;\r\nuint16_t ioc4_revid_min = 62;\r\nuint16_t ioc4_revid;\r\nstruct pci_dev *pdev = idd->idd_pdev;\r\nstruct ioc4_control* control = idd->idd_serial_data;\r\nstruct ioc4_soft *soft = control->ic_soft;\r\nvoid __iomem *ioc4_misc = idd->idd_misc_regs;\r\nvoid __iomem *ioc4_serial = soft->is_ioc4_serial_addr;\r\npci_read_config_word(pdev, PCI_COMMAND_SPECIAL, &ioc4_revid);\r\nprintk(KERN_INFO "IOC4 firmware revision %d\n", ioc4_revid);\r\nif (ioc4_revid < ioc4_revid_min) {\r\nprintk(KERN_WARNING\r\n"IOC4 serial not supported on firmware rev %d, "\r\n"please upgrade to rev %d or higher\n",\r\nioc4_revid, ioc4_revid_min);\r\nreturn -EPERM;\r\n}\r\nBUG_ON(ioc4_misc == NULL);\r\nBUG_ON(ioc4_serial == NULL);\r\nfor (port_number = 0; port_number < IOC4_NUM_SERIAL_PORTS;\r\nport_number++) {\r\nport = kzalloc(sizeof(struct ioc4_port), GFP_KERNEL);\r\nif (!port) {\r\nprintk(KERN_WARNING\r\n"IOC4 serial memory not available for port\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&port->ip_lock);\r\nports[port_number] = port;\r\ncontrol->ic_port[port_number].icp_port = port;\r\nport->ip_ioc4_soft = soft;\r\nport->ip_pdev = pdev;\r\nport->ip_ienb = 0;\r\nif (idd->count_period/IOC4_EXTINT_COUNT_DIVISOR < 20) {\r\nport->ip_pci_bus_speed = IOC4_SER_XIN_CLK_66;\r\n} else {\r\nport->ip_pci_bus_speed = IOC4_SER_XIN_CLK_33;\r\n}\r\nport->ip_baud = 9600;\r\nport->ip_control = control;\r\nport->ip_mem = ioc4_misc;\r\nport->ip_serial = ioc4_serial;\r\nport->ip_hooks = &hooks_array[port_number];\r\nswitch (port_number) {\r\ncase 0:\r\nport->ip_serial_regs = &(port->ip_serial->port_0);\r\nport->ip_uart_regs = &(port->ip_serial->uart_0);\r\nbreak;\r\ncase 1:\r\nport->ip_serial_regs = &(port->ip_serial->port_1);\r\nport->ip_uart_regs = &(port->ip_serial->uart_1);\r\nbreak;\r\ncase 2:\r\nport->ip_serial_regs = &(port->ip_serial->port_2);\r\nport->ip_uart_regs = &(port->ip_serial->uart_2);\r\nbreak;\r\ndefault:\r\ncase 3:\r\nport->ip_serial_regs = &(port->ip_serial->port_3);\r\nport->ip_uart_regs = &(port->ip_serial->uart_3);\r\nbreak;\r\n}\r\nif (port_number && (port_number & 1)) {\r\nport->ip_dma_ringbuf =\r\nports[port_number - 1]->ip_dma_ringbuf;\r\nport->ip_cpu_ringbuf =\r\nports[port_number - 1]->ip_cpu_ringbuf;\r\nport->ip_inring = RING(port, RX_1_OR_3);\r\nport->ip_outring = RING(port, TX_1_OR_3);\r\n} else {\r\nif (port->ip_dma_ringbuf == 0) {\r\nport->ip_cpu_ringbuf = pci_alloc_consistent\r\n(pdev, TOTAL_RING_BUF_SIZE,\r\n&port->ip_dma_ringbuf);\r\n}\r\nBUG_ON(!((((int64_t)port->ip_dma_ringbuf) &\r\n(TOTAL_RING_BUF_SIZE - 1)) == 0));\r\nDPRINT_CONFIG(("%s : ip_cpu_ringbuf 0x%p "\r\n"ip_dma_ringbuf 0x%p\n",\r\n__func__,\r\n(void *)port->ip_cpu_ringbuf,\r\n(void *)port->ip_dma_ringbuf));\r\nport->ip_inring = RING(port, RX_0_OR_2);\r\nport->ip_outring = RING(port, TX_0_OR_2);\r\n}\r\nDPRINT_CONFIG(("%s : port %d [addr 0x%p] control 0x%p",\r\n__func__,\r\nport_number, (void *)port, (void *)control));\r\nDPRINT_CONFIG((" ip_serial_regs 0x%p ip_uart_regs 0x%p\n",\r\n(void *)port->ip_serial_regs,\r\n(void *)port->ip_uart_regs));\r\nport_init(port);\r\nDPRINT_CONFIG(("%s: port_number %d port 0x%p inring 0x%p "\r\n"outring 0x%p\n",\r\n__func__,\r\nport_number, (void *)port,\r\n(void *)port->ip_inring,\r\n(void *)port->ip_outring));\r\nintr_connect(soft, IOC4_SIO_INTR_TYPE,\r\nGET_SIO_IR(port_number),\r\nhandle_intr, port);\r\nintr_connect(soft, IOC4_OTHER_INTR_TYPE,\r\nGET_OTHER_IR(port_number),\r\nhandle_dma_error_intr, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void enable_intrs(struct ioc4_port *port, uint32_t mask)\r\n{\r\nstruct hooks *hooks = port->ip_hooks;\r\nif ((port->ip_ienb & mask) != mask) {\r\nwrite_ireg(port->ip_ioc4_soft, mask, IOC4_W_IES,\r\nIOC4_SIO_INTR_TYPE);\r\nport->ip_ienb |= mask;\r\n}\r\nif (port->ip_ienb)\r\nwrite_ireg(port->ip_ioc4_soft, hooks->intr_dma_error,\r\nIOC4_W_IES, IOC4_OTHER_INTR_TYPE);\r\n}\r\nstatic inline int local_open(struct ioc4_port *port)\r\n{\r\nint spiniter = 0;\r\nport->ip_flags = PORT_ACTIVE;\r\nif (port->ip_sscr & IOC4_SSCR_DMA_EN) {\r\nwritel(port->ip_sscr | IOC4_SSCR_DMA_PAUSE,\r\n&port->ip_serial_regs->sscr);\r\nwhile((readl(&port->ip_serial_regs-> sscr)\r\n& IOC4_SSCR_PAUSE_STATE) == 0) {\r\nspiniter++;\r\nif (spiniter > MAXITER) {\r\nport->ip_flags = PORT_INACTIVE;\r\nreturn -1;\r\n}\r\n}\r\n}\r\nwriteb(UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR,\r\n&port->ip_uart_regs->i4u_fcr);\r\nwriteb(UART_LCR_WLEN8, &port->ip_uart_regs->i4u_lcr);\r\nport->ip_sscr &= ~IOC4_SSCR_RX_THRESHOLD;\r\nport->ip_sscr |= 1;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nport->ip_tx_lowat = 1;\r\nreturn 0;\r\n}\r\nstatic inline int set_rx_timeout(struct ioc4_port *port, int timeout)\r\n{\r\nint threshold;\r\nport->ip_rx_timeout = timeout;\r\nthreshold = timeout * port->ip_baud / 4000;\r\nif (threshold == 0)\r\nthreshold = 1;\r\nif ((unsigned)threshold > (unsigned)IOC4_SSCR_RX_THRESHOLD)\r\nreturn 1;\r\nport->ip_sscr &= ~IOC4_SSCR_RX_THRESHOLD;\r\nport->ip_sscr |= threshold;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\ntimeout = timeout * IOC4_SRTR_HZ / 100;\r\nif (timeout > IOC4_SRTR_CNT)\r\ntimeout = IOC4_SRTR_CNT;\r\nwritel(timeout, &port->ip_serial_regs->srtr);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nconfig_port(struct ioc4_port *port,\r\nint baud, int byte_size, int stop_bits, int parenb, int parodd)\r\n{\r\nchar lcr, sizebits;\r\nint spiniter = 0;\r\nDPRINT_CONFIG(("%s: baud %d byte_size %d stop %d parenb %d parodd %d\n",\r\n__func__, baud, byte_size, stop_bits, parenb, parodd));\r\nif (set_baud(port, baud))\r\nreturn 1;\r\nswitch (byte_size) {\r\ncase 5:\r\nsizebits = UART_LCR_WLEN5;\r\nbreak;\r\ncase 6:\r\nsizebits = UART_LCR_WLEN6;\r\nbreak;\r\ncase 7:\r\nsizebits = UART_LCR_WLEN7;\r\nbreak;\r\ncase 8:\r\nsizebits = UART_LCR_WLEN8;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (port->ip_sscr & IOC4_SSCR_DMA_EN) {\r\nwritel(port->ip_sscr | IOC4_SSCR_DMA_PAUSE,\r\n&port->ip_serial_regs->sscr);\r\nwhile((readl(&port->ip_serial_regs->sscr)\r\n& IOC4_SSCR_PAUSE_STATE) == 0) {\r\nspiniter++;\r\nif (spiniter > MAXITER)\r\nreturn -1;\r\n}\r\n}\r\nlcr = readb(&port->ip_uart_regs->i4u_lcr);\r\nlcr &= ~(LCR_MASK_BITS_CHAR | UART_LCR_EPAR |\r\nUART_LCR_PARITY | LCR_MASK_STOP_BITS);\r\nlcr |= sizebits;\r\nif (parenb) {\r\nlcr |= UART_LCR_PARITY;\r\nif (!parodd)\r\nlcr |= UART_LCR_EPAR;\r\n}\r\nif (stop_bits)\r\nlcr |= UART_LCR_STOP ;\r\nwriteb(lcr, &port->ip_uart_regs->i4u_lcr);\r\nif (port->ip_sscr & IOC4_SSCR_DMA_EN) {\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\nport->ip_baud = baud;\r\nport->ip_tx_lowat = (TX_LOWAT_CHARS(baud) + 3) / 4;\r\nif (port->ip_tx_lowat == 0)\r\nport->ip_tx_lowat = 1;\r\nset_rx_timeout(port, 2);\r\nreturn 0;\r\n}\r\nstatic inline int do_write(struct ioc4_port *port, char *buf, int len)\r\n{\r\nint prod_ptr, cons_ptr, total = 0;\r\nstruct ring *outring;\r\nstruct ring_entry *entry;\r\nstruct hooks *hooks = port->ip_hooks;\r\nBUG_ON(!(len >= 0));\r\nprod_ptr = port->ip_tx_prod;\r\ncons_ptr = readl(&port->ip_serial_regs->stcir) & PROD_CONS_MASK;\r\noutring = port->ip_outring;\r\ncons_ptr = (cons_ptr - (int)sizeof(struct ring_entry)) & PROD_CONS_MASK;\r\nwhile ((prod_ptr != cons_ptr) && (len > 0)) {\r\nint xx;\r\nentry = (struct ring_entry *)((caddr_t) outring + prod_ptr);\r\nentry->ring_allsc = 0;\r\nfor (xx = 0; (xx < 4) && (len > 0); xx++) {\r\nentry->ring_data[xx] = *buf++;\r\nentry->ring_sc[xx] = IOC4_TXCB_VALID;\r\nlen--;\r\ntotal++;\r\n}\r\nif (!(port->ip_flags & LOWAT_WRITTEN) &&\r\n((cons_ptr - prod_ptr) & PROD_CONS_MASK)\r\n<= port->ip_tx_lowat\r\n* (int)sizeof(struct ring_entry)) {\r\nport->ip_flags |= LOWAT_WRITTEN;\r\nentry->ring_sc[0] |= IOC4_TXCB_INT_WHEN_DONE;\r\n}\r\nprod_ptr += sizeof(struct ring_entry);\r\nprod_ptr &= PROD_CONS_MASK;\r\n}\r\nif (total > 0 && !(port->ip_sscr & IOC4_SSCR_DMA_EN)) {\r\nport->ip_sscr |= IOC4_SSCR_DMA_EN;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\nif (!uart_tx_stopped(port->ip_port)) {\r\nwritel(prod_ptr, &port->ip_serial_regs->stpir);\r\nif (total > 0)\r\nenable_intrs(port, hooks->intr_tx_mt);\r\n}\r\nport->ip_tx_prod = prod_ptr;\r\nreturn total;\r\n}\r\nstatic void disable_intrs(struct ioc4_port *port, uint32_t mask)\r\n{\r\nstruct hooks *hooks = port->ip_hooks;\r\nif (port->ip_ienb & mask) {\r\nwrite_ireg(port->ip_ioc4_soft, mask, IOC4_W_IEC,\r\nIOC4_SIO_INTR_TYPE);\r\nport->ip_ienb &= ~mask;\r\n}\r\nif (!port->ip_ienb)\r\nwrite_ireg(port->ip_ioc4_soft, hooks->intr_dma_error,\r\nIOC4_W_IEC, IOC4_OTHER_INTR_TYPE);\r\n}\r\nstatic int set_notification(struct ioc4_port *port, int mask, int set_on)\r\n{\r\nstruct hooks *hooks = port->ip_hooks;\r\nuint32_t intrbits, sscrbits;\r\nBUG_ON(!mask);\r\nintrbits = sscrbits = 0;\r\nif (mask & N_DATA_READY)\r\nintrbits |= (hooks->intr_rx_timer | hooks->intr_rx_high);\r\nif (mask & N_OUTPUT_LOWAT)\r\nintrbits |= hooks->intr_tx_explicit;\r\nif (mask & N_DDCD) {\r\nintrbits |= hooks->intr_delta_dcd;\r\nsscrbits |= IOC4_SSCR_RX_RING_DCD;\r\n}\r\nif (mask & N_DCTS)\r\nintrbits |= hooks->intr_delta_cts;\r\nif (set_on) {\r\nenable_intrs(port, intrbits);\r\nport->ip_notify |= mask;\r\nport->ip_sscr |= sscrbits;\r\n} else {\r\ndisable_intrs(port, intrbits);\r\nport->ip_notify &= ~mask;\r\nport->ip_sscr &= ~sscrbits;\r\n}\r\nif (port->ip_notify & (N_DATA_READY | N_DDCD))\r\nport->ip_sscr |= IOC4_SSCR_DMA_EN;\r\nelse if (!(port->ip_ienb & hooks->intr_tx_mt))\r\nport->ip_sscr &= ~IOC4_SSCR_DMA_EN;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nreturn 0;\r\n}\r\nstatic inline int set_mcr(struct uart_port *the_port,\r\nint mask1, int mask2)\r\n{\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nuint32_t shadow;\r\nint spiniter = 0;\r\nchar mcr;\r\nif (!port)\r\nreturn -1;\r\nif (port->ip_sscr & IOC4_SSCR_DMA_EN) {\r\nwritel(port->ip_sscr | IOC4_SSCR_DMA_PAUSE,\r\n&port->ip_serial_regs->sscr);\r\nwhile ((readl(&port->ip_serial_regs->sscr)\r\n& IOC4_SSCR_PAUSE_STATE) == 0) {\r\nspiniter++;\r\nif (spiniter > MAXITER)\r\nreturn -1;\r\n}\r\n}\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nmcr = (shadow & 0xff000000) >> 24;\r\nmcr |= mask1;\r\nshadow |= mask2;\r\nwriteb(mcr, &port->ip_uart_regs->i4u_mcr);\r\nwritel(shadow, &port->ip_serial_regs->shadow);\r\nif (port->ip_sscr & IOC4_SSCR_DMA_EN) {\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioc4_set_proto(struct ioc4_port *port, int proto)\r\n{\r\nstruct hooks *hooks = port->ip_hooks;\r\nswitch (proto) {\r\ncase PROTO_RS232:\r\nwritel(0, (&port->ip_mem->gppr[hooks->rs422_select_pin].raw));\r\nbreak;\r\ncase PROTO_RS422:\r\nwritel(1, (&port->ip_mem->gppr[hooks->rs422_select_pin].raw));\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void transmit_chars(struct uart_port *the_port)\r\n{\r\nint xmit_count, tail, head;\r\nint result;\r\nchar *start;\r\nstruct tty_struct *tty;\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nstruct uart_state *state;\r\nif (!the_port)\r\nreturn;\r\nif (!port)\r\nreturn;\r\nstate = the_port->state;\r\ntty = state->port.tty;\r\nif (uart_circ_empty(&state->xmit) || uart_tx_stopped(the_port)) {\r\nset_notification(port, N_ALL_OUTPUT, 0);\r\nreturn;\r\n}\r\nhead = state->xmit.head;\r\ntail = state->xmit.tail;\r\nstart = (char *)&state->xmit.buf[tail];\r\nxmit_count = (head < tail) ? (UART_XMIT_SIZE - tail) : (head - tail);\r\nif (xmit_count > 0) {\r\nresult = do_write(port, start, xmit_count);\r\nif (result > 0) {\r\nxmit_count -= result;\r\nthe_port->icount.tx += result;\r\ntail += result;\r\ntail &= UART_XMIT_SIZE - 1;\r\nstate->xmit.tail = tail;\r\nstart = (char *)&state->xmit.buf[tail];\r\n}\r\n}\r\nif (uart_circ_chars_pending(&state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(the_port);\r\nif (uart_circ_empty(&state->xmit)) {\r\nset_notification(port, N_OUTPUT_LOWAT, 0);\r\n} else {\r\nset_notification(port, N_OUTPUT_LOWAT, 1);\r\n}\r\n}\r\nstatic void\r\nioc4_change_speed(struct uart_port *the_port,\r\nstruct ktermios *new_termios, struct ktermios *old_termios)\r\n{\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nint baud, bits;\r\nunsigned cflag, iflag;\r\nint new_parity = 0, new_parity_enable = 0, new_stop = 0, new_data = 8;\r\nstruct uart_state *state = the_port->state;\r\ncflag = new_termios->c_cflag;\r\niflag = new_termios->c_iflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nnew_data = 5;\r\nbits = 7;\r\nbreak;\r\ncase CS6:\r\nnew_data = 6;\r\nbits = 8;\r\nbreak;\r\ncase CS7:\r\nnew_data = 7;\r\nbits = 9;\r\nbreak;\r\ncase CS8:\r\nnew_data = 8;\r\nbits = 10;\r\nbreak;\r\ndefault:\r\nnew_data = 5;\r\nbits = 7;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB) {\r\nbits++;\r\nnew_stop = 1;\r\n}\r\nif (cflag & PARENB) {\r\nbits++;\r\nnew_parity_enable = 1;\r\nif (cflag & PARODD)\r\nnew_parity = 1;\r\n}\r\nbaud = uart_get_baud_rate(the_port, new_termios, old_termios,\r\nMIN_BAUD_SUPPORTED, MAX_BAUD_SUPPORTED);\r\nDPRINT_CONFIG(("%s: returned baud %d\n", __func__, baud));\r\nif (!baud)\r\nbaud = 9600;\r\nif (!the_port->fifosize)\r\nthe_port->fifosize = IOC4_FIFO_CHARS;\r\nthe_port->timeout = ((the_port->fifosize * HZ * bits) / (baud / 10));\r\nthe_port->timeout += HZ / 50;\r\nthe_port->ignore_status_mask = N_ALL_INPUT;\r\nstate->port.tty->low_latency = 1;\r\nif (iflag & IGNPAR)\r\nthe_port->ignore_status_mask &= ~(N_PARITY_ERROR\r\n| N_FRAMING_ERROR);\r\nif (iflag & IGNBRK) {\r\nthe_port->ignore_status_mask &= ~N_BREAK;\r\nif (iflag & IGNPAR)\r\nthe_port->ignore_status_mask &= ~N_OVERRUN_ERROR;\r\n}\r\nif (!(cflag & CREAD)) {\r\nthe_port->ignore_status_mask &= ~N_DATA_READY;\r\n}\r\nif (cflag & CRTSCTS) {\r\nport->ip_sscr |= IOC4_SSCR_HFC_EN;\r\n}\r\nelse {\r\nport->ip_sscr &= ~IOC4_SSCR_HFC_EN;\r\n}\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nDPRINT_CONFIG(("%s : port 0x%p cflag 0%o "\r\n"config_port(baud %d data %d stop %d p enable %d parity %d),"\r\n" notification 0x%x\n",\r\n__func__, (void *)port, cflag, baud, new_data, new_stop,\r\nnew_parity_enable, new_parity, the_port->ignore_status_mask));\r\nif ((config_port(port, baud,\r\nnew_data,\r\nnew_stop,\r\nnew_parity_enable,\r\nnew_parity)) >= 0) {\r\nset_notification(port, the_port->ignore_status_mask, 1);\r\n}\r\n}\r\nstatic inline int ic4_startup_local(struct uart_port *the_port)\r\n{\r\nstruct ioc4_port *port;\r\nstruct uart_state *state;\r\nif (!the_port)\r\nreturn -1;\r\nport = get_ioc4_port(the_port, 0);\r\nif (!port)\r\nreturn -1;\r\nstate = the_port->state;\r\nlocal_open(port);\r\nioc4_set_proto(port, the_port->mapbase);\r\nioc4_change_speed(the_port, state->port.tty->termios,\r\n(struct ktermios *)0);\r\nreturn 0;\r\n}\r\nstatic void ioc4_cb_output_lowat(struct uart_port *the_port)\r\n{\r\nunsigned long pflags;\r\nif (the_port) {\r\nspin_lock_irqsave(&the_port->lock, pflags);\r\ntransmit_chars(the_port);\r\nspin_unlock_irqrestore(&the_port->lock, pflags);\r\n}\r\n}\r\nstatic void handle_intr(void *arg, uint32_t sio_ir)\r\n{\r\nstruct ioc4_port *port = (struct ioc4_port *)arg;\r\nstruct hooks *hooks = port->ip_hooks;\r\nunsigned int rx_high_rd_aborted = 0;\r\nunsigned long flags;\r\nstruct uart_port *the_port;\r\nint loop_counter;\r\nsio_ir &= ~(hooks->intr_tx_mt);\r\nspin_lock_irqsave(&port->ip_lock, flags);\r\nloop_counter = MAXITER;\r\ndo {\r\nuint32_t shadow;\r\nif ( loop_counter-- <= 0 ) {\r\nprintk(KERN_WARNING "IOC4 serial: "\r\n"possible hang condition/"\r\n"port stuck on interrupt.\n");\r\nbreak;\r\n}\r\nif (sio_ir & hooks->intr_delta_dcd) {\r\nwritel(hooks->intr_delta_dcd,\r\n&port->ip_mem->sio_ir.raw);\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nif ((port->ip_notify & N_DDCD)\r\n&& (shadow & IOC4_SHADOW_DCD)\r\n&& (port->ip_port)) {\r\nthe_port = port->ip_port;\r\nthe_port->icount.dcd = 1;\r\nwake_up_interruptible\r\n(&the_port->state->port.delta_msr_wait);\r\n} else if ((port->ip_notify & N_DDCD)\r\n&& !(shadow & IOC4_SHADOW_DCD)) {\r\nport->ip_flags |= DCD_ON;\r\n}\r\n}\r\nif (sio_ir & hooks->intr_delta_cts) {\r\nwritel(hooks->intr_delta_cts,\r\n&port->ip_mem->sio_ir.raw);\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nif ((port->ip_notify & N_DCTS)\r\n&& (port->ip_port)) {\r\nthe_port = port->ip_port;\r\nthe_port->icount.cts =\r\n(shadow & IOC4_SHADOW_CTS) ? 1 : 0;\r\nwake_up_interruptible\r\n(&the_port->state->port.delta_msr_wait);\r\n}\r\n}\r\nif (sio_ir & hooks->intr_rx_timer) {\r\nwritel(hooks->intr_rx_timer,\r\n&port->ip_mem->sio_ir.raw);\r\nif ((port->ip_notify & N_DATA_READY)\r\n&& (port->ip_port)) {\r\nreceive_chars(port->ip_port);\r\n}\r\n}\r\nelse if (sio_ir & hooks->intr_rx_high) {\r\nif ((port->ip_notify & N_DATA_READY)\r\n&& port->ip_port) {\r\nreceive_chars(port->ip_port);\r\n}\r\nif ((sio_ir = PENDING(port)) & hooks->intr_rx_high) {\r\nif ((port->ip_flags & READ_ABORTED) == 0) {\r\nport->ip_ienb &= ~hooks->intr_rx_high;\r\nport->ip_flags |= INPUT_HIGH;\r\n} else {\r\nrx_high_rd_aborted++;\r\n}\r\n}\r\n}\r\nif (sio_ir & hooks->intr_tx_explicit) {\r\nport->ip_flags &= ~LOWAT_WRITTEN;\r\nwritel(hooks->intr_tx_explicit,\r\n&port->ip_mem->sio_ir.raw);\r\nif (port->ip_notify & N_OUTPUT_LOWAT)\r\nioc4_cb_output_lowat(port->ip_port);\r\n}\r\nelse if (sio_ir & hooks->intr_tx_mt) {\r\nif (port->ip_notify & N_OUTPUT_LOWAT) {\r\nioc4_cb_output_lowat(port->ip_port);\r\nsio_ir = PENDING(port);\r\n}\r\nif (sio_ir & hooks->intr_tx_mt) {\r\nif (!(port->ip_notify\r\n& (N_DATA_READY | N_DDCD))) {\r\nBUG_ON(!(port->ip_sscr\r\n& IOC4_SSCR_DMA_EN));\r\nport->ip_sscr &= ~IOC4_SSCR_DMA_EN;\r\nwritel(port->ip_sscr,\r\n&port->ip_serial_regs->sscr);\r\n}\r\nport->ip_ienb &= ~hooks->intr_tx_mt;\r\n}\r\n}\r\nsio_ir = PENDING(port);\r\nif (rx_high_rd_aborted && (sio_ir == hooks->intr_rx_high)) {\r\nsio_ir &= ~hooks->intr_rx_high;\r\n}\r\n} while (sio_ir & hooks->intr_all);\r\nspin_unlock_irqrestore(&port->ip_lock, flags);\r\nwrite_ireg(port->ip_ioc4_soft, port->ip_ienb, IOC4_W_IES,\r\nIOC4_SIO_INTR_TYPE);\r\n}\r\nstatic void ioc4_cb_post_ncs(struct uart_port *the_port, int ncs)\r\n{\r\nstruct uart_icount *icount;\r\nicount = &the_port->icount;\r\nif (ncs & NCS_BREAK)\r\nicount->brk++;\r\nif (ncs & NCS_FRAMING)\r\nicount->frame++;\r\nif (ncs & NCS_OVERRUN)\r\nicount->overrun++;\r\nif (ncs & NCS_PARITY)\r\nicount->parity++;\r\n}\r\nstatic inline int do_read(struct uart_port *the_port, unsigned char *buf,\r\nint len)\r\n{\r\nint prod_ptr, cons_ptr, total;\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nstruct ring *inring;\r\nstruct ring_entry *entry;\r\nstruct hooks *hooks = port->ip_hooks;\r\nint byte_num;\r\nchar *sc;\r\nint loop_counter;\r\nBUG_ON(!(len >= 0));\r\nBUG_ON(!port);\r\nwritel(port->ip_rx_cons | IOC4_SRCIR_ARM, &port->ip_serial_regs->srcir);\r\nprod_ptr = readl(&port->ip_serial_regs->srpir) & PROD_CONS_MASK;\r\ncons_ptr = port->ip_rx_cons;\r\nif (prod_ptr == cons_ptr) {\r\nint reset_dma = 0;\r\nif (!(port->ip_sscr & IOC4_SSCR_DMA_EN)) {\r\nport->ip_sscr |= IOC4_SSCR_DMA_EN;\r\nreset_dma = 1;\r\n}\r\nwritel(port->ip_sscr | IOC4_SSCR_RX_DRAIN,\r\n&port->ip_serial_regs->sscr);\r\nprod_ptr = readl(&port->ip_serial_regs->srpir)\r\n& PROD_CONS_MASK;\r\nif (prod_ptr == cons_ptr) {\r\nloop_counter = 0;\r\nwhile (readl(&port->ip_serial_regs->sscr) &\r\nIOC4_SSCR_RX_DRAIN) {\r\nloop_counter++;\r\nif (loop_counter > MAXITER)\r\nreturn -1;\r\n}\r\nprod_ptr = readl(&port->ip_serial_regs->srpir)\r\n& PROD_CONS_MASK;\r\n}\r\nif (reset_dma) {\r\nport->ip_sscr &= ~IOC4_SSCR_DMA_EN;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\n}\r\ninring = port->ip_inring;\r\nport->ip_flags &= ~READ_ABORTED;\r\ntotal = 0;\r\nloop_counter = 0xfffff;\r\nwhile ((prod_ptr != cons_ptr) && (len > 0)) {\r\nentry = (struct ring_entry *)((caddr_t)inring + cons_ptr);\r\nif ( loop_counter-- <= 0 ) {\r\nprintk(KERN_WARNING "IOC4 serial: "\r\n"possible hang condition/"\r\n"port stuck on read.\n");\r\nbreak;\r\n}\r\nif ((entry->ring_allsc & RING_ANY_VALID) == 0) {\r\nport->ip_flags |= READ_ABORTED;\r\nlen = 0;\r\nbreak;\r\n}\r\nfor (byte_num = 0; byte_num < 4 && len > 0; byte_num++) {\r\nsc = &(entry->ring_sc[byte_num]);\r\nif ((*sc & IOC4_RXSB_MODEM_VALID)\r\n&& (port->ip_notify & N_DDCD)) {\r\nif ((port->ip_flags & DCD_ON)\r\n&& !(*sc & IOC4_RXSB_DCD)) {\r\nif (total > 0) {\r\nlen = 0;\r\nbreak;\r\n}\r\nport->ip_flags &= ~DCD_ON;\r\n*sc &= ~IOC4_RXSB_MODEM_VALID;\r\nif ((entry->ring_allsc & RING_ANY_VALID)\r\n== 0) {\r\ncons_ptr += (int)sizeof\r\n(struct ring_entry);\r\ncons_ptr &= PROD_CONS_MASK;\r\n}\r\nwritel(cons_ptr,\r\n&port->ip_serial_regs->srcir);\r\nport->ip_rx_cons = cons_ptr;\r\nif ((port->ip_notify & N_DDCD)\r\n&& port->ip_port) {\r\nthe_port->icount.dcd = 0;\r\nwake_up_interruptible\r\n(&the_port->state->\r\nport.delta_msr_wait);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nif (*sc & IOC4_RXSB_MODEM_VALID) {\r\nif ((*sc & IOC4_RXSB_OVERRUN)\r\n&& (port->ip_notify & N_OVERRUN_ERROR)) {\r\nioc4_cb_post_ncs(the_port, NCS_OVERRUN);\r\n}\r\n*sc &= ~IOC4_RXSB_MODEM_VALID;\r\n}\r\nif ((*sc & IOC4_RXSB_DATA_VALID) &&\r\n((*sc & (IOC4_RXSB_PAR_ERR\r\n| IOC4_RXSB_FRAME_ERR\r\n| IOC4_RXSB_BREAK))\r\n&& (port->ip_notify & (N_PARITY_ERROR\r\n| N_FRAMING_ERROR\r\n| N_BREAK)))) {\r\nif (total > 0) {\r\nlen = 0;\r\nbreak;\r\n} else {\r\nif ((*sc & IOC4_RXSB_PAR_ERR) &&\r\n(port->ip_notify & N_PARITY_ERROR)) {\r\nioc4_cb_post_ncs(the_port,\r\nNCS_PARITY);\r\n}\r\nif ((*sc & IOC4_RXSB_FRAME_ERR) &&\r\n(port->ip_notify & N_FRAMING_ERROR)){\r\nioc4_cb_post_ncs(the_port,\r\nNCS_FRAMING);\r\n}\r\nif ((*sc & IOC4_RXSB_BREAK)\r\n&& (port->ip_notify & N_BREAK)) {\r\nioc4_cb_post_ncs\r\n(the_port,\r\nNCS_BREAK);\r\n}\r\nlen = 1;\r\n}\r\n}\r\nif (*sc & IOC4_RXSB_DATA_VALID) {\r\n*sc &= ~IOC4_RXSB_DATA_VALID;\r\n*buf = entry->ring_data[byte_num];\r\nbuf++;\r\nlen--;\r\ntotal++;\r\n}\r\n}\r\nif ((entry->ring_allsc & RING_ANY_VALID) == 0) {\r\ncons_ptr += (int)sizeof(struct ring_entry);\r\ncons_ptr &= PROD_CONS_MASK;\r\n}\r\n}\r\nwritel(cons_ptr, &port->ip_serial_regs->srcir);\r\nport->ip_rx_cons = cons_ptr;\r\nif ((port->ip_flags & INPUT_HIGH) && (((prod_ptr - cons_ptr)\r\n& PROD_CONS_MASK) < ((port->ip_sscr &\r\nIOC4_SSCR_RX_THRESHOLD)\r\n<< IOC4_PROD_CONS_PTR_OFF))) {\r\nport->ip_flags &= ~INPUT_HIGH;\r\nenable_intrs(port, hooks->intr_rx_high);\r\n}\r\nreturn total;\r\n}\r\nstatic void receive_chars(struct uart_port *the_port)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned char ch[IOC4_MAX_CHARS];\r\nint read_count, request_count = IOC4_MAX_CHARS;\r\nstruct uart_icount *icount;\r\nstruct uart_state *state = the_port->state;\r\nunsigned long pflags;\r\nif (!state)\r\nreturn;\r\nif (!state->port.tty)\r\nreturn;\r\nspin_lock_irqsave(&the_port->lock, pflags);\r\ntty = state->port.tty;\r\nrequest_count = tty_buffer_request_room(tty, IOC4_MAX_CHARS);\r\nif (request_count > 0) {\r\nicount = &the_port->icount;\r\nread_count = do_read(the_port, ch, request_count);\r\nif (read_count > 0) {\r\ntty_insert_flip_string(tty, ch, read_count);\r\nicount->rx += read_count;\r\n}\r\n}\r\nspin_unlock_irqrestore(&the_port->lock, pflags);\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic const char *ic4_type(struct uart_port *the_port)\r\n{\r\nif (the_port->mapbase == PROTO_RS232)\r\nreturn "SGI IOC4 Serial [rs232]";\r\nelse\r\nreturn "SGI IOC4 Serial [rs422]";\r\n}\r\nstatic unsigned int ic4_tx_empty(struct uart_port *the_port)\r\n{\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nunsigned int ret = 0;\r\nif (port_is_active(port, the_port)) {\r\nif (readl(&port->ip_serial_regs->shadow) & IOC4_SHADOW_TEMT)\r\nret = TIOCSER_TEMT;\r\n}\r\nreturn ret;\r\n}\r\nstatic void ic4_stop_tx(struct uart_port *the_port)\r\n{\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nif (port_is_active(port, the_port))\r\nset_notification(port, N_OUTPUT_LOWAT, 0);\r\n}\r\nstatic void null_void_function(struct uart_port *the_port)\r\n{\r\n}\r\nstatic void ic4_shutdown(struct uart_port *the_port)\r\n{\r\nunsigned long port_flags;\r\nstruct ioc4_port *port;\r\nstruct uart_state *state;\r\nport = get_ioc4_port(the_port, 0);\r\nif (!port)\r\nreturn;\r\nstate = the_port->state;\r\nport->ip_port = NULL;\r\nwake_up_interruptible(&state->port.delta_msr_wait);\r\nif (state->port.tty)\r\nset_bit(TTY_IO_ERROR, &state->port.tty->flags);\r\nspin_lock_irqsave(&the_port->lock, port_flags);\r\nset_notification(port, N_ALL, 0);\r\nport->ip_flags = PORT_INACTIVE;\r\nspin_unlock_irqrestore(&the_port->lock, port_flags);\r\n}\r\nstatic void ic4_set_mctrl(struct uart_port *the_port, unsigned int mctrl)\r\n{\r\nunsigned char mcr = 0;\r\nstruct ioc4_port *port;\r\nport = get_ioc4_port(the_port, 0);\r\nif (!port_is_active(port, the_port))\r\nreturn;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nset_mcr(the_port, mcr, IOC4_SHADOW_DTR);\r\n}\r\nstatic unsigned int ic4_get_mctrl(struct uart_port *the_port)\r\n{\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nuint32_t shadow;\r\nunsigned int ret = 0;\r\nif (!port_is_active(port, the_port))\r\nreturn 0;\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nif (shadow & IOC4_SHADOW_DCD)\r\nret |= TIOCM_CAR;\r\nif (shadow & IOC4_SHADOW_DR)\r\nret |= TIOCM_DSR;\r\nif (shadow & IOC4_SHADOW_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void ic4_start_tx(struct uart_port *the_port)\r\n{\r\nstruct ioc4_port *port = get_ioc4_port(the_port, 0);\r\nif (port_is_active(port, the_port)) {\r\nset_notification(port, N_OUTPUT_LOWAT, 1);\r\nenable_intrs(port, port->ip_hooks->intr_tx_mt);\r\n}\r\n}\r\nstatic void ic4_break_ctl(struct uart_port *the_port, int break_state)\r\n{\r\n}\r\nstatic int ic4_startup(struct uart_port *the_port)\r\n{\r\nint retval;\r\nstruct ioc4_port *port;\r\nstruct ioc4_control *control;\r\nstruct uart_state *state;\r\nunsigned long port_flags;\r\nif (!the_port)\r\nreturn -ENODEV;\r\nport = get_ioc4_port(the_port, 1);\r\nif (!port)\r\nreturn -ENODEV;\r\nstate = the_port->state;\r\ncontrol = port->ip_control;\r\nif (!control) {\r\nport->ip_port = NULL;\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&the_port->lock, port_flags);\r\nretval = ic4_startup_local(the_port);\r\nspin_unlock_irqrestore(&the_port->lock, port_flags);\r\nreturn retval;\r\n}\r\nstatic void\r\nic4_set_termios(struct uart_port *the_port,\r\nstruct ktermios *termios, struct ktermios *old_termios)\r\n{\r\nunsigned long port_flags;\r\nspin_lock_irqsave(&the_port->lock, port_flags);\r\nioc4_change_speed(the_port, termios, old_termios);\r\nspin_unlock_irqrestore(&the_port->lock, port_flags);\r\n}\r\nstatic int ic4_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ioc4_serial_remove_one(struct ioc4_driver_data *idd)\r\n{\r\nint port_num, port_type;\r\nstruct ioc4_control *control;\r\nstruct uart_port *the_port;\r\nstruct ioc4_port *port;\r\nstruct ioc4_soft *soft;\r\ncontrol = idd->idd_serial_data;\r\nif (!control)\r\nreturn 0;\r\nfor (port_num = 0; port_num < IOC4_NUM_SERIAL_PORTS; port_num++) {\r\nfor (port_type = UART_PORT_MIN;\r\nport_type < UART_PORT_COUNT;\r\nport_type++) {\r\nthe_port = &control->ic_port[port_num].icp_uart_port\r\n[port_type];\r\nif (the_port) {\r\nswitch (port_type) {\r\ncase UART_PORT_RS422:\r\nuart_remove_one_port(&ioc4_uart_rs422,\r\nthe_port);\r\nbreak;\r\ndefault:\r\ncase UART_PORT_RS232:\r\nuart_remove_one_port(&ioc4_uart_rs232,\r\nthe_port);\r\nbreak;\r\n}\r\n}\r\n}\r\nport = control->ic_port[port_num].icp_port;\r\nif (!(port_num & 1) && port) {\r\npci_free_consistent(port->ip_pdev,\r\nTOTAL_RING_BUF_SIZE,\r\nport->ip_cpu_ringbuf,\r\nport->ip_dma_ringbuf);\r\nkfree(port);\r\n}\r\n}\r\nsoft = control->ic_soft;\r\nif (soft) {\r\nfree_irq(control->ic_irq, soft);\r\nif (soft->is_ioc4_serial_addr) {\r\niounmap(soft->is_ioc4_serial_addr);\r\nrelease_mem_region((unsigned long)\r\nsoft->is_ioc4_serial_addr,\r\nsizeof(struct ioc4_serial));\r\n}\r\nkfree(soft);\r\n}\r\nkfree(control);\r\nidd->idd_serial_data = NULL;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nioc4_serial_core_attach(struct pci_dev *pdev, int port_type)\r\n{\r\nstruct ioc4_port *port;\r\nstruct uart_port *the_port;\r\nstruct ioc4_driver_data *idd = pci_get_drvdata(pdev);\r\nstruct ioc4_control *control = idd->idd_serial_data;\r\nint port_num;\r\nint port_type_idx;\r\nstruct uart_driver *u_driver;\r\nDPRINT_CONFIG(("%s: attach pdev 0x%p - control 0x%p\n",\r\n__func__, pdev, (void *)control));\r\nif (!control)\r\nreturn -ENODEV;\r\nport_type_idx = (port_type == PROTO_RS232) ? UART_PORT_RS232\r\n: UART_PORT_RS422;\r\nu_driver = (port_type == PROTO_RS232) ? &ioc4_uart_rs232\r\n: &ioc4_uart_rs422;\r\nfor (port_num = 0; port_num < IOC4_NUM_SERIAL_PORTS; port_num++) {\r\nthe_port = &control->ic_port[port_num].icp_uart_port\r\n[port_type_idx];\r\nport = control->ic_port[port_num].icp_port;\r\nport->ip_all_ports[port_type_idx] = the_port;\r\nDPRINT_CONFIG(("%s: attach the_port 0x%p / port 0x%p : type %s\n",\r\n__func__, (void *)the_port,\r\n(void *)port,\r\nport_type == PROTO_RS232 ? "rs232" : "rs422"));\r\nthe_port->membase = (unsigned char __iomem *)1;\r\nthe_port->iobase = (pdev->bus->number << 16) | port_num;\r\nthe_port->line = (Num_of_ioc4_cards << 2) | port_num;\r\nthe_port->mapbase = port_type;\r\nthe_port->type = PORT_16550A;\r\nthe_port->fifosize = IOC4_FIFO_CHARS;\r\nthe_port->ops = &ioc4_ops;\r\nthe_port->irq = control->ic_irq;\r\nthe_port->dev = &pdev->dev;\r\nspin_lock_init(&the_port->lock);\r\nif (uart_add_one_port(u_driver, the_port) < 0) {\r\nprintk(KERN_WARNING\r\n"%s: unable to add port %d bus %d\n",\r\n__func__, the_port->line, pdev->bus->number);\r\n} else {\r\nDPRINT_CONFIG(\r\n("IOC4 serial port %d irq = %d, bus %d\n",\r\nthe_port->line, the_port->irq, pdev->bus->number));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nioc4_serial_attach_one(struct ioc4_driver_data *idd)\r\n{\r\nunsigned long tmp_addr1;\r\nstruct ioc4_serial __iomem *serial;\r\nstruct ioc4_soft *soft;\r\nstruct ioc4_control *control;\r\nint ret = 0;\r\nDPRINT_CONFIG(("%s (0x%p, 0x%p)\n", __func__, idd->idd_pdev,\r\nidd->idd_pci_id));\r\nif (idd->idd_variant == IOC4_VARIANT_PCI_RT)\r\nreturn 0;\r\ntmp_addr1 = idd->idd_bar0 + IOC4_SERIAL_OFFSET;\r\nif (!request_mem_region(tmp_addr1, sizeof(struct ioc4_serial),\r\n"sioc4_uart")) {\r\nprintk(KERN_WARNING\r\n"ioc4 (%p): unable to get request region for "\r\n"uart space\n", (void *)idd->idd_pdev);\r\nret = -ENODEV;\r\ngoto out1;\r\n}\r\nserial = ioremap(tmp_addr1, sizeof(struct ioc4_serial));\r\nif (!serial) {\r\nprintk(KERN_WARNING\r\n"ioc4 (%p) : unable to remap ioc4 serial register\n",\r\n(void *)idd->idd_pdev);\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nDPRINT_CONFIG(("%s : mem 0x%p, serial 0x%p\n",\r\n__func__, (void *)idd->idd_misc_regs,\r\n(void *)serial));\r\ncontrol = kzalloc(sizeof(struct ioc4_control), GFP_KERNEL);\r\nif (!control) {\r\nprintk(KERN_WARNING "ioc4_attach_one"\r\n": unable to get memory for the IOC4\n");\r\nret = -ENOMEM;\r\ngoto out2;\r\n}\r\nidd->idd_serial_data = control;\r\nsoft = kzalloc(sizeof(struct ioc4_soft), GFP_KERNEL);\r\nif (!soft) {\r\nprintk(KERN_WARNING\r\n"ioc4 (%p): unable to get memory for the soft struct\n",\r\n(void *)idd->idd_pdev);\r\nret = -ENOMEM;\r\ngoto out3;\r\n}\r\nspin_lock_init(&soft->is_ir_lock);\r\nsoft->is_ioc4_misc_addr = idd->idd_misc_regs;\r\nsoft->is_ioc4_serial_addr = serial;\r\nwritel(0xf << IOC4_SIO_CR_CMD_PULSE_SHIFT,\r\n&idd->idd_misc_regs->sio_cr.raw);\r\nwritel(IOC4_GPCR_UART0_MODESEL | IOC4_GPCR_UART1_MODESEL\r\n| IOC4_GPCR_UART2_MODESEL | IOC4_GPCR_UART3_MODESEL,\r\n&idd->idd_misc_regs->gpcr_s.raw);\r\nwrite_ireg(soft, ~0, IOC4_W_IEC, IOC4_SIO_INTR_TYPE);\r\nwritel(~0, &idd->idd_misc_regs->sio_ir.raw);\r\nwrite_ireg(soft, IOC4_OTHER_IR_SER_MEMERR, IOC4_W_IEC,\r\nIOC4_OTHER_INTR_TYPE);\r\nwritel(IOC4_OTHER_IR_SER_MEMERR, &idd->idd_misc_regs->other_ir.raw);\r\ncontrol->ic_soft = soft;\r\nif (!request_irq(idd->idd_pdev->irq, ioc4_intr, IRQF_SHARED,\r\n"sgi-ioc4serial", soft)) {\r\ncontrol->ic_irq = idd->idd_pdev->irq;\r\n} else {\r\nprintk(KERN_WARNING\r\n"%s : request_irq fails for IRQ 0x%x\n ",\r\n__func__, idd->idd_pdev->irq);\r\n}\r\nret = ioc4_attach_local(idd);\r\nif (ret)\r\ngoto out4;\r\nif ((ret = ioc4_serial_core_attach(idd->idd_pdev, PROTO_RS232)))\r\ngoto out4;\r\nif ((ret = ioc4_serial_core_attach(idd->idd_pdev, PROTO_RS422)))\r\ngoto out5;\r\nNum_of_ioc4_cards++;\r\nreturn ret;\r\nout5:\r\nioc4_serial_remove_one(idd);\r\nout4:\r\nkfree(soft);\r\nout3:\r\nkfree(control);\r\nout2:\r\nif (serial)\r\niounmap(serial);\r\nrelease_mem_region(tmp_addr1, sizeof(struct ioc4_serial));\r\nout1:\r\nreturn ret;\r\n}\r\nstatic int __init ioc4_serial_init(void)\r\n{\r\nint ret;\r\nif ((ret = uart_register_driver(&ioc4_uart_rs232)) < 0) {\r\nprintk(KERN_WARNING\r\n"%s: Couldn't register rs232 IOC4 serial driver\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif ((ret = uart_register_driver(&ioc4_uart_rs422)) < 0) {\r\nprintk(KERN_WARNING\r\n"%s: Couldn't register rs422 IOC4 serial driver\n",\r\n__func__);\r\ngoto out_uart_rs232;\r\n}\r\nret = ioc4_register_submodule(&ioc4_serial_submodule);\r\nif (ret)\r\ngoto out_uart_rs422;\r\nreturn 0;\r\nout_uart_rs422:\r\nuart_unregister_driver(&ioc4_uart_rs422);\r\nout_uart_rs232:\r\nuart_unregister_driver(&ioc4_uart_rs232);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit ioc4_serial_exit(void)\r\n{\r\nioc4_unregister_submodule(&ioc4_serial_submodule);\r\nuart_unregister_driver(&ioc4_uart_rs232);\r\nuart_unregister_driver(&ioc4_uart_rs422);\r\n}
