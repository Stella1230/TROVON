void ctcm_ccw_check_rc(struct channel *ch, int rc, char *msg)\r\n{\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): %s: %04x\n",\r\nCTCM_FUNTAIL, ch->id, msg, rc);\r\nswitch (rc) {\r\ncase -EBUSY:\r\npr_info("%s: The communication peer is busy\n",\r\nch->id);\r\nfsm_event(ch->fsm, CTC_EVENT_IO_EBUSY, ch);\r\nbreak;\r\ncase -ENODEV:\r\npr_err("%s: The specified target device is not valid\n",\r\nch->id);\r\nfsm_event(ch->fsm, CTC_EVENT_IO_ENODEV, ch);\r\nbreak;\r\ndefault:\r\npr_err("An I/O operation resulted in error %04x\n",\r\nrc);\r\nfsm_event(ch->fsm, CTC_EVENT_IO_UNKNOWN, ch);\r\n}\r\n}\r\nvoid ctcm_purge_skb_queue(struct sk_buff_head *q)\r\n{\r\nstruct sk_buff *skb;\r\nCTCM_DBF_TEXT(TRACE, CTC_DBF_DEBUG, __func__);\r\nwhile ((skb = skb_dequeue(q))) {\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic void ctcm_action_nop(fsm_instance *fi, int event, void *arg)\r\n{\r\n}\r\nstatic void chx_txdone(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct sk_buff *skb;\r\nint first = 1;\r\nint i;\r\nunsigned long duration;\r\nstruct timespec done_stamp = current_kernel_time();\r\nCTCM_PR_DEBUG("%s(%s): %s\n", __func__, ch->id, dev->name);\r\nduration =\r\n(done_stamp.tv_sec - ch->prof.send_stamp.tv_sec) * 1000000 +\r\n(done_stamp.tv_nsec - ch->prof.send_stamp.tv_nsec) / 1000;\r\nif (duration > ch->prof.tx_time)\r\nch->prof.tx_time = duration;\r\nif (ch->irb->scsw.cmd.count != 0)\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\r\n"%s(%s): TX not complete, remaining %d bytes",\r\nCTCM_FUNTAIL, dev->name, ch->irb->scsw.cmd.count);\r\nfsm_deltimer(&ch->timer);\r\nwhile ((skb = skb_dequeue(&ch->io_queue))) {\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;\r\nif (first) {\r\npriv->stats.tx_bytes += 2;\r\nfirst = 0;\r\n}\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nspin_lock(&ch->collect_lock);\r\nclear_normalized_cda(&ch->ccw[4]);\r\nif (ch->collect_len > 0) {\r\nint rc;\r\nif (ctcm_checkalloc_buffer(ch)) {\r\nspin_unlock(&ch->collect_lock);\r\nreturn;\r\n}\r\nch->trans_skb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nif (ch->prof.maxmulti < (ch->collect_len + 2))\r\nch->prof.maxmulti = ch->collect_len + 2;\r\nif (ch->prof.maxcqueue < skb_queue_len(&ch->collect_queue))\r\nch->prof.maxcqueue = skb_queue_len(&ch->collect_queue);\r\n*((__u16 *)skb_put(ch->trans_skb, 2)) = ch->collect_len + 2;\r\ni = 0;\r\nwhile ((skb = skb_dequeue(&ch->collect_queue))) {\r\nskb_copy_from_linear_data(skb,\r\nskb_put(ch->trans_skb, skb->len), skb->len);\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\ni++;\r\n}\r\nch->collect_len = 0;\r\nspin_unlock(&ch->collect_lock);\r\nch->ccw[1].count = ch->trans_skb->len;\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\nch->prof.send_stamp = current_kernel_time();\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nch->prof.doios_multi++;\r\nif (rc != 0) {\r\npriv->stats.tx_dropped += i;\r\npriv->stats.tx_errors += i;\r\nfsm_deltimer(&ch->timer);\r\nctcm_ccw_check_rc(ch, rc, "chained TX");\r\n}\r\n} else {\r\nspin_unlock(&ch->collect_lock);\r\nfsm_newstate(fi, CTC_STATE_TXIDLE);\r\n}\r\nctcm_clear_busy_do(dev);\r\n}\r\nvoid ctcm_chx_txidle(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCM_PR_DEBUG("%s(%s): %s\n", __func__, ch->id, dev->name);\r\nfsm_deltimer(&ch->timer);\r\nfsm_newstate(fi, CTC_STATE_TXIDLE);\r\nfsm_event(priv->fsm, DEV_EVENT_TXUP, ch->netdev);\r\n}\r\nstatic void chx_rx(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nint len = ch->max_bufsize - ch->irb->scsw.cmd.count;\r\nstruct sk_buff *skb = ch->trans_skb;\r\n__u16 block_len = *((__u16 *)skb->data);\r\nint check_len;\r\nint rc;\r\nfsm_deltimer(&ch->timer);\r\nif (len < 8) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s(%s): got packet with length %d < 8\n",\r\nCTCM_FUNTAIL, dev->name, len);\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\ngoto again;\r\n}\r\nif (len > ch->max_bufsize) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s(%s): got packet with length %d > %d\n",\r\nCTCM_FUNTAIL, dev->name, len, ch->max_bufsize);\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\ngoto again;\r\n}\r\nswitch (ch->protocol) {\r\ncase CTCM_PROTO_S390:\r\ncase CTCM_PROTO_OS390:\r\ncheck_len = block_len + 2;\r\nbreak;\r\ndefault:\r\ncheck_len = block_len;\r\nbreak;\r\n}\r\nif ((len < block_len) || (len > check_len)) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s(%s): got block length %d != rx length %d\n",\r\nCTCM_FUNTAIL, dev->name, block_len, len);\r\nif (do_debug)\r\nctcmpc_dump_skb(skb, 0);\r\n*((__u16 *)skb->data) = len;\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\ngoto again;\r\n}\r\nif (block_len > 2) {\r\n*((__u16 *)skb->data) = block_len - 2;\r\nctcm_unpack_skb(ch, skb);\r\n}\r\nagain:\r\nskb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(skb);\r\nskb->len = 0;\r\nif (ctcm_checkalloc_buffer(ch))\r\nreturn;\r\nch->ccw[1].count = ch->max_bufsize;\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nif (rc != 0)\r\nctcm_ccw_check_rc(ch, rc, "normal RX");\r\n}\r\nstatic void chx_firstio(fsm_instance *fi, int event, void *arg)\r\n{\r\nint rc;\r\nstruct channel *ch = arg;\r\nint fsmstate = fsm_getstate(fi);\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s(%s) : %02x",\r\nCTCM_FUNTAIL, ch->id, fsmstate);\r\nch->sense_rc = 0;\r\nif (fsmstate == CTC_STATE_TXIDLE)\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\r\n"%s(%s): remote side issued READ?, init.\n",\r\nCTCM_FUNTAIL, ch->id);\r\nfsm_deltimer(&ch->timer);\r\nif (ctcm_checkalloc_buffer(ch))\r\nreturn;\r\nif ((fsmstate == CTC_STATE_SETUPWAIT) &&\r\n(ch->protocol == CTCM_PROTO_OS390)) {\r\nif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\r\n*((__u16 *)ch->trans_skb->data) = CTCM_INITIAL_BLOCKLEN;\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC,\r\nCTC_EVENT_TIMER, ch);\r\nchx_rxidle(fi, event, arg);\r\n} else {\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nfsm_newstate(fi, CTC_STATE_TXIDLE);\r\nfsm_event(priv->fsm, DEV_EVENT_TXUP, dev);\r\n}\r\nreturn;\r\n}\r\nif ((CHANNEL_DIRECTION(ch->flags) == CTCM_WRITE) ||\r\n(ch->protocol != CTCM_PROTO_S390))\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\n*((__u16 *)ch->trans_skb->data) = CTCM_INITIAL_BLOCKLEN;\r\nch->ccw[1].count = 2;\r\nfsm_newstate(fi, (CHANNEL_DIRECTION(ch->flags) == CTCM_READ)\r\n? CTC_STATE_RXINIT : CTC_STATE_TXINIT);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nif (rc != 0) {\r\nfsm_deltimer(&ch->timer);\r\nfsm_newstate(fi, CTC_STATE_SETUPWAIT);\r\nctcm_ccw_check_rc(ch, rc, "init IO");\r\n}\r\nif ((CHANNEL_DIRECTION(ch->flags) == CTCM_READ) &&\r\n(ch->protocol == CTCM_PROTO_S390)) {\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nfsm_event(priv->fsm, DEV_EVENT_RXUP, dev);\r\n}\r\n}\r\nstatic void chx_rxidle(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\n__u16 buflen;\r\nint rc;\r\nfsm_deltimer(&ch->timer);\r\nbuflen = *((__u16 *)ch->trans_skb->data);\r\nCTCM_PR_DEBUG("%s: %s: Initial RX count = %d\n",\r\n__func__, dev->name, buflen);\r\nif (buflen >= CTCM_INITIAL_BLOCKLEN) {\r\nif (ctcm_checkalloc_buffer(ch))\r\nreturn;\r\nch->ccw[1].count = ch->max_bufsize;\r\nfsm_newstate(fi, CTC_STATE_RXIDLE);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nif (rc != 0) {\r\nfsm_newstate(fi, CTC_STATE_RXINIT);\r\nctcm_ccw_check_rc(ch, rc, "initial RX");\r\n} else\r\nfsm_event(priv->fsm, DEV_EVENT_RXUP, dev);\r\n} else {\r\nCTCM_PR_DEBUG("%s: %s: Initial RX count %d not %d\n",\r\n__func__, dev->name,\r\nbuflen, CTCM_INITIAL_BLOCKLEN);\r\nchx_firstio(fi, event, arg);\r\n}\r\n}\r\nstatic void ctcm_chx_setmode(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nint rc;\r\nunsigned long saveflags = 0;\r\nint timeout = CTCM_TIME_5_SEC;\r\nfsm_deltimer(&ch->timer);\r\nif (IS_MPC(ch)) {\r\ntimeout = 1500;\r\nCTCM_PR_DEBUG("enter %s: cp=%i ch=0x%p id=%s\n",\r\n__func__, smp_processor_id(), ch, ch->id);\r\n}\r\nfsm_addtimer(&ch->timer, timeout, CTC_EVENT_TIMER, ch);\r\nfsm_newstate(fi, CTC_STATE_SETUPWAIT);\r\nCTCM_CCW_DUMP((char *)&ch->ccw[6], sizeof(struct ccw1) * 2);\r\nif (event == CTC_EVENT_TIMER)\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[6],\r\n(unsigned long)ch, 0xff, 0);\r\nif (event == CTC_EVENT_TIMER)\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0) {\r\nfsm_deltimer(&ch->timer);\r\nfsm_newstate(fi, CTC_STATE_STARTWAIT);\r\nctcm_ccw_check_rc(ch, rc, "set Mode");\r\n} else\r\nch->retry = 0;\r\n}\r\nstatic void ctcm_chx_start(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nunsigned long saveflags;\r\nint rc;\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_INFO, "%s(%s): %s",\r\nCTCM_FUNTAIL, ch->id,\r\n(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ? "RX" : "TX");\r\nif (ch->trans_skb != NULL) {\r\nclear_normalized_cda(&ch->ccw[1]);\r\ndev_kfree_skb(ch->trans_skb);\r\nch->trans_skb = NULL;\r\n}\r\nif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\r\nch->ccw[1].cmd_code = CCW_CMD_READ;\r\nch->ccw[1].flags = CCW_FLAG_SLI;\r\nch->ccw[1].count = 0;\r\n} else {\r\nch->ccw[1].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[1].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[1].count = 0;\r\n}\r\nif (ctcm_checkalloc_buffer(ch)) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\r\n"%s(%s): %s trans_skb alloc delayed "\r\n"until first transfer",\r\nCTCM_FUNTAIL, ch->id,\r\n(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ?\r\n"RX" : "TX");\r\n}\r\nch->ccw[0].cmd_code = CCW_CMD_PREPARE;\r\nch->ccw[0].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[0].count = 0;\r\nch->ccw[0].cda = 0;\r\nch->ccw[2].cmd_code = CCW_CMD_NOOP;\r\nch->ccw[2].flags = CCW_FLAG_SLI;\r\nch->ccw[2].count = 0;\r\nch->ccw[2].cda = 0;\r\nmemcpy(&ch->ccw[3], &ch->ccw[0], sizeof(struct ccw1) * 3);\r\nch->ccw[4].cda = 0;\r\nch->ccw[4].flags &= ~CCW_FLAG_IDA;\r\nfsm_newstate(fi, CTC_STATE_STARTWAIT);\r\nfsm_addtimer(&ch->timer, 1000, CTC_EVENT_TIMER, ch);\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nrc = ccw_device_halt(ch->cdev, (unsigned long)ch);\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0) {\r\nif (rc != -EBUSY)\r\nfsm_deltimer(&ch->timer);\r\nctcm_ccw_check_rc(ch, rc, "initial HaltIO");\r\n}\r\n}\r\nstatic void ctcm_chx_haltio(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nunsigned long saveflags = 0;\r\nint rc;\r\nint oldstate;\r\nfsm_deltimer(&ch->timer);\r\nif (IS_MPC(ch))\r\nfsm_deltimer(&ch->sweep_timer);\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\nif (event == CTC_EVENT_STOP)\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\noldstate = fsm_getstate(fi);\r\nfsm_newstate(fi, CTC_STATE_TERM);\r\nrc = ccw_device_halt(ch->cdev, (unsigned long)ch);\r\nif (event == CTC_EVENT_STOP)\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0 && rc != -EBUSY) {\r\nfsm_deltimer(&ch->timer);\r\nif (event != CTC_EVENT_STOP) {\r\nfsm_newstate(fi, oldstate);\r\nctcm_ccw_check_rc(ch, rc, (char *)__func__);\r\n}\r\n}\r\n}\r\nstatic void ctcm_chx_cleanup(fsm_instance *fi, int state,\r\nstruct channel *ch)\r\n{\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_NOTICE,\r\n"%s(%s): %s[%d]\n",\r\nCTCM_FUNTAIL, dev->name, ch->id, state);\r\nfsm_deltimer(&ch->timer);\r\nif (IS_MPC(ch))\r\nfsm_deltimer(&ch->sweep_timer);\r\nfsm_newstate(fi, state);\r\nif (state == CTC_STATE_STOPPED && ch->trans_skb != NULL) {\r\nclear_normalized_cda(&ch->ccw[1]);\r\ndev_kfree_skb_any(ch->trans_skb);\r\nch->trans_skb = NULL;\r\n}\r\nch->th_seg = 0x00;\r\nch->th_seq_num = 0x00;\r\nif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\r\nskb_queue_purge(&ch->io_queue);\r\nfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\r\n} else {\r\nctcm_purge_skb_queue(&ch->io_queue);\r\nif (IS_MPC(ch))\r\nctcm_purge_skb_queue(&ch->sweep_queue);\r\nspin_lock(&ch->collect_lock);\r\nctcm_purge_skb_queue(&ch->collect_queue);\r\nch->collect_len = 0;\r\nspin_unlock(&ch->collect_lock);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\n}\r\n}\r\nstatic void ctcm_chx_stopped(fsm_instance *fi, int event, void *arg)\r\n{\r\nctcm_chx_cleanup(fi, CTC_STATE_STOPPED, arg);\r\n}\r\nstatic void ctcm_chx_stop(fsm_instance *fi, int event, void *arg)\r\n{\r\nfsm_newstate(fi, CTC_STATE_STOPPED);\r\n}\r\nstatic void ctcm_chx_fail(fsm_instance *fi, int event, void *arg)\r\n{\r\nctcm_chx_cleanup(fi, CTC_STATE_NOTOP, arg);\r\n}\r\nstatic void ctcm_chx_setuperr(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nif ((fsm_getstate(fi) == CTC_STATE_SETUPWAIT) &&\r\n((event == CTC_EVENT_UC_RCRESET) ||\r\n(event == CTC_EVENT_UC_RSRESET))) {\r\nfsm_newstate(fi, CTC_STATE_STARTRETRY);\r\nfsm_deltimer(&ch->timer);\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\nif (!IS_MPC(ch) &&\r\n(CHANNEL_DIRECTION(ch->flags) == CTCM_READ)) {\r\nint rc = ccw_device_halt(ch->cdev, (unsigned long)ch);\r\nif (rc != 0)\r\nctcm_ccw_check_rc(ch, rc,\r\n"HaltIO in chx_setuperr");\r\n}\r\nreturn;\r\n}\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_CRIT,\r\n"%s(%s) : %s error during %s channel setup state=%s\n",\r\nCTCM_FUNTAIL, dev->name, ctc_ch_event_names[event],\r\n(CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ? "RX" : "TX",\r\nfsm_getstate_str(fi));\r\nif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\r\nfsm_newstate(fi, CTC_STATE_RXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\r\n} else {\r\nfsm_newstate(fi, CTC_STATE_TXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\n}\r\n}\r\nstatic void ctcm_chx_restart(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nunsigned long saveflags = 0;\r\nint oldstate;\r\nint rc;\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s: %s[%d] of %s\n",\r\nCTCM_FUNTAIL, ch->id, event, dev->name);\r\nfsm_deltimer(&ch->timer);\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\noldstate = fsm_getstate(fi);\r\nfsm_newstate(fi, CTC_STATE_STARTWAIT);\r\nif (event == CTC_EVENT_TIMER)\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nrc = ccw_device_halt(ch->cdev, (unsigned long)ch);\r\nif (event == CTC_EVENT_TIMER)\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0) {\r\nif (rc != -EBUSY) {\r\nfsm_deltimer(&ch->timer);\r\nfsm_newstate(fi, oldstate);\r\n}\r\nctcm_ccw_check_rc(ch, rc, "HaltIO in ctcm_chx_restart");\r\n}\r\n}\r\nstatic void ctcm_chx_rxiniterr(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nif (event == CTC_EVENT_TIMER) {\r\nif (!IS_MPCDEV(dev))\r\nfsm_deltimer(&ch->timer);\r\nif (ch->retry++ < 3)\r\nctcm_chx_restart(fi, event, arg);\r\nelse {\r\nfsm_newstate(fi, CTC_STATE_RXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\r\n}\r\n} else {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): %s in %s", CTCM_FUNTAIL, ch->id,\r\nctc_ch_event_names[event], fsm_getstate_str(fi));\r\ndev_warn(&dev->dev,\r\n"Initialization failed with RX/TX init handshake "\r\n"error %s\n", ctc_ch_event_names[event]);\r\n}\r\n}\r\nstatic void ctcm_chx_rxinitfail(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): RX %s busy, init. fail",\r\nCTCM_FUNTAIL, dev->name, ch->id);\r\nfsm_newstate(fi, CTC_STATE_RXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\r\n}\r\nstatic void ctcm_chx_rxdisc(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct channel *ch2;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_NOTICE,\r\n"%s: %s: remote disconnect - re-init ...",\r\nCTCM_FUNTAIL, dev->name);\r\nfsm_deltimer(&ch->timer);\r\nfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\nfsm_newstate(fi, CTC_STATE_DTERM);\r\nch2 = priv->channel[CTCM_WRITE];\r\nfsm_newstate(ch2->fsm, CTC_STATE_DTERM);\r\nccw_device_halt(ch->cdev, (unsigned long)ch);\r\nccw_device_halt(ch2->cdev, (unsigned long)ch2);\r\n}\r\nstatic void ctcm_chx_txiniterr(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nif (event == CTC_EVENT_TIMER) {\r\nfsm_deltimer(&ch->timer);\r\nif (ch->retry++ < 3)\r\nctcm_chx_restart(fi, event, arg);\r\nelse {\r\nfsm_newstate(fi, CTC_STATE_TXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\n}\r\n} else {\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s(%s): %s in %s", CTCM_FUNTAIL, ch->id,\r\nctc_ch_event_names[event], fsm_getstate_str(fi));\r\ndev_warn(&dev->dev,\r\n"Initialization failed with RX/TX init handshake "\r\n"error %s\n", ctc_ch_event_names[event]);\r\n}\r\n}\r\nstatic void ctcm_chx_txretry(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct sk_buff *skb;\r\nCTCM_PR_DEBUG("Enter: %s: cp=%i ch=0x%p id=%s\n",\r\n__func__, smp_processor_id(), ch, ch->id);\r\nfsm_deltimer(&ch->timer);\r\nif (ch->retry++ > 3) {\r\nstruct mpc_group *gptr = priv->mpcg;\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_INFO,\r\n"%s: %s: retries exceeded",\r\nCTCM_FUNTAIL, ch->id);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\nif (!(gptr && (fsm_getstate(gptr->fsm) != MPCG_STATE_READY)))\r\nctcm_chx_restart(fi, event, arg);\r\ngoto done;\r\n}\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_DEBUG,\r\n"%s : %s: retry %d",\r\nCTCM_FUNTAIL, ch->id, ch->retry);\r\nskb = skb_peek(&ch->io_queue);\r\nif (skb) {\r\nint rc = 0;\r\nunsigned long saveflags = 0;\r\nclear_normalized_cda(&ch->ccw[4]);\r\nch->ccw[4].count = skb->len;\r\nif (set_normalized_cda(&ch->ccw[4], skb->data)) {\r\nCTCM_DBF_TEXT_(TRACE, CTC_DBF_INFO,\r\n"%s: %s: IDAL alloc failed",\r\nCTCM_FUNTAIL, ch->id);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\nctcm_chx_restart(fi, event, arg);\r\ngoto done;\r\n}\r\nfsm_addtimer(&ch->timer, 1000, CTC_EVENT_TIMER, ch);\r\nif (event == CTC_EVENT_TIMER)\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (do_debug_ccw)\r\nctcmpc_dumpit((char *)&ch->ccw[3],\r\nsizeof(struct ccw1) * 3);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[3],\r\n(unsigned long)ch, 0xff, 0);\r\nif (event == CTC_EVENT_TIMER)\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev),\r\nsaveflags);\r\nif (rc != 0) {\r\nfsm_deltimer(&ch->timer);\r\nctcm_ccw_check_rc(ch, rc, "TX in chx_txretry");\r\nctcm_purge_skb_queue(&ch->io_queue);\r\n}\r\n}\r\ndone:\r\nreturn;\r\n}\r\nstatic void ctcm_chx_iofatal(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nint rd = CHANNEL_DIRECTION(ch->flags);\r\nfsm_deltimer(&ch->timer);\r\nCTCM_DBF_TEXT_(ERROR, CTC_DBF_ERROR,\r\n"%s: %s: %s unrecoverable channel error",\r\nCTCM_FUNTAIL, ch->id, rd == CTCM_READ ? "RX" : "TX");\r\nif (IS_MPC(ch)) {\r\npriv->stats.tx_dropped++;\r\npriv->stats.tx_errors++;\r\n}\r\nif (rd == CTCM_READ) {\r\nfsm_newstate(fi, CTC_STATE_RXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_RXDOWN, dev);\r\n} else {\r\nfsm_newstate(fi, CTC_STATE_TXERR);\r\nfsm_event(priv->fsm, DEV_EVENT_TXDOWN, dev);\r\n}\r\n}\r\nstatic void ctcmpc_chx_txdone(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct sk_buff *skb;\r\nint first = 1;\r\nint i;\r\n__u32 data_space;\r\nunsigned long duration;\r\nstruct sk_buff *peekskb;\r\nint rc;\r\nstruct th_header *header;\r\nstruct pdu *p_header;\r\nstruct timespec done_stamp = current_kernel_time();\r\nCTCM_PR_DEBUG("Enter %s: %s cp:%i\n",\r\n__func__, dev->name, smp_processor_id());\r\nduration =\r\n(done_stamp.tv_sec - ch->prof.send_stamp.tv_sec) * 1000000 +\r\n(done_stamp.tv_nsec - ch->prof.send_stamp.tv_nsec) / 1000;\r\nif (duration > ch->prof.tx_time)\r\nch->prof.tx_time = duration;\r\nif (ch->irb->scsw.cmd.count != 0)\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\r\n"%s(%s): TX not complete, remaining %d bytes",\r\nCTCM_FUNTAIL, dev->name, ch->irb->scsw.cmd.count);\r\nfsm_deltimer(&ch->timer);\r\nwhile ((skb = skb_dequeue(&ch->io_queue))) {\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += skb->len - TH_HEADER_LENGTH;\r\nif (first) {\r\npriv->stats.tx_bytes += 2;\r\nfirst = 0;\r\n}\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nspin_lock(&ch->collect_lock);\r\nclear_normalized_cda(&ch->ccw[4]);\r\nif ((ch->collect_len <= 0) || (grp->in_sweep != 0)) {\r\nspin_unlock(&ch->collect_lock);\r\nfsm_newstate(fi, CTC_STATE_TXIDLE);\r\ngoto done;\r\n}\r\nif (ctcm_checkalloc_buffer(ch)) {\r\nspin_unlock(&ch->collect_lock);\r\ngoto done;\r\n}\r\nch->trans_skb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nif (ch->prof.maxmulti < (ch->collect_len + TH_HEADER_LENGTH))\r\nch->prof.maxmulti = ch->collect_len + TH_HEADER_LENGTH;\r\nif (ch->prof.maxcqueue < skb_queue_len(&ch->collect_queue))\r\nch->prof.maxcqueue = skb_queue_len(&ch->collect_queue);\r\ni = 0;\r\np_header = NULL;\r\ndata_space = grp->group_max_buflen - TH_HEADER_LENGTH;\r\nCTCM_PR_DBGDATA("%s: building trans_skb from collect_q"\r\n" data_space:%04x\n",\r\n__func__, data_space);\r\nwhile ((skb = skb_dequeue(&ch->collect_queue))) {\r\nmemcpy(skb_put(ch->trans_skb, skb->len), skb->data, skb->len);\r\np_header = (struct pdu *)\r\n(skb_tail_pointer(ch->trans_skb) - skb->len);\r\np_header->pdu_flag = 0x00;\r\nif (skb->protocol == ntohs(ETH_P_SNAP))\r\np_header->pdu_flag |= 0x60;\r\nelse\r\np_header->pdu_flag |= 0x20;\r\nCTCM_PR_DBGDATA("%s: trans_skb len:%04x \n",\r\n__func__, ch->trans_skb->len);\r\nCTCM_PR_DBGDATA("%s: pdu header and data for up"\r\n" to 32 bytes sent to vtam\n", __func__);\r\nCTCM_D3_DUMP((char *)p_header, min_t(int, skb->len, 32));\r\nch->collect_len -= skb->len;\r\ndata_space -= skb->len;\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += skb->len;\r\natomic_dec(&skb->users);\r\ndev_kfree_skb_any(skb);\r\npeekskb = skb_peek(&ch->collect_queue);\r\nif (peekskb->len > data_space)\r\nbreak;\r\ni++;\r\n}\r\nif (p_header)\r\np_header->pdu_flag |= PDU_LAST;\r\nheader = kzalloc(TH_HEADER_LENGTH, gfp_type());\r\nif (!header) {\r\nspin_unlock(&ch->collect_lock);\r\nfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n}\r\nheader->th_ch_flag = TH_HAS_PDU;\r\nch->th_seq_num++;\r\nheader->th_seq_num = ch->th_seq_num;\r\nCTCM_PR_DBGDATA("%s: ToVTAM_th_seq= %08x\n" ,\r\n__func__, ch->th_seq_num);\r\nmemcpy(skb_push(ch->trans_skb, TH_HEADER_LENGTH), header,\r\nTH_HEADER_LENGTH);\r\nkfree(header);\r\nCTCM_PR_DBGDATA("%s: trans_skb len:%04x \n",\r\n__func__, ch->trans_skb->len);\r\nCTCM_PR_DBGDATA("%s: up-to-50 bytes of trans_skb "\r\n"data to vtam from collect_q\n", __func__);\r\nCTCM_D3_DUMP((char *)ch->trans_skb->data,\r\nmin_t(int, ch->trans_skb->len, 50));\r\nspin_unlock(&ch->collect_lock);\r\nclear_normalized_cda(&ch->ccw[1]);\r\nCTCM_PR_DBGDATA("ccwcda=0x%p data=0x%p\n",\r\n(void *)(unsigned long)ch->ccw[1].cda,\r\nch->trans_skb->data);\r\nch->ccw[1].count = ch->max_bufsize;\r\nif (set_normalized_cda(&ch->ccw[1], ch->trans_skb->data)) {\r\ndev_kfree_skb_any(ch->trans_skb);\r\nch->trans_skb = NULL;\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ERROR,\r\n"%s: %s: IDAL alloc failed",\r\nCTCM_FUNTAIL, ch->id);\r\nfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\r\nreturn;\r\n}\r\nCTCM_PR_DBGDATA("ccwcda=0x%p data=0x%p\n",\r\n(void *)(unsigned long)ch->ccw[1].cda,\r\nch->trans_skb->data);\r\nch->ccw[1].count = ch->trans_skb->len;\r\nfsm_addtimer(&ch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, ch);\r\nch->prof.send_stamp = current_kernel_time();\r\nif (do_debug_ccw)\r\nctcmpc_dumpit((char *)&ch->ccw[0], sizeof(struct ccw1) * 3);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nch->prof.doios_multi++;\r\nif (rc != 0) {\r\npriv->stats.tx_dropped += i;\r\npriv->stats.tx_errors += i;\r\nfsm_deltimer(&ch->timer);\r\nctcm_ccw_check_rc(ch, rc, "chained TX");\r\n}\r\ndone:\r\nctcm_clear_busy(dev);\r\nreturn;\r\n}\r\nstatic void ctcmpc_chx_rx(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct sk_buff *skb = ch->trans_skb;\r\nstruct sk_buff *new_skb;\r\nunsigned long saveflags = 0;\r\nint len = ch->max_bufsize - ch->irb->scsw.cmd.count;\r\nCTCM_PR_DEBUG("%s: %s: cp:%i %s maxbuf : %04x, len: %04x\n",\r\nCTCM_FUNTAIL, dev->name, smp_processor_id(),\r\nch->id, ch->max_bufsize, len);\r\nfsm_deltimer(&ch->timer);\r\nif (skb == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): TRANS_SKB = NULL",\r\nCTCM_FUNTAIL, dev->name);\r\ngoto again;\r\n}\r\nif (len < TH_HEADER_LENGTH) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): packet length %d to short",\r\nCTCM_FUNTAIL, dev->name, len);\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\n} else {\r\n__u32 block_len = len;\r\nlen = TH_HEADER_LENGTH + XID2_LENGTH + 4;\r\nnew_skb = __dev_alloc_skb(ch->max_bufsize, GFP_ATOMIC);\r\nif (new_skb == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%d): skb allocation failed",\r\nCTCM_FUNTAIL, dev->name);\r\nfsm_event(priv->mpcg->fsm, MPCG_EVENT_INOP, dev);\r\ngoto again;\r\n}\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_RESET:\r\ncase MPCG_STATE_INOP:\r\ndev_kfree_skb_any(new_skb);\r\nbreak;\r\ncase MPCG_STATE_FLOWC:\r\ncase MPCG_STATE_READY:\r\nmemcpy(skb_put(new_skb, block_len),\r\nskb->data, block_len);\r\nskb_queue_tail(&ch->io_queue, new_skb);\r\ntasklet_schedule(&ch->ch_tasklet);\r\nbreak;\r\ndefault:\r\nmemcpy(skb_put(new_skb, len), skb->data, len);\r\nskb_queue_tail(&ch->io_queue, new_skb);\r\ntasklet_hi_schedule(&ch->ch_tasklet);\r\nbreak;\r\n}\r\n}\r\nagain:\r\nswitch (fsm_getstate(grp->fsm)) {\r\nint rc, dolock;\r\ncase MPCG_STATE_FLOWC:\r\ncase MPCG_STATE_READY:\r\nif (ctcm_checkalloc_buffer(ch))\r\nbreak;\r\nch->trans_skb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nch->ccw[1].count = ch->max_bufsize;\r\nif (do_debug_ccw)\r\nctcmpc_dumpit((char *)&ch->ccw[0],\r\nsizeof(struct ccw1) * 3);\r\ndolock = !in_irq();\r\nif (dolock)\r\nspin_lock_irqsave(\r\nget_ccwdev_lock(ch->cdev), saveflags);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nif (dolock)\r\nspin_unlock_irqrestore(\r\nget_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0)\r\nctcm_ccw_check_rc(ch, rc, "normal RX");\r\ndefault:\r\nbreak;\r\n}\r\nCTCM_PR_DEBUG("Exit %s: %s, ch=0x%p, id=%s\n",\r\n__func__, dev->name, ch, ch->id);\r\n}\r\nstatic void ctcmpc_chx_firstio(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *gptr = priv->mpcg;\r\nCTCM_PR_DEBUG("Enter %s: id=%s, ch=0x%p\n",\r\n__func__, ch->id, ch);\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_INFO,\r\n"%s: %s: chstate:%i, grpstate:%i, prot:%i\n",\r\nCTCM_FUNTAIL, ch->id, fsm_getstate(fi),\r\nfsm_getstate(gptr->fsm), ch->protocol);\r\nif (fsm_getstate(fi) == CTC_STATE_TXIDLE)\r\nMPC_DBF_DEV_NAME(TRACE, dev, "remote side issued READ? ");\r\nfsm_deltimer(&ch->timer);\r\nif (ctcm_checkalloc_buffer(ch))\r\ngoto done;\r\nswitch (fsm_getstate(fi)) {\r\ncase CTC_STATE_STARTRETRY:\r\ncase CTC_STATE_SETUPWAIT:\r\nif (CHANNEL_DIRECTION(ch->flags) == CTCM_READ) {\r\nctcmpc_chx_rxidle(fi, event, arg);\r\n} else {\r\nfsm_newstate(fi, CTC_STATE_TXIDLE);\r\nfsm_event(priv->fsm, DEV_EVENT_TXUP, dev);\r\n}\r\ngoto done;\r\ndefault:\r\nbreak;\r\n};\r\nfsm_newstate(fi, (CHANNEL_DIRECTION(ch->flags) == CTCM_READ)\r\n? CTC_STATE_RXINIT : CTC_STATE_TXINIT);\r\ndone:\r\nCTCM_PR_DEBUG("Exit %s: id=%s, ch=0x%p\n",\r\n__func__, ch->id, ch);\r\nreturn;\r\n}\r\nvoid ctcmpc_chx_rxidle(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nint rc;\r\nunsigned long saveflags = 0;\r\nfsm_deltimer(&ch->timer);\r\nCTCM_PR_DEBUG("%s: %s: %s: cp:%i, chstate:%i grpstate:%i\n",\r\n__func__, ch->id, dev->name, smp_processor_id(),\r\nfsm_getstate(fi), fsm_getstate(grp->fsm));\r\nfsm_newstate(fi, CTC_STATE_RXIDLE);\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_FLOWC:\r\ncase MPCG_STATE_READY:\r\nif (ctcm_checkalloc_buffer(ch))\r\ngoto done;\r\nch->trans_skb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nch->ccw[1].count = ch->max_bufsize;\r\nCTCM_CCW_DUMP((char *)&ch->ccw[0], sizeof(struct ccw1) * 3);\r\nif (event == CTC_EVENT_START)\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[0],\r\n(unsigned long)ch, 0xff, 0);\r\nif (event == CTC_EVENT_START)\r\nspin_unlock_irqrestore(\r\nget_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0) {\r\nfsm_newstate(fi, CTC_STATE_RXINIT);\r\nctcm_ccw_check_rc(ch, rc, "initial RX");\r\ngoto done;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfsm_event(priv->fsm, DEV_EVENT_RXUP, dev);\r\ndone:\r\nreturn;\r\n}\r\nstatic void ctcmpc_chx_attn(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("%s(%s): %s(ch=0x%p), cp=%i, ChStat:%s, GrpStat:%s\n",\r\n__func__, dev->name, ch->id, ch, smp_processor_id(),\r\nfsm_getstate_str(ch->fsm), fsm_getstate_str(grp->fsm));\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_XID2INITW:\r\nif (!ch->in_mpcgroup)\r\nbreak;\r\nif (fsm_getstate(ch->fsm) == CH_XID0_PENDING) {\r\nfsm_deltimer(&grp->timer);\r\nfsm_addtimer(&grp->timer,\r\nMPC_XID_TIMEOUT_VALUE,\r\nMPCG_EVENT_TIMER, dev);\r\nfsm_event(grp->fsm, MPCG_EVENT_XID0DO, ch);\r\n} else if (fsm_getstate(ch->fsm) < CH_XID7_PENDING1)\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING1);\r\nbreak;\r\ncase MPCG_STATE_XID2INITX:\r\ncase MPCG_STATE_XID0IOWAIT:\r\ncase MPCG_STATE_XID0IOWAIX:\r\nif (fsm_getstate(ch->fsm) < CH_XID7_PENDING1)\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING1);\r\nbreak;\r\ncase MPCG_STATE_XID7INITW:\r\ncase MPCG_STATE_XID7INITX:\r\ncase MPCG_STATE_XID7INITI:\r\ncase MPCG_STATE_XID7INITZ:\r\nswitch (fsm_getstate(ch->fsm)) {\r\ncase CH_XID7_PENDING:\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING1);\r\nbreak;\r\ncase CH_XID7_PENDING2:\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING3);\r\nbreak;\r\n}\r\nfsm_event(grp->fsm, MPCG_EVENT_XID7DONE, dev);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void ctcmpc_chx_attnbusy(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("%s(%s): %s\n ChState:%s GrpState:%s\n",\r\n__func__, dev->name, ch->id,\r\nfsm_getstate_str(ch->fsm), fsm_getstate_str(grp->fsm));\r\nfsm_deltimer(&ch->timer);\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_XID0IOWAIT:\r\ngrp->changed_side = 1;\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID2INITW);\r\nbreak;\r\ncase MPCG_STATE_XID2INITW:\r\nif (grp->changed_side == 1) {\r\ngrp->changed_side = 2;\r\nbreak;\r\n}\r\nif (grp->estconnfunc)\r\ngoto done;\r\nif (fsm_getstate(ch->fsm) == CH_XID0_INPROGRESS) {\r\nfsm_newstate(ch->fsm, CH_XID0_PENDING) ;\r\nfsm_deltimer(&grp->timer);\r\ngoto done;\r\n}\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\ncase MPCG_STATE_XID2INITX:\r\nif (grp->changed_side == 1) {\r\ngrp->changed_side = 2;\r\nbreak;\r\n}\r\ncase MPCG_STATE_XID0IOWAIX:\r\ncase MPCG_STATE_XID7INITW:\r\ncase MPCG_STATE_XID7INITX:\r\ncase MPCG_STATE_XID7INITI:\r\ncase MPCG_STATE_XID7INITZ:\r\ndefault:\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n}\r\nif (grp->changed_side == 1) {\r\nfsm_deltimer(&grp->timer);\r\nfsm_addtimer(&grp->timer, MPC_XID_TIMEOUT_VALUE,\r\nMPCG_EVENT_TIMER, dev);\r\n}\r\nif (ch->in_mpcgroup)\r\nfsm_event(grp->fsm, MPCG_EVENT_XID0DO, ch);\r\nelse\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): channel %s not added to group",\r\nCTCM_FUNTAIL, dev->name, ch->id);\r\ndone:\r\nreturn;\r\n}\r\nstatic void ctcmpc_chx_resend(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nfsm_event(grp->fsm, MPCG_EVENT_XID0DO, ch);\r\nreturn;\r\n}\r\nstatic void ctcmpc_chx_send_sweep(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct channel *ach = arg;\r\nstruct net_device *dev = ach->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct channel *wch = priv->channel[CTCM_WRITE];\r\nstruct channel *rch = priv->channel[CTCM_READ];\r\nstruct sk_buff *skb;\r\nstruct th_sweep *header;\r\nint rc = 0;\r\nunsigned long saveflags = 0;\r\nCTCM_PR_DEBUG("ctcmpc enter: %s(): cp=%i ch=0x%p id=%s\n",\r\n__func__, smp_processor_id(), ach, ach->id);\r\nif (grp->in_sweep == 0)\r\ngoto done;\r\nCTCM_PR_DBGDATA("%s: 1: ToVTAM_th_seq= %08x\n" ,\r\n__func__, wch->th_seq_num);\r\nCTCM_PR_DBGDATA("%s: 1: FromVTAM_th_seq= %08x\n" ,\r\n__func__, rch->th_seq_num);\r\nif (fsm_getstate(wch->fsm) != CTC_STATE_TXIDLE) {\r\nfsm_addtimer(&wch->sweep_timer,\r\n200, CTC_EVENT_RSWEEP_TIMER, wch);\r\ngoto done;\r\n}\r\nskb = skb_dequeue(&wch->sweep_queue);\r\nif (!skb)\r\ngoto done;\r\nif (set_normalized_cda(&wch->ccw[4], skb->data)) {\r\ngrp->in_sweep = 0;\r\nctcm_clear_busy_do(dev);\r\ndev_kfree_skb_any(skb);\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n} else {\r\natomic_inc(&skb->users);\r\nskb_queue_tail(&wch->io_queue, skb);\r\n}\r\nwch->ccw[4].count = skb->len;\r\nheader = (struct th_sweep *)skb->data;\r\nswitch (header->th.th_ch_flag) {\r\ncase TH_SWEEP_REQ:\r\ngrp->sweep_req_pend_num--;\r\nbreak;\r\ncase TH_SWEEP_RESP:\r\ngrp->sweep_rsp_pend_num--;\r\nbreak;\r\n}\r\nheader->sw.th_last_seq = wch->th_seq_num;\r\nCTCM_CCW_DUMP((char *)&wch->ccw[3], sizeof(struct ccw1) * 3);\r\nCTCM_PR_DBGDATA("%s: sweep packet\n", __func__);\r\nCTCM_D3_DUMP((char *)header, TH_SWEEP_LENGTH);\r\nfsm_addtimer(&wch->timer, CTCM_TIME_5_SEC, CTC_EVENT_TIMER, wch);\r\nfsm_newstate(wch->fsm, CTC_STATE_TX);\r\nspin_lock_irqsave(get_ccwdev_lock(wch->cdev), saveflags);\r\nwch->prof.send_stamp = current_kernel_time();\r\nrc = ccw_device_start(wch->cdev, &wch->ccw[3],\r\n(unsigned long) wch, 0xff, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(wch->cdev), saveflags);\r\nif ((grp->sweep_req_pend_num == 0) &&\r\n(grp->sweep_rsp_pend_num == 0)) {\r\ngrp->in_sweep = 0;\r\nrch->th_seq_num = 0x00;\r\nwch->th_seq_num = 0x00;\r\nctcm_clear_busy_do(dev);\r\n}\r\nCTCM_PR_DBGDATA("%s: To-/From-VTAM_th_seq = %08x/%08x\n" ,\r\n__func__, wch->th_seq_num, rch->th_seq_num);\r\nif (rc != 0)\r\nctcm_ccw_check_rc(wch, rc, "send sweep");\r\ndone:\r\nreturn;\r\n}\r\nstatic void dev_action_start(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nint direction;\r\nCTCMY_DBF_DEV_NAME(SETUP, dev, "");\r\nfsm_deltimer(&priv->restart_timer);\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_RXTX);\r\nif (IS_MPC(priv))\r\npriv->mpcg->channels_terminating = 0;\r\nfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\r\nstruct channel *ch = priv->channel[direction];\r\nfsm_event(ch->fsm, CTC_EVENT_START, ch);\r\n}\r\n}\r\nstatic void dev_action_stop(fsm_instance *fi, int event, void *arg)\r\n{\r\nint direction;\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCMY_DBF_DEV_NAME(SETUP, dev, "");\r\nfsm_newstate(fi, DEV_STATE_STOPWAIT_RXTX);\r\nfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\r\nstruct channel *ch = priv->channel[direction];\r\nfsm_event(ch->fsm, CTC_EVENT_STOP, ch);\r\nch->th_seq_num = 0x00;\r\nCTCM_PR_DEBUG("%s: CH_th_seq= %08x\n",\r\n__func__, ch->th_seq_num);\r\n}\r\nif (IS_MPC(priv))\r\nfsm_newstate(priv->mpcg->fsm, MPCG_STATE_RESET);\r\n}\r\nstatic void dev_action_restart(fsm_instance *fi, int event, void *arg)\r\n{\r\nint restart_timer;\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCMY_DBF_DEV_NAME(TRACE, dev, "");\r\nif (IS_MPC(priv)) {\r\nrestart_timer = CTCM_TIME_1_SEC;\r\n} else {\r\nrestart_timer = CTCM_TIME_5_SEC;\r\n}\r\ndev_info(&dev->dev, "Restarting device\n");\r\ndev_action_stop(fi, event, arg);\r\nfsm_event(priv->fsm, DEV_EVENT_STOP, dev);\r\nif (IS_MPC(priv))\r\nfsm_newstate(priv->mpcg->fsm, MPCG_STATE_RESET);\r\nfsm_addtimer(&priv->restart_timer, restart_timer,\r\nDEV_EVENT_START, dev);\r\n}\r\nstatic void dev_action_chup(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nint dev_stat = fsm_getstate(fi);\r\nCTCM_DBF_TEXT_(SETUP, CTC_DBF_NOTICE,\r\n"%s(%s): priv = %p [%d,%d]\n ", CTCM_FUNTAIL,\r\ndev->name, dev->ml_priv, dev_stat, event);\r\nswitch (fsm_getstate(fi)) {\r\ncase DEV_STATE_STARTWAIT_RXTX:\r\nif (event == DEV_EVENT_RXUP)\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_TX);\r\nelse\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_RX);\r\nbreak;\r\ncase DEV_STATE_STARTWAIT_RX:\r\nif (event == DEV_EVENT_RXUP) {\r\nfsm_newstate(fi, DEV_STATE_RUNNING);\r\ndev_info(&dev->dev,\r\n"Connected with remote side\n");\r\nctcm_clear_busy(dev);\r\n}\r\nbreak;\r\ncase DEV_STATE_STARTWAIT_TX:\r\nif (event == DEV_EVENT_TXUP) {\r\nfsm_newstate(fi, DEV_STATE_RUNNING);\r\ndev_info(&dev->dev,\r\n"Connected with remote side\n");\r\nctcm_clear_busy(dev);\r\n}\r\nbreak;\r\ncase DEV_STATE_STOPWAIT_TX:\r\nif (event == DEV_EVENT_RXUP)\r\nfsm_newstate(fi, DEV_STATE_STOPWAIT_RXTX);\r\nbreak;\r\ncase DEV_STATE_STOPWAIT_RX:\r\nif (event == DEV_EVENT_TXUP)\r\nfsm_newstate(fi, DEV_STATE_STOPWAIT_RXTX);\r\nbreak;\r\n}\r\nif (IS_MPC(priv)) {\r\nif (event == DEV_EVENT_RXUP)\r\nmpc_channel_action(priv->channel[CTCM_READ],\r\nCTCM_READ, MPC_CHANNEL_ADD);\r\nelse\r\nmpc_channel_action(priv->channel[CTCM_WRITE],\r\nCTCM_WRITE, MPC_CHANNEL_ADD);\r\n}\r\n}\r\nstatic void dev_action_chdown(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nCTCMY_DBF_DEV_NAME(SETUP, dev, "");\r\nswitch (fsm_getstate(fi)) {\r\ncase DEV_STATE_RUNNING:\r\nif (event == DEV_EVENT_TXDOWN)\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_TX);\r\nelse\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_RX);\r\nbreak;\r\ncase DEV_STATE_STARTWAIT_RX:\r\nif (event == DEV_EVENT_TXDOWN)\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_RXTX);\r\nbreak;\r\ncase DEV_STATE_STARTWAIT_TX:\r\nif (event == DEV_EVENT_RXDOWN)\r\nfsm_newstate(fi, DEV_STATE_STARTWAIT_RXTX);\r\nbreak;\r\ncase DEV_STATE_STOPWAIT_RXTX:\r\nif (event == DEV_EVENT_TXDOWN)\r\nfsm_newstate(fi, DEV_STATE_STOPWAIT_RX);\r\nelse\r\nfsm_newstate(fi, DEV_STATE_STOPWAIT_TX);\r\nbreak;\r\ncase DEV_STATE_STOPWAIT_RX:\r\nif (event == DEV_EVENT_RXDOWN)\r\nfsm_newstate(fi, DEV_STATE_STOPPED);\r\nbreak;\r\ncase DEV_STATE_STOPWAIT_TX:\r\nif (event == DEV_EVENT_TXDOWN)\r\nfsm_newstate(fi, DEV_STATE_STOPPED);\r\nbreak;\r\n}\r\nif (IS_MPC(priv)) {\r\nif (event == DEV_EVENT_RXDOWN)\r\nmpc_channel_action(priv->channel[CTCM_READ],\r\nCTCM_READ, MPC_CHANNEL_REMOVE);\r\nelse\r\nmpc_channel_action(priv->channel[CTCM_WRITE],\r\nCTCM_WRITE, MPC_CHANNEL_REMOVE);\r\n}\r\n}
