static inline struct fsl_upm_nand *to_fsl_upm_nand(struct mtd_info *mtdinfo)\r\n{\r\nreturn container_of(mtdinfo, struct fsl_upm_nand, mtd);\r\n}\r\nstatic int fun_chip_ready(struct mtd_info *mtd)\r\n{\r\nstruct fsl_upm_nand *fun = to_fsl_upm_nand(mtd);\r\nif (gpio_get_value(fun->rnb_gpio[fun->mchip_number]))\r\nreturn 1;\r\ndev_vdbg(fun->dev, "busy\n");\r\nreturn 0;\r\n}\r\nstatic void fun_wait_rnb(struct fsl_upm_nand *fun)\r\n{\r\nif (fun->rnb_gpio[fun->mchip_number] >= 0) {\r\nint cnt = 1000000;\r\nwhile (--cnt && !fun_chip_ready(&fun->mtd))\r\ncpu_relax();\r\nif (!cnt)\r\ndev_err(fun->dev, "tired waiting for RNB\n");\r\n} else {\r\nndelay(100);\r\n}\r\n}\r\nstatic void fun_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_upm_nand *fun = to_fsl_upm_nand(mtd);\r\nu32 mar;\r\nif (!(ctrl & fun->last_ctrl)) {\r\nfsl_upm_end_pattern(&fun->upm);\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nfun->last_ctrl = ctrl & (NAND_ALE | NAND_CLE);\r\n}\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_ALE)\r\nfsl_upm_start_pattern(&fun->upm, fun->upm_addr_offset);\r\nelse if (ctrl & NAND_CLE)\r\nfsl_upm_start_pattern(&fun->upm, fun->upm_cmd_offset);\r\n}\r\nmar = (cmd << (32 - fun->upm.width)) |\r\nfun->mchip_offsets[fun->mchip_number];\r\nfsl_upm_run_pattern(&fun->upm, chip->IO_ADDR_R, mar);\r\nif (fun->wait_flags & FSL_UPM_WAIT_RUN_PATTERN)\r\nfun_wait_rnb(fun);\r\n}\r\nstatic void fun_select_chip(struct mtd_info *mtd, int mchip_nr)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nstruct fsl_upm_nand *fun = to_fsl_upm_nand(mtd);\r\nif (mchip_nr == -1) {\r\nchip->cmd_ctrl(mtd, NAND_CMD_NONE, 0 | NAND_CTRL_CHANGE);\r\n} else if (mchip_nr >= 0 && mchip_nr < NAND_MAX_CHIPS) {\r\nfun->mchip_number = mchip_nr;\r\nchip->IO_ADDR_R = fun->io_base + fun->mchip_offsets[mchip_nr];\r\nchip->IO_ADDR_W = chip->IO_ADDR_R;\r\n} else {\r\nBUG();\r\n}\r\n}\r\nstatic uint8_t fun_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct fsl_upm_nand *fun = to_fsl_upm_nand(mtd);\r\nreturn in_8(fun->chip.IO_ADDR_R);\r\n}\r\nstatic void fun_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct fsl_upm_nand *fun = to_fsl_upm_nand(mtd);\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = in_8(fun->chip.IO_ADDR_R);\r\n}\r\nstatic void fun_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct fsl_upm_nand *fun = to_fsl_upm_nand(mtd);\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nout_8(fun->chip.IO_ADDR_W, buf[i]);\r\nif (fun->wait_flags & FSL_UPM_WAIT_WRITE_BYTE)\r\nfun_wait_rnb(fun);\r\n}\r\nif (fun->wait_flags & FSL_UPM_WAIT_WRITE_BUFFER)\r\nfun_wait_rnb(fun);\r\n}\r\nstatic int __devinit fun_chip_init(struct fsl_upm_nand *fun,\r\nconst struct device_node *upm_np,\r\nconst struct resource *io_res)\r\n{\r\nint ret;\r\nstruct device_node *flash_np;\r\nstruct mtd_part_parser_data ppdata;\r\nfun->chip.IO_ADDR_R = fun->io_base;\r\nfun->chip.IO_ADDR_W = fun->io_base;\r\nfun->chip.cmd_ctrl = fun_cmd_ctrl;\r\nfun->chip.chip_delay = fun->chip_delay;\r\nfun->chip.read_byte = fun_read_byte;\r\nfun->chip.read_buf = fun_read_buf;\r\nfun->chip.write_buf = fun_write_buf;\r\nfun->chip.ecc.mode = NAND_ECC_SOFT;\r\nif (fun->mchip_count > 1)\r\nfun->chip.select_chip = fun_select_chip;\r\nif (fun->rnb_gpio[0] >= 0)\r\nfun->chip.dev_ready = fun_chip_ready;\r\nfun->mtd.priv = &fun->chip;\r\nfun->mtd.owner = THIS_MODULE;\r\nflash_np = of_get_next_child(upm_np, NULL);\r\nif (!flash_np)\r\nreturn -ENODEV;\r\nfun->mtd.name = kasprintf(GFP_KERNEL, "0x%llx.%s", (u64)io_res->start,\r\nflash_np->name);\r\nif (!fun->mtd.name) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nret = nand_scan(&fun->mtd, fun->mchip_count);\r\nif (ret)\r\ngoto err;\r\nppdata.of_node = flash_np;\r\nret = mtd_device_parse_register(&fun->mtd, NULL, &ppdata, NULL, 0);\r\nerr:\r\nof_node_put(flash_np);\r\nif (ret)\r\nkfree(fun->mtd.name);\r\nreturn ret;\r\n}\r\nstatic int __devinit fun_probe(struct platform_device *ofdev)\r\n{\r\nstruct fsl_upm_nand *fun;\r\nstruct resource io_res;\r\nconst __be32 *prop;\r\nint rnb_gpio;\r\nint ret;\r\nint size;\r\nint i;\r\nfun = kzalloc(sizeof(*fun), GFP_KERNEL);\r\nif (!fun)\r\nreturn -ENOMEM;\r\nret = of_address_to_resource(ofdev->dev.of_node, 0, &io_res);\r\nif (ret) {\r\ndev_err(&ofdev->dev, "can't get IO base\n");\r\ngoto err1;\r\n}\r\nret = fsl_upm_find(io_res.start, &fun->upm);\r\nif (ret) {\r\ndev_err(&ofdev->dev, "can't find UPM\n");\r\ngoto err1;\r\n}\r\nprop = of_get_property(ofdev->dev.of_node, "fsl,upm-addr-offset",\r\n&size);\r\nif (!prop || size != sizeof(uint32_t)) {\r\ndev_err(&ofdev->dev, "can't get UPM address offset\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nfun->upm_addr_offset = *prop;\r\nprop = of_get_property(ofdev->dev.of_node, "fsl,upm-cmd-offset", &size);\r\nif (!prop || size != sizeof(uint32_t)) {\r\ndev_err(&ofdev->dev, "can't get UPM command offset\n");\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nfun->upm_cmd_offset = *prop;\r\nprop = of_get_property(ofdev->dev.of_node,\r\n"fsl,upm-addr-line-cs-offsets", &size);\r\nif (prop && (size / sizeof(uint32_t)) > 0) {\r\nfun->mchip_count = size / sizeof(uint32_t);\r\nif (fun->mchip_count >= NAND_MAX_CHIPS) {\r\ndev_err(&ofdev->dev, "too much multiple chips\n");\r\ngoto err1;\r\n}\r\nfor (i = 0; i < fun->mchip_count; i++)\r\nfun->mchip_offsets[i] = be32_to_cpu(prop[i]);\r\n} else {\r\nfun->mchip_count = 1;\r\n}\r\nfor (i = 0; i < fun->mchip_count; i++) {\r\nfun->rnb_gpio[i] = -1;\r\nrnb_gpio = of_get_gpio(ofdev->dev.of_node, i);\r\nif (rnb_gpio >= 0) {\r\nret = gpio_request(rnb_gpio, dev_name(&ofdev->dev));\r\nif (ret) {\r\ndev_err(&ofdev->dev,\r\n"can't request RNB gpio #%d\n", i);\r\ngoto err2;\r\n}\r\ngpio_direction_input(rnb_gpio);\r\nfun->rnb_gpio[i] = rnb_gpio;\r\n} else if (rnb_gpio == -EINVAL) {\r\ndev_err(&ofdev->dev, "RNB gpio #%d is invalid\n", i);\r\ngoto err2;\r\n}\r\n}\r\nprop = of_get_property(ofdev->dev.of_node, "chip-delay", NULL);\r\nif (prop)\r\nfun->chip_delay = be32_to_cpup(prop);\r\nelse\r\nfun->chip_delay = 50;\r\nprop = of_get_property(ofdev->dev.of_node, "fsl,upm-wait-flags", &size);\r\nif (prop && size == sizeof(uint32_t))\r\nfun->wait_flags = be32_to_cpup(prop);\r\nelse\r\nfun->wait_flags = FSL_UPM_WAIT_RUN_PATTERN |\r\nFSL_UPM_WAIT_WRITE_BYTE;\r\nfun->io_base = devm_ioremap_nocache(&ofdev->dev, io_res.start,\r\nresource_size(&io_res));\r\nif (!fun->io_base) {\r\nret = -ENOMEM;\r\ngoto err2;\r\n}\r\nfun->dev = &ofdev->dev;\r\nfun->last_ctrl = NAND_CLE;\r\nret = fun_chip_init(fun, ofdev->dev.of_node, &io_res);\r\nif (ret)\r\ngoto err2;\r\ndev_set_drvdata(&ofdev->dev, fun);\r\nreturn 0;\r\nerr2:\r\nfor (i = 0; i < fun->mchip_count; i++) {\r\nif (fun->rnb_gpio[i] < 0)\r\nbreak;\r\ngpio_free(fun->rnb_gpio[i]);\r\n}\r\nerr1:\r\nkfree(fun);\r\nreturn ret;\r\n}\r\nstatic int __devexit fun_remove(struct platform_device *ofdev)\r\n{\r\nstruct fsl_upm_nand *fun = dev_get_drvdata(&ofdev->dev);\r\nint i;\r\nnand_release(&fun->mtd);\r\nkfree(fun->mtd.name);\r\nfor (i = 0; i < fun->mchip_count; i++) {\r\nif (fun->rnb_gpio[i] < 0)\r\nbreak;\r\ngpio_free(fun->rnb_gpio[i]);\r\n}\r\nkfree(fun);\r\nreturn 0;\r\n}
