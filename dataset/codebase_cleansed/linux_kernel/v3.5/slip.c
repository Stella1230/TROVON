static int sl_alloc_bufs(struct slip *sl, int mtu)\r\n{\r\nint err = -ENOBUFS;\r\nunsigned long len;\r\nchar *rbuff = NULL;\r\nchar *xbuff = NULL;\r\n#ifdef SL_INCLUDE_CSLIP\r\nchar *cbuff = NULL;\r\nstruct slcompress *slcomp = NULL;\r\n#endif\r\nlen = mtu * 2;\r\nif (len < 576 * 2)\r\nlen = 576 * 2;\r\nrbuff = kmalloc(len + 4, GFP_KERNEL);\r\nif (rbuff == NULL)\r\ngoto err_exit;\r\nxbuff = kmalloc(len + 4, GFP_KERNEL);\r\nif (xbuff == NULL)\r\ngoto err_exit;\r\n#ifdef SL_INCLUDE_CSLIP\r\ncbuff = kmalloc(len + 4, GFP_KERNEL);\r\nif (cbuff == NULL)\r\ngoto err_exit;\r\nslcomp = slhc_init(16, 16);\r\nif (slcomp == NULL)\r\ngoto err_exit;\r\n#endif\r\nspin_lock_bh(&sl->lock);\r\nif (sl->tty == NULL) {\r\nspin_unlock_bh(&sl->lock);\r\nerr = -ENODEV;\r\ngoto err_exit;\r\n}\r\nsl->mtu = mtu;\r\nsl->buffsize = len;\r\nsl->rcount = 0;\r\nsl->xleft = 0;\r\nrbuff = xchg(&sl->rbuff, rbuff);\r\nxbuff = xchg(&sl->xbuff, xbuff);\r\n#ifdef SL_INCLUDE_CSLIP\r\ncbuff = xchg(&sl->cbuff, cbuff);\r\nslcomp = xchg(&sl->slcomp, slcomp);\r\n#endif\r\n#ifdef CONFIG_SLIP_MODE_SLIP6\r\nsl->xdata = 0;\r\nsl->xbits = 0;\r\n#endif\r\nspin_unlock_bh(&sl->lock);\r\nerr = 0;\r\nerr_exit:\r\n#ifdef SL_INCLUDE_CSLIP\r\nkfree(cbuff);\r\nslhc_free(slcomp);\r\n#endif\r\nkfree(xbuff);\r\nkfree(rbuff);\r\nreturn err;\r\n}\r\nstatic void sl_free_bufs(struct slip *sl)\r\n{\r\nkfree(xchg(&sl->rbuff, NULL));\r\nkfree(xchg(&sl->xbuff, NULL));\r\n#ifdef SL_INCLUDE_CSLIP\r\nkfree(xchg(&sl->cbuff, NULL));\r\nslhc_free(xchg(&sl->slcomp, NULL));\r\n#endif\r\n}\r\nstatic inline void sl_lock(struct slip *sl)\r\n{\r\nnetif_stop_queue(sl->dev);\r\n}\r\nstatic inline void sl_unlock(struct slip *sl)\r\n{\r\nnetif_wake_queue(sl->dev);\r\n}\r\nstatic void sl_bump(struct slip *sl)\r\n{\r\nstruct net_device *dev = sl->dev;\r\nstruct sk_buff *skb;\r\nint count;\r\ncount = sl->rcount;\r\n#ifdef SL_INCLUDE_CSLIP\r\nif (sl->mode & (SL_MODE_ADAPTIVE | SL_MODE_CSLIP)) {\r\nunsigned char c = sl->rbuff[0];\r\nif (c & SL_TYPE_COMPRESSED_TCP) {\r\nif (!(sl->mode & SL_MODE_CSLIP)) {\r\nprintk(KERN_WARNING "%s: compressed packet ignored\n", dev->name);\r\nreturn;\r\n}\r\nif (count + 80 > sl->buffsize) {\r\ndev->stats.rx_over_errors++;\r\nreturn;\r\n}\r\ncount = slhc_uncompress(sl->slcomp, sl->rbuff, count);\r\nif (count <= 0)\r\nreturn;\r\n} else if (c >= SL_TYPE_UNCOMPRESSED_TCP) {\r\nif (!(sl->mode & SL_MODE_CSLIP)) {\r\nsl->mode |= SL_MODE_CSLIP;\r\nsl->mode &= ~SL_MODE_ADAPTIVE;\r\nprintk(KERN_INFO "%s: header compression turned on\n", dev->name);\r\n}\r\nsl->rbuff[0] &= 0x4f;\r\nif (slhc_remember(sl->slcomp, sl->rbuff, count) <= 0)\r\nreturn;\r\n}\r\n}\r\n#endif\r\ndev->stats.rx_bytes += count;\r\nskb = dev_alloc_skb(count);\r\nif (skb == NULL) {\r\nprintk(KERN_WARNING "%s: memory squeeze, dropping packet.\n", dev->name);\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb->dev = dev;\r\nmemcpy(skb_put(skb, count), sl->rbuff, count);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IP);\r\nnetif_rx_ni(skb);\r\ndev->stats.rx_packets++;\r\n}\r\nstatic void sl_encaps(struct slip *sl, unsigned char *icp, int len)\r\n{\r\nunsigned char *p;\r\nint actual, count;\r\nif (len > sl->mtu) {\r\nprintk(KERN_WARNING "%s: truncating oversized transmit packet!\n", sl->dev->name);\r\nsl->dev->stats.tx_dropped++;\r\nsl_unlock(sl);\r\nreturn;\r\n}\r\np = icp;\r\n#ifdef SL_INCLUDE_CSLIP\r\nif (sl->mode & SL_MODE_CSLIP)\r\nlen = slhc_compress(sl->slcomp, p, len, sl->cbuff, &p, 1);\r\n#endif\r\n#ifdef CONFIG_SLIP_MODE_SLIP6\r\nif (sl->mode & SL_MODE_SLIP6)\r\ncount = slip_esc6(p, (unsigned char *) sl->xbuff, len);\r\nelse\r\n#endif\r\ncount = slip_esc(p, (unsigned char *) sl->xbuff, len);\r\nset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nactual = sl->tty->ops->write(sl->tty, sl->xbuff, count);\r\n#ifdef SL_CHECK_TRANSMIT\r\nsl->dev->trans_start = jiffies;\r\n#endif\r\nsl->xleft = count - actual;\r\nsl->xhead = sl->xbuff + actual;\r\n#ifdef CONFIG_SLIP_SMART\r\nclear_bit(SLF_OUTWAIT, &sl->flags);\r\n#endif\r\n}\r\nstatic void slip_write_wakeup(struct tty_struct *tty)\r\n{\r\nint actual;\r\nstruct slip *sl = tty->disc_data;\r\nif (!sl || sl->magic != SLIP_MAGIC || !netif_running(sl->dev))\r\nreturn;\r\nif (sl->xleft <= 0) {\r\nsl->dev->stats.tx_packets++;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nsl_unlock(sl);\r\nreturn;\r\n}\r\nactual = tty->ops->write(tty, sl->xhead, sl->xleft);\r\nsl->xleft -= actual;\r\nsl->xhead += actual;\r\n}\r\nstatic void sl_tx_timeout(struct net_device *dev)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nspin_lock(&sl->lock);\r\nif (netif_queue_stopped(dev)) {\r\nif (!netif_running(dev))\r\ngoto out;\r\n#ifdef SL_CHECK_TRANSMIT\r\nif (time_before(jiffies, dev_trans_start(dev) + 20 * HZ)) {\r\ngoto out;\r\n}\r\nprintk(KERN_WARNING "%s: transmit timed out, %s?\n",\r\ndev->name,\r\n(tty_chars_in_buffer(sl->tty) || sl->xleft) ?\r\n"bad line quality" : "driver error");\r\nsl->xleft = 0;\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nsl_unlock(sl);\r\n#endif\r\n}\r\nout:\r\nspin_unlock(&sl->lock);\r\n}\r\nstatic netdev_tx_t\r\nsl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nspin_lock(&sl->lock);\r\nif (!netif_running(dev)) {\r\nspin_unlock(&sl->lock);\r\nprintk(KERN_WARNING "%s: xmit call when iface is down\n", dev->name);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (sl->tty == NULL) {\r\nspin_unlock(&sl->lock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nsl_lock(sl);\r\ndev->stats.tx_bytes += skb->len;\r\nsl_encaps(sl, skb->data, skb->len);\r\nspin_unlock(&sl->lock);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int\r\nsl_close(struct net_device *dev)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nspin_lock_bh(&sl->lock);\r\nif (sl->tty)\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\r\nnetif_stop_queue(dev);\r\nsl->rcount = 0;\r\nsl->xleft = 0;\r\nspin_unlock_bh(&sl->lock);\r\nreturn 0;\r\n}\r\nstatic int sl_open(struct net_device *dev)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nif (sl->tty == NULL)\r\nreturn -ENODEV;\r\nsl->flags &= (1 << SLF_INUSE);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int sl_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nif (new_mtu < 68 || new_mtu > 65534)\r\nreturn -EINVAL;\r\nif (new_mtu != dev->mtu)\r\nreturn sl_realloc_bufs(sl, new_mtu);\r\nreturn 0;\r\n}\r\nstatic struct rtnl_link_stats64 *\r\nsl_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct net_device_stats *devstats = &dev->stats;\r\n#ifdef SL_INCLUDE_CSLIP\r\nstruct slip *sl = netdev_priv(dev);\r\nstruct slcompress *comp = sl->slcomp;\r\n#endif\r\nstats->rx_packets = devstats->rx_packets;\r\nstats->tx_packets = devstats->tx_packets;\r\nstats->rx_bytes = devstats->rx_bytes;\r\nstats->tx_bytes = devstats->tx_bytes;\r\nstats->rx_dropped = devstats->rx_dropped;\r\nstats->tx_dropped = devstats->tx_dropped;\r\nstats->tx_errors = devstats->tx_errors;\r\nstats->rx_errors = devstats->rx_errors;\r\nstats->rx_over_errors = devstats->rx_over_errors;\r\n#ifdef SL_INCLUDE_CSLIP\r\nif (comp) {\r\nstats->rx_compressed = comp->sls_i_compressed;\r\nstats->tx_compressed = comp->sls_o_compressed;\r\nstats->rx_fifo_errors += comp->sls_i_compressed;\r\nstats->rx_dropped += comp->sls_i_tossed;\r\nstats->tx_fifo_errors += comp->sls_o_compressed;\r\nstats->collisions += comp->sls_o_misses;\r\n}\r\n#endif\r\nreturn stats;\r\n}\r\nstatic int sl_init(struct net_device *dev)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\ndev->mtu = sl->mtu;\r\ndev->type = ARPHRD_SLIP + sl->mode;\r\n#ifdef SL_CHECK_TRANSMIT\r\ndev->watchdog_timeo = 20*HZ;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void sl_uninit(struct net_device *dev)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nsl_free_bufs(sl);\r\n}\r\nstatic void sl_free_netdev(struct net_device *dev)\r\n{\r\nint i = dev->base_addr;\r\nfree_netdev(dev);\r\nslip_devs[i] = NULL;\r\n}\r\nstatic void sl_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &sl_netdev_ops;\r\ndev->destructor = sl_free_netdev;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->tx_queue_len = 10;\r\ndev->flags = IFF_NOARP|IFF_POINTOPOINT|IFF_MULTICAST;\r\n}\r\nstatic void slip_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct slip *sl = tty->disc_data;\r\nif (!sl || sl->magic != SLIP_MAGIC || !netif_running(sl->dev))\r\nreturn;\r\nwhile (count--) {\r\nif (fp && *fp++) {\r\nif (!test_and_set_bit(SLF_ERROR, &sl->flags))\r\nsl->dev->stats.rx_errors++;\r\ncp++;\r\ncontinue;\r\n}\r\n#ifdef CONFIG_SLIP_MODE_SLIP6\r\nif (sl->mode & SL_MODE_SLIP6)\r\nslip_unesc6(sl, *cp++);\r\nelse\r\n#endif\r\nslip_unesc(sl, *cp++);\r\n}\r\n}\r\nstatic void sl_sync(void)\r\n{\r\nint i;\r\nstruct net_device *dev;\r\nstruct slip *sl;\r\nfor (i = 0; i < slip_maxdev; i++) {\r\ndev = slip_devs[i];\r\nif (dev == NULL)\r\nbreak;\r\nsl = netdev_priv(dev);\r\nif (sl->tty || sl->leased)\r\ncontinue;\r\nif (dev->flags & IFF_UP)\r\ndev_close(dev);\r\n}\r\n}\r\nstatic struct slip *sl_alloc(dev_t line)\r\n{\r\nint i;\r\nchar name[IFNAMSIZ];\r\nstruct net_device *dev = NULL;\r\nstruct slip *sl;\r\nfor (i = 0; i < slip_maxdev; i++) {\r\ndev = slip_devs[i];\r\nif (dev == NULL)\r\nbreak;\r\n}\r\nif (i >= slip_maxdev)\r\nreturn NULL;\r\nsprintf(name, "sl%d", i);\r\ndev = alloc_netdev(sizeof(*sl), name, sl_setup);\r\nif (!dev)\r\nreturn NULL;\r\ndev->base_addr = i;\r\nsl = netdev_priv(dev);\r\nsl->magic = SLIP_MAGIC;\r\nsl->dev = dev;\r\nspin_lock_init(&sl->lock);\r\nsl->mode = SL_MODE_DEFAULT;\r\n#ifdef CONFIG_SLIP_SMART\r\ninit_timer(&sl->keepalive_timer);\r\nsl->keepalive_timer.data = (unsigned long)sl;\r\nsl->keepalive_timer.function = sl_keepalive;\r\ninit_timer(&sl->outfill_timer);\r\nsl->outfill_timer.data = (unsigned long)sl;\r\nsl->outfill_timer.function = sl_outfill;\r\n#endif\r\nslip_devs[i] = dev;\r\nreturn sl;\r\n}\r\nstatic int slip_open(struct tty_struct *tty)\r\n{\r\nstruct slip *sl;\r\nint err;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (tty->ops->write == NULL)\r\nreturn -EOPNOTSUPP;\r\nrtnl_lock();\r\nsl_sync();\r\nsl = tty->disc_data;\r\nerr = -EEXIST;\r\nif (sl && sl->magic == SLIP_MAGIC)\r\ngoto err_exit;\r\nerr = -ENFILE;\r\nsl = sl_alloc(tty_devnum(tty));\r\nif (sl == NULL)\r\ngoto err_exit;\r\nsl->tty = tty;\r\ntty->disc_data = sl;\r\nsl->pid = current->pid;\r\nif (!test_bit(SLF_INUSE, &sl->flags)) {\r\nerr = sl_alloc_bufs(sl, SL_MTU);\r\nif (err)\r\ngoto err_free_chan;\r\nset_bit(SLF_INUSE, &sl->flags);\r\nerr = register_netdevice(sl->dev);\r\nif (err)\r\ngoto err_free_bufs;\r\n}\r\n#ifdef CONFIG_SLIP_SMART\r\nif (sl->keepalive) {\r\nsl->keepalive_timer.expires = jiffies + sl->keepalive * HZ;\r\nadd_timer(&sl->keepalive_timer);\r\n}\r\nif (sl->outfill) {\r\nsl->outfill_timer.expires = jiffies + sl->outfill * HZ;\r\nadd_timer(&sl->outfill_timer);\r\n}\r\n#endif\r\nrtnl_unlock();\r\ntty->receive_room = 65536;\r\nreturn 0;\r\nerr_free_bufs:\r\nsl_free_bufs(sl);\r\nerr_free_chan:\r\nsl->tty = NULL;\r\ntty->disc_data = NULL;\r\nclear_bit(SLF_INUSE, &sl->flags);\r\nerr_exit:\r\nrtnl_unlock();\r\nreturn err;\r\n}\r\nstatic void slip_close(struct tty_struct *tty)\r\n{\r\nstruct slip *sl = tty->disc_data;\r\nif (!sl || sl->magic != SLIP_MAGIC || sl->tty != tty)\r\nreturn;\r\ntty->disc_data = NULL;\r\nsl->tty = NULL;\r\n#ifdef CONFIG_SLIP_SMART\r\ndel_timer_sync(&sl->keepalive_timer);\r\ndel_timer_sync(&sl->outfill_timer);\r\n#endif\r\nunregister_netdev(sl->dev);\r\n}\r\nstatic int slip_hangup(struct tty_struct *tty)\r\n{\r\nslip_close(tty);\r\nreturn 0;\r\n}\r\nstatic int slip_esc(unsigned char *s, unsigned char *d, int len)\r\n{\r\nunsigned char *ptr = d;\r\nunsigned char c;\r\n*ptr++ = END;\r\nwhile (len-- > 0) {\r\nswitch (c = *s++) {\r\ncase END:\r\n*ptr++ = ESC;\r\n*ptr++ = ESC_END;\r\nbreak;\r\ncase ESC:\r\n*ptr++ = ESC;\r\n*ptr++ = ESC_ESC;\r\nbreak;\r\ndefault:\r\n*ptr++ = c;\r\nbreak;\r\n}\r\n}\r\n*ptr++ = END;\r\nreturn ptr - d;\r\n}\r\nstatic void slip_unesc(struct slip *sl, unsigned char s)\r\n{\r\nswitch (s) {\r\ncase END:\r\n#ifdef CONFIG_SLIP_SMART\r\nif (test_bit(SLF_KEEPTEST, &sl->flags))\r\nclear_bit(SLF_KEEPTEST, &sl->flags);\r\n#endif\r\nif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\r\n(sl->rcount > 2))\r\nsl_bump(sl);\r\nclear_bit(SLF_ESCAPE, &sl->flags);\r\nsl->rcount = 0;\r\nreturn;\r\ncase ESC:\r\nset_bit(SLF_ESCAPE, &sl->flags);\r\nreturn;\r\ncase ESC_ESC:\r\nif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\r\ns = ESC;\r\nbreak;\r\ncase ESC_END:\r\nif (test_and_clear_bit(SLF_ESCAPE, &sl->flags))\r\ns = END;\r\nbreak;\r\n}\r\nif (!test_bit(SLF_ERROR, &sl->flags)) {\r\nif (sl->rcount < sl->buffsize) {\r\nsl->rbuff[sl->rcount++] = s;\r\nreturn;\r\n}\r\nsl->dev->stats.rx_over_errors++;\r\nset_bit(SLF_ERROR, &sl->flags);\r\n}\r\n}\r\nstatic int slip_esc6(unsigned char *s, unsigned char *d, int len)\r\n{\r\nunsigned char *ptr = d;\r\nunsigned char c;\r\nint i;\r\nunsigned short v = 0;\r\nshort bits = 0;\r\n*ptr++ = 0x70;\r\nfor (i = 0; i < len; ++i) {\r\nv = (v << 8) | s[i];\r\nbits += 8;\r\nwhile (bits >= 6) {\r\nbits -= 6;\r\nc = 0x30 + ((v >> bits) & 0x3F);\r\n*ptr++ = c;\r\n}\r\n}\r\nif (bits) {\r\nc = 0x30 + ((v << (6 - bits)) & 0x3F);\r\n*ptr++ = c;\r\n}\r\n*ptr++ = 0x70;\r\nreturn ptr - d;\r\n}\r\nstatic void slip_unesc6(struct slip *sl, unsigned char s)\r\n{\r\nunsigned char c;\r\nif (s == 0x70) {\r\n#ifdef CONFIG_SLIP_SMART\r\nif (test_bit(SLF_KEEPTEST, &sl->flags))\r\nclear_bit(SLF_KEEPTEST, &sl->flags);\r\n#endif\r\nif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\r\n(sl->rcount > 2))\r\nsl_bump(sl);\r\nsl->rcount = 0;\r\nsl->xbits = 0;\r\nsl->xdata = 0;\r\n} else if (s >= 0x30 && s < 0x70) {\r\nsl->xdata = (sl->xdata << 6) | ((s - 0x30) & 0x3F);\r\nsl->xbits += 6;\r\nif (sl->xbits >= 8) {\r\nsl->xbits -= 8;\r\nc = (unsigned char)(sl->xdata >> sl->xbits);\r\nif (!test_bit(SLF_ERROR, &sl->flags)) {\r\nif (sl->rcount < sl->buffsize) {\r\nsl->rbuff[sl->rcount++] = c;\r\nreturn;\r\n}\r\nsl->dev->stats.rx_over_errors++;\r\nset_bit(SLF_ERROR, &sl->flags);\r\n}\r\n}\r\n}\r\n}\r\nstatic int slip_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct slip *sl = tty->disc_data;\r\nunsigned int tmp;\r\nint __user *p = (int __user *)arg;\r\nif (!sl || sl->magic != SLIP_MAGIC)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\ntmp = strlen(sl->dev->name) + 1;\r\nif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SIOCGIFENCAP:\r\nif (put_user(sl->mode, p))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SIOCSIFENCAP:\r\nif (get_user(tmp, p))\r\nreturn -EFAULT;\r\n#ifndef SL_INCLUDE_CSLIP\r\nif (tmp & (SL_MODE_CSLIP|SL_MODE_ADAPTIVE))\r\nreturn -EINVAL;\r\n#else\r\nif ((tmp & (SL_MODE_ADAPTIVE | SL_MODE_CSLIP)) ==\r\n(SL_MODE_ADAPTIVE | SL_MODE_CSLIP))\r\ntmp &= ~SL_MODE_ADAPTIVE;\r\n#endif\r\n#ifndef CONFIG_SLIP_MODE_SLIP6\r\nif (tmp & SL_MODE_SLIP6)\r\nreturn -EINVAL;\r\n#endif\r\nsl->mode = tmp;\r\nsl->dev->type = ARPHRD_SLIP + sl->mode;\r\nreturn 0;\r\ncase SIOCSIFHWADDR:\r\nreturn -EINVAL;\r\n#ifdef CONFIG_SLIP_SMART\r\ncase SIOCSKEEPALIVE:\r\nif (get_user(tmp, p))\r\nreturn -EFAULT;\r\nif (tmp > 255)\r\nreturn -EINVAL;\r\nspin_lock_bh(&sl->lock);\r\nif (!sl->tty) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn -ENODEV;\r\n}\r\nsl->keepalive = (u8)tmp;\r\nif (sl->keepalive != 0) {\r\nmod_timer(&sl->keepalive_timer,\r\njiffies + sl->keepalive * HZ);\r\nset_bit(SLF_KEEPTEST, &sl->flags);\r\n} else\r\ndel_timer(&sl->keepalive_timer);\r\nspin_unlock_bh(&sl->lock);\r\nreturn 0;\r\ncase SIOCGKEEPALIVE:\r\nif (put_user(sl->keepalive, p))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SIOCSOUTFILL:\r\nif (get_user(tmp, p))\r\nreturn -EFAULT;\r\nif (tmp > 255)\r\nreturn -EINVAL;\r\nspin_lock_bh(&sl->lock);\r\nif (!sl->tty) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn -ENODEV;\r\n}\r\nsl->outfill = (u8)tmp;\r\nif (sl->outfill != 0) {\r\nmod_timer(&sl->outfill_timer,\r\njiffies + sl->outfill * HZ);\r\nset_bit(SLF_OUTWAIT, &sl->flags);\r\n} else\r\ndel_timer(&sl->outfill_timer);\r\nspin_unlock_bh(&sl->lock);\r\nreturn 0;\r\ncase SIOCGOUTFILL:\r\nif (put_user(sl->outfill, p))\r\nreturn -EFAULT;\r\nreturn 0;\r\n#endif\r\ndefault:\r\nreturn tty_mode_ioctl(tty, file, cmd, arg);\r\n}\r\n}\r\nstatic long slip_compat_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase SIOCGIFNAME:\r\ncase SIOCGIFENCAP:\r\ncase SIOCSIFENCAP:\r\ncase SIOCSIFHWADDR:\r\ncase SIOCSKEEPALIVE:\r\ncase SIOCGKEEPALIVE:\r\ncase SIOCSOUTFILL:\r\ncase SIOCGOUTFILL:\r\nreturn slip_ioctl(tty, file, cmd,\r\n(unsigned long)compat_ptr(arg));\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int sl_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct slip *sl = netdev_priv(dev);\r\nunsigned long *p = (unsigned long *)&rq->ifr_ifru;\r\nif (sl == NULL)\r\nreturn -ENODEV;\r\nspin_lock_bh(&sl->lock);\r\nif (!sl->tty) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn -ENODEV;\r\n}\r\nswitch (cmd) {\r\ncase SIOCSKEEPALIVE:\r\nif ((unsigned)*p > 255) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn -EINVAL;\r\n}\r\nsl->keepalive = (u8)*p;\r\nif (sl->keepalive != 0) {\r\nsl->keepalive_timer.expires =\r\njiffies + sl->keepalive * HZ;\r\nmod_timer(&sl->keepalive_timer,\r\njiffies + sl->keepalive * HZ);\r\nset_bit(SLF_KEEPTEST, &sl->flags);\r\n} else\r\ndel_timer(&sl->keepalive_timer);\r\nbreak;\r\ncase SIOCGKEEPALIVE:\r\n*p = sl->keepalive;\r\nbreak;\r\ncase SIOCSOUTFILL:\r\nif ((unsigned)*p > 255) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn -EINVAL;\r\n}\r\nsl->outfill = (u8)*p;\r\nif (sl->outfill != 0) {\r\nmod_timer(&sl->outfill_timer,\r\njiffies + sl->outfill * HZ);\r\nset_bit(SLF_OUTWAIT, &sl->flags);\r\n} else\r\ndel_timer(&sl->outfill_timer);\r\nbreak;\r\ncase SIOCGOUTFILL:\r\n*p = sl->outfill;\r\nbreak;\r\ncase SIOCSLEASE:\r\nif (sl->tty != current->signal->tty &&\r\nsl->pid != current->pid) {\r\nspin_unlock_bh(&sl->lock);\r\nreturn -EPERM;\r\n}\r\nsl->leased = 0;\r\nif (*p)\r\nsl->leased = 1;\r\nbreak;\r\ncase SIOCGLEASE:\r\n*p = sl->leased;\r\n}\r\nspin_unlock_bh(&sl->lock);\r\nreturn 0;\r\n}\r\nstatic int __init slip_init(void)\r\n{\r\nint status;\r\nif (slip_maxdev < 4)\r\nslip_maxdev = 4;\r\nprintk(KERN_INFO "SLIP: version %s (dynamic channels, max=%d)"\r\n#ifdef CONFIG_SLIP_MODE_SLIP6\r\n" (6 bit encapsulation enabled)"\r\n#endif\r\n".\n",\r\nSLIP_VERSION, slip_maxdev);\r\n#if defined(SL_INCLUDE_CSLIP)\r\nprintk(KERN_INFO "CSLIP: code copyright 1989 Regents of the University of California.\n");\r\n#endif\r\n#ifdef CONFIG_SLIP_SMART\r\nprintk(KERN_INFO "SLIP linefill/keepalive option.\n");\r\n#endif\r\nslip_devs = kzalloc(sizeof(struct net_device *)*slip_maxdev,\r\nGFP_KERNEL);\r\nif (!slip_devs)\r\nreturn -ENOMEM;\r\nstatus = tty_register_ldisc(N_SLIP, &sl_ldisc);\r\nif (status != 0) {\r\nprintk(KERN_ERR "SLIP: can't register line discipline (err = %d)\n", status);\r\nkfree(slip_devs);\r\n}\r\nreturn status;\r\n}\r\nstatic void __exit slip_exit(void)\r\n{\r\nint i;\r\nstruct net_device *dev;\r\nstruct slip *sl;\r\nunsigned long timeout = jiffies + HZ;\r\nint busy = 0;\r\nif (slip_devs == NULL)\r\nreturn;\r\ndo {\r\nif (busy)\r\nmsleep_interruptible(100);\r\nbusy = 0;\r\nfor (i = 0; i < slip_maxdev; i++) {\r\ndev = slip_devs[i];\r\nif (!dev)\r\ncontinue;\r\nsl = netdev_priv(dev);\r\nspin_lock_bh(&sl->lock);\r\nif (sl->tty) {\r\nbusy++;\r\ntty_hangup(sl->tty);\r\n}\r\nspin_unlock_bh(&sl->lock);\r\n}\r\n} while (busy && time_before(jiffies, timeout));\r\nfor (i = 0; i < slip_maxdev; i++) {\r\ndev = slip_devs[i];\r\nif (!dev)\r\ncontinue;\r\nslip_devs[i] = NULL;\r\nsl = netdev_priv(dev);\r\nif (sl->tty) {\r\nprintk(KERN_ERR "%s: tty discipline still running\n",\r\ndev->name);\r\ndev->destructor = NULL;\r\n}\r\nunregister_netdev(dev);\r\n}\r\nkfree(slip_devs);\r\nslip_devs = NULL;\r\ni = tty_unregister_ldisc(N_SLIP);\r\nif (i != 0)\r\nprintk(KERN_ERR "SLIP: can't unregister line discipline (err = %d)\n", i);\r\n}\r\nstatic void sl_outfill(unsigned long sls)\r\n{\r\nstruct slip *sl = (struct slip *)sls;\r\nspin_lock(&sl->lock);\r\nif (sl->tty == NULL)\r\ngoto out;\r\nif (sl->outfill) {\r\nif (test_bit(SLF_OUTWAIT, &sl->flags)) {\r\n#ifdef CONFIG_SLIP_MODE_SLIP6\r\nunsigned char s = (sl->mode & SL_MODE_SLIP6)?0x70:END;\r\n#else\r\nunsigned char s = END;\r\n#endif\r\nif (!netif_queue_stopped(sl->dev)) {\r\nsl->tty->ops->write(sl->tty, &s, 1);\r\n}\r\n} else\r\nset_bit(SLF_OUTWAIT, &sl->flags);\r\nmod_timer(&sl->outfill_timer, jiffies+sl->outfill*HZ);\r\n}\r\nout:\r\nspin_unlock(&sl->lock);\r\n}\r\nstatic void sl_keepalive(unsigned long sls)\r\n{\r\nstruct slip *sl = (struct slip *)sls;\r\nspin_lock(&sl->lock);\r\nif (sl->tty == NULL)\r\ngoto out;\r\nif (sl->keepalive) {\r\nif (test_bit(SLF_KEEPTEST, &sl->flags)) {\r\nif (sl->outfill)\r\n(void)del_timer(&sl->outfill_timer);\r\nprintk(KERN_DEBUG "%s: no packets received during keepalive timeout, hangup.\n", sl->dev->name);\r\ntty_hangup(sl->tty);\r\ngoto out;\r\n} else\r\nset_bit(SLF_KEEPTEST, &sl->flags);\r\nmod_timer(&sl->keepalive_timer, jiffies+sl->keepalive*HZ);\r\n}\r\nout:\r\nspin_unlock(&sl->lock);\r\n}
