static void xenfb_send_event(struct xenfb_info *info,\r\nunion xenfb_out_event *event)\r\n{\r\nu32 prod;\r\nprod = info->page->out_prod;\r\nmb();\r\nXENFB_OUT_RING_REF(info->page, prod) = *event;\r\nwmb();\r\ninfo->page->out_prod = prod + 1;\r\nnotify_remote_via_irq(info->irq);\r\n}\r\nstatic void xenfb_do_update(struct xenfb_info *info,\r\nint x, int y, int w, int h)\r\n{\r\nunion xenfb_out_event event;\r\nmemset(&event, 0, sizeof(event));\r\nevent.type = XENFB_TYPE_UPDATE;\r\nevent.update.x = x;\r\nevent.update.y = y;\r\nevent.update.width = w;\r\nevent.update.height = h;\r\nxenfb_send_event(info, &event);\r\n}\r\nstatic void xenfb_do_resize(struct xenfb_info *info)\r\n{\r\nunion xenfb_out_event event;\r\nmemset(&event, 0, sizeof(event));\r\nevent.resize = info->resize;\r\nxenfb_send_event(info, &event);\r\n}\r\nstatic int xenfb_queue_full(struct xenfb_info *info)\r\n{\r\nu32 cons, prod;\r\nprod = info->page->out_prod;\r\ncons = info->page->out_cons;\r\nreturn prod - cons == XENFB_OUT_RING_LEN;\r\n}\r\nstatic void xenfb_handle_resize_dpy(struct xenfb_info *info)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&info->resize_lock, flags);\r\nif (info->resize_dpy) {\r\nif (!xenfb_queue_full(info)) {\r\ninfo->resize_dpy = 0;\r\nxenfb_do_resize(info);\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->resize_lock, flags);\r\n}\r\nstatic void xenfb_refresh(struct xenfb_info *info,\r\nint x1, int y1, int w, int h)\r\n{\r\nunsigned long flags;\r\nint x2 = x1 + w - 1;\r\nint y2 = y1 + h - 1;\r\nxenfb_handle_resize_dpy(info);\r\nif (!info->update_wanted)\r\nreturn;\r\nspin_lock_irqsave(&info->dirty_lock, flags);\r\nif (info->y1 < y1)\r\ny1 = info->y1;\r\nif (info->y2 > y2)\r\ny2 = info->y2;\r\nif (info->x1 < x1)\r\nx1 = info->x1;\r\nif (info->x2 > x2)\r\nx2 = info->x2;\r\nif (xenfb_queue_full(info)) {\r\ninfo->x1 = x1;\r\ninfo->x2 = x2;\r\ninfo->y1 = y1;\r\ninfo->y2 = y2;\r\nspin_unlock_irqrestore(&info->dirty_lock, flags);\r\nreturn;\r\n}\r\ninfo->x1 = info->y1 = INT_MAX;\r\ninfo->x2 = info->y2 = 0;\r\nspin_unlock_irqrestore(&info->dirty_lock, flags);\r\nif (x1 <= x2 && y1 <= y2)\r\nxenfb_do_update(info, x1, y1, x2 - x1 + 1, y2 - y1 + 1);\r\n}\r\nstatic void xenfb_deferred_io(struct fb_info *fb_info,\r\nstruct list_head *pagelist)\r\n{\r\nstruct xenfb_info *info = fb_info->par;\r\nstruct page *page;\r\nunsigned long beg, end;\r\nint y1, y2, miny, maxy;\r\nminy = INT_MAX;\r\nmaxy = 0;\r\nlist_for_each_entry(page, pagelist, lru) {\r\nbeg = page->index << PAGE_SHIFT;\r\nend = beg + PAGE_SIZE - 1;\r\ny1 = beg / fb_info->fix.line_length;\r\ny2 = end / fb_info->fix.line_length;\r\nif (y2 >= fb_info->var.yres)\r\ny2 = fb_info->var.yres - 1;\r\nif (miny > y1)\r\nminy = y1;\r\nif (maxy < y2)\r\nmaxy = y2;\r\n}\r\nxenfb_refresh(info, 0, miny, fb_info->var.xres, maxy - miny + 1);\r\n}\r\nstatic int xenfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nu32 v;\r\nif (regno > info->cmap.len)\r\nreturn 1;\r\n#define CNVT_TOHW(val, width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\n#undef CNVT_TOHW\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\n((u32 *)info->pseudo_palette)[regno] = v;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xenfb_fillrect(struct fb_info *p, const struct fb_fillrect *rect)\r\n{\r\nstruct xenfb_info *info = p->par;\r\nsys_fillrect(p, rect);\r\nxenfb_refresh(info, rect->dx, rect->dy, rect->width, rect->height);\r\n}\r\nstatic void xenfb_imageblit(struct fb_info *p, const struct fb_image *image)\r\n{\r\nstruct xenfb_info *info = p->par;\r\nsys_imageblit(p, image);\r\nxenfb_refresh(info, image->dx, image->dy, image->width, image->height);\r\n}\r\nstatic void xenfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)\r\n{\r\nstruct xenfb_info *info = p->par;\r\nsys_copyarea(p, area);\r\nxenfb_refresh(info, area->dx, area->dy, area->width, area->height);\r\n}\r\nstatic ssize_t xenfb_write(struct fb_info *p, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct xenfb_info *info = p->par;\r\nssize_t res;\r\nres = fb_sys_write(p, buf, count, ppos);\r\nxenfb_refresh(info, 0, 0, info->page->width, info->page->height);\r\nreturn res;\r\n}\r\nstatic int\r\nxenfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct xenfb_info *xenfb_info;\r\nint required_mem_len;\r\nxenfb_info = info->par;\r\nif (!xenfb_info->feature_resize) {\r\nif (var->xres == video[KPARAM_WIDTH] &&\r\nvar->yres == video[KPARAM_HEIGHT] &&\r\nvar->bits_per_pixel == xenfb_info->page->depth) {\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nif (var->xres > video[KPARAM_WIDTH] || var->yres > video[KPARAM_HEIGHT])\r\nreturn -EINVAL;\r\nrequired_mem_len = var->xres * var->yres * xenfb_info->page->depth / 8;\r\nif (var->bits_per_pixel == xenfb_info->page->depth &&\r\nvar->xres <= info->fix.line_length / (XENFB_DEPTH / 8) &&\r\nrequired_mem_len <= info->fix.smem_len) {\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int xenfb_set_par(struct fb_info *info)\r\n{\r\nstruct xenfb_info *xenfb_info;\r\nunsigned long flags;\r\nxenfb_info = info->par;\r\nspin_lock_irqsave(&xenfb_info->resize_lock, flags);\r\nxenfb_info->resize.type = XENFB_TYPE_RESIZE;\r\nxenfb_info->resize.width = info->var.xres;\r\nxenfb_info->resize.height = info->var.yres;\r\nxenfb_info->resize.stride = info->fix.line_length;\r\nxenfb_info->resize.depth = info->var.bits_per_pixel;\r\nxenfb_info->resize.offset = 0;\r\nxenfb_info->resize_dpy = 1;\r\nspin_unlock_irqrestore(&xenfb_info->resize_lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xenfb_event_handler(int rq, void *dev_id)\r\n{\r\nstruct xenfb_info *info = dev_id;\r\nstruct xenfb_page *page = info->page;\r\nif (page->in_cons != page->in_prod) {\r\ninfo->page->in_cons = info->page->in_prod;\r\nnotify_remote_via_irq(info->irq);\r\n}\r\nxenfb_refresh(info, INT_MAX, INT_MAX, -INT_MAX, -INT_MAX);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit xenfb_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nstruct xenfb_info *info;\r\nstruct fb_info *fb_info;\r\nint fb_size;\r\nint val;\r\nint ret = 0;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\nxenbus_dev_fatal(dev, -ENOMEM, "allocating info structure");\r\nreturn -ENOMEM;\r\n}\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "videoram", "%d", &val) == 1) {\r\nif (val < video[KPARAM_MEM])\r\nvideo[KPARAM_MEM] = val;\r\n}\r\nfb_size = video[KPARAM_MEM] * 1024 * 1024;\r\nif (video[KPARAM_WIDTH] * video[KPARAM_HEIGHT] * XENFB_DEPTH / 8\r\n> fb_size) {\r\nvideo[KPARAM_WIDTH] = XENFB_WIDTH;\r\nvideo[KPARAM_HEIGHT] = XENFB_HEIGHT;\r\nfb_size = XENFB_DEFAULT_FB_LEN;\r\n}\r\ndev_set_drvdata(&dev->dev, info);\r\ninfo->xbdev = dev;\r\ninfo->irq = -1;\r\ninfo->x1 = info->y1 = INT_MAX;\r\nspin_lock_init(&info->dirty_lock);\r\nspin_lock_init(&info->resize_lock);\r\ninfo->fb = vzalloc(fb_size);\r\nif (info->fb == NULL)\r\ngoto error_nomem;\r\ninfo->nr_pages = (fb_size + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\ninfo->mfns = vmalloc(sizeof(unsigned long) * info->nr_pages);\r\nif (!info->mfns)\r\ngoto error_nomem;\r\ninfo->page = (void *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!info->page)\r\ngoto error_nomem;\r\nfb_info = framebuffer_alloc(sizeof(u32) * 256, NULL);\r\nif (fb_info == NULL)\r\ngoto error_nomem;\r\nfb_info->pseudo_palette = fb_info->par;\r\nfb_info->par = info;\r\nfb_info->screen_base = info->fb;\r\nfb_info->fbops = &xenfb_fb_ops;\r\nfb_info->var.xres_virtual = fb_info->var.xres = video[KPARAM_WIDTH];\r\nfb_info->var.yres_virtual = fb_info->var.yres = video[KPARAM_HEIGHT];\r\nfb_info->var.bits_per_pixel = XENFB_DEPTH;\r\nfb_info->var.red = (struct fb_bitfield){16, 8, 0};\r\nfb_info->var.green = (struct fb_bitfield){8, 8, 0};\r\nfb_info->var.blue = (struct fb_bitfield){0, 8, 0};\r\nfb_info->var.activate = FB_ACTIVATE_NOW;\r\nfb_info->var.height = -1;\r\nfb_info->var.width = -1;\r\nfb_info->var.vmode = FB_VMODE_NONINTERLACED;\r\nfb_info->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfb_info->fix.line_length = fb_info->var.xres * XENFB_DEPTH / 8;\r\nfb_info->fix.smem_start = 0;\r\nfb_info->fix.smem_len = fb_size;\r\nstrcpy(fb_info->fix.id, "xen");\r\nfb_info->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb_info->fix.accel = FB_ACCEL_NONE;\r\nfb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;\r\nret = fb_alloc_cmap(&fb_info->cmap, 256, 0);\r\nif (ret < 0) {\r\nframebuffer_release(fb_info);\r\nxenbus_dev_fatal(dev, ret, "fb_alloc_cmap");\r\ngoto error;\r\n}\r\nfb_info->fbdefio = &xenfb_defio;\r\nfb_deferred_io_init(fb_info);\r\nxenfb_init_shared_page(info, fb_info);\r\nret = xenfb_connect_backend(dev, info);\r\nif (ret < 0) {\r\nxenbus_dev_fatal(dev, ret, "xenfb_connect_backend");\r\ngoto error_fb;\r\n}\r\nret = register_framebuffer(fb_info);\r\nif (ret) {\r\nxenbus_dev_fatal(dev, ret, "register_framebuffer");\r\ngoto error_fb;\r\n}\r\ninfo->fb_info = fb_info;\r\nxenfb_make_preferred_console();\r\nreturn 0;\r\nerror_fb:\r\nfb_deferred_io_cleanup(fb_info);\r\nfb_dealloc_cmap(&fb_info->cmap);\r\nframebuffer_release(fb_info);\r\nerror_nomem:\r\nif (!ret) {\r\nret = -ENOMEM;\r\nxenbus_dev_fatal(dev, ret, "allocating device memory");\r\n}\r\nerror:\r\nxenfb_remove(dev);\r\nreturn ret;\r\n}\r\nstatic __devinit void\r\nxenfb_make_preferred_console(void)\r\n{\r\nstruct console *c;\r\nif (console_set_on_cmdline)\r\nreturn;\r\nconsole_lock();\r\nfor_each_console(c) {\r\nif (!strcmp(c->name, "tty") && c->index == 0)\r\nbreak;\r\n}\r\nconsole_unlock();\r\nif (c) {\r\nunregister_console(c);\r\nc->flags |= CON_CONSDEV;\r\nc->flags &= ~CON_PRINTBUFFER;\r\nregister_console(c);\r\n}\r\n}\r\nstatic int xenfb_resume(struct xenbus_device *dev)\r\n{\r\nstruct xenfb_info *info = dev_get_drvdata(&dev->dev);\r\nxenfb_disconnect_backend(info);\r\nxenfb_init_shared_page(info, info->fb_info);\r\nreturn xenfb_connect_backend(dev, info);\r\n}\r\nstatic int xenfb_remove(struct xenbus_device *dev)\r\n{\r\nstruct xenfb_info *info = dev_get_drvdata(&dev->dev);\r\nxenfb_disconnect_backend(info);\r\nif (info->fb_info) {\r\nfb_deferred_io_cleanup(info->fb_info);\r\nunregister_framebuffer(info->fb_info);\r\nfb_dealloc_cmap(&info->fb_info->cmap);\r\nframebuffer_release(info->fb_info);\r\n}\r\nfree_page((unsigned long)info->page);\r\nvfree(info->mfns);\r\nvfree(info->fb);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic unsigned long vmalloc_to_mfn(void *address)\r\n{\r\nreturn pfn_to_mfn(vmalloc_to_pfn(address));\r\n}\r\nstatic void xenfb_init_shared_page(struct xenfb_info *info,\r\nstruct fb_info *fb_info)\r\n{\r\nint i;\r\nint epd = PAGE_SIZE / sizeof(info->mfns[0]);\r\nfor (i = 0; i < info->nr_pages; i++)\r\ninfo->mfns[i] = vmalloc_to_mfn(info->fb + i * PAGE_SIZE);\r\nfor (i = 0; i * epd < info->nr_pages; i++)\r\ninfo->page->pd[i] = vmalloc_to_mfn(&info->mfns[i * epd]);\r\ninfo->page->width = fb_info->var.xres;\r\ninfo->page->height = fb_info->var.yres;\r\ninfo->page->depth = fb_info->var.bits_per_pixel;\r\ninfo->page->line_length = fb_info->fix.line_length;\r\ninfo->page->mem_length = fb_info->fix.smem_len;\r\ninfo->page->in_cons = info->page->in_prod = 0;\r\ninfo->page->out_cons = info->page->out_prod = 0;\r\n}\r\nstatic int xenfb_connect_backend(struct xenbus_device *dev,\r\nstruct xenfb_info *info)\r\n{\r\nint ret, evtchn, irq;\r\nstruct xenbus_transaction xbt;\r\nret = xenbus_alloc_evtchn(dev, &evtchn);\r\nif (ret)\r\nreturn ret;\r\nirq = bind_evtchn_to_irqhandler(evtchn, xenfb_event_handler,\r\n0, dev->devicetype, info);\r\nif (irq < 0) {\r\nxenbus_free_evtchn(dev, evtchn);\r\nxenbus_dev_fatal(dev, ret, "bind_evtchn_to_irqhandler");\r\nreturn irq;\r\n}\r\nagain:\r\nret = xenbus_transaction_start(&xbt);\r\nif (ret) {\r\nxenbus_dev_fatal(dev, ret, "starting transaction");\r\ngoto unbind_irq;\r\n}\r\nret = xenbus_printf(xbt, dev->nodename, "page-ref", "%lu",\r\nvirt_to_mfn(info->page));\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "event-channel", "%u",\r\nevtchn);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "protocol", "%s",\r\nXEN_IO_PROTO_ABI_NATIVE);\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_printf(xbt, dev->nodename, "feature-update", "1");\r\nif (ret)\r\ngoto error_xenbus;\r\nret = xenbus_transaction_end(xbt, 0);\r\nif (ret) {\r\nif (ret == -EAGAIN)\r\ngoto again;\r\nxenbus_dev_fatal(dev, ret, "completing transaction");\r\ngoto unbind_irq;\r\n}\r\nxenbus_switch_state(dev, XenbusStateInitialised);\r\ninfo->irq = irq;\r\nreturn 0;\r\nerror_xenbus:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, ret, "writing xenstore");\r\nunbind_irq:\r\nunbind_from_irqhandler(irq, info);\r\nreturn ret;\r\n}\r\nstatic void xenfb_disconnect_backend(struct xenfb_info *info)\r\n{\r\ninfo->update_wanted = 0;\r\nif (info->irq >= 0)\r\nunbind_from_irqhandler(info->irq, info);\r\ninfo->irq = -1;\r\n}\r\nstatic void xenfb_backend_changed(struct xenbus_device *dev,\r\nenum xenbus_state backend_state)\r\n{\r\nstruct xenfb_info *info = dev_get_drvdata(&dev->dev);\r\nint val;\r\nswitch (backend_state) {\r\ncase XenbusStateInitialising:\r\ncase XenbusStateInitialised:\r\ncase XenbusStateReconfiguring:\r\ncase XenbusStateReconfigured:\r\ncase XenbusStateUnknown:\r\ncase XenbusStateClosed:\r\nbreak;\r\ncase XenbusStateInitWait:\r\nInitWait:\r\nxenbus_switch_state(dev, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateConnected:\r\nif (dev->state != XenbusStateConnected)\r\ngoto InitWait;\r\nif (xenbus_scanf(XBT_NIL, info->xbdev->otherend,\r\n"request-update", "%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\ninfo->update_wanted = 1;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend,\r\n"feature-resize", "%d", &val) < 0)\r\nval = 0;\r\ninfo->feature_resize = val;\r\nbreak;\r\ncase XenbusStateClosing:\r\nxenbus_frontend_closed(dev);\r\nbreak;\r\n}\r\n}\r\nstatic int __init xenfb_init(void)\r\n{\r\nif (!xen_pv_domain())\r\nreturn -ENODEV;\r\nif (xen_initial_domain())\r\nreturn -ENODEV;\r\nreturn xenbus_register_frontend(&xenfb_driver);\r\n}\r\nstatic void __exit xenfb_cleanup(void)\r\n{\r\nxenbus_unregister_driver(&xenfb_driver);\r\n}
