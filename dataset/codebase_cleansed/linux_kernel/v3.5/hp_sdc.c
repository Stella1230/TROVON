static inline uint8_t hp_sdc_status_in8(void)\r\n{\r\nuint8_t status;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&hp_sdc.ibf_lock, flags);\r\nstatus = sdc_readb(hp_sdc.status_io);\r\nif (!(status & HP_SDC_STATUS_IBF))\r\nhp_sdc.ibf = 0;\r\nwrite_unlock_irqrestore(&hp_sdc.ibf_lock, flags);\r\nreturn status;\r\n}\r\nstatic inline uint8_t hp_sdc_data_in8(void)\r\n{\r\nreturn sdc_readb(hp_sdc.data_io);\r\n}\r\nstatic inline void hp_sdc_status_out8(uint8_t val)\r\n{\r\nunsigned long flags;\r\nwrite_lock_irqsave(&hp_sdc.ibf_lock, flags);\r\nhp_sdc.ibf = 1;\r\nif ((val & 0xf0) == 0xe0)\r\nhp_sdc.wi = 0xff;\r\nsdc_writeb(val, hp_sdc.status_io);\r\nwrite_unlock_irqrestore(&hp_sdc.ibf_lock, flags);\r\n}\r\nstatic inline void hp_sdc_data_out8(uint8_t val)\r\n{\r\nunsigned long flags;\r\nwrite_lock_irqsave(&hp_sdc.ibf_lock, flags);\r\nhp_sdc.ibf = 1;\r\nsdc_writeb(val, hp_sdc.data_io);\r\nwrite_unlock_irqrestore(&hp_sdc.ibf_lock, flags);\r\n}\r\nstatic inline void hp_sdc_spin_ibf(void)\r\n{\r\nunsigned long flags;\r\nrwlock_t *lock;\r\nlock = &hp_sdc.ibf_lock;\r\nread_lock_irqsave(lock, flags);\r\nif (!hp_sdc.ibf) {\r\nread_unlock_irqrestore(lock, flags);\r\nreturn;\r\n}\r\nread_unlock(lock);\r\nwrite_lock(lock);\r\nwhile (sdc_readb(hp_sdc.status_io) & HP_SDC_STATUS_IBF)\r\n{ }\r\nhp_sdc.ibf = 0;\r\nwrite_unlock_irqrestore(lock, flags);\r\n}\r\nstatic void hp_sdc_take(int irq, void *dev_id, uint8_t status, uint8_t data)\r\n{\r\nhp_sdc_transaction *curr;\r\nread_lock(&hp_sdc.rtq_lock);\r\nif (hp_sdc.rcurr < 0) {\r\nread_unlock(&hp_sdc.rtq_lock);\r\nreturn;\r\n}\r\ncurr = hp_sdc.tq[hp_sdc.rcurr];\r\nread_unlock(&hp_sdc.rtq_lock);\r\ncurr->seq[curr->idx++] = status;\r\ncurr->seq[curr->idx++] = data;\r\nhp_sdc.rqty -= 2;\r\ndo_gettimeofday(&hp_sdc.rtv);\r\nif (hp_sdc.rqty <= 0) {\r\nif (curr->seq[curr->actidx] & HP_SDC_ACT_SEMAPHORE)\r\nif (curr->act.semaphore)\r\nup(curr->act.semaphore);\r\nif (curr->seq[curr->actidx] & HP_SDC_ACT_CALLBACK)\r\nif (curr->act.irqhook)\r\ncurr->act.irqhook(irq, dev_id, status, data);\r\ncurr->actidx = curr->idx;\r\ncurr->idx++;\r\nwrite_lock(&hp_sdc.rtq_lock);\r\nhp_sdc.rcurr = -1;\r\nhp_sdc.rqty = 0;\r\nwrite_unlock(&hp_sdc.rtq_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\n}\r\n}\r\nstatic irqreturn_t hp_sdc_isr(int irq, void *dev_id)\r\n{\r\nuint8_t status, data;\r\nstatus = hp_sdc_status_in8();\r\ndata = hp_sdc_data_in8();\r\nif (((status & 0xf1) == 0x51) && data == 0x82)\r\nreturn IRQ_HANDLED;\r\nswitch (status & HP_SDC_STATUS_IRQMASK) {\r\ncase 0:\r\nbreak;\r\ncase HP_SDC_STATUS_USERTIMER:\r\ncase HP_SDC_STATUS_PERIODIC:\r\ncase HP_SDC_STATUS_TIMER:\r\nread_lock(&hp_sdc.hook_lock);\r\nif (hp_sdc.timer != NULL)\r\nhp_sdc.timer(irq, dev_id, status, data);\r\nread_unlock(&hp_sdc.hook_lock);\r\nbreak;\r\ncase HP_SDC_STATUS_REG:\r\nhp_sdc_take(irq, dev_id, status, data);\r\nbreak;\r\ncase HP_SDC_STATUS_HILCMD:\r\ncase HP_SDC_STATUS_HILDATA:\r\nread_lock(&hp_sdc.hook_lock);\r\nif (hp_sdc.hil != NULL)\r\nhp_sdc.hil(irq, dev_id, status, data);\r\nread_unlock(&hp_sdc.hook_lock);\r\nbreak;\r\ncase HP_SDC_STATUS_PUP:\r\nread_lock(&hp_sdc.hook_lock);\r\nif (hp_sdc.pup != NULL)\r\nhp_sdc.pup(irq, dev_id, status, data);\r\nelse\r\nprintk(KERN_INFO PREFIX "HP SDC reports successful PUP.\n");\r\nread_unlock(&hp_sdc.hook_lock);\r\nbreak;\r\ndefault:\r\nread_lock(&hp_sdc.hook_lock);\r\nif (hp_sdc.cooked != NULL)\r\nhp_sdc.cooked(irq, dev_id, status, data);\r\nread_unlock(&hp_sdc.hook_lock);\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t hp_sdc_nmisr(int irq, void *dev_id)\r\n{\r\nint status;\r\nstatus = hp_sdc_status_in8();\r\nprintk(KERN_WARNING PREFIX "NMI !\n");\r\n#if 0\r\nif (status & HP_SDC_NMISTATUS_FHS) {\r\nread_lock(&hp_sdc.hook_lock);\r\nif (hp_sdc.timer != NULL)\r\nhp_sdc.timer(irq, dev_id, status, 0);\r\nread_unlock(&hp_sdc.hook_lock);\r\n} else {\r\nprintk(KERN_WARNING PREFIX "HIL NMI\n");\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hp_sdc_tasklet(unsigned long foo)\r\n{\r\nwrite_lock_irq(&hp_sdc.rtq_lock);\r\nif (hp_sdc.rcurr >= 0) {\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nif (tv.tv_sec > hp_sdc.rtv.tv_sec)\r\ntv.tv_usec += USEC_PER_SEC;\r\nif (tv.tv_usec - hp_sdc.rtv.tv_usec > HP_SDC_MAX_REG_DELAY) {\r\nhp_sdc_transaction *curr;\r\nuint8_t tmp;\r\ncurr = hp_sdc.tq[hp_sdc.rcurr];\r\nprintk(KERN_WARNING PREFIX "read timeout (%ius)!\n",\r\n(int)(tv.tv_usec - hp_sdc.rtv.tv_usec));\r\ncurr->idx += hp_sdc.rqty;\r\nhp_sdc.rqty = 0;\r\ntmp = curr->seq[curr->actidx];\r\ncurr->seq[curr->actidx] |= HP_SDC_ACT_DEAD;\r\nif (tmp & HP_SDC_ACT_SEMAPHORE)\r\nif (curr->act.semaphore)\r\nup(curr->act.semaphore);\r\nif (tmp & HP_SDC_ACT_CALLBACK) {\r\nif (curr->act.irqhook)\r\ncurr->act.irqhook(0, NULL, 0, 0);\r\n}\r\ncurr->actidx = curr->idx;\r\ncurr->idx++;\r\nhp_sdc.rcurr = -1;\r\n}\r\n}\r\nwrite_unlock_irq(&hp_sdc.rtq_lock);\r\nhp_sdc_put();\r\n}\r\nunsigned long hp_sdc_put(void)\r\n{\r\nhp_sdc_transaction *curr;\r\nuint8_t act;\r\nint idx, curridx;\r\nint limit = 0;\r\nwrite_lock(&hp_sdc.lock);\r\nif (hp_sdc.ibf) {\r\nhp_sdc_status_in8();\r\nif (hp_sdc.ibf)\r\ngoto finish;\r\n}\r\nanew:\r\nif (hp_sdc.wcurr < 0)\r\nhp_sdc.wcurr = 0;\r\nread_lock_irq(&hp_sdc.rtq_lock);\r\nif (hp_sdc.rcurr == hp_sdc.wcurr)\r\nhp_sdc.wcurr++;\r\nread_unlock_irq(&hp_sdc.rtq_lock);\r\nif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\r\nhp_sdc.wcurr = 0;\r\ncurridx = hp_sdc.wcurr;\r\nif (hp_sdc.tq[curridx] != NULL)\r\ngoto start;\r\nwhile (++curridx != hp_sdc.wcurr) {\r\nif (curridx >= HP_SDC_QUEUE_LEN) {\r\ncurridx = -1;\r\ncontinue;\r\n}\r\nread_lock_irq(&hp_sdc.rtq_lock);\r\nif (hp_sdc.rcurr == curridx) {\r\nread_unlock_irq(&hp_sdc.rtq_lock);\r\ncontinue;\r\n}\r\nread_unlock_irq(&hp_sdc.rtq_lock);\r\nif (hp_sdc.tq[curridx] != NULL)\r\nbreak;\r\n}\r\nif (curridx == hp_sdc.wcurr) {\r\ncurridx = -1;\r\n}\r\nhp_sdc.wcurr = curridx;\r\nstart:\r\nif (hp_sdc.set_im) {\r\nhp_sdc_status_out8(hp_sdc.im | HP_SDC_CMD_SET_IM);\r\nhp_sdc.set_im = 0;\r\ngoto finish;\r\n}\r\nif (hp_sdc.wcurr == -1)\r\ngoto done;\r\ncurr = hp_sdc.tq[curridx];\r\nidx = curr->actidx;\r\nif (curr->actidx >= curr->endidx) {\r\nhp_sdc.tq[curridx] = NULL;\r\nhp_sdc.wcurr++;\r\nif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\r\nhp_sdc.wcurr = 0;\r\ngoto finish;\r\n}\r\nact = curr->seq[idx];\r\nidx++;\r\nif (curr->idx >= curr->endidx) {\r\nif (act & HP_SDC_ACT_DEALLOC)\r\nkfree(curr);\r\nhp_sdc.tq[curridx] = NULL;\r\nhp_sdc.wcurr++;\r\nif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\r\nhp_sdc.wcurr = 0;\r\ngoto finish;\r\n}\r\nwhile (act & HP_SDC_ACT_PRECMD) {\r\nif (curr->idx != idx) {\r\nidx++;\r\nact &= ~HP_SDC_ACT_PRECMD;\r\nbreak;\r\n}\r\nhp_sdc_status_out8(curr->seq[idx]);\r\ncurr->idx++;\r\nif ((act & HP_SDC_ACT_DURING) == HP_SDC_ACT_PRECMD)\r\ngoto actdone;\r\nif (act & HP_SDC_ACT_DATAOUT)\r\ncurr->idx++;\r\ngoto finish;\r\n}\r\nif (act & HP_SDC_ACT_DATAOUT) {\r\nint qty;\r\nqty = curr->seq[idx];\r\nidx++;\r\nif (curr->idx - idx < qty) {\r\nhp_sdc_data_out8(curr->seq[curr->idx]);\r\ncurr->idx++;\r\nif (curr->idx - idx >= qty &&\r\n(act & HP_SDC_ACT_DURING) == HP_SDC_ACT_DATAOUT)\r\ngoto actdone;\r\ngoto finish;\r\n}\r\nidx += qty;\r\nact &= ~HP_SDC_ACT_DATAOUT;\r\n} else\r\nwhile (act & HP_SDC_ACT_DATAREG) {\r\nint mask;\r\nuint8_t w7[4];\r\nmask = curr->seq[idx];\r\nif (idx != curr->idx) {\r\nidx++;\r\nidx += !!(mask & 1);\r\nidx += !!(mask & 2);\r\nidx += !!(mask & 4);\r\nidx += !!(mask & 8);\r\nact &= ~HP_SDC_ACT_DATAREG;\r\nbreak;\r\n}\r\nw7[0] = (mask & 1) ? curr->seq[++idx] : hp_sdc.r7[0];\r\nw7[1] = (mask & 2) ? curr->seq[++idx] : hp_sdc.r7[1];\r\nw7[2] = (mask & 4) ? curr->seq[++idx] : hp_sdc.r7[2];\r\nw7[3] = (mask & 8) ? curr->seq[++idx] : hp_sdc.r7[3];\r\nif (hp_sdc.wi > 0x73 || hp_sdc.wi < 0x70 ||\r\nw7[hp_sdc.wi - 0x70] == hp_sdc.r7[hp_sdc.wi - 0x70]) {\r\nint i = 0;\r\nwhile (i < 4 && w7[i] == hp_sdc.r7[i])\r\ni++;\r\nif (i < 4) {\r\nhp_sdc_status_out8(HP_SDC_CMD_SET_D0 + i);\r\nhp_sdc.wi = 0x70 + i;\r\ngoto finish;\r\n}\r\nidx++;\r\nif ((act & HP_SDC_ACT_DURING) == HP_SDC_ACT_DATAREG)\r\ngoto actdone;\r\ncurr->idx = idx;\r\nact &= ~HP_SDC_ACT_DATAREG;\r\nbreak;\r\n}\r\nhp_sdc_data_out8(w7[hp_sdc.wi - 0x70]);\r\nhp_sdc.r7[hp_sdc.wi - 0x70] = w7[hp_sdc.wi - 0x70];\r\nhp_sdc.wi++;\r\n{\r\nint i = 0;\r\nwhile ((i < 4) && w7[i] == hp_sdc.r7[i])\r\ni++;\r\nif (i >= 4) {\r\ncurr->idx = idx + 1;\r\nif ((act & HP_SDC_ACT_DURING) ==\r\nHP_SDC_ACT_DATAREG)\r\ngoto actdone;\r\n}\r\n}\r\ngoto finish;\r\n}\r\nread_lock_irq(&hp_sdc.rtq_lock);\r\nif (hp_sdc.rcurr >= 0) {\r\nread_unlock_irq(&hp_sdc.rtq_lock);\r\ngoto finish;\r\n}\r\nread_unlock_irq(&hp_sdc.rtq_lock);\r\nif (act & HP_SDC_ACT_POSTCMD) {\r\nuint8_t postcmd;\r\npostcmd = curr->seq[idx];\r\ncurr->idx++;\r\nif (act & HP_SDC_ACT_DATAIN) {\r\nhp_sdc.rqty = curr->seq[curr->idx];\r\ndo_gettimeofday(&hp_sdc.rtv);\r\ncurr->idx++;\r\nwrite_lock_irq(&hp_sdc.rtq_lock);\r\nhp_sdc.rcurr = curridx;\r\nwrite_unlock_irq(&hp_sdc.rtq_lock);\r\nhp_sdc_status_out8(postcmd);\r\ngoto finish;\r\n}\r\nhp_sdc_status_out8(postcmd);\r\ngoto actdone;\r\n}\r\nactdone:\r\nif (act & HP_SDC_ACT_SEMAPHORE)\r\nup(curr->act.semaphore);\r\nelse if (act & HP_SDC_ACT_CALLBACK)\r\ncurr->act.irqhook(0,NULL,0,0);\r\nif (curr->idx >= curr->endidx) {\r\nif (act & HP_SDC_ACT_DEALLOC)\r\nkfree(curr);\r\nhp_sdc.tq[curridx] = NULL;\r\n} else {\r\ncurr->actidx = idx + 1;\r\ncurr->idx = idx + 2;\r\n}\r\nhp_sdc.wcurr++;\r\nif (hp_sdc.wcurr >= HP_SDC_QUEUE_LEN)\r\nhp_sdc.wcurr = 0;\r\nfinish:\r\nif (!hp_sdc.ibf && limit++ < 20)\r\ngoto anew;\r\ndone:\r\nif (hp_sdc.wcurr >= 0)\r\ntasklet_schedule(&hp_sdc.task);\r\nwrite_unlock(&hp_sdc.lock);\r\nreturn 0;\r\n}\r\nint __hp_sdc_enqueue_transaction(hp_sdc_transaction *this)\r\n{\r\nint i;\r\nif (this == NULL) {\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < HP_SDC_QUEUE_LEN; i++)\r\nif (hp_sdc.tq[i] == this)\r\ngoto fail;\r\nthis->actidx = 0;\r\nthis->idx = 1;\r\nfor (i = 0; i < HP_SDC_QUEUE_LEN; i++)\r\nif (hp_sdc.tq[i] == NULL) {\r\nhp_sdc.tq[i] = this;\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING PREFIX "No free slot to add transaction.\n");\r\nreturn -EBUSY;\r\nfail:\r\nprintk(KERN_WARNING PREFIX "Transaction add failed: transaction already queued?\n");\r\nreturn -EINVAL;\r\n}\r\nint hp_sdc_enqueue_transaction(hp_sdc_transaction *this) {\r\nunsigned long flags;\r\nint ret;\r\nwrite_lock_irqsave(&hp_sdc.lock, flags);\r\nret = __hp_sdc_enqueue_transaction(this);\r\nwrite_unlock_irqrestore(&hp_sdc.lock,flags);\r\nreturn ret;\r\n}\r\nint hp_sdc_dequeue_transaction(hp_sdc_transaction *this)\r\n{\r\nunsigned long flags;\r\nint i;\r\nwrite_lock_irqsave(&hp_sdc.lock, flags);\r\nfor (i = 0; i < HP_SDC_QUEUE_LEN; i++)\r\nif (hp_sdc.tq[i] == this)\r\nhp_sdc.tq[i] = NULL;\r\nwrite_unlock_irqrestore(&hp_sdc.lock, flags);\r\nreturn 0;\r\n}\r\nint hp_sdc_request_timer_irq(hp_sdc_irqhook *callback)\r\n{\r\nif (callback == NULL || hp_sdc.dev == NULL)\r\nreturn -EINVAL;\r\nwrite_lock_irq(&hp_sdc.hook_lock);\r\nif (hp_sdc.timer != NULL) {\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\nreturn -EBUSY;\r\n}\r\nhp_sdc.timer = callback;\r\nhp_sdc.im &= ~HP_SDC_IM_FH;\r\nhp_sdc.im &= ~HP_SDC_IM_PT;\r\nhp_sdc.im &= ~HP_SDC_IM_TIMERS;\r\nhp_sdc.set_im = 1;\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nint hp_sdc_request_hil_irq(hp_sdc_irqhook *callback)\r\n{\r\nif (callback == NULL || hp_sdc.dev == NULL)\r\nreturn -EINVAL;\r\nwrite_lock_irq(&hp_sdc.hook_lock);\r\nif (hp_sdc.hil != NULL) {\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\nreturn -EBUSY;\r\n}\r\nhp_sdc.hil = callback;\r\nhp_sdc.im &= ~(HP_SDC_IM_HIL | HP_SDC_IM_RESET);\r\nhp_sdc.set_im = 1;\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nint hp_sdc_request_cooked_irq(hp_sdc_irqhook *callback)\r\n{\r\nif (callback == NULL || hp_sdc.dev == NULL)\r\nreturn -EINVAL;\r\nwrite_lock_irq(&hp_sdc.hook_lock);\r\nif (hp_sdc.cooked != NULL) {\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\nreturn -EBUSY;\r\n}\r\nhp_sdc.cooked = callback;\r\nhp_sdc.im &= ~(HP_SDC_IM_HIL | HP_SDC_IM_RESET);\r\nhp_sdc.set_im = 1;\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nint hp_sdc_release_timer_irq(hp_sdc_irqhook *callback)\r\n{\r\nwrite_lock_irq(&hp_sdc.hook_lock);\r\nif ((callback != hp_sdc.timer) ||\r\n(hp_sdc.timer == NULL)) {\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\nreturn -EINVAL;\r\n}\r\nhp_sdc.timer = NULL;\r\nhp_sdc.im |= HP_SDC_IM_TIMERS;\r\nhp_sdc.im |= HP_SDC_IM_FH;\r\nhp_sdc.im |= HP_SDC_IM_PT;\r\nhp_sdc.set_im = 1;\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nint hp_sdc_release_hil_irq(hp_sdc_irqhook *callback)\r\n{\r\nwrite_lock_irq(&hp_sdc.hook_lock);\r\nif ((callback != hp_sdc.hil) ||\r\n(hp_sdc.hil == NULL)) {\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\nreturn -EINVAL;\r\n}\r\nhp_sdc.hil = NULL;\r\nif(hp_sdc.cooked == NULL) {\r\nhp_sdc.im |= (HP_SDC_IM_HIL | HP_SDC_IM_RESET);\r\nhp_sdc.set_im = 1;\r\n}\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nint hp_sdc_release_cooked_irq(hp_sdc_irqhook *callback)\r\n{\r\nwrite_lock_irq(&hp_sdc.hook_lock);\r\nif ((callback != hp_sdc.cooked) ||\r\n(hp_sdc.cooked == NULL)) {\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\nreturn -EINVAL;\r\n}\r\nhp_sdc.cooked = NULL;\r\nif(hp_sdc.hil == NULL) {\r\nhp_sdc.im |= (HP_SDC_IM_HIL | HP_SDC_IM_RESET);\r\nhp_sdc.set_im = 1;\r\n}\r\nwrite_unlock_irq(&hp_sdc.hook_lock);\r\ntasklet_schedule(&hp_sdc.task);\r\nreturn 0;\r\n}\r\nstatic void hp_sdc_kicker(unsigned long data)\r\n{\r\ntasklet_schedule(&hp_sdc.task);\r\nmod_timer(&hp_sdc.kicker, jiffies + HZ);\r\n}\r\nstatic int __init hp_sdc_init(void)\r\n{\r\nchar *errstr;\r\nhp_sdc_transaction t_sync;\r\nuint8_t ts_sync[6];\r\nstruct semaphore s_sync;\r\nrwlock_init(&hp_sdc.lock);\r\nrwlock_init(&hp_sdc.ibf_lock);\r\nrwlock_init(&hp_sdc.rtq_lock);\r\nrwlock_init(&hp_sdc.hook_lock);\r\nhp_sdc.timer = NULL;\r\nhp_sdc.hil = NULL;\r\nhp_sdc.pup = NULL;\r\nhp_sdc.cooked = NULL;\r\nhp_sdc.im = HP_SDC_IM_MASK;\r\nhp_sdc.set_im = 1;\r\nhp_sdc.wi = 0xff;\r\nhp_sdc.r7[0] = 0xff;\r\nhp_sdc.r7[1] = 0xff;\r\nhp_sdc.r7[2] = 0xff;\r\nhp_sdc.r7[3] = 0xff;\r\nhp_sdc.ibf = 1;\r\nmemset(&hp_sdc.tq, 0, sizeof(hp_sdc.tq));\r\nhp_sdc.wcurr = -1;\r\nhp_sdc.rcurr = -1;\r\nhp_sdc.rqty = 0;\r\nhp_sdc.dev_err = -ENODEV;\r\nerrstr = "IO not found for";\r\nif (!hp_sdc.base_io)\r\ngoto err0;\r\nerrstr = "IRQ not found for";\r\nif (!hp_sdc.irq)\r\ngoto err0;\r\nhp_sdc.dev_err = -EBUSY;\r\n#if defined(__hppa__)\r\nerrstr = "IO not available for";\r\nif (request_region(hp_sdc.data_io, 2, hp_sdc_driver.name))\r\ngoto err0;\r\n#endif\r\nerrstr = "IRQ not available for";\r\nif (request_irq(hp_sdc.irq, &hp_sdc_isr, IRQF_SHARED|IRQF_SAMPLE_RANDOM,\r\n"HP SDC", &hp_sdc))\r\ngoto err1;\r\nerrstr = "NMI not available for";\r\nif (request_irq(hp_sdc.nmi, &hp_sdc_nmisr, IRQF_SHARED,\r\n"HP SDC NMI", &hp_sdc))\r\ngoto err2;\r\nprintk(KERN_INFO PREFIX "HP SDC at 0x%p, IRQ %d (NMI IRQ %d)\n",\r\n(void *)hp_sdc.base_io, hp_sdc.irq, hp_sdc.nmi);\r\nhp_sdc_status_in8();\r\nhp_sdc_data_in8();\r\ntasklet_init(&hp_sdc.task, hp_sdc_tasklet, 0);\r\nt_sync.actidx = 0;\r\nt_sync.idx = 1;\r\nt_sync.endidx = 6;\r\nt_sync.seq = ts_sync;\r\nts_sync[0] = HP_SDC_ACT_DATAREG | HP_SDC_ACT_SEMAPHORE;\r\nts_sync[1] = 0x0f;\r\nts_sync[2] = ts_sync[3] = ts_sync[4] = ts_sync[5] = 0;\r\nt_sync.act.semaphore = &s_sync;\r\nsema_init(&s_sync, 0);\r\nhp_sdc_enqueue_transaction(&t_sync);\r\ndown(&s_sync);\r\ninit_timer(&hp_sdc.kicker);\r\nhp_sdc.kicker.expires = jiffies + HZ;\r\nhp_sdc.kicker.function = &hp_sdc_kicker;\r\nadd_timer(&hp_sdc.kicker);\r\nhp_sdc.dev_err = 0;\r\nreturn 0;\r\nerr2:\r\nfree_irq(hp_sdc.irq, &hp_sdc);\r\nerr1:\r\nrelease_region(hp_sdc.data_io, 2);\r\nerr0:\r\nprintk(KERN_WARNING PREFIX ": %s SDC IO=0x%p IRQ=0x%x NMI=0x%x\n",\r\nerrstr, (void *)hp_sdc.base_io, hp_sdc.irq, hp_sdc.nmi);\r\nhp_sdc.dev = NULL;\r\nreturn hp_sdc.dev_err;\r\n}\r\nstatic void request_module_delayed(struct work_struct *work)\r\n{\r\nrequest_module("hp_sdc_mlc");\r\n}\r\nstatic int __init hp_sdc_init_hppa(struct parisc_device *d)\r\n{\r\nint ret;\r\nif (!d)\r\nreturn 1;\r\nif (hp_sdc.dev != NULL)\r\nreturn 1;\r\nhp_sdc.dev = d;\r\nhp_sdc.irq = d->irq;\r\nhp_sdc.nmi = d->aux_irq;\r\nhp_sdc.base_io = d->hpa.start;\r\nhp_sdc.data_io = d->hpa.start + 0x800;\r\nhp_sdc.status_io = d->hpa.start + 0x801;\r\nINIT_DELAYED_WORK(&moduleloader_work, request_module_delayed);\r\nret = hp_sdc_init();\r\nif (!ret)\r\nschedule_delayed_work(&moduleloader_work,\r\nmsecs_to_jiffies(2000));\r\nreturn ret;\r\n}\r\nstatic void hp_sdc_exit(void)\r\n{\r\nif (!hp_sdc.dev)\r\nreturn;\r\nwrite_lock_irq(&hp_sdc.lock);\r\nhp_sdc_spin_ibf();\r\nsdc_writeb(HP_SDC_CMD_SET_IM | HP_SDC_IM_MASK, hp_sdc.status_io);\r\nhp_sdc_spin_ibf();\r\nfree_irq(hp_sdc.nmi, &hp_sdc);\r\nfree_irq(hp_sdc.irq, &hp_sdc);\r\nwrite_unlock_irq(&hp_sdc.lock);\r\ndel_timer(&hp_sdc.kicker);\r\ntasklet_kill(&hp_sdc.task);\r\n#if defined(__hppa__)\r\ncancel_delayed_work_sync(&moduleloader_work);\r\nif (unregister_parisc_driver(&hp_sdc_driver))\r\nprintk(KERN_WARNING PREFIX "Error unregistering HP SDC");\r\n#endif\r\n}\r\nstatic int __init hp_sdc_register(void)\r\n{\r\nhp_sdc_transaction tq_init;\r\nuint8_t tq_init_seq[5];\r\nstruct semaphore tq_init_sem;\r\n#if defined(__mc68000__)\r\nmm_segment_t fs;\r\nunsigned char i;\r\n#endif\r\nif (hp_sdc_disabled) {\r\nprintk(KERN_WARNING PREFIX "HP SDC driver disabled by no_hpsdc=1.\n");\r\nreturn -ENODEV;\r\n}\r\nhp_sdc.dev = NULL;\r\nhp_sdc.dev_err = 0;\r\n#if defined(__hppa__)\r\nif (register_parisc_driver(&hp_sdc_driver)) {\r\nprintk(KERN_WARNING PREFIX "Error registering SDC with system bus tree.\n");\r\nreturn -ENODEV;\r\n}\r\n#elif defined(__mc68000__)\r\nif (!MACH_IS_HP300)\r\nreturn -ENODEV;\r\nhp_sdc.irq = 1;\r\nhp_sdc.nmi = 7;\r\nhp_sdc.base_io = (unsigned long) 0xf0428000;\r\nhp_sdc.data_io = (unsigned long) hp_sdc.base_io + 1;\r\nhp_sdc.status_io = (unsigned long) hp_sdc.base_io + 3;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nif (!get_user(i, (unsigned char *)hp_sdc.data_io))\r\nhp_sdc.dev = (void *)1;\r\nset_fs(fs);\r\nhp_sdc.dev_err = hp_sdc_init();\r\n#endif\r\nif (hp_sdc.dev == NULL) {\r\nprintk(KERN_WARNING PREFIX "No SDC found.\n");\r\nreturn hp_sdc.dev_err;\r\n}\r\nsema_init(&tq_init_sem, 0);\r\ntq_init.actidx = 0;\r\ntq_init.idx = 1;\r\ntq_init.endidx = 5;\r\ntq_init.seq = tq_init_seq;\r\ntq_init.act.semaphore = &tq_init_sem;\r\ntq_init_seq[0] =\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN | HP_SDC_ACT_SEMAPHORE;\r\ntq_init_seq[1] = HP_SDC_CMD_READ_KCC;\r\ntq_init_seq[2] = 1;\r\ntq_init_seq[3] = 0;\r\ntq_init_seq[4] = 0;\r\nhp_sdc_enqueue_transaction(&tq_init);\r\ndown(&tq_init_sem);\r\nup(&tq_init_sem);\r\nif ((tq_init_seq[0] & HP_SDC_ACT_DEAD) == HP_SDC_ACT_DEAD) {\r\nprintk(KERN_WARNING PREFIX "Error reading config byte.\n");\r\nhp_sdc_exit();\r\nreturn -ENODEV;\r\n}\r\nhp_sdc.r11 = tq_init_seq[4];\r\nif (hp_sdc.r11 & HP_SDC_CFG_NEW) {\r\nconst char *str;\r\nprintk(KERN_INFO PREFIX "New style SDC\n");\r\ntq_init_seq[1] = HP_SDC_CMD_READ_XTD;\r\ntq_init.actidx = 0;\r\ntq_init.idx = 1;\r\ndown(&tq_init_sem);\r\nhp_sdc_enqueue_transaction(&tq_init);\r\ndown(&tq_init_sem);\r\nup(&tq_init_sem);\r\nif ((tq_init_seq[0] & HP_SDC_ACT_DEAD) == HP_SDC_ACT_DEAD) {\r\nprintk(KERN_WARNING PREFIX "Error reading extended config byte.\n");\r\nreturn -ENODEV;\r\n}\r\nhp_sdc.r7e = tq_init_seq[4];\r\nHP_SDC_XTD_REV_STRINGS(hp_sdc.r7e & HP_SDC_XTD_REV, str)\r\nprintk(KERN_INFO PREFIX "Revision: %s\n", str);\r\nif (hp_sdc.r7e & HP_SDC_XTD_BEEPER)\r\nprintk(KERN_INFO PREFIX "TI SN76494 beeper present\n");\r\nif (hp_sdc.r7e & HP_SDC_XTD_BBRTC)\r\nprintk(KERN_INFO PREFIX "OKI MSM-58321 BBRTC present\n");\r\nprintk(KERN_INFO PREFIX "Spunking the self test register to force PUP "\r\n"on next firmware reset.\n");\r\ntq_init_seq[0] = HP_SDC_ACT_PRECMD |\r\nHP_SDC_ACT_DATAOUT | HP_SDC_ACT_SEMAPHORE;\r\ntq_init_seq[1] = HP_SDC_CMD_SET_STR;\r\ntq_init_seq[2] = 1;\r\ntq_init_seq[3] = 0;\r\ntq_init.actidx = 0;\r\ntq_init.idx = 1;\r\ntq_init.endidx = 4;\r\ndown(&tq_init_sem);\r\nhp_sdc_enqueue_transaction(&tq_init);\r\ndown(&tq_init_sem);\r\nup(&tq_init_sem);\r\n} else\r\nprintk(KERN_INFO PREFIX "Old style SDC (1820-%s).\n",\r\n(hp_sdc.r11 & HP_SDC_CFG_REV) ? "3300" : "2564/3087");\r\nreturn 0;\r\n}
