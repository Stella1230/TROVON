static void load_csrs(struct lance_private *lp)\r\n{\r\nvolatile struct lance_regs *ll = lp->ll;\r\nvolatile struct lance_init_block *aib = lp->lance_init_block;\r\nint leptr = LANCE_ADDR(aib);\r\nll->rap = LE_CSR1;\r\nll->rdp = (leptr & 0xFFFF);\r\nll->rap = LE_CSR2;\r\nll->rdp = leptr >> 16;\r\nll->rap = LE_CSR3;\r\nll->rdp = lp->busmaster_regval;\r\nll->rap = LE_CSR0;\r\n}\r\nstatic void lance_init_ring(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_init_block *aib = lp->lance_init_block;\r\nint leptr;\r\nint i;\r\nnetif_stop_queue(dev);\r\nlp->rx_new = lp->tx_new = 0;\r\nlp->rx_old = lp->tx_old = 0;\r\nib->mode = 0;\r\nib->phys_addr[0] = dev->dev_addr[1];\r\nib->phys_addr[1] = dev->dev_addr[0];\r\nib->phys_addr[2] = dev->dev_addr[3];\r\nib->phys_addr[3] = dev->dev_addr[2];\r\nib->phys_addr[4] = dev->dev_addr[5];\r\nib->phys_addr[5] = dev->dev_addr[4];\r\nnetdev_dbg(dev, "TX rings:\n");\r\nfor (i = 0; i <= 1 << lp->lance_log_tx_bufs; i++) {\r\nleptr = LANCE_ADDR(&aib->tx_buf[i][0]);\r\nib->btx_ring[i].tmd0 = leptr;\r\nib->btx_ring[i].tmd1_hadr = leptr >> 16;\r\nib->btx_ring[i].tmd1_bits = 0;\r\nib->btx_ring[i].length = 0xf000;\r\nib->btx_ring[i].misc = 0;\r\nif (i < 3)\r\nnetdev_dbg(dev, "%d: 0x%08x\n", i, leptr);\r\n}\r\nnetdev_dbg(dev, "RX rings:\n");\r\nfor (i = 0; i < 1 << lp->lance_log_rx_bufs; i++) {\r\nleptr = LANCE_ADDR(&aib->rx_buf[i][0]);\r\nib->brx_ring[i].rmd0 = leptr;\r\nib->brx_ring[i].rmd1_hadr = leptr >> 16;\r\nib->brx_ring[i].rmd1_bits = LE_R1_OWN;\r\nib->brx_ring[i].length = -RX_BUFF_SIZE | 0xf000;\r\nib->brx_ring[i].mblength = 0;\r\nif (i < 3)\r\nnetdev_dbg(dev, "%d: 0x%08x\n", i, leptr);\r\n}\r\nleptr = LANCE_ADDR(&aib->brx_ring);\r\nib->rx_len = (lp->lance_log_rx_bufs << 13) | (leptr >> 16);\r\nib->rx_ptr = leptr;\r\nnetdev_dbg(dev, "RX ptr: %08x\n", leptr);\r\nleptr = LANCE_ADDR(&aib->btx_ring);\r\nib->tx_len = (lp->lance_log_tx_bufs << 13) | (leptr >> 16);\r\nib->tx_ptr = leptr;\r\nnetdev_dbg(dev, "TX ptr: %08x\n", leptr);\r\nib->filter[0] = 0;\r\nib->filter[1] = 0;\r\n}\r\nstatic int init_restart_lance(struct lance_private *lp)\r\n{\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint i;\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_INIT;\r\nfor (i = 0; (i < 100) && !(ll->rdp & (LE_C0_ERR | LE_C0_IDON)); i++)\r\nbarrier();\r\nif ((i == 100) || (ll->rdp & LE_C0_ERR)) {\r\npr_err("unopened after %d ticks, csr0=%04x\n", i, ll->rdp);\r\nreturn -EIO;\r\n}\r\nll->rdp = LE_C0_IDON;\r\nll->rdp = LE_C0_INEA | LE_C0_STRT;\r\nreturn 0;\r\n}\r\nstatic int lance_rx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_regs *ll = lp->ll;\r\nvolatile struct lance_rx_desc *rd;\r\nunsigned char bits;\r\n#ifdef TEST_HITS\r\nint i;\r\nchar buf[RX_RING_SIZE + 1];\r\nfor (i = 0; i < RX_RING_SIZE; i++) {\r\nchar r1_own = ib->brx_ring[i].rmd1_bits & LE_R1_OWN;\r\nif (i == lp->rx_new)\r\nbuf[i] = r1_own ? '_' : 'X';\r\nelse\r\nbuf[i] = r1_own ? '.' : '1';\r\n}\r\nbuf[RX_RING_SIZE] = 0;\r\npr_debug("RxRing TestHits: [%s]\n", buf);\r\n#endif\r\nll->rdp = LE_C0_RINT | LE_C0_INEA;\r\nfor (rd = &ib->brx_ring[lp->rx_new];\r\n!((bits = rd->rmd1_bits) & LE_R1_OWN);\r\nrd = &ib->brx_ring[lp->rx_new]) {\r\nif ((bits & LE_R1_POK) != LE_R1_POK) {\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\ncontinue;\r\n} else if (bits & LE_R1_ERR) {\r\nif (bits & LE_R1_BUF)\r\ndev->stats.rx_fifo_errors++;\r\nif (bits & LE_R1_CRC)\r\ndev->stats.rx_crc_errors++;\r\nif (bits & LE_R1_OFL)\r\ndev->stats.rx_over_errors++;\r\nif (bits & LE_R1_FRA)\r\ndev->stats.rx_frame_errors++;\r\nif (bits & LE_R1_EOP)\r\ndev->stats.rx_errors++;\r\n} else {\r\nint len = (rd->mblength & 0xfff) - 4;\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, len + 2);\r\nif (!skb) {\r\nnetdev_warn(dev, "Memory squeeze, deferring packet\n");\r\ndev->stats.rx_dropped++;\r\nrd->mblength = 0;\r\nrd->rmd1_bits = LE_R1_OWN;\r\nlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\r\nreturn 0;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_put(skb, len);\r\nskb_copy_to_linear_data(skb,\r\n(unsigned char *)&ib->rx_buf[lp->rx_new][0],\r\nlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\n}\r\nrd->mblength = 0;\r\nrd->rmd1_bits = LE_R1_OWN;\r\nlp->rx_new = (lp->rx_new + 1) & lp->rx_ring_mod_mask;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lance_tx(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_regs *ll = lp->ll;\r\nvolatile struct lance_tx_desc *td;\r\nint i, j;\r\nint status;\r\nll->rdp = LE_C0_TINT | LE_C0_INEA;\r\nj = lp->tx_old;\r\nfor (i = j; i != lp->tx_new; i = j) {\r\ntd = &ib->btx_ring[i];\r\nif (td->tmd1_bits & LE_T1_OWN)\r\nbreak;\r\nif (td->tmd1_bits & LE_T1_ERR) {\r\nstatus = td->misc;\r\ndev->stats.tx_errors++;\r\nif (status & LE_T3_RTY)\r\ndev->stats.tx_aborted_errors++;\r\nif (status & LE_T3_LCOL)\r\ndev->stats.tx_window_errors++;\r\nif (status & LE_T3_CLOS) {\r\ndev->stats.tx_carrier_errors++;\r\nif (lp->auto_select) {\r\nlp->tpe = 1 - lp->tpe;\r\nnetdev_err(dev, "Carrier Lost, trying %s\n",\r\nlp->tpe ? "TPE" : "AUI");\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_STOP;\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nreturn 0;\r\n}\r\n}\r\nif (status & (LE_T3_BUF | LE_T3_UFL)) {\r\ndev->stats.tx_fifo_errors++;\r\nnetdev_err(dev, "Tx: ERR_BUF|ERR_UFL, restarting\n");\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_STOP;\r\nlance_init_ring(dev);\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nreturn 0;\r\n}\r\n} else if ((td->tmd1_bits & LE_T1_POK) == LE_T1_POK) {\r\ntd->tmd1_bits &= ~(LE_T1_POK);\r\nif (td->tmd1_bits & LE_T1_EONE)\r\ndev->stats.collisions++;\r\nif (td->tmd1_bits & LE_T1_EMORE)\r\ndev->stats.collisions += 2;\r\ndev->stats.tx_packets++;\r\n}\r\nj = (j + 1) & lp->tx_ring_mod_mask;\r\n}\r\nlp->tx_old = j;\r\nll->rdp = LE_C0_TINT | LE_C0_INEA;\r\nreturn 0;\r\n}\r\nstatic int lance_tx_buffs_avail(struct lance_private *lp)\r\n{\r\nif (lp->tx_old <= lp->tx_new)\r\nreturn lp->tx_old + lp->tx_ring_mod_mask - lp->tx_new;\r\nreturn lp->tx_old - lp->tx_new - 1;\r\n}\r\nstatic irqreturn_t lance_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint csr0;\r\nll->rap = LE_CSR0;\r\ncsr0 = ll->rdp;\r\nif (!(csr0 & LE_C0_INTR))\r\nreturn IRQ_NONE;\r\nll->rdp = csr0 & ~(LE_C0_INEA | LE_C0_TDMD | LE_C0_STOP | LE_C0_STRT |\r\nLE_C0_INIT);\r\nif (csr0 & LE_C0_ERR) {\r\nll->rdp = LE_C0_BABL | LE_C0_ERR | LE_C0_MISS | LE_C0_INEA;\r\n}\r\nif (csr0 & LE_C0_RINT)\r\nlance_rx(dev);\r\nif (csr0 & LE_C0_TINT)\r\nlance_tx(dev);\r\nif (csr0 & LE_C0_BABL)\r\ndev->stats.tx_errors++;\r\nif (csr0 & LE_C0_MISS)\r\ndev->stats.rx_errors++;\r\nif (csr0 & LE_C0_MERR) {\r\nnetdev_err(dev, "Bus master arbitration failure, status %04x\n",\r\ncsr0);\r\nll->rdp = LE_C0_STRT;\r\n}\r\nif (netif_queue_stopped(dev) && lance_tx_buffs_avail(lp) > 0)\r\nnetif_wake_queue(dev);\r\nll->rap = LE_CSR0;\r\nll->rdp = (LE_C0_BABL | LE_C0_CERR | LE_C0_MISS | LE_C0_MERR |\r\nLE_C0_IDON | LE_C0_INEA);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lance_open(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint ret;\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_STOP;\r\nret = request_irq(IRQ_AMIGA_PORTS, lance_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nload_csrs(lp);\r\nlance_init_ring(dev);\r\nnetif_start_queue(dev);\r\nreturn init_restart_lance(lp);\r\n}\r\nstatic int lance_close(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&lp->multicast_timer);\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_STOP;\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\nreturn 0;\r\n}\r\nstatic inline int lance_reset(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nint status;\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_STOP;\r\nload_csrs(lp);\r\nlance_init_ring(dev);\r\ndev->trans_start = jiffies;\r\nnetif_start_queue(dev);\r\nstatus = init_restart_lance(lp);\r\nnetdev_dbg(dev, "Lance restart=%d\n", status);\r\nreturn status;\r\n}\r\nstatic void lance_tx_timeout(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nnetdev_err(dev, "transmit timed out, status %04x, reset\n", ll->rdp);\r\nlance_reset(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t lance_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_regs *ll = lp->ll;\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nint entry, skblen;\r\nint status = NETDEV_TX_OK;\r\nunsigned long flags;\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nskblen = max_t(unsigned, skb->len, ETH_ZLEN);\r\nlocal_irq_save(flags);\r\nif (!lance_tx_buffs_avail(lp)) {\r\nlocal_irq_restore(flags);\r\nreturn NETDEV_TX_LOCKED;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_DEBUG, "skb->data: ", DUMP_PREFIX_NONE,\r\n16, 1, skb->data, 64, true);\r\n#endif\r\nentry = lp->tx_new & lp->tx_ring_mod_mask;\r\nib->btx_ring[entry].length = (-skblen) | 0xf000;\r\nib->btx_ring[entry].misc = 0;\r\nskb_copy_from_linear_data(skb, (void *)&ib->tx_buf[entry][0], skblen);\r\nib->btx_ring[entry].tmd1_bits = (LE_T1_POK | LE_T1_OWN);\r\nlp->tx_new = (lp->tx_new+1) & lp->tx_ring_mod_mask;\r\ndev->stats.tx_bytes += skblen;\r\nif (lance_tx_buffs_avail(lp) <= 0)\r\nnetif_stop_queue(dev);\r\nll->rdp = LE_C0_INEA | LE_C0_TDMD;\r\ndev_kfree_skb(skb);\r\nlocal_irq_restore(flags);\r\nreturn status;\r\n}\r\nstatic void lance_load_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile u16 *mcast_table = (u16 *)&ib->filter;\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nif (dev->flags & IFF_ALLMULTI) {\r\nib->filter[0] = 0xffffffff;\r\nib->filter[1] = 0xffffffff;\r\nreturn;\r\n}\r\nib->filter[0] = 0;\r\nib->filter[1] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc_le(6, ha->addr);\r\ncrc = crc >> 26;\r\nmcast_table[crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\n}\r\nstatic void lance_set_multicast(struct net_device *dev)\r\n{\r\nstruct lance_private *lp = netdev_priv(dev);\r\nvolatile struct lance_init_block *ib = lp->init_block;\r\nvolatile struct lance_regs *ll = lp->ll;\r\nif (!netif_running(dev))\r\nreturn;\r\nif (lp->tx_old != lp->tx_new) {\r\nmod_timer(&lp->multicast_timer, jiffies + 4);\r\nnetif_wake_queue(dev);\r\nreturn;\r\n}\r\nnetif_stop_queue(dev);\r\nll->rap = LE_CSR0;\r\nll->rdp = LE_C0_STOP;\r\nlance_init_ring(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nib->mode |= LE_MO_PROM;\r\n} else {\r\nib->mode &= ~LE_MO_PROM;\r\nlance_load_multicast(dev);\r\n}\r\nload_csrs(lp);\r\ninit_restart_lance(lp);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int __devinit a2065_init_one(struct zorro_dev *z,\r\nconst struct zorro_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct lance_private *priv;\r\nunsigned long board = z->resource.start;\r\nunsigned long base_addr = board + A2065_LANCE;\r\nunsigned long mem_start = board + A2065_RAM;\r\nstruct resource *r1, *r2;\r\nint err;\r\nr1 = request_mem_region(base_addr, sizeof(struct lance_regs),\r\n"Am7990");\r\nif (!r1)\r\nreturn -EBUSY;\r\nr2 = request_mem_region(mem_start, A2065_RAM_SIZE, "RAM");\r\nif (!r2) {\r\nrelease_mem_region(base_addr, sizeof(struct lance_regs));\r\nreturn -EBUSY;\r\n}\r\ndev = alloc_etherdev(sizeof(struct lance_private));\r\nif (dev == NULL) {\r\nrelease_mem_region(base_addr, sizeof(struct lance_regs));\r\nrelease_mem_region(mem_start, A2065_RAM_SIZE);\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(dev);\r\nr1->name = dev->name;\r\nr2->name = dev->name;\r\ndev->dev_addr[0] = 0x00;\r\nif (z->id != ZORRO_PROD_AMERISTAR_A2065) {\r\ndev->dev_addr[1] = 0x80;\r\ndev->dev_addr[2] = 0x10;\r\n} else {\r\ndev->dev_addr[1] = 0x00;\r\ndev->dev_addr[2] = 0x9f;\r\n}\r\ndev->dev_addr[3] = (z->rom.er_SerialNumber >> 16) & 0xff;\r\ndev->dev_addr[4] = (z->rom.er_SerialNumber >> 8) & 0xff;\r\ndev->dev_addr[5] = z->rom.er_SerialNumber & 0xff;\r\ndev->base_addr = ZTWO_VADDR(base_addr);\r\ndev->mem_start = ZTWO_VADDR(mem_start);\r\ndev->mem_end = dev->mem_start + A2065_RAM_SIZE;\r\npriv->ll = (volatile struct lance_regs *)dev->base_addr;\r\npriv->init_block = (struct lance_init_block *)dev->mem_start;\r\npriv->lance_init_block = (struct lance_init_block *)A2065_RAM;\r\npriv->auto_select = 0;\r\npriv->busmaster_regval = LE_C3_BSWP;\r\npriv->lance_log_rx_bufs = LANCE_LOG_RX_BUFFERS;\r\npriv->lance_log_tx_bufs = LANCE_LOG_TX_BUFFERS;\r\npriv->rx_ring_mod_mask = RX_RING_MOD_MASK;\r\npriv->tx_ring_mod_mask = TX_RING_MOD_MASK;\r\ndev->netdev_ops = &lance_netdev_ops;\r\ndev->watchdog_timeo = 5*HZ;\r\ndev->dma = 0;\r\ninit_timer(&priv->multicast_timer);\r\npriv->multicast_timer.data = (unsigned long) dev;\r\npriv->multicast_timer.function =\r\n(void (*)(unsigned long))lance_set_multicast;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nrelease_mem_region(base_addr, sizeof(struct lance_regs));\r\nrelease_mem_region(mem_start, A2065_RAM_SIZE);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nzorro_set_drvdata(z, dev);\r\nnetdev_info(dev, "A2065 at 0x%08lx, Ethernet Address %pM\n",\r\nboard, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void __devexit a2065_remove_one(struct zorro_dev *z)\r\n{\r\nstruct net_device *dev = zorro_get_drvdata(z);\r\nunregister_netdev(dev);\r\nrelease_mem_region(ZTWO_PADDR(dev->base_addr),\r\nsizeof(struct lance_regs));\r\nrelease_mem_region(ZTWO_PADDR(dev->mem_start), A2065_RAM_SIZE);\r\nfree_netdev(dev);\r\n}\r\nstatic int __init a2065_init_module(void)\r\n{\r\nreturn zorro_register_driver(&a2065_driver);\r\n}\r\nstatic void __exit a2065_cleanup_module(void)\r\n{\r\nzorro_unregister_driver(&a2065_driver);\r\n}
