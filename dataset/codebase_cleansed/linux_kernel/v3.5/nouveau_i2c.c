static void\r\ni2c_drive_scl(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *port = data;\r\nif (port->type == 0) {\r\nu8 val = NVReadVgaCrtc(port->dev, 0, port->drive);\r\nif (state) val |= 0x20;\r\nelse val &= 0xdf;\r\nNVWriteVgaCrtc(port->dev, 0, port->drive, val | 0x01);\r\n} else\r\nif (port->type == 4) {\r\nnv_mask(port->dev, port->drive, 0x2f, state ? 0x21 : 0x01);\r\n} else\r\nif (port->type == 5) {\r\nif (state) port->state |= 0x01;\r\nelse port->state &= 0xfe;\r\nnv_wr32(port->dev, port->drive, 4 | port->state);\r\n}\r\n}\r\nstatic void\r\ni2c_drive_sda(void *data, int state)\r\n{\r\nstruct nouveau_i2c_chan *port = data;\r\nif (port->type == 0) {\r\nu8 val = NVReadVgaCrtc(port->dev, 0, port->drive);\r\nif (state) val |= 0x10;\r\nelse val &= 0xef;\r\nNVWriteVgaCrtc(port->dev, 0, port->drive, val | 0x01);\r\n} else\r\nif (port->type == 4) {\r\nnv_mask(port->dev, port->drive, 0x1f, state ? 0x11 : 0x01);\r\n} else\r\nif (port->type == 5) {\r\nif (state) port->state |= 0x02;\r\nelse port->state &= 0xfd;\r\nnv_wr32(port->dev, port->drive, 4 | port->state);\r\n}\r\n}\r\nstatic int\r\ni2c_sense_scl(void *data)\r\n{\r\nstruct nouveau_i2c_chan *port = data;\r\nstruct drm_nouveau_private *dev_priv = port->dev->dev_private;\r\nif (port->type == 0) {\r\nreturn !!(NVReadVgaCrtc(port->dev, 0, port->sense) & 0x04);\r\n} else\r\nif (port->type == 4) {\r\nreturn !!(nv_rd32(port->dev, port->sense) & 0x00040000);\r\n} else\r\nif (port->type == 5) {\r\nif (dev_priv->card_type < NV_D0)\r\nreturn !!(nv_rd32(port->dev, port->sense) & 0x01);\r\nelse\r\nreturn !!(nv_rd32(port->dev, port->sense) & 0x10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_sense_sda(void *data)\r\n{\r\nstruct nouveau_i2c_chan *port = data;\r\nstruct drm_nouveau_private *dev_priv = port->dev->dev_private;\r\nif (port->type == 0) {\r\nreturn !!(NVReadVgaCrtc(port->dev, 0, port->sense) & 0x08);\r\n} else\r\nif (port->type == 4) {\r\nreturn !!(nv_rd32(port->dev, port->sense) & 0x00080000);\r\n} else\r\nif (port->type == 5) {\r\nif (dev_priv->card_type < NV_D0)\r\nreturn !!(nv_rd32(port->dev, port->sense) & 0x02);\r\nelse\r\nreturn !!(nv_rd32(port->dev, port->sense) & 0x20);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 *\r\ni2c_table(struct drm_device *dev, u8 *version)\r\n{\r\nu8 *dcb = dcb_table(dev), *i2c = NULL;\r\nif (dcb) {\r\nif (dcb[0] >= 0x15)\r\ni2c = ROMPTR(dev, dcb[2]);\r\nif (dcb[0] >= 0x30)\r\ni2c = ROMPTR(dev, dcb[4]);\r\n}\r\nif (i2c) {\r\n*version = dcb[0];\r\nif (*version >= 0x30)\r\n*version = i2c[0];\r\n}\r\nreturn i2c;\r\n}\r\nint\r\nnouveau_i2c_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nvbios *bios = &dev_priv->vbios;\r\nstruct nouveau_i2c_chan *port;\r\nu8 version = 0x00, entries, recordlen;\r\nu8 *i2c, *entry, legacy[2][4] = {};\r\nint ret, i;\r\nINIT_LIST_HEAD(&dev_priv->i2c_ports);\r\ni2c = i2c_table(dev, &version);\r\nif (!i2c) {\r\nu8 *bmp = &bios->data[bios->offset];\r\nif (bios->type != NVBIOS_BMP)\r\nreturn -ENODEV;\r\nlegacy[0][0] = NV_CIO_CRE_DDC_WR__INDEX;\r\nlegacy[0][1] = NV_CIO_CRE_DDC_STATUS__INDEX;\r\nlegacy[1][0] = NV_CIO_CRE_DDC0_WR__INDEX;\r\nlegacy[1][1] = NV_CIO_CRE_DDC0_STATUS__INDEX;\r\nif (bmp[5] < 4)\r\ni2c = &bios->data[0x48];\r\nelse\r\ni2c = &bmp[0x36];\r\nif (i2c[4]) legacy[0][0] = i2c[4];\r\nif (i2c[5]) legacy[0][1] = i2c[5];\r\nif (i2c[6]) legacy[1][0] = i2c[6];\r\nif (i2c[7]) legacy[1][1] = i2c[7];\r\n}\r\nif (version >= 0x30) {\r\nentry = i2c[1] + i2c;\r\nentries = i2c[2];\r\nrecordlen = i2c[3];\r\n} else\r\nif (version) {\r\nentry = i2c;\r\nentries = 16;\r\nrecordlen = 4;\r\n} else {\r\nentry = legacy[0];\r\nentries = 2;\r\nrecordlen = 4;\r\n}\r\nfor (i = 0; i < entries; i++, entry += recordlen) {\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (port == NULL) {\r\nnouveau_i2c_fini(dev);\r\nreturn -ENOMEM;\r\n}\r\nport->type = entry[3];\r\nif (version < 0x30) {\r\nport->type &= 0x07;\r\nif (port->type == 0x07)\r\nport->type = 0xff;\r\n}\r\nif (port->type == 0xff) {\r\nkfree(port);\r\ncontinue;\r\n}\r\nswitch (port->type) {\r\ncase 0:\r\nport->drive = entry[0];\r\nport->sense = entry[1];\r\nbreak;\r\ncase 4:\r\nport->drive = 0x600800 + entry[1];\r\nport->sense = port->drive;\r\nbreak;\r\ncase 5:\r\nport->drive = entry[0] & 0x0f;\r\nif (dev_priv->card_type < NV_D0) {\r\nif (port->drive >= ARRAY_SIZE(nv50_i2c_port))\r\nbreak;\r\nport->drive = nv50_i2c_port[port->drive];\r\nport->sense = port->drive;\r\n} else {\r\nport->drive = 0x00d014 + (port->drive * 0x20);\r\nport->sense = port->drive;\r\n}\r\nbreak;\r\ncase 6:\r\nport->drive = entry[0];\r\nport->sense = port->drive;\r\nport->adapter.algo = &nouveau_dp_i2c_algo;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!port->adapter.algo && !port->drive) {\r\nNV_ERROR(dev, "I2C%d: type %d index %x/%x unknown\n",\r\ni, port->type, port->drive, port->sense);\r\nkfree(port);\r\ncontinue;\r\n}\r\nsnprintf(port->adapter.name, sizeof(port->adapter.name),\r\n"nouveau-%s-%d", pci_name(dev->pdev), i);\r\nport->adapter.owner = THIS_MODULE;\r\nport->adapter.dev.parent = &dev->pdev->dev;\r\nport->dev = dev;\r\nport->index = i;\r\nport->dcb = ROM32(entry[0]);\r\ni2c_set_adapdata(&port->adapter, i2c);\r\nif (port->adapter.algo != &nouveau_dp_i2c_algo) {\r\nport->adapter.algo_data = &port->bit;\r\nport->bit.udelay = 10;\r\nport->bit.timeout = usecs_to_jiffies(2200);\r\nport->bit.data = port;\r\nport->bit.setsda = i2c_drive_sda;\r\nport->bit.setscl = i2c_drive_scl;\r\nport->bit.getsda = i2c_sense_sda;\r\nport->bit.getscl = i2c_sense_scl;\r\ni2c_drive_scl(port, 0);\r\ni2c_drive_sda(port, 1);\r\ni2c_drive_scl(port, 1);\r\nret = i2c_bit_add_bus(&port->adapter);\r\n} else {\r\nport->adapter.algo = &nouveau_dp_i2c_algo;\r\nret = i2c_add_adapter(&port->adapter);\r\n}\r\nif (ret) {\r\nNV_ERROR(dev, "I2C%d: failed register: %d\n", i, ret);\r\nkfree(port);\r\ncontinue;\r\n}\r\nlist_add_tail(&port->head, &dev_priv->i2c_ports);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_i2c_fini(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_i2c_chan *port, *tmp;\r\nlist_for_each_entry_safe(port, tmp, &dev_priv->i2c_ports, head) {\r\ni2c_del_adapter(&port->adapter);\r\nkfree(port);\r\n}\r\n}\r\nstruct nouveau_i2c_chan *\r\nnouveau_i2c_find(struct drm_device *dev, u8 index)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_i2c_chan *port;\r\nif (index == NV_I2C_DEFAULT(0) ||\r\nindex == NV_I2C_DEFAULT(1)) {\r\nu8 version, *i2c = i2c_table(dev, &version);\r\nif (i2c && version >= 0x30) {\r\nif (index == NV_I2C_DEFAULT(0))\r\nindex = (i2c[4] & 0x0f);\r\nelse\r\nindex = (i2c[4] & 0xf0) >> 4;\r\n} else {\r\nindex = 2;\r\n}\r\n}\r\nlist_for_each_entry(port, &dev_priv->i2c_ports, head) {\r\nif (port->index == index)\r\nbreak;\r\n}\r\nif (&port->head == &dev_priv->i2c_ports)\r\nreturn NULL;\r\nif (dev_priv->card_type >= NV_50 && (port->dcb & 0x00000100)) {\r\nu32 reg = 0x00e500, val;\r\nif (port->type == 6) {\r\nreg += port->drive * 0x50;\r\nval = 0x2002;\r\n} else {\r\nreg += ((port->dcb & 0x1e00) >> 9) * 0x50;\r\nval = 0xe001;\r\n}\r\nnv_mask(dev, reg + 0x0c, 0x00000001, 0x00000000);\r\nnv_mask(dev, reg + 0x00, 0x0000f003, val);\r\n}\r\nreturn port;\r\n}\r\nbool\r\nnouveau_probe_i2c_addr(struct nouveau_i2c_chan *i2c, int addr)\r\n{\r\nuint8_t buf[] = { 0 };\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = buf,\r\n},\r\n{\r\n.addr = addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = buf,\r\n}\r\n};\r\nreturn i2c_transfer(&i2c->adapter, msgs, 2) == 2;\r\n}\r\nint\r\nnouveau_i2c_identify(struct drm_device *dev, const char *what,\r\nstruct i2c_board_info *info,\r\nbool (*match)(struct nouveau_i2c_chan *,\r\nstruct i2c_board_info *),\r\nint index)\r\n{\r\nstruct nouveau_i2c_chan *i2c = nouveau_i2c_find(dev, index);\r\nint i;\r\nif (!i2c) {\r\nNV_DEBUG(dev, "No bus when probing %s on %d\n", what, index);\r\nreturn -ENODEV;\r\n}\r\nNV_DEBUG(dev, "Probing %ss on I2C bus: %d\n", what, i2c->index);\r\nfor (i = 0; info[i].addr; i++) {\r\nif (nouveau_probe_i2c_addr(i2c, info[i].addr) &&\r\n(!match || match(i2c, &info[i]))) {\r\nNV_INFO(dev, "Detected %s: %s\n", what, info[i].type);\r\nreturn i;\r\n}\r\n}\r\nNV_DEBUG(dev, "No devices found.\n");\r\nreturn -ENODEV;\r\n}
