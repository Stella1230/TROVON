static inline int gpio_twl4030_write(u8 address, u8 data)\r\n{\r\nreturn twl_i2c_write_u8(TWL4030_MODULE_GPIO, data, address);\r\n}\r\nstatic inline int gpio_twl4030_read(u8 address)\r\n{\r\nu8 data;\r\nint ret = 0;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_GPIO, &data, address);\r\nreturn (ret < 0) ? ret : data;\r\n}\r\nstatic void twl4030_led_set_value(int led, int value)\r\n{\r\nu8 mask = LEDEN_LEDAON | LEDEN_LEDAPWM;\r\nint status;\r\nif (led)\r\nmask <<= 1;\r\nmutex_lock(&gpio_lock);\r\nif (value)\r\ncached_leden &= ~mask;\r\nelse\r\ncached_leden |= mask;\r\nstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, cached_leden,\r\nTWL4030_LED_LEDEN);\r\nmutex_unlock(&gpio_lock);\r\n}\r\nstatic int twl4030_set_gpio_direction(int gpio, int is_input)\r\n{\r\nu8 d_bnk = gpio >> 3;\r\nu8 d_msk = BIT(gpio & 0x7);\r\nu8 reg = 0;\r\nu8 base = REG_GPIODATADIR1 + d_bnk;\r\nint ret = 0;\r\nmutex_lock(&gpio_lock);\r\nret = gpio_twl4030_read(base);\r\nif (ret >= 0) {\r\nif (is_input)\r\nreg = ret & ~d_msk;\r\nelse\r\nreg = ret | d_msk;\r\nret = gpio_twl4030_write(base, reg);\r\n}\r\nmutex_unlock(&gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int twl4030_set_gpio_dataout(int gpio, int enable)\r\n{\r\nu8 d_bnk = gpio >> 3;\r\nu8 d_msk = BIT(gpio & 0x7);\r\nu8 base = 0;\r\nif (enable)\r\nbase = REG_SETGPIODATAOUT1 + d_bnk;\r\nelse\r\nbase = REG_CLEARGPIODATAOUT1 + d_bnk;\r\nreturn gpio_twl4030_write(base, d_msk);\r\n}\r\nstatic int twl4030_get_gpio_datain(int gpio)\r\n{\r\nu8 d_bnk = gpio >> 3;\r\nu8 d_off = gpio & 0x7;\r\nu8 base = 0;\r\nint ret = 0;\r\nif (unlikely((gpio >= TWL4030_GPIO_MAX)\r\n|| !(gpio_usage_count & BIT(gpio))))\r\nreturn -EPERM;\r\nbase = REG_GPIODATAIN1 + d_bnk;\r\nret = gpio_twl4030_read(base);\r\nif (ret > 0)\r\nret = (ret >> d_off) & 0x1;\r\nreturn ret;\r\n}\r\nstatic int twl_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint status = 0;\r\nmutex_lock(&gpio_lock);\r\nif (offset >= TWL4030_GPIO_MAX) {\r\nu8 ledclr_mask = LEDEN_LEDAON | LEDEN_LEDAEXT\r\n| LEDEN_LEDAPWM | LEDEN_PWM_LENGTHA;\r\nu8 module = TWL4030_MODULE_PWMA;\r\noffset -= TWL4030_GPIO_MAX;\r\nif (offset) {\r\nledclr_mask <<= 1;\r\nmodule = TWL4030_MODULE_PWMB;\r\n}\r\nstatus = twl_i2c_write_u8(module, 0x7f,\r\nTWL4030_PWMx_PWMxOFF);\r\nif (status < 0)\r\ngoto done;\r\nstatus = twl_i2c_write_u8(module, 0x7f,\r\nTWL4030_PWMx_PWMxON);\r\nif (status < 0)\r\ngoto done;\r\nmodule = TWL4030_MODULE_LED;\r\nstatus = twl_i2c_read_u8(module, &cached_leden,\r\nTWL4030_LED_LEDEN);\r\nif (status < 0)\r\ngoto done;\r\ncached_leden &= ~ledclr_mask;\r\nstatus = twl_i2c_write_u8(module, cached_leden,\r\nTWL4030_LED_LEDEN);\r\nif (status < 0)\r\ngoto done;\r\nstatus = 0;\r\ngoto done;\r\n}\r\nif (!gpio_usage_count) {\r\nstruct twl4030_gpio_platform_data *pdata;\r\nu8 value = MASK_GPIO_CTRL_GPIO_ON;\r\npdata = chip->dev->platform_data;\r\nif (pdata)\r\nvalue |= pdata->mmc_cd & 0x03;\r\nstatus = gpio_twl4030_write(REG_GPIO_CTRL, value);\r\n}\r\nif (!status)\r\ngpio_usage_count |= (0x1 << offset);\r\ndone:\r\nmutex_unlock(&gpio_lock);\r\nreturn status;\r\n}\r\nstatic void twl_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nif (offset >= TWL4030_GPIO_MAX) {\r\ntwl4030_led_set_value(offset - TWL4030_GPIO_MAX, 1);\r\nreturn;\r\n}\r\nmutex_lock(&gpio_lock);\r\ngpio_usage_count &= ~BIT(offset);\r\nif (!gpio_usage_count)\r\ngpio_twl4030_write(REG_GPIO_CTRL, 0x0);\r\nmutex_unlock(&gpio_lock);\r\n}\r\nstatic int twl_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn (offset < TWL4030_GPIO_MAX)\r\n? twl4030_set_gpio_direction(offset, 1)\r\n: -EINVAL;\r\n}\r\nstatic int twl_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint status = 0;\r\nif (offset < TWL4030_GPIO_MAX)\r\nstatus = twl4030_get_gpio_datain(offset);\r\nelse if (offset == TWL4030_GPIO_MAX)\r\nstatus = cached_leden & LEDEN_LEDAON;\r\nelse\r\nstatus = cached_leden & LEDEN_LEDBON;\r\nreturn (status < 0) ? 0 : status;\r\n}\r\nstatic int twl_direction_out(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nif (offset < TWL4030_GPIO_MAX) {\r\ntwl4030_set_gpio_dataout(offset, value);\r\nreturn twl4030_set_gpio_direction(offset, 0);\r\n} else {\r\ntwl4030_led_set_value(offset - TWL4030_GPIO_MAX, value);\r\nreturn 0;\r\n}\r\n}\r\nstatic void twl_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nif (offset < TWL4030_GPIO_MAX)\r\ntwl4030_set_gpio_dataout(offset, value);\r\nelse\r\ntwl4030_led_set_value(offset - TWL4030_GPIO_MAX, value);\r\n}\r\nstatic int twl_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn (twl4030_gpio_irq_base && (offset < TWL4030_GPIO_MAX))\r\n? (twl4030_gpio_irq_base + offset)\r\n: -EINVAL;\r\n}\r\nstatic int __devinit gpio_twl4030_pulls(u32 ups, u32 downs)\r\n{\r\nu8 message[6];\r\nunsigned i, gpio_bit;\r\nfor (gpio_bit = 1, i = 1; i < 6; i++) {\r\nu8 bit_mask;\r\nunsigned j;\r\nfor (bit_mask = 0, j = 0; j < 8; j += 2, gpio_bit <<= 1) {\r\nif (ups & gpio_bit)\r\nbit_mask |= 1 << (j + 1);\r\nelse if (downs & gpio_bit)\r\nbit_mask |= 1 << (j + 0);\r\n}\r\nmessage[i] = bit_mask;\r\n}\r\nreturn twl_i2c_write(TWL4030_MODULE_GPIO, message,\r\nREG_GPIOPUPDCTR1, 5);\r\n}\r\nstatic int __devinit gpio_twl4030_debounce(u32 debounce, u8 mmc_cd)\r\n{\r\nu8 message[4];\r\nmessage[1] = (debounce & 0xff) | (mmc_cd & 0x03);\r\ndebounce >>= 8;\r\nmessage[2] = (debounce & 0xff);\r\ndebounce >>= 8;\r\nmessage[3] = (debounce & 0x03);\r\nreturn twl_i2c_write(TWL4030_MODULE_GPIO, message,\r\nREG_GPIO_DEBEN1, 3);\r\n}\r\nstatic int __devinit gpio_twl4030_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nstruct device_node *node = pdev->dev.of_node;\r\nint ret, irq_base;\r\nif (is_module()) {\r\ndev_err(&pdev->dev, "can't dispatch IRQs from modules\n");\r\ngoto no_irqs;\r\n}\r\nirq_base = irq_alloc_descs(-1, 0, TWL4030_GPIO_MAX, 0);\r\nif (irq_base < 0) {\r\ndev_err(&pdev->dev, "Failed to alloc irq_descs\n");\r\nreturn irq_base;\r\n}\r\nirq_domain_add_legacy(node, TWL4030_GPIO_MAX, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nret = twl4030_sih_setup(&pdev->dev, TWL4030_MODULE_GPIO, irq_base);\r\nif (ret < 0)\r\nreturn ret;\r\ntwl4030_gpio_irq_base = irq_base;\r\nno_irqs:\r\ntwl_gpiochip.base = -1;\r\ntwl_gpiochip.ngpio = TWL4030_GPIO_MAX;\r\ntwl_gpiochip.dev = &pdev->dev;\r\nif (pdata) {\r\ntwl_gpiochip.base = pdata->gpio_base;\r\nret = gpio_twl4030_pulls(pdata->pullups, pdata->pulldowns);\r\nif (ret)\r\ndev_dbg(&pdev->dev, "pullups %.05x %.05x --> %d\n",\r\npdata->pullups, pdata->pulldowns,\r\nret);\r\nret = gpio_twl4030_debounce(pdata->debounce, pdata->mmc_cd);\r\nif (ret)\r\ndev_dbg(&pdev->dev, "debounce %.03x %.01x --> %d\n",\r\npdata->debounce, pdata->mmc_cd,\r\nret);\r\nif (pdata->use_leds)\r\ntwl_gpiochip.ngpio += 2;\r\n}\r\nret = gpiochip_add(&twl_gpiochip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not register gpiochip, %d\n", ret);\r\ntwl_gpiochip.ngpio = 0;\r\ngpio_twl4030_remove(pdev);\r\n} else if (pdata && pdata->setup) {\r\nint status;\r\nstatus = pdata->setup(&pdev->dev,\r\npdata->gpio_base, TWL4030_GPIO_MAX);\r\nif (status)\r\ndev_dbg(&pdev->dev, "setup --> %d\n", status);\r\n}\r\nreturn ret;\r\n}\r\nstatic int gpio_twl4030_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_gpio_platform_data *pdata = pdev->dev.platform_data;\r\nint status;\r\nif (pdata && pdata->teardown) {\r\nstatus = pdata->teardown(&pdev->dev,\r\npdata->gpio_base, TWL4030_GPIO_MAX);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "teardown --> %d\n", status);\r\nreturn status;\r\n}\r\n}\r\nstatus = gpiochip_remove(&twl_gpiochip);\r\nif (status < 0)\r\nreturn status;\r\nif (is_module())\r\nreturn 0;\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nstatic int __init gpio_twl4030_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_twl4030_driver);\r\n}\r\nstatic void __exit gpio_twl4030_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_twl4030_driver);\r\n}
