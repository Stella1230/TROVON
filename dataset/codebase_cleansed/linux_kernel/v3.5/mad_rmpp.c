static inline void deref_rmpp_recv(struct mad_rmpp_recv *rmpp_recv)\r\n{\r\nif (atomic_dec_and_test(&rmpp_recv->refcount))\r\ncomplete(&rmpp_recv->comp);\r\n}\r\nstatic void destroy_rmpp_recv(struct mad_rmpp_recv *rmpp_recv)\r\n{\r\nderef_rmpp_recv(rmpp_recv);\r\nwait_for_completion(&rmpp_recv->comp);\r\nib_destroy_ah(rmpp_recv->ah);\r\nkfree(rmpp_recv);\r\n}\r\nvoid ib_cancel_rmpp_recvs(struct ib_mad_agent_private *agent)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv, *temp_rmpp_recv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&agent->lock, flags);\r\nlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\r\nif (rmpp_recv->state != RMPP_STATE_COMPLETE)\r\nib_free_recv_mad(rmpp_recv->rmpp_wc);\r\nrmpp_recv->state = RMPP_STATE_CANCELING;\r\n}\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\r\ncancel_delayed_work(&rmpp_recv->timeout_work);\r\ncancel_delayed_work(&rmpp_recv->cleanup_work);\r\n}\r\nflush_workqueue(agent->qp_info->port_priv->wq);\r\nlist_for_each_entry_safe(rmpp_recv, temp_rmpp_recv,\r\n&agent->rmpp_list, list) {\r\nlist_del(&rmpp_recv->list);\r\ndestroy_rmpp_recv(rmpp_recv);\r\n}\r\n}\r\nstatic void format_ack(struct ib_mad_send_buf *msg,\r\nstruct ib_rmpp_mad *data,\r\nstruct mad_rmpp_recv *rmpp_recv)\r\n{\r\nstruct ib_rmpp_mad *ack = msg->mad;\r\nunsigned long flags;\r\nmemcpy(ack, &data->mad_hdr, msg->hdr_len);\r\nack->mad_hdr.method ^= IB_MGMT_METHOD_RESP;\r\nack->rmpp_hdr.rmpp_type = IB_MGMT_RMPP_TYPE_ACK;\r\nib_set_rmpp_flags(&ack->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\r\nspin_lock_irqsave(&rmpp_recv->lock, flags);\r\nrmpp_recv->last_ack = rmpp_recv->seg_num;\r\nack->rmpp_hdr.seg_num = cpu_to_be32(rmpp_recv->seg_num);\r\nack->rmpp_hdr.paylen_newwin = cpu_to_be32(rmpp_recv->newwin);\r\nspin_unlock_irqrestore(&rmpp_recv->lock, flags);\r\n}\r\nstatic void ack_recv(struct mad_rmpp_recv *rmpp_recv,\r\nstruct ib_mad_recv_wc *recv_wc)\r\n{\r\nstruct ib_mad_send_buf *msg;\r\nint ret, hdr_len;\r\nhdr_len = ib_get_mad_data_offset(recv_wc->recv_buf.mad->mad_hdr.mgmt_class);\r\nmsg = ib_create_send_mad(&rmpp_recv->agent->agent, recv_wc->wc->src_qp,\r\nrecv_wc->wc->pkey_index, 1, hdr_len,\r\n0, GFP_KERNEL);\r\nif (IS_ERR(msg))\r\nreturn;\r\nformat_ack(msg, (struct ib_rmpp_mad *) recv_wc->recv_buf.mad, rmpp_recv);\r\nmsg->ah = rmpp_recv->ah;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret)\r\nib_free_send_mad(msg);\r\n}\r\nstatic struct ib_mad_send_buf *alloc_response_msg(struct ib_mad_agent *agent,\r\nstruct ib_mad_recv_wc *recv_wc)\r\n{\r\nstruct ib_mad_send_buf *msg;\r\nstruct ib_ah *ah;\r\nint hdr_len;\r\nah = ib_create_ah_from_wc(agent->qp->pd, recv_wc->wc,\r\nrecv_wc->recv_buf.grh, agent->port_num);\r\nif (IS_ERR(ah))\r\nreturn (void *) ah;\r\nhdr_len = ib_get_mad_data_offset(recv_wc->recv_buf.mad->mad_hdr.mgmt_class);\r\nmsg = ib_create_send_mad(agent, recv_wc->wc->src_qp,\r\nrecv_wc->wc->pkey_index, 1,\r\nhdr_len, 0, GFP_KERNEL);\r\nif (IS_ERR(msg))\r\nib_destroy_ah(ah);\r\nelse {\r\nmsg->ah = ah;\r\nmsg->context[0] = ah;\r\n}\r\nreturn msg;\r\n}\r\nstatic void ack_ds_ack(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *recv_wc)\r\n{\r\nstruct ib_mad_send_buf *msg;\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint ret;\r\nmsg = alloc_response_msg(&agent->agent, recv_wc);\r\nif (IS_ERR(msg))\r\nreturn;\r\nrmpp_mad = msg->mad;\r\nmemcpy(rmpp_mad, recv_wc->recv_buf.mad, msg->hdr_len);\r\nrmpp_mad->mad_hdr.method ^= IB_MGMT_METHOD_RESP;\r\nib_set_rmpp_flags(&rmpp_mad->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\r\nrmpp_mad->rmpp_hdr.seg_num = 0;\r\nrmpp_mad->rmpp_hdr.paylen_newwin = cpu_to_be32(1);\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nib_destroy_ah(msg->ah);\r\nib_free_send_mad(msg);\r\n}\r\n}\r\nvoid ib_rmpp_send_handler(struct ib_mad_send_wc *mad_send_wc)\r\n{\r\nif (mad_send_wc->send_buf->context[0] == mad_send_wc->send_buf->ah)\r\nib_destroy_ah(mad_send_wc->send_buf->ah);\r\nib_free_send_mad(mad_send_wc->send_buf);\r\n}\r\nstatic void nack_recv(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *recv_wc, u8 rmpp_status)\r\n{\r\nstruct ib_mad_send_buf *msg;\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint ret;\r\nmsg = alloc_response_msg(&agent->agent, recv_wc);\r\nif (IS_ERR(msg))\r\nreturn;\r\nrmpp_mad = msg->mad;\r\nmemcpy(rmpp_mad, recv_wc->recv_buf.mad, msg->hdr_len);\r\nrmpp_mad->mad_hdr.method ^= IB_MGMT_METHOD_RESP;\r\nrmpp_mad->rmpp_hdr.rmpp_version = IB_MGMT_RMPP_VERSION;\r\nrmpp_mad->rmpp_hdr.rmpp_type = IB_MGMT_RMPP_TYPE_ABORT;\r\nib_set_rmpp_flags(&rmpp_mad->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\r\nrmpp_mad->rmpp_hdr.rmpp_status = rmpp_status;\r\nrmpp_mad->rmpp_hdr.seg_num = 0;\r\nrmpp_mad->rmpp_hdr.paylen_newwin = 0;\r\nret = ib_post_send_mad(msg, NULL);\r\nif (ret) {\r\nib_destroy_ah(msg->ah);\r\nib_free_send_mad(msg);\r\n}\r\n}\r\nstatic void recv_timeout_handler(struct work_struct *work)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv =\r\ncontainer_of(work, struct mad_rmpp_recv, timeout_work.work);\r\nstruct ib_mad_recv_wc *rmpp_wc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rmpp_recv->agent->lock, flags);\r\nif (rmpp_recv->state != RMPP_STATE_ACTIVE) {\r\nspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\r\nreturn;\r\n}\r\nrmpp_recv->state = RMPP_STATE_TIMEOUT;\r\nlist_del(&rmpp_recv->list);\r\nspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\r\nrmpp_wc = rmpp_recv->rmpp_wc;\r\nnack_recv(rmpp_recv->agent, rmpp_wc, IB_MGMT_RMPP_STATUS_T2L);\r\ndestroy_rmpp_recv(rmpp_recv);\r\nib_free_recv_mad(rmpp_wc);\r\n}\r\nstatic void recv_cleanup_handler(struct work_struct *work)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv =\r\ncontainer_of(work, struct mad_rmpp_recv, cleanup_work.work);\r\nunsigned long flags;\r\nspin_lock_irqsave(&rmpp_recv->agent->lock, flags);\r\nif (rmpp_recv->state == RMPP_STATE_CANCELING) {\r\nspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\r\nreturn;\r\n}\r\nlist_del(&rmpp_recv->list);\r\nspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\r\ndestroy_rmpp_recv(rmpp_recv);\r\n}\r\nstatic struct mad_rmpp_recv *\r\ncreate_rmpp_recv(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nstruct ib_mad_hdr *mad_hdr;\r\nrmpp_recv = kmalloc(sizeof *rmpp_recv, GFP_KERNEL);\r\nif (!rmpp_recv)\r\nreturn NULL;\r\nrmpp_recv->ah = ib_create_ah_from_wc(agent->agent.qp->pd,\r\nmad_recv_wc->wc,\r\nmad_recv_wc->recv_buf.grh,\r\nagent->agent.port_num);\r\nif (IS_ERR(rmpp_recv->ah))\r\ngoto error;\r\nrmpp_recv->agent = agent;\r\ninit_completion(&rmpp_recv->comp);\r\nINIT_DELAYED_WORK(&rmpp_recv->timeout_work, recv_timeout_handler);\r\nINIT_DELAYED_WORK(&rmpp_recv->cleanup_work, recv_cleanup_handler);\r\nspin_lock_init(&rmpp_recv->lock);\r\nrmpp_recv->state = RMPP_STATE_ACTIVE;\r\natomic_set(&rmpp_recv->refcount, 1);\r\nrmpp_recv->rmpp_wc = mad_recv_wc;\r\nrmpp_recv->cur_seg_buf = &mad_recv_wc->recv_buf;\r\nrmpp_recv->newwin = 1;\r\nrmpp_recv->seg_num = 1;\r\nrmpp_recv->last_ack = 0;\r\nrmpp_recv->repwin = 1;\r\nmad_hdr = &mad_recv_wc->recv_buf.mad->mad_hdr;\r\nrmpp_recv->tid = mad_hdr->tid;\r\nrmpp_recv->src_qp = mad_recv_wc->wc->src_qp;\r\nrmpp_recv->slid = mad_recv_wc->wc->slid;\r\nrmpp_recv->mgmt_class = mad_hdr->mgmt_class;\r\nrmpp_recv->class_version = mad_hdr->class_version;\r\nrmpp_recv->method = mad_hdr->method;\r\nreturn rmpp_recv;\r\nerror: kfree(rmpp_recv);\r\nreturn NULL;\r\n}\r\nstatic struct mad_rmpp_recv *\r\nfind_rmpp_recv(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nstruct ib_mad_hdr *mad_hdr = &mad_recv_wc->recv_buf.mad->mad_hdr;\r\nlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\r\nif (rmpp_recv->tid == mad_hdr->tid &&\r\nrmpp_recv->src_qp == mad_recv_wc->wc->src_qp &&\r\nrmpp_recv->slid == mad_recv_wc->wc->slid &&\r\nrmpp_recv->mgmt_class == mad_hdr->mgmt_class &&\r\nrmpp_recv->class_version == mad_hdr->class_version &&\r\nrmpp_recv->method == mad_hdr->method)\r\nreturn rmpp_recv;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mad_rmpp_recv *\r\nacquire_rmpp_recv(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&agent->lock, flags);\r\nrmpp_recv = find_rmpp_recv(agent, mad_recv_wc);\r\nif (rmpp_recv)\r\natomic_inc(&rmpp_recv->refcount);\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nreturn rmpp_recv;\r\n}\r\nstatic struct mad_rmpp_recv *\r\ninsert_rmpp_recv(struct ib_mad_agent_private *agent,\r\nstruct mad_rmpp_recv *rmpp_recv)\r\n{\r\nstruct mad_rmpp_recv *cur_rmpp_recv;\r\ncur_rmpp_recv = find_rmpp_recv(agent, rmpp_recv->rmpp_wc);\r\nif (!cur_rmpp_recv)\r\nlist_add_tail(&rmpp_recv->list, &agent->rmpp_list);\r\nreturn cur_rmpp_recv;\r\n}\r\nstatic inline int get_last_flag(struct ib_mad_recv_buf *seg)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nrmpp_mad = (struct ib_rmpp_mad *) seg->mad;\r\nreturn ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) & IB_MGMT_RMPP_FLAG_LAST;\r\n}\r\nstatic inline int get_seg_num(struct ib_mad_recv_buf *seg)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nrmpp_mad = (struct ib_rmpp_mad *) seg->mad;\r\nreturn be32_to_cpu(rmpp_mad->rmpp_hdr.seg_num);\r\n}\r\nstatic inline struct ib_mad_recv_buf * get_next_seg(struct list_head *rmpp_list,\r\nstruct ib_mad_recv_buf *seg)\r\n{\r\nif (seg->list.next == rmpp_list)\r\nreturn NULL;\r\nreturn container_of(seg->list.next, struct ib_mad_recv_buf, list);\r\n}\r\nstatic inline int window_size(struct ib_mad_agent_private *agent)\r\n{\r\nreturn max(agent->qp_info->recv_queue.max_active >> 3, 1);\r\n}\r\nstatic struct ib_mad_recv_buf * find_seg_location(struct list_head *rmpp_list,\r\nint seg_num)\r\n{\r\nstruct ib_mad_recv_buf *seg_buf;\r\nint cur_seg_num;\r\nlist_for_each_entry_reverse(seg_buf, rmpp_list, list) {\r\ncur_seg_num = get_seg_num(seg_buf);\r\nif (seg_num > cur_seg_num)\r\nreturn seg_buf;\r\nif (seg_num == cur_seg_num)\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void update_seg_num(struct mad_rmpp_recv *rmpp_recv,\r\nstruct ib_mad_recv_buf *new_buf)\r\n{\r\nstruct list_head *rmpp_list = &rmpp_recv->rmpp_wc->rmpp_list;\r\nwhile (new_buf && (get_seg_num(new_buf) == rmpp_recv->seg_num + 1)) {\r\nrmpp_recv->cur_seg_buf = new_buf;\r\nrmpp_recv->seg_num++;\r\nnew_buf = get_next_seg(rmpp_list, new_buf);\r\n}\r\n}\r\nstatic inline int get_mad_len(struct mad_rmpp_recv *rmpp_recv)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint hdr_size, data_size, pad;\r\nrmpp_mad = (struct ib_rmpp_mad *)rmpp_recv->cur_seg_buf->mad;\r\nhdr_size = ib_get_mad_data_offset(rmpp_mad->mad_hdr.mgmt_class);\r\ndata_size = sizeof(struct ib_rmpp_mad) - hdr_size;\r\npad = IB_MGMT_RMPP_DATA - be32_to_cpu(rmpp_mad->rmpp_hdr.paylen_newwin);\r\nif (pad > IB_MGMT_RMPP_DATA || pad < 0)\r\npad = 0;\r\nreturn hdr_size + rmpp_recv->seg_num * data_size - pad;\r\n}\r\nstatic struct ib_mad_recv_wc * complete_rmpp(struct mad_rmpp_recv *rmpp_recv)\r\n{\r\nstruct ib_mad_recv_wc *rmpp_wc;\r\nack_recv(rmpp_recv, rmpp_recv->rmpp_wc);\r\nif (rmpp_recv->seg_num > 1)\r\ncancel_delayed_work(&rmpp_recv->timeout_work);\r\nrmpp_wc = rmpp_recv->rmpp_wc;\r\nrmpp_wc->mad_len = get_mad_len(rmpp_recv);\r\nqueue_delayed_work(rmpp_recv->agent->qp_info->port_priv->wq,\r\n&rmpp_recv->cleanup_work, msecs_to_jiffies(10000));\r\nreturn rmpp_wc;\r\n}\r\nstatic struct ib_mad_recv_wc *\r\ncontinue_rmpp(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nstruct ib_mad_recv_buf *prev_buf;\r\nstruct ib_mad_recv_wc *done_wc;\r\nint seg_num;\r\nunsigned long flags;\r\nrmpp_recv = acquire_rmpp_recv(agent, mad_recv_wc);\r\nif (!rmpp_recv)\r\ngoto drop1;\r\nseg_num = get_seg_num(&mad_recv_wc->recv_buf);\r\nspin_lock_irqsave(&rmpp_recv->lock, flags);\r\nif ((rmpp_recv->state == RMPP_STATE_TIMEOUT) ||\r\n(seg_num > rmpp_recv->newwin))\r\ngoto drop3;\r\nif ((seg_num <= rmpp_recv->last_ack) ||\r\n(rmpp_recv->state == RMPP_STATE_COMPLETE)) {\r\nspin_unlock_irqrestore(&rmpp_recv->lock, flags);\r\nack_recv(rmpp_recv, mad_recv_wc);\r\ngoto drop2;\r\n}\r\nprev_buf = find_seg_location(&rmpp_recv->rmpp_wc->rmpp_list, seg_num);\r\nif (!prev_buf)\r\ngoto drop3;\r\ndone_wc = NULL;\r\nlist_add(&mad_recv_wc->recv_buf.list, &prev_buf->list);\r\nif (rmpp_recv->cur_seg_buf == prev_buf) {\r\nupdate_seg_num(rmpp_recv, &mad_recv_wc->recv_buf);\r\nif (get_last_flag(rmpp_recv->cur_seg_buf)) {\r\nrmpp_recv->state = RMPP_STATE_COMPLETE;\r\nspin_unlock_irqrestore(&rmpp_recv->lock, flags);\r\ndone_wc = complete_rmpp(rmpp_recv);\r\ngoto out;\r\n} else if (rmpp_recv->seg_num == rmpp_recv->newwin) {\r\nrmpp_recv->newwin += window_size(agent);\r\nspin_unlock_irqrestore(&rmpp_recv->lock, flags);\r\nack_recv(rmpp_recv, mad_recv_wc);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock_irqrestore(&rmpp_recv->lock, flags);\r\nout:\r\nderef_rmpp_recv(rmpp_recv);\r\nreturn done_wc;\r\ndrop3: spin_unlock_irqrestore(&rmpp_recv->lock, flags);\r\ndrop2: deref_rmpp_recv(rmpp_recv);\r\ndrop1: ib_free_recv_mad(mad_recv_wc);\r\nreturn NULL;\r\n}\r\nstatic struct ib_mad_recv_wc *\r\nstart_rmpp(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nunsigned long flags;\r\nrmpp_recv = create_rmpp_recv(agent, mad_recv_wc);\r\nif (!rmpp_recv) {\r\nib_free_recv_mad(mad_recv_wc);\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&agent->lock, flags);\r\nif (insert_rmpp_recv(agent, rmpp_recv)) {\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\ndestroy_rmpp_recv(rmpp_recv);\r\nreturn continue_rmpp(agent, mad_recv_wc);\r\n}\r\natomic_inc(&rmpp_recv->refcount);\r\nif (get_last_flag(&mad_recv_wc->recv_buf)) {\r\nrmpp_recv->state = RMPP_STATE_COMPLETE;\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\ncomplete_rmpp(rmpp_recv);\r\n} else {\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nqueue_delayed_work(agent->qp_info->port_priv->wq,\r\n&rmpp_recv->timeout_work,\r\nmsecs_to_jiffies(40000));\r\nrmpp_recv->newwin += window_size(agent);\r\nack_recv(rmpp_recv, mad_recv_wc);\r\nmad_recv_wc = NULL;\r\n}\r\nderef_rmpp_recv(rmpp_recv);\r\nreturn mad_recv_wc;\r\n}\r\nstatic int send_next_seg(struct ib_mad_send_wr_private *mad_send_wr)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint timeout;\r\nu32 paylen = 0;\r\nrmpp_mad = mad_send_wr->send_buf.mad;\r\nib_set_rmpp_flags(&rmpp_mad->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\r\nrmpp_mad->rmpp_hdr.seg_num = cpu_to_be32(++mad_send_wr->seg_num);\r\nif (mad_send_wr->seg_num == 1) {\r\nrmpp_mad->rmpp_hdr.rmpp_rtime_flags |= IB_MGMT_RMPP_FLAG_FIRST;\r\npaylen = mad_send_wr->send_buf.seg_count * IB_MGMT_RMPP_DATA -\r\nmad_send_wr->pad;\r\n}\r\nif (mad_send_wr->seg_num == mad_send_wr->send_buf.seg_count) {\r\nrmpp_mad->rmpp_hdr.rmpp_rtime_flags |= IB_MGMT_RMPP_FLAG_LAST;\r\npaylen = IB_MGMT_RMPP_DATA - mad_send_wr->pad;\r\n}\r\nrmpp_mad->rmpp_hdr.paylen_newwin = cpu_to_be32(paylen);\r\ntimeout = mad_send_wr->send_buf.timeout_ms;\r\nif (!timeout || timeout > 2000)\r\nmad_send_wr->timeout = msecs_to_jiffies(2000);\r\nreturn ib_send_mad(mad_send_wr);\r\n}\r\nstatic void abort_send(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc, u8 rmpp_status)\r\n{\r\nstruct ib_mad_send_wr_private *mad_send_wr;\r\nstruct ib_mad_send_wc wc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&agent->lock, flags);\r\nmad_send_wr = ib_find_send_mad(agent, mad_recv_wc);\r\nif (!mad_send_wr)\r\ngoto out;\r\nif ((mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) ||\r\n(!mad_send_wr->timeout) || (mad_send_wr->status != IB_WC_SUCCESS))\r\ngoto out;\r\nib_mark_mad_done(mad_send_wr);\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nwc.status = IB_WC_REM_ABORT_ERR;\r\nwc.vendor_err = rmpp_status;\r\nwc.send_buf = &mad_send_wr->send_buf;\r\nib_mad_complete_send_wr(mad_send_wr, &wc);\r\nreturn;\r\nout:\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\n}\r\nstatic inline void adjust_last_ack(struct ib_mad_send_wr_private *wr,\r\nint seg_num)\r\n{\r\nstruct list_head *list;\r\nwr->last_ack = seg_num;\r\nlist = &wr->last_ack_seg->list;\r\nlist_for_each_entry(wr->last_ack_seg, list, list)\r\nif (wr->last_ack_seg->num == seg_num)\r\nbreak;\r\n}\r\nstatic void process_ds_ack(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc, int newwin)\r\n{\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nrmpp_recv = find_rmpp_recv(agent, mad_recv_wc);\r\nif (rmpp_recv && rmpp_recv->state == RMPP_STATE_COMPLETE)\r\nrmpp_recv->repwin = newwin;\r\n}\r\nstatic void process_rmpp_ack(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct ib_mad_send_wr_private *mad_send_wr;\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nunsigned long flags;\r\nint seg_num, newwin, ret;\r\nrmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\r\nif (rmpp_mad->rmpp_hdr.rmpp_status) {\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\r\nreturn;\r\n}\r\nseg_num = be32_to_cpu(rmpp_mad->rmpp_hdr.seg_num);\r\nnewwin = be32_to_cpu(rmpp_mad->rmpp_hdr.paylen_newwin);\r\nif (newwin < seg_num) {\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_W2S);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_W2S);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&agent->lock, flags);\r\nmad_send_wr = ib_find_send_mad(agent, mad_recv_wc);\r\nif (!mad_send_wr) {\r\nif (!seg_num)\r\nprocess_ds_ack(agent, mad_recv_wc, newwin);\r\ngoto out;\r\n}\r\nif ((mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) &&\r\n(mad_send_wr->timeout)) {\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nack_ds_ack(agent, mad_recv_wc);\r\nreturn;\r\n}\r\nif ((mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) ||\r\n(!mad_send_wr->timeout) || (mad_send_wr->status != IB_WC_SUCCESS))\r\ngoto out;\r\nif (seg_num > mad_send_wr->send_buf.seg_count ||\r\nseg_num > mad_send_wr->newwin) {\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_S2B);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_S2B);\r\nreturn;\r\n}\r\nif (newwin < mad_send_wr->newwin || seg_num < mad_send_wr->last_ack)\r\ngoto out;\r\nif (seg_num > mad_send_wr->last_ack) {\r\nadjust_last_ack(mad_send_wr, seg_num);\r\nmad_send_wr->retries_left = mad_send_wr->max_retries;\r\n}\r\nmad_send_wr->newwin = newwin;\r\nif (mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) {\r\nif (!mad_send_wr->send_buf.timeout_ms) {\r\nstruct ib_mad_send_wc wc;\r\nib_mark_mad_done(mad_send_wr);\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nwc.status = IB_WC_SUCCESS;\r\nwc.vendor_err = 0;\r\nwc.send_buf = &mad_send_wr->send_buf;\r\nib_mad_complete_send_wr(mad_send_wr, &wc);\r\nreturn;\r\n}\r\nif (mad_send_wr->refcount == 1)\r\nib_reset_mad_timeout(mad_send_wr,\r\nmad_send_wr->send_buf.timeout_ms);\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nack_ds_ack(agent, mad_recv_wc);\r\nreturn;\r\n} else if (mad_send_wr->refcount == 1 &&\r\nmad_send_wr->seg_num < mad_send_wr->newwin &&\r\nmad_send_wr->seg_num < mad_send_wr->send_buf.seg_count) {\r\nret = send_next_seg(mad_send_wr);\r\nif (ret)\r\ngoto out;\r\nmad_send_wr->refcount++;\r\nlist_move_tail(&mad_send_wr->agent_list,\r\n&mad_send_wr->mad_agent_priv->send_list);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\n}\r\nstatic struct ib_mad_recv_wc *\r\nprocess_rmpp_data(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct ib_rmpp_hdr *rmpp_hdr;\r\nu8 rmpp_status;\r\nrmpp_hdr = &((struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad)->rmpp_hdr;\r\nif (rmpp_hdr->rmpp_status) {\r\nrmpp_status = IB_MGMT_RMPP_STATUS_BAD_STATUS;\r\ngoto bad;\r\n}\r\nif (rmpp_hdr->seg_num == cpu_to_be32(1)) {\r\nif (!(ib_get_rmpp_flags(rmpp_hdr) & IB_MGMT_RMPP_FLAG_FIRST)) {\r\nrmpp_status = IB_MGMT_RMPP_STATUS_BAD_SEG;\r\ngoto bad;\r\n}\r\nreturn start_rmpp(agent, mad_recv_wc);\r\n} else {\r\nif (ib_get_rmpp_flags(rmpp_hdr) & IB_MGMT_RMPP_FLAG_FIRST) {\r\nrmpp_status = IB_MGMT_RMPP_STATUS_BAD_SEG;\r\ngoto bad;\r\n}\r\nreturn continue_rmpp(agent, mad_recv_wc);\r\n}\r\nbad:\r\nnack_recv(agent, mad_recv_wc, rmpp_status);\r\nib_free_recv_mad(mad_recv_wc);\r\nreturn NULL;\r\n}\r\nstatic void process_rmpp_stop(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nrmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\r\nif (rmpp_mad->rmpp_hdr.rmpp_status != IB_MGMT_RMPP_STATUS_RESX) {\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\r\n} else\r\nabort_send(agent, mad_recv_wc, rmpp_mad->rmpp_hdr.rmpp_status);\r\n}\r\nstatic void process_rmpp_abort(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nrmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\r\nif (rmpp_mad->rmpp_hdr.rmpp_status < IB_MGMT_RMPP_STATUS_ABORT_MIN ||\r\nrmpp_mad->rmpp_hdr.rmpp_status > IB_MGMT_RMPP_STATUS_ABORT_MAX) {\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\r\n} else\r\nabort_send(agent, mad_recv_wc, rmpp_mad->rmpp_hdr.rmpp_status);\r\n}\r\nstruct ib_mad_recv_wc *\r\nib_process_rmpp_recv_wc(struct ib_mad_agent_private *agent,\r\nstruct ib_mad_recv_wc *mad_recv_wc)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nrmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\r\nif (!(rmpp_mad->rmpp_hdr.rmpp_rtime_flags & IB_MGMT_RMPP_FLAG_ACTIVE))\r\nreturn mad_recv_wc;\r\nif (rmpp_mad->rmpp_hdr.rmpp_version != IB_MGMT_RMPP_VERSION) {\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_UNV);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_UNV);\r\ngoto out;\r\n}\r\nswitch (rmpp_mad->rmpp_hdr.rmpp_type) {\r\ncase IB_MGMT_RMPP_TYPE_DATA:\r\nreturn process_rmpp_data(agent, mad_recv_wc);\r\ncase IB_MGMT_RMPP_TYPE_ACK:\r\nprocess_rmpp_ack(agent, mad_recv_wc);\r\nbreak;\r\ncase IB_MGMT_RMPP_TYPE_STOP:\r\nprocess_rmpp_stop(agent, mad_recv_wc);\r\nbreak;\r\ncase IB_MGMT_RMPP_TYPE_ABORT:\r\nprocess_rmpp_abort(agent, mad_recv_wc);\r\nbreak;\r\ndefault:\r\nabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BADT);\r\nnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BADT);\r\nbreak;\r\n}\r\nout:\r\nib_free_recv_mad(mad_recv_wc);\r\nreturn NULL;\r\n}\r\nstatic int init_newwin(struct ib_mad_send_wr_private *mad_send_wr)\r\n{\r\nstruct ib_mad_agent_private *agent = mad_send_wr->mad_agent_priv;\r\nstruct ib_mad_hdr *mad_hdr = mad_send_wr->send_buf.mad;\r\nstruct mad_rmpp_recv *rmpp_recv;\r\nstruct ib_ah_attr ah_attr;\r\nunsigned long flags;\r\nint newwin = 1;\r\nif (!(mad_hdr->method & IB_MGMT_METHOD_RESP))\r\ngoto out;\r\nspin_lock_irqsave(&agent->lock, flags);\r\nlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\r\nif (rmpp_recv->tid != mad_hdr->tid ||\r\nrmpp_recv->mgmt_class != mad_hdr->mgmt_class ||\r\nrmpp_recv->class_version != mad_hdr->class_version ||\r\n(rmpp_recv->method & IB_MGMT_METHOD_RESP))\r\ncontinue;\r\nif (ib_query_ah(mad_send_wr->send_buf.ah, &ah_attr))\r\ncontinue;\r\nif (rmpp_recv->slid == ah_attr.dlid) {\r\nnewwin = rmpp_recv->repwin;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&agent->lock, flags);\r\nout:\r\nreturn newwin;\r\n}\r\nint ib_send_rmpp_mad(struct ib_mad_send_wr_private *mad_send_wr)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint ret;\r\nrmpp_mad = mad_send_wr->send_buf.mad;\r\nif (!(ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) &\r\nIB_MGMT_RMPP_FLAG_ACTIVE))\r\nreturn IB_RMPP_RESULT_UNHANDLED;\r\nif (rmpp_mad->rmpp_hdr.rmpp_type != IB_MGMT_RMPP_TYPE_DATA) {\r\nmad_send_wr->seg_num = 1;\r\nreturn IB_RMPP_RESULT_INTERNAL;\r\n}\r\nmad_send_wr->newwin = init_newwin(mad_send_wr);\r\nmad_send_wr->refcount += (mad_send_wr->timeout == 0);\r\nret = send_next_seg(mad_send_wr);\r\nif (!ret)\r\nreturn IB_RMPP_RESULT_CONSUMED;\r\nreturn ret;\r\n}\r\nint ib_process_rmpp_send_wc(struct ib_mad_send_wr_private *mad_send_wr,\r\nstruct ib_mad_send_wc *mad_send_wc)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint ret;\r\nrmpp_mad = mad_send_wr->send_buf.mad;\r\nif (!(ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) &\r\nIB_MGMT_RMPP_FLAG_ACTIVE))\r\nreturn IB_RMPP_RESULT_UNHANDLED;\r\nif (rmpp_mad->rmpp_hdr.rmpp_type != IB_MGMT_RMPP_TYPE_DATA)\r\nreturn IB_RMPP_RESULT_INTERNAL;\r\nif (mad_send_wc->status != IB_WC_SUCCESS ||\r\nmad_send_wr->status != IB_WC_SUCCESS)\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\nif (!mad_send_wr->timeout)\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\nif (mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) {\r\nmad_send_wr->timeout =\r\nmsecs_to_jiffies(mad_send_wr->send_buf.timeout_ms);\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\n}\r\nif (mad_send_wr->seg_num == mad_send_wr->newwin ||\r\nmad_send_wr->seg_num == mad_send_wr->send_buf.seg_count)\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\nret = send_next_seg(mad_send_wr);\r\nif (ret) {\r\nmad_send_wc->status = IB_WC_GENERAL_ERR;\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\n}\r\nreturn IB_RMPP_RESULT_CONSUMED;\r\n}\r\nint ib_retry_rmpp(struct ib_mad_send_wr_private *mad_send_wr)\r\n{\r\nstruct ib_rmpp_mad *rmpp_mad;\r\nint ret;\r\nrmpp_mad = mad_send_wr->send_buf.mad;\r\nif (!(ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) &\r\nIB_MGMT_RMPP_FLAG_ACTIVE))\r\nreturn IB_RMPP_RESULT_UNHANDLED;\r\nif (mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count)\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\nmad_send_wr->seg_num = mad_send_wr->last_ack;\r\nmad_send_wr->cur_seg = mad_send_wr->last_ack_seg;\r\nret = send_next_seg(mad_send_wr);\r\nif (ret)\r\nreturn IB_RMPP_RESULT_PROCESSED;\r\nreturn IB_RMPP_RESULT_CONSUMED;\r\n}
