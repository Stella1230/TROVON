static void free_list(struct list_head *head)\r\n{\r\nstruct pci_dev_resource *dev_res, *tmp;\r\nlist_for_each_entry_safe(dev_res, tmp, head, list) {\r\nlist_del(&dev_res->list);\r\nkfree(dev_res);\r\n}\r\n}\r\nstatic int add_to_list(struct list_head *head,\r\nstruct pci_dev *dev, struct resource *res,\r\nresource_size_t add_size, resource_size_t min_align)\r\n{\r\nstruct pci_dev_resource *tmp;\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp) {\r\npr_warning("add_to_list: kmalloc() failed!\n");\r\nreturn -ENOMEM;\r\n}\r\ntmp->res = res;\r\ntmp->dev = dev;\r\ntmp->start = res->start;\r\ntmp->end = res->end;\r\ntmp->flags = res->flags;\r\ntmp->add_size = add_size;\r\ntmp->min_align = min_align;\r\nlist_add(&tmp->list, head);\r\nreturn 0;\r\n}\r\nstatic void remove_from_list(struct list_head *head,\r\nstruct resource *res)\r\n{\r\nstruct pci_dev_resource *dev_res, *tmp;\r\nlist_for_each_entry_safe(dev_res, tmp, head, list) {\r\nif (dev_res->res == res) {\r\nlist_del(&dev_res->list);\r\nkfree(dev_res);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic resource_size_t get_res_add_size(struct list_head *head,\r\nstruct resource *res)\r\n{\r\nstruct pci_dev_resource *dev_res;\r\nlist_for_each_entry(dev_res, head, list) {\r\nif (dev_res->res == res) {\r\nint idx = res - &dev_res->dev->resource[0];\r\ndev_printk(KERN_DEBUG, &dev_res->dev->dev,\r\n"res[%d]=%pR get_res_add_size add_size %llx\n",\r\nidx, dev_res->res,\r\n(unsigned long long)dev_res->add_size);\r\nreturn dev_res->add_size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pdev_sort_resources(struct pci_dev *dev, struct list_head *head)\r\n{\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r;\r\nstruct pci_dev_resource *dev_res, *tmp;\r\nresource_size_t r_align;\r\nstruct list_head *n;\r\nr = &dev->resource[i];\r\nif (r->flags & IORESOURCE_PCI_FIXED)\r\ncontinue;\r\nif (!(r->flags) || r->parent)\r\ncontinue;\r\nr_align = pci_resource_alignment(dev, r);\r\nif (!r_align) {\r\ndev_warn(&dev->dev, "BAR %d: %pR has bogus alignment\n",\r\ni, r);\r\ncontinue;\r\n}\r\ntmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\r\nif (!tmp)\r\npanic("pdev_sort_resources(): "\r\n"kmalloc() failed!\n");\r\ntmp->res = r;\r\ntmp->dev = dev;\r\nn = head;\r\nlist_for_each_entry(dev_res, head, list) {\r\nresource_size_t align;\r\nalign = pci_resource_alignment(dev_res->dev,\r\ndev_res->res);\r\nif (r_align > align) {\r\nn = &dev_res->list;\r\nbreak;\r\n}\r\n}\r\nlist_add_tail(&tmp->list, n);\r\n}\r\n}\r\nstatic void __dev_sort_resources(struct pci_dev *dev,\r\nstruct list_head *head)\r\n{\r\nu16 class = dev->class >> 8;\r\nif (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)\r\nreturn;\r\nif (class == PCI_CLASS_SYSTEM_PIC) {\r\nu16 command;\r\npci_read_config_word(dev, PCI_COMMAND, &command);\r\nif (command & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))\r\nreturn;\r\n}\r\npdev_sort_resources(dev, head);\r\n}\r\nstatic inline void reset_resource(struct resource *res)\r\n{\r\nres->start = 0;\r\nres->end = 0;\r\nres->flags = 0;\r\n}\r\nstatic void reassign_resources_sorted(struct list_head *realloc_head,\r\nstruct list_head *head)\r\n{\r\nstruct resource *res;\r\nstruct pci_dev_resource *add_res, *tmp;\r\nstruct pci_dev_resource *dev_res;\r\nresource_size_t add_size;\r\nint idx;\r\nlist_for_each_entry_safe(add_res, tmp, realloc_head, list) {\r\nbool found_match = false;\r\nres = add_res->res;\r\nif (!res->flags)\r\ngoto out;\r\nlist_for_each_entry(dev_res, head, list) {\r\nif (dev_res->res == res) {\r\nfound_match = true;\r\nbreak;\r\n}\r\n}\r\nif (!found_match)\r\ncontinue;\r\nidx = res - &add_res->dev->resource[0];\r\nadd_size = add_res->add_size;\r\nif (!resource_size(res)) {\r\nres->start = add_res->start;\r\nres->end = res->start + add_size - 1;\r\nif (pci_assign_resource(add_res->dev, idx))\r\nreset_resource(res);\r\n} else {\r\nresource_size_t align = add_res->min_align;\r\nres->flags |= add_res->flags &\r\n(IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);\r\nif (pci_reassign_resource(add_res->dev, idx,\r\nadd_size, align))\r\ndev_printk(KERN_DEBUG, &add_res->dev->dev,\r\n"failed to add %llx res[%d]=%pR\n",\r\n(unsigned long long)add_size,\r\nidx, res);\r\n}\r\nout:\r\nlist_del(&add_res->list);\r\nkfree(add_res);\r\n}\r\n}\r\nstatic void assign_requested_resources_sorted(struct list_head *head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct resource *res;\r\nstruct pci_dev_resource *dev_res;\r\nint idx;\r\nlist_for_each_entry(dev_res, head, list) {\r\nres = dev_res->res;\r\nidx = res - &dev_res->dev->resource[0];\r\nif (resource_size(res) &&\r\npci_assign_resource(dev_res->dev, idx)) {\r\nif (fail_head && !pci_is_root_bus(dev_res->dev->bus)) {\r\nif (!((idx == PCI_ROM_RESOURCE) &&\r\n(!(res->flags & IORESOURCE_ROM_ENABLE))))\r\nadd_to_list(fail_head,\r\ndev_res->dev, res,\r\n0 ,\r\n0 );\r\n}\r\nreset_resource(res);\r\n}\r\n}\r\n}\r\nstatic void __assign_resources_sorted(struct list_head *head,\r\nstruct list_head *realloc_head,\r\nstruct list_head *fail_head)\r\n{\r\nLIST_HEAD(save_head);\r\nLIST_HEAD(local_fail_head);\r\nstruct pci_dev_resource *save_res;\r\nstruct pci_dev_resource *dev_res;\r\nif (!realloc_head || list_empty(realloc_head))\r\ngoto requested_and_reassign;\r\nlist_for_each_entry(dev_res, head, list) {\r\nif (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {\r\nfree_list(&save_head);\r\ngoto requested_and_reassign;\r\n}\r\n}\r\nlist_for_each_entry(dev_res, head, list)\r\ndev_res->res->end += get_res_add_size(realloc_head,\r\ndev_res->res);\r\nassign_requested_resources_sorted(head, &local_fail_head);\r\nif (list_empty(&local_fail_head)) {\r\nlist_for_each_entry(dev_res, head, list)\r\nremove_from_list(realloc_head, dev_res->res);\r\nfree_list(&save_head);\r\nfree_list(head);\r\nreturn;\r\n}\r\nfree_list(&local_fail_head);\r\nlist_for_each_entry(dev_res, head, list)\r\nif (dev_res->res->parent)\r\nrelease_resource(dev_res->res);\r\nlist_for_each_entry(save_res, &save_head, list) {\r\nstruct resource *res = save_res->res;\r\nres->start = save_res->start;\r\nres->end = save_res->end;\r\nres->flags = save_res->flags;\r\n}\r\nfree_list(&save_head);\r\nrequested_and_reassign:\r\nassign_requested_resources_sorted(head, fail_head);\r\nif (realloc_head)\r\nreassign_resources_sorted(realloc_head, head);\r\nfree_list(head);\r\n}\r\nstatic void pdev_assign_resources_sorted(struct pci_dev *dev,\r\nstruct list_head *add_head,\r\nstruct list_head *fail_head)\r\n{\r\nLIST_HEAD(head);\r\n__dev_sort_resources(dev, &head);\r\n__assign_resources_sorted(&head, add_head, fail_head);\r\n}\r\nstatic void pbus_assign_resources_sorted(const struct pci_bus *bus,\r\nstruct list_head *realloc_head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct pci_dev *dev;\r\nLIST_HEAD(head);\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\n__dev_sort_resources(dev, &head);\r\n__assign_resources_sorted(&head, realloc_head, fail_head);\r\n}\r\nvoid pci_setup_cardbus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\ndev_info(&bridge->dev, "CardBus bridge to [bus %02x-%02x]\n",\r\nbus->secondary, bus->subordinate);\r\nres = bus->resource[0];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_IO_BASE_0,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_IO_LIMIT_0,\r\nregion.end);\r\n}\r\nres = bus->resource[1];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_IO_BASE_1,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_IO_LIMIT_1,\r\nregion.end);\r\n}\r\nres = bus->resource[2];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_0,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_0,\r\nregion.end);\r\n}\r\nres = bus->resource[3];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_1,\r\nregion.start);\r\npci_write_config_dword(bridge, PCI_CB_MEMORY_LIMIT_1,\r\nregion.end);\r\n}\r\n}\r\nstatic void pci_setup_bridge_io(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l, io_upper16;\r\nres = bus->resource[0];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_IO) {\r\npci_read_config_dword(bridge, PCI_IO_BASE, &l);\r\nl &= 0xffff0000;\r\nl |= (region.start >> 8) & 0x00f0;\r\nl |= region.end & 0xf000;\r\nio_upper16 = (region.end & 0xffff0000) | (region.start >> 16);\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nio_upper16 = 0;\r\nl = 0x00f0;\r\n}\r\npci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, 0x0000ffff);\r\npci_write_config_dword(bridge, PCI_IO_BASE, l);\r\npci_write_config_dword(bridge, PCI_IO_BASE_UPPER16, io_upper16);\r\n}\r\nstatic void pci_setup_bridge_mmio(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l;\r\nres = bus->resource[1];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_MEM) {\r\nl = (region.start >> 16) & 0xfff0;\r\nl |= region.end & 0xfff00000;\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nl = 0x0000fff0;\r\n}\r\npci_write_config_dword(bridge, PCI_MEMORY_BASE, l);\r\n}\r\nstatic void pci_setup_bridge_mmio_pref(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *res;\r\nstruct pci_bus_region region;\r\nu32 l, bu, lu;\r\npci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, 0);\r\nbu = lu = 0;\r\nres = bus->resource[2];\r\npcibios_resource_to_bus(bridge, &region, res);\r\nif (res->flags & IORESOURCE_PREFETCH) {\r\nl = (region.start >> 16) & 0xfff0;\r\nl |= region.end & 0xfff00000;\r\nif (res->flags & IORESOURCE_MEM_64) {\r\nbu = upper_32_bits(region.start);\r\nlu = upper_32_bits(region.end);\r\n}\r\ndev_info(&bridge->dev, " bridge window %pR\n", res);\r\n} else {\r\nl = 0x0000fff0;\r\n}\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, l);\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, bu);\r\npci_write_config_dword(bridge, PCI_PREF_LIMIT_UPPER32, lu);\r\n}\r\nstatic void __pci_setup_bridge(struct pci_bus *bus, unsigned long type)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\ndev_info(&bridge->dev, "PCI bridge to [bus %02x-%02x]\n",\r\nbus->secondary, bus->subordinate);\r\nif (type & IORESOURCE_IO)\r\npci_setup_bridge_io(bus);\r\nif (type & IORESOURCE_MEM)\r\npci_setup_bridge_mmio(bus);\r\nif (type & IORESOURCE_PREFETCH)\r\npci_setup_bridge_mmio_pref(bus);\r\npci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);\r\n}\r\nvoid pci_setup_bridge(struct pci_bus *bus)\r\n{\r\nunsigned long type = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\n__pci_setup_bridge(bus, type);\r\n}\r\nstatic void pci_bridge_check_ranges(struct pci_bus *bus)\r\n{\r\nu16 io;\r\nu32 pmem;\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *b_res;\r\nb_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\r\nb_res[1].flags |= IORESOURCE_MEM;\r\npci_read_config_word(bridge, PCI_IO_BASE, &io);\r\nif (!io) {\r\npci_write_config_word(bridge, PCI_IO_BASE, 0xf0f0);\r\npci_read_config_word(bridge, PCI_IO_BASE, &io);\r\npci_write_config_word(bridge, PCI_IO_BASE, 0x0);\r\n}\r\nif (io)\r\nb_res[0].flags |= IORESOURCE_IO;\r\nif (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)\r\nreturn;\r\npci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\r\nif (!pmem) {\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,\r\n0xfff0fff0);\r\npci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);\r\npci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);\r\n}\r\nif (pmem) {\r\nb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nif ((pmem & PCI_PREF_RANGE_TYPE_MASK) ==\r\nPCI_PREF_RANGE_TYPE_64) {\r\nb_res[2].flags |= IORESOURCE_MEM_64;\r\nb_res[2].flags |= PCI_PREF_RANGE_TYPE_64;\r\n}\r\n}\r\nif (b_res[2].flags & IORESOURCE_MEM_64) {\r\nu32 mem_base_hi, tmp;\r\npci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\n&mem_base_hi);\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\n0xffffffff);\r\npci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);\r\nif (!tmp)\r\nb_res[2].flags &= ~IORESOURCE_MEM_64;\r\npci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,\r\nmem_base_hi);\r\n}\r\n}\r\nstatic struct resource *find_free_bus_resource(struct pci_bus *bus, unsigned long type)\r\n{\r\nint i;\r\nstruct resource *r;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\npci_bus_for_each_resource(bus, r, i) {\r\nif (r == &ioport_resource || r == &iomem_resource)\r\ncontinue;\r\nif (r && (r->flags & type_mask) == type && !r->parent)\r\nreturn r;\r\n}\r\nreturn NULL;\r\n}\r\nstatic resource_size_t calculate_iosize(resource_size_t size,\r\nresource_size_t min_size,\r\nresource_size_t size1,\r\nresource_size_t old_size,\r\nresource_size_t align)\r\n{\r\nif (size < min_size)\r\nsize = min_size;\r\nif (old_size == 1 )\r\nold_size = 0;\r\n#if defined(CONFIG_ISA) || defined(CONFIG_EISA)\r\nsize = (size & 0xff) + ((size & ~0xffUL) << 2);\r\n#endif\r\nsize = ALIGN(size + size1, align);\r\nif (size < old_size)\r\nsize = old_size;\r\nreturn size;\r\n}\r\nstatic resource_size_t calculate_memsize(resource_size_t size,\r\nresource_size_t min_size,\r\nresource_size_t size1,\r\nresource_size_t old_size,\r\nresource_size_t align)\r\n{\r\nif (size < min_size)\r\nsize = min_size;\r\nif (old_size == 1 )\r\nold_size = 0;\r\nif (size < old_size)\r\nsize = old_size;\r\nsize = ALIGN(size + size1, align);\r\nreturn size;\r\n}\r\nstatic void pbus_size_io(struct pci_bus *bus, resource_size_t min_size,\r\nresource_size_t add_size, struct list_head *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nstruct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO);\r\nunsigned long size = 0, size0 = 0, size1 = 0;\r\nresource_size_t children_add_size = 0;\r\nif (!b_res)\r\nreturn;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nunsigned long r_size;\r\nif (r->parent || !(r->flags & IORESOURCE_IO))\r\ncontinue;\r\nr_size = resource_size(r);\r\nif (r_size < 0x400)\r\nsize += r_size;\r\nelse\r\nsize1 += r_size;\r\nif (realloc_head)\r\nchildren_add_size += get_res_add_size(realloc_head, r);\r\n}\r\n}\r\nsize0 = calculate_iosize(size, min_size, size1,\r\nresource_size(b_res), 4096);\r\nif (children_add_size > add_size)\r\nadd_size = children_add_size;\r\nsize1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :\r\ncalculate_iosize(size, min_size, add_size + size1,\r\nresource_size(b_res), 4096);\r\nif (!size0 && !size1) {\r\nif (b_res->start || b_res->end)\r\ndev_info(&bus->self->dev, "disabling bridge window "\r\n"%pR to [bus %02x-%02x] (unused)\n", b_res,\r\nbus->secondary, bus->subordinate);\r\nb_res->flags = 0;\r\nreturn;\r\n}\r\nb_res->start = 4096;\r\nb_res->end = b_res->start + size0 - 1;\r\nb_res->flags |= IORESOURCE_STARTALIGN;\r\nif (size1 > size0 && realloc_head) {\r\nadd_to_list(realloc_head, bus->self, b_res, size1-size0, 4096);\r\ndev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "\r\n"%pR to [bus %02x-%02x] add_size %lx\n", b_res,\r\nbus->secondary, bus->subordinate, size1-size0);\r\n}\r\n}\r\nstatic int pbus_size_mem(struct pci_bus *bus, unsigned long mask,\r\nunsigned long type, resource_size_t min_size,\r\nresource_size_t add_size,\r\nstruct list_head *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nresource_size_t min_align, align, size, size0, size1;\r\nresource_size_t aligns[12];\r\nint order, max_order;\r\nstruct resource *b_res = find_free_bus_resource(bus, type);\r\nunsigned int mem64_mask = 0;\r\nresource_size_t children_add_size = 0;\r\nif (!b_res)\r\nreturn 0;\r\nmemset(aligns, 0, sizeof(aligns));\r\nmax_order = 0;\r\nsize = 0;\r\nmem64_mask = b_res->flags & IORESOURCE_MEM_64;\r\nb_res->flags &= ~IORESOURCE_MEM_64;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nresource_size_t r_size;\r\nif (r->parent || (r->flags & mask) != type)\r\ncontinue;\r\nr_size = resource_size(r);\r\n#ifdef CONFIG_PCI_IOV\r\nif (realloc_head && i >= PCI_IOV_RESOURCES &&\r\ni <= PCI_IOV_RESOURCE_END) {\r\nr->end = r->start - 1;\r\nadd_to_list(realloc_head, dev, r, r_size, 0);\r\nchildren_add_size += r_size;\r\ncontinue;\r\n}\r\n#endif\r\nalign = pci_resource_alignment(dev, r);\r\norder = __ffs(align) - 20;\r\nif (order > 11) {\r\ndev_warn(&dev->dev, "disabling BAR %d: %pR "\r\n"(bad alignment %#llx)\n", i, r,\r\n(unsigned long long) align);\r\nr->flags = 0;\r\ncontinue;\r\n}\r\nsize += r_size;\r\nif (order < 0)\r\norder = 0;\r\nif (r_size == align)\r\naligns[order] += align;\r\nif (order > max_order)\r\nmax_order = order;\r\nmem64_mask &= r->flags & IORESOURCE_MEM_64;\r\nif (realloc_head)\r\nchildren_add_size += get_res_add_size(realloc_head, r);\r\n}\r\n}\r\nalign = 0;\r\nmin_align = 0;\r\nfor (order = 0; order <= max_order; order++) {\r\nresource_size_t align1 = 1;\r\nalign1 <<= (order + 20);\r\nif (!align)\r\nmin_align = align1;\r\nelse if (ALIGN(align + min_align, min_align) < align1)\r\nmin_align = align1 >> 1;\r\nalign += aligns[order];\r\n}\r\nsize0 = calculate_memsize(size, min_size, 0, resource_size(b_res), min_align);\r\nif (children_add_size > add_size)\r\nadd_size = children_add_size;\r\nsize1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :\r\ncalculate_memsize(size, min_size, add_size,\r\nresource_size(b_res), min_align);\r\nif (!size0 && !size1) {\r\nif (b_res->start || b_res->end)\r\ndev_info(&bus->self->dev, "disabling bridge window "\r\n"%pR to [bus %02x-%02x] (unused)\n", b_res,\r\nbus->secondary, bus->subordinate);\r\nb_res->flags = 0;\r\nreturn 1;\r\n}\r\nb_res->start = min_align;\r\nb_res->end = size0 + min_align - 1;\r\nb_res->flags |= IORESOURCE_STARTALIGN | mem64_mask;\r\nif (size1 > size0 && realloc_head) {\r\nadd_to_list(realloc_head, bus->self, b_res, size1-size0, min_align);\r\ndev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "\r\n"%pR to [bus %02x-%02x] add_size %llx\n", b_res,\r\nbus->secondary, bus->subordinate, (unsigned long long)size1-size0);\r\n}\r\nreturn 1;\r\n}\r\nunsigned long pci_cardbus_resource_alignment(struct resource *res)\r\n{\r\nif (res->flags & IORESOURCE_IO)\r\nreturn pci_cardbus_io_size;\r\nif (res->flags & IORESOURCE_MEM)\r\nreturn pci_cardbus_mem_size;\r\nreturn 0;\r\n}\r\nstatic void pci_bus_size_cardbus(struct pci_bus *bus,\r\nstruct list_head *realloc_head)\r\n{\r\nstruct pci_dev *bridge = bus->self;\r\nstruct resource *b_res = &bridge->resource[PCI_BRIDGE_RESOURCES];\r\nresource_size_t b_res_3_size = pci_cardbus_mem_size * 2;\r\nu16 ctrl;\r\nif (b_res[0].parent)\r\ngoto handle_b_res_1;\r\nb_res[0].start = pci_cardbus_io_size;\r\nb_res[0].end = b_res[0].start + pci_cardbus_io_size - 1;\r\nb_res[0].flags |= IORESOURCE_IO | IORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[0].end -= pci_cardbus_io_size;\r\nadd_to_list(realloc_head, bridge, b_res, pci_cardbus_io_size,\r\npci_cardbus_io_size);\r\n}\r\nhandle_b_res_1:\r\nif (b_res[1].parent)\r\ngoto handle_b_res_2;\r\nb_res[1].start = pci_cardbus_io_size;\r\nb_res[1].end = b_res[1].start + pci_cardbus_io_size - 1;\r\nb_res[1].flags |= IORESOURCE_IO | IORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[1].end -= pci_cardbus_io_size;\r\nadd_to_list(realloc_head, bridge, b_res+1, pci_cardbus_io_size,\r\npci_cardbus_io_size);\r\n}\r\nhandle_b_res_2:\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\nif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM1) {\r\nctrl &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM1;\r\npci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\n}\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\nif (!(ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0)) {\r\nctrl |= PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;\r\npci_write_config_word(bridge, PCI_CB_BRIDGE_CONTROL, ctrl);\r\npci_read_config_word(bridge, PCI_CB_BRIDGE_CONTROL, &ctrl);\r\n}\r\nif (b_res[2].parent)\r\ngoto handle_b_res_3;\r\nif (ctrl & PCI_CB_BRIDGE_CTL_PREFETCH_MEM0) {\r\nb_res[2].start = pci_cardbus_mem_size;\r\nb_res[2].end = b_res[2].start + pci_cardbus_mem_size - 1;\r\nb_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH |\r\nIORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[2].end -= pci_cardbus_mem_size;\r\nadd_to_list(realloc_head, bridge, b_res+2,\r\npci_cardbus_mem_size, pci_cardbus_mem_size);\r\n}\r\nb_res_3_size = pci_cardbus_mem_size;\r\n}\r\nhandle_b_res_3:\r\nif (b_res[3].parent)\r\ngoto handle_done;\r\nb_res[3].start = pci_cardbus_mem_size;\r\nb_res[3].end = b_res[3].start + b_res_3_size - 1;\r\nb_res[3].flags |= IORESOURCE_MEM | IORESOURCE_STARTALIGN;\r\nif (realloc_head) {\r\nb_res[3].end -= b_res_3_size;\r\nadd_to_list(realloc_head, bridge, b_res+3, b_res_3_size,\r\npci_cardbus_mem_size);\r\n}\r\nhandle_done:\r\n;\r\n}\r\nvoid __ref __pci_bus_size_bridges(struct pci_bus *bus,\r\nstruct list_head *realloc_head)\r\n{\r\nstruct pci_dev *dev;\r\nunsigned long mask, prefmask;\r\nresource_size_t additional_mem_size = 0, additional_io_size = 0;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_bus_size_cardbus(b, realloc_head);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_PCI:\r\ndefault:\r\n__pci_bus_size_bridges(b, realloc_head);\r\nbreak;\r\n}\r\n}\r\nif (!bus->self)\r\nreturn;\r\nswitch (bus->self->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_bridge_check_ranges(bus);\r\nif (bus->self->is_hotplug_bridge) {\r\nadditional_io_size = pci_hotplug_io_size;\r\nadditional_mem_size = pci_hotplug_mem_size;\r\n}\r\ndefault:\r\npbus_size_io(bus, realloc_head ? 0 : additional_io_size,\r\nadditional_io_size, realloc_head);\r\nmask = IORESOURCE_MEM;\r\nprefmask = IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nif (pbus_size_mem(bus, prefmask, prefmask,\r\nrealloc_head ? 0 : additional_mem_size,\r\nadditional_mem_size, realloc_head))\r\nmask = prefmask;\r\nelse\r\nadditional_mem_size += additional_mem_size;\r\npbus_size_mem(bus, mask, IORESOURCE_MEM,\r\nrealloc_head ? 0 : additional_mem_size,\r\nadditional_mem_size, realloc_head);\r\nbreak;\r\n}\r\n}\r\nvoid __ref pci_bus_size_bridges(struct pci_bus *bus)\r\n{\r\n__pci_bus_size_bridges(bus, NULL);\r\n}\r\nstatic void __ref __pci_bus_assign_resources(const struct pci_bus *bus,\r\nstruct list_head *realloc_head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct pci_bus *b;\r\nstruct pci_dev *dev;\r\npbus_assign_resources_sorted(bus, realloc_head, fail_head);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nb = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\n__pci_bus_assign_resources(b, realloc_head, fail_head);\r\nswitch (dev->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\nif (!pci_is_enabled(dev))\r\npci_setup_bridge(b);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_setup_cardbus(b);\r\nbreak;\r\ndefault:\r\ndev_info(&dev->dev, "not setting up bridge for bus "\r\n"%04x:%02x\n", pci_domain_nr(b), b->number);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid __ref pci_bus_assign_resources(const struct pci_bus *bus)\r\n{\r\n__pci_bus_assign_resources(bus, NULL, NULL);\r\n}\r\nstatic void __ref __pci_bridge_assign_resources(const struct pci_dev *bridge,\r\nstruct list_head *add_head,\r\nstruct list_head *fail_head)\r\n{\r\nstruct pci_bus *b;\r\npdev_assign_resources_sorted((struct pci_dev *)bridge,\r\nadd_head, fail_head);\r\nb = bridge->subordinate;\r\nif (!b)\r\nreturn;\r\n__pci_bus_assign_resources(b, add_head, fail_head);\r\nswitch (bridge->class >> 8) {\r\ncase PCI_CLASS_BRIDGE_PCI:\r\npci_setup_bridge(b);\r\nbreak;\r\ncase PCI_CLASS_BRIDGE_CARDBUS:\r\npci_setup_cardbus(b);\r\nbreak;\r\ndefault:\r\ndev_info(&bridge->dev, "not setting up bridge for bus "\r\n"%04x:%02x\n", pci_domain_nr(b), b->number);\r\nbreak;\r\n}\r\n}\r\nstatic void pci_bridge_release_resources(struct pci_bus *bus,\r\nunsigned long type)\r\n{\r\nint idx;\r\nbool changed = false;\r\nstruct pci_dev *dev;\r\nstruct resource *r;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\ndev = bus->self;\r\nfor (idx = PCI_BRIDGE_RESOURCES; idx <= PCI_BRIDGE_RESOURCE_END;\r\nidx++) {\r\nr = &dev->resource[idx];\r\nif ((r->flags & type_mask) != type)\r\ncontinue;\r\nif (!r->parent)\r\ncontinue;\r\nrelease_child_resources(r);\r\nif (!release_resource(r)) {\r\ndev_printk(KERN_DEBUG, &dev->dev,\r\n"resource %d %pR released\n", idx, r);\r\nr->end = resource_size(r) - 1;\r\nr->start = 0;\r\nr->flags = 0;\r\nchanged = true;\r\n}\r\n}\r\nif (changed) {\r\nif (type & IORESOURCE_PREFETCH)\r\ntype = IORESOURCE_PREFETCH;\r\n__pci_setup_bridge(bus, type);\r\n}\r\n}\r\nstatic void __ref pci_bus_release_bridge_resources(struct pci_bus *bus,\r\nunsigned long type,\r\nenum release_type rel_type)\r\n{\r\nstruct pci_dev *dev;\r\nbool is_leaf_bridge = true;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nis_leaf_bridge = false;\r\nif ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\ncontinue;\r\nif (rel_type == whole_subtree)\r\npci_bus_release_bridge_resources(b, type,\r\nwhole_subtree);\r\n}\r\nif (pci_is_root_bus(bus))\r\nreturn;\r\nif ((bus->self->class >> 8) != PCI_CLASS_BRIDGE_PCI)\r\nreturn;\r\nif ((rel_type == whole_subtree) || is_leaf_bridge)\r\npci_bridge_release_resources(bus, type);\r\n}\r\nstatic void pci_bus_dump_res(struct pci_bus *bus)\r\n{\r\nstruct resource *res;\r\nint i;\r\npci_bus_for_each_resource(bus, res, i) {\r\nif (!res || !res->end || !res->flags)\r\ncontinue;\r\ndev_printk(KERN_DEBUG, &bus->dev, "resource %d %pR\n", i, res);\r\n}\r\n}\r\nstatic void pci_bus_dump_resources(struct pci_bus *bus)\r\n{\r\nstruct pci_bus *b;\r\nstruct pci_dev *dev;\r\npci_bus_dump_res(bus);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nb = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\npci_bus_dump_resources(b);\r\n}\r\n}\r\nstatic int __init pci_bus_get_depth(struct pci_bus *bus)\r\n{\r\nint depth = 0;\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint ret;\r\nstruct pci_bus *b = dev->subordinate;\r\nif (!b)\r\ncontinue;\r\nret = pci_bus_get_depth(b);\r\nif (ret + 1 > depth)\r\ndepth = ret + 1;\r\n}\r\nreturn depth;\r\n}\r\nstatic int __init pci_get_max_depth(void)\r\n{\r\nint depth = 0;\r\nstruct pci_bus *bus;\r\nlist_for_each_entry(bus, &pci_root_buses, node) {\r\nint ret;\r\nret = pci_bus_get_depth(bus);\r\nif (ret > depth)\r\ndepth = ret;\r\n}\r\nreturn depth;\r\n}\r\nvoid __init pci_realloc_get_opt(char *str)\r\n{\r\nif (!strncmp(str, "off", 3))\r\npci_realloc_enable = user_disabled;\r\nelse if (!strncmp(str, "on", 2))\r\npci_realloc_enable = user_enabled;\r\n}\r\nstatic bool __init pci_realloc_enabled(void)\r\n{\r\nreturn pci_realloc_enable >= user_enabled;\r\n}\r\nstatic void __init pci_realloc_detect(void)\r\n{\r\n#if defined(CONFIG_PCI_IOV) && defined(CONFIG_PCI_REALLOC_ENABLE_AUTO)\r\nstruct pci_dev *dev = NULL;\r\nif (pci_realloc_enable != undefined)\r\nreturn;\r\nfor_each_pci_dev(dev) {\r\nint i;\r\nfor (i = PCI_IOV_RESOURCES; i <= PCI_IOV_RESOURCE_END; i++) {\r\nstruct resource *r = &dev->resource[i];\r\nif (r->flags && !r->start) {\r\npci_realloc_enable = auto_enabled;\r\nreturn;\r\n}\r\n}\r\n}\r\n#endif\r\n}\r\nvoid __init\r\npci_assign_unassigned_resources(void)\r\n{\r\nstruct pci_bus *bus;\r\nLIST_HEAD(realloc_head);\r\nstruct list_head *add_list = NULL;\r\nint tried_times = 0;\r\nenum release_type rel_type = leaf_only;\r\nLIST_HEAD(fail_head);\r\nstruct pci_dev_resource *fail_res;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\nint pci_try_num = 1;\r\npci_realloc_detect();\r\nif (pci_realloc_enabled()) {\r\nint max_depth = pci_get_max_depth();\r\npci_try_num = max_depth + 1;\r\nprintk(KERN_DEBUG "PCI: max bus depth: %d pci_try_num: %d\n",\r\nmax_depth, pci_try_num);\r\n}\r\nagain:\r\nif (tried_times + 1 == pci_try_num)\r\nadd_list = &realloc_head;\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\n__pci_bus_size_bridges(bus, add_list);\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\n__pci_bus_assign_resources(bus, add_list, &fail_head);\r\nif (add_list)\r\nBUG_ON(!list_empty(add_list));\r\ntried_times++;\r\nif (list_empty(&fail_head))\r\ngoto enable_and_dump;\r\nif (tried_times >= pci_try_num) {\r\nif (pci_realloc_enable == undefined)\r\nprintk(KERN_INFO "Some PCI device resources are unassigned, try booting with pci=realloc\n");\r\nelse if (pci_realloc_enable == auto_enabled)\r\nprintk(KERN_INFO "Automatically enabled pci realloc, if you have problem, try booting with pci=realloc=off\n");\r\nfree_list(&fail_head);\r\ngoto enable_and_dump;\r\n}\r\nprintk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",\r\ntried_times + 1);\r\nif ((tried_times + 1) > 2)\r\nrel_type = whole_subtree;\r\nlist_for_each_entry(fail_res, &fail_head, list) {\r\nbus = fail_res->dev->bus;\r\npci_bus_release_bridge_resources(bus,\r\nfail_res->flags & type_mask,\r\nrel_type);\r\n}\r\nlist_for_each_entry(fail_res, &fail_head, list) {\r\nstruct resource *res = fail_res->res;\r\nres->start = fail_res->start;\r\nres->end = fail_res->end;\r\nres->flags = fail_res->flags;\r\nif (fail_res->dev->subordinate)\r\nres->flags = 0;\r\n}\r\nfree_list(&fail_head);\r\ngoto again;\r\nenable_and_dump:\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\npci_enable_bridges(bus);\r\nlist_for_each_entry(bus, &pci_root_buses, node)\r\npci_bus_dump_resources(bus);\r\n}\r\nvoid pci_assign_unassigned_bridge_resources(struct pci_dev *bridge)\r\n{\r\nstruct pci_bus *parent = bridge->subordinate;\r\nLIST_HEAD(add_list);\r\nint tried_times = 0;\r\nLIST_HEAD(fail_head);\r\nstruct pci_dev_resource *fail_res;\r\nint retval;\r\nunsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |\r\nIORESOURCE_PREFETCH;\r\nagain:\r\n__pci_bus_size_bridges(parent, &add_list);\r\n__pci_bridge_assign_resources(bridge, &add_list, &fail_head);\r\nBUG_ON(!list_empty(&add_list));\r\ntried_times++;\r\nif (list_empty(&fail_head))\r\ngoto enable_all;\r\nif (tried_times >= 2) {\r\nfree_list(&fail_head);\r\ngoto enable_all;\r\n}\r\nprintk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",\r\ntried_times + 1);\r\nlist_for_each_entry(fail_res, &fail_head, list) {\r\nstruct pci_bus *bus = fail_res->dev->bus;\r\nunsigned long flags = fail_res->flags;\r\npci_bus_release_bridge_resources(bus, flags & type_mask,\r\nwhole_subtree);\r\n}\r\nlist_for_each_entry(fail_res, &fail_head, list) {\r\nstruct resource *res = fail_res->res;\r\nres->start = fail_res->start;\r\nres->end = fail_res->end;\r\nres->flags = fail_res->flags;\r\nif (fail_res->dev->subordinate)\r\nres->flags = 0;\r\n}\r\nfree_list(&fail_head);\r\ngoto again;\r\nenable_all:\r\nretval = pci_reenable_device(bridge);\r\npci_set_master(bridge);\r\npci_enable_bridges(parent);\r\n}\r\nunsigned int __ref pci_rescan_bus(struct pci_bus *bus)\r\n{\r\nunsigned int max;\r\nstruct pci_dev *dev;\r\nLIST_HEAD(add_list);\r\nmax = pci_scan_child_bus(bus);\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\nif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||\r\ndev->hdr_type == PCI_HEADER_TYPE_CARDBUS)\r\nif (dev->subordinate)\r\n__pci_bus_size_bridges(dev->subordinate,\r\n&add_list);\r\nup_read(&pci_bus_sem);\r\n__pci_bus_assign_resources(bus, &add_list, NULL);\r\nBUG_ON(!list_empty(&add_list));\r\npci_enable_bridges(bus);\r\npci_bus_add_devices(bus);\r\nreturn max;\r\n}
