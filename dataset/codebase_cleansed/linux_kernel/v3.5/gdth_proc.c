int gdth_proc_info(struct Scsi_Host *host, char *buffer,char **start,off_t offset,int length,\r\nint inout)\r\n{\r\ngdth_ha_str *ha = shost_priv(host);\r\nTRACE2(("gdth_proc_info() length %d offs %d inout %d\n",\r\nlength,(int)offset,inout));\r\nif (inout)\r\nreturn(gdth_set_info(buffer,length,host,ha));\r\nelse\r\nreturn(gdth_get_info(buffer,start,offset,length,host,ha));\r\n}\r\nstatic int gdth_set_info(char *buffer,int length,struct Scsi_Host *host,\r\ngdth_ha_str *ha)\r\n{\r\nint ret_val = -EINVAL;\r\nTRACE2(("gdth_set_info() ha %d\n",ha->hanum,));\r\nif (length >= 4) {\r\nif (strncmp(buffer,"gdth",4) == 0) {\r\nbuffer += 5;\r\nlength -= 5;\r\nret_val = gdth_set_asc_info(host, buffer, length, ha);\r\n}\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int gdth_set_asc_info(struct Scsi_Host *host, char *buffer,\r\nint length, gdth_ha_str *ha)\r\n{\r\nint orig_length, drive, wb_mode;\r\nint i, found;\r\ngdth_cmd_str gdtcmd;\r\ngdth_cpar_str *pcpar;\r\nu64 paddr;\r\nchar cmnd[MAX_COMMAND_SIZE];\r\nmemset(cmnd, 0xff, 12);\r\nmemset(&gdtcmd, 0, sizeof(gdth_cmd_str));\r\nTRACE2(("gdth_set_asc_info() ha %d\n",ha->hanum));\r\norig_length = length + 5;\r\ndrive = -1;\r\nwb_mode = 0;\r\nfound = FALSE;\r\nif (length >= 5 && strncmp(buffer,"flush",5)==0) {\r\nbuffer += 6;\r\nlength -= 6;\r\nif (length && *buffer>='0' && *buffer<='9') {\r\ndrive = (int)(*buffer-'0');\r\n++buffer; --length;\r\nif (length && *buffer>='0' && *buffer<='9') {\r\ndrive = drive*10 + (int)(*buffer-'0');\r\n++buffer; --length;\r\n}\r\nprintk("GDT: Flushing host drive %d .. ",drive);\r\n} else {\r\nprintk("GDT: Flushing all host drives .. ");\r\n}\r\nfor (i = 0; i < MAX_HDRIVES; ++i) {\r\nif (ha->hdr[i].present) {\r\nif (drive != -1 && i != drive)\r\ncontinue;\r\nfound = TRUE;\r\ngdtcmd.Service = CACHESERVICE;\r\ngdtcmd.OpCode = GDT_FLUSH;\r\nif (ha->cache_feat & GDT_64BIT) {\r\ngdtcmd.u.cache64.DeviceNo = i;\r\ngdtcmd.u.cache64.BlockNo = 1;\r\n} else {\r\ngdtcmd.u.cache.DeviceNo = i;\r\ngdtcmd.u.cache.BlockNo = 1;\r\n}\r\ngdth_execute(host, &gdtcmd, cmnd, 30, NULL);\r\n}\r\n}\r\nif (!found)\r\nprintk("\nNo host drive found !\n");\r\nelse\r\nprintk("Done.\n");\r\nreturn(orig_length);\r\n}\r\nif (length >= 7 && strncmp(buffer,"wbp_off",7)==0) {\r\nbuffer += 8;\r\nlength -= 8;\r\nprintk("GDT: Disabling write back permanently .. ");\r\nwb_mode = 1;\r\n} else if (length >= 6 && strncmp(buffer,"wbp_on",6)==0) {\r\nbuffer += 7;\r\nlength -= 7;\r\nprintk("GDT: Enabling write back permanently .. ");\r\nwb_mode = 2;\r\n} else if (length >= 6 && strncmp(buffer,"wb_off",6)==0) {\r\nbuffer += 7;\r\nlength -= 7;\r\nprintk("GDT: Disabling write back commands .. ");\r\nif (ha->cache_feat & GDT_WR_THROUGH) {\r\ngdth_write_through = TRUE;\r\nprintk("Done.\n");\r\n} else {\r\nprintk("Not supported !\n");\r\n}\r\nreturn(orig_length);\r\n} else if (length >= 5 && strncmp(buffer,"wb_on",5)==0) {\r\nbuffer += 6;\r\nlength -= 6;\r\nprintk("GDT: Enabling write back commands .. ");\r\ngdth_write_through = FALSE;\r\nprintk("Done.\n");\r\nreturn(orig_length);\r\n}\r\nif (wb_mode) {\r\nif (!gdth_ioctl_alloc(ha, sizeof(gdth_cpar_str), TRUE, &paddr))\r\nreturn(-EBUSY);\r\npcpar = (gdth_cpar_str *)ha->pscratch;\r\nmemcpy( pcpar, &ha->cpar, sizeof(gdth_cpar_str) );\r\ngdtcmd.Service = CACHESERVICE;\r\ngdtcmd.OpCode = GDT_IOCTL;\r\ngdtcmd.u.ioctl.p_param = paddr;\r\ngdtcmd.u.ioctl.param_size = sizeof(gdth_cpar_str);\r\ngdtcmd.u.ioctl.subfunc = CACHE_CONFIG;\r\ngdtcmd.u.ioctl.channel = INVALID_CHANNEL;\r\npcpar->write_back = wb_mode==1 ? 0:1;\r\ngdth_execute(host, &gdtcmd, cmnd, 30, NULL);\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, ha->pscratch, paddr);\r\nprintk("Done.\n");\r\nreturn(orig_length);\r\n}\r\nprintk("GDT: Unknown command: %s Length: %d\n",buffer,length);\r\nreturn(-EINVAL);\r\n}\r\nstatic int gdth_get_info(char *buffer,char **start,off_t offset,int length,\r\nstruct Scsi_Host *host, gdth_ha_str *ha)\r\n{\r\nint size = 0,len = 0;\r\nint hlen;\r\noff_t begin = 0,pos = 0;\r\nint id, i, j, k, sec, flag;\r\nint no_mdrv = 0, drv_no, is_mirr;\r\nu32 cnt;\r\nu64 paddr;\r\nint rc = -ENOMEM;\r\ngdth_cmd_str *gdtcmd;\r\ngdth_evt_str *estr;\r\nchar hrec[161];\r\nstruct timeval tv;\r\nchar *buf;\r\ngdth_dskstat_str *pds;\r\ngdth_diskinfo_str *pdi;\r\ngdth_arrayinf_str *pai;\r\ngdth_defcnt_str *pdef;\r\ngdth_cdrinfo_str *pcdi;\r\ngdth_hget_str *phg;\r\nchar cmnd[MAX_COMMAND_SIZE];\r\ngdtcmd = kmalloc(sizeof(*gdtcmd), GFP_KERNEL);\r\nestr = kmalloc(sizeof(*estr), GFP_KERNEL);\r\nif (!gdtcmd || !estr)\r\ngoto free_fail;\r\nmemset(cmnd, 0xff, 12);\r\nmemset(gdtcmd, 0, sizeof(gdth_cmd_str));\r\nTRACE2(("gdth_get_info() ha %d\n",ha->hanum));\r\nsize = sprintf(buffer+len,"Driver Parameters:\n");\r\nlen += size; pos = begin + len;\r\nif (reserve_list[0] == 0xff)\r\nstrcpy(hrec, "--");\r\nelse {\r\nhlen = sprintf(hrec, "%d", reserve_list[0]);\r\nfor (i = 1; i < MAX_RES_ARGS; i++) {\r\nif (reserve_list[i] == 0xff)\r\nbreak;\r\nhlen += snprintf(hrec + hlen , 161 - hlen, ",%d", reserve_list[i]);\r\n}\r\n}\r\nsize = sprintf(buffer+len,\r\n" reserve_mode: \t%d \treserve_list: \t%s\n",\r\nreserve_mode, hrec);\r\nlen += size; pos = begin + len;\r\nsize = sprintf(buffer+len,\r\n" max_ids: \t%-3d \thdr_channel: \t%d\n",\r\nmax_ids, hdr_channel);\r\nlen += size; pos = begin + len;\r\nsize = sprintf(buffer+len,"\nDisk Array Controller Information:\n");\r\nlen += size; pos = begin + len;\r\nstrcpy(hrec, ha->binfo.type_string);\r\nsize = sprintf(buffer+len,\r\n" Number: \t%d \tName: \t%s\n",\r\nha->hanum, hrec);\r\nlen += size; pos = begin + len;\r\nif (ha->more_proc)\r\nsprintf(hrec, "%d.%02d.%02d-%c%03X",\r\n(u8)(ha->binfo.upd_fw_ver>>24),\r\n(u8)(ha->binfo.upd_fw_ver>>16),\r\n(u8)(ha->binfo.upd_fw_ver),\r\nha->bfeat.raid ? 'R':'N',\r\nha->binfo.upd_revision);\r\nelse\r\nsprintf(hrec, "%d.%02d", (u8)(ha->cpar.version>>8),\r\n(u8)(ha->cpar.version));\r\nsize = sprintf(buffer+len,\r\n" Driver Ver.: \t%-10s\tFirmware Ver.: \t%s\n",\r\nGDTH_VERSION_STR, hrec);\r\nlen += size; pos = begin + len;\r\nif (ha->more_proc) {\r\nsize = sprintf(buffer+len,\r\n" Serial No.: \t0x%8X\tCache RAM size:\t%d KB\n",\r\nha->binfo.ser_no, ha->binfo.memsize / 1024);\r\nlen += size; pos = begin + len;\r\n}\r\n#ifdef GDTH_DMA_STATISTICS\r\nsize = sprintf(buffer+len,"\nController Statistics:\n");\r\nlen += size; pos = begin + len;\r\nsize = sprintf(buffer+len,\r\n" 32-bit DMA buffer:\t%lu\t64-bit DMA buffer:\t%lu\n",\r\nha->dma32_cnt, ha->dma64_cnt);\r\nlen += size; pos = begin + len;\r\n#endif\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length)\r\ngoto stop_output;\r\nif (ha->more_proc) {\r\nsize = sprintf(buffer+len,"\nPhysical Devices:");\r\nlen += size; pos = begin + len;\r\nflag = FALSE;\r\nbuf = gdth_ioctl_alloc(ha, GDTH_SCRATCH, FALSE, &paddr);\r\nif (!buf)\r\ngoto stop_output;\r\nfor (i = 0; i < ha->bus_cnt; ++i) {\r\nTRACE2(("pdr_statistics() chn %d\n",i));\r\npds = (gdth_dskstat_str *)(buf + GDTH_SCRATCH/4);\r\ngdtcmd->Service = CACHESERVICE;\r\ngdtcmd->OpCode = GDT_IOCTL;\r\ngdtcmd->u.ioctl.p_param = paddr + GDTH_SCRATCH/4;\r\ngdtcmd->u.ioctl.param_size = 3*GDTH_SCRATCH/4;\r\ngdtcmd->u.ioctl.subfunc = DSK_STATISTICS | L_CTRL_PATTERN;\r\ngdtcmd->u.ioctl.channel = ha->raw[i].address | INVALID_CHANNEL;\r\npds->bid = ha->raw[i].local_no;\r\npds->first = 0;\r\npds->entries = ha->raw[i].pdev_cnt;\r\ncnt = (3*GDTH_SCRATCH/4 - 5 * sizeof(u32)) /\r\nsizeof(pds->list[0]);\r\nif (pds->entries > cnt)\r\npds->entries = cnt;\r\nif (gdth_execute(host, gdtcmd, cmnd, 30, NULL) != S_OK)\r\npds->count = 0;\r\nfor (j = 0; j < ha->raw[i].pdev_cnt; ++j) {\r\nTRACE2(("scsi_drv_info() chn %d dev %d\n",\r\ni, ha->raw[i].id_list[j]));\r\npdi = (gdth_diskinfo_str *)buf;\r\ngdtcmd->Service = CACHESERVICE;\r\ngdtcmd->OpCode = GDT_IOCTL;\r\ngdtcmd->u.ioctl.p_param = paddr;\r\ngdtcmd->u.ioctl.param_size = sizeof(gdth_diskinfo_str);\r\ngdtcmd->u.ioctl.subfunc = SCSI_DR_INFO | L_CTRL_PATTERN;\r\ngdtcmd->u.ioctl.channel =\r\nha->raw[i].address | ha->raw[i].id_list[j];\r\nif (gdth_execute(host, gdtcmd, cmnd, 30, NULL) == S_OK) {\r\nstrncpy(hrec,pdi->vendor,8);\r\nstrncpy(hrec+8,pdi->product,16);\r\nstrncpy(hrec+24,pdi->revision,4);\r\nhrec[28] = 0;\r\nsize = sprintf(buffer+len,\r\n"\n Chn/ID/LUN: \t%c/%02d/%d \tName: \t%s\n",\r\n'A'+i,pdi->target_id,pdi->lun,hrec);\r\nlen += size; pos = begin + len;\r\nflag = TRUE;\r\npdi->no_ldrive &= 0xffff;\r\nif (pdi->no_ldrive == 0xffff)\r\nstrcpy(hrec,"--");\r\nelse\r\nsprintf(hrec,"%d",pdi->no_ldrive);\r\nsize = sprintf(buffer+len,\r\n" Capacity [MB]:\t%-6d \tTo Log. Drive: \t%s\n",\r\npdi->blkcnt/(1024*1024/pdi->blksize),\r\nhrec);\r\nlen += size; pos = begin + len;\r\n} else {\r\npdi->devtype = 0xff;\r\n}\r\nif (pdi->devtype == 0) {\r\nfor (k = 0; k < pds->count; ++k) {\r\nif (pds->list[k].tid == pdi->target_id &&\r\npds->list[k].lun == pdi->lun) {\r\nsize = sprintf(buffer+len,\r\n" Retries: \t%-6d \tReassigns: \t%d\n",\r\npds->list[k].retries,\r\npds->list[k].reassigns);\r\nlen += size; pos = begin + len;\r\nbreak;\r\n}\r\n}\r\nTRACE2(("scsi_drv_defcnt() chn %d dev %d\n",\r\ni, ha->raw[i].id_list[j]));\r\npdef = (gdth_defcnt_str *)buf;\r\ngdtcmd->Service = CACHESERVICE;\r\ngdtcmd->OpCode = GDT_IOCTL;\r\ngdtcmd->u.ioctl.p_param = paddr;\r\ngdtcmd->u.ioctl.param_size = sizeof(gdth_defcnt_str);\r\ngdtcmd->u.ioctl.subfunc = SCSI_DEF_CNT | L_CTRL_PATTERN;\r\ngdtcmd->u.ioctl.channel =\r\nha->raw[i].address | ha->raw[i].id_list[j];\r\npdef->sddc_type = 0x08;\r\nif (gdth_execute(host, gdtcmd, cmnd, 30, NULL) == S_OK) {\r\nsize = sprintf(buffer+len,\r\n" Grown Defects:\t%d\n",\r\npdef->sddc_cnt);\r\nlen += size; pos = begin + len;\r\n}\r\n}\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length) {\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\ngoto stop_output;\r\n}\r\n}\r\n}\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\nif (!flag) {\r\nsize = sprintf(buffer+len, "\n --\n");\r\nlen += size; pos = begin + len;\r\n}\r\nsize = sprintf(buffer+len,"\nLogical Drives:");\r\nlen += size; pos = begin + len;\r\nflag = FALSE;\r\nbuf = gdth_ioctl_alloc(ha, GDTH_SCRATCH, FALSE, &paddr);\r\nif (!buf)\r\ngoto stop_output;\r\nfor (i = 0; i < MAX_LDRIVES; ++i) {\r\nif (!ha->hdr[i].is_logdrv)\r\ncontinue;\r\ndrv_no = i;\r\nj = k = 0;\r\nis_mirr = FALSE;\r\ndo {\r\nTRACE2(("cache_drv_info() drive no %d\n",drv_no));\r\npcdi = (gdth_cdrinfo_str *)buf;\r\ngdtcmd->Service = CACHESERVICE;\r\ngdtcmd->OpCode = GDT_IOCTL;\r\ngdtcmd->u.ioctl.p_param = paddr;\r\ngdtcmd->u.ioctl.param_size = sizeof(gdth_cdrinfo_str);\r\ngdtcmd->u.ioctl.subfunc = CACHE_DRV_INFO;\r\ngdtcmd->u.ioctl.channel = drv_no;\r\nif (gdth_execute(host, gdtcmd, cmnd, 30, NULL) != S_OK)\r\nbreak;\r\npcdi->ld_dtype >>= 16;\r\nj++;\r\nif (pcdi->ld_dtype > 2) {\r\nstrcpy(hrec, "missing");\r\n} else if (pcdi->ld_error & 1) {\r\nstrcpy(hrec, "fault");\r\n} else if (pcdi->ld_error & 2) {\r\nstrcpy(hrec, "invalid");\r\nk++; j--;\r\n} else {\r\nstrcpy(hrec, "ok");\r\n}\r\nif (drv_no == i) {\r\nsize = sprintf(buffer+len,\r\n"\n Number: \t%-2d \tStatus: \t%s\n",\r\ndrv_no, hrec);\r\nlen += size; pos = begin + len;\r\nflag = TRUE;\r\nno_mdrv = pcdi->cd_ldcnt;\r\nif (no_mdrv > 1 || pcdi->ld_slave != -1) {\r\nis_mirr = TRUE;\r\nstrcpy(hrec, "RAID-1");\r\n} else if (pcdi->ld_dtype == 0) {\r\nstrcpy(hrec, "Disk");\r\n} else if (pcdi->ld_dtype == 1) {\r\nstrcpy(hrec, "RAID-0");\r\n} else if (pcdi->ld_dtype == 2) {\r\nstrcpy(hrec, "Chain");\r\n} else {\r\nstrcpy(hrec, "???");\r\n}\r\nsize = sprintf(buffer+len,\r\n" Capacity [MB]:\t%-6d \tType: \t%s\n",\r\npcdi->ld_blkcnt/(1024*1024/pcdi->ld_blksize),\r\nhrec);\r\nlen += size; pos = begin + len;\r\n} else {\r\nsize = sprintf(buffer+len,\r\n" Slave Number: \t%-2d \tStatus: \t%s\n",\r\ndrv_no & 0x7fff, hrec);\r\nlen += size; pos = begin + len;\r\n}\r\ndrv_no = pcdi->ld_slave;\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length) {\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\ngoto stop_output;\r\n}\r\n} while (drv_no != -1);\r\nif (is_mirr) {\r\nsize = sprintf(buffer+len,\r\n" Missing Drv.: \t%-2d \tInvalid Drv.: \t%d\n",\r\nno_mdrv - j - k, k);\r\nlen += size; pos = begin + len;\r\n}\r\nif (!ha->hdr[i].is_arraydrv)\r\nstrcpy(hrec, "--");\r\nelse\r\nsprintf(hrec, "%d", ha->hdr[i].master_no);\r\nsize = sprintf(buffer+len,\r\n" To Array Drv.:\t%s\n", hrec);\r\nlen += size; pos = begin + len;\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length) {\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\ngoto stop_output;\r\n}\r\n}\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\nif (!flag) {\r\nsize = sprintf(buffer+len, "\n --\n");\r\nlen += size; pos = begin + len;\r\n}\r\nsize = sprintf(buffer+len,"\nArray Drives:");\r\nlen += size; pos = begin + len;\r\nflag = FALSE;\r\nbuf = gdth_ioctl_alloc(ha, GDTH_SCRATCH, FALSE, &paddr);\r\nif (!buf)\r\ngoto stop_output;\r\nfor (i = 0; i < MAX_LDRIVES; ++i) {\r\nif (!(ha->hdr[i].is_arraydrv && ha->hdr[i].is_master))\r\ncontinue;\r\nTRACE2(("array_info() drive no %d\n",i));\r\npai = (gdth_arrayinf_str *)buf;\r\ngdtcmd->Service = CACHESERVICE;\r\ngdtcmd->OpCode = GDT_IOCTL;\r\ngdtcmd->u.ioctl.p_param = paddr;\r\ngdtcmd->u.ioctl.param_size = sizeof(gdth_arrayinf_str);\r\ngdtcmd->u.ioctl.subfunc = ARRAY_INFO | LA_CTRL_PATTERN;\r\ngdtcmd->u.ioctl.channel = i;\r\nif (gdth_execute(host, gdtcmd, cmnd, 30, NULL) == S_OK) {\r\nif (pai->ai_state == 0)\r\nstrcpy(hrec, "idle");\r\nelse if (pai->ai_state == 2)\r\nstrcpy(hrec, "build");\r\nelse if (pai->ai_state == 4)\r\nstrcpy(hrec, "ready");\r\nelse if (pai->ai_state == 6)\r\nstrcpy(hrec, "fail");\r\nelse if (pai->ai_state == 8 || pai->ai_state == 10)\r\nstrcpy(hrec, "rebuild");\r\nelse\r\nstrcpy(hrec, "error");\r\nif (pai->ai_ext_state & 0x10)\r\nstrcat(hrec, "/expand");\r\nelse if (pai->ai_ext_state & 0x1)\r\nstrcat(hrec, "/patch");\r\nsize = sprintf(buffer+len,\r\n"\n Number: \t%-2d \tStatus: \t%s\n",\r\ni,hrec);\r\nlen += size; pos = begin + len;\r\nflag = TRUE;\r\nif (pai->ai_type == 0)\r\nstrcpy(hrec, "RAID-0");\r\nelse if (pai->ai_type == 4)\r\nstrcpy(hrec, "RAID-4");\r\nelse if (pai->ai_type == 5)\r\nstrcpy(hrec, "RAID-5");\r\nelse\r\nstrcpy(hrec, "RAID-10");\r\nsize = sprintf(buffer+len,\r\n" Capacity [MB]:\t%-6d \tType: \t%s\n",\r\npai->ai_size/(1024*1024/pai->ai_secsize),\r\nhrec);\r\nlen += size; pos = begin + len;\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length) {\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\ngoto stop_output;\r\n}\r\n}\r\n}\r\ngdth_ioctl_free(ha, GDTH_SCRATCH, buf, paddr);\r\nif (!flag) {\r\nsize = sprintf(buffer+len, "\n --\n");\r\nlen += size; pos = begin + len;\r\n}\r\nsize = sprintf(buffer+len,"\nHost Drives:");\r\nlen += size; pos = begin + len;\r\nflag = FALSE;\r\nbuf = gdth_ioctl_alloc(ha, sizeof(gdth_hget_str), FALSE, &paddr);\r\nif (!buf)\r\ngoto stop_output;\r\nfor (i = 0; i < MAX_LDRIVES; ++i) {\r\nif (!ha->hdr[i].is_logdrv ||\r\n(ha->hdr[i].is_arraydrv && !ha->hdr[i].is_master))\r\ncontinue;\r\nTRACE2(("host_get() drv_no %d\n",i));\r\nphg = (gdth_hget_str *)buf;\r\ngdtcmd->Service = CACHESERVICE;\r\ngdtcmd->OpCode = GDT_IOCTL;\r\ngdtcmd->u.ioctl.p_param = paddr;\r\ngdtcmd->u.ioctl.param_size = sizeof(gdth_hget_str);\r\ngdtcmd->u.ioctl.subfunc = HOST_GET | LA_CTRL_PATTERN;\r\ngdtcmd->u.ioctl.channel = i;\r\nphg->entries = MAX_HDRIVES;\r\nphg->offset = GDTOFFSOF(gdth_hget_str, entry[0]);\r\nif (gdth_execute(host, gdtcmd, cmnd, 30, NULL) == S_OK) {\r\nha->hdr[i].ldr_no = i;\r\nha->hdr[i].rw_attribs = 0;\r\nha->hdr[i].start_sec = 0;\r\n} else {\r\nfor (j = 0; j < phg->entries; ++j) {\r\nk = phg->entry[j].host_drive;\r\nif (k >= MAX_LDRIVES)\r\ncontinue;\r\nha->hdr[k].ldr_no = phg->entry[j].log_drive;\r\nha->hdr[k].rw_attribs = phg->entry[j].rw_attribs;\r\nha->hdr[k].start_sec = phg->entry[j].start_sec;\r\n}\r\n}\r\n}\r\ngdth_ioctl_free(ha, sizeof(gdth_hget_str), buf, paddr);\r\nfor (i = 0; i < MAX_HDRIVES; ++i) {\r\nif (!(ha->hdr[i].present))\r\ncontinue;\r\nsize = sprintf(buffer+len,\r\n"\n Number: \t%-2d \tArr/Log. Drive:\t%d\n",\r\ni, ha->hdr[i].ldr_no);\r\nlen += size; pos = begin + len;\r\nflag = TRUE;\r\nsize = sprintf(buffer+len,\r\n" Capacity [MB]:\t%-6d \tStart Sector: \t%d\n",\r\n(u32)(ha->hdr[i].size/2048), ha->hdr[i].start_sec);\r\nlen += size; pos = begin + len;\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length)\r\ngoto stop_output;\r\n}\r\nif (!flag) {\r\nsize = sprintf(buffer+len, "\n --\n");\r\nlen += size; pos = begin + len;\r\n}\r\n}\r\nsize = sprintf(buffer+len,"\nController Events:\n");\r\nlen += size; pos = begin + len;\r\nfor (id = -1;;) {\r\nid = gdth_read_event(ha, id, estr);\r\nif (estr->event_source == 0)\r\nbreak;\r\nif (estr->event_data.eu.driver.ionode == ha->hanum &&\r\nestr->event_source == ES_ASYNC) {\r\ngdth_log_event(&estr->event_data, hrec);\r\ndo_gettimeofday(&tv);\r\nsec = (int)(tv.tv_sec - estr->first_stamp);\r\nif (sec < 0) sec = 0;\r\nsize = sprintf(buffer+len," date- %02d:%02d:%02d\t%s\n",\r\nsec/3600, sec%3600/60, sec%60, hrec);\r\nlen += size; pos = begin + len;\r\nif (pos < offset) {\r\nlen = 0;\r\nbegin = pos;\r\n}\r\nif (pos > offset + length)\r\ngoto stop_output;\r\n}\r\nif (id == -1)\r\nbreak;\r\n}\r\nstop_output:\r\n*start = buffer +(offset-begin);\r\nlen -= (offset-begin);\r\nif (len > length)\r\nlen = length;\r\nTRACE2(("get_info() len %d pos %d begin %d offset %d length %d size %d\n",\r\nlen,(int)pos,(int)begin,(int)offset,length,size));\r\nrc = len;\r\nfree_fail:\r\nkfree(gdtcmd);\r\nkfree(estr);\r\nreturn rc;\r\n}\r\nstatic char *gdth_ioctl_alloc(gdth_ha_str *ha, int size, int scratch,\r\nu64 *paddr)\r\n{\r\nunsigned long flags;\r\nchar *ret_val;\r\nif (size == 0)\r\nreturn NULL;\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nif (!ha->scratch_busy && size <= GDTH_SCRATCH) {\r\nha->scratch_busy = TRUE;\r\nret_val = ha->pscratch;\r\n*paddr = ha->scratch_phys;\r\n} else if (scratch) {\r\nret_val = NULL;\r\n} else {\r\ndma_addr_t dma_addr;\r\nret_val = pci_alloc_consistent(ha->pdev, size, &dma_addr);\r\n*paddr = dma_addr;\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn ret_val;\r\n}\r\nstatic void gdth_ioctl_free(gdth_ha_str *ha, int size, char *buf, u64 paddr)\r\n{\r\nunsigned long flags;\r\nif (buf == ha->pscratch) {\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nha->scratch_busy = FALSE;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n} else {\r\npci_free_consistent(ha->pdev, size, buf, paddr);\r\n}\r\n}\r\nstatic int gdth_ioctl_check_bin(gdth_ha_str *ha, u16 size)\r\n{\r\nunsigned long flags;\r\nint ret_val;\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nret_val = FALSE;\r\nif (ha->scratch_busy) {\r\nif (((gdth_iord_str *)ha->pscratch)->size == (u32)size)\r\nret_val = TRUE;\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nreturn ret_val;\r\n}\r\nstatic void gdth_wait_completion(gdth_ha_str *ha, int busnum, int id)\r\n{\r\nunsigned long flags;\r\nint i;\r\nScsi_Cmnd *scp;\r\nstruct gdth_cmndinfo *cmndinfo;\r\nu8 b, t;\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\nfor (i = 0; i < GDTH_MAXCMDS; ++i) {\r\nscp = ha->cmd_tab[i].cmnd;\r\ncmndinfo = gdth_cmnd_priv(scp);\r\nb = scp->device->channel;\r\nt = scp->device->id;\r\nif (!SPECIAL_SCP(scp) && t == (u8)id &&\r\nb == (u8)busnum) {\r\ncmndinfo->wait_for_completion = 0;\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\nwhile (!cmndinfo->wait_for_completion)\r\nbarrier();\r\nspin_lock_irqsave(&ha->smp_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->smp_lock, flags);\r\n}
