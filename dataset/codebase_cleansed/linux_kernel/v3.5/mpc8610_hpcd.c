static irqreturn_t mpc8610_sw9_irq(int irq, void *data)\r\n{\r\npr_debug("%s: PIXIS' event (sw9/wakeup) IRQ handled\n", __func__);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init mpc8610_suspend_init(void)\r\n{\r\nint irq;\r\nint ret;\r\nif (!pixis_node)\r\nreturn;\r\nirq = irq_of_parse_and_map(pixis_node, 0);\r\nif (!irq) {\r\npr_err("%s: can't map pixis event IRQ.\n", __func__);\r\nreturn;\r\n}\r\nret = request_irq(irq, mpc8610_sw9_irq, 0, "sw9:wakeup", NULL);\r\nif (ret) {\r\npr_err("%s: can't request pixis event IRQ: %d\n",\r\n__func__, ret);\r\nirq_dispose_mapping(irq);\r\n}\r\nenable_irq_wake(irq);\r\n}\r\nstatic inline void mpc8610_suspend_init(void) { }\r\nstatic int __init mpc8610_declare_of_platform_devices(void)\r\n{\r\nsimple_gpiochip_init("fsl,fpga-pixis-gpio-bank");\r\nmpc8610_suspend_init();\r\nof_platform_bus_probe(NULL, mpc8610_ids, NULL);\r\nreturn 0;\r\n}\r\nu32 mpc8610hpcd_get_pixel_format(enum fsl_diu_monitor_port port,\r\nunsigned int bits_per_pixel)\r\n{\r\nstatic const u32 pixelformat[][3] = {\r\n{\r\nMAKE_AD(3, 0, 2, 1, 3, 8, 8, 8, 8),\r\nMAKE_AD(4, 2, 0, 1, 2, 8, 8, 8, 0),\r\nMAKE_AD(4, 0, 2, 1, 1, 5, 6, 5, 0)\r\n},\r\n{\r\nMAKE_AD(3, 2, 0, 1, 3, 8, 8, 8, 8),\r\nMAKE_AD(4, 0, 2, 1, 2, 8, 8, 8, 0),\r\nMAKE_AD(4, 2, 0, 1, 1, 5, 6, 5, 0)\r\n},\r\n};\r\nunsigned int arch_monitor;\r\narch_monitor =\r\n((*pixis_arch == 0x01) && (port == FSL_DIU_PORT_DVI)) ? 0 : 1;\r\nswitch (bits_per_pixel) {\r\ncase 32:\r\nreturn pixelformat[arch_monitor][0];\r\ncase 24:\r\nreturn pixelformat[arch_monitor][1];\r\ncase 16:\r\nreturn pixelformat[arch_monitor][2];\r\ndefault:\r\npr_err("fsl-diu: unsupported pixel depth %u\n", bits_per_pixel);\r\nreturn 0;\r\n}\r\n}\r\nvoid mpc8610hpcd_set_gamma_table(enum fsl_diu_monitor_port port,\r\nchar *gamma_table_base)\r\n{\r\nint i;\r\nif (port == FSL_DIU_PORT_DLVDS) {\r\nfor (i = 0; i < 256*3; i++)\r\ngamma_table_base[i] = (gamma_table_base[i] << 2) |\r\n((gamma_table_base[i] >> 6) & 0x03);\r\n}\r\n}\r\nvoid mpc8610hpcd_set_monitor_port(enum fsl_diu_monitor_port port)\r\n{\r\nswitch (port) {\r\ncase FSL_DIU_PORT_DVI:\r\nclrsetbits_8(pixis_bdcfg0, PX_BRDCFG0_DIU_MASK,\r\nPX_BRDCFG0_DVISEL | PX_BRDCFG0_DLINK);\r\nbreak;\r\ncase FSL_DIU_PORT_LVDS:\r\nclrsetbits_8(pixis_bdcfg0, PX_BRDCFG0_DIU_MASK,\r\nPX_BRDCFG0_DLINK);\r\nbreak;\r\ncase FSL_DIU_PORT_DLVDS:\r\nclrbits8(pixis_bdcfg0, PX_BRDCFG0_DIU_MASK);\r\nbreak;\r\n}\r\n}\r\nvoid mpc8610hpcd_set_pixel_clock(unsigned int pixclock)\r\n{\r\nstruct device_node *guts_np = NULL;\r\nstruct ccsr_guts __iomem *guts;\r\nunsigned long freq;\r\nu64 temp;\r\nu32 pxclk;\r\nguts_np = of_find_compatible_node(NULL, NULL, "fsl,mpc8610-guts");\r\nif (!guts_np) {\r\npr_err("mpc8610hpcd: missing global utilties device node\n");\r\nreturn;\r\n}\r\nguts = of_iomap(guts_np, 0);\r\nof_node_put(guts_np);\r\nif (!guts) {\r\npr_err("mpc8610hpcd: could not map global utilties device\n");\r\nreturn;\r\n}\r\ntemp = 1000000000000ULL;\r\ndo_div(temp, pixclock);\r\nfreq = temp;\r\npxclk = DIV_ROUND_CLOSEST(fsl_get_sys_freq(), freq) - 1;\r\npxclk = clamp_t(u32, pxclk, 2, 31);\r\nclrbits32(&guts->clkdvdr,\r\nCLKDVDR_PXCKEN | CLKDVDR_PXCKDLY | CLKDVDR_PXCLK_MASK);\r\nsetbits32(&guts->clkdvdr, CLKDVDR_PXCKEN | (pxclk << 16));\r\niounmap(guts);\r\n}\r\nenum fsl_diu_monitor_port\r\nmpc8610hpcd_valid_monitor_port(enum fsl_diu_monitor_port port)\r\n{\r\nreturn port;\r\n}\r\nstatic void __init mpc86xx_hpcd_setup_arch(void)\r\n{\r\nstruct resource r;\r\nstruct device_node *np;\r\nunsigned char *pixis;\r\nif (ppc_md.progress)\r\nppc_md.progress("mpc86xx_hpcd_setup_arch()", 0);\r\n#ifdef CONFIG_PCI\r\nfor_each_node_by_type(np, "pci") {\r\nif (of_device_is_compatible(np, "fsl,mpc8610-pci")\r\n|| of_device_is_compatible(np, "fsl,mpc8641-pcie")) {\r\nstruct resource rsrc;\r\nof_address_to_resource(np, 0, &rsrc);\r\nif ((rsrc.start & 0xfffff) == 0xa000)\r\nfsl_add_bridge(np, 1);\r\nelse\r\nfsl_add_bridge(np, 0);\r\n}\r\n}\r\n#endif\r\n#if defined(CONFIG_FB_FSL_DIU) || defined(CONFIG_FB_FSL_DIU_MODULE)\r\ndiu_ops.get_pixel_format = mpc8610hpcd_get_pixel_format;\r\ndiu_ops.set_gamma_table = mpc8610hpcd_set_gamma_table;\r\ndiu_ops.set_monitor_port = mpc8610hpcd_set_monitor_port;\r\ndiu_ops.set_pixel_clock = mpc8610hpcd_set_pixel_clock;\r\ndiu_ops.valid_monitor_port = mpc8610hpcd_valid_monitor_port;\r\n#endif\r\npixis_node = of_find_compatible_node(NULL, NULL, "fsl,fpga-pixis");\r\nif (pixis_node) {\r\nof_address_to_resource(pixis_node, 0, &r);\r\nof_node_put(pixis_node);\r\npixis = ioremap(r.start, 32);\r\nif (!pixis) {\r\nprintk(KERN_ERR "Err: can't map FPGA cfg register!\n");\r\nreturn;\r\n}\r\npixis_bdcfg0 = pixis + 8;\r\npixis_arch = pixis + 1;\r\n} else\r\nprintk(KERN_ERR "Err: "\r\n"can't find device node 'fsl,fpga-pixis'\n");\r\nprintk("MPC86xx HPCD board from Freescale Semiconductor\n");\r\n}\r\nstatic int __init mpc86xx_hpcd_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "fsl,MPC8610HPCD"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic long __init mpc86xx_time_init(void)\r\n{\r\nunsigned int temp;\r\nmtspr(SPRN_TBWL, 0);\r\nmtspr(SPRN_TBWU, 0);\r\ntemp = mfspr(SPRN_HID0);\r\ntemp |= HID0_TBEN;\r\nmtspr(SPRN_HID0, temp);\r\nasm volatile("isync");\r\nreturn 0;\r\n}
