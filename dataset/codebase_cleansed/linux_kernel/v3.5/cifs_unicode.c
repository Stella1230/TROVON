int\r\ncifs_utf16_bytes(const __le16 *from, int maxbytes,\r\nconst struct nls_table *codepage)\r\n{\r\nint i;\r\nint charlen, outlen = 0;\r\nint maxwords = maxbytes / 2;\r\nchar tmp[NLS_MAX_CHARSET_SIZE];\r\n__u16 ftmp;\r\nfor (i = 0; i < maxwords; i++) {\r\nftmp = get_unaligned_le16(&from[i]);\r\nif (ftmp == 0)\r\nbreak;\r\ncharlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);\r\nif (charlen > 0)\r\noutlen += charlen;\r\nelse\r\noutlen++;\r\n}\r\nreturn outlen;\r\n}\r\nstatic int\r\ncifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,\r\nbool mapchar)\r\n{\r\nint len = 1;\r\nif (!mapchar)\r\ngoto cp_convert;\r\nswitch (src_char) {\r\ncase UNI_COLON:\r\n*target = ':';\r\nbreak;\r\ncase UNI_ASTERISK:\r\n*target = '*';\r\nbreak;\r\ncase UNI_QUESTION:\r\n*target = '?';\r\nbreak;\r\ncase UNI_PIPE:\r\n*target = '|';\r\nbreak;\r\ncase UNI_GRTRTHAN:\r\n*target = '>';\r\nbreak;\r\ncase UNI_LESSTHAN:\r\n*target = '<';\r\nbreak;\r\ndefault:\r\ngoto cp_convert;\r\n}\r\nout:\r\nreturn len;\r\ncp_convert:\r\nlen = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);\r\nif (len <= 0) {\r\n*target = '?';\r\nlen = 1;\r\n}\r\ngoto out;\r\n}\r\nint\r\ncifs_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,\r\nconst struct nls_table *codepage, bool mapchar)\r\n{\r\nint i, charlen, safelen;\r\nint outlen = 0;\r\nint nullsize = nls_nullsize(codepage);\r\nint fromwords = fromlen / 2;\r\nchar tmp[NLS_MAX_CHARSET_SIZE];\r\n__u16 ftmp;\r\nsafelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);\r\nfor (i = 0; i < fromwords; i++) {\r\nftmp = get_unaligned_le16(&from[i]);\r\nif (ftmp == 0)\r\nbreak;\r\nif (outlen >= safelen) {\r\ncharlen = cifs_mapchar(tmp, ftmp, codepage, mapchar);\r\nif ((outlen + charlen) > (tolen - nullsize))\r\nbreak;\r\n}\r\ncharlen = cifs_mapchar(&to[outlen], ftmp, codepage, mapchar);\r\noutlen += charlen;\r\n}\r\nfor (i = 0; i < nullsize; i++)\r\nto[outlen++] = 0;\r\nreturn outlen;\r\n}\r\nint\r\ncifs_strtoUTF16(__le16 *to, const char *from, int len,\r\nconst struct nls_table *codepage)\r\n{\r\nint charlen;\r\nint i;\r\nwchar_t wchar_to;\r\nfor (i = 0; len && *from; i++, from += charlen, len -= charlen) {\r\ncharlen = codepage->char2uni(from, len, &wchar_to);\r\nif (charlen < 1) {\r\ncERROR(1, "strtoUTF16: char2uni of 0x%x returned %d",\r\n*from, charlen);\r\nwchar_to = 0x003f;\r\ncharlen = 1;\r\n}\r\nput_unaligned_le16(wchar_to, &to[i]);\r\n}\r\nput_unaligned_le16(0, &to[i]);\r\nreturn i;\r\n}\r\nchar *\r\ncifs_strndup_from_utf16(const char *src, const int maxlen,\r\nconst bool is_unicode, const struct nls_table *codepage)\r\n{\r\nint len;\r\nchar *dst;\r\nif (is_unicode) {\r\nlen = cifs_utf16_bytes((__le16 *) src, maxlen, codepage);\r\nlen += nls_nullsize(codepage);\r\ndst = kmalloc(len, GFP_KERNEL);\r\nif (!dst)\r\nreturn NULL;\r\ncifs_from_utf16(dst, (__le16 *) src, len, maxlen, codepage,\r\nfalse);\r\n} else {\r\nlen = strnlen(src, maxlen);\r\nlen++;\r\ndst = kmalloc(len, GFP_KERNEL);\r\nif (!dst)\r\nreturn NULL;\r\nstrlcpy(dst, src, len);\r\n}\r\nreturn dst;\r\n}\r\nint\r\ncifsConvertToUTF16(__le16 *target, const char *source, int srclen,\r\nconst struct nls_table *cp, int mapChars)\r\n{\r\nint i, j, charlen;\r\nchar src_char;\r\n__le16 dst_char;\r\nwchar_t tmp;\r\nif (!mapChars)\r\nreturn cifs_strtoUTF16(target, source, PATH_MAX, cp);\r\nfor (i = 0, j = 0; i < srclen; j++) {\r\nsrc_char = source[i];\r\ncharlen = 1;\r\nswitch (src_char) {\r\ncase 0:\r\nput_unaligned(0, &target[j]);\r\ngoto ctoUTF16_out;\r\ncase ':':\r\ndst_char = cpu_to_le16(UNI_COLON);\r\nbreak;\r\ncase '*':\r\ndst_char = cpu_to_le16(UNI_ASTERISK);\r\nbreak;\r\ncase '?':\r\ndst_char = cpu_to_le16(UNI_QUESTION);\r\nbreak;\r\ncase '<':\r\ndst_char = cpu_to_le16(UNI_LESSTHAN);\r\nbreak;\r\ncase '>':\r\ndst_char = cpu_to_le16(UNI_GRTRTHAN);\r\nbreak;\r\ncase '|':\r\ndst_char = cpu_to_le16(UNI_PIPE);\r\nbreak;\r\ndefault:\r\ncharlen = cp->char2uni(source + i, srclen - i, &tmp);\r\ndst_char = cpu_to_le16(tmp);\r\nif (charlen < 1) {\r\ndst_char = cpu_to_le16(0x003f);\r\ncharlen = 1;\r\n}\r\n}\r\ni += charlen;\r\nput_unaligned(dst_char, &target[j]);\r\n}\r\nctoUTF16_out:\r\nreturn i;\r\n}
