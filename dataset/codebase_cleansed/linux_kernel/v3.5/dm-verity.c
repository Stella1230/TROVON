static struct shash_desc *io_hash_desc(struct dm_verity *v, struct dm_verity_io *io)\r\n{\r\nreturn (struct shash_desc *)(io + 1);\r\n}\r\nstatic u8 *io_real_digest(struct dm_verity *v, struct dm_verity_io *io)\r\n{\r\nreturn (u8 *)(io + 1) + v->shash_descsize;\r\n}\r\nstatic u8 *io_want_digest(struct dm_verity *v, struct dm_verity_io *io)\r\n{\r\nreturn (u8 *)(io + 1) + v->shash_descsize + v->digest_size;\r\n}\r\nstatic void dm_bufio_alloc_callback(struct dm_buffer *buf)\r\n{\r\nstruct buffer_aux *aux = dm_bufio_get_aux_data(buf);\r\naux->hash_verified = 0;\r\n}\r\nstatic sector_t verity_map_sector(struct dm_verity *v, sector_t bi_sector)\r\n{\r\nreturn v->data_start + dm_target_offset(v->ti, bi_sector);\r\n}\r\nstatic sector_t verity_position_at_level(struct dm_verity *v, sector_t block,\r\nint level)\r\n{\r\nreturn block >> (level * v->hash_per_block_bits);\r\n}\r\nstatic void verity_hash_at_level(struct dm_verity *v, sector_t block, int level,\r\nsector_t *hash_block, unsigned *offset)\r\n{\r\nsector_t position = verity_position_at_level(v, block, level);\r\nunsigned idx;\r\n*hash_block = v->hash_level_block[level] + (position >> v->hash_per_block_bits);\r\nif (!offset)\r\nreturn;\r\nidx = position & ((1 << v->hash_per_block_bits) - 1);\r\nif (!v->version)\r\n*offset = idx * v->digest_size;\r\nelse\r\n*offset = idx << (v->hash_dev_block_bits - v->hash_per_block_bits);\r\n}\r\nstatic int verity_verify_level(struct dm_verity_io *io, sector_t block,\r\nint level, bool skip_unverified)\r\n{\r\nstruct dm_verity *v = io->v;\r\nstruct dm_buffer *buf;\r\nstruct buffer_aux *aux;\r\nu8 *data;\r\nint r;\r\nsector_t hash_block;\r\nunsigned offset;\r\nverity_hash_at_level(v, block, level, &hash_block, &offset);\r\ndata = dm_bufio_read(v->bufio, hash_block, &buf);\r\nif (unlikely(IS_ERR(data)))\r\nreturn PTR_ERR(data);\r\naux = dm_bufio_get_aux_data(buf);\r\nif (!aux->hash_verified) {\r\nstruct shash_desc *desc;\r\nu8 *result;\r\nif (skip_unverified) {\r\nr = 1;\r\ngoto release_ret_r;\r\n}\r\ndesc = io_hash_desc(v, io);\r\ndesc->tfm = v->tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nr = crypto_shash_init(desc);\r\nif (r < 0) {\r\nDMERR("crypto_shash_init failed: %d", r);\r\ngoto release_ret_r;\r\n}\r\nif (likely(v->version >= 1)) {\r\nr = crypto_shash_update(desc, v->salt, v->salt_size);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\ngoto release_ret_r;\r\n}\r\n}\r\nr = crypto_shash_update(desc, data, 1 << v->hash_dev_block_bits);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\ngoto release_ret_r;\r\n}\r\nif (!v->version) {\r\nr = crypto_shash_update(desc, v->salt, v->salt_size);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\ngoto release_ret_r;\r\n}\r\n}\r\nresult = io_real_digest(v, io);\r\nr = crypto_shash_final(desc, result);\r\nif (r < 0) {\r\nDMERR("crypto_shash_final failed: %d", r);\r\ngoto release_ret_r;\r\n}\r\nif (unlikely(memcmp(result, io_want_digest(v, io), v->digest_size))) {\r\nDMERR_LIMIT("metadata block %llu is corrupted",\r\n(unsigned long long)hash_block);\r\nv->hash_failed = 1;\r\nr = -EIO;\r\ngoto release_ret_r;\r\n} else\r\naux->hash_verified = 1;\r\n}\r\ndata += offset;\r\nmemcpy(io_want_digest(v, io), data, v->digest_size);\r\ndm_bufio_release(buf);\r\nreturn 0;\r\nrelease_ret_r:\r\ndm_bufio_release(buf);\r\nreturn r;\r\n}\r\nstatic int verity_verify_io(struct dm_verity_io *io)\r\n{\r\nstruct dm_verity *v = io->v;\r\nunsigned b;\r\nint i;\r\nunsigned vector = 0, offset = 0;\r\nfor (b = 0; b < io->n_blocks; b++) {\r\nstruct shash_desc *desc;\r\nu8 *result;\r\nint r;\r\nunsigned todo;\r\nif (likely(v->levels)) {\r\nint r = verity_verify_level(io, io->block + b, 0, true);\r\nif (likely(!r))\r\ngoto test_block_hash;\r\nif (r < 0)\r\nreturn r;\r\n}\r\nmemcpy(io_want_digest(v, io), v->root_digest, v->digest_size);\r\nfor (i = v->levels - 1; i >= 0; i--) {\r\nint r = verity_verify_level(io, io->block + b, i, false);\r\nif (unlikely(r))\r\nreturn r;\r\n}\r\ntest_block_hash:\r\ndesc = io_hash_desc(v, io);\r\ndesc->tfm = v->tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nr = crypto_shash_init(desc);\r\nif (r < 0) {\r\nDMERR("crypto_shash_init failed: %d", r);\r\nreturn r;\r\n}\r\nif (likely(v->version >= 1)) {\r\nr = crypto_shash_update(desc, v->salt, v->salt_size);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\nreturn r;\r\n}\r\n}\r\ntodo = 1 << v->data_dev_block_bits;\r\ndo {\r\nstruct bio_vec *bv;\r\nu8 *page;\r\nunsigned len;\r\nBUG_ON(vector >= io->io_vec_size);\r\nbv = &io->io_vec[vector];\r\npage = kmap_atomic(bv->bv_page);\r\nlen = bv->bv_len - offset;\r\nif (likely(len >= todo))\r\nlen = todo;\r\nr = crypto_shash_update(desc,\r\npage + bv->bv_offset + offset, len);\r\nkunmap_atomic(page);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\nreturn r;\r\n}\r\noffset += len;\r\nif (likely(offset == bv->bv_len)) {\r\noffset = 0;\r\nvector++;\r\n}\r\ntodo -= len;\r\n} while (todo);\r\nif (!v->version) {\r\nr = crypto_shash_update(desc, v->salt, v->salt_size);\r\nif (r < 0) {\r\nDMERR("crypto_shash_update failed: %d", r);\r\nreturn r;\r\n}\r\n}\r\nresult = io_real_digest(v, io);\r\nr = crypto_shash_final(desc, result);\r\nif (r < 0) {\r\nDMERR("crypto_shash_final failed: %d", r);\r\nreturn r;\r\n}\r\nif (unlikely(memcmp(result, io_want_digest(v, io), v->digest_size))) {\r\nDMERR_LIMIT("data block %llu is corrupted",\r\n(unsigned long long)(io->block + b));\r\nv->hash_failed = 1;\r\nreturn -EIO;\r\n}\r\n}\r\nBUG_ON(vector != io->io_vec_size);\r\nBUG_ON(offset);\r\nreturn 0;\r\n}\r\nstatic void verity_finish_io(struct dm_verity_io *io, int error)\r\n{\r\nstruct bio *bio = io->bio;\r\nstruct dm_verity *v = io->v;\r\nbio->bi_end_io = io->orig_bi_end_io;\r\nbio->bi_private = io->orig_bi_private;\r\nif (io->io_vec != io->io_vec_inline)\r\nmempool_free(io->io_vec, v->vec_mempool);\r\nmempool_free(io, v->io_mempool);\r\nbio_endio(bio, error);\r\n}\r\nstatic void verity_work(struct work_struct *w)\r\n{\r\nstruct dm_verity_io *io = container_of(w, struct dm_verity_io, work);\r\nverity_finish_io(io, verity_verify_io(io));\r\n}\r\nstatic void verity_end_io(struct bio *bio, int error)\r\n{\r\nstruct dm_verity_io *io = bio->bi_private;\r\nif (error) {\r\nverity_finish_io(io, error);\r\nreturn;\r\n}\r\nINIT_WORK(&io->work, verity_work);\r\nqueue_work(io->v->verify_wq, &io->work);\r\n}\r\nstatic void verity_prefetch_io(struct dm_verity *v, struct dm_verity_io *io)\r\n{\r\nint i;\r\nfor (i = v->levels - 2; i >= 0; i--) {\r\nsector_t hash_block_start;\r\nsector_t hash_block_end;\r\nverity_hash_at_level(v, io->block, i, &hash_block_start, NULL);\r\nverity_hash_at_level(v, io->block + io->n_blocks - 1, i, &hash_block_end, NULL);\r\nif (!i) {\r\nunsigned cluster = *(volatile unsigned *)&dm_verity_prefetch_cluster;\r\ncluster >>= v->data_dev_block_bits;\r\nif (unlikely(!cluster))\r\ngoto no_prefetch_cluster;\r\nif (unlikely(cluster & (cluster - 1)))\r\ncluster = 1 << (fls(cluster) - 1);\r\nhash_block_start &= ~(sector_t)(cluster - 1);\r\nhash_block_end |= cluster - 1;\r\nif (unlikely(hash_block_end >= v->hash_blocks))\r\nhash_block_end = v->hash_blocks - 1;\r\n}\r\nno_prefetch_cluster:\r\ndm_bufio_prefetch(v->bufio, hash_block_start,\r\nhash_block_end - hash_block_start + 1);\r\n}\r\n}\r\nstatic int verity_map(struct dm_target *ti, struct bio *bio,\r\nunion map_info *map_context)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nstruct dm_verity_io *io;\r\nbio->bi_bdev = v->data_dev->bdev;\r\nbio->bi_sector = verity_map_sector(v, bio->bi_sector);\r\nif (((unsigned)bio->bi_sector | bio_sectors(bio)) &\r\n((1 << (v->data_dev_block_bits - SECTOR_SHIFT)) - 1)) {\r\nDMERR_LIMIT("unaligned io");\r\nreturn -EIO;\r\n}\r\nif ((bio->bi_sector + bio_sectors(bio)) >>\r\n(v->data_dev_block_bits - SECTOR_SHIFT) > v->data_blocks) {\r\nDMERR_LIMIT("io out of range");\r\nreturn -EIO;\r\n}\r\nif (bio_data_dir(bio) == WRITE)\r\nreturn -EIO;\r\nio = mempool_alloc(v->io_mempool, GFP_NOIO);\r\nio->v = v;\r\nio->bio = bio;\r\nio->orig_bi_end_io = bio->bi_end_io;\r\nio->orig_bi_private = bio->bi_private;\r\nio->block = bio->bi_sector >> (v->data_dev_block_bits - SECTOR_SHIFT);\r\nio->n_blocks = bio->bi_size >> v->data_dev_block_bits;\r\nbio->bi_end_io = verity_end_io;\r\nbio->bi_private = io;\r\nio->io_vec_size = bio->bi_vcnt - bio->bi_idx;\r\nif (io->io_vec_size < DM_VERITY_IO_VEC_INLINE)\r\nio->io_vec = io->io_vec_inline;\r\nelse\r\nio->io_vec = mempool_alloc(v->vec_mempool, GFP_NOIO);\r\nmemcpy(io->io_vec, bio_iovec(bio),\r\nio->io_vec_size * sizeof(struct bio_vec));\r\nverity_prefetch_io(v, io);\r\ngeneric_make_request(bio);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nstatic int verity_status(struct dm_target *ti, status_type_t type,\r\nchar *result, unsigned maxlen)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nunsigned sz = 0;\r\nunsigned x;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%c", v->hash_failed ? 'C' : 'V');\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%u %s %s %u %u %llu %llu %s ",\r\nv->version,\r\nv->data_dev->name,\r\nv->hash_dev->name,\r\n1 << v->data_dev_block_bits,\r\n1 << v->hash_dev_block_bits,\r\n(unsigned long long)v->data_blocks,\r\n(unsigned long long)v->hash_start,\r\nv->alg_name\r\n);\r\nfor (x = 0; x < v->digest_size; x++)\r\nDMEMIT("%02x", v->root_digest[x]);\r\nDMEMIT(" ");\r\nif (!v->salt_size)\r\nDMEMIT("-");\r\nelse\r\nfor (x = 0; x < v->salt_size; x++)\r\nDMEMIT("%02x", v->salt[x]);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int verity_ioctl(struct dm_target *ti, unsigned cmd,\r\nunsigned long arg)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nint r = 0;\r\nif (v->data_start ||\r\nti->len != i_size_read(v->data_dev->bdev->bd_inode) >> SECTOR_SHIFT)\r\nr = scsi_verify_blk_ioctl(NULL, cmd);\r\nreturn r ? : __blkdev_driver_ioctl(v->data_dev->bdev, v->data_dev->mode,\r\ncmd, arg);\r\n}\r\nstatic int verity_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\r\nstruct bio_vec *biovec, int max_size)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nstruct request_queue *q = bdev_get_queue(v->data_dev->bdev);\r\nif (!q->merge_bvec_fn)\r\nreturn max_size;\r\nbvm->bi_bdev = v->data_dev->bdev;\r\nbvm->bi_sector = verity_map_sector(v, bvm->bi_sector);\r\nreturn min(max_size, q->merge_bvec_fn(q, bvm, biovec));\r\n}\r\nstatic int verity_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nreturn fn(ti, v->data_dev, v->data_start, ti->len, data);\r\n}\r\nstatic void verity_io_hints(struct dm_target *ti, struct queue_limits *limits)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nif (limits->logical_block_size < 1 << v->data_dev_block_bits)\r\nlimits->logical_block_size = 1 << v->data_dev_block_bits;\r\nif (limits->physical_block_size < 1 << v->data_dev_block_bits)\r\nlimits->physical_block_size = 1 << v->data_dev_block_bits;\r\nblk_limits_io_min(limits, limits->logical_block_size);\r\n}\r\nstatic void verity_dtr(struct dm_target *ti)\r\n{\r\nstruct dm_verity *v = ti->private;\r\nif (v->verify_wq)\r\ndestroy_workqueue(v->verify_wq);\r\nif (v->vec_mempool)\r\nmempool_destroy(v->vec_mempool);\r\nif (v->io_mempool)\r\nmempool_destroy(v->io_mempool);\r\nif (v->bufio)\r\ndm_bufio_client_destroy(v->bufio);\r\nkfree(v->salt);\r\nkfree(v->root_digest);\r\nif (v->tfm)\r\ncrypto_free_shash(v->tfm);\r\nkfree(v->alg_name);\r\nif (v->hash_dev)\r\ndm_put_device(ti, v->hash_dev);\r\nif (v->data_dev)\r\ndm_put_device(ti, v->data_dev);\r\nkfree(v);\r\n}\r\nstatic int verity_ctr(struct dm_target *ti, unsigned argc, char **argv)\r\n{\r\nstruct dm_verity *v;\r\nunsigned num;\r\nunsigned long long num_ll;\r\nint r;\r\nint i;\r\nsector_t hash_position;\r\nchar dummy;\r\nv = kzalloc(sizeof(struct dm_verity), GFP_KERNEL);\r\nif (!v) {\r\nti->error = "Cannot allocate verity structure";\r\nreturn -ENOMEM;\r\n}\r\nti->private = v;\r\nv->ti = ti;\r\nif ((dm_table_get_mode(ti->table) & ~FMODE_READ)) {\r\nti->error = "Device must be readonly";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (argc != 10) {\r\nti->error = "Invalid argument count: exactly 10 arguments required";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (sscanf(argv[0], "%d%c", &num, &dummy) != 1 ||\r\nnum < 0 || num > 1) {\r\nti->error = "Invalid version";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->version = num;\r\nr = dm_get_device(ti, argv[1], FMODE_READ, &v->data_dev);\r\nif (r) {\r\nti->error = "Data device lookup failed";\r\ngoto bad;\r\n}\r\nr = dm_get_device(ti, argv[2], FMODE_READ, &v->hash_dev);\r\nif (r) {\r\nti->error = "Data device lookup failed";\r\ngoto bad;\r\n}\r\nif (sscanf(argv[3], "%u%c", &num, &dummy) != 1 ||\r\n!num || (num & (num - 1)) ||\r\nnum < bdev_logical_block_size(v->data_dev->bdev) ||\r\nnum > PAGE_SIZE) {\r\nti->error = "Invalid data device block size";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->data_dev_block_bits = ffs(num) - 1;\r\nif (sscanf(argv[4], "%u%c", &num, &dummy) != 1 ||\r\n!num || (num & (num - 1)) ||\r\nnum < bdev_logical_block_size(v->hash_dev->bdev) ||\r\nnum > INT_MAX) {\r\nti->error = "Invalid hash device block size";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->hash_dev_block_bits = ffs(num) - 1;\r\nif (sscanf(argv[5], "%llu%c", &num_ll, &dummy) != 1 ||\r\nnum_ll << (v->data_dev_block_bits - SECTOR_SHIFT) !=\r\n(sector_t)num_ll << (v->data_dev_block_bits - SECTOR_SHIFT)) {\r\nti->error = "Invalid data blocks";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->data_blocks = num_ll;\r\nif (ti->len > (v->data_blocks << (v->data_dev_block_bits - SECTOR_SHIFT))) {\r\nti->error = "Data device is too small";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (sscanf(argv[6], "%llu%c", &num_ll, &dummy) != 1 ||\r\nnum_ll << (v->hash_dev_block_bits - SECTOR_SHIFT) !=\r\n(sector_t)num_ll << (v->hash_dev_block_bits - SECTOR_SHIFT)) {\r\nti->error = "Invalid hash start";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->hash_start = num_ll;\r\nv->alg_name = kstrdup(argv[7], GFP_KERNEL);\r\nif (!v->alg_name) {\r\nti->error = "Cannot allocate algorithm name";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nv->tfm = crypto_alloc_shash(v->alg_name, 0, 0);\r\nif (IS_ERR(v->tfm)) {\r\nti->error = "Cannot initialize hash function";\r\nr = PTR_ERR(v->tfm);\r\nv->tfm = NULL;\r\ngoto bad;\r\n}\r\nv->digest_size = crypto_shash_digestsize(v->tfm);\r\nif ((1 << v->hash_dev_block_bits) < v->digest_size * 2) {\r\nti->error = "Digest size too big";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nv->shash_descsize =\r\nsizeof(struct shash_desc) + crypto_shash_descsize(v->tfm);\r\nv->root_digest = kmalloc(v->digest_size, GFP_KERNEL);\r\nif (!v->root_digest) {\r\nti->error = "Cannot allocate root digest";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nif (strlen(argv[8]) != v->digest_size * 2 ||\r\nhex2bin(v->root_digest, argv[8], v->digest_size)) {\r\nti->error = "Invalid root digest";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\nif (strcmp(argv[9], "-")) {\r\nv->salt_size = strlen(argv[9]) / 2;\r\nv->salt = kmalloc(v->salt_size, GFP_KERNEL);\r\nif (!v->salt) {\r\nti->error = "Cannot allocate salt";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nif (strlen(argv[9]) != v->salt_size * 2 ||\r\nhex2bin(v->salt, argv[9], v->salt_size)) {\r\nti->error = "Invalid salt";\r\nr = -EINVAL;\r\ngoto bad;\r\n}\r\n}\r\nv->hash_per_block_bits =\r\nfls((1 << v->hash_dev_block_bits) / v->digest_size) - 1;\r\nv->levels = 0;\r\nif (v->data_blocks)\r\nwhile (v->hash_per_block_bits * v->levels < 64 &&\r\n(unsigned long long)(v->data_blocks - 1) >>\r\n(v->hash_per_block_bits * v->levels))\r\nv->levels++;\r\nif (v->levels > DM_VERITY_MAX_LEVELS) {\r\nti->error = "Too many tree levels";\r\nr = -E2BIG;\r\ngoto bad;\r\n}\r\nhash_position = v->hash_start;\r\nfor (i = v->levels - 1; i >= 0; i--) {\r\nsector_t s;\r\nv->hash_level_block[i] = hash_position;\r\ns = verity_position_at_level(v, v->data_blocks, i);\r\ns = (s >> v->hash_per_block_bits) +\r\n!!(s & ((1 << v->hash_per_block_bits) - 1));\r\nif (hash_position + s < hash_position) {\r\nti->error = "Hash device offset overflow";\r\nr = -E2BIG;\r\ngoto bad;\r\n}\r\nhash_position += s;\r\n}\r\nv->hash_blocks = hash_position;\r\nv->bufio = dm_bufio_client_create(v->hash_dev->bdev,\r\n1 << v->hash_dev_block_bits, 1, sizeof(struct buffer_aux),\r\ndm_bufio_alloc_callback, NULL);\r\nif (IS_ERR(v->bufio)) {\r\nti->error = "Cannot initialize dm-bufio";\r\nr = PTR_ERR(v->bufio);\r\nv->bufio = NULL;\r\ngoto bad;\r\n}\r\nif (dm_bufio_get_device_size(v->bufio) < v->hash_blocks) {\r\nti->error = "Hash device is too small";\r\nr = -E2BIG;\r\ngoto bad;\r\n}\r\nv->io_mempool = mempool_create_kmalloc_pool(DM_VERITY_MEMPOOL_SIZE,\r\nsizeof(struct dm_verity_io) + v->shash_descsize + v->digest_size * 2);\r\nif (!v->io_mempool) {\r\nti->error = "Cannot allocate io mempool";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nv->vec_mempool = mempool_create_kmalloc_pool(DM_VERITY_MEMPOOL_SIZE,\r\nBIO_MAX_PAGES * sizeof(struct bio_vec));\r\nif (!v->vec_mempool) {\r\nti->error = "Cannot allocate vector mempool";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nv->verify_wq = alloc_workqueue("kverityd", WQ_CPU_INTENSIVE | WQ_MEM_RECLAIM | WQ_UNBOUND, num_online_cpus());\r\nif (!v->verify_wq) {\r\nti->error = "Cannot allocate workqueue";\r\nr = -ENOMEM;\r\ngoto bad;\r\n}\r\nreturn 0;\r\nbad:\r\nverity_dtr(ti);\r\nreturn r;\r\n}\r\nstatic int __init dm_verity_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&verity_target);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nreturn r;\r\n}\r\nstatic void __exit dm_verity_exit(void)\r\n{\r\ndm_unregister_target(&verity_target);\r\n}
