static void omap_wdt_ping(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\nwhile ((__raw_readl(base + OMAP_WATCHDOG_WPS)) & 0x08)\r\ncpu_relax();\r\nwdt_trgr_pattern = ~wdt_trgr_pattern;\r\n__raw_writel(wdt_trgr_pattern, (base + OMAP_WATCHDOG_TGR));\r\nwhile ((__raw_readl(base + OMAP_WATCHDOG_WPS)) & 0x08)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_enable(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\n__raw_writel(0xBBBB, base + OMAP_WATCHDOG_SPR);\r\nwhile ((__raw_readl(base + OMAP_WATCHDOG_WPS)) & 0x10)\r\ncpu_relax();\r\n__raw_writel(0x4444, base + OMAP_WATCHDOG_SPR);\r\nwhile ((__raw_readl(base + OMAP_WATCHDOG_WPS)) & 0x10)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_disable(struct omap_wdt_dev *wdev)\r\n{\r\nvoid __iomem *base = wdev->base;\r\n__raw_writel(0xAAAA, base + OMAP_WATCHDOG_SPR);\r\nwhile (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x10)\r\ncpu_relax();\r\n__raw_writel(0x5555, base + OMAP_WATCHDOG_SPR);\r\nwhile (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x10)\r\ncpu_relax();\r\n}\r\nstatic void omap_wdt_adjust_timeout(unsigned new_timeout)\r\n{\r\nif (new_timeout < TIMER_MARGIN_MIN)\r\nnew_timeout = TIMER_MARGIN_DEFAULT;\r\nif (new_timeout > TIMER_MARGIN_MAX)\r\nnew_timeout = TIMER_MARGIN_MAX;\r\ntimer_margin = new_timeout;\r\n}\r\nstatic void omap_wdt_set_timeout(struct omap_wdt_dev *wdev)\r\n{\r\nu32 pre_margin = GET_WLDR_VAL(timer_margin);\r\nvoid __iomem *base = wdev->base;\r\npm_runtime_get_sync(wdev->dev);\r\nwhile (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x04)\r\ncpu_relax();\r\n__raw_writel(pre_margin, base + OMAP_WATCHDOG_LDR);\r\nwhile (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x04)\r\ncpu_relax();\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nstatic int omap_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);\r\nvoid __iomem *base = wdev->base;\r\nif (test_and_set_bit(1, (unsigned long *)&(wdev->omap_wdt_users)))\r\nreturn -EBUSY;\r\npm_runtime_get_sync(wdev->dev);\r\nwhile (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)\r\ncpu_relax();\r\n__raw_writel((1 << 5) | (PTV << 2), base + OMAP_WATCHDOG_CNTRL);\r\nwhile (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)\r\ncpu_relax();\r\nfile->private_data = (void *) wdev;\r\nomap_wdt_set_timeout(wdev);\r\nomap_wdt_ping(wdev);\r\nomap_wdt_enable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int omap_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nstruct omap_wdt_dev *wdev = file->private_data;\r\n#ifndef CONFIG_WATCHDOG_NOWAYOUT\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n#else\r\npr_crit("Unexpected close, not stopping!\n");\r\n#endif\r\nwdev->omap_wdt_users = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t omap_wdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct omap_wdt_dev *wdev = file->private_data;\r\nif (len) {\r\npm_runtime_get_sync(wdev->dev);\r\nspin_lock(&wdt_lock);\r\nomap_wdt_ping(wdev);\r\nspin_unlock(&wdt_lock);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nreturn len;\r\n}\r\nstatic long omap_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct omap_wdt_dev *wdev;\r\nint new_margin;\r\nstatic const struct watchdog_info ident = {\r\n.identity = "OMAP Watchdog",\r\n.options = WDIOF_SETTIMEOUT,\r\n.firmware_version = 0,\r\n};\r\nwdev = file->private_data;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user((struct watchdog_info __user *)arg, &ident,\r\nsizeof(ident));\r\ncase WDIOC_GETSTATUS:\r\nreturn put_user(0, (int __user *)arg);\r\ncase WDIOC_GETBOOTSTATUS:\r\nif (cpu_is_omap16xx())\r\nreturn put_user(__raw_readw(ARM_SYSST),\r\n(int __user *)arg);\r\nif (cpu_is_omap24xx())\r\nreturn put_user(omap_prcm_get_reset_sources(),\r\n(int __user *)arg);\r\nreturn put_user(0, (int __user *)arg);\r\ncase WDIOC_KEEPALIVE:\r\npm_runtime_get_sync(wdev->dev);\r\nspin_lock(&wdt_lock);\r\nomap_wdt_ping(wdev);\r\nspin_unlock(&wdt_lock);\r\npm_runtime_put_sync(wdev->dev);\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_margin, (int __user *)arg))\r\nreturn -EFAULT;\r\nomap_wdt_adjust_timeout(new_margin);\r\npm_runtime_get_sync(wdev->dev);\r\nspin_lock(&wdt_lock);\r\nomap_wdt_disable(wdev);\r\nomap_wdt_set_timeout(wdev);\r\nomap_wdt_enable(wdev);\r\nomap_wdt_ping(wdev);\r\nspin_unlock(&wdt_lock);\r\npm_runtime_put_sync(wdev->dev);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(timer_margin, (int __user *)arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int __devinit omap_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res, *mem;\r\nstruct omap_wdt_dev *wdev;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENOENT;\r\ngoto err_get_resource;\r\n}\r\nif (omap_wdt_dev) {\r\nret = -EBUSY;\r\ngoto err_busy;\r\n}\r\nmem = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (!mem) {\r\nret = -EBUSY;\r\ngoto err_busy;\r\n}\r\nwdev = kzalloc(sizeof(struct omap_wdt_dev), GFP_KERNEL);\r\nif (!wdev) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\nwdev->omap_wdt_users = 0;\r\nwdev->mem = mem;\r\nwdev->dev = &pdev->dev;\r\nwdev->base = ioremap(res->start, resource_size(res));\r\nif (!wdev->base) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nplatform_set_drvdata(pdev, wdev);\r\npm_runtime_enable(wdev->dev);\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_disable(wdev);\r\nomap_wdt_adjust_timeout(timer_margin);\r\nwdev->omap_wdt_miscdev.parent = &pdev->dev;\r\nwdev->omap_wdt_miscdev.minor = WATCHDOG_MINOR;\r\nwdev->omap_wdt_miscdev.name = "watchdog";\r\nwdev->omap_wdt_miscdev.fops = &omap_wdt_fops;\r\nret = misc_register(&(wdev->omap_wdt_miscdev));\r\nif (ret)\r\ngoto err_misc;\r\npr_info("OMAP Watchdog Timer Rev 0x%02x: initial timeout %d sec\n",\r\n__raw_readl(wdev->base + OMAP_WATCHDOG_REV) & 0xFF,\r\ntimer_margin);\r\npm_runtime_put_sync(wdev->dev);\r\nomap_wdt_dev = pdev;\r\nreturn 0;\r\nerr_misc:\r\npm_runtime_disable(wdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(wdev->base);\r\nerr_ioremap:\r\nwdev->base = NULL;\r\nkfree(wdev);\r\nerr_kzalloc:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_busy:\r\nerr_get_resource:\r\nreturn ret;\r\n}\r\nstatic void omap_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nif (wdev->omap_wdt_users) {\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\n}\r\nstatic int __devexit omap_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npm_runtime_disable(wdev->dev);\r\nif (!res)\r\nreturn -ENOENT;\r\nmisc_deregister(&(wdev->omap_wdt_miscdev));\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(wdev->base);\r\nkfree(wdev);\r\nomap_wdt_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nif (wdev->omap_wdt_users) {\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_disable(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_wdt_resume(struct platform_device *pdev)\r\n{\r\nstruct omap_wdt_dev *wdev = platform_get_drvdata(pdev);\r\nif (wdev->omap_wdt_users) {\r\npm_runtime_get_sync(wdev->dev);\r\nomap_wdt_enable(wdev);\r\nomap_wdt_ping(wdev);\r\npm_runtime_put_sync(wdev->dev);\r\n}\r\nreturn 0;\r\n}
