static inline struct tiny_spi *tiny_spi_to_hw(struct spi_device *sdev)\r\n{\r\nreturn spi_master_get_devdata(sdev->master);\r\n}\r\nstatic unsigned int tiny_spi_baud(struct spi_device *spi, unsigned int hz)\r\n{\r\nstruct tiny_spi *hw = tiny_spi_to_hw(spi);\r\nreturn min(DIV_ROUND_UP(hw->freq, hz * 2), (1U << hw->baudwidth)) - 1;\r\n}\r\nstatic void tiny_spi_chipselect(struct spi_device *spi, int is_active)\r\n{\r\nstruct tiny_spi *hw = tiny_spi_to_hw(spi);\r\nif (hw->gpio_cs_count) {\r\ngpio_set_value(hw->gpio_cs[spi->chip_select],\r\n(spi->mode & SPI_CS_HIGH) ? is_active : !is_active);\r\n}\r\n}\r\nstatic int tiny_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct tiny_spi *hw = tiny_spi_to_hw(spi);\r\nunsigned int baud = hw->baud;\r\nif (t) {\r\nif (t->speed_hz && t->speed_hz != hw->speed_hz)\r\nbaud = tiny_spi_baud(spi, t->speed_hz);\r\n}\r\nwritel(baud, hw->base + TINY_SPI_BAUD);\r\nwritel(hw->mode, hw->base + TINY_SPI_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int tiny_spi_setup(struct spi_device *spi)\r\n{\r\nstruct tiny_spi *hw = tiny_spi_to_hw(spi);\r\nif (spi->max_speed_hz != hw->speed_hz) {\r\nhw->speed_hz = spi->max_speed_hz;\r\nhw->baud = tiny_spi_baud(spi, hw->speed_hz);\r\n}\r\nhw->mode = spi->mode & (SPI_CPOL | SPI_CPHA);\r\nreturn 0;\r\n}\r\nstatic inline void tiny_spi_wait_txr(struct tiny_spi *hw)\r\n{\r\nwhile (!(readb(hw->base + TINY_SPI_STATUS) &\r\nTINY_SPI_STATUS_TXR))\r\ncpu_relax();\r\n}\r\nstatic inline void tiny_spi_wait_txe(struct tiny_spi *hw)\r\n{\r\nwhile (!(readb(hw->base + TINY_SPI_STATUS) &\r\nTINY_SPI_STATUS_TXE))\r\ncpu_relax();\r\n}\r\nstatic int tiny_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct tiny_spi *hw = tiny_spi_to_hw(spi);\r\nconst u8 *txp = t->tx_buf;\r\nu8 *rxp = t->rx_buf;\r\nunsigned int i;\r\nif (hw->irq >= 0) {\r\nhw->len = t->len;\r\nhw->txp = t->tx_buf;\r\nhw->rxp = t->rx_buf;\r\nhw->txc = 0;\r\nhw->rxc = 0;\r\nif (t->len > 1) {\r\nwriteb(hw->txp ? *hw->txp++ : 0,\r\nhw->base + TINY_SPI_TXDATA);\r\nhw->txc++;\r\nwriteb(hw->txp ? *hw->txp++ : 0,\r\nhw->base + TINY_SPI_TXDATA);\r\nhw->txc++;\r\nwriteb(TINY_SPI_STATUS_TXR, hw->base + TINY_SPI_STATUS);\r\n} else {\r\nwriteb(hw->txp ? *hw->txp++ : 0,\r\nhw->base + TINY_SPI_TXDATA);\r\nhw->txc++;\r\nwriteb(TINY_SPI_STATUS_TXE, hw->base + TINY_SPI_STATUS);\r\n}\r\nwait_for_completion(&hw->done);\r\n} else if (txp && rxp) {\r\nwriteb(*txp++, hw->base + TINY_SPI_TXDATA);\r\nif (t->len > 1) {\r\nwriteb(*txp++, hw->base + TINY_SPI_TXDATA);\r\nfor (i = 2; i < t->len; i++) {\r\nu8 rx, tx = *txp++;\r\ntiny_spi_wait_txr(hw);\r\nrx = readb(hw->base + TINY_SPI_TXDATA);\r\nwriteb(tx, hw->base + TINY_SPI_TXDATA);\r\n*rxp++ = rx;\r\n}\r\ntiny_spi_wait_txr(hw);\r\n*rxp++ = readb(hw->base + TINY_SPI_TXDATA);\r\n}\r\ntiny_spi_wait_txe(hw);\r\n*rxp++ = readb(hw->base + TINY_SPI_RXDATA);\r\n} else if (rxp) {\r\nwriteb(0, hw->base + TINY_SPI_TXDATA);\r\nif (t->len > 1) {\r\nwriteb(0,\r\nhw->base + TINY_SPI_TXDATA);\r\nfor (i = 2; i < t->len; i++) {\r\nu8 rx;\r\ntiny_spi_wait_txr(hw);\r\nrx = readb(hw->base + TINY_SPI_TXDATA);\r\nwriteb(0, hw->base + TINY_SPI_TXDATA);\r\n*rxp++ = rx;\r\n}\r\ntiny_spi_wait_txr(hw);\r\n*rxp++ = readb(hw->base + TINY_SPI_TXDATA);\r\n}\r\ntiny_spi_wait_txe(hw);\r\n*rxp++ = readb(hw->base + TINY_SPI_RXDATA);\r\n} else if (txp) {\r\nwriteb(*txp++, hw->base + TINY_SPI_TXDATA);\r\nif (t->len > 1) {\r\nwriteb(*txp++, hw->base + TINY_SPI_TXDATA);\r\nfor (i = 2; i < t->len; i++) {\r\nu8 tx = *txp++;\r\ntiny_spi_wait_txr(hw);\r\nwriteb(tx, hw->base + TINY_SPI_TXDATA);\r\n}\r\n}\r\ntiny_spi_wait_txe(hw);\r\n} else {\r\nwriteb(0, hw->base + TINY_SPI_TXDATA);\r\nif (t->len > 1) {\r\nwriteb(0, hw->base + TINY_SPI_TXDATA);\r\nfor (i = 2; i < t->len; i++) {\r\ntiny_spi_wait_txr(hw);\r\nwriteb(0, hw->base + TINY_SPI_TXDATA);\r\n}\r\n}\r\ntiny_spi_wait_txe(hw);\r\n}\r\nreturn t->len;\r\n}\r\nstatic irqreturn_t tiny_spi_irq(int irq, void *dev)\r\n{\r\nstruct tiny_spi *hw = dev;\r\nwriteb(0, hw->base + TINY_SPI_STATUS);\r\nif (hw->rxc + 1 == hw->len) {\r\nif (hw->rxp)\r\n*hw->rxp++ = readb(hw->base + TINY_SPI_RXDATA);\r\nhw->rxc++;\r\ncomplete(&hw->done);\r\n} else {\r\nif (hw->rxp)\r\n*hw->rxp++ = readb(hw->base + TINY_SPI_TXDATA);\r\nhw->rxc++;\r\nif (hw->txc < hw->len) {\r\nwriteb(hw->txp ? *hw->txp++ : 0,\r\nhw->base + TINY_SPI_TXDATA);\r\nhw->txc++;\r\nwriteb(TINY_SPI_STATUS_TXR,\r\nhw->base + TINY_SPI_STATUS);\r\n} else {\r\nwriteb(TINY_SPI_STATUS_TXE,\r\nhw->base + TINY_SPI_STATUS);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit tiny_spi_of_probe(struct platform_device *pdev)\r\n{\r\nstruct tiny_spi *hw = platform_get_drvdata(pdev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nunsigned int i;\r\nconst __be32 *val;\r\nint len;\r\nif (!np)\r\nreturn 0;\r\nhw->gpio_cs_count = of_gpio_count(np);\r\nif (hw->gpio_cs_count) {\r\nhw->gpio_cs = devm_kzalloc(&pdev->dev,\r\nhw->gpio_cs_count * sizeof(unsigned int),\r\nGFP_KERNEL);\r\nif (!hw->gpio_cs)\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < hw->gpio_cs_count; i++) {\r\nhw->gpio_cs[i] = of_get_gpio_flags(np, i, NULL);\r\nif (hw->gpio_cs[i] < 0)\r\nreturn -ENODEV;\r\n}\r\nhw->bitbang.master->dev.of_node = pdev->dev.of_node;\r\nval = of_get_property(pdev->dev.of_node,\r\n"clock-frequency", &len);\r\nif (val && len >= sizeof(__be32))\r\nhw->freq = be32_to_cpup(val);\r\nval = of_get_property(pdev->dev.of_node, "baud-width", &len);\r\nif (val && len >= sizeof(__be32))\r\nhw->baudwidth = be32_to_cpup(val);\r\nreturn 0;\r\n}\r\nstatic int __devinit tiny_spi_of_probe(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devinit tiny_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct tiny_spi_platform_data *platp = pdev->dev.platform_data;\r\nstruct tiny_spi *hw;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nunsigned int i;\r\nint err = -ENODEV;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct tiny_spi));\r\nif (!master)\r\nreturn err;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = 255;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->setup = tiny_spi_setup;\r\nhw = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, hw);\r\nhw->bitbang.master = spi_master_get(master);\r\nif (!hw->bitbang.master)\r\nreturn err;\r\nhw->bitbang.setup_transfer = tiny_spi_setup_transfer;\r\nhw->bitbang.chipselect = tiny_spi_chipselect;\r\nhw->bitbang.txrx_bufs = tiny_spi_txrx_bufs;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\ngoto exit_busy;\r\nif (!devm_request_mem_region(&pdev->dev, res->start, resource_size(res),\r\npdev->name))\r\ngoto exit_busy;\r\nhw->base = devm_ioremap_nocache(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (!hw->base)\r\ngoto exit_busy;\r\nhw->irq = platform_get_irq(pdev, 0);\r\nif (hw->irq >= 0) {\r\ninit_completion(&hw->done);\r\nerr = devm_request_irq(&pdev->dev, hw->irq, tiny_spi_irq, 0,\r\npdev->name, hw);\r\nif (err)\r\ngoto exit;\r\n}\r\nif (platp) {\r\nhw->gpio_cs_count = platp->gpio_cs_count;\r\nhw->gpio_cs = platp->gpio_cs;\r\nif (platp->gpio_cs_count && !platp->gpio_cs)\r\ngoto exit_busy;\r\nhw->freq = platp->freq;\r\nhw->baudwidth = platp->baudwidth;\r\n} else {\r\nerr = tiny_spi_of_probe(pdev);\r\nif (err)\r\ngoto exit;\r\n}\r\nfor (i = 0; i < hw->gpio_cs_count; i++) {\r\nerr = gpio_request(hw->gpio_cs[i], dev_name(&pdev->dev));\r\nif (err)\r\ngoto exit_gpio;\r\ngpio_direction_output(hw->gpio_cs[i], 1);\r\n}\r\nhw->bitbang.master->num_chipselect = max(1U, hw->gpio_cs_count);\r\nerr = spi_bitbang_start(&hw->bitbang);\r\nif (err)\r\ngoto exit;\r\ndev_info(&pdev->dev, "base %p, irq %d\n", hw->base, hw->irq);\r\nreturn 0;\r\nexit_gpio:\r\nwhile (i-- > 0)\r\ngpio_free(hw->gpio_cs[i]);\r\nexit_busy:\r\nerr = -EBUSY;\r\nexit:\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int __devexit tiny_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct tiny_spi *hw = platform_get_drvdata(pdev);\r\nstruct spi_master *master = hw->bitbang.master;\r\nunsigned int i;\r\nspi_bitbang_stop(&hw->bitbang);\r\nfor (i = 0; i < hw->gpio_cs_count; i++)\r\ngpio_free(hw->gpio_cs[i]);\r\nplatform_set_drvdata(pdev, NULL);\r\nspi_master_put(master);\r\nreturn 0;\r\n}
