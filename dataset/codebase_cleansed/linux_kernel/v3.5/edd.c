static int\r\nedd_has_mbr_signature(struct edd_device *edev)\r\n{\r\nreturn edev->index < min_t(unsigned char, edd.mbr_signature_nr, EDD_MBR_SIG_MAX);\r\n}\r\nstatic int\r\nedd_has_edd_info(struct edd_device *edev)\r\n{\r\nreturn edev->index < min_t(unsigned char, edd.edd_info_nr, EDDMAXNR);\r\n}\r\nstatic inline struct edd_info *\r\nedd_dev_get_info(struct edd_device *edev)\r\n{\r\nreturn edev->info;\r\n}\r\nstatic inline void\r\nedd_dev_set_info(struct edd_device *edev, int i)\r\n{\r\nedev->index = i;\r\nif (edd_has_mbr_signature(edev))\r\nedev->mbr_signature = edd.mbr_signature[i];\r\nif (edd_has_edd_info(edev))\r\nedev->info = &edd.edd_info[i];\r\n}\r\nstatic ssize_t\r\nedd_attr_show(struct kobject * kobj, struct attribute *attr, char *buf)\r\n{\r\nstruct edd_device *dev = to_edd_device(kobj);\r\nstruct edd_attribute *edd_attr = to_edd_attr(attr);\r\nssize_t ret = -EIO;\r\nif (edd_attr->show)\r\nret = edd_attr->show(dev, buf);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nedd_show_host_bus(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nint i;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 4; i++) {\r\nif (isprint(info->params.host_bus_type[i])) {\r\np += scnprintf(p, left, "%c", info->params.host_bus_type[i]);\r\n} else {\r\np += scnprintf(p, left, " ");\r\n}\r\n}\r\nif (!strncmp(info->params.host_bus_type, "ISA", 3)) {\r\np += scnprintf(p, left, "\tbase_address: %x\n",\r\ninfo->params.interface_path.isa.base_address);\r\n} else if (!strncmp(info->params.host_bus_type, "PCIX", 4) ||\r\n!strncmp(info->params.host_bus_type, "PCI", 3) ||\r\n!strncmp(info->params.host_bus_type, "XPRS", 4)) {\r\np += scnprintf(p, left,\r\n"\t%02x:%02x.%d channel: %u\n",\r\ninfo->params.interface_path.pci.bus,\r\ninfo->params.interface_path.pci.slot,\r\ninfo->params.interface_path.pci.function,\r\ninfo->params.interface_path.pci.channel);\r\n} else if (!strncmp(info->params.host_bus_type, "IBND", 4) ||\r\n!strncmp(info->params.host_bus_type, "HTPT", 4)) {\r\np += scnprintf(p, left,\r\n"\tTBD: %llx\n",\r\ninfo->params.interface_path.ibnd.reserved);\r\n} else {\r\np += scnprintf(p, left, "\tunknown: %llx\n",\r\ninfo->params.interface_path.unknown.reserved);\r\n}\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_interface(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nint i;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 8; i++) {\r\nif (isprint(info->params.interface_type[i])) {\r\np += scnprintf(p, left, "%c", info->params.interface_type[i]);\r\n} else {\r\np += scnprintf(p, left, " ");\r\n}\r\n}\r\nif (!strncmp(info->params.interface_type, "ATAPI", 5)) {\r\np += scnprintf(p, left, "\tdevice: %u lun: %u\n",\r\ninfo->params.device_path.atapi.device,\r\ninfo->params.device_path.atapi.lun);\r\n} else if (!strncmp(info->params.interface_type, "ATA", 3)) {\r\np += scnprintf(p, left, "\tdevice: %u\n",\r\ninfo->params.device_path.ata.device);\r\n} else if (!strncmp(info->params.interface_type, "SCSI", 4)) {\r\np += scnprintf(p, left, "\tid: %u lun: %llu\n",\r\ninfo->params.device_path.scsi.id,\r\ninfo->params.device_path.scsi.lun);\r\n} else if (!strncmp(info->params.interface_type, "USB", 3)) {\r\np += scnprintf(p, left, "\tserial_number: %llx\n",\r\ninfo->params.device_path.usb.serial_number);\r\n} else if (!strncmp(info->params.interface_type, "1394", 4)) {\r\np += scnprintf(p, left, "\teui: %llx\n",\r\ninfo->params.device_path.i1394.eui);\r\n} else if (!strncmp(info->params.interface_type, "FIBRE", 5)) {\r\np += scnprintf(p, left, "\twwid: %llx lun: %llx\n",\r\ninfo->params.device_path.fibre.wwid,\r\ninfo->params.device_path.fibre.lun);\r\n} else if (!strncmp(info->params.interface_type, "I2O", 3)) {\r\np += scnprintf(p, left, "\tidentity_tag: %llx\n",\r\ninfo->params.device_path.i2o.identity_tag);\r\n} else if (!strncmp(info->params.interface_type, "RAID", 4)) {\r\np += scnprintf(p, left, "\tidentity_tag: %x\n",\r\ninfo->params.device_path.raid.array_number);\r\n} else if (!strncmp(info->params.interface_type, "SATA", 4)) {\r\np += scnprintf(p, left, "\tdevice: %u\n",\r\ninfo->params.device_path.sata.device);\r\n} else {\r\np += scnprintf(p, left, "\tunknown: %llx %llx\n",\r\ninfo->params.device_path.unknown.reserved1,\r\ninfo->params.device_path.unknown.reserved2);\r\n}\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_raw_data(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nssize_t len = sizeof (info->params);\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\nif (!(info->params.key == 0xBEDD || info->params.key == 0xDDBE))\r\nlen = info->params.length;\r\nif (len > (sizeof(info->params)))\r\nlen = sizeof(info->params);\r\nmemcpy(buf, &info->params, len);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nedd_show_version(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += scnprintf(p, left, "0x%02x\n", info->version);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_mbr_signature(struct edd_device *edev, char *buf)\r\n{\r\nchar *p = buf;\r\np += scnprintf(p, left, "0x%08x\n", edev->mbr_signature);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_extensions(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\nif (info->interface_support & EDD_EXT_FIXED_DISK_ACCESS) {\r\np += scnprintf(p, left, "Fixed disk access\n");\r\n}\r\nif (info->interface_support & EDD_EXT_DEVICE_LOCKING_AND_EJECTING) {\r\np += scnprintf(p, left, "Device locking and ejecting\n");\r\n}\r\nif (info->interface_support & EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT) {\r\np += scnprintf(p, left, "Enhanced Disk Drive support\n");\r\n}\r\nif (info->interface_support & EDD_EXT_64BIT_EXTENSIONS) {\r\np += scnprintf(p, left, "64-bit extensions\n");\r\n}\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_info_flags(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\nif (info->params.info_flags & EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT)\r\np += scnprintf(p, left, "DMA boundary error transparent\n");\r\nif (info->params.info_flags & EDD_INFO_GEOMETRY_VALID)\r\np += scnprintf(p, left, "geometry valid\n");\r\nif (info->params.info_flags & EDD_INFO_REMOVABLE)\r\np += scnprintf(p, left, "removable\n");\r\nif (info->params.info_flags & EDD_INFO_WRITE_VERIFY)\r\np += scnprintf(p, left, "write verify\n");\r\nif (info->params.info_flags & EDD_INFO_MEDIA_CHANGE_NOTIFICATION)\r\np += scnprintf(p, left, "media change notification\n");\r\nif (info->params.info_flags & EDD_INFO_LOCKABLE)\r\np += scnprintf(p, left, "lockable\n");\r\nif (info->params.info_flags & EDD_INFO_NO_MEDIA_PRESENT)\r\np += scnprintf(p, left, "no media present\n");\r\nif (info->params.info_flags & EDD_INFO_USE_INT13_FN50)\r\np += scnprintf(p, left, "use int13 fn50\n");\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_legacy_max_cylinder(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += snprintf(p, left, "%u\n", info->legacy_max_cylinder);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_legacy_max_head(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += snprintf(p, left, "%u\n", info->legacy_max_head);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_legacy_sectors_per_track(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += snprintf(p, left, "%u\n", info->legacy_sectors_per_track);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_default_cylinders(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += scnprintf(p, left, "%u\n", info->params.num_default_cylinders);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_default_heads(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += scnprintf(p, left, "%u\n", info->params.num_default_heads);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_default_sectors_per_track(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += scnprintf(p, left, "%u\n", info->params.sectors_per_track);\r\nreturn (p - buf);\r\n}\r\nstatic ssize_t\r\nedd_show_sectors(struct edd_device *edev, char *buf)\r\n{\r\nstruct edd_info *info;\r\nchar *p = buf;\r\nif (!edev)\r\nreturn -EINVAL;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info || !buf)\r\nreturn -EINVAL;\r\np += scnprintf(p, left, "%llu\n", info->params.number_of_sectors);\r\nreturn (p - buf);\r\n}\r\nstatic int\r\nedd_has_legacy_max_cylinder(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nreturn info->legacy_max_cylinder > 0;\r\n}\r\nstatic int\r\nedd_has_legacy_max_head(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nreturn info->legacy_max_head > 0;\r\n}\r\nstatic int\r\nedd_has_legacy_sectors_per_track(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nreturn info->legacy_sectors_per_track > 0;\r\n}\r\nstatic int\r\nedd_has_default_cylinders(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nreturn info->params.num_default_cylinders > 0;\r\n}\r\nstatic int\r\nedd_has_default_heads(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nreturn info->params.num_default_heads > 0;\r\n}\r\nstatic int\r\nedd_has_default_sectors_per_track(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nreturn info->params.sectors_per_track > 0;\r\n}\r\nstatic int\r\nedd_has_edd30(struct edd_device *edev)\r\n{\r\nstruct edd_info *info;\r\nint i;\r\nu8 csum = 0;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (!info)\r\nreturn 0;\r\nif (!(info->params.key == 0xBEDD || info->params.key == 0xDDBE)) {\r\nreturn 0;\r\n}\r\nif (info->params.device_path_info_length != 44)\r\nreturn 0;\r\nfor (i = 30; i < info->params.device_path_info_length + 30; i++)\r\ncsum += *(((u8 *)&info->params) + i);\r\nif (csum)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void edd_release(struct kobject * kobj)\r\n{\r\nstruct edd_device * dev = to_edd_device(kobj);\r\nkfree(dev);\r\n}\r\nstatic int\r\nedd_dev_is_type(struct edd_device *edev, const char *type)\r\n{\r\nstruct edd_info *info;\r\nif (!edev)\r\nreturn 0;\r\ninfo = edd_dev_get_info(edev);\r\nif (type && info) {\r\nif (!strncmp(info->params.host_bus_type, type, strlen(type)) ||\r\n!strncmp(info->params.interface_type, type, strlen(type)))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *\r\nedd_get_pci_dev(struct edd_device *edev)\r\n{\r\nstruct edd_info *info = edd_dev_get_info(edev);\r\nif (edd_dev_is_type(edev, "PCI") || edd_dev_is_type(edev, "XPRS")) {\r\nreturn pci_get_bus_and_slot(info->params.interface_path.pci.bus,\r\nPCI_DEVFN(info->params.interface_path.pci.slot,\r\ninfo->params.interface_path.pci.\r\nfunction));\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nedd_create_symlink_to_pcidev(struct edd_device *edev)\r\n{\r\nstruct pci_dev *pci_dev = edd_get_pci_dev(edev);\r\nint ret;\r\nif (!pci_dev)\r\nreturn 1;\r\nret = sysfs_create_link(&edev->kobj,&pci_dev->dev.kobj,"pci_dev");\r\npci_dev_put(pci_dev);\r\nreturn ret;\r\n}\r\nstatic inline void\r\nedd_device_unregister(struct edd_device *edev)\r\n{\r\nkobject_put(&edev->kobj);\r\n}\r\nstatic void edd_populate_dir(struct edd_device * edev)\r\n{\r\nstruct edd_attribute * attr;\r\nint error = 0;\r\nint i;\r\nfor (i = 0; (attr = edd_attrs[i]) && !error; i++) {\r\nif (!attr->test ||\r\n(attr->test && attr->test(edev)))\r\nerror = sysfs_create_file(&edev->kobj,&attr->attr);\r\n}\r\nif (!error) {\r\nedd_create_symlink_to_pcidev(edev);\r\n}\r\n}\r\nstatic int\r\nedd_device_register(struct edd_device *edev, int i)\r\n{\r\nint error;\r\nif (!edev)\r\nreturn 1;\r\nedd_dev_set_info(edev, i);\r\nedev->kobj.kset = edd_kset;\r\nerror = kobject_init_and_add(&edev->kobj, &edd_ktype, NULL,\r\n"int13_dev%02x", 0x80 + i);\r\nif (!error) {\r\nedd_populate_dir(edev);\r\nkobject_uevent(&edev->kobj, KOBJ_ADD);\r\n}\r\nreturn error;\r\n}\r\nstatic inline int edd_num_devices(void)\r\n{\r\nreturn max_t(unsigned char,\r\nmin_t(unsigned char, EDD_MBR_SIG_MAX, edd.mbr_signature_nr),\r\nmin_t(unsigned char, EDDMAXNR, edd.edd_info_nr));\r\n}\r\nstatic int __init\r\nedd_init(void)\r\n{\r\nint i;\r\nint rc=0;\r\nstruct edd_device *edev;\r\nprintk(KERN_INFO "BIOS EDD facility v%s %s, %d devices found\n",\r\nEDD_VERSION, EDD_DATE, edd_num_devices());\r\nif (!edd_num_devices()) {\r\nprintk(KERN_INFO "EDD information not available.\n");\r\nreturn -ENODEV;\r\n}\r\nedd_kset = kset_create_and_add("edd", NULL, firmware_kobj);\r\nif (!edd_kset)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < edd_num_devices(); i++) {\r\nedev = kzalloc(sizeof (*edev), GFP_KERNEL);\r\nif (!edev) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = edd_device_register(edev, i);\r\nif (rc) {\r\nkfree(edev);\r\ngoto out;\r\n}\r\nedd_devices[i] = edev;\r\n}\r\nreturn 0;\r\nout:\r\nwhile (--i >= 0)\r\nedd_device_unregister(edd_devices[i]);\r\nkset_unregister(edd_kset);\r\nreturn rc;\r\n}\r\nstatic void __exit\r\nedd_exit(void)\r\n{\r\nint i;\r\nstruct edd_device *edev;\r\nfor (i = 0; i < edd_num_devices(); i++) {\r\nif ((edev = edd_devices[i]))\r\nedd_device_unregister(edev);\r\n}\r\nkset_unregister(edd_kset);\r\n}
