static inline int zmii_valid_mode(int mode)\r\n{\r\nreturn mode == PHY_MODE_MII ||\r\nmode == PHY_MODE_RMII ||\r\nmode == PHY_MODE_SMII ||\r\nmode == PHY_MODE_NA;\r\n}\r\nstatic inline const char *zmii_mode_name(int mode)\r\n{\r\nswitch (mode) {\r\ncase PHY_MODE_MII:\r\nreturn "MII";\r\ncase PHY_MODE_RMII:\r\nreturn "RMII";\r\ncase PHY_MODE_SMII:\r\nreturn "SMII";\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline u32 zmii_mode_mask(int mode, int input)\r\n{\r\nswitch (mode) {\r\ncase PHY_MODE_MII:\r\nreturn ZMII_FER_MII(input);\r\ncase PHY_MODE_RMII:\r\nreturn ZMII_FER_RMII(input);\r\ncase PHY_MODE_SMII:\r\nreturn ZMII_FER_SMII(input);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint __devinit zmii_attach(struct platform_device *ofdev, int input, int *mode)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\nstruct zmii_regs __iomem *p = dev->base;\r\nZMII_DBG(dev, "init(%d, %d)" NL, input, *mode);\r\nif (!zmii_valid_mode(*mode)) {\r\ndev->users++;\r\nreturn 0;\r\n}\r\nmutex_lock(&dev->lock);\r\nif (dev->mode == PHY_MODE_NA) {\r\nif (*mode == PHY_MODE_NA) {\r\nu32 r = dev->fer_save;\r\nZMII_DBG(dev, "autodetecting mode, FER = 0x%08x" NL, r);\r\nif (r & (ZMII_FER_MII(0) | ZMII_FER_MII(1)))\r\ndev->mode = PHY_MODE_MII;\r\nelse if (r & (ZMII_FER_RMII(0) | ZMII_FER_RMII(1)))\r\ndev->mode = PHY_MODE_RMII;\r\nelse\r\ndev->mode = PHY_MODE_SMII;\r\n} else\r\ndev->mode = *mode;\r\nprintk(KERN_NOTICE "%s: bridge in %s mode\n",\r\nofdev->dev.of_node->full_name,\r\nzmii_mode_name(dev->mode));\r\n} else {\r\nif (*mode != PHY_MODE_NA && *mode != dev->mode) {\r\nprintk(KERN_ERR\r\n"%s: invalid mode %d specified for input %d\n",\r\nofdev->dev.of_node->full_name, *mode, input);\r\nmutex_unlock(&dev->lock);\r\nreturn -EINVAL;\r\n}\r\n}\r\n*mode = dev->mode;\r\nout_be32(&p->fer, in_be32(&p->fer) | zmii_mode_mask(dev->mode, input));\r\n++dev->users;\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nvoid zmii_get_mdio(struct platform_device *ofdev, int input)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\nu32 fer;\r\nZMII_DBG2(dev, "get_mdio(%d)" NL, input);\r\nmutex_lock(&dev->lock);\r\nfer = in_be32(&dev->base->fer) & ~ZMII_FER_MDI_ALL;\r\nout_be32(&dev->base->fer, fer | ZMII_FER_MDI(input));\r\n}\r\nvoid zmii_put_mdio(struct platform_device *ofdev, int input)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\nZMII_DBG2(dev, "put_mdio(%d)" NL, input);\r\nmutex_unlock(&dev->lock);\r\n}\r\nvoid zmii_set_speed(struct platform_device *ofdev, int input, int speed)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\nu32 ssr;\r\nmutex_lock(&dev->lock);\r\nssr = in_be32(&dev->base->ssr);\r\nZMII_DBG(dev, "speed(%d, %d)" NL, input, speed);\r\nif (speed == SPEED_100)\r\nssr |= ZMII_SSR_SP(input);\r\nelse\r\nssr &= ~ZMII_SSR_SP(input);\r\nout_be32(&dev->base->ssr, ssr);\r\nmutex_unlock(&dev->lock);\r\n}\r\nvoid zmii_detach(struct platform_device *ofdev, int input)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\nBUG_ON(!dev || dev->users == 0);\r\nmutex_lock(&dev->lock);\r\nZMII_DBG(dev, "detach(%d)" NL, input);\r\nout_be32(&dev->base->fer,\r\nin_be32(&dev->base->fer) & ~zmii_mode_mask(dev->mode, input));\r\n--dev->users;\r\nmutex_unlock(&dev->lock);\r\n}\r\nint zmii_get_regs_len(struct platform_device *ofdev)\r\n{\r\nreturn sizeof(struct emac_ethtool_regs_subhdr) +\r\nsizeof(struct zmii_regs);\r\n}\r\nvoid *zmii_dump_regs(struct platform_device *ofdev, void *buf)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\nstruct emac_ethtool_regs_subhdr *hdr = buf;\r\nstruct zmii_regs *regs = (struct zmii_regs *)(hdr + 1);\r\nhdr->version = 0;\r\nhdr->index = 0;\r\nmemcpy_fromio(regs, dev->base, sizeof(struct zmii_regs));\r\nreturn regs + 1;\r\n}\r\nstatic int __devinit zmii_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct zmii_instance *dev;\r\nstruct resource regs;\r\nint rc;\r\nrc = -ENOMEM;\r\ndev = kzalloc(sizeof(struct zmii_instance), GFP_KERNEL);\r\nif (dev == NULL)\r\ngoto err_gone;\r\nmutex_init(&dev->lock);\r\ndev->ofdev = ofdev;\r\ndev->mode = PHY_MODE_NA;\r\nrc = -ENXIO;\r\nif (of_address_to_resource(np, 0, &regs)) {\r\nprintk(KERN_ERR "%s: Can't get registers address\n",\r\nnp->full_name);\r\ngoto err_free;\r\n}\r\nrc = -ENOMEM;\r\ndev->base = (struct zmii_regs __iomem *)ioremap(regs.start,\r\nsizeof(struct zmii_regs));\r\nif (dev->base == NULL) {\r\nprintk(KERN_ERR "%s: Can't map device registers!\n",\r\nnp->full_name);\r\ngoto err_free;\r\n}\r\ndev->fer_save = in_be32(&dev->base->fer);\r\nout_be32(&dev->base->fer, 0);\r\nprintk(KERN_INFO\r\n"ZMII %s initialized\n", ofdev->dev.of_node->full_name);\r\nwmb();\r\ndev_set_drvdata(&ofdev->dev, dev);\r\nreturn 0;\r\nerr_free:\r\nkfree(dev);\r\nerr_gone:\r\nreturn rc;\r\n}\r\nstatic int __devexit zmii_remove(struct platform_device *ofdev)\r\n{\r\nstruct zmii_instance *dev = dev_get_drvdata(&ofdev->dev);\r\ndev_set_drvdata(&ofdev->dev, NULL);\r\nWARN_ON(dev->users != 0);\r\niounmap(dev->base);\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nint __init zmii_init(void)\r\n{\r\nreturn platform_driver_register(&zmii_driver);\r\n}\r\nvoid zmii_exit(void)\r\n{\r\nplatform_driver_unregister(&zmii_driver);\r\n}
