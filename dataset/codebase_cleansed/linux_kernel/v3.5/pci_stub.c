static struct pcistub_device *pcistub_device_alloc(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev;\r\ndev_dbg(&dev->dev, "pcistub_device_alloc\n");\r\npsdev = kzalloc(sizeof(*psdev), GFP_ATOMIC);\r\nif (!psdev)\r\nreturn NULL;\r\npsdev->dev = pci_dev_get(dev);\r\nif (!psdev->dev) {\r\nkfree(psdev);\r\nreturn NULL;\r\n}\r\nkref_init(&psdev->kref);\r\nspin_lock_init(&psdev->lock);\r\nreturn psdev;\r\n}\r\nstatic void pcistub_device_release(struct kref *kref)\r\n{\r\nstruct pcistub_device *psdev;\r\nstruct xen_pcibk_dev_data *dev_data;\r\npsdev = container_of(kref, struct pcistub_device, kref);\r\ndev_data = pci_get_drvdata(psdev->dev);\r\ndev_dbg(&psdev->dev->dev, "pcistub_device_release\n");\r\nxen_unregister_device_domain_owner(psdev->dev);\r\n__pci_reset_function_locked(psdev->dev);\r\nif (pci_load_and_free_saved_state(psdev->dev,\r\n&dev_data->pci_saved_state)) {\r\ndev_dbg(&psdev->dev->dev, "Could not reload PCI state\n");\r\n} else\r\npci_restore_state(psdev->dev);\r\nxen_pcibk_reset_device(psdev->dev);\r\nkfree(dev_data);\r\npci_set_drvdata(psdev->dev, NULL);\r\nxen_pcibk_config_free_dyn_fields(psdev->dev);\r\nxen_pcibk_config_free_dev(psdev->dev);\r\npsdev->dev->dev_flags &= ~PCI_DEV_FLAGS_ASSIGNED;\r\npci_dev_put(psdev->dev);\r\nkfree(psdev);\r\n}\r\nstatic inline void pcistub_device_get(struct pcistub_device *psdev)\r\n{\r\nkref_get(&psdev->kref);\r\n}\r\nstatic inline void pcistub_device_put(struct pcistub_device *psdev)\r\n{\r\nkref_put(&psdev->kref, pcistub_device_release);\r\n}\r\nstatic struct pcistub_device *pcistub_device_find(int domain, int bus,\r\nint slot, int func)\r\n{\r\nstruct pcistub_device *psdev = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (psdev->dev != NULL\r\n&& domain == pci_domain_nr(psdev->dev->bus)\r\n&& bus == psdev->dev->bus->number\r\n&& PCI_DEVFN(slot, func) == psdev->dev->devfn) {\r\npcistub_device_get(psdev);\r\ngoto out;\r\n}\r\n}\r\npsdev = NULL;\r\nout:\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nreturn psdev;\r\n}\r\nstatic struct pci_dev *pcistub_device_get_pci_dev(struct xen_pcibk_device *pdev,\r\nstruct pcistub_device *psdev)\r\n{\r\nstruct pci_dev *pci_dev = NULL;\r\nunsigned long flags;\r\npcistub_device_get(psdev);\r\nspin_lock_irqsave(&psdev->lock, flags);\r\nif (!psdev->pdev) {\r\npsdev->pdev = pdev;\r\npci_dev = psdev->dev;\r\n}\r\nspin_unlock_irqrestore(&psdev->lock, flags);\r\nif (!pci_dev)\r\npcistub_device_put(psdev);\r\nreturn pci_dev;\r\n}\r\nstruct pci_dev *pcistub_get_pci_dev_by_slot(struct xen_pcibk_device *pdev,\r\nint domain, int bus,\r\nint slot, int func)\r\n{\r\nstruct pcistub_device *psdev;\r\nstruct pci_dev *found_dev = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (psdev->dev != NULL\r\n&& domain == pci_domain_nr(psdev->dev->bus)\r\n&& bus == psdev->dev->bus->number\r\n&& PCI_DEVFN(slot, func) == psdev->dev->devfn) {\r\nfound_dev = pcistub_device_get_pci_dev(pdev, psdev);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nreturn found_dev;\r\n}\r\nstruct pci_dev *pcistub_get_pci_dev(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev;\r\nstruct pci_dev *found_dev = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (psdev->dev == dev) {\r\nfound_dev = pcistub_device_get_pci_dev(pdev, psdev);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nreturn found_dev;\r\n}\r\nvoid pcistub_put_pci_dev(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev, *found_psdev = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (psdev->dev == dev) {\r\nfound_psdev = psdev;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nif (WARN_ON(!found_psdev))\r\nreturn;\r\ndown_write(&pcistub_sem);\r\npci_reset_function(dev);\r\npci_restore_state(psdev->dev);\r\nxen_pcibk_reset_device(found_psdev->dev);\r\nxen_pcibk_config_free_dyn_fields(found_psdev->dev);\r\nxen_pcibk_config_reset_dev(found_psdev->dev);\r\nxen_unregister_device_domain_owner(found_psdev->dev);\r\nspin_lock_irqsave(&found_psdev->lock, flags);\r\nfound_psdev->pdev = NULL;\r\nspin_unlock_irqrestore(&found_psdev->lock, flags);\r\npcistub_device_put(found_psdev);\r\nup_write(&pcistub_sem);\r\n}\r\nstatic int __devinit pcistub_match_one(struct pci_dev *dev,\r\nstruct pcistub_device_id *pdev_id)\r\n{\r\nfor (; dev != NULL; dev = dev->bus->self) {\r\nif (pci_domain_nr(dev->bus) == pdev_id->domain\r\n&& dev->bus->number == pdev_id->bus\r\n&& dev->devfn == pdev_id->devfn)\r\nreturn 1;\r\nif (dev == dev->bus->self)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit pcistub_match(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device_id *pdev_id;\r\nunsigned long flags;\r\nint found = 0;\r\nspin_lock_irqsave(&device_ids_lock, flags);\r\nlist_for_each_entry(pdev_id, &pcistub_device_ids, slot_list) {\r\nif (pcistub_match_one(dev, pdev_id)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&device_ids_lock, flags);\r\nreturn found;\r\n}\r\nstatic int __devinit pcistub_init_device(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data;\r\nint err = 0;\r\ndev_dbg(&dev->dev, "initializing...\n");\r\ndev_data = kzalloc(sizeof(*dev_data) + strlen(DRV_NAME "[]")\r\n+ strlen(pci_name(dev)) + 1, GFP_ATOMIC);\r\nif (!dev_data) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\npci_set_drvdata(dev, dev_data);\r\nsprintf(dev_data->irq_name, DRV_NAME "[%s]", pci_name(dev));\r\ndev_dbg(&dev->dev, "initializing config\n");\r\ninit_waitqueue_head(&xen_pcibk_aer_wait_queue);\r\nerr = xen_pcibk_config_init_dev(dev);\r\nif (err)\r\ngoto out;\r\ndev_dbg(&dev->dev, "enabling device\n");\r\nerr = pci_enable_device(dev);\r\nif (err)\r\ngoto config_release;\r\ndev_dbg(&dev->dev, "reseting (FLR, D3, etc) the device\n");\r\n__pci_reset_function_locked(dev);\r\ndev_dbg(&dev->dev, "save state of device\n");\r\npci_save_state(dev);\r\ndev_data->pci_saved_state = pci_store_saved_state(dev);\r\nif (!dev_data->pci_saved_state)\r\ndev_err(&dev->dev, "Could not store PCI conf saved state!\n");\r\ndev_dbg(&dev->dev, "reset device\n");\r\nxen_pcibk_reset_device(dev);\r\ndev->dev_flags |= PCI_DEV_FLAGS_ASSIGNED;\r\nreturn 0;\r\nconfig_release:\r\nxen_pcibk_config_free_dev(dev);\r\nout:\r\npci_set_drvdata(dev, NULL);\r\nkfree(dev_data);\r\nreturn err;\r\n}\r\nstatic int __init pcistub_init_devices_late(void)\r\n{\r\nstruct pcistub_device *psdev;\r\nunsigned long flags;\r\nint err = 0;\r\npr_debug(DRV_NAME ": pcistub_init_devices_late\n");\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nwhile (!list_empty(&seized_devices)) {\r\npsdev = container_of(seized_devices.next,\r\nstruct pcistub_device, dev_list);\r\nlist_del(&psdev->dev_list);\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nerr = pcistub_init_device(psdev->dev);\r\nif (err) {\r\ndev_err(&psdev->dev->dev,\r\n"error %d initializing device\n", err);\r\nkfree(psdev);\r\npsdev = NULL;\r\n}\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nif (psdev)\r\nlist_add_tail(&psdev->dev_list, &pcistub_devices);\r\n}\r\ninitialize_devices = 1;\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __devinit pcistub_seize(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev;\r\nunsigned long flags;\r\nint err = 0;\r\npsdev = pcistub_device_alloc(dev);\r\nif (!psdev)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nif (initialize_devices) {\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nerr = pcistub_init_device(psdev->dev);\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nif (!err)\r\nlist_add(&psdev->dev_list, &pcistub_devices);\r\n} else {\r\ndev_dbg(&dev->dev, "deferring initialization\n");\r\nlist_add(&psdev->dev_list, &seized_devices);\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nif (err)\r\npcistub_device_put(psdev);\r\nreturn err;\r\n}\r\nstatic int __devinit pcistub_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err = 0;\r\ndev_dbg(&dev->dev, "probing...\n");\r\nif (pcistub_match(dev)) {\r\nif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL\r\n&& dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\r\ndev_err(&dev->dev, "can't export pci devices that "\r\n"don't have a normal (0) or bridge (1) "\r\n"header type!\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ndev_info(&dev->dev, "seizing device\n");\r\nerr = pcistub_seize(dev);\r\n} else\r\nerr = -ENODEV;\r\nout:\r\nreturn err;\r\n}\r\nstatic void pcistub_remove(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev, *found_psdev = NULL;\r\nunsigned long flags;\r\ndev_dbg(&dev->dev, "removing\n");\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nxen_pcibk_config_quirk_release(dev);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (psdev->dev == dev) {\r\nfound_psdev = psdev;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nif (found_psdev) {\r\ndev_dbg(&dev->dev, "found device to remove - in use? %p\n",\r\nfound_psdev->pdev);\r\nif (found_psdev->pdev) {\r\nprintk(KERN_WARNING DRV_NAME ": ****** removing device "\r\n"%s while still in-use! ******\n",\r\npci_name(found_psdev->dev));\r\nprintk(KERN_WARNING DRV_NAME ": ****** driver domain may"\r\n" still access this device's i/o resources!\n");\r\nprintk(KERN_WARNING DRV_NAME ": ****** shutdown driver "\r\n"domain before binding device\n");\r\nprintk(KERN_WARNING DRV_NAME ": ****** to other drivers "\r\n"or domains\n");\r\nxen_pcibk_release_pci_dev(found_psdev->pdev,\r\nfound_psdev->dev);\r\n}\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_del(&found_psdev->dev_list);\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\npcistub_device_put(found_psdev);\r\n}\r\n}\r\nstatic void kill_domain_by_device(struct pcistub_device *psdev)\r\n{\r\nstruct xenbus_transaction xbt;\r\nint err;\r\nchar nodename[PCI_NODENAME_MAX];\r\nBUG_ON(!psdev);\r\nsnprintf(nodename, PCI_NODENAME_MAX, "/local/domain/0/backend/pci/%d/0",\r\npsdev->pdev->xdev->otherend_id);\r\nagain:\r\nerr = xenbus_transaction_start(&xbt);\r\nif (err) {\r\ndev_err(&psdev->dev->dev,\r\n"error %d when start xenbus transaction\n", err);\r\nreturn;\r\n}\r\nxenbus_printf(xbt, nodename, "aerState" , "aerfail");\r\nerr = xenbus_transaction_end(xbt, 0);\r\nif (err) {\r\nif (err == -EAGAIN)\r\ngoto again;\r\ndev_err(&psdev->dev->dev,\r\n"error %d when end xenbus transaction\n", err);\r\nreturn;\r\n}\r\n}\r\nstatic pci_ers_result_t common_process(struct pcistub_device *psdev,\r\npci_channel_state_t state, int aer_cmd,\r\npci_ers_result_t result)\r\n{\r\npci_ers_result_t res = result;\r\nstruct xen_pcie_aer_op *aer_op;\r\nint ret;\r\naer_op = &(psdev->pdev->sh_info->aer_op);\r\naer_op->cmd = aer_cmd ;\r\naer_op->err = state;\r\nret = xen_pcibk_get_pcifront_dev(psdev->dev, psdev->pdev,\r\n&aer_op->domain, &aer_op->bus, &aer_op->devfn);\r\nif (!ret) {\r\ndev_err(&psdev->dev->dev,\r\nDRV_NAME ": failed to get pcifront device\n");\r\nreturn PCI_ERS_RESULT_NONE;\r\n}\r\nwmb();\r\ndev_dbg(&psdev->dev->dev,\r\nDRV_NAME ": aer_op %x dom %x bus %x devfn %x\n",\r\naer_cmd, aer_op->domain, aer_op->bus, aer_op->devfn);\r\nset_bit(_PCIB_op_pending, (unsigned long *)&psdev->pdev->flags);\r\nset_bit(_XEN_PCIB_active,\r\n(unsigned long *)&psdev->pdev->sh_info->flags);\r\nwmb();\r\nnotify_remote_via_irq(psdev->pdev->evtchn_irq);\r\nret = wait_event_timeout(xen_pcibk_aer_wait_queue,\r\n!(test_bit(_XEN_PCIB_active, (unsigned long *)\r\n&psdev->pdev->sh_info->flags)), 300*HZ);\r\nif (!ret) {\r\nif (test_bit(_XEN_PCIB_active,\r\n(unsigned long *)&psdev->pdev->sh_info->flags)) {\r\ndev_err(&psdev->dev->dev,\r\n"pcifront aer process not responding!\n");\r\nclear_bit(_XEN_PCIB_active,\r\n(unsigned long *)&psdev->pdev->sh_info->flags);\r\naer_op->err = PCI_ERS_RESULT_NONE;\r\nreturn res;\r\n}\r\n}\r\nclear_bit(_PCIB_op_pending, (unsigned long *)&psdev->pdev->flags);\r\nif (test_bit(_XEN_PCIF_active,\r\n(unsigned long *)&psdev->pdev->sh_info->flags)) {\r\ndev_dbg(&psdev->dev->dev,\r\n"schedule pci_conf service in " DRV_NAME "\n");\r\nxen_pcibk_test_and_schedule_op(psdev->pdev);\r\n}\r\nres = (pci_ers_result_t)aer_op->err;\r\nreturn res;\r\n}\r\nstatic pci_ers_result_t xen_pcibk_slot_reset(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev;\r\npci_ers_result_t result;\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\ndev_dbg(&dev->dev, "xen_pcibk_slot_reset(bus:%x,devfn:%x)\n",\r\ndev->bus->number, dev->devfn);\r\ndown_write(&pcistub_sem);\r\npsdev = pcistub_device_find(pci_domain_nr(dev->bus),\r\ndev->bus->number,\r\nPCI_SLOT(dev->devfn),\r\nPCI_FUNC(dev->devfn));\r\nif (!psdev || !psdev->pdev) {\r\ndev_err(&dev->dev,\r\nDRV_NAME " device is not found/assigned\n");\r\ngoto end;\r\n}\r\nif (!psdev->pdev->sh_info) {\r\ndev_err(&dev->dev, DRV_NAME " device is not connected or owned"\r\n" by HVM, kill it\n");\r\nkill_domain_by_device(psdev);\r\ngoto release;\r\n}\r\nif (!test_bit(_XEN_PCIB_AERHANDLER,\r\n(unsigned long *)&psdev->pdev->sh_info->flags)) {\r\ndev_err(&dev->dev,\r\n"guest with no AER driver should have been killed\n");\r\ngoto release;\r\n}\r\nresult = common_process(psdev, 1, XEN_PCI_OP_aer_slotreset, result);\r\nif (result == PCI_ERS_RESULT_NONE ||\r\nresult == PCI_ERS_RESULT_DISCONNECT) {\r\ndev_dbg(&dev->dev,\r\n"No AER slot_reset service or disconnected!\n");\r\nkill_domain_by_device(psdev);\r\n}\r\nrelease:\r\npcistub_device_put(psdev);\r\nend:\r\nup_write(&pcistub_sem);\r\nreturn result;\r\n}\r\nstatic pci_ers_result_t xen_pcibk_mmio_enabled(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev;\r\npci_ers_result_t result;\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\ndev_dbg(&dev->dev, "xen_pcibk_mmio_enabled(bus:%x,devfn:%x)\n",\r\ndev->bus->number, dev->devfn);\r\ndown_write(&pcistub_sem);\r\npsdev = pcistub_device_find(pci_domain_nr(dev->bus),\r\ndev->bus->number,\r\nPCI_SLOT(dev->devfn),\r\nPCI_FUNC(dev->devfn));\r\nif (!psdev || !psdev->pdev) {\r\ndev_err(&dev->dev,\r\nDRV_NAME " device is not found/assigned\n");\r\ngoto end;\r\n}\r\nif (!psdev->pdev->sh_info) {\r\ndev_err(&dev->dev, DRV_NAME " device is not connected or owned"\r\n" by HVM, kill it\n");\r\nkill_domain_by_device(psdev);\r\ngoto release;\r\n}\r\nif (!test_bit(_XEN_PCIB_AERHANDLER,\r\n(unsigned long *)&psdev->pdev->sh_info->flags)) {\r\ndev_err(&dev->dev,\r\n"guest with no AER driver should have been killed\n");\r\ngoto release;\r\n}\r\nresult = common_process(psdev, 1, XEN_PCI_OP_aer_mmio, result);\r\nif (result == PCI_ERS_RESULT_NONE ||\r\nresult == PCI_ERS_RESULT_DISCONNECT) {\r\ndev_dbg(&dev->dev,\r\n"No AER mmio_enabled service or disconnected!\n");\r\nkill_domain_by_device(psdev);\r\n}\r\nrelease:\r\npcistub_device_put(psdev);\r\nend:\r\nup_write(&pcistub_sem);\r\nreturn result;\r\n}\r\nstatic pci_ers_result_t xen_pcibk_error_detected(struct pci_dev *dev,\r\npci_channel_state_t error)\r\n{\r\nstruct pcistub_device *psdev;\r\npci_ers_result_t result;\r\nresult = PCI_ERS_RESULT_CAN_RECOVER;\r\ndev_dbg(&dev->dev, "xen_pcibk_error_detected(bus:%x,devfn:%x)\n",\r\ndev->bus->number, dev->devfn);\r\ndown_write(&pcistub_sem);\r\npsdev = pcistub_device_find(pci_domain_nr(dev->bus),\r\ndev->bus->number,\r\nPCI_SLOT(dev->devfn),\r\nPCI_FUNC(dev->devfn));\r\nif (!psdev || !psdev->pdev) {\r\ndev_err(&dev->dev,\r\nDRV_NAME " device is not found/assigned\n");\r\ngoto end;\r\n}\r\nif (!psdev->pdev->sh_info) {\r\ndev_err(&dev->dev, DRV_NAME " device is not connected or owned"\r\n" by HVM, kill it\n");\r\nkill_domain_by_device(psdev);\r\ngoto release;\r\n}\r\nif (!test_bit(_XEN_PCIB_AERHANDLER,\r\n(unsigned long *)&psdev->pdev->sh_info->flags)) {\r\ndev_dbg(&dev->dev, "guest may have no aer driver, kill it\n");\r\nkill_domain_by_device(psdev);\r\ngoto release;\r\n}\r\nresult = common_process(psdev, error, XEN_PCI_OP_aer_detected, result);\r\nif (result == PCI_ERS_RESULT_NONE ||\r\nresult == PCI_ERS_RESULT_DISCONNECT) {\r\ndev_dbg(&dev->dev,\r\n"No AER error_detected service or disconnected!\n");\r\nkill_domain_by_device(psdev);\r\n}\r\nrelease:\r\npcistub_device_put(psdev);\r\nend:\r\nup_write(&pcistub_sem);\r\nreturn result;\r\n}\r\nstatic void xen_pcibk_error_resume(struct pci_dev *dev)\r\n{\r\nstruct pcistub_device *psdev;\r\ndev_dbg(&dev->dev, "xen_pcibk_error_resume(bus:%x,devfn:%x)\n",\r\ndev->bus->number, dev->devfn);\r\ndown_write(&pcistub_sem);\r\npsdev = pcistub_device_find(pci_domain_nr(dev->bus),\r\ndev->bus->number,\r\nPCI_SLOT(dev->devfn),\r\nPCI_FUNC(dev->devfn));\r\nif (!psdev || !psdev->pdev) {\r\ndev_err(&dev->dev,\r\nDRV_NAME " device is not found/assigned\n");\r\ngoto end;\r\n}\r\nif (!psdev->pdev->sh_info) {\r\ndev_err(&dev->dev, DRV_NAME " device is not connected or owned"\r\n" by HVM, kill it\n");\r\nkill_domain_by_device(psdev);\r\ngoto release;\r\n}\r\nif (!test_bit(_XEN_PCIB_AERHANDLER,\r\n(unsigned long *)&psdev->pdev->sh_info->flags)) {\r\ndev_err(&dev->dev,\r\n"guest with no AER driver should have been killed\n");\r\nkill_domain_by_device(psdev);\r\ngoto release;\r\n}\r\ncommon_process(psdev, 1, XEN_PCI_OP_aer_resume,\r\nPCI_ERS_RESULT_RECOVERED);\r\nrelease:\r\npcistub_device_put(psdev);\r\nend:\r\nup_write(&pcistub_sem);\r\nreturn;\r\n}\r\nstatic inline int str_to_slot(const char *buf, int *domain, int *bus,\r\nint *slot, int *func)\r\n{\r\nint err;\r\nerr = sscanf(buf, " %x:%x:%x.%x", domain, bus, slot, func);\r\nif (err == 4)\r\nreturn 0;\r\nelse if (err < 0)\r\nreturn -EINVAL;\r\n*domain = 0;\r\nerr = sscanf(buf, " %x:%x.%x", bus, slot, func);\r\nif (err == 3)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic inline int str_to_quirk(const char *buf, int *domain, int *bus, int\r\n*slot, int *func, int *reg, int *size, int *mask)\r\n{\r\nint err;\r\nerr =\r\nsscanf(buf, " %04x:%02x:%02x.%d-%08x:%1x:%08x", domain, bus, slot,\r\nfunc, reg, size, mask);\r\nif (err == 7)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int pcistub_device_id_add(int domain, int bus, int slot, int func)\r\n{\r\nstruct pcistub_device_id *pci_dev_id;\r\nunsigned long flags;\r\npci_dev_id = kmalloc(sizeof(*pci_dev_id), GFP_KERNEL);\r\nif (!pci_dev_id)\r\nreturn -ENOMEM;\r\npci_dev_id->domain = domain;\r\npci_dev_id->bus = bus;\r\npci_dev_id->devfn = PCI_DEVFN(slot, func);\r\npr_debug(DRV_NAME ": wants to seize %04x:%02x:%02x.%d\n",\r\ndomain, bus, slot, func);\r\nspin_lock_irqsave(&device_ids_lock, flags);\r\nlist_add_tail(&pci_dev_id->slot_list, &pcistub_device_ids);\r\nspin_unlock_irqrestore(&device_ids_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pcistub_device_id_remove(int domain, int bus, int slot, int func)\r\n{\r\nstruct pcistub_device_id *pci_dev_id, *t;\r\nint devfn = PCI_DEVFN(slot, func);\r\nint err = -ENOENT;\r\nunsigned long flags;\r\nspin_lock_irqsave(&device_ids_lock, flags);\r\nlist_for_each_entry_safe(pci_dev_id, t, &pcistub_device_ids,\r\nslot_list) {\r\nif (pci_dev_id->domain == domain\r\n&& pci_dev_id->bus == bus && pci_dev_id->devfn == devfn) {\r\nlist_del(&pci_dev_id->slot_list);\r\nkfree(pci_dev_id);\r\nerr = 0;\r\npr_debug(DRV_NAME ": removed %04x:%02x:%02x.%d from "\r\n"seize list\n", domain, bus, slot, func);\r\n}\r\n}\r\nspin_unlock_irqrestore(&device_ids_lock, flags);\r\nreturn err;\r\n}\r\nstatic int pcistub_reg_add(int domain, int bus, int slot, int func, int reg,\r\nint size, int mask)\r\n{\r\nint err = 0;\r\nstruct pcistub_device *psdev;\r\nstruct pci_dev *dev;\r\nstruct config_field *field;\r\npsdev = pcistub_device_find(domain, bus, slot, func);\r\nif (!psdev || !psdev->dev) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\ndev = psdev->dev;\r\nfield = kzalloc(sizeof(*field), GFP_ATOMIC);\r\nif (!field) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nfield->offset = reg;\r\nfield->size = size;\r\nfield->mask = mask;\r\nfield->init = NULL;\r\nfield->reset = NULL;\r\nfield->release = NULL;\r\nfield->clean = xen_pcibk_config_field_free;\r\nerr = xen_pcibk_config_quirks_add_field(dev, field);\r\nif (err)\r\nkfree(field);\r\nout:\r\nreturn err;\r\n}\r\nstatic ssize_t pcistub_slot_add(struct device_driver *drv, const char *buf,\r\nsize_t count)\r\n{\r\nint domain, bus, slot, func;\r\nint err;\r\nerr = str_to_slot(buf, &domain, &bus, &slot, &func);\r\nif (err)\r\ngoto out;\r\nerr = pcistub_device_id_add(domain, bus, slot, func);\r\nout:\r\nif (!err)\r\nerr = count;\r\nreturn err;\r\n}\r\nstatic ssize_t pcistub_slot_remove(struct device_driver *drv, const char *buf,\r\nsize_t count)\r\n{\r\nint domain, bus, slot, func;\r\nint err;\r\nerr = str_to_slot(buf, &domain, &bus, &slot, &func);\r\nif (err)\r\ngoto out;\r\nerr = pcistub_device_id_remove(domain, bus, slot, func);\r\nout:\r\nif (!err)\r\nerr = count;\r\nreturn err;\r\n}\r\nstatic ssize_t pcistub_slot_show(struct device_driver *drv, char *buf)\r\n{\r\nstruct pcistub_device_id *pci_dev_id;\r\nsize_t count = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&device_ids_lock, flags);\r\nlist_for_each_entry(pci_dev_id, &pcistub_device_ids, slot_list) {\r\nif (count >= PAGE_SIZE)\r\nbreak;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"%04x:%02x:%02x.%d\n",\r\npci_dev_id->domain, pci_dev_id->bus,\r\nPCI_SLOT(pci_dev_id->devfn),\r\nPCI_FUNC(pci_dev_id->devfn));\r\n}\r\nspin_unlock_irqrestore(&device_ids_lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t pcistub_irq_handler_show(struct device_driver *drv, char *buf)\r\n{\r\nstruct pcistub_device *psdev;\r\nstruct xen_pcibk_dev_data *dev_data;\r\nsize_t count = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (count >= PAGE_SIZE)\r\nbreak;\r\nif (!psdev->dev)\r\ncontinue;\r\ndev_data = pci_get_drvdata(psdev->dev);\r\nif (!dev_data)\r\ncontinue;\r\ncount +=\r\nscnprintf(buf + count, PAGE_SIZE - count,\r\n"%s:%s:%sing:%ld\n",\r\npci_name(psdev->dev),\r\ndev_data->isr_on ? "on" : "off",\r\ndev_data->ack_intr ? "ack" : "not ack",\r\ndev_data->handled);\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t pcistub_irq_handler_switch(struct device_driver *drv,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct pcistub_device *psdev;\r\nstruct xen_pcibk_dev_data *dev_data;\r\nint domain, bus, slot, func;\r\nint err = -ENOENT;\r\nerr = str_to_slot(buf, &domain, &bus, &slot, &func);\r\nif (err)\r\ngoto out;\r\npsdev = pcistub_device_find(domain, bus, slot, func);\r\nif (!psdev)\r\ngoto out;\r\ndev_data = pci_get_drvdata(psdev->dev);\r\nif (!dev_data)\r\ngoto out;\r\ndev_dbg(&psdev->dev->dev, "%s fake irq handler: %d->%d\n",\r\ndev_data->irq_name, dev_data->isr_on,\r\n!dev_data->isr_on);\r\ndev_data->isr_on = !(dev_data->isr_on);\r\nif (dev_data->isr_on)\r\ndev_data->ack_intr = 1;\r\nout:\r\nif (!err)\r\nerr = count;\r\nreturn err;\r\n}\r\nstatic ssize_t pcistub_quirk_add(struct device_driver *drv, const char *buf,\r\nsize_t count)\r\n{\r\nint domain, bus, slot, func, reg, size, mask;\r\nint err;\r\nerr = str_to_quirk(buf, &domain, &bus, &slot, &func, &reg, &size,\r\n&mask);\r\nif (err)\r\ngoto out;\r\nerr = pcistub_reg_add(domain, bus, slot, func, reg, size, mask);\r\nout:\r\nif (!err)\r\nerr = count;\r\nreturn err;\r\n}\r\nstatic ssize_t pcistub_quirk_show(struct device_driver *drv, char *buf)\r\n{\r\nint count = 0;\r\nunsigned long flags;\r\nstruct xen_pcibk_config_quirk *quirk;\r\nstruct xen_pcibk_dev_data *dev_data;\r\nconst struct config_field *field;\r\nconst struct config_field_entry *cfg_entry;\r\nspin_lock_irqsave(&device_ids_lock, flags);\r\nlist_for_each_entry(quirk, &xen_pcibk_quirks, quirks_list) {\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"%02x:%02x.%01x\n\t%04x:%04x:%04x:%04x\n",\r\nquirk->pdev->bus->number,\r\nPCI_SLOT(quirk->pdev->devfn),\r\nPCI_FUNC(quirk->pdev->devfn),\r\nquirk->devid.vendor, quirk->devid.device,\r\nquirk->devid.subvendor,\r\nquirk->devid.subdevice);\r\ndev_data = pci_get_drvdata(quirk->pdev);\r\nlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\r\nfield = cfg_entry->field;\r\nif (count >= PAGE_SIZE)\r\ngoto out;\r\ncount += scnprintf(buf + count, PAGE_SIZE - count,\r\n"\t\t%08x:%01x:%08x\n",\r\ncfg_entry->base_offset +\r\nfield->offset, field->size,\r\nfield->mask);\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&device_ids_lock, flags);\r\nreturn count;\r\n}\r\nstatic ssize_t permissive_add(struct device_driver *drv, const char *buf,\r\nsize_t count)\r\n{\r\nint domain, bus, slot, func;\r\nint err;\r\nstruct pcistub_device *psdev;\r\nstruct xen_pcibk_dev_data *dev_data;\r\nerr = str_to_slot(buf, &domain, &bus, &slot, &func);\r\nif (err)\r\ngoto out;\r\npsdev = pcistub_device_find(domain, bus, slot, func);\r\nif (!psdev) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (!psdev->dev) {\r\nerr = -ENODEV;\r\ngoto release;\r\n}\r\ndev_data = pci_get_drvdata(psdev->dev);\r\nif (!dev_data) {\r\nerr = -ENXIO;\r\ngoto release;\r\n}\r\nif (!dev_data->permissive) {\r\ndev_data->permissive = 1;\r\ndev_warn(&psdev->dev->dev, "enabling permissive mode "\r\n"configuration space accesses!\n");\r\ndev_warn(&psdev->dev->dev,\r\n"permissive mode is potentially unsafe!\n");\r\n}\r\nrelease:\r\npcistub_device_put(psdev);\r\nout:\r\nif (!err)\r\nerr = count;\r\nreturn err;\r\n}\r\nstatic ssize_t permissive_show(struct device_driver *drv, char *buf)\r\n{\r\nstruct pcistub_device *psdev;\r\nstruct xen_pcibk_dev_data *dev_data;\r\nsize_t count = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcistub_devices_lock, flags);\r\nlist_for_each_entry(psdev, &pcistub_devices, dev_list) {\r\nif (count >= PAGE_SIZE)\r\nbreak;\r\nif (!psdev->dev)\r\ncontinue;\r\ndev_data = pci_get_drvdata(psdev->dev);\r\nif (!dev_data || !dev_data->permissive)\r\ncontinue;\r\ncount +=\r\nscnprintf(buf + count, PAGE_SIZE - count, "%s\n",\r\npci_name(psdev->dev));\r\n}\r\nspin_unlock_irqrestore(&pcistub_devices_lock, flags);\r\nreturn count;\r\n}\r\nstatic void pcistub_exit(void)\r\n{\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver, &driver_attr_new_slot);\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_remove_slot);\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver, &driver_attr_slots);\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver, &driver_attr_quirks);\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_permissive);\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_irq_handlers);\r\ndriver_remove_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_irq_handler_state);\r\npci_unregister_driver(&xen_pcibk_pci_driver);\r\n}\r\nstatic int __init pcistub_init(void)\r\n{\r\nint pos = 0;\r\nint err = 0;\r\nint domain, bus, slot, func;\r\nint parsed;\r\nif (pci_devs_to_hide && *pci_devs_to_hide) {\r\ndo {\r\nparsed = 0;\r\nerr = sscanf(pci_devs_to_hide + pos,\r\n" (%x:%x:%x.%x) %n",\r\n&domain, &bus, &slot, &func, &parsed);\r\nif (err != 4) {\r\ndomain = 0;\r\nerr = sscanf(pci_devs_to_hide + pos,\r\n" (%x:%x.%x) %n",\r\n&bus, &slot, &func, &parsed);\r\nif (err != 3)\r\ngoto parse_error;\r\n}\r\nerr = pcistub_device_id_add(domain, bus, slot, func);\r\nif (err)\r\ngoto out;\r\npos += parsed;\r\n} while (parsed > 0 && pci_devs_to_hide[pos]);\r\n}\r\nerr = pci_register_driver(&xen_pcibk_pci_driver);\r\nif (err < 0)\r\ngoto out;\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_new_slot);\r\nif (!err)\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_remove_slot);\r\nif (!err)\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_slots);\r\nif (!err)\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_quirks);\r\nif (!err)\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_permissive);\r\nif (!err)\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_irq_handlers);\r\nif (!err)\r\nerr = driver_create_file(&xen_pcibk_pci_driver.driver,\r\n&driver_attr_irq_handler_state);\r\nif (err)\r\npcistub_exit();\r\nout:\r\nreturn err;\r\nparse_error:\r\nprintk(KERN_ERR DRV_NAME ": Error parsing pci_devs_to_hide at \"%s\"\n",\r\npci_devs_to_hide + pos);\r\nreturn -EINVAL;\r\n}\r\nstatic int __init xen_pcibk_init(void)\r\n{\r\nint err;\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nerr = xen_pcibk_config_init();\r\nif (err)\r\nreturn err;\r\n#ifdef MODULE\r\nerr = pcistub_init();\r\nif (err < 0)\r\nreturn err;\r\n#endif\r\npcistub_init_devices_late();\r\nerr = xen_pcibk_xenbus_register();\r\nif (err)\r\npcistub_exit();\r\nreturn err;\r\n}\r\nstatic void __exit xen_pcibk_cleanup(void)\r\n{\r\nxen_pcibk_xenbus_unregister();\r\npcistub_exit();\r\n}
