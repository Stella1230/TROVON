int dcd_auto_register(struct dcd_manager *hdcd_mgr,\r\nchar *sz_coff_path)\r\n{\r\nint status = 0;\r\nif (hdcd_mgr)\r\nstatus = dcd_get_objects(hdcd_mgr, sz_coff_path,\r\n(dcd_registerfxn) dcd_register_object,\r\n(void *)sz_coff_path);\r\nelse\r\nstatus = -EFAULT;\r\nreturn status;\r\n}\r\nint dcd_auto_unregister(struct dcd_manager *hdcd_mgr,\r\nchar *sz_coff_path)\r\n{\r\nint status = 0;\r\nif (hdcd_mgr)\r\nstatus = dcd_get_objects(hdcd_mgr, sz_coff_path,\r\n(dcd_registerfxn) dcd_register_object,\r\nNULL);\r\nelse\r\nstatus = -EFAULT;\r\nreturn status;\r\n}\r\nint dcd_create_manager(char *sz_zl_dll_name,\r\nstruct dcd_manager **dcd_mgr)\r\n{\r\nstruct cod_manager *cod_mgr;\r\nstruct dcd_manager *dcd_mgr_obj = NULL;\r\nint status = 0;\r\nstatus = cod_create(&cod_mgr, sz_zl_dll_name);\r\nif (status)\r\ngoto func_end;\r\ndcd_mgr_obj = kzalloc(sizeof(struct dcd_manager), GFP_KERNEL);\r\nif (dcd_mgr_obj != NULL) {\r\ndcd_mgr_obj->cod_mgr = cod_mgr;\r\n*dcd_mgr = dcd_mgr_obj;\r\n} else {\r\nstatus = -ENOMEM;\r\ncod_delete(cod_mgr);\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nint dcd_destroy_manager(struct dcd_manager *hdcd_mgr)\r\n{\r\nstruct dcd_manager *dcd_mgr_obj = hdcd_mgr;\r\nint status = -EFAULT;\r\nif (hdcd_mgr) {\r\ncod_delete(dcd_mgr_obj->cod_mgr);\r\nkfree(dcd_mgr_obj);\r\nstatus = 0;\r\n}\r\nreturn status;\r\n}\r\nint dcd_enumerate_object(s32 index, enum dsp_dcdobjtype obj_type,\r\nstruct dsp_uuid *uuid_obj)\r\n{\r\nint status = 0;\r\nchar sz_reg_key[DCD_MAXPATHLENGTH];\r\nchar sz_value[DCD_MAXPATHLENGTH];\r\nstruct dsp_uuid dsp_uuid_obj;\r\nchar sz_obj_type[MAX_INT2CHAR_LENGTH];\r\nu32 dw_key_len = 0;\r\nstruct dcd_key_elem *dcd_key;\r\nint len;\r\nif ((index != 0) && (enum_refs == 0)) {\r\nstatus = -EIDRM;\r\n} else {\r\ndw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;\r\nstrncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);\r\nif ((strlen(sz_reg_key) + strlen("_\0")) <\r\nDCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, "_\0", 2);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nstatus = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d",\r\nobj_type);\r\nif (status == -1) {\r\nstatus = -EPERM;\r\n} else {\r\nstatus = 0;\r\nif ((strlen(sz_reg_key) + strlen(sz_obj_type)) <\r\nDCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, sz_obj_type,\r\nstrlen(sz_obj_type) + 1);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\n}\r\nif (!status) {\r\nlen = strlen(sz_reg_key);\r\nspin_lock(&dbdcd_lock);\r\nlist_for_each_entry(dcd_key, &reg_key_list, link) {\r\nif (!strncmp(dcd_key->name, sz_reg_key, len)\r\n&& !index--) {\r\nstrncpy(sz_value, &dcd_key->name[len],\r\nstrlen(&dcd_key->name[len]) + 1);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dbdcd_lock);\r\nif (&dcd_key->link == &reg_key_list)\r\nstatus = -ENODATA;\r\n}\r\nif (!status) {\r\nuuid_uuid_from_string(sz_value, &dsp_uuid_obj);\r\n*uuid_obj = dsp_uuid_obj;\r\nenum_refs++;\r\nstatus = 0;\r\n} else if (status == -ENODATA) {\r\nenum_refs = 0;\r\nstatus = ENODATA;\r\n} else {\r\nstatus = -EPERM;\r\n}\r\n}\r\nreturn status;\r\n}\r\nvoid dcd_exit(void)\r\n{\r\nstruct dcd_key_elem *rv, *rv_tmp;\r\nrefs--;\r\nif (refs == 0) {\r\nlist_for_each_entry_safe(rv, rv_tmp, &reg_key_list, link) {\r\nlist_del(&rv->link);\r\nkfree(rv->path);\r\nkfree(rv);\r\n}\r\n}\r\n}\r\nint dcd_get_dep_libs(struct dcd_manager *hdcd_mgr,\r\nstruct dsp_uuid *uuid_obj,\r\nu16 num_libs, struct dsp_uuid *dep_lib_uuids,\r\nbool *prstnt_dep_libs,\r\nenum nldr_phase phase)\r\n{\r\nint status = 0;\r\nstatus =\r\nget_dep_lib_info(hdcd_mgr, uuid_obj, &num_libs, NULL, dep_lib_uuids,\r\nprstnt_dep_libs, phase);\r\nreturn status;\r\n}\r\nint dcd_get_num_dep_libs(struct dcd_manager *hdcd_mgr,\r\nstruct dsp_uuid *uuid_obj,\r\nu16 *num_libs, u16 *num_pers_libs,\r\nenum nldr_phase phase)\r\n{\r\nint status = 0;\r\nstatus = get_dep_lib_info(hdcd_mgr, uuid_obj, num_libs, num_pers_libs,\r\nNULL, NULL, phase);\r\nreturn status;\r\n}\r\nint dcd_get_object_def(struct dcd_manager *hdcd_mgr,\r\nstruct dsp_uuid *obj_uuid,\r\nenum dsp_dcdobjtype obj_type,\r\nstruct dcd_genericobj *obj_def)\r\n{\r\nstruct dcd_manager *dcd_mgr_obj = hdcd_mgr;\r\nstruct cod_libraryobj *lib = NULL;\r\nint status = 0;\r\nu32 ul_addr = 0;\r\nu32 ul_len = 0;\r\nu32 dw_buf_size;\r\nchar sz_reg_key[DCD_MAXPATHLENGTH];\r\nchar *sz_uuid;\r\nstruct dcd_key_elem *dcd_key = NULL;\r\nchar sz_sect_name[MAXUUIDLEN + 2];\r\nchar *psz_coff_buf;\r\nu32 dw_key_len;\r\nchar sz_obj_type[MAX_INT2CHAR_LENGTH];\r\nsz_uuid = kzalloc(MAXUUIDLEN, GFP_KERNEL);\r\nif (!sz_uuid) {\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\nif (!hdcd_mgr) {\r\nstatus = -EFAULT;\r\ngoto func_end;\r\n}\r\ndw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;\r\nstrncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);\r\nif ((strlen(sz_reg_key) + strlen("_\0")) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, "_\0", 2);\r\nelse\r\nstatus = -EPERM;\r\nstatus = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);\r\nif (status == -1) {\r\nstatus = -EPERM;\r\n} else {\r\nstatus = 0;\r\nif ((strlen(sz_reg_key) + strlen(sz_obj_type)) <\r\nDCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, sz_obj_type,\r\nstrlen(sz_obj_type) + 1);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nuuid_uuid_to_string(obj_uuid, sz_uuid, MAXUUIDLEN);\r\nif ((strlen(sz_reg_key) + MAXUUIDLEN) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, sz_uuid, MAXUUIDLEN);\r\nelse\r\nstatus = -EPERM;\r\ndw_buf_size = DCD_MAXPATHLENGTH;\r\n}\r\nif (!status) {\r\nspin_lock(&dbdcd_lock);\r\nlist_for_each_entry(dcd_key, &reg_key_list, link) {\r\nif (!strncmp(dcd_key->name, sz_reg_key,\r\nstrlen(sz_reg_key) + 1))\r\nbreak;\r\n}\r\nspin_unlock(&dbdcd_lock);\r\nif (&dcd_key->link == &reg_key_list) {\r\nstatus = -ENOKEY;\r\ngoto func_end;\r\n}\r\n}\r\nstatus = cod_open(dcd_mgr_obj->cod_mgr, dcd_key->path,\r\nCOD_NOLOAD, &lib);\r\nif (status) {\r\nstatus = -EACCES;\r\ngoto func_end;\r\n}\r\nstrncpy(sz_sect_name, ".", 2);\r\nstrncat(sz_sect_name, sz_uuid, strlen(sz_uuid));\r\nstatus = cod_get_section(lib, sz_sect_name, &ul_addr, &ul_len);\r\nif (status) {\r\nstatus = -EACCES;\r\ngoto func_end;\r\n}\r\npsz_coff_buf = kzalloc(ul_len + 4, GFP_KERNEL);\r\nif (psz_coff_buf == NULL) {\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\n#ifdef _DB_TIOMAP\r\nif (strstr(dcd_key->path, "iva") == NULL) {\r\nstatus =\r\ncod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);\r\n} else {\r\nstatus =\r\ncod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);\r\ndev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);\r\n}\r\n#else\r\nstatus = cod_read_section(lib, sz_sect_name, psz_coff_buf, ul_len);\r\n#endif\r\nif (!status) {\r\nif (strstr(dcd_key->path, "iva") == NULL) {\r\ncompress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);\r\n} else {\r\ncompress_buf(psz_coff_buf, ul_len, 1);\r\ndev_dbg(bridge, "%s: Compressing IVA COFF buffer by 1 "\r\n"for IVA!!\n", __func__);\r\n}\r\nstatus =\r\nget_attrs_from_buf(psz_coff_buf, ul_len, obj_type, obj_def);\r\nif (status)\r\nstatus = -EACCES;\r\n} else {\r\nstatus = -EACCES;\r\n}\r\nkfree(psz_coff_buf);\r\nfunc_end:\r\nif (lib)\r\ncod_close(lib);\r\nkfree(sz_uuid);\r\nreturn status;\r\n}\r\nint dcd_get_objects(struct dcd_manager *hdcd_mgr,\r\nchar *sz_coff_path, dcd_registerfxn register_fxn,\r\nvoid *handle)\r\n{\r\nstruct dcd_manager *dcd_mgr_obj = hdcd_mgr;\r\nint status = 0;\r\nchar *psz_coff_buf;\r\nchar *psz_cur;\r\nstruct cod_libraryobj *lib = NULL;\r\nu32 ul_addr = 0;\r\nu32 ul_len = 0;\r\nchar seps[] = ":, ";\r\nchar *token = NULL;\r\nstruct dsp_uuid dsp_uuid_obj;\r\ns32 object_type;\r\nif (!hdcd_mgr) {\r\nstatus = -EFAULT;\r\ngoto func_end;\r\n}\r\nstatus = cod_open(dcd_mgr_obj->cod_mgr, sz_coff_path, COD_NOLOAD, &lib);\r\nif (status) {\r\nstatus = -EACCES;\r\ngoto func_cont;\r\n}\r\nstatus = cod_get_section(lib, DCD_REGISTER_SECTION, &ul_addr, &ul_len);\r\nif (status || !(ul_len > 0)) {\r\nstatus = -EACCES;\r\ngoto func_cont;\r\n}\r\npsz_coff_buf = kzalloc(ul_len + 4, GFP_KERNEL);\r\nif (psz_coff_buf == NULL) {\r\nstatus = -ENOMEM;\r\ngoto func_cont;\r\n}\r\n#ifdef _DB_TIOMAP\r\nif (strstr(sz_coff_path, "iva") == NULL) {\r\nstatus = cod_read_section(lib, DCD_REGISTER_SECTION,\r\npsz_coff_buf, ul_len);\r\n} else {\r\ndev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);\r\nstatus = cod_read_section(lib, DCD_REGISTER_SECTION,\r\npsz_coff_buf, ul_len);\r\n}\r\n#else\r\nstatus =\r\ncod_read_section(lib, DCD_REGISTER_SECTION, psz_coff_buf, ul_len);\r\n#endif\r\nif (!status) {\r\nif (strstr(sz_coff_path, "iva") == NULL) {\r\ncompress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);\r\n} else {\r\ncompress_buf(psz_coff_buf, ul_len, 1);\r\ndev_dbg(bridge, "%s: Compress COFF buffer with 1 word "\r\n"for IVA!!\n", __func__);\r\n}\r\npsz_cur = psz_coff_buf;\r\nwhile ((token = strsep(&psz_cur, seps)) && *token != '\0') {\r\nuuid_uuid_from_string(token, &dsp_uuid_obj);\r\ntoken = strsep(&psz_cur, seps);\r\nobject_type = atoi(token);\r\nstatus =\r\nregister_fxn(&dsp_uuid_obj, object_type, handle);\r\nif (status) {\r\nbreak;\r\n}\r\n}\r\n} else {\r\nstatus = -EACCES;\r\n}\r\nkfree(psz_coff_buf);\r\nfunc_cont:\r\nif (lib)\r\ncod_close(lib);\r\nfunc_end:\r\nreturn status;\r\n}\r\nint dcd_get_library_name(struct dcd_manager *hdcd_mgr,\r\nstruct dsp_uuid *uuid_obj,\r\nchar *str_lib_name,\r\nu32 *buff_size,\r\nenum nldr_phase phase, bool *phase_split)\r\n{\r\nchar sz_reg_key[DCD_MAXPATHLENGTH];\r\nchar sz_uuid[MAXUUIDLEN];\r\nu32 dw_key_len;\r\nchar sz_obj_type[MAX_INT2CHAR_LENGTH];\r\nint status = 0;\r\nstruct dcd_key_elem *dcd_key = NULL;\r\ndev_dbg(bridge, "%s: hdcd_mgr %p, uuid_obj %p, str_lib_name %p,"\r\n" buff_size %p\n", __func__, hdcd_mgr, uuid_obj, str_lib_name,\r\nbuff_size);\r\ndw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;\r\nstrncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);\r\nif ((strlen(sz_reg_key) + strlen("_\0")) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, "_\0", 2);\r\nelse\r\nstatus = -EPERM;\r\nswitch (phase) {\r\ncase NLDR_CREATE:\r\nsprintf(sz_obj_type, "%d", DSP_DCDCREATELIBTYPE);\r\nbreak;\r\ncase NLDR_EXECUTE:\r\nsprintf(sz_obj_type, "%d", DSP_DCDEXECUTELIBTYPE);\r\nbreak;\r\ncase NLDR_DELETE:\r\nsprintf(sz_obj_type, "%d", DSP_DCDDELETELIBTYPE);\r\nbreak;\r\ncase NLDR_NOPHASE:\r\nsprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nif (!status) {\r\nif ((strlen(sz_reg_key) + strlen(sz_obj_type)) <\r\nDCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, sz_obj_type,\r\nstrlen(sz_obj_type) + 1);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nuuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);\r\nif ((strlen(sz_reg_key) + MAXUUIDLEN) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, sz_uuid, MAXUUIDLEN);\r\nelse\r\nstatus = -EPERM;\r\n}\r\nif (!status) {\r\nspin_lock(&dbdcd_lock);\r\nlist_for_each_entry(dcd_key, &reg_key_list, link) {\r\nif (!strncmp(dcd_key->name, sz_reg_key,\r\nstrlen(sz_reg_key) + 1))\r\nbreak;\r\n}\r\nspin_unlock(&dbdcd_lock);\r\n}\r\nif (&dcd_key->link == &reg_key_list)\r\nstatus = -ENOKEY;\r\nif (status && phase != NLDR_NOPHASE) {\r\nif (phase_split)\r\n*phase_split = false;\r\nstrncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);\r\nif ((strlen(sz_reg_key) + strlen("_\0")) <\r\nDCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, "_\0", 2);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nsprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);\r\nif ((strlen(sz_reg_key) + strlen(sz_obj_type))\r\n< DCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, sz_obj_type,\r\nstrlen(sz_obj_type) + 1);\r\n} else {\r\nstatus = -EPERM;\r\n}\r\nuuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);\r\nif ((strlen(sz_reg_key) + MAXUUIDLEN) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, sz_uuid, MAXUUIDLEN);\r\nelse\r\nstatus = -EPERM;\r\nspin_lock(&dbdcd_lock);\r\nlist_for_each_entry(dcd_key, &reg_key_list, link) {\r\nif (!strncmp(dcd_key->name, sz_reg_key,\r\nstrlen(sz_reg_key) + 1))\r\nbreak;\r\n}\r\nspin_unlock(&dbdcd_lock);\r\nstatus = (&dcd_key->link != &reg_key_list) ?\r\n0 : -ENOKEY;\r\n}\r\nif (!status)\r\nmemcpy(str_lib_name, dcd_key->path, strlen(dcd_key->path) + 1);\r\nreturn status;\r\n}\r\nbool dcd_init(void)\r\n{\r\nbool ret = true;\r\nif (refs == 0)\r\nINIT_LIST_HEAD(&reg_key_list);\r\nif (ret)\r\nrefs++;\r\nreturn ret;\r\n}\r\nint dcd_register_object(struct dsp_uuid *uuid_obj,\r\nenum dsp_dcdobjtype obj_type,\r\nchar *psz_path_name)\r\n{\r\nint status = 0;\r\nchar sz_reg_key[DCD_MAXPATHLENGTH];\r\nchar sz_uuid[MAXUUIDLEN + 1];\r\nu32 dw_path_size = 0;\r\nu32 dw_key_len;\r\nchar sz_obj_type[MAX_INT2CHAR_LENGTH];\r\nstruct dcd_key_elem *dcd_key = NULL;\r\ndev_dbg(bridge, "%s: object UUID %p, obj_type %d, szPathName %s\n",\r\n__func__, uuid_obj, obj_type, psz_path_name);\r\ndw_key_len = strlen(DCD_REGKEY) + 1 + sizeof(sz_obj_type) + 1;\r\nstrncpy(sz_reg_key, DCD_REGKEY, strlen(DCD_REGKEY) + 1);\r\nif ((strlen(sz_reg_key) + strlen("_\0")) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, "_\0", 2);\r\nelse {\r\nstatus = -EPERM;\r\ngoto func_end;\r\n}\r\nstatus = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);\r\nif (status == -1) {\r\nstatus = -EPERM;\r\n} else {\r\nstatus = 0;\r\nif ((strlen(sz_reg_key) + strlen(sz_obj_type)) <\r\nDCD_MAXPATHLENGTH) {\r\nstrncat(sz_reg_key, sz_obj_type,\r\nstrlen(sz_obj_type) + 1);\r\n} else\r\nstatus = -EPERM;\r\nuuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);\r\nif ((strlen(sz_reg_key) + MAXUUIDLEN) < DCD_MAXPATHLENGTH)\r\nstrncat(sz_reg_key, sz_uuid, MAXUUIDLEN);\r\nelse\r\nstatus = -EPERM;\r\n}\r\nif (status)\r\ngoto func_end;\r\nif (psz_path_name) {\r\ndw_path_size = strlen(psz_path_name) + 1;\r\nspin_lock(&dbdcd_lock);\r\nlist_for_each_entry(dcd_key, &reg_key_list, link) {\r\nif (!strncmp(dcd_key->name, sz_reg_key,\r\nstrlen(sz_reg_key) + 1))\r\nbreak;\r\n}\r\nspin_unlock(&dbdcd_lock);\r\nif (&dcd_key->link == &reg_key_list) {\r\ndcd_key = kmalloc(sizeof(struct dcd_key_elem),\r\nGFP_KERNEL);\r\nif (!dcd_key) {\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\ndcd_key->path = kmalloc(strlen(sz_reg_key) + 1,\r\nGFP_KERNEL);\r\nif (!dcd_key->path) {\r\nkfree(dcd_key);\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\nstrncpy(dcd_key->name, sz_reg_key,\r\nstrlen(sz_reg_key) + 1);\r\nstrncpy(dcd_key->path, psz_path_name ,\r\ndw_path_size);\r\nspin_lock(&dbdcd_lock);\r\nlist_add_tail(&dcd_key->link, &reg_key_list);\r\nspin_unlock(&dbdcd_lock);\r\n} else {\r\nif (strncmp(dcd_key->path, psz_path_name,\r\ndw_path_size)) {\r\nkfree(dcd_key->path);\r\ndcd_key->path = kmalloc(dw_path_size,\r\nGFP_KERNEL);\r\nif (dcd_key->path == NULL) {\r\nstatus = -ENOMEM;\r\ngoto func_end;\r\n}\r\n}\r\nmemcpy(dcd_key->path, psz_path_name, dw_path_size);\r\n}\r\ndev_dbg(bridge, "%s: psz_path_name=%s, dw_path_size=%d\n",\r\n__func__, psz_path_name, dw_path_size);\r\n} else {\r\nspin_lock(&dbdcd_lock);\r\nlist_for_each_entry(dcd_key, &reg_key_list, link) {\r\nif (!strncmp(dcd_key->name, sz_reg_key,\r\nstrlen(sz_reg_key) + 1)) {\r\nlist_del(&dcd_key->link);\r\nkfree(dcd_key->path);\r\nkfree(dcd_key);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dbdcd_lock);\r\nif (&dcd_key->link == &reg_key_list)\r\nstatus = -EPERM;\r\n}\r\nif (!status) {\r\nenum_refs = 0;\r\n}\r\nfunc_end:\r\nreturn status;\r\n}\r\nint dcd_unregister_object(struct dsp_uuid *uuid_obj,\r\nenum dsp_dcdobjtype obj_type)\r\n{\r\nint status = 0;\r\nstatus = dcd_register_object(uuid_obj, obj_type, NULL);\r\nreturn status;\r\n}\r\nstatic s32 atoi(char *psz_buf)\r\n{\r\nchar *pch = psz_buf;\r\ns32 base = 0;\r\nwhile (isspace(*pch))\r\npch++;\r\nif (*pch == '-' || *pch == '+') {\r\nbase = 10;\r\npch++;\r\n} else if (*pch && tolower(pch[strlen(pch) - 1]) == 'h') {\r\nbase = 16;\r\n}\r\nreturn simple_strtoul(pch, NULL, base);\r\n}\r\nstatic int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,\r\nenum dsp_dcdobjtype obj_type,\r\nstruct dcd_genericobj *gen_obj)\r\n{\r\nint status = 0;\r\nchar seps[] = ", ";\r\nchar *psz_cur;\r\nchar *token;\r\ns32 token_len = 0;\r\nu32 i = 0;\r\n#ifdef _DB_TIOMAP\r\ns32 entry_id;\r\n#endif\r\nswitch (obj_type) {\r\ncase DSP_DCDNODETYPE:\r\npsz_cur = psz_buf;\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.cb_struct =\r\n(u32) atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\nuuid_uuid_from_string(token,\r\n&gen_obj->obj_data.node_obj.ndb_props.\r\nui_node_id);\r\ntoken = strsep(&psz_cur, seps);\r\ntoken_len = strlen(token);\r\nif (token_len > DSP_MAXNAMELEN - 1)\r\ntoken_len = DSP_MAXNAMELEN - 1;\r\nstrncpy(gen_obj->obj_data.node_obj.ndb_props.ac_name,\r\ntoken, token_len);\r\ngen_obj->obj_data.node_obj.ndb_props.ac_name[token_len] = '\0';\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.ntype = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.cache_on_gpp = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.dsp_resource_reqmts.\r\ncb_struct = (u32) atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.static_data_size = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.global_data_size = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.program_mem_size = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.wc_execution_time = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.wc_period = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.wc_deadline = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.avg_exection_time = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.\r\ndsp_resource_reqmts.minimum_period = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.prio = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.stack_size = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.sys_stack_size =\r\natoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.stack_seg = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.message_depth =\r\natoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.num_input_streams =\r\natoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.num_output_streams =\r\natoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.ndb_props.timeout = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ntoken_len = strlen(token);\r\ngen_obj->obj_data.node_obj.str_create_phase_fxn =\r\nkzalloc(token_len + 1, GFP_KERNEL);\r\nstrncpy(gen_obj->obj_data.node_obj.str_create_phase_fxn,\r\ntoken, token_len);\r\ngen_obj->obj_data.node_obj.str_create_phase_fxn[token_len] =\r\n'\0';\r\ntoken = strsep(&psz_cur, seps);\r\ntoken_len = strlen(token);\r\ngen_obj->obj_data.node_obj.str_execute_phase_fxn =\r\nkzalloc(token_len + 1, GFP_KERNEL);\r\nstrncpy(gen_obj->obj_data.node_obj.str_execute_phase_fxn,\r\ntoken, token_len);\r\ngen_obj->obj_data.node_obj.str_execute_phase_fxn[token_len] =\r\n'\0';\r\ntoken = strsep(&psz_cur, seps);\r\ntoken_len = strlen(token);\r\ngen_obj->obj_data.node_obj.str_delete_phase_fxn =\r\nkzalloc(token_len + 1, GFP_KERNEL);\r\nstrncpy(gen_obj->obj_data.node_obj.str_delete_phase_fxn,\r\ntoken, token_len);\r\ngen_obj->obj_data.node_obj.str_delete_phase_fxn[token_len] =\r\n'\0';\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.msg_segid = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.node_obj.msg_notify_type = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\nif (token) {\r\ntoken_len = strlen(token);\r\ngen_obj->obj_data.node_obj.str_i_alg_name =\r\nkzalloc(token_len + 1, GFP_KERNEL);\r\nstrncpy(gen_obj->obj_data.node_obj.str_i_alg_name,\r\ntoken, token_len);\r\ngen_obj->obj_data.node_obj.str_i_alg_name[token_len] =\r\n'\0';\r\ntoken = strsep(&psz_cur, seps);\r\n}\r\nif (token) {\r\ngen_obj->obj_data.node_obj.load_type = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\n}\r\nif (token) {\r\ngen_obj->obj_data.node_obj.data_mem_seg_mask =\r\natoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\n}\r\nif (token) {\r\ngen_obj->obj_data.node_obj.code_mem_seg_mask =\r\natoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\n}\r\nif (token) {\r\ngen_obj->obj_data.node_obj.ndb_props.count_profiles =\r\natoi(token);\r\nfor (i = 0;\r\ni <\r\ngen_obj->obj_data.node_obj.\r\nndb_props.count_profiles; i++) {\r\ntoken = strsep(&psz_cur, seps);\r\nif (token) {\r\ngen_obj->obj_data.node_obj.\r\nndb_props.node_profiles[i].\r\nheap_size = atoi(token);\r\n}\r\n}\r\n}\r\ntoken = strsep(&psz_cur, seps);\r\nif (token) {\r\ngen_obj->obj_data.node_obj.ndb_props.stack_seg_name =\r\n(u32) (token);\r\n}\r\nbreak;\r\ncase DSP_DCDPROCESSORTYPE:\r\npsz_cur = psz_buf;\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.cb_struct = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.processor_family = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.processor_type = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.clock_rate = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.internal_mem_size = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.external_mem_size = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.processor_id = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.ty_running_rtos = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.node_min_priority = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.proc_info.node_max_priority = atoi(token);\r\n#ifdef _DB_TIOMAP\r\nfor (entry_id = 0; entry_id < 7; entry_id++) {\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.ext_proc_obj.ty_tlb[entry_id].\r\ngpp_phys = atoi(token);\r\ntoken = strsep(&psz_cur, seps);\r\ngen_obj->obj_data.ext_proc_obj.ty_tlb[entry_id].\r\ndsp_virt = atoi(token);\r\n}\r\n#endif\r\nbreak;\r\ndefault:\r\nstatus = -EPERM;\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic void compress_buf(char *psz_buf, u32 ul_buf_size, s32 char_size)\r\n{\r\nchar *p;\r\nchar ch;\r\nchar *q;\r\np = psz_buf;\r\nif (p == NULL)\r\nreturn;\r\nfor (q = psz_buf; q < (psz_buf + ul_buf_size);) {\r\nch = dsp_char2_gpp_char(q, char_size);\r\nif (ch == '\\') {\r\nq += char_size;\r\nch = dsp_char2_gpp_char(q, char_size);\r\nswitch (ch) {\r\ncase 't':\r\n*p = '\t';\r\nbreak;\r\ncase 'n':\r\n*p = '\n';\r\nbreak;\r\ncase 'r':\r\n*p = '\r';\r\nbreak;\r\ncase '0':\r\n*p = '\0';\r\nbreak;\r\ndefault:\r\n*p = ch;\r\nbreak;\r\n}\r\n} else {\r\n*p = ch;\r\n}\r\np++;\r\nq += char_size;\r\n}\r\nwhile (p < q)\r\n*p++ = '\0';\r\n}\r\nstatic char dsp_char2_gpp_char(char *word, s32 dsp_char_size)\r\n{\r\nchar ch = '\0';\r\nchar *ch_src;\r\ns32 i;\r\nfor (ch_src = word, i = dsp_char_size; i > 0; i--)\r\nch |= *ch_src++;\r\nreturn ch;\r\n}\r\nstatic int get_dep_lib_info(struct dcd_manager *hdcd_mgr,\r\nstruct dsp_uuid *uuid_obj,\r\nu16 *num_libs,\r\nu16 *num_pers_libs,\r\nstruct dsp_uuid *dep_lib_uuids,\r\nbool *prstnt_dep_libs,\r\nenum nldr_phase phase)\r\n{\r\nstruct dcd_manager *dcd_mgr_obj = hdcd_mgr;\r\nchar *psz_coff_buf = NULL;\r\nchar *psz_cur;\r\nchar *psz_file_name = NULL;\r\nstruct cod_libraryobj *lib = NULL;\r\nu32 ul_addr = 0;\r\nu32 ul_len = 0;\r\nu32 dw_data_size = COD_MAXPATHLENGTH;\r\nchar seps[] = ", ";\r\nchar *token = NULL;\r\nbool get_uuids = (dep_lib_uuids != NULL);\r\nu16 dep_libs = 0;\r\nint status = 0;\r\nif (!get_uuids) {\r\n*num_libs = 0;\r\n*num_pers_libs = 0;\r\n}\r\npsz_file_name = kzalloc(dw_data_size, GFP_KERNEL);\r\nif (psz_file_name == NULL) {\r\nstatus = -ENOMEM;\r\n} else {\r\nstatus = dcd_get_library_name(hdcd_mgr, uuid_obj, psz_file_name,\r\n&dw_data_size, phase, NULL);\r\n}\r\nif (!status) {\r\nstatus = cod_open(dcd_mgr_obj->cod_mgr, psz_file_name,\r\nCOD_NOLOAD, &lib);\r\n}\r\nif (!status) {\r\nstatus = cod_get_section(lib, DEPLIBSECT, &ul_addr, &ul_len);\r\nif (status) {\r\nul_len = 0;\r\nstatus = 0;\r\n}\r\n}\r\nif (status || !(ul_len > 0))\r\ngoto func_cont;\r\npsz_coff_buf = kzalloc(ul_len + 4, GFP_KERNEL);\r\nif (psz_coff_buf == NULL)\r\nstatus = -ENOMEM;\r\nstatus = cod_read_section(lib, DEPLIBSECT, psz_coff_buf, ul_len);\r\nif (status)\r\ngoto func_cont;\r\ncompress_buf(psz_coff_buf, ul_len, DSPWORDSIZE);\r\npsz_cur = psz_coff_buf;\r\nwhile ((token = strsep(&psz_cur, seps)) && *token != '\0') {\r\nif (get_uuids) {\r\nif (dep_libs >= *num_libs) {\r\nbreak;\r\n} else {\r\nuuid_uuid_from_string(token,\r\n&(dep_lib_uuids\r\n[dep_libs]));\r\ntoken = strsep(&psz_cur, seps);\r\nprstnt_dep_libs[dep_libs] = atoi(token);\r\ndep_libs++;\r\n}\r\n} else {\r\ntoken = strsep(&psz_cur, seps);\r\nif (atoi(token))\r\n(*num_pers_libs)++;\r\n(*num_libs)++;\r\n}\r\n}\r\nfunc_cont:\r\nif (lib)\r\ncod_close(lib);\r\nkfree(psz_file_name);\r\nkfree(psz_coff_buf);\r\nreturn status;\r\n}
