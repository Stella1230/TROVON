static inline u64 readq(void __iomem *addr)\r\n{\r\nreturn readl(addr) | (((u64) readl(addr + 4)) << 32LL);\r\n}\r\nstatic inline void writeq(u64 val, void __iomem *addr)\r\n{\r\nwritel(((u32) (val)), (addr));\r\nwritel(((u32) (val >> 32)), (addr + 4));\r\n}\r\nint\r\nqlcnic_pcie_sem_lock(struct qlcnic_adapter *adapter, int sem, u32 id_reg)\r\n{\r\nint done = 0, timeout = 0;\r\nwhile (!done) {\r\ndone = QLCRD32(adapter, QLCNIC_PCIE_REG(PCIE_SEM_LOCK(sem)));\r\nif (done == 1)\r\nbreak;\r\nif (++timeout >= QLCNIC_PCIE_SEM_TIMEOUT) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to acquire sem=%d lock; holdby=%d\n",\r\nsem, id_reg ? QLCRD32(adapter, id_reg) : -1);\r\nreturn -EIO;\r\n}\r\nmsleep(1);\r\n}\r\nif (id_reg)\r\nQLCWR32(adapter, id_reg, adapter->portnum);\r\nreturn 0;\r\n}\r\nvoid\r\nqlcnic_pcie_sem_unlock(struct qlcnic_adapter *adapter, int sem)\r\n{\r\nQLCRD32(adapter, QLCNIC_PCIE_REG(PCIE_SEM_UNLOCK(sem)));\r\n}\r\nstatic int\r\nqlcnic_send_cmd_descs(struct qlcnic_adapter *adapter,\r\nstruct cmd_desc_type0 *cmd_desc_arr, int nr_desc)\r\n{\r\nu32 i, producer, consumer;\r\nstruct qlcnic_cmd_buffer *pbuf;\r\nstruct cmd_desc_type0 *cmd_desc;\r\nstruct qlcnic_host_tx_ring *tx_ring;\r\ni = 0;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn -EIO;\r\ntx_ring = adapter->tx_ring;\r\n__netif_tx_lock_bh(tx_ring->txq);\r\nproducer = tx_ring->producer;\r\nconsumer = tx_ring->sw_consumer;\r\nif (nr_desc >= qlcnic_tx_avail(tx_ring)) {\r\nnetif_tx_stop_queue(tx_ring->txq);\r\nsmp_mb();\r\nif (qlcnic_tx_avail(tx_ring) > nr_desc) {\r\nif (qlcnic_tx_avail(tx_ring) > TX_STOP_THRESH)\r\nnetif_tx_wake_queue(tx_ring->txq);\r\n} else {\r\nadapter->stats.xmit_off++;\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn -EBUSY;\r\n}\r\n}\r\ndo {\r\ncmd_desc = &cmd_desc_arr[i];\r\npbuf = &tx_ring->cmd_buf_arr[producer];\r\npbuf->skb = NULL;\r\npbuf->frag_count = 0;\r\nmemcpy(&tx_ring->desc_head[producer],\r\n&cmd_desc_arr[i], sizeof(struct cmd_desc_type0));\r\nproducer = get_next_index(producer, tx_ring->num_desc);\r\ni++;\r\n} while (i != nr_desc);\r\ntx_ring->producer = producer;\r\nqlcnic_update_cmd_producer(adapter, tx_ring);\r\n__netif_tx_unlock_bh(tx_ring->txq);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_sre_macaddr_change(struct qlcnic_adapter *adapter, u8 *addr,\r\n__le16 vlan_id, unsigned op)\r\n{\r\nstruct qlcnic_nic_req req;\r\nstruct qlcnic_mac_req *mac_req;\r\nstruct qlcnic_vlan_req *vlan_req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_REQUEST << 23);\r\nword = QLCNIC_MAC_EVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nmac_req = (struct qlcnic_mac_req *)&req.words[0];\r\nmac_req->op = op;\r\nmemcpy(mac_req->mac_addr, addr, 6);\r\nvlan_req = (struct qlcnic_vlan_req *)&req.words[1];\r\nvlan_req->vlan_id = vlan_id;\r\nreturn qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\n}\r\nstatic int qlcnic_nic_add_mac(struct qlcnic_adapter *adapter, const u8 *addr)\r\n{\r\nstruct list_head *head;\r\nstruct qlcnic_mac_list_s *cur;\r\nlist_for_each(head, &adapter->mac_list) {\r\ncur = list_entry(head, struct qlcnic_mac_list_s, list);\r\nif (memcmp(addr, cur->mac_addr, ETH_ALEN) == 0)\r\nreturn 0;\r\n}\r\ncur = kzalloc(sizeof(struct qlcnic_mac_list_s), GFP_ATOMIC);\r\nif (cur == NULL) {\r\ndev_err(&adapter->netdev->dev,\r\n"failed to add mac address filter\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cur->mac_addr, addr, ETH_ALEN);\r\nif (qlcnic_sre_macaddr_change(adapter,\r\ncur->mac_addr, 0, QLCNIC_MAC_ADD)) {\r\nkfree(cur);\r\nreturn -EIO;\r\n}\r\nlist_add_tail(&cur->list, &adapter->mac_list);\r\nreturn 0;\r\n}\r\nvoid qlcnic_set_multi(struct net_device *netdev)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nstatic const u8 bcast_addr[ETH_ALEN] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nu32 mode = VPORT_MISS_MODE_DROP;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn;\r\nqlcnic_nic_add_mac(adapter, adapter->mac_addr);\r\nqlcnic_nic_add_mac(adapter, bcast_addr);\r\nif (netdev->flags & IFF_PROMISC) {\r\nif (!(adapter->flags & QLCNIC_PROMISC_DISABLED))\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\ngoto send_fw_cmd;\r\n}\r\nif ((netdev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(netdev) > adapter->max_mc_count)) {\r\nmode = VPORT_MISS_MODE_ACCEPT_MULTI;\r\ngoto send_fw_cmd;\r\n}\r\nif (!netdev_mc_empty(netdev)) {\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nqlcnic_nic_add_mac(adapter, ha->addr);\r\n}\r\n}\r\nsend_fw_cmd:\r\nif (mode == VPORT_MISS_MODE_ACCEPT_ALL) {\r\nqlcnic_alloc_lb_filters_mem(adapter);\r\nadapter->mac_learn = 1;\r\n} else {\r\nadapter->mac_learn = 0;\r\n}\r\nqlcnic_nic_set_promisc(adapter, mode);\r\n}\r\nint qlcnic_nic_set_promisc(struct qlcnic_adapter *adapter, u32 mode)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_SET_MAC_RECEIVE_MODE |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(mode);\r\nreturn qlcnic_send_cmd_descs(adapter,\r\n(struct cmd_desc_type0 *)&req, 1);\r\n}\r\nvoid qlcnic_free_mac_list(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_mac_list_s *cur;\r\nstruct list_head *head = &adapter->mac_list;\r\nwhile (!list_empty(head)) {\r\ncur = list_entry(head->next, struct qlcnic_mac_list_s, list);\r\nqlcnic_sre_macaddr_change(adapter,\r\ncur->mac_addr, 0, QLCNIC_MAC_DEL);\r\nlist_del(&cur->list);\r\nkfree(cur);\r\n}\r\n}\r\nvoid qlcnic_prune_lb_filters(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_filter *tmp_fil;\r\nstruct hlist_node *tmp_hnode, *n;\r\nstruct hlist_head *head;\r\nint i;\r\nfor (i = 0; i < adapter->fhash.fmax; i++) {\r\nhead = &(adapter->fhash.fhead[i]);\r\nhlist_for_each_entry_safe(tmp_fil, tmp_hnode, n, head, fnode)\r\n{\r\nif (jiffies >\r\n(QLCNIC_FILTER_AGE * HZ + tmp_fil->ftime)) {\r\nqlcnic_sre_macaddr_change(adapter,\r\ntmp_fil->faddr, tmp_fil->vlan_id,\r\ntmp_fil->vlan_id ? QLCNIC_MAC_VLAN_DEL :\r\nQLCNIC_MAC_DEL);\r\nspin_lock_bh(&adapter->mac_learn_lock);\r\nadapter->fhash.fnum--;\r\nhlist_del(&tmp_fil->fnode);\r\nspin_unlock_bh(&adapter->mac_learn_lock);\r\nkfree(tmp_fil);\r\n}\r\n}\r\n}\r\n}\r\nvoid qlcnic_delete_lb_filters(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_filter *tmp_fil;\r\nstruct hlist_node *tmp_hnode, *n;\r\nstruct hlist_head *head;\r\nint i;\r\nfor (i = 0; i < adapter->fhash.fmax; i++) {\r\nhead = &(adapter->fhash.fhead[i]);\r\nhlist_for_each_entry_safe(tmp_fil, tmp_hnode, n, head, fnode) {\r\nqlcnic_sre_macaddr_change(adapter, tmp_fil->faddr,\r\ntmp_fil->vlan_id, tmp_fil->vlan_id ?\r\nQLCNIC_MAC_VLAN_DEL : QLCNIC_MAC_DEL);\r\nspin_lock_bh(&adapter->mac_learn_lock);\r\nadapter->fhash.fnum--;\r\nhlist_del(&tmp_fil->fnode);\r\nspin_unlock_bh(&adapter->mac_learn_lock);\r\nkfree(tmp_fil);\r\n}\r\n}\r\n}\r\nint qlcnic_set_fw_loopback(struct qlcnic_adapter *adapter, u8 flag)\r\n{\r\nstruct qlcnic_nic_req req;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nreq.req_hdr = cpu_to_le64(QLCNIC_H2C_OPCODE_CONFIG_LOOPBACK |\r\n((u64) adapter->portnum << 16) | ((u64) 0x1 << 32));\r\nreq.words[0] = cpu_to_le64(flag);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->pdev->dev, "%sting loopback mode failed\n",\r\nflag ? "Set" : "Reset");\r\nreturn rv;\r\n}\r\nint qlcnic_set_lb_mode(struct qlcnic_adapter *adapter, u8 mode)\r\n{\r\nif (qlcnic_set_fw_loopback(adapter, mode))\r\nreturn -EIO;\r\nif (qlcnic_nic_set_promisc(adapter, VPORT_MISS_MODE_ACCEPT_ALL)) {\r\nqlcnic_set_fw_loopback(adapter, 0);\r\nreturn -EIO;\r\n}\r\nmsleep(1000);\r\nreturn 0;\r\n}\r\nvoid qlcnic_clear_lb_mode(struct qlcnic_adapter *adapter)\r\n{\r\nint mode = VPORT_MISS_MODE_DROP;\r\nstruct net_device *netdev = adapter->netdev;\r\nqlcnic_set_fw_loopback(adapter, 0);\r\nif (netdev->flags & IFF_PROMISC)\r\nmode = VPORT_MISS_MODE_ACCEPT_ALL;\r\nelse if (netdev->flags & IFF_ALLMULTI)\r\nmode = VPORT_MISS_MODE_ACCEPT_MULTI;\r\nqlcnic_nic_set_promisc(adapter, mode);\r\nmsleep(1000);\r\n}\r\nint qlcnic_config_intr_coalesce(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_nic_req req;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nreq.req_hdr = cpu_to_le64(QLCNIC_CONFIG_INTR_COALESCE |\r\n((u64) adapter->portnum << 16));\r\nreq.words[0] = cpu_to_le64(((u64) adapter->ahw->coal.flag) << 32);\r\nreq.words[2] = cpu_to_le64(adapter->ahw->coal.rx_packets |\r\n((u64) adapter->ahw->coal.rx_time_us) << 16);\r\nreq.words[5] = cpu_to_le64(adapter->ahw->coal.timer_out |\r\n((u64) adapter->ahw->coal.type) << 32 |\r\n((u64) adapter->ahw->coal.sts_ring_mask) << 40);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"Could not send interrupt coalescing parameters\n");\r\nreturn rv;\r\n}\r\nint qlcnic_config_hw_lro(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_HW_LRO | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"Could not send configure hw lro request\n");\r\nreturn rv;\r\n}\r\nint qlcnic_config_bridged_mode(struct qlcnic_adapter *adapter, u32 enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nif (!!(adapter->flags & QLCNIC_BRIDGE_ENABLED) == enable)\r\nreturn 0;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_BRIDGING |\r\n((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"Could not send configure bridge mode request\n");\r\nadapter->flags ^= QLCNIC_BRIDGE_ENABLED;\r\nreturn rv;\r\n}\r\nint qlcnic_config_rss(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint i, rv;\r\nstatic const u64 key[] = {\r\n0xbeac01fa6a42b73bULL, 0x8030f20c77cb2da3ULL,\r\n0xae7b30b4d0ca2bcbULL, 0x43a38fb04167253dULL,\r\n0x255b0ec26d5a56daULL\r\n};\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_RSS | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nword = ((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 4) |\r\n((u64)(RSS_HASHTYPE_IP_TCP & 0x3) << 6) |\r\n((u64)(enable & 0x1) << 8) |\r\n((0x7ULL) << 48);\r\nreq.words[0] = cpu_to_le64(word);\r\nfor (i = 0; i < 5; i++)\r\nreq.words[i+1] = cpu_to_le64(key[i]);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev, "could not configure RSS\n");\r\nreturn rv;\r\n}\r\nint qlcnic_config_ipaddr(struct qlcnic_adapter *adapter, __be32 ip, int cmd)\r\n{\r\nstruct qlcnic_nic_req req;\r\nstruct qlcnic_ipaddr *ipa;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_IPADDR | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(cmd);\r\nipa = (struct qlcnic_ipaddr *)&req.words[1];\r\nipa->ipv4 = ip;\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"could not notify %s IP 0x%x reuqest\n",\r\n(cmd == QLCNIC_IP_UP) ? "Add" : "Remove", ip);\r\nreturn rv;\r\n}\r\nint qlcnic_linkevent_request(struct qlcnic_adapter *adapter, int enable)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_GET_LINKEVENT | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64(enable | (enable << 8));\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"could not configure link notification\n");\r\nreturn rv;\r\n}\r\nint qlcnic_send_lro_cleanup(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_nic_req req;\r\nu64 word;\r\nint rv;\r\nif (!test_bit(__QLCNIC_FW_ATTACHED, &adapter->state))\r\nreturn 0;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_LRO_REQUEST |\r\n((u64)adapter->portnum << 16) |\r\n((u64)QLCNIC_LRO_REQUEST_CLEANUP << 56) ;\r\nreq.req_hdr = cpu_to_le64(word);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv != 0)\r\ndev_err(&adapter->netdev->dev,\r\n"could not cleanup lro flows\n");\r\nreturn rv;\r\n}\r\nint qlcnic_change_mtu(struct net_device *netdev, int mtu)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nint rc = 0;\r\nif (mtu < P3P_MIN_MTU || mtu > P3P_MAX_MTU) {\r\ndev_err(&adapter->netdev->dev, "%d bytes < mtu < %d bytes"\r\n" not supported\n", P3P_MAX_MTU, P3P_MIN_MTU);\r\nreturn -EINVAL;\r\n}\r\nrc = qlcnic_fw_cmd_set_mtu(adapter, mtu);\r\nif (!rc)\r\nnetdev->mtu = mtu;\r\nreturn rc;\r\n}\r\nnetdev_features_t qlcnic_fix_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nif ((adapter->flags & QLCNIC_ESWITCH_ENABLED)) {\r\nnetdev_features_t changed = features ^ netdev->features;\r\nfeatures ^= changed & (NETIF_F_ALL_CSUM | NETIF_F_RXCSUM);\r\n}\r\nif (!(features & NETIF_F_RXCSUM))\r\nfeatures &= ~NETIF_F_LRO;\r\nreturn features;\r\n}\r\nint qlcnic_set_features(struct net_device *netdev, netdev_features_t features)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nnetdev_features_t changed = netdev->features ^ features;\r\nint hw_lro = (features & NETIF_F_LRO) ? QLCNIC_LRO_ENABLED : 0;\r\nif (!(changed & NETIF_F_LRO))\r\nreturn 0;\r\nnetdev->features = features ^ NETIF_F_LRO;\r\nif (qlcnic_config_hw_lro(adapter, hw_lro))\r\nreturn -EIO;\r\nif ((hw_lro == 0) && qlcnic_send_lro_cleanup(adapter))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_pci_get_crb_addr_2M(struct qlcnic_adapter *adapter,\r\nulong off, void __iomem **addr)\r\n{\r\nconst struct crb_128M_2M_sub_block_map *m;\r\nif ((off >= QLCNIC_CRB_MAX) || (off < QLCNIC_PCI_CRBSPACE))\r\nreturn -EINVAL;\r\noff -= QLCNIC_PCI_CRBSPACE;\r\nm = &crb_128M_2M_map[CRB_BLK(off)].sub_block[CRB_SUBBLK(off)];\r\nif (m->valid && (m->start_128M <= off) && (m->end_128M > off)) {\r\n*addr = adapter->ahw->pci_base0 + m->start_2M +\r\n(off - m->start_128M);\r\nreturn 0;\r\n}\r\n*addr = adapter->ahw->pci_base0 + CRB_INDIRECT_2M + (off & MASK(16));\r\nreturn 1;\r\n}\r\nstatic int\r\nqlcnic_pci_set_crbwindow_2M(struct qlcnic_adapter *adapter, ulong off)\r\n{\r\nu32 window;\r\nvoid __iomem *addr = adapter->ahw->pci_base0 + CRB_WINDOW_2M;\r\noff -= QLCNIC_PCI_CRBSPACE;\r\nwindow = CRB_HI(off);\r\nif (window == 0) {\r\ndev_err(&adapter->pdev->dev, "Invalid offset 0x%lx\n", off);\r\nreturn -EIO;\r\n}\r\nwritel(window, addr);\r\nif (readl(addr) != window) {\r\nif (printk_ratelimit())\r\ndev_warn(&adapter->pdev->dev,\r\n"failed to set CRB window to %d off 0x%lx\n",\r\nwindow, off);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_hw_write_wx_2M(struct qlcnic_adapter *adapter, ulong off, u32 data)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nvoid __iomem *addr = NULL;\r\nrv = qlcnic_pci_get_crb_addr_2M(adapter, off, &addr);\r\nif (rv == 0) {\r\nwritel(data, addr);\r\nreturn 0;\r\n}\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw->crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nrv = qlcnic_pci_set_crbwindow_2M(adapter, off);\r\nif (!rv)\r\nwritel(data, addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw->crb_lock, flags);\r\nreturn rv;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -EIO;\r\n}\r\nu32\r\nqlcnic_hw_read_wx_2M(struct qlcnic_adapter *adapter, ulong off)\r\n{\r\nunsigned long flags;\r\nint rv;\r\nu32 data = -1;\r\nvoid __iomem *addr = NULL;\r\nrv = qlcnic_pci_get_crb_addr_2M(adapter, off, &addr);\r\nif (rv == 0)\r\nreturn readl(addr);\r\nif (rv > 0) {\r\nwrite_lock_irqsave(&adapter->ahw->crb_lock, flags);\r\ncrb_win_lock(adapter);\r\nif (!qlcnic_pci_set_crbwindow_2M(adapter, off))\r\ndata = readl(addr);\r\ncrb_win_unlock(adapter);\r\nwrite_unlock_irqrestore(&adapter->ahw->crb_lock, flags);\r\nreturn data;\r\n}\r\ndev_err(&adapter->pdev->dev,\r\n"%s: invalid offset: 0x%016lx\n", __func__, off);\r\ndump_stack();\r\nreturn -1;\r\n}\r\nvoid __iomem *\r\nqlcnic_get_ioaddr(struct qlcnic_adapter *adapter, u32 offset)\r\n{\r\nvoid __iomem *addr = NULL;\r\nWARN_ON(qlcnic_pci_get_crb_addr_2M(adapter, offset, &addr));\r\nreturn addr;\r\n}\r\nstatic int\r\nqlcnic_pci_set_window_2M(struct qlcnic_adapter *adapter,\r\nu64 addr, u32 *start)\r\n{\r\nu32 window;\r\nwindow = OCM_WIN_P3P(addr);\r\nwritel(window, adapter->ahw->ocm_win_crb);\r\nreadl(adapter->ahw->ocm_win_crb);\r\n*start = QLCNIC_PCI_OCM0_2M + GET_MEM_OFFS_2M(addr);\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_pci_mem_access_direct(struct qlcnic_adapter *adapter, u64 off,\r\nu64 *data, int op)\r\n{\r\nvoid __iomem *addr;\r\nint ret;\r\nu32 start;\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nret = qlcnic_pci_set_window_2M(adapter, off, &start);\r\nif (ret != 0)\r\ngoto unlock;\r\naddr = adapter->ahw->pci_base0 + start;\r\nif (op == 0)\r\n*data = readq(addr);\r\nelse\r\nwriteq(*data, addr);\r\nunlock:\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn ret;\r\n}\r\nvoid\r\nqlcnic_pci_camqm_read_2M(struct qlcnic_adapter *adapter, u64 off, u64 *data)\r\n{\r\nvoid __iomem *addr = adapter->ahw->pci_base0 +\r\nQLCNIC_PCI_CAMQM_2M_BASE + (off - QLCNIC_PCI_CAMQM);\r\nmutex_lock(&adapter->ahw->mem_lock);\r\n*data = readq(addr);\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\n}\r\nvoid\r\nqlcnic_pci_camqm_write_2M(struct qlcnic_adapter *adapter, u64 off, u64 data)\r\n{\r\nvoid __iomem *addr = adapter->ahw->pci_base0 +\r\nQLCNIC_PCI_CAMQM_2M_BASE + (off - QLCNIC_PCI_CAMQM);\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwriteq(data, addr);\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\n}\r\nint\r\nqlcnic_pci_mem_write_2M(struct qlcnic_adapter *adapter,\r\nu64 off, u64 data)\r\n{\r\nint i, j, ret;\r\nu32 temp, off8;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_QDR_NET,\r\nQLCNIC_ADDR_QDR_NET_MAX)) {\r\nmem_crb = qlcnic_get_ioaddr(adapter,\r\nQLCNIC_CRB_QDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_DDR_NET, QLCNIC_ADDR_DDR_NET_MAX)) {\r\nmem_crb = qlcnic_get_ioaddr(adapter,\r\nQLCNIC_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_OCM0, QLCNIC_ADDR_OCM0_MAX))\r\nreturn qlcnic_pci_mem_access_direct(adapter, off, &data, 1);\r\nreturn -EIO;\r\ncorrect:\r\noff8 = off & ~0xf;\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\r\ni = 0;\r\nwritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE),\r\n(mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\ni = (off & 0xf) ? 0 : 2;\r\nwritel(readl(mem_crb + MIU_TEST_AGT_RDDATA(i)),\r\nmem_crb + MIU_TEST_AGT_WRDATA(i));\r\nwritel(readl(mem_crb + MIU_TEST_AGT_RDDATA(i+1)),\r\nmem_crb + MIU_TEST_AGT_WRDATA(i+1));\r\ni = (off & 0xf) ? 2 : 0;\r\nwritel(data & 0xffffffff,\r\nmem_crb + MIU_TEST_AGT_WRDATA(i));\r\nwritel((data >> 32) & 0xffffffff,\r\nmem_crb + MIU_TEST_AGT_WRDATA(i+1));\r\nwritel((TA_CTL_ENABLE | TA_CTL_WRITE), (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE | TA_CTL_WRITE),\r\n(mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to write through agent\n");\r\nret = -EIO;\r\n} else\r\nret = 0;\r\ndone:\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn ret;\r\n}\r\nint\r\nqlcnic_pci_mem_read_2M(struct qlcnic_adapter *adapter,\r\nu64 off, u64 *data)\r\n{\r\nint j, ret;\r\nu32 temp, off8;\r\nu64 val;\r\nvoid __iomem *mem_crb;\r\nif (off & 7)\r\nreturn -EIO;\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_QDR_NET,\r\nQLCNIC_ADDR_QDR_NET_MAX)) {\r\nmem_crb = qlcnic_get_ioaddr(adapter,\r\nQLCNIC_CRB_QDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_DDR_NET, QLCNIC_ADDR_DDR_NET_MAX)) {\r\nmem_crb = qlcnic_get_ioaddr(adapter,\r\nQLCNIC_CRB_DDR_NET+MIU_TEST_AGT_BASE);\r\ngoto correct;\r\n}\r\nif (ADDR_IN_RANGE(off, QLCNIC_ADDR_OCM0, QLCNIC_ADDR_OCM0_MAX)) {\r\nreturn qlcnic_pci_mem_access_direct(adapter,\r\noff, data, 0);\r\n}\r\nreturn -EIO;\r\ncorrect:\r\noff8 = off & ~0xf;\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwritel(off8, (mem_crb + MIU_TEST_AGT_ADDR_LO));\r\nwritel(0, (mem_crb + MIU_TEST_AGT_ADDR_HI));\r\nwritel(TA_CTL_ENABLE, (mem_crb + TEST_AGT_CTRL));\r\nwritel((TA_CTL_START | TA_CTL_ENABLE), (mem_crb + TEST_AGT_CTRL));\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\ntemp = readl(mem_crb + TEST_AGT_CTRL);\r\nif ((temp & TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nif (printk_ratelimit())\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EIO;\r\n} else {\r\noff8 = MIU_TEST_AGT_RDDATA_LO;\r\nif (off & 0xf)\r\noff8 = MIU_TEST_AGT_RDDATA_UPPER_LO;\r\ntemp = readl(mem_crb + off8 + 4);\r\nval = (u64)temp << 32;\r\nval |= readl(mem_crb + off8);\r\n*data = val;\r\nret = 0;\r\n}\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn ret;\r\n}\r\nint qlcnic_get_board_info(struct qlcnic_adapter *adapter)\r\n{\r\nint offset, board_type, magic;\r\nstruct pci_dev *pdev = adapter->pdev;\r\noffset = QLCNIC_FW_MAGIC_OFFSET;\r\nif (qlcnic_rom_fast_read(adapter, offset, &magic))\r\nreturn -EIO;\r\nif (magic != QLCNIC_BDINFO_MAGIC) {\r\ndev_err(&pdev->dev, "invalid board config, magic=%08x\n",\r\nmagic);\r\nreturn -EIO;\r\n}\r\noffset = QLCNIC_BRDTYPE_OFFSET;\r\nif (qlcnic_rom_fast_read(adapter, offset, &board_type))\r\nreturn -EIO;\r\nadapter->ahw->board_type = board_type;\r\nif (board_type == QLCNIC_BRDTYPE_P3P_4_GB_MM) {\r\nu32 gpio = QLCRD32(adapter, QLCNIC_ROMUSB_GLB_PAD_GPIO_I);\r\nif ((gpio & 0x8000) == 0)\r\nboard_type = QLCNIC_BRDTYPE_P3P_10G_TP;\r\n}\r\nswitch (board_type) {\r\ncase QLCNIC_BRDTYPE_P3P_HMEZ:\r\ncase QLCNIC_BRDTYPE_P3P_XG_LOM:\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4:\r\ncase QLCNIC_BRDTYPE_P3P_10G_CX4_LP:\r\ncase QLCNIC_BRDTYPE_P3P_IMEZ:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_PLUS:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_CT:\r\ncase QLCNIC_BRDTYPE_P3P_10G_SFP_QT:\r\ncase QLCNIC_BRDTYPE_P3P_10G_XFP:\r\ncase QLCNIC_BRDTYPE_P3P_10000_BASE_T:\r\nadapter->ahw->port_type = QLCNIC_XGBE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_REF_QG:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB:\r\ncase QLCNIC_BRDTYPE_P3P_4_GB_MM:\r\nadapter->ahw->port_type = QLCNIC_GBE;\r\nbreak;\r\ncase QLCNIC_BRDTYPE_P3P_10G_TP:\r\nadapter->ahw->port_type = (adapter->portnum < 2) ?\r\nQLCNIC_XGBE : QLCNIC_GBE;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unknown board type %x\n", board_type);\r\nadapter->ahw->port_type = QLCNIC_XGBE;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nqlcnic_wol_supported(struct qlcnic_adapter *adapter)\r\n{\r\nu32 wol_cfg;\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG_NV);\r\nif (wol_cfg & (1UL << adapter->portnum)) {\r\nwol_cfg = QLCRD32(adapter, QLCNIC_WOL_CONFIG);\r\nif (wol_cfg & (1 << adapter->portnum))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_config_led(struct qlcnic_adapter *adapter, u32 state, u32 rate)\r\n{\r\nstruct qlcnic_nic_req req;\r\nint rv;\r\nu64 word;\r\nmemset(&req, 0, sizeof(struct qlcnic_nic_req));\r\nreq.qhdr = cpu_to_le64(QLCNIC_HOST_REQUEST << 23);\r\nword = QLCNIC_H2C_OPCODE_CONFIG_LED | ((u64)adapter->portnum << 16);\r\nreq.req_hdr = cpu_to_le64(word);\r\nreq.words[0] = cpu_to_le64((u64)rate << 32);\r\nreq.words[1] = cpu_to_le64(state);\r\nrv = qlcnic_send_cmd_descs(adapter, (struct cmd_desc_type0 *)&req, 1);\r\nif (rv)\r\ndev_err(&adapter->pdev->dev, "LED configuration failed.\n");\r\nreturn rv;\r\n}\r\nstatic u32\r\nqlcnic_dump_crb(struct qlcnic_adapter *adapter, struct qlcnic_dump_entry *entry,\r\nu32 *buffer)\r\n{\r\nint i;\r\nu32 addr, data;\r\nstruct __crb *crb = &entry->region.crb;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\naddr = crb->addr;\r\nfor (i = 0; i < crb->no_ops; i++) {\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\n*buffer++ = cpu_to_le32(addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += crb->stride;\r\n}\r\nreturn crb->no_ops * 2 * sizeof(u32);\r\n}\r\nstatic u32\r\nqlcnic_dump_ctrl(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, u32 *buffer)\r\n{\r\nint i, k, timeout = 0;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nu32 addr, data;\r\nu8 opcode, no_ops;\r\nstruct __ctrl *ctr = &entry->region.ctrl;\r\nstruct qlcnic_dump_template_hdr *t_hdr = adapter->ahw->fw_dump.tmpl_hdr;\r\naddr = ctr->addr;\r\nno_ops = ctr->no_ops;\r\nfor (i = 0; i < no_ops; i++) {\r\nk = 0;\r\nopcode = 0;\r\nfor (k = 0; k < 8; k++) {\r\nif (!(ctr->opcode & (1 << k)))\r\ncontinue;\r\nswitch (1 << k) {\r\ncase QLCNIC_DUMP_WCRB:\r\nQLCNIC_WR_DUMP_REG(addr, base, ctr->val1);\r\nbreak;\r\ncase QLCNIC_DUMP_RWCRB:\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\nQLCNIC_WR_DUMP_REG(addr, base, data);\r\nbreak;\r\ncase QLCNIC_DUMP_ANDCRB:\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\nQLCNIC_WR_DUMP_REG(addr, base,\r\n(data & ctr->val2));\r\nbreak;\r\ncase QLCNIC_DUMP_ORCRB:\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\nQLCNIC_WR_DUMP_REG(addr, base,\r\n(data | ctr->val3));\r\nbreak;\r\ncase QLCNIC_DUMP_POLLCRB:\r\nwhile (timeout <= ctr->timeout) {\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\nif ((data & ctr->val2) == ctr->val1)\r\nbreak;\r\nmsleep(1);\r\ntimeout++;\r\n}\r\nif (timeout > ctr->timeout) {\r\ndev_info(&adapter->pdev->dev,\r\n"Timed out, aborting poll CRB\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase QLCNIC_DUMP_RD_SAVE:\r\nif (ctr->index_a)\r\naddr = t_hdr->saved_state[ctr->index_a];\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\nt_hdr->saved_state[ctr->index_v] = data;\r\nbreak;\r\ncase QLCNIC_DUMP_WRT_SAVED:\r\nif (ctr->index_v)\r\ndata = t_hdr->saved_state[ctr->index_v];\r\nelse\r\ndata = ctr->val1;\r\nif (ctr->index_a)\r\naddr = t_hdr->saved_state[ctr->index_a];\r\nQLCNIC_WR_DUMP_REG(addr, base, data);\r\nbreak;\r\ncase QLCNIC_DUMP_MOD_SAVE_ST:\r\ndata = t_hdr->saved_state[ctr->index_v];\r\ndata <<= ctr->shl_val;\r\ndata >>= ctr->shr_val;\r\nif (ctr->val2)\r\ndata &= ctr->val2;\r\ndata |= ctr->val3;\r\ndata += ctr->val1;\r\nt_hdr->saved_state[ctr->index_v] = data;\r\nbreak;\r\ndefault:\r\ndev_info(&adapter->pdev->dev,\r\n"Unknown opcode\n");\r\nbreak;\r\n}\r\n}\r\naddr += ctr->stride;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32\r\nqlcnic_dump_mux(struct qlcnic_adapter *adapter, struct qlcnic_dump_entry *entry,\r\nu32 *buffer)\r\n{\r\nint loop;\r\nu32 val, data = 0;\r\nstruct __mux *mux = &entry->region.mux;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nval = mux->val;\r\nfor (loop = 0; loop < mux->no_ops; loop++) {\r\nQLCNIC_WR_DUMP_REG(mux->addr, base, val);\r\nQLCNIC_RD_DUMP_REG(mux->read_addr, base, &data);\r\n*buffer++ = cpu_to_le32(val);\r\n*buffer++ = cpu_to_le32(data);\r\nval += mux->val_stride;\r\n}\r\nreturn 2 * mux->no_ops * sizeof(u32);\r\n}\r\nstatic u32\r\nqlcnic_dump_que(struct qlcnic_adapter *adapter, struct qlcnic_dump_entry *entry,\r\nu32 *buffer)\r\n{\r\nint i, loop;\r\nu32 cnt, addr, data, que_id = 0;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nstruct __queue *que = &entry->region.que;\r\naddr = que->read_addr;\r\ncnt = que->read_addr_cnt;\r\nfor (loop = 0; loop < que->no_ops; loop++) {\r\nQLCNIC_WR_DUMP_REG(que->sel_addr, base, que_id);\r\naddr = que->read_addr;\r\nfor (i = 0; i < cnt; i++) {\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += que->read_addr_stride;\r\n}\r\nque_id += que->stride;\r\n}\r\nreturn que->no_ops * cnt * sizeof(u32);\r\n}\r\nstatic u32\r\nqlcnic_dump_ocm(struct qlcnic_adapter *adapter, struct qlcnic_dump_entry *entry,\r\nu32 *buffer)\r\n{\r\nint i;\r\nu32 data;\r\nvoid __iomem *addr;\r\nstruct __ocm *ocm = &entry->region.ocm;\r\naddr = adapter->ahw->pci_base0 + ocm->read_addr;\r\nfor (i = 0; i < ocm->no_ops; i++) {\r\ndata = readl(addr);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += ocm->read_addr_stride;\r\n}\r\nreturn ocm->no_ops * sizeof(u32);\r\n}\r\nstatic u32\r\nqlcnic_read_rom(struct qlcnic_adapter *adapter, struct qlcnic_dump_entry *entry,\r\nu32 *buffer)\r\n{\r\nint i, count = 0;\r\nu32 fl_addr, size, val, lck_val, addr;\r\nstruct __mem *rom = &entry->region.mem;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nfl_addr = rom->addr;\r\nsize = rom->size/4;\r\nlock_try:\r\nlck_val = readl(base + QLCNIC_FLASH_SEM2_LK);\r\nif (!lck_val && count < MAX_CTL_CHECK) {\r\nmsleep(10);\r\ncount++;\r\ngoto lock_try;\r\n}\r\nwritel(adapter->ahw->pci_func, (base + QLCNIC_FLASH_LOCK_ID));\r\nfor (i = 0; i < size; i++) {\r\naddr = fl_addr & 0xFFFF0000;\r\nQLCNIC_WR_DUMP_REG(FLASH_ROM_WINDOW, base, addr);\r\naddr = LSW(fl_addr) + FLASH_ROM_DATA;\r\nQLCNIC_RD_DUMP_REG(addr, base, &val);\r\nfl_addr += 4;\r\n*buffer++ = cpu_to_le32(val);\r\n}\r\nreadl(base + QLCNIC_FLASH_SEM2_ULK);\r\nreturn rom->size;\r\n}\r\nstatic u32\r\nqlcnic_dump_l1_cache(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, u32 *buffer)\r\n{\r\nint i;\r\nu32 cnt, val, data, addr;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nstruct __cache *l1 = &entry->region.cache;\r\nval = l1->init_tag_val;\r\nfor (i = 0; i < l1->no_ops; i++) {\r\nQLCNIC_WR_DUMP_REG(l1->addr, base, val);\r\nQLCNIC_WR_DUMP_REG(l1->ctrl_addr, base, LSW(l1->ctrl_val));\r\naddr = l1->read_addr;\r\ncnt = l1->read_addr_num;\r\nwhile (cnt) {\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += l1->read_addr_stride;\r\ncnt--;\r\n}\r\nval += l1->stride;\r\n}\r\nreturn l1->no_ops * l1->read_addr_num * sizeof(u32);\r\n}\r\nstatic u32\r\nqlcnic_dump_l2_cache(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, u32 *buffer)\r\n{\r\nint i;\r\nu32 cnt, val, data, addr;\r\nu8 poll_mask, poll_to, time_out = 0;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nstruct __cache *l2 = &entry->region.cache;\r\nval = l2->init_tag_val;\r\npoll_mask = LSB(MSW(l2->ctrl_val));\r\npoll_to = MSB(MSW(l2->ctrl_val));\r\nfor (i = 0; i < l2->no_ops; i++) {\r\nQLCNIC_WR_DUMP_REG(l2->addr, base, val);\r\nif (LSW(l2->ctrl_val))\r\nQLCNIC_WR_DUMP_REG(l2->ctrl_addr, base,\r\nLSW(l2->ctrl_val));\r\nif (!poll_mask)\r\ngoto skip_poll;\r\ndo {\r\nQLCNIC_RD_DUMP_REG(l2->ctrl_addr, base, &data);\r\nif (!(data & poll_mask))\r\nbreak;\r\nmsleep(1);\r\ntime_out++;\r\n} while (time_out <= poll_to);\r\nif (time_out > poll_to) {\r\ndev_err(&adapter->pdev->dev,\r\n"Timeout exceeded in %s, aborting dump\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nskip_poll:\r\naddr = l2->read_addr;\r\ncnt = l2->read_addr_num;\r\nwhile (cnt) {\r\nQLCNIC_RD_DUMP_REG(addr, base, &data);\r\n*buffer++ = cpu_to_le32(data);\r\naddr += l2->read_addr_stride;\r\ncnt--;\r\n}\r\nval += l2->stride;\r\n}\r\nreturn l2->no_ops * l2->read_addr_num * sizeof(u32);\r\n}\r\nstatic u32\r\nqlcnic_read_memory(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, u32 *buffer)\r\n{\r\nu32 addr, data, test, ret = 0;\r\nint i, reg_read;\r\nstruct __mem *mem = &entry->region.mem;\r\nvoid __iomem *base = adapter->ahw->pci_base0;\r\nreg_read = mem->size;\r\naddr = mem->addr;\r\nif ((addr & 0xf) || (reg_read%16)) {\r\ndev_info(&adapter->pdev->dev,\r\n"Unaligned memory addr:0x%x size:0x%x\n",\r\naddr, reg_read);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&adapter->ahw->mem_lock);\r\nwhile (reg_read != 0) {\r\nQLCNIC_WR_DUMP_REG(MIU_TEST_ADDR_LO, base, addr);\r\nQLCNIC_WR_DUMP_REG(MIU_TEST_ADDR_HI, base, 0);\r\nQLCNIC_WR_DUMP_REG(MIU_TEST_CTR, base,\r\nTA_CTL_ENABLE | TA_CTL_START);\r\nfor (i = 0; i < MAX_CTL_CHECK; i++) {\r\nQLCNIC_RD_DUMP_REG(MIU_TEST_CTR, base, &test);\r\nif (!(test & TA_CTL_BUSY))\r\nbreak;\r\n}\r\nif (i == MAX_CTL_CHECK) {\r\nif (printk_ratelimit()) {\r\ndev_err(&adapter->pdev->dev,\r\n"failed to read through agent\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nQLCNIC_RD_DUMP_REG(MIU_TEST_READ_DATA[i], base, &data);\r\n*buffer++ = cpu_to_le32(data);\r\n}\r\naddr += 16;\r\nreg_read -= 16;\r\nret += 16;\r\n}\r\nout:\r\nmutex_unlock(&adapter->ahw->mem_lock);\r\nreturn mem->size;\r\n}\r\nstatic u32\r\nqlcnic_dump_nop(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_dump_entry *entry, u32 *buffer)\r\n{\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nreturn 0;\r\n}\r\nstatic int\r\nqlcnic_valid_dump_entry(struct device *dev, struct qlcnic_dump_entry *entry,\r\nu32 size)\r\n{\r\nint ret = 1;\r\nif (size != entry->hdr.cap_size) {\r\ndev_info(dev,\r\n"Invalidate dump, Type:%d\tMask:%d\tSize:%dCap_size:%d\n",\r\nentry->hdr.type, entry->hdr.mask, size, entry->hdr.cap_size);\r\ndev_info(dev, "Aborting further dump capture\n");\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint qlcnic_dump_fw(struct qlcnic_adapter *adapter)\r\n{\r\nu32 *buffer;\r\nchar mesg[64];\r\nchar *msg[] = {mesg, NULL};\r\nint i, k, ops_cnt, ops_index, dump_size = 0;\r\nu32 entry_offset, dump, no_entries, buf_offset = 0;\r\nstruct qlcnic_dump_entry *entry;\r\nstruct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;\r\nstruct qlcnic_dump_template_hdr *tmpl_hdr = fw_dump->tmpl_hdr;\r\nif (fw_dump->clr) {\r\ndev_info(&adapter->pdev->dev,\r\n"Previous dump not cleared, not capturing dump\n");\r\nreturn -EIO;\r\n}\r\nfor (i = 2, k = 1; (i & QLCNIC_DUMP_MASK_MAX); i <<= 1, k++)\r\nif (i & tmpl_hdr->drv_cap_mask)\r\ndump_size += tmpl_hdr->cap_sizes[k];\r\nif (!dump_size)\r\nreturn -EIO;\r\nfw_dump->data = vzalloc(dump_size);\r\nif (!fw_dump->data) {\r\ndev_info(&adapter->pdev->dev,\r\n"Unable to allocate (%d KB) for fw dump\n",\r\ndump_size/1024);\r\nreturn -ENOMEM;\r\n}\r\nbuffer = fw_dump->data;\r\nfw_dump->size = dump_size;\r\nno_entries = tmpl_hdr->num_entries;\r\nops_cnt = ARRAY_SIZE(fw_dump_ops);\r\nentry_offset = tmpl_hdr->offset;\r\ntmpl_hdr->sys_info[0] = QLCNIC_DRIVER_VERSION;\r\ntmpl_hdr->sys_info[1] = adapter->fw_version;\r\nfor (i = 0; i < no_entries; i++) {\r\nentry = (void *)tmpl_hdr + entry_offset;\r\nif (!(entry->hdr.mask & tmpl_hdr->drv_cap_mask)) {\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nentry_offset += entry->hdr.offset;\r\ncontinue;\r\n}\r\nops_index = 0;\r\nwhile (ops_index < ops_cnt) {\r\nif (entry->hdr.type == fw_dump_ops[ops_index].opcode)\r\nbreak;\r\nops_index++;\r\n}\r\nif (ops_index == ops_cnt) {\r\ndev_info(&adapter->pdev->dev,\r\n"Invalid entry type %d, exiting dump\n",\r\nentry->hdr.type);\r\ngoto error;\r\n}\r\ndump = fw_dump_ops[ops_index].handler(adapter, entry, buffer);\r\nif (dump && !qlcnic_valid_dump_entry(&adapter->pdev->dev, entry,\r\ndump))\r\nentry->hdr.flags |= QLCNIC_DUMP_SKIP;\r\nbuf_offset += entry->hdr.cap_size;\r\nentry_offset += entry->hdr.offset;\r\nbuffer = fw_dump->data + buf_offset;\r\n}\r\nif (dump_size != buf_offset) {\r\ndev_info(&adapter->pdev->dev,\r\n"Captured(%d) and expected size(%d) do not match\n",\r\nbuf_offset, dump_size);\r\ngoto error;\r\n} else {\r\nfw_dump->clr = 1;\r\nsnprintf(mesg, sizeof(mesg), "FW_DUMP=%s",\r\nadapter->netdev->name);\r\ndev_info(&adapter->pdev->dev, "Dump data, %d bytes captured\n",\r\nfw_dump->size);\r\nkobject_uevent_env(&adapter->pdev->dev.kobj, KOBJ_CHANGE, msg);\r\nreturn 0;\r\n}\r\nerror:\r\nvfree(fw_dump->data);\r\nreturn -EINVAL;\r\n}
