static inline int TO_LEVEL(int brightness)\r\n{\r\nreturn brightness >> 4;\r\n}\r\nstatic inline int TO_BRIGHT(int level)\r\n{\r\nif (level)\r\nreturn (level << 4) | 0xf;\r\nreturn 0;\r\n}\r\nstatic int choose_times(int msec, int *c1p, int *c2p)\r\n{\r\nint c1, c2;\r\nint tmax = msec * 9 / 8;\r\nint tmin = msec * 7 / 8;\r\nint diff = 65536;\r\nfor (c1 = 1; c1 < TIMECODES; c1++) {\r\nint t = time_codes[c1];\r\nif (t*2 < tmin)\r\ncontinue;\r\nif (t > tmax)\r\nbreak;\r\nfor (c2 = 0; c2 <= c1; c2++) {\r\nint tt = t + time_codes[c2];\r\nint d;\r\nif (tt < tmin)\r\ncontinue;\r\nif (tt > tmax)\r\nbreak;\r\nd = abs(msec - tt);\r\nif (d >= diff)\r\ncontinue;\r\n*c1p = c1;\r\n*c2p = c2;\r\ndiff = d;\r\nif (d == 0)\r\nreturn msec;\r\n}\r\n}\r\nif (diff < 65536) {\r\nint actual;\r\nif (msec & 1) {\r\nc1 = *c2p;\r\n*c2p = *c1p;\r\n*c1p = c1;\r\n}\r\nactual = time_codes[*c1p] + time_codes[*c2p];\r\nif (*c1p < *c2p)\r\nreturn actual + 1;\r\nelse\r\nreturn actual;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void set_select(struct tca6507_chip *tca, int led, int val)\r\n{\r\nint mask = (1 << led);\r\nint bit;\r\nfor (bit = 0; bit < 3; bit++) {\r\nint n = tca->reg_file[bit] & ~mask;\r\nif (val & (1 << bit))\r\nn |= mask;\r\nif (tca->reg_file[bit] != n) {\r\ntca->reg_file[bit] = n;\r\ntca->reg_set |= (1 << bit);\r\n}\r\n}\r\n}\r\nstatic void set_code(struct tca6507_chip *tca, int reg, int bank, int new)\r\n{\r\nint mask = 0xF;\r\nint n;\r\nif (bank) {\r\nmask <<= 4;\r\nnew <<= 4;\r\n}\r\nn = tca->reg_file[reg] & ~mask;\r\nn |= new;\r\nif (tca->reg_file[reg] != n) {\r\ntca->reg_file[reg] = n;\r\ntca->reg_set |= 1 << reg;\r\n}\r\n}\r\nstatic void set_level(struct tca6507_chip *tca, int bank, int level)\r\n{\r\nswitch (bank) {\r\ncase BANK0:\r\ncase BANK1:\r\nset_code(tca, TCA6507_MAX_INTENSITY, bank, level);\r\nbreak;\r\ncase MASTER:\r\nset_code(tca, TCA6507_MASTER_INTENSITY, 0, level);\r\nbreak;\r\n}\r\ntca->bank[bank].level = level;\r\n}\r\nstatic void set_times(struct tca6507_chip *tca, int bank)\r\n{\r\nint c1, c2;\r\nint result;\r\nresult = choose_times(tca->bank[bank].ontime, &c1, &c2);\r\ndev_dbg(&tca->client->dev,\r\n"Chose on times %d(%d) %d(%d) for %dms\n", c1, time_codes[c1],\r\nc2, time_codes[c2], tca->bank[bank].ontime);\r\nset_code(tca, TCA6507_FADE_ON, bank, c2);\r\nset_code(tca, TCA6507_FULL_ON, bank, c1);\r\ntca->bank[bank].ontime = result;\r\nresult = choose_times(tca->bank[bank].offtime, &c1, &c2);\r\ndev_dbg(&tca->client->dev,\r\n"Chose off times %d(%d) %d(%d) for %dms\n", c1, time_codes[c1],\r\nc2, time_codes[c2], tca->bank[bank].offtime);\r\nset_code(tca, TCA6507_FADE_OFF, bank, c2);\r\nset_code(tca, TCA6507_FIRST_OFF, bank, c1);\r\nset_code(tca, TCA6507_SECOND_OFF, bank, c1);\r\ntca->bank[bank].offtime = result;\r\nset_code(tca, TCA6507_INITIALIZE, bank, INIT_CODE);\r\n}\r\nstatic void tca6507_work(struct work_struct *work)\r\n{\r\nstruct tca6507_chip *tca = container_of(work, struct tca6507_chip,\r\nwork);\r\nstruct i2c_client *cl = tca->client;\r\nint set;\r\nu8 file[TCA6507_REG_CNT];\r\nint r;\r\nspin_lock_irq(&tca->lock);\r\nset = tca->reg_set;\r\nmemcpy(file, tca->reg_file, TCA6507_REG_CNT);\r\ntca->reg_set = 0;\r\nspin_unlock_irq(&tca->lock);\r\nfor (r = 0; r < TCA6507_REG_CNT; r++)\r\nif (set & (1<<r))\r\ni2c_smbus_write_byte_data(cl, r, file[r]);\r\n}\r\nstatic void led_release(struct tca6507_led *led)\r\n{\r\nstruct tca6507_chip *tca = led->chip;\r\nif (led->bank >= 0) {\r\nstruct bank *b = tca->bank + led->bank;\r\nif (led->blink)\r\nb->time_use--;\r\nb->level_use--;\r\n}\r\nled->blink = 0;\r\nled->bank = -1;\r\n}\r\nstatic int led_prepare(struct tca6507_led *led)\r\n{\r\nint level = TO_LEVEL(led->led_cdev.brightness);\r\nstruct tca6507_chip *tca = led->chip;\r\nint c1, c2;\r\nint i;\r\nstruct bank *b;\r\nint need_init = 0;\r\nled->led_cdev.brightness = TO_BRIGHT(level);\r\nif (level == 0) {\r\nset_select(tca, led->num, TCA6507_LS_LED_OFF);\r\nreturn 0;\r\n}\r\nif (led->ontime == 0 || led->offtime == 0) {\r\nint best = -1;\r\nint diff = 15-level;\r\nif (level == 15) {\r\nset_select(tca, led->num, TCA6507_LS_LED_ON);\r\nreturn 0;\r\n}\r\nfor (i = MASTER; i >= BANK0; i--) {\r\nint d;\r\nif (tca->bank[i].level == level ||\r\ntca->bank[i].level_use == 0) {\r\nbest = i;\r\nbreak;\r\n}\r\nd = abs(level - tca->bank[i].level);\r\nif (d < diff) {\r\ndiff = d;\r\nbest = i;\r\n}\r\n}\r\nif (best == -1) {\r\nset_select(tca, led->num, TCA6507_LS_LED_ON);\r\nled->led_cdev.brightness = LED_FULL;\r\nreturn 0;\r\n}\r\nif (!tca->bank[best].level_use)\r\nset_level(tca, best, level);\r\ntca->bank[best].level_use++;\r\nled->bank = best;\r\nset_select(tca, led->num, bank_source[best]);\r\nled->led_cdev.brightness = TO_BRIGHT(tca->bank[best].level);\r\nreturn 0;\r\n}\r\nif (choose_times(led->ontime, &c1, &c2) < 0)\r\nreturn -EINVAL;\r\nif (choose_times(led->offtime, &c1, &c2) < 0)\r\nreturn -EINVAL;\r\nfor (i = BANK0; i <= BANK1; i++) {\r\nif (tca->bank[i].level_use == 0)\r\nbreak;\r\nif (tca->bank[i].level != level)\r\ncontinue;\r\nif (tca->bank[i].time_use == 0)\r\nbreak;\r\nif (!(tca->bank[i].on_dflt ||\r\nled->on_dflt ||\r\ntca->bank[i].ontime == led->ontime))\r\ncontinue;\r\nif (!(tca->bank[i].off_dflt ||\r\nled->off_dflt ||\r\ntca->bank[i].offtime == led->offtime))\r\ncontinue;\r\nbreak;\r\n}\r\nif (i > BANK1)\r\nreturn -EINVAL;\r\nb = &tca->bank[i];\r\nif (b->level_use == 0)\r\nset_level(tca, i, level);\r\nb->level_use++;\r\nled->bank = i;\r\nif (b->on_dflt ||\r\n!led->on_dflt ||\r\nb->time_use == 0) {\r\nb->ontime = led->ontime;\r\nb->on_dflt = led->on_dflt;\r\nneed_init = 1;\r\n}\r\nif (b->off_dflt ||\r\n!led->off_dflt ||\r\nb->time_use == 0) {\r\nb->offtime = led->offtime;\r\nb->off_dflt = led->off_dflt;\r\nneed_init = 1;\r\n}\r\nif (need_init)\r\nset_times(tca, i);\r\nled->ontime = b->ontime;\r\nled->offtime = b->offtime;\r\nb->time_use++;\r\nled->blink = 1;\r\nled->led_cdev.brightness = TO_BRIGHT(b->level);\r\nset_select(tca, led->num, blink_source[i]);\r\nreturn 0;\r\n}\r\nstatic int led_assign(struct tca6507_led *led)\r\n{\r\nstruct tca6507_chip *tca = led->chip;\r\nint err;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tca->lock, flags);\r\nled_release(led);\r\nerr = led_prepare(led);\r\nif (err) {\r\nled->ontime = 0;\r\nled->offtime = 0;\r\nled_prepare(led);\r\n}\r\nspin_unlock_irqrestore(&tca->lock, flags);\r\nif (tca->reg_set)\r\nschedule_work(&tca->work);\r\nreturn err;\r\n}\r\nstatic void tca6507_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct tca6507_led *led = container_of(led_cdev, struct tca6507_led,\r\nled_cdev);\r\nled->led_cdev.brightness = brightness;\r\nled->ontime = 0;\r\nled->offtime = 0;\r\nled_assign(led);\r\n}\r\nstatic int tca6507_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct tca6507_led *led = container_of(led_cdev, struct tca6507_led,\r\nled_cdev);\r\nif (*delay_on == 0)\r\nled->on_dflt = 1;\r\nelse if (delay_on != &led_cdev->blink_delay_on)\r\nled->on_dflt = 0;\r\nled->ontime = *delay_on;\r\nif (*delay_off == 0)\r\nled->off_dflt = 1;\r\nelse if (delay_off != &led_cdev->blink_delay_off)\r\nled->off_dflt = 0;\r\nled->offtime = *delay_off;\r\nif (led->ontime == 0)\r\nled->ontime = 512;\r\nif (led->offtime == 0)\r\nled->offtime = 512;\r\nif (led->led_cdev.brightness == LED_OFF)\r\nled->led_cdev.brightness = LED_FULL;\r\nif (led_assign(led) < 0) {\r\nled->ontime = 0;\r\nled->offtime = 0;\r\nled->led_cdev.brightness = LED_OFF;\r\nreturn -EINVAL;\r\n}\r\n*delay_on = led->ontime;\r\n*delay_off = led->offtime;\r\nreturn 0;\r\n}\r\nstatic void tca6507_gpio_set_value(struct gpio_chip *gc,\r\nunsigned offset, int val)\r\n{\r\nstruct tca6507_chip *tca = container_of(gc, struct tca6507_chip, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&tca->lock, flags);\r\nset_select(tca, tca->gpio_map[offset],\r\nval ? TCA6507_LS_LED_OFF : TCA6507_LS_LED_ON);\r\nspin_unlock_irqrestore(&tca->lock, flags);\r\nif (tca->reg_set)\r\nschedule_work(&tca->work);\r\n}\r\nstatic int tca6507_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned offset, int val)\r\n{\r\ntca6507_gpio_set_value(gc, offset, val);\r\nreturn 0;\r\n}\r\nstatic int tca6507_probe_gpios(struct i2c_client *client,\r\nstruct tca6507_chip *tca,\r\nstruct tca6507_platform_data *pdata)\r\n{\r\nint err;\r\nint i = 0;\r\nint gpios = 0;\r\nfor (i = 0; i < NUM_LEDS; i++)\r\nif (pdata->leds.leds[i].name && pdata->leds.leds[i].flags) {\r\ntca->gpio_name[gpios] = pdata->leds.leds[i].name;\r\ntca->gpio_map[gpios] = i;\r\ngpios++;\r\n}\r\nif (!gpios)\r\nreturn 0;\r\ntca->gpio.label = "gpio-tca6507";\r\ntca->gpio.names = tca->gpio_name;\r\ntca->gpio.ngpio = gpios;\r\ntca->gpio.base = pdata->gpio_base;\r\ntca->gpio.owner = THIS_MODULE;\r\ntca->gpio.direction_output = tca6507_gpio_direction_output;\r\ntca->gpio.set = tca6507_gpio_set_value;\r\ntca->gpio.dev = &client->dev;\r\nerr = gpiochip_add(&tca->gpio);\r\nif (err) {\r\ntca->gpio.ngpio = 0;\r\nreturn err;\r\n}\r\nif (pdata->setup)\r\npdata->setup(tca->gpio.base, tca->gpio.ngpio);\r\nreturn 0;\r\n}\r\nstatic void tca6507_remove_gpio(struct tca6507_chip *tca)\r\n{\r\nif (tca->gpio.ngpio) {\r\nint err = gpiochip_remove(&tca->gpio);\r\ndev_err(&tca->client->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", err);\r\n}\r\n}\r\nstatic int tca6507_probe_gpios(struct i2c_client *client,\r\nstruct tca6507_chip *tca,\r\nstruct tca6507_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tca6507_remove_gpio(struct tca6507_chip *tca)\r\n{\r\n}\r\nstatic int __devinit tca6507_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tca6507_chip *tca;\r\nstruct i2c_adapter *adapter;\r\nstruct tca6507_platform_data *pdata;\r\nint err;\r\nint i = 0;\r\nadapter = to_i2c_adapter(client->dev.parent);\r\npdata = client->dev.platform_data;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_I2C))\r\nreturn -EIO;\r\nif (!pdata || pdata->leds.num_leds != NUM_LEDS) {\r\ndev_err(&client->dev, "Need %d entries in platform-data list\n",\r\nNUM_LEDS);\r\nreturn -ENODEV;\r\n}\r\ntca = kzalloc(sizeof(*tca), GFP_KERNEL);\r\nif (!tca)\r\nreturn -ENOMEM;\r\ntca->client = client;\r\nINIT_WORK(&tca->work, tca6507_work);\r\nspin_lock_init(&tca->lock);\r\ni2c_set_clientdata(client, tca);\r\nfor (i = 0; i < NUM_LEDS; i++) {\r\nstruct tca6507_led *l = tca->leds + i;\r\nl->chip = tca;\r\nl->num = i;\r\nif (pdata->leds.leds[i].name && !pdata->leds.leds[i].flags) {\r\nl->led_cdev.name = pdata->leds.leds[i].name;\r\nl->led_cdev.default_trigger\r\n= pdata->leds.leds[i].default_trigger;\r\nl->led_cdev.brightness_set = tca6507_brightness_set;\r\nl->led_cdev.blink_set = tca6507_blink_set;\r\nl->bank = -1;\r\nerr = led_classdev_register(&client->dev,\r\n&l->led_cdev);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\n}\r\nerr = tca6507_probe_gpios(client, tca, pdata);\r\nif (err)\r\ngoto exit;\r\ntca->reg_set = 0x7f;\r\nschedule_work(&tca->work);\r\nreturn 0;\r\nexit:\r\nwhile (i--) {\r\nif (tca->leds[i].led_cdev.name)\r\nled_classdev_unregister(&tca->leds[i].led_cdev);\r\n}\r\nkfree(tca);\r\nreturn err;\r\n}\r\nstatic int __devexit tca6507_remove(struct i2c_client *client)\r\n{\r\nint i;\r\nstruct tca6507_chip *tca = i2c_get_clientdata(client);\r\nstruct tca6507_led *tca_leds = tca->leds;\r\nfor (i = 0; i < NUM_LEDS; i++) {\r\nif (tca_leds[i].led_cdev.name)\r\nled_classdev_unregister(&tca_leds[i].led_cdev);\r\n}\r\ntca6507_remove_gpio(tca);\r\ncancel_work_sync(&tca->work);\r\nkfree(tca);\r\nreturn 0;\r\n}\r\nstatic int __init tca6507_leds_init(void)\r\n{\r\nreturn i2c_add_driver(&tca6507_driver);\r\n}\r\nstatic void __exit tca6507_leds_exit(void)\r\n{\r\ni2c_del_driver(&tca6507_driver);\r\n}
