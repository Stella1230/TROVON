static int max7359_write_reg(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret < 0)\r\ndev_err(&client->dev, "%s: reg 0x%x, val 0x%x, err %d\n",\r\n__func__, reg, val, ret);\r\nreturn ret;\r\n}\r\nstatic int max7359_read_reg(struct i2c_client *client, int reg)\r\n{\r\nint ret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ndev_err(&client->dev, "%s: reg 0x%x, err %d\n",\r\n__func__, reg, ret);\r\nreturn ret;\r\n}\r\nstatic void max7359_build_keycode(struct max7359_keypad *keypad,\r\nconst struct matrix_keymap_data *keymap_data)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nint i;\r\nfor (i = 0; i < keymap_data->keymap_size; i++) {\r\nunsigned int key = keymap_data->keymap[i];\r\nunsigned int row = KEY_ROW(key);\r\nunsigned int col = KEY_COL(key);\r\nunsigned int scancode = MATRIX_SCAN_CODE(row, col,\r\nMAX7359_ROW_SHIFT);\r\nunsigned short keycode = KEY_VAL(key);\r\nkeypad->keycodes[scancode] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\n}\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\n}\r\nstatic irqreturn_t max7359_interrupt(int irq, void *dev_id)\r\n{\r\nstruct max7359_keypad *keypad = dev_id;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nint val, row, col, release, code;\r\nval = max7359_read_reg(keypad->client, MAX7359_REG_KEYFIFO);\r\nrow = val & 0x7;\r\ncol = (val >> 3) & 0x7;\r\nrelease = val & 0x40;\r\ncode = MATRIX_SCAN_CODE(row, col, MAX7359_ROW_SHIFT);\r\ndev_dbg(&keypad->client->dev,\r\n"key[%d:%d] %s\n", row, col, release ? "release" : "press");\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code], !release);\r\ninput_sync(input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void max7359_fall_deepsleep(struct i2c_client *client)\r\n{\r\nmax7359_write_reg(client, MAX7359_REG_SLEEP, MAX7359_AUTOSLEEP_8192);\r\n}\r\nstatic inline void max7359_take_catnap(struct i2c_client *client)\r\n{\r\nmax7359_write_reg(client, MAX7359_REG_SLEEP, MAX7359_AUTOSLEEP_256);\r\n}\r\nstatic int max7359_open(struct input_dev *dev)\r\n{\r\nstruct max7359_keypad *keypad = input_get_drvdata(dev);\r\nmax7359_take_catnap(keypad->client);\r\nreturn 0;\r\n}\r\nstatic void max7359_close(struct input_dev *dev)\r\n{\r\nstruct max7359_keypad *keypad = input_get_drvdata(dev);\r\nmax7359_fall_deepsleep(keypad->client);\r\n}\r\nstatic void max7359_initialize(struct i2c_client *client)\r\n{\r\nmax7359_write_reg(client, MAX7359_REG_CONFIG,\r\nMAX7359_CFG_INTERRUPT |\r\nMAX7359_CFG_KEY_RELEASE |\r\nMAX7359_CFG_WAKEUP);\r\nmax7359_write_reg(client, MAX7359_REG_DEBOUNCE, 0x1F);\r\nmax7359_write_reg(client, MAX7359_REG_INTERRUPT, 0x01);\r\nmax7359_fall_deepsleep(client);\r\n}\r\nstatic int __devinit max7359_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct matrix_keymap_data *keymap_data = client->dev.platform_data;\r\nstruct max7359_keypad *keypad;\r\nstruct input_dev *input_dev;\r\nint ret;\r\nint error;\r\nif (!client->irq) {\r\ndev_err(&client->dev, "The irq number should not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nret = max7359_read_reg(client, MAX7359_REG_KEYFIFO);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to detect device\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&client->dev, "keys FIFO is 0x%02x\n", ret);\r\nkeypad = kzalloc(sizeof(struct max7359_keypad), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!keypad || !input_dev) {\r\ndev_err(&client->dev, "failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto failed_free_mem;\r\n}\r\nkeypad->client = client;\r\nkeypad->input_dev = input_dev;\r\ninput_dev->name = client->name;\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->open = max7359_open;\r\ninput_dev->close = max7359_close;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\ninput_dev->keycodesize = sizeof(keypad->keycodes[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\r\ninput_dev->keycode = keypad->keycodes;\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, keypad);\r\nmax7359_build_keycode(keypad, keymap_data);\r\nerror = request_threaded_irq(client->irq, NULL, max7359_interrupt,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nclient->name, keypad);\r\nif (error) {\r\ndev_err(&client->dev, "failed to register interrupt\n");\r\ngoto failed_free_mem;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "failed to register input device\n");\r\ngoto failed_free_irq;\r\n}\r\nmax7359_initialize(client);\r\ni2c_set_clientdata(client, keypad);\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\nfailed_free_irq:\r\nfree_irq(client->irq, keypad);\r\nfailed_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(keypad);\r\nreturn error;\r\n}\r\nstatic int __devexit max7359_remove(struct i2c_client *client)\r\n{\r\nstruct max7359_keypad *keypad = i2c_get_clientdata(client);\r\nfree_irq(client->irq, keypad);\r\ninput_unregister_device(keypad->input_dev);\r\nkfree(keypad);\r\nreturn 0;\r\n}\r\nstatic int max7359_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nmax7359_fall_deepsleep(client);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int max7359_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nmax7359_take_catnap(client);\r\nreturn 0;\r\n}
