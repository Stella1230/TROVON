static void cfrfml_release(struct cflayer *layer)\r\n{\r\nstruct cfsrvl *srvl = container_of(layer, struct cfsrvl, layer);\r\nstruct cfrfml *rfml = container_obj(&srvl->layer);\r\nif (rfml->incomplete_frm)\r\ncfpkt_destroy(rfml->incomplete_frm);\r\nkfree(srvl);\r\n}\r\nstruct cflayer *cfrfml_create(u8 channel_id, struct dev_info *dev_info,\r\nint mtu_size)\r\n{\r\nint tmp;\r\nstruct cfrfml *this = kzalloc(sizeof(struct cfrfml), GFP_ATOMIC);\r\nif (!this)\r\nreturn NULL;\r\ncfsrvl_init(&this->serv, channel_id, dev_info, false);\r\nthis->serv.release = cfrfml_release;\r\nthis->serv.layer.receive = cfrfml_receive;\r\nthis->serv.layer.transmit = cfrfml_transmit;\r\ntmp = (mtu_size - RFM_HEAD_SIZE - 6) / 16;\r\ntmp *= 16;\r\nthis->fragment_size = tmp;\r\nspin_lock_init(&this->sync);\r\nsnprintf(this->serv.layer.name, CAIF_LAYER_NAME_SZ,\r\n"rfm%d", channel_id);\r\nreturn &this->serv.layer;\r\n}\r\nstatic struct cfpkt *rfm_append(struct cfrfml *rfml, char *seghead,\r\nstruct cfpkt *pkt, int *err)\r\n{\r\nstruct cfpkt *tmppkt;\r\n*err = -EPROTO;\r\nif (cfpkt_extr_head(pkt, seghead, 6) < 0)\r\nreturn NULL;\r\nif (memcmp(seghead, rfml->seghead, 6) != 0)\r\nreturn NULL;\r\ntmppkt = cfpkt_append(rfml->incomplete_frm, pkt,\r\nrfml->pdu_size + RFM_HEAD_SIZE);\r\n*err = -ENOMEM;\r\nif (tmppkt == NULL)\r\nreturn NULL;\r\n*err = 0;\r\nreturn tmppkt;\r\n}\r\nstatic int cfrfml_receive(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nu8 tmp;\r\nbool segmented;\r\nint err;\r\nu8 seghead[6];\r\nstruct cfrfml *rfml;\r\nstruct cfpkt *tmppkt = NULL;\r\ncaif_assert(layr->up != NULL);\r\ncaif_assert(layr->receive != NULL);\r\nrfml = container_obj(layr);\r\nspin_lock(&rfml->sync);\r\nerr = -EPROTO;\r\nif (cfpkt_extr_head(pkt, &tmp, 1) < 0)\r\ngoto out;\r\nsegmented = tmp & RFM_SEGMENTATION_BIT;\r\nif (segmented) {\r\nif (rfml->incomplete_frm == NULL) {\r\nif (cfpkt_peek_head(pkt, rfml->seghead, 6) < 0)\r\ngoto out;\r\nrfml->pdu_size = get_unaligned_le16(rfml->seghead+4);\r\nif (cfpkt_erroneous(pkt))\r\ngoto out;\r\nrfml->incomplete_frm = pkt;\r\npkt = NULL;\r\n} else {\r\ntmppkt = rfm_append(rfml, seghead, pkt, &err);\r\nif (tmppkt == NULL)\r\ngoto out;\r\nif (cfpkt_erroneous(tmppkt))\r\ngoto out;\r\nrfml->incomplete_frm = tmppkt;\r\nif (cfpkt_erroneous(tmppkt))\r\ngoto out;\r\n}\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (rfml->incomplete_frm) {\r\ntmppkt = rfm_append(rfml, seghead, pkt, &err);\r\nif (tmppkt == NULL)\r\ngoto out;\r\nif (cfpkt_erroneous(tmppkt))\r\ngoto out;\r\nrfml->incomplete_frm = NULL;\r\npkt = tmppkt;\r\ntmppkt = NULL;\r\nerr = EPROTO;\r\nif (rfml->pdu_size != cfpkt_getlen(pkt) - RFM_HEAD_SIZE + 1)\r\ngoto out;\r\n}\r\nerr = rfml->serv.layer.up->receive(rfml->serv.layer.up, pkt);\r\nout:\r\nif (err != 0) {\r\nif (tmppkt)\r\ncfpkt_destroy(tmppkt);\r\nif (pkt)\r\ncfpkt_destroy(pkt);\r\nif (rfml->incomplete_frm)\r\ncfpkt_destroy(rfml->incomplete_frm);\r\nrfml->incomplete_frm = NULL;\r\npr_info("Connection error %d triggered on RFM link\n", err);\r\nlayr->up->ctrlcmd(layr->up, CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND,\r\nrfml->serv.dev_info.id);\r\n}\r\nspin_unlock(&rfml->sync);\r\nif (unlikely(err == -EAGAIN))\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nstatic int cfrfml_transmit_segment(struct cfrfml *rfml, struct cfpkt *pkt)\r\n{\r\ncaif_assert(cfpkt_getlen(pkt) < rfml->fragment_size + RFM_HEAD_SIZE);\r\ncfpkt_info(pkt)->channel_id = rfml->serv.layer.id;\r\ncfpkt_info(pkt)->hdr_len = RFM_HEAD_SIZE;\r\ncfpkt_info(pkt)->dev_info = &rfml->serv.dev_info;\r\nreturn rfml->serv.layer.dn->transmit(rfml->serv.layer.dn, pkt);\r\n}\r\nstatic int cfrfml_transmit(struct cflayer *layr, struct cfpkt *pkt)\r\n{\r\nint err;\r\nu8 seg;\r\nu8 head[6];\r\nstruct cfpkt *rearpkt = NULL;\r\nstruct cfpkt *frontpkt = pkt;\r\nstruct cfrfml *rfml = container_obj(layr);\r\ncaif_assert(layr->dn != NULL);\r\ncaif_assert(layr->dn->transmit != NULL);\r\nif (!cfsrvl_ready(&rfml->serv, &err))\r\ngoto out;\r\nerr = -EPROTO;\r\nif (cfpkt_getlen(pkt) <= RFM_HEAD_SIZE-1)\r\ngoto out;\r\nerr = 0;\r\nif (cfpkt_getlen(pkt) > rfml->fragment_size + RFM_HEAD_SIZE)\r\nerr = cfpkt_peek_head(pkt, head, 6);\r\nif (err < 0)\r\ngoto out;\r\nwhile (cfpkt_getlen(frontpkt) > rfml->fragment_size + RFM_HEAD_SIZE) {\r\nseg = 1;\r\nerr = -EPROTO;\r\nif (cfpkt_add_head(frontpkt, &seg, 1) < 0)\r\ngoto out;\r\nrearpkt = cfpkt_split(frontpkt, rfml->fragment_size);\r\nif (rearpkt == NULL)\r\ngoto out;\r\nerr = cfrfml_transmit_segment(rfml, frontpkt);\r\nif (err != 0) {\r\nfrontpkt = NULL;\r\ngoto out;\r\n}\r\nfrontpkt = rearpkt;\r\nrearpkt = NULL;\r\nerr = -ENOMEM;\r\nif (frontpkt == NULL)\r\ngoto out;\r\nerr = -EPROTO;\r\nif (cfpkt_add_head(frontpkt, head, 6) < 0)\r\ngoto out;\r\n}\r\nseg = 0;\r\nerr = -EPROTO;\r\nif (cfpkt_add_head(frontpkt, &seg, 1) < 0)\r\ngoto out;\r\nerr = cfrfml_transmit_segment(rfml, frontpkt);\r\nfrontpkt = NULL;\r\nout:\r\nif (err != 0) {\r\npr_info("Connection error %d triggered on RFM link\n", err);\r\nlayr->up->ctrlcmd(layr->up, CAIF_CTRLCMD_REMOTE_SHUTDOWN_IND,\r\nrfml->serv.dev_info.id);\r\nif (rearpkt)\r\ncfpkt_destroy(rearpkt);\r\nif (frontpkt)\r\ncfpkt_destroy(frontpkt);\r\n}\r\nreturn err;\r\n}
