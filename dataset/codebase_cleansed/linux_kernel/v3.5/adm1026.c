static int adm1026_read_value(struct i2c_client *client, u8 reg)\r\n{\r\nint res;\r\nif (reg < 0x80) {\r\nres = i2c_smbus_read_byte_data(client, reg) & 0xff;\r\n} else {\r\nres = 0;\r\n}\r\nreturn res;\r\n}\r\nstatic int adm1026_write_value(struct i2c_client *client, u8 reg, int value)\r\n{\r\nint res;\r\nif (reg < 0x80) {\r\nres = i2c_smbus_write_byte_data(client, reg, value);\r\n} else {\r\nres = 0;\r\n}\r\nreturn res;\r\n}\r\nstatic void adm1026_init_client(struct i2c_client *client)\r\n{\r\nint value, i;\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "Initializing device\n");\r\ndata->config1 = adm1026_read_value(client, ADM1026_REG_CONFIG1);\r\ndata->config2 = adm1026_read_value(client, ADM1026_REG_CONFIG2);\r\ndata->config3 = adm1026_read_value(client, ADM1026_REG_CONFIG3);\r\ndev_dbg(&client->dev, "ADM1026_REG_CONFIG1 is: 0x%02x\n",\r\ndata->config1);\r\nif ((data->config1 & CFG1_MONITOR) == 0) {\r\ndev_dbg(&client->dev, "Monitoring not currently "\r\n"enabled.\n");\r\n}\r\nif (data->config1 & CFG1_INT_ENABLE) {\r\ndev_dbg(&client->dev, "SMBALERT interrupts are "\r\n"enabled.\n");\r\n}\r\nif (data->config1 & CFG1_AIN8_9) {\r\ndev_dbg(&client->dev, "in8 and in9 enabled. "\r\n"temp3 disabled.\n");\r\n} else {\r\ndev_dbg(&client->dev, "temp3 enabled. in8 and "\r\n"in9 disabled.\n");\r\n}\r\nif (data->config1 & CFG1_THERM_HOT) {\r\ndev_dbg(&client->dev, "Automatic THERM, PWM, "\r\n"and temp limits enabled.\n");\r\n}\r\nif (data->config3 & CFG3_GPIO16_ENABLE) {\r\ndev_dbg(&client->dev, "GPIO16 enabled. THERM "\r\n"pin disabled.\n");\r\n} else {\r\ndev_dbg(&client->dev, "THERM pin enabled. "\r\n"GPIO16 disabled.\n");\r\n}\r\nif (data->config3 & CFG3_VREF_250)\r\ndev_dbg(&client->dev, "Vref is 2.50 Volts.\n");\r\nelse\r\ndev_dbg(&client->dev, "Vref is 1.82 Volts.\n");\r\nvalue = 0;\r\nfor (i = 0; i <= 15; ++i) {\r\nif ((i & 0x03) == 0) {\r\nvalue = adm1026_read_value(client,\r\nADM1026_REG_GPIO_CFG_0_3 + i / 4);\r\n}\r\ndata->gpio_config[i] = value & 0x03;\r\nvalue >>= 2;\r\n}\r\ndata->gpio_config[16] = (data->config3 >> 6) & 0x03;\r\nadm1026_print_gpio(client);\r\nif (gpio_input[0] != -1 || gpio_output[0] != -1\r\n|| gpio_inverted[0] != -1 || gpio_normal[0] != -1\r\n|| gpio_fan[0] != -1) {\r\nadm1026_fixup_gpio(client);\r\n}\r\ndata->pwm1.auto_pwm_min = 255;\r\nvalue = adm1026_read_value(client, ADM1026_REG_CONFIG1);\r\nvalue = (value | CFG1_MONITOR) & (~CFG1_INT_CLEAR & ~CFG1_RESET);\r\ndev_dbg(&client->dev, "Setting CONFIG to: 0x%02x\n", value);\r\ndata->config1 = value;\r\nadm1026_write_value(client, ADM1026_REG_CONFIG1, value);\r\nvalue = adm1026_read_value(client, ADM1026_REG_FAN_DIV_0_3) |\r\n(adm1026_read_value(client, ADM1026_REG_FAN_DIV_4_7) << 8);\r\nfor (i = 0; i <= 7; ++i) {\r\ndata->fan_div[i] = DIV_FROM_REG(value & 0x03);\r\nvalue >>= 2;\r\n}\r\n}\r\nstatic void adm1026_print_gpio(struct i2c_client *client)\r\n{\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nint i;\r\ndev_dbg(&client->dev, "GPIO config is:\n");\r\nfor (i = 0; i <= 7; ++i) {\r\nif (data->config2 & (1 << i)) {\r\ndev_dbg(&client->dev, "\t%sGP%s%d\n",\r\ndata->gpio_config[i] & 0x02 ? "" : "!",\r\ndata->gpio_config[i] & 0x01 ? "OUT" : "IN",\r\ni);\r\n} else {\r\ndev_dbg(&client->dev, "\tFAN%d\n", i);\r\n}\r\n}\r\nfor (i = 8; i <= 15; ++i) {\r\ndev_dbg(&client->dev, "\t%sGP%s%d\n",\r\ndata->gpio_config[i] & 0x02 ? "" : "!",\r\ndata->gpio_config[i] & 0x01 ? "OUT" : "IN",\r\ni);\r\n}\r\nif (data->config3 & CFG3_GPIO16_ENABLE) {\r\ndev_dbg(&client->dev, "\t%sGP%s16\n",\r\ndata->gpio_config[16] & 0x02 ? "" : "!",\r\ndata->gpio_config[16] & 0x01 ? "OUT" : "IN");\r\n} else {\r\ndev_dbg(&client->dev, "\tTHERM\n");\r\n}\r\n}\r\nstatic void adm1026_fixup_gpio(struct i2c_client *client)\r\n{\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nint i;\r\nint value;\r\nfor (i = 0; i <= 16; ++i) {\r\nif (gpio_output[i] >= 0 && gpio_output[i] <= 16)\r\ndata->gpio_config[gpio_output[i]] |= 0x01;\r\nif (gpio_output[i] >= 0 && gpio_output[i] <= 7)\r\ndata->config2 |= 1 << gpio_output[i];\r\n}\r\nfor (i = 0; i <= 16; ++i) {\r\nif (gpio_input[i] >= 0 && gpio_input[i] <= 16)\r\ndata->gpio_config[gpio_input[i]] &= ~0x01;\r\nif (gpio_input[i] >= 0 && gpio_input[i] <= 7)\r\ndata->config2 |= 1 << gpio_input[i];\r\n}\r\nfor (i = 0; i <= 16; ++i) {\r\nif (gpio_inverted[i] >= 0 && gpio_inverted[i] <= 16)\r\ndata->gpio_config[gpio_inverted[i]] &= ~0x02;\r\n}\r\nfor (i = 0; i <= 16; ++i) {\r\nif (gpio_normal[i] >= 0 && gpio_normal[i] <= 16)\r\ndata->gpio_config[gpio_normal[i]] |= 0x02;\r\n}\r\nfor (i = 0; i <= 7; ++i) {\r\nif (gpio_fan[i] >= 0 && gpio_fan[i] <= 7)\r\ndata->config2 &= ~(1 << gpio_fan[i]);\r\n}\r\nadm1026_write_value(client, ADM1026_REG_CONFIG2, data->config2);\r\ndata->config3 = (data->config3 & 0x3f)\r\n| ((data->gpio_config[16] & 0x03) << 6);\r\nadm1026_write_value(client, ADM1026_REG_CONFIG3, data->config3);\r\nfor (i = 15, value = 0; i >= 0; --i) {\r\nvalue <<= 2;\r\nvalue |= data->gpio_config[i] & 0x03;\r\nif ((i & 0x03) == 0) {\r\nadm1026_write_value(client,\r\nADM1026_REG_GPIO_CFG_0_3 + i/4,\r\nvalue);\r\nvalue = 0;\r\n}\r\n}\r\nadm1026_print_gpio(client);\r\n}\r\nstatic struct adm1026_data *adm1026_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nint i;\r\nlong value, alarms, gpio;\r\nmutex_lock(&data->update_lock);\r\nif (!data->valid\r\n|| time_after(jiffies,\r\ndata->last_reading + ADM1026_DATA_INTERVAL)) {\r\ndev_dbg(&client->dev, "Reading sensor values\n");\r\nfor (i = 0; i <= 16; ++i) {\r\ndata->in[i] =\r\nadm1026_read_value(client, ADM1026_REG_IN[i]);\r\n}\r\nfor (i = 0; i <= 7; ++i) {\r\ndata->fan[i] =\r\nadm1026_read_value(client, ADM1026_REG_FAN(i));\r\n}\r\nfor (i = 0; i <= 2; ++i) {\r\ndata->temp[i] =\r\nadm1026_read_value(client, ADM1026_REG_TEMP[i]);\r\n}\r\ndata->pwm1.pwm = adm1026_read_value(client,\r\nADM1026_REG_PWM);\r\ndata->analog_out = adm1026_read_value(client,\r\nADM1026_REG_DAC);\r\nalarms = adm1026_read_value(client, ADM1026_REG_STATUS4);\r\ngpio = alarms & 0x80 ? 0x0100 : 0;\r\nalarms &= 0x7f;\r\nalarms <<= 8;\r\nalarms |= adm1026_read_value(client, ADM1026_REG_STATUS3);\r\nalarms <<= 8;\r\nalarms |= adm1026_read_value(client, ADM1026_REG_STATUS2);\r\nalarms <<= 8;\r\nalarms |= adm1026_read_value(client, ADM1026_REG_STATUS1);\r\ndata->alarms = alarms;\r\ngpio |= adm1026_read_value(client,\r\nADM1026_REG_GPIO_STATUS_8_15);\r\ngpio <<= 8;\r\ngpio |= adm1026_read_value(client,\r\nADM1026_REG_GPIO_STATUS_0_7);\r\ndata->gpio = gpio;\r\ndata->last_reading = jiffies;\r\n};\r\nif (!data->valid ||\r\ntime_after(jiffies, data->last_config + ADM1026_CONFIG_INTERVAL)) {\r\ndev_dbg(&client->dev, "Reading config values\n");\r\nfor (i = 0; i <= 16; ++i) {\r\ndata->in_min[i] = adm1026_read_value(client,\r\nADM1026_REG_IN_MIN[i]);\r\ndata->in_max[i] = adm1026_read_value(client,\r\nADM1026_REG_IN_MAX[i]);\r\n}\r\nvalue = adm1026_read_value(client, ADM1026_REG_FAN_DIV_0_3)\r\n| (adm1026_read_value(client, ADM1026_REG_FAN_DIV_4_7)\r\n<< 8);\r\nfor (i = 0; i <= 7; ++i) {\r\ndata->fan_min[i] = adm1026_read_value(client,\r\nADM1026_REG_FAN_MIN(i));\r\ndata->fan_div[i] = DIV_FROM_REG(value & 0x03);\r\nvalue >>= 2;\r\n}\r\nfor (i = 0; i <= 2; ++i) {\r\ndata->temp_min[i] = adm1026_read_value(client,\r\nADM1026_REG_TEMP_MIN[i]);\r\ndata->temp_max[i] = adm1026_read_value(client,\r\nADM1026_REG_TEMP_MAX[i]);\r\ndata->temp_tmin[i] = adm1026_read_value(client,\r\nADM1026_REG_TEMP_TMIN[i]);\r\ndata->temp_crit[i] = adm1026_read_value(client,\r\nADM1026_REG_TEMP_THERM[i]);\r\ndata->temp_offset[i] = adm1026_read_value(client,\r\nADM1026_REG_TEMP_OFFSET[i]);\r\n}\r\nalarms = adm1026_read_value(client, ADM1026_REG_MASK4);\r\ngpio = alarms & 0x80 ? 0x0100 : 0;\r\nalarms = (alarms & 0x7f) << 8;\r\nalarms |= adm1026_read_value(client, ADM1026_REG_MASK3);\r\nalarms <<= 8;\r\nalarms |= adm1026_read_value(client, ADM1026_REG_MASK2);\r\nalarms <<= 8;\r\nalarms |= adm1026_read_value(client, ADM1026_REG_MASK1);\r\ndata->alarm_mask = alarms;\r\ngpio |= adm1026_read_value(client,\r\nADM1026_REG_GPIO_MASK_8_15);\r\ngpio <<= 8;\r\ngpio |= adm1026_read_value(client, ADM1026_REG_GPIO_MASK_0_7);\r\ndata->gpio_mask = gpio;\r\ndata->config1 = adm1026_read_value(client,\r\nADM1026_REG_CONFIG1);\r\nif (data->config1 & CFG1_PWM_AFC) {\r\ndata->pwm1.enable = 2;\r\ndata->pwm1.auto_pwm_min =\r\nPWM_MIN_FROM_REG(data->pwm1.pwm);\r\n}\r\ndata->config2 = adm1026_read_value(client,\r\nADM1026_REG_CONFIG2);\r\ndata->config3 = adm1026_read_value(client,\r\nADM1026_REG_CONFIG3);\r\ndata->gpio_config[16] = (data->config3 >> 6) & 0x03;\r\nvalue = 0;\r\nfor (i = 0; i <= 15; ++i) {\r\nif ((i & 0x03) == 0) {\r\nvalue = adm1026_read_value(client,\r\nADM1026_REG_GPIO_CFG_0_3 + i/4);\r\n}\r\ndata->gpio_config[i] = value & 0x03;\r\nvalue >>= 2;\r\n}\r\ndata->last_config = jiffies;\r\n};\r\ndata->valid = 1;\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(nr, data->in[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(nr, data->in_min[nr]));\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[nr] = INS_TO_REG(nr, val);\r\nadm1026_write_value(client, ADM1026_REG_IN_MIN[nr], data->in_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(nr, data->in_max[nr]));\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[nr] = INS_TO_REG(nr, val);\r\nadm1026_write_value(client, ADM1026_REG_IN_MAX[nr], data->in_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in16(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(16, data->in[16]) -\r\nNEG12_OFFSET);\r\n}\r\nstatic ssize_t show_in16_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(16, data->in_min[16])\r\n- NEG12_OFFSET);\r\n}\r\nstatic ssize_t set_in16_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[16] = INS_TO_REG(16, val + NEG12_OFFSET);\r\nadm1026_write_value(client, ADM1026_REG_IN_MIN[16], data->in_min[16]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in16_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(16, data->in_max[16])\r\n- NEG12_OFFSET);\r\n}\r\nstatic ssize_t set_in16_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[16] = INS_TO_REG(16, val+NEG12_OFFSET);\r\nadm1026_write_value(client, ADM1026_REG_IN_MAX[16], data->in_max[16]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr],\r\ndata->fan_div[nr]));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr],\r\ndata->fan_div[nr]));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val, data->fan_div[nr]);\r\nadm1026_write_value(client, ADM1026_REG_FAN_MIN(nr),\r\ndata->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void fixup_fan_min(struct device *dev, int fan, int old_div)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nint new_min;\r\nint new_div = data->fan_div[fan];\r\nif (data->fan_min[fan] == 0 || data->fan_min[fan] == 0xff)\r\nreturn;\r\nnew_min = data->fan_min[fan] * old_div / new_div;\r\nnew_min = SENSORS_LIMIT(new_min, 1, 254);\r\ndata->fan_min[fan] = new_min;\r\nadm1026_write_value(client, ADM1026_REG_FAN_MIN(fan), new_min);\r\n}\r\nstatic ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->fan_div[nr]);\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint orig_div, new_div;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nnew_div = DIV_TO_REG(val);\r\nmutex_lock(&data->update_lock);\r\norig_div = data->fan_div[nr];\r\ndata->fan_div[nr] = DIV_FROM_REG(new_div);\r\nif (nr < 4) {\r\nadm1026_write_value(client, ADM1026_REG_FAN_DIV_0_3,\r\n(DIV_TO_REG(data->fan_div[0]) << 0) |\r\n(DIV_TO_REG(data->fan_div[1]) << 2) |\r\n(DIV_TO_REG(data->fan_div[2]) << 4) |\r\n(DIV_TO_REG(data->fan_div[3]) << 6));\r\n} else {\r\nadm1026_write_value(client, ADM1026_REG_FAN_DIV_4_7,\r\n(DIV_TO_REG(data->fan_div[4]) << 0) |\r\n(DIV_TO_REG(data->fan_div[5]) << 2) |\r\n(DIV_TO_REG(data->fan_div[6]) << 4) |\r\n(DIV_TO_REG(data->fan_div[7]) << 6));\r\n}\r\nif (data->fan_div[nr] != orig_div)\r\nfixup_fan_min(dev, nr, orig_div);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[nr]));\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_min[nr]));\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_min[nr] = TEMP_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_TEMP_MIN[nr],\r\ndata->temp_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max[nr]));\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[nr] = TEMP_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_TEMP_MAX[nr],\r\ndata->temp_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_offset(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_offset[nr]));\r\n}\r\nstatic ssize_t set_temp_offset(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_offset[nr] = TEMP_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_TEMP_OFFSET[nr],\r\ndata->temp_offset[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_point1_temp_hyst(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(\r\nADM1026_FAN_ACTIVATION_TEMP_HYST + data->temp_tmin[nr]));\r\n}\r\nstatic ssize_t show_temp_auto_point2_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_tmin[nr] +\r\nADM1026_FAN_CONTROL_TEMP_RANGE));\r\n}\r\nstatic ssize_t show_temp_auto_point1_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_tmin[nr]));\r\n}\r\nstatic ssize_t set_temp_auto_point1_temp(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_tmin[nr] = TEMP_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_TEMP_TMIN[nr],\r\ndata->temp_tmin[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_crit_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", (data->config1 & CFG1_THERM_HOT) >> 4);\r\n}\r\nstatic ssize_t set_temp_crit_enable(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->config1 = (data->config1 & ~CFG1_THERM_HOT) | (val << 4);\r\nadm1026_write_value(client, ADM1026_REG_CONFIG1, data->config1);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_crit(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_crit[nr]));\r\n}\r\nstatic ssize_t set_temp_crit(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);\r\nint nr = sensor_attr->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_crit[nr] = TEMP_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_TEMP_THERM[nr],\r\ndata->temp_crit[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_analog_out_reg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", DAC_FROM_REG(data->analog_out));\r\n}\r\nstatic ssize_t set_analog_out_reg(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->analog_out = DAC_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_DAC, data->analog_out);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid_reg(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nint vid = (data->gpio >> 11) & 0x1f;\r\ndev_dbg(dev, "Setting VID from GPIO11-15.\n");\r\nreturn sprintf(buf, "%d\n", vid_from_reg(vid, data->vrm));\r\n}\r\nstatic ssize_t show_vrm_reg(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->vrm);\r\n}\r\nstatic ssize_t store_vrm_reg(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adm1026_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms_reg(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nint bitnr = to_sensor_dev_attr(attr)->index;\r\nreturn sprintf(buf, "%ld\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t show_alarm_mask(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", data->alarm_mask);\r\n}\r\nstatic ssize_t set_alarm_mask(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nunsigned long mask;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->alarm_mask = val & 0x7fffffff;\r\nmask = data->alarm_mask\r\n| (data->gpio_mask & 0x10000 ? 0x80000000 : 0);\r\nadm1026_write_value(client, ADM1026_REG_MASK1,\r\nmask & 0xff);\r\nmask >>= 8;\r\nadm1026_write_value(client, ADM1026_REG_MASK2,\r\nmask & 0xff);\r\nmask >>= 8;\r\nadm1026_write_value(client, ADM1026_REG_MASK3,\r\nmask & 0xff);\r\nmask >>= 8;\r\nadm1026_write_value(client, ADM1026_REG_MASK4,\r\nmask & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_gpio(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", data->gpio);\r\n}\r\nstatic ssize_t set_gpio(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong gpio;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->gpio = val & 0x1ffff;\r\ngpio = data->gpio;\r\nadm1026_write_value(client, ADM1026_REG_GPIO_STATUS_0_7, gpio & 0xff);\r\ngpio >>= 8;\r\nadm1026_write_value(client, ADM1026_REG_GPIO_STATUS_8_15, gpio & 0xff);\r\ngpio = ((gpio >> 1) & 0x80) | (data->alarms >> 24 & 0x7f);\r\nadm1026_write_value(client, ADM1026_REG_STATUS4, gpio & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_gpio_mask(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%ld\n", data->gpio_mask);\r\n}\r\nstatic ssize_t set_gpio_mask(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nlong mask;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->gpio_mask = val & 0x1ffff;\r\nmask = data->gpio_mask;\r\nadm1026_write_value(client, ADM1026_REG_GPIO_MASK_0_7, mask & 0xff);\r\nmask >>= 8;\r\nadm1026_write_value(client, ADM1026_REG_GPIO_MASK_8_15, mask & 0xff);\r\nmask = ((mask >> 1) & 0x80) | (data->alarm_mask >> 24 & 0x7f);\r\nadm1026_write_value(client, ADM1026_REG_MASK1, mask & 0xff);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_reg(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_REG(data->pwm1.pwm));\r\n}\r\nstatic ssize_t set_pwm_reg(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nif (data->pwm1.enable == 1) {\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm1.pwm = PWM_TO_REG(val);\r\nadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\r\nmutex_unlock(&data->update_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_pwm_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1.auto_pwm_min);\r\n}\r\nstatic ssize_t set_auto_pwm_min(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm1.auto_pwm_min = SENSORS_LIMIT(val, 0, 255);\r\nif (data->pwm1.enable == 2) {\r\ndata->pwm1.pwm = PWM_TO_REG((data->pwm1.pwm & 0x0f) |\r\nPWM_MIN_TO_REG(data->pwm1.auto_pwm_min));\r\nadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_auto_pwm_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", ADM1026_PWM_MAX);\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adm1026_data *data = adm1026_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1.enable);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nint old_enable;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val >= 3)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nold_enable = data->pwm1.enable;\r\ndata->pwm1.enable = val;\r\ndata->config1 = (data->config1 & ~CFG1_PWM_AFC)\r\n| ((val == 2) ? CFG1_PWM_AFC : 0);\r\nadm1026_write_value(client, ADM1026_REG_CONFIG1, data->config1);\r\nif (val == 2) {\r\ndata->pwm1.pwm = PWM_TO_REG((data->pwm1.pwm & 0x0f) |\r\nPWM_MIN_TO_REG(data->pwm1.auto_pwm_min));\r\nadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\r\n} else if (!((old_enable == 1) && (val == 1))) {\r\ndata->pwm1.pwm = 255;\r\nadm1026_write_value(client, ADM1026_REG_PWM, data->pwm1.pwm);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int adm1026_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint address = client->addr;\r\nint company, verstep;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\nreturn -ENODEV;\r\n};\r\ncompany = adm1026_read_value(client, ADM1026_REG_COMPANY);\r\nverstep = adm1026_read_value(client, ADM1026_REG_VERSTEP);\r\ndev_dbg(&adapter->dev, "Detecting device at %d,0x%02x with"\r\n" COMPANY: 0x%02x and VERSTEP: 0x%02x\n",\r\ni2c_adapter_id(client->adapter), client->addr,\r\ncompany, verstep);\r\ndev_dbg(&adapter->dev, "Autodetecting device at %d,0x%02x...\n",\r\ni2c_adapter_id(adapter), address);\r\nif (company == ADM1026_COMPANY_ANALOG_DEV\r\n&& verstep == ADM1026_VERSTEP_ADM1026) {\r\n} else if (company == ADM1026_COMPANY_ANALOG_DEV\r\n&& (verstep & 0xf0) == ADM1026_VERSTEP_GENERIC) {\r\ndev_err(&adapter->dev, "Unrecognized stepping "\r\n"0x%02x. Defaulting to ADM1026.\n", verstep);\r\n} else if ((verstep & 0xf0) == ADM1026_VERSTEP_GENERIC) {\r\ndev_err(&adapter->dev, "Found version/stepping "\r\n"0x%02x. Assuming generic ADM1026.\n",\r\nverstep);\r\n} else {\r\ndev_dbg(&adapter->dev, "Autodetection failed\n");\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, "adm1026", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int adm1026_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adm1026_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct adm1026_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\ndata->vrm = vid_which_vrm();\r\nadm1026_init_client(client);\r\nerr = sysfs_create_group(&client->dev.kobj, &adm1026_group);\r\nif (err)\r\ngoto exitfree;\r\nif (data->config1 & CFG1_AIN8_9)\r\nerr = sysfs_create_group(&client->dev.kobj,\r\n&adm1026_group_in8_9);\r\nelse\r\nerr = sysfs_create_group(&client->dev.kobj,\r\n&adm1026_group_temp3);\r\nif (err)\r\ngoto exitremove;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exitremove;\r\n}\r\nreturn 0;\r\nexitremove:\r\nsysfs_remove_group(&client->dev.kobj, &adm1026_group);\r\nif (data->config1 & CFG1_AIN8_9)\r\nsysfs_remove_group(&client->dev.kobj, &adm1026_group_in8_9);\r\nelse\r\nsysfs_remove_group(&client->dev.kobj, &adm1026_group_temp3);\r\nexitfree:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int adm1026_remove(struct i2c_client *client)\r\n{\r\nstruct adm1026_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &adm1026_group);\r\nif (data->config1 & CFG1_AIN8_9)\r\nsysfs_remove_group(&client->dev.kobj, &adm1026_group_in8_9);\r\nelse\r\nsysfs_remove_group(&client->dev.kobj, &adm1026_group_temp3);\r\nkfree(data);\r\nreturn 0;\r\n}
