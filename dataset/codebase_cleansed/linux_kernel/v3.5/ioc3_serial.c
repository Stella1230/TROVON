static int set_baud(struct ioc3_port *port, int baud)\r\n{\r\nint divisor;\r\nint actual_baud;\r\nint diff;\r\nint lcr, prediv;\r\nstruct ioc3_uartregs __iomem *uart;\r\nfor (prediv = 6; prediv < 64; prediv++) {\r\ndivisor = SER_DIVISOR(baud, SER_CLK_SPEED(prediv));\r\nif (!divisor)\r\ncontinue;\r\nactual_baud = DIVISOR_TO_BAUD(divisor, SER_CLK_SPEED(prediv));\r\ndiff = actual_baud - baud;\r\nif (diff < 0)\r\ndiff = -diff;\r\nif (diff * 100 <= actual_baud)\r\nbreak;\r\n}\r\nif (prediv == 64) {\r\nNOT_PROGRESS();\r\nreturn 1;\r\n}\r\nuart = port->ip_uart_regs;\r\nlcr = readb(&uart->iu_lcr);\r\nwriteb(lcr | UART_LCR_DLAB, &uart->iu_lcr);\r\nwriteb((unsigned char)divisor, &uart->iu_dll);\r\nwriteb((unsigned char)(divisor >> 8), &uart->iu_dlm);\r\nwriteb((unsigned char)prediv, &uart->iu_scr);\r\nwriteb((unsigned char)lcr, &uart->iu_lcr);\r\nreturn 0;\r\n}\r\nstatic struct ioc3_port *get_ioc3_port(struct uart_port *the_port)\r\n{\r\nstruct ioc3_driver_data *idd = dev_get_drvdata(the_port->dev);\r\nstruct ioc3_card *card_ptr = idd->data[Submodule_slot];\r\nint ii, jj;\r\nif (!card_ptr) {\r\nNOT_PROGRESS();\r\nreturn NULL;\r\n}\r\nfor (ii = 0; ii < PORTS_PER_CARD; ii++) {\r\nfor (jj = 0; jj < LOGICAL_PORTS; jj++) {\r\nif (the_port == &card_ptr->ic_port[ii].icp_uart_port[jj])\r\nreturn card_ptr->ic_port[ii].icp_port;\r\n}\r\n}\r\nNOT_PROGRESS();\r\nreturn NULL;\r\n}\r\nstatic int inline port_init(struct ioc3_port *port)\r\n{\r\nuint32_t sio_cr;\r\nstruct port_hooks *hooks = port->ip_hooks;\r\nstruct ioc3_uartregs __iomem *uart;\r\nint reset_loop_counter = 0xfffff;\r\nstruct ioc3_driver_data *idd = port->ip_idd;\r\nwritel(SSCR_RESET, &port->ip_serial_regs->sscr);\r\ndo {\r\nsio_cr = readl(&idd->vma->sio_cr);\r\nif (reset_loop_counter-- <= 0) {\r\nprintk(KERN_WARNING\r\n"IOC3 unable to come out of reset"\r\n" scr 0x%x\n", sio_cr);\r\nreturn -1;\r\n}\r\n} while (!(sio_cr & SIO_CR_ARB_DIAG_IDLE) &&\r\n(((sio_cr &= SIO_CR_ARB_DIAG) == SIO_CR_ARB_DIAG_TXA)\r\n|| sio_cr == SIO_CR_ARB_DIAG_TXB\r\n|| sio_cr == SIO_CR_ARB_DIAG_RXA\r\n|| sio_cr == SIO_CR_ARB_DIAG_RXB));\r\nwritel(0, &port->ip_serial_regs->sscr);\r\nport->ip_tx_prod = readl(&port->ip_serial_regs->stcir) & PROD_CONS_MASK;\r\nwritel(port->ip_tx_prod, &port->ip_serial_regs->stpir);\r\nport->ip_rx_cons = readl(&port->ip_serial_regs->srpir) & PROD_CONS_MASK;\r\nwritel(port->ip_rx_cons | SRCIR_ARM, &port->ip_serial_regs->srcir);\r\nuart = port->ip_uart_regs;\r\nwriteb(0, &uart->iu_lcr);\r\nwriteb(0, &uart->iu_ier);\r\nset_baud(port, port->ip_baud);\r\nwriteb(UART_LCR_WLEN8 | 0, &uart->iu_lcr);\r\nwriteb(UART_FCR_ENABLE_FIFO, &uart->iu_fcr);\r\nwriteb(UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,\r\n&uart->iu_fcr);\r\nwriteb(0, &uart->iu_mcr);\r\nwritel(0, &port->ip_serial_regs->shadow);\r\nif (port->ip_hooks == &hooks_array[0]) {\r\nunsigned long ring_pci_addr;\r\nuint32_t __iomem *sbbr_l, *sbbr_h;\r\nsbbr_l = &idd->vma->sbbr_l;\r\nsbbr_h = &idd->vma->sbbr_h;\r\nring_pci_addr = (unsigned long __iomem)port->ip_dma_ringbuf;\r\nDPRINT_CONFIG(("%s: ring_pci_addr 0x%p\n",\r\n__func__, (void *)ring_pci_addr));\r\nwritel((unsigned int)((uint64_t) ring_pci_addr >> 32), sbbr_h);\r\nwritel((unsigned int)ring_pci_addr | BUF_SIZE_BIT, sbbr_l);\r\n}\r\nwritel(SRTR_HZ / 100, &port->ip_serial_regs->srtr);\r\nport->ip_sscr = (ENTRIES_PER_RING * 3 / 4);\r\nport->ip_sscr |= SSCR_HIGH_SPD;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nport->ip_card->ic_enable &= ~hooks->intr_clear;\r\nioc3_disable(port->ip_is, idd, hooks->intr_clear);\r\nioc3_ack(port->ip_is, idd, hooks->intr_clear);\r\nreturn 0;\r\n}\r\nstatic void enable_intrs(struct ioc3_port *port, uint32_t mask)\r\n{\r\nif ((port->ip_card->ic_enable & mask) != mask) {\r\nport->ip_card->ic_enable |= mask;\r\nioc3_enable(port->ip_is, port->ip_idd, mask);\r\n}\r\n}\r\nstatic inline int local_open(struct ioc3_port *port)\r\n{\r\nint spiniter = 0;\r\nport->ip_flags = INPUT_ENABLE;\r\nif (port->ip_sscr & SSCR_DMA_EN) {\r\nwritel(port->ip_sscr | SSCR_DMA_PAUSE,\r\n&port->ip_serial_regs->sscr);\r\nwhile ((readl(&port->ip_serial_regs->sscr)\r\n& SSCR_PAUSE_STATE) == 0) {\r\nspiniter++;\r\nif (spiniter > MAXITER) {\r\nNOT_PROGRESS();\r\nreturn -1;\r\n}\r\n}\r\n}\r\nwriteb(UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR,\r\n&port->ip_uart_regs->iu_fcr);\r\nwriteb(UART_LCR_WLEN8, &port->ip_uart_regs->iu_lcr);\r\nport->ip_sscr &= ~SSCR_RX_THRESHOLD;\r\nport->ip_sscr |= 1;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nport->ip_tx_lowat = 1;\r\nreturn 0;\r\n}\r\nstatic inline int set_rx_timeout(struct ioc3_port *port, int timeout)\r\n{\r\nint threshold;\r\nport->ip_rx_timeout = timeout;\r\nthreshold = timeout * port->ip_baud / 4000;\r\nif (threshold == 0)\r\nthreshold = 1;\r\nif ((unsigned)threshold > (unsigned)SSCR_RX_THRESHOLD)\r\nreturn 1;\r\nport->ip_sscr &= ~SSCR_RX_THRESHOLD;\r\nport->ip_sscr |= threshold;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\ntimeout = timeout * SRTR_HZ / 100;\r\nif (timeout > SRTR_CNT)\r\ntimeout = SRTR_CNT;\r\nwritel(timeout, &port->ip_serial_regs->srtr);\r\nreturn 0;\r\n}\r\nstatic inline int\r\nconfig_port(struct ioc3_port *port,\r\nint baud, int byte_size, int stop_bits, int parenb, int parodd)\r\n{\r\nchar lcr, sizebits;\r\nint spiniter = 0;\r\nDPRINT_CONFIG(("%s: line %d baud %d byte_size %d stop %d parenb %d "\r\n"parodd %d\n",\r\n__func__, ((struct uart_port *)port->ip_port)->line,\r\nbaud, byte_size, stop_bits, parenb, parodd));\r\nif (set_baud(port, baud))\r\nreturn 1;\r\nswitch (byte_size) {\r\ncase 5:\r\nsizebits = UART_LCR_WLEN5;\r\nbreak;\r\ncase 6:\r\nsizebits = UART_LCR_WLEN6;\r\nbreak;\r\ncase 7:\r\nsizebits = UART_LCR_WLEN7;\r\nbreak;\r\ncase 8:\r\nsizebits = UART_LCR_WLEN8;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (port->ip_sscr & SSCR_DMA_EN) {\r\nwritel(port->ip_sscr | SSCR_DMA_PAUSE,\r\n&port->ip_serial_regs->sscr);\r\nwhile ((readl(&port->ip_serial_regs->sscr)\r\n& SSCR_PAUSE_STATE) == 0) {\r\nspiniter++;\r\nif (spiniter > MAXITER)\r\nreturn -1;\r\n}\r\n}\r\nlcr = readb(&port->ip_uart_regs->iu_lcr);\r\nlcr &= ~(LCR_MASK_BITS_CHAR | UART_LCR_EPAR |\r\nUART_LCR_PARITY | LCR_MASK_STOP_BITS);\r\nlcr |= sizebits;\r\nif (parenb) {\r\nlcr |= UART_LCR_PARITY;\r\nif (!parodd)\r\nlcr |= UART_LCR_EPAR;\r\n}\r\nif (stop_bits)\r\nlcr |= UART_LCR_STOP ;\r\nwriteb(lcr, &port->ip_uart_regs->iu_lcr);\r\nif (port->ip_sscr & SSCR_DMA_EN) {\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\nport->ip_baud = baud;\r\nport->ip_tx_lowat = (TX_LOWAT_CHARS(baud) + 3) / 4;\r\nif (port->ip_tx_lowat == 0)\r\nport->ip_tx_lowat = 1;\r\nset_rx_timeout(port, 2);\r\nreturn 0;\r\n}\r\nstatic inline int do_write(struct ioc3_port *port, char *buf, int len)\r\n{\r\nint prod_ptr, cons_ptr, total = 0;\r\nstruct ring *outring;\r\nstruct ring_entry *entry;\r\nstruct port_hooks *hooks = port->ip_hooks;\r\nBUG_ON(!(len >= 0));\r\nprod_ptr = port->ip_tx_prod;\r\ncons_ptr = readl(&port->ip_serial_regs->stcir) & PROD_CONS_MASK;\r\noutring = port->ip_outring;\r\ncons_ptr = (cons_ptr - (int)sizeof(struct ring_entry)) & PROD_CONS_MASK;\r\nwhile ((prod_ptr != cons_ptr) && (len > 0)) {\r\nint xx;\r\nentry = (struct ring_entry *)((caddr_t) outring + prod_ptr);\r\nentry->ring_allsc = 0;\r\nfor (xx = 0; (xx < 4) && (len > 0); xx++) {\r\nentry->ring_data[xx] = *buf++;\r\nentry->ring_sc[xx] = TXCB_VALID;\r\nlen--;\r\ntotal++;\r\n}\r\nif (!(port->ip_flags & LOWAT_WRITTEN) &&\r\n((cons_ptr - prod_ptr) & PROD_CONS_MASK)\r\n<= port->ip_tx_lowat * (int)sizeof(struct ring_entry)) {\r\nport->ip_flags |= LOWAT_WRITTEN;\r\nentry->ring_sc[0] |= TXCB_INT_WHEN_DONE;\r\n}\r\nprod_ptr += sizeof(struct ring_entry);\r\nprod_ptr &= PROD_CONS_MASK;\r\n}\r\nif (total > 0 && !(port->ip_sscr & SSCR_DMA_EN)) {\r\nport->ip_sscr |= SSCR_DMA_EN;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\nif (!uart_tx_stopped(port->ip_port)) {\r\nwritel(prod_ptr, &port->ip_serial_regs->stpir);\r\nif (total > 0)\r\nenable_intrs(port, hooks->intr_tx_mt);\r\n}\r\nport->ip_tx_prod = prod_ptr;\r\nreturn total;\r\n}\r\nstatic inline void disable_intrs(struct ioc3_port *port, uint32_t mask)\r\n{\r\nif (port->ip_card->ic_enable & mask) {\r\nioc3_disable(port->ip_is, port->ip_idd, mask);\r\nport->ip_card->ic_enable &= ~mask;\r\n}\r\n}\r\nstatic int set_notification(struct ioc3_port *port, int mask, int set_on)\r\n{\r\nstruct port_hooks *hooks = port->ip_hooks;\r\nuint32_t intrbits, sscrbits;\r\nBUG_ON(!mask);\r\nintrbits = sscrbits = 0;\r\nif (mask & N_DATA_READY)\r\nintrbits |= (hooks->intr_rx_timer | hooks->intr_rx_high);\r\nif (mask & N_OUTPUT_LOWAT)\r\nintrbits |= hooks->intr_tx_explicit;\r\nif (mask & N_DDCD) {\r\nintrbits |= hooks->intr_delta_dcd;\r\nsscrbits |= SSCR_RX_RING_DCD;\r\n}\r\nif (mask & N_DCTS)\r\nintrbits |= hooks->intr_delta_cts;\r\nif (set_on) {\r\nenable_intrs(port, intrbits);\r\nport->ip_notify |= mask;\r\nport->ip_sscr |= sscrbits;\r\n} else {\r\ndisable_intrs(port, intrbits);\r\nport->ip_notify &= ~mask;\r\nport->ip_sscr &= ~sscrbits;\r\n}\r\nif (port->ip_notify & (N_DATA_READY | N_DDCD))\r\nport->ip_sscr |= SSCR_DMA_EN;\r\nelse if (!(port->ip_card->ic_enable & hooks->intr_tx_mt))\r\nport->ip_sscr &= ~SSCR_DMA_EN;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nreturn 0;\r\n}\r\nstatic inline int set_mcr(struct uart_port *the_port,\r\nint mask1, int mask2)\r\n{\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nuint32_t shadow;\r\nint spiniter = 0;\r\nchar mcr;\r\nif (!port)\r\nreturn -1;\r\nif (port->ip_sscr & SSCR_DMA_EN) {\r\nwritel(port->ip_sscr | SSCR_DMA_PAUSE,\r\n&port->ip_serial_regs->sscr);\r\nwhile ((readl(&port->ip_serial_regs->sscr)\r\n& SSCR_PAUSE_STATE) == 0) {\r\nspiniter++;\r\nif (spiniter > MAXITER)\r\nreturn -1;\r\n}\r\n}\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nmcr = (shadow & 0xff000000) >> 24;\r\nmcr |= mask1;\r\nshadow |= mask2;\r\nwriteb(mcr, &port->ip_uart_regs->iu_mcr);\r\nwritel(shadow, &port->ip_serial_regs->shadow);\r\nif (port->ip_sscr & SSCR_DMA_EN) {\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioc3_set_proto(struct ioc3_port *port, int proto)\r\n{\r\nstruct port_hooks *hooks = port->ip_hooks;\r\nswitch (proto) {\r\ndefault:\r\ncase PROTO_RS232:\r\nDPRINT_CONFIG(("%s: rs232\n", __func__));\r\nwritel(0, (&port->ip_idd->vma->gppr[0]\r\n+ hooks->rs422_select_pin));\r\nbreak;\r\ncase PROTO_RS422:\r\nDPRINT_CONFIG(("%s: rs422\n", __func__));\r\nwritel(1, (&port->ip_idd->vma->gppr[0]\r\n+ hooks->rs422_select_pin));\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void transmit_chars(struct uart_port *the_port)\r\n{\r\nint xmit_count, tail, head;\r\nint result;\r\nchar *start;\r\nstruct tty_struct *tty;\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nstruct uart_state *state;\r\nif (!the_port)\r\nreturn;\r\nif (!port)\r\nreturn;\r\nstate = the_port->state;\r\ntty = state->port.tty;\r\nif (uart_circ_empty(&state->xmit) || uart_tx_stopped(the_port)) {\r\nset_notification(port, N_ALL_OUTPUT, 0);\r\nreturn;\r\n}\r\nhead = state->xmit.head;\r\ntail = state->xmit.tail;\r\nstart = (char *)&state->xmit.buf[tail];\r\nxmit_count = (head < tail) ? (UART_XMIT_SIZE - tail) : (head - tail);\r\nif (xmit_count > 0) {\r\nresult = do_write(port, start, xmit_count);\r\nif (result > 0) {\r\nxmit_count -= result;\r\nthe_port->icount.tx += result;\r\ntail += result;\r\ntail &= UART_XMIT_SIZE - 1;\r\nstate->xmit.tail = tail;\r\nstart = (char *)&state->xmit.buf[tail];\r\n}\r\n}\r\nif (uart_circ_chars_pending(&state->xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(the_port);\r\nif (uart_circ_empty(&state->xmit)) {\r\nset_notification(port, N_OUTPUT_LOWAT, 0);\r\n} else {\r\nset_notification(port, N_OUTPUT_LOWAT, 1);\r\n}\r\n}\r\nstatic void\r\nioc3_change_speed(struct uart_port *the_port,\r\nstruct ktermios *new_termios, struct ktermios *old_termios)\r\n{\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nunsigned int cflag, iflag;\r\nint baud;\r\nint new_parity = 0, new_parity_enable = 0, new_stop = 0, new_data = 8;\r\nstruct uart_state *state = the_port->state;\r\ncflag = new_termios->c_cflag;\r\niflag = new_termios->c_iflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nnew_data = 5;\r\nbreak;\r\ncase CS6:\r\nnew_data = 6;\r\nbreak;\r\ncase CS7:\r\nnew_data = 7;\r\nbreak;\r\ncase CS8:\r\nnew_data = 8;\r\nbreak;\r\ndefault:\r\nnew_data = 5;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB) {\r\nnew_stop = 1;\r\n}\r\nif (cflag & PARENB) {\r\nnew_parity_enable = 1;\r\nif (cflag & PARODD)\r\nnew_parity = 1;\r\n}\r\nbaud = uart_get_baud_rate(the_port, new_termios, old_termios,\r\nMIN_BAUD_SUPPORTED, MAX_BAUD_SUPPORTED);\r\nDPRINT_CONFIG(("%s: returned baud %d for line %d\n", __func__, baud,\r\nthe_port->line));\r\nif (!the_port->fifosize)\r\nthe_port->fifosize = FIFO_SIZE;\r\nuart_update_timeout(the_port, cflag, baud);\r\nthe_port->ignore_status_mask = N_ALL_INPUT;\r\nstate->port.tty->low_latency = 1;\r\nif (iflag & IGNPAR)\r\nthe_port->ignore_status_mask &= ~(N_PARITY_ERROR\r\n| N_FRAMING_ERROR);\r\nif (iflag & IGNBRK) {\r\nthe_port->ignore_status_mask &= ~N_BREAK;\r\nif (iflag & IGNPAR)\r\nthe_port->ignore_status_mask &= ~N_OVERRUN_ERROR;\r\n}\r\nif (!(cflag & CREAD)) {\r\nthe_port->ignore_status_mask &= ~N_DATA_READY;\r\n}\r\nif (cflag & CRTSCTS) {\r\nport->ip_sscr |= SSCR_HFC_EN;\r\n}\r\nelse {\r\nport->ip_sscr &= ~SSCR_HFC_EN;\r\n}\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\nDPRINT_CONFIG(("%s : port 0x%p line %d cflag 0%o "\r\n"config_port(baud %d data %d stop %d penable %d "\r\n" parity %d), notification 0x%x\n",\r\n__func__, (void *)port, the_port->line, cflag, baud,\r\nnew_data, new_stop, new_parity_enable, new_parity,\r\nthe_port->ignore_status_mask));\r\nif ((config_port(port, baud,\r\nnew_data,\r\nnew_stop,\r\nnew_parity_enable,\r\nnew_parity)) >= 0) {\r\nset_notification(port, the_port->ignore_status_mask, 1);\r\n}\r\n}\r\nstatic inline int ic3_startup_local(struct uart_port *the_port)\r\n{\r\nstruct ioc3_port *port;\r\nif (!the_port) {\r\nNOT_PROGRESS();\r\nreturn -1;\r\n}\r\nport = get_ioc3_port(the_port);\r\nif (!port) {\r\nNOT_PROGRESS();\r\nreturn -1;\r\n}\r\nlocal_open(port);\r\nioc3_set_proto(port, IS_RS232(the_port->line) ? PROTO_RS232 :\r\nPROTO_RS422);\r\nreturn 0;\r\n}\r\nstatic void ioc3_cb_output_lowat(struct ioc3_port *port)\r\n{\r\nunsigned long pflags;\r\nif (port->ip_port) {\r\nspin_lock_irqsave(&port->ip_port->lock, pflags);\r\ntransmit_chars(port->ip_port);\r\nspin_unlock_irqrestore(&port->ip_port->lock, pflags);\r\n}\r\n}\r\nstatic void ioc3_cb_post_ncs(struct uart_port *the_port, int ncs)\r\n{\r\nstruct uart_icount *icount;\r\nicount = &the_port->icount;\r\nif (ncs & NCS_BREAK)\r\nicount->brk++;\r\nif (ncs & NCS_FRAMING)\r\nicount->frame++;\r\nif (ncs & NCS_OVERRUN)\r\nicount->overrun++;\r\nif (ncs & NCS_PARITY)\r\nicount->parity++;\r\n}\r\nstatic inline int do_read(struct uart_port *the_port, char *buf, int len)\r\n{\r\nint prod_ptr, cons_ptr, total;\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nstruct ring *inring;\r\nstruct ring_entry *entry;\r\nstruct port_hooks *hooks = port->ip_hooks;\r\nint byte_num;\r\nchar *sc;\r\nint loop_counter;\r\nBUG_ON(!(len >= 0));\r\nBUG_ON(!port);\r\nwritel(port->ip_rx_cons | SRCIR_ARM, &port->ip_serial_regs->srcir);\r\nprod_ptr = readl(&port->ip_serial_regs->srpir) & PROD_CONS_MASK;\r\ncons_ptr = port->ip_rx_cons;\r\nif (prod_ptr == cons_ptr) {\r\nint reset_dma = 0;\r\nif (!(port->ip_sscr & SSCR_DMA_EN)) {\r\nport->ip_sscr |= SSCR_DMA_EN;\r\nreset_dma = 1;\r\n}\r\nwritel(port->ip_sscr | SSCR_RX_DRAIN,\r\n&port->ip_serial_regs->sscr);\r\nprod_ptr = readl(&port->ip_serial_regs->srpir) & PROD_CONS_MASK;\r\nif (prod_ptr == cons_ptr) {\r\nloop_counter = 0;\r\nwhile (readl(&port->ip_serial_regs->sscr) &\r\nSSCR_RX_DRAIN) {\r\nloop_counter++;\r\nif (loop_counter > MAXITER)\r\nreturn -1;\r\n}\r\nprod_ptr = readl(&port->ip_serial_regs->srpir)\r\n& PROD_CONS_MASK;\r\n}\r\nif (reset_dma) {\r\nport->ip_sscr &= ~SSCR_DMA_EN;\r\nwritel(port->ip_sscr, &port->ip_serial_regs->sscr);\r\n}\r\n}\r\ninring = port->ip_inring;\r\nport->ip_flags &= ~READ_ABORTED;\r\ntotal = 0;\r\nloop_counter = 0xfffff;\r\nwhile ((prod_ptr != cons_ptr) && (len > 0)) {\r\nentry = (struct ring_entry *)((caddr_t) inring + cons_ptr);\r\nif (loop_counter-- <= 0) {\r\nprintk(KERN_WARNING "IOC3 serial: "\r\n"possible hang condition/"\r\n"port stuck on read (line %d).\n",\r\nthe_port->line);\r\nbreak;\r\n}\r\nif ((entry->ring_allsc & RING_ANY_VALID) == 0) {\r\nport->ip_flags |= READ_ABORTED;\r\nlen = 0;\r\nbreak;\r\n}\r\nfor (byte_num = 0; byte_num < 4 && len > 0; byte_num++) {\r\nsc = &(entry->ring_sc[byte_num]);\r\nif ((*sc & RXSB_MODEM_VALID)\r\n&& (port->ip_notify & N_DDCD)) {\r\nif ((port->ip_flags & DCD_ON)\r\n&& !(*sc & RXSB_DCD)) {\r\nif (total > 0) {\r\nlen = 0;\r\nbreak;\r\n}\r\nport->ip_flags &= ~DCD_ON;\r\n*sc &= ~RXSB_MODEM_VALID;\r\nif ((entry->ring_allsc & RING_ANY_VALID)\r\n== 0) {\r\ncons_ptr += (int)sizeof\r\n(struct ring_entry);\r\ncons_ptr &= PROD_CONS_MASK;\r\n}\r\nwritel(cons_ptr,\r\n&port->ip_serial_regs->srcir);\r\nport->ip_rx_cons = cons_ptr;\r\nif ((port->ip_notify & N_DDCD)\r\n&& port->ip_port) {\r\nuart_handle_dcd_change\r\n(port->ip_port, 0);\r\nwake_up_interruptible\r\n(&the_port->state->\r\nport.delta_msr_wait);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nif (*sc & RXSB_MODEM_VALID) {\r\nif ((*sc & RXSB_OVERRUN)\r\n&& (port->ip_notify & N_OVERRUN_ERROR)) {\r\nioc3_cb_post_ncs(the_port, NCS_OVERRUN);\r\n}\r\n*sc &= ~RXSB_MODEM_VALID;\r\n}\r\nif ((*sc & RXSB_DATA_VALID) &&\r\n((*sc & (RXSB_PAR_ERR\r\n| RXSB_FRAME_ERR | RXSB_BREAK))\r\n&& (port->ip_notify & (N_PARITY_ERROR\r\n| N_FRAMING_ERROR\r\n| N_BREAK)))) {\r\nif (total > 0) {\r\nlen = 0;\r\nbreak;\r\n} else {\r\nif ((*sc & RXSB_PAR_ERR) &&\r\n(port->\r\nip_notify & N_PARITY_ERROR)) {\r\nioc3_cb_post_ncs(the_port,\r\nNCS_PARITY);\r\n}\r\nif ((*sc & RXSB_FRAME_ERR) &&\r\n(port->\r\nip_notify & N_FRAMING_ERROR)) {\r\nioc3_cb_post_ncs(the_port,\r\nNCS_FRAMING);\r\n}\r\nif ((*sc & RXSB_BREAK)\r\n&& (port->ip_notify & N_BREAK)) {\r\nioc3_cb_post_ncs\r\n(the_port, NCS_BREAK);\r\n}\r\nlen = 1;\r\n}\r\n}\r\nif (*sc & RXSB_DATA_VALID) {\r\n*sc &= ~RXSB_DATA_VALID;\r\n*buf = entry->ring_data[byte_num];\r\nbuf++;\r\nlen--;\r\ntotal++;\r\n}\r\n}\r\nif ((entry->ring_allsc & RING_ANY_VALID) == 0) {\r\ncons_ptr += (int)sizeof(struct ring_entry);\r\ncons_ptr &= PROD_CONS_MASK;\r\n}\r\n}\r\nwritel(cons_ptr, &port->ip_serial_regs->srcir);\r\nport->ip_rx_cons = cons_ptr;\r\nif ((port->ip_flags & INPUT_HIGH) && (((prod_ptr - cons_ptr)\r\n& PROD_CONS_MASK) <\r\n((port->\r\nip_sscr &\r\nSSCR_RX_THRESHOLD)\r\n<< PROD_CONS_PTR_OFF))) {\r\nport->ip_flags &= ~INPUT_HIGH;\r\nenable_intrs(port, hooks->intr_rx_high);\r\n}\r\nreturn total;\r\n}\r\nstatic int receive_chars(struct uart_port *the_port)\r\n{\r\nstruct tty_struct *tty;\r\nunsigned char ch[MAX_CHARS];\r\nint read_count = 0, read_room, flip = 0;\r\nstruct uart_state *state = the_port->state;\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nunsigned long pflags;\r\nif (!state)\r\nreturn 0;\r\nif (!state->port.tty)\r\nreturn 0;\r\nif (!(port->ip_flags & INPUT_ENABLE))\r\nreturn 0;\r\nspin_lock_irqsave(&the_port->lock, pflags);\r\ntty = state->port.tty;\r\nread_count = do_read(the_port, ch, MAX_CHARS);\r\nif (read_count > 0) {\r\nflip = 1;\r\nread_room = tty_insert_flip_string(tty, ch, read_count);\r\nthe_port->icount.rx += read_count;\r\n}\r\nspin_unlock_irqrestore(&the_port->lock, pflags);\r\nif (flip)\r\ntty_flip_buffer_push(tty);\r\nreturn read_count;\r\n}\r\nstatic int inline\r\nioc3uart_intr_one(struct ioc3_submodule *is,\r\nstruct ioc3_driver_data *idd,\r\nunsigned int pending)\r\n{\r\nint port_num = GET_PORT_FROM_SIO_IR(pending);\r\nstruct port_hooks *hooks;\r\nunsigned int rx_high_rd_aborted = 0;\r\nunsigned long flags;\r\nstruct uart_port *the_port;\r\nstruct ioc3_port *port;\r\nint loop_counter;\r\nstruct ioc3_card *card_ptr;\r\nunsigned int sio_ir;\r\ncard_ptr = idd->data[is->id];\r\nport = card_ptr->ic_port[port_num].icp_port;\r\nhooks = port->ip_hooks;\r\nsio_ir = pending & ~(hooks->intr_tx_mt);\r\nspin_lock_irqsave(&port->ip_lock, flags);\r\nloop_counter = MAXITER;\r\ndo {\r\nuint32_t shadow;\r\nif (loop_counter-- <= 0) {\r\nprintk(KERN_WARNING "IOC3 serial: "\r\n"possible hang condition/"\r\n"port stuck on interrupt (line %d).\n",\r\n((struct uart_port *)port->ip_port)->line);\r\nbreak;\r\n}\r\nif (sio_ir & hooks->intr_delta_dcd) {\r\nioc3_ack(is, idd, hooks->intr_delta_dcd);\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nif ((port->ip_notify & N_DDCD)\r\n&& (shadow & SHADOW_DCD)\r\n&& (port->ip_port)) {\r\nthe_port = port->ip_port;\r\nuart_handle_dcd_change(the_port,\r\nshadow & SHADOW_DCD);\r\nwake_up_interruptible\r\n(&the_port->state->port.delta_msr_wait);\r\n} else if ((port->ip_notify & N_DDCD)\r\n&& !(shadow & SHADOW_DCD)) {\r\nuart_handle_dcd_change(port->ip_port,\r\nshadow & SHADOW_DCD);\r\nport->ip_flags |= DCD_ON;\r\n}\r\n}\r\nif (sio_ir & hooks->intr_delta_cts) {\r\nioc3_ack(is, idd, hooks->intr_delta_cts);\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nif ((port->ip_notify & N_DCTS) && (port->ip_port)) {\r\nthe_port = port->ip_port;\r\nuart_handle_cts_change(the_port, shadow\r\n& SHADOW_CTS);\r\nwake_up_interruptible\r\n(&the_port->state->port.delta_msr_wait);\r\n}\r\n}\r\nif (sio_ir & hooks->intr_rx_timer) {\r\nioc3_ack(is, idd, hooks->intr_rx_timer);\r\nif ((port->ip_notify & N_DATA_READY)\r\n&& (port->ip_port)) {\r\nreceive_chars(port->ip_port);\r\n}\r\n}\r\nelse if (sio_ir & hooks->intr_rx_high) {\r\nif ((port->ip_notify & N_DATA_READY) && port->ip_port) {\r\nreceive_chars(port->ip_port);\r\n}\r\nif ((sio_ir = PENDING(card_ptr, idd))\r\n& hooks->intr_rx_high) {\r\nif (port->ip_flags & READ_ABORTED) {\r\nrx_high_rd_aborted++;\r\n}\r\nelse {\r\ncard_ptr->ic_enable &= ~hooks->intr_rx_high;\r\nport->ip_flags |= INPUT_HIGH;\r\n}\r\n}\r\n}\r\nif (sio_ir & hooks->intr_tx_explicit) {\r\nport->ip_flags &= ~LOWAT_WRITTEN;\r\nioc3_ack(is, idd, hooks->intr_tx_explicit);\r\nif (port->ip_notify & N_OUTPUT_LOWAT)\r\nioc3_cb_output_lowat(port);\r\n}\r\nelse if (sio_ir & hooks->intr_tx_mt) {\r\nif (port->ip_notify & N_OUTPUT_LOWAT) {\r\nioc3_cb_output_lowat(port);\r\nsio_ir = PENDING(card_ptr, idd);\r\n}\r\nif (sio_ir & hooks->intr_tx_mt) {\r\nif (!(port->ip_notify\r\n& (N_DATA_READY | N_DDCD))) {\r\nBUG_ON(!(port->ip_sscr\r\n& SSCR_DMA_EN));\r\nport->ip_sscr &= ~SSCR_DMA_EN;\r\nwritel(port->ip_sscr,\r\n&port->ip_serial_regs->sscr);\r\n}\r\ncard_ptr->ic_enable &= ~hooks->intr_tx_mt;\r\n}\r\n}\r\nsio_ir = PENDING(card_ptr, idd);\r\nif (rx_high_rd_aborted && (sio_ir == hooks->intr_rx_high)) {\r\nsio_ir &= ~hooks->intr_rx_high;\r\n}\r\n} while (sio_ir & hooks->intr_all);\r\nspin_unlock_irqrestore(&port->ip_lock, flags);\r\nioc3_enable(is, idd, card_ptr->ic_enable);\r\nreturn 0;\r\n}\r\nstatic int ioc3uart_intr(struct ioc3_submodule *is,\r\nstruct ioc3_driver_data *idd,\r\nunsigned int pending)\r\n{\r\nint ret = 0;\r\nif (pending & SIO_IR_SA)\r\nret |= ioc3uart_intr_one(is, idd, pending & SIO_IR_SA);\r\nif (pending & SIO_IR_SB)\r\nret |= ioc3uart_intr_one(is, idd, pending & SIO_IR_SB);\r\nreturn ret;\r\n}\r\nstatic const char *ic3_type(struct uart_port *the_port)\r\n{\r\nif (IS_RS232(the_port->line))\r\nreturn "SGI IOC3 Serial [rs232]";\r\nelse\r\nreturn "SGI IOC3 Serial [rs422]";\r\n}\r\nstatic unsigned int ic3_tx_empty(struct uart_port *the_port)\r\n{\r\nunsigned int ret = 0;\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nif (readl(&port->ip_serial_regs->shadow) & SHADOW_TEMT)\r\nret = TIOCSER_TEMT;\r\nreturn ret;\r\n}\r\nstatic void ic3_stop_tx(struct uart_port *the_port)\r\n{\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nif (port)\r\nset_notification(port, N_OUTPUT_LOWAT, 0);\r\n}\r\nstatic void ic3_stop_rx(struct uart_port *the_port)\r\n{\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nif (port)\r\nport->ip_flags &= ~INPUT_ENABLE;\r\n}\r\nstatic void null_void_function(struct uart_port *the_port)\r\n{\r\n}\r\nstatic void ic3_shutdown(struct uart_port *the_port)\r\n{\r\nunsigned long port_flags;\r\nstruct ioc3_port *port;\r\nstruct uart_state *state;\r\nport = get_ioc3_port(the_port);\r\nif (!port)\r\nreturn;\r\nstate = the_port->state;\r\nwake_up_interruptible(&state->port.delta_msr_wait);\r\nspin_lock_irqsave(&the_port->lock, port_flags);\r\nset_notification(port, N_ALL, 0);\r\nspin_unlock_irqrestore(&the_port->lock, port_flags);\r\n}\r\nstatic void ic3_set_mctrl(struct uart_port *the_port, unsigned int mctrl)\r\n{\r\nunsigned char mcr = 0;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nset_mcr(the_port, mcr, SHADOW_DTR);\r\n}\r\nstatic unsigned int ic3_get_mctrl(struct uart_port *the_port)\r\n{\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nuint32_t shadow;\r\nunsigned int ret = 0;\r\nif (!port)\r\nreturn 0;\r\nshadow = readl(&port->ip_serial_regs->shadow);\r\nif (shadow & SHADOW_DCD)\r\nret |= TIOCM_CD;\r\nif (shadow & SHADOW_DR)\r\nret |= TIOCM_DSR;\r\nif (shadow & SHADOW_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void ic3_start_tx(struct uart_port *the_port)\r\n{\r\nstruct ioc3_port *port = get_ioc3_port(the_port);\r\nif (port) {\r\nset_notification(port, N_OUTPUT_LOWAT, 1);\r\nenable_intrs(port, port->ip_hooks->intr_tx_mt);\r\n}\r\n}\r\nstatic void ic3_break_ctl(struct uart_port *the_port, int break_state)\r\n{\r\n}\r\nstatic int ic3_startup(struct uart_port *the_port)\r\n{\r\nint retval;\r\nstruct ioc3_port *port;\r\nstruct ioc3_card *card_ptr;\r\nunsigned long port_flags;\r\nif (!the_port) {\r\nNOT_PROGRESS();\r\nreturn -ENODEV;\r\n}\r\nport = get_ioc3_port(the_port);\r\nif (!port) {\r\nNOT_PROGRESS();\r\nreturn -ENODEV;\r\n}\r\ncard_ptr = port->ip_card;\r\nport->ip_port = the_port;\r\nif (!card_ptr) {\r\nNOT_PROGRESS();\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&the_port->lock, port_flags);\r\nretval = ic3_startup_local(the_port);\r\nspin_unlock_irqrestore(&the_port->lock, port_flags);\r\nreturn retval;\r\n}\r\nstatic void\r\nic3_set_termios(struct uart_port *the_port,\r\nstruct ktermios *termios, struct ktermios *old_termios)\r\n{\r\nunsigned long port_flags;\r\nspin_lock_irqsave(&the_port->lock, port_flags);\r\nioc3_change_speed(the_port, termios, old_termios);\r\nspin_unlock_irqrestore(&the_port->lock, port_flags);\r\n}\r\nstatic int ic3_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int ioc3_serial_core_attach( struct ioc3_submodule *is,\r\nstruct ioc3_driver_data *idd)\r\n{\r\nstruct ioc3_port *port;\r\nstruct uart_port *the_port;\r\nstruct ioc3_card *card_ptr = idd->data[is->id];\r\nint ii, phys_port;\r\nstruct pci_dev *pdev = idd->pdev;\r\nDPRINT_CONFIG(("%s: attach pdev 0x%p - card_ptr 0x%p\n",\r\n__func__, pdev, (void *)card_ptr));\r\nif (!card_ptr)\r\nreturn -ENODEV;\r\nfor (ii = 0; ii < LOGICAL_PORTS_PER_CARD; ii++) {\r\nphys_port = GET_PHYSICAL_PORT(ii);\r\nthe_port = &card_ptr->ic_port[phys_port].\r\nicp_uart_port[GET_LOGICAL_PORT(ii)];\r\nport = card_ptr->ic_port[phys_port].icp_port;\r\nport->ip_port = the_port;\r\nDPRINT_CONFIG(("%s: attach the_port 0x%p / port 0x%p [%d/%d]\n",\r\n__func__, (void *)the_port, (void *)port,\r\nphys_port, ii));\r\nthe_port->membase = (unsigned char __iomem *)1;\r\nthe_port->iobase = (pdev->bus->number << 16) | ii;\r\nthe_port->line = (Num_of_ioc3_cards << 2) | ii;\r\nthe_port->mapbase = 1;\r\nthe_port->type = PORT_16550A;\r\nthe_port->fifosize = FIFO_SIZE;\r\nthe_port->ops = &ioc3_ops;\r\nthe_port->irq = idd->irq_io;\r\nthe_port->dev = &pdev->dev;\r\nif (uart_add_one_port(&ioc3_uart, the_port) < 0) {\r\nprintk(KERN_WARNING\r\n"%s: unable to add port %d bus %d\n",\r\n__func__, the_port->line, pdev->bus->number);\r\n} else {\r\nDPRINT_CONFIG(("IOC3 serial port %d irq %d bus %d\n",\r\nthe_port->line, the_port->irq, pdev->bus->number));\r\n}\r\nif (IS_PHYSICAL_PORT(ii))\r\nioc3_set_proto(port, PROTO_RS232);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioc3uart_remove(struct ioc3_submodule *is,\r\nstruct ioc3_driver_data *idd)\r\n{\r\nstruct ioc3_card *card_ptr = idd->data[is->id];\r\nstruct uart_port *the_port;\r\nstruct ioc3_port *port;\r\nint ii;\r\nif (card_ptr) {\r\nfor (ii = 0; ii < LOGICAL_PORTS_PER_CARD; ii++) {\r\nthe_port = &card_ptr->ic_port[GET_PHYSICAL_PORT(ii)].\r\nicp_uart_port[GET_LOGICAL_PORT(ii)];\r\nif (the_port)\r\nuart_remove_one_port(&ioc3_uart, the_port);\r\nport = card_ptr->ic_port[GET_PHYSICAL_PORT(ii)].icp_port;\r\nif (port && IS_PHYSICAL_PORT(ii)\r\n&& (GET_PHYSICAL_PORT(ii) == 0)) {\r\npci_free_consistent(port->ip_idd->pdev,\r\nTOTAL_RING_BUF_SIZE,\r\n(void *)port->ip_cpu_ringbuf,\r\nport->ip_dma_ringbuf);\r\nkfree(port);\r\ncard_ptr->ic_port[GET_PHYSICAL_PORT(ii)].\r\nicp_port = NULL;\r\n}\r\n}\r\nkfree(card_ptr);\r\nidd->data[is->id] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nioc3uart_probe(struct ioc3_submodule *is, struct ioc3_driver_data *idd)\r\n{\r\nstruct pci_dev *pdev = idd->pdev;\r\nstruct ioc3_card *card_ptr;\r\nint ret = 0;\r\nstruct ioc3_port *port;\r\nstruct ioc3_port *ports[PORTS_PER_CARD];\r\nint phys_port;\r\nint cnt;\r\nDPRINT_CONFIG(("%s (0x%p, 0x%p)\n", __func__, is, idd));\r\ncard_ptr = kzalloc(sizeof(struct ioc3_card), GFP_KERNEL);\r\nif (!card_ptr) {\r\nprintk(KERN_WARNING "ioc3_attach_one"\r\n": unable to get memory for the IOC3\n");\r\nreturn -ENOMEM;\r\n}\r\nidd->data[is->id] = card_ptr;\r\nSubmodule_slot = is->id;\r\nwritel(((UARTA_BASE >> 3) << SIO_CR_SER_A_BASE_SHIFT) |\r\n((UARTB_BASE >> 3) << SIO_CR_SER_B_BASE_SHIFT) |\r\n(0xf << SIO_CR_CMD_PULSE_SHIFT), &idd->vma->sio_cr);\r\npci_write_config_dword(pdev, PCI_LAT, 0xff00);\r\nioc3_gpcr_set(idd, GPCR_UARTA_MODESEL | GPCR_UARTB_MODESEL);\r\nfor (phys_port = 0; phys_port < PORTS_PER_CARD; phys_port++) {\r\nport = kzalloc(sizeof(struct ioc3_port), GFP_KERNEL);\r\nif (!port) {\r\nprintk(KERN_WARNING\r\n"IOC3 serial memory not available for port\n");\r\nret = -ENOMEM;\r\ngoto out4;\r\n}\r\nspin_lock_init(&port->ip_lock);\r\nports[phys_port] = port;\r\ncard_ptr->ic_port[phys_port].icp_port = port;\r\nport->ip_is = is;\r\nport->ip_idd = idd;\r\nport->ip_baud = 9600;\r\nport->ip_card = card_ptr;\r\nport->ip_hooks = &hooks_array[phys_port];\r\nif (phys_port == 0) {\r\nport->ip_serial_regs = &idd->vma->port_a;\r\nport->ip_uart_regs = &idd->vma->sregs.uarta;\r\nDPRINT_CONFIG(("%s : Port A ip_serial_regs 0x%p "\r\n"ip_uart_regs 0x%p\n",\r\n__func__,\r\n(void *)port->ip_serial_regs,\r\n(void *)port->ip_uart_regs));\r\nport->ip_cpu_ringbuf = pci_alloc_consistent(pdev,\r\nTOTAL_RING_BUF_SIZE, &port->ip_dma_ringbuf);\r\nBUG_ON(!((((int64_t) port->ip_dma_ringbuf) &\r\n(TOTAL_RING_BUF_SIZE - 1)) == 0));\r\nport->ip_inring = RING(port, RX_A);\r\nport->ip_outring = RING(port, TX_A);\r\nDPRINT_CONFIG(("%s : Port A ip_cpu_ringbuf 0x%p "\r\n"ip_dma_ringbuf 0x%p, ip_inring 0x%p "\r\n"ip_outring 0x%p\n",\r\n__func__,\r\n(void *)port->ip_cpu_ringbuf,\r\n(void *)port->ip_dma_ringbuf,\r\n(void *)port->ip_inring,\r\n(void *)port->ip_outring));\r\n}\r\nelse {\r\nport->ip_serial_regs = &idd->vma->port_b;\r\nport->ip_uart_regs = &idd->vma->sregs.uartb;\r\nDPRINT_CONFIG(("%s : Port B ip_serial_regs 0x%p "\r\n"ip_uart_regs 0x%p\n",\r\n__func__,\r\n(void *)port->ip_serial_regs,\r\n(void *)port->ip_uart_regs));\r\nport->ip_dma_ringbuf =\r\nports[phys_port - 1]->ip_dma_ringbuf;\r\nport->ip_cpu_ringbuf =\r\nports[phys_port - 1]->ip_cpu_ringbuf;\r\nport->ip_inring = RING(port, RX_B);\r\nport->ip_outring = RING(port, TX_B);\r\nDPRINT_CONFIG(("%s : Port B ip_cpu_ringbuf 0x%p "\r\n"ip_dma_ringbuf 0x%p, ip_inring 0x%p "\r\n"ip_outring 0x%p\n",\r\n__func__,\r\n(void *)port->ip_cpu_ringbuf,\r\n(void *)port->ip_dma_ringbuf,\r\n(void *)port->ip_inring,\r\n(void *)port->ip_outring));\r\n}\r\nDPRINT_CONFIG(("%s : port %d [addr 0x%p] card_ptr 0x%p",\r\n__func__,\r\nphys_port, (void *)port, (void *)card_ptr));\r\nDPRINT_CONFIG((" ip_serial_regs 0x%p ip_uart_regs 0x%p\n",\r\n(void *)port->ip_serial_regs,\r\n(void *)port->ip_uart_regs));\r\nport_init(port);\r\nDPRINT_CONFIG(("%s: phys_port %d port 0x%p inring 0x%p "\r\n"outring 0x%p\n",\r\n__func__,\r\nphys_port, (void *)port,\r\n(void *)port->ip_inring,\r\n(void *)port->ip_outring));\r\n}\r\nif ((ret = ioc3_serial_core_attach(is, idd)))\r\ngoto out4;\r\nNum_of_ioc3_cards++;\r\nreturn ret;\r\nout4:\r\nfor (cnt = 0; cnt < phys_port; cnt++)\r\nkfree(ports[cnt]);\r\nkfree(card_ptr);\r\nreturn ret;\r\n}\r\nstatic int __init ioc3uart_init(void)\r\n{\r\nint ret;\r\nif ((ret = uart_register_driver(&ioc3_uart)) < 0) {\r\nprintk(KERN_WARNING\r\n"%s: Couldn't register IOC3 uart serial driver\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nret = ioc3_register_submodule(&ioc3uart_ops);\r\nif (ret)\r\nuart_unregister_driver(&ioc3_uart);\r\nreturn ret;\r\n}\r\nstatic void __exit ioc3uart_exit(void)\r\n{\r\nioc3_unregister_submodule(&ioc3uart_ops);\r\nuart_unregister_driver(&ioc3_uart);\r\n}
