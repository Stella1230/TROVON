static inline void\r\n__ip_vs_dst_set(struct ip_vs_dest *dest, u32 rtos, struct dst_entry *dst,\r\nu32 dst_cookie)\r\n{\r\nstruct dst_entry *old_dst;\r\nold_dst = dest->dst_cache;\r\ndest->dst_cache = dst;\r\ndest->dst_rtos = rtos;\r\ndest->dst_cookie = dst_cookie;\r\ndst_release(old_dst);\r\n}\r\nstatic inline struct dst_entry *\r\n__ip_vs_dst_check(struct ip_vs_dest *dest, u32 rtos)\r\n{\r\nstruct dst_entry *dst = dest->dst_cache;\r\nif (!dst)\r\nreturn NULL;\r\nif ((dst->obsolete || rtos != dest->dst_rtos) &&\r\ndst->ops->check(dst, dest->dst_cookie) == NULL) {\r\ndest->dst_cache = NULL;\r\ndst_release(dst);\r\nreturn NULL;\r\n}\r\ndst_hold(dst);\r\nreturn dst;\r\n}\r\nstatic struct rtable *\r\n__ip_vs_get_out_rt(struct sk_buff *skb, struct ip_vs_dest *dest,\r\n__be32 daddr, u32 rtos, int rt_mode, __be32 *ret_saddr)\r\n{\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nstruct rtable *rt;\r\nstruct rtable *ort;\r\nint local;\r\nif (dest) {\r\nspin_lock(&dest->dst_lock);\r\nif (!(rt = (struct rtable *)\r\n__ip_vs_dst_check(dest, rtos))) {\r\nstruct flowi4 fl4;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nfl4.daddr = dest->addr.ip;\r\nfl4.flowi4_tos = rtos;\r\nrt = ip_route_output_key(net, &fl4);\r\nif (IS_ERR(rt)) {\r\nspin_unlock(&dest->dst_lock);\r\nIP_VS_DBG_RL("ip_route_output error, dest: %pI4\n",\r\n&dest->addr.ip);\r\nreturn NULL;\r\n}\r\n__ip_vs_dst_set(dest, rtos, dst_clone(&rt->dst), 0);\r\ndest->dst_saddr.ip = fl4.saddr;\r\nIP_VS_DBG(10, "new dst %pI4, src %pI4, refcnt=%d, "\r\n"rtos=%X\n",\r\n&dest->addr.ip, &dest->dst_saddr.ip,\r\natomic_read(&rt->dst.__refcnt), rtos);\r\n}\r\ndaddr = dest->addr.ip;\r\nif (ret_saddr)\r\n*ret_saddr = dest->dst_saddr.ip;\r\nspin_unlock(&dest->dst_lock);\r\n} else {\r\nstruct flowi4 fl4;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nfl4.daddr = daddr;\r\nfl4.flowi4_tos = rtos;\r\nrt = ip_route_output_key(net, &fl4);\r\nif (IS_ERR(rt)) {\r\nIP_VS_DBG_RL("ip_route_output error, dest: %pI4\n",\r\n&daddr);\r\nreturn NULL;\r\n}\r\nif (ret_saddr)\r\n*ret_saddr = fl4.saddr;\r\n}\r\nlocal = rt->rt_flags & RTCF_LOCAL;\r\nif (!((local ? IP_VS_RT_MODE_LOCAL : IP_VS_RT_MODE_NON_LOCAL) &\r\nrt_mode)) {\r\nIP_VS_DBG_RL("Stopping traffic to %s address, dest: %pI4\n",\r\n(rt->rt_flags & RTCF_LOCAL) ?\r\n"local":"non-local", &daddr);\r\nip_rt_put(rt);\r\nreturn NULL;\r\n}\r\nif (local && !(rt_mode & IP_VS_RT_MODE_RDR) &&\r\n!((ort = skb_rtable(skb)) && ort->rt_flags & RTCF_LOCAL)) {\r\nIP_VS_DBG_RL("Redirect from non-local address %pI4 to local "\r\n"requires NAT method, dest: %pI4\n",\r\n&ip_hdr(skb)->daddr, &daddr);\r\nip_rt_put(rt);\r\nreturn NULL;\r\n}\r\nif (unlikely(!local && ipv4_is_loopback(ip_hdr(skb)->saddr))) {\r\nIP_VS_DBG_RL("Stopping traffic from loopback address %pI4 "\r\n"to non-local address, dest: %pI4\n",\r\n&ip_hdr(skb)->saddr, &daddr);\r\nip_rt_put(rt);\r\nreturn NULL;\r\n}\r\nreturn rt;\r\n}\r\nstatic int\r\n__ip_vs_reroute_locally(struct sk_buff *skb)\r\n{\r\nstruct rtable *rt = skb_rtable(skb);\r\nstruct net_device *dev = rt->dst.dev;\r\nstruct net *net = dev_net(dev);\r\nstruct iphdr *iph = ip_hdr(skb);\r\nif (rt_is_input_route(rt)) {\r\nunsigned long orefdst = skb->_skb_refdst;\r\nif (ip_route_input(skb, iph->daddr, iph->saddr,\r\niph->tos, skb->dev))\r\nreturn 0;\r\nrefdst_drop(orefdst);\r\n} else {\r\nstruct flowi4 fl4 = {\r\n.daddr = iph->daddr,\r\n.saddr = iph->saddr,\r\n.flowi4_tos = RT_TOS(iph->tos),\r\n.flowi4_mark = skb->mark,\r\n};\r\nrt = ip_route_output_key(net, &fl4);\r\nif (IS_ERR(rt))\r\nreturn 0;\r\nif (!(rt->rt_flags & RTCF_LOCAL)) {\r\nip_rt_put(rt);\r\nreturn 0;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\n}\r\nreturn 1;\r\n}\r\nstatic inline int __ip_vs_is_local_route6(struct rt6_info *rt)\r\n{\r\nreturn rt->dst.dev && rt->dst.dev->flags & IFF_LOOPBACK;\r\n}\r\nstatic struct dst_entry *\r\n__ip_vs_route_output_v6(struct net *net, struct in6_addr *daddr,\r\nstruct in6_addr *ret_saddr, int do_xfrm)\r\n{\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6 = {\r\n.daddr = *daddr,\r\n};\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst->error)\r\ngoto out_err;\r\nif (!ret_saddr)\r\nreturn dst;\r\nif (ipv6_addr_any(&fl6.saddr) &&\r\nipv6_dev_get_saddr(net, ip6_dst_idev(dst)->dev,\r\n&fl6.daddr, 0, &fl6.saddr) < 0)\r\ngoto out_err;\r\nif (do_xfrm) {\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nif (IS_ERR(dst)) {\r\ndst = NULL;\r\ngoto out_err;\r\n}\r\n}\r\n*ret_saddr = fl6.saddr;\r\nreturn dst;\r\nout_err:\r\ndst_release(dst);\r\nIP_VS_DBG_RL("ip6_route_output error, dest: %pI6\n", daddr);\r\nreturn NULL;\r\n}\r\nstatic struct rt6_info *\r\n__ip_vs_get_out_rt_v6(struct sk_buff *skb, struct ip_vs_dest *dest,\r\nstruct in6_addr *daddr, struct in6_addr *ret_saddr,\r\nint do_xfrm, int rt_mode)\r\n{\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nstruct rt6_info *rt;\r\nstruct rt6_info *ort;\r\nstruct dst_entry *dst;\r\nint local;\r\nif (dest) {\r\nspin_lock(&dest->dst_lock);\r\nrt = (struct rt6_info *)__ip_vs_dst_check(dest, 0);\r\nif (!rt) {\r\nu32 cookie;\r\ndst = __ip_vs_route_output_v6(net, &dest->addr.in6,\r\n&dest->dst_saddr.in6,\r\ndo_xfrm);\r\nif (!dst) {\r\nspin_unlock(&dest->dst_lock);\r\nreturn NULL;\r\n}\r\nrt = (struct rt6_info *) dst;\r\ncookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;\r\n__ip_vs_dst_set(dest, 0, dst_clone(&rt->dst), cookie);\r\nIP_VS_DBG(10, "new dst %pI6, src %pI6, refcnt=%d\n",\r\n&dest->addr.in6, &dest->dst_saddr.in6,\r\natomic_read(&rt->dst.__refcnt));\r\n}\r\nif (ret_saddr)\r\n*ret_saddr = dest->dst_saddr.in6;\r\nspin_unlock(&dest->dst_lock);\r\n} else {\r\ndst = __ip_vs_route_output_v6(net, daddr, ret_saddr, do_xfrm);\r\nif (!dst)\r\nreturn NULL;\r\nrt = (struct rt6_info *) dst;\r\n}\r\nlocal = __ip_vs_is_local_route6(rt);\r\nif (!((local ? IP_VS_RT_MODE_LOCAL : IP_VS_RT_MODE_NON_LOCAL) &\r\nrt_mode)) {\r\nIP_VS_DBG_RL("Stopping traffic to %s address, dest: %pI6\n",\r\nlocal ? "local":"non-local", daddr);\r\ndst_release(&rt->dst);\r\nreturn NULL;\r\n}\r\nif (local && !(rt_mode & IP_VS_RT_MODE_RDR) &&\r\n!((ort = (struct rt6_info *) skb_dst(skb)) &&\r\n__ip_vs_is_local_route6(ort))) {\r\nIP_VS_DBG_RL("Redirect from non-local address %pI6 to local "\r\n"requires NAT method, dest: %pI6\n",\r\n&ipv6_hdr(skb)->daddr, daddr);\r\ndst_release(&rt->dst);\r\nreturn NULL;\r\n}\r\nif (unlikely(!local && (!skb->dev || skb->dev->flags & IFF_LOOPBACK) &&\r\nipv6_addr_type(&ipv6_hdr(skb)->saddr) &\r\nIPV6_ADDR_LOOPBACK)) {\r\nIP_VS_DBG_RL("Stopping traffic from loopback address %pI6 "\r\n"to non-local address, dest: %pI6\n",\r\n&ipv6_hdr(skb)->saddr, daddr);\r\ndst_release(&rt->dst);\r\nreturn NULL;\r\n}\r\nreturn rt;\r\n}\r\nvoid\r\nip_vs_dst_reset(struct ip_vs_dest *dest)\r\n{\r\nstruct dst_entry *old_dst;\r\nold_dst = dest->dst_cache;\r\ndest->dst_cache = NULL;\r\ndst_release(old_dst);\r\n}\r\nint\r\nip_vs_null_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nIP_VS_XMIT(NFPROTO_IPV4, skb, cp, 1);\r\n}\r\nint\r\nip_vs_bypass_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rtable *rt;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nint mtu;\r\nEnterFunction(10);\r\nif (!(rt = __ip_vs_get_out_rt(skb, NULL, iph->daddr, RT_TOS(iph->tos),\r\nIP_VS_RT_MODE_NON_LOCAL, NULL)))\r\ngoto tx_error_icmp;\r\nmtu = dst_mtu(&rt->dst);\r\nif ((skb->len > mtu) && (iph->frag_off & htons(IP_DF)) &&\r\n!skb_is_gso(skb)) {\r\nip_rt_put(rt);\r\nicmp_send(skb, ICMP_DEST_UNREACH,ICMP_FRAG_NEEDED, htonl(mtu));\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error;\r\n}\r\nif (unlikely((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)) {\r\nip_rt_put(rt);\r\nreturn NF_STOLEN;\r\n}\r\nip_send_check(ip_hdr(skb));\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nskb->local_df = 1;\r\nIP_VS_XMIT(NFPROTO_IPV4, skb, cp, 0);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\n}\r\nint\r\nip_vs_bypass_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rt6_info *rt;\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nint mtu;\r\nEnterFunction(10);\r\nif (!(rt = __ip_vs_get_out_rt_v6(skb, NULL, &iph->daddr, NULL, 0,\r\nIP_VS_RT_MODE_NON_LOCAL)))\r\ngoto tx_error_icmp;\r\nmtu = dst_mtu(&rt->dst);\r\nif (skb->len > mtu && !skb_is_gso(skb)) {\r\nif (!skb->dev) {\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nskb->dev = net->loopback_dev;\r\n}\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\ndst_release(&rt->dst);\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error;\r\n}\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (unlikely(skb == NULL)) {\r\ndst_release(&rt->dst);\r\nreturn NF_STOLEN;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nskb->local_df = 1;\r\nIP_VS_XMIT(NFPROTO_IPV6, skb, cp, 0);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\n}\r\nint\r\nip_vs_nat_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rtable *rt;\r\nint mtu;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nint local;\r\nEnterFunction(10);\r\nif (unlikely(cp->flags & IP_VS_CONN_F_NO_CPORT)) {\r\n__be16 _pt, *p;\r\np = skb_header_pointer(skb, iph->ihl*4, sizeof(_pt), &_pt);\r\nif (p == NULL)\r\ngoto tx_error;\r\nip_vs_conn_fill_cport(cp, *p);\r\nIP_VS_DBG(10, "filled cport=%d\n", ntohs(*p));\r\n}\r\nif (!(rt = __ip_vs_get_out_rt(skb, cp->dest, cp->daddr.ip,\r\nRT_TOS(iph->tos),\r\nIP_VS_RT_MODE_LOCAL |\r\nIP_VS_RT_MODE_NON_LOCAL |\r\nIP_VS_RT_MODE_RDR, NULL)))\r\ngoto tx_error_icmp;\r\nlocal = rt->rt_flags & RTCF_LOCAL;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (cp->flags & IP_VS_CONN_F_SYNC && local) {\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = ct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct)) {\r\nIP_VS_DBG_RL_PKT(10, AF_INET, pp, skb, 0,\r\n"ip_vs_nat_xmit(): "\r\n"stopping DNAT to local address");\r\ngoto tx_error_put;\r\n}\r\n}\r\n#endif\r\nif (local && ipv4_is_loopback(cp->daddr.ip) &&\r\nrt_is_input_route(skb_rtable(skb))) {\r\nIP_VS_DBG_RL_PKT(1, AF_INET, pp, skb, 0, "ip_vs_nat_xmit(): "\r\n"stopping DNAT to loopback address");\r\ngoto tx_error_put;\r\n}\r\nmtu = dst_mtu(&rt->dst);\r\nif ((skb->len > mtu) && (iph->frag_off & htons(IP_DF)) &&\r\n!skb_is_gso(skb)) {\r\nicmp_send(skb, ICMP_DEST_UNREACH,ICMP_FRAG_NEEDED, htonl(mtu));\r\nIP_VS_DBG_RL_PKT(0, AF_INET, pp, skb, 0,\r\n"ip_vs_nat_xmit(): frag needed for");\r\ngoto tx_error_put;\r\n}\r\nif (!skb_make_writable(skb, sizeof(struct iphdr)))\r\ngoto tx_error_put;\r\nif (skb_cow(skb, rt->dst.dev->hard_header_len))\r\ngoto tx_error_put;\r\nif (pp->dnat_handler && !pp->dnat_handler(skb, pp, cp))\r\ngoto tx_error_put;\r\nip_hdr(skb)->daddr = cp->daddr.ip;\r\nip_send_check(ip_hdr(skb));\r\nif (!local) {\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\n} else {\r\nip_rt_put(rt);\r\nif (!__ip_vs_reroute_locally(skb))\r\ngoto tx_error;\r\n}\r\nIP_VS_DBG_PKT(10, AF_INET, pp, skb, 0, "After DNAT");\r\nskb->local_df = 1;\r\nIP_VS_XMIT_NAT(NFPROTO_IPV4, skb, cp, local);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_put:\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nint\r\nip_vs_nat_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rt6_info *rt;\r\nint mtu;\r\nint local;\r\nEnterFunction(10);\r\nif (unlikely(cp->flags & IP_VS_CONN_F_NO_CPORT)) {\r\n__be16 _pt, *p;\r\np = skb_header_pointer(skb, sizeof(struct ipv6hdr),\r\nsizeof(_pt), &_pt);\r\nif (p == NULL)\r\ngoto tx_error;\r\nip_vs_conn_fill_cport(cp, *p);\r\nIP_VS_DBG(10, "filled cport=%d\n", ntohs(*p));\r\n}\r\nif (!(rt = __ip_vs_get_out_rt_v6(skb, cp->dest, &cp->daddr.in6, NULL,\r\n0, (IP_VS_RT_MODE_LOCAL |\r\nIP_VS_RT_MODE_NON_LOCAL |\r\nIP_VS_RT_MODE_RDR))))\r\ngoto tx_error_icmp;\r\nlocal = __ip_vs_is_local_route6(rt);\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (cp->flags & IP_VS_CONN_F_SYNC && local) {\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = ct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct)) {\r\nIP_VS_DBG_RL_PKT(10, AF_INET6, pp, skb, 0,\r\n"ip_vs_nat_xmit_v6(): "\r\n"stopping DNAT to local address");\r\ngoto tx_error_put;\r\n}\r\n}\r\n#endif\r\nif (local && skb->dev && !(skb->dev->flags & IFF_LOOPBACK) &&\r\nipv6_addr_type(&rt->rt6i_dst.addr) & IPV6_ADDR_LOOPBACK) {\r\nIP_VS_DBG_RL_PKT(1, AF_INET6, pp, skb, 0,\r\n"ip_vs_nat_xmit_v6(): "\r\n"stopping DNAT to loopback address");\r\ngoto tx_error_put;\r\n}\r\nmtu = dst_mtu(&rt->dst);\r\nif (skb->len > mtu && !skb_is_gso(skb)) {\r\nif (!skb->dev) {\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nskb->dev = net->loopback_dev;\r\n}\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nIP_VS_DBG_RL_PKT(0, AF_INET6, pp, skb, 0,\r\n"ip_vs_nat_xmit_v6(): frag needed for");\r\ngoto tx_error_put;\r\n}\r\nif (!skb_make_writable(skb, sizeof(struct ipv6hdr)))\r\ngoto tx_error_put;\r\nif (skb_cow(skb, rt->dst.dev->hard_header_len))\r\ngoto tx_error_put;\r\nif (pp->dnat_handler && !pp->dnat_handler(skb, pp, cp))\r\ngoto tx_error;\r\nipv6_hdr(skb)->daddr = cp->daddr.in6;\r\nif (!local || !skb->dev) {\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\n} else {\r\ndst_release(&rt->dst);\r\n}\r\nIP_VS_DBG_PKT(10, AF_INET6, pp, skb, 0, "After DNAT");\r\nskb->local_df = 1;\r\nIP_VS_XMIT_NAT(NFPROTO_IPV6, skb, cp, local);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nLeaveFunction(10);\r\nkfree_skb(skb);\r\nreturn NF_STOLEN;\r\ntx_error_put:\r\ndst_release(&rt->dst);\r\ngoto tx_error;\r\n}\r\nint\r\nip_vs_tunnel_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rtable *rt;\r\n__be32 saddr;\r\nstruct net_device *tdev;\r\nstruct iphdr *old_iph = ip_hdr(skb);\r\nu8 tos = old_iph->tos;\r\n__be16 df = old_iph->frag_off;\r\nstruct iphdr *iph;\r\nunsigned int max_headroom;\r\nint mtu;\r\nint ret;\r\nEnterFunction(10);\r\nif (!(rt = __ip_vs_get_out_rt(skb, cp->dest, cp->daddr.ip,\r\nRT_TOS(tos), IP_VS_RT_MODE_LOCAL |\r\nIP_VS_RT_MODE_NON_LOCAL,\r\n&saddr)))\r\ngoto tx_error_icmp;\r\nif (rt->rt_flags & RTCF_LOCAL) {\r\nip_rt_put(rt);\r\nIP_VS_XMIT(NFPROTO_IPV4, skb, cp, 1);\r\n}\r\ntdev = rt->dst.dev;\r\nmtu = dst_mtu(&rt->dst) - sizeof(struct iphdr);\r\nif (mtu < 68) {\r\nIP_VS_DBG_RL("%s(): mtu less than 68\n", __func__);\r\ngoto tx_error_put;\r\n}\r\nif (skb_dst(skb))\r\nskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\r\ndf |= (old_iph->frag_off & htons(IP_DF));\r\nif ((old_iph->frag_off & htons(IP_DF) &&\r\nmtu < ntohs(old_iph->tot_len) && !skb_is_gso(skb))) {\r\nicmp_send(skb, ICMP_DEST_UNREACH,ICMP_FRAG_NEEDED, htonl(mtu));\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error_put;\r\n}\r\nmax_headroom = LL_RESERVED_SPACE(tdev) + sizeof(struct iphdr);\r\nif (skb_headroom(skb) < max_headroom\r\n|| skb_cloned(skb) || skb_shared(skb)) {\r\nstruct sk_buff *new_skb =\r\nskb_realloc_headroom(skb, max_headroom);\r\nif (!new_skb) {\r\nip_rt_put(rt);\r\nkfree_skb(skb);\r\nIP_VS_ERR_RL("%s(): no memory\n", __func__);\r\nreturn NF_STOLEN;\r\n}\r\nkfree_skb(skb);\r\nskb = new_skb;\r\nold_iph = ip_hdr(skb);\r\n}\r\nskb->transport_header = skb->network_header;\r\nip_send_check(old_iph);\r\nskb_push(skb, sizeof(struct iphdr));\r\nskb_reset_network_header(skb);\r\nmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\niph = ip_hdr(skb);\r\niph->version = 4;\r\niph->ihl = sizeof(struct iphdr)>>2;\r\niph->frag_off = df;\r\niph->protocol = IPPROTO_IPIP;\r\niph->tos = tos;\r\niph->daddr = cp->daddr.ip;\r\niph->saddr = saddr;\r\niph->ttl = old_iph->ttl;\r\nip_select_ident(iph, &rt->dst, NULL);\r\nskb->local_df = 1;\r\nret = IP_VS_XMIT_TUNNEL(skb, cp);\r\nif (ret == NF_ACCEPT)\r\nip_local_out(skb);\r\nelse if (ret == NF_DROP)\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_put:\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nint\r\nip_vs_tunnel_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rt6_info *rt;\r\nstruct in6_addr saddr;\r\nstruct net_device *tdev;\r\nstruct ipv6hdr *old_iph = ipv6_hdr(skb);\r\nstruct ipv6hdr *iph;\r\nunsigned int max_headroom;\r\nint mtu;\r\nint ret;\r\nEnterFunction(10);\r\nif (!(rt = __ip_vs_get_out_rt_v6(skb, cp->dest, &cp->daddr.in6,\r\n&saddr, 1, (IP_VS_RT_MODE_LOCAL |\r\nIP_VS_RT_MODE_NON_LOCAL))))\r\ngoto tx_error_icmp;\r\nif (__ip_vs_is_local_route6(rt)) {\r\ndst_release(&rt->dst);\r\nIP_VS_XMIT(NFPROTO_IPV6, skb, cp, 1);\r\n}\r\ntdev = rt->dst.dev;\r\nmtu = dst_mtu(&rt->dst) - sizeof(struct ipv6hdr);\r\nif (mtu < IPV6_MIN_MTU) {\r\nIP_VS_DBG_RL("%s(): mtu less than %d\n", __func__,\r\nIPV6_MIN_MTU);\r\ngoto tx_error_put;\r\n}\r\nif (skb_dst(skb))\r\nskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\r\nif (mtu < ntohs(old_iph->payload_len) + sizeof(struct ipv6hdr) &&\r\n!skb_is_gso(skb)) {\r\nif (!skb->dev) {\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nskb->dev = net->loopback_dev;\r\n}\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error_put;\r\n}\r\nmax_headroom = LL_RESERVED_SPACE(tdev) + sizeof(struct ipv6hdr);\r\nif (skb_headroom(skb) < max_headroom\r\n|| skb_cloned(skb) || skb_shared(skb)) {\r\nstruct sk_buff *new_skb =\r\nskb_realloc_headroom(skb, max_headroom);\r\nif (!new_skb) {\r\ndst_release(&rt->dst);\r\nkfree_skb(skb);\r\nIP_VS_ERR_RL("%s(): no memory\n", __func__);\r\nreturn NF_STOLEN;\r\n}\r\nkfree_skb(skb);\r\nskb = new_skb;\r\nold_iph = ipv6_hdr(skb);\r\n}\r\nskb->transport_header = skb->network_header;\r\nskb_push(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\nmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\niph = ipv6_hdr(skb);\r\niph->version = 6;\r\niph->nexthdr = IPPROTO_IPV6;\r\niph->payload_len = old_iph->payload_len;\r\nbe16_add_cpu(&iph->payload_len, sizeof(*old_iph));\r\niph->priority = old_iph->priority;\r\nmemset(&iph->flow_lbl, 0, sizeof(iph->flow_lbl));\r\niph->daddr = cp->daddr.in6;\r\niph->saddr = saddr;\r\niph->hop_limit = old_iph->hop_limit;\r\nskb->local_df = 1;\r\nret = IP_VS_XMIT_TUNNEL(skb, cp);\r\nif (ret == NF_ACCEPT)\r\nip6_local_out(skb);\r\nelse if (ret == NF_DROP)\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_put:\r\ndst_release(&rt->dst);\r\ngoto tx_error;\r\n}\r\nint\r\nip_vs_dr_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rtable *rt;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nint mtu;\r\nEnterFunction(10);\r\nif (!(rt = __ip_vs_get_out_rt(skb, cp->dest, cp->daddr.ip,\r\nRT_TOS(iph->tos),\r\nIP_VS_RT_MODE_LOCAL |\r\nIP_VS_RT_MODE_NON_LOCAL, NULL)))\r\ngoto tx_error_icmp;\r\nif (rt->rt_flags & RTCF_LOCAL) {\r\nip_rt_put(rt);\r\nIP_VS_XMIT(NFPROTO_IPV4, skb, cp, 1);\r\n}\r\nmtu = dst_mtu(&rt->dst);\r\nif ((iph->frag_off & htons(IP_DF)) && skb->len > mtu &&\r\n!skb_is_gso(skb)) {\r\nicmp_send(skb, ICMP_DEST_UNREACH,ICMP_FRAG_NEEDED, htonl(mtu));\r\nip_rt_put(rt);\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error;\r\n}\r\nif (unlikely((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)) {\r\nip_rt_put(rt);\r\nreturn NF_STOLEN;\r\n}\r\nip_send_check(ip_hdr(skb));\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nskb->local_df = 1;\r\nIP_VS_XMIT(NFPROTO_IPV4, skb, cp, 0);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\n}\r\nint\r\nip_vs_dr_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp)\r\n{\r\nstruct rt6_info *rt;\r\nint mtu;\r\nEnterFunction(10);\r\nif (!(rt = __ip_vs_get_out_rt_v6(skb, cp->dest, &cp->daddr.in6, NULL,\r\n0, (IP_VS_RT_MODE_LOCAL |\r\nIP_VS_RT_MODE_NON_LOCAL))))\r\ngoto tx_error_icmp;\r\nif (__ip_vs_is_local_route6(rt)) {\r\ndst_release(&rt->dst);\r\nIP_VS_XMIT(NFPROTO_IPV6, skb, cp, 1);\r\n}\r\nmtu = dst_mtu(&rt->dst);\r\nif (skb->len > mtu) {\r\nif (!skb->dev) {\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nskb->dev = net->loopback_dev;\r\n}\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\ndst_release(&rt->dst);\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error;\r\n}\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (unlikely(skb == NULL)) {\r\ndst_release(&rt->dst);\r\nreturn NF_STOLEN;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nskb->local_df = 1;\r\nIP_VS_XMIT(NFPROTO_IPV6, skb, cp, 0);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\nkfree_skb(skb);\r\nLeaveFunction(10);\r\nreturn NF_STOLEN;\r\n}\r\nint\r\nip_vs_icmp_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp, int offset, unsigned int hooknum)\r\n{\r\nstruct rtable *rt;\r\nint mtu;\r\nint rc;\r\nint local;\r\nint rt_mode;\r\nEnterFunction(10);\r\nif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ) {\r\nif (cp->packet_xmit)\r\nrc = cp->packet_xmit(skb, cp, pp);\r\nelse\r\nrc = NF_ACCEPT;\r\natomic_inc(&cp->in_pkts);\r\ngoto out;\r\n}\r\nrt_mode = (hooknum != NF_INET_FORWARD) ?\r\nIP_VS_RT_MODE_LOCAL | IP_VS_RT_MODE_NON_LOCAL |\r\nIP_VS_RT_MODE_RDR : IP_VS_RT_MODE_NON_LOCAL;\r\nif (!(rt = __ip_vs_get_out_rt(skb, cp->dest, cp->daddr.ip,\r\nRT_TOS(ip_hdr(skb)->tos),\r\nrt_mode, NULL)))\r\ngoto tx_error_icmp;\r\nlocal = rt->rt_flags & RTCF_LOCAL;\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (cp->flags & IP_VS_CONN_F_SYNC && local) {\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = ct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct)) {\r\nIP_VS_DBG(10, "%s(): "\r\n"stopping DNAT to local address %pI4\n",\r\n__func__, &cp->daddr.ip);\r\ngoto tx_error_put;\r\n}\r\n}\r\n#endif\r\nif (local && ipv4_is_loopback(cp->daddr.ip) &&\r\nrt_is_input_route(skb_rtable(skb))) {\r\nIP_VS_DBG(1, "%s(): "\r\n"stopping DNAT to loopback %pI4\n",\r\n__func__, &cp->daddr.ip);\r\ngoto tx_error_put;\r\n}\r\nmtu = dst_mtu(&rt->dst);\r\nif ((skb->len > mtu) && (ip_hdr(skb)->frag_off & htons(IP_DF)) &&\r\n!skb_is_gso(skb)) {\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error_put;\r\n}\r\nif (!skb_make_writable(skb, offset))\r\ngoto tx_error_put;\r\nif (skb_cow(skb, rt->dst.dev->hard_header_len))\r\ngoto tx_error_put;\r\nip_vs_nat_icmp(skb, pp, cp, 0);\r\nif (!local) {\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\n} else {\r\nip_rt_put(rt);\r\nif (!__ip_vs_reroute_locally(skb))\r\ngoto tx_error;\r\n}\r\nskb->local_df = 1;\r\nIP_VS_XMIT_NAT(NFPROTO_IPV4, skb, cp, local);\r\nrc = NF_STOLEN;\r\ngoto out;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\ndev_kfree_skb(skb);\r\nrc = NF_STOLEN;\r\nout:\r\nLeaveFunction(10);\r\nreturn rc;\r\ntx_error_put:\r\nip_rt_put(rt);\r\ngoto tx_error;\r\n}\r\nint\r\nip_vs_icmp_xmit_v6(struct sk_buff *skb, struct ip_vs_conn *cp,\r\nstruct ip_vs_protocol *pp, int offset, unsigned int hooknum)\r\n{\r\nstruct rt6_info *rt;\r\nint mtu;\r\nint rc;\r\nint local;\r\nint rt_mode;\r\nEnterFunction(10);\r\nif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ) {\r\nif (cp->packet_xmit)\r\nrc = cp->packet_xmit(skb, cp, pp);\r\nelse\r\nrc = NF_ACCEPT;\r\natomic_inc(&cp->in_pkts);\r\ngoto out;\r\n}\r\nrt_mode = (hooknum != NF_INET_FORWARD) ?\r\nIP_VS_RT_MODE_LOCAL | IP_VS_RT_MODE_NON_LOCAL |\r\nIP_VS_RT_MODE_RDR : IP_VS_RT_MODE_NON_LOCAL;\r\nif (!(rt = __ip_vs_get_out_rt_v6(skb, cp->dest, &cp->daddr.in6, NULL,\r\n0, rt_mode)))\r\ngoto tx_error_icmp;\r\nlocal = __ip_vs_is_local_route6(rt);\r\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\r\nif (cp->flags & IP_VS_CONN_F_SYNC && local) {\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = ct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct)) {\r\nIP_VS_DBG(10, "%s(): "\r\n"stopping DNAT to local address %pI6\n",\r\n__func__, &cp->daddr.in6);\r\ngoto tx_error_put;\r\n}\r\n}\r\n#endif\r\nif (local && skb->dev && !(skb->dev->flags & IFF_LOOPBACK) &&\r\nipv6_addr_type(&rt->rt6i_dst.addr) & IPV6_ADDR_LOOPBACK) {\r\nIP_VS_DBG(1, "%s(): "\r\n"stopping DNAT to loopback %pI6\n",\r\n__func__, &cp->daddr.in6);\r\ngoto tx_error_put;\r\n}\r\nmtu = dst_mtu(&rt->dst);\r\nif (skb->len > mtu && !skb_is_gso(skb)) {\r\nif (!skb->dev) {\r\nstruct net *net = dev_net(skb_dst(skb)->dev);\r\nskb->dev = net->loopback_dev;\r\n}\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nIP_VS_DBG_RL("%s(): frag needed\n", __func__);\r\ngoto tx_error_put;\r\n}\r\nif (!skb_make_writable(skb, offset))\r\ngoto tx_error_put;\r\nif (skb_cow(skb, rt->dst.dev->hard_header_len))\r\ngoto tx_error_put;\r\nip_vs_nat_icmp_v6(skb, pp, cp, 0);\r\nif (!local || !skb->dev) {\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\n} else {\r\ndst_release(&rt->dst);\r\n}\r\nskb->local_df = 1;\r\nIP_VS_XMIT_NAT(NFPROTO_IPV6, skb, cp, local);\r\nrc = NF_STOLEN;\r\ngoto out;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\ndev_kfree_skb(skb);\r\nrc = NF_STOLEN;\r\nout:\r\nLeaveFunction(10);\r\nreturn rc;\r\ntx_error_put:\r\ndst_release(&rt->dst);\r\ngoto tx_error;\r\n}
