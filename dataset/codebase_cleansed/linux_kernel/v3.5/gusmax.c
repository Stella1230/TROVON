static int __devinit snd_gusmax_detect(struct snd_gus_card * gus)\r\n{\r\nunsigned char d;\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {\r\nsnd_printdd("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -ENODEV;\r\n}\r\nudelay(160);\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\r\nudelay(160);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {\r\nsnd_printdd("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_gusmax_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_gusmax *maxcard = dev_id;\r\nint loop, max = 5;\r\nint handled = 0;\r\ndo {\r\nloop = 0;\r\nif (inb(maxcard->gus_status_reg)) {\r\nhandled = 1;\r\nsnd_gus_interrupt(irq, maxcard->gus);\r\nloop++;\r\n}\r\nif (inb(maxcard->pcm_status_reg) & 0x01) {\r\nhandled = 1;\r\nsnd_wss_interrupt(irq, maxcard->wss);\r\nloop++;\r\n}\r\n} while (loop && --max > 0);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void __devinit snd_gusmax_init(int dev, struct snd_card *card,\r\nstruct snd_gus_card * gus)\r\n{\r\ngus->equal_irq = 1;\r\ngus->codec_flag = 1;\r\ngus->joystick_dac = joystick_dac[dev];\r\ngus->max_cntrl_val = (gus->gf1.port >> 4) & 0x0f;\r\nif (gus->gf1.dma1 > 3)\r\ngus->max_cntrl_val |= 0x10;\r\nif (gus->gf1.dma2 > 3)\r\ngus->max_cntrl_val |= 0x20;\r\ngus->max_cntrl_val |= 0x40;\r\noutb(gus->max_cntrl_val, GUSP(gus, MAXCNTRLPORT));\r\n}\r\nstatic int __devinit snd_gusmax_mixer(struct snd_wss *chip)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_ctl_elem_id id1, id2;\r\nint err;\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id1.name, "Aux Playback Switch");\r\nstrcpy(id2.name, "Synth Playback Switch");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "Synth Playback Volume");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Aux Playback Switch"); id1.index = 1;\r\nstrcpy(id2.name, "CD Playback Switch");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "CD Playback Volume");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0)\r\nreturn err;\r\n#if 0\r\nif (snd_mixer_group_rename(mixer,\r\nSNDRV_MIXER_IN_MONO, 0,\r\nSNDRV_MIXER_IN_MIC, 0) < 0)\r\ngoto __error;\r\nif (snd_mixer_elem_rename(mixer,\r\nSNDRV_MIXER_IN_MONO, 0, SNDRV_MIXER_ETYPE_INPUT,\r\nSNDRV_MIXER_IN_MIC, 0) < 0)\r\ngoto __error;\r\nif (snd_mixer_elem_rename(mixer,\r\n"Mono Capture Volume", 0, SNDRV_MIXER_ETYPE_VOLUME1,\r\n"Mic Capture Volume", 0) < 0)\r\ngoto __error;\r\nif (snd_mixer_elem_rename(mixer,\r\n"Mono Capture Switch", 0, SNDRV_MIXER_ETYPE_SWITCH1,\r\n"Mic Capture Switch", 0) < 0)\r\ngoto __error;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void snd_gusmax_free(struct snd_card *card)\r\n{\r\nstruct snd_gusmax *maxcard = card->private_data;\r\nif (maxcard == NULL)\r\nreturn;\r\nif (maxcard->irq >= 0)\r\nfree_irq(maxcard->irq, (void *)maxcard);\r\n}\r\nstatic int __devinit snd_gusmax_match(struct device *pdev, unsigned int dev)\r\n{\r\nreturn enable[dev];\r\n}\r\nstatic int __devinit snd_gusmax_probe(struct device *pdev, unsigned int dev)\r\n{\r\nstatic int possible_irqs[] = {5, 11, 12, 9, 7, 15, 3, -1};\r\nstatic int possible_dmas[] = {5, 6, 7, 1, 3, -1};\r\nint xirq, xdma1, xdma2, err;\r\nstruct snd_card *card;\r\nstruct snd_gus_card *gus = NULL;\r\nstruct snd_wss *wss;\r\nstruct snd_gusmax *maxcard;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_gusmax), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_gusmax_free;\r\nmaxcard = card->private_data;\r\nmaxcard->card = card;\r\nmaxcard->irq = -1;\r\nxirq = irq[dev];\r\nif (xirq == SNDRV_AUTO_IRQ) {\r\nif ((xirq = snd_legacy_find_free_irq(possible_irqs)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free IRQ\n");\r\nerr = -EBUSY;\r\ngoto _err;\r\n}\r\n}\r\nxdma1 = dma1[dev];\r\nif (xdma1 == SNDRV_AUTO_DMA) {\r\nif ((xdma1 = snd_legacy_find_free_dma(possible_dmas)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free DMA1\n");\r\nerr = -EBUSY;\r\ngoto _err;\r\n}\r\n}\r\nxdma2 = dma2[dev];\r\nif (xdma2 == SNDRV_AUTO_DMA) {\r\nif ((xdma2 = snd_legacy_find_free_dma(possible_dmas)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free DMA2\n");\r\nerr = -EBUSY;\r\ngoto _err;\r\n}\r\n}\r\nif (port[dev] != SNDRV_AUTO_PORT) {\r\nerr = snd_gus_create(card,\r\nport[dev],\r\n-xirq, xdma1, xdma2,\r\n0, channels[dev],\r\npcm_channels[dev],\r\n0, &gus);\r\n} else {\r\nstatic unsigned long possible_ports[] = {\r\n0x220, 0x230, 0x240, 0x250, 0x260\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\r\nerr = snd_gus_create(card,\r\npossible_ports[i],\r\n-xirq, xdma1, xdma2,\r\n0, channels[dev],\r\npcm_channels[dev],\r\n0, &gus);\r\nif (err >= 0) {\r\nport[dev] = possible_ports[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif (err < 0)\r\ngoto _err;\r\nif ((err = snd_gusmax_detect(gus)) < 0)\r\ngoto _err;\r\nmaxcard->gus_status_reg = gus->gf1.reg_irqstat;\r\nmaxcard->pcm_status_reg = gus->gf1.port + 0x10c + 2;\r\nsnd_gusmax_init(dev, card, gus);\r\nif ((err = snd_gus_initialize(gus)) < 0)\r\ngoto _err;\r\nif (!gus->max_flag) {\r\nsnd_printk(KERN_ERR PFX "GUS MAX soundcard was not detected at 0x%lx\n", gus->gf1.port);\r\nerr = -ENODEV;\r\ngoto _err;\r\n}\r\nif (request_irq(xirq, snd_gusmax_interrupt, 0, "GUS MAX", (void *)maxcard)) {\r\nsnd_printk(KERN_ERR PFX "unable to grab IRQ %d\n", xirq);\r\nerr = -EBUSY;\r\ngoto _err;\r\n}\r\nmaxcard->irq = xirq;\r\nerr = snd_wss_create(card,\r\ngus->gf1.port + 0x10c, -1, xirq,\r\nxdma2 < 0 ? xdma1 : xdma2, xdma1,\r\nWSS_HW_DETECT,\r\nWSS_HWSHARE_IRQ |\r\nWSS_HWSHARE_DMA1 |\r\nWSS_HWSHARE_DMA2,\r\n&wss);\r\nif (err < 0)\r\ngoto _err;\r\nerr = snd_wss_pcm(wss, 0, NULL);\r\nif (err < 0)\r\ngoto _err;\r\nerr = snd_wss_mixer(wss);\r\nif (err < 0)\r\ngoto _err;\r\nerr = snd_wss_timer(wss, 2, NULL);\r\nif (err < 0)\r\ngoto _err;\r\nif (pcm_channels[dev] > 0) {\r\nif ((err = snd_gf1_pcm_new(gus, 1, 1, NULL)) < 0)\r\ngoto _err;\r\n}\r\nerr = snd_gusmax_mixer(wss);\r\nif (err < 0)\r\ngoto _err;\r\nerr = snd_gf1_rawmidi_new(gus, 0, NULL);\r\nif (err < 0)\r\ngoto _err;\r\nsprintf(card->longname + strlen(card->longname), " at 0x%lx, irq %i, dma %i", gus->gf1.port, xirq, xdma1);\r\nif (xdma2 >= 0)\r\nsprintf(card->longname + strlen(card->longname), "&%i", xdma2);\r\nsnd_card_set_dev(card, pdev);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto _err;\r\nmaxcard->gus = gus;\r\nmaxcard->wss = wss;\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n_err:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int __devexit snd_gusmax_remove(struct device *devptr, unsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\ndev_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_gusmax_init(void)\r\n{\r\nreturn isa_register_driver(&snd_gusmax_driver, SNDRV_CARDS);\r\n}\r\nstatic void __exit alsa_card_gusmax_exit(void)\r\n{\r\nisa_unregister_driver(&snd_gusmax_driver);\r\n}
