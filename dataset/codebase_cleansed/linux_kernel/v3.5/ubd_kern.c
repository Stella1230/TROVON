static inline int ubd_test_bit(__u64 bit, unsigned char *data)\r\n{\r\n__u64 n;\r\nint bits, off;\r\nbits = sizeof(data[0]) * 8;\r\nn = bit / bits;\r\noff = bit % bits;\r\nreturn (data[n] & (1 << off)) != 0;\r\n}\r\nstatic inline void ubd_set_bit(__u64 bit, unsigned char *data)\r\n{\r\n__u64 n;\r\nint bits, off;\r\nbits = sizeof(data[0]) * 8;\r\nn = bit / bits;\r\noff = bit % bits;\r\ndata[n] |= (1 << off);\r\n}\r\nstatic void make_proc_ide(void)\r\n{\r\nproc_ide_root = proc_mkdir("ide", NULL);\r\nproc_ide = proc_mkdir("ide0", proc_ide_root);\r\n}\r\nstatic int fake_ide_media_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_puts(m, "disk\n");\r\nreturn 0;\r\n}\r\nstatic int fake_ide_media_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fake_ide_media_proc_show, NULL);\r\n}\r\nstatic void make_ide_entries(const char *dev_name)\r\n{\r\nstruct proc_dir_entry *dir, *ent;\r\nchar name[64];\r\nif(proc_ide_root == NULL) make_proc_ide();\r\ndir = proc_mkdir(dev_name, proc_ide);\r\nif(!dir) return;\r\nent = proc_create("media", S_IRUGO, dir, &fake_ide_media_proc_fops);\r\nif(!ent) return;\r\nsnprintf(name, sizeof(name), "ide0/%s", dev_name);\r\nproc_symlink(dev_name, proc_ide_root, name);\r\n}\r\nstatic int fake_ide_setup(char *str)\r\n{\r\nfake_ide = 1;\r\nreturn 1;\r\n}\r\nstatic int parse_unit(char **ptr)\r\n{\r\nchar *str = *ptr, *end;\r\nint n = -1;\r\nif(isdigit(*str)) {\r\nn = simple_strtoul(str, &end, 0);\r\nif(end == str)\r\nreturn -1;\r\n*ptr = end;\r\n}\r\nelse if (('a' <= *str) && (*str <= 'z')) {\r\nn = *str - 'a';\r\nstr++;\r\n*ptr = str;\r\n}\r\nreturn n;\r\n}\r\nstatic int ubd_setup_common(char *str, int *index_out, char **error_out)\r\n{\r\nstruct ubd *ubd_dev;\r\nstruct openflags flags = global_openflags;\r\nchar *backing_file;\r\nint n, err = 0, i;\r\nif(index_out) *index_out = -1;\r\nn = *str;\r\nif(n == '='){\r\nchar *end;\r\nint major;\r\nstr++;\r\nif(!strcmp(str, "sync")){\r\nglobal_openflags = of_sync(global_openflags);\r\ngoto out1;\r\n}\r\nerr = -EINVAL;\r\nmajor = simple_strtoul(str, &end, 0);\r\nif((*end != '\0') || (end == str)){\r\n*error_out = "Didn't parse major number";\r\ngoto out1;\r\n}\r\nmutex_lock(&ubd_lock);\r\nif (fake_major != UBD_MAJOR) {\r\n*error_out = "Can't assign a fake major twice";\r\ngoto out1;\r\n}\r\nfake_major = major;\r\nprintk(KERN_INFO "Setting extra ubd major number to %d\n",\r\nmajor);\r\nerr = 0;\r\nout1:\r\nmutex_unlock(&ubd_lock);\r\nreturn err;\r\n}\r\nn = parse_unit(&str);\r\nif(n < 0){\r\n*error_out = "Couldn't parse device number";\r\nreturn -EINVAL;\r\n}\r\nif(n >= MAX_DEV){\r\n*error_out = "Device number out of range";\r\nreturn 1;\r\n}\r\nerr = -EBUSY;\r\nmutex_lock(&ubd_lock);\r\nubd_dev = &ubd_devs[n];\r\nif(ubd_dev->file != NULL){\r\n*error_out = "Device is already configured";\r\ngoto out;\r\n}\r\nif (index_out)\r\n*index_out = n;\r\nerr = -EINVAL;\r\nfor (i = 0; i < sizeof("rscd="); i++) {\r\nswitch (*str) {\r\ncase 'r':\r\nflags.w = 0;\r\nbreak;\r\ncase 's':\r\nflags.s = 1;\r\nbreak;\r\ncase 'd':\r\nubd_dev->no_cow = 1;\r\nbreak;\r\ncase 'c':\r\nubd_dev->shared = 1;\r\nbreak;\r\ncase '=':\r\nstr++;\r\ngoto break_loop;\r\ndefault:\r\n*error_out = "Expected '=' or flag letter "\r\n"(r, s, c, or d)";\r\ngoto out;\r\n}\r\nstr++;\r\n}\r\nif (*str == '=')\r\n*error_out = "Too many flags specified";\r\nelse\r\n*error_out = "Missing '='";\r\ngoto out;\r\nbreak_loop:\r\nbacking_file = strchr(str, ',');\r\nif (backing_file == NULL)\r\nbacking_file = strchr(str, ':');\r\nif(backing_file != NULL){\r\nif(ubd_dev->no_cow){\r\n*error_out = "Can't specify both 'd' and a cow file";\r\ngoto out;\r\n}\r\nelse {\r\n*backing_file = '\0';\r\nbacking_file++;\r\n}\r\n}\r\nerr = 0;\r\nubd_dev->file = str;\r\nubd_dev->cow.file = backing_file;\r\nubd_dev->boot_openflags = flags;\r\nout:\r\nmutex_unlock(&ubd_lock);\r\nreturn err;\r\n}\r\nstatic int ubd_setup(char *str)\r\n{\r\nchar *error;\r\nint err;\r\nerr = ubd_setup_common(str, NULL, &error);\r\nif(err)\r\nprintk(KERN_ERR "Failed to initialize device with \"%s\" : "\r\n"%s\n", str, error);\r\nreturn 1;\r\n}\r\nstatic int udb_setup(char *str)\r\n{\r\nprintk("udb%s specified on command line is almost certainly a ubd -> "\r\n"udb TYPO\n", str);\r\nreturn 1;\r\n}\r\nstatic void ubd_handler(void)\r\n{\r\nstruct io_thread_req *req;\r\nstruct ubd *ubd;\r\nstruct list_head *list, *next_ele;\r\nunsigned long flags;\r\nint n;\r\nwhile(1){\r\nn = os_read_file(thread_fd, &req,\r\nsizeof(struct io_thread_req *));\r\nif(n != sizeof(req)){\r\nif(n == -EAGAIN)\r\nbreak;\r\nprintk(KERN_ERR "spurious interrupt in ubd_handler, "\r\n"err = %d\n", -n);\r\nreturn;\r\n}\r\nblk_end_request(req->req, 0, req->length);\r\nkfree(req);\r\n}\r\nreactivate_fd(thread_fd, UBD_IRQ);\r\nlist_for_each_safe(list, next_ele, &restart){\r\nubd = container_of(list, struct ubd, restart);\r\nlist_del_init(&ubd->restart);\r\nspin_lock_irqsave(&ubd->lock, flags);\r\ndo_ubd_request(ubd->queue);\r\nspin_unlock_irqrestore(&ubd->lock, flags);\r\n}\r\n}\r\nstatic irqreturn_t ubd_intr(int irq, void *dev)\r\n{\r\nubd_handler();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void kill_io_thread(void)\r\n{\r\nif(io_pid != -1)\r\nos_kill_process(io_pid, 1);\r\n}\r\nstatic inline int ubd_file_size(struct ubd *ubd_dev, __u64 *size_out)\r\n{\r\nchar *file;\r\nint fd;\r\nint err;\r\n__u32 version;\r\n__u32 align;\r\nchar *backing_file;\r\ntime_t mtime;\r\nunsigned long long size;\r\nint sector_size;\r\nint bitmap_offset;\r\nif (ubd_dev->file && ubd_dev->cow.file) {\r\nfile = ubd_dev->cow.file;\r\ngoto out;\r\n}\r\nfd = os_open_file(ubd_dev->file, global_openflags, 0);\r\nif (fd < 0)\r\nreturn fd;\r\nerr = read_cow_header(file_reader, &fd, &version, &backing_file, \\r\n&mtime, &size, &sector_size, &align, &bitmap_offset);\r\nos_close_file(fd);\r\nif(err == -EINVAL)\r\nfile = ubd_dev->file;\r\nelse\r\nfile = backing_file;\r\nout:\r\nreturn os_file_size(file, size_out);\r\n}\r\nstatic int read_cow_bitmap(int fd, void *buf, int offset, int len)\r\n{\r\nint err;\r\nerr = os_seek_file(fd, offset);\r\nif (err < 0)\r\nreturn err;\r\nerr = os_read_file(fd, buf, len);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int backing_file_mismatch(char *file, __u64 size, time_t mtime)\r\n{\r\nunsigned long modtime;\r\nunsigned long long actual;\r\nint err;\r\nerr = os_file_modtime(file, &modtime);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to get modification time of backing "\r\n"file \"%s\", err = %d\n", file, -err);\r\nreturn err;\r\n}\r\nerr = os_file_size(file, &actual);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to get size of backing file \"%s\", "\r\n"err = %d\n", file, -err);\r\nreturn err;\r\n}\r\nif (actual != size) {\r\nprintk(KERN_ERR "Size mismatch (%llu vs %llu) of COW header "\r\n"vs backing file\n", (unsigned long long) size, actual);\r\nreturn -EINVAL;\r\n}\r\nif (modtime != mtime) {\r\nprintk(KERN_ERR "mtime mismatch (%ld vs %ld) of COW header vs "\r\n"backing file\n", mtime, modtime);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int path_requires_switch(char *from_cmdline, char *from_cow, char *cow)\r\n{\r\nstruct uml_stat buf1, buf2;\r\nint err;\r\nif (from_cmdline == NULL)\r\nreturn 0;\r\nif (!strcmp(from_cmdline, from_cow))\r\nreturn 0;\r\nerr = os_stat_file(from_cmdline, &buf1);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Couldn't stat '%s', err = %d\n", from_cmdline,\r\n-err);\r\nreturn 0;\r\n}\r\nerr = os_stat_file(from_cow, &buf2);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Couldn't stat '%s', err = %d\n", from_cow,\r\n-err);\r\nreturn 1;\r\n}\r\nif ((buf1.ust_dev == buf2.ust_dev) && (buf1.ust_ino == buf2.ust_ino))\r\nreturn 0;\r\nprintk(KERN_ERR "Backing file mismatch - \"%s\" requested, "\r\n"\"%s\" specified in COW header of \"%s\"\n",\r\nfrom_cmdline, from_cow, cow);\r\nreturn 1;\r\n}\r\nstatic int open_ubd_file(char *file, struct openflags *openflags, int shared,\r\nchar **backing_file_out, int *bitmap_offset_out,\r\nunsigned long *bitmap_len_out, int *data_offset_out,\r\nint *create_cow_out)\r\n{\r\ntime_t mtime;\r\nunsigned long long size;\r\n__u32 version, align;\r\nchar *backing_file;\r\nint fd, err, sectorsize, asked_switch, mode = 0644;\r\nfd = os_open_file(file, *openflags, mode);\r\nif (fd < 0) {\r\nif ((fd == -ENOENT) && (create_cow_out != NULL))\r\n*create_cow_out = 1;\r\nif (!openflags->w ||\r\n((fd != -EROFS) && (fd != -EACCES)))\r\nreturn fd;\r\nopenflags->w = 0;\r\nfd = os_open_file(file, *openflags, mode);\r\nif (fd < 0)\r\nreturn fd;\r\n}\r\nif (shared)\r\nprintk(KERN_INFO "Not locking \"%s\" on the host\n", file);\r\nelse {\r\nerr = os_lock_file(fd, openflags->w);\r\nif (err < 0) {\r\nprintk(KERN_ERR "Failed to lock '%s', err = %d\n",\r\nfile, -err);\r\ngoto out_close;\r\n}\r\n}\r\nif (backing_file_out == NULL)\r\nreturn fd;\r\nerr = read_cow_header(file_reader, &fd, &version, &backing_file, &mtime,\r\n&size, &sectorsize, &align, bitmap_offset_out);\r\nif (err && (*backing_file_out != NULL)) {\r\nprintk(KERN_ERR "Failed to read COW header from COW file "\r\n"\"%s\", errno = %d\n", file, -err);\r\ngoto out_close;\r\n}\r\nif (err)\r\nreturn fd;\r\nasked_switch = path_requires_switch(*backing_file_out, backing_file,\r\nfile);\r\nif (asked_switch && !backing_file_mismatch(*backing_file_out, size,\r\nmtime)) {\r\nprintk(KERN_ERR "Switching backing file to '%s'\n",\r\n*backing_file_out);\r\nerr = write_cow_header(file, fd, *backing_file_out,\r\nsectorsize, align, &size);\r\nif (err) {\r\nprintk(KERN_ERR "Switch failed, errno = %d\n", -err);\r\ngoto out_close;\r\n}\r\n} else {\r\n*backing_file_out = backing_file;\r\nerr = backing_file_mismatch(*backing_file_out, size, mtime);\r\nif (err)\r\ngoto out_close;\r\n}\r\ncow_sizes(version, size, sectorsize, align, *bitmap_offset_out,\r\nbitmap_len_out, data_offset_out);\r\nreturn fd;\r\nout_close:\r\nos_close_file(fd);\r\nreturn err;\r\n}\r\nstatic int create_cow_file(char *cow_file, char *backing_file,\r\nstruct openflags flags,\r\nint sectorsize, int alignment, int *bitmap_offset_out,\r\nunsigned long *bitmap_len_out, int *data_offset_out)\r\n{\r\nint err, fd;\r\nflags.c = 1;\r\nfd = open_ubd_file(cow_file, &flags, 0, NULL, NULL, NULL, NULL, NULL);\r\nif (fd < 0) {\r\nerr = fd;\r\nprintk(KERN_ERR "Open of COW file '%s' failed, errno = %d\n",\r\ncow_file, -err);\r\ngoto out;\r\n}\r\nerr = init_cow_file(fd, cow_file, backing_file, sectorsize, alignment,\r\nbitmap_offset_out, bitmap_len_out,\r\ndata_offset_out);\r\nif (!err)\r\nreturn fd;\r\nos_close_file(fd);\r\nout:\r\nreturn err;\r\n}\r\nstatic void ubd_close_dev(struct ubd *ubd_dev)\r\n{\r\nos_close_file(ubd_dev->fd);\r\nif(ubd_dev->cow.file == NULL)\r\nreturn;\r\nos_close_file(ubd_dev->cow.fd);\r\nvfree(ubd_dev->cow.bitmap);\r\nubd_dev->cow.bitmap = NULL;\r\n}\r\nstatic int ubd_open_dev(struct ubd *ubd_dev)\r\n{\r\nstruct openflags flags;\r\nchar **back_ptr;\r\nint err, create_cow, *create_ptr;\r\nint fd;\r\nubd_dev->openflags = ubd_dev->boot_openflags;\r\ncreate_cow = 0;\r\ncreate_ptr = (ubd_dev->cow.file != NULL) ? &create_cow : NULL;\r\nback_ptr = ubd_dev->no_cow ? NULL : &ubd_dev->cow.file;\r\nfd = open_ubd_file(ubd_dev->file, &ubd_dev->openflags, ubd_dev->shared,\r\nback_ptr, &ubd_dev->cow.bitmap_offset,\r\n&ubd_dev->cow.bitmap_len, &ubd_dev->cow.data_offset,\r\ncreate_ptr);\r\nif((fd == -ENOENT) && create_cow){\r\nfd = create_cow_file(ubd_dev->file, ubd_dev->cow.file,\r\nubd_dev->openflags, 1 << 9, PAGE_SIZE,\r\n&ubd_dev->cow.bitmap_offset,\r\n&ubd_dev->cow.bitmap_len,\r\n&ubd_dev->cow.data_offset);\r\nif(fd >= 0){\r\nprintk(KERN_INFO "Creating \"%s\" as COW file for "\r\n"\"%s\"\n", ubd_dev->file, ubd_dev->cow.file);\r\n}\r\n}\r\nif(fd < 0){\r\nprintk("Failed to open '%s', errno = %d\n", ubd_dev->file,\r\n-fd);\r\nreturn fd;\r\n}\r\nubd_dev->fd = fd;\r\nif(ubd_dev->cow.file != NULL){\r\nblk_queue_max_hw_sectors(ubd_dev->queue, 8 * sizeof(long));\r\nerr = -ENOMEM;\r\nubd_dev->cow.bitmap = vmalloc(ubd_dev->cow.bitmap_len);\r\nif(ubd_dev->cow.bitmap == NULL){\r\nprintk(KERN_ERR "Failed to vmalloc COW bitmap\n");\r\ngoto error;\r\n}\r\nflush_tlb_kernel_vm();\r\nerr = read_cow_bitmap(ubd_dev->fd, ubd_dev->cow.bitmap,\r\nubd_dev->cow.bitmap_offset,\r\nubd_dev->cow.bitmap_len);\r\nif(err < 0)\r\ngoto error;\r\nflags = ubd_dev->openflags;\r\nflags.w = 0;\r\nerr = open_ubd_file(ubd_dev->cow.file, &flags, ubd_dev->shared, NULL,\r\nNULL, NULL, NULL, NULL);\r\nif(err < 0) goto error;\r\nubd_dev->cow.fd = err;\r\n}\r\nreturn 0;\r\nerror:\r\nos_close_file(ubd_dev->fd);\r\nreturn err;\r\n}\r\nstatic void ubd_device_release(struct device *dev)\r\n{\r\nstruct ubd *ubd_dev = dev_get_drvdata(dev);\r\nblk_cleanup_queue(ubd_dev->queue);\r\n*ubd_dev = ((struct ubd) DEFAULT_UBD);\r\n}\r\nstatic int ubd_disk_register(int major, u64 size, int unit,\r\nstruct gendisk **disk_out)\r\n{\r\nstruct gendisk *disk;\r\ndisk = alloc_disk(1 << UBD_SHIFT);\r\nif(disk == NULL)\r\nreturn -ENOMEM;\r\ndisk->major = major;\r\ndisk->first_minor = unit << UBD_SHIFT;\r\ndisk->fops = &ubd_blops;\r\nset_capacity(disk, size / 512);\r\nif (major == UBD_MAJOR)\r\nsprintf(disk->disk_name, "ubd%c", 'a' + unit);\r\nelse\r\nsprintf(disk->disk_name, "ubd_fake%d", unit);\r\nif (major == UBD_MAJOR) {\r\nubd_devs[unit].pdev.id = unit;\r\nubd_devs[unit].pdev.name = DRIVER_NAME;\r\nubd_devs[unit].pdev.dev.release = ubd_device_release;\r\ndev_set_drvdata(&ubd_devs[unit].pdev.dev, &ubd_devs[unit]);\r\nplatform_device_register(&ubd_devs[unit].pdev);\r\ndisk->driverfs_dev = &ubd_devs[unit].pdev.dev;\r\n}\r\ndisk->private_data = &ubd_devs[unit];\r\ndisk->queue = ubd_devs[unit].queue;\r\nadd_disk(disk);\r\n*disk_out = disk;\r\nreturn 0;\r\n}\r\nstatic int ubd_add(int n, char **error_out)\r\n{\r\nstruct ubd *ubd_dev = &ubd_devs[n];\r\nint err = 0;\r\nif(ubd_dev->file == NULL)\r\ngoto out;\r\nerr = ubd_file_size(ubd_dev, &ubd_dev->size);\r\nif(err < 0){\r\n*error_out = "Couldn't determine size of device's file";\r\ngoto out;\r\n}\r\nubd_dev->size = ROUND_BLOCK(ubd_dev->size);\r\nINIT_LIST_HEAD(&ubd_dev->restart);\r\nsg_init_table(ubd_dev->sg, MAX_SG);\r\nerr = -ENOMEM;\r\nubd_dev->queue = blk_init_queue(do_ubd_request, &ubd_dev->lock);\r\nif (ubd_dev->queue == NULL) {\r\n*error_out = "Failed to initialize device queue";\r\ngoto out;\r\n}\r\nubd_dev->queue->queuedata = ubd_dev;\r\nblk_queue_max_segments(ubd_dev->queue, MAX_SG);\r\nerr = ubd_disk_register(UBD_MAJOR, ubd_dev->size, n, &ubd_gendisk[n]);\r\nif(err){\r\n*error_out = "Failed to register device";\r\ngoto out_cleanup;\r\n}\r\nif (fake_major != UBD_MAJOR)\r\nubd_disk_register(fake_major, ubd_dev->size, n,\r\n&fake_gendisk[n]);\r\nif (fake_ide)\r\nmake_ide_entries(ubd_gendisk[n]->disk_name);\r\nerr = 0;\r\nout:\r\nreturn err;\r\nout_cleanup:\r\nblk_cleanup_queue(ubd_dev->queue);\r\ngoto out;\r\n}\r\nstatic int ubd_config(char *str, char **error_out)\r\n{\r\nint n, ret;\r\nstr = kstrdup(str, GFP_KERNEL);\r\nif (str == NULL) {\r\n*error_out = "Failed to allocate memory";\r\nreturn -ENOMEM;\r\n}\r\nret = ubd_setup_common(str, &n, error_out);\r\nif (ret)\r\ngoto err_free;\r\nif (n == -1) {\r\nret = 0;\r\ngoto err_free;\r\n}\r\nmutex_lock(&ubd_lock);\r\nret = ubd_add(n, error_out);\r\nif (ret)\r\nubd_devs[n].file = NULL;\r\nmutex_unlock(&ubd_lock);\r\nout:\r\nreturn ret;\r\nerr_free:\r\nkfree(str);\r\ngoto out;\r\n}\r\nstatic int ubd_get_config(char *name, char *str, int size, char **error_out)\r\n{\r\nstruct ubd *ubd_dev;\r\nint n, len = 0;\r\nn = parse_unit(&name);\r\nif((n >= MAX_DEV) || (n < 0)){\r\n*error_out = "ubd_get_config : device number out of range";\r\nreturn -1;\r\n}\r\nubd_dev = &ubd_devs[n];\r\nmutex_lock(&ubd_lock);\r\nif(ubd_dev->file == NULL){\r\nCONFIG_CHUNK(str, size, len, "", 1);\r\ngoto out;\r\n}\r\nCONFIG_CHUNK(str, size, len, ubd_dev->file, 0);\r\nif(ubd_dev->cow.file != NULL){\r\nCONFIG_CHUNK(str, size, len, ",", 0);\r\nCONFIG_CHUNK(str, size, len, ubd_dev->cow.file, 1);\r\n}\r\nelse CONFIG_CHUNK(str, size, len, "", 1);\r\nout:\r\nmutex_unlock(&ubd_lock);\r\nreturn len;\r\n}\r\nstatic int ubd_id(char **str, int *start_out, int *end_out)\r\n{\r\nint n;\r\nn = parse_unit(str);\r\n*start_out = 0;\r\n*end_out = MAX_DEV - 1;\r\nreturn n;\r\n}\r\nstatic int ubd_remove(int n, char **error_out)\r\n{\r\nstruct gendisk *disk = ubd_gendisk[n];\r\nstruct ubd *ubd_dev;\r\nint err = -ENODEV;\r\nmutex_lock(&ubd_lock);\r\nubd_dev = &ubd_devs[n];\r\nif(ubd_dev->file == NULL)\r\ngoto out;\r\nerr = -EBUSY;\r\nif(ubd_dev->count > 0)\r\ngoto out;\r\nubd_gendisk[n] = NULL;\r\nif(disk != NULL){\r\ndel_gendisk(disk);\r\nput_disk(disk);\r\n}\r\nif(fake_gendisk[n] != NULL){\r\ndel_gendisk(fake_gendisk[n]);\r\nput_disk(fake_gendisk[n]);\r\nfake_gendisk[n] = NULL;\r\n}\r\nerr = 0;\r\nplatform_device_unregister(&ubd_dev->pdev);\r\nout:\r\nmutex_unlock(&ubd_lock);\r\nreturn err;\r\n}\r\nstatic int __init ubd_mc_init(void)\r\n{\r\nmconsole_register_dev(&ubd_mc);\r\nreturn 0;\r\n}\r\nstatic int __init ubd0_init(void)\r\n{\r\nstruct ubd *ubd_dev = &ubd_devs[0];\r\nmutex_lock(&ubd_lock);\r\nif(ubd_dev->file == NULL)\r\nubd_dev->file = "root_fs";\r\nmutex_unlock(&ubd_lock);\r\nreturn 0;\r\n}\r\nstatic int __init ubd_init(void)\r\n{\r\nchar *error;\r\nint i, err;\r\nif (register_blkdev(UBD_MAJOR, "ubd"))\r\nreturn -1;\r\nif (fake_major != UBD_MAJOR) {\r\nchar name[sizeof("ubd_nnn\0")];\r\nsnprintf(name, sizeof(name), "ubd_%d", fake_major);\r\nif (register_blkdev(fake_major, "ubd"))\r\nreturn -1;\r\n}\r\nplatform_driver_register(&ubd_driver);\r\nmutex_lock(&ubd_lock);\r\nfor (i = 0; i < MAX_DEV; i++){\r\nerr = ubd_add(i, &error);\r\nif(err)\r\nprintk(KERN_ERR "Failed to initialize ubd device %d :"\r\n"%s\n", i, error);\r\n}\r\nmutex_unlock(&ubd_lock);\r\nreturn 0;\r\n}\r\nstatic int __init ubd_driver_init(void){\r\nunsigned long stack;\r\nint err;\r\nif(global_openflags.s){\r\nprintk(KERN_INFO "ubd: Synchronous mode\n");\r\n}\r\nstack = alloc_stack(0, 0);\r\nio_pid = start_io_thread(stack + PAGE_SIZE - sizeof(void *),\r\n&thread_fd);\r\nif(io_pid < 0){\r\nprintk(KERN_ERR\r\n"ubd : Failed to start I/O thread (errno = %d) - "\r\n"falling back to synchronous I/O\n", -io_pid);\r\nio_pid = -1;\r\nreturn 0;\r\n}\r\nerr = um_request_irq(UBD_IRQ, thread_fd, IRQ_READ, ubd_intr,\r\n0, "ubd", ubd_devs);\r\nif(err != 0)\r\nprintk(KERN_ERR "um_request_irq failed - errno = %d\n", -err);\r\nreturn 0;\r\n}\r\nstatic int ubd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nstruct ubd *ubd_dev = disk->private_data;\r\nint err = 0;\r\nmutex_lock(&ubd_mutex);\r\nif(ubd_dev->count == 0){\r\nerr = ubd_open_dev(ubd_dev);\r\nif(err){\r\nprintk(KERN_ERR "%s: Can't open \"%s\": errno = %d\n",\r\ndisk->disk_name, ubd_dev->file, -err);\r\ngoto out;\r\n}\r\n}\r\nubd_dev->count++;\r\nset_disk_ro(disk, !ubd_dev->openflags.w);\r\nout:\r\nmutex_unlock(&ubd_mutex);\r\nreturn err;\r\n}\r\nstatic int ubd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct ubd *ubd_dev = disk->private_data;\r\nmutex_lock(&ubd_mutex);\r\nif(--ubd_dev->count == 0)\r\nubd_close_dev(ubd_dev);\r\nmutex_unlock(&ubd_mutex);\r\nreturn 0;\r\n}\r\nstatic void cowify_bitmap(__u64 io_offset, int length, unsigned long *cow_mask,\r\n__u64 *cow_offset, unsigned long *bitmap,\r\n__u64 bitmap_offset, unsigned long *bitmap_words,\r\n__u64 bitmap_len)\r\n{\r\n__u64 sector = io_offset >> 9;\r\nint i, update_bitmap = 0;\r\nfor(i = 0; i < length >> 9; i++){\r\nif(cow_mask != NULL)\r\nubd_set_bit(i, (unsigned char *) cow_mask);\r\nif(ubd_test_bit(sector + i, (unsigned char *) bitmap))\r\ncontinue;\r\nupdate_bitmap = 1;\r\nubd_set_bit(sector + i, (unsigned char *) bitmap);\r\n}\r\nif(!update_bitmap)\r\nreturn;\r\n*cow_offset = sector / (sizeof(unsigned long) * 8);\r\nif (*cow_offset == (DIV_ROUND_UP(bitmap_len,\r\nsizeof(unsigned long)) - 1))\r\n(*cow_offset)--;\r\nbitmap_words[0] = bitmap[*cow_offset];\r\nbitmap_words[1] = bitmap[*cow_offset + 1];\r\n*cow_offset *= sizeof(unsigned long);\r\n*cow_offset += bitmap_offset;\r\n}\r\nstatic void cowify_req(struct io_thread_req *req, unsigned long *bitmap,\r\n__u64 bitmap_offset, __u64 bitmap_len)\r\n{\r\n__u64 sector = req->offset >> 9;\r\nint i;\r\nif(req->length > (sizeof(req->sector_mask) * 8) << 9)\r\npanic("Operation too long");\r\nif(req->op == UBD_READ) {\r\nfor(i = 0; i < req->length >> 9; i++){\r\nif(ubd_test_bit(sector + i, (unsigned char *) bitmap))\r\nubd_set_bit(i, (unsigned char *)\r\n&req->sector_mask);\r\n}\r\n}\r\nelse cowify_bitmap(req->offset, req->length, &req->sector_mask,\r\n&req->cow_offset, bitmap, bitmap_offset,\r\nreq->bitmap_words, bitmap_len);\r\n}\r\nstatic void prepare_request(struct request *req, struct io_thread_req *io_req,\r\nunsigned long long offset, int page_offset,\r\nint len, struct page *page)\r\n{\r\nstruct gendisk *disk = req->rq_disk;\r\nstruct ubd *ubd_dev = disk->private_data;\r\nio_req->req = req;\r\nio_req->fds[0] = (ubd_dev->cow.file != NULL) ? ubd_dev->cow.fd :\r\nubd_dev->fd;\r\nio_req->fds[1] = ubd_dev->fd;\r\nio_req->cow_offset = -1;\r\nio_req->offset = offset;\r\nio_req->length = len;\r\nio_req->error = 0;\r\nio_req->sector_mask = 0;\r\nio_req->op = (rq_data_dir(req) == READ) ? UBD_READ : UBD_WRITE;\r\nio_req->offsets[0] = 0;\r\nio_req->offsets[1] = ubd_dev->cow.data_offset;\r\nio_req->buffer = page_address(page) + page_offset;\r\nio_req->sectorsize = 1 << 9;\r\nif(ubd_dev->cow.file != NULL)\r\ncowify_req(io_req, ubd_dev->cow.bitmap,\r\nubd_dev->cow.bitmap_offset, ubd_dev->cow.bitmap_len);\r\n}\r\nstatic void do_ubd_request(struct request_queue *q)\r\n{\r\nstruct io_thread_req *io_req;\r\nstruct request *req;\r\nint n;\r\nwhile(1){\r\nstruct ubd *dev = q->queuedata;\r\nif(dev->end_sg == 0){\r\nstruct request *req = blk_fetch_request(q);\r\nif(req == NULL)\r\nreturn;\r\ndev->request = req;\r\ndev->rq_pos = blk_rq_pos(req);\r\ndev->start_sg = 0;\r\ndev->end_sg = blk_rq_map_sg(q, req, dev->sg);\r\n}\r\nreq = dev->request;\r\nwhile(dev->start_sg < dev->end_sg){\r\nstruct scatterlist *sg = &dev->sg[dev->start_sg];\r\nio_req = kmalloc(sizeof(struct io_thread_req),\r\nGFP_ATOMIC);\r\nif(io_req == NULL){\r\nif(list_empty(&dev->restart))\r\nlist_add(&dev->restart, &restart);\r\nreturn;\r\n}\r\nprepare_request(req, io_req,\r\n(unsigned long long)dev->rq_pos << 9,\r\nsg->offset, sg->length, sg_page(sg));\r\nn = os_write_file(thread_fd, &io_req,\r\nsizeof(struct io_thread_req *));\r\nif(n != sizeof(struct io_thread_req *)){\r\nif(n != -EAGAIN)\r\nprintk("write to io thread failed, "\r\n"errno = %d\n", -n);\r\nelse if(list_empty(&dev->restart))\r\nlist_add(&dev->restart, &restart);\r\nkfree(io_req);\r\nreturn;\r\n}\r\ndev->rq_pos += sg->length >> 9;\r\ndev->start_sg++;\r\n}\r\ndev->end_sg = 0;\r\ndev->request = NULL;\r\n}\r\n}\r\nstatic int ubd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct ubd *ubd_dev = bdev->bd_disk->private_data;\r\ngeo->heads = 128;\r\ngeo->sectors = 32;\r\ngeo->cylinders = ubd_dev->size / (128 * 32 * 512);\r\nreturn 0;\r\n}\r\nstatic int ubd_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ubd *ubd_dev = bdev->bd_disk->private_data;\r\nu16 ubd_id[ATA_ID_WORDS];\r\nswitch (cmd) {\r\nstruct cdrom_volctrl volume;\r\ncase HDIO_GET_IDENTITY:\r\nmemset(&ubd_id, 0, ATA_ID_WORDS * 2);\r\nubd_id[ATA_ID_CYLS] = ubd_dev->size / (128 * 32 * 512);\r\nubd_id[ATA_ID_HEADS] = 128;\r\nubd_id[ATA_ID_SECTORS] = 32;\r\nif(copy_to_user((char __user *) arg, (char *) &ubd_id,\r\nsizeof(ubd_id)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase CDROMVOLREAD:\r\nif(copy_from_user(&volume, (char __user *) arg, sizeof(volume)))\r\nreturn -EFAULT;\r\nvolume.channel0 = 255;\r\nvolume.channel1 = 255;\r\nvolume.channel2 = 255;\r\nvolume.channel3 = 255;\r\nif(copy_to_user((char __user *) arg, &volume, sizeof(volume)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int update_bitmap(struct io_thread_req *req)\r\n{\r\nint n;\r\nif(req->cow_offset == -1)\r\nreturn 0;\r\nn = os_seek_file(req->fds[1], req->cow_offset);\r\nif(n < 0){\r\nprintk("do_io - bitmap lseek failed : err = %d\n", -n);\r\nreturn 1;\r\n}\r\nn = os_write_file(req->fds[1], &req->bitmap_words,\r\nsizeof(req->bitmap_words));\r\nif(n != sizeof(req->bitmap_words)){\r\nprintk("do_io - bitmap update failed, err = %d fd = %d\n", -n,\r\nreq->fds[1]);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void do_io(struct io_thread_req *req)\r\n{\r\nchar *buf;\r\nunsigned long len;\r\nint n, nsectors, start, end, bit;\r\nint err;\r\n__u64 off;\r\nnsectors = req->length / req->sectorsize;\r\nstart = 0;\r\ndo {\r\nbit = ubd_test_bit(start, (unsigned char *) &req->sector_mask);\r\nend = start;\r\nwhile((end < nsectors) &&\r\n(ubd_test_bit(end, (unsigned char *)\r\n&req->sector_mask) == bit))\r\nend++;\r\noff = req->offset + req->offsets[bit] +\r\nstart * req->sectorsize;\r\nlen = (end - start) * req->sectorsize;\r\nbuf = &req->buffer[start * req->sectorsize];\r\nerr = os_seek_file(req->fds[bit], off);\r\nif(err < 0){\r\nprintk("do_io - lseek failed : err = %d\n", -err);\r\nreq->error = 1;\r\nreturn;\r\n}\r\nif(req->op == UBD_READ){\r\nn = 0;\r\ndo {\r\nbuf = &buf[n];\r\nlen -= n;\r\nn = os_read_file(req->fds[bit], buf, len);\r\nif (n < 0) {\r\nprintk("do_io - read failed, err = %d "\r\n"fd = %d\n", -n, req->fds[bit]);\r\nreq->error = 1;\r\nreturn;\r\n}\r\n} while((n < len) && (n != 0));\r\nif (n < len) memset(&buf[n], 0, len - n);\r\n} else {\r\nn = os_write_file(req->fds[bit], buf, len);\r\nif(n != len){\r\nprintk("do_io - write failed err = %d "\r\n"fd = %d\n", -n, req->fds[bit]);\r\nreq->error = 1;\r\nreturn;\r\n}\r\n}\r\nstart = end;\r\n} while(start < nsectors);\r\nreq->error = update_bitmap(req);\r\n}\r\nint io_thread(void *arg)\r\n{\r\nstruct io_thread_req *req;\r\nint n;\r\nignore_sigwinch_sig();\r\nwhile(1){\r\nn = os_read_file(kernel_fd, &req,\r\nsizeof(struct io_thread_req *));\r\nif(n != sizeof(struct io_thread_req *)){\r\nif(n < 0)\r\nprintk("io_thread - read failed, fd = %d, "\r\n"err = %d\n", kernel_fd, -n);\r\nelse {\r\nprintk("io_thread - short read, fd = %d, "\r\n"length = %d\n", kernel_fd, n);\r\n}\r\ncontinue;\r\n}\r\nio_count++;\r\ndo_io(req);\r\nn = os_write_file(kernel_fd, &req,\r\nsizeof(struct io_thread_req *));\r\nif(n != sizeof(struct io_thread_req *))\r\nprintk("io_thread - write failed, fd = %d, err = %d\n",\r\nkernel_fd, -n);\r\n}\r\nreturn 0;\r\n}
