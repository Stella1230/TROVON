void __init m68k_setup_node(int node)\r\n{\r\n#ifndef CONFIG_SINGLE_MEMORY_CHUNK\r\nstruct mem_info *info = m68k_memory + node;\r\nint i, end;\r\ni = (unsigned long)phys_to_virt(info->addr) >> __virt_to_node_shift();\r\nend = (unsigned long)phys_to_virt(info->addr + info->size - 1) >> __virt_to_node_shift();\r\nfor (; i <= end; i++) {\r\nif (pg_data_table[i])\r\nprintk("overlap at %u for chunk %u\n", i, node);\r\npg_data_table[i] = pg_data_map + node;\r\n}\r\n#endif\r\npg_data_map[node].bdata = bootmem_node_data + node;\r\nnode_set_online(node);\r\n}\r\nvoid __init print_memmap(void)\r\n{\r\n#define UL(x) ((unsigned long) (x))\r\n#define MLK(b, t) UL(b), UL(t), (UL(t) - UL(b)) >> 10\r\n#define MLM(b, t) UL(b), UL(t), (UL(t) - UL(b)) >> 20\r\n#define MLK_ROUNDUP(b, t) b, t, DIV_ROUND_UP(((t) - (b)), 1024)\r\npr_notice("Virtual kernel memory layout:\n"\r\n" vector : 0x%08lx - 0x%08lx (%4ld KiB)\n"\r\n" kmap : 0x%08lx - 0x%08lx (%4ld MiB)\n"\r\n" vmalloc : 0x%08lx - 0x%08lx (%4ld MiB)\n"\r\n" lowmem : 0x%08lx - 0x%08lx (%4ld MiB)\n"\r\n" .init : 0x%p" " - 0x%p" " (%4d KiB)\n"\r\n" .text : 0x%p" " - 0x%p" " (%4d KiB)\n"\r\n" .data : 0x%p" " - 0x%p" " (%4d KiB)\n"\r\n" .bss : 0x%p" " - 0x%p" " (%4d KiB)\n",\r\nMLK(VECTORS, VECTORS + 256),\r\nMLM(KMAP_START, KMAP_END),\r\nMLM(VMALLOC_START, VMALLOC_END),\r\nMLM(PAGE_OFFSET, (unsigned long)high_memory),\r\nMLK_ROUNDUP(__init_begin, __init_end),\r\nMLK_ROUNDUP(_stext, _etext),\r\nMLK_ROUNDUP(_sdata, _edata),\r\nMLK_ROUNDUP(_sbss, _ebss));\r\n}\r\nvoid __init mem_init(void)\r\n{\r\npg_data_t *pgdat;\r\nint codepages = 0;\r\nint datapages = 0;\r\nint initpages = 0;\r\nint i;\r\ntotalram_pages = num_physpages = 0;\r\nfor_each_online_pgdat(pgdat) {\r\nnum_physpages += pgdat->node_present_pages;\r\ntotalram_pages += free_all_bootmem_node(pgdat);\r\nfor (i = 0; i < pgdat->node_spanned_pages; i++) {\r\nstruct page *page = pgdat->node_mem_map + i;\r\nchar *addr = page_to_virt(page);\r\nif (!PageReserved(page))\r\ncontinue;\r\nif (addr >= _text &&\r\naddr < _etext)\r\ncodepages++;\r\nelse if (addr >= __init_begin &&\r\naddr < __init_end)\r\ninitpages++;\r\nelse\r\ndatapages++;\r\n}\r\n}\r\n#if !defined(CONFIG_SUN3) && !defined(CONFIG_COLDFIRE)\r\ninit_pointer_table((unsigned long)kernel_pg_dir);\r\nfor (i = 0; i < PTRS_PER_PGD; i++) {\r\nif (pgd_present(kernel_pg_dir[i]))\r\ninit_pointer_table(__pgd_page(kernel_pg_dir[i]));\r\n}\r\nif (zero_pgtable)\r\ninit_pointer_table((unsigned long)zero_pgtable);\r\n#endif\r\nprintk("Memory: %luk/%luk available (%dk kernel code, %dk data, %dk init)\n",\r\nnr_free_pages() << (PAGE_SHIFT-10),\r\ntotalram_pages << (PAGE_SHIFT-10),\r\ncodepages << (PAGE_SHIFT-10),\r\ndatapages << (PAGE_SHIFT-10),\r\ninitpages << (PAGE_SHIFT-10));\r\nprint_memmap();\r\n}\r\nvoid free_initrd_mem(unsigned long start, unsigned long end)\r\n{\r\nint pages = 0;\r\nfor (; start < end; start += PAGE_SIZE) {\r\nClearPageReserved(virt_to_page(start));\r\ninit_page_count(virt_to_page(start));\r\nfree_page(start);\r\ntotalram_pages++;\r\npages++;\r\n}\r\nprintk ("Freeing initrd memory: %dk freed\n", pages);\r\n}
