static void snd_sb16_csp_playback_prepare(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\r\n{\r\nif (chip->hardware == SB_HW_16CSP) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\r\nif ((csp->mode & SNDRV_SB_CSP_MODE_DSP_WRITE) &&\r\n((1U << runtime->format) == csp->acc_format)) {\r\nif (csp->ops.csp_use(csp) == 0) {\r\ngoto __start_CSP;\r\n}\r\n} else if ((csp->mode & SNDRV_SB_CSP_MODE_QSOUND) && (csp->q_enabled)) {\r\nif ((1 << runtime->format) & (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\r\nSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE)) {\r\nif (csp->ops.csp_use(csp) == 0) {\r\ngoto __start_CSP;\r\n}\r\n}\r\n}\r\n} else if (csp->ops.csp_use(csp) == 0) {\r\nif (csp->ops.csp_autoload(csp, runtime->format, SNDRV_SB_CSP_MODE_DSP_WRITE)) {\r\ncsp->ops.csp_unuse(csp);\r\n} else {\r\n__start_CSP:\r\nif (csp->ops.csp_start(csp, (chip->mode & SB_MODE_PLAYBACK_16) ?\r\nSNDRV_SB_CSP_SAMPLE_16BIT : SNDRV_SB_CSP_SAMPLE_8BIT,\r\n(runtime->channels > 1) ?\r\nSNDRV_SB_CSP_STEREO : SNDRV_SB_CSP_MONO)) {\r\ncsp->ops.csp_unuse(csp);\r\n} else {\r\nchip->open = SNDRV_SB_CSP_MODE_DSP_WRITE;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_csp_capture_prepare(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\r\n{\r\nif (chip->hardware == SB_HW_16CSP) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\r\nif ((csp->mode & SNDRV_SB_CSP_MODE_DSP_READ) &&\r\n((1U << runtime->format) == csp->acc_format)) {\r\nif (csp->ops.csp_use(csp) == 0) {\r\ngoto __start_CSP;\r\n}\r\n}\r\n} else if (csp->ops.csp_use(csp) == 0) {\r\nif (csp->ops.csp_autoload(csp, runtime->format, SNDRV_SB_CSP_MODE_DSP_READ)) {\r\ncsp->ops.csp_unuse(csp);\r\n} else {\r\n__start_CSP:\r\nif (csp->ops.csp_start(csp, (chip->mode & SB_MODE_CAPTURE_16) ?\r\nSNDRV_SB_CSP_SAMPLE_16BIT : SNDRV_SB_CSP_SAMPLE_8BIT,\r\n(runtime->channels > 1) ?\r\nSNDRV_SB_CSP_STEREO : SNDRV_SB_CSP_MONO)) {\r\ncsp->ops.csp_unuse(csp);\r\n} else {\r\nchip->open = SNDRV_SB_CSP_MODE_DSP_READ;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_csp_update(struct snd_sb *chip)\r\n{\r\nif (chip->hardware == SB_HW_16CSP) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->qpos_changed) {\r\nspin_lock(&chip->reg_lock);\r\ncsp->ops.csp_qsound_transfer (csp);\r\nspin_unlock(&chip->reg_lock);\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_csp_playback_open(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\r\n{\r\nif (chip->hardware == SB_HW_16CSP) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\r\nif (csp->mode & SNDRV_SB_CSP_MODE_DSP_WRITE) {\r\nruntime->hw.formats |= csp->acc_format;\r\n}\r\n} else {\r\nruntime->hw.formats |= SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW |\r\nSNDRV_PCM_FMTBIT_IMA_ADPCM;\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_csp_playback_close(struct snd_sb *chip)\r\n{\r\nif ((chip->hardware == SB_HW_16CSP) && (chip->open == SNDRV_SB_CSP_MODE_DSP_WRITE)) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->ops.csp_stop(csp) == 0) {\r\ncsp->ops.csp_unuse(csp);\r\nchip->open = 0;\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_csp_capture_open(struct snd_sb *chip, struct snd_pcm_runtime *runtime)\r\n{\r\nif (chip->hardware == SB_HW_16CSP) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->running & SNDRV_SB_CSP_ST_LOADED) {\r\nif (csp->mode & SNDRV_SB_CSP_MODE_DSP_READ) {\r\nruntime->hw.formats |= csp->acc_format;\r\n}\r\n} else {\r\nruntime->hw.formats |= SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW |\r\nSNDRV_PCM_FMTBIT_IMA_ADPCM;\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_csp_capture_close(struct snd_sb *chip)\r\n{\r\nif ((chip->hardware == SB_HW_16CSP) && (chip->open == SNDRV_SB_CSP_MODE_DSP_READ)) {\r\nstruct snd_sb_csp *csp = chip->csp;\r\nif (csp->ops.csp_stop(csp) == 0) {\r\ncsp->ops.csp_unuse(csp);\r\nchip->open = 0;\r\n}\r\n}\r\n}\r\nstatic void snd_sb16_setup_rate(struct snd_sb *chip,\r\nunsigned short rate,\r\nint channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->mode & (channel == SNDRV_PCM_STREAM_PLAYBACK ? SB_MODE_PLAYBACK_16 : SB_MODE_CAPTURE_16))\r\nsnd_sb_ack_16bit(chip);\r\nelse\r\nsnd_sb_ack_8bit(chip);\r\nif (!(chip->mode & SB_RATE_LOCK)) {\r\nchip->locked_rate = rate;\r\nsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_IN);\r\nsnd_sbdsp_command(chip, rate >> 8);\r\nsnd_sbdsp_command(chip, rate & 0xff);\r\nsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_OUT);\r\nsnd_sbdsp_command(chip, rate >> 8);\r\nsnd_sbdsp_command(chip, rate & 0xff);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic int snd_sb16_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_sb16_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned char format;\r\nunsigned int size, count, dma;\r\nsnd_sb16_csp_playback_prepare(chip, runtime);\r\nif (snd_pcm_format_unsigned(runtime->format) > 0) {\r\nformat = runtime->channels > 1 ? SB_DSP4_MODE_UNS_STEREO : SB_DSP4_MODE_UNS_MONO;\r\n} else {\r\nformat = runtime->channels > 1 ? SB_DSP4_MODE_SIGN_STEREO : SB_DSP4_MODE_SIGN_MONO;\r\n}\r\nsnd_sb16_setup_rate(chip, runtime->rate, SNDRV_PCM_STREAM_PLAYBACK);\r\nsize = chip->p_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\ndma = (chip->mode & SB_MODE_PLAYBACK_8) ? chip->dma8 : chip->dma16;\r\nsnd_dma_program(dma, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\r\ncount = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->mode & SB_MODE_PLAYBACK_16) {\r\ncount >>= 1;\r\ncount--;\r\nsnd_sbdsp_command(chip, SB_DSP4_OUT16_AI);\r\nsnd_sbdsp_command(chip, format);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\nsnd_sbdsp_command(chip, SB_DSP_DMA16_OFF);\r\n} else {\r\ncount--;\r\nsnd_sbdsp_command(chip, SB_DSP4_OUT8_AI);\r\nsnd_sbdsp_command(chip, format);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\nsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->mode |= SB_RATE_LOCK_PLAYBACK;\r\nsnd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nsnd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_OFF : SB_DSP_DMA8_OFF);\r\nif (chip->mode & SB_RATE_LOCK_CAPTURE)\r\nsnd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\r\nchip->mode &= ~SB_RATE_LOCK_PLAYBACK;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn result;\r\n}\r\nstatic int snd_sb16_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned char format;\r\nunsigned int size, count, dma;\r\nsnd_sb16_csp_capture_prepare(chip, runtime);\r\nif (snd_pcm_format_unsigned(runtime->format) > 0) {\r\nformat = runtime->channels > 1 ? SB_DSP4_MODE_UNS_STEREO : SB_DSP4_MODE_UNS_MONO;\r\n} else {\r\nformat = runtime->channels > 1 ? SB_DSP4_MODE_SIGN_STEREO : SB_DSP4_MODE_SIGN_MONO;\r\n}\r\nsnd_sb16_setup_rate(chip, runtime->rate, SNDRV_PCM_STREAM_CAPTURE);\r\nsize = chip->c_dma_size = snd_pcm_lib_buffer_bytes(substream);\r\ndma = (chip->mode & SB_MODE_CAPTURE_8) ? chip->dma8 : chip->dma16;\r\nsnd_dma_program(dma, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\r\ncount = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->mode & SB_MODE_CAPTURE_16) {\r\ncount >>= 1;\r\ncount--;\r\nsnd_sbdsp_command(chip, SB_DSP4_IN16_AI);\r\nsnd_sbdsp_command(chip, format);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\nsnd_sbdsp_command(chip, SB_DSP_DMA16_OFF);\r\n} else {\r\ncount--;\r\nsnd_sbdsp_command(chip, SB_DSP4_IN8_AI);\r\nsnd_sbdsp_command(chip, format);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\nsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->mode |= SB_RATE_LOCK_CAPTURE;\r\nsnd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nsnd_sbdsp_command(chip, chip->mode & SB_MODE_CAPTURE_16 ? SB_DSP_DMA16_OFF : SB_DSP_DMA8_OFF);\r\nif (chip->mode & SB_RATE_LOCK_PLAYBACK)\r\nsnd_sbdsp_command(chip, chip->mode & SB_MODE_PLAYBACK_16 ? SB_DSP_DMA16_ON : SB_DSP_DMA8_ON);\r\nchip->mode &= ~SB_RATE_LOCK_CAPTURE;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn result;\r\n}\r\nirqreturn_t snd_sb16dsp_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_sb *chip = dev_id;\r\nunsigned char status;\r\nint ok;\r\nspin_lock(&chip->mixer_lock);\r\nstatus = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);\r\nspin_unlock(&chip->mixer_lock);\r\nif ((status & SB_IRQTYPE_MPUIN) && chip->rmidi_callback)\r\nchip->rmidi_callback(irq, chip->rmidi->private_data);\r\nif (status & SB_IRQTYPE_8BIT) {\r\nok = 0;\r\nif (chip->mode & SB_MODE_PLAYBACK_8) {\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nsnd_sb16_csp_update(chip);\r\nok++;\r\n}\r\nif (chip->mode & SB_MODE_CAPTURE_8) {\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nok++;\r\n}\r\nspin_lock(&chip->reg_lock);\r\nif (!ok)\r\nsnd_sbdsp_command(chip, SB_DSP_DMA8_OFF);\r\nsnd_sb_ack_8bit(chip);\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nif (status & SB_IRQTYPE_16BIT) {\r\nok = 0;\r\nif (chip->mode & SB_MODE_PLAYBACK_16) {\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nsnd_sb16_csp_update(chip);\r\nok++;\r\n}\r\nif (chip->mode & SB_MODE_CAPTURE_16) {\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nok++;\r\n}\r\nspin_lock(&chip->reg_lock);\r\nif (!ok)\r\nsnd_sbdsp_command(chip, SB_DSP_DMA16_OFF);\r\nsnd_sb_ack_16bit(chip);\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_sb16_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nunsigned int dma;\r\nsize_t ptr;\r\ndma = (chip->mode & SB_MODE_PLAYBACK_8) ? chip->dma8 : chip->dma16;\r\nptr = snd_dma_pointer(dma, chip->p_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_sb16_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nunsigned int dma;\r\nsize_t ptr;\r\ndma = (chip->mode & SB_MODE_CAPTURE_8) ? chip->dma8 : chip->dma16;\r\nptr = snd_dma_pointer(dma, chip->c_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_sb16_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irqsave(&chip->open_lock, flags);\r\nif (chip->mode & SB_MODE_PLAYBACK) {\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nruntime->hw = snd_sb16_playback;\r\nif (chip->force_mode16 & SB_MODE_CAPTURE_16)\r\ngoto __skip_16bit;\r\nif (chip->dma16 >= 0 && !(chip->mode & SB_MODE_CAPTURE_16)) {\r\nchip->mode |= SB_MODE_PLAYBACK_16;\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\r\nif (chip->dma16 <= 3) {\r\nruntime->hw.buffer_bytes_max =\r\nruntime->hw.period_bytes_max = 64 * 1024;\r\n} else {\r\nsnd_sb16_csp_playback_open(chip, runtime);\r\n}\r\ngoto __open_ok;\r\n}\r\n__skip_16bit:\r\nif (chip->dma8 >= 0 && !(chip->mode & SB_MODE_CAPTURE_8)) {\r\nchip->mode |= SB_MODE_PLAYBACK_8;\r\nif (chip->dma16 < 0) {\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\r\nchip->mode |= SB_MODE_PLAYBACK_16;\r\n} else {\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8;\r\n}\r\nruntime->hw.buffer_bytes_max =\r\nruntime->hw.period_bytes_max = 64 * 1024;\r\ngoto __open_ok;\r\n}\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn -EAGAIN;\r\n__open_ok:\r\nif (chip->hardware == SB_HW_ALS100)\r\nruntime->hw.rate_max = 48000;\r\nif (chip->hardware == SB_HW_CS5530) {\r\nruntime->hw.buffer_bytes_max = 32 * 1024;\r\nruntime->hw.periods_min = 2;\r\nruntime->hw.rate_min = 44100;\r\n}\r\nif (chip->mode & SB_RATE_LOCK)\r\nruntime->hw.rate_min = runtime->hw.rate_max = chip->locked_rate;\r\nchip->playback_substream = substream;\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nsnd_sb16_csp_playback_close(chip);\r\nspin_lock_irqsave(&chip->open_lock, flags);\r\nchip->playback_substream = NULL;\r\nchip->mode &= ~SB_MODE_PLAYBACK;\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irqsave(&chip->open_lock, flags);\r\nif (chip->mode & SB_MODE_CAPTURE) {\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nruntime->hw = snd_sb16_capture;\r\nif (chip->force_mode16 & SB_MODE_PLAYBACK_16)\r\ngoto __skip_16bit;\r\nif (chip->dma16 >= 0 && !(chip->mode & SB_MODE_PLAYBACK_16)) {\r\nchip->mode |= SB_MODE_CAPTURE_16;\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\r\nif (chip->dma16 <= 3) {\r\nruntime->hw.buffer_bytes_max =\r\nruntime->hw.period_bytes_max = 64 * 1024;\r\n} else {\r\nsnd_sb16_csp_capture_open(chip, runtime);\r\n}\r\ngoto __open_ok;\r\n}\r\n__skip_16bit:\r\nif (chip->dma8 >= 0 && !(chip->mode & SB_MODE_PLAYBACK_8)) {\r\nchip->mode |= SB_MODE_CAPTURE_8;\r\nif (chip->dma16 < 0) {\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE;\r\nchip->mode |= SB_MODE_CAPTURE_16;\r\n} else {\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S8;\r\n}\r\nruntime->hw.buffer_bytes_max =\r\nruntime->hw.period_bytes_max = 64 * 1024;\r\ngoto __open_ok;\r\n}\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn -EAGAIN;\r\n__open_ok:\r\nif (chip->hardware == SB_HW_ALS100)\r\nruntime->hw.rate_max = 48000;\r\nif (chip->hardware == SB_HW_CS5530) {\r\nruntime->hw.buffer_bytes_max = 32 * 1024;\r\nruntime->hw.periods_min = 2;\r\nruntime->hw.rate_min = 44100;\r\n}\r\nif (chip->mode & SB_RATE_LOCK)\r\nruntime->hw.rate_min = runtime->hw.rate_max = chip->locked_rate;\r\nchip->capture_substream = substream;\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nsnd_sb16_csp_capture_close(chip);\r\nspin_lock_irqsave(&chip->open_lock, flags);\r\nchip->capture_substream = NULL;\r\nchip->mode &= ~SB_MODE_CAPTURE;\r\nspin_unlock_irqrestore(&chip->open_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_set_dma_mode(struct snd_sb *chip, int what)\r\n{\r\nif (chip->dma8 < 0 || chip->dma16 < 0) {\r\nif (snd_BUG_ON(what))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif (what == 0) {\r\nchip->force_mode16 = 0;\r\n} else if (what == 1) {\r\nchip->force_mode16 = SB_MODE_PLAYBACK_16;\r\n} else if (what == 2) {\r\nchip->force_mode16 = SB_MODE_CAPTURE_16;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_get_dma_mode(struct snd_sb *chip)\r\n{\r\nif (chip->dma8 < 0 || chip->dma16 < 0)\r\nreturn 0;\r\nswitch (chip->force_mode16) {\r\ncase SB_MODE_PLAYBACK_16:\r\nreturn 1;\r\ncase SB_MODE_CAPTURE_16:\r\nreturn 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int snd_sb16_dma_control_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[3] = {\r\n"Auto", "Playback", "Capture"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item > 2)\r\nuinfo->value.enumerated.item = 2;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_dma_control_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sb *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.enumerated.item[0] = snd_sb16_get_dma_mode(chip);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_sb16_dma_control_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_sb *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nunsigned char nval, oval;\r\nint change;\r\nif ((nval = ucontrol->value.enumerated.item[0]) > 2)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noval = snd_sb16_get_dma_mode(chip);\r\nchange = nval != oval;\r\nsnd_sb16_set_dma_mode(chip, nval);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nint snd_sb16dsp_configure(struct snd_sb * chip)\r\n{\r\nunsigned long flags;\r\nunsigned char irqreg = 0, dmareg = 0, mpureg;\r\nunsigned char realirq, realdma, realmpureg;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\nmpureg = snd_sbmixer_read(chip, SB_DSP4_MPUSETUP) & ~0x06;\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nswitch (chip->irq) {\r\ncase 2:\r\ncase 9:\r\nirqreg |= SB_IRQSETUP_IRQ9;\r\nbreak;\r\ncase 5:\r\nirqreg |= SB_IRQSETUP_IRQ5;\r\nbreak;\r\ncase 7:\r\nirqreg |= SB_IRQSETUP_IRQ7;\r\nbreak;\r\ncase 10:\r\nirqreg |= SB_IRQSETUP_IRQ10;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (chip->dma8 >= 0) {\r\nswitch (chip->dma8) {\r\ncase 0:\r\ndmareg |= SB_DMASETUP_DMA0;\r\nbreak;\r\ncase 1:\r\ndmareg |= SB_DMASETUP_DMA1;\r\nbreak;\r\ncase 3:\r\ndmareg |= SB_DMASETUP_DMA3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (chip->dma16 >= 0 && chip->dma16 != chip->dma8) {\r\nswitch (chip->dma16) {\r\ncase 5:\r\ndmareg |= SB_DMASETUP_DMA5;\r\nbreak;\r\ncase 6:\r\ndmareg |= SB_DMASETUP_DMA6;\r\nbreak;\r\ncase 7:\r\ndmareg |= SB_DMASETUP_DMA7;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (chip->mpu_port) {\r\ncase 0x300:\r\nmpureg |= 0x04;\r\nbreak;\r\ncase 0x330:\r\nmpureg |= 0x00;\r\nbreak;\r\ndefault:\r\nmpureg |= 0x02;\r\n}\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\nsnd_sbmixer_write(chip, SB_DSP4_IRQSETUP, irqreg);\r\nrealirq = snd_sbmixer_read(chip, SB_DSP4_IRQSETUP);\r\nsnd_sbmixer_write(chip, SB_DSP4_DMASETUP, dmareg);\r\nrealdma = snd_sbmixer_read(chip, SB_DSP4_DMASETUP);\r\nsnd_sbmixer_write(chip, SB_DSP4_MPUSETUP, mpureg);\r\nrealmpureg = snd_sbmixer_read(chip, SB_DSP4_MPUSETUP);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nif ((~realirq) & irqreg || (~realdma) & dmareg) {\r\nsnd_printk(KERN_ERR "SB16 [0x%lx]: unable to set DMA & IRQ (PnP device?)\n", chip->port);\r\nsnd_printk(KERN_ERR "SB16 [0x%lx]: wanted: irqreg=0x%x, dmareg=0x%x, mpureg = 0x%x\n", chip->port, realirq, realdma, realmpureg);\r\nsnd_printk(KERN_ERR "SB16 [0x%lx]: got: irqreg=0x%x, dmareg=0x%x, mpureg = 0x%x\n", chip->port, irqreg, dmareg, mpureg);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint snd_sb16dsp_pcm(struct snd_sb * chip, int device, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(card, "SB16 DSP", device, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nsprintf(pcm->name, "DSP v%i.%i", chip->version >> 8, chip->version & 0xff);\r\npcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sb16_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sb16_capture_ops);\r\nif (chip->dma16 >= 0 && chip->dma8 != chip->dma16)\r\nsnd_ctl_add(card, snd_ctl_new1(&snd_sb16_dma_control, chip));\r\nelse\r\npcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, 128*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nconst struct snd_pcm_ops *snd_sb16dsp_get_pcm_ops(int direction)\r\n{\r\nreturn direction == SNDRV_PCM_STREAM_PLAYBACK ?\r\n&snd_sb16_playback_ops : &snd_sb16_capture_ops;\r\n}\r\nstatic int __init alsa_sb16_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_sb16_exit(void)\r\n{\r\n}
