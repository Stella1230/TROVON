static inline struct ocfs2_refcount_tree *\r\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\r\n{\r\nreturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\r\n}\r\nstatic int ocfs2_validate_refcount_block(struct super_block *sb,\r\nstruct buffer_head *bh)\r\n{\r\nint rc;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)bh->b_data;\r\ntrace_ocfs2_validate_refcount_block((unsigned long long)bh->b_blocknr);\r\nBUG_ON(!buffer_uptodate(bh));\r\nrc = ocfs2_validate_meta_ecc(sb, bh->b_data, &rb->rf_check);\r\nif (rc) {\r\nmlog(ML_ERROR, "Checksum failed for refcount block %llu\n",\r\n(unsigned long long)bh->b_blocknr);\r\nreturn rc;\r\n}\r\nif (!OCFS2_IS_VALID_REFCOUNT_BLOCK(rb)) {\r\nocfs2_error(sb,\r\n"Refcount block #%llu has bad signature %.*s",\r\n(unsigned long long)bh->b_blocknr, 7,\r\nrb->rf_signature);\r\nreturn -EINVAL;\r\n}\r\nif (le64_to_cpu(rb->rf_blkno) != bh->b_blocknr) {\r\nocfs2_error(sb,\r\n"Refcount block #%llu has an invalid rf_blkno "\r\n"of %llu",\r\n(unsigned long long)bh->b_blocknr,\r\n(unsigned long long)le64_to_cpu(rb->rf_blkno));\r\nreturn -EINVAL;\r\n}\r\nif (le32_to_cpu(rb->rf_fs_generation) != OCFS2_SB(sb)->fs_generation) {\r\nocfs2_error(sb,\r\n"Refcount block #%llu has an invalid "\r\n"rf_fs_generation of #%u",\r\n(unsigned long long)bh->b_blocknr,\r\nle32_to_cpu(rb->rf_fs_generation));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\r\nu64 rb_blkno,\r\nstruct buffer_head **bh)\r\n{\r\nint rc;\r\nstruct buffer_head *tmp = *bh;\r\nrc = ocfs2_read_block(ci, rb_blkno, &tmp,\r\nocfs2_validate_refcount_block);\r\nif (!rc && !*bh)\r\n*bh = tmp;\r\nreturn rc;\r\n}\r\nstatic u64 ocfs2_refcount_cache_owner(struct ocfs2_caching_info *ci)\r\n{\r\nstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\r\nreturn rf->rf_blkno;\r\n}\r\nstatic struct super_block *\r\nocfs2_refcount_cache_get_super(struct ocfs2_caching_info *ci)\r\n{\r\nstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\r\nreturn rf->rf_sb;\r\n}\r\nstatic void ocfs2_refcount_cache_lock(struct ocfs2_caching_info *ci)\r\n{\r\nstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\r\nspin_lock(&rf->rf_lock);\r\n}\r\nstatic void ocfs2_refcount_cache_unlock(struct ocfs2_caching_info *ci)\r\n{\r\nstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\r\nspin_unlock(&rf->rf_lock);\r\n}\r\nstatic void ocfs2_refcount_cache_io_lock(struct ocfs2_caching_info *ci)\r\n{\r\nstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\r\nmutex_lock(&rf->rf_io_mutex);\r\n}\r\nstatic void ocfs2_refcount_cache_io_unlock(struct ocfs2_caching_info *ci)\r\n{\r\nstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\r\nmutex_unlock(&rf->rf_io_mutex);\r\n}\r\nstatic struct ocfs2_refcount_tree *\r\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\r\n{\r\nstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\r\nstruct ocfs2_refcount_tree *tree = NULL;\r\nwhile (n) {\r\ntree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\r\nif (blkno < tree->rf_blkno)\r\nn = n->rb_left;\r\nelse if (blkno > tree->rf_blkno)\r\nn = n->rb_right;\r\nelse\r\nreturn tree;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\r\nstruct ocfs2_refcount_tree *new)\r\n{\r\nu64 rf_blkno = new->rf_blkno;\r\nstruct rb_node *parent = NULL;\r\nstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\r\nstruct ocfs2_refcount_tree *tmp;\r\nwhile (*p) {\r\nparent = *p;\r\ntmp = rb_entry(parent, struct ocfs2_refcount_tree,\r\nrf_node);\r\nif (rf_blkno < tmp->rf_blkno)\r\np = &(*p)->rb_left;\r\nelse if (rf_blkno > tmp->rf_blkno)\r\np = &(*p)->rb_right;\r\nelse {\r\nmlog(ML_ERROR, "Duplicate refcount block %llu found!\n",\r\n(unsigned long long)rf_blkno);\r\nBUG();\r\n}\r\n}\r\nrb_link_node(&new->rf_node, parent, p);\r\nrb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\r\n}\r\nstatic void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\r\n{\r\nocfs2_metadata_cache_exit(&tree->rf_ci);\r\nocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\r\nocfs2_lock_res_free(&tree->rf_lockres);\r\nkfree(tree);\r\n}\r\nstatic inline void\r\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_refcount_tree *tree)\r\n{\r\nrb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\r\nif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\r\nosb->osb_ref_tree_lru = NULL;\r\n}\r\nstatic void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\r\nstruct ocfs2_refcount_tree *tree)\r\n{\r\nspin_lock(&osb->osb_lock);\r\nocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\r\nspin_unlock(&osb->osb_lock);\r\n}\r\nstatic void ocfs2_kref_remove_refcount_tree(struct kref *kref)\r\n{\r\nstruct ocfs2_refcount_tree *tree =\r\ncontainer_of(kref, struct ocfs2_refcount_tree, rf_getcnt);\r\nocfs2_free_refcount_tree(tree);\r\n}\r\nstatic inline void\r\nocfs2_refcount_tree_get(struct ocfs2_refcount_tree *tree)\r\n{\r\nkref_get(&tree->rf_getcnt);\r\n}\r\nstatic inline void\r\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\r\n{\r\nkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\r\n}\r\nstatic inline void ocfs2_init_refcount_tree_ci(struct ocfs2_refcount_tree *new,\r\nstruct super_block *sb)\r\n{\r\nocfs2_metadata_cache_init(&new->rf_ci, &ocfs2_refcount_caching_ops);\r\nmutex_init(&new->rf_io_mutex);\r\nnew->rf_sb = sb;\r\nspin_lock_init(&new->rf_lock);\r\n}\r\nstatic inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_refcount_tree *new,\r\nu64 rf_blkno, u32 generation)\r\n{\r\ninit_rwsem(&new->rf_sem);\r\nocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\r\nrf_blkno, generation);\r\n}\r\nstatic struct ocfs2_refcount_tree*\r\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\r\n{\r\nstruct ocfs2_refcount_tree *new;\r\nnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\r\nif (!new)\r\nreturn NULL;\r\nnew->rf_blkno = rf_blkno;\r\nkref_init(&new->rf_getcnt);\r\nocfs2_init_refcount_tree_ci(new, osb->sb);\r\nreturn new;\r\n}\r\nstatic int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\r\nstruct ocfs2_refcount_tree **ret_tree)\r\n{\r\nint ret = 0;\r\nstruct ocfs2_refcount_tree *tree, *new = NULL;\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_refcount_block *ref_rb;\r\nspin_lock(&osb->osb_lock);\r\nif (osb->osb_ref_tree_lru &&\r\nosb->osb_ref_tree_lru->rf_blkno == rf_blkno)\r\ntree = osb->osb_ref_tree_lru;\r\nelse\r\ntree = ocfs2_find_refcount_tree(osb, rf_blkno);\r\nif (tree)\r\ngoto out;\r\nspin_unlock(&osb->osb_lock);\r\nnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\r\nif (!new) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\nocfs2_metadata_cache_exit(&new->rf_ci);\r\nkfree(new);\r\nreturn ret;\r\n}\r\nref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\r\nocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\r\nnew->rf_generation);\r\nocfs2_metadata_cache_purge(&new->rf_ci);\r\nspin_lock(&osb->osb_lock);\r\ntree = ocfs2_find_refcount_tree(osb, rf_blkno);\r\nif (tree)\r\ngoto out;\r\nocfs2_insert_refcount_tree(osb, new);\r\ntree = new;\r\nnew = NULL;\r\nout:\r\n*ret_tree = tree;\r\nosb->osb_ref_tree_lru = tree;\r\nspin_unlock(&osb->osb_lock);\r\nif (new)\r\nocfs2_free_refcount_tree(new);\r\nbrelse(ref_root_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_get_refcount_block(struct inode *inode, u64 *ref_blkno)\r\n{\r\nint ret;\r\nstruct buffer_head *di_bh = NULL;\r\nstruct ocfs2_dinode *di;\r\nret = ocfs2_read_inode_block(inode, &di_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\r\ndi = (struct ocfs2_dinode *)di_bh->b_data;\r\n*ref_blkno = le64_to_cpu(di->i_refcount_loc);\r\nbrelse(di_bh);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\r\nstruct ocfs2_refcount_tree *tree, int rw)\r\n{\r\nint ret;\r\nret = ocfs2_refcount_lock(tree, rw);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (rw)\r\ndown_write(&tree->rf_sem);\r\nelse\r\ndown_read(&tree->rf_sem);\r\nout:\r\nreturn ret;\r\n}\r\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\r\nu64 ref_blkno, int rw,\r\nstruct ocfs2_refcount_tree **ret_tree,\r\nstruct buffer_head **ref_bh)\r\n{\r\nint ret, delete_tree = 0;\r\nstruct ocfs2_refcount_tree *tree = NULL;\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_refcount_block *rb;\r\nagain:\r\nret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nocfs2_refcount_tree_get(tree);\r\nret = __ocfs2_lock_refcount_tree(osb, tree, rw);\r\nif (ret) {\r\nmlog_errno(ret);\r\nocfs2_refcount_tree_put(tree);\r\ngoto out;\r\n}\r\nret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\r\n&ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\nocfs2_unlock_refcount_tree(osb, tree, rw);\r\nocfs2_refcount_tree_put(tree);\r\ngoto out;\r\n}\r\nrb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\r\nif (!tree->rf_removed) {\r\nocfs2_erase_refcount_tree_from_list(osb, tree);\r\ntree->rf_removed = 1;\r\ndelete_tree = 1;\r\n}\r\nocfs2_unlock_refcount_tree(osb, tree, rw);\r\nif (delete_tree)\r\nocfs2_refcount_tree_put(tree);\r\nbrelse(ref_root_bh);\r\nref_root_bh = NULL;\r\ngoto again;\r\n}\r\n*ret_tree = tree;\r\nif (ref_bh) {\r\n*ref_bh = ref_root_bh;\r\nref_root_bh = NULL;\r\n}\r\nout:\r\nbrelse(ref_root_bh);\r\nreturn ret;\r\n}\r\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\r\nstruct ocfs2_refcount_tree *tree, int rw)\r\n{\r\nif (rw)\r\nup_write(&tree->rf_sem);\r\nelse\r\nup_read(&tree->rf_sem);\r\nocfs2_refcount_unlock(tree, rw);\r\nocfs2_refcount_tree_put(tree);\r\n}\r\nvoid ocfs2_purge_refcount_trees(struct ocfs2_super *osb)\r\n{\r\nstruct rb_node *node;\r\nstruct ocfs2_refcount_tree *tree;\r\nstruct rb_root *root = &osb->osb_rf_lock_tree;\r\nwhile ((node = rb_last(root)) != NULL) {\r\ntree = rb_entry(node, struct ocfs2_refcount_tree, rf_node);\r\ntrace_ocfs2_purge_refcount_trees(\r\n(unsigned long long) tree->rf_blkno);\r\nrb_erase(&tree->rf_node, root);\r\nocfs2_free_refcount_tree(tree);\r\n}\r\n}\r\nstatic int ocfs2_create_refcount_tree(struct inode *inode,\r\nstruct buffer_head *di_bh)\r\n{\r\nint ret;\r\nhandle_t *handle = NULL;\r\nstruct ocfs2_alloc_context *meta_ac = NULL;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct buffer_head *new_bh = NULL;\r\nstruct ocfs2_refcount_block *rb;\r\nstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\r\nu16 suballoc_bit_start;\r\nu32 num_got;\r\nu64 suballoc_loc, first_blkno;\r\nBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\r\ntrace_ocfs2_create_refcount_tree(\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\nret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nhandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\r\n&suballoc_bit_start, &num_got,\r\n&first_blkno);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\r\nif (!new_tree) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nnew_bh = sb_getblk(inode->i_sb, first_blkno);\r\nocfs2_set_new_buffer_uptodate(&new_tree->rf_ci, new_bh);\r\nret = ocfs2_journal_access_rb(handle, &new_tree->rf_ci, new_bh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nrb = (struct ocfs2_refcount_block *)new_bh->b_data;\r\nmemset(rb, 0, inode->i_sb->s_blocksize);\r\nstrcpy((void *)rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\r\nrb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\r\nrb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\r\nrb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\r\nrb->rf_fs_generation = cpu_to_le32(osb->fs_generation);\r\nrb->rf_blkno = cpu_to_le64(first_blkno);\r\nrb->rf_count = cpu_to_le32(1);\r\nrb->rf_records.rl_count =\r\ncpu_to_le16(ocfs2_refcount_recs_per_rb(osb->sb));\r\nspin_lock(&osb->osb_lock);\r\nrb->rf_generation = osb->s_next_generation++;\r\nspin_unlock(&osb->osb_lock);\r\nocfs2_journal_dirty(handle, new_bh);\r\nspin_lock(&oi->ip_lock);\r\noi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\r\ndi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\r\ndi->i_refcount_loc = cpu_to_le64(first_blkno);\r\nspin_unlock(&oi->ip_lock);\r\ntrace_ocfs2_create_refcount_tree_blkno((unsigned long long)first_blkno);\r\nocfs2_journal_dirty(handle, di_bh);\r\nnew_tree->rf_generation = le32_to_cpu(rb->rf_generation);\r\nocfs2_init_refcount_tree_lock(osb, new_tree, first_blkno,\r\nnew_tree->rf_generation);\r\nspin_lock(&osb->osb_lock);\r\ntree = ocfs2_find_refcount_tree(osb, first_blkno);\r\nBUG_ON(tree && tree->rf_generation == new_tree->rf_generation);\r\nif (tree)\r\nocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\r\nocfs2_insert_refcount_tree(osb, new_tree);\r\nspin_unlock(&osb->osb_lock);\r\nnew_tree = NULL;\r\nif (tree)\r\nocfs2_refcount_tree_put(tree);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nif (new_tree) {\r\nocfs2_metadata_cache_exit(&new_tree->rf_ci);\r\nkfree(new_tree);\r\n}\r\nbrelse(new_bh);\r\nif (meta_ac)\r\nocfs2_free_alloc_context(meta_ac);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_set_refcount_tree(struct inode *inode,\r\nstruct buffer_head *di_bh,\r\nu64 refcount_loc)\r\n{\r\nint ret;\r\nhandle_t *handle = NULL;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_refcount_block *rb;\r\nstruct ocfs2_refcount_tree *ref_tree;\r\nBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\r\nret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\r\n&ref_tree, &ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nhandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_SET_CREDITS);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, ref_root_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nrb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nle32_add_cpu(&rb->rf_count, 1);\r\nocfs2_journal_dirty(handle, ref_root_bh);\r\nspin_lock(&oi->ip_lock);\r\noi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\r\ndi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\r\ndi->i_refcount_loc = cpu_to_le64(refcount_loc);\r\nspin_unlock(&oi->ip_lock);\r\nocfs2_journal_dirty(handle, di_bh);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nbrelse(ref_root_bh);\r\nreturn ret;\r\n}\r\nint ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\r\n{\r\nint ret, delete_tree = 0;\r\nhandle_t *handle = NULL;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct ocfs2_refcount_block *rb;\r\nstruct inode *alloc_inode = NULL;\r\nstruct buffer_head *alloc_bh = NULL;\r\nstruct buffer_head *blk_bh = NULL;\r\nstruct ocfs2_refcount_tree *ref_tree;\r\nint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\r\nu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\r\nu16 bit = 0;\r\nif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\r\nreturn 0;\r\nBUG_ON(!ref_blkno);\r\nret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nrb = (struct ocfs2_refcount_block *)blk_bh->b_data;\r\nif (le32_to_cpu(rb->rf_count) == 1) {\r\nblk = le64_to_cpu(rb->rf_blkno);\r\nbit = le16_to_cpu(rb->rf_suballoc_bit);\r\nif (rb->rf_suballoc_loc)\r\nbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\r\nelse\r\nbg_blkno = ocfs2_which_suballoc_group(blk, bit);\r\nalloc_inode = ocfs2_get_system_file_inode(osb,\r\nEXTENT_ALLOC_SYSTEM_INODE,\r\nle16_to_cpu(rb->rf_suballoc_slot));\r\nif (!alloc_inode) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nmutex_lock(&alloc_inode->i_mutex);\r\nret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_mutex;\r\n}\r\ncredits += OCFS2_SUBALLOC_FREE;\r\n}\r\nhandle = ocfs2_start_trans(osb, credits);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out_unlock;\r\n}\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nspin_lock(&oi->ip_lock);\r\noi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\r\ndi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\r\ndi->i_refcount_loc = 0;\r\nspin_unlock(&oi->ip_lock);\r\nocfs2_journal_dirty(handle, di_bh);\r\nle32_add_cpu(&rb->rf_count , -1);\r\nocfs2_journal_dirty(handle, blk_bh);\r\nif (!rb->rf_count) {\r\ndelete_tree = 1;\r\nocfs2_erase_refcount_tree_from_list(osb, ref_tree);\r\nret = ocfs2_free_suballoc_bits(handle, alloc_inode,\r\nalloc_bh, bit, bg_blkno, 1);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout_unlock:\r\nif (alloc_inode) {\r\nocfs2_inode_unlock(alloc_inode, 1);\r\nbrelse(alloc_bh);\r\n}\r\nout_mutex:\r\nif (alloc_inode) {\r\nmutex_unlock(&alloc_inode->i_mutex);\r\niput(alloc_inode);\r\n}\r\nout:\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nif (delete_tree)\r\nocfs2_refcount_tree_put(ref_tree);\r\nbrelse(blk_bh);\r\nreturn ret;\r\n}\r\nstatic void ocfs2_find_refcount_rec_in_rl(struct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_leaf_bh,\r\nu64 cpos, unsigned int len,\r\nstruct ocfs2_refcount_rec *ret_rec,\r\nint *index)\r\n{\r\nint i = 0;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_refcount_rec *rec = NULL;\r\nfor (; i < le16_to_cpu(rb->rf_records.rl_used); i++) {\r\nrec = &rb->rf_records.rl_recs[i];\r\nif (le64_to_cpu(rec->r_cpos) +\r\nle32_to_cpu(rec->r_clusters) <= cpos)\r\ncontinue;\r\nelse if (le64_to_cpu(rec->r_cpos) > cpos)\r\nbreak;\r\nif (ret_rec)\r\n*ret_rec = *rec;\r\ngoto out;\r\n}\r\nif (ret_rec) {\r\nret_rec->r_cpos = cpu_to_le64(cpos);\r\nret_rec->r_refcount = 0;\r\nif (i < le16_to_cpu(rb->rf_records.rl_used) &&\r\nle64_to_cpu(rec->r_cpos) < cpos + len)\r\nret_rec->r_clusters =\r\ncpu_to_le32(le64_to_cpu(rec->r_cpos) - cpos);\r\nelse\r\nret_rec->r_clusters = cpu_to_le32(len);\r\n}\r\nout:\r\n*index = i;\r\n}\r\nint ocfs2_try_remove_refcount_tree(struct inode *inode,\r\nstruct buffer_head *di_bh)\r\n{\r\nint ret;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\ndown_write(&oi->ip_xattr_sem);\r\ndown_write(&oi->ip_alloc_sem);\r\nif (oi->ip_clusters)\r\ngoto out;\r\nif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\r\ngoto out;\r\nif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\r\nocfs2_has_inline_xattr_value_outside(inode, di))\r\ngoto out;\r\nret = ocfs2_remove_refcount_tree(inode, di_bh);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nup_write(&oi->ip_alloc_sem);\r\nup_write(&oi->ip_xattr_sem);\r\nreturn 0;\r\n}\r\nstatic int ocfs2_get_refcount_cpos_end(struct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct ocfs2_extent_block *eb,\r\nstruct ocfs2_extent_list *el,\r\nint index, u32 *cpos_end)\r\n{\r\nint ret, i, subtree_root;\r\nu32 cpos;\r\nu64 blkno;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nstruct ocfs2_path *left_path = NULL, *right_path = NULL;\r\nstruct ocfs2_extent_tree et;\r\nstruct ocfs2_extent_list *tmp_el;\r\nif (index < le16_to_cpu(el->l_next_free_rec) - 1) {\r\n*cpos_end = le32_to_cpu(el->l_recs[index+1].e_cpos);\r\nreturn 0;\r\n}\r\nif (!eb || (eb && !eb->h_next_leaf_blk)) {\r\n*cpos_end = UINT_MAX;\r\nreturn 0;\r\n}\r\nocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\r\nleft_path = ocfs2_new_path_from_et(&et);\r\nif (!left_path) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ncpos = le32_to_cpu(eb->h_list.l_recs[index].e_cpos);\r\nret = ocfs2_find_path(ci, left_path, cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nright_path = ocfs2_new_path_from_path(left_path);\r\nif (!right_path) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_find_cpos_for_right_leaf(sb, left_path, &cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_find_path(ci, right_path, cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nsubtree_root = ocfs2_find_subtree_root(&et, left_path,\r\nright_path);\r\ntmp_el = left_path->p_node[subtree_root].el;\r\nblkno = left_path->p_node[subtree_root+1].bh->b_blocknr;\r\nfor (i = 0; i < le16_to_cpu(tmp_el->l_next_free_rec); i++) {\r\nif (le64_to_cpu(tmp_el->l_recs[i].e_blkno) == blkno) {\r\n*cpos_end = le32_to_cpu(tmp_el->l_recs[i+1].e_cpos);\r\nbreak;\r\n}\r\n}\r\nBUG_ON(i == le16_to_cpu(tmp_el->l_next_free_rec));\r\nout:\r\nocfs2_free_path(left_path);\r\nocfs2_free_path(right_path);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nu64 cpos, unsigned int len,\r\nstruct ocfs2_refcount_rec *ret_rec,\r\nint *index,\r\nstruct buffer_head **ret_bh)\r\n{\r\nint ret = 0, i, found;\r\nu32 low_cpos, uninitialized_var(cpos_end);\r\nstruct ocfs2_extent_list *el;\r\nstruct ocfs2_extent_rec *rec = NULL;\r\nstruct ocfs2_extent_block *eb = NULL;\r\nstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\r\nocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\r\nret_rec, index);\r\n*ret_bh = ref_root_bh;\r\nget_bh(ref_root_bh);\r\nreturn 0;\r\n}\r\nel = &rb->rf_list;\r\nlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\r\nif (el->l_tree_depth) {\r\nret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\neb = (struct ocfs2_extent_block *) eb_bh->b_data;\r\nel = &eb->h_list;\r\nif (el->l_tree_depth) {\r\nocfs2_error(sb,\r\n"refcount tree %llu has non zero tree "\r\n"depth in leaf btree tree block %llu\n",\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci),\r\n(unsigned long long)eb_bh->b_blocknr);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\n}\r\nfound = 0;\r\nfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\r\nrec = &el->l_recs[i];\r\nif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\r\neb, el, i, &cpos_end);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (cpos_end < low_cpos + len)\r\nlen = cpos_end - low_cpos;\r\n}\r\nret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\r\n&ref_leaf_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\r\nret_rec, index);\r\n*ret_bh = ref_leaf_bh;\r\nout:\r\nbrelse(eb_bh);\r\nreturn ret;\r\n}\r\nstatic enum ocfs2_ref_rec_contig\r\nocfs2_refcount_rec_adjacent(struct ocfs2_refcount_block *rb,\r\nint index)\r\n{\r\nif ((rb->rf_records.rl_recs[index].r_refcount ==\r\nrb->rf_records.rl_recs[index + 1].r_refcount) &&\r\n(le64_to_cpu(rb->rf_records.rl_recs[index].r_cpos) +\r\nle32_to_cpu(rb->rf_records.rl_recs[index].r_clusters) ==\r\nle64_to_cpu(rb->rf_records.rl_recs[index + 1].r_cpos)))\r\nreturn REF_CONTIG_RIGHT;\r\nreturn REF_CONTIG_NONE;\r\n}\r\nstatic enum ocfs2_ref_rec_contig\r\nocfs2_refcount_rec_contig(struct ocfs2_refcount_block *rb,\r\nint index)\r\n{\r\nenum ocfs2_ref_rec_contig ret = REF_CONTIG_NONE;\r\nif (index < le16_to_cpu(rb->rf_records.rl_used) - 1)\r\nret = ocfs2_refcount_rec_adjacent(rb, index);\r\nif (index > 0) {\r\nenum ocfs2_ref_rec_contig tmp;\r\ntmp = ocfs2_refcount_rec_adjacent(rb, index - 1);\r\nif (tmp == REF_CONTIG_RIGHT) {\r\nif (ret == REF_CONTIG_RIGHT)\r\nret = REF_CONTIG_LEFTRIGHT;\r\nelse\r\nret = REF_CONTIG_LEFT;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ocfs2_rotate_refcount_rec_left(struct ocfs2_refcount_block *rb,\r\nint index)\r\n{\r\nBUG_ON(rb->rf_records.rl_recs[index].r_refcount !=\r\nrb->rf_records.rl_recs[index+1].r_refcount);\r\nle32_add_cpu(&rb->rf_records.rl_recs[index].r_clusters,\r\nle32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters));\r\nif (index < le16_to_cpu(rb->rf_records.rl_used) - 2)\r\nmemmove(&rb->rf_records.rl_recs[index + 1],\r\n&rb->rf_records.rl_recs[index + 2],\r\nsizeof(struct ocfs2_refcount_rec) *\r\n(le16_to_cpu(rb->rf_records.rl_used) - index - 2));\r\nmemset(&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1],\r\n0, sizeof(struct ocfs2_refcount_rec));\r\nle16_add_cpu(&rb->rf_records.rl_used, -1);\r\n}\r\nstatic void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\r\nint index)\r\n{\r\nenum ocfs2_ref_rec_contig contig =\r\nocfs2_refcount_rec_contig(rb, index);\r\nif (contig == REF_CONTIG_NONE)\r\nreturn;\r\nif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\r\nBUG_ON(index == 0);\r\nindex--;\r\n}\r\nocfs2_rotate_refcount_rec_left(rb, index);\r\nif (contig == REF_CONTIG_LEFTRIGHT)\r\nocfs2_rotate_refcount_rec_left(rb, index);\r\n}\r\nstatic int ocfs2_change_refcount_rec(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_leaf_bh,\r\nint index, int merge, int change)\r\n{\r\nint ret;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_refcount_list *rl = &rb->rf_records;\r\nstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\r\nret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ntrace_ocfs2_change_refcount_rec(\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci),\r\nindex, le32_to_cpu(rec->r_refcount), change);\r\nle32_add_cpu(&rec->r_refcount, change);\r\nif (!rec->r_refcount) {\r\nif (index != le16_to_cpu(rl->rl_used) - 1) {\r\nmemmove(rec, rec + 1,\r\n(le16_to_cpu(rl->rl_used) - index - 1) *\r\nsizeof(struct ocfs2_refcount_rec));\r\nmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\r\n0, sizeof(struct ocfs2_refcount_rec));\r\n}\r\nle16_add_cpu(&rl->rl_used, -1);\r\n} else if (merge)\r\nocfs2_refcount_rec_merge(rb, index);\r\nocfs2_journal_dirty(handle, ref_leaf_bh);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_expand_inline_ref_root(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head **ref_leaf_bh,\r\nstruct ocfs2_alloc_context *meta_ac)\r\n{\r\nint ret;\r\nu16 suballoc_bit_start;\r\nu32 num_got;\r\nu64 suballoc_loc, blkno;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nstruct buffer_head *new_bh = NULL;\r\nstruct ocfs2_refcount_block *new_rb;\r\nstruct ocfs2_refcount_block *root_rb =\r\n(struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\r\n&suballoc_bit_start, &num_got,\r\n&blkno);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nnew_bh = sb_getblk(sb, blkno);\r\nif (new_bh == NULL) {\r\nret = -EIO;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_set_new_buffer_uptodate(ci, new_bh);\r\nret = ocfs2_journal_access_rb(handle, ci, new_bh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nmemcpy(new_bh->b_data, ref_root_bh->b_data, sb->s_blocksize);\r\nnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\r\nnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\r\nnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\r\nnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\r\nnew_rb->rf_blkno = cpu_to_le64(blkno);\r\nnew_rb->rf_cpos = cpu_to_le32(0);\r\nnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\r\nnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\r\nocfs2_journal_dirty(handle, new_bh);\r\nmemset(&root_rb->rf_list, 0, sb->s_blocksize -\r\noffsetof(struct ocfs2_refcount_block, rf_list));\r\nroot_rb->rf_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_rb(sb));\r\nroot_rb->rf_clusters = cpu_to_le32(1);\r\nroot_rb->rf_list.l_next_free_rec = cpu_to_le16(1);\r\nroot_rb->rf_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\r\nroot_rb->rf_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\r\nroot_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_TREE_FL);\r\nocfs2_journal_dirty(handle, ref_root_bh);\r\ntrace_ocfs2_expand_inline_ref_root((unsigned long long)blkno,\r\nle16_to_cpu(new_rb->rf_records.rl_used));\r\n*ref_leaf_bh = new_bh;\r\nnew_bh = NULL;\r\nout:\r\nbrelse(new_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_refcount_rec_no_intersect(struct ocfs2_refcount_rec *prev,\r\nstruct ocfs2_refcount_rec *next)\r\n{\r\nif (ocfs2_get_ref_rec_low_cpos(prev) + le32_to_cpu(prev->r_clusters) <=\r\nocfs2_get_ref_rec_low_cpos(next))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int cmp_refcount_rec_by_low_cpos(const void *a, const void *b)\r\n{\r\nconst struct ocfs2_refcount_rec *l = a, *r = b;\r\nu32 l_cpos = ocfs2_get_ref_rec_low_cpos(l);\r\nu32 r_cpos = ocfs2_get_ref_rec_low_cpos(r);\r\nif (l_cpos > r_cpos)\r\nreturn 1;\r\nif (l_cpos < r_cpos)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int cmp_refcount_rec_by_cpos(const void *a, const void *b)\r\n{\r\nconst struct ocfs2_refcount_rec *l = a, *r = b;\r\nu64 l_cpos = le64_to_cpu(l->r_cpos);\r\nu64 r_cpos = le64_to_cpu(r->r_cpos);\r\nif (l_cpos > r_cpos)\r\nreturn 1;\r\nif (l_cpos < r_cpos)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void swap_refcount_rec(void *a, void *b, int size)\r\n{\r\nstruct ocfs2_refcount_rec *l = a, *r = b, tmp;\r\ntmp = *(struct ocfs2_refcount_rec *)l;\r\n*(struct ocfs2_refcount_rec *)l =\r\n*(struct ocfs2_refcount_rec *)r;\r\n*(struct ocfs2_refcount_rec *)r = tmp;\r\n}\r\nstatic int ocfs2_find_refcount_split_pos(struct ocfs2_refcount_list *rl,\r\nu32 *split_pos, int *split_index)\r\n{\r\nint num_used = le16_to_cpu(rl->rl_used);\r\nint delta, middle = num_used / 2;\r\nfor (delta = 0; delta < middle; delta++) {\r\nif (ocfs2_refcount_rec_no_intersect(\r\n&rl->rl_recs[middle - delta - 1],\r\n&rl->rl_recs[middle - delta])) {\r\n*split_index = middle - delta;\r\nbreak;\r\n}\r\nif ((middle + delta + 1) == num_used)\r\ncontinue;\r\nif (ocfs2_refcount_rec_no_intersect(\r\n&rl->rl_recs[middle + delta],\r\n&rl->rl_recs[middle + delta + 1])) {\r\n*split_index = middle + delta + 1;\r\nbreak;\r\n}\r\n}\r\nif (delta >= middle)\r\nreturn -ENOSPC;\r\n*split_pos = ocfs2_get_ref_rec_low_cpos(&rl->rl_recs[*split_index]);\r\nreturn 0;\r\n}\r\nstatic int ocfs2_divide_leaf_refcount_block(struct buffer_head *ref_leaf_bh,\r\nstruct buffer_head *new_bh,\r\nu32 *split_cpos)\r\n{\r\nint split_index = 0, num_moved, ret;\r\nu32 cpos = 0;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_refcount_list *rl = &rb->rf_records;\r\nstruct ocfs2_refcount_block *new_rb =\r\n(struct ocfs2_refcount_block *)new_bh->b_data;\r\nstruct ocfs2_refcount_list *new_rl = &new_rb->rf_records;\r\ntrace_ocfs2_divide_leaf_refcount_block(\r\n(unsigned long long)ref_leaf_bh->b_blocknr,\r\nle16_to_cpu(rl->rl_count), le16_to_cpu(rl->rl_used));\r\nsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\r\nsizeof(struct ocfs2_refcount_rec),\r\ncmp_refcount_rec_by_low_cpos, swap_refcount_rec);\r\nret = ocfs2_find_refcount_split_pos(rl, &cpos, &split_index);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nnew_rb->rf_cpos = cpu_to_le32(cpos);\r\nnum_moved = le16_to_cpu(rl->rl_used) - split_index;\r\nmemcpy(new_rl->rl_recs, &rl->rl_recs[split_index],\r\nnum_moved * sizeof(struct ocfs2_refcount_rec));\r\nmemset(&rl->rl_recs[split_index], 0,\r\nnum_moved * sizeof(struct ocfs2_refcount_rec));\r\nle16_add_cpu(&rl->rl_used, -num_moved);\r\nnew_rl->rl_used = cpu_to_le16(num_moved);\r\nsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\r\nsizeof(struct ocfs2_refcount_rec),\r\ncmp_refcount_rec_by_cpos, swap_refcount_rec);\r\nsort(&new_rl->rl_recs, le16_to_cpu(new_rl->rl_used),\r\nsizeof(struct ocfs2_refcount_rec),\r\ncmp_refcount_rec_by_cpos, swap_refcount_rec);\r\n*split_cpos = cpos;\r\nreturn 0;\r\n}\r\nstatic int ocfs2_new_leaf_refcount_block(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nstruct ocfs2_alloc_context *meta_ac)\r\n{\r\nint ret;\r\nu16 suballoc_bit_start;\r\nu32 num_got, new_cpos;\r\nu64 suballoc_loc, blkno;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nstruct ocfs2_refcount_block *root_rb =\r\n(struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nstruct buffer_head *new_bh = NULL;\r\nstruct ocfs2_refcount_block *new_rb;\r\nstruct ocfs2_extent_tree ref_et;\r\nBUG_ON(!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL));\r\nret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\r\n&suballoc_bit_start, &num_got,\r\n&blkno);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nnew_bh = sb_getblk(sb, blkno);\r\nif (new_bh == NULL) {\r\nret = -EIO;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_set_new_buffer_uptodate(ci, new_bh);\r\nret = ocfs2_journal_access_rb(handle, ci, new_bh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\r\nmemset(new_rb, 0, sb->s_blocksize);\r\nstrcpy((void *)new_rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\r\nnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\r\nnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\r\nnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\r\nnew_rb->rf_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\r\nnew_rb->rf_blkno = cpu_to_le64(blkno);\r\nnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\r\nnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\r\nnew_rb->rf_records.rl_count =\r\ncpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\r\nnew_rb->rf_generation = root_rb->rf_generation;\r\nret = ocfs2_divide_leaf_refcount_block(ref_leaf_bh, new_bh, &new_cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_journal_dirty(handle, ref_leaf_bh);\r\nocfs2_journal_dirty(handle, new_bh);\r\nocfs2_init_refcount_extent_tree(&ref_et, ci, ref_root_bh);\r\ntrace_ocfs2_new_leaf_refcount_block(\r\n(unsigned long long)new_bh->b_blocknr, new_cpos);\r\nret = ocfs2_insert_extent(handle, &ref_et, new_cpos, new_bh->b_blocknr,\r\n1, 0, meta_ac);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nbrelse(new_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_expand_refcount_tree(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nstruct ocfs2_alloc_context *meta_ac)\r\n{\r\nint ret;\r\nstruct buffer_head *expand_bh = NULL;\r\nif (ref_root_bh == ref_leaf_bh) {\r\nret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\r\n&expand_bh, meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n} else {\r\nexpand_bh = ref_leaf_bh;\r\nget_bh(expand_bh);\r\n}\r\nret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\r\nexpand_bh, meta_ac);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nbrelse(expand_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_adjust_refcount_rec(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nstruct ocfs2_refcount_rec *rec)\r\n{\r\nint ret = 0, i;\r\nu32 new_cpos, old_cpos;\r\nstruct ocfs2_path *path = NULL;\r\nstruct ocfs2_extent_tree et;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nstruct ocfs2_extent_list *el;\r\nif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL))\r\ngoto out;\r\nrb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nold_cpos = le32_to_cpu(rb->rf_cpos);\r\nnew_cpos = le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\r\nif (old_cpos <= new_cpos)\r\ngoto out;\r\nocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\r\npath = ocfs2_new_path_from_et(&et);\r\nif (!path) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_find_path(ci, path, old_cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_extend_trans(handle, 2);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_eb(handle, ci, path_leaf_bh(path),\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nel = path_leaf_el(path);\r\nfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++)\r\nif (le32_to_cpu(el->l_recs[i].e_cpos) == old_cpos)\r\nbreak;\r\nBUG_ON(i == le16_to_cpu(el->l_next_free_rec));\r\nel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\r\nrb->rf_cpos = cpu_to_le32(new_cpos);\r\nocfs2_journal_dirty(handle, path_leaf_bh(path));\r\nocfs2_journal_dirty(handle, ref_leaf_bh);\r\nout:\r\nocfs2_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_insert_refcount_rec(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nstruct ocfs2_refcount_rec *rec,\r\nint index, int merge,\r\nstruct ocfs2_alloc_context *meta_ac)\r\n{\r\nint ret;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\r\nstruct buffer_head *new_bh = NULL;\r\nBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\r\nif (rf_list->rl_used == rf_list->rl_count) {\r\nu64 cpos = le64_to_cpu(rec->r_cpos);\r\nu32 len = le32_to_cpu(rec->r_clusters);\r\nret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\r\nref_leaf_bh, meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_get_refcount_rec(ci, ref_root_bh,\r\ncpos, len, NULL, &index,\r\n&new_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nref_leaf_bh = new_bh;\r\nrb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nrf_list = &rb->rf_records;\r\n}\r\nret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (index < le16_to_cpu(rf_list->rl_used))\r\nmemmove(&rf_list->rl_recs[index + 1],\r\n&rf_list->rl_recs[index],\r\n(le16_to_cpu(rf_list->rl_used) - index) *\r\nsizeof(struct ocfs2_refcount_rec));\r\ntrace_ocfs2_insert_refcount_rec(\r\n(unsigned long long)ref_leaf_bh->b_blocknr, index,\r\n(unsigned long long)le64_to_cpu(rec->r_cpos),\r\nle32_to_cpu(rec->r_clusters), le32_to_cpu(rec->r_refcount));\r\nrf_list->rl_recs[index] = *rec;\r\nle16_add_cpu(&rf_list->rl_used, 1);\r\nif (merge)\r\nocfs2_refcount_rec_merge(rb, index);\r\nocfs2_journal_dirty(handle, ref_leaf_bh);\r\nif (index == 0) {\r\nret = ocfs2_adjust_refcount_rec(handle, ci,\r\nref_root_bh,\r\nref_leaf_bh, rec);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nout:\r\nbrelse(new_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_split_refcount_rec(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nstruct ocfs2_refcount_rec *split_rec,\r\nint index, int merge,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret, recs_need;\r\nu32 len;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\r\nstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\r\nstruct ocfs2_refcount_rec *tail_rec = NULL;\r\nstruct buffer_head *new_bh = NULL;\r\nBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\r\ntrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\r\nle32_to_cpu(orig_rec->r_clusters),\r\nle32_to_cpu(orig_rec->r_refcount),\r\nle64_to_cpu(split_rec->r_cpos),\r\nle32_to_cpu(split_rec->r_clusters),\r\nle32_to_cpu(split_rec->r_refcount));\r\nif (!split_rec->r_refcount &&\r\n(split_rec->r_cpos == orig_rec->r_cpos ||\r\nle64_to_cpu(split_rec->r_cpos) +\r\nle32_to_cpu(split_rec->r_clusters) ==\r\nle64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\r\nrecs_need = 0;\r\nelse\r\nrecs_need = 1;\r\nif (split_rec->r_refcount &&\r\n(split_rec->r_cpos != orig_rec->r_cpos &&\r\nle64_to_cpu(split_rec->r_cpos) +\r\nle32_to_cpu(split_rec->r_clusters) !=\r\nle64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\r\nrecs_need++;\r\nif (le16_to_cpu(rf_list->rl_used) + recs_need >\r\nle16_to_cpu(rf_list->rl_count)) {\r\nstruct ocfs2_refcount_rec tmp_rec;\r\nu64 cpos = le64_to_cpu(orig_rec->r_cpos);\r\nlen = le32_to_cpu(orig_rec->r_clusters);\r\nret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\r\nref_leaf_bh, meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_get_refcount_rec(ci, ref_root_bh,\r\ncpos, len, &tmp_rec, &index,\r\n&new_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nref_leaf_bh = new_bh;\r\nrb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nrf_list = &rb->rf_records;\r\norig_rec = &rf_list->rl_recs[index];\r\n}\r\nret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (index != le16_to_cpu(rf_list->rl_used) - 1)\r\nmemmove(&rf_list->rl_recs[index + 1 + recs_need],\r\n&rf_list->rl_recs[index + 1],\r\n(le16_to_cpu(rf_list->rl_used) - index - 1) *\r\nsizeof(struct ocfs2_refcount_rec));\r\nlen = (le64_to_cpu(orig_rec->r_cpos) +\r\nle32_to_cpu(orig_rec->r_clusters)) -\r\n(le64_to_cpu(split_rec->r_cpos) +\r\nle32_to_cpu(split_rec->r_clusters));\r\nif (len) {\r\ntail_rec = &rf_list->rl_recs[index + recs_need];\r\nmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\r\nle64_add_cpu(&tail_rec->r_cpos,\r\nle32_to_cpu(tail_rec->r_clusters) - len);\r\ntail_rec->r_clusters = cpu_to_le32(len);\r\n}\r\nif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\r\nlen = le64_to_cpu(split_rec->r_cpos) -\r\nle64_to_cpu(orig_rec->r_cpos);\r\norig_rec->r_clusters = cpu_to_le32(len);\r\nindex++;\r\n}\r\nle16_add_cpu(&rf_list->rl_used, recs_need);\r\nif (split_rec->r_refcount) {\r\nrf_list->rl_recs[index] = *split_rec;\r\ntrace_ocfs2_split_refcount_rec_insert(\r\n(unsigned long long)ref_leaf_bh->b_blocknr, index,\r\n(unsigned long long)le64_to_cpu(split_rec->r_cpos),\r\nle32_to_cpu(split_rec->r_clusters),\r\nle32_to_cpu(split_rec->r_refcount));\r\nif (merge)\r\nocfs2_refcount_rec_merge(rb, index);\r\n}\r\nocfs2_journal_dirty(handle, ref_leaf_bh);\r\nout:\r\nbrelse(new_bh);\r\nreturn ret;\r\n}\r\nstatic int __ocfs2_increase_refcount(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nu64 cpos, u32 len, int merge,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret = 0, index;\r\nstruct buffer_head *ref_leaf_bh = NULL;\r\nstruct ocfs2_refcount_rec rec;\r\nunsigned int set_len = 0;\r\ntrace_ocfs2_increase_refcount_begin(\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci),\r\n(unsigned long long)cpos, len);\r\nwhile (len) {\r\nret = ocfs2_get_refcount_rec(ci, ref_root_bh,\r\ncpos, len, &rec, &index,\r\n&ref_leaf_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nset_len = le32_to_cpu(rec.r_clusters);\r\nif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\r\nset_len <= len) {\r\ntrace_ocfs2_increase_refcount_change(\r\n(unsigned long long)cpos, set_len,\r\nle32_to_cpu(rec.r_refcount));\r\nret = ocfs2_change_refcount_rec(handle, ci,\r\nref_leaf_bh, index,\r\nmerge, 1);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n} else if (!rec.r_refcount) {\r\nrec.r_refcount = cpu_to_le32(1);\r\ntrace_ocfs2_increase_refcount_insert(\r\n(unsigned long long)le64_to_cpu(rec.r_cpos),\r\nset_len);\r\nret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\r\nref_leaf_bh,\r\n&rec, index,\r\nmerge, meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n} else {\r\nset_len = min((u64)(cpos + len),\r\nle64_to_cpu(rec.r_cpos) + set_len) - cpos;\r\nrec.r_cpos = cpu_to_le64(cpos);\r\nrec.r_clusters = cpu_to_le32(set_len);\r\nle32_add_cpu(&rec.r_refcount, 1);\r\ntrace_ocfs2_increase_refcount_split(\r\n(unsigned long long)le64_to_cpu(rec.r_cpos),\r\nset_len, le32_to_cpu(rec.r_refcount));\r\nret = ocfs2_split_refcount_rec(handle, ci,\r\nref_root_bh, ref_leaf_bh,\r\n&rec, index, merge,\r\nmeta_ac, dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\ncpos += set_len;\r\nlen -= set_len;\r\nbrelse(ref_leaf_bh);\r\nref_leaf_bh = NULL;\r\n}\r\nout:\r\nbrelse(ref_leaf_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_remove_refcount_extent(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_extent_tree et;\r\nBUG_ON(rb->rf_records.rl_used);\r\ntrace_ocfs2_remove_refcount_extent(\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci),\r\n(unsigned long long)ref_leaf_bh->b_blocknr,\r\nle32_to_cpu(rb->rf_cpos));\r\nocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\r\nret = ocfs2_remove_extent(handle, &et, le32_to_cpu(rb->rf_cpos),\r\n1, meta_ac, dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_remove_from_cache(ci, ref_leaf_bh);\r\nret = ocfs2_cache_block_dealloc(dealloc, EXTENT_ALLOC_SYSTEM_INODE,\r\nle16_to_cpu(rb->rf_suballoc_slot),\r\nle64_to_cpu(rb->rf_suballoc_loc),\r\nle64_to_cpu(rb->rf_blkno),\r\nle16_to_cpu(rb->rf_suballoc_bit));\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nrb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nle32_add_cpu(&rb->rf_clusters, -1);\r\nif (!rb->rf_list.l_next_free_rec) {\r\nBUG_ON(rb->rf_clusters);\r\ntrace_ocfs2_restore_refcount_block(\r\n(unsigned long long)ref_root_bh->b_blocknr);\r\nrb->rf_flags = 0;\r\nrb->rf_parent = 0;\r\nrb->rf_cpos = 0;\r\nmemset(&rb->rf_records, 0, sb->s_blocksize -\r\noffsetof(struct ocfs2_refcount_block, rf_records));\r\nrb->rf_records.rl_count =\r\ncpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\r\n}\r\nocfs2_journal_dirty(handle, ref_root_bh);\r\nout:\r\nreturn ret;\r\n}\r\nint ocfs2_increase_refcount(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nu64 cpos, u32 len,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nreturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\r\ncpos, len, 1,\r\nmeta_ac, dealloc);\r\n}\r\nstatic int ocfs2_decrease_refcount_rec(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct buffer_head *ref_leaf_bh,\r\nint index, u64 cpos, unsigned int len,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret;\r\nstruct ocfs2_refcount_block *rb =\r\n(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nstruct ocfs2_refcount_rec *rec = &rb->rf_records.rl_recs[index];\r\nBUG_ON(cpos < le64_to_cpu(rec->r_cpos));\r\nBUG_ON(cpos + len >\r\nle64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters));\r\ntrace_ocfs2_decrease_refcount_rec(\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci),\r\n(unsigned long long)cpos, len);\r\nif (cpos == le64_to_cpu(rec->r_cpos) &&\r\nlen == le32_to_cpu(rec->r_clusters))\r\nret = ocfs2_change_refcount_rec(handle, ci,\r\nref_leaf_bh, index, 1, -1);\r\nelse {\r\nstruct ocfs2_refcount_rec split = *rec;\r\nsplit.r_cpos = cpu_to_le64(cpos);\r\nsplit.r_clusters = cpu_to_le32(len);\r\nle32_add_cpu(&split.r_refcount, -1);\r\nret = ocfs2_split_refcount_rec(handle, ci,\r\nref_root_bh, ref_leaf_bh,\r\n&split, index, 1,\r\nmeta_ac, dealloc);\r\n}\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (!rb->rf_records.rl_used && ref_leaf_bh != ref_root_bh) {\r\nret = ocfs2_remove_refcount_extent(handle, ci, ref_root_bh,\r\nref_leaf_bh, meta_ac,\r\ndealloc);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __ocfs2_decrease_refcount(handle_t *handle,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nu64 cpos, u32 len,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc,\r\nint delete)\r\n{\r\nint ret = 0, index = 0;\r\nstruct ocfs2_refcount_rec rec;\r\nunsigned int r_count = 0, r_len;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nstruct buffer_head *ref_leaf_bh = NULL;\r\ntrace_ocfs2_decrease_refcount(\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci),\r\n(unsigned long long)cpos, len, delete);\r\nwhile (len) {\r\nret = ocfs2_get_refcount_rec(ci, ref_root_bh,\r\ncpos, len, &rec, &index,\r\n&ref_leaf_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nr_count = le32_to_cpu(rec.r_refcount);\r\nBUG_ON(r_count == 0);\r\nif (!delete)\r\nBUG_ON(r_count > 1);\r\nr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\r\nle32_to_cpu(rec.r_clusters)) - cpos;\r\nret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\r\nref_leaf_bh, index,\r\ncpos, r_len,\r\nmeta_ac, dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\r\nret = ocfs2_cache_cluster_dealloc(dealloc,\r\nocfs2_clusters_to_blocks(sb, cpos),\r\nr_len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\ncpos += r_len;\r\nlen -= r_len;\r\nbrelse(ref_leaf_bh);\r\nref_leaf_bh = NULL;\r\n}\r\nout:\r\nbrelse(ref_leaf_bh);\r\nreturn ret;\r\n}\r\nint ocfs2_decrease_refcount(struct inode *inode,\r\nhandle_t *handle, u32 cpos, u32 len,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc,\r\nint delete)\r\n{\r\nint ret;\r\nu64 ref_blkno;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_refcount_tree *tree;\r\nBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\r\nret = ocfs2_get_refcount_block(inode, &ref_blkno);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\r\n&ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\r\ncpos, len, meta_ac, dealloc, delete);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nbrelse(ref_root_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_mark_extent_refcounted(struct inode *inode,\r\nstruct ocfs2_extent_tree *et,\r\nhandle_t *handle, u32 cpos,\r\nu32 len, u32 phys,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret;\r\ntrace_ocfs2_mark_extent_refcounted(OCFS2_I(inode)->ip_blkno,\r\ncpos, len, phys);\r\nif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\r\nocfs2_error(inode->i_sb, "Inode %lu want to use refcount "\r\n"tree, but the feature bit is not set in the "\r\n"super block.", inode->i_ino);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\nret = ocfs2_change_extent_flag(handle, et, cpos,\r\nlen, phys, meta_ac, dealloc,\r\nOCFS2_EXT_REFCOUNTED, 0);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\r\nstruct ocfs2_caching_info *ci,\r\nstruct buffer_head *ref_root_bh,\r\nu64 start_cpos,\r\nu32 clusters,\r\nint *meta_add,\r\nint *credits)\r\n{\r\nint ret = 0, index, ref_blocks = 0, recs_add = 0;\r\nu64 cpos = start_cpos;\r\nstruct ocfs2_refcount_block *rb;\r\nstruct ocfs2_refcount_rec rec;\r\nstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\r\nu32 len;\r\nwhile (clusters) {\r\nret = ocfs2_get_refcount_rec(ci, ref_root_bh,\r\ncpos, clusters, &rec,\r\n&index, &ref_leaf_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (ref_leaf_bh != prev_bh) {\r\nif (prev_bh) {\r\nrb = (struct ocfs2_refcount_block *)\r\nprev_bh->b_data;\r\nif (le16_to_cpu(rb->rf_records.rl_used) +\r\nrecs_add >\r\nle16_to_cpu(rb->rf_records.rl_count))\r\nref_blocks++;\r\n}\r\nrecs_add = 0;\r\n*credits += 1;\r\nbrelse(prev_bh);\r\nprev_bh = ref_leaf_bh;\r\nget_bh(prev_bh);\r\n}\r\nrb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\ntrace_ocfs2_calc_refcount_meta_credits_iterate(\r\nrecs_add, (unsigned long long)cpos, clusters,\r\n(unsigned long long)le64_to_cpu(rec.r_cpos),\r\nle32_to_cpu(rec.r_clusters),\r\nle32_to_cpu(rec.r_refcount), index);\r\nlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\r\nle32_to_cpu(rec.r_clusters)) - cpos;\r\nif (rec.r_refcount) {\r\nrecs_add += 2;\r\nif (cpos == start_cpos &&\r\ncpos != le64_to_cpu(rec.r_cpos))\r\nrecs_add++;\r\nif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\r\nle32_to_cpu(rec.r_clusters))\r\nrecs_add++;\r\n} else\r\nrecs_add++;\r\nbrelse(ref_leaf_bh);\r\nref_leaf_bh = NULL;\r\nclusters -= len;\r\ncpos += len;\r\n}\r\nif (prev_bh) {\r\nrb = (struct ocfs2_refcount_block *)prev_bh->b_data;\r\nif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\r\nle16_to_cpu(rb->rf_records.rl_count))\r\nref_blocks++;\r\n*credits += 1;\r\n}\r\nif (!ref_blocks)\r\ngoto out;\r\n*meta_add += ref_blocks;\r\n*credits += ref_blocks;\r\nrb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\r\nstruct ocfs2_extent_tree et;\r\nocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\r\n*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\r\n*credits += ocfs2_calc_extend_credits(sb,\r\net.et_root_el,\r\nref_blocks);\r\n} else {\r\n*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\r\n*meta_add += 1;\r\n}\r\nout:\r\ntrace_ocfs2_calc_refcount_meta_credits(\r\n(unsigned long long)start_cpos, clusters,\r\n*meta_add, *credits);\r\nbrelse(ref_leaf_bh);\r\nbrelse(prev_bh);\r\nreturn ret;\r\n}\r\nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\r\nu64 refcount_loc,\r\nu64 phys_blkno,\r\nu32 clusters,\r\nint *credits,\r\nint *ref_blocks)\r\n{\r\nint ret;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_refcount_tree *tree;\r\nu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\r\nif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\r\nocfs2_error(inode->i_sb, "Inode %lu want to use refcount "\r\n"tree, but the feature bit is not set in the "\r\n"super block.", inode->i_ino);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\nBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\r\nret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\r\nrefcount_loc, &tree);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\r\n&ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\r\n&tree->rf_ci,\r\nref_root_bh,\r\nstart_cpos, clusters,\r\nref_blocks, credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ntrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\r\nout:\r\nbrelse(ref_root_bh);\r\nreturn ret;\r\n}\r\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\r\n{\r\nreturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\r\n}\r\nstatic inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\r\n{\r\nreturn ~(ocfs2_cow_contig_clusters(sb) - 1);\r\n}\r\nstatic inline unsigned int ocfs2_cow_align_start(struct super_block *sb,\r\nunsigned int start,\r\nunsigned int cpos)\r\n{\r\nBUG_ON(start > cpos);\r\nreturn start + ((cpos - start) & ocfs2_cow_contig_mask(sb));\r\n}\r\nstatic inline unsigned int ocfs2_cow_align_length(struct super_block *sb,\r\nunsigned int len)\r\n{\r\nunsigned int padded =\r\n(len + (ocfs2_cow_contig_clusters(sb) - 1)) &\r\nocfs2_cow_contig_mask(sb);\r\nif (padded < len)\r\npadded = UINT_MAX;\r\nreturn padded;\r\n}\r\nstatic int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\r\nstruct ocfs2_extent_list *el,\r\nu32 cpos,\r\nu32 write_len,\r\nu32 max_cpos,\r\nu32 *cow_start,\r\nu32 *cow_len)\r\n{\r\nint ret = 0;\r\nint tree_height = le16_to_cpu(el->l_tree_depth), i;\r\nstruct buffer_head *eb_bh = NULL;\r\nstruct ocfs2_extent_block *eb = NULL;\r\nstruct ocfs2_extent_rec *rec;\r\nunsigned int want_clusters, rec_end = 0;\r\nint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\r\nint leaf_clusters;\r\nBUG_ON(cpos + write_len > max_cpos);\r\nif (tree_height > 0) {\r\nret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\neb = (struct ocfs2_extent_block *) eb_bh->b_data;\r\nel = &eb->h_list;\r\nif (el->l_tree_depth) {\r\nocfs2_error(inode->i_sb,\r\n"Inode %lu has non zero tree depth in "\r\n"leaf block %llu\n", inode->i_ino,\r\n(unsigned long long)eb_bh->b_blocknr);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\n}\r\n*cow_len = 0;\r\nfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\r\nrec = &el->l_recs[i];\r\nif (ocfs2_is_empty_extent(rec)) {\r\nmlog_bug_on_msg(i != 0, "Inode %lu has empty record in "\r\n"index %d\n", inode->i_ino, i);\r\ncontinue;\r\n}\r\nif (le32_to_cpu(rec->e_cpos) +\r\nle16_to_cpu(rec->e_leaf_clusters) <= cpos)\r\ncontinue;\r\nif (*cow_len == 0) {\r\nBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\r\n*cow_start = le32_to_cpu(rec->e_cpos);\r\n}\r\nif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\r\n(*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\r\n(max_cpos <= le32_to_cpu(rec->e_cpos)))\r\nbreak;\r\nleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\r\nrec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\r\nif (rec_end > max_cpos) {\r\nrec_end = max_cpos;\r\nleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\r\n}\r\nif (!*cow_len)\r\nwant_clusters = write_len;\r\nelse\r\nwant_clusters = (cpos + write_len) -\r\n(*cow_start + *cow_len);\r\nif (want_clusters < contig_clusters)\r\nwant_clusters = contig_clusters;\r\nif (leaf_clusters <= contig_clusters)\r\n*cow_len += leaf_clusters;\r\nelse if (*cow_len || (*cow_start == cpos)) {\r\nwant_clusters = ocfs2_cow_align_length(inode->i_sb,\r\nwant_clusters);\r\nif (leaf_clusters < want_clusters)\r\n*cow_len += leaf_clusters;\r\nelse\r\n*cow_len += want_clusters;\r\n} else if ((*cow_start + contig_clusters) >=\r\n(cpos + write_len)) {\r\n*cow_len = contig_clusters;\r\n} else if ((rec_end - cpos) <= contig_clusters) {\r\n*cow_start = rec_end - contig_clusters;\r\n*cow_len = contig_clusters;\r\n} else if ((rec_end - cpos) <= want_clusters) {\r\n*cow_start = ocfs2_cow_align_start(inode->i_sb,\r\n*cow_start, cpos);\r\n*cow_len = rec_end - *cow_start;\r\n} else {\r\n*cow_start = ocfs2_cow_align_start(inode->i_sb,\r\n*cow_start, cpos);\r\nwant_clusters = (cpos + write_len) - *cow_start;\r\nwant_clusters = ocfs2_cow_align_length(inode->i_sb,\r\nwant_clusters);\r\nif (*cow_start + want_clusters <= rec_end)\r\n*cow_len = want_clusters;\r\nelse\r\n*cow_len = rec_end - *cow_start;\r\n}\r\nif ((*cow_start + *cow_len) >= (cpos + write_len))\r\nbreak;\r\nif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\r\neb && eb->h_next_leaf_blk) {\r\nbrelse(eb_bh);\r\neb_bh = NULL;\r\nret = ocfs2_read_extent_block(INODE_CACHE(inode),\r\nle64_to_cpu(eb->h_next_leaf_blk),\r\n&eb_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\neb = (struct ocfs2_extent_block *) eb_bh->b_data;\r\nel = &eb->h_list;\r\ni = -1;\r\n}\r\n}\r\nout:\r\nbrelse(eb_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_lock_refcount_allocators(struct super_block *sb,\r\nu32 p_cluster, u32 num_clusters,\r\nstruct ocfs2_extent_tree *et,\r\nstruct ocfs2_caching_info *ref_ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct ocfs2_alloc_context **meta_ac,\r\nstruct ocfs2_alloc_context **data_ac,\r\nint *credits)\r\n{\r\nint ret = 0, meta_add = 0;\r\nint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\r\nif (num_free_extents < 0) {\r\nret = num_free_extents;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (num_free_extents < num_clusters + 2)\r\nmeta_add =\r\nocfs2_extend_meta_needed(et->et_root_el);\r\n*credits += ocfs2_calc_extend_credits(sb, et->et_root_el,\r\nnum_clusters + 2);\r\nret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\r\np_cluster, num_clusters,\r\n&meta_add, credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ntrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\r\nret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\r\nmeta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (data_ac) {\r\nret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\r\ndata_ac);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nout:\r\nif (ret) {\r\nif (*meta_ac) {\r\nocfs2_free_alloc_context(*meta_ac);\r\n*meta_ac = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ocfs2_clear_cow_buffer(handle_t *handle, struct buffer_head *bh)\r\n{\r\nBUG_ON(buffer_dirty(bh));\r\nclear_buffer_mapped(bh);\r\nreturn 0;\r\n}\r\nint ocfs2_duplicate_clusters_by_page(handle_t *handle,\r\nstruct file *file,\r\nu32 cpos, u32 old_cluster,\r\nu32 new_cluster, u32 new_len)\r\n{\r\nint ret = 0, partial;\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct ocfs2_caching_info *ci = INODE_CACHE(inode);\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\nu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\r\nstruct page *page;\r\npgoff_t page_index;\r\nunsigned int from, to, readahead_pages;\r\nloff_t offset, end, map_end;\r\nstruct address_space *mapping = inode->i_mapping;\r\ntrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\r\nnew_cluster, new_len);\r\nreadahead_pages =\r\n(ocfs2_cow_contig_clusters(sb) <<\r\nOCFS2_SB(sb)->s_clustersize_bits) >> PAGE_CACHE_SHIFT;\r\noffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\r\nend = offset + (new_len << OCFS2_SB(sb)->s_clustersize_bits);\r\nif (end > i_size_read(inode))\r\nend = i_size_read(inode);\r\nwhile (offset < end) {\r\npage_index = offset >> PAGE_CACHE_SHIFT;\r\nmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\r\nif (map_end > end)\r\nmap_end = end;\r\nfrom = offset & (PAGE_CACHE_SIZE - 1);\r\nto = PAGE_CACHE_SIZE;\r\nif (map_end & (PAGE_CACHE_SIZE - 1))\r\nto = map_end & (PAGE_CACHE_SIZE - 1);\r\npage = find_or_create_page(mapping, page_index, GFP_NOFS);\r\nif (PAGE_CACHE_SIZE <= OCFS2_SB(sb)->s_clustersize)\r\nBUG_ON(PageDirty(page));\r\nif (PageReadahead(page)) {\r\npage_cache_async_readahead(mapping,\r\n&file->f_ra, file,\r\npage, page_index,\r\nreadahead_pages);\r\n}\r\nif (!PageUptodate(page)) {\r\nret = block_read_full_page(page, ocfs2_get_block);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto unlock;\r\n}\r\nlock_page(page);\r\n}\r\nif (page_has_buffers(page)) {\r\nret = walk_page_buffers(handle, page_buffers(page),\r\nfrom, to, &partial,\r\nocfs2_clear_cow_buffer);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto unlock;\r\n}\r\n}\r\nocfs2_map_and_dirty_page(inode, handle, from, to,\r\npage, 0, &new_block);\r\nmark_page_accessed(page);\r\nunlock:\r\nunlock_page(page);\r\npage_cache_release(page);\r\npage = NULL;\r\noffset = map_end;\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint ocfs2_duplicate_clusters_by_jbd(handle_t *handle,\r\nstruct file *file,\r\nu32 cpos, u32 old_cluster,\r\nu32 new_cluster, u32 new_len)\r\n{\r\nint ret = 0;\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct ocfs2_caching_info *ci = INODE_CACHE(inode);\r\nint i, blocks = ocfs2_clusters_to_blocks(sb, new_len);\r\nu64 old_block = ocfs2_clusters_to_blocks(sb, old_cluster);\r\nu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\nstruct buffer_head *old_bh = NULL;\r\nstruct buffer_head *new_bh = NULL;\r\ntrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\r\nnew_cluster, new_len);\r\nfor (i = 0; i < blocks; i++, old_block++, new_block++) {\r\nnew_bh = sb_getblk(osb->sb, new_block);\r\nif (new_bh == NULL) {\r\nret = -EIO;\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\nocfs2_set_new_buffer_uptodate(ci, new_bh);\r\nret = ocfs2_read_block(ci, old_block, &old_bh, NULL);\r\nif (ret) {\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\nret = ocfs2_journal_access(handle, ci, new_bh,\r\nOCFS2_JOURNAL_ACCESS_CREATE);\r\nif (ret) {\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\nmemcpy(new_bh->b_data, old_bh->b_data, sb->s_blocksize);\r\nocfs2_journal_dirty(handle, new_bh);\r\nbrelse(new_bh);\r\nbrelse(old_bh);\r\nnew_bh = NULL;\r\nold_bh = NULL;\r\n}\r\nbrelse(new_bh);\r\nbrelse(old_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_clear_ext_refcount(handle_t *handle,\r\nstruct ocfs2_extent_tree *et,\r\nu32 cpos, u32 p_cluster, u32 len,\r\nunsigned int ext_flags,\r\nstruct ocfs2_alloc_context *meta_ac,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret, index;\r\nstruct ocfs2_extent_rec replace_rec;\r\nstruct ocfs2_path *path = NULL;\r\nstruct ocfs2_extent_list *el;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\r\nu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\r\ntrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\r\ncpos, len, p_cluster, ext_flags);\r\nmemset(&replace_rec, 0, sizeof(replace_rec));\r\nreplace_rec.e_cpos = cpu_to_le32(cpos);\r\nreplace_rec.e_leaf_clusters = cpu_to_le16(len);\r\nreplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\r\np_cluster));\r\nreplace_rec.e_flags = ext_flags;\r\nreplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\r\npath = ocfs2_new_path_from_et(et);\r\nif (!path) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_find_path(et->et_ci, path, cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nel = path_leaf_el(path);\r\nindex = ocfs2_search_extent_list(el, cpos);\r\nif (index == -1 || index >= le16_to_cpu(el->l_next_free_rec)) {\r\nocfs2_error(sb,\r\n"Inode %llu has an extent at cpos %u which can no "\r\n"longer be found.\n",\r\n(unsigned long long)ino, cpos);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\nret = ocfs2_split_extent(handle, et, path, index,\r\n&replace_rec, meta_ac, dealloc);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nocfs2_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_replace_clusters(handle_t *handle,\r\nstruct ocfs2_cow_context *context,\r\nu32 cpos, u32 old,\r\nu32 new, u32 len,\r\nunsigned int ext_flags)\r\n{\r\nint ret;\r\nstruct ocfs2_caching_info *ci = context->data_et.et_ci;\r\nu64 ino = ocfs2_metadata_cache_owner(ci);\r\ntrace_ocfs2_replace_clusters((unsigned long long)ino,\r\ncpos, old, new, len, ext_flags);\r\nif (!(ext_flags & OCFS2_EXT_UNWRITTEN)) {\r\nret = context->cow_duplicate_clusters(handle, context->file,\r\ncpos, old, new, len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\nret = ocfs2_clear_ext_refcount(handle, &context->data_et,\r\ncpos, new, len, ext_flags,\r\ncontext->meta_ac, &context->dealloc);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nreturn ret;\r\n}\r\nint ocfs2_cow_sync_writeback(struct super_block *sb,\r\nstruct inode *inode,\r\nu32 cpos, u32 num_clusters)\r\n{\r\nint ret = 0;\r\nloff_t offset, end, map_end;\r\npgoff_t page_index;\r\nstruct page *page;\r\nif (ocfs2_should_order_data(inode))\r\nreturn 0;\r\noffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\r\nend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\r\nret = filemap_fdatawrite_range(inode->i_mapping,\r\noffset, end - 1);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nwhile (offset < end) {\r\npage_index = offset >> PAGE_CACHE_SHIFT;\r\nmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\r\nif (map_end > end)\r\nmap_end = end;\r\npage = find_or_create_page(inode->i_mapping,\r\npage_index, GFP_NOFS);\r\nBUG_ON(!page);\r\nwait_on_page_writeback(page);\r\nif (PageError(page)) {\r\nret = -EIO;\r\nmlog_errno(ret);\r\n} else\r\nmark_page_accessed(page);\r\nunlock_page(page);\r\npage_cache_release(page);\r\npage = NULL;\r\noffset = map_end;\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ocfs2_di_get_clusters(struct ocfs2_cow_context *context,\r\nu32 v_cluster, u32 *p_cluster,\r\nu32 *num_clusters,\r\nunsigned int *extent_flags)\r\n{\r\nreturn ocfs2_get_clusters(context->inode, v_cluster, p_cluster,\r\nnum_clusters, extent_flags);\r\n}\r\nstatic int ocfs2_make_clusters_writable(struct super_block *sb,\r\nstruct ocfs2_cow_context *context,\r\nu32 cpos, u32 p_cluster,\r\nu32 num_clusters, unsigned int e_flags)\r\n{\r\nint ret, delete, index, credits = 0;\r\nu32 new_bit, new_len, orig_num_clusters;\r\nunsigned int set_len;\r\nstruct ocfs2_super *osb = OCFS2_SB(sb);\r\nhandle_t *handle;\r\nstruct buffer_head *ref_leaf_bh = NULL;\r\nstruct ocfs2_caching_info *ref_ci = &context->ref_tree->rf_ci;\r\nstruct ocfs2_refcount_rec rec;\r\ntrace_ocfs2_make_clusters_writable(cpos, p_cluster,\r\nnum_clusters, e_flags);\r\nret = ocfs2_lock_refcount_allocators(sb, p_cluster, num_clusters,\r\n&context->data_et,\r\nref_ci,\r\ncontext->ref_root_bh,\r\n&context->meta_ac,\r\n&context->data_ac, &credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nif (context->post_refcount)\r\ncredits += context->post_refcount->credits;\r\ncredits += context->extra_credits;\r\nhandle = ocfs2_start_trans(osb, credits);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\norig_num_clusters = num_clusters;\r\nwhile (num_clusters) {\r\nret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,\r\np_cluster, num_clusters,\r\n&rec, &index, &ref_leaf_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nBUG_ON(!rec.r_refcount);\r\nset_len = min((u64)p_cluster + num_clusters,\r\nle64_to_cpu(rec.r_cpos) +\r\nle32_to_cpu(rec.r_clusters)) - p_cluster;\r\nif (le32_to_cpu(rec.r_refcount) == 1) {\r\ndelete = 0;\r\nret = ocfs2_clear_ext_refcount(handle,\r\n&context->data_et,\r\ncpos, p_cluster,\r\nset_len, e_flags,\r\ncontext->meta_ac,\r\n&context->dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\n} else {\r\ndelete = 1;\r\nret = __ocfs2_claim_clusters(handle,\r\ncontext->data_ac,\r\n1, set_len,\r\n&new_bit, &new_len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = ocfs2_replace_clusters(handle, context,\r\ncpos, p_cluster, new_bit,\r\nnew_len, e_flags);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nset_len = new_len;\r\n}\r\nret = __ocfs2_decrease_refcount(handle, ref_ci,\r\ncontext->ref_root_bh,\r\np_cluster, set_len,\r\ncontext->meta_ac,\r\n&context->dealloc, delete);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\ncpos += set_len;\r\np_cluster += set_len;\r\nnum_clusters -= set_len;\r\nbrelse(ref_leaf_bh);\r\nref_leaf_bh = NULL;\r\n}\r\nif (context->post_refcount && context->post_refcount->func) {\r\nret = context->post_refcount->func(context->inode, handle,\r\ncontext->post_refcount->para);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\n}\r\nif (context->get_clusters == ocfs2_di_get_clusters) {\r\nret = ocfs2_cow_sync_writeback(sb, context->inode, cpos,\r\norig_num_clusters);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nif (context->data_ac) {\r\nocfs2_free_alloc_context(context->data_ac);\r\ncontext->data_ac = NULL;\r\n}\r\nif (context->meta_ac) {\r\nocfs2_free_alloc_context(context->meta_ac);\r\ncontext->meta_ac = NULL;\r\n}\r\nbrelse(ref_leaf_bh);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_replace_cow(struct ocfs2_cow_context *context)\r\n{\r\nint ret = 0;\r\nstruct inode *inode = context->inode;\r\nu32 cow_start = context->cow_start, cow_len = context->cow_len;\r\nu32 p_cluster, num_clusters;\r\nunsigned int ext_flags;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\r\nocfs2_error(inode->i_sb, "Inode %lu want to use refcount "\r\n"tree, but the feature bit is not set in the "\r\n"super block.", inode->i_ino);\r\nreturn -EROFS;\r\n}\r\nocfs2_init_dealloc_ctxt(&context->dealloc);\r\nwhile (cow_len) {\r\nret = context->get_clusters(context, cow_start, &p_cluster,\r\n&num_clusters, &ext_flags);\r\nif (ret) {\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\nBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\r\nif (cow_len < num_clusters)\r\nnum_clusters = cow_len;\r\nret = ocfs2_make_clusters_writable(inode->i_sb, context,\r\ncow_start, p_cluster,\r\nnum_clusters, ext_flags);\r\nif (ret) {\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\ncow_len -= num_clusters;\r\ncow_start += num_clusters;\r\n}\r\nif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\r\nocfs2_schedule_truncate_log_flush(osb, 1);\r\nocfs2_run_deallocs(osb, &context->dealloc);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ocfs2_readahead_for_cow(struct inode *inode,\r\nstruct file *file,\r\nu32 start, u32 len)\r\n{\r\nstruct address_space *mapping;\r\npgoff_t index;\r\nunsigned long num_pages;\r\nint cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;\r\nif (!file)\r\nreturn;\r\nmapping = file->f_mapping;\r\nnum_pages = (len << cs_bits) >> PAGE_CACHE_SHIFT;\r\nif (!num_pages)\r\nnum_pages = 1;\r\nindex = ((loff_t)start << cs_bits) >> PAGE_CACHE_SHIFT;\r\npage_cache_sync_readahead(mapping, &file->f_ra, file,\r\nindex, num_pages);\r\n}\r\nstatic int ocfs2_refcount_cow_hunk(struct inode *inode,\r\nstruct file *file,\r\nstruct buffer_head *di_bh,\r\nu32 cpos, u32 write_len, u32 max_cpos)\r\n{\r\nint ret;\r\nu32 cow_start = 0, cow_len = 0;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_refcount_tree *ref_tree;\r\nstruct ocfs2_cow_context *context = NULL;\r\nBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\r\nret = ocfs2_refcount_cal_cow_clusters(inode, &di->id2.i_list,\r\ncpos, write_len, max_cpos,\r\n&cow_start, &cow_len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ntrace_ocfs2_refcount_cow_hunk(OCFS2_I(inode)->ip_blkno,\r\ncpos, write_len, max_cpos,\r\ncow_start, cow_len);\r\nBUG_ON(cow_len == 0);\r\nocfs2_readahead_for_cow(inode, file, cow_start, cow_len);\r\ncontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\r\nif (!context) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\r\n1, &ref_tree, &ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ncontext->inode = inode;\r\ncontext->cow_start = cow_start;\r\ncontext->cow_len = cow_len;\r\ncontext->ref_tree = ref_tree;\r\ncontext->ref_root_bh = ref_root_bh;\r\ncontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_page;\r\ncontext->get_clusters = ocfs2_di_get_clusters;\r\ncontext->file = file;\r\nocfs2_init_dinode_extent_tree(&context->data_et,\r\nINODE_CACHE(inode), di_bh);\r\nret = ocfs2_replace_cow(context);\r\nif (ret)\r\nmlog_errno(ret);\r\nocfs2_extent_map_trunc(inode, cow_start);\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nbrelse(ref_root_bh);\r\nout:\r\nkfree(context);\r\nreturn ret;\r\n}\r\nint ocfs2_refcount_cow(struct inode *inode,\r\nstruct file *file,\r\nstruct buffer_head *di_bh,\r\nu32 cpos, u32 write_len, u32 max_cpos)\r\n{\r\nint ret = 0;\r\nu32 p_cluster, num_clusters;\r\nunsigned int ext_flags;\r\nwhile (write_len) {\r\nret = ocfs2_get_clusters(inode, cpos, &p_cluster,\r\n&num_clusters, &ext_flags);\r\nif (ret) {\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\nif (write_len < num_clusters)\r\nnum_clusters = write_len;\r\nif (ext_flags & OCFS2_EXT_REFCOUNTED) {\r\nret = ocfs2_refcount_cow_hunk(inode, file, di_bh, cpos,\r\nnum_clusters, max_cpos);\r\nif (ret) {\r\nmlog_errno(ret);\r\nbreak;\r\n}\r\n}\r\nwrite_len -= num_clusters;\r\ncpos += num_clusters;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ocfs2_xattr_value_get_clusters(struct ocfs2_cow_context *context,\r\nu32 v_cluster, u32 *p_cluster,\r\nu32 *num_clusters,\r\nunsigned int *extent_flags)\r\n{\r\nstruct inode *inode = context->inode;\r\nstruct ocfs2_xattr_value_root *xv = context->cow_object;\r\nreturn ocfs2_xattr_get_clusters(inode, v_cluster, p_cluster,\r\nnum_clusters, &xv->xr_list,\r\nextent_flags);\r\n}\r\nint ocfs2_refcounted_xattr_delete_need(struct inode *inode,\r\nstruct ocfs2_caching_info *ref_ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct ocfs2_xattr_value_root *xv,\r\nint *meta_add, int *credits)\r\n{\r\nint ret = 0, index, ref_blocks = 0;\r\nu32 p_cluster, num_clusters;\r\nu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\r\nstruct ocfs2_refcount_block *rb;\r\nstruct ocfs2_refcount_rec rec;\r\nstruct buffer_head *ref_leaf_bh = NULL;\r\nwhile (cpos < clusters) {\r\nret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\r\n&num_clusters, &xv->xr_list,\r\nNULL);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ncpos += num_clusters;\r\nwhile (num_clusters) {\r\nret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\r\np_cluster, num_clusters,\r\n&rec, &index,\r\n&ref_leaf_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nBUG_ON(!rec.r_refcount);\r\nrb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\r\nif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\r\nle16_to_cpu(rb->rf_records.rl_count))\r\nref_blocks++;\r\n*credits += 1;\r\nbrelse(ref_leaf_bh);\r\nref_leaf_bh = NULL;\r\nif (num_clusters <= le32_to_cpu(rec.r_clusters))\r\nbreak;\r\nelse\r\nnum_clusters -= le32_to_cpu(rec.r_clusters);\r\np_cluster += num_clusters;\r\n}\r\n}\r\n*meta_add += ref_blocks;\r\nif (!ref_blocks)\r\ngoto out;\r\nrb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\r\n*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\r\nelse {\r\nstruct ocfs2_extent_tree et;\r\nocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\r\n*credits += ocfs2_calc_extend_credits(inode->i_sb,\r\net.et_root_el,\r\nref_blocks);\r\n}\r\nout:\r\nbrelse(ref_leaf_bh);\r\nreturn ret;\r\n}\r\nint ocfs2_refcount_cow_xattr(struct inode *inode,\r\nstruct ocfs2_dinode *di,\r\nstruct ocfs2_xattr_value_buf *vb,\r\nstruct ocfs2_refcount_tree *ref_tree,\r\nstruct buffer_head *ref_root_bh,\r\nu32 cpos, u32 write_len,\r\nstruct ocfs2_post_refcount *post)\r\n{\r\nint ret;\r\nstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_cow_context *context = NULL;\r\nu32 cow_start, cow_len;\r\nBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\r\nret = ocfs2_refcount_cal_cow_clusters(inode, &xv->xr_list,\r\ncpos, write_len, UINT_MAX,\r\n&cow_start, &cow_len);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nBUG_ON(cow_len == 0);\r\ncontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\r\nif (!context) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ncontext->inode = inode;\r\ncontext->cow_start = cow_start;\r\ncontext->cow_len = cow_len;\r\ncontext->ref_tree = ref_tree;\r\ncontext->ref_root_bh = ref_root_bh;\r\ncontext->cow_object = xv;\r\ncontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_jbd;\r\ncontext->extra_credits =\r\nocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;\r\ncontext->get_clusters = ocfs2_xattr_value_get_clusters;\r\ncontext->post_refcount = post;\r\nocfs2_init_xattr_value_extent_tree(&context->data_et,\r\nINODE_CACHE(inode), vb);\r\nret = ocfs2_replace_cow(context);\r\nif (ret)\r\nmlog_errno(ret);\r\nout:\r\nkfree(context);\r\nreturn ret;\r\n}\r\nint ocfs2_add_refcount_flag(struct inode *inode,\r\nstruct ocfs2_extent_tree *data_et,\r\nstruct ocfs2_caching_info *ref_ci,\r\nstruct buffer_head *ref_root_bh,\r\nu32 cpos, u32 p_cluster, u32 num_clusters,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc,\r\nstruct ocfs2_post_refcount *post)\r\n{\r\nint ret;\r\nhandle_t *handle;\r\nint credits = 1, ref_blocks = 0;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct ocfs2_alloc_context *meta_ac = NULL;\r\nret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\r\nref_ci, ref_root_bh,\r\np_cluster, num_clusters,\r\n&ref_blocks, &credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ntrace_ocfs2_add_refcount_flag(ref_blocks, credits);\r\nif (ref_blocks) {\r\nret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\r\nref_blocks, &meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\nif (post)\r\ncredits += post->credits;\r\nhandle = ocfs2_start_trans(osb, credits);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\r\ncpos, num_clusters, p_cluster,\r\nmeta_ac, dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\r\np_cluster, num_clusters, 0,\r\nmeta_ac, dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nif (post && post->func) {\r\nret = post->func(inode, handle, post->para);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nif (meta_ac)\r\nocfs2_free_alloc_context(meta_ac);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_change_ctime(struct inode *inode,\r\nstruct buffer_head *di_bh)\r\n{\r\nint ret;\r\nhandle_t *handle;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nhandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\r\nOCFS2_INODE_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\ninode->i_ctime = CURRENT_TIME;\r\ndi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\r\ndi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\r\nocfs2_journal_dirty(handle, di_bh);\r\nout_commit:\r\nocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_attach_refcount_tree(struct inode *inode,\r\nstruct buffer_head *di_bh)\r\n{\r\nint ret, data_changed = 0;\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct ocfs2_refcount_tree *ref_tree;\r\nunsigned int ext_flags;\r\nloff_t size;\r\nu32 cpos, num_clusters, clusters, p_cluster;\r\nstruct ocfs2_cached_dealloc_ctxt dealloc;\r\nstruct ocfs2_extent_tree di_et;\r\nocfs2_init_dealloc_ctxt(&dealloc);\r\nif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)) {\r\nret = ocfs2_create_refcount_tree(inode, di_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\nBUG_ON(!di->i_refcount_loc);\r\nret = ocfs2_lock_refcount_tree(osb,\r\nle64_to_cpu(di->i_refcount_loc), 1,\r\n&ref_tree, &ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\r\ngoto attach_xattr;\r\nocfs2_init_dinode_extent_tree(&di_et, INODE_CACHE(inode), di_bh);\r\nsize = i_size_read(inode);\r\nclusters = ocfs2_clusters_for_bytes(inode->i_sb, size);\r\ncpos = 0;\r\nwhile (cpos < clusters) {\r\nret = ocfs2_get_clusters(inode, cpos, &p_cluster,\r\n&num_clusters, &ext_flags);\r\nif (p_cluster && !(ext_flags & OCFS2_EXT_REFCOUNTED)) {\r\nret = ocfs2_add_refcount_flag(inode, &di_et,\r\n&ref_tree->rf_ci,\r\nref_root_bh, cpos,\r\np_cluster, num_clusters,\r\n&dealloc, NULL);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto unlock;\r\n}\r\ndata_changed = 1;\r\n}\r\ncpos += num_clusters;\r\n}\r\nattach_xattr:\r\nif (oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\r\nret = ocfs2_xattr_attach_refcount_tree(inode, di_bh,\r\n&ref_tree->rf_ci,\r\nref_root_bh,\r\n&dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto unlock;\r\n}\r\n}\r\nif (data_changed) {\r\nret = ocfs2_change_ctime(inode, di_bh);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nunlock:\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nbrelse(ref_root_bh);\r\nif (!ret && ocfs2_dealloc_has_cluster(&dealloc)) {\r\nocfs2_schedule_truncate_log_flush(osb, 1);\r\nocfs2_run_deallocs(osb, &dealloc);\r\n}\r\nout:\r\nocfs2_extent_map_trunc(inode, 0);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_add_refcounted_extent(struct inode *inode,\r\nstruct ocfs2_extent_tree *et,\r\nstruct ocfs2_caching_info *ref_ci,\r\nstruct buffer_head *ref_root_bh,\r\nu32 cpos, u32 p_cluster, u32 num_clusters,\r\nunsigned int ext_flags,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret;\r\nhandle_t *handle;\r\nint credits = 0;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct ocfs2_alloc_context *meta_ac = NULL;\r\nret = ocfs2_lock_refcount_allocators(inode->i_sb,\r\np_cluster, num_clusters,\r\net, ref_ci,\r\nref_root_bh, &meta_ac,\r\nNULL, &credits);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nhandle = ocfs2_start_trans(osb, credits);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_insert_extent(handle, et, cpos,\r\nocfs2_clusters_to_blocks(inode->i_sb, p_cluster),\r\nnum_clusters, ext_flags, meta_ac);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nret = ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\r\np_cluster, num_clusters,\r\nmeta_ac, dealloc);\r\nif (ret)\r\nmlog_errno(ret);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nif (meta_ac)\r\nocfs2_free_alloc_context(meta_ac);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_duplicate_inline_data(struct inode *s_inode,\r\nstruct buffer_head *s_bh,\r\nstruct inode *t_inode,\r\nstruct buffer_head *t_bh)\r\n{\r\nint ret;\r\nhandle_t *handle;\r\nstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\r\nstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\r\nstruct ocfs2_dinode *t_di = (struct ocfs2_dinode *)t_bh->b_data;\r\nBUG_ON(!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\r\nhandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nt_di->id2.i_data.id_count = s_di->id2.i_data.id_count;\r\nmemcpy(t_di->id2.i_data.id_data, s_di->id2.i_data.id_data,\r\nle16_to_cpu(s_di->id2.i_data.id_count));\r\nspin_lock(&OCFS2_I(t_inode)->ip_lock);\r\nOCFS2_I(t_inode)->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\r\nt_di->i_dyn_features = cpu_to_le16(OCFS2_I(t_inode)->ip_dyn_features);\r\nspin_unlock(&OCFS2_I(t_inode)->ip_lock);\r\nocfs2_journal_dirty(handle, t_bh);\r\nout_commit:\r\nocfs2_commit_trans(osb, handle);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_duplicate_extent_list(struct inode *s_inode,\r\nstruct inode *t_inode,\r\nstruct buffer_head *t_bh,\r\nstruct ocfs2_caching_info *ref_ci,\r\nstruct buffer_head *ref_root_bh,\r\nstruct ocfs2_cached_dealloc_ctxt *dealloc)\r\n{\r\nint ret = 0;\r\nu32 p_cluster, num_clusters, clusters, cpos;\r\nloff_t size;\r\nunsigned int ext_flags;\r\nstruct ocfs2_extent_tree et;\r\nocfs2_init_dinode_extent_tree(&et, INODE_CACHE(t_inode), t_bh);\r\nsize = i_size_read(s_inode);\r\nclusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);\r\ncpos = 0;\r\nwhile (cpos < clusters) {\r\nret = ocfs2_get_clusters(s_inode, cpos, &p_cluster,\r\n&num_clusters, &ext_flags);\r\nif (p_cluster) {\r\nret = ocfs2_add_refcounted_extent(t_inode, &et,\r\nref_ci, ref_root_bh,\r\ncpos, p_cluster,\r\nnum_clusters,\r\next_flags,\r\ndealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\n}\r\ncpos += num_clusters;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_complete_reflink(struct inode *s_inode,\r\nstruct buffer_head *s_bh,\r\nstruct inode *t_inode,\r\nstruct buffer_head *t_bh,\r\nbool preserve)\r\n{\r\nint ret;\r\nhandle_t *handle;\r\nstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)t_bh->b_data;\r\nloff_t size = i_size_read(s_inode);\r\nhandle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),\r\nOCFS2_INODE_UPDATE_CREDITS);\r\nif (IS_ERR(handle)) {\r\nret = PTR_ERR(handle);\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\r\nOCFS2_JOURNAL_ACCESS_WRITE);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_commit;\r\n}\r\nspin_lock(&OCFS2_I(t_inode)->ip_lock);\r\nOCFS2_I(t_inode)->ip_clusters = OCFS2_I(s_inode)->ip_clusters;\r\nOCFS2_I(t_inode)->ip_attr = OCFS2_I(s_inode)->ip_attr;\r\nOCFS2_I(t_inode)->ip_dyn_features = OCFS2_I(s_inode)->ip_dyn_features;\r\nspin_unlock(&OCFS2_I(t_inode)->ip_lock);\r\ni_size_write(t_inode, size);\r\nt_inode->i_blocks = s_inode->i_blocks;\r\ndi->i_xattr_inline_size = s_di->i_xattr_inline_size;\r\ndi->i_clusters = s_di->i_clusters;\r\ndi->i_size = s_di->i_size;\r\ndi->i_dyn_features = s_di->i_dyn_features;\r\ndi->i_attr = s_di->i_attr;\r\nif (preserve) {\r\nt_inode->i_uid = s_inode->i_uid;\r\nt_inode->i_gid = s_inode->i_gid;\r\nt_inode->i_mode = s_inode->i_mode;\r\ndi->i_uid = s_di->i_uid;\r\ndi->i_gid = s_di->i_gid;\r\ndi->i_mode = s_di->i_mode;\r\nt_inode->i_ctime = CURRENT_TIME;\r\ndi->i_ctime = cpu_to_le64(t_inode->i_ctime.tv_sec);\r\ndi->i_ctime_nsec = cpu_to_le32(t_inode->i_ctime.tv_nsec);\r\nt_inode->i_mtime = s_inode->i_mtime;\r\ndi->i_mtime = s_di->i_mtime;\r\ndi->i_mtime_nsec = s_di->i_mtime_nsec;\r\n}\r\nocfs2_journal_dirty(handle, t_bh);\r\nout_commit:\r\nocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_create_reflink_node(struct inode *s_inode,\r\nstruct buffer_head *s_bh,\r\nstruct inode *t_inode,\r\nstruct buffer_head *t_bh,\r\nbool preserve)\r\n{\r\nint ret;\r\nstruct buffer_head *ref_root_bh = NULL;\r\nstruct ocfs2_cached_dealloc_ctxt dealloc;\r\nstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\r\nstruct ocfs2_refcount_block *rb;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)s_bh->b_data;\r\nstruct ocfs2_refcount_tree *ref_tree;\r\nocfs2_init_dealloc_ctxt(&dealloc);\r\nret = ocfs2_set_refcount_tree(t_inode, t_bh,\r\nle64_to_cpu(di->i_refcount_loc));\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nif (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\r\nret = ocfs2_duplicate_inline_data(s_inode, s_bh,\r\nt_inode, t_bh);\r\nif (ret)\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\r\n1, &ref_tree, &ref_root_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nrb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\r\nret = ocfs2_duplicate_extent_list(s_inode, t_inode, t_bh,\r\n&ref_tree->rf_ci, ref_root_bh,\r\n&dealloc);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_unlock_refcount;\r\n}\r\nout_unlock_refcount:\r\nocfs2_unlock_refcount_tree(osb, ref_tree, 1);\r\nbrelse(ref_root_bh);\r\nout:\r\nif (ocfs2_dealloc_has_cluster(&dealloc)) {\r\nocfs2_schedule_truncate_log_flush(osb, 1);\r\nocfs2_run_deallocs(osb, &dealloc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __ocfs2_reflink(struct dentry *old_dentry,\r\nstruct buffer_head *old_bh,\r\nstruct inode *new_inode,\r\nbool preserve)\r\n{\r\nint ret;\r\nstruct inode *inode = old_dentry->d_inode;\r\nstruct buffer_head *new_bh = NULL;\r\nif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\r\nret = -EINVAL;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = filemap_fdatawrite(inode->i_mapping);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_attach_refcount_tree(inode, old_bh);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nmutex_lock_nested(&new_inode->i_mutex, I_MUTEX_CHILD);\r\nret = ocfs2_inode_lock_nested(new_inode, &new_bh, 1,\r\nOI_LS_REFLINK_TARGET);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out_unlock;\r\n}\r\nret = ocfs2_create_reflink_node(inode, old_bh,\r\nnew_inode, new_bh, preserve);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto inode_unlock;\r\n}\r\nif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\r\nret = ocfs2_reflink_xattrs(inode, old_bh,\r\nnew_inode, new_bh,\r\npreserve);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto inode_unlock;\r\n}\r\n}\r\nret = ocfs2_complete_reflink(inode, old_bh,\r\nnew_inode, new_bh, preserve);\r\nif (ret)\r\nmlog_errno(ret);\r\ninode_unlock:\r\nocfs2_inode_unlock(new_inode, 1);\r\nbrelse(new_bh);\r\nout_unlock:\r\nmutex_unlock(&new_inode->i_mutex);\r\nout:\r\nif (!ret) {\r\nret = filemap_fdatawait(inode->i_mapping);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,\r\nstruct dentry *new_dentry, bool preserve)\r\n{\r\nint error;\r\nstruct inode *inode = old_dentry->d_inode;\r\nstruct buffer_head *old_bh = NULL;\r\nstruct inode *new_orphan_inode = NULL;\r\nif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\r\nreturn -EOPNOTSUPP;\r\nerror = ocfs2_create_inode_in_orphan(dir, inode->i_mode,\r\n&new_orphan_inode);\r\nif (error) {\r\nmlog_errno(error);\r\ngoto out;\r\n}\r\nerror = ocfs2_inode_lock(inode, &old_bh, 1);\r\nif (error) {\r\nmlog_errno(error);\r\ngoto out;\r\n}\r\ndown_write(&OCFS2_I(inode)->ip_xattr_sem);\r\ndown_write(&OCFS2_I(inode)->ip_alloc_sem);\r\nerror = __ocfs2_reflink(old_dentry, old_bh,\r\nnew_orphan_inode, preserve);\r\nup_write(&OCFS2_I(inode)->ip_alloc_sem);\r\nup_write(&OCFS2_I(inode)->ip_xattr_sem);\r\nocfs2_inode_unlock(inode, 1);\r\nbrelse(old_bh);\r\nif (error) {\r\nmlog_errno(error);\r\ngoto out;\r\n}\r\nif (!preserve) {\r\nerror = ocfs2_init_security_and_acl(dir, new_orphan_inode,\r\n&new_dentry->d_name);\r\nif (error)\r\nmlog_errno(error);\r\n}\r\nout:\r\nif (!error) {\r\nerror = ocfs2_mv_orphaned_inode_to_new(dir, new_orphan_inode,\r\nnew_dentry);\r\nif (error)\r\nmlog_errno(error);\r\n}\r\nif (new_orphan_inode) {\r\nocfs2_open_unlock(new_orphan_inode);\r\nif (error)\r\niput(new_orphan_inode);\r\n}\r\nreturn error;\r\n}\r\nstatic inline int ocfs2_may_create(struct inode *dir, struct dentry *child)\r\n{\r\nif (child->d_inode)\r\nreturn -EEXIST;\r\nif (IS_DEADDIR(dir))\r\nreturn -ENOENT;\r\nreturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\r\n}\r\nstatic int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,\r\nstruct dentry *new_dentry, bool preserve)\r\n{\r\nstruct inode *inode = old_dentry->d_inode;\r\nint error;\r\nif (!inode)\r\nreturn -ENOENT;\r\nerror = ocfs2_may_create(dir, new_dentry);\r\nif (error)\r\nreturn error;\r\nif (dir->i_sb != inode->i_sb)\r\nreturn -EXDEV;\r\nif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\r\nreturn -EPERM;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EPERM;\r\nif (preserve) {\r\nif ((current_fsuid() != inode->i_uid) && !capable(CAP_CHOWN))\r\nreturn -EPERM;\r\nif (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))\r\nreturn -EPERM;\r\n}\r\nif (!preserve) {\r\nerror = inode_permission(inode, MAY_READ);\r\nif (error)\r\nreturn error;\r\n}\r\nmutex_lock(&inode->i_mutex);\r\ndquot_initialize(dir);\r\nerror = ocfs2_reflink(old_dentry, dir, new_dentry, preserve);\r\nmutex_unlock(&inode->i_mutex);\r\nif (!error)\r\nfsnotify_create(dir, new_dentry);\r\nreturn error;\r\n}\r\nint ocfs2_reflink_ioctl(struct inode *inode,\r\nconst char __user *oldname,\r\nconst char __user *newname,\r\nbool preserve)\r\n{\r\nstruct dentry *new_dentry;\r\nstruct path old_path, new_path;\r\nint error;\r\nif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\r\nreturn -EOPNOTSUPP;\r\nerror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\r\nif (error) {\r\nmlog_errno(error);\r\nreturn error;\r\n}\r\nnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\r\nerror = PTR_ERR(new_dentry);\r\nif (IS_ERR(new_dentry)) {\r\nmlog_errno(error);\r\ngoto out;\r\n}\r\nerror = -EXDEV;\r\nif (old_path.mnt != new_path.mnt) {\r\nmlog_errno(error);\r\ngoto out_dput;\r\n}\r\nerror = mnt_want_write(new_path.mnt);\r\nif (error) {\r\nmlog_errno(error);\r\ngoto out_dput;\r\n}\r\nerror = ocfs2_vfs_reflink(old_path.dentry,\r\nnew_path.dentry->d_inode,\r\nnew_dentry, preserve);\r\nmnt_drop_write(new_path.mnt);\r\nout_dput:\r\ndput(new_dentry);\r\nmutex_unlock(&new_path.dentry->d_inode->i_mutex);\r\npath_put(&new_path);\r\nout:\r\npath_put(&old_path);\r\nreturn error;\r\n}
