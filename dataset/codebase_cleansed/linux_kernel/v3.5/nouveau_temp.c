static void\r\nnouveau_temp_vbios_parse(struct drm_device *dev, u8 *temp)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_temp_sensor_constants *sensor = &pm->sensor_constants;\r\nstruct nouveau_pm_threshold_temp *temps = &pm->threshold_temp;\r\nint i, headerlen, recordlen, entries;\r\nif (!temp) {\r\nNV_DEBUG(dev, "temperature table pointer invalid\n");\r\nreturn;\r\n}\r\nsensor->offset_constant = 0;\r\nsensor->offset_mult = 0;\r\nsensor->offset_div = 1;\r\nsensor->slope_mult = 1;\r\nsensor->slope_div = 1;\r\ntemps->critical = 110;\r\ntemps->down_clock = 100;\r\ntemps->fan_boost = 90;\r\npm->fan.min_duty = 30;\r\npm->fan.max_duty = 100;\r\nif (dev_priv->card_type >= NV_40) {\r\nswitch (dev_priv->chipset) {\r\ncase 0x43:\r\nsensor->offset_mult = 32060;\r\nsensor->offset_div = 1000;\r\nsensor->slope_mult = 792;\r\nsensor->slope_div = 1000;\r\nbreak;\r\ncase 0x44:\r\ncase 0x47:\r\ncase 0x4a:\r\nsensor->offset_mult = 27839;\r\nsensor->offset_div = 1000;\r\nsensor->slope_mult = 780;\r\nsensor->slope_div = 1000;\r\nbreak;\r\ncase 0x46:\r\nsensor->offset_mult = -24775;\r\nsensor->offset_div = 100;\r\nsensor->slope_mult = 467;\r\nsensor->slope_div = 10000;\r\nbreak;\r\ncase 0x49:\r\nsensor->offset_mult = -25051;\r\nsensor->offset_div = 100;\r\nsensor->slope_mult = 458;\r\nsensor->slope_div = 10000;\r\nbreak;\r\ncase 0x4b:\r\nsensor->offset_mult = -24088;\r\nsensor->offset_div = 100;\r\nsensor->slope_mult = 442;\r\nsensor->slope_div = 10000;\r\nbreak;\r\ncase 0x50:\r\nsensor->offset_mult = -22749;\r\nsensor->offset_div = 100;\r\nsensor->slope_mult = 431;\r\nsensor->slope_div = 10000;\r\nbreak;\r\ncase 0x67:\r\nsensor->offset_mult = -26149;\r\nsensor->offset_div = 100;\r\nsensor->slope_mult = 484;\r\nsensor->slope_div = 10000;\r\nbreak;\r\n}\r\n}\r\nheaderlen = temp[1];\r\nrecordlen = temp[2];\r\nentries = temp[3];\r\ntemp = temp + headerlen;\r\nfor (i = 0; i < entries; i++) {\r\ns16 value = ROM16(temp[1]);\r\nswitch (temp[0]) {\r\ncase 0x01:\r\nif ((value & 0x8f) == 0)\r\nsensor->offset_constant = (value >> 9) & 0x7f;\r\nbreak;\r\ncase 0x04:\r\nif ((value & 0xf00f) == 0xa000)\r\ntemps->critical = (value&0x0ff0) >> 4;\r\nbreak;\r\ncase 0x07:\r\nif ((value & 0xf00f) == 0xa000)\r\ntemps->down_clock = (value&0x0ff0) >> 4;\r\nbreak;\r\ncase 0x08:\r\nif ((value & 0xf00f) == 0xa000)\r\ntemps->fan_boost = (value&0x0ff0) >> 4;\r\nbreak;\r\ncase 0x10:\r\nsensor->offset_mult = value;\r\nbreak;\r\ncase 0x11:\r\nsensor->offset_div = value;\r\nbreak;\r\ncase 0x12:\r\nsensor->slope_mult = value;\r\nbreak;\r\ncase 0x13:\r\nsensor->slope_div = value;\r\nbreak;\r\ncase 0x22:\r\npm->fan.min_duty = value & 0xff;\r\npm->fan.max_duty = (value & 0xff00) >> 8;\r\nbreak;\r\ncase 0x26:\r\npm->fan.pwm_freq = value;\r\nbreak;\r\n}\r\ntemp += recordlen;\r\n}\r\nnouveau_temp_safety_checks(dev);\r\nif (pm->fan.min_duty < 10)\r\npm->fan.min_duty = 10;\r\nif (pm->fan.max_duty > 100)\r\npm->fan.max_duty = 100;\r\nif (pm->fan.max_duty < pm->fan.min_duty)\r\npm->fan.max_duty = pm->fan.min_duty;\r\n}\r\nstatic int\r\nnv40_sensor_setup(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_temp_sensor_constants *sensor = &pm->sensor_constants;\r\ns32 offset = sensor->offset_mult / sensor->offset_div;\r\ns32 sensor_calibration;\r\nsensor_calibration = 120 - offset - sensor->offset_constant;\r\nsensor_calibration = sensor_calibration * sensor->slope_div /\r\nsensor->slope_mult;\r\nif (dev_priv->chipset >= 0x46)\r\nsensor_calibration |= 0x80000000;\r\nelse\r\nsensor_calibration |= 0x10000000;\r\nnv_wr32(dev, 0x0015b0, sensor_calibration);\r\nmsleep(5);\r\nreturn nv_rd32(dev, 0x0015b4) & 0x1fff;\r\n}\r\nint\r\nnv40_temp_get(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_temp_sensor_constants *sensor = &pm->sensor_constants;\r\nint offset = sensor->offset_mult / sensor->offset_div;\r\nint core_temp;\r\nif (dev_priv->card_type >= NV_50) {\r\ncore_temp = nv_rd32(dev, 0x20008);\r\n} else {\r\ncore_temp = nv_rd32(dev, 0x0015b4) & 0x1fff;\r\nif (core_temp == 0)\r\ncore_temp = nv40_sensor_setup(dev);\r\n}\r\ncore_temp = core_temp * sensor->slope_mult / sensor->slope_div;\r\ncore_temp = core_temp + offset + sensor->offset_constant;\r\nreturn core_temp;\r\n}\r\nint\r\nnv84_temp_get(struct drm_device *dev)\r\n{\r\nreturn nv_rd32(dev, 0x20400);\r\n}\r\nvoid\r\nnouveau_temp_safety_checks(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_pm_engine *pm = &dev_priv->engine.pm;\r\nstruct nouveau_pm_threshold_temp *temps = &pm->threshold_temp;\r\nif (temps->critical > 120)\r\ntemps->critical = 120;\r\nelse if (temps->critical < 80)\r\ntemps->critical = 80;\r\nif (temps->down_clock > 110)\r\ntemps->down_clock = 110;\r\nelse if (temps->down_clock < 60)\r\ntemps->down_clock = 60;\r\nif (temps->fan_boost > 100)\r\ntemps->fan_boost = 100;\r\nelse if (temps->fan_boost < 40)\r\ntemps->fan_boost = 40;\r\n}\r\nstatic bool\r\nprobe_monitoring_device(struct nouveau_i2c_chan *i2c,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_client *client;\r\nrequest_module("%s%s", I2C_MODULE_PREFIX, info->type);\r\nclient = i2c_new_device(&i2c->adapter, info);\r\nif (!client)\r\nreturn false;\r\nif (!client->driver || client->driver->detect(client, info)) {\r\ni2c_unregister_device(client);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nnouveau_temp_probe_i2c(struct drm_device *dev)\r\n{\r\nstruct i2c_board_info info[] = {\r\n{ I2C_BOARD_INFO("w83l785ts", 0x2d) },\r\n{ I2C_BOARD_INFO("w83781d", 0x2d) },\r\n{ I2C_BOARD_INFO("adt7473", 0x2e) },\r\n{ I2C_BOARD_INFO("f75375", 0x2e) },\r\n{ I2C_BOARD_INFO("lm99", 0x4c) },\r\n{ }\r\n};\r\nnouveau_i2c_identify(dev, "monitoring device", info,\r\nprobe_monitoring_device, NV_I2C_DEFAULT(0));\r\n}\r\nvoid\r\nnouveau_temp_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nvbios *bios = &dev_priv->vbios;\r\nstruct bit_entry P;\r\nu8 *temp = NULL;\r\nif (bios->type == NVBIOS_BIT) {\r\nif (bit_table(dev, 'P', &P))\r\nreturn;\r\nif (P.version == 1)\r\ntemp = ROMPTR(dev, P.data[12]);\r\nelse if (P.version == 2)\r\ntemp = ROMPTR(dev, P.data[16]);\r\nelse\r\nNV_WARN(dev, "unknown temp for BIT P %d\n", P.version);\r\nnouveau_temp_vbios_parse(dev, temp);\r\n}\r\nnouveau_temp_probe_i2c(dev);\r\n}\r\nvoid\r\nnouveau_temp_fini(struct drm_device *dev)\r\n{\r\n}
