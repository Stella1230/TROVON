static int tea_setkey(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *key = (const __le32 *)in_key;\r\nctx->KEY[0] = le32_to_cpu(key[0]);\r\nctx->KEY[1] = le32_to_cpu(key[1]);\r\nctx->KEY[2] = le32_to_cpu(key[2]);\r\nctx->KEY[3] = le32_to_cpu(key[3]);\r\nreturn 0;\r\n}\r\nstatic void tea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nu32 y, z, n, sum = 0;\r\nu32 k0, k1, k2, k3;\r\nstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *in = (const __le32 *)src;\r\n__le32 *out = (__le32 *)dst;\r\ny = le32_to_cpu(in[0]);\r\nz = le32_to_cpu(in[1]);\r\nk0 = ctx->KEY[0];\r\nk1 = ctx->KEY[1];\r\nk2 = ctx->KEY[2];\r\nk3 = ctx->KEY[3];\r\nn = TEA_ROUNDS;\r\nwhile (n-- > 0) {\r\nsum += TEA_DELTA;\r\ny += ((z << 4) + k0) ^ (z + sum) ^ ((z >> 5) + k1);\r\nz += ((y << 4) + k2) ^ (y + sum) ^ ((y >> 5) + k3);\r\n}\r\nout[0] = cpu_to_le32(y);\r\nout[1] = cpu_to_le32(z);\r\n}\r\nstatic void tea_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nu32 y, z, n, sum;\r\nu32 k0, k1, k2, k3;\r\nstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *in = (const __le32 *)src;\r\n__le32 *out = (__le32 *)dst;\r\ny = le32_to_cpu(in[0]);\r\nz = le32_to_cpu(in[1]);\r\nk0 = ctx->KEY[0];\r\nk1 = ctx->KEY[1];\r\nk2 = ctx->KEY[2];\r\nk3 = ctx->KEY[3];\r\nsum = TEA_DELTA << 5;\r\nn = TEA_ROUNDS;\r\nwhile (n-- > 0) {\r\nz -= ((y << 4) + k2) ^ (y + sum) ^ ((y >> 5) + k3);\r\ny -= ((z << 4) + k0) ^ (z + sum) ^ ((z >> 5) + k1);\r\nsum -= TEA_DELTA;\r\n}\r\nout[0] = cpu_to_le32(y);\r\nout[1] = cpu_to_le32(z);\r\n}\r\nstatic int xtea_setkey(struct crypto_tfm *tfm, const u8 *in_key,\r\nunsigned int key_len)\r\n{\r\nstruct xtea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *key = (const __le32 *)in_key;\r\nctx->KEY[0] = le32_to_cpu(key[0]);\r\nctx->KEY[1] = le32_to_cpu(key[1]);\r\nctx->KEY[2] = le32_to_cpu(key[2]);\r\nctx->KEY[3] = le32_to_cpu(key[3]);\r\nreturn 0;\r\n}\r\nstatic void xtea_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nu32 y, z, sum = 0;\r\nu32 limit = XTEA_DELTA * XTEA_ROUNDS;\r\nstruct xtea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *in = (const __le32 *)src;\r\n__le32 *out = (__le32 *)dst;\r\ny = le32_to_cpu(in[0]);\r\nz = le32_to_cpu(in[1]);\r\nwhile (sum != limit) {\r\ny += ((z << 4 ^ z >> 5) + z) ^ (sum + ctx->KEY[sum&3]);\r\nsum += XTEA_DELTA;\r\nz += ((y << 4 ^ y >> 5) + y) ^ (sum + ctx->KEY[sum>>11 &3]);\r\n}\r\nout[0] = cpu_to_le32(y);\r\nout[1] = cpu_to_le32(z);\r\n}\r\nstatic void xtea_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nu32 y, z, sum;\r\nstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *in = (const __le32 *)src;\r\n__le32 *out = (__le32 *)dst;\r\ny = le32_to_cpu(in[0]);\r\nz = le32_to_cpu(in[1]);\r\nsum = XTEA_DELTA * XTEA_ROUNDS;\r\nwhile (sum) {\r\nz -= ((y << 4 ^ y >> 5) + y) ^ (sum + ctx->KEY[sum>>11 & 3]);\r\nsum -= XTEA_DELTA;\r\ny -= ((z << 4 ^ z >> 5) + z) ^ (sum + ctx->KEY[sum & 3]);\r\n}\r\nout[0] = cpu_to_le32(y);\r\nout[1] = cpu_to_le32(z);\r\n}\r\nstatic void xeta_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nu32 y, z, sum = 0;\r\nu32 limit = XTEA_DELTA * XTEA_ROUNDS;\r\nstruct xtea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *in = (const __le32 *)src;\r\n__le32 *out = (__le32 *)dst;\r\ny = le32_to_cpu(in[0]);\r\nz = le32_to_cpu(in[1]);\r\nwhile (sum != limit) {\r\ny += (z << 4 ^ z >> 5) + (z ^ sum) + ctx->KEY[sum&3];\r\nsum += XTEA_DELTA;\r\nz += (y << 4 ^ y >> 5) + (y ^ sum) + ctx->KEY[sum>>11 &3];\r\n}\r\nout[0] = cpu_to_le32(y);\r\nout[1] = cpu_to_le32(z);\r\n}\r\nstatic void xeta_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\r\n{\r\nu32 y, z, sum;\r\nstruct tea_ctx *ctx = crypto_tfm_ctx(tfm);\r\nconst __le32 *in = (const __le32 *)src;\r\n__le32 *out = (__le32 *)dst;\r\ny = le32_to_cpu(in[0]);\r\nz = le32_to_cpu(in[1]);\r\nsum = XTEA_DELTA * XTEA_ROUNDS;\r\nwhile (sum) {\r\nz -= (y << 4 ^ y >> 5) + (y ^ sum) + ctx->KEY[sum>>11 & 3];\r\nsum -= XTEA_DELTA;\r\ny -= (z << 4 ^ z >> 5) + (z ^ sum) + ctx->KEY[sum & 3];\r\n}\r\nout[0] = cpu_to_le32(y);\r\nout[1] = cpu_to_le32(z);\r\n}\r\nstatic int __init tea_mod_init(void)\r\n{\r\nint ret = 0;\r\nret = crypto_register_alg(&tea_alg);\r\nif (ret < 0)\r\ngoto out;\r\nret = crypto_register_alg(&xtea_alg);\r\nif (ret < 0) {\r\ncrypto_unregister_alg(&tea_alg);\r\ngoto out;\r\n}\r\nret = crypto_register_alg(&xeta_alg);\r\nif (ret < 0) {\r\ncrypto_unregister_alg(&tea_alg);\r\ncrypto_unregister_alg(&xtea_alg);\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit tea_mod_fini(void)\r\n{\r\ncrypto_unregister_alg(&tea_alg);\r\ncrypto_unregister_alg(&xtea_alg);\r\ncrypto_unregister_alg(&xeta_alg);\r\n}
