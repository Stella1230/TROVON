static irqreturn_t sabre_ue_intr(int irq, void *dev_id)\r\n{\r\nstruct pci_pbm_info *pbm = dev_id;\r\nunsigned long afsr_reg = pbm->controller_regs + SABRE_UE_AFSR;\r\nunsigned long afar_reg = pbm->controller_regs + SABRE_UECE_AFAR;\r\nunsigned long afsr, afar, error_bits;\r\nint reported;\r\nafar = upa_readq(afar_reg);\r\nafsr = upa_readq(afsr_reg);\r\nerror_bits = afsr &\r\n(SABRE_UEAFSR_PDRD | SABRE_UEAFSR_PDWR |\r\nSABRE_UEAFSR_SDRD | SABRE_UEAFSR_SDWR |\r\nSABRE_UEAFSR_SDTE | SABRE_UEAFSR_PDTE);\r\nif (!error_bits)\r\nreturn IRQ_NONE;\r\nupa_writeq(error_bits, afsr_reg);\r\nprintk("%s: Uncorrectable Error, primary error type[%s%s]\n",\r\npbm->name,\r\n((error_bits & SABRE_UEAFSR_PDRD) ?\r\n"DMA Read" :\r\n((error_bits & SABRE_UEAFSR_PDWR) ?\r\n"DMA Write" : "???")),\r\n((error_bits & SABRE_UEAFSR_PDTE) ?\r\n":Translation Error" : ""));\r\nprintk("%s: bytemask[%04lx] dword_offset[%lx] was_block(%d)\n",\r\npbm->name,\r\n(afsr & SABRE_UEAFSR_BMSK) >> 32UL,\r\n(afsr & SABRE_UEAFSR_OFF) >> 29UL,\r\n((afsr & SABRE_UEAFSR_BLK) ? 1 : 0));\r\nprintk("%s: UE AFAR [%016lx]\n", pbm->name, afar);\r\nprintk("%s: UE Secondary errors [", pbm->name);\r\nreported = 0;\r\nif (afsr & SABRE_UEAFSR_SDRD) {\r\nreported++;\r\nprintk("(DMA Read)");\r\n}\r\nif (afsr & SABRE_UEAFSR_SDWR) {\r\nreported++;\r\nprintk("(DMA Write)");\r\n}\r\nif (afsr & SABRE_UEAFSR_SDTE) {\r\nreported++;\r\nprintk("(Translation Error)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\npsycho_check_iommu_error(pbm, afsr, afar, UE_ERR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sabre_ce_intr(int irq, void *dev_id)\r\n{\r\nstruct pci_pbm_info *pbm = dev_id;\r\nunsigned long afsr_reg = pbm->controller_regs + SABRE_CE_AFSR;\r\nunsigned long afar_reg = pbm->controller_regs + SABRE_UECE_AFAR;\r\nunsigned long afsr, afar, error_bits;\r\nint reported;\r\nafar = upa_readq(afar_reg);\r\nafsr = upa_readq(afsr_reg);\r\nerror_bits = afsr &\r\n(SABRE_CEAFSR_PDRD | SABRE_CEAFSR_PDWR |\r\nSABRE_CEAFSR_SDRD | SABRE_CEAFSR_SDWR);\r\nif (!error_bits)\r\nreturn IRQ_NONE;\r\nupa_writeq(error_bits, afsr_reg);\r\nprintk("%s: Correctable Error, primary error type[%s]\n",\r\npbm->name,\r\n((error_bits & SABRE_CEAFSR_PDRD) ?\r\n"DMA Read" :\r\n((error_bits & SABRE_CEAFSR_PDWR) ?\r\n"DMA Write" : "???")));\r\nprintk("%s: syndrome[%02lx] bytemask[%04lx] dword_offset[%lx] "\r\n"was_block(%d)\n",\r\npbm->name,\r\n(afsr & SABRE_CEAFSR_ESYND) >> 48UL,\r\n(afsr & SABRE_CEAFSR_BMSK) >> 32UL,\r\n(afsr & SABRE_CEAFSR_OFF) >> 29UL,\r\n((afsr & SABRE_CEAFSR_BLK) ? 1 : 0));\r\nprintk("%s: CE AFAR [%016lx]\n", pbm->name, afar);\r\nprintk("%s: CE Secondary errors [", pbm->name);\r\nreported = 0;\r\nif (afsr & SABRE_CEAFSR_SDRD) {\r\nreported++;\r\nprintk("(DMA Read)");\r\n}\r\nif (afsr & SABRE_CEAFSR_SDWR) {\r\nreported++;\r\nprintk("(DMA Write)");\r\n}\r\nif (!reported)\r\nprintk("(none)");\r\nprintk("]\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sabre_register_error_handlers(struct pci_pbm_info *pbm)\r\n{\r\nstruct device_node *dp = pbm->op->dev.of_node;\r\nstruct platform_device *op;\r\nunsigned long base = pbm->controller_regs;\r\nu64 tmp;\r\nint err;\r\nif (pbm->chip_type == PBM_CHIP_TYPE_SABRE)\r\ndp = dp->parent;\r\nop = of_find_device_by_node(dp);\r\nif (!op)\r\nreturn;\r\nif (op->archdata.num_irqs < 4)\r\nreturn;\r\nupa_writeq((SABRE_UEAFSR_PDRD | SABRE_UEAFSR_PDWR |\r\nSABRE_UEAFSR_SDRD | SABRE_UEAFSR_SDWR |\r\nSABRE_UEAFSR_SDTE | SABRE_UEAFSR_PDTE),\r\nbase + SABRE_UE_AFSR);\r\nerr = request_irq(op->archdata.irqs[1], sabre_ue_intr, 0, "SABRE_UE", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Couldn't register UE, err=%d.\n",\r\npbm->name, err);\r\nupa_writeq((SABRE_CEAFSR_PDRD | SABRE_CEAFSR_PDWR |\r\nSABRE_CEAFSR_SDRD | SABRE_CEAFSR_SDWR),\r\nbase + SABRE_CE_AFSR);\r\nerr = request_irq(op->archdata.irqs[2], sabre_ce_intr, 0, "SABRE_CE", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Couldn't register CE, err=%d.\n",\r\npbm->name, err);\r\nerr = request_irq(op->archdata.irqs[0], psycho_pcierr_intr, 0,\r\n"SABRE_PCIERR", pbm);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Couldn't register PCIERR, err=%d.\n",\r\npbm->name, err);\r\ntmp = upa_readq(base + SABRE_PCICTRL);\r\ntmp |= SABRE_PCICTRL_ERREN;\r\nupa_writeq(tmp, base + SABRE_PCICTRL);\r\n}\r\nstatic void apb_init(struct pci_bus *sabre_bus)\r\n{\r\nstruct pci_dev *pdev;\r\nlist_for_each_entry(pdev, &sabre_bus->devices, bus_list) {\r\nif (pdev->vendor == PCI_VENDOR_ID_SUN &&\r\npdev->device == PCI_DEVICE_ID_SUN_SIMBA) {\r\nu16 word16;\r\npci_read_config_word(pdev, PCI_COMMAND, &word16);\r\nword16 |= PCI_COMMAND_SERR | PCI_COMMAND_PARITY |\r\nPCI_COMMAND_MASTER | PCI_COMMAND_MEMORY |\r\nPCI_COMMAND_IO;\r\npci_write_config_word(pdev, PCI_COMMAND, word16);\r\npci_write_config_word(pdev, PCI_STATUS, 0xffff);\r\npci_write_config_word(pdev, PCI_SEC_STATUS, 0xffff);\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 64);\r\npci_write_config_byte(pdev, PCI_SEC_LATENCY_TIMER, 64);\r\npci_write_config_byte(pdev, PCI_BRIDGE_CONTROL,\r\n(PCI_BRIDGE_CTL_PARITY |\r\nPCI_BRIDGE_CTL_SERR |\r\nPCI_BRIDGE_CTL_MASTER_ABORT));\r\n}\r\n}\r\n}\r\nstatic void __devinit sabre_scan_bus(struct pci_pbm_info *pbm,\r\nstruct device *parent)\r\n{\r\nstatic int once;\r\nif (hummingbird_p)\r\npbm->is_66mhz_capable = 1;\r\nelse\r\npbm->is_66mhz_capable = 0;\r\nif (once != 0) {\r\nprintk(KERN_ERR PFX "Multiple controllers unsupported.\n");\r\nreturn;\r\n}\r\nonce++;\r\npbm->pci_bus = pci_scan_one_pbm(pbm, parent);\r\nif (!pbm->pci_bus)\r\nreturn;\r\nsabre_root_bus = pbm->pci_bus;\r\napb_init(pbm->pci_bus);\r\nsabre_register_error_handlers(pbm);\r\n}\r\nstatic void __devinit sabre_pbm_init(struct pci_pbm_info *pbm,\r\nstruct platform_device *op)\r\n{\r\npsycho_pbm_init_common(pbm, op, "SABRE", PBM_CHIP_TYPE_SABRE);\r\npbm->pci_afsr = pbm->controller_regs + SABRE_PIOAFSR;\r\npbm->pci_afar = pbm->controller_regs + SABRE_PIOAFAR;\r\npbm->pci_csr = pbm->controller_regs + SABRE_PCICTRL;\r\nsabre_scan_bus(pbm, &op->dev);\r\n}\r\nstatic int __devinit sabre_probe(struct platform_device *op)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct linux_prom64_registers *pr_regs;\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct pci_pbm_info *pbm;\r\nu32 upa_portid, dma_mask;\r\nstruct iommu *iommu;\r\nint tsbsize, err;\r\nconst u32 *vdma;\r\nu64 clear_irq;\r\nmatch = of_match_device(sabre_match, &op->dev);\r\nhummingbird_p = match && (match->data != NULL);\r\nif (!hummingbird_p) {\r\nstruct device_node *cpu_dp;\r\nfor_each_node_by_type(cpu_dp, "cpu") {\r\nif (!strcmp(cpu_dp->name, "SUNW,UltraSPARC-IIe"))\r\nhummingbird_p = 1;\r\n}\r\n}\r\nerr = -ENOMEM;\r\npbm = kzalloc(sizeof(*pbm), GFP_KERNEL);\r\nif (!pbm) {\r\nprintk(KERN_ERR PFX "Cannot allocate pci_pbm_info.\n");\r\ngoto out_err;\r\n}\r\niommu = kzalloc(sizeof(*iommu), GFP_KERNEL);\r\nif (!iommu) {\r\nprintk(KERN_ERR PFX "Cannot allocate PBM iommu.\n");\r\ngoto out_free_controller;\r\n}\r\npbm->iommu = iommu;\r\nupa_portid = of_getintprop_default(dp, "upa-portid", 0xff);\r\npbm->portid = upa_portid;\r\npr_regs = of_get_property(dp, "reg", NULL);\r\nerr = -ENODEV;\r\nif (!pr_regs) {\r\nprintk(KERN_ERR PFX "No reg property\n");\r\ngoto out_free_iommu;\r\n}\r\npbm->controller_regs = pr_regs[0].phys_addr;\r\nfor (clear_irq = SABRE_ICLR_A_SLOT0; clear_irq < SABRE_ICLR_B_SLOT0 + 0x80; clear_irq += 8)\r\nupa_writeq(0x0UL, pbm->controller_regs + clear_irq);\r\nfor (clear_irq = SABRE_ICLR_SCSI; clear_irq < SABRE_ICLR_SCSI + 0x80; clear_irq += 8)\r\nupa_writeq(0x0UL, pbm->controller_regs + clear_irq);\r\nupa_writeq((SABRE_PCICTRL_MRLEN | SABRE_PCICTRL_SERR |\r\nSABRE_PCICTRL_ARBPARK | SABRE_PCICTRL_AEN),\r\npbm->controller_regs + SABRE_PCICTRL);\r\npbm->config_space = pbm->controller_regs + SABRE_CONFIGSPACE;\r\nvdma = of_get_property(dp, "virtual-dma", NULL);\r\nif (!vdma) {\r\nprintk(KERN_ERR PFX "No virtual-dma property\n");\r\ngoto out_free_iommu;\r\n}\r\ndma_mask = vdma[0];\r\nswitch(vdma[1]) {\r\ncase 0x20000000:\r\ndma_mask |= 0x1fffffff;\r\ntsbsize = 64;\r\nbreak;\r\ncase 0x40000000:\r\ndma_mask |= 0x3fffffff;\r\ntsbsize = 128;\r\nbreak;\r\ncase 0x80000000:\r\ndma_mask |= 0x7fffffff;\r\ntsbsize = 128;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX "Strange virtual-dma size.\n");\r\ngoto out_free_iommu;\r\n}\r\nerr = psycho_iommu_init(pbm, tsbsize, vdma[0], dma_mask, SABRE_WRSYNC);\r\nif (err)\r\ngoto out_free_iommu;\r\nsabre_pbm_init(pbm, op);\r\npbm->next = pci_pbm_root;\r\npci_pbm_root = pbm;\r\ndev_set_drvdata(&op->dev, pbm);\r\nreturn 0;\r\nout_free_iommu:\r\nkfree(pbm->iommu);\r\nout_free_controller:\r\nkfree(pbm);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int __init sabre_init(void)\r\n{\r\nreturn platform_driver_register(&sabre_driver);\r\n}
