static const char *skip_arg(const char *cp)\r\n{\r\nwhile (*cp && !isspace(*cp))\r\ncp++;\r\nreturn cp;\r\n}\r\nstatic int count_argc(const char *str)\r\n{\r\nint count = 0;\r\nwhile (*str) {\r\nstr = skip_spaces(str);\r\nif (*str) {\r\ncount++;\r\nstr = skip_arg(str);\r\n}\r\n}\r\nreturn count;\r\n}\r\nvoid argv_free(char **argv)\r\n{\r\nchar **p;\r\nfor (p = argv; *p; p++)\r\nkfree(*p);\r\nkfree(argv);\r\n}\r\nchar **argv_split(gfp_t gfp, const char *str, int *argcp)\r\n{\r\nint argc = count_argc(str);\r\nchar **argv = kzalloc(sizeof(*argv) * (argc+1), gfp);\r\nchar **argvp;\r\nif (argv == NULL)\r\ngoto out;\r\nif (argcp)\r\n*argcp = argc;\r\nargvp = argv;\r\nwhile (*str) {\r\nstr = skip_spaces(str);\r\nif (*str) {\r\nconst char *p = str;\r\nchar *t;\r\nstr = skip_arg(str);\r\nt = kstrndup(p, str-p, gfp);\r\nif (t == NULL)\r\ngoto fail;\r\n*argvp++ = t;\r\n}\r\n}\r\n*argvp = NULL;\r\nout:\r\nreturn argv;\r\nfail:\r\nargv_free(argv);\r\nreturn NULL;\r\n}
