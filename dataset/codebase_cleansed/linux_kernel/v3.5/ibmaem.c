static int aem_init_ipmi_data(struct aem_ipmi_data *data, int iface,\r\nstruct device *bmc)\r\n{\r\nint err;\r\ninit_completion(&data->read_complete);\r\ndata->bmc_device = bmc;\r\ndata->address.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\ndata->address.channel = IPMI_BMC_CHANNEL;\r\ndata->address.data[0] = 0;\r\ndata->interface = iface;\r\ndata->tx_msgid = 0;\r\ndata->tx_message.netfn = AEM_NETFN;\r\nerr = ipmi_create_user(data->interface, &driver_data.ipmi_hndlrs,\r\ndata, &data->user);\r\nif (err < 0) {\r\ndev_err(bmc, "Unable to register user with IPMI "\r\n"interface %d\n", data->interface);\r\nreturn -EACCES;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aem_send_message(struct aem_ipmi_data *data)\r\n{\r\nint err;\r\nerr = ipmi_validate_addr(&data->address, sizeof(data->address));\r\nif (err)\r\ngoto out;\r\ndata->tx_msgid++;\r\nerr = ipmi_request_settime(data->user, &data->address, data->tx_msgid,\r\n&data->tx_message, data, 0, 0, 0);\r\nif (err)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\ndev_err(data->bmc_device, "request_settime=%x\n", err);\r\nreturn err;\r\nout:\r\ndev_err(data->bmc_device, "validate_addr=%x\n", err);\r\nreturn err;\r\n}\r\nstatic void aem_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\r\n{\r\nunsigned short rx_len;\r\nstruct aem_ipmi_data *data = user_msg_data;\r\nif (msg->msgid != data->tx_msgid) {\r\ndev_err(data->bmc_device, "Mismatch between received msgid "\r\n"(%02x) and transmitted msgid (%02x)!\n",\r\n(int)msg->msgid,\r\n(int)data->tx_msgid);\r\nipmi_free_recv_msg(msg);\r\nreturn;\r\n}\r\ndata->rx_recv_type = msg->recv_type;\r\nif (msg->msg.data_len > 0)\r\ndata->rx_result = msg->msg.data[0];\r\nelse\r\ndata->rx_result = IPMI_UNKNOWN_ERR_COMPLETION_CODE;\r\nif (msg->msg.data_len > 1) {\r\nrx_len = msg->msg.data_len - 1;\r\nif (data->rx_msg_len < rx_len)\r\nrx_len = data->rx_msg_len;\r\ndata->rx_msg_len = rx_len;\r\nmemcpy(data->rx_msg_data, msg->msg.data + 1, data->rx_msg_len);\r\n} else\r\ndata->rx_msg_len = 0;\r\nipmi_free_recv_msg(msg);\r\ncomplete(&data->read_complete);\r\n}\r\nstatic int aem_read_sensor(struct aem_data *data, u8 elt, u8 reg,\r\nvoid *buf, size_t size)\r\n{\r\nint rs_size, res;\r\nstruct aem_read_sensor_req rs_req;\r\nstruct aem_read_sensor_resp *rs_resp = data->rs_resp;\r\nstruct aem_ipmi_data *ipmi = &data->ipmi;\r\nswitch (size) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrs_req.id = system_x_id;\r\nrs_req.module_handle = data->module_handle;\r\nrs_req.element = elt;\r\nrs_req.subcommand = AEM_READ_REGISTER;\r\nrs_req.reg = reg;\r\nrs_req.rx_buf_size = size;\r\nipmi->tx_message.cmd = AEM_ELEMENT_CMD;\r\nipmi->tx_message.data = (char *)&rs_req;\r\nipmi->tx_message.data_len = sizeof(rs_req);\r\nrs_size = sizeof(*rs_resp) + size;\r\nipmi->rx_msg_data = rs_resp;\r\nipmi->rx_msg_len = rs_size;\r\naem_send_message(ipmi);\r\nres = wait_for_completion_timeout(&ipmi->read_complete, IPMI_TIMEOUT);\r\nif (!res) {\r\nres = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (ipmi->rx_result || ipmi->rx_msg_len != rs_size ||\r\nmemcmp(&rs_resp->id, &system_x_id, sizeof(system_x_id))) {\r\nres = -ENOENT;\r\ngoto out;\r\n}\r\nswitch (size) {\r\ncase 1: {\r\nu8 *x = buf;\r\n*x = rs_resp->bytes[0];\r\nbreak;\r\n}\r\ncase 2: {\r\nu16 *x = buf;\r\n*x = be16_to_cpup((__be16 *)rs_resp->bytes);\r\nbreak;\r\n}\r\ncase 4: {\r\nu32 *x = buf;\r\n*x = be32_to_cpup((__be32 *)rs_resp->bytes);\r\nbreak;\r\n}\r\ncase 8: {\r\nu64 *x = buf;\r\n*x = be64_to_cpup((__be64 *)rs_resp->bytes);\r\nbreak;\r\n}\r\n}\r\nres = 0;\r\nout:\r\nreturn res;\r\n}\r\nstatic void update_aem_energy_one(struct aem_data *data, int which)\r\n{\r\naem_read_sensor(data, AEM_ENERGY_ELEMENT, which,\r\n&data->energy[which], 8);\r\n}\r\nstatic void update_aem_energy(struct aem_data *data)\r\n{\r\nupdate_aem_energy_one(data, 0);\r\nif (data->ver_major < 2)\r\nreturn;\r\nupdate_aem_energy_one(data, 1);\r\n}\r\nstatic void update_aem1_sensors(struct aem_data *data)\r\n{\r\nmutex_lock(&data->lock);\r\nif (time_before(jiffies, data->last_updated + REFRESH_INTERVAL) &&\r\ndata->valid)\r\ngoto out;\r\nupdate_aem_energy(data);\r\nout:\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic void update_aem2_sensors(struct aem_data *data)\r\n{\r\nint i;\r\nmutex_lock(&data->lock);\r\nif (time_before(jiffies, data->last_updated + REFRESH_INTERVAL) &&\r\ndata->valid)\r\ngoto out;\r\nupdate_aem_energy(data);\r\naem_read_sensor(data, AEM_EXHAUST_ELEMENT, 0, &data->temp[0], 1);\r\naem_read_sensor(data, AEM_EXHAUST_ELEMENT, 1, &data->temp[1], 1);\r\nfor (i = POWER_CAP; i <= POWER_AUX; i++)\r\naem_read_sensor(data, AEM_POWER_CAP_ELEMENT, i,\r\n&data->pcap[i], 2);\r\nout:\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic void aem_delete(struct aem_data *data)\r\n{\r\nlist_del(&data->list);\r\naem_remove_sensors(data);\r\nkfree(data->rs_resp);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nipmi_destroy_user(data->ipmi.user);\r\nplatform_set_drvdata(data->pdev, NULL);\r\nplatform_device_unregister(data->pdev);\r\nida_simple_remove(&aem_ida, data->id);\r\nkfree(data);\r\n}\r\nstatic int aem_find_aem1_count(struct aem_ipmi_data *data)\r\n{\r\nint res;\r\nstruct aem_find_firmware_req ff_req;\r\nstruct aem_find_firmware_resp ff_resp;\r\nff_req.id = system_x_id;\r\nff_req.index = 0;\r\nff_req.module_type_id = cpu_to_be16(AEM_MODULE_TYPE_ID);\r\ndata->tx_message.cmd = AEM_FIND_FW_CMD;\r\ndata->tx_message.data = (char *)&ff_req;\r\ndata->tx_message.data_len = sizeof(ff_req);\r\ndata->rx_msg_data = &ff_resp;\r\ndata->rx_msg_len = sizeof(ff_resp);\r\naem_send_message(data);\r\nres = wait_for_completion_timeout(&data->read_complete, IPMI_TIMEOUT);\r\nif (!res)\r\nreturn -ETIMEDOUT;\r\nif (data->rx_result || data->rx_msg_len != sizeof(ff_resp) ||\r\nmemcmp(&ff_resp.id, &system_x_id, sizeof(system_x_id)))\r\nreturn -ENOENT;\r\nreturn ff_resp.num_instances;\r\n}\r\nstatic int aem_init_aem1_inst(struct aem_ipmi_data *probe, u8 module_handle)\r\n{\r\nstruct aem_data *data;\r\nint i;\r\nint res = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn res;\r\nmutex_init(&data->lock);\r\ndata->ver_major = 1;\r\ndata->ver_minor = 0;\r\ndata->module_handle = module_handle;\r\nfor (i = 0; i < AEM1_NUM_ENERGY_REGS; i++)\r\ndata->power_period[i] = AEM_DEFAULT_POWER_INTERVAL;\r\ndata->id = ida_simple_get(&aem_ida, 0, 0, GFP_KERNEL);\r\nif (data->id < 0)\r\ngoto id_err;\r\ndata->pdev = platform_device_alloc(DRVNAME, data->id);\r\nif (!data->pdev)\r\ngoto dev_err;\r\ndata->pdev->dev.driver = &aem_driver.driver;\r\nres = platform_device_add(data->pdev);\r\nif (res)\r\ngoto ipmi_err;\r\nplatform_set_drvdata(data->pdev, data);\r\nres = aem_init_ipmi_data(&data->ipmi, probe->interface,\r\nprobe->bmc_device);\r\nif (res)\r\ngoto ipmi_err;\r\ndata->hwmon_dev = hwmon_device_register(&data->pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\ndev_err(&data->pdev->dev, "Unable to register hwmon "\r\n"device for IPMI interface %d\n",\r\nprobe->interface);\r\nres = PTR_ERR(data->hwmon_dev);\r\ngoto hwmon_reg_err;\r\n}\r\ndata->update = update_aem1_sensors;\r\ndata->rs_resp = kzalloc(sizeof(*(data->rs_resp)) + 8, GFP_KERNEL);\r\nif (!data->rs_resp) {\r\nres = -ENOMEM;\r\ngoto alloc_resp_err;\r\n}\r\nres = aem1_find_sensors(data);\r\nif (res)\r\ngoto sensor_err;\r\nlist_add_tail(&data->list, &driver_data.aem_devices);\r\ndev_info(data->ipmi.bmc_device, "Found AEM v%d.%d at 0x%X\n",\r\ndata->ver_major, data->ver_minor,\r\ndata->module_handle);\r\nreturn 0;\r\nsensor_err:\r\nkfree(data->rs_resp);\r\nalloc_resp_err:\r\nhwmon_device_unregister(data->hwmon_dev);\r\nhwmon_reg_err:\r\nipmi_destroy_user(data->ipmi.user);\r\nipmi_err:\r\nplatform_set_drvdata(data->pdev, NULL);\r\nplatform_device_unregister(data->pdev);\r\ndev_err:\r\nida_simple_remove(&aem_ida, data->id);\r\nid_err:\r\nkfree(data);\r\nreturn res;\r\n}\r\nstatic void aem_init_aem1(struct aem_ipmi_data *probe)\r\n{\r\nint num, i, err;\r\nnum = aem_find_aem1_count(probe);\r\nfor (i = 0; i < num; i++) {\r\nerr = aem_init_aem1_inst(probe, i);\r\nif (err) {\r\ndev_err(probe->bmc_device,\r\n"Error %d initializing AEM1 0x%X\n",\r\nerr, i);\r\n}\r\n}\r\n}\r\nstatic int aem_find_aem2(struct aem_ipmi_data *data,\r\nstruct aem_find_instance_resp *fi_resp,\r\nint instance_num)\r\n{\r\nint res;\r\nstruct aem_find_instance_req fi_req;\r\nfi_req.id = system_x_id;\r\nfi_req.instance_number = instance_num;\r\nfi_req.module_type_id = cpu_to_be16(AEM_MODULE_TYPE_ID);\r\ndata->tx_message.cmd = AEM_FW_INSTANCE_CMD;\r\ndata->tx_message.data = (char *)&fi_req;\r\ndata->tx_message.data_len = sizeof(fi_req);\r\ndata->rx_msg_data = fi_resp;\r\ndata->rx_msg_len = sizeof(*fi_resp);\r\naem_send_message(data);\r\nres = wait_for_completion_timeout(&data->read_complete, IPMI_TIMEOUT);\r\nif (!res)\r\nreturn -ETIMEDOUT;\r\nif (data->rx_result || data->rx_msg_len != sizeof(*fi_resp) ||\r\nmemcmp(&fi_resp->id, &system_x_id, sizeof(system_x_id)) ||\r\nfi_resp->num_instances <= instance_num)\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic int aem_init_aem2_inst(struct aem_ipmi_data *probe,\r\nstruct aem_find_instance_resp *fi_resp)\r\n{\r\nstruct aem_data *data;\r\nint i;\r\nint res = -ENOMEM;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn res;\r\nmutex_init(&data->lock);\r\ndata->ver_major = fi_resp->major;\r\ndata->ver_minor = fi_resp->minor;\r\ndata->module_handle = fi_resp->module_handle;\r\nfor (i = 0; i < AEM2_NUM_ENERGY_REGS; i++)\r\ndata->power_period[i] = AEM_DEFAULT_POWER_INTERVAL;\r\ndata->id = ida_simple_get(&aem_ida, 0, 0, GFP_KERNEL);\r\nif (data->id < 0)\r\ngoto id_err;\r\ndata->pdev = platform_device_alloc(DRVNAME, data->id);\r\nif (!data->pdev)\r\ngoto dev_err;\r\ndata->pdev->dev.driver = &aem_driver.driver;\r\nres = platform_device_add(data->pdev);\r\nif (res)\r\ngoto ipmi_err;\r\nplatform_set_drvdata(data->pdev, data);\r\nres = aem_init_ipmi_data(&data->ipmi, probe->interface,\r\nprobe->bmc_device);\r\nif (res)\r\ngoto ipmi_err;\r\ndata->hwmon_dev = hwmon_device_register(&data->pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\ndev_err(&data->pdev->dev, "Unable to register hwmon "\r\n"device for IPMI interface %d\n",\r\nprobe->interface);\r\nres = PTR_ERR(data->hwmon_dev);\r\ngoto hwmon_reg_err;\r\n}\r\ndata->update = update_aem2_sensors;\r\ndata->rs_resp = kzalloc(sizeof(*(data->rs_resp)) + 8, GFP_KERNEL);\r\nif (!data->rs_resp) {\r\nres = -ENOMEM;\r\ngoto alloc_resp_err;\r\n}\r\nres = aem2_find_sensors(data);\r\nif (res)\r\ngoto sensor_err;\r\nlist_add_tail(&data->list, &driver_data.aem_devices);\r\ndev_info(data->ipmi.bmc_device, "Found AEM v%d.%d at 0x%X\n",\r\ndata->ver_major, data->ver_minor,\r\ndata->module_handle);\r\nreturn 0;\r\nsensor_err:\r\nkfree(data->rs_resp);\r\nalloc_resp_err:\r\nhwmon_device_unregister(data->hwmon_dev);\r\nhwmon_reg_err:\r\nipmi_destroy_user(data->ipmi.user);\r\nipmi_err:\r\nplatform_set_drvdata(data->pdev, NULL);\r\nplatform_device_unregister(data->pdev);\r\ndev_err:\r\nida_simple_remove(&aem_ida, data->id);\r\nid_err:\r\nkfree(data);\r\nreturn res;\r\n}\r\nstatic void aem_init_aem2(struct aem_ipmi_data *probe)\r\n{\r\nstruct aem_find_instance_resp fi_resp;\r\nint err;\r\nint i = 0;\r\nwhile (!aem_find_aem2(probe, &fi_resp, i)) {\r\nif (fi_resp.major != 2) {\r\ndev_err(probe->bmc_device, "Unknown AEM v%d; please "\r\n"report this to the maintainer.\n",\r\nfi_resp.major);\r\ni++;\r\ncontinue;\r\n}\r\nerr = aem_init_aem2_inst(probe, &fi_resp);\r\nif (err) {\r\ndev_err(probe->bmc_device,\r\n"Error %d initializing AEM2 0x%X\n",\r\nerr, fi_resp.module_handle);\r\n}\r\ni++;\r\n}\r\n}\r\nstatic void aem_register_bmc(int iface, struct device *dev)\r\n{\r\nstruct aem_ipmi_data probe;\r\nif (aem_init_ipmi_data(&probe, iface, dev))\r\nreturn;\r\naem_init_aem1(&probe);\r\naem_init_aem2(&probe);\r\nipmi_destroy_user(probe.user);\r\n}\r\nstatic void aem_bmc_gone(int iface)\r\n{\r\nstruct aem_data *p1, *next1;\r\nlist_for_each_entry_safe(p1, next1, &driver_data.aem_devices, list)\r\nif (p1->ipmi.interface == iface)\r\naem_delete(p1);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct aem_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s%d\n", DRVNAME, data->ver_major);\r\n}\r\nstatic ssize_t show_version(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct aem_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d.%d\n", data->ver_major, data->ver_minor);\r\n}\r\nstatic ssize_t aem_show_power(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct aem_data *data = dev_get_drvdata(dev);\r\nu64 before, after, delta, time;\r\nsigned long leftover;\r\nstruct timespec b, a;\r\nmutex_lock(&data->lock);\r\nupdate_aem_energy_one(data, attr->index);\r\ngetnstimeofday(&b);\r\nbefore = data->energy[attr->index];\r\nleftover = schedule_timeout_interruptible(\r\nmsecs_to_jiffies(data->power_period[attr->index])\r\n);\r\nif (leftover) {\r\nmutex_unlock(&data->lock);\r\nreturn 0;\r\n}\r\nupdate_aem_energy_one(data, attr->index);\r\ngetnstimeofday(&a);\r\nafter = data->energy[attr->index];\r\nmutex_unlock(&data->lock);\r\ntime = timespec_to_ns(&a) - timespec_to_ns(&b);\r\ndelta = (after - before) * UJ_PER_MJ;\r\nreturn sprintf(buf, "%llu\n",\r\n(unsigned long long)div64_u64(delta * NSEC_PER_SEC, time));\r\n}\r\nstatic ssize_t aem_show_energy(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct aem_data *a = dev_get_drvdata(dev);\r\nmutex_lock(&a->lock);\r\nupdate_aem_energy_one(a, attr->index);\r\nmutex_unlock(&a->lock);\r\nreturn sprintf(buf, "%llu\n",\r\n(unsigned long long)a->energy[attr->index] * 1000);\r\n}\r\nstatic ssize_t aem_show_power_period(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct aem_data *a = dev_get_drvdata(dev);\r\na->update(a);\r\nreturn sprintf(buf, "%lu\n", a->power_period[attr->index]);\r\n}\r\nstatic ssize_t aem_set_power_period(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct aem_data *a = dev_get_drvdata(dev);\r\nunsigned long temp;\r\nint res;\r\nres = kstrtoul(buf, 10, &temp);\r\nif (res)\r\nreturn res;\r\nif (temp < AEM_MIN_POWER_INTERVAL)\r\nreturn -EINVAL;\r\nmutex_lock(&a->lock);\r\na->power_period[attr->index] = temp;\r\nmutex_unlock(&a->lock);\r\nreturn count;\r\n}\r\nstatic int aem_register_sensors(struct aem_data *data,\r\nstruct aem_ro_sensor_template *ro,\r\nstruct aem_rw_sensor_template *rw)\r\n{\r\nstruct device *dev = &data->pdev->dev;\r\nstruct sensor_device_attribute *sensors = data->sensors;\r\nint err;\r\nwhile (ro->label) {\r\nsysfs_attr_init(&sensors->dev_attr.attr);\r\nsensors->dev_attr.attr.name = ro->label;\r\nsensors->dev_attr.attr.mode = S_IRUGO;\r\nsensors->dev_attr.show = ro->show;\r\nsensors->index = ro->index;\r\nerr = device_create_file(dev, &sensors->dev_attr);\r\nif (err) {\r\nsensors->dev_attr.attr.name = NULL;\r\ngoto error;\r\n}\r\nsensors++;\r\nro++;\r\n}\r\nwhile (rw->label) {\r\nsysfs_attr_init(&sensors->dev_attr.attr);\r\nsensors->dev_attr.attr.name = rw->label;\r\nsensors->dev_attr.attr.mode = S_IRUGO | S_IWUSR;\r\nsensors->dev_attr.show = rw->show;\r\nsensors->dev_attr.store = rw->set;\r\nsensors->index = rw->index;\r\nerr = device_create_file(dev, &sensors->dev_attr);\r\nif (err) {\r\nsensors->dev_attr.attr.name = NULL;\r\ngoto error;\r\n}\r\nsensors++;\r\nrw++;\r\n}\r\nerr = device_create_file(dev, &sensor_dev_attr_name.dev_attr);\r\nif (err)\r\ngoto error;\r\nerr = device_create_file(dev, &sensor_dev_attr_version.dev_attr);\r\nreturn err;\r\nerror:\r\naem_remove_sensors(data);\r\nreturn err;\r\n}\r\nstatic ssize_t aem2_show_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct aem_data *a = dev_get_drvdata(dev);\r\na->update(a);\r\nreturn sprintf(buf, "%u\n", a->temp[attr->index] * 1000);\r\n}\r\nstatic ssize_t aem2_show_pcap_value(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct aem_data *a = dev_get_drvdata(dev);\r\na->update(a);\r\nreturn sprintf(buf, "%u\n", a->pcap[attr->index] * 100000);\r\n}\r\nstatic void aem_remove_sensors(struct aem_data *data)\r\n{\r\nint i;\r\nfor (i = 0; i < AEM_NUM_SENSORS; i++) {\r\nif (!data->sensors[i].dev_attr.attr.name)\r\ncontinue;\r\ndevice_remove_file(&data->pdev->dev,\r\n&data->sensors[i].dev_attr);\r\n}\r\ndevice_remove_file(&data->pdev->dev,\r\n&sensor_dev_attr_name.dev_attr);\r\ndevice_remove_file(&data->pdev->dev,\r\n&sensor_dev_attr_version.dev_attr);\r\n}\r\nstatic int aem1_find_sensors(struct aem_data *data)\r\n{\r\nreturn aem_register_sensors(data, aem1_ro_sensors, aem1_rw_sensors);\r\n}\r\nstatic int aem2_find_sensors(struct aem_data *data)\r\n{\r\nreturn aem_register_sensors(data, aem2_ro_sensors, aem2_rw_sensors);\r\n}\r\nstatic int __init aem_init(void)\r\n{\r\nint res;\r\nres = driver_register(&aem_driver.driver);\r\nif (res) {\r\npr_err("Can't register aem driver\n");\r\nreturn res;\r\n}\r\nres = ipmi_smi_watcher_register(&driver_data.bmc_events);\r\nif (res)\r\ngoto ipmi_reg_err;\r\nreturn 0;\r\nipmi_reg_err:\r\ndriver_unregister(&aem_driver.driver);\r\nreturn res;\r\n}\r\nstatic void __exit aem_exit(void)\r\n{\r\nstruct aem_data *p1, *next1;\r\nipmi_smi_watcher_unregister(&driver_data.bmc_events);\r\ndriver_unregister(&aem_driver.driver);\r\nlist_for_each_entry_safe(p1, next1, &driver_data.aem_devices, list)\r\naem_delete(p1);\r\n}
