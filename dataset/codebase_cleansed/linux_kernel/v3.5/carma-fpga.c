static void fpga_device_release(struct kref *ref)\r\n{\r\nstruct fpga_device *priv = container_of(ref, struct fpga_device, ref);\r\nmutex_destroy(&priv->mutex);\r\nkfree(priv);\r\n}\r\nstatic void data_free_buffer(struct data_buf *buf)\r\n{\r\nif (!buf)\r\nreturn;\r\nvideobuf_dma_free(&buf->vb);\r\nkfree(buf);\r\n}\r\nstatic struct data_buf *data_alloc_buffer(const size_t bytes)\r\n{\r\nunsigned int nr_pages;\r\nstruct data_buf *buf;\r\nint ret;\r\nnr_pages = DIV_ROUND_UP(bytes, PAGE_SIZE);\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\ngoto out_return;\r\nINIT_LIST_HEAD(&buf->entry);\r\nbuf->size = bytes;\r\nvideobuf_dma_init(&buf->vb);\r\nret = videobuf_dma_init_kernel(&buf->vb, DMA_FROM_DEVICE, nr_pages);\r\nif (ret)\r\ngoto out_free_buf;\r\nreturn buf;\r\nout_free_buf:\r\nkfree(buf);\r\nout_return:\r\nreturn NULL;\r\n}\r\nstatic void data_free_buffers(struct fpga_device *priv)\r\n{\r\nstruct data_buf *buf, *tmp;\r\nBUG_ON(priv->inflight != NULL);\r\nlist_for_each_entry_safe(buf, tmp, &priv->free, entry) {\r\nlist_del_init(&buf->entry);\r\nvideobuf_dma_unmap(priv->dev, &buf->vb);\r\ndata_free_buffer(buf);\r\n}\r\nlist_for_each_entry_safe(buf, tmp, &priv->used, entry) {\r\nlist_del_init(&buf->entry);\r\nvideobuf_dma_unmap(priv->dev, &buf->vb);\r\ndata_free_buffer(buf);\r\n}\r\npriv->num_buffers = 0;\r\npriv->bufsize = 0;\r\n}\r\nstatic int data_alloc_buffers(struct fpga_device *priv)\r\n{\r\nstruct data_buf *buf;\r\nint i, ret;\r\nfor (i = 0; i < MAX_DATA_BUFS; i++) {\r\nbuf = data_alloc_buffer(priv->bufsize);\r\nif (!buf)\r\nbreak;\r\nret = videobuf_dma_map(priv->dev, &buf->vb);\r\nif (ret) {\r\ndata_free_buffer(buf);\r\nbreak;\r\n}\r\nlist_add_tail(&buf->entry, &priv->free);\r\npriv->num_buffers++;\r\n}\r\nif (priv->num_buffers < MIN_DATA_BUFS) {\r\ndev_err(priv->dev, "Unable to allocate enough data buffers\n");\r\ndata_free_buffers(priv);\r\nreturn -ENOMEM;\r\n}\r\nif (priv->num_buffers < MAX_DATA_BUFS) {\r\ndev_warn(priv->dev,\r\n"Unable to allocate %d buffers, using %d buffers instead\n",\r\nMAX_DATA_BUFS, i);\r\n}\r\nreturn 0;\r\n}\r\nstatic dma_addr_t fpga_start_addr(struct fpga_device *priv, unsigned int fpga)\r\n{\r\nreturn priv->phys_addr + 0x400000 + (0x80000 * fpga);\r\n}\r\nstatic dma_addr_t fpga_block_addr(struct fpga_device *priv, unsigned int fpga,\r\nunsigned int blknum)\r\n{\r\nreturn fpga_start_addr(priv, fpga) + (0x10000 * (1 + blknum));\r\n}\r\nstatic int data_setup_corl_table(struct fpga_device *priv)\r\n{\r\nstruct sg_table *table = &priv->corl_table;\r\nstruct scatterlist *sg;\r\nstruct fpga_info *info;\r\nint i, j, ret;\r\npriv->corl_nents = (1 + NUM_FPGA) * REG_BLOCK_SIZE;\r\nfor (i = 0; i < NUM_FPGA; i++)\r\npriv->corl_nents += priv->info[i].num_lag_ram;\r\nret = sg_alloc_table(table, priv->corl_nents, GFP_KERNEL);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to allocate DMA table\n");\r\nreturn ret;\r\n}\r\nsg = table->sgl;\r\nfor (i = 0; i < NUM_FPGA; i++) {\r\nsg_dma_address(sg) = fpga_start_addr(priv, i);\r\nsg_dma_len(sg) = REG_BLOCK_SIZE;\r\nsg = sg_next(sg);\r\n}\r\nsg_dma_address(sg) = SYS_FPGA_BLOCK;\r\nsg_dma_len(sg) = REG_BLOCK_SIZE;\r\nsg = sg_next(sg);\r\nfor (i = 0; i < NUM_FPGA; i++) {\r\ninfo = &priv->info[i];\r\nfor (j = 0; j < info->num_lag_ram; j++) {\r\nsg_dma_address(sg) = fpga_block_addr(priv, i, j);\r\nsg_dma_len(sg) = info->blk_size;\r\nsg = sg_next(sg);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fpga_write_reg(struct fpga_device *priv, unsigned int fpga,\r\nunsigned int reg, u32 val)\r\n{\r\nconst int fpga_start = DATA_FPGA_START + (fpga * DATA_FPGA_SIZE);\r\niowrite32be(val, priv->regs + fpga_start + reg);\r\n}\r\nstatic u32 fpga_read_reg(struct fpga_device *priv, unsigned int fpga,\r\nunsigned int reg)\r\n{\r\nconst int fpga_start = DATA_FPGA_START + (fpga * DATA_FPGA_SIZE);\r\nreturn ioread32be(priv->regs + fpga_start + reg);\r\n}\r\nstatic int data_calculate_bufsize(struct fpga_device *priv)\r\n{\r\nu32 num_corl, num_lags, num_meta, num_qcnt, num_pack;\r\nu32 conf1, conf2, version;\r\nu32 num_lag_ram, blk_size;\r\nint i;\r\npriv->bufsize = (1 + NUM_FPGA) * REG_BLOCK_SIZE;\r\nfor (i = 0; i < NUM_FPGA; i++) {\r\nversion = fpga_read_reg(priv, i, MMAP_REG_VERSION);\r\nconf1 = fpga_read_reg(priv, i, MMAP_REG_CORL_CONF1);\r\nconf2 = fpga_read_reg(priv, i, MMAP_REG_CORL_CONF2);\r\nif ((version & 0x000000FF) >= 2) {\r\nnum_corl = (conf1 & 0x000000F0) >> 4;\r\nnum_pack = (conf1 & 0x00000F00) >> 8;\r\nnum_lags = (conf1 & 0x00FFF000) >> 12;\r\nnum_meta = (conf1 & 0x7F000000) >> 24;\r\nnum_qcnt = (conf2 & 0x00000FFF) >> 0;\r\n} else {\r\nnum_corl = (conf1 & 0x000000F0) >> 4;\r\nnum_pack = 1;\r\nnum_lags = (conf1 & 0x000FFF00) >> 8;\r\nnum_meta = (conf1 & 0x7FF00000) >> 20;\r\nnum_qcnt = (conf2 & 0x00000FFF) >> 0;\r\n}\r\nnum_lag_ram = (num_corl + num_pack - 1) / num_pack;\r\nblk_size = ((num_pack * num_lags) + num_meta + num_qcnt) * 8;\r\npriv->info[i].num_lag_ram = num_lag_ram;\r\npriv->info[i].blk_size = blk_size;\r\npriv->bufsize += num_lag_ram * blk_size;\r\ndev_dbg(priv->dev, "FPGA %d NUM_CORL: %d\n", i, num_corl);\r\ndev_dbg(priv->dev, "FPGA %d NUM_PACK: %d\n", i, num_pack);\r\ndev_dbg(priv->dev, "FPGA %d NUM_LAGS: %d\n", i, num_lags);\r\ndev_dbg(priv->dev, "FPGA %d NUM_META: %d\n", i, num_meta);\r\ndev_dbg(priv->dev, "FPGA %d NUM_QCNT: %d\n", i, num_qcnt);\r\ndev_dbg(priv->dev, "FPGA %d BLK_SIZE: %d\n", i, blk_size);\r\n}\r\ndev_dbg(priv->dev, "TOTAL BUFFER SIZE: %zu bytes\n", priv->bufsize);\r\nreturn 0;\r\n}\r\nstatic void data_disable_interrupts(struct fpga_device *priv)\r\n{\r\niowrite32be(0x2F, priv->regs + SYS_IRQ_SOURCE_CTL);\r\n}\r\nstatic void data_enable_interrupts(struct fpga_device *priv)\r\n{\r\nfpga_write_reg(priv, 0, MMAP_REG_STATUS, 0x0);\r\nfpga_write_reg(priv, 1, MMAP_REG_STATUS, 0x0);\r\nfpga_write_reg(priv, 2, MMAP_REG_STATUS, 0x0);\r\nfpga_write_reg(priv, 3, MMAP_REG_STATUS, 0x0);\r\nfpga_read_reg(priv, 0, MMAP_REG_STATUS);\r\nfpga_read_reg(priv, 1, MMAP_REG_STATUS);\r\nfpga_read_reg(priv, 2, MMAP_REG_STATUS);\r\nfpga_read_reg(priv, 3, MMAP_REG_STATUS);\r\niowrite32be(0x3F, priv->regs + SYS_IRQ_SOURCE_CTL);\r\n}\r\nstatic void data_dma_cb(void *data)\r\n{\r\nstruct fpga_device *priv = data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nBUG_ON(priv->inflight == NULL);\r\nlist_move_tail(&priv->inflight->entry, &priv->used);\r\npriv->inflight = NULL;\r\nif (priv->enabled)\r\ndata_enable_interrupts(priv);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nwake_up(&priv->wait);\r\n}\r\nstatic int data_submit_dma(struct fpga_device *priv, struct data_buf *buf)\r\n{\r\nstruct scatterlist *dst_sg, *src_sg;\r\nunsigned int dst_nents, src_nents;\r\nstruct dma_chan *chan = priv->chan;\r\nstruct dma_async_tx_descriptor *tx;\r\ndma_cookie_t cookie;\r\ndma_addr_t dst, src;\r\ndst_sg = buf->vb.sglist;\r\ndst_nents = buf->vb.sglen;\r\nsrc_sg = priv->corl_table.sgl;\r\nsrc_nents = priv->corl_nents;\r\ntx = chan->device->device_prep_dma_sg(chan,\r\ndst_sg, dst_nents,\r\nsrc_sg, src_nents,\r\n0);\r\nif (!tx) {\r\ndev_err(priv->dev, "unable to prep scatterlist DMA\n");\r\nreturn -ENOMEM;\r\n}\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_err(priv->dev, "unable to submit scatterlist DMA\n");\r\nreturn -ENOMEM;\r\n}\r\ndst = sg_dma_address(dst_sg) + (NUM_FPGA * REG_BLOCK_SIZE);\r\nsrc = SYS_FPGA_BLOCK;\r\ntx = chan->device->device_prep_dma_memcpy(chan, dst, src,\r\nREG_BLOCK_SIZE,\r\nDMA_PREP_INTERRUPT);\r\nif (!tx) {\r\ndev_err(priv->dev, "unable to prep SYS-FPGA DMA\n");\r\nreturn -ENOMEM;\r\n}\r\ntx->callback = data_dma_cb;\r\ntx->callback_param = priv;\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_err(priv->dev, "unable to submit SYS-FPGA DMA\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t data_irq(int irq, void *dev_id)\r\n{\r\nstruct fpga_device *priv = dev_id;\r\nbool submitted = false;\r\nstruct data_buf *buf;\r\nu32 status;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nstatus = fpga_read_reg(priv, i, MMAP_REG_STATUS);\r\nif (!(status & (CORL_DONE | CORL_ERR))) {\r\ndev_err(priv->dev, "spurious irq detected (FPGA)\n");\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nstatus = ioread32be(priv->regs + SYS_IRQ_INPUT_DATA);\r\nif (status & IRQ_CORL_DONE) {\r\ndev_err(priv->dev, "spurious irq detected (IRQ)\n");\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&priv->lock);\r\nBUG_ON(priv->inflight != NULL);\r\ndata_disable_interrupts(priv);\r\nif (list_empty(&priv->free)) {\r\npriv->num_dropped++;\r\ngoto out;\r\n}\r\nbuf = list_first_entry(&priv->free, struct data_buf, entry);\r\nlist_del_init(&buf->entry);\r\nBUG_ON(buf->size != priv->bufsize);\r\nif (data_submit_dma(priv, buf)) {\r\ndev_err(priv->dev, "Unable to setup DMA transfer\n");\r\nlist_move_tail(&buf->entry, &priv->free);\r\ngoto out;\r\n}\r\npriv->inflight = buf;\r\nsubmitted = true;\r\ndma_async_memcpy_issue_pending(priv->chan);\r\nout:\r\nif (!submitted)\r\ndata_enable_interrupts(priv);\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int data_device_enable(struct fpga_device *priv)\r\n{\r\nbool enabled;\r\nu32 val;\r\nint ret;\r\nspin_lock_irq(&priv->lock);\r\nenabled = priv->enabled;\r\nspin_unlock_irq(&priv->lock);\r\nif (enabled)\r\nreturn 0;\r\nval = ioread32be(priv->regs + SYS_FPGA_CONFIG_STATUS);\r\nif (!(val & (1 << 18))) {\r\ndev_err(priv->dev, "DATA-FPGAs are not enabled\n");\r\nreturn -ENODATA;\r\n}\r\nret = data_calculate_bufsize(priv);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to calculate buffer size\n");\r\ngoto out_error;\r\n}\r\nret = data_alloc_buffers(priv);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to allocate buffers\n");\r\ngoto out_error;\r\n}\r\nret = data_setup_corl_table(priv);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to setup correlation DMA table\n");\r\ngoto out_error;\r\n}\r\ndata_disable_interrupts(priv);\r\nret = request_irq(priv->irq, data_irq, IRQF_SHARED, drv_name, priv);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to request IRQ handler\n");\r\ngoto out_error;\r\n}\r\nspin_lock_irq(&priv->lock);\r\npriv->enabled = true;\r\nspin_unlock_irq(&priv->lock);\r\ndata_enable_interrupts(priv);\r\nreturn 0;\r\nout_error:\r\nsg_free_table(&priv->corl_table);\r\npriv->corl_nents = 0;\r\ndata_free_buffers(priv);\r\nreturn ret;\r\n}\r\nstatic int data_device_disable(struct fpga_device *priv)\r\n{\r\nspin_lock_irq(&priv->lock);\r\nif (!priv->enabled) {\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\npriv->enabled = false;\r\ndata_disable_interrupts(priv);\r\nwhile (priv->inflight != NULL) {\r\nspin_unlock_irq(&priv->lock);\r\nwait_event(priv->wait, priv->inflight == NULL);\r\nspin_lock_irq(&priv->lock);\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nfree_irq(priv->irq, priv);\r\nsg_free_table(&priv->corl_table);\r\npriv->corl_nents = 0;\r\ndata_free_buffers(priv);\r\nreturn 0;\r\n}\r\nstatic unsigned int list_num_entries(struct list_head *list)\r\n{\r\nstruct list_head *entry;\r\nunsigned int ret = 0;\r\nlist_for_each(entry, list)\r\nret++;\r\nreturn ret;\r\n}\r\nstatic int data_debug_show(struct seq_file *f, void *offset)\r\n{\r\nstruct fpga_device *priv = f->private;\r\nspin_lock_irq(&priv->lock);\r\nseq_printf(f, "enabled: %d\n", priv->enabled);\r\nseq_printf(f, "bufsize: %d\n", priv->bufsize);\r\nseq_printf(f, "num_buffers: %d\n", priv->num_buffers);\r\nseq_printf(f, "num_free: %d\n", list_num_entries(&priv->free));\r\nseq_printf(f, "inflight: %d\n", priv->inflight != NULL);\r\nseq_printf(f, "num_used: %d\n", list_num_entries(&priv->used));\r\nseq_printf(f, "num_dropped: %d\n", priv->num_dropped);\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int data_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, data_debug_show, inode->i_private);\r\n}\r\nstatic int data_debugfs_init(struct fpga_device *priv)\r\n{\r\npriv->dbg_entry = debugfs_create_file(drv_name, S_IRUGO, NULL, priv,\r\n&data_debug_fops);\r\nif (IS_ERR(priv->dbg_entry))\r\nreturn PTR_ERR(priv->dbg_entry);\r\nreturn 0;\r\n}\r\nstatic void data_debugfs_exit(struct fpga_device *priv)\r\n{\r\ndebugfs_remove(priv->dbg_entry);\r\n}\r\nstatic inline int data_debugfs_init(struct fpga_device *priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void data_debugfs_exit(struct fpga_device *priv)\r\n{\r\n}\r\nstatic ssize_t data_en_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fpga_device *priv = dev_get_drvdata(dev);\r\nint ret;\r\nspin_lock_irq(&priv->lock);\r\nret = snprintf(buf, PAGE_SIZE, "%u\n", priv->enabled);\r\nspin_unlock_irq(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t data_en_set(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fpga_device *priv = dev_get_drvdata(dev);\r\nunsigned long enable;\r\nint ret;\r\nret = strict_strtoul(buf, 0, &enable);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to parse enable input\n");\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&priv->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (enable)\r\nret = data_device_enable(priv);\r\nelse\r\nret = data_device_disable(priv);\r\nif (ret) {\r\ndev_err(priv->dev, "device %s failed\n",\r\nenable ? "enable" : "disable");\r\ncount = ret;\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nmutex_unlock(&priv->mutex);\r\nreturn count;\r\n}\r\nstatic int data_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct fpga_device *priv = container_of(filp->private_data,\r\nstruct fpga_device, miscdev);\r\nstruct fpga_reader *reader;\r\nint ret;\r\nreader = kzalloc(sizeof(*reader), GFP_KERNEL);\r\nif (!reader)\r\nreturn -ENOMEM;\r\nreader->priv = priv;\r\nreader->buf = NULL;\r\nfilp->private_data = reader;\r\nret = nonseekable_open(inode, filp);\r\nif (ret) {\r\ndev_err(priv->dev, "nonseekable-open failed\n");\r\nkfree(reader);\r\nreturn ret;\r\n}\r\nkref_get(&priv->ref);\r\nreturn 0;\r\n}\r\nstatic int data_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct fpga_reader *reader = filp->private_data;\r\nstruct fpga_device *priv = reader->priv;\r\ndata_free_buffer(reader->buf);\r\nkfree(reader);\r\nfilp->private_data = NULL;\r\nkref_put(&priv->ref, fpga_device_release);\r\nreturn 0;\r\n}\r\nstatic ssize_t data_read(struct file *filp, char __user *ubuf, size_t count,\r\nloff_t *f_pos)\r\n{\r\nstruct fpga_reader *reader = filp->private_data;\r\nstruct fpga_device *priv = reader->priv;\r\nstruct list_head *used = &priv->used;\r\nbool drop_buffer = false;\r\nstruct data_buf *dbuf;\r\nsize_t avail;\r\nvoid *data;\r\nint ret;\r\nif (reader->buf) {\r\ndbuf = reader->buf;\r\ngoto have_buffer;\r\n}\r\nspin_lock_irq(&priv->lock);\r\nwhile (list_empty(used)) {\r\nspin_unlock_irq(&priv->lock);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(priv->wait, !list_empty(used));\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irq(&priv->lock);\r\n}\r\ndbuf = list_first_entry(used, struct data_buf, entry);\r\nlist_del_init(&dbuf->entry);\r\nspin_unlock_irq(&priv->lock);\r\nvideobuf_dma_unmap(priv->dev, &dbuf->vb);\r\nreader->buf = dbuf;\r\nreader->buf_start = 0;\r\nhave_buffer:\r\navail = dbuf->size - reader->buf_start;\r\ndata = dbuf->vb.vaddr + reader->buf_start;\r\ncount = min(count, avail);\r\nif (copy_to_user(ubuf, data, count))\r\nreturn -EFAULT;\r\navail -= count;\r\nif (avail > 0) {\r\nreader->buf_start += count;\r\nreader->buf = dbuf;\r\nreturn count;\r\n}\r\nret = videobuf_dma_map(priv->dev, &dbuf->vb);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to remap buffer for DMA\n");\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irq(&priv->lock);\r\nreader->buf = NULL;\r\nif (!priv->enabled || dbuf->size != priv->bufsize) {\r\ndrop_buffer = true;\r\ngoto out_unlock;\r\n}\r\nlist_add_tail(&dbuf->entry, &priv->free);\r\nout_unlock:\r\nspin_unlock_irq(&priv->lock);\r\nif (drop_buffer) {\r\nvideobuf_dma_unmap(priv->dev, &dbuf->vb);\r\ndata_free_buffer(dbuf);\r\n}\r\nreturn count;\r\n}\r\nstatic unsigned int data_poll(struct file *filp, struct poll_table_struct *tbl)\r\n{\r\nstruct fpga_reader *reader = filp->private_data;\r\nstruct fpga_device *priv = reader->priv;\r\nunsigned int mask = 0;\r\npoll_wait(filp, &priv->wait, tbl);\r\nif (!list_empty(&priv->used))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int data_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct fpga_reader *reader = filp->private_data;\r\nstruct fpga_device *priv = reader->priv;\r\nunsigned long offset, vsize, psize, addr;\r\noffset = vma->vm_pgoff << PAGE_SHIFT;\r\nvsize = vma->vm_end - vma->vm_start;\r\npsize = priv->phys_size - offset;\r\naddr = (priv->phys_addr + offset) >> PAGE_SHIFT;\r\nif (vsize > psize) {\r\ndev_err(priv->dev, "requested mmap mapping too large\n");\r\nreturn -EINVAL;\r\n}\r\nvma->vm_flags |= VM_IO | VM_RESERVED;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn io_remap_pfn_range(vma, vma->vm_start, addr, vsize,\r\nvma->vm_page_prot);\r\n}\r\nstatic bool dma_filter(struct dma_chan *chan, void *data)\r\n{\r\nif (chan->chan_id == 0 && chan->device->dev_id == 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int data_of_probe(struct platform_device *op)\r\n{\r\nstruct device_node *of_node = op->dev.of_node;\r\nstruct device *this_device;\r\nstruct fpga_device *priv;\r\nstruct resource res;\r\ndma_cap_mask_t mask;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&op->dev, "Unable to allocate device private data\n");\r\nret = -ENOMEM;\r\ngoto out_return;\r\n}\r\ndev_set_drvdata(&op->dev, priv);\r\npriv->dev = &op->dev;\r\nkref_init(&priv->ref);\r\nmutex_init(&priv->mutex);\r\ndev_set_drvdata(priv->dev, priv);\r\nspin_lock_init(&priv->lock);\r\nINIT_LIST_HEAD(&priv->free);\r\nINIT_LIST_HEAD(&priv->used);\r\ninit_waitqueue_head(&priv->wait);\r\npriv->miscdev.minor = MISC_DYNAMIC_MINOR;\r\npriv->miscdev.name = drv_name;\r\npriv->miscdev.fops = &data_fops;\r\nret = of_address_to_resource(of_node, 0, &res);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to find FPGA physical address\n");\r\nret = -ENODEV;\r\ngoto out_free_priv;\r\n}\r\npriv->phys_addr = res.start;\r\npriv->phys_size = resource_size(&res);\r\npriv->regs = of_iomap(of_node, 0);\r\nif (!priv->regs) {\r\ndev_err(&op->dev, "Unable to ioremap registers\n");\r\nret = -ENOMEM;\r\ngoto out_free_priv;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\ndma_cap_set(DMA_INTERRUPT, mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_SG, mask);\r\npriv->chan = dma_request_channel(mask, dma_filter, NULL);\r\nif (!priv->chan) {\r\ndev_err(&op->dev, "Unable to request DMA channel\n");\r\nret = -ENODEV;\r\ngoto out_unmap_regs;\r\n}\r\npriv->irq = irq_of_parse_and_map(of_node, 0);\r\nif (priv->irq == NO_IRQ) {\r\ndev_err(&op->dev, "Unable to find IRQ line\n");\r\nret = -ENODEV;\r\ngoto out_release_dma;\r\n}\r\niowrite32be(IRQ_CORL_DONE, priv->regs + SYS_IRQ_OUTPUT_DATA);\r\nret = misc_register(&priv->miscdev);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to register miscdevice\n");\r\ngoto out_irq_dispose_mapping;\r\n}\r\nret = data_debugfs_init(priv);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to create debugfs files\n");\r\ngoto out_misc_deregister;\r\n}\r\nthis_device = priv->miscdev.this_device;\r\ndev_set_drvdata(this_device, priv);\r\nret = sysfs_create_group(&this_device->kobj, &rt_sysfs_attr_group);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to create sysfs files\n");\r\ngoto out_data_debugfs_exit;\r\n}\r\ndev_info(&op->dev, "CARMA FPGA Realtime Data Driver Loaded\n");\r\nreturn 0;\r\nout_data_debugfs_exit:\r\ndata_debugfs_exit(priv);\r\nout_misc_deregister:\r\nmisc_deregister(&priv->miscdev);\r\nout_irq_dispose_mapping:\r\nirq_dispose_mapping(priv->irq);\r\nout_release_dma:\r\ndma_release_channel(priv->chan);\r\nout_unmap_regs:\r\niounmap(priv->regs);\r\nout_free_priv:\r\nkref_put(&priv->ref, fpga_device_release);\r\nout_return:\r\nreturn ret;\r\n}\r\nstatic int data_of_remove(struct platform_device *op)\r\n{\r\nstruct fpga_device *priv = dev_get_drvdata(&op->dev);\r\nstruct device *this_device = priv->miscdev.this_device;\r\nsysfs_remove_group(&this_device->kobj, &rt_sysfs_attr_group);\r\ndata_debugfs_exit(priv);\r\ndata_device_disable(priv);\r\nmisc_deregister(&priv->miscdev);\r\nirq_dispose_mapping(priv->irq);\r\ndma_release_channel(priv->chan);\r\niounmap(priv->regs);\r\nkref_put(&priv->ref, fpga_device_release);\r\nreturn 0;\r\n}
