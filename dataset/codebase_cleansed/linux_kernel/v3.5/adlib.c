static int __devinit snd_adlib_match(struct device *dev, unsigned int n)\r\n{\r\nif (!enable[n])\r\nreturn 0;\r\nif (port[n] == SNDRV_AUTO_PORT) {\r\ndev_err(dev, "please specify port\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void snd_adlib_free(struct snd_card *card)\r\n{\r\nrelease_and_free_resource(card->private_data);\r\n}\r\nstatic int __devinit snd_adlib_probe(struct device *dev, unsigned int n)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_opl3 *opl3;\r\nint error;\r\nerror = snd_card_create(index[n], id[n], THIS_MODULE, 0, &card);\r\nif (error < 0) {\r\ndev_err(dev, "could not create card\n");\r\nreturn error;\r\n}\r\ncard->private_data = request_region(port[n], 4, CRD_NAME);\r\nif (!card->private_data) {\r\ndev_err(dev, "could not grab ports\n");\r\nerror = -EBUSY;\r\ngoto out;\r\n}\r\ncard->private_free = snd_adlib_free;\r\nstrcpy(card->driver, DEV_NAME);\r\nstrcpy(card->shortname, CRD_NAME);\r\nsprintf(card->longname, CRD_NAME " at %#lx", port[n]);\r\nerror = snd_opl3_create(card, port[n], port[n] + 2, OPL3_HW_AUTO, 1, &opl3);\r\nif (error < 0) {\r\ndev_err(dev, "could not create OPL\n");\r\ngoto out;\r\n}\r\nerror = snd_opl3_hwdep_new(opl3, 0, 0, NULL);\r\nif (error < 0) {\r\ndev_err(dev, "could not create FM\n");\r\ngoto out;\r\n}\r\nsnd_card_set_dev(card, dev);\r\nerror = snd_card_register(card);\r\nif (error < 0) {\r\ndev_err(dev, "could not register card\n");\r\ngoto out;\r\n}\r\ndev_set_drvdata(dev, card);\r\nreturn 0;\r\nout: snd_card_free(card);\r\nreturn error;\r\n}\r\nstatic int __devexit snd_adlib_remove(struct device *dev, unsigned int n)\r\n{\r\nsnd_card_free(dev_get_drvdata(dev));\r\ndev_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_adlib_init(void)\r\n{\r\nreturn isa_register_driver(&snd_adlib_driver, SNDRV_CARDS);\r\n}\r\nstatic void __exit alsa_card_adlib_exit(void)\r\n{\r\nisa_unregister_driver(&snd_adlib_driver);\r\n}
