static struct dentry *proc_ns_instantiate(struct inode *dir,\r\nstruct dentry *dentry, struct task_struct *task, const void *ptr)\r\n{\r\nconst struct proc_ns_operations *ns_ops = ptr;\r\nstruct inode *inode;\r\nstruct proc_inode *ei;\r\nstruct dentry *error = ERR_PTR(-ENOENT);\r\nvoid *ns;\r\ninode = proc_pid_make_inode(dir->i_sb, task);\r\nif (!inode)\r\ngoto out;\r\nns = ns_ops->get(task);\r\nif (!ns)\r\ngoto out_iput;\r\nei = PROC_I(inode);\r\ninode->i_mode = S_IFREG|S_IRUSR;\r\ninode->i_fop = &ns_file_operations;\r\nei->ns_ops = ns_ops;\r\nei->ns = ns;\r\nd_set_d_op(dentry, &pid_dentry_operations);\r\nd_add(dentry, inode);\r\nif (pid_revalidate(dentry, NULL))\r\nerror = NULL;\r\nout:\r\nreturn error;\r\nout_iput:\r\niput(inode);\r\ngoto out;\r\n}\r\nstatic int proc_ns_fill_cache(struct file *filp, void *dirent,\r\nfilldir_t filldir, struct task_struct *task,\r\nconst struct proc_ns_operations *ops)\r\n{\r\nreturn proc_fill_cache(filp, dirent, filldir,\r\nops->name, strlen(ops->name),\r\nproc_ns_instantiate, task, ops);\r\n}\r\nstatic int proc_ns_dir_readdir(struct file *filp, void *dirent,\r\nfilldir_t filldir)\r\n{\r\nint i;\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nstruct task_struct *task = get_proc_task(inode);\r\nconst struct proc_ns_operations **entry, **last;\r\nino_t ino;\r\nint ret;\r\nret = -ENOENT;\r\nif (!task)\r\ngoto out_no_task;\r\nret = -EPERM;\r\nif (!ptrace_may_access(task, PTRACE_MODE_READ))\r\ngoto out;\r\nret = 0;\r\ni = filp->f_pos;\r\nswitch (i) {\r\ncase 0:\r\nino = inode->i_ino;\r\nif (filldir(dirent, ".", 1, i, ino, DT_DIR) < 0)\r\ngoto out;\r\ni++;\r\nfilp->f_pos++;\r\ncase 1:\r\nino = parent_ino(dentry);\r\nif (filldir(dirent, "..", 2, i, ino, DT_DIR) < 0)\r\ngoto out;\r\ni++;\r\nfilp->f_pos++;\r\ndefault:\r\ni -= 2;\r\nif (i >= ARRAY_SIZE(ns_entries)) {\r\nret = 1;\r\ngoto out;\r\n}\r\nentry = ns_entries + i;\r\nlast = &ns_entries[ARRAY_SIZE(ns_entries) - 1];\r\nwhile (entry <= last) {\r\nif (proc_ns_fill_cache(filp, dirent, filldir,\r\ntask, *entry) < 0)\r\ngoto out;\r\nfilp->f_pos++;\r\nentry++;\r\n}\r\n}\r\nret = 1;\r\nout:\r\nput_task_struct(task);\r\nout_no_task:\r\nreturn ret;\r\n}\r\nstatic struct dentry *proc_ns_dir_lookup(struct inode *dir,\r\nstruct dentry *dentry, struct nameidata *nd)\r\n{\r\nstruct dentry *error;\r\nstruct task_struct *task = get_proc_task(dir);\r\nconst struct proc_ns_operations **entry, **last;\r\nunsigned int len = dentry->d_name.len;\r\nerror = ERR_PTR(-ENOENT);\r\nif (!task)\r\ngoto out_no_task;\r\nerror = ERR_PTR(-EPERM);\r\nif (!ptrace_may_access(task, PTRACE_MODE_READ))\r\ngoto out;\r\nlast = &ns_entries[ARRAY_SIZE(ns_entries)];\r\nfor (entry = ns_entries; entry < last; entry++) {\r\nif (strlen((*entry)->name) != len)\r\ncontinue;\r\nif (!memcmp(dentry->d_name.name, (*entry)->name, len))\r\nbreak;\r\n}\r\nerror = ERR_PTR(-ENOENT);\r\nif (entry == last)\r\ngoto out;\r\nerror = proc_ns_instantiate(dir, dentry, task, *entry);\r\nout:\r\nput_task_struct(task);\r\nout_no_task:\r\nreturn error;\r\n}\r\nstruct file *proc_ns_fget(int fd)\r\n{\r\nstruct file *file;\r\nfile = fget(fd);\r\nif (!file)\r\nreturn ERR_PTR(-EBADF);\r\nif (file->f_op != &ns_file_operations)\r\ngoto out_invalid;\r\nreturn file;\r\nout_invalid:\r\nfput(file);\r\nreturn ERR_PTR(-EINVAL);\r\n}
