void pvclock_set_flags(u8 flags)\r\n{\r\nvalid_flags = flags;\r\n}\r\nstatic u64 pvclock_get_nsec_offset(struct pvclock_shadow_time *shadow)\r\n{\r\nu64 delta = native_read_tsc() - shadow->tsc_timestamp;\r\nreturn pvclock_scale_delta(delta, shadow->tsc_to_nsec_mul,\r\nshadow->tsc_shift);\r\n}\r\nstatic unsigned pvclock_get_time_values(struct pvclock_shadow_time *dst,\r\nstruct pvclock_vcpu_time_info *src)\r\n{\r\ndo {\r\ndst->version = src->version;\r\nrmb();\r\ndst->tsc_timestamp = src->tsc_timestamp;\r\ndst->system_timestamp = src->system_time;\r\ndst->tsc_to_nsec_mul = src->tsc_to_system_mul;\r\ndst->tsc_shift = src->tsc_shift;\r\ndst->flags = src->flags;\r\nrmb();\r\n} while ((src->version & 1) || (dst->version != src->version));\r\nreturn dst->version;\r\n}\r\nunsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src)\r\n{\r\nu64 pv_tsc_khz = 1000000ULL << 32;\r\ndo_div(pv_tsc_khz, src->tsc_to_system_mul);\r\nif (src->tsc_shift < 0)\r\npv_tsc_khz <<= -src->tsc_shift;\r\nelse\r\npv_tsc_khz >>= src->tsc_shift;\r\nreturn pv_tsc_khz;\r\n}\r\nvoid pvclock_resume(void)\r\n{\r\natomic64_set(&last_value, 0);\r\n}\r\ncycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src)\r\n{\r\nstruct pvclock_shadow_time shadow;\r\nunsigned version;\r\ncycle_t ret, offset;\r\nu64 last;\r\ndo {\r\nversion = pvclock_get_time_values(&shadow, src);\r\nbarrier();\r\noffset = pvclock_get_nsec_offset(&shadow);\r\nret = shadow.system_timestamp + offset;\r\nbarrier();\r\n} while (version != src->version);\r\nif ((valid_flags & PVCLOCK_TSC_STABLE_BIT) &&\r\n(shadow.flags & PVCLOCK_TSC_STABLE_BIT))\r\nreturn ret;\r\nlast = atomic64_read(&last_value);\r\ndo {\r\nif (ret < last)\r\nreturn last;\r\nlast = atomic64_cmpxchg(&last_value, last, ret);\r\n} while (unlikely(last != ret));\r\nreturn ret;\r\n}\r\nvoid pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,\r\nstruct pvclock_vcpu_time_info *vcpu_time,\r\nstruct timespec *ts)\r\n{\r\nu32 version;\r\nu64 delta;\r\nstruct timespec now;\r\ndo {\r\nversion = wall_clock->version;\r\nrmb();\r\nnow.tv_sec = wall_clock->sec;\r\nnow.tv_nsec = wall_clock->nsec;\r\nrmb();\r\n} while ((wall_clock->version & 1) || (version != wall_clock->version));\r\ndelta = pvclock_clocksource_read(vcpu_time);\r\ndelta += now.tv_sec * (u64)NSEC_PER_SEC + now.tv_nsec;\r\nnow.tv_nsec = do_div(delta, NSEC_PER_SEC);\r\nnow.tv_sec = delta;\r\nset_normalized_timespec(ts, now.tv_sec, now.tv_nsec);\r\n}
