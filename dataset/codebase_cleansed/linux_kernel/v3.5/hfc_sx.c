static inline void\r\nWrite_hfc(struct IsdnCardState *cs, u_char regnum, u_char val)\r\n{\r\nbyteout(cs->hw.hfcsx.base + 1, regnum);\r\nbyteout(cs->hw.hfcsx.base, val);\r\n}\r\nstatic inline u_char\r\nRead_hfc(struct IsdnCardState *cs, u_char regnum)\r\n{\r\nu_char ret;\r\nbyteout(cs->hw.hfcsx.base + 1, regnum);\r\nret = bytein(cs->hw.hfcsx.base);\r\nreturn (ret);\r\n}\r\nstatic void\r\nfifo_select(struct IsdnCardState *cs, u_char fifo)\r\n{\r\nif (fifo == cs->hw.hfcsx.last_fifo)\r\nreturn;\r\nbyteout(cs->hw.hfcsx.base + 1, HFCSX_FIF_SEL);\r\nbyteout(cs->hw.hfcsx.base, fifo);\r\nwhile (bytein(cs->hw.hfcsx.base + 1) & 1);\r\nudelay(4);\r\nbyteout(cs->hw.hfcsx.base, fifo);\r\nwhile (bytein(cs->hw.hfcsx.base + 1) & 1);\r\n}\r\nstatic void\r\nreset_fifo(struct IsdnCardState *cs, u_char fifo)\r\n{\r\nfifo_select(cs, fifo);\r\nbyteout(cs->hw.hfcsx.base + 1, HFCSX_CIRM);\r\nbyteout(cs->hw.hfcsx.base, cs->hw.hfcsx.cirm | 0x80);\r\nudelay(1);\r\nwhile (bytein(cs->hw.hfcsx.base + 1) & 1);\r\n}\r\nstatic int\r\nwrite_fifo(struct IsdnCardState *cs, struct sk_buff *skb, u_char fifo, int trans_max)\r\n{\r\nunsigned short *msp;\r\nint fifo_size, count, z1, z2;\r\nu_char f_msk, f1, f2, *src;\r\nif (skb->len <= 0) return (0);\r\nif (fifo & 1) return (0);\r\nfifo_select(cs, fifo);\r\nif (fifo & 4) {\r\nfifo_size = D_FIFO_SIZE;\r\nf_msk = MAX_D_FRAMES;\r\nif (trans_max) return (0);\r\n}\r\nelse {\r\nfifo_size = cs->hw.hfcsx.b_fifo_size;\r\nf_msk = MAX_B_FRAMES;\r\n}\r\nz1 = Read_hfc(cs, HFCSX_FIF_Z1H);\r\nz1 = ((z1 << 8) | Read_hfc(cs, HFCSX_FIF_Z1L));\r\nif (trans_max) {\r\nz2 = Read_hfc(cs, HFCSX_FIF_Z2H);\r\nz2 = ((z2 << 8) | Read_hfc(cs, HFCSX_FIF_Z2L));\r\ncount = z2 - z1;\r\nif (count <= 0)\r\ncount += fifo_size;\r\nif (count < skb->len + 1) return (0);\r\ncount = fifo_size - count;\r\nif (count > 2 * trans_max) return (0);\r\ncount = skb->len;\r\nsrc = skb->data;\r\nwhile (count--)\r\nWrite_hfc(cs, HFCSX_FIF_DWR, *src++);\r\nreturn (1);\r\n}\r\nmsp = ((struct hfcsx_extra *)(cs->hw.hfcsx.extra))->marker;\r\nmsp += (((fifo >> 1) & 3) * (MAX_B_FRAMES + 1));\r\nf1 = Read_hfc(cs, HFCSX_FIF_F1) & f_msk;\r\nf2 = Read_hfc(cs, HFCSX_FIF_F2) & f_msk;\r\ncount = f1 - f2;\r\nif (count < 0)\r\ncount += (f_msk + 1);\r\nif (count > f_msk - 1) {\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_write_fifo %d more as %d frames", fifo, f_msk - 1);\r\nreturn (0);\r\n}\r\n*(msp + f1) = z1;\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_write_fifo %d f1(%x) f2(%x) z1(f1)(%x)",\r\nfifo, f1, f2, z1);\r\ncount = *(msp + f2) - z1;\r\nif (count <= 0)\r\ncount += fifo_size;\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_write_fifo %d count(%u/%d)",\r\nfifo, skb->len, count);\r\nif (count < skb->len) {\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_write_fifo %d no fifo mem", fifo);\r\nreturn (0);\r\n}\r\ncount = skb->len;\r\nsrc = skb->data;\r\nwhile (count--)\r\nWrite_hfc(cs, HFCSX_FIF_DWR, *src++);\r\nRead_hfc(cs, HFCSX_FIF_INCF1);\r\nudelay(1);\r\nwhile (bytein(cs->hw.hfcsx.base + 1) & 1);\r\nreturn (1);\r\n}\r\nstatic struct sk_buff *\r\nread_fifo(struct IsdnCardState *cs, u_char fifo, int trans_max)\r\n{ int fifo_size, count, z1, z2;\r\nu_char f_msk, f1, f2, *dst;\r\nstruct sk_buff *skb;\r\nif (!(fifo & 1)) return (NULL);\r\nfifo_select(cs, fifo);\r\nif (fifo & 4) {\r\nfifo_size = D_FIFO_SIZE;\r\nf_msk = MAX_D_FRAMES;\r\nif (trans_max) return (NULL);\r\n}\r\nelse {\r\nfifo_size = cs->hw.hfcsx.b_fifo_size;\r\nf_msk = MAX_B_FRAMES;\r\n}\r\nif (trans_max) {\r\nz1 = Read_hfc(cs, HFCSX_FIF_Z1H);\r\nz1 = ((z1 << 8) | Read_hfc(cs, HFCSX_FIF_Z1L));\r\nz2 = Read_hfc(cs, HFCSX_FIF_Z2H);\r\nz2 = ((z2 << 8) | Read_hfc(cs, HFCSX_FIF_Z2L));\r\ncount = z1 - z2;\r\nif (count <= 0)\r\ncount += fifo_size;\r\ncount++;\r\nif (count > trans_max)\r\ncount = trans_max;\r\nskb = dev_alloc_skb(count);\r\nif (skb) {\r\ndst = skb_put(skb, count);\r\nwhile (count--)\r\n*dst++ = Read_hfc(cs, HFCSX_FIF_DRD);\r\nreturn skb;\r\n} else\r\nreturn NULL;\r\n}\r\ndo {\r\nf1 = Read_hfc(cs, HFCSX_FIF_F1) & f_msk;\r\nf2 = Read_hfc(cs, HFCSX_FIF_F2) & f_msk;\r\nif (f1 == f2) return (NULL);\r\nz1 = Read_hfc(cs, HFCSX_FIF_Z1H);\r\nz1 = ((z1 << 8) | Read_hfc(cs, HFCSX_FIF_Z1L));\r\nz2 = Read_hfc(cs, HFCSX_FIF_Z2H);\r\nz2 = ((z2 << 8) | Read_hfc(cs, HFCSX_FIF_Z2L));\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_read_fifo %d f1(%x) f2(%x) z1(f2)(%x) z2(f2)(%x)",\r\nfifo, f1, f2, z1, z2);\r\ncount = z1 - z2;\r\nif (count <= 0)\r\ncount += fifo_size;\r\ncount++;\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_read_fifo %d count %u)",\r\nfifo, count);\r\nif ((count > fifo_size) || (count < 4)) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcsx_read_fifo %d paket inv. len %d ", fifo , count);\r\nwhile (count) {\r\ncount--;\r\nRead_hfc(cs, HFCSX_FIF_DRD);\r\n}\r\nskb = NULL;\r\n} else\r\nif ((skb = dev_alloc_skb(count - 3))) {\r\ncount -= 3;\r\ndst = skb_put(skb, count);\r\nwhile (count--)\r\n*dst++ = Read_hfc(cs, HFCSX_FIF_DRD);\r\nRead_hfc(cs, HFCSX_FIF_DRD);\r\nRead_hfc(cs, HFCSX_FIF_DRD);\r\nif (Read_hfc(cs, HFCSX_FIF_DRD)) {\r\ndev_kfree_skb_irq(skb);\r\nif (cs->debug & L1_DEB_ISAC_FIFO)\r\ndebugl1(cs, "hfcsx_read_fifo %d crc error", fifo);\r\nskb = NULL;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "HFC-SX: receive out of memory\n");\r\nreturn (NULL);\r\n}\r\nRead_hfc(cs, HFCSX_FIF_INCF2);\r\nudelay(1);\r\nwhile (bytein(cs->hw.hfcsx.base + 1) & 1);\r\nudelay(1);\r\n} while (!skb);\r\nreturn (skb);\r\n}\r\nstatic void\r\nrelease_io_hfcsx(struct IsdnCardState *cs)\r\n{\r\ncs->hw.hfcsx.int_m2 = 0;\r\nWrite_hfc(cs, HFCSX_INT_M2, cs->hw.hfcsx.int_m2);\r\nWrite_hfc(cs, HFCSX_CIRM, HFCSX_RESET);\r\nmsleep(30);\r\nWrite_hfc(cs, HFCSX_CIRM, 0);\r\ndel_timer(&cs->hw.hfcsx.timer);\r\nrelease_region(cs->hw.hfcsx.base, 2);\r\nkfree(cs->hw.hfcsx.extra);\r\ncs->hw.hfcsx.extra = NULL;\r\n}\r\nstatic int set_fifo_size(struct IsdnCardState *cs)\r\n{\r\nif (cs->hw.hfcsx.b_fifo_size) return (1);\r\nif ((cs->hw.hfcsx.chip >> 4) == 9) {\r\ncs->hw.hfcsx.b_fifo_size = B_FIFO_SIZE_32K;\r\nreturn (1);\r\n}\r\ncs->hw.hfcsx.b_fifo_size = B_FIFO_SIZE_8K;\r\ncs->hw.hfcsx.cirm |= 0x10;\r\nreturn (0);\r\n}\r\nstatic void\r\nreset_hfcsx(struct IsdnCardState *cs)\r\n{\r\ncs->hw.hfcsx.int_m2 = 0;\r\nWrite_hfc(cs, HFCSX_INT_M2, cs->hw.hfcsx.int_m2);\r\nprintk(KERN_INFO "HFC_SX: resetting card\n");\r\nwhile (1) {\r\nWrite_hfc(cs, HFCSX_CIRM, HFCSX_RESET | cs->hw.hfcsx.cirm);\r\nmdelay(30);\r\nWrite_hfc(cs, HFCSX_CIRM, cs->hw.hfcsx.cirm);\r\nmdelay(20);\r\nif (Read_hfc(cs, HFCSX_STATUS) & 2)\r\nprintk(KERN_WARNING "HFC-SX init bit busy\n");\r\ncs->hw.hfcsx.last_fifo = 0xff;\r\nif (!set_fifo_size(cs)) continue;\r\nbreak;\r\n}\r\ncs->hw.hfcsx.trm = 0 + HFCSX_BTRANS_THRESMASK;\r\nWrite_hfc(cs, HFCSX_TRM, cs->hw.hfcsx.trm);\r\nWrite_hfc(cs, HFCSX_CLKDEL, 0x0e);\r\ncs->hw.hfcsx.sctrl_e = HFCSX_AUTO_AWAKE;\r\nWrite_hfc(cs, HFCSX_SCTRL_E, cs->hw.hfcsx.sctrl_e);\r\ncs->hw.hfcsx.bswapped = 0;\r\ncs->hw.hfcsx.nt_mode = 0;\r\ncs->hw.hfcsx.ctmt = HFCSX_TIM3_125 | HFCSX_AUTO_TIMER;\r\nWrite_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt);\r\ncs->hw.hfcsx.int_m1 = HFCSX_INTS_DTRANS | HFCSX_INTS_DREC |\r\nHFCSX_INTS_L1STATE | HFCSX_INTS_TIMER;\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nif (Read_hfc(cs, HFCSX_INT_S1));\r\nWrite_hfc(cs, HFCSX_STATES, HFCSX_LOAD_STATE | 2);\r\nudelay(10);\r\nWrite_hfc(cs, HFCSX_STATES, 2);\r\ncs->hw.hfcsx.mst_m = HFCSX_MASTER;\r\nWrite_hfc(cs, HFCSX_MST_MODE, cs->hw.hfcsx.mst_m);\r\ncs->hw.hfcsx.sctrl = 0x40;\r\nWrite_hfc(cs, HFCSX_SCTRL, cs->hw.hfcsx.sctrl);\r\ncs->hw.hfcsx.sctrl_r = 0;\r\nWrite_hfc(cs, HFCSX_SCTRL_R, cs->hw.hfcsx.sctrl_r);\r\ncs->hw.hfcsx.conn = 0x36;\r\nWrite_hfc(cs, HFCSX_CONNECT, cs->hw.hfcsx.conn);\r\nWrite_hfc(cs, HFCSX_B1_SSL, 0x80);\r\nWrite_hfc(cs, HFCSX_B2_SSL, 0x81);\r\nWrite_hfc(cs, HFCSX_B1_RSL, 0x80);\r\nWrite_hfc(cs, HFCSX_B2_RSL, 0x81);\r\ncs->hw.hfcsx.int_m2 = HFCSX_IRQ_ENABLE;\r\nWrite_hfc(cs, HFCSX_INT_M2, cs->hw.hfcsx.int_m2);\r\nif (Read_hfc(cs, HFCSX_INT_S2));\r\n}\r\nstatic void\r\nhfcsx_Timer(struct IsdnCardState *cs)\r\n{\r\ncs->hw.hfcsx.timer.expires = jiffies + 75;\r\n}\r\nstatic\r\nstruct BCState *\r\nSel_BCS(struct IsdnCardState *cs, int channel)\r\n{\r\nif (cs->bcs[0].mode && (cs->bcs[0].channel == channel))\r\nreturn (&cs->bcs[0]);\r\nelse if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))\r\nreturn (&cs->bcs[1]);\r\nelse\r\nreturn (NULL);\r\n}\r\nstatic\r\nint\r\nreceive_dmsg(struct IsdnCardState *cs)\r\n{\r\nstruct sk_buff *skb;\r\nint count = 5;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "rec_dmsg blocked");\r\nreturn (1);\r\n}\r\ndo {\r\nskb = read_fifo(cs, HFCSX_SEL_D_RX, 0);\r\nif (skb) {\r\nskb_queue_tail(&cs->rq, skb);\r\nschedule_event(cs, D_RCVBUFREADY);\r\n}\r\n} while (--count && skb);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nreturn (1);\r\n}\r\nstatic void\r\nmain_rec_hfcsx(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint count = 5;\r\nstruct sk_buff *skb;\r\nBegin:\r\ncount--;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "rec_data %d blocked", bcs->channel);\r\nreturn;\r\n}\r\nskb = read_fifo(cs, ((bcs->channel) && (!cs->hw.hfcsx.bswapped)) ?\r\nHFCSX_SEL_B2_RX : HFCSX_SEL_B1_RX,\r\n(bcs->mode == L1_MODE_TRANS) ?\r\nHFCSX_BTRANS_THRESHOLD : 0);\r\nif (skb) {\r\nskb_queue_tail(&bcs->rqueue, skb);\r\nschedule_event(bcs, B_RCVBUFREADY);\r\n}\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nif (count && skb)\r\ngoto Begin;\r\nreturn;\r\n}\r\nstatic void\r\nhfcsx_fill_dfifo(struct IsdnCardState *cs)\r\n{\r\nif (!cs->tx_skb)\r\nreturn;\r\nif (cs->tx_skb->len <= 0)\r\nreturn;\r\nif (write_fifo(cs, cs->tx_skb, HFCSX_SEL_D_TX, 0)) {\r\ndev_kfree_skb_any(cs->tx_skb);\r\ncs->tx_skb = NULL;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nhfcsx_fill_fifo(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (!bcs->tx_skb)\r\nreturn;\r\nif (bcs->tx_skb->len <= 0)\r\nreturn;\r\nif (write_fifo(cs, bcs->tx_skb,\r\n((bcs->channel) && (!cs->hw.hfcsx.bswapped)) ?\r\nHFCSX_SEL_B2_TX : HFCSX_SEL_B1_TX,\r\n(bcs->mode == L1_MODE_TRANS) ?\r\nHFCSX_BTRANS_THRESHOLD : 0)) {\r\nbcs->tx_cnt -= bcs->tx_skb->len;\r\nif (test_bit(FLG_LLI_L1WAKEUP, &bcs->st->lli.flag) &&\r\n(PACKET_NOACK != bcs->tx_skb->pkt_type)) {\r\nu_long flags;\r\nspin_lock_irqsave(&bcs->aclock, flags);\r\nbcs->ackcnt += bcs->tx_skb->len;\r\nspin_unlock_irqrestore(&bcs->aclock, flags);\r\nschedule_event(bcs, B_ACKPENDING);\r\n}\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\nstatic void\r\ndch_nt_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\ncase (PH_PULL | REQUEST):\r\ncase (PH_PULL | INDICATION):\r\nst->l1.l1hw(st, pr, arg);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nst->l1.l1l2(st, PH_ACTIVATE | CONFIRM, NULL);\r\nbreak;\r\ncase (PH_TESTLOOP | REQUEST):\r\nif (1 & (long) arg)\r\ndebugl1(cs, "PH_TEST_LOOP B1");\r\nif (2 & (long) arg)\r\ndebugl1(cs, "PH_TEST_LOOP B2");\r\nif (!(3 & (long) arg))\r\ndebugl1(cs, "PH_TEST_LOOP DISABLED");\r\nst->l1.l1hw(st, HW_TESTLOOP | REQUEST, arg);\r\nbreak;\r\ndefault:\r\nif (cs->debug)\r\ndebugl1(cs, "dch_nt_l2l1 msg %04X unhandled", pr);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nhfcsx_auxcmd(struct IsdnCardState *cs, isdn_ctrl *ic)\r\n{\r\nunsigned long flags;\r\nint i = *(unsigned int *) ic->parm.num;\r\nif ((ic->arg == 98) &&\r\n(!(cs->hw.hfcsx.int_m1 & (HFCSX_INTS_B2TRANS + HFCSX_INTS_B2REC + HFCSX_INTS_B1TRANS + HFCSX_INTS_B1REC)))) {\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCSX_STATES, HFCSX_LOAD_STATE | 0);\r\nudelay(10);\r\ncs->hw.hfcsx.sctrl |= SCTRL_MODE_NT;\r\nWrite_hfc(cs, HFCSX_SCTRL, cs->hw.hfcsx.sctrl);\r\nudelay(10);\r\nWrite_hfc(cs, HFCSX_STATES, HFCSX_LOAD_STATE | 1);\r\nudelay(10);\r\nWrite_hfc(cs, HFCSX_STATES, 1 | HFCSX_ACTIVATE | HFCSX_DO_ACTION);\r\ncs->dc.hfcsx.ph_state = 1;\r\ncs->hw.hfcsx.nt_mode = 1;\r\ncs->hw.hfcsx.nt_timer = 0;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\ncs->stlist->l2.l2l1 = dch_nt_l2l1;\r\ndebugl1(cs, "NT mode activated");\r\nreturn (0);\r\n}\r\nif ((cs->chanlimit > 1) || (cs->hw.hfcsx.bswapped) ||\r\n(cs->hw.hfcsx.nt_mode) || (ic->arg != 12))\r\nreturn (-EINVAL);\r\nif (i) {\r\ncs->logecho = 1;\r\ncs->hw.hfcsx.trm |= 0x20;\r\ncs->hw.hfcsx.int_m1 |= HFCSX_INTS_B2REC;\r\n} else {\r\ncs->logecho = 0;\r\ncs->hw.hfcsx.trm &= ~0x20;\r\ncs->hw.hfcsx.int_m1 &= ~HFCSX_INTS_B2REC;\r\n}\r\ncs->hw.hfcsx.sctrl_r &= ~SCTRL_B2_ENA;\r\ncs->hw.hfcsx.sctrl &= ~SCTRL_B2_ENA;\r\ncs->hw.hfcsx.conn |= 0x10;\r\ncs->hw.hfcsx.ctmt &= ~2;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt);\r\nWrite_hfc(cs, HFCSX_SCTRL_R, cs->hw.hfcsx.sctrl_r);\r\nWrite_hfc(cs, HFCSX_SCTRL, cs->hw.hfcsx.sctrl);\r\nWrite_hfc(cs, HFCSX_CONNECT, cs->hw.hfcsx.conn);\r\nWrite_hfc(cs, HFCSX_TRM, cs->hw.hfcsx.trm);\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\n}\r\nstatic void\r\nreceive_emsg(struct IsdnCardState *cs)\r\n{\r\nint count = 5;\r\nu_char *ptr;\r\nstruct sk_buff *skb;\r\nif (test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ndebugl1(cs, "echo_rec_data blocked");\r\nreturn;\r\n}\r\ndo {\r\nskb = read_fifo(cs, HFCSX_SEL_B2_RX, 0);\r\nif (skb) {\r\nif (cs->debug & DEB_DLOG_HEX) {\r\nptr = cs->dlog;\r\nif ((skb->len) < MAX_DLOG_SPACE / 3 - 10) {\r\n*ptr++ = 'E';\r\n*ptr++ = 'C';\r\n*ptr++ = 'H';\r\n*ptr++ = 'O';\r\n*ptr++ = ':';\r\nptr += QuickHex(ptr, skb->data, skb->len);\r\nptr--;\r\n*ptr++ = '\n';\r\n*ptr = 0;\r\nHiSax_putstatus(cs, NULL, cs->dlog);\r\n} else\r\nHiSax_putstatus(cs, "LogEcho: ", "warning Frame too big (%d)", skb->len);\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\n} while (--count && skb);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\nreturn;\r\n}\r\nstatic irqreturn_t\r\nhfcsx_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char exval;\r\nstruct BCState *bcs;\r\nint count = 15;\r\nu_long flags;\r\nu_char val, stat;\r\nif (!(cs->hw.hfcsx.int_m2 & 0x08))\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (HFCSX_ANYINT & (stat = Read_hfc(cs, HFCSX_STATUS))) {\r\nval = Read_hfc(cs, HFCSX_INT_S1);\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFC-SX: stat(%02x) s1(%02x)", stat, val);\r\n} else {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFC-SX irq %x %s", val,\r\ntest_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags) ?\r\n"locked" : "unlocked");\r\nval &= cs->hw.hfcsx.int_m1;\r\nif (val & 0x40) {\r\nexval = Read_hfc(cs, HFCSX_STATES) & 0xf;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ph_state chg %d->%d", cs->dc.hfcsx.ph_state,\r\nexval);\r\ncs->dc.hfcsx.ph_state = exval;\r\nschedule_event(cs, D_L1STATECHANGE);\r\nval &= ~0x40;\r\n}\r\nif (val & 0x80) {\r\nif (cs->hw.hfcsx.nt_mode) {\r\nif ((--cs->hw.hfcsx.nt_timer) < 0)\r\nschedule_event(cs, D_L1STATECHANGE);\r\n}\r\nval &= ~0x80;\r\nWrite_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt | HFCSX_CLTIMER);\r\n}\r\nwhile (val) {\r\nif (test_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\ncs->hw.hfcsx.int_s1 |= val;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cs->hw.hfcsx.int_s1 & 0x18) {\r\nexval = val;\r\nval = cs->hw.hfcsx.int_s1;\r\ncs->hw.hfcsx.int_s1 = exval;\r\n}\r\nif (val & 0x08) {\r\nif (!(bcs = Sel_BCS(cs, cs->hw.hfcsx.bswapped ? 1 : 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcsx spurious 0x08 IRQ");\r\n} else\r\nmain_rec_hfcsx(bcs);\r\n}\r\nif (val & 0x10) {\r\nif (cs->logecho)\r\nreceive_emsg(cs);\r\nelse if (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcsx spurious 0x10 IRQ");\r\n} else\r\nmain_rec_hfcsx(bcs);\r\n}\r\nif (val & 0x01) {\r\nif (!(bcs = Sel_BCS(cs, cs->hw.hfcsx.bswapped ? 1 : 0))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcsx spurious 0x01 IRQ");\r\n} else {\r\nif (bcs->tx_skb) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\n}\r\nif (val & 0x02) {\r\nif (!(bcs = Sel_BCS(cs, 1))) {\r\nif (cs->debug)\r\ndebugl1(cs, "hfcsx spurious 0x02 IRQ");\r\n} else {\r\nif (bcs->tx_skb) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nif ((bcs->tx_skb = skb_dequeue(&bcs->squeue))) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "fill_data %d blocked", bcs->channel);\r\n} else {\r\nschedule_event(bcs, B_XMTBUFREADY);\r\n}\r\n}\r\n}\r\n}\r\nif (val & 0x20) {\r\nreceive_dmsg(cs);\r\n}\r\nif (val & 0x04) {\r\nif (test_and_clear_bit(FLG_DBUSY_TIMER, &cs->HW_Flags))\r\ndel_timer(&cs->dbusytimer);\r\nif (test_and_clear_bit(FLG_L1_DBUSY, &cs->HW_Flags))\r\nschedule_event(cs, D_CLEARBUSY);\r\nif (cs->tx_skb) {\r\nif (cs->tx_skb->len) {\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else {\r\ndebugl1(cs, "hfcsx_fill_dfifo irq blocked");\r\n}\r\ngoto afterXPR;\r\n} else {\r\ndev_kfree_skb_irq(cs->tx_skb);\r\ncs->tx_cnt = 0;\r\ncs->tx_skb = NULL;\r\n}\r\n}\r\nif ((cs->tx_skb = skb_dequeue(&cs->sq))) {\r\ncs->tx_cnt = 0;\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else {\r\ndebugl1(cs, "hfcsx_fill_dfifo irq blocked");\r\n}\r\n} else\r\nschedule_event(cs, D_XMTBUFREADY);\r\n}\r\nafterXPR:\r\nif (cs->hw.hfcsx.int_s1 && count--) {\r\nval = cs->hw.hfcsx.int_s1;\r\ncs->hw.hfcsx.int_s1 = 0;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFC-SX irq %x loop %d", val, 15 - count);\r\n} else\r\nval = 0;\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nhfcsx_dbusy_timer(struct IsdnCardState *cs)\r\n{\r\n}\r\nstatic void\r\nHFCSX_l1hw(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs = (struct IsdnCardState *) st->l1.hardware;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nskb_queue_tail(&cs->sq, skb);\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA Queued", 0);\r\n#endif\r\n} else {\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA", 0);\r\n#endif\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "hfcsx_fill_dfifo blocked");\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->tx_skb) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, " l2l1 tx_skb exist this shouldn't happen");\r\nskb_queue_tail(&cs->sq, skb);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\n}\r\nif (cs->debug & DEB_DLOG_HEX)\r\nLogFrame(cs, skb->data, skb->len);\r\nif (cs->debug & DEB_DLOG_VERBOSE)\r\ndlogframe(cs, skb, 0);\r\ncs->tx_skb = skb;\r\ncs->tx_cnt = 0;\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\nLogl2Frame(cs, skb, "PH_DATA_PULLED", 0);\r\n#endif\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_dfifo(cs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "hfcsx_fill_dfifo blocked");\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\n#ifdef L2FRAME_DEBUG\r\nif (cs->debug & L1_DEB_LAPD)\r\ndebugl1(cs, "-> PH_REQUEST_PULL");\r\n#endif\r\nif (!cs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (HW_RESET | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCSX_STATES, HFCSX_LOAD_STATE | 3);\r\nudelay(6);\r\nWrite_hfc(cs, HFCSX_STATES, 3);\r\ncs->hw.hfcsx.mst_m |= HFCSX_MASTER;\r\nWrite_hfc(cs, HFCSX_MST_MODE, cs->hw.hfcsx.mst_m);\r\nWrite_hfc(cs, HFCSX_STATES, HFCSX_ACTIVATE | HFCSX_DO_ACTION);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nl1_msg(cs, HW_POWERUP | CONFIRM, NULL);\r\nbreak;\r\ncase (HW_ENABLE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nWrite_hfc(cs, HFCSX_STATES, HFCSX_ACTIVATE | HFCSX_DO_ACTION);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_DEACTIVATE | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcsx.mst_m &= ~HFCSX_MASTER;\r\nWrite_hfc(cs, HFCSX_MST_MODE, cs->hw.hfcsx.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_INFO3 | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcsx.mst_m |= HFCSX_MASTER;\r\nWrite_hfc(cs, HFCSX_MST_MODE, cs->hw.hfcsx.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (HW_TESTLOOP | REQUEST):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nswitch ((long) arg) {\r\ncase (1):\r\nWrite_hfc(cs, HFCSX_B1_SSL, 0x80);\r\nWrite_hfc(cs, HFCSX_B1_RSL, 0x80);\r\ncs->hw.hfcsx.conn = (cs->hw.hfcsx.conn & ~7) | 1;\r\nWrite_hfc(cs, HFCSX_CONNECT, cs->hw.hfcsx.conn);\r\nbreak;\r\ncase (2):\r\nWrite_hfc(cs, HFCSX_B2_SSL, 0x81);\r\nWrite_hfc(cs, HFCSX_B2_RSL, 0x81);\r\ncs->hw.hfcsx.conn = (cs->hw.hfcsx.conn & ~0x38) | 0x08;\r\nWrite_hfc(cs, HFCSX_CONNECT, cs->hw.hfcsx.conn);\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcsx_l1hw loop invalid %4lx", (unsigned long)arg);\r\nreturn;\r\n}\r\ncs->hw.hfcsx.trm |= 0x80;\r\nWrite_hfc(cs, HFCSX_TRM, cs->hw.hfcsx.trm);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ndefault:\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "hfcsx_l1hw unknown pr %4x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nsetstack_hfcsx(struct PStack *st, struct IsdnCardState *cs)\r\n{\r\nst->l1.l1hw = HFCSX_l1hw;\r\n}\r\nstatic void\r\nhfcsx_send_data(struct BCState *bcs)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nif (!test_and_set_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags)) {\r\nhfcsx_fill_fifo(bcs);\r\ntest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);\r\n} else\r\ndebugl1(cs, "send_data %d blocked", bcs->channel);\r\n}\r\nstatic void\r\nmode_hfcsx(struct BCState *bcs, int mode, int bc)\r\n{\r\nstruct IsdnCardState *cs = bcs->cs;\r\nint fifo2;\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HFCSX bchannel mode %d bchan %d/%d",\r\nmode, bc, bcs->channel);\r\nbcs->mode = mode;\r\nbcs->channel = bc;\r\nfifo2 = bc;\r\nif (cs->chanlimit > 1) {\r\ncs->hw.hfcsx.bswapped = 0;\r\ncs->hw.hfcsx.sctrl_e &= ~0x80;\r\n} else {\r\nif (bc) {\r\nif (mode != L1_MODE_NULL) {\r\ncs->hw.hfcsx.bswapped = 1;\r\ncs->hw.hfcsx.sctrl_e |= 0x80;\r\n} else {\r\ncs->hw.hfcsx.bswapped = 0;\r\ncs->hw.hfcsx.sctrl_e &= ~0x80;\r\n}\r\nfifo2 = 0;\r\n} else {\r\ncs->hw.hfcsx.bswapped = 0;\r\ncs->hw.hfcsx.sctrl_e &= ~0x80;\r\n}\r\n}\r\nswitch (mode) {\r\ncase (L1_MODE_NULL):\r\nif (bc) {\r\ncs->hw.hfcsx.sctrl &= ~SCTRL_B2_ENA;\r\ncs->hw.hfcsx.sctrl_r &= ~SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcsx.sctrl &= ~SCTRL_B1_ENA;\r\ncs->hw.hfcsx.sctrl_r &= ~SCTRL_B1_ENA;\r\n}\r\nif (fifo2) {\r\ncs->hw.hfcsx.int_m1 &= ~(HFCSX_INTS_B2TRANS + HFCSX_INTS_B2REC);\r\n} else {\r\ncs->hw.hfcsx.int_m1 &= ~(HFCSX_INTS_B1TRANS + HFCSX_INTS_B1REC);\r\n}\r\nbreak;\r\ncase (L1_MODE_TRANS):\r\nif (bc) {\r\ncs->hw.hfcsx.sctrl |= SCTRL_B2_ENA;\r\ncs->hw.hfcsx.sctrl_r |= SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcsx.sctrl |= SCTRL_B1_ENA;\r\ncs->hw.hfcsx.sctrl_r |= SCTRL_B1_ENA;\r\n}\r\nif (fifo2) {\r\ncs->hw.hfcsx.int_m1 |= (HFCSX_INTS_B2TRANS + HFCSX_INTS_B2REC);\r\ncs->hw.hfcsx.ctmt |= 2;\r\ncs->hw.hfcsx.conn &= ~0x18;\r\n} else {\r\ncs->hw.hfcsx.int_m1 |= (HFCSX_INTS_B1TRANS + HFCSX_INTS_B1REC);\r\ncs->hw.hfcsx.ctmt |= 1;\r\ncs->hw.hfcsx.conn &= ~0x03;\r\n}\r\nbreak;\r\ncase (L1_MODE_HDLC):\r\nif (bc) {\r\ncs->hw.hfcsx.sctrl |= SCTRL_B2_ENA;\r\ncs->hw.hfcsx.sctrl_r |= SCTRL_B2_ENA;\r\n} else {\r\ncs->hw.hfcsx.sctrl |= SCTRL_B1_ENA;\r\ncs->hw.hfcsx.sctrl_r |= SCTRL_B1_ENA;\r\n}\r\nif (fifo2) {\r\ncs->hw.hfcsx.int_m1 |= (HFCSX_INTS_B2TRANS + HFCSX_INTS_B2REC);\r\ncs->hw.hfcsx.ctmt &= ~2;\r\ncs->hw.hfcsx.conn &= ~0x18;\r\n} else {\r\ncs->hw.hfcsx.int_m1 |= (HFCSX_INTS_B1TRANS + HFCSX_INTS_B1REC);\r\ncs->hw.hfcsx.ctmt &= ~1;\r\ncs->hw.hfcsx.conn &= ~0x03;\r\n}\r\nbreak;\r\ncase (L1_MODE_EXTRN):\r\nif (bc) {\r\ncs->hw.hfcsx.conn |= 0x10;\r\ncs->hw.hfcsx.sctrl |= SCTRL_B2_ENA;\r\ncs->hw.hfcsx.sctrl_r |= SCTRL_B2_ENA;\r\ncs->hw.hfcsx.int_m1 &= ~(HFCSX_INTS_B2TRANS + HFCSX_INTS_B2REC);\r\n} else {\r\ncs->hw.hfcsx.conn |= 0x02;\r\ncs->hw.hfcsx.sctrl |= SCTRL_B1_ENA;\r\ncs->hw.hfcsx.sctrl_r |= SCTRL_B1_ENA;\r\ncs->hw.hfcsx.int_m1 &= ~(HFCSX_INTS_B1TRANS + HFCSX_INTS_B1REC);\r\n}\r\nbreak;\r\n}\r\nWrite_hfc(cs, HFCSX_SCTRL_E, cs->hw.hfcsx.sctrl_e);\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nWrite_hfc(cs, HFCSX_SCTRL, cs->hw.hfcsx.sctrl);\r\nWrite_hfc(cs, HFCSX_SCTRL_R, cs->hw.hfcsx.sctrl_r);\r\nWrite_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt);\r\nWrite_hfc(cs, HFCSX_CONNECT, cs->hw.hfcsx.conn);\r\nif (mode != L1_MODE_EXTRN) {\r\nreset_fifo(cs, fifo2 ? HFCSX_SEL_B2_RX : HFCSX_SEL_B1_RX);\r\nreset_fifo(cs, fifo2 ? HFCSX_SEL_B2_TX : HFCSX_SEL_B1_TX);\r\n}\r\n}\r\nstatic void\r\nhfcsx_l2l1(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct BCState *bcs = st->l1.bcs;\r\nstruct sk_buff *skb = arg;\r\nu_long flags;\r\nswitch (pr) {\r\ncase (PH_DATA | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nskb_queue_tail(&bcs->squeue, skb);\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | INDICATION):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\nif (bcs->tx_skb) {\r\nprintk(KERN_WARNING "hfc_l2l1: this shouldn't happen\n");\r\n} else {\r\nbcs->tx_skb = skb;\r\nbcs->cs->BC_Send_Data(bcs);\r\n}\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nbreak;\r\ncase (PH_PULL | REQUEST):\r\nif (!bcs->tx_skb) {\r\ntest_and_clear_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nst->l1.l1l2(st, PH_PULL | CONFIRM, NULL);\r\n} else\r\ntest_and_set_bit(FLG_L1_PULL_REQ, &st->l1.Flags);\r\nbreak;\r\ncase (PH_ACTIVATE | REQUEST):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_set_bit(BC_FLG_ACTIV, &bcs->Flag);\r\nmode_hfcsx(bcs, st->l1.mode, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | REQUEST):\r\nl1_msg_b(st, pr, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nspin_lock_irqsave(&bcs->cs->lock, flags);\r\ntest_and_clear_bit(BC_FLG_ACTIV, &bcs->Flag);\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nmode_hfcsx(bcs, 0, st->l1.bc);\r\nspin_unlock_irqrestore(&bcs->cs->lock, flags);\r\nst->l1.l1l2(st, PH_DEACTIVATE | CONFIRM, NULL);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nclose_hfcsx(struct BCState *bcs)\r\n{\r\nmode_hfcsx(bcs, 0, bcs->channel);\r\nif (test_and_clear_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_purge(&bcs->rqueue);\r\nskb_queue_purge(&bcs->squeue);\r\nif (bcs->tx_skb) {\r\ndev_kfree_skb_any(bcs->tx_skb);\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\n}\r\n}\r\n}\r\nstatic int\r\nopen_hfcsxstate(struct IsdnCardState *cs, struct BCState *bcs)\r\n{\r\nif (!test_and_set_bit(BC_FLG_INIT, &bcs->Flag)) {\r\nskb_queue_head_init(&bcs->rqueue);\r\nskb_queue_head_init(&bcs->squeue);\r\n}\r\nbcs->tx_skb = NULL;\r\ntest_and_clear_bit(BC_FLG_BUSY, &bcs->Flag);\r\nbcs->event = 0;\r\nbcs->tx_cnt = 0;\r\nreturn (0);\r\n}\r\nstatic int\r\nsetstack_2b(struct PStack *st, struct BCState *bcs)\r\n{\r\nbcs->channel = st->l1.bc;\r\nif (open_hfcsxstate(st->l1.hardware, bcs))\r\nreturn (-1);\r\nst->l1.bcs = bcs;\r\nst->l2.l2l1 = hfcsx_l2l1;\r\nsetstack_manager(st);\r\nbcs->st = st;\r\nsetstack_l1_B(st);\r\nreturn (0);\r\n}\r\nstatic void\r\nhfcsx_bh(struct work_struct *work)\r\n{\r\nstruct IsdnCardState *cs =\r\ncontainer_of(work, struct IsdnCardState, tqueue);\r\nu_long flags;\r\nif (test_and_clear_bit(D_L1STATECHANGE, &cs->event)) {\r\nif (!cs->hw.hfcsx.nt_mode)\r\nswitch (cs->dc.hfcsx.ph_state) {\r\ncase (0):\r\nl1_msg(cs, HW_RESET | INDICATION, NULL);\r\nbreak;\r\ncase (3):\r\nl1_msg(cs, HW_DEACTIVATE | INDICATION, NULL);\r\nbreak;\r\ncase (8):\r\nl1_msg(cs, HW_RSYNC | INDICATION, NULL);\r\nbreak;\r\ncase (6):\r\nl1_msg(cs, HW_INFO2 | INDICATION, NULL);\r\nbreak;\r\ncase (7):\r\nl1_msg(cs, HW_INFO4_P8 | INDICATION, NULL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n} else {\r\nswitch (cs->dc.hfcsx.ph_state) {\r\ncase (2):\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->hw.hfcsx.nt_timer < 0) {\r\ncs->hw.hfcsx.nt_timer = 0;\r\ncs->hw.hfcsx.int_m1 &= ~HFCSX_INTS_TIMER;\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nif (Read_hfc(cs, HFCSX_INT_S1));\r\nWrite_hfc(cs, HFCSX_STATES, 4 | HFCSX_LOAD_STATE);\r\nudelay(10);\r\nWrite_hfc(cs, HFCSX_STATES, 4);\r\ncs->dc.hfcsx.ph_state = 4;\r\n} else {\r\ncs->hw.hfcsx.int_m1 |= HFCSX_INTS_TIMER;\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\ncs->hw.hfcsx.ctmt &= ~HFCSX_AUTO_TIMER;\r\ncs->hw.hfcsx.ctmt |= HFCSX_TIM3_125;\r\nWrite_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt | HFCSX_CLTIMER);\r\nWrite_hfc(cs, HFCSX_CTMT, cs->hw.hfcsx.ctmt | HFCSX_CLTIMER);\r\ncs->hw.hfcsx.nt_timer = NT_T1_COUNT;\r\nWrite_hfc(cs, HFCSX_STATES, 2 | HFCSX_NT_G2_G3);\r\n}\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ncase (1):\r\ncase (3):\r\ncase (4):\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcsx.nt_timer = 0;\r\ncs->hw.hfcsx.int_m1 &= ~HFCSX_INTS_TIMER;\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (test_and_clear_bit(D_RCVBUFREADY, &cs->event))\r\nDChannel_proc_rcv(cs);\r\nif (test_and_clear_bit(D_XMTBUFREADY, &cs->event))\r\nDChannel_proc_xmt(cs);\r\n}\r\nstatic void inithfcsx(struct IsdnCardState *cs)\r\n{\r\ncs->setstack_d = setstack_hfcsx;\r\ncs->BC_Send_Data = &hfcsx_send_data;\r\ncs->bcs[0].BC_SetStack = setstack_2b;\r\ncs->bcs[1].BC_SetStack = setstack_2b;\r\ncs->bcs[0].BC_Close = close_hfcsx;\r\ncs->bcs[1].BC_Close = close_hfcsx;\r\nmode_hfcsx(cs->bcs, 0, 0);\r\nmode_hfcsx(cs->bcs + 1, 0, 1);\r\n}\r\nstatic int\r\nhfcsx_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "HFCSX: card_msg %x", mt);\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_hfcsx(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nrelease_io_hfcsx(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\ninithfcsx(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nmsleep(80);\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.hfcsx.int_m1 &= ~HFCSX_INTS_TIMER;\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nWrite_hfc(cs, HFCSX_MST_MODE, cs->hw.hfcsx.mst_m);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nreturn (0);\r\n}\r\nreturn (0);\r\n}\r\nint __devinit\r\nsetup_hfcsx(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, hfcsx_revision);\r\nprintk(KERN_INFO "HiSax: HFC-SX driver Rev. %s\n", HiSax_getrev(tmp));\r\n#ifdef __ISAPNP__\r\nif (!card->para[1] && isapnp_present()) {\r\nstruct pnp_dev *pnp_d;\r\nwhile (ipid->card_vendor) {\r\nif ((pnp_c = pnp_find_card(ipid->card_vendor,\r\nipid->card_device, pnp_c))) {\r\npnp_d = NULL;\r\nif ((pnp_d = pnp_find_dev(pnp_c,\r\nipid->vendor, ipid->function, pnp_d))) {\r\nint err;\r\nprintk(KERN_INFO "HiSax: %s detected\n",\r\n(char *)ipid->driver_data);\r\npnp_disable_dev(pnp_d);\r\nerr = pnp_activate_dev(pnp_d);\r\nif (err < 0) {\r\nprintk(KERN_WARNING "%s: pnp_activate_dev ret(%d)\n",\r\n__func__, err);\r\nreturn (0);\r\n}\r\ncard->para[1] = pnp_port_start(pnp_d, 0);\r\ncard->para[0] = pnp_irq(pnp_d, 0);\r\nif (!card->para[0] || !card->para[1]) {\r\nprintk(KERN_ERR "HFC PnP:some resources are missing %ld/%lx\n",\r\ncard->para[0], card->para[1]);\r\npnp_disable_dev(pnp_d);\r\nreturn (0);\r\n}\r\nbreak;\r\n} else {\r\nprintk(KERN_ERR "HFC PnP: PnP error card found, no device\n");\r\n}\r\n}\r\nipid++;\r\npnp_c = NULL;\r\n}\r\nif (!ipid->card_vendor) {\r\nprintk(KERN_INFO "HFC PnP: no ISAPnP card found\n");\r\nreturn (0);\r\n}\r\n}\r\n#endif\r\ncs->hw.hfcsx.base = card->para[1] & 0xfffe;\r\ncs->irq = card->para[0];\r\ncs->hw.hfcsx.int_s1 = 0;\r\ncs->dc.hfcsx.ph_state = 0;\r\ncs->hw.hfcsx.fifo = 255;\r\nif ((cs->typ == ISDN_CTYPE_HFC_SX) ||\r\n(cs->typ == ISDN_CTYPE_HFC_SP_PCMCIA)) {\r\nif ((!cs->hw.hfcsx.base) || !request_region(cs->hw.hfcsx.base, 2, "HFCSX isdn")) {\r\nprintk(KERN_WARNING\r\n"HiSax: HFC-SX io-base %#lx already in use\n",\r\ncs->hw.hfcsx.base);\r\nreturn (0);\r\n}\r\nbyteout(cs->hw.hfcsx.base, cs->hw.hfcsx.base & 0xFF);\r\nbyteout(cs->hw.hfcsx.base + 1,\r\n((cs->hw.hfcsx.base >> 8) & 3) | 0x54);\r\nudelay(10);\r\ncs->hw.hfcsx.chip = Read_hfc(cs, HFCSX_CHIP_ID);\r\nswitch (cs->hw.hfcsx.chip >> 4) {\r\ncase 1:\r\ntmp[0] = '+';\r\nbreak;\r\ncase 9:\r\ntmp[0] = 'P';\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"HFC-SX: invalid chip id 0x%x\n",\r\ncs->hw.hfcsx.chip >> 4);\r\nrelease_region(cs->hw.hfcsx.base, 2);\r\nreturn (0);\r\n}\r\nif (!ccd_sp_irqtab[cs->irq & 0xF]) {\r\nprintk(KERN_WARNING\r\n"HFC_SX: invalid irq %d specified\n", cs->irq & 0xF);\r\nrelease_region(cs->hw.hfcsx.base, 2);\r\nreturn (0);\r\n}\r\nif (!(cs->hw.hfcsx.extra = (void *)\r\nkmalloc(sizeof(struct hfcsx_extra), GFP_ATOMIC))) {\r\nrelease_region(cs->hw.hfcsx.base, 2);\r\nprintk(KERN_WARNING "HFC-SX: unable to allocate memory\n");\r\nreturn (0);\r\n}\r\nprintk(KERN_INFO "HFC-S%c chip detected at base 0x%x IRQ %d HZ %d\n",\r\ntmp[0], (u_int) cs->hw.hfcsx.base, cs->irq, HZ);\r\ncs->hw.hfcsx.int_m2 = 0;\r\ncs->hw.hfcsx.int_m1 = 0;\r\nWrite_hfc(cs, HFCSX_INT_M1, cs->hw.hfcsx.int_m1);\r\nWrite_hfc(cs, HFCSX_INT_M2, cs->hw.hfcsx.int_m2);\r\n} else\r\nreturn (0);\r\ncs->dbusytimer.function = (void *) hfcsx_dbusy_timer;\r\ncs->dbusytimer.data = (long) cs;\r\ninit_timer(&cs->dbusytimer);\r\nINIT_WORK(&cs->tqueue, hfcsx_bh);\r\ncs->readisac = NULL;\r\ncs->writeisac = NULL;\r\ncs->readisacfifo = NULL;\r\ncs->writeisacfifo = NULL;\r\ncs->BC_Read_Reg = NULL;\r\ncs->BC_Write_Reg = NULL;\r\ncs->irq_func = &hfcsx_interrupt;\r\ncs->hw.hfcsx.timer.function = (void *) hfcsx_Timer;\r\ncs->hw.hfcsx.timer.data = (long) cs;\r\ncs->hw.hfcsx.b_fifo_size = 0;\r\ncs->hw.hfcsx.cirm = ccd_sp_irqtab[cs->irq & 0xF];\r\ninit_timer(&cs->hw.hfcsx.timer);\r\nreset_hfcsx(cs);\r\ncs->cardmsg = &hfcsx_card_msg;\r\ncs->auxcmd = &hfcsx_auxcmd;\r\nreturn (1);\r\n}
