static int tda826x_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int tda826x_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tda826x_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 buf [] = { 0x00, 0x8d };\r\nstruct i2c_msg msg = { .addr = priv->i2c_address, .flags = 0, .buf = buf, .len = 2 };\r\ndprintk("%s:\n", __func__);\r\nif (!priv->has_loopthrough)\r\nbuf[1] = 0xad;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif ((ret = i2c_transfer (priv->i2c, &msg, 1)) != 1) {\r\ndprintk("%s: i2c error\n", __func__);\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nstatic int tda826x_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct tda826x_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu32 div;\r\nu32 ksyms;\r\nu32 bandwidth;\r\nu8 buf [11];\r\nstruct i2c_msg msg = { .addr = priv->i2c_address, .flags = 0, .buf = buf, .len = 11 };\r\ndprintk("%s:\n", __func__);\r\ndiv = (p->frequency + (1000-1)) / 1000;\r\nksyms = p->symbol_rate / 1000;\r\nbandwidth = (878 * ksyms + 6500000) / 1000000 + 1;\r\nif (bandwidth < 5)\r\nbandwidth = 5;\r\nelse if (bandwidth > 36)\r\nbandwidth = 36;\r\nbuf[0] = 0x00;\r\nbuf[1] = 0x09;\r\nif (!priv->has_loopthrough)\r\nbuf[1] |= 0x20;\r\nbuf[2] = (1<<5) | 0x0b;\r\nbuf[3] = div >> 7;\r\nbuf[4] = div << 1;\r\nbuf[5] = ((bandwidth - 5) << 3) | 7;\r\nbuf[6] = 0xfe;\r\nbuf[7] = 0x83;\r\nbuf[8] = 0x80;\r\nbuf[9] = 0x1a;\r\nbuf[10] = 0xd4;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif ((ret = i2c_transfer (priv->i2c, &msg, 1)) != 1) {\r\ndprintk("%s: i2c error\n", __func__);\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\npriv->frequency = div * 1000;\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nstatic int tda826x_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda826x_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tda826x_attach(struct dvb_frontend *fe, int addr, struct i2c_adapter *i2c, int has_loopthrough)\r\n{\r\nstruct tda826x_priv *priv = NULL;\r\nu8 b1 [] = { 0, 0 };\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = addr, .flags = 0, .buf = NULL, .len = 0 },\r\n{ .addr = addr, .flags = I2C_M_RD, .buf = b1, .len = 2 }\r\n};\r\nint ret;\r\ndprintk("%s:\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer (i2c, msg, 2);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret != 2)\r\nreturn NULL;\r\nif (!(b1[1] & 0x80))\r\nreturn NULL;\r\npriv = kzalloc(sizeof(struct tda826x_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = addr;\r\npriv->i2c = i2c;\r\npriv->has_loopthrough = has_loopthrough;\r\nmemcpy(&fe->ops.tuner_ops, &tda826x_tuner_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nreturn fe;\r\n}
