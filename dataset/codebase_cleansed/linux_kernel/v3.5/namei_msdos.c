static int msdos_format_name(const unsigned char *name, int len,\r\nunsigned char *res, struct fat_mount_options *opts)\r\n{\r\nunsigned char *walk;\r\nunsigned char c;\r\nint space;\r\nif (name[0] == '.') {\r\nif (opts->dotsOK) {\r\nname++;\r\nlen--;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nspace = 1;\r\nc = 0;\r\nfor (walk = res; len && walk - res < 8; walk++) {\r\nc = *name++;\r\nlen--;\r\nif (opts->name_check != 'r' && strchr(bad_chars, c))\r\nreturn -EINVAL;\r\nif (opts->name_check == 's' && strchr(bad_if_strict, c))\r\nreturn -EINVAL;\r\nif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\r\nreturn -EINVAL;\r\nif (c < ' ' || c == ':' || c == '\\')\r\nreturn -EINVAL;\r\nif ((res == walk) && (c == 0xE5))\r\nc = 0x05;\r\nif (c == '.')\r\nbreak;\r\nspace = (c == ' ');\r\n*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\r\n}\r\nif (space)\r\nreturn -EINVAL;\r\nif (opts->name_check == 's' && len && c != '.') {\r\nc = *name++;\r\nlen--;\r\nif (c != '.')\r\nreturn -EINVAL;\r\n}\r\nwhile (c != '.' && len--)\r\nc = *name++;\r\nif (c == '.') {\r\nwhile (walk - res < 8)\r\n*walk++ = ' ';\r\nwhile (len > 0 && walk - res < MSDOS_NAME) {\r\nc = *name++;\r\nlen--;\r\nif (opts->name_check != 'r' && strchr(bad_chars, c))\r\nreturn -EINVAL;\r\nif (opts->name_check == 's' &&\r\nstrchr(bad_if_strict, c))\r\nreturn -EINVAL;\r\nif (c < ' ' || c == ':' || c == '\\')\r\nreturn -EINVAL;\r\nif (c == '.') {\r\nif (opts->name_check == 's')\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\r\nreturn -EINVAL;\r\nspace = c == ' ';\r\nif (!opts->nocase && c >= 'a' && c <= 'z')\r\n*walk++ = c - 32;\r\nelse\r\n*walk++ = c;\r\n}\r\nif (space)\r\nreturn -EINVAL;\r\nif (opts->name_check == 's' && len)\r\nreturn -EINVAL;\r\n}\r\nwhile (walk - res < MSDOS_NAME)\r\n*walk++ = ' ';\r\nreturn 0;\r\n}\r\nstatic int msdos_find(struct inode *dir, const unsigned char *name, int len,\r\nstruct fat_slot_info *sinfo)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\r\nunsigned char msdos_name[MSDOS_NAME];\r\nint err;\r\nerr = msdos_format_name(name, len, msdos_name, &sbi->options);\r\nif (err)\r\nreturn -ENOENT;\r\nerr = fat_scan(dir, msdos_name, sinfo);\r\nif (!err && sbi->options.dotsOK) {\r\nif (name[0] == '.') {\r\nif (!(sinfo->de->attr & ATTR_HIDDEN))\r\nerr = -ENOENT;\r\n} else {\r\nif (sinfo->de->attr & ATTR_HIDDEN)\r\nerr = -ENOENT;\r\n}\r\nif (err)\r\nbrelse(sinfo->bh);\r\n}\r\nreturn err;\r\n}\r\nstatic int msdos_hash(const struct dentry *dentry, const struct inode *inode,\r\nstruct qstr *qstr)\r\n{\r\nstruct fat_mount_options *options = &MSDOS_SB(dentry->d_sb)->options;\r\nunsigned char msdos_name[MSDOS_NAME];\r\nint error;\r\nerror = msdos_format_name(qstr->name, qstr->len, msdos_name, options);\r\nif (!error)\r\nqstr->hash = full_name_hash(msdos_name, MSDOS_NAME);\r\nreturn 0;\r\n}\r\nstatic int msdos_cmp(const struct dentry *parent, const struct inode *pinode,\r\nconst struct dentry *dentry, const struct inode *inode,\r\nunsigned int len, const char *str, const struct qstr *name)\r\n{\r\nstruct fat_mount_options *options = &MSDOS_SB(parent->d_sb)->options;\r\nunsigned char a_msdos_name[MSDOS_NAME], b_msdos_name[MSDOS_NAME];\r\nint error;\r\nerror = msdos_format_name(name->name, name->len, a_msdos_name, options);\r\nif (error)\r\ngoto old_compare;\r\nerror = msdos_format_name(str, len, b_msdos_name, options);\r\nif (error)\r\ngoto old_compare;\r\nerror = memcmp(a_msdos_name, b_msdos_name, MSDOS_NAME);\r\nout:\r\nreturn error;\r\nold_compare:\r\nerror = 1;\r\nif (name->len == len)\r\nerror = memcmp(name->name, str, len);\r\ngoto out;\r\n}\r\nstatic struct dentry *msdos_lookup(struct inode *dir, struct dentry *dentry,\r\nstruct nameidata *nd)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct fat_slot_info sinfo;\r\nstruct inode *inode;\r\nint err;\r\nlock_super(sb);\r\nerr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\r\nswitch (err) {\r\ncase -ENOENT:\r\ninode = NULL;\r\nbreak;\r\ncase 0:\r\ninode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(sinfo.bh);\r\nbreak;\r\ndefault:\r\ninode = ERR_PTR(err);\r\n}\r\nunlock_super(sb);\r\nreturn d_splice_alias(inode, dentry);\r\n}\r\nstatic int msdos_add_entry(struct inode *dir, const unsigned char *name,\r\nint is_dir, int is_hid, int cluster,\r\nstruct timespec *ts, struct fat_slot_info *sinfo)\r\n{\r\nstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\r\nstruct msdos_dir_entry de;\r\n__le16 time, date;\r\nint err;\r\nmemcpy(de.name, name, MSDOS_NAME);\r\nde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\r\nif (is_hid)\r\nde.attr |= ATTR_HIDDEN;\r\nde.lcase = 0;\r\nfat_time_unix2fat(sbi, ts, &time, &date, NULL);\r\nde.cdate = de.adate = 0;\r\nde.ctime = 0;\r\nde.ctime_cs = 0;\r\nde.time = time;\r\nde.date = date;\r\nde.start = cpu_to_le16(cluster);\r\nde.starthi = cpu_to_le16(cluster >> 16);\r\nde.size = 0;\r\nerr = fat_add_entries(dir, &de, 1, sinfo);\r\nif (err)\r\nreturn err;\r\ndir->i_ctime = dir->i_mtime = *ts;\r\nif (IS_DIRSYNC(dir))\r\n(void)fat_sync_inode(dir);\r\nelse\r\nmark_inode_dirty(dir);\r\nreturn 0;\r\n}\r\nstatic int msdos_create(struct inode *dir, struct dentry *dentry, umode_t mode,\r\nstruct nameidata *nd)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct inode *inode = NULL;\r\nstruct fat_slot_info sinfo;\r\nstruct timespec ts;\r\nunsigned char msdos_name[MSDOS_NAME];\r\nint err, is_hid;\r\nlock_super(sb);\r\nerr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\r\nmsdos_name, &MSDOS_SB(sb)->options);\r\nif (err)\r\ngoto out;\r\nis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\r\nif (!fat_scan(dir, msdos_name, &sinfo)) {\r\nbrelse(sinfo.bh);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nts = CURRENT_TIME_SEC;\r\nerr = msdos_add_entry(dir, msdos_name, 0, is_hid, 0, &ts, &sinfo);\r\nif (err)\r\ngoto out;\r\ninode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(sinfo.bh);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto out;\r\n}\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = ts;\r\nd_instantiate(dentry, inode);\r\nout:\r\nunlock_super(sb);\r\nif (!err)\r\nerr = fat_flush_inodes(sb, dir, inode);\r\nreturn err;\r\n}\r\nstatic int msdos_rmdir(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct inode *inode = dentry->d_inode;\r\nstruct fat_slot_info sinfo;\r\nint err;\r\nlock_super(sb);\r\nerr = fat_dir_empty(inode);\r\nif (err)\r\ngoto out;\r\nerr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\r\nif (err)\r\ngoto out;\r\nerr = fat_remove_entries(dir, &sinfo);\r\nif (err)\r\ngoto out;\r\ndrop_nlink(dir);\r\nclear_nlink(inode);\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\nfat_detach(inode);\r\nout:\r\nunlock_super(sb);\r\nif (!err)\r\nerr = fat_flush_inodes(sb, dir, inode);\r\nreturn err;\r\n}\r\nstatic int msdos_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct fat_slot_info sinfo;\r\nstruct inode *inode;\r\nunsigned char msdos_name[MSDOS_NAME];\r\nstruct timespec ts;\r\nint err, is_hid, cluster;\r\nlock_super(sb);\r\nerr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\r\nmsdos_name, &MSDOS_SB(sb)->options);\r\nif (err)\r\ngoto out;\r\nis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\r\nif (!fat_scan(dir, msdos_name, &sinfo)) {\r\nbrelse(sinfo.bh);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nts = CURRENT_TIME_SEC;\r\ncluster = fat_alloc_new_dir(dir, &ts);\r\nif (cluster < 0) {\r\nerr = cluster;\r\ngoto out;\r\n}\r\nerr = msdos_add_entry(dir, msdos_name, 1, is_hid, cluster, &ts, &sinfo);\r\nif (err)\r\ngoto out_free;\r\ninc_nlink(dir);\r\ninode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\r\nbrelse(sinfo.bh);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\ngoto out;\r\n}\r\nset_nlink(inode, 2);\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = ts;\r\nd_instantiate(dentry, inode);\r\nunlock_super(sb);\r\nfat_flush_inodes(sb, dir, inode);\r\nreturn 0;\r\nout_free:\r\nfat_free_clusters(dir, cluster);\r\nout:\r\nunlock_super(sb);\r\nreturn err;\r\n}\r\nstatic int msdos_unlink(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct super_block *sb= inode->i_sb;\r\nstruct fat_slot_info sinfo;\r\nint err;\r\nlock_super(sb);\r\nerr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\r\nif (err)\r\ngoto out;\r\nerr = fat_remove_entries(dir, &sinfo);\r\nif (err)\r\ngoto out;\r\nclear_nlink(inode);\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\nfat_detach(inode);\r\nout:\r\nunlock_super(sb);\r\nif (!err)\r\nerr = fat_flush_inodes(sb, dir, inode);\r\nreturn err;\r\n}\r\nstatic int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,\r\nstruct dentry *old_dentry,\r\nstruct inode *new_dir, unsigned char *new_name,\r\nstruct dentry *new_dentry, int is_hid)\r\n{\r\nstruct buffer_head *dotdot_bh;\r\nstruct msdos_dir_entry *dotdot_de;\r\nstruct inode *old_inode, *new_inode;\r\nstruct fat_slot_info old_sinfo, sinfo;\r\nstruct timespec ts;\r\nloff_t dotdot_i_pos, new_i_pos;\r\nint err, old_attrs, is_dir, update_dotdot, corrupt = 0;\r\nold_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\r\nold_inode = old_dentry->d_inode;\r\nnew_inode = new_dentry->d_inode;\r\nerr = fat_scan(old_dir, old_name, &old_sinfo);\r\nif (err) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nis_dir = S_ISDIR(old_inode->i_mode);\r\nupdate_dotdot = (is_dir && old_dir != new_dir);\r\nif (update_dotdot) {\r\nif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de,\r\n&dotdot_i_pos) < 0) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n}\r\nold_attrs = MSDOS_I(old_inode)->i_attrs;\r\nerr = fat_scan(new_dir, new_name, &sinfo);\r\nif (!err) {\r\nif (!new_inode) {\r\nif (sinfo.de != old_sinfo.de) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (is_hid)\r\nMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\r\nelse\r\nMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\r\nif (IS_DIRSYNC(old_dir)) {\r\nerr = fat_sync_inode(old_inode);\r\nif (err) {\r\nMSDOS_I(old_inode)->i_attrs = old_attrs;\r\ngoto out;\r\n}\r\n} else\r\nmark_inode_dirty(old_inode);\r\nold_dir->i_version++;\r\nold_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\r\nif (IS_DIRSYNC(old_dir))\r\n(void)fat_sync_inode(old_dir);\r\nelse\r\nmark_inode_dirty(old_dir);\r\ngoto out;\r\n}\r\n}\r\nts = CURRENT_TIME_SEC;\r\nif (new_inode) {\r\nif (err)\r\ngoto out;\r\nif (is_dir) {\r\nerr = fat_dir_empty(new_inode);\r\nif (err)\r\ngoto out;\r\n}\r\nnew_i_pos = MSDOS_I(new_inode)->i_pos;\r\nfat_detach(new_inode);\r\n} else {\r\nerr = msdos_add_entry(new_dir, new_name, is_dir, is_hid, 0,\r\n&ts, &sinfo);\r\nif (err)\r\ngoto out;\r\nnew_i_pos = sinfo.i_pos;\r\n}\r\nnew_dir->i_version++;\r\nfat_detach(old_inode);\r\nfat_attach(old_inode, new_i_pos);\r\nif (is_hid)\r\nMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\r\nelse\r\nMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\r\nif (IS_DIRSYNC(new_dir)) {\r\nerr = fat_sync_inode(old_inode);\r\nif (err)\r\ngoto error_inode;\r\n} else\r\nmark_inode_dirty(old_inode);\r\nif (update_dotdot) {\r\nint start = MSDOS_I(new_dir)->i_logstart;\r\ndotdot_de->start = cpu_to_le16(start);\r\ndotdot_de->starthi = cpu_to_le16(start >> 16);\r\nmark_buffer_dirty_inode(dotdot_bh, old_inode);\r\nif (IS_DIRSYNC(new_dir)) {\r\nerr = sync_dirty_buffer(dotdot_bh);\r\nif (err)\r\ngoto error_dotdot;\r\n}\r\ndrop_nlink(old_dir);\r\nif (!new_inode)\r\ninc_nlink(new_dir);\r\n}\r\nerr = fat_remove_entries(old_dir, &old_sinfo);\r\nold_sinfo.bh = NULL;\r\nif (err)\r\ngoto error_dotdot;\r\nold_dir->i_version++;\r\nold_dir->i_ctime = old_dir->i_mtime = ts;\r\nif (IS_DIRSYNC(old_dir))\r\n(void)fat_sync_inode(old_dir);\r\nelse\r\nmark_inode_dirty(old_dir);\r\nif (new_inode) {\r\ndrop_nlink(new_inode);\r\nif (is_dir)\r\ndrop_nlink(new_inode);\r\nnew_inode->i_ctime = ts;\r\n}\r\nout:\r\nbrelse(sinfo.bh);\r\nbrelse(dotdot_bh);\r\nbrelse(old_sinfo.bh);\r\nreturn err;\r\nerror_dotdot:\r\ncorrupt = 1;\r\nif (update_dotdot) {\r\nint start = MSDOS_I(old_dir)->i_logstart;\r\ndotdot_de->start = cpu_to_le16(start);\r\ndotdot_de->starthi = cpu_to_le16(start >> 16);\r\nmark_buffer_dirty_inode(dotdot_bh, old_inode);\r\ncorrupt |= sync_dirty_buffer(dotdot_bh);\r\n}\r\nerror_inode:\r\nfat_detach(old_inode);\r\nfat_attach(old_inode, old_sinfo.i_pos);\r\nMSDOS_I(old_inode)->i_attrs = old_attrs;\r\nif (new_inode) {\r\nfat_attach(new_inode, new_i_pos);\r\nif (corrupt)\r\ncorrupt |= fat_sync_inode(new_inode);\r\n} else {\r\nint err2 = fat_remove_entries(new_dir, &sinfo);\r\nif (corrupt)\r\ncorrupt |= err2;\r\nsinfo.bh = NULL;\r\n}\r\nif (corrupt < 0) {\r\nfat_fs_error(new_dir->i_sb,\r\n"%s: Filesystem corrupted (i_pos %lld)",\r\n__func__, sinfo.i_pos);\r\n}\r\ngoto out;\r\n}\r\nstatic int msdos_rename(struct inode *old_dir, struct dentry *old_dentry,\r\nstruct inode *new_dir, struct dentry *new_dentry)\r\n{\r\nstruct super_block *sb = old_dir->i_sb;\r\nunsigned char old_msdos_name[MSDOS_NAME], new_msdos_name[MSDOS_NAME];\r\nint err, is_hid;\r\nlock_super(sb);\r\nerr = msdos_format_name(old_dentry->d_name.name,\r\nold_dentry->d_name.len, old_msdos_name,\r\n&MSDOS_SB(old_dir->i_sb)->options);\r\nif (err)\r\ngoto out;\r\nerr = msdos_format_name(new_dentry->d_name.name,\r\nnew_dentry->d_name.len, new_msdos_name,\r\n&MSDOS_SB(new_dir->i_sb)->options);\r\nif (err)\r\ngoto out;\r\nis_hid =\r\n(new_dentry->d_name.name[0] == '.') && (new_msdos_name[0] != '.');\r\nerr = do_msdos_rename(old_dir, old_msdos_name, old_dentry,\r\nnew_dir, new_msdos_name, new_dentry, is_hid);\r\nout:\r\nunlock_super(sb);\r\nif (!err)\r\nerr = fat_flush_inodes(sb, old_dir, new_dir);\r\nreturn err;\r\n}\r\nstatic void setup(struct super_block *sb)\r\n{\r\nMSDOS_SB(sb)->dir_ops = &msdos_dir_inode_operations;\r\nsb->s_d_op = &msdos_dentry_operations;\r\nsb->s_flags |= MS_NOATIME;\r\n}\r\nstatic int msdos_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nreturn fat_fill_super(sb, data, silent, 0, setup);\r\n}\r\nstatic struct dentry *msdos_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name,\r\nvoid *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, msdos_fill_super);\r\n}\r\nstatic int __init init_msdos_fs(void)\r\n{\r\nreturn register_filesystem(&msdos_fs_type);\r\n}\r\nstatic void __exit exit_msdos_fs(void)\r\n{\r\nunregister_filesystem(&msdos_fs_type);\r\n}
