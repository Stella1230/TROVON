static unsigned int get_scr_cfg_addr(struct ata_link *link, unsigned int sc_reg)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned int addr = SIS_SCR_BASE + (4 * sc_reg);\r\nu8 pmr;\r\nif (ap->port_no) {\r\nswitch (pdev->device) {\r\ncase 0x0180:\r\ncase 0x0181:\r\npci_read_config_byte(pdev, SIS_PMR, &pmr);\r\nif ((pmr & SIS_PMR_COMBINED) == 0)\r\naddr += SIS180_SATA1_OFS;\r\nbreak;\r\ncase 0x0182:\r\ncase 0x0183:\r\ncase 0x1182:\r\naddr += SIS182_SATA1_OFS;\r\nbreak;\r\n}\r\n}\r\nif (link->pmp)\r\naddr += 0x10;\r\nreturn addr;\r\n}\r\nstatic u32 sis_scr_cfg_read(struct ata_link *link,\r\nunsigned int sc_reg, u32 *val)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\r\nunsigned int cfg_addr = get_scr_cfg_addr(link, sc_reg);\r\nif (sc_reg == SCR_ERROR)\r\nreturn -EINVAL;\r\npci_read_config_dword(pdev, cfg_addr, val);\r\nreturn 0;\r\n}\r\nstatic int sis_scr_cfg_write(struct ata_link *link,\r\nunsigned int sc_reg, u32 val)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(link->ap->host->dev);\r\nunsigned int cfg_addr = get_scr_cfg_addr(link, sc_reg);\r\npci_write_config_dword(pdev, cfg_addr, val);\r\nreturn 0;\r\n}\r\nstatic int sis_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nvoid __iomem *base = ap->ioaddr.scr_addr + link->pmp * 0x10;\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\nif (ap->flags & SIS_FLAG_CFGSCR)\r\nreturn sis_scr_cfg_read(link, sc_reg, val);\r\n*val = ioread32(base + sc_reg * 4);\r\nreturn 0;\r\n}\r\nstatic int sis_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nvoid __iomem *base = ap->ioaddr.scr_addr + link->pmp * 0x10;\r\nif (sc_reg > SCR_CONTROL)\r\nreturn -EINVAL;\r\nif (ap->flags & SIS_FLAG_CFGSCR)\r\nreturn sis_scr_cfg_write(link, sc_reg, val);\r\niowrite32(val, base + (sc_reg * 4));\r\nreturn 0;\r\n}\r\nstatic int sis_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct ata_port_info pi = sis_port_info;\r\nconst struct ata_port_info *ppi[] = { &pi, &pi };\r\nstruct ata_host *host;\r\nu32 genctl, val;\r\nu8 pmr;\r\nu8 port2_start = 0x20;\r\nint i, rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\npci_read_config_dword(pdev, SIS_GENCTL, &genctl);\r\nif ((genctl & GENCTL_IOMAPPED_SCR) == 0)\r\npi.flags |= SIS_FLAG_CFGSCR;\r\nif ((!(pi.flags & SIS_FLAG_CFGSCR)) &&\r\n((pci_resource_start(pdev, SIS_SCR_PCI_BAR) == 0) ||\r\n(pci_resource_len(pdev, SIS_SCR_PCI_BAR) < 128))) {\r\ngenctl &= ~GENCTL_IOMAPPED_SCR;\r\npci_write_config_dword(pdev, SIS_GENCTL, genctl);\r\npi.flags |= SIS_FLAG_CFGSCR;\r\n}\r\npci_read_config_byte(pdev, SIS_PMR, &pmr);\r\nswitch (ent->device) {\r\ncase 0x0180:\r\ncase 0x0181:\r\nswitch (pmr & 0x30) {\r\ncase 0x10:\r\nppi[1] = &sis_info133_for_sata;\r\nbreak;\r\ncase 0x30:\r\nppi[0] = &sis_info133_for_sata;\r\nbreak;\r\n}\r\nif ((pmr & SIS_PMR_COMBINED) == 0) {\r\ndev_info(&pdev->dev,\r\n"Detected SiS 180/181/964 chipset in SATA mode\n");\r\nport2_start = 64;\r\n} else {\r\ndev_info(&pdev->dev,\r\n"Detected SiS 180/181 chipset in combined mode\n");\r\nport2_start = 0;\r\npi.flags |= ATA_FLAG_SLAVE_POSS;\r\n}\r\nbreak;\r\ncase 0x0182:\r\ncase 0x0183:\r\npci_read_config_dword(pdev, 0x6C, &val);\r\nif (val & (1L << 31)) {\r\ndev_info(&pdev->dev, "Detected SiS 182/965 chipset\n");\r\npi.flags |= ATA_FLAG_SLAVE_POSS;\r\n} else {\r\ndev_info(&pdev->dev, "Detected SiS 182/965L chipset\n");\r\n}\r\nbreak;\r\ncase 0x1182:\r\ndev_info(&pdev->dev,\r\n"Detected SiS 1182/966/680 SATA controller\n");\r\npi.flags |= ATA_FLAG_SLAVE_POSS;\r\nbreak;\r\ncase 0x1183:\r\ndev_info(&pdev->dev,\r\n"Detected SiS 1183/966/966L/968/680 controller in PATA mode\n");\r\nppi[0] = &sis_info133_for_sata;\r\nppi[1] = &sis_info133_for_sata;\r\nbreak;\r\n}\r\nrc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < 2; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nif (ap->flags & ATA_FLAG_SATA &&\r\nap->flags & ATA_FLAG_SLAVE_POSS) {\r\nrc = ata_slave_link_init(ap);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nif (!(pi.flags & SIS_FLAG_CFGSCR)) {\r\nvoid __iomem *mmio;\r\nrc = pcim_iomap_regions(pdev, 1 << SIS_SCR_PCI_BAR, DRV_NAME);\r\nif (rc)\r\nreturn rc;\r\nmmio = host->iomap[SIS_SCR_PCI_BAR];\r\nhost->ports[0]->ioaddr.scr_addr = mmio;\r\nhost->ports[1]->ioaddr.scr_addr = mmio + port2_start;\r\n}\r\npci_set_master(pdev);\r\npci_intx(pdev, 1);\r\nreturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\r\nIRQF_SHARED, &sis_sht);\r\n}\r\nstatic int __init sis_init(void)\r\n{\r\nreturn pci_register_driver(&sis_pci_driver);\r\n}\r\nstatic void __exit sis_exit(void)\r\n{\r\npci_unregister_driver(&sis_pci_driver);\r\n}
