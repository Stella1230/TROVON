static inline struct atmel_uart_port *\r\nto_atmel_uart_port(struct uart_port *uart)\r\n{\r\nreturn container_of(uart, struct atmel_uart_port, uart);\r\n}\r\nstatic bool atmel_use_dma_rx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->use_dma_rx;\r\n}\r\nstatic bool atmel_use_dma_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nreturn atmel_port->use_dma_tx;\r\n}\r\nstatic bool atmel_use_dma_rx(struct uart_port *port)\r\n{\r\nreturn false;\r\n}\r\nstatic bool atmel_use_dma_tx(struct uart_port *port)\r\n{\r\nreturn false;\r\n}\r\nvoid atmel_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int mode;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nUART_PUT_IDR(port, atmel_port->tx_done_mask);\r\nmode = UART_GET_MR(port);\r\nmode &= ~ATMEL_US_USMODE;\r\natmel_port->rs485 = *rs485conf;\r\nif (rs485conf->flags & SER_RS485_ENABLED) {\r\ndev_dbg(port->dev, "Setting UART to RS485\n");\r\natmel_port->tx_done_mask = ATMEL_US_TXEMPTY;\r\nif ((rs485conf->delay_rts_after_send) > 0)\r\nUART_PUT_TTGR(port, rs485conf->delay_rts_after_send);\r\nmode |= ATMEL_US_USMODE_RS485;\r\n} else {\r\ndev_dbg(port->dev, "Setting UART to RS232\n");\r\nif (atmel_use_dma_tx(port))\r\natmel_port->tx_done_mask = ATMEL_US_ENDTX |\r\nATMEL_US_TXBUFE;\r\nelse\r\natmel_port->tx_done_mask = ATMEL_US_TXRDY;\r\n}\r\nUART_PUT_MR(port, mode);\r\nUART_PUT_IER(port, atmel_port->tx_done_mask);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic u_int atmel_tx_empty(struct uart_port *port)\r\n{\r\nreturn (UART_GET_CSR(port) & ATMEL_US_TXEMPTY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void atmel_set_mctrl(struct uart_port *port, u_int mctrl)\r\n{\r\nunsigned int control = 0;\r\nunsigned int mode;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\n#ifdef CONFIG_ARCH_AT91RM9200\r\nif (cpu_is_at91rm9200()) {\r\nif (port->mapbase == AT91RM9200_BASE_US0) {\r\nif (mctrl & TIOCM_RTS)\r\nat91_set_gpio_value(AT91_PIN_PA21, 0);\r\nelse\r\nat91_set_gpio_value(AT91_PIN_PA21, 1);\r\n}\r\n}\r\n#endif\r\nif (mctrl & TIOCM_RTS)\r\ncontrol |= ATMEL_US_RTSEN;\r\nelse\r\ncontrol |= ATMEL_US_RTSDIS;\r\nif (mctrl & TIOCM_DTR)\r\ncontrol |= ATMEL_US_DTREN;\r\nelse\r\ncontrol |= ATMEL_US_DTRDIS;\r\nUART_PUT_CR(port, control);\r\nmode = UART_GET_MR(port) & ~ATMEL_US_CHMODE;\r\nif (mctrl & TIOCM_LOOP)\r\nmode |= ATMEL_US_CHMODE_LOC_LOOP;\r\nelse\r\nmode |= ATMEL_US_CHMODE_NORMAL;\r\nmode &= ~ATMEL_US_USMODE;\r\nif (atmel_port->rs485.flags & SER_RS485_ENABLED) {\r\ndev_dbg(port->dev, "Setting UART to RS485\n");\r\nif ((atmel_port->rs485.delay_rts_after_send) > 0)\r\nUART_PUT_TTGR(port,\r\natmel_port->rs485.delay_rts_after_send);\r\nmode |= ATMEL_US_USMODE_RS485;\r\n} else {\r\ndev_dbg(port->dev, "Setting UART to RS232\n");\r\n}\r\nUART_PUT_MR(port, mode);\r\n}\r\nstatic u_int atmel_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned int status, ret = 0;\r\nstatus = UART_GET_CSR(port);\r\nif (!(status & ATMEL_US_DCD))\r\nret |= TIOCM_CD;\r\nif (!(status & ATMEL_US_CTS))\r\nret |= TIOCM_CTS;\r\nif (!(status & ATMEL_US_DSR))\r\nret |= TIOCM_DSR;\r\nif (!(status & ATMEL_US_RI))\r\nret |= TIOCM_RI;\r\nreturn ret;\r\n}\r\nstatic void atmel_stop_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_dma_tx(port)) {\r\nUART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);\r\n}\r\nUART_PUT_IDR(port, atmel_port->tx_done_mask);\r\nif ((atmel_port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(atmel_port->rs485.flags & SER_RS485_RX_DURING_TX))\r\natmel_start_rx(port);\r\n}\r\nstatic void atmel_start_tx(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_dma_tx(port)) {\r\nif (UART_GET_PTSR(port) & ATMEL_PDC_TXTEN)\r\nreturn;\r\nif ((atmel_port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(atmel_port->rs485.flags & SER_RS485_RX_DURING_TX))\r\natmel_stop_rx(port);\r\nUART_PUT_PTCR(port, ATMEL_PDC_TXTEN);\r\n}\r\nUART_PUT_IER(port, atmel_port->tx_done_mask);\r\n}\r\nstatic void atmel_start_rx(struct uart_port *port)\r\n{\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA);\r\nUART_PUT_CR(port, ATMEL_US_RXEN);\r\nif (atmel_use_dma_rx(port)) {\r\nUART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT |\r\nport->read_status_mask);\r\nUART_PUT_PTCR(port, ATMEL_PDC_RXTEN);\r\n} else {\r\nUART_PUT_IER(port, ATMEL_US_RXRDY);\r\n}\r\n}\r\nstatic void atmel_stop_rx(struct uart_port *port)\r\n{\r\nUART_PUT_CR(port, ATMEL_US_RXDIS);\r\nif (atmel_use_dma_rx(port)) {\r\nUART_PUT_PTCR(port, ATMEL_PDC_RXTDIS);\r\nUART_PUT_IDR(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT |\r\nport->read_status_mask);\r\n} else {\r\nUART_PUT_IDR(port, ATMEL_US_RXRDY);\r\n}\r\n}\r\nstatic void atmel_enable_ms(struct uart_port *port)\r\n{\r\nUART_PUT_IER(port, ATMEL_US_RIIC | ATMEL_US_DSRIC\r\n| ATMEL_US_DCDIC | ATMEL_US_CTSIC);\r\n}\r\nstatic void atmel_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nif (break_state != 0)\r\nUART_PUT_CR(port, ATMEL_US_STTBRK);\r\nelse\r\nUART_PUT_CR(port, ATMEL_US_STPBRK);\r\n}\r\nstatic void\r\natmel_buffer_rx_char(struct uart_port *port, unsigned int status,\r\nunsigned int ch)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *ring = &atmel_port->rx_ring;\r\nstruct atmel_uart_char *c;\r\nif (!CIRC_SPACE(ring->head, ring->tail, ATMEL_SERIAL_RINGSIZE))\r\nreturn;\r\nc = &((struct atmel_uart_char *)ring->buf)[ring->head];\r\nc->status = status;\r\nc->ch = ch;\r\nsmp_wmb();\r\nring->head = (ring->head + 1) & (ATMEL_SERIAL_RINGSIZE - 1);\r\n}\r\nstatic void atmel_pdc_rxerr(struct uart_port *port, unsigned int status)\r\n{\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA);\r\nif (status & ATMEL_US_RXBRK) {\r\nstatus &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);\r\nport->icount.brk++;\r\n}\r\nif (status & ATMEL_US_PARE)\r\nport->icount.parity++;\r\nif (status & ATMEL_US_FRAME)\r\nport->icount.frame++;\r\nif (status & ATMEL_US_OVRE)\r\nport->icount.overrun++;\r\n}\r\nstatic void atmel_rx_chars(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status, ch;\r\nstatus = UART_GET_CSR(port);\r\nwhile (status & ATMEL_US_RXRDY) {\r\nch = UART_GET_CHAR(port);\r\nif (unlikely(status & (ATMEL_US_PARE | ATMEL_US_FRAME\r\n| ATMEL_US_OVRE | ATMEL_US_RXBRK)\r\n|| atmel_port->break_active)) {\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA);\r\nif (status & ATMEL_US_RXBRK\r\n&& !atmel_port->break_active) {\r\natmel_port->break_active = 1;\r\nUART_PUT_IER(port, ATMEL_US_RXBRK);\r\n} else {\r\nUART_PUT_IDR(port, ATMEL_US_RXBRK);\r\nstatus &= ~ATMEL_US_RXBRK;\r\natmel_port->break_active = 0;\r\n}\r\n}\r\natmel_buffer_rx_char(port, status, ch);\r\nstatus = UART_GET_CSR(port);\r\n}\r\ntasklet_schedule(&atmel_port->tasklet);\r\n}\r\nstatic void atmel_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (port->x_char && UART_GET_CSR(port) & atmel_port->tx_done_mask) {\r\nUART_PUT_CHAR(port, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nwhile (UART_GET_CSR(port) & atmel_port->tx_done_mask) {\r\nUART_PUT_CHAR(port, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (!uart_circ_empty(xmit))\r\nUART_PUT_IER(port, atmel_port->tx_done_mask);\r\n}\r\nstatic void\r\natmel_handle_receive(struct uart_port *port, unsigned int pending)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_dma_rx(port)) {\r\nif (pending & (ATMEL_US_ENDRX | ATMEL_US_TIMEOUT)) {\r\nUART_PUT_IDR(port, (ATMEL_US_ENDRX\r\n| ATMEL_US_TIMEOUT));\r\ntasklet_schedule(&atmel_port->tasklet);\r\n}\r\nif (pending & (ATMEL_US_RXBRK | ATMEL_US_OVRE |\r\nATMEL_US_FRAME | ATMEL_US_PARE))\r\natmel_pdc_rxerr(port, pending);\r\n}\r\nif (pending & ATMEL_US_RXRDY)\r\natmel_rx_chars(port);\r\nelse if (pending & ATMEL_US_RXBRK) {\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA);\r\nUART_PUT_IDR(port, ATMEL_US_RXBRK);\r\natmel_port->break_active = 0;\r\n}\r\n}\r\nstatic void\r\natmel_handle_transmit(struct uart_port *port, unsigned int pending)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (pending & atmel_port->tx_done_mask) {\r\nUART_PUT_IDR(port, atmel_port->tx_done_mask);\r\ntasklet_schedule(&atmel_port->tasklet);\r\n}\r\n}\r\nstatic void\r\natmel_handle_status(struct uart_port *port, unsigned int pending,\r\nunsigned int status)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (pending & (ATMEL_US_RIIC | ATMEL_US_DSRIC | ATMEL_US_DCDIC\r\n| ATMEL_US_CTSIC)) {\r\natmel_port->irq_status = status;\r\ntasklet_schedule(&atmel_port->tasklet);\r\n}\r\n}\r\nstatic irqreturn_t atmel_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nunsigned int status, pending, pass_counter = 0;\r\ndo {\r\nstatus = UART_GET_CSR(port);\r\npending = status & UART_GET_IMR(port);\r\nif (!pending)\r\nbreak;\r\natmel_handle_receive(port, pending);\r\natmel_handle_status(port, pending, status);\r\natmel_handle_transmit(port, pending);\r\n} while (pass_counter++ < ATMEL_ISR_PASS_LIMIT);\r\nreturn pass_counter ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void atmel_tx_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\r\nint count;\r\nif (UART_GET_TCR(port))\r\nreturn;\r\nxmit->tail += pdc->ofs;\r\nxmit->tail &= UART_XMIT_SIZE - 1;\r\nport->icount.tx += pdc->ofs;\r\npdc->ofs = 0;\r\nUART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {\r\ndma_sync_single_for_device(port->dev,\r\npdc->dma_addr,\r\npdc->dma_size,\r\nDMA_TO_DEVICE);\r\ncount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\npdc->ofs = count;\r\nUART_PUT_TPR(port, pdc->dma_addr + xmit->tail);\r\nUART_PUT_TCR(port, count);\r\nUART_PUT_PTCR(port, ATMEL_PDC_TXTEN);\r\nUART_PUT_IER(port, atmel_port->tx_done_mask);\r\n} else {\r\nif ((atmel_port->rs485.flags & SER_RS485_ENABLED) &&\r\n!(atmel_port->rs485.flags & SER_RS485_RX_DURING_TX)) {\r\natmel_start_rx(port);\r\n}\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void atmel_rx_from_ring(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct circ_buf *ring = &atmel_port->rx_ring;\r\nunsigned int flg;\r\nunsigned int status;\r\nwhile (ring->head != ring->tail) {\r\nstruct atmel_uart_char c;\r\nsmp_rmb();\r\nc = ((struct atmel_uart_char *)ring->buf)[ring->tail];\r\nring->tail = (ring->tail + 1) & (ATMEL_SERIAL_RINGSIZE - 1);\r\nport->icount.rx++;\r\nstatus = c.status;\r\nflg = TTY_NORMAL;\r\nif (unlikely(status & (ATMEL_US_PARE | ATMEL_US_FRAME\r\n| ATMEL_US_OVRE | ATMEL_US_RXBRK))) {\r\nif (status & ATMEL_US_RXBRK) {\r\nstatus &= ~(ATMEL_US_PARE | ATMEL_US_FRAME);\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n}\r\nif (status & ATMEL_US_PARE)\r\nport->icount.parity++;\r\nif (status & ATMEL_US_FRAME)\r\nport->icount.frame++;\r\nif (status & ATMEL_US_OVRE)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & ATMEL_US_RXBRK)\r\nflg = TTY_BREAK;\r\nelse if (status & ATMEL_US_PARE)\r\nflg = TTY_PARITY;\r\nelse if (status & ATMEL_US_FRAME)\r\nflg = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, c.ch))\r\ncontinue;\r\nuart_insert_char(port, status, ATMEL_US_OVRE, c.ch, flg);\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(port->state->port.tty);\r\nspin_lock(&port->lock);\r\n}\r\nstatic void atmel_rx_from_dma(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct tty_struct *tty = port->state->port.tty;\r\nstruct atmel_dma_buffer *pdc;\r\nint rx_idx = atmel_port->pdc_rx_idx;\r\nunsigned int head;\r\nunsigned int tail;\r\nunsigned int count;\r\ndo {\r\nUART_PUT_CR(port, ATMEL_US_STTTO);\r\npdc = &atmel_port->pdc_rx[rx_idx];\r\nhead = UART_GET_RPR(port) - pdc->dma_addr;\r\ntail = pdc->ofs;\r\nhead = min(head, pdc->dma_size);\r\nif (likely(head != tail)) {\r\ndma_sync_single_for_cpu(port->dev, pdc->dma_addr,\r\npdc->dma_size, DMA_FROM_DEVICE);\r\ncount = head - tail;\r\ntty_insert_flip_string(tty, pdc->buf + pdc->ofs, count);\r\ndma_sync_single_for_device(port->dev, pdc->dma_addr,\r\npdc->dma_size, DMA_FROM_DEVICE);\r\nport->icount.rx += count;\r\npdc->ofs = head;\r\n}\r\nif (head >= pdc->dma_size) {\r\npdc->ofs = 0;\r\nUART_PUT_RNPR(port, pdc->dma_addr);\r\nUART_PUT_RNCR(port, pdc->dma_size);\r\nrx_idx = !rx_idx;\r\natmel_port->pdc_rx_idx = rx_idx;\r\n}\r\n} while (head >= pdc->dma_size);\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tty);\r\nspin_lock(&port->lock);\r\nUART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);\r\n}\r\nstatic void atmel_tasklet_func(unsigned long data)\r\n{\r\nstruct uart_port *port = (struct uart_port *)data;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status;\r\nunsigned int status_change;\r\nspin_lock(&port->lock);\r\nif (atmel_use_dma_tx(port))\r\natmel_tx_dma(port);\r\nelse\r\natmel_tx_chars(port);\r\nstatus = atmel_port->irq_status;\r\nstatus_change = status ^ atmel_port->irq_status_prev;\r\nif (status_change & (ATMEL_US_RI | ATMEL_US_DSR\r\n| ATMEL_US_DCD | ATMEL_US_CTS)) {\r\nif (status_change & ATMEL_US_RI)\r\nport->icount.rng++;\r\nif (status_change & ATMEL_US_DSR)\r\nport->icount.dsr++;\r\nif (status_change & ATMEL_US_DCD)\r\nuart_handle_dcd_change(port, !(status & ATMEL_US_DCD));\r\nif (status_change & ATMEL_US_CTS)\r\nuart_handle_cts_change(port, !(status & ATMEL_US_CTS));\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\natmel_port->irq_status_prev = status;\r\n}\r\nif (atmel_use_dma_rx(port))\r\natmel_rx_from_dma(port);\r\nelse\r\natmel_rx_from_ring(port);\r\nspin_unlock(&port->lock);\r\n}\r\nstatic int atmel_startup(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nstruct tty_struct *tty = port->state->port.tty;\r\nint retval;\r\nUART_PUT_IDR(port, -1);\r\nretval = request_irq(port->irq, atmel_interrupt, IRQF_SHARED,\r\ntty ? tty->name : "atmel_serial", port);\r\nif (retval) {\r\nprintk("atmel_serial: atmel_startup - Can't get irq\n");\r\nreturn retval;\r\n}\r\nif (atmel_use_dma_rx(port)) {\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];\r\npdc->buf = kmalloc(PDC_BUFFER_SIZE, GFP_KERNEL);\r\nif (pdc->buf == NULL) {\r\nif (i != 0) {\r\ndma_unmap_single(port->dev,\r\natmel_port->pdc_rx[0].dma_addr,\r\nPDC_BUFFER_SIZE,\r\nDMA_FROM_DEVICE);\r\nkfree(atmel_port->pdc_rx[0].buf);\r\n}\r\nfree_irq(port->irq, port);\r\nreturn -ENOMEM;\r\n}\r\npdc->dma_addr = dma_map_single(port->dev,\r\npdc->buf,\r\nPDC_BUFFER_SIZE,\r\nDMA_FROM_DEVICE);\r\npdc->dma_size = PDC_BUFFER_SIZE;\r\npdc->ofs = 0;\r\n}\r\natmel_port->pdc_rx_idx = 0;\r\nUART_PUT_RPR(port, atmel_port->pdc_rx[0].dma_addr);\r\nUART_PUT_RCR(port, PDC_BUFFER_SIZE);\r\nUART_PUT_RNPR(port, atmel_port->pdc_rx[1].dma_addr);\r\nUART_PUT_RNCR(port, PDC_BUFFER_SIZE);\r\n}\r\nif (atmel_use_dma_tx(port)) {\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\npdc->buf = xmit->buf;\r\npdc->dma_addr = dma_map_single(port->dev,\r\npdc->buf,\r\nUART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\npdc->dma_size = UART_XMIT_SIZE;\r\npdc->ofs = 0;\r\n}\r\nif (atmel_open_hook) {\r\nretval = atmel_open_hook(port);\r\nif (retval) {\r\nfree_irq(port->irq, port);\r\nreturn retval;\r\n}\r\n}\r\natmel_port->irq_status_prev = UART_GET_CSR(port);\r\natmel_port->irq_status = atmel_port->irq_status_prev;\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\r\nUART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);\r\nif (atmel_use_dma_rx(port)) {\r\nUART_PUT_RTOR(port, PDC_RX_TIMEOUT);\r\nUART_PUT_CR(port, ATMEL_US_STTTO);\r\nUART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT);\r\nUART_PUT_PTCR(port, ATMEL_PDC_RXTEN);\r\n} else {\r\nUART_PUT_IER(port, ATMEL_US_RXRDY);\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_shutdown(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\natmel_stop_rx(port);\r\natmel_stop_tx(port);\r\nif (atmel_use_dma_rx(port)) {\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_rx[i];\r\ndma_unmap_single(port->dev,\r\npdc->dma_addr,\r\npdc->dma_size,\r\nDMA_FROM_DEVICE);\r\nkfree(pdc->buf);\r\n}\r\n}\r\nif (atmel_use_dma_tx(port)) {\r\nstruct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;\r\ndma_unmap_single(port->dev,\r\npdc->dma_addr,\r\npdc->dma_size,\r\nDMA_TO_DEVICE);\r\n}\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA);\r\nUART_PUT_IDR(port, -1);\r\nfree_irq(port->irq, port);\r\nif (atmel_close_hook)\r\natmel_close_hook(port);\r\n}\r\nstatic void atmel_flush_buffer(struct uart_port *port)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_use_dma_tx(port)) {\r\nUART_PUT_TCR(port, 0);\r\natmel_port->pdc_tx.ofs = 0;\r\n}\r\n}\r\nstatic void atmel_serial_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nswitch (state) {\r\ncase 0:\r\nclk_enable(atmel_port->clk);\r\nUART_PUT_IER(port, atmel_port->backup_imr);\r\nbreak;\r\ncase 3:\r\natmel_port->backup_imr = UART_GET_IMR(port);\r\nUART_PUT_IDR(port, -1);\r\nclk_disable(atmel_port->clk);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "atmel_serial: unknown pm %d\n", state);\r\n}\r\n}\r\nstatic void atmel_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int mode, imr, quot, baud;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nmode = UART_GET_MR(port) & ~(ATMEL_US_USCLKS | ATMEL_US_CHRL\r\n| ATMEL_US_NBSTOP | ATMEL_US_PAR\r\n| ATMEL_US_USMODE);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\r\nquot = uart_get_divisor(port, baud);\r\nif (quot > 65535) {\r\nquot /= 8;\r\nmode |= ATMEL_US_USCLKS_MCK_DIV8;\r\n}\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nmode |= ATMEL_US_CHRL_5;\r\nbreak;\r\ncase CS6:\r\nmode |= ATMEL_US_CHRL_6;\r\nbreak;\r\ncase CS7:\r\nmode |= ATMEL_US_CHRL_7;\r\nbreak;\r\ndefault:\r\nmode |= ATMEL_US_CHRL_8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nmode |= ATMEL_US_NBSTOP_2;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & CMSPAR) {\r\nif (termios->c_cflag & PARODD)\r\nmode |= ATMEL_US_PAR_MARK;\r\nelse\r\nmode |= ATMEL_US_PAR_SPACE;\r\n} else if (termios->c_cflag & PARODD)\r\nmode |= ATMEL_US_PAR_ODD;\r\nelse\r\nmode |= ATMEL_US_PAR_EVEN;\r\n} else\r\nmode |= ATMEL_US_PAR_NONE;\r\nif (termios->c_cflag & CRTSCTS)\r\nmode |= ATMEL_US_USMODE_HWHS;\r\nelse\r\nmode |= ATMEL_US_USMODE_NORMAL;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->read_status_mask = ATMEL_US_OVRE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= (ATMEL_US_FRAME | ATMEL_US_PARE);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= ATMEL_US_RXBRK;\r\nif (atmel_use_dma_rx(port))\r\nUART_PUT_IER(port, port->read_status_mask);\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= (ATMEL_US_FRAME | ATMEL_US_PARE);\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= ATMEL_US_RXBRK;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= ATMEL_US_OVRE;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nimr = UART_GET_IMR(port);\r\nUART_PUT_IDR(port, -1);\r\nUART_PUT_CR(port, ATMEL_US_TXDIS | ATMEL_US_RXDIS);\r\nmode &= ~ATMEL_US_USMODE;\r\nif (atmel_port->rs485.flags & SER_RS485_ENABLED) {\r\ndev_dbg(port->dev, "Setting UART to RS485\n");\r\nif ((atmel_port->rs485.delay_rts_after_send) > 0)\r\nUART_PUT_TTGR(port,\r\natmel_port->rs485.delay_rts_after_send);\r\nmode |= ATMEL_US_USMODE_RS485;\r\n} else {\r\ndev_dbg(port->dev, "Setting UART to RS232\n");\r\n}\r\nUART_PUT_MR(port, mode);\r\nUART_PUT_BRGR(port, quot);\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\r\nUART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);\r\nUART_PUT_IER(port, imr);\r\nif (UART_ENABLE_MS(port, termios->c_cflag))\r\nport->ops->enable_ms(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void atmel_set_ldisc(struct uart_port *port, int new)\r\n{\r\nif (new == N_PPS) {\r\nport->flags |= UPF_HARDPPS_CD;\r\natmel_enable_ms(port);\r\n} else {\r\nport->flags &= ~UPF_HARDPPS_CD;\r\n}\r\n}\r\nstatic const char *atmel_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_ATMEL) ? "ATMEL_SERIAL" : NULL;\r\n}\r\nstatic void atmel_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nint size = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nrelease_mem_region(port->mapbase, size);\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\n}\r\nstatic int atmel_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nint size = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nif (!request_mem_region(port->mapbase, size, "atmel_serial"))\r\nreturn -EBUSY;\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = ioremap(port->mapbase, size);\r\nif (port->membase == NULL) {\r\nrelease_mem_region(port->mapbase, size);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_ATMEL;\r\natmel_request_port(port);\r\n}\r\n}\r\nstatic int atmel_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_ATMEL)\r\nret = -EINVAL;\r\nif (port->irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != SERIAL_IO_MEM)\r\nret = -EINVAL;\r\nif (port->uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif ((void *)port->mapbase != ser->iomem_base)\r\nret = -EINVAL;\r\nif (port->iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int atmel_poll_get_char(struct uart_port *port)\r\n{\r\nwhile (!(UART_GET_CSR(port) & ATMEL_US_RXRDY))\r\ncpu_relax();\r\nreturn UART_GET_CHAR(port);\r\n}\r\nstatic void atmel_poll_put_char(struct uart_port *port, unsigned char ch)\r\n{\r\nwhile (!(UART_GET_CSR(port) & ATMEL_US_TXRDY))\r\ncpu_relax();\r\nUART_PUT_CHAR(port, ch);\r\n}\r\nstatic int\r\natmel_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct serial_rs485 rs485conf;\r\nswitch (cmd) {\r\ncase TIOCSRS485:\r\nif (copy_from_user(&rs485conf, (struct serial_rs485 *) arg,\r\nsizeof(rs485conf)))\r\nreturn -EFAULT;\r\natmel_config_rs485(port, &rs485conf);\r\nbreak;\r\ncase TIOCGRS485:\r\nif (copy_to_user((struct serial_rs485 *) arg,\r\n&(to_atmel_uart_port(port)->rs485),\r\nsizeof(rs485conf)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit atmel_of_init_port(struct atmel_uart_port *atmel_port,\r\nstruct device_node *np)\r\n{\r\nu32 rs485_delay[2];\r\nif (of_get_property(np, "atmel,use-dma-rx", NULL))\r\natmel_port->use_dma_rx = 1;\r\nelse\r\natmel_port->use_dma_rx = 0;\r\nif (of_get_property(np, "atmel,use-dma-tx", NULL))\r\natmel_port->use_dma_tx = 1;\r\nelse\r\natmel_port->use_dma_tx = 0;\r\nif (of_property_read_u32_array(np, "rs485-rts-delay",\r\nrs485_delay, 2) == 0) {\r\nstruct serial_rs485 *rs485conf = &atmel_port->rs485;\r\nrs485conf->delay_rts_before_send = rs485_delay[0];\r\nrs485conf->delay_rts_after_send = rs485_delay[1];\r\nrs485conf->flags = 0;\r\nif (of_get_property(np, "rs485-rx-during-tx", NULL))\r\nrs485conf->flags |= SER_RS485_RX_DURING_TX;\r\nif (of_get_property(np, "linux,rs485-enabled-at-boot-time", NULL))\r\nrs485conf->flags |= SER_RS485_ENABLED;\r\n}\r\n}\r\nstatic void __devinit atmel_init_port(struct atmel_uart_port *atmel_port,\r\nstruct platform_device *pdev)\r\n{\r\nstruct uart_port *port = &atmel_port->uart;\r\nstruct atmel_uart_data *pdata = pdev->dev.platform_data;\r\nif (pdev->dev.of_node) {\r\natmel_of_init_port(atmel_port, pdev->dev.of_node);\r\n} else {\r\natmel_port->use_dma_rx = pdata->use_dma_rx;\r\natmel_port->use_dma_tx = pdata->use_dma_tx;\r\natmel_port->rs485 = pdata->rs485;\r\n}\r\nport->iotype = UPIO_MEM;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &atmel_pops;\r\nport->fifosize = 1;\r\nport->dev = &pdev->dev;\r\nport->mapbase = pdev->resource[0].start;\r\nport->irq = pdev->resource[1].start;\r\ntasklet_init(&atmel_port->tasklet, atmel_tasklet_func,\r\n(unsigned long)port);\r\nmemset(&atmel_port->rx_ring, 0, sizeof(atmel_port->rx_ring));\r\nif (pdata && pdata->regs) {\r\nport->membase = pdata->regs;\r\n} else {\r\nport->flags |= UPF_IOREMAP;\r\nport->membase = NULL;\r\n}\r\nif (!atmel_port->clk) {\r\natmel_port->clk = clk_get(&pdev->dev, "usart");\r\nclk_enable(atmel_port->clk);\r\nport->uartclk = clk_get_rate(atmel_port->clk);\r\nclk_disable(atmel_port->clk);\r\n}\r\nif (atmel_port->rs485.flags & SER_RS485_ENABLED)\r\natmel_port->tx_done_mask = ATMEL_US_TXEMPTY;\r\nelse if (atmel_use_dma_tx(port)) {\r\nport->fifosize = PDC_BUFFER_SIZE;\r\natmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;\r\n} else {\r\natmel_port->tx_done_mask = ATMEL_US_TXRDY;\r\n}\r\n}\r\nvoid __init atmel_register_uart_fns(struct atmel_port_fns *fns)\r\n{\r\nif (fns->enable_ms)\r\natmel_pops.enable_ms = fns->enable_ms;\r\nif (fns->get_mctrl)\r\natmel_pops.get_mctrl = fns->get_mctrl;\r\nif (fns->set_mctrl)\r\natmel_pops.set_mctrl = fns->set_mctrl;\r\natmel_open_hook = fns->open;\r\natmel_close_hook = fns->close;\r\natmel_pops.pm = fns->pm;\r\natmel_pops.set_wake = fns->set_wake;\r\n}\r\nstatic void atmel_console_putchar(struct uart_port *port, int ch)\r\n{\r\nwhile (!(UART_GET_CSR(port) & ATMEL_US_TXRDY))\r\ncpu_relax();\r\nUART_PUT_CHAR(port, ch);\r\n}\r\nstatic void atmel_console_write(struct console *co, const char *s, u_int count)\r\n{\r\nstruct uart_port *port = &atmel_ports[co->index].uart;\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nunsigned int status, imr;\r\nunsigned int pdc_tx;\r\nimr = UART_GET_IMR(port);\r\nUART_PUT_IDR(port, ATMEL_US_RXRDY | atmel_port->tx_done_mask);\r\npdc_tx = UART_GET_PTSR(port) & ATMEL_PDC_TXTEN;\r\nUART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);\r\nuart_console_write(port, s, count, atmel_console_putchar);\r\ndo {\r\nstatus = UART_GET_CSR(port);\r\n} while (!(status & ATMEL_US_TXRDY));\r\nif (pdc_tx)\r\nUART_PUT_PTCR(port, ATMEL_PDC_TXTEN);\r\nUART_PUT_IER(port, imr);\r\n}\r\nstatic void __init atmel_console_get_options(struct uart_port *port, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned int mr, quot;\r\nquot = UART_GET_BRGR(port) & ATMEL_US_CD;\r\nif (!quot)\r\nreturn;\r\nmr = UART_GET_MR(port) & ATMEL_US_CHRL;\r\nif (mr == ATMEL_US_CHRL_8)\r\n*bits = 8;\r\nelse\r\n*bits = 7;\r\nmr = UART_GET_MR(port) & ATMEL_US_PAR;\r\nif (mr == ATMEL_US_PAR_EVEN)\r\n*parity = 'e';\r\nelse if (mr == ATMEL_US_PAR_ODD)\r\n*parity = 'o';\r\n*baud = port->uartclk / (16 * (quot - 1));\r\n}\r\nstatic int __init atmel_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port = &atmel_ports[co->index].uart;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (port->membase == NULL) {\r\nreturn -ENODEV;\r\n}\r\nclk_enable(atmel_ports[co->index].clk);\r\nUART_PUT_IDR(port, -1);\r\nUART_PUT_CR(port, ATMEL_US_RSTSTA | ATMEL_US_RSTRX);\r\nUART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\natmel_console_get_options(port, &baud, &parity, &bits);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init atmel_console_init(void)\r\n{\r\nif (atmel_default_console_device) {\r\nstruct atmel_uart_data *pdata =\r\natmel_default_console_device->dev.platform_data;\r\nint id = pdata->num;\r\nstruct atmel_uart_port *port = &atmel_ports[id];\r\nport->backup_imr = 0;\r\nport->uart.line = id;\r\nadd_preferred_console(ATMEL_DEVICENAME, id, NULL);\r\natmel_init_port(port, atmel_default_console_device);\r\nregister_console(&atmel_console);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init atmel_late_console_init(void)\r\n{\r\nif (atmel_default_console_device\r\n&& !(atmel_console.flags & CON_ENABLED))\r\nregister_console(&atmel_console);\r\nreturn 0;\r\n}\r\nstatic inline bool atmel_is_console_port(struct uart_port *port)\r\n{\r\nreturn port->cons && port->cons->index == port->line;\r\n}\r\nstatic inline bool atmel_is_console_port(struct uart_port *port)\r\n{\r\nreturn false;\r\n}\r\nstatic bool atmel_serial_clk_will_stop(void)\r\n{\r\n#ifdef CONFIG_ARCH_AT91\r\nreturn at91_suspend_entering_slow_clock();\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nstatic int atmel_serial_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nif (atmel_is_console_port(port) && console_suspend_enabled) {\r\nwhile (!(UART_GET_CSR(port) & ATMEL_US_TXEMPTY))\r\ncpu_relax();\r\n}\r\natmel_port->may_wakeup = device_may_wakeup(&pdev->dev);\r\nif (atmel_serial_clk_will_stop())\r\ndevice_set_wakeup_enable(&pdev->dev, 0);\r\nuart_suspend_port(&atmel_uart, port);\r\nreturn 0;\r\n}\r\nstatic int atmel_serial_resume(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nuart_resume_port(&atmel_uart, port);\r\ndevice_set_wakeup_enable(&pdev->dev, atmel_port->may_wakeup);\r\nreturn 0;\r\n}\r\nstatic int __devinit atmel_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_uart_port *port;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct atmel_uart_data *pdata = pdev->dev.platform_data;\r\nvoid *data;\r\nint ret = -ENODEV;\r\nBUILD_BUG_ON(ATMEL_SERIAL_RINGSIZE & (ATMEL_SERIAL_RINGSIZE - 1));\r\nif (np)\r\nret = of_alias_get_id(np, "serial");\r\nelse\r\nif (pdata)\r\nret = pdata->num;\r\nif (ret < 0)\r\nret = find_first_zero_bit(&atmel_ports_in_use,\r\nsizeof(atmel_ports_in_use));\r\nif (ret > ATMEL_MAX_UART) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (test_and_set_bit(ret, &atmel_ports_in_use)) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nport = &atmel_ports[ret];\r\nport->backup_imr = 0;\r\nport->uart.line = ret;\r\natmel_init_port(port, pdev);\r\nif (!atmel_use_dma_rx(&port->uart)) {\r\nret = -ENOMEM;\r\ndata = kmalloc(sizeof(struct atmel_uart_char)\r\n* ATMEL_SERIAL_RINGSIZE, GFP_KERNEL);\r\nif (!data)\r\ngoto err_alloc_ring;\r\nport->rx_ring.buf = data;\r\n}\r\nret = uart_add_one_port(&atmel_uart, &port->uart);\r\nif (ret)\r\ngoto err_add_port;\r\n#ifdef CONFIG_SERIAL_ATMEL_CONSOLE\r\nif (atmel_is_console_port(&port->uart)\r\n&& ATMEL_CONSOLE_DEVICE->flags & CON_ENABLED) {\r\nclk_disable(port->clk);\r\n}\r\n#endif\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nplatform_set_drvdata(pdev, port);\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\nUART_PUT_MR(&port->uart, ATMEL_US_USMODE_NORMAL);\r\nUART_PUT_CR(&port->uart, ATMEL_US_RTSEN);\r\n}\r\nreturn 0;\r\nerr_add_port:\r\nkfree(port->rx_ring.buf);\r\nport->rx_ring.buf = NULL;\r\nerr_alloc_ring:\r\nif (!atmel_is_console_port(&port->uart)) {\r\nclk_put(port->clk);\r\nport->clk = NULL;\r\n}\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int __devexit atmel_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nstruct atmel_uart_port *atmel_port = to_atmel_uart_port(port);\r\nint ret = 0;\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\nret = uart_remove_one_port(&atmel_uart, port);\r\ntasklet_kill(&atmel_port->tasklet);\r\nkfree(atmel_port->rx_ring.buf);\r\nclear_bit(port->line, &atmel_ports_in_use);\r\nclk_put(atmel_port->clk);\r\nreturn ret;\r\n}\r\nstatic int __init atmel_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&atmel_uart);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&atmel_serial_driver);\r\nif (ret)\r\nuart_unregister_driver(&atmel_uart);\r\nreturn ret;\r\n}\r\nstatic void __exit atmel_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&atmel_serial_driver);\r\nuart_unregister_driver(&atmel_uart);\r\n}
