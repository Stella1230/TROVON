static void zorro8390_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nif (ei_debug > 1)\r\nnetdev_dbg(dev, "resetting - t=%ld...\n", jiffies);\r\nz_writeb(z_readb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((z_readb(NE_BASE + NE_EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2 * HZ / 100)) {\r\nnetdev_warn(dev, "%s: did not complete\n", __func__);\r\nbreak;\r\n}\r\nz_writeb(ENISR_RESET, NE_BASE + NE_EN0_ISR);\r\n}\r\nstatic void zorro8390_get_8390_hdr(struct net_device *dev,\r\nstruct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nint cnt;\r\nshort *ptrs;\r\nif (ei_status.dmaing) {\r\nnetdev_err(dev, "%s: DMAing conflict [DMAstat:%d][irqlock:%d]\n",\r\n__func__, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\nz_writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\r\nz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nz_writeb(sizeof(struct e8390_pkt_hdr), nic_base + NE_EN0_RCNTLO);\r\nz_writeb(0, nic_base + NE_EN0_RCNTHI);\r\nz_writeb(0, nic_base + NE_EN0_RSARLO);\r\nz_writeb(ring_page, nic_base + NE_EN0_RSARHI);\r\nz_writeb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nptrs = (short *)hdr;\r\nfor (cnt = 0; cnt < sizeof(struct e8390_pkt_hdr) >> 1; cnt++)\r\n*ptrs++ = z_readw(NE_BASE + NE_DATAPORT);\r\nz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nhdr->count = WORDSWAP(hdr->count);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void zorro8390_block_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nint nic_base = dev->base_addr;\r\nchar *buf = skb->data;\r\nshort *ptrs;\r\nint cnt;\r\nif (ei_status.dmaing) {\r\nnetdev_err(dev, "%s: DMAing conflict [DMAstat:%d][irqlock:%d]\n",\r\n__func__, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\nz_writeb(E8390_NODMA + E8390_PAGE0 + E8390_START, nic_base + NE_CMD);\r\nz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nz_writeb(count & 0xff, nic_base + NE_EN0_RCNTLO);\r\nz_writeb(count >> 8, nic_base + NE_EN0_RCNTHI);\r\nz_writeb(ring_offset & 0xff, nic_base + NE_EN0_RSARLO);\r\nz_writeb(ring_offset >> 8, nic_base + NE_EN0_RSARHI);\r\nz_writeb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nptrs = (short *)buf;\r\nfor (cnt = 0; cnt < count >> 1; cnt++)\r\n*ptrs++ = z_readw(NE_BASE + NE_DATAPORT);\r\nif (count & 0x01)\r\nbuf[count - 1] = z_readb(NE_BASE + NE_DATAPORT);\r\nz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void zorro8390_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf,\r\nconst int start_page)\r\n{\r\nint nic_base = NE_BASE;\r\nunsigned long dma_start;\r\nshort *ptrs;\r\nint cnt;\r\nif (count & 0x01)\r\ncount++;\r\nif (ei_status.dmaing) {\r\nnetdev_err(dev, "%s: DMAing conflict [DMAstat:%d][irqlock:%d]\n",\r\n__func__, ei_status.dmaing, ei_status.irqlock);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\nz_writeb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\r\nz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nz_writeb(count & 0xff, nic_base + NE_EN0_RCNTLO);\r\nz_writeb(count >> 8, nic_base + NE_EN0_RCNTHI);\r\nz_writeb(0x00, nic_base + NE_EN0_RSARLO);\r\nz_writeb(start_page, nic_base + NE_EN0_RSARHI);\r\nz_writeb(E8390_RWRITE + E8390_START, nic_base + NE_CMD);\r\nptrs = (short *)buf;\r\nfor (cnt = 0; cnt < count >> 1; cnt++)\r\nz_writew(*ptrs++, NE_BASE + NE_DATAPORT);\r\ndma_start = jiffies;\r\nwhile ((z_readb(NE_BASE + NE_EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + 2 * HZ / 100)) {\r\nnetdev_err(dev, "timeout waiting for Tx RDC\n");\r\nzorro8390_reset_8390(dev);\r\n__NS8390_init(dev, 1);\r\nbreak;\r\n}\r\nz_writeb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic int zorro8390_open(struct net_device *dev)\r\n{\r\n__ei_open(dev);\r\nreturn 0;\r\n}\r\nstatic int zorro8390_close(struct net_device *dev)\r\n{\r\nif (ei_debug > 1)\r\nnetdev_dbg(dev, "Shutting down ethercard\n");\r\n__ei_close(dev);\r\nreturn 0;\r\n}\r\nstatic void __devexit zorro8390_remove_one(struct zorro_dev *z)\r\n{\r\nstruct net_device *dev = zorro_get_drvdata(z);\r\nunregister_netdev(dev);\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\nrelease_mem_region(ZTWO_PADDR(dev->base_addr), NE_IO_EXTENT * 2);\r\nfree_netdev(dev);\r\n}\r\nstatic int __devinit zorro8390_init(struct net_device *dev,\r\nunsigned long board, const char *name,\r\nunsigned long ioaddr)\r\n{\r\nint i;\r\nint err;\r\nunsigned char SA_prom[32];\r\nint start_page, stop_page;\r\nstatic u32 zorro8390_offsets[16] = {\r\n0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,\r\n0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\r\n};\r\n{\r\nunsigned long reset_start_time = jiffies;\r\nz_writeb(z_readb(ioaddr + NE_RESET), ioaddr + NE_RESET);\r\nwhile ((z_readb(ioaddr + NE_EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies,\r\nreset_start_time + 2 * HZ / 100)) {\r\nnetdev_warn(dev, "not found (no reset ack)\n");\r\nreturn -ENODEV;\r\n}\r\nz_writeb(0xff, ioaddr + NE_EN0_ISR);\r\n}\r\n{\r\nstatic const struct {\r\nu32 value;\r\nu32 offset;\r\n} program_seq[] = {\r\n{E8390_NODMA + E8390_PAGE0 + E8390_STOP, NE_CMD},\r\n{0x48, NE_EN0_DCFG},\r\n{0x00, NE_EN0_RCNTLO},\r\n{0x00, NE_EN0_RCNTHI},\r\n{0x00, NE_EN0_IMR},\r\n{0xFF, NE_EN0_ISR},\r\n{E8390_RXOFF, NE_EN0_RXCR},\r\n{E8390_TXOFF, NE_EN0_TXCR},\r\n{32, NE_EN0_RCNTLO},\r\n{0x00, NE_EN0_RCNTHI},\r\n{0x00, NE_EN0_RSARLO},\r\n{0x00, NE_EN0_RSARHI},\r\n{E8390_RREAD + E8390_START, NE_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++)\r\nz_writeb(program_seq[i].value,\r\nioaddr + program_seq[i].offset);\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nSA_prom[i] = z_readb(ioaddr + NE_DATAPORT);\r\n(void)z_readb(ioaddr + NE_DATAPORT);\r\n}\r\nz_writeb(0x49, ioaddr + NE_EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\ndev->base_addr = ioaddr;\r\ndev->irq = IRQ_AMIGA_PORTS;\r\ni = request_irq(IRQ_AMIGA_PORTS, __ei_interrupt,\r\nIRQF_SHARED, DRV_NAME, dev);\r\nif (i)\r\nreturn i;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = SA_prom[i];\r\npr_debug("Found ethernet address: %pM\n", dev->dev_addr);\r\nei_status.name = name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = 1;\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\nei_status.reset_8390 = zorro8390_reset_8390;\r\nei_status.block_input = zorro8390_block_input;\r\nei_status.block_output = zorro8390_block_output;\r\nei_status.get_8390_hdr = zorro8390_get_8390_hdr;\r\nei_status.reg_offset = zorro8390_offsets;\r\ndev->netdev_ops = &zorro8390_netdev_ops;\r\n__NS8390_init(dev, 0);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\nreturn err;\r\n}\r\nnetdev_info(dev, "%s at 0x%08lx, Ethernet Address %pM\n",\r\nname, board, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int __devinit zorro8390_init_one(struct zorro_dev *z,\r\nconst struct zorro_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nunsigned long board, ioaddr;\r\nint err, i;\r\nfor (i = ARRAY_SIZE(cards) - 1; i >= 0; i--)\r\nif (z->id == cards[i].id)\r\nbreak;\r\nif (i < 0)\r\nreturn -ENODEV;\r\nboard = z->resource.start;\r\nioaddr = board + cards[i].offset;\r\ndev = ____alloc_ei_netdev(0);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nif (!request_mem_region(ioaddr, NE_IO_EXTENT * 2, DRV_NAME)) {\r\nfree_netdev(dev);\r\nreturn -EBUSY;\r\n}\r\nerr = zorro8390_init(dev, board, cards[i].name, ZTWO_VADDR(ioaddr));\r\nif (err) {\r\nrelease_mem_region(ioaddr, NE_IO_EXTENT * 2);\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nzorro_set_drvdata(z, dev);\r\nreturn 0;\r\n}\r\nstatic int __init zorro8390_init_module(void)\r\n{\r\nreturn zorro_register_driver(&zorro8390_driver);\r\n}\r\nstatic void __exit zorro8390_cleanup_module(void)\r\n{\r\nzorro_unregister_driver(&zorro8390_driver);\r\n}
