enum sched_prio string_to_prio(const char *str)\r\n{\r\nif (strncasecmp("high", str, strlen(str)) == 0)\r\nreturn SCHED_HIGH;\r\nelse if (strncasecmp("default", str, strlen(str)) == 0)\r\nreturn SCHED_DEFAULT;\r\nelse if (strncasecmp("low", str, strlen(str)) == 0)\r\nreturn SCHED_LOW;\r\nelse\r\nreturn SCHED_ERR;\r\n}\r\nFILE *prepare_output(const char *dirname)\r\n{\r\nFILE *output = NULL;\r\nint len;\r\nchar *filename;\r\nstruct utsname sysdata;\r\nDIR *dir;\r\ndir = opendir(dirname);\r\nif (dir == NULL) {\r\nif (mkdir(dirname, 0755)) {\r\nperror("mkdir");\r\nfprintf(stderr, "error: Cannot create dir %s\n",\r\ndirname);\r\nreturn NULL;\r\n}\r\n}\r\nlen = strlen(dirname) + 30;\r\nfilename = malloc(sizeof(char) * len);\r\nif (uname(&sysdata) == 0) {\r\nlen += strlen(sysdata.nodename) + strlen(sysdata.release);\r\nfilename = realloc(filename, sizeof(char) * len);\r\nif (filename == NULL) {\r\nperror("realloc");\r\nreturn NULL;\r\n}\r\nsnprintf(filename, len - 1, "%s/benchmark_%s_%s_%li.log",\r\ndirname, sysdata.nodename, sysdata.release, time(NULL));\r\n} else {\r\nsnprintf(filename, len - 1, "%s/benchmark_%li.log",\r\ndirname, time(NULL));\r\n}\r\ndprintf("logilename: %s\n", filename);\r\noutput = fopen(filename, "w+");\r\nif (output == NULL) {\r\nperror("fopen");\r\nfprintf(stderr, "error: unable to open logfile\n");\r\n}\r\nfprintf(stdout, "Logfile: %s\n", filename);\r\nfree(filename);\r\nfprintf(output, "#round load sleep performance powersave percentage\n");\r\nreturn output;\r\n}\r\nstruct config *prepare_default_config()\r\n{\r\nstruct config *config = malloc(sizeof(struct config));\r\ndprintf("loading defaults\n");\r\nconfig->sleep = 500000;\r\nconfig->load = 500000;\r\nconfig->sleep_step = 500000;\r\nconfig->load_step = 500000;\r\nconfig->cycles = 5;\r\nconfig->rounds = 50;\r\nconfig->cpu = 0;\r\nconfig->prio = SCHED_HIGH;\r\nconfig->verbose = 0;\r\nstrncpy(config->governor, "ondemand", 8);\r\nconfig->output = stdout;\r\n#ifdef DEFAULT_CONFIG_FILE\r\nif (prepare_config(DEFAULT_CONFIG_FILE, config))\r\nreturn NULL;\r\n#endif\r\nreturn config;\r\n}\r\nint prepare_config(const char *path, struct config *config)\r\n{\r\nsize_t len = 0;\r\nchar *opt, *val, *line = NULL;\r\nFILE *configfile = fopen(path, "r");\r\nif (config == NULL) {\r\nfprintf(stderr, "error: config is NULL\n");\r\nreturn 1;\r\n}\r\nif (configfile == NULL) {\r\nperror("fopen");\r\nfprintf(stderr, "error: unable to read configfile\n");\r\nfree(config);\r\nreturn 1;\r\n}\r\nwhile (getline(&line, &len, configfile) != -1) {\r\nif (line[0] == '#' || line[0] == ' ')\r\ncontinue;\r\nsscanf(line, "%as = %as", &opt, &val);\r\ndprintf("parsing: %s -> %s\n", opt, val);\r\nif (strncmp("sleep", opt, strlen(opt)) == 0)\r\nsscanf(val, "%li", &config->sleep);\r\nelse if (strncmp("load", opt, strlen(opt)) == 0)\r\nsscanf(val, "%li", &config->load);\r\nelse if (strncmp("load_step", opt, strlen(opt)) == 0)\r\nsscanf(val, "%li", &config->load_step);\r\nelse if (strncmp("sleep_step", opt, strlen(opt)) == 0)\r\nsscanf(val, "%li", &config->sleep_step);\r\nelse if (strncmp("cycles", opt, strlen(opt)) == 0)\r\nsscanf(val, "%u", &config->cycles);\r\nelse if (strncmp("rounds", opt, strlen(opt)) == 0)\r\nsscanf(val, "%u", &config->rounds);\r\nelse if (strncmp("verbose", opt, strlen(opt)) == 0)\r\nsscanf(val, "%u", &config->verbose);\r\nelse if (strncmp("output", opt, strlen(opt)) == 0)\r\nconfig->output = prepare_output(val);\r\nelse if (strncmp("cpu", opt, strlen(opt)) == 0)\r\nsscanf(val, "%u", &config->cpu);\r\nelse if (strncmp("governor", opt, 14) == 0)\r\nstrncpy(config->governor, val, 14);\r\nelse if (strncmp("priority", opt, strlen(opt)) == 0) {\r\nif (string_to_prio(val) != SCHED_ERR)\r\nconfig->prio = string_to_prio(val);\r\n}\r\n}\r\nfree(line);\r\nfree(opt);\r\nfree(val);\r\nreturn 0;\r\n}
