static int\r\nisl1208_i2c_read_regs(struct i2c_client *client, u8 reg, u8 buf[],\r\nunsigned len)\r\n{\r\nu8 reg_addr[1] = { reg };\r\nstruct i2c_msg msgs[2] = {\r\n{client->addr, 0, sizeof(reg_addr), reg_addr}\r\n,\r\n{client->addr, I2C_M_RD, len, buf}\r\n};\r\nint ret;\r\nBUG_ON(reg > ISL1208_REG_USR2);\r\nBUG_ON(reg + len > ISL1208_REG_USR2 + 1);\r\nret = i2c_transfer(client->adapter, msgs, 2);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int\r\nisl1208_i2c_set_regs(struct i2c_client *client, u8 reg, u8 const buf[],\r\nunsigned len)\r\n{\r\nu8 i2c_buf[ISL1208_REG_USR2 + 2];\r\nstruct i2c_msg msgs[1] = {\r\n{client->addr, 0, len + 1, i2c_buf}\r\n};\r\nint ret;\r\nBUG_ON(reg > ISL1208_REG_USR2);\r\nBUG_ON(reg + len > ISL1208_REG_USR2 + 1);\r\ni2c_buf[0] = reg;\r\nmemcpy(&i2c_buf[1], &buf[0], len);\r\nret = i2c_transfer(client->adapter, msgs, 1);\r\nif (ret > 0)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int\r\nisl1208_i2c_validate_client(struct i2c_client *client)\r\n{\r\nu8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };\r\nu8 zero_mask[ISL1208_RTC_SECTION_LEN] = {\r\n0x80, 0x80, 0x40, 0xc0, 0xe0, 0x00, 0xf8\r\n};\r\nint i;\r\nint ret;\r\nret = isl1208_i2c_read_regs(client, 0, regs, ISL1208_RTC_SECTION_LEN);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ISL1208_RTC_SECTION_LEN; ++i) {\r\nif (regs[i] & zero_mask[i])\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_i2c_get_sr(struct i2c_client *client)\r\n{\r\nint sr = i2c_smbus_read_byte_data(client, ISL1208_REG_SR);\r\nif (sr < 0)\r\nreturn -EIO;\r\nreturn sr;\r\n}\r\nstatic int\r\nisl1208_i2c_get_atr(struct i2c_client *client)\r\n{\r\nint atr = i2c_smbus_read_byte_data(client, ISL1208_REG_ATR);\r\nif (atr < 0)\r\nreturn atr;\r\natr &= 0x3f;\r\natr ^= 1 << 5;\r\natr += 2 * 9;\r\nreturn atr;\r\n}\r\nstatic int\r\nisl1208_i2c_get_dtr(struct i2c_client *client)\r\n{\r\nint dtr = i2c_smbus_read_byte_data(client, ISL1208_REG_DTR);\r\nif (dtr < 0)\r\nreturn -EIO;\r\ndtr = ((dtr & 0x3) * 20) * (dtr & (1 << 2) ? -1 : 1);\r\nreturn dtr;\r\n}\r\nstatic int\r\nisl1208_i2c_get_usr(struct i2c_client *client)\r\n{\r\nu8 buf[ISL1208_USR_SECTION_LEN] = { 0, };\r\nint ret;\r\nret = isl1208_i2c_read_regs(client, ISL1208_REG_USR1, buf,\r\nISL1208_USR_SECTION_LEN);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn (buf[1] << 8) | buf[0];\r\n}\r\nstatic int\r\nisl1208_i2c_set_usr(struct i2c_client *client, u16 usr)\r\n{\r\nu8 buf[ISL1208_USR_SECTION_LEN];\r\nbuf[0] = usr & 0xff;\r\nbuf[1] = (usr >> 8) & 0xff;\r\nreturn isl1208_i2c_set_regs(client, ISL1208_REG_USR1, buf,\r\nISL1208_USR_SECTION_LEN);\r\n}\r\nstatic int\r\nisl1208_rtc_toggle_alarm(struct i2c_client *client, int enable)\r\n{\r\nint icr = i2c_smbus_read_byte_data(client, ISL1208_REG_INT);\r\nif (icr < 0) {\r\ndev_err(&client->dev, "%s: reading INT failed\n", __func__);\r\nreturn icr;\r\n}\r\nif (enable)\r\nicr |= ISL1208_REG_INT_ALME | ISL1208_REG_INT_IM;\r\nelse\r\nicr &= ~(ISL1208_REG_INT_ALME | ISL1208_REG_INT_IM);\r\nicr = i2c_smbus_write_byte_data(client, ISL1208_REG_INT, icr);\r\nif (icr < 0) {\r\ndev_err(&client->dev, "%s: writing INT failed\n", __func__);\r\nreturn icr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct i2c_client *const client = to_i2c_client(dev);\r\nint sr, dtr, atr, usr;\r\nsr = isl1208_i2c_get_sr(client);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: reading SR failed\n", __func__);\r\nreturn sr;\r\n}\r\nseq_printf(seq, "status_reg\t:%s%s%s%s%s%s (0x%.2x)\n",\r\n(sr & ISL1208_REG_SR_RTCF) ? " RTCF" : "",\r\n(sr & ISL1208_REG_SR_BAT) ? " BAT" : "",\r\n(sr & ISL1208_REG_SR_ALM) ? " ALM" : "",\r\n(sr & ISL1208_REG_SR_WRTC) ? " WRTC" : "",\r\n(sr & ISL1208_REG_SR_XTOSCB) ? " XTOSCB" : "",\r\n(sr & ISL1208_REG_SR_ARST) ? " ARST" : "", sr);\r\nseq_printf(seq, "batt_status\t: %s\n",\r\n(sr & ISL1208_REG_SR_RTCF) ? "bad" : "okay");\r\ndtr = isl1208_i2c_get_dtr(client);\r\nif (dtr >= 0 - 1)\r\nseq_printf(seq, "digital_trim\t: %d ppm\n", dtr);\r\natr = isl1208_i2c_get_atr(client);\r\nif (atr >= 0)\r\nseq_printf(seq, "analog_trim\t: %d.%.2d pF\n",\r\natr >> 2, (atr & 0x3) * 25);\r\nusr = isl1208_i2c_get_usr(client);\r\nif (usr >= 0)\r\nseq_printf(seq, "user_data\t: 0x%.4x\n", usr);\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_i2c_read_time(struct i2c_client *client, struct rtc_time *tm)\r\n{\r\nint sr;\r\nu8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };\r\nsr = isl1208_i2c_get_sr(client);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: reading SR failed\n", __func__);\r\nreturn -EIO;\r\n}\r\nsr = isl1208_i2c_read_regs(client, 0, regs, ISL1208_RTC_SECTION_LEN);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: reading RTC section failed\n",\r\n__func__);\r\nreturn sr;\r\n}\r\ntm->tm_sec = bcd2bin(regs[ISL1208_REG_SC]);\r\ntm->tm_min = bcd2bin(regs[ISL1208_REG_MN]);\r\n{\r\nconst u8 _hr = regs[ISL1208_REG_HR];\r\nif (_hr & ISL1208_REG_HR_MIL)\r\ntm->tm_hour = bcd2bin(_hr & 0x3f);\r\nelse {\r\ntm->tm_hour = bcd2bin(_hr & 0x1f);\r\nif (_hr & ISL1208_REG_HR_PM)\r\ntm->tm_hour += 12;\r\n}\r\n}\r\ntm->tm_mday = bcd2bin(regs[ISL1208_REG_DT]);\r\ntm->tm_mon = bcd2bin(regs[ISL1208_REG_MO]) - 1;\r\ntm->tm_year = bcd2bin(regs[ISL1208_REG_YR]) + 100;\r\ntm->tm_wday = bcd2bin(regs[ISL1208_REG_DW]);\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_i2c_read_alarm(struct i2c_client *client, struct rtc_wkalrm *alarm)\r\n{\r\nstruct rtc_time *const tm = &alarm->time;\r\nu8 regs[ISL1208_ALARM_SECTION_LEN] = { 0, };\r\nint icr, yr, sr = isl1208_i2c_get_sr(client);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: reading SR failed\n", __func__);\r\nreturn sr;\r\n}\r\nsr = isl1208_i2c_read_regs(client, ISL1208_REG_SCA, regs,\r\nISL1208_ALARM_SECTION_LEN);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: reading alarm section failed\n",\r\n__func__);\r\nreturn sr;\r\n}\r\ntm->tm_sec = bcd2bin(regs[ISL1208_REG_SCA - ISL1208_REG_SCA] & 0x7f);\r\ntm->tm_min = bcd2bin(regs[ISL1208_REG_MNA - ISL1208_REG_SCA] & 0x7f);\r\ntm->tm_hour = bcd2bin(regs[ISL1208_REG_HRA - ISL1208_REG_SCA] & 0x3f);\r\ntm->tm_mday = bcd2bin(regs[ISL1208_REG_DTA - ISL1208_REG_SCA] & 0x3f);\r\ntm->tm_mon =\r\nbcd2bin(regs[ISL1208_REG_MOA - ISL1208_REG_SCA] & 0x1f) - 1;\r\ntm->tm_wday = bcd2bin(regs[ISL1208_REG_DWA - ISL1208_REG_SCA] & 0x03);\r\nyr = i2c_smbus_read_byte_data(client, ISL1208_REG_YR);\r\nif (yr < 0) {\r\ndev_err(&client->dev, "%s: reading RTC YR failed\n", __func__);\r\nreturn yr;\r\n}\r\ntm->tm_year = bcd2bin(yr) + 100;\r\nicr = i2c_smbus_read_byte_data(client, ISL1208_REG_INT);\r\nif (icr < 0) {\r\ndev_err(&client->dev, "%s: reading INT failed\n", __func__);\r\nreturn icr;\r\n}\r\nalarm->enabled = !!(icr & ISL1208_REG_INT_ALME);\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_i2c_set_alarm(struct i2c_client *client, struct rtc_wkalrm *alarm)\r\n{\r\nstruct rtc_time *alarm_tm = &alarm->time;\r\nu8 regs[ISL1208_ALARM_SECTION_LEN] = { 0, };\r\nconst int offs = ISL1208_REG_SCA;\r\nunsigned long rtc_secs, alarm_secs;\r\nstruct rtc_time rtc_tm;\r\nint err, enable;\r\nerr = isl1208_i2c_read_time(client, &rtc_tm);\r\nif (err)\r\nreturn err;\r\nerr = rtc_tm_to_time(&rtc_tm, &rtc_secs);\r\nif (err)\r\nreturn err;\r\nerr = rtc_tm_to_time(alarm_tm, &alarm_secs);\r\nif (err)\r\nreturn err;\r\nif (!alarm->enabled || alarm_secs <= rtc_secs)\r\nenable = 0x00;\r\nelse\r\nenable = 0x80;\r\nregs[ISL1208_REG_SCA - offs] = bin2bcd(alarm_tm->tm_sec) | enable;\r\nregs[ISL1208_REG_MNA - offs] = bin2bcd(alarm_tm->tm_min) | enable;\r\nregs[ISL1208_REG_HRA - offs] = bin2bcd(alarm_tm->tm_hour) |\r\nISL1208_REG_HR_MIL | enable;\r\nregs[ISL1208_REG_DTA - offs] = bin2bcd(alarm_tm->tm_mday) | enable;\r\nregs[ISL1208_REG_MOA - offs] = bin2bcd(alarm_tm->tm_mon + 1) | enable;\r\nregs[ISL1208_REG_DWA - offs] = bin2bcd(alarm_tm->tm_wday & 7) | enable;\r\nerr = isl1208_i2c_set_regs(client, offs, regs,\r\nISL1208_ALARM_SECTION_LEN);\r\nif (err < 0) {\r\ndev_err(&client->dev, "%s: writing ALARM section failed\n",\r\n__func__);\r\nreturn err;\r\n}\r\nerr = isl1208_rtc_toggle_alarm(client, enable);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn isl1208_i2c_read_time(to_i2c_client(dev), tm);\r\n}\r\nstatic int\r\nisl1208_i2c_set_time(struct i2c_client *client, struct rtc_time const *tm)\r\n{\r\nint sr;\r\nu8 regs[ISL1208_RTC_SECTION_LEN] = { 0, };\r\nif (tm->tm_year < 100)\r\nreturn -EINVAL;\r\nregs[ISL1208_REG_SC] = bin2bcd(tm->tm_sec);\r\nregs[ISL1208_REG_MN] = bin2bcd(tm->tm_min);\r\nregs[ISL1208_REG_HR] = bin2bcd(tm->tm_hour) | ISL1208_REG_HR_MIL;\r\nregs[ISL1208_REG_DT] = bin2bcd(tm->tm_mday);\r\nregs[ISL1208_REG_MO] = bin2bcd(tm->tm_mon + 1);\r\nregs[ISL1208_REG_YR] = bin2bcd(tm->tm_year - 100);\r\nregs[ISL1208_REG_DW] = bin2bcd(tm->tm_wday & 7);\r\nsr = isl1208_i2c_get_sr(client);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: reading SR failed\n", __func__);\r\nreturn sr;\r\n}\r\nsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR,\r\nsr | ISL1208_REG_SR_WRTC);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: writing SR failed\n", __func__);\r\nreturn sr;\r\n}\r\nsr = isl1208_i2c_set_regs(client, 0, regs, ISL1208_RTC_SECTION_LEN);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: writing RTC section failed\n",\r\n__func__);\r\nreturn sr;\r\n}\r\nsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR,\r\nsr & ~ISL1208_REG_SR_WRTC);\r\nif (sr < 0) {\r\ndev_err(&client->dev, "%s: writing SR failed\n", __func__);\r\nreturn sr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nisl1208_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nreturn isl1208_i2c_set_time(to_i2c_client(dev), tm);\r\n}\r\nstatic int\r\nisl1208_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nreturn isl1208_i2c_read_alarm(to_i2c_client(dev), alarm);\r\n}\r\nstatic int\r\nisl1208_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nreturn isl1208_i2c_set_alarm(to_i2c_client(dev), alarm);\r\n}\r\nstatic irqreturn_t\r\nisl1208_rtc_interrupt(int irq, void *data)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nstruct i2c_client *client = data;\r\nint handled = 0, sr, err;\r\nwhile (1) {\r\nsr = isl1208_i2c_get_sr(client);\r\nif (sr >= 0)\r\nbreak;\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&client->dev, "%s: reading SR failed\n",\r\n__func__);\r\nreturn sr;\r\n}\r\n}\r\nif (sr & ISL1208_REG_SR_ALM) {\r\ndev_dbg(&client->dev, "alarm!\n");\r\nsr &= ~ISL1208_REG_SR_ALM;\r\nsr = i2c_smbus_write_byte_data(client, ISL1208_REG_SR, sr);\r\nif (sr < 0)\r\ndev_err(&client->dev, "%s: writing SR failed\n",\r\n__func__);\r\nelse\r\nhandled = 1;\r\nerr = isl1208_rtc_toggle_alarm(client, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic ssize_t\r\nisl1208_sysfs_show_atrim(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint atr = isl1208_i2c_get_atr(to_i2c_client(dev));\r\nif (atr < 0)\r\nreturn atr;\r\nreturn sprintf(buf, "%d.%.2d pF\n", atr >> 2, (atr & 0x3) * 25);\r\n}\r\nstatic ssize_t\r\nisl1208_sysfs_show_dtrim(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint dtr = isl1208_i2c_get_dtr(to_i2c_client(dev));\r\nif (dtr < 0)\r\nreturn dtr;\r\nreturn sprintf(buf, "%d ppm\n", dtr);\r\n}\r\nstatic ssize_t\r\nisl1208_sysfs_show_usr(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint usr = isl1208_i2c_get_usr(to_i2c_client(dev));\r\nif (usr < 0)\r\nreturn usr;\r\nreturn sprintf(buf, "0x%.4x\n", usr);\r\n}\r\nstatic ssize_t\r\nisl1208_sysfs_store_usr(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint usr = -1;\r\nif (buf[0] == '0' && (buf[1] == 'x' || buf[1] == 'X')) {\r\nif (sscanf(buf, "%x", &usr) != 1)\r\nreturn -EINVAL;\r\n} else {\r\nif (sscanf(buf, "%d", &usr) != 1)\r\nreturn -EINVAL;\r\n}\r\nif (usr < 0 || usr > 0xffff)\r\nreturn -EINVAL;\r\nreturn isl1208_i2c_set_usr(to_i2c_client(dev), usr) ? -EIO : count;\r\n}\r\nstatic int\r\nisl1208_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nint rc = 0;\r\nstruct rtc_device *rtc;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nif (isl1208_i2c_validate_client(client) < 0)\r\nreturn -ENODEV;\r\ndev_info(&client->dev,\r\n"chip found, driver version " DRV_VERSION "\n");\r\nif (client->irq > 0) {\r\nrc = request_threaded_irq(client->irq, NULL,\r\nisl1208_rtc_interrupt,\r\nIRQF_SHARED,\r\nisl1208_driver.driver.name, client);\r\nif (!rc) {\r\ndevice_init_wakeup(&client->dev, 1);\r\nenable_irq_wake(client->irq);\r\n} else {\r\ndev_err(&client->dev,\r\n"Unable to request irq %d, no alarm support\n",\r\nclient->irq);\r\nclient->irq = 0;\r\n}\r\n}\r\nrtc = rtc_device_register(isl1208_driver.driver.name,\r\n&client->dev, &isl1208_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\nrc = PTR_ERR(rtc);\r\ngoto exit_free_irq;\r\n}\r\ni2c_set_clientdata(client, rtc);\r\nrc = isl1208_i2c_get_sr(client);\r\nif (rc < 0) {\r\ndev_err(&client->dev, "reading status failed\n");\r\ngoto exit_unregister;\r\n}\r\nif (rc & ISL1208_REG_SR_RTCF)\r\ndev_warn(&client->dev, "rtc power failure detected, "\r\n"please set clock.\n");\r\nrc = sysfs_create_group(&client->dev.kobj, &isl1208_rtc_sysfs_files);\r\nif (rc)\r\ngoto exit_unregister;\r\nreturn 0;\r\nexit_unregister:\r\nrtc_device_unregister(rtc);\r\nexit_free_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, client);\r\nreturn rc;\r\n}\r\nstatic int\r\nisl1208_remove(struct i2c_client *client)\r\n{\r\nstruct rtc_device *rtc = i2c_get_clientdata(client);\r\nsysfs_remove_group(&client->dev.kobj, &isl1208_rtc_sysfs_files);\r\nrtc_device_unregister(rtc);\r\nif (client->irq)\r\nfree_irq(client->irq, client);\r\nreturn 0;\r\n}
