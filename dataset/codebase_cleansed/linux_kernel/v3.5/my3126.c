static int my3126_reset(struct cphy *cphy, int wait)\r\n{\r\nreturn 0;\r\n}\r\nstatic int my3126_interrupt_enable(struct cphy *cphy)\r\n{\r\nschedule_delayed_work(&cphy->phy_update, HZ/30);\r\nt1_tpi_read(cphy->adapter, A_ELMER0_GPO, &cphy->elmer_gpo);\r\nreturn 0;\r\n}\r\nstatic int my3126_interrupt_disable(struct cphy *cphy)\r\n{\r\ncancel_delayed_work_sync(&cphy->phy_update);\r\nreturn 0;\r\n}\r\nstatic int my3126_interrupt_clear(struct cphy *cphy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int my3126_interrupt_handler(struct cphy *cphy)\r\n{\r\nu32 val;\r\nu16 val16;\r\nu16 status;\r\nu32 act_count;\r\nadapter_t *adapter;\r\nadapter = cphy->adapter;\r\nif (cphy->count == 50) {\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\r\nval16 = (u16) val;\r\nstatus = cphy->bmsr ^ val16;\r\nif (status & MDIO_STAT1_LSTATUS)\r\nt1_link_changed(adapter, 0);\r\ncphy->bmsr = val16;\r\ncphy->count = 0;\r\n}\r\nt1_tpi_write(adapter, OFFSET(SUNI1x10GEXP_REG_MSTAT_CONTROL),\r\nSUNI1x10GEXP_BITMSK_MSTAT_SNAP);\r\nt1_tpi_read(adapter,\r\nOFFSET(SUNI1x10GEXP_REG_MSTAT_COUNTER_1_LOW), &act_count);\r\nt1_tpi_read(adapter,\r\nOFFSET(SUNI1x10GEXP_REG_MSTAT_COUNTER_33_LOW), &val);\r\nact_count += val;\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\ncphy->elmer_gpo = val;\r\nif ( (val & (1 << 8)) || (val & (1 << 19)) ||\r\n(cphy->act_count == act_count) || cphy->act_on ) {\r\nif (is_T2(adapter))\r\nval |= (1 << 9);\r\nelse if (t1_is_T1B(adapter))\r\nval |= (1 << 20);\r\ncphy->act_on = 0;\r\n} else {\r\nif (is_T2(adapter))\r\nval &= ~(1 << 9);\r\nelse if (t1_is_T1B(adapter))\r\nval &= ~(1 << 20);\r\ncphy->act_on = 1;\r\n}\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\ncphy->elmer_gpo = val;\r\ncphy->act_count = act_count;\r\ncphy->count++;\r\nreturn cphy_cause_link_change;\r\n}\r\nstatic void my3216_poll(struct work_struct *work)\r\n{\r\nstruct cphy *cphy = container_of(work, struct cphy, phy_update.work);\r\nmy3126_interrupt_handler(cphy);\r\n}\r\nstatic int my3126_set_loopback(struct cphy *cphy, int on)\r\n{\r\nreturn 0;\r\n}\r\nstatic int my3126_get_link_status(struct cphy *cphy,\r\nint *link_ok, int *speed, int *duplex, int *fc)\r\n{\r\nu32 val;\r\nu16 val16;\r\nadapter_t *adapter;\r\nadapter = cphy->adapter;\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\r\nval16 = (u16) val;\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\ncphy->elmer_gpo = val;\r\n*link_ok = (val16 & MDIO_STAT1_LSTATUS);\r\nif (*link_ok) {\r\nif (is_T2(adapter))\r\nval &= ~(1 << 8);\r\nelse if (t1_is_T1B(adapter))\r\nval &= ~(1 << 19);\r\n} else {\r\nif (is_T2(adapter))\r\nval |= (1 << 8);\r\nelse if (t1_is_T1B(adapter))\r\nval |= (1 << 19);\r\n}\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\ncphy->elmer_gpo = val;\r\n*speed = SPEED_10000;\r\n*duplex = DUPLEX_FULL;\r\nif (fc)\r\n*fc = PAUSE_RX | PAUSE_TX;\r\nreturn 0;\r\n}\r\nstatic void my3126_destroy(struct cphy *cphy)\r\n{\r\nkfree(cphy);\r\n}\r\nstatic struct cphy *my3126_phy_create(struct net_device *dev,\r\nint phy_addr, const struct mdio_ops *mdio_ops)\r\n{\r\nstruct cphy *cphy = kzalloc(sizeof (*cphy), GFP_KERNEL);\r\nif (!cphy)\r\nreturn NULL;\r\ncphy_init(cphy, dev, phy_addr, &my3126_ops, mdio_ops);\r\nINIT_DELAYED_WORK(&cphy->phy_update, my3216_poll);\r\ncphy->bmsr = 0;\r\nreturn cphy;\r\n}\r\nstatic int my3126_phy_reset(adapter_t * adapter)\r\n{\r\nu32 val;\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~4;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nmsleep(100);\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val | 4);\r\nmsleep(1000);\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval |= 0x8000;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(100);\r\nreturn 0;\r\n}
