static void se401_write_req(struct gspca_dev *gspca_dev, u16 req, u16 value,\r\nint silent)\r\n{\r\nint err;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nerr = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0), req,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, 0, NULL, 0, 1000);\r\nif (err < 0) {\r\nif (!silent)\r\npr_err("write req failed req %#04x val %#04x error %d\n",\r\nreq, value, err);\r\ngspca_dev->usb_err = err;\r\n}\r\n}\r\nstatic void se401_read_req(struct gspca_dev *gspca_dev, u16 req, int silent)\r\n{\r\nint err;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nif (USB_BUF_SZ < READ_REQ_SIZE) {\r\npr_err("USB_BUF_SZ too small!!\n");\r\ngspca_dev->usb_err = -ENOBUFS;\r\nreturn;\r\n}\r\nerr = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0), req,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, gspca_dev->usb_buf, READ_REQ_SIZE, 1000);\r\nif (err < 0) {\r\nif (!silent)\r\npr_err("read req failed req %#04x error %d\n",\r\nreq, err);\r\ngspca_dev->usb_err = err;\r\n}\r\n}\r\nstatic void se401_set_feature(struct gspca_dev *gspca_dev,\r\nu16 selector, u16 param)\r\n{\r\nint err;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nerr = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nSE401_REQ_SET_EXT_FEATURE,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nparam, selector, NULL, 0, 1000);\r\nif (err < 0) {\r\npr_err("set feature failed sel %#04x param %#04x error %d\n",\r\nselector, param, err);\r\ngspca_dev->usb_err = err;\r\n}\r\n}\r\nstatic int se401_get_feature(struct gspca_dev *gspca_dev, u16 selector)\r\n{\r\nint err;\r\nif (gspca_dev->usb_err < 0)\r\nreturn gspca_dev->usb_err;\r\nif (USB_BUF_SZ < 2) {\r\npr_err("USB_BUF_SZ too small!!\n");\r\ngspca_dev->usb_err = -ENOBUFS;\r\nreturn gspca_dev->usb_err;\r\n}\r\nerr = usb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\nSE401_REQ_GET_EXT_FEATURE,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, selector, gspca_dev->usb_buf, 2, 1000);\r\nif (err < 0) {\r\npr_err("get feature failed sel %#04x error %d\n",\r\nselector, err);\r\ngspca_dev->usb_err = err;\r\nreturn err;\r\n}\r\nreturn gspca_dev->usb_buf[0] | (gspca_dev->usb_buf[1] << 8);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (gspca_dev->ctrl_dis & (1 << BRIGHTNESS))\r\nreturn;\r\nse401_write_req(gspca_dev, SE401_REQ_SET_BRT,\r\nsd->ctrls[BRIGHTNESS].val, 0);\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 gain = 63 - sd->ctrls[GAIN].val;\r\nse401_set_feature(gspca_dev, HV7131_REG_ARCG, gain);\r\nse401_set_feature(gspca_dev, HV7131_REG_AGCG, gain);\r\nse401_set_feature(gspca_dev, HV7131_REG_ABCG, gain);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint integration = sd->ctrls[EXPOSURE].val << 6;\r\nu8 expose_h, expose_m, expose_l;\r\nsd->expo_change_state = EXPO_CHANGED;\r\nif (sd->ctrls[FREQ].val == V4L2_CID_POWER_LINE_FREQUENCY_50HZ)\r\nintegration = integration - integration % 106667;\r\nif (sd->ctrls[FREQ].val == V4L2_CID_POWER_LINE_FREQUENCY_60HZ)\r\nintegration = integration - integration % 88889;\r\nexpose_h = (integration >> 16);\r\nexpose_m = (integration >> 8);\r\nexpose_l = integration;\r\nse401_set_feature(gspca_dev, HV7131_REG_TITL, expose_l);\r\nse401_set_feature(gspca_dev, HV7131_REG_TITM, expose_m);\r\nse401_set_feature(gspca_dev, HV7131_REG_TITU, expose_h);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nu8 *cd = gspca_dev->usb_buf;\r\nint i, j, n;\r\nint widths[MAX_MODES], heights[MAX_MODES];\r\nse401_read_req(gspca_dev, SE401_REQ_GET_CAMERA_DESCRIPTOR, 1);\r\nif (gspca_dev->usb_err) {\r\nusb_reset_device(gspca_dev->dev);\r\ngspca_dev->usb_err = 0;\r\nse401_read_req(gspca_dev, SE401_REQ_GET_CAMERA_DESCRIPTOR, 0);\r\n}\r\nse401_write_req(gspca_dev, SE401_REQ_LED_CONTROL, 0, 0);\r\nif (gspca_dev->usb_err)\r\nreturn gspca_dev->usb_err;\r\nif (cd[1] != 0x41) {\r\npr_err("Wrong descriptor type\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(cd[2] & SE401_FORMAT_BAYER)) {\r\npr_err("Bayer format not supported!\n");\r\nreturn -ENODEV;\r\n}\r\nif (cd[3])\r\npr_info("ExtraFeatures: %d\n", cd[3]);\r\nn = cd[4] | (cd[5] << 8);\r\nif (n > MAX_MODES) {\r\npr_err("Too many frame sizes\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < n ; i++) {\r\nwidths[i] = cd[6 + i * 4 + 0] | (cd[6 + i * 4 + 1] << 8);\r\nheights[i] = cd[6 + i * 4 + 2] | (cd[6 + i * 4 + 3] << 8);\r\n}\r\nfor (i = 0; i < n ; i++) {\r\nsd->fmts[i].width = widths[i];\r\nsd->fmts[i].height = heights[i];\r\nsd->fmts[i].field = V4L2_FIELD_NONE;\r\nsd->fmts[i].colorspace = V4L2_COLORSPACE_SRGB;\r\nsd->fmts[i].priv = 1;\r\nfor (j = 0; j < n; j++) {\r\nif (widths[j] / 2 == widths[i] &&\r\nheights[j] / 2 == heights[i]) {\r\nsd->fmts[i].priv = 2;\r\nbreak;\r\n}\r\n}\r\nfor (j = 0; j < n; j++) {\r\nif (widths[j] / 4 == widths[i] &&\r\nheights[j] / 4 == heights[i]) {\r\nsd->fmts[i].priv = 4;\r\nbreak;\r\n}\r\n}\r\nif (sd->fmts[i].priv == 1) {\r\nsd->fmts[i].pixelformat = V4L2_PIX_FMT_SBGGR8;\r\nsd->fmts[i].bytesperline = widths[i];\r\nsd->fmts[i].sizeimage = widths[i] * heights[i];\r\npr_info("Frame size: %dx%d bayer\n",\r\nwidths[i], heights[i]);\r\n} else {\r\nsd->fmts[i].pixelformat = V4L2_PIX_FMT_SE401;\r\nsd->fmts[i].bytesperline = 0;\r\nsd->fmts[i].sizeimage = widths[i] * heights[i] * 3;\r\npr_info("Frame size: %dx%d 1/%dth janggu\n",\r\nwidths[i], heights[i],\r\nsd->fmts[i].priv * sd->fmts[i].priv);\r\n}\r\n}\r\ncam->cam_mode = sd->fmts;\r\ncam->nmodes = n;\r\ncam->bulk = 1;\r\ncam->bulk_size = BULK_SIZE;\r\ncam->bulk_nurbs = 4;\r\ncam->ctrls = sd->ctrls;\r\nsd->resetlevel = 0x2d;\r\nse401_read_req(gspca_dev, SE401_REQ_GET_BRT, 1);\r\nif (gspca_dev->usb_err) {\r\ngspca_dev->ctrl_dis = (1 << BRIGHTNESS);\r\ngspca_dev->usb_err = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->alt = 1;\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint mult = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nint mode = 0;\r\nse401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 1, 1);\r\nif (gspca_dev->usb_err) {\r\nusb_reset_device(gspca_dev->dev);\r\ngspca_dev->usb_err = 0;\r\nse401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 1, 0);\r\n}\r\nse401_write_req(gspca_dev, SE401_REQ_LED_CONTROL, 1, 0);\r\nse401_set_feature(gspca_dev, HV7131_REG_MODE_B, 0x05);\r\nse401_write_req(gspca_dev, SE401_REQ_SET_WIDTH,\r\ngspca_dev->width * mult, 0);\r\nse401_write_req(gspca_dev, SE401_REQ_SET_HEIGHT,\r\ngspca_dev->height * mult, 0);\r\nswitch (mult) {\r\ncase 1:\r\nmode = 0x03; break;\r\ncase 2:\r\nmode = SE401_QUANT_FACT << 4; break;\r\ncase 4:\r\nmode = (SE401_QUANT_FACT << 4) | 0x02; break;\r\n}\r\nse401_set_feature(gspca_dev, SE401_OPERATINGMODE, mode);\r\nsetbrightness(gspca_dev);\r\nsetgain(gspca_dev);\r\nsetexposure(gspca_dev);\r\nse401_set_feature(gspca_dev, HV7131_REG_ARLV, sd->resetlevel);\r\nsd->packet_read = 0;\r\nsd->pixels_read = 0;\r\nsd->restart_stream = 0;\r\nsd->resetlevel_frame_count = 0;\r\nsd->resetlevel_adjust_dir = 0;\r\nsd->expo_change_state = EXPO_NO_CHANGE;\r\nse401_write_req(gspca_dev, SE401_REQ_START_CONTINUOUS_CAPTURE, 0, 0);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nse401_write_req(gspca_dev, SE401_REQ_STOP_CONTINUOUS_CAPTURE, 0, 0);\r\nse401_write_req(gspca_dev, SE401_REQ_LED_CONTROL, 0, 0);\r\nse401_write_req(gspca_dev, SE401_REQ_CAMERA_POWER, 0, 0);\r\n}\r\nstatic void sd_dq_callback(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nunsigned int ahrc, alrc;\r\nint oldreset, adjust_dir;\r\nif (sd->restart_stream) {\r\nsd_stopN(gspca_dev);\r\nsd_start(gspca_dev);\r\nsd->restart_stream = 0;\r\n}\r\nsd->resetlevel_frame_count++;\r\nif (sd->resetlevel_frame_count < 20)\r\nreturn;\r\nse401_get_feature(gspca_dev, HV7131_REG_HIREFNOH);\r\nse401_get_feature(gspca_dev, HV7131_REG_HIREFNOL);\r\nse401_get_feature(gspca_dev, HV7131_REG_LOREFNOH);\r\nse401_get_feature(gspca_dev, HV7131_REG_LOREFNOL);\r\nahrc = 256*se401_get_feature(gspca_dev, HV7131_REG_HIREFNOH) +\r\nse401_get_feature(gspca_dev, HV7131_REG_HIREFNOL);\r\nalrc = 256*se401_get_feature(gspca_dev, HV7131_REG_LOREFNOH) +\r\nse401_get_feature(gspca_dev, HV7131_REG_LOREFNOL);\r\noldreset = sd->resetlevel;\r\nif (alrc > 10) {\r\nwhile (alrc >= 10 && sd->resetlevel < 63) {\r\nsd->resetlevel++;\r\nalrc /= 2;\r\n}\r\n} else if (ahrc > 20) {\r\nwhile (ahrc >= 20 && sd->resetlevel > 0) {\r\nsd->resetlevel--;\r\nahrc /= 2;\r\n}\r\n}\r\nif (sd->resetlevel > oldreset)\r\nadjust_dir = 1;\r\nelse\r\nadjust_dir = -1;\r\nif (sd->resetlevel_adjust_dir &&\r\nsd->resetlevel_adjust_dir != adjust_dir)\r\nsd->resetlevel = oldreset + (sd->resetlevel - oldreset) / 2;\r\nif (sd->resetlevel != oldreset) {\r\nsd->resetlevel_adjust_dir = adjust_dir;\r\nse401_set_feature(gspca_dev, HV7131_REG_ARLV, sd->resetlevel);\r\n}\r\nsd->resetlevel_frame_count = 0;\r\n}\r\nstatic void sd_complete_frame(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nswitch (sd->expo_change_state) {\r\ncase EXPO_CHANGED:\r\nsd->expo_change_state = EXPO_DROP_FRAME;\r\nbreak;\r\ncase EXPO_DROP_FRAME:\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nsd->expo_change_state = EXPO_NO_CHANGE;\r\nbreak;\r\ncase EXPO_NO_CHANGE:\r\nbreak;\r\n}\r\ngspca_frame_add(gspca_dev, LAST_PACKET, data, len);\r\n}\r\nstatic void sd_pkt_scan_janggu(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint imagesize = gspca_dev->width * gspca_dev->height;\r\nint i, plen, bits, pixels, info, count;\r\nif (sd->restart_stream)\r\nreturn;\r\nif (gspca_dev->last_packet_type == LAST_PACKET && len == 1024) {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nreturn;\r\n}\r\ni = 0;\r\nwhile (i < len) {\r\nif (sd->packet_read < 4) {\r\ncount = 4 - sd->packet_read;\r\nif (count > len - i)\r\ncount = len - i;\r\nmemcpy(&sd->packet[sd->packet_read], &data[i], count);\r\nsd->packet_read += count;\r\ni += count;\r\nif (sd->packet_read < 4)\r\nbreak;\r\n}\r\nbits = sd->packet[3] + (sd->packet[2] << 8);\r\npixels = sd->packet[1] + ((sd->packet[0] & 0x3f) << 8);\r\ninfo = (sd->packet[0] & 0xc0) >> 6;\r\nplen = ((bits + 47) >> 4) << 1;\r\nif (plen > 1024) {\r\npr_err("invalid packet len %d restarting stream\n",\r\nplen);\r\ngoto error;\r\n}\r\nif (info == 3) {\r\npr_err("unknown frame info value restarting stream\n");\r\ngoto error;\r\n}\r\ncount = plen - sd->packet_read;\r\nif (count > len - i)\r\ncount = len - i;\r\nmemcpy(&sd->packet[sd->packet_read], &data[i], count);\r\nsd->packet_read += count;\r\ni += count;\r\nif (sd->packet_read < plen)\r\nbreak;\r\nsd->pixels_read += pixels;\r\nsd->packet_read = 0;\r\nswitch (info) {\r\ncase 0:\r\ngspca_frame_add(gspca_dev, INTER_PACKET, sd->packet,\r\nplen);\r\nbreak;\r\ncase 1:\r\nif (sd->pixels_read != imagesize) {\r\npr_err("frame size %d expected %d\n",\r\nsd->pixels_read, imagesize);\r\ngoto error;\r\n}\r\nsd_complete_frame(gspca_dev, sd->packet, plen);\r\nreturn;\r\ncase 2:\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, sd->packet,\r\nplen);\r\nsd->pixels_read = pixels;\r\nbreak;\r\n}\r\n}\r\nreturn;\r\nerror:\r\nsd->restart_stream = 1;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\n}\r\nstatic void sd_pkt_scan_bayer(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nstruct cam *cam = &gspca_dev->cam;\r\nint imagesize = cam->cam_mode[gspca_dev->curr_mode].sizeimage;\r\nif (gspca_dev->image_len == 0) {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\r\nreturn;\r\n}\r\nif (gspca_dev->image_len + len >= imagesize) {\r\nsd_complete_frame(gspca_dev, data, len);\r\nreturn;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nint mult = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nif (len == 0)\r\nreturn;\r\nif (mult == 1)\r\nsd_pkt_scan_bayer(gspca_dev, data, len);\r\nelse\r\nsd_pkt_scan_janggu(gspca_dev, data, len);\r\n}\r\nstatic int sd_querymenu(struct gspca_dev *gspca_dev,\r\nstruct v4l2_querymenu *menu)\r\n{\r\nswitch (menu->id) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nswitch (menu->index) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:\r\nstrcpy((char *) menu->name, "NoFliker");\r\nreturn 0;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_50HZ:\r\nstrcpy((char *) menu->name, "50 Hz");\r\nreturn 0;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY_60HZ:\r\nstrcpy((char *) menu->name, "60 Hz");\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nu8 state;\r\nif (len != 2)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase 0:\r\ncase 1:\r\nstate = data[0];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (sd->button_state != state) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, state);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->button_state = state;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic int sd_pre_reset(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_post_reset(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}
