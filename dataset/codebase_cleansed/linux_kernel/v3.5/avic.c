static int avic_irq_set_priority(unsigned char irq, unsigned char prio)\r\n{\r\nunsigned int temp;\r\nunsigned int mask = 0x0F << irq % 8 * 4;\r\nif (irq >= AVIC_NUM_IRQS)\r\nreturn -EINVAL;\r\ntemp = __raw_readl(avic_base + AVIC_NIPRIORITY(irq / 8));\r\ntemp &= ~mask;\r\ntemp |= prio & mask;\r\n__raw_writel(temp, avic_base + AVIC_NIPRIORITY(irq / 8));\r\nreturn 0;\r\n}\r\nstatic int avic_set_irq_fiq(unsigned int irq, unsigned int type)\r\n{\r\nunsigned int irqt;\r\nif (irq >= AVIC_NUM_IRQS)\r\nreturn -EINVAL;\r\nif (irq < AVIC_NUM_IRQS / 2) {\r\nirqt = __raw_readl(avic_base + AVIC_INTTYPEL) & ~(1 << irq);\r\n__raw_writel(irqt | (!!type << irq), avic_base + AVIC_INTTYPEL);\r\n} else {\r\nirq -= AVIC_NUM_IRQS / 2;\r\nirqt = __raw_readl(avic_base + AVIC_INTTYPEH) & ~(1 << irq);\r\n__raw_writel(irqt | (!!type << irq), avic_base + AVIC_INTTYPEH);\r\n}\r\nreturn 0;\r\n}\r\nstatic void avic_irq_suspend(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nint idx = gc->irq_base >> 5;\r\navic_saved_mask_reg[idx] = __raw_readl(avic_base + ct->regs.mask);\r\n__raw_writel(gc->wake_active, avic_base + ct->regs.mask);\r\n}\r\nstatic void avic_irq_resume(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nint idx = gc->irq_base >> 5;\r\n__raw_writel(avic_saved_mask_reg[idx], avic_base + ct->regs.mask);\r\n}\r\nstatic __init void avic_init_gc(unsigned int irq_start)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nint idx = irq_start >> 5;\r\ngc = irq_alloc_generic_chip("mxc-avic", 1, irq_start, avic_base,\r\nhandle_level_irq);\r\ngc->private = &avic_extra_irq;\r\ngc->wake_enabled = IRQ_MSK(32);\r\nct = gc->chip_types;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_ack = irq_gc_mask_clr_bit;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\nct->chip.irq_suspend = avic_irq_suspend;\r\nct->chip.irq_resume = avic_irq_resume;\r\nct->regs.mask = !idx ? AVIC_INTENABLEL : AVIC_INTENABLEH;\r\nct->regs.ack = ct->regs.mask;\r\nirq_setup_generic_chip(gc, IRQ_MSK(32), 0, IRQ_NOREQUEST, 0);\r\n}\r\nasmlinkage void __exception_irq_entry avic_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 nivector;\r\ndo {\r\nnivector = __raw_readl(avic_base + AVIC_NIVECSR) >> 16;\r\nif (nivector == 0xffff)\r\nbreak;\r\nhandle_IRQ(nivector, regs);\r\n} while (1);\r\n}\r\nvoid __init mxc_init_irq(void __iomem *irqbase)\r\n{\r\nint i;\r\navic_base = irqbase;\r\n__raw_writel(0, avic_base + AVIC_INTCNTL);\r\n__raw_writel(0x1f, avic_base + AVIC_NIMASK);\r\n__raw_writel(0, avic_base + AVIC_INTENABLEH);\r\n__raw_writel(0, avic_base + AVIC_INTENABLEL);\r\n__raw_writel(0, avic_base + AVIC_INTTYPEH);\r\n__raw_writel(0, avic_base + AVIC_INTTYPEL);\r\nfor (i = 0; i < AVIC_NUM_IRQS; i += 32)\r\navic_init_gc(i);\r\nfor (i = 0; i < 8; i++)\r\n__raw_writel(0, avic_base + AVIC_NIPRIORITY(i));\r\n#ifdef CONFIG_FIQ\r\ninit_FIQ();\r\n#endif\r\nprintk(KERN_INFO "MXC IRQ initialized\n");\r\n}
