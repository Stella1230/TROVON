static int ezx_pcap_putget(struct pcap_chip *pcap, u32 *data)\r\n{\r\nstruct spi_transfer t;\r\nstruct spi_message m;\r\nint status;\r\nmemset(&t, 0, sizeof t);\r\nspi_message_init(&m);\r\nt.len = sizeof(u32);\r\nspi_message_add_tail(&t, &m);\r\npcap->buf = *data;\r\nt.tx_buf = (u8 *) &pcap->buf;\r\nt.rx_buf = (u8 *) &pcap->buf;\r\nstatus = spi_sync(pcap->spi, &m);\r\nif (status == 0)\r\n*data = pcap->buf;\r\nreturn status;\r\n}\r\nint ezx_pcap_write(struct pcap_chip *pcap, u8 reg_num, u32 value)\r\n{\r\nint ret;\r\nmutex_lock(&pcap->io_mutex);\r\nvalue &= PCAP_REGISTER_VALUE_MASK;\r\nvalue |= PCAP_REGISTER_WRITE_OP_BIT\r\n| (reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\r\nret = ezx_pcap_putget(pcap, &value);\r\nmutex_unlock(&pcap->io_mutex);\r\nreturn ret;\r\n}\r\nint ezx_pcap_read(struct pcap_chip *pcap, u8 reg_num, u32 *value)\r\n{\r\nint ret;\r\nmutex_lock(&pcap->io_mutex);\r\n*value = PCAP_REGISTER_READ_OP_BIT\r\n| (reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\r\nret = ezx_pcap_putget(pcap, value);\r\nmutex_unlock(&pcap->io_mutex);\r\nreturn ret;\r\n}\r\nint ezx_pcap_set_bits(struct pcap_chip *pcap, u8 reg_num, u32 mask, u32 val)\r\n{\r\nint ret;\r\nu32 tmp = PCAP_REGISTER_READ_OP_BIT |\r\n(reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\r\nmutex_lock(&pcap->io_mutex);\r\nret = ezx_pcap_putget(pcap, &tmp);\r\nif (ret)\r\ngoto out_unlock;\r\ntmp &= (PCAP_REGISTER_VALUE_MASK & ~mask);\r\ntmp |= (val & mask) | PCAP_REGISTER_WRITE_OP_BIT |\r\n(reg_num << PCAP_REGISTER_ADDRESS_SHIFT);\r\nret = ezx_pcap_putget(pcap, &tmp);\r\nout_unlock:\r\nmutex_unlock(&pcap->io_mutex);\r\nreturn ret;\r\n}\r\nint irq_to_pcap(struct pcap_chip *pcap, int irq)\r\n{\r\nreturn irq - pcap->irq_base;\r\n}\r\nint pcap_to_irq(struct pcap_chip *pcap, int irq)\r\n{\r\nreturn pcap->irq_base + irq;\r\n}\r\nstatic void pcap_mask_irq(struct irq_data *d)\r\n{\r\nstruct pcap_chip *pcap = irq_data_get_irq_chip_data(d);\r\npcap->msr |= 1 << irq_to_pcap(pcap, d->irq);\r\nqueue_work(pcap->workqueue, &pcap->msr_work);\r\n}\r\nstatic void pcap_unmask_irq(struct irq_data *d)\r\n{\r\nstruct pcap_chip *pcap = irq_data_get_irq_chip_data(d);\r\npcap->msr &= ~(1 << irq_to_pcap(pcap, d->irq));\r\nqueue_work(pcap->workqueue, &pcap->msr_work);\r\n}\r\nstatic void pcap_msr_work(struct work_struct *work)\r\n{\r\nstruct pcap_chip *pcap = container_of(work, struct pcap_chip, msr_work);\r\nezx_pcap_write(pcap, PCAP_REG_MSR, pcap->msr);\r\n}\r\nstatic void pcap_isr_work(struct work_struct *work)\r\n{\r\nstruct pcap_chip *pcap = container_of(work, struct pcap_chip, isr_work);\r\nstruct pcap_platform_data *pdata = pcap->spi->dev.platform_data;\r\nu32 msr, isr, int_sel, service;\r\nint irq;\r\ndo {\r\nezx_pcap_read(pcap, PCAP_REG_MSR, &msr);\r\nezx_pcap_read(pcap, PCAP_REG_ISR, &isr);\r\nif (!(pdata->config & PCAP_SECOND_PORT)) {\r\nezx_pcap_read(pcap, PCAP_REG_INT_SEL, &int_sel);\r\nisr &= ~int_sel;\r\n}\r\nezx_pcap_write(pcap, PCAP_REG_MSR, isr | msr);\r\nezx_pcap_write(pcap, PCAP_REG_ISR, isr);\r\nlocal_irq_disable();\r\nservice = isr & ~msr;\r\nfor (irq = pcap->irq_base; service; service >>= 1, irq++) {\r\nif (service & 1)\r\ngeneric_handle_irq(irq);\r\n}\r\nlocal_irq_enable();\r\nezx_pcap_write(pcap, PCAP_REG_MSR, pcap->msr);\r\n} while (gpio_get_value(irq_to_gpio(pcap->spi->irq)));\r\n}\r\nstatic void pcap_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct pcap_chip *pcap = irq_get_handler_data(irq);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nqueue_work(pcap->workqueue, &pcap->isr_work);\r\nreturn;\r\n}\r\nvoid pcap_set_ts_bits(struct pcap_chip *pcap, u32 bits)\r\n{\r\nu32 tmp;\r\nmutex_lock(&pcap->adc_mutex);\r\nezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\r\ntmp &= ~(PCAP_ADC_TS_M_MASK | PCAP_ADC_TS_REF_LOWPWR);\r\ntmp |= bits & (PCAP_ADC_TS_M_MASK | PCAP_ADC_TS_REF_LOWPWR);\r\nezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\r\nmutex_unlock(&pcap->adc_mutex);\r\n}\r\nstatic void pcap_disable_adc(struct pcap_chip *pcap)\r\n{\r\nu32 tmp;\r\nezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\r\ntmp &= ~(PCAP_ADC_ADEN|PCAP_ADC_BATT_I_ADC|PCAP_ADC_BATT_I_POLARITY);\r\nezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\r\n}\r\nstatic void pcap_adc_trigger(struct pcap_chip *pcap)\r\n{\r\nu32 tmp;\r\nu8 head;\r\nmutex_lock(&pcap->adc_mutex);\r\nhead = pcap->adc_head;\r\nif (!pcap->adc_queue[head]) {\r\npcap_disable_adc(pcap);\r\nmutex_unlock(&pcap->adc_mutex);\r\nreturn;\r\n}\r\nezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\r\ntmp &= (PCAP_ADC_TS_M_MASK | PCAP_ADC_TS_REF_LOWPWR);\r\ntmp |= pcap->adc_queue[head]->flags | PCAP_ADC_ADEN;\r\nif (pcap->adc_queue[head]->bank == PCAP_ADC_BANK_1)\r\ntmp |= PCAP_ADC_AD_SEL1;\r\nezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\r\nmutex_unlock(&pcap->adc_mutex);\r\nezx_pcap_write(pcap, PCAP_REG_ADR, PCAP_ADR_ASC);\r\n}\r\nstatic irqreturn_t pcap_adc_irq(int irq, void *_pcap)\r\n{\r\nstruct pcap_chip *pcap = _pcap;\r\nstruct pcap_adc_request *req;\r\nu16 res[2];\r\nu32 tmp;\r\nmutex_lock(&pcap->adc_mutex);\r\nreq = pcap->adc_queue[pcap->adc_head];\r\nif (WARN(!req, "adc irq without pending request\n")) {\r\nmutex_unlock(&pcap->adc_mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nezx_pcap_read(pcap, PCAP_REG_ADC, &tmp);\r\ntmp &= ~(PCAP_ADC_ADA1_MASK | PCAP_ADC_ADA2_MASK);\r\ntmp |= (req->ch[0] << PCAP_ADC_ADA1_SHIFT);\r\ntmp |= (req->ch[1] << PCAP_ADC_ADA2_SHIFT);\r\nezx_pcap_write(pcap, PCAP_REG_ADC, tmp);\r\nezx_pcap_read(pcap, PCAP_REG_ADR, &tmp);\r\nres[0] = (tmp & PCAP_ADR_ADD1_MASK) >> PCAP_ADR_ADD1_SHIFT;\r\nres[1] = (tmp & PCAP_ADR_ADD2_MASK) >> PCAP_ADR_ADD2_SHIFT;\r\npcap->adc_queue[pcap->adc_head] = NULL;\r\npcap->adc_head = (pcap->adc_head + 1) & (PCAP_ADC_MAXQ - 1);\r\nmutex_unlock(&pcap->adc_mutex);\r\nreq->callback(req->data, res);\r\nkfree(req);\r\npcap_adc_trigger(pcap);\r\nreturn IRQ_HANDLED;\r\n}\r\nint pcap_adc_async(struct pcap_chip *pcap, u8 bank, u32 flags, u8 ch[],\r\nvoid *callback, void *data)\r\n{\r\nstruct pcap_adc_request *req;\r\nreq = kmalloc(sizeof(struct pcap_adc_request), GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->bank = bank;\r\nreq->flags = flags;\r\nreq->ch[0] = ch[0];\r\nreq->ch[1] = ch[1];\r\nreq->callback = callback;\r\nreq->data = data;\r\nmutex_lock(&pcap->adc_mutex);\r\nif (pcap->adc_queue[pcap->adc_tail]) {\r\nmutex_unlock(&pcap->adc_mutex);\r\nkfree(req);\r\nreturn -EBUSY;\r\n}\r\npcap->adc_queue[pcap->adc_tail] = req;\r\npcap->adc_tail = (pcap->adc_tail + 1) & (PCAP_ADC_MAXQ - 1);\r\nmutex_unlock(&pcap->adc_mutex);\r\npcap_adc_trigger(pcap);\r\nreturn 0;\r\n}\r\nstatic void pcap_adc_sync_cb(void *param, u16 res[])\r\n{\r\nstruct pcap_adc_sync_request *req = param;\r\nreq->res[0] = res[0];\r\nreq->res[1] = res[1];\r\ncomplete(&req->completion);\r\n}\r\nint pcap_adc_sync(struct pcap_chip *pcap, u8 bank, u32 flags, u8 ch[],\r\nu16 res[])\r\n{\r\nstruct pcap_adc_sync_request sync_data;\r\nint ret;\r\ninit_completion(&sync_data.completion);\r\nret = pcap_adc_async(pcap, bank, flags, ch, pcap_adc_sync_cb,\r\n&sync_data);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&sync_data.completion);\r\nres[0] = sync_data.res[0];\r\nres[1] = sync_data.res[1];\r\nreturn 0;\r\n}\r\nstatic int pcap_remove_subdev(struct device *dev, void *unused)\r\n{\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic int __devinit pcap_add_subdev(struct pcap_chip *pcap,\r\nstruct pcap_subdev *subdev)\r\n{\r\nstruct platform_device *pdev;\r\nint ret;\r\npdev = platform_device_alloc(subdev->name, subdev->id);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\npdev->dev.parent = &pcap->spi->dev;\r\npdev->dev.platform_data = subdev->platform_data;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\nplatform_device_put(pdev);\r\nreturn ret;\r\n}\r\nstatic int __devexit ezx_pcap_remove(struct spi_device *spi)\r\n{\r\nstruct pcap_chip *pcap = dev_get_drvdata(&spi->dev);\r\nstruct pcap_platform_data *pdata = spi->dev.platform_data;\r\nint i, adc_irq;\r\ndevice_for_each_child(&spi->dev, NULL, pcap_remove_subdev);\r\nadc_irq = pcap_to_irq(pcap, (pdata->config & PCAP_SECOND_PORT) ?\r\nPCAP_IRQ_ADCDONE2 : PCAP_IRQ_ADCDONE);\r\nfree_irq(adc_irq, pcap);\r\nmutex_lock(&pcap->adc_mutex);\r\nfor (i = 0; i < PCAP_ADC_MAXQ; i++)\r\nkfree(pcap->adc_queue[i]);\r\nmutex_unlock(&pcap->adc_mutex);\r\nfor (i = pcap->irq_base; i < (pcap->irq_base + PCAP_NIRQS); i++)\r\nirq_set_chip_and_handler(i, NULL, NULL);\r\ndestroy_workqueue(pcap->workqueue);\r\nkfree(pcap);\r\nreturn 0;\r\n}\r\nstatic int __devinit ezx_pcap_probe(struct spi_device *spi)\r\n{\r\nstruct pcap_platform_data *pdata = spi->dev.platform_data;\r\nstruct pcap_chip *pcap;\r\nint i, adc_irq;\r\nint ret = -ENODEV;\r\nif (!pdata)\r\ngoto ret;\r\npcap = kzalloc(sizeof(*pcap), GFP_KERNEL);\r\nif (!pcap) {\r\nret = -ENOMEM;\r\ngoto ret;\r\n}\r\nmutex_init(&pcap->io_mutex);\r\nmutex_init(&pcap->adc_mutex);\r\nINIT_WORK(&pcap->isr_work, pcap_isr_work);\r\nINIT_WORK(&pcap->msr_work, pcap_msr_work);\r\ndev_set_drvdata(&spi->dev, pcap);\r\nspi->bits_per_word = 32;\r\nspi->mode = SPI_MODE_0 | (pdata->config & PCAP_CS_AH ? SPI_CS_HIGH : 0);\r\nret = spi_setup(spi);\r\nif (ret)\r\ngoto free_pcap;\r\npcap->spi = spi;\r\npcap->irq_base = pdata->irq_base;\r\npcap->workqueue = create_singlethread_workqueue("pcapd");\r\nif (!pcap->workqueue) {\r\nret = -ENOMEM;\r\ndev_err(&spi->dev, "can't create pcap thread\n");\r\ngoto free_pcap;\r\n}\r\nif (!(pdata->config & PCAP_SECOND_PORT))\r\nezx_pcap_write(pcap, PCAP_REG_INT_SEL,\r\n(1 << PCAP_IRQ_ADCDONE2));\r\nfor (i = pcap->irq_base; i < (pcap->irq_base + PCAP_NIRQS); i++) {\r\nirq_set_chip_and_handler(i, &pcap_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(i, pcap);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(i, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(i);\r\n#endif\r\n}\r\nezx_pcap_write(pcap, PCAP_REG_MSR, PCAP_MASK_ALL_INTERRUPT);\r\nezx_pcap_write(pcap, PCAP_REG_ISR, PCAP_CLEAR_INTERRUPT_REGISTER);\r\npcap->msr = PCAP_MASK_ALL_INTERRUPT;\r\nirq_set_irq_type(spi->irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_handler_data(spi->irq, pcap);\r\nirq_set_chained_handler(spi->irq, pcap_irq_handler);\r\nirq_set_irq_wake(spi->irq, 1);\r\nadc_irq = pcap_to_irq(pcap, (pdata->config & PCAP_SECOND_PORT) ?\r\nPCAP_IRQ_ADCDONE2 : PCAP_IRQ_ADCDONE);\r\nret = request_irq(adc_irq, pcap_adc_irq, 0, "ADC", pcap);\r\nif (ret)\r\ngoto free_irqchip;\r\nfor (i = 0; i < pdata->num_subdevs; i++) {\r\nret = pcap_add_subdev(pcap, &pdata->subdevs[i]);\r\nif (ret)\r\ngoto remove_subdevs;\r\n}\r\nif (pdata->init)\r\npdata->init(pcap);\r\nreturn 0;\r\nremove_subdevs:\r\ndevice_for_each_child(&spi->dev, NULL, pcap_remove_subdev);\r\nfree_irq(adc_irq, pcap);\r\nfree_irqchip:\r\nfor (i = pcap->irq_base; i < (pcap->irq_base + PCAP_NIRQS); i++)\r\nirq_set_chip_and_handler(i, NULL, NULL);\r\ndestroy_workqueue(pcap->workqueue);\r\nfree_pcap:\r\nkfree(pcap);\r\nret:\r\nreturn ret;\r\n}\r\nstatic int __init ezx_pcap_init(void)\r\n{\r\nreturn spi_register_driver(&ezxpcap_driver);\r\n}\r\nstatic void __exit ezx_pcap_exit(void)\r\n{\r\nspi_unregister_driver(&ezxpcap_driver);\r\n}
