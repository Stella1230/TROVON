struct arm_vmregion *\r\narm_vmregion_alloc(struct arm_vmregion_head *head, size_t align,\r\nsize_t size, gfp_t gfp, const void *caller)\r\n{\r\nunsigned long start = head->vm_start, addr = head->vm_end;\r\nunsigned long flags;\r\nstruct arm_vmregion *c, *new;\r\nif (head->vm_end - head->vm_start < size) {\r\nprintk(KERN_WARNING "%s: allocation too big (requested %#x)\n",\r\n__func__, size);\r\ngoto out;\r\n}\r\nnew = kmalloc(sizeof(struct arm_vmregion), gfp);\r\nif (!new)\r\ngoto out;\r\nnew->caller = caller;\r\nspin_lock_irqsave(&head->vm_lock, flags);\r\naddr = rounddown(addr - size, align);\r\nlist_for_each_entry_reverse(c, &head->vm_list, vm_list) {\r\nif (addr >= c->vm_end)\r\ngoto found;\r\naddr = rounddown(c->vm_start - size, align);\r\nif (addr < start)\r\ngoto nospc;\r\n}\r\nfound:\r\nlist_add(&new->vm_list, &c->vm_list);\r\nnew->vm_start = addr;\r\nnew->vm_end = addr + size;\r\nnew->vm_active = 1;\r\nspin_unlock_irqrestore(&head->vm_lock, flags);\r\nreturn new;\r\nnospc:\r\nspin_unlock_irqrestore(&head->vm_lock, flags);\r\nkfree(new);\r\nout:\r\nreturn NULL;\r\n}\r\nstatic struct arm_vmregion *__arm_vmregion_find(struct arm_vmregion_head *head, unsigned long addr)\r\n{\r\nstruct arm_vmregion *c;\r\nlist_for_each_entry(c, &head->vm_list, vm_list) {\r\nif (c->vm_active && c->vm_start == addr)\r\ngoto out;\r\n}\r\nc = NULL;\r\nout:\r\nreturn c;\r\n}\r\nstruct arm_vmregion *arm_vmregion_find(struct arm_vmregion_head *head, unsigned long addr)\r\n{\r\nstruct arm_vmregion *c;\r\nunsigned long flags;\r\nspin_lock_irqsave(&head->vm_lock, flags);\r\nc = __arm_vmregion_find(head, addr);\r\nspin_unlock_irqrestore(&head->vm_lock, flags);\r\nreturn c;\r\n}\r\nstruct arm_vmregion *arm_vmregion_find_remove(struct arm_vmregion_head *head, unsigned long addr)\r\n{\r\nstruct arm_vmregion *c;\r\nunsigned long flags;\r\nspin_lock_irqsave(&head->vm_lock, flags);\r\nc = __arm_vmregion_find(head, addr);\r\nif (c)\r\nc->vm_active = 0;\r\nspin_unlock_irqrestore(&head->vm_lock, flags);\r\nreturn c;\r\n}\r\nvoid arm_vmregion_free(struct arm_vmregion_head *head, struct arm_vmregion *c)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&head->vm_lock, flags);\r\nlist_del(&c->vm_list);\r\nspin_unlock_irqrestore(&head->vm_lock, flags);\r\nkfree(c);\r\n}\r\nstatic int arm_vmregion_show(struct seq_file *m, void *p)\r\n{\r\nstruct arm_vmregion *c = list_entry(p, struct arm_vmregion, vm_list);\r\nseq_printf(m, "0x%08lx-0x%08lx %7lu", c->vm_start, c->vm_end,\r\nc->vm_end - c->vm_start);\r\nif (c->caller)\r\nseq_printf(m, " %pS", (void *)c->caller);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void *arm_vmregion_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct arm_vmregion_head *h = m->private;\r\nspin_lock_irq(&h->vm_lock);\r\nreturn seq_list_start(&h->vm_list, *pos);\r\n}\r\nstatic void *arm_vmregion_next(struct seq_file *m, void *p, loff_t *pos)\r\n{\r\nstruct arm_vmregion_head *h = m->private;\r\nreturn seq_list_next(p, &h->vm_list, pos);\r\n}\r\nstatic void arm_vmregion_stop(struct seq_file *m, void *p)\r\n{\r\nstruct arm_vmregion_head *h = m->private;\r\nspin_unlock_irq(&h->vm_lock);\r\n}\r\nstatic int arm_vmregion_open(struct inode *inode, struct file *file)\r\n{\r\nstruct arm_vmregion_head *h = PDE(inode)->data;\r\nint ret = seq_open(file, &arm_vmregion_ops);\r\nif (!ret) {\r\nstruct seq_file *m = file->private_data;\r\nm->private = h;\r\n}\r\nreturn ret;\r\n}\r\nint arm_vmregion_create_proc(const char *path, struct arm_vmregion_head *h)\r\n{\r\nproc_create_data(path, S_IRUSR, NULL, &arm_vmregion_fops, h);\r\nreturn 0;\r\n}\r\nint arm_vmregion_create_proc(const char *path, struct arm_vmregion_head *h)\r\n{\r\nreturn 0;\r\n}
