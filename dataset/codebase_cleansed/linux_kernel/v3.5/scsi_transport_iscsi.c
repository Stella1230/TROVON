static void iscsi_transport_release(struct device *dev)\r\n{\r\nstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\r\nkfree(priv);\r\n}\r\nstatic ssize_t\r\nshow_transport_handle(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\r\nreturn sprintf(buf, "%llu\n", (unsigned long long)iscsi_handle(priv->iscsi_transport));\r\n}\r\nstatic void iscsi_endpoint_release(struct device *dev)\r\n{\r\nstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\r\nkfree(ep);\r\n}\r\nstatic ssize_t\r\nshow_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\r\nreturn sprintf(buf, "%llu\n", (unsigned long long) ep->id);\r\n}\r\nstatic int iscsi_match_epid(struct device *dev, void *data)\r\n{\r\nstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\r\nuint64_t *epid = (uint64_t *) data;\r\nreturn *epid == ep->id;\r\n}\r\nstruct iscsi_endpoint *\r\niscsi_create_endpoint(int dd_size)\r\n{\r\nstruct device *dev;\r\nstruct iscsi_endpoint *ep;\r\nuint64_t id;\r\nint err;\r\nfor (id = 1; id < ISCSI_MAX_EPID; id++) {\r\ndev = class_find_device(&iscsi_endpoint_class, NULL, &id,\r\niscsi_match_epid);\r\nif (!dev)\r\nbreak;\r\n}\r\nif (id == ISCSI_MAX_EPID) {\r\nprintk(KERN_ERR "Too many connections. Max supported %u\n",\r\nISCSI_MAX_EPID - 1);\r\nreturn NULL;\r\n}\r\nep = kzalloc(sizeof(*ep) + dd_size, GFP_KERNEL);\r\nif (!ep)\r\nreturn NULL;\r\nep->id = id;\r\nep->dev.class = &iscsi_endpoint_class;\r\ndev_set_name(&ep->dev, "ep-%llu", (unsigned long long) id);\r\nerr = device_register(&ep->dev);\r\nif (err)\r\ngoto free_ep;\r\nerr = sysfs_create_group(&ep->dev.kobj, &iscsi_endpoint_group);\r\nif (err)\r\ngoto unregister_dev;\r\nif (dd_size)\r\nep->dd_data = &ep[1];\r\nreturn ep;\r\nunregister_dev:\r\ndevice_unregister(&ep->dev);\r\nreturn NULL;\r\nfree_ep:\r\nkfree(ep);\r\nreturn NULL;\r\n}\r\nvoid iscsi_destroy_endpoint(struct iscsi_endpoint *ep)\r\n{\r\nsysfs_remove_group(&ep->dev.kobj, &iscsi_endpoint_group);\r\ndevice_unregister(&ep->dev);\r\n}\r\nstruct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle)\r\n{\r\nstruct iscsi_endpoint *ep;\r\nstruct device *dev;\r\ndev = class_find_device(&iscsi_endpoint_class, NULL, &handle,\r\niscsi_match_epid);\r\nif (!dev)\r\nreturn NULL;\r\nep = iscsi_dev_to_endpoint(dev);\r\nput_device(dev);\r\nreturn ep;\r\n}\r\nstatic void iscsi_iface_release(struct device *dev)\r\n{\r\nstruct iscsi_iface *iface = iscsi_dev_to_iface(dev);\r\nstruct device *parent = iface->dev.parent;\r\nkfree(iface);\r\nput_device(parent);\r\n}\r\nstatic umode_t iscsi_iface_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct iscsi_iface *iface = iscsi_dev_to_iface(dev);\r\nstruct iscsi_transport *t = iface->transport;\r\nint param;\r\nif (attr == &dev_attr_iface_enabled.attr)\r\nparam = ISCSI_NET_PARAM_IFACE_ENABLE;\r\nelse if (attr == &dev_attr_iface_vlan_id.attr)\r\nparam = ISCSI_NET_PARAM_VLAN_ID;\r\nelse if (attr == &dev_attr_iface_vlan_priority.attr)\r\nparam = ISCSI_NET_PARAM_VLAN_PRIORITY;\r\nelse if (attr == &dev_attr_iface_vlan_enabled.attr)\r\nparam = ISCSI_NET_PARAM_VLAN_ENABLED;\r\nelse if (attr == &dev_attr_iface_mtu.attr)\r\nparam = ISCSI_NET_PARAM_MTU;\r\nelse if (attr == &dev_attr_iface_port.attr)\r\nparam = ISCSI_NET_PARAM_PORT;\r\nelse if (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\r\nif (attr == &dev_attr_ipv4_iface_ipaddress.attr)\r\nparam = ISCSI_NET_PARAM_IPV4_ADDR;\r\nelse if (attr == &dev_attr_ipv4_iface_gateway.attr)\r\nparam = ISCSI_NET_PARAM_IPV4_GW;\r\nelse if (attr == &dev_attr_ipv4_iface_subnet.attr)\r\nparam = ISCSI_NET_PARAM_IPV4_SUBNET;\r\nelse if (attr == &dev_attr_ipv4_iface_bootproto.attr)\r\nparam = ISCSI_NET_PARAM_IPV4_BOOTPROTO;\r\nelse\r\nreturn 0;\r\n} else if (iface->iface_type == ISCSI_IFACE_TYPE_IPV6) {\r\nif (attr == &dev_attr_ipv6_iface_ipaddress.attr)\r\nparam = ISCSI_NET_PARAM_IPV6_ADDR;\r\nelse if (attr == &dev_attr_ipv6_iface_link_local_addr.attr)\r\nparam = ISCSI_NET_PARAM_IPV6_LINKLOCAL;\r\nelse if (attr == &dev_attr_ipv6_iface_router_addr.attr)\r\nparam = ISCSI_NET_PARAM_IPV6_ROUTER;\r\nelse if (attr == &dev_attr_ipv6_iface_ipaddr_autocfg.attr)\r\nparam = ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG;\r\nelse if (attr == &dev_attr_ipv6_iface_link_local_autocfg.attr)\r\nparam = ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG;\r\nelse\r\nreturn 0;\r\n} else {\r\nWARN_ONCE(1, "Invalid iface attr");\r\nreturn 0;\r\n}\r\nreturn t->attr_is_visible(ISCSI_NET_PARAM, param);\r\n}\r\nstruct iscsi_iface *\r\niscsi_create_iface(struct Scsi_Host *shost, struct iscsi_transport *transport,\r\nuint32_t iface_type, uint32_t iface_num, int dd_size)\r\n{\r\nstruct iscsi_iface *iface;\r\nint err;\r\niface = kzalloc(sizeof(*iface) + dd_size, GFP_KERNEL);\r\nif (!iface)\r\nreturn NULL;\r\niface->transport = transport;\r\niface->iface_type = iface_type;\r\niface->iface_num = iface_num;\r\niface->dev.release = iscsi_iface_release;\r\niface->dev.class = &iscsi_iface_class;\r\niface->dev.parent = get_device(&shost->shost_gendev);\r\nif (iface_type == ISCSI_IFACE_TYPE_IPV4)\r\ndev_set_name(&iface->dev, "ipv4-iface-%u-%u", shost->host_no,\r\niface_num);\r\nelse\r\ndev_set_name(&iface->dev, "ipv6-iface-%u-%u", shost->host_no,\r\niface_num);\r\nerr = device_register(&iface->dev);\r\nif (err)\r\ngoto free_iface;\r\nerr = sysfs_create_group(&iface->dev.kobj, &iscsi_iface_group);\r\nif (err)\r\ngoto unreg_iface;\r\nif (dd_size)\r\niface->dd_data = &iface[1];\r\nreturn iface;\r\nunreg_iface:\r\ndevice_unregister(&iface->dev);\r\nreturn NULL;\r\nfree_iface:\r\nput_device(iface->dev.parent);\r\nkfree(iface);\r\nreturn NULL;\r\n}\r\nvoid iscsi_destroy_iface(struct iscsi_iface *iface)\r\n{\r\nsysfs_remove_group(&iface->dev.kobj, &iscsi_iface_group);\r\ndevice_unregister(&iface->dev);\r\n}\r\nstatic int iscsi_bsg_host_dispatch(struct bsg_job *job)\r\n{\r\nstruct Scsi_Host *shost = iscsi_job_to_shost(job);\r\nstruct iscsi_bsg_request *req = job->request;\r\nstruct iscsi_bsg_reply *reply = job->reply;\r\nstruct iscsi_internal *i = to_iscsi_internal(shost->transportt);\r\nint cmdlen = sizeof(uint32_t);\r\nint ret;\r\nif (job->request_len < sizeof(uint32_t)) {\r\nret = -ENOMSG;\r\ngoto fail_host_msg;\r\n}\r\nswitch (req->msgcode) {\r\ncase ISCSI_BSG_HST_VENDOR:\r\ncmdlen += sizeof(struct iscsi_bsg_host_vendor);\r\nif ((shost->hostt->vendor_id == 0L) ||\r\n(req->rqst_data.h_vendor.vendor_id !=\r\nshost->hostt->vendor_id)) {\r\nret = -ESRCH;\r\ngoto fail_host_msg;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EBADR;\r\ngoto fail_host_msg;\r\n}\r\nif (job->request_len < cmdlen) {\r\nret = -ENOMSG;\r\ngoto fail_host_msg;\r\n}\r\nret = i->iscsi_transport->bsg_request(job);\r\nif (!ret)\r\nreturn 0;\r\nfail_host_msg:\r\nBUG_ON(job->reply_len < sizeof(uint32_t));\r\nreply->reply_payload_rcv_len = 0;\r\nreply->result = ret;\r\njob->reply_len = sizeof(uint32_t);\r\nbsg_job_done(job, ret, 0);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_bsg_host_add(struct Scsi_Host *shost, struct iscsi_cls_host *ihost)\r\n{\r\nstruct device *dev = &shost->shost_gendev;\r\nstruct iscsi_internal *i = to_iscsi_internal(shost->transportt);\r\nstruct request_queue *q;\r\nchar bsg_name[20];\r\nint ret;\r\nif (!i->iscsi_transport->bsg_request)\r\nreturn -ENOTSUPP;\r\nsnprintf(bsg_name, sizeof(bsg_name), "iscsi_host%d", shost->host_no);\r\nq = __scsi_alloc_queue(shost, bsg_request_fn);\r\nif (!q)\r\nreturn -ENOMEM;\r\nret = bsg_setup_queue(dev, q, bsg_name, iscsi_bsg_host_dispatch, 0);\r\nif (ret) {\r\nshost_printk(KERN_ERR, shost, "bsg interface failed to "\r\n"initialize - no request queue\n");\r\nblk_cleanup_queue(q);\r\nreturn ret;\r\n}\r\nihost->bsg_q = q;\r\nreturn 0;\r\n}\r\nstatic int iscsi_setup_host(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nmemset(ihost, 0, sizeof(*ihost));\r\natomic_set(&ihost->nr_scans, 0);\r\nmutex_init(&ihost->mutex);\r\niscsi_bsg_host_add(shost, ihost);\r\nreturn 0;\r\n}\r\nstatic int iscsi_remove_host(struct transport_container *tc,\r\nstruct device *dev, struct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nif (ihost->bsg_q) {\r\nbsg_remove_queue(ihost->bsg_q);\r\nblk_cleanup_queue(ihost->bsg_q);\r\n}\r\nreturn 0;\r\n}\r\nstatic uint32_t iscsi_conn_get_sid(struct iscsi_cls_conn *conn)\r\n{\r\nstruct iscsi_cls_session *sess = iscsi_dev_to_session(conn->dev.parent);\r\nreturn sess->sid;\r\n}\r\nstatic struct iscsi_cls_session *iscsi_session_lookup(uint32_t sid)\r\n{\r\nunsigned long flags;\r\nstruct iscsi_cls_session *sess;\r\nspin_lock_irqsave(&sesslock, flags);\r\nlist_for_each_entry(sess, &sesslist, sess_list) {\r\nif (sess->sid == sid) {\r\nspin_unlock_irqrestore(&sesslock, flags);\r\nreturn sess;\r\n}\r\n}\r\nspin_unlock_irqrestore(&sesslock, flags);\r\nreturn NULL;\r\n}\r\nstatic struct iscsi_cls_conn *iscsi_conn_lookup(uint32_t sid, uint32_t cid)\r\n{\r\nunsigned long flags;\r\nstruct iscsi_cls_conn *conn;\r\nspin_lock_irqsave(&connlock, flags);\r\nlist_for_each_entry(conn, &connlist, conn_list) {\r\nif ((conn->cid == cid) && (iscsi_conn_get_sid(conn) == sid)) {\r\nspin_unlock_irqrestore(&connlock, flags);\r\nreturn conn;\r\n}\r\n}\r\nspin_unlock_irqrestore(&connlock, flags);\r\nreturn NULL;\r\n}\r\nstatic const char *iscsi_session_state_name(int state)\r\n{\r\nint i;\r\nchar *name = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(iscsi_session_state_names); i++) {\r\nif (iscsi_session_state_names[i].value == state) {\r\nname = iscsi_session_state_names[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn name;\r\n}\r\nint iscsi_session_chkready(struct iscsi_cls_session *session)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&session->lock, flags);\r\nswitch (session->state) {\r\ncase ISCSI_SESSION_LOGGED_IN:\r\nerr = 0;\r\nbreak;\r\ncase ISCSI_SESSION_FAILED:\r\nerr = DID_IMM_RETRY << 16;\r\nbreak;\r\ncase ISCSI_SESSION_FREE:\r\nerr = DID_TRANSPORT_FAILFAST << 16;\r\nbreak;\r\ndefault:\r\nerr = DID_NO_CONNECT << 16;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nreturn err;\r\n}\r\nint iscsi_is_session_online(struct iscsi_cls_session *session)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&session->lock, flags);\r\nif (session->state == ISCSI_SESSION_LOGGED_IN)\r\nret = 1;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void iscsi_session_release(struct device *dev)\r\n{\r\nstruct iscsi_cls_session *session = iscsi_dev_to_session(dev);\r\nstruct Scsi_Host *shost;\r\nshost = iscsi_session_to_shost(session);\r\nscsi_host_put(shost);\r\nISCSI_DBG_TRANS_SESSION(session, "Completing session release\n");\r\nkfree(session);\r\n}\r\nint iscsi_is_session_dev(const struct device *dev)\r\n{\r\nreturn dev->release == iscsi_session_release;\r\n}\r\nstatic int iscsi_iter_session_fn(struct device *dev, void *data)\r\n{\r\nvoid (* fn) (struct iscsi_cls_session *) = data;\r\nif (!iscsi_is_session_dev(dev))\r\nreturn 0;\r\nfn(iscsi_dev_to_session(dev));\r\nreturn 0;\r\n}\r\nvoid iscsi_host_for_each_session(struct Scsi_Host *shost,\r\nvoid (*fn)(struct iscsi_cls_session *))\r\n{\r\ndevice_for_each_child(&shost->shost_gendev, fn,\r\niscsi_iter_session_fn);\r\n}\r\nint iscsi_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nreturn !atomic_read(&ihost->nr_scans);\r\n}\r\nstatic int iscsi_user_scan_session(struct device *dev, void *data)\r\n{\r\nstruct iscsi_scan_data *scan_data = data;\r\nstruct iscsi_cls_session *session;\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_cls_host *ihost;\r\nunsigned long flags;\r\nunsigned int id;\r\nif (!iscsi_is_session_dev(dev))\r\nreturn 0;\r\nsession = iscsi_dev_to_session(dev);\r\nISCSI_DBG_TRANS_SESSION(session, "Scanning session\n");\r\nshost = iscsi_session_to_shost(session);\r\nihost = shost->shost_data;\r\nmutex_lock(&ihost->mutex);\r\nspin_lock_irqsave(&session->lock, flags);\r\nif (session->state != ISCSI_SESSION_LOGGED_IN) {\r\nspin_unlock_irqrestore(&session->lock, flags);\r\ngoto user_scan_exit;\r\n}\r\nid = session->target_id;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nif (id != ISCSI_MAX_TARGET) {\r\nif ((scan_data->channel == SCAN_WILD_CARD ||\r\nscan_data->channel == 0) &&\r\n(scan_data->id == SCAN_WILD_CARD ||\r\nscan_data->id == id))\r\nscsi_scan_target(&session->dev, 0, id,\r\nscan_data->lun, 1);\r\n}\r\nuser_scan_exit:\r\nmutex_unlock(&ihost->mutex);\r\nISCSI_DBG_TRANS_SESSION(session, "Completed session scan\n");\r\nreturn 0;\r\n}\r\nstatic int iscsi_user_scan(struct Scsi_Host *shost, uint channel,\r\nuint id, uint lun)\r\n{\r\nstruct iscsi_scan_data scan_data;\r\nscan_data.channel = channel;\r\nscan_data.id = id;\r\nscan_data.lun = lun;\r\nreturn device_for_each_child(&shost->shost_gendev, &scan_data,\r\niscsi_user_scan_session);\r\n}\r\nstatic void iscsi_scan_session(struct work_struct *work)\r\n{\r\nstruct iscsi_cls_session *session =\r\ncontainer_of(work, struct iscsi_cls_session, scan_work);\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(session);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nstruct iscsi_scan_data scan_data;\r\nscan_data.channel = 0;\r\nscan_data.id = SCAN_WILD_CARD;\r\nscan_data.lun = SCAN_WILD_CARD;\r\niscsi_user_scan_session(&session->dev, &scan_data);\r\natomic_dec(&ihost->nr_scans);\r\n}\r\nint iscsi_block_scsi_eh(struct scsi_cmnd *cmd)\r\n{\r\nstruct iscsi_cls_session *session =\r\nstarget_to_session(scsi_target(cmd->device));\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&session->lock, flags);\r\nwhile (session->state != ISCSI_SESSION_LOGGED_IN) {\r\nif (session->state == ISCSI_SESSION_FREE) {\r\nret = FAST_IO_FAIL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nmsleep(1000);\r\nspin_lock_irqsave(&session->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void session_recovery_timedout(struct work_struct *work)\r\n{\r\nstruct iscsi_cls_session *session =\r\ncontainer_of(work, struct iscsi_cls_session,\r\nrecovery_work.work);\r\nunsigned long flags;\r\niscsi_cls_session_printk(KERN_INFO, session,\r\n"session recovery timed out after %d secs\n",\r\nsession->recovery_tmo);\r\nspin_lock_irqsave(&session->lock, flags);\r\nswitch (session->state) {\r\ncase ISCSI_SESSION_FAILED:\r\nsession->state = ISCSI_SESSION_FREE;\r\nbreak;\r\ncase ISCSI_SESSION_LOGGED_IN:\r\ncase ISCSI_SESSION_FREE:\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nif (session->transport->session_recovery_timedout)\r\nsession->transport->session_recovery_timedout(session);\r\nISCSI_DBG_TRANS_SESSION(session, "Unblocking SCSI target\n");\r\nscsi_target_unblock(&session->dev);\r\nISCSI_DBG_TRANS_SESSION(session, "Completed unblocking SCSI target\n");\r\n}\r\nstatic void __iscsi_unblock_session(struct work_struct *work)\r\n{\r\nstruct iscsi_cls_session *session =\r\ncontainer_of(work, struct iscsi_cls_session,\r\nunblock_work);\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(session);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nunsigned long flags;\r\nISCSI_DBG_TRANS_SESSION(session, "Unblocking session\n");\r\ncancel_delayed_work(&session->recovery_work);\r\nspin_lock_irqsave(&session->lock, flags);\r\nsession->state = ISCSI_SESSION_LOGGED_IN;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nscsi_target_unblock(&session->dev);\r\nif (shost->hostt->scan_finished) {\r\nif (scsi_queue_work(shost, &session->scan_work))\r\natomic_inc(&ihost->nr_scans);\r\n}\r\nISCSI_DBG_TRANS_SESSION(session, "Completed unblocking session\n");\r\n}\r\nvoid iscsi_unblock_session(struct iscsi_cls_session *session)\r\n{\r\nqueue_work(iscsi_eh_timer_workq, &session->unblock_work);\r\nflush_workqueue(iscsi_eh_timer_workq);\r\n}\r\nstatic void __iscsi_block_session(struct work_struct *work)\r\n{\r\nstruct iscsi_cls_session *session =\r\ncontainer_of(work, struct iscsi_cls_session,\r\nblock_work);\r\nunsigned long flags;\r\nISCSI_DBG_TRANS_SESSION(session, "Blocking session\n");\r\nspin_lock_irqsave(&session->lock, flags);\r\nsession->state = ISCSI_SESSION_FAILED;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nscsi_target_block(&session->dev);\r\nISCSI_DBG_TRANS_SESSION(session, "Completed SCSI target blocking\n");\r\nif (session->recovery_tmo >= 0)\r\nqueue_delayed_work(iscsi_eh_timer_workq,\r\n&session->recovery_work,\r\nsession->recovery_tmo * HZ);\r\n}\r\nvoid iscsi_block_session(struct iscsi_cls_session *session)\r\n{\r\nqueue_work(iscsi_eh_timer_workq, &session->block_work);\r\n}\r\nstatic void __iscsi_unbind_session(struct work_struct *work)\r\n{\r\nstruct iscsi_cls_session *session =\r\ncontainer_of(work, struct iscsi_cls_session,\r\nunbind_work);\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(session);\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nunsigned long flags;\r\nunsigned int target_id;\r\nISCSI_DBG_TRANS_SESSION(session, "Unbinding session\n");\r\nmutex_lock(&ihost->mutex);\r\nspin_lock_irqsave(&session->lock, flags);\r\nif (session->target_id == ISCSI_MAX_TARGET) {\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nmutex_unlock(&ihost->mutex);\r\nreturn;\r\n}\r\ntarget_id = session->target_id;\r\nsession->target_id = ISCSI_MAX_TARGET;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nmutex_unlock(&ihost->mutex);\r\nif (session->ida_used)\r\nida_simple_remove(&iscsi_sess_ida, target_id);\r\nscsi_remove_target(&session->dev);\r\niscsi_session_event(session, ISCSI_KEVENT_UNBIND_SESSION);\r\nISCSI_DBG_TRANS_SESSION(session, "Completed target removal\n");\r\n}\r\nstruct iscsi_cls_session *\r\niscsi_alloc_session(struct Scsi_Host *shost, struct iscsi_transport *transport,\r\nint dd_size)\r\n{\r\nstruct iscsi_cls_session *session;\r\nsession = kzalloc(sizeof(*session) + dd_size,\r\nGFP_KERNEL);\r\nif (!session)\r\nreturn NULL;\r\nsession->transport = transport;\r\nsession->creator = -1;\r\nsession->recovery_tmo = 120;\r\nsession->state = ISCSI_SESSION_FREE;\r\nINIT_DELAYED_WORK(&session->recovery_work, session_recovery_timedout);\r\nINIT_LIST_HEAD(&session->sess_list);\r\nINIT_WORK(&session->unblock_work, __iscsi_unblock_session);\r\nINIT_WORK(&session->block_work, __iscsi_block_session);\r\nINIT_WORK(&session->unbind_work, __iscsi_unbind_session);\r\nINIT_WORK(&session->scan_work, iscsi_scan_session);\r\nspin_lock_init(&session->lock);\r\nscsi_host_get(shost);\r\nsession->dev.parent = &shost->shost_gendev;\r\nsession->dev.release = iscsi_session_release;\r\ndevice_initialize(&session->dev);\r\nif (dd_size)\r\nsession->dd_data = &session[1];\r\nISCSI_DBG_TRANS_SESSION(session, "Completed session allocation\n");\r\nreturn session;\r\n}\r\nint iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)\r\n{\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(session);\r\nstruct iscsi_cls_host *ihost;\r\nunsigned long flags;\r\nint id = 0;\r\nint err;\r\nihost = shost->shost_data;\r\nsession->sid = atomic_add_return(1, &iscsi_session_nr);\r\nif (target_id == ISCSI_MAX_TARGET) {\r\nid = ida_simple_get(&iscsi_sess_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\niscsi_cls_session_printk(KERN_ERR, session,\r\n"Failure in Target ID Allocation\n");\r\nreturn id;\r\n}\r\nsession->target_id = (unsigned int)id;\r\nsession->ida_used = true;\r\n} else\r\nsession->target_id = target_id;\r\ndev_set_name(&session->dev, "session%u", session->sid);\r\nerr = device_add(&session->dev);\r\nif (err) {\r\niscsi_cls_session_printk(KERN_ERR, session,\r\n"could not register session's dev\n");\r\ngoto release_ida;\r\n}\r\ntransport_register_device(&session->dev);\r\nspin_lock_irqsave(&sesslock, flags);\r\nlist_add(&session->sess_list, &sesslist);\r\nspin_unlock_irqrestore(&sesslock, flags);\r\niscsi_session_event(session, ISCSI_KEVENT_CREATE_SESSION);\r\nISCSI_DBG_TRANS_SESSION(session, "Completed session adding\n");\r\nreturn 0;\r\nrelease_ida:\r\nif (session->ida_used)\r\nida_simple_remove(&iscsi_sess_ida, session->target_id);\r\nreturn err;\r\n}\r\nstruct iscsi_cls_session *\r\niscsi_create_session(struct Scsi_Host *shost, struct iscsi_transport *transport,\r\nint dd_size, unsigned int target_id)\r\n{\r\nstruct iscsi_cls_session *session;\r\nsession = iscsi_alloc_session(shost, transport, dd_size);\r\nif (!session)\r\nreturn NULL;\r\nif (iscsi_add_session(session, target_id)) {\r\niscsi_free_session(session);\r\nreturn NULL;\r\n}\r\nreturn session;\r\n}\r\nstatic void iscsi_conn_release(struct device *dev)\r\n{\r\nstruct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);\r\nstruct device *parent = conn->dev.parent;\r\nISCSI_DBG_TRANS_CONN(conn, "Releasing conn\n");\r\nkfree(conn);\r\nput_device(parent);\r\n}\r\nstatic int iscsi_is_conn_dev(const struct device *dev)\r\n{\r\nreturn dev->release == iscsi_conn_release;\r\n}\r\nstatic int iscsi_iter_destroy_conn_fn(struct device *dev, void *data)\r\n{\r\nif (!iscsi_is_conn_dev(dev))\r\nreturn 0;\r\nreturn iscsi_destroy_conn(iscsi_dev_to_conn(dev));\r\n}\r\nvoid iscsi_remove_session(struct iscsi_cls_session *session)\r\n{\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(session);\r\nunsigned long flags;\r\nint err;\r\nISCSI_DBG_TRANS_SESSION(session, "Removing session\n");\r\nspin_lock_irqsave(&sesslock, flags);\r\nlist_del(&session->sess_list);\r\nspin_unlock_irqrestore(&sesslock, flags);\r\nflush_workqueue(iscsi_eh_timer_workq);\r\nif (!cancel_delayed_work(&session->recovery_work))\r\nflush_workqueue(iscsi_eh_timer_workq);\r\nspin_lock_irqsave(&session->lock, flags);\r\nsession->state = ISCSI_SESSION_FREE;\r\nspin_unlock_irqrestore(&session->lock, flags);\r\nscsi_target_unblock(&session->dev);\r\nscsi_flush_work(shost);\r\n__iscsi_unbind_session(&session->unbind_work);\r\nerr = device_for_each_child(&session->dev, NULL,\r\niscsi_iter_destroy_conn_fn);\r\nif (err)\r\niscsi_cls_session_printk(KERN_ERR, session,\r\n"Could not delete all connections "\r\n"for session. Error %d.\n", err);\r\ntransport_unregister_device(&session->dev);\r\nISCSI_DBG_TRANS_SESSION(session, "Completing session removal\n");\r\ndevice_del(&session->dev);\r\n}\r\nvoid iscsi_free_session(struct iscsi_cls_session *session)\r\n{\r\nISCSI_DBG_TRANS_SESSION(session, "Freeing session\n");\r\niscsi_session_event(session, ISCSI_KEVENT_DESTROY_SESSION);\r\nput_device(&session->dev);\r\n}\r\nint iscsi_destroy_session(struct iscsi_cls_session *session)\r\n{\r\niscsi_remove_session(session);\r\nISCSI_DBG_TRANS_SESSION(session, "Completing session destruction\n");\r\niscsi_free_session(session);\r\nreturn 0;\r\n}\r\nstruct iscsi_cls_conn *\r\niscsi_create_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)\r\n{\r\nstruct iscsi_transport *transport = session->transport;\r\nstruct iscsi_cls_conn *conn;\r\nunsigned long flags;\r\nint err;\r\nconn = kzalloc(sizeof(*conn) + dd_size, GFP_KERNEL);\r\nif (!conn)\r\nreturn NULL;\r\nif (dd_size)\r\nconn->dd_data = &conn[1];\r\nmutex_init(&conn->ep_mutex);\r\nINIT_LIST_HEAD(&conn->conn_list);\r\nconn->transport = transport;\r\nconn->cid = cid;\r\nif (!get_device(&session->dev))\r\ngoto free_conn;\r\ndev_set_name(&conn->dev, "connection%d:%u", session->sid, cid);\r\nconn->dev.parent = &session->dev;\r\nconn->dev.release = iscsi_conn_release;\r\nerr = device_register(&conn->dev);\r\nif (err) {\r\niscsi_cls_session_printk(KERN_ERR, session, "could not "\r\n"register connection's dev\n");\r\ngoto release_parent_ref;\r\n}\r\ntransport_register_device(&conn->dev);\r\nspin_lock_irqsave(&connlock, flags);\r\nlist_add(&conn->conn_list, &connlist);\r\nspin_unlock_irqrestore(&connlock, flags);\r\nISCSI_DBG_TRANS_CONN(conn, "Completed conn creation\n");\r\nreturn conn;\r\nrelease_parent_ref:\r\nput_device(&session->dev);\r\nfree_conn:\r\nkfree(conn);\r\nreturn NULL;\r\n}\r\nint iscsi_destroy_conn(struct iscsi_cls_conn *conn)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&connlock, flags);\r\nlist_del(&conn->conn_list);\r\nspin_unlock_irqrestore(&connlock, flags);\r\ntransport_unregister_device(&conn->dev);\r\nISCSI_DBG_TRANS_CONN(conn, "Completing conn destruction\n");\r\ndevice_unregister(&conn->dev);\r\nreturn 0;\r\n}\r\nstatic struct iscsi_internal *\r\niscsi_if_transport_lookup(struct iscsi_transport *tt)\r\n{\r\nstruct iscsi_internal *priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iscsi_transport_lock, flags);\r\nlist_for_each_entry(priv, &iscsi_transports, list) {\r\nif (tt == priv->iscsi_transport) {\r\nspin_unlock_irqrestore(&iscsi_transport_lock, flags);\r\nreturn priv;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iscsi_transport_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic int\r\niscsi_multicast_skb(struct sk_buff *skb, uint32_t group, gfp_t gfp)\r\n{\r\nreturn nlmsg_multicast(nls, skb, 0, group, gfp);\r\n}\r\nint iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,\r\nchar *data, uint32_t data_size)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct iscsi_uevent *ev;\r\nchar *pdu;\r\nstruct iscsi_internal *priv;\r\nint len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iscsi_hdr) +\r\ndata_size);\r\npriv = iscsi_if_transport_lookup(conn->transport);\r\nif (!priv)\r\nreturn -EINVAL;\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb) {\r\niscsi_conn_error_event(conn, ISCSI_ERR_CONN_FAILED);\r\niscsi_cls_conn_printk(KERN_ERR, conn, "can not deliver "\r\n"control PDU: OOM\n");\r\nreturn -ENOMEM;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nmemset(ev, 0, sizeof(*ev));\r\nev->transport_handle = iscsi_handle(conn->transport);\r\nev->type = ISCSI_KEVENT_RECV_PDU;\r\nev->r.recv_req.cid = conn->cid;\r\nev->r.recv_req.sid = iscsi_conn_get_sid(conn);\r\npdu = (char*)ev + sizeof(*ev);\r\nmemcpy(pdu, hdr, sizeof(struct iscsi_hdr));\r\nmemcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);\r\nreturn iscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_ATOMIC);\r\n}\r\nint iscsi_offload_mesg(struct Scsi_Host *shost,\r\nstruct iscsi_transport *transport, uint32_t type,\r\nchar *data, uint16_t data_size)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct iscsi_uevent *ev;\r\nint len = NLMSG_SPACE(sizeof(*ev) + data_size);\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "can not deliver iscsi offload message:OOM\n");\r\nreturn -ENOMEM;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nmemset(ev, 0, sizeof(*ev));\r\nev->type = type;\r\nev->transport_handle = iscsi_handle(transport);\r\nswitch (type) {\r\ncase ISCSI_KEVENT_PATH_REQ:\r\nev->r.req_path.host_no = shost->host_no;\r\nbreak;\r\ncase ISCSI_KEVENT_IF_DOWN:\r\nev->r.notify_if_down.host_no = shost->host_no;\r\nbreak;\r\n}\r\nmemcpy((char *)ev + sizeof(*ev), data, data_size);\r\nreturn iscsi_multicast_skb(skb, ISCSI_NL_GRP_UIP, GFP_ATOMIC);\r\n}\r\nvoid iscsi_conn_error_event(struct iscsi_cls_conn *conn, enum iscsi_err error)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct iscsi_uevent *ev;\r\nstruct iscsi_internal *priv;\r\nint len = NLMSG_SPACE(sizeof(*ev));\r\npriv = iscsi_if_transport_lookup(conn->transport);\r\nif (!priv)\r\nreturn;\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb) {\r\niscsi_cls_conn_printk(KERN_ERR, conn, "gracefully ignored "\r\n"conn error (%d)\n", error);\r\nreturn;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nev->transport_handle = iscsi_handle(conn->transport);\r\nev->type = ISCSI_KEVENT_CONN_ERROR;\r\nev->r.connerror.error = error;\r\nev->r.connerror.cid = conn->cid;\r\nev->r.connerror.sid = iscsi_conn_get_sid(conn);\r\niscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_ATOMIC);\r\niscsi_cls_conn_printk(KERN_INFO, conn, "detected conn error (%d)\n",\r\nerror);\r\n}\r\nvoid iscsi_conn_login_event(struct iscsi_cls_conn *conn,\r\nenum iscsi_conn_state state)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct iscsi_uevent *ev;\r\nstruct iscsi_internal *priv;\r\nint len = NLMSG_SPACE(sizeof(*ev));\r\npriv = iscsi_if_transport_lookup(conn->transport);\r\nif (!priv)\r\nreturn;\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb) {\r\niscsi_cls_conn_printk(KERN_ERR, conn, "gracefully ignored "\r\n"conn login (%d)\n", state);\r\nreturn;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nev->transport_handle = iscsi_handle(conn->transport);\r\nev->type = ISCSI_KEVENT_CONN_LOGIN_STATE;\r\nev->r.conn_login.state = state;\r\nev->r.conn_login.cid = conn->cid;\r\nev->r.conn_login.sid = iscsi_conn_get_sid(conn);\r\niscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_ATOMIC);\r\niscsi_cls_conn_printk(KERN_INFO, conn, "detected conn login (%d)\n",\r\nstate);\r\n}\r\nvoid iscsi_post_host_event(uint32_t host_no, struct iscsi_transport *transport,\r\nenum iscsi_host_event_code code, uint32_t data_size,\r\nuint8_t *data)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct iscsi_uevent *ev;\r\nint len = NLMSG_SPACE(sizeof(*ev) + data_size);\r\nskb = alloc_skb(len, GFP_NOIO);\r\nif (!skb) {\r\nprintk(KERN_ERR "gracefully ignored host event (%d):%d OOM\n",\r\nhost_no, code);\r\nreturn;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nev->transport_handle = iscsi_handle(transport);\r\nev->type = ISCSI_KEVENT_HOST_EVENT;\r\nev->r.host_event.host_no = host_no;\r\nev->r.host_event.code = code;\r\nev->r.host_event.data_size = data_size;\r\nif (data_size)\r\nmemcpy((char *)ev + sizeof(*ev), data, data_size);\r\niscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_NOIO);\r\n}\r\nvoid iscsi_ping_comp_event(uint32_t host_no, struct iscsi_transport *transport,\r\nuint32_t status, uint32_t pid, uint32_t data_size,\r\nuint8_t *data)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nstruct iscsi_uevent *ev;\r\nint len = NLMSG_SPACE(sizeof(*ev) + data_size);\r\nskb = alloc_skb(len, GFP_NOIO);\r\nif (!skb) {\r\nprintk(KERN_ERR "gracefully ignored ping comp: OOM\n");\r\nreturn;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nev->transport_handle = iscsi_handle(transport);\r\nev->type = ISCSI_KEVENT_PING_COMP;\r\nev->r.ping_comp.host_no = host_no;\r\nev->r.ping_comp.status = status;\r\nev->r.ping_comp.pid = pid;\r\nev->r.ping_comp.data_size = data_size;\r\nmemcpy((char *)ev + sizeof(*ev), data, data_size);\r\niscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_NOIO);\r\n}\r\nstatic int\r\niscsi_if_send_reply(uint32_t group, int seq, int type, int done, int multi,\r\nvoid *payload, int size)\r\n{\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nint len = NLMSG_SPACE(size);\r\nint flags = multi ? NLM_F_MULTI : 0;\r\nint t = done ? NLMSG_DONE : type;\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "Could not allocate skb to send reply.\n");\r\nreturn -ENOMEM;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, t, (len - sizeof(*nlh)), 0);\r\nnlh->nlmsg_flags = flags;\r\nmemcpy(NLMSG_DATA(nlh), payload, size);\r\nreturn iscsi_multicast_skb(skb, group, GFP_ATOMIC);\r\n}\r\nstatic int\r\niscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)\r\n{\r\nstruct iscsi_uevent *ev = NLMSG_DATA(nlh);\r\nstruct iscsi_stats *stats;\r\nstruct sk_buff *skbstat;\r\nstruct iscsi_cls_conn *conn;\r\nstruct nlmsghdr *nlhstat;\r\nstruct iscsi_uevent *evstat;\r\nstruct iscsi_internal *priv;\r\nint len = NLMSG_SPACE(sizeof(*ev) +\r\nsizeof(struct iscsi_stats) +\r\nsizeof(struct iscsi_stats_custom) *\r\nISCSI_STATS_CUSTOM_MAX);\r\nint err = 0;\r\npriv = iscsi_if_transport_lookup(transport);\r\nif (!priv)\r\nreturn -EINVAL;\r\nconn = iscsi_conn_lookup(ev->u.get_stats.sid, ev->u.get_stats.cid);\r\nif (!conn)\r\nreturn -EEXIST;\r\ndo {\r\nint actual_size;\r\nskbstat = alloc_skb(len, GFP_ATOMIC);\r\nif (!skbstat) {\r\niscsi_cls_conn_printk(KERN_ERR, conn, "can not "\r\n"deliver stats: OOM\n");\r\nreturn -ENOMEM;\r\n}\r\nnlhstat = __nlmsg_put(skbstat, 0, 0, 0,\r\n(len - sizeof(*nlhstat)), 0);\r\nevstat = NLMSG_DATA(nlhstat);\r\nmemset(evstat, 0, sizeof(*evstat));\r\nevstat->transport_handle = iscsi_handle(conn->transport);\r\nevstat->type = nlh->nlmsg_type;\r\nevstat->u.get_stats.cid =\r\nev->u.get_stats.cid;\r\nevstat->u.get_stats.sid =\r\nev->u.get_stats.sid;\r\nstats = (struct iscsi_stats *)\r\n((char*)evstat + sizeof(*evstat));\r\nmemset(stats, 0, sizeof(*stats));\r\ntransport->get_stats(conn, stats);\r\nactual_size = NLMSG_SPACE(sizeof(struct iscsi_uevent) +\r\nsizeof(struct iscsi_stats) +\r\nsizeof(struct iscsi_stats_custom) *\r\nstats->custom_length);\r\nactual_size -= sizeof(*nlhstat);\r\nactual_size = NLMSG_LENGTH(actual_size);\r\nskb_trim(skbstat, NLMSG_ALIGN(actual_size));\r\nnlhstat->nlmsg_len = actual_size;\r\nerr = iscsi_multicast_skb(skbstat, ISCSI_NL_GRP_ISCSID,\r\nGFP_ATOMIC);\r\n} while (err < 0 && err != -ECONNREFUSED);\r\nreturn err;\r\n}\r\nint iscsi_session_event(struct iscsi_cls_session *session,\r\nenum iscsi_uevent_e event)\r\n{\r\nstruct iscsi_internal *priv;\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_uevent *ev;\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nint rc, len = NLMSG_SPACE(sizeof(*ev));\r\npriv = iscsi_if_transport_lookup(session->transport);\r\nif (!priv)\r\nreturn -EINVAL;\r\nshost = iscsi_session_to_shost(session);\r\nskb = alloc_skb(len, GFP_KERNEL);\r\nif (!skb) {\r\niscsi_cls_session_printk(KERN_ERR, session,\r\n"Cannot notify userspace of session "\r\n"event %u\n", event);\r\nreturn -ENOMEM;\r\n}\r\nnlh = __nlmsg_put(skb, 0, 0, 0, (len - sizeof(*nlh)), 0);\r\nev = NLMSG_DATA(nlh);\r\nev->transport_handle = iscsi_handle(session->transport);\r\nev->type = event;\r\nswitch (event) {\r\ncase ISCSI_KEVENT_DESTROY_SESSION:\r\nev->r.d_session.host_no = shost->host_no;\r\nev->r.d_session.sid = session->sid;\r\nbreak;\r\ncase ISCSI_KEVENT_CREATE_SESSION:\r\nev->r.c_session_ret.host_no = shost->host_no;\r\nev->r.c_session_ret.sid = session->sid;\r\nbreak;\r\ncase ISCSI_KEVENT_UNBIND_SESSION:\r\nev->r.unbind_session.host_no = shost->host_no;\r\nev->r.unbind_session.sid = session->sid;\r\nbreak;\r\ndefault:\r\niscsi_cls_session_printk(KERN_ERR, session, "Invalid event "\r\n"%u.\n", event);\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nrc = iscsi_multicast_skb(skb, ISCSI_NL_GRP_ISCSID, GFP_KERNEL);\r\nif (rc == -ESRCH)\r\niscsi_cls_session_printk(KERN_ERR, session,\r\n"Cannot notify userspace of session "\r\n"event %u. Check iscsi daemon\n",\r\nevent);\r\nISCSI_DBG_TRANS_SESSION(session, "Completed handling event %d rc %d\n",\r\nevent, rc);\r\nreturn rc;\r\n}\r\nstatic int\r\niscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,\r\nstruct iscsi_uevent *ev, pid_t pid,\r\nuint32_t initial_cmdsn, uint16_t cmds_max,\r\nuint16_t queue_depth)\r\n{\r\nstruct iscsi_transport *transport = priv->iscsi_transport;\r\nstruct iscsi_cls_session *session;\r\nstruct Scsi_Host *shost;\r\nsession = transport->create_session(ep, cmds_max, queue_depth,\r\ninitial_cmdsn);\r\nif (!session)\r\nreturn -ENOMEM;\r\nsession->creator = pid;\r\nshost = iscsi_session_to_shost(session);\r\nev->r.c_session_ret.host_no = shost->host_no;\r\nev->r.c_session_ret.sid = session->sid;\r\nISCSI_DBG_TRANS_SESSION(session,\r\n"Completed creating transport session\n");\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)\r\n{\r\nstruct iscsi_cls_conn *conn;\r\nstruct iscsi_cls_session *session;\r\nsession = iscsi_session_lookup(ev->u.c_conn.sid);\r\nif (!session) {\r\nprintk(KERN_ERR "iscsi: invalid session %d.\n",\r\nev->u.c_conn.sid);\r\nreturn -EINVAL;\r\n}\r\nconn = transport->create_conn(session, ev->u.c_conn.cid);\r\nif (!conn) {\r\niscsi_cls_session_printk(KERN_ERR, session,\r\n"couldn't create a new connection.");\r\nreturn -ENOMEM;\r\n}\r\nev->r.c_conn_ret.sid = session->sid;\r\nev->r.c_conn_ret.cid = conn->cid;\r\nISCSI_DBG_TRANS_CONN(conn, "Completed creating transport conn\n");\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)\r\n{\r\nstruct iscsi_cls_conn *conn;\r\nconn = iscsi_conn_lookup(ev->u.d_conn.sid, ev->u.d_conn.cid);\r\nif (!conn)\r\nreturn -EINVAL;\r\nISCSI_DBG_TRANS_CONN(conn, "Destroying transport conn\n");\r\nif (transport->destroy_conn)\r\ntransport->destroy_conn(conn);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)\r\n{\r\nchar *data = (char*)ev + sizeof(*ev);\r\nstruct iscsi_cls_conn *conn;\r\nstruct iscsi_cls_session *session;\r\nint err = 0, value = 0;\r\nsession = iscsi_session_lookup(ev->u.set_param.sid);\r\nconn = iscsi_conn_lookup(ev->u.set_param.sid, ev->u.set_param.cid);\r\nif (!conn || !session)\r\nreturn -EINVAL;\r\nswitch (ev->u.set_param.param) {\r\ncase ISCSI_PARAM_SESS_RECOVERY_TMO:\r\nsscanf(data, "%d", &value);\r\nsession->recovery_tmo = value;\r\nbreak;\r\ndefault:\r\nerr = transport->set_param(conn, ev->u.set_param.param,\r\ndata, ev->u.set_param.len);\r\n}\r\nreturn err;\r\n}\r\nstatic int iscsi_if_ep_connect(struct iscsi_transport *transport,\r\nstruct iscsi_uevent *ev, int msg_type)\r\n{\r\nstruct iscsi_endpoint *ep;\r\nstruct sockaddr *dst_addr;\r\nstruct Scsi_Host *shost = NULL;\r\nint non_blocking, err = 0;\r\nif (!transport->ep_connect)\r\nreturn -EINVAL;\r\nif (msg_type == ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST) {\r\nshost = scsi_host_lookup(ev->u.ep_connect_through_host.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "ep connect failed. Could not find "\r\n"host no %u\n",\r\nev->u.ep_connect_through_host.host_no);\r\nreturn -ENODEV;\r\n}\r\nnon_blocking = ev->u.ep_connect_through_host.non_blocking;\r\n} else\r\nnon_blocking = ev->u.ep_connect.non_blocking;\r\ndst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));\r\nep = transport->ep_connect(shost, dst_addr, non_blocking);\r\nif (IS_ERR(ep)) {\r\nerr = PTR_ERR(ep);\r\ngoto release_host;\r\n}\r\nev->r.ep_connect_ret.handle = ep->id;\r\nrelease_host:\r\nif (shost)\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int iscsi_if_ep_disconnect(struct iscsi_transport *transport,\r\nu64 ep_handle)\r\n{\r\nstruct iscsi_cls_conn *conn;\r\nstruct iscsi_endpoint *ep;\r\nif (!transport->ep_disconnect)\r\nreturn -EINVAL;\r\nep = iscsi_lookup_endpoint(ep_handle);\r\nif (!ep)\r\nreturn -EINVAL;\r\nconn = ep->conn;\r\nif (conn) {\r\nmutex_lock(&conn->ep_mutex);\r\nconn->ep = NULL;\r\nmutex_unlock(&conn->ep_mutex);\r\n}\r\ntransport->ep_disconnect(ep);\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_if_transport_ep(struct iscsi_transport *transport,\r\nstruct iscsi_uevent *ev, int msg_type)\r\n{\r\nstruct iscsi_endpoint *ep;\r\nint rc = 0;\r\nswitch (msg_type) {\r\ncase ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST:\r\ncase ISCSI_UEVENT_TRANSPORT_EP_CONNECT:\r\nrc = iscsi_if_ep_connect(transport, ev, msg_type);\r\nbreak;\r\ncase ISCSI_UEVENT_TRANSPORT_EP_POLL:\r\nif (!transport->ep_poll)\r\nreturn -EINVAL;\r\nep = iscsi_lookup_endpoint(ev->u.ep_poll.ep_handle);\r\nif (!ep)\r\nreturn -EINVAL;\r\nev->r.retcode = transport->ep_poll(ep,\r\nev->u.ep_poll.timeout_ms);\r\nbreak;\r\ncase ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:\r\nrc = iscsi_if_ep_disconnect(transport,\r\nev->u.ep_disconnect.ep_handle);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\niscsi_tgt_dscvr(struct iscsi_transport *transport,\r\nstruct iscsi_uevent *ev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sockaddr *dst_addr;\r\nint err;\r\nif (!transport->tgt_dscvr)\r\nreturn -EINVAL;\r\nshost = scsi_host_lookup(ev->u.tgt_dscvr.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "target discovery could not find host no %u\n",\r\nev->u.tgt_dscvr.host_no);\r\nreturn -ENODEV;\r\n}\r\ndst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));\r\nerr = transport->tgt_dscvr(shost, ev->u.tgt_dscvr.type,\r\nev->u.tgt_dscvr.enable, dst_addr);\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int\r\niscsi_set_host_param(struct iscsi_transport *transport,\r\nstruct iscsi_uevent *ev)\r\n{\r\nchar *data = (char*)ev + sizeof(*ev);\r\nstruct Scsi_Host *shost;\r\nint err;\r\nif (!transport->set_host_param)\r\nreturn -ENOSYS;\r\nshost = scsi_host_lookup(ev->u.set_host_param.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "set_host_param could not find host no %u\n",\r\nev->u.set_host_param.host_no);\r\nreturn -ENODEV;\r\n}\r\nerr = transport->set_host_param(shost, ev->u.set_host_param.param,\r\ndata, ev->u.set_host_param.len);\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int\r\niscsi_set_path(struct iscsi_transport *transport, struct iscsi_uevent *ev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_path *params;\r\nint err;\r\nif (!transport->set_path)\r\nreturn -ENOSYS;\r\nshost = scsi_host_lookup(ev->u.set_path.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "set path could not find host no %u\n",\r\nev->u.set_path.host_no);\r\nreturn -ENODEV;\r\n}\r\nparams = (struct iscsi_path *)((char *)ev + sizeof(*ev));\r\nerr = transport->set_path(shost, params);\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int\r\niscsi_set_iface_params(struct iscsi_transport *transport,\r\nstruct iscsi_uevent *ev, uint32_t len)\r\n{\r\nchar *data = (char *)ev + sizeof(*ev);\r\nstruct Scsi_Host *shost;\r\nint err;\r\nif (!transport->set_iface_param)\r\nreturn -ENOSYS;\r\nshost = scsi_host_lookup(ev->u.set_iface_params.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "set_iface_params could not find host no %u\n",\r\nev->u.set_iface_params.host_no);\r\nreturn -ENODEV;\r\n}\r\nerr = transport->set_iface_param(shost, data, len);\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int\r\niscsi_send_ping(struct iscsi_transport *transport, struct iscsi_uevent *ev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sockaddr *dst_addr;\r\nint err;\r\nif (!transport->send_ping)\r\nreturn -ENOSYS;\r\nshost = scsi_host_lookup(ev->u.iscsi_ping.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "iscsi_ping could not find host no %u\n",\r\nev->u.iscsi_ping.host_no);\r\nreturn -ENODEV;\r\n}\r\ndst_addr = (struct sockaddr *)((char *)ev + sizeof(*ev));\r\nerr = transport->send_ping(shost, ev->u.iscsi_ping.iface_num,\r\nev->u.iscsi_ping.iface_type,\r\nev->u.iscsi_ping.payload_size,\r\nev->u.iscsi_ping.pid,\r\ndst_addr);\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int\r\niscsi_get_chap(struct iscsi_transport *transport, struct nlmsghdr *nlh)\r\n{\r\nstruct iscsi_uevent *ev = NLMSG_DATA(nlh);\r\nstruct Scsi_Host *shost = NULL;\r\nstruct iscsi_chap_rec *chap_rec;\r\nstruct iscsi_internal *priv;\r\nstruct sk_buff *skbchap;\r\nstruct nlmsghdr *nlhchap;\r\nstruct iscsi_uevent *evchap;\r\nuint32_t chap_buf_size;\r\nint len, err = 0;\r\nchar *buf;\r\nif (!transport->get_chap)\r\nreturn -EINVAL;\r\npriv = iscsi_if_transport_lookup(transport);\r\nif (!priv)\r\nreturn -EINVAL;\r\nchap_buf_size = (ev->u.get_chap.num_entries * sizeof(*chap_rec));\r\nlen = NLMSG_SPACE(sizeof(*ev) + chap_buf_size);\r\nshost = scsi_host_lookup(ev->u.get_chap.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "%s: failed. Cound not find host no %u\n",\r\n__func__, ev->u.get_chap.host_no);\r\nreturn -ENODEV;\r\n}\r\ndo {\r\nint actual_size;\r\nskbchap = alloc_skb(len, GFP_KERNEL);\r\nif (!skbchap) {\r\nprintk(KERN_ERR "can not deliver chap: OOM\n");\r\nerr = -ENOMEM;\r\ngoto exit_get_chap;\r\n}\r\nnlhchap = __nlmsg_put(skbchap, 0, 0, 0,\r\n(len - sizeof(*nlhchap)), 0);\r\nevchap = NLMSG_DATA(nlhchap);\r\nmemset(evchap, 0, sizeof(*evchap));\r\nevchap->transport_handle = iscsi_handle(transport);\r\nevchap->type = nlh->nlmsg_type;\r\nevchap->u.get_chap.host_no = ev->u.get_chap.host_no;\r\nevchap->u.get_chap.chap_tbl_idx = ev->u.get_chap.chap_tbl_idx;\r\nevchap->u.get_chap.num_entries = ev->u.get_chap.num_entries;\r\nbuf = (char *) ((char *)evchap + sizeof(*evchap));\r\nmemset(buf, 0, chap_buf_size);\r\nerr = transport->get_chap(shost, ev->u.get_chap.chap_tbl_idx,\r\n&evchap->u.get_chap.num_entries, buf);\r\nactual_size = NLMSG_SPACE(sizeof(*ev) + chap_buf_size);\r\nskb_trim(skbchap, NLMSG_ALIGN(actual_size));\r\nnlhchap->nlmsg_len = actual_size;\r\nerr = iscsi_multicast_skb(skbchap, ISCSI_NL_GRP_ISCSID,\r\nGFP_KERNEL);\r\n} while (err < 0 && err != -ECONNREFUSED);\r\nexit_get_chap:\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int iscsi_delete_chap(struct iscsi_transport *transport,\r\nstruct iscsi_uevent *ev)\r\n{\r\nstruct Scsi_Host *shost;\r\nint err = 0;\r\nif (!transport->delete_chap)\r\nreturn -ENOSYS;\r\nshost = scsi_host_lookup(ev->u.delete_chap.host_no);\r\nif (!shost) {\r\nprintk(KERN_ERR "%s could not find host no %u\n",\r\n__func__, ev->u.delete_chap.host_no);\r\nreturn -ENODEV;\r\n}\r\nerr = transport->delete_chap(shost, ev->u.delete_chap.chap_tbl_idx);\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic int\r\niscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)\r\n{\r\nint err = 0;\r\nstruct iscsi_uevent *ev = NLMSG_DATA(nlh);\r\nstruct iscsi_transport *transport = NULL;\r\nstruct iscsi_internal *priv;\r\nstruct iscsi_cls_session *session;\r\nstruct iscsi_cls_conn *conn;\r\nstruct iscsi_endpoint *ep = NULL;\r\nif (nlh->nlmsg_type == ISCSI_UEVENT_PATH_UPDATE)\r\n*group = ISCSI_NL_GRP_UIP;\r\nelse\r\n*group = ISCSI_NL_GRP_ISCSID;\r\npriv = iscsi_if_transport_lookup(iscsi_ptr(ev->transport_handle));\r\nif (!priv)\r\nreturn -EINVAL;\r\ntransport = priv->iscsi_transport;\r\nif (!try_module_get(transport->owner))\r\nreturn -EINVAL;\r\nswitch (nlh->nlmsg_type) {\r\ncase ISCSI_UEVENT_CREATE_SESSION:\r\nerr = iscsi_if_create_session(priv, ep, ev,\r\nNETLINK_CB(skb).pid,\r\nev->u.c_session.initial_cmdsn,\r\nev->u.c_session.cmds_max,\r\nev->u.c_session.queue_depth);\r\nbreak;\r\ncase ISCSI_UEVENT_CREATE_BOUND_SESSION:\r\nep = iscsi_lookup_endpoint(ev->u.c_bound_session.ep_handle);\r\nif (!ep) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nerr = iscsi_if_create_session(priv, ep, ev,\r\nNETLINK_CB(skb).pid,\r\nev->u.c_bound_session.initial_cmdsn,\r\nev->u.c_bound_session.cmds_max,\r\nev->u.c_bound_session.queue_depth);\r\nbreak;\r\ncase ISCSI_UEVENT_DESTROY_SESSION:\r\nsession = iscsi_session_lookup(ev->u.d_session.sid);\r\nif (session)\r\ntransport->destroy_session(session);\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase ISCSI_UEVENT_UNBIND_SESSION:\r\nsession = iscsi_session_lookup(ev->u.d_session.sid);\r\nif (session)\r\nscsi_queue_work(iscsi_session_to_shost(session),\r\n&session->unbind_work);\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase ISCSI_UEVENT_CREATE_CONN:\r\nerr = iscsi_if_create_conn(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_DESTROY_CONN:\r\nerr = iscsi_if_destroy_conn(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_BIND_CONN:\r\nsession = iscsi_session_lookup(ev->u.b_conn.sid);\r\nconn = iscsi_conn_lookup(ev->u.b_conn.sid, ev->u.b_conn.cid);\r\nif (conn && conn->ep)\r\niscsi_if_ep_disconnect(transport, conn->ep->id);\r\nif (!session || !conn) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nev->r.retcode = transport->bind_conn(session, conn,\r\nev->u.b_conn.transport_eph,\r\nev->u.b_conn.is_leading);\r\nif (ev->r.retcode || !transport->ep_connect)\r\nbreak;\r\nep = iscsi_lookup_endpoint(ev->u.b_conn.transport_eph);\r\nif (ep) {\r\nep->conn = conn;\r\nmutex_lock(&conn->ep_mutex);\r\nconn->ep = ep;\r\nmutex_unlock(&conn->ep_mutex);\r\n} else\r\niscsi_cls_conn_printk(KERN_ERR, conn,\r\n"Could not set ep conn "\r\n"binding\n");\r\nbreak;\r\ncase ISCSI_UEVENT_SET_PARAM:\r\nerr = iscsi_set_param(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_START_CONN:\r\nconn = iscsi_conn_lookup(ev->u.start_conn.sid, ev->u.start_conn.cid);\r\nif (conn)\r\nev->r.retcode = transport->start_conn(conn);\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase ISCSI_UEVENT_STOP_CONN:\r\nconn = iscsi_conn_lookup(ev->u.stop_conn.sid, ev->u.stop_conn.cid);\r\nif (conn)\r\ntransport->stop_conn(conn, ev->u.stop_conn.flag);\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase ISCSI_UEVENT_SEND_PDU:\r\nconn = iscsi_conn_lookup(ev->u.send_pdu.sid, ev->u.send_pdu.cid);\r\nif (conn)\r\nev->r.retcode = transport->send_pdu(conn,\r\n(struct iscsi_hdr*)((char*)ev + sizeof(*ev)),\r\n(char*)ev + sizeof(*ev) + ev->u.send_pdu.hdr_size,\r\nev->u.send_pdu.data_size);\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase ISCSI_UEVENT_GET_STATS:\r\nerr = iscsi_if_get_stats(transport, nlh);\r\nbreak;\r\ncase ISCSI_UEVENT_TRANSPORT_EP_CONNECT:\r\ncase ISCSI_UEVENT_TRANSPORT_EP_POLL:\r\ncase ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:\r\ncase ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST:\r\nerr = iscsi_if_transport_ep(transport, ev, nlh->nlmsg_type);\r\nbreak;\r\ncase ISCSI_UEVENT_TGT_DSCVR:\r\nerr = iscsi_tgt_dscvr(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_SET_HOST_PARAM:\r\nerr = iscsi_set_host_param(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_PATH_UPDATE:\r\nerr = iscsi_set_path(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_SET_IFACE_PARAMS:\r\nerr = iscsi_set_iface_params(transport, ev,\r\nnlmsg_attrlen(nlh, sizeof(*ev)));\r\nbreak;\r\ncase ISCSI_UEVENT_PING:\r\nerr = iscsi_send_ping(transport, ev);\r\nbreak;\r\ncase ISCSI_UEVENT_GET_CHAP:\r\nerr = iscsi_get_chap(transport, nlh);\r\nbreak;\r\ncase ISCSI_UEVENT_DELETE_CHAP:\r\nerr = iscsi_delete_chap(transport, ev);\r\nbreak;\r\ndefault:\r\nerr = -ENOSYS;\r\nbreak;\r\n}\r\nmodule_put(transport->owner);\r\nreturn err;\r\n}\r\nstatic void\r\niscsi_if_rx(struct sk_buff *skb)\r\n{\r\nmutex_lock(&rx_queue_mutex);\r\nwhile (skb->len >= NLMSG_SPACE(0)) {\r\nint err;\r\nuint32_t rlen;\r\nstruct nlmsghdr *nlh;\r\nstruct iscsi_uevent *ev;\r\nuint32_t group;\r\nnlh = nlmsg_hdr(skb);\r\nif (nlh->nlmsg_len < sizeof(*nlh) ||\r\nskb->len < nlh->nlmsg_len) {\r\nbreak;\r\n}\r\nev = NLMSG_DATA(nlh);\r\nrlen = NLMSG_ALIGN(nlh->nlmsg_len);\r\nif (rlen > skb->len)\r\nrlen = skb->len;\r\nerr = iscsi_if_recv_msg(skb, nlh, &group);\r\nif (err) {\r\nev->type = ISCSI_KEVENT_IF_ERROR;\r\nev->iferror = err;\r\n}\r\ndo {\r\nif (ev->type == ISCSI_UEVENT_GET_STATS && !err)\r\nbreak;\r\nif (ev->type == ISCSI_UEVENT_GET_CHAP && !err)\r\nbreak;\r\nerr = iscsi_if_send_reply(group, nlh->nlmsg_seq,\r\nnlh->nlmsg_type, 0, 0, ev, sizeof(*ev));\r\n} while (err < 0 && err != -ECONNREFUSED && err != -ESRCH);\r\nskb_pull(skb, rlen);\r\n}\r\nmutex_unlock(&rx_queue_mutex);\r\n}\r\nstatic umode_t iscsi_conn_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct device *cdev = container_of(kobj, struct device, kobj);\r\nstruct iscsi_cls_conn *conn = transport_class_to_conn(cdev);\r\nstruct iscsi_transport *t = conn->transport;\r\nint param;\r\nif (attr == &dev_attr_conn_max_recv_dlength.attr)\r\nparam = ISCSI_PARAM_MAX_RECV_DLENGTH;\r\nelse if (attr == &dev_attr_conn_max_xmit_dlength.attr)\r\nparam = ISCSI_PARAM_MAX_XMIT_DLENGTH;\r\nelse if (attr == &dev_attr_conn_header_digest.attr)\r\nparam = ISCSI_PARAM_HDRDGST_EN;\r\nelse if (attr == &dev_attr_conn_data_digest.attr)\r\nparam = ISCSI_PARAM_DATADGST_EN;\r\nelse if (attr == &dev_attr_conn_ifmarker.attr)\r\nparam = ISCSI_PARAM_IFMARKER_EN;\r\nelse if (attr == &dev_attr_conn_ofmarker.attr)\r\nparam = ISCSI_PARAM_OFMARKER_EN;\r\nelse if (attr == &dev_attr_conn_address.attr)\r\nparam = ISCSI_PARAM_CONN_ADDRESS;\r\nelse if (attr == &dev_attr_conn_port.attr)\r\nparam = ISCSI_PARAM_CONN_PORT;\r\nelse if (attr == &dev_attr_conn_exp_statsn.attr)\r\nparam = ISCSI_PARAM_EXP_STATSN;\r\nelse if (attr == &dev_attr_conn_persistent_address.attr)\r\nparam = ISCSI_PARAM_PERSISTENT_ADDRESS;\r\nelse if (attr == &dev_attr_conn_persistent_port.attr)\r\nparam = ISCSI_PARAM_PERSISTENT_PORT;\r\nelse if (attr == &dev_attr_conn_ping_tmo.attr)\r\nparam = ISCSI_PARAM_PING_TMO;\r\nelse if (attr == &dev_attr_conn_recv_tmo.attr)\r\nparam = ISCSI_PARAM_RECV_TMO;\r\nelse {\r\nWARN_ONCE(1, "Invalid conn attr");\r\nreturn 0;\r\n}\r\nreturn t->attr_is_visible(ISCSI_PARAM, param);\r\n}\r\nstatic ssize_t\r\nshow_priv_session_state(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);\r\nreturn sprintf(buf, "%s\n", iscsi_session_state_name(session->state));\r\n}\r\nstatic ssize_t\r\nshow_priv_session_creator(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iscsi_cls_session *session = iscsi_dev_to_session(dev->parent);\r\nreturn sprintf(buf, "%d\n", session->creator);\r\n}\r\nstatic umode_t iscsi_session_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct device *cdev = container_of(kobj, struct device, kobj);\r\nstruct iscsi_cls_session *session = transport_class_to_session(cdev);\r\nstruct iscsi_transport *t = session->transport;\r\nint param;\r\nif (attr == &dev_attr_sess_initial_r2t.attr)\r\nparam = ISCSI_PARAM_INITIAL_R2T_EN;\r\nelse if (attr == &dev_attr_sess_max_outstanding_r2t.attr)\r\nparam = ISCSI_PARAM_MAX_R2T;\r\nelse if (attr == &dev_attr_sess_immediate_data.attr)\r\nparam = ISCSI_PARAM_IMM_DATA_EN;\r\nelse if (attr == &dev_attr_sess_first_burst_len.attr)\r\nparam = ISCSI_PARAM_FIRST_BURST;\r\nelse if (attr == &dev_attr_sess_max_burst_len.attr)\r\nparam = ISCSI_PARAM_MAX_BURST;\r\nelse if (attr == &dev_attr_sess_data_pdu_in_order.attr)\r\nparam = ISCSI_PARAM_PDU_INORDER_EN;\r\nelse if (attr == &dev_attr_sess_data_seq_in_order.attr)\r\nparam = ISCSI_PARAM_DATASEQ_INORDER_EN;\r\nelse if (attr == &dev_attr_sess_erl.attr)\r\nparam = ISCSI_PARAM_ERL;\r\nelse if (attr == &dev_attr_sess_targetname.attr)\r\nparam = ISCSI_PARAM_TARGET_NAME;\r\nelse if (attr == &dev_attr_sess_tpgt.attr)\r\nparam = ISCSI_PARAM_TPGT;\r\nelse if (attr == &dev_attr_sess_chap_in_idx.attr)\r\nparam = ISCSI_PARAM_CHAP_IN_IDX;\r\nelse if (attr == &dev_attr_sess_chap_out_idx.attr)\r\nparam = ISCSI_PARAM_CHAP_OUT_IDX;\r\nelse if (attr == &dev_attr_sess_password.attr)\r\nparam = ISCSI_PARAM_USERNAME;\r\nelse if (attr == &dev_attr_sess_password_in.attr)\r\nparam = ISCSI_PARAM_USERNAME_IN;\r\nelse if (attr == &dev_attr_sess_username.attr)\r\nparam = ISCSI_PARAM_PASSWORD;\r\nelse if (attr == &dev_attr_sess_username_in.attr)\r\nparam = ISCSI_PARAM_PASSWORD_IN;\r\nelse if (attr == &dev_attr_sess_fast_abort.attr)\r\nparam = ISCSI_PARAM_FAST_ABORT;\r\nelse if (attr == &dev_attr_sess_abort_tmo.attr)\r\nparam = ISCSI_PARAM_ABORT_TMO;\r\nelse if (attr == &dev_attr_sess_lu_reset_tmo.attr)\r\nparam = ISCSI_PARAM_LU_RESET_TMO;\r\nelse if (attr == &dev_attr_sess_tgt_reset_tmo.attr)\r\nparam = ISCSI_PARAM_TGT_RESET_TMO;\r\nelse if (attr == &dev_attr_sess_ifacename.attr)\r\nparam = ISCSI_PARAM_IFACE_NAME;\r\nelse if (attr == &dev_attr_sess_initiatorname.attr)\r\nparam = ISCSI_PARAM_INITIATOR_NAME;\r\nelse if (attr == &dev_attr_sess_targetalias.attr)\r\nparam = ISCSI_PARAM_TARGET_ALIAS;\r\nelse if (attr == &dev_attr_priv_sess_recovery_tmo.attr)\r\nreturn S_IRUGO | S_IWUSR;\r\nelse if (attr == &dev_attr_priv_sess_state.attr)\r\nreturn S_IRUGO;\r\nelse if (attr == &dev_attr_priv_sess_creator.attr)\r\nreturn S_IRUGO;\r\nelse {\r\nWARN_ONCE(1, "Invalid session attr");\r\nreturn 0;\r\n}\r\nreturn t->attr_is_visible(ISCSI_PARAM, param);\r\n}\r\nstatic umode_t iscsi_host_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct device *cdev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *shost = transport_class_to_shost(cdev);\r\nstruct iscsi_internal *priv = to_iscsi_internal(shost->transportt);\r\nint param;\r\nif (attr == &dev_attr_host_netdev.attr)\r\nparam = ISCSI_HOST_PARAM_NETDEV_NAME;\r\nelse if (attr == &dev_attr_host_hwaddress.attr)\r\nparam = ISCSI_HOST_PARAM_HWADDRESS;\r\nelse if (attr == &dev_attr_host_ipaddress.attr)\r\nparam = ISCSI_HOST_PARAM_IPADDRESS;\r\nelse if (attr == &dev_attr_host_initiatorname.attr)\r\nparam = ISCSI_HOST_PARAM_INITIATOR_NAME;\r\nelse if (attr == &dev_attr_host_port_state.attr)\r\nparam = ISCSI_HOST_PARAM_PORT_STATE;\r\nelse if (attr == &dev_attr_host_port_speed.attr)\r\nparam = ISCSI_HOST_PARAM_PORT_SPEED;\r\nelse {\r\nWARN_ONCE(1, "Invalid host attr");\r\nreturn 0;\r\n}\r\nreturn priv->iscsi_transport->attr_is_visible(ISCSI_HOST_PARAM, param);\r\n}\r\nchar *iscsi_get_port_speed_name(struct Scsi_Host *shost)\r\n{\r\nint i;\r\nchar *speed = "Unknown!";\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nuint32_t port_speed = ihost->port_speed;\r\nfor (i = 0; i < ARRAY_SIZE(iscsi_port_speed_names); i++) {\r\nif (iscsi_port_speed_names[i].value & port_speed) {\r\nspeed = iscsi_port_speed_names[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn speed;\r\n}\r\nchar *iscsi_get_port_state_name(struct Scsi_Host *shost)\r\n{\r\nint i;\r\nchar *state = "Unknown!";\r\nstruct iscsi_cls_host *ihost = shost->shost_data;\r\nuint32_t port_state = ihost->port_state;\r\nfor (i = 0; i < ARRAY_SIZE(iscsi_port_state_names); i++) {\r\nif (iscsi_port_state_names[i].value & port_state) {\r\nstate = iscsi_port_state_names[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn state;\r\n}\r\nstatic int iscsi_session_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct iscsi_cls_session *session;\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_internal *priv;\r\nif (!iscsi_is_session_dev(dev))\r\nreturn 0;\r\nsession = iscsi_dev_to_session(dev);\r\nshost = iscsi_session_to_shost(session);\r\nif (!shost->transportt)\r\nreturn 0;\r\npriv = to_iscsi_internal(shost->transportt);\r\nif (priv->session_cont.ac.class != &iscsi_session_class.class)\r\nreturn 0;\r\nreturn &priv->session_cont.ac == cont;\r\n}\r\nstatic int iscsi_conn_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct iscsi_cls_session *session;\r\nstruct iscsi_cls_conn *conn;\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_internal *priv;\r\nif (!iscsi_is_conn_dev(dev))\r\nreturn 0;\r\nconn = iscsi_dev_to_conn(dev);\r\nsession = iscsi_dev_to_session(conn->dev.parent);\r\nshost = iscsi_session_to_shost(session);\r\nif (!shost->transportt)\r\nreturn 0;\r\npriv = to_iscsi_internal(shost->transportt);\r\nif (priv->conn_cont.ac.class != &iscsi_connection_class.class)\r\nreturn 0;\r\nreturn &priv->conn_cont.ac == cont;\r\n}\r\nstatic int iscsi_host_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_internal *priv;\r\nif (!scsi_is_host_device(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev);\r\nif (!shost->transportt ||\r\nshost->transportt->host_attrs.ac.class != &iscsi_host_class.class)\r\nreturn 0;\r\npriv = to_iscsi_internal(shost->transportt);\r\nreturn &priv->t.host_attrs.ac == cont;\r\n}\r\nstruct scsi_transport_template *\r\niscsi_register_transport(struct iscsi_transport *tt)\r\n{\r\nstruct iscsi_internal *priv;\r\nunsigned long flags;\r\nint err;\r\nBUG_ON(!tt);\r\npriv = iscsi_if_transport_lookup(tt);\r\nif (priv)\r\nreturn NULL;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&priv->list);\r\npriv->iscsi_transport = tt;\r\npriv->t.user_scan = iscsi_user_scan;\r\npriv->t.create_work_queue = 1;\r\npriv->dev.class = &iscsi_transport_class;\r\ndev_set_name(&priv->dev, "%s", tt->name);\r\nerr = device_register(&priv->dev);\r\nif (err)\r\ngoto free_priv;\r\nerr = sysfs_create_group(&priv->dev.kobj, &iscsi_transport_group);\r\nif (err)\r\ngoto unregister_dev;\r\npriv->t.host_attrs.ac.class = &iscsi_host_class.class;\r\npriv->t.host_attrs.ac.match = iscsi_host_match;\r\npriv->t.host_attrs.ac.grp = &iscsi_host_group;\r\npriv->t.host_size = sizeof(struct iscsi_cls_host);\r\ntransport_container_register(&priv->t.host_attrs);\r\npriv->conn_cont.ac.class = &iscsi_connection_class.class;\r\npriv->conn_cont.ac.match = iscsi_conn_match;\r\npriv->conn_cont.ac.grp = &iscsi_conn_group;\r\ntransport_container_register(&priv->conn_cont);\r\npriv->session_cont.ac.class = &iscsi_session_class.class;\r\npriv->session_cont.ac.match = iscsi_session_match;\r\npriv->session_cont.ac.grp = &iscsi_session_group;\r\ntransport_container_register(&priv->session_cont);\r\nspin_lock_irqsave(&iscsi_transport_lock, flags);\r\nlist_add(&priv->list, &iscsi_transports);\r\nspin_unlock_irqrestore(&iscsi_transport_lock, flags);\r\nprintk(KERN_NOTICE "iscsi: registered transport (%s)\n", tt->name);\r\nreturn &priv->t;\r\nunregister_dev:\r\ndevice_unregister(&priv->dev);\r\nreturn NULL;\r\nfree_priv:\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nint iscsi_unregister_transport(struct iscsi_transport *tt)\r\n{\r\nstruct iscsi_internal *priv;\r\nunsigned long flags;\r\nBUG_ON(!tt);\r\nmutex_lock(&rx_queue_mutex);\r\npriv = iscsi_if_transport_lookup(tt);\r\nBUG_ON (!priv);\r\nspin_lock_irqsave(&iscsi_transport_lock, flags);\r\nlist_del(&priv->list);\r\nspin_unlock_irqrestore(&iscsi_transport_lock, flags);\r\ntransport_container_unregister(&priv->conn_cont);\r\ntransport_container_unregister(&priv->session_cont);\r\ntransport_container_unregister(&priv->t.host_attrs);\r\nsysfs_remove_group(&priv->dev.kobj, &iscsi_transport_group);\r\ndevice_unregister(&priv->dev);\r\nmutex_unlock(&rx_queue_mutex);\r\nreturn 0;\r\n}\r\nstatic __init int iscsi_transport_init(void)\r\n{\r\nint err;\r\nprintk(KERN_INFO "Loading iSCSI transport class v%s.\n",\r\nISCSI_TRANSPORT_VERSION);\r\natomic_set(&iscsi_session_nr, 0);\r\nerr = class_register(&iscsi_transport_class);\r\nif (err)\r\nreturn err;\r\nerr = class_register(&iscsi_endpoint_class);\r\nif (err)\r\ngoto unregister_transport_class;\r\nerr = class_register(&iscsi_iface_class);\r\nif (err)\r\ngoto unregister_endpoint_class;\r\nerr = transport_class_register(&iscsi_host_class);\r\nif (err)\r\ngoto unregister_iface_class;\r\nerr = transport_class_register(&iscsi_connection_class);\r\nif (err)\r\ngoto unregister_host_class;\r\nerr = transport_class_register(&iscsi_session_class);\r\nif (err)\r\ngoto unregister_conn_class;\r\nnls = netlink_kernel_create(&init_net, NETLINK_ISCSI, 1, iscsi_if_rx,\r\nNULL, THIS_MODULE);\r\nif (!nls) {\r\nerr = -ENOBUFS;\r\ngoto unregister_session_class;\r\n}\r\niscsi_eh_timer_workq = create_singlethread_workqueue("iscsi_eh");\r\nif (!iscsi_eh_timer_workq)\r\ngoto release_nls;\r\nreturn 0;\r\nrelease_nls:\r\nnetlink_kernel_release(nls);\r\nunregister_session_class:\r\ntransport_class_unregister(&iscsi_session_class);\r\nunregister_conn_class:\r\ntransport_class_unregister(&iscsi_connection_class);\r\nunregister_host_class:\r\ntransport_class_unregister(&iscsi_host_class);\r\nunregister_iface_class:\r\nclass_unregister(&iscsi_iface_class);\r\nunregister_endpoint_class:\r\nclass_unregister(&iscsi_endpoint_class);\r\nunregister_transport_class:\r\nclass_unregister(&iscsi_transport_class);\r\nreturn err;\r\n}\r\nstatic void __exit iscsi_transport_exit(void)\r\n{\r\ndestroy_workqueue(iscsi_eh_timer_workq);\r\nnetlink_kernel_release(nls);\r\ntransport_class_unregister(&iscsi_connection_class);\r\ntransport_class_unregister(&iscsi_session_class);\r\ntransport_class_unregister(&iscsi_host_class);\r\nclass_unregister(&iscsi_endpoint_class);\r\nclass_unregister(&iscsi_iface_class);\r\nclass_unregister(&iscsi_transport_class);\r\n}
