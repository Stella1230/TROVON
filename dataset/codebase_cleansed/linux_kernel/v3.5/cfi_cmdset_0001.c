static void cfi_tell_features(struct cfi_pri_intelext *extp)\r\n{\r\nint i;\r\nprintk(" Extended Query version %c.%c\n", extp->MajorVersion, extp->MinorVersion);\r\nprintk(" Feature/Command Support: %4.4X\n", extp->FeatureSupport);\r\nprintk(" - Chip Erase: %s\n", extp->FeatureSupport&1?"supported":"unsupported");\r\nprintk(" - Suspend Erase: %s\n", extp->FeatureSupport&2?"supported":"unsupported");\r\nprintk(" - Suspend Program: %s\n", extp->FeatureSupport&4?"supported":"unsupported");\r\nprintk(" - Legacy Lock/Unlock: %s\n", extp->FeatureSupport&8?"supported":"unsupported");\r\nprintk(" - Queued Erase: %s\n", extp->FeatureSupport&16?"supported":"unsupported");\r\nprintk(" - Instant block lock: %s\n", extp->FeatureSupport&32?"supported":"unsupported");\r\nprintk(" - Protection Bits: %s\n", extp->FeatureSupport&64?"supported":"unsupported");\r\nprintk(" - Page-mode read: %s\n", extp->FeatureSupport&128?"supported":"unsupported");\r\nprintk(" - Synchronous read: %s\n", extp->FeatureSupport&256?"supported":"unsupported");\r\nprintk(" - Simultaneous operations: %s\n", extp->FeatureSupport&512?"supported":"unsupported");\r\nprintk(" - Extended Flash Array: %s\n", extp->FeatureSupport&1024?"supported":"unsupported");\r\nfor (i=11; i<32; i++) {\r\nif (extp->FeatureSupport & (1<<i))\r\nprintk(" - Unknown Bit %X: supported\n", i);\r\n}\r\nprintk(" Supported functions after Suspend: %2.2X\n", extp->SuspendCmdSupport);\r\nprintk(" - Program after Erase Suspend: %s\n", extp->SuspendCmdSupport&1?"supported":"unsupported");\r\nfor (i=1; i<8; i++) {\r\nif (extp->SuspendCmdSupport & (1<<i))\r\nprintk(" - Unknown Bit %X: supported\n", i);\r\n}\r\nprintk(" Block Status Register Mask: %4.4X\n", extp->BlkStatusRegMask);\r\nprintk(" - Lock Bit Active: %s\n", extp->BlkStatusRegMask&1?"yes":"no");\r\nprintk(" - Lock-Down Bit Active: %s\n", extp->BlkStatusRegMask&2?"yes":"no");\r\nfor (i=2; i<3; i++) {\r\nif (extp->BlkStatusRegMask & (1<<i))\r\nprintk(" - Unknown Bit %X Active: yes\n",i);\r\n}\r\nprintk(" - EFA Lock Bit: %s\n", extp->BlkStatusRegMask&16?"yes":"no");\r\nprintk(" - EFA Lock-Down Bit: %s\n", extp->BlkStatusRegMask&32?"yes":"no");\r\nfor (i=6; i<16; i++) {\r\nif (extp->BlkStatusRegMask & (1<<i))\r\nprintk(" - Unknown Bit %X Active: yes\n",i);\r\n}\r\nprintk(" Vcc Logic Supply Optimum Program/Erase Voltage: %d.%d V\n",\r\nextp->VccOptimal >> 4, extp->VccOptimal & 0xf);\r\nif (extp->VppOptimal)\r\nprintk(" Vpp Programming Supply Optimum Program/Erase Voltage: %d.%d V\n",\r\nextp->VppOptimal >> 4, extp->VppOptimal & 0xf);\r\n}\r\nstatic void fixup_convert_atmel_pri(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nstruct cfi_pri_atmel atmel_pri;\r\nuint32_t features = 0;\r\nextp->FeatureSupport = cpu_to_le32(extp->FeatureSupport);\r\nextp->BlkStatusRegMask = cpu_to_le16(extp->BlkStatusRegMask);\r\nextp->ProtRegAddr = cpu_to_le16(extp->ProtRegAddr);\r\nmemcpy(&atmel_pri, extp, sizeof(atmel_pri));\r\nmemset((char *)extp + 5, 0, sizeof(*extp) - 5);\r\nprintk(KERN_ERR "atmel Features: %02x\n", atmel_pri.Features);\r\nif (atmel_pri.Features & 0x01)\r\nfeatures |= (1<<0);\r\nif (atmel_pri.Features & 0x02)\r\nfeatures |= (1<<1);\r\nif (atmel_pri.Features & 0x04)\r\nfeatures |= (1<<2);\r\nif (atmel_pri.Features & 0x08)\r\nfeatures |= (1<<9);\r\nif (atmel_pri.Features & 0x20)\r\nfeatures |= (1<<7);\r\nif (atmel_pri.Features & 0x40)\r\nfeatures |= (1<<4);\r\nif (atmel_pri.Features & 0x80)\r\nfeatures |= (1<<6);\r\nextp->FeatureSupport = features;\r\ncfi->cfiq->BufWriteTimeoutTyp = 0;\r\ncfi->cfiq->BufWriteTimeoutMax = 0;\r\n}\r\nstatic void fixup_at49bv640dx_lock(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\r\ncfip->FeatureSupport |= (1 << 5);\r\nmtd->flags |= MTD_POWERUP_LOCK;\r\n}\r\nstatic void fixup_intel_strataflash(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nprintk(KERN_WARNING "cfi_cmdset_0001: Suspend "\r\n"erase on write disabled.\n");\r\nextp->SuspendCmdSupport &= ~1;\r\n}\r\nstatic void fixup_no_write_suspend(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\r\nif (cfip && (cfip->FeatureSupport&4)) {\r\ncfip->FeatureSupport &= ~4;\r\nprintk(KERN_WARNING "cfi_cmdset_0001: write suspend disabled\n");\r\n}\r\n}\r\nstatic void fixup_st_m28w320ct(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\ncfi->cfiq->BufWriteTimeoutTyp = 0;\r\ncfi->cfiq->BufWriteTimeoutMax = 0;\r\n}\r\nstatic void fixup_st_m28w320cb(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\ncfi->cfiq->EraseRegionInfo[1] =\r\n(cfi->cfiq->EraseRegionInfo[1] & 0xffff0000) | 0x3e;\r\n}\r\nstatic void fixup_use_point(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nif (!mtd->_point && map_is_linear(map)) {\r\nmtd->_point = cfi_intelext_point;\r\nmtd->_unpoint = cfi_intelext_unpoint;\r\n}\r\n}\r\nstatic void fixup_use_write_buffers(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif (cfi->cfiq->BufWriteTimeoutTyp) {\r\nprintk(KERN_INFO "Using buffer write method\n" );\r\nmtd->_write = cfi_intelext_write_buffers;\r\nmtd->_writev = cfi_intelext_writev;\r\n}\r\n}\r\nstatic void fixup_unlock_powerup_lock(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\r\nif (cfip->FeatureSupport&32) {\r\nprintk(KERN_INFO "Using auto-unlock on power-up/resume\n" );\r\nmtd->flags |= MTD_POWERUP_LOCK;\r\n}\r\n}\r\nstatic void cfi_fixup_major_minor(struct cfi_private *cfi,\r\nstruct cfi_pri_intelext *extp)\r\n{\r\nif (cfi->mfr == CFI_MFR_INTEL &&\r\ncfi->id == PF38F4476 && extp->MinorVersion == '3')\r\nextp->MinorVersion = '1';\r\n}\r\nstatic inline struct cfi_pri_intelext *\r\nread_pri_intelext(struct map_info *map, __u16 adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp;\r\nunsigned int extra_size = 0;\r\nunsigned int extp_size = sizeof(*extp);\r\nagain:\r\nextp = (struct cfi_pri_intelext *)cfi_read_pri(map, adr, extp_size, "Intel/Sharp");\r\nif (!extp)\r\nreturn NULL;\r\ncfi_fixup_major_minor(cfi, extp);\r\nif (extp->MajorVersion != '1' ||\r\n(extp->MinorVersion < '0' || extp->MinorVersion > '5')) {\r\nprintk(KERN_ERR " Unknown Intel/Sharp Extended Query "\r\n"version %c.%c.\n", extp->MajorVersion,\r\nextp->MinorVersion);\r\nkfree(extp);\r\nreturn NULL;\r\n}\r\nextp->FeatureSupport = le32_to_cpu(extp->FeatureSupport);\r\nextp->BlkStatusRegMask = le16_to_cpu(extp->BlkStatusRegMask);\r\nextp->ProtRegAddr = le16_to_cpu(extp->ProtRegAddr);\r\nif (extp->MinorVersion >= '0') {\r\nextra_size = 0;\r\nextra_size += (extp->NumProtectionFields - 1) *\r\nsizeof(struct cfi_intelext_otpinfo);\r\n}\r\nif (extp->MinorVersion >= '1') {\r\nextra_size += 2;\r\nif (extp_size < sizeof(*extp) + extra_size)\r\ngoto need_more;\r\nextra_size += extp->extra[extra_size - 1];\r\n}\r\nif (extp->MinorVersion >= '3') {\r\nint nb_parts, i;\r\nextra_size += 1;\r\nif (extp_size < sizeof(*extp) + extra_size)\r\ngoto need_more;\r\nnb_parts = extp->extra[extra_size - 1];\r\nif (extp->MinorVersion >= '4')\r\nextra_size += 2;\r\nfor (i = 0; i < nb_parts; i++) {\r\nstruct cfi_intelext_regioninfo *rinfo;\r\nrinfo = (struct cfi_intelext_regioninfo *)&extp->extra[extra_size];\r\nextra_size += sizeof(*rinfo);\r\nif (extp_size < sizeof(*extp) + extra_size)\r\ngoto need_more;\r\nrinfo->NumIdentPartitions=le16_to_cpu(rinfo->NumIdentPartitions);\r\nextra_size += (rinfo->NumBlockTypes - 1)\r\n* sizeof(struct cfi_intelext_blockinfo);\r\n}\r\nif (extp->MinorVersion >= '4')\r\nextra_size += sizeof(struct cfi_intelext_programming_regioninfo);\r\nif (extp_size < sizeof(*extp) + extra_size) {\r\nneed_more:\r\nextp_size = sizeof(*extp) + extra_size;\r\nkfree(extp);\r\nif (extp_size > 4096) {\r\nprintk(KERN_ERR\r\n"%s: cfi_pri_intelext is too fat\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\ngoto again;\r\n}\r\n}\r\nreturn extp;\r\n}\r\nstruct mtd_info *cfi_cmdset_0001(struct map_info *map, int primary)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct mtd_info *mtd;\r\nint i;\r\nmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd) {\r\nprintk(KERN_ERR "Failed to allocate memory for MTD device\n");\r\nreturn NULL;\r\n}\r\nmtd->priv = map;\r\nmtd->type = MTD_NORFLASH;\r\nmtd->_erase = cfi_intelext_erase_varsize;\r\nmtd->_read = cfi_intelext_read;\r\nmtd->_write = cfi_intelext_write_words;\r\nmtd->_sync = cfi_intelext_sync;\r\nmtd->_lock = cfi_intelext_lock;\r\nmtd->_unlock = cfi_intelext_unlock;\r\nmtd->_is_locked = cfi_intelext_is_locked;\r\nmtd->_suspend = cfi_intelext_suspend;\r\nmtd->_resume = cfi_intelext_resume;\r\nmtd->flags = MTD_CAP_NORFLASH;\r\nmtd->name = map->name;\r\nmtd->writesize = 1;\r\nmtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nmtd->reboot_notifier.notifier_call = cfi_intelext_reboot;\r\nif (cfi->cfi_mode == CFI_MODE_CFI) {\r\n__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;\r\nstruct cfi_pri_intelext *extp;\r\nextp = read_pri_intelext(map, adr);\r\nif (!extp) {\r\nkfree(mtd);\r\nreturn NULL;\r\n}\r\ncfi->cmdset_priv = extp;\r\ncfi_fixup(mtd, cfi_fixup_table);\r\n#ifdef DEBUG_CFI_FEATURES\r\ncfi_tell_features(extp);\r\n#endif\r\nif(extp->SuspendCmdSupport & 1) {\r\nprintk(KERN_NOTICE "cfi_cmdset_0001: Erase suspend on write enabled\n");\r\n}\r\n}\r\nelse if (cfi->cfi_mode == CFI_MODE_JEDEC) {\r\ncfi_fixup(mtd, jedec_fixup_table);\r\n}\r\ncfi_fixup(mtd, fixup_table);\r\nfor (i=0; i< cfi->numchips; i++) {\r\nif (cfi->cfiq->WordWriteTimeoutTyp)\r\ncfi->chips[i].word_write_time =\r\n1<<cfi->cfiq->WordWriteTimeoutTyp;\r\nelse\r\ncfi->chips[i].word_write_time = 50000;\r\nif (cfi->cfiq->BufWriteTimeoutTyp)\r\ncfi->chips[i].buffer_write_time =\r\n1<<cfi->cfiq->BufWriteTimeoutTyp;\r\nif (cfi->cfiq->BlockEraseTimeoutTyp)\r\ncfi->chips[i].erase_time =\r\n1000<<cfi->cfiq->BlockEraseTimeoutTyp;\r\nelse\r\ncfi->chips[i].erase_time = 2000000;\r\nif (cfi->cfiq->WordWriteTimeoutTyp &&\r\ncfi->cfiq->WordWriteTimeoutMax)\r\ncfi->chips[i].word_write_time_max =\r\n1<<(cfi->cfiq->WordWriteTimeoutTyp +\r\ncfi->cfiq->WordWriteTimeoutMax);\r\nelse\r\ncfi->chips[i].word_write_time_max = 50000 * 8;\r\nif (cfi->cfiq->BufWriteTimeoutTyp &&\r\ncfi->cfiq->BufWriteTimeoutMax)\r\ncfi->chips[i].buffer_write_time_max =\r\n1<<(cfi->cfiq->BufWriteTimeoutTyp +\r\ncfi->cfiq->BufWriteTimeoutMax);\r\nif (cfi->cfiq->BlockEraseTimeoutTyp &&\r\ncfi->cfiq->BlockEraseTimeoutMax)\r\ncfi->chips[i].erase_time_max =\r\n1000<<(cfi->cfiq->BlockEraseTimeoutTyp +\r\ncfi->cfiq->BlockEraseTimeoutMax);\r\nelse\r\ncfi->chips[i].erase_time_max = 2000000 * 8;\r\ncfi->chips[i].ref_point_counter = 0;\r\ninit_waitqueue_head(&(cfi->chips[i].wq));\r\n}\r\nmap->fldrv = &cfi_intelext_chipdrv;\r\nreturn cfi_intelext_setup(mtd);\r\n}\r\nstatic struct mtd_info *cfi_intelext_setup(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long offset = 0;\r\nint i,j;\r\nunsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;\r\nmtd->size = devsize * cfi->numchips;\r\nmtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;\r\nmtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info)\r\n* mtd->numeraseregions, GFP_KERNEL);\r\nif (!mtd->eraseregions) {\r\nprintk(KERN_ERR "Failed to allocate memory for MTD erase region info\n");\r\ngoto setup_err;\r\n}\r\nfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\r\nunsigned long ernum, ersize;\r\nersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;\r\nernum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;\r\nif (mtd->erasesize < ersize) {\r\nmtd->erasesize = ersize;\r\n}\r\nfor (j=0; j<cfi->numchips; j++) {\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;\r\nmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].lockmap = kmalloc(ernum / 8 + 1, GFP_KERNEL);\r\n}\r\noffset += (ersize * ernum);\r\n}\r\nif (offset != devsize) {\r\nprintk(KERN_WARNING "Sum of regions (%lx) != total size of set of interleaved chips (%lx)\n", offset, devsize);\r\ngoto setup_err;\r\n}\r\nfor (i=0; i<mtd->numeraseregions;i++){\r\nprintk(KERN_DEBUG "erase region %d: offset=0x%llx,size=0x%x,blocks=%d\n",\r\ni,(unsigned long long)mtd->eraseregions[i].offset,\r\nmtd->eraseregions[i].erasesize,\r\nmtd->eraseregions[i].numblocks);\r\n}\r\n#ifdef CONFIG_MTD_OTP\r\nmtd->_read_fact_prot_reg = cfi_intelext_read_fact_prot_reg;\r\nmtd->_read_user_prot_reg = cfi_intelext_read_user_prot_reg;\r\nmtd->_write_user_prot_reg = cfi_intelext_write_user_prot_reg;\r\nmtd->_lock_user_prot_reg = cfi_intelext_lock_user_prot_reg;\r\nmtd->_get_fact_prot_info = cfi_intelext_get_fact_prot_info;\r\nmtd->_get_user_prot_info = cfi_intelext_get_user_prot_info;\r\n#endif\r\nif (cfi_intelext_partition_fixup(mtd, &cfi) != 0)\r\ngoto setup_err;\r\n__module_get(THIS_MODULE);\r\nregister_reboot_notifier(&mtd->reboot_notifier);\r\nreturn mtd;\r\nsetup_err:\r\nkfree(mtd->eraseregions);\r\nkfree(mtd);\r\nkfree(cfi->cmdset_priv);\r\nreturn NULL;\r\n}\r\nstatic int cfi_intelext_partition_fixup(struct mtd_info *mtd,\r\nstruct cfi_private **pcfi)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = *pcfi;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nif (extp && extp->MajorVersion == '1' && extp->MinorVersion >= '3'\r\n&& extp->FeatureSupport & (1 << 9)) {\r\nstruct cfi_private *newcfi;\r\nstruct flchip *chip;\r\nstruct flchip_shared *shared;\r\nint offs, numregions, numparts, partshift, numvirtchips, i, j;\r\noffs = (extp->NumProtectionFields - 1) *\r\nsizeof(struct cfi_intelext_otpinfo);\r\noffs += extp->extra[offs+1]+2;\r\nnumregions = extp->extra[offs];\r\noffs += 1;\r\nif (extp->MinorVersion >= '4')\r\noffs += 2;\r\nnumparts = 0;\r\nfor (i = 0; i < numregions; i++) {\r\nstruct cfi_intelext_regioninfo *rinfo;\r\nrinfo = (struct cfi_intelext_regioninfo *)&extp->extra[offs];\r\nnumparts += rinfo->NumIdentPartitions;\r\noffs += sizeof(*rinfo)\r\n+ (rinfo->NumBlockTypes - 1) *\r\nsizeof(struct cfi_intelext_blockinfo);\r\n}\r\nif (!numparts)\r\nnumparts = 1;\r\nif (extp->MinorVersion >= '4') {\r\nstruct cfi_intelext_programming_regioninfo *prinfo;\r\nprinfo = (struct cfi_intelext_programming_regioninfo *)&extp->extra[offs];\r\nmtd->writesize = cfi->interleave << prinfo->ProgRegShift;\r\nmtd->flags &= ~MTD_BIT_WRITEABLE;\r\nprintk(KERN_DEBUG "%s: program region size/ctrl_valid/ctrl_inval = %d/%d/%d\n",\r\nmap->name, mtd->writesize,\r\ncfi->interleave * prinfo->ControlValid,\r\ncfi->interleave * prinfo->ControlInvalid);\r\n}\r\npartshift = cfi->chipshift - __ffs(numparts);\r\nif ((1 << partshift) < mtd->erasesize) {\r\nprintk( KERN_ERR\r\n"%s: bad number of hw partitions (%d)\n",\r\n__func__, numparts);\r\nreturn -EINVAL;\r\n}\r\nnumvirtchips = cfi->numchips * numparts;\r\nnewcfi = kmalloc(sizeof(struct cfi_private) + numvirtchips * sizeof(struct flchip), GFP_KERNEL);\r\nif (!newcfi)\r\nreturn -ENOMEM;\r\nshared = kmalloc(sizeof(struct flchip_shared) * cfi->numchips, GFP_KERNEL);\r\nif (!shared) {\r\nkfree(newcfi);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(newcfi, cfi, sizeof(struct cfi_private));\r\nnewcfi->numchips = numvirtchips;\r\nnewcfi->chipshift = partshift;\r\nchip = &newcfi->chips[0];\r\nfor (i = 0; i < cfi->numchips; i++) {\r\nshared[i].writing = shared[i].erasing = NULL;\r\nmutex_init(&shared[i].lock);\r\nfor (j = 0; j < numparts; j++) {\r\n*chip = cfi->chips[i];\r\nchip->start += j << partshift;\r\nchip->priv = &shared[i];\r\ninit_waitqueue_head(&chip->wq);\r\nmutex_init(&chip->mutex);\r\nchip++;\r\n}\r\n}\r\nprintk(KERN_DEBUG "%s: %d set(s) of %d interleaved chips "\r\n"--> %d partitions of %d KiB\n",\r\nmap->name, cfi->numchips, cfi->interleave,\r\nnewcfi->numchips, 1<<(newcfi->chipshift-10));\r\nmap->fldrv_priv = newcfi;\r\n*pcfi = newcfi;\r\nkfree(cfi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int chip_ready (struct map_info *map, struct flchip *chip, unsigned long adr, int mode)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, status_OK = CMD(0x80), status_PWS = CMD(0x01);\r\nstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\r\nunsigned long timeo = jiffies + HZ;\r\nif (mode == FL_SYNCING && chip->oldstate != FL_READY)\r\ngoto sleep;\r\nswitch (chip->state) {\r\ncase FL_STATUS:\r\nfor (;;) {\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (chip->priv && map_word_andequal(map, status, status_PWS, status_PWS))\r\nbreak;\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\nreturn -EAGAIN;\r\n}\r\ncase FL_READY:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nreturn 0;\r\ncase FL_ERASING:\r\nif (!cfip ||\r\n!(cfip->FeatureSupport & 2) ||\r\n!(mode == FL_READY || mode == FL_POINT ||\r\n(mode == FL_WRITING && (cfip->SuspendCmdSupport & 1))))\r\ngoto sleep;\r\nmap_write(map, CMD(0xB0), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nchip->oldstate = FL_ERASING;\r\nchip->state = FL_ERASE_SUSPENDING;\r\nchip->erase_suspended = 1;\r\nfor (;;) {\r\nstatus = map_read(map, adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (time_after(jiffies, timeo)) {\r\nput_chip(map, chip, adr);\r\nprintk(KERN_ERR "%s: Chip not ready after erase "\r\n"suspended: status = 0x%lx\n", map->name, status.x[0]);\r\nreturn -EIO;\r\n}\r\nmutex_unlock(&chip->mutex);\r\ncfi_udelay(1);\r\nmutex_lock(&chip->mutex);\r\n}\r\nchip->state = FL_STATUS;\r\nreturn 0;\r\ncase FL_XIP_WHILE_ERASING:\r\nif (mode != FL_READY && mode != FL_POINT &&\r\n(mode != FL_WRITING || !cfip || !(cfip->SuspendCmdSupport&1)))\r\ngoto sleep;\r\nchip->oldstate = chip->state;\r\nchip->state = FL_READY;\r\nreturn 0;\r\ncase FL_SHUTDOWN:\r\nreturn -EIO;\r\ncase FL_POINT:\r\nif (mode == FL_READY && chip->oldstate == FL_READY)\r\nreturn 0;\r\ndefault:\r\nsleep:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode)\r\n{\r\nint ret;\r\nDECLARE_WAITQUEUE(wait, current);\r\nretry:\r\nif (chip->priv &&\r\n(mode == FL_WRITING || mode == FL_ERASING || mode == FL_OTP_WRITE\r\n|| mode == FL_SHUTDOWN) && chip->state != FL_SYNCING) {\r\nstruct flchip_shared *shared = chip->priv;\r\nstruct flchip *contender;\r\nmutex_lock(&shared->lock);\r\ncontender = shared->writing;\r\nif (contender && contender != chip) {\r\nret = mutex_trylock(&contender->mutex);\r\nmutex_unlock(&shared->lock);\r\nif (!ret)\r\ngoto retry;\r\nmutex_unlock(&chip->mutex);\r\nret = chip_ready(map, contender, contender->start, mode);\r\nmutex_lock(&chip->mutex);\r\nif (ret == -EAGAIN) {\r\nmutex_unlock(&contender->mutex);\r\ngoto retry;\r\n}\r\nif (ret) {\r\nmutex_unlock(&contender->mutex);\r\nreturn ret;\r\n}\r\nmutex_lock(&shared->lock);\r\nif (chip->state == FL_SYNCING) {\r\nput_chip(map, contender, contender->start);\r\nmutex_unlock(&contender->mutex);\r\ngoto retry;\r\n}\r\nmutex_unlock(&contender->mutex);\r\n}\r\nif (mode == FL_ERASING && shared->erasing\r\n&& shared->erasing->oldstate == FL_ERASING) {\r\nmutex_unlock(&shared->lock);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\ngoto retry;\r\n}\r\nshared->writing = chip;\r\nif (mode == FL_ERASING)\r\nshared->erasing = chip;\r\nmutex_unlock(&shared->lock);\r\n}\r\nret = chip_ready(map, chip, adr, mode);\r\nif (ret == -EAGAIN)\r\ngoto retry;\r\nreturn ret;\r\n}\r\nstatic void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif (chip->priv) {\r\nstruct flchip_shared *shared = chip->priv;\r\nmutex_lock(&shared->lock);\r\nif (shared->writing == chip && chip->oldstate == FL_READY) {\r\nshared->writing = shared->erasing;\r\nif (shared->writing && shared->writing != chip) {\r\nstruct flchip *loaner = shared->writing;\r\nmutex_lock(&loaner->mutex);\r\nmutex_unlock(&shared->lock);\r\nmutex_unlock(&chip->mutex);\r\nput_chip(map, loaner, loaner->start);\r\nmutex_lock(&chip->mutex);\r\nmutex_unlock(&loaner->mutex);\r\nwake_up(&chip->wq);\r\nreturn;\r\n}\r\nshared->erasing = NULL;\r\nshared->writing = NULL;\r\n} else if (shared->erasing == chip && shared->writing != chip) {\r\nmutex_unlock(&shared->lock);\r\nwake_up(&chip->wq);\r\nreturn;\r\n}\r\nmutex_unlock(&shared->lock);\r\n}\r\nswitch(chip->oldstate) {\r\ncase FL_ERASING:\r\nmap_write(map, CMD(0xd0), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nchip->oldstate = FL_READY;\r\nchip->state = FL_ERASING;\r\nbreak;\r\ncase FL_XIP_WHILE_ERASING:\r\nchip->state = chip->oldstate;\r\nchip->oldstate = FL_READY;\r\nbreak;\r\ncase FL_READY:\r\ncase FL_STATUS:\r\ncase FL_JEDEC_QUERY:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: put_chip() called with oldstate %d!!\n", map->name, chip->oldstate);\r\n}\r\nwake_up(&chip->wq);\r\n}\r\nstatic void xip_disable(struct map_info *map, struct flchip *chip,\r\nunsigned long adr)\r\n{\r\n(void) map_read(map, adr);\r\nlocal_irq_disable();\r\n}\r\nstatic void __xipram xip_enable(struct map_info *map, struct flchip *chip,\r\nunsigned long adr)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nif (chip->state != FL_POINT && chip->state != FL_READY) {\r\nmap_write(map, CMD(0xff), adr);\r\nchip->state = FL_READY;\r\n}\r\n(void) map_read(map, adr);\r\nxip_iprefetch();\r\nlocal_irq_enable();\r\n}\r\nstatic int __xipram xip_wait_for_operation(\r\nstruct map_info *map, struct flchip *chip,\r\nunsigned long adr, unsigned int chip_op_time_max)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\r\nmap_word status, OK = CMD(0x80);\r\nunsigned long usec, suspended, start, done;\r\nflstate_t oldstate, newstate;\r\nstart = xip_currtime();\r\nusec = chip_op_time_max;\r\nif (usec == 0)\r\nusec = 500000;\r\ndone = 0;\r\ndo {\r\ncpu_relax();\r\nif (xip_irqpending() && cfip &&\r\n((chip->state == FL_ERASING && (cfip->FeatureSupport&2)) ||\r\n(chip->state == FL_WRITING && (cfip->FeatureSupport&4))) &&\r\n(cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {\r\nusec -= done;\r\nmap_write(map, CMD(0xb0), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nsuspended = xip_currtime();\r\ndo {\r\nif (xip_elapsed_since(suspended) > 100000) {\r\nreturn -EIO;\r\n}\r\nstatus = map_read(map, adr);\r\n} while (!map_word_andequal(map, status, OK, OK));\r\noldstate = chip->state;\r\nif (oldstate == FL_ERASING) {\r\nif (!map_word_bitsset(map, status, CMD(0x40)))\r\nbreak;\r\nnewstate = FL_XIP_WHILE_ERASING;\r\nchip->erase_suspended = 1;\r\n} else {\r\nif (!map_word_bitsset(map, status, CMD(0x04)))\r\nbreak;\r\nnewstate = FL_XIP_WHILE_WRITING;\r\nchip->write_suspended = 1;\r\n}\r\nchip->state = newstate;\r\nmap_write(map, CMD(0xff), adr);\r\n(void) map_read(map, adr);\r\nxip_iprefetch();\r\nlocal_irq_enable();\r\nmutex_unlock(&chip->mutex);\r\nxip_iprefetch();\r\ncond_resched();\r\nmutex_lock(&chip->mutex);\r\nwhile (chip->state != newstate) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\n}\r\nlocal_irq_disable();\r\nmap_write(map, CMD(0xd0), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = oldstate;\r\nstart = xip_currtime();\r\n} else if (usec >= 1000000/HZ) {\r\nxip_cpu_idle();\r\n}\r\nstatus = map_read(map, adr);\r\ndone = xip_elapsed_since(start);\r\n} while (!map_word_andequal(map, status, OK, OK)\r\n&& done < usec);\r\nreturn (done >= usec) ? -ETIME : 0;\r\n}\r\nstatic int inval_cache_and_wait_for_operation(\r\nstruct map_info *map, struct flchip *chip,\r\nunsigned long cmd_adr, unsigned long inval_adr, int inval_len,\r\nunsigned int chip_op_time, unsigned int chip_op_time_max)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, status_OK = CMD(0x80);\r\nint chip_state = chip->state;\r\nunsigned int timeo, sleep_time, reset_timeo;\r\nmutex_unlock(&chip->mutex);\r\nif (inval_len)\r\nINVALIDATE_CACHED_RANGE(map, inval_adr, inval_len);\r\nmutex_lock(&chip->mutex);\r\ntimeo = chip_op_time_max;\r\nif (!timeo)\r\ntimeo = 500000;\r\nreset_timeo = timeo;\r\nsleep_time = chip_op_time / 2;\r\nfor (;;) {\r\nif (chip->state != chip_state) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&chip->wq, &wait);\r\nmutex_unlock(&chip->mutex);\r\nschedule();\r\nremove_wait_queue(&chip->wq, &wait);\r\nmutex_lock(&chip->mutex);\r\ncontinue;\r\n}\r\nstatus = map_read(map, cmd_adr);\r\nif (map_word_andequal(map, status, status_OK, status_OK))\r\nbreak;\r\nif (chip->erase_suspended && chip_state == FL_ERASING) {\r\ntimeo = reset_timeo;\r\nchip->erase_suspended = 0;\r\n}\r\nif (chip->write_suspended && chip_state == FL_WRITING) {\r\ntimeo = reset_timeo;\r\nchip->write_suspended = 0;\r\n}\r\nif (!timeo) {\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nchip->state = FL_STATUS;\r\nreturn -ETIME;\r\n}\r\nmutex_unlock(&chip->mutex);\r\nif (sleep_time >= 1000000/HZ) {\r\nmsleep(sleep_time/1000);\r\ntimeo -= sleep_time;\r\nsleep_time = 1000000/HZ;\r\n} else {\r\nudelay(1);\r\ncond_resched();\r\ntimeo--;\r\n}\r\nmutex_lock(&chip->mutex);\r\n}\r\nchip->state = FL_STATUS;\r\nreturn 0;\r\n}\r\nstatic int do_point_onechip (struct map_info *map, struct flchip *chip, loff_t adr, size_t len)\r\n{\r\nunsigned long cmd_addr;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret = 0;\r\nadr += chip->start;\r\ncmd_addr = adr & ~(map_bankwidth(map)-1);\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, cmd_addr, FL_POINT);\r\nif (!ret) {\r\nif (chip->state != FL_POINT && chip->state != FL_READY)\r\nmap_write(map, CMD(0xff), cmd_addr);\r\nchip->state = FL_POINT;\r\nchip->ref_point_counter++;\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_point(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, void **virt, resource_size_t *phys)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long ofs, last_end = 0;\r\nint chipnum;\r\nint ret = 0;\r\nif (!map->virt)\r\nreturn -EINVAL;\r\nchipnum = (from >> cfi->chipshift);\r\nofs = from - (chipnum << cfi->chipshift);\r\n*virt = map->virt + cfi->chips[chipnum].start + ofs;\r\nif (phys)\r\n*phys = map->phys + cfi->chips[chipnum].start + ofs;\r\nwhile (len) {\r\nunsigned long thislen;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\nif (!last_end)\r\nlast_end = cfi->chips[chipnum].start;\r\nelse if (cfi->chips[chipnum].start != last_end)\r\nbreak;\r\nif ((len + ofs -1) >> cfi->chipshift)\r\nthislen = (1<<cfi->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nret = do_point_onechip(map, &cfi->chips[chipnum], ofs, thislen);\r\nif (ret)\r\nbreak;\r\n*retlen += thislen;\r\nlen -= thislen;\r\nofs = 0;\r\nlast_end += 1 << cfi->chipshift;\r\nchipnum++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfi_intelext_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long ofs;\r\nint chipnum, err = 0;\r\nchipnum = (from >> cfi->chipshift);\r\nofs = from - (chipnum << cfi->chipshift);\r\nwhile (len && !err) {\r\nunsigned long thislen;\r\nstruct flchip *chip;\r\nchip = &cfi->chips[chipnum];\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\nif ((len + ofs -1) >> cfi->chipshift)\r\nthislen = (1<<cfi->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_POINT) {\r\nchip->ref_point_counter--;\r\nif(chip->ref_point_counter == 0)\r\nchip->state = FL_READY;\r\n} else {\r\nprintk(KERN_ERR "%s: Error: unpoint called on non pointed region\n", map->name);\r\nerr = -EINVAL;\r\n}\r\nput_chip(map, chip, chip->start);\r\nmutex_unlock(&chip->mutex);\r\nlen -= thislen;\r\nofs = 0;\r\nchipnum++;\r\n}\r\nreturn err;\r\n}\r\nstatic inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\r\n{\r\nunsigned long cmd_addr;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret;\r\nadr += chip->start;\r\ncmd_addr = adr & ~(map_bankwidth(map)-1);\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, cmd_addr, FL_READY);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nif (chip->state != FL_POINT && chip->state != FL_READY) {\r\nmap_write(map, CMD(0xff), cmd_addr);\r\nchip->state = FL_READY;\r\n}\r\nmap_copy_from(map, buf, adr, len);\r\nput_chip(map, chip, cmd_addr);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int cfi_intelext_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long ofs;\r\nint chipnum;\r\nint ret = 0;\r\nchipnum = (from >> cfi->chipshift);\r\nofs = from - (chipnum << cfi->chipshift);\r\nwhile (len) {\r\nunsigned long thislen;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\nif ((len + ofs -1) >> cfi->chipshift)\r\nthislen = (1<<cfi->chipshift) - ofs;\r\nelse\r\nthislen = len;\r\nret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\r\nif (ret)\r\nbreak;\r\n*retlen += thislen;\r\nlen -= thislen;\r\nbuf += thislen;\r\nofs = 0;\r\nchipnum++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, map_word datum, int mode)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, write_cmd;\r\nint ret=0;\r\nadr += chip->start;\r\nswitch (mode) {\r\ncase FL_WRITING:\r\nwrite_cmd = (cfi->cfiq->P_ID != P_ID_INTEL_PERFORMANCE) ? CMD(0x40) : CMD(0x41);\r\nbreak;\r\ncase FL_OTP_WRITE:\r\nwrite_cmd = CMD(0xc0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, mode);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nXIP_INVAL_CACHED_RANGE(map, adr, map_bankwidth(map));\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, adr);\r\nmap_write(map, write_cmd, adr);\r\nmap_write(map, datum, adr);\r\nchip->state = mode;\r\nret = INVAL_CACHE_AND_WAIT(map, chip, adr,\r\nadr, map_bankwidth(map),\r\nchip->word_write_time,\r\nchip->word_write_time_max);\r\nif (ret) {\r\nxip_enable(map, chip, adr);\r\nprintk(KERN_ERR "%s: word write error (status timeout)\n", map->name);\r\ngoto out;\r\n}\r\nstatus = map_read(map, adr);\r\nif (map_word_bitsset(map, status, CMD(0x1a))) {\r\nunsigned long chipstatus = MERGESTATUS(status);\r\nmap_write(map, CMD(0x50), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nxip_enable(map, chip, adr);\r\nif (chipstatus & 0x02) {\r\nret = -EROFS;\r\n} else if (chipstatus & 0x08) {\r\nprintk(KERN_ERR "%s: word write error (bad VPP)\n", map->name);\r\nret = -EIO;\r\n} else {\r\nprintk(KERN_ERR "%s: word write error (status 0x%lx)\n", map->name, chipstatus);\r\nret = -EINVAL;\r\n}\r\ngoto out;\r\n}\r\nxip_enable(map, chip, adr);\r\nout: DISABLE_VPP(map);\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_write_words (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret = 0;\r\nint chipnum;\r\nunsigned long ofs;\r\nchipnum = to >> cfi->chipshift;\r\nofs = to - (chipnum << cfi->chipshift);\r\nif (ofs & (map_bankwidth(map)-1)) {\r\nunsigned long bus_ofs = ofs & ~(map_bankwidth(map)-1);\r\nint gap = ofs - bus_ofs;\r\nint n;\r\nmap_word datum;\r\nn = min_t(int, len, map_bankwidth(map)-gap);\r\ndatum = map_word_ff(map);\r\ndatum = map_word_load_partial(map, datum, buf, gap, n);\r\nret = do_write_oneword(map, &cfi->chips[chipnum],\r\nbus_ofs, datum, FL_WRITING);\r\nif (ret)\r\nreturn ret;\r\nlen -= n;\r\nofs += n;\r\nbuf += n;\r\n(*retlen) += n;\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\n}\r\nwhile(len >= map_bankwidth(map)) {\r\nmap_word datum = map_word_load(map, buf);\r\nret = do_write_oneword(map, &cfi->chips[chipnum],\r\nofs, datum, FL_WRITING);\r\nif (ret)\r\nreturn ret;\r\nofs += map_bankwidth(map);\r\nbuf += map_bankwidth(map);\r\n(*retlen) += map_bankwidth(map);\r\nlen -= map_bankwidth(map);\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\n}\r\nif (len & (map_bankwidth(map)-1)) {\r\nmap_word datum;\r\ndatum = map_word_ff(map);\r\ndatum = map_word_load_partial(map, datum, buf, 0, len);\r\nret = do_write_oneword(map, &cfi->chips[chipnum],\r\nofs, datum, FL_WRITING);\r\nif (ret)\r\nreturn ret;\r\n(*retlen) += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, const struct kvec **pvec,\r\nunsigned long *pvec_seek, int len)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status, write_cmd, datum;\r\nunsigned long cmd_adr;\r\nint ret, wbufsize, word_gap, words;\r\nconst struct kvec *vec;\r\nunsigned long vec_seek;\r\nunsigned long initial_adr;\r\nint initial_len = len;\r\nwbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nadr += chip->start;\r\ninitial_adr = adr;\r\ncmd_adr = adr & ~(wbufsize-1);\r\nwrite_cmd = (cfi->cfiq->P_ID != P_ID_INTEL_PERFORMANCE) ? CMD(0xe8) : CMD(0xe9);\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, cmd_adr, FL_WRITING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nXIP_INVAL_CACHED_RANGE(map, initial_adr, initial_len);\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, cmd_adr);\r\nif (chip->state != FL_STATUS) {\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nchip->state = FL_STATUS;\r\n}\r\nstatus = map_read(map, cmd_adr);\r\nif (map_word_bitsset(map, status, CMD(0x30))) {\r\nxip_enable(map, chip, cmd_adr);\r\nprintk(KERN_WARNING "SR.4 or SR.5 bits set in buffer write (status %lx). Clearing.\n", status.x[0]);\r\nxip_disable(map, chip, cmd_adr);\r\nmap_write(map, CMD(0x50), cmd_adr);\r\nmap_write(map, CMD(0x70), cmd_adr);\r\n}\r\nchip->state = FL_WRITING_TO_BUFFER;\r\nmap_write(map, write_cmd, cmd_adr);\r\nret = WAIT_TIMEOUT(map, chip, cmd_adr, 0, 0);\r\nif (ret) {\r\nmap_word Xstatus = map_read(map, cmd_adr);\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nchip->state = FL_STATUS;\r\nstatus = map_read(map, cmd_adr);\r\nmap_write(map, CMD(0x50), cmd_adr);\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nxip_enable(map, chip, cmd_adr);\r\nprintk(KERN_ERR "%s: Chip not ready for buffer write. Xstatus = %lx, status = %lx\n",\r\nmap->name, Xstatus.x[0], status.x[0]);\r\ngoto out;\r\n}\r\nword_gap = (-adr & (map_bankwidth(map)-1));\r\nwords = DIV_ROUND_UP(len - word_gap, map_bankwidth(map));\r\nif (!word_gap) {\r\nwords--;\r\n} else {\r\nword_gap = map_bankwidth(map) - word_gap;\r\nadr -= word_gap;\r\ndatum = map_word_ff(map);\r\n}\r\nmap_write(map, CMD(words), cmd_adr );\r\nvec = *pvec;\r\nvec_seek = *pvec_seek;\r\ndo {\r\nint n = map_bankwidth(map) - word_gap;\r\nif (n > vec->iov_len - vec_seek)\r\nn = vec->iov_len - vec_seek;\r\nif (n > len)\r\nn = len;\r\nif (!word_gap && len < map_bankwidth(map))\r\ndatum = map_word_ff(map);\r\ndatum = map_word_load_partial(map, datum,\r\nvec->iov_base + vec_seek,\r\nword_gap, n);\r\nlen -= n;\r\nword_gap += n;\r\nif (!len || word_gap == map_bankwidth(map)) {\r\nmap_write(map, datum, adr);\r\nadr += map_bankwidth(map);\r\nword_gap = 0;\r\n}\r\nvec_seek += n;\r\nif (vec_seek == vec->iov_len) {\r\nvec++;\r\nvec_seek = 0;\r\n}\r\n} while (len);\r\n*pvec = vec;\r\n*pvec_seek = vec_seek;\r\nmap_write(map, CMD(0xd0), cmd_adr);\r\nchip->state = FL_WRITING;\r\nret = INVAL_CACHE_AND_WAIT(map, chip, cmd_adr,\r\ninitial_adr, initial_len,\r\nchip->buffer_write_time,\r\nchip->buffer_write_time_max);\r\nif (ret) {\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nchip->state = FL_STATUS;\r\nxip_enable(map, chip, cmd_adr);\r\nprintk(KERN_ERR "%s: buffer write error (status timeout)\n", map->name);\r\ngoto out;\r\n}\r\nstatus = map_read(map, cmd_adr);\r\nif (map_word_bitsset(map, status, CMD(0x1a))) {\r\nunsigned long chipstatus = MERGESTATUS(status);\r\nmap_write(map, CMD(0x50), cmd_adr);\r\nmap_write(map, CMD(0x70), cmd_adr);\r\nxip_enable(map, chip, cmd_adr);\r\nif (chipstatus & 0x02) {\r\nret = -EROFS;\r\n} else if (chipstatus & 0x08) {\r\nprintk(KERN_ERR "%s: buffer write error (bad VPP)\n", map->name);\r\nret = -EIO;\r\n} else {\r\nprintk(KERN_ERR "%s: buffer write error (status 0x%lx)\n", map->name, chipstatus);\r\nret = -EINVAL;\r\n}\r\ngoto out;\r\n}\r\nxip_enable(map, chip, cmd_adr);\r\nout: DISABLE_VPP(map);\r\nput_chip(map, chip, cmd_adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_writev (struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\r\nint ret = 0;\r\nint chipnum;\r\nunsigned long ofs, vec_seek, i;\r\nsize_t len = 0;\r\nfor (i = 0; i < count; i++)\r\nlen += vecs[i].iov_len;\r\nif (!len)\r\nreturn 0;\r\nchipnum = to >> cfi->chipshift;\r\nofs = to - (chipnum << cfi->chipshift);\r\nvec_seek = 0;\r\ndo {\r\nint size = wbufsize - (ofs & (wbufsize-1));\r\nif (size > len)\r\nsize = len;\r\nret = do_write_buffer(map, &cfi->chips[chipnum],\r\nofs, &vecs, &vec_seek, size);\r\nif (ret)\r\nreturn ret;\r\nofs += size;\r\n(*retlen) += size;\r\nlen -= size;\r\nif (ofs >> cfi->chipshift) {\r\nchipnum ++;\r\nofs = 0;\r\nif (chipnum == cfi->numchips)\r\nreturn 0;\r\n}\r\ncond_resched();\r\n} while (len);\r\nreturn 0;\r\n}\r\nstatic int cfi_intelext_write_buffers (struct mtd_info *mtd, loff_t to,\r\nsize_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct kvec vec;\r\nvec.iov_base = (void *) buf;\r\nvec.iov_len = len;\r\nreturn cfi_intelext_writev(mtd, &vec, 1, to, retlen);\r\n}\r\nstatic int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, int len, void *thunk)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word status;\r\nint retries = 3;\r\nint ret;\r\nadr += chip->start;\r\nretry:\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, FL_ERASING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nXIP_INVAL_CACHED_RANGE(map, adr, len);\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, adr);\r\nmap_write(map, CMD(0x50), adr);\r\nmap_write(map, CMD(0x20), adr);\r\nmap_write(map, CMD(0xD0), adr);\r\nchip->state = FL_ERASING;\r\nchip->erase_suspended = 0;\r\nret = INVAL_CACHE_AND_WAIT(map, chip, adr,\r\nadr, len,\r\nchip->erase_time,\r\nchip->erase_time_max);\r\nif (ret) {\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nxip_enable(map, chip, adr);\r\nprintk(KERN_ERR "%s: block erase error: (status timeout)\n", map->name);\r\ngoto out;\r\n}\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nstatus = map_read(map, adr);\r\nif (map_word_bitsset(map, status, CMD(0x3a))) {\r\nunsigned long chipstatus = MERGESTATUS(status);\r\nmap_write(map, CMD(0x50), adr);\r\nmap_write(map, CMD(0x70), adr);\r\nxip_enable(map, chip, adr);\r\nif ((chipstatus & 0x30) == 0x30) {\r\nprintk(KERN_ERR "%s: block erase error: (bad command sequence, status 0x%lx)\n", map->name, chipstatus);\r\nret = -EINVAL;\r\n} else if (chipstatus & 0x02) {\r\nret = -EROFS;\r\n} else if (chipstatus & 0x8) {\r\nprintk(KERN_ERR "%s: block erase error: (bad VPP)\n", map->name);\r\nret = -EIO;\r\n} else if (chipstatus & 0x20 && retries--) {\r\nprintk(KERN_DEBUG "block erase failed at 0x%08lx: status 0x%lx. Retrying...\n", adr, chipstatus);\r\nDISABLE_VPP(map);\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\ngoto retry;\r\n} else {\r\nprintk(KERN_ERR "%s: block erase failed at 0x%08lx (status 0x%lx)\n", map->name, adr, chipstatus);\r\nret = -EIO;\r\n}\r\ngoto out;\r\n}\r\nxip_enable(map, chip, adr);\r\nout: DISABLE_VPP(map);\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nunsigned long ofs, len;\r\nint ret;\r\nofs = instr->addr;\r\nlen = instr->len;\r\nret = cfi_varsize_frob(mtd, do_erase_oneblock, ofs, len, NULL);\r\nif (ret)\r\nreturn ret;\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic void cfi_intelext_sync (struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i;\r\nstruct flchip *chip;\r\nint ret = 0;\r\nfor (i=0; !ret && i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, chip->start, FL_SYNCING);\r\nif (!ret) {\r\nchip->oldstate = chip->state;\r\nchip->state = FL_SYNCING;\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nfor (i--; i >=0; i--) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_SYNCING) {\r\nchip->state = chip->oldstate;\r\nchip->oldstate = FL_READY;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nstatic int __xipram do_getlockstatus_oneblock(struct map_info *map,\r\nstruct flchip *chip,\r\nunsigned long adr,\r\nint len, void *thunk)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint status, ofs_factor = cfi->interleave * cfi->device_type;\r\nadr += chip->start;\r\nxip_disable(map, chip, adr+(2*ofs_factor));\r\nmap_write(map, CMD(0x90), adr+(2*ofs_factor));\r\nchip->state = FL_JEDEC_QUERY;\r\nstatus = cfi_read_query(map, adr+(2*ofs_factor));\r\nxip_enable(map, chip, 0);\r\nreturn status;\r\n}\r\nstatic int __xipram do_printlockstatus_oneblock(struct map_info *map,\r\nstruct flchip *chip,\r\nunsigned long adr,\r\nint len, void *thunk)\r\n{\r\nprintk(KERN_DEBUG "block status register for 0x%08lx is %x\n",\r\nadr, do_getlockstatus_oneblock(map, chip, adr, len, thunk));\r\nreturn 0;\r\n}\r\nstatic int __xipram do_xxlock_oneblock(struct map_info *map, struct flchip *chip,\r\nunsigned long adr, int len, void *thunk)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nint udelay;\r\nint ret;\r\nadr += chip->start;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, adr, FL_LOCKING);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nENABLE_VPP(map);\r\nxip_disable(map, chip, adr);\r\nmap_write(map, CMD(0x60), adr);\r\nif (thunk == DO_XXLOCK_ONEBLOCK_LOCK) {\r\nmap_write(map, CMD(0x01), adr);\r\nchip->state = FL_LOCKING;\r\n} else if (thunk == DO_XXLOCK_ONEBLOCK_UNLOCK) {\r\nmap_write(map, CMD(0xD0), adr);\r\nchip->state = FL_UNLOCKING;\r\n} else\r\nBUG();\r\nudelay = (!extp || !(extp->FeatureSupport & (1 << 5))) ? 1000000/HZ : 0;\r\nret = WAIT_TIMEOUT(map, chip, adr, udelay, udelay * 100);\r\nif (ret) {\r\nmap_write(map, CMD(0x70), adr);\r\nchip->state = FL_STATUS;\r\nxip_enable(map, chip, adr);\r\nprintk(KERN_ERR "%s: block unlock error: (status timeout)\n", map->name);\r\ngoto out;\r\n}\r\nxip_enable(map, chip, adr);\r\nout: DISABLE_VPP(map);\r\nput_chip(map, chip, adr);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret;\r\n#ifdef DEBUG_LOCK_BITS\r\nprintk(KERN_DEBUG "%s: lock status before, ofs=0x%08llx, len=0x%08X\n",\r\n__func__, ofs, len);\r\ncfi_varsize_frob(mtd, do_printlockstatus_oneblock,\r\nofs, len, NULL);\r\n#endif\r\nret = cfi_varsize_frob(mtd, do_xxlock_oneblock,\r\nofs, len, DO_XXLOCK_ONEBLOCK_LOCK);\r\n#ifdef DEBUG_LOCK_BITS\r\nprintk(KERN_DEBUG "%s: lock status after, ret=%d\n",\r\n__func__, ret);\r\ncfi_varsize_frob(mtd, do_printlockstatus_oneblock,\r\nofs, len, NULL);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nint ret;\r\n#ifdef DEBUG_LOCK_BITS\r\nprintk(KERN_DEBUG "%s: lock status before, ofs=0x%08llx, len=0x%08X\n",\r\n__func__, ofs, len);\r\ncfi_varsize_frob(mtd, do_printlockstatus_oneblock,\r\nofs, len, NULL);\r\n#endif\r\nret = cfi_varsize_frob(mtd, do_xxlock_oneblock,\r\nofs, len, DO_XXLOCK_ONEBLOCK_UNLOCK);\r\n#ifdef DEBUG_LOCK_BITS\r\nprintk(KERN_DEBUG "%s: lock status after, ret=%d\n",\r\n__func__, ret);\r\ncfi_varsize_frob(mtd, do_printlockstatus_oneblock,\r\nofs, len, NULL);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int cfi_intelext_is_locked(struct mtd_info *mtd, loff_t ofs,\r\nuint64_t len)\r\n{\r\nreturn cfi_varsize_frob(mtd, do_getlockstatus_oneblock,\r\nofs, len, NULL) ? 1 : 0;\r\n}\r\nstatic int __xipram\r\ndo_otp_read(struct map_info *map, struct flchip *chip, u_long offset,\r\nu_char *buf, u_int size, u_long prot, u_int grpno, u_int grpsz)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint ret;\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, chip->start, FL_JEDEC_QUERY);\r\nif (ret) {\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nINVALIDATE_CACHED_RANGE(map, chip->start + offset, size);\r\nxip_disable(map, chip, chip->start);\r\nif (chip->state != FL_JEDEC_QUERY) {\r\nmap_write(map, CMD(0x90), chip->start);\r\nchip->state = FL_JEDEC_QUERY;\r\n}\r\nmap_copy_from(map, buf, chip->start + offset, size);\r\nxip_enable(map, chip, chip->start);\r\nINVALIDATE_CACHED_RANGE(map, chip->start + offset, size);\r\nput_chip(map, chip, chip->start);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_otp_write(struct map_info *map, struct flchip *chip, u_long offset,\r\nu_char *buf, u_int size, u_long prot, u_int grpno, u_int grpsz)\r\n{\r\nint ret;\r\nwhile (size) {\r\nunsigned long bus_ofs = offset & ~(map_bankwidth(map)-1);\r\nint gap = offset - bus_ofs;\r\nint n = min_t(int, size, map_bankwidth(map)-gap);\r\nmap_word datum = map_word_ff(map);\r\ndatum = map_word_load_partial(map, datum, buf, gap, n);\r\nret = do_write_oneword(map, chip, bus_ofs, datum, FL_OTP_WRITE);\r\nif (ret)\r\nreturn ret;\r\noffset += n;\r\nbuf += n;\r\nsize -= n;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndo_otp_lock(struct map_info *map, struct flchip *chip, u_long offset,\r\nu_char *buf, u_int size, u_long prot, u_int grpno, u_int grpsz)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nmap_word datum;\r\nif (size != grpsz)\r\nreturn -EXDEV;\r\ndatum = map_word_ff(map);\r\ndatum = map_word_clr(map, datum, CMD(1 << grpno));\r\nreturn do_write_oneword(map, chip, prot, datum, FL_OTP_WRITE);\r\n}\r\nstatic int cfi_intelext_otp_walk(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf,\r\notp_op_t action, int user_regs)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nstruct flchip *chip;\r\nstruct cfi_intelext_otpinfo *otp;\r\nu_long devsize, reg_prot_offset, data_offset;\r\nu_int chip_num, chip_step, field, reg_fact_size, reg_user_size;\r\nu_int groups, groupno, groupsize, reg_fact_groups, reg_user_groups;\r\nint ret;\r\n*retlen = 0;\r\nif (!extp || !(extp->FeatureSupport & 64) || !extp->NumProtectionFields)\r\nreturn -ENODATA;\r\ndevsize = (1 << cfi->cfiq->DevSize) * cfi->interleave;\r\nchip_step = devsize >> cfi->chipshift;\r\nchip_num = 0;\r\nif (cfi->mfr == CFI_MFR_INTEL) {\r\nswitch (cfi->id) {\r\ncase 0x880b:\r\ncase 0x880c:\r\ncase 0x880d:\r\nchip_num = chip_step - 1;\r\n}\r\n}\r\nfor ( ; chip_num < cfi->numchips; chip_num += chip_step) {\r\nchip = &cfi->chips[chip_num];\r\notp = (struct cfi_intelext_otpinfo *)&extp->extra[0];\r\nfield = 0;\r\nreg_prot_offset = extp->ProtRegAddr;\r\nreg_fact_groups = 1;\r\nreg_fact_size = 1 << extp->FactProtRegSize;\r\nreg_user_groups = 1;\r\nreg_user_size = 1 << extp->UserProtRegSize;\r\nwhile (len > 0) {\r\ndata_offset = reg_prot_offset + 1;\r\ndata_offset *= cfi->interleave * cfi->device_type;\r\nreg_prot_offset *= cfi->interleave * cfi->device_type;\r\nreg_fact_size *= cfi->interleave;\r\nreg_user_size *= cfi->interleave;\r\nif (user_regs) {\r\ngroups = reg_user_groups;\r\ngroupsize = reg_user_size;\r\ngroupno = reg_fact_groups;\r\ndata_offset += reg_fact_groups * reg_fact_size;\r\n} else {\r\ngroups = reg_fact_groups;\r\ngroupsize = reg_fact_size;\r\ngroupno = 0;\r\n}\r\nwhile (len > 0 && groups > 0) {\r\nif (!action) {\r\nstruct otp_info *otpinfo;\r\nmap_word lockword;\r\nlen -= sizeof(struct otp_info);\r\nif (len <= 0)\r\nreturn -ENOSPC;\r\nret = do_otp_read(map, chip,\r\nreg_prot_offset,\r\n(u_char *)&lockword,\r\nmap_bankwidth(map),\r\n0, 0, 0);\r\nif (ret)\r\nreturn ret;\r\notpinfo = (struct otp_info *)buf;\r\notpinfo->start = from;\r\notpinfo->length = groupsize;\r\notpinfo->locked =\r\n!map_word_bitsset(map, lockword,\r\nCMD(1 << groupno));\r\nfrom += groupsize;\r\nbuf += sizeof(*otpinfo);\r\n*retlen += sizeof(*otpinfo);\r\n} else if (from >= groupsize) {\r\nfrom -= groupsize;\r\ndata_offset += groupsize;\r\n} else {\r\nint size = groupsize;\r\ndata_offset += from;\r\nsize -= from;\r\nfrom = 0;\r\nif (size > len)\r\nsize = len;\r\nret = action(map, chip, data_offset,\r\nbuf, size, reg_prot_offset,\r\ngroupno, groupsize);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf += size;\r\nlen -= size;\r\n*retlen += size;\r\ndata_offset += size;\r\n}\r\ngroupno++;\r\ngroups--;\r\n}\r\nif (++field == extp->NumProtectionFields)\r\nbreak;\r\nreg_prot_offset = otp->ProtRegAddr;\r\nreg_fact_groups = otp->FactGroups;\r\nreg_fact_size = 1 << otp->FactProtRegSize;\r\nreg_user_groups = otp->UserGroups;\r\nreg_user_size = 1 << otp->UserProtRegSize;\r\notp++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfi_intelext_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen,\r\nu_char *buf)\r\n{\r\nreturn cfi_intelext_otp_walk(mtd, from, len, retlen,\r\nbuf, do_otp_read, 0);\r\n}\r\nstatic int cfi_intelext_read_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen,\r\nu_char *buf)\r\n{\r\nreturn cfi_intelext_otp_walk(mtd, from, len, retlen,\r\nbuf, do_otp_read, 1);\r\n}\r\nstatic int cfi_intelext_write_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen,\r\nu_char *buf)\r\n{\r\nreturn cfi_intelext_otp_walk(mtd, from, len, retlen,\r\nbuf, do_otp_write, 1);\r\n}\r\nstatic int cfi_intelext_lock_user_prot_reg(struct mtd_info *mtd,\r\nloff_t from, size_t len)\r\n{\r\nsize_t retlen;\r\nreturn cfi_intelext_otp_walk(mtd, from, len, &retlen,\r\nNULL, do_otp_lock, 1);\r\n}\r\nstatic int cfi_intelext_get_fact_prot_info(struct mtd_info *mtd,\r\nstruct otp_info *buf, size_t len)\r\n{\r\nsize_t retlen;\r\nint ret;\r\nret = cfi_intelext_otp_walk(mtd, 0, len, &retlen, (u_char *)buf, NULL, 0);\r\nreturn ret ? : retlen;\r\n}\r\nstatic int cfi_intelext_get_user_prot_info(struct mtd_info *mtd,\r\nstruct otp_info *buf, size_t len)\r\n{\r\nsize_t retlen;\r\nint ret;\r\nret = cfi_intelext_otp_walk(mtd, 0, len, &retlen, (u_char *)buf, NULL, 1);\r\nreturn ret ? : retlen;\r\n}\r\nstatic void cfi_intelext_save_locks(struct mtd_info *mtd)\r\n{\r\nstruct mtd_erase_region_info *region;\r\nint block, status, i;\r\nunsigned long adr;\r\nsize_t len;\r\nfor (i = 0; i < mtd->numeraseregions; i++) {\r\nregion = &mtd->eraseregions[i];\r\nif (!region->lockmap)\r\ncontinue;\r\nfor (block = 0; block < region->numblocks; block++){\r\nlen = region->erasesize;\r\nadr = region->offset + block * len;\r\nstatus = cfi_varsize_frob(mtd,\r\ndo_getlockstatus_oneblock, adr, len, NULL);\r\nif (status)\r\nset_bit(block, region->lockmap);\r\nelse\r\nclear_bit(block, region->lockmap);\r\n}\r\n}\r\n}\r\nstatic int cfi_intelext_suspend(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nint i;\r\nstruct flchip *chip;\r\nint ret = 0;\r\nif ((mtd->flags & MTD_POWERUP_LOCK)\r\n&& extp && (extp->FeatureSupport & (1 << 5)))\r\ncfi_intelext_save_locks(mtd);\r\nfor (i=0; !ret && i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nswitch (chip->state) {\r\ncase FL_READY:\r\ncase FL_STATUS:\r\ncase FL_CFI_QUERY:\r\ncase FL_JEDEC_QUERY:\r\nif (chip->oldstate == FL_READY) {\r\nmap_write(map, CMD(0xFF), cfi->chips[i].start);\r\nchip->oldstate = chip->state;\r\nchip->state = FL_PM_SUSPENDED;\r\n} else {\r\nprintk(KERN_NOTICE "Flash device refused suspend due to pending operation (oldstate %d)\n", chip->oldstate);\r\nret = -EAGAIN;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_NOTICE "Flash device refused suspend due to active operation (state %d)\n", chip->state);\r\nret = -EAGAIN;\r\ncase FL_PM_SUSPENDED:\r\nbreak;\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nif (ret) {\r\nfor (i--; i >=0; i--) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_PM_SUSPENDED) {\r\nchip->state = chip->oldstate;\r\nchip->oldstate = FL_READY;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void cfi_intelext_restore_locks(struct mtd_info *mtd)\r\n{\r\nstruct mtd_erase_region_info *region;\r\nint block, i;\r\nunsigned long adr;\r\nsize_t len;\r\nfor (i = 0; i < mtd->numeraseregions; i++) {\r\nregion = &mtd->eraseregions[i];\r\nif (!region->lockmap)\r\ncontinue;\r\nfor_each_clear_bit(block, region->lockmap, region->numblocks) {\r\nlen = region->erasesize;\r\nadr = region->offset + block * len;\r\ncfi_intelext_unlock(mtd, adr, len);\r\n}\r\n}\r\n}\r\nstatic void cfi_intelext_resume(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\r\nint i;\r\nstruct flchip *chip;\r\nfor (i=0; i<cfi->numchips; i++) {\r\nchip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nif (chip->state == FL_PM_SUSPENDED) {\r\nmap_write(map, CMD(0xFF), cfi->chips[i].start);\r\nchip->oldstate = chip->state = FL_READY;\r\nwake_up(&chip->wq);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nif ((mtd->flags & MTD_POWERUP_LOCK)\r\n&& extp && (extp->FeatureSupport & (1 << 5)))\r\ncfi_intelext_restore_locks(mtd);\r\n}\r\nstatic int cfi_intelext_reset(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nint i, ret;\r\nfor (i=0; i < cfi->numchips; i++) {\r\nstruct flchip *chip = &cfi->chips[i];\r\nmutex_lock(&chip->mutex);\r\nret = get_chip(map, chip, chip->start, FL_SHUTDOWN);\r\nif (!ret) {\r\nmap_write(map, CMD(0xff), chip->start);\r\nchip->state = FL_SHUTDOWN;\r\nput_chip(map, chip, chip->start);\r\n}\r\nmutex_unlock(&chip->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfi_intelext_reboot(struct notifier_block *nb, unsigned long val,\r\nvoid *v)\r\n{\r\nstruct mtd_info *mtd;\r\nmtd = container_of(nb, struct mtd_info, reboot_notifier);\r\ncfi_intelext_reset(mtd);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void cfi_intelext_destroy(struct mtd_info *mtd)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct mtd_erase_region_info *region;\r\nint i;\r\ncfi_intelext_reset(mtd);\r\nunregister_reboot_notifier(&mtd->reboot_notifier);\r\nkfree(cfi->cmdset_priv);\r\nkfree(cfi->cfiq);\r\nkfree(cfi->chips[0].priv);\r\nkfree(cfi);\r\nfor (i = 0; i < mtd->numeraseregions; i++) {\r\nregion = &mtd->eraseregions[i];\r\nif (region->lockmap)\r\nkfree(region->lockmap);\r\n}\r\nkfree(mtd->eraseregions);\r\n}
