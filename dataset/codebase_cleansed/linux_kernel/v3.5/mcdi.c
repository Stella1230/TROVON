static inline struct efx_mcdi_iface *efx_mcdi(struct efx_nic *efx)\r\n{\r\nstruct siena_nic_data *nic_data;\r\nEFX_BUG_ON_PARANOID(efx_nic_rev(efx) < EFX_REV_SIENA_A0);\r\nnic_data = efx->nic_data;\r\nreturn &nic_data->mcdi;\r\n}\r\nvoid efx_mcdi_init(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi;\r\nif (efx_nic_rev(efx) < EFX_REV_SIENA_A0)\r\nreturn;\r\nmcdi = efx_mcdi(efx);\r\ninit_waitqueue_head(&mcdi->wq);\r\nspin_lock_init(&mcdi->iface_lock);\r\natomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);\r\nmcdi->mode = MCDI_MODE_POLL;\r\n(void) efx_mcdi_poll_reboot(efx);\r\n}\r\nstatic void efx_mcdi_copyin(struct efx_nic *efx, unsigned cmd,\r\nconst u8 *inbuf, size_t inlen)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nunsigned pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\r\nunsigned doorbell = FR_CZ_MC_TREG_SMEM + MCDI_DOORBELL(efx);\r\nunsigned int i;\r\nefx_dword_t hdr;\r\nu32 xflags, seqno;\r\nBUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);\r\nBUG_ON(inlen & 3 || inlen >= MC_SMEM_PDU_LEN);\r\nseqno = mcdi->seqno & SEQ_MASK;\r\nxflags = 0;\r\nif (mcdi->mode == MCDI_MODE_EVENTS)\r\nxflags |= MCDI_HEADER_XFLAGS_EVREQ;\r\nEFX_POPULATE_DWORD_6(hdr,\r\nMCDI_HEADER_RESPONSE, 0,\r\nMCDI_HEADER_RESYNC, 1,\r\nMCDI_HEADER_CODE, cmd,\r\nMCDI_HEADER_DATALEN, inlen,\r\nMCDI_HEADER_SEQ, seqno,\r\nMCDI_HEADER_XFLAGS, xflags);\r\nefx_writed(efx, &hdr, pdu);\r\nfor (i = 0; i < inlen; i += 4)\r\n_efx_writed(efx, *((__le32 *)(inbuf + i)), pdu + 4 + i);\r\nwmb();\r\n_efx_writed(efx, (__force __le32) 0x45789abc, doorbell);\r\n}\r\nstatic void efx_mcdi_copyout(struct efx_nic *efx, u8 *outbuf, size_t outlen)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nunsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\r\nint i;\r\nBUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);\r\nBUG_ON(outlen & 3 || outlen >= MC_SMEM_PDU_LEN);\r\nfor (i = 0; i < outlen; i += 4)\r\n*((__le32 *)(outbuf + i)) = _efx_readd(efx, pdu + 4 + i);\r\n}\r\nstatic int efx_mcdi_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nunsigned int time, finish;\r\nunsigned int respseq, respcmd, error;\r\nunsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);\r\nunsigned int rc, spins;\r\nefx_dword_t reg;\r\nrc = -efx_mcdi_poll_reboot(efx);\r\nif (rc)\r\ngoto out;\r\nspins = TICK_USEC;\r\nfinish = get_seconds() + MCDI_RPC_TIMEOUT;\r\nwhile (1) {\r\nif (spins != 0) {\r\n--spins;\r\nudelay(1);\r\n} else {\r\nschedule_timeout_uninterruptible(1);\r\n}\r\ntime = get_seconds();\r\nrmb();\r\nefx_readd(efx, &reg, pdu);\r\nif (EFX_DWORD_FIELD(reg, EFX_DWORD_0) != 0xffffffff &&\r\nEFX_DWORD_FIELD(reg, MCDI_HEADER_RESPONSE))\r\nbreak;\r\nif (time >= finish)\r\nreturn -ETIMEDOUT;\r\n}\r\nmcdi->resplen = EFX_DWORD_FIELD(reg, MCDI_HEADER_DATALEN);\r\nrespseq = EFX_DWORD_FIELD(reg, MCDI_HEADER_SEQ);\r\nrespcmd = EFX_DWORD_FIELD(reg, MCDI_HEADER_CODE);\r\nerror = EFX_DWORD_FIELD(reg, MCDI_HEADER_ERROR);\r\nif (error && mcdi->resplen == 0) {\r\nnetif_err(efx, hw, efx->net_dev, "MC rebooted\n");\r\nrc = EIO;\r\n} else if ((respseq ^ mcdi->seqno) & SEQ_MASK) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC response mismatch tx seq 0x%x rx seq 0x%x\n",\r\nrespseq, mcdi->seqno);\r\nrc = EIO;\r\n} else if (error) {\r\nefx_readd(efx, &reg, pdu + 4);\r\nswitch (EFX_DWORD_FIELD(reg, EFX_DWORD_0)) {\r\n#define TRANSLATE_ERROR(name) \\r\ncase MC_CMD_ERR_ ## name: \\r\nrc = name; \\r\nbreak\r\nTRANSLATE_ERROR(ENOENT);\r\nTRANSLATE_ERROR(EINTR);\r\nTRANSLATE_ERROR(EACCES);\r\nTRANSLATE_ERROR(EBUSY);\r\nTRANSLATE_ERROR(EINVAL);\r\nTRANSLATE_ERROR(EDEADLK);\r\nTRANSLATE_ERROR(ENOSYS);\r\nTRANSLATE_ERROR(ETIME);\r\n#undef TRANSLATE_ERROR\r\ndefault:\r\nrc = EIO;\r\nbreak;\r\n}\r\n} else\r\nrc = 0;\r\nout:\r\nmcdi->resprc = rc;\r\nif (rc)\r\nmcdi->resplen = 0;\r\nreturn 0;\r\n}\r\nint efx_mcdi_poll_reboot(struct efx_nic *efx)\r\n{\r\nunsigned int addr = FR_CZ_MC_TREG_SMEM + MCDI_STATUS(efx);\r\nefx_dword_t reg;\r\nuint32_t value;\r\nif (efx_nic_rev(efx) < EFX_REV_SIENA_A0)\r\nreturn false;\r\nefx_readd(efx, &reg, addr);\r\nvalue = EFX_DWORD_FIELD(reg, EFX_DWORD_0);\r\nif (value == 0)\r\nreturn 0;\r\nEFX_ZERO_DWORD(reg);\r\nefx_writed(efx, &reg, addr);\r\nif (value == MC_STATUS_DWORD_ASSERT)\r\nreturn -EINTR;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic void efx_mcdi_acquire(struct efx_mcdi_iface *mcdi)\r\n{\r\nwait_event(mcdi->wq,\r\natomic_cmpxchg(&mcdi->state,\r\nMCDI_STATE_QUIESCENT,\r\nMCDI_STATE_RUNNING)\r\n== MCDI_STATE_QUIESCENT);\r\n}\r\nstatic int efx_mcdi_await_completion(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nif (wait_event_timeout(\r\nmcdi->wq,\r\natomic_read(&mcdi->state) == MCDI_STATE_COMPLETED,\r\nmsecs_to_jiffies(MCDI_RPC_TIMEOUT * 1000)) == 0)\r\nreturn -ETIMEDOUT;\r\nif (mcdi->mode == MCDI_MODE_POLL)\r\nreturn efx_mcdi_poll(efx);\r\nreturn 0;\r\n}\r\nstatic bool efx_mcdi_complete(struct efx_mcdi_iface *mcdi)\r\n{\r\nif (atomic_cmpxchg(&mcdi->state,\r\nMCDI_STATE_RUNNING,\r\nMCDI_STATE_COMPLETED) == MCDI_STATE_RUNNING) {\r\nwake_up(&mcdi->wq);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void efx_mcdi_release(struct efx_mcdi_iface *mcdi)\r\n{\r\natomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);\r\nwake_up(&mcdi->wq);\r\n}\r\nstatic void efx_mcdi_ev_cpl(struct efx_nic *efx, unsigned int seqno,\r\nunsigned int datalen, unsigned int errno)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nbool wake = false;\r\nspin_lock(&mcdi->iface_lock);\r\nif ((seqno ^ mcdi->seqno) & SEQ_MASK) {\r\nif (mcdi->credits)\r\n--mcdi->credits;\r\nelse\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC response mismatch tx seq 0x%x rx "\r\n"seq 0x%x\n", seqno, mcdi->seqno);\r\n} else {\r\nmcdi->resprc = errno;\r\nmcdi->resplen = datalen;\r\nwake = true;\r\n}\r\nspin_unlock(&mcdi->iface_lock);\r\nif (wake)\r\nefx_mcdi_complete(mcdi);\r\n}\r\nint efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd,\r\nconst u8 *inbuf, size_t inlen, u8 *outbuf, size_t outlen,\r\nsize_t *outlen_actual)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nint rc;\r\nBUG_ON(efx_nic_rev(efx) < EFX_REV_SIENA_A0);\r\nefx_mcdi_acquire(mcdi);\r\nspin_lock_bh(&mcdi->iface_lock);\r\n++mcdi->seqno;\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nefx_mcdi_copyin(efx, cmd, inbuf, inlen);\r\nif (mcdi->mode == MCDI_MODE_POLL)\r\nrc = efx_mcdi_poll(efx);\r\nelse\r\nrc = efx_mcdi_await_completion(efx);\r\nif (rc != 0) {\r\nspin_lock_bh(&mcdi->iface_lock);\r\n++mcdi->seqno;\r\n++mcdi->credits;\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC command 0x%x inlen %d mode %d timed out\n",\r\ncmd, (int)inlen, mcdi->mode);\r\n} else {\r\nsize_t resplen;\r\nspin_lock_bh(&mcdi->iface_lock);\r\nrc = -mcdi->resprc;\r\nresplen = mcdi->resplen;\r\nspin_unlock_bh(&mcdi->iface_lock);\r\nif (rc == 0) {\r\nefx_mcdi_copyout(efx, outbuf,\r\nmin(outlen, mcdi->resplen + 3) & ~0x3);\r\nif (outlen_actual != NULL)\r\n*outlen_actual = resplen;\r\n} else if (cmd == MC_CMD_REBOOT && rc == -EIO)\r\n;\r\nelse if (rc == -EIO || rc == -EINTR) {\r\nnetif_err(efx, hw, efx->net_dev, "MC fatal error %d\n",\r\n-rc);\r\nefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\r\n} else\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"MC command 0x%x inlen %d failed rc=%d\n",\r\ncmd, (int)inlen, -rc);\r\nif (rc == -EIO || rc == -EINTR) {\r\nmsleep(MCDI_STATUS_SLEEP_MS);\r\nefx_mcdi_poll_reboot(efx);\r\n}\r\n}\r\nefx_mcdi_release(mcdi);\r\nreturn rc;\r\n}\r\nvoid efx_mcdi_mode_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi;\r\nif (efx_nic_rev(efx) < EFX_REV_SIENA_A0)\r\nreturn;\r\nmcdi = efx_mcdi(efx);\r\nif (mcdi->mode == MCDI_MODE_POLL)\r\nreturn;\r\nmcdi->mode = MCDI_MODE_POLL;\r\nefx_mcdi_complete(mcdi);\r\n}\r\nvoid efx_mcdi_mode_event(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_iface *mcdi;\r\nif (efx_nic_rev(efx) < EFX_REV_SIENA_A0)\r\nreturn;\r\nmcdi = efx_mcdi(efx);\r\nif (mcdi->mode == MCDI_MODE_EVENTS)\r\nreturn;\r\nefx_mcdi_acquire(mcdi);\r\nmcdi->mode = MCDI_MODE_EVENTS;\r\nefx_mcdi_release(mcdi);\r\n}\r\nstatic void efx_mcdi_ev_death(struct efx_nic *efx, int rc)\r\n{\r\nstruct efx_mcdi_iface *mcdi = efx_mcdi(efx);\r\nspin_lock(&mcdi->iface_lock);\r\nif (efx_mcdi_complete(mcdi)) {\r\nif (mcdi->mode == MCDI_MODE_EVENTS) {\r\nmcdi->resprc = rc;\r\nmcdi->resplen = 0;\r\n++mcdi->credits;\r\n}\r\n} else {\r\nint count;\r\nefx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);\r\nfor (count = 0; count < MCDI_STATUS_DELAY_COUNT; ++count) {\r\nif (efx_mcdi_poll_reboot(efx))\r\nbreak;\r\nudelay(MCDI_STATUS_DELAY_US);\r\n}\r\n}\r\nspin_unlock(&mcdi->iface_lock);\r\n}\r\nstatic void efx_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev)\r\n{\r\nu32 flags, fcntl, speed, lpa;\r\nspeed = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_SPEED);\r\nEFX_BUG_ON_PARANOID(speed >= ARRAY_SIZE(efx_mcdi_event_link_speed));\r\nspeed = efx_mcdi_event_link_speed[speed];\r\nflags = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LINK_FLAGS);\r\nfcntl = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_FCNTL);\r\nlpa = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LP_CAP);\r\nefx_mcdi_phy_decode_link(efx, &efx->link_state, speed, flags, fcntl);\r\nefx_mcdi_phy_check_fcntl(efx, lpa);\r\nefx_link_status_changed(efx);\r\n}\r\nvoid efx_mcdi_process_event(struct efx_channel *channel,\r\nefx_qword_t *event)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nint code = EFX_QWORD_FIELD(*event, MCDI_EVENT_CODE);\r\nu32 data = EFX_QWORD_FIELD(*event, MCDI_EVENT_DATA);\r\nswitch (code) {\r\ncase MCDI_EVENT_CODE_BADSSERT:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MC watchdog or assertion failure at 0x%x\n", data);\r\nefx_mcdi_ev_death(efx, EINTR);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PMNOTICE:\r\nnetif_info(efx, wol, efx->net_dev, "MCDI PM event.\n");\r\nbreak;\r\ncase MCDI_EVENT_CODE_CMDDONE:\r\nefx_mcdi_ev_cpl(efx,\r\nMCDI_EVENT_FIELD(*event, CMDDONE_SEQ),\r\nMCDI_EVENT_FIELD(*event, CMDDONE_DATALEN),\r\nMCDI_EVENT_FIELD(*event, CMDDONE_ERRNO));\r\nbreak;\r\ncase MCDI_EVENT_CODE_LINKCHANGE:\r\nefx_mcdi_process_link_change(efx, event);\r\nbreak;\r\ncase MCDI_EVENT_CODE_SENSOREVT:\r\nefx_mcdi_sensor_event(efx, event);\r\nbreak;\r\ncase MCDI_EVENT_CODE_SCHEDERR:\r\nnetif_info(efx, hw, efx->net_dev,\r\n"MC Scheduler error address=0x%x\n", data);\r\nbreak;\r\ncase MCDI_EVENT_CODE_REBOOT:\r\nnetif_info(efx, hw, efx->net_dev, "MC Reboot\n");\r\nefx_mcdi_ev_death(efx, EIO);\r\nbreak;\r\ncase MCDI_EVENT_CODE_MAC_STATS_DMA:\r\nbreak;\r\ncase MCDI_EVENT_CODE_FLR:\r\nefx_sriov_flr(efx, MCDI_EVENT_FIELD(*event, FLR_VF));\r\nbreak;\r\ndefault:\r\nnetif_err(efx, hw, efx->net_dev, "Unknown MCDI event 0x%x\n",\r\ncode);\r\n}\r\n}\r\nvoid efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len)\r\n{\r\nu8 outbuf[ALIGN(MC_CMD_GET_VERSION_OUT_LEN, 4)];\r\nsize_t outlength;\r\nconst __le16 *ver_words;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_VERSION_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_VERSION, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlength);\r\nif (rc)\r\ngoto fail;\r\nif (outlength < MC_CMD_GET_VERSION_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nver_words = (__le16 *)MCDI_PTR(outbuf, GET_VERSION_OUT_VERSION);\r\nsnprintf(buf, len, "%u.%u.%u.%u",\r\nle16_to_cpu(ver_words[0]), le16_to_cpu(ver_words[1]),\r\nle16_to_cpu(ver_words[2]), le16_to_cpu(ver_words[3]));\r\nreturn;\r\nfail:\r\nnetif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nbuf[0] = 0;\r\n}\r\nint efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,\r\nbool *was_attached)\r\n{\r\nu8 inbuf[MC_CMD_DRV_ATTACH_IN_LEN];\r\nu8 outbuf[MC_CMD_DRV_ATTACH_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_NEW_STATE,\r\ndriver_operating ? 1 : 0);\r\nMCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_UPDATE, 1);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_DRV_ATTACH, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_DRV_ATTACH_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nif (was_attached != NULL)\r\n*was_attached = MCDI_DWORD(outbuf, DRV_ATTACH_OUT_OLD_STATE);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,\r\nu16 *fw_subtype_list, u32 *capabilities)\r\n{\r\nuint8_t outbuf[MC_CMD_GET_BOARD_CFG_OUT_LENMIN];\r\nsize_t outlen;\r\nint port_num = efx_port_num(efx);\r\nint offset;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_BOARD_CFG, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_GET_BOARD_CFG_OUT_LENMIN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\noffset = (port_num)\r\n? MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST\r\n: MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST;\r\nif (mac_address)\r\nmemcpy(mac_address, outbuf + offset, ETH_ALEN);\r\nif (fw_subtype_list)\r\nmemcpy(fw_subtype_list,\r\noutbuf + MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST,\r\nMC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MINNUM *\r\nsizeof(fw_subtype_list[0]));\r\nif (capabilities) {\r\nif (port_num)\r\n*capabilities = MCDI_DWORD(outbuf,\r\nGET_BOARD_CFG_OUT_CAPABILITIES_PORT1);\r\nelse\r\n*capabilities = MCDI_DWORD(outbuf,\r\nGET_BOARD_CFG_OUT_CAPABILITIES_PORT0);\r\n}\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d len=%d\n",\r\n__func__, rc, (int)outlen);\r\nreturn rc;\r\n}\r\nint efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq)\r\n{\r\nu8 inbuf[MC_CMD_LOG_CTRL_IN_LEN];\r\nu32 dest = 0;\r\nint rc;\r\nif (uart)\r\ndest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_UART;\r\nif (evq)\r\ndest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ;\r\nMCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST, dest);\r\nMCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST_EVQ, dest_evq);\r\nBUILD_BUG_ON(MC_CMD_LOG_CTRL_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_LOG_CTRL, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out)\r\n{\r\nu8 outbuf[MC_CMD_NVRAM_TYPES_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_NVRAM_TYPES_IN_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TYPES, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_NVRAM_TYPES_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*nvram_types_out = MCDI_DWORD(outbuf, NVRAM_TYPES_OUT_TYPES);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,\r\nsize_t *size_out, size_t *erase_size_out,\r\nbool *protected_out)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_INFO_IN_LEN];\r\nu8 outbuf[MC_CMD_NVRAM_INFO_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_INFO_IN_TYPE, type);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_INFO, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_NVRAM_INFO_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_SIZE);\r\n*erase_size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_ERASESIZE);\r\n*protected_out = !!(MCDI_DWORD(outbuf, NVRAM_INFO_OUT_FLAGS) &\r\n(1 << MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN));\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_update_start(struct efx_nic *efx, unsigned int type)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_UPDATE_START_IN_LEN];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_UPDATE_START_IN_TYPE, type);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_START_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_START, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,\r\nloff_t offset, u8 *buffer, size_t length)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_READ_IN_LEN];\r\nu8 outbuf[MC_CMD_NVRAM_READ_OUT_LEN(EFX_MCDI_NVRAM_LEN_MAX)];\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_OFFSET, offset);\r\nMCDI_SET_DWORD(inbuf, NVRAM_READ_IN_LENGTH, length);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_READ, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nmemcpy(buffer, MCDI_PTR(outbuf, NVRAM_READ_OUT_READ_BUFFER), length);\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,\r\nloff_t offset, const u8 *buffer, size_t length)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_WRITE_IN_LEN(EFX_MCDI_NVRAM_LEN_MAX)];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_OFFSET, offset);\r\nMCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_LENGTH, length);\r\nmemcpy(MCDI_PTR(inbuf, NVRAM_WRITE_IN_WRITE_BUFFER), buffer, length);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_WRITE_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_WRITE, inbuf,\r\nALIGN(MC_CMD_NVRAM_WRITE_IN_LEN(length), 4),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,\r\nloff_t offset, size_t length)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_ERASE_IN_LEN];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_OFFSET, offset);\r\nMCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_LENGTH, length);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_ERASE_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_ERASE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_nvram_update_finish(struct efx_nic *efx, unsigned int type)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_TYPE, type);\r\nBUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN != 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_FINISH, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_nvram_test(struct efx_nic *efx, unsigned int type)\r\n{\r\nu8 inbuf[MC_CMD_NVRAM_TEST_IN_LEN];\r\nu8 outbuf[MC_CMD_NVRAM_TEST_OUT_LEN];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, NVRAM_TEST_IN_TYPE, type);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TEST, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\nreturn rc;\r\nswitch (MCDI_DWORD(outbuf, NVRAM_TEST_OUT_RESULT)) {\r\ncase MC_CMD_NVRAM_TEST_PASS:\r\ncase MC_CMD_NVRAM_TEST_NOTSUPP:\r\nreturn 0;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nint efx_mcdi_nvram_test_all(struct efx_nic *efx)\r\n{\r\nu32 nvram_types;\r\nunsigned int type;\r\nint rc;\r\nrc = efx_mcdi_nvram_types(efx, &nvram_types);\r\nif (rc)\r\ngoto fail1;\r\ntype = 0;\r\nwhile (nvram_types != 0) {\r\nif (nvram_types & 1) {\r\nrc = efx_mcdi_nvram_test(efx, type);\r\nif (rc)\r\ngoto fail2;\r\n}\r\ntype++;\r\nnvram_types >>= 1;\r\n}\r\nreturn 0;\r\nfail2:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed type=%u\n",\r\n__func__, type);\r\nfail1:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_read_assertion(struct efx_nic *efx)\r\n{\r\nu8 inbuf[MC_CMD_GET_ASSERTS_IN_LEN];\r\nu8 outbuf[MC_CMD_GET_ASSERTS_OUT_LEN];\r\nunsigned int flags, index, ofst;\r\nconst char *reason;\r\nsize_t outlen;\r\nint retry;\r\nint rc;\r\nretry = 2;\r\ndo {\r\nMCDI_SET_DWORD(inbuf, GET_ASSERTS_IN_CLEAR, 1);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_GET_ASSERTS,\r\ninbuf, MC_CMD_GET_ASSERTS_IN_LEN,\r\noutbuf, sizeof(outbuf), &outlen);\r\n} while ((rc == -EINTR || rc == -EIO) && retry-- > 0);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < MC_CMD_GET_ASSERTS_OUT_LEN)\r\nreturn -EIO;\r\nflags = MCDI_DWORD(outbuf, GET_ASSERTS_OUT_GLOBAL_FLAGS);\r\nif (flags == MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS)\r\nreturn 0;\r\nreason = (flags == MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL)\r\n? "system-level assertion"\r\n: (flags == MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL)\r\n? "thread-level assertion"\r\n: (flags == MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED)\r\n? "watchdog reset"\r\n: "unknown assertion";\r\nnetif_err(efx, hw, efx->net_dev,\r\n"MCPU %s at PC = 0x%.8x in thread 0x%.8x\n", reason,\r\nMCDI_DWORD(outbuf, GET_ASSERTS_OUT_SAVED_PC_OFFS),\r\nMCDI_DWORD(outbuf, GET_ASSERTS_OUT_THREAD_OFFS));\r\nofst = MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST;\r\nfor (index = 1; index < 32; index++) {\r\nnetif_err(efx, hw, efx->net_dev, "R%.2d (?): 0x%.8x\n", index,\r\nMCDI_DWORD2(outbuf, ofst));\r\nofst += sizeof(efx_dword_t);\r\n}\r\nreturn 0;\r\n}\r\nstatic void efx_mcdi_exit_assertion(struct efx_nic *efx)\r\n{\r\nu8 inbuf[MC_CMD_REBOOT_IN_LEN];\r\nBUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS,\r\nMC_CMD_REBOOT_FLAGS_AFTER_ASSERTION);\r\nefx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, MC_CMD_REBOOT_IN_LEN,\r\nNULL, 0, NULL);\r\n}\r\nint efx_mcdi_handle_assertion(struct efx_nic *efx)\r\n{\r\nint rc;\r\nrc = efx_mcdi_read_assertion(efx);\r\nif (rc)\r\nreturn rc;\r\nefx_mcdi_exit_assertion(efx);\r\nreturn 0;\r\n}\r\nvoid efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nu8 inbuf[MC_CMD_SET_ID_LED_IN_LEN];\r\nint rc;\r\nBUILD_BUG_ON(EFX_LED_OFF != MC_CMD_LED_OFF);\r\nBUILD_BUG_ON(EFX_LED_ON != MC_CMD_LED_ON);\r\nBUILD_BUG_ON(EFX_LED_DEFAULT != MC_CMD_LED_DEFAULT);\r\nBUILD_BUG_ON(MC_CMD_SET_ID_LED_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, SET_ID_LED_IN_STATE, mode);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_SET_ID_LED, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\n}\r\nint efx_mcdi_reset_port(struct efx_nic *efx)\r\n{\r\nint rc = efx_mcdi_rpc(efx, MC_CMD_ENTITY_RESET, NULL, 0, NULL, 0, NULL);\r\nif (rc)\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",\r\n__func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_reset_mc(struct efx_nic *efx)\r\n{\r\nu8 inbuf[MC_CMD_REBOOT_IN_LEN];\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);\r\nMCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS, 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc == -EIO)\r\nreturn 0;\r\nif (rc == 0)\r\nrc = -EIO;\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_wol_filter_set(struct efx_nic *efx, u32 type,\r\nconst u8 *mac, int *id_out)\r\n{\r\nu8 inbuf[MC_CMD_WOL_FILTER_SET_IN_LEN];\r\nu8 outbuf[MC_CMD_WOL_FILTER_SET_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_WOL_TYPE, type);\r\nMCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_FILTER_MODE,\r\nMC_CMD_FILTER_MODE_SIMPLE);\r\nmemcpy(MCDI_PTR(inbuf, WOL_FILTER_SET_IN_MAGIC_MAC), mac, ETH_ALEN);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_SET, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_WOL_FILTER_SET_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_SET_OUT_FILTER_ID);\r\nreturn 0;\r\nfail:\r\n*id_out = -1;\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint\r\nefx_mcdi_wol_filter_set_magic(struct efx_nic *efx, const u8 *mac, int *id_out)\r\n{\r\nreturn efx_mcdi_wol_filter_set(efx, MC_CMD_WOL_TYPE_MAGIC, mac, id_out);\r\n}\r\nint efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out)\r\n{\r\nu8 outbuf[MC_CMD_WOL_FILTER_GET_OUT_LEN];\r\nsize_t outlen;\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_GET, NULL, 0,\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_WOL_FILTER_GET_OUT_LEN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_GET_OUT_FILTER_ID);\r\nreturn 0;\r\nfail:\r\n*id_out = -1;\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id)\r\n{\r\nu8 inbuf[MC_CMD_WOL_FILTER_REMOVE_IN_LEN];\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, WOL_FILTER_REMOVE_IN_FILTER_ID, (u32)id);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_REMOVE, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint efx_mcdi_flush_rxqs(struct efx_nic *efx)\r\n{\r\nstruct efx_channel *channel;\r\nstruct efx_rx_queue *rx_queue;\r\n__le32 *qid;\r\nint rc, count;\r\nqid = kmalloc(EFX_MAX_CHANNELS * sizeof(*qid), GFP_KERNEL);\r\nif (qid == NULL)\r\nreturn -ENOMEM;\r\ncount = 0;\r\nefx_for_each_channel(channel, efx) {\r\nefx_for_each_channel_rx_queue(rx_queue, channel) {\r\nif (rx_queue->flush_pending) {\r\nrx_queue->flush_pending = false;\r\natomic_dec(&efx->rxq_flush_pending);\r\nqid[count++] = cpu_to_le32(\r\nefx_rx_queue_index(rx_queue));\r\n}\r\n}\r\n}\r\nrc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, (u8 *)qid,\r\ncount * sizeof(*qid), NULL, 0, NULL);\r\nWARN_ON(rc > 0);\r\nkfree(qid);\r\nreturn rc;\r\n}\r\nint efx_mcdi_wol_filter_reset(struct efx_nic *efx)\r\n{\r\nint rc;\r\nrc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_RESET, NULL, 0, NULL, 0, NULL);\r\nif (rc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nnetif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);\r\nreturn rc;\r\n}
