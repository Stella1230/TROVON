static long get_driver_data(int cstate)\r\n{\r\nint driver_data;\r\nswitch (cstate) {\r\ncase 1:\r\ndriver_data = 0x00;\r\nbreak;\r\ncase 2:\r\ndriver_data = 0x10;\r\nbreak;\r\ncase 3:\r\ndriver_data = 0x20;\r\nbreak;\r\ncase 4:\r\ndriver_data = 0x30;\r\nbreak;\r\ncase 5:\r\ndriver_data = 0x40;\r\nbreak;\r\ncase 6:\r\ndriver_data = 0x52;\r\nbreak;\r\ndefault:\r\ndriver_data = 0x00;\r\n}\r\nreturn driver_data;\r\n}\r\nstatic int intel_idle(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv, int index)\r\n{\r\nunsigned long ecx = 1;\r\nstruct cpuidle_state *state = &drv->states[index];\r\nstruct cpuidle_state_usage *state_usage = &dev->states_usage[index];\r\nunsigned long eax = (unsigned long)cpuidle_get_statedata(state_usage);\r\nunsigned int cstate;\r\nktime_t kt_before, kt_after;\r\ns64 usec_delta;\r\nint cpu = smp_processor_id();\r\ncstate = (((eax) >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) + 1;\r\nif (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)\r\nleave_mm(cpu);\r\nif (!(lapic_timer_reliable_states & (1 << (cstate))))\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);\r\nkt_before = ktime_get_real();\r\nstop_critical_timings();\r\nif (!need_resched()) {\r\n__monitor((void *)&current_thread_info()->flags, 0, 0);\r\nsmp_mb();\r\nif (!need_resched())\r\n__mwait(eax, ecx);\r\n}\r\nstart_critical_timings();\r\nkt_after = ktime_get_real();\r\nusec_delta = ktime_to_us(ktime_sub(kt_after, kt_before));\r\nlocal_irq_enable();\r\nif (!(lapic_timer_reliable_states & (1 << (cstate))))\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);\r\ndev->last_residency = (int)usec_delta;\r\nreturn index;\r\n}\r\nstatic void __setup_broadcast_timer(void *arg)\r\n{\r\nunsigned long reason = (unsigned long)arg;\r\nint cpu = smp_processor_id();\r\nreason = reason ?\r\nCLOCK_EVT_NOTIFY_BROADCAST_ON : CLOCK_EVT_NOTIFY_BROADCAST_OFF;\r\nclockevents_notify(reason, &cpu);\r\n}\r\nstatic int setup_broadcast_cpuhp_notify(struct notifier_block *n,\r\nunsigned long action, void *hcpu)\r\n{\r\nint hotcpu = (unsigned long)hcpu;\r\nswitch (action & 0xf) {\r\ncase CPU_ONLINE:\r\nsmp_call_function_single(hotcpu, __setup_broadcast_timer,\r\n(void *)true, 1);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void auto_demotion_disable(void *dummy)\r\n{\r\nunsigned long long msr_bits;\r\nrdmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr_bits);\r\nmsr_bits &= ~(icpu->auto_demotion_disable_flags);\r\nwrmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr_bits);\r\n}\r\nstatic int intel_idle_probe(void)\r\n{\r\nunsigned int eax, ebx, ecx;\r\nconst struct x86_cpu_id *id;\r\nif (max_cstate == 0) {\r\npr_debug(PREFIX "disabled\n");\r\nreturn -EPERM;\r\n}\r\nid = x86_match_cpu(intel_idle_ids);\r\nif (!id) {\r\nif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\r\nboot_cpu_data.x86 == 6)\r\npr_debug(PREFIX "does not run on family %d model %d\n",\r\nboot_cpu_data.x86, boot_cpu_data.x86_model);\r\nreturn -ENODEV;\r\n}\r\nif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\r\nreturn -ENODEV;\r\ncpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &mwait_substates);\r\nif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\r\n!(ecx & CPUID5_ECX_INTERRUPT_BREAK) ||\r\n!mwait_substates)\r\nreturn -ENODEV;\r\npr_debug(PREFIX "MWAIT substates: 0x%x\n", mwait_substates);\r\nicpu = (const struct idle_cpu *)id->driver_data;\r\ncpuidle_state_table = icpu->state_table;\r\nif (boot_cpu_has(X86_FEATURE_ARAT))\r\nlapic_timer_reliable_states = LAPIC_TIMER_ALWAYS_RELIABLE;\r\nelse {\r\non_each_cpu(__setup_broadcast_timer, (void *)true, 1);\r\nregister_cpu_notifier(&setup_broadcast_notifier);\r\n}\r\npr_debug(PREFIX "v" INTEL_IDLE_VERSION\r\n" model 0x%X\n", boot_cpu_data.x86_model);\r\npr_debug(PREFIX "lapic_timer_reliable_states 0x%x\n",\r\nlapic_timer_reliable_states);\r\nreturn 0;\r\n}\r\nstatic void intel_idle_cpuidle_devices_uninit(void)\r\n{\r\nint i;\r\nstruct cpuidle_device *dev;\r\nfor_each_online_cpu(i) {\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, i);\r\ncpuidle_unregister_device(dev);\r\n}\r\nfree_percpu(intel_idle_cpuidle_devices);\r\nreturn;\r\n}\r\nstatic int intel_idle_cpuidle_driver_init(void)\r\n{\r\nint cstate;\r\nstruct cpuidle_driver *drv = &intel_idle_driver;\r\ndrv->state_count = 1;\r\nfor (cstate = 1; cstate < MWAIT_MAX_NUM_CSTATES; ++cstate) {\r\nint num_substates;\r\nif (cstate > max_cstate) {\r\nprintk(PREFIX "max_cstate %d reached\n",\r\nmax_cstate);\r\nbreak;\r\n}\r\nnum_substates = (mwait_substates >> ((cstate) * 4))\r\n& MWAIT_SUBSTATE_MASK;\r\nif (num_substates == 0)\r\ncontinue;\r\nif (cpuidle_state_table[cstate].enter == NULL) {\r\nif (*cpuidle_state_table[cstate].name == '\0')\r\npr_debug(PREFIX "unaware of model 0x%x"\r\n" MWAIT %d please"\r\n" contact lenb@kernel.org",\r\nboot_cpu_data.x86_model, cstate);\r\ncontinue;\r\n}\r\nif ((cstate > 2) &&\r\n!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))\r\nmark_tsc_unstable("TSC halts in idle"\r\n" states deeper than C2");\r\ndrv->states[drv->state_count] =\r\ncpuidle_state_table[cstate];\r\ndrv->state_count += 1;\r\n}\r\nif (icpu->auto_demotion_disable_flags)\r\non_each_cpu(auto_demotion_disable, NULL, 1);\r\nreturn 0;\r\n}\r\nint intel_idle_cpu_init(int cpu)\r\n{\r\nint cstate;\r\nstruct cpuidle_device *dev;\r\ndev = per_cpu_ptr(intel_idle_cpuidle_devices, cpu);\r\ndev->state_count = 1;\r\nfor (cstate = 1; cstate < MWAIT_MAX_NUM_CSTATES; ++cstate) {\r\nint num_substates;\r\nif (cstate > max_cstate) {\r\nprintk(PREFIX "max_cstate %d reached\n", max_cstate);\r\nbreak;\r\n}\r\nnum_substates = (mwait_substates >> ((cstate) * 4))\r\n& MWAIT_SUBSTATE_MASK;\r\nif (num_substates == 0)\r\ncontinue;\r\nif (cpuidle_state_table[cstate].enter == NULL)\r\ncontinue;\r\ndev->states_usage[dev->state_count].driver_data =\r\n(void *)get_driver_data(cstate);\r\ndev->state_count += 1;\r\n}\r\ndev->cpu = cpu;\r\nif (cpuidle_register_device(dev)) {\r\npr_debug(PREFIX "cpuidle_register_device %d failed!\n", cpu);\r\nintel_idle_cpuidle_devices_uninit();\r\nreturn -EIO;\r\n}\r\nif (icpu->auto_demotion_disable_flags)\r\nsmp_call_function_single(cpu, auto_demotion_disable, NULL, 1);\r\nreturn 0;\r\n}\r\nstatic int __init intel_idle_init(void)\r\n{\r\nint retval, i;\r\nif (boot_option_idle_override != IDLE_NO_OVERRIDE)\r\nreturn -ENODEV;\r\nretval = intel_idle_probe();\r\nif (retval)\r\nreturn retval;\r\nintel_idle_cpuidle_driver_init();\r\nretval = cpuidle_register_driver(&intel_idle_driver);\r\nif (retval) {\r\nprintk(KERN_DEBUG PREFIX "intel_idle yielding to %s",\r\ncpuidle_get_driver()->name);\r\nreturn retval;\r\n}\r\nintel_idle_cpuidle_devices = alloc_percpu(struct cpuidle_device);\r\nif (intel_idle_cpuidle_devices == NULL)\r\nreturn -ENOMEM;\r\nfor_each_online_cpu(i) {\r\nretval = intel_idle_cpu_init(i);\r\nif (retval) {\r\ncpuidle_unregister_driver(&intel_idle_driver);\r\nreturn retval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit intel_idle_exit(void)\r\n{\r\nintel_idle_cpuidle_devices_uninit();\r\ncpuidle_unregister_driver(&intel_idle_driver);\r\nif (lapic_timer_reliable_states != LAPIC_TIMER_ALWAYS_RELIABLE) {\r\non_each_cpu(__setup_broadcast_timer, (void *)false, 1);\r\nunregister_cpu_notifier(&setup_broadcast_notifier);\r\n}\r\nreturn;\r\n}
