int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)\r\n{\r\nextern asmlinkage void handle_dsemulret(void);\r\nstruct emuframe __user *fr;\r\nint err;\r\nif (ir == 0) {\r\nregs->cp0_epc = cpc;\r\nregs->cp0_cause &= ~CAUSEF_BD;\r\nreturn 0;\r\n}\r\n#ifdef DSEMUL_TRACE\r\nprintk("dsemul %lx %lx\n", regs->cp0_epc, cpc);\r\n#endif\r\nfr = (struct emuframe __user *)\r\n((regs->regs[29] - sizeof(struct emuframe)) & ~0x7);\r\nif (unlikely(!access_ok(VERIFY_WRITE, fr, sizeof(struct emuframe))))\r\nreturn SIGBUS;\r\nerr = __put_user(ir, &fr->emul);\r\nerr |= __put_user((mips_instruction)BREAK_MATH, &fr->badinst);\r\nerr |= __put_user((mips_instruction)BD_COOKIE, &fr->cookie);\r\nerr |= __put_user(cpc, &fr->epc);\r\nif (unlikely(err)) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\nreturn SIGBUS;\r\n}\r\nregs->cp0_epc = (unsigned long) &fr->emul;\r\nflush_cache_sigtramp((unsigned long)&fr->badinst);\r\nreturn SIGILL;\r\n}\r\nint do_dsemulret(struct pt_regs *xcp)\r\n{\r\nstruct emuframe __user *fr;\r\nunsigned long epc;\r\nu32 insn, cookie;\r\nint err = 0;\r\nfr = (struct emuframe __user *)\r\n(xcp->cp0_epc - sizeof(mips_instruction));\r\nif (!access_ok(VERIFY_READ, fr, sizeof(struct emuframe)))\r\nreturn 0;\r\nerr = __get_user(insn, &fr->badinst);\r\nerr |= __get_user(cookie, &fr->cookie);\r\nif (unlikely(err || (insn != BREAK_MATH) || (cookie != BD_COOKIE))) {\r\nMIPS_FPU_EMU_INC_STATS(errors);\r\nreturn 0;\r\n}\r\n#ifdef DSEMUL_TRACE\r\nprintk("dsemulret\n");\r\n#endif\r\nif (__get_user(epc, &fr->epc)) {\r\nforce_sig(SIGBUS, current);\r\nreturn 0;\r\n}\r\nxcp->cp0_epc = epc;\r\nreturn 1;\r\n}
