void local_flush_tlb_all(void)\r\n{\r\nunsigned long flags;\r\nunsigned long old_ctx;\r\nint entry;\r\n#ifdef DEBUG_TLB\r\nprintk("[tlball]");\r\n#endif\r\nlocal_irq_save(flags);\r\nold_ctx = read_c0_entryhi() & ASID_MASK;\r\nwrite_c0_entrylo0(0);\r\nentry = r3k_have_wired_reg ? read_c0_wired() : 8;\r\nfor (; entry < current_cpu_data.tlbsize; entry++) {\r\nwrite_c0_index(entry << 8);\r\nwrite_c0_entryhi((entry | 0x80000) << 12);\r\nBARRIER;\r\ntlb_write_indexed();\r\n}\r\nwrite_c0_entryhi(old_ctx);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid local_flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nint cpu = smp_processor_id();\r\nif (cpu_context(cpu, mm) != 0) {\r\n#ifdef DEBUG_TLB\r\nprintk("[tlbmm<%lu>]", (unsigned long)cpu_context(cpu, mm));\r\n#endif\r\ndrop_mmu_context(mm, cpu);\r\n}\r\n}\r\nvoid local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,\r\nunsigned long end)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nint cpu = smp_processor_id();\r\nif (cpu_context(cpu, mm) != 0) {\r\nunsigned long size, flags;\r\n#ifdef DEBUG_TLB\r\nprintk("[tlbrange<%lu,0x%08lx,0x%08lx>]",\r\ncpu_context(cpu, mm) & ASID_MASK, start, end);\r\n#endif\r\nlocal_irq_save(flags);\r\nsize = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\r\nif (size <= current_cpu_data.tlbsize) {\r\nint oldpid = read_c0_entryhi() & ASID_MASK;\r\nint newpid = cpu_context(cpu, mm) & ASID_MASK;\r\nstart &= PAGE_MASK;\r\nend += PAGE_SIZE - 1;\r\nend &= PAGE_MASK;\r\nwhile (start < end) {\r\nint idx;\r\nwrite_c0_entryhi(start | newpid);\r\nstart += PAGE_SIZE;\r\ntlb_probe();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entryhi(KSEG0);\r\nif (idx < 0)\r\ncontinue;\r\ntlb_write_indexed();\r\n}\r\nwrite_c0_entryhi(oldpid);\r\n} else {\r\ndrop_mmu_context(mm, cpu);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid local_flush_tlb_kernel_range(unsigned long start, unsigned long end)\r\n{\r\nunsigned long size, flags;\r\n#ifdef DEBUG_TLB\r\nprintk("[tlbrange<%lu,0x%08lx,0x%08lx>]", start, end);\r\n#endif\r\nlocal_irq_save(flags);\r\nsize = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\r\nif (size <= current_cpu_data.tlbsize) {\r\nint pid = read_c0_entryhi();\r\nstart &= PAGE_MASK;\r\nend += PAGE_SIZE - 1;\r\nend &= PAGE_MASK;\r\nwhile (start < end) {\r\nint idx;\r\nwrite_c0_entryhi(start);\r\nstart += PAGE_SIZE;\r\ntlb_probe();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entryhi(KSEG0);\r\nif (idx < 0)\r\ncontinue;\r\ntlb_write_indexed();\r\n}\r\nwrite_c0_entryhi(pid);\r\n} else {\r\nlocal_flush_tlb_all();\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nvoid local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)\r\n{\r\nint cpu = smp_processor_id();\r\nif (!vma || cpu_context(cpu, vma->vm_mm) != 0) {\r\nunsigned long flags;\r\nint oldpid, newpid, idx;\r\n#ifdef DEBUG_TLB\r\nprintk("[tlbpage<%lu,0x%08lx>]", cpu_context(cpu, vma->vm_mm), page);\r\n#endif\r\nnewpid = cpu_context(cpu, vma->vm_mm) & ASID_MASK;\r\npage &= PAGE_MASK;\r\nlocal_irq_save(flags);\r\noldpid = read_c0_entryhi() & ASID_MASK;\r\nwrite_c0_entryhi(page | newpid);\r\nBARRIER;\r\ntlb_probe();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(0);\r\nwrite_c0_entryhi(KSEG0);\r\nif (idx < 0)\r\ngoto finish;\r\ntlb_write_indexed();\r\nfinish:\r\nwrite_c0_entryhi(oldpid);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)\r\n{\r\nunsigned long flags;\r\nint idx, pid;\r\nif (current->active_mm != vma->vm_mm)\r\nreturn;\r\npid = read_c0_entryhi() & ASID_MASK;\r\n#ifdef DEBUG_TLB\r\nif ((pid != (cpu_context(cpu, vma->vm_mm) & ASID_MASK)) || (cpu_context(cpu, vma->vm_mm) == 0)) {\r\nprintk("update_mmu_cache: Wheee, bogus tlbpid mmpid=%lu tlbpid=%d\n",\r\n(cpu_context(cpu, vma->vm_mm)), pid);\r\n}\r\n#endif\r\nlocal_irq_save(flags);\r\naddress &= PAGE_MASK;\r\nwrite_c0_entryhi(address | pid);\r\nBARRIER;\r\ntlb_probe();\r\nidx = read_c0_index();\r\nwrite_c0_entrylo0(pte_val(pte));\r\nwrite_c0_entryhi(address | pid);\r\nif (idx < 0) {\r\ntlb_write_random();\r\n} else {\r\ntlb_write_indexed();\r\n}\r\nwrite_c0_entryhi(pid);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,\r\nunsigned long entryhi, unsigned long pagemask)\r\n{\r\nunsigned long flags;\r\nunsigned long old_ctx;\r\nstatic unsigned long wired = 0;\r\nif (r3k_have_wired_reg) {\r\nunsigned long old_pagemask;\r\nunsigned long w;\r\n#ifdef DEBUG_TLB\r\nprintk("[tlbwired<entry lo0 %8x, hi %8x\n, pagemask %8x>]\n",\r\nentrylo0, entryhi, pagemask);\r\n#endif\r\nlocal_irq_save(flags);\r\nold_ctx = read_c0_entryhi() & ASID_MASK;\r\nold_pagemask = read_c0_pagemask();\r\nw = read_c0_wired();\r\nwrite_c0_wired(w + 1);\r\nwrite_c0_index(w << 8);\r\nwrite_c0_pagemask(pagemask);\r\nwrite_c0_entryhi(entryhi);\r\nwrite_c0_entrylo0(entrylo0);\r\nBARRIER;\r\ntlb_write_indexed();\r\nwrite_c0_entryhi(old_ctx);\r\nwrite_c0_pagemask(old_pagemask);\r\nlocal_flush_tlb_all();\r\nlocal_irq_restore(flags);\r\n} else if (wired < 8) {\r\n#ifdef DEBUG_TLB\r\nprintk("[tlbwired<entry lo0 %8x, hi %8x\n>]\n",\r\nentrylo0, entryhi);\r\n#endif\r\nlocal_irq_save(flags);\r\nold_ctx = read_c0_entryhi() & ASID_MASK;\r\nwrite_c0_entrylo0(entrylo0);\r\nwrite_c0_entryhi(entryhi);\r\nwrite_c0_index(wired);\r\nwired++;\r\ntlb_write_indexed();\r\nwrite_c0_entryhi(old_ctx);\r\nlocal_flush_tlb_all();\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid __cpuinit tlb_init(void)\r\n{\r\nlocal_flush_tlb_all();\r\nbuild_tlb_refill_handler();\r\n}
