static int omap_vc_config_channel(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nif (vc->flags & OMAP_VC_CHANNEL_DEFAULT)\r\nvc->cfg_channel &= vc_cfg_bits->racen;\r\nvoltdm->rmw(CFG_CHANNEL_MASK << vc->cfg_channel_sa_shift,\r\nvc->cfg_channel << vc->cfg_channel_sa_shift,\r\nvc->cfg_channel_reg);\r\nreturn 0;\r\n}\r\nint omap_vc_pre_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt,\r\nu8 *target_vsel, u8 *current_vsel)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nu32 vc_cmdval;\r\nif (!voltdm->pmic) {\r\npr_err("%s: Insufficient pmic info to scale the vdd_%s\n",\r\n__func__, voltdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (!voltdm->pmic->uv_to_vsel) {\r\npr_err("%s: PMIC function to convert voltage in uV to"\r\n"vsel not registered. Hence unable to scale voltage"\r\n"for vdd_%s\n", __func__, voltdm->name);\r\nreturn -ENODATA;\r\n}\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn -EINVAL;\r\n}\r\n*target_vsel = voltdm->pmic->uv_to_vsel(target_volt);\r\n*current_vsel = voltdm->pmic->uv_to_vsel(voltdm->nominal_volt);\r\nvc_cmdval = voltdm->read(vc->cmdval_reg);\r\nvc_cmdval &= ~vc->common->cmd_on_mask;\r\nvc_cmdval |= (*target_vsel << vc->common->cmd_on_shift);\r\nvoltdm->write(vc_cmdval, vc->cmdval_reg);\r\nomap_vp_update_errorgain(voltdm, target_volt);\r\nreturn 0;\r\n}\r\nvoid omap_vc_post_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt,\r\nu8 target_vsel, u8 current_vsel)\r\n{\r\nu32 smps_steps = 0, smps_delay = 0;\r\nsmps_steps = abs(target_vsel - current_vsel);\r\nsmps_delay = ((smps_steps * voltdm->pmic->step_size) /\r\nvoltdm->pmic->slew_rate) + 2;\r\nudelay(smps_delay);\r\n}\r\nint omap_vc_bypass_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nu32 loop_cnt = 0, retries_cnt = 0;\r\nu32 vc_valid, vc_bypass_val_reg, vc_bypass_value;\r\nu8 target_vsel, current_vsel;\r\nint ret;\r\nret = omap_vc_pre_scale(voltdm, target_volt, &target_vsel, &current_vsel);\r\nif (ret)\r\nreturn ret;\r\nvc_valid = vc->common->valid;\r\nvc_bypass_val_reg = vc->common->bypass_val_reg;\r\nvc_bypass_value = (target_vsel << vc->common->data_shift) |\r\n(vc->volt_reg_addr << vc->common->regaddr_shift) |\r\n(vc->i2c_slave_addr << vc->common->slaveaddr_shift);\r\nvoltdm->write(vc_bypass_value, vc_bypass_val_reg);\r\nvoltdm->write(vc_bypass_value | vc_valid, vc_bypass_val_reg);\r\nvc_bypass_value = voltdm->read(vc_bypass_val_reg);\r\nwhile (!(vc_bypass_value & vc_valid)) {\r\nloop_cnt++;\r\nif (retries_cnt > 10) {\r\npr_warning("%s: Retry count exceeded\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (loop_cnt > 50) {\r\nretries_cnt++;\r\nloop_cnt = 0;\r\nudelay(10);\r\n}\r\nvc_bypass_value = voltdm->read(vc_bypass_val_reg);\r\n}\r\nomap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);\r\nreturn 0;\r\n}\r\nstatic void __init omap3_vfsm_init(struct voltagedomain *voltdm)\r\n{\r\nvoltdm->write(OMAP3_CLKSETUP, OMAP3_PRM_CLKSETUP_OFFSET);\r\nvoltdm->write(OMAP3_VOLTOFFSET, OMAP3_PRM_VOLTOFFSET_OFFSET);\r\nvoltdm->write(OMAP3_VOLTSETUP2, OMAP3_PRM_VOLTSETUP2_OFFSET);\r\n}\r\nstatic void __init omap3_vc_init_channel(struct voltagedomain *voltdm)\r\n{\r\nstatic bool is_initialized;\r\nif (is_initialized)\r\nreturn;\r\nomap3_vfsm_init(voltdm);\r\nis_initialized = true;\r\n}\r\nstatic void __init omap4_vc_init_channel(struct voltagedomain *voltdm)\r\n{\r\nstatic bool is_initialized;\r\nu32 vc_val;\r\nif (is_initialized)\r\nreturn;\r\nvc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);\r\nvoltdm->write(vc_val, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);\r\nis_initialized = true;\r\n}\r\nstatic void __init omap_vc_i2c_init(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nstatic bool initialized;\r\nstatic bool i2c_high_speed;\r\nu8 mcode;\r\nif (initialized) {\r\nif (voltdm->pmic->i2c_high_speed != i2c_high_speed)\r\npr_warn("%s: I2C config for vdd_%s does not match other channels (%u).",\r\n__func__, voltdm->name, i2c_high_speed);\r\nreturn;\r\n}\r\ni2c_high_speed = voltdm->pmic->i2c_high_speed;\r\nif (i2c_high_speed)\r\nvoltdm->rmw(vc->common->i2c_cfg_hsen_mask,\r\nvc->common->i2c_cfg_hsen_mask,\r\nvc->common->i2c_cfg_reg);\r\nmcode = voltdm->pmic->i2c_mcode;\r\nif (mcode)\r\nvoltdm->rmw(vc->common->i2c_mcode_mask,\r\nmcode << __ffs(vc->common->i2c_mcode_mask),\r\nvc->common->i2c_cfg_reg);\r\ninitialized = true;\r\n}\r\nvoid __init omap_vc_init_channel(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nu8 on_vsel, onlp_vsel, ret_vsel, off_vsel;\r\nu32 val;\r\nif (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {\r\npr_err("%s: No PMIC info for vdd_%s\n", __func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nvc->cfg_channel = 0;\r\nif (vc->flags & OMAP_VC_CHANNEL_CFG_MUTANT)\r\nvc_cfg_bits = &vc_mutant_channel_cfg;\r\nelse\r\nvc_cfg_bits = &vc_default_channel_cfg;\r\nvc->i2c_slave_addr = voltdm->pmic->i2c_slave_addr;\r\nvc->volt_reg_addr = voltdm->pmic->volt_reg_addr;\r\nvc->cmd_reg_addr = voltdm->pmic->cmd_reg_addr;\r\nvc->setup_time = voltdm->pmic->volt_setup_time;\r\nvoltdm->rmw(vc->smps_sa_mask,\r\nvc->i2c_slave_addr << __ffs(vc->smps_sa_mask),\r\nvc->smps_sa_reg);\r\nvc->cfg_channel |= vc_cfg_bits->sa;\r\nvoltdm->rmw(vc->smps_volra_mask,\r\nvc->volt_reg_addr << __ffs(vc->smps_volra_mask),\r\nvc->smps_volra_reg);\r\nvc->cfg_channel |= vc_cfg_bits->rav;\r\nif (vc->cmd_reg_addr) {\r\nvoltdm->rmw(vc->smps_cmdra_mask,\r\nvc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),\r\nvc->smps_cmdra_reg);\r\nvc->cfg_channel |= vc_cfg_bits->rac | vc_cfg_bits->racen;\r\n}\r\non_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->on_volt);\r\nonlp_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->onlp_volt);\r\nret_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->ret_volt);\r\noff_vsel = voltdm->pmic->uv_to_vsel(voltdm->pmic->off_volt);\r\nval = ((on_vsel << vc->common->cmd_on_shift) |\r\n(onlp_vsel << vc->common->cmd_onlp_shift) |\r\n(ret_vsel << vc->common->cmd_ret_shift) |\r\n(off_vsel << vc->common->cmd_off_shift));\r\nvoltdm->write(val, vc->cmdval_reg);\r\nvc->cfg_channel |= vc_cfg_bits->cmd;\r\nomap_vc_config_channel(voltdm);\r\nvoltdm->rmw(voltdm->vfsm->voltsetup_mask,\r\nvc->setup_time << __ffs(voltdm->vfsm->voltsetup_mask),\r\nvoltdm->vfsm->voltsetup_reg);\r\nomap_vc_i2c_init(voltdm);\r\nif (cpu_is_omap34xx())\r\nomap3_vc_init_channel(voltdm);\r\nelse if (cpu_is_omap44xx())\r\nomap4_vc_init_channel(voltdm);\r\n}
