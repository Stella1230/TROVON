static int __init do_el2_probe(struct net_device *dev)\r\n{\r\nint *addr, addrs[] = { 0xddffe, 0xd9ffe, 0xcdffe, 0xc9ffe, 0};\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nif (base_addr > 0x1ff)\r\nreturn el2_probe1(dev, base_addr);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nfor (addr = addrs; *addr; addr++) {\r\nvoid __iomem *p = ioremap(*addr, 1);\r\nunsigned base_bits;\r\nint i;\r\nif (!p)\r\ncontinue;\r\nbase_bits = readb(p);\r\niounmap(p);\r\ni = ffs(base_bits) - 1;\r\nif (i == -1 || base_bits != (1 << i))\r\ncontinue;\r\nif (el2_probe1(dev, netcard_portlist[i]) == 0)\r\nreturn 0;\r\ndev->irq = irq;\r\n}\r\n#if ! defined(no_probe_nonshared_memory)\r\nreturn el2_pio_probe(dev);\r\n#else\r\nreturn -ENODEV;\r\n#endif\r\n}\r\nstatic int __init\r\nel2_pio_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nif (base_addr > 0x1ff)\r\nreturn el2_probe1(dev, base_addr);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\nfor (i = 0; netcard_portlist[i]; i++) {\r\nif (el2_probe1(dev, netcard_portlist[i]) == 0)\r\nreturn 0;\r\ndev->irq = irq;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init el2_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_eip_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_el2_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init\r\nel2_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, iobase_reg, membase_reg, saved_406, wordlength, retval;\r\nstatic unsigned version_printed;\r\nunsigned long vendor_id;\r\nif (!request_region(ioaddr, EL2_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nif (!request_region(ioaddr + 0x400, 8, DRV_NAME)) {\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\nif (inb(ioaddr + 0x408) == 0xff) {\r\nmdelay(1);\r\nretval = -ENODEV;\r\ngoto out1;\r\n}\r\niobase_reg = inb(ioaddr+0x403);\r\nmembase_reg = inb(ioaddr+0x404);\r\nif ((iobase_reg & (iobase_reg - 1)) ||\r\n(membase_reg & (membase_reg - 1))) {\r\nretval = -ENODEV;\r\ngoto out1;\r\n}\r\nsaved_406 = inb_p(ioaddr + 0x406);\r\noutb_p(ECNTRL_RESET|ECNTRL_THIN, ioaddr + 0x406);\r\noutb_p(ECNTRL_THIN, ioaddr + 0x406);\r\noutb(ECNTRL_SAPROM|ECNTRL_THIN, ioaddr + 0x406);\r\nvendor_id = inb(ioaddr)*0x10000 + inb(ioaddr + 1)*0x100 + inb(ioaddr + 2);\r\nif ((vendor_id != OLD_3COM_ID) && (vendor_id != NEW_3COM_ID)) {\r\noutb(saved_406, ioaddr + 0x406);\r\nretval = -ENODEV;\r\ngoto out1;\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\npr_debug("%s", version);\r\ndev->base_addr = ioaddr;\r\npr_info("%s: 3c503 at i/o base %#3x, node ", dev->name, ioaddr);\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + i);\r\npr_cont("%pM", dev->dev_addr);\r\noutb(ECNTRL_THIN, ioaddr + 0x406);\r\noutb_p(E8390_PAGE0, ioaddr + E8390_CMD);\r\noutb_p(0, ioaddr + EN0_DCFG);\r\noutb_p(E8390_PAGE2, ioaddr + E8390_CMD);\r\nwordlength = inb_p(ioaddr + EN0_DCFG) & ENDCFG_WTS;\r\noutb_p(E8390_PAGE0, ioaddr + E8390_CMD);\r\nif (ei_debug > 2)\r\npr_cont(" memory jumpers %2.2x ", membase_reg);\r\noutb(EGACFR_NORM, ioaddr + 0x405);\r\n#if defined(EI8390_THICK) || defined(EL2_AUI)\r\nei_status.interface_num = 1;\r\n#else\r\nei_status.interface_num = dev->mem_end & 0xf;\r\n#endif\r\npr_cont(", using %sternal xcvr.\n", ei_status.interface_num == 0 ? "in" : "ex");\r\nif ((membase_reg & 0xf0) == 0) {\r\ndev->mem_start = 0;\r\nei_status.name = "3c503-PIO";\r\nei_status.mem = NULL;\r\n} else {\r\ndev->mem_start = ((membase_reg & 0xc0) ? 0xD8000 : 0xC8000) +\r\n((membase_reg & 0xA0) ? 0x4000 : 0);\r\n#define EL2_MEMSIZE (EL2_MB1_STOP_PG - EL2_MB1_START_PG)*256\r\nei_status.mem = ioremap(dev->mem_start, EL2_MEMSIZE);\r\n#ifdef EL2MEMTEST\r\n{\r\nvoid __iomem *mem_base = ei_status.mem;\r\nunsigned int test_val = 0xbbadf00d;\r\nwritel(0xba5eba5e, mem_base);\r\nfor (i = sizeof(test_val); i < EL2_MEMSIZE; i+=sizeof(test_val)) {\r\nwritel(test_val, mem_base + i);\r\nif (readl(mem_base) != 0xba5eba5e ||\r\nreadl(mem_base + i) != test_val) {\r\npr_warning("3c503: memory failure or memory address conflict.\n");\r\ndev->mem_start = 0;\r\nei_status.name = "3c503-PIO";\r\niounmap(mem_base);\r\nei_status.mem = NULL;\r\nbreak;\r\n}\r\ntest_val += 0x55555555;\r\nwritel(0, mem_base + i);\r\n}\r\n}\r\n#endif\r\nif (dev->mem_start)\r\ndev->mem_end = dev->mem_start + EL2_MEMSIZE;\r\nif (wordlength) {\r\nei_status.priv = 0;\r\nei_status.name = "3c503/16";\r\n} else {\r\nei_status.priv = TX_PAGES * 256;\r\nei_status.name = "3c503";\r\n}\r\n}\r\nif (wordlength) {\r\nei_status.tx_start_page = EL2_MB0_START_PG;\r\nei_status.rx_start_page = EL2_MB1_START_PG;\r\n} else {\r\nei_status.tx_start_page = EL2_MB1_START_PG;\r\nei_status.rx_start_page = EL2_MB1_START_PG + TX_PAGES;\r\n}\r\nei_status.stop_page = EL2_MB1_STOP_PG;\r\nei_status.word16 = wordlength;\r\nei_status.reset_8390 = el2_reset_8390;\r\nei_status.get_8390_hdr = el2_get_8390_hdr;\r\nei_status.block_input = el2_block_input;\r\nei_status.block_output = el2_block_output;\r\nif (dev->irq == 2)\r\ndev->irq = 9;\r\nelse if (dev->irq > 5 && dev->irq != 9) {\r\npr_warning("3c503: configured interrupt %d invalid, will use autoIRQ.\n",\r\ndev->irq);\r\ndev->irq = 0;\r\n}\r\nei_status.saved_irq = dev->irq;\r\ndev->netdev_ops = &el2_netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out1;\r\nif (dev->mem_start)\r\npr_info("%s: %s - %dkB RAM, 8kB shared mem window at %#6lx-%#6lx.\n",\r\ndev->name, ei_status.name, (wordlength+1)<<3,\r\ndev->mem_start, dev->mem_end-1);\r\nelse\r\n{\r\nei_status.tx_start_page = EL2_MB1_START_PG;\r\nei_status.rx_start_page = EL2_MB1_START_PG + TX_PAGES;\r\npr_info("%s: %s, %dkB RAM, using programmed I/O (REJUMPER for SHARED MEMORY).\n",\r\ndev->name, ei_status.name, (wordlength+1)<<3);\r\n}\r\nrelease_region(ioaddr + 0x400, 8);\r\nreturn 0;\r\nout1:\r\nrelease_region(ioaddr + 0x400, 8);\r\nout:\r\nrelease_region(ioaddr, EL2_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic irqreturn_t el2_probe_interrupt(int irq, void *seen)\r\n{\r\n*(bool *)seen = true;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nel2_open(struct net_device *dev)\r\n{\r\nint retval;\r\nif (dev->irq < 2) {\r\nstatic const int irqlist[] = {5, 9, 3, 4, 0};\r\nconst int *irqp = irqlist;\r\noutb(EGACFR_NORM, E33G_GACFR);\r\ndo {\r\nbool seen;\r\nretval = request_irq(*irqp, el2_probe_interrupt, 0,\r\ndev->name, &seen);\r\nif (retval == -EBUSY)\r\ncontinue;\r\nif (retval < 0)\r\ngoto err_disable;\r\nseen = false;\r\nsmp_wmb();\r\noutb_p(0x04 << ((*irqp == 9) ? 2 : *irqp), E33G_IDCFR);\r\noutb_p(0x00, E33G_IDCFR);\r\nmsleep(1);\r\nfree_irq(*irqp, &seen);\r\nif (!seen)\r\ncontinue;\r\nretval = request_irq(dev->irq = *irqp, eip_interrupt, 0,\r\ndev->name, dev);\r\nif (retval == -EBUSY)\r\ncontinue;\r\nif (retval < 0)\r\ngoto err_disable;\r\nbreak;\r\n} while (*++irqp);\r\nif (*irqp == 0) {\r\nerr_disable:\r\noutb(EGACFR_IRQOFF, E33G_GACFR);\r\nreturn -EAGAIN;\r\n}\r\n} else {\r\nif ((retval = request_irq(dev->irq, eip_interrupt, 0, dev->name, dev))) {\r\nreturn retval;\r\n}\r\n}\r\nel2_init_card(dev);\r\neip_open(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nel2_close(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\ndev->irq = ei_status.saved_irq;\r\noutb(EGACFR_IRQOFF, E33G_GACFR);\r\neip_close(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nel2_reset_8390(struct net_device *dev)\r\n{\r\nif (ei_debug > 1) {\r\npr_debug("%s: Resetting the 3c503 board...", dev->name);\r\npr_cont(" %#lx=%#02x %#lx=%#02x %#lx=%#02x...", E33G_IDCFR, inb(E33G_IDCFR),\r\nE33G_CNTRL, inb(E33G_CNTRL), E33G_GACFR, inb(E33G_GACFR));\r\n}\r\noutb_p(ECNTRL_RESET|ECNTRL_THIN, E33G_CNTRL);\r\nei_status.txing = 0;\r\noutb_p(ei_status.interface_num==0 ? ECNTRL_THIN : ECNTRL_AUI, E33G_CNTRL);\r\nel2_init_card(dev);\r\nif (ei_debug > 1)\r\npr_cont("done\n");\r\n}\r\nstatic void\r\nel2_init_card(struct net_device *dev)\r\n{\r\noutb_p(ei_status.interface_num==0 ? ECNTRL_THIN : ECNTRL_AUI, E33G_CNTRL);\r\noutb(ei_status.rx_start_page, E33G_STARTPG);\r\noutb(ei_status.stop_page, E33G_STOPPG);\r\noutb(0xff, E33G_VP2);\r\noutb(0xff, E33G_VP1);\r\noutb(0x00, E33G_VP0);\r\noutb_p(0x00, dev->base_addr + EN0_IMR);\r\noutb(EGACFR_NORM, E33G_GACFR);\r\noutb_p((0x04 << (dev->irq == 9 ? 2 : dev->irq)), E33G_IDCFR);\r\noutb_p((WRD_COUNT << 1), E33G_DRQCNT);\r\noutb_p(0x20, E33G_DMAAH);\r\noutb_p(0x00, E33G_DMAAL);\r\nreturn;\r\n}\r\nstatic void\r\nel2_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nunsigned short int *wrd;\r\nint boguscount;\r\nunsigned short word;\r\nvoid __iomem *base = ei_status.mem;\r\nif (ei_status.word16)\r\noutb(EGACFR_RSEL|EGACFR_TCM, E33G_GACFR);\r\nelse\r\noutb(EGACFR_NORM, E33G_GACFR);\r\nif (base) {\r\nmemcpy_toio(base + ((start_page - ei_status.tx_start_page) << 8),\r\nbuf, count);\r\noutb(EGACFR_NORM, E33G_GACFR);\r\nreturn;\r\n}\r\nword = (unsigned short)start_page;\r\noutb(word&0xFF, E33G_DMAAH);\r\noutb(word>>8, E33G_DMAAL);\r\noutb_p((ei_status.interface_num ? ECNTRL_AUI : ECNTRL_THIN ) | ECNTRL_OUTPUT\r\n| ECNTRL_START, E33G_CNTRL);\r\nwrd = (unsigned short int *) buf;\r\ncount = (count + 1) >> 1;\r\nfor(;;)\r\n{\r\nboguscount = 0x1000;\r\nwhile ((inb(E33G_STATUS) & ESTAT_DPRDY) == 0)\r\n{\r\nif(!boguscount--)\r\n{\r\npr_notice("%s: FIFO blocked in el2_block_output.\n", dev->name);\r\nel2_reset_8390(dev);\r\ngoto blocked;\r\n}\r\n}\r\nif(count > WRD_COUNT)\r\n{\r\noutsw(E33G_FIFOH, wrd, WRD_COUNT);\r\nwrd += WRD_COUNT;\r\ncount -= WRD_COUNT;\r\n}\r\nelse\r\n{\r\noutsw(E33G_FIFOH, wrd, count);\r\nbreak;\r\n}\r\n}\r\nblocked:;\r\noutb_p(ei_status.interface_num==0 ? ECNTRL_THIN : ECNTRL_AUI, E33G_CNTRL);\r\n}\r\nstatic void\r\nel2_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint boguscount;\r\nvoid __iomem *base = ei_status.mem;\r\nunsigned short word;\r\nif (base) {\r\nvoid __iomem *hdr_start = base + ((ring_page - EL2_MB1_START_PG)<<8);\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = le16_to_cpu(hdr->count);\r\nreturn;\r\n}\r\nword = (unsigned short)ring_page;\r\noutb(word&0xFF, E33G_DMAAH);\r\noutb(word>>8, E33G_DMAAL);\r\noutb_p((ei_status.interface_num == 0 ? ECNTRL_THIN : ECNTRL_AUI) | ECNTRL_INPUT\r\n| ECNTRL_START, E33G_CNTRL);\r\nboguscount = 0x1000;\r\nwhile ((inb(E33G_STATUS) & ESTAT_DPRDY) == 0)\r\n{\r\nif(!boguscount--)\r\n{\r\npr_notice("%s: FIFO blocked in el2_get_8390_hdr.\n", dev->name);\r\nmemset(hdr, 0x00, sizeof(struct e8390_pkt_hdr));\r\nel2_reset_8390(dev);\r\ngoto blocked;\r\n}\r\n}\r\ninsw(E33G_FIFOH, hdr, (sizeof(struct e8390_pkt_hdr))>> 1);\r\nblocked:;\r\noutb_p(ei_status.interface_num == 0 ? ECNTRL_THIN : ECNTRL_AUI, E33G_CNTRL);\r\n}\r\nstatic void\r\nel2_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nint boguscount = 0;\r\nvoid __iomem *base = ei_status.mem;\r\nunsigned short int *buf;\r\nunsigned short word;\r\nif (base) {\r\nring_offset -= (EL2_MB1_START_PG<<8);\r\nif (ring_offset + count > EL2_MEMSIZE) {\r\nint semi_count = EL2_MEMSIZE - ring_offset;\r\nmemcpy_fromio(skb->data, base + ring_offset, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count, base + ei_status.priv, count);\r\n} else {\r\nmemcpy_fromio(skb->data, base + ring_offset, count);\r\n}\r\nreturn;\r\n}\r\nword = (unsigned short) ring_offset;\r\noutb(word>>8, E33G_DMAAH);\r\noutb(word&0xFF, E33G_DMAAL);\r\noutb_p((ei_status.interface_num == 0 ? ECNTRL_THIN : ECNTRL_AUI) | ECNTRL_INPUT\r\n| ECNTRL_START, E33G_CNTRL);\r\nbuf = (unsigned short int *) skb->data;\r\ncount = (count + 1) >> 1;\r\nfor(;;)\r\n{\r\nboguscount = 0x1000;\r\nwhile ((inb(E33G_STATUS) & ESTAT_DPRDY) == 0)\r\n{\r\nif(!boguscount--)\r\n{\r\npr_notice("%s: FIFO blocked in el2_block_input.\n", dev->name);\r\nel2_reset_8390(dev);\r\ngoto blocked;\r\n}\r\n}\r\nif(count > WRD_COUNT)\r\n{\r\ninsw(E33G_FIFOH, buf, WRD_COUNT);\r\nbuf += WRD_COUNT;\r\ncount -= WRD_COUNT;\r\n}\r\nelse\r\n{\r\ninsw(E33G_FIFOH, buf, count);\r\nbreak;\r\n}\r\n}\r\nblocked:;\r\noutb_p(ei_status.interface_num == 0 ? ECNTRL_THIN : ECNTRL_AUI, E33G_CNTRL);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrcpy(info->driver, DRV_NAME);\r\nstrcpy(info->version, DRV_VERSION);\r\nsprintf(info->bus_info, "ISA 0x%lx", dev->base_addr);\r\n}\r\nint __init\r\ninit_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_EL2_CARDS; this_dev++) {\r\nif (io[this_dev] == 0) {\r\nif (this_dev != 0) break;\r\npr_notice("3c503.c: Presently autoprobing (not recommended) for a single card.\n");\r\n}\r\ndev = alloc_eip_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\ndev->mem_end = xcvr[this_dev];\r\nif (do_el2_probe(dev) == 0) {\r\ndev_el2[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\npr_warning("3c503.c: No 3c503 card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nrelease_region(dev->base_addr, EL2_IO_EXTENT);\r\nif (ei_status.mem)\r\niounmap(ei_status.mem);\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_EL2_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_el2[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
