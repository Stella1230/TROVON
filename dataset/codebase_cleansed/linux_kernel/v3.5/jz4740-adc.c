static void jz4740_adc_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip_generic *gc = irq_desc_get_handler_data(desc);\r\nuint8_t status;\r\nunsigned int i;\r\nstatus = readb(gc->reg_base + JZ_REG_ADC_STATUS);\r\nfor (i = 0; i < 5; ++i) {\r\nif (status & BIT(i))\r\ngeneric_handle_irq(gc->irq_base + i);\r\n}\r\n}\r\nstatic inline void jz4740_adc_clk_enable(struct jz4740_adc *adc)\r\n{\r\nif (atomic_inc_return(&adc->clk_ref) == 1)\r\nclk_enable(adc->clk);\r\n}\r\nstatic inline void jz4740_adc_clk_disable(struct jz4740_adc *adc)\r\n{\r\nif (atomic_dec_return(&adc->clk_ref) == 0)\r\nclk_disable(adc->clk);\r\n}\r\nstatic inline void jz4740_adc_set_enabled(struct jz4740_adc *adc, int engine,\r\nbool enabled)\r\n{\r\nunsigned long flags;\r\nuint8_t val;\r\nspin_lock_irqsave(&adc->lock, flags);\r\nval = readb(adc->base + JZ_REG_ADC_ENABLE);\r\nif (enabled)\r\nval |= BIT(engine);\r\nelse\r\nval &= ~BIT(engine);\r\nwriteb(val, adc->base + JZ_REG_ADC_ENABLE);\r\nspin_unlock_irqrestore(&adc->lock, flags);\r\n}\r\nstatic int jz4740_adc_cell_enable(struct platform_device *pdev)\r\n{\r\nstruct jz4740_adc *adc = dev_get_drvdata(pdev->dev.parent);\r\njz4740_adc_clk_enable(adc);\r\njz4740_adc_set_enabled(adc, pdev->id, true);\r\nreturn 0;\r\n}\r\nstatic int jz4740_adc_cell_disable(struct platform_device *pdev)\r\n{\r\nstruct jz4740_adc *adc = dev_get_drvdata(pdev->dev.parent);\r\njz4740_adc_set_enabled(adc, pdev->id, false);\r\njz4740_adc_clk_disable(adc);\r\nreturn 0;\r\n}\r\nint jz4740_adc_set_config(struct device *dev, uint32_t mask, uint32_t val)\r\n{\r\nstruct jz4740_adc *adc = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nuint32_t cfg;\r\nif (!adc)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&adc->lock, flags);\r\ncfg = readl(adc->base + JZ_REG_ADC_CFG);\r\ncfg &= ~mask;\r\ncfg |= val;\r\nwritel(cfg, adc->base + JZ_REG_ADC_CFG);\r\nspin_unlock_irqrestore(&adc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __devinit jz4740_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nstruct jz4740_adc *adc;\r\nstruct resource *mem_base;\r\nint ret;\r\nint irq_base;\r\nadc = kmalloc(sizeof(*adc), GFP_KERNEL);\r\nif (!adc) {\r\ndev_err(&pdev->dev, "Failed to allocate driver structure\n");\r\nreturn -ENOMEM;\r\n}\r\nadc->irq = platform_get_irq(pdev, 0);\r\nif (adc->irq < 0) {\r\nret = adc->irq;\r\ndev_err(&pdev->dev, "Failed to get platform irq: %d\n", ret);\r\ngoto err_free;\r\n}\r\nirq_base = platform_get_irq(pdev, 1);\r\nif (irq_base < 0) {\r\nret = irq_base;\r\ndev_err(&pdev->dev, "Failed to get irq base: %d\n", ret);\r\ngoto err_free;\r\n}\r\nmem_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_base) {\r\nret = -ENOENT;\r\ndev_err(&pdev->dev, "Failed to get platform mmio resource\n");\r\ngoto err_free;\r\n}\r\nadc->mem = request_mem_region(mem_base->start, JZ_REG_ADC_STATUS,\r\npdev->name);\r\nif (!adc->mem) {\r\nret = -EBUSY;\r\ndev_err(&pdev->dev, "Failed to request mmio memory region\n");\r\ngoto err_free;\r\n}\r\nadc->base = ioremap_nocache(adc->mem->start, resource_size(adc->mem));\r\nif (!adc->base) {\r\nret = -EBUSY;\r\ndev_err(&pdev->dev, "Failed to ioremap mmio memory\n");\r\ngoto err_release_mem_region;\r\n}\r\nadc->clk = clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(adc->clk)) {\r\nret = PTR_ERR(adc->clk);\r\ndev_err(&pdev->dev, "Failed to get clock: %d\n", ret);\r\ngoto err_iounmap;\r\n}\r\nspin_lock_init(&adc->lock);\r\natomic_set(&adc->clk_ref, 0);\r\nplatform_set_drvdata(pdev, adc);\r\ngc = irq_alloc_generic_chip("INTC", 1, irq_base, adc->base,\r\nhandle_level_irq);\r\nct = gc->chip_types;\r\nct->regs.mask = JZ_REG_ADC_CTRL;\r\nct->regs.ack = JZ_REG_ADC_STATUS;\r\nct->chip.irq_mask = irq_gc_mask_set_bit;\r\nct->chip.irq_unmask = irq_gc_mask_clr_bit;\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nirq_setup_generic_chip(gc, IRQ_MSK(5), 0, 0, IRQ_NOPROBE | IRQ_LEVEL);\r\nadc->gc = gc;\r\nirq_set_handler_data(adc->irq, gc);\r\nirq_set_chained_handler(adc->irq, jz4740_adc_irq_demux);\r\nwriteb(0x00, adc->base + JZ_REG_ADC_ENABLE);\r\nwriteb(0xff, adc->base + JZ_REG_ADC_CTRL);\r\nret = mfd_add_devices(&pdev->dev, 0, jz4740_adc_cells,\r\nARRAY_SIZE(jz4740_adc_cells), mem_base, irq_base);\r\nif (ret < 0)\r\ngoto err_clk_put;\r\nreturn 0;\r\nerr_clk_put:\r\nclk_put(adc->clk);\r\nerr_iounmap:\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(adc->base);\r\nerr_release_mem_region:\r\nrelease_mem_region(adc->mem->start, resource_size(adc->mem));\r\nerr_free:\r\nkfree(adc);\r\nreturn ret;\r\n}\r\nstatic int __devexit jz4740_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct jz4740_adc *adc = platform_get_drvdata(pdev);\r\nmfd_remove_devices(&pdev->dev);\r\nirq_remove_generic_chip(adc->gc, IRQ_MSK(5), IRQ_NOPROBE | IRQ_LEVEL, 0);\r\nkfree(adc->gc);\r\nirq_set_handler_data(adc->irq, NULL);\r\nirq_set_chained_handler(adc->irq, NULL);\r\niounmap(adc->base);\r\nrelease_mem_region(adc->mem->start, resource_size(adc->mem));\r\nclk_put(adc->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(adc);\r\nreturn 0;\r\n}
