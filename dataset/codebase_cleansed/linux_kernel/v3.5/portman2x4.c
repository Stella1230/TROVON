static int portman_free(struct portman *pm)\r\n{\r\nkfree(pm);\r\nreturn 0;\r\n}\r\nstatic int __devinit portman_create(struct snd_card *card,\r\nstruct pardevice *pardev,\r\nstruct portman **rchip)\r\n{\r\nstruct portman *pm;\r\n*rchip = NULL;\r\npm = kzalloc(sizeof(struct portman), GFP_KERNEL);\r\nif (pm == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pm->reg_lock);\r\npm->card = card;\r\npm->pardev = pardev;\r\n*rchip = pm;\r\nreturn 0;\r\n}\r\nstatic inline void portman_write_command(struct portman *pm, u8 value)\r\n{\r\nparport_write_control(pm->pardev->port, value);\r\n}\r\nstatic inline u8 portman_read_command(struct portman *pm)\r\n{\r\nreturn parport_read_control(pm->pardev->port);\r\n}\r\nstatic inline u8 portman_read_status(struct portman *pm)\r\n{\r\nreturn parport_read_status(pm->pardev->port);\r\n}\r\nstatic inline u8 portman_read_data(struct portman *pm)\r\n{\r\nreturn parport_read_data(pm->pardev->port);\r\n}\r\nstatic inline void portman_write_data(struct portman *pm, u8 value)\r\n{\r\nparport_write_data(pm->pardev->port, value);\r\n}\r\nstatic void portman_write_midi(struct portman *pm,\r\nint port, u8 mididata)\r\n{\r\nint command = ((port + 4) << 1);\r\ncommand |= INT_EN;\r\ndo {\r\nportman_write_command(pm, command);\r\nportman_write_data(pm, mididata);\r\n} while ((portman_read_status(pm) & TXEMPTY) != TXEMPTY);\r\nportman_write_command(pm, command | STROBE);\r\nwhile ((portman_read_status(pm) & ESTB) == 0)\r\ncpu_relax();\r\nportman_write_command(pm, command);\r\nwhile ((portman_read_status(pm) & ESTB) == ESTB)\r\ncpu_relax();\r\nwhile ((portman_read_status(pm) & BUSY) == BUSY)\r\ncpu_relax();\r\n}\r\nstatic int portman_read_midi(struct portman *pm, int port)\r\n{\r\nunsigned char midi_data = 0;\r\nunsigned char cmdout;\r\nportman_write_data(pm, 0);\r\ncmdout = (port << 1) | INT_EN;\r\nportman_write_command(pm, cmdout);\r\nwhile ((portman_read_status(pm) & ESTB) == ESTB)\r\ncpu_relax();\r\nif ((portman_read_status(pm) & RXAVAIL) == 0)\r\nreturn -1;\r\nportman_write_command(pm, cmdout | STROBE);\r\nwhile ((portman_read_status(pm) & ESTB) == 0)\r\ncpu_relax();\r\nmidi_data = (portman_read_status(pm) & 128);\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 1) & 64;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 2) & 32;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 3) & 16;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 4) & 8;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 5) & 4;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 6) & 2;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nmidi_data |= (portman_read_status(pm) >> 7) & 1;\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\nportman_write_command(pm, cmdout);\r\nwhile ((portman_read_status(pm) & ESTB) == ESTB)\r\ncpu_relax();\r\nreturn (midi_data & 255);\r\n}\r\nstatic int portman_data_avail(struct portman *pm, int channel)\r\n{\r\nint command = INT_EN;\r\nswitch (channel) {\r\ncase 0:\r\ncommand |= RXDATA0;\r\nbreak;\r\ncase 1:\r\ncommand |= RXDATA1;\r\nbreak;\r\n}\r\nportman_write_command(pm, command);\r\nif ((portman_read_status(pm) & RXAVAIL) == RXAVAIL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void portman_flush_input(struct portman *pm, unsigned char port)\r\n{\r\nunsigned int i = 0;\r\nunsigned char command = 0;\r\nswitch (port) {\r\ncase 0:\r\ncommand = RXDATA0;\r\nbreak;\r\ncase 1:\r\ncommand = RXDATA1;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"portman_flush_input() Won't flush port %i\n",\r\nport);\r\nreturn;\r\n}\r\nportman_write_command(pm, command);\r\nportman_write_command(pm, command | STROBE);\r\nwhile ((portman_read_status(pm) & ESTB) == 0)\r\ncpu_relax();\r\nportman_write_data(pm, 0);\r\nfor (i = 0; i < 250; i++) {\r\nportman_write_data(pm, 1);\r\nportman_write_data(pm, 0);\r\n}\r\nportman_write_command(pm, command | INT_EN);\r\nwhile ((portman_read_status(pm) & ESTB) == ESTB)\r\ncpu_relax();\r\n}\r\nstatic int portman_probe(struct parport *p)\r\n{\r\nparport_write_data(p, 0);\r\nparport_write_control(p, 0);\r\nparport_write_control(p, RXDATA0);\r\nif ((parport_read_status(p) & ESTB) == ESTB)\r\nreturn 1;\r\nparport_write_control(p, RXDATA0 + STROBE);\r\nif ((parport_read_status(p) & ESTB) != ESTB)\r\nreturn 1;\r\nparport_write_control(p, 0);\r\nparport_write_control(p, TXDATA0);\r\nif ((parport_read_status(p) & TXEMPTY) == 0)\r\nreturn 2;\r\nreturn 0;\r\n}\r\nstatic int portman_device_init(struct portman *pm)\r\n{\r\nportman_flush_input(pm, 0);\r\nportman_flush_input(pm, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_portman_midi_open(struct snd_rawmidi_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_portman_midi_close(struct snd_rawmidi_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void snd_portman_midi_input_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nstruct portman *pm = substream->rmidi->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pm->reg_lock, flags);\r\nif (up)\r\npm->mode[substream->number] |= PORTMAN2X4_MODE_INPUT_TRIGGERED;\r\nelse\r\npm->mode[substream->number] &= ~PORTMAN2X4_MODE_INPUT_TRIGGERED;\r\nspin_unlock_irqrestore(&pm->reg_lock, flags);\r\n}\r\nstatic void snd_portman_midi_output_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nstruct portman *pm = substream->rmidi->private_data;\r\nunsigned long flags;\r\nunsigned char byte;\r\nspin_lock_irqsave(&pm->reg_lock, flags);\r\nif (up) {\r\nwhile ((snd_rawmidi_transmit(substream, &byte, 1) == 1))\r\nportman_write_midi(pm, substream->number, byte);\r\n}\r\nspin_unlock_irqrestore(&pm->reg_lock, flags);\r\n}\r\nstatic int __devinit snd_portman_rawmidi_create(struct snd_card *card)\r\n{\r\nstruct portman *pm = card->private_data;\r\nstruct snd_rawmidi *rmidi;\r\nstruct snd_rawmidi_substream *substream;\r\nint err;\r\nerr = snd_rawmidi_new(card, CARD_NAME, 0,\r\nPORTMAN_NUM_OUTPUT_PORTS,\r\nPORTMAN_NUM_INPUT_PORTS,\r\n&rmidi);\r\nif (err < 0)\r\nreturn err;\r\nrmidi->private_data = pm;\r\nstrcpy(rmidi->name, CARD_NAME);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\npm->rmidi = rmidi;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&snd_portman_midi_output);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&snd_portman_midi_input);\r\nlist_for_each_entry(substream,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT].substreams,\r\nlist) {\r\nsprintf(substream->name,\r\n"Portman2x4 %d", substream->number+1);\r\n}\r\nlist_for_each_entry(substream,\r\n&rmidi->streams[SNDRV_RAWMIDI_STREAM_INPUT].substreams,\r\nlist) {\r\npm->midi_input[substream->number] = substream;\r\nsprintf(substream->name,\r\n"Portman2x4 %d", substream->number+1);\r\n}\r\nreturn err;\r\n}\r\nstatic void snd_portman_interrupt(void *userdata)\r\n{\r\nunsigned char midivalue = 0;\r\nstruct portman *pm = ((struct snd_card*)userdata)->private_data;\r\nspin_lock(&pm->reg_lock);\r\nwhile ((portman_read_status(pm) & INT_REQ) == INT_REQ) {\r\nif (portman_data_avail(pm, 0)) {\r\nmidivalue = portman_read_midi(pm, 0);\r\nif (pm->mode[0] & PORTMAN2X4_MODE_INPUT_TRIGGERED)\r\nsnd_rawmidi_receive(pm->midi_input[0],\r\n&midivalue, 1);\r\n}\r\nif (portman_data_avail(pm, 1)) {\r\nmidivalue = portman_read_midi(pm, 1);\r\nif (pm->mode[1] & PORTMAN2X4_MODE_INPUT_TRIGGERED)\r\nsnd_rawmidi_receive(pm->midi_input[1],\r\n&midivalue, 1);\r\n}\r\n}\r\nspin_unlock(&pm->reg_lock);\r\n}\r\nstatic int __devinit snd_portman_probe_port(struct parport *p)\r\n{\r\nstruct pardevice *pardev;\r\nint res;\r\npardev = parport_register_device(p, DRIVER_NAME,\r\nNULL, NULL, NULL,\r\n0, NULL);\r\nif (!pardev)\r\nreturn -EIO;\r\nif (parport_claim(pardev)) {\r\nparport_unregister_device(pardev);\r\nreturn -EIO;\r\n}\r\nres = portman_probe(p);\r\nparport_release(pardev);\r\nparport_unregister_device(pardev);\r\nreturn res ? -EIO : 0;\r\n}\r\nstatic void __devinit snd_portman_attach(struct parport *p)\r\n{\r\nstruct platform_device *device;\r\ndevice = platform_device_alloc(PLATFORM_DRIVER, device_count);\r\nif (!device)\r\nreturn;\r\nplatform_set_drvdata(device, p);\r\nif (platform_device_add(device) < 0) {\r\nplatform_device_put(device);\r\nreturn;\r\n}\r\nif (!platform_get_drvdata(device)) {\r\nplatform_device_unregister(device);\r\nreturn;\r\n}\r\nplatform_devices[device_count] = device;\r\ndevice_count++;\r\n}\r\nstatic void snd_portman_detach(struct parport *p)\r\n{\r\n}\r\nstatic void snd_portman_card_private_free(struct snd_card *card)\r\n{\r\nstruct portman *pm = card->private_data;\r\nstruct pardevice *pardev = pm->pardev;\r\nif (pardev) {\r\nif (pm->pardev_claimed)\r\nparport_release(pardev);\r\nparport_unregister_device(pardev);\r\n}\r\nportman_free(pm);\r\n}\r\nstatic int __devinit snd_portman_probe(struct platform_device *pdev)\r\n{\r\nstruct pardevice *pardev;\r\nstruct parport *p;\r\nint dev = pdev->id;\r\nstruct snd_card *card = NULL;\r\nstruct portman *pm = NULL;\r\nint err;\r\np = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev])\r\nreturn -ENOENT;\r\nif ((err = snd_portman_probe_port(p)) < 0)\r\nreturn err;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0) {\r\nsnd_printd("Cannot create card\n");\r\nreturn err;\r\n}\r\nstrcpy(card->driver, DRIVER_NAME);\r\nstrcpy(card->shortname, CARD_NAME);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, p->base, p->irq);\r\npardev = parport_register_device(p,\r\nDRIVER_NAME,\r\nNULL,\r\nNULL,\r\nsnd_portman_interrupt,\r\nPARPORT_DEV_EXCL,\r\n(void *)card);\r\nif (pardev == NULL) {\r\nsnd_printd("Cannot register pardevice\n");\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\nif ((err = portman_create(card, pardev, &pm)) < 0) {\r\nsnd_printd("Cannot create main component\n");\r\nparport_unregister_device(pardev);\r\ngoto __err;\r\n}\r\ncard->private_data = pm;\r\ncard->private_free = snd_portman_card_private_free;\r\nif ((err = snd_portman_rawmidi_create(card)) < 0) {\r\nsnd_printd("Creating Rawmidi component failed\n");\r\ngoto __err;\r\n}\r\nif (parport_claim(pardev)) {\r\nsnd_printd("Cannot claim parport 0x%lx\n", pardev->port->base);\r\nerr = -EIO;\r\ngoto __err;\r\n}\r\npm->pardev_claimed = 1;\r\nif ((err = portman_device_init(pm)) < 0)\r\ngoto __err;\r\nplatform_set_drvdata(pdev, card);\r\nsnd_card_set_dev(card, &pdev->dev);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_printd("Cannot register card\n");\r\ngoto __err;\r\n}\r\nsnd_printk(KERN_INFO "Portman 2x4 on 0x%lx\n", p->base);\r\nreturn 0;\r\n__err:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int __devexit snd_portman_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nif (card)\r\nsnd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic void snd_portman_unregister_all(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SNDRV_CARDS; ++i) {\r\nif (platform_devices[i]) {\r\nplatform_device_unregister(platform_devices[i]);\r\nplatform_devices[i] = NULL;\r\n}\r\n}\r\nplatform_driver_unregister(&snd_portman_driver);\r\nparport_unregister_driver(&portman_parport_driver);\r\n}\r\nstatic int __init snd_portman_module_init(void)\r\n{\r\nint err;\r\nif ((err = platform_driver_register(&snd_portman_driver)) < 0)\r\nreturn err;\r\nif (parport_register_driver(&portman_parport_driver) != 0) {\r\nplatform_driver_unregister(&snd_portman_driver);\r\nreturn -EIO;\r\n}\r\nif (device_count == 0) {\r\nsnd_portman_unregister_all();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit snd_portman_module_exit(void)\r\n{\r\nsnd_portman_unregister_all();\r\n}
