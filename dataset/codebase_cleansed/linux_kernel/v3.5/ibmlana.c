static void dumpregs(struct net_device *dev)\r\n{\r\nint z;\r\nfor (z = 0; z < 160; z += 2) {\r\nif (!(z & 15))\r\nprintk("REGS: %04x:", z);\r\nprintk(" %04x", inw(dev->base_addr + z));\r\nif ((z & 15) == 14)\r\nprintk("\n");\r\n}\r\n}\r\nstatic void dumpmem(struct net_device *dev, u32 start, u32 len)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\nint z;\r\nprintk("Address %04x:\n", start);\r\nfor (z = 0; z < len; z++) {\r\nif ((z & 15) == 0)\r\nprintk("%04x:", z);\r\nprintk(" %02x", readb(priv->base + start + z));\r\nif ((z & 15) == 15)\r\nprintk("\n");\r\n}\r\nif ((z & 15) != 0)\r\nprintk("\n");\r\n}\r\nstatic void PrTime(void)\r\n{\r\nstruct timeval tv;\r\ndo_gettimeofday(&tv);\r\nprintk("%9d:%06d: ", (int) tv.tv_sec, (int) tv.tv_usec);\r\n}\r\nstatic void getaddrs(struct mca_device *mdev, int *base, int *memlen,\r\nint *iobase, int *irq, ibmlana_medium *medium)\r\n{\r\nu_char pos0, pos1;\r\npos0 = mca_device_read_stored_pos(mdev, 2);\r\npos1 = mca_device_read_stored_pos(mdev, 3);\r\n*base = 0xc0000 + ((pos1 & 0xf0) << 9);\r\n*memlen = (pos1 & 0x01) ? 0x8000 : 0x4000;\r\n*iobase = (pos0 & 0xe0) << 7;\r\nswitch (pos0 & 0x06) {\r\ncase 0:\r\n*irq = 5;\r\nbreak;\r\ncase 2:\r\n*irq = 15;\r\nbreak;\r\ncase 4:\r\n*irq = 10;\r\nbreak;\r\ncase 6:\r\n*irq = 11;\r\nbreak;\r\n}\r\n*medium = (pos0 & 0x18) >> 3;\r\n}\r\nstatic int wait_timeout(struct net_device *dev, int regoffs, u16 mask,\r\nu16 value, int timeout)\r\n{\r\nunsigned long fin = jiffies + timeout;\r\nwhile (time_before(jiffies,fin))\r\nif ((inw(dev->base_addr + regoffs) & mask) == value)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ResetBoard(struct net_device *dev)\r\n{\r\nunsigned char bcmval;\r\nbcmval = inb(dev->base_addr + BCMREG);\r\nbcmval |= BCMREG_RESET;\r\noutb(bcmval, dev->base_addr + BCMREG);\r\nudelay(10);\r\nbcmval &= ~BCMREG_RESET;\r\noutb(bcmval, dev->base_addr + BCMREG);\r\nbcmval |= BCMREG_RAMEN | BCMREG_RAMWIN;\r\noutb(bcmval, dev->base_addr + BCMREG);\r\n}\r\nstatic void InitDscrs(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\nu32 addr, baddr, raddr;\r\nint z;\r\ntda_t tda;\r\nrda_t rda;\r\nrra_t rra;\r\nmemset_io(priv->base, 0xaa,\r\ndev->mem_start - dev->mem_start);\r\npriv->tdastart = addr = 0;\r\npriv->txbufstart = baddr = sizeof(tda_t) * TXBUFCNT;\r\nfor (z = 0; z < TXBUFCNT; z++) {\r\ntda.status = 0;\r\ntda.config = 0;\r\ntda.length = 0;\r\ntda.fragcount = 1;\r\ntda.startlo = baddr;\r\ntda.starthi = 0;\r\ntda.fraglength = 0;\r\nif (z == TXBUFCNT - 1)\r\ntda.link = priv->tdastart;\r\nelse\r\ntda.link = addr + sizeof(tda_t);\r\ntda.link |= 1;\r\nmemcpy_toio(priv->base + addr, &tda, sizeof(tda_t));\r\naddr += sizeof(tda_t);\r\nbaddr += PKTSIZE;\r\n}\r\npriv->rxbufcnt = (dev->mem_end - dev->mem_start - baddr) / (sizeof(rra_t) + sizeof(rda_t) + PKTSIZE);\r\npriv->rrastart = raddr = priv->txbufstart + (TXBUFCNT * PKTSIZE);\r\npriv->rdastart = addr = priv->rrastart + (priv->rxbufcnt * sizeof(rra_t));\r\npriv->rxbufstart = baddr = priv->rdastart + (priv->rxbufcnt * sizeof(rda_t));\r\nfor (z = 0; z < priv->rxbufcnt; z++) {\r\nrra.startlo = baddr;\r\nrra.starthi = 0;\r\nrra.cntlo = PKTSIZE >> 1;\r\nrra.cnthi = 0;\r\nmemcpy_toio(priv->base + raddr, &rra, sizeof(rra_t));\r\nrda.status = 0;\r\nrda.length = 0;\r\nrda.startlo = 0;\r\nrda.starthi = 0;\r\nrda.seqno = 0;\r\nif (z < priv->rxbufcnt - 1)\r\nrda.link = addr + sizeof(rda_t);\r\nelse\r\nrda.link = 1;\r\nrda.inuse = 1;\r\nmemcpy_toio(priv->base + addr, &rda, sizeof(rda_t));\r\nbaddr += PKTSIZE;\r\nraddr += sizeof(rra_t);\r\naddr += sizeof(rda_t);\r\n}\r\npriv->nextrxdescr = 0;\r\npriv->lastrxdescr = priv->rxbufcnt - 1;\r\npriv->nexttxdescr = 0;\r\npriv->currtxdescr = 0;\r\npriv->txusedcnt = 0;\r\nmemset(priv->txused, 0, sizeof(priv->txused));\r\n}\r\nstatic int InitSONIC(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\noutw(0, SONIC_URRA);\r\noutw(priv->rrastart, dev->base_addr + SONIC_RSA);\r\noutw(priv->rrastart + (priv->rxbufcnt * sizeof(rra_t)), dev->base_addr + SONIC_REA);\r\noutw(priv->rrastart, dev->base_addr + SONIC_RRP);\r\noutw(priv->rrastart, dev->base_addr + SONIC_RWP);\r\noutw((PKTSIZE - 4) >> 1, dev->base_addr + SONIC_EOBC);\r\noutw(CMDREG_RRRA, dev->base_addr + SONIC_CMDREG);\r\nif (!wait_timeout(dev, SONIC_CMDREG, CMDREG_RRRA, 0, 2)) {\r\nprintk(KERN_ERR "%s: SONIC did not respond on RRRA command - giving up.", dev->name);\r\nreturn 0;\r\n}\r\noutw(0, dev->base_addr + SONIC_URDA);\r\noutw(priv->rdastart, dev->base_addr + SONIC_CRDA);\r\noutw(0, dev->base_addr + SONIC_UTDA);\r\nreturn 1;\r\n}\r\nstatic void StopSONIC(struct net_device *dev)\r\n{\r\noutb(inb(dev->base_addr + BCMREG) & (~BCMREG_IEN), dev->base_addr + BCMREG);\r\noutb(0, dev->base_addr + SONIC_IMREG);\r\noutw(CMDREG_RST, dev->base_addr + SONIC_CMDREG);\r\nudelay(10);\r\noutw(CMDREG_RST, dev->base_addr + SONIC_CMDREG);\r\n}\r\nstatic void putcam(camentry_t * cams, int *camcnt, char *addr)\r\n{\r\ncamentry_t *pcam = cams + (*camcnt);\r\nu8 *uaddr = (u8 *) addr;\r\npcam->index = *camcnt;\r\npcam->addr0 = (((u16) uaddr[1]) << 8) | uaddr[0];\r\npcam->addr1 = (((u16) uaddr[3]) << 8) | uaddr[2];\r\npcam->addr2 = (((u16) uaddr[5]) << 8) | uaddr[4];\r\n(*camcnt)++;\r\n}\r\nstatic void InitBoard(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\nint camcnt;\r\ncamentry_t cams[16];\r\nu32 cammask;\r\nstruct netdev_hw_addr *ha;\r\nu16 rcrval;\r\noutw(CMDREG_RST, dev->base_addr + SONIC_CMDREG);\r\nudelay(10);\r\noutw(inw(dev->base_addr + SONIC_ISREG), dev->base_addr + SONIC_ISREG);\r\noutw(DCREG_USR1 | DCREG_USR0 | DCREG_WC1 | DCREG_DW32, dev->base_addr + SONIC_DCREG);\r\noutw(0, dev->base_addr + SONIC_DCREG2);\r\noutw(0, dev->base_addr + SONIC_CMDREG);\r\nudelay(10);\r\noutw(0, dev->base_addr + SONIC_URRA);\r\ncamcnt = 0;\r\nputcam(cams, &camcnt, dev->dev_addr);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nputcam(cams, &camcnt, ha->addr);\r\nif (camcnt == 16)\r\nbreak;\r\n}\r\ncammask = (1 << camcnt) - 1;\r\nmemcpy_toio(priv->base, cams, sizeof(camentry_t) * camcnt);\r\nmemcpy_toio(priv->base + (sizeof(camentry_t) * camcnt), &cammask, sizeof(cammask));\r\n#ifdef DEBUG\r\nprintk("CAM setup:\n");\r\ndumpmem(dev, 0, sizeof(camentry_t) * camcnt + sizeof(cammask));\r\n#endif\r\noutw(0, dev->base_addr + SONIC_CAMPTR);\r\noutw(camcnt, dev->base_addr + SONIC_CAMCNT);\r\noutw(CMDREG_LCAM, dev->base_addr + SONIC_CMDREG);\r\nif (!wait_timeout(dev, SONIC_CMDREG, CMDREG_LCAM, 0, 2)) {\r\nprintk(KERN_ERR "%s:SONIC did not respond on LCAM command - giving up.", dev->name);\r\nreturn;\r\n} else {\r\noutw(ISREG_LCD, dev->base_addr + SONIC_ISREG);\r\n#ifdef DEBUG\r\nprintk("Loading CAM done, address pointers %04x:%04x\n",\r\ninw(dev->base_addr + SONIC_URRA),\r\ninw(dev->base_addr + SONIC_CAMPTR));\r\n{\r\nint z;\r\nprintk("\n-->CAM: PTR %04x CNT %04x\n",\r\ninw(dev->base_addr + SONIC_CAMPTR),\r\ninw(dev->base_addr + SONIC_CAMCNT));\r\noutw(CMDREG_RST, dev->base_addr + SONIC_CMDREG);\r\nfor (z = 0; z < camcnt; z++) {\r\noutw(z, dev->base_addr + SONIC_CAMEPTR);\r\nprintk("Entry %d: %04x %04x %04x\n", z,\r\ninw(dev->base_addr + SONIC_CAMADDR0),\r\ninw(dev->base_addr + SONIC_CAMADDR1),\r\ninw(dev->base_addr + SONIC_CAMADDR2));\r\n}\r\noutw(0, dev->base_addr + SONIC_CMDREG);\r\n}\r\n#endif\r\n}\r\nrcrval = RCREG_BRD | RCREG_LB_NONE;\r\nif ((dev->flags & IFF_ALLMULTI) || netdev_mc_count(dev) > camcnt)\r\nrcrval |= RCREG_AMC;\r\nif (dev->flags & IFF_PROMISC)\r\nrcrval |= RCREG_PRO;\r\noutw(rcrval, dev->base_addr + SONIC_RCREG);\r\n#ifdef DEBUG\r\nprintk("\nRCRVAL: %04x\n", rcrval);\r\n#endif\r\nInitDscrs(dev);\r\nif (!InitSONIC(dev))\r\nreturn;\r\noutw(0xffff, dev->base_addr + SONIC_ISREG);\r\noutw(CMDREG_RXEN, dev->base_addr + SONIC_CMDREG);\r\noutw(IMREG_PRXEN | IMREG_RBEEN | IMREG_PTXEN | IMREG_TXEREN, dev->base_addr + SONIC_IMREG);\r\noutb(inb(dev->base_addr + BCMREG) | BCMREG_IEN, dev->base_addr + BCMREG);\r\n#ifdef DEBUG\r\nprintk("Register dump after initialization:\n");\r\ndumpregs(dev);\r\n#endif\r\n}\r\nstatic void StartTx(struct net_device *dev, int descr)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\nint addr;\r\naddr = priv->tdastart + (descr * sizeof(tda_t));\r\noutw(addr, dev->base_addr + SONIC_CTDA);\r\npriv->currtxdescr = descr;\r\noutw(CMDREG_TXP, dev->base_addr + SONIC_CMDREG);\r\n}\r\nstatic void irqrbe_handler(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\noutw(priv->rrastart, dev->base_addr + SONIC_RRP);\r\noutw(priv->rrastart, dev->base_addr + SONIC_RWP);\r\n}\r\nstatic void irqrx_handler(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\nrda_t rda;\r\nu32 rdaaddr, lrdaaddr;\r\nwhile (1) {\r\nrdaaddr = priv->rdastart + (priv->nextrxdescr * sizeof(rda_t));\r\nlrdaaddr = priv->rdastart + (priv->lastrxdescr * sizeof(rda_t));\r\nmemcpy_fromio(&rda, priv->base + rdaaddr, sizeof(rda_t));\r\nrda.status &= 0xffff;\r\nrda.length &= 0xffff;\r\nrda.startlo &= 0xffff;\r\nif (rda.inuse)\r\nbreak;\r\nelse if (rda.status & RCREG_PRX) {\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, rda.length + 2);\r\nif (skb == NULL)\r\ndev->stats.rx_dropped++;\r\nelse {\r\nmemcpy_fromio(skb_put(skb, rda.length),\r\npriv->base +\r\nrda.startlo, rda.length);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nskb_checksum_none_assert(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += rda.length;\r\nnetif_rx(skb);\r\n}\r\n}\r\nelse {\r\ndev->stats.rx_errors++;\r\nif (rda.status & RCREG_FAER)\r\ndev->stats.rx_frame_errors++;\r\nif (rda.status & RCREG_CRCR)\r\ndev->stats.rx_crc_errors++;\r\n}\r\nrda.link = 1;\r\nrda.inuse = 1;\r\nmemcpy_toio(priv->base + rdaaddr, &rda,\r\nsizeof(rda_t));\r\nmemcpy_toio(priv->base + lrdaaddr + 20, &rdaaddr, 4);\r\npriv->lastrxdescr = priv->nextrxdescr;\r\nif ((++priv->nextrxdescr) >= priv->rxbufcnt)\r\npriv->nextrxdescr = 0;\r\n}\r\n}\r\nstatic void irqtx_handler(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\ntda_t tda;\r\nmemcpy_fromio(&tda, priv->base + priv->tdastart + (priv->currtxdescr * sizeof(tda_t)), sizeof(tda_t));\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += tda.length;\r\npriv->txused[priv->currtxdescr] = 0;\r\npriv->txusedcnt--;\r\nif (priv->txusedcnt > 0)\r\nStartTx(dev, (priv->currtxdescr + 1) % TXBUFCNT);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void irqtxerr_handler(struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\ntda_t tda;\r\nmemcpy_fromio(&tda, priv->base + priv->tdastart + (priv->currtxdescr * sizeof(tda_t)), sizeof(tda_t));\r\ndev->stats.tx_errors++;\r\nif (tda.status & (TCREG_NCRS | TCREG_CRSL))\r\ndev->stats.tx_carrier_errors++;\r\nif (tda.status & TCREG_EXC)\r\ndev->stats.tx_aborted_errors++;\r\nif (tda.status & TCREG_OWC)\r\ndev->stats.tx_window_errors++;\r\nif (tda.status & TCREG_FU)\r\ndev->stats.tx_fifo_errors++;\r\npriv->txused[priv->currtxdescr] = 0;\r\npriv->txusedcnt--;\r\nif (priv->txusedcnt > 0)\r\nStartTx(dev, (priv->currtxdescr + 1) % TXBUFCNT);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic irqreturn_t irq_handler(int dummy, void *device)\r\n{\r\nstruct net_device *dev = device;\r\nu16 ival;\r\nif (!(inb(dev->base_addr + BCMREG) & BCMREG_IPEND))\r\nreturn IRQ_NONE;\r\nwhile (1) {\r\nival = inw(dev->base_addr + SONIC_ISREG);\r\nif (ival & ISREG_RBE) {\r\nirqrbe_handler(dev);\r\noutw(ISREG_RBE, dev->base_addr + SONIC_ISREG);\r\n}\r\nif (ival & ISREG_PKTRX) {\r\nirqrx_handler(dev);\r\noutw(ISREG_PKTRX, dev->base_addr + SONIC_ISREG);\r\n}\r\nif (ival & ISREG_TXDN) {\r\nirqtx_handler(dev);\r\noutw(ISREG_TXDN, dev->base_addr + SONIC_ISREG);\r\n}\r\nif (ival & ISREG_TXER) {\r\nirqtxerr_handler(dev);\r\noutw(ISREG_TXER, dev->base_addr + SONIC_ISREG);\r\n}\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ibmlana_open(struct net_device *dev)\r\n{\r\nint result;\r\nibmlana_priv *priv = netdev_priv(dev);\r\nresult = request_irq(priv->realirq, irq_handler, IRQF_SHARED,\r\ndev->name, dev);\r\nif (result != 0) {\r\nprintk(KERN_ERR "%s: failed to register irq %d\n", dev->name, dev->irq);\r\nreturn result;\r\n}\r\ndev->irq = priv->realirq;\r\nInitBoard(dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ibmlana_close(struct net_device *dev)\r\n{\r\nif (dev->irq != 0)\r\nfree_irq(dev->irq, dev);\r\ndev->irq = 0;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ibmlana_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nibmlana_priv *priv = netdev_priv(dev);\r\nint tmplen, addr;\r\nunsigned long flags;\r\ntda_t tda;\r\nint baddr;\r\nif (priv->txusedcnt >= TXBUFCNT) {\r\ndev->stats.tx_dropped++;\r\ngoto tx_done;\r\n}\r\ntmplen = skb->len;\r\nif (tmplen < 60)\r\ntmplen = 60;\r\nbaddr = priv->txbufstart + (priv->nexttxdescr * PKTSIZE);\r\nmemcpy_toio(priv->base + baddr, skb->data, skb->len);\r\nif (tmplen > skb->len) {\r\nchar *fill = "NetBSD is a nice OS too! ";\r\nunsigned int destoffs = skb->len, l = strlen(fill);\r\nwhile (destoffs < tmplen) {\r\nmemcpy_toio(priv->base + baddr + destoffs, fill, l);\r\ndestoffs += l;\r\n}\r\n}\r\naddr = priv->tdastart + (priv->nexttxdescr * sizeof(tda_t));\r\nmemcpy_fromio(&tda, priv->base + addr, sizeof(tda_t));\r\ntda.length = tda.fraglength = tmplen;\r\nmemcpy_toio(priv->base + addr, &tda, sizeof(tda_t));\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->txusedcnt++;\r\npriv->txused[priv->nexttxdescr] = 1;\r\nif (priv->txusedcnt >= TXBUFCNT)\r\nnetif_stop_queue(dev);\r\nif (priv->txusedcnt == 1)\r\nStartTx(dev, priv->nexttxdescr);\r\npriv->nexttxdescr = (priv->nexttxdescr + 1) % TXBUFCNT;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ntx_done:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ibmlana_set_multicast_list(struct net_device *dev)\r\n{\r\nStopSONIC(dev);\r\nInitBoard(dev);\r\n}\r\nstatic int __devinit ibmlana_init_one(struct device *kdev)\r\n{\r\nstruct mca_device *mdev = to_mca_device(kdev);\r\nstruct net_device *dev;\r\nint slot = mdev->slot, z, rc;\r\nint base = 0, irq = 0, iobase = 0, memlen = 0;\r\nibmlana_priv *priv;\r\nibmlana_medium medium;\r\ndev = alloc_etherdev(sizeof(ibmlana_priv));\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->irq = ibmlana_irq;\r\ndev->base_addr = ibmlana_io;\r\nbase = dev->mem_start;\r\nirq = dev->irq;\r\ngetaddrs(mdev, &base, &memlen, &iobase, &irq, &medium);\r\nif (dev->irq && dev->irq != irq) {\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nif (dev->mem_start && dev->mem_start != base) {\r\nrc = -ENODEV;\r\ngoto err_out;\r\n}\r\nprintk(KERN_INFO "%s: IBM LAN Adapter/A found in slot %d\n", dev->name, slot + 1);\r\nif (!request_region(iobase, IBM_LANA_IORANGE, DRV_NAME)) {\r\nprintk(KERN_ERR "%s: cannot allocate I/O range at %#x!\n", DRV_NAME, iobase);\r\nstartslot = slot + 1;\r\nrc = -EBUSY;\r\ngoto err_out;\r\n}\r\npriv = netdev_priv(dev);\r\npriv->slot = slot;\r\npriv->realirq = mca_device_transform_irq(mdev, irq);\r\npriv->medium = medium;\r\nspin_lock_init(&priv->lock);\r\ndev->irq = 0;\r\ndev->mem_start = base;\r\ndev->mem_end = base + memlen;\r\ndev->base_addr = iobase;\r\npriv->base = ioremap(base, memlen);\r\nif (!priv->base) {\r\nprintk(KERN_ERR "%s: cannot remap memory!\n", DRV_NAME);\r\nstartslot = slot + 1;\r\nrc = -EBUSY;\r\ngoto err_out_reg;\r\n}\r\nmca_device_set_name(mdev, ibmlana_adapter_names[mdev->index]);\r\nmca_device_set_claim(mdev, 1);\r\ndev->netdev_ops = &ibmlana_netdev_ops;\r\ndev->flags |= IFF_MULTICAST;\r\nfor (z = 0; z < ETH_ALEN; z++)\r\ndev->dev_addr[z] = inb(dev->base_addr + MACADDRPROM + z);\r\nprintk(KERN_INFO "%s: IRQ %d, I/O %#lx, memory %#lx-%#lx, "\r\n"MAC address %pM.\n",\r\ndev->name, priv->realirq, dev->base_addr,\r\ndev->mem_start, dev->mem_end - 1,\r\ndev->dev_addr);\r\nprintk(KERN_INFO "%s: %s medium\n", dev->name, MediaNames[priv->medium]);\r\nResetBoard(dev);\r\nstartslot = slot + 1;\r\nrc = register_netdev(dev);\r\nif (rc)\r\ngoto err_out_claimed;\r\ndev_set_drvdata(kdev, dev);\r\nreturn 0;\r\nerr_out_claimed:\r\nmca_device_set_claim(mdev, 0);\r\niounmap(priv->base);\r\nerr_out_reg:\r\nrelease_region(iobase, IBM_LANA_IORANGE);\r\nerr_out:\r\nfree_netdev(dev);\r\nreturn rc;\r\n}\r\nstatic int ibmlana_remove_one(struct device *kdev)\r\n{\r\nstruct mca_device *mdev = to_mca_device(kdev);\r\nstruct net_device *dev = dev_get_drvdata(kdev);\r\nibmlana_priv *priv = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nrelease_region(dev->base_addr, IBM_LANA_IORANGE);\r\nmca_device_set_claim(mdev, 0);\r\niounmap(priv->base);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init ibmlana_init_module(void)\r\n{\r\nreturn mca_register_driver(&ibmlana_driver);\r\n}\r\nstatic void __exit ibmlana_cleanup_module(void)\r\n{\r\nmca_unregister_driver(&ibmlana_driver);\r\n}
