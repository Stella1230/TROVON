static int __init do_lne390_probe(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\nint irq = dev->irq;\r\nint mem_start = dev->mem_start;\r\nint ret;\r\nif (ioaddr > 0x1ff) {\r\nif (!request_region(ioaddr, LNE390_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nret = lne390_probe1(dev, ioaddr);\r\nif (ret)\r\nrelease_region(ioaddr, LNE390_IO_EXTENT);\r\nreturn ret;\r\n}\r\nelse if (ioaddr > 0)\r\nreturn -ENXIO;\r\nif (!EISA_bus) {\r\n#if LNE390_DEBUG & LNE390_D_PROBE\r\nprintk("lne390-debug: Not an EISA bus. Not probing high ports.\n");\r\n#endif\r\nreturn -ENXIO;\r\n}\r\nfor (ioaddr = 0x1000; ioaddr < 0x9000; ioaddr += 0x1000) {\r\nif (!request_region(ioaddr, LNE390_IO_EXTENT, DRV_NAME))\r\ncontinue;\r\nif (lne390_probe1(dev, ioaddr) == 0)\r\nreturn 0;\r\nrelease_region(ioaddr, LNE390_IO_EXTENT);\r\ndev->irq = irq;\r\ndev->mem_start = mem_start;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init lne390_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_ei_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_lne390_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init lne390_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, revision, ret;\r\nunsigned long eisa_id;\r\nif (inb_p(ioaddr + LNE390_ID_PORT) == 0xff) return -ENODEV;\r\n#if LNE390_DEBUG & LNE390_D_PROBE\r\nprintk("lne390-debug: probe at %#x, ID %#8x\n", ioaddr, inl(ioaddr + LNE390_ID_PORT));\r\nprintk("lne390-debug: config regs: %#x %#x\n",\r\ninb(ioaddr + LNE390_CFG1), inb(ioaddr + LNE390_CFG2));\r\n#endif\r\neisa_id = inl(ioaddr + LNE390_ID_PORT);\r\nif ((eisa_id != LNE390_ID0) && (eisa_id != LNE390_ID1)) {\r\nreturn -ENODEV;\r\n}\r\nrevision = (eisa_id >> 24) & 0x01;\r\n#if 0\r\nif (inb(ioaddr + LNE390_SA_PROM + 0) != LNE390_ADDR0\r\n|| inb(ioaddr + LNE390_SA_PROM + 1) != LNE390_ADDR1\r\n|| inb(ioaddr + LNE390_SA_PROM + 2) != LNE390_ADDR2 ) {\r\nprintk("lne390.c: card not found");\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nprintk(" %02x", inb(ioaddr + LNE390_SA_PROM + i));\r\nprintk(" (invalid prefix).\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = inb(ioaddr + LNE390_SA_PROM + i);\r\nprintk("lne390.c: LNE390%X in EISA slot %d, address %pM.\n",\r\n0xa+revision, ioaddr/0x1000, dev->dev_addr);\r\nprintk("lne390.c: ");\r\nif (dev->irq == 0) {\r\nunsigned char irq_reg = inb(ioaddr + LNE390_CFG2) >> 3;\r\ndev->irq = irq_map[irq_reg & 0x07];\r\nprintk("using");\r\n} else {\r\nif (dev->irq == 2) dev->irq = 9;\r\nprintk("assigning");\r\n}\r\nprintk(" IRQ %d,", dev->irq);\r\nif ((ret = request_irq(dev->irq, ei_interrupt, 0, DRV_NAME, dev))) {\r\nprintk (" unable to get IRQ %d.\n", dev->irq);\r\nreturn ret;\r\n}\r\nif (dev->mem_start == 0) {\r\nunsigned char mem_reg = inb(ioaddr + LNE390_CFG2) & 0x07;\r\nif (revision)\r\ndev->mem_start = shmem_mapB[mem_reg] * 0x10000;\r\nelse\r\ndev->mem_start = shmem_mapA[mem_reg] * 0x10000;\r\nprintk(" using ");\r\n} else {\r\ndev->mem_start &= 0xfff0000;\r\nprintk(" assigning ");\r\n}\r\nprintk("%dkB memory at physical address %#lx\n",\r\nLNE390_STOP_PG/4, dev->mem_start);\r\nei_status.mem = ioremap(dev->mem_start, LNE390_STOP_PG*0x100);\r\nif (!ei_status.mem) {\r\nprintk(KERN_ERR "lne390.c: Unable to remap card memory above 1MB !!\n");\r\nprintk(KERN_ERR "lne390.c: Try using EISA SCU to set memory below 1MB.\n");\r\nprintk(KERN_ERR "lne390.c: Driver NOT installed.\n");\r\nret = -EAGAIN;\r\ngoto cleanup;\r\n}\r\nprintk("lne390.c: remapped %dkB card memory to virtual address %p\n",\r\nLNE390_STOP_PG/4, ei_status.mem);\r\ndev->mem_start = (unsigned long)ei_status.mem;\r\ndev->mem_end = dev->mem_start + (LNE390_STOP_PG - LNE390_START_PG)*256;\r\ndev->base_addr = ioaddr;\r\nei_status.name = "LNE390";\r\nei_status.tx_start_page = LNE390_START_PG;\r\nei_status.rx_start_page = LNE390_START_PG + TX_PAGES;\r\nei_status.stop_page = LNE390_STOP_PG;\r\nei_status.word16 = 1;\r\nif (ei_debug > 0)\r\nprintk(version);\r\nei_status.reset_8390 = &lne390_reset_8390;\r\nei_status.block_input = &lne390_block_input;\r\nei_status.block_output = &lne390_block_output;\r\nei_status.get_8390_hdr = &lne390_get_8390_hdr;\r\ndev->netdev_ops = &ei_netdev_ops;\r\nNS8390_init(dev, 0);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto unmap;\r\nreturn 0;\r\nunmap:\r\nif (ei_status.reg0)\r\niounmap(ei_status.mem);\r\ncleanup:\r\nfree_irq(dev->irq, dev);\r\nreturn ret;\r\n}\r\nstatic void lne390_reset_8390(struct net_device *dev)\r\n{\r\nunsigned short ioaddr = dev->base_addr;\r\noutb(0x04, ioaddr + LNE390_RESET_PORT);\r\nif (ei_debug > 1) printk("%s: resetting the LNE390...", dev->name);\r\nmdelay(2);\r\nei_status.txing = 0;\r\noutb(0x01, ioaddr + LNE390_RESET_PORT);\r\nif (ei_debug > 1) printk("reset done\n");\r\n}\r\nstatic void\r\nlne390_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nvoid __iomem *hdr_start = ei_status.mem + ((ring_page - LNE390_START_PG)<<8);\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = (hdr->count + 3) & ~3;\r\n}\r\nstatic void lne390_block_input(struct net_device *dev, int count, struct sk_buff *skb,\r\nint ring_offset)\r\n{\r\nvoid __iomem *xfer_start = ei_status.mem + ring_offset - (LNE390_START_PG<<8);\r\nif (ring_offset + count > (LNE390_STOP_PG<<8)) {\r\nint semi_count = (LNE390_STOP_PG<<8) - ring_offset;\r\nmemcpy_fromio(skb->data, xfer_start, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count,\r\nei_status.mem + (TX_PAGES<<8), count);\r\n} else {\r\nmemcpy_fromio(skb->data, xfer_start, count);\r\n}\r\n}\r\nstatic void lne390_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, int start_page)\r\n{\r\nvoid __iomem *shmem = ei_status.mem + ((start_page - LNE390_START_PG)<<8);\r\ncount = (count + 3) & ~3;\r\nmemcpy_toio(shmem, buf, count);\r\n}\r\nint __init init_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_LNE_CARDS; this_dev++) {\r\nif (io[this_dev] == 0 && this_dev != 0)\r\nbreak;\r\ndev = alloc_ei_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\ndev->mem_start = mem[this_dev];\r\nif (do_lne390_probe(dev) == 0) {\r\ndev_lne[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "lne390.c: No LNE390 card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, LNE390_IO_EXTENT);\r\niounmap(ei_status.mem);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_LNE_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_lne[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
