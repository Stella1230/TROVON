static int ns2_led_get_mode(struct ns2_led_data *led_dat,\r\nenum ns2_led_modes *mode)\r\n{\r\nint i;\r\nint ret = -EINVAL;\r\nint cmd_level;\r\nint slow_level;\r\nread_lock_irq(&led_dat->rw_lock);\r\ncmd_level = gpio_get_value(led_dat->cmd);\r\nslow_level = gpio_get_value(led_dat->slow);\r\nfor (i = 0; i < ARRAY_SIZE(ns2_led_modval); i++) {\r\nif (cmd_level == ns2_led_modval[i].cmd_level &&\r\nslow_level == ns2_led_modval[i].slow_level) {\r\n*mode = ns2_led_modval[i].mode;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nread_unlock_irq(&led_dat->rw_lock);\r\nreturn ret;\r\n}\r\nstatic void ns2_led_set_mode(struct ns2_led_data *led_dat,\r\nenum ns2_led_modes mode)\r\n{\r\nint i;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&led_dat->rw_lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(ns2_led_modval); i++) {\r\nif (mode == ns2_led_modval[i].mode) {\r\ngpio_set_value(led_dat->cmd,\r\nns2_led_modval[i].cmd_level);\r\ngpio_set_value(led_dat->slow,\r\nns2_led_modval[i].slow_level);\r\n}\r\n}\r\nwrite_unlock_irqrestore(&led_dat->rw_lock, flags);\r\n}\r\nstatic void ns2_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nenum ns2_led_modes mode;\r\nif (value == LED_OFF)\r\nmode = NS_V2_LED_OFF;\r\nelse if (led_dat->sata)\r\nmode = NS_V2_LED_SATA;\r\nelse\r\nmode = NS_V2_LED_ON;\r\nns2_led_set_mode(led_dat, mode);\r\n}\r\nstatic ssize_t ns2_led_sata_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buff, size_t count)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nint ret;\r\nunsigned long enable;\r\nenum ns2_led_modes mode;\r\nret = strict_strtoul(buff, 10, &enable);\r\nif (ret < 0)\r\nreturn ret;\r\nenable = !!enable;\r\nif (led_dat->sata == enable)\r\nreturn count;\r\nret = ns2_led_get_mode(led_dat, &mode);\r\nif (ret < 0)\r\nreturn ret;\r\nif (enable && mode == NS_V2_LED_ON)\r\nns2_led_set_mode(led_dat, NS_V2_LED_SATA);\r\nif (!enable && mode == NS_V2_LED_SATA)\r\nns2_led_set_mode(led_dat, NS_V2_LED_ON);\r\nled_dat->sata = enable;\r\nreturn count;\r\n}\r\nstatic ssize_t ns2_led_sata_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct led_classdev *led_cdev = dev_get_drvdata(dev);\r\nstruct ns2_led_data *led_dat =\r\ncontainer_of(led_cdev, struct ns2_led_data, cdev);\r\nreturn sprintf(buf, "%d\n", led_dat->sata);\r\n}\r\nstatic int __devinit\r\ncreate_ns2_led(struct platform_device *pdev, struct ns2_led_data *led_dat,\r\nconst struct ns2_led *template)\r\n{\r\nint ret;\r\nenum ns2_led_modes mode;\r\nret = gpio_request(template->cmd, template->name);\r\nif (ret == 0) {\r\nret = gpio_direction_output(template->cmd,\r\ngpio_get_value(template->cmd));\r\nif (ret)\r\ngpio_free(template->cmd);\r\n}\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: failed to setup command GPIO\n",\r\ntemplate->name);\r\n}\r\nret = gpio_request(template->slow, template->name);\r\nif (ret == 0) {\r\nret = gpio_direction_output(template->slow,\r\ngpio_get_value(template->slow));\r\nif (ret)\r\ngpio_free(template->slow);\r\n}\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: failed to setup slow GPIO\n",\r\ntemplate->name);\r\ngoto err_free_cmd;\r\n}\r\nrwlock_init(&led_dat->rw_lock);\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->cdev.blink_set = NULL;\r\nled_dat->cdev.brightness_set = ns2_led_set;\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled_dat->cmd = template->cmd;\r\nled_dat->slow = template->slow;\r\nret = ns2_led_get_mode(led_dat, &mode);\r\nif (ret < 0)\r\ngoto err_free_slow;\r\nled_dat->sata = (mode == NS_V2_LED_SATA) ? 1 : 0;\r\nled_dat->cdev.brightness =\r\n(mode == NS_V2_LED_OFF) ? LED_OFF : LED_FULL;\r\nret = led_classdev_register(&pdev->dev, &led_dat->cdev);\r\nif (ret < 0)\r\ngoto err_free_slow;\r\nret = device_create_file(led_dat->cdev.dev, &dev_attr_sata);\r\nif (ret < 0)\r\ngoto err_free_cdev;\r\nreturn 0;\r\nerr_free_cdev:\r\nled_classdev_unregister(&led_dat->cdev);\r\nerr_free_slow:\r\ngpio_free(led_dat->slow);\r\nerr_free_cmd:\r\ngpio_free(led_dat->cmd);\r\nreturn ret;\r\n}\r\nstatic void delete_ns2_led(struct ns2_led_data *led_dat)\r\n{\r\ndevice_remove_file(led_dat->cdev.dev, &dev_attr_sata);\r\nled_classdev_unregister(&led_dat->cdev);\r\ngpio_free(led_dat->cmd);\r\ngpio_free(led_dat->slow);\r\n}\r\nstatic int __devinit ns2_led_probe(struct platform_device *pdev)\r\n{\r\nstruct ns2_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct ns2_led_data *leds_data;\r\nint i;\r\nint ret;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nleds_data = kzalloc(sizeof(struct ns2_led_data) *\r\npdata->num_leds, GFP_KERNEL);\r\nif (!leds_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pdata->num_leds; i++) {\r\nret = create_ns2_led(pdev, &leds_data[i], &pdata->leds[i]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, leds_data);\r\nreturn 0;\r\nerr:\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_ns2_led(&leds_data[i]);\r\nkfree(leds_data);\r\nreturn ret;\r\n}\r\nstatic int __devexit ns2_led_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct ns2_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct ns2_led_data *leds_data;\r\nleds_data = platform_get_drvdata(pdev);\r\nfor (i = 0; i < pdata->num_leds; i++)\r\ndelete_ns2_led(&leds_data[i]);\r\nkfree(leds_data);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
