static void atmel_abdac_dma_period_done(void *arg)\r\n{\r\nstruct atmel_abdac *dac = arg;\r\nsnd_pcm_period_elapsed(dac->substream);\r\n}\r\nstatic int atmel_abdac_prepare_dma(struct atmel_abdac *dac,\r\nstruct snd_pcm_substream *substream,\r\nenum dma_data_direction direction)\r\n{\r\nstruct dma_chan *chan = dac->dma.chan;\r\nstruct dw_cyclic_desc *cdesc;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long buffer_len, period_len;\r\nif (runtime->dma_addr & 1 || runtime->buffer_size & 1) {\r\ndev_dbg(&dac->pdev->dev, "too complex transfer\n");\r\nreturn -EINVAL;\r\n}\r\nbuffer_len = frames_to_bytes(runtime, runtime->buffer_size);\r\nperiod_len = frames_to_bytes(runtime, runtime->period_size);\r\ncdesc = dw_dma_cyclic_prep(chan, runtime->dma_addr, buffer_len,\r\nperiod_len, DMA_MEM_TO_DEV);\r\nif (IS_ERR(cdesc)) {\r\ndev_dbg(&dac->pdev->dev, "could not prepare cyclic DMA\n");\r\nreturn PTR_ERR(cdesc);\r\n}\r\ncdesc->period_callback = atmel_abdac_dma_period_done;\r\ncdesc->period_callback_param = dac;\r\ndac->dma.cdesc = cdesc;\r\nset_bit(DMA_READY, &dac->flags);\r\nreturn 0;\r\n}\r\nstatic int atmel_abdac_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\ndac->substream = substream;\r\natmel_abdac_hw.rate_max = dac->rates[dac->rates_num - 1];\r\natmel_abdac_hw.rate_min = dac->rates[0];\r\nsubstream->runtime->hw = atmel_abdac_hw;\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &dac->constraints_rates);\r\n}\r\nstatic int atmel_abdac_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\ndac->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int atmel_abdac_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\nint retval;\r\nretval = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (retval < 0)\r\nreturn retval;\r\nif (retval == 1)\r\nif (test_and_clear_bit(DMA_READY, &dac->flags))\r\ndw_dma_cyclic_free(dac->dma.chan);\r\nreturn retval;\r\n}\r\nstatic int atmel_abdac_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\nif (test_and_clear_bit(DMA_READY, &dac->flags))\r\ndw_dma_cyclic_free(dac->dma.chan);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int atmel_abdac_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\nint retval;\r\nretval = clk_set_rate(dac->sample_clk, 256 * substream->runtime->rate);\r\nif (retval)\r\nreturn retval;\r\nif (!test_bit(DMA_READY, &dac->flags))\r\nretval = atmel_abdac_prepare_dma(dac, substream, DMA_TO_DEVICE);\r\nreturn retval;\r\n}\r\nstatic int atmel_abdac_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\nint retval = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\nclk_enable(dac->sample_clk);\r\nretval = dw_dma_cyclic_start(dac->dma.chan);\r\nif (retval)\r\ngoto out;\r\ndac_writel(dac, CTRL, DAC_BIT(EN));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndw_dma_cyclic_stop(dac->dma.chan);\r\ndac_writel(dac, DATA, 0);\r\ndac_writel(dac, CTRL, 0);\r\nclk_disable(dac->sample_clk);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nstatic snd_pcm_uframes_t\r\natmel_abdac_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_abdac *dac = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t frames;\r\nunsigned long bytes;\r\nbytes = dw_dma_get_src_addr(dac->dma.chan);\r\nbytes -= runtime->dma_addr;\r\nframes = bytes_to_frames(runtime, bytes);\r\nif (frames >= runtime->buffer_size)\r\nframes -= runtime->buffer_size;\r\nreturn frames;\r\n}\r\nstatic irqreturn_t abdac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct atmel_abdac *dac = dev_id;\r\nu32 status;\r\nstatus = dac_readl(dac, INT_STATUS);\r\nif (status & DAC_BIT(UNDERRUN)) {\r\ndev_err(&dac->pdev->dev, "underrun detected\n");\r\ndac_writel(dac, INT_CLR, DAC_BIT(UNDERRUN));\r\n} else {\r\ndev_err(&dac->pdev->dev, "spurious interrupt (status=0x%x)\n",\r\nstatus);\r\ndac_writel(dac, INT_CLR, status);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit atmel_abdac_pcm_new(struct atmel_abdac *dac)\r\n{\r\nstruct snd_pcm_hardware hw = atmel_abdac_hw;\r\nstruct snd_pcm *pcm;\r\nint retval;\r\nretval = snd_pcm_new(dac->card, dac->card->shortname,\r\ndac->pdev->id, 1, 0, &pcm);\r\nif (retval)\r\nreturn retval;\r\nstrcpy(pcm->name, dac->card->shortname);\r\npcm->private_data = dac;\r\npcm->info_flags = 0;\r\ndac->pcm = pcm;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &atmel_abdac_ops);\r\nretval = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\n&dac->pdev->dev, hw.periods_min * hw.period_bytes_min,\r\nhw.buffer_bytes_max);\r\nreturn retval;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct dw_dma_slave *dws = slave;\r\nif (dws->dma_dev == chan->device->dev) {\r\nchan->private = dws;\r\nreturn true;\r\n} else\r\nreturn false;\r\n}\r\nstatic int set_sample_rates(struct atmel_abdac *dac)\r\n{\r\nlong new_rate = RATE_MAX;\r\nint retval = -EINVAL;\r\nint index = 0;\r\nwhile (new_rate >= RATE_MIN && index < (MAX_NUM_RATES + 1)) {\r\nnew_rate = clk_round_rate(dac->sample_clk, 256 * new_rate);\r\nif (new_rate < 0)\r\nbreak;\r\nif (new_rate <= clk_get_rate(dac->pclk)) {\r\ndac->rates[index] = new_rate / 256;\r\nindex++;\r\n}\r\nnew_rate /= 256 * 2;\r\n}\r\nif (index) {\r\nint i;\r\nfor (i = 0; i < (index / 2); i++) {\r\nunsigned int tmp = dac->rates[index - 1 - i];\r\ndac->rates[index - 1 - i] = dac->rates[i];\r\ndac->rates[i] = tmp;\r\n}\r\ndac->constraints_rates.count = index;\r\ndac->constraints_rates.list = dac->rates;\r\ndac->constraints_rates.mask = 0;\r\ndac->rates_num = index;\r\nretval = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic int __devinit atmel_abdac_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card;\r\nstruct atmel_abdac *dac;\r\nstruct resource *regs;\r\nstruct atmel_abdac_pdata *pdata;\r\nstruct clk *pclk;\r\nstruct clk *sample_clk;\r\nint retval;\r\nint irq;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_dbg(&pdev->dev, "no memory resource\n");\r\nreturn -ENXIO;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_dbg(&pdev->dev, "could not get IRQ number\n");\r\nreturn irq;\r\n}\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_dbg(&pdev->dev, "no platform data\n");\r\nreturn -ENXIO;\r\n}\r\npclk = clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(pclk)) {\r\ndev_dbg(&pdev->dev, "no peripheral clock\n");\r\nreturn PTR_ERR(pclk);\r\n}\r\nsample_clk = clk_get(&pdev->dev, "sample_clk");\r\nif (IS_ERR(sample_clk)) {\r\ndev_dbg(&pdev->dev, "no sample clock\n");\r\nretval = PTR_ERR(sample_clk);\r\ngoto out_put_pclk;\r\n}\r\nclk_enable(pclk);\r\nretval = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\r\nTHIS_MODULE, sizeof(struct atmel_abdac), &card);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not create sound card device\n");\r\ngoto out_put_sample_clk;\r\n}\r\ndac = get_dac(card);\r\ndac->irq = irq;\r\ndac->card = card;\r\ndac->pclk = pclk;\r\ndac->sample_clk = sample_clk;\r\ndac->pdev = pdev;\r\nretval = set_sample_rates(dac);\r\nif (retval < 0) {\r\ndev_dbg(&pdev->dev, "could not set supported rates\n");\r\ngoto out_free_card;\r\n}\r\ndac->regs = ioremap(regs->start, resource_size(regs));\r\nif (!dac->regs) {\r\ndev_dbg(&pdev->dev, "could not remap register memory\n");\r\ngoto out_free_card;\r\n}\r\ndac_writel(dac, DATA, 0);\r\ndac_writel(dac, CTRL, 0);\r\nretval = request_irq(irq, abdac_interrupt, 0, "abdac", dac);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not request irq\n");\r\ngoto out_unmap_regs;\r\n}\r\nsnd_card_set_dev(card, &pdev->dev);\r\nif (pdata->dws.dma_dev) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndac->dma.chan = dma_request_channel(mask, filter, &pdata->dws);\r\nif (dac->dma.chan) {\r\nstruct dma_slave_config dma_conf = {\r\n.dst_addr = regs->start + DAC_DATA,\r\n.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\r\n.src_maxburst = 1,\r\n.dst_maxburst = 1,\r\n.direction = DMA_MEM_TO_DEV,\r\n.device_fc = false,\r\n};\r\ndmaengine_slave_config(dac->dma.chan, &dma_conf);\r\n}\r\n}\r\nif (!pdata->dws.dma_dev || !dac->dma.chan) {\r\ndev_dbg(&pdev->dev, "DMA not available\n");\r\nretval = -ENODEV;\r\ngoto out_unset_card_dev;\r\n}\r\nstrcpy(card->driver, "Atmel ABDAC");\r\nstrcpy(card->shortname, "Atmel ABDAC");\r\nsprintf(card->longname, "Atmel Audio Bitstream DAC");\r\nretval = atmel_abdac_pcm_new(dac);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not register ABDAC pcm device\n");\r\ngoto out_release_dma;\r\n}\r\nretval = snd_card_register(card);\r\nif (retval) {\r\ndev_dbg(&pdev->dev, "could not register sound card\n");\r\ngoto out_release_dma;\r\n}\r\nplatform_set_drvdata(pdev, card);\r\ndev_info(&pdev->dev, "Atmel ABDAC at 0x%p using %s\n",\r\ndac->regs, dev_name(&dac->dma.chan->dev->device));\r\nreturn retval;\r\nout_release_dma:\r\ndma_release_channel(dac->dma.chan);\r\ndac->dma.chan = NULL;\r\nout_unset_card_dev:\r\nsnd_card_set_dev(card, NULL);\r\nfree_irq(irq, dac);\r\nout_unmap_regs:\r\niounmap(dac->regs);\r\nout_free_card:\r\nsnd_card_free(card);\r\nout_put_sample_clk:\r\nclk_put(sample_clk);\r\nclk_disable(pclk);\r\nout_put_pclk:\r\nclk_put(pclk);\r\nreturn retval;\r\n}\r\nstatic int atmel_abdac_suspend(struct platform_device *pdev, pm_message_t msg)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nstruct atmel_abdac *dac = card->private_data;\r\ndw_dma_cyclic_stop(dac->dma.chan);\r\nclk_disable(dac->sample_clk);\r\nclk_disable(dac->pclk);\r\nreturn 0;\r\n}\r\nstatic int atmel_abdac_resume(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nstruct atmel_abdac *dac = card->private_data;\r\nclk_enable(dac->pclk);\r\nclk_enable(dac->sample_clk);\r\nif (test_bit(DMA_READY, &dac->flags))\r\ndw_dma_cyclic_start(dac->dma.chan);\r\nreturn 0;\r\n}\r\nstatic int __devexit atmel_abdac_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nstruct atmel_abdac *dac = get_dac(card);\r\nclk_put(dac->sample_clk);\r\nclk_disable(dac->pclk);\r\nclk_put(dac->pclk);\r\ndma_release_channel(dac->dma.chan);\r\ndac->dma.chan = NULL;\r\nsnd_card_set_dev(card, NULL);\r\niounmap(dac->regs);\r\nfree_irq(dac->irq, dac);\r\nsnd_card_free(card);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init atmel_abdac_init(void)\r\n{\r\nreturn platform_driver_probe(&atmel_abdac_driver,\r\natmel_abdac_probe);\r\n}\r\nstatic void __exit atmel_abdac_exit(void)\r\n{\r\nplatform_driver_unregister(&atmel_abdac_driver);\r\n}
