static inline u_int32_t gpi_i_bit(int i)\r\n{\r\nif (i < 10)\r\nreturn 1 << i;\r\nelse\r\nreturn 1 << (i + 14);\r\n}\r\nstatic inline u_int32_t gpo_o_bit(int i)\r\n{\r\nif (i < 11)\r\nreturn 1 << i;\r\nelse\r\nreturn 1 << (i + 14);\r\n}\r\nstatic inline u_int32_t gpio_i_bit(int i)\r\n{\r\nif (i < 14)\r\nreturn 1 << (i + 10);\r\nelse\r\nreturn 1 << (i + 14);\r\n}\r\nstatic inline u_int32_t gpio_o_bit(int i)\r\n{\r\nif (i < 14)\r\nreturn 1 << (i + 11);\r\nelse\r\nreturn 1 << (i + 13);\r\n}\r\nstatic int vx855gpio_direction_input(struct gpio_chip *gpio,\r\nunsigned int nr)\r\n{\r\nstruct vx855_gpio *vg = container_of(gpio, struct vx855_gpio, gpio);\r\nunsigned long flags;\r\nu_int32_t reg_out;\r\nif (nr < NR_VX855_GPI)\r\nreturn 0;\r\nif (nr < NR_VX855_GPInO)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nreg_out = inl(vg->io_gpo);\r\nreg_out |= gpio_o_bit(nr - NR_VX855_GPInO);\r\noutl(reg_out, vg->io_gpo);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vx855gpio_get(struct gpio_chip *gpio, unsigned int nr)\r\n{\r\nstruct vx855_gpio *vg = container_of(gpio, struct vx855_gpio, gpio);\r\nu_int32_t reg_in;\r\nint ret = 0;\r\nif (nr < NR_VX855_GPI) {\r\nreg_in = inl(vg->io_gpi);\r\nif (reg_in & gpi_i_bit(nr))\r\nret = 1;\r\n} else if (nr < NR_VX855_GPInO) {\r\nreg_in = inl(vg->io_gpo);\r\nif (reg_in & gpo_o_bit(nr - NR_VX855_GPI))\r\nret = 1;\r\n} else {\r\nreg_in = inl(vg->io_gpi);\r\nif (reg_in & gpio_i_bit(nr - NR_VX855_GPInO))\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void vx855gpio_set(struct gpio_chip *gpio, unsigned int nr,\r\nint val)\r\n{\r\nstruct vx855_gpio *vg = container_of(gpio, struct vx855_gpio, gpio);\r\nunsigned long flags;\r\nu_int32_t reg_out;\r\nif (nr < NR_VX855_GPI)\r\nreturn;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nreg_out = inl(vg->io_gpo);\r\nif (nr < NR_VX855_GPInO) {\r\nif (val)\r\nreg_out |= gpo_o_bit(nr - NR_VX855_GPI);\r\nelse\r\nreg_out &= ~gpo_o_bit(nr - NR_VX855_GPI);\r\n} else {\r\nif (val)\r\nreg_out |= gpio_o_bit(nr - NR_VX855_GPInO);\r\nelse\r\nreg_out &= ~gpio_o_bit(nr - NR_VX855_GPInO);\r\n}\r\noutl(reg_out, vg->io_gpo);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int vx855gpio_direction_output(struct gpio_chip *gpio,\r\nunsigned int nr, int val)\r\n{\r\nif (nr < NR_VX855_GPI)\r\nreturn -EINVAL;\r\nvx855gpio_set(gpio, nr, val);\r\nreturn 0;\r\n}\r\nstatic void vx855gpio_gpio_setup(struct vx855_gpio *vg)\r\n{\r\nstruct gpio_chip *c = &vg->gpio;\r\nc->label = "VX855 South Bridge";\r\nc->owner = THIS_MODULE;\r\nc->direction_input = vx855gpio_direction_input;\r\nc->direction_output = vx855gpio_direction_output;\r\nc->get = vx855gpio_get;\r\nc->set = vx855gpio_set;\r\nc->dbg_show = NULL;\r\nc->base = 0;\r\nc->ngpio = NR_VX855_GP;\r\nc->can_sleep = 0;\r\nc->names = vx855gpio_names;\r\n}\r\nstatic __devinit int vx855gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_gpi;\r\nstruct resource *res_gpo;\r\nstruct vx855_gpio *vg;\r\nint ret;\r\nres_gpi = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nres_gpo = platform_get_resource(pdev, IORESOURCE_IO, 1);\r\nif (!res_gpi || !res_gpo)\r\nreturn -EBUSY;\r\nvg = kzalloc(sizeof(*vg), GFP_KERNEL);\r\nif (!vg)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, vg);\r\ndev_info(&pdev->dev, "found VX855 GPIO controller\n");\r\nvg->io_gpi = res_gpi->start;\r\nvg->io_gpo = res_gpo->start;\r\nspin_lock_init(&vg->lock);\r\nif (!request_region(res_gpi->start, resource_size(res_gpi),\r\nMODULE_NAME "_gpi"))\r\ndev_warn(&pdev->dev,\r\n"GPI I/O resource busy, probably claimed by ACPI\n");\r\nelse\r\nvg->gpi_reserved = true;\r\nif (!request_region(res_gpo->start, resource_size(res_gpo),\r\nMODULE_NAME "_gpo"))\r\ndev_warn(&pdev->dev,\r\n"GPO I/O resource busy, probably claimed by ACPI\n");\r\nelse\r\nvg->gpo_reserved = true;\r\nvx855gpio_gpio_setup(vg);\r\nret = gpiochip_add(&vg->gpio);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register GPIOs\n");\r\ngoto out_release;\r\n}\r\nreturn 0;\r\nout_release:\r\nif (vg->gpi_reserved)\r\nrelease_region(res_gpi->start, resource_size(res_gpi));\r\nif (vg->gpo_reserved)\r\nrelease_region(res_gpi->start, resource_size(res_gpo));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(vg);\r\nreturn ret;\r\n}\r\nstatic int __devexit vx855gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct vx855_gpio *vg = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nif (gpiochip_remove(&vg->gpio))\r\ndev_err(&pdev->dev, "unable to remove gpio_chip?\n");\r\nif (vg->gpi_reserved) {\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nrelease_region(res->start, resource_size(res));\r\n}\r\nif (vg->gpo_reserved) {\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 1);\r\nrelease_region(res->start, resource_size(res));\r\n}\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(vg);\r\nreturn 0;\r\n}
