static int power4_reg_setup(struct op_counter_config *ctr,\r\nstruct op_system_config *sys,\r\nint num_ctrs)\r\n{\r\nint i;\r\nmmcr0_val = sys->mmcr0;\r\nmmcr1_val = sys->mmcr1;\r\nmmcra_val = sys->mmcra;\r\nfor (i = 0; i < cur_cpu_spec->num_pmcs; ++i)\r\nreset_value[i] = 0x80000000UL - ctr[i].count;\r\nif (sys->enable_kernel)\r\nmmcr0_val &= ~MMCR0_KERNEL_DISABLE;\r\nelse\r\nmmcr0_val |= MMCR0_KERNEL_DISABLE;\r\nif (sys->enable_user)\r\nmmcr0_val &= ~MMCR0_PROBLEM_DISABLE;\r\nelse\r\nmmcr0_val |= MMCR0_PROBLEM_DISABLE;\r\nif (__is_processor(PV_POWER4) || __is_processor(PV_POWER4p) ||\r\n__is_processor(PV_970) || __is_processor(PV_970FX) ||\r\n__is_processor(PV_970MP) || __is_processor(PV_970GX) ||\r\n__is_processor(PV_POWER5) || __is_processor(PV_POWER5p))\r\nuse_slot_nums = 1;\r\nreturn 0;\r\n}\r\nstatic inline int mmcra_must_set_sample(void)\r\n{\r\nif (__is_processor(PV_POWER4) || __is_processor(PV_POWER4p) ||\r\n__is_processor(PV_970) || __is_processor(PV_970FX) ||\r\n__is_processor(PV_970MP) || __is_processor(PV_970GX))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int power4_cpu_setup(struct op_counter_config *ctr)\r\n{\r\nunsigned int mmcr0 = mmcr0_val;\r\nunsigned long mmcra = mmcra_val;\r\nppc_enable_pmcs();\r\nmmcr0 |= MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\nmmcr0 |= MMCR0_FCM1|MMCR0_PMXE|MMCR0_FCECE;\r\nmmcr0 |= MMCR0_PMC1CE|MMCR0_PMCjCE;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\nmtspr(SPRN_MMCR1, mmcr1_val);\r\nif (mmcra_must_set_sample())\r\nmmcra |= MMCRA_SAMPLE_ENABLE;\r\nmtspr(SPRN_MMCRA, mmcra);\r\ndbg("setup on cpu %d, mmcr0 %lx\n", smp_processor_id(),\r\nmfspr(SPRN_MMCR0));\r\ndbg("setup on cpu %d, mmcr1 %lx\n", smp_processor_id(),\r\nmfspr(SPRN_MMCR1));\r\ndbg("setup on cpu %d, mmcra %lx\n", smp_processor_id(),\r\nmfspr(SPRN_MMCRA));\r\nreturn 0;\r\n}\r\nstatic int power4_start(struct op_counter_config *ctr)\r\n{\r\nint i;\r\nunsigned int mmcr0;\r\nmtmsrd(mfmsr() | MSR_PMM);\r\nfor (i = 0; i < cur_cpu_spec->num_pmcs; ++i) {\r\nif (ctr[i].enabled) {\r\nclassic_ctr_write(i, reset_value[i]);\r\n} else {\r\nclassic_ctr_write(i, 0);\r\n}\r\n}\r\nmmcr0 = mfspr(SPRN_MMCR0);\r\nmmcr0 &= ~MMCR0_PMAO;\r\nmmcr0 &= ~MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\noprofile_running = 1;\r\ndbg("start on cpu %d, mmcr0 %x\n", smp_processor_id(), mmcr0);\r\nreturn 0;\r\n}\r\nstatic void power4_stop(void)\r\n{\r\nunsigned int mmcr0;\r\nmmcr0 = mfspr(SPRN_MMCR0);\r\nmmcr0 |= MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\noprofile_running = 0;\r\ndbg("stop on cpu %d, mmcr0 %x\n", smp_processor_id(), mmcr0);\r\nmb();\r\n}\r\nstatic void __used hypervisor_bucket(void)\r\n{\r\n}\r\nstatic void __used rtas_bucket(void)\r\n{\r\n}\r\nstatic void __used kernel_unknown_bucket(void)\r\n{\r\n}\r\nstatic unsigned long get_pc(struct pt_regs *regs)\r\n{\r\nunsigned long pc = mfspr(SPRN_SIAR);\r\nunsigned long mmcra;\r\nunsigned long slot;\r\nif (!cur_cpu_spec->oprofile_mmcra_sihv)\r\nreturn pc;\r\nmmcra = mfspr(SPRN_MMCRA);\r\nif (use_slot_nums && (mmcra & MMCRA_SAMPLE_ENABLE)) {\r\nslot = ((mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT);\r\nif (slot > 1)\r\npc += 4 * (slot - 1);\r\n}\r\nif (firmware_has_feature(FW_FEATURE_LPAR) &&\r\n(mmcra & cur_cpu_spec->oprofile_mmcra_sihv))\r\nreturn *((unsigned long *)hypervisor_bucket);\r\nif (mmcra & cur_cpu_spec->oprofile_mmcra_sipr)\r\nreturn pc;\r\n#ifdef CONFIG_PPC_RTAS\r\nif (pc >= rtas.base && pc < (rtas.base + rtas.size))\r\nreturn *((unsigned long *)rtas_bucket);\r\n#endif\r\nif (pc < 0x1000000UL)\r\nreturn (unsigned long)__va(pc);\r\nif (!is_kernel_addr(pc))\r\nreturn *((unsigned long *)kernel_unknown_bucket);\r\nreturn pc;\r\n}\r\nstatic int get_kernel(unsigned long pc, unsigned long mmcra)\r\n{\r\nint is_kernel;\r\nif (!cur_cpu_spec->oprofile_mmcra_sihv) {\r\nis_kernel = is_kernel_addr(pc);\r\n} else {\r\nis_kernel = ((mmcra & cur_cpu_spec->oprofile_mmcra_sipr) == 0);\r\n}\r\nreturn is_kernel;\r\n}\r\nstatic bool pmc_overflow(unsigned long val)\r\n{\r\nif ((int)val < 0)\r\nreturn true;\r\nif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void power4_handle_interrupt(struct pt_regs *regs,\r\nstruct op_counter_config *ctr)\r\n{\r\nunsigned long pc;\r\nint is_kernel;\r\nint val;\r\nint i;\r\nunsigned int mmcr0;\r\nunsigned long mmcra;\r\nmmcra = mfspr(SPRN_MMCRA);\r\npc = get_pc(regs);\r\nis_kernel = get_kernel(pc, mmcra);\r\nmtmsrd(mfmsr() | MSR_PMM);\r\nfor (i = 0; i < cur_cpu_spec->num_pmcs; ++i) {\r\nval = classic_ctr_read(i);\r\nif (pmc_overflow(val)) {\r\nif (oprofile_running && ctr[i].enabled) {\r\noprofile_add_ext_sample(pc, regs, i, is_kernel);\r\nclassic_ctr_write(i, reset_value[i]);\r\n} else {\r\nclassic_ctr_write(i, 0);\r\n}\r\n}\r\n}\r\nmmcr0 = mfspr(SPRN_MMCR0);\r\nmmcr0 |= MMCR0_PMXE;\r\nmmcr0 &= ~MMCR0_PMAO;\r\nmmcra &= ~cur_cpu_spec->oprofile_mmcra_clear;\r\nmtspr(SPRN_MMCRA, mmcra);\r\nmmcr0 &= ~MMCR0_FC;\r\nmtspr(SPRN_MMCR0, mmcr0);\r\n}
