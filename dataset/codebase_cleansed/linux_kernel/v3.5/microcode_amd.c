static int collect_cpu_info_amd(int cpu, struct cpu_signature *csig)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\ncsig->rev = c->microcode;\r\npr_info("CPU%d: patch_level=0x%08x\n", cpu, csig->rev);\r\nreturn 0;\r\n}\r\nstatic unsigned int verify_ucode_size(int cpu, u32 patch_size,\r\nunsigned int size)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nu32 max_size;\r\n#define F1XH_MPB_MAX_SIZE 2048\r\n#define F14H_MPB_MAX_SIZE 1824\r\n#define F15H_MPB_MAX_SIZE 4096\r\nswitch (c->x86) {\r\ncase 0x14:\r\nmax_size = F14H_MPB_MAX_SIZE;\r\nbreak;\r\ncase 0x15:\r\nmax_size = F15H_MPB_MAX_SIZE;\r\nbreak;\r\ndefault:\r\nmax_size = F1XH_MPB_MAX_SIZE;\r\nbreak;\r\n}\r\nif (patch_size > min_t(u32, size, max_size)) {\r\npr_err("patch size mismatch\n");\r\nreturn 0;\r\n}\r\nreturn patch_size;\r\n}\r\nstatic u16 find_equiv_id(void)\r\n{\r\nunsigned int current_cpu_id, i = 0;\r\nBUG_ON(equiv_cpu_table == NULL);\r\ncurrent_cpu_id = cpuid_eax(0x00000001);\r\nwhile (equiv_cpu_table[i].installed_cpu != 0) {\r\nif (current_cpu_id == equiv_cpu_table[i].installed_cpu)\r\nreturn equiv_cpu_table[i].equiv_cpu;\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_matching_microcode(int cpu, const u8 *ucode_ptr,\r\nunsigned int leftover_size, int rev,\r\nunsigned int *current_size)\r\n{\r\nstruct microcode_header_amd *mc_hdr;\r\nunsigned int actual_size;\r\nu16 equiv_cpu_id;\r\n*current_size = *(u32 *)(ucode_ptr + 4) + SECTION_HDR_SIZE;\r\nequiv_cpu_id = find_equiv_id();\r\nif (!equiv_cpu_id)\r\nreturn 0;\r\nmc_hdr = (struct microcode_header_amd *)(ucode_ptr + SECTION_HDR_SIZE);\r\nif (mc_hdr->processor_rev_id != equiv_cpu_id)\r\nreturn 0;\r\nif (mc_hdr->nb_dev_id || mc_hdr->sb_dev_id) {\r\npr_err("CPU%d: chipset specific code not yet supported\n",\r\ncpu);\r\nreturn 0;\r\n}\r\nif (mc_hdr->patch_id <= rev)\r\nreturn 0;\r\nactual_size = verify_ucode_size(cpu, *current_size, leftover_size);\r\nif (!actual_size)\r\nreturn 0;\r\nmemset(patch, 0, PAGE_SIZE);\r\nget_ucode_data(patch, ucode_ptr + SECTION_HDR_SIZE, actual_size);\r\nreturn actual_size;\r\n}\r\nstatic int apply_microcode_amd(int cpu)\r\n{\r\nu32 rev, dummy;\r\nint cpu_num = raw_smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu_num;\r\nstruct microcode_amd *mc_amd = uci->mc;\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nBUG_ON(cpu_num != cpu);\r\nif (mc_amd == NULL)\r\nreturn 0;\r\nwrmsrl(MSR_AMD64_PATCH_LOADER, (u64)(long)&mc_amd->hdr.data_code);\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);\r\nif (rev != mc_amd->hdr.patch_id) {\r\npr_err("CPU%d: update failed for patch_level=0x%08x\n",\r\ncpu, mc_amd->hdr.patch_id);\r\nreturn -1;\r\n}\r\npr_info("CPU%d: new patch_level=0x%08x\n", cpu, rev);\r\nuci->cpu_sig.rev = rev;\r\nc->microcode = rev;\r\nreturn 0;\r\n}\r\nstatic int install_equiv_cpu_table(const u8 *buf)\r\n{\r\nunsigned int *ibuf = (unsigned int *)buf;\r\nunsigned int type = ibuf[1];\r\nunsigned int size = ibuf[2];\r\nif (type != UCODE_EQUIV_CPU_TABLE_TYPE || !size) {\r\npr_err("empty section/"\r\n"invalid type field in container file section header\n");\r\nreturn -EINVAL;\r\n}\r\nequiv_cpu_table = vmalloc(size);\r\nif (!equiv_cpu_table) {\r\npr_err("failed to allocate equivalent CPU table\n");\r\nreturn -ENOMEM;\r\n}\r\nget_ucode_data(equiv_cpu_table, buf + CONTAINER_HDR_SZ, size);\r\nreturn size + CONTAINER_HDR_SZ;\r\n}\r\nstatic void free_equiv_cpu_table(void)\r\n{\r\nvfree(equiv_cpu_table);\r\nequiv_cpu_table = NULL;\r\n}\r\nstatic enum ucode_state\r\ngeneric_load_microcode(int cpu, const u8 *data, size_t size)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nstruct microcode_header_amd *mc_hdr = NULL;\r\nunsigned int mc_size, leftover, current_size = 0;\r\nint offset;\r\nconst u8 *ucode_ptr = data;\r\nvoid *new_mc = NULL;\r\nunsigned int new_rev = uci->cpu_sig.rev;\r\nenum ucode_state state = UCODE_ERROR;\r\noffset = install_equiv_cpu_table(ucode_ptr);\r\nif (offset < 0) {\r\npr_err("failed to create equivalent cpu table\n");\r\ngoto out;\r\n}\r\nucode_ptr += offset;\r\nleftover = size - offset;\r\nif (*(u32 *)ucode_ptr != UCODE_UCODE_TYPE) {\r\npr_err("invalid type field in container file section header\n");\r\ngoto free_table;\r\n}\r\nwhile (leftover) {\r\nmc_size = get_matching_microcode(cpu, ucode_ptr, leftover,\r\nnew_rev, &current_size);\r\nif (mc_size) {\r\nmc_hdr = patch;\r\nnew_mc = patch;\r\nnew_rev = mc_hdr->patch_id;\r\ngoto out_ok;\r\n}\r\nucode_ptr += current_size;\r\nleftover -= current_size;\r\n}\r\nif (!new_mc) {\r\nstate = UCODE_NFOUND;\r\ngoto free_table;\r\n}\r\nout_ok:\r\nuci->mc = new_mc;\r\nstate = UCODE_OK;\r\npr_debug("CPU%d update ucode (0x%08x -> 0x%08x)\n",\r\ncpu, uci->cpu_sig.rev, new_rev);\r\nfree_table:\r\nfree_equiv_cpu_table();\r\nout:\r\nreturn state;\r\n}\r\nstatic enum ucode_state request_microcode_amd(int cpu, struct device *device)\r\n{\r\nchar fw_name[36] = "amd-ucode/microcode_amd.bin";\r\nconst struct firmware *fw;\r\nenum ucode_state ret = UCODE_NFOUND;\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nif (c->x86 >= 0x15)\r\nsnprintf(fw_name, sizeof(fw_name), "amd-ucode/microcode_amd_fam%.2xh.bin", c->x86);\r\nif (request_firmware(&fw, (const char *)fw_name, device)) {\r\npr_err("failed to load file %s\n", fw_name);\r\ngoto out;\r\n}\r\nret = UCODE_ERROR;\r\nif (*(u32 *)fw->data != UCODE_MAGIC) {\r\npr_err("invalid magic value (0x%08x)\n", *(u32 *)fw->data);\r\ngoto fw_release;\r\n}\r\nret = generic_load_microcode(cpu, fw->data, fw->size);\r\nfw_release:\r\nrelease_firmware(fw);\r\nout:\r\nreturn ret;\r\n}\r\nstatic enum ucode_state\r\nrequest_microcode_user(int cpu, const void __user *buf, size_t size)\r\n{\r\nreturn UCODE_ERROR;\r\n}\r\nstatic void microcode_fini_cpu_amd(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nuci->mc = NULL;\r\n}\r\nstruct microcode_ops * __init init_amd_microcode(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nif (c->x86_vendor != X86_VENDOR_AMD || c->x86 < 0x10) {\r\npr_warning("AMD CPU family 0x%x not supported\n", c->x86);\r\nreturn NULL;\r\n}\r\npatch = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!patch)\r\nreturn NULL;\r\nreturn &microcode_amd_ops;\r\n}\r\nvoid __exit exit_amd_microcode(void)\r\n{\r\nfree_page((unsigned long)patch);\r\n}
