static int n_tracesink_open(struct tty_struct *tty)\r\n{\r\nint retval = -EEXIST;\r\nmutex_lock(&writelock);\r\nif (this_tty == NULL) {\r\nthis_tty = tty_kref_get(tty);\r\nif (this_tty == NULL) {\r\nretval = -EFAULT;\r\n} else {\r\ntty->disc_data = this_tty;\r\ntty_driver_flush_buffer(tty);\r\nretval = 0;\r\n}\r\n}\r\nmutex_unlock(&writelock);\r\nreturn retval;\r\n}\r\nstatic void n_tracesink_close(struct tty_struct *tty)\r\n{\r\nmutex_lock(&writelock);\r\ntty_driver_flush_buffer(tty);\r\ntty_kref_put(this_tty);\r\nthis_tty = NULL;\r\ntty->disc_data = NULL;\r\nmutex_unlock(&writelock);\r\n}\r\nstatic ssize_t n_tracesink_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t nr) {\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t n_tracesink_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *buf, size_t nr) {\r\nreturn -EINVAL;\r\n}\r\nvoid n_tracesink_datadrain(u8 *buf, int count)\r\n{\r\nmutex_lock(&writelock);\r\nif ((buf != NULL) && (count > 0) && (this_tty != NULL))\r\nthis_tty->ops->write(this_tty, buf, count);\r\nmutex_unlock(&writelock);\r\n}\r\nstatic int __init n_tracesink_init(void)\r\n{\r\nint retval = tty_register_ldisc(N_TRACESINK, &tty_n_tracesink);\r\nif (retval < 0)\r\npr_err("%s: Registration failed: %d\n", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic void __exit n_tracesink_exit(void)\r\n{\r\nint retval = tty_unregister_ldisc(N_TRACESINK);\r\nif (retval < 0)\r\npr_err("%s: Unregistration failed: %d\n", __func__, retval);\r\n}
