static int max2165_write_reg(struct max2165_priv *priv, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = 2 };\r\nmsg.addr = priv->config->i2c_address;\r\nif (debug >= 2)\r\ndprintk("%s: reg=0x%02X, data=0x%02X\n", __func__, reg, data);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: error reg=0x%x, data=0x%x, ret=%i\n",\r\n__func__, reg, data, ret);\r\nreturn (ret != 1) ? -EIO : 0;\r\n}\r\nstatic int max2165_read_reg(struct max2165_priv *priv, u8 reg, u8 *p_data)\r\n{\r\nint ret;\r\nu8 dev_addr = priv->config->i2c_address;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = dev_addr, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = dev_addr, .flags = I2C_M_RD, .buf = b1, .len = 1 },\r\n};\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret != 2) {\r\ndprintk("%s: error reg=0x%x, ret=%i\n", __func__, reg, ret);\r\nreturn -EIO;\r\n}\r\n*p_data = b1[0];\r\nif (debug >= 2)\r\ndprintk("%s: reg=0x%02X, data=0x%02X\n",\r\n__func__, reg, b1[0]);\r\nreturn 0;\r\n}\r\nstatic int max2165_mask_write_reg(struct max2165_priv *priv, u8 reg,\r\nu8 mask, u8 data)\r\n{\r\nint ret;\r\nu8 v;\r\ndata &= mask;\r\nret = max2165_read_reg(priv, reg, &v);\r\nif (ret != 0)\r\nreturn ret;\r\nv &= ~mask;\r\nv |= data;\r\nret = max2165_write_reg(priv, reg, v);\r\nreturn ret;\r\n}\r\nstatic int max2165_read_rom_table(struct max2165_priv *priv)\r\n{\r\nu8 dat[3];\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nmax2165_write_reg(priv, REG_ROM_TABLE_ADDR, i + 1);\r\nmax2165_read_reg(priv, REG_ROM_TABLE_DATA, &dat[i]);\r\n}\r\npriv->tf_ntch_low_cfg = dat[0] >> 4;\r\npriv->tf_ntch_hi_cfg = dat[0] & 0x0F;\r\npriv->tf_balun_low_ref = dat[1] & 0x0F;\r\npriv->tf_balun_hi_ref = dat[1] >> 4;\r\npriv->bb_filter_7mhz_cfg = dat[2] & 0x0F;\r\npriv->bb_filter_8mhz_cfg = dat[2] >> 4;\r\ndprintk("tf_ntch_low_cfg = 0x%X\n", priv->tf_ntch_low_cfg);\r\ndprintk("tf_ntch_hi_cfg = 0x%X\n", priv->tf_ntch_hi_cfg);\r\ndprintk("tf_balun_low_ref = 0x%X\n", priv->tf_balun_low_ref);\r\ndprintk("tf_balun_hi_ref = 0x%X\n", priv->tf_balun_hi_ref);\r\ndprintk("bb_filter_7mhz_cfg = 0x%X\n", priv->bb_filter_7mhz_cfg);\r\ndprintk("bb_filter_8mhz_cfg = 0x%X\n", priv->bb_filter_8mhz_cfg);\r\nreturn 0;\r\n}\r\nstatic int max2165_set_osc(struct max2165_priv *priv, u8 osc )\r\n{\r\nu8 v;\r\nv = (osc / 2);\r\nif (v == 2)\r\nv = 0x7;\r\nelse\r\nv -= 8;\r\nmax2165_mask_write_reg(priv, REG_PLL_CFG, 0x07, v);\r\nreturn 0;\r\n}\r\nstatic int max2165_set_bandwidth(struct max2165_priv *priv, u32 bw)\r\n{\r\nu8 val;\r\nif (bw == 8000000)\r\nval = priv->bb_filter_8mhz_cfg;\r\nelse\r\nval = priv->bb_filter_7mhz_cfg;\r\nmax2165_mask_write_reg(priv, REG_BASEBAND_CTRL, 0xF0, val << 4);\r\nreturn 0;\r\n}\r\nint fixpt_div32(u32 dividend, u32 divisor, u32 *quotient, u32 *fraction)\r\n{\r\nu32 remainder;\r\nu32 q, f = 0;\r\nint i;\r\nif (0 == divisor)\r\nreturn -EINVAL;\r\nq = dividend / divisor;\r\nremainder = dividend - q * divisor;\r\nfor (i = 0; i < 31; i++) {\r\nremainder <<= 1;\r\nif (remainder >= divisor) {\r\nf += 1;\r\nremainder -= divisor;\r\n}\r\nf <<= 1;\r\n}\r\n*quotient = q;\r\n*fraction = f;\r\nreturn 0;\r\n}\r\nstatic int max2165_set_rf(struct max2165_priv *priv, u32 freq)\r\n{\r\nu8 tf;\r\nu8 tf_ntch;\r\nu32 t;\r\nu32 quotient, fraction;\r\nint ret;\r\nret = fixpt_div32(freq / 1000, priv->config->osc_clk * 1000,\r\n&quotient, &fraction);\r\nif (ret != 0)\r\nreturn ret;\r\nfraction >>= 12;\r\nmax2165_write_reg(priv, REG_NDIV_INT, quotient);\r\nmax2165_mask_write_reg(priv, REG_NDIV_FRAC2, 0x0F, fraction >> 16);\r\nmax2165_write_reg(priv, REG_NDIV_FRAC1, fraction >> 8);\r\nmax2165_write_reg(priv, REG_NDIV_FRAC0, fraction);\r\ntf_ntch = (freq < 725000000) ?\r\npriv->tf_ntch_low_cfg : priv->tf_ntch_hi_cfg;\r\nt = priv->tf_balun_low_ref;\r\nt += (priv->tf_balun_hi_ref - priv->tf_balun_low_ref)\r\n* (freq / 1000 - 470000) / (780000 - 470000);\r\ntf = t;\r\ndprintk("tf = %X\n", tf);\r\ntf |= tf_ntch << 4;\r\nmax2165_write_reg(priv, REG_TRACK_FILTER, tf);\r\nreturn 0;\r\n}\r\nstatic void max2165_debug_status(struct max2165_priv *priv)\r\n{\r\nu8 status, autotune;\r\nu8 auto_vco_success, auto_vco_active;\r\nu8 pll_locked;\r\nu8 dc_offset_low, dc_offset_hi;\r\nu8 signal_lv_over_threshold;\r\nu8 vco, vco_sub_band, adc;\r\nmax2165_read_reg(priv, REG_STATUS, &status);\r\nmax2165_read_reg(priv, REG_AUTOTUNE, &autotune);\r\nauto_vco_success = (status >> 6) & 0x01;\r\nauto_vco_active = (status >> 5) & 0x01;\r\npll_locked = (status >> 4) & 0x01;\r\ndc_offset_low = (status >> 3) & 0x01;\r\ndc_offset_hi = (status >> 2) & 0x01;\r\nsignal_lv_over_threshold = status & 0x01;\r\nvco = autotune >> 6;\r\nvco_sub_band = (autotune >> 3) & 0x7;\r\nadc = autotune & 0x7;\r\ndprintk("auto VCO active: %d, auto VCO success: %d\n",\r\nauto_vco_active, auto_vco_success);\r\ndprintk("PLL locked: %d\n", pll_locked);\r\ndprintk("DC offset low: %d, DC offset high: %d\n",\r\ndc_offset_low, dc_offset_hi);\r\ndprintk("Signal lvl over threshold: %d\n", signal_lv_over_threshold);\r\ndprintk("VCO: %d, VCO Sub-band: %d, ADC: %d\n", vco, vco_sub_band, adc);\r\n}\r\nstatic int max2165_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct max2165_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nswitch (c->bandwidth_hz) {\r\ncase 7000000:\r\ncase 8000000:\r\npriv->frequency = c->frequency;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "MAX2165: bandwidth %d Hz not supported.\n",\r\nc->bandwidth_hz);\r\nreturn -EINVAL;\r\n}\r\ndprintk("%s() frequency=%d\n", __func__, c->frequency);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nmax2165_set_bandwidth(priv, c->bandwidth_hz);\r\nret = max2165_set_rf(priv, priv->frequency);\r\nmdelay(50);\r\nmax2165_debug_status(priv);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (ret != 0)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int max2165_get_frequency(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct max2165_priv *priv = fe->tuner_priv;\r\ndprintk("%s()\n", __func__);\r\n*freq = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int max2165_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\r\n{\r\nstruct max2165_priv *priv = fe->tuner_priv;\r\ndprintk("%s()\n", __func__);\r\n*bw = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int max2165_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct max2165_priv *priv = fe->tuner_priv;\r\nu16 lock_status = 0;\r\ndprintk("%s()\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nmax2165_debug_status(priv);\r\n*status = lock_status;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int max2165_sleep(struct dvb_frontend *fe)\r\n{\r\ndprintk("%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int max2165_init(struct dvb_frontend *fe)\r\n{\r\nstruct max2165_priv *priv = fe->tuner_priv;\r\ndprintk("%s()\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nmax2165_write_reg(priv, REG_NDIV_FRAC2, 0x18);\r\nmax2165_write_reg(priv, REG_LNA, 0x01);\r\nmax2165_write_reg(priv, REG_PLL_CFG, 0x7A);\r\nmax2165_write_reg(priv, REG_TEST, 0x08);\r\nmax2165_write_reg(priv, REG_SHUTDOWN, 0x40);\r\nmax2165_write_reg(priv, REG_VCO_CTRL, 0x84);\r\nmax2165_write_reg(priv, REG_BASEBAND_CTRL, 0xC3);\r\nmax2165_write_reg(priv, REG_DC_OFFSET_CTRL, 0x75);\r\nmax2165_write_reg(priv, REG_DC_OFFSET_DAC, 0x00);\r\nmax2165_write_reg(priv, REG_ROM_TABLE_ADDR, 0x00);\r\nmax2165_set_osc(priv, priv->config->osc_clk);\r\nmax2165_read_rom_table(priv);\r\nmax2165_set_bandwidth(priv, 8000000);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int max2165_release(struct dvb_frontend *fe)\r\n{\r\nstruct max2165_priv *priv = fe->tuner_priv;\r\ndprintk("%s()\n", __func__);\r\nkfree(priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *max2165_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c,\r\nstruct max2165_config *cfg)\r\n{\r\nstruct max2165_priv *priv = NULL;\r\ndprintk("%s(%d-%04x)\n", __func__,\r\ni2c ? i2c_adapter_id(i2c) : -1,\r\ncfg ? cfg->i2c_address : -1);\r\npriv = kzalloc(sizeof(struct max2165_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\nmemcpy(&fe->ops.tuner_ops, &max2165_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\npriv->config = cfg;\r\npriv->i2c = i2c;\r\nfe->tuner_priv = priv;\r\nmax2165_init(fe);\r\nmax2165_debug_status(priv);\r\nreturn fe;\r\n}
