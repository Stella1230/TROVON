static u8 reg_r(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nusb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0,\r\nindex,\r\ngspca_dev->usb_buf, 1, 500);\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\nu16 index)\r\n{\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index,\r\nNULL, 0, 500);\r\n}\r\nstatic void reg_w_buf(struct gspca_dev *gspca_dev,\r\nconst u8 *buffer, u16 len)\r\n{\r\nif (len <= USB_BUF_SZ) {\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01, 0,\r\ngspca_dev->usb_buf, len, 500);\r\n} else {\r\nu8 *tmpbuf;\r\ntmpbuf = kmemdup(buffer, len, GFP_KERNEL);\r\nif (!tmpbuf) {\r\npr_err("Out of memory\n");\r\nreturn;\r\n}\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01, 0,\r\ntmpbuf, len, 500);\r\nkfree(tmpbuf);\r\n}\r\n}\r\nstatic void reg_w_ixbuf(struct gspca_dev *gspca_dev,\r\nu8 reg,\r\nconst u8 *buffer, u16 len)\r\n{\r\nint i;\r\nu8 *p, *tmpbuf;\r\nif (len * 2 <= USB_BUF_SZ) {\r\np = tmpbuf = gspca_dev->usb_buf;\r\n} else {\r\np = tmpbuf = kmalloc(len * 2, GFP_KERNEL);\r\nif (!tmpbuf) {\r\npr_err("Out of memory\n");\r\nreturn;\r\n}\r\n}\r\ni = len;\r\nwhile (--i >= 0) {\r\n*p++ = reg++;\r\n*p++ = *buffer++;\r\n}\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x01, 0,\r\ntmpbuf, len * 2, 500);\r\nif (len * 2 > USB_BUF_SZ)\r\nkfree(tmpbuf);\r\n}\r\nstatic void om6802_sensor_init(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nconst u8 *p;\r\nu8 byte;\r\nu8 val[6] = {0x62, 0, 0x64, 0, 0x60, 0x05};\r\nstatic const u8 sensor_init[] = {\r\n0xdf, 0x6d,\r\n0xdd, 0x18,\r\n0x5a, 0xe0,\r\n0x5c, 0x07,\r\n0x5d, 0xb0,\r\n0x5e, 0x1e,\r\n0x60, 0x71,\r\n0xef, 0x00,\r\n0xe9, 0x00,\r\n0xea, 0x00,\r\n0x90, 0x24,\r\n0x91, 0xb2,\r\n0x82, 0x32,\r\n0xfd, 0x41,\r\n0x00\r\n};\r\nreg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);\r\nmsleep(100);\r\ni = 4;\r\nwhile (--i > 0) {\r\nbyte = reg_r(gspca_dev, 0x0060);\r\nif (!(byte & 0x01))\r\nbreak;\r\nmsleep(100);\r\n}\r\nbyte = reg_r(gspca_dev, 0x0063);\r\nif (byte != 0x17) {\r\npr_err("Bad sensor reset %02x\n", byte);\r\n}\r\np = sensor_init;\r\nwhile (*p != 0) {\r\nval[1] = *p++;\r\nval[3] = *p++;\r\nif (*p == 0)\r\nreg_w(gspca_dev, 0x3c80);\r\nreg_w_buf(gspca_dev, val, sizeof val);\r\ni = 4;\r\nwhile (--i >= 0) {\r\nmsleep(15);\r\nbyte = reg_r(gspca_dev, 0x60);\r\nif (!(byte & 0x01))\r\nbreak;\r\n}\r\n}\r\nmsleep(15);\r\nreg_w(gspca_dev, 0x3c80);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\ncam->cam_mode = vga_mode_t16;\r\ncam->nmodes = ARRAY_SIZE(vga_mode_t16);\r\nsd->brightness = BRIGHTNESS_DEF;\r\nsd->contrast = CONTRAST_DEF;\r\nsd->colors = COLORS_DEF;\r\nsd->gamma = GAMMA_DEF;\r\nsd->autogain = AUTOGAIN_DEF;\r\nsd->mirror = MIRROR_DEF;\r\nsd->freq = FREQ_DEF;\r\nsd->awb = AWB_DEF;\r\nsd->sharpness = SHARPNESS_DEF;\r\nsd->effect = EFFECTS_DEF;\r\nsd->red_gain = RED_GAIN_DEF;\r\nsd->blue_gain = BLUE_GAIN_DEF;\r\nsd->green_gain = GAIN_DEF * 3 - RED_GAIN_DEF - BLUE_GAIN_DEF;\r\nreturn 0;\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned int brightness;\r\nu8 set6[4] = { 0x8f, 0x24, 0xc3, 0x00 };\r\nbrightness = sd->brightness;\r\nif (brightness < 7) {\r\nset6[1] = 0x26;\r\nset6[3] = 0x70 - brightness * 0x10;\r\n} else {\r\nset6[3] = 0x00 + ((brightness - 7) * 0x10);\r\n}\r\nreg_w_buf(gspca_dev, set6, sizeof set6);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned int contrast = sd->contrast;\r\nu16 reg_to_write;\r\nif (contrast < 7)\r\nreg_to_write = 0x8ea9 - contrast * 0x200;\r\nelse\r\nreg_to_write = 0x00a9 + (contrast - 7) * 0x200;\r\nreg_w(gspca_dev, reg_to_write);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg_to_write;\r\nreg_to_write = 0x80bb + sd->colors * 0x100;\r\nreg_w(gspca_dev, reg_to_write);\r\n}\r\nstatic void setgamma(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Gamma: %d", sd->gamma);\r\nreg_w_ixbuf(gspca_dev, 0x90,\r\ngamma_table[sd->gamma], sizeof gamma_table[0]);\r\n}\r\nstatic void setRGB(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 all_gain_reg[6] =\r\n{0x87, 0x00, 0x88, 0x00, 0x89, 0x00};\r\nall_gain_reg[1] = sd->red_gain;\r\nall_gain_reg[3] = sd->blue_gain;\r\nall_gain_reg[5] = sd->green_gain;\r\nreg_w_buf(gspca_dev, all_gain_reg, sizeof all_gain_reg);\r\n}\r\nstatic void setawb(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg80;\r\nreg80 = (sensor_data[sd->sensor].reg80 << 8) | 0x80;\r\nif (!sd->awb) {\r\nsd->red_gain = reg_r(gspca_dev, 0x0087);\r\nsd->blue_gain = reg_r(gspca_dev, 0x0088);\r\nsd->green_gain = reg_r(gspca_dev, 0x0089);\r\nreg80 &= ~0x0400;\r\n}\r\nreg_w(gspca_dev, reg80);\r\nreg_w(gspca_dev, reg80);\r\n}\r\nstatic void init_gains(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg80;\r\nu8 all_gain_reg[8] =\r\n{0x87, 0x00, 0x88, 0x00, 0x89, 0x00, 0x80, 0x00};\r\nall_gain_reg[1] = sd->red_gain;\r\nall_gain_reg[3] = sd->blue_gain;\r\nall_gain_reg[5] = sd->green_gain;\r\nreg80 = sensor_data[sd->sensor].reg80;\r\nif (!sd->awb)\r\nreg80 &= ~0x04;\r\nall_gain_reg[7] = reg80;\r\nreg_w_buf(gspca_dev, all_gain_reg, sizeof all_gain_reg);\r\nreg_w(gspca_dev, (sd->red_gain << 8) + 0x87);\r\nreg_w(gspca_dev, (sd->blue_gain << 8) + 0x88);\r\nreg_w(gspca_dev, (sd->green_gain << 8) + 0x89);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 reg_to_write;\r\nreg_to_write = 0x0aa6 + 0x1000 * sd->sharpness;\r\nreg_w(gspca_dev, reg_to_write);\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 reg66;\r\nu8 freq[4] = { 0x66, 0x00, 0xa8, 0xe8 };\r\nswitch (sd->sensor) {\r\ncase SENSOR_LT168G:\r\nif (sd->freq != 0)\r\nfreq[3] = 0xa8;\r\nreg66 = 0x41;\r\nbreak;\r\ncase SENSOR_OM6802:\r\nreg66 = 0xca;\r\nbreak;\r\ndefault:\r\nreg66 = 0x40;\r\nbreak;\r\n}\r\nswitch (sd->freq) {\r\ncase 0:\r\nfreq[3] = 0xf0;\r\nbreak;\r\ncase 2:\r\nreg66 &= ~0x40;\r\nbreak;\r\n}\r\nfreq[1] = reg66;\r\nreg_w_buf(gspca_dev, freq, sizeof freq);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct additional_sensor_data *sensor;\r\nint i;\r\nu16 sensor_id;\r\nu8 test_byte = 0;\r\nstatic const u8 read_indexs[] =\r\n{ 0x0a, 0x0b, 0x66, 0x80, 0x81, 0x8e, 0x8f, 0xa5,\r\n0xa6, 0xa8, 0xbb, 0xbc, 0xc6, 0x00 };\r\nstatic const u8 n1[] =\r\n{0x08, 0x03, 0x09, 0x03, 0x12, 0x04};\r\nstatic const u8 n2[] =\r\n{0x08, 0x00};\r\nsensor_id = (reg_r(gspca_dev, 0x06) << 8)\r\n| reg_r(gspca_dev, 0x07);\r\nswitch (sensor_id & 0xff0f) {\r\ncase 0x0801:\r\nPDEBUG(D_PROBE, "sensor tas5130a");\r\nsd->sensor = SENSOR_TAS5130A;\r\nbreak;\r\ncase 0x0802:\r\nPDEBUG(D_PROBE, "sensor lt168g");\r\nsd->sensor = SENSOR_LT168G;\r\nbreak;\r\ncase 0x0803:\r\nPDEBUG(D_PROBE, "sensor 'other'");\r\nsd->sensor = SENSOR_OTHER;\r\nbreak;\r\ncase 0x0807:\r\nPDEBUG(D_PROBE, "sensor om6802");\r\nsd->sensor = SENSOR_OM6802;\r\nbreak;\r\ndefault:\r\npr_err("unknown sensor %04x\n", sensor_id);\r\nreturn -EINVAL;\r\n}\r\nif (sd->sensor == SENSOR_OM6802) {\r\nreg_w_buf(gspca_dev, n1, sizeof n1);\r\ni = 5;\r\nwhile (--i >= 0) {\r\nreg_w_buf(gspca_dev, sensor_reset, sizeof sensor_reset);\r\ntest_byte = reg_r(gspca_dev, 0x0063);\r\nmsleep(100);\r\nif (test_byte == 0x17)\r\nbreak;\r\n}\r\nif (i < 0) {\r\npr_err("Bad sensor reset %02x\n", test_byte);\r\nreturn -EIO;\r\n}\r\nreg_w_buf(gspca_dev, n2, sizeof n2);\r\n}\r\ni = 0;\r\nwhile (read_indexs[i] != 0x00) {\r\ntest_byte = reg_r(gspca_dev, read_indexs[i]);\r\nPDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", read_indexs[i],\r\ntest_byte);\r\ni++;\r\n}\r\nsensor = &sensor_data[sd->sensor];\r\nreg_w_buf(gspca_dev, sensor->n3, sizeof sensor->n3);\r\nreg_w_buf(gspca_dev, sensor->n4, sensor->n4sz);\r\nif (sd->sensor == SENSOR_LT168G) {\r\ntest_byte = reg_r(gspca_dev, 0x80);\r\nPDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", 0x80,\r\ntest_byte);\r\nreg_w(gspca_dev, 0x6c80);\r\n}\r\nreg_w_ixbuf(gspca_dev, 0xd0, sensor->data1, sizeof sensor->data1);\r\nreg_w_ixbuf(gspca_dev, 0xc7, sensor->data2, sizeof sensor->data2);\r\nreg_w_ixbuf(gspca_dev, 0xe0, sensor->data3, sizeof sensor->data3);\r\nreg_w(gspca_dev, (sensor->reg80 << 8) + 0x80);\r\nreg_w(gspca_dev, (sensor->reg80 << 8) + 0x80);\r\nreg_w(gspca_dev, (sensor->reg8e << 8) + 0x8e);\r\nsetbrightness(gspca_dev);\r\nsetcontrast(gspca_dev);\r\nsetgamma(gspca_dev);\r\nsetcolors(gspca_dev);\r\nsetsharpness(gspca_dev);\r\ninit_gains(gspca_dev);\r\nsetfreq(gspca_dev);\r\nreg_w_buf(gspca_dev, sensor->data5, sizeof sensor->data5);\r\nreg_w_buf(gspca_dev, sensor->nset8, sizeof sensor->nset8);\r\nreg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\r\nif (sd->sensor == SENSOR_LT168G) {\r\ntest_byte = reg_r(gspca_dev, 0x80);\r\nPDEBUG(D_STREAM, "Reg 0x%02x = 0x%02x", 0x80,\r\ntest_byte);\r\nreg_w(gspca_dev, 0x6c80);\r\n}\r\nreg_w_ixbuf(gspca_dev, 0xd0, sensor->data1, sizeof sensor->data1);\r\nreg_w_ixbuf(gspca_dev, 0xc7, sensor->data2, sizeof sensor->data2);\r\nreg_w_ixbuf(gspca_dev, 0xe0, sensor->data3, sizeof sensor->data3);\r\nreturn 0;\r\n}\r\nstatic void setmirror(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 hflipcmd[8] =\r\n{0x62, 0x07, 0x63, 0x03, 0x64, 0x00, 0x60, 0x09};\r\nif (sd->mirror)\r\nhflipcmd[3] = 0x01;\r\nreg_w_buf(gspca_dev, hflipcmd, sizeof hflipcmd);\r\n}\r\nstatic void seteffect(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w_buf(gspca_dev, effects_table[sd->effect],\r\nsizeof effects_table[0]);\r\nif (sd->effect == 1 || sd->effect == 5) {\r\nPDEBUG(D_CONF,\r\n"This effect have been disabled for webcam \"safety\"");\r\nreturn;\r\n}\r\nif (sd->effect == 1 || sd->effect == 4)\r\nreg_w(gspca_dev, 0x4aa6);\r\nelse\r\nreg_w(gspca_dev, 0xfaa6);\r\n}\r\nstatic void poll_sensor(struct gspca_dev *gspca_dev)\r\n{\r\nstatic const u8 poll1[] =\r\n{0x67, 0x05, 0x68, 0x81, 0x69, 0x80, 0x6a, 0x82,\r\n0x6b, 0x68, 0x6c, 0x69, 0x72, 0xd9, 0x73, 0x34,\r\n0x74, 0x32, 0x75, 0x92, 0x76, 0x00, 0x09, 0x01,\r\n0x60, 0x14};\r\nstatic const u8 poll2[] =\r\n{0x67, 0x02, 0x68, 0x71, 0x69, 0x72, 0x72, 0xa9,\r\n0x73, 0x02, 0x73, 0x02, 0x60, 0x14};\r\nstatic const u8 noise03[] =\r\n{0xa6, 0x0a, 0xea, 0xcf, 0xbe, 0x26, 0xb1, 0x5f,\r\n0xa1, 0xb1, 0xda, 0x6b, 0xdb, 0x98, 0xdf, 0x0c,\r\n0xc2, 0x80, 0xc3, 0x10};\r\nPDEBUG(D_STREAM, "[Sensor requires polling]");\r\nreg_w_buf(gspca_dev, poll1, sizeof poll1);\r\nreg_w_buf(gspca_dev, poll2, sizeof poll2);\r\nreg_w_buf(gspca_dev, noise03, sizeof noise03);\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct additional_sensor_data *sensor;\r\nint i, mode;\r\nu8 t2[] = { 0x07, 0x00, 0x0d, 0x60, 0x0e, 0x80 };\r\nstatic const u8 t3[] =\r\n{ 0x07, 0x00, 0x88, 0x02, 0x06, 0x00, 0xe7, 0x01 };\r\nmode = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nswitch (mode) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nt2[1] = 0x40;\r\nbreak;\r\ncase 2:\r\nt2[1] = 0x10;\r\nbreak;\r\ncase 3:\r\nt2[1] = 0x50;\r\nbreak;\r\ndefault:\r\nt2[1] = 0x20;\r\nbreak;\r\n}\r\nswitch (sd->sensor) {\r\ncase SENSOR_OM6802:\r\nom6802_sensor_init(gspca_dev);\r\nbreak;\r\ncase SENSOR_TAS5130A:\r\ni = 0;\r\nfor (;;) {\r\nreg_w_buf(gspca_dev, tas5130a_sensor_init[i],\r\nsizeof tas5130a_sensor_init[0]);\r\nif (i >= ARRAY_SIZE(tas5130a_sensor_init) - 1)\r\nbreak;\r\ni++;\r\n}\r\nreg_w(gspca_dev, 0x3c80);\r\nreg_w_buf(gspca_dev, tas5130a_sensor_init[i],\r\nsizeof tas5130a_sensor_init[0]);\r\nreg_w(gspca_dev, 0x3c80);\r\nbreak;\r\n}\r\nsensor = &sensor_data[sd->sensor];\r\nsetfreq(gspca_dev);\r\nreg_r(gspca_dev, 0x0012);\r\nreg_w_buf(gspca_dev, t2, sizeof t2);\r\nreg_w_ixbuf(gspca_dev, 0xb3, t3, sizeof t3);\r\nreg_w(gspca_dev, 0x0013);\r\nmsleep(15);\r\nreg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\r\nreg_w_buf(gspca_dev, sensor->stream, sizeof sensor->stream);\r\nif (sd->sensor == SENSOR_OM6802)\r\npoll_sensor(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w_buf(gspca_dev, sensor_data[sd->sensor].stream,\r\nsizeof sensor_data[sd->sensor].stream);\r\nreg_w_buf(gspca_dev, sensor_data[sd->sensor].stream,\r\nsizeof sensor_data[sd->sensor].stream);\r\nif (sd->sensor == SENSOR_OM6802) {\r\nmsleep(20);\r\nreg_w(gspca_dev, 0x0309);\r\n}\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nif (sd->button_pressed) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->button_pressed = 0;\r\n}\r\n#endif\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint pkt_type;\r\nif (data[0] == 0x5a) {\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nif (len > 20) {\r\nu8 state = (data[20] & 0x80) ? 1 : 0;\r\nif (sd->button_pressed != state) {\r\ninput_report_key(gspca_dev->input_dev,\r\nKEY_CAMERA, state);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->button_pressed = state;\r\n}\r\n}\r\n#endif\r\nreturn;\r\n}\r\ndata += 2;\r\nlen -= 2;\r\nif (data[0] == 0xff && data[1] == 0xd8)\r\npkt_type = FIRST_PACKET;\r\nelse if (data[len - 2] == 0xff && data[len - 1] == 0xd9)\r\npkt_type = LAST_PACKET;\r\nelse\r\npkt_type = INTER_PACKET;\r\ngspca_frame_add(gspca_dev, pkt_type, data, len);\r\n}\r\nstatic int sd_setblue_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->blue_gain = val;\r\nif (gspca_dev->streaming)\r\nreg_w(gspca_dev, (val << 8) + 0x88);\r\nreturn 0;\r\n}\r\nstatic int sd_getblue_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->blue_gain;\r\nreturn 0;\r\n}\r\nstatic int sd_setred_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->red_gain = val;\r\nif (gspca_dev->streaming)\r\nreg_w(gspca_dev, (val << 8) + 0x87);\r\nreturn 0;\r\n}\r\nstatic int sd_getred_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->red_gain;\r\nreturn 0;\r\n}\r\nstatic int sd_setgain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 psg, nsg;\r\npsg = sd->red_gain + sd->blue_gain + sd->green_gain;\r\nnsg = val * 3;\r\nsd->red_gain = sd->red_gain * nsg / psg;\r\nif (sd->red_gain > 0x40)\r\nsd->red_gain = 0x40;\r\nelse if (sd->red_gain < 0x10)\r\nsd->red_gain = 0x10;\r\nsd->blue_gain = sd->blue_gain * nsg / psg;\r\nif (sd->blue_gain > 0x40)\r\nsd->blue_gain = 0x40;\r\nelse if (sd->blue_gain < 0x10)\r\nsd->blue_gain = 0x10;\r\nsd->green_gain = sd->green_gain * nsg / psg;\r\nif (sd->green_gain > 0x40)\r\nsd->green_gain = 0x40;\r\nelse if (sd->green_gain < 0x10)\r\nsd->green_gain = 0x10;\r\nif (gspca_dev->streaming)\r\nsetRGB(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getgain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = (sd->red_gain + sd->blue_gain + sd->green_gain) / 3;\r\nreturn 0;\r\n}\r\nstatic int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->brightness = val;\r\nif (gspca_dev->streaming)\r\nsetbrightness(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->brightness;\r\nreturn *val;\r\n}\r\nstatic int sd_setawb(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->awb = val;\r\nif (gspca_dev->streaming)\r\nsetawb(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getawb(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->awb;\r\nreturn *val;\r\n}\r\nstatic int sd_setmirror(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->mirror = val;\r\nif (gspca_dev->streaming)\r\nsetmirror(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getmirror(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->mirror;\r\nreturn *val;\r\n}\r\nstatic int sd_seteffect(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->effect = val;\r\nif (gspca_dev->streaming)\r\nseteffect(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_geteffect(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->effect;\r\nreturn *val;\r\n}\r\nstatic int sd_setcontrast(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->contrast = val;\r\nif (gspca_dev->streaming)\r\nsetcontrast(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->contrast;\r\nreturn *val;\r\n}\r\nstatic int sd_setcolors(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->colors = val;\r\nif (gspca_dev->streaming)\r\nsetcolors(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getcolors(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->colors;\r\nreturn 0;\r\n}\r\nstatic int sd_setgamma(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->gamma = val;\r\nif (gspca_dev->streaming)\r\nsetgamma(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getgamma(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->gamma;\r\nreturn 0;\r\n}\r\nstatic int sd_setfreq(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->freq = val;\r\nif (gspca_dev->streaming)\r\nsetfreq(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getfreq(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->freq;\r\nreturn 0;\r\n}\r\nstatic int sd_setsharpness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->sharpness = val;\r\nif (gspca_dev->streaming)\r\nsetsharpness(gspca_dev);\r\nreturn 0;\r\n}\r\nstatic int sd_getsharpness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->sharpness;\r\nreturn 0;\r\n}\r\nstatic int sd_setlowlight(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->autogain = val;\r\nif (val != 0)\r\nreg_w(gspca_dev, 0xf48e);\r\nelse\r\nreg_w(gspca_dev, 0xb48e);\r\nreturn 0;\r\n}\r\nstatic int sd_getlowlight(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->autogain;\r\nreturn 0;\r\n}\r\nstatic int sd_querymenu(struct gspca_dev *gspca_dev,\r\nstruct v4l2_querymenu *menu)\r\n{\r\nstatic const char *freq_nm[3] = {"NoFliker", "50 Hz", "60 Hz"};\r\nswitch (menu->id) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nif ((unsigned) menu->index >= ARRAY_SIZE(freq_nm))\r\nbreak;\r\nstrcpy((char *) menu->name, freq_nm[menu->index]);\r\nreturn 0;\r\ncase V4L2_CID_EFFECTS:\r\nif ((unsigned) menu->index < ARRAY_SIZE(effects_control)) {\r\nstrlcpy((char *) menu->name,\r\neffects_control[menu->index],\r\nsizeof menu->name);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
