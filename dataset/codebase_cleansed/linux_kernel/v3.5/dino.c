static int dino_cfg_read(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *val)\r\n{\r\nstruct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));\r\nu32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;\r\nu32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);\r\nvoid __iomem *base_addr = d->hba.base_addr;\r\nunsigned long flags;\r\nDBG("%s: %p, %d, %d, %d\n", __func__, base_addr, devfn, where,\r\nsize);\r\nspin_lock_irqsave(&d->dinosaur_pen, flags);\r\n__raw_writel(v, base_addr + DINO_PCI_ADDR);\r\nif (size == 1) {\r\n*val = readb(base_addr + DINO_CONFIG_DATA + (where & 3));\r\n} else if (size == 2) {\r\n*val = readw(base_addr + DINO_CONFIG_DATA + (where & 2));\r\n} else if (size == 4) {\r\n*val = readl(base_addr + DINO_CONFIG_DATA);\r\n}\r\nspin_unlock_irqrestore(&d->dinosaur_pen, flags);\r\nreturn 0;\r\n}\r\nstatic int dino_cfg_write(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 val)\r\n{\r\nstruct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));\r\nu32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;\r\nu32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);\r\nvoid __iomem *base_addr = d->hba.base_addr;\r\nunsigned long flags;\r\nDBG("%s: %p, %d, %d, %d\n", __func__, base_addr, devfn, where,\r\nsize);\r\nspin_lock_irqsave(&d->dinosaur_pen, flags);\r\n__raw_writel(v & 0xffffff00, base_addr + DINO_PCI_ADDR);\r\n__raw_readl(base_addr + DINO_CONFIG_DATA);\r\n__raw_writel(v, base_addr + DINO_PCI_ADDR);\r\nif (size == 1) {\r\nwriteb(val, base_addr + DINO_CONFIG_DATA + (where & 3));\r\n} else if (size == 2) {\r\nwritew(val, base_addr + DINO_CONFIG_DATA + (where & 2));\r\n} else if (size == 4) {\r\nwritel(val, base_addr + DINO_CONFIG_DATA);\r\n}\r\nspin_unlock_irqrestore(&d->dinosaur_pen, flags);\r\nreturn 0;\r\n}\r\nstatic void dino_mask_irq(struct irq_data *d)\r\n{\r\nstruct dino_device *dino_dev = irq_data_get_irq_chip_data(d);\r\nint local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);\r\nDBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, d->irq);\r\ndino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));\r\n__raw_writel(dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);\r\n}\r\nstatic void dino_unmask_irq(struct irq_data *d)\r\n{\r\nstruct dino_device *dino_dev = irq_data_get_irq_chip_data(d);\r\nint local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);\r\nu32 tmp;\r\nDBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, d->irq);\r\n__raw_readl(dino_dev->hba.base_addr+DINO_IPR);\r\ndino_dev->imr |= DINO_MASK_IRQ(local_irq);\r\n__raw_writel( dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);\r\ntmp = __raw_readl(dino_dev->hba.base_addr+DINO_ILR);\r\nif (tmp & DINO_MASK_IRQ(local_irq)) {\r\nDBG(KERN_WARNING "%s(): IRQ asserted! (ILR 0x%x)\n",\r\n__func__, tmp);\r\ngsc_writel(dino_dev->txn_data, dino_dev->txn_addr);\r\n}\r\n}\r\nstatic irqreturn_t dino_isr(int irq, void *intr_dev)\r\n{\r\nstruct dino_device *dino_dev = intr_dev;\r\nu32 mask;\r\nint ilr_loop = 100;\r\n#ifdef DINO_DEBUG\r\ndino_dev->dino_irr0 =\r\n#endif\r\nmask = __raw_readl(dino_dev->hba.base_addr+DINO_IRR0) & DINO_IRR_MASK;\r\nif (mask == 0)\r\nreturn IRQ_NONE;\r\nilr_again:\r\ndo {\r\nint local_irq = __ffs(mask);\r\nint irq = dino_dev->global_irq[local_irq];\r\nDBG(KERN_DEBUG "%s(%d, %p) mask 0x%x\n",\r\n__func__, irq, intr_dev, mask);\r\ngeneric_handle_irq(irq);\r\nmask &= ~(1 << local_irq);\r\n} while (mask);\r\nmask = __raw_readl(dino_dev->hba.base_addr+DINO_ILR) & dino_dev->imr;\r\nif (mask) {\r\nif (--ilr_loop > 0)\r\ngoto ilr_again;\r\nprintk(KERN_ERR "Dino 0x%p: stuck interrupt %d\n",\r\ndino_dev->hba.base_addr, mask);\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dino_assign_irq(struct dino_device *dino, int local_irq, int *irqp)\r\n{\r\nint irq = gsc_assign_irq(&dino_interrupt_type, dino);\r\nif (irq == NO_IRQ)\r\nreturn;\r\n*irqp = irq;\r\ndino->global_irq[local_irq] = irq;\r\n}\r\nstatic void dino_choose_irq(struct parisc_device *dev, void *ctrl)\r\n{\r\nint irq;\r\nstruct dino_device *dino = ctrl;\r\nswitch (dev->id.sversion) {\r\ncase 0x00084: irq = 8; break;\r\ncase 0x0008c: irq = 10; break;\r\ncase 0x00096: irq = 8; break;\r\ndefault: return;\r\n}\r\ndino_assign_irq(dino, irq, &dev->irq);\r\n}\r\nstatic void __devinit quirk_cirrus_cardbus(struct pci_dev *dev)\r\n{\r\nu8 new_irq = dev->irq - 1;\r\nprintk(KERN_INFO "PCI: Cirrus Cardbus IRQ fixup for %s, from %d to %d\n",\r\npci_name(dev), dev->irq, new_irq);\r\ndev->irq = new_irq;\r\n}\r\nstatic void __init\r\ndino_bios_init(void)\r\n{\r\nDBG("dino_bios_init\n");\r\n}\r\nstatic void __init\r\ndino_card_setup(struct pci_bus *bus, void __iomem *base_addr)\r\n{\r\nint i;\r\nstruct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));\r\nstruct resource *res;\r\nchar name[128];\r\nint size;\r\nres = &dino_dev->hba.lmmio_space;\r\nres->flags = IORESOURCE_MEM;\r\nsize = scnprintf(name, sizeof(name), "Dino LMMIO (%s)",\r\ndev_name(bus->bridge));\r\nres->name = kmalloc(size+1, GFP_KERNEL);\r\nif(res->name)\r\nstrcpy((char *)res->name, name);\r\nelse\r\nres->name = dino_dev->hba.lmmio_space.name;\r\nif (ccio_allocate_resource(dino_dev->hba.dev, res, _8MB,\r\nF_EXTEND(0xf0000000UL) | _8MB,\r\nF_EXTEND(0xffffffffUL) &~ _8MB, _8MB) < 0) {\r\nstruct list_head *ln, *tmp_ln;\r\nprintk(KERN_ERR "Dino: cannot attach bus %s\n",\r\ndev_name(bus->bridge));\r\nlist_for_each_safe(ln, tmp_ln, &bus->devices) {\r\nstruct pci_dev *dev = pci_dev_b(ln);\r\nlist_del(&dev->bus_list);\r\n}\r\nreturn;\r\n}\r\nbus->resource[1] = res;\r\nbus->resource[0] = &(dino_dev->hba.io_space);\r\nfor (i = 1; i < 31; i++) {\r\nif (res->start == F_EXTEND(0xf0000000UL | (i * _8MB)))\r\nbreak;\r\n}\r\nDBG("DINO GSC WRITE i=%d, start=%lx, dino addr = %p\n",\r\ni, res->start, base_addr + DINO_IO_ADDR_EN);\r\n__raw_writel(1 << i, base_addr + DINO_IO_ADDR_EN);\r\n}\r\nstatic void __init\r\ndino_card_fixup(struct pci_dev *dev)\r\n{\r\nu32 irq_pin;\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {\r\npanic("Card-Mode Dino: PCI-PCI Bridge not supported\n");\r\n}\r\ndino_cfg_write(dev->bus, dev->devfn,\r\nPCI_CACHE_LINE_SIZE, 2, 0xff00 | L1_CACHE_BYTES/4);\r\ndino_cfg_read(dev->bus, dev->devfn, PCI_INTERRUPT_PIN, 1, &irq_pin);\r\ndev->irq = pci_swizzle_interrupt_pin(dev, irq_pin) - 1;\r\ndino_cfg_write(dev->bus, dev->devfn, PCI_INTERRUPT_LINE, 1, dev->irq);\r\n}\r\nstatic void __init\r\ndino_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct list_head *ln;\r\nstruct pci_dev *dev;\r\nstruct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));\r\nDBG(KERN_WARNING "%s(0x%p) bus %d platform_data 0x%p\n",\r\n__func__, bus, bus->secondary,\r\nbus->bridge->platform_data);\r\nif (is_card_dino(&dino_dev->hba.dev->id)) {\r\ndino_card_setup(bus, dino_dev->hba.base_addr);\r\n} else if (bus->parent) {\r\nint i;\r\npci_read_bridge_bases(bus);\r\nfor(i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {\r\nif((bus->self->resource[i].flags &\r\n(IORESOURCE_IO | IORESOURCE_MEM)) == 0)\r\ncontinue;\r\nif(bus->self->resource[i].flags & IORESOURCE_MEM) {\r\nbus->self->resource[i].end = bus->self->resource[i].end - bus->self->resource[i].start + DINO_BRIDGE_ALIGN;\r\nbus->self->resource[i].start = DINO_BRIDGE_ALIGN;\r\n}\r\nDBG("DEBUG %s assigning %d [0x%lx,0x%lx]\n",\r\ndev_name(&bus->self->dev), i,\r\nbus->self->resource[i].start,\r\nbus->self->resource[i].end);\r\nWARN_ON(pci_assign_resource(bus->self, i));\r\nDBG("DEBUG %s after assign %d [0x%lx,0x%lx]\n",\r\ndev_name(&bus->self->dev), i,\r\nbus->self->resource[i].start,\r\nbus->self->resource[i].end);\r\n}\r\n}\r\nlist_for_each(ln, &bus->devices) {\r\ndev = pci_dev_b(ln);\r\nif (is_card_dino(&dino_dev->hba.dev->id))\r\ndino_card_fixup(dev);\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)\r\ncontinue;\r\ndev->resource[PCI_ROM_RESOURCE].flags = 0;\r\nif(dev->irq == 255) {\r\n#define DINO_FIX_UNASSIGNED_INTERRUPTS\r\n#ifdef DINO_FIX_UNASSIGNED_INTERRUPTS\r\nu32 irq_pin;\r\ndino_cfg_read(dev->bus, dev->devfn,\r\nPCI_INTERRUPT_PIN, 1, &irq_pin);\r\nirq_pin = pci_swizzle_interrupt_pin(dev, irq_pin) - 1;\r\nprintk(KERN_WARNING "Device %s has undefined IRQ, "\r\n"setting to %d\n", pci_name(dev), irq_pin);\r\ndino_cfg_write(dev->bus, dev->devfn,\r\nPCI_INTERRUPT_LINE, 1, irq_pin);\r\ndino_assign_irq(dino_dev, irq_pin, &dev->irq);\r\n#else\r\ndev->irq = 65535;\r\nprintk(KERN_WARNING "Device %s has unassigned IRQ\n", pci_name(dev));\r\n#endif\r\n} else {\r\ndino_assign_irq(dino_dev, dev->irq, &dev->irq);\r\n}\r\n}\r\n}\r\nstatic void __init\r\ndino_card_init(struct dino_device *dino_dev)\r\n{\r\nu32 brdg_feat = 0x00784e05;\r\nunsigned long status;\r\nstatus = __raw_readl(dino_dev->hba.base_addr+DINO_IO_STATUS);\r\nif (status & 0x0000ff80) {\r\n__raw_writel(0x00000005,\r\ndino_dev->hba.base_addr+DINO_IO_COMMAND);\r\nudelay(1);\r\n}\r\n__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_GMASK);\r\n__raw_writel(0x00000001, dino_dev->hba.base_addr+DINO_IO_FBB_EN);\r\n__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_ICR);\r\n#if 1\r\nbrdg_feat &= ~0x4;\r\n#endif\r\n__raw_writel( brdg_feat, dino_dev->hba.base_addr+DINO_BRDG_FEAT);\r\n__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_IO_ADDR_EN);\r\n__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_DAMODE);\r\n__raw_writel(0x00222222, dino_dev->hba.base_addr+DINO_PCIROR);\r\n__raw_writel(0x00222222, dino_dev->hba.base_addr+DINO_PCIWOR);\r\n__raw_writel(0x00000040, dino_dev->hba.base_addr+DINO_MLTIM);\r\n__raw_writel(0x00000080, dino_dev->hba.base_addr+DINO_IO_CONTROL);\r\n__raw_writel(0x0000008c, dino_dev->hba.base_addr+DINO_TLTIM);\r\n__raw_writel(0x0000007e, dino_dev->hba.base_addr+DINO_PAMR);\r\n__raw_writel(0x0000007f, dino_dev->hba.base_addr+DINO_PAPR);\r\n__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_PAMR);\r\n__raw_writel(0x0000004f, dino_dev->hba.base_addr+DINO_PCICMD);\r\nmdelay(pci_post_reset_delay);\r\n}\r\nstatic int __init\r\ndino_bridge_init(struct dino_device *dino_dev, const char *name)\r\n{\r\nunsigned long io_addr;\r\nint result, i, count=0;\r\nstruct resource *res, *prevres = NULL;\r\nio_addr = __raw_readl(dino_dev->hba.base_addr + DINO_IO_ADDR_EN);\r\nif (io_addr == 0) {\r\nprintk(KERN_WARNING "%s: No PCI devices enabled.\n", name);\r\nreturn -ENODEV;\r\n}\r\nres = &dino_dev->hba.lmmio_space;\r\nfor (i = 0; i < 32; i++) {\r\nunsigned long start, end;\r\nif((io_addr & (1 << i)) == 0)\r\ncontinue;\r\nstart = F_EXTEND(0xf0000000UL) | (i << 23);\r\nend = start + 8 * 1024 * 1024 - 1;\r\nDBG("DINO RANGE %d is at 0x%lx-0x%lx\n", count,\r\nstart, end);\r\nif(prevres && prevres->end + 1 == start) {\r\nprevres->end = end;\r\n} else {\r\nif(count >= DINO_MAX_LMMIO_RESOURCES) {\r\nprintk(KERN_ERR "%s is out of resource windows for range %d (0x%lx-0x%lx)\n", name, count, start, end);\r\nbreak;\r\n}\r\nprevres = res;\r\nres->start = start;\r\nres->end = end;\r\nres->flags = IORESOURCE_MEM;\r\nres->name = kmalloc(64, GFP_KERNEL);\r\nif(res->name)\r\nsnprintf((char *)res->name, 64, "%s LMMIO %d",\r\nname, count);\r\nres++;\r\ncount++;\r\n}\r\n}\r\nres = &dino_dev->hba.lmmio_space;\r\nfor(i = 0; i < DINO_MAX_LMMIO_RESOURCES; i++) {\r\nif(res[i].flags == 0)\r\nbreak;\r\nresult = ccio_request_resource(dino_dev->hba.dev, &res[i]);\r\nif (result < 0) {\r\nprintk(KERN_ERR "%s: failed to claim PCI Bus address "\r\n"space %d (0x%lx-0x%lx)!\n", name, i,\r\n(unsigned long)res[i].start, (unsigned long)res[i].end);\r\nreturn result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init dino_common_init(struct parisc_device *dev,\r\nstruct dino_device *dino_dev, const char *name)\r\n{\r\nint status;\r\nu32 eim;\r\nstruct gsc_irq gsc_irq;\r\nstruct resource *res;\r\npcibios_register_hba(&dino_dev->hba);\r\npci_bios = &dino_bios_ops;\r\npci_port = &dino_port_ops;\r\ndev->irq = gsc_alloc_irq(&gsc_irq);\r\ndino_dev->txn_addr = gsc_irq.txn_addr;\r\ndino_dev->txn_data = gsc_irq.txn_data;\r\neim = ((u32) gsc_irq.txn_addr) | gsc_irq.txn_data;\r\nif (dev->irq < 0) {\r\nprintk(KERN_WARNING "%s: gsc_alloc_irq() failed\n", name);\r\nreturn 1;\r\n}\r\nstatus = request_irq(dev->irq, dino_isr, 0, name, dino_dev);\r\nif (status) {\r\nprintk(KERN_WARNING "%s: request_irq() failed with %d\n",\r\nname, status);\r\nreturn 1;\r\n}\r\ngsc_fixup_irqs(dev, dino_dev, dino_choose_irq);\r\n__raw_writel(eim, dino_dev->hba.base_addr+DINO_IAR0);\r\n__raw_readl(dino_dev->hba.base_addr+DINO_IRR0);\r\nres = &dino_dev->hba.io_space;\r\nif (!is_cujo(&dev->id)) {\r\nres->name = "Dino I/O Port";\r\n} else {\r\nres->name = "Cujo I/O Port";\r\n}\r\nres->start = HBA_PORT_BASE(dino_dev->hba.hba_num);\r\nres->end = res->start + (HBA_PORT_SPACE_SIZE - 1);\r\nres->flags = IORESOURCE_IO;\r\nif (request_resource(&ioport_resource, res) < 0) {\r\nprintk(KERN_ERR "%s: request I/O Port region failed "\r\n"0x%lx/%lx (hpa 0x%p)\n",\r\nname, (unsigned long)res->start, (unsigned long)res->end,\r\ndino_dev->hba.base_addr);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init dino_probe(struct parisc_device *dev)\r\n{\r\nstruct dino_device *dino_dev;\r\nconst char *version = "unknown";\r\nchar *name;\r\nint is_cujo = 0;\r\nLIST_HEAD(resources);\r\nstruct pci_bus *bus;\r\nunsigned long hpa = dev->hpa.start;\r\nname = "Dino";\r\nif (is_card_dino(&dev->id)) {\r\nversion = "3.x (card mode)";\r\n} else {\r\nif (!is_cujo(&dev->id)) {\r\nif (dev->id.hversion_rev < 4) {\r\nversion = dino_vers[dev->id.hversion_rev];\r\n}\r\n} else {\r\nname = "Cujo";\r\nis_cujo = 1;\r\nif (dev->id.hversion_rev < 2) {\r\nversion = cujo_vers[dev->id.hversion_rev];\r\n}\r\n}\r\n}\r\nprintk("%s version %s found at 0x%lx\n", name, version, hpa);\r\nif (!request_mem_region(hpa, PAGE_SIZE, name)) {\r\nprintk(KERN_ERR "DINO: Hey! Someone took my MMIO space (0x%ld)!\n",\r\nhpa);\r\nreturn 1;\r\n}\r\nif (is_cujo && dev->id.hversion_rev == 1) {\r\n#ifdef CONFIG_IOMMU_CCIO\r\nprintk(KERN_WARNING "Enabling Cujo 2.0 bug workaround\n");\r\nif (hpa == (unsigned long)CUJO_RAVEN_ADDR) {\r\nccio_cujo20_fixup(dev, CUJO_RAVEN_BADPAGE);\r\n} else if (hpa == (unsigned long)CUJO_FIREHAWK_ADDR) {\r\nccio_cujo20_fixup(dev, CUJO_FIREHAWK_BADPAGE);\r\n} else {\r\nprintk("Don't recognise Cujo at address 0x%lx, not enabling workaround\n", hpa);\r\n}\r\n#endif\r\n} else if (!is_cujo && !is_card_dino(&dev->id) &&\r\ndev->id.hversion_rev < 3) {\r\nprintk(KERN_WARNING\r\n"The GSCtoPCI (Dino hrev %d) bus converter found may exhibit\n"\r\n"data corruption. See Service Note Numbers: A4190A-01, A4191A-01.\n"\r\n"Systems shipped after Aug 20, 1997 will not exhibit this problem.\n"\r\n"Models affected: C180, C160, C160L, B160L, and B132L workstations.\n\n",\r\ndev->id.hversion_rev);\r\n}\r\ndino_dev = kzalloc(sizeof(struct dino_device), GFP_KERNEL);\r\nif (!dino_dev) {\r\nprintk("dino_init_chip - couldn't alloc dino_device\n");\r\nreturn 1;\r\n}\r\ndino_dev->hba.dev = dev;\r\ndino_dev->hba.base_addr = ioremap_nocache(hpa, 4096);\r\ndino_dev->hba.lmmio_space_offset = 0;\r\nspin_lock_init(&dino_dev->dinosaur_pen);\r\ndino_dev->hba.iommu = ccio_get_iommu(dev);\r\nif (is_card_dino(&dev->id)) {\r\ndino_card_init(dino_dev);\r\n} else {\r\ndino_bridge_init(dino_dev, name);\r\n}\r\nif (dino_common_init(dev, dino_dev, name))\r\nreturn 1;\r\ndev->dev.platform_data = dino_dev;\r\npci_add_resource_offset(&resources, &dino_dev->hba.io_space,\r\nHBA_PORT_BASE(dino_dev->hba.hba_num));\r\nif (dino_dev->hba.lmmio_space.flags)\r\npci_add_resource_offset(&resources, &dino_dev->hba.lmmio_space,\r\ndino_dev->hba.lmmio_space_offset);\r\nif (dino_dev->hba.elmmio_space.flags)\r\npci_add_resource_offset(&resources, &dino_dev->hba.elmmio_space,\r\ndino_dev->hba.lmmio_space_offset);\r\nif (dino_dev->hba.gmmio_space.flags)\r\npci_add_resource(&resources, &dino_dev->hba.gmmio_space);\r\ndino_dev->hba.hba_bus = bus = pci_create_root_bus(&dev->dev,\r\ndino_current_bus, &dino_cfg_ops, NULL, &resources);\r\nif (!bus) {\r\nprintk(KERN_ERR "ERROR: failed to scan PCI bus on %s (duplicate bus number %d?)\n",\r\ndev_name(&dev->dev), dino_current_bus);\r\npci_free_resource_list(&resources);\r\ndino_current_bus++;\r\nreturn 0;\r\n}\r\nbus->subordinate = pci_scan_child_bus(bus);\r\ndino_current_bus = bus->subordinate + 1;\r\npci_bus_assign_resources(bus);\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\n}\r\nint __init dino_init(void)\r\n{\r\nregister_parisc_driver(&dino_driver);\r\nreturn 0;\r\n}
