static void smp_task_timedout(unsigned long _task)\r\n{\r\nstruct sas_task *task = (void *) _task;\r\nunsigned long flags;\r\nspin_lock_irqsave(&task->task_state_lock, flags);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\r\ntask->task_state_flags |= SAS_TASK_STATE_ABORTED;\r\nspin_unlock_irqrestore(&task->task_state_lock, flags);\r\ncomplete(&task->completion);\r\n}\r\nstatic void smp_task_done(struct sas_task *task)\r\n{\r\nif (!del_timer(&task->timer))\r\nreturn;\r\ncomplete(&task->completion);\r\n}\r\nstatic int smp_execute_task(struct domain_device *dev, void *req, int req_size,\r\nvoid *resp, int resp_size)\r\n{\r\nint res, retry;\r\nstruct sas_task *task = NULL;\r\nstruct sas_internal *i =\r\nto_sas_internal(dev->port->ha->core.shost->transportt);\r\nmutex_lock(&dev->ex_dev.cmd_mutex);\r\nfor (retry = 0; retry < 3; retry++) {\r\nif (test_bit(SAS_DEV_GONE, &dev->state)) {\r\nres = -ECOMM;\r\nbreak;\r\n}\r\ntask = sas_alloc_task(GFP_KERNEL);\r\nif (!task) {\r\nres = -ENOMEM;\r\nbreak;\r\n}\r\ntask->dev = dev;\r\ntask->task_proto = dev->tproto;\r\nsg_init_one(&task->smp_task.smp_req, req, req_size);\r\nsg_init_one(&task->smp_task.smp_resp, resp, resp_size);\r\ntask->task_done = smp_task_done;\r\ntask->timer.data = (unsigned long) task;\r\ntask->timer.function = smp_task_timedout;\r\ntask->timer.expires = jiffies + SMP_TIMEOUT*HZ;\r\nadd_timer(&task->timer);\r\nres = i->dft->lldd_execute_task(task, 1, GFP_KERNEL);\r\nif (res) {\r\ndel_timer(&task->timer);\r\nSAS_DPRINTK("executing SMP task failed:%d\n", res);\r\nbreak;\r\n}\r\nwait_for_completion(&task->completion);\r\nres = -ECOMM;\r\nif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\r\nSAS_DPRINTK("smp task timed out or aborted\n");\r\ni->dft->lldd_abort_task(task);\r\nif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\r\nSAS_DPRINTK("SMP task aborted and not done\n");\r\nbreak;\r\n}\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAM_STAT_GOOD) {\r\nres = 0;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_UNDERRUN) {\r\nres = task->task_status.residual;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_COMPLETE &&\r\ntask->task_status.stat == SAS_DATA_OVERRUN) {\r\nres = -EMSGSIZE;\r\nbreak;\r\n}\r\nif (task->task_status.resp == SAS_TASK_UNDELIVERED &&\r\ntask->task_status.stat == SAS_DEVICE_UNKNOWN)\r\nbreak;\r\nelse {\r\nSAS_DPRINTK("%s: task to dev %016llx response: 0x%x "\r\n"status 0x%x\n", __func__,\r\nSAS_ADDR(dev->sas_addr),\r\ntask->task_status.resp,\r\ntask->task_status.stat);\r\nsas_free_task(task);\r\ntask = NULL;\r\n}\r\n}\r\nmutex_unlock(&dev->ex_dev.cmd_mutex);\r\nBUG_ON(retry == 3 && task != NULL);\r\nsas_free_task(task);\r\nreturn res;\r\n}\r\nstatic inline void *alloc_smp_req(int size)\r\n{\r\nu8 *p = kzalloc(size, GFP_KERNEL);\r\nif (p)\r\np[0] = SMP_REQUEST;\r\nreturn p;\r\n}\r\nstatic inline void *alloc_smp_resp(int size)\r\n{\r\nreturn kzalloc(size, GFP_KERNEL);\r\n}\r\nstatic char sas_route_char(struct domain_device *dev, struct ex_phy *phy)\r\n{\r\nswitch (phy->routing_attr) {\r\ncase TABLE_ROUTING:\r\nif (dev->ex_dev.t2t_supp)\r\nreturn 'U';\r\nelse\r\nreturn 'T';\r\ncase DIRECT_ROUTING:\r\nreturn 'D';\r\ncase SUBTRACTIVE_ROUTING:\r\nreturn 'S';\r\ndefault:\r\nreturn '?';\r\n}\r\n}\r\nstatic enum sas_dev_type to_dev_type(struct discover_resp *dr)\r\n{\r\nif (dr->attached_dev_type == NO_DEVICE && dr->attached_sata_dev &&\r\ndr->linkrate >= SAS_LINK_RATE_1_5_GBPS)\r\nreturn SATA_PENDING;\r\nelse\r\nreturn dr->attached_dev_type;\r\n}\r\nstatic void sas_set_ex_phy(struct domain_device *dev, int phy_id, void *rsp)\r\n{\r\nenum sas_dev_type dev_type;\r\nenum sas_linkrate linkrate;\r\nu8 sas_addr[SAS_ADDR_SIZE];\r\nstruct smp_resp *resp = rsp;\r\nstruct discover_resp *dr = &resp->disc;\r\nstruct sas_ha_struct *ha = dev->port->ha;\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct ex_phy *phy = &ex->ex_phy[phy_id];\r\nstruct sas_rphy *rphy = dev->rphy;\r\nbool new_phy = !phy->phy;\r\nchar *type;\r\nif (new_phy) {\r\nif (WARN_ON_ONCE(test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)))\r\nreturn;\r\nphy->phy = sas_phy_alloc(&rphy->dev, phy_id);\r\nBUG_ON(!phy->phy);\r\n}\r\nswitch (resp->result) {\r\ncase SMP_RESP_PHY_VACANT:\r\nphy->phy_state = PHY_VACANT;\r\nbreak;\r\ndefault:\r\nphy->phy_state = PHY_NOT_PRESENT;\r\nbreak;\r\ncase SMP_RESP_FUNC_ACC:\r\nphy->phy_state = PHY_EMPTY;\r\nbreak;\r\n}\r\ndev_type = phy->attached_dev_type;\r\nlinkrate = phy->linkrate;\r\nmemcpy(sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\r\nphy->attached_dev_type = to_dev_type(dr);\r\nif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\r\ngoto out;\r\nphy->phy_id = phy_id;\r\nphy->linkrate = dr->linkrate;\r\nphy->attached_sata_host = dr->attached_sata_host;\r\nphy->attached_sata_dev = dr->attached_sata_dev;\r\nphy->attached_sata_ps = dr->attached_sata_ps;\r\nphy->attached_iproto = dr->iproto << 1;\r\nphy->attached_tproto = dr->tproto << 1;\r\nif (phy->attached_dev_type == NO_DEVICE ||\r\nphy->linkrate < SAS_LINK_RATE_1_5_GBPS)\r\nmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\r\nelse\r\nmemcpy(phy->attached_sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE);\r\nphy->attached_phy_id = dr->attached_phy_id;\r\nphy->phy_change_count = dr->change_count;\r\nphy->routing_attr = dr->routing_attr;\r\nphy->virtual = dr->virtual;\r\nphy->last_da_index = -1;\r\nphy->phy->identify.sas_address = SAS_ADDR(phy->attached_sas_addr);\r\nphy->phy->identify.device_type = dr->attached_dev_type;\r\nphy->phy->identify.initiator_port_protocols = phy->attached_iproto;\r\nphy->phy->identify.target_port_protocols = phy->attached_tproto;\r\nif (!phy->attached_tproto && dr->attached_sata_dev)\r\nphy->phy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\r\nphy->phy->identify.phy_identifier = phy_id;\r\nphy->phy->minimum_linkrate_hw = dr->hmin_linkrate;\r\nphy->phy->maximum_linkrate_hw = dr->hmax_linkrate;\r\nphy->phy->minimum_linkrate = dr->pmin_linkrate;\r\nphy->phy->maximum_linkrate = dr->pmax_linkrate;\r\nphy->phy->negotiated_linkrate = phy->linkrate;\r\nif (new_phy)\r\nif (sas_phy_add(phy->phy)) {\r\nsas_phy_free(phy->phy);\r\nreturn;\r\n}\r\nout:\r\nswitch (phy->attached_dev_type) {\r\ncase SATA_PENDING:\r\ntype = "stp pending";\r\nbreak;\r\ncase NO_DEVICE:\r\ntype = "no device";\r\nbreak;\r\ncase SAS_END_DEV:\r\nif (phy->attached_iproto) {\r\nif (phy->attached_tproto)\r\ntype = "host+target";\r\nelse\r\ntype = "host";\r\n} else {\r\nif (dr->attached_sata_dev)\r\ntype = "stp";\r\nelse\r\ntype = "ssp";\r\n}\r\nbreak;\r\ncase EDGE_DEV:\r\ncase FANOUT_DEV:\r\ntype = "smp";\r\nbreak;\r\ndefault:\r\ntype = "unknown";\r\n}\r\nif (new_phy || phy->attached_dev_type != dev_type ||\r\nphy->linkrate != linkrate ||\r\nSAS_ADDR(phy->attached_sas_addr) != SAS_ADDR(sas_addr))\r\n;\r\nelse\r\nreturn;\r\nif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\r\nset_bit(DISCE_REVALIDATE_DOMAIN, &dev->port->disc.pending);\r\nSAS_DPRINTK("%sex %016llx phy%02d:%c:%X attached: %016llx (%s)\n",\r\ntest_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state) ? "ata: " : "",\r\nSAS_ADDR(dev->sas_addr), phy->phy_id,\r\nsas_route_char(dev, phy), phy->linkrate,\r\nSAS_ADDR(phy->attached_sas_addr), type);\r\n}\r\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\r\n{\r\nstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\r\nstruct domain_device *dev;\r\nstruct sas_rphy *rphy;\r\nif (!ex_phy->port)\r\nreturn NULL;\r\nrphy = ex_phy->port->rphy;\r\nif (!rphy)\r\nreturn NULL;\r\ndev = sas_find_dev_by_rphy(rphy);\r\nif (dev && dev_is_sata(dev))\r\nreturn dev;\r\nreturn NULL;\r\n}\r\nstatic int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,\r\nu8 *disc_resp, int single)\r\n{\r\nstruct discover_resp *dr;\r\nint res;\r\ndisc_req[9] = single;\r\nres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\r\ndisc_resp, DISCOVER_RESP_SIZE);\r\nif (res)\r\nreturn res;\r\ndr = &((struct smp_resp *)disc_resp)->disc;\r\nif (memcmp(dev->sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE) == 0) {\r\nsas_printk("Found loopback topology, just ignore it!\n");\r\nreturn 0;\r\n}\r\nsas_set_ex_phy(dev, single, disc_resp);\r\nreturn 0;\r\n}\r\nint sas_ex_phy_discover(struct domain_device *dev, int single)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint res = 0;\r\nu8 *disc_req;\r\nu8 *disc_resp;\r\ndisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\r\nif (!disc_req)\r\nreturn -ENOMEM;\r\ndisc_resp = alloc_smp_req(DISCOVER_RESP_SIZE);\r\nif (!disc_resp) {\r\nkfree(disc_req);\r\nreturn -ENOMEM;\r\n}\r\ndisc_req[1] = SMP_DISCOVER;\r\nif (0 <= single && single < ex->num_phys) {\r\nres = sas_ex_phy_discover_helper(dev, disc_req, disc_resp, single);\r\n} else {\r\nint i;\r\nfor (i = 0; i < ex->num_phys; i++) {\r\nres = sas_ex_phy_discover_helper(dev, disc_req,\r\ndisc_resp, i);\r\nif (res)\r\ngoto out_err;\r\n}\r\n}\r\nout_err:\r\nkfree(disc_resp);\r\nkfree(disc_req);\r\nreturn res;\r\n}\r\nstatic int sas_expander_discover(struct domain_device *dev)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint res = -ENOMEM;\r\nex->ex_phy = kzalloc(sizeof(*ex->ex_phy)*ex->num_phys, GFP_KERNEL);\r\nif (!ex->ex_phy)\r\nreturn -ENOMEM;\r\nres = sas_ex_phy_discover(dev, -1);\r\nif (res)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nkfree(ex->ex_phy);\r\nex->ex_phy = NULL;\r\nreturn res;\r\n}\r\nstatic void ex_assign_report_general(struct domain_device *dev,\r\nstruct smp_resp *resp)\r\n{\r\nstruct report_general_resp *rg = &resp->rg;\r\ndev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\r\ndev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\r\ndev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\r\ndev->ex_dev.t2t_supp = rg->t2t_supp;\r\ndev->ex_dev.conf_route_table = rg->conf_route_table;\r\ndev->ex_dev.configuring = rg->configuring;\r\nmemcpy(dev->ex_dev.enclosure_logical_id, rg->enclosure_logical_id, 8);\r\n}\r\nstatic int sas_ex_general(struct domain_device *dev)\r\n{\r\nu8 *rg_req;\r\nstruct smp_resp *rg_resp;\r\nint res;\r\nint i;\r\nrg_req = alloc_smp_req(RG_REQ_SIZE);\r\nif (!rg_req)\r\nreturn -ENOMEM;\r\nrg_resp = alloc_smp_resp(RG_RESP_SIZE);\r\nif (!rg_resp) {\r\nkfree(rg_req);\r\nreturn -ENOMEM;\r\n}\r\nrg_req[1] = SMP_REPORT_GENERAL;\r\nfor (i = 0; i < 5; i++) {\r\nres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\r\nRG_RESP_SIZE);\r\nif (res) {\r\nSAS_DPRINTK("RG to ex %016llx failed:0x%x\n",\r\nSAS_ADDR(dev->sas_addr), res);\r\ngoto out;\r\n} else if (rg_resp->result != SMP_RESP_FUNC_ACC) {\r\nSAS_DPRINTK("RG:ex %016llx returned SMP result:0x%x\n",\r\nSAS_ADDR(dev->sas_addr), rg_resp->result);\r\nres = rg_resp->result;\r\ngoto out;\r\n}\r\nex_assign_report_general(dev, rg_resp);\r\nif (dev->ex_dev.configuring) {\r\nSAS_DPRINTK("RG: ex %llx self-configuring...\n",\r\nSAS_ADDR(dev->sas_addr));\r\nschedule_timeout_interruptible(5*HZ);\r\n} else\r\nbreak;\r\n}\r\nout:\r\nkfree(rg_req);\r\nkfree(rg_resp);\r\nreturn res;\r\n}\r\nstatic void ex_assign_manuf_info(struct domain_device *dev, void\r\n*_mi_resp)\r\n{\r\nu8 *mi_resp = _mi_resp;\r\nstruct sas_rphy *rphy = dev->rphy;\r\nstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\r\nmemcpy(edev->vendor_id, mi_resp + 12, SAS_EXPANDER_VENDOR_ID_LEN);\r\nmemcpy(edev->product_id, mi_resp + 20, SAS_EXPANDER_PRODUCT_ID_LEN);\r\nmemcpy(edev->product_rev, mi_resp + 36,\r\nSAS_EXPANDER_PRODUCT_REV_LEN);\r\nif (mi_resp[8] & 1) {\r\nmemcpy(edev->component_vendor_id, mi_resp + 40,\r\nSAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\r\nedev->component_id = mi_resp[48] << 8 | mi_resp[49];\r\nedev->component_revision_id = mi_resp[50];\r\n}\r\n}\r\nstatic int sas_ex_manuf_info(struct domain_device *dev)\r\n{\r\nu8 *mi_req;\r\nu8 *mi_resp;\r\nint res;\r\nmi_req = alloc_smp_req(MI_REQ_SIZE);\r\nif (!mi_req)\r\nreturn -ENOMEM;\r\nmi_resp = alloc_smp_resp(MI_RESP_SIZE);\r\nif (!mi_resp) {\r\nkfree(mi_req);\r\nreturn -ENOMEM;\r\n}\r\nmi_req[1] = SMP_REPORT_MANUF_INFO;\r\nres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp,MI_RESP_SIZE);\r\nif (res) {\r\nSAS_DPRINTK("MI: ex %016llx failed:0x%x\n",\r\nSAS_ADDR(dev->sas_addr), res);\r\ngoto out;\r\n} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\r\nSAS_DPRINTK("MI ex %016llx returned SMP result:0x%x\n",\r\nSAS_ADDR(dev->sas_addr), mi_resp[2]);\r\ngoto out;\r\n}\r\nex_assign_manuf_info(dev, mi_resp);\r\nout:\r\nkfree(mi_req);\r\nkfree(mi_resp);\r\nreturn res;\r\n}\r\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\r\nenum phy_func phy_func,\r\nstruct sas_phy_linkrates *rates)\r\n{\r\nu8 *pc_req;\r\nu8 *pc_resp;\r\nint res;\r\npc_req = alloc_smp_req(PC_REQ_SIZE);\r\nif (!pc_req)\r\nreturn -ENOMEM;\r\npc_resp = alloc_smp_resp(PC_RESP_SIZE);\r\nif (!pc_resp) {\r\nkfree(pc_req);\r\nreturn -ENOMEM;\r\n}\r\npc_req[1] = SMP_PHY_CONTROL;\r\npc_req[9] = phy_id;\r\npc_req[10]= phy_func;\r\nif (rates) {\r\npc_req[32] = rates->minimum_linkrate << 4;\r\npc_req[33] = rates->maximum_linkrate << 4;\r\n}\r\nres = smp_execute_task(dev, pc_req, PC_REQ_SIZE, pc_resp,PC_RESP_SIZE);\r\nkfree(pc_resp);\r\nkfree(pc_req);\r\nreturn res;\r\n}\r\nstatic void sas_ex_disable_phy(struct domain_device *dev, int phy_id)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct ex_phy *phy = &ex->ex_phy[phy_id];\r\nsas_smp_phy_control(dev, phy_id, PHY_FUNC_DISABLE, NULL);\r\nphy->linkrate = SAS_PHY_DISABLED;\r\n}\r\nstatic void sas_ex_disable_port(struct domain_device *dev, u8 *sas_addr)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint i;\r\nfor (i = 0; i < ex->num_phys; i++) {\r\nstruct ex_phy *phy = &ex->ex_phy[i];\r\nif (phy->phy_state == PHY_VACANT ||\r\nphy->phy_state == PHY_NOT_PRESENT)\r\ncontinue;\r\nif (SAS_ADDR(phy->attached_sas_addr) == SAS_ADDR(sas_addr))\r\nsas_ex_disable_phy(dev, i);\r\n}\r\n}\r\nstatic int sas_dev_present_in_domain(struct asd_sas_port *port,\r\nu8 *sas_addr)\r\n{\r\nstruct domain_device *dev;\r\nif (SAS_ADDR(port->sas_addr) == SAS_ADDR(sas_addr))\r\nreturn 1;\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nif (SAS_ADDR(dev->sas_addr) == SAS_ADDR(sas_addr))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint sas_smp_get_phy_events(struct sas_phy *phy)\r\n{\r\nint res;\r\nu8 *req;\r\nu8 *resp;\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\r\nreq = alloc_smp_req(RPEL_REQ_SIZE);\r\nif (!req)\r\nreturn -ENOMEM;\r\nresp = alloc_smp_resp(RPEL_RESP_SIZE);\r\nif (!resp) {\r\nkfree(req);\r\nreturn -ENOMEM;\r\n}\r\nreq[1] = SMP_REPORT_PHY_ERR_LOG;\r\nreq[9] = phy->number;\r\nres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\r\nresp, RPEL_RESP_SIZE);\r\nif (!res)\r\ngoto out;\r\nphy->invalid_dword_count = scsi_to_u32(&resp[12]);\r\nphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\r\nphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\r\nphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\r\nout:\r\nkfree(resp);\r\nreturn res;\r\n}\r\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\r\nstruct smp_resp *rps_resp)\r\n{\r\nint res;\r\nu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\r\nu8 *resp = (u8 *)rps_resp;\r\nif (!rps_req)\r\nreturn -ENOMEM;\r\nrps_req[1] = SMP_REPORT_PHY_SATA;\r\nrps_req[9] = phy_id;\r\nres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\r\nrps_resp, RPS_RESP_SIZE);\r\nif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nint j = 24 + (i*4);\r\nu8 a, b;\r\na = resp[j + 0];\r\nb = resp[j + 1];\r\nresp[j + 0] = resp[j + 3];\r\nresp[j + 1] = resp[j + 2];\r\nresp[j + 2] = b;\r\nresp[j + 3] = a;\r\n}\r\n}\r\nkfree(rps_req);\r\nreturn res;\r\n}\r\nstatic void sas_ex_get_linkrate(struct domain_device *parent,\r\nstruct domain_device *child,\r\nstruct ex_phy *parent_phy)\r\n{\r\nstruct expander_device *parent_ex = &parent->ex_dev;\r\nstruct sas_port *port;\r\nint i;\r\nchild->pathways = 0;\r\nport = parent_phy->port;\r\nfor (i = 0; i < parent_ex->num_phys; i++) {\r\nstruct ex_phy *phy = &parent_ex->ex_phy[i];\r\nif (phy->phy_state == PHY_VACANT ||\r\nphy->phy_state == PHY_NOT_PRESENT)\r\ncontinue;\r\nif (SAS_ADDR(phy->attached_sas_addr) ==\r\nSAS_ADDR(child->sas_addr)) {\r\nchild->min_linkrate = min(parent->min_linkrate,\r\nphy->linkrate);\r\nchild->max_linkrate = max(parent->max_linkrate,\r\nphy->linkrate);\r\nchild->pathways++;\r\nsas_port_add_phy(port, phy->phy);\r\n}\r\n}\r\nchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\r\nchild->pathways = min(child->pathways, parent->pathways);\r\n}\r\nstatic struct domain_device *sas_ex_discover_end_dev(\r\nstruct domain_device *parent, int phy_id)\r\n{\r\nstruct expander_device *parent_ex = &parent->ex_dev;\r\nstruct ex_phy *phy = &parent_ex->ex_phy[phy_id];\r\nstruct domain_device *child = NULL;\r\nstruct sas_rphy *rphy;\r\nint res;\r\nif (phy->attached_sata_host || phy->attached_sata_ps)\r\nreturn NULL;\r\nchild = sas_alloc_device();\r\nif (!child)\r\nreturn NULL;\r\nkref_get(&parent->kref);\r\nchild->parent = parent;\r\nchild->port = parent->port;\r\nchild->iproto = phy->attached_iproto;\r\nmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\r\nsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\r\nif (!phy->port) {\r\nphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\r\nif (unlikely(!phy->port))\r\ngoto out_err;\r\nif (unlikely(sas_port_add(phy->port) != 0)) {\r\nsas_port_free(phy->port);\r\ngoto out_err;\r\n}\r\n}\r\nsas_ex_get_linkrate(parent, child, phy);\r\nsas_device_set_phy(child, phy->port);\r\n#ifdef CONFIG_SCSI_SAS_ATA\r\nif ((phy->attached_tproto & SAS_PROTOCOL_STP) || phy->attached_sata_dev) {\r\nres = sas_get_ata_info(child, phy);\r\nif (res)\r\ngoto out_free;\r\nsas_init_dev(child);\r\nres = sas_ata_init(child);\r\nif (res)\r\ngoto out_free;\r\nrphy = sas_end_device_alloc(phy->port);\r\nif (!rphy)\r\ngoto out_free;\r\nchild->rphy = rphy;\r\nget_device(&rphy->dev);\r\nlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\r\nres = sas_discover_sata(child);\r\nif (res) {\r\nSAS_DPRINTK("sas_discover_sata() for device %16llx at "\r\n"%016llx:0x%x returned 0x%x\n",\r\nSAS_ADDR(child->sas_addr),\r\nSAS_ADDR(parent->sas_addr), phy_id, res);\r\ngoto out_list_del;\r\n}\r\n} else\r\n#endif\r\nif (phy->attached_tproto & SAS_PROTOCOL_SSP) {\r\nchild->dev_type = SAS_END_DEV;\r\nrphy = sas_end_device_alloc(phy->port);\r\nif (unlikely(!rphy))\r\ngoto out_free;\r\nchild->tproto = phy->attached_tproto;\r\nsas_init_dev(child);\r\nchild->rphy = rphy;\r\nget_device(&rphy->dev);\r\nsas_fill_in_rphy(child, rphy);\r\nlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\r\nres = sas_discover_end_dev(child);\r\nif (res) {\r\nSAS_DPRINTK("sas_discover_end_dev() for device %16llx "\r\n"at %016llx:0x%x returned 0x%x\n",\r\nSAS_ADDR(child->sas_addr),\r\nSAS_ADDR(parent->sas_addr), phy_id, res);\r\ngoto out_list_del;\r\n}\r\n} else {\r\nSAS_DPRINTK("target proto 0x%x at %016llx:0x%x not handled\n",\r\nphy->attached_tproto, SAS_ADDR(parent->sas_addr),\r\nphy_id);\r\ngoto out_free;\r\n}\r\nlist_add_tail(&child->siblings, &parent_ex->children);\r\nreturn child;\r\nout_list_del:\r\nsas_rphy_free(child->rphy);\r\nlist_del(&child->disco_list_node);\r\nspin_lock_irq(&parent->port->dev_list_lock);\r\nlist_del(&child->dev_list_node);\r\nspin_unlock_irq(&parent->port->dev_list_lock);\r\nout_free:\r\nsas_port_delete(phy->port);\r\nout_err:\r\nphy->port = NULL;\r\nsas_put_device(child);\r\nreturn NULL;\r\n}\r\nstatic int sas_ex_join_wide_port(struct domain_device *parent, int phy_id)\r\n{\r\nstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\r\nint i;\r\nfor (i = 0; i < parent->ex_dev.num_phys; i++) {\r\nstruct ex_phy *ephy = &parent->ex_dev.ex_phy[i];\r\nif (ephy == phy)\r\ncontinue;\r\nif (!memcmp(phy->attached_sas_addr, ephy->attached_sas_addr,\r\nSAS_ADDR_SIZE) && ephy->port) {\r\nsas_port_add_phy(ephy->port, phy->phy);\r\nphy->port = ephy->port;\r\nphy->phy_state = PHY_DEVICE_DISCOVERED;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic struct domain_device *sas_ex_discover_expander(\r\nstruct domain_device *parent, int phy_id)\r\n{\r\nstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\r\nstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\r\nstruct domain_device *child = NULL;\r\nstruct sas_rphy *rphy;\r\nstruct sas_expander_device *edev;\r\nstruct asd_sas_port *port;\r\nint res;\r\nif (phy->routing_attr == DIRECT_ROUTING) {\r\nSAS_DPRINTK("ex %016llx:0x%x:D <--> ex %016llx:0x%x is not "\r\n"allowed\n",\r\nSAS_ADDR(parent->sas_addr), phy_id,\r\nSAS_ADDR(phy->attached_sas_addr),\r\nphy->attached_phy_id);\r\nreturn NULL;\r\n}\r\nchild = sas_alloc_device();\r\nif (!child)\r\nreturn NULL;\r\nphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\r\nBUG_ON(sas_port_add(phy->port) != 0);\r\nswitch (phy->attached_dev_type) {\r\ncase EDGE_DEV:\r\nrphy = sas_expander_alloc(phy->port,\r\nSAS_EDGE_EXPANDER_DEVICE);\r\nbreak;\r\ncase FANOUT_DEV:\r\nrphy = sas_expander_alloc(phy->port,\r\nSAS_FANOUT_EXPANDER_DEVICE);\r\nbreak;\r\ndefault:\r\nrphy = NULL;\r\nBUG();\r\n}\r\nport = parent->port;\r\nchild->rphy = rphy;\r\nget_device(&rphy->dev);\r\nedev = rphy_to_expander_device(rphy);\r\nchild->dev_type = phy->attached_dev_type;\r\nkref_get(&parent->kref);\r\nchild->parent = parent;\r\nchild->port = port;\r\nchild->iproto = phy->attached_iproto;\r\nchild->tproto = phy->attached_tproto;\r\nmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\r\nsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\r\nsas_ex_get_linkrate(parent, child, phy);\r\nedev->level = parent_ex->level + 1;\r\nparent->port->disc.max_level = max(parent->port->disc.max_level,\r\nedev->level);\r\nsas_init_dev(child);\r\nsas_fill_in_rphy(child, rphy);\r\nsas_rphy_add(rphy);\r\nspin_lock_irq(&parent->port->dev_list_lock);\r\nlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\r\nspin_unlock_irq(&parent->port->dev_list_lock);\r\nres = sas_discover_expander(child);\r\nif (res) {\r\nsas_rphy_delete(rphy);\r\nspin_lock_irq(&parent->port->dev_list_lock);\r\nlist_del(&child->dev_list_node);\r\nspin_unlock_irq(&parent->port->dev_list_lock);\r\nsas_put_device(child);\r\nreturn NULL;\r\n}\r\nlist_add_tail(&child->siblings, &parent->ex_dev.children);\r\nreturn child;\r\n}\r\nstatic int sas_ex_discover_dev(struct domain_device *dev, int phy_id)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\r\nstruct domain_device *child = NULL;\r\nint res = 0;\r\nif (ex_phy->linkrate == SAS_SATA_SPINUP_HOLD) {\r\nif (!sas_smp_phy_control(dev, phy_id, PHY_FUNC_LINK_RESET, NULL))\r\nres = sas_ex_phy_discover(dev, phy_id);\r\nif (res)\r\nreturn res;\r\n}\r\nif (!dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\r\nSAS_ADDR(dev->port->sas_addr))) {\r\nsas_add_parent_port(dev, phy_id);\r\nreturn 0;\r\n}\r\nif (dev->parent && (SAS_ADDR(ex_phy->attached_sas_addr) ==\r\nSAS_ADDR(dev->parent->sas_addr))) {\r\nsas_add_parent_port(dev, phy_id);\r\nif (ex_phy->routing_attr == TABLE_ROUTING)\r\nsas_configure_phy(dev, phy_id, dev->port->sas_addr, 1);\r\nreturn 0;\r\n}\r\nif (sas_dev_present_in_domain(dev->port, ex_phy->attached_sas_addr))\r\nsas_ex_disable_port(dev, ex_phy->attached_sas_addr);\r\nif (ex_phy->attached_dev_type == NO_DEVICE) {\r\nif (ex_phy->routing_attr == DIRECT_ROUTING) {\r\nmemset(ex_phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\r\nsas_configure_routing(dev, ex_phy->attached_sas_addr);\r\n}\r\nreturn 0;\r\n} else if (ex_phy->linkrate == SAS_LINK_RATE_UNKNOWN)\r\nreturn 0;\r\nif (ex_phy->attached_dev_type != SAS_END_DEV &&\r\nex_phy->attached_dev_type != FANOUT_DEV &&\r\nex_phy->attached_dev_type != EDGE_DEV &&\r\nex_phy->attached_dev_type != SATA_PENDING) {\r\nSAS_DPRINTK("unknown device type(0x%x) attached to ex %016llx "\r\n"phy 0x%x\n", ex_phy->attached_dev_type,\r\nSAS_ADDR(dev->sas_addr),\r\nphy_id);\r\nreturn 0;\r\n}\r\nres = sas_configure_routing(dev, ex_phy->attached_sas_addr);\r\nif (res) {\r\nSAS_DPRINTK("configure routing for dev %016llx "\r\n"reported 0x%x. Forgotten\n",\r\nSAS_ADDR(ex_phy->attached_sas_addr), res);\r\nsas_disable_routing(dev, ex_phy->attached_sas_addr);\r\nreturn res;\r\n}\r\nres = sas_ex_join_wide_port(dev, phy_id);\r\nif (!res) {\r\nSAS_DPRINTK("Attaching ex phy%d to wide port %016llx\n",\r\nphy_id, SAS_ADDR(ex_phy->attached_sas_addr));\r\nreturn res;\r\n}\r\nswitch (ex_phy->attached_dev_type) {\r\ncase SAS_END_DEV:\r\ncase SATA_PENDING:\r\nchild = sas_ex_discover_end_dev(dev, phy_id);\r\nbreak;\r\ncase FANOUT_DEV:\r\nif (SAS_ADDR(dev->port->disc.fanout_sas_addr)) {\r\nSAS_DPRINTK("second fanout expander %016llx phy 0x%x "\r\n"attached to ex %016llx phy 0x%x\n",\r\nSAS_ADDR(ex_phy->attached_sas_addr),\r\nex_phy->attached_phy_id,\r\nSAS_ADDR(dev->sas_addr),\r\nphy_id);\r\nsas_ex_disable_phy(dev, phy_id);\r\nbreak;\r\n} else\r\nmemcpy(dev->port->disc.fanout_sas_addr,\r\nex_phy->attached_sas_addr, SAS_ADDR_SIZE);\r\ncase EDGE_DEV:\r\nchild = sas_ex_discover_expander(dev, phy_id);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (child) {\r\nint i;\r\nfor (i = 0; i < ex->num_phys; i++) {\r\nif (ex->ex_phy[i].phy_state == PHY_VACANT ||\r\nex->ex_phy[i].phy_state == PHY_NOT_PRESENT)\r\ncontinue;\r\nif (SAS_ADDR(ex->ex_phy[i].attached_sas_addr) ==\r\nSAS_ADDR(child->sas_addr)) {\r\nex->ex_phy[i].phy_state= PHY_DEVICE_DISCOVERED;\r\nres = sas_ex_join_wide_port(dev, i);\r\nif (!res)\r\nSAS_DPRINTK("Attaching ex phy%d to wide port %016llx\n",\r\ni, SAS_ADDR(ex->ex_phy[i].attached_sas_addr));\r\n}\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_find_sub_addr(struct domain_device *dev, u8 *sub_addr)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint i;\r\nfor (i = 0; i < ex->num_phys; i++) {\r\nstruct ex_phy *phy = &ex->ex_phy[i];\r\nif (phy->phy_state == PHY_VACANT ||\r\nphy->phy_state == PHY_NOT_PRESENT)\r\ncontinue;\r\nif ((phy->attached_dev_type == EDGE_DEV ||\r\nphy->attached_dev_type == FANOUT_DEV) &&\r\nphy->routing_attr == SUBTRACTIVE_ROUTING) {\r\nmemcpy(sub_addr, phy->attached_sas_addr,SAS_ADDR_SIZE);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sas_check_level_subtractive_boundary(struct domain_device *dev)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct domain_device *child;\r\nu8 sub_addr[8] = {0, };\r\nlist_for_each_entry(child, &ex->children, siblings) {\r\nif (child->dev_type != EDGE_DEV &&\r\nchild->dev_type != FANOUT_DEV)\r\ncontinue;\r\nif (sub_addr[0] == 0) {\r\nsas_find_sub_addr(child, sub_addr);\r\ncontinue;\r\n} else {\r\nu8 s2[8];\r\nif (sas_find_sub_addr(child, s2) &&\r\n(SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\r\nSAS_DPRINTK("ex %016llx->%016llx-?->%016llx "\r\n"diverges from subtractive "\r\n"boundary %016llx\n",\r\nSAS_ADDR(dev->sas_addr),\r\nSAS_ADDR(child->sas_addr),\r\nSAS_ADDR(s2),\r\nSAS_ADDR(sub_addr));\r\nsas_ex_disable_port(child, s2);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sas_ex_discover_devices(struct domain_device *dev, int single)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint i = 0, end = ex->num_phys;\r\nint res = 0;\r\nif (0 <= single && single < end) {\r\ni = single;\r\nend = i+1;\r\n}\r\nfor ( ; i < end; i++) {\r\nstruct ex_phy *ex_phy = &ex->ex_phy[i];\r\nif (ex_phy->phy_state == PHY_VACANT ||\r\nex_phy->phy_state == PHY_NOT_PRESENT ||\r\nex_phy->phy_state == PHY_DEVICE_DISCOVERED)\r\ncontinue;\r\nswitch (ex_phy->linkrate) {\r\ncase SAS_PHY_DISABLED:\r\ncase SAS_PHY_RESET_PROBLEM:\r\ncase SAS_SATA_PORT_SELECTOR:\r\ncontinue;\r\ndefault:\r\nres = sas_ex_discover_dev(dev, i);\r\nif (res)\r\nbreak;\r\ncontinue;\r\n}\r\n}\r\nif (!res)\r\nsas_check_level_subtractive_boundary(dev);\r\nreturn res;\r\n}\r\nstatic int sas_check_ex_subtractive_boundary(struct domain_device *dev)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint i;\r\nu8 *sub_sas_addr = NULL;\r\nif (dev->dev_type != EDGE_DEV)\r\nreturn 0;\r\nfor (i = 0; i < ex->num_phys; i++) {\r\nstruct ex_phy *phy = &ex->ex_phy[i];\r\nif (phy->phy_state == PHY_VACANT ||\r\nphy->phy_state == PHY_NOT_PRESENT)\r\ncontinue;\r\nif ((phy->attached_dev_type == FANOUT_DEV ||\r\nphy->attached_dev_type == EDGE_DEV) &&\r\nphy->routing_attr == SUBTRACTIVE_ROUTING) {\r\nif (!sub_sas_addr)\r\nsub_sas_addr = &phy->attached_sas_addr[0];\r\nelse if (SAS_ADDR(sub_sas_addr) !=\r\nSAS_ADDR(phy->attached_sas_addr)) {\r\nSAS_DPRINTK("ex %016llx phy 0x%x "\r\n"diverges(%016llx) on subtractive "\r\n"boundary(%016llx). Disabled\n",\r\nSAS_ADDR(dev->sas_addr), i,\r\nSAS_ADDR(phy->attached_sas_addr),\r\nSAS_ADDR(sub_sas_addr));\r\nsas_ex_disable_phy(dev, i);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sas_print_parent_topology_bug(struct domain_device *child,\r\nstruct ex_phy *parent_phy,\r\nstruct ex_phy *child_phy)\r\n{\r\nstatic const char *ex_type[] = {\r\n[EDGE_DEV] = "edge",\r\n[FANOUT_DEV] = "fanout",\r\n};\r\nstruct domain_device *parent = child->parent;\r\nsas_printk("%s ex %016llx phy 0x%x <--> %s ex %016llx "\r\n"phy 0x%x has %c:%c routing link!\n",\r\nex_type[parent->dev_type],\r\nSAS_ADDR(parent->sas_addr),\r\nparent_phy->phy_id,\r\nex_type[child->dev_type],\r\nSAS_ADDR(child->sas_addr),\r\nchild_phy->phy_id,\r\nsas_route_char(parent, parent_phy),\r\nsas_route_char(child, child_phy));\r\n}\r\nstatic int sas_check_eeds(struct domain_device *child,\r\nstruct ex_phy *parent_phy,\r\nstruct ex_phy *child_phy)\r\n{\r\nint res = 0;\r\nstruct domain_device *parent = child->parent;\r\nif (SAS_ADDR(parent->port->disc.fanout_sas_addr) != 0) {\r\nres = -ENODEV;\r\nSAS_DPRINTK("edge ex %016llx phy S:0x%x <--> edge ex %016llx "\r\n"phy S:0x%x, while there is a fanout ex %016llx\n",\r\nSAS_ADDR(parent->sas_addr),\r\nparent_phy->phy_id,\r\nSAS_ADDR(child->sas_addr),\r\nchild_phy->phy_id,\r\nSAS_ADDR(parent->port->disc.fanout_sas_addr));\r\n} else if (SAS_ADDR(parent->port->disc.eeds_a) == 0) {\r\nmemcpy(parent->port->disc.eeds_a, parent->sas_addr,\r\nSAS_ADDR_SIZE);\r\nmemcpy(parent->port->disc.eeds_b, child->sas_addr,\r\nSAS_ADDR_SIZE);\r\n} else if (((SAS_ADDR(parent->port->disc.eeds_a) ==\r\nSAS_ADDR(parent->sas_addr)) ||\r\n(SAS_ADDR(parent->port->disc.eeds_a) ==\r\nSAS_ADDR(child->sas_addr)))\r\n&&\r\n((SAS_ADDR(parent->port->disc.eeds_b) ==\r\nSAS_ADDR(parent->sas_addr)) ||\r\n(SAS_ADDR(parent->port->disc.eeds_b) ==\r\nSAS_ADDR(child->sas_addr))))\r\n;\r\nelse {\r\nres = -ENODEV;\r\nSAS_DPRINTK("edge ex %016llx phy 0x%x <--> edge ex %016llx "\r\n"phy 0x%x link forms a third EEDS!\n",\r\nSAS_ADDR(parent->sas_addr),\r\nparent_phy->phy_id,\r\nSAS_ADDR(child->sas_addr),\r\nchild_phy->phy_id);\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_check_parent_topology(struct domain_device *child)\r\n{\r\nstruct expander_device *child_ex = &child->ex_dev;\r\nstruct expander_device *parent_ex;\r\nint i;\r\nint res = 0;\r\nif (!child->parent)\r\nreturn 0;\r\nif (child->parent->dev_type != EDGE_DEV &&\r\nchild->parent->dev_type != FANOUT_DEV)\r\nreturn 0;\r\nparent_ex = &child->parent->ex_dev;\r\nfor (i = 0; i < parent_ex->num_phys; i++) {\r\nstruct ex_phy *parent_phy = &parent_ex->ex_phy[i];\r\nstruct ex_phy *child_phy;\r\nif (parent_phy->phy_state == PHY_VACANT ||\r\nparent_phy->phy_state == PHY_NOT_PRESENT)\r\ncontinue;\r\nif (SAS_ADDR(parent_phy->attached_sas_addr) != SAS_ADDR(child->sas_addr))\r\ncontinue;\r\nchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\r\nswitch (child->parent->dev_type) {\r\ncase EDGE_DEV:\r\nif (child->dev_type == FANOUT_DEV) {\r\nif (parent_phy->routing_attr != SUBTRACTIVE_ROUTING ||\r\nchild_phy->routing_attr != TABLE_ROUTING) {\r\nsas_print_parent_topology_bug(child, parent_phy, child_phy);\r\nres = -ENODEV;\r\n}\r\n} else if (parent_phy->routing_attr == SUBTRACTIVE_ROUTING) {\r\nif (child_phy->routing_attr == SUBTRACTIVE_ROUTING) {\r\nres = sas_check_eeds(child, parent_phy, child_phy);\r\n} else if (child_phy->routing_attr != TABLE_ROUTING) {\r\nsas_print_parent_topology_bug(child, parent_phy, child_phy);\r\nres = -ENODEV;\r\n}\r\n} else if (parent_phy->routing_attr == TABLE_ROUTING) {\r\nif (child_phy->routing_attr == SUBTRACTIVE_ROUTING ||\r\n(child_phy->routing_attr == TABLE_ROUTING &&\r\nchild_ex->t2t_supp && parent_ex->t2t_supp)) {\r\n;\r\n} else {\r\nsas_print_parent_topology_bug(child, parent_phy, child_phy);\r\nres = -ENODEV;\r\n}\r\n}\r\nbreak;\r\ncase FANOUT_DEV:\r\nif (parent_phy->routing_attr != TABLE_ROUTING ||\r\nchild_phy->routing_attr != SUBTRACTIVE_ROUTING) {\r\nsas_print_parent_topology_bug(child, parent_phy, child_phy);\r\nres = -ENODEV;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_configure_present(struct domain_device *dev, int phy_id,\r\nu8 *sas_addr, int *index, int *present)\r\n{\r\nint i, res = 0;\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct ex_phy *phy = &ex->ex_phy[phy_id];\r\nu8 *rri_req;\r\nu8 *rri_resp;\r\n*present = 0;\r\n*index = 0;\r\nrri_req = alloc_smp_req(RRI_REQ_SIZE);\r\nif (!rri_req)\r\nreturn -ENOMEM;\r\nrri_resp = alloc_smp_resp(RRI_RESP_SIZE);\r\nif (!rri_resp) {\r\nkfree(rri_req);\r\nreturn -ENOMEM;\r\n}\r\nrri_req[1] = SMP_REPORT_ROUTE_INFO;\r\nrri_req[9] = phy_id;\r\nfor (i = 0; i < ex->max_route_indexes ; i++) {\r\n*(__be16 *)(rri_req+6) = cpu_to_be16(i);\r\nres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\r\nRRI_RESP_SIZE);\r\nif (res)\r\ngoto out;\r\nres = rri_resp[2];\r\nif (res == SMP_RESP_NO_INDEX) {\r\nSAS_DPRINTK("overflow of indexes: dev %016llx "\r\n"phy 0x%x index 0x%x\n",\r\nSAS_ADDR(dev->sas_addr), phy_id, i);\r\ngoto out;\r\n} else if (res != SMP_RESP_FUNC_ACC) {\r\nSAS_DPRINTK("%s: dev %016llx phy 0x%x index 0x%x "\r\n"result 0x%x\n", __func__,\r\nSAS_ADDR(dev->sas_addr), phy_id, i, res);\r\ngoto out;\r\n}\r\nif (SAS_ADDR(sas_addr) != 0) {\r\nif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\r\n*index = i;\r\nif ((rri_resp[12] & 0x80) == 0x80)\r\n*present = 0;\r\nelse\r\n*present = 1;\r\ngoto out;\r\n} else if (SAS_ADDR(rri_resp+16) == 0) {\r\n*index = i;\r\n*present = 0;\r\ngoto out;\r\n}\r\n} else if (SAS_ADDR(rri_resp+16) == 0 &&\r\nphy->last_da_index < i) {\r\nphy->last_da_index = i;\r\n*index = i;\r\n*present = 0;\r\ngoto out;\r\n}\r\n}\r\nres = -1;\r\nout:\r\nkfree(rri_req);\r\nkfree(rri_resp);\r\nreturn res;\r\n}\r\nstatic int sas_configure_set(struct domain_device *dev, int phy_id,\r\nu8 *sas_addr, int index, int include)\r\n{\r\nint res;\r\nu8 *cri_req;\r\nu8 *cri_resp;\r\ncri_req = alloc_smp_req(CRI_REQ_SIZE);\r\nif (!cri_req)\r\nreturn -ENOMEM;\r\ncri_resp = alloc_smp_resp(CRI_RESP_SIZE);\r\nif (!cri_resp) {\r\nkfree(cri_req);\r\nreturn -ENOMEM;\r\n}\r\ncri_req[1] = SMP_CONF_ROUTE_INFO;\r\n*(__be16 *)(cri_req+6) = cpu_to_be16(index);\r\ncri_req[9] = phy_id;\r\nif (SAS_ADDR(sas_addr) == 0 || !include)\r\ncri_req[12] |= 0x80;\r\nmemcpy(cri_req+16, sas_addr, SAS_ADDR_SIZE);\r\nres = smp_execute_task(dev, cri_req, CRI_REQ_SIZE, cri_resp,\r\nCRI_RESP_SIZE);\r\nif (res)\r\ngoto out;\r\nres = cri_resp[2];\r\nif (res == SMP_RESP_NO_INDEX) {\r\nSAS_DPRINTK("overflow of indexes: dev %016llx phy 0x%x "\r\n"index 0x%x\n",\r\nSAS_ADDR(dev->sas_addr), phy_id, index);\r\n}\r\nout:\r\nkfree(cri_req);\r\nkfree(cri_resp);\r\nreturn res;\r\n}\r\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\r\nu8 *sas_addr, int include)\r\n{\r\nint index;\r\nint present;\r\nint res;\r\nres = sas_configure_present(dev, phy_id, sas_addr, &index, &present);\r\nif (res)\r\nreturn res;\r\nif (include ^ present)\r\nreturn sas_configure_set(dev, phy_id, sas_addr, index,include);\r\nreturn res;\r\n}\r\nstatic int sas_configure_parent(struct domain_device *parent,\r\nstruct domain_device *child,\r\nu8 *sas_addr, int include)\r\n{\r\nstruct expander_device *ex_parent = &parent->ex_dev;\r\nint res = 0;\r\nint i;\r\nif (parent->parent) {\r\nres = sas_configure_parent(parent->parent, parent, sas_addr,\r\ninclude);\r\nif (res)\r\nreturn res;\r\n}\r\nif (ex_parent->conf_route_table == 0) {\r\nSAS_DPRINTK("ex %016llx has self-configuring routing table\n",\r\nSAS_ADDR(parent->sas_addr));\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ex_parent->num_phys; i++) {\r\nstruct ex_phy *phy = &ex_parent->ex_phy[i];\r\nif ((phy->routing_attr == TABLE_ROUTING) &&\r\n(SAS_ADDR(phy->attached_sas_addr) ==\r\nSAS_ADDR(child->sas_addr))) {\r\nres = sas_configure_phy(parent, i, sas_addr, include);\r\nif (res)\r\nreturn res;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr)\r\n{\r\nif (dev->parent)\r\nreturn sas_configure_parent(dev->parent, dev, sas_addr, 1);\r\nreturn 0;\r\n}\r\nstatic int sas_disable_routing(struct domain_device *dev, u8 *sas_addr)\r\n{\r\nif (dev->parent)\r\nreturn sas_configure_parent(dev->parent, dev, sas_addr, 0);\r\nreturn 0;\r\n}\r\nstatic int sas_discover_expander(struct domain_device *dev)\r\n{\r\nint res;\r\nres = sas_notify_lldd_dev_found(dev);\r\nif (res)\r\nreturn res;\r\nres = sas_ex_general(dev);\r\nif (res)\r\ngoto out_err;\r\nres = sas_ex_manuf_info(dev);\r\nif (res)\r\ngoto out_err;\r\nres = sas_expander_discover(dev);\r\nif (res) {\r\nSAS_DPRINTK("expander %016llx discovery failed(0x%x)\n",\r\nSAS_ADDR(dev->sas_addr), res);\r\ngoto out_err;\r\n}\r\nsas_check_ex_subtractive_boundary(dev);\r\nres = sas_check_parent_topology(dev);\r\nif (res)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\nsas_notify_lldd_dev_gone(dev);\r\nreturn res;\r\n}\r\nstatic int sas_ex_level_discovery(struct asd_sas_port *port, const int level)\r\n{\r\nint res = 0;\r\nstruct domain_device *dev;\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nif (dev->dev_type == EDGE_DEV ||\r\ndev->dev_type == FANOUT_DEV) {\r\nstruct sas_expander_device *ex =\r\nrphy_to_expander_device(dev->rphy);\r\nif (level == ex->level)\r\nres = sas_ex_discover_devices(dev, -1);\r\nelse if (level > 0)\r\nres = sas_ex_discover_devices(port->port_dev, -1);\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_ex_bfs_disc(struct asd_sas_port *port)\r\n{\r\nint res;\r\nint level;\r\ndo {\r\nlevel = port->disc.max_level;\r\nres = sas_ex_level_discovery(port, level);\r\nmb();\r\n} while (level < port->disc.max_level);\r\nreturn res;\r\n}\r\nint sas_discover_root_expander(struct domain_device *dev)\r\n{\r\nint res;\r\nstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\r\nres = sas_rphy_add(dev->rphy);\r\nif (res)\r\ngoto out_err;\r\nex->level = dev->port->disc.max_level;\r\nres = sas_discover_expander(dev);\r\nif (res)\r\ngoto out_err2;\r\nsas_ex_bfs_disc(dev->port);\r\nreturn res;\r\nout_err2:\r\nsas_rphy_remove(dev->rphy);\r\nout_err:\r\nreturn res;\r\n}\r\nstatic int sas_get_phy_discover(struct domain_device *dev,\r\nint phy_id, struct smp_resp *disc_resp)\r\n{\r\nint res;\r\nu8 *disc_req;\r\ndisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\r\nif (!disc_req)\r\nreturn -ENOMEM;\r\ndisc_req[1] = SMP_DISCOVER;\r\ndisc_req[9] = phy_id;\r\nres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\r\ndisc_resp, DISCOVER_RESP_SIZE);\r\nif (res)\r\ngoto out;\r\nelse if (disc_resp->result != SMP_RESP_FUNC_ACC) {\r\nres = disc_resp->result;\r\ngoto out;\r\n}\r\nout:\r\nkfree(disc_req);\r\nreturn res;\r\n}\r\nstatic int sas_get_phy_change_count(struct domain_device *dev,\r\nint phy_id, int *pcc)\r\n{\r\nint res;\r\nstruct smp_resp *disc_resp;\r\ndisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\r\nif (!disc_resp)\r\nreturn -ENOMEM;\r\nres = sas_get_phy_discover(dev, phy_id, disc_resp);\r\nif (!res)\r\n*pcc = disc_resp->disc.change_count;\r\nkfree(disc_resp);\r\nreturn res;\r\n}\r\nstatic int sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\r\nu8 *sas_addr, enum sas_dev_type *type)\r\n{\r\nint res;\r\nstruct smp_resp *disc_resp;\r\nstruct discover_resp *dr;\r\ndisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\r\nif (!disc_resp)\r\nreturn -ENOMEM;\r\ndr = &disc_resp->disc;\r\nres = sas_get_phy_discover(dev, phy_id, disc_resp);\r\nif (res == 0) {\r\nmemcpy(sas_addr, disc_resp->disc.attached_sas_addr, 8);\r\n*type = to_dev_type(dr);\r\nif (*type == 0)\r\nmemset(sas_addr, 0, 8);\r\n}\r\nkfree(disc_resp);\r\nreturn res;\r\n}\r\nstatic int sas_find_bcast_phy(struct domain_device *dev, int *phy_id,\r\nint from_phy, bool update)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint res = 0;\r\nint i;\r\nfor (i = from_phy; i < ex->num_phys; i++) {\r\nint phy_change_count = 0;\r\nres = sas_get_phy_change_count(dev, i, &phy_change_count);\r\nswitch (res) {\r\ncase SMP_RESP_PHY_VACANT:\r\ncase SMP_RESP_NO_PHY:\r\ncontinue;\r\ncase SMP_RESP_FUNC_ACC:\r\nbreak;\r\ndefault:\r\nreturn res;\r\n}\r\nif (phy_change_count != ex->ex_phy[i].phy_change_count) {\r\nif (update)\r\nex->ex_phy[i].phy_change_count =\r\nphy_change_count;\r\n*phy_id = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sas_get_ex_change_count(struct domain_device *dev, int *ecc)\r\n{\r\nint res;\r\nu8 *rg_req;\r\nstruct smp_resp *rg_resp;\r\nrg_req = alloc_smp_req(RG_REQ_SIZE);\r\nif (!rg_req)\r\nreturn -ENOMEM;\r\nrg_resp = alloc_smp_resp(RG_RESP_SIZE);\r\nif (!rg_resp) {\r\nkfree(rg_req);\r\nreturn -ENOMEM;\r\n}\r\nrg_req[1] = SMP_REPORT_GENERAL;\r\nres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\r\nRG_RESP_SIZE);\r\nif (res)\r\ngoto out;\r\nif (rg_resp->result != SMP_RESP_FUNC_ACC) {\r\nres = rg_resp->result;\r\ngoto out;\r\n}\r\n*ecc = be16_to_cpu(rg_resp->rg.change_count);\r\nout:\r\nkfree(rg_resp);\r\nkfree(rg_req);\r\nreturn res;\r\n}\r\nstatic int sas_find_bcast_dev(struct domain_device *dev,\r\nstruct domain_device **src_dev)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint ex_change_count = -1;\r\nint phy_id = -1;\r\nint res;\r\nstruct domain_device *ch;\r\nres = sas_get_ex_change_count(dev, &ex_change_count);\r\nif (res)\r\ngoto out;\r\nif (ex_change_count != -1 && ex_change_count != ex->ex_change_count) {\r\nres = sas_find_bcast_phy(dev, &phy_id, 0, false);\r\nif (phy_id != -1) {\r\n*src_dev = dev;\r\nex->ex_change_count = ex_change_count;\r\nSAS_DPRINTK("Expander phy change count has changed\n");\r\nreturn res;\r\n} else\r\nSAS_DPRINTK("Expander phys DID NOT change\n");\r\n}\r\nlist_for_each_entry(ch, &ex->children, siblings) {\r\nif (ch->dev_type == EDGE_DEV || ch->dev_type == FANOUT_DEV) {\r\nres = sas_find_bcast_dev(ch, src_dev);\r\nif (*src_dev)\r\nreturn res;\r\n}\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic void sas_unregister_ex_tree(struct asd_sas_port *port, struct domain_device *dev)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct domain_device *child, *n;\r\nlist_for_each_entry_safe(child, n, &ex->children, siblings) {\r\nset_bit(SAS_DEV_GONE, &child->state);\r\nif (child->dev_type == EDGE_DEV ||\r\nchild->dev_type == FANOUT_DEV)\r\nsas_unregister_ex_tree(port, child);\r\nelse\r\nsas_unregister_dev(port, child);\r\n}\r\nsas_unregister_dev(port, dev);\r\n}\r\nstatic void sas_unregister_devs_sas_addr(struct domain_device *parent,\r\nint phy_id, bool last)\r\n{\r\nstruct expander_device *ex_dev = &parent->ex_dev;\r\nstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\r\nstruct domain_device *child, *n, *found = NULL;\r\nif (last) {\r\nlist_for_each_entry_safe(child, n,\r\n&ex_dev->children, siblings) {\r\nif (SAS_ADDR(child->sas_addr) ==\r\nSAS_ADDR(phy->attached_sas_addr)) {\r\nset_bit(SAS_DEV_GONE, &child->state);\r\nif (child->dev_type == EDGE_DEV ||\r\nchild->dev_type == FANOUT_DEV)\r\nsas_unregister_ex_tree(parent->port, child);\r\nelse\r\nsas_unregister_dev(parent->port, child);\r\nfound = child;\r\nbreak;\r\n}\r\n}\r\nsas_disable_routing(parent, phy->attached_sas_addr);\r\n}\r\nmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\r\nif (phy->port) {\r\nsas_port_delete_phy(phy->port, phy->phy);\r\nsas_device_set_phy(found, phy->port);\r\nif (phy->port->num_phys == 0)\r\nsas_port_delete(phy->port);\r\nphy->port = NULL;\r\n}\r\n}\r\nstatic int sas_discover_bfs_by_root_level(struct domain_device *root,\r\nconst int level)\r\n{\r\nstruct expander_device *ex_root = &root->ex_dev;\r\nstruct domain_device *child;\r\nint res = 0;\r\nlist_for_each_entry(child, &ex_root->children, siblings) {\r\nif (child->dev_type == EDGE_DEV ||\r\nchild->dev_type == FANOUT_DEV) {\r\nstruct sas_expander_device *ex =\r\nrphy_to_expander_device(child->rphy);\r\nif (level > ex->level)\r\nres = sas_discover_bfs_by_root_level(child,\r\nlevel);\r\nelse if (level == ex->level)\r\nres = sas_ex_discover_devices(child, -1);\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sas_discover_bfs_by_root(struct domain_device *dev)\r\n{\r\nint res;\r\nstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\r\nint level = ex->level+1;\r\nres = sas_ex_discover_devices(dev, -1);\r\nif (res)\r\ngoto out;\r\ndo {\r\nres = sas_discover_bfs_by_root_level(dev, level);\r\nmb();\r\nlevel += 1;\r\n} while (level <= dev->port->disc.max_level);\r\nout:\r\nreturn res;\r\n}\r\nstatic int sas_discover_new(struct domain_device *dev, int phy_id)\r\n{\r\nstruct ex_phy *ex_phy = &dev->ex_dev.ex_phy[phy_id];\r\nstruct domain_device *child;\r\nbool found = false;\r\nint res, i;\r\nSAS_DPRINTK("ex %016llx phy%d new device attached\n",\r\nSAS_ADDR(dev->sas_addr), phy_id);\r\nres = sas_ex_phy_discover(dev, phy_id);\r\nif (res)\r\ngoto out;\r\nfor (i = 0; i < dev->ex_dev.num_phys; i++) {\r\nstruct ex_phy *ex_phy_temp = &dev->ex_dev.ex_phy[i];\r\nif (i == phy_id)\r\ncontinue;\r\nif (SAS_ADDR(ex_phy_temp->attached_sas_addr) ==\r\nSAS_ADDR(ex_phy->attached_sas_addr)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nsas_ex_join_wide_port(dev, phy_id);\r\nreturn 0;\r\n}\r\nres = sas_ex_discover_devices(dev, phy_id);\r\nif (!res)\r\ngoto out;\r\nlist_for_each_entry(child, &dev->ex_dev.children, siblings) {\r\nif (SAS_ADDR(child->sas_addr) ==\r\nSAS_ADDR(ex_phy->attached_sas_addr)) {\r\nif (child->dev_type == EDGE_DEV ||\r\nchild->dev_type == FANOUT_DEV)\r\nres = sas_discover_bfs_by_root(child);\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn res;\r\n}\r\nstatic bool dev_type_flutter(enum sas_dev_type new, enum sas_dev_type old)\r\n{\r\nif (old == new)\r\nreturn true;\r\nif ((old == SATA_PENDING && new == SAS_END_DEV) ||\r\n(old == SAS_END_DEV && new == SATA_PENDING))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int sas_rediscover_dev(struct domain_device *dev, int phy_id, bool last)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct ex_phy *phy = &ex->ex_phy[phy_id];\r\nenum sas_dev_type type = NO_DEVICE;\r\nu8 sas_addr[8];\r\nint res;\r\nres = sas_get_phy_attached_dev(dev, phy_id, sas_addr, &type);\r\nswitch (res) {\r\ncase SMP_RESP_NO_PHY:\r\nphy->phy_state = PHY_NOT_PRESENT;\r\nsas_unregister_devs_sas_addr(dev, phy_id, last);\r\nreturn res;\r\ncase SMP_RESP_PHY_VACANT:\r\nphy->phy_state = PHY_VACANT;\r\nsas_unregister_devs_sas_addr(dev, phy_id, last);\r\nreturn res;\r\ncase SMP_RESP_FUNC_ACC:\r\nbreak;\r\n}\r\nif (SAS_ADDR(sas_addr) == 0) {\r\nphy->phy_state = PHY_EMPTY;\r\nsas_unregister_devs_sas_addr(dev, phy_id, last);\r\nreturn res;\r\n} else if (SAS_ADDR(sas_addr) == SAS_ADDR(phy->attached_sas_addr) &&\r\ndev_type_flutter(type, phy->attached_dev_type)) {\r\nstruct domain_device *ata_dev = sas_ex_to_ata(dev, phy_id);\r\nchar *action = "";\r\nsas_ex_phy_discover(dev, phy_id);\r\nif (ata_dev && phy->attached_dev_type == SATA_PENDING)\r\naction = ", needs recovery";\r\nSAS_DPRINTK("ex %016llx phy 0x%x broadcast flutter%s\n",\r\nSAS_ADDR(dev->sas_addr), phy_id, action);\r\nreturn res;\r\n}\r\nif (SAS_ADDR(phy->attached_sas_addr) &&\r\nSAS_ADDR(sas_addr) != SAS_ADDR(phy->attached_sas_addr)) {\r\nSAS_DPRINTK("ex %016llx phy 0x%x replace %016llx\n",\r\nSAS_ADDR(dev->sas_addr), phy_id,\r\nSAS_ADDR(phy->attached_sas_addr));\r\nsas_unregister_devs_sas_addr(dev, phy_id, last);\r\n}\r\nreturn sas_discover_new(dev, phy_id);\r\n}\r\nstatic int sas_rediscover(struct domain_device *dev, const int phy_id)\r\n{\r\nstruct expander_device *ex = &dev->ex_dev;\r\nstruct ex_phy *changed_phy = &ex->ex_phy[phy_id];\r\nint res = 0;\r\nint i;\r\nbool last = true;\r\nSAS_DPRINTK("ex %016llx phy%d originated BROADCAST(CHANGE)\n",\r\nSAS_ADDR(dev->sas_addr), phy_id);\r\nif (SAS_ADDR(changed_phy->attached_sas_addr) != 0) {\r\nfor (i = 0; i < ex->num_phys; i++) {\r\nstruct ex_phy *phy = &ex->ex_phy[i];\r\nif (i == phy_id)\r\ncontinue;\r\nif (SAS_ADDR(phy->attached_sas_addr) ==\r\nSAS_ADDR(changed_phy->attached_sas_addr)) {\r\nSAS_DPRINTK("phy%d part of wide port with "\r\n"phy%d\n", phy_id, i);\r\nlast = false;\r\nbreak;\r\n}\r\n}\r\nres = sas_rediscover_dev(dev, phy_id, last);\r\n} else\r\nres = sas_discover_new(dev, phy_id);\r\nreturn res;\r\n}\r\nint sas_ex_revalidate_domain(struct domain_device *port_dev)\r\n{\r\nint res;\r\nstruct domain_device *dev = NULL;\r\nres = sas_find_bcast_dev(port_dev, &dev);\r\nif (res)\r\ngoto out;\r\nif (dev) {\r\nstruct expander_device *ex = &dev->ex_dev;\r\nint i = 0, phy_id;\r\ndo {\r\nphy_id = -1;\r\nres = sas_find_bcast_phy(dev, &phy_id, i, true);\r\nif (phy_id == -1)\r\nbreak;\r\nres = sas_rediscover(dev, phy_id);\r\ni = phy_id + 1;\r\n} while (i < ex->num_phys);\r\n}\r\nout:\r\nreturn res;\r\n}\r\nint sas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,\r\nstruct request *req)\r\n{\r\nstruct domain_device *dev;\r\nint ret, type;\r\nstruct request *rsp = req->next_rq;\r\nif (!rsp) {\r\nprintk("%s: space for a smp response is missing\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (!rphy)\r\nreturn sas_smp_host_handler(shost, req, rsp);\r\ntype = rphy->identify.device_type;\r\nif (type != SAS_EDGE_EXPANDER_DEVICE &&\r\ntype != SAS_FANOUT_EXPANDER_DEVICE) {\r\nprintk("%s: can we send a smp request to a device?\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ndev = sas_find_dev_by_rphy(rphy);\r\nif (!dev) {\r\nprintk("%s: fail to find a domain_device?\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (req->bio->bi_vcnt > 1 || rsp->bio->bi_vcnt > 1) {\r\nprintk("%s: multiple segments req %u %u, rsp %u %u\n",\r\n__func__, req->bio->bi_vcnt, blk_rq_bytes(req),\r\nrsp->bio->bi_vcnt, blk_rq_bytes(rsp));\r\nreturn -EINVAL;\r\n}\r\nret = smp_execute_task(dev, bio_data(req->bio), blk_rq_bytes(req),\r\nbio_data(rsp->bio), blk_rq_bytes(rsp));\r\nif (ret > 0) {\r\nrsp->resid_len = ret;\r\nreq->resid_len = 0;\r\nret = 0;\r\n} else if (ret == 0) {\r\nrsp->resid_len = 0;\r\nreq->resid_len = 0;\r\n}\r\nreturn ret;\r\n}
