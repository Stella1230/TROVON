static int\r\nmpc52xx_pci_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 *val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nu32 value;\r\nif (ppc_md.pci_exclude_device)\r\nif (ppc_md.pci_exclude_device(hose, bus->number, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nout_be32(hose->cfg_addr,\r\n(1 << 31) |\r\n(bus->number << 16) |\r\n(devfn << 8) |\r\n(offset & 0xfc));\r\nmb();\r\n#if defined(CONFIG_PPC_MPC5200_BUGFIX)\r\nif (bus->number) {\r\nswitch (len) {\r\ncase 1:\r\nvalue = in_8(((u8 __iomem *)hose->cfg_data) +\r\n(offset & 3));\r\nbreak;\r\ncase 2:\r\nvalue = in_le16(((u16 __iomem *)hose->cfg_data) +\r\n((offset>>1) & 1));\r\nbreak;\r\ndefault:\r\nvalue = in_le16((u16 __iomem *)hose->cfg_data) |\r\n(in_le16(((u16 __iomem *)hose->cfg_data) + 1) << 16);\r\nbreak;\r\n}\r\n}\r\nelse\r\n#endif\r\n{\r\nvalue = in_le32(hose->cfg_data);\r\nif (len != 4) {\r\nvalue >>= ((offset & 0x3) << 3);\r\nvalue &= 0xffffffff >> (32 - (len << 3));\r\n}\r\n}\r\n*val = value;\r\nout_be32(hose->cfg_addr, 0);\r\nmb();\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nmpc52xx_pci_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nu32 value, mask;\r\nif (ppc_md.pci_exclude_device)\r\nif (ppc_md.pci_exclude_device(hose, bus->number, devfn))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nout_be32(hose->cfg_addr,\r\n(1 << 31) |\r\n(bus->number << 16) |\r\n(devfn << 8) |\r\n(offset & 0xfc));\r\nmb();\r\n#if defined(CONFIG_PPC_MPC5200_BUGFIX)\r\nif (bus->number) {\r\nswitch (len) {\r\ncase 1:\r\nout_8(((u8 __iomem *)hose->cfg_data) +\r\n(offset & 3), val);\r\nbreak;\r\ncase 2:\r\nout_le16(((u16 __iomem *)hose->cfg_data) +\r\n((offset>>1) & 1), val);\r\nbreak;\r\ndefault:\r\nout_le16((u16 __iomem *)hose->cfg_data,\r\n(u16)val);\r\nout_le16(((u16 __iomem *)hose->cfg_data) + 1,\r\n(u16)(val>>16));\r\nbreak;\r\n}\r\n}\r\nelse\r\n#endif\r\n{\r\nif (len != 4) {\r\nvalue = in_le32(hose->cfg_data);\r\noffset = (offset & 0x3) << 3;\r\nmask = (0xffffffff >> (32 - (len << 3)));\r\nmask <<= offset;\r\nvalue &= ~mask;\r\nval = value | ((val << offset) & mask);\r\n}\r\nout_le32(hose->cfg_data, val);\r\n}\r\nmb();\r\nout_be32(hose->cfg_addr, 0);\r\nmb();\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void __init\r\nmpc52xx_pci_setup(struct pci_controller *hose,\r\nstruct mpc52xx_pci __iomem *pci_regs, phys_addr_t pci_phys)\r\n{\r\nstruct resource *res;\r\nu32 tmp;\r\nint iwcr0 = 0, iwcr1 = 0, iwcr2 = 0;\r\npr_debug("mpc52xx_pci_setup(hose=%p, pci_regs=%p)\n", hose, pci_regs);\r\nhose->cfg_addr = &pci_regs->car;\r\nhose->cfg_data = hose->io_base_virt;\r\ntmp = in_be32(&pci_regs->scr);\r\ntmp |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\r\nout_be32(&pci_regs->scr, tmp);\r\nres = &hose->mem_resources[0];\r\nif (res->flags) {\r\npr_debug("mem_resource[0] = "\r\n"{.start=%llx, .end=%llx, .flags=%llx}\n",\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned long long)res->flags);\r\nout_be32(&pci_regs->iw0btar,\r\nMPC52xx_PCI_IWBTAR_TRANSLATION(res->start, res->start,\r\nresource_size(res)));\r\niwcr0 = MPC52xx_PCI_IWCR_ENABLE | MPC52xx_PCI_IWCR_MEM;\r\nif (res->flags & IORESOURCE_PREFETCH)\r\niwcr0 |= MPC52xx_PCI_IWCR_READ_MULTI;\r\nelse\r\niwcr0 |= MPC52xx_PCI_IWCR_READ;\r\n}\r\nres = &hose->mem_resources[1];\r\nif (res->flags) {\r\npr_debug("mem_resource[1] = {.start=%x, .end=%x, .flags=%lx}\n",\r\nres->start, res->end, res->flags);\r\nout_be32(&pci_regs->iw1btar,\r\nMPC52xx_PCI_IWBTAR_TRANSLATION(res->start, res->start,\r\nresource_size(res)));\r\niwcr1 = MPC52xx_PCI_IWCR_ENABLE | MPC52xx_PCI_IWCR_MEM;\r\nif (res->flags & IORESOURCE_PREFETCH)\r\niwcr1 |= MPC52xx_PCI_IWCR_READ_MULTI;\r\nelse\r\niwcr1 |= MPC52xx_PCI_IWCR_READ;\r\n}\r\nres = &hose->io_resource;\r\nif (!res) {\r\nprintk(KERN_ERR "%s: Didn't find IO resources\n", __FILE__);\r\nreturn;\r\n}\r\npr_debug(".io_resource={.start=%llx,.end=%llx,.flags=%llx} "\r\n".io_base_phys=0x%p\n",\r\n(unsigned long long)res->start,\r\n(unsigned long long)res->end,\r\n(unsigned long long)res->flags, (void*)hose->io_base_phys);\r\nout_be32(&pci_regs->iw2btar,\r\nMPC52xx_PCI_IWBTAR_TRANSLATION(hose->io_base_phys,\r\nres->start,\r\nresource_size(res)));\r\niwcr2 = MPC52xx_PCI_IWCR_ENABLE | MPC52xx_PCI_IWCR_IO;\r\nout_be32(&pci_regs->iwcr, MPC52xx_PCI_IWCR_PACK(iwcr0, iwcr1, iwcr2));\r\npci_phys &= 0xfffc0000;\r\nout_be32(&pci_regs->tbatr0, MPC52xx_PCI_TBATR_ENABLE | pci_phys);\r\nout_be32(&pci_regs->bar0, PCI_BASE_ADDRESS_MEM_PREFETCH | pci_phys);\r\nout_be32(&pci_regs->tbatr1, MPC52xx_PCI_TBATR_ENABLE);\r\nout_be32(&pci_regs->bar1, PCI_BASE_ADDRESS_MEM_PREFETCH);\r\nout_be32(&pci_regs->tcr, MPC52xx_PCI_TCR_LD | MPC52xx_PCI_TCR_WCT8);\r\ntmp = in_be32(&pci_regs->gscr);\r\n#if 0\r\nout_be32(&pci_regs->gscr, tmp | MPC52xx_PCI_GSCR_PR);\r\nudelay(50);\r\n#endif\r\nout_be32(&pci_regs->gscr, tmp & ~MPC52xx_PCI_GSCR_PR);\r\n}\r\nstatic void\r\nmpc52xx_pci_fixup_resources(struct pci_dev *dev)\r\n{\r\nint i;\r\npr_debug("mpc52xx_pci_fixup_resources() %.4x:%.4x\n",\r\ndev->vendor, dev->device);\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nstruct resource *res = &dev->resource[i];\r\nif (res->end > res->start) {\r\nres->end -= res->start;\r\nres->start = 0;\r\nres->flags |= IORESOURCE_UNSET;\r\n}\r\n}\r\nif ( (dev->vendor == PCI_VENDOR_ID_MOTOROLA) &&\r\n( dev->device == PCI_DEVICE_ID_MOTOROLA_MPC5200\r\n|| dev->device == PCI_DEVICE_ID_MOTOROLA_MPC5200B) ) {\r\nstruct resource *res = &dev->resource[1];\r\nres->start = res->end = res->flags = 0;\r\n}\r\n}\r\nint __init\r\nmpc52xx_add_bridge(struct device_node *node)\r\n{\r\nint len;\r\nstruct mpc52xx_pci __iomem *pci_regs;\r\nstruct pci_controller *hose;\r\nconst int *bus_range;\r\nstruct resource rsrc;\r\npr_debug("Adding MPC52xx PCI host bridge %s\n", node->full_name);\r\npci_add_flags(PCI_REASSIGN_ALL_BUS);\r\nif (of_address_to_resource(node, 0, &rsrc) != 0) {\r\nprintk(KERN_ERR "Can't get %s resources\n", node->full_name);\r\nreturn -EINVAL;\r\n}\r\nbus_range = of_get_property(node, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int)) {\r\nprintk(KERN_WARNING "Can't get %s bus-range, assume bus 0\n",\r\nnode->full_name);\r\nbus_range = NULL;\r\n}\r\nppc_md.pcibios_fixup_resources = mpc52xx_pci_fixup_resources;\r\nhose = pcibios_alloc_controller(node);\r\nif (!hose)\r\nreturn -ENOMEM;\r\nhose->first_busno = bus_range ? bus_range[0] : 0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nhose->ops = &mpc52xx_pci_ops;\r\npci_regs = ioremap(rsrc.start, resource_size(&rsrc));\r\nif (!pci_regs)\r\nreturn -ENOMEM;\r\npci_process_bridge_OF_ranges(hose, node, 1);\r\nmpc52xx_pci_setup(hose, pci_regs, rsrc.start);\r\nreturn 0;\r\n}\r\nvoid __init mpc52xx_setup_pci(void)\r\n{\r\nstruct device_node *pci;\r\npci = of_find_matching_node(NULL, mpc52xx_pci_ids);\r\nif (!pci)\r\nreturn;\r\nmpc52xx_add_bridge(pci);\r\nof_node_put(pci);\r\n}
