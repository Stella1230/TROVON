static inline struct venc_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct venc_state, sd);\r\n}\r\nstatic inline u32 venc_read(struct v4l2_subdev *sd, u32 offset)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nreturn readl(venc->venc_base + offset);\r\n}\r\nstatic inline u32 venc_write(struct v4l2_subdev *sd, u32 offset, u32 val)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nwritel(val, (venc->venc_base + offset));\r\nreturn val;\r\n}\r\nstatic inline u32 venc_modify(struct v4l2_subdev *sd, u32 offset,\r\nu32 val, u32 mask)\r\n{\r\nu32 new_val = (venc_read(sd, offset) & ~mask) | (val & mask);\r\nvenc_write(sd, offset, new_val);\r\nreturn new_val;\r\n}\r\nstatic inline u32 vdaccfg_write(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nwritel(val, venc->vdaccfg_reg);\r\nval = readl(venc->vdaccfg_reg);\r\nreturn val;\r\n}\r\nstatic int venc_set_dac(struct v4l2_subdev *sd, u32 out_index)\r\n{\r\nswitch (out_index) {\r\ncase 0:\r\nv4l2_dbg(debug, 1, sd, "Setting output to Composite\n");\r\nvenc_write(sd, VENC_DACSEL, 0);\r\nbreak;\r\ncase 1:\r\nv4l2_dbg(debug, 1, sd, "Setting output to Component\n");\r\nvenc_write(sd, VENC_DACSEL, VDAC_COMPONENT);\r\nbreak;\r\ncase 2:\r\nv4l2_dbg(debug, 1, sd, "Setting output to S-video\n");\r\nvenc_write(sd, VENC_DACSEL, VDAC_S_VIDEO);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void venc_enabledigitaloutput(struct v4l2_subdev *sd, int benable)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nv4l2_dbg(debug, 2, sd, "venc_enabledigitaloutput\n");\r\nif (benable) {\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_write(sd, VENC_CVBS, 0);\r\nvenc_write(sd, VENC_LCDOUT, 0);\r\nvenc_write(sd, VENC_HSPLS, 0);\r\nvenc_write(sd, VENC_HSTART, 0);\r\nvenc_write(sd, VENC_HVALID, 0);\r\nvenc_write(sd, VENC_HINT, 0);\r\nvenc_write(sd, VENC_VSPLS, 0);\r\nvenc_write(sd, VENC_VSTART, 0);\r\nvenc_write(sd, VENC_VVALID, 0);\r\nvenc_write(sd, VENC_VINT, 0);\r\nvenc_write(sd, VENC_YCCCTL, 0);\r\nvenc_write(sd, VENC_DACSEL, 0);\r\n} else {\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_write(sd, VENC_VIDCTL, 0x141);\r\nvenc_write(sd, VENC_SYNCCTL, 0);\r\nvenc_write(sd, VENC_DCLKCTL, 0);\r\nvenc_write(sd, VENC_DRGBX1, 0x0000057C);\r\nvenc_write(sd, VENC_LCDOUT, 0);\r\nif (pdata->venc_type != VPBE_VERSION_3)\r\nvenc_write(sd, VENC_CMPNT, 0x100);\r\nvenc_write(sd, VENC_HSPLS, 0);\r\nvenc_write(sd, VENC_HINT, 0);\r\nvenc_write(sd, VENC_HSTART, 0);\r\nvenc_write(sd, VENC_HVALID, 0);\r\nvenc_write(sd, VENC_VSPLS, 0);\r\nvenc_write(sd, VENC_VINT, 0);\r\nvenc_write(sd, VENC_VSTART, 0);\r\nvenc_write(sd, VENC_VVALID, 0);\r\nvenc_write(sd, VENC_HSDLY, 0);\r\nvenc_write(sd, VENC_VSDLY, 0);\r\nvenc_write(sd, VENC_YCCCTL, 0);\r\nvenc_write(sd, VENC_VSTARTA, 0);\r\nvenc_write(sd, VENC_OSDCLK0, 1);\r\nvenc_write(sd, VENC_OSDCLK1, 2);\r\n}\r\n}\r\nstatic int venc_set_ntsc(struct v4l2_subdev *sd)\r\n{\r\nu32 val;\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nv4l2_dbg(debug, 2, sd, "venc_set_ntsc\n");\r\nvpss_enable_clock(VPSS_VENC_CLOCK_SEL, 1);\r\nif (pdata->setup_clock(VPBE_ENC_STD, V4L2_STD_525_60) < 0)\r\nreturn -EINVAL;\r\nvenc_enabledigitaloutput(sd, 0);\r\nif (pdata->venc_type == VPBE_VERSION_3) {\r\nvenc_write(sd, VENC_CLKCTL, 0x01);\r\nvenc_write(sd, VENC_VIDCTL, 0);\r\nval = vdaccfg_write(sd, VDAC_CONFIG_SD_V3);\r\n} else if (pdata->venc_type == VPBE_VERSION_2) {\r\nvenc_write(sd, VENC_CLKCTL, 0x01);\r\nvenc_write(sd, VENC_VIDCTL, 0);\r\nvdaccfg_write(sd, VDAC_CONFIG_SD_V2);\r\n} else {\r\nvenc_modify(sd, VENC_VIDCTL, 0, 1 << 1);\r\nvenc_write(sd, VENC_YCCCTL, 0x1);\r\nvenc_modify(sd, VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);\r\nvenc_modify(sd, VENC_VDPRO, 0, VENC_VDPRO_DAUPS);\r\n}\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_modify(sd, VENC_VMOD, (1 << VENC_VMOD_VIE_SHIFT),\r\nVENC_VMOD_VIE);\r\nvenc_modify(sd, VENC_VMOD, (0 << VENC_VMOD_VMD), VENC_VMOD_VMD);\r\nvenc_modify(sd, VENC_VMOD, (0 << VENC_VMOD_TVTYP_SHIFT),\r\nVENC_VMOD_TVTYP);\r\nvenc_write(sd, VENC_DACTST, 0x0);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);\r\nreturn 0;\r\n}\r\nstatic int venc_set_pal(struct v4l2_subdev *sd)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nv4l2_dbg(debug, 2, sd, "venc_set_pal\n");\r\nvpss_enable_clock(VPSS_VENC_CLOCK_SEL, 1);\r\nif (venc->pdata->setup_clock(VPBE_ENC_STD, V4L2_STD_625_50) < 0)\r\nreturn -EINVAL;\r\nvenc_enabledigitaloutput(sd, 0);\r\nif (pdata->venc_type == VPBE_VERSION_3) {\r\nvenc_write(sd, VENC_CLKCTL, 0x1);\r\nvenc_write(sd, VENC_VIDCTL, 0);\r\nvdaccfg_write(sd, VDAC_CONFIG_SD_V3);\r\n} else if (pdata->venc_type == VPBE_VERSION_2) {\r\nvenc_write(sd, VENC_CLKCTL, 0x1);\r\nvenc_write(sd, VENC_VIDCTL, 0);\r\nvdaccfg_write(sd, VDAC_CONFIG_SD_V2);\r\n} else {\r\nvenc_modify(sd, VENC_VIDCTL, 0, 1 << 1);\r\nvenc_write(sd, VENC_YCCCTL, 0x1);\r\n}\r\nvenc_modify(sd, VENC_SYNCCTL, 1 << VENC_SYNCCTL_OVD_SHIFT,\r\nVENC_SYNCCTL_OVD);\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_modify(sd, VENC_VMOD,\r\n(1 << VENC_VMOD_VIE_SHIFT),\r\nVENC_VMOD_VIE);\r\nvenc_modify(sd, VENC_VMOD,\r\n(0 << VENC_VMOD_VMD), VENC_VMOD_VMD);\r\nvenc_modify(sd, VENC_VMOD,\r\n(1 << VENC_VMOD_TVTYP_SHIFT),\r\nVENC_VMOD_TVTYP);\r\nvenc_write(sd, VENC_DACTST, 0x0);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);\r\nreturn 0;\r\n}\r\nstatic int venc_set_480p59_94(struct v4l2_subdev *sd)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nv4l2_dbg(debug, 2, sd, "venc_set_480p59_94\n");\r\nif ((pdata->venc_type != VPBE_VERSION_1) &&\r\n(pdata->venc_type != VPBE_VERSION_2))\r\nreturn -EINVAL;\r\nif (pdata->setup_clock(VPBE_ENC_DV_PRESET, V4L2_DV_480P59_94) < 0)\r\nreturn -EINVAL;\r\nvenc_enabledigitaloutput(sd, 0);\r\nif (pdata->venc_type == VPBE_VERSION_2)\r\nvdaccfg_write(sd, VDAC_CONFIG_HD_V2);\r\nvenc_write(sd, VENC_OSDCLK0, 0);\r\nvenc_write(sd, VENC_OSDCLK1, 1);\r\nif (pdata->venc_type == VPBE_VERSION_1) {\r\nvenc_modify(sd, VENC_VDPRO, VENC_VDPRO_DAFRQ,\r\nVENC_VDPRO_DAFRQ);\r\nvenc_modify(sd, VENC_VDPRO, VENC_VDPRO_DAUPS,\r\nVENC_VDPRO_DAUPS);\r\n}\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_modify(sd, VENC_VMOD, (1 << VENC_VMOD_VIE_SHIFT),\r\nVENC_VMOD_VIE);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_HDMD, VENC_VMOD_HDMD);\r\nvenc_modify(sd, VENC_VMOD, (HDTV_525P << VENC_VMOD_TVTYP_SHIFT),\r\nVENC_VMOD_TVTYP);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VDMD_YCBCR8 <<\r\nVENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);\r\nreturn 0;\r\n}\r\nstatic int venc_set_576p50(struct v4l2_subdev *sd)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nv4l2_dbg(debug, 2, sd, "venc_set_576p50\n");\r\nif ((pdata->venc_type != VPBE_VERSION_1) &&\r\n(pdata->venc_type != VPBE_VERSION_2))\r\nreturn -EINVAL;\r\nif (pdata->setup_clock(VPBE_ENC_DV_PRESET, V4L2_DV_576P50) < 0)\r\nreturn -EINVAL;\r\nvenc_enabledigitaloutput(sd, 0);\r\nif (pdata->venc_type == VPBE_VERSION_2)\r\nvdaccfg_write(sd, VDAC_CONFIG_HD_V2);\r\nvenc_write(sd, VENC_OSDCLK0, 0);\r\nvenc_write(sd, VENC_OSDCLK1, 1);\r\nif (pdata->venc_type == VPBE_VERSION_1) {\r\nvenc_modify(sd, VENC_VDPRO, VENC_VDPRO_DAFRQ,\r\nVENC_VDPRO_DAFRQ);\r\nvenc_modify(sd, VENC_VDPRO, VENC_VDPRO_DAUPS,\r\nVENC_VDPRO_DAUPS);\r\n}\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_modify(sd, VENC_VMOD, (1 << VENC_VMOD_VIE_SHIFT),\r\nVENC_VMOD_VIE);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_HDMD, VENC_VMOD_HDMD);\r\nvenc_modify(sd, VENC_VMOD, (HDTV_625P << VENC_VMOD_TVTYP_SHIFT),\r\nVENC_VMOD_TVTYP);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VDMD_YCBCR8 <<\r\nVENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);\r\nreturn 0;\r\n}\r\nstatic int venc_set_720p60_internal(struct v4l2_subdev *sd)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nif (pdata->setup_clock(VPBE_ENC_DV_PRESET, V4L2_DV_720P60) < 0)\r\nreturn -EINVAL;\r\nvenc_enabledigitaloutput(sd, 0);\r\nvenc_write(sd, VENC_OSDCLK0, 0);\r\nvenc_write(sd, VENC_OSDCLK1, 1);\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_modify(sd, VENC_VMOD, (1 << VENC_VMOD_VIE_SHIFT),\r\nVENC_VMOD_VIE);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_HDMD, VENC_VMOD_HDMD);\r\nvenc_modify(sd, VENC_VMOD, (HDTV_720P << VENC_VMOD_TVTYP_SHIFT),\r\nVENC_VMOD_TVTYP);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);\r\nvenc_write(sd, VENC_XHINTVL, 0);\r\nreturn 0;\r\n}\r\nstatic int venc_set_1080i30_internal(struct v4l2_subdev *sd)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nstruct venc_platform_data *pdata = venc->pdata;\r\nif (pdata->setup_clock(VPBE_ENC_DV_PRESET, V4L2_DV_1080P30) < 0)\r\nreturn -EINVAL;\r\nvenc_enabledigitaloutput(sd, 0);\r\nvenc_write(sd, VENC_OSDCLK0, 0);\r\nvenc_write(sd, VENC_OSDCLK1, 1);\r\nvenc_write(sd, VENC_VMOD, 0);\r\nvenc_modify(sd, VENC_VMOD, (1 << VENC_VMOD_VIE_SHIFT),\r\nVENC_VMOD_VIE);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_HDMD, VENC_VMOD_HDMD);\r\nvenc_modify(sd, VENC_VMOD, (HDTV_1080I << VENC_VMOD_TVTYP_SHIFT),\r\nVENC_VMOD_TVTYP);\r\nvenc_modify(sd, VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);\r\nvenc_write(sd, VENC_XHINTVL, 0);\r\nreturn 0;\r\n}\r\nstatic int venc_s_std_output(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nv4l2_dbg(debug, 1, sd, "venc_s_std_output\n");\r\nif (norm & V4L2_STD_525_60)\r\nreturn venc_set_ntsc(sd);\r\nelse if (norm & V4L2_STD_625_50)\r\nreturn venc_set_pal(sd);\r\nreturn -EINVAL;\r\n}\r\nstatic int venc_s_dv_preset(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_preset *dv_preset)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nint ret;\r\nv4l2_dbg(debug, 1, sd, "venc_s_dv_preset\n");\r\nif (dv_preset->preset == V4L2_DV_576P50)\r\nreturn venc_set_576p50(sd);\r\nelse if (dv_preset->preset == V4L2_DV_480P59_94)\r\nreturn venc_set_480p59_94(sd);\r\nelse if ((dv_preset->preset == V4L2_DV_720P60) &&\r\n(venc->pdata->venc_type == VPBE_VERSION_2)) {\r\nret = venc_set_720p60_internal(sd);\r\nvdaccfg_write(sd, VDAC_CONFIG_HD_V2);\r\nreturn ret;\r\n} else if ((dv_preset->preset == V4L2_DV_1080I30) &&\r\n(venc->pdata->venc_type == VPBE_VERSION_2)) {\r\nret = venc_set_1080i30_internal(sd);\r\nvdaccfg_write(sd, VDAC_CONFIG_HD_V2);\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int venc_s_routing(struct v4l2_subdev *sd, u32 input, u32 output,\r\nu32 config)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nint ret;\r\nv4l2_dbg(debug, 1, sd, "venc_s_routing\n");\r\nret = venc_set_dac(sd, output);\r\nif (!ret)\r\nvenc->output = output;\r\nreturn ret;\r\n}\r\nstatic long venc_ioctl(struct v4l2_subdev *sd,\r\nunsigned int cmd,\r\nvoid *arg)\r\n{\r\nu32 val;\r\nswitch (cmd) {\r\ncase VENC_GET_FLD:\r\nval = venc_read(sd, VENC_VSTAT);\r\n*((int *)arg) = ((val & VENC_VSTAT_FIDST) ==\r\nVENC_VSTAT_FIDST);\r\nbreak;\r\ndefault:\r\nv4l2_err(sd, "Wrong IOCTL cmd\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int venc_initialize(struct v4l2_subdev *sd)\r\n{\r\nstruct venc_state *venc = to_state(sd);\r\nint ret;\r\nvenc->output = 0;\r\nvenc->std = V4L2_STD_525_60;\r\nret = venc_s_routing(sd, 0, venc->output, 0);\r\nif (ret < 0) {\r\nv4l2_err(sd, "Error setting output during init\n");\r\nreturn -EINVAL;\r\n}\r\nret = venc_s_std_output(sd, venc->std);\r\nif (ret < 0) {\r\nv4l2_err(sd, "Error setting std during init\n");\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int venc_device_get(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct venc_state **venc = data;\r\nif (strcmp(MODULE_NAME, pdev->name) == 0)\r\n*venc = platform_get_drvdata(pdev);\r\nreturn 0;\r\n}\r\nstruct v4l2_subdev *venc_sub_dev_init(struct v4l2_device *v4l2_dev,\r\nconst char *venc_name)\r\n{\r\nstruct venc_state *venc;\r\nint err;\r\nerr = bus_for_each_dev(&platform_bus_type, NULL, &venc,\r\nvenc_device_get);\r\nif (venc == NULL)\r\nreturn NULL;\r\nv4l2_subdev_init(&venc->sd, &venc_ops);\r\nstrcpy(venc->sd.name, venc_name);\r\nif (v4l2_device_register_subdev(v4l2_dev, &venc->sd) < 0) {\r\nv4l2_err(v4l2_dev,\r\n"vpbe unable to register venc sub device\n");\r\nreturn NULL;\r\n}\r\nif (venc_initialize(&venc->sd)) {\r\nv4l2_err(v4l2_dev,\r\n"vpbe venc initialization failed\n");\r\nreturn NULL;\r\n}\r\nreturn &venc->sd;\r\n}\r\nstatic int venc_probe(struct platform_device *pdev)\r\n{\r\nstruct venc_state *venc;\r\nstruct resource *res;\r\nint ret;\r\nvenc = kzalloc(sizeof(struct venc_state), GFP_KERNEL);\r\nif (venc == NULL)\r\nreturn -ENOMEM;\r\nvenc->pdev = &pdev->dev;\r\nvenc->pdata = pdev->dev.platform_data;\r\nif (NULL == venc->pdata) {\r\ndev_err(venc->pdev, "Unable to get platform data for"\r\n" VENC sub device");\r\nret = -ENOENT;\r\ngoto free_mem;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(venc->pdev,\r\n"Unable to get VENC register address map\n");\r\nret = -ENODEV;\r\ngoto free_mem;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), "venc")) {\r\ndev_err(venc->pdev, "Unable to reserve VENC MMIO region\n");\r\nret = -ENODEV;\r\ngoto free_mem;\r\n}\r\nvenc->venc_base = ioremap_nocache(res->start, resource_size(res));\r\nif (!venc->venc_base) {\r\ndev_err(venc->pdev, "Unable to map VENC IO space\n");\r\nret = -ENODEV;\r\ngoto release_venc_mem_region;\r\n}\r\nif (venc->pdata->venc_type != VPBE_VERSION_1) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(venc->pdev,\r\n"Unable to get VDAC_CONFIG address map\n");\r\nret = -ENODEV;\r\ngoto unmap_venc_io;\r\n}\r\nif (!request_mem_region(res->start,\r\nresource_size(res), "venc")) {\r\ndev_err(venc->pdev,\r\n"Unable to reserve VDAC_CONFIG MMIO region\n");\r\nret = -ENODEV;\r\ngoto unmap_venc_io;\r\n}\r\nvenc->vdaccfg_reg = ioremap_nocache(res->start,\r\nresource_size(res));\r\nif (!venc->vdaccfg_reg) {\r\ndev_err(venc->pdev,\r\n"Unable to map VDAC_CONFIG IO space\n");\r\nret = -ENODEV;\r\ngoto release_vdaccfg_mem_region;\r\n}\r\n}\r\nspin_lock_init(&venc->lock);\r\nplatform_set_drvdata(pdev, venc);\r\ndev_notice(venc->pdev, "VENC sub device probe success\n");\r\nreturn 0;\r\nrelease_vdaccfg_mem_region:\r\nrelease_mem_region(res->start, resource_size(res));\r\nunmap_venc_io:\r\niounmap(venc->venc_base);\r\nrelease_venc_mem_region:\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nfree_mem:\r\nkfree(venc);\r\nreturn ret;\r\n}\r\nstatic int venc_remove(struct platform_device *pdev)\r\n{\r\nstruct venc_state *venc = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\niounmap((void *)venc->venc_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nif (venc->pdata->venc_type != VPBE_VERSION_1) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\niounmap((void *)venc->vdaccfg_reg);\r\nrelease_mem_region(res->start, resource_size(res));\r\n}\r\nkfree(venc);\r\nreturn 0;\r\n}
