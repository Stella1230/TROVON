static inline u8 celleb_fake_config_readb(void *addr)\r\n{\r\nu8 *p = addr;\r\nreturn *p;\r\n}\r\nstatic inline u16 celleb_fake_config_readw(void *addr)\r\n{\r\n__le16 *p = addr;\r\nreturn le16_to_cpu(*p);\r\n}\r\nstatic inline u32 celleb_fake_config_readl(void *addr)\r\n{\r\n__le32 *p = addr;\r\nreturn le32_to_cpu(*p);\r\n}\r\nstatic inline void celleb_fake_config_writeb(u32 val, void *addr)\r\n{\r\nu8 *p = addr;\r\n*p = val;\r\n}\r\nstatic inline void celleb_fake_config_writew(u32 val, void *addr)\r\n{\r\n__le16 val16;\r\n__le16 *p = addr;\r\nval16 = cpu_to_le16(val);\r\n*p = val16;\r\n}\r\nstatic inline void celleb_fake_config_writel(u32 val, void *addr)\r\n{\r\n__le32 val32;\r\n__le32 *p = addr;\r\nval32 = cpu_to_le32(val);\r\n*p = val32;\r\n}\r\nstatic unsigned char *get_fake_config_start(struct pci_controller *hose,\r\nint devno, int fn)\r\n{\r\nstruct celleb_pci_private *private = hose->private_data;\r\nif (private == NULL)\r\nreturn NULL;\r\nreturn private->fake_config[devno][fn];\r\n}\r\nstatic struct celleb_pci_resource *get_resource_start(\r\nstruct pci_controller *hose,\r\nint devno, int fn)\r\n{\r\nstruct celleb_pci_private *private = hose->private_data;\r\nif (private == NULL)\r\nreturn NULL;\r\nreturn private->res[devno][fn];\r\n}\r\nstatic void celleb_config_read_fake(unsigned char *config, int where,\r\nint size, u32 *val)\r\n{\r\nchar *p = config + where;\r\nswitch (size) {\r\ncase 1:\r\n*val = celleb_fake_config_readb(p);\r\nbreak;\r\ncase 2:\r\n*val = celleb_fake_config_readw(p);\r\nbreak;\r\ncase 4:\r\n*val = celleb_fake_config_readl(p);\r\nbreak;\r\n}\r\n}\r\nstatic void celleb_config_write_fake(unsigned char *config, int where,\r\nint size, u32 val)\r\n{\r\nchar *p = config + where;\r\nswitch (size) {\r\ncase 1:\r\ncelleb_fake_config_writeb(val, p);\r\nbreak;\r\ncase 2:\r\ncelleb_fake_config_writew(val, p);\r\nbreak;\r\ncase 4:\r\ncelleb_fake_config_writel(val, p);\r\nbreak;\r\n}\r\n}\r\nstatic int celleb_fake_pci_read_config(struct pci_bus *bus,\r\nunsigned int devfn, int where, int size, u32 *val)\r\n{\r\nchar *config;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nunsigned int devno = devfn >> 3;\r\nunsigned int fn = devfn & 0x7;\r\nBUG_ON(where % size);\r\npr_debug(" fake read: bus=0x%x, ", bus->number);\r\nconfig = get_fake_config_start(hose, devno, fn);\r\npr_debug("devno=0x%x, where=0x%x, size=0x%x, ", devno, where, size);\r\nif (!config) {\r\npr_debug("failed\n");\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\ncelleb_config_read_fake(config, where, size, val);\r\npr_debug("val=0x%x\n", *val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int celleb_fake_pci_write_config(struct pci_bus *bus,\r\nunsigned int devfn, int where, int size, u32 val)\r\n{\r\nchar *config;\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct celleb_pci_resource *res;\r\nunsigned int devno = devfn >> 3;\r\nunsigned int fn = devfn & 0x7;\r\nBUG_ON(where % size);\r\nconfig = get_fake_config_start(hose, devno, fn);\r\nif (!config)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (val == ~0) {\r\nint i = (where - PCI_BASE_ADDRESS_0) >> 3;\r\nswitch (where) {\r\ncase PCI_BASE_ADDRESS_0:\r\ncase PCI_BASE_ADDRESS_2:\r\nif (size != 4)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nres = get_resource_start(hose, devno, fn);\r\nif (!res)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\ncelleb_config_write_fake(config, where, size,\r\n(res->r[i].end - res->r[i].start));\r\nreturn PCIBIOS_SUCCESSFUL;\r\ncase PCI_BASE_ADDRESS_1:\r\ncase PCI_BASE_ADDRESS_3:\r\ncase PCI_BASE_ADDRESS_4:\r\ncase PCI_BASE_ADDRESS_5:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ncelleb_config_write_fake(config, where, size, val);\r\npr_debug(" fake write: where=%x, size=%d, val=%x\n",\r\nwhere, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic inline void celleb_setup_pci_base_addrs(struct pci_controller *hose,\r\nunsigned int devno, unsigned int fn,\r\nunsigned int num_base_addr)\r\n{\r\nu32 val;\r\nunsigned char *config;\r\nstruct celleb_pci_resource *res;\r\nconfig = get_fake_config_start(hose, devno, fn);\r\nres = get_resource_start(hose, devno, fn);\r\nif (!config || !res)\r\nreturn;\r\nswitch (num_base_addr) {\r\ncase 3:\r\nval = (res->r[2].start & 0xfffffff0)\r\n| PCI_BASE_ADDRESS_MEM_TYPE_64;\r\ncelleb_config_write_fake(config, PCI_BASE_ADDRESS_4, 4, val);\r\nval = res->r[2].start >> 32;\r\ncelleb_config_write_fake(config, PCI_BASE_ADDRESS_5, 4, val);\r\ncase 2:\r\nval = (res->r[1].start & 0xfffffff0)\r\n| PCI_BASE_ADDRESS_MEM_TYPE_64;\r\ncelleb_config_write_fake(config, PCI_BASE_ADDRESS_2, 4, val);\r\nval = res->r[1].start >> 32;\r\ncelleb_config_write_fake(config, PCI_BASE_ADDRESS_3, 4, val);\r\ncase 1:\r\nval = (res->r[0].start & 0xfffffff0)\r\n| PCI_BASE_ADDRESS_MEM_TYPE_64;\r\ncelleb_config_write_fake(config, PCI_BASE_ADDRESS_0, 4, val);\r\nval = res->r[0].start >> 32;\r\ncelleb_config_write_fake(config, PCI_BASE_ADDRESS_1, 4, val);\r\nbreak;\r\n}\r\nval = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\r\ncelleb_config_write_fake(config, PCI_COMMAND, 2, val);\r\n}\r\nstatic int __init celleb_setup_fake_pci_device(struct device_node *node,\r\nstruct pci_controller *hose)\r\n{\r\nunsigned int rlen;\r\nint num_base_addr = 0;\r\nu32 val;\r\nconst u32 *wi0, *wi1, *wi2, *wi3, *wi4;\r\nunsigned int devno, fn;\r\nstruct celleb_pci_private *private = hose->private_data;\r\nunsigned char **config = NULL;\r\nstruct celleb_pci_resource **res = NULL;\r\nconst char *name;\r\nconst unsigned long *li;\r\nint size, result;\r\nif (private == NULL) {\r\nprintk(KERN_ERR "PCI: "\r\n"memory space for pci controller is not assigned\n");\r\ngoto error;\r\n}\r\nname = of_get_property(node, "model", &rlen);\r\nif (!name) {\r\nprintk(KERN_ERR "PCI: model property not found.\n");\r\ngoto error;\r\n}\r\nwi4 = of_get_property(node, "reg", &rlen);\r\nif (wi4 == NULL)\r\ngoto error;\r\ndevno = ((wi4[0] >> 8) & 0xff) >> 3;\r\nfn = (wi4[0] >> 8) & 0x7;\r\npr_debug("PCI: celleb_setup_fake_pci() %s devno=%x fn=%x\n", name,\r\ndevno, fn);\r\nsize = 256;\r\nconfig = &private->fake_config[devno][fn];\r\n*config = zalloc_maybe_bootmem(size, GFP_KERNEL);\r\nif (*config == NULL) {\r\nprintk(KERN_ERR "PCI: "\r\n"not enough memory for fake configuration space\n");\r\ngoto error;\r\n}\r\npr_debug("PCI: fake config area assigned 0x%016lx\n",\r\n(unsigned long)*config);\r\nsize = sizeof(struct celleb_pci_resource);\r\nres = &private->res[devno][fn];\r\n*res = zalloc_maybe_bootmem(size, GFP_KERNEL);\r\nif (*res == NULL) {\r\nprintk(KERN_ERR\r\n"PCI: not enough memory for resource data space\n");\r\ngoto error;\r\n}\r\npr_debug("PCI: res assigned 0x%016lx\n", (unsigned long)*res);\r\nwi0 = of_get_property(node, "device-id", NULL);\r\nwi1 = of_get_property(node, "vendor-id", NULL);\r\nwi2 = of_get_property(node, "class-code", NULL);\r\nwi3 = of_get_property(node, "revision-id", NULL);\r\nif (!wi0 || !wi1 || !wi2 || !wi3) {\r\nprintk(KERN_ERR "PCI: Missing device tree properties.\n");\r\ngoto error;\r\n}\r\ncelleb_config_write_fake(*config, PCI_DEVICE_ID, 2, wi0[0] & 0xffff);\r\ncelleb_config_write_fake(*config, PCI_VENDOR_ID, 2, wi1[0] & 0xffff);\r\npr_debug("class-code = 0x%08x\n", wi2[0]);\r\ncelleb_config_write_fake(*config, PCI_CLASS_PROG, 1, wi2[0] & 0xff);\r\ncelleb_config_write_fake(*config, PCI_CLASS_DEVICE, 2,\r\n(wi2[0] >> 8) & 0xffff);\r\ncelleb_config_write_fake(*config, PCI_REVISION_ID, 1, wi3[0]);\r\nwhile (num_base_addr < MAX_PCI_BASE_ADDRS) {\r\nresult = of_address_to_resource(node,\r\nnum_base_addr, &(*res)->r[num_base_addr]);\r\nif (result)\r\nbreak;\r\nnum_base_addr++;\r\n}\r\ncelleb_setup_pci_base_addrs(hose, devno, fn, num_base_addr);\r\nli = of_get_property(node, "interrupts", &rlen);\r\nif (!li) {\r\nprintk(KERN_ERR "PCI: interrupts not found.\n");\r\ngoto error;\r\n}\r\nval = li[0];\r\ncelleb_config_write_fake(*config, PCI_INTERRUPT_PIN, 1, 1);\r\ncelleb_config_write_fake(*config, PCI_INTERRUPT_LINE, 1, val);\r\n#ifdef DEBUG\r\npr_debug("PCI: %s irq=%ld\n", name, li[0]);\r\nfor (i = 0; i < 6; i++) {\r\ncelleb_config_read_fake(*config,\r\nPCI_BASE_ADDRESS_0 + 0x4 * i, 4,\r\n&val);\r\npr_debug("PCI: %s fn=%d base_address_%d=0x%x\n",\r\nname, fn, i, val);\r\n}\r\n#endif\r\ncelleb_config_write_fake(*config, PCI_HEADER_TYPE, 1,\r\nPCI_HEADER_TYPE_NORMAL);\r\nreturn 0;\r\nerror:\r\nif (mem_init_done) {\r\nif (config && *config)\r\nkfree(*config);\r\nif (res && *res)\r\nkfree(*res);\r\n} else {\r\nif (config && *config) {\r\nsize = 256;\r\nfree_bootmem((unsigned long)(*config), size);\r\n}\r\nif (res && *res) {\r\nsize = sizeof(struct celleb_pci_resource);\r\nfree_bootmem((unsigned long)(*res), size);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init phb_set_bus_ranges(struct device_node *dev,\r\nstruct pci_controller *phb)\r\n{\r\nconst int *bus_range;\r\nunsigned int len;\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int))\r\nreturn 1;\r\nphb->first_busno = bus_range[0];\r\nphb->last_busno = bus_range[1];\r\nreturn 0;\r\n}\r\nstatic void __init celleb_alloc_private_mem(struct pci_controller *hose)\r\n{\r\nhose->private_data =\r\nzalloc_maybe_bootmem(sizeof(struct celleb_pci_private),\r\nGFP_KERNEL);\r\n}\r\nstatic int __init celleb_setup_fake_pci(struct device_node *dev,\r\nstruct pci_controller *phb)\r\n{\r\nstruct device_node *node;\r\nphb->ops = &celleb_fake_pci_ops;\r\ncelleb_alloc_private_mem(phb);\r\nfor (node = of_get_next_child(dev, NULL);\r\nnode != NULL; node = of_get_next_child(dev, node))\r\ncelleb_setup_fake_pci_device(node, phb);\r\nreturn 0;\r\n}\r\nint __init celleb_setup_phb(struct pci_controller *phb)\r\n{\r\nstruct device_node *dev = phb->dn;\r\nconst struct of_device_id *match;\r\nstruct celleb_phb_spec *phb_spec;\r\nint rc;\r\nmatch = of_match_node(celleb_phb_match, dev);\r\nif (!match)\r\nreturn 1;\r\nphb_set_bus_ranges(dev, phb);\r\nphb->buid = 1;\r\nphb_spec = match->data;\r\nrc = (*phb_spec->setup)(dev, phb);\r\nif (rc)\r\nreturn 1;\r\nif (phb_spec->ops)\r\niowa_register_bus(phb, phb_spec->ops,\r\nphb_spec->iowa_init,\r\nphb_spec->iowa_data);\r\nreturn 0;\r\n}\r\nint celleb_pci_probe_mode(struct pci_bus *bus)\r\n{\r\nreturn PCI_PROBE_DEVTREE;\r\n}
