struct ch7006_mode *ch7006_lookup_mode(struct drm_encoder *encoder,\r\nstruct drm_display_mode *drm_mode)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_mode *mode;\r\nfor (mode = ch7006_modes; mode->mode.clock; mode++) {\r\nif (~mode->valid_norms & 1<<priv->norm)\r\ncontinue;\r\nif (mode->mode.hdisplay != drm_mode->hdisplay ||\r\nmode->mode.vdisplay != drm_mode->vdisplay ||\r\nmode->mode.vtotal != drm_mode->vtotal ||\r\nmode->mode.htotal != drm_mode->htotal ||\r\nmode->mode.clock != drm_mode->clock)\r\ncontinue;\r\nreturn mode;\r\n}\r\nreturn NULL;\r\n}\r\nvoid ch7006_setup_levels(struct drm_encoder *encoder)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nuint8_t *regs = priv->state.regs;\r\nstruct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\r\nint gain;\r\nint black_level;\r\nif (norm->black_level < 339*fixed1/1000) {\r\ngain = 76;\r\nregs[CH7006_INPUT_FORMAT] |= CH7006_INPUT_FORMAT_DAC_GAIN;\r\n} else {\r\ngain = 71;\r\nregs[CH7006_INPUT_FORMAT] &= ~CH7006_INPUT_FORMAT_DAC_GAIN;\r\n}\r\nblack_level = round_fixed(norm->black_level*26625)/gain;\r\nblack_level = interpolate(90, black_level, 208, priv->brightness);\r\nregs[CH7006_BLACK_LEVEL] = bitf(CH7006_BLACK_LEVEL_0, black_level);\r\nch7006_dbg(client, "black level: %d\n", black_level);\r\n}\r\nvoid ch7006_setup_subcarrier(struct drm_encoder *encoder)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_state *state = &priv->state;\r\nstruct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\r\nstruct ch7006_mode *mode = priv->mode;\r\nuint32_t subc_inc;\r\nsubc_inc = round_fixed((mode->subc_coeff >> 8)\r\n* (norm->subc_freq >> 24));\r\nsetbitf(state, CH7006_SUBC_INC0, 28, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC1, 24, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC2, 20, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC3, 16, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC4, 12, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC5, 8, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC6, 4, subc_inc);\r\nsetbitf(state, CH7006_SUBC_INC7, 0, subc_inc);\r\nch7006_dbg(client, "subcarrier inc: %u\n", subc_inc);\r\n}\r\nvoid ch7006_setup_pll(struct drm_encoder *encoder)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nuint8_t *regs = priv->state.regs;\r\nstruct ch7006_mode *mode = priv->mode;\r\nint n, best_n = 0;\r\nint m, best_m = 0;\r\nint freq, best_freq = 0;\r\nfor (n = 0; n < CH7006_MAXN; n++) {\r\nfor (m = 0; m < CH7006_MAXM; m++) {\r\nfreq = CH7006_FREQ0*(n+2)/(m+2);\r\nif (abs(freq - mode->mode.clock) <\r\nabs(best_freq - mode->mode.clock)) {\r\nbest_freq = freq;\r\nbest_n = n;\r\nbest_m = m;\r\n}\r\n}\r\n}\r\nregs[CH7006_PLLOV] = bitf(CH7006_PLLOV_N_8, best_n) |\r\nbitf(CH7006_PLLOV_M_8, best_m);\r\nregs[CH7006_PLLM] = bitf(CH7006_PLLM_0, best_m);\r\nregs[CH7006_PLLN] = bitf(CH7006_PLLN_0, best_n);\r\nif (best_n < 108)\r\nregs[CH7006_PLL_CONTROL] |= CH7006_PLL_CONTROL_CAPACITOR;\r\nelse\r\nregs[CH7006_PLL_CONTROL] &= ~CH7006_PLL_CONTROL_CAPACITOR;\r\nch7006_dbg(client, "n=%d m=%d f=%d c=%d\n",\r\nbest_n, best_m, best_freq, best_n < 108);\r\n}\r\nvoid ch7006_setup_power_state(struct drm_encoder *encoder)\r\n{\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nuint8_t *power = &priv->state.regs[CH7006_POWER];\r\nint subconnector;\r\nsubconnector = priv->select_subconnector ? priv->select_subconnector :\r\npriv->subconnector;\r\n*power = CH7006_POWER_RESET;\r\nif (priv->last_dpms == DRM_MODE_DPMS_ON) {\r\nswitch (subconnector) {\r\ncase DRM_MODE_SUBCONNECTOR_SVIDEO:\r\n*power |= bitfs(CH7006_POWER_LEVEL, CVBS_OFF);\r\nbreak;\r\ncase DRM_MODE_SUBCONNECTOR_Composite:\r\n*power |= bitfs(CH7006_POWER_LEVEL, SVIDEO_OFF);\r\nbreak;\r\ncase DRM_MODE_SUBCONNECTOR_SCART:\r\n*power |= bitfs(CH7006_POWER_LEVEL, NORMAL) |\r\nCH7006_POWER_SCART;\r\nbreak;\r\n}\r\n} else {\r\nif (priv->chip_version >= 0x20)\r\n*power |= bitfs(CH7006_POWER_LEVEL, FULL_POWER_OFF);\r\nelse\r\n*power |= bitfs(CH7006_POWER_LEVEL, POWER_OFF);\r\n}\r\n}\r\nvoid ch7006_setup_properties(struct drm_encoder *encoder)\r\n{\r\nstruct i2c_client *client = drm_i2c_encoder_get_client(encoder);\r\nstruct ch7006_priv *priv = to_ch7006_priv(encoder);\r\nstruct ch7006_state *state = &priv->state;\r\nstruct ch7006_tv_norm_info *norm = &ch7006_tv_norms[priv->norm];\r\nstruct ch7006_mode *ch_mode = priv->mode;\r\nstruct drm_display_mode *mode = &ch_mode->mode;\r\nuint8_t *regs = state->regs;\r\nint flicker, contrast, hpos, vpos;\r\nuint64_t scale, aspect;\r\nflicker = interpolate(0, 2, 3, priv->flicker);\r\nregs[CH7006_FFILTER] = bitf(CH7006_FFILTER_TEXT, flicker) |\r\nbitf(CH7006_FFILTER_LUMA, flicker) |\r\nbitf(CH7006_FFILTER_CHROMA, 1);\r\ncontrast = interpolate(0, 5, 7, priv->contrast);\r\nregs[CH7006_CONTRAST] = bitf(CH7006_CONTRAST_0, contrast);\r\nscale = norm->vtotal*fixed1;\r\ndo_div(scale, mode->vtotal);\r\naspect = ch_mode->enc_hdisp*fixed1;\r\ndo_div(aspect, ch_mode->enc_vdisp);\r\nhpos = round_fixed((norm->hvirtual * aspect - mode->hdisplay * scale)\r\n* priv->hmargin * mode->vtotal) / norm->vtotal / 100 / 4;\r\nsetbitf(state, CH7006_POV, HPOS_8, hpos);\r\nsetbitf(state, CH7006_HPOS, 0, hpos);\r\nvpos = max(0, norm->vdisplay - round_fixed(mode->vdisplay*scale)\r\n+ norm->voffset) * priv->vmargin / 100 / 2;\r\nsetbitf(state, CH7006_POV, VPOS_8, vpos);\r\nsetbitf(state, CH7006_VPOS, 0, vpos);\r\nch7006_dbg(client, "hpos: %d, vpos: %d\n", hpos, vpos);\r\n}\r\nvoid ch7006_write(struct i2c_client *client, uint8_t addr, uint8_t val)\r\n{\r\nuint8_t buf[] = {addr, val};\r\nint ret;\r\nret = i2c_master_send(client, buf, ARRAY_SIZE(buf));\r\nif (ret < 0)\r\nch7006_err(client, "Error %d writing to subaddress 0x%x\n",\r\nret, addr);\r\n}\r\nuint8_t ch7006_read(struct i2c_client *client, uint8_t addr)\r\n{\r\nuint8_t val;\r\nint ret;\r\nret = i2c_master_send(client, &addr, sizeof(addr));\r\nif (ret < 0)\r\ngoto fail;\r\nret = i2c_master_recv(client, &val, sizeof(val));\r\nif (ret < 0)\r\ngoto fail;\r\nreturn val;\r\nfail:\r\nch7006_err(client, "Error %d reading from subaddress 0x%x\n",\r\nret, addr);\r\nreturn 0;\r\n}\r\nvoid ch7006_state_load(struct i2c_client *client,\r\nstruct ch7006_state *state)\r\n{\r\nch7006_load_reg(client, state, CH7006_POWER);\r\nch7006_load_reg(client, state, CH7006_DISPMODE);\r\nch7006_load_reg(client, state, CH7006_FFILTER);\r\nch7006_load_reg(client, state, CH7006_BWIDTH);\r\nch7006_load_reg(client, state, CH7006_INPUT_FORMAT);\r\nch7006_load_reg(client, state, CH7006_CLKMODE);\r\nch7006_load_reg(client, state, CH7006_START_ACTIVE);\r\nch7006_load_reg(client, state, CH7006_POV);\r\nch7006_load_reg(client, state, CH7006_BLACK_LEVEL);\r\nch7006_load_reg(client, state, CH7006_HPOS);\r\nch7006_load_reg(client, state, CH7006_VPOS);\r\nch7006_load_reg(client, state, CH7006_INPUT_SYNC);\r\nch7006_load_reg(client, state, CH7006_DETECT);\r\nch7006_load_reg(client, state, CH7006_CONTRAST);\r\nch7006_load_reg(client, state, CH7006_PLLOV);\r\nch7006_load_reg(client, state, CH7006_PLLM);\r\nch7006_load_reg(client, state, CH7006_PLLN);\r\nch7006_load_reg(client, state, CH7006_BCLKOUT);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC0);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC1);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC2);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC3);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC4);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC5);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC6);\r\nch7006_load_reg(client, state, CH7006_SUBC_INC7);\r\nch7006_load_reg(client, state, CH7006_PLL_CONTROL);\r\nch7006_load_reg(client, state, CH7006_CALC_SUBC_INC0);\r\n}\r\nvoid ch7006_state_save(struct i2c_client *client,\r\nstruct ch7006_state *state)\r\n{\r\nch7006_save_reg(client, state, CH7006_POWER);\r\nch7006_save_reg(client, state, CH7006_DISPMODE);\r\nch7006_save_reg(client, state, CH7006_FFILTER);\r\nch7006_save_reg(client, state, CH7006_BWIDTH);\r\nch7006_save_reg(client, state, CH7006_INPUT_FORMAT);\r\nch7006_save_reg(client, state, CH7006_CLKMODE);\r\nch7006_save_reg(client, state, CH7006_START_ACTIVE);\r\nch7006_save_reg(client, state, CH7006_POV);\r\nch7006_save_reg(client, state, CH7006_BLACK_LEVEL);\r\nch7006_save_reg(client, state, CH7006_HPOS);\r\nch7006_save_reg(client, state, CH7006_VPOS);\r\nch7006_save_reg(client, state, CH7006_INPUT_SYNC);\r\nch7006_save_reg(client, state, CH7006_DETECT);\r\nch7006_save_reg(client, state, CH7006_CONTRAST);\r\nch7006_save_reg(client, state, CH7006_PLLOV);\r\nch7006_save_reg(client, state, CH7006_PLLM);\r\nch7006_save_reg(client, state, CH7006_PLLN);\r\nch7006_save_reg(client, state, CH7006_BCLKOUT);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC0);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC1);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC2);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC3);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC4);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC5);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC6);\r\nch7006_save_reg(client, state, CH7006_SUBC_INC7);\r\nch7006_save_reg(client, state, CH7006_PLL_CONTROL);\r\nch7006_save_reg(client, state, CH7006_CALC_SUBC_INC0);\r\nstate->regs[CH7006_FFILTER] = (state->regs[CH7006_FFILTER] & 0xf0) |\r\n(state->regs[CH7006_FFILTER] & 0x0c) >> 2 |\r\n(state->regs[CH7006_FFILTER] & 0x03) << 2;\r\n}
