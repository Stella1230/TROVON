static int ebook_send_state(struct acpi_device *device)\r\n{\r\nstruct ebook_switch *button = acpi_driver_data(device);\r\nunsigned long long state;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(device->handle, "EBK", NULL, &state);\r\nif (ACPI_FAILURE(status))\r\nreturn -EIO;\r\ninput_report_switch(button->input, SW_TABLET_MODE, !state);\r\ninput_sync(button->input);\r\nreturn 0;\r\n}\r\nstatic void ebook_switch_notify(struct acpi_device *device, u32 event)\r\n{\r\nswitch (event) {\r\ncase ACPI_FIXED_HARDWARE_EVENT:\r\ncase XO15_EBOOK_NOTIFY_STATUS:\r\nebook_send_state(device);\r\nbreak;\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\nbreak;\r\n}\r\n}\r\nstatic int ebook_switch_resume(struct acpi_device *device)\r\n{\r\nreturn ebook_send_state(device);\r\n}\r\nstatic int ebook_switch_add(struct acpi_device *device)\r\n{\r\nstruct ebook_switch *button;\r\nstruct input_dev *input;\r\nconst char *hid = acpi_device_hid(device);\r\nchar *name, *class;\r\nint error;\r\nbutton = kzalloc(sizeof(struct ebook_switch), GFP_KERNEL);\r\nif (!button)\r\nreturn -ENOMEM;\r\ndevice->driver_data = button;\r\nbutton->input = input = input_allocate_device();\r\nif (!input) {\r\nerror = -ENOMEM;\r\ngoto err_free_button;\r\n}\r\nname = acpi_device_name(device);\r\nclass = acpi_device_class(device);\r\nif (strcmp(hid, XO15_EBOOK_HID)) {\r\npr_err("Unsupported hid [%s]\n", hid);\r\nerror = -ENODEV;\r\ngoto err_free_input;\r\n}\r\nstrcpy(name, XO15_EBOOK_DEVICE_NAME);\r\nsprintf(class, "%s/%s", XO15_EBOOK_CLASS, XO15_EBOOK_SUBCLASS);\r\nsnprintf(button->phys, sizeof(button->phys), "%s/button/input0", hid);\r\ninput->name = name;\r\ninput->phys = button->phys;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &device->dev;\r\ninput->evbit[0] = BIT_MASK(EV_SW);\r\nset_bit(SW_TABLET_MODE, input->swbit);\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_free_input;\r\nebook_send_state(device);\r\nif (device->wakeup.flags.valid) {\r\nacpi_enable_gpe(device->wakeup.gpe_device,\r\ndevice->wakeup.gpe_number);\r\ndevice_set_wakeup_enable(&device->dev, true);\r\n}\r\nreturn 0;\r\nerr_free_input:\r\ninput_free_device(input);\r\nerr_free_button:\r\nkfree(button);\r\nreturn error;\r\n}\r\nstatic int ebook_switch_remove(struct acpi_device *device, int type)\r\n{\r\nstruct ebook_switch *button = acpi_driver_data(device);\r\ninput_unregister_device(button->input);\r\nkfree(button);\r\nreturn 0;\r\n}\r\nstatic int __init xo15_ebook_init(void)\r\n{\r\nreturn acpi_bus_register_driver(&xo15_ebook_driver);\r\n}\r\nstatic void __exit xo15_ebook_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&xo15_ebook_driver);\r\n}
