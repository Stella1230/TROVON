static void _rtl92ce_set_bcn_ctrl_reg(struct ieee80211_hw *hw,\r\nu8 set_bits, u8 clear_bits)\r\n{\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtlpci->reg_bcn_ctrl_val |= set_bits;\r\nrtlpci->reg_bcn_ctrl_val &= ~clear_bits;\r\nrtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8) rtlpci->reg_bcn_ctrl_val);\r\n}\r\nstatic void _rtl92ce_stop_tx_beacon(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmp1byte;\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte & (~BIT(6)));\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\r\ntmp1byte &= ~(BIT(0));\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\r\n}\r\nstatic void _rtl92ce_resume_tx_beacon(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 tmp1byte;\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte | BIT(6));\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\r\ntmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\r\ntmp1byte |= BIT(0);\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\r\n}\r\nstatic void _rtl92ce_enable_bcn_sub_func(struct ieee80211_hw *hw)\r\n{\r\n_rtl92ce_set_bcn_ctrl_reg(hw, 0, BIT(1));\r\n}\r\nstatic void _rtl92ce_disable_bcn_sub_func(struct ieee80211_hw *hw)\r\n{\r\n_rtl92ce_set_bcn_ctrl_reg(hw, BIT(1), 0);\r\n}\r\nvoid rtl92ce_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nswitch (variable) {\r\ncase HW_VAR_RCR:\r\n*((u32 *) (val)) = rtlpci->receive_config;\r\nbreak;\r\ncase HW_VAR_RF_STATE:\r\n*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;\r\nbreak;\r\ncase HW_VAR_FWLPS_RF_ON:{\r\nenum rf_pwrstate rfState;\r\nu32 val_rcr;\r\nrtlpriv->cfg->ops->get_hw_reg(hw,\r\nHW_VAR_RF_STATE,\r\n(u8 *) (&rfState));\r\nif (rfState == ERFOFF) {\r\n*((bool *) (val)) = true;\r\n} else {\r\nval_rcr = rtl_read_dword(rtlpriv, REG_RCR);\r\nval_rcr &= 0x00070000;\r\nif (val_rcr)\r\n*((bool *) (val)) = false;\r\nelse\r\n*((bool *) (val)) = true;\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_FW_PSMODE_STATUS:\r\n*((bool *) (val)) = ppsc->fw_current_inpsmode;\r\nbreak;\r\ncase HW_VAR_CORRECT_TSF:{\r\nu64 tsf;\r\nu32 *ptsf_low = (u32 *)&tsf;\r\nu32 *ptsf_high = ((u32 *)&tsf) + 1;\r\n*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));\r\n*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);\r\n*((u64 *) (val)) = tsf;\r\nbreak;\r\n}\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"switch case not processed\n");\r\nbreak;\r\n}\r\n}\r\nvoid rtl92ce_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nu8 idx;\r\nswitch (variable) {\r\ncase HW_VAR_ETHER_ADDR:{\r\nfor (idx = 0; idx < ETH_ALEN; idx++) {\r\nrtl_write_byte(rtlpriv, (REG_MACID + idx),\r\nval[idx]);\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_BASIC_RATE:{\r\nu16 rate_cfg = ((u16 *) val)[0];\r\nu8 rate_index = 0;\r\nrate_cfg &= 0x15f;\r\nrate_cfg |= 0x01;\r\nrtl_write_byte(rtlpriv, REG_RRSR, rate_cfg & 0xff);\r\nrtl_write_byte(rtlpriv, REG_RRSR + 1,\r\n(rate_cfg >> 8) & 0xff);\r\nwhile (rate_cfg > 0x1) {\r\nrate_cfg = (rate_cfg >> 1);\r\nrate_index++;\r\n}\r\nrtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL,\r\nrate_index);\r\nbreak;\r\n}\r\ncase HW_VAR_BSSID:{\r\nfor (idx = 0; idx < ETH_ALEN; idx++) {\r\nrtl_write_byte(rtlpriv, (REG_BSSID + idx),\r\nval[idx]);\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_SIFS:{\r\nrtl_write_byte(rtlpriv, REG_SIFS_CTX + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_SIFS_TRX + 1, val[1]);\r\nrtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);\r\nrtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);\r\nif (!mac->ht_enable)\r\nrtl_write_word(rtlpriv, REG_RESP_SIFS_OFDM,\r\n0x0e0e);\r\nelse\r\nrtl_write_word(rtlpriv, REG_RESP_SIFS_OFDM,\r\n*((u16 *) val));\r\nbreak;\r\n}\r\ncase HW_VAR_SLOT_TIME:{\r\nu8 e_aci;\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"HW_VAR_SLOT_TIME %x\n", val[0]);\r\nrtl_write_byte(rtlpriv, REG_SLOT, val[0]);\r\nfor (e_aci = 0; e_aci < AC_MAX; e_aci++) {\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_AC_PARAM,\r\n(u8 *) (&e_aci));\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_ACK_PREAMBLE:{\r\nu8 reg_tmp;\r\nu8 short_preamble = (bool) (*(u8 *) val);\r\nreg_tmp = (mac->cur_40_prime_sc) << 5;\r\nif (short_preamble)\r\nreg_tmp |= 0x80;\r\nrtl_write_byte(rtlpriv, REG_RRSR + 2, reg_tmp);\r\nbreak;\r\n}\r\ncase HW_VAR_AMPDU_MIN_SPACE:{\r\nu8 min_spacing_to_set;\r\nu8 sec_min_space;\r\nmin_spacing_to_set = *((u8 *) val);\r\nif (min_spacing_to_set <= 7) {\r\nsec_min_space = 0;\r\nif (min_spacing_to_set < sec_min_space)\r\nmin_spacing_to_set = sec_min_space;\r\nmac->min_space_cfg = ((mac->min_space_cfg &\r\n0xf8) |\r\nmin_spacing_to_set);\r\n*val = min_spacing_to_set;\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"Set HW_VAR_AMPDU_MIN_SPACE: %#x\n",\r\nmac->min_space_cfg);\r\nrtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\r\nmac->min_space_cfg);\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_SHORTGI_DENSITY:{\r\nu8 density_to_set;\r\ndensity_to_set = *((u8 *) val);\r\nmac->min_space_cfg |= (density_to_set << 3);\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"Set HW_VAR_SHORTGI_DENSITY: %#x\n",\r\nmac->min_space_cfg);\r\nrtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\r\nmac->min_space_cfg);\r\nbreak;\r\n}\r\ncase HW_VAR_AMPDU_FACTOR:{\r\nu8 regtoset_normal[4] = {0x41, 0xa8, 0x72, 0xb9};\r\nu8 regtoset_bt[4] = {0x31, 0x74, 0x42, 0x97};\r\nu8 factor_toset;\r\nu8 *p_regtoset = NULL;\r\nu8 index = 0;\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n(rtlpcipriv->bt_coexist.bt_coexist_type ==\r\nBT_CSR_BC4))\r\np_regtoset = regtoset_bt;\r\nelse\r\np_regtoset = regtoset_normal;\r\nfactor_toset = *((u8 *) val);\r\nif (factor_toset <= 3) {\r\nfactor_toset = (1 << (factor_toset + 2));\r\nif (factor_toset > 0xf)\r\nfactor_toset = 0xf;\r\nfor (index = 0; index < 4; index++) {\r\nif ((p_regtoset[index] & 0xf0) >\r\n(factor_toset << 4))\r\np_regtoset[index] =\r\n(p_regtoset[index] & 0x0f) |\r\n(factor_toset << 4);\r\nif ((p_regtoset[index] & 0x0f) >\r\nfactor_toset)\r\np_regtoset[index] =\r\n(p_regtoset[index] & 0xf0) |\r\n(factor_toset);\r\nrtl_write_byte(rtlpriv,\r\n(REG_AGGLEN_LMT + index),\r\np_regtoset[index]);\r\n}\r\nRT_TRACE(rtlpriv, COMP_MLME, DBG_LOUD,\r\n"Set HW_VAR_AMPDU_FACTOR: %#x\n",\r\nfactor_toset);\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_AC_PARAM:{\r\nu8 e_aci = *((u8 *) val);\r\nrtl92c_dm_init_edca_turbo(hw);\r\nif (rtlpci->acm_method != eAcmWay2_SW)\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_ACM_CTRL,\r\n(u8 *) (&e_aci));\r\nbreak;\r\n}\r\ncase HW_VAR_ACM_CTRL:{\r\nu8 e_aci = *((u8 *) val);\r\nunion aci_aifsn *p_aci_aifsn =\r\n(union aci_aifsn *)(&(mac->ac[0].aifs));\r\nu8 acm = p_aci_aifsn->f.acm;\r\nu8 acm_ctrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);\r\nacm_ctrl =\r\nacm_ctrl | ((rtlpci->acm_method == 2) ? 0x0 : 0x1);\r\nif (acm) {\r\nswitch (e_aci) {\r\ncase AC0_BE:\r\nacm_ctrl |= AcmHw_BeqEn;\r\nbreak;\r\ncase AC2_VI:\r\nacm_ctrl |= AcmHw_ViqEn;\r\nbreak;\r\ncase AC3_VO:\r\nacm_ctrl |= AcmHw_VoqEn;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"HW_VAR_ACM_CTRL acm set failed: eACI is %d\n",\r\nacm);\r\nbreak;\r\n}\r\n} else {\r\nswitch (e_aci) {\r\ncase AC0_BE:\r\nacm_ctrl &= (~AcmHw_BeqEn);\r\nbreak;\r\ncase AC2_VI:\r\nacm_ctrl &= (~AcmHw_ViqEn);\r\nbreak;\r\ncase AC3_VO:\r\nacm_ctrl &= (~AcmHw_BeqEn);\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"switch case not processed\n");\r\nbreak;\r\n}\r\n}\r\nRT_TRACE(rtlpriv, COMP_QOS, DBG_TRACE,\r\n"SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\n",\r\nacm_ctrl);\r\nrtl_write_byte(rtlpriv, REG_ACMHWCTRL, acm_ctrl);\r\nbreak;\r\n}\r\ncase HW_VAR_RCR:{\r\nrtl_write_dword(rtlpriv, REG_RCR, ((u32 *) (val))[0]);\r\nrtlpci->receive_config = ((u32 *) (val))[0];\r\nbreak;\r\n}\r\ncase HW_VAR_RETRY_LIMIT:{\r\nu8 retry_limit = ((u8 *) (val))[0];\r\nrtl_write_word(rtlpriv, REG_RL,\r\nretry_limit << RETRY_LIMIT_SHORT_SHIFT |\r\nretry_limit << RETRY_LIMIT_LONG_SHIFT);\r\nbreak;\r\n}\r\ncase HW_VAR_DUAL_TSF_RST:\r\nrtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));\r\nbreak;\r\ncase HW_VAR_EFUSE_BYTES:\r\nrtlefuse->efuse_usedbytes = *((u16 *) val);\r\nbreak;\r\ncase HW_VAR_EFUSE_USAGE:\r\nrtlefuse->efuse_usedpercentage = *((u8 *) val);\r\nbreak;\r\ncase HW_VAR_IO_CMD:\r\nrtl92c_phy_set_io_cmd(hw, (*(enum io_type *)val));\r\nbreak;\r\ncase HW_VAR_WPA_CONFIG:\r\nrtl_write_byte(rtlpriv, REG_SECCFG, *((u8 *) val));\r\nbreak;\r\ncase HW_VAR_SET_RPWM:{\r\nu8 rpwm_val;\r\nrpwm_val = rtl_read_byte(rtlpriv, REG_PCIE_HRPWM);\r\nudelay(1);\r\nif (rpwm_val & BIT(7)) {\r\nrtl_write_byte(rtlpriv, REG_PCIE_HRPWM,\r\n(*(u8 *) val));\r\n} else {\r\nrtl_write_byte(rtlpriv, REG_PCIE_HRPWM,\r\n((*(u8 *) val) | BIT(7)));\r\n}\r\nbreak;\r\n}\r\ncase HW_VAR_H2C_FW_PWRMODE:{\r\nu8 psmode = (*(u8 *) val);\r\nif ((psmode != FW_PS_ACTIVE_MODE) &&\r\n(!IS_92C_SERIAL(rtlhal->version))) {\r\nrtl92c_dm_rf_saving(hw, true);\r\n}\r\nrtl92c_set_fw_pwrmode_cmd(hw, (*(u8 *) val));\r\nbreak;\r\n}\r\ncase HW_VAR_FW_PSMODE_STATUS:\r\nppsc->fw_current_inpsmode = *((bool *) val);\r\nbreak;\r\ncase HW_VAR_H2C_FW_JOINBSSRPT:{\r\nu8 mstatus = (*(u8 *) val);\r\nu8 tmp_regcr, tmp_reg422;\r\nbool recover = false;\r\nif (mstatus == RT_MEDIA_CONNECT) {\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID,\r\nNULL);\r\ntmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);\r\nrtl_write_byte(rtlpriv, REG_CR + 1,\r\n(tmp_regcr | BIT(0)));\r\n_rtl92ce_set_bcn_ctrl_reg(hw, 0, BIT(3));\r\n_rtl92ce_set_bcn_ctrl_reg(hw, BIT(4), 0);\r\ntmp_reg422 =\r\nrtl_read_byte(rtlpriv,\r\nREG_FWHW_TXQ_CTRL + 2);\r\nif (tmp_reg422 & BIT(6))\r\nrecover = true;\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\r\ntmp_reg422 & (~BIT(6)));\r\nrtl92c_set_fw_rsvdpagepkt(hw, 0);\r\n_rtl92ce_set_bcn_ctrl_reg(hw, BIT(3), 0);\r\n_rtl92ce_set_bcn_ctrl_reg(hw, 0, BIT(4));\r\nif (recover) {\r\nrtl_write_byte(rtlpriv,\r\nREG_FWHW_TXQ_CTRL + 2,\r\ntmp_reg422);\r\n}\r\nrtl_write_byte(rtlpriv, REG_CR + 1,\r\n(tmp_regcr & ~(BIT(0))));\r\n}\r\nrtl92c_set_fw_joinbss_report_cmd(hw, (*(u8 *) val));\r\nbreak;\r\n}\r\ncase HW_VAR_AID:{\r\nu16 u2btmp;\r\nu2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);\r\nu2btmp &= 0xC000;\r\nrtl_write_word(rtlpriv, REG_BCN_PSR_RPT, (u2btmp |\r\nmac->assoc_id));\r\nbreak;\r\n}\r\ncase HW_VAR_CORRECT_TSF:{\r\nu8 btype_ibss = ((u8 *) (val))[0];\r\nif (btype_ibss)\r\n_rtl92ce_stop_tx_beacon(hw);\r\n_rtl92ce_set_bcn_ctrl_reg(hw, 0, BIT(3));\r\nrtl_write_dword(rtlpriv, REG_TSFTR,\r\n(u32) (mac->tsf & 0xffffffff));\r\nrtl_write_dword(rtlpriv, REG_TSFTR + 4,\r\n(u32) ((mac->tsf >> 32) & 0xffffffff));\r\n_rtl92ce_set_bcn_ctrl_reg(hw, BIT(3), 0);\r\nif (btype_ibss)\r\n_rtl92ce_resume_tx_beacon(hw);\r\nbreak;\r\n}\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"switch case not processed\n");\r\nbreak;\r\n}\r\n}\r\nstatic bool _rtl92ce_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nbool status = true;\r\nlong count = 0;\r\nu32 value = _LLT_INIT_ADDR(address) |\r\n_LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);\r\nrtl_write_dword(rtlpriv, REG_LLT_INIT, value);\r\ndo {\r\nvalue = rtl_read_dword(rtlpriv, REG_LLT_INIT);\r\nif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))\r\nbreak;\r\nif (count > POLLING_LLT_THRESHOLD) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Failed to polling write LLT done at address %d!\n",\r\naddress);\r\nstatus = false;\r\nbreak;\r\n}\r\n} while (++count);\r\nreturn status;\r\n}\r\nstatic bool _rtl92ce_llt_table_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nunsigned short i;\r\nu8 txpktbuf_bndy;\r\nu8 maxPage;\r\nbool status;\r\n#if LLT_CONFIG == 1\r\nmaxPage = 255;\r\ntxpktbuf_bndy = 252;\r\n#elif LLT_CONFIG == 2\r\nmaxPage = 127;\r\ntxpktbuf_bndy = 124;\r\n#elif LLT_CONFIG == 3\r\nmaxPage = 255;\r\ntxpktbuf_bndy = 174;\r\n#elif LLT_CONFIG == 4\r\nmaxPage = 255;\r\ntxpktbuf_bndy = 246;\r\n#elif LLT_CONFIG == 5\r\nmaxPage = 255;\r\ntxpktbuf_bndy = 246;\r\n#endif\r\n#if LLT_CONFIG == 1\r\nrtl_write_byte(rtlpriv, REG_RQPN_NPQ, 0x1c);\r\nrtl_write_dword(rtlpriv, REG_RQPN, 0x80a71c1c);\r\n#elif LLT_CONFIG == 2\r\nrtl_write_dword(rtlpriv, REG_RQPN, 0x845B1010);\r\n#elif LLT_CONFIG == 3\r\nrtl_write_dword(rtlpriv, REG_RQPN, 0x84838484);\r\n#elif LLT_CONFIG == 4\r\nrtl_write_dword(rtlpriv, REG_RQPN, 0x80bd1c1c);\r\n#elif LLT_CONFIG == 5\r\nrtl_write_word(rtlpriv, REG_RQPN_NPQ, 0x0000);\r\nrtl_write_dword(rtlpriv, REG_RQPN, 0x80b01c29);\r\n#endif\r\nrtl_write_dword(rtlpriv, REG_TRXFF_BNDY, (0x27FF0000 | txpktbuf_bndy));\r\nrtl_write_byte(rtlpriv, REG_TDECTRL + 1, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, 0x45D, txpktbuf_bndy);\r\nrtl_write_byte(rtlpriv, REG_PBP, 0x11);\r\nrtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, 0x4);\r\nfor (i = 0; i < (txpktbuf_bndy - 1); i++) {\r\nstatus = _rtl92ce_llt_write(hw, i, i + 1);\r\nif (true != status)\r\nreturn status;\r\n}\r\nstatus = _rtl92ce_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);\r\nif (true != status)\r\nreturn status;\r\nfor (i = txpktbuf_bndy; i < maxPage; i++) {\r\nstatus = _rtl92ce_llt_write(hw, i, (i + 1));\r\nif (true != status)\r\nreturn status;\r\n}\r\nstatus = _rtl92ce_llt_write(hw, maxPage, txpktbuf_bndy);\r\nif (true != status)\r\nreturn status;\r\nreturn true;\r\n}\r\nstatic void _rtl92ce_gen_refresh_led_state(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_led *pLed0 = &(pcipriv->ledctl.sw_led0);\r\nif (rtlpci->up_first_time)\r\nreturn;\r\nif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\r\nrtl92ce_sw_led_on(hw, pLed0);\r\nelse if (ppsc->rfoff_reason == RF_CHANGE_BY_INIT)\r\nrtl92ce_sw_led_on(hw, pLed0);\r\nelse\r\nrtl92ce_sw_led_off(hw, pLed0);\r\n}\r\nstatic bool _rtl92ce_init_mac(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nunsigned char bytetmp;\r\nunsigned short wordtmp;\r\nu16 retry;\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x00);\r\nif (rtlpcipriv->bt_coexist.bt_coexistence) {\r\nu32 value32;\r\nvalue32 = rtl_read_dword(rtlpriv, REG_APS_FSMCO);\r\nvalue32 |= (SOP_ABG | SOP_AMB | XOP_BTCK);\r\nrtl_write_dword(rtlpriv, REG_APS_FSMCO, value32);\r\n}\r\nrtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\r\nrtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL, 0x0F);\r\nif (rtlpcipriv->bt_coexist.bt_coexistence) {\r\nu32 u4b_tmp = rtl_read_dword(rtlpriv, REG_AFE_XTAL_CTRL);\r\nu4b_tmp &= (~0x00024800);\r\nrtl_write_dword(rtlpriv, REG_AFE_XTAL_CTRL, u4b_tmp);\r\n}\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1) | BIT(0);\r\nudelay(2);\r\nrtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, bytetmp);\r\nudelay(2);\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1);\r\nudelay(2);\r\nretry = 0;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "reg0xec:%x:%x\n",\r\nrtl_read_dword(rtlpriv, 0xEC), bytetmp);\r\nwhile ((bytetmp & BIT(0)) && retry < 1000) {\r\nretry++;\r\nudelay(50);\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "reg0xec:%x:%x\n",\r\nrtl_read_dword(rtlpriv, 0xEC), bytetmp);\r\nudelay(50);\r\n}\r\nrtl_write_word(rtlpriv, REG_APS_FSMCO, 0x1012);\r\nrtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL + 1, 0x82);\r\nudelay(2);\r\nif (rtlpcipriv->bt_coexist.bt_coexistence) {\r\nbytetmp = rtl_read_byte(rtlpriv, REG_AFE_XTAL_CTRL+2) & 0xfd;\r\nrtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL+2, bytetmp);\r\n}\r\nrtl_write_word(rtlpriv, REG_CR, 0x2ff);\r\nif (!_rtl92ce_llt_table_init(hw))\r\nreturn false;\r\nrtl_write_dword(rtlpriv, REG_HISR, 0xffffffff);\r\nrtl_write_byte(rtlpriv, REG_HISRE, 0xff);\r\nrtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, 0x27ff);\r\nwordtmp = rtl_read_word(rtlpriv, REG_TRXDMA_CTRL);\r\nwordtmp &= 0xf;\r\nwordtmp |= 0xF771;\r\nrtl_write_word(rtlpriv, REG_TRXDMA_CTRL, wordtmp);\r\nrtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 1, 0x1F);\r\nrtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);\r\nrtl_write_dword(rtlpriv, REG_TCR, rtlpci->transmit_config);\r\nrtl_write_byte(rtlpriv, 0x4d0, 0x0);\r\nrtl_write_dword(rtlpriv, REG_BCNQ_DESA,\r\n((u64) rtlpci->tx_ring[BEACON_QUEUE].dma) &\r\nDMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_MGQ_DESA,\r\n(u64) rtlpci->tx_ring[MGNT_QUEUE].dma &\r\nDMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_VOQ_DESA,\r\n(u64) rtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_VIQ_DESA,\r\n(u64) rtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_BEQ_DESA,\r\n(u64) rtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_BKQ_DESA,\r\n(u64) rtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_HQ_DESA,\r\n(u64) rtlpci->tx_ring[HIGH_QUEUE].dma &\r\nDMA_BIT_MASK(32));\r\nrtl_write_dword(rtlpriv, REG_RX_DESA,\r\n(u64) rtlpci->rx_ring[RX_MPDU_QUEUE].dma &\r\nDMA_BIT_MASK(32));\r\nif (IS_92C_SERIAL(rtlhal->version))\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 3, 0x77);\r\nelse\r\nrtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 3, 0x22);\r\nrtl_write_dword(rtlpriv, REG_INT_MIG, 0);\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APSD_CTRL);\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, bytetmp & ~BIT(6));\r\ndo {\r\nretry++;\r\nbytetmp = rtl_read_byte(rtlpriv, REG_APSD_CTRL);\r\n} while ((retry < 200) && (bytetmp & BIT(7)));\r\n_rtl92ce_gen_refresh_led_state(hw);\r\nrtl_write_dword(rtlpriv, REG_MCUTST_1, 0x0);\r\nreturn true;\r\n}\r\nstatic void _rtl92ce_hw_configure(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nu8 reg_bw_opmode;\r\nu32 reg_prsr;\r\nreg_bw_opmode = BW_OPMODE_20MHZ;\r\nreg_prsr = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nrtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL, 0x8);\r\nrtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\r\nrtl_write_dword(rtlpriv, REG_RRSR, reg_prsr);\r\nrtl_write_byte(rtlpriv, REG_SLOT, 0x09);\r\nrtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE, 0x0);\r\nrtl_write_word(rtlpriv, REG_FWHW_TXQ_CTRL, 0x1F80);\r\nrtl_write_word(rtlpriv, REG_RL, 0x0707);\r\nrtl_write_dword(rtlpriv, REG_BAR_MODE_CTRL, 0x02012802);\r\nrtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, 0xFF);\r\nrtl_write_dword(rtlpriv, REG_DARFRC, 0x01000000);\r\nrtl_write_dword(rtlpriv, REG_DARFRC + 4, 0x07060504);\r\nrtl_write_dword(rtlpriv, REG_RARFRC, 0x01000000);\r\nrtl_write_dword(rtlpriv, REG_RARFRC + 4, 0x07060504);\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n(rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4))\r\nrtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0x97427431);\r\nelse\r\nrtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0xb972a841);\r\nrtl_write_byte(rtlpriv, REG_ATIMWND, 0x2);\r\nrtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xff);\r\nrtlpci->reg_bcn_ctrl_val = 0x1f;\r\nrtl_write_byte(rtlpriv, REG_BCN_CTRL, rtlpci->reg_bcn_ctrl_val);\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\r\nrtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\r\nrtl_write_byte(rtlpriv, REG_PIFS, 0x1C);\r\nrtl_write_byte(rtlpriv, REG_AGGR_BREAK_TIME, 0x16);\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n(rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4)) {\r\nrtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0020);\r\nrtl_write_word(rtlpriv, REG_PROT_MODE_CTRL, 0x0402);\r\n} else {\r\nrtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0020);\r\nrtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0020);\r\n}\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n(rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4))\r\nrtl_write_dword(rtlpriv, REG_FAST_EDCA_CTRL, 0x03086666);\r\nelse\r\nrtl_write_dword(rtlpriv, REG_FAST_EDCA_CTRL, 0x086666);\r\nrtl_write_byte(rtlpriv, REG_ACKTO, 0x40);\r\nrtl_write_word(rtlpriv, REG_SPEC_SIFS, 0x1010);\r\nrtl_write_word(rtlpriv, REG_MAC_SPEC_SIFS, 0x1010);\r\nrtl_write_word(rtlpriv, REG_SIFS_CTX, 0x1010);\r\nrtl_write_word(rtlpriv, REG_SIFS_TRX, 0x1010);\r\nrtl_write_dword(rtlpriv, REG_MAR, 0xffffffff);\r\nrtl_write_dword(rtlpriv, REG_MAR + 4, 0xffffffff);\r\n}\r\nstatic void _rtl92ce_enable_aspm_back_door(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nrtl_write_byte(rtlpriv, 0x34b, 0x93);\r\nrtl_write_word(rtlpriv, 0x350, 0x870c);\r\nrtl_write_byte(rtlpriv, 0x352, 0x1);\r\nif (ppsc->support_backdoor)\r\nrtl_write_byte(rtlpriv, 0x349, 0x1b);\r\nelse\r\nrtl_write_byte(rtlpriv, 0x349, 0x03);\r\nrtl_write_word(rtlpriv, 0x350, 0x2718);\r\nrtl_write_byte(rtlpriv, 0x352, 0x1);\r\n}\r\nvoid rtl92ce_enable_hw_security_config(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 sec_reg_value;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\n",\r\nrtlpriv->sec.pairwise_enc_algorithm,\r\nrtlpriv->sec.group_enc_algorithm);\r\nif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"not open hw encryption\n");\r\nreturn;\r\n}\r\nsec_reg_value = SCR_TxEncEnable | SCR_RxDecEnable;\r\nif (rtlpriv->sec.use_defaultkey) {\r\nsec_reg_value |= SCR_TxUseDK;\r\nsec_reg_value |= SCR_RxUseDK;\r\n}\r\nsec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);\r\nrtl_write_byte(rtlpriv, REG_CR + 1, 0x02);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"The SECR-value %x\n", sec_reg_value);\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);\r\n}\r\nint rtl92ce_hw_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstatic bool iqk_initialized;\r\nbool rtstatus = true;\r\nbool is92c;\r\nint err;\r\nu8 tmp_u1b;\r\nrtlpci->being_init_adapter = true;\r\nrtlpriv->intf_ops->disable_aspm(hw);\r\nrtstatus = _rtl92ce_init_mac(hw);\r\nif (!rtstatus) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Init MAC failed\n");\r\nerr = 1;\r\nreturn err;\r\n}\r\nerr = rtl92c_download_fw(hw);\r\nif (err) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"Failed to download FW. Init HW without FW now..\n");\r\nerr = 1;\r\nreturn err;\r\n}\r\nrtlhal->last_hmeboxnum = 0;\r\nrtl92c_phy_mac_config(hw);\r\nrtl92c_phy_bb_config(hw);\r\nrtlphy->rf_mode = RF_OP_BY_SW_3WIRE;\r\nrtl92c_phy_rf_config(hw);\r\nrtlphy->rfreg_chnlval[0] = rtl_get_rfreg(hw, (enum radio_path)0,\r\nRF_CHNLBW, RFREG_OFFSET_MASK);\r\nrtlphy->rfreg_chnlval[1] = rtl_get_rfreg(hw, (enum radio_path)1,\r\nRF_CHNLBW, RFREG_OFFSET_MASK);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0x1);\r\nrtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0x1);\r\nrtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10), 1);\r\n_rtl92ce_hw_configure(hw);\r\nrtl_cam_reset_all_entry(hw);\r\nrtl92ce_enable_hw_security_config(hw);\r\nppsc->rfpwr_state = ERFON;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);\r\n_rtl92ce_enable_aspm_back_door(hw);\r\nrtlpriv->intf_ops->enable_aspm(hw);\r\nrtl8192ce_bt_hw_init(hw);\r\nif (ppsc->rfpwr_state == ERFON) {\r\nrtl92c_phy_set_rfpath_switch(hw, 1);\r\nif (iqk_initialized) {\r\nrtl92c_phy_iq_calibrate(hw, true);\r\n} else {\r\nrtl92c_phy_iq_calibrate(hw, false);\r\niqk_initialized = true;\r\n}\r\nrtl92c_dm_check_txpower_tracking(hw);\r\nrtl92c_phy_lc_calibrate(hw);\r\n}\r\nis92c = IS_92C_SERIAL(rtlhal->version);\r\ntmp_u1b = efuse_read_1byte(hw, 0x1FA);\r\nif (!(tmp_u1b & BIT(0))) {\r\nrtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0F, 0x05);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "PA BIAS path A\n");\r\n}\r\nif (!(tmp_u1b & BIT(1)) && is92c) {\r\nrtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0F, 0x05);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "PA BIAS path B\n");\r\n}\r\nif (!(tmp_u1b & BIT(4))) {\r\ntmp_u1b = rtl_read_byte(rtlpriv, 0x16);\r\ntmp_u1b &= 0x0F;\r\nrtl_write_byte(rtlpriv, 0x16, tmp_u1b | 0x80);\r\nudelay(10);\r\nrtl_write_byte(rtlpriv, 0x16, tmp_u1b | 0x90);\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "under 1.5V\n");\r\n}\r\nrtl92c_dm_init(hw);\r\nrtlpci->being_init_adapter = false;\r\nreturn err;\r\n}\r\nstatic enum version_8192c _rtl92ce_read_chip_version(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nenum version_8192c version = VERSION_UNKNOWN;\r\nu32 value32;\r\nconst char *versionid;\r\nvalue32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);\r\nif (value32 & TRP_VAUX_EN) {\r\nversion = (value32 & TYPE_ID) ? VERSION_A_CHIP_92C :\r\nVERSION_A_CHIP_88C;\r\n} else {\r\nversion = (value32 & TYPE_ID) ? VERSION_B_CHIP_92C :\r\nVERSION_B_CHIP_88C;\r\n}\r\nswitch (version) {\r\ncase VERSION_B_CHIP_92C:\r\nversionid = "B_CHIP_92C";\r\nbreak;\r\ncase VERSION_B_CHIP_88C:\r\nversionid = "B_CHIP_88C";\r\nbreak;\r\ncase VERSION_A_CHIP_92C:\r\nversionid = "A_CHIP_92C";\r\nbreak;\r\ncase VERSION_A_CHIP_88C:\r\nversionid = "A_CHIP_88C";\r\nbreak;\r\ndefault:\r\nversionid = "Unknown. Bug?";\r\nbreak;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Chip Version ID: %s\n", versionid);\r\nswitch (version & 0x3) {\r\ncase CHIP_88C:\r\nrtlphy->rf_type = RF_1T1R;\r\nbreak;\r\ncase CHIP_92C:\r\nrtlphy->rf_type = RF_2T2R;\r\nbreak;\r\ncase CHIP_92C_1T2R:\r\nrtlphy->rf_type = RF_1T2R;\r\nbreak;\r\ndefault:\r\nrtlphy->rf_type = RF_1T1R;\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"ERROR RF_Type is set!!\n");\r\nbreak;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Chip RF Type: %s\n",\r\nrtlphy->rf_type == RF_2T2R ? "RF_2T2R" : "RF_1T1R");\r\nreturn version;\r\n}\r\nstatic int _rtl92ce_set_media_status(struct ieee80211_hw *hw,\r\nenum nl80211_iftype type)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu8 bt_msr = rtl_read_byte(rtlpriv, MSR);\r\nenum led_ctl_mode ledaction = LED_CTL_NO_LINK;\r\nbt_msr &= 0xfc;\r\nif (type == NL80211_IFTYPE_UNSPECIFIED ||\r\ntype == NL80211_IFTYPE_STATION) {\r\n_rtl92ce_stop_tx_beacon(hw);\r\n_rtl92ce_enable_bcn_sub_func(hw);\r\n} else if (type == NL80211_IFTYPE_ADHOC || type == NL80211_IFTYPE_AP) {\r\n_rtl92ce_resume_tx_beacon(hw);\r\n_rtl92ce_disable_bcn_sub_func(hw);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"Set HW_VAR_MEDIA_STATUS: No such media status(%x)\n",\r\ntype);\r\n}\r\nswitch (type) {\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\nbt_msr |= MSR_NOLINK;\r\nledaction = LED_CTL_LINK;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to NO LINK!\n");\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nbt_msr |= MSR_ADHOC;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to Ad Hoc!\n");\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nbt_msr |= MSR_INFRA;\r\nledaction = LED_CTL_LINK;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to STA!\n");\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nbt_msr |= MSR_AP;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,\r\n"Set Network type to AP!\n");\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"Network type %d not supported!\n", type);\r\nreturn 1;\r\nbreak;\r\n}\r\nrtl_write_byte(rtlpriv, (MSR), bt_msr);\r\nrtlpriv->cfg->ops->led_control(hw, ledaction);\r\nif ((bt_msr & 0xfc) == MSR_AP)\r\nrtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);\r\nelse\r\nrtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);\r\nreturn 0;\r\n}\r\nvoid rtl92ce_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nu32 reg_rcr = rtl_read_dword(rtlpriv, REG_RCR);\r\nif (rtlpriv->psc.rfpwr_state != ERFON)\r\nreturn;\r\nif (check_bssid) {\r\nreg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,\r\n(u8 *) (&reg_rcr));\r\n_rtl92ce_set_bcn_ctrl_reg(hw, 0, BIT(4));\r\n} else if (!check_bssid) {\r\nreg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));\r\n_rtl92ce_set_bcn_ctrl_reg(hw, BIT(4), 0);\r\nrtlpriv->cfg->ops->set_hw_reg(hw,\r\nHW_VAR_RCR, (u8 *) (&reg_rcr));\r\n}\r\n}\r\nint rtl92ce_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (_rtl92ce_set_media_status(hw, type))\r\nreturn -EOPNOTSUPP;\r\nif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\r\nif (type != NL80211_IFTYPE_AP)\r\nrtl92ce_set_check_bssid(hw, true);\r\n} else {\r\nrtl92ce_set_check_bssid(hw, false);\r\n}\r\nreturn 0;\r\n}\r\nvoid rtl92ce_set_qos(struct ieee80211_hw *hw, int aci)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nrtl92c_dm_init_edca_turbo(hw);\r\nswitch (aci) {\r\ncase AC1_BK:\r\nrtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0xa44f);\r\nbreak;\r\ncase AC0_BE:\r\nbreak;\r\ncase AC2_VI:\r\nrtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x5e4322);\r\nbreak;\r\ncase AC3_VO:\r\nrtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x2f3222);\r\nbreak;\r\ndefault:\r\nRT_ASSERT(false, "invalid aci: %d !\n", aci);\r\nbreak;\r\n}\r\n}\r\nvoid rtl92ce_enable_interrupt(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nrtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] & 0xFFFFFFFF);\r\nrtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] & 0xFFFFFFFF);\r\n}\r\nvoid rtl92ce_disable_interrupt(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nrtl_write_dword(rtlpriv, REG_HIMR, IMR8190_DISABLED);\r\nrtl_write_dword(rtlpriv, REG_HIMRE, IMR8190_DISABLED);\r\nsynchronize_irq(rtlpci->pdev->irq);\r\n}\r\nstatic void _rtl92ce_poweroff_adapter(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nu8 u1b_tmp;\r\nu32 u4b_tmp;\r\nrtlpriv->intf_ops->enable_aspm(hw);\r\nrtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\r\nrtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\r\nrtl_write_byte(rtlpriv, REG_RF_CTRL, 0x00);\r\nrtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE0);\r\nif (rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(7))\r\nrtl92c_firmware_selfreset(hw);\r\nrtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, 0x51);\r\nrtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);\r\nrtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x00000000);\r\nu1b_tmp = rtl_read_byte(rtlpriv, REG_GPIO_PIN_CTRL);\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n((rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4) ||\r\n(rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC8))) {\r\nrtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x00F30000 |\r\n(u1b_tmp << 8));\r\n} else {\r\nrtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x00FF0000 |\r\n(u1b_tmp << 8));\r\n}\r\nrtl_write_word(rtlpriv, REG_GPIO_IO_SEL, 0x0790);\r\nrtl_write_word(rtlpriv, REG_LEDCFG0, 0x8080);\r\nrtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x80);\r\nrtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x23);\r\nif (rtlpcipriv->bt_coexist.bt_coexistence) {\r\nu4b_tmp = rtl_read_dword(rtlpriv, REG_AFE_XTAL_CTRL);\r\nu4b_tmp |= 0x03824800;\r\nrtl_write_dword(rtlpriv, REG_AFE_XTAL_CTRL, u4b_tmp);\r\n} else {\r\nrtl_write_dword(rtlpriv, REG_AFE_XTAL_CTRL, 0x0e);\r\n}\r\nrtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0e);\r\nrtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, 0x10);\r\n}\r\nvoid rtl92ce_card_disable(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nenum nl80211_iftype opmode;\r\nmac->link_state = MAC80211_NOLINK;\r\nopmode = NL80211_IFTYPE_UNSPECIFIED;\r\n_rtl92ce_set_media_status(hw, opmode);\r\nif (rtlpci->driver_is_goingto_unload ||\r\nppsc->rfoff_reason > RF_CHANGE_BY_PS)\r\nrtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\r\nRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\r\n_rtl92ce_poweroff_adapter(hw);\r\n}\r\nvoid rtl92ce_interrupt_recognized(struct ieee80211_hw *hw,\r\nu32 *p_inta, u32 *p_intb)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\n*p_inta = rtl_read_dword(rtlpriv, ISR) & rtlpci->irq_mask[0];\r\nrtl_write_dword(rtlpriv, ISR, *p_inta);\r\n}\r\nvoid rtl92ce_set_beacon_related_registers(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nu16 bcn_interval, atim_window;\r\nbcn_interval = mac->beacon_interval;\r\natim_window = 2;\r\nrtl92ce_disable_interrupt(hw);\r\nrtl_write_word(rtlpriv, REG_ATIMWND, atim_window);\r\nrtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\r\nrtl_write_word(rtlpriv, REG_BCNTCFG, 0x660f);\r\nrtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x18);\r\nrtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x18);\r\nrtl_write_byte(rtlpriv, 0x606, 0x30);\r\nrtl92ce_enable_interrupt(hw);\r\n}\r\nvoid rtl92ce_set_beacon_interval(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nu16 bcn_interval = mac->beacon_interval;\r\nRT_TRACE(rtlpriv, COMP_BEACON, DBG_DMESG,\r\n"beacon_interval:%d\n", bcn_interval);\r\nrtl92ce_disable_interrupt(hw);\r\nrtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\r\nrtl92ce_enable_interrupt(hw);\r\n}\r\nvoid rtl92ce_update_interrupt_mask(struct ieee80211_hw *hw,\r\nu32 add_msr, u32 rm_msr)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nRT_TRACE(rtlpriv, COMP_INTR, DBG_LOUD, "add_msr:%x, rm_msr:%x\n",\r\nadd_msr, rm_msr);\r\nif (add_msr)\r\nrtlpci->irq_mask[0] |= add_msr;\r\nif (rm_msr)\r\nrtlpci->irq_mask[0] &= (~rm_msr);\r\nrtl92ce_disable_interrupt(hw);\r\nrtl92ce_enable_interrupt(hw);\r\n}\r\nstatic void _rtl92ce_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,\r\nbool autoload_fail,\r\nu8 *hwinfo)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 rf_path, index, tempval;\r\nu16 i;\r\nfor (rf_path = 0; rf_path < 2; rf_path++) {\r\nfor (i = 0; i < 3; i++) {\r\nif (!autoload_fail) {\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_cck[rf_path][i] =\r\nhwinfo[EEPROM_TXPOWERCCK + rf_path * 3 + i];\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_1s[rf_path][i] =\r\nhwinfo[EEPROM_TXPOWERHT40_1S + rf_path * 3 +\r\ni];\r\n} else {\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_cck[rf_path][i] =\r\nEEPROM_DEFAULT_TXPOWERLEVEL;\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_1s[rf_path][i] =\r\nEEPROM_DEFAULT_TXPOWERLEVEL;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (!autoload_fail)\r\ntempval = hwinfo[EEPROM_TXPOWERHT40_2SDIFF + i];\r\nelse\r\ntempval = EEPROM_DEFAULT_HT40_2SDIFF;\r\nrtlefuse->eeprom_chnlarea_txpwr_ht40_2sdiif[RF90_PATH_A][i] =\r\n(tempval & 0xf);\r\nrtlefuse->eeprom_chnlarea_txpwr_ht40_2sdiif[RF90_PATH_B][i] =\r\n((tempval & 0xf0) >> 4);\r\n}\r\nfor (rf_path = 0; rf_path < 2; rf_path++)\r\nfor (i = 0; i < 3; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\r\n"RF(%d) EEPROM CCK Area(%d) = 0x%x\n",\r\nrf_path, i,\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_cck[rf_path][i]);\r\nfor (rf_path = 0; rf_path < 2; rf_path++)\r\nfor (i = 0; i < 3; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\r\n"RF(%d) EEPROM HT40 1S Area(%d) = 0x%x\n",\r\nrf_path, i,\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_1s[rf_path][i]);\r\nfor (rf_path = 0; rf_path < 2; rf_path++)\r\nfor (i = 0; i < 3; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\r\n"RF(%d) EEPROM HT40 2S Diff Area(%d) = 0x%x\n",\r\nrf_path, i,\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_2sdiif[rf_path][i]);\r\nfor (rf_path = 0; rf_path < 2; rf_path++) {\r\nfor (i = 0; i < 14; i++) {\r\nindex = _rtl92c_get_chnl_group((u8) i);\r\nrtlefuse->txpwrlevel_cck[rf_path][i] =\r\nrtlefuse->eeprom_chnlarea_txpwr_cck[rf_path][index];\r\nrtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_1s[rf_path][index];\r\nif ((rtlefuse->\r\neeprom_chnlarea_txpwr_ht40_1s[rf_path][index] -\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_2sdiif[rf_path][index])\r\n> 0) {\r\nrtlefuse->txpwrlevel_ht40_2s[rf_path][i] =\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_1s[rf_path]\r\n[index] -\r\nrtlefuse->\r\neeprom_chnlarea_txpwr_ht40_2sdiif[rf_path]\r\n[index];\r\n} else {\r\nrtlefuse->txpwrlevel_ht40_2s[rf_path][i] = 0;\r\n}\r\n}\r\nfor (i = 0; i < 14; i++) {\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\n",\r\nrf_path, i,\r\nrtlefuse->txpwrlevel_cck[rf_path][i],\r\nrtlefuse->txpwrlevel_ht40_1s[rf_path][i],\r\nrtlefuse->txpwrlevel_ht40_2s[rf_path][i]);\r\n}\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (!autoload_fail) {\r\nrtlefuse->eeprom_pwrlimit_ht40[i] =\r\nhwinfo[EEPROM_TXPWR_GROUP + i];\r\nrtlefuse->eeprom_pwrlimit_ht20[i] =\r\nhwinfo[EEPROM_TXPWR_GROUP + 3 + i];\r\n} else {\r\nrtlefuse->eeprom_pwrlimit_ht40[i] = 0;\r\nrtlefuse->eeprom_pwrlimit_ht20[i] = 0;\r\n}\r\n}\r\nfor (rf_path = 0; rf_path < 2; rf_path++) {\r\nfor (i = 0; i < 14; i++) {\r\nindex = _rtl92c_get_chnl_group((u8) i);\r\nif (rf_path == RF90_PATH_A) {\r\nrtlefuse->pwrgroup_ht20[rf_path][i] =\r\n(rtlefuse->eeprom_pwrlimit_ht20[index]\r\n& 0xf);\r\nrtlefuse->pwrgroup_ht40[rf_path][i] =\r\n(rtlefuse->eeprom_pwrlimit_ht40[index]\r\n& 0xf);\r\n} else if (rf_path == RF90_PATH_B) {\r\nrtlefuse->pwrgroup_ht20[rf_path][i] =\r\n((rtlefuse->eeprom_pwrlimit_ht20[index]\r\n& 0xf0) >> 4);\r\nrtlefuse->pwrgroup_ht40[rf_path][i] =\r\n((rtlefuse->eeprom_pwrlimit_ht40[index]\r\n& 0xf0) >> 4);\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF-%d pwrgroup_ht20[%d] = 0x%x\n",\r\nrf_path, i,\r\nrtlefuse->pwrgroup_ht20[rf_path][i]);\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF-%d pwrgroup_ht40[%d] = 0x%x\n",\r\nrf_path, i,\r\nrtlefuse->pwrgroup_ht40[rf_path][i]);\r\n}\r\n}\r\nfor (i = 0; i < 14; i++) {\r\nindex = _rtl92c_get_chnl_group((u8) i);\r\nif (!autoload_fail)\r\ntempval = hwinfo[EEPROM_TXPOWERHT20DIFF + index];\r\nelse\r\ntempval = EEPROM_DEFAULT_HT20_DIFF;\r\nrtlefuse->txpwr_ht20diff[RF90_PATH_A][i] = (tempval & 0xF);\r\nrtlefuse->txpwr_ht20diff[RF90_PATH_B][i] =\r\n((tempval >> 4) & 0xF);\r\nif (rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] & BIT(3))\r\nrtlefuse->txpwr_ht20diff[RF90_PATH_A][i] |= 0xF0;\r\nif (rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] & BIT(3))\r\nrtlefuse->txpwr_ht20diff[RF90_PATH_B][i] |= 0xF0;\r\nindex = _rtl92c_get_chnl_group((u8) i);\r\nif (!autoload_fail)\r\ntempval = hwinfo[EEPROM_TXPOWER_OFDMDIFF + index];\r\nelse\r\ntempval = EEPROM_DEFAULT_LEGACYHTTXPOWERDIFF;\r\nrtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i] = (tempval & 0xF);\r\nrtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i] =\r\n((tempval >> 4) & 0xF);\r\n}\r\nrtlefuse->legacy_ht_txpowerdiff =\r\nrtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][7];\r\nfor (i = 0; i < 14; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF-A Ht20 to HT40 Diff[%d] = 0x%x\n",\r\ni, rtlefuse->txpwr_ht20diff[RF90_PATH_A][i]);\r\nfor (i = 0; i < 14; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF-A Legacy to Ht40 Diff[%d] = 0x%x\n",\r\ni, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i]);\r\nfor (i = 0; i < 14; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF-B Ht20 to HT40 Diff[%d] = 0x%x\n",\r\ni, rtlefuse->txpwr_ht20diff[RF90_PATH_B][i]);\r\nfor (i = 0; i < 14; i++)\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"RF-B Legacy to HT40 Diff[%d] = 0x%x\n",\r\ni, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i]);\r\nif (!autoload_fail)\r\nrtlefuse->eeprom_regulatory = (hwinfo[RF_OPTION1] & 0x7);\r\nelse\r\nrtlefuse->eeprom_regulatory = 0;\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"eeprom_regulatory = 0x%x\n", rtlefuse->eeprom_regulatory);\r\nif (!autoload_fail) {\r\nrtlefuse->eeprom_tssi[RF90_PATH_A] = hwinfo[EEPROM_TSSI_A];\r\nrtlefuse->eeprom_tssi[RF90_PATH_B] = hwinfo[EEPROM_TSSI_B];\r\n} else {\r\nrtlefuse->eeprom_tssi[RF90_PATH_A] = EEPROM_DEFAULT_TSSI;\r\nrtlefuse->eeprom_tssi[RF90_PATH_B] = EEPROM_DEFAULT_TSSI;\r\n}\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower, "TSSI_A = 0x%x, TSSI_B = 0x%x\n",\r\nrtlefuse->eeprom_tssi[RF90_PATH_A],\r\nrtlefuse->eeprom_tssi[RF90_PATH_B]);\r\nif (!autoload_fail)\r\ntempval = hwinfo[EEPROM_THERMAL_METER];\r\nelse\r\ntempval = EEPROM_DEFAULT_THERMALMETER;\r\nrtlefuse->eeprom_thermalmeter = (tempval & 0x1f);\r\nif (rtlefuse->eeprom_thermalmeter == 0x1f || autoload_fail)\r\nrtlefuse->apk_thermalmeterignore = true;\r\nrtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;\r\nRTPRINT(rtlpriv, FINIT, INIT_TxPower,\r\n"thermalmeter = 0x%x\n", rtlefuse->eeprom_thermalmeter);\r\n}\r\nstatic void _rtl92ce_read_adapter_info(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu16 i, usvalue;\r\nu8 hwinfo[HWSET_MAX_SIZE];\r\nu16 eeprom_id;\r\nif (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {\r\nrtl_efuse_shadow_map_update(hw);\r\nmemcpy((void *)hwinfo,\r\n(void *)&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\r\nHWSET_MAX_SIZE);\r\n} else if (rtlefuse->epromtype == EEPROM_93C46) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"RTL819X Not boot from eeprom, check it !!");\r\n}\r\nRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, "MAP",\r\nhwinfo, HWSET_MAX_SIZE);\r\neeprom_id = *((u16 *)&hwinfo[0]);\r\nif (eeprom_id != RTL8190_EEPROM_ID) {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,\r\n"EEPROM ID(%#x) is invalid!!\n", eeprom_id);\r\nrtlefuse->autoload_failflag = true;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");\r\nrtlefuse->autoload_failflag = false;\r\n}\r\nif (rtlefuse->autoload_failflag)\r\nreturn;\r\nfor (i = 0; i < 6; i += 2) {\r\nusvalue = *(u16 *)&hwinfo[EEPROM_MAC_ADDR + i];\r\n*((u16 *) (&rtlefuse->dev_addr[i])) = usvalue;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "%pM\n", rtlefuse->dev_addr);\r\n_rtl92ce_read_txpower_info_from_hwpg(hw,\r\nrtlefuse->autoload_failflag,\r\nhwinfo);\r\nrtl8192ce_read_bt_coexist_info_from_hwpg(hw,\r\nrtlefuse->autoload_failflag,\r\nhwinfo);\r\nrtlefuse->eeprom_channelplan = *(u8 *)&hwinfo[EEPROM_CHANNELPLAN];\r\nrtlefuse->eeprom_version = *(u16 *)&hwinfo[EEPROM_VERSION];\r\nrtlefuse->txpwr_fromeprom = true;\r\nrtlefuse->eeprom_oemid = *(u8 *)&hwinfo[EEPROM_CUSTOMER_ID];\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,\r\n"EEPROM Customer ID: 0x%2x\n", rtlefuse->eeprom_oemid);\r\nrtlefuse->channel_plan = COUNTRY_CODE_WORLD_WIDE_13;\r\nif (rtlhal->oem_id == RT_CID_DEFAULT) {\r\nswitch (rtlefuse->eeprom_oemid) {\r\ncase EEPROM_CID_DEFAULT:\r\nif (rtlefuse->eeprom_did == 0x8176) {\r\nif ((rtlefuse->eeprom_svid == 0x103C &&\r\nrtlefuse->eeprom_smid == 0x1629))\r\nrtlhal->oem_id = RT_CID_819x_HP;\r\nelse\r\nrtlhal->oem_id = RT_CID_DEFAULT;\r\n} else {\r\nrtlhal->oem_id = RT_CID_DEFAULT;\r\n}\r\nbreak;\r\ncase EEPROM_CID_TOSHIBA:\r\nrtlhal->oem_id = RT_CID_TOSHIBA;\r\nbreak;\r\ncase EEPROM_CID_QMI:\r\nrtlhal->oem_id = RT_CID_819x_QMI;\r\nbreak;\r\ncase EEPROM_CID_WHQL:\r\ndefault:\r\nrtlhal->oem_id = RT_CID_DEFAULT;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void _rtl92ce_hal_customized_behavior(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nswitch (rtlhal->oem_id) {\r\ncase RT_CID_819x_HP:\r\npcipriv->ledctl.led_opendrain = true;\r\nbreak;\r\ncase RT_CID_819x_Lenovo:\r\ncase RT_CID_DEFAULT:\r\ncase RT_CID_TOSHIBA:\r\ncase RT_CID_CCX:\r\ncase RT_CID_819x_Acer:\r\ncase RT_CID_WHQL:\r\ndefault:\r\nbreak;\r\n}\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG,\r\n"RT Customized ID: 0x%02X\n", rtlhal->oem_id);\r\n}\r\nvoid rtl92ce_read_eeprom_info(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu8 tmp_u1b;\r\nrtlhal->version = _rtl92ce_read_chip_version(hw);\r\nif (get_rf_type(rtlphy) == RF_1T1R)\r\nrtlpriv->dm.rfpath_rxenable[0] = true;\r\nelse\r\nrtlpriv->dm.rfpath_rxenable[0] =\r\nrtlpriv->dm.rfpath_rxenable[1] = true;\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "VersionID = 0x%4x\n",\r\nrtlhal->version);\r\ntmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);\r\nif (tmp_u1b & BIT(4)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EEPROM\n");\r\nrtlefuse->epromtype = EEPROM_93C46;\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EFUSE\n");\r\nrtlefuse->epromtype = EEPROM_BOOT_EFUSE;\r\n}\r\nif (tmp_u1b & BIT(5)) {\r\nRT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");\r\nrtlefuse->autoload_failflag = false;\r\n_rtl92ce_read_adapter_info(hw);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Autoload ERR!!\n");\r\n}\r\n_rtl92ce_hal_customized_behavior(hw);\r\n}\r\nstatic void rtl92ce_update_hal_rate_table(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nu32 ratr_value;\r\nu8 ratr_index = 0;\r\nu8 nmode = mac->ht_enable;\r\nu8 mimo_ps = IEEE80211_SMPS_OFF;\r\nu16 shortgi_rate;\r\nu32 tmp_ratr_value;\r\nu8 curtxbw_40mhz = mac->bw_40;\r\nu8 curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\r\n1 : 0;\r\nu8 curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\r\n1 : 0;\r\nenum wireless_mode wirelessmode = mac->mode;\r\nif (rtlhal->current_bandtype == BAND_ON_5G)\r\nratr_value = sta->supp_rates[1] << 4;\r\nelse\r\nratr_value = sta->supp_rates[0];\r\nratr_value |= (sta->ht_cap.mcs.rx_mask[1] << 20 |\r\nsta->ht_cap.mcs.rx_mask[0] << 12);\r\nswitch (wirelessmode) {\r\ncase WIRELESS_MODE_B:\r\nif (ratr_value & 0x0000000c)\r\nratr_value &= 0x0000000d;\r\nelse\r\nratr_value &= 0x0000000f;\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nratr_value &= 0x00000FF5;\r\nbreak;\r\ncase WIRELESS_MODE_N_24G:\r\ncase WIRELESS_MODE_N_5G:\r\nnmode = 1;\r\nif (mimo_ps == IEEE80211_SMPS_STATIC) {\r\nratr_value &= 0x0007F005;\r\n} else {\r\nu32 ratr_mask;\r\nif (get_rf_type(rtlphy) == RF_1T2R ||\r\nget_rf_type(rtlphy) == RF_1T1R)\r\nratr_mask = 0x000ff005;\r\nelse\r\nratr_mask = 0x0f0ff005;\r\nratr_value &= ratr_mask;\r\n}\r\nbreak;\r\ndefault:\r\nif (rtlphy->rf_type == RF_1T2R)\r\nratr_value &= 0x000ff0ff;\r\nelse\r\nratr_value &= 0x0f0ff0ff;\r\nbreak;\r\n}\r\nif ((rtlpcipriv->bt_coexist.bt_coexistence) &&\r\n(rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4) &&\r\n(rtlpcipriv->bt_coexist.bt_cur_state) &&\r\n(rtlpcipriv->bt_coexist.bt_ant_isolation) &&\r\n((rtlpcipriv->bt_coexist.bt_service == BT_SCO) ||\r\n(rtlpcipriv->bt_coexist.bt_service == BT_BUSY)))\r\nratr_value &= 0x0fffcfc0;\r\nelse\r\nratr_value &= 0x0FFFFFFF;\r\nif (nmode && ((curtxbw_40mhz &&\r\ncurshortgi_40mhz) || (!curtxbw_40mhz &&\r\ncurshortgi_20mhz))) {\r\nratr_value |= 0x10000000;\r\ntmp_ratr_value = (ratr_value >> 12);\r\nfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\r\nif ((1 << shortgi_rate) & tmp_ratr_value)\r\nbreak;\r\n}\r\nshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\r\n(shortgi_rate << 4) | (shortgi_rate);\r\n}\r\nrtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG, "%x\n",\r\nrtl_read_dword(rtlpriv, REG_ARFR0));\r\n}\r\nstatic void rtl92ce_update_hal_rate_mask(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta, u8 rssi_level)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\r\nstruct rtl_sta_info *sta_entry = NULL;\r\nu32 ratr_bitmap;\r\nu8 ratr_index;\r\nu8 curtxbw_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)\r\n? 1 : 0;\r\nu8 curshortgi_40mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\r\n1 : 0;\r\nu8 curshortgi_20mhz = (sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\r\n1 : 0;\r\nenum wireless_mode wirelessmode = 0;\r\nbool shortgi = false;\r\nu8 rate_mask[5];\r\nu8 macid = 0;\r\nu8 mimo_ps = IEEE80211_SMPS_OFF;\r\nsta_entry = (struct rtl_sta_info *) sta->drv_priv;\r\nwirelessmode = sta_entry->wireless_mode;\r\nif (mac->opmode == NL80211_IFTYPE_STATION)\r\ncurtxbw_40mhz = mac->bw_40;\r\nelse if (mac->opmode == NL80211_IFTYPE_AP ||\r\nmac->opmode == NL80211_IFTYPE_ADHOC)\r\nmacid = sta->aid + 1;\r\nif (rtlhal->current_bandtype == BAND_ON_5G)\r\nratr_bitmap = sta->supp_rates[1] << 4;\r\nelse\r\nratr_bitmap = sta->supp_rates[0];\r\nratr_bitmap |= (sta->ht_cap.mcs.rx_mask[1] << 20 |\r\nsta->ht_cap.mcs.rx_mask[0] << 12);\r\nswitch (wirelessmode) {\r\ncase WIRELESS_MODE_B:\r\nratr_index = RATR_INX_WIRELESS_B;\r\nif (ratr_bitmap & 0x0000000c)\r\nratr_bitmap &= 0x0000000d;\r\nelse\r\nratr_bitmap &= 0x0000000f;\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nratr_index = RATR_INX_WIRELESS_GB;\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x00000f00;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x00000ff0;\r\nelse\r\nratr_bitmap &= 0x00000ff5;\r\nbreak;\r\ncase WIRELESS_MODE_A:\r\nratr_index = RATR_INX_WIRELESS_A;\r\nratr_bitmap &= 0x00000ff0;\r\nbreak;\r\ncase WIRELESS_MODE_N_24G:\r\ncase WIRELESS_MODE_N_5G:\r\nratr_index = RATR_INX_WIRELESS_NGB;\r\nif (mimo_ps == IEEE80211_SMPS_STATIC) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x00070000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x0007f000;\r\nelse\r\nratr_bitmap &= 0x0007f005;\r\n} else {\r\nif (rtlphy->rf_type == RF_1T2R ||\r\nrtlphy->rf_type == RF_1T1R) {\r\nif (curtxbw_40mhz) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x000f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x000ff000;\r\nelse\r\nratr_bitmap &= 0x000ff015;\r\n} else {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x000f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x000ff000;\r\nelse\r\nratr_bitmap &= 0x000ff005;\r\n}\r\n} else {\r\nif (curtxbw_40mhz) {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x0f0f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x0f0ff000;\r\nelse\r\nratr_bitmap &= 0x0f0ff015;\r\n} else {\r\nif (rssi_level == 1)\r\nratr_bitmap &= 0x0f0f0000;\r\nelse if (rssi_level == 2)\r\nratr_bitmap &= 0x0f0ff000;\r\nelse\r\nratr_bitmap &= 0x0f0ff005;\r\n}\r\n}\r\n}\r\nif ((curtxbw_40mhz && curshortgi_40mhz) ||\r\n(!curtxbw_40mhz && curshortgi_20mhz)) {\r\nif (macid == 0)\r\nshortgi = true;\r\nelse if (macid == 1)\r\nshortgi = false;\r\n}\r\nbreak;\r\ndefault:\r\nratr_index = RATR_INX_WIRELESS_NGB;\r\nif (rtlphy->rf_type == RF_1T2R)\r\nratr_bitmap &= 0x000ff0ff;\r\nelse\r\nratr_bitmap &= 0x0f0ff0ff;\r\nbreak;\r\n}\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,\r\n"ratr_bitmap :%x\n", ratr_bitmap);\r\n*(u32 *)&rate_mask = EF4BYTE((ratr_bitmap & 0x0fffffff) |\r\n(ratr_index << 28));\r\nrate_mask[4] = macid | (shortgi ? 0x20 : 0x00) | 0x80;\r\nRT_TRACE(rtlpriv, COMP_RATR, DBG_DMESG,\r\n"Rate_index:%x, ratr_val:%x, %x:%x:%x:%x:%x\n",\r\nratr_index, ratr_bitmap,\r\nrate_mask[0], rate_mask[1], rate_mask[2], rate_mask[3],\r\nrate_mask[4]);\r\nrtl92c_fill_h2c_cmd(hw, H2C_RA_MASK, 5, rate_mask);\r\nif (macid != 0)\r\nsta_entry->ratr_index = ratr_index;\r\n}\r\nvoid rtl92ce_update_hal_rate_tbl(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta, u8 rssi_level)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nif (rtlpriv->dm.useramask)\r\nrtl92ce_update_hal_rate_mask(hw, sta, rssi_level);\r\nelse\r\nrtl92ce_update_hal_rate_table(hw, sta);\r\n}\r\nvoid rtl92ce_update_channel_access_setting(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nu16 sifs_timer;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\r\n(u8 *)&mac->slot_time);\r\nif (!mac->ht_enable)\r\nsifs_timer = 0x0a0a;\r\nelse\r\nsifs_timer = 0x1010;\r\nrtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);\r\n}\r\nbool rtl92ce_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 *valid)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\r\nstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\r\nenum rf_pwrstate e_rfpowerstate_toset;\r\nu8 u1tmp;\r\nbool actuallyset = false;\r\nunsigned long flag;\r\nif (rtlpci->being_init_adapter)\r\nreturn false;\r\nif (ppsc->swrf_processing)\r\nreturn false;\r\nspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\r\nif (ppsc->rfchange_inprogress) {\r\nspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\r\nreturn false;\r\n} else {\r\nppsc->rfchange_inprogress = true;\r\nspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\r\n}\r\nrtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG, rtl_read_byte(rtlpriv,\r\nREG_MAC_PINMUX_CFG)&~(BIT(3)));\r\nu1tmp = rtl_read_byte(rtlpriv, REG_GPIO_IO_SEL);\r\ne_rfpowerstate_toset = (u1tmp & BIT(3)) ? ERFON : ERFOFF;\r\nif ((ppsc->hwradiooff) && (e_rfpowerstate_toset == ERFON)) {\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,\r\n"GPIOChangeRF - HW Radio ON, RF ON\n");\r\ne_rfpowerstate_toset = ERFON;\r\nppsc->hwradiooff = false;\r\nactuallyset = true;\r\n} else if (!ppsc->hwradiooff && (e_rfpowerstate_toset == ERFOFF)) {\r\nRT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,\r\n"GPIOChangeRF - HW Radio OFF, RF OFF\n");\r\ne_rfpowerstate_toset = ERFOFF;\r\nppsc->hwradiooff = true;\r\nactuallyset = true;\r\n}\r\nif (actuallyset) {\r\nspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\r\nppsc->rfchange_inprogress = false;\r\nspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\r\n} else {\r\nif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC)\r\nRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\r\nspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\r\nppsc->rfchange_inprogress = false;\r\nspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\r\n}\r\n*valid = 1;\r\nreturn !ppsc->hwradiooff;\r\n}\r\nvoid rtl92ce_set_key(struct ieee80211_hw *hw, u32 key_index,\r\nu8 *p_macaddr, bool is_group, u8 enc_algo,\r\nbool is_wepkey, bool clear_all)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\r\nstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\r\nu8 *macaddr = p_macaddr;\r\nu32 entry_id = 0;\r\nbool is_pairwise = false;\r\nstatic u8 cam_const_addr[4][6] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\r\n};\r\nstatic u8 cam_const_broad[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff\r\n};\r\nif (clear_all) {\r\nu8 idx = 0;\r\nu8 cam_offset = 0;\r\nu8 clear_number = 5;\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "clear_all\n");\r\nfor (idx = 0; idx < clear_number; idx++) {\r\nrtl_cam_mark_invalid(hw, cam_offset + idx);\r\nrtl_cam_empty_entry(hw, cam_offset + idx);\r\nif (idx < 5) {\r\nmemset(rtlpriv->sec.key_buf[idx], 0,\r\nMAX_KEY_LEN);\r\nrtlpriv->sec.key_len[idx] = 0;\r\n}\r\n}\r\n} else {\r\nswitch (enc_algo) {\r\ncase WEP40_ENCRYPTION:\r\nenc_algo = CAM_WEP40;\r\nbreak;\r\ncase WEP104_ENCRYPTION:\r\nenc_algo = CAM_WEP104;\r\nbreak;\r\ncase TKIP_ENCRYPTION:\r\nenc_algo = CAM_TKIP;\r\nbreak;\r\ncase AESCCMP_ENCRYPTION:\r\nenc_algo = CAM_AES;\r\nbreak;\r\ndefault:\r\nRT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,\r\n"switch case not processed\n");\r\nenc_algo = CAM_TKIP;\r\nbreak;\r\n}\r\nif (is_wepkey || rtlpriv->sec.use_defaultkey) {\r\nmacaddr = cam_const_addr[key_index];\r\nentry_id = key_index;\r\n} else {\r\nif (is_group) {\r\nmacaddr = cam_const_broad;\r\nentry_id = key_index;\r\n} else {\r\nif (mac->opmode == NL80211_IFTYPE_AP) {\r\nentry_id = rtl_cam_get_free_entry(hw,\r\np_macaddr);\r\nif (entry_id >= TOTAL_CAM_ENTRY) {\r\nRT_TRACE(rtlpriv, COMP_SEC,\r\nDBG_EMERG,\r\n"Can not find free hw security cam entry\n");\r\nreturn;\r\n}\r\n} else {\r\nentry_id = CAM_PAIRWISE_KEY_POSITION;\r\n}\r\nkey_index = PAIRWISE_KEYIDX;\r\nis_pairwise = true;\r\n}\r\n}\r\nif (rtlpriv->sec.key_len[key_index] == 0) {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"delete one entry, entry_id is %d\n",\r\nentry_id);\r\nif (mac->opmode == NL80211_IFTYPE_AP)\r\nrtl_cam_del_entry(hw, p_macaddr);\r\nrtl_cam_delete_one_entry(hw, p_macaddr, entry_id);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"The insert KEY length is %d\n",\r\nrtlpriv->sec.key_len[PAIRWISE_KEYIDX]);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"The insert KEY is %x %x\n",\r\nrtlpriv->sec.key_buf[0][0],\r\nrtlpriv->sec.key_buf[0][1]);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"add one entry\n");\r\nif (is_pairwise) {\r\nRT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_LOUD,\r\n"Pairwise Key content",\r\nrtlpriv->sec.pairwise_key,\r\nrtlpriv->sec.\r\nkey_len[PAIRWISE_KEYIDX]);\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"set Pairwise key\n");\r\nrtl_cam_add_one_entry(hw, macaddr, key_index,\r\nentry_id, enc_algo,\r\nCAM_CONFIG_NO_USEDK,\r\nrtlpriv->sec.\r\nkey_buf[key_index]);\r\n} else {\r\nRT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,\r\n"set group key\n");\r\nif (mac->opmode == NL80211_IFTYPE_ADHOC) {\r\nrtl_cam_add_one_entry(hw,\r\nrtlefuse->dev_addr,\r\nPAIRWISE_KEYIDX,\r\nCAM_PAIRWISE_KEY_POSITION,\r\nenc_algo,\r\nCAM_CONFIG_NO_USEDK,\r\nrtlpriv->sec.key_buf\r\n[entry_id]);\r\n}\r\nrtl_cam_add_one_entry(hw, macaddr, key_index,\r\nentry_id, enc_algo,\r\nCAM_CONFIG_NO_USEDK,\r\nrtlpriv->sec.key_buf[entry_id]);\r\n}\r\n}\r\n}\r\n}\r\nstatic void rtl8192ce_bt_var_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nrtlpcipriv->bt_coexist.bt_coexistence =\r\nrtlpcipriv->bt_coexist.eeprom_bt_coexist;\r\nrtlpcipriv->bt_coexist.bt_ant_num =\r\nrtlpcipriv->bt_coexist.eeprom_bt_ant_num;\r\nrtlpcipriv->bt_coexist.bt_coexist_type =\r\nrtlpcipriv->bt_coexist.eeprom_bt_type;\r\nif (rtlpcipriv->bt_coexist.reg_bt_iso == 2)\r\nrtlpcipriv->bt_coexist.bt_ant_isolation =\r\nrtlpcipriv->bt_coexist.eeprom_bt_ant_isolation;\r\nelse\r\nrtlpcipriv->bt_coexist.bt_ant_isolation =\r\nrtlpcipriv->bt_coexist.reg_bt_iso;\r\nrtlpcipriv->bt_coexist.bt_radio_shared_type =\r\nrtlpcipriv->bt_coexist.eeprom_bt_radio_shared;\r\nif (rtlpcipriv->bt_coexist.bt_coexistence) {\r\nif (rtlpcipriv->bt_coexist.reg_bt_sco == 1)\r\nrtlpcipriv->bt_coexist.bt_service = BT_OTHER_ACTION;\r\nelse if (rtlpcipriv->bt_coexist.reg_bt_sco == 2)\r\nrtlpcipriv->bt_coexist.bt_service = BT_SCO;\r\nelse if (rtlpcipriv->bt_coexist.reg_bt_sco == 4)\r\nrtlpcipriv->bt_coexist.bt_service = BT_BUSY;\r\nelse if (rtlpcipriv->bt_coexist.reg_bt_sco == 5)\r\nrtlpcipriv->bt_coexist.bt_service = BT_OTHERBUSY;\r\nelse\r\nrtlpcipriv->bt_coexist.bt_service = BT_IDLE;\r\nrtlpcipriv->bt_coexist.bt_edca_ul = 0;\r\nrtlpcipriv->bt_coexist.bt_edca_dl = 0;\r\nrtlpcipriv->bt_coexist.bt_rssi_state = 0xff;\r\n}\r\n}\r\nvoid rtl8192ce_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,\r\nbool auto_load_fail, u8 *hwinfo)\r\n{\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nu8 value;\r\nif (!auto_load_fail) {\r\nrtlpcipriv->bt_coexist.eeprom_bt_coexist =\r\n((hwinfo[RF_OPTION1] & 0xe0) >> 5);\r\nvalue = hwinfo[RF_OPTION4];\r\nrtlpcipriv->bt_coexist.eeprom_bt_type = ((value & 0xe) >> 1);\r\nrtlpcipriv->bt_coexist.eeprom_bt_ant_num = (value & 0x1);\r\nrtlpcipriv->bt_coexist.eeprom_bt_ant_isolation =\r\n((value & 0x10) >> 4);\r\nrtlpcipriv->bt_coexist.eeprom_bt_radio_shared =\r\n((value & 0x20) >> 5);\r\n} else {\r\nrtlpcipriv->bt_coexist.eeprom_bt_coexist = 0;\r\nrtlpcipriv->bt_coexist.eeprom_bt_type = BT_2WIRE;\r\nrtlpcipriv->bt_coexist.eeprom_bt_ant_num = ANT_X2;\r\nrtlpcipriv->bt_coexist.eeprom_bt_ant_isolation = 0;\r\nrtlpcipriv->bt_coexist.eeprom_bt_radio_shared = BT_RADIO_SHARED;\r\n}\r\nrtl8192ce_bt_var_init(hw);\r\n}\r\nvoid rtl8192ce_bt_reg_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nrtlpcipriv->bt_coexist.reg_bt_iso = 2;\r\nrtlpcipriv->bt_coexist.reg_bt_sco = 3;\r\nrtlpcipriv->bt_coexist.reg_bt_sco = 0;\r\n}\r\nvoid rtl8192ce_bt_hw_init(struct ieee80211_hw *hw)\r\n{\r\nstruct rtl_priv *rtlpriv = rtl_priv(hw);\r\nstruct rtl_phy *rtlphy = &(rtlpriv->phy);\r\nstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\r\nu8 u1_tmp;\r\nif (rtlpcipriv->bt_coexist.bt_coexistence &&\r\n((rtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC4) ||\r\nrtlpcipriv->bt_coexist.bt_coexist_type == BT_CSR_BC8)) {\r\nif (rtlpcipriv->bt_coexist.bt_ant_isolation)\r\nrtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\r\nu1_tmp = rtl_read_byte(rtlpriv, 0x4fd) &\r\nBIT_OFFSET_LEN_MASK_32(0, 1);\r\nu1_tmp = u1_tmp |\r\n((rtlpcipriv->bt_coexist.bt_ant_isolation == 1) ?\r\n0 : BIT_OFFSET_LEN_MASK_32(1, 1)) |\r\n((rtlpcipriv->bt_coexist.bt_service == BT_SCO) ?\r\n0 : BIT_OFFSET_LEN_MASK_32(2, 1));\r\nrtl_write_byte(rtlpriv, 0x4fd, u1_tmp);\r\nrtl_write_dword(rtlpriv, REG_BT_COEX_TABLE+4, 0xaaaa9aaa);\r\nrtl_write_dword(rtlpriv, REG_BT_COEX_TABLE+8, 0xffbd0040);\r\nrtl_write_dword(rtlpriv, REG_BT_COEX_TABLE+0xc, 0x40000010);\r\nif (rtlphy->rf_type == RF_1T1R) {\r\nu1_tmp = rtl_read_byte(rtlpriv, ROFDM0_TRXPATHENABLE);\r\nu1_tmp &= ~(BIT_OFFSET_LEN_MASK_32(1, 1));\r\nrtl_write_byte(rtlpriv, ROFDM0_TRXPATHENABLE, u1_tmp);\r\nu1_tmp = rtl_read_byte(rtlpriv, ROFDM1_TRXPATHENABLE);\r\nu1_tmp &= ~(BIT_OFFSET_LEN_MASK_32(1, 1));\r\nrtl_write_byte(rtlpriv, ROFDM1_TRXPATHENABLE, u1_tmp);\r\n}\r\n}\r\n}\r\nvoid rtl92ce_suspend(struct ieee80211_hw *hw)\r\n{\r\n}\r\nvoid rtl92ce_resume(struct ieee80211_hw *hw)\r\n{\r\n}
