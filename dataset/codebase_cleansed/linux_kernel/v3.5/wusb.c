static int whc_update_di(struct whc *whc, int idx)\r\n{\r\nint offset = idx / 32;\r\nu32 bit = 1 << (idx % 32);\r\nle_writel(bit, whc->base + WUSBDIBUPDATED + offset);\r\nreturn whci_wait_for(&whc->umc->dev,\r\nwhc->base + WUSBDIBUPDATED + offset, bit, 0,\r\n100, "DI update");\r\n}\r\nint whc_wusbhc_start(struct wusbhc *wusbhc)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nasl_start(whc);\r\npzl_start(whc);\r\nreturn 0;\r\n}\r\nvoid whc_wusbhc_stop(struct wusbhc *wusbhc, int delay)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nu32 stop_time, now_time;\r\nint ret;\r\npzl_stop(whc);\r\nasl_stop(whc);\r\nnow_time = le_readl(whc->base + WUSBTIME) & WUSBTIME_CHANNEL_TIME_MASK;\r\nstop_time = (now_time + ((delay * 8) << 7)) & 0x00ffffff;\r\nret = whc_do_gencmd(whc, WUSBGENCMDSTS_CHAN_STOP, stop_time, NULL, 0);\r\nif (ret == 0)\r\nmsleep(delay);\r\n}\r\nint whc_mmcie_add(struct wusbhc *wusbhc, u8 interval, u8 repeat_cnt,\r\nu8 handle, struct wuie_hdr *wuie)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nu32 params;\r\nparams = (interval << 24)\r\n| (repeat_cnt << 16)\r\n| (wuie->bLength << 8)\r\n| handle;\r\nreturn whc_do_gencmd(whc, WUSBGENCMDSTS_MMCIE_ADD, params, wuie, wuie->bLength);\r\n}\r\nint whc_mmcie_rm(struct wusbhc *wusbhc, u8 handle)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nu32 params;\r\nparams = handle;\r\nreturn whc_do_gencmd(whc, WUSBGENCMDSTS_MMCIE_RM, params, NULL, 0);\r\n}\r\nint whc_bwa_set(struct wusbhc *wusbhc, s8 stream_index, const struct uwb_mas_bm *mas_bm)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nif (stream_index >= 0)\r\nwhc_write_wusbcmd(whc, WUSBCMD_WUSBSI_MASK, WUSBCMD_WUSBSI(stream_index));\r\nreturn whc_do_gencmd(whc, WUSBGENCMDSTS_SET_MAS, 0, (void *)mas_bm, sizeof(*mas_bm));\r\n}\r\nint whc_dev_info_set(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nint idx = wusb_dev->port_idx;\r\nstruct di_buf_entry *di = &whc->di_buf[idx];\r\nint ret;\r\nmutex_lock(&whc->mutex);\r\nuwb_mas_bm_copy_le(di->availability_info, &wusb_dev->availability);\r\ndi->addr_sec_info &= ~(WHC_DI_DISABLE | WHC_DI_DEV_ADDR_MASK);\r\ndi->addr_sec_info |= WHC_DI_DEV_ADDR(wusb_dev->addr);\r\nret = whc_update_di(whc, idx);\r\nmutex_unlock(&whc->mutex);\r\nreturn ret;\r\n}\r\nint whc_set_num_dnts(struct wusbhc *wusbhc, u8 interval, u8 slots)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nu32 dntsctrl;\r\ndntsctrl = WUSBDNTSCTRL_ACTIVE\r\n| WUSBDNTSCTRL_INTERVAL(interval)\r\n| WUSBDNTSCTRL_SLOTS(slots);\r\nle_writel(dntsctrl, whc->base + WUSBDNTSCTRL);\r\nreturn 0;\r\n}\r\nstatic int whc_set_key(struct whc *whc, u8 key_index, uint32_t tkid,\r\nconst void *key, size_t key_size, bool is_gtk)\r\n{\r\nuint32_t setkeycmd;\r\nuint32_t seckey[4];\r\nint i;\r\nint ret;\r\nmemcpy(seckey, key, key_size);\r\nsetkeycmd = WUSBSETSECKEYCMD_SET | WUSBSETSECKEYCMD_IDX(key_index);\r\nif (is_gtk)\r\nsetkeycmd |= WUSBSETSECKEYCMD_GTK;\r\nle_writel(tkid, whc->base + WUSBTKID);\r\nfor (i = 0; i < 4; i++)\r\nle_writel(seckey[i], whc->base + WUSBSECKEY + 4*i);\r\nle_writel(setkeycmd, whc->base + WUSBSETSECKEYCMD);\r\nret = whci_wait_for(&whc->umc->dev, whc->base + WUSBSETSECKEYCMD,\r\nWUSBSETSECKEYCMD_SET, 0, 100, "set key");\r\nreturn ret;\r\n}\r\nint whc_set_ptk(struct wusbhc *wusbhc, u8 port_idx, u32 tkid,\r\nconst void *ptk, size_t key_size)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nstruct di_buf_entry *di = &whc->di_buf[port_idx];\r\nint ret;\r\nmutex_lock(&whc->mutex);\r\nif (ptk) {\r\nret = whc_set_key(whc, port_idx, tkid, ptk, key_size, false);\r\nif (ret)\r\ngoto out;\r\ndi->addr_sec_info &= ~WHC_DI_KEY_IDX_MASK;\r\ndi->addr_sec_info |= WHC_DI_SECURE | WHC_DI_KEY_IDX(port_idx);\r\n} else\r\ndi->addr_sec_info &= ~WHC_DI_SECURE;\r\nret = whc_update_di(whc, port_idx);\r\nout:\r\nmutex_unlock(&whc->mutex);\r\nreturn ret;\r\n}\r\nint whc_set_gtk(struct wusbhc *wusbhc, u32 tkid,\r\nconst void *gtk, size_t key_size)\r\n{\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nint ret;\r\nmutex_lock(&whc->mutex);\r\nret = whc_set_key(whc, whc->n_devices, tkid, gtk, key_size, true);\r\nmutex_unlock(&whc->mutex);\r\nreturn ret;\r\n}\r\nint whc_set_cluster_id(struct whc *whc, u8 bcid)\r\n{\r\nwhc_write_wusbcmd(whc, WUSBCMD_BCID_MASK, WUSBCMD_BCID(bcid));\r\nreturn 0;\r\n}
