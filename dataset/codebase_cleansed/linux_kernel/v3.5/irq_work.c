static bool irq_work_claim(struct irq_work *work)\r\n{\r\nunsigned long flags, nflags;\r\nfor (;;) {\r\nflags = work->flags;\r\nif (flags & IRQ_WORK_PENDING)\r\nreturn false;\r\nnflags = flags | IRQ_WORK_FLAGS;\r\nif (cmpxchg(&work->flags, flags, nflags) == flags)\r\nbreak;\r\ncpu_relax();\r\n}\r\nreturn true;\r\n}\r\nvoid __weak arch_irq_work_raise(void)\r\n{\r\n}\r\nstatic void __irq_work_queue(struct irq_work *work)\r\n{\r\nbool empty;\r\npreempt_disable();\r\nempty = llist_add(&work->llnode, &__get_cpu_var(irq_work_list));\r\nif (empty)\r\narch_irq_work_raise();\r\npreempt_enable();\r\n}\r\nbool irq_work_queue(struct irq_work *work)\r\n{\r\nif (!irq_work_claim(work)) {\r\nreturn false;\r\n}\r\n__irq_work_queue(work);\r\nreturn true;\r\n}\r\nvoid irq_work_run(void)\r\n{\r\nstruct irq_work *work;\r\nstruct llist_head *this_list;\r\nstruct llist_node *llnode;\r\nthis_list = &__get_cpu_var(irq_work_list);\r\nif (llist_empty(this_list))\r\nreturn;\r\nBUG_ON(!in_irq());\r\nBUG_ON(!irqs_disabled());\r\nllnode = llist_del_all(this_list);\r\nwhile (llnode != NULL) {\r\nwork = llist_entry(llnode, struct irq_work, llnode);\r\nllnode = llist_next(llnode);\r\nwork->flags = IRQ_WORK_BUSY;\r\nwork->func(work);\r\n(void)cmpxchg(&work->flags, IRQ_WORK_BUSY, 0);\r\n}\r\n}\r\nvoid irq_work_sync(struct irq_work *work)\r\n{\r\nWARN_ON_ONCE(irqs_disabled());\r\nwhile (work->flags & IRQ_WORK_BUSY)\r\ncpu_relax();\r\n}
