static inline void fm_irq_call(struct fmdev *fmdev)\r\n{\r\nfmdev->irq_info.handlers[fmdev->irq_info.stage](fmdev);\r\n}\r\nstatic inline void fm_irq_call_stage(struct fmdev *fmdev, u8 stage)\r\n{\r\nfmdev->irq_info.stage = stage;\r\nfm_irq_call(fmdev);\r\n}\r\nstatic inline void fm_irq_timeout_stage(struct fmdev *fmdev, u8 stage)\r\n{\r\nfmdev->irq_info.stage = stage;\r\nmod_timer(&fmdev->irq_info.timer, jiffies + FM_DRV_TX_TIMEOUT);\r\n}\r\ninline void dump_tx_skb_data(struct sk_buff *skb)\r\n{\r\nint len, len_org;\r\nu8 index;\r\nstruct fm_cmd_msg_hdr *cmd_hdr;\r\ncmd_hdr = (struct fm_cmd_msg_hdr *)skb->data;\r\nprintk(KERN_INFO "<<%shdr:%02x len:%02x opcode:%02x type:%s dlen:%02x",\r\nfm_cb(skb)->completion ? " " : "*", cmd_hdr->hdr,\r\ncmd_hdr->len, cmd_hdr->op,\r\ncmd_hdr->rd_wr ? "RD" : "WR", cmd_hdr->dlen);\r\nlen_org = skb->len - FM_CMD_MSG_HDR_SIZE;\r\nif (len_org > 0) {\r\nprintk("\n data(%d): ", cmd_hdr->dlen);\r\nlen = min(len_org, 14);\r\nfor (index = 0; index < len; index++)\r\nprintk("%x ",\r\nskb->data[FM_CMD_MSG_HDR_SIZE + index]);\r\nprintk("%s", (len_org > 14) ? ".." : "");\r\n}\r\nprintk("\n");\r\n}\r\ninline void dump_rx_skb_data(struct sk_buff *skb)\r\n{\r\nint len, len_org;\r\nu8 index;\r\nstruct fm_event_msg_hdr *evt_hdr;\r\nevt_hdr = (struct fm_event_msg_hdr *)skb->data;\r\nprintk(KERN_INFO ">> hdr:%02x len:%02x sts:%02x numhci:%02x "\r\n"opcode:%02x type:%s dlen:%02x", evt_hdr->hdr, evt_hdr->len,\r\nevt_hdr->status, evt_hdr->num_fm_hci_cmds, evt_hdr->op,\r\n(evt_hdr->rd_wr) ? "RD" : "WR", evt_hdr->dlen);\r\nlen_org = skb->len - FM_EVT_MSG_HDR_SIZE;\r\nif (len_org > 0) {\r\nprintk("\n data(%d): ", evt_hdr->dlen);\r\nlen = min(len_org, 14);\r\nfor (index = 0; index < len; index++)\r\nprintk("%x ",\r\nskb->data[FM_EVT_MSG_HDR_SIZE + index]);\r\nprintk("%s", (len_org > 14) ? ".." : "");\r\n}\r\nprintk("\n");\r\n}\r\nvoid fmc_update_region_info(struct fmdev *fmdev, u8 region_to_set)\r\n{\r\nfmdev->rx.region = region_configs[region_to_set];\r\n}\r\nstatic void recv_tasklet(unsigned long arg)\r\n{\r\nstruct fmdev *fmdev;\r\nstruct fm_irq *irq_info;\r\nstruct fm_event_msg_hdr *evt_hdr;\r\nstruct sk_buff *skb;\r\nu8 num_fm_hci_cmds;\r\nunsigned long flags;\r\nfmdev = (struct fmdev *)arg;\r\nirq_info = &fmdev->irq_info;\r\nwhile ((skb = skb_dequeue(&fmdev->rx_q))) {\r\nif (skb->len < sizeof(struct fm_event_msg_hdr)) {\r\nfmerr("skb(%p) has only %d bytes, "\r\n"at least need %zu bytes to decode\n", skb,\r\nskb->len, sizeof(struct fm_event_msg_hdr));\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\nevt_hdr = (void *)skb->data;\r\nnum_fm_hci_cmds = evt_hdr->num_fm_hci_cmds;\r\nif (evt_hdr->op == FM_INTERRUPT) {\r\nif (!test_bit(FM_INTTASK_RUNNING, &fmdev->flag)) {\r\nset_bit(FM_INTTASK_RUNNING, &fmdev->flag);\r\nif (irq_info->stage != 0) {\r\nfmerr("Inval stage resetting to zero\n");\r\nirq_info->stage = 0;\r\n}\r\nirq_info->handlers[irq_info->stage](fmdev);\r\n} else {\r\nset_bit(FM_INTTASK_SCHEDULE_PENDING, &fmdev->flag);\r\n}\r\nkfree_skb(skb);\r\n}\r\nelse if (evt_hdr->op == fmdev->pre_op && fmdev->resp_comp != NULL) {\r\nspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\r\nfmdev->resp_skb = skb;\r\nspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\r\ncomplete(fmdev->resp_comp);\r\nfmdev->resp_comp = NULL;\r\natomic_set(&fmdev->tx_cnt, 1);\r\n}\r\nelse if (evt_hdr->op == fmdev->pre_op && fmdev->resp_comp == NULL) {\r\nif (fmdev->resp_skb != NULL)\r\nfmerr("Response SKB ptr not NULL\n");\r\nspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\r\nfmdev->resp_skb = skb;\r\nspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\r\nirq_info->handlers[irq_info->stage](fmdev);\r\nkfree_skb(skb);\r\natomic_set(&fmdev->tx_cnt, 1);\r\n} else {\r\nfmerr("Nobody claimed SKB(%p),purging\n", skb);\r\n}\r\nif (num_fm_hci_cmds && atomic_read(&fmdev->tx_cnt))\r\nif (!skb_queue_empty(&fmdev->tx_q))\r\ntasklet_schedule(&fmdev->tx_task);\r\n}\r\n}\r\nstatic void send_tasklet(unsigned long arg)\r\n{\r\nstruct fmdev *fmdev;\r\nstruct sk_buff *skb;\r\nint len;\r\nfmdev = (struct fmdev *)arg;\r\nif (!atomic_read(&fmdev->tx_cnt))\r\nreturn;\r\nif ((jiffies - fmdev->last_tx_jiffies) > FM_DRV_TX_TIMEOUT) {\r\nfmerr("TX timeout occurred\n");\r\natomic_set(&fmdev->tx_cnt, 1);\r\n}\r\nskb = skb_dequeue(&fmdev->tx_q);\r\nif (!skb)\r\nreturn;\r\natomic_dec(&fmdev->tx_cnt);\r\nfmdev->pre_op = fm_cb(skb)->fm_op;\r\nif (fmdev->resp_comp != NULL)\r\nfmerr("Response completion handler is not NULL\n");\r\nfmdev->resp_comp = fm_cb(skb)->completion;\r\nlen = g_st_write(skb);\r\nif (len < 0) {\r\nkfree_skb(skb);\r\nfmdev->resp_comp = NULL;\r\nfmerr("TX tasklet failed to send skb(%p)\n", skb);\r\natomic_set(&fmdev->tx_cnt, 1);\r\n} else {\r\nfmdev->last_tx_jiffies = jiffies;\r\n}\r\n}\r\nstatic int fm_send_cmd(struct fmdev *fmdev, u8 fm_op, u16 type, void *payload,\r\nint payload_len, struct completion *wait_completion)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fm_cmd_msg_hdr *hdr;\r\nint size;\r\nif (fm_op >= FM_INTERRUPT) {\r\nfmerr("Invalid fm opcode - %d\n", fm_op);\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(FM_FW_DW_INPROGRESS, &fmdev->flag) && payload == NULL) {\r\nfmerr("Payload data is NULL during fw download\n");\r\nreturn -EINVAL;\r\n}\r\nif (!test_bit(FM_FW_DW_INPROGRESS, &fmdev->flag))\r\nsize =\r\nFM_CMD_MSG_HDR_SIZE + ((payload == NULL) ? 0 : payload_len);\r\nelse\r\nsize = payload_len;\r\nskb = alloc_skb(size, GFP_ATOMIC);\r\nif (!skb) {\r\nfmerr("No memory to create new SKB\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!test_bit(FM_FW_DW_INPROGRESS, &fmdev->flag) ||\r\ntest_bit(FM_INTTASK_RUNNING, &fmdev->flag)) {\r\nhdr = (struct fm_cmd_msg_hdr *)skb_put(skb, FM_CMD_MSG_HDR_SIZE);\r\nhdr->hdr = FM_PKT_LOGICAL_CHAN_NUMBER;\r\nhdr->len = ((payload == NULL) ? 0 : payload_len) + 3;\r\nhdr->op = fm_op;\r\nhdr->rd_wr = type;\r\nhdr->dlen = payload_len;\r\nfm_cb(skb)->fm_op = fm_op;\r\nif (payload != NULL)\r\n*(u16 *)payload = cpu_to_be16(*(u16 *)payload);\r\n} else if (payload != NULL) {\r\nfm_cb(skb)->fm_op = *((u8 *)payload + 2);\r\n}\r\nif (payload != NULL)\r\nmemcpy(skb_put(skb, payload_len), payload, payload_len);\r\nfm_cb(skb)->completion = wait_completion;\r\nskb_queue_tail(&fmdev->tx_q, skb);\r\ntasklet_schedule(&fmdev->tx_task);\r\nreturn 0;\r\n}\r\nint fmc_send_cmd(struct fmdev *fmdev, u8 fm_op, u16 type, void *payload,\r\nunsigned int payload_len, void *response, int *response_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fm_event_msg_hdr *evt_hdr;\r\nunsigned long flags;\r\nint ret;\r\ninit_completion(&fmdev->maintask_comp);\r\nret = fm_send_cmd(fmdev, fm_op, type, payload, payload_len,\r\n&fmdev->maintask_comp);\r\nif (ret)\r\nreturn ret;\r\nif (!wait_for_completion_timeout(&fmdev->maintask_comp,\r\nFM_DRV_TX_TIMEOUT)) {\r\nfmerr("Timeout(%d sec),didn't get reg"\r\n"completion signal from RX tasklet\n",\r\njiffies_to_msecs(FM_DRV_TX_TIMEOUT) / 1000);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!fmdev->resp_skb) {\r\nfmerr("Response SKB is missing\n");\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\r\nskb = fmdev->resp_skb;\r\nfmdev->resp_skb = NULL;\r\nspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\r\nevt_hdr = (void *)skb->data;\r\nif (evt_hdr->status != 0) {\r\nfmerr("Received event pkt status(%d) is not zero\n",\r\nevt_hdr->status);\r\nkfree_skb(skb);\r\nreturn -EIO;\r\n}\r\nif (response != NULL && response_len != NULL && evt_hdr->dlen) {\r\nskb_pull(skb, sizeof(struct fm_event_msg_hdr));\r\nmemcpy(response, skb->data, evt_hdr->dlen);\r\n*response_len = evt_hdr->dlen;\r\n} else if (response_len != NULL && evt_hdr->dlen == 0) {\r\n*response_len = 0;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic inline int check_cmdresp_status(struct fmdev *fmdev,\r\nstruct sk_buff **skb)\r\n{\r\nstruct fm_event_msg_hdr *fm_evt_hdr;\r\nunsigned long flags;\r\ndel_timer(&fmdev->irq_info.timer);\r\nspin_lock_irqsave(&fmdev->resp_skb_lock, flags);\r\n*skb = fmdev->resp_skb;\r\nfmdev->resp_skb = NULL;\r\nspin_unlock_irqrestore(&fmdev->resp_skb_lock, flags);\r\nfm_evt_hdr = (void *)(*skb)->data;\r\nif (fm_evt_hdr->status != 0) {\r\nfmerr("irq: opcode %x response status is not zero "\r\n"Initiating irq recovery process\n",\r\nfm_evt_hdr->op);\r\nmod_timer(&fmdev->irq_info.timer, jiffies + FM_DRV_TX_TIMEOUT);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void fm_irq_common_cmd_resp_helper(struct fmdev *fmdev, u8 stage)\r\n{\r\nstruct sk_buff *skb;\r\nif (!check_cmdresp_status(fmdev, &skb))\r\nfm_irq_call_stage(fmdev, stage);\r\n}\r\nstatic void int_timeout_handler(unsigned long data)\r\n{\r\nstruct fmdev *fmdev;\r\nstruct fm_irq *fmirq;\r\nfmdbg("irq: timeout,trying to re-enable fm interrupts\n");\r\nfmdev = (struct fmdev *)data;\r\nfmirq = &fmdev->irq_info;\r\nfmirq->retry++;\r\nif (fmirq->retry > FM_IRQ_TIMEOUT_RETRY_MAX) {\r\nfmirq->stage = 0;\r\nfmirq->retry = 0;\r\nfmerr("Recovery action failed during"\r\n"irq processing, max retry reached\n");\r\nreturn;\r\n}\r\nfm_irq_call_stage(fmdev, FM_SEND_INTMSK_CMD_IDX);\r\n}\r\nstatic void fm_irq_send_flag_getcmd(struct fmdev *fmdev)\r\n{\r\nu16 flag;\r\nif (!fm_send_cmd(fmdev, FLAG_GET, REG_RD, NULL, sizeof(flag), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_HANDLE_FLAG_GETCMD_RESP_IDX);\r\n}\r\nstatic void fm_irq_handle_flag_getcmd_resp(struct fmdev *fmdev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fm_event_msg_hdr *fm_evt_hdr;\r\nif (check_cmdresp_status(fmdev, &skb))\r\nreturn;\r\nfm_evt_hdr = (void *)skb->data;\r\nskb_pull(skb, sizeof(struct fm_event_msg_hdr));\r\nmemcpy(&fmdev->irq_info.flag, skb->data, fm_evt_hdr->dlen);\r\nfmdev->irq_info.flag = be16_to_cpu(fmdev->irq_info.flag);\r\nfmdbg("irq: flag register(0x%x)\n", fmdev->irq_info.flag);\r\nfm_irq_call_stage(fmdev, FM_HW_MAL_FUNC_IDX);\r\n}\r\nstatic void fm_irq_handle_hw_malfunction(struct fmdev *fmdev)\r\n{\r\nif (fmdev->irq_info.flag & FM_MAL_EVENT & fmdev->irq_info.mask)\r\nfmerr("irq: HW MAL int received - do nothing\n");\r\nfm_irq_call_stage(fmdev, FM_RDS_START_IDX);\r\n}\r\nstatic void fm_irq_handle_rds_start(struct fmdev *fmdev)\r\n{\r\nif (fmdev->irq_info.flag & FM_RDS_EVENT & fmdev->irq_info.mask) {\r\nfmdbg("irq: rds threshold reached\n");\r\nfmdev->irq_info.stage = FM_RDS_SEND_RDS_GETCMD_IDX;\r\n} else {\r\nfmdev->irq_info.stage = FM_HW_TUNE_OP_ENDED_IDX;\r\n}\r\nfm_irq_call(fmdev);\r\n}\r\nstatic void fm_irq_send_rdsdata_getcmd(struct fmdev *fmdev)\r\n{\r\nif (!fm_send_cmd(fmdev, RDS_DATA_GET, REG_RD, NULL,\r\n(FM_RX_RDS_FIFO_THRESHOLD * 3), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_RDS_HANDLE_RDS_GETCMD_RESP_IDX);\r\n}\r\nstatic void fm_rx_update_af_cache(struct fmdev *fmdev, u8 af)\r\n{\r\nstruct tuned_station_info *stat_info = &fmdev->rx.stat_info;\r\nu8 reg_idx = fmdev->rx.region.fm_band;\r\nu8 index;\r\nu32 freq;\r\nif ((af >= FM_RDS_1_AF_FOLLOWS) && (af <= FM_RDS_25_AF_FOLLOWS)) {\r\nfmdev->rx.stat_info.af_list_max = (af - FM_RDS_1_AF_FOLLOWS + 1);\r\nfmdev->rx.stat_info.afcache_size = 0;\r\nfmdbg("No of expected AF : %d\n", fmdev->rx.stat_info.af_list_max);\r\nreturn;\r\n}\r\nif (af < FM_RDS_MIN_AF)\r\nreturn;\r\nif (reg_idx == FM_BAND_EUROPE_US && af > FM_RDS_MAX_AF)\r\nreturn;\r\nif (reg_idx == FM_BAND_JAPAN && af > FM_RDS_MAX_AF_JAPAN)\r\nreturn;\r\nfreq = fmdev->rx.region.bot_freq + (af * 100);\r\nif (freq == fmdev->rx.freq) {\r\nfmdbg("Current freq(%d) is matching with received AF(%d)\n",\r\nfmdev->rx.freq, freq);\r\nreturn;\r\n}\r\nfor (index = 0; index < stat_info->afcache_size; index++) {\r\nif (stat_info->af_cache[index] == freq)\r\nbreak;\r\n}\r\nif (index == stat_info->af_list_max) {\r\nfmdbg("AF cache is full\n");\r\nreturn;\r\n}\r\nif (index == stat_info->afcache_size) {\r\nfmdbg("Storing AF %d to cache index %d\n", freq, index);\r\nstat_info->af_cache[index] = freq;\r\nstat_info->afcache_size++;\r\n}\r\n}\r\nstatic void fm_rdsparse_swapbytes(struct fmdev *fmdev,\r\nstruct fm_rdsdata_format *rds_format)\r\n{\r\nu8 byte1;\r\nu8 index = 0;\r\nu8 *rds_buff;\r\nif (fmdev->asci_id != 0x6350) {\r\nrds_buff = &rds_format->data.groupdatabuff.buff[0];\r\nwhile (index + 1 < FM_RX_RDS_INFO_FIELD_MAX) {\r\nbyte1 = rds_buff[index];\r\nrds_buff[index] = rds_buff[index + 1];\r\nrds_buff[index + 1] = byte1;\r\nindex += 2;\r\n}\r\n}\r\n}\r\nstatic void fm_irq_handle_rdsdata_getcmd_resp(struct fmdev *fmdev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fm_rdsdata_format rds_fmt;\r\nstruct fm_rds *rds = &fmdev->rx.rds;\r\nunsigned long group_idx, flags;\r\nu8 *rds_data, meta_data, tmpbuf[3];\r\nu8 type, blk_idx;\r\nu16 cur_picode;\r\nu32 rds_len;\r\nif (check_cmdresp_status(fmdev, &skb))\r\nreturn;\r\nskb_pull(skb, sizeof(struct fm_event_msg_hdr));\r\nrds_data = skb->data;\r\nrds_len = skb->len;\r\nwhile (rds_len >= FM_RDS_BLK_SIZE) {\r\nmeta_data = rds_data[2];\r\ntype = (meta_data & 0x07);\r\nblk_idx = (type <= FM_RDS_BLOCK_C ? type : (type - 1));\r\nfmdbg("Block index:%d(%s)\n", blk_idx,\r\n(meta_data & FM_RDS_STATUS_ERR_MASK) ? "Bad" : "Ok");\r\nif ((meta_data & FM_RDS_STATUS_ERR_MASK) != 0)\r\nbreak;\r\nif (blk_idx < FM_RDS_BLK_IDX_A || blk_idx > FM_RDS_BLK_IDX_D) {\r\nfmdbg("Block sequence mismatch\n");\r\nrds->last_blk_idx = -1;\r\nbreak;\r\n}\r\nmemcpy(&rds_fmt.data.groupdatabuff.\r\nbuff[blk_idx * (FM_RDS_BLK_SIZE - 1)],\r\nrds_data, (FM_RDS_BLK_SIZE - 1));\r\nrds->last_blk_idx = blk_idx;\r\nif (blk_idx == FM_RDS_BLK_IDX_D) {\r\nfmdbg("Good block received\n");\r\nfm_rdsparse_swapbytes(fmdev, &rds_fmt);\r\ncur_picode = be16_to_cpu(rds_fmt.data.groupgeneral.pidata);\r\nif (fmdev->rx.stat_info.picode != cur_picode)\r\nfmdev->rx.stat_info.picode = cur_picode;\r\nfmdbg("picode:%d\n", cur_picode);\r\ngroup_idx = (rds_fmt.data.groupgeneral.blk_b[0] >> 3);\r\nfmdbg("(fmdrv):Group:%ld%s\n", group_idx/2,\r\n(group_idx % 2) ? "B" : "A");\r\ngroup_idx = 1 << (rds_fmt.data.groupgeneral.blk_b[0] >> 3);\r\nif (group_idx == FM_RDS_GROUP_TYPE_MASK_0A) {\r\nfm_rx_update_af_cache(fmdev, rds_fmt.data.group0A.af[0]);\r\nfm_rx_update_af_cache(fmdev, rds_fmt.data.group0A.af[1]);\r\n}\r\n}\r\nrds_len -= FM_RDS_BLK_SIZE;\r\nrds_data += FM_RDS_BLK_SIZE;\r\n}\r\nrds_data = skb->data;\r\nrds_len = skb->len;\r\nspin_lock_irqsave(&fmdev->rds_buff_lock, flags);\r\nwhile (rds_len > 0) {\r\ntype = (rds_data[2] & 0x07);\r\nblk_idx = (type <= FM_RDS_BLOCK_C ? type : (type - 1));\r\ntmpbuf[2] = blk_idx;\r\ntmpbuf[2] |= blk_idx << 3;\r\ntmpbuf[0] = rds_data[0];\r\ntmpbuf[1] = rds_data[1];\r\nmemcpy(&rds->buff[rds->wr_idx], &tmpbuf, FM_RDS_BLK_SIZE);\r\nrds->wr_idx = (rds->wr_idx + FM_RDS_BLK_SIZE) % rds->buf_size;\r\nif (rds->wr_idx == rds->rd_idx) {\r\nfmdbg("RDS buffer overflow\n");\r\nrds->wr_idx = 0;\r\nrds->rd_idx = 0;\r\nbreak;\r\n}\r\nrds_len -= FM_RDS_BLK_SIZE;\r\nrds_data += FM_RDS_BLK_SIZE;\r\n}\r\nspin_unlock_irqrestore(&fmdev->rds_buff_lock, flags);\r\nif (rds->wr_idx != rds->rd_idx)\r\nwake_up_interruptible(&rds->read_queue);\r\nfm_irq_call_stage(fmdev, FM_RDS_FINISH_IDX);\r\n}\r\nstatic void fm_irq_handle_rds_finish(struct fmdev *fmdev)\r\n{\r\nfm_irq_call_stage(fmdev, FM_HW_TUNE_OP_ENDED_IDX);\r\n}\r\nstatic void fm_irq_handle_tune_op_ended(struct fmdev *fmdev)\r\n{\r\nif (fmdev->irq_info.flag & (FM_FR_EVENT | FM_BL_EVENT) & fmdev->\r\nirq_info.mask) {\r\nfmdbg("irq: tune ended/bandlimit reached\n");\r\nif (test_and_clear_bit(FM_AF_SWITCH_INPROGRESS, &fmdev->flag)) {\r\nfmdev->irq_info.stage = FM_AF_JUMP_RD_FREQ_IDX;\r\n} else {\r\ncomplete(&fmdev->maintask_comp);\r\nfmdev->irq_info.stage = FM_HW_POWER_ENB_IDX;\r\n}\r\n} else\r\nfmdev->irq_info.stage = FM_HW_POWER_ENB_IDX;\r\nfm_irq_call(fmdev);\r\n}\r\nstatic void fm_irq_handle_power_enb(struct fmdev *fmdev)\r\n{\r\nif (fmdev->irq_info.flag & FM_POW_ENB_EVENT) {\r\nfmdbg("irq: Power Enabled/Disabled\n");\r\ncomplete(&fmdev->maintask_comp);\r\n}\r\nfm_irq_call_stage(fmdev, FM_LOW_RSSI_START_IDX);\r\n}\r\nstatic void fm_irq_handle_low_rssi_start(struct fmdev *fmdev)\r\n{\r\nif ((fmdev->rx.af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON) &&\r\n(fmdev->irq_info.flag & FM_LEV_EVENT & fmdev->irq_info.mask) &&\r\n(fmdev->rx.freq != FM_UNDEFINED_FREQ) &&\r\n(fmdev->rx.stat_info.afcache_size != 0)) {\r\nfmdbg("irq: rssi level has fallen below threshold level\n");\r\nfmdev->irq_info.mask &= ~FM_LEV_EVENT;\r\nfmdev->rx.afjump_idx = 0;\r\nfmdev->rx.freq_before_jump = fmdev->rx.freq;\r\nfmdev->irq_info.stage = FM_AF_JUMP_SETPI_IDX;\r\n} else {\r\nfmdev->irq_info.stage = FM_SEND_INTMSK_CMD_IDX;\r\n}\r\nfm_irq_call(fmdev);\r\n}\r\nstatic void fm_irq_afjump_set_pi(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\npayload = fmdev->rx.stat_info.picode;\r\nif (!fm_send_cmd(fmdev, RDS_PI_SET, REG_WR, &payload, sizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_SETPI_RESP_IDX);\r\n}\r\nstatic void fm_irq_handle_set_pi_resp(struct fmdev *fmdev)\r\n{\r\nfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_SETPI_MASK_IDX);\r\n}\r\nstatic void fm_irq_afjump_set_pimask(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\npayload = 0x0000;\r\nif (!fm_send_cmd(fmdev, RDS_PI_MASK_SET, REG_WR, &payload, sizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_SETPI_MASK_RESP_IDX);\r\n}\r\nstatic void fm_irq_handle_set_pimask_resp(struct fmdev *fmdev)\r\n{\r\nfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_SET_AF_FREQ_IDX);\r\n}\r\nstatic void fm_irq_afjump_setfreq(struct fmdev *fmdev)\r\n{\r\nu16 frq_index;\r\nu16 payload;\r\nfmdbg("Swtich to %d KHz\n", fmdev->rx.stat_info.af_cache[fmdev->rx.afjump_idx]);\r\nfrq_index = (fmdev->rx.stat_info.af_cache[fmdev->rx.afjump_idx] -\r\nfmdev->rx.region.bot_freq) / FM_FREQ_MUL;\r\npayload = frq_index;\r\nif (!fm_send_cmd(fmdev, AF_FREQ_SET, REG_WR, &payload, sizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_SET_AFFREQ_RESP_IDX);\r\n}\r\nstatic void fm_irq_handle_setfreq_resp(struct fmdev *fmdev)\r\n{\r\nfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_ENABLE_INT_IDX);\r\n}\r\nstatic void fm_irq_afjump_enableint(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\npayload = FM_FR_EVENT;\r\nif (!fm_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload, sizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_AF_JUMP_ENABLE_INT_RESP_IDX);\r\n}\r\nstatic void fm_irq_afjump_enableint_resp(struct fmdev *fmdev)\r\n{\r\nfm_irq_common_cmd_resp_helper(fmdev, FM_AF_JUMP_START_AFJUMP_IDX);\r\n}\r\nstatic void fm_irq_start_afjump(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\npayload = FM_TUNER_AF_JUMP_MODE;\r\nif (!fm_send_cmd(fmdev, TUNER_MODE_SET, REG_WR, &payload,\r\nsizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_AF_JUMP_HANDLE_START_AFJUMP_RESP_IDX);\r\n}\r\nstatic void fm_irq_handle_start_afjump_resp(struct fmdev *fmdev)\r\n{\r\nstruct sk_buff *skb;\r\nif (check_cmdresp_status(fmdev, &skb))\r\nreturn;\r\nfmdev->irq_info.stage = FM_SEND_FLAG_GETCMD_IDX;\r\nset_bit(FM_AF_SWITCH_INPROGRESS, &fmdev->flag);\r\nclear_bit(FM_INTTASK_RUNNING, &fmdev->flag);\r\n}\r\nstatic void fm_irq_afjump_rd_freq(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\nif (!fm_send_cmd(fmdev, FREQ_SET, REG_RD, NULL, sizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_AF_JUMP_RD_FREQ_RESP_IDX);\r\n}\r\nstatic void fm_irq_afjump_rd_freq_resp(struct fmdev *fmdev)\r\n{\r\nstruct sk_buff *skb;\r\nu16 read_freq;\r\nu32 curr_freq, jumped_freq;\r\nif (check_cmdresp_status(fmdev, &skb))\r\nreturn;\r\nskb_pull(skb, sizeof(struct fm_event_msg_hdr));\r\nmemcpy(&read_freq, skb->data, sizeof(read_freq));\r\nread_freq = be16_to_cpu(read_freq);\r\ncurr_freq = fmdev->rx.region.bot_freq + ((u32)read_freq * FM_FREQ_MUL);\r\njumped_freq = fmdev->rx.stat_info.af_cache[fmdev->rx.afjump_idx];\r\nif ((curr_freq != fmdev->rx.freq_before_jump) && (curr_freq == jumped_freq)) {\r\nfmdbg("Successfully switched to alternate freq %d\n", curr_freq);\r\nfmdev->rx.freq = curr_freq;\r\nfm_rx_reset_rds_cache(fmdev);\r\nif (fmdev->rx.af_mode == FM_RX_RDS_AF_SWITCH_MODE_ON)\r\nfmdev->irq_info.mask |= FM_LEV_EVENT;\r\nfmdev->irq_info.stage = FM_LOW_RSSI_FINISH_IDX;\r\n} else {\r\nfmdev->rx.afjump_idx++;\r\nif (fmdev->rx.afjump_idx >= fmdev->rx.stat_info.afcache_size) {\r\nfmdbg("AF switch processing failed\n");\r\nfmdev->irq_info.stage = FM_LOW_RSSI_FINISH_IDX;\r\n} else {\r\nfmdbg("Trying next freq in AF cache\n");\r\nfmdev->irq_info.stage = FM_AF_JUMP_SETPI_IDX;\r\n}\r\n}\r\nfm_irq_call(fmdev);\r\n}\r\nstatic void fm_irq_handle_low_rssi_finish(struct fmdev *fmdev)\r\n{\r\nfm_irq_call_stage(fmdev, FM_SEND_INTMSK_CMD_IDX);\r\n}\r\nstatic void fm_irq_send_intmsk_cmd(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\npayload = fmdev->irq_info.mask;\r\nif (!fm_send_cmd(fmdev, INT_MASK_SET, REG_WR, &payload,\r\nsizeof(payload), NULL))\r\nfm_irq_timeout_stage(fmdev, FM_HANDLE_INTMSK_CMD_RESP_IDX);\r\n}\r\nstatic void fm_irq_handle_intmsk_cmd_resp(struct fmdev *fmdev)\r\n{\r\nstruct sk_buff *skb;\r\nif (check_cmdresp_status(fmdev, &skb))\r\nreturn;\r\nfmdev->irq_info.stage = FM_SEND_FLAG_GETCMD_IDX;\r\nif (test_and_clear_bit(FM_INTTASK_SCHEDULE_PENDING, &fmdev->flag))\r\nfmdev->irq_info.handlers[fmdev->irq_info.stage](fmdev);\r\nelse\r\nclear_bit(FM_INTTASK_RUNNING, &fmdev->flag);\r\n}\r\nint fmc_is_rds_data_available(struct fmdev *fmdev, struct file *file,\r\nstruct poll_table_struct *pts)\r\n{\r\npoll_wait(file, &fmdev->rx.rds.read_queue, pts);\r\nif (fmdev->rx.rds.rd_idx != fmdev->rx.rds.wr_idx)\r\nreturn 0;\r\nreturn -EAGAIN;\r\n}\r\nint fmc_transfer_rds_from_internal_buff(struct fmdev *fmdev, struct file *file,\r\nu8 __user *buf, size_t count)\r\n{\r\nu32 block_count;\r\nunsigned long flags;\r\nint ret;\r\nif (fmdev->rx.rds.wr_idx == fmdev->rx.rds.rd_idx) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nret = wait_event_interruptible(fmdev->rx.rds.read_queue,\r\n(fmdev->rx.rds.wr_idx != fmdev->rx.rds.rd_idx));\r\nif (ret)\r\nreturn -EINTR;\r\n}\r\ncount /= 3;\r\nblock_count = 0;\r\nret = 0;\r\nspin_lock_irqsave(&fmdev->rds_buff_lock, flags);\r\nwhile (block_count < count) {\r\nif (fmdev->rx.rds.wr_idx == fmdev->rx.rds.rd_idx)\r\nbreak;\r\nif (copy_to_user(buf, &fmdev->rx.rds.buff[fmdev->rx.rds.rd_idx],\r\nFM_RDS_BLK_SIZE))\r\nbreak;\r\nfmdev->rx.rds.rd_idx += FM_RDS_BLK_SIZE;\r\nif (fmdev->rx.rds.rd_idx >= fmdev->rx.rds.buf_size)\r\nfmdev->rx.rds.rd_idx = 0;\r\nblock_count++;\r\nbuf += FM_RDS_BLK_SIZE;\r\nret += FM_RDS_BLK_SIZE;\r\n}\r\nspin_unlock_irqrestore(&fmdev->rds_buff_lock, flags);\r\nreturn ret;\r\n}\r\nint fmc_set_freq(struct fmdev *fmdev, u32 freq_to_set)\r\n{\r\nswitch (fmdev->curr_fmmode) {\r\ncase FM_MODE_RX:\r\nreturn fm_rx_set_freq(fmdev, freq_to_set);\r\ncase FM_MODE_TX:\r\nreturn fm_tx_set_freq(fmdev, freq_to_set);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint fmc_get_freq(struct fmdev *fmdev, u32 *cur_tuned_frq)\r\n{\r\nif (fmdev->rx.freq == FM_UNDEFINED_FREQ) {\r\nfmerr("RX frequency is not set\n");\r\nreturn -EPERM;\r\n}\r\nif (cur_tuned_frq == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (fmdev->curr_fmmode) {\r\ncase FM_MODE_RX:\r\n*cur_tuned_frq = fmdev->rx.freq;\r\nreturn 0;\r\ncase FM_MODE_TX:\r\n*cur_tuned_frq = 0;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint fmc_set_region(struct fmdev *fmdev, u8 region_to_set)\r\n{\r\nswitch (fmdev->curr_fmmode) {\r\ncase FM_MODE_RX:\r\nreturn fm_rx_set_region(fmdev, region_to_set);\r\ncase FM_MODE_TX:\r\nreturn fm_tx_set_region(fmdev, region_to_set);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint fmc_set_mute_mode(struct fmdev *fmdev, u8 mute_mode_toset)\r\n{\r\nswitch (fmdev->curr_fmmode) {\r\ncase FM_MODE_RX:\r\nreturn fm_rx_set_mute_mode(fmdev, mute_mode_toset);\r\ncase FM_MODE_TX:\r\nreturn fm_tx_set_mute_mode(fmdev, mute_mode_toset);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint fmc_set_stereo_mono(struct fmdev *fmdev, u16 mode)\r\n{\r\nswitch (fmdev->curr_fmmode) {\r\ncase FM_MODE_RX:\r\nreturn fm_rx_set_stereo_mono(fmdev, mode);\r\ncase FM_MODE_TX:\r\nreturn fm_tx_set_stereo_mono(fmdev, mode);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint fmc_set_rds_mode(struct fmdev *fmdev, u8 rds_en_dis)\r\n{\r\nswitch (fmdev->curr_fmmode) {\r\ncase FM_MODE_RX:\r\nreturn fm_rx_set_rds_mode(fmdev, rds_en_dis);\r\ncase FM_MODE_TX:\r\nreturn fm_tx_set_rds_mode(fmdev, rds_en_dis);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int fm_power_down(struct fmdev *fmdev)\r\n{\r\nu16 payload;\r\nint ret;\r\nif (!test_bit(FM_CORE_READY, &fmdev->flag)) {\r\nfmerr("FM core is not ready\n");\r\nreturn -EPERM;\r\n}\r\nif (fmdev->curr_fmmode == FM_MODE_OFF) {\r\nfmdbg("FM chip is already in OFF state\n");\r\nreturn 0;\r\n}\r\npayload = 0x0;\r\nret = fmc_send_cmd(fmdev, FM_POWER_MODE, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn fmc_release(fmdev);\r\n}\r\nstatic int fm_download_firmware(struct fmdev *fmdev, const u8 *fw_name)\r\n{\r\nconst struct firmware *fw_entry;\r\nstruct bts_header *fw_header;\r\nstruct bts_action *action;\r\nstruct bts_action_delay *delay;\r\nu8 *fw_data;\r\nint ret, fw_len, cmd_cnt;\r\ncmd_cnt = 0;\r\nset_bit(FM_FW_DW_INPROGRESS, &fmdev->flag);\r\nret = request_firmware(&fw_entry, fw_name,\r\n&fmdev->radio_dev->dev);\r\nif (ret < 0) {\r\nfmerr("Unable to read firmware(%s) content\n", fw_name);\r\nreturn ret;\r\n}\r\nfmdbg("Firmware(%s) length : %d bytes\n", fw_name, fw_entry->size);\r\nfw_data = (void *)fw_entry->data;\r\nfw_len = fw_entry->size;\r\nfw_header = (struct bts_header *)fw_data;\r\nif (fw_header->magic != FM_FW_FILE_HEADER_MAGIC) {\r\nfmerr("%s not a legal TI firmware file\n", fw_name);\r\nret = -EINVAL;\r\ngoto rel_fw;\r\n}\r\nfmdbg("FW(%s) magic number : 0x%x\n", fw_name, fw_header->magic);\r\nfw_data += sizeof(struct bts_header);\r\nfw_len -= sizeof(struct bts_header);\r\nwhile (fw_data && fw_len > 0) {\r\naction = (struct bts_action *)fw_data;\r\nswitch (action->type) {\r\ncase ACTION_SEND_COMMAND:\r\nif (fmc_send_cmd(fmdev, 0, 0, action->data,\r\naction->size, NULL, NULL))\r\ngoto rel_fw;\r\ncmd_cnt++;\r\nbreak;\r\ncase ACTION_DELAY:\r\ndelay = (struct bts_action_delay *)action->data;\r\nmdelay(delay->msec);\r\nbreak;\r\n}\r\nfw_data += (sizeof(struct bts_action) + (action->size));\r\nfw_len -= (sizeof(struct bts_action) + (action->size));\r\n}\r\nfmdbg("Firmware commands(%d) loaded to chip\n", cmd_cnt);\r\nrel_fw:\r\nrelease_firmware(fw_entry);\r\nclear_bit(FM_FW_DW_INPROGRESS, &fmdev->flag);\r\nreturn ret;\r\n}\r\nstatic int load_default_rx_configuration(struct fmdev *fmdev)\r\n{\r\nint ret;\r\nret = fm_rx_set_volume(fmdev, FM_DEFAULT_RX_VOLUME);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn fm_rx_set_rssi_threshold(fmdev, FM_DEFAULT_RSSI_THRESHOLD);\r\n}\r\nstatic int fm_power_up(struct fmdev *fmdev, u8 mode)\r\n{\r\nu16 payload, asic_id, asic_ver;\r\nint resp_len, ret;\r\nu8 fw_name[50];\r\nif (mode >= FM_MODE_ENTRY_MAX) {\r\nfmerr("Invalid firmware download option\n");\r\nreturn -EINVAL;\r\n}\r\nret = fmc_prepare(fmdev);\r\nif (ret < 0) {\r\nfmerr("Unable to prepare FM Common\n");\r\nreturn ret;\r\n}\r\npayload = FM_ENABLE;\r\nif (fmc_send_cmd(fmdev, FM_POWER_MODE, REG_WR, &payload,\r\nsizeof(payload), NULL, NULL))\r\ngoto rel;\r\nmsleep(20);\r\nif (fmc_send_cmd(fmdev, ASIC_ID_GET, REG_RD, NULL,\r\nsizeof(asic_id), &asic_id, &resp_len))\r\ngoto rel;\r\nif (fmc_send_cmd(fmdev, ASIC_VER_GET, REG_RD, NULL,\r\nsizeof(asic_ver), &asic_ver, &resp_len))\r\ngoto rel;\r\nfmdbg("ASIC ID: 0x%x , ASIC Version: %d\n",\r\nbe16_to_cpu(asic_id), be16_to_cpu(asic_ver));\r\nsprintf(fw_name, "%s_%x.%d.bts", FM_FMC_FW_FILE_START,\r\nbe16_to_cpu(asic_id), be16_to_cpu(asic_ver));\r\nret = fm_download_firmware(fmdev, fw_name);\r\nif (ret < 0) {\r\nfmdbg("Failed to download firmware file %s\n", fw_name);\r\ngoto rel;\r\n}\r\nsprintf(fw_name, "%s_%x.%d.bts", (mode == FM_MODE_RX) ?\r\nFM_RX_FW_FILE_START : FM_TX_FW_FILE_START,\r\nbe16_to_cpu(asic_id), be16_to_cpu(asic_ver));\r\nret = fm_download_firmware(fmdev, fw_name);\r\nif (ret < 0) {\r\nfmdbg("Failed to download firmware file %s\n", fw_name);\r\ngoto rel;\r\n} else\r\nreturn ret;\r\nrel:\r\nreturn fmc_release(fmdev);\r\n}\r\nint fmc_set_mode(struct fmdev *fmdev, u8 fm_mode)\r\n{\r\nint ret = 0;\r\nif (fm_mode >= FM_MODE_ENTRY_MAX) {\r\nfmerr("Invalid FM mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmdev->curr_fmmode == fm_mode) {\r\nfmdbg("Already fm is in mode(%d)\n", fm_mode);\r\nreturn ret;\r\n}\r\nswitch (fm_mode) {\r\ncase FM_MODE_OFF:\r\nret = fm_power_down(fmdev);\r\nif (ret < 0) {\r\nfmerr("Failed to set OFF mode\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ncase FM_MODE_TX:\r\ncase FM_MODE_RX:\r\nif (fmdev->curr_fmmode != FM_MODE_OFF) {\r\nret = fm_power_down(fmdev);\r\nif (ret < 0) {\r\nfmerr("Failed to set OFF mode\n");\r\nreturn ret;\r\n}\r\nmsleep(30);\r\n}\r\nret = fm_power_up(fmdev, fm_mode);\r\nif (ret < 0) {\r\nfmerr("Failed to load firmware\n");\r\nreturn ret;\r\n}\r\n}\r\nfmdev->curr_fmmode = fm_mode;\r\nif (fmdev->curr_fmmode == FM_MODE_RX) {\r\nfmdbg("Loading default rx configuration..\n");\r\nret = load_default_rx_configuration(fmdev);\r\nif (ret < 0)\r\nfmerr("Failed to load default values\n");\r\n}\r\nreturn ret;\r\n}\r\nint fmc_get_mode(struct fmdev *fmdev, u8 *fmmode)\r\n{\r\nif (!test_bit(FM_CORE_READY, &fmdev->flag)) {\r\nfmerr("FM core is not ready\n");\r\nreturn -EPERM;\r\n}\r\nif (fmmode == NULL) {\r\nfmerr("Invalid memory\n");\r\nreturn -ENOMEM;\r\n}\r\n*fmmode = fmdev->curr_fmmode;\r\nreturn 0;\r\n}\r\nstatic long fm_st_receive(void *arg, struct sk_buff *skb)\r\n{\r\nstruct fmdev *fmdev;\r\nfmdev = (struct fmdev *)arg;\r\nif (skb == NULL) {\r\nfmerr("Invalid SKB received from ST\n");\r\nreturn -EFAULT;\r\n}\r\nif (skb->cb[0] != FM_PKT_LOGICAL_CHAN_NUMBER) {\r\nfmerr("Received SKB (%p) is not FM Channel 8 pkt\n", skb);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(skb_push(skb, 1), &skb->cb[0], 1);\r\nskb_queue_tail(&fmdev->rx_q, skb);\r\ntasklet_schedule(&fmdev->rx_task);\r\nreturn 0;\r\n}\r\nstatic void fm_st_reg_comp_cb(void *arg, char data)\r\n{\r\nstruct fmdev *fmdev;\r\nfmdev = (struct fmdev *)arg;\r\nfmdev->streg_cbdata = data;\r\ncomplete(&wait_for_fmdrv_reg_comp);\r\n}\r\nint fmc_prepare(struct fmdev *fmdev)\r\n{\r\nstatic struct st_proto_s fm_st_proto;\r\nint ret;\r\nif (test_bit(FM_CORE_READY, &fmdev->flag)) {\r\nfmdbg("FM Core is already up\n");\r\nreturn 0;\r\n}\r\nmemset(&fm_st_proto, 0, sizeof(fm_st_proto));\r\nfm_st_proto.recv = fm_st_receive;\r\nfm_st_proto.match_packet = NULL;\r\nfm_st_proto.reg_complete_cb = fm_st_reg_comp_cb;\r\nfm_st_proto.write = NULL;\r\nfm_st_proto.priv_data = fmdev;\r\nfm_st_proto.chnl_id = 0x08;\r\nfm_st_proto.max_frame_size = 0xff;\r\nfm_st_proto.hdr_len = 1;\r\nfm_st_proto.offset_len_in_hdr = 0;\r\nfm_st_proto.len_size = 1;\r\nfm_st_proto.reserve = 1;\r\nret = st_register(&fm_st_proto);\r\nif (ret == -EINPROGRESS) {\r\ninit_completion(&wait_for_fmdrv_reg_comp);\r\nfmdev->streg_cbdata = -EINPROGRESS;\r\nfmdbg("%s waiting for ST reg completion signal\n", __func__);\r\nif (!wait_for_completion_timeout(&wait_for_fmdrv_reg_comp,\r\nFM_ST_REG_TIMEOUT)) {\r\nfmerr("Timeout(%d sec), didn't get reg "\r\n"completion signal from ST\n",\r\njiffies_to_msecs(FM_ST_REG_TIMEOUT) / 1000);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (fmdev->streg_cbdata != 0) {\r\nfmerr("ST reg comp CB called with error "\r\n"status %d\n", fmdev->streg_cbdata);\r\nreturn -EAGAIN;\r\n}\r\nret = 0;\r\n} else if (ret == -1) {\r\nfmerr("st_register failed %d\n", ret);\r\nreturn -EAGAIN;\r\n}\r\nif (fm_st_proto.write != NULL) {\r\ng_st_write = fm_st_proto.write;\r\n} else {\r\nfmerr("Failed to get ST write func pointer\n");\r\nret = st_unregister(&fm_st_proto);\r\nif (ret < 0)\r\nfmerr("st_unregister failed %d\n", ret);\r\nreturn -EAGAIN;\r\n}\r\nspin_lock_init(&fmdev->rds_buff_lock);\r\nspin_lock_init(&fmdev->resp_skb_lock);\r\nskb_queue_head_init(&fmdev->tx_q);\r\ntasklet_init(&fmdev->tx_task, send_tasklet, (unsigned long)fmdev);\r\nskb_queue_head_init(&fmdev->rx_q);\r\ntasklet_init(&fmdev->rx_task, recv_tasklet, (unsigned long)fmdev);\r\nfmdev->irq_info.stage = 0;\r\natomic_set(&fmdev->tx_cnt, 1);\r\nfmdev->resp_comp = NULL;\r\ninit_timer(&fmdev->irq_info.timer);\r\nfmdev->irq_info.timer.function = &int_timeout_handler;\r\nfmdev->irq_info.timer.data = (unsigned long)fmdev;\r\nfmdev->irq_info.mask = FM_MAL_EVENT;\r\nmemcpy(&fmdev->rx.region, &region_configs[default_radio_region],\r\nsizeof(struct region_info));\r\nfmdev->rx.mute_mode = FM_MUTE_OFF;\r\nfmdev->rx.rf_depend_mute = FM_RX_RF_DEPENDENT_MUTE_OFF;\r\nfmdev->rx.rds.flag = FM_RDS_DISABLE;\r\nfmdev->rx.freq = FM_UNDEFINED_FREQ;\r\nfmdev->rx.rds_mode = FM_RDS_SYSTEM_RDS;\r\nfmdev->rx.af_mode = FM_RX_RDS_AF_SWITCH_MODE_OFF;\r\nfmdev->irq_info.retry = 0;\r\nfm_rx_reset_rds_cache(fmdev);\r\ninit_waitqueue_head(&fmdev->rx.rds.read_queue);\r\nfm_rx_reset_station_info(fmdev);\r\nset_bit(FM_CORE_READY, &fmdev->flag);\r\nreturn ret;\r\n}\r\nint fmc_release(struct fmdev *fmdev)\r\n{\r\nstatic struct st_proto_s fm_st_proto;\r\nint ret;\r\nif (!test_bit(FM_CORE_READY, &fmdev->flag)) {\r\nfmdbg("FM Core is already down\n");\r\nreturn 0;\r\n}\r\nwake_up_interruptible(&fmdev->rx.rds.read_queue);\r\ntasklet_kill(&fmdev->tx_task);\r\ntasklet_kill(&fmdev->rx_task);\r\nskb_queue_purge(&fmdev->tx_q);\r\nskb_queue_purge(&fmdev->rx_q);\r\nfmdev->resp_comp = NULL;\r\nfmdev->rx.freq = 0;\r\nmemset(&fm_st_proto, 0, sizeof(fm_st_proto));\r\nfm_st_proto.chnl_id = 0x08;\r\nret = st_unregister(&fm_st_proto);\r\nif (ret < 0)\r\nfmerr("Failed to de-register FM from ST %d\n", ret);\r\nelse\r\nfmdbg("Successfully unregistered from ST\n");\r\nclear_bit(FM_CORE_READY, &fmdev->flag);\r\nreturn ret;\r\n}\r\nstatic int __init fm_drv_init(void)\r\n{\r\nstruct fmdev *fmdev = NULL;\r\nint ret = -ENOMEM;\r\nfmdbg("FM driver version %s\n", FM_DRV_VERSION);\r\nfmdev = kzalloc(sizeof(struct fmdev), GFP_KERNEL);\r\nif (NULL == fmdev) {\r\nfmerr("Can't allocate operation structure memory\n");\r\nreturn ret;\r\n}\r\nfmdev->rx.rds.buf_size = default_rds_buf * FM_RDS_BLK_SIZE;\r\nfmdev->rx.rds.buff = kzalloc(fmdev->rx.rds.buf_size, GFP_KERNEL);\r\nif (NULL == fmdev->rx.rds.buff) {\r\nfmerr("Can't allocate rds ring buffer\n");\r\ngoto rel_dev;\r\n}\r\nret = fm_v4l2_init_video_device(fmdev, radio_nr);\r\nif (ret < 0)\r\ngoto rel_rdsbuf;\r\nfmdev->irq_info.handlers = int_handler_table;\r\nfmdev->curr_fmmode = FM_MODE_OFF;\r\nfmdev->tx_data.pwr_lvl = FM_PWR_LVL_DEF;\r\nfmdev->tx_data.preemph = FM_TX_PREEMPH_50US;\r\nreturn ret;\r\nrel_rdsbuf:\r\nkfree(fmdev->rx.rds.buff);\r\nrel_dev:\r\nkfree(fmdev);\r\nreturn ret;\r\n}\r\nstatic void __exit fm_drv_exit(void)\r\n{\r\nstruct fmdev *fmdev = NULL;\r\nfmdev = fm_v4l2_deinit_video_device();\r\nif (fmdev != NULL) {\r\nkfree(fmdev->rx.rds.buff);\r\nkfree(fmdev);\r\n}\r\n}
