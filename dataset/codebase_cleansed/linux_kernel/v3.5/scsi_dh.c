static struct scsi_device_handler *get_device_handler(const char *name)\r\n{\r\nstruct scsi_device_handler *tmp, *found = NULL;\r\nspin_lock(&list_lock);\r\nlist_for_each_entry(tmp, &scsi_dh_list, list) {\r\nif (!strncmp(tmp->name, name, strlen(tmp->name))) {\r\nfound = tmp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&list_lock);\r\nreturn found;\r\n}\r\nstatic struct scsi_device_handler *\r\ndevice_handler_match_function(struct scsi_device *sdev)\r\n{\r\nstruct scsi_device_handler *tmp_dh, *found_dh = NULL;\r\nspin_lock(&list_lock);\r\nlist_for_each_entry(tmp_dh, &scsi_dh_list, list) {\r\nif (tmp_dh->match && tmp_dh->match(sdev)) {\r\nfound_dh = tmp_dh;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&list_lock);\r\nreturn found_dh;\r\n}\r\nstatic struct scsi_device_handler *\r\ndevice_handler_match(struct scsi_device_handler *scsi_dh,\r\nstruct scsi_device *sdev)\r\n{\r\nstruct scsi_device_handler *found_dh;\r\nfound_dh = device_handler_match_function(sdev);\r\nif (scsi_dh && found_dh != scsi_dh)\r\nfound_dh = NULL;\r\nreturn found_dh;\r\n}\r\nstatic int scsi_dh_handler_attach(struct scsi_device *sdev,\r\nstruct scsi_device_handler *scsi_dh)\r\n{\r\nint err = 0;\r\nif (sdev->scsi_dh_data) {\r\nif (sdev->scsi_dh_data->scsi_dh != scsi_dh)\r\nerr = -EBUSY;\r\nelse\r\nkref_get(&sdev->scsi_dh_data->kref);\r\n} else if (scsi_dh->attach) {\r\nerr = scsi_dh->attach(sdev);\r\nif (!err) {\r\nkref_init(&sdev->scsi_dh_data->kref);\r\nsdev->scsi_dh_data->sdev = sdev;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void __detach_handler (struct kref *kref)\r\n{\r\nstruct scsi_dh_data *scsi_dh_data = container_of(kref, struct scsi_dh_data, kref);\r\nscsi_dh_data->scsi_dh->detach(scsi_dh_data->sdev);\r\n}\r\nstatic void scsi_dh_handler_detach(struct scsi_device *sdev,\r\nstruct scsi_device_handler *scsi_dh)\r\n{\r\nif (!sdev->scsi_dh_data)\r\nreturn;\r\nif (scsi_dh && scsi_dh != sdev->scsi_dh_data->scsi_dh)\r\nreturn;\r\nif (!scsi_dh)\r\nscsi_dh = sdev->scsi_dh_data->scsi_dh;\r\nif (scsi_dh && scsi_dh->detach)\r\nkref_put(&sdev->scsi_dh_data->kref, __detach_handler);\r\n}\r\nstatic ssize_t\r\nstore_dh_state(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct scsi_device_handler *scsi_dh;\r\nint err = -EINVAL;\r\nif (sdev->sdev_state == SDEV_CANCEL ||\r\nsdev->sdev_state == SDEV_DEL)\r\nreturn -ENODEV;\r\nif (!sdev->scsi_dh_data) {\r\nif (!(scsi_dh = get_device_handler(buf)))\r\nreturn err;\r\nerr = scsi_dh_handler_attach(sdev, scsi_dh);\r\n} else {\r\nscsi_dh = sdev->scsi_dh_data->scsi_dh;\r\nif (!strncmp(buf, "detach", 6)) {\r\nscsi_dh_handler_detach(sdev, scsi_dh);\r\nerr = 0;\r\n} else if (!strncmp(buf, "activate", 8)) {\r\nif (scsi_dh->activate)\r\nerr = scsi_dh->activate(sdev, NULL, NULL);\r\nelse\r\nerr = 0;\r\n}\r\n}\r\nreturn err<0?err:count;\r\n}\r\nstatic ssize_t\r\nshow_dh_state(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nif (!sdev->scsi_dh_data)\r\nreturn snprintf(buf, 20, "detached\n");\r\nreturn snprintf(buf, 20, "%s\n", sdev->scsi_dh_data->scsi_dh->name);\r\n}\r\nstatic int scsi_dh_sysfs_attr_add(struct device *dev, void *data)\r\n{\r\nstruct scsi_device *sdev;\r\nint err;\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\nerr = device_create_file(&sdev->sdev_gendev,\r\n&scsi_dh_state_attr);\r\nreturn 0;\r\n}\r\nstatic int scsi_dh_sysfs_attr_remove(struct device *dev, void *data)\r\n{\r\nstruct scsi_device *sdev;\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\ndevice_remove_file(&sdev->sdev_gendev,\r\n&scsi_dh_state_attr);\r\nreturn 0;\r\n}\r\nstatic int scsi_dh_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct device *dev = data;\r\nstruct scsi_device *sdev;\r\nint err = 0;\r\nstruct scsi_device_handler *devinfo = NULL;\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\nif (action == BUS_NOTIFY_ADD_DEVICE) {\r\nerr = device_create_file(dev, &scsi_dh_state_attr);\r\ndevinfo = device_handler_match(NULL, sdev);\r\nif (devinfo)\r\nerr = scsi_dh_handler_attach(sdev, devinfo);\r\n} else if (action == BUS_NOTIFY_DEL_DEVICE) {\r\ndevice_remove_file(dev, &scsi_dh_state_attr);\r\nscsi_dh_handler_detach(sdev, NULL);\r\n}\r\nreturn err;\r\n}\r\nstatic int scsi_dh_notifier_add(struct device *dev, void *data)\r\n{\r\nstruct scsi_device_handler *scsi_dh = data;\r\nstruct scsi_device *sdev;\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nif (!get_device(dev))\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\nif (device_handler_match(scsi_dh, sdev))\r\nscsi_dh_handler_attach(sdev, scsi_dh);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic int scsi_dh_notifier_remove(struct device *dev, void *data)\r\n{\r\nstruct scsi_device_handler *scsi_dh = data;\r\nstruct scsi_device *sdev;\r\nif (!scsi_is_sdev_device(dev))\r\nreturn 0;\r\nif (!get_device(dev))\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\nscsi_dh_handler_detach(sdev, scsi_dh);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nint scsi_register_device_handler(struct scsi_device_handler *scsi_dh)\r\n{\r\nif (get_device_handler(scsi_dh->name))\r\nreturn -EBUSY;\r\nspin_lock(&list_lock);\r\nlist_add(&scsi_dh->list, &scsi_dh_list);\r\nspin_unlock(&list_lock);\r\nbus_for_each_dev(&scsi_bus_type, NULL, scsi_dh, scsi_dh_notifier_add);\r\nprintk(KERN_INFO "%s: device handler registered\n", scsi_dh->name);\r\nreturn SCSI_DH_OK;\r\n}\r\nint scsi_unregister_device_handler(struct scsi_device_handler *scsi_dh)\r\n{\r\nif (!get_device_handler(scsi_dh->name))\r\nreturn -ENODEV;\r\nbus_for_each_dev(&scsi_bus_type, NULL, scsi_dh,\r\nscsi_dh_notifier_remove);\r\nspin_lock(&list_lock);\r\nlist_del(&scsi_dh->list);\r\nspin_unlock(&list_lock);\r\nprintk(KERN_INFO "%s: device handler unregistered\n", scsi_dh->name);\r\nreturn SCSI_DH_OK;\r\n}\r\nint scsi_dh_activate(struct request_queue *q, activate_complete fn, void *data)\r\n{\r\nint err = 0;\r\nunsigned long flags;\r\nstruct scsi_device *sdev;\r\nstruct scsi_device_handler *scsi_dh = NULL;\r\nstruct device *dev = NULL;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nsdev = q->queuedata;\r\nif (!sdev) {\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nerr = SCSI_DH_NOSYS;\r\nif (fn)\r\nfn(data, err);\r\nreturn err;\r\n}\r\nif (sdev->scsi_dh_data)\r\nscsi_dh = sdev->scsi_dh_data->scsi_dh;\r\ndev = get_device(&sdev->sdev_gendev);\r\nif (!scsi_dh || !dev ||\r\nsdev->sdev_state == SDEV_CANCEL ||\r\nsdev->sdev_state == SDEV_DEL)\r\nerr = SCSI_DH_NOSYS;\r\nif (sdev->sdev_state == SDEV_OFFLINE)\r\nerr = SCSI_DH_DEV_OFFLINED;\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nif (err) {\r\nif (fn)\r\nfn(data, err);\r\ngoto out;\r\n}\r\nif (scsi_dh->activate)\r\nerr = scsi_dh->activate(sdev, fn, data);\r\nout:\r\nput_device(dev);\r\nreturn err;\r\n}\r\nint scsi_dh_set_params(struct request_queue *q, const char *params)\r\n{\r\nint err = -SCSI_DH_NOSYS;\r\nunsigned long flags;\r\nstruct scsi_device *sdev;\r\nstruct scsi_device_handler *scsi_dh = NULL;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nsdev = q->queuedata;\r\nif (sdev && sdev->scsi_dh_data)\r\nscsi_dh = sdev->scsi_dh_data->scsi_dh;\r\nif (scsi_dh && scsi_dh->set_params && get_device(&sdev->sdev_gendev))\r\nerr = 0;\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nif (err)\r\nreturn err;\r\nerr = scsi_dh->set_params(sdev, params);\r\nput_device(&sdev->sdev_gendev);\r\nreturn err;\r\n}\r\nint scsi_dh_handler_exist(const char *name)\r\n{\r\nreturn (get_device_handler(name) != NULL);\r\n}\r\nint scsi_dh_attach(struct request_queue *q, const char *name)\r\n{\r\nunsigned long flags;\r\nstruct scsi_device *sdev;\r\nstruct scsi_device_handler *scsi_dh;\r\nint err = 0;\r\nscsi_dh = get_device_handler(name);\r\nif (!scsi_dh)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nsdev = q->queuedata;\r\nif (!sdev || !get_device(&sdev->sdev_gendev))\r\nerr = -ENODEV;\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nif (!err) {\r\nerr = scsi_dh_handler_attach(sdev, scsi_dh);\r\nput_device(&sdev->sdev_gendev);\r\n}\r\nreturn err;\r\n}\r\nvoid scsi_dh_detach(struct request_queue *q)\r\n{\r\nunsigned long flags;\r\nstruct scsi_device *sdev;\r\nstruct scsi_device_handler *scsi_dh = NULL;\r\nspin_lock_irqsave(q->queue_lock, flags);\r\nsdev = q->queuedata;\r\nif (!sdev || !get_device(&sdev->sdev_gendev))\r\nsdev = NULL;\r\nspin_unlock_irqrestore(q->queue_lock, flags);\r\nif (!sdev)\r\nreturn;\r\nif (sdev->scsi_dh_data) {\r\nscsi_dh = sdev->scsi_dh_data->scsi_dh;\r\nscsi_dh_handler_detach(sdev, scsi_dh);\r\n}\r\nput_device(&sdev->sdev_gendev);\r\n}\r\nstatic int __init scsi_dh_init(void)\r\n{\r\nint r;\r\nr = bus_register_notifier(&scsi_bus_type, &scsi_dh_nb);\r\nif (!r)\r\nbus_for_each_dev(&scsi_bus_type, NULL, NULL,\r\nscsi_dh_sysfs_attr_add);\r\nreturn r;\r\n}\r\nstatic void __exit scsi_dh_exit(void)\r\n{\r\nbus_for_each_dev(&scsi_bus_type, NULL, NULL,\r\nscsi_dh_sysfs_attr_remove);\r\nbus_unregister_notifier(&scsi_bus_type, &scsi_dh_nb);\r\n}
