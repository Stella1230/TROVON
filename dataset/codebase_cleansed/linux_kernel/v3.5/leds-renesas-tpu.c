static inline unsigned short r_tpu_read(struct r_tpu_priv *p, int reg_nr)\r\n{\r\nstruct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;\r\nvoid __iomem *base = p->mapbase;\r\nunsigned long offs = reg_nr << 2;\r\nif (reg_nr == TSTR)\r\nreturn ioread16(base - cfg->channel_offset);\r\nreturn ioread16(base + offs);\r\n}\r\nstatic inline void r_tpu_write(struct r_tpu_priv *p, int reg_nr,\r\nunsigned short value)\r\n{\r\nstruct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;\r\nvoid __iomem *base = p->mapbase;\r\nunsigned long offs = reg_nr << 2;\r\nif (reg_nr == TSTR) {\r\niowrite16(value, base - cfg->channel_offset);\r\nreturn;\r\n}\r\niowrite16(value, base + offs);\r\n}\r\nstatic void r_tpu_start_stop_ch(struct r_tpu_priv *p, int start)\r\n{\r\nstruct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;\r\nunsigned long flags, value;\r\nspin_lock_irqsave(&r_tpu_lock, flags);\r\nvalue = r_tpu_read(p, TSTR);\r\nif (start)\r\nvalue |= 1 << cfg->timer_bit;\r\nelse\r\nvalue &= ~(1 << cfg->timer_bit);\r\nr_tpu_write(p, TSTR, value);\r\nspin_unlock_irqrestore(&r_tpu_lock, flags);\r\n}\r\nstatic int r_tpu_enable(struct r_tpu_priv *p, enum led_brightness brightness)\r\n{\r\nstruct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;\r\nint prescaler[] = { 1, 4, 16, 64 };\r\nint k, ret;\r\nunsigned long rate, tmp;\r\nif (p->timer_state == R_TPU_TIMER_ON)\r\nreturn 0;\r\npm_runtime_get_sync(&p->pdev->dev);\r\nret = clk_enable(p->clk);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "cannot enable clock\n");\r\nreturn ret;\r\n}\r\nr_tpu_start_stop_ch(p, 0);\r\nrate = clk_get_rate(p->clk);\r\nfor (k = 0; k < ARRAY_SIZE(prescaler); k++)\r\nif ((rate / prescaler[k]) < p->min_rate)\r\nbreak;\r\nif (!k) {\r\ndev_err(&p->pdev->dev, "clock rate mismatch\n");\r\ngoto err0;\r\n}\r\ndev_dbg(&p->pdev->dev, "rate = %lu, prescaler %u\n",\r\nrate, prescaler[k - 1]);\r\nr_tpu_write(p, TCR, 0x0040 | (k - 1));\r\nr_tpu_write(p, TIOR, 0x0002);\r\nrate /= prescaler[k - 1] * p->refresh_rate;\r\nr_tpu_write(p, TGRB, rate);\r\ndev_dbg(&p->pdev->dev, "TRGB = 0x%04lx\n", rate);\r\ntmp = (cfg->max_brightness - brightness) * rate;\r\nr_tpu_write(p, TGRA, tmp / cfg->max_brightness);\r\ndev_dbg(&p->pdev->dev, "TRGA = 0x%04lx\n", tmp / cfg->max_brightness);\r\nr_tpu_write(p, TMDR, 0x0002);\r\nr_tpu_start_stop_ch(p, 1);\r\np->timer_state = R_TPU_TIMER_ON;\r\nreturn 0;\r\nerr0:\r\nclk_disable(p->clk);\r\npm_runtime_put_sync(&p->pdev->dev);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void r_tpu_disable(struct r_tpu_priv *p)\r\n{\r\nif (p->timer_state == R_TPU_TIMER_UNUSED)\r\nreturn;\r\nr_tpu_start_stop_ch(p, 0);\r\nclk_disable(p->clk);\r\npm_runtime_put_sync(&p->pdev->dev);\r\np->timer_state = R_TPU_TIMER_UNUSED;\r\n}\r\nstatic void r_tpu_set_pin(struct r_tpu_priv *p, enum r_tpu_pin new_state,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_renesas_tpu_config *cfg = p->pdev->dev.platform_data;\r\nif (p->pin_state == new_state) {\r\nif (p->pin_state == R_TPU_PIN_GPIO)\r\ngpio_set_value(cfg->pin_gpio, brightness);\r\nreturn;\r\n}\r\nif (p->pin_state == R_TPU_PIN_GPIO)\r\ngpio_free(cfg->pin_gpio);\r\nif (p->pin_state == R_TPU_PIN_GPIO_FN)\r\ngpio_free(cfg->pin_gpio_fn);\r\nif (new_state == R_TPU_PIN_GPIO) {\r\ngpio_request(cfg->pin_gpio, cfg->name);\r\ngpio_direction_output(cfg->pin_gpio, !!brightness);\r\n}\r\nif (new_state == R_TPU_PIN_GPIO_FN)\r\ngpio_request(cfg->pin_gpio_fn, cfg->name);\r\np->pin_state = new_state;\r\n}\r\nstatic void r_tpu_work(struct work_struct *work)\r\n{\r\nstruct r_tpu_priv *p = container_of(work, struct r_tpu_priv, work);\r\nenum led_brightness brightness = p->new_brightness;\r\nr_tpu_disable(p);\r\nif ((brightness == 0) || (brightness == p->ldev.max_brightness))\r\nr_tpu_set_pin(p, R_TPU_PIN_GPIO, brightness);\r\nelse {\r\nr_tpu_set_pin(p, R_TPU_PIN_GPIO_FN, 0);\r\nr_tpu_enable(p, brightness);\r\n}\r\n}\r\nstatic void r_tpu_set_brightness(struct led_classdev *ldev,\r\nenum led_brightness brightness)\r\n{\r\nstruct r_tpu_priv *p = container_of(ldev, struct r_tpu_priv, ldev);\r\np->new_brightness = brightness;\r\nschedule_work(&p->work);\r\n}\r\nstatic int __devinit r_tpu_probe(struct platform_device *pdev)\r\n{\r\nstruct led_renesas_tpu_config *cfg = pdev->dev.platform_data;\r\nstruct r_tpu_priv *p;\r\nstruct resource *res;\r\nint ret = -ENXIO;\r\nif (!cfg) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\ngoto err0;\r\n}\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\ngoto err1;\r\n}\r\np->mapbase = ioremap_nocache(res->start, resource_size(res));\r\nif (p->mapbase == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\ngoto err1;\r\n}\r\np->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(p->clk);\r\ngoto err2;\r\n}\r\np->pdev = pdev;\r\np->pin_state = R_TPU_PIN_UNUSED;\r\np->timer_state = R_TPU_TIMER_UNUSED;\r\np->refresh_rate = cfg->refresh_rate ? cfg->refresh_rate : 100;\r\nr_tpu_set_pin(p, R_TPU_PIN_GPIO, LED_OFF);\r\nplatform_set_drvdata(pdev, p);\r\nINIT_WORK(&p->work, r_tpu_work);\r\np->ldev.name = cfg->name;\r\np->ldev.brightness = LED_OFF;\r\np->ldev.max_brightness = cfg->max_brightness;\r\np->ldev.brightness_set = r_tpu_set_brightness;\r\np->ldev.flags |= LED_CORE_SUSPENDRESUME;\r\nret = led_classdev_register(&pdev->dev, &p->ldev);\r\nif (ret < 0)\r\ngoto err3;\r\np->min_rate = p->ldev.max_brightness * p->refresh_rate;\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nerr3:\r\nr_tpu_set_pin(p, R_TPU_PIN_UNUSED, LED_OFF);\r\nclk_put(p->clk);\r\nerr2:\r\niounmap(p->mapbase);\r\nerr1:\r\nkfree(p);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int __devexit r_tpu_remove(struct platform_device *pdev)\r\n{\r\nstruct r_tpu_priv *p = platform_get_drvdata(pdev);\r\nr_tpu_set_brightness(&p->ldev, LED_OFF);\r\nled_classdev_unregister(&p->ldev);\r\ncancel_work_sync(&p->work);\r\nr_tpu_disable(p);\r\nr_tpu_set_pin(p, R_TPU_PIN_UNUSED, LED_OFF);\r\npm_runtime_disable(&pdev->dev);\r\nclk_put(p->clk);\r\niounmap(p->mapbase);\r\nkfree(p);\r\nreturn 0;\r\n}
