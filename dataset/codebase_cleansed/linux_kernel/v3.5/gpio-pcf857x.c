static int pcf857x_input8(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint status;\r\nmutex_lock(&gpio->lock);\r\ngpio->out |= (1 << offset);\r\nstatus = i2c_smbus_write_byte(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic int pcf857x_get8(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\ns32 value;\r\nvalue = i2c_smbus_read_byte(gpio->client);\r\nreturn (value < 0) ? 0 : (value & (1 << offset));\r\n}\r\nstatic int pcf857x_output8(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nunsigned bit = 1 << offset;\r\nint status;\r\nmutex_lock(&gpio->lock);\r\nif (value)\r\ngpio->out |= bit;\r\nelse\r\ngpio->out &= ~bit;\r\nstatus = i2c_smbus_write_byte(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic void pcf857x_set8(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\npcf857x_output8(chip, offset, value);\r\n}\r\nstatic int i2c_write_le16(struct i2c_client *client, u16 word)\r\n{\r\nu8 buf[2] = { word & 0xff, word >> 8, };\r\nint status;\r\nstatus = i2c_master_send(client, buf, 2);\r\nreturn (status < 0) ? status : 0;\r\n}\r\nstatic int i2c_read_le16(struct i2c_client *client)\r\n{\r\nu8 buf[2];\r\nint status;\r\nstatus = i2c_master_recv(client, buf, 2);\r\nif (status < 0)\r\nreturn status;\r\nreturn (buf[1] << 8) | buf[0];\r\n}\r\nstatic int pcf857x_input16(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint status;\r\nmutex_lock(&gpio->lock);\r\ngpio->out |= (1 << offset);\r\nstatus = i2c_write_le16(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic int pcf857x_get16(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint value;\r\nvalue = i2c_read_le16(gpio->client);\r\nreturn (value < 0) ? 0 : (value & (1 << offset));\r\n}\r\nstatic int pcf857x_output16(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nunsigned bit = 1 << offset;\r\nint status;\r\nmutex_lock(&gpio->lock);\r\nif (value)\r\ngpio->out |= bit;\r\nelse\r\ngpio->out &= ~bit;\r\nstatus = i2c_write_le16(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic void pcf857x_set16(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\npcf857x_output16(chip, offset, value);\r\n}\r\nstatic int pcf857x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pcf857x_platform_data *pdata;\r\nstruct pcf857x *gpio;\r\nint status;\r\npdata = client->dev.platform_data;\r\nif (!pdata) {\r\ndev_dbg(&client->dev, "no platform data\n");\r\n}\r\ngpio = kzalloc(sizeof *gpio, GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&gpio->lock);\r\ngpio->chip.base = pdata ? pdata->gpio_base : -1;\r\ngpio->chip.can_sleep = 1;\r\ngpio->chip.dev = &client->dev;\r\ngpio->chip.owner = THIS_MODULE;\r\ngpio->chip.ngpio = id->driver_data;\r\nif (gpio->chip.ngpio == 8) {\r\ngpio->chip.direction_input = pcf857x_input8;\r\ngpio->chip.get = pcf857x_get8;\r\ngpio->chip.direction_output = pcf857x_output8;\r\ngpio->chip.set = pcf857x_set8;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_smbus_read_byte(client);\r\n} else if (gpio->chip.ngpio == 16) {\r\ngpio->chip.direction_input = pcf857x_input16;\r\ngpio->chip.get = pcf857x_get16;\r\ngpio->chip.direction_output = pcf857x_output16;\r\ngpio->chip.set = pcf857x_set16;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_read_le16(client);\r\n} else {\r\ndev_dbg(&client->dev, "unsupported number of gpios\n");\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto fail;\r\ngpio->chip.label = client->name;\r\ngpio->client = client;\r\ni2c_set_clientdata(client, gpio);\r\ngpio->out = pdata ? ~pdata->n_latch : ~0;\r\nstatus = gpiochip_add(&gpio->chip);\r\nif (status < 0)\r\ngoto fail;\r\ndev_info(&client->dev, "%s\n",\r\nclient->irq ? " (irq ignored)" : "");\r\nif (pdata && pdata->setup) {\r\nstatus = pdata->setup(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0)\r\ndev_warn(&client->dev, "setup --> %d\n", status);\r\n}\r\nreturn 0;\r\nfail:\r\ndev_dbg(&client->dev, "probe error %d for '%s'\n",\r\nstatus, client->name);\r\nkfree(gpio);\r\nreturn status;\r\n}\r\nstatic int pcf857x_remove(struct i2c_client *client)\r\n{\r\nstruct pcf857x_platform_data *pdata = client->dev.platform_data;\r\nstruct pcf857x *gpio = i2c_get_clientdata(client);\r\nint status = 0;\r\nif (pdata && pdata->teardown) {\r\nstatus = pdata->teardown(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0) {\r\ndev_err(&client->dev, "%s --> %d\n",\r\n"teardown", status);\r\nreturn status;\r\n}\r\n}\r\nstatus = gpiochip_remove(&gpio->chip);\r\nif (status == 0)\r\nkfree(gpio);\r\nelse\r\ndev_err(&client->dev, "%s --> %d\n", "remove", status);\r\nreturn status;\r\n}\r\nstatic int __init pcf857x_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf857x_driver);\r\n}\r\nstatic void __exit pcf857x_exit(void)\r\n{\r\ni2c_del_driver(&pcf857x_driver);\r\n}
