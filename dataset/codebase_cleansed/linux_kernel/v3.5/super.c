static void detected_xenix(struct sysv_sb_info *sbi, unsigned *max_links)\r\n{\r\nstruct buffer_head *bh1 = sbi->s_bh1;\r\nstruct buffer_head *bh2 = sbi->s_bh2;\r\nstruct xenix_super_block * sbd1;\r\nstruct xenix_super_block * sbd2;\r\nif (bh1 != bh2)\r\nsbd1 = sbd2 = (struct xenix_super_block *) bh1->b_data;\r\nelse {\r\nsbd1 = (struct xenix_super_block *) bh1->b_data;\r\nsbd2 = (struct xenix_super_block *) (bh2->b_data - 512);\r\n}\r\n*max_links = XENIX_LINK_MAX;\r\nsbi->s_fic_size = XENIX_NICINOD;\r\nsbi->s_flc_size = XENIX_NICFREE;\r\nsbi->s_sbd1 = (char *)sbd1;\r\nsbi->s_sbd2 = (char *)sbd2;\r\nsbi->s_sb_fic_count = &sbd1->s_ninode;\r\nsbi->s_sb_fic_inodes = &sbd1->s_inode[0];\r\nsbi->s_sb_total_free_inodes = &sbd2->s_tinode;\r\nsbi->s_bcache_count = &sbd1->s_nfree;\r\nsbi->s_bcache = &sbd1->s_free[0];\r\nsbi->s_free_blocks = &sbd2->s_tfree;\r\nsbi->s_sb_time = &sbd2->s_time;\r\nsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd1->s_isize);\r\nsbi->s_nzones = fs32_to_cpu(sbi, sbd1->s_fsize);\r\n}\r\nstatic void detected_sysv4(struct sysv_sb_info *sbi, unsigned *max_links)\r\n{\r\nstruct sysv4_super_block * sbd;\r\nstruct buffer_head *bh1 = sbi->s_bh1;\r\nstruct buffer_head *bh2 = sbi->s_bh2;\r\nif (bh1 == bh2)\r\nsbd = (struct sysv4_super_block *) (bh1->b_data + BLOCK_SIZE/2);\r\nelse\r\nsbd = (struct sysv4_super_block *) bh2->b_data;\r\n*max_links = SYSV_LINK_MAX;\r\nsbi->s_fic_size = SYSV_NICINOD;\r\nsbi->s_flc_size = SYSV_NICFREE;\r\nsbi->s_sbd1 = (char *)sbd;\r\nsbi->s_sbd2 = (char *)sbd;\r\nsbi->s_sb_fic_count = &sbd->s_ninode;\r\nsbi->s_sb_fic_inodes = &sbd->s_inode[0];\r\nsbi->s_sb_total_free_inodes = &sbd->s_tinode;\r\nsbi->s_bcache_count = &sbd->s_nfree;\r\nsbi->s_bcache = &sbd->s_free[0];\r\nsbi->s_free_blocks = &sbd->s_tfree;\r\nsbi->s_sb_time = &sbd->s_time;\r\nsbi->s_sb_state = &sbd->s_state;\r\nsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\r\nsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\r\n}\r\nstatic void detected_sysv2(struct sysv_sb_info *sbi, unsigned *max_links)\r\n{\r\nstruct sysv2_super_block *sbd;\r\nstruct buffer_head *bh1 = sbi->s_bh1;\r\nstruct buffer_head *bh2 = sbi->s_bh2;\r\nif (bh1 == bh2)\r\nsbd = (struct sysv2_super_block *) (bh1->b_data + BLOCK_SIZE/2);\r\nelse\r\nsbd = (struct sysv2_super_block *) bh2->b_data;\r\n*max_links = SYSV_LINK_MAX;\r\nsbi->s_fic_size = SYSV_NICINOD;\r\nsbi->s_flc_size = SYSV_NICFREE;\r\nsbi->s_sbd1 = (char *)sbd;\r\nsbi->s_sbd2 = (char *)sbd;\r\nsbi->s_sb_fic_count = &sbd->s_ninode;\r\nsbi->s_sb_fic_inodes = &sbd->s_inode[0];\r\nsbi->s_sb_total_free_inodes = &sbd->s_tinode;\r\nsbi->s_bcache_count = &sbd->s_nfree;\r\nsbi->s_bcache = &sbd->s_free[0];\r\nsbi->s_free_blocks = &sbd->s_tfree;\r\nsbi->s_sb_time = &sbd->s_time;\r\nsbi->s_sb_state = &sbd->s_state;\r\nsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\r\nsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\r\n}\r\nstatic void detected_coherent(struct sysv_sb_info *sbi, unsigned *max_links)\r\n{\r\nstruct coh_super_block * sbd;\r\nstruct buffer_head *bh1 = sbi->s_bh1;\r\nsbd = (struct coh_super_block *) bh1->b_data;\r\n*max_links = COH_LINK_MAX;\r\nsbi->s_fic_size = COH_NICINOD;\r\nsbi->s_flc_size = COH_NICFREE;\r\nsbi->s_sbd1 = (char *)sbd;\r\nsbi->s_sbd2 = (char *)sbd;\r\nsbi->s_sb_fic_count = &sbd->s_ninode;\r\nsbi->s_sb_fic_inodes = &sbd->s_inode[0];\r\nsbi->s_sb_total_free_inodes = &sbd->s_tinode;\r\nsbi->s_bcache_count = &sbd->s_nfree;\r\nsbi->s_bcache = &sbd->s_free[0];\r\nsbi->s_free_blocks = &sbd->s_tfree;\r\nsbi->s_sb_time = &sbd->s_time;\r\nsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\r\nsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\r\n}\r\nstatic void detected_v7(struct sysv_sb_info *sbi, unsigned *max_links)\r\n{\r\nstruct buffer_head *bh2 = sbi->s_bh2;\r\nstruct v7_super_block *sbd = (struct v7_super_block *)bh2->b_data;\r\n*max_links = V7_LINK_MAX;\r\nsbi->s_fic_size = V7_NICINOD;\r\nsbi->s_flc_size = V7_NICFREE;\r\nsbi->s_sbd1 = (char *)sbd;\r\nsbi->s_sbd2 = (char *)sbd;\r\nsbi->s_sb_fic_count = &sbd->s_ninode;\r\nsbi->s_sb_fic_inodes = &sbd->s_inode[0];\r\nsbi->s_sb_total_free_inodes = &sbd->s_tinode;\r\nsbi->s_bcache_count = &sbd->s_nfree;\r\nsbi->s_bcache = &sbd->s_free[0];\r\nsbi->s_free_blocks = &sbd->s_tfree;\r\nsbi->s_sb_time = &sbd->s_time;\r\nsbi->s_firstdatazone = fs16_to_cpu(sbi, sbd->s_isize);\r\nsbi->s_nzones = fs32_to_cpu(sbi, sbd->s_fsize);\r\n}\r\nstatic int detect_xenix(struct sysv_sb_info *sbi, struct buffer_head *bh)\r\n{\r\nstruct xenix_super_block *sbd = (struct xenix_super_block *)bh->b_data;\r\nif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0x2b5544))\r\nsbi->s_bytesex = BYTESEX_LE;\r\nelse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0x2b5544))\r\nsbi->s_bytesex = BYTESEX_BE;\r\nelse\r\nreturn 0;\r\nswitch (fs32_to_cpu(sbi, sbd->s_type)) {\r\ncase 1:\r\nsbi->s_type = FSTYPE_XENIX;\r\nreturn 1;\r\ncase 2:\r\nsbi->s_type = FSTYPE_XENIX;\r\nreturn 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int detect_sysv(struct sysv_sb_info *sbi, struct buffer_head *bh)\r\n{\r\nstruct super_block *sb = sbi->s_sb;\r\nstruct sysv4_super_block * sbd;\r\nu32 type;\r\nsbd = (struct sysv4_super_block *) (bh->b_data + BLOCK_SIZE/2);\r\nif (*(__le32 *)&sbd->s_magic == cpu_to_le32(0xfd187e20))\r\nsbi->s_bytesex = BYTESEX_LE;\r\nelse if (*(__be32 *)&sbd->s_magic == cpu_to_be32(0xfd187e20))\r\nsbi->s_bytesex = BYTESEX_BE;\r\nelse\r\nreturn 0;\r\ntype = fs32_to_cpu(sbi, sbd->s_type);\r\nif (fs16_to_cpu(sbi, sbd->s_nfree) == 0xffff) {\r\nsbi->s_type = FSTYPE_AFS;\r\nsbi->s_forced_ro = 1;\r\nif (!(sb->s_flags & MS_RDONLY)) {\r\nprintk("SysV FS: SCO EAFS on %s detected, "\r\n"forcing read-only mode.\n",\r\nsb->s_id);\r\n}\r\nreturn type;\r\n}\r\nif (fs32_to_cpu(sbi, sbd->s_time) < JAN_1_1980) {\r\nif (type > 3 || type < 1)\r\nreturn 0;\r\nsbi->s_type = FSTYPE_SYSV2;\r\nreturn type;\r\n}\r\nif ((type > 3 || type < 1) && (type > 0x30 || type < 0x10))\r\nreturn 0;\r\nif (type >= 0x10) {\r\nprintk("SysV FS: can't handle long file names on %s, "\r\n"forcing read-only mode.\n", sb->s_id);\r\nsbi->s_forced_ro = 1;\r\n}\r\nsbi->s_type = FSTYPE_SYSV4;\r\nreturn type >= 0x10 ? type >> 4 : type;\r\n}\r\nstatic int detect_coherent(struct sysv_sb_info *sbi, struct buffer_head *bh)\r\n{\r\nstruct coh_super_block * sbd;\r\nsbd = (struct coh_super_block *) (bh->b_data + BLOCK_SIZE/2);\r\nif ((memcmp(sbd->s_fname,"noname",6) && memcmp(sbd->s_fname,"xxxxx ",6))\r\n|| (memcmp(sbd->s_fpack,"nopack",6) && memcmp(sbd->s_fpack,"xxxxx\n",6)))\r\nreturn 0;\r\nsbi->s_bytesex = BYTESEX_PDP;\r\nsbi->s_type = FSTYPE_COH;\r\nreturn 1;\r\n}\r\nstatic int detect_sysv_odd(struct sysv_sb_info *sbi, struct buffer_head *bh)\r\n{\r\nint size = detect_sysv(sbi, bh);\r\nreturn size>2 ? 0 : size;\r\n}\r\nstatic int complete_read_super(struct super_block *sb, int silent, int size)\r\n{\r\nstruct sysv_sb_info *sbi = SYSV_SB(sb);\r\nstruct inode *root_inode;\r\nchar *found = flavour_names[sbi->s_type];\r\nu_char n_bits = size+8;\r\nint bsize = 1 << n_bits;\r\nint bsize_4 = bsize >> 2;\r\nsbi->s_firstinodezone = 2;\r\nflavour_setup[sbi->s_type](sbi, &sb->s_max_links);\r\nsbi->s_truncate = 1;\r\nsbi->s_ndatazones = sbi->s_nzones - sbi->s_firstdatazone;\r\nsbi->s_inodes_per_block = bsize >> 6;\r\nsbi->s_inodes_per_block_1 = (bsize >> 6)-1;\r\nsbi->s_inodes_per_block_bits = n_bits-6;\r\nsbi->s_ind_per_block = bsize_4;\r\nsbi->s_ind_per_block_2 = bsize_4*bsize_4;\r\nsbi->s_toobig_block = 10 + bsize_4 * (1 + bsize_4 * (1 + bsize_4));\r\nsbi->s_ind_per_block_bits = n_bits-2;\r\nsbi->s_ninodes = (sbi->s_firstdatazone - sbi->s_firstinodezone)\r\n<< sbi->s_inodes_per_block_bits;\r\nif (!silent)\r\nprintk("VFS: Found a %s FS (block size = %ld) on device %s\n",\r\nfound, sb->s_blocksize, sb->s_id);\r\nsb->s_magic = SYSV_MAGIC_BASE + sbi->s_type;\r\nsb->s_op = &sysv_sops;\r\nif (sbi->s_forced_ro)\r\nsb->s_flags |= MS_RDONLY;\r\nif (sbi->s_truncate)\r\nsb->s_d_op = &sysv_dentry_operations;\r\nroot_inode = sysv_iget(sb, SYSV_ROOT_INO);\r\nif (IS_ERR(root_inode)) {\r\nprintk("SysV FS: get root inode failed\n");\r\nreturn 0;\r\n}\r\nsb->s_root = d_make_root(root_inode);\r\nif (!sb->s_root) {\r\nprintk("SysV FS: get root dentry failed\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int sysv_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct buffer_head *bh1, *bh = NULL;\r\nstruct sysv_sb_info *sbi;\r\nunsigned long blocknr;\r\nint size = 0, i;\r\nBUILD_BUG_ON(1024 != sizeof (struct xenix_super_block));\r\nBUILD_BUG_ON(512 != sizeof (struct sysv4_super_block));\r\nBUILD_BUG_ON(512 != sizeof (struct sysv2_super_block));\r\nBUILD_BUG_ON(500 != sizeof (struct coh_super_block));\r\nBUILD_BUG_ON(64 != sizeof (struct sysv_inode));\r\nsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\r\nif (!sbi)\r\nreturn -ENOMEM;\r\nsbi->s_sb = sb;\r\nsbi->s_block_base = 0;\r\nsb->s_fs_info = sbi;\r\nsb_set_blocksize(sb, BLOCK_SIZE);\r\nfor (i = 0; i < ARRAY_SIZE(flavours) && !size; i++) {\r\nbrelse(bh);\r\nbh = sb_bread(sb, flavours[i].block);\r\nif (!bh)\r\ncontinue;\r\nsize = flavours[i].test(SYSV_SB(sb), bh);\r\n}\r\nif (!size)\r\ngoto Eunknown;\r\nswitch (size) {\r\ncase 1:\r\nblocknr = bh->b_blocknr << 1;\r\nbrelse(bh);\r\nsb_set_blocksize(sb, 512);\r\nbh1 = sb_bread(sb, blocknr);\r\nbh = sb_bread(sb, blocknr + 1);\r\nbreak;\r\ncase 2:\r\nbh1 = bh;\r\nbreak;\r\ncase 3:\r\nblocknr = bh->b_blocknr >> 1;\r\nbrelse(bh);\r\nsb_set_blocksize(sb, 2048);\r\nbh1 = bh = sb_bread(sb, blocknr);\r\nbreak;\r\ndefault:\r\ngoto Ebadsize;\r\n}\r\nif (bh && bh1) {\r\nsbi->s_bh1 = bh1;\r\nsbi->s_bh2 = bh;\r\nif (complete_read_super(sb, silent, size))\r\nreturn 0;\r\n}\r\nbrelse(bh1);\r\nbrelse(bh);\r\nsb_set_blocksize(sb, BLOCK_SIZE);\r\nprintk("oldfs: cannot read superblock\n");\r\nfailed:\r\nkfree(sbi);\r\nreturn -EINVAL;\r\nEunknown:\r\nbrelse(bh);\r\nif (!silent)\r\nprintk("VFS: unable to find oldfs superblock on device %s\n",\r\nsb->s_id);\r\ngoto failed;\r\nEbadsize:\r\nbrelse(bh);\r\nif (!silent)\r\nprintk("VFS: oldfs: unsupported block size (%dKb)\n",\r\n1<<(size-2));\r\ngoto failed;\r\n}\r\nstatic int v7_sanity_check(struct super_block *sb, struct buffer_head *bh)\r\n{\r\nstruct v7_super_block *v7sb;\r\nstruct sysv_inode *v7i;\r\nstruct buffer_head *bh2;\r\nstruct sysv_sb_info *sbi;\r\nsbi = sb->s_fs_info;\r\nv7sb = (struct v7_super_block *) bh->b_data;\r\nif (fs16_to_cpu(sbi, v7sb->s_nfree) > V7_NICFREE ||\r\nfs16_to_cpu(sbi, v7sb->s_ninode) > V7_NICINOD ||\r\nfs32_to_cpu(sbi, v7sb->s_fsize) > V7_MAXSIZE)\r\nreturn 0;\r\nbh2 = sb_bread(sb, 2);\r\nif (bh2 == NULL)\r\nreturn 0;\r\nv7i = (struct sysv_inode *)(bh2->b_data + 64);\r\nif ((fs16_to_cpu(sbi, v7i->i_mode) & ~0777) != S_IFDIR ||\r\n(fs32_to_cpu(sbi, v7i->i_size) == 0) ||\r\n(fs32_to_cpu(sbi, v7i->i_size) & 017) ||\r\n(fs32_to_cpu(sbi, v7i->i_size) > V7_NFILES *\r\nsizeof(struct sysv_dir_entry))) {\r\nbrelse(bh2);\r\nreturn 0;\r\n}\r\nbrelse(bh2);\r\nreturn 1;\r\n}\r\nstatic int v7_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct sysv_sb_info *sbi;\r\nstruct buffer_head *bh;\r\nif (440 != sizeof (struct v7_super_block))\r\npanic("V7 FS: bad super-block size");\r\nif (64 != sizeof (struct sysv_inode))\r\npanic("sysv fs: bad i-node size");\r\nsbi = kzalloc(sizeof(struct sysv_sb_info), GFP_KERNEL);\r\nif (!sbi)\r\nreturn -ENOMEM;\r\nsbi->s_sb = sb;\r\nsbi->s_block_base = 0;\r\nsbi->s_type = FSTYPE_V7;\r\nsb->s_fs_info = sbi;\r\nsb_set_blocksize(sb, 512);\r\nif ((bh = sb_bread(sb, 1)) == NULL) {\r\nif (!silent)\r\nprintk("VFS: unable to read V7 FS superblock on "\r\n"device %s.\n", sb->s_id);\r\ngoto failed;\r\n}\r\nsbi->s_bytesex = BYTESEX_PDP;\r\nif (v7_sanity_check(sb, bh))\r\ngoto detected;\r\nsbi->s_bytesex = BYTESEX_LE;\r\nif (v7_sanity_check(sb, bh))\r\ngoto detected;\r\ngoto failed;\r\ndetected:\r\nsbi->s_bh1 = bh;\r\nsbi->s_bh2 = bh;\r\nif (complete_read_super(sb, silent, 1))\r\nreturn 0;\r\nfailed:\r\nprintk(KERN_ERR "VFS: could not find a valid V7 on %s.\n",\r\nsb->s_id);\r\nbrelse(bh);\r\nkfree(sbi);\r\nreturn -EINVAL;\r\n}\r\nstatic struct dentry *sysv_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, sysv_fill_super);\r\n}\r\nstatic struct dentry *v7_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, v7_fill_super);\r\n}\r\nstatic int __init init_sysv_fs(void)\r\n{\r\nint error;\r\nerror = sysv_init_icache();\r\nif (error)\r\ngoto out;\r\nerror = register_filesystem(&sysv_fs_type);\r\nif (error)\r\ngoto destroy_icache;\r\nerror = register_filesystem(&v7_fs_type);\r\nif (error)\r\ngoto unregister;\r\nreturn 0;\r\nunregister:\r\nunregister_filesystem(&sysv_fs_type);\r\ndestroy_icache:\r\nsysv_destroy_icache();\r\nout:\r\nreturn error;\r\n}\r\nstatic void __exit exit_sysv_fs(void)\r\n{\r\nunregister_filesystem(&sysv_fs_type);\r\nunregister_filesystem(&v7_fs_type);\r\nsysv_destroy_icache();\r\n}
