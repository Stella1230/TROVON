static inline u8 __iomem * rowaddr(struct fb_info *info, u_int row)\r\n{\r\nreturn info->screen_base + HGA_ROWADDR(row);\r\n}\r\nstatic void write_hga_b(unsigned int val, unsigned char reg)\r\n{\r\noutb_p(reg, HGA_INDEX_PORT);\r\noutb_p(val, HGA_VALUE_PORT);\r\n}\r\nstatic void write_hga_w(unsigned int val, unsigned char reg)\r\n{\r\noutb_p(reg, HGA_INDEX_PORT); outb_p(val >> 8, HGA_VALUE_PORT);\r\noutb_p(reg+1, HGA_INDEX_PORT); outb_p(val & 0xff, HGA_VALUE_PORT);\r\n}\r\nstatic int test_hga_b(unsigned char val, unsigned char reg)\r\n{\r\noutb_p(reg, HGA_INDEX_PORT);\r\noutb (val, HGA_VALUE_PORT);\r\nudelay(20); val = (inb_p(HGA_VALUE_PORT) == val);\r\nreturn val;\r\n}\r\nstatic void hga_clear_screen(void)\r\n{\r\nunsigned char fillchar = 0xbf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hga_reg_lock, flags);\r\nif (hga_mode == HGA_TXT)\r\nfillchar = ' ';\r\nelse if (hga_mode == HGA_GFX)\r\nfillchar = 0x00;\r\nspin_unlock_irqrestore(&hga_reg_lock, flags);\r\nif (fillchar != 0xbf)\r\nmemset_io(hga_vram, fillchar, hga_vram_len);\r\n}\r\nstatic void hga_txt_mode(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hga_reg_lock, flags);\r\noutb_p(HGA_MODE_VIDEO_EN | HGA_MODE_BLINK_EN, HGA_MODE_PORT);\r\noutb_p(0x00, HGA_GFX_PORT);\r\noutb_p(0x00, HGA_STATUS_PORT);\r\nwrite_hga_b(0x61, 0x00);\r\nwrite_hga_b(0x50, 0x01);\r\nwrite_hga_b(0x52, 0x02);\r\nwrite_hga_b(0x0f, 0x03);\r\nwrite_hga_b(0x19, 0x04);\r\nwrite_hga_b(0x06, 0x05);\r\nwrite_hga_b(0x19, 0x06);\r\nwrite_hga_b(0x19, 0x07);\r\nwrite_hga_b(0x02, 0x08);\r\nwrite_hga_b(0x0d, 0x09);\r\nwrite_hga_b(0x0c, 0x0a);\r\nwrite_hga_b(0x0d, 0x0b);\r\nwrite_hga_w(0x0000, 0x0c);\r\nwrite_hga_w(0x0000, 0x0e);\r\nhga_mode = HGA_TXT;\r\nspin_unlock_irqrestore(&hga_reg_lock, flags);\r\n}\r\nstatic void hga_gfx_mode(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hga_reg_lock, flags);\r\noutb_p(0x00, HGA_STATUS_PORT);\r\noutb_p(HGA_GFX_MODE_EN, HGA_GFX_PORT);\r\noutb_p(HGA_MODE_VIDEO_EN | HGA_MODE_GRAPHICS, HGA_MODE_PORT);\r\nwrite_hga_b(0x35, 0x00);\r\nwrite_hga_b(0x2d, 0x01);\r\nwrite_hga_b(0x2e, 0x02);\r\nwrite_hga_b(0x07, 0x03);\r\nwrite_hga_b(0x5b, 0x04);\r\nwrite_hga_b(0x02, 0x05);\r\nwrite_hga_b(0x57, 0x06);\r\nwrite_hga_b(0x57, 0x07);\r\nwrite_hga_b(0x02, 0x08);\r\nwrite_hga_b(0x03, 0x09);\r\nwrite_hga_b(0x00, 0x0a);\r\nwrite_hga_b(0x00, 0x0b);\r\nwrite_hga_w(0x0000, 0x0c);\r\nwrite_hga_w(0x0000, 0x0e);\r\nhga_mode = HGA_GFX;\r\nspin_unlock_irqrestore(&hga_reg_lock, flags);\r\n}\r\nstatic void hga_show_logo(struct fb_info *info)\r\n{\r\n}\r\nstatic void hga_pan(unsigned int xoffset, unsigned int yoffset)\r\n{\r\nunsigned int base;\r\nunsigned long flags;\r\nbase = (yoffset / 8) * 90 + xoffset;\r\nspin_lock_irqsave(&hga_reg_lock, flags);\r\nwrite_hga_w(base, 0x0c);\r\nspin_unlock_irqrestore(&hga_reg_lock, flags);\r\nDPRINTK("hga_pan: base:%d\n", base);\r\n}\r\nstatic void hga_blank(int blank_mode)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hga_reg_lock, flags);\r\nif (blank_mode) {\r\noutb_p(0x00, HGA_MODE_PORT);\r\n} else {\r\noutb_p(HGA_MODE_VIDEO_EN | HGA_MODE_GRAPHICS, HGA_MODE_PORT);\r\n}\r\nspin_unlock_irqrestore(&hga_reg_lock, flags);\r\n}\r\nstatic int __devinit hga_card_detect(void)\r\n{\r\nint count = 0;\r\nvoid __iomem *p, *q;\r\nunsigned short p_save, q_save;\r\nhga_vram_len = 0x08000;\r\nhga_vram = ioremap(0xb0000, hga_vram_len);\r\nif (request_region(0x3b0, 12, "hgafb"))\r\nrelease_io_ports = 1;\r\nif (request_region(0x3bf, 1, "hgafb"))\r\nrelease_io_port = 1;\r\np = hga_vram;\r\nq = hga_vram + 0x01000;\r\np_save = readw(p); q_save = readw(q);\r\nwritew(0xaa55, p); if (readw(p) == 0xaa55) count++;\r\nwritew(0x55aa, p); if (readw(p) == 0x55aa) count++;\r\nwritew(p_save, p);\r\nif (count != 2)\r\ngoto error;\r\nif (!test_hga_b(0x66, 0x0f))\r\ngoto error;\r\nif (!test_hga_b(0x99, 0x0f))\r\ngoto error;\r\np_save = q_save = inb_p(HGA_STATUS_PORT) & HGA_STATUS_VSYNC;\r\nfor (count=0; count < 50000 && p_save == q_save; count++) {\r\nq_save = inb(HGA_STATUS_PORT) & HGA_STATUS_VSYNC;\r\nudelay(2);\r\n}\r\nif (p_save == q_save)\r\ngoto error;\r\nswitch (inb_p(HGA_STATUS_PORT) & 0x70) {\r\ncase 0x10:\r\nhga_type = TYPE_HERCPLUS;\r\nhga_type_name = "HerculesPlus";\r\nbreak;\r\ncase 0x50:\r\nhga_type = TYPE_HERCCOLOR;\r\nhga_type_name = "HerculesColor";\r\nbreak;\r\ndefault:\r\nhga_type = TYPE_HERC;\r\nhga_type_name = "Hercules";\r\nbreak;\r\n}\r\nreturn 1;\r\nerror:\r\nif (release_io_ports)\r\nrelease_region(0x3b0, 12);\r\nif (release_io_port)\r\nrelease_region(0x3bf, 1);\r\nreturn 0;\r\n}\r\nstatic int hgafb_open(struct fb_info *info, int init)\r\n{\r\nhga_gfx_mode();\r\nhga_clear_screen();\r\nif (!nologo) hga_show_logo(info);\r\nreturn 0;\r\n}\r\nstatic int hgafb_release(struct fb_info *info, int init)\r\n{\r\nhga_txt_mode();\r\nhga_clear_screen();\r\nreturn 0;\r\n}\r\nstatic int hgafb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nif (regno > 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hgafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->yoffset < 0 ||\r\nvar->yoffset >= info->var.yres_virtual ||\r\nvar->xoffset)\r\nreturn -EINVAL;\r\n} else {\r\nif (var->xoffset + info->var.xres > info->var.xres_virtual\r\n|| var->yoffset + info->var.yres > info->var.yres_virtual\r\n|| var->yoffset % 8)\r\nreturn -EINVAL;\r\n}\r\nhga_pan(var->xoffset, var->yoffset);\r\nreturn 0;\r\n}\r\nstatic int hgafb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nhga_blank(blank_mode);\r\nreturn 0;\r\n}\r\nstatic void hgafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nu_int rows, y;\r\nu8 __iomem *dest;\r\ny = rect->dy;\r\nfor (rows = rect->height; rows--; y++) {\r\ndest = rowaddr(info, y) + (rect->dx >> 3);\r\nswitch (rect->rop) {\r\ncase ROP_COPY:\r\nmemset_io(dest, rect->color, (rect->width >> 3));\r\nbreak;\r\ncase ROP_XOR:\r\nfb_writeb(~(fb_readb(dest)), dest);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void hgafb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nu_int rows, y1, y2;\r\nu8 __iomem *src;\r\nu8 __iomem *dest;\r\nif (area->dy <= area->sy) {\r\ny1 = area->sy;\r\ny2 = area->dy;\r\nfor (rows = area->height; rows--; ) {\r\nsrc = rowaddr(info, y1) + (area->sx >> 3);\r\ndest = rowaddr(info, y2) + (area->dx >> 3);\r\nmemmove(dest, src, (area->width >> 3));\r\ny1++;\r\ny2++;\r\n}\r\n} else {\r\ny1 = area->sy + area->height - 1;\r\ny2 = area->dy + area->height - 1;\r\nfor (rows = area->height; rows--;) {\r\nsrc = rowaddr(info, y1) + (area->sx >> 3);\r\ndest = rowaddr(info, y2) + (area->dx >> 3);\r\nmemmove(dest, src, (area->width >> 3));\r\ny1--;\r\ny2--;\r\n}\r\n}\r\n}\r\nstatic void hgafb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nu8 __iomem *dest;\r\nu8 *cdat = (u8 *) image->data;\r\nu_int rows, y = image->dy;\r\nu_int x;\r\nu8 d;\r\nfor (rows = image->height; rows--; y++) {\r\nfor (x = 0; x < image->width; x+= 8) {\r\nd = *cdat++;\r\ndest = rowaddr(info, y) + ((image->dx + x)>> 3);\r\nfb_writeb(d, dest);\r\n}\r\n}\r\n}\r\nstatic int __devinit hgafb_probe(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info;\r\nif (! hga_card_detect()) {\r\nprintk(KERN_INFO "hgafb: HGA card not detected.\n");\r\nif (hga_vram)\r\niounmap(hga_vram);\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "hgafb: %s with %ldK of memory detected.\n",\r\nhga_type_name, hga_vram_len/1024);\r\ninfo = framebuffer_alloc(0, &pdev->dev);\r\nif (!info) {\r\niounmap(hga_vram);\r\nreturn -ENOMEM;\r\n}\r\nhga_fix.smem_start = (unsigned long)hga_vram;\r\nhga_fix.smem_len = hga_vram_len;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\ninfo->var = hga_default_var;\r\ninfo->fix = hga_fix;\r\ninfo->monspecs.hfmin = 0;\r\ninfo->monspecs.hfmax = 0;\r\ninfo->monspecs.vfmin = 10000;\r\ninfo->monspecs.vfmax = 10000;\r\ninfo->monspecs.dpms = 0;\r\ninfo->fbops = &hgafb_ops;\r\ninfo->screen_base = hga_vram;\r\nif (register_framebuffer(info) < 0) {\r\nframebuffer_release(info);\r\niounmap(hga_vram);\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nplatform_set_drvdata(pdev, info);\r\nreturn 0;\r\n}\r\nstatic int __devexit hgafb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nhga_txt_mode();\r\nhga_clear_screen();\r\nif (info) {\r\nunregister_framebuffer(info);\r\nframebuffer_release(info);\r\n}\r\niounmap(hga_vram);\r\nif (release_io_ports)\r\nrelease_region(0x3b0, 12);\r\nif (release_io_port)\r\nrelease_region(0x3bf, 1);\r\nreturn 0;\r\n}\r\nstatic int __init hgafb_init(void)\r\n{\r\nint ret;\r\nif (fb_get_options("hgafb", NULL))\r\nreturn -ENODEV;\r\nret = platform_driver_register(&hgafb_driver);\r\nif (!ret) {\r\nhgafb_device = platform_device_register_simple("hgafb", 0, NULL, 0);\r\nif (IS_ERR(hgafb_device)) {\r\nplatform_driver_unregister(&hgafb_driver);\r\nret = PTR_ERR(hgafb_device);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit hgafb_exit(void)\r\n{\r\nplatform_device_unregister(hgafb_device);\r\nplatform_driver_unregister(&hgafb_driver);\r\n}
