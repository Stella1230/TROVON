static int\r\nefx_spi_slow_wait(struct efx_mtd_partition *part, bool uninterruptible)\r\n{\r\nstruct efx_mtd *efx_mtd = part->mtd.priv;\r\nconst struct efx_spi_device *spi = efx_mtd->spi;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nu8 status;\r\nint rc, i;\r\nfor (i = 0; i < 40; i++) {\r\n__set_current_state(uninterruptible ?\r\nTASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ / 10);\r\nrc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,\r\n&status, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nif (!(status & SPI_STATUS_NRDY))\r\nreturn 0;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\npr_err("%s: timed out waiting for %s\n", part->name, efx_mtd->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\nefx_spi_unlock(struct efx_nic *efx, const struct efx_spi_device *spi)\r\n{\r\nconst u8 unlock_mask = (SPI_STATUS_BP2 | SPI_STATUS_BP1 |\r\nSPI_STATUS_BP0);\r\nu8 status;\r\nint rc;\r\nrc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,\r\n&status, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nif (!(status & unlock_mask))\r\nreturn 0;\r\nrc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_cmd(efx, spi, SPI_SST_EWSR, -1, NULL, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nstatus &= ~unlock_mask;\r\nrc = falcon_spi_cmd(efx, spi, SPI_WRSR, -1, &status,\r\nNULL, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_wait_write(efx, spi);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int\r\nefx_spi_erase(struct efx_mtd_partition *part, loff_t start, size_t len)\r\n{\r\nstruct efx_mtd *efx_mtd = part->mtd.priv;\r\nconst struct efx_spi_device *spi = efx_mtd->spi;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nunsigned pos, block_len;\r\nu8 empty[EFX_SPI_VERIFY_BUF_LEN];\r\nu8 buffer[EFX_SPI_VERIFY_BUF_LEN];\r\nint rc;\r\nif (len != spi->erase_size)\r\nreturn -EINVAL;\r\nif (spi->erase_command == 0)\r\nreturn -EOPNOTSUPP;\r\nrc = efx_spi_unlock(efx, spi);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_cmd(efx, spi, spi->erase_command, start, NULL,\r\nNULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = efx_spi_slow_wait(part, false);\r\nmemset(empty, 0xff, sizeof(empty));\r\nfor (pos = 0; pos < len; pos += block_len) {\r\nblock_len = min(len - pos, sizeof(buffer));\r\nrc = falcon_spi_read(efx, spi, start + pos, block_len,\r\nNULL, buffer);\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(empty, buffer, block_len))\r\nreturn -EIO;\r\ncond_resched();\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\nreturn rc;\r\n}\r\nstatic int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)\r\n{\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nint rc;\r\nrc = efx_mtd->ops->erase(mtd, erase->addr, erase->len);\r\nif (rc == 0) {\r\nerase->state = MTD_ERASE_DONE;\r\n} else {\r\nerase->state = MTD_ERASE_FAILED;\r\nerase->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\r\n}\r\nmtd_erase_callback(erase);\r\nreturn rc;\r\n}\r\nstatic void efx_mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nint rc;\r\nrc = efx_mtd->ops->sync(mtd);\r\nif (rc)\r\npr_err("%s: %s sync failed (%d)\n",\r\npart->name, efx_mtd->name, rc);\r\n}\r\nstatic void efx_mtd_remove_partition(struct efx_mtd_partition *part)\r\n{\r\nint rc;\r\nfor (;;) {\r\nrc = mtd_device_unregister(&part->mtd);\r\nif (rc != -EBUSY)\r\nbreak;\r\nssleep(1);\r\n}\r\nWARN_ON(rc);\r\n}\r\nstatic void efx_mtd_remove_device(struct efx_mtd *efx_mtd)\r\n{\r\nstruct efx_mtd_partition *part;\r\nefx_for_each_partition(part, efx_mtd)\r\nefx_mtd_remove_partition(part);\r\nlist_del(&efx_mtd->node);\r\nkfree(efx_mtd);\r\n}\r\nstatic void efx_mtd_rename_device(struct efx_mtd *efx_mtd)\r\n{\r\nstruct efx_mtd_partition *part;\r\nefx_for_each_partition(part, efx_mtd)\r\nif (efx_nic_rev(efx_mtd->efx) >= EFX_REV_SIENA_A0)\r\nsnprintf(part->name, sizeof(part->name),\r\n"%s %s:%02x", efx_mtd->efx->name,\r\npart->type_name, part->mcdi.fw_subtype);\r\nelse\r\nsnprintf(part->name, sizeof(part->name),\r\n"%s %s", efx_mtd->efx->name,\r\npart->type_name);\r\n}\r\nstatic int efx_mtd_probe_device(struct efx_nic *efx, struct efx_mtd *efx_mtd)\r\n{\r\nstruct efx_mtd_partition *part;\r\nefx_mtd->efx = efx;\r\nefx_mtd_rename_device(efx_mtd);\r\nefx_for_each_partition(part, efx_mtd) {\r\npart->mtd.writesize = 1;\r\npart->mtd.owner = THIS_MODULE;\r\npart->mtd.priv = efx_mtd;\r\npart->mtd.name = part->name;\r\npart->mtd._erase = efx_mtd_erase;\r\npart->mtd._read = efx_mtd->ops->read;\r\npart->mtd._write = efx_mtd->ops->write;\r\npart->mtd._sync = efx_mtd_sync;\r\nif (mtd_device_register(&part->mtd, NULL, 0))\r\ngoto fail;\r\n}\r\nlist_add(&efx_mtd->node, &efx->mtd_list);\r\nreturn 0;\r\nfail:\r\nwhile (part != &efx_mtd->part[0]) {\r\n--part;\r\nefx_mtd_remove_partition(part);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nvoid efx_mtd_remove(struct efx_nic *efx)\r\n{\r\nstruct efx_mtd *efx_mtd, *next;\r\nWARN_ON(efx_dev_registered(efx));\r\nlist_for_each_entry_safe(efx_mtd, next, &efx->mtd_list, node)\r\nefx_mtd_remove_device(efx_mtd);\r\n}\r\nvoid efx_mtd_rename(struct efx_nic *efx)\r\n{\r\nstruct efx_mtd *efx_mtd;\r\nASSERT_RTNL();\r\nlist_for_each_entry(efx_mtd, &efx->mtd_list, node)\r\nefx_mtd_rename_device(efx_mtd);\r\n}\r\nint efx_mtd_probe(struct efx_nic *efx)\r\n{\r\nif (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)\r\nreturn siena_mtd_probe(efx);\r\nelse\r\nreturn falcon_mtd_probe(efx);\r\n}\r\nstatic int falcon_mtd_read(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, u8 *buffer)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nconst struct efx_spi_device *spi = efx_mtd->spi;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = mutex_lock_interruptible(&nic_data->spi_lock);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_read(efx, spi, part->offset + start, len,\r\nretlen, buffer);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = mutex_lock_interruptible(&nic_data->spi_lock);\r\nif (rc)\r\nreturn rc;\r\nrc = efx_spi_erase(part, part->offset + start, len);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_write(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, const u8 *buffer)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nconst struct efx_spi_device *spi = efx_mtd->spi;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = mutex_lock_interruptible(&nic_data->spi_lock);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_write(efx, spi, part->offset + start, len,\r\nretlen, buffer);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nmutex_lock(&nic_data->spi_lock);\r\nrc = efx_spi_slow_wait(part, true);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_probe(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct efx_spi_device *spi;\r\nstruct efx_mtd *efx_mtd;\r\nint rc = -ENODEV;\r\nASSERT_RTNL();\r\nspi = &nic_data->spi_flash;\r\nif (efx_spi_present(spi) && spi->size > FALCON_FLASH_BOOTCODE_START) {\r\nefx_mtd = kzalloc(sizeof(*efx_mtd) + sizeof(efx_mtd->part[0]),\r\nGFP_KERNEL);\r\nif (!efx_mtd)\r\nreturn -ENOMEM;\r\nefx_mtd->spi = spi;\r\nefx_mtd->name = "flash";\r\nefx_mtd->ops = &falcon_mtd_ops;\r\nefx_mtd->n_parts = 1;\r\nefx_mtd->part[0].mtd.type = MTD_NORFLASH;\r\nefx_mtd->part[0].mtd.flags = MTD_CAP_NORFLASH;\r\nefx_mtd->part[0].mtd.size = spi->size - FALCON_FLASH_BOOTCODE_START;\r\nefx_mtd->part[0].mtd.erasesize = spi->erase_size;\r\nefx_mtd->part[0].offset = FALCON_FLASH_BOOTCODE_START;\r\nefx_mtd->part[0].type_name = "sfc_flash_bootrom";\r\nrc = efx_mtd_probe_device(efx, efx_mtd);\r\nif (rc) {\r\nkfree(efx_mtd);\r\nreturn rc;\r\n}\r\n}\r\nspi = &nic_data->spi_eeprom;\r\nif (efx_spi_present(spi) && spi->size > EFX_EEPROM_BOOTCONFIG_START) {\r\nefx_mtd = kzalloc(sizeof(*efx_mtd) + sizeof(efx_mtd->part[0]),\r\nGFP_KERNEL);\r\nif (!efx_mtd)\r\nreturn -ENOMEM;\r\nefx_mtd->spi = spi;\r\nefx_mtd->name = "EEPROM";\r\nefx_mtd->ops = &falcon_mtd_ops;\r\nefx_mtd->n_parts = 1;\r\nefx_mtd->part[0].mtd.type = MTD_RAM;\r\nefx_mtd->part[0].mtd.flags = MTD_CAP_RAM;\r\nefx_mtd->part[0].mtd.size =\r\nmin(spi->size, EFX_EEPROM_BOOTCONFIG_END) -\r\nEFX_EEPROM_BOOTCONFIG_START;\r\nefx_mtd->part[0].mtd.erasesize = spi->erase_size;\r\nefx_mtd->part[0].offset = EFX_EEPROM_BOOTCONFIG_START;\r\nefx_mtd->part[0].type_name = "sfc_bootconfig";\r\nrc = efx_mtd_probe_device(efx, efx_mtd);\r\nif (rc) {\r\nkfree(efx_mtd);\r\nreturn rc;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int siena_mtd_read(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, u8 *buffer)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nloff_t offset = start;\r\nloff_t end = min_t(loff_t, start + len, mtd->size);\r\nsize_t chunk;\r\nint rc = 0;\r\nwhile (offset < end) {\r\nchunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);\r\nrc = efx_mcdi_nvram_read(efx, part->mcdi.nvram_type, offset,\r\nbuffer, chunk);\r\nif (rc)\r\ngoto out;\r\noffset += chunk;\r\nbuffer += chunk;\r\n}\r\nout:\r\n*retlen = offset - start;\r\nreturn rc;\r\n}\r\nstatic int siena_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nloff_t offset = start & ~((loff_t)(mtd->erasesize - 1));\r\nloff_t end = min_t(loff_t, start + len, mtd->size);\r\nsize_t chunk = part->mtd.erasesize;\r\nint rc = 0;\r\nif (!part->mcdi.updating) {\r\nrc = efx_mcdi_nvram_update_start(efx, part->mcdi.nvram_type);\r\nif (rc)\r\ngoto out;\r\npart->mcdi.updating = true;\r\n}\r\nwhile (offset < end) {\r\nrc = efx_mcdi_nvram_erase(efx, part->mcdi.nvram_type, offset,\r\nchunk);\r\nif (rc)\r\ngoto out;\r\noffset += chunk;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int siena_mtd_write(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, const u8 *buffer)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nloff_t offset = start;\r\nloff_t end = min_t(loff_t, start + len, mtd->size);\r\nsize_t chunk;\r\nint rc = 0;\r\nif (!part->mcdi.updating) {\r\nrc = efx_mcdi_nvram_update_start(efx, part->mcdi.nvram_type);\r\nif (rc)\r\ngoto out;\r\npart->mcdi.updating = true;\r\n}\r\nwhile (offset < end) {\r\nchunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);\r\nrc = efx_mcdi_nvram_write(efx, part->mcdi.nvram_type, offset,\r\nbuffer, chunk);\r\nif (rc)\r\ngoto out;\r\noffset += chunk;\r\nbuffer += chunk;\r\n}\r\nout:\r\n*retlen = offset - start;\r\nreturn rc;\r\n}\r\nstatic int siena_mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct efx_mtd_partition *part = to_efx_mtd_partition(mtd);\r\nstruct efx_mtd *efx_mtd = mtd->priv;\r\nstruct efx_nic *efx = efx_mtd->efx;\r\nint rc = 0;\r\nif (part->mcdi.updating) {\r\npart->mcdi.updating = false;\r\nrc = efx_mcdi_nvram_update_finish(efx, part->mcdi.nvram_type);\r\n}\r\nreturn rc;\r\n}\r\nstatic int siena_mtd_probe_partition(struct efx_nic *efx,\r\nstruct efx_mtd *efx_mtd,\r\nunsigned int part_id,\r\nunsigned int type)\r\n{\r\nstruct efx_mtd_partition *part = &efx_mtd->part[part_id];\r\nconst struct siena_nvram_type_info *info;\r\nsize_t size, erase_size;\r\nbool protected;\r\nint rc;\r\nif (type >= ARRAY_SIZE(siena_nvram_types))\r\nreturn -ENODEV;\r\ninfo = &siena_nvram_types[type];\r\nif (info->port != efx_port_num(efx))\r\nreturn -ENODEV;\r\nrc = efx_mcdi_nvram_info(efx, type, &size, &erase_size, &protected);\r\nif (rc)\r\nreturn rc;\r\nif (protected)\r\nreturn -ENODEV;\r\npart->mcdi.nvram_type = type;\r\npart->type_name = info->name;\r\npart->mtd.type = MTD_NORFLASH;\r\npart->mtd.flags = MTD_CAP_NORFLASH;\r\npart->mtd.size = size;\r\npart->mtd.erasesize = erase_size;\r\nreturn 0;\r\n}\r\nstatic int siena_mtd_get_fw_subtypes(struct efx_nic *efx,\r\nstruct efx_mtd *efx_mtd)\r\n{\r\nstruct efx_mtd_partition *part;\r\nuint16_t fw_subtype_list[MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MINNUM];\r\nint rc;\r\nrc = efx_mcdi_get_board_cfg(efx, NULL, fw_subtype_list, NULL);\r\nif (rc)\r\nreturn rc;\r\nefx_for_each_partition(part, efx_mtd)\r\npart->mcdi.fw_subtype = fw_subtype_list[part->mcdi.nvram_type];\r\nreturn 0;\r\n}\r\nstatic int siena_mtd_probe(struct efx_nic *efx)\r\n{\r\nstruct efx_mtd *efx_mtd;\r\nint rc = -ENODEV;\r\nu32 nvram_types;\r\nunsigned int type;\r\nASSERT_RTNL();\r\nrc = efx_mcdi_nvram_types(efx, &nvram_types);\r\nif (rc)\r\nreturn rc;\r\nefx_mtd = kzalloc(sizeof(*efx_mtd) +\r\nhweight32(nvram_types) * sizeof(efx_mtd->part[0]),\r\nGFP_KERNEL);\r\nif (!efx_mtd)\r\nreturn -ENOMEM;\r\nefx_mtd->name = "Siena NVRAM manager";\r\nefx_mtd->ops = &siena_mtd_ops;\r\ntype = 0;\r\nefx_mtd->n_parts = 0;\r\nwhile (nvram_types != 0) {\r\nif (nvram_types & 1) {\r\nrc = siena_mtd_probe_partition(efx, efx_mtd,\r\nefx_mtd->n_parts, type);\r\nif (rc == 0)\r\nefx_mtd->n_parts++;\r\nelse if (rc != -ENODEV)\r\ngoto fail;\r\n}\r\ntype++;\r\nnvram_types >>= 1;\r\n}\r\nrc = siena_mtd_get_fw_subtypes(efx, efx_mtd);\r\nif (rc)\r\ngoto fail;\r\nrc = efx_mtd_probe_device(efx, efx_mtd);\r\nfail:\r\nif (rc)\r\nkfree(efx_mtd);\r\nreturn rc;\r\n}
