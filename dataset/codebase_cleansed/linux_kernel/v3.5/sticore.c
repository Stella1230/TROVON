static int sti_init_graph(struct sti_struct *sti)\r\n{\r\nstruct sti_init_inptr_ext inptr_ext = { 0, };\r\nstruct sti_init_inptr inptr = {\r\n.text_planes = 3,\r\n.ext_ptr = STI_PTR(&inptr_ext)\r\n};\r\nstruct sti_init_outptr outptr = { 0, };\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&sti->lock, flags);\r\nret = STI_CALL(sti->init_graph, &default_init_flags, &inptr,\r\n&outptr, sti->glob_cfg);\r\nspin_unlock_irqrestore(&sti->lock, flags);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "STI init_graph failed (ret %d, errno %d)\n",ret,outptr.errno);\r\nreturn -1;\r\n}\r\nsti->text_planes = outptr.text_planes;\r\nreturn 0;\r\n}\r\nstatic void sti_inq_conf(struct sti_struct *sti)\r\n{\r\nstruct sti_conf_inptr inptr = { 0, };\r\nunsigned long flags;\r\ns32 ret;\r\nsti->outptr.ext_ptr = STI_PTR(&sti->outptr_ext);\r\ndo {\r\nspin_lock_irqsave(&sti->lock, flags);\r\nret = STI_CALL(sti->inq_conf, &default_conf_flags,\r\n&inptr, &sti->outptr, sti->glob_cfg);\r\nspin_unlock_irqrestore(&sti->lock, flags);\r\n} while (ret == 1);\r\n}\r\nvoid\r\nsti_putc(struct sti_struct *sti, int c, int y, int x)\r\n{\r\nstruct sti_font_inptr inptr = {\r\n.font_start_addr= STI_PTR(sti->font->raw),\r\n.index = c_index(sti, c),\r\n.fg_color = c_fg(sti, c),\r\n.bg_color = c_bg(sti, c),\r\n.dest_x = x * sti->font_width,\r\n.dest_y = y * sti->font_height,\r\n};\r\nstruct sti_font_outptr outptr = { 0, };\r\ns32 ret;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&sti->lock, flags);\r\nret = STI_CALL(sti->font_unpmv, &default_font_flags,\r\n&inptr, &outptr, sti->glob_cfg);\r\nspin_unlock_irqrestore(&sti->lock, flags);\r\n} while (ret == 1);\r\n}\r\nvoid\r\nsti_set(struct sti_struct *sti, int src_y, int src_x,\r\nint height, int width, u8 color)\r\n{\r\nstruct sti_blkmv_inptr inptr = {\r\n.fg_color = color,\r\n.bg_color = color,\r\n.src_x = src_x,\r\n.src_y = src_y,\r\n.dest_x = src_x,\r\n.dest_y = src_y,\r\n.width = width,\r\n.height = height,\r\n};\r\nstruct sti_blkmv_outptr outptr = { 0, };\r\ns32 ret;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&sti->lock, flags);\r\nret = STI_CALL(sti->block_move, &clear_blkmv_flags,\r\n&inptr, &outptr, sti->glob_cfg);\r\nspin_unlock_irqrestore(&sti->lock, flags);\r\n} while (ret == 1);\r\n}\r\nvoid\r\nsti_clear(struct sti_struct *sti, int src_y, int src_x,\r\nint height, int width, int c)\r\n{\r\nstruct sti_blkmv_inptr inptr = {\r\n.fg_color = c_fg(sti, c),\r\n.bg_color = c_bg(sti, c),\r\n.src_x = src_x * sti->font_width,\r\n.src_y = src_y * sti->font_height,\r\n.dest_x = src_x * sti->font_width,\r\n.dest_y = src_y * sti->font_height,\r\n.width = width * sti->font_width,\r\n.height = height* sti->font_height,\r\n};\r\nstruct sti_blkmv_outptr outptr = { 0, };\r\ns32 ret;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&sti->lock, flags);\r\nret = STI_CALL(sti->block_move, &clear_blkmv_flags,\r\n&inptr, &outptr, sti->glob_cfg);\r\nspin_unlock_irqrestore(&sti->lock, flags);\r\n} while (ret == 1);\r\n}\r\nvoid\r\nsti_bmove(struct sti_struct *sti, int src_y, int src_x,\r\nint dst_y, int dst_x, int height, int width)\r\n{\r\nstruct sti_blkmv_inptr inptr = {\r\n.src_x = src_x * sti->font_width,\r\n.src_y = src_y * sti->font_height,\r\n.dest_x = dst_x * sti->font_width,\r\n.dest_y = dst_y * sti->font_height,\r\n.width = width * sti->font_width,\r\n.height = height* sti->font_height,\r\n};\r\nstruct sti_blkmv_outptr outptr = { 0, };\r\ns32 ret;\r\nunsigned long flags;\r\ndo {\r\nspin_lock_irqsave(&sti->lock, flags);\r\nret = STI_CALL(sti->block_move, &default_blkmv_flags,\r\n&inptr, &outptr, sti->glob_cfg);\r\nspin_unlock_irqrestore(&sti->lock, flags);\r\n} while (ret == 1);\r\n}\r\nstatic void sti_flush(unsigned long start, unsigned long end)\r\n{\r\nflush_icache_range(start, end);\r\n}\r\nstatic void __devinit sti_rom_copy(unsigned long base, unsigned long count,\r\nvoid *dest)\r\n{\r\nunsigned long dest_start = (unsigned long) dest;\r\nwhile (count >= 4) {\r\ncount -= 4;\r\n*(u32 *)dest = gsc_readl(base);\r\nbase += 4;\r\ndest += 4;\r\n}\r\nwhile (count) {\r\ncount--;\r\n*(u8 *)dest = gsc_readb(base);\r\nbase++;\r\ndest++;\r\n}\r\nsti_flush(dest_start, (unsigned long)dest);\r\n}\r\nstatic int __devinit sti_setup(char *str)\r\n{\r\nif (str)\r\nstrlcpy (default_sti_path, str, sizeof (default_sti_path));\r\nreturn 1;\r\n}\r\nstatic int __devinit sti_font_setup(char *str)\r\n{\r\nchar *x;\r\nint i = 0;\r\nwhile (i<MAX_STI_ROMS && str && *str) {\r\nif (*str>='0' && *str<='9') {\r\nif ((x = strchr(str, 'x')) || (x = strchr(str, '*'))) {\r\nfont_height[i] = simple_strtoul(str, NULL, 0);\r\nfont_width[i] = simple_strtoul(x+1, NULL, 0);\r\n} else {\r\nfont_index[i] = simple_strtoul(str, NULL, 0);\r\n}\r\n} else {\r\nfont_name[i] = str;\r\n}\r\nif ((x = strchr(str, ',')))\r\n*x++ = 0;\r\nstr = x;\r\ni++;\r\n}\r\nreturn 1;\r\n}\r\nstatic void __devinit\r\nsti_dump_globcfg(struct sti_glob_cfg *glob_cfg, unsigned int sti_mem_request)\r\n{\r\nstruct sti_glob_cfg_ext *cfg;\r\nDPRINTK((KERN_INFO\r\n"%d text planes\n"\r\n"%4d x %4d screen resolution\n"\r\n"%4d x %4d offscreen\n"\r\n"%4d x %4d layout\n"\r\n"regions at %08x %08x %08x %08x\n"\r\n"regions at %08x %08x %08x %08x\n"\r\n"reent_lvl %d\n"\r\n"save_addr %08x\n",\r\nglob_cfg->text_planes,\r\nglob_cfg->onscreen_x, glob_cfg->onscreen_y,\r\nglob_cfg->offscreen_x, glob_cfg->offscreen_y,\r\nglob_cfg->total_x, glob_cfg->total_y,\r\nglob_cfg->region_ptrs[0], glob_cfg->region_ptrs[1],\r\nglob_cfg->region_ptrs[2], glob_cfg->region_ptrs[3],\r\nglob_cfg->region_ptrs[4], glob_cfg->region_ptrs[5],\r\nglob_cfg->region_ptrs[6], glob_cfg->region_ptrs[7],\r\nglob_cfg->reent_lvl,\r\nglob_cfg->save_addr));\r\ncfg = PTR_STI((unsigned long)glob_cfg->ext_ptr);\r\nDPRINTK(( KERN_INFO\r\n"monitor %d\n"\r\n"in friendly mode: %d\n"\r\n"power consumption %d watts\n"\r\n"freq ref %d\n"\r\n"sti_mem_addr %08x (size=%d bytes)\n",\r\ncfg->curr_mon,\r\ncfg->friendly_boot,\r\ncfg->power,\r\ncfg->freq_ref,\r\ncfg->sti_mem_addr, sti_mem_request));\r\n}\r\nstatic void __devinit\r\nsti_dump_outptr(struct sti_struct *sti)\r\n{\r\nDPRINTK((KERN_INFO\r\n"%d bits per pixel\n"\r\n"%d used bits\n"\r\n"%d planes\n"\r\n"attributes %08x\n",\r\nsti->outptr.bits_per_pixel,\r\nsti->outptr.bits_used,\r\nsti->outptr.planes,\r\nsti->outptr.attributes));\r\n}\r\nstatic int __devinit\r\nsti_init_glob_cfg(struct sti_struct *sti,\r\nunsigned long rom_address, unsigned long hpa)\r\n{\r\nstruct sti_glob_cfg *glob_cfg;\r\nstruct sti_glob_cfg_ext *glob_cfg_ext;\r\nvoid *save_addr;\r\nvoid *sti_mem_addr;\r\nconst int save_addr_size = 1024;\r\nint i;\r\nif (!sti->sti_mem_request)\r\nsti->sti_mem_request = 256;\r\nglob_cfg = kzalloc(sizeof(*sti->glob_cfg), GFP_KERNEL);\r\nglob_cfg_ext = kzalloc(sizeof(*glob_cfg_ext), GFP_KERNEL);\r\nsave_addr = kzalloc(save_addr_size, GFP_KERNEL);\r\nsti_mem_addr = kzalloc(sti->sti_mem_request, GFP_KERNEL);\r\nif (!(glob_cfg && glob_cfg_ext && save_addr && sti_mem_addr)) {\r\nkfree(glob_cfg);\r\nkfree(glob_cfg_ext);\r\nkfree(save_addr);\r\nkfree(sti_mem_addr);\r\nreturn -ENOMEM;\r\n}\r\nglob_cfg->ext_ptr = STI_PTR(glob_cfg_ext);\r\nglob_cfg->save_addr = STI_PTR(save_addr);\r\nfor (i=0; i<8; i++) {\r\nunsigned long newhpa, len;\r\nif (sti->pd) {\r\nunsigned char offs = sti->rm_entry[i];\r\nif (offs == 0)\r\ncontinue;\r\nif (offs != PCI_ROM_ADDRESS &&\r\n(offs < PCI_BASE_ADDRESS_0 ||\r\noffs > PCI_BASE_ADDRESS_5)) {\r\nprintk (KERN_WARNING\r\n"STI pci region mapping for region %d (%02x) can't be mapped\n",\r\ni,sti->rm_entry[i]);\r\ncontinue;\r\n}\r\nnewhpa = pci_resource_start (sti->pd, (offs - PCI_BASE_ADDRESS_0) / 4);\r\n} else\r\nnewhpa = (i == 0) ? rom_address : hpa;\r\nsti->regions_phys[i] =\r\nREGION_OFFSET_TO_PHYS(sti->regions[i], newhpa);\r\nlen = sti->regions[i].region_desc.length * 4096;\r\nif (len)\r\nglob_cfg->region_ptrs[i] = sti->regions_phys[i];\r\nDPRINTK(("region #%d: phys %08lx, region_ptr %08x, len=%lukB, "\r\n"btlb=%d, sysonly=%d, cache=%d, last=%d\n",\r\ni, sti->regions_phys[i], glob_cfg->region_ptrs[i],\r\nlen/1024,\r\nsti->regions[i].region_desc.btlb,\r\nsti->regions[i].region_desc.sys_only,\r\nsti->regions[i].region_desc.cache,\r\nsti->regions[i].region_desc.last));\r\nif (sti->regions[i].region_desc.last)\r\nbreak;\r\n}\r\nif (++i<8 && sti->regions[i].region)\r\nprintk(KERN_WARNING "%s: *future ptr (0x%8x) not yet supported !\n",\r\n__FILE__, sti->regions[i].region);\r\nglob_cfg_ext->sti_mem_addr = STI_PTR(sti_mem_addr);\r\nsti->glob_cfg = glob_cfg;\r\nreturn 0;\r\n}\r\nstatic struct sti_cooked_font __devinit\r\n*sti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)\r\n{\r\nconst struct font_desc *fbfont;\r\nunsigned int size, bpc;\r\nvoid *dest;\r\nstruct sti_rom_font *nf;\r\nstruct sti_cooked_font *cooked_font;\r\nif (!fbfont_name || !strlen(fbfont_name))\r\nreturn NULL;\r\nfbfont = find_font(fbfont_name);\r\nif (!fbfont)\r\nfbfont = get_default_font(1024,768, ~(u32)0, ~(u32)0);\r\nif (!fbfont)\r\nreturn NULL;\r\nDPRINTK((KERN_DEBUG "selected %dx%d fb-font %s\n",\r\nfbfont->width, fbfont->height, fbfont->name));\r\nbpc = ((fbfont->width+7)/8) * fbfont->height;\r\nsize = bpc * 256;\r\nsize += sizeof(struct sti_rom_font);\r\nnf = kzalloc(size, GFP_KERNEL);\r\nif (!nf)\r\nreturn NULL;\r\nnf->first_char = 0;\r\nnf->last_char = 255;\r\nnf->width = fbfont->width;\r\nnf->height = fbfont->height;\r\nnf->font_type = STI_FONT_HPROMAN8;\r\nnf->bytes_per_char = bpc;\r\nnf->next_font = 0;\r\nnf->underline_height = 1;\r\nnf->underline_pos = fbfont->height - nf->underline_height;\r\ndest = nf;\r\ndest += sizeof(struct sti_rom_font);\r\nmemcpy(dest, fbfont->data, bpc*256);\r\ncooked_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\r\nif (!cooked_font) {\r\nkfree(nf);\r\nreturn NULL;\r\n}\r\ncooked_font->raw = nf;\r\ncooked_font->next_font = NULL;\r\ncooked_rom->font_start = cooked_font;\r\nreturn cooked_font;\r\n}\r\nstatic struct sti_cooked_font __devinit\r\n*sti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)\r\n{\r\nreturn NULL;\r\n}\r\nstatic struct sti_cooked_font __devinit\r\n*sti_select_font(struct sti_cooked_rom *rom,\r\nint (*search_font_fnc)(struct sti_cooked_rom *, int, int))\r\n{\r\nstruct sti_cooked_font *font;\r\nint i;\r\nint index = num_sti_roms;\r\nif ((font = sti_select_fbfont(rom, font_name[index])))\r\nreturn font;\r\nif (font_width[index] && font_height[index])\r\nfont_index[index] = search_font_fnc(rom,\r\nfont_height[index], font_width[index]);\r\nfor (font = rom->font_start, i = font_index[index];\r\nfont && (i > 0);\r\nfont = font->next_font, i--);\r\nif (font)\r\nreturn font;\r\nelse\r\nreturn rom->font_start;\r\n}\r\nstatic void __devinit\r\nsti_dump_rom(struct sti_rom *rom)\r\n{\r\nprintk(KERN_INFO " id %04x-%04x, conforms to spec rev. %d.%02x\n",\r\nrom->graphics_id[0],\r\nrom->graphics_id[1],\r\nrom->revno[0] >> 4,\r\nrom->revno[0] & 0x0f);\r\nDPRINTK((" supports %d monitors\n", rom->num_mons));\r\nDPRINTK((" font start %08x\n", rom->font_start));\r\nDPRINTK((" region list %08x\n", rom->region_list));\r\nDPRINTK((" init_graph %08x\n", rom->init_graph));\r\nDPRINTK((" bus support %02x\n", rom->bus_support));\r\nDPRINTK((" ext bus support %02x\n", rom->ext_bus_support));\r\nDPRINTK((" alternate code type %d\n", rom->alt_code_type));\r\n}\r\nstatic int __devinit\r\nsti_cook_fonts(struct sti_cooked_rom *cooked_rom,\r\nstruct sti_rom *raw_rom)\r\n{\r\nstruct sti_rom_font *raw_font, *font_start;\r\nstruct sti_cooked_font *cooked_font;\r\ncooked_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\r\nif (!cooked_font)\r\nreturn 0;\r\ncooked_rom->font_start = cooked_font;\r\nraw_font = ((void *)raw_rom) + (raw_rom->font_start);\r\nfont_start = raw_font;\r\ncooked_font->raw = raw_font;\r\nwhile (raw_font->next_font) {\r\nraw_font = ((void *)font_start) + (raw_font->next_font);\r\ncooked_font->next_font = kzalloc(sizeof(*cooked_font), GFP_KERNEL);\r\nif (!cooked_font->next_font)\r\nreturn 1;\r\ncooked_font = cooked_font->next_font;\r\ncooked_font->raw = raw_font;\r\n}\r\ncooked_font->next_font = NULL;\r\nreturn 1;\r\n}\r\nstatic int __devinit\r\nsti_search_font(struct sti_cooked_rom *rom, int height, int width)\r\n{\r\nstruct sti_cooked_font *font;\r\nint i = 0;\r\nfor (font = rom->font_start; font; font = font->next_font, i++) {\r\nif ((font->raw->width == width) &&\r\n(font->raw->height == height))\r\nreturn i;\r\n}\r\nreturn 0;\r\n}\r\nstatic void * __devinit\r\nsti_bmode_font_raw(struct sti_cooked_font *f)\r\n{\r\nunsigned char *n, *p, *q;\r\nint size = f->raw->bytes_per_char*256+sizeof(struct sti_rom_font);\r\nn = kzalloc (4*size, GFP_KERNEL);\r\nif (!n)\r\nreturn NULL;\r\np = n + 3;\r\nq = (unsigned char *)f->raw;\r\nwhile (size--) {\r\n*p = *q++;\r\np+=4;\r\n}\r\nreturn n + 3;\r\n}\r\nstatic void __devinit\r\nsti_bmode_rom_copy(unsigned long base, unsigned long count, void *dest)\r\n{\r\nunsigned long dest_start = (unsigned long) dest;\r\nwhile (count) {\r\ncount--;\r\n*(u8 *)dest = gsc_readl(base);\r\nbase += 4;\r\ndest++;\r\n}\r\nsti_flush(dest_start, (unsigned long)dest);\r\n}\r\nstatic struct sti_rom * __devinit\r\nsti_get_bmode_rom (unsigned long address)\r\n{\r\nstruct sti_rom *raw;\r\nu32 size;\r\nstruct sti_rom_font *raw_font, *font_start;\r\nsti_bmode_rom_copy(address + BMODE_LAST_ADDR_OFFS, sizeof(size), &size);\r\nsize = (size+3) / 4;\r\nraw = kmalloc(size, GFP_KERNEL);\r\nif (raw) {\r\nsti_bmode_rom_copy(address, size, raw);\r\nmemmove (&raw->res004, &raw->type[0], 0x3c);\r\nraw->type[3] = raw->res004;\r\nBMODE_RELOCATE (raw->region_list);\r\nBMODE_RELOCATE (raw->font_start);\r\nBMODE_RELOCATE (raw->init_graph);\r\nBMODE_RELOCATE (raw->state_mgmt);\r\nBMODE_RELOCATE (raw->font_unpmv);\r\nBMODE_RELOCATE (raw->block_move);\r\nBMODE_RELOCATE (raw->inq_conf);\r\nraw_font = ((void *)raw) + raw->font_start;\r\nfont_start = raw_font;\r\nwhile (raw_font->next_font) {\r\nBMODE_RELOCATE (raw_font->next_font);\r\nraw_font = ((void *)font_start) + raw_font->next_font;\r\n}\r\n}\r\nreturn raw;\r\n}\r\nstatic struct sti_rom __devinit *sti_get_wmode_rom(unsigned long address)\r\n{\r\nstruct sti_rom *raw;\r\nunsigned long size;\r\nsize = gsc_readl(address + offsetof(struct sti_rom,last_addr));\r\nraw = kmalloc(size, GFP_KERNEL);\r\nif (raw)\r\nsti_rom_copy(address, size, raw);\r\nreturn raw;\r\n}\r\nstatic int __devinit sti_read_rom(int wordmode, struct sti_struct *sti,\r\nunsigned long address)\r\n{\r\nstruct sti_cooked_rom *cooked;\r\nstruct sti_rom *raw = NULL;\r\nunsigned long revno;\r\ncooked = kmalloc(sizeof *cooked, GFP_KERNEL);\r\nif (!cooked)\r\ngoto out_err;\r\nif (wordmode)\r\nraw = sti_get_wmode_rom (address);\r\nelse\r\nraw = sti_get_bmode_rom (address);\r\nif (!raw)\r\ngoto out_err;\r\nif (!sti_cook_fonts(cooked, raw)) {\r\nprintk(KERN_ERR "No font found for STI at %08lx\n", address);\r\ngoto out_err;\r\n}\r\nif (raw->region_list)\r\nmemcpy(sti->regions, ((void *)raw)+raw->region_list, sizeof(sti->regions));\r\naddress = (unsigned long) STI_PTR(raw);\r\nsti->font_unpmv = address + (raw->font_unpmv & 0x03ffffff);\r\nsti->block_move = address + (raw->block_move & 0x03ffffff);\r\nsti->init_graph = address + (raw->init_graph & 0x03ffffff);\r\nsti->inq_conf = address + (raw->inq_conf & 0x03ffffff);\r\nsti->rom = cooked;\r\nsti->rom->raw = raw;\r\nsti->font = sti_select_font(sti->rom, sti_search_font);\r\nsti->font_width = sti->font->raw->width;\r\nsti->font_height = sti->font->raw->height;\r\nif (!wordmode)\r\nsti->font->raw = sti_bmode_font_raw(sti->font);\r\nsti->sti_mem_request = raw->sti_mem_req;\r\nsti->graphics_id[0] = raw->graphics_id[0];\r\nsti->graphics_id[1] = raw->graphics_id[1];\r\nsti_dump_rom(raw);\r\nif (wordmode || sti->graphics_id[1] != 0x09A02587)\r\ngoto ok;\r\nrevno = (raw->revno[0] << 8) | raw->revno[1];\r\nswitch (sti->graphics_id[0]) {\r\ncase S9000_ID_HCRX:\r\nif (revno == 0x8408 || revno == 0x840b)\r\ngoto msg_not_supported;\r\nbreak;\r\ncase CRT_ID_THUNDER:\r\nif (revno == 0x8509)\r\ngoto msg_not_supported;\r\nbreak;\r\ncase CRT_ID_THUNDER2:\r\nif (revno == 0x850c)\r\ngoto msg_not_supported;\r\n}\r\nok:\r\nreturn 1;\r\nmsg_not_supported:\r\nprintk(KERN_ERR "Sorry, this GSC/STI card is not yet supported.\n");\r\nprintk(KERN_ERR "Please see http://parisc-linux.org/faq/"\r\n"graphics-howto.html for more info.\n");\r\nout_err:\r\nkfree(raw);\r\nkfree(cooked);\r\nreturn 0;\r\n}\r\nstatic struct sti_struct * __devinit\r\nsti_try_rom_generic(unsigned long address, unsigned long hpa, struct pci_dev *pd)\r\n{\r\nstruct sti_struct *sti;\r\nint ok;\r\nu32 sig;\r\nif (num_sti_roms >= MAX_STI_ROMS) {\r\nprintk(KERN_WARNING "maximum number of STI ROMS reached !\n");\r\nreturn NULL;\r\n}\r\nsti = kzalloc(sizeof(*sti), GFP_KERNEL);\r\nif (!sti) {\r\nprintk(KERN_ERR "Not enough memory !\n");\r\nreturn NULL;\r\n}\r\nspin_lock_init(&sti->lock);\r\ntest_rom:\r\nif (pdc_add_valid(address))\r\ngoto out_err;\r\nsig = gsc_readl(address);\r\nif ((le32_to_cpu(sig)==0xaa55)) {\r\nunsigned int i, rm_offset;\r\nu32 *rm;\r\ni = gsc_readl(address+0x04);\r\nif (i != 1) {\r\nprintk(KERN_WARNING\r\n"PCI ROM is not a STI ROM type image (0x%8x)\n", i);\r\ngoto out_err;\r\n}\r\nsti->pd = pd;\r\ni = gsc_readl(address+0x0c);\r\nDPRINTK(("PCI ROM size (from header) = %d kB\n",\r\nle16_to_cpu(i>>16)*512/1024));\r\nrm_offset = le16_to_cpu(i & 0xffff);\r\nif (rm_offset) {\r\nrm = (u32*) &sti->rm_entry;\r\n*rm++ = gsc_readl(address+rm_offset+0x00);\r\n*rm++ = gsc_readl(address+rm_offset+0x04);\r\n*rm++ = gsc_readl(address+rm_offset+0x08);\r\n*rm++ = gsc_readl(address+rm_offset+0x0c);\r\nDPRINTK(("PCI region Mapper offset = %08x: ",\r\nrm_offset));\r\nfor (i=0; i<16; i++)\r\nDPRINTK(("%02x ", sti->rm_entry[i]));\r\nDPRINTK(("\n"));\r\n}\r\naddress += le32_to_cpu(gsc_readl(address+8));\r\nDPRINTK(("sig %04x, PCI STI ROM at %08lx\n", sig, address));\r\ngoto test_rom;\r\n}\r\nok = 0;\r\nif ((sig & 0xff) == 0x01) {\r\nDPRINTK((" byte mode ROM at %08lx, hpa at %08lx\n",\r\naddress, hpa));\r\nok = sti_read_rom(0, sti, address);\r\n}\r\nif ((sig & 0xffff) == 0x0303) {\r\nDPRINTK((" word mode ROM at %08lx, hpa at %08lx\n",\r\naddress, hpa));\r\nok = sti_read_rom(1, sti, address);\r\n}\r\nif (!ok)\r\ngoto out_err;\r\nif (sti_init_glob_cfg(sti, address, hpa))\r\ngoto out_err;\r\nif (sti->pd) {\r\nunsigned long rom_base;\r\nrom_base = pci_resource_start(sti->pd, PCI_ROM_RESOURCE);\r\npci_write_config_dword(sti->pd, PCI_ROM_ADDRESS, rom_base & ~PCI_ROM_ADDRESS_ENABLE);\r\nDPRINTK((KERN_DEBUG "STI PCI ROM disabled\n"));\r\n}\r\nif (sti_init_graph(sti))\r\ngoto out_err;\r\nsti_inq_conf(sti);\r\nsti_dump_globcfg(sti->glob_cfg, sti->sti_mem_request);\r\nsti_dump_outptr(sti);\r\nprintk(KERN_INFO " graphics card name: %s\n", sti->outptr.dev_name );\r\nsti_roms[num_sti_roms] = sti;\r\nnum_sti_roms++;\r\nreturn sti;\r\nout_err:\r\nkfree(sti);\r\nreturn NULL;\r\n}\r\nstatic void __devinit sticore_check_for_default_sti(struct sti_struct *sti, char *path)\r\n{\r\nif (strcmp (path, default_sti_path) == 0)\r\ndefault_sti = sti;\r\n}\r\nstatic int __devinit sticore_pa_init(struct parisc_device *dev)\r\n{\r\nchar pa_path[21];\r\nstruct sti_struct *sti = NULL;\r\nint hpa = dev->hpa.start;\r\nif (dev->num_addrs && dev->addr[0])\r\nsti = sti_try_rom_generic(dev->addr[0], hpa, NULL);\r\nif (!sti)\r\nsti = sti_try_rom_generic(hpa, hpa, NULL);\r\nif (!sti)\r\nsti = sti_try_rom_generic(PAGE0->proc_sti, hpa, NULL);\r\nif (!sti)\r\nreturn 1;\r\nprint_pa_hwpath(dev, pa_path);\r\nsticore_check_for_default_sti(sti, pa_path);\r\nreturn 0;\r\n}\r\nstatic int __devinit sticore_pci_init(struct pci_dev *pd,\r\nconst struct pci_device_id *ent)\r\n{\r\n#ifdef CONFIG_PCI\r\nunsigned long fb_base, rom_base;\r\nunsigned int fb_len, rom_len;\r\nint err;\r\nstruct sti_struct *sti;\r\nerr = pci_enable_device(pd);\r\nif (err < 0) {\r\ndev_err(&pd->dev, "Cannot enable PCI device\n");\r\nreturn err;\r\n}\r\nfb_base = pci_resource_start(pd, 0);\r\nfb_len = pci_resource_len(pd, 0);\r\nrom_base = pci_resource_start(pd, PCI_ROM_RESOURCE);\r\nrom_len = pci_resource_len(pd, PCI_ROM_RESOURCE);\r\nif (rom_base) {\r\npci_write_config_dword(pd, PCI_ROM_ADDRESS, rom_base | PCI_ROM_ADDRESS_ENABLE);\r\nDPRINTK((KERN_DEBUG "STI PCI ROM enabled at 0x%08lx\n", rom_base));\r\n}\r\nprintk(KERN_INFO "STI PCI graphic ROM found at %08lx (%u kB), fb at %08lx (%u MB)\n",\r\nrom_base, rom_len/1024, fb_base, fb_len/1024/1024);\r\nDPRINTK((KERN_DEBUG "Trying PCI STI ROM at %08lx, PCI hpa at %08lx\n",\r\nrom_base, fb_base));\r\nsti = sti_try_rom_generic(rom_base, fb_base, pd);\r\nif (sti) {\r\nchar pa_path[30];\r\nprint_pci_hwpath(pd, pa_path);\r\nsticore_check_for_default_sti(sti, pa_path);\r\n}\r\nif (!sti) {\r\nprintk(KERN_WARNING "Unable to handle STI device '%s'\n",\r\npci_name(pd));\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __devexit sticore_pci_remove(struct pci_dev *pd)\r\n{\r\nBUG();\r\n}\r\nstatic void __devinit sti_init_roms(void)\r\n{\r\nif (sticore_initialized)\r\nreturn;\r\nsticore_initialized = 1;\r\nprintk(KERN_INFO "STI GSC/PCI core graphics driver "\r\nSTI_DRIVERVERSION "\n");\r\nregister_parisc_driver(&pa_sti_driver);\r\nWARN_ON(pci_register_driver(&pci_sti_driver));\r\nif (!default_sti)\r\ndefault_sti = sti_roms[0];\r\n}\r\nstruct sti_struct * sti_get_rom(unsigned int index)\r\n{\r\nif (!sticore_initialized)\r\nsti_init_roms();\r\nif (index == 0)\r\nreturn default_sti;\r\nif (index > num_sti_roms)\r\nreturn NULL;\r\nreturn sti_roms[index-1];\r\n}
