int __xipram cfi_qry_present(struct map_info *map, __u32 base,\r\nstruct cfi_private *cfi)\r\n{\r\nint osf = cfi->interleave * cfi->device_type;\r\nmap_word val[3];\r\nmap_word qry[3];\r\nqry[0] = cfi_build_cmd('Q', map, cfi);\r\nqry[1] = cfi_build_cmd('R', map, cfi);\r\nqry[2] = cfi_build_cmd('Y', map, cfi);\r\nval[0] = map_read(map, base + osf*0x10);\r\nval[1] = map_read(map, base + osf*0x11);\r\nval[2] = map_read(map, base + osf*0x12);\r\nif (!map_word_equal(map, qry[0], val[0]))\r\nreturn 0;\r\nif (!map_word_equal(map, qry[1], val[1]))\r\nreturn 0;\r\nif (!map_word_equal(map, qry[2], val[2]))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint __xipram cfi_qry_mode_on(uint32_t base, struct map_info *map,\r\nstruct cfi_private *cfi)\r\n{\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x5555, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xAA, 0x555, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x55, 0x2AA, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);\r\nif (cfi_qry_present(map, base, cfi))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid __xipram cfi_qry_mode_off(uint32_t base, struct map_info *map,\r\nstruct cfi_private *cfi)\r\n{\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\ncfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\r\nif ((cfi->mfr == CFI_MFR_ST) && (cfi->id == 0x227E || cfi->id == 0x7E))\r\ncfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\r\n}\r\nstruct cfi_extquery *\r\n__xipram cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* name)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\n__u32 base = 0;\r\nint ofs_factor = cfi->interleave * cfi->device_type;\r\nint i;\r\nstruct cfi_extquery *extp = NULL;\r\nif (!adr)\r\ngoto out;\r\nprintk(KERN_INFO "%s Extended Query Table at 0x%4.4X\n", name, adr);\r\nextp = kmalloc(size, GFP_KERNEL);\r\nif (!extp) {\r\nprintk(KERN_ERR "Failed to allocate memory\n");\r\ngoto out;\r\n}\r\n#ifdef CONFIG_MTD_XIP\r\nlocal_irq_disable();\r\n#endif\r\ncfi_qry_mode_on(base, map, cfi);\r\nfor (i=0; i<size; i++) {\r\n((unsigned char *)extp)[i] =\r\ncfi_read_query(map, base+((adr+i)*ofs_factor));\r\n}\r\ncfi_qry_mode_off(base, map, cfi);\r\n#ifdef CONFIG_MTD_XIP\r\n(void) map_read(map, base);\r\nxip_iprefetch();\r\nlocal_irq_enable();\r\n#endif\r\nout: return extp;\r\n}\r\nvoid cfi_fixup(struct mtd_info *mtd, struct cfi_fixup *fixups)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nstruct cfi_fixup *f;\r\nfor (f=fixups; f->fixup; f++) {\r\nif (((f->mfr == CFI_MFR_ANY) || (f->mfr == cfi->mfr)) &&\r\n((f->id == CFI_ID_ANY) || (f->id == cfi->id))) {\r\nf->fixup(mtd);\r\n}\r\n}\r\n}\r\nint cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,\r\nloff_t ofs, size_t len, void *thunk)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\nunsigned long adr;\r\nint chipnum, ret = 0;\r\nint i, first;\r\nstruct mtd_erase_region_info *regions = mtd->eraseregions;\r\ni = 0;\r\nwhile (i < mtd->numeraseregions && ofs >= regions[i].offset)\r\ni++;\r\ni--;\r\nif (ofs & (regions[i].erasesize-1))\r\nreturn -EINVAL;\r\nfirst = i;\r\nwhile (i<mtd->numeraseregions && (ofs + len) >= regions[i].offset)\r\ni++;\r\ni--;\r\nif ((ofs + len) & (regions[i].erasesize-1))\r\nreturn -EINVAL;\r\nchipnum = ofs >> cfi->chipshift;\r\nadr = ofs - (chipnum << cfi->chipshift);\r\ni=first;\r\nwhile(len) {\r\nint size = regions[i].erasesize;\r\nret = (*frob)(map, &cfi->chips[chipnum], adr, size, thunk);\r\nif (ret)\r\nreturn ret;\r\nadr += size;\r\nofs += size;\r\nlen -= size;\r\nif (ofs == regions[i].offset + size * regions[i].numblocks)\r\ni++;\r\nif (adr >> cfi->chipshift) {\r\nadr = 0;\r\nchipnum++;\r\nif (chipnum >= cfi->numchips)\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
