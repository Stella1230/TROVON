static ssize_t atk_input_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct atk_sensor_data *s = input_to_atk_sensor(attr);\r\nu64 value;\r\nint err;\r\nerr = atk_read_value(s, &value);\r\nif (err)\r\nreturn err;\r\nif (s->type == HWMON_TYPE_TEMP)\r\nvalue *= 100;\r\nreturn sprintf(buf, "%llu\n", value);\r\n}\r\nstatic ssize_t atk_label_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct atk_sensor_data *s = label_to_atk_sensor(attr);\r\nreturn sprintf(buf, "%s\n", s->acpi_name);\r\n}\r\nstatic ssize_t atk_limit1_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct atk_sensor_data *s = limit1_to_atk_sensor(attr);\r\nu64 value = s->limit1;\r\nif (s->type == HWMON_TYPE_TEMP)\r\nvalue *= 100;\r\nreturn sprintf(buf, "%lld\n", value);\r\n}\r\nstatic ssize_t atk_limit2_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct atk_sensor_data *s = limit2_to_atk_sensor(attr);\r\nu64 value = s->limit2;\r\nif (s->type == HWMON_TYPE_TEMP)\r\nvalue *= 100;\r\nreturn sprintf(buf, "%lld\n", value);\r\n}\r\nstatic ssize_t atk_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "atk0110\n");\r\n}\r\nstatic void atk_init_attribute(struct device_attribute *attr, char *name,\r\nsysfs_show_func show)\r\n{\r\nsysfs_attr_init(&attr->attr);\r\nattr->attr.name = name;\r\nattr->attr.mode = 0444;\r\nattr->show = show;\r\nattr->store = NULL;\r\n}\r\nstatic union acpi_object *atk_get_pack_member(struct atk_data *data,\r\nunion acpi_object *pack,\r\nenum atk_pack_member m)\r\n{\r\nbool old_if = data->old_interface;\r\nint offset;\r\nswitch (m) {\r\ncase HWMON_PACK_FLAGS:\r\noffset = old_if ? _HWMON_OLD_PACK_FLAGS : _HWMON_NEW_PACK_FLAGS;\r\nbreak;\r\ncase HWMON_PACK_NAME:\r\noffset = old_if ? _HWMON_OLD_PACK_NAME : _HWMON_NEW_PACK_NAME;\r\nbreak;\r\ncase HWMON_PACK_LIMIT1:\r\noffset = old_if ? _HWMON_OLD_PACK_LIMIT1 :\r\n_HWMON_NEW_PACK_LIMIT1;\r\nbreak;\r\ncase HWMON_PACK_LIMIT2:\r\noffset = old_if ? _HWMON_OLD_PACK_LIMIT2 :\r\n_HWMON_NEW_PACK_LIMIT2;\r\nbreak;\r\ncase HWMON_PACK_ENABLE:\r\noffset = old_if ? _HWMON_OLD_PACK_ENABLE :\r\n_HWMON_NEW_PACK_ENABLE;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nreturn &pack->package.elements[offset];\r\n}\r\nstatic int validate_hwmon_pack(struct atk_data *data, union acpi_object *obj)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *tmp;\r\nbool old_if = data->old_interface;\r\nint const expected_size = old_if ? _HWMON_OLD_PACK_SIZE :\r\n_HWMON_NEW_PACK_SIZE;\r\nif (obj->type != ACPI_TYPE_PACKAGE) {\r\ndev_warn(dev, "Invalid type: %d\n", obj->type);\r\nreturn -EINVAL;\r\n}\r\nif (obj->package.count != expected_size) {\r\ndev_warn(dev, "Invalid package size: %d, expected: %d\n",\r\nobj->package.count, expected_size);\r\nreturn -EINVAL;\r\n}\r\ntmp = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS);\r\nif (tmp->type != ACPI_TYPE_INTEGER) {\r\ndev_warn(dev, "Invalid type (flag): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\ntmp = atk_get_pack_member(data, obj, HWMON_PACK_NAME);\r\nif (tmp->type != ACPI_TYPE_STRING) {\r\ndev_warn(dev, "Invalid type (name): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\n#if 0\r\ntmp = &obj->package.elements[HWMON_PACK_UNK1];\r\nif (tmp->type != ACPI_TYPE_INTEGER) {\r\ndev_warn(dev, "Invalid type (unk1): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\ntmp = &obj->package.elements[HWMON_PACK_UNK2];\r\nif (tmp->type != ACPI_TYPE_INTEGER) {\r\ndev_warn(dev, "Invalid type (unk2): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\n#endif\r\ntmp = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT1);\r\nif (tmp->type != ACPI_TYPE_INTEGER) {\r\ndev_warn(dev, "Invalid type (limit1): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\ntmp = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT2);\r\nif (tmp->type != ACPI_TYPE_INTEGER) {\r\ndev_warn(dev, "Invalid type (limit2): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\ntmp = atk_get_pack_member(data, obj, HWMON_PACK_ENABLE);\r\nif (tmp->type != ACPI_TYPE_INTEGER) {\r\ndev_warn(dev, "Invalid type (enable): %d\n", tmp->type);\r\nreturn -EINVAL;\r\n}\r\natk_print_sensor(data, obj);\r\nreturn 0;\r\n}\r\nstatic char const *atk_sensor_type(union acpi_object *flags)\r\n{\r\nu64 type = flags->integer.value & ATK_TYPE_MASK;\r\nchar const *what;\r\nswitch (type) {\r\ncase HWMON_TYPE_VOLT:\r\nwhat = "voltage";\r\nbreak;\r\ncase HWMON_TYPE_TEMP:\r\nwhat = "temperature";\r\nbreak;\r\ncase HWMON_TYPE_FAN:\r\nwhat = "fan";\r\nbreak;\r\ndefault:\r\nwhat = "unknown";\r\nbreak;\r\n}\r\nreturn what;\r\n}\r\nstatic void atk_print_sensor(struct atk_data *data, union acpi_object *obj)\r\n{\r\n#ifdef DEBUG\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *flags;\r\nunion acpi_object *name;\r\nunion acpi_object *limit1;\r\nunion acpi_object *limit2;\r\nunion acpi_object *enable;\r\nchar const *what;\r\nflags = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS);\r\nname = atk_get_pack_member(data, obj, HWMON_PACK_NAME);\r\nlimit1 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT1);\r\nlimit2 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT2);\r\nenable = atk_get_pack_member(data, obj, HWMON_PACK_ENABLE);\r\nwhat = atk_sensor_type(flags);\r\ndev_dbg(dev, "%s: %#llx %s [%llu-%llu] %s\n", what,\r\nflags->integer.value,\r\nname->string.pointer,\r\nlimit1->integer.value, limit2->integer.value,\r\nenable->integer.value ? "enabled" : "disabled");\r\n#endif\r\n}\r\nstatic int atk_read_value_old(struct atk_sensor_data *sensor, u64 *value)\r\n{\r\nstruct atk_data *data = sensor->data;\r\nstruct device *dev = &data->acpi_dev->dev;\r\nstruct acpi_object_list params;\r\nunion acpi_object id;\r\nacpi_status status;\r\nacpi_handle method;\r\nswitch (sensor->type) {\r\ncase HWMON_TYPE_VOLT:\r\nmethod = data->rvlt_handle;\r\nbreak;\r\ncase HWMON_TYPE_TEMP:\r\nmethod = data->rtmp_handle;\r\nbreak;\r\ncase HWMON_TYPE_FAN:\r\nmethod = data->rfan_handle;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nid.type = ACPI_TYPE_INTEGER;\r\nid.integer.value = sensor->id;\r\nparams.count = 1;\r\nparams.pointer = &id;\r\nstatus = acpi_evaluate_integer(method, NULL, &params, value);\r\nif (status != AE_OK) {\r\ndev_warn(dev, "%s: ACPI exception: %s\n", __func__,\r\nacpi_format_exception(status));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic union acpi_object *atk_ggrp(struct atk_data *data, u16 mux)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nstruct acpi_buffer buf;\r\nacpi_status ret;\r\nstruct acpi_object_list params;\r\nunion acpi_object id;\r\nunion acpi_object *pack;\r\nid.type = ACPI_TYPE_INTEGER;\r\nid.integer.value = mux;\r\nparams.count = 1;\r\nparams.pointer = &id;\r\nbuf.length = ACPI_ALLOCATE_BUFFER;\r\nret = acpi_evaluate_object(data->enumerate_handle, NULL, &params, &buf);\r\nif (ret != AE_OK) {\r\ndev_err(dev, "GGRP[%#x] ACPI exception: %s\n", mux,\r\nacpi_format_exception(ret));\r\nreturn ERR_PTR(-EIO);\r\n}\r\npack = buf.pointer;\r\nif (pack->type != ACPI_TYPE_PACKAGE) {\r\nACPI_FREE(pack);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nif (pack->package.count < 1) {\r\ndev_err(dev, "GGRP[%#x] package is too small\n", mux);\r\nACPI_FREE(pack);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn pack;\r\n}\r\nstatic union acpi_object *atk_gitm(struct atk_data *data, u64 id)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nstruct atk_acpi_input_buf buf;\r\nunion acpi_object tmp;\r\nstruct acpi_object_list params;\r\nstruct acpi_buffer ret;\r\nunion acpi_object *obj;\r\nacpi_status status;\r\nbuf.id = id;\r\nbuf.param1 = 0;\r\nbuf.param2 = 0;\r\ntmp.type = ACPI_TYPE_BUFFER;\r\ntmp.buffer.pointer = (u8 *)&buf;\r\ntmp.buffer.length = sizeof(buf);\r\nparams.count = 1;\r\nparams.pointer = (void *)&tmp;\r\nret.length = ACPI_ALLOCATE_BUFFER;\r\nstatus = acpi_evaluate_object_typed(data->read_handle, NULL, &params,\r\n&ret, ACPI_TYPE_BUFFER);\r\nif (status != AE_OK) {\r\ndev_warn(dev, "GITM[%#llx] ACPI exception: %s\n", id,\r\nacpi_format_exception(status));\r\nreturn ERR_PTR(-EIO);\r\n}\r\nobj = ret.pointer;\r\nif (obj->buffer.length < 8) {\r\ndev_warn(dev, "Unexpected ASBF length: %u\n",\r\nobj->buffer.length);\r\nACPI_FREE(obj);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn obj;\r\n}\r\nstatic union acpi_object *atk_sitm(struct atk_data *data,\r\nstruct atk_acpi_input_buf *buf)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nstruct acpi_object_list params;\r\nunion acpi_object tmp;\r\nstruct acpi_buffer ret;\r\nunion acpi_object *obj;\r\nacpi_status status;\r\ntmp.type = ACPI_TYPE_BUFFER;\r\ntmp.buffer.pointer = (u8 *)buf;\r\ntmp.buffer.length = sizeof(*buf);\r\nparams.count = 1;\r\nparams.pointer = &tmp;\r\nret.length = ACPI_ALLOCATE_BUFFER;\r\nstatus = acpi_evaluate_object_typed(data->write_handle, NULL, &params,\r\n&ret, ACPI_TYPE_BUFFER);\r\nif (status != AE_OK) {\r\ndev_warn(dev, "SITM[%#x] ACPI exception: %s\n", buf->id,\r\nacpi_format_exception(status));\r\nreturn ERR_PTR(-EIO);\r\n}\r\nobj = ret.pointer;\r\nif (obj->buffer.length < 8) {\r\ndev_warn(dev, "Unexpected ASBF length: %u\n",\r\nobj->buffer.length);\r\nACPI_FREE(obj);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nreturn obj;\r\n}\r\nstatic int atk_read_value_new(struct atk_sensor_data *sensor, u64 *value)\r\n{\r\nstruct atk_data *data = sensor->data;\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *obj;\r\nstruct atk_acpi_ret_buffer *buf;\r\nint err = 0;\r\nobj = atk_gitm(data, sensor->id);\r\nif (IS_ERR(obj))\r\nreturn PTR_ERR(obj);\r\nbuf = (struct atk_acpi_ret_buffer *)obj->buffer.pointer;\r\nif (buf->flags == 0) {\r\ndev_warn(dev, "Read failed, sensor = %#llx\n", sensor->id);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\n*value = buf->value;\r\nout:\r\nACPI_FREE(obj);\r\nreturn err;\r\n}\r\nstatic int atk_read_value(struct atk_sensor_data *sensor, u64 *value)\r\n{\r\nint err;\r\nif (!sensor->is_valid ||\r\ntime_after(jiffies, sensor->last_updated + CACHE_TIME)) {\r\nif (sensor->data->old_interface)\r\nerr = atk_read_value_old(sensor, value);\r\nelse\r\nerr = atk_read_value_new(sensor, value);\r\nsensor->is_valid = true;\r\nsensor->last_updated = jiffies;\r\nsensor->cached_value = *value;\r\n} else {\r\n*value = sensor->cached_value;\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int atk_debugfs_gitm_get(void *p, u64 *val)\r\n{\r\nstruct atk_data *data = p;\r\nunion acpi_object *ret;\r\nstruct atk_acpi_ret_buffer *buf;\r\nint err = 0;\r\nif (!data->read_handle)\r\nreturn -ENODEV;\r\nif (!data->debugfs.id)\r\nreturn -EINVAL;\r\nret = atk_gitm(data, data->debugfs.id);\r\nif (IS_ERR(ret))\r\nreturn PTR_ERR(ret);\r\nbuf = (struct atk_acpi_ret_buffer *)ret->buffer.pointer;\r\nif (buf->flags)\r\n*val = buf->value;\r\nelse\r\nerr = -EIO;\r\nACPI_FREE(ret);\r\nreturn err;\r\n}\r\nstatic int atk_acpi_print(char *buf, size_t sz, union acpi_object *obj)\r\n{\r\nint ret = 0;\r\nswitch (obj->type) {\r\ncase ACPI_TYPE_INTEGER:\r\nret = snprintf(buf, sz, "0x%08llx\n", obj->integer.value);\r\nbreak;\r\ncase ACPI_TYPE_STRING:\r\nret = snprintf(buf, sz, "%s\n", obj->string.pointer);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void atk_pack_print(char *buf, size_t sz, union acpi_object *pack)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < pack->package.count; i++) {\r\nunion acpi_object *obj = &pack->package.elements[i];\r\nret = atk_acpi_print(buf, sz, obj);\r\nif (ret >= sz)\r\nbreak;\r\nbuf += ret;\r\nsz -= ret;\r\n}\r\n}\r\nstatic int atk_debugfs_ggrp_open(struct inode *inode, struct file *file)\r\n{\r\nstruct atk_data *data = inode->i_private;\r\nchar *buf = NULL;\r\nunion acpi_object *ret;\r\nu8 cls;\r\nint i;\r\nif (!data->enumerate_handle)\r\nreturn -ENODEV;\r\nif (!data->debugfs.id)\r\nreturn -EINVAL;\r\ncls = (data->debugfs.id & 0xff000000) >> 24;\r\nret = atk_ggrp(data, cls);\r\nif (IS_ERR(ret))\r\nreturn PTR_ERR(ret);\r\nfor (i = 0; i < ret->package.count; i++) {\r\nunion acpi_object *pack = &ret->package.elements[i];\r\nunion acpi_object *id;\r\nif (pack->type != ACPI_TYPE_PACKAGE)\r\ncontinue;\r\nif (!pack->package.count)\r\ncontinue;\r\nid = &pack->package.elements[0];\r\nif (id->integer.value == data->debugfs.id) {\r\nbuf = kzalloc(512, GFP_KERNEL);\r\nif (!buf) {\r\nACPI_FREE(ret);\r\nreturn -ENOMEM;\r\n}\r\natk_pack_print(buf, 512, pack);\r\nbreak;\r\n}\r\n}\r\nACPI_FREE(ret);\r\nif (!buf)\r\nreturn -EINVAL;\r\nfile->private_data = buf;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t atk_debugfs_ggrp_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar *str = file->private_data;\r\nsize_t len = strlen(str);\r\nreturn simple_read_from_buffer(buf, count, pos, str, len);\r\n}\r\nstatic int atk_debugfs_ggrp_release(struct inode *inode, struct file *file)\r\n{\r\nkfree(file->private_data);\r\nreturn 0;\r\n}\r\nstatic void atk_debugfs_init(struct atk_data *data)\r\n{\r\nstruct dentry *d;\r\nstruct dentry *f;\r\ndata->debugfs.id = 0;\r\nd = debugfs_create_dir("asus_atk0110", NULL);\r\nif (!d || IS_ERR(d))\r\nreturn;\r\nf = debugfs_create_x32("id", S_IRUSR | S_IWUSR, d, &data->debugfs.id);\r\nif (!f || IS_ERR(f))\r\ngoto cleanup;\r\nf = debugfs_create_file("gitm", S_IRUSR, d, data,\r\n&atk_debugfs_gitm);\r\nif (!f || IS_ERR(f))\r\ngoto cleanup;\r\nf = debugfs_create_file("ggrp", S_IRUSR, d, data,\r\n&atk_debugfs_ggrp_fops);\r\nif (!f || IS_ERR(f))\r\ngoto cleanup;\r\ndata->debugfs.root = d;\r\nreturn;\r\ncleanup:\r\ndebugfs_remove_recursive(d);\r\n}\r\nstatic void atk_debugfs_cleanup(struct atk_data *data)\r\n{\r\ndebugfs_remove_recursive(data->debugfs.root);\r\n}\r\nstatic void atk_debugfs_init(struct atk_data *data)\r\n{\r\n}\r\nstatic void atk_debugfs_cleanup(struct atk_data *data)\r\n{\r\n}\r\nstatic int atk_add_sensor(struct atk_data *data, union acpi_object *obj)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *flags;\r\nunion acpi_object *name;\r\nunion acpi_object *limit1;\r\nunion acpi_object *limit2;\r\nunion acpi_object *enable;\r\nstruct atk_sensor_data *sensor;\r\nchar const *base_name;\r\nchar const *limit1_name;\r\nchar const *limit2_name;\r\nu64 type;\r\nint err;\r\nint *num;\r\nint start;\r\nif (obj->type != ACPI_TYPE_PACKAGE) {\r\ndev_warn(dev, "Unknown type for ACPI object: (%d)\n",\r\nobj->type);\r\nreturn -EINVAL;\r\n}\r\nerr = validate_hwmon_pack(data, obj);\r\nif (err)\r\nreturn err;\r\ntype = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS)->integer.value\r\n& ATK_TYPE_MASK;\r\nswitch (type) {\r\ncase HWMON_TYPE_VOLT:\r\nbase_name = "in";\r\nlimit1_name = "min";\r\nlimit2_name = "max";\r\nnum = &data->voltage_count;\r\nstart = 0;\r\nbreak;\r\ncase HWMON_TYPE_TEMP:\r\nbase_name = "temp";\r\nlimit1_name = "max";\r\nlimit2_name = "crit";\r\nnum = &data->temperature_count;\r\nstart = 1;\r\nbreak;\r\ncase HWMON_TYPE_FAN:\r\nbase_name = "fan";\r\nlimit1_name = "min";\r\nlimit2_name = "max";\r\nnum = &data->fan_count;\r\nstart = 1;\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "Unknown sensor type: %#llx\n", type);\r\nreturn -EINVAL;\r\n}\r\nenable = atk_get_pack_member(data, obj, HWMON_PACK_ENABLE);\r\nif (!enable->integer.value)\r\nreturn 0;\r\nflags = atk_get_pack_member(data, obj, HWMON_PACK_FLAGS);\r\nname = atk_get_pack_member(data, obj, HWMON_PACK_NAME);\r\nlimit1 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT1);\r\nlimit2 = atk_get_pack_member(data, obj, HWMON_PACK_LIMIT2);\r\nsensor = kzalloc(sizeof(*sensor), GFP_KERNEL);\r\nif (!sensor)\r\nreturn -ENOMEM;\r\nsensor->acpi_name = kstrdup(name->string.pointer, GFP_KERNEL);\r\nif (!sensor->acpi_name) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&sensor->list);\r\nsensor->type = type;\r\nsensor->data = data;\r\nsensor->id = flags->integer.value;\r\nsensor->limit1 = limit1->integer.value;\r\nif (data->old_interface)\r\nsensor->limit2 = limit2->integer.value;\r\nelse\r\nsensor->limit2 = sensor->limit1 + limit2->integer.value;\r\nsnprintf(sensor->input_attr_name, ATTR_NAME_SIZE,\r\n"%s%d_input", base_name, start + *num);\r\natk_init_attribute(&sensor->input_attr,\r\nsensor->input_attr_name,\r\natk_input_show);\r\nsnprintf(sensor->label_attr_name, ATTR_NAME_SIZE,\r\n"%s%d_label", base_name, start + *num);\r\natk_init_attribute(&sensor->label_attr,\r\nsensor->label_attr_name,\r\natk_label_show);\r\nsnprintf(sensor->limit1_attr_name, ATTR_NAME_SIZE,\r\n"%s%d_%s", base_name, start + *num, limit1_name);\r\natk_init_attribute(&sensor->limit1_attr,\r\nsensor->limit1_attr_name,\r\natk_limit1_show);\r\nsnprintf(sensor->limit2_attr_name, ATTR_NAME_SIZE,\r\n"%s%d_%s", base_name, start + *num, limit2_name);\r\natk_init_attribute(&sensor->limit2_attr,\r\nsensor->limit2_attr_name,\r\natk_limit2_show);\r\nlist_add(&sensor->list, &data->sensor_list);\r\n(*num)++;\r\nreturn 1;\r\nout:\r\nkfree(sensor->acpi_name);\r\nkfree(sensor);\r\nreturn err;\r\n}\r\nstatic int atk_enumerate_old_hwmon(struct atk_data *data)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nstruct acpi_buffer buf;\r\nunion acpi_object *pack;\r\nacpi_status status;\r\nint i, ret;\r\nint count = 0;\r\nbuf.length = ACPI_ALLOCATE_BUFFER;\r\nstatus = acpi_evaluate_object_typed(data->atk_handle,\r\nMETHOD_OLD_ENUM_VLT, NULL, &buf, ACPI_TYPE_PACKAGE);\r\nif (status != AE_OK) {\r\ndev_warn(dev, METHOD_OLD_ENUM_VLT ": ACPI exception: %s\n",\r\nacpi_format_exception(status));\r\nreturn -ENODEV;\r\n}\r\npack = buf.pointer;\r\nfor (i = 1; i < pack->package.count; i++) {\r\nunion acpi_object *obj = &pack->package.elements[i];\r\nret = atk_add_sensor(data, obj);\r\nif (ret > 0)\r\ncount++;\r\n}\r\nACPI_FREE(buf.pointer);\r\nbuf.length = ACPI_ALLOCATE_BUFFER;\r\nstatus = acpi_evaluate_object_typed(data->atk_handle,\r\nMETHOD_OLD_ENUM_TMP, NULL, &buf, ACPI_TYPE_PACKAGE);\r\nif (status != AE_OK) {\r\ndev_warn(dev, METHOD_OLD_ENUM_TMP ": ACPI exception: %s\n",\r\nacpi_format_exception(status));\r\nret = -ENODEV;\r\ngoto cleanup;\r\n}\r\npack = buf.pointer;\r\nfor (i = 1; i < pack->package.count; i++) {\r\nunion acpi_object *obj = &pack->package.elements[i];\r\nret = atk_add_sensor(data, obj);\r\nif (ret > 0)\r\ncount++;\r\n}\r\nACPI_FREE(buf.pointer);\r\nbuf.length = ACPI_ALLOCATE_BUFFER;\r\nstatus = acpi_evaluate_object_typed(data->atk_handle,\r\nMETHOD_OLD_ENUM_FAN, NULL, &buf, ACPI_TYPE_PACKAGE);\r\nif (status != AE_OK) {\r\ndev_warn(dev, METHOD_OLD_ENUM_FAN ": ACPI exception: %s\n",\r\nacpi_format_exception(status));\r\nret = -ENODEV;\r\ngoto cleanup;\r\n}\r\npack = buf.pointer;\r\nfor (i = 1; i < pack->package.count; i++) {\r\nunion acpi_object *obj = &pack->package.elements[i];\r\nret = atk_add_sensor(data, obj);\r\nif (ret > 0)\r\ncount++;\r\n}\r\nACPI_FREE(buf.pointer);\r\nreturn count;\r\ncleanup:\r\natk_free_sensors(data);\r\nreturn ret;\r\n}\r\nstatic int atk_ec_present(struct atk_data *data)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *pack;\r\nunion acpi_object *ec;\r\nint ret;\r\nint i;\r\npack = atk_ggrp(data, ATK_MUX_MGMT);\r\nif (IS_ERR(pack)) {\r\nif (PTR_ERR(pack) == -ENOENT) {\r\ndev_dbg(dev, "Class %#llx not found\n", ATK_MUX_MGMT);\r\nreturn 0;\r\n}\r\nreturn PTR_ERR(pack);\r\n}\r\nec = NULL;\r\nfor (i = 0; i < pack->package.count; i++) {\r\nunion acpi_object *obj = &pack->package.elements[i];\r\nunion acpi_object *id;\r\nif (obj->type != ACPI_TYPE_PACKAGE)\r\ncontinue;\r\nid = &obj->package.elements[0];\r\nif (id->type != ACPI_TYPE_INTEGER)\r\ncontinue;\r\nif (id->integer.value == ATK_EC_ID) {\r\nec = obj;\r\nbreak;\r\n}\r\n}\r\nret = (ec != NULL);\r\nif (!ret)\r\ndev_dbg(dev, "EC not found\n");\r\nACPI_FREE(pack);\r\nreturn ret;\r\n}\r\nstatic int atk_ec_enabled(struct atk_data *data)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *obj;\r\nstruct atk_acpi_ret_buffer *buf;\r\nint err;\r\nobj = atk_gitm(data, ATK_EC_ID);\r\nif (IS_ERR(obj)) {\r\ndev_err(dev, "Unable to query EC status\n");\r\nreturn PTR_ERR(obj);\r\n}\r\nbuf = (struct atk_acpi_ret_buffer *)obj->buffer.pointer;\r\nif (buf->flags == 0) {\r\ndev_err(dev, "Unable to query EC status\n");\r\nerr = -EIO;\r\n} else {\r\nerr = (buf->value != 0);\r\ndev_dbg(dev, "EC is %sabled\n",\r\nerr ? "en" : "dis");\r\n}\r\nACPI_FREE(obj);\r\nreturn err;\r\n}\r\nstatic int atk_ec_ctl(struct atk_data *data, int enable)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *obj;\r\nstruct atk_acpi_input_buf sitm;\r\nstruct atk_acpi_ret_buffer *ec_ret;\r\nint err = 0;\r\nsitm.id = ATK_EC_ID;\r\nsitm.param1 = enable;\r\nsitm.param2 = 0;\r\nobj = atk_sitm(data, &sitm);\r\nif (IS_ERR(obj)) {\r\ndev_err(dev, "Failed to %sable the EC\n",\r\nenable ? "en" : "dis");\r\nreturn PTR_ERR(obj);\r\n}\r\nec_ret = (struct atk_acpi_ret_buffer *)obj->buffer.pointer;\r\nif (ec_ret->flags == 0) {\r\ndev_err(dev, "Failed to %sable the EC\n",\r\nenable ? "en" : "dis");\r\nerr = -EIO;\r\n} else {\r\ndev_info(dev, "EC %sabled\n",\r\nenable ? "en" : "dis");\r\n}\r\nACPI_FREE(obj);\r\nreturn err;\r\n}\r\nstatic int atk_enumerate_new_hwmon(struct atk_data *data)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nunion acpi_object *pack;\r\nint err;\r\nint i;\r\nerr = atk_ec_present(data);\r\nif (err < 0)\r\nreturn err;\r\nif (err) {\r\nerr = atk_ec_enabled(data);\r\nif (err < 0)\r\nreturn err;\r\ndata->disable_ec = err;\r\nerr = atk_ec_ctl(data, 1);\r\nif (err) {\r\ndata->disable_ec = false;\r\nreturn err;\r\n}\r\n}\r\ndev_dbg(dev, "Enumerating hwmon sensors\n");\r\npack = atk_ggrp(data, ATK_MUX_HWMON);\r\nif (IS_ERR(pack))\r\nreturn PTR_ERR(pack);\r\nfor (i = 0; i < pack->package.count; i++) {\r\nunion acpi_object *obj = &pack->package.elements[i];\r\natk_add_sensor(data, obj);\r\n}\r\nerr = data->voltage_count + data->temperature_count + data->fan_count;\r\nACPI_FREE(pack);\r\nreturn err;\r\n}\r\nstatic int atk_create_files(struct atk_data *data)\r\n{\r\nstruct atk_sensor_data *s;\r\nint err;\r\nlist_for_each_entry(s, &data->sensor_list, list) {\r\nerr = device_create_file(data->hwmon_dev, &s->input_attr);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(data->hwmon_dev, &s->label_attr);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(data->hwmon_dev, &s->limit1_attr);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(data->hwmon_dev, &s->limit2_attr);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = device_create_file(data->hwmon_dev, &atk_name_attr);\r\nreturn err;\r\n}\r\nstatic void atk_remove_files(struct atk_data *data)\r\n{\r\nstruct atk_sensor_data *s;\r\nlist_for_each_entry(s, &data->sensor_list, list) {\r\ndevice_remove_file(data->hwmon_dev, &s->input_attr);\r\ndevice_remove_file(data->hwmon_dev, &s->label_attr);\r\ndevice_remove_file(data->hwmon_dev, &s->limit1_attr);\r\ndevice_remove_file(data->hwmon_dev, &s->limit2_attr);\r\n}\r\ndevice_remove_file(data->hwmon_dev, &atk_name_attr);\r\n}\r\nstatic void atk_free_sensors(struct atk_data *data)\r\n{\r\nstruct list_head *head = &data->sensor_list;\r\nstruct atk_sensor_data *s, *tmp;\r\nlist_for_each_entry_safe(s, tmp, head, list) {\r\nkfree(s->acpi_name);\r\nkfree(s);\r\n}\r\n}\r\nstatic int atk_register_hwmon(struct atk_data *data)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nint err;\r\ndev_dbg(dev, "registering hwmon device\n");\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev))\r\nreturn PTR_ERR(data->hwmon_dev);\r\ndev_dbg(dev, "populating sysfs directory\n");\r\nerr = atk_create_files(data);\r\nif (err)\r\ngoto remove;\r\nreturn 0;\r\nremove:\r\natk_remove_files(data);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nreturn err;\r\n}\r\nstatic int atk_probe_if(struct atk_data *data)\r\n{\r\nstruct device *dev = &data->acpi_dev->dev;\r\nacpi_handle ret;\r\nacpi_status status;\r\nint err = 0;\r\nstatus = acpi_get_handle(data->atk_handle, METHOD_OLD_READ_TMP, &ret);\r\nif (ACPI_SUCCESS(status))\r\ndata->rtmp_handle = ret;\r\nelse\r\ndev_dbg(dev, "method " METHOD_OLD_READ_TMP " not found: %s\n",\r\nacpi_format_exception(status));\r\nstatus = acpi_get_handle(data->atk_handle, METHOD_OLD_READ_VLT, &ret);\r\nif (ACPI_SUCCESS(status))\r\ndata->rvlt_handle = ret;\r\nelse\r\ndev_dbg(dev, "method " METHOD_OLD_READ_VLT " not found: %s\n",\r\nacpi_format_exception(status));\r\nstatus = acpi_get_handle(data->atk_handle, METHOD_OLD_READ_FAN, &ret);\r\nif (ACPI_SUCCESS(status))\r\ndata->rfan_handle = ret;\r\nelse\r\ndev_dbg(dev, "method " METHOD_OLD_READ_FAN " not found: %s\n",\r\nacpi_format_exception(status));\r\nstatus = acpi_get_handle(data->atk_handle, METHOD_ENUMERATE, &ret);\r\nif (ACPI_SUCCESS(status))\r\ndata->enumerate_handle = ret;\r\nelse\r\ndev_dbg(dev, "method " METHOD_ENUMERATE " not found: %s\n",\r\nacpi_format_exception(status));\r\nstatus = acpi_get_handle(data->atk_handle, METHOD_READ, &ret);\r\nif (ACPI_SUCCESS(status))\r\ndata->read_handle = ret;\r\nelse\r\ndev_dbg(dev, "method " METHOD_READ " not found: %s\n",\r\nacpi_format_exception(status));\r\nstatus = acpi_get_handle(data->atk_handle, METHOD_WRITE, &ret);\r\nif (ACPI_SUCCESS(status))\r\ndata->write_handle = ret;\r\nelse\r\ndev_dbg(dev, "method " METHOD_WRITE " not found: %s\n",\r\nacpi_format_exception(status));\r\nif (new_if)\r\ndev_info(dev, "Overriding interface detection\n");\r\nif (data->rtmp_handle &&\r\ndata->rvlt_handle && data->rfan_handle && !new_if)\r\ndata->old_interface = true;\r\nelse if (data->enumerate_handle && data->read_handle &&\r\ndata->write_handle)\r\ndata->old_interface = false;\r\nelse\r\nerr = -ENODEV;\r\nreturn err;\r\n}\r\nstatic int atk_add(struct acpi_device *device)\r\n{\r\nacpi_status ret;\r\nint err;\r\nstruct acpi_buffer buf;\r\nunion acpi_object *obj;\r\nstruct atk_data *data;\r\ndev_dbg(&device->dev, "adding...\n");\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->acpi_dev = device;\r\ndata->atk_handle = device->handle;\r\nINIT_LIST_HEAD(&data->sensor_list);\r\ndata->disable_ec = false;\r\nbuf.length = ACPI_ALLOCATE_BUFFER;\r\nret = acpi_evaluate_object_typed(data->atk_handle, BOARD_ID, NULL,\r\n&buf, ACPI_TYPE_PACKAGE);\r\nif (ret != AE_OK) {\r\ndev_dbg(&device->dev, "atk: method MBIF not found\n");\r\n} else {\r\nobj = buf.pointer;\r\nif (obj->package.count >= 2) {\r\nunion acpi_object *id = &obj->package.elements[1];\r\nif (id->type == ACPI_TYPE_STRING)\r\ndev_dbg(&device->dev, "board ID = %s\n",\r\nid->string.pointer);\r\n}\r\nACPI_FREE(buf.pointer);\r\n}\r\nerr = atk_probe_if(data);\r\nif (err) {\r\ndev_err(&device->dev, "No usable hwmon interface detected\n");\r\ngoto out;\r\n}\r\nif (data->old_interface) {\r\ndev_dbg(&device->dev, "Using old hwmon interface\n");\r\nerr = atk_enumerate_old_hwmon(data);\r\n} else {\r\ndev_dbg(&device->dev, "Using new hwmon interface\n");\r\nerr = atk_enumerate_new_hwmon(data);\r\n}\r\nif (err < 0)\r\ngoto out;\r\nif (err == 0) {\r\ndev_info(&device->dev,\r\n"No usable sensor detected, bailing out\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = atk_register_hwmon(data);\r\nif (err)\r\ngoto cleanup;\r\natk_debugfs_init(data);\r\ndevice->driver_data = data;\r\nreturn 0;\r\ncleanup:\r\natk_free_sensors(data);\r\nout:\r\nif (data->disable_ec)\r\natk_ec_ctl(data, 0);\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int atk_remove(struct acpi_device *device, int type)\r\n{\r\nstruct atk_data *data = device->driver_data;\r\ndev_dbg(&device->dev, "removing...\n");\r\ndevice->driver_data = NULL;\r\natk_debugfs_cleanup(data);\r\natk_remove_files(data);\r\natk_free_sensors(data);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nif (data->disable_ec) {\r\nif (atk_ec_ctl(data, 0))\r\ndev_err(&device->dev, "Failed to disable EC\n");\r\n}\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int __init atk0110_init(void)\r\n{\r\nint ret;\r\nif (!acpi_resources_are_enforced()) {\r\npr_err("Resources not safely usable due to acpi_enforce_resources kernel parameter\n");\r\nreturn -EBUSY;\r\n}\r\nif (dmi_check_system(atk_force_new_if))\r\nnew_if = true;\r\nret = acpi_bus_register_driver(&atk_driver);\r\nif (ret)\r\npr_info("acpi_bus_register_driver failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit atk0110_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&atk_driver);\r\n}
