int tm6000_read_write_usb(struct tm6000_core *dev, u8 req_type, u8 req,\r\nu16 value, u16 index, u8 *buf, u16 len)\r\n{\r\nint ret, i;\r\nunsigned int pipe;\r\nu8 *data = NULL;\r\nint delay = 5000;\r\nmutex_lock(&dev->usb_lock);\r\nif (len)\r\ndata = kzalloc(len, GFP_KERNEL);\r\nif (req_type & USB_DIR_IN)\r\npipe = usb_rcvctrlpipe(dev->udev, 0);\r\nelse {\r\npipe = usb_sndctrlpipe(dev->udev, 0);\r\nmemcpy(data, buf, len);\r\n}\r\nif (tm6000_debug & V4L2_DEBUG_I2C) {\r\nprintk(KERN_DEBUG "(dev %p, pipe %08x): ", dev->udev, pipe);\r\nprintk(KERN_CONT "%s: %02x %02x %02x %02x %02x %02x %02x %02x ",\r\n(req_type & USB_DIR_IN) ? " IN" : "OUT",\r\nreq_type, req, value&0xff, value>>8, index&0xff,\r\nindex>>8, len&0xff, len>>8);\r\nif (!(req_type & USB_DIR_IN)) {\r\nprintk(KERN_CONT ">>> ");\r\nfor (i = 0; i < len; i++)\r\nprintk(KERN_CONT " %02x", buf[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\n}\r\nret = usb_control_msg(dev->udev, pipe, req, req_type, value, index,\r\ndata, len, USB_TIMEOUT);\r\nif (req_type & USB_DIR_IN)\r\nmemcpy(buf, data, len);\r\nif (tm6000_debug & V4L2_DEBUG_I2C) {\r\nif (ret < 0) {\r\nif (req_type & USB_DIR_IN)\r\nprintk(KERN_DEBUG "<<< (len=%d)\n", len);\r\nprintk(KERN_CONT "%s: Error #%d\n", __func__, ret);\r\n} else if (req_type & USB_DIR_IN) {\r\nprintk(KERN_CONT "<<< ");\r\nfor (i = 0; i < len; i++)\r\nprintk(KERN_CONT " %02x", buf[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\n}\r\nkfree(data);\r\nif (dev->quirks & TM6000_QUIRK_NO_USB_DELAY)\r\ndelay = 0;\r\nif (req == REQ_16_SET_GET_I2C_WR1_RDN && !(req_type & USB_DIR_IN)) {\r\nunsigned int tsleep;\r\ntsleep = (len * 200) + 200;\r\nif (tsleep < delay)\r\ntsleep = delay;\r\nusleep_range(tsleep, tsleep + 1000);\r\n}\r\nelse if (delay)\r\nusleep_range(delay, delay + 1000);\r\nmutex_unlock(&dev->usb_lock);\r\nreturn ret;\r\n}\r\nint tm6000_set_reg(struct tm6000_core *dev, u8 req, u16 value, u16 index)\r\n{\r\nreturn\r\ntm6000_read_write_usb(dev, USB_DIR_OUT | USB_TYPE_VENDOR,\r\nreq, value, index, NULL, 0);\r\n}\r\nint tm6000_get_reg(struct tm6000_core *dev, u8 req, u16 value, u16 index)\r\n{\r\nint rc;\r\nu8 buf[1];\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR, req,\r\nvalue, index, buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn *buf;\r\n}\r\nint tm6000_set_reg_mask(struct tm6000_core *dev, u8 req, u16 value,\r\nu16 index, u16 mask)\r\n{\r\nint rc;\r\nu8 buf[1];\r\nu8 new_index;\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR, req,\r\nvalue, 0, buf, 1);\r\nif (rc < 0)\r\nreturn rc;\r\nnew_index = (buf[0] & ~mask) | (index & mask);\r\nif (new_index == buf[0])\r\nreturn 0;\r\nreturn tm6000_read_write_usb(dev, USB_DIR_OUT | USB_TYPE_VENDOR,\r\nreq, value, new_index, NULL, 0);\r\n}\r\nint tm6000_get_reg16(struct tm6000_core *dev, u8 req, u16 value, u16 index)\r\n{\r\nint rc;\r\nu8 buf[2];\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR, req,\r\nvalue, index, buf, 2);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn buf[1]|buf[0]<<8;\r\n}\r\nint tm6000_get_reg32(struct tm6000_core *dev, u8 req, u16 value, u16 index)\r\n{\r\nint rc;\r\nu8 buf[4];\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR, req,\r\nvalue, index, buf, 4);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn buf[3] | buf[2] << 8 | buf[1] << 16 | buf[0] << 24;\r\n}\r\nint tm6000_i2c_reset(struct tm6000_core *dev, u16 tsleep)\r\n{\r\nint rc;\r\nrc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, TM6000_GPIO_CLK, 0);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(tsleep);\r\nrc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, TM6000_GPIO_CLK, 1);\r\nmsleep(tsleep);\r\nreturn rc;\r\n}\r\nvoid tm6000_set_fourcc_format(struct tm6000_core *dev)\r\n{\r\nif (dev->dev_type == TM6010) {\r\nint val;\r\nval = tm6000_get_reg(dev, TM6010_REQ07_RCC_ACTIVE_IF, 0) & 0xfc;\r\nif (dev->fourcc == V4L2_PIX_FMT_UYVY)\r\ntm6000_set_reg(dev, TM6010_REQ07_RCC_ACTIVE_IF, val);\r\nelse\r\ntm6000_set_reg(dev, TM6010_REQ07_RCC_ACTIVE_IF, val | 1);\r\n} else {\r\nif (dev->fourcc == V4L2_PIX_FMT_UYVY)\r\ntm6000_set_reg(dev, TM6010_REQ07_RC1_TRESHOLD, 0xd0);\r\nelse\r\ntm6000_set_reg(dev, TM6010_REQ07_RC1_TRESHOLD, 0x90);\r\n}\r\n}\r\nstatic void tm6000_set_vbi(struct tm6000_core *dev)\r\n{\r\nif (dev->dev_type == TM6010) {\r\ntm6000_set_reg(dev, TM6010_REQ07_R3F_RESET, 0x01);\r\ntm6000_set_reg(dev, TM6010_REQ07_R41_TELETEXT_VBI_CODE1, 0x27);\r\ntm6000_set_reg(dev, TM6010_REQ07_R42_VBI_DATA_HIGH_LEVEL, 0x55);\r\ntm6000_set_reg(dev, TM6010_REQ07_R43_VBI_DATA_TYPE_LINE7, 0x66);\r\ntm6000_set_reg(dev, TM6010_REQ07_R44_VBI_DATA_TYPE_LINE8, 0x66);\r\ntm6000_set_reg(dev, TM6010_REQ07_R45_VBI_DATA_TYPE_LINE9, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R46_VBI_DATA_TYPE_LINE10, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R47_VBI_DATA_TYPE_LINE11, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R48_VBI_DATA_TYPE_LINE12, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R49_VBI_DATA_TYPE_LINE13, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R4A_VBI_DATA_TYPE_LINE14, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R4B_VBI_DATA_TYPE_LINE15, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R4C_VBI_DATA_TYPE_LINE16, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R4D_VBI_DATA_TYPE_LINE17, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R4E_VBI_DATA_TYPE_LINE18, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R4F_VBI_DATA_TYPE_LINE19, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R50_VBI_DATA_TYPE_LINE20, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R51_VBI_DATA_TYPE_LINE21, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R52_VBI_DATA_TYPE_LINE22, 0x66);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R53_VBI_DATA_TYPE_LINE23, 0x00);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R54_VBI_DATA_TYPE_RLINES, 0x00);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R55_VBI_LOOP_FILTER_GAIN, 0x01);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R56_VBI_LOOP_FILTER_I_GAIN, 0x00);\r\ntm6000_set_reg(dev,\r\nTM6010_REQ07_R57_VBI_LOOP_FILTER_P_GAIN, 0x02);\r\ntm6000_set_reg(dev, TM6010_REQ07_R58_VBI_CAPTION_DTO1, 0x35);\r\ntm6000_set_reg(dev, TM6010_REQ07_R59_VBI_CAPTION_DTO0, 0xa0);\r\ntm6000_set_reg(dev, TM6010_REQ07_R5A_VBI_TELETEXT_DTO1, 0x11);\r\ntm6000_set_reg(dev, TM6010_REQ07_R5B_VBI_TELETEXT_DTO0, 0x4c);\r\ntm6000_set_reg(dev, TM6010_REQ07_R40_TELETEXT_VBI_CODE0, 0x01);\r\ntm6000_set_reg(dev, TM6010_REQ07_R3F_RESET, 0x00);\r\n}\r\n}\r\nint tm6000_init_analog_mode(struct tm6000_core *dev)\r\n{\r\nstruct v4l2_frequency f;\r\nif (dev->dev_type == TM6010) {\r\nu8 active = TM6010_REQ07_RCC_ACTIVE_IF_AUDIO_ENABLE;\r\nif (!dev->radio)\r\nactive |= TM6010_REQ07_RCC_ACTIVE_IF_VIDEO_ENABLE;\r\ntm6000_set_reg_mask(dev, TM6010_REQ07_RCC_ACTIVE_IF,\r\nactive, 0x60);\r\ntm6000_set_reg_mask(dev, TM6010_REQ07_RC0_ACTIVE_VIDEO_SOURCE,\r\n0x00, 0x40);\r\n} else {\r\ntm6000_set_reg(dev, TM6010_REQ07_R3F_RESET, 0x01);\r\nif (dev->scaler)\r\ntm6000_set_reg(dev, TM6010_REQ07_RC0_ACTIVE_VIDEO_SOURCE, 0x20);\r\nelse\r\ntm6000_set_reg(dev, TM6010_REQ07_RC0_ACTIVE_VIDEO_SOURCE, 0x80);\r\ntm6000_set_reg(dev, TM6010_REQ07_RC3_HSTART1, 0x88);\r\ntm6000_set_reg(dev, TM6000_REQ07_RDA_CLK_SEL, 0x23);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD1_ADDR_FOR_REQ1, 0xc0);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD2_ADDR_FOR_REQ2, 0xd8);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD6_ENDP_REQ1_REQ2, 0x06);\r\ntm6000_set_reg(dev, TM6000_REQ07_RDF_PWDOWN_ACLK, 0x1f);\r\ntm6000_set_reg(dev, TM6010_REQ07_RFF_SOFT_RESET, 0x08);\r\ntm6000_set_reg(dev, TM6010_REQ07_RFF_SOFT_RESET, 0x00);\r\ntm6000_set_fourcc_format(dev);\r\ntm6000_set_reg(dev, TM6010_REQ07_R3F_RESET, 0x00);\r\n}\r\nmsleep(20);\r\nf.frequency = dev->freq;\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, tuner, s_frequency, &f);\r\nmsleep(100);\r\ntm6000_set_standard(dev);\r\ntm6000_set_vbi(dev);\r\ntm6000_set_audio_bitrate(dev, 48000);\r\nif (dev->gpio.dvb_led) {\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.dvb_led, 0x01);\r\n}\r\nreturn 0;\r\n}\r\nint tm6000_init_digital_mode(struct tm6000_core *dev)\r\n{\r\nif (dev->dev_type == TM6010) {\r\ntm6000_set_reg_mask(dev, TM6010_REQ07_RCC_ACTIVE_IF,\r\n0x00, 0x60);\r\ntm6000_set_reg_mask(dev, TM6010_REQ07_RC0_ACTIVE_VIDEO_SOURCE,\r\n0x40, 0x40);\r\ntm6000_set_reg(dev, TM6010_REQ07_RFE_POWER_DOWN, 0x28);\r\ntm6000_set_reg(dev, TM6010_REQ08_RE2_POWER_DOWN_CTRL1, 0xfc);\r\ntm6000_set_reg(dev, TM6010_REQ08_RE6_POWER_DOWN_CTRL2, 0xff);\r\n} else {\r\ntm6000_set_reg(dev, TM6010_REQ07_RFF_SOFT_RESET, 0x08);\r\ntm6000_set_reg(dev, TM6010_REQ07_RFF_SOFT_RESET, 0x00);\r\ntm6000_set_reg(dev, TM6010_REQ07_R3F_RESET, 0x01);\r\ntm6000_set_reg(dev, TM6000_REQ07_RDF_PWDOWN_ACLK, 0x08);\r\ntm6000_set_reg(dev, TM6000_REQ07_RE2_VADC_STATUS_CTL, 0x0c);\r\ntm6000_set_reg(dev, TM6000_REQ07_RE8_VADC_PWDOWN_CTL, 0xff);\r\ntm6000_set_reg(dev, TM6000_REQ07_REB_VADC_AADC_MODE, 0xd8);\r\ntm6000_set_reg(dev, TM6010_REQ07_RC0_ACTIVE_VIDEO_SOURCE, 0x40);\r\ntm6000_set_reg(dev, TM6010_REQ07_RC1_TRESHOLD, 0xd0);\r\ntm6000_set_reg(dev, TM6010_REQ07_RC3_HSTART1, 0x09);\r\ntm6000_set_reg(dev, TM6000_REQ07_RDA_CLK_SEL, 0x37);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD1_ADDR_FOR_REQ1, 0xd8);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD2_ADDR_FOR_REQ2, 0xc0);\r\ntm6000_set_reg(dev, TM6010_REQ07_RD6_ENDP_REQ1_REQ2, 0x60);\r\ntm6000_set_reg(dev, TM6000_REQ07_RE2_VADC_STATUS_CTL, 0x0c);\r\ntm6000_set_reg(dev, TM6000_REQ07_RE8_VADC_PWDOWN_CTL, 0xff);\r\ntm6000_set_reg(dev, TM6000_REQ07_REB_VADC_AADC_MODE, 0x08);\r\nmsleep(50);\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT, 0x0020, 0x00);\r\nmsleep(50);\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT, 0x0020, 0x01);\r\nmsleep(50);\r\ntm6000_set_reg(dev, REQ_04_EN_DISABLE_MCU_INT, 0x0020, 0x00);\r\nmsleep(100);\r\n}\r\nif (dev->gpio.dvb_led) {\r\ntm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,\r\ndev->gpio.dvb_led, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nint tm6000_init(struct tm6000_core *dev)\r\n{\r\nint board, rc = 0, i, size;\r\nstruct reg_init *tab;\r\nboard = tm6000_get_reg32(dev, REQ_40_GET_VERSION, 0, 0);\r\nif (board >= 0) {\r\nswitch (board & 0xff) {\r\ncase 0xf3:\r\nprintk(KERN_INFO "Found tm6000\n");\r\nif (dev->dev_type != TM6000)\r\ndev->dev_type = TM6000;\r\nbreak;\r\ncase 0xf4:\r\nprintk(KERN_INFO "Found tm6010\n");\r\nif (dev->dev_type != TM6010)\r\ndev->dev_type = TM6010;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unknown board version = 0x%08x\n", board);\r\n}\r\n} else\r\nprintk(KERN_ERR "Error %i while retrieving board version\n", board);\r\nif (dev->dev_type == TM6010) {\r\ntab = tm6010_init_tab;\r\nsize = ARRAY_SIZE(tm6010_init_tab);\r\n} else {\r\ntab = tm6000_init_tab;\r\nsize = ARRAY_SIZE(tm6000_init_tab);\r\n}\r\nfor (i = 0; i < size; i++) {\r\nrc = tm6000_set_reg(dev, tab[i].req, tab[i].reg, tab[i].val);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "Error %i while setting req %d, "\r\n"reg %d to value %d\n", rc,\r\ntab[i].req, tab[i].reg, tab[i].val);\r\nreturn rc;\r\n}\r\n}\r\nmsleep(5);\r\nrc = tm6000_cards_setup(dev);\r\nreturn rc;\r\n}\r\nint tm6000_set_audio_bitrate(struct tm6000_core *dev, int bitrate)\r\n{\r\nint val = 0;\r\nu8 areg_f0 = 0x60;\r\nu8 areg_0a = 0x91;\r\nswitch (bitrate) {\r\ncase 48000:\r\nareg_f0 = 0x60;\r\nareg_0a = 0x91;\r\ndev->audio_bitrate = bitrate;\r\nbreak;\r\ncase 32000:\r\nareg_f0 = 0x00;\r\nareg_0a = 0x90;\r\ndev->audio_bitrate = bitrate;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (dev->dev_type == TM6010) {\r\nval = tm6000_set_reg(dev, TM6010_REQ08_R0A_A_I2S_MOD, areg_0a);\r\nif (val < 0)\r\nreturn val;\r\nval = tm6000_set_reg_mask(dev, TM6010_REQ08_RF0_DAUDIO_INPUT_CONFIG,\r\nareg_f0, 0xf0);\r\nif (val < 0)\r\nreturn val;\r\n} else {\r\nval = tm6000_set_reg_mask(dev, TM6000_REQ07_REB_VADC_AADC_MODE,\r\nareg_f0, 0xf0);\r\nif (val < 0)\r\nreturn val;\r\n}\r\nreturn 0;\r\n}\r\nint tm6000_set_audio_rinput(struct tm6000_core *dev)\r\n{\r\nif (dev->dev_type == TM6010) {\r\nu8 areg_f0;\r\nu8 areg_07 = 0x10;\r\nswitch (dev->rinput.amux) {\r\ncase TM6000_AMUX_SIF1:\r\ncase TM6000_AMUX_SIF2:\r\nareg_f0 = 0x03;\r\nareg_07 = 0x30;\r\nbreak;\r\ncase TM6000_AMUX_ADC1:\r\nareg_f0 = 0x00;\r\nbreak;\r\ncase TM6000_AMUX_ADC2:\r\nareg_f0 = 0x08;\r\nbreak;\r\ncase TM6000_AMUX_I2S:\r\nareg_f0 = 0x04;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: audio input dosn't support\n",\r\ndev->name);\r\nreturn 0;\r\nbreak;\r\n}\r\ntm6000_set_reg_mask(dev, TM6010_REQ08_RF0_DAUDIO_INPUT_CONFIG,\r\nareg_f0, 0x0f);\r\ntm6000_set_reg_mask(dev, TM6010_REQ07_R07_OUTPUT_CONTROL,\r\nareg_07, 0xf0);\r\n} else {\r\nu8 areg_eb;\r\nswitch (dev->rinput.amux) {\r\ncase TM6000_AMUX_ADC1:\r\nareg_eb = 0x00;\r\nbreak;\r\ncase TM6000_AMUX_ADC2:\r\nareg_eb = 0x04;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "%s: audio input dosn't support\n",\r\ndev->name);\r\nreturn 0;\r\nbreak;\r\n}\r\ntm6000_set_reg_mask(dev, TM6000_REQ07_REB_VADC_AADC_MODE,\r\nareg_eb, 0x0f);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tm6010_set_mute_sif(struct tm6000_core *dev, u8 mute)\r\n{\r\nu8 mute_reg = 0;\r\nif (mute)\r\nmute_reg = 0x08;\r\ntm6000_set_reg_mask(dev, TM6010_REQ08_R0A_A_I2S_MOD, mute_reg, 0x08);\r\n}\r\nstatic void tm6010_set_mute_adc(struct tm6000_core *dev, u8 mute)\r\n{\r\nu8 mute_reg = 0;\r\nif (mute)\r\nmute_reg = 0x20;\r\nif (dev->dev_type == TM6010) {\r\ntm6000_set_reg_mask(dev, TM6010_REQ08_RF2_LEFT_CHANNEL_VOL,\r\nmute_reg, 0x20);\r\ntm6000_set_reg_mask(dev, TM6010_REQ08_RF3_RIGHT_CHANNEL_VOL,\r\nmute_reg, 0x20);\r\n} else {\r\ntm6000_set_reg_mask(dev, TM6000_REQ07_REC_VADC_AADC_LVOL,\r\nmute_reg, 0x20);\r\ntm6000_set_reg_mask(dev, TM6000_REQ07_RED_VADC_AADC_RVOL,\r\nmute_reg, 0x20);\r\n}\r\n}\r\nint tm6000_tvaudio_set_mute(struct tm6000_core *dev, u8 mute)\r\n{\r\nenum tm6000_mux mux;\r\nif (dev->radio)\r\nmux = dev->rinput.amux;\r\nelse\r\nmux = dev->vinput[dev->input].amux;\r\nswitch (mux) {\r\ncase TM6000_AMUX_SIF1:\r\ncase TM6000_AMUX_SIF2:\r\nif (dev->dev_type == TM6010)\r\ntm6010_set_mute_sif(dev, mute);\r\nelse {\r\nprintk(KERN_INFO "ERROR: TM5600 and TM6000 don't has"\r\n" SIF audio inputs. Please check the %s"\r\n" configuration.\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase TM6000_AMUX_ADC1:\r\ncase TM6000_AMUX_ADC2:\r\ntm6010_set_mute_adc(dev, mute);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tm6010_set_volume_sif(struct tm6000_core *dev, int vol)\r\n{\r\nu8 vol_reg;\r\nvol_reg = vol & 0x0F;\r\nif (vol < 0)\r\nvol_reg |= 0x40;\r\ntm6000_set_reg(dev, TM6010_REQ08_R07_A_LEFT_VOL, vol_reg);\r\ntm6000_set_reg(dev, TM6010_REQ08_R08_A_RIGHT_VOL, vol_reg);\r\n}\r\nstatic void tm6010_set_volume_adc(struct tm6000_core *dev, int vol)\r\n{\r\nu8 vol_reg;\r\nvol_reg = (vol + 0x10) & 0x1f;\r\nif (dev->dev_type == TM6010) {\r\ntm6000_set_reg(dev, TM6010_REQ08_RF2_LEFT_CHANNEL_VOL, vol_reg);\r\ntm6000_set_reg(dev, TM6010_REQ08_RF3_RIGHT_CHANNEL_VOL, vol_reg);\r\n} else {\r\ntm6000_set_reg(dev, TM6000_REQ07_REC_VADC_AADC_LVOL, vol_reg);\r\ntm6000_set_reg(dev, TM6000_REQ07_RED_VADC_AADC_RVOL, vol_reg);\r\n}\r\n}\r\nvoid tm6000_set_volume(struct tm6000_core *dev, int vol)\r\n{\r\nenum tm6000_mux mux;\r\nif (dev->radio) {\r\nmux = dev->rinput.amux;\r\nvol += 8;\r\n} else\r\nmux = dev->vinput[dev->input].amux;\r\nswitch (mux) {\r\ncase TM6000_AMUX_SIF1:\r\ncase TM6000_AMUX_SIF2:\r\nif (dev->dev_type == TM6010)\r\ntm6010_set_volume_sif(dev, vol);\r\nelse\r\nprintk(KERN_INFO "ERROR: TM5600 and TM6000 don't has"\r\n" SIF audio inputs. Please check the %s"\r\n" configuration.\n", dev->name);\r\nbreak;\r\ncase TM6000_AMUX_ADC1:\r\ncase TM6000_AMUX_ADC2:\r\ntm6010_set_volume_adc(dev, vol);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid tm6000_remove_from_devlist(struct tm6000_core *dev)\r\n{\r\nmutex_lock(&tm6000_devlist_mutex);\r\nlist_del(&dev->devlist);\r\nmutex_unlock(&tm6000_devlist_mutex);\r\n}\r\nvoid tm6000_add_into_devlist(struct tm6000_core *dev)\r\n{\r\nmutex_lock(&tm6000_devlist_mutex);\r\nlist_add_tail(&dev->devlist, &tm6000_devlist);\r\nmutex_unlock(&tm6000_devlist_mutex);\r\n}\r\nint tm6000_call_fillbuf(struct tm6000_core *dev, enum tm6000_ops_type type,\r\nchar *buf, int size)\r\n{\r\nstruct tm6000_ops *ops = NULL;\r\nif (!list_empty(&tm6000_extension_devlist)) {\r\nlist_for_each_entry(ops, &tm6000_extension_devlist, next) {\r\nif (ops->fillbuf && ops->type == type)\r\nops->fillbuf(dev, buf, size);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tm6000_register_extension(struct tm6000_ops *ops)\r\n{\r\nstruct tm6000_core *dev = NULL;\r\nmutex_lock(&tm6000_devlist_mutex);\r\nlist_add_tail(&ops->next, &tm6000_extension_devlist);\r\nlist_for_each_entry(dev, &tm6000_devlist, devlist) {\r\nops->init(dev);\r\nprintk(KERN_INFO "%s: Initialized (%s) extension\n",\r\ndev->name, ops->name);\r\n}\r\nmutex_unlock(&tm6000_devlist_mutex);\r\nreturn 0;\r\n}\r\nvoid tm6000_unregister_extension(struct tm6000_ops *ops)\r\n{\r\nstruct tm6000_core *dev = NULL;\r\nmutex_lock(&tm6000_devlist_mutex);\r\nlist_for_each_entry(dev, &tm6000_devlist, devlist)\r\nops->fini(dev);\r\nprintk(KERN_INFO "tm6000: Remove (%s) extension\n", ops->name);\r\nlist_del(&ops->next);\r\nmutex_unlock(&tm6000_devlist_mutex);\r\n}\r\nvoid tm6000_init_extension(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_ops *ops = NULL;\r\nmutex_lock(&tm6000_devlist_mutex);\r\nif (!list_empty(&tm6000_extension_devlist)) {\r\nlist_for_each_entry(ops, &tm6000_extension_devlist, next) {\r\nif (ops->init)\r\nops->init(dev);\r\n}\r\n}\r\nmutex_unlock(&tm6000_devlist_mutex);\r\n}\r\nvoid tm6000_close_extension(struct tm6000_core *dev)\r\n{\r\nstruct tm6000_ops *ops = NULL;\r\nmutex_lock(&tm6000_devlist_mutex);\r\nif (!list_empty(&tm6000_extension_devlist)) {\r\nlist_for_each_entry(ops, &tm6000_extension_devlist, next) {\r\nif (ops->fini)\r\nops->fini(dev);\r\n}\r\n}\r\nmutex_unlock(&tm6000_devlist_mutex);\r\n}
