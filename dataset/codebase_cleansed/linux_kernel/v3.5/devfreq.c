static struct devfreq *find_device_devfreq(struct device *dev)\r\n{\r\nstruct devfreq *tmp_devfreq;\r\nif (unlikely(IS_ERR_OR_NULL(dev))) {\r\npr_err("DEVFREQ: %s: Invalid parameters\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nWARN(!mutex_is_locked(&devfreq_list_lock),\r\n"devfreq_list_lock must be locked.");\r\nlist_for_each_entry(tmp_devfreq, &devfreq_list, node) {\r\nif (tmp_devfreq->dev.parent == dev)\r\nreturn tmp_devfreq;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nint update_devfreq(struct devfreq *devfreq)\r\n{\r\nunsigned long freq;\r\nint err = 0;\r\nu32 flags = 0;\r\nif (!mutex_is_locked(&devfreq->lock)) {\r\nWARN(true, "devfreq->lock must be locked by the caller.\n");\r\nreturn -EINVAL;\r\n}\r\nerr = devfreq->governor->get_target_freq(devfreq, &freq);\r\nif (err)\r\nreturn err;\r\nif (devfreq->min_freq && freq < devfreq->min_freq) {\r\nfreq = devfreq->min_freq;\r\nflags &= ~DEVFREQ_FLAG_LEAST_UPPER_BOUND;\r\n}\r\nif (devfreq->max_freq && freq > devfreq->max_freq) {\r\nfreq = devfreq->max_freq;\r\nflags |= DEVFREQ_FLAG_LEAST_UPPER_BOUND;\r\n}\r\nerr = devfreq->profile->target(devfreq->dev.parent, &freq, flags);\r\nif (err)\r\nreturn err;\r\ndevfreq->previous_freq = freq;\r\nreturn err;\r\n}\r\nstatic int devfreq_notifier_call(struct notifier_block *nb, unsigned long type,\r\nvoid *devp)\r\n{\r\nstruct devfreq *devfreq = container_of(nb, struct devfreq, nb);\r\nint ret;\r\nmutex_lock(&devfreq->lock);\r\nret = update_devfreq(devfreq);\r\nmutex_unlock(&devfreq->lock);\r\nreturn ret;\r\n}\r\nstatic void _remove_devfreq(struct devfreq *devfreq, bool skip)\r\n{\r\nif (!mutex_is_locked(&devfreq->lock)) {\r\nWARN(true, "devfreq->lock must be locked by the caller.\n");\r\nreturn;\r\n}\r\nif (!devfreq->governor->no_central_polling &&\r\n!mutex_is_locked(&devfreq_list_lock)) {\r\nWARN(true, "devfreq_list_lock must be locked by the caller.\n");\r\nreturn;\r\n}\r\nif (devfreq->being_removed)\r\nreturn;\r\ndevfreq->being_removed = true;\r\nif (devfreq->profile->exit)\r\ndevfreq->profile->exit(devfreq->dev.parent);\r\nif (devfreq->governor->exit)\r\ndevfreq->governor->exit(devfreq);\r\nif (!skip && get_device(&devfreq->dev)) {\r\ndevice_unregister(&devfreq->dev);\r\nput_device(&devfreq->dev);\r\n}\r\nif (!devfreq->governor->no_central_polling)\r\nlist_del(&devfreq->node);\r\nmutex_unlock(&devfreq->lock);\r\nmutex_destroy(&devfreq->lock);\r\nkfree(devfreq);\r\n}\r\nstatic void devfreq_dev_release(struct device *dev)\r\n{\r\nstruct devfreq *devfreq = to_devfreq(dev);\r\nbool central_polling = !devfreq->governor->no_central_polling;\r\nif (devfreq->being_removed)\r\nreturn;\r\nif (central_polling)\r\nmutex_lock(&devfreq_list_lock);\r\nmutex_lock(&devfreq->lock);\r\nif (devfreq->being_removed) {\r\nmutex_unlock(&devfreq->lock);\r\ngoto out;\r\n}\r\n_remove_devfreq(devfreq, true);\r\nout:\r\nif (central_polling)\r\nmutex_unlock(&devfreq_list_lock);\r\n}\r\nstatic void devfreq_monitor(struct work_struct *work)\r\n{\r\nstatic unsigned long last_polled_at;\r\nstruct devfreq *devfreq, *tmp;\r\nint error;\r\nunsigned long jiffies_passed;\r\nunsigned long next_jiffies = ULONG_MAX, now = jiffies;\r\nstruct device *dev;\r\njiffies_passed = now - last_polled_at;\r\nlast_polled_at = now;\r\nif (jiffies_passed == 0)\r\njiffies_passed = 1;\r\nmutex_lock(&devfreq_list_lock);\r\nlist_for_each_entry_safe(devfreq, tmp, &devfreq_list, node) {\r\nmutex_lock(&devfreq->lock);\r\ndev = devfreq->dev.parent;\r\nwait_remove_device = tmp;\r\nif (devfreq->governor->no_central_polling ||\r\ndevfreq->next_polling == 0) {\r\nmutex_unlock(&devfreq->lock);\r\ncontinue;\r\n}\r\nmutex_unlock(&devfreq_list_lock);\r\nif (devfreq->next_polling <= jiffies_passed) {\r\nerror = update_devfreq(devfreq);\r\nif (error && error != -EAGAIN) {\r\ndev_err(dev, "Due to update_devfreq error(%d), devfreq(%s) is removed from the device\n",\r\nerror, devfreq->governor->name);\r\nmutex_unlock(&devfreq->lock);\r\nmutex_lock(&devfreq_list_lock);\r\nif (IS_ERR(find_device_devfreq(dev)))\r\ncontinue;\r\nmutex_lock(&devfreq->lock);\r\n_remove_devfreq(devfreq, false);\r\ncontinue;\r\n}\r\ndevfreq->next_polling = devfreq->polling_jiffies;\r\n} else {\r\ndevfreq->next_polling -= jiffies_passed;\r\n}\r\nif (devfreq->next_polling)\r\nnext_jiffies = (next_jiffies > devfreq->next_polling) ?\r\ndevfreq->next_polling : next_jiffies;\r\nmutex_unlock(&devfreq->lock);\r\nmutex_lock(&devfreq_list_lock);\r\n}\r\nwait_remove_device = NULL;\r\nmutex_unlock(&devfreq_list_lock);\r\nif (next_jiffies > 0 && next_jiffies < ULONG_MAX) {\r\npolling = true;\r\nqueue_delayed_work(devfreq_wq, &devfreq_work, next_jiffies);\r\n} else {\r\npolling = false;\r\n}\r\n}\r\nstruct devfreq *devfreq_add_device(struct device *dev,\r\nstruct devfreq_dev_profile *profile,\r\nconst struct devfreq_governor *governor,\r\nvoid *data)\r\n{\r\nstruct devfreq *devfreq;\r\nint err = 0;\r\nif (!dev || !profile || !governor) {\r\ndev_err(dev, "%s: Invalid parameters.\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!governor->no_central_polling) {\r\nmutex_lock(&devfreq_list_lock);\r\ndevfreq = find_device_devfreq(dev);\r\nmutex_unlock(&devfreq_list_lock);\r\nif (!IS_ERR(devfreq)) {\r\ndev_err(dev, "%s: Unable to create devfreq for the device. It already has one.\n", __func__);\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\n}\r\ndevfreq = kzalloc(sizeof(struct devfreq), GFP_KERNEL);\r\nif (!devfreq) {\r\ndev_err(dev, "%s: Unable to create devfreq for the device\n",\r\n__func__);\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nmutex_init(&devfreq->lock);\r\nmutex_lock(&devfreq->lock);\r\ndevfreq->dev.parent = dev;\r\ndevfreq->dev.class = devfreq_class;\r\ndevfreq->dev.release = devfreq_dev_release;\r\ndevfreq->profile = profile;\r\ndevfreq->governor = governor;\r\ndevfreq->previous_freq = profile->initial_freq;\r\ndevfreq->data = data;\r\ndevfreq->next_polling = devfreq->polling_jiffies\r\n= msecs_to_jiffies(devfreq->profile->polling_ms);\r\ndevfreq->nb.notifier_call = devfreq_notifier_call;\r\ndev_set_name(&devfreq->dev, dev_name(dev));\r\nerr = device_register(&devfreq->dev);\r\nif (err) {\r\nput_device(&devfreq->dev);\r\ngoto err_dev;\r\n}\r\nif (governor->init)\r\nerr = governor->init(devfreq);\r\nif (err)\r\ngoto err_init;\r\nmutex_unlock(&devfreq->lock);\r\nif (governor->no_central_polling)\r\ngoto out;\r\nmutex_lock(&devfreq_list_lock);\r\nlist_add(&devfreq->node, &devfreq_list);\r\nif (devfreq_wq && devfreq->next_polling && !polling) {\r\npolling = true;\r\nqueue_delayed_work(devfreq_wq, &devfreq_work,\r\ndevfreq->next_polling);\r\n}\r\nmutex_unlock(&devfreq_list_lock);\r\nout:\r\nreturn devfreq;\r\nerr_init:\r\ndevice_unregister(&devfreq->dev);\r\nerr_dev:\r\nmutex_unlock(&devfreq->lock);\r\nkfree(devfreq);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nint devfreq_remove_device(struct devfreq *devfreq)\r\n{\r\nbool central_polling;\r\nif (!devfreq)\r\nreturn -EINVAL;\r\ncentral_polling = !devfreq->governor->no_central_polling;\r\nif (central_polling) {\r\nmutex_lock(&devfreq_list_lock);\r\nwhile (wait_remove_device == devfreq) {\r\nmutex_unlock(&devfreq_list_lock);\r\nschedule();\r\nmutex_lock(&devfreq_list_lock);\r\n}\r\n}\r\nmutex_lock(&devfreq->lock);\r\n_remove_devfreq(devfreq, false);\r\nif (central_polling)\r\nmutex_unlock(&devfreq_list_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_governor(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", to_devfreq(dev)->governor->name);\r\n}\r\nstatic ssize_t show_freq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", to_devfreq(dev)->previous_freq);\r\n}\r\nstatic ssize_t show_polling_interval(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", to_devfreq(dev)->profile->polling_ms);\r\n}\r\nstatic ssize_t store_polling_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nunsigned int value;\r\nint ret;\r\nret = sscanf(buf, "%u", &value);\r\nif (ret != 1)\r\ngoto out;\r\nmutex_lock(&df->lock);\r\ndf->profile->polling_ms = value;\r\ndf->next_polling = df->polling_jiffies\r\n= msecs_to_jiffies(value);\r\nmutex_unlock(&df->lock);\r\nret = count;\r\nif (df->governor->no_central_polling)\r\ngoto out;\r\nmutex_lock(&devfreq_list_lock);\r\nif (df->next_polling > 0 && !polling) {\r\npolling = true;\r\nqueue_delayed_work(devfreq_wq, &devfreq_work,\r\ndf->next_polling);\r\n}\r\nmutex_unlock(&devfreq_list_lock);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_central_polling(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n",\r\n!to_devfreq(dev)->governor->no_central_polling);\r\n}\r\nstatic ssize_t store_min_freq(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nunsigned long value;\r\nint ret;\r\nunsigned long max;\r\nret = sscanf(buf, "%lu", &value);\r\nif (ret != 1)\r\ngoto out;\r\nmutex_lock(&df->lock);\r\nmax = df->max_freq;\r\nif (value && max && value > max) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ndf->min_freq = value;\r\nupdate_devfreq(df);\r\nret = count;\r\nunlock:\r\nmutex_unlock(&df->lock);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_min_freq(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", to_devfreq(dev)->min_freq);\r\n}\r\nstatic ssize_t store_max_freq(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nunsigned long value;\r\nint ret;\r\nunsigned long min;\r\nret = sscanf(buf, "%lu", &value);\r\nif (ret != 1)\r\ngoto out;\r\nmutex_lock(&df->lock);\r\nmin = df->min_freq;\r\nif (value && min && value < min) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ndf->max_freq = value;\r\nupdate_devfreq(df);\r\nret = count;\r\nunlock:\r\nmutex_unlock(&df->lock);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_max_freq(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", to_devfreq(dev)->max_freq);\r\n}\r\nstatic int __init devfreq_start_polling(void)\r\n{\r\nmutex_lock(&devfreq_list_lock);\r\npolling = false;\r\ndevfreq_wq = create_freezable_workqueue("devfreq_wq");\r\nINIT_DELAYED_WORK_DEFERRABLE(&devfreq_work, devfreq_monitor);\r\nmutex_unlock(&devfreq_list_lock);\r\ndevfreq_monitor(&devfreq_work.work);\r\nreturn 0;\r\n}\r\nstatic int __init devfreq_init(void)\r\n{\r\ndevfreq_class = class_create(THIS_MODULE, "devfreq");\r\nif (IS_ERR(devfreq_class)) {\r\npr_err("%s: couldn't create class\n", __FILE__);\r\nreturn PTR_ERR(devfreq_class);\r\n}\r\ndevfreq_class->dev_attrs = devfreq_attrs;\r\nreturn 0;\r\n}\r\nstatic void __exit devfreq_exit(void)\r\n{\r\nclass_destroy(devfreq_class);\r\n}\r\nstruct opp *devfreq_recommended_opp(struct device *dev, unsigned long *freq,\r\nu32 flags)\r\n{\r\nstruct opp *opp;\r\nif (flags & DEVFREQ_FLAG_LEAST_UPPER_BOUND) {\r\nopp = opp_find_freq_floor(dev, freq);\r\nif (opp == ERR_PTR(-ENODEV))\r\nopp = opp_find_freq_ceil(dev, freq);\r\n} else {\r\nopp = opp_find_freq_ceil(dev, freq);\r\nif (opp == ERR_PTR(-ENODEV))\r\nopp = opp_find_freq_floor(dev, freq);\r\n}\r\nreturn opp;\r\n}\r\nint devfreq_register_opp_notifier(struct device *dev, struct devfreq *devfreq)\r\n{\r\nstruct srcu_notifier_head *nh = opp_get_notifier(dev);\r\nif (IS_ERR(nh))\r\nreturn PTR_ERR(nh);\r\nreturn srcu_notifier_chain_register(nh, &devfreq->nb);\r\n}\r\nint devfreq_unregister_opp_notifier(struct device *dev, struct devfreq *devfreq)\r\n{\r\nstruct srcu_notifier_head *nh = opp_get_notifier(dev);\r\nif (IS_ERR(nh))\r\nreturn PTR_ERR(nh);\r\nreturn srcu_notifier_chain_unregister(nh, &devfreq->nb);\r\n}
