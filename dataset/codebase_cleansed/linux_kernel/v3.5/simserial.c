static void receive_chars(struct tty_struct *tty)\r\n{\r\nunsigned char ch;\r\nstatic unsigned char seen_esc = 0;\r\nwhile ( (ch = ia64_ssc(0, 0, 0, 0, SSC_GETCHAR)) ) {\r\nif (ch == 27 && seen_esc == 0) {\r\nseen_esc = 1;\r\ncontinue;\r\n} else if (seen_esc == 1 && ch == 'O') {\r\nseen_esc = 2;\r\ncontinue;\r\n} else if (seen_esc == 2) {\r\nif (ch == 'P')\r\nshow_state();\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nif (ch == 'S') {\r\ndo {\r\nch = ia64_ssc(0, 0, 0, 0, SSC_GETCHAR);\r\n} while (!ch);\r\nhandle_sysrq(ch);\r\n}\r\n#endif\r\nseen_esc = 0;\r\ncontinue;\r\n}\r\nseen_esc = 0;\r\nif (tty_insert_flip_char(tty, ch, TTY_NORMAL) == 0)\r\nbreak;\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic irqreturn_t rs_interrupt_single(int irq, void *dev_id)\r\n{\r\nstruct serial_state *info = dev_id;\r\nstruct tty_struct *tty = tty_port_tty_get(&info->port);\r\nif (!tty) {\r\nprintk(KERN_INFO "%s: tty=0 problem\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nreceive_chars(tty);\r\ntty_kref_put(tty);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rs_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nif (!info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nif (CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE) == 0) {\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\ninfo->xmit.buf[info->xmit.head] = ch;\r\ninfo->xmit.head = (info->xmit.head + 1) & (SERIAL_XMIT_SIZE-1);\r\nlocal_irq_restore(flags);\r\nreturn 1;\r\n}\r\nstatic void transmit_chars(struct tty_struct *tty, struct serial_state *info,\r\nint *intr_done)\r\n{\r\nint count;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (info->x_char) {\r\nchar c = info->x_char;\r\nconsole->write(console, &c, 1);\r\ninfo->x_char = 0;\r\ngoto out;\r\n}\r\nif (info->xmit.head == info->xmit.tail || tty->stopped ||\r\ntty->hw_stopped) {\r\n#ifdef SIMSERIAL_DEBUG\r\nprintk("transmit_chars: head=%d, tail=%d, stopped=%d\n",\r\ninfo->xmit.head, info->xmit.tail, tty->stopped);\r\n#endif\r\ngoto out;\r\n}\r\ncount = min(CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE),\r\nSERIAL_XMIT_SIZE - info->xmit.tail);\r\nconsole->write(console, info->xmit.buf+info->xmit.tail, count);\r\ninfo->xmit.tail = (info->xmit.tail+count) & (SERIAL_XMIT_SIZE-1);\r\ncount = CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\nif (count) {\r\nconsole->write(console, info->xmit.buf, count);\r\ninfo->xmit.tail += count;\r\n}\r\nout:\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nif (info->xmit.head == info->xmit.tail || tty->stopped ||\r\ntty->hw_stopped || !info->xmit.buf)\r\nreturn;\r\ntransmit_chars(tty, info, NULL);\r\n}\r\nstatic int rs_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nint c, ret = 0;\r\nunsigned long flags;\r\nif (!info->xmit.buf)\r\nreturn 0;\r\nlocal_irq_save(flags);\r\nwhile (1) {\r\nc = CIRC_SPACE_TO_END(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\nif (count < c)\r\nc = count;\r\nif (c <= 0) {\r\nbreak;\r\n}\r\nmemcpy(info->xmit.buf + info->xmit.head, buf, c);\r\ninfo->xmit.head = ((info->xmit.head + c) &\r\n(SERIAL_XMIT_SIZE-1));\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nlocal_irq_restore(flags);\r\nif (CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE) &&\r\n!tty->stopped && !tty->hw_stopped)\r\ntransmit_chars(tty, info, NULL);\r\nreturn ret;\r\n}\r\nstatic int rs_write_room(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nreturn CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic int rs_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nreturn CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);\r\n}\r\nstatic void rs_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ninfo->xmit.head = info->xmit.tail = 0;\r\nlocal_irq_restore(flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void rs_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\ninfo->x_char = ch;\r\nif (ch) {\r\ntransmit_chars(tty, info, NULL);\r\n}\r\n}\r\nstatic void rs_throttle(struct tty_struct * tty)\r\n{\r\nif (I_IXOFF(tty))\r\nrs_send_xchar(tty, STOP_CHAR(tty));\r\nprintk(KERN_INFO "simrs_throttle called\n");\r\n}\r\nstatic void rs_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nif (I_IXOFF(tty)) {\r\nif (info->x_char)\r\ninfo->x_char = 0;\r\nelse\r\nrs_send_xchar(tty, START_CHAR(tty));\r\n}\r\nprintk(KERN_INFO "simrs_unthrottle called\n");\r\n}\r\nstatic int rs_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\r\n{\r\nif ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&\r\n(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&\r\n(cmd != TIOCMIWAIT)) {\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\n}\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\ncase TIOCSSERIAL:\r\ncase TIOCSERGSTRUCT:\r\ncase TIOCMIWAIT:\r\nreturn 0;\r\ncase TIOCSERCONFIG:\r\ncase TIOCSERGETLSR:\r\nreturn -EINVAL;\r\ncase TIOCSERGWILD:\r\ncase TIOCSERSWILD:\r\nprintk (KERN_INFO "TIOCSER?WILD ioctl obsolete, ignored.\n");\r\nreturn 0;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)\r\n{\r\nif ((old_termios->c_cflag & CRTSCTS) &&\r\n!(tty->termios->c_cflag & CRTSCTS)) {\r\ntty->hw_stopped = 0;\r\n}\r\n}\r\nstatic void shutdown(struct tty_port *port)\r\n{\r\nstruct serial_state *info = container_of(port, struct serial_state,\r\nport);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (info->irq)\r\nfree_irq(info->irq, info);\r\nif (info->xmit.buf) {\r\nfree_page((unsigned long) info->xmit.buf);\r\ninfo->xmit.buf = NULL;\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void rs_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\ntty_port_close(&info->port, tty, filp);\r\n}\r\nstatic void rs_hangup(struct tty_struct *tty)\r\n{\r\nstruct serial_state *info = tty->driver_data;\r\nrs_flush_buffer(tty);\r\ntty_port_hangup(&info->port);\r\n}\r\nstatic int activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct serial_state *state = container_of(port, struct serial_state,\r\nport);\r\nunsigned long flags, page;\r\nint retval = 0;\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nlocal_irq_save(flags);\r\nif (state->xmit.buf)\r\nfree_page(page);\r\nelse\r\nstate->xmit.buf = (unsigned char *) page;\r\nif (state->irq) {\r\nretval = request_irq(state->irq, rs_interrupt_single, 0,\r\n"simserial", state);\r\nif (retval)\r\ngoto errout;\r\n}\r\nstate->xmit.head = state->xmit.tail = 0;\r\nif ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)\r\ntty->alt_speed = 57600;\r\nif ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)\r\ntty->alt_speed = 115200;\r\nif ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)\r\ntty->alt_speed = 230400;\r\nif ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)\r\ntty->alt_speed = 460800;\r\nerrout:\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic int rs_open(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct serial_state *info = rs_table + tty->index;\r\nstruct tty_port *port = &info->port;\r\ntty->driver_data = info;\r\ntty->low_latency = (port->flags & ASYNC_LOW_LATENCY) ? 1 : 0;\r\nconsole = console_drivers;\r\nwhile (console) {\r\nif ((console->flags & CON_ENABLED) && console->write) break;\r\nconsole = console->next;\r\n}\r\nreturn tty_port_open(port, tty, filp);\r\n}\r\nstatic int rs_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nseq_printf(m, "simserinfo:1.0\n");\r\nfor (i = 0; i < NR_PORTS; i++)\r\nseq_printf(m, "%d: uart:16550 port:3F8 irq:%d\n",\r\ni, rs_table[i].irq);\r\nreturn 0;\r\n}\r\nstatic int rs_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, rs_proc_show, NULL);\r\n}\r\nstatic int __init simrs_init(void)\r\n{\r\nstruct serial_state *state;\r\nint retval;\r\nif (!ia64_platform_is("hpsim"))\r\nreturn -ENODEV;\r\nhp_simserial_driver = alloc_tty_driver(NR_PORTS);\r\nif (!hp_simserial_driver)\r\nreturn -ENOMEM;\r\nprintk(KERN_INFO "SimSerial driver with no serial options enabled\n");\r\nhp_simserial_driver->driver_name = "simserial";\r\nhp_simserial_driver->name = "ttyS";\r\nhp_simserial_driver->major = TTY_MAJOR;\r\nhp_simserial_driver->minor_start = 64;\r\nhp_simserial_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nhp_simserial_driver->subtype = SERIAL_TYPE_NORMAL;\r\nhp_simserial_driver->init_termios = tty_std_termios;\r\nhp_simserial_driver->init_termios.c_cflag =\r\nB9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nhp_simserial_driver->flags = TTY_DRIVER_REAL_RAW;\r\ntty_set_operations(hp_simserial_driver, &hp_ops);\r\nstate = rs_table;\r\ntty_port_init(&state->port);\r\nstate->port.ops = &hp_port_ops;\r\nstate->port.close_delay = 0;\r\nretval = hpsim_get_irq(KEYBOARD_INTR);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "%s: out of interrupt vectors!\n",\r\n__func__);\r\ngoto err_free_tty;\r\n}\r\nstate->irq = retval;\r\nprintk(KERN_INFO "ttyS0 at 0x03f8 (irq = %d) is a 16550\n", state->irq);\r\nretval = tty_register_driver(hp_simserial_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "Couldn't register simserial driver\n");\r\ngoto err_free_tty;\r\n}\r\nreturn 0;\r\nerr_free_tty:\r\nput_tty_driver(hp_simserial_driver);\r\nreturn retval;\r\n}
