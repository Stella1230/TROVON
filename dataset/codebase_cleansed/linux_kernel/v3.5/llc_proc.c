static void llc_ui_format_mac(struct seq_file *seq, u8 *addr)\r\n{\r\nseq_printf(seq, "%pM", addr);\r\n}\r\nstatic struct sock *llc_get_sk_idx(loff_t pos)\r\n{\r\nstruct llc_sap *sap;\r\nstruct sock *sk = NULL;\r\nint i;\r\nlist_for_each_entry_rcu(sap, &llc_sap_list, node) {\r\nspin_lock_bh(&sap->sk_lock);\r\nfor (i = 0; i < LLC_SK_LADDR_HASH_ENTRIES; i++) {\r\nstruct hlist_nulls_head *head = &sap->sk_laddr_hash[i];\r\nstruct hlist_nulls_node *node;\r\nsk_nulls_for_each(sk, node, head) {\r\nif (!pos)\r\ngoto found;\r\n--pos;\r\n}\r\n}\r\nspin_unlock_bh(&sap->sk_lock);\r\n}\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic void *llc_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nloff_t l = *pos;\r\nrcu_read_lock_bh();\r\nreturn l ? llc_get_sk_idx(--l) : SEQ_START_TOKEN;\r\n}\r\nstatic struct sock *laddr_hash_next(struct llc_sap *sap, int bucket)\r\n{\r\nstruct hlist_nulls_node *node;\r\nstruct sock *sk = NULL;\r\nwhile (++bucket < LLC_SK_LADDR_HASH_ENTRIES)\r\nsk_nulls_for_each(sk, node, &sap->sk_laddr_hash[bucket])\r\ngoto out;\r\nout:\r\nreturn sk;\r\n}\r\nstatic void *llc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct sock* sk, *next;\r\nstruct llc_sock *llc;\r\nstruct llc_sap *sap;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN) {\r\nsk = llc_get_sk_idx(0);\r\ngoto out;\r\n}\r\nsk = v;\r\nnext = sk_nulls_next(sk);\r\nif (next) {\r\nsk = next;\r\ngoto out;\r\n}\r\nllc = llc_sk(sk);\r\nsap = llc->sap;\r\nsk = laddr_hash_next(sap, llc_sk_laddr_hashfn(sap, &llc->laddr));\r\nif (sk)\r\ngoto out;\r\nspin_unlock_bh(&sap->sk_lock);\r\nlist_for_each_entry_continue_rcu(sap, &llc_sap_list, node) {\r\nspin_lock_bh(&sap->sk_lock);\r\nsk = laddr_hash_next(sap, -1);\r\nif (sk)\r\nbreak;\r\nspin_unlock_bh(&sap->sk_lock);\r\n}\r\nout:\r\nreturn sk;\r\n}\r\nstatic void llc_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nif (v && v != SEQ_START_TOKEN) {\r\nstruct sock *sk = v;\r\nstruct llc_sock *llc = llc_sk(sk);\r\nstruct llc_sap *sap = llc->sap;\r\nspin_unlock_bh(&sap->sk_lock);\r\n}\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int llc_seq_socket_show(struct seq_file *seq, void *v)\r\n{\r\nstruct sock* sk;\r\nstruct llc_sock *llc;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "SKt Mc local_mac_sap remote_mac_sap "\r\n" tx_queue rx_queue st uid link\n");\r\ngoto out;\r\n}\r\nsk = v;\r\nllc = llc_sk(sk);\r\nseq_printf(seq, "%2X %2X ", sk->sk_type, 0);\r\nif (llc->dev)\r\nllc_ui_format_mac(seq, llc->dev->dev_addr);\r\nelse {\r\nu8 addr[6] = {0,0,0,0,0,0};\r\nllc_ui_format_mac(seq, addr);\r\n}\r\nseq_printf(seq, "@%02X ", llc->sap->laddr.lsap);\r\nllc_ui_format_mac(seq, llc->daddr.mac);\r\nseq_printf(seq, "@%02X %8d %8d %2d %3d %4d\n", llc->daddr.lsap,\r\nsk_wmem_alloc_get(sk),\r\nsk_rmem_alloc_get(sk) - llc->copied_seq,\r\nsk->sk_state,\r\nsk->sk_socket ? SOCK_INODE(sk->sk_socket)->i_uid : -1,\r\nllc->link);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int llc_seq_core_show(struct seq_file *seq, void *v)\r\n{\r\nstruct sock* sk;\r\nstruct llc_sock *llc;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(seq, "Connection list:\n"\r\n"dsap state retr txw rxw pf ff sf df rs cs "\r\n"tack tpfc trs tbs blog busr\n");\r\ngoto out;\r\n}\r\nsk = v;\r\nllc = llc_sk(sk);\r\nseq_printf(seq, " %02X %-10s %3d %3d %3d %2d %2d %2d %2d %2d %2d "\r\n"%4d %4d %3d %3d %4d %4d\n",\r\nllc->daddr.lsap, llc_conn_state_names[llc->state],\r\nllc->retry_count, llc->k, llc->rw, llc->p_flag, llc->f_flag,\r\nllc->s_flag, llc->data_flag, llc->remote_busy_flag,\r\nllc->cause_flag, timer_pending(&llc->ack_timer.timer),\r\ntimer_pending(&llc->pf_cycle_timer.timer),\r\ntimer_pending(&llc->rej_sent_timer.timer),\r\ntimer_pending(&llc->busy_state_timer.timer),\r\n!!sk->sk_backlog.tail, !!sock_owned_by_user(sk));\r\nout:\r\nreturn 0;\r\n}\r\nstatic int llc_seq_socket_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &llc_seq_socket_ops);\r\n}\r\nstatic int llc_seq_core_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &llc_seq_core_ops);\r\n}\r\nint __init llc_proc_init(void)\r\n{\r\nint rc = -ENOMEM;\r\nstruct proc_dir_entry *p;\r\nllc_proc_dir = proc_mkdir("llc", init_net.proc_net);\r\nif (!llc_proc_dir)\r\ngoto out;\r\np = proc_create("socket", S_IRUGO, llc_proc_dir, &llc_seq_socket_fops);\r\nif (!p)\r\ngoto out_socket;\r\np = proc_create("core", S_IRUGO, llc_proc_dir, &llc_seq_core_fops);\r\nif (!p)\r\ngoto out_core;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nout_core:\r\nremove_proc_entry("socket", llc_proc_dir);\r\nout_socket:\r\nremove_proc_entry("llc", init_net.proc_net);\r\ngoto out;\r\n}\r\nvoid llc_proc_exit(void)\r\n{\r\nremove_proc_entry("socket", llc_proc_dir);\r\nremove_proc_entry("core", llc_proc_dir);\r\nremove_proc_entry("llc", init_net.proc_net);\r\n}
