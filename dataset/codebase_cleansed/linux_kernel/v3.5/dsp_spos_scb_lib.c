static void remove_symbol (struct snd_cs46xx * chip, struct dsp_symbol_entry * symbol)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nint symbol_index = (int)(symbol - ins->symbol_table.symbols);\r\nif (snd_BUG_ON(ins->symbol_table.nsymbols <= 0))\r\nreturn;\r\nif (snd_BUG_ON(symbol_index < 0 ||\r\nsymbol_index >= ins->symbol_table.nsymbols))\r\nreturn;\r\nins->symbol_table.symbols[symbol_index].deleted = 1;\r\nif (symbol_index < ins->symbol_table.highest_frag_index) {\r\nins->symbol_table.highest_frag_index = symbol_index;\r\n}\r\nif (symbol_index == ins->symbol_table.nsymbols - 1)\r\nins->symbol_table.nsymbols --;\r\nif (ins->symbol_table.highest_frag_index > ins->symbol_table.nsymbols) {\r\nins->symbol_table.highest_frag_index = ins->symbol_table.nsymbols;\r\n}\r\n}\r\nstatic void cs46xx_dsp_proc_scb_info_read (struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct proc_scb_info * scb_info = entry->private_data;\r\nstruct dsp_scb_descriptor * scb = scb_info->scb_desc;\r\nstruct dsp_spos_instance * ins;\r\nstruct snd_cs46xx *chip = scb_info->chip;\r\nint j,col;\r\nvoid __iomem *dst = chip->region.idx[1].remap_addr + DSP_PARAMETER_BYTE_OFFSET;\r\nins = chip->dsp_spos_instance;\r\nmutex_lock(&chip->spos_mutex);\r\nsnd_iprintf(buffer,"%04x %s:\n",scb->address,scb->scb_name);\r\nfor (col = 0,j = 0;j < 0x10; j++,col++) {\r\nif (col == 4) {\r\nsnd_iprintf(buffer,"\n");\r\ncol = 0;\r\n}\r\nsnd_iprintf(buffer,"%08x ",readl(dst + (scb->address + j) * sizeof(u32)));\r\n}\r\nsnd_iprintf(buffer,"\n");\r\nif (scb->parent_scb_ptr != NULL) {\r\nsnd_iprintf(buffer,"parent [%s:%04x] ",\r\nscb->parent_scb_ptr->scb_name,\r\nscb->parent_scb_ptr->address);\r\n} else snd_iprintf(buffer,"parent [none] ");\r\nsnd_iprintf(buffer,"sub_list_ptr [%s:%04x]\nnext_scb_ptr [%s:%04x] task_entry [%s:%04x]\n",\r\nscb->sub_list_ptr->scb_name,\r\nscb->sub_list_ptr->address,\r\nscb->next_scb_ptr->scb_name,\r\nscb->next_scb_ptr->address,\r\nscb->task_entry->symbol_name,\r\nscb->task_entry->address);\r\nsnd_iprintf(buffer,"index [%d] ref_count [%d]\n",scb->index,scb->ref_count);\r\nmutex_unlock(&chip->spos_mutex);\r\n}\r\nstatic void _dsp_unlink_scb (struct snd_cs46xx *chip, struct dsp_scb_descriptor * scb)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif ( scb->parent_scb_ptr ) {\r\nif (snd_BUG_ON(scb->parent_scb_ptr->sub_list_ptr != scb &&\r\nscb->parent_scb_ptr->next_scb_ptr != scb))\r\nreturn;\r\nif (scb->parent_scb_ptr->sub_list_ptr == scb) {\r\nif (scb->next_scb_ptr == ins->the_null_scb) {\r\nscb->parent_scb_ptr->sub_list_ptr = scb->sub_list_ptr;\r\nif (scb->sub_list_ptr != ins->the_null_scb) {\r\nscb->sub_list_ptr->parent_scb_ptr = scb->parent_scb_ptr;\r\n}\r\nscb->sub_list_ptr = ins->the_null_scb;\r\n} else {\r\nscb->parent_scb_ptr->sub_list_ptr = scb->next_scb_ptr;\r\nif (scb->next_scb_ptr != ins->the_null_scb) {\r\nscb->next_scb_ptr->parent_scb_ptr = scb->parent_scb_ptr;\r\n}\r\nscb->next_scb_ptr = ins->the_null_scb;\r\n}\r\n} else {\r\nscb->parent_scb_ptr->next_scb_ptr = scb->next_scb_ptr;\r\nif (scb->next_scb_ptr != ins->the_null_scb) {\r\nscb->next_scb_ptr->parent_scb_ptr = scb->parent_scb_ptr;\r\n}\r\nscb->next_scb_ptr = ins->the_null_scb;\r\n}\r\ncs46xx_dsp_spos_update_scb(chip,scb->parent_scb_ptr);\r\ncs46xx_dsp_spos_update_scb(chip,scb);\r\nscb->parent_scb_ptr = NULL;\r\n}\r\n}\r\nstatic void _dsp_clear_sample_buffer (struct snd_cs46xx *chip, u32 sample_buffer_addr,\r\nint dword_count)\r\n{\r\nvoid __iomem *dst = chip->region.idx[2].remap_addr + sample_buffer_addr;\r\nint i;\r\nfor (i = 0; i < dword_count ; ++i ) {\r\nwritel(0, dst);\r\ndst += 4;\r\n}\r\n}\r\nvoid cs46xx_dsp_remove_scb (struct snd_cs46xx *chip, struct dsp_scb_descriptor * scb)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nunsigned long flags;\r\nif (snd_BUG_ON(scb->index < 0 ||\r\nscb->index >= ins->nscb ||\r\n(ins->scbs + scb->index) != scb))\r\nreturn;\r\n#if 0\r\nif (snd_BUG_ON(scb->sub_list_ptr != ins->the_null_scb ||\r\nscb->next_scb_ptr != ins->the_null_scb))\r\ngoto _end;\r\n#endif\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n_dsp_unlink_scb (chip,scb);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\ncs46xx_dsp_proc_free_scb_desc(scb);\r\nif (snd_BUG_ON(!scb->scb_symbol))\r\nreturn;\r\nremove_symbol (chip,scb->scb_symbol);\r\nins->scbs[scb->index].deleted = 1;\r\n#ifdef CONFIG_PM\r\nkfree(ins->scbs[scb->index].data);\r\nins->scbs[scb->index].data = NULL;\r\n#endif\r\nif (scb->index < ins->scb_highest_frag_index)\r\nins->scb_highest_frag_index = scb->index;\r\nif (scb->index == ins->nscb - 1) {\r\nins->nscb --;\r\n}\r\nif (ins->scb_highest_frag_index > ins->nscb) {\r\nins->scb_highest_frag_index = ins->nscb;\r\n}\r\n#if 0\r\nfor(i = scb->index + 1;i < ins->nscb; ++i) {\r\nins->scbs[i - 1].index = i - 1;\r\n}\r\n#endif\r\n}\r\nvoid cs46xx_dsp_proc_free_scb_desc (struct dsp_scb_descriptor * scb)\r\n{\r\nif (scb->proc_info) {\r\nstruct proc_scb_info * scb_info = scb->proc_info->private_data;\r\nsnd_printdd("cs46xx_dsp_proc_free_scb_desc: freeing %s\n",scb->scb_name);\r\nsnd_info_free_entry(scb->proc_info);\r\nscb->proc_info = NULL;\r\nkfree (scb_info);\r\n}\r\n}\r\nvoid cs46xx_dsp_proc_register_scb_desc (struct snd_cs46xx *chip,\r\nstruct dsp_scb_descriptor * scb)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct snd_info_entry * entry;\r\nstruct proc_scb_info * scb_info;\r\nif (ins->snd_card != NULL && ins->proc_dsp_dir != NULL &&\r\nscb->proc_info == NULL) {\r\nif ((entry = snd_info_create_card_entry(ins->snd_card, scb->scb_name,\r\nins->proc_dsp_dir)) != NULL) {\r\nscb_info = kmalloc(sizeof(struct proc_scb_info), GFP_KERNEL);\r\nif (!scb_info) {\r\nsnd_info_free_entry(entry);\r\nentry = NULL;\r\ngoto out;\r\n}\r\nscb_info->chip = chip;\r\nscb_info->scb_desc = scb;\r\nentry->content = SNDRV_INFO_CONTENT_TEXT;\r\nentry->private_data = scb_info;\r\nentry->mode = S_IFREG | S_IRUGO | S_IWUSR;\r\nentry->c.text.read = cs46xx_dsp_proc_scb_info_read;\r\nif (snd_info_register(entry) < 0) {\r\nsnd_info_free_entry(entry);\r\nkfree (scb_info);\r\nentry = NULL;\r\n}\r\n}\r\nout:\r\nscb->proc_info = entry;\r\n}\r\n}\r\nstatic struct dsp_scb_descriptor *\r\n_dsp_create_generic_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data, u32 dest,\r\nstruct dsp_symbol_entry * task_entry,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * scb;\r\nunsigned long flags;\r\nif (snd_BUG_ON(!ins->the_null_scb))\r\nreturn NULL;\r\nscb_data[SCBsubListPtr] =\r\n(ins->the_null_scb->address << 0x10) | ins->the_null_scb->address;\r\nscb_data[SCBfuncEntryPtr] &= 0xFFFF0000;\r\nscb_data[SCBfuncEntryPtr] |= task_entry->address;\r\nsnd_printdd("dsp_spos: creating SCB <%s>\n",name);\r\nscb = cs46xx_dsp_create_scb(chip,name,scb_data,dest);\r\nscb->sub_list_ptr = ins->the_null_scb;\r\nscb->next_scb_ptr = ins->the_null_scb;\r\nscb->parent_scb_ptr = parent_scb;\r\nscb->task_entry = task_entry;\r\nif (scb->parent_scb_ptr) {\r\n#if 0\r\nprintk ("scb->parent_scb_ptr = %s\n",scb->parent_scb_ptr->scb_name);\r\nprintk ("scb->parent_scb_ptr->next_scb_ptr = %s\n",scb->parent_scb_ptr->next_scb_ptr->scb_name);\r\nprintk ("scb->parent_scb_ptr->sub_list_ptr = %s\n",scb->parent_scb_ptr->sub_list_ptr->scb_name);\r\n#endif\r\nif (scb_child_type == SCB_ON_PARENT_NEXT_SCB) {\r\nif (snd_BUG_ON(scb->parent_scb_ptr->next_scb_ptr !=\r\nins->the_null_scb))\r\nreturn NULL;\r\nscb->parent_scb_ptr->next_scb_ptr = scb;\r\n} else if (scb_child_type == SCB_ON_PARENT_SUBLIST_SCB) {\r\nif (snd_BUG_ON(scb->parent_scb_ptr->sub_list_ptr !=\r\nins->the_null_scb))\r\nreturn NULL;\r\nscb->parent_scb_ptr->sub_list_ptr = scb;\r\n} else {\r\nsnd_BUG();\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\ncs46xx_dsp_spos_update_scb(chip,scb->parent_scb_ptr);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\ncs46xx_dsp_proc_register_scb_desc (chip,scb);\r\nreturn scb;\r\n}\r\nstatic struct dsp_scb_descriptor *\r\ncs46xx_dsp_create_generic_scb (struct snd_cs46xx *chip, char * name, u32 * scb_data,\r\nu32 dest, char * task_entry_name,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_symbol_entry * task_entry;\r\ntask_entry = cs46xx_dsp_lookup_symbol (chip,task_entry_name,\r\nSYMBOL_CODE);\r\nif (task_entry == NULL) {\r\nsnd_printk (KERN_ERR "dsp_spos: symbol %s not found\n",task_entry_name);\r\nreturn NULL;\r\n}\r\nreturn _dsp_create_generic_scb (chip,name,scb_data,dest,task_entry,\r\nparent_scb,scb_child_type);\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_timing_master_scb (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_timing_master_scb timing_master_scb = {\r\n{ 0,\r\n0,\r\n0,\r\n0\r\n},\r\n{ 0,\r\n0,\r\n0,\r\n0,\r\n0\r\n},\r\n0,0,\r\n0,NULL_SCB_ADDR,\r\n0,0,\r\n0,0,\r\n0x0001,0x8000,\r\n0x0001,0x0000,\r\n0x00060000\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,"TimingMasterSCBInst",(u32 *)&timing_master_scb,\r\nTIMINGMASTER_SCB_ADDR,\r\n"TIMINGMASTER",NULL,SCB_NO_PARENT);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_codec_out_scb(struct snd_cs46xx * chip, char * codec_name,\r\nu16 channel_disp, u16 fifo_addr, u16 child_scb_addr,\r\nu32 dest, struct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_codec_output_scb codec_out_scb = {\r\n{ 0,\r\n0,\r\n0,\r\n0\r\n},\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0\r\n},\r\n0,0,\r\n0,NULL_SCB_ADDR,\r\n0,\r\n0,\r\nchannel_disp,fifo_addr,\r\n0x0000,0x0080,\r\n0,child_scb_addr\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,codec_name,(u32 *)&codec_out_scb,\r\ndest,"S16_CODECOUTPUTTASK",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_codec_in_scb(struct snd_cs46xx * chip, char * codec_name,\r\nu16 channel_disp, u16 fifo_addr, u16 sample_buffer_addr,\r\nu32 dest, struct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_codec_input_scb codec_input_scb = {\r\n{ 0,\r\n0,\r\n0,\r\n0\r\n},\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0\r\n},\r\n#if 0\r\nSyncIOSCB,NULL_SCB_ADDR\r\n#else\r\n0 , 0,\r\n#endif\r\n0,0,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,\r\nsample_buffer_addr << 0x10,\r\nchannel_disp,fifo_addr,\r\n0x0000,0x0000,\r\n0x80008000\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,codec_name,(u32 *)&codec_input_scb,\r\ndest,"S16_CODECINPUTTASK",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstatic struct dsp_scb_descriptor *\r\ncs46xx_dsp_create_pcm_reader_scb(struct snd_cs46xx * chip, char * scb_name,\r\nu16 sample_buffer_addr, u32 dest,\r\nint virtual_channel, u32 playback_hw_addr,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_generic_scb pcm_reader_scb = {\r\n{ DMA_RQ_C1_SOURCE_ON_HOST +\r\nDMA_RQ_C1_SOURCE_MOD1024 +\r\nDMA_RQ_C1_DEST_MOD32 +\r\nDMA_RQ_C1_WRITEBACK_SRC_FLAG +\r\nDMA_RQ_C1_WRITEBACK_DEST_FLAG +\r\n15,\r\nDMA_RQ_C2_AC_NONE +\r\nDMA_RQ_C2_SIGNAL_SOURCE_PINGPONG +\r\nvirtual_channel,\r\nplayback_hw_addr,\r\nDMA_RQ_SD_SP_SAMPLE_ADDR +\r\nsample_buffer_addr\r\n},\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0\r\n},\r\nNULL_SCB_ADDR,NULL_SCB_ADDR,\r\n0,NULL_SCB_ADDR,\r\nRSCONFIG_DMA_ENABLE +\r\n(19 << RSCONFIG_MAX_DMA_SIZE_SHIFT) +\r\n((dest >> 4) << RSCONFIG_STREAM_NUM_SHIFT) +\r\nRSCONFIG_SAMPLE_16STEREO +\r\nRSCONFIG_MODULO_32,\r\n(sample_buffer_addr << 0x10),\r\n0,\r\n{\r\n0xffff,0xffff,\r\n0xffff,0xffff\r\n}\r\n};\r\nif (ins->null_algorithm == NULL) {\r\nins->null_algorithm = cs46xx_dsp_lookup_symbol (chip,"NULLALGORITHM",\r\nSYMBOL_CODE);\r\nif (ins->null_algorithm == NULL) {\r\nsnd_printk (KERN_ERR "dsp_spos: symbol NULLALGORITHM not found\n");\r\nreturn NULL;\r\n}\r\n}\r\nscb = _dsp_create_generic_scb(chip,scb_name,(u32 *)&pcm_reader_scb,\r\ndest,ins->null_algorithm,parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_src_task_scb(struct snd_cs46xx * chip, char * scb_name,\r\nint rate,\r\nu16 src_buffer_addr,\r\nu16 src_delay_buffer_addr, u32 dest,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type,\r\nint pass_through)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * scb;\r\nunsigned int tmp1, tmp2;\r\nunsigned int phiIncr;\r\nunsigned int correctionPerGOF, correctionPerSec;\r\nsnd_printdd( "dsp_spos: setting %s rate to %u\n",scb_name,rate);\r\ntmp1 = rate << 16;\r\nphiIncr = tmp1 / 48000;\r\ntmp1 -= phiIncr * 48000;\r\ntmp1 <<= 10;\r\nphiIncr <<= 10;\r\ntmp2 = tmp1 / 48000;\r\nphiIncr += tmp2;\r\ntmp1 -= tmp2 * 48000;\r\ncorrectionPerGOF = tmp1 / GOF_PER_SEC;\r\ntmp1 -= correctionPerGOF * GOF_PER_SEC;\r\ncorrectionPerSec = tmp1;\r\n{\r\nstruct dsp_src_task_scb src_task_scb = {\r\n0x0028,0x00c8,\r\n0x5555,0x0000,\r\n0x0000,0x0000,\r\nsrc_buffer_addr,1,\r\ncorrectionPerGOF,correctionPerSec,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_32,\r\n0x0000,src_delay_buffer_addr,\r\n0x0,\r\n0x080,(src_delay_buffer_addr + (24 * 4)),\r\n0,0,\r\n0,0,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_8,\r\nsrc_buffer_addr << 0x10,\r\nphiIncr,\r\n{\r\n0xffff - ins->dac_volume_right,0xffff - ins->dac_volume_left,\r\n0xffff - ins->dac_volume_right,0xffff - ins->dac_volume_left\r\n}\r\n};\r\nif (ins->s16_up == NULL) {\r\nins->s16_up = cs46xx_dsp_lookup_symbol (chip,"S16_UPSRC",\r\nSYMBOL_CODE);\r\nif (ins->s16_up == NULL) {\r\nsnd_printk (KERN_ERR "dsp_spos: symbol S16_UPSRC not found\n");\r\nreturn NULL;\r\n}\r\n}\r\n_dsp_clear_sample_buffer (chip,src_buffer_addr,8);\r\n_dsp_clear_sample_buffer (chip,src_delay_buffer_addr,32);\r\nif (pass_through) {\r\nsnd_BUG_ON(rate != 48000);\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&src_task_scb,\r\ndest,"DMAREADER",parent_scb,\r\nscb_child_type);\r\n} else {\r\nscb = _dsp_create_generic_scb(chip,scb_name,(u32 *)&src_task_scb,\r\ndest,ins->s16_up,parent_scb,\r\nscb_child_type);\r\n}\r\n}\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_mix_only_scb(struct snd_cs46xx * chip, char * scb_name,\r\nu16 mix_buffer_addr, u32 dest,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_mix_only_scb master_mix_scb = {\r\n{ 0,\r\n0,\r\nmix_buffer_addr,\r\n0\r\n},\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0x00000080\r\n},\r\n0,0,\r\n0,0,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_32,\r\n(mix_buffer_addr + (16 * 4)) << 0x10,\r\n0,\r\n{\r\n0x8000,0x8000,\r\n0x8000,0x8000\r\n}\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&master_mix_scb,\r\ndest,"S16_MIX",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_mix_to_ostream_scb(struct snd_cs46xx * chip, char * scb_name,\r\nu16 mix_buffer_addr, u16 writeback_spb, u32 dest,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_mix2_ostream_scb mix2_ostream_scb = {\r\n{\r\nDMA_RQ_C1_SOURCE_MOD64 +\r\nDMA_RQ_C1_DEST_ON_HOST +\r\nDMA_RQ_C1_DEST_MOD1024 +\r\nDMA_RQ_C1_WRITEBACK_SRC_FLAG +\r\nDMA_RQ_C1_WRITEBACK_DEST_FLAG +\r\n15,\r\nDMA_RQ_C2_AC_NONE +\r\nDMA_RQ_C2_SIGNAL_DEST_PINGPONG +\r\nCS46XX_DSP_CAPTURE_CHANNEL,\r\nDMA_RQ_SD_SP_SAMPLE_ADDR +\r\nmix_buffer_addr,\r\n0x0\r\n},\r\n{ 0, 0, 0, 0, 0, },\r\n0,0,\r\n0,writeback_spb,\r\nRSCONFIG_DMA_ENABLE +\r\n(19 << RSCONFIG_MAX_DMA_SIZE_SHIFT) +\r\n((dest >> 4) << RSCONFIG_STREAM_NUM_SHIFT) +\r\nRSCONFIG_DMA_TO_HOST +\r\nRSCONFIG_SAMPLE_16STEREO +\r\nRSCONFIG_MODULO_64,\r\n(mix_buffer_addr + (32 * 4)) << 0x10,\r\n1,0,\r\n0x0001,0x0080,\r\n0xFFFF,0\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&mix2_ostream_scb,\r\ndest,"S16_MIX_TO_OSTREAM",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_vari_decimate_scb(struct snd_cs46xx * chip,char * scb_name,\r\nu16 vari_buffer_addr0,\r\nu16 vari_buffer_addr1,\r\nu32 dest,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_vari_decimate_scb vari_decimate_scb = {\r\n0x0028,0x00c8,\r\n0x5555,0x0000,\r\n0x0000,0x0000,\r\nvari_buffer_addr0,vari_buffer_addr1,\r\n0x0028,0x00c8,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_256,\r\n0xFF800000,\r\n0,\r\n0x0080,vari_buffer_addr1 + (25 * 4),\r\n0,0,\r\n0,0,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_8,\r\nvari_buffer_addr0 << 0x10,\r\n0x04000000,\r\n{\r\n0x8000,0x8000,\r\n0xFFFF,0xFFFF\r\n}\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&vari_decimate_scb,\r\ndest,"VARIDECIMATE",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstatic struct dsp_scb_descriptor *\r\ncs46xx_dsp_create_pcm_serial_input_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\r\nstruct dsp_scb_descriptor * input_scb,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_pcm_serial_input_scb pcm_serial_input_scb = {\r\n{ 0,\r\n0,\r\n0,\r\n0\r\n},\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0\r\n},\r\n0,0,\r\n0,0,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_16,\r\n0,\r\n0,input_scb->address,\r\n{\r\n0x8000,0x8000,\r\n0x8000,0x8000\r\n}\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&pcm_serial_input_scb,\r\ndest,"PCMSERIALINPUTTASK",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstatic struct dsp_scb_descriptor *\r\ncs46xx_dsp_create_asynch_fg_tx_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\r\nu16 hfg_scb_address,\r\nu16 asynch_buffer_address,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_asynch_fg_tx_scb asynch_fg_tx_scb = {\r\n0xfc00,0x03ff,\r\n0x0058,0x0028,\r\n0,hfg_scb_address,\r\n0,0,\r\n0,\r\n0,0x2aab,\r\n{\r\n0,\r\n0,\r\n0\r\n},\r\n0,0,\r\n0,dest + AFGTxAccumPhi,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_256,\r\n(asynch_buffer_address) << 0x10,\r\n0x18000000,\r\n0x8000,0x8000,\r\n0x8000,0x8000\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&asynch_fg_tx_scb,\r\ndest,"ASYNCHFGTXCODE",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_asynch_fg_rx_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\r\nu16 hfg_scb_address,\r\nu16 asynch_buffer_address,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_asynch_fg_rx_scb asynch_fg_rx_scb = {\r\n0xfe00,0x01ff,\r\n0x0064,0x001c,\r\n0,hfg_scb_address,\r\n0,0,\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0\r\n},\r\n0,0,\r\n0,dest,\r\nRSCONFIG_MODULO_128 |\r\nRSCONFIG_SAMPLE_16STEREO,\r\n( (asynch_buffer_address + (16 * 4)) << 0x10),\r\n0x18000000,\r\n0xffff - ins->spdif_input_volume_right,0xffff - ins->spdif_input_volume_left,\r\n0xffff - ins->spdif_input_volume_right,0xffff - ins->spdif_input_volume_left,\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&asynch_fg_rx_scb,\r\ndest,"ASYNCHFGRXCODE",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_spio_write_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_spio_write_scb spio_write_scb = {\r\n0,0,\r\n0,\r\n0,\r\n0,0,\r\n0,\r\n0,\r\n0,0,\r\n{ 0,0 },\r\n0,0,\r\n0,0,\r\n{\r\n0,\r\n0,\r\n0,\r\n0,\r\n0\r\n}\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&spio_write_scb,\r\ndest,"SPIOWRITE",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_dsp_create_magic_snoop_scb(struct snd_cs46xx * chip, char * scb_name, u32 dest,\r\nu16 snoop_buffer_address,\r\nstruct dsp_scb_descriptor * snoop_scb,\r\nstruct dsp_scb_descriptor * parent_scb,\r\nint scb_child_type)\r\n{\r\nstruct dsp_scb_descriptor * scb;\r\nstruct dsp_magic_snoop_task magic_snoop_scb = {\r\n0,\r\n0,\r\nsnoop_buffer_address << 0x10,\r\n0,snoop_scb->address,\r\n0,\r\n0,\r\n0,\r\n0,\r\n0,\r\n0,0,\r\n0,0,\r\nRSCONFIG_SAMPLE_16STEREO + RSCONFIG_MODULO_64,\r\nsnoop_buffer_address << 0x10,\r\n0,\r\n{ 0x8000,0x8000,\r\n0xffff,0xffff\r\n}\r\n};\r\nscb = cs46xx_dsp_create_generic_scb(chip,scb_name,(u32 *)&magic_snoop_scb,\r\ndest,"MAGICSNOOPTASK",parent_scb,\r\nscb_child_type);\r\nreturn scb;\r\n}\r\nstatic struct dsp_scb_descriptor *\r\nfind_next_free_scb (struct snd_cs46xx * chip, struct dsp_scb_descriptor * from)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * scb = from;\r\nwhile (scb->next_scb_ptr != ins->the_null_scb) {\r\nif (snd_BUG_ON(!scb->next_scb_ptr))\r\nreturn NULL;\r\nscb = scb->next_scb_ptr;\r\n}\r\nreturn scb;\r\n}\r\nstruct dsp_pcm_channel_descriptor *\r\ncs46xx_dsp_create_pcm_channel (struct snd_cs46xx * chip,\r\nu32 sample_rate, void * private_data,\r\nu32 hw_dma_addr,\r\nint pcm_channel_id)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * src_scb = NULL, * pcm_scb, * mixer_scb = NULL;\r\nstruct dsp_scb_descriptor * src_parent_scb = NULL;\r\nchar scb_name[DSP_MAX_SCB_NAME];\r\nint i, pcm_index = -1, insert_point, src_index = -1, pass_through = 0;\r\nunsigned long flags;\r\nswitch (pcm_channel_id) {\r\ncase DSP_PCM_MAIN_CHANNEL:\r\nmixer_scb = ins->master_mix_scb;\r\nbreak;\r\ncase DSP_PCM_REAR_CHANNEL:\r\nmixer_scb = ins->rear_mix_scb;\r\nbreak;\r\ncase DSP_PCM_CENTER_LFE_CHANNEL:\r\nmixer_scb = ins->center_lfe_mix_scb;\r\nbreak;\r\ncase DSP_PCM_S71_CHANNEL:\r\nsnd_BUG();\r\nbreak;\r\ncase DSP_IEC958_CHANNEL:\r\nif (snd_BUG_ON(!ins->asynch_tx_scb))\r\nreturn NULL;\r\nmixer_scb = ins->asynch_tx_scb;\r\nif (sample_rate == 48000) {\r\nsnd_printdd ("IEC958 pass through\n");\r\npass_through = 1;\r\n}\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn NULL;\r\n}\r\nif (!sample_rate) sample_rate = 44100;\r\nfor (i = 0; i < DSP_MAX_PCM_CHANNELS &&\r\n(pcm_index == -1 || src_scb == NULL); ++i) {\r\nif (i == CS46XX_DSP_CAPTURE_CHANNEL) continue;\r\nif (ins->pcm_channels[i].active) {\r\nif (!src_scb &&\r\nins->pcm_channels[i].sample_rate == sample_rate &&\r\nins->pcm_channels[i].mixer_scb == mixer_scb) {\r\nsrc_scb = ins->pcm_channels[i].src_scb;\r\nins->pcm_channels[i].src_scb->ref_count ++;\r\nsrc_index = ins->pcm_channels[i].src_slot;\r\n}\r\n} else if (pcm_index == -1) {\r\npcm_index = i;\r\n}\r\n}\r\nif (pcm_index == -1) {\r\nsnd_printk (KERN_ERR "dsp_spos: no free PCM channel\n");\r\nreturn NULL;\r\n}\r\nif (src_scb == NULL) {\r\nif (ins->nsrc_scb >= DSP_MAX_SRC_NR) {\r\nsnd_printk(KERN_ERR "dsp_spos: to many SRC instances\n!");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < DSP_MAX_SRC_NR; ++i) {\r\nif (ins->src_scb_slots[i] == 0) {\r\nsrc_index = i;\r\nins->src_scb_slots[i] = 1;\r\nbreak;\r\n}\r\n}\r\nif (snd_BUG_ON(src_index == -1))\r\nreturn NULL;\r\nif (mixer_scb->sub_list_ptr == ins->the_null_scb) {\r\nsrc_parent_scb = mixer_scb;\r\ninsert_point = SCB_ON_PARENT_SUBLIST_SCB;\r\n} else {\r\nsrc_parent_scb = find_next_free_scb(chip,mixer_scb->sub_list_ptr);\r\ninsert_point = SCB_ON_PARENT_NEXT_SCB;\r\n}\r\nsnprintf (scb_name,DSP_MAX_SCB_NAME,"SrcTask_SCB%d",src_index);\r\nsnd_printdd( "dsp_spos: creating SRC \"%s\"\n",scb_name);\r\nsrc_scb = cs46xx_dsp_create_src_task_scb(chip,scb_name,\r\nsample_rate,\r\nsrc_output_buffer_addr[src_index],\r\nsrc_delay_buffer_addr[src_index],\r\n0x400 + (src_index * 0x10) ,\r\nsrc_parent_scb,\r\ninsert_point,\r\npass_through);\r\nif (!src_scb) {\r\nsnd_printk (KERN_ERR "dsp_spos: failed to create SRCtaskSCB\n");\r\nreturn NULL;\r\n}\r\nins->nsrc_scb ++;\r\n}\r\nsnprintf (scb_name,DSP_MAX_SCB_NAME,"PCMReader_SCB%d",pcm_index);\r\nsnd_printdd( "dsp_spos: creating PCM \"%s\" (%d)\n",scb_name,\r\npcm_channel_id);\r\npcm_scb = cs46xx_dsp_create_pcm_reader_scb(chip,scb_name,\r\npcm_reader_buffer_addr[pcm_index],\r\n(pcm_index * 0x10) + 0x200,\r\npcm_index,\r\nhw_dma_addr,\r\nNULL,\r\n0\r\n);\r\nif (!pcm_scb) {\r\nsnd_printk (KERN_ERR "dsp_spos: failed to create PCMreaderSCB\n");\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nins->pcm_channels[pcm_index].sample_rate = sample_rate;\r\nins->pcm_channels[pcm_index].pcm_reader_scb = pcm_scb;\r\nins->pcm_channels[pcm_index].src_scb = src_scb;\r\nins->pcm_channels[pcm_index].unlinked = 1;\r\nins->pcm_channels[pcm_index].private_data = private_data;\r\nins->pcm_channels[pcm_index].src_slot = src_index;\r\nins->pcm_channels[pcm_index].active = 1;\r\nins->pcm_channels[pcm_index].pcm_slot = pcm_index;\r\nins->pcm_channels[pcm_index].mixer_scb = mixer_scb;\r\nins->npcm_channels ++;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn (ins->pcm_channels + pcm_index);\r\n}\r\nint cs46xx_dsp_pcm_channel_set_period (struct snd_cs46xx * chip,\r\nstruct dsp_pcm_channel_descriptor * pcm_channel,\r\nint period_size)\r\n{\r\nu32 temp = snd_cs46xx_peek (chip,pcm_channel->pcm_reader_scb->address << 2);\r\ntemp &= ~DMA_RQ_C1_SOURCE_SIZE_MASK;\r\nswitch (period_size) {\r\ncase 2048:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD1024;\r\nbreak;\r\ncase 1024:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD512;\r\nbreak;\r\ncase 512:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD256;\r\nbreak;\r\ncase 256:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD128;\r\nbreak;\r\ncase 128:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD64;\r\nbreak;\r\ncase 64:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD32;\r\nbreak;\r\ncase 32:\r\ntemp |= DMA_RQ_C1_SOURCE_MOD16;\r\nbreak;\r\ndefault:\r\nsnd_printdd ("period size (%d) not supported by HW\n", period_size);\r\nreturn -EINVAL;\r\n}\r\nsnd_cs46xx_poke (chip,pcm_channel->pcm_reader_scb->address << 2,temp);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_pcm_ostream_set_period (struct snd_cs46xx * chip,\r\nint period_size)\r\n{\r\nu32 temp = snd_cs46xx_peek (chip,WRITEBACK_SCB_ADDR << 2);\r\ntemp &= ~DMA_RQ_C1_DEST_SIZE_MASK;\r\nswitch (period_size) {\r\ncase 2048:\r\ntemp |= DMA_RQ_C1_DEST_MOD1024;\r\nbreak;\r\ncase 1024:\r\ntemp |= DMA_RQ_C1_DEST_MOD512;\r\nbreak;\r\ncase 512:\r\ntemp |= DMA_RQ_C1_DEST_MOD256;\r\nbreak;\r\ncase 256:\r\ntemp |= DMA_RQ_C1_DEST_MOD128;\r\nbreak;\r\ncase 128:\r\ntemp |= DMA_RQ_C1_DEST_MOD64;\r\nbreak;\r\ncase 64:\r\ntemp |= DMA_RQ_C1_DEST_MOD32;\r\nbreak;\r\ncase 32:\r\ntemp |= DMA_RQ_C1_DEST_MOD16;\r\nbreak;\r\ndefault:\r\nsnd_printdd ("period size (%d) not supported by HW\n", period_size);\r\nreturn -EINVAL;\r\n}\r\nsnd_cs46xx_poke (chip,WRITEBACK_SCB_ADDR << 2,temp);\r\nreturn 0;\r\n}\r\nvoid cs46xx_dsp_destroy_pcm_channel (struct snd_cs46xx * chip,\r\nstruct dsp_pcm_channel_descriptor * pcm_channel)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nunsigned long flags;\r\nif (snd_BUG_ON(!pcm_channel->active ||\r\nins->npcm_channels <= 0 ||\r\npcm_channel->src_scb->ref_count <= 0))\r\nreturn;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\npcm_channel->unlinked = 1;\r\npcm_channel->active = 0;\r\npcm_channel->private_data = NULL;\r\npcm_channel->src_scb->ref_count --;\r\nins->npcm_channels --;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\ncs46xx_dsp_remove_scb(chip,pcm_channel->pcm_reader_scb);\r\nif (!pcm_channel->src_scb->ref_count) {\r\ncs46xx_dsp_remove_scb(chip,pcm_channel->src_scb);\r\nif (snd_BUG_ON(pcm_channel->src_slot < 0 ||\r\npcm_channel->src_slot >= DSP_MAX_SRC_NR))\r\nreturn;\r\nins->src_scb_slots[pcm_channel->src_slot] = 0;\r\nins->nsrc_scb --;\r\n}\r\n}\r\nint cs46xx_dsp_pcm_unlink (struct snd_cs46xx * chip,\r\nstruct dsp_pcm_channel_descriptor * pcm_channel)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!pcm_channel->active ||\r\nchip->dsp_spos_instance->npcm_channels <= 0))\r\nreturn -EIO;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (pcm_channel->unlinked) {\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn -EIO;\r\n}\r\npcm_channel->unlinked = 1;\r\n_dsp_unlink_scb (chip,pcm_channel->pcm_reader_scb);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_pcm_link (struct snd_cs46xx * chip,\r\nstruct dsp_pcm_channel_descriptor * pcm_channel)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * parent_scb;\r\nstruct dsp_scb_descriptor * src_scb = pcm_channel->src_scb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (pcm_channel->unlinked == 0) {\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn -EIO;\r\n}\r\nparent_scb = src_scb;\r\nif (src_scb->sub_list_ptr != ins->the_null_scb) {\r\nsrc_scb->sub_list_ptr->parent_scb_ptr = pcm_channel->pcm_reader_scb;\r\npcm_channel->pcm_reader_scb->next_scb_ptr = src_scb->sub_list_ptr;\r\n}\r\nsrc_scb->sub_list_ptr = pcm_channel->pcm_reader_scb;\r\nsnd_BUG_ON(pcm_channel->pcm_reader_scb->parent_scb_ptr);\r\npcm_channel->pcm_reader_scb->parent_scb_ptr = parent_scb;\r\ncs46xx_dsp_spos_update_scb(chip,pcm_channel->pcm_reader_scb);\r\ncs46xx_dsp_spos_update_scb(chip,parent_scb);\r\npcm_channel->unlinked = 0;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstruct dsp_scb_descriptor *\r\ncs46xx_add_record_source (struct snd_cs46xx *chip, struct dsp_scb_descriptor * source,\r\nu16 addr, char * scb_name)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * parent;\r\nstruct dsp_scb_descriptor * pcm_input;\r\nint insert_point;\r\nif (snd_BUG_ON(!ins->record_mixer_scb))\r\nreturn NULL;\r\nif (ins->record_mixer_scb->sub_list_ptr != ins->the_null_scb) {\r\nparent = find_next_free_scb (chip,ins->record_mixer_scb->sub_list_ptr);\r\ninsert_point = SCB_ON_PARENT_NEXT_SCB;\r\n} else {\r\nparent = ins->record_mixer_scb;\r\ninsert_point = SCB_ON_PARENT_SUBLIST_SCB;\r\n}\r\npcm_input = cs46xx_dsp_create_pcm_serial_input_scb(chip,scb_name,addr,\r\nsource, parent,\r\ninsert_point);\r\nreturn pcm_input;\r\n}\r\nint cs46xx_src_unlink(struct snd_cs46xx *chip, struct dsp_scb_descriptor * src)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!src->parent_scb_ptr))\r\nreturn -EINVAL;\r\ncs46xx_dsp_scb_set_volume (chip,src,0,0);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n_dsp_unlink_scb (chip,src);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nint cs46xx_src_link(struct snd_cs46xx *chip, struct dsp_scb_descriptor * src)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nstruct dsp_scb_descriptor * parent_scb;\r\nif (snd_BUG_ON(src->parent_scb_ptr))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!ins->master_mix_scb))\r\nreturn -EINVAL;\r\nif (ins->master_mix_scb->sub_list_ptr != ins->the_null_scb) {\r\nparent_scb = find_next_free_scb (chip,ins->master_mix_scb->sub_list_ptr);\r\nparent_scb->next_scb_ptr = src;\r\n} else {\r\nparent_scb = ins->master_mix_scb;\r\nparent_scb->sub_list_ptr = src;\r\n}\r\nsrc->parent_scb_ptr = parent_scb;\r\ncs46xx_dsp_spos_update_scb(chip,parent_scb);\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_enable_spdif_out (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif ( ! (ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) ) {\r\ncs46xx_dsp_enable_spdif_hw (chip);\r\n}\r\nif ( ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN) {\r\nins->spdif_status_out |= DSP_SPDIF_STATUS_OUTPUT_ENABLED;\r\nreturn -EBUSY;\r\n}\r\nif (snd_BUG_ON(ins->asynch_tx_scb))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(ins->master_mix_scb->next_scb_ptr !=\r\nins->the_null_scb))\r\nreturn -EINVAL;\r\nsnd_cs46xx_poke (chip, (ins->ref_snoop_scb->address + 2) << 2,\r\n(OUTPUT_SNOOP_BUFFER + 0x10) << 0x10 );\r\nins->asynch_tx_scb = cs46xx_dsp_create_asynch_fg_tx_scb(chip,"AsynchFGTxSCB",ASYNCTX_SCB_ADDR,\r\nSPDIFO_SCB_INST,\r\nSPDIFO_IP_OUTPUT_BUFFER1,\r\nins->master_mix_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\nif (!ins->asynch_tx_scb) return -ENOMEM;\r\nins->spdif_pcm_input_scb = cs46xx_dsp_create_pcm_serial_input_scb(chip,"PCMSerialInput_II",\r\nPCMSERIALINII_SCB_ADDR,\r\nins->ref_snoop_scb,\r\nins->asynch_tx_scb,\r\nSCB_ON_PARENT_SUBLIST_SCB);\r\nif (!ins->spdif_pcm_input_scb) return -ENOMEM;\r\nins->spdif_status_out |= DSP_SPDIF_STATUS_OUTPUT_ENABLED;\r\nreturn 0;\r\n}\r\nint cs46xx_dsp_disable_spdif_out (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif ( ins->spdif_status_out & DSP_SPDIF_STATUS_PLAYBACK_OPEN) {\r\nins->spdif_status_out &= ~DSP_SPDIF_STATUS_OUTPUT_ENABLED;\r\nreturn -EBUSY;\r\n}\r\nif (snd_BUG_ON(!ins->asynch_tx_scb))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!ins->spdif_pcm_input_scb))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(ins->master_mix_scb->next_scb_ptr != ins->asynch_tx_scb))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(ins->asynch_tx_scb->parent_scb_ptr !=\r\nins->master_mix_scb))\r\nreturn -EINVAL;\r\ncs46xx_dsp_remove_scb (chip,ins->spdif_pcm_input_scb);\r\ncs46xx_dsp_remove_scb (chip,ins->asynch_tx_scb);\r\nins->spdif_pcm_input_scb = NULL;\r\nins->asynch_tx_scb = NULL;\r\n_dsp_clear_sample_buffer(chip,SPDIFO_IP_OUTPUT_BUFFER1,256);\r\nins->spdif_status_out &= ~DSP_SPDIF_STATUS_OUTPUT_ENABLED;\r\nreturn 0;\r\n}\r\nint cs46xx_iec958_pre_open (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif ( ins->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED ) {\r\ncs46xx_dsp_disable_spdif_out (chip);\r\nins->spdif_status_out |= DSP_SPDIF_STATUS_OUTPUT_ENABLED;\r\n}\r\nif ( !(ins->spdif_status_out & DSP_SPDIF_STATUS_HW_ENABLED) ) {\r\ncs46xx_dsp_enable_spdif_hw (chip);\r\n}\r\nins->asynch_tx_scb = cs46xx_dsp_create_asynch_fg_tx_scb(chip,"AsynchFGTxSCB",ASYNCTX_SCB_ADDR,\r\nSPDIFO_SCB_INST,\r\nSPDIFO_IP_OUTPUT_BUFFER1,\r\nins->master_mix_scb,\r\nSCB_ON_PARENT_NEXT_SCB);\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_stream);\r\nins->spdif_status_out |= DSP_SPDIF_STATUS_PLAYBACK_OPEN;\r\nreturn 0;\r\n}\r\nint cs46xx_iec958_post_close (struct snd_cs46xx *chip)\r\n{\r\nstruct dsp_spos_instance * ins = chip->dsp_spos_instance;\r\nif (snd_BUG_ON(!ins->asynch_tx_scb))\r\nreturn -EINVAL;\r\nins->spdif_status_out &= ~DSP_SPDIF_STATUS_PLAYBACK_OPEN;\r\ncs46xx_poke_via_dsp (chip,SP_SPDOUT_CSUV, ins->spdif_csuv_default);\r\nif (ins->spdif_pcm_input_scb != NULL) {\r\ncs46xx_dsp_remove_scb (chip,ins->spdif_pcm_input_scb);\r\nins->spdif_pcm_input_scb = NULL;\r\n}\r\ncs46xx_dsp_remove_scb (chip,ins->asynch_tx_scb);\r\nins->asynch_tx_scb = NULL;\r\n_dsp_clear_sample_buffer(chip,SPDIFO_IP_OUTPUT_BUFFER1,256);\r\nif ( ins->spdif_status_out & DSP_SPDIF_STATUS_OUTPUT_ENABLED ) {\r\ncs46xx_dsp_enable_spdif_out (chip);\r\n}\r\nreturn 0;\r\n}
