static int twl4030_madc_channel_raw_read(struct twl4030_madc_data *madc, u8 reg)\r\n{\r\nu8 msb, lsb;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &msb, reg + 1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read MSB register 0x%X\n",\r\nreg + 1);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &lsb, reg);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read LSB register 0x%X\n", reg);\r\nreturn ret;\r\n}\r\nreturn (int)(((msb << 8) | lsb) >> 6);\r\n}\r\nstatic int twl4030battery_temperature(int raw_volt)\r\n{\r\nu8 val;\r\nint temp, curr, volt, res, ret;\r\nvolt = (raw_volt * TEMP_STEP_SIZE) / TEMP_PSR_R;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE, &val,\r\nREG_BCICTL2);\r\nif (ret < 0)\r\nreturn ret;\r\ncurr = ((val & TWL4030_BCI_ITHEN) + 1) * 10;\r\nres = volt * 1000 / curr;\r\nfor (temp = 58; temp >= 0; temp--) {\r\nint actual = therm_tbl[temp];\r\nif ((actual - res) >= 0)\r\nbreak;\r\n}\r\nreturn temp + 1;\r\n}\r\nstatic int twl4030battery_current(int raw_volt)\r\n{\r\nint ret;\r\nu8 val;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE, &val,\r\nTWL4030_BCI_BCICTL1);\r\nif (ret)\r\nreturn ret;\r\nif (val & TWL4030_BCI_CGAIN)\r\nreturn (raw_volt * CURR_STEP_SIZE) / CURR_PSR_R1;\r\nelse\r\nreturn (raw_volt * CURR_STEP_SIZE) / CURR_PSR_R2;\r\n}\r\nstatic int twl4030_madc_read_channels(struct twl4030_madc_data *madc,\r\nu8 reg_base, unsigned\r\nlong channels, int *buf)\r\n{\r\nint count = 0, count_req = 0, i;\r\nu8 reg;\r\nfor_each_set_bit(i, &channels, TWL4030_MADC_MAX_CHANNELS) {\r\nreg = reg_base + 2 * i;\r\nbuf[i] = twl4030_madc_channel_raw_read(madc, reg);\r\nif (buf[i] < 0) {\r\ndev_err(madc->dev,\r\n"Unable to read register 0x%X\n", reg);\r\ncount_req++;\r\ncontinue;\r\n}\r\nswitch (i) {\r\ncase 10:\r\nbuf[i] = twl4030battery_current(buf[i]);\r\nif (buf[i] < 0) {\r\ndev_err(madc->dev, "err reading current\n");\r\ncount_req++;\r\n} else {\r\ncount++;\r\nbuf[i] = buf[i] - 750;\r\n}\r\nbreak;\r\ncase 1:\r\nbuf[i] = twl4030battery_temperature(buf[i]);\r\nif (buf[i] < 0) {\r\ndev_err(madc->dev, "err reading temperature\n");\r\ncount_req++;\r\n} else {\r\nbuf[i] -= 3;\r\ncount++;\r\n}\r\nbreak;\r\ndefault:\r\ncount++;\r\nbuf[i] = (buf[i] * 3 * 1000 *\r\ntwl4030_divider_ratios[i].denominator)\r\n/ (2 * 1023 *\r\ntwl4030_divider_ratios[i].numerator);\r\n}\r\n}\r\nif (count_req)\r\ndev_err(madc->dev, "%d channel conversion failed\n", count_req);\r\nreturn count;\r\n}\r\nstatic int twl4030_madc_enable_irq(struct twl4030_madc_data *madc, u8 id)\r\n{\r\nu8 val;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read imr register 0x%X\n",\r\nmadc->imr);\r\nreturn ret;\r\n}\r\nval &= ~(1 << id);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to write imr register 0x%X\n", madc->imr);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_disable_irq(struct twl4030_madc_data *madc, u8 id)\r\n{\r\nu8 val;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read imr register 0x%X\n",\r\nmadc->imr);\r\nreturn ret;\r\n}\r\nval |= (1 << id);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to write imr register 0x%X\n", madc->imr);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t twl4030_madc_threaded_irq_handler(int irq, void *_madc)\r\n{\r\nstruct twl4030_madc_data *madc = _madc;\r\nconst struct twl4030_madc_conversion_method *method;\r\nu8 isr_val, imr_val;\r\nint i, len, ret;\r\nstruct twl4030_madc_request *r;\r\nmutex_lock(&madc->lock);\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &isr_val, madc->isr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read isr register 0x%X\n",\r\nmadc->isr);\r\ngoto err_i2c;\r\n}\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &imr_val, madc->imr);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read imr register 0x%X\n",\r\nmadc->imr);\r\ngoto err_i2c;\r\n}\r\nisr_val &= ~imr_val;\r\nfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\r\nif (!(isr_val & (1 << i)))\r\ncontinue;\r\nret = twl4030_madc_disable_irq(madc, i);\r\nif (ret < 0)\r\ndev_dbg(madc->dev, "Disable interrupt failed%d\n", i);\r\nmadc->requests[i].result_pending = 1;\r\n}\r\nfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\r\nr = &madc->requests[i];\r\nif (!r->result_pending)\r\ncontinue;\r\nmethod = &twl4030_conversion_methods[r->method];\r\nlen = twl4030_madc_read_channels(madc, method->rbase,\r\nr->channels, r->rbuf);\r\nif (r->func_cb != NULL) {\r\nr->func_cb(len, r->channels, r->rbuf);\r\nr->func_cb = NULL;\r\n}\r\nr->result_pending = 0;\r\nr->active = 0;\r\n}\r\nmutex_unlock(&madc->lock);\r\nreturn IRQ_HANDLED;\r\nerr_i2c:\r\nfor (i = 0; i < TWL4030_MADC_NUM_METHODS; i++) {\r\nr = &madc->requests[i];\r\nif (r->active == 0)\r\ncontinue;\r\nmethod = &twl4030_conversion_methods[r->method];\r\nlen = twl4030_madc_read_channels(madc, method->rbase,\r\nr->channels, r->rbuf);\r\nif (r->func_cb != NULL) {\r\nr->func_cb(len, r->channels, r->rbuf);\r\nr->func_cb = NULL;\r\n}\r\nr->result_pending = 0;\r\nr->active = 0;\r\n}\r\nmutex_unlock(&madc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl4030_madc_set_irq(struct twl4030_madc_data *madc,\r\nstruct twl4030_madc_request *req)\r\n{\r\nstruct twl4030_madc_request *p;\r\nint ret;\r\np = &madc->requests[req->method];\r\nmemcpy(p, req, sizeof(*req));\r\nret = twl4030_madc_enable_irq(madc, req->method);\r\nif (ret < 0) {\r\ndev_err(madc->dev, "enable irq failed!!\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_start_conversion(struct twl4030_madc_data *madc,\r\nint conv_method)\r\n{\r\nconst struct twl4030_madc_conversion_method *method;\r\nint ret = 0;\r\nmethod = &twl4030_conversion_methods[conv_method];\r\nswitch (conv_method) {\r\ncase TWL4030_MADC_SW1:\r\ncase TWL4030_MADC_SW2:\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC,\r\nTWL4030_MADC_SW_START, method->ctrl);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to write ctrl register 0x%X\n",\r\nmethod->ctrl);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_wait_conversion_ready(struct twl4030_madc_data *madc,\r\nunsigned int timeout_ms,\r\nu8 status_reg)\r\n{\r\nunsigned long timeout;\r\nint ret;\r\ntimeout = jiffies + msecs_to_jiffies(timeout_ms);\r\ndo {\r\nu8 reg;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MADC, &reg, status_reg);\r\nif (ret) {\r\ndev_err(madc->dev,\r\n"unable to read status register 0x%X\n",\r\nstatus_reg);\r\nreturn ret;\r\n}\r\nif (!(reg & TWL4030_MADC_BUSY) && (reg & TWL4030_MADC_EOC_SW))\r\nreturn 0;\r\nusleep_range(500, 2000);\r\n} while (!time_after(jiffies, timeout));\r\ndev_err(madc->dev, "conversion timeout!\n");\r\nreturn -EAGAIN;\r\n}\r\nint twl4030_madc_conversion(struct twl4030_madc_request *req)\r\n{\r\nconst struct twl4030_madc_conversion_method *method;\r\nu8 ch_msb, ch_lsb;\r\nint ret;\r\nif (!req || !twl4030_madc)\r\nreturn -EINVAL;\r\nmutex_lock(&twl4030_madc->lock);\r\nif (req->method < TWL4030_MADC_RT || req->method > TWL4030_MADC_SW2) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (twl4030_madc->requests[req->method].active) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nch_msb = (req->channels >> 8) & 0xff;\r\nch_lsb = req->channels & 0xff;\r\nmethod = &twl4030_conversion_methods[req->method];\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, ch_msb, method->sel + 1);\r\nif (ret) {\r\ndev_err(twl4030_madc->dev,\r\n"unable to write sel register 0x%X\n", method->sel + 1);\r\ngoto out;\r\n}\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, ch_lsb, method->sel);\r\nif (ret) {\r\ndev_err(twl4030_madc->dev,\r\n"unable to write sel register 0x%X\n", method->sel + 1);\r\ngoto out;\r\n}\r\nif (req->do_avg) {\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC,\r\nch_msb, method->avg + 1);\r\nif (ret) {\r\ndev_err(twl4030_madc->dev,\r\n"unable to write avg register 0x%X\n",\r\nmethod->avg + 1);\r\ngoto out;\r\n}\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC,\r\nch_lsb, method->avg);\r\nif (ret) {\r\ndev_err(twl4030_madc->dev,\r\n"unable to write sel reg 0x%X\n",\r\nmethod->sel + 1);\r\ngoto out;\r\n}\r\n}\r\nif (req->type == TWL4030_MADC_IRQ_ONESHOT && req->func_cb != NULL) {\r\nret = twl4030_madc_set_irq(twl4030_madc, req);\r\nif (ret < 0)\r\ngoto out;\r\nret = twl4030_madc_start_conversion(twl4030_madc, req->method);\r\nif (ret < 0)\r\ngoto out;\r\ntwl4030_madc->requests[req->method].active = 1;\r\nret = 0;\r\ngoto out;\r\n}\r\nif (req->method == TWL4030_MADC_RT) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = twl4030_madc_start_conversion(twl4030_madc, req->method);\r\nif (ret < 0)\r\ngoto out;\r\ntwl4030_madc->requests[req->method].active = 1;\r\nret = twl4030_madc_wait_conversion_ready(twl4030_madc, 5, method->ctrl);\r\nif (ret) {\r\ntwl4030_madc->requests[req->method].active = 0;\r\ngoto out;\r\n}\r\nret = twl4030_madc_read_channels(twl4030_madc, method->rbase,\r\nreq->channels, req->rbuf);\r\ntwl4030_madc->requests[req->method].active = 0;\r\nout:\r\nmutex_unlock(&twl4030_madc->lock);\r\nreturn ret;\r\n}\r\nint twl4030_get_madc_conversion(int channel_no)\r\n{\r\nstruct twl4030_madc_request req;\r\nint temp = 0;\r\nint ret;\r\nreq.channels = (1 << channel_no);\r\nreq.method = TWL4030_MADC_SW2;\r\nreq.active = 0;\r\nreq.func_cb = NULL;\r\nret = twl4030_madc_conversion(&req);\r\nif (ret < 0)\r\nreturn ret;\r\nif (req.rbuf[channel_no] > 0)\r\ntemp = req.rbuf[channel_no];\r\nreturn temp;\r\n}\r\nstatic int twl4030_madc_set_current_generator(struct twl4030_madc_data *madc,\r\nint chan, int on)\r\n{\r\nint ret;\r\nu8 regval;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE,\r\n&regval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read BCICTL1 reg 0x%X",\r\nTWL4030_BCI_BCICTL1);\r\nreturn ret;\r\n}\r\nif (on)\r\nregval |= chan ? TWL4030_BCI_ITHEN : TWL4030_BCI_TYPEN;\r\nelse\r\nregval &= chan ? ~TWL4030_BCI_ITHEN : ~TWL4030_BCI_TYPEN;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MAIN_CHARGE,\r\nregval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to write BCICTL1 reg 0x%X\n",\r\nTWL4030_BCI_BCICTL1);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl4030_madc_set_power(struct twl4030_madc_data *madc, int on)\r\n{\r\nu8 regval;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE,\r\n&regval, TWL4030_MADC_CTRL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to read madc ctrl1 reg 0x%X\n",\r\nTWL4030_MADC_CTRL1);\r\nreturn ret;\r\n}\r\nif (on)\r\nregval |= TWL4030_MADC_MADCON;\r\nelse\r\nregval &= ~TWL4030_MADC_MADCON;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MADC, regval, TWL4030_MADC_CTRL1);\r\nif (ret) {\r\ndev_err(madc->dev, "unable to write madc ctrl1 reg 0x%X\n",\r\nTWL4030_MADC_CTRL1);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit twl4030_madc_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_madc_data *madc;\r\nstruct twl4030_madc_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nu8 regval;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "platform_data not available\n");\r\nreturn -EINVAL;\r\n}\r\nmadc = kzalloc(sizeof(*madc), GFP_KERNEL);\r\nif (!madc)\r\nreturn -ENOMEM;\r\nmadc->dev = &pdev->dev;\r\nmadc->imr = (pdata->irq_line == 1) ?\r\nTWL4030_MADC_IMR1 : TWL4030_MADC_IMR2;\r\nmadc->isr = (pdata->irq_line == 1) ?\r\nTWL4030_MADC_ISR1 : TWL4030_MADC_ISR2;\r\nret = twl4030_madc_set_power(madc, 1);\r\nif (ret < 0)\r\ngoto err_power;\r\nret = twl4030_madc_set_current_generator(madc, 0, 1);\r\nif (ret < 0)\r\ngoto err_current_generator;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_MAIN_CHARGE,\r\n&regval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to read reg BCI CTL1 0x%X\n",\r\nTWL4030_BCI_BCICTL1);\r\ngoto err_i2c;\r\n}\r\nregval |= TWL4030_BCI_MESBAT;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_MAIN_CHARGE,\r\nregval, TWL4030_BCI_BCICTL1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to write reg BCI Ctl1 0x%X\n",\r\nTWL4030_BCI_BCICTL1);\r\ngoto err_i2c;\r\n}\r\nret = twl_i2c_read_u8(TWL4030_MODULE_INTBR, &regval, TWL4030_REG_GPBR1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to read reg GPBR1 0x%X\n",\r\nTWL4030_REG_GPBR1);\r\ngoto err_i2c;\r\n}\r\nif (!(regval & TWL4030_GPBR1_MADC_HFCLK_EN)) {\r\ndev_info(&pdev->dev, "clk disabled, enabling\n");\r\nregval |= TWL4030_GPBR1_MADC_HFCLK_EN;\r\nret = twl_i2c_write_u8(TWL4030_MODULE_INTBR, regval,\r\nTWL4030_REG_GPBR1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to write reg GPBR1 0x%X\n",\r\nTWL4030_REG_GPBR1);\r\ngoto err_i2c;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, madc);\r\nmutex_init(&madc->lock);\r\nret = request_threaded_irq(platform_get_irq(pdev, 0), NULL,\r\ntwl4030_madc_threaded_irq_handler,\r\nIRQF_TRIGGER_RISING, "twl4030_madc", madc);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "could not request irq\n");\r\ngoto err_irq;\r\n}\r\ntwl4030_madc = madc;\r\nreturn 0;\r\nerr_irq:\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_i2c:\r\ntwl4030_madc_set_current_generator(madc, 0, 0);\r\nerr_current_generator:\r\ntwl4030_madc_set_power(madc, 0);\r\nerr_power:\r\nkfree(madc);\r\nreturn ret;\r\n}\r\nstatic int __devexit twl4030_madc_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_madc_data *madc = platform_get_drvdata(pdev);\r\nfree_irq(platform_get_irq(pdev, 0), madc);\r\nplatform_set_drvdata(pdev, NULL);\r\ntwl4030_madc_set_current_generator(madc, 0, 0);\r\ntwl4030_madc_set_power(madc, 0);\r\nkfree(madc);\r\nreturn 0;\r\n}
