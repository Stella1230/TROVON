static int\r\norinoco_cs_hard_reset(struct orinoco_private *priv)\r\n{\r\nstruct orinoco_pccard *card = priv->card;\r\nstruct pcmcia_device *link = card->p_dev;\r\nint err;\r\nset_bit(0, &card->hard_reset_in_progress);\r\nerr = pcmcia_reset_card(link->socket);\r\nif (err)\r\nreturn err;\r\nmsleep(100);\r\nclear_bit(0, &card->hard_reset_in_progress);\r\nreturn 0;\r\n}\r\nstatic int\r\norinoco_cs_probe(struct pcmcia_device *link)\r\n{\r\nstruct orinoco_private *priv;\r\nstruct orinoco_pccard *card;\r\npriv = alloc_orinocodev(sizeof(*card), &link->dev,\r\norinoco_cs_hard_reset, NULL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ncard = priv->card;\r\ncard->p_dev = link;\r\nlink->priv = priv;\r\nreturn orinoco_cs_config(link);\r\n}\r\nstatic void orinoco_cs_detach(struct pcmcia_device *link)\r\n{\r\nstruct orinoco_private *priv = link->priv;\r\norinoco_if_del(priv);\r\norinoco_cs_release(link);\r\nfree_orinocodev(priv);\r\n}\r\nstatic int orinoco_cs_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nif (p_dev->config_index == 0)\r\nreturn -EINVAL;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int\r\norinoco_cs_config(struct pcmcia_device *link)\r\n{\r\nstruct orinoco_private *priv = link->priv;\r\nstruct hermes *hw = &priv->hw;\r\nint ret;\r\nvoid __iomem *mem;\r\nlink->config_flags |= CONF_AUTO_SET_VPP | CONF_AUTO_CHECK_VCC |\r\nCONF_AUTO_SET_IO | CONF_ENABLE_IRQ;\r\nif (ignore_cis_vcc)\r\nlink->config_flags &= ~CONF_AUTO_CHECK_VCC;\r\nret = pcmcia_loop_config(link, orinoco_cs_config_check, NULL);\r\nif (ret) {\r\nif (!ignore_cis_vcc)\r\nprintk(KERN_ERR PFX "GetNextTuple(): No matching "\r\n"CIS configuration. Maybe you need the "\r\n"ignore_cis_vcc=1 parameter.\n");\r\ngoto failed;\r\n}\r\nmem = ioport_map(link->resource[0]->start,\r\nresource_size(link->resource[0]));\r\nif (!mem)\r\ngoto failed;\r\nhermes_struct_init(hw, mem, HERMES_16BIT_REGSPACING);\r\nret = pcmcia_request_irq(link, orinoco_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\nif (orinoco_init(priv) != 0) {\r\nprintk(KERN_ERR PFX "orinoco_init() failed\n");\r\ngoto failed;\r\n}\r\nif (orinoco_if_add(priv, link->resource[0]->start,\r\nlink->irq, NULL) != 0) {\r\nprintk(KERN_ERR PFX "orinoco_if_add() failed\n");\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\norinoco_cs_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void\r\norinoco_cs_release(struct pcmcia_device *link)\r\n{\r\nstruct orinoco_private *priv = link->priv;\r\nunsigned long flags;\r\npriv->hw.ops->lock_irqsave(&priv->lock, &flags);\r\npriv->hw_unavailable++;\r\npriv->hw.ops->unlock_irqrestore(&priv->lock, &flags);\r\npcmcia_disable_device(link);\r\nif (priv->hw.iobase)\r\nioport_unmap(priv->hw.iobase);\r\n}\r\nstatic int orinoco_cs_suspend(struct pcmcia_device *link)\r\n{\r\nstruct orinoco_private *priv = link->priv;\r\nstruct orinoco_pccard *card = priv->card;\r\nif (!test_bit(0, &card->hard_reset_in_progress))\r\norinoco_down(priv);\r\nreturn 0;\r\n}\r\nstatic int orinoco_cs_resume(struct pcmcia_device *link)\r\n{\r\nstruct orinoco_private *priv = link->priv;\r\nstruct orinoco_pccard *card = priv->card;\r\nint err = 0;\r\nif (!test_bit(0, &card->hard_reset_in_progress))\r\nerr = orinoco_up(priv);\r\nreturn err;\r\n}\r\nstatic int __init\r\ninit_orinoco_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&orinoco_driver);\r\n}\r\nstatic void __exit\r\nexit_orinoco_cs(void)\r\n{\r\npcmcia_unregister_driver(&orinoco_driver);\r\n}
