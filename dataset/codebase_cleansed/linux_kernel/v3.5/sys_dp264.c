static void\r\ntsunami_update_irq_hw(unsigned long mask)\r\n{\r\nregister tsunami_cchip *cchip = TSUNAMI_cchip;\r\nunsigned long isa_enable = 1UL << 55;\r\nregister int bcpu = boot_cpuid;\r\n#ifdef CONFIG_SMP\r\nvolatile unsigned long *dim0, *dim1, *dim2, *dim3;\r\nunsigned long mask0, mask1, mask2, mask3, dummy;\r\nmask &= ~isa_enable;\r\nmask0 = mask & cpu_irq_affinity[0];\r\nmask1 = mask & cpu_irq_affinity[1];\r\nmask2 = mask & cpu_irq_affinity[2];\r\nmask3 = mask & cpu_irq_affinity[3];\r\nif (bcpu == 0) mask0 |= isa_enable;\r\nelse if (bcpu == 1) mask1 |= isa_enable;\r\nelse if (bcpu == 2) mask2 |= isa_enable;\r\nelse mask3 |= isa_enable;\r\ndim0 = &cchip->dim0.csr;\r\ndim1 = &cchip->dim1.csr;\r\ndim2 = &cchip->dim2.csr;\r\ndim3 = &cchip->dim3.csr;\r\nif (!cpu_possible(0)) dim0 = &dummy;\r\nif (!cpu_possible(1)) dim1 = &dummy;\r\nif (!cpu_possible(2)) dim2 = &dummy;\r\nif (!cpu_possible(3)) dim3 = &dummy;\r\n*dim0 = mask0;\r\n*dim1 = mask1;\r\n*dim2 = mask2;\r\n*dim3 = mask3;\r\nmb();\r\n*dim0;\r\n*dim1;\r\n*dim2;\r\n*dim3;\r\n#else\r\nvolatile unsigned long *dimB;\r\nif (bcpu == 0) dimB = &cchip->dim0.csr;\r\nelse if (bcpu == 1) dimB = &cchip->dim1.csr;\r\nelse if (bcpu == 2) dimB = &cchip->dim2.csr;\r\nelse dimB = &cchip->dim3.csr;\r\n*dimB = mask | isa_enable;\r\nmb();\r\n*dimB;\r\n#endif\r\n}\r\nstatic void\r\ndp264_enable_irq(struct irq_data *d)\r\n{\r\nspin_lock(&dp264_irq_lock);\r\ncached_irq_mask |= 1UL << d->irq;\r\ntsunami_update_irq_hw(cached_irq_mask);\r\nspin_unlock(&dp264_irq_lock);\r\n}\r\nstatic void\r\ndp264_disable_irq(struct irq_data *d)\r\n{\r\nspin_lock(&dp264_irq_lock);\r\ncached_irq_mask &= ~(1UL << d->irq);\r\ntsunami_update_irq_hw(cached_irq_mask);\r\nspin_unlock(&dp264_irq_lock);\r\n}\r\nstatic void\r\nclipper_enable_irq(struct irq_data *d)\r\n{\r\nspin_lock(&dp264_irq_lock);\r\ncached_irq_mask |= 1UL << (d->irq - 16);\r\ntsunami_update_irq_hw(cached_irq_mask);\r\nspin_unlock(&dp264_irq_lock);\r\n}\r\nstatic void\r\nclipper_disable_irq(struct irq_data *d)\r\n{\r\nspin_lock(&dp264_irq_lock);\r\ncached_irq_mask &= ~(1UL << (d->irq - 16));\r\ntsunami_update_irq_hw(cached_irq_mask);\r\nspin_unlock(&dp264_irq_lock);\r\n}\r\nstatic void\r\ncpu_set_irq_affinity(unsigned int irq, cpumask_t affinity)\r\n{\r\nint cpu;\r\nfor (cpu = 0; cpu < 4; cpu++) {\r\nunsigned long aff = cpu_irq_affinity[cpu];\r\nif (cpumask_test_cpu(cpu, &affinity))\r\naff |= 1UL << irq;\r\nelse\r\naff &= ~(1UL << irq);\r\ncpu_irq_affinity[cpu] = aff;\r\n}\r\n}\r\nstatic int\r\ndp264_set_affinity(struct irq_data *d, const struct cpumask *affinity,\r\nbool force)\r\n{\r\nspin_lock(&dp264_irq_lock);\r\ncpu_set_irq_affinity(d->irq, *affinity);\r\ntsunami_update_irq_hw(cached_irq_mask);\r\nspin_unlock(&dp264_irq_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nclipper_set_affinity(struct irq_data *d, const struct cpumask *affinity,\r\nbool force)\r\n{\r\nspin_lock(&dp264_irq_lock);\r\ncpu_set_irq_affinity(d->irq - 16, *affinity);\r\ntsunami_update_irq_hw(cached_irq_mask);\r\nspin_unlock(&dp264_irq_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\ndp264_device_interrupt(unsigned long vector)\r\n{\r\n#if 1\r\nprintk("dp264_device_interrupt: NOT IMPLEMENTED YET!!\n");\r\n#else\r\nunsigned long pld;\r\nunsigned int i;\r\npld = TSUNAMI_cchip->dir0.csr;\r\nwhile (pld) {\r\ni = ffz(~pld);\r\npld &= pld - 1;\r\nif (i == 55)\r\nisa_device_interrupt(vector);\r\nelse\r\nhandle_irq(16 + i);\r\n#if 0\r\nTSUNAMI_cchip->dir0.csr = 1UL << i; mb();\r\ntmp = TSUNAMI_cchip->dir0.csr;\r\n#endif\r\n}\r\n#endif\r\n}\r\nstatic void\r\ndp264_srm_device_interrupt(unsigned long vector)\r\n{\r\nint irq;\r\nirq = (vector - 0x800) >> 4;\r\nif (irq >= 32)\r\nirq -= 16;\r\nhandle_irq(irq);\r\n}\r\nstatic void\r\nclipper_srm_device_interrupt(unsigned long vector)\r\n{\r\nint irq;\r\nirq = (vector - 0x800) >> 4;\r\nhandle_irq(irq);\r\n}\r\nstatic void __init\r\ninit_tsunami_irqs(struct irq_chip * ops, int imin, int imax)\r\n{\r\nlong i;\r\nfor (i = imin; i <= imax; ++i) {\r\nirq_set_chip_and_handler(i, ops, handle_level_irq);\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\n}\r\nstatic void __init\r\ndp264_init_irq(void)\r\n{\r\noutb(0, DMA1_RESET_REG);\r\noutb(0, DMA2_RESET_REG);\r\noutb(DMA_MODE_CASCADE, DMA2_MODE_REG);\r\noutb(0, DMA2_MASK_REG);\r\nif (alpha_using_srm)\r\nalpha_mv.device_interrupt = dp264_srm_device_interrupt;\r\ntsunami_update_irq_hw(0);\r\ninit_i8259a_irqs();\r\ninit_tsunami_irqs(&dp264_irq_type, 16, 47);\r\n}\r\nstatic void __init\r\nclipper_init_irq(void)\r\n{\r\noutb(0, DMA1_RESET_REG);\r\noutb(0, DMA2_RESET_REG);\r\noutb(DMA_MODE_CASCADE, DMA2_MODE_REG);\r\noutb(0, DMA2_MASK_REG);\r\nif (alpha_using_srm)\r\nalpha_mv.device_interrupt = clipper_srm_device_interrupt;\r\ntsunami_update_irq_hw(0);\r\ninit_i8259a_irqs();\r\ninit_tsunami_irqs(&clipper_irq_type, 24, 63);\r\n}\r\nstatic int __init\r\nisa_irq_fixup(const struct pci_dev *dev, int irq)\r\n{\r\nu8 irq8;\r\nif (irq > 0)\r\nreturn irq;\r\npci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq8);\r\nreturn irq8 & 0xf;\r\n}\r\nstatic int __init\r\ndp264_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[6][5] __initdata = {\r\n{ -1, -1, -1, -1, -1},\r\n{ 16+ 3, 16+ 3, 16+ 2, 16+ 2, 16+ 2},\r\n{ 16+15, 16+15, 16+14, 16+13, 16+12},\r\n{ 16+11, 16+11, 16+10, 16+ 9, 16+ 8},\r\n{ 16+ 7, 16+ 7, 16+ 6, 16+ 5, 16+ 4},\r\n{ 16+ 3, 16+ 3, 16+ 2, 16+ 1, 16+ 0}\r\n};\r\nconst long min_idsel = 5, max_idsel = 10, irqs_per_slot = 5;\r\nstruct pci_controller *hose = dev->sysdata;\r\nint irq = COMMON_TABLE_LOOKUP;\r\nif (irq > 0)\r\nirq += 16 * hose->index;\r\nreturn isa_irq_fixup(dev, irq);\r\n}\r\nstatic int __init\r\nmonet_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[13][5] __initdata = {\r\n{ 45, 45, 45, 45, 45},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ 47, 47, 47, 47, 47},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n#if 1\r\n{ 28, 28, 29, 30, 31},\r\n{ 24, 24, 25, 26, 27},\r\n#else\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n#endif\r\n{ 40, 40, 41, 42, 43},\r\n{ 36, 36, 37, 38, 39},\r\n{ 32, 32, 33, 34, 35},\r\n{ 28, 28, 29, 30, 31},\r\n{ 24, 24, 25, 26, 27}\r\n};\r\nconst long min_idsel = 3, max_idsel = 15, irqs_per_slot = 5;\r\nreturn isa_irq_fixup(dev, COMMON_TABLE_LOOKUP);\r\n}\r\nstatic u8 __init\r\nmonet_swizzle(struct pci_dev *dev, u8 *pinp)\r\n{\r\nstruct pci_controller *hose = dev->sysdata;\r\nint slot, pin = *pinp;\r\nif (!dev->bus->parent) {\r\nslot = PCI_SLOT(dev->devfn);\r\n}\r\nelse if (hose->index == 1 && PCI_SLOT(dev->bus->self->devfn) == 8) {\r\nslot = PCI_SLOT(dev->devfn);\r\n} else {\r\ndo {\r\nif (hose->index == 1 &&\r\nPCI_SLOT(dev->bus->self->devfn) == 8) {\r\nslot = PCI_SLOT(dev->devfn);\r\nbreak;\r\n}\r\npin = pci_swizzle_interrupt_pin(dev, pin);\r\ndev = dev->bus->self;\r\nslot = PCI_SLOT(dev->devfn);\r\n} while (dev->bus->self);\r\n}\r\n*pinp = pin;\r\nreturn slot;\r\n}\r\nstatic int __init\r\nwebbrick_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[13][5] __initdata = {\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ 29, 29, 29, 29, 29},\r\n{ -1, -1, -1, -1, -1},\r\n{ 30, 30, 30, 30, 30},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ 35, 35, 34, 33, 32},\r\n{ 39, 39, 38, 37, 36},\r\n{ 43, 43, 42, 41, 40},\r\n{ 47, 47, 46, 45, 44},\r\n};\r\nconst long min_idsel = 7, max_idsel = 17, irqs_per_slot = 5;\r\nreturn isa_irq_fixup(dev, COMMON_TABLE_LOOKUP);\r\n}\r\nstatic int __init\r\nclipper_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[7][5] __initdata = {\r\n{ 16+ 8, 16+ 8, 16+ 9, 16+10, 16+11},\r\n{ 16+12, 16+12, 16+13, 16+14, 16+15},\r\n{ 16+16, 16+16, 16+17, 16+18, 16+19},\r\n{ 16+20, 16+20, 16+21, 16+22, 16+23},\r\n{ 16+24, 16+24, 16+25, 16+26, 16+27},\r\n{ 16+28, 16+28, 16+29, 16+30, 16+31},\r\n{ -1, -1, -1, -1, -1}\r\n};\r\nconst long min_idsel = 1, max_idsel = 7, irqs_per_slot = 5;\r\nstruct pci_controller *hose = dev->sysdata;\r\nint irq = COMMON_TABLE_LOOKUP;\r\nif (irq > 0)\r\nirq += 16 * hose->index;\r\nreturn isa_irq_fixup(dev, irq);\r\n}\r\nstatic void __init\r\ndp264_init_pci(void)\r\n{\r\ncommon_init_pci();\r\nSMC669_Init(0);\r\nlocate_and_init_vga(NULL);\r\n}\r\nstatic void __init\r\nmonet_init_pci(void)\r\n{\r\ncommon_init_pci();\r\nSMC669_Init(1);\r\nes1888_init();\r\nlocate_and_init_vga(NULL);\r\n}\r\nstatic void __init\r\nclipper_init_pci(void)\r\n{\r\ncommon_init_pci();\r\nlocate_and_init_vga(NULL);\r\n}\r\nstatic void __init\r\nwebbrick_init_arch(void)\r\n{\r\ntsunami_init_arch();\r\nhose_head->sg_isa->align_entry = 4;\r\nhose_head->sg_pci->align_entry = 4;\r\n}
