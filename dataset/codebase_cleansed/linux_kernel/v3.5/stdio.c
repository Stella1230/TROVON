size_t strnlen(const char * s, size_t count)\r\n{\r\nconst char *sc;\r\nfor (sc = s; count-- && *sc != '\0'; ++sc)\r\n;\r\nreturn sc - s;\r\n}\r\nstatic int skip_atoi(const char **s)\r\n{\r\nint i, c;\r\nfor (i = 0; '0' <= (c = **s) && c <= '9'; ++*s)\r\ni = i*10 + c - '0';\r\nreturn i;\r\n}\r\nstatic char * number(char * str, unsigned long long num, int base, int size, int precision, int type)\r\n{\r\nchar c,sign,tmp[66];\r\nconst char *digits="0123456789abcdefghijklmnopqrstuvwxyz";\r\nint i;\r\nif (type & LARGE)\r\ndigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";\r\nif (type & LEFT)\r\ntype &= ~ZEROPAD;\r\nif (base < 2 || base > 36)\r\nreturn 0;\r\nc = (type & ZEROPAD) ? '0' : ' ';\r\nsign = 0;\r\nif (type & SIGN) {\r\nif ((signed long long)num < 0) {\r\nsign = '-';\r\nnum = - (signed long long)num;\r\nsize--;\r\n} else if (type & PLUS) {\r\nsign = '+';\r\nsize--;\r\n} else if (type & SPACE) {\r\nsign = ' ';\r\nsize--;\r\n}\r\n}\r\nif (type & SPECIAL) {\r\nif (base == 16)\r\nsize -= 2;\r\nelse if (base == 8)\r\nsize--;\r\n}\r\ni = 0;\r\nif (num == 0)\r\ntmp[i++]='0';\r\nelse while (num != 0) {\r\ntmp[i++] = digits[do_div(num, base)];\r\n}\r\nif (i > precision)\r\nprecision = i;\r\nsize -= precision;\r\nif (!(type&(ZEROPAD+LEFT)))\r\nwhile(size-->0)\r\n*str++ = ' ';\r\nif (sign)\r\n*str++ = sign;\r\nif (type & SPECIAL) {\r\nif (base==8)\r\n*str++ = '0';\r\nelse if (base==16) {\r\n*str++ = '0';\r\n*str++ = digits[33];\r\n}\r\n}\r\nif (!(type & LEFT))\r\nwhile (size-- > 0)\r\n*str++ = c;\r\nwhile (i < precision--)\r\n*str++ = '0';\r\nwhile (i-- > 0)\r\n*str++ = tmp[i];\r\nwhile (size-- > 0)\r\n*str++ = ' ';\r\nreturn str;\r\n}\r\nint vsprintf(char *buf, const char *fmt, va_list args)\r\n{\r\nint len;\r\nunsigned long long num;\r\nint i, base;\r\nchar * str;\r\nconst char *s;\r\nint flags;\r\nint field_width;\r\nint precision;\r\nint qualifier;\r\nfor (str=buf ; *fmt ; ++fmt) {\r\nif (*fmt != '%') {\r\n*str++ = *fmt;\r\ncontinue;\r\n}\r\nflags = 0;\r\nrepeat:\r\n++fmt;\r\nswitch (*fmt) {\r\ncase '-': flags |= LEFT; goto repeat;\r\ncase '+': flags |= PLUS; goto repeat;\r\ncase ' ': flags |= SPACE; goto repeat;\r\ncase '#': flags |= SPECIAL; goto repeat;\r\ncase '0': flags |= ZEROPAD; goto repeat;\r\n}\r\nfield_width = -1;\r\nif ('0' <= *fmt && *fmt <= '9')\r\nfield_width = skip_atoi(&fmt);\r\nelse if (*fmt == '*') {\r\n++fmt;\r\nfield_width = va_arg(args, int);\r\nif (field_width < 0) {\r\nfield_width = -field_width;\r\nflags |= LEFT;\r\n}\r\n}\r\nprecision = -1;\r\nif (*fmt == '.') {\r\n++fmt;\r\nif ('0' <= *fmt && *fmt <= '9')\r\nprecision = skip_atoi(&fmt);\r\nelse if (*fmt == '*') {\r\n++fmt;\r\nprecision = va_arg(args, int);\r\n}\r\nif (precision < 0)\r\nprecision = 0;\r\n}\r\nqualifier = -1;\r\nif (*fmt == 'l' && *(fmt + 1) == 'l') {\r\nqualifier = 'q';\r\nfmt += 2;\r\n} else if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L'\r\n|| *fmt == 'Z') {\r\nqualifier = *fmt;\r\n++fmt;\r\n}\r\nbase = 10;\r\nswitch (*fmt) {\r\ncase 'c':\r\nif (!(flags & LEFT))\r\nwhile (--field_width > 0)\r\n*str++ = ' ';\r\n*str++ = (unsigned char) va_arg(args, int);\r\nwhile (--field_width > 0)\r\n*str++ = ' ';\r\ncontinue;\r\ncase 's':\r\ns = va_arg(args, char *);\r\nif (!s)\r\ns = "<NULL>";\r\nlen = strnlen(s, precision);\r\nif (!(flags & LEFT))\r\nwhile (len < field_width--)\r\n*str++ = ' ';\r\nfor (i = 0; i < len; ++i)\r\n*str++ = *s++;\r\nwhile (len < field_width--)\r\n*str++ = ' ';\r\ncontinue;\r\ncase 'p':\r\nif (field_width == -1) {\r\nfield_width = 2*sizeof(void *);\r\nflags |= ZEROPAD;\r\n}\r\nstr = number(str,\r\n(unsigned long) va_arg(args, void *), 16,\r\nfield_width, precision, flags);\r\ncontinue;\r\ncase 'n':\r\nif (qualifier == 'l') {\r\nlong * ip = va_arg(args, long *);\r\n*ip = (str - buf);\r\n} else if (qualifier == 'Z') {\r\nsize_t * ip = va_arg(args, size_t *);\r\n*ip = (str - buf);\r\n} else {\r\nint * ip = va_arg(args, int *);\r\n*ip = (str - buf);\r\n}\r\ncontinue;\r\ncase '%':\r\n*str++ = '%';\r\ncontinue;\r\ncase 'o':\r\nbase = 8;\r\nbreak;\r\ncase 'X':\r\nflags |= LARGE;\r\ncase 'x':\r\nbase = 16;\r\nbreak;\r\ncase 'd':\r\ncase 'i':\r\nflags |= SIGN;\r\ncase 'u':\r\nbreak;\r\ndefault:\r\n*str++ = '%';\r\nif (*fmt)\r\n*str++ = *fmt;\r\nelse\r\n--fmt;\r\ncontinue;\r\n}\r\nif (qualifier == 'l') {\r\nnum = va_arg(args, unsigned long);\r\nif (flags & SIGN)\r\nnum = (signed long) num;\r\n} else if (qualifier == 'q') {\r\nnum = va_arg(args, unsigned long long);\r\nif (flags & SIGN)\r\nnum = (signed long long) num;\r\n} else if (qualifier == 'Z') {\r\nnum = va_arg(args, size_t);\r\n} else if (qualifier == 'h') {\r\nnum = (unsigned short) va_arg(args, int);\r\nif (flags & SIGN)\r\nnum = (signed short) num;\r\n} else {\r\nnum = va_arg(args, unsigned int);\r\nif (flags & SIGN)\r\nnum = (signed int) num;\r\n}\r\nstr = number(str, num, base, field_width, precision, flags);\r\n}\r\n*str = '\0';\r\nreturn str-buf;\r\n}\r\nint sprintf(char * buf, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint i;\r\nva_start(args, fmt);\r\ni=vsprintf(buf,fmt,args);\r\nva_end(args);\r\nreturn i;\r\n}\r\nint\r\nprintf(const char *fmt, ...)\r\n{\r\nva_list args;\r\nint n;\r\nva_start(args, fmt);\r\nn = vsprintf(sprint_buf, fmt, args);\r\nva_end(args);\r\nif (console_ops.write)\r\nconsole_ops.write(sprint_buf, n);\r\nreturn n;\r\n}
