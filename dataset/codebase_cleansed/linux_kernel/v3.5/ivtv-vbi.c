static void ivtv_set_vps(struct ivtv *itv, int enabled)\r\n{\r\nstruct v4l2_sliced_vbi_data data;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn;\r\ndata.id = V4L2_SLICED_VPS;\r\ndata.field = 0;\r\ndata.line = enabled ? 16 : 0;\r\ndata.data[2] = itv->vbi.vps_payload.data[0];\r\ndata.data[8] = itv->vbi.vps_payload.data[1];\r\ndata.data[9] = itv->vbi.vps_payload.data[2];\r\ndata.data[10] = itv->vbi.vps_payload.data[3];\r\ndata.data[11] = itv->vbi.vps_payload.data[4];\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\r\n}\r\nstatic void ivtv_set_cc(struct ivtv *itv, int mode, const struct vbi_cc *cc)\r\n{\r\nstruct v4l2_sliced_vbi_data data;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn;\r\ndata.id = V4L2_SLICED_CAPTION_525;\r\ndata.field = 0;\r\ndata.line = (mode & 1) ? 21 : 0;\r\ndata.data[0] = cc->odd[0];\r\ndata.data[1] = cc->odd[1];\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\r\ndata.field = 1;\r\ndata.line = (mode & 2) ? 21 : 0;\r\ndata.data[0] = cc->even[0];\r\ndata.data[1] = cc->even[1];\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\r\n}\r\nstatic void ivtv_set_wss(struct ivtv *itv, int enabled, int mode)\r\n{\r\nstruct v4l2_sliced_vbi_data data;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn;\r\nif ((itv->std_out & V4L2_STD_625_50) && !enabled) {\r\nenabled = 1;\r\nmode = 0x08;\r\n}\r\ndata.id = V4L2_SLICED_WSS_625;\r\ndata.field = 0;\r\ndata.line = enabled ? 23 : 0;\r\ndata.data[0] = mode & 0xff;\r\ndata.data[1] = (mode >> 8) & 0xff;\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, vbi, s_vbi_data, &data);\r\n}\r\nstatic int odd_parity(u8 c)\r\n{\r\nc ^= (c >> 4);\r\nc ^= (c >> 2);\r\nc ^= (c >> 1);\r\nreturn c & 1;\r\n}\r\nstatic void ivtv_write_vbi_line(struct ivtv *itv,\r\nconst struct v4l2_sliced_vbi_data *d,\r\nstruct vbi_cc *cc, int *found_cc)\r\n{\r\nstruct vbi_info *vi = &itv->vbi;\r\nif (d->id == V4L2_SLICED_CAPTION_525 && d->line == 21) {\r\nif (d->field) {\r\ncc->even[0] = d->data[0];\r\ncc->even[1] = d->data[1];\r\n} else {\r\ncc->odd[0] = d->data[0];\r\ncc->odd[1] = d->data[1];\r\n}\r\n*found_cc = 1;\r\n} else if (d->id == V4L2_SLICED_VPS && d->line == 16 && d->field == 0) {\r\nstruct vbi_vps vps;\r\nvps.data[0] = d->data[2];\r\nvps.data[1] = d->data[8];\r\nvps.data[2] = d->data[9];\r\nvps.data[3] = d->data[10];\r\nvps.data[4] = d->data[11];\r\nif (memcmp(&vps, &vi->vps_payload, sizeof(vps))) {\r\nvi->vps_payload = vps;\r\nset_bit(IVTV_F_I_UPDATE_VPS, &itv->i_flags);\r\n}\r\n} else if (d->id == V4L2_SLICED_WSS_625 &&\r\nd->line == 23 && d->field == 0) {\r\nint wss = d->data[0] | d->data[1] << 8;\r\nif (vi->wss_payload != wss) {\r\nvi->wss_payload = wss;\r\nset_bit(IVTV_F_I_UPDATE_WSS, &itv->i_flags);\r\n}\r\n}\r\n}\r\nstatic void ivtv_write_vbi_cc_lines(struct ivtv *itv, const struct vbi_cc *cc)\r\n{\r\nstruct vbi_info *vi = &itv->vbi;\r\nif (vi->cc_payload_idx < ARRAY_SIZE(vi->cc_payload)) {\r\nmemcpy(&vi->cc_payload[vi->cc_payload_idx], cc,\r\nsizeof(struct vbi_cc));\r\nvi->cc_payload_idx++;\r\nset_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags);\r\n}\r\n}\r\nstatic void ivtv_write_vbi(struct ivtv *itv,\r\nconst struct v4l2_sliced_vbi_data *sliced,\r\nsize_t cnt)\r\n{\r\nstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\r\nint found_cc = 0;\r\nsize_t i;\r\nfor (i = 0; i < cnt; i++)\r\nivtv_write_vbi_line(itv, sliced + i, &cc, &found_cc);\r\nif (found_cc)\r\nivtv_write_vbi_cc_lines(itv, &cc);\r\n}\r\nssize_t\r\nivtv_write_vbi_from_user(struct ivtv *itv,\r\nconst struct v4l2_sliced_vbi_data __user *sliced,\r\nsize_t cnt)\r\n{\r\nstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\r\nint found_cc = 0;\r\nsize_t i;\r\nstruct v4l2_sliced_vbi_data d;\r\nssize_t ret = cnt * sizeof(struct v4l2_sliced_vbi_data);\r\nfor (i = 0; i < cnt; i++) {\r\nif (copy_from_user(&d, sliced + i,\r\nsizeof(struct v4l2_sliced_vbi_data))) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nivtv_write_vbi_line(itv, &d, &cc, &found_cc);\r\n}\r\nif (found_cc)\r\nivtv_write_vbi_cc_lines(itv, &cc);\r\nreturn ret;\r\n}\r\nstatic void copy_vbi_data(struct ivtv *itv, int lines, u32 pts_stamp)\r\n{\r\nint line = 0;\r\nint i;\r\nu32 linemask[2] = { 0, 0 };\r\nunsigned short size;\r\nstatic const u8 mpeg_hdr_data[] = {\r\n0x00, 0x00, 0x01, 0xba, 0x44, 0x00, 0x0c, 0x66,\r\n0x24, 0x01, 0x01, 0xd1, 0xd3, 0xfa, 0xff, 0xff,\r\n0x00, 0x00, 0x01, 0xbd, 0x00, 0x1a, 0x84, 0x80,\r\n0x07, 0x21, 0x00, 0x5d, 0x63, 0xa7, 0xff, 0xff\r\n};\r\nconst int sd = sizeof(mpeg_hdr_data);\r\nint idx = itv->vbi.frame % IVTV_VBI_FRAMES;\r\nu8 *dst = &itv->vbi.sliced_mpeg_data[idx][0];\r\nfor (i = 0; i < lines; i++) {\r\nint f, l;\r\nif (itv->vbi.sliced_data[i].id == 0)\r\ncontinue;\r\nl = itv->vbi.sliced_data[i].line - 6;\r\nf = itv->vbi.sliced_data[i].field;\r\nif (f)\r\nl += 18;\r\nif (l < 32)\r\nlinemask[0] |= (1 << l);\r\nelse\r\nlinemask[1] |= (1 << (l - 32));\r\ndst[sd + 12 + line * 43] =\r\nivtv_service2vbi(itv->vbi.sliced_data[i].id);\r\nmemcpy(dst + sd + 12 + line * 43 + 1, itv->vbi.sliced_data[i].data, 42);\r\nline++;\r\n}\r\nmemcpy(dst, mpeg_hdr_data, sizeof(mpeg_hdr_data));\r\nif (line == 36) {\r\nmemcpy(dst + sd, "ITV0", 4);\r\nmemcpy(dst + sd + 4, dst + sd + 12, line * 43);\r\nsize = 4 + ((43 * line + 3) & ~3);\r\n} else {\r\nmemcpy(dst + sd, "itv0", 4);\r\ncpu_to_le32s(&linemask[0]);\r\ncpu_to_le32s(&linemask[1]);\r\nmemcpy(dst + sd + 4, &linemask[0], 8);\r\nsize = 12 + ((43 * line + 3) & ~3);\r\n}\r\ndst[4+16] = (size + 10) >> 8;\r\ndst[5+16] = (size + 10) & 0xff;\r\ndst[9+16] = 0x21 | ((pts_stamp >> 29) & 0x6);\r\ndst[10+16] = (pts_stamp >> 22) & 0xff;\r\ndst[11+16] = 1 | ((pts_stamp >> 14) & 0xff);\r\ndst[12+16] = (pts_stamp >> 7) & 0xff;\r\ndst[13+16] = 1 | ((pts_stamp & 0x7f) << 1);\r\nitv->vbi.sliced_mpeg_size[idx] = sd + size;\r\n}\r\nstatic int ivtv_convert_ivtv_vbi(struct ivtv *itv, u8 *p)\r\n{\r\nu32 linemask[2];\r\nint i, l, id2;\r\nint line = 0;\r\nif (!memcmp(p, "itv0", 4)) {\r\nmemcpy(linemask, p + 4, 8);\r\np += 12;\r\n} else if (!memcmp(p, "ITV0", 4)) {\r\nlinemask[0] = 0xffffffff;\r\nlinemask[1] = 0xf;\r\np += 4;\r\n} else {\r\nlinemask[0] = linemask[1] = 0;\r\n}\r\nfor (i = 0; i < 36; i++) {\r\nint err = 0;\r\nif (i < 32 && !(linemask[0] & (1 << i)))\r\ncontinue;\r\nif (i >= 32 && !(linemask[1] & (1 << (i - 32))))\r\ncontinue;\r\nid2 = *p & 0xf;\r\nswitch (id2) {\r\ncase IVTV_SLICED_TYPE_TELETEXT_B:\r\nid2 = V4L2_SLICED_TELETEXT_B;\r\nbreak;\r\ncase IVTV_SLICED_TYPE_CAPTION_525:\r\nid2 = V4L2_SLICED_CAPTION_525;\r\nerr = !odd_parity(p[1]) || !odd_parity(p[2]);\r\nbreak;\r\ncase IVTV_SLICED_TYPE_VPS:\r\nid2 = V4L2_SLICED_VPS;\r\nbreak;\r\ncase IVTV_SLICED_TYPE_WSS_625:\r\nid2 = V4L2_SLICED_WSS_625;\r\nbreak;\r\ndefault:\r\nid2 = 0;\r\nbreak;\r\n}\r\nif (err == 0) {\r\nl = (i < 18) ? i + 6 : i - 18 + 6;\r\nitv->vbi.sliced_dec_data[line].line = l;\r\nitv->vbi.sliced_dec_data[line].field = i >= 18;\r\nitv->vbi.sliced_dec_data[line].id = id2;\r\nmemcpy(itv->vbi.sliced_dec_data[line].data, p + 1, 42);\r\nline++;\r\n}\r\np += 43;\r\n}\r\nwhile (line < 36) {\r\nitv->vbi.sliced_dec_data[line].id = 0;\r\nitv->vbi.sliced_dec_data[line].line = 0;\r\nitv->vbi.sliced_dec_data[line].field = 0;\r\nline++;\r\n}\r\nreturn line * sizeof(itv->vbi.sliced_dec_data[0]);\r\n}\r\nstatic u32 compress_raw_buf(struct ivtv *itv, u8 *buf, u32 size)\r\n{\r\nu32 line_size = itv->vbi.raw_decoder_line_size;\r\nu32 lines = itv->vbi.count;\r\nu8 sav1 = itv->vbi.raw_decoder_sav_odd_field;\r\nu8 sav2 = itv->vbi.raw_decoder_sav_even_field;\r\nu8 *q = buf;\r\nu8 *p;\r\nint i;\r\nfor (i = 0; i < lines; i++) {\r\np = buf + i * line_size;\r\nif (p[0] != 0xff || p[1] || p[2] || (p[3] != sav1 && p[3] != sav2)) {\r\nbreak;\r\n}\r\nmemcpy(q, p + 4, line_size - 4);\r\nq += line_size - 4;\r\n}\r\nreturn lines * (line_size - 4);\r\n}\r\nstatic u32 compress_sliced_buf(struct ivtv *itv, u32 line, u8 *buf, u32 size, u8 sav)\r\n{\r\nu32 line_size = itv->vbi.sliced_decoder_line_size;\r\nstruct v4l2_decode_vbi_line vbi;\r\nint i;\r\nunsigned lines = 0;\r\nfor (i = 0; i < size; i++, buf++) {\r\nif (buf[0] == 0xff && !buf[1] && !buf[2] && buf[3] == sav)\r\nbreak;\r\n}\r\nsize -= i;\r\nif (size < line_size) {\r\nreturn line;\r\n}\r\nfor (i = 0; i < size / line_size; i++) {\r\nu8 *p = buf + i * line_size;\r\nif (p[0] != 0xff || p[1] || p[2] || p[3] != sav) {\r\ncontinue;\r\n}\r\nvbi.p = p + 4;\r\nv4l2_subdev_call(itv->sd_video, vbi, decode_vbi_line, &vbi);\r\nif (vbi.type && !(lines & (1 << vbi.line))) {\r\nlines |= 1 << vbi.line;\r\nitv->vbi.sliced_data[line].id = vbi.type;\r\nitv->vbi.sliced_data[line].field = vbi.is_second_field;\r\nitv->vbi.sliced_data[line].line = vbi.line;\r\nmemcpy(itv->vbi.sliced_data[line].data, vbi.p, 42);\r\nline++;\r\n}\r\n}\r\nreturn line;\r\n}\r\nvoid ivtv_process_vbi_data(struct ivtv *itv, struct ivtv_buffer *buf,\r\nu64 pts_stamp, int streamtype)\r\n{\r\nu8 *p = (u8 *) buf->buf;\r\nu32 size = buf->bytesused;\r\nint y;\r\nif (streamtype == IVTV_ENC_STREAM_TYPE_VBI && ivtv_raw_vbi(itv)) {\r\nu8 type;\r\nivtv_buf_swap(buf);\r\ntype = p[3];\r\nsize = buf->bytesused = compress_raw_buf(itv, p, size);\r\nif (type == itv->vbi.raw_decoder_sav_even_field) {\r\np += size - 4;\r\nmemcpy(p, &itv->vbi.frame, 4);\r\nitv->vbi.frame++;\r\n}\r\nreturn;\r\n}\r\nif (streamtype == IVTV_ENC_STREAM_TYPE_VBI) {\r\nint lines;\r\nivtv_buf_swap(buf);\r\nlines = compress_sliced_buf(itv, 0, p, size / 2,\r\nitv->vbi.sliced_decoder_sav_odd_field);\r\nlines = compress_sliced_buf(itv, lines, p + size / 2 - 32, size / 2 + 32,\r\nitv->vbi.sliced_decoder_sav_even_field);\r\nif (lines == 0) {\r\nitv->vbi.sliced_data[0].id = 0;\r\nitv->vbi.sliced_data[0].line = 0;\r\nitv->vbi.sliced_data[0].field = 0;\r\nlines = 1;\r\n}\r\nbuf->bytesused = size = lines * sizeof(itv->vbi.sliced_data[0]);\r\nmemcpy(p, &itv->vbi.sliced_data[0], size);\r\nif (itv->vbi.insert_mpeg) {\r\ncopy_vbi_data(itv, lines, pts_stamp);\r\n}\r\nitv->vbi.frame++;\r\nreturn;\r\n}\r\nif (streamtype == IVTV_DEC_STREAM_TYPE_VBI) {\r\nint offset = size & 3;\r\nint cnt;\r\nif (offset) {\r\np += 4 - offset;\r\n}\r\nfor (y = 0; y < size; y += 4) {\r\nswab32s((u32 *)(p + y));\r\n}\r\ncnt = ivtv_convert_ivtv_vbi(itv, p + offset);\r\nmemcpy(buf->buf, itv->vbi.sliced_dec_data, cnt);\r\nbuf->bytesused = cnt;\r\nivtv_write_vbi(itv, itv->vbi.sliced_dec_data,\r\ncnt / sizeof(itv->vbi.sliced_dec_data[0]));\r\nreturn;\r\n}\r\n}\r\nvoid ivtv_disable_cc(struct ivtv *itv)\r\n{\r\nstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\r\nclear_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags);\r\nivtv_set_cc(itv, 0, &cc);\r\nitv->vbi.cc_payload_idx = 0;\r\n}\r\nvoid ivtv_vbi_work_handler(struct ivtv *itv)\r\n{\r\nstruct vbi_info *vi = &itv->vbi;\r\nstruct v4l2_sliced_vbi_data data;\r\nstruct vbi_cc cc = { .odd = { 0x80, 0x80 }, .even = { 0x80, 0x80 } };\r\nif (itv->output_mode == OUT_PASSTHROUGH) {\r\nif (itv->is_50hz) {\r\ndata.id = V4L2_SLICED_WSS_625;\r\ndata.field = 0;\r\nif (v4l2_subdev_call(itv->sd_video, vbi, g_vbi_data, &data) == 0) {\r\nivtv_set_wss(itv, 1, data.data[0] & 0xf);\r\nvi->wss_missing_cnt = 0;\r\n} else if (vi->wss_missing_cnt == 4) {\r\nivtv_set_wss(itv, 1, 0x8);\r\n} else {\r\nvi->wss_missing_cnt++;\r\n}\r\n}\r\nelse {\r\nint mode = 0;\r\ndata.id = V4L2_SLICED_CAPTION_525;\r\ndata.field = 0;\r\nif (v4l2_subdev_call(itv->sd_video, vbi, g_vbi_data, &data) == 0) {\r\nmode |= 1;\r\ncc.odd[0] = data.data[0];\r\ncc.odd[1] = data.data[1];\r\n}\r\ndata.field = 1;\r\nif (v4l2_subdev_call(itv->sd_video, vbi, g_vbi_data, &data) == 0) {\r\nmode |= 2;\r\ncc.even[0] = data.data[0];\r\ncc.even[1] = data.data[1];\r\n}\r\nif (mode) {\r\nvi->cc_missing_cnt = 0;\r\nivtv_set_cc(itv, mode, &cc);\r\n} else if (vi->cc_missing_cnt == 4) {\r\nivtv_set_cc(itv, 0, &cc);\r\n} else {\r\nvi->cc_missing_cnt++;\r\n}\r\n}\r\nreturn;\r\n}\r\nif (test_and_clear_bit(IVTV_F_I_UPDATE_WSS, &itv->i_flags)) {\r\nivtv_set_wss(itv, 1, vi->wss_payload & 0xf);\r\n}\r\nif (test_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags)) {\r\nif (vi->cc_payload_idx == 0) {\r\nclear_bit(IVTV_F_I_UPDATE_CC, &itv->i_flags);\r\nivtv_set_cc(itv, 3, &cc);\r\n}\r\nwhile (vi->cc_payload_idx) {\r\ncc = vi->cc_payload[0];\r\nmemcpy(vi->cc_payload, vi->cc_payload + 1,\r\nsizeof(vi->cc_payload) - sizeof(vi->cc_payload[0]));\r\nvi->cc_payload_idx--;\r\nif (vi->cc_payload_idx && cc.odd[0] == 0x80 && cc.odd[1] == 0x80)\r\ncontinue;\r\nivtv_set_cc(itv, 3, &cc);\r\nbreak;\r\n}\r\n}\r\nif (test_and_clear_bit(IVTV_F_I_UPDATE_VPS, &itv->i_flags)) {\r\nivtv_set_vps(itv, 1);\r\n}\r\n}
