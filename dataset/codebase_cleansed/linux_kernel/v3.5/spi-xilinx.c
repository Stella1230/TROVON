static void xspi_write32(u32 val, void __iomem *addr)\r\n{\r\niowrite32(val, addr);\r\n}\r\nstatic unsigned int xspi_read32(void __iomem *addr)\r\n{\r\nreturn ioread32(addr);\r\n}\r\nstatic void xspi_write32_be(u32 val, void __iomem *addr)\r\n{\r\niowrite32be(val, addr);\r\n}\r\nstatic unsigned int xspi_read32_be(void __iomem *addr)\r\n{\r\nreturn ioread32be(addr);\r\n}\r\nstatic void xspi_tx8(struct xilinx_spi *xspi)\r\n{\r\nxspi->write_fn(*xspi->tx_ptr, xspi->regs + XSPI_TXD_OFFSET);\r\nxspi->tx_ptr++;\r\n}\r\nstatic void xspi_tx16(struct xilinx_spi *xspi)\r\n{\r\nxspi->write_fn(*(u16 *)(xspi->tx_ptr), xspi->regs + XSPI_TXD_OFFSET);\r\nxspi->tx_ptr += 2;\r\n}\r\nstatic void xspi_tx32(struct xilinx_spi *xspi)\r\n{\r\nxspi->write_fn(*(u32 *)(xspi->tx_ptr), xspi->regs + XSPI_TXD_OFFSET);\r\nxspi->tx_ptr += 4;\r\n}\r\nstatic void xspi_rx8(struct xilinx_spi *xspi)\r\n{\r\nu32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);\r\nif (xspi->rx_ptr) {\r\n*xspi->rx_ptr = data & 0xff;\r\nxspi->rx_ptr++;\r\n}\r\n}\r\nstatic void xspi_rx16(struct xilinx_spi *xspi)\r\n{\r\nu32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);\r\nif (xspi->rx_ptr) {\r\n*(u16 *)(xspi->rx_ptr) = data & 0xffff;\r\nxspi->rx_ptr += 2;\r\n}\r\n}\r\nstatic void xspi_rx32(struct xilinx_spi *xspi)\r\n{\r\nu32 data = xspi->read_fn(xspi->regs + XSPI_RXD_OFFSET);\r\nif (xspi->rx_ptr) {\r\n*(u32 *)(xspi->rx_ptr) = data;\r\nxspi->rx_ptr += 4;\r\n}\r\n}\r\nstatic void xspi_init_hw(struct xilinx_spi *xspi)\r\n{\r\nvoid __iomem *regs_base = xspi->regs;\r\nxspi->write_fn(XIPIF_V123B_RESET_MASK,\r\nregs_base + XIPIF_V123B_RESETR_OFFSET);\r\nxspi->write_fn(0, regs_base + XIPIF_V123B_IIER_OFFSET);\r\nxspi->write_fn(XIPIF_V123B_GINTR_ENABLE,\r\nregs_base + XIPIF_V123B_DGIER_OFFSET);\r\nxspi->write_fn(0xffff, regs_base + XSPI_SSR_OFFSET);\r\nxspi->write_fn(XSPI_CR_TRANS_INHIBIT | XSPI_CR_MANUAL_SSELECT |\r\nXSPI_CR_MASTER_MODE | XSPI_CR_ENABLE | XSPI_CR_TXFIFO_RESET |\r\nXSPI_CR_RXFIFO_RESET, regs_base + XSPI_CR_OFFSET);\r\n}\r\nstatic void xilinx_spi_chipselect(struct spi_device *spi, int is_on)\r\n{\r\nstruct xilinx_spi *xspi = spi_master_get_devdata(spi->master);\r\nif (is_on == BITBANG_CS_INACTIVE) {\r\nxspi->write_fn(0xffff, xspi->regs + XSPI_SSR_OFFSET);\r\n} else if (is_on == BITBANG_CS_ACTIVE) {\r\nu16 cr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET)\r\n& ~XSPI_CR_MODE_MASK;\r\nif (spi->mode & SPI_CPHA)\r\ncr |= XSPI_CR_CPHA;\r\nif (spi->mode & SPI_CPOL)\r\ncr |= XSPI_CR_CPOL;\r\nxspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);\r\nxspi->write_fn(~(0x0001 << spi->chip_select),\r\nxspi->regs + XSPI_SSR_OFFSET);\r\n}\r\n}\r\nstatic int xilinx_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct xilinx_spi *xspi = spi_master_get_devdata(spi->master);\r\nu8 bits_per_word;\r\nbits_per_word = (t && t->bits_per_word)\r\n? t->bits_per_word : spi->bits_per_word;\r\nif (bits_per_word != xspi->bits_per_word) {\r\ndev_err(&spi->dev, "%s, unsupported bits_per_word=%d\n",\r\n__func__, bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xilinx_spi_setup(struct spi_device *spi)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xilinx_spi_fill_tx_fifo(struct xilinx_spi *xspi)\r\n{\r\nu8 sr;\r\nsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\r\nwhile ((sr & XSPI_SR_TX_FULL_MASK) == 0 && xspi->remaining_bytes > 0) {\r\nif (xspi->tx_ptr)\r\nxspi->tx_fn(xspi);\r\nelse\r\nxspi->write_fn(0, xspi->regs + XSPI_TXD_OFFSET);\r\nxspi->remaining_bytes -= xspi->bits_per_word / 8;\r\nsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\r\n}\r\n}\r\nstatic int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct xilinx_spi *xspi = spi_master_get_devdata(spi->master);\r\nu32 ipif_ier;\r\nu16 cr;\r\nxspi->tx_ptr = t->tx_buf;\r\nxspi->rx_ptr = t->rx_buf;\r\nxspi->remaining_bytes = t->len;\r\nINIT_COMPLETION(xspi->done);\r\nxilinx_spi_fill_tx_fifo(xspi);\r\nipif_ier = xspi->read_fn(xspi->regs + XIPIF_V123B_IIER_OFFSET);\r\nxspi->write_fn(ipif_ier | XSPI_INTR_TX_EMPTY,\r\nxspi->regs + XIPIF_V123B_IIER_OFFSET);\r\ncr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET) &\r\n~XSPI_CR_TRANS_INHIBIT;\r\nxspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);\r\nwait_for_completion(&xspi->done);\r\nxspi->write_fn(ipif_ier, xspi->regs + XIPIF_V123B_IIER_OFFSET);\r\nreturn t->len - xspi->remaining_bytes;\r\n}\r\nstatic irqreturn_t xilinx_spi_irq(int irq, void *dev_id)\r\n{\r\nstruct xilinx_spi *xspi = dev_id;\r\nu32 ipif_isr;\r\nipif_isr = xspi->read_fn(xspi->regs + XIPIF_V123B_IISR_OFFSET);\r\nxspi->write_fn(ipif_isr, xspi->regs + XIPIF_V123B_IISR_OFFSET);\r\nif (ipif_isr & XSPI_INTR_TX_EMPTY) {\r\nu16 cr;\r\nu8 sr;\r\ncr = xspi->read_fn(xspi->regs + XSPI_CR_OFFSET);\r\nxspi->write_fn(cr | XSPI_CR_TRANS_INHIBIT,\r\nxspi->regs + XSPI_CR_OFFSET);\r\nsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\r\nwhile ((sr & XSPI_SR_RX_EMPTY_MASK) == 0) {\r\nxspi->rx_fn(xspi);\r\nsr = xspi->read_fn(xspi->regs + XSPI_SR_OFFSET);\r\n}\r\nif (xspi->remaining_bytes > 0) {\r\nxilinx_spi_fill_tx_fifo(xspi);\r\nxspi->write_fn(cr, xspi->regs + XSPI_CR_OFFSET);\r\n} else {\r\ncomplete(&xspi->done);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct spi_master *xilinx_spi_init(struct device *dev, struct resource *mem,\r\nu32 irq, s16 bus_num, int num_cs, int little_endian, int bits_per_word)\r\n{\r\nstruct spi_master *master;\r\nstruct xilinx_spi *xspi;\r\nint ret;\r\nmaster = spi_alloc_master(dev, sizeof(struct xilinx_spi));\r\nif (!master)\r\nreturn NULL;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nxspi = spi_master_get_devdata(master);\r\nxspi->bitbang.master = spi_master_get(master);\r\nxspi->bitbang.chipselect = xilinx_spi_chipselect;\r\nxspi->bitbang.setup_transfer = xilinx_spi_setup_transfer;\r\nxspi->bitbang.txrx_bufs = xilinx_spi_txrx_bufs;\r\nxspi->bitbang.master->setup = xilinx_spi_setup;\r\ninit_completion(&xspi->done);\r\nif (!request_mem_region(mem->start, resource_size(mem),\r\nXILINX_SPI_NAME))\r\ngoto put_master;\r\nxspi->regs = ioremap(mem->start, resource_size(mem));\r\nif (xspi->regs == NULL) {\r\ndev_warn(dev, "ioremap failure\n");\r\ngoto map_failed;\r\n}\r\nmaster->bus_num = bus_num;\r\nmaster->num_chipselect = num_cs;\r\nmaster->dev.of_node = dev->of_node;\r\nxspi->mem = *mem;\r\nxspi->irq = irq;\r\nif (little_endian) {\r\nxspi->read_fn = xspi_read32;\r\nxspi->write_fn = xspi_write32;\r\n} else {\r\nxspi->read_fn = xspi_read32_be;\r\nxspi->write_fn = xspi_write32_be;\r\n}\r\nxspi->bits_per_word = bits_per_word;\r\nif (xspi->bits_per_word == 8) {\r\nxspi->tx_fn = xspi_tx8;\r\nxspi->rx_fn = xspi_rx8;\r\n} else if (xspi->bits_per_word == 16) {\r\nxspi->tx_fn = xspi_tx16;\r\nxspi->rx_fn = xspi_rx16;\r\n} else if (xspi->bits_per_word == 32) {\r\nxspi->tx_fn = xspi_tx32;\r\nxspi->rx_fn = xspi_rx32;\r\n} else\r\ngoto unmap_io;\r\nxspi_init_hw(xspi);\r\nret = request_irq(xspi->irq, xilinx_spi_irq, 0, XILINX_SPI_NAME, xspi);\r\nif (ret)\r\ngoto unmap_io;\r\nret = spi_bitbang_start(&xspi->bitbang);\r\nif (ret) {\r\ndev_err(dev, "spi_bitbang_start FAILED\n");\r\ngoto free_irq;\r\n}\r\ndev_info(dev, "at 0x%08llX mapped to 0x%p, irq=%d\n",\r\n(unsigned long long)mem->start, xspi->regs, xspi->irq);\r\nreturn master;\r\nfree_irq:\r\nfree_irq(xspi->irq, xspi);\r\nunmap_io:\r\niounmap(xspi->regs);\r\nmap_failed:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nput_master:\r\nspi_master_put(master);\r\nreturn NULL;\r\n}\r\nvoid xilinx_spi_deinit(struct spi_master *master)\r\n{\r\nstruct xilinx_spi *xspi;\r\nxspi = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&xspi->bitbang);\r\nfree_irq(xspi->irq, xspi);\r\niounmap(xspi->regs);\r\nrelease_mem_region(xspi->mem.start, resource_size(&xspi->mem));\r\nspi_master_put(xspi->bitbang.master);\r\n}\r\nstatic int __devinit xilinx_spi_probe(struct platform_device *dev)\r\n{\r\nstruct xspi_platform_data *pdata;\r\nstruct resource *r;\r\nint irq, num_cs = 0, little_endian = 0, bits_per_word = 8;\r\nstruct spi_master *master;\r\nu8 i;\r\npdata = dev->dev.platform_data;\r\nif (pdata) {\r\nnum_cs = pdata->num_chipselect;\r\nlittle_endian = pdata->little_endian;\r\nbits_per_word = pdata->bits_per_word;\r\n}\r\n#ifdef CONFIG_OF\r\nif (dev->dev.of_node) {\r\nconst __be32 *prop;\r\nint len;\r\nprop = of_get_property(dev->dev.of_node, "xlnx,num-ss-bits",\r\n&len);\r\nif (prop && len >= sizeof(*prop))\r\nnum_cs = __be32_to_cpup(prop);\r\n}\r\n#endif\r\nif (!num_cs) {\r\ndev_err(&dev->dev, "Missing slave select configuration data\n");\r\nreturn -EINVAL;\r\n}\r\nr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENODEV;\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0)\r\nreturn -ENXIO;\r\nmaster = xilinx_spi_init(&dev->dev, r, irq, dev->id, num_cs,\r\nlittle_endian, bits_per_word);\r\nif (!master)\r\nreturn -ENODEV;\r\nif (pdata) {\r\nfor (i = 0; i < pdata->num_devices; i++)\r\nspi_new_device(master, pdata->devices + i);\r\n}\r\nplatform_set_drvdata(dev, master);\r\nreturn 0;\r\n}\r\nstatic int __devexit xilinx_spi_remove(struct platform_device *dev)\r\n{\r\nxilinx_spi_deinit(platform_get_drvdata(dev));\r\nplatform_set_drvdata(dev, 0);\r\nreturn 0;\r\n}
