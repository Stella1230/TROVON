static inline void path_get_longterm(struct path *path)\r\n{\r\npath_get(path);\r\nmnt_make_longterm(path->mnt);\r\n}\r\nstatic inline void path_put_longterm(struct path *path)\r\n{\r\nmnt_make_shortterm(path->mnt);\r\npath_put(path);\r\n}\r\nvoid set_fs_root(struct fs_struct *fs, struct path *path)\r\n{\r\nstruct path old_root;\r\npath_get_longterm(path);\r\nspin_lock(&fs->lock);\r\nwrite_seqcount_begin(&fs->seq);\r\nold_root = fs->root;\r\nfs->root = *path;\r\nwrite_seqcount_end(&fs->seq);\r\nspin_unlock(&fs->lock);\r\nif (old_root.dentry)\r\npath_put_longterm(&old_root);\r\n}\r\nvoid set_fs_pwd(struct fs_struct *fs, struct path *path)\r\n{\r\nstruct path old_pwd;\r\npath_get_longterm(path);\r\nspin_lock(&fs->lock);\r\nwrite_seqcount_begin(&fs->seq);\r\nold_pwd = fs->pwd;\r\nfs->pwd = *path;\r\nwrite_seqcount_end(&fs->seq);\r\nspin_unlock(&fs->lock);\r\nif (old_pwd.dentry)\r\npath_put_longterm(&old_pwd);\r\n}\r\nstatic inline int replace_path(struct path *p, const struct path *old, const struct path *new)\r\n{\r\nif (likely(p->dentry != old->dentry || p->mnt != old->mnt))\r\nreturn 0;\r\n*p = *new;\r\nreturn 1;\r\n}\r\nvoid chroot_fs_refs(struct path *old_root, struct path *new_root)\r\n{\r\nstruct task_struct *g, *p;\r\nstruct fs_struct *fs;\r\nint count = 0;\r\nread_lock(&tasklist_lock);\r\ndo_each_thread(g, p) {\r\ntask_lock(p);\r\nfs = p->fs;\r\nif (fs) {\r\nint hits = 0;\r\nspin_lock(&fs->lock);\r\nwrite_seqcount_begin(&fs->seq);\r\nhits += replace_path(&fs->root, old_root, new_root);\r\nhits += replace_path(&fs->pwd, old_root, new_root);\r\nwrite_seqcount_end(&fs->seq);\r\nwhile (hits--) {\r\ncount++;\r\npath_get_longterm(new_root);\r\n}\r\nspin_unlock(&fs->lock);\r\n}\r\ntask_unlock(p);\r\n} while_each_thread(g, p);\r\nread_unlock(&tasklist_lock);\r\nwhile (count--)\r\npath_put_longterm(old_root);\r\n}\r\nvoid free_fs_struct(struct fs_struct *fs)\r\n{\r\npath_put_longterm(&fs->root);\r\npath_put_longterm(&fs->pwd);\r\nkmem_cache_free(fs_cachep, fs);\r\n}\r\nvoid exit_fs(struct task_struct *tsk)\r\n{\r\nstruct fs_struct *fs = tsk->fs;\r\nif (fs) {\r\nint kill;\r\ntask_lock(tsk);\r\nspin_lock(&fs->lock);\r\ntsk->fs = NULL;\r\nkill = !--fs->users;\r\nspin_unlock(&fs->lock);\r\ntask_unlock(tsk);\r\nif (kill)\r\nfree_fs_struct(fs);\r\n}\r\n}\r\nstruct fs_struct *copy_fs_struct(struct fs_struct *old)\r\n{\r\nstruct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);\r\nif (fs) {\r\nfs->users = 1;\r\nfs->in_exec = 0;\r\nspin_lock_init(&fs->lock);\r\nseqcount_init(&fs->seq);\r\nfs->umask = old->umask;\r\nspin_lock(&old->lock);\r\nfs->root = old->root;\r\npath_get_longterm(&fs->root);\r\nfs->pwd = old->pwd;\r\npath_get_longterm(&fs->pwd);\r\nspin_unlock(&old->lock);\r\n}\r\nreturn fs;\r\n}\r\nint unshare_fs_struct(void)\r\n{\r\nstruct fs_struct *fs = current->fs;\r\nstruct fs_struct *new_fs = copy_fs_struct(fs);\r\nint kill;\r\nif (!new_fs)\r\nreturn -ENOMEM;\r\ntask_lock(current);\r\nspin_lock(&fs->lock);\r\nkill = !--fs->users;\r\ncurrent->fs = new_fs;\r\nspin_unlock(&fs->lock);\r\ntask_unlock(current);\r\nif (kill)\r\nfree_fs_struct(fs);\r\nreturn 0;\r\n}\r\nint current_umask(void)\r\n{\r\nreturn current->fs->umask;\r\n}\r\nvoid daemonize_fs_struct(void)\r\n{\r\nstruct fs_struct *fs = current->fs;\r\nif (fs) {\r\nint kill;\r\ntask_lock(current);\r\nspin_lock(&init_fs.lock);\r\ninit_fs.users++;\r\nspin_unlock(&init_fs.lock);\r\nspin_lock(&fs->lock);\r\ncurrent->fs = &init_fs;\r\nkill = !--fs->users;\r\nspin_unlock(&fs->lock);\r\ntask_unlock(current);\r\nif (kill)\r\nfree_fs_struct(fs);\r\n}\r\n}
