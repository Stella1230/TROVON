static ssize_t bin_dir(struct file *file,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nreturn -ENOTDIR;\r\n}\r\nstatic ssize_t bin_string(struct file *file,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nssize_t result, copied = 0;\r\nif (oldval && oldlen) {\r\nchar __user *lastp;\r\nloff_t pos = 0;\r\nint ch;\r\nresult = vfs_read(file, oldval, oldlen, &pos);\r\nif (result < 0)\r\ngoto out;\r\ncopied = result;\r\nlastp = oldval + copied - 1;\r\nresult = -EFAULT;\r\nif (get_user(ch, lastp))\r\ngoto out;\r\nif (ch == '\n') {\r\nresult = -EFAULT;\r\nif (put_user('\0', lastp))\r\ngoto out;\r\ncopied -= 1;\r\n}\r\n}\r\nif (newval && newlen) {\r\nloff_t pos = 0;\r\nresult = vfs_write(file, newval, newlen, &pos);\r\nif (result < 0)\r\ngoto out;\r\n}\r\nresult = copied;\r\nout:\r\nreturn result;\r\n}\r\nstatic ssize_t bin_intvec(struct file *file,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nssize_t copied = 0;\r\nchar *buffer;\r\nssize_t result;\r\nresult = -ENOMEM;\r\nbuffer = kmalloc(BUFSZ, GFP_KERNEL);\r\nif (!buffer)\r\ngoto out;\r\nif (oldval && oldlen) {\r\nunsigned __user *vec = oldval;\r\nsize_t length = oldlen / sizeof(*vec);\r\nloff_t pos = 0;\r\nchar *str, *end;\r\nint i;\r\nset_fs(KERNEL_DS);\r\nresult = vfs_read(file, buffer, BUFSZ - 1, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out_kfree;\r\nstr = buffer;\r\nend = str + result;\r\n*end++ = '\0';\r\nfor (i = 0; i < length; i++) {\r\nunsigned long value;\r\nvalue = simple_strtoul(str, &str, 10);\r\nwhile (isspace(*str))\r\nstr++;\r\nresult = -EFAULT;\r\nif (put_user(value, vec + i))\r\ngoto out_kfree;\r\ncopied += sizeof(*vec);\r\nif (!isdigit(*str))\r\nbreak;\r\n}\r\n}\r\nif (newval && newlen) {\r\nunsigned __user *vec = newval;\r\nsize_t length = newlen / sizeof(*vec);\r\nloff_t pos = 0;\r\nchar *str, *end;\r\nint i;\r\nstr = buffer;\r\nend = str + BUFSZ;\r\nfor (i = 0; i < length; i++) {\r\nunsigned long value;\r\nresult = -EFAULT;\r\nif (get_user(value, vec + i))\r\ngoto out_kfree;\r\nstr += snprintf(str, end - str, "%lu\t", value);\r\n}\r\nset_fs(KERNEL_DS);\r\nresult = vfs_write(file, buffer, str - buffer, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out_kfree;\r\n}\r\nresult = copied;\r\nout_kfree:\r\nkfree(buffer);\r\nout:\r\nreturn result;\r\n}\r\nstatic ssize_t bin_ulongvec(struct file *file,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nssize_t copied = 0;\r\nchar *buffer;\r\nssize_t result;\r\nresult = -ENOMEM;\r\nbuffer = kmalloc(BUFSZ, GFP_KERNEL);\r\nif (!buffer)\r\ngoto out;\r\nif (oldval && oldlen) {\r\nunsigned long __user *vec = oldval;\r\nsize_t length = oldlen / sizeof(*vec);\r\nloff_t pos = 0;\r\nchar *str, *end;\r\nint i;\r\nset_fs(KERNEL_DS);\r\nresult = vfs_read(file, buffer, BUFSZ - 1, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out_kfree;\r\nstr = buffer;\r\nend = str + result;\r\n*end++ = '\0';\r\nfor (i = 0; i < length; i++) {\r\nunsigned long value;\r\nvalue = simple_strtoul(str, &str, 10);\r\nwhile (isspace(*str))\r\nstr++;\r\nresult = -EFAULT;\r\nif (put_user(value, vec + i))\r\ngoto out_kfree;\r\ncopied += sizeof(*vec);\r\nif (!isdigit(*str))\r\nbreak;\r\n}\r\n}\r\nif (newval && newlen) {\r\nunsigned long __user *vec = newval;\r\nsize_t length = newlen / sizeof(*vec);\r\nloff_t pos = 0;\r\nchar *str, *end;\r\nint i;\r\nstr = buffer;\r\nend = str + BUFSZ;\r\nfor (i = 0; i < length; i++) {\r\nunsigned long value;\r\nresult = -EFAULT;\r\nif (get_user(value, vec + i))\r\ngoto out_kfree;\r\nstr += snprintf(str, end - str, "%lu\t", value);\r\n}\r\nset_fs(KERNEL_DS);\r\nresult = vfs_write(file, buffer, str - buffer, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out_kfree;\r\n}\r\nresult = copied;\r\nout_kfree:\r\nkfree(buffer);\r\nout:\r\nreturn result;\r\n}\r\nstatic ssize_t bin_uuid(struct file *file,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nssize_t result, copied = 0;\r\nif (oldval && oldlen) {\r\nloff_t pos = 0;\r\nchar buf[40], *str = buf;\r\nunsigned char uuid[16];\r\nint i;\r\nset_fs(KERNEL_DS);\r\nresult = vfs_read(file, buf, sizeof(buf) - 1, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out;\r\nbuf[result] = '\0';\r\nfor (i = 0; i < 16; i++) {\r\nresult = -EIO;\r\nif (!isxdigit(str[0]) || !isxdigit(str[1]))\r\ngoto out;\r\nuuid[i] = (hex_to_bin(str[0]) << 4) |\r\nhex_to_bin(str[1]);\r\nstr += 2;\r\nif (*str == '-')\r\nstr++;\r\n}\r\nif (oldlen > 16)\r\noldlen = 16;\r\nresult = -EFAULT;\r\nif (copy_to_user(oldval, uuid, oldlen))\r\ngoto out;\r\ncopied = oldlen;\r\n}\r\nresult = copied;\r\nout:\r\nreturn result;\r\n}\r\nstatic ssize_t bin_dn_node_address(struct file *file,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nmm_segment_t old_fs = get_fs();\r\nssize_t result, copied = 0;\r\nif (oldval && oldlen) {\r\nloff_t pos = 0;\r\nchar buf[15], *nodep;\r\nunsigned long area, node;\r\n__le16 dnaddr;\r\nset_fs(KERNEL_DS);\r\nresult = vfs_read(file, buf, sizeof(buf) - 1, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out;\r\nbuf[result] = '\0';\r\nresult = -EIO;\r\nnodep = strchr(buf, '.') + 1;\r\nif (!nodep)\r\ngoto out;\r\narea = simple_strtoul(buf, NULL, 10);\r\nnode = simple_strtoul(nodep, NULL, 10);\r\nresult = -EIO;\r\nif ((area > 63)||(node > 1023))\r\ngoto out;\r\ndnaddr = cpu_to_le16((area << 10) | node);\r\nresult = -EFAULT;\r\nif (put_user(dnaddr, (__le16 __user *)oldval))\r\ngoto out;\r\ncopied = sizeof(dnaddr);\r\n}\r\nif (newval && newlen) {\r\nloff_t pos = 0;\r\n__le16 dnaddr;\r\nchar buf[15];\r\nint len;\r\nresult = -EINVAL;\r\nif (newlen != sizeof(dnaddr))\r\ngoto out;\r\nresult = -EFAULT;\r\nif (get_user(dnaddr, (__le16 __user *)newval))\r\ngoto out;\r\nlen = snprintf(buf, sizeof(buf), "%hu.%hu",\r\nle16_to_cpu(dnaddr) >> 10,\r\nle16_to_cpu(dnaddr) & 0x3ff);\r\nset_fs(KERNEL_DS);\r\nresult = vfs_write(file, buf, len, &pos);\r\nset_fs(old_fs);\r\nif (result < 0)\r\ngoto out;\r\n}\r\nresult = copied;\r\nout:\r\nreturn result;\r\n}\r\nstatic const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\r\n{\r\nconst struct bin_table *table = &bin_root_table[0];\r\nint ctl_name;\r\nmemcpy(path, "sys/", 4);\r\npath += 4;\r\nrepeat:\r\nif (!nlen)\r\nreturn ERR_PTR(-ENOTDIR);\r\nctl_name = *name;\r\nname++;\r\nnlen--;\r\nfor ( ; table->convert; table++) {\r\nint len = 0;\r\nif (!table->ctl_name) {\r\n#ifdef CONFIG_NET\r\nstruct net *net = current->nsproxy->net_ns;\r\nstruct net_device *dev;\r\ndev = dev_get_by_index(net, ctl_name);\r\nif (dev) {\r\nlen = strlen(dev->name);\r\nmemcpy(path, dev->name, len);\r\ndev_put(dev);\r\n}\r\n#endif\r\n} else if (ctl_name == table->ctl_name) {\r\nlen = strlen(table->procname);\r\nmemcpy(path, table->procname, len);\r\n}\r\nif (len) {\r\npath += len;\r\nif (table->child) {\r\n*path++ = '/';\r\ntable = table->child;\r\ngoto repeat;\r\n}\r\n*path = '\0';\r\nreturn table;\r\n}\r\n}\r\nreturn ERR_PTR(-ENOTDIR);\r\n}\r\nstatic char *sysctl_getname(const int *name, int nlen, const struct bin_table **tablep)\r\n{\r\nchar *tmp, *result;\r\nresult = ERR_PTR(-ENOMEM);\r\ntmp = __getname();\r\nif (tmp) {\r\nconst struct bin_table *table = get_sysctl(name, nlen, tmp);\r\nresult = tmp;\r\n*tablep = table;\r\nif (IS_ERR(table)) {\r\n__putname(tmp);\r\nresult = ERR_CAST(table);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic ssize_t binary_sysctl(const int *name, int nlen,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nconst struct bin_table *table = NULL;\r\nstruct vfsmount *mnt;\r\nstruct file *file;\r\nssize_t result;\r\nchar *pathname;\r\nint flags;\r\npathname = sysctl_getname(name, nlen, &table);\r\nresult = PTR_ERR(pathname);\r\nif (IS_ERR(pathname))\r\ngoto out;\r\nif (oldval && oldlen && newval && newlen) {\r\nflags = O_RDWR;\r\n} else if (newval && newlen) {\r\nflags = O_WRONLY;\r\n} else if (oldval && oldlen) {\r\nflags = O_RDONLY;\r\n} else {\r\nresult = 0;\r\ngoto out_putname;\r\n}\r\nmnt = current->nsproxy->pid_ns->proc_mnt;\r\nfile = file_open_root(mnt->mnt_root, mnt, pathname, flags);\r\nresult = PTR_ERR(file);\r\nif (IS_ERR(file))\r\ngoto out_putname;\r\nresult = table->convert(file, oldval, oldlen, newval, newlen);\r\nfput(file);\r\nout_putname:\r\n__putname(pathname);\r\nout:\r\nreturn result;\r\n}\r\nstatic ssize_t binary_sysctl(const int *name, int nlen,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void deprecated_sysctl_warning(const int *name, int nlen)\r\n{\r\nint i;\r\nif (name[0] == CTL_KERN && name[1] == KERN_VERSION)\r\nreturn;\r\nif (printk_ratelimit()) {\r\nprintk(KERN_INFO\r\n"warning: process `%s' used the deprecated sysctl "\r\n"system call with ", current->comm);\r\nfor (i = 0; i < nlen; i++)\r\nprintk("%d.", name[i]);\r\nprintk("\n");\r\n}\r\nreturn;\r\n}\r\nstatic void warn_on_bintable(const int *name, int nlen)\r\n{\r\nint i;\r\nu32 hash = FNV32_OFFSET;\r\nfor (i = 0; i < nlen; i++)\r\nhash = (hash ^ name[i]) * FNV32_PRIME;\r\nhash %= WARN_ONCE_HASH_SIZE;\r\nif (__test_and_set_bit(hash, warn_once_bitmap))\r\nreturn;\r\ndeprecated_sysctl_warning(name, nlen);\r\n}\r\nstatic ssize_t do_sysctl(int __user *args_name, int nlen,\r\nvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\r\n{\r\nint name[CTL_MAXNAME];\r\nint i;\r\nif (nlen < 0 || nlen > CTL_MAXNAME)\r\nreturn -ENOTDIR;\r\nfor (i = 0; i < nlen; i++)\r\nif (get_user(name[i], args_name + i))\r\nreturn -EFAULT;\r\nwarn_on_bintable(name, nlen);\r\nreturn binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);\r\n}\r\nasmlinkage long compat_sys_sysctl(struct compat_sysctl_args __user *args)\r\n{\r\nstruct compat_sysctl_args tmp;\r\ncompat_size_t __user *compat_oldlenp;\r\nsize_t oldlen = 0;\r\nssize_t result;\r\nif (copy_from_user(&tmp, args, sizeof(tmp)))\r\nreturn -EFAULT;\r\nif (tmp.oldval && !tmp.oldlenp)\r\nreturn -EFAULT;\r\ncompat_oldlenp = compat_ptr(tmp.oldlenp);\r\nif (compat_oldlenp && get_user(oldlen, compat_oldlenp))\r\nreturn -EFAULT;\r\nresult = do_sysctl(compat_ptr(tmp.name), tmp.nlen,\r\ncompat_ptr(tmp.oldval), oldlen,\r\ncompat_ptr(tmp.newval), tmp.newlen);\r\nif (result >= 0) {\r\noldlen = result;\r\nresult = 0;\r\n}\r\nif (compat_oldlenp && put_user(oldlen, compat_oldlenp))\r\nreturn -EFAULT;\r\nreturn result;\r\n}
