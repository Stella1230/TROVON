static int arcmsr_adjust_disk_queue_depth(struct scsi_device *sdev,\r\nint queue_depth, int reason)\r\n{\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (queue_depth > ARCMSR_MAX_CMD_PERLUN)\r\nqueue_depth = ARCMSR_MAX_CMD_PERLUN;\r\nscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, queue_depth);\r\nreturn queue_depth;\r\n}\r\nstatic void arcmsr_free_hbb_mu(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:\r\ncase ACB_ADAPTER_TYPE_C:\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B:{\r\ndma_free_coherent(&acb->pdev->dev,\r\nsizeof(struct MessageUnit_B),\r\nacb->pmuB, acb->dma_coherent_handle_hbb_mu);\r\n}\r\n}\r\n}\r\nstatic bool arcmsr_remap_pciregion(struct AdapterControlBlock *acb)\r\n{\r\nstruct pci_dev *pdev = acb->pdev;\r\nswitch (acb->adapter_type){\r\ncase ACB_ADAPTER_TYPE_A:{\r\nacb->pmuA = ioremap(pci_resource_start(pdev,0), pci_resource_len(pdev,0));\r\nif (!acb->pmuA) {\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_B:{\r\nvoid __iomem *mem_base0, *mem_base1;\r\nmem_base0 = ioremap(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\nif (!mem_base0) {\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nmem_base1 = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));\r\nif (!mem_base1) {\r\niounmap(mem_base0);\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nacb->mem_base0 = mem_base0;\r\nacb->mem_base1 = mem_base1;\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_C:{\r\nacb->pmuC = ioremap_nocache(pci_resource_start(pdev, 1), pci_resource_len(pdev, 1));\r\nif (!acb->pmuC) {\r\nprintk(KERN_NOTICE "arcmsr%d: memory mapping region fail \n", acb->host->host_no);\r\nreturn false;\r\n}\r\nif (readl(&acb->pmuC->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &acb->pmuC->outbound_doorbell_clear);\r\nreturn true;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void arcmsr_unmap_pciregion(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:{\r\niounmap(acb->pmuA);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B:{\r\niounmap(acb->mem_base0);\r\niounmap(acb->mem_base1);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:{\r\niounmap(acb->pmuC);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t arcmsr_do_interrupt(int irq, void *dev_id)\r\n{\r\nirqreturn_t handle_state;\r\nstruct AdapterControlBlock *acb = dev_id;\r\nhandle_state = arcmsr_interrupt(acb);\r\nreturn handle_state;\r\n}\r\nstatic int arcmsr_bios_param(struct scsi_device *sdev,\r\nstruct block_device *bdev, sector_t capacity, int *geom)\r\n{\r\nint ret, heads, sectors, cylinders, total_capacity;\r\nunsigned char *buffer;\r\nbuffer = scsi_bios_ptable(bdev);\r\nif (buffer) {\r\nret = scsi_partsize(buffer, capacity, &geom[2], &geom[0], &geom[1]);\r\nkfree(buffer);\r\nif (ret != -1)\r\nreturn ret;\r\n}\r\ntotal_capacity = capacity;\r\nheads = 64;\r\nsectors = 32;\r\ncylinders = total_capacity / (heads * sectors);\r\nif (cylinders > 1024) {\r\nheads = 255;\r\nsectors = 63;\r\ncylinders = total_capacity / (heads * sectors);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic void arcmsr_define_adapter_type(struct AdapterControlBlock *acb)\r\n{\r\nstruct pci_dev *pdev = acb->pdev;\r\nu16 dev_id;\r\npci_read_config_word(pdev, PCI_DEVICE_ID, &dev_id);\r\nacb->dev_id = dev_id;\r\nswitch (dev_id) {\r\ncase 0x1880: {\r\nacb->adapter_type = ACB_ADAPTER_TYPE_C;\r\n}\r\nbreak;\r\ncase 0x1201: {\r\nacb->adapter_type = ACB_ADAPTER_TYPE_B;\r\n}\r\nbreak;\r\ndefault: acb->adapter_type = ACB_ADAPTER_TYPE_A;\r\n}\r\n}\r\nstatic uint8_t arcmsr_hba_wait_msgint_ready(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(&reg->outbound_intstatus) &\r\nARCMSR_MU_OUTBOUND_MESSAGE0_INT) {\r\nwritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT,\r\n&reg->outbound_intstatus);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic uint8_t arcmsr_hbb_wait_msgint_ready(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(reg->iop2drv_doorbell)\r\n& ARCMSR_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN,\r\nreg->iop2drv_doorbell);\r\nwritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT,\r\nreg->drv2iop_doorbell);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic uint8_t arcmsr_hbc_wait_msgint_ready(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C *phbcmu = (struct MessageUnit_C *)pACB->pmuC;\r\nint i;\r\nfor (i = 0; i < 2000; i++) {\r\nif (readl(&phbcmu->outbound_doorbell)\r\n& ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR,\r\n&phbcmu->outbound_doorbell_clear);\r\nreturn true;\r\n}\r\nmsleep(10);\r\n}\r\nreturn false;\r\n}\r\nstatic void arcmsr_flush_hba_cache(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nint retry_count = 30;\r\nwritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\r\ndo {\r\nif (arcmsr_hba_wait_msgint_ready(acb))\r\nbreak;\r\nelse {\r\nretry_count--;\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'flush adapter cache' \\r\ntimeout, retry count down = %d \n", acb->host->host_no, retry_count);\r\n}\r\n} while (retry_count != 0);\r\n}\r\nstatic void arcmsr_flush_hbb_cache(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nint retry_count = 30;\r\nwritel(ARCMSR_MESSAGE_FLUSH_CACHE, reg->drv2iop_doorbell);\r\ndo {\r\nif (arcmsr_hbb_wait_msgint_ready(acb))\r\nbreak;\r\nelse {\r\nretry_count--;\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'flush adapter cache' \\r\ntimeout,retry count down = %d \n", acb->host->host_no, retry_count);\r\n}\r\n} while (retry_count != 0);\r\n}\r\nstatic void arcmsr_flush_hbc_cache(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)pACB->pmuC;\r\nint retry_count = 30;\r\nwritel(ARCMSR_INBOUND_MESG0_FLUSH_CACHE, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\ndo {\r\nif (arcmsr_hbc_wait_msgint_ready(pACB)) {\r\nbreak;\r\n} else {\r\nretry_count--;\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'flush adapter cache' \\r\ntimeout,retry count down = %d \n", pACB->host->host_no, retry_count);\r\n}\r\n} while (retry_count != 0);\r\nreturn;\r\n}\r\nstatic void arcmsr_flush_adapter_cache(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\narcmsr_flush_hba_cache(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\narcmsr_flush_hbb_cache(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\narcmsr_flush_hbc_cache(acb);\r\n}\r\n}\r\n}\r\nstatic int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\r\n{\r\nstruct pci_dev *pdev = acb->pdev;\r\nvoid *dma_coherent;\r\ndma_addr_t dma_coherent_handle;\r\nstruct CommandControlBlock *ccb_tmp;\r\nint i = 0, j = 0;\r\ndma_addr_t cdb_phyaddr;\r\nunsigned long roundup_ccbsize;\r\nunsigned long max_xfer_len;\r\nunsigned long max_sg_entrys;\r\nuint32_t firm_config_version;\r\nfor (i = 0; i < ARCMSR_MAX_TARGETID; i++)\r\nfor (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\r\nacb->devstate[i][j] = ARECA_RAID_GONE;\r\nmax_xfer_len = ARCMSR_MAX_XFER_LEN;\r\nmax_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\r\nfirm_config_version = acb->firm_cfg_version;\r\nif((firm_config_version & 0xFF) >= 3){\r\nmax_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;\r\nmax_sg_entrys = (max_xfer_len/4096);\r\n}\r\nacb->host->max_sectors = max_xfer_len/512;\r\nacb->host->sg_tablesize = max_sg_entrys;\r\nroundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\r\nacb->uncache_size = roundup_ccbsize * ARCMSR_MAX_FREECCB_NUM;\r\ndma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\r\nif(!dma_coherent){\r\nprintk(KERN_NOTICE "arcmsr%d: dma_alloc_coherent got error\n", acb->host->host_no);\r\nreturn -ENOMEM;\r\n}\r\nacb->dma_coherent = dma_coherent;\r\nacb->dma_coherent_handle = dma_coherent_handle;\r\nmemset(dma_coherent, 0, acb->uncache_size);\r\nccb_tmp = dma_coherent;\r\nacb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\r\nfor(i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++){\r\ncdb_phyaddr = dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\r\nccb_tmp->cdb_phyaddr_pattern = ((acb->adapter_type == ACB_ADAPTER_TYPE_C) ? cdb_phyaddr : (cdb_phyaddr >> 5));\r\nacb->pccb_pool[i] = ccb_tmp;\r\nccb_tmp->acb = acb;\r\nINIT_LIST_HEAD(&ccb_tmp->list);\r\nlist_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\r\nccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\r\ndma_coherent_handle = dma_coherent_handle + roundup_ccbsize;\r\n}\r\nreturn 0;\r\n}\r\nstatic void arcmsr_message_isr_bh_fn(struct work_struct *work)\r\n{\r\nstruct AdapterControlBlock *acb = container_of(work,struct AdapterControlBlock, arcmsr_do_message_isr_bh);\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nchar *acb_dev_map = (char *)acb->device_map;\r\nuint32_t __iomem *signature = (uint32_t __iomem*) (&reg->message_rwbuffer[0]);\r\nchar __iomem *devicemap = (char __iomem*) (&reg->message_rwbuffer[21]);\r\nint target, lun;\r\nstruct scsi_device *psdev;\r\nchar diff;\r\natomic_inc(&acb->rq_map_token);\r\nif (readl(signature) == ARCMSR_SIGNATURE_GET_CONFIG) {\r\nfor(target = 0; target < ARCMSR_MAX_TARGETID -1; target++) {\r\ndiff = (*acb_dev_map)^readb(devicemap);\r\nif (diff != 0) {\r\nchar temp;\r\n*acb_dev_map = readb(devicemap);\r\ntemp =*acb_dev_map;\r\nfor(lun = 0; lun < ARCMSR_MAX_TARGETLUN; lun++) {\r\nif((temp & 0x01)==1 && (diff & 0x01) == 1) {\r\nscsi_add_device(acb->host, 0, target, lun);\r\n}else if((temp & 0x01) == 0 && (diff & 0x01) == 1) {\r\npsdev = scsi_device_lookup(acb->host, 0, target, lun);\r\nif (psdev != NULL ) {\r\nscsi_remove_device(psdev);\r\nscsi_device_put(psdev);\r\n}\r\n}\r\ntemp >>= 1;\r\ndiff >>= 1;\r\n}\r\n}\r\ndevicemap++;\r\nacb_dev_map++;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nchar *acb_dev_map = (char *)acb->device_map;\r\nuint32_t __iomem *signature = (uint32_t __iomem*)(&reg->message_rwbuffer[0]);\r\nchar __iomem *devicemap = (char __iomem*)(&reg->message_rwbuffer[21]);\r\nint target, lun;\r\nstruct scsi_device *psdev;\r\nchar diff;\r\natomic_inc(&acb->rq_map_token);\r\nif (readl(signature) == ARCMSR_SIGNATURE_GET_CONFIG) {\r\nfor(target = 0; target < ARCMSR_MAX_TARGETID -1; target++) {\r\ndiff = (*acb_dev_map)^readb(devicemap);\r\nif (diff != 0) {\r\nchar temp;\r\n*acb_dev_map = readb(devicemap);\r\ntemp =*acb_dev_map;\r\nfor(lun = 0; lun < ARCMSR_MAX_TARGETLUN; lun++) {\r\nif((temp & 0x01)==1 && (diff & 0x01) == 1) {\r\nscsi_add_device(acb->host, 0, target, lun);\r\n}else if((temp & 0x01) == 0 && (diff & 0x01) == 1) {\r\npsdev = scsi_device_lookup(acb->host, 0, target, lun);\r\nif (psdev != NULL ) {\r\nscsi_remove_device(psdev);\r\nscsi_device_put(psdev);\r\n}\r\n}\r\ntemp >>= 1;\r\ndiff >>= 1;\r\n}\r\n}\r\ndevicemap++;\r\nacb_dev_map++;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *reg = acb->pmuC;\r\nchar *acb_dev_map = (char *)acb->device_map;\r\nuint32_t __iomem *signature = (uint32_t __iomem *)(&reg->msgcode_rwbuffer[0]);\r\nchar __iomem *devicemap = (char __iomem *)(&reg->msgcode_rwbuffer[21]);\r\nint target, lun;\r\nstruct scsi_device *psdev;\r\nchar diff;\r\natomic_inc(&acb->rq_map_token);\r\nif (readl(signature) == ARCMSR_SIGNATURE_GET_CONFIG) {\r\nfor (target = 0; target < ARCMSR_MAX_TARGETID - 1; target++) {\r\ndiff = (*acb_dev_map)^readb(devicemap);\r\nif (diff != 0) {\r\nchar temp;\r\n*acb_dev_map = readb(devicemap);\r\ntemp = *acb_dev_map;\r\nfor (lun = 0; lun < ARCMSR_MAX_TARGETLUN; lun++) {\r\nif ((temp & 0x01) == 1 && (diff & 0x01) == 1) {\r\nscsi_add_device(acb->host, 0, target, lun);\r\n} else if ((temp & 0x01) == 0 && (diff & 0x01) == 1) {\r\npsdev = scsi_device_lookup(acb->host, 0, target, lun);\r\nif (psdev != NULL) {\r\nscsi_remove_device(psdev);\r\nscsi_device_put(psdev);\r\n}\r\n}\r\ntemp >>= 1;\r\ndiff >>= 1;\r\n}\r\n}\r\ndevicemap++;\r\nacb_dev_map++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int arcmsr_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct AdapterControlBlock *acb;\r\nuint8_t bus,dev_fun;\r\nint error;\r\nerror = pci_enable_device(pdev);\r\nif(error){\r\nreturn -ENODEV;\r\n}\r\nhost = scsi_host_alloc(&arcmsr_scsi_host_template, sizeof(struct AdapterControlBlock));\r\nif(!host){\r\ngoto pci_disable_dev;\r\n}\r\nerror = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif(error){\r\nerror = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif(error){\r\nprintk(KERN_WARNING\r\n"scsi%d: No suitable DMA mask available\n",\r\nhost->host_no);\r\ngoto scsi_host_release;\r\n}\r\n}\r\ninit_waitqueue_head(&wait_q);\r\nbus = pdev->bus->number;\r\ndev_fun = pdev->devfn;\r\nacb = (struct AdapterControlBlock *) host->hostdata;\r\nmemset(acb,0,sizeof(struct AdapterControlBlock));\r\nacb->pdev = pdev;\r\nacb->host = host;\r\nhost->max_lun = ARCMSR_MAX_TARGETLUN;\r\nhost->max_id = ARCMSR_MAX_TARGETID;\r\nhost->max_cmd_len = 16;\r\nhost->can_queue = ARCMSR_MAX_FREECCB_NUM;\r\nhost->cmd_per_lun = ARCMSR_MAX_CMD_PERLUN;\r\nhost->this_id = ARCMSR_SCSI_INITIATOR_ID;\r\nhost->unique_id = (bus << 8) | dev_fun;\r\npci_set_drvdata(pdev, host);\r\npci_set_master(pdev);\r\nerror = pci_request_regions(pdev, "arcmsr");\r\nif(error){\r\ngoto scsi_host_release;\r\n}\r\nspin_lock_init(&acb->eh_lock);\r\nspin_lock_init(&acb->ccblist_lock);\r\nacb->acb_flags |= (ACB_F_MESSAGE_WQBUFFER_CLEARED |\r\nACB_F_MESSAGE_RQBUFFER_CLEARED |\r\nACB_F_MESSAGE_WQBUFFER_READED);\r\nacb->acb_flags &= ~ACB_F_SCSISTOPADAPTER;\r\nINIT_LIST_HEAD(&acb->ccb_free_list);\r\narcmsr_define_adapter_type(acb);\r\nerror = arcmsr_remap_pciregion(acb);\r\nif(!error){\r\ngoto pci_release_regs;\r\n}\r\nerror = arcmsr_get_firmware_spec(acb);\r\nif(!error){\r\ngoto unmap_pci_region;\r\n}\r\nerror = arcmsr_alloc_ccb_pool(acb);\r\nif(error){\r\ngoto free_hbb_mu;\r\n}\r\narcmsr_iop_init(acb);\r\nerror = scsi_add_host(host, &pdev->dev);\r\nif(error){\r\ngoto RAID_controller_stop;\r\n}\r\nerror = request_irq(pdev->irq, arcmsr_do_interrupt, IRQF_SHARED, "arcmsr", acb);\r\nif(error){\r\ngoto scsi_host_remove;\r\n}\r\nhost->irq = pdev->irq;\r\nscsi_scan_host(host);\r\nINIT_WORK(&acb->arcmsr_do_message_isr_bh, arcmsr_message_isr_bh_fn);\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\ninit_timer(&acb->eternal_timer);\r\nacb->eternal_timer.expires = jiffies + msecs_to_jiffies(6 * HZ);\r\nacb->eternal_timer.data = (unsigned long) acb;\r\nacb->eternal_timer.function = &arcmsr_request_device_map;\r\nadd_timer(&acb->eternal_timer);\r\nif(arcmsr_alloc_sysfs_attr(acb))\r\ngoto out_free_sysfs;\r\nreturn 0;\r\nout_free_sysfs:\r\nscsi_host_remove:\r\nscsi_remove_host(host);\r\nRAID_controller_stop:\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\narcmsr_free_ccb_pool(acb);\r\nfree_hbb_mu:\r\narcmsr_free_hbb_mu(acb);\r\nunmap_pci_region:\r\narcmsr_unmap_pciregion(acb);\r\npci_release_regs:\r\npci_release_regions(pdev);\r\nscsi_host_release:\r\nscsi_host_put(host);\r\npci_disable_dev:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic uint8_t arcmsr_abort_hba_allcmd(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\r\nif (!arcmsr_hba_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'abort all outstanding command' timeout \n"\r\n, acb->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_abort_hbb_allcmd(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_MESSAGE_ABORT_CMD, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'abort all outstanding command' timeout \n"\r\n, acb->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_abort_hbc_allcmd(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)pACB->pmuC;\r\nwritel(ARCMSR_INBOUND_MESG0_ABORT_CMD, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nif (!arcmsr_hbc_wait_msgint_ready(pACB)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'abort all outstanding command' timeout \n"\r\n, pACB->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic uint8_t arcmsr_abort_allcmd(struct AdapterControlBlock *acb)\r\n{\r\nuint8_t rtnval = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nrtnval = arcmsr_abort_hba_allcmd(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nrtnval = arcmsr_abort_hbb_allcmd(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nrtnval = arcmsr_abort_hbc_allcmd(acb);\r\n}\r\n}\r\nreturn rtnval;\r\n}\r\nstatic bool arcmsr_hbb_enable_driver_mode(struct AdapterControlBlock *pacb)\r\n{\r\nstruct MessageUnit_B *reg = pacb->pmuB;\r\nwritel(ARCMSR_MESSAGE_START_DRIVER_MODE, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(pacb)) {\r\nprintk(KERN_ERR "arcmsr%d: can't set driver mode. \n", pacb->host->host_no);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void arcmsr_pci_unmap_dma(struct CommandControlBlock *ccb)\r\n{\r\nstruct scsi_cmnd *pcmd = ccb->pcmd;\r\nscsi_dma_unmap(pcmd);\r\n}\r\nstatic void arcmsr_ccb_complete(struct CommandControlBlock *ccb)\r\n{\r\nstruct AdapterControlBlock *acb = ccb->acb;\r\nstruct scsi_cmnd *pcmd = ccb->pcmd;\r\nunsigned long flags;\r\natomic_dec(&acb->ccboutstandingcount);\r\narcmsr_pci_unmap_dma(ccb);\r\nccb->startdone = ARCMSR_CCB_DONE;\r\nspin_lock_irqsave(&acb->ccblist_lock, flags);\r\nlist_add_tail(&ccb->list, &acb->ccb_free_list);\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\npcmd->scsi_done(pcmd);\r\n}\r\nstatic void arcmsr_report_sense_info(struct CommandControlBlock *ccb)\r\n{\r\nstruct scsi_cmnd *pcmd = ccb->pcmd;\r\nstruct SENSE_DATA *sensebuffer = (struct SENSE_DATA *)pcmd->sense_buffer;\r\npcmd->result = DID_OK << 16;\r\nif (sensebuffer) {\r\nint sense_data_length =\r\nsizeof(struct SENSE_DATA) < SCSI_SENSE_BUFFERSIZE\r\n? sizeof(struct SENSE_DATA) : SCSI_SENSE_BUFFERSIZE;\r\nmemset(sensebuffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nmemcpy(sensebuffer, ccb->arcmsr_cdb.SenseData, sense_data_length);\r\nsensebuffer->ErrorCode = SCSI_SENSE_CURRENT_ERRORS;\r\nsensebuffer->Valid = 1;\r\n}\r\n}\r\nstatic u32 arcmsr_disable_outbound_ints(struct AdapterControlBlock *acb)\r\n{\r\nu32 orig_mask = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A : {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\norig_mask = readl(&reg->outbound_intmask);\r\nwritel(orig_mask|ARCMSR_MU_OUTBOUND_ALL_INTMASKENABLE, \\r\n&reg->outbound_intmask);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B : {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\norig_mask = readl(reg->iop2drv_doorbell_mask);\r\nwritel(0, reg->iop2drv_doorbell_mask);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:{\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)acb->pmuC;\r\norig_mask = readl(&reg->host_int_mask);\r\nwritel(orig_mask|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\r\n}\r\nbreak;\r\n}\r\nreturn orig_mask;\r\n}\r\nstatic void arcmsr_report_ccb_state(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *ccb, bool error)\r\n{\r\nuint8_t id, lun;\r\nid = ccb->pcmd->device->id;\r\nlun = ccb->pcmd->device->lun;\r\nif (!error) {\r\nif (acb->devstate[id][lun] == ARECA_RAID_GONE)\r\nacb->devstate[id][lun] = ARECA_RAID_GOOD;\r\nccb->pcmd->result = DID_OK << 16;\r\narcmsr_ccb_complete(ccb);\r\n}else{\r\nswitch (ccb->arcmsr_cdb.DeviceStatus) {\r\ncase ARCMSR_DEV_SELECT_TIMEOUT: {\r\nacb->devstate[id][lun] = ARECA_RAID_GONE;\r\nccb->pcmd->result = DID_NO_CONNECT << 16;\r\narcmsr_ccb_complete(ccb);\r\n}\r\nbreak;\r\ncase ARCMSR_DEV_ABORTED:\r\ncase ARCMSR_DEV_INIT_FAIL: {\r\nacb->devstate[id][lun] = ARECA_RAID_GONE;\r\nccb->pcmd->result = DID_BAD_TARGET << 16;\r\narcmsr_ccb_complete(ccb);\r\n}\r\nbreak;\r\ncase ARCMSR_DEV_CHECK_CONDITION: {\r\nacb->devstate[id][lun] = ARECA_RAID_GOOD;\r\narcmsr_report_sense_info(ccb);\r\narcmsr_ccb_complete(ccb);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: scsi id = %d lun = %d isr get command error done, \\r\nbut got unknown DeviceStatus = 0x%x \n"\r\n, acb->host->host_no\r\n, id\r\n, lun\r\n, ccb->arcmsr_cdb.DeviceStatus);\r\nacb->devstate[id][lun] = ARECA_RAID_GONE;\r\nccb->pcmd->result = DID_NO_CONNECT << 16;\r\narcmsr_ccb_complete(ccb);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error)\r\n{\r\nint id, lun;\r\nif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\r\nif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\r\nstruct scsi_cmnd *abortcmd = pCCB->pcmd;\r\nif (abortcmd) {\r\nid = abortcmd->device->id;\r\nlun = abortcmd->device->lun;\r\nabortcmd->result |= DID_ABORT << 16;\r\narcmsr_ccb_complete(pCCB);\r\nprintk(KERN_NOTICE "arcmsr%d: pCCB ='0x%p' isr got aborted command \n",\r\nacb->host->host_no, pCCB);\r\n}\r\nreturn;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: isr get an illegal ccb command \\r\ndone acb = '0x%p'"\r\n"ccb = '0x%p' ccbacb = '0x%p' startdone = 0x%x"\r\n" ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, acb\r\n, pCCB\r\n, pCCB->acb\r\n, pCCB->startdone\r\n, atomic_read(&acb->ccboutstandingcount));\r\nreturn;\r\n}\r\narcmsr_report_ccb_state(acb, pCCB, error);\r\n}\r\nstatic void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb)\r\n{\r\nint i = 0;\r\nuint32_t flag_ccb;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nbool error;\r\nstruct CommandControlBlock *pCCB;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nuint32_t outbound_intstatus;\r\noutbound_intstatus = readl(&reg->outbound_intstatus) &\r\nacb->outbound_int_enable;\r\nwritel(outbound_intstatus, &reg->outbound_intstatus);\r\nwhile(((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF)\r\n&& (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nfor (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) {\r\nif ((flag_ccb = readl(&reg->done_qbuffer[i])) != 0) {\r\nwritel(0, &reg->done_qbuffer[i]);\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\nreg->post_qbuffer[i] = 0;\r\n}\r\nreg->doneq_index = 0;\r\nreg->postq_index = 0;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *reg = acb->pmuC;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nuint32_t flag_ccb, ccb_cdb_phy;\r\nbool error;\r\nstruct CommandControlBlock *pCCB;\r\nwhile ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) && (i++ < ARCMSR_MAX_OUTSTANDING_CMD)) {\r\nflag_ccb = readl(&reg->outbound_queueport_low);\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+ccb_cdb_phy);\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\n}\r\n}\r\n}\r\nstatic void arcmsr_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *) host->hostdata;\r\nint poll_count = 0;\r\narcmsr_free_sysfs_attr(acb);\r\nscsi_remove_host(host);\r\nflush_work_sync(&acb->arcmsr_do_message_isr_bh);\r\ndel_timer_sync(&acb->eternal_timer);\r\narcmsr_disable_outbound_ints(acb);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\nacb->acb_flags |= ACB_F_SCSISTOPADAPTER;\r\nacb->acb_flags &= ~ACB_F_IOP_INITED;\r\nfor (poll_count = 0; poll_count < ARCMSR_MAX_OUTSTANDING_CMD; poll_count++){\r\nif (!atomic_read(&acb->ccboutstandingcount))\r\nbreak;\r\narcmsr_interrupt(acb);\r\nmsleep(25);\r\n}\r\nif (atomic_read(&acb->ccboutstandingcount)) {\r\nint i;\r\narcmsr_abort_allcmd(acb);\r\narcmsr_done4abort_postqueue(acb);\r\nfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\r\nstruct CommandControlBlock *ccb = acb->pccb_pool[i];\r\nif (ccb->startdone == ARCMSR_CCB_START) {\r\nccb->startdone = ARCMSR_CCB_ABORTED;\r\nccb->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(ccb);\r\n}\r\n}\r\n}\r\nfree_irq(pdev->irq, acb);\r\narcmsr_free_ccb_pool(acb);\r\narcmsr_free_hbb_mu(acb);\r\narcmsr_unmap_pciregion(acb);\r\npci_release_regions(pdev);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic void arcmsr_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *)host->hostdata;\r\ndel_timer_sync(&acb->eternal_timer);\r\narcmsr_disable_outbound_ints(acb);\r\nflush_work_sync(&acb->arcmsr_do_message_isr_bh);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\n}\r\nstatic int arcmsr_module_init(void)\r\n{\r\nint error = 0;\r\nerror = pci_register_driver(&arcmsr_pci_driver);\r\nreturn error;\r\n}\r\nstatic void arcmsr_module_exit(void)\r\n{\r\npci_unregister_driver(&arcmsr_pci_driver);\r\n}\r\nstatic void arcmsr_enable_outbound_ints(struct AdapterControlBlock *acb,\r\nu32 intmask_org)\r\n{\r\nu32 mask;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nmask = intmask_org & ~(ARCMSR_MU_OUTBOUND_POSTQUEUE_INTMASKENABLE |\r\nARCMSR_MU_OUTBOUND_DOORBELL_INTMASKENABLE|\r\nARCMSR_MU_OUTBOUND_MESSAGE0_INTMASKENABLE);\r\nwritel(mask, &reg->outbound_intmask);\r\nacb->outbound_int_enable = ~(intmask_org & mask) & 0x000000ff;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nmask = intmask_org | (ARCMSR_IOP2DRV_DATA_WRITE_OK |\r\nARCMSR_IOP2DRV_DATA_READ_OK |\r\nARCMSR_IOP2DRV_CDB_DONE |\r\nARCMSR_IOP2DRV_MESSAGE_CMD_DONE);\r\nwritel(mask, reg->iop2drv_doorbell_mask);\r\nacb->outbound_int_enable = (intmask_org | mask) & 0x0000000f;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *reg = acb->pmuC;\r\nmask = ~(ARCMSR_HBCMU_UTILITY_A_ISR_MASK | ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR_MASK|ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR_MASK);\r\nwritel(intmask_org & mask, &reg->host_int_mask);\r\nacb->outbound_int_enable = ~(intmask_org & mask) & 0x0000000f;\r\n}\r\n}\r\n}\r\nstatic int arcmsr_build_ccb(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *ccb, struct scsi_cmnd *pcmd)\r\n{\r\nstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\r\nint8_t *psge = (int8_t *)&arcmsr_cdb->u;\r\n__le32 address_lo, address_hi;\r\nint arccdbsize = 0x30;\r\n__le32 length = 0;\r\nint i;\r\nstruct scatterlist *sg;\r\nint nseg;\r\nccb->pcmd = pcmd;\r\nmemset(arcmsr_cdb, 0, sizeof(struct ARCMSR_CDB));\r\narcmsr_cdb->TargetID = pcmd->device->id;\r\narcmsr_cdb->LUN = pcmd->device->lun;\r\narcmsr_cdb->Function = 1;\r\narcmsr_cdb->Context = 0;\r\nmemcpy(arcmsr_cdb->Cdb, pcmd->cmnd, pcmd->cmd_len);\r\nnseg = scsi_dma_map(pcmd);\r\nif (unlikely(nseg > acb->host->sg_tablesize || nseg < 0))\r\nreturn FAILED;\r\nscsi_for_each_sg(pcmd, sg, nseg, i) {\r\nlength = cpu_to_le32(sg_dma_len(sg));\r\naddress_lo = cpu_to_le32(dma_addr_lo32(sg_dma_address(sg)));\r\naddress_hi = cpu_to_le32(dma_addr_hi32(sg_dma_address(sg)));\r\nif (address_hi == 0) {\r\nstruct SG32ENTRY *pdma_sg = (struct SG32ENTRY *)psge;\r\npdma_sg->address = address_lo;\r\npdma_sg->length = length;\r\npsge += sizeof (struct SG32ENTRY);\r\narccdbsize += sizeof (struct SG32ENTRY);\r\n} else {\r\nstruct SG64ENTRY *pdma_sg = (struct SG64ENTRY *)psge;\r\npdma_sg->addresshigh = address_hi;\r\npdma_sg->address = address_lo;\r\npdma_sg->length = length|cpu_to_le32(IS_SG64_ADDR);\r\npsge += sizeof (struct SG64ENTRY);\r\narccdbsize += sizeof (struct SG64ENTRY);\r\n}\r\n}\r\narcmsr_cdb->sgcount = (uint8_t)nseg;\r\narcmsr_cdb->DataLength = scsi_bufflen(pcmd);\r\narcmsr_cdb->msgPages = arccdbsize/0x100 + (arccdbsize % 0x100 ? 1 : 0);\r\nif ( arccdbsize > 256)\r\narcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_SGL_BSIZE;\r\nif (pcmd->sc_data_direction == DMA_TO_DEVICE)\r\narcmsr_cdb->Flags |= ARCMSR_CDB_FLAG_WRITE;\r\nccb->arc_cdb_size = arccdbsize;\r\nreturn SUCCESS;\r\n}\r\nstatic void arcmsr_post_ccb(struct AdapterControlBlock *acb, struct CommandControlBlock *ccb)\r\n{\r\nuint32_t cdb_phyaddr_pattern = ccb->cdb_phyaddr_pattern;\r\nstruct ARCMSR_CDB *arcmsr_cdb = (struct ARCMSR_CDB *)&ccb->arcmsr_cdb;\r\natomic_inc(&acb->ccboutstandingcount);\r\nccb->startdone = ARCMSR_CCB_START;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE)\r\nwritel(cdb_phyaddr_pattern | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\r\n&reg->inbound_queueport);\r\nelse {\r\nwritel(cdb_phyaddr_pattern, &reg->inbound_queueport);\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nuint32_t ending_index, index = reg->postq_index;\r\nending_index = ((index + 1) % ARCMSR_MAX_HBB_POSTQUEUE);\r\nwritel(0, &reg->post_qbuffer[ending_index]);\r\nif (arcmsr_cdb->Flags & ARCMSR_CDB_FLAG_SGL_BSIZE) {\r\nwritel(cdb_phyaddr_pattern | ARCMSR_CCBPOST_FLAG_SGL_BSIZE,\\r\n&reg->post_qbuffer[index]);\r\n} else {\r\nwritel(cdb_phyaddr_pattern, &reg->post_qbuffer[index]);\r\n}\r\nindex++;\r\nindex %= ARCMSR_MAX_HBB_POSTQUEUE;\r\nreg->postq_index = index;\r\nwritel(ARCMSR_DRV2IOP_CDB_POSTED, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *phbcmu = (struct MessageUnit_C *)acb->pmuC;\r\nuint32_t ccb_post_stamp, arc_cdb_size;\r\narc_cdb_size = (ccb->arc_cdb_size > 0x300) ? 0x300 : ccb->arc_cdb_size;\r\nccb_post_stamp = (cdb_phyaddr_pattern | ((arc_cdb_size - 1) >> 6) | 1);\r\nif (acb->cdb_phyaddr_hi32) {\r\nwritel(acb->cdb_phyaddr_hi32, &phbcmu->inbound_queueport_high);\r\nwritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\r\n} else {\r\nwritel(ccb_post_stamp, &phbcmu->inbound_queueport_low);\r\n}\r\n}\r\n}\r\n}\r\nstatic void arcmsr_stop_hba_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\r\nif (!arcmsr_hba_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"\r\n, acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_stop_hbb_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_MESSAGE_STOP_BGRB, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"\r\n, acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_stop_hbc_bgrb(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)pACB->pmuC;\r\npACB->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_STOP_BGRB, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nif (!arcmsr_hbc_wait_msgint_ready(pACB)) {\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: wait 'stop adapter background rebulid' timeout \n"\r\n, pACB->host->host_no);\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_stop_adapter_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\narcmsr_stop_hba_bgrb(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\narcmsr_stop_hbb_bgrb(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\narcmsr_stop_hbc_bgrb(acb);\r\n}\r\n}\r\n}\r\nstatic void arcmsr_free_ccb_pool(struct AdapterControlBlock *acb)\r\n{\r\ndma_free_coherent(&acb->pdev->dev, acb->uncache_size, acb->dma_coherent, acb->dma_coherent_handle);\r\n}\r\nvoid arcmsr_iop_message_read(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nwritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\r\n}\r\n}\r\n}\r\nstatic void arcmsr_iop_message_wrote(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nwritel(ARCMSR_INBOUND_DRIVER_DATA_WRITE_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_DRV2IOP_DATA_WRITE_OK, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nwritel(ARCMSR_HBCMU_DRV2IOP_DATA_WRITE_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\n}\r\n}\r\nstruct QBUFFER __iomem *arcmsr_get_iop_rqbuffer(struct AdapterControlBlock *acb)\r\n{\r\nstruct QBUFFER __iomem *qbuffer = NULL;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nqbuffer = (struct QBUFFER __iomem *)&reg->message_rbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nqbuffer = (struct QBUFFER __iomem *)reg->message_rbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *phbcmu = (struct MessageUnit_C *)acb->pmuC;\r\nqbuffer = (struct QBUFFER __iomem *)&phbcmu->message_rbuffer;\r\n}\r\n}\r\nreturn qbuffer;\r\n}\r\nstatic struct QBUFFER __iomem *arcmsr_get_iop_wqbuffer(struct AdapterControlBlock *acb)\r\n{\r\nstruct QBUFFER __iomem *pqbuffer = NULL;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\npqbuffer = (struct QBUFFER __iomem *) &reg->message_wbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\npqbuffer = (struct QBUFFER __iomem *)reg->message_wbuffer;\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)acb->pmuC;\r\npqbuffer = (struct QBUFFER __iomem *)&reg->message_wbuffer;\r\n}\r\n}\r\nreturn pqbuffer;\r\n}\r\nstatic void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)\r\n{\r\nstruct QBUFFER __iomem *prbuffer;\r\nstruct QBUFFER *pQbuffer;\r\nuint8_t __iomem *iop_data;\r\nint32_t my_empty_len, iop_len, rqbuf_firstindex, rqbuf_lastindex;\r\nrqbuf_lastindex = acb->rqbuf_lastindex;\r\nrqbuf_firstindex = acb->rqbuf_firstindex;\r\nprbuffer = arcmsr_get_iop_rqbuffer(acb);\r\niop_data = (uint8_t __iomem *)prbuffer->data;\r\niop_len = prbuffer->data_len;\r\nmy_empty_len = (rqbuf_firstindex - rqbuf_lastindex - 1) & (ARCMSR_MAX_QBUFFER - 1);\r\nif (my_empty_len >= iop_len)\r\n{\r\nwhile (iop_len > 0) {\r\npQbuffer = (struct QBUFFER *)&acb->rqbuffer[rqbuf_lastindex];\r\nmemcpy(pQbuffer, iop_data, 1);\r\nrqbuf_lastindex++;\r\nrqbuf_lastindex %= ARCMSR_MAX_QBUFFER;\r\niop_data++;\r\niop_len--;\r\n}\r\nacb->rqbuf_lastindex = rqbuf_lastindex;\r\narcmsr_iop_message_read(acb);\r\n}\r\nelse {\r\nacb->acb_flags |= ACB_F_IOPDATA_OVERFLOW;\r\n}\r\n}\r\nstatic void arcmsr_iop2drv_data_read_handle(struct AdapterControlBlock *acb)\r\n{\r\nacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_READED;\r\nif (acb->wqbuf_firstindex != acb->wqbuf_lastindex) {\r\nuint8_t *pQbuffer;\r\nstruct QBUFFER __iomem *pwbuffer;\r\nuint8_t __iomem *iop_data;\r\nint32_t allxfer_len = 0;\r\nacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\r\npwbuffer = arcmsr_get_iop_wqbuffer(acb);\r\niop_data = (uint8_t __iomem *)pwbuffer->data;\r\nwhile ((acb->wqbuf_firstindex != acb->wqbuf_lastindex) && \\r\n(allxfer_len < 124)) {\r\npQbuffer = &acb->wqbuffer[acb->wqbuf_firstindex];\r\nmemcpy(iop_data, pQbuffer, 1);\r\nacb->wqbuf_firstindex++;\r\nacb->wqbuf_firstindex %= ARCMSR_MAX_QBUFFER;\r\niop_data++;\r\nallxfer_len++;\r\n}\r\npwbuffer->data_len = allxfer_len;\r\narcmsr_iop_message_wrote(acb);\r\n}\r\nif (acb->wqbuf_firstindex == acb->wqbuf_lastindex) {\r\nacb->acb_flags |= ACB_F_MESSAGE_WQBUFFER_CLEARED;\r\n}\r\n}\r\nstatic void arcmsr_hba_doorbell_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\nwritel(outbound_doorbell, &reg->outbound_doorbell);\r\nif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK) {\r\narcmsr_iop2drv_data_wrote_handle(acb);\r\n}\r\nif (outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_READ_OK) {\r\narcmsr_iop2drv_data_read_handle(acb);\r\n}\r\n}\r\nstatic void arcmsr_hbc_doorbell_isr(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)pACB->pmuC;\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\nwritel(outbound_doorbell, &reg->outbound_doorbell_clear);\r\nif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_WRITE_OK) {\r\narcmsr_iop2drv_data_wrote_handle(pACB);\r\n}\r\nif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_DATA_READ_OK) {\r\narcmsr_iop2drv_data_read_handle(pACB);\r\n}\r\nif (outbound_doorbell & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\narcmsr_hbc_message_isr(pACB);\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hba_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t flag_ccb;\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nstruct CommandControlBlock *pCCB;\r\nbool error;\r\nwhile ((flag_ccb = readl(&reg->outbound_queueport)) != 0xFFFFFFFF) {\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\n}\r\n}\r\nstatic void arcmsr_hbb_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t index;\r\nuint32_t flag_ccb;\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nstruct ARCMSR_CDB *pARCMSR_CDB;\r\nstruct CommandControlBlock *pCCB;\r\nbool error;\r\nindex = reg->doneq_index;\r\nwhile ((flag_ccb = readl(&reg->done_qbuffer[index])) != 0) {\r\nwritel(0, &reg->done_qbuffer[index]);\r\npARCMSR_CDB = (struct ARCMSR_CDB *)(acb->vir2phy_offset+(flag_ccb << 5));\r\npCCB = container_of(pARCMSR_CDB, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_drain_donequeue(acb, pCCB, error);\r\nindex++;\r\nindex %= ARCMSR_MAX_HBB_POSTQUEUE;\r\nreg->doneq_index = index;\r\n}\r\n}\r\nstatic void arcmsr_hbc_postqueue_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_C *phbcmu;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nstruct CommandControlBlock *ccb;\r\nuint32_t flag_ccb, ccb_cdb_phy, throttling = 0;\r\nint error;\r\nphbcmu = (struct MessageUnit_C *)acb->pmuC;\r\nwhile (readl(&phbcmu->host_int_status) &\r\nARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR){\r\nflag_ccb = readl(&phbcmu->outbound_queueport_low);\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\r\nccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\r\narcmsr_drain_donequeue(acb, ccb, error);\r\nif (throttling == ARCMSR_HBC_ISR_THROTTLING_LEVEL) {\r\nwritel(ARCMSR_HBCMU_DRV2IOP_POSTQUEUE_THROTTLING, &phbcmu->inbound_doorbell);\r\nbreak;\r\n}\r\nthrottling++;\r\n}\r\n}\r\nstatic void arcmsr_hba_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A *reg = acb->pmuA;\r\nwritel(ARCMSR_MU_OUTBOUND_MESSAGE0_INT, &reg->outbound_intstatus);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic void arcmsr_hbb_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic void arcmsr_hbc_message_isr(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_C *reg = acb->pmuC;\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\r\nschedule_work(&acb->arcmsr_do_message_isr_bh);\r\n}\r\nstatic int arcmsr_handle_hba_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t outbound_intstatus;\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\noutbound_intstatus = readl(&reg->outbound_intstatus) &\r\nacb->outbound_int_enable;\r\nif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT)) {\r\nreturn 1;\r\n}\r\nwritel(outbound_intstatus, &reg->outbound_intstatus);\r\nif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT) {\r\narcmsr_hba_doorbell_isr(acb);\r\n}\r\nif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT) {\r\narcmsr_hba_postqueue_isr(acb);\r\n}\r\nif(outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT) {\r\narcmsr_hba_message_isr(acb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int arcmsr_handle_hbb_isr(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t outbound_doorbell;\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\noutbound_doorbell = readl(reg->iop2drv_doorbell) &\r\nacb->outbound_int_enable;\r\nif (!outbound_doorbell)\r\nreturn 1;\r\nwritel(~outbound_doorbell, reg->iop2drv_doorbell);\r\nreadl(reg->iop2drv_doorbell);\r\nwritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK) {\r\narcmsr_iop2drv_data_wrote_handle(acb);\r\n}\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_DATA_READ_OK) {\r\narcmsr_iop2drv_data_read_handle(acb);\r\n}\r\nif (outbound_doorbell & ARCMSR_IOP2DRV_CDB_DONE) {\r\narcmsr_hbb_postqueue_isr(acb);\r\n}\r\nif(outbound_doorbell & ARCMSR_IOP2DRV_MESSAGE_CMD_DONE) {\r\narcmsr_hbb_message_isr(acb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int arcmsr_handle_hbc_isr(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t host_interrupt_status;\r\nstruct MessageUnit_C *phbcmu = (struct MessageUnit_C *)pACB->pmuC;\r\nhost_interrupt_status = readl(&phbcmu->host_int_status);\r\nif (!host_interrupt_status) {\r\nreturn 1;\r\n}\r\nif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_DOORBELL_ISR) {\r\narcmsr_hbc_doorbell_isr(pACB);\r\n}\r\nif (host_interrupt_status & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) {\r\narcmsr_hbc_postqueue_isr(pACB);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nif (arcmsr_handle_hba_isr(acb)) {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nif (arcmsr_handle_hbb_isr(acb)) {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nif (arcmsr_handle_hbc_isr(acb)) {\r\nreturn IRQ_NONE;\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void arcmsr_iop_parking(struct AdapterControlBlock *acb)\r\n{\r\nif (acb) {\r\nif (acb->acb_flags & ACB_F_MSG_START_BGRB) {\r\nuint32_t intmask_org;\r\nacb->acb_flags &= ~ACB_F_MSG_START_BGRB;\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\narcmsr_stop_adapter_bgrb(acb);\r\narcmsr_flush_adapter_cache(acb);\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\n}\r\n}\r\n}\r\nvoid arcmsr_post_ioctldata2iop(struct AdapterControlBlock *acb)\r\n{\r\nint32_t wqbuf_firstindex, wqbuf_lastindex;\r\nuint8_t *pQbuffer;\r\nstruct QBUFFER __iomem *pwbuffer;\r\nuint8_t __iomem *iop_data;\r\nint32_t allxfer_len = 0;\r\npwbuffer = arcmsr_get_iop_wqbuffer(acb);\r\niop_data = (uint8_t __iomem *)pwbuffer->data;\r\nif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_READED) {\r\nacb->acb_flags &= (~ACB_F_MESSAGE_WQBUFFER_READED);\r\nwqbuf_firstindex = acb->wqbuf_firstindex;\r\nwqbuf_lastindex = acb->wqbuf_lastindex;\r\nwhile ((wqbuf_firstindex != wqbuf_lastindex) && (allxfer_len < 124)) {\r\npQbuffer = &acb->wqbuffer[wqbuf_firstindex];\r\nmemcpy(iop_data, pQbuffer, 1);\r\nwqbuf_firstindex++;\r\nwqbuf_firstindex %= ARCMSR_MAX_QBUFFER;\r\niop_data++;\r\nallxfer_len++;\r\n}\r\nacb->wqbuf_firstindex = wqbuf_firstindex;\r\npwbuffer->data_len = allxfer_len;\r\narcmsr_iop_message_wrote(acb);\r\n}\r\n}\r\nstatic int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct CMD_MESSAGE_FIELD *pcmdmessagefld;\r\nint retvalue = 0, transfer_len = 0;\r\nchar *buffer;\r\nstruct scatterlist *sg;\r\nuint32_t controlcode = (uint32_t ) cmd->cmnd[5] << 24 |\r\n(uint32_t ) cmd->cmnd[6] << 16 |\r\n(uint32_t ) cmd->cmnd[7] << 8 |\r\n(uint32_t ) cmd->cmnd[8];\r\nsg = scsi_sglist(cmd);\r\nbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\nif (scsi_sg_count(cmd) > 1) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\ngoto message_out;\r\n}\r\ntransfer_len += sg->length;\r\nif (transfer_len > sizeof(struct CMD_MESSAGE_FIELD)) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\ngoto message_out;\r\n}\r\npcmdmessagefld = (struct CMD_MESSAGE_FIELD *) buffer;\r\nswitch(controlcode) {\r\ncase ARCMSR_MESSAGE_READ_RQBUFFER: {\r\nunsigned char *ver_addr;\r\nuint8_t *pQbuffer, *ptmpQbuffer;\r\nint32_t allxfer_len = 0;\r\nver_addr = kmalloc(1032, GFP_ATOMIC);\r\nif (!ver_addr) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\ngoto message_out;\r\n}\r\nptmpQbuffer = ver_addr;\r\nwhile ((acb->rqbuf_firstindex != acb->rqbuf_lastindex)\r\n&& (allxfer_len < 1031)) {\r\npQbuffer = &acb->rqbuffer[acb->rqbuf_firstindex];\r\nmemcpy(ptmpQbuffer, pQbuffer, 1);\r\nacb->rqbuf_firstindex++;\r\nacb->rqbuf_firstindex %= ARCMSR_MAX_QBUFFER;\r\nptmpQbuffer++;\r\nallxfer_len++;\r\n}\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nstruct QBUFFER __iomem *prbuffer;\r\nuint8_t __iomem *iop_data;\r\nint32_t iop_len;\r\nacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\r\nprbuffer = arcmsr_get_iop_rqbuffer(acb);\r\niop_data = prbuffer->data;\r\niop_len = readl(&prbuffer->data_len);\r\nwhile (iop_len > 0) {\r\nacb->rqbuffer[acb->rqbuf_lastindex] = readb(iop_data);\r\nacb->rqbuf_lastindex++;\r\nacb->rqbuf_lastindex %= ARCMSR_MAX_QBUFFER;\r\niop_data++;\r\niop_len--;\r\n}\r\narcmsr_iop_message_read(acb);\r\n}\r\nmemcpy(pcmdmessagefld->messagedatabuffer, ver_addr, allxfer_len);\r\npcmdmessagefld->cmdmessage.Length = allxfer_len;\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode = ARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode = ARCMSR_MESSAGE_RETURNCODE_OK;\r\n}\r\nkfree(ver_addr);\r\n}\r\nbreak;\r\ncase ARCMSR_MESSAGE_WRITE_WQBUFFER: {\r\nunsigned char *ver_addr;\r\nint32_t my_empty_len, user_len, wqbuf_firstindex, wqbuf_lastindex;\r\nuint8_t *pQbuffer, *ptmpuserbuffer;\r\nver_addr = kmalloc(1032, GFP_ATOMIC);\r\nif (!ver_addr) {\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\ngoto message_out;\r\n}\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\n}\r\nptmpuserbuffer = ver_addr;\r\nuser_len = pcmdmessagefld->cmdmessage.Length;\r\nmemcpy(ptmpuserbuffer, pcmdmessagefld->messagedatabuffer, user_len);\r\nwqbuf_lastindex = acb->wqbuf_lastindex;\r\nwqbuf_firstindex = acb->wqbuf_firstindex;\r\nif (wqbuf_lastindex != wqbuf_firstindex) {\r\nstruct SENSE_DATA *sensebuffer =\r\n(struct SENSE_DATA *)cmd->sense_buffer;\r\narcmsr_post_ioctldata2iop(acb);\r\nsensebuffer->ErrorCode = 0x70;\r\nsensebuffer->SenseKey = ILLEGAL_REQUEST;\r\nsensebuffer->AdditionalSenseLength = 0x0A;\r\nsensebuffer->AdditionalSenseCode = 0x20;\r\nsensebuffer->Valid = 1;\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\n} else {\r\nmy_empty_len = (wqbuf_firstindex-wqbuf_lastindex - 1)\r\n&(ARCMSR_MAX_QBUFFER - 1);\r\nif (my_empty_len >= user_len) {\r\nwhile (user_len > 0) {\r\npQbuffer =\r\n&acb->wqbuffer[acb->wqbuf_lastindex];\r\nmemcpy(pQbuffer, ptmpuserbuffer, 1);\r\nacb->wqbuf_lastindex++;\r\nacb->wqbuf_lastindex %= ARCMSR_MAX_QBUFFER;\r\nptmpuserbuffer++;\r\nuser_len--;\r\n}\r\nif (acb->acb_flags & ACB_F_MESSAGE_WQBUFFER_CLEARED) {\r\nacb->acb_flags &=\r\n~ACB_F_MESSAGE_WQBUFFER_CLEARED;\r\narcmsr_post_ioctldata2iop(acb);\r\n}\r\n} else {\r\nstruct SENSE_DATA *sensebuffer =\r\n(struct SENSE_DATA *)cmd->sense_buffer;\r\nsensebuffer->ErrorCode = 0x70;\r\nsensebuffer->SenseKey = ILLEGAL_REQUEST;\r\nsensebuffer->AdditionalSenseLength = 0x0A;\r\nsensebuffer->AdditionalSenseCode = 0x20;\r\nsensebuffer->Valid = 1;\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\n}\r\n}\r\nkfree(ver_addr);\r\n}\r\nbreak;\r\ncase ARCMSR_MESSAGE_CLEAR_RQBUFFER: {\r\nuint8_t *pQbuffer = acb->rqbuffer;\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\r\narcmsr_iop_message_read(acb);\r\n}\r\nacb->acb_flags |= ACB_F_MESSAGE_RQBUFFER_CLEARED;\r\nacb->rqbuf_firstindex = 0;\r\nacb->rqbuf_lastindex = 0;\r\nmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\n}\r\n}\r\nbreak;\r\ncase ARCMSR_MESSAGE_CLEAR_WQBUFFER: {\r\nuint8_t *pQbuffer = acb->wqbuffer;\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\n}\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\r\narcmsr_iop_message_read(acb);\r\n}\r\nacb->acb_flags |=\r\n(ACB_F_MESSAGE_WQBUFFER_CLEARED |\r\nACB_F_MESSAGE_WQBUFFER_READED);\r\nacb->wqbuf_firstindex = 0;\r\nacb->wqbuf_lastindex = 0;\r\nmemset(pQbuffer, 0, ARCMSR_MAX_QBUFFER);\r\n}\r\nbreak;\r\ncase ARCMSR_MESSAGE_CLEAR_ALLQBUFFER: {\r\nuint8_t *pQbuffer;\r\nif (acb->acb_flags & ACB_F_IOPDATA_OVERFLOW) {\r\nacb->acb_flags &= ~ACB_F_IOPDATA_OVERFLOW;\r\narcmsr_iop_message_read(acb);\r\n}\r\nacb->acb_flags |=\r\n(ACB_F_MESSAGE_WQBUFFER_CLEARED\r\n| ACB_F_MESSAGE_RQBUFFER_CLEARED\r\n| ACB_F_MESSAGE_WQBUFFER_READED);\r\nacb->rqbuf_firstindex = 0;\r\nacb->rqbuf_lastindex = 0;\r\nacb->wqbuf_firstindex = 0;\r\nacb->wqbuf_lastindex = 0;\r\npQbuffer = acb->rqbuffer;\r\nmemset(pQbuffer, 0, sizeof(struct QBUFFER));\r\npQbuffer = acb->wqbuffer;\r\nmemset(pQbuffer, 0, sizeof(struct QBUFFER));\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\n}\r\n}\r\nbreak;\r\ncase ARCMSR_MESSAGE_RETURN_CODE_3F: {\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_3F;\r\n}\r\nbreak;\r\n}\r\ncase ARCMSR_MESSAGE_SAY_HELLO: {\r\nint8_t *hello_string = "Hello! I am ARCMSR";\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}else{\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_OK;\r\n}\r\nmemcpy(pcmdmessagefld->messagedatabuffer, hello_string\r\n, (int16_t)strlen(hello_string));\r\n}\r\nbreak;\r\ncase ARCMSR_MESSAGE_SAY_GOODBYE:\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}\r\narcmsr_iop_parking(acb);\r\nbreak;\r\ncase ARCMSR_MESSAGE_FLUSH_ADAPTER_CACHE:\r\nif(acb->fw_flag == FW_DEADLOCK) {\r\npcmdmessagefld->cmdmessage.ReturnCode =\r\nARCMSR_MESSAGE_RETURNCODE_BUS_HANG_ON;\r\n}\r\narcmsr_flush_adapter_cache(acb);\r\nbreak;\r\ndefault:\r\nretvalue = ARCMSR_MESSAGE_FAIL;\r\n}\r\nmessage_out:\r\nsg = scsi_sglist(cmd);\r\nkunmap_atomic(buffer - sg->offset);\r\nreturn retvalue;\r\n}\r\nstatic struct CommandControlBlock *arcmsr_get_freeccb(struct AdapterControlBlock *acb)\r\n{\r\nstruct list_head *head = &acb->ccb_free_list;\r\nstruct CommandControlBlock *ccb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&acb->ccblist_lock, flags);\r\nif (!list_empty(head)) {\r\nccb = list_entry(head->next, struct CommandControlBlock, list);\r\nlist_del_init(&ccb->list);\r\n}else{\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\nreturn ccb;\r\n}\r\nstatic void arcmsr_handle_virtual_command(struct AdapterControlBlock *acb,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nswitch (cmd->cmnd[0]) {\r\ncase INQUIRY: {\r\nunsigned char inqdata[36];\r\nchar *buffer;\r\nstruct scatterlist *sg;\r\nif (cmd->device->lun) {\r\ncmd->result = (DID_TIME_OUT << 16);\r\ncmd->scsi_done(cmd);\r\nreturn;\r\n}\r\ninqdata[0] = TYPE_PROCESSOR;\r\ninqdata[1] = 0;\r\ninqdata[2] = 0;\r\ninqdata[4] = 31;\r\nstrncpy(&inqdata[8], "Areca ", 8);\r\nstrncpy(&inqdata[16], "RAID controller ", 16);\r\nstrncpy(&inqdata[32], "R001", 4);\r\nsg = scsi_sglist(cmd);\r\nbuffer = kmap_atomic(sg_page(sg)) + sg->offset;\r\nmemcpy(buffer, inqdata, sizeof(inqdata));\r\nsg = scsi_sglist(cmd);\r\nkunmap_atomic(buffer - sg->offset);\r\ncmd->scsi_done(cmd);\r\n}\r\nbreak;\r\ncase WRITE_BUFFER:\r\ncase READ_BUFFER: {\r\nif (arcmsr_iop_message_xfer(acb, cmd))\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\n}\r\nbreak;\r\ndefault:\r\ncmd->scsi_done(cmd);\r\n}\r\n}\r\nstatic int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,\r\nvoid (* done)(struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *host = cmd->device->host;\r\nstruct AdapterControlBlock *acb = (struct AdapterControlBlock *) host->hostdata;\r\nstruct CommandControlBlock *ccb;\r\nint target = cmd->device->id;\r\nint lun = cmd->device->lun;\r\nuint8_t scsicmd = cmd->cmnd[0];\r\ncmd->scsi_done = done;\r\ncmd->host_scribble = NULL;\r\ncmd->result = 0;\r\nif ((scsicmd == SYNCHRONIZE_CACHE) ||(scsicmd == SEND_DIAGNOSTIC)){\r\nif(acb->devstate[target][lun] == ARECA_RAID_GONE) {\r\ncmd->result = (DID_NO_CONNECT << 16);\r\n}\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nif (target == 16) {\r\narcmsr_handle_virtual_command(acb, cmd);\r\nreturn 0;\r\n}\r\nif (atomic_read(&acb->ccboutstandingcount) >=\r\nARCMSR_MAX_OUTSTANDING_CMD)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nccb = arcmsr_get_freeccb(acb);\r\nif (!ccb)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (arcmsr_build_ccb( acb, ccb, cmd ) == FAILED) {\r\ncmd->result = (DID_ERROR << 16) | (RESERVATION_CONFLICT << 1);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\narcmsr_post_ccb(acb, ccb);\r\nreturn 0;\r\n}\r\nbool arcmsr_get_hbb_config(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nstruct pci_dev *pdev = acb->pdev;\r\nvoid *dma_coherent;\r\ndma_addr_t dma_coherent_handle;\r\nchar *acb_firm_model = acb->firm_model;\r\nchar *acb_firm_version = acb->firm_version;\r\nchar *acb_device_map = acb->device_map;\r\nchar __iomem *iop_firm_model;\r\nchar __iomem *iop_firm_version;\r\nchar __iomem *iop_device_map;\r\nint count;\r\ndma_coherent = dma_alloc_coherent(&pdev->dev, sizeof(struct MessageUnit_B), &dma_coherent_handle, GFP_KERNEL);\r\nif (!dma_coherent){\r\nprintk(KERN_NOTICE "arcmsr%d: dma_alloc_coherent got error for hbb mu\n", acb->host->host_no);\r\nreturn false;\r\n}\r\nacb->dma_coherent_handle_hbb_mu = dma_coherent_handle;\r\nreg = (struct MessageUnit_B *)dma_coherent;\r\nacb->pmuB = reg;\r\nreg->drv2iop_doorbell= (uint32_t __iomem *)((unsigned long)acb->mem_base0 + ARCMSR_DRV2IOP_DOORBELL);\r\nreg->drv2iop_doorbell_mask = (uint32_t __iomem *)((unsigned long)acb->mem_base0 + ARCMSR_DRV2IOP_DOORBELL_MASK);\r\nreg->iop2drv_doorbell = (uint32_t __iomem *)((unsigned long)acb->mem_base0 + ARCMSR_IOP2DRV_DOORBELL);\r\nreg->iop2drv_doorbell_mask = (uint32_t __iomem *)((unsigned long)acb->mem_base0 + ARCMSR_IOP2DRV_DOORBELL_MASK);\r\nreg->message_wbuffer = (uint32_t __iomem *)((unsigned long)acb->mem_base1 + ARCMSR_MESSAGE_WBUFFER);\r\nreg->message_rbuffer = (uint32_t __iomem *)((unsigned long)acb->mem_base1 + ARCMSR_MESSAGE_RBUFFER);\r\nreg->message_rwbuffer = (uint32_t __iomem *)((unsigned long)acb->mem_base1 + ARCMSR_MESSAGE_RWBUFFER);\r\niop_firm_model = (char __iomem *)(&reg->message_rwbuffer[15]);\r\niop_firm_version = (char __iomem *)(&reg->message_rwbuffer[17]);\r\niop_device_map = (char __iomem *)(&reg->message_rwbuffer[21]);\r\nwritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'get adapter firmware \\r\nmiscellaneous data' timeout \n", acb->host->host_no);\r\nreturn false;\r\n}\r\ncount = 8;\r\nwhile (count){\r\n*acb_firm_model = readb(iop_firm_model);\r\nacb_firm_model++;\r\niop_firm_model++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile (count){\r\n*acb_firm_version = readb(iop_firm_version);\r\nacb_firm_version++;\r\niop_firm_version++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile(count){\r\n*acb_device_map = readb(iop_device_map);\r\nacb_device_map++;\r\niop_device_map++;\r\ncount--;\r\n}\r\nprintk(KERN_NOTICE "Areca RAID Controller%d: F/W %s & Model %s\n",\r\nacb->host->host_no,\r\nacb->firm_version,\r\nacb->firm_model);\r\nacb->signature = readl(&reg->message_rwbuffer[1]);\r\nacb->firm_request_len = readl(&reg->message_rwbuffer[2]);\r\nacb->firm_numbers_queue = readl(&reg->message_rwbuffer[3]);\r\nacb->firm_sdram_size = readl(&reg->message_rwbuffer[4]);\r\nacb->firm_hd_channels = readl(&reg->message_rwbuffer[5]);\r\nacb->firm_cfg_version = readl(&reg->message_rwbuffer[25]);\r\nreturn true;\r\n}\r\nstatic bool arcmsr_get_hbc_config(struct AdapterControlBlock *pACB)\r\n{\r\nuint32_t intmask_org, Index, firmware_state = 0;\r\nstruct MessageUnit_C *reg = pACB->pmuC;\r\nchar *acb_firm_model = pACB->firm_model;\r\nchar *acb_firm_version = pACB->firm_version;\r\nchar *iop_firm_model = (char *)(&reg->msgcode_rwbuffer[15]);\r\nchar *iop_firm_version = (char *)(&reg->msgcode_rwbuffer[17]);\r\nint count;\r\nintmask_org = readl(&reg->host_int_mask);\r\nwritel(intmask_org|ARCMSR_HBCMU_ALL_INTMASKENABLE, &reg->host_int_mask);\r\ndo {\r\nfirmware_state = readl(&reg->outbound_msgaddr1);\r\n} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nfor (Index = 0; Index < 2000; Index++) {\r\nif (readl(&reg->outbound_doorbell) & ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE) {\r\nwritel(ARCMSR_HBCMU_IOP2DRV_MESSAGE_CMD_DONE_DOORBELL_CLEAR, &reg->outbound_doorbell_clear);\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nif (Index >= 2000) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'get adapter firmware \\r\nmiscellaneous data' timeout \n", pACB->host->host_no);\r\nreturn false;\r\n}\r\ncount = 8;\r\nwhile (count) {\r\n*acb_firm_model = readb(iop_firm_model);\r\nacb_firm_model++;\r\niop_firm_model++;\r\ncount--;\r\n}\r\ncount = 16;\r\nwhile (count) {\r\n*acb_firm_version = readb(iop_firm_version);\r\nacb_firm_version++;\r\niop_firm_version++;\r\ncount--;\r\n}\r\nprintk(KERN_NOTICE "Areca RAID Controller%d: F/W %s & Model %s\n",\r\npACB->host->host_no,\r\npACB->firm_version,\r\npACB->firm_model);\r\npACB->firm_request_len = readl(&reg->msgcode_rwbuffer[1]);\r\npACB->firm_numbers_queue = readl(&reg->msgcode_rwbuffer[2]);\r\npACB->firm_sdram_size = readl(&reg->msgcode_rwbuffer[3]);\r\npACB->firm_hd_channels = readl(&reg->msgcode_rwbuffer[4]);\r\npACB->firm_cfg_version = readl(&reg->msgcode_rwbuffer[25]);\r\nreturn true;\r\n}\r\nstatic bool arcmsr_get_firmware_spec(struct AdapterControlBlock *acb)\r\n{\r\nif (acb->adapter_type == ACB_ADAPTER_TYPE_A)\r\nreturn arcmsr_get_hba_config(acb);\r\nelse if (acb->adapter_type == ACB_ADAPTER_TYPE_B)\r\nreturn arcmsr_get_hbb_config(acb);\r\nelse\r\nreturn arcmsr_get_hbc_config(acb);\r\n}\r\nstatic int arcmsr_polling_hba_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nstruct CommandControlBlock *ccb;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nuint32_t flag_ccb, outbound_intstatus, poll_ccb_done = 0, poll_count = 0;\r\nint rtn;\r\nbool error;\r\npolling_hba_ccb_retry:\r\npoll_count++;\r\noutbound_intstatus = readl(&reg->outbound_intstatus) & acb->outbound_int_enable;\r\nwritel(outbound_intstatus, &reg->outbound_intstatus);\r\nwhile (1) {\r\nif ((flag_ccb = readl(&reg->outbound_queueport)) == 0xFFFFFFFF) {\r\nif (poll_ccb_done){\r\nrtn = SUCCESS;\r\nbreak;\r\n}else {\r\nmsleep(25);\r\nif (poll_count > 100){\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hba_ccb_retry;\r\n}\r\n}\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\nccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\npoll_ccb_done = (ccb == poll_ccb) ? 1:0;\r\nif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\r\nif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"\r\n" poll command abort successfully \n"\r\n, acb->host->host_no\r\n, ccb->pcmd->device->id\r\n, ccb->pcmd->device->lun\r\n, ccb);\r\nccb->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(ccb);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: polling get an illegal ccb"\r\n" command done ccb = '0x%p'"\r\n"ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, ccb\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_report_ccb_state(acb, ccb, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_polling_hbb_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nstruct CommandControlBlock *ccb;\r\nuint32_t flag_ccb, poll_ccb_done = 0, poll_count = 0;\r\nint index, rtn;\r\nbool error;\r\npolling_hbb_ccb_retry:\r\npoll_count++;\r\nwritel(ARCMSR_DOORBELL_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nwhile(1){\r\nindex = reg->doneq_index;\r\nif ((flag_ccb = readl(&reg->done_qbuffer[index])) == 0) {\r\nif (poll_ccb_done){\r\nrtn = SUCCESS;\r\nbreak;\r\n}else {\r\nmsleep(25);\r\nif (poll_count > 100){\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hbb_ccb_retry;\r\n}\r\n}\r\nwritel(0, &reg->done_qbuffer[index]);\r\nindex++;\r\nindex %= ARCMSR_MAX_HBB_POSTQUEUE;\r\nreg->doneq_index = index;\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + (flag_ccb << 5));\r\nccb = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\npoll_ccb_done = (ccb == poll_ccb) ? 1:0;\r\nif ((ccb->acb != acb) || (ccb->startdone != ARCMSR_CCB_START)) {\r\nif ((ccb->startdone == ARCMSR_CCB_ABORTED) || (ccb == poll_ccb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"\r\n" poll command abort successfully \n"\r\n,acb->host->host_no\r\n,ccb->pcmd->device->id\r\n,ccb->pcmd->device->lun\r\n,ccb);\r\nccb->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(ccb);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: polling get an illegal ccb"\r\n" command done ccb = '0x%p'"\r\n"ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, ccb\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0) ? true : false;\r\narcmsr_report_ccb_state(acb, ccb, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_polling_hbc_ccbdone(struct AdapterControlBlock *acb, struct CommandControlBlock *poll_ccb)\r\n{\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)acb->pmuC;\r\nuint32_t flag_ccb, ccb_cdb_phy;\r\nstruct ARCMSR_CDB *arcmsr_cdb;\r\nbool error;\r\nstruct CommandControlBlock *pCCB;\r\nuint32_t poll_ccb_done = 0, poll_count = 0;\r\nint rtn;\r\npolling_hbc_ccb_retry:\r\npoll_count++;\r\nwhile (1) {\r\nif ((readl(&reg->host_int_status) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR) == 0) {\r\nif (poll_ccb_done) {\r\nrtn = SUCCESS;\r\nbreak;\r\n} else {\r\nmsleep(25);\r\nif (poll_count > 100) {\r\nrtn = FAILED;\r\nbreak;\r\n}\r\ngoto polling_hbc_ccb_retry;\r\n}\r\n}\r\nflag_ccb = readl(&reg->outbound_queueport_low);\r\nccb_cdb_phy = (flag_ccb & 0xFFFFFFF0);\r\narcmsr_cdb = (struct ARCMSR_CDB *)(acb->vir2phy_offset + ccb_cdb_phy);\r\npCCB = container_of(arcmsr_cdb, struct CommandControlBlock, arcmsr_cdb);\r\npoll_ccb_done = (pCCB == poll_ccb) ? 1 : 0;\r\nif ((pCCB->acb != acb) || (pCCB->startdone != ARCMSR_CCB_START)) {\r\nif (pCCB->startdone == ARCMSR_CCB_ABORTED) {\r\nprintk(KERN_NOTICE "arcmsr%d: scsi id = %d lun = %d ccb = '0x%p'"\r\n" poll command abort successfully \n"\r\n, acb->host->host_no\r\n, pCCB->pcmd->device->id\r\n, pCCB->pcmd->device->lun\r\n, pCCB);\r\npCCB->pcmd->result = DID_ABORT << 16;\r\narcmsr_ccb_complete(pCCB);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "arcmsr%d: polling get an illegal ccb"\r\n" command done ccb = '0x%p'"\r\n"ccboutstandingcount = %d \n"\r\n, acb->host->host_no\r\n, pCCB\r\n, atomic_read(&acb->ccboutstandingcount));\r\ncontinue;\r\n}\r\nerror = (flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1) ? true : false;\r\narcmsr_report_ccb_state(acb, pCCB, error);\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_polling_ccbdone(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *poll_ccb)\r\n{\r\nint rtn = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nrtn = arcmsr_polling_hba_ccbdone(acb, poll_ccb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nrtn = arcmsr_polling_hbb_ccbdone(acb, poll_ccb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nrtn = arcmsr_polling_hbc_ccbdone(acb, poll_ccb);\r\n}\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_iop_confirm(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t cdb_phyaddr, cdb_phyaddr_hi32;\r\ndma_addr_t dma_coherent_handle;\r\ndma_coherent_handle = acb->dma_coherent_handle;\r\ncdb_phyaddr = (uint32_t)(dma_coherent_handle);\r\ncdb_phyaddr_hi32 = (uint32_t)((cdb_phyaddr >> 16) >> 16);\r\nacb->cdb_phyaddr_hi32 = cdb_phyaddr_hi32;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nif (cdb_phyaddr_hi32 != 0) {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nuint32_t intmask_org;\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, \\r\n&reg->message_rwbuffer[0]);\r\nwritel(cdb_phyaddr_hi32, &reg->message_rwbuffer[1]);\r\nwritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, \\r\n&reg->inbound_msgaddr0);\r\nif (!arcmsr_hba_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: ""set ccb high \\r\npart physical address timeout\n",\r\nacb->host->host_no);\r\nreturn 1;\r\n}\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nunsigned long post_queue_phyaddr;\r\nuint32_t __iomem *rwbuffer;\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nuint32_t intmask_org;\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\nreg->postq_index = 0;\r\nreg->doneq_index = 0;\r\nwritel(ARCMSR_MESSAGE_SET_POST_WINDOW, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d:can not set diver mode\n", \\r\nacb->host->host_no);\r\nreturn 1;\r\n}\r\npost_queue_phyaddr = acb->dma_coherent_handle_hbb_mu;\r\nrwbuffer = reg->message_rwbuffer;\r\n/* driver "set config" signature */\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, rwbuffer++);\r\n/* normal should be zero */\r\nwritel(cdb_phyaddr_hi32, rwbuffer++);\r\n/* postQ size (256 + 8)*4 */\r\nwritel(post_queue_phyaddr, rwbuffer++);\r\n/* doneQ size (256 + 8)*4 */\r\nwritel(post_queue_phyaddr + 1056, rwbuffer++);\r\n/* ccb maxQ size must be --> [(256 + 8)*4]*/\r\nwritel(1056, rwbuffer);\r\nwritel(ARCMSR_MESSAGE_SET_CONFIG, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: 'set command Q window' \\r\ntimeout \n",acb->host->host_no);\r\nreturn 1;\r\n}\r\narcmsr_hbb_enable_driver_mode(acb);\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nif (cdb_phyaddr_hi32 != 0) {\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)acb->pmuC;\r\nprintk(KERN_NOTICE "arcmsr%d: cdb_phyaddr_hi32=0x%x\n",\r\nacb->adapter_index, cdb_phyaddr_hi32);\r\nwritel(ARCMSR_SIGNATURE_SET_CONFIG, &reg->msgcode_rwbuffer[0]);\r\nwritel(cdb_phyaddr_hi32, &reg->msgcode_rwbuffer[1]);\r\nwritel(ARCMSR_INBOUND_MESG0_SET_CONFIG, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nif (!arcmsr_hbc_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: 'set command Q window' \\r\ntimeout \n", acb->host->host_no);\r\nreturn 1;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void arcmsr_wait_firmware_ready(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t firmware_state = 0;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\ndo {\r\nfirmware_state = readl(&reg->outbound_msgaddr1);\r\n} while ((firmware_state & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\ndo {\r\nfirmware_state = readl(reg->iop2drv_doorbell);\r\n} while ((firmware_state & ARCMSR_MESSAGE_FIRMWARE_OK) == 0);\r\nwritel(ARCMSR_DRV2IOP_END_OF_INTERRUPT, reg->drv2iop_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)acb->pmuC;\r\ndo {\r\nfirmware_state = readl(&reg->outbound_msgaddr1);\r\n} while ((firmware_state & ARCMSR_HBCMU_MESSAGE_FIRMWARE_OK) == 0);\r\n}\r\n}\r\n}\r\nstatic void arcmsr_request_hba_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)){\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_request_hbb_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B __iomem *reg = acb->pmuB;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0 ) || ((acb->acb_flags & ACB_F_ABORT) != 0 )){\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_MESSAGE_GET_CONFIG, reg->drv2iop_doorbell);\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_request_hbc_device_map(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_C __iomem *reg = acb->pmuC;\r\nif (unlikely(atomic_read(&acb->rq_map_token) == 0) || ((acb->acb_flags & ACB_F_BUS_RESET) != 0) || ((acb->acb_flags & ACB_F_ABORT) != 0)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n} else {\r\nacb->fw_flag = FW_NORMAL;\r\nif (atomic_read(&acb->ante_token_value) == atomic_read(&acb->rq_map_token)) {\r\natomic_set(&acb->rq_map_token, 16);\r\n}\r\natomic_set(&acb->ante_token_value, atomic_read(&acb->rq_map_token));\r\nif (atomic_dec_and_test(&acb->rq_map_token)) {\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nreturn;\r\n}\r\nwritel(ARCMSR_INBOUND_MESG0_GET_CONFIG, &reg->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &reg->inbound_doorbell);\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_request_device_map(unsigned long pacb)\r\n{\r\nstruct AdapterControlBlock *acb = (struct AdapterControlBlock *)pacb;\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\narcmsr_request_hba_device_map(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\narcmsr_request_hbb_device_map(acb);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\narcmsr_request_hbc_device_map(acb);\r\n}\r\n}\r\n}\r\nstatic void arcmsr_start_hba_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nacb->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_START_BGRB, &reg->inbound_msgaddr0);\r\nif (!arcmsr_hba_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'start adapter background \\r\nrebulid' timeout \n", acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_start_hbb_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nacb->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_MESSAGE_START_BGRB, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'start adapter background \\r\nrebulid' timeout \n",acb->host->host_no);\r\n}\r\n}\r\nstatic void arcmsr_start_hbc_bgrb(struct AdapterControlBlock *pACB)\r\n{\r\nstruct MessageUnit_C *phbcmu = (struct MessageUnit_C *)pACB->pmuC;\r\npACB->acb_flags |= ACB_F_MSG_START_BGRB;\r\nwritel(ARCMSR_INBOUND_MESG0_START_BGRB, &phbcmu->inbound_msgaddr0);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_MESSAGE_CMD_DONE, &phbcmu->inbound_doorbell);\r\nif (!arcmsr_hbc_wait_msgint_ready(pACB)) {\r\nprintk(KERN_NOTICE "arcmsr%d: wait 'start adapter background \\r\nrebulid' timeout \n", pACB->host->host_no);\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_start_adapter_bgrb(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:\r\narcmsr_start_hba_bgrb(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B:\r\narcmsr_start_hbb_bgrb(acb);\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:\r\narcmsr_start_hbc_bgrb(acb);\r\n}\r\n}\r\nstatic void arcmsr_clear_doorbell_queue_buffer(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A: {\r\nstruct MessageUnit_A __iomem *reg = acb->pmuA;\r\nuint32_t outbound_doorbell;\r\n/* empty doorbell Qbuffer if door bell ringed */\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\n/*clear doorbell interrupt */\r\nwritel(outbound_doorbell, &reg->outbound_doorbell);\r\nwritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_B: {\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\n/*clear interrupt and message state*/\r\nwritel(ARCMSR_MESSAGE_INT_CLEAR_PATTERN, reg->iop2drv_doorbell);\r\nwritel(ARCMSR_DRV2IOP_DATA_READ_OK, reg->drv2iop_doorbell);\r\n/* let IOP know data has been read */\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C: {\r\nstruct MessageUnit_C *reg = (struct MessageUnit_C *)acb->pmuC;\r\nuint32_t outbound_doorbell;\r\n/* empty doorbell Qbuffer if door bell ringed */\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\nwritel(outbound_doorbell, &reg->outbound_doorbell_clear);\r\nwritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\r\n}\r\n}\r\n}\r\nstatic void arcmsr_enable_eoi_mode(struct AdapterControlBlock *acb)\r\n{\r\nswitch (acb->adapter_type) {\r\ncase ACB_ADAPTER_TYPE_A:\r\nreturn;\r\ncase ACB_ADAPTER_TYPE_B:\r\n{\r\nstruct MessageUnit_B *reg = acb->pmuB;\r\nwritel(ARCMSR_MESSAGE_ACTIVE_EOI_MODE, reg->drv2iop_doorbell);\r\nif (!arcmsr_hbb_wait_msgint_ready(acb)) {\r\nprintk(KERN_NOTICE "ARCMSR IOP enables EOI_MODE TIMEOUT");\r\nreturn;\r\n}\r\n}\r\nbreak;\r\ncase ACB_ADAPTER_TYPE_C:\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nstatic void arcmsr_hardware_reset(struct AdapterControlBlock *acb)\r\n{\r\nuint8_t value[64];\r\nint i, count = 0;\r\nstruct MessageUnit_A __iomem *pmuA = acb->pmuA;\r\nstruct MessageUnit_C __iomem *pmuC = acb->pmuC;\r\nu32 temp = 0;\r\n/* backup pci config data */\r\nprintk(KERN_NOTICE "arcmsr%d: executing hw bus reset .....\n", acb->host->host_no);\r\nfor (i = 0; i < 64; i++) {\r\npci_read_config_byte(acb->pdev, i, &value[i]);\r\n}\r\n/* hardware reset signal */\r\nif ((acb->dev_id == 0x1680)) {\r\nwritel(ARCMSR_ARC1680_BUS_RESET, &pmuA->reserved1[0]);\r\n} else if ((acb->dev_id == 0x1880)) {\r\ndo {\r\ncount++;\r\nwritel(0xF, &pmuC->write_sequence);\r\nwritel(0x4, &pmuC->write_sequence);\r\nwritel(0xB, &pmuC->write_sequence);\r\nwritel(0x2, &pmuC->write_sequence);\r\nwritel(0x7, &pmuC->write_sequence);\r\nwritel(0xD, &pmuC->write_sequence);\r\n} while ((((temp = readl(&pmuC->host_diagnostic)) | ARCMSR_ARC1880_DiagWrite_ENABLE) == 0) && (count < 5));\r\nwritel(ARCMSR_ARC1880_RESET_ADAPTER, &pmuC->host_diagnostic);\r\n} else {\r\npci_write_config_byte(acb->pdev, 0x84, 0x20);\r\n}\r\nmsleep(2000);\r\n/* write back pci config data */\r\nfor (i = 0; i < 64; i++) {\r\npci_write_config_byte(acb->pdev, i, value[i]);\r\n}\r\nmsleep(1000);\r\nreturn;\r\n}\r\nstatic void arcmsr_iop_init(struct AdapterControlBlock *acb)\r\n{\r\nuint32_t intmask_org;\r\n/* disable all outbound interrupt */\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\narcmsr_wait_firmware_ready(acb);\r\narcmsr_iop_confirm(acb);\r\n/*start background rebuild*/\r\narcmsr_start_adapter_bgrb(acb);\r\n/* empty doorbell Qbuffer if door bell ringed */\r\narcmsr_clear_doorbell_queue_buffer(acb);\r\narcmsr_enable_eoi_mode(acb);\r\n/* enable outbound Post Queue,outbound doorbell Interrupt */\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\nacb->acb_flags |= ACB_F_IOP_INITED;\r\n}\r\nstatic uint8_t arcmsr_iop_reset(struct AdapterControlBlock *acb)\r\n{\r\nstruct CommandControlBlock *ccb;\r\nuint32_t intmask_org;\r\nuint8_t rtnval = 0x00;\r\nint i = 0;\r\nunsigned long flags;\r\nif (atomic_read(&acb->ccboutstandingcount) != 0) {\r\n/* disable all outbound interrupt */\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\n/* talk to iop 331 outstanding command aborted */\r\nrtnval = arcmsr_abort_allcmd(acb);\r\n/* clear all outbound posted Q */\r\narcmsr_done4abort_postqueue(acb);\r\nfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\r\nccb = acb->pccb_pool[i];\r\nif (ccb->startdone == ARCMSR_CCB_START) {\r\nscsi_dma_unmap(ccb->pcmd);\r\nccb->startdone = ARCMSR_CCB_DONE;\r\nccb->ccb_flags = 0;\r\nspin_lock_irqsave(&acb->ccblist_lock, flags);\r\nlist_add_tail(&ccb->list, &acb->ccb_free_list);\r\nspin_unlock_irqrestore(&acb->ccblist_lock, flags);\r\n}\r\n}\r\natomic_set(&acb->ccboutstandingcount, 0);\r\n/* enable all outbound interrupt */\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\nreturn rtnval;\r\n}\r\nreturn rtnval;\r\n}\r\nstatic int arcmsr_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct AdapterControlBlock *acb;\r\nuint32_t intmask_org, outbound_doorbell;\r\nint retry_count = 0;\r\nint rtn = FAILED;\r\nacb = (struct AdapterControlBlock *) cmd->device->host->hostdata;\r\nprintk(KERN_ERR "arcmsr: executing bus reset eh.....num_resets = %d, num_aborts = %d \n", acb->num_resets, acb->num_aborts);\r\nacb->num_resets++;\r\nswitch(acb->adapter_type){\r\ncase ACB_ADAPTER_TYPE_A:{\r\nif (acb->acb_flags & ACB_F_BUS_RESET){\r\nlong timeout;\r\nprintk(KERN_ERR "arcmsr: there is an bus reset eh proceeding.......\n");\r\ntimeout = wait_event_timeout(wait_q, (acb->acb_flags & ACB_F_BUS_RESET) == 0, 220*HZ);\r\nif (timeout) {\r\nreturn SUCCESS;\r\n}\r\n}\r\nacb->acb_flags |= ACB_F_BUS_RESET;\r\nif (!arcmsr_iop_reset(acb)) {\r\nstruct MessageUnit_A __iomem *reg;\r\nreg = acb->pmuA;\r\narcmsr_hardware_reset(acb);\r\nacb->acb_flags &= ~ACB_F_IOP_INITED;\r\nsleep_again:\r\nssleep(ARCMSR_SLEEPTIME);\r\nif ((readl(&reg->outbound_msgaddr1) & ARCMSR_OUTBOUND_MESG1_FIRMWARE_OK) == 0) {\r\nprintk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, retry=%d\n", acb->host->host_no, retry_count);\r\nif (retry_count > ARCMSR_RETRYCOUNT) {\r\nacb->fw_flag = FW_DEADLOCK;\r\nprintk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\n", acb->host->host_no);\r\nreturn FAILED;\r\n}\r\nretry_count++;\r\ngoto sleep_again;\r\n}\r\nacb->acb_flags |= ACB_F_IOP_INITED;\r\n/* disable all outbound interrupt */\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\narcmsr_get_firmware_spec(acb);\r\narcmsr_start_adapter_bgrb(acb);\r\n/* clear Qbuffer if door bell ringed */\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\nwritel(outbound_doorbell, &reg->outbound_doorbell); /*clear interrupt */\r\nwritel(ARCMSR_INBOUND_DRIVER_DATA_READ_OK, &reg->inbound_doorbell);\r\n/* enable outbound Post Queue,outbound doorbell Interrupt */\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nacb->acb_flags &= ~ACB_F_BUS_RESET;\r\nrtn = SUCCESS;\r\nprintk(KERN_ERR "arcmsr: scsi bus reset eh returns with success\n");\r\n} else {\r\nacb->acb_flags &= ~ACB_F_BUS_RESET;\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6*HZ));\r\nrtn = SUCCESS;\r\n}\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_B:{\r\nacb->acb_flags |= ACB_F_BUS_RESET;\r\nif (!arcmsr_iop_reset(acb)) {\r\nacb->acb_flags &= ~ACB_F_BUS_RESET;\r\nrtn = FAILED;\r\n} else {\r\nacb->acb_flags &= ~ACB_F_BUS_RESET;\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nrtn = SUCCESS;\r\n}\r\nbreak;\r\n}\r\ncase ACB_ADAPTER_TYPE_C:{\r\nif (acb->acb_flags & ACB_F_BUS_RESET) {\r\nlong timeout;\r\nprintk(KERN_ERR "arcmsr: there is an bus reset eh proceeding.......\n");\r\ntimeout = wait_event_timeout(wait_q, (acb->acb_flags & ACB_F_BUS_RESET) == 0, 220*HZ);\r\nif (timeout) {\r\nreturn SUCCESS;\r\n}\r\n}\r\nacb->acb_flags |= ACB_F_BUS_RESET;\r\nif (!arcmsr_iop_reset(acb)) {\r\nstruct MessageUnit_C __iomem *reg;\r\nreg = acb->pmuC;\r\narcmsr_hardware_reset(acb);\r\nacb->acb_flags &= ~ACB_F_IOP_INITED;\r\nsleep:\r\nssleep(ARCMSR_SLEEPTIME);\r\nif ((readl(&reg->host_diagnostic) & 0x04) != 0) {\r\nprintk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, retry=%d\n", acb->host->host_no, retry_count);\r\nif (retry_count > ARCMSR_RETRYCOUNT) {\r\nacb->fw_flag = FW_DEADLOCK;\r\nprintk(KERN_ERR "arcmsr%d: waiting for hw bus reset return, RETRY TERMINATED!!\n", acb->host->host_no);\r\nreturn FAILED;\r\n}\r\nretry_count++;\r\ngoto sleep;\r\n}\r\nacb->acb_flags |= ACB_F_IOP_INITED;\r\n/* disable all outbound interrupt */\r\nintmask_org = arcmsr_disable_outbound_ints(acb);\r\narcmsr_get_firmware_spec(acb);\r\narcmsr_start_adapter_bgrb(acb);\r\n/* clear Qbuffer if door bell ringed */\r\noutbound_doorbell = readl(&reg->outbound_doorbell);\r\nwritel(outbound_doorbell, &reg->outbound_doorbell_clear); /*clear interrupt */\r\nwritel(ARCMSR_HBCMU_DRV2IOP_DATA_READ_OK, &reg->inbound_doorbell);\r\n/* enable outbound Post Queue,outbound doorbell Interrupt */\r\narcmsr_enable_outbound_ints(acb, intmask_org);\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6 * HZ));\r\nacb->acb_flags &= ~ACB_F_BUS_RESET;\r\nrtn = SUCCESS;\r\nprintk(KERN_ERR "arcmsr: scsi bus reset eh returns with success\n");\r\n} else {\r\nacb->acb_flags &= ~ACB_F_BUS_RESET;\r\natomic_set(&acb->rq_map_token, 16);\r\natomic_set(&acb->ante_token_value, 16);\r\nacb->fw_flag = FW_NORMAL;\r\nmod_timer(&acb->eternal_timer, jiffies + msecs_to_jiffies(6*HZ));\r\nrtn = SUCCESS;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_abort_one_cmd(struct AdapterControlBlock *acb,\r\nstruct CommandControlBlock *ccb)\r\n{\r\nint rtn;\r\nrtn = arcmsr_polling_ccbdone(acb, ccb);\r\nreturn rtn;\r\n}\r\nstatic int arcmsr_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *)cmd->device->host->hostdata;\r\nint i = 0;\r\nint rtn = FAILED;\r\nprintk(KERN_NOTICE\r\n"arcmsr%d: abort device command of scsi id = %d lun = %d \n",\r\nacb->host->host_no, cmd->device->id, cmd->device->lun);\r\nacb->acb_flags |= ACB_F_ABORT;\r\nacb->num_aborts++;\r\n/*\r\n************************************************\r\n** the all interrupt service routine is locked\r\n** we need to handle it as soon as possible and exit\r\n************************************************\r\n*/\r\nif (!atomic_read(&acb->ccboutstandingcount))\r\nreturn rtn;\r\nfor (i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++) {\r\nstruct CommandControlBlock *ccb = acb->pccb_pool[i];\r\nif (ccb->startdone == ARCMSR_CCB_START && ccb->pcmd == cmd) {\r\nccb->startdone = ARCMSR_CCB_ABORTED;\r\nrtn = arcmsr_abort_one_cmd(acb, ccb);\r\nbreak;\r\n}\r\n}\r\nacb->acb_flags &= ~ACB_F_ABORT;\r\nreturn rtn;\r\n}\r\nstatic const char *arcmsr_info(struct Scsi_Host *host)\r\n{\r\nstruct AdapterControlBlock *acb =\r\n(struct AdapterControlBlock *) host->hostdata;\r\nstatic char buf[256];\r\nchar *type;\r\nint raid6 = 1;\r\nswitch (acb->pdev->device) {\r\ncase PCI_DEVICE_ID_ARECA_1110:\r\ncase PCI_DEVICE_ID_ARECA_1200:\r\ncase PCI_DEVICE_ID_ARECA_1202:\r\ncase PCI_DEVICE_ID_ARECA_1210:\r\nraid6 = 0;\r\n/*FALLTHRU*/\r\ncase PCI_DEVICE_ID_ARECA_1120:\r\ncase PCI_DEVICE_ID_ARECA_1130:\r\ncase PCI_DEVICE_ID_ARECA_1160:\r\ncase PCI_DEVICE_ID_ARECA_1170:\r\ncase PCI_DEVICE_ID_ARECA_1201:\r\ncase PCI_DEVICE_ID_ARECA_1220:\r\ncase PCI_DEVICE_ID_ARECA_1230:\r\ncase PCI_DEVICE_ID_ARECA_1260:\r\ncase PCI_DEVICE_ID_ARECA_1270:\r\ncase PCI_DEVICE_ID_ARECA_1280:\r\ntype = "SATA";\r\nbreak;\r\ncase PCI_DEVICE_ID_ARECA_1380:\r\ncase PCI_DEVICE_ID_ARECA_1381:\r\ncase PCI_DEVICE_ID_ARECA_1680:\r\ncase PCI_DEVICE_ID_ARECA_1681:\r\ncase PCI_DEVICE_ID_ARECA_1880:\r\ntype = "SAS";\r\nbreak;\r\ndefault:\r\ntype = "X-TYPE";\r\nbreak;\r\n}\r\nsprintf(buf, "Areca %s Host Adapter RAID Controller%s\n %s",\r\ntype, raid6 ? "( RAID6 capable)" : "",\r\nARCMSR_DRIVER_VERSION);\r\nreturn buf;\r\n}
