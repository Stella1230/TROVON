ssize_t nfs_dns_resolve_name(struct net *net, char *name, size_t namelen,\r\nstruct sockaddr *sa, size_t salen)\r\n{\r\nssize_t ret;\r\nchar *ip_addr = NULL;\r\nint ip_len;\r\nip_len = dns_query(NULL, name, namelen, NULL, &ip_addr, NULL);\r\nif (ip_len > 0)\r\nret = rpc_pton(net, ip_addr, ip_len, sa, salen);\r\nelse\r\nret = -ESRCH;\r\nkfree(ip_addr);\r\nreturn ret;\r\n}\r\nstatic void nfs_dns_ent_update(struct cache_head *cnew,\r\nstruct cache_head *ckey)\r\n{\r\nstruct nfs_dns_ent *new;\r\nstruct nfs_dns_ent *key;\r\nnew = container_of(cnew, struct nfs_dns_ent, h);\r\nkey = container_of(ckey, struct nfs_dns_ent, h);\r\nmemcpy(&new->addr, &key->addr, key->addrlen);\r\nnew->addrlen = key->addrlen;\r\n}\r\nstatic void nfs_dns_ent_init(struct cache_head *cnew,\r\nstruct cache_head *ckey)\r\n{\r\nstruct nfs_dns_ent *new;\r\nstruct nfs_dns_ent *key;\r\nnew = container_of(cnew, struct nfs_dns_ent, h);\r\nkey = container_of(ckey, struct nfs_dns_ent, h);\r\nkfree(new->hostname);\r\nnew->hostname = kstrndup(key->hostname, key->namelen, GFP_KERNEL);\r\nif (new->hostname) {\r\nnew->namelen = key->namelen;\r\nnfs_dns_ent_update(cnew, ckey);\r\n} else {\r\nnew->namelen = 0;\r\nnew->addrlen = 0;\r\n}\r\n}\r\nstatic void nfs_dns_ent_put(struct kref *ref)\r\n{\r\nstruct nfs_dns_ent *item;\r\nitem = container_of(ref, struct nfs_dns_ent, h.ref);\r\nkfree(item->hostname);\r\nkfree(item);\r\n}\r\nstatic struct cache_head *nfs_dns_ent_alloc(void)\r\n{\r\nstruct nfs_dns_ent *item = kmalloc(sizeof(*item), GFP_KERNEL);\r\nif (item != NULL) {\r\nitem->hostname = NULL;\r\nitem->namelen = 0;\r\nitem->addrlen = 0;\r\nreturn &item->h;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int nfs_dns_hash(const struct nfs_dns_ent *key)\r\n{\r\nreturn hash_str(key->hostname, NFS_DNS_HASHBITS);\r\n}\r\nstatic void nfs_dns_request(struct cache_detail *cd,\r\nstruct cache_head *ch,\r\nchar **bpp, int *blen)\r\n{\r\nstruct nfs_dns_ent *key = container_of(ch, struct nfs_dns_ent, h);\r\nqword_add(bpp, blen, key->hostname);\r\n(*bpp)[-1] = '\n';\r\n}\r\nstatic int nfs_dns_upcall(struct cache_detail *cd,\r\nstruct cache_head *ch)\r\n{\r\nstruct nfs_dns_ent *key = container_of(ch, struct nfs_dns_ent, h);\r\nint ret;\r\nret = nfs_cache_upcall(cd, key->hostname);\r\nif (ret)\r\nret = sunrpc_cache_pipe_upcall(cd, ch, nfs_dns_request);\r\nreturn ret;\r\n}\r\nstatic int nfs_dns_match(struct cache_head *ca,\r\nstruct cache_head *cb)\r\n{\r\nstruct nfs_dns_ent *a;\r\nstruct nfs_dns_ent *b;\r\na = container_of(ca, struct nfs_dns_ent, h);\r\nb = container_of(cb, struct nfs_dns_ent, h);\r\nif (a->namelen == 0 || a->namelen != b->namelen)\r\nreturn 0;\r\nreturn memcmp(a->hostname, b->hostname, a->namelen) == 0;\r\n}\r\nstatic int nfs_dns_show(struct seq_file *m, struct cache_detail *cd,\r\nstruct cache_head *h)\r\n{\r\nstruct nfs_dns_ent *item;\r\nlong ttl;\r\nif (h == NULL) {\r\nseq_puts(m, "# ip address hostname ttl\n");\r\nreturn 0;\r\n}\r\nitem = container_of(h, struct nfs_dns_ent, h);\r\nttl = item->h.expiry_time - seconds_since_boot();\r\nif (ttl < 0)\r\nttl = 0;\r\nif (!test_bit(CACHE_NEGATIVE, &h->flags)) {\r\nchar buf[INET6_ADDRSTRLEN+IPV6_SCOPE_ID_LEN+1];\r\nrpc_ntop((struct sockaddr *)&item->addr, buf, sizeof(buf));\r\nseq_printf(m, "%15s ", buf);\r\n} else\r\nseq_puts(m, "<none> ");\r\nseq_printf(m, "%15s %ld\n", item->hostname, ttl);\r\nreturn 0;\r\n}\r\nstatic struct nfs_dns_ent *nfs_dns_lookup(struct cache_detail *cd,\r\nstruct nfs_dns_ent *key)\r\n{\r\nstruct cache_head *ch;\r\nch = sunrpc_cache_lookup(cd,\r\n&key->h,\r\nnfs_dns_hash(key));\r\nif (!ch)\r\nreturn NULL;\r\nreturn container_of(ch, struct nfs_dns_ent, h);\r\n}\r\nstatic struct nfs_dns_ent *nfs_dns_update(struct cache_detail *cd,\r\nstruct nfs_dns_ent *new,\r\nstruct nfs_dns_ent *key)\r\n{\r\nstruct cache_head *ch;\r\nch = sunrpc_cache_update(cd,\r\n&new->h, &key->h,\r\nnfs_dns_hash(key));\r\nif (!ch)\r\nreturn NULL;\r\nreturn container_of(ch, struct nfs_dns_ent, h);\r\n}\r\nstatic int nfs_dns_parse(struct cache_detail *cd, char *buf, int buflen)\r\n{\r\nchar buf1[NFS_DNS_HOSTNAME_MAXLEN+1];\r\nstruct nfs_dns_ent key, *item;\r\nunsigned long ttl;\r\nssize_t len;\r\nint ret = -EINVAL;\r\nif (buf[buflen-1] != '\n')\r\ngoto out;\r\nbuf[buflen-1] = '\0';\r\nlen = qword_get(&buf, buf1, sizeof(buf1));\r\nif (len <= 0)\r\ngoto out;\r\nkey.addrlen = rpc_pton(cd->net, buf1, len,\r\n(struct sockaddr *)&key.addr,\r\nsizeof(key.addr));\r\nlen = qword_get(&buf, buf1, sizeof(buf1));\r\nif (len <= 0)\r\ngoto out;\r\nkey.hostname = buf1;\r\nkey.namelen = len;\r\nmemset(&key.h, 0, sizeof(key.h));\r\nttl = get_expiry(&buf);\r\nif (ttl == 0)\r\ngoto out;\r\nkey.h.expiry_time = ttl + seconds_since_boot();\r\nret = -ENOMEM;\r\nitem = nfs_dns_lookup(cd, &key);\r\nif (item == NULL)\r\ngoto out;\r\nif (key.addrlen == 0)\r\nset_bit(CACHE_NEGATIVE, &key.h.flags);\r\nitem = nfs_dns_update(cd, &key, item);\r\nif (item == NULL)\r\ngoto out;\r\nret = 0;\r\ncache_put(&item->h, cd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int do_cache_lookup(struct cache_detail *cd,\r\nstruct nfs_dns_ent *key,\r\nstruct nfs_dns_ent **item,\r\nstruct nfs_cache_defer_req *dreq)\r\n{\r\nint ret = -ENOMEM;\r\n*item = nfs_dns_lookup(cd, key);\r\nif (*item) {\r\nret = cache_check(cd, &(*item)->h, &dreq->req);\r\nif (ret)\r\n*item = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int do_cache_lookup_nowait(struct cache_detail *cd,\r\nstruct nfs_dns_ent *key,\r\nstruct nfs_dns_ent **item)\r\n{\r\nint ret = -ENOMEM;\r\n*item = nfs_dns_lookup(cd, key);\r\nif (!*item)\r\ngoto out_err;\r\nret = -ETIMEDOUT;\r\nif (!test_bit(CACHE_VALID, &(*item)->h.flags)\r\n|| (*item)->h.expiry_time < seconds_since_boot()\r\n|| cd->flush_time > (*item)->h.last_refresh)\r\ngoto out_put;\r\nret = -ENOENT;\r\nif (test_bit(CACHE_NEGATIVE, &(*item)->h.flags))\r\ngoto out_put;\r\nreturn 0;\r\nout_put:\r\ncache_put(&(*item)->h, cd);\r\nout_err:\r\n*item = NULL;\r\nreturn ret;\r\n}\r\nstatic int do_cache_lookup_wait(struct cache_detail *cd,\r\nstruct nfs_dns_ent *key,\r\nstruct nfs_dns_ent **item)\r\n{\r\nstruct nfs_cache_defer_req *dreq;\r\nint ret = -ENOMEM;\r\ndreq = nfs_cache_defer_req_alloc();\r\nif (!dreq)\r\ngoto out;\r\nret = do_cache_lookup(cd, key, item, dreq);\r\nif (ret == -EAGAIN) {\r\nret = nfs_cache_wait_for_upcall(dreq);\r\nif (!ret)\r\nret = do_cache_lookup_nowait(cd, key, item);\r\n}\r\nnfs_cache_defer_req_put(dreq);\r\nout:\r\nreturn ret;\r\n}\r\nssize_t nfs_dns_resolve_name(struct net *net, char *name,\r\nsize_t namelen, struct sockaddr *sa, size_t salen)\r\n{\r\nstruct nfs_dns_ent key = {\r\n.hostname = name,\r\n.namelen = namelen,\r\n};\r\nstruct nfs_dns_ent *item = NULL;\r\nssize_t ret;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nret = do_cache_lookup_wait(nn->nfs_dns_resolve, &key, &item);\r\nif (ret == 0) {\r\nif (salen >= item->addrlen) {\r\nmemcpy(sa, &item->addr, item->addrlen);\r\nret = item->addrlen;\r\n} else\r\nret = -EOVERFLOW;\r\ncache_put(&item->h, nn->nfs_dns_resolve);\r\n} else if (ret == -ENOENT)\r\nret = -ESRCH;\r\nreturn ret;\r\n}\r\nint nfs_dns_resolver_cache_init(struct net *net)\r\n{\r\nint err = -ENOMEM;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct cache_detail *cd;\r\nstruct cache_head **tbl;\r\ncd = kzalloc(sizeof(struct cache_detail), GFP_KERNEL);\r\nif (cd == NULL)\r\ngoto err_cd;\r\ntbl = kzalloc(NFS_DNS_HASHTBL_SIZE * sizeof(struct cache_head *),\r\nGFP_KERNEL);\r\nif (tbl == NULL)\r\ngoto err_tbl;\r\ncd->owner = THIS_MODULE,\r\ncd->hash_size = NFS_DNS_HASHTBL_SIZE,\r\ncd->hash_table = tbl,\r\ncd->name = "dns_resolve",\r\ncd->cache_put = nfs_dns_ent_put,\r\ncd->cache_upcall = nfs_dns_upcall,\r\ncd->cache_parse = nfs_dns_parse,\r\ncd->cache_show = nfs_dns_show,\r\ncd->match = nfs_dns_match,\r\ncd->init = nfs_dns_ent_init,\r\ncd->update = nfs_dns_ent_update,\r\ncd->alloc = nfs_dns_ent_alloc,\r\nnfs_cache_init(cd);\r\nerr = nfs_cache_register_net(net, cd);\r\nif (err)\r\ngoto err_reg;\r\nnn->nfs_dns_resolve = cd;\r\nreturn 0;\r\nerr_reg:\r\nnfs_cache_destroy(cd);\r\nkfree(cd->hash_table);\r\nerr_tbl:\r\nkfree(cd);\r\nerr_cd:\r\nreturn err;\r\n}\r\nvoid nfs_dns_resolver_cache_destroy(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct cache_detail *cd = nn->nfs_dns_resolve;\r\nnfs_cache_unregister_net(net, cd);\r\nnfs_cache_destroy(cd);\r\nkfree(cd->hash_table);\r\nkfree(cd);\r\n}\r\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct super_block *sb = ptr;\r\nstruct net *net = sb->s_fs_info;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct cache_detail *cd = nn->nfs_dns_resolve;\r\nint ret = 0;\r\nif (cd == NULL)\r\nreturn 0;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn 0;\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\nret = nfs_cache_register_sb(sb, cd);\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\nnfs_cache_unregister_sb(sb, cd);\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nint nfs_dns_resolver_init(void)\r\n{\r\nreturn rpc_pipefs_notifier_register(&nfs_dns_resolver_block);\r\n}\r\nvoid nfs_dns_resolver_destroy(void)\r\n{\r\nrpc_pipefs_notifier_unregister(&nfs_dns_resolver_block);\r\n}
