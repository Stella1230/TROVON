static void ultra_poll(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nei_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int __init do_ultra_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint base_addr = dev->base_addr;\r\nint irq = dev->irq;\r\nif (base_addr > 0x1ff)\r\nreturn ultra_probe1(dev, base_addr);\r\nelse if (base_addr != 0)\r\nreturn -ENXIO;\r\n#ifdef __ISAPNP__\r\nif (isapnp_present() && (ultra_probe_isapnp(dev) == 0))\r\nreturn 0;\r\n#endif\r\nfor (i = 0; ultra_portlist[i]; i++) {\r\ndev->irq = irq;\r\nif (ultra_probe1(dev, ultra_portlist[i]) == 0)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstruct net_device * __init ultra_probe(int unit)\r\n{\r\nstruct net_device *dev = alloc_ei_netdev();\r\nint err;\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\nerr = do_ultra_probe(dev);\r\nif (err)\r\ngoto out;\r\nreturn dev;\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init ultra_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i, retval;\r\nint checksum = 0;\r\nconst char *model_name;\r\nunsigned char eeprom_irq = 0;\r\nstatic unsigned version_printed;\r\nunsigned char num_pages, irqreg, addr, piomode;\r\nunsigned char idreg = inb(ioaddr + 7);\r\nunsigned char reg4 = inb(ioaddr + 4) & 0x7f;\r\nif (!request_region(ioaddr, ULTRA_IO_EXTENT, DRV_NAME))\r\nreturn -EBUSY;\r\nif ((idreg & 0xF0) != 0x20\r\n&& (idreg & 0xF0) != 0x40) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\noutb(reg4, ioaddr + 4);\r\nfor (i = 0; i < 8; i++)\r\nchecksum += inb(ioaddr + 8 + i);\r\nif ((checksum & 0xff) != 0xFF) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(version);\r\nmodel_name = (idreg & 0xF0) == 0x20 ? "SMC Ultra" : "SMC EtherEZ";\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(ioaddr + 8 + i);\r\nprintk("%s: %s at %#3x, %pM", dev->name, model_name,\r\nioaddr, dev->dev_addr);\r\noutb(0x80 | reg4, ioaddr + 4);\r\noutb(0x80 | inb(ioaddr + 0x0c), ioaddr + 0x0c);\r\npiomode = inb(ioaddr + 0x8);\r\naddr = inb(ioaddr + 0xb);\r\nirqreg = inb(ioaddr + 0xd);\r\noutb(reg4, ioaddr + 4);\r\nif (dev->irq < 2) {\r\nunsigned char irqmap[] = {0, 9, 3, 5, 7, 10, 11, 15};\r\nint irq;\r\nirq = irqmap[((irqreg & 0x40) >> 4) + ((irqreg & 0x0c) >> 2)];\r\nif (irq == 0) {\r\nprintk(", failed to detect IRQ line.\n");\r\nretval = -EAGAIN;\r\ngoto out;\r\n}\r\ndev->irq = irq;\r\neeprom_irq = 1;\r\n}\r\ndev->base_addr = ioaddr+ULTRA_NIC_OFFSET;\r\n{\r\nstatic const int addr_tbl[4] = {\r\n0x0C0000, 0x0E0000, 0xFC0000, 0xFE0000\r\n};\r\nstatic const short num_pages_tbl[4] = {\r\n0x20, 0x40, 0x80, 0xff\r\n};\r\ndev->mem_start = ((addr & 0x0f) << 13) + addr_tbl[(addr >> 6) & 3] ;\r\nnum_pages = num_pages_tbl[(addr >> 4) & 3];\r\n}\r\nei_status.name = model_name;\r\nei_status.word16 = 1;\r\nei_status.tx_start_page = START_PG;\r\nei_status.rx_start_page = START_PG + TX_PAGES;\r\nei_status.stop_page = num_pages;\r\nei_status.mem = ioremap(dev->mem_start, (ei_status.stop_page - START_PG)*256);\r\nif (!ei_status.mem) {\r\nprintk(", failed to ioremap.\n");\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\ndev->mem_end = dev->mem_start + (ei_status.stop_page - START_PG)*256;\r\nif (piomode) {\r\nprintk(",%s IRQ %d programmed-I/O mode.\n",\r\neeprom_irq ? "EEPROM" : "assigned ", dev->irq);\r\nei_status.block_input = &ultra_pio_input;\r\nei_status.block_output = &ultra_pio_output;\r\nei_status.get_8390_hdr = &ultra_pio_get_hdr;\r\n} else {\r\nprintk(",%s IRQ %d memory %#lx-%#lx.\n", eeprom_irq ? "" : "assigned ",\r\ndev->irq, dev->mem_start, dev->mem_end-1);\r\nei_status.block_input = &ultra_block_input;\r\nei_status.block_output = &ultra_block_output;\r\nei_status.get_8390_hdr = &ultra_get_8390_hdr;\r\n}\r\nei_status.reset_8390 = &ultra_reset_8390;\r\ndev->netdev_ops = &ultra_netdev_ops;\r\nNS8390_init(dev, 0);\r\nretval = register_netdev(dev);\r\nif (retval)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nrelease_region(ioaddr, ULTRA_IO_EXTENT);\r\nreturn retval;\r\n}\r\nstatic int __init ultra_probe_isapnp(struct net_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; ultra_device_ids[i].vendor != 0; i++) {\r\nstruct pnp_dev *idev = NULL;\r\nwhile ((idev = pnp_find_dev(NULL,\r\nultra_device_ids[i].vendor,\r\nultra_device_ids[i].function,\r\nidev))) {\r\nif (pnp_device_attach(idev) < 0)\r\ncontinue;\r\nif (pnp_activate_dev(idev) < 0) {\r\n__again:\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\nif (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0))\r\ngoto __again;\r\ndev->base_addr = pnp_port_start(idev, 0);\r\ndev->irq = pnp_irq(idev, 0);\r\nprintk(KERN_INFO "smc-ultra.c: ISAPnP reports %s at i/o %#lx, irq %d.\n",\r\n(char *) ultra_device_ids[i].driver_data,\r\ndev->base_addr, dev->irq);\r\nif (ultra_probe1(dev, dev->base_addr) != 0) {\r\nprintk(KERN_ERR "smc-ultra.c: Probe of ISAPnP card at %#lx failed.\n", dev->base_addr);\r\npnp_device_detach(idev);\r\nreturn -ENXIO;\r\n}\r\nei_status.priv = (unsigned long)idev;\r\nbreak;\r\n}\r\nif (!idev)\r\ncontinue;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nultra_open(struct net_device *dev)\r\n{\r\nint retval;\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\nunsigned char irq2reg[] = {0, 0, 0x04, 0x08, 0, 0x0C, 0, 0x40,\r\n0, 0x04, 0x44, 0x48, 0, 0, 0, 0x4C, };\r\nretval = request_irq(dev->irq, ei_interrupt, 0, dev->name, dev);\r\nif (retval)\r\nreturn retval;\r\noutb(0x00, ioaddr);\r\noutb(0x80, ioaddr + 5);\r\noutb(inb(ioaddr + 4) | 0x80, ioaddr + 4);\r\noutb((inb(ioaddr + 13) & ~0x4C) | irq2reg[dev->irq], ioaddr + 13);\r\noutb(inb(ioaddr + 4) & 0x7f, ioaddr + 4);\r\nif (ei_status.block_input == &ultra_pio_input) {\r\noutb(0x11, ioaddr + 6);\r\noutb(0x01, ioaddr + 0x19);\r\n} else\r\noutb(0x01, ioaddr + 6);\r\noutb_p(E8390_NODMA+E8390_PAGE0, dev->base_addr);\r\noutb(0xff, dev->base_addr + EN0_ERWCNT);\r\nei_open(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nultra_reset_8390(struct net_device *dev)\r\n{\r\nint cmd_port = dev->base_addr - ULTRA_NIC_OFFSET;\r\noutb(ULTRA_RESET, cmd_port);\r\nif (ei_debug > 1) printk("resetting Ultra, t=%ld...", jiffies);\r\nei_status.txing = 0;\r\noutb(0x00, cmd_port);\r\noutb(0x80, cmd_port + 5);\r\nif (ei_status.block_input == &ultra_pio_input)\r\noutb(0x11, cmd_port + 6);\r\nelse\r\noutb(0x01, cmd_port + 6);\r\nif (ei_debug > 1) printk("reset done\n");\r\n}\r\nstatic void\r\nultra_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nvoid __iomem *hdr_start = ei_status.mem + ((ring_page - START_PG)<<8);\r\noutb(ULTRA_MEMENB, dev->base_addr - ULTRA_NIC_OFFSET);\r\n#ifdef __BIG_ENDIAN\r\nmemcpy_fromio(hdr, hdr_start, sizeof(struct e8390_pkt_hdr));\r\nhdr->count = le16_to_cpu(hdr->count);\r\n#else\r\n((unsigned int*)hdr)[0] = readl(hdr_start);\r\n#endif\r\noutb(0x00, dev->base_addr - ULTRA_NIC_OFFSET);\r\n}\r\nstatic void\r\nultra_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nvoid __iomem *xfer_start = ei_status.mem + ring_offset - (START_PG<<8);\r\noutb(ULTRA_MEMENB, dev->base_addr - ULTRA_NIC_OFFSET);\r\nif (ring_offset + count > ei_status.stop_page*256) {\r\nint semi_count = ei_status.stop_page*256 - ring_offset;\r\nmemcpy_fromio(skb->data, xfer_start, semi_count);\r\ncount -= semi_count;\r\nmemcpy_fromio(skb->data + semi_count, ei_status.mem + TX_PAGES * 256, count);\r\n} else {\r\nmemcpy_fromio(skb->data, xfer_start, count);\r\n}\r\noutb(0x00, dev->base_addr - ULTRA_NIC_OFFSET);\r\n}\r\nstatic void\r\nultra_block_output(struct net_device *dev, int count, const unsigned char *buf,\r\nint start_page)\r\n{\r\nvoid __iomem *shmem = ei_status.mem + ((start_page - START_PG)<<8);\r\noutb(ULTRA_MEMENB, dev->base_addr - ULTRA_NIC_OFFSET);\r\nmemcpy_toio(shmem, buf, count);\r\noutb(0x00, dev->base_addr - ULTRA_NIC_OFFSET);\r\n}\r\nstatic void ultra_pio_get_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,\r\nint ring_page)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\noutb(0x00, ioaddr + IOPA);\r\noutb(ring_page, ioaddr + IOPA);\r\ninsw(ioaddr + IOPD, hdr, sizeof(struct e8390_pkt_hdr)>>1);\r\n}\r\nstatic void ultra_pio_input(struct net_device *dev, int count,\r\nstruct sk_buff *skb, int ring_offset)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\nchar *buf = skb->data;\r\noutb(ring_offset, ioaddr + IOPA);\r\noutb(ring_offset >> 8, ioaddr + IOPA);\r\ninsw(ioaddr + IOPD, buf, (count+1)>>1);\r\n}\r\nstatic void ultra_pio_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\noutb(0x00, ioaddr + IOPA);\r\noutb(start_page, ioaddr + IOPA);\r\noutsw(ioaddr + IOPD, buf, (count+1)>>1);\r\n}\r\nstatic int\r\nultra_close_card(struct net_device *dev)\r\n{\r\nint ioaddr = dev->base_addr - ULTRA_NIC_OFFSET;\r\nnetif_stop_queue(dev);\r\nif (ei_debug > 1)\r\nprintk("%s: Shutting down ethercard.\n", dev->name);\r\noutb(0x00, ioaddr + 6);\r\nfree_irq(dev->irq, dev);\r\nNS8390_init(dev, 0);\r\nreturn 0;\r\n}\r\nint __init\r\ninit_module(void)\r\n{\r\nstruct net_device *dev;\r\nint this_dev, found = 0;\r\nfor (this_dev = 0; this_dev < MAX_ULTRA_CARDS; this_dev++) {\r\nif (io[this_dev] == 0) {\r\nif (this_dev != 0) break;\r\nprintk(KERN_NOTICE "smc-ultra.c: Presently autoprobing (not recommended) for a single card.\n");\r\n}\r\ndev = alloc_ei_netdev();\r\nif (!dev)\r\nbreak;\r\ndev->irq = irq[this_dev];\r\ndev->base_addr = io[this_dev];\r\nif (do_ultra_probe(dev) == 0) {\r\ndev_ultra[found++] = dev;\r\ncontinue;\r\n}\r\nfree_netdev(dev);\r\nprintk(KERN_WARNING "smc-ultra.c: No SMC Ultra card found (i/o = 0x%x).\n", io[this_dev]);\r\nbreak;\r\n}\r\nif (found)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nstatic void cleanup_card(struct net_device *dev)\r\n{\r\n#ifdef __ISAPNP__\r\nstruct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;\r\nif (idev)\r\npnp_device_detach(idev);\r\n#endif\r\nrelease_region(dev->base_addr - ULTRA_NIC_OFFSET, ULTRA_IO_EXTENT);\r\niounmap(ei_status.mem);\r\n}\r\nvoid __exit\r\ncleanup_module(void)\r\n{\r\nint this_dev;\r\nfor (this_dev = 0; this_dev < MAX_ULTRA_CARDS; this_dev++) {\r\nstruct net_device *dev = dev_ultra[this_dev];\r\nif (dev) {\r\nunregister_netdev(dev);\r\ncleanup_card(dev);\r\nfree_netdev(dev);\r\n}\r\n}\r\n}
