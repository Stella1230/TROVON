static void nat_decode_session(struct sk_buff *skb, struct flowi *fl)\r\n{\r\nstruct flowi4 *fl4 = &fl->u.ip4;\r\nconst struct nf_conn *ct;\r\nconst struct nf_conntrack_tuple *t;\r\nenum ip_conntrack_info ctinfo;\r\nenum ip_conntrack_dir dir;\r\nunsigned long statusbit;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn;\r\ndir = CTINFO2DIR(ctinfo);\r\nt = &ct->tuplehash[dir].tuple;\r\nif (dir == IP_CT_DIR_ORIGINAL)\r\nstatusbit = IPS_DST_NAT;\r\nelse\r\nstatusbit = IPS_SRC_NAT;\r\nif (ct->status & statusbit) {\r\nfl4->daddr = t->dst.u3.ip;\r\nif (t->dst.protonum == IPPROTO_TCP ||\r\nt->dst.protonum == IPPROTO_UDP ||\r\nt->dst.protonum == IPPROTO_UDPLITE ||\r\nt->dst.protonum == IPPROTO_DCCP ||\r\nt->dst.protonum == IPPROTO_SCTP)\r\nfl4->fl4_dport = t->dst.u.tcp.port;\r\n}\r\nstatusbit ^= IPS_NAT_MASK;\r\nif (ct->status & statusbit) {\r\nfl4->saddr = t->src.u3.ip;\r\nif (t->dst.protonum == IPPROTO_TCP ||\r\nt->dst.protonum == IPPROTO_UDP ||\r\nt->dst.protonum == IPPROTO_UDPLITE ||\r\nt->dst.protonum == IPPROTO_DCCP ||\r\nt->dst.protonum == IPPROTO_SCTP)\r\nfl4->fl4_sport = t->src.u.tcp.port;\r\n}\r\n}\r\nstatic unsigned int\r\nnf_nat_fn(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn_nat *nat;\r\nenum nf_nat_manip_type maniptype = HOOK2MANIP(hooknum);\r\nNF_CT_ASSERT(!ip_is_fragment(ip_hdr(skb)));\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct)\r\nreturn NF_ACCEPT;\r\nif (nf_ct_is_untracked(ct))\r\nreturn NF_ACCEPT;\r\nnat = nfct_nat(ct);\r\nif (!nat) {\r\nif (nf_ct_is_confirmed(ct))\r\nreturn NF_ACCEPT;\r\nnat = nf_ct_ext_add(ct, NF_CT_EXT_NAT, GFP_ATOMIC);\r\nif (nat == NULL) {\r\npr_debug("failed to add NAT extension\n");\r\nreturn NF_ACCEPT;\r\n}\r\n}\r\nswitch (ctinfo) {\r\ncase IP_CT_RELATED:\r\ncase IP_CT_RELATED_REPLY:\r\nif (ip_hdr(skb)->protocol == IPPROTO_ICMP) {\r\nif (!nf_nat_icmp_reply_translation(ct, ctinfo,\r\nhooknum, skb))\r\nreturn NF_DROP;\r\nelse\r\nreturn NF_ACCEPT;\r\n}\r\ncase IP_CT_NEW:\r\nif (!nf_nat_initialized(ct, maniptype)) {\r\nunsigned int ret;\r\nret = nf_nat_rule_find(skb, hooknum, in, out, ct);\r\nif (ret != NF_ACCEPT)\r\nreturn ret;\r\n} else\r\npr_debug("Already setup manip %s for ct %p\n",\r\nmaniptype == NF_NAT_MANIP_SRC ? "SRC" : "DST",\r\nct);\r\nbreak;\r\ndefault:\r\nNF_CT_ASSERT(ctinfo == IP_CT_ESTABLISHED ||\r\nctinfo == IP_CT_ESTABLISHED_REPLY);\r\n}\r\nreturn nf_nat_packet(ct, ctinfo, hooknum, skb);\r\n}\r\nstatic unsigned int\r\nnf_nat_in(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nunsigned int ret;\r\n__be32 daddr = ip_hdr(skb)->daddr;\r\nret = nf_nat_fn(hooknum, skb, in, out, okfn);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\ndaddr != ip_hdr(skb)->daddr)\r\nskb_dst_drop(skb);\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nnf_nat_out(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\n#ifdef CONFIG_XFRM\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\n#endif\r\nunsigned int ret;\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr))\r\nreturn NF_ACCEPT;\r\nret = nf_nat_fn(hooknum, skb, in, out, okfn);\r\n#ifdef CONFIG_XFRM\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(ct = nf_ct_get(skb, &ctinfo)) != NULL) {\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nif ((ct->tuplehash[dir].tuple.src.u3.ip !=\r\nct->tuplehash[!dir].tuple.dst.u3.ip) ||\r\n(ct->tuplehash[dir].tuple.src.u.all !=\r\nct->tuplehash[!dir].tuple.dst.u.all)\r\n)\r\nreturn ip_xfrm_me_harder(skb) == 0 ? ret : NF_DROP;\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic unsigned int\r\nnf_nat_local_fn(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nunsigned int ret;\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr))\r\nreturn NF_ACCEPT;\r\nret = nf_nat_fn(hooknum, skb, in, out, okfn);\r\nif (ret != NF_DROP && ret != NF_STOLEN &&\r\n(ct = nf_ct_get(skb, &ctinfo)) != NULL) {\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nif (ct->tuplehash[dir].tuple.dst.u3.ip !=\r\nct->tuplehash[!dir].tuple.src.u3.ip) {\r\nif (ip_route_me_harder(skb, RTN_UNSPEC))\r\nret = NF_DROP;\r\n}\r\n#ifdef CONFIG_XFRM\r\nelse if (ct->tuplehash[dir].tuple.dst.u.all !=\r\nct->tuplehash[!dir].tuple.src.u.all)\r\nif (ip_xfrm_me_harder(skb))\r\nret = NF_DROP;\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init nf_nat_standalone_init(void)\r\n{\r\nint ret = 0;\r\nneed_ipv4_conntrack();\r\n#ifdef CONFIG_XFRM\r\nBUG_ON(ip_nat_decode_session != NULL);\r\nRCU_INIT_POINTER(ip_nat_decode_session, nat_decode_session);\r\n#endif\r\nret = nf_nat_rule_init();\r\nif (ret < 0) {\r\npr_err("nf_nat_init: can't setup rules.\n");\r\ngoto cleanup_decode_session;\r\n}\r\nret = nf_register_hooks(nf_nat_ops, ARRAY_SIZE(nf_nat_ops));\r\nif (ret < 0) {\r\npr_err("nf_nat_init: can't register hooks.\n");\r\ngoto cleanup_rule_init;\r\n}\r\nreturn ret;\r\ncleanup_rule_init:\r\nnf_nat_rule_cleanup();\r\ncleanup_decode_session:\r\n#ifdef CONFIG_XFRM\r\nRCU_INIT_POINTER(ip_nat_decode_session, NULL);\r\nsynchronize_net();\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit nf_nat_standalone_fini(void)\r\n{\r\nnf_unregister_hooks(nf_nat_ops, ARRAY_SIZE(nf_nat_ops));\r\nnf_nat_rule_cleanup();\r\n#ifdef CONFIG_XFRM\r\nRCU_INIT_POINTER(ip_nat_decode_session, NULL);\r\nsynchronize_net();\r\n#endif\r\n}
