static bool vidi_display_is_connected(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn ctx->connected ? true : false;\r\n}\r\nstatic int vidi_get_edid(struct device *dev, struct drm_connector *connector,\r\nu8 *edid, int len)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct edid *raw_edid;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (!ctx->raw_edid) {\r\nDRM_DEBUG_KMS("raw_edid is null.\n");\r\nreturn -EFAULT;\r\n}\r\nraw_edid = kzalloc(len, GFP_KERNEL);\r\nif (!raw_edid) {\r\nDRM_DEBUG_KMS("failed to allocate raw_edid.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(raw_edid, ctx->raw_edid, min((1 + ctx->raw_edid->extensions)\r\n* EDID_LENGTH, len));\r\nconnector->display_info.raw_edid = (char *)raw_edid;\r\nmemcpy(edid, ctx->raw_edid, min((1 + ctx->raw_edid->extensions)\r\n* EDID_LENGTH, len));\r\nreturn 0;\r\n}\r\nstatic void *vidi_get_panel(struct device *dev)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn NULL;\r\n}\r\nstatic int vidi_check_timing(struct device *dev, void *timing)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn 0;\r\n}\r\nstatic int vidi_display_power_on(struct device *dev, int mode)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn 0;\r\n}\r\nstatic void vidi_dpms(struct device *subdrv_dev, int mode)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(subdrv_dev);\r\nDRM_DEBUG_KMS("%s, %d\n", __FILE__, mode);\r\nmutex_lock(&ctx->lock);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("unspecified mode %d\n", mode);\r\nbreak;\r\n}\r\nmutex_unlock(&ctx->lock);\r\n}\r\nstatic void vidi_apply(struct device *subdrv_dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(subdrv_dev);\r\nstruct exynos_drm_manager *mgr = ctx->subdrv.manager;\r\nstruct exynos_drm_manager_ops *mgr_ops = mgr->ops;\r\nstruct exynos_drm_overlay_ops *ovl_ops = mgr->overlay_ops;\r\nstruct vidi_win_data *win_data;\r\nint i;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nfor (i = 0; i < WINDOWS_NR; i++) {\r\nwin_data = &ctx->win_data[i];\r\nif (win_data->enabled && (ovl_ops && ovl_ops->commit))\r\novl_ops->commit(subdrv_dev, i);\r\n}\r\nif (mgr_ops && mgr_ops->commit)\r\nmgr_ops->commit(subdrv_dev);\r\n}\r\nstatic void vidi_commit(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn;\r\n}\r\nstatic int vidi_enable_vblank(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn -EPERM;\r\nif (!test_and_set_bit(0, &ctx->irq_flags))\r\nctx->vblank_on = true;\r\nreturn 0;\r\n}\r\nstatic void vidi_disable_vblank(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nctx->vblank_on = false;\r\n}\r\nstatic void vidi_win_mode_set(struct device *dev,\r\nstruct exynos_drm_overlay *overlay)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct vidi_win_data *win_data;\r\nint win;\r\nunsigned long offset;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (!overlay) {\r\ndev_err(dev, "overlay is NULL\n");\r\nreturn;\r\n}\r\nwin = overlay->zpos;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win > WINDOWS_NR)\r\nreturn;\r\noffset = overlay->fb_x * (overlay->bpp >> 3);\r\noffset += overlay->fb_y * overlay->pitch;\r\nDRM_DEBUG_KMS("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);\r\nwin_data = &ctx->win_data[win];\r\nwin_data->offset_x = overlay->crtc_x;\r\nwin_data->offset_y = overlay->crtc_y;\r\nwin_data->ovl_width = overlay->crtc_width;\r\nwin_data->ovl_height = overlay->crtc_height;\r\nwin_data->fb_width = overlay->fb_width;\r\nwin_data->fb_height = overlay->fb_height;\r\nwin_data->dma_addr = overlay->dma_addr[0] + offset;\r\nwin_data->vaddr = overlay->vaddr[0] + offset;\r\nwin_data->bpp = overlay->bpp;\r\nwin_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *\r\n(overlay->bpp >> 3);\r\nwin_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);\r\nDRM_DEBUG_KMS("offset_x = %d, offset_y = %d\n",\r\nwin_data->offset_x, win_data->offset_y);\r\nDRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",\r\nwin_data->ovl_width, win_data->ovl_height);\r\nDRM_DEBUG_KMS("paddr = 0x%lx, vaddr = 0x%lx\n",\r\n(unsigned long)win_data->dma_addr,\r\n(unsigned long)win_data->vaddr);\r\nDRM_DEBUG_KMS("fb_width = %d, crtc_width = %d\n",\r\noverlay->fb_width, overlay->crtc_width);\r\n}\r\nstatic void vidi_win_commit(struct device *dev, int zpos)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct vidi_win_data *win_data;\r\nint win = zpos;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win > WINDOWS_NR)\r\nreturn;\r\nwin_data = &ctx->win_data[win];\r\nwin_data->enabled = true;\r\nDRM_DEBUG_KMS("dma_addr = 0x%x\n", win_data->dma_addr);\r\nif (ctx->vblank_on)\r\nschedule_work(&ctx->work);\r\n}\r\nstatic void vidi_win_disable(struct device *dev, int zpos)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nstruct vidi_win_data *win_data;\r\nint win = zpos;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win > WINDOWS_NR)\r\nreturn;\r\nwin_data = &ctx->win_data[win];\r\nwin_data->enabled = false;\r\n}\r\nstatic void vidi_finish_pageflip(struct drm_device *drm_dev, int crtc)\r\n{\r\nstruct exynos_drm_private *dev_priv = drm_dev->dev_private;\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct timeval now;\r\nunsigned long flags;\r\nbool is_checked = false;\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nlist_for_each_entry_safe(e, t, &dev_priv->pageflip_event_list,\r\nbase.link) {\r\nif (crtc != e->pipe)\r\ncontinue;\r\nis_checked = true;\r\ndo_gettimeofday(&now);\r\ne->event.sequence = 0;\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\nlist_move_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\n}\r\nif (is_checked) {\r\nif (atomic_read(&drm_dev->vblank_refcount[crtc]) > 0)\r\ndrm_vblank_put(drm_dev, crtc);\r\nif (!drm_dev->vblank_disable_allowed)\r\ndrm_vblank_off(drm_dev, crtc);\r\n}\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\n}\r\nstatic void vidi_fake_vblank_handler(struct work_struct *work)\r\n{\r\nstruct vidi_context *ctx = container_of(work, struct vidi_context,\r\nwork);\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct exynos_drm_manager *manager = subdrv->manager;\r\nif (manager->pipe < 0)\r\nreturn;\r\nusleep_range(16000, 20000);\r\ndrm_handle_vblank(subdrv->drm_dev, manager->pipe);\r\nvidi_finish_pageflip(subdrv->drm_dev, manager->pipe);\r\n}\r\nstatic int vidi_subdrv_probe(struct drm_device *drm_dev, struct device *dev)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\ndrm_dev->irq_enabled = 1;\r\ndrm_dev->vblank_disable_allowed = 1;\r\nreturn 0;\r\n}\r\nstatic void vidi_subdrv_remove(struct drm_device *drm_dev)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\n}\r\nstatic int vidi_power_on(struct vidi_context *ctx, bool enable)\r\n{\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct device *dev = subdrv->dev;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (enable != false && enable != true)\r\nreturn -EINVAL;\r\nif (enable) {\r\nctx->suspended = false;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nvidi_enable_vblank(dev);\r\nvidi_apply(dev);\r\n} else {\r\nctx->suspended = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidi_show_connection(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint rc;\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nmutex_lock(&ctx->lock);\r\nrc = sprintf(buf, "%d\n", ctx->connected);\r\nmutex_unlock(&ctx->lock);\r\nreturn rc;\r\n}\r\nstatic int vidi_store_connection(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nint ret;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nret = kstrtoint(buf, 0, &ctx->connected);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->connected > 1)\r\nreturn -EINVAL;\r\nDRM_DEBUG_KMS("requested connection.\n");\r\ndrm_helper_hpd_irq_event(ctx->subdrv.drm_dev);\r\nreturn len;\r\n}\r\nint vidi_connection_ioctl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vidi_context *ctx = NULL;\r\nstruct drm_encoder *encoder;\r\nstruct exynos_drm_manager *manager;\r\nstruct exynos_drm_display_ops *display_ops;\r\nstruct drm_exynos_vidi_connection *vidi = data;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (!vidi) {\r\nDRM_DEBUG_KMS("user data for vidi is null.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!vidi->edid) {\r\nDRM_DEBUG_KMS("edid data is null.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vidi->connection > 1) {\r\nDRM_DEBUG_KMS("connection should be 0 or 1.\n");\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(encoder, &drm_dev->mode_config.encoder_list,\r\nhead) {\r\nmanager = exynos_drm_get_manager(encoder);\r\ndisplay_ops = manager->display_ops;\r\nif (display_ops->type == EXYNOS_DISPLAY_TYPE_VIDI) {\r\nctx = get_vidi_context(manager->dev);\r\nbreak;\r\n}\r\n}\r\nif (!ctx) {\r\nDRM_DEBUG_KMS("not found virtual device type encoder.\n");\r\nreturn -EINVAL;\r\n}\r\nif (ctx->connected == vidi->connection) {\r\nDRM_DEBUG_KMS("same connection request.\n");\r\nreturn -EINVAL;\r\n}\r\nif (vidi->connection)\r\nctx->raw_edid = (struct edid *)vidi->edid;\r\nctx->connected = vidi->connection;\r\ndrm_helper_hpd_irq_event(ctx->subdrv.drm_dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit vidi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct vidi_context *ctx;\r\nstruct exynos_drm_subdrv *subdrv;\r\nint ret;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->default_win = 0;\r\nINIT_WORK(&ctx->work, vidi_fake_vblank_handler);\r\nctx->raw_edid = (struct edid *)fake_edid_info;\r\nsubdrv = &ctx->subdrv;\r\nsubdrv->dev = dev;\r\nsubdrv->manager = &vidi_manager;\r\nsubdrv->probe = vidi_subdrv_probe;\r\nsubdrv->remove = vidi_subdrv_remove;\r\nmutex_init(&ctx->lock);\r\nplatform_set_drvdata(pdev, ctx);\r\nret = device_create_file(&pdev->dev, &dev_attr_connection);\r\nif (ret < 0)\r\nDRM_INFO("failed to create connection sysfs.\n");\r\nexynos_drm_subdrv_register(subdrv);\r\nreturn 0;\r\n}\r\nstatic int __devexit vidi_remove(struct platform_device *pdev)\r\n{\r\nstruct vidi_context *ctx = platform_get_drvdata(pdev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nexynos_drm_subdrv_unregister(&ctx->subdrv);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic int vidi_suspend(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nreturn vidi_power_on(ctx, false);\r\n}\r\nstatic int vidi_resume(struct device *dev)\r\n{\r\nstruct vidi_context *ctx = get_vidi_context(dev);\r\nreturn vidi_power_on(ctx, true);\r\n}
