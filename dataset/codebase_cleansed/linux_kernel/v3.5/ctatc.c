static int ct_map_audio_buffer(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nstruct ct_vm *vm;\r\nif (!apcm->substream)\r\nreturn 0;\r\nruntime = apcm->substream->runtime;\r\nvm = atc->vm;\r\napcm->vm_block = vm->map(vm, apcm->substream, runtime->dma_bytes);\r\nif (!apcm->vm_block)\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic void ct_unmap_audio_buffer(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct ct_vm *vm;\r\nif (!apcm->vm_block)\r\nreturn;\r\nvm = atc->vm;\r\nvm->unmap(vm, apcm->vm_block);\r\napcm->vm_block = NULL;\r\n}\r\nstatic unsigned long atc_get_ptp_phys(struct ct_atc *atc, int index)\r\n{\r\nreturn atc->vm->get_ptp_phys(atc->vm, index);\r\n}\r\nstatic unsigned int convert_format(snd_pcm_format_t snd_format)\r\n{\r\nswitch (snd_format) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\nreturn SRC_SF_U8;\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nreturn SRC_SF_S16;\r\ncase SNDRV_PCM_FORMAT_S24_3LE:\r\nreturn SRC_SF_S24;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nreturn SRC_SF_S32;\r\ncase SNDRV_PCM_FORMAT_FLOAT_LE:\r\nreturn SRC_SF_F32;\r\ndefault:\r\nprintk(KERN_ERR "ctxfi: not recognized snd format is %d \n",\r\nsnd_format);\r\nreturn SRC_SF_S16;\r\n}\r\n}\r\nstatic unsigned int\r\natc_get_pitch(unsigned int input_rate, unsigned int output_rate)\r\n{\r\nunsigned int pitch;\r\nint b;\r\npitch = (input_rate / output_rate) << 24;\r\ninput_rate %= output_rate;\r\ninput_rate /= 100;\r\noutput_rate /= 100;\r\nfor (b = 31; ((b >= 0) && !(input_rate >> b)); )\r\nb--;\r\nif (b >= 0) {\r\ninput_rate <<= (31 - b);\r\ninput_rate /= output_rate;\r\nb = 24 - (31 - b);\r\nif (b >= 0)\r\ninput_rate <<= b;\r\nelse\r\ninput_rate >>= -b;\r\npitch |= input_rate;\r\n}\r\nreturn pitch;\r\n}\r\nstatic int select_rom(unsigned int pitch)\r\n{\r\nif (pitch > 0x00428f5c && pitch < 0x01b851ec) {\r\nreturn 1;\r\n} else if (pitch == 0x01d66666 || pitch == 0x01d66667) {\r\nreturn 2;\r\n} else if (pitch == 0x02000000) {\r\nreturn 3;\r\n} else if (pitch <= 0x08000000) {\r\nreturn 0;\r\n} else {\r\nreturn -ENOENT;\r\n}\r\n}\r\nstatic int atc_pcm_playback_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\r\nstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\r\nstruct src_desc desc = {0};\r\nstruct amixer_desc mix_dsc = {0};\r\nstruct src *src;\r\nstruct amixer *amixer;\r\nint err;\r\nint n_amixer = apcm->substream->runtime->channels, i = 0;\r\nint device = apcm->substream->pcm->device;\r\nunsigned int pitch;\r\natc_pcm_release_resources(atc, apcm);\r\ndesc.multi = apcm->substream->runtime->channels;\r\ndesc.msr = atc->msr;\r\ndesc.mode = MEMRD;\r\nerr = src_mgr->get_src(src_mgr, &desc, (struct src **)&apcm->src);\r\nif (err)\r\ngoto error1;\r\npitch = atc_get_pitch(apcm->substream->runtime->rate,\r\n(atc->rsr * atc->msr));\r\nsrc = apcm->src;\r\nsrc->ops->set_pitch(src, pitch);\r\nsrc->ops->set_rom(src, select_rom(pitch));\r\nsrc->ops->set_sf(src, convert_format(apcm->substream->runtime->format));\r\nsrc->ops->set_pm(src, (src->ops->next_interleave(src) != NULL));\r\nn_amixer = (n_amixer < 2) ? 2 : n_amixer;\r\napcm->amixers = kzalloc(sizeof(void *)*n_amixer, GFP_KERNEL);\r\nif (!apcm->amixers) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\nmix_dsc.msr = atc->msr;\r\nfor (i = 0, apcm->n_amixer = 0; i < n_amixer; i++) {\r\nerr = amixer_mgr->get_amixer(amixer_mgr, &mix_dsc,\r\n(struct amixer **)&apcm->amixers[i]);\r\nif (err)\r\ngoto error1;\r\napcm->n_amixer++;\r\n}\r\nerr = ct_map_audio_buffer(atc, apcm);\r\nif (err < 0)\r\ngoto error1;\r\nsrc = apcm->src;\r\nfor (i = 0; i < n_amixer; i++) {\r\namixer = apcm->amixers[i];\r\nmutex_lock(&atc->atc_mutex);\r\namixer->ops->setup(amixer, &src->rsc,\r\nINIT_VOL, atc->pcm[i+device*2]);\r\nmutex_unlock(&atc->atc_mutex);\r\nsrc = src->ops->next_interleave(src);\r\nif (!src)\r\nsrc = apcm->src;\r\n}\r\nct_timer_prepare(apcm->timer);\r\nreturn 0;\r\nerror1:\r\natc_pcm_release_resources(atc, apcm);\r\nreturn err;\r\n}\r\nstatic int\r\natc_pcm_release_resources(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\r\nstruct srcimp_mgr *srcimp_mgr = atc->rsc_mgrs[SRCIMP];\r\nstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\r\nstruct sum_mgr *sum_mgr = atc->rsc_mgrs[SUM];\r\nstruct srcimp *srcimp;\r\nint i;\r\nif (apcm->srcimps) {\r\nfor (i = 0; i < apcm->n_srcimp; i++) {\r\nsrcimp = apcm->srcimps[i];\r\nsrcimp->ops->unmap(srcimp);\r\nsrcimp_mgr->put_srcimp(srcimp_mgr, srcimp);\r\napcm->srcimps[i] = NULL;\r\n}\r\nkfree(apcm->srcimps);\r\napcm->srcimps = NULL;\r\n}\r\nif (apcm->srccs) {\r\nfor (i = 0; i < apcm->n_srcc; i++) {\r\nsrc_mgr->put_src(src_mgr, apcm->srccs[i]);\r\napcm->srccs[i] = NULL;\r\n}\r\nkfree(apcm->srccs);\r\napcm->srccs = NULL;\r\n}\r\nif (apcm->amixers) {\r\nfor (i = 0; i < apcm->n_amixer; i++) {\r\namixer_mgr->put_amixer(amixer_mgr, apcm->amixers[i]);\r\napcm->amixers[i] = NULL;\r\n}\r\nkfree(apcm->amixers);\r\napcm->amixers = NULL;\r\n}\r\nif (apcm->mono) {\r\nsum_mgr->put_sum(sum_mgr, apcm->mono);\r\napcm->mono = NULL;\r\n}\r\nif (apcm->src) {\r\nsrc_mgr->put_src(src_mgr, apcm->src);\r\napcm->src = NULL;\r\n}\r\nif (apcm->vm_block) {\r\nct_unmap_audio_buffer(atc, apcm);\r\napcm->vm_block = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atc_pcm_playback_start(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nunsigned int max_cisz;\r\nstruct src *src = apcm->src;\r\nif (apcm->started)\r\nreturn 0;\r\napcm->started = 1;\r\nmax_cisz = src->multi * src->rsc.msr;\r\nmax_cisz = 0x80 * (max_cisz < 8 ? max_cisz : 8);\r\nsrc->ops->set_sa(src, apcm->vm_block->addr);\r\nsrc->ops->set_la(src, apcm->vm_block->addr + apcm->vm_block->size);\r\nsrc->ops->set_ca(src, apcm->vm_block->addr + max_cisz);\r\nsrc->ops->set_cisz(src, max_cisz);\r\nsrc->ops->set_bm(src, 1);\r\nsrc->ops->set_state(src, SRC_STATE_INIT);\r\nsrc->ops->commit_write(src);\r\nct_timer_start(apcm->timer);\r\nreturn 0;\r\n}\r\nstatic int atc_pcm_stop(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src *src;\r\nint i;\r\nct_timer_stop(apcm->timer);\r\nsrc = apcm->src;\r\nsrc->ops->set_bm(src, 0);\r\nsrc->ops->set_state(src, SRC_STATE_OFF);\r\nsrc->ops->commit_write(src);\r\nif (apcm->srccs) {\r\nfor (i = 0; i < apcm->n_srcc; i++) {\r\nsrc = apcm->srccs[i];\r\nsrc->ops->set_bm(src, 0);\r\nsrc->ops->set_state(src, SRC_STATE_OFF);\r\nsrc->ops->commit_write(src);\r\n}\r\n}\r\napcm->started = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\natc_pcm_playback_position(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src *src = apcm->src;\r\nu32 size, max_cisz;\r\nint position;\r\nif (!src)\r\nreturn 0;\r\nposition = src->ops->get_ca(src);\r\nsize = apcm->vm_block->size;\r\nmax_cisz = src->multi * src->rsc.msr;\r\nmax_cisz = 128 * (max_cisz < 8 ? max_cisz : 8);\r\nreturn (position + size - max_cisz - apcm->vm_block->addr) % size;\r\n}\r\nstatic void setup_src_node_conf(struct ct_atc *atc, struct ct_atc_pcm *apcm,\r\nstruct src_node_conf_t *conf, int *n_srcc)\r\n{\r\nunsigned int pitch;\r\npitch = atc_get_pitch((atc->rsr * atc->msr),\r\napcm->substream->runtime->rate);\r\n*n_srcc = 0;\r\nif (1 == atc->msr) {\r\n*n_srcc = apcm->substream->runtime->channels;\r\nconf[0].pitch = pitch;\r\nconf[0].mix_msr = conf[0].imp_msr = conf[0].msr = 1;\r\nconf[0].vo = 1;\r\n} else if (2 <= atc->msr) {\r\nif (0x8000000 < pitch) {\r\nconf[0].pitch = (atc->msr << 24);\r\nconf[0].msr = conf[0].mix_msr = 1;\r\nconf[0].imp_msr = atc->msr;\r\nconf[0].vo = 0;\r\nconf[1].pitch = atc_get_pitch(atc->rsr,\r\napcm->substream->runtime->rate);\r\nconf[1].msr = conf[1].mix_msr = conf[1].imp_msr = 1;\r\nconf[1].vo = 1;\r\n*n_srcc = apcm->substream->runtime->channels * 2;\r\n} else if (0x1000000 < pitch) {\r\nconf[0].pitch = pitch;\r\nconf[0].msr = conf[0].mix_msr\r\n= conf[0].imp_msr = atc->msr;\r\nconf[0].vo = 1;\r\n*n_srcc = apcm->substream->runtime->channels;\r\n}\r\n}\r\n}\r\nstatic int\r\natc_pcm_capture_get_resources(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\r\nstruct srcimp_mgr *srcimp_mgr = atc->rsc_mgrs[SRCIMP];\r\nstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\r\nstruct sum_mgr *sum_mgr = atc->rsc_mgrs[SUM];\r\nstruct src_desc src_dsc = {0};\r\nstruct src *src;\r\nstruct srcimp_desc srcimp_dsc = {0};\r\nstruct srcimp *srcimp;\r\nstruct amixer_desc mix_dsc = {0};\r\nstruct sum_desc sum_dsc = {0};\r\nunsigned int pitch;\r\nint multi, err, i;\r\nint n_srcimp, n_amixer, n_srcc, n_sum;\r\nstruct src_node_conf_t src_node_conf[2] = {{0} };\r\natc_pcm_release_resources(atc, apcm);\r\nmulti = apcm->substream->runtime->channels;\r\npitch = atc_get_pitch((atc->rsr * atc->msr),\r\napcm->substream->runtime->rate);\r\nsetup_src_node_conf(atc, apcm, src_node_conf, &n_srcc);\r\nn_sum = (1 == multi) ? 1 : 0;\r\nn_amixer = n_sum * 2 + n_srcc;\r\nn_srcimp = n_srcc;\r\nif ((multi > 1) && (0x8000000 >= pitch)) {\r\nn_amixer += multi * atc->msr;\r\nn_srcimp += multi * atc->msr;\r\n} else {\r\nn_srcimp += multi;\r\n}\r\nif (n_srcc) {\r\napcm->srccs = kzalloc(sizeof(void *)*n_srcc, GFP_KERNEL);\r\nif (!apcm->srccs)\r\nreturn -ENOMEM;\r\n}\r\nif (n_amixer) {\r\napcm->amixers = kzalloc(sizeof(void *)*n_amixer, GFP_KERNEL);\r\nif (!apcm->amixers) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\n}\r\napcm->srcimps = kzalloc(sizeof(void *)*n_srcimp, GFP_KERNEL);\r\nif (!apcm->srcimps) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\nsrc_dsc.multi = 1;\r\nsrc_dsc.mode = ARCRW;\r\nfor (i = 0, apcm->n_srcc = 0; i < n_srcc; i++) {\r\nsrc_dsc.msr = src_node_conf[i/multi].msr;\r\nerr = src_mgr->get_src(src_mgr, &src_dsc,\r\n(struct src **)&apcm->srccs[i]);\r\nif (err)\r\ngoto error1;\r\nsrc = apcm->srccs[i];\r\npitch = src_node_conf[i/multi].pitch;\r\nsrc->ops->set_pitch(src, pitch);\r\nsrc->ops->set_rom(src, select_rom(pitch));\r\nsrc->ops->set_vo(src, src_node_conf[i/multi].vo);\r\napcm->n_srcc++;\r\n}\r\nfor (i = 0, apcm->n_amixer = 0; i < n_amixer; i++) {\r\nif (i < (n_sum*2))\r\nmix_dsc.msr = atc->msr;\r\nelse if (i < (n_sum*2+n_srcc))\r\nmix_dsc.msr = src_node_conf[(i-n_sum*2)/multi].mix_msr;\r\nelse\r\nmix_dsc.msr = 1;\r\nerr = amixer_mgr->get_amixer(amixer_mgr, &mix_dsc,\r\n(struct amixer **)&apcm->amixers[i]);\r\nif (err)\r\ngoto error1;\r\napcm->n_amixer++;\r\n}\r\nsum_dsc.msr = atc->msr;\r\nerr = sum_mgr->get_sum(sum_mgr, &sum_dsc, (struct sum **)&apcm->mono);\r\nif (err)\r\ngoto error1;\r\npitch = atc_get_pitch((atc->rsr * atc->msr),\r\napcm->substream->runtime->rate);\r\nfor (i = 0, apcm->n_srcimp = 0; i < n_srcimp; i++) {\r\nif (i < (n_srcc))\r\nsrcimp_dsc.msr = src_node_conf[i/multi].imp_msr;\r\nelse if (1 == multi)\r\nsrcimp_dsc.msr = (pitch <= 0x8000000) ? atc->msr : 1;\r\nelse\r\nsrcimp_dsc.msr = 1;\r\nerr = srcimp_mgr->get_srcimp(srcimp_mgr, &srcimp_dsc, &srcimp);\r\nif (err)\r\ngoto error1;\r\napcm->srcimps[i] = srcimp;\r\napcm->n_srcimp++;\r\n}\r\nsrc_dsc.multi = apcm->substream->runtime->channels;\r\nsrc_dsc.msr = 1;\r\nsrc_dsc.mode = MEMWR;\r\nerr = src_mgr->get_src(src_mgr, &src_dsc, (struct src **)&apcm->src);\r\nif (err)\r\ngoto error1;\r\nsrc = apcm->src;\r\nsrc->ops->set_pitch(src, pitch);\r\nerr = ct_map_audio_buffer(atc, apcm);\r\nif (err < 0)\r\ngoto error1;\r\nreturn 0;\r\nerror1:\r\natc_pcm_release_resources(atc, apcm);\r\nreturn err;\r\n}\r\nstatic int atc_pcm_capture_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src *src;\r\nstruct amixer *amixer;\r\nstruct srcimp *srcimp;\r\nstruct ct_mixer *mixer = atc->mixer;\r\nstruct sum *mono;\r\nstruct rsc *out_ports[8] = {NULL};\r\nint err, i, j, n_sum, multi;\r\nunsigned int pitch;\r\nint mix_base = 0, imp_base = 0;\r\natc_pcm_release_resources(atc, apcm);\r\nerr = atc_pcm_capture_get_resources(atc, apcm);\r\nif (err)\r\nreturn err;\r\nmixer->get_output_ports(mixer, MIX_PCMO_FRONT,\r\n&out_ports[0], &out_ports[1]);\r\nmulti = apcm->substream->runtime->channels;\r\nif (1 == multi) {\r\nmono = apcm->mono;\r\nfor (i = 0; i < 2; i++) {\r\namixer = apcm->amixers[i];\r\namixer->ops->setup(amixer, out_ports[i],\r\nMONO_SUM_SCALE, mono);\r\n}\r\nout_ports[0] = &mono->rsc;\r\nn_sum = 1;\r\nmix_base = n_sum * 2;\r\n}\r\nfor (i = 0; i < apcm->n_srcc; i++) {\r\nsrc = apcm->srccs[i];\r\nsrcimp = apcm->srcimps[imp_base+i];\r\namixer = apcm->amixers[mix_base+i];\r\nsrcimp->ops->map(srcimp, src, out_ports[i%multi]);\r\namixer->ops->setup(amixer, &src->rsc, INIT_VOL, NULL);\r\nout_ports[i%multi] = &amixer->rsc;\r\n}\r\npitch = atc_get_pitch((atc->rsr * atc->msr),\r\napcm->substream->runtime->rate);\r\nif ((multi > 1) && (pitch <= 0x8000000)) {\r\nfor (i = 0; i < multi; i++) {\r\nout_ports[i]->ops->master(out_ports[i]);\r\nfor (j = 0; j < atc->msr; j++) {\r\namixer = apcm->amixers[apcm->n_srcc+j*multi+i];\r\namixer->ops->set_input(amixer, out_ports[i]);\r\namixer->ops->set_scale(amixer, INIT_VOL);\r\namixer->ops->set_sum(amixer, NULL);\r\namixer->ops->commit_raw_write(amixer);\r\nout_ports[i]->ops->next_conj(out_ports[i]);\r\nsrcimp = apcm->srcimps[apcm->n_srcc+j*multi+i];\r\nsrcimp->ops->map(srcimp, apcm->src,\r\n&amixer->rsc);\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < multi; i++) {\r\nsrcimp = apcm->srcimps[apcm->n_srcc+i];\r\nsrcimp->ops->map(srcimp, apcm->src, out_ports[i]);\r\n}\r\n}\r\nct_timer_prepare(apcm->timer);\r\nreturn 0;\r\n}\r\nstatic int atc_pcm_capture_start(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src *src;\r\nstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\r\nint i, multi;\r\nif (apcm->started)\r\nreturn 0;\r\napcm->started = 1;\r\nmulti = apcm->substream->runtime->channels;\r\nfor (i = 0; i < apcm->n_srcc; i++) {\r\nsrc = apcm->srccs[i];\r\nsrc->ops->set_pm(src, ((i%multi) != (multi-1)));\r\nsrc_mgr->src_disable(src_mgr, src);\r\n}\r\nsrc = apcm->src;\r\nsrc->ops->set_sf(src, convert_format(apcm->substream->runtime->format));\r\nsrc->ops->set_sa(src, apcm->vm_block->addr);\r\nsrc->ops->set_la(src, apcm->vm_block->addr + apcm->vm_block->size);\r\nsrc->ops->set_ca(src, apcm->vm_block->addr);\r\nsrc_mgr->src_disable(src_mgr, src);\r\nsrc_mgr->commit_write(src_mgr);\r\nfor (i = 0; i < apcm->n_srcc; i++) {\r\nsrc = apcm->srccs[i];\r\nsrc->ops->set_state(src, SRC_STATE_RUN);\r\nsrc->ops->commit_write(src);\r\nsrc_mgr->src_enable_s(src_mgr, src);\r\n}\r\nsrc = apcm->src;\r\nsrc->ops->set_bm(src, 1);\r\nsrc->ops->set_state(src, SRC_STATE_RUN);\r\nsrc->ops->commit_write(src);\r\nsrc_mgr->src_enable_s(src_mgr, src);\r\nsrc_mgr->commit_write(src_mgr);\r\nct_timer_start(apcm->timer);\r\nreturn 0;\r\n}\r\nstatic int\r\natc_pcm_capture_position(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src *src = apcm->src;\r\nif (!src)\r\nreturn 0;\r\nreturn src->ops->get_ca(src) - apcm->vm_block->addr;\r\n}\r\nstatic int spdif_passthru_playback_get_resources(struct ct_atc *atc,\r\nstruct ct_atc_pcm *apcm)\r\n{\r\nstruct src_mgr *src_mgr = atc->rsc_mgrs[SRC];\r\nstruct amixer_mgr *amixer_mgr = atc->rsc_mgrs[AMIXER];\r\nstruct src_desc desc = {0};\r\nstruct amixer_desc mix_dsc = {0};\r\nstruct src *src;\r\nint err;\r\nint n_amixer = apcm->substream->runtime->channels, i;\r\nunsigned int pitch, rsr = atc->pll_rate;\r\natc_pcm_release_resources(atc, apcm);\r\ndesc.multi = apcm->substream->runtime->channels;\r\ndesc.msr = 1;\r\nwhile (apcm->substream->runtime->rate > (rsr * desc.msr))\r\ndesc.msr <<= 1;\r\ndesc.mode = MEMRD;\r\nerr = src_mgr->get_src(src_mgr, &desc, (struct src **)&apcm->src);\r\nif (err)\r\ngoto error1;\r\npitch = atc_get_pitch(apcm->substream->runtime->rate, (rsr * desc.msr));\r\nsrc = apcm->src;\r\nsrc->ops->set_pitch(src, pitch);\r\nsrc->ops->set_rom(src, select_rom(pitch));\r\nsrc->ops->set_sf(src, convert_format(apcm->substream->runtime->format));\r\nsrc->ops->set_pm(src, (src->ops->next_interleave(src) != NULL));\r\nsrc->ops->set_bp(src, 1);\r\nn_amixer = (n_amixer < 2) ? 2 : n_amixer;\r\napcm->amixers = kzalloc(sizeof(void *)*n_amixer, GFP_KERNEL);\r\nif (!apcm->amixers) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\nmix_dsc.msr = desc.msr;\r\nfor (i = 0, apcm->n_amixer = 0; i < n_amixer; i++) {\r\nerr = amixer_mgr->get_amixer(amixer_mgr, &mix_dsc,\r\n(struct amixer **)&apcm->amixers[i]);\r\nif (err)\r\ngoto error1;\r\napcm->n_amixer++;\r\n}\r\nerr = ct_map_audio_buffer(atc, apcm);\r\nif (err < 0)\r\ngoto error1;\r\nreturn 0;\r\nerror1:\r\natc_pcm_release_resources(atc, apcm);\r\nreturn err;\r\n}\r\nstatic int atc_pll_init(struct ct_atc *atc, int rate)\r\n{\r\nstruct hw *hw = atc->hw;\r\nint err;\r\nerr = hw->pll_init(hw, rate);\r\natc->pll_rate = err ? 0 : rate;\r\nreturn err;\r\n}\r\nstatic int\r\nspdif_passthru_playback_setup(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct dao *dao = container_of(atc->daios[SPDIFOO], struct dao, daio);\r\nunsigned int rate = apcm->substream->runtime->rate;\r\nunsigned int status;\r\nint err = 0;\r\nunsigned char iec958_con_fs;\r\nswitch (rate) {\r\ncase 48000:\r\niec958_con_fs = IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 44100:\r\niec958_con_fs = IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 32000:\r\niec958_con_fs = IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nmutex_lock(&atc->atc_mutex);\r\ndao->ops->get_spos(dao, &status);\r\nif (((status >> 24) & IEC958_AES3_CON_FS) != iec958_con_fs) {\r\nstatus &= ~(IEC958_AES3_CON_FS << 24);\r\nstatus |= (iec958_con_fs << 24);\r\ndao->ops->set_spos(dao, status);\r\ndao->ops->commit_write(dao);\r\n}\r\nif ((rate != atc->pll_rate) && (32000 != rate))\r\nerr = atc_pll_init(atc, rate);\r\nmutex_unlock(&atc->atc_mutex);\r\nreturn err;\r\n}\r\nstatic int\r\nspdif_passthru_playback_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)\r\n{\r\nstruct src *src;\r\nstruct amixer *amixer;\r\nstruct dao *dao;\r\nint err;\r\nint i;\r\natc_pcm_release_resources(atc, apcm);\r\nerr = spdif_passthru_playback_setup(atc, apcm);\r\nif (err)\r\nreturn err;\r\nerr = spdif_passthru_playback_get_resources(atc, apcm);\r\nif (err)\r\nreturn err;\r\nsrc = apcm->src;\r\nfor (i = 0; i < apcm->n_amixer; i++) {\r\namixer = apcm->amixers[i];\r\namixer->ops->setup(amixer, &src->rsc, INIT_VOL, NULL);\r\nsrc = src->ops->next_interleave(src);\r\nif (!src)\r\nsrc = apcm->src;\r\n}\r\nmutex_lock(&atc->atc_mutex);\r\ndao = container_of(atc->daios[SPDIFOO], struct dao, daio);\r\namixer = apcm->amixers[0];\r\ndao->ops->set_left_input(dao, &amixer->rsc);\r\namixer = apcm->amixers[1];\r\ndao->ops->set_right_input(dao, &amixer->rsc);\r\nmutex_unlock(&atc->atc_mutex);\r\nct_timer_prepare(apcm->timer);\r\nreturn 0;\r\n}\r\nstatic int atc_select_line_in(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nstruct ct_mixer *mixer = atc->mixer;\r\nstruct src *src;\r\nif (hw->is_adc_source_selected(hw, ADC_LINEIN))\r\nreturn 0;\r\nmixer->set_input_left(mixer, MIX_MIC_IN, NULL);\r\nmixer->set_input_right(mixer, MIX_MIC_IN, NULL);\r\nhw->select_adc_source(hw, ADC_LINEIN);\r\nsrc = atc->srcs[2];\r\nmixer->set_input_left(mixer, MIX_LINE_IN, &src->rsc);\r\nsrc = atc->srcs[3];\r\nmixer->set_input_right(mixer, MIX_LINE_IN, &src->rsc);\r\nreturn 0;\r\n}\r\nstatic int atc_select_mic_in(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nstruct ct_mixer *mixer = atc->mixer;\r\nstruct src *src;\r\nif (hw->is_adc_source_selected(hw, ADC_MICIN))\r\nreturn 0;\r\nmixer->set_input_left(mixer, MIX_LINE_IN, NULL);\r\nmixer->set_input_right(mixer, MIX_LINE_IN, NULL);\r\nhw->select_adc_source(hw, ADC_MICIN);\r\nsrc = atc->srcs[2];\r\nmixer->set_input_left(mixer, MIX_MIC_IN, &src->rsc);\r\nsrc = atc->srcs[3];\r\nmixer->set_input_right(mixer, MIX_MIC_IN, &src->rsc);\r\nreturn 0;\r\n}\r\nstatic struct capabilities atc_capabilities(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nreturn hw->capabilities(hw);\r\n}\r\nstatic int atc_output_switch_get(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nreturn hw->output_switch_get(hw);\r\n}\r\nstatic int atc_output_switch_put(struct ct_atc *atc, int position)\r\n{\r\nstruct hw *hw = atc->hw;\r\nreturn hw->output_switch_put(hw, position);\r\n}\r\nstatic int atc_mic_source_switch_get(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nreturn hw->mic_source_switch_get(hw);\r\n}\r\nstatic int atc_mic_source_switch_put(struct ct_atc *atc, int position)\r\n{\r\nstruct hw *hw = atc->hw;\r\nreturn hw->mic_source_switch_put(hw, position);\r\n}\r\nstatic int atc_select_digit_io(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nif (hw->is_adc_source_selected(hw, ADC_NONE))\r\nreturn 0;\r\nhw->select_adc_source(hw, ADC_NONE);\r\nreturn 0;\r\n}\r\nstatic int atc_daio_unmute(struct ct_atc *atc, unsigned char state, int type)\r\n{\r\nstruct daio_mgr *daio_mgr = atc->rsc_mgrs[DAIO];\r\nif (state)\r\ndaio_mgr->daio_enable(daio_mgr, atc->daios[type]);\r\nelse\r\ndaio_mgr->daio_disable(daio_mgr, atc->daios[type]);\r\ndaio_mgr->commit_write(daio_mgr);\r\nreturn 0;\r\n}\r\nstatic int\r\natc_dao_get_status(struct ct_atc *atc, unsigned int *status, int type)\r\n{\r\nstruct dao *dao = container_of(atc->daios[type], struct dao, daio);\r\nreturn dao->ops->get_spos(dao, status);\r\n}\r\nstatic int\r\natc_dao_set_status(struct ct_atc *atc, unsigned int status, int type)\r\n{\r\nstruct dao *dao = container_of(atc->daios[type], struct dao, daio);\r\ndao->ops->set_spos(dao, status);\r\ndao->ops->commit_write(dao);\r\nreturn 0;\r\n}\r\nstatic int atc_line_front_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, LINEO1);\r\n}\r\nstatic int atc_line_surround_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, LINEO2);\r\n}\r\nstatic int atc_line_clfe_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, LINEO3);\r\n}\r\nstatic int atc_line_rear_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, LINEO4);\r\n}\r\nstatic int atc_line_in_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, LINEIM);\r\n}\r\nstatic int atc_mic_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, MIC);\r\n}\r\nstatic int atc_spdif_out_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, SPDIFOO);\r\n}\r\nstatic int atc_spdif_in_unmute(struct ct_atc *atc, unsigned char state)\r\n{\r\nreturn atc_daio_unmute(atc, state, SPDIFIO);\r\n}\r\nstatic int atc_spdif_out_get_status(struct ct_atc *atc, unsigned int *status)\r\n{\r\nreturn atc_dao_get_status(atc, status, SPDIFOO);\r\n}\r\nstatic int atc_spdif_out_set_status(struct ct_atc *atc, unsigned int status)\r\n{\r\nreturn atc_dao_set_status(atc, status, SPDIFOO);\r\n}\r\nstatic int atc_spdif_out_passthru(struct ct_atc *atc, unsigned char state)\r\n{\r\nstruct dao_desc da_dsc = {0};\r\nstruct dao *dao;\r\nint err;\r\nstruct ct_mixer *mixer = atc->mixer;\r\nstruct rsc *rscs[2] = {NULL};\r\nunsigned int spos = 0;\r\nmutex_lock(&atc->atc_mutex);\r\ndao = container_of(atc->daios[SPDIFOO], struct dao, daio);\r\nda_dsc.msr = state ? 1 : atc->msr;\r\nda_dsc.passthru = state ? 1 : 0;\r\nerr = dao->ops->reinit(dao, &da_dsc);\r\nif (state) {\r\nspos = IEC958_DEFAULT_CON;\r\n} else {\r\nmixer->get_output_ports(mixer, MIX_SPDIF_OUT,\r\n&rscs[0], &rscs[1]);\r\ndao->ops->set_left_input(dao, rscs[0]);\r\ndao->ops->set_right_input(dao, rscs[1]);\r\nif (atc->pll_rate != atc->rsr)\r\nerr = atc_pll_init(atc, atc->rsr);\r\n}\r\ndao->ops->set_spos(dao, spos);\r\ndao->ops->commit_write(dao);\r\nmutex_unlock(&atc->atc_mutex);\r\nreturn err;\r\n}\r\nstatic int atc_release_resources(struct ct_atc *atc)\r\n{\r\nint i;\r\nstruct daio_mgr *daio_mgr = NULL;\r\nstruct dao *dao = NULL;\r\nstruct dai *dai = NULL;\r\nstruct daio *daio = NULL;\r\nstruct sum_mgr *sum_mgr = NULL;\r\nstruct src_mgr *src_mgr = NULL;\r\nstruct srcimp_mgr *srcimp_mgr = NULL;\r\nstruct srcimp *srcimp = NULL;\r\nstruct ct_mixer *mixer = NULL;\r\nif (atc->mixer) {\r\nmixer = atc->mixer;\r\nmixer->set_input_left(mixer, MIX_LINE_IN, NULL);\r\nmixer->set_input_right(mixer, MIX_LINE_IN, NULL);\r\nmixer->set_input_left(mixer, MIX_MIC_IN, NULL);\r\nmixer->set_input_right(mixer, MIX_MIC_IN, NULL);\r\nmixer->set_input_left(mixer, MIX_SPDIF_IN, NULL);\r\nmixer->set_input_right(mixer, MIX_SPDIF_IN, NULL);\r\n}\r\nif (atc->daios) {\r\ndaio_mgr = (struct daio_mgr *)atc->rsc_mgrs[DAIO];\r\nfor (i = 0; i < atc->n_daio; i++) {\r\ndaio = atc->daios[i];\r\nif (daio->type < LINEIM) {\r\ndao = container_of(daio, struct dao, daio);\r\ndao->ops->clear_left_input(dao);\r\ndao->ops->clear_right_input(dao);\r\n} else {\r\ndai = container_of(daio, struct dai, daio);\r\n}\r\ndaio_mgr->put_daio(daio_mgr, daio);\r\n}\r\nkfree(atc->daios);\r\natc->daios = NULL;\r\n}\r\nif (atc->pcm) {\r\nsum_mgr = atc->rsc_mgrs[SUM];\r\nfor (i = 0; i < atc->n_pcm; i++)\r\nsum_mgr->put_sum(sum_mgr, atc->pcm[i]);\r\nkfree(atc->pcm);\r\natc->pcm = NULL;\r\n}\r\nif (atc->srcs) {\r\nsrc_mgr = atc->rsc_mgrs[SRC];\r\nfor (i = 0; i < atc->n_src; i++)\r\nsrc_mgr->put_src(src_mgr, atc->srcs[i]);\r\nkfree(atc->srcs);\r\natc->srcs = NULL;\r\n}\r\nif (atc->srcimps) {\r\nsrcimp_mgr = atc->rsc_mgrs[SRCIMP];\r\nfor (i = 0; i < atc->n_srcimp; i++) {\r\nsrcimp = atc->srcimps[i];\r\nsrcimp->ops->unmap(srcimp);\r\nsrcimp_mgr->put_srcimp(srcimp_mgr, atc->srcimps[i]);\r\n}\r\nkfree(atc->srcimps);\r\natc->srcimps = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ct_atc_destroy(struct ct_atc *atc)\r\n{\r\nint i = 0;\r\nif (!atc)\r\nreturn 0;\r\nif (atc->timer) {\r\nct_timer_free(atc->timer);\r\natc->timer = NULL;\r\n}\r\natc_release_resources(atc);\r\nif (atc->mixer)\r\nct_mixer_destroy(atc->mixer);\r\nfor (i = 0; i < NUM_RSCTYP; i++) {\r\nif (rsc_mgr_funcs[i].destroy && atc->rsc_mgrs[i])\r\nrsc_mgr_funcs[i].destroy(atc->rsc_mgrs[i]);\r\n}\r\nif (atc->hw)\r\ndestroy_hw_obj((struct hw *)atc->hw);\r\nif (atc->vm) {\r\nct_vm_destroy(atc->vm);\r\natc->vm = NULL;\r\n}\r\nkfree(atc);\r\nreturn 0;\r\n}\r\nstatic int atc_dev_free(struct snd_device *dev)\r\n{\r\nstruct ct_atc *atc = dev->device_data;\r\nreturn ct_atc_destroy(atc);\r\n}\r\nstatic int __devinit atc_identify_card(struct ct_atc *atc, unsigned int ssid)\r\n{\r\nconst struct snd_pci_quirk *p;\r\nconst struct snd_pci_quirk *list;\r\nu16 vendor_id, device_id;\r\nswitch (atc->chip_type) {\r\ncase ATC20K1:\r\natc->chip_name = "20K1";\r\nlist = subsys_20k1_list;\r\nbreak;\r\ncase ATC20K2:\r\natc->chip_name = "20K2";\r\nlist = subsys_20k2_list;\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nif (ssid) {\r\nvendor_id = ssid >> 16;\r\ndevice_id = ssid & 0xffff;\r\n} else {\r\nvendor_id = atc->pci->subsystem_vendor;\r\ndevice_id = atc->pci->subsystem_device;\r\n}\r\np = snd_pci_quirk_lookup_id(vendor_id, device_id, list);\r\nif (p) {\r\nif (p->value < 0) {\r\nprintk(KERN_ERR "ctxfi: "\r\n"Device %04x:%04x is black-listed\n",\r\nvendor_id, device_id);\r\nreturn -ENOENT;\r\n}\r\natc->model = p->value;\r\n} else {\r\nif (atc->chip_type == ATC20K1)\r\natc->model = CT20K1_UNKNOWN;\r\nelse\r\natc->model = CT20K2_UNKNOWN;\r\n}\r\natc->model_name = ct_subsys_name[atc->model];\r\nsnd_printd("ctxfi: chip %s model %s (%04x:%04x) is found\n",\r\natc->chip_name, atc->model_name,\r\nvendor_id, device_id);\r\nreturn 0;\r\n}\r\nint __devinit ct_atc_create_alsa_devs(struct ct_atc *atc)\r\n{\r\nenum CTALSADEVS i;\r\nint err;\r\nalsa_dev_funcs[MIXER].public_name = atc->chip_name;\r\nfor (i = 0; i < NUM_CTALSADEVS; i++) {\r\nif (!alsa_dev_funcs[i].create)\r\ncontinue;\r\nerr = alsa_dev_funcs[i].create(atc, i,\r\nalsa_dev_funcs[i].public_name);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi: "\r\n"Creating alsa device %d failed!\n", i);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit atc_create_hw_devs(struct ct_atc *atc)\r\n{\r\nstruct hw *hw;\r\nstruct card_conf info = {0};\r\nint i, err;\r\nerr = create_hw_obj(atc->pci, atc->chip_type, atc->model, &hw);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to create hw obj!!!\n");\r\nreturn err;\r\n}\r\natc->hw = hw;\r\ninfo.rsr = atc->rsr;\r\ninfo.msr = atc->msr;\r\ninfo.vm_pgt_phys = atc_get_ptp_phys(atc, 0);\r\nerr = hw->card_init(hw, &info);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < NUM_RSCTYP; i++) {\r\nif (!rsc_mgr_funcs[i].create)\r\ncontinue;\r\nerr = rsc_mgr_funcs[i].create(atc->hw, &atc->rsc_mgrs[i]);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi: "\r\n"Failed to create rsc_mgr %d!!!\n", i);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int atc_get_resources(struct ct_atc *atc)\r\n{\r\nstruct daio_desc da_desc = {0};\r\nstruct daio_mgr *daio_mgr;\r\nstruct src_desc src_dsc = {0};\r\nstruct src_mgr *src_mgr;\r\nstruct srcimp_desc srcimp_dsc = {0};\r\nstruct srcimp_mgr *srcimp_mgr;\r\nstruct sum_desc sum_dsc = {0};\r\nstruct sum_mgr *sum_mgr;\r\nint err, i, num_srcs, num_daios;\r\nnum_daios = ((atc->model == CTSB1270) ? 8 : 7);\r\nnum_srcs = ((atc->model == CTSB1270) ? 6 : 4);\r\natc->daios = kzalloc(sizeof(void *)*num_daios, GFP_KERNEL);\r\nif (!atc->daios)\r\nreturn -ENOMEM;\r\natc->srcs = kzalloc(sizeof(void *)*num_srcs, GFP_KERNEL);\r\nif (!atc->srcs)\r\nreturn -ENOMEM;\r\natc->srcimps = kzalloc(sizeof(void *)*num_srcs, GFP_KERNEL);\r\nif (!atc->srcimps)\r\nreturn -ENOMEM;\r\natc->pcm = kzalloc(sizeof(void *)*(2*4), GFP_KERNEL);\r\nif (!atc->pcm)\r\nreturn -ENOMEM;\r\ndaio_mgr = (struct daio_mgr *)atc->rsc_mgrs[DAIO];\r\nda_desc.msr = atc->msr;\r\nfor (i = 0, atc->n_daio = 0; i < num_daios; i++) {\r\nda_desc.type = (atc->model != CTSB073X) ? i :\r\n((i == SPDIFIO) ? SPDIFI1 : i);\r\nerr = daio_mgr->get_daio(daio_mgr, &da_desc,\r\n(struct daio **)&atc->daios[i]);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi: Failed to get DAIO "\r\n"resource %d!!!\n", i);\r\nreturn err;\r\n}\r\natc->n_daio++;\r\n}\r\nsrc_mgr = atc->rsc_mgrs[SRC];\r\nsrc_dsc.multi = 1;\r\nsrc_dsc.msr = atc->msr;\r\nsrc_dsc.mode = ARCRW;\r\nfor (i = 0, atc->n_src = 0; i < num_srcs; i++) {\r\nerr = src_mgr->get_src(src_mgr, &src_dsc,\r\n(struct src **)&atc->srcs[i]);\r\nif (err)\r\nreturn err;\r\natc->n_src++;\r\n}\r\nsrcimp_mgr = atc->rsc_mgrs[SRCIMP];\r\nsrcimp_dsc.msr = 8;\r\nfor (i = 0, atc->n_srcimp = 0; i < num_srcs; i++) {\r\nerr = srcimp_mgr->get_srcimp(srcimp_mgr, &srcimp_dsc,\r\n(struct srcimp **)&atc->srcimps[i]);\r\nif (err)\r\nreturn err;\r\natc->n_srcimp++;\r\n}\r\nsum_mgr = atc->rsc_mgrs[SUM];\r\nsum_dsc.msr = atc->msr;\r\nfor (i = 0, atc->n_pcm = 0; i < (2*4); i++) {\r\nerr = sum_mgr->get_sum(sum_mgr, &sum_dsc,\r\n(struct sum **)&atc->pcm[i]);\r\nif (err)\r\nreturn err;\r\natc->n_pcm++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\natc_connect_dai(struct src_mgr *src_mgr, struct dai *dai,\r\nstruct src **srcs, struct srcimp **srcimps)\r\n{\r\nstruct rsc *rscs[2] = {NULL};\r\nstruct src *src;\r\nstruct srcimp *srcimp;\r\nint i = 0;\r\nrscs[0] = &dai->daio.rscl;\r\nrscs[1] = &dai->daio.rscr;\r\nfor (i = 0; i < 2; i++) {\r\nsrc = srcs[i];\r\nsrcimp = srcimps[i];\r\nsrcimp->ops->map(srcimp, src, rscs[i]);\r\nsrc_mgr->src_disable(src_mgr, src);\r\n}\r\nsrc_mgr->commit_write(src_mgr);\r\nsrc = srcs[0];\r\nsrc->ops->set_pm(src, 1);\r\nfor (i = 0; i < 2; i++) {\r\nsrc = srcs[i];\r\nsrc->ops->set_state(src, SRC_STATE_RUN);\r\nsrc->ops->commit_write(src);\r\nsrc_mgr->src_enable_s(src_mgr, src);\r\n}\r\ndai->ops->set_srt_srcl(dai, &(srcs[0]->rsc));\r\ndai->ops->set_srt_srcr(dai, &(srcs[1]->rsc));\r\ndai->ops->set_enb_src(dai, 1);\r\ndai->ops->set_enb_srt(dai, 1);\r\ndai->ops->commit_write(dai);\r\nsrc_mgr->commit_write(src_mgr);\r\n}\r\nstatic void atc_connect_resources(struct ct_atc *atc)\r\n{\r\nstruct dai *dai;\r\nstruct dao *dao;\r\nstruct src *src;\r\nstruct sum *sum;\r\nstruct ct_mixer *mixer;\r\nstruct rsc *rscs[2] = {NULL};\r\nint i, j;\r\nmixer = atc->mixer;\r\nfor (i = MIX_WAVE_FRONT, j = LINEO1; i <= MIX_SPDIF_OUT; i++, j++) {\r\nmixer->get_output_ports(mixer, i, &rscs[0], &rscs[1]);\r\ndao = container_of(atc->daios[j], struct dao, daio);\r\ndao->ops->set_left_input(dao, rscs[0]);\r\ndao->ops->set_right_input(dao, rscs[1]);\r\n}\r\ndai = container_of(atc->daios[LINEIM], struct dai, daio);\r\natc_connect_dai(atc->rsc_mgrs[SRC], dai,\r\n(struct src **)&atc->srcs[2],\r\n(struct srcimp **)&atc->srcimps[2]);\r\nsrc = atc->srcs[2];\r\nmixer->set_input_left(mixer, MIX_LINE_IN, &src->rsc);\r\nsrc = atc->srcs[3];\r\nmixer->set_input_right(mixer, MIX_LINE_IN, &src->rsc);\r\nif (atc->model == CTSB1270) {\r\ndai = container_of(atc->daios[MIC], struct dai, daio);\r\natc_connect_dai(atc->rsc_mgrs[SRC], dai,\r\n(struct src **)&atc->srcs[4],\r\n(struct srcimp **)&atc->srcimps[4]);\r\nsrc = atc->srcs[4];\r\nmixer->set_input_left(mixer, MIX_MIC_IN, &src->rsc);\r\nsrc = atc->srcs[5];\r\nmixer->set_input_right(mixer, MIX_MIC_IN, &src->rsc);\r\n}\r\ndai = container_of(atc->daios[SPDIFIO], struct dai, daio);\r\natc_connect_dai(atc->rsc_mgrs[SRC], dai,\r\n(struct src **)&atc->srcs[0],\r\n(struct srcimp **)&atc->srcimps[0]);\r\nsrc = atc->srcs[0];\r\nmixer->set_input_left(mixer, MIX_SPDIF_IN, &src->rsc);\r\nsrc = atc->srcs[1];\r\nmixer->set_input_right(mixer, MIX_SPDIF_IN, &src->rsc);\r\nfor (i = MIX_PCMI_FRONT, j = 0; i <= MIX_PCMI_SURROUND; i++, j += 2) {\r\nsum = atc->pcm[j];\r\nmixer->set_input_left(mixer, i, &sum->rsc);\r\nsum = atc->pcm[j+1];\r\nmixer->set_input_right(mixer, i, &sum->rsc);\r\n}\r\n}\r\nstatic int atc_suspend(struct ct_atc *atc, pm_message_t state)\r\n{\r\nint i;\r\nstruct hw *hw = atc->hw;\r\nsnd_power_change_state(atc->card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = FRONT; i < NUM_PCMS; i++) {\r\nif (!atc->pcms[i])\r\ncontinue;\r\nsnd_pcm_suspend_all(atc->pcms[i]);\r\n}\r\natc_release_resources(atc);\r\nhw->suspend(hw, state);\r\nreturn 0;\r\n}\r\nstatic int atc_hw_resume(struct ct_atc *atc)\r\n{\r\nstruct hw *hw = atc->hw;\r\nstruct card_conf info = {0};\r\ninfo.rsr = atc->rsr;\r\ninfo.msr = atc->msr;\r\ninfo.vm_pgt_phys = atc_get_ptp_phys(atc, 0);\r\nreturn hw->resume(hw, &info);\r\n}\r\nstatic int atc_resources_resume(struct ct_atc *atc)\r\n{\r\nstruct ct_mixer *mixer;\r\nint err = 0;\r\nerr = atc_get_resources(atc);\r\nif (err < 0) {\r\natc_release_resources(atc);\r\nreturn err;\r\n}\r\natc_connect_resources(atc);\r\nmixer = atc->mixer;\r\nmixer->resume(mixer);\r\nreturn 0;\r\n}\r\nstatic int atc_resume(struct ct_atc *atc)\r\n{\r\nint err = 0;\r\nerr = atc_hw_resume(atc);\r\nif (err < 0) {\r\nprintk(KERN_ERR "ctxfi: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(atc->card);\r\nreturn err;\r\n}\r\nerr = atc_resources_resume(atc);\r\nif (err < 0)\r\nreturn err;\r\nsnd_power_change_state(atc->card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nint __devinit ct_atc_create(struct snd_card *card, struct pci_dev *pci,\r\nunsigned int rsr, unsigned int msr,\r\nint chip_type, unsigned int ssid,\r\nstruct ct_atc **ratc)\r\n{\r\nstruct ct_atc *atc;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = atc_dev_free,\r\n};\r\nint err;\r\n*ratc = NULL;\r\natc = kzalloc(sizeof(*atc), GFP_KERNEL);\r\nif (!atc)\r\nreturn -ENOMEM;\r\n*atc = atc_preset;\r\natc->card = card;\r\natc->pci = pci;\r\natc->rsr = rsr;\r\natc->msr = msr;\r\natc->chip_type = chip_type;\r\nmutex_init(&atc->atc_mutex);\r\nerr = atc_identify_card(atc, ssid);\r\nif (err < 0) {\r\nprintk(KERN_ERR "ctatc: Card not recognised\n");\r\ngoto error1;\r\n}\r\nerr = ct_vm_create(&atc->vm, pci);\r\nif (err < 0)\r\ngoto error1;\r\nerr = atc_create_hw_devs(atc);\r\nif (err < 0)\r\ngoto error1;\r\nerr = ct_mixer_create(atc, (struct ct_mixer **)&atc->mixer);\r\nif (err) {\r\nprintk(KERN_ERR "ctxfi: Failed to create mixer obj!!!\n");\r\ngoto error1;\r\n}\r\nerr = atc_get_resources(atc);\r\nif (err < 0)\r\ngoto error1;\r\natc_connect_resources(atc);\r\natc->timer = ct_timer_new(atc);\r\nif (!atc->timer)\r\ngoto error1;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, atc, &ops);\r\nif (err < 0)\r\ngoto error1;\r\nsnd_card_set_dev(card, &pci->dev);\r\n*ratc = atc;\r\nreturn 0;\r\nerror1:\r\nct_atc_destroy(atc);\r\nprintk(KERN_ERR "ctxfi: Something wrong!!!\n");\r\nreturn err;\r\n}
