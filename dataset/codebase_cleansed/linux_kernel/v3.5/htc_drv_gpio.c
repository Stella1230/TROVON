static void ath_detect_bt_priority(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_hw *ah = priv->ah;\r\nif (ath9k_hw_gpio_get(ah, ah->btcoex_hw.btpriority_gpio))\r\nbtcoex->bt_priority_cnt++;\r\nif (time_after(jiffies, btcoex->bt_priority_time +\r\nmsecs_to_jiffies(ATH_BT_PRIORITY_TIME_THRESHOLD))) {\r\npriv->op_flags &= ~(OP_BT_PRIORITY_DETECTED | OP_BT_SCAN);\r\nif (btcoex->bt_priority_cnt >= ATH_BT_CNT_SCAN_THRESHOLD) {\r\nath_dbg(ath9k_hw_common(ah), BTCOEX,\r\n"BT scan detected\n");\r\npriv->op_flags |= (OP_BT_SCAN |\r\nOP_BT_PRIORITY_DETECTED);\r\n} else if (btcoex->bt_priority_cnt >= ATH_BT_CNT_THRESHOLD) {\r\nath_dbg(ath9k_hw_common(ah), BTCOEX,\r\n"BT priority traffic detected\n");\r\npriv->op_flags |= OP_BT_PRIORITY_DETECTED;\r\n}\r\nbtcoex->bt_priority_cnt = 0;\r\nbtcoex->bt_priority_time = jiffies;\r\n}\r\n}\r\nstatic void ath_btcoex_period_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\r\ncoex_period_work.work);\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nu32 timer_period;\r\nbool is_btscan;\r\nint ret;\r\nath_detect_bt_priority(priv);\r\nis_btscan = !!(priv->op_flags & OP_BT_SCAN);\r\nret = ath9k_htc_update_cap_target(priv,\r\n!!(priv->op_flags & OP_BT_PRIORITY_DETECTED));\r\nif (ret) {\r\nath_err(common, "Unable to set BTCOEX parameters\n");\r\nreturn;\r\n}\r\nath9k_hw_btcoex_bt_stomp(priv->ah, is_btscan ? ATH_BTCOEX_STOMP_ALL :\r\nbtcoex->bt_stomp_type);\r\nath9k_hw_btcoex_enable(priv->ah);\r\ntimer_period = is_btscan ? btcoex->btscan_no_stomp :\r\nbtcoex->btcoex_no_stomp;\r\nieee80211_queue_delayed_work(priv->hw, &priv->duty_cycle_work,\r\nmsecs_to_jiffies(timer_period));\r\nieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work,\r\nmsecs_to_jiffies(btcoex->btcoex_period));\r\n}\r\nstatic void ath_btcoex_duty_cycle_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\r\nduty_cycle_work.work);\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nbool is_btscan = priv->op_flags & OP_BT_SCAN;\r\nath_dbg(common, BTCOEX, "time slice work for bt and wlan\n");\r\nif (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_LOW || is_btscan)\r\nath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_NONE);\r\nelse if (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_ALL)\r\nath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_LOW);\r\nath9k_hw_btcoex_enable(priv->ah);\r\n}\r\nstatic void ath_htc_init_btcoex_work(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nbtcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD;\r\nbtcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *\r\nbtcoex->btcoex_period / 100;\r\nbtcoex->btscan_no_stomp = (100 - ATH_BTCOEX_BTSCAN_DUTY_CYCLE) *\r\nbtcoex->btcoex_period / 100;\r\nINIT_DELAYED_WORK(&priv->coex_period_work, ath_btcoex_period_work);\r\nINIT_DELAYED_WORK(&priv->duty_cycle_work, ath_btcoex_duty_cycle_work);\r\n}\r\nstatic void ath_htc_resume_btcoex_work(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_btcoex *btcoex = &priv->btcoex;\r\nstruct ath_hw *ah = priv->ah;\r\nath_dbg(ath9k_hw_common(ah), BTCOEX, "Starting btcoex work\n");\r\nbtcoex->bt_priority_cnt = 0;\r\nbtcoex->bt_priority_time = jiffies;\r\npriv->op_flags &= ~(OP_BT_PRIORITY_DETECTED | OP_BT_SCAN);\r\nieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work, 0);\r\n}\r\nstatic void ath_htc_cancel_btcoex_work(struct ath9k_htc_priv *priv)\r\n{\r\ncancel_delayed_work_sync(&priv->coex_period_work);\r\ncancel_delayed_work_sync(&priv->duty_cycle_work);\r\n}\r\nvoid ath9k_htc_start_btcoex(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nif (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE) {\r\nath9k_hw_btcoex_set_weight(ah, AR_BT_COEX_WGHT,\r\nAR_STOMP_LOW_WLAN_WGHT);\r\nath9k_hw_btcoex_enable(ah);\r\nath_htc_resume_btcoex_work(priv);\r\n}\r\n}\r\nvoid ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nif (ah->btcoex_hw.enabled &&\r\nath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) {\r\nath9k_hw_btcoex_disable(ah);\r\nif (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)\r\nath_htc_cancel_btcoex_work(priv);\r\n}\r\n}\r\nvoid ath9k_htc_init_btcoex(struct ath9k_htc_priv *priv, char *product)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nint qnum;\r\nif (product && strncmp(product, ATH_HTC_BTCOEX_PRODUCT_ID, 5) == 0) {\r\nah->btcoex_hw.scheme = ATH_BTCOEX_CFG_3WIRE;\r\n}\r\nswitch (ath9k_hw_get_btcoex_scheme(priv->ah)) {\r\ncase ATH_BTCOEX_CFG_NONE:\r\nbreak;\r\ncase ATH_BTCOEX_CFG_3WIRE:\r\npriv->ah->btcoex_hw.btactive_gpio = 7;\r\npriv->ah->btcoex_hw.btpriority_gpio = 6;\r\npriv->ah->btcoex_hw.wlanactive_gpio = 8;\r\npriv->btcoex.bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\r\nath9k_hw_btcoex_init_3wire(priv->ah);\r\nath_htc_init_btcoex_work(priv);\r\nqnum = priv->hwq_map[WME_AC_BE];\r\nath9k_hw_init_btcoex_hw(priv->ah, qnum);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nvoid ath9k_led_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(work,\r\nstruct ath9k_htc_priv,\r\nled_work);\r\nath9k_hw_set_gpio(priv->ah, priv->ah->led_pin,\r\n(priv->brightness == LED_OFF));\r\n}\r\nstatic void ath9k_led_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct ath9k_htc_priv *priv = container_of(led_cdev,\r\nstruct ath9k_htc_priv,\r\nled_cdev);\r\npriv->brightness = brightness;\r\nieee80211_queue_work(priv->hw, &priv->led_work);\r\n}\r\nvoid ath9k_deinit_leds(struct ath9k_htc_priv *priv)\r\n{\r\nif (!priv->led_registered)\r\nreturn;\r\nath9k_led_brightness(&priv->led_cdev, LED_OFF);\r\nled_classdev_unregister(&priv->led_cdev);\r\ncancel_work_sync(&priv->led_work);\r\n}\r\nvoid ath9k_init_leds(struct ath9k_htc_priv *priv)\r\n{\r\nint ret;\r\nif (AR_SREV_9287(priv->ah))\r\npriv->ah->led_pin = ATH_LED_PIN_9287;\r\nelse if (AR_SREV_9271(priv->ah))\r\npriv->ah->led_pin = ATH_LED_PIN_9271;\r\nelse if (AR_DEVID_7010(priv->ah))\r\npriv->ah->led_pin = ATH_LED_PIN_7010;\r\nelse\r\npriv->ah->led_pin = ATH_LED_PIN_DEF;\r\nath9k_hw_cfg_output(priv->ah, priv->ah->led_pin,\r\nAR_GPIO_OUTPUT_MUX_AS_OUTPUT);\r\nath9k_hw_set_gpio(priv->ah, priv->ah->led_pin, 1);\r\nsnprintf(priv->led_name, sizeof(priv->led_name),\r\n"ath9k_htc-%s", wiphy_name(priv->hw->wiphy));\r\npriv->led_cdev.name = priv->led_name;\r\npriv->led_cdev.brightness_set = ath9k_led_brightness;\r\nret = led_classdev_register(wiphy_dev(priv->hw->wiphy), &priv->led_cdev);\r\nif (ret < 0)\r\nreturn;\r\nINIT_WORK(&priv->led_work, ath9k_led_work);\r\npriv->led_registered = true;\r\nreturn;\r\n}\r\nstatic bool ath_is_rfkill_set(struct ath9k_htc_priv *priv)\r\n{\r\nbool is_blocked;\r\nath9k_htc_ps_wakeup(priv);\r\nis_blocked = ath9k_hw_gpio_get(priv->ah, priv->ah->rfkill_gpio) ==\r\npriv->ah->rfkill_polarity;\r\nath9k_htc_ps_restore(priv);\r\nreturn is_blocked;\r\n}\r\nvoid ath9k_htc_rfkill_poll_state(struct ieee80211_hw *hw)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nbool blocked = !!ath_is_rfkill_set(priv);\r\nwiphy_rfkill_set_hw_state(hw->wiphy, blocked);\r\n}\r\nvoid ath9k_start_rfkill_poll(struct ath9k_htc_priv *priv)\r\n{\r\nif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)\r\nwiphy_rfkill_start_polling(priv->hw->wiphy);\r\n}\r\nvoid ath9k_htc_radio_enable(struct ieee80211_hw *hw)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint ret;\r\nu8 cmd_rsp;\r\nif (!ah->curchan)\r\nah->curchan = ath9k_cmn_get_curchannel(hw, ah);\r\nret = ath9k_hw_reset(ah, ah->curchan, ah->caldata, false);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to reset hardware; reset status %d (freq %u MHz)\n",\r\nret, ah->curchan->channel);\r\n}\r\nath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\r\n&priv->curtxpow);\r\nWMI_CMD(WMI_START_RECV_CMDID);\r\nath9k_host_rx_init(priv);\r\nhtc_start(priv->htc);\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.flags &= ~ATH9K_HTC_OP_TX_QUEUES_STOP;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nieee80211_wake_queues(hw);\r\nWMI_CMD(WMI_ENABLE_INTR_CMDID);\r\nath9k_hw_cfg_output(ah, ah->led_pin,\r\nAR_GPIO_OUTPUT_MUX_AS_OUTPUT);\r\nath9k_hw_set_gpio(ah, ah->led_pin, 0);\r\n}\r\nvoid ath9k_htc_radio_disable(struct ieee80211_hw *hw)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint ret;\r\nu8 cmd_rsp;\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_hw_set_gpio(ah, ah->led_pin, 1);\r\nath9k_hw_cfg_gpio_input(ah, ah->led_pin);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nieee80211_stop_queues(hw);\r\nath9k_htc_tx_drain(priv);\r\nWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\r\nWMI_CMD(WMI_STOP_RECV_CMDID);\r\nath9k_wmi_event_drain(priv);\r\nath9k_hw_disable_mib_counters(ah);\r\nif (!ah->curchan)\r\nah->curchan = ath9k_cmn_get_curchannel(hw, ah);\r\nret = ath9k_hw_reset(ah, ah->curchan, ah->caldata, false);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to reset hardware; reset status %d (freq %u MHz)\n",\r\nret, ah->curchan->channel);\r\n}\r\nath9k_hw_phy_disable(ah);\r\nath9k_htc_ps_restore(priv);\r\nath9k_htc_setpower(priv, ATH9K_PM_FULL_SLEEP);\r\n}
