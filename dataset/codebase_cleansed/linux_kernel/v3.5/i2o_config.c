static int i2o_cfg_getiops(unsigned long arg)\r\n{\r\nstruct i2o_controller *c;\r\nu8 __user *user_iop_table = (void __user *)arg;\r\nu8 tmp[MAX_I2O_CONTROLLERS];\r\nint ret = 0;\r\nmemset(tmp, 0, MAX_I2O_CONTROLLERS);\r\nlist_for_each_entry(c, &i2o_controllers, list)\r\ntmp[c->unit] = 1;\r\nif (copy_to_user(user_iop_table, tmp, MAX_I2O_CONTROLLERS))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int i2o_cfg_gethrt(unsigned long arg)\r\n{\r\nstruct i2o_controller *c;\r\nstruct i2o_cmd_hrtlct __user *cmd = (struct i2o_cmd_hrtlct __user *)arg;\r\nstruct i2o_cmd_hrtlct kcmd;\r\ni2o_hrt *hrt;\r\nint len;\r\nu32 reslen;\r\nint ret = 0;\r\nif (copy_from_user(&kcmd, cmd, sizeof(struct i2o_cmd_hrtlct)))\r\nreturn -EFAULT;\r\nif (get_user(reslen, kcmd.reslen) < 0)\r\nreturn -EFAULT;\r\nif (kcmd.resbuf == NULL)\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kcmd.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nhrt = (i2o_hrt *) c->hrt.virt;\r\nlen = 8 + ((hrt->entry_len * hrt->num_entries) << 2);\r\nif (put_user(len, kcmd.reslen))\r\nret = -EFAULT;\r\nelse if (len > reslen)\r\nret = -ENOBUFS;\r\nelse if (copy_to_user(kcmd.resbuf, (void *)hrt, len))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int i2o_cfg_getlct(unsigned long arg)\r\n{\r\nstruct i2o_controller *c;\r\nstruct i2o_cmd_hrtlct __user *cmd = (struct i2o_cmd_hrtlct __user *)arg;\r\nstruct i2o_cmd_hrtlct kcmd;\r\ni2o_lct *lct;\r\nint len;\r\nint ret = 0;\r\nu32 reslen;\r\nif (copy_from_user(&kcmd, cmd, sizeof(struct i2o_cmd_hrtlct)))\r\nreturn -EFAULT;\r\nif (get_user(reslen, kcmd.reslen) < 0)\r\nreturn -EFAULT;\r\nif (kcmd.resbuf == NULL)\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kcmd.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nlct = (i2o_lct *) c->lct;\r\nlen = (unsigned int)lct->table_size << 2;\r\nif (put_user(len, kcmd.reslen))\r\nret = -EFAULT;\r\nelse if (len > reslen)\r\nret = -ENOBUFS;\r\nelse if (copy_to_user(kcmd.resbuf, lct, len))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nstatic int i2o_cfg_parms(unsigned long arg, unsigned int type)\r\n{\r\nint ret = 0;\r\nstruct i2o_controller *c;\r\nstruct i2o_device *dev;\r\nstruct i2o_cmd_psetget __user *cmd =\r\n(struct i2o_cmd_psetget __user *)arg;\r\nstruct i2o_cmd_psetget kcmd;\r\nu32 reslen;\r\nu8 *ops;\r\nu8 *res;\r\nint len = 0;\r\nu32 i2o_cmd = (type == I2OPARMGET ?\r\nI2O_CMD_UTIL_PARAMS_GET : I2O_CMD_UTIL_PARAMS_SET);\r\nif (copy_from_user(&kcmd, cmd, sizeof(struct i2o_cmd_psetget)))\r\nreturn -EFAULT;\r\nif (get_user(reslen, kcmd.reslen))\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kcmd.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\ndev = i2o_iop_find_device(c, kcmd.tid);\r\nif (!dev)\r\nreturn -ENXIO;\r\nops = memdup_user(kcmd.opbuf, kcmd.oplen);\r\nif (IS_ERR(ops))\r\nreturn PTR_ERR(ops);\r\nres = kmalloc(65536, GFP_KERNEL);\r\nif (!res) {\r\nkfree(ops);\r\nreturn -ENOMEM;\r\n}\r\nlen = i2o_parm_issue(dev, i2o_cmd, ops, kcmd.oplen, res, 65536);\r\nkfree(ops);\r\nif (len < 0) {\r\nkfree(res);\r\nreturn -EAGAIN;\r\n}\r\nif (put_user(len, kcmd.reslen))\r\nret = -EFAULT;\r\nelse if (len > reslen)\r\nret = -ENOBUFS;\r\nelse if (copy_to_user(kcmd.resbuf, res, len))\r\nret = -EFAULT;\r\nkfree(res);\r\nreturn ret;\r\n}\r\nstatic int i2o_cfg_swdl(unsigned long arg)\r\n{\r\nstruct i2o_sw_xfer kxfer;\r\nstruct i2o_sw_xfer __user *pxfer = (struct i2o_sw_xfer __user *)arg;\r\nunsigned char maxfrag = 0, curfrag = 1;\r\nstruct i2o_dma buffer;\r\nstruct i2o_message *msg;\r\nunsigned int status = 0, swlen = 0, fragsize = 8192;\r\nstruct i2o_controller *c;\r\nif (copy_from_user(&kxfer, pxfer, sizeof(struct i2o_sw_xfer)))\r\nreturn -EFAULT;\r\nif (get_user(swlen, kxfer.swlen) < 0)\r\nreturn -EFAULT;\r\nif (get_user(maxfrag, kxfer.maxfrag) < 0)\r\nreturn -EFAULT;\r\nif (get_user(curfrag, kxfer.curfrag) < 0)\r\nreturn -EFAULT;\r\nif (curfrag == maxfrag)\r\nfragsize = swlen - (maxfrag - 1) * 8192;\r\nif (!kxfer.buf || !access_ok(VERIFY_READ, kxfer.buf, fragsize))\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kxfer.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nif (i2o_dma_alloc(&c->pdev->dev, &buffer, fragsize)) {\r\ni2o_msg_nop(c, msg);\r\nreturn -ENOMEM;\r\n}\r\nif (__copy_from_user(buffer.virt, kxfer.buf, fragsize)) {\r\ni2o_msg_nop(c, msg);\r\ni2o_dma_free(&c->pdev->dev, &buffer);\r\nreturn -EFAULT;\r\n}\r\nmsg->u.head[0] = cpu_to_le32(NINE_WORD_MSG_SIZE | SGL_OFFSET_7);\r\nmsg->u.head[1] =\r\ncpu_to_le32(I2O_CMD_SW_DOWNLOAD << 24 | HOST_TID << 12 |\r\nADAPTER_TID);\r\nmsg->u.head[2] = cpu_to_le32(i2o_config_driver.context);\r\nmsg->u.head[3] = cpu_to_le32(0);\r\nmsg->body[0] =\r\ncpu_to_le32((((u32) kxfer.flags) << 24) | (((u32) kxfer.\r\nsw_type) << 16) |\r\n(((u32) maxfrag) << 8) | (((u32) curfrag)));\r\nmsg->body[1] = cpu_to_le32(swlen);\r\nmsg->body[2] = cpu_to_le32(kxfer.sw_id);\r\nmsg->body[3] = cpu_to_le32(0xD0000000 | fragsize);\r\nmsg->body[4] = cpu_to_le32(buffer.phys);\r\nosm_debug("swdl frag %d/%d (size %d)\n", curfrag, maxfrag, fragsize);\r\nstatus = i2o_msg_post_wait_mem(c, msg, 60, &buffer);\r\nif (status != -ETIMEDOUT)\r\ni2o_dma_free(&c->pdev->dev, &buffer);\r\nif (status != I2O_POST_WAIT_OK) {\r\nosm_info("swdl failed, DetailedStatus = %d\n", status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_cfg_swul(unsigned long arg)\r\n{\r\nstruct i2o_sw_xfer kxfer;\r\nstruct i2o_sw_xfer __user *pxfer = (struct i2o_sw_xfer __user *)arg;\r\nunsigned char maxfrag = 0, curfrag = 1;\r\nstruct i2o_dma buffer;\r\nstruct i2o_message *msg;\r\nunsigned int status = 0, swlen = 0, fragsize = 8192;\r\nstruct i2o_controller *c;\r\nint ret = 0;\r\nif (copy_from_user(&kxfer, pxfer, sizeof(struct i2o_sw_xfer)))\r\nreturn -EFAULT;\r\nif (get_user(swlen, kxfer.swlen) < 0)\r\nreturn -EFAULT;\r\nif (get_user(maxfrag, kxfer.maxfrag) < 0)\r\nreturn -EFAULT;\r\nif (get_user(curfrag, kxfer.curfrag) < 0)\r\nreturn -EFAULT;\r\nif (curfrag == maxfrag)\r\nfragsize = swlen - (maxfrag - 1) * 8192;\r\nif (!kxfer.buf)\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kxfer.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nif (i2o_dma_alloc(&c->pdev->dev, &buffer, fragsize)) {\r\ni2o_msg_nop(c, msg);\r\nreturn -ENOMEM;\r\n}\r\nmsg->u.head[0] = cpu_to_le32(NINE_WORD_MSG_SIZE | SGL_OFFSET_7);\r\nmsg->u.head[1] =\r\ncpu_to_le32(I2O_CMD_SW_UPLOAD << 24 | HOST_TID << 12 | ADAPTER_TID);\r\nmsg->u.head[2] = cpu_to_le32(i2o_config_driver.context);\r\nmsg->u.head[3] = cpu_to_le32(0);\r\nmsg->body[0] =\r\ncpu_to_le32((u32) kxfer.flags << 24 | (u32) kxfer.\r\nsw_type << 16 | (u32) maxfrag << 8 | (u32) curfrag);\r\nmsg->body[1] = cpu_to_le32(swlen);\r\nmsg->body[2] = cpu_to_le32(kxfer.sw_id);\r\nmsg->body[3] = cpu_to_le32(0xD0000000 | fragsize);\r\nmsg->body[4] = cpu_to_le32(buffer.phys);\r\nosm_debug("swul frag %d/%d (size %d)\n", curfrag, maxfrag, fragsize);\r\nstatus = i2o_msg_post_wait_mem(c, msg, 60, &buffer);\r\nif (status != I2O_POST_WAIT_OK) {\r\nif (status != -ETIMEDOUT)\r\ni2o_dma_free(&c->pdev->dev, &buffer);\r\nosm_info("swul failed, DetailedStatus = %d\n", status);\r\nreturn status;\r\n}\r\nif (copy_to_user(kxfer.buf, buffer.virt, fragsize))\r\nret = -EFAULT;\r\ni2o_dma_free(&c->pdev->dev, &buffer);\r\nreturn ret;\r\n}\r\nstatic int i2o_cfg_swdel(unsigned long arg)\r\n{\r\nstruct i2o_controller *c;\r\nstruct i2o_sw_xfer kxfer;\r\nstruct i2o_sw_xfer __user *pxfer = (struct i2o_sw_xfer __user *)arg;\r\nstruct i2o_message *msg;\r\nunsigned int swlen;\r\nint token;\r\nif (copy_from_user(&kxfer, pxfer, sizeof(struct i2o_sw_xfer)))\r\nreturn -EFAULT;\r\nif (get_user(swlen, kxfer.swlen) < 0)\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kxfer.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nmsg->u.head[0] = cpu_to_le32(SEVEN_WORD_MSG_SIZE | SGL_OFFSET_0);\r\nmsg->u.head[1] =\r\ncpu_to_le32(I2O_CMD_SW_REMOVE << 24 | HOST_TID << 12 | ADAPTER_TID);\r\nmsg->u.head[2] = cpu_to_le32(i2o_config_driver.context);\r\nmsg->u.head[3] = cpu_to_le32(0);\r\nmsg->body[0] =\r\ncpu_to_le32((u32) kxfer.flags << 24 | (u32) kxfer.sw_type << 16);\r\nmsg->body[1] = cpu_to_le32(swlen);\r\nmsg->body[2] = cpu_to_le32(kxfer.sw_id);\r\ntoken = i2o_msg_post_wait(c, msg, 10);\r\nif (token != I2O_POST_WAIT_OK) {\r\nosm_info("swdel failed, DetailedStatus = %d\n", token);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_cfg_validate(unsigned long arg)\r\n{\r\nint token;\r\nint iop = (int)arg;\r\nstruct i2o_message *msg;\r\nstruct i2o_controller *c;\r\nc = i2o_find_iop(iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nmsg->u.head[0] = cpu_to_le32(FOUR_WORD_MSG_SIZE | SGL_OFFSET_0);\r\nmsg->u.head[1] =\r\ncpu_to_le32(I2O_CMD_CONFIG_VALIDATE << 24 | HOST_TID << 12 | iop);\r\nmsg->u.head[2] = cpu_to_le32(i2o_config_driver.context);\r\nmsg->u.head[3] = cpu_to_le32(0);\r\ntoken = i2o_msg_post_wait(c, msg, 10);\r\nif (token != I2O_POST_WAIT_OK) {\r\nosm_info("Can't validate configuration, ErrorStatus = %d\n",\r\ntoken);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2o_cfg_evt_reg(unsigned long arg, struct file *fp)\r\n{\r\nstruct i2o_message *msg;\r\nstruct i2o_evt_id __user *pdesc = (struct i2o_evt_id __user *)arg;\r\nstruct i2o_evt_id kdesc;\r\nstruct i2o_controller *c;\r\nstruct i2o_device *d;\r\nif (copy_from_user(&kdesc, pdesc, sizeof(struct i2o_evt_id)))\r\nreturn -EFAULT;\r\nc = i2o_find_iop(kdesc.iop);\r\nif (!c)\r\nreturn -ENXIO;\r\nd = i2o_iop_find_device(c, kdesc.tid);\r\nif (!d)\r\nreturn -ENODEV;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nmsg->u.head[0] = cpu_to_le32(FOUR_WORD_MSG_SIZE | SGL_OFFSET_0);\r\nmsg->u.head[1] =\r\ncpu_to_le32(I2O_CMD_UTIL_EVT_REGISTER << 24 | HOST_TID << 12 |\r\nkdesc.tid);\r\nmsg->u.head[2] = cpu_to_le32(i2o_config_driver.context);\r\nmsg->u.head[3] = cpu_to_le32(i2o_cntxt_list_add(c, fp->private_data));\r\nmsg->body[0] = cpu_to_le32(kdesc.evt_mask);\r\ni2o_msg_post(c, msg);\r\nreturn 0;\r\n}\r\nstatic int i2o_cfg_evt_get(unsigned long arg, struct file *fp)\r\n{\r\nstruct i2o_cfg_info *p = NULL;\r\nstruct i2o_evt_get __user *uget = (struct i2o_evt_get __user *)arg;\r\nstruct i2o_evt_get kget;\r\nunsigned long flags;\r\nfor (p = open_files; p; p = p->next)\r\nif (p->q_id == (ulong) fp->private_data)\r\nbreak;\r\nif (!p->q_len)\r\nreturn -ENOENT;\r\nmemcpy(&kget.info, &p->event_q[p->q_out], sizeof(struct i2o_evt_info));\r\nMODINC(p->q_out, I2O_EVT_Q_LEN);\r\nspin_lock_irqsave(&i2o_config_lock, flags);\r\np->q_len--;\r\nkget.pending = p->q_len;\r\nkget.lost = p->q_lost;\r\nspin_unlock_irqrestore(&i2o_config_lock, flags);\r\nif (copy_to_user(uget, &kget, sizeof(struct i2o_evt_get)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int i2o_cfg_passthru32(struct file *file, unsigned cmnd,\r\nunsigned long arg)\r\n{\r\nstruct i2o_cmd_passthru32 __user *cmd;\r\nstruct i2o_controller *c;\r\nu32 __user *user_msg;\r\nu32 *reply = NULL;\r\nu32 __user *user_reply = NULL;\r\nu32 size = 0;\r\nu32 reply_size = 0;\r\nu32 rcode = 0;\r\nstruct i2o_dma sg_list[SG_TABLESIZE];\r\nu32 sg_offset = 0;\r\nu32 sg_count = 0;\r\nu32 i = 0;\r\nu32 sg_index = 0;\r\ni2o_status_block *sb;\r\nstruct i2o_message *msg;\r\nunsigned int iop;\r\ncmd = (struct i2o_cmd_passthru32 __user *)arg;\r\nif (get_user(iop, &cmd->iop) || get_user(i, &cmd->msg))\r\nreturn -EFAULT;\r\nuser_msg = compat_ptr(i);\r\nc = i2o_find_iop(iop);\r\nif (!c) {\r\nosm_debug("controller %d not found\n", iop);\r\nreturn -ENXIO;\r\n}\r\nsb = c->status_block.virt;\r\nif (get_user(size, &user_msg[0])) {\r\nosm_warn("unable to get size!\n");\r\nreturn -EFAULT;\r\n}\r\nsize = size >> 16;\r\nif (size > sb->inbound_frame_size) {\r\nosm_warn("size of message > inbound_frame_size");\r\nreturn -EFAULT;\r\n}\r\nuser_reply = &user_msg[size];\r\nsize <<= 2;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nrcode = -EFAULT;\r\nif (copy_from_user(msg, user_msg, size)) {\r\nosm_warn("unable to copy user message\n");\r\ngoto out;\r\n}\r\ni2o_dump_message(msg);\r\nif (get_user(reply_size, &user_reply[0]) < 0)\r\ngoto out;\r\nreply_size >>= 16;\r\nreply_size <<= 2;\r\nrcode = -ENOMEM;\r\nreply = kzalloc(reply_size, GFP_KERNEL);\r\nif (!reply) {\r\nprintk(KERN_WARNING "%s: Could not allocate reply buffer\n",\r\nc->name);\r\ngoto out;\r\n}\r\nsg_offset = (msg->u.head[0] >> 4) & 0x0f;\r\nmemset(sg_list, 0, sizeof(sg_list[0]) * SG_TABLESIZE);\r\nif (sg_offset) {\r\nstruct sg_simple_element *sg;\r\nif (sg_offset * 4 >= size) {\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nsg = (struct sg_simple_element *)((&msg->u.head[0]) +\r\nsg_offset);\r\nsg_count =\r\n(size - sg_offset * 4) / sizeof(struct sg_simple_element);\r\nif (sg_count > SG_TABLESIZE) {\r\nprintk(KERN_DEBUG "%s:IOCTL SG List too large (%u)\n",\r\nc->name, sg_count);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nfor (i = 0; i < sg_count; i++) {\r\nint sg_size;\r\nstruct i2o_dma *p;\r\nif (!(sg[i].flag_count & 0x10000000\r\n)) {\r\nprintk(KERN_DEBUG\r\n"%s:Bad SG element %d - not simple (%x)\n",\r\nc->name, i, sg[i].flag_count);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nsg_size = sg[i].flag_count & 0xffffff;\r\np = &(sg_list[sg_index]);\r\nif (i2o_dma_alloc(&c->pdev->dev, p, sg_size)) {\r\nprintk(KERN_DEBUG\r\n"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nc->name, sg_size, i, sg_count);\r\nrcode = -ENOMEM;\r\ngoto sg_list_cleanup;\r\n}\r\nsg_index++;\r\nif (sg[i].\r\nflag_count & 0x04000000 ) {\r\nif (copy_from_user\r\n(p->virt,\r\n(void __user *)(unsigned long)sg[i].\r\naddr_bus, sg_size)) {\r\nprintk(KERN_DEBUG\r\n"%s: Could not copy SG buf %d FROM user\n",\r\nc->name, i);\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\n}\r\nsg[i].addr_bus = (u32) p->phys;\r\n}\r\n}\r\nrcode = i2o_msg_post_wait(c, msg, 60);\r\nmsg = NULL;\r\nif (rcode) {\r\nreply[4] = ((u32) rcode) << 24;\r\ngoto sg_list_cleanup;\r\n}\r\nif (sg_offset) {\r\nu32 rmsg[I2O_OUTBOUND_MSG_FRAME_SIZE];\r\nu32 j;\r\nstruct sg_simple_element *sg;\r\nint sg_size;\r\nmemset(&rmsg, 0, I2O_OUTBOUND_MSG_FRAME_SIZE * 4);\r\nif (get_user(size, &user_msg[0])) {\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\nsize = size >> 16;\r\nsize *= 4;\r\nif (copy_from_user(rmsg, user_msg, size)) {\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\nsg_count =\r\n(size - sg_offset * 4) / sizeof(struct sg_simple_element);\r\nsg = (struct sg_simple_element *)(rmsg + sg_offset);\r\nfor (j = 0; j < sg_count; j++) {\r\nif (!\r\n(sg[j].\r\nflag_count & 0x4000000 )) {\r\nsg_size = sg[j].flag_count & 0xffffff;\r\nif (copy_to_user\r\n((void __user *)(u64) sg[j].addr_bus,\r\nsg_list[j].virt, sg_size)) {\r\nprintk(KERN_WARNING\r\n"%s: Could not copy %p TO user %x\n",\r\nc->name, sg_list[j].virt,\r\nsg[j].addr_bus);\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\n}\r\n}\r\n}\r\nsg_list_cleanup:\r\nif (reply_size) {\r\nif (copy_from_user(reply + 2, user_msg + 2, sizeof(u32) * 2)) {\r\nprintk(KERN_WARNING\r\n"%s: Could not copy message context FROM user\n",\r\nc->name);\r\nrcode = -EFAULT;\r\n}\r\nif (copy_to_user(user_reply, reply, reply_size)) {\r\nprintk(KERN_WARNING\r\n"%s: Could not copy reply TO user\n", c->name);\r\nrcode = -EFAULT;\r\n}\r\n}\r\nfor (i = 0; i < sg_index; i++)\r\ni2o_dma_free(&c->pdev->dev, &sg_list[i]);\r\ncleanup:\r\nkfree(reply);\r\nout:\r\nif (msg)\r\ni2o_msg_nop(c, msg);\r\nreturn rcode;\r\n}\r\nstatic long i2o_cfg_compat_ioctl(struct file *file, unsigned cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&i2o_cfg_mutex);\r\nswitch (cmd) {\r\ncase I2OGETIOPS:\r\nret = i2o_cfg_ioctl(file, cmd, arg);\r\nbreak;\r\ncase I2OPASSTHRU32:\r\nret = i2o_cfg_passthru32(file, cmd, arg);\r\nbreak;\r\ndefault:\r\nret = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nmutex_unlock(&i2o_cfg_mutex);\r\nreturn ret;\r\n}\r\nstatic int i2o_cfg_passthru(unsigned long arg)\r\n{\r\nstruct i2o_cmd_passthru __user *cmd =\r\n(struct i2o_cmd_passthru __user *)arg;\r\nstruct i2o_controller *c;\r\nu32 __user *user_msg;\r\nu32 *reply = NULL;\r\nu32 __user *user_reply = NULL;\r\nu32 size = 0;\r\nu32 reply_size = 0;\r\nu32 rcode = 0;\r\nstruct i2o_dma sg_list[SG_TABLESIZE];\r\nu32 sg_offset = 0;\r\nu32 sg_count = 0;\r\nint sg_index = 0;\r\nu32 i = 0;\r\ni2o_status_block *sb;\r\nstruct i2o_message *msg;\r\nunsigned int iop;\r\nif (get_user(iop, &cmd->iop) || get_user(user_msg, &cmd->msg))\r\nreturn -EFAULT;\r\nc = i2o_find_iop(iop);\r\nif (!c) {\r\nosm_warn("controller %d not found\n", iop);\r\nreturn -ENXIO;\r\n}\r\nsb = c->status_block.virt;\r\nif (get_user(size, &user_msg[0]))\r\nreturn -EFAULT;\r\nsize = size >> 16;\r\nif (size > sb->inbound_frame_size) {\r\nosm_warn("size of message > inbound_frame_size");\r\nreturn -EFAULT;\r\n}\r\nuser_reply = &user_msg[size];\r\nsize <<= 2;\r\nmsg = i2o_msg_get_wait(c, I2O_TIMEOUT_MESSAGE_GET);\r\nif (IS_ERR(msg))\r\nreturn PTR_ERR(msg);\r\nrcode = -EFAULT;\r\nif (copy_from_user(msg, user_msg, size))\r\ngoto out;\r\nif (get_user(reply_size, &user_reply[0]) < 0)\r\ngoto out;\r\nreply_size >>= 16;\r\nreply_size <<= 2;\r\nreply = kzalloc(reply_size, GFP_KERNEL);\r\nif (!reply) {\r\nprintk(KERN_WARNING "%s: Could not allocate reply buffer\n",\r\nc->name);\r\nrcode = -ENOMEM;\r\ngoto out;\r\n}\r\nsg_offset = (msg->u.head[0] >> 4) & 0x0f;\r\nmemset(sg_list, 0, sizeof(sg_list[0]) * SG_TABLESIZE);\r\nif (sg_offset) {\r\nstruct sg_simple_element *sg;\r\nstruct i2o_dma *p;\r\nif (sg_offset * 4 >= size) {\r\nrcode = -EFAULT;\r\ngoto cleanup;\r\n}\r\nsg = (struct sg_simple_element *)((&msg->u.head[0]) +\r\nsg_offset);\r\nsg_count =\r\n(size - sg_offset * 4) / sizeof(struct sg_simple_element);\r\nif (sg_count > SG_TABLESIZE) {\r\nprintk(KERN_DEBUG "%s:IOCTL SG List too large (%u)\n",\r\nc->name, sg_count);\r\nrcode = -EINVAL;\r\ngoto cleanup;\r\n}\r\nfor (i = 0; i < sg_count; i++) {\r\nint sg_size;\r\nif (!(sg[i].flag_count & 0x10000000\r\n)) {\r\nprintk(KERN_DEBUG\r\n"%s:Bad SG element %d - not simple (%x)\n",\r\nc->name, i, sg[i].flag_count);\r\nrcode = -EINVAL;\r\ngoto sg_list_cleanup;\r\n}\r\nsg_size = sg[i].flag_count & 0xffffff;\r\np = &(sg_list[sg_index]);\r\nif (i2o_dma_alloc(&c->pdev->dev, p, sg_size)) {\r\nprintk(KERN_DEBUG\r\n"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",\r\nc->name, sg_size, i, sg_count);\r\nrcode = -ENOMEM;\r\ngoto sg_list_cleanup;\r\n}\r\nsg_index++;\r\nif (sg[i].\r\nflag_count & 0x04000000 ) {\r\nif (copy_from_user\r\n(p->virt, (void __user *)sg[i].addr_bus,\r\nsg_size)) {\r\nprintk(KERN_DEBUG\r\n"%s: Could not copy SG buf %d FROM user\n",\r\nc->name, i);\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\n}\r\nsg[i].addr_bus = p->phys;\r\n}\r\n}\r\nrcode = i2o_msg_post_wait(c, msg, 60);\r\nmsg = NULL;\r\nif (rcode) {\r\nreply[4] = ((u32) rcode) << 24;\r\ngoto sg_list_cleanup;\r\n}\r\nif (sg_offset) {\r\nu32 rmsg[I2O_OUTBOUND_MSG_FRAME_SIZE];\r\nu32 j;\r\nstruct sg_simple_element *sg;\r\nint sg_size;\r\nmemset(&rmsg, 0, I2O_OUTBOUND_MSG_FRAME_SIZE * 4);\r\nif (get_user(size, &user_msg[0])) {\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\nsize = size >> 16;\r\nsize *= 4;\r\nif (copy_from_user(rmsg, user_msg, size)) {\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\nsg_count =\r\n(size - sg_offset * 4) / sizeof(struct sg_simple_element);\r\nsg = (struct sg_simple_element *)(rmsg + sg_offset);\r\nfor (j = 0; j < sg_count; j++) {\r\nif (!\r\n(sg[j].\r\nflag_count & 0x4000000 )) {\r\nsg_size = sg[j].flag_count & 0xffffff;\r\nif (copy_to_user\r\n((void __user *)sg[j].addr_bus, sg_list[j].virt,\r\nsg_size)) {\r\nprintk(KERN_WARNING\r\n"%s: Could not copy %p TO user %x\n",\r\nc->name, sg_list[j].virt,\r\nsg[j].addr_bus);\r\nrcode = -EFAULT;\r\ngoto sg_list_cleanup;\r\n}\r\n}\r\n}\r\n}\r\nsg_list_cleanup:\r\nif (reply_size) {\r\nif (copy_from_user(reply + 2, user_msg + 2, sizeof(u32) * 2)) {\r\nprintk(KERN_WARNING\r\n"%s: Could not copy message context FROM user\n",\r\nc->name);\r\nrcode = -EFAULT;\r\n}\r\nif (copy_to_user(user_reply, reply, reply_size)) {\r\nprintk(KERN_WARNING\r\n"%s: Could not copy reply TO user\n", c->name);\r\nrcode = -EFAULT;\r\n}\r\n}\r\nfor (i = 0; i < sg_index; i++)\r\ni2o_dma_free(&c->pdev->dev, &sg_list[i]);\r\ncleanup:\r\nkfree(reply);\r\nout:\r\nif (msg)\r\ni2o_msg_nop(c, msg);\r\nreturn rcode;\r\n}\r\nstatic long i2o_cfg_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&i2o_cfg_mutex);\r\nswitch (cmd) {\r\ncase I2OGETIOPS:\r\nret = i2o_cfg_getiops(arg);\r\nbreak;\r\ncase I2OHRTGET:\r\nret = i2o_cfg_gethrt(arg);\r\nbreak;\r\ncase I2OLCTGET:\r\nret = i2o_cfg_getlct(arg);\r\nbreak;\r\ncase I2OPARMSET:\r\nret = i2o_cfg_parms(arg, I2OPARMSET);\r\nbreak;\r\ncase I2OPARMGET:\r\nret = i2o_cfg_parms(arg, I2OPARMGET);\r\nbreak;\r\ncase I2OSWDL:\r\nret = i2o_cfg_swdl(arg);\r\nbreak;\r\ncase I2OSWUL:\r\nret = i2o_cfg_swul(arg);\r\nbreak;\r\ncase I2OSWDEL:\r\nret = i2o_cfg_swdel(arg);\r\nbreak;\r\ncase I2OVALIDATE:\r\nret = i2o_cfg_validate(arg);\r\nbreak;\r\ncase I2OEVTREG:\r\nret = i2o_cfg_evt_reg(arg, fp);\r\nbreak;\r\ncase I2OEVTGET:\r\nret = i2o_cfg_evt_get(arg, fp);\r\nbreak;\r\n#ifdef CONFIG_I2O_EXT_ADAPTEC\r\ncase I2OPASSTHRU:\r\nret = i2o_cfg_passthru(arg);\r\nbreak;\r\n#endif\r\ndefault:\r\nosm_debug("unknown ioctl called!\n");\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&i2o_cfg_mutex);\r\nreturn ret;\r\n}\r\nstatic int cfg_open(struct inode *inode, struct file *file)\r\n{\r\nstruct i2o_cfg_info *tmp = kmalloc(sizeof(struct i2o_cfg_info),\r\nGFP_KERNEL);\r\nunsigned long flags;\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nmutex_lock(&i2o_cfg_mutex);\r\nfile->private_data = (void *)(i2o_cfg_info_id++);\r\ntmp->fp = file;\r\ntmp->fasync = NULL;\r\ntmp->q_id = (ulong) file->private_data;\r\ntmp->q_len = 0;\r\ntmp->q_in = 0;\r\ntmp->q_out = 0;\r\ntmp->q_lost = 0;\r\ntmp->next = open_files;\r\nspin_lock_irqsave(&i2o_config_lock, flags);\r\nopen_files = tmp;\r\nspin_unlock_irqrestore(&i2o_config_lock, flags);\r\nmutex_unlock(&i2o_cfg_mutex);\r\nreturn 0;\r\n}\r\nstatic int cfg_fasync(int fd, struct file *fp, int on)\r\n{\r\nulong id = (ulong) fp->private_data;\r\nstruct i2o_cfg_info *p;\r\nint ret = -EBADF;\r\nmutex_lock(&i2o_cfg_mutex);\r\nfor (p = open_files; p; p = p->next)\r\nif (p->q_id == id)\r\nbreak;\r\nif (p)\r\nret = fasync_helper(fd, fp, on, &p->fasync);\r\nmutex_unlock(&i2o_cfg_mutex);\r\nreturn ret;\r\n}\r\nstatic int cfg_release(struct inode *inode, struct file *file)\r\n{\r\nulong id = (ulong) file->private_data;\r\nstruct i2o_cfg_info *p, **q;\r\nunsigned long flags;\r\nmutex_lock(&i2o_cfg_mutex);\r\nspin_lock_irqsave(&i2o_config_lock, flags);\r\nfor (q = &open_files; (p = *q) != NULL; q = &p->next) {\r\nif (p->q_id == id) {\r\n*q = p->next;\r\nkfree(p);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&i2o_config_lock, flags);\r\nmutex_unlock(&i2o_cfg_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init i2o_config_old_init(void)\r\n{\r\nspin_lock_init(&i2o_config_lock);\r\nif (misc_register(&i2o_miscdev) < 0) {\r\nosm_err("can't register device.\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void i2o_config_old_exit(void)\r\n{\r\nmisc_deregister(&i2o_miscdev);\r\n}
