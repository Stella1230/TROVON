static int prog_dmabuf_adc(struct cs4297a_state *s)\r\n{\r\ns->dma_adc.ready = 1;\r\nreturn 0;\r\n}\r\nstatic int prog_dmabuf_dac(struct cs4297a_state *s)\r\n{\r\ns->dma_dac.ready = 1;\r\nreturn 0;\r\n}\r\nstatic void clear_advance(void *buf, unsigned bsize, unsigned bptr,\r\nunsigned len, unsigned char c)\r\n{\r\nif (bptr + len > bsize) {\r\nunsigned x = bsize - bptr;\r\nmemset(((char *) buf) + bptr, c, x);\r\nbptr = 0;\r\nlen -= x;\r\n}\r\nCS_DBGOUT(CS_WAVE_WRITE, 4, printk(KERN_INFO\r\n"cs4297a: clear_advance(): memset %d at 0x%.8x for %d size \n",\r\n(unsigned)c, (unsigned)((char *) buf) + bptr, len));\r\nmemset(((char *) buf) + bptr, c, len);\r\n}\r\nstatic void cs_printioctl(unsigned int x)\r\n{\r\nunsigned int i;\r\nunsigned char vidx;\r\nstatic const unsigned char mixtable1[SOUND_MIXER_NRDEVICES] = {\r\n[SOUND_MIXER_PCM] = 1,\r\n[SOUND_MIXER_LINE1] = 2,\r\n[SOUND_MIXER_CD] = 3,\r\n[SOUND_MIXER_LINE] = 4,\r\n[SOUND_MIXER_SYNTH] = 5,\r\n[SOUND_MIXER_MIC] = 6,\r\n[SOUND_MIXER_SPEAKER] = 7,\r\n[SOUND_MIXER_RECLEV] = 8,\r\n[SOUND_MIXER_VOLUME] = 9\r\n};\r\nswitch (x) {\r\ncase SOUND_MIXER_CS_GETDBGMASK:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_CS_GETDBGMASK:\n"));\r\nbreak;\r\ncase SOUND_MIXER_CS_GETDBGLEVEL:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_CS_GETDBGLEVEL:\n"));\r\nbreak;\r\ncase SOUND_MIXER_CS_SETDBGMASK:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_CS_SETDBGMASK:\n"));\r\nbreak;\r\ncase SOUND_MIXER_CS_SETDBGLEVEL:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_CS_SETDBGLEVEL:\n"));\r\nbreak;\r\ncase OSS_GETVERSION:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("OSS_GETVERSION:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SYNC:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SYNC:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SETDUPLEX:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETDUPLEX:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETCAPS:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETCAPS:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_RESET:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_RESET:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SPEED:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SPEED:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_STEREO:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_STEREO:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_CHANNELS:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_CHANNELS:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETFMTS:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETFMTS:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SETFMT:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETFMT:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_POST:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_POST:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETTRIGGER:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETTRIGGER:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SETTRIGGER:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETTRIGGER:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETOSPACE:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETOSPACE:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETISPACE:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETISPACE:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_NONBLOCK:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_NONBLOCK:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETODELAY:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETODELAY:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETIPTR:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETIPTR:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETOPTR:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETOPTR:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_GETBLKSIZE:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SNDCTL_DSP_SETFRAGMENT:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SUBDIVIDE:\n"));\r\nbreak;\r\ncase SOUND_PCM_READ_RATE:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_PCM_READ_RATE:\n"));\r\nbreak;\r\ncase SOUND_PCM_READ_CHANNELS:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_PCM_READ_CHANNELS:\n"));\r\nbreak;\r\ncase SOUND_PCM_READ_BITS:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_PCM_READ_BITS:\n"));\r\nbreak;\r\ncase SOUND_PCM_WRITE_FILTER:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_PCM_WRITE_FILTER:\n"));\r\nbreak;\r\ncase SNDCTL_DSP_SETSYNCRO:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SNDCTL_DSP_SETSYNCRO:\n"));\r\nbreak;\r\ncase SOUND_PCM_READ_FILTER:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_PCM_READ_FILTER:\n"));\r\nbreak;\r\ncase SOUND_MIXER_PRIVATE1:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE1:\n"));\r\nbreak;\r\ncase SOUND_MIXER_PRIVATE2:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE2:\n"));\r\nbreak;\r\ncase SOUND_MIXER_PRIVATE3:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE3:\n"));\r\nbreak;\r\ncase SOUND_MIXER_PRIVATE4:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE4:\n"));\r\nbreak;\r\ncase SOUND_MIXER_PRIVATE5:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_PRIVATE5:\n"));\r\nbreak;\r\ncase SOUND_MIXER_INFO:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_INFO:\n"));\r\nbreak;\r\ncase SOUND_OLD_MIXER_INFO:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_OLD_MIXER_INFO:\n"));\r\nbreak;\r\ndefault:\r\nswitch (_IOC_NR(x)) {\r\ncase SOUND_MIXER_VOLUME:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_VOLUME:\n"));\r\nbreak;\r\ncase SOUND_MIXER_SPEAKER:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_SPEAKER:\n"));\r\nbreak;\r\ncase SOUND_MIXER_RECLEV:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_RECLEV:\n"));\r\nbreak;\r\ncase SOUND_MIXER_MIC:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_MIC:\n"));\r\nbreak;\r\ncase SOUND_MIXER_SYNTH:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_SYNTH:\n"));\r\nbreak;\r\ncase SOUND_MIXER_RECSRC:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_RECSRC:\n"));\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_DEVMASK:\n"));\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_RECMASK:\n"));\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nCS_DBGOUT(CS_IOCTL, 4,\r\nprintk("SOUND_MIXER_STEREODEVS:\n"));\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nCS_DBGOUT(CS_IOCTL, 4, printk("SOUND_MIXER_CAPS:\n"));\r\nbreak;\r\ndefault:\r\ni = _IOC_NR(x);\r\nif (i >= SOUND_MIXER_NRDEVICES\r\n|| !(vidx = mixtable1[i])) {\r\nCS_DBGOUT(CS_IOCTL, 4, printk\r\n("UNKNOWN IOCTL: 0x%.8x NR=%d\n",\r\nx, i));\r\n} else {\r\nCS_DBGOUT(CS_IOCTL, 4, printk\r\n("SOUND_MIXER_IOCTL AC9x: 0x%.8x NR=%d\n",\r\nx, i));\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int ser_init(struct cs4297a_state *s)\r\n{\r\nint i;\r\nCS_DBGOUT(CS_INIT, 2,\r\nprintk(KERN_INFO "cs4297a: Setting up serial parameters\n"));\r\n__raw_writeq(M_SYNCSER_CMD_RX_RESET | M_SYNCSER_CMD_TX_RESET, SS_CSR(R_SER_CMD));\r\n__raw_writeq(M_SYNCSER_MSB_FIRST, SS_CSR(R_SER_MODE));\r\n__raw_writeq(32, SS_CSR(R_SER_MINFRM_SZ));\r\n__raw_writeq(32, SS_CSR(R_SER_MAXFRM_SZ));\r\n__raw_writeq(1, SS_CSR(R_SER_TX_RD_THRSH));\r\n__raw_writeq(4, SS_CSR(R_SER_TX_WR_THRSH));\r\n__raw_writeq(8, SS_CSR(R_SER_RX_RD_THRSH));\r\n__raw_writeq((M_SYNCSER_TXSYNC_INT | V_SYNCSER_TXSYNC_DLY(0) | M_SYNCSER_TXCLK_EXT |\r\nM_SYNCSER_RXSYNC_INT | V_SYNCSER_RXSYNC_DLY(1) | M_SYNCSER_RXCLK_EXT | M_SYNCSER_RXSYNC_EDGE),\r\nSS_CSR(R_SER_LINE_MODE));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT(14) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE,\r\nSS_TXTBL(0));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT(15) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,\r\nSS_TXTBL(1));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT(13) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,\r\nSS_TXTBL(2));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT( 0) | M_SYNCSER_SEQ_ENABLE |\r\nM_SYNCSER_SEQ_STROBE | M_SYNCSER_SEQ_LAST, SS_TXTBL(3));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT(14) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE,\r\nSS_RXTBL(0));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT(15) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,\r\nSS_RXTBL(1));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT(13) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_BYTE,\r\nSS_RXTBL(2));\r\n__raw_writeq(V_SYNCSER_SEQ_COUNT( 0) | M_SYNCSER_SEQ_ENABLE | M_SYNCSER_SEQ_STROBE |\r\nM_SYNCSER_SEQ_LAST, SS_RXTBL(3));\r\nfor (i=4; i<16; i++) {\r\n__raw_writeq(M_SYNCSER_SEQ_LAST, SS_TXTBL(i));\r\n__raw_writeq(M_SYNCSER_SEQ_LAST, SS_RXTBL(i));\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_serdma(serdma_t *dma)\r\n{\r\nCS_DBGOUT(CS_INIT, 2,\r\nprintk(KERN_ERR "cs4297a: desc - %d sbufsize - %d dbufsize - %d\n",\r\nDMA_DESCR, SAMPLE_BUF_SIZE, DMA_BUF_SIZE));\r\ndma->ringsz = DMA_DESCR;\r\ndma->descrtab = kzalloc(dma->ringsz * sizeof(serdma_descr_t), GFP_KERNEL);\r\nif (!dma->descrtab) {\r\nprintk(KERN_ERR "cs4297a: kzalloc descrtab failed\n");\r\nreturn -1;\r\n}\r\ndma->descrtab_end = dma->descrtab + dma->ringsz;\r\ndma->descrtab_phys = CPHYSADDR((long)dma->descrtab);\r\ndma->descr_add = dma->descr_rem = dma->descrtab;\r\ndma->dma_buf = kzalloc(DMA_BUF_SIZE, GFP_KERNEL);\r\nif (!dma->dma_buf) {\r\nprintk(KERN_ERR "cs4297a: kzalloc dma_buf failed\n");\r\nkfree(dma->descrtab);\r\nreturn -1;\r\n}\r\ndma->dma_buf_phys = CPHYSADDR((long)dma->dma_buf);\r\ndma->sbufsz = SAMPLE_BUF_SIZE;\r\ndma->sample_buf = kmalloc(dma->sbufsz, GFP_KERNEL);\r\nif (!dma->sample_buf) {\r\nprintk(KERN_ERR "cs4297a: kmalloc sample_buf failed\n");\r\nkfree(dma->descrtab);\r\nkfree(dma->dma_buf);\r\nreturn -1;\r\n}\r\ndma->sb_swptr = dma->sb_hwptr = dma->sample_buf;\r\ndma->sb_end = (u16 *)((void *)dma->sample_buf + dma->sbufsz);\r\ndma->fragsize = dma->sbufsz >> 1;\r\nCS_DBGOUT(CS_INIT, 4,\r\nprintk(KERN_ERR "cs4297a: descrtab - %08x dma_buf - %x sample_buf - %x\n",\r\n(int)dma->descrtab, (int)dma->dma_buf,\r\n(int)dma->sample_buf));\r\nreturn 0;\r\n}\r\nstatic int dma_init(struct cs4297a_state *s)\r\n{\r\nint i;\r\nCS_DBGOUT(CS_INIT, 2,\r\nprintk(KERN_INFO "cs4297a: Setting up DMA\n"));\r\nif (init_serdma(&s->dma_adc) ||\r\ninit_serdma(&s->dma_dac))\r\nreturn -1;\r\nif (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_RX))||\r\n__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX))) {\r\npanic("DMA state corrupted?!");\r\n}\r\nfor (i=0; i<DMA_DESCR; i++) {\r\ns->dma_dac.descrtab[i].descr_a = M_DMA_SERRX_SOP | V_DMA_DSCRA_A_SIZE(1) |\r\n(s->dma_dac.dma_buf_phys + i*FRAME_BYTES);\r\ns->dma_dac.descrtab[i].descr_b = V_DMA_DSCRB_PKT_SIZE(FRAME_BYTES);\r\ns->dma_adc.descrtab[i].descr_a = V_DMA_DSCRA_A_SIZE(1) |\r\n(s->dma_adc.dma_buf_phys + i*FRAME_BYTES);\r\ns->dma_adc.descrtab[i].descr_b = 0;\r\n}\r\n__raw_writeq((M_DMA_EOP_INT_EN | V_DMA_INT_PKTCNT(DMA_INT_CNT) |\r\nV_DMA_RINGSZ(DMA_DESCR) | M_DMA_TDX_EN),\r\nSS_CSR(R_SER_DMA_CONFIG0_RX));\r\n__raw_writeq(M_DMA_L2CA, SS_CSR(R_SER_DMA_CONFIG1_RX));\r\n__raw_writeq(s->dma_adc.descrtab_phys, SS_CSR(R_SER_DMA_DSCR_BASE_RX));\r\n__raw_writeq(V_DMA_RINGSZ(DMA_DESCR), SS_CSR(R_SER_DMA_CONFIG0_TX));\r\n__raw_writeq(M_DMA_L2CA | M_DMA_NO_DSCR_UPDT, SS_CSR(R_SER_DMA_CONFIG1_TX));\r\n__raw_writeq(s->dma_dac.descrtab_phys, SS_CSR(R_SER_DMA_DSCR_BASE_TX));\r\n__raw_writeq(DMA_DESCR, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));\r\n__raw_writeq(M_SYNCSER_DMA_RX_EN | M_SYNCSER_DMA_TX_EN, SS_CSR(R_SER_DMA_ENABLE));\r\n__raw_writeq((M_SYNCSER_RX_SYNC_ERR | M_SYNCSER_RX_OVERRUN | M_SYNCSER_RX_EOP_COUNT),\r\nSS_CSR(R_SER_INT_MASK));\r\n__raw_writeq(M_SYNCSER_CMD_TX_EN, SS_CSR(R_SER_CMD));\r\nudelay(1000);\r\n__raw_writeq(M_SYNCSER_CMD_RX_EN | M_SYNCSER_CMD_TX_EN, SS_CSR(R_SER_CMD));\r\nwhile ((__raw_readq(SS_CSR(R_SER_STATUS)) & 0xf1) != 1)\r\n;\r\nCS_DBGOUT(CS_INIT, 4,\r\nprintk(KERN_INFO "cs4297a: status: %08x\n",\r\n(unsigned int)(__raw_readq(SS_CSR(R_SER_STATUS)) & 0xffffffff)));\r\nreturn 0;\r\n}\r\nstatic int serdma_reg_access(struct cs4297a_state *s, u64 data)\r\n{\r\nserdma_t *d = &s->dma_dac;\r\nu64 *data_p;\r\nunsigned swptr;\r\nunsigned long flags;\r\nserdma_descr_t *descr;\r\nif (s->reg_request) {\r\nprintk(KERN_ERR "cs4297a: attempt to issue multiple reg_access\n");\r\nreturn -1;\r\n}\r\nif (s->ena & FMODE_WRITE) {\r\ns->reg_request = data;\r\ninterruptible_sleep_on(&s->dma_dac.reg_wait);\r\n} else {\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (d->hwptr != d->swptr) {\r\nprintk(KERN_ERR "cs4297a: reg access found bookkeeping error (hw/sw = %d/%d\n",\r\nd->hwptr, d->swptr);\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn -1;\r\n}\r\nswptr = d->swptr;\r\nd->hwptr = d->swptr = (d->swptr + 1) % d->ringsz;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\ndescr = &d->descrtab[swptr];\r\ndata_p = &d->dma_buf[swptr * 4];\r\n*data_p = cpu_to_be64(data);\r\n__raw_writeq(1, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));\r\nCS_DBGOUT(CS_DESCR, 4,\r\nprintk(KERN_INFO "cs4297a: add_tx %p (%x -> %x)\n",\r\ndata_p, swptr, d->hwptr));\r\n}\r\nCS_DBGOUT(CS_FUNCTION, 6,\r\nprintk(KERN_INFO "cs4297a: serdma_reg_access()-\n"));\r\nreturn 0;\r\n}\r\nstatic int cs4297a_read_ac97(struct cs4297a_state *s, u32 offset,\r\nu32 * value)\r\n{\r\nCS_DBGOUT(CS_AC97, 1,\r\nprintk(KERN_INFO "cs4297a: read reg %2x\n", offset));\r\nif (serdma_reg_access(s, (0xCLL << 60) | (1LL << 47) | ((u64)(offset & 0x7F) << 40)))\r\nreturn -1;\r\ninterruptible_sleep_on(&s->dma_adc.reg_wait);\r\n*value = s->read_value;\r\nCS_DBGOUT(CS_AC97, 2,\r\nprintk(KERN_INFO "cs4297a: rdr reg %x -> %x\n", s->read_reg, s->read_value));\r\nreturn 0;\r\n}\r\nstatic int cs4297a_write_ac97(struct cs4297a_state *s, u32 offset,\r\nu32 value)\r\n{\r\nCS_DBGOUT(CS_AC97, 1,\r\nprintk(KERN_INFO "cs4297a: write reg %2x -> %04x\n", offset, value));\r\nreturn (serdma_reg_access(s, (0xELL << 60) | ((u64)(offset & 0x7F) << 40) | ((value & 0xffff) << 12)));\r\n}\r\nstatic void stop_dac(struct cs4297a_state *s)\r\n{\r\nunsigned long flags;\r\nCS_DBGOUT(CS_WAVE_WRITE, 3, printk(KERN_INFO "cs4297a: stop_dac():\n"));\r\nspin_lock_irqsave(&s->lock, flags);\r\ns->ena &= ~FMODE_WRITE;\r\n#if 0\r\n__raw_writeq((s->ena & FMODE_READ) ? M_SYNCSER_DMA_RX_EN : 0,\r\nSS_CSR(R_SER_DMA_ENABLE));\r\n#endif\r\nspin_unlock_irqrestore(&s->lock, flags);\r\n}\r\nstatic void start_dac(struct cs4297a_state *s)\r\n{\r\nunsigned long flags;\r\nCS_DBGOUT(CS_FUNCTION, 3, printk(KERN_INFO "cs4297a: start_dac()+\n"));\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (!(s->ena & FMODE_WRITE) && (s->dma_dac.mapped ||\r\n(s->dma_dac.count > 0\r\n&& s->dma_dac.ready))) {\r\ns->ena |= FMODE_WRITE;\r\nCS_DBGOUT(CS_WAVE_WRITE | CS_PARMS, 8, printk(KERN_INFO\r\n"cs4297a: start_dac(): start dma\n"));\r\n}\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nCS_DBGOUT(CS_FUNCTION, 3,\r\nprintk(KERN_INFO "cs4297a: start_dac()-\n"));\r\n}\r\nstatic void stop_adc(struct cs4297a_state *s)\r\n{\r\nunsigned long flags;\r\nCS_DBGOUT(CS_FUNCTION, 3,\r\nprintk(KERN_INFO "cs4297a: stop_adc()+\n"));\r\nspin_lock_irqsave(&s->lock, flags);\r\ns->ena &= ~FMODE_READ;\r\nif (s->conversion == 1) {\r\ns->conversion = 0;\r\ns->prop_adc.fmt = s->prop_adc.fmt_original;\r\n}\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nCS_DBGOUT(CS_FUNCTION, 3,\r\nprintk(KERN_INFO "cs4297a: stop_adc()-\n"));\r\n}\r\nstatic void start_adc(struct cs4297a_state *s)\r\n{\r\nunsigned long flags;\r\nCS_DBGOUT(CS_FUNCTION, 2,\r\nprintk(KERN_INFO "cs4297a: start_adc()+\n"));\r\nif (!(s->ena & FMODE_READ) &&\r\n(s->dma_adc.mapped || s->dma_adc.count <=\r\n(signed) (s->dma_adc.sbufsz - 2 * s->dma_adc.fragsize))\r\n&& s->dma_adc.ready) {\r\nif (s->prop_adc.fmt & AFMT_S8 || s->prop_adc.fmt & AFMT_U8) {\r\ns->prop_adc.fmt_original = s->prop_adc.fmt;\r\nif (s->prop_adc.fmt & AFMT_S8) {\r\ns->prop_adc.fmt &= ~AFMT_S8;\r\ns->prop_adc.fmt |= AFMT_S16_LE;\r\n}\r\nif (s->prop_adc.fmt & AFMT_U8) {\r\ns->prop_adc.fmt &= ~AFMT_U8;\r\ns->prop_adc.fmt |= AFMT_U16_LE;\r\n}\r\nprog_codec(s, CS_TYPE_ADC);\r\nprog_dmabuf_adc(s);\r\ns->conversion = 1;\r\n}\r\nspin_lock_irqsave(&s->lock, flags);\r\ns->ena |= FMODE_READ;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nCS_DBGOUT(CS_PARMS, 6, printk(KERN_INFO\r\n"cs4297a: start_adc(): start adc\n"));\r\n}\r\nCS_DBGOUT(CS_FUNCTION, 2,\r\nprintk(KERN_INFO "cs4297a: start_adc()-\n"));\r\n}\r\nstatic void cs4297a_update_ptr(struct cs4297a_state *s, int intflag)\r\n{\r\nint good_diff, diff, diff2;\r\nu64 *data_p, data;\r\nu32 *s_ptr;\r\nunsigned hwptr;\r\nu32 status;\r\nserdma_t *d;\r\nserdma_descr_t *descr;\r\nstatus = intflag ? __raw_readq(SS_CSR(R_SER_STATUS)) : 0;\r\nif ((s->ena & FMODE_READ) || (status & (M_SYNCSER_RX_EOP_COUNT))) {\r\nd = &s->dma_adc;\r\nhwptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -\r\nd->descrtab_phys) / sizeof(serdma_descr_t));\r\nif (s->ena & FMODE_READ) {\r\nCS_DBGOUT(CS_FUNCTION, 2,\r\nprintk(KERN_INFO "cs4297a: upd_rcv sw->hw->hw %x/%x/%x (int-%d)n",\r\nd->swptr, d->hwptr, hwptr, intflag));\r\ndiff2 = diff = (d->ringsz + hwptr - d->hwptr) % d->ringsz;\r\nd->hwptr = hwptr;\r\ngood_diff = 0;\r\ns_ptr = (u32 *)&(d->dma_buf[d->swptr*4]);\r\ndescr = &d->descrtab[d->swptr];\r\nwhile (diff2--) {\r\nu64 data = be64_to_cpu(*(u64 *)s_ptr);\r\nu64 descr_a;\r\nu16 left, right;\r\ndescr_a = descr->descr_a;\r\ndescr->descr_a &= ~M_DMA_SERRX_SOP;\r\nif ((descr_a & M_DMA_DSCRA_A_ADDR) != CPHYSADDR((long)s_ptr)) {\r\nprintk(KERN_ERR "cs4297a: RX Bad address (read)\n");\r\n}\r\nif (((data & 0x9800000000000000) != 0x9800000000000000) ||\r\n(!(descr_a & M_DMA_SERRX_SOP)) ||\r\n(G_DMA_DSCRB_PKT_SIZE(descr->descr_b) != FRAME_BYTES)) {\r\ns->stats.rx_bad++;\r\nprintk(KERN_DEBUG "cs4297a: RX Bad attributes (read)\n");\r\ncontinue;\r\n}\r\ns->stats.rx_good++;\r\nif ((data >> 61) == 7) {\r\ns->read_value = (data >> 12) & 0xffff;\r\ns->read_reg = (data >> 40) & 0x7f;\r\nwake_up(&d->reg_wait);\r\n}\r\nif (d->count && (d->sb_hwptr == d->sb_swptr)) {\r\ns->stats.rx_overflow++;\r\nprintk(KERN_DEBUG "cs4297a: RX overflow\n");\r\ncontinue;\r\n}\r\ngood_diff++;\r\nleft = ((be32_to_cpu(s_ptr[1]) & 0xff) << 8) |\r\n((be32_to_cpu(s_ptr[2]) >> 24) & 0xff);\r\nright = (be32_to_cpu(s_ptr[2]) >> 4) & 0xffff;\r\n*d->sb_hwptr++ = cpu_to_be16(left);\r\n*d->sb_hwptr++ = cpu_to_be16(right);\r\nif (d->sb_hwptr == d->sb_end)\r\nd->sb_hwptr = d->sample_buf;\r\ndescr++;\r\nif (descr == d->descrtab_end) {\r\ndescr = d->descrtab;\r\ns_ptr = (u32 *)s->dma_adc.dma_buf;\r\n} else {\r\ns_ptr += 8;\r\n}\r\n}\r\nd->total_bytes += good_diff * FRAME_SAMPLE_BYTES;\r\nd->count += good_diff * FRAME_SAMPLE_BYTES;\r\nif (d->count > d->sbufsz) {\r\nprintk(KERN_ERR "cs4297a: bogus receive overflow!!\n");\r\n}\r\nd->swptr = (d->swptr + diff) % d->ringsz;\r\n__raw_writeq(diff, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));\r\nif (d->mapped) {\r\nif (d->count >= (signed) d->fragsize)\r\nwake_up(&d->wait);\r\n} else {\r\nif (d->count > 0) {\r\nCS_DBGOUT(CS_WAVE_READ, 4,\r\nprintk(KERN_INFO\r\n"cs4297a: update count -> %d\n", d->count));\r\nwake_up(&d->wait);\r\n}\r\n}\r\n} else {\r\ndiff2 = diff = (hwptr + d->ringsz - d->hwptr) % d->ringsz;\r\nif (!diff) {\r\nprintk(KERN_ERR "cs4297a: RX full or empty?\n");\r\n}\r\ndescr = &d->descrtab[d->swptr];\r\ndata_p = &d->dma_buf[d->swptr*4];\r\ndo {\r\ndata = be64_to_cpu(*data_p);\r\nif ((descr->descr_a & M_DMA_DSCRA_A_ADDR) != CPHYSADDR((long)data_p)) {\r\nprintk(KERN_ERR "cs4297a: RX Bad address %d (%llx %lx)\n", d->swptr,\r\n(long long)(descr->descr_a & M_DMA_DSCRA_A_ADDR),\r\n(long)CPHYSADDR((long)data_p));\r\n}\r\nif (!(data & (1LL << 63)) ||\r\n!(descr->descr_a & M_DMA_SERRX_SOP) ||\r\n(G_DMA_DSCRB_PKT_SIZE(descr->descr_b) != FRAME_BYTES)) {\r\ns->stats.rx_bad++;\r\nprintk(KERN_DEBUG "cs4297a: RX Bad attributes\n");\r\n} else {\r\ns->stats.rx_good++;\r\nif ((data >> 61) == 7) {\r\ns->read_value = (data >> 12) & 0xffff;\r\ns->read_reg = (data >> 40) & 0x7f;\r\nwake_up(&d->reg_wait);\r\n}\r\n}\r\ndescr->descr_a &= ~M_DMA_SERRX_SOP;\r\ndescr++;\r\nd->swptr++;\r\ndata_p += 4;\r\nif (descr == d->descrtab_end) {\r\ndescr = d->descrtab;\r\nd->swptr = 0;\r\ndata_p = d->dma_buf;\r\n}\r\n__raw_writeq(1, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));\r\n} while (--diff);\r\nd->hwptr = hwptr;\r\nCS_DBGOUT(CS_DESCR, 6,\r\nprintk(KERN_INFO "cs4297a: hw/sw %x/%x\n", d->hwptr, d->swptr));\r\n}\r\nCS_DBGOUT(CS_PARMS, 8, printk(KERN_INFO\r\n"cs4297a: cs4297a_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d \n",\r\n(unsigned)s, d->hwptr,\r\nd->total_bytes, d->count));\r\n}\r\nif (s->ena & FMODE_WRITE) {\r\nserdma_t *d = &s->dma_dac;\r\nhwptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -\r\nd->descrtab_phys) / sizeof(serdma_descr_t));\r\ndiff = (d->ringsz + hwptr - d->hwptr) % d->ringsz;\r\nCS_DBGOUT(CS_WAVE_WRITE, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_update_ptr(): hw/hw/sw %x/%x/%x diff %d count %d\n",\r\nd->hwptr, hwptr, d->swptr, diff, d->count));\r\nd->hwptr = hwptr;\r\nd->total_bytes += diff * FRAME_SAMPLE_BYTES;\r\nif (d->mapped) {\r\nd->count += diff * FRAME_SAMPLE_BYTES;\r\nif (d->count >= d->fragsize) {\r\nd->wakeup = 1;\r\nwake_up(&d->wait);\r\nif (d->count > d->sbufsz)\r\nd->count &= d->sbufsz - 1;\r\n}\r\n} else {\r\nd->count -= diff * FRAME_SAMPLE_BYTES;\r\nif (d->count <= 0) {\r\nCS_DBGOUT(CS_WAVE_WRITE, 6, printk(KERN_INFO\r\n"cs4297a: cs4297a_update_ptr(): memset %d at 0x%.8x for %d size \n",\r\n(unsigned)(s->prop_dac.fmt &\r\n(AFMT_U8 | AFMT_U16_LE)) ? 0x80 : 0,\r\n(unsigned)d->dma_buf,\r\nd->ringsz));\r\nmemset(d->dma_buf, 0, d->ringsz * FRAME_BYTES);\r\nif (d->count < 0) {\r\nd->underrun = 1;\r\ns->stats.tx_underrun++;\r\nd->count = 0;\r\nCS_DBGOUT(CS_ERROR, 9, printk(KERN_INFO\r\n"cs4297a: cs4297a_update_ptr(): underrun\n"));\r\n}\r\n} else if (d->count <=\r\n(signed) d->fragsize\r\n&& !d->endcleared) {\r\nclear_advance(d->dma_buf,\r\nd->sbufsz,\r\nd->swptr,\r\nd->fragsize,\r\n0);\r\nd->endcleared = 1;\r\n}\r\nif ( (d->count <= (signed) d->sbufsz/2) || intflag)\r\n{\r\nCS_DBGOUT(CS_WAVE_WRITE, 4,\r\nprintk(KERN_INFO\r\n"cs4297a: update count -> %d\n", d->count));\r\nwake_up(&d->wait);\r\n}\r\n}\r\nCS_DBGOUT(CS_PARMS, 8, printk(KERN_INFO\r\n"cs4297a: cs4297a_update_ptr(): s=0x%.8x hwptr=%d total_bytes=%d count=%d \n",\r\n(unsigned) s, d->hwptr,\r\nd->total_bytes, d->count));\r\n}\r\n}\r\nstatic int mixer_ioctl(struct cs4297a_state *s, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstatic const unsigned int mixer_src[8] = {\r\nSOUND_MASK_MIC, SOUND_MASK_CD, 0, SOUND_MASK_LINE1,\r\nSOUND_MASK_LINE, SOUND_MASK_VOLUME, 0, 0\r\n};\r\nstatic const unsigned char mixtable1[SOUND_MIXER_NRDEVICES] = {\r\n[SOUND_MIXER_PCM] = 1,\r\n[SOUND_MIXER_LINE1] = 2,\r\n[SOUND_MIXER_CD] = 3,\r\n[SOUND_MIXER_LINE] = 4,\r\n[SOUND_MIXER_SYNTH] = 5,\r\n[SOUND_MIXER_MIC] = 6,\r\n[SOUND_MIXER_SPEAKER] = 7,\r\n[SOUND_MIXER_RECLEV] = 8,\r\n[SOUND_MIXER_VOLUME] = 9\r\n};\r\nstatic const unsigned mixreg[] = {\r\nAC97_PCMOUT_VOL,\r\nAC97_AUX_VOL,\r\nAC97_CD_VOL,\r\nAC97_LINEIN_VOL\r\n};\r\nunsigned char l, r, rl, rr, vidx;\r\nunsigned char attentbl[11] =\r\n{ 63, 42, 26, 17, 14, 11, 8, 6, 4, 2, 0 };\r\nunsigned temp1;\r\nint i, val;\r\nVALIDATE_STATE(s);\r\nCS_DBGOUT(CS_FUNCTION, 4, printk(KERN_INFO\r\n"cs4297a: mixer_ioctl(): s=0x%.8x cmd=0x%.8x\n",\r\n(unsigned) s, cmd));\r\n#if CSDEBUG\r\ncs_printioctl(cmd);\r\n#endif\r\n#if CSDEBUG_INTERFACE\r\nif ((cmd == SOUND_MIXER_CS_GETDBGMASK) ||\r\n(cmd == SOUND_MIXER_CS_SETDBGMASK) ||\r\n(cmd == SOUND_MIXER_CS_GETDBGLEVEL) ||\r\n(cmd == SOUND_MIXER_CS_SETDBGLEVEL))\r\n{\r\nswitch (cmd) {\r\ncase SOUND_MIXER_CS_GETDBGMASK:\r\nreturn put_user(cs_debugmask,\r\n(unsigned long *) arg);\r\ncase SOUND_MIXER_CS_GETDBGLEVEL:\r\nreturn put_user(cs_debuglevel,\r\n(unsigned long *) arg);\r\ncase SOUND_MIXER_CS_SETDBGMASK:\r\nif (get_user(val, (unsigned long *) arg))\r\nreturn -EFAULT;\r\ncs_debugmask = val;\r\nreturn 0;\r\ncase SOUND_MIXER_CS_SETDBGLEVEL:\r\nif (get_user(val, (unsigned long *) arg))\r\nreturn -EFAULT;\r\ncs_debuglevel = val;\r\nreturn 0;\r\ndefault:\r\nCS_DBGOUT(CS_ERROR, 1, printk(KERN_INFO\r\n"cs4297a: mixer_ioctl(): ERROR unknown debug cmd\n"));\r\nreturn 0;\r\n}\r\n}\r\n#endif\r\nif (cmd == SOUND_MIXER_PRIVATE1) {\r\nreturn -EINVAL;\r\n}\r\nif (cmd == SOUND_MIXER_PRIVATE2) {\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nif (val != -1) {\r\ntemp1 = (val & 0x3f) >> 2;\r\ncs4297a_write_ac97(s, AC97_3D_CONTROL, temp1);\r\ncs4297a_read_ac97(s, AC97_GENERAL_PURPOSE,\r\n&temp1);\r\ncs4297a_write_ac97(s, AC97_GENERAL_PURPOSE,\r\ntemp1 | 0x2000);\r\n}\r\ncs4297a_read_ac97(s, AC97_3D_CONTROL, &temp1);\r\nreturn put_user((temp1 << 2) | 3, (int *) arg);\r\n}\r\nif (cmd == SOUND_MIXER_INFO) {\r\nmixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, "CS4297a", sizeof(info.id));\r\nstrlcpy(info.name, "Crystal CS4297a", sizeof(info.name));\r\ninfo.modify_counter = s->mix.modcnt;\r\nif (copy_to_user((void *) arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (cmd == SOUND_OLD_MIXER_INFO) {\r\n_old_mixer_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.id, "CS4297a", sizeof(info.id));\r\nstrlcpy(info.name, "Crystal CS4297a", sizeof(info.name));\r\nif (copy_to_user((void *) arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (cmd == OSS_GETVERSION)\r\nreturn put_user(SOUND_VERSION, (int *) arg);\r\nif (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))\r\nreturn -EINVAL;\r\nif (_SIOC_DIR(cmd) == _SIOC_READ) {\r\nswitch (_IOC_NR(cmd)) {\r\ncase SOUND_MIXER_RECSRC:\r\ncs4297a_read_ac97(s, AC97_RECORD_SELECT,\r\n&temp1);\r\nreturn put_user(mixer_src[temp1 & 7], (int *) arg);\r\ncase SOUND_MIXER_DEVMASK:\r\nreturn put_user(SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_VOLUME | SOUND_MASK_RECLEV,\r\n(int *) arg);\r\ncase SOUND_MIXER_RECMASK:\r\nreturn put_user(SOUND_MASK_LINE | SOUND_MASK_VOLUME,\r\n(int *) arg);\r\ncase SOUND_MIXER_STEREODEVS:\r\nreturn put_user(SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_VOLUME | SOUND_MASK_RECLEV,\r\n(int *) arg);\r\ncase SOUND_MIXER_CAPS:\r\nreturn put_user(SOUND_CAP_EXCL_INPUT, (int *) arg);\r\ndefault:\r\ni = _IOC_NR(cmd);\r\nif (i >= SOUND_MIXER_NRDEVICES\r\n|| !(vidx = mixtable1[i]))\r\nreturn -EINVAL;\r\nreturn put_user(s->mix.vol[vidx - 1], (int *) arg);\r\n}\r\n}\r\nif (_SIOC_DIR(cmd) != (_SIOC_READ | _SIOC_WRITE))\r\nreturn -EINVAL;\r\ns->mix.modcnt++;\r\nswitch (_IOC_NR(cmd)) {\r\ncase SOUND_MIXER_RECSRC:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\ni = hweight32(val);\r\nif (i != 1)\r\nreturn 0;\r\nfor (i = 0; i < sizeof(mixer_src) / sizeof(int); i++) {\r\nif (val == mixer_src[i]) {\r\ntemp1 = (i << 8) | i;\r\ncs4297a_write_ac97(s,\r\nAC97_RECORD_SELECT,\r\ntemp1);\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\ncase SOUND_MIXER_VOLUME:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nl = val & 0xff;\r\nif (l > 100)\r\nl = 100;\r\nif (l < 6) {\r\nrl = 63;\r\nl = 0;\r\n} else\r\nrl = attentbl[(10 * l) / 100];\r\nr = (val >> 8) & 0xff;\r\nif (r > 100)\r\nr = 100;\r\nif (r < 6) {\r\nrr = 63;\r\nr = 0;\r\n} else\r\nrr = attentbl[(10 * r) / 100];\r\nif ((rl > 60) && (rr > 60))\r\ntemp1 = 0x8000;\r\nelse\r\ntemp1 = 0;\r\ntemp1 |= (rl << 8) | rr;\r\ncs4297a_write_ac97(s, AC97_MASTER_VOL_STEREO, temp1);\r\ncs4297a_write_ac97(s, AC97_PHONE_VOL, temp1);\r\n#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS\r\ns->mix.vol[8] = ((unsigned int) r << 8) | l;\r\n#else\r\ns->mix.vol[8] = val;\r\n#endif\r\nreturn put_user(s->mix.vol[8], (int *) arg);\r\ncase SOUND_MIXER_SPEAKER:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nl = val & 0xff;\r\nif (l > 100)\r\nl = 100;\r\nif (l < 3) {\r\nrl = 0;\r\nl = 0;\r\n} else {\r\nrl = (l * 2 - 5) / 13;\r\nl = (rl * 13 + 5) / 2;\r\n}\r\nif (rl < 3) {\r\ntemp1 = 0x8000;\r\nrl = 0;\r\n} else\r\ntemp1 = 0;\r\nrl = 15 - rl;\r\ntemp1 |= rl << 1;\r\ncs4297a_write_ac97(s, AC97_PCBEEP_VOL, temp1);\r\n#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS\r\ns->mix.vol[6] = l << 8;\r\n#else\r\ns->mix.vol[6] = val;\r\n#endif\r\nreturn put_user(s->mix.vol[6], (int *) arg);\r\ncase SOUND_MIXER_RECLEV:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nl = val & 0xff;\r\nif (l > 100)\r\nl = 100;\r\nr = (val >> 8) & 0xff;\r\nif (r > 100)\r\nr = 100;\r\nrl = (l * 2 - 5) / 13;\r\nrr = (r * 2 - 5) / 13;\r\nif (rl < 3 && rr < 3)\r\ntemp1 = 0x8000;\r\nelse\r\ntemp1 = 0;\r\ntemp1 = temp1 | (rl << 8) | rr;\r\ncs4297a_write_ac97(s, AC97_RECORD_GAIN, temp1);\r\n#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS\r\ns->mix.vol[7] = ((unsigned int) r << 8) | l;\r\n#else\r\ns->mix.vol[7] = val;\r\n#endif\r\nreturn put_user(s->mix.vol[7], (int *) arg);\r\ncase SOUND_MIXER_MIC:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nl = val & 0xff;\r\nif (l > 100)\r\nl = 100;\r\nif (l < 1) {\r\nl = 0;\r\nrl = 0;\r\n} else {\r\nrl = ((unsigned) l * 5 - 4) / 16;\r\nl = (rl * 16 + 4) / 5;\r\n}\r\ncs4297a_read_ac97(s, AC97_MIC_VOL, &temp1);\r\ntemp1 &= 0x40;\r\nif (rl < 3) {\r\ntemp1 |= 0x8000;\r\nrl = 0;\r\n}\r\nrl = 31 - rl;\r\ntemp1 |= rl;\r\ncs4297a_write_ac97(s, AC97_MIC_VOL, temp1);\r\n#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS\r\ns->mix.vol[5] = val << 8;\r\n#else\r\ns->mix.vol[5] = val;\r\n#endif\r\nreturn put_user(s->mix.vol[5], (int *) arg);\r\ncase SOUND_MIXER_SYNTH:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nl = val & 0xff;\r\nif (l > 100)\r\nl = 100;\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nr = (val >> 8) & 0xff;\r\nif (r > 100)\r\nr = 100;\r\nrl = (l * 2 - 11) / 3;\r\nrr = (r * 2 - 11) / 3;\r\nif (rl < 3)\r\ntemp1 = 0x0080;\r\nelse\r\ntemp1 = 0;\r\nrl = 63 - rl;\r\nif (rr < 3)\r\ntemp1 = 0x0080;\r\nelse\r\ntemp1 = 0;\r\nrr = 63 - rr;\r\n#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS\r\ns->mix.vol[4] = (r << 8) | l;\r\n#else\r\ns->mix.vol[4] = val;\r\n#endif\r\nreturn put_user(s->mix.vol[4], (int *) arg);\r\ndefault:\r\nCS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO\r\n"cs4297a: mixer_ioctl(): default\n"));\r\ni = _IOC_NR(cmd);\r\nif (i >= SOUND_MIXER_NRDEVICES || !(vidx = mixtable1[i]))\r\nreturn -EINVAL;\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nl = val & 0xff;\r\nif (l > 100)\r\nl = 100;\r\nif (l < 1) {\r\nl = 0;\r\nrl = 31;\r\n} else\r\nrl = (attentbl[(l * 10) / 100]) >> 1;\r\nr = (val >> 8) & 0xff;\r\nif (r > 100)\r\nr = 100;\r\nif (r < 1) {\r\nr = 0;\r\nrr = 31;\r\n} else\r\nrr = (attentbl[(r * 10) / 100]) >> 1;\r\nif ((rl > 30) && (rr > 30))\r\ntemp1 = 0x8000;\r\nelse\r\ntemp1 = 0;\r\ntemp1 = temp1 | (rl << 8) | rr;\r\ncs4297a_write_ac97(s, mixreg[vidx - 1], temp1);\r\n#ifdef OSS_DOCUMENTED_MIXER_SEMANTICS\r\ns->mix.vol[vidx - 1] = ((unsigned int) r << 8) | l;\r\n#else\r\ns->mix.vol[vidx - 1] = val;\r\n#endif\r\nreturn put_user(s->mix.vol[vidx - 1], (int *) arg);\r\n}\r\n}\r\nstatic int cs4297a_open_mixdev(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nstruct cs4297a_state *s=NULL;\r\nstruct list_head *entry;\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN, 4,\r\nprintk(KERN_INFO "cs4297a: cs4297a_open_mixdev()+\n"));\r\nmutex_lock(&swarm_cs4297a_mutex);\r\nlist_for_each(entry, &cs4297a_devs)\r\n{\r\ns = list_entry(entry, struct cs4297a_state, list);\r\nif(s->dev_mixer == minor)\r\nbreak;\r\n}\r\nif (!s)\r\n{\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN | CS_ERROR, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_open_mixdev()- -ENODEV\n"));\r\nmutex_unlock(&swarm_cs4297a_mutex);\r\nreturn -ENODEV;\r\n}\r\nVALIDATE_STATE(s);\r\nfile->private_data = s;\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN, 4,\r\nprintk(KERN_INFO "cs4297a: cs4297a_open_mixdev()- 0\n"));\r\nmutex_unlock(&swarm_cs4297a_mutex);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int cs4297a_release_mixdev(struct inode *inode, struct file *file)\r\n{\r\nstruct cs4297a_state *s =\r\n(struct cs4297a_state *) file->private_data;\r\nVALIDATE_STATE(s);\r\nreturn 0;\r\n}\r\nstatic int cs4297a_ioctl_mixdev(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&swarm_cs4297a_mutex);\r\nret = mixer_ioctl((struct cs4297a_state *) file->private_data, cmd,\r\narg);\r\nmutex_unlock(&swarm_cs4297a_mutex);\r\nreturn ret;\r\n}\r\nstatic int drain_adc(struct cs4297a_state *s, int nonblock)\r\n{\r\nreturn 0;\r\n}\r\nstatic int drain_dac(struct cs4297a_state *s, int nonblock)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nunsigned hwptr;\r\nunsigned tmo;\r\nint count;\r\nif (s->dma_dac.mapped)\r\nreturn 0;\r\nif (nonblock)\r\nreturn -EBUSY;\r\nadd_wait_queue(&s->dma_dac.wait, &wait);\r\nwhile ((count = __raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX))) ||\r\n(s->dma_dac.count > 0)) {\r\nif (!signal_pending(current)) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ntmo = ((count * FRAME_TX_US) * HZ) / 1000000;\r\nschedule_timeout(tmo + 1);\r\n} else {\r\n}\r\n}\r\nspin_lock_irqsave(&s->lock, flags);\r\nhwptr = (int)(((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -\r\ns->dma_dac.descrtab_phys) / sizeof(serdma_descr_t));\r\ns->dma_dac.hwptr = s->dma_dac.swptr = hwptr;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nremove_wait_queue(&s->dma_dac.wait, &wait);\r\ncurrent->state = TASK_RUNNING;\r\nreturn 0;\r\n}\r\nstatic ssize_t cs4297a_read(struct file *file, char *buffer, size_t count,\r\nloff_t * ppos)\r\n{\r\nstruct cs4297a_state *s =\r\n(struct cs4297a_state *) file->private_data;\r\nssize_t ret;\r\nunsigned long flags;\r\nint cnt, count_fr, cnt_by;\r\nunsigned copied = 0;\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_READ, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_read()+ %d \n", count));\r\nVALIDATE_STATE(s);\r\nif (s->dma_adc.mapped)\r\nreturn -ENXIO;\r\nif (!s->dma_adc.ready && (ret = prog_dmabuf_adc(s)))\r\nreturn ret;\r\nif (!access_ok(VERIFY_WRITE, buffer, count))\r\nreturn -EFAULT;\r\nret = 0;\r\nwhile (count > 0) {\r\nCS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO\r\n"_read() count>0 count=%d .count=%d .swptr=%d .hwptr=%d \n",\r\ncount, s->dma_adc.count,\r\ns->dma_adc.swptr, s->dma_adc.hwptr));\r\nspin_lock_irqsave(&s->lock, flags);\r\ncnt = (s->dma_adc.sb_end - s->dma_adc.sb_swptr) / 2;\r\ncount_fr = s->dma_adc.count / FRAME_SAMPLE_BYTES;\r\nif (count_fr < cnt)\r\ncnt = count_fr;\r\ncnt_by = cnt * FRAME_SAMPLE_BYTES;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nif (s->conversion) {\r\nif (cnt_by > (count * 2)) {\r\ncnt = (count * 2) / FRAME_SAMPLE_BYTES;\r\ncnt_by = count * 2;\r\n}\r\n} else {\r\nif (cnt_by > count) {\r\ncnt = count / FRAME_SAMPLE_BYTES;\r\ncnt_by = count;\r\n}\r\n}\r\nif (cnt <= 0) {\r\nstart_adc(s);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn ret ? ret : -EAGAIN;\r\ninterruptible_sleep_on(&s->dma_adc.wait);\r\nif (signal_pending(current))\r\nreturn ret ? ret : -ERESTARTSYS;\r\ncontinue;\r\n}\r\nCS_DBGOUT(CS_WAVE_READ, 2, printk(KERN_INFO\r\n"_read() copy_to cnt=%d count=%d ", cnt_by, count));\r\nCS_DBGOUT(CS_WAVE_READ, 8, printk(KERN_INFO\r\n" .sbufsz=%d .count=%d buffer=0x%.8x ret=%d\n",\r\ns->dma_adc.sbufsz, s->dma_adc.count,\r\n(unsigned) buffer, ret));\r\nif (copy_to_user (buffer, ((void *)s->dma_adc.sb_swptr), cnt_by))\r\nreturn ret ? ret : -EFAULT;\r\ncopied = cnt_by;\r\nspin_lock_irqsave(&s->lock, flags);\r\nCS_DBGOUT(CS_FUNCTION, 2,\r\nprintk(KERN_INFO "cs4297a: upd_rcv sw->hw %x/%x\n", s->dma_adc.swptr, s->dma_adc.hwptr));\r\ns->dma_adc.count -= cnt_by;\r\ns->dma_adc.sb_swptr += cnt * 2;\r\nif (s->dma_adc.sb_swptr == s->dma_adc.sb_end)\r\ns->dma_adc.sb_swptr = s->dma_adc.sample_buf;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\ncount -= copied;\r\nbuffer += copied;\r\nret += copied;\r\nstart_adc(s);\r\n}\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_READ, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_read()- %d\n", ret));\r\nreturn ret;\r\n}\r\nstatic ssize_t cs4297a_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t * ppos)\r\n{\r\nstruct cs4297a_state *s =\r\n(struct cs4297a_state *) file->private_data;\r\nssize_t ret;\r\nunsigned long flags;\r\nunsigned swptr, hwptr;\r\nint cnt;\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_write()+ count=%d\n",\r\ncount));\r\nVALIDATE_STATE(s);\r\nif (s->dma_dac.mapped)\r\nreturn -ENXIO;\r\nif (!s->dma_dac.ready && (ret = prog_dmabuf_dac(s)))\r\nreturn ret;\r\nif (!access_ok(VERIFY_READ, buffer, count))\r\nreturn -EFAULT;\r\nret = 0;\r\nwhile (count > 0) {\r\nserdma_t *d = &s->dma_dac;\r\nint copy_cnt;\r\nu32 *s_tmpl;\r\nu32 *t_tmpl;\r\nu32 left, right;\r\nint swap = (s->prop_dac.fmt == AFMT_S16_LE) || (s->prop_dac.fmt == AFMT_U16_LE);\r\nspin_lock_irqsave(&s->lock, flags);\r\nif (d->count < 0) {\r\nd->count = 0;\r\nd->swptr = d->hwptr;\r\n}\r\nif (d->underrun) {\r\nd->underrun = 0;\r\nhwptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -\r\nd->descrtab_phys) / sizeof(serdma_descr_t));\r\nd->swptr = d->hwptr = hwptr;\r\n}\r\nswptr = d->swptr;\r\ncnt = d->sbufsz - (swptr * FRAME_SAMPLE_BYTES);\r\nif (d->count + cnt > d->sbufsz)\r\ncnt = d->sbufsz - d->count;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nif (cnt > count)\r\ncnt = count;\r\nif (cnt <= 0) {\r\nstart_dac(s);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn ret ? ret : -EAGAIN;\r\ninterruptible_sleep_on(&d->wait);\r\nif (signal_pending(current))\r\nreturn ret ? ret : -ERESTARTSYS;\r\ncontinue;\r\n}\r\nif (copy_from_user(d->sample_buf, buffer, cnt))\r\nreturn ret ? ret : -EFAULT;\r\ncopy_cnt = cnt;\r\ns_tmpl = (u32 *)d->sample_buf;\r\nt_tmpl = (u32 *)(d->dma_buf + (swptr * 4));\r\ndo {\r\nu32 tmp;\r\nt_tmpl[0] = cpu_to_be32(0x98000000);\r\ntmp = be32_to_cpu(s_tmpl[0]);\r\nleft = tmp & 0xffff;\r\nright = tmp >> 16;\r\nif (swap) {\r\nleft = swab16(left);\r\nright = swab16(right);\r\n}\r\nt_tmpl[1] = cpu_to_be32(left >> 8);\r\nt_tmpl[2] = cpu_to_be32(((left & 0xff) << 24) |\r\n(right << 4));\r\ns_tmpl++;\r\nt_tmpl += 8;\r\ncopy_cnt -= 4;\r\n} while (copy_cnt);\r\nif (s->reg_request) {\r\n*(u64 *)(d->dma_buf + (swptr * 4)) |=\r\ncpu_to_be64(s->reg_request);\r\ns->reg_request = 0;\r\nwake_up(&s->dma_dac.reg_wait);\r\n}\r\nCS_DBGOUT(CS_WAVE_WRITE, 4,\r\nprintk(KERN_INFO\r\n"cs4297a: copy in %d to swptr %x\n", cnt, swptr));\r\nswptr = (swptr + (cnt/FRAME_SAMPLE_BYTES)) % d->ringsz;\r\n__raw_writeq(cnt/FRAME_SAMPLE_BYTES, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));\r\nspin_lock_irqsave(&s->lock, flags);\r\nd->swptr = swptr;\r\nd->count += cnt;\r\nd->endcleared = 0;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\ncount -= cnt;\r\nbuffer += cnt;\r\nret += cnt;\r\nstart_dac(s);\r\n}\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_write()- %d\n", ret));\r\nreturn ret;\r\n}\r\nstatic unsigned int cs4297a_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct cs4297a_state *s =\r\n(struct cs4297a_state *) file->private_data;\r\nunsigned long flags;\r\nunsigned int mask = 0;\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,\r\nprintk(KERN_INFO "cs4297a: cs4297a_poll()+\n"));\r\nVALIDATE_STATE(s);\r\nif (file->f_mode & FMODE_WRITE) {\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,\r\nprintk(KERN_INFO\r\n"cs4297a: cs4297a_poll() wait on FMODE_WRITE\n"));\r\nif(!s->dma_dac.ready && prog_dmabuf_dac(s))\r\nreturn 0;\r\npoll_wait(file, &s->dma_dac.wait, wait);\r\n}\r\nif (file->f_mode & FMODE_READ) {\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,\r\nprintk(KERN_INFO\r\n"cs4297a: cs4297a_poll() wait on FMODE_READ\n"));\r\nif(!s->dma_dac.ready && prog_dmabuf_adc(s))\r\nreturn 0;\r\npoll_wait(file, &s->dma_adc.wait, wait);\r\n}\r\nspin_lock_irqsave(&s->lock, flags);\r\ncs4297a_update_ptr(s,CS_FALSE);\r\nif (file->f_mode & FMODE_WRITE) {\r\nif (s->dma_dac.mapped) {\r\nif (s->dma_dac.count >=\r\n(signed) s->dma_dac.fragsize) {\r\nif (s->dma_dac.wakeup)\r\nmask |= POLLOUT | POLLWRNORM;\r\nelse\r\nmask = 0;\r\ns->dma_dac.wakeup = 0;\r\n}\r\n} else {\r\nif ((signed) (s->dma_dac.sbufsz/2) >= s->dma_dac.count)\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\n} else if (file->f_mode & FMODE_READ) {\r\nif (s->dma_adc.mapped) {\r\nif (s->dma_adc.count >= (signed) s->dma_adc.fragsize)\r\nmask |= POLLIN | POLLRDNORM;\r\n} else {\r\nif (s->dma_adc.count > 0)\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\n}\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nCS_DBGOUT(CS_FUNCTION | CS_WAVE_WRITE | CS_WAVE_READ, 4,\r\nprintk(KERN_INFO "cs4297a: cs4297a_poll()- 0x%.8x\n",\r\nmask));\r\nreturn mask;\r\n}\r\nstatic int cs4297a_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int cs4297a_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cs4297a_state *s =\r\n(struct cs4297a_state *) file->private_data;\r\nunsigned long flags;\r\naudio_buf_info abinfo;\r\ncount_info cinfo;\r\nint val, mapped, ret;\r\nCS_DBGOUT(CS_FUNCTION|CS_IOCTL, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): file=0x%.8x cmd=0x%.8x\n",\r\n(unsigned) file, cmd));\r\n#if CSDEBUG\r\ncs_printioctl(cmd);\r\n#endif\r\nVALIDATE_STATE(s);\r\nmapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||\r\n((file->f_mode & FMODE_READ) && s->dma_adc.mapped);\r\nswitch (cmd) {\r\ncase OSS_GETVERSION:\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): SOUND_VERSION=0x%.8x\n",\r\nSOUND_VERSION));\r\nreturn put_user(SOUND_VERSION, (int *) arg);\r\ncase SNDCTL_DSP_SYNC:\r\nCS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_SYNC\n"));\r\nif (file->f_mode & FMODE_WRITE)\r\nreturn drain_dac(s,\r\n0\r\n);\r\nreturn 0;\r\ncase SNDCTL_DSP_SETDUPLEX:\r\nreturn 0;\r\ncase SNDCTL_DSP_GETCAPS:\r\nreturn put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |\r\nDSP_CAP_TRIGGER | DSP_CAP_MMAP,\r\n(int *) arg);\r\ncase SNDCTL_DSP_RESET:\r\nCS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_RESET\n"));\r\nif (file->f_mode & FMODE_WRITE) {\r\nstop_dac(s);\r\nsynchronize_irq(s->irq);\r\ns->dma_dac.count = s->dma_dac.total_bytes =\r\ns->dma_dac.blocks = s->dma_dac.wakeup = 0;\r\ns->dma_dac.swptr = s->dma_dac.hwptr =\r\n(int)(((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_TX)) & M_DMA_CURDSCR_ADDR) -\r\ns->dma_dac.descrtab_phys) / sizeof(serdma_descr_t));\r\n}\r\nif (file->f_mode & FMODE_READ) {\r\nstop_adc(s);\r\nsynchronize_irq(s->irq);\r\ns->dma_adc.count = s->dma_adc.total_bytes =\r\ns->dma_adc.blocks = s->dma_dac.wakeup = 0;\r\ns->dma_adc.swptr = s->dma_adc.hwptr =\r\n(int)(((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -\r\ns->dma_adc.descrtab_phys) / sizeof(serdma_descr_t));\r\n}\r\nreturn 0;\r\ncase SNDCTL_DSP_SPEED:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_SPEED val=%d -> 48000\n", val));\r\nval = 48000;\r\nreturn put_user(val, (int *) arg);\r\ncase SNDCTL_DSP_STEREO:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_STEREO val=%d\n", val));\r\nif (file->f_mode & FMODE_READ) {\r\nstop_adc(s);\r\ns->dma_adc.ready = 0;\r\ns->prop_adc.channels = val ? 2 : 1;\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\nstop_dac(s);\r\ns->dma_dac.ready = 0;\r\ns->prop_dac.channels = val ? 2 : 1;\r\n}\r\nreturn 0;\r\ncase SNDCTL_DSP_CHANNELS:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_CHANNELS val=%d\n",\r\nval));\r\nif (val != 0) {\r\nif (file->f_mode & FMODE_READ) {\r\nstop_adc(s);\r\ns->dma_adc.ready = 0;\r\nif (val >= 2)\r\ns->prop_adc.channels = 2;\r\nelse\r\ns->prop_adc.channels = 1;\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\nstop_dac(s);\r\ns->dma_dac.ready = 0;\r\nif (val >= 2)\r\ns->prop_dac.channels = 2;\r\nelse\r\ns->prop_dac.channels = 1;\r\n}\r\n}\r\nif (file->f_mode & FMODE_WRITE)\r\nval = s->prop_dac.channels;\r\nelse if (file->f_mode & FMODE_READ)\r\nval = s->prop_adc.channels;\r\nreturn put_user(val, (int *) arg);\r\ncase SNDCTL_DSP_GETFMTS:\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_GETFMT val=0x%.8x\n",\r\nAFMT_S16_LE | AFMT_U16_LE | AFMT_S8 |\r\nAFMT_U8));\r\nreturn put_user(AFMT_S16_LE | AFMT_U16_LE | AFMT_S8 |\r\nAFMT_U8, (int *) arg);\r\ncase SNDCTL_DSP_SETFMT:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_SETFMT val=0x%.8x\n",\r\nval));\r\nif (val != AFMT_QUERY) {\r\nif (file->f_mode & FMODE_READ) {\r\nstop_adc(s);\r\ns->dma_adc.ready = 0;\r\nif (val != AFMT_S16_LE\r\n&& val != AFMT_U16_LE && val != AFMT_S8\r\n&& val != AFMT_U8)\r\nval = AFMT_U8;\r\ns->prop_adc.fmt = val;\r\ns->prop_adc.fmt_original = s->prop_adc.fmt;\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\nstop_dac(s);\r\ns->dma_dac.ready = 0;\r\nif (val != AFMT_S16_LE\r\n&& val != AFMT_U16_LE && val != AFMT_S8\r\n&& val != AFMT_U8)\r\nval = AFMT_U8;\r\ns->prop_dac.fmt = val;\r\ns->prop_dac.fmt_original = s->prop_dac.fmt;\r\n}\r\n} else {\r\nif (file->f_mode & FMODE_WRITE)\r\nval = s->prop_dac.fmt_original;\r\nelse if (file->f_mode & FMODE_READ)\r\nval = s->prop_adc.fmt_original;\r\n}\r\nCS_DBGOUT(CS_IOCTL | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_SETFMT return val=0x%.8x\n",\r\nval));\r\nreturn put_user(val, (int *) arg);\r\ncase SNDCTL_DSP_POST:\r\nCS_DBGOUT(CS_IOCTL, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): DSP_POST\n"));\r\nreturn 0;\r\ncase SNDCTL_DSP_GETTRIGGER:\r\nval = 0;\r\nif (file->f_mode & s->ena & FMODE_READ)\r\nval |= PCM_ENABLE_INPUT;\r\nif (file->f_mode & s->ena & FMODE_WRITE)\r\nval |= PCM_ENABLE_OUTPUT;\r\nreturn put_user(val, (int *) arg);\r\ncase SNDCTL_DSP_SETTRIGGER:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nif (file->f_mode & FMODE_READ) {\r\nif (val & PCM_ENABLE_INPUT) {\r\nif (!s->dma_adc.ready\r\n&& (ret = prog_dmabuf_adc(s)))\r\nreturn ret;\r\nstart_adc(s);\r\n} else\r\nstop_adc(s);\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\nif (val & PCM_ENABLE_OUTPUT) {\r\nif (!s->dma_dac.ready\r\n&& (ret = prog_dmabuf_dac(s)))\r\nreturn ret;\r\nstart_dac(s);\r\n} else\r\nstop_dac(s);\r\n}\r\nreturn 0;\r\ncase SNDCTL_DSP_GETOSPACE:\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EINVAL;\r\nif (!s->dma_dac.ready && (val = prog_dmabuf_dac(s)))\r\nreturn val;\r\nspin_lock_irqsave(&s->lock, flags);\r\ncs4297a_update_ptr(s,CS_FALSE);\r\nabinfo.fragsize = s->dma_dac.fragsize;\r\nif (s->dma_dac.mapped)\r\nabinfo.bytes = s->dma_dac.sbufsz;\r\nelse\r\nabinfo.bytes =\r\ns->dma_dac.sbufsz - s->dma_dac.count;\r\nabinfo.fragstotal = s->dma_dac.numfrag;\r\nabinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;\r\nCS_DBGOUT(CS_FUNCTION | CS_PARMS, 4, printk(KERN_INFO\r\n"cs4297a: cs4297a_ioctl(): GETOSPACE .fragsize=%d .bytes=%d .fragstotal=%d .fragments=%d\n",\r\nabinfo.fragsize,abinfo.bytes,abinfo.fragstotal,\r\nabinfo.fragments));\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn copy_to_user((void *) arg, &abinfo,\r\nsizeof(abinfo)) ? -EFAULT : 0;\r\ncase SNDCTL_DSP_GETISPACE:\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EINVAL;\r\nif (!s->dma_adc.ready && (val = prog_dmabuf_adc(s)))\r\nreturn val;\r\nspin_lock_irqsave(&s->lock, flags);\r\ncs4297a_update_ptr(s,CS_FALSE);\r\nif (s->conversion) {\r\nabinfo.fragsize = s->dma_adc.fragsize / 2;\r\nabinfo.bytes = s->dma_adc.count / 2;\r\nabinfo.fragstotal = s->dma_adc.numfrag;\r\nabinfo.fragments =\r\nabinfo.bytes >> (s->dma_adc.fragshift - 1);\r\n} else {\r\nabinfo.fragsize = s->dma_adc.fragsize;\r\nabinfo.bytes = s->dma_adc.count;\r\nabinfo.fragstotal = s->dma_adc.numfrag;\r\nabinfo.fragments =\r\nabinfo.bytes >> s->dma_adc.fragshift;\r\n}\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn copy_to_user((void *) arg, &abinfo,\r\nsizeof(abinfo)) ? -EFAULT : 0;\r\ncase SNDCTL_DSP_NONBLOCK:\r\nspin_lock(&file->f_lock);\r\nfile->f_flags |= O_NONBLOCK;\r\nspin_unlock(&file->f_lock);\r\nreturn 0;\r\ncase SNDCTL_DSP_GETODELAY:\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EINVAL;\r\nif(!s->dma_dac.ready && prog_dmabuf_dac(s))\r\nreturn 0;\r\nspin_lock_irqsave(&s->lock, flags);\r\ncs4297a_update_ptr(s,CS_FALSE);\r\nval = s->dma_dac.count;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn put_user(val, (int *) arg);\r\ncase SNDCTL_DSP_GETIPTR:\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EINVAL;\r\nif(!s->dma_adc.ready && prog_dmabuf_adc(s))\r\nreturn 0;\r\nspin_lock_irqsave(&s->lock, flags);\r\ncs4297a_update_ptr(s,CS_FALSE);\r\ncinfo.bytes = s->dma_adc.total_bytes;\r\nif (s->dma_adc.mapped) {\r\ncinfo.blocks =\r\n(cinfo.bytes >> s->dma_adc.fragshift) -\r\ns->dma_adc.blocks;\r\ns->dma_adc.blocks =\r\ncinfo.bytes >> s->dma_adc.fragshift;\r\n} else {\r\nif (s->conversion) {\r\ncinfo.blocks =\r\ns->dma_adc.count /\r\n2 >> (s->dma_adc.fragshift - 1);\r\n} else\r\ncinfo.blocks =\r\ns->dma_adc.count >> s->dma_adc.\r\nfragshift;\r\n}\r\nif (s->conversion)\r\ncinfo.ptr = s->dma_adc.hwptr / 2;\r\nelse\r\ncinfo.ptr = s->dma_adc.hwptr;\r\nif (s->dma_adc.mapped)\r\ns->dma_adc.count &= s->dma_adc.fragsize - 1;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn copy_to_user((void *) arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;\r\ncase SNDCTL_DSP_GETOPTR:\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EINVAL;\r\nif(!s->dma_dac.ready && prog_dmabuf_dac(s))\r\nreturn 0;\r\nspin_lock_irqsave(&s->lock, flags);\r\ncs4297a_update_ptr(s,CS_FALSE);\r\ncinfo.bytes = s->dma_dac.total_bytes;\r\nif (s->dma_dac.mapped) {\r\ncinfo.blocks =\r\n(cinfo.bytes >> s->dma_dac.fragshift) -\r\ns->dma_dac.blocks;\r\ns->dma_dac.blocks =\r\ncinfo.bytes >> s->dma_dac.fragshift;\r\n} else {\r\ncinfo.blocks =\r\ns->dma_dac.count >> s->dma_dac.fragshift;\r\n}\r\ncinfo.ptr = s->dma_dac.hwptr;\r\nif (s->dma_dac.mapped)\r\ns->dma_dac.count &= s->dma_dac.fragsize - 1;\r\nspin_unlock_irqrestore(&s->lock, flags);\r\nreturn copy_to_user((void *) arg, &cinfo, sizeof(cinfo)) ? -EFAULT : 0;\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\nif (file->f_mode & FMODE_WRITE) {\r\nif ((val = prog_dmabuf_dac(s)))\r\nreturn val;\r\nreturn put_user(s->dma_dac.fragsize, (int *) arg);\r\n}\r\nif ((val = prog_dmabuf_adc(s)))\r\nreturn val;\r\nif (s->conversion)\r\nreturn put_user(s->dma_adc.fragsize / 2,\r\n(int *) arg);\r\nelse\r\nreturn put_user(s->dma_adc.fragsize, (int *) arg);\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\nif ((file->f_mode & FMODE_READ && s->dma_adc.subdivision)\r\n|| (file->f_mode & FMODE_WRITE\r\n&& s->dma_dac.subdivision)) return -EINVAL;\r\nif (get_user(val, (int *) arg))\r\nreturn -EFAULT;\r\nif (val != 1 && val != 2 && val != 4)\r\nreturn -EINVAL;\r\nif (file->f_mode & FMODE_READ)\r\ns->dma_adc.subdivision = val;\r\nelse if (file->f_mode & FMODE_WRITE)\r\ns->dma_dac.subdivision = val;\r\nreturn 0;\r\ncase SOUND_PCM_READ_RATE:\r\nif (file->f_mode & FMODE_READ)\r\nreturn put_user(s->prop_adc.rate, (int *) arg);\r\nelse if (file->f_mode & FMODE_WRITE)\r\nreturn put_user(s->prop_dac.rate, (int *) arg);\r\ncase SOUND_PCM_READ_CHANNELS:\r\nif (file->f_mode & FMODE_READ)\r\nreturn put_user(s->prop_adc.channels, (int *) arg);\r\nelse if (file->f_mode & FMODE_WRITE)\r\nreturn put_user(s->prop_dac.channels, (int *) arg);\r\ncase SOUND_PCM_READ_BITS:\r\nif (file->f_mode & FMODE_READ)\r\nreturn\r\nput_user(\r\n(s->prop_adc.\r\nfmt & (AFMT_S8 | AFMT_U8)) ? 8 : 16,\r\n(int *) arg);\r\nelse if (file->f_mode & FMODE_WRITE)\r\nreturn\r\nput_user(\r\n(s->prop_dac.\r\nfmt & (AFMT_S8 | AFMT_U8)) ? 8 : 16,\r\n(int *) arg);\r\ncase SOUND_PCM_WRITE_FILTER:\r\ncase SNDCTL_DSP_SETSYNCRO:\r\ncase SOUND_PCM_READ_FILTER:\r\nreturn -EINVAL;\r\n}\r\nreturn mixer_ioctl(s, cmd, arg);\r\n}\r\nstatic long cs4297a_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nint ret;\r\nmutex_lock(&swarm_cs4297a_mutex);\r\nret = cs4297a_ioctl(file, cmd, arg);\r\nmutex_unlock(&swarm_cs4297a_mutex);\r\nreturn ret;\r\n}\r\nstatic int cs4297a_release(struct inode *inode, struct file *file)\r\n{\r\nstruct cs4297a_state *s =\r\n(struct cs4297a_state *) file->private_data;\r\nCS_DBGOUT(CS_FUNCTION | CS_RELEASE, 2, printk(KERN_INFO\r\n"cs4297a: cs4297a_release(): inode=0x%.8x file=0x%.8x f_mode=0x%x\n",\r\n(unsigned) inode, (unsigned) file, file->f_mode));\r\nVALIDATE_STATE(s);\r\nif (file->f_mode & FMODE_WRITE) {\r\ndrain_dac(s, file->f_flags & O_NONBLOCK);\r\nmutex_lock(&s->open_sem_dac);\r\nstop_dac(s);\r\ndealloc_dmabuf(s, &s->dma_dac);\r\ns->open_mode &= ~FMODE_WRITE;\r\nmutex_unlock(&s->open_sem_dac);\r\nwake_up(&s->open_wait_dac);\r\n}\r\nif (file->f_mode & FMODE_READ) {\r\ndrain_adc(s, file->f_flags & O_NONBLOCK);\r\nmutex_lock(&s->open_sem_adc);\r\nstop_adc(s);\r\ndealloc_dmabuf(s, &s->dma_adc);\r\ns->open_mode &= ~FMODE_READ;\r\nmutex_unlock(&s->open_sem_adc);\r\nwake_up(&s->open_wait_adc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs4297a_locked_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nstruct cs4297a_state *s=NULL;\r\nstruct list_head *entry;\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO\r\n"cs4297a: cs4297a_open(): inode=0x%.8x file=0x%.8x f_mode=0x%x\n",\r\n(unsigned) inode, (unsigned) file, file->f_mode));\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO\r\n"cs4297a: status = %08x\n", (int)__raw_readq(SS_CSR(R_SER_STATUS_DEBUG))));\r\nlist_for_each(entry, &cs4297a_devs)\r\n{\r\ns = list_entry(entry, struct cs4297a_state, list);\r\nif (!((s->dev_audio ^ minor) & ~0xf))\r\nbreak;\r\n}\r\nif (entry == &cs4297a_devs)\r\nreturn -ENODEV;\r\nif (!s) {\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN, 2, printk(KERN_INFO\r\n"cs4297a: cs4297a_open(): Error - unable to find audio state struct\n"));\r\nreturn -ENODEV;\r\n}\r\nVALIDATE_STATE(s);\r\nfile->private_data = s;\r\nif (!(file->f_mode & (FMODE_WRITE | FMODE_READ))) {\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN | CS_ERROR, 2, printk(KERN_INFO\r\n"cs4297a: cs4297a_open(): Error - must open READ and/or WRITE\n"));\r\nreturn -ENODEV;\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\nif (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX)) != 0) {\r\nprintk(KERN_ERR "cs4297a: TX pipe needs to drain\n");\r\nwhile (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_TX)))\r\n;\r\n}\r\nmutex_lock(&s->open_sem_dac);\r\nwhile (s->open_mode & FMODE_WRITE) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nmutex_unlock(&s->open_sem_dac);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&s->open_sem_dac);\r\ninterruptible_sleep_on(&s->open_wait_dac);\r\nif (signal_pending(current)) {\r\nprintk("open - sig pending\n");\r\nreturn -ERESTARTSYS;\r\n}\r\nmutex_lock(&s->open_sem_dac);\r\n}\r\n}\r\nif (file->f_mode & FMODE_READ) {\r\nmutex_lock(&s->open_sem_adc);\r\nwhile (s->open_mode & FMODE_READ) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nmutex_unlock(&s->open_sem_adc);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&s->open_sem_adc);\r\ninterruptible_sleep_on(&s->open_wait_adc);\r\nif (signal_pending(current)) {\r\nprintk("open - sig pending\n");\r\nreturn -ERESTARTSYS;\r\n}\r\nmutex_lock(&s->open_sem_adc);\r\n}\r\n}\r\ns->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);\r\nif (file->f_mode & FMODE_READ) {\r\ns->prop_adc.fmt = AFMT_S16_BE;\r\ns->prop_adc.fmt_original = s->prop_adc.fmt;\r\ns->prop_adc.channels = 2;\r\ns->prop_adc.rate = 48000;\r\ns->conversion = 0;\r\ns->ena &= ~FMODE_READ;\r\ns->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =\r\ns->dma_adc.subdivision = 0;\r\nmutex_unlock(&s->open_sem_adc);\r\nif (prog_dmabuf_adc(s)) {\r\nCS_DBGOUT(CS_OPEN | CS_ERROR, 2, printk(KERN_ERR\r\n"cs4297a: adc Program dmabufs failed.\n"));\r\ncs4297a_release(inode, file);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\ns->prop_dac.fmt = AFMT_S16_BE;\r\ns->prop_dac.fmt_original = s->prop_dac.fmt;\r\ns->prop_dac.channels = 2;\r\ns->prop_dac.rate = 48000;\r\ns->conversion = 0;\r\ns->ena &= ~FMODE_WRITE;\r\ns->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =\r\ns->dma_dac.subdivision = 0;\r\nmutex_unlock(&s->open_sem_dac);\r\nif (prog_dmabuf_dac(s)) {\r\nCS_DBGOUT(CS_OPEN | CS_ERROR, 2, printk(KERN_ERR\r\n"cs4297a: dac Program dmabufs failed.\n"));\r\ncs4297a_release(inode, file);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nCS_DBGOUT(CS_FUNCTION | CS_OPEN, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_open()- 0\n"));\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int cs4297a_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nmutex_lock(&swarm_cs4297a_mutex);\r\nret = cs4297a_open(inode, file);\r\nmutex_unlock(&swarm_cs4297a_mutex);\r\nreturn ret;\r\n}\r\nstatic void cs4297a_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cs4297a_state *s = (struct cs4297a_state *) dev_id;\r\nu32 status;\r\nstatus = __raw_readq(SS_CSR(R_SER_STATUS_DEBUG));\r\nCS_DBGOUT(CS_INTERRUPT, 6, printk(KERN_INFO\r\n"cs4297a: cs4297a_interrupt() HISR=0x%.8x\n", status));\r\n#if 0\r\nif (!(status & (M_SYNCSER_RX_EOP_COUNT | M_SYNCSER_RX_OVERRUN | M_SYNCSER_RX_SYNC_ERR))) {\r\nstatus = __raw_readq(SS_CSR(R_SER_STATUS));\r\nprintk(KERN_ERR "cs4297a: unexpected interrupt (status %08x)\n", status);\r\nreturn;\r\n}\r\n#endif\r\nif (status & M_SYNCSER_RX_SYNC_ERR) {\r\nstatus = __raw_readq(SS_CSR(R_SER_STATUS));\r\nprintk(KERN_ERR "cs4297a: rx sync error (status %08x)\n", status);\r\nreturn;\r\n}\r\nif (status & M_SYNCSER_RX_OVERRUN) {\r\nint newptr, i;\r\ns->stats.rx_ovrrn++;\r\nprintk(KERN_ERR "cs4297a: receive FIFO overrun\n");\r\nwhile (__raw_readq(SS_CSR(R_SER_DMA_DSCR_COUNT_RX)))\r\n;\r\nnewptr = (unsigned) (((__raw_readq(SS_CSR(R_SER_DMA_CUR_DSCR_ADDR_RX)) & M_DMA_CURDSCR_ADDR) -\r\ns->dma_adc.descrtab_phys) / sizeof(serdma_descr_t));\r\nfor (i=0; i<DMA_DESCR; i++) {\r\ns->dma_adc.descrtab[i].descr_a &= ~M_DMA_SERRX_SOP;\r\n}\r\ns->dma_adc.swptr = s->dma_adc.hwptr = newptr;\r\ns->dma_adc.count = 0;\r\ns->dma_adc.sb_swptr = s->dma_adc.sb_hwptr = s->dma_adc.sample_buf;\r\n__raw_writeq(DMA_DESCR, SS_CSR(R_SER_DMA_DSCR_COUNT_RX));\r\n}\r\nspin_lock(&s->lock);\r\ncs4297a_update_ptr(s,CS_TRUE);\r\nspin_unlock(&s->lock);\r\nCS_DBGOUT(CS_INTERRUPT, 6, printk(KERN_INFO\r\n"cs4297a: cs4297a_interrupt()-\n"));\r\n}\r\nstatic int __init cs4297a_init(void)\r\n{\r\nstruct cs4297a_state *s;\r\nu32 pwr, id;\r\nmm_segment_t fs;\r\nint rval;\r\n#ifndef CONFIG_BCM_CS4297A_CSWARM\r\nu64 cfg;\r\nint mdio_val;\r\n#endif\r\nCS_DBGOUT(CS_INIT | CS_FUNCTION, 2, printk(KERN_INFO\r\n"cs4297a: cs4297a_init_module()+ \n"));\r\n#ifndef CONFIG_BCM_CS4297A_CSWARM\r\nmdio_val = __raw_readq(KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO)) &\r\n(M_MAC_MDIO_DIR|M_MAC_MDIO_OUT);\r\ncfg = __raw_readq(KSEG1 + A_SCD_SYSTEM_CFG);\r\nif (!(cfg & M_SYS_SER1_ENABLE)) {\r\n__raw_writeq(cfg | M_SYS_SER1_ENABLE, KSEG1+A_SCD_SYSTEM_CFG);\r\ncfg = __raw_readq(KSEG1 + A_SCD_SYSTEM_CFG);\r\nif (!(cfg & M_SYS_SER1_ENABLE)) {\r\nprintk(KERN_INFO "cs4297a: serial port 1 not configured for synchronous operation\n");\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "cs4297a: serial port 1 switching to synchronous operation\n");\r\n__raw_writeq(mdio_val, KSEG1+A_MAC_REGISTER(2, R_MAC_MDIO));\r\nudelay(10);\r\n}\r\n__raw_writeq(mdio_val | M_MAC_GENC, KSEG1+A_MAC_REGISTER(2, R_MAC_MDIO));\r\nudelay(100);\r\n#endif\r\nif (!(s = kzalloc(sizeof(struct cs4297a_state), GFP_KERNEL))) {\r\nCS_DBGOUT(CS_ERROR, 1, printk(KERN_ERR\r\n"cs4297a: probe() no memory for state struct.\n"));\r\nreturn -1;\r\n}\r\ns->magic = CS4297a_MAGIC;\r\ninit_waitqueue_head(&s->dma_adc.wait);\r\ninit_waitqueue_head(&s->dma_dac.wait);\r\ninit_waitqueue_head(&s->dma_adc.reg_wait);\r\ninit_waitqueue_head(&s->dma_dac.reg_wait);\r\ninit_waitqueue_head(&s->open_wait);\r\ninit_waitqueue_head(&s->open_wait_adc);\r\ninit_waitqueue_head(&s->open_wait_dac);\r\nmutex_init(&s->open_sem_adc);\r\nmutex_init(&s->open_sem_dac);\r\nspin_lock_init(&s->lock);\r\ns->irq = K_INT_SER_1;\r\nif (request_irq\r\n(s->irq, cs4297a_interrupt, 0, "Crystal CS4297a", s)) {\r\nCS_DBGOUT(CS_INIT | CS_ERROR, 1,\r\nprintk(KERN_ERR "cs4297a: irq %u in use\n", s->irq));\r\ngoto err_irq;\r\n}\r\nif ((s->dev_audio = register_sound_dsp(&cs4297a_audio_fops, -1)) <\r\n0) {\r\nCS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR\r\n"cs4297a: probe() register_sound_dsp() failed.\n"));\r\ngoto err_dev1;\r\n}\r\nif ((s->dev_mixer = register_sound_mixer(&cs4297a_mixer_fops, -1)) <\r\n0) {\r\nCS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR\r\n"cs4297a: probe() register_sound_mixer() failed.\n"));\r\ngoto err_dev2;\r\n}\r\nif (ser_init(s) || dma_init(s)) {\r\nCS_DBGOUT(CS_INIT | CS_ERROR, 1, printk(KERN_ERR\r\n"cs4297a: ser_init failed.\n"));\r\ngoto err_dev3;\r\n}\r\ndo {\r\nudelay(4000);\r\nrval = cs4297a_read_ac97(s, AC97_POWER_CONTROL, &pwr);\r\n} while (!rval && (pwr != 0xf));\r\nif (!rval) {\r\nchar *sb1250_duart_present;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\n#if 0\r\nval = SOUND_MASK_LINE;\r\nmixer_ioctl(s, SOUND_MIXER_WRITE_RECSRC, (unsigned long) &val);\r\nfor (i = 0; i < ARRAY_SIZE(initvol); i++) {\r\nval = initvol[i].vol;\r\nmixer_ioctl(s, initvol[i].mixch, (unsigned long) &val);\r\n}\r\n#else\r\ncs4297a_write_ac97(s, 0x02, 0x0808);\r\ncs4297a_write_ac97(s, 0x18, 0x0808);\r\n#endif\r\nset_fs(fs);\r\nlist_add(&s->list, &cs4297a_devs);\r\ncs4297a_read_ac97(s, AC97_VENDOR_ID1, &id);\r\nsb1250_duart_present = symbol_get(sb1250_duart_present);\r\nif (sb1250_duart_present)\r\nsb1250_duart_present[1] = 0;\r\nprintk(KERN_INFO "cs4297a: initialized (vendor id = %x)\n", id);\r\nCS_DBGOUT(CS_INIT | CS_FUNCTION, 2,\r\nprintk(KERN_INFO "cs4297a: cs4297a_init_module()-\n"));\r\nreturn 0;\r\n}\r\nerr_dev3:\r\nunregister_sound_mixer(s->dev_mixer);\r\nerr_dev2:\r\nunregister_sound_dsp(s->dev_audio);\r\nerr_dev1:\r\nfree_irq(s->irq, s);\r\nerr_irq:\r\nkfree(s);\r\nprintk(KERN_INFO "cs4297a: initialization failed\n");\r\nreturn -1;\r\n}\r\nstatic void __exit cs4297a_cleanup(void)\r\n{\r\nCS_DBGOUT(CS_INIT | CS_FUNCTION, 2,\r\nprintk(KERN_INFO "cs4297a: cleanup_cs4297a() finished\n"));\r\n}
