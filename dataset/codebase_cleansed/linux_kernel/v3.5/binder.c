static int binder_set_stop_on_user_error(const char *val,\r\nstruct kernel_param *kp)\r\n{\r\nint ret;\r\nret = param_set_int(val, kp);\r\nif (binder_stop_on_user_error < 2)\r\nwake_up(&binder_user_error_wait);\r\nreturn ret;\r\n}\r\nstatic inline void binder_stats_deleted(enum binder_stat_types type)\r\n{\r\nbinder_stats.obj_deleted[type]++;\r\n}\r\nstatic inline void binder_stats_created(enum binder_stat_types type)\r\n{\r\nbinder_stats.obj_created[type]++;\r\n}\r\nstatic struct binder_transaction_log_entry *binder_transaction_log_add(\r\nstruct binder_transaction_log *log)\r\n{\r\nstruct binder_transaction_log_entry *e;\r\ne = &log->entry[log->next];\r\nmemset(e, 0, sizeof(*e));\r\nlog->next++;\r\nif (log->next == ARRAY_SIZE(log->entry)) {\r\nlog->next = 0;\r\nlog->full = 1;\r\n}\r\nreturn e;\r\n}\r\nint task_get_unused_fd_flags(struct binder_proc *proc, int flags)\r\n{\r\nstruct files_struct *files = proc->files;\r\nint fd, error;\r\nstruct fdtable *fdt;\r\nunsigned long rlim_cur;\r\nunsigned long irqs;\r\nif (files == NULL)\r\nreturn -ESRCH;\r\nerror = -EMFILE;\r\nspin_lock(&files->file_lock);\r\nrepeat:\r\nfdt = files_fdtable(files);\r\nfd = find_next_zero_bit(fdt->open_fds, fdt->max_fds, files->next_fd);\r\nrlim_cur = 0;\r\nif (lock_task_sighand(proc->tsk, &irqs)) {\r\nrlim_cur = proc->tsk->signal->rlim[RLIMIT_NOFILE].rlim_cur;\r\nunlock_task_sighand(proc->tsk, &irqs);\r\n}\r\nif (fd >= rlim_cur)\r\ngoto out;\r\nerror = expand_files(files, fd);\r\nif (error < 0)\r\ngoto out;\r\nif (error) {\r\nerror = -EMFILE;\r\ngoto repeat;\r\n}\r\n__set_open_fd(fd, fdt);\r\nif (flags & O_CLOEXEC)\r\n__set_close_on_exec(fd, fdt);\r\nelse\r\n__clear_close_on_exec(fd, fdt);\r\nfiles->next_fd = fd + 1;\r\n#if 1\r\nif (fdt->fd[fd] != NULL) {\r\nprintk(KERN_WARNING "get_unused_fd: slot %d not NULL!\n", fd);\r\nfdt->fd[fd] = NULL;\r\n}\r\n#endif\r\nerror = fd;\r\nout:\r\nspin_unlock(&files->file_lock);\r\nreturn error;\r\n}\r\nstatic void task_fd_install(\r\nstruct binder_proc *proc, unsigned int fd, struct file *file)\r\n{\r\nstruct files_struct *files = proc->files;\r\nstruct fdtable *fdt;\r\nif (files == NULL)\r\nreturn;\r\nspin_lock(&files->file_lock);\r\nfdt = files_fdtable(files);\r\nBUG_ON(fdt->fd[fd] != NULL);\r\nrcu_assign_pointer(fdt->fd[fd], file);\r\nspin_unlock(&files->file_lock);\r\n}\r\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\r\n{\r\nstruct fdtable *fdt = files_fdtable(files);\r\n__clear_open_fd(fd, fdt);\r\nif (fd < files->next_fd)\r\nfiles->next_fd = fd;\r\n}\r\nstatic long task_close_fd(struct binder_proc *proc, unsigned int fd)\r\n{\r\nstruct file *filp;\r\nstruct files_struct *files = proc->files;\r\nstruct fdtable *fdt;\r\nint retval;\r\nif (files == NULL)\r\nreturn -ESRCH;\r\nspin_lock(&files->file_lock);\r\nfdt = files_fdtable(files);\r\nif (fd >= fdt->max_fds)\r\ngoto out_unlock;\r\nfilp = fdt->fd[fd];\r\nif (!filp)\r\ngoto out_unlock;\r\nrcu_assign_pointer(fdt->fd[fd], NULL);\r\n__clear_close_on_exec(fd, fdt);\r\n__put_unused_fd(files, fd);\r\nspin_unlock(&files->file_lock);\r\nretval = filp_close(filp, files);\r\nif (unlikely(retval == -ERESTARTSYS ||\r\nretval == -ERESTARTNOINTR ||\r\nretval == -ERESTARTNOHAND ||\r\nretval == -ERESTART_RESTARTBLOCK))\r\nretval = -EINTR;\r\nreturn retval;\r\nout_unlock:\r\nspin_unlock(&files->file_lock);\r\nreturn -EBADF;\r\n}\r\nstatic void binder_set_nice(long nice)\r\n{\r\nlong min_nice;\r\nif (can_nice(current, nice)) {\r\nset_user_nice(current, nice);\r\nreturn;\r\n}\r\nmin_nice = 20 - current->signal->rlim[RLIMIT_NICE].rlim_cur;\r\nbinder_debug(BINDER_DEBUG_PRIORITY_CAP,\r\n"binder: %d: nice value %ld not allowed use "\r\n"%ld instead\n", current->pid, nice, min_nice);\r\nset_user_nice(current, min_nice);\r\nif (min_nice < 20)\r\nreturn;\r\nbinder_user_error("binder: %d RLIMIT_NICE not set\n", current->pid);\r\n}\r\nstatic size_t binder_buffer_size(struct binder_proc *proc,\r\nstruct binder_buffer *buffer)\r\n{\r\nif (list_is_last(&buffer->entry, &proc->buffers))\r\nreturn proc->buffer + proc->buffer_size - (void *)buffer->data;\r\nelse\r\nreturn (size_t)list_entry(buffer->entry.next,\r\nstruct binder_buffer, entry) - (size_t)buffer->data;\r\n}\r\nstatic void binder_insert_free_buffer(struct binder_proc *proc,\r\nstruct binder_buffer *new_buffer)\r\n{\r\nstruct rb_node **p = &proc->free_buffers.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct binder_buffer *buffer;\r\nsize_t buffer_size;\r\nsize_t new_buffer_size;\r\nBUG_ON(!new_buffer->free);\r\nnew_buffer_size = binder_buffer_size(proc, new_buffer);\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: add free buffer, size %zd, "\r\n"at %p\n", proc->pid, new_buffer_size, new_buffer);\r\nwhile (*p) {\r\nparent = *p;\r\nbuffer = rb_entry(parent, struct binder_buffer, rb_node);\r\nBUG_ON(!buffer->free);\r\nbuffer_size = binder_buffer_size(proc, buffer);\r\nif (new_buffer_size < buffer_size)\r\np = &parent->rb_left;\r\nelse\r\np = &parent->rb_right;\r\n}\r\nrb_link_node(&new_buffer->rb_node, parent, p);\r\nrb_insert_color(&new_buffer->rb_node, &proc->free_buffers);\r\n}\r\nstatic void binder_insert_allocated_buffer(struct binder_proc *proc,\r\nstruct binder_buffer *new_buffer)\r\n{\r\nstruct rb_node **p = &proc->allocated_buffers.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct binder_buffer *buffer;\r\nBUG_ON(new_buffer->free);\r\nwhile (*p) {\r\nparent = *p;\r\nbuffer = rb_entry(parent, struct binder_buffer, rb_node);\r\nBUG_ON(buffer->free);\r\nif (new_buffer < buffer)\r\np = &parent->rb_left;\r\nelse if (new_buffer > buffer)\r\np = &parent->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&new_buffer->rb_node, parent, p);\r\nrb_insert_color(&new_buffer->rb_node, &proc->allocated_buffers);\r\n}\r\nstatic struct binder_buffer *binder_buffer_lookup(struct binder_proc *proc,\r\nvoid __user *user_ptr)\r\n{\r\nstruct rb_node *n = proc->allocated_buffers.rb_node;\r\nstruct binder_buffer *buffer;\r\nstruct binder_buffer *kern_ptr;\r\nkern_ptr = user_ptr - proc->user_buffer_offset\r\n- offsetof(struct binder_buffer, data);\r\nwhile (n) {\r\nbuffer = rb_entry(n, struct binder_buffer, rb_node);\r\nBUG_ON(buffer->free);\r\nif (kern_ptr < buffer)\r\nn = n->rb_left;\r\nelse if (kern_ptr > buffer)\r\nn = n->rb_right;\r\nelse\r\nreturn buffer;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int binder_update_page_range(struct binder_proc *proc, int allocate,\r\nvoid *start, void *end,\r\nstruct vm_area_struct *vma)\r\n{\r\nvoid *page_addr;\r\nunsigned long user_page_addr;\r\nstruct vm_struct tmp_area;\r\nstruct page **page;\r\nstruct mm_struct *mm;\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: %s pages %p-%p\n", proc->pid,\r\nallocate ? "allocate" : "free", start, end);\r\nif (end <= start)\r\nreturn 0;\r\nif (vma)\r\nmm = NULL;\r\nelse\r\nmm = get_task_mm(proc->tsk);\r\nif (mm) {\r\ndown_write(&mm->mmap_sem);\r\nvma = proc->vma;\r\nif (vma && mm != proc->vma_vm_mm) {\r\npr_err("binder: %d: vma mm and task mm mismatch\n",\r\nproc->pid);\r\nvma = NULL;\r\n}\r\n}\r\nif (allocate == 0)\r\ngoto free_range;\r\nif (vma == NULL) {\r\nprintk(KERN_ERR "binder: %d: binder_alloc_buf failed to "\r\n"map pages in userspace, no vma\n", proc->pid);\r\ngoto err_no_vma;\r\n}\r\nfor (page_addr = start; page_addr < end; page_addr += PAGE_SIZE) {\r\nint ret;\r\nstruct page **page_array_ptr;\r\npage = &proc->pages[(page_addr - proc->buffer) / PAGE_SIZE];\r\nBUG_ON(*page);\r\n*page = alloc_page(GFP_KERNEL | __GFP_ZERO);\r\nif (*page == NULL) {\r\nprintk(KERN_ERR "binder: %d: binder_alloc_buf failed "\r\n"for page at %p\n", proc->pid, page_addr);\r\ngoto err_alloc_page_failed;\r\n}\r\ntmp_area.addr = page_addr;\r\ntmp_area.size = PAGE_SIZE + PAGE_SIZE ;\r\npage_array_ptr = page;\r\nret = map_vm_area(&tmp_area, PAGE_KERNEL, &page_array_ptr);\r\nif (ret) {\r\nprintk(KERN_ERR "binder: %d: binder_alloc_buf failed "\r\n"to map page at %p in kernel\n",\r\nproc->pid, page_addr);\r\ngoto err_map_kernel_failed;\r\n}\r\nuser_page_addr =\r\n(uintptr_t)page_addr + proc->user_buffer_offset;\r\nret = vm_insert_page(vma, user_page_addr, page[0]);\r\nif (ret) {\r\nprintk(KERN_ERR "binder: %d: binder_alloc_buf failed "\r\n"to map page at %lx in userspace\n",\r\nproc->pid, user_page_addr);\r\ngoto err_vm_insert_page_failed;\r\n}\r\n}\r\nif (mm) {\r\nup_write(&mm->mmap_sem);\r\nmmput(mm);\r\n}\r\nreturn 0;\r\nfree_range:\r\nfor (page_addr = end - PAGE_SIZE; page_addr >= start;\r\npage_addr -= PAGE_SIZE) {\r\npage = &proc->pages[(page_addr - proc->buffer) / PAGE_SIZE];\r\nif (vma)\r\nzap_page_range(vma, (uintptr_t)page_addr +\r\nproc->user_buffer_offset, PAGE_SIZE, NULL);\r\nerr_vm_insert_page_failed:\r\nunmap_kernel_range((unsigned long)page_addr, PAGE_SIZE);\r\nerr_map_kernel_failed:\r\n__free_page(*page);\r\n*page = NULL;\r\nerr_alloc_page_failed:\r\n;\r\n}\r\nerr_no_vma:\r\nif (mm) {\r\nup_write(&mm->mmap_sem);\r\nmmput(mm);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic struct binder_buffer *binder_alloc_buf(struct binder_proc *proc,\r\nsize_t data_size,\r\nsize_t offsets_size, int is_async)\r\n{\r\nstruct rb_node *n = proc->free_buffers.rb_node;\r\nstruct binder_buffer *buffer;\r\nsize_t buffer_size;\r\nstruct rb_node *best_fit = NULL;\r\nvoid *has_page_addr;\r\nvoid *end_page_addr;\r\nsize_t size;\r\nif (proc->vma == NULL) {\r\nprintk(KERN_ERR "binder: %d: binder_alloc_buf, no vma\n",\r\nproc->pid);\r\nreturn NULL;\r\n}\r\nsize = ALIGN(data_size, sizeof(void *)) +\r\nALIGN(offsets_size, sizeof(void *));\r\nif (size < data_size || size < offsets_size) {\r\nbinder_user_error("binder: %d: got transaction with invalid "\r\n"size %zd-%zd\n", proc->pid, data_size, offsets_size);\r\nreturn NULL;\r\n}\r\nif (is_async &&\r\nproc->free_async_space < size + sizeof(struct binder_buffer)) {\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: binder_alloc_buf size %zd"\r\n"failed, no async space left\n", proc->pid, size);\r\nreturn NULL;\r\n}\r\nwhile (n) {\r\nbuffer = rb_entry(n, struct binder_buffer, rb_node);\r\nBUG_ON(!buffer->free);\r\nbuffer_size = binder_buffer_size(proc, buffer);\r\nif (size < buffer_size) {\r\nbest_fit = n;\r\nn = n->rb_left;\r\n} else if (size > buffer_size)\r\nn = n->rb_right;\r\nelse {\r\nbest_fit = n;\r\nbreak;\r\n}\r\n}\r\nif (best_fit == NULL) {\r\nprintk(KERN_ERR "binder: %d: binder_alloc_buf size %zd failed, "\r\n"no address space\n", proc->pid, size);\r\nreturn NULL;\r\n}\r\nif (n == NULL) {\r\nbuffer = rb_entry(best_fit, struct binder_buffer, rb_node);\r\nbuffer_size = binder_buffer_size(proc, buffer);\r\n}\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: binder_alloc_buf size %zd got buff"\r\n"er %p size %zd\n", proc->pid, size, buffer, buffer_size);\r\nhas_page_addr =\r\n(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK);\r\nif (n == NULL) {\r\nif (size + sizeof(struct binder_buffer) + 4 >= buffer_size)\r\nbuffer_size = size;\r\nelse\r\nbuffer_size = size + sizeof(struct binder_buffer);\r\n}\r\nend_page_addr =\r\n(void *)PAGE_ALIGN((uintptr_t)buffer->data + buffer_size);\r\nif (end_page_addr > has_page_addr)\r\nend_page_addr = has_page_addr;\r\nif (binder_update_page_range(proc, 1,\r\n(void *)PAGE_ALIGN((uintptr_t)buffer->data), end_page_addr, NULL))\r\nreturn NULL;\r\nrb_erase(best_fit, &proc->free_buffers);\r\nbuffer->free = 0;\r\nbinder_insert_allocated_buffer(proc, buffer);\r\nif (buffer_size != size) {\r\nstruct binder_buffer *new_buffer = (void *)buffer->data + size;\r\nlist_add(&new_buffer->entry, &buffer->entry);\r\nnew_buffer->free = 1;\r\nbinder_insert_free_buffer(proc, new_buffer);\r\n}\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: binder_alloc_buf size %zd got "\r\n"%p\n", proc->pid, size, buffer);\r\nbuffer->data_size = data_size;\r\nbuffer->offsets_size = offsets_size;\r\nbuffer->async_transaction = is_async;\r\nif (is_async) {\r\nproc->free_async_space -= size + sizeof(struct binder_buffer);\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,\r\n"binder: %d: binder_alloc_buf size %zd "\r\n"async free %zd\n", proc->pid, size,\r\nproc->free_async_space);\r\n}\r\nreturn buffer;\r\n}\r\nstatic void *buffer_start_page(struct binder_buffer *buffer)\r\n{\r\nreturn (void *)((uintptr_t)buffer & PAGE_MASK);\r\n}\r\nstatic void *buffer_end_page(struct binder_buffer *buffer)\r\n{\r\nreturn (void *)(((uintptr_t)(buffer + 1) - 1) & PAGE_MASK);\r\n}\r\nstatic void binder_delete_free_buffer(struct binder_proc *proc,\r\nstruct binder_buffer *buffer)\r\n{\r\nstruct binder_buffer *prev, *next = NULL;\r\nint free_page_end = 1;\r\nint free_page_start = 1;\r\nBUG_ON(proc->buffers.next == &buffer->entry);\r\nprev = list_entry(buffer->entry.prev, struct binder_buffer, entry);\r\nBUG_ON(!prev->free);\r\nif (buffer_end_page(prev) == buffer_start_page(buffer)) {\r\nfree_page_start = 0;\r\nif (buffer_end_page(prev) == buffer_end_page(buffer))\r\nfree_page_end = 0;\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: merge free, buffer %p "\r\n"share page with %p\n", proc->pid, buffer, prev);\r\n}\r\nif (!list_is_last(&buffer->entry, &proc->buffers)) {\r\nnext = list_entry(buffer->entry.next,\r\nstruct binder_buffer, entry);\r\nif (buffer_start_page(next) == buffer_end_page(buffer)) {\r\nfree_page_end = 0;\r\nif (buffer_start_page(next) ==\r\nbuffer_start_page(buffer))\r\nfree_page_start = 0;\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: merge free, buffer"\r\n" %p share page with %p\n", proc->pid,\r\nbuffer, prev);\r\n}\r\n}\r\nlist_del(&buffer->entry);\r\nif (free_page_start || free_page_end) {\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: merge free, buffer %p do "\r\n"not share page%s%s with with %p or %p\n",\r\nproc->pid, buffer, free_page_start ? "" : " end",\r\nfree_page_end ? "" : " start", prev, next);\r\nbinder_update_page_range(proc, 0, free_page_start ?\r\nbuffer_start_page(buffer) : buffer_end_page(buffer),\r\n(free_page_end ? buffer_end_page(buffer) :\r\nbuffer_start_page(buffer)) + PAGE_SIZE, NULL);\r\n}\r\n}\r\nstatic void binder_free_buf(struct binder_proc *proc,\r\nstruct binder_buffer *buffer)\r\n{\r\nsize_t size, buffer_size;\r\nbuffer_size = binder_buffer_size(proc, buffer);\r\nsize = ALIGN(buffer->data_size, sizeof(void *)) +\r\nALIGN(buffer->offsets_size, sizeof(void *));\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder: %d: binder_free_buf %p size %zd buffer"\r\n"_size %zd\n", proc->pid, buffer, size, buffer_size);\r\nBUG_ON(buffer->free);\r\nBUG_ON(size > buffer_size);\r\nBUG_ON(buffer->transaction != NULL);\r\nBUG_ON((void *)buffer < proc->buffer);\r\nBUG_ON((void *)buffer > proc->buffer + proc->buffer_size);\r\nif (buffer->async_transaction) {\r\nproc->free_async_space += size + sizeof(struct binder_buffer);\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,\r\n"binder: %d: binder_free_buf size %zd "\r\n"async free %zd\n", proc->pid, size,\r\nproc->free_async_space);\r\n}\r\nbinder_update_page_range(proc, 0,\r\n(void *)PAGE_ALIGN((uintptr_t)buffer->data),\r\n(void *)(((uintptr_t)buffer->data + buffer_size) & PAGE_MASK),\r\nNULL);\r\nrb_erase(&buffer->rb_node, &proc->allocated_buffers);\r\nbuffer->free = 1;\r\nif (!list_is_last(&buffer->entry, &proc->buffers)) {\r\nstruct binder_buffer *next = list_entry(buffer->entry.next,\r\nstruct binder_buffer, entry);\r\nif (next->free) {\r\nrb_erase(&next->rb_node, &proc->free_buffers);\r\nbinder_delete_free_buffer(proc, next);\r\n}\r\n}\r\nif (proc->buffers.next != &buffer->entry) {\r\nstruct binder_buffer *prev = list_entry(buffer->entry.prev,\r\nstruct binder_buffer, entry);\r\nif (prev->free) {\r\nbinder_delete_free_buffer(proc, buffer);\r\nrb_erase(&prev->rb_node, &proc->free_buffers);\r\nbuffer = prev;\r\n}\r\n}\r\nbinder_insert_free_buffer(proc, buffer);\r\n}\r\nstatic struct binder_node *binder_get_node(struct binder_proc *proc,\r\nvoid __user *ptr)\r\n{\r\nstruct rb_node *n = proc->nodes.rb_node;\r\nstruct binder_node *node;\r\nwhile (n) {\r\nnode = rb_entry(n, struct binder_node, rb_node);\r\nif (ptr < node->ptr)\r\nn = n->rb_left;\r\nelse if (ptr > node->ptr)\r\nn = n->rb_right;\r\nelse\r\nreturn node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct binder_node *binder_new_node(struct binder_proc *proc,\r\nvoid __user *ptr,\r\nvoid __user *cookie)\r\n{\r\nstruct rb_node **p = &proc->nodes.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct binder_node *node;\r\nwhile (*p) {\r\nparent = *p;\r\nnode = rb_entry(parent, struct binder_node, rb_node);\r\nif (ptr < node->ptr)\r\np = &(*p)->rb_left;\r\nelse if (ptr > node->ptr)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn NULL;\r\n}\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (node == NULL)\r\nreturn NULL;\r\nbinder_stats_created(BINDER_STAT_NODE);\r\nrb_link_node(&node->rb_node, parent, p);\r\nrb_insert_color(&node->rb_node, &proc->nodes);\r\nnode->debug_id = ++binder_last_id;\r\nnode->proc = proc;\r\nnode->ptr = ptr;\r\nnode->cookie = cookie;\r\nnode->work.type = BINDER_WORK_NODE;\r\nINIT_LIST_HEAD(&node->work.entry);\r\nINIT_LIST_HEAD(&node->async_todo);\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: %d:%d node %d u%p c%p created\n",\r\nproc->pid, current->pid, node->debug_id,\r\nnode->ptr, node->cookie);\r\nreturn node;\r\n}\r\nstatic int binder_inc_node(struct binder_node *node, int strong, int internal,\r\nstruct list_head *target_list)\r\n{\r\nif (strong) {\r\nif (internal) {\r\nif (target_list == NULL &&\r\nnode->internal_strong_refs == 0 &&\r\n!(node == binder_context_mgr_node &&\r\nnode->has_strong_ref)) {\r\nprintk(KERN_ERR "binder: invalid inc strong "\r\n"node for %d\n", node->debug_id);\r\nreturn -EINVAL;\r\n}\r\nnode->internal_strong_refs++;\r\n} else\r\nnode->local_strong_refs++;\r\nif (!node->has_strong_ref && target_list) {\r\nlist_del_init(&node->work.entry);\r\nlist_add_tail(&node->work.entry, target_list);\r\n}\r\n} else {\r\nif (!internal)\r\nnode->local_weak_refs++;\r\nif (!node->has_weak_ref && list_empty(&node->work.entry)) {\r\nif (target_list == NULL) {\r\nprintk(KERN_ERR "binder: invalid inc weak node "\r\n"for %d\n", node->debug_id);\r\nreturn -EINVAL;\r\n}\r\nlist_add_tail(&node->work.entry, target_list);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int binder_dec_node(struct binder_node *node, int strong, int internal)\r\n{\r\nif (strong) {\r\nif (internal)\r\nnode->internal_strong_refs--;\r\nelse\r\nnode->local_strong_refs--;\r\nif (node->local_strong_refs || node->internal_strong_refs)\r\nreturn 0;\r\n} else {\r\nif (!internal)\r\nnode->local_weak_refs--;\r\nif (node->local_weak_refs || !hlist_empty(&node->refs))\r\nreturn 0;\r\n}\r\nif (node->proc && (node->has_strong_ref || node->has_weak_ref)) {\r\nif (list_empty(&node->work.entry)) {\r\nlist_add_tail(&node->work.entry, &node->proc->todo);\r\nwake_up_interruptible(&node->proc->wait);\r\n}\r\n} else {\r\nif (hlist_empty(&node->refs) && !node->local_strong_refs &&\r\n!node->local_weak_refs) {\r\nlist_del_init(&node->work.entry);\r\nif (node->proc) {\r\nrb_erase(&node->rb_node, &node->proc->nodes);\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: refless node %d deleted\n",\r\nnode->debug_id);\r\n} else {\r\nhlist_del(&node->dead_node);\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: dead node %d deleted\n",\r\nnode->debug_id);\r\n}\r\nkfree(node);\r\nbinder_stats_deleted(BINDER_STAT_NODE);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct binder_ref *binder_get_ref(struct binder_proc *proc,\r\nuint32_t desc)\r\n{\r\nstruct rb_node *n = proc->refs_by_desc.rb_node;\r\nstruct binder_ref *ref;\r\nwhile (n) {\r\nref = rb_entry(n, struct binder_ref, rb_node_desc);\r\nif (desc < ref->desc)\r\nn = n->rb_left;\r\nelse if (desc > ref->desc)\r\nn = n->rb_right;\r\nelse\r\nreturn ref;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct binder_ref *binder_get_ref_for_node(struct binder_proc *proc,\r\nstruct binder_node *node)\r\n{\r\nstruct rb_node *n;\r\nstruct rb_node **p = &proc->refs_by_node.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct binder_ref *ref, *new_ref;\r\nwhile (*p) {\r\nparent = *p;\r\nref = rb_entry(parent, struct binder_ref, rb_node_node);\r\nif (node < ref->node)\r\np = &(*p)->rb_left;\r\nelse if (node > ref->node)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn ref;\r\n}\r\nnew_ref = kzalloc(sizeof(*ref), GFP_KERNEL);\r\nif (new_ref == NULL)\r\nreturn NULL;\r\nbinder_stats_created(BINDER_STAT_REF);\r\nnew_ref->debug_id = ++binder_last_id;\r\nnew_ref->proc = proc;\r\nnew_ref->node = node;\r\nrb_link_node(&new_ref->rb_node_node, parent, p);\r\nrb_insert_color(&new_ref->rb_node_node, &proc->refs_by_node);\r\nnew_ref->desc = (node == binder_context_mgr_node) ? 0 : 1;\r\nfor (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {\r\nref = rb_entry(n, struct binder_ref, rb_node_desc);\r\nif (ref->desc > new_ref->desc)\r\nbreak;\r\nnew_ref->desc = ref->desc + 1;\r\n}\r\np = &proc->refs_by_desc.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nref = rb_entry(parent, struct binder_ref, rb_node_desc);\r\nif (new_ref->desc < ref->desc)\r\np = &(*p)->rb_left;\r\nelse if (new_ref->desc > ref->desc)\r\np = &(*p)->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&new_ref->rb_node_desc, parent, p);\r\nrb_insert_color(&new_ref->rb_node_desc, &proc->refs_by_desc);\r\nif (node) {\r\nhlist_add_head(&new_ref->node_entry, &node->refs);\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: %d new ref %d desc %d for "\r\n"node %d\n", proc->pid, new_ref->debug_id,\r\nnew_ref->desc, node->debug_id);\r\n} else {\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: %d new ref %d desc %d for "\r\n"dead node\n", proc->pid, new_ref->debug_id,\r\nnew_ref->desc);\r\n}\r\nreturn new_ref;\r\n}\r\nstatic void binder_delete_ref(struct binder_ref *ref)\r\n{\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: %d delete ref %d desc %d for "\r\n"node %d\n", ref->proc->pid, ref->debug_id,\r\nref->desc, ref->node->debug_id);\r\nrb_erase(&ref->rb_node_desc, &ref->proc->refs_by_desc);\r\nrb_erase(&ref->rb_node_node, &ref->proc->refs_by_node);\r\nif (ref->strong)\r\nbinder_dec_node(ref->node, 1, 1);\r\nhlist_del(&ref->node_entry);\r\nbinder_dec_node(ref->node, 0, 1);\r\nif (ref->death) {\r\nbinder_debug(BINDER_DEBUG_DEAD_BINDER,\r\n"binder: %d delete ref %d desc %d "\r\n"has death notification\n", ref->proc->pid,\r\nref->debug_id, ref->desc);\r\nlist_del(&ref->death->work.entry);\r\nkfree(ref->death);\r\nbinder_stats_deleted(BINDER_STAT_DEATH);\r\n}\r\nkfree(ref);\r\nbinder_stats_deleted(BINDER_STAT_REF);\r\n}\r\nstatic int binder_inc_ref(struct binder_ref *ref, int strong,\r\nstruct list_head *target_list)\r\n{\r\nint ret;\r\nif (strong) {\r\nif (ref->strong == 0) {\r\nret = binder_inc_node(ref->node, 1, 1, target_list);\r\nif (ret)\r\nreturn ret;\r\n}\r\nref->strong++;\r\n} else {\r\nif (ref->weak == 0) {\r\nret = binder_inc_node(ref->node, 0, 1, target_list);\r\nif (ret)\r\nreturn ret;\r\n}\r\nref->weak++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int binder_dec_ref(struct binder_ref *ref, int strong)\r\n{\r\nif (strong) {\r\nif (ref->strong == 0) {\r\nbinder_user_error("binder: %d invalid dec strong, "\r\n"ref %d desc %d s %d w %d\n",\r\nref->proc->pid, ref->debug_id,\r\nref->desc, ref->strong, ref->weak);\r\nreturn -EINVAL;\r\n}\r\nref->strong--;\r\nif (ref->strong == 0) {\r\nint ret;\r\nret = binder_dec_node(ref->node, strong, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else {\r\nif (ref->weak == 0) {\r\nbinder_user_error("binder: %d invalid dec weak, "\r\n"ref %d desc %d s %d w %d\n",\r\nref->proc->pid, ref->debug_id,\r\nref->desc, ref->strong, ref->weak);\r\nreturn -EINVAL;\r\n}\r\nref->weak--;\r\n}\r\nif (ref->strong == 0 && ref->weak == 0)\r\nbinder_delete_ref(ref);\r\nreturn 0;\r\n}\r\nstatic void binder_pop_transaction(struct binder_thread *target_thread,\r\nstruct binder_transaction *t)\r\n{\r\nif (target_thread) {\r\nBUG_ON(target_thread->transaction_stack != t);\r\nBUG_ON(target_thread->transaction_stack->from != target_thread);\r\ntarget_thread->transaction_stack =\r\ntarget_thread->transaction_stack->from_parent;\r\nt->from = NULL;\r\n}\r\nt->need_reply = 0;\r\nif (t->buffer)\r\nt->buffer->transaction = NULL;\r\nkfree(t);\r\nbinder_stats_deleted(BINDER_STAT_TRANSACTION);\r\n}\r\nstatic void binder_send_failed_reply(struct binder_transaction *t,\r\nuint32_t error_code)\r\n{\r\nstruct binder_thread *target_thread;\r\nBUG_ON(t->flags & TF_ONE_WAY);\r\nwhile (1) {\r\ntarget_thread = t->from;\r\nif (target_thread) {\r\nif (target_thread->return_error != BR_OK &&\r\ntarget_thread->return_error2 == BR_OK) {\r\ntarget_thread->return_error2 =\r\ntarget_thread->return_error;\r\ntarget_thread->return_error = BR_OK;\r\n}\r\nif (target_thread->return_error == BR_OK) {\r\nbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\r\n"binder: send failed reply for "\r\n"transaction %d to %d:%d\n",\r\nt->debug_id, target_thread->proc->pid,\r\ntarget_thread->pid);\r\nbinder_pop_transaction(target_thread, t);\r\ntarget_thread->return_error = error_code;\r\nwake_up_interruptible(&target_thread->wait);\r\n} else {\r\nprintk(KERN_ERR "binder: reply failed, target "\r\n"thread, %d:%d, has error code %d "\r\n"already\n", target_thread->proc->pid,\r\ntarget_thread->pid,\r\ntarget_thread->return_error);\r\n}\r\nreturn;\r\n} else {\r\nstruct binder_transaction *next = t->from_parent;\r\nbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\r\n"binder: send failed reply "\r\n"for transaction %d, target dead\n",\r\nt->debug_id);\r\nbinder_pop_transaction(target_thread, t);\r\nif (next == NULL) {\r\nbinder_debug(BINDER_DEBUG_DEAD_BINDER,\r\n"binder: reply failed,"\r\n" no target thread at root\n");\r\nreturn;\r\n}\r\nt = next;\r\nbinder_debug(BINDER_DEBUG_DEAD_BINDER,\r\n"binder: reply failed, no target "\r\n"thread -- retry %d\n", t->debug_id);\r\n}\r\n}\r\n}\r\nstatic void binder_transaction_buffer_release(struct binder_proc *proc,\r\nstruct binder_buffer *buffer,\r\nsize_t *failed_at)\r\n{\r\nsize_t *offp, *off_end;\r\nint debug_id = buffer->debug_id;\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n"binder: %d buffer release %d, size %zd-%zd, failed at %p\n",\r\nproc->pid, buffer->debug_id,\r\nbuffer->data_size, buffer->offsets_size, failed_at);\r\nif (buffer->target_node)\r\nbinder_dec_node(buffer->target_node, 1, 0);\r\noffp = (size_t *)(buffer->data + ALIGN(buffer->data_size, sizeof(void *)));\r\nif (failed_at)\r\noff_end = failed_at;\r\nelse\r\noff_end = (void *)offp + buffer->offsets_size;\r\nfor (; offp < off_end; offp++) {\r\nstruct flat_binder_object *fp;\r\nif (*offp > buffer->data_size - sizeof(*fp) ||\r\nbuffer->data_size < sizeof(*fp) ||\r\n!IS_ALIGNED(*offp, sizeof(void *))) {\r\nprintk(KERN_ERR "binder: transaction release %d bad"\r\n"offset %zd, size %zd\n", debug_id,\r\n*offp, buffer->data_size);\r\ncontinue;\r\n}\r\nfp = (struct flat_binder_object *)(buffer->data + *offp);\r\nswitch (fp->type) {\r\ncase BINDER_TYPE_BINDER:\r\ncase BINDER_TYPE_WEAK_BINDER: {\r\nstruct binder_node *node = binder_get_node(proc, fp->binder);\r\nif (node == NULL) {\r\nprintk(KERN_ERR "binder: transaction release %d"\r\n" bad node %p\n", debug_id, fp->binder);\r\nbreak;\r\n}\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" node %d u%p\n",\r\nnode->debug_id, node->ptr);\r\nbinder_dec_node(node, fp->type == BINDER_TYPE_BINDER, 0);\r\n} break;\r\ncase BINDER_TYPE_HANDLE:\r\ncase BINDER_TYPE_WEAK_HANDLE: {\r\nstruct binder_ref *ref = binder_get_ref(proc, fp->handle);\r\nif (ref == NULL) {\r\nprintk(KERN_ERR "binder: transaction release %d"\r\n" bad handle %ld\n", debug_id,\r\nfp->handle);\r\nbreak;\r\n}\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" ref %d desc %d (node %d)\n",\r\nref->debug_id, ref->desc, ref->node->debug_id);\r\nbinder_dec_ref(ref, fp->type == BINDER_TYPE_HANDLE);\r\n} break;\r\ncase BINDER_TYPE_FD:\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" fd %ld\n", fp->handle);\r\nif (failed_at)\r\ntask_close_fd(proc, fp->handle);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "binder: transaction release %d bad "\r\n"object type %lx\n", debug_id, fp->type);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void binder_transaction(struct binder_proc *proc,\r\nstruct binder_thread *thread,\r\nstruct binder_transaction_data *tr, int reply)\r\n{\r\nstruct binder_transaction *t;\r\nstruct binder_work *tcomplete;\r\nsize_t *offp, *off_end;\r\nstruct binder_proc *target_proc;\r\nstruct binder_thread *target_thread = NULL;\r\nstruct binder_node *target_node = NULL;\r\nstruct list_head *target_list;\r\nwait_queue_head_t *target_wait;\r\nstruct binder_transaction *in_reply_to = NULL;\r\nstruct binder_transaction_log_entry *e;\r\nuint32_t return_error;\r\ne = binder_transaction_log_add(&binder_transaction_log);\r\ne->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);\r\ne->from_proc = proc->pid;\r\ne->from_thread = thread->pid;\r\ne->target_handle = tr->target.handle;\r\ne->data_size = tr->data_size;\r\ne->offsets_size = tr->offsets_size;\r\nif (reply) {\r\nin_reply_to = thread->transaction_stack;\r\nif (in_reply_to == NULL) {\r\nbinder_user_error("binder: %d:%d got reply transaction "\r\n"with no transaction stack\n",\r\nproc->pid, thread->pid);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_empty_call_stack;\r\n}\r\nbinder_set_nice(in_reply_to->saved_priority);\r\nif (in_reply_to->to_thread != thread) {\r\nbinder_user_error("binder: %d:%d got reply transaction "\r\n"with bad transaction stack,"\r\n" transaction %d has target %d:%d\n",\r\nproc->pid, thread->pid, in_reply_to->debug_id,\r\nin_reply_to->to_proc ?\r\nin_reply_to->to_proc->pid : 0,\r\nin_reply_to->to_thread ?\r\nin_reply_to->to_thread->pid : 0);\r\nreturn_error = BR_FAILED_REPLY;\r\nin_reply_to = NULL;\r\ngoto err_bad_call_stack;\r\n}\r\nthread->transaction_stack = in_reply_to->to_parent;\r\ntarget_thread = in_reply_to->from;\r\nif (target_thread == NULL) {\r\nreturn_error = BR_DEAD_REPLY;\r\ngoto err_dead_binder;\r\n}\r\nif (target_thread->transaction_stack != in_reply_to) {\r\nbinder_user_error("binder: %d:%d got reply transaction "\r\n"with bad target transaction stack %d, "\r\n"expected %d\n",\r\nproc->pid, thread->pid,\r\ntarget_thread->transaction_stack ?\r\ntarget_thread->transaction_stack->debug_id : 0,\r\nin_reply_to->debug_id);\r\nreturn_error = BR_FAILED_REPLY;\r\nin_reply_to = NULL;\r\ntarget_thread = NULL;\r\ngoto err_dead_binder;\r\n}\r\ntarget_proc = target_thread->proc;\r\n} else {\r\nif (tr->target.handle) {\r\nstruct binder_ref *ref;\r\nref = binder_get_ref(proc, tr->target.handle);\r\nif (ref == NULL) {\r\nbinder_user_error("binder: %d:%d got "\r\n"transaction to invalid handle\n",\r\nproc->pid, thread->pid);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_invalid_target_handle;\r\n}\r\ntarget_node = ref->node;\r\n} else {\r\ntarget_node = binder_context_mgr_node;\r\nif (target_node == NULL) {\r\nreturn_error = BR_DEAD_REPLY;\r\ngoto err_no_context_mgr_node;\r\n}\r\n}\r\ne->to_node = target_node->debug_id;\r\ntarget_proc = target_node->proc;\r\nif (target_proc == NULL) {\r\nreturn_error = BR_DEAD_REPLY;\r\ngoto err_dead_binder;\r\n}\r\nif (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {\r\nstruct binder_transaction *tmp;\r\ntmp = thread->transaction_stack;\r\nif (tmp->to_thread != thread) {\r\nbinder_user_error("binder: %d:%d got new "\r\n"transaction with bad transaction stack"\r\n", transaction %d has target %d:%d\n",\r\nproc->pid, thread->pid, tmp->debug_id,\r\ntmp->to_proc ? tmp->to_proc->pid : 0,\r\ntmp->to_thread ?\r\ntmp->to_thread->pid : 0);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_bad_call_stack;\r\n}\r\nwhile (tmp) {\r\nif (tmp->from && tmp->from->proc == target_proc)\r\ntarget_thread = tmp->from;\r\ntmp = tmp->from_parent;\r\n}\r\n}\r\n}\r\nif (target_thread) {\r\ne->to_thread = target_thread->pid;\r\ntarget_list = &target_thread->todo;\r\ntarget_wait = &target_thread->wait;\r\n} else {\r\ntarget_list = &target_proc->todo;\r\ntarget_wait = &target_proc->wait;\r\n}\r\ne->to_proc = target_proc->pid;\r\nt = kzalloc(sizeof(*t), GFP_KERNEL);\r\nif (t == NULL) {\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_alloc_t_failed;\r\n}\r\nbinder_stats_created(BINDER_STAT_TRANSACTION);\r\ntcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);\r\nif (tcomplete == NULL) {\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_alloc_tcomplete_failed;\r\n}\r\nbinder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);\r\nt->debug_id = ++binder_last_id;\r\ne->debug_id = t->debug_id;\r\nif (reply)\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n"binder: %d:%d BC_REPLY %d -> %d:%d, "\r\n"data %p-%p size %zd-%zd\n",\r\nproc->pid, thread->pid, t->debug_id,\r\ntarget_proc->pid, target_thread->pid,\r\ntr->data.ptr.buffer, tr->data.ptr.offsets,\r\ntr->data_size, tr->offsets_size);\r\nelse\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n"binder: %d:%d BC_TRANSACTION %d -> "\r\n"%d - node %d, data %p-%p size %zd-%zd\n",\r\nproc->pid, thread->pid, t->debug_id,\r\ntarget_proc->pid, target_node->debug_id,\r\ntr->data.ptr.buffer, tr->data.ptr.offsets,\r\ntr->data_size, tr->offsets_size);\r\nif (!reply && !(tr->flags & TF_ONE_WAY))\r\nt->from = thread;\r\nelse\r\nt->from = NULL;\r\nt->sender_euid = proc->tsk->cred->euid;\r\nt->to_proc = target_proc;\r\nt->to_thread = target_thread;\r\nt->code = tr->code;\r\nt->flags = tr->flags;\r\nt->priority = task_nice(current);\r\nt->buffer = binder_alloc_buf(target_proc, tr->data_size,\r\ntr->offsets_size, !reply && (t->flags & TF_ONE_WAY));\r\nif (t->buffer == NULL) {\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_binder_alloc_buf_failed;\r\n}\r\nt->buffer->allow_user_free = 0;\r\nt->buffer->debug_id = t->debug_id;\r\nt->buffer->transaction = t;\r\nt->buffer->target_node = target_node;\r\nif (target_node)\r\nbinder_inc_node(target_node, 1, 0, NULL);\r\noffp = (size_t *)(t->buffer->data + ALIGN(tr->data_size, sizeof(void *)));\r\nif (copy_from_user(t->buffer->data, tr->data.ptr.buffer, tr->data_size)) {\r\nbinder_user_error("binder: %d:%d got transaction with invalid "\r\n"data ptr\n", proc->pid, thread->pid);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_copy_data_failed;\r\n}\r\nif (copy_from_user(offp, tr->data.ptr.offsets, tr->offsets_size)) {\r\nbinder_user_error("binder: %d:%d got transaction with invalid "\r\n"offsets ptr\n", proc->pid, thread->pid);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_copy_data_failed;\r\n}\r\nif (!IS_ALIGNED(tr->offsets_size, sizeof(size_t))) {\r\nbinder_user_error("binder: %d:%d got transaction with "\r\n"invalid offsets size, %zd\n",\r\nproc->pid, thread->pid, tr->offsets_size);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_bad_offset;\r\n}\r\noff_end = (void *)offp + tr->offsets_size;\r\nfor (; offp < off_end; offp++) {\r\nstruct flat_binder_object *fp;\r\nif (*offp > t->buffer->data_size - sizeof(*fp) ||\r\nt->buffer->data_size < sizeof(*fp) ||\r\n!IS_ALIGNED(*offp, sizeof(void *))) {\r\nbinder_user_error("binder: %d:%d got transaction with "\r\n"invalid offset, %zd\n",\r\nproc->pid, thread->pid, *offp);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_bad_offset;\r\n}\r\nfp = (struct flat_binder_object *)(t->buffer->data + *offp);\r\nswitch (fp->type) {\r\ncase BINDER_TYPE_BINDER:\r\ncase BINDER_TYPE_WEAK_BINDER: {\r\nstruct binder_ref *ref;\r\nstruct binder_node *node = binder_get_node(proc, fp->binder);\r\nif (node == NULL) {\r\nnode = binder_new_node(proc, fp->binder, fp->cookie);\r\nif (node == NULL) {\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_binder_new_node_failed;\r\n}\r\nnode->min_priority = fp->flags & FLAT_BINDER_FLAG_PRIORITY_MASK;\r\nnode->accept_fds = !!(fp->flags & FLAT_BINDER_FLAG_ACCEPTS_FDS);\r\n}\r\nif (fp->cookie != node->cookie) {\r\nbinder_user_error("binder: %d:%d sending u%p "\r\n"node %d, cookie mismatch %p != %p\n",\r\nproc->pid, thread->pid,\r\nfp->binder, node->debug_id,\r\nfp->cookie, node->cookie);\r\ngoto err_binder_get_ref_for_node_failed;\r\n}\r\nref = binder_get_ref_for_node(target_proc, node);\r\nif (ref == NULL) {\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_binder_get_ref_for_node_failed;\r\n}\r\nif (fp->type == BINDER_TYPE_BINDER)\r\nfp->type = BINDER_TYPE_HANDLE;\r\nelse\r\nfp->type = BINDER_TYPE_WEAK_HANDLE;\r\nfp->handle = ref->desc;\r\nbinder_inc_ref(ref, fp->type == BINDER_TYPE_HANDLE,\r\n&thread->todo);\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" node %d u%p -> ref %d desc %d\n",\r\nnode->debug_id, node->ptr, ref->debug_id,\r\nref->desc);\r\n} break;\r\ncase BINDER_TYPE_HANDLE:\r\ncase BINDER_TYPE_WEAK_HANDLE: {\r\nstruct binder_ref *ref = binder_get_ref(proc, fp->handle);\r\nif (ref == NULL) {\r\nbinder_user_error("binder: %d:%d got "\r\n"transaction with invalid "\r\n"handle, %ld\n", proc->pid,\r\nthread->pid, fp->handle);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_binder_get_ref_failed;\r\n}\r\nif (ref->node->proc == target_proc) {\r\nif (fp->type == BINDER_TYPE_HANDLE)\r\nfp->type = BINDER_TYPE_BINDER;\r\nelse\r\nfp->type = BINDER_TYPE_WEAK_BINDER;\r\nfp->binder = ref->node->ptr;\r\nfp->cookie = ref->node->cookie;\r\nbinder_inc_node(ref->node, fp->type == BINDER_TYPE_BINDER, 0, NULL);\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" ref %d desc %d -> node %d u%p\n",\r\nref->debug_id, ref->desc, ref->node->debug_id,\r\nref->node->ptr);\r\n} else {\r\nstruct binder_ref *new_ref;\r\nnew_ref = binder_get_ref_for_node(target_proc, ref->node);\r\nif (new_ref == NULL) {\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_binder_get_ref_for_node_failed;\r\n}\r\nfp->handle = new_ref->desc;\r\nbinder_inc_ref(new_ref, fp->type == BINDER_TYPE_HANDLE, NULL);\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" ref %d desc %d -> ref %d desc %d (node %d)\n",\r\nref->debug_id, ref->desc, new_ref->debug_id,\r\nnew_ref->desc, ref->node->debug_id);\r\n}\r\n} break;\r\ncase BINDER_TYPE_FD: {\r\nint target_fd;\r\nstruct file *file;\r\nif (reply) {\r\nif (!(in_reply_to->flags & TF_ACCEPT_FDS)) {\r\nbinder_user_error("binder: %d:%d got reply with fd, %ld, but target does not allow fds\n",\r\nproc->pid, thread->pid, fp->handle);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_fd_not_allowed;\r\n}\r\n} else if (!target_node->accept_fds) {\r\nbinder_user_error("binder: %d:%d got transaction with fd, %ld, but target does not allow fds\n",\r\nproc->pid, thread->pid, fp->handle);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_fd_not_allowed;\r\n}\r\nfile = fget(fp->handle);\r\nif (file == NULL) {\r\nbinder_user_error("binder: %d:%d got transaction with invalid fd, %ld\n",\r\nproc->pid, thread->pid, fp->handle);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_fget_failed;\r\n}\r\ntarget_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);\r\nif (target_fd < 0) {\r\nfput(file);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_get_unused_fd_failed;\r\n}\r\ntask_fd_install(target_proc, target_fd, file);\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n" fd %ld -> %d\n", fp->handle, target_fd);\r\nfp->handle = target_fd;\r\n} break;\r\ndefault:\r\nbinder_user_error("binder: %d:%d got transactio"\r\n"n with invalid object type, %lx\n",\r\nproc->pid, thread->pid, fp->type);\r\nreturn_error = BR_FAILED_REPLY;\r\ngoto err_bad_object_type;\r\n}\r\n}\r\nif (reply) {\r\nBUG_ON(t->buffer->async_transaction != 0);\r\nbinder_pop_transaction(target_thread, in_reply_to);\r\n} else if (!(t->flags & TF_ONE_WAY)) {\r\nBUG_ON(t->buffer->async_transaction != 0);\r\nt->need_reply = 1;\r\nt->from_parent = thread->transaction_stack;\r\nthread->transaction_stack = t;\r\n} else {\r\nBUG_ON(target_node == NULL);\r\nBUG_ON(t->buffer->async_transaction != 1);\r\nif (target_node->has_async_transaction) {\r\ntarget_list = &target_node->async_todo;\r\ntarget_wait = NULL;\r\n} else\r\ntarget_node->has_async_transaction = 1;\r\n}\r\nt->work.type = BINDER_WORK_TRANSACTION;\r\nlist_add_tail(&t->work.entry, target_list);\r\ntcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;\r\nlist_add_tail(&tcomplete->entry, &thread->todo);\r\nif (target_wait)\r\nwake_up_interruptible(target_wait);\r\nreturn;\r\nerr_get_unused_fd_failed:\r\nerr_fget_failed:\r\nerr_fd_not_allowed:\r\nerr_binder_get_ref_for_node_failed:\r\nerr_binder_get_ref_failed:\r\nerr_binder_new_node_failed:\r\nerr_bad_object_type:\r\nerr_bad_offset:\r\nerr_copy_data_failed:\r\nbinder_transaction_buffer_release(target_proc, t->buffer, offp);\r\nt->buffer->transaction = NULL;\r\nbinder_free_buf(target_proc, t->buffer);\r\nerr_binder_alloc_buf_failed:\r\nkfree(tcomplete);\r\nbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\r\nerr_alloc_tcomplete_failed:\r\nkfree(t);\r\nbinder_stats_deleted(BINDER_STAT_TRANSACTION);\r\nerr_alloc_t_failed:\r\nerr_bad_call_stack:\r\nerr_empty_call_stack:\r\nerr_dead_binder:\r\nerr_invalid_target_handle:\r\nerr_no_context_mgr_node:\r\nbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\r\n"binder: %d:%d transaction failed %d, size %zd-%zd\n",\r\nproc->pid, thread->pid, return_error,\r\ntr->data_size, tr->offsets_size);\r\n{\r\nstruct binder_transaction_log_entry *fe;\r\nfe = binder_transaction_log_add(&binder_transaction_log_failed);\r\n*fe = *e;\r\n}\r\nBUG_ON(thread->return_error != BR_OK);\r\nif (in_reply_to) {\r\nthread->return_error = BR_TRANSACTION_COMPLETE;\r\nbinder_send_failed_reply(in_reply_to, return_error);\r\n} else\r\nthread->return_error = return_error;\r\n}\r\nint binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,\r\nvoid __user *buffer, int size, signed long *consumed)\r\n{\r\nuint32_t cmd;\r\nvoid __user *ptr = buffer + *consumed;\r\nvoid __user *end = buffer + size;\r\nwhile (ptr < end && thread->return_error == BR_OK) {\r\nif (get_user(cmd, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (_IOC_NR(cmd) < ARRAY_SIZE(binder_stats.bc)) {\r\nbinder_stats.bc[_IOC_NR(cmd)]++;\r\nproc->stats.bc[_IOC_NR(cmd)]++;\r\nthread->stats.bc[_IOC_NR(cmd)]++;\r\n}\r\nswitch (cmd) {\r\ncase BC_INCREFS:\r\ncase BC_ACQUIRE:\r\ncase BC_RELEASE:\r\ncase BC_DECREFS: {\r\nuint32_t target;\r\nstruct binder_ref *ref;\r\nconst char *debug_string;\r\nif (get_user(target, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (target == 0 && binder_context_mgr_node &&\r\n(cmd == BC_INCREFS || cmd == BC_ACQUIRE)) {\r\nref = binder_get_ref_for_node(proc,\r\nbinder_context_mgr_node);\r\nif (ref->desc != target) {\r\nbinder_user_error("binder: %d:"\r\n"%d tried to acquire "\r\n"reference to desc 0, "\r\n"got %d instead\n",\r\nproc->pid, thread->pid,\r\nref->desc);\r\n}\r\n} else\r\nref = binder_get_ref(proc, target);\r\nif (ref == NULL) {\r\nbinder_user_error("binder: %d:%d refcou"\r\n"nt change on invalid ref %d\n",\r\nproc->pid, thread->pid, target);\r\nbreak;\r\n}\r\nswitch (cmd) {\r\ncase BC_INCREFS:\r\ndebug_string = "IncRefs";\r\nbinder_inc_ref(ref, 0, NULL);\r\nbreak;\r\ncase BC_ACQUIRE:\r\ndebug_string = "Acquire";\r\nbinder_inc_ref(ref, 1, NULL);\r\nbreak;\r\ncase BC_RELEASE:\r\ndebug_string = "Release";\r\nbinder_dec_ref(ref, 1);\r\nbreak;\r\ncase BC_DECREFS:\r\ndefault:\r\ndebug_string = "DecRefs";\r\nbinder_dec_ref(ref, 0);\r\nbreak;\r\n}\r\nbinder_debug(BINDER_DEBUG_USER_REFS,\r\n"binder: %d:%d %s ref %d desc %d s %d w %d for node %d\n",\r\nproc->pid, thread->pid, debug_string, ref->debug_id,\r\nref->desc, ref->strong, ref->weak, ref->node->debug_id);\r\nbreak;\r\n}\r\ncase BC_INCREFS_DONE:\r\ncase BC_ACQUIRE_DONE: {\r\nvoid __user *node_ptr;\r\nvoid *cookie;\r\nstruct binder_node *node;\r\nif (get_user(node_ptr, (void * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nif (get_user(cookie, (void * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nnode = binder_get_node(proc, node_ptr);\r\nif (node == NULL) {\r\nbinder_user_error("binder: %d:%d "\r\n"%s u%p no match\n",\r\nproc->pid, thread->pid,\r\ncmd == BC_INCREFS_DONE ?\r\n"BC_INCREFS_DONE" :\r\n"BC_ACQUIRE_DONE",\r\nnode_ptr);\r\nbreak;\r\n}\r\nif (cookie != node->cookie) {\r\nbinder_user_error("binder: %d:%d %s u%p node %d"\r\n" cookie mismatch %p != %p\n",\r\nproc->pid, thread->pid,\r\ncmd == BC_INCREFS_DONE ?\r\n"BC_INCREFS_DONE" : "BC_ACQUIRE_DONE",\r\nnode_ptr, node->debug_id,\r\ncookie, node->cookie);\r\nbreak;\r\n}\r\nif (cmd == BC_ACQUIRE_DONE) {\r\nif (node->pending_strong_ref == 0) {\r\nbinder_user_error("binder: %d:%d "\r\n"BC_ACQUIRE_DONE node %d has "\r\n"no pending acquire request\n",\r\nproc->pid, thread->pid,\r\nnode->debug_id);\r\nbreak;\r\n}\r\nnode->pending_strong_ref = 0;\r\n} else {\r\nif (node->pending_weak_ref == 0) {\r\nbinder_user_error("binder: %d:%d "\r\n"BC_INCREFS_DONE node %d has "\r\n"no pending increfs request\n",\r\nproc->pid, thread->pid,\r\nnode->debug_id);\r\nbreak;\r\n}\r\nnode->pending_weak_ref = 0;\r\n}\r\nbinder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0);\r\nbinder_debug(BINDER_DEBUG_USER_REFS,\r\n"binder: %d:%d %s node %d ls %d lw %d\n",\r\nproc->pid, thread->pid,\r\ncmd == BC_INCREFS_DONE ? "BC_INCREFS_DONE" : "BC_ACQUIRE_DONE",\r\nnode->debug_id, node->local_strong_refs, node->local_weak_refs);\r\nbreak;\r\n}\r\ncase BC_ATTEMPT_ACQUIRE:\r\nprintk(KERN_ERR "binder: BC_ATTEMPT_ACQUIRE not supported\n");\r\nreturn -EINVAL;\r\ncase BC_ACQUIRE_RESULT:\r\nprintk(KERN_ERR "binder: BC_ACQUIRE_RESULT not supported\n");\r\nreturn -EINVAL;\r\ncase BC_FREE_BUFFER: {\r\nvoid __user *data_ptr;\r\nstruct binder_buffer *buffer;\r\nif (get_user(data_ptr, (void * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nbuffer = binder_buffer_lookup(proc, data_ptr);\r\nif (buffer == NULL) {\r\nbinder_user_error("binder: %d:%d "\r\n"BC_FREE_BUFFER u%p no match\n",\r\nproc->pid, thread->pid, data_ptr);\r\nbreak;\r\n}\r\nif (!buffer->allow_user_free) {\r\nbinder_user_error("binder: %d:%d "\r\n"BC_FREE_BUFFER u%p matched "\r\n"unreturned buffer\n",\r\nproc->pid, thread->pid, data_ptr);\r\nbreak;\r\n}\r\nbinder_debug(BINDER_DEBUG_FREE_BUFFER,\r\n"binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction\n",\r\nproc->pid, thread->pid, data_ptr, buffer->debug_id,\r\nbuffer->transaction ? "active" : "finished");\r\nif (buffer->transaction) {\r\nbuffer->transaction->buffer = NULL;\r\nbuffer->transaction = NULL;\r\n}\r\nif (buffer->async_transaction && buffer->target_node) {\r\nBUG_ON(!buffer->target_node->has_async_transaction);\r\nif (list_empty(&buffer->target_node->async_todo))\r\nbuffer->target_node->has_async_transaction = 0;\r\nelse\r\nlist_move_tail(buffer->target_node->async_todo.next, &thread->todo);\r\n}\r\nbinder_transaction_buffer_release(proc, buffer, NULL);\r\nbinder_free_buf(proc, buffer);\r\nbreak;\r\n}\r\ncase BC_TRANSACTION:\r\ncase BC_REPLY: {\r\nstruct binder_transaction_data tr;\r\nif (copy_from_user(&tr, ptr, sizeof(tr)))\r\nreturn -EFAULT;\r\nptr += sizeof(tr);\r\nbinder_transaction(proc, thread, &tr, cmd == BC_REPLY);\r\nbreak;\r\n}\r\ncase BC_REGISTER_LOOPER:\r\nbinder_debug(BINDER_DEBUG_THREADS,\r\n"binder: %d:%d BC_REGISTER_LOOPER\n",\r\nproc->pid, thread->pid);\r\nif (thread->looper & BINDER_LOOPER_STATE_ENTERED) {\r\nthread->looper |= BINDER_LOOPER_STATE_INVALID;\r\nbinder_user_error("binder: %d:%d ERROR:"\r\n" BC_REGISTER_LOOPER called "\r\n"after BC_ENTER_LOOPER\n",\r\nproc->pid, thread->pid);\r\n} else if (proc->requested_threads == 0) {\r\nthread->looper |= BINDER_LOOPER_STATE_INVALID;\r\nbinder_user_error("binder: %d:%d ERROR:"\r\n" BC_REGISTER_LOOPER called "\r\n"without request\n",\r\nproc->pid, thread->pid);\r\n} else {\r\nproc->requested_threads--;\r\nproc->requested_threads_started++;\r\n}\r\nthread->looper |= BINDER_LOOPER_STATE_REGISTERED;\r\nbreak;\r\ncase BC_ENTER_LOOPER:\r\nbinder_debug(BINDER_DEBUG_THREADS,\r\n"binder: %d:%d BC_ENTER_LOOPER\n",\r\nproc->pid, thread->pid);\r\nif (thread->looper & BINDER_LOOPER_STATE_REGISTERED) {\r\nthread->looper |= BINDER_LOOPER_STATE_INVALID;\r\nbinder_user_error("binder: %d:%d ERROR:"\r\n" BC_ENTER_LOOPER called after "\r\n"BC_REGISTER_LOOPER\n",\r\nproc->pid, thread->pid);\r\n}\r\nthread->looper |= BINDER_LOOPER_STATE_ENTERED;\r\nbreak;\r\ncase BC_EXIT_LOOPER:\r\nbinder_debug(BINDER_DEBUG_THREADS,\r\n"binder: %d:%d BC_EXIT_LOOPER\n",\r\nproc->pid, thread->pid);\r\nthread->looper |= BINDER_LOOPER_STATE_EXITED;\r\nbreak;\r\ncase BC_REQUEST_DEATH_NOTIFICATION:\r\ncase BC_CLEAR_DEATH_NOTIFICATION: {\r\nuint32_t target;\r\nvoid __user *cookie;\r\nstruct binder_ref *ref;\r\nstruct binder_ref_death *death;\r\nif (get_user(target, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (get_user(cookie, (void __user * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nref = binder_get_ref(proc, target);\r\nif (ref == NULL) {\r\nbinder_user_error("binder: %d:%d %s "\r\n"invalid ref %d\n",\r\nproc->pid, thread->pid,\r\ncmd == BC_REQUEST_DEATH_NOTIFICATION ?\r\n"BC_REQUEST_DEATH_NOTIFICATION" :\r\n"BC_CLEAR_DEATH_NOTIFICATION",\r\ntarget);\r\nbreak;\r\n}\r\nbinder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,\r\n"binder: %d:%d %s %p ref %d desc %d s %d w %d for node %d\n",\r\nproc->pid, thread->pid,\r\ncmd == BC_REQUEST_DEATH_NOTIFICATION ?\r\n"BC_REQUEST_DEATH_NOTIFICATION" :\r\n"BC_CLEAR_DEATH_NOTIFICATION",\r\ncookie, ref->debug_id, ref->desc,\r\nref->strong, ref->weak, ref->node->debug_id);\r\nif (cmd == BC_REQUEST_DEATH_NOTIFICATION) {\r\nif (ref->death) {\r\nbinder_user_error("binder: %d:%"\r\n"d BC_REQUEST_DEATH_NOTI"\r\n"FICATION death notific"\r\n"ation already set\n",\r\nproc->pid, thread->pid);\r\nbreak;\r\n}\r\ndeath = kzalloc(sizeof(*death), GFP_KERNEL);\r\nif (death == NULL) {\r\nthread->return_error = BR_ERROR;\r\nbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\r\n"binder: %d:%d "\r\n"BC_REQUEST_DEATH_NOTIFICATION failed\n",\r\nproc->pid, thread->pid);\r\nbreak;\r\n}\r\nbinder_stats_created(BINDER_STAT_DEATH);\r\nINIT_LIST_HEAD(&death->work.entry);\r\ndeath->cookie = cookie;\r\nref->death = death;\r\nif (ref->node->proc == NULL) {\r\nref->death->work.type = BINDER_WORK_DEAD_BINDER;\r\nif (thread->looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {\r\nlist_add_tail(&ref->death->work.entry, &thread->todo);\r\n} else {\r\nlist_add_tail(&ref->death->work.entry, &proc->todo);\r\nwake_up_interruptible(&proc->wait);\r\n}\r\n}\r\n} else {\r\nif (ref->death == NULL) {\r\nbinder_user_error("binder: %d:%"\r\n"d BC_CLEAR_DEATH_NOTIFI"\r\n"CATION death notificat"\r\n"ion not active\n",\r\nproc->pid, thread->pid);\r\nbreak;\r\n}\r\ndeath = ref->death;\r\nif (death->cookie != cookie) {\r\nbinder_user_error("binder: %d:%"\r\n"d BC_CLEAR_DEATH_NOTIFI"\r\n"CATION death notificat"\r\n"ion cookie mismatch "\r\n"%p != %p\n",\r\nproc->pid, thread->pid,\r\ndeath->cookie, cookie);\r\nbreak;\r\n}\r\nref->death = NULL;\r\nif (list_empty(&death->work.entry)) {\r\ndeath->work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;\r\nif (thread->looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {\r\nlist_add_tail(&death->work.entry, &thread->todo);\r\n} else {\r\nlist_add_tail(&death->work.entry, &proc->todo);\r\nwake_up_interruptible(&proc->wait);\r\n}\r\n} else {\r\nBUG_ON(death->work.type != BINDER_WORK_DEAD_BINDER);\r\ndeath->work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;\r\n}\r\n}\r\n} break;\r\ncase BC_DEAD_BINDER_DONE: {\r\nstruct binder_work *w;\r\nvoid __user *cookie;\r\nstruct binder_ref_death *death = NULL;\r\nif (get_user(cookie, (void __user * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nlist_for_each_entry(w, &proc->delivered_death, entry) {\r\nstruct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);\r\nif (tmp_death->cookie == cookie) {\r\ndeath = tmp_death;\r\nbreak;\r\n}\r\n}\r\nbinder_debug(BINDER_DEBUG_DEAD_BINDER,\r\n"binder: %d:%d BC_DEAD_BINDER_DONE %p found %p\n",\r\nproc->pid, thread->pid, cookie, death);\r\nif (death == NULL) {\r\nbinder_user_error("binder: %d:%d BC_DEAD"\r\n"_BINDER_DONE %p not found\n",\r\nproc->pid, thread->pid, cookie);\r\nbreak;\r\n}\r\nlist_del_init(&death->work.entry);\r\nif (death->work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {\r\ndeath->work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;\r\nif (thread->looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {\r\nlist_add_tail(&death->work.entry, &thread->todo);\r\n} else {\r\nlist_add_tail(&death->work.entry, &proc->todo);\r\nwake_up_interruptible(&proc->wait);\r\n}\r\n}\r\n} break;\r\ndefault:\r\nprintk(KERN_ERR "binder: %d:%d unknown command %d\n",\r\nproc->pid, thread->pid, cmd);\r\nreturn -EINVAL;\r\n}\r\n*consumed = ptr - buffer;\r\n}\r\nreturn 0;\r\n}\r\nvoid binder_stat_br(struct binder_proc *proc, struct binder_thread *thread,\r\nuint32_t cmd)\r\n{\r\nif (_IOC_NR(cmd) < ARRAY_SIZE(binder_stats.br)) {\r\nbinder_stats.br[_IOC_NR(cmd)]++;\r\nproc->stats.br[_IOC_NR(cmd)]++;\r\nthread->stats.br[_IOC_NR(cmd)]++;\r\n}\r\n}\r\nstatic int binder_has_proc_work(struct binder_proc *proc,\r\nstruct binder_thread *thread)\r\n{\r\nreturn !list_empty(&proc->todo) ||\r\n(thread->looper & BINDER_LOOPER_STATE_NEED_RETURN);\r\n}\r\nstatic int binder_has_thread_work(struct binder_thread *thread)\r\n{\r\nreturn !list_empty(&thread->todo) || thread->return_error != BR_OK ||\r\n(thread->looper & BINDER_LOOPER_STATE_NEED_RETURN);\r\n}\r\nstatic int binder_thread_read(struct binder_proc *proc,\r\nstruct binder_thread *thread,\r\nvoid __user *buffer, int size,\r\nsigned long *consumed, int non_block)\r\n{\r\nvoid __user *ptr = buffer + *consumed;\r\nvoid __user *end = buffer + size;\r\nint ret = 0;\r\nint wait_for_proc_work;\r\nif (*consumed == 0) {\r\nif (put_user(BR_NOOP, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\n}\r\nretry:\r\nwait_for_proc_work = thread->transaction_stack == NULL &&\r\nlist_empty(&thread->todo);\r\nif (thread->return_error != BR_OK && ptr < end) {\r\nif (thread->return_error2 != BR_OK) {\r\nif (put_user(thread->return_error2, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (ptr == end)\r\ngoto done;\r\nthread->return_error2 = BR_OK;\r\n}\r\nif (put_user(thread->return_error, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nthread->return_error = BR_OK;\r\ngoto done;\r\n}\r\nthread->looper |= BINDER_LOOPER_STATE_WAITING;\r\nif (wait_for_proc_work)\r\nproc->ready_threads++;\r\nmutex_unlock(&binder_lock);\r\nif (wait_for_proc_work) {\r\nif (!(thread->looper & (BINDER_LOOPER_STATE_REGISTERED |\r\nBINDER_LOOPER_STATE_ENTERED))) {\r\nbinder_user_error("binder: %d:%d ERROR: Thread waiting "\r\n"for process work before calling BC_REGISTER_"\r\n"LOOPER or BC_ENTER_LOOPER (state %x)\n",\r\nproc->pid, thread->pid, thread->looper);\r\nwait_event_interruptible(binder_user_error_wait,\r\nbinder_stop_on_user_error < 2);\r\n}\r\nbinder_set_nice(proc->default_priority);\r\nif (non_block) {\r\nif (!binder_has_proc_work(proc, thread))\r\nret = -EAGAIN;\r\n} else\r\nret = wait_event_interruptible_exclusive(proc->wait, binder_has_proc_work(proc, thread));\r\n} else {\r\nif (non_block) {\r\nif (!binder_has_thread_work(thread))\r\nret = -EAGAIN;\r\n} else\r\nret = wait_event_interruptible(thread->wait, binder_has_thread_work(thread));\r\n}\r\nmutex_lock(&binder_lock);\r\nif (wait_for_proc_work)\r\nproc->ready_threads--;\r\nthread->looper &= ~BINDER_LOOPER_STATE_WAITING;\r\nif (ret)\r\nreturn ret;\r\nwhile (1) {\r\nuint32_t cmd;\r\nstruct binder_transaction_data tr;\r\nstruct binder_work *w;\r\nstruct binder_transaction *t = NULL;\r\nif (!list_empty(&thread->todo))\r\nw = list_first_entry(&thread->todo, struct binder_work, entry);\r\nelse if (!list_empty(&proc->todo) && wait_for_proc_work)\r\nw = list_first_entry(&proc->todo, struct binder_work, entry);\r\nelse {\r\nif (ptr - buffer == 4 && !(thread->looper & BINDER_LOOPER_STATE_NEED_RETURN))\r\ngoto retry;\r\nbreak;\r\n}\r\nif (end - ptr < sizeof(tr) + 4)\r\nbreak;\r\nswitch (w->type) {\r\ncase BINDER_WORK_TRANSACTION: {\r\nt = container_of(w, struct binder_transaction, work);\r\n} break;\r\ncase BINDER_WORK_TRANSACTION_COMPLETE: {\r\ncmd = BR_TRANSACTION_COMPLETE;\r\nif (put_user(cmd, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nbinder_stat_br(proc, thread, cmd);\r\nbinder_debug(BINDER_DEBUG_TRANSACTION_COMPLETE,\r\n"binder: %d:%d BR_TRANSACTION_COMPLETE\n",\r\nproc->pid, thread->pid);\r\nlist_del(&w->entry);\r\nkfree(w);\r\nbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\r\n} break;\r\ncase BINDER_WORK_NODE: {\r\nstruct binder_node *node = container_of(w, struct binder_node, work);\r\nuint32_t cmd = BR_NOOP;\r\nconst char *cmd_name;\r\nint strong = node->internal_strong_refs || node->local_strong_refs;\r\nint weak = !hlist_empty(&node->refs) || node->local_weak_refs || strong;\r\nif (weak && !node->has_weak_ref) {\r\ncmd = BR_INCREFS;\r\ncmd_name = "BR_INCREFS";\r\nnode->has_weak_ref = 1;\r\nnode->pending_weak_ref = 1;\r\nnode->local_weak_refs++;\r\n} else if (strong && !node->has_strong_ref) {\r\ncmd = BR_ACQUIRE;\r\ncmd_name = "BR_ACQUIRE";\r\nnode->has_strong_ref = 1;\r\nnode->pending_strong_ref = 1;\r\nnode->local_strong_refs++;\r\n} else if (!strong && node->has_strong_ref) {\r\ncmd = BR_RELEASE;\r\ncmd_name = "BR_RELEASE";\r\nnode->has_strong_ref = 0;\r\n} else if (!weak && node->has_weak_ref) {\r\ncmd = BR_DECREFS;\r\ncmd_name = "BR_DECREFS";\r\nnode->has_weak_ref = 0;\r\n}\r\nif (cmd != BR_NOOP) {\r\nif (put_user(cmd, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (put_user(node->ptr, (void * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nif (put_user(node->cookie, (void * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nbinder_stat_br(proc, thread, cmd);\r\nbinder_debug(BINDER_DEBUG_USER_REFS,\r\n"binder: %d:%d %s %d u%p c%p\n",\r\nproc->pid, thread->pid, cmd_name, node->debug_id, node->ptr, node->cookie);\r\n} else {\r\nlist_del_init(&w->entry);\r\nif (!weak && !strong) {\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: %d:%d node %d u%p c%p deleted\n",\r\nproc->pid, thread->pid, node->debug_id,\r\nnode->ptr, node->cookie);\r\nrb_erase(&node->rb_node, &proc->nodes);\r\nkfree(node);\r\nbinder_stats_deleted(BINDER_STAT_NODE);\r\n} else {\r\nbinder_debug(BINDER_DEBUG_INTERNAL_REFS,\r\n"binder: %d:%d node %d u%p c%p state unchanged\n",\r\nproc->pid, thread->pid, node->debug_id, node->ptr,\r\nnode->cookie);\r\n}\r\n}\r\n} break;\r\ncase BINDER_WORK_DEAD_BINDER:\r\ncase BINDER_WORK_DEAD_BINDER_AND_CLEAR:\r\ncase BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {\r\nstruct binder_ref_death *death;\r\nuint32_t cmd;\r\ndeath = container_of(w, struct binder_ref_death, work);\r\nif (w->type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)\r\ncmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;\r\nelse\r\ncmd = BR_DEAD_BINDER;\r\nif (put_user(cmd, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (put_user(death->cookie, (void * __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(void *);\r\nbinder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,\r\n"binder: %d:%d %s %p\n",\r\nproc->pid, thread->pid,\r\ncmd == BR_DEAD_BINDER ?\r\n"BR_DEAD_BINDER" :\r\n"BR_CLEAR_DEATH_NOTIFICATION_DONE",\r\ndeath->cookie);\r\nif (w->type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {\r\nlist_del(&w->entry);\r\nkfree(death);\r\nbinder_stats_deleted(BINDER_STAT_DEATH);\r\n} else\r\nlist_move(&w->entry, &proc->delivered_death);\r\nif (cmd == BR_DEAD_BINDER)\r\ngoto done;\r\n} break;\r\n}\r\nif (!t)\r\ncontinue;\r\nBUG_ON(t->buffer == NULL);\r\nif (t->buffer->target_node) {\r\nstruct binder_node *target_node = t->buffer->target_node;\r\ntr.target.ptr = target_node->ptr;\r\ntr.cookie = target_node->cookie;\r\nt->saved_priority = task_nice(current);\r\nif (t->priority < target_node->min_priority &&\r\n!(t->flags & TF_ONE_WAY))\r\nbinder_set_nice(t->priority);\r\nelse if (!(t->flags & TF_ONE_WAY) ||\r\nt->saved_priority > target_node->min_priority)\r\nbinder_set_nice(target_node->min_priority);\r\ncmd = BR_TRANSACTION;\r\n} else {\r\ntr.target.ptr = NULL;\r\ntr.cookie = NULL;\r\ncmd = BR_REPLY;\r\n}\r\ntr.code = t->code;\r\ntr.flags = t->flags;\r\ntr.sender_euid = t->sender_euid;\r\nif (t->from) {\r\nstruct task_struct *sender = t->from->proc->tsk;\r\ntr.sender_pid = task_tgid_nr_ns(sender,\r\ncurrent->nsproxy->pid_ns);\r\n} else {\r\ntr.sender_pid = 0;\r\n}\r\ntr.data_size = t->buffer->data_size;\r\ntr.offsets_size = t->buffer->offsets_size;\r\ntr.data.ptr.buffer = (void *)t->buffer->data +\r\nproc->user_buffer_offset;\r\ntr.data.ptr.offsets = tr.data.ptr.buffer +\r\nALIGN(t->buffer->data_size,\r\nsizeof(void *));\r\nif (put_user(cmd, (uint32_t __user *)ptr))\r\nreturn -EFAULT;\r\nptr += sizeof(uint32_t);\r\nif (copy_to_user(ptr, &tr, sizeof(tr)))\r\nreturn -EFAULT;\r\nptr += sizeof(tr);\r\nbinder_stat_br(proc, thread, cmd);\r\nbinder_debug(BINDER_DEBUG_TRANSACTION,\r\n"binder: %d:%d %s %d %d:%d, cmd %d"\r\n"size %zd-%zd ptr %p-%p\n",\r\nproc->pid, thread->pid,\r\n(cmd == BR_TRANSACTION) ? "BR_TRANSACTION" :\r\n"BR_REPLY",\r\nt->debug_id, t->from ? t->from->proc->pid : 0,\r\nt->from ? t->from->pid : 0, cmd,\r\nt->buffer->data_size, t->buffer->offsets_size,\r\ntr.data.ptr.buffer, tr.data.ptr.offsets);\r\nlist_del(&t->work.entry);\r\nt->buffer->allow_user_free = 1;\r\nif (cmd == BR_TRANSACTION && !(t->flags & TF_ONE_WAY)) {\r\nt->to_parent = thread->transaction_stack;\r\nt->to_thread = thread;\r\nthread->transaction_stack = t;\r\n} else {\r\nt->buffer->transaction = NULL;\r\nkfree(t);\r\nbinder_stats_deleted(BINDER_STAT_TRANSACTION);\r\n}\r\nbreak;\r\n}\r\ndone:\r\n*consumed = ptr - buffer;\r\nif (proc->requested_threads + proc->ready_threads == 0 &&\r\nproc->requested_threads_started < proc->max_threads &&\r\n(thread->looper & (BINDER_LOOPER_STATE_REGISTERED |\r\nBINDER_LOOPER_STATE_ENTERED))\r\n) {\r\nproc->requested_threads++;\r\nbinder_debug(BINDER_DEBUG_THREADS,\r\n"binder: %d:%d BR_SPAWN_LOOPER\n",\r\nproc->pid, thread->pid);\r\nif (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void binder_release_work(struct list_head *list)\r\n{\r\nstruct binder_work *w;\r\nwhile (!list_empty(list)) {\r\nw = list_first_entry(list, struct binder_work, entry);\r\nlist_del_init(&w->entry);\r\nswitch (w->type) {\r\ncase BINDER_WORK_TRANSACTION: {\r\nstruct binder_transaction *t;\r\nt = container_of(w, struct binder_transaction, work);\r\nif (t->buffer->target_node && !(t->flags & TF_ONE_WAY))\r\nbinder_send_failed_reply(t, BR_DEAD_REPLY);\r\n} break;\r\ncase BINDER_WORK_TRANSACTION_COMPLETE: {\r\nkfree(w);\r\nbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\r\n} break;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic struct binder_thread *binder_get_thread(struct binder_proc *proc)\r\n{\r\nstruct binder_thread *thread = NULL;\r\nstruct rb_node *parent = NULL;\r\nstruct rb_node **p = &proc->threads.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\nthread = rb_entry(parent, struct binder_thread, rb_node);\r\nif (current->pid < thread->pid)\r\np = &(*p)->rb_left;\r\nelse if (current->pid > thread->pid)\r\np = &(*p)->rb_right;\r\nelse\r\nbreak;\r\n}\r\nif (*p == NULL) {\r\nthread = kzalloc(sizeof(*thread), GFP_KERNEL);\r\nif (thread == NULL)\r\nreturn NULL;\r\nbinder_stats_created(BINDER_STAT_THREAD);\r\nthread->proc = proc;\r\nthread->pid = current->pid;\r\ninit_waitqueue_head(&thread->wait);\r\nINIT_LIST_HEAD(&thread->todo);\r\nrb_link_node(&thread->rb_node, parent, p);\r\nrb_insert_color(&thread->rb_node, &proc->threads);\r\nthread->looper |= BINDER_LOOPER_STATE_NEED_RETURN;\r\nthread->return_error = BR_OK;\r\nthread->return_error2 = BR_OK;\r\n}\r\nreturn thread;\r\n}\r\nstatic int binder_free_thread(struct binder_proc *proc,\r\nstruct binder_thread *thread)\r\n{\r\nstruct binder_transaction *t;\r\nstruct binder_transaction *send_reply = NULL;\r\nint active_transactions = 0;\r\nrb_erase(&thread->rb_node, &proc->threads);\r\nt = thread->transaction_stack;\r\nif (t && t->to_thread == thread)\r\nsend_reply = t;\r\nwhile (t) {\r\nactive_transactions++;\r\nbinder_debug(BINDER_DEBUG_DEAD_TRANSACTION,\r\n"binder: release %d:%d transaction %d "\r\n"%s, still active\n", proc->pid, thread->pid,\r\nt->debug_id,\r\n(t->to_thread == thread) ? "in" : "out");\r\nif (t->to_thread == thread) {\r\nt->to_proc = NULL;\r\nt->to_thread = NULL;\r\nif (t->buffer) {\r\nt->buffer->transaction = NULL;\r\nt->buffer = NULL;\r\n}\r\nt = t->to_parent;\r\n} else if (t->from == thread) {\r\nt->from = NULL;\r\nt = t->from_parent;\r\n} else\r\nBUG();\r\n}\r\nif (send_reply)\r\nbinder_send_failed_reply(send_reply, BR_DEAD_REPLY);\r\nbinder_release_work(&thread->todo);\r\nkfree(thread);\r\nbinder_stats_deleted(BINDER_STAT_THREAD);\r\nreturn active_transactions;\r\n}\r\nstatic unsigned int binder_poll(struct file *filp,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct binder_proc *proc = filp->private_data;\r\nstruct binder_thread *thread = NULL;\r\nint wait_for_proc_work;\r\nmutex_lock(&binder_lock);\r\nthread = binder_get_thread(proc);\r\nwait_for_proc_work = thread->transaction_stack == NULL &&\r\nlist_empty(&thread->todo) && thread->return_error == BR_OK;\r\nmutex_unlock(&binder_lock);\r\nif (wait_for_proc_work) {\r\nif (binder_has_proc_work(proc, thread))\r\nreturn POLLIN;\r\npoll_wait(filp, &proc->wait, wait);\r\nif (binder_has_proc_work(proc, thread))\r\nreturn POLLIN;\r\n} else {\r\nif (binder_has_thread_work(thread))\r\nreturn POLLIN;\r\npoll_wait(filp, &thread->wait, wait);\r\nif (binder_has_thread_work(thread))\r\nreturn POLLIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nstruct binder_proc *proc = filp->private_data;\r\nstruct binder_thread *thread;\r\nunsigned int size = _IOC_SIZE(cmd);\r\nvoid __user *ubuf = (void __user *)arg;\r\nret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error < 2);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&binder_lock);\r\nthread = binder_get_thread(proc);\r\nif (thread == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nswitch (cmd) {\r\ncase BINDER_WRITE_READ: {\r\nstruct binder_write_read bwr;\r\nif (size != sizeof(struct binder_write_read)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (copy_from_user(&bwr, ubuf, sizeof(bwr))) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nbinder_debug(BINDER_DEBUG_READ_WRITE,\r\n"binder: %d:%d write %ld at %08lx, read %ld at %08lx\n",\r\nproc->pid, thread->pid, bwr.write_size, bwr.write_buffer,\r\nbwr.read_size, bwr.read_buffer);\r\nif (bwr.write_size > 0) {\r\nret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &bwr.write_consumed);\r\nif (ret < 0) {\r\nbwr.read_consumed = 0;\r\nif (copy_to_user(ubuf, &bwr, sizeof(bwr)))\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\nif (bwr.read_size > 0) {\r\nret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &bwr.read_consumed, filp->f_flags & O_NONBLOCK);\r\nif (!list_empty(&proc->todo))\r\nwake_up_interruptible(&proc->wait);\r\nif (ret < 0) {\r\nif (copy_to_user(ubuf, &bwr, sizeof(bwr)))\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\nbinder_debug(BINDER_DEBUG_READ_WRITE,\r\n"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n",\r\nproc->pid, thread->pid, bwr.write_consumed, bwr.write_size,\r\nbwr.read_consumed, bwr.read_size);\r\nif (copy_to_user(ubuf, &bwr, sizeof(bwr))) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nbreak;\r\n}\r\ncase BINDER_SET_MAX_THREADS:\r\nif (copy_from_user(&proc->max_threads, ubuf, sizeof(proc->max_threads))) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbreak;\r\ncase BINDER_SET_CONTEXT_MGR:\r\nif (binder_context_mgr_node != NULL) {\r\nprintk(KERN_ERR "binder: BINDER_SET_CONTEXT_MGR already set\n");\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nif (binder_context_mgr_uid != -1) {\r\nif (binder_context_mgr_uid != current->cred->euid) {\r\nprintk(KERN_ERR "binder: BINDER_SET_"\r\n"CONTEXT_MGR bad uid %d != %d\n",\r\ncurrent->cred->euid,\r\nbinder_context_mgr_uid);\r\nret = -EPERM;\r\ngoto err;\r\n}\r\n} else\r\nbinder_context_mgr_uid = current->cred->euid;\r\nbinder_context_mgr_node = binder_new_node(proc, NULL, NULL);\r\nif (binder_context_mgr_node == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nbinder_context_mgr_node->local_weak_refs++;\r\nbinder_context_mgr_node->local_strong_refs++;\r\nbinder_context_mgr_node->has_strong_ref = 1;\r\nbinder_context_mgr_node->has_weak_ref = 1;\r\nbreak;\r\ncase BINDER_THREAD_EXIT:\r\nbinder_debug(BINDER_DEBUG_THREADS, "binder: %d:%d exit\n",\r\nproc->pid, thread->pid);\r\nbinder_free_thread(proc, thread);\r\nthread = NULL;\r\nbreak;\r\ncase BINDER_VERSION:\r\nif (size != sizeof(struct binder_version)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &((struct binder_version *)ubuf)->protocol_version)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = 0;\r\nerr:\r\nif (thread)\r\nthread->looper &= ~BINDER_LOOPER_STATE_NEED_RETURN;\r\nmutex_unlock(&binder_lock);\r\nwait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error < 2);\r\nif (ret && ret != -ERESTARTSYS)\r\nprintk(KERN_INFO "binder: %d:%d ioctl %x %lx returned %d\n", proc->pid, current->pid, cmd, arg, ret);\r\nreturn ret;\r\n}\r\nstatic void binder_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct binder_proc *proc = vma->vm_private_data;\r\nbinder_debug(BINDER_DEBUG_OPEN_CLOSE,\r\n"binder: %d open vm area %lx-%lx (%ld K) vma %lx pagep %lx\n",\r\nproc->pid, vma->vm_start, vma->vm_end,\r\n(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,\r\n(unsigned long)pgprot_val(vma->vm_page_prot));\r\n}\r\nstatic void binder_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct binder_proc *proc = vma->vm_private_data;\r\nbinder_debug(BINDER_DEBUG_OPEN_CLOSE,\r\n"binder: %d close vm area %lx-%lx (%ld K) vma %lx pagep %lx\n",\r\nproc->pid, vma->vm_start, vma->vm_end,\r\n(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,\r\n(unsigned long)pgprot_val(vma->vm_page_prot));\r\nproc->vma = NULL;\r\nproc->vma_vm_mm = NULL;\r\nbinder_defer_work(proc, BINDER_DEFERRED_PUT_FILES);\r\n}\r\nstatic int binder_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nint ret;\r\nstruct vm_struct *area;\r\nstruct binder_proc *proc = filp->private_data;\r\nconst char *failure_string;\r\nstruct binder_buffer *buffer;\r\nif ((vma->vm_end - vma->vm_start) > SZ_4M)\r\nvma->vm_end = vma->vm_start + SZ_4M;\r\nbinder_debug(BINDER_DEBUG_OPEN_CLOSE,\r\n"binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n",\r\nproc->pid, vma->vm_start, vma->vm_end,\r\n(vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags,\r\n(unsigned long)pgprot_val(vma->vm_page_prot));\r\nif (vma->vm_flags & FORBIDDEN_MMAP_FLAGS) {\r\nret = -EPERM;\r\nfailure_string = "bad vm_flags";\r\ngoto err_bad_arg;\r\n}\r\nvma->vm_flags = (vma->vm_flags | VM_DONTCOPY) & ~VM_MAYWRITE;\r\nmutex_lock(&binder_mmap_lock);\r\nif (proc->buffer) {\r\nret = -EBUSY;\r\nfailure_string = "already mapped";\r\ngoto err_already_mapped;\r\n}\r\narea = get_vm_area(vma->vm_end - vma->vm_start, VM_IOREMAP);\r\nif (area == NULL) {\r\nret = -ENOMEM;\r\nfailure_string = "get_vm_area";\r\ngoto err_get_vm_area_failed;\r\n}\r\nproc->buffer = area->addr;\r\nproc->user_buffer_offset = vma->vm_start - (uintptr_t)proc->buffer;\r\nmutex_unlock(&binder_mmap_lock);\r\n#ifdef CONFIG_CPU_CACHE_VIPT\r\nif (cache_is_vipt_aliasing()) {\r\nwhile (CACHE_COLOUR((vma->vm_start ^ (uint32_t)proc->buffer))) {\r\nprintk(KERN_INFO "binder_mmap: %d %lx-%lx maps %p bad alignment\n", proc->pid, vma->vm_start, vma->vm_end, proc->buffer);\r\nvma->vm_start += PAGE_SIZE;\r\n}\r\n}\r\n#endif\r\nproc->pages = kzalloc(sizeof(proc->pages[0]) * ((vma->vm_end - vma->vm_start) / PAGE_SIZE), GFP_KERNEL);\r\nif (proc->pages == NULL) {\r\nret = -ENOMEM;\r\nfailure_string = "alloc page array";\r\ngoto err_alloc_pages_failed;\r\n}\r\nproc->buffer_size = vma->vm_end - vma->vm_start;\r\nvma->vm_ops = &binder_vm_ops;\r\nvma->vm_private_data = proc;\r\nif (binder_update_page_range(proc, 1, proc->buffer, proc->buffer + PAGE_SIZE, vma)) {\r\nret = -ENOMEM;\r\nfailure_string = "alloc small buf";\r\ngoto err_alloc_small_buf_failed;\r\n}\r\nbuffer = proc->buffer;\r\nINIT_LIST_HEAD(&proc->buffers);\r\nlist_add(&buffer->entry, &proc->buffers);\r\nbuffer->free = 1;\r\nbinder_insert_free_buffer(proc, buffer);\r\nproc->free_async_space = proc->buffer_size / 2;\r\nbarrier();\r\nproc->files = get_files_struct(proc->tsk);\r\nproc->vma = vma;\r\nproc->vma_vm_mm = vma->vm_mm;\r\nreturn 0;\r\nerr_alloc_small_buf_failed:\r\nkfree(proc->pages);\r\nproc->pages = NULL;\r\nerr_alloc_pages_failed:\r\nmutex_lock(&binder_mmap_lock);\r\nvfree(proc->buffer);\r\nproc->buffer = NULL;\r\nerr_get_vm_area_failed:\r\nerr_already_mapped:\r\nmutex_unlock(&binder_mmap_lock);\r\nerr_bad_arg:\r\nprintk(KERN_ERR "binder_mmap: %d %lx-%lx %s failed %d\n",\r\nproc->pid, vma->vm_start, vma->vm_end, failure_string, ret);\r\nreturn ret;\r\n}\r\nstatic int binder_open(struct inode *nodp, struct file *filp)\r\n{\r\nstruct binder_proc *proc;\r\nbinder_debug(BINDER_DEBUG_OPEN_CLOSE, "binder_open: %d:%d\n",\r\ncurrent->group_leader->pid, current->pid);\r\nproc = kzalloc(sizeof(*proc), GFP_KERNEL);\r\nif (proc == NULL)\r\nreturn -ENOMEM;\r\nget_task_struct(current);\r\nproc->tsk = current;\r\nINIT_LIST_HEAD(&proc->todo);\r\ninit_waitqueue_head(&proc->wait);\r\nproc->default_priority = task_nice(current);\r\nmutex_lock(&binder_lock);\r\nbinder_stats_created(BINDER_STAT_PROC);\r\nhlist_add_head(&proc->proc_node, &binder_procs);\r\nproc->pid = current->group_leader->pid;\r\nINIT_LIST_HEAD(&proc->delivered_death);\r\nfilp->private_data = proc;\r\nmutex_unlock(&binder_lock);\r\nif (binder_debugfs_dir_entry_proc) {\r\nchar strbuf[11];\r\nsnprintf(strbuf, sizeof(strbuf), "%u", proc->pid);\r\nproc->debugfs_entry = debugfs_create_file(strbuf, S_IRUGO,\r\nbinder_debugfs_dir_entry_proc, proc, &binder_proc_fops);\r\n}\r\nreturn 0;\r\n}\r\nstatic int binder_flush(struct file *filp, fl_owner_t id)\r\n{\r\nstruct binder_proc *proc = filp->private_data;\r\nbinder_defer_work(proc, BINDER_DEFERRED_FLUSH);\r\nreturn 0;\r\n}\r\nstatic void binder_deferred_flush(struct binder_proc *proc)\r\n{\r\nstruct rb_node *n;\r\nint wake_count = 0;\r\nfor (n = rb_first(&proc->threads); n != NULL; n = rb_next(n)) {\r\nstruct binder_thread *thread = rb_entry(n, struct binder_thread, rb_node);\r\nthread->looper |= BINDER_LOOPER_STATE_NEED_RETURN;\r\nif (thread->looper & BINDER_LOOPER_STATE_WAITING) {\r\nwake_up_interruptible(&thread->wait);\r\nwake_count++;\r\n}\r\n}\r\nwake_up_interruptible_all(&proc->wait);\r\nbinder_debug(BINDER_DEBUG_OPEN_CLOSE,\r\n"binder_flush: %d woke %d threads\n", proc->pid,\r\nwake_count);\r\n}\r\nstatic int binder_release(struct inode *nodp, struct file *filp)\r\n{\r\nstruct binder_proc *proc = filp->private_data;\r\ndebugfs_remove(proc->debugfs_entry);\r\nbinder_defer_work(proc, BINDER_DEFERRED_RELEASE);\r\nreturn 0;\r\n}\r\nstatic void binder_deferred_release(struct binder_proc *proc)\r\n{\r\nstruct hlist_node *pos;\r\nstruct binder_transaction *t;\r\nstruct rb_node *n;\r\nint threads, nodes, incoming_refs, outgoing_refs, buffers, active_transactions, page_count;\r\nBUG_ON(proc->vma);\r\nBUG_ON(proc->files);\r\nhlist_del(&proc->proc_node);\r\nif (binder_context_mgr_node && binder_context_mgr_node->proc == proc) {\r\nbinder_debug(BINDER_DEBUG_DEAD_BINDER,\r\n"binder_release: %d context_mgr_node gone\n",\r\nproc->pid);\r\nbinder_context_mgr_node = NULL;\r\n}\r\nthreads = 0;\r\nactive_transactions = 0;\r\nwhile ((n = rb_first(&proc->threads))) {\r\nstruct binder_thread *thread = rb_entry(n, struct binder_thread, rb_node);\r\nthreads++;\r\nactive_transactions += binder_free_thread(proc, thread);\r\n}\r\nnodes = 0;\r\nincoming_refs = 0;\r\nwhile ((n = rb_first(&proc->nodes))) {\r\nstruct binder_node *node = rb_entry(n, struct binder_node, rb_node);\r\nnodes++;\r\nrb_erase(&node->rb_node, &proc->nodes);\r\nlist_del_init(&node->work.entry);\r\nif (hlist_empty(&node->refs)) {\r\nkfree(node);\r\nbinder_stats_deleted(BINDER_STAT_NODE);\r\n} else {\r\nstruct binder_ref *ref;\r\nint death = 0;\r\nnode->proc = NULL;\r\nnode->local_strong_refs = 0;\r\nnode->local_weak_refs = 0;\r\nhlist_add_head(&node->dead_node, &binder_dead_nodes);\r\nhlist_for_each_entry(ref, pos, &node->refs, node_entry) {\r\nincoming_refs++;\r\nif (ref->death) {\r\ndeath++;\r\nif (list_empty(&ref->death->work.entry)) {\r\nref->death->work.type = BINDER_WORK_DEAD_BINDER;\r\nlist_add_tail(&ref->death->work.entry, &ref->proc->todo);\r\nwake_up_interruptible(&ref->proc->wait);\r\n} else\r\nBUG();\r\n}\r\n}\r\nbinder_debug(BINDER_DEBUG_DEAD_BINDER,\r\n"binder: node %d now dead, "\r\n"refs %d, death %d\n", node->debug_id,\r\nincoming_refs, death);\r\n}\r\n}\r\noutgoing_refs = 0;\r\nwhile ((n = rb_first(&proc->refs_by_desc))) {\r\nstruct binder_ref *ref = rb_entry(n, struct binder_ref,\r\nrb_node_desc);\r\noutgoing_refs++;\r\nbinder_delete_ref(ref);\r\n}\r\nbinder_release_work(&proc->todo);\r\nbuffers = 0;\r\nwhile ((n = rb_first(&proc->allocated_buffers))) {\r\nstruct binder_buffer *buffer = rb_entry(n, struct binder_buffer,\r\nrb_node);\r\nt = buffer->transaction;\r\nif (t) {\r\nt->buffer = NULL;\r\nbuffer->transaction = NULL;\r\nprintk(KERN_ERR "binder: release proc %d, "\r\n"transaction %d, not freed\n",\r\nproc->pid, t->debug_id);\r\n}\r\nbinder_free_buf(proc, buffer);\r\nbuffers++;\r\n}\r\nbinder_stats_deleted(BINDER_STAT_PROC);\r\npage_count = 0;\r\nif (proc->pages) {\r\nint i;\r\nfor (i = 0; i < proc->buffer_size / PAGE_SIZE; i++) {\r\nif (proc->pages[i]) {\r\nvoid *page_addr = proc->buffer + i * PAGE_SIZE;\r\nbinder_debug(BINDER_DEBUG_BUFFER_ALLOC,\r\n"binder_release: %d: "\r\n"page %d at %p not freed\n",\r\nproc->pid, i,\r\npage_addr);\r\nunmap_kernel_range((unsigned long)page_addr,\r\nPAGE_SIZE);\r\n__free_page(proc->pages[i]);\r\npage_count++;\r\n}\r\n}\r\nkfree(proc->pages);\r\nvfree(proc->buffer);\r\n}\r\nput_task_struct(proc->tsk);\r\nbinder_debug(BINDER_DEBUG_OPEN_CLOSE,\r\n"binder_release: %d threads %d, nodes %d (ref %d), "\r\n"refs %d, active transactions %d, buffers %d, "\r\n"pages %d\n",\r\nproc->pid, threads, nodes, incoming_refs, outgoing_refs,\r\nactive_transactions, buffers, page_count);\r\nkfree(proc);\r\n}\r\nstatic void binder_deferred_func(struct work_struct *work)\r\n{\r\nstruct binder_proc *proc;\r\nstruct files_struct *files;\r\nint defer;\r\ndo {\r\nmutex_lock(&binder_lock);\r\nmutex_lock(&binder_deferred_lock);\r\nif (!hlist_empty(&binder_deferred_list)) {\r\nproc = hlist_entry(binder_deferred_list.first,\r\nstruct binder_proc, deferred_work_node);\r\nhlist_del_init(&proc->deferred_work_node);\r\ndefer = proc->deferred_work;\r\nproc->deferred_work = 0;\r\n} else {\r\nproc = NULL;\r\ndefer = 0;\r\n}\r\nmutex_unlock(&binder_deferred_lock);\r\nfiles = NULL;\r\nif (defer & BINDER_DEFERRED_PUT_FILES) {\r\nfiles = proc->files;\r\nif (files)\r\nproc->files = NULL;\r\n}\r\nif (defer & BINDER_DEFERRED_FLUSH)\r\nbinder_deferred_flush(proc);\r\nif (defer & BINDER_DEFERRED_RELEASE)\r\nbinder_deferred_release(proc);\r\nmutex_unlock(&binder_lock);\r\nif (files)\r\nput_files_struct(files);\r\n} while (proc);\r\n}\r\nstatic void\r\nbinder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer)\r\n{\r\nmutex_lock(&binder_deferred_lock);\r\nproc->deferred_work |= defer;\r\nif (hlist_unhashed(&proc->deferred_work_node)) {\r\nhlist_add_head(&proc->deferred_work_node,\r\n&binder_deferred_list);\r\nqueue_work(binder_deferred_workqueue, &binder_deferred_work);\r\n}\r\nmutex_unlock(&binder_deferred_lock);\r\n}\r\nstatic void print_binder_transaction(struct seq_file *m, const char *prefix,\r\nstruct binder_transaction *t)\r\n{\r\nseq_printf(m,\r\n"%s %d: %p from %d:%d to %d:%d code %x flags %x pri %ld r%d",\r\nprefix, t->debug_id, t,\r\nt->from ? t->from->proc->pid : 0,\r\nt->from ? t->from->pid : 0,\r\nt->to_proc ? t->to_proc->pid : 0,\r\nt->to_thread ? t->to_thread->pid : 0,\r\nt->code, t->flags, t->priority, t->need_reply);\r\nif (t->buffer == NULL) {\r\nseq_puts(m, " buffer free\n");\r\nreturn;\r\n}\r\nif (t->buffer->target_node)\r\nseq_printf(m, " node %d",\r\nt->buffer->target_node->debug_id);\r\nseq_printf(m, " size %zd:%zd data %p\n",\r\nt->buffer->data_size, t->buffer->offsets_size,\r\nt->buffer->data);\r\n}\r\nstatic void print_binder_buffer(struct seq_file *m, const char *prefix,\r\nstruct binder_buffer *buffer)\r\n{\r\nseq_printf(m, "%s %d: %p size %zd:%zd %s\n",\r\nprefix, buffer->debug_id, buffer->data,\r\nbuffer->data_size, buffer->offsets_size,\r\nbuffer->transaction ? "active" : "delivered");\r\n}\r\nstatic void print_binder_work(struct seq_file *m, const char *prefix,\r\nconst char *transaction_prefix,\r\nstruct binder_work *w)\r\n{\r\nstruct binder_node *node;\r\nstruct binder_transaction *t;\r\nswitch (w->type) {\r\ncase BINDER_WORK_TRANSACTION:\r\nt = container_of(w, struct binder_transaction, work);\r\nprint_binder_transaction(m, transaction_prefix, t);\r\nbreak;\r\ncase BINDER_WORK_TRANSACTION_COMPLETE:\r\nseq_printf(m, "%stransaction complete\n", prefix);\r\nbreak;\r\ncase BINDER_WORK_NODE:\r\nnode = container_of(w, struct binder_node, work);\r\nseq_printf(m, "%snode work %d: u%p c%p\n",\r\nprefix, node->debug_id, node->ptr, node->cookie);\r\nbreak;\r\ncase BINDER_WORK_DEAD_BINDER:\r\nseq_printf(m, "%shas dead binder\n", prefix);\r\nbreak;\r\ncase BINDER_WORK_DEAD_BINDER_AND_CLEAR:\r\nseq_printf(m, "%shas cleared dead binder\n", prefix);\r\nbreak;\r\ncase BINDER_WORK_CLEAR_DEATH_NOTIFICATION:\r\nseq_printf(m, "%shas cleared death notification\n", prefix);\r\nbreak;\r\ndefault:\r\nseq_printf(m, "%sunknown work: type %d\n", prefix, w->type);\r\nbreak;\r\n}\r\n}\r\nstatic void print_binder_thread(struct seq_file *m,\r\nstruct binder_thread *thread,\r\nint print_always)\r\n{\r\nstruct binder_transaction *t;\r\nstruct binder_work *w;\r\nsize_t start_pos = m->count;\r\nsize_t header_pos;\r\nseq_printf(m, " thread %d: l %02x\n", thread->pid, thread->looper);\r\nheader_pos = m->count;\r\nt = thread->transaction_stack;\r\nwhile (t) {\r\nif (t->from == thread) {\r\nprint_binder_transaction(m,\r\n" outgoing transaction", t);\r\nt = t->from_parent;\r\n} else if (t->to_thread == thread) {\r\nprint_binder_transaction(m,\r\n" incoming transaction", t);\r\nt = t->to_parent;\r\n} else {\r\nprint_binder_transaction(m, " bad transaction", t);\r\nt = NULL;\r\n}\r\n}\r\nlist_for_each_entry(w, &thread->todo, entry) {\r\nprint_binder_work(m, " ", " pending transaction", w);\r\n}\r\nif (!print_always && m->count == header_pos)\r\nm->count = start_pos;\r\n}\r\nstatic void print_binder_node(struct seq_file *m, struct binder_node *node)\r\n{\r\nstruct binder_ref *ref;\r\nstruct hlist_node *pos;\r\nstruct binder_work *w;\r\nint count;\r\ncount = 0;\r\nhlist_for_each_entry(ref, pos, &node->refs, node_entry)\r\ncount++;\r\nseq_printf(m, " node %d: u%p c%p hs %d hw %d ls %d lw %d is %d iw %d",\r\nnode->debug_id, node->ptr, node->cookie,\r\nnode->has_strong_ref, node->has_weak_ref,\r\nnode->local_strong_refs, node->local_weak_refs,\r\nnode->internal_strong_refs, count);\r\nif (count) {\r\nseq_puts(m, " proc");\r\nhlist_for_each_entry(ref, pos, &node->refs, node_entry)\r\nseq_printf(m, " %d", ref->proc->pid);\r\n}\r\nseq_puts(m, "\n");\r\nlist_for_each_entry(w, &node->async_todo, entry)\r\nprint_binder_work(m, " ",\r\n" pending async transaction", w);\r\n}\r\nstatic void print_binder_ref(struct seq_file *m, struct binder_ref *ref)\r\n{\r\nseq_printf(m, " ref %d: desc %d %snode %d s %d w %d d %p\n",\r\nref->debug_id, ref->desc, ref->node->proc ? "" : "dead ",\r\nref->node->debug_id, ref->strong, ref->weak, ref->death);\r\n}\r\nstatic void print_binder_proc(struct seq_file *m,\r\nstruct binder_proc *proc, int print_all)\r\n{\r\nstruct binder_work *w;\r\nstruct rb_node *n;\r\nsize_t start_pos = m->count;\r\nsize_t header_pos;\r\nseq_printf(m, "proc %d\n", proc->pid);\r\nheader_pos = m->count;\r\nfor (n = rb_first(&proc->threads); n != NULL; n = rb_next(n))\r\nprint_binder_thread(m, rb_entry(n, struct binder_thread,\r\nrb_node), print_all);\r\nfor (n = rb_first(&proc->nodes); n != NULL; n = rb_next(n)) {\r\nstruct binder_node *node = rb_entry(n, struct binder_node,\r\nrb_node);\r\nif (print_all || node->has_async_transaction)\r\nprint_binder_node(m, node);\r\n}\r\nif (print_all) {\r\nfor (n = rb_first(&proc->refs_by_desc);\r\nn != NULL;\r\nn = rb_next(n))\r\nprint_binder_ref(m, rb_entry(n, struct binder_ref,\r\nrb_node_desc));\r\n}\r\nfor (n = rb_first(&proc->allocated_buffers); n != NULL; n = rb_next(n))\r\nprint_binder_buffer(m, " buffer",\r\nrb_entry(n, struct binder_buffer, rb_node));\r\nlist_for_each_entry(w, &proc->todo, entry)\r\nprint_binder_work(m, " ", " pending transaction", w);\r\nlist_for_each_entry(w, &proc->delivered_death, entry) {\r\nseq_puts(m, " has delivered dead binder\n");\r\nbreak;\r\n}\r\nif (!print_all && m->count == header_pos)\r\nm->count = start_pos;\r\n}\r\nstatic void print_binder_stats(struct seq_file *m, const char *prefix,\r\nstruct binder_stats *stats)\r\n{\r\nint i;\r\nBUILD_BUG_ON(ARRAY_SIZE(stats->bc) !=\r\nARRAY_SIZE(binder_command_strings));\r\nfor (i = 0; i < ARRAY_SIZE(stats->bc); i++) {\r\nif (stats->bc[i])\r\nseq_printf(m, "%s%s: %d\n", prefix,\r\nbinder_command_strings[i], stats->bc[i]);\r\n}\r\nBUILD_BUG_ON(ARRAY_SIZE(stats->br) !=\r\nARRAY_SIZE(binder_return_strings));\r\nfor (i = 0; i < ARRAY_SIZE(stats->br); i++) {\r\nif (stats->br[i])\r\nseq_printf(m, "%s%s: %d\n", prefix,\r\nbinder_return_strings[i], stats->br[i]);\r\n}\r\nBUILD_BUG_ON(ARRAY_SIZE(stats->obj_created) !=\r\nARRAY_SIZE(binder_objstat_strings));\r\nBUILD_BUG_ON(ARRAY_SIZE(stats->obj_created) !=\r\nARRAY_SIZE(stats->obj_deleted));\r\nfor (i = 0; i < ARRAY_SIZE(stats->obj_created); i++) {\r\nif (stats->obj_created[i] || stats->obj_deleted[i])\r\nseq_printf(m, "%s%s: active %d total %d\n", prefix,\r\nbinder_objstat_strings[i],\r\nstats->obj_created[i] - stats->obj_deleted[i],\r\nstats->obj_created[i]);\r\n}\r\n}\r\nstatic void print_binder_proc_stats(struct seq_file *m,\r\nstruct binder_proc *proc)\r\n{\r\nstruct binder_work *w;\r\nstruct rb_node *n;\r\nint count, strong, weak;\r\nseq_printf(m, "proc %d\n", proc->pid);\r\ncount = 0;\r\nfor (n = rb_first(&proc->threads); n != NULL; n = rb_next(n))\r\ncount++;\r\nseq_printf(m, " threads: %d\n", count);\r\nseq_printf(m, " requested threads: %d+%d/%d\n"\r\n" ready threads %d\n"\r\n" free async space %zd\n", proc->requested_threads,\r\nproc->requested_threads_started, proc->max_threads,\r\nproc->ready_threads, proc->free_async_space);\r\ncount = 0;\r\nfor (n = rb_first(&proc->nodes); n != NULL; n = rb_next(n))\r\ncount++;\r\nseq_printf(m, " nodes: %d\n", count);\r\ncount = 0;\r\nstrong = 0;\r\nweak = 0;\r\nfor (n = rb_first(&proc->refs_by_desc); n != NULL; n = rb_next(n)) {\r\nstruct binder_ref *ref = rb_entry(n, struct binder_ref,\r\nrb_node_desc);\r\ncount++;\r\nstrong += ref->strong;\r\nweak += ref->weak;\r\n}\r\nseq_printf(m, " refs: %d s %d w %d\n", count, strong, weak);\r\ncount = 0;\r\nfor (n = rb_first(&proc->allocated_buffers); n != NULL; n = rb_next(n))\r\ncount++;\r\nseq_printf(m, " buffers: %d\n", count);\r\ncount = 0;\r\nlist_for_each_entry(w, &proc->todo, entry) {\r\nswitch (w->type) {\r\ncase BINDER_WORK_TRANSACTION:\r\ncount++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nseq_printf(m, " pending transactions: %d\n", count);\r\nprint_binder_stats(m, " ", &proc->stats);\r\n}\r\nstatic int binder_state_show(struct seq_file *m, void *unused)\r\n{\r\nstruct binder_proc *proc;\r\nstruct hlist_node *pos;\r\nstruct binder_node *node;\r\nint do_lock = !binder_debug_no_lock;\r\nif (do_lock)\r\nmutex_lock(&binder_lock);\r\nseq_puts(m, "binder state:\n");\r\nif (!hlist_empty(&binder_dead_nodes))\r\nseq_puts(m, "dead nodes:\n");\r\nhlist_for_each_entry(node, pos, &binder_dead_nodes, dead_node)\r\nprint_binder_node(m, node);\r\nhlist_for_each_entry(proc, pos, &binder_procs, proc_node)\r\nprint_binder_proc(m, proc, 1);\r\nif (do_lock)\r\nmutex_unlock(&binder_lock);\r\nreturn 0;\r\n}\r\nstatic int binder_stats_show(struct seq_file *m, void *unused)\r\n{\r\nstruct binder_proc *proc;\r\nstruct hlist_node *pos;\r\nint do_lock = !binder_debug_no_lock;\r\nif (do_lock)\r\nmutex_lock(&binder_lock);\r\nseq_puts(m, "binder stats:\n");\r\nprint_binder_stats(m, "", &binder_stats);\r\nhlist_for_each_entry(proc, pos, &binder_procs, proc_node)\r\nprint_binder_proc_stats(m, proc);\r\nif (do_lock)\r\nmutex_unlock(&binder_lock);\r\nreturn 0;\r\n}\r\nstatic int binder_transactions_show(struct seq_file *m, void *unused)\r\n{\r\nstruct binder_proc *proc;\r\nstruct hlist_node *pos;\r\nint do_lock = !binder_debug_no_lock;\r\nif (do_lock)\r\nmutex_lock(&binder_lock);\r\nseq_puts(m, "binder transactions:\n");\r\nhlist_for_each_entry(proc, pos, &binder_procs, proc_node)\r\nprint_binder_proc(m, proc, 0);\r\nif (do_lock)\r\nmutex_unlock(&binder_lock);\r\nreturn 0;\r\n}\r\nstatic int binder_proc_show(struct seq_file *m, void *unused)\r\n{\r\nstruct binder_proc *proc = m->private;\r\nint do_lock = !binder_debug_no_lock;\r\nif (do_lock)\r\nmutex_lock(&binder_lock);\r\nseq_puts(m, "binder proc state:\n");\r\nprint_binder_proc(m, proc, 1);\r\nif (do_lock)\r\nmutex_unlock(&binder_lock);\r\nreturn 0;\r\n}\r\nstatic void print_binder_transaction_log_entry(struct seq_file *m,\r\nstruct binder_transaction_log_entry *e)\r\n{\r\nseq_printf(m,\r\n"%d: %s from %d:%d to %d:%d node %d handle %d size %d:%d\n",\r\ne->debug_id, (e->call_type == 2) ? "reply" :\r\n((e->call_type == 1) ? "async" : "call "), e->from_proc,\r\ne->from_thread, e->to_proc, e->to_thread, e->to_node,\r\ne->target_handle, e->data_size, e->offsets_size);\r\n}\r\nstatic int binder_transaction_log_show(struct seq_file *m, void *unused)\r\n{\r\nstruct binder_transaction_log *log = m->private;\r\nint i;\r\nif (log->full) {\r\nfor (i = log->next; i < ARRAY_SIZE(log->entry); i++)\r\nprint_binder_transaction_log_entry(m, &log->entry[i]);\r\n}\r\nfor (i = 0; i < log->next; i++)\r\nprint_binder_transaction_log_entry(m, &log->entry[i]);\r\nreturn 0;\r\n}\r\nstatic int __init binder_init(void)\r\n{\r\nint ret;\r\nbinder_deferred_workqueue = create_singlethread_workqueue("binder");\r\nif (!binder_deferred_workqueue)\r\nreturn -ENOMEM;\r\nbinder_debugfs_dir_entry_root = debugfs_create_dir("binder", NULL);\r\nif (binder_debugfs_dir_entry_root)\r\nbinder_debugfs_dir_entry_proc = debugfs_create_dir("proc",\r\nbinder_debugfs_dir_entry_root);\r\nret = misc_register(&binder_miscdev);\r\nif (binder_debugfs_dir_entry_root) {\r\ndebugfs_create_file("state",\r\nS_IRUGO,\r\nbinder_debugfs_dir_entry_root,\r\nNULL,\r\n&binder_state_fops);\r\ndebugfs_create_file("stats",\r\nS_IRUGO,\r\nbinder_debugfs_dir_entry_root,\r\nNULL,\r\n&binder_stats_fops);\r\ndebugfs_create_file("transactions",\r\nS_IRUGO,\r\nbinder_debugfs_dir_entry_root,\r\nNULL,\r\n&binder_transactions_fops);\r\ndebugfs_create_file("transaction_log",\r\nS_IRUGO,\r\nbinder_debugfs_dir_entry_root,\r\n&binder_transaction_log,\r\n&binder_transaction_log_fops);\r\ndebugfs_create_file("failed_transaction_log",\r\nS_IRUGO,\r\nbinder_debugfs_dir_entry_root,\r\n&binder_transaction_log_failed,\r\n&binder_transaction_log_fops);\r\n}\r\nreturn ret;\r\n}
