static bool ar9002_hw_is_cal_supported(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nenum ar9002_cal_types cal_type)\r\n{\r\nbool supported = false;\r\nswitch (ah->supp_cals & cal_type) {\r\ncase IQ_MISMATCH_CAL:\r\nif (!IS_CHAN_B(chan))\r\nsupported = true;\r\nbreak;\r\ncase ADC_GAIN_CAL:\r\ncase ADC_DC_CAL:\r\nif (!IS_CHAN_B(chan) &&\r\n!((IS_CHAN_2GHZ(chan) || IS_CHAN_A_FAST_CLOCK(ah, chan)) &&\r\nIS_CHAN_HT20(chan)))\r\nsupported = true;\r\nbreak;\r\n}\r\nreturn supported;\r\n}\r\nstatic void ar9002_hw_setup_calibration(struct ath_hw *ah,\r\nstruct ath9k_cal_list *currCal)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nREG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4(0),\r\nAR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX,\r\ncurrCal->calData->calCountMax);\r\nswitch (currCal->calData->calType) {\r\ncase IQ_MISMATCH_CAL:\r\nREG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_IQ);\r\nath_dbg(common, CALIBRATE,\r\n"starting IQ Mismatch Calibration\n");\r\nbreak;\r\ncase ADC_GAIN_CAL:\r\nREG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_ADC_GAIN);\r\nath_dbg(common, CALIBRATE, "starting ADC Gain Calibration\n");\r\nbreak;\r\ncase ADC_DC_CAL:\r\nREG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_ADC_DC_PER);\r\nath_dbg(common, CALIBRATE, "starting ADC DC Calibration\n");\r\nbreak;\r\n}\r\nREG_SET_BIT(ah, AR_PHY_TIMING_CTRL4(0),\r\nAR_PHY_TIMING_CTRL4_DO_CAL);\r\n}\r\nstatic bool ar9002_hw_per_calibration(struct ath_hw *ah,\r\nstruct ath9k_channel *ichan,\r\nu8 rxchainmask,\r\nstruct ath9k_cal_list *currCal)\r\n{\r\nstruct ath9k_hw_cal_data *caldata = ah->caldata;\r\nbool iscaldone = false;\r\nif (currCal->calState == CAL_RUNNING) {\r\nif (!(REG_READ(ah, AR_PHY_TIMING_CTRL4(0)) &\r\nAR_PHY_TIMING_CTRL4_DO_CAL)) {\r\ncurrCal->calData->calCollect(ah);\r\nah->cal_samples++;\r\nif (ah->cal_samples >=\r\ncurrCal->calData->calNumSamples) {\r\nint i, numChains = 0;\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nif (rxchainmask & (1 << i))\r\nnumChains++;\r\n}\r\ncurrCal->calData->calPostProc(ah, numChains);\r\ncaldata->CalValid |= currCal->calData->calType;\r\ncurrCal->calState = CAL_DONE;\r\niscaldone = true;\r\n} else {\r\nar9002_hw_setup_calibration(ah, currCal);\r\n}\r\n}\r\n} else if (!(caldata->CalValid & currCal->calData->calType)) {\r\nath9k_hw_reset_calibration(ah, currCal);\r\n}\r\nreturn iscaldone;\r\n}\r\nstatic void ar9002_hw_iqcal_collect(struct ath_hw *ah)\r\n{\r\nint i;\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nah->totalPowerMeasI[i] +=\r\nREG_READ(ah, AR_PHY_CAL_MEAS_0(i));\r\nah->totalPowerMeasQ[i] +=\r\nREG_READ(ah, AR_PHY_CAL_MEAS_1(i));\r\nah->totalIqCorrMeas[i] +=\r\n(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_2(i));\r\nath_dbg(ath9k_hw_common(ah), CALIBRATE,\r\n"%d: Chn %d pmi=0x%08x;pmq=0x%08x;iqcm=0x%08x;\n",\r\nah->cal_samples, i, ah->totalPowerMeasI[i],\r\nah->totalPowerMeasQ[i],\r\nah->totalIqCorrMeas[i]);\r\n}\r\n}\r\nstatic void ar9002_hw_adc_gaincal_collect(struct ath_hw *ah)\r\n{\r\nint i;\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nah->totalAdcIOddPhase[i] +=\r\nREG_READ(ah, AR_PHY_CAL_MEAS_0(i));\r\nah->totalAdcIEvenPhase[i] +=\r\nREG_READ(ah, AR_PHY_CAL_MEAS_1(i));\r\nah->totalAdcQOddPhase[i] +=\r\nREG_READ(ah, AR_PHY_CAL_MEAS_2(i));\r\nah->totalAdcQEvenPhase[i] +=\r\nREG_READ(ah, AR_PHY_CAL_MEAS_3(i));\r\nath_dbg(ath9k_hw_common(ah), CALIBRATE,\r\n"%d: Chn %d oddi=0x%08x; eveni=0x%08x; oddq=0x%08x; evenq=0x%08x;\n",\r\nah->cal_samples, i,\r\nah->totalAdcIOddPhase[i],\r\nah->totalAdcIEvenPhase[i],\r\nah->totalAdcQOddPhase[i],\r\nah->totalAdcQEvenPhase[i]);\r\n}\r\n}\r\nstatic void ar9002_hw_adc_dccal_collect(struct ath_hw *ah)\r\n{\r\nint i;\r\nfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\r\nah->totalAdcDcOffsetIOddPhase[i] +=\r\n(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_0(i));\r\nah->totalAdcDcOffsetIEvenPhase[i] +=\r\n(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_1(i));\r\nah->totalAdcDcOffsetQOddPhase[i] +=\r\n(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_2(i));\r\nah->totalAdcDcOffsetQEvenPhase[i] +=\r\n(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_3(i));\r\nath_dbg(ath9k_hw_common(ah), CALIBRATE,\r\n"%d: Chn %d oddi=0x%08x; eveni=0x%08x; oddq=0x%08x; evenq=0x%08x;\n",\r\nah->cal_samples, i,\r\nah->totalAdcDcOffsetIOddPhase[i],\r\nah->totalAdcDcOffsetIEvenPhase[i],\r\nah->totalAdcDcOffsetQOddPhase[i],\r\nah->totalAdcDcOffsetQEvenPhase[i]);\r\n}\r\n}\r\nstatic void ar9002_hw_iqcalibrate(struct ath_hw *ah, u8 numChains)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 powerMeasQ, powerMeasI, iqCorrMeas;\r\nu32 qCoffDenom, iCoffDenom;\r\nint32_t qCoff, iCoff;\r\nint iqCorrNeg, i;\r\nfor (i = 0; i < numChains; i++) {\r\npowerMeasI = ah->totalPowerMeasI[i];\r\npowerMeasQ = ah->totalPowerMeasQ[i];\r\niqCorrMeas = ah->totalIqCorrMeas[i];\r\nath_dbg(common, CALIBRATE,\r\n"Starting IQ Cal and Correction for Chain %d\n",\r\ni);\r\nath_dbg(common, CALIBRATE,\r\n"Original: Chn %d iq_corr_meas = 0x%08x\n",\r\ni, ah->totalIqCorrMeas[i]);\r\niqCorrNeg = 0;\r\nif (iqCorrMeas > 0x80000000) {\r\niqCorrMeas = (0xffffffff - iqCorrMeas) + 1;\r\niqCorrNeg = 1;\r\n}\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_i = 0x%08x\n",\r\ni, powerMeasI);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_q = 0x%08x\n",\r\ni, powerMeasQ);\r\nath_dbg(common, CALIBRATE, "iqCorrNeg is 0x%08x\n", iqCorrNeg);\r\niCoffDenom = (powerMeasI / 2 + powerMeasQ / 2) / 128;\r\nqCoffDenom = powerMeasQ / 64;\r\nif ((powerMeasQ != 0) && (iCoffDenom != 0) &&\r\n(qCoffDenom != 0)) {\r\niCoff = iqCorrMeas / iCoffDenom;\r\nqCoff = powerMeasI / qCoffDenom - 64;\r\nath_dbg(common, CALIBRATE, "Chn %d iCoff = 0x%08x\n",\r\ni, iCoff);\r\nath_dbg(common, CALIBRATE, "Chn %d qCoff = 0x%08x\n",\r\ni, qCoff);\r\niCoff = iCoff & 0x3f;\r\nath_dbg(common, CALIBRATE,\r\n"New: Chn %d iCoff = 0x%08x\n", i, iCoff);\r\nif (iqCorrNeg == 0x0)\r\niCoff = 0x40 - iCoff;\r\nif (qCoff > 15)\r\nqCoff = 15;\r\nelse if (qCoff <= -16)\r\nqCoff = -16;\r\nath_dbg(common, CALIBRATE,\r\n"Chn %d : iCoff = 0x%x qCoff = 0x%x\n",\r\ni, iCoff, qCoff);\r\nREG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4(i),\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF,\r\niCoff);\r\nREG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4(i),\r\nAR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF,\r\nqCoff);\r\nath_dbg(common, CALIBRATE,\r\n"IQ Cal and Correction done for Chain %d\n",\r\ni);\r\n}\r\n}\r\nREG_SET_BIT(ah, AR_PHY_TIMING_CTRL4(0),\r\nAR_PHY_TIMING_CTRL4_IQCORR_ENABLE);\r\n}\r\nstatic void ar9002_hw_adc_gaincal_calibrate(struct ath_hw *ah, u8 numChains)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 iOddMeasOffset, iEvenMeasOffset, qOddMeasOffset, qEvenMeasOffset;\r\nu32 qGainMismatch, iGainMismatch, val, i;\r\nfor (i = 0; i < numChains; i++) {\r\niOddMeasOffset = ah->totalAdcIOddPhase[i];\r\niEvenMeasOffset = ah->totalAdcIEvenPhase[i];\r\nqOddMeasOffset = ah->totalAdcQOddPhase[i];\r\nqEvenMeasOffset = ah->totalAdcQEvenPhase[i];\r\nath_dbg(common, CALIBRATE,\r\n"Starting ADC Gain Cal for Chain %d\n", i);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_odd_i = 0x%08x\n",\r\ni, iOddMeasOffset);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_even_i = 0x%08x\n",\r\ni, iEvenMeasOffset);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_odd_q = 0x%08x\n",\r\ni, qOddMeasOffset);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_even_q = 0x%08x\n",\r\ni, qEvenMeasOffset);\r\nif (iOddMeasOffset != 0 && qEvenMeasOffset != 0) {\r\niGainMismatch =\r\n((iEvenMeasOffset * 32) /\r\niOddMeasOffset) & 0x3f;\r\nqGainMismatch =\r\n((qOddMeasOffset * 32) /\r\nqEvenMeasOffset) & 0x3f;\r\nath_dbg(common, CALIBRATE,\r\n"Chn %d gain_mismatch_i = 0x%08x\n",\r\ni, iGainMismatch);\r\nath_dbg(common, CALIBRATE,\r\n"Chn %d gain_mismatch_q = 0x%08x\n",\r\ni, qGainMismatch);\r\nval = REG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i));\r\nval &= 0xfffff000;\r\nval |= (qGainMismatch) | (iGainMismatch << 6);\r\nREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i), val);\r\nath_dbg(common, CALIBRATE,\r\n"ADC Gain Cal done for Chain %d\n", i);\r\n}\r\n}\r\nREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0),\r\nREG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0)) |\r\nAR_PHY_NEW_ADC_GAIN_CORR_ENABLE);\r\n}\r\nstatic void ar9002_hw_adc_dccal_calibrate(struct ath_hw *ah, u8 numChains)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 iOddMeasOffset, iEvenMeasOffset, val, i;\r\nint32_t qOddMeasOffset, qEvenMeasOffset, qDcMismatch, iDcMismatch;\r\nconst struct ath9k_percal_data *calData =\r\nah->cal_list_curr->calData;\r\nu32 numSamples =\r\n(1 << (calData->calCountMax + 5)) * calData->calNumSamples;\r\nfor (i = 0; i < numChains; i++) {\r\niOddMeasOffset = ah->totalAdcDcOffsetIOddPhase[i];\r\niEvenMeasOffset = ah->totalAdcDcOffsetIEvenPhase[i];\r\nqOddMeasOffset = ah->totalAdcDcOffsetQOddPhase[i];\r\nqEvenMeasOffset = ah->totalAdcDcOffsetQEvenPhase[i];\r\nath_dbg(common, CALIBRATE,\r\n"Starting ADC DC Offset Cal for Chain %d\n", i);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_odd_i = %d\n",\r\ni, iOddMeasOffset);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_even_i = %d\n",\r\ni, iEvenMeasOffset);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_odd_q = %d\n",\r\ni, qOddMeasOffset);\r\nath_dbg(common, CALIBRATE, "Chn %d pwr_meas_even_q = %d\n",\r\ni, qEvenMeasOffset);\r\niDcMismatch = (((iEvenMeasOffset - iOddMeasOffset) * 2) /\r\nnumSamples) & 0x1ff;\r\nqDcMismatch = (((qOddMeasOffset - qEvenMeasOffset) * 2) /\r\nnumSamples) & 0x1ff;\r\nath_dbg(common, CALIBRATE,\r\n"Chn %d dc_offset_mismatch_i = 0x%08x\n",\r\ni, iDcMismatch);\r\nath_dbg(common, CALIBRATE,\r\n"Chn %d dc_offset_mismatch_q = 0x%08x\n",\r\ni, qDcMismatch);\r\nval = REG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i));\r\nval &= 0xc0000fff;\r\nval |= (qDcMismatch << 12) | (iDcMismatch << 21);\r\nREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i), val);\r\nath_dbg(common, CALIBRATE,\r\n"ADC DC Offset Cal done for Chain %d\n", i);\r\n}\r\nREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0),\r\nREG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0)) |\r\nAR_PHY_NEW_ADC_DC_OFFSET_CORR_ENABLE);\r\n}\r\nstatic void ar9287_hw_olc_temp_compensation(struct ath_hw *ah)\r\n{\r\nu32 rddata;\r\nint32_t delta, currPDADC, slope;\r\nrddata = REG_READ(ah, AR_PHY_TX_PWRCTRL4);\r\ncurrPDADC = MS(rddata, AR_PHY_TX_PWRCTRL_PD_AVG_OUT);\r\nif (ah->initPDADC == 0 || currPDADC == 0) {\r\nreturn;\r\n} else {\r\nslope = ah->eep_ops->get_eeprom(ah, EEP_TEMPSENSE_SLOPE);\r\nif (slope == 0) {\r\ndelta = 0;\r\n} else {\r\ndelta = ((currPDADC - ah->initPDADC)*4) / slope;\r\n}\r\nREG_RMW_FIELD(ah, AR_PHY_CH0_TX_PWRCTRL11,\r\nAR_PHY_TX_PWRCTRL_OLPC_TEMP_COMP, delta);\r\nREG_RMW_FIELD(ah, AR_PHY_CH1_TX_PWRCTRL11,\r\nAR_PHY_TX_PWRCTRL_OLPC_TEMP_COMP, delta);\r\n}\r\n}\r\nstatic void ar9280_hw_olc_temp_compensation(struct ath_hw *ah)\r\n{\r\nu32 rddata, i;\r\nint delta, currPDADC, regval;\r\nrddata = REG_READ(ah, AR_PHY_TX_PWRCTRL4);\r\ncurrPDADC = MS(rddata, AR_PHY_TX_PWRCTRL_PD_AVG_OUT);\r\nif (ah->initPDADC == 0 || currPDADC == 0)\r\nreturn;\r\nif (ah->eep_ops->get_eeprom(ah, EEP_DAC_HPWR_5G))\r\ndelta = (currPDADC - ah->initPDADC + 4) / 8;\r\nelse\r\ndelta = (currPDADC - ah->initPDADC + 5) / 10;\r\nif (delta != ah->PDADCdelta) {\r\nah->PDADCdelta = delta;\r\nfor (i = 1; i < AR9280_TX_GAIN_TABLE_SIZE; i++) {\r\nregval = ah->originalGain[i] - delta;\r\nif (regval < 0)\r\nregval = 0;\r\nREG_RMW_FIELD(ah,\r\nAR_PHY_TX_GAIN_TBL1 + i * 4,\r\nAR_PHY_TX_GAIN, regval);\r\n}\r\n}\r\n}\r\nstatic void ar9271_hw_pa_cal(struct ath_hw *ah, bool is_reset)\r\n{\r\nu32 regVal;\r\nunsigned int i;\r\nu32 regList[][2] = {\r\n{ 0x786c, 0 },\r\n{ 0x7854, 0 },\r\n{ 0x7820, 0 },\r\n{ 0x7824, 0 },\r\n{ 0x7868, 0 },\r\n{ 0x783c, 0 },\r\n{ 0x7838, 0 } ,\r\n{ 0x7828, 0 } ,\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(regList); i++)\r\nregList[i][1] = REG_READ(ah, regList[i][0]);\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal &= (~(0x1));\r\nREG_WRITE(ah, 0x7834, regVal);\r\nregVal = REG_READ(ah, 0x9808);\r\nregVal |= (0x1 << 27);\r\nREG_WRITE(ah, 0x9808, regVal);\r\nREG_RMW_FIELD(ah, AR9285_AN_TOP3, AR9285_AN_TOP3_PWDDAC, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDRXTXBB1, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDV2I, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDDACIF, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G2, AR9285_AN_RF2G2_OFFCAL, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PWDDB, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_ENPACAL, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV1, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV2, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPAOUT, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G8, AR9285_AN_RF2G8_PADRVGN2TAB0, 7);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PADRVGN2TAB0, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9271_AN_RF2G3_CCOMP, 0xfff);\r\nREG_WRITE(ah, AR9285_AN_TOP2, 0xca0358a0);\r\nudelay(30);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9271_AN_RF2G6_OFFS, 0);\r\nfor (i = 6; i > 0; i--) {\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal |= (1 << (20 + i));\r\nREG_WRITE(ah, 0x7834, regVal);\r\nudelay(1);\r\nregVal &= (~(0x1 << (20 + i)));\r\nregVal |= (MS(REG_READ(ah, 0x7840), AR9285_AN_RXTXBB1_SPARE9)\r\n<< (20 + i));\r\nREG_WRITE(ah, 0x7834, regVal);\r\n}\r\nregVal = (regVal >> 20) & 0x7f;\r\nif ((!is_reset) && (ah->pacal_info.prev_offset == regVal)) {\r\nif (ah->pacal_info.max_skipcount < MAX_PACAL_SKIPCOUNT)\r\nah->pacal_info.max_skipcount =\r\n2 * ah->pacal_info.max_skipcount;\r\nah->pacal_info.skipcount = ah->pacal_info.max_skipcount;\r\n} else {\r\nah->pacal_info.max_skipcount = 1;\r\nah->pacal_info.skipcount = 0;\r\nah->pacal_info.prev_offset = regVal;\r\n}\r\nENABLE_REGWRITE_BUFFER(ah);\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal |= 0x1;\r\nREG_WRITE(ah, 0x7834, regVal);\r\nregVal = REG_READ(ah, 0x9808);\r\nregVal &= (~(0x1 << 27));\r\nREG_WRITE(ah, 0x9808, regVal);\r\nfor (i = 0; i < ARRAY_SIZE(regList); i++)\r\nREG_WRITE(ah, regList[i][0], regList[i][1]);\r\nREGWRITE_BUFFER_FLUSH(ah);\r\n}\r\nstatic inline void ar9285_hw_pa_cal(struct ath_hw *ah, bool is_reset)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nu32 regVal;\r\nint i, offset, offs_6_1, offs_0;\r\nu32 ccomp_org, reg_field;\r\nu32 regList[][2] = {\r\n{ 0x786c, 0 },\r\n{ 0x7854, 0 },\r\n{ 0x7820, 0 },\r\n{ 0x7824, 0 },\r\n{ 0x7868, 0 },\r\n{ 0x783c, 0 },\r\n{ 0x7838, 0 },\r\n};\r\nath_dbg(common, CALIBRATE, "Running PA Calibration\n");\r\nif (ah->eep_ops->get_eeprom(ah, EEP_TXGAIN_TYPE) ==\r\nAR5416_EEP_TXGAIN_HIGH_POWER)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(regList); i++)\r\nregList[i][1] = REG_READ(ah, regList[i][0]);\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal &= (~(0x1));\r\nREG_WRITE(ah, 0x7834, regVal);\r\nregVal = REG_READ(ah, 0x9808);\r\nregVal |= (0x1 << 27);\r\nREG_WRITE(ah, 0x9808, regVal);\r\nREG_RMW_FIELD(ah, AR9285_AN_TOP3, AR9285_AN_TOP3_PWDDAC, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDRXTXBB1, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDV2I, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDDACIF, 1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G2, AR9285_AN_RF2G2_OFFCAL, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PWDDB, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_ENPACAL, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV1, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV2, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPAOUT, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G8, AR9285_AN_RF2G8_PADRVGN2TAB0, 7);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PADRVGN2TAB0, 0);\r\nccomp_org = MS(REG_READ(ah, AR9285_AN_RF2G6), AR9285_AN_RF2G6_CCOMP);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_CCOMP, 0xf);\r\nREG_WRITE(ah, AR9285_AN_TOP2, 0xca0358a0);\r\nudelay(30);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_OFFS, 0);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, 0);\r\nfor (i = 6; i > 0; i--) {\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal |= (1 << (19 + i));\r\nREG_WRITE(ah, 0x7834, regVal);\r\nudelay(1);\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal &= (~(0x1 << (19 + i)));\r\nreg_field = MS(REG_READ(ah, 0x7840), AR9285_AN_RXTXBB1_SPARE9);\r\nregVal |= (reg_field << (19 + i));\r\nREG_WRITE(ah, 0x7834, regVal);\r\n}\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, 1);\r\nudelay(1);\r\nreg_field = MS(REG_READ(ah, AR9285_AN_RF2G9), AR9285_AN_RXTXBB1_SPARE9);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, reg_field);\r\noffs_6_1 = MS(REG_READ(ah, AR9285_AN_RF2G6), AR9285_AN_RF2G6_OFFS);\r\noffs_0 = MS(REG_READ(ah, AR9285_AN_RF2G3), AR9285_AN_RF2G3_PDVCCOMP);\r\noffset = (offs_6_1<<1) | offs_0;\r\noffset = offset - 0;\r\noffs_6_1 = offset>>1;\r\noffs_0 = offset & 1;\r\nif ((!is_reset) && (ah->pacal_info.prev_offset == offset)) {\r\nif (ah->pacal_info.max_skipcount < MAX_PACAL_SKIPCOUNT)\r\nah->pacal_info.max_skipcount =\r\n2 * ah->pacal_info.max_skipcount;\r\nah->pacal_info.skipcount = ah->pacal_info.max_skipcount;\r\n} else {\r\nah->pacal_info.max_skipcount = 1;\r\nah->pacal_info.skipcount = 0;\r\nah->pacal_info.prev_offset = offset;\r\n}\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_OFFS, offs_6_1);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, offs_0);\r\nregVal = REG_READ(ah, 0x7834);\r\nregVal |= 0x1;\r\nREG_WRITE(ah, 0x7834, regVal);\r\nregVal = REG_READ(ah, 0x9808);\r\nregVal &= (~(0x1 << 27));\r\nREG_WRITE(ah, 0x9808, regVal);\r\nfor (i = 0; i < ARRAY_SIZE(regList); i++)\r\nREG_WRITE(ah, regList[i][0], regList[i][1]);\r\nREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_CCOMP, ccomp_org);\r\n}\r\nstatic void ar9002_hw_pa_cal(struct ath_hw *ah, bool is_reset)\r\n{\r\nif (AR_SREV_9271(ah)) {\r\nif (is_reset || !ah->pacal_info.skipcount)\r\nar9271_hw_pa_cal(ah, is_reset);\r\nelse\r\nah->pacal_info.skipcount--;\r\n} else if (AR_SREV_9285_12_OR_LATER(ah)) {\r\nif (is_reset || !ah->pacal_info.skipcount)\r\nar9285_hw_pa_cal(ah, is_reset);\r\nelse\r\nah->pacal_info.skipcount--;\r\n}\r\n}\r\nstatic void ar9002_hw_olc_temp_compensation(struct ath_hw *ah)\r\n{\r\nif (OLC_FOR_AR9287_10_LATER)\r\nar9287_hw_olc_temp_compensation(ah);\r\nelse if (OLC_FOR_AR9280_20_LATER)\r\nar9280_hw_olc_temp_compensation(ah);\r\n}\r\nstatic bool ar9002_hw_calibrate(struct ath_hw *ah,\r\nstruct ath9k_channel *chan,\r\nu8 rxchainmask,\r\nbool longcal)\r\n{\r\nbool iscaldone = true;\r\nstruct ath9k_cal_list *currCal = ah->cal_list_curr;\r\nbool nfcal, nfcal_pending = false;\r\nnfcal = !!(REG_READ(ah, AR_PHY_AGC_CONTROL) & AR_PHY_AGC_CONTROL_NF);\r\nif (ah->caldata)\r\nnfcal_pending = ah->caldata->nfcal_pending;\r\nif (currCal && !nfcal &&\r\n(currCal->calState == CAL_RUNNING ||\r\ncurrCal->calState == CAL_WAITING)) {\r\niscaldone = ar9002_hw_per_calibration(ah, chan,\r\nrxchainmask, currCal);\r\nif (iscaldone) {\r\nah->cal_list_curr = currCal = currCal->calNext;\r\nif (currCal->calState == CAL_WAITING) {\r\niscaldone = false;\r\nath9k_hw_reset_calibration(ah, currCal);\r\n}\r\n}\r\n}\r\nif (longcal || nfcal_pending) {\r\nif (ath9k_hw_getnf(ah, chan)) {\r\nath9k_hw_loadnf(ah, ah->curchan);\r\n}\r\nif (longcal) {\r\nath9k_hw_start_nfcal(ah, false);\r\nar9002_hw_pa_cal(ah, false);\r\nar9002_hw_olc_temp_compensation(ah);\r\n}\r\n}\r\nreturn iscaldone;\r\n}\r\nstatic bool ar9285_hw_cl_cal(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nREG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);\r\nif (IS_CHAN_HT20(chan)) {\r\nREG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_PARALLEL_CAL_ENABLE);\r\nREG_SET_BIT(ah, AR_PHY_TURBO, AR_PHY_FC_DYN2040_EN);\r\nREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_FLTR_CAL);\r\nREG_CLR_BIT(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_CAL_ENABLE);\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_CAL);\r\nif (!ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_CAL, 0, AH_WAIT_TIMEOUT)) {\r\nath_dbg(common, CALIBRATE,\r\n"offset calibration failed to complete in 1ms; noisy environment?\n");\r\nreturn false;\r\n}\r\nREG_CLR_BIT(ah, AR_PHY_TURBO, AR_PHY_FC_DYN2040_EN);\r\nREG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_PARALLEL_CAL_ENABLE);\r\nREG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);\r\n}\r\nREG_CLR_BIT(ah, AR_PHY_ADC_CTL, AR_PHY_ADC_CTL_OFF_PWDADC);\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_FLTR_CAL);\r\nREG_SET_BIT(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_CAL_ENABLE);\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_CAL);\r\nif (!ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_CAL,\r\n0, AH_WAIT_TIMEOUT)) {\r\nath_dbg(common, CALIBRATE,\r\n"offset calibration failed to complete in 1ms; noisy environment?\n");\r\nreturn false;\r\n}\r\nREG_SET_BIT(ah, AR_PHY_ADC_CTL, AR_PHY_ADC_CTL_OFF_PWDADC);\r\nREG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);\r\nREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_FLTR_CAL);\r\nreturn true;\r\n}\r\nstatic bool ar9285_hw_clc(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nint i;\r\nu_int32_t txgain_max;\r\nu_int32_t clc_gain, gain_mask = 0, clc_num = 0;\r\nu_int32_t reg_clc_I0, reg_clc_Q0;\r\nu_int32_t i0_num = 0;\r\nu_int32_t q0_num = 0;\r\nu_int32_t total_num = 0;\r\nu_int32_t reg_rf2g5_org;\r\nbool retv = true;\r\nif (!(ar9285_hw_cl_cal(ah, chan)))\r\nreturn false;\r\ntxgain_max = MS(REG_READ(ah, AR_PHY_TX_PWRCTRL7),\r\nAR_PHY_TX_PWRCTRL_TX_GAIN_TAB_MAX);\r\nfor (i = 0; i < (txgain_max+1); i++) {\r\nclc_gain = (REG_READ(ah, (AR_PHY_TX_GAIN_TBL1+(i<<2))) &\r\nAR_PHY_TX_GAIN_CLC) >> AR_PHY_TX_GAIN_CLC_S;\r\nif (!(gain_mask & (1 << clc_gain))) {\r\ngain_mask |= (1 << clc_gain);\r\nclc_num++;\r\n}\r\n}\r\nfor (i = 0; i < clc_num; i++) {\r\nreg_clc_I0 = (REG_READ(ah, (AR_PHY_CLC_TBL1 + (i << 2)))\r\n& AR_PHY_CLC_I0) >> AR_PHY_CLC_I0_S;\r\nreg_clc_Q0 = (REG_READ(ah, (AR_PHY_CLC_TBL1 + (i << 2)))\r\n& AR_PHY_CLC_Q0) >> AR_PHY_CLC_Q0_S;\r\nif (reg_clc_I0 == 0)\r\ni0_num++;\r\nif (reg_clc_Q0 == 0)\r\nq0_num++;\r\n}\r\ntotal_num = i0_num + q0_num;\r\nif (total_num > AR9285_CLCAL_REDO_THRESH) {\r\nreg_rf2g5_org = REG_READ(ah, AR9285_RF2G5);\r\nif (AR_SREV_9285E_20(ah)) {\r\nREG_WRITE(ah, AR9285_RF2G5,\r\n(reg_rf2g5_org & AR9285_RF2G5_IC50TX) |\r\nAR9285_RF2G5_IC50TX_XE_SET);\r\n} else {\r\nREG_WRITE(ah, AR9285_RF2G5,\r\n(reg_rf2g5_org & AR9285_RF2G5_IC50TX) |\r\nAR9285_RF2G5_IC50TX_SET);\r\n}\r\nretv = ar9285_hw_cl_cal(ah, chan);\r\nREG_WRITE(ah, AR9285_RF2G5, reg_rf2g5_org);\r\n}\r\nreturn retv;\r\n}\r\nstatic bool ar9002_hw_init_cal(struct ath_hw *ah, struct ath9k_channel *chan)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nif (AR_SREV_9271(ah)) {\r\nif (!ar9285_hw_cl_cal(ah, chan))\r\nreturn false;\r\n} else if (AR_SREV_9285(ah) && AR_SREV_9285_12_OR_LATER(ah)) {\r\nif (!ar9285_hw_clc(ah, chan))\r\nreturn false;\r\n} else {\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nif (!AR_SREV_9287_11_OR_LATER(ah))\r\nREG_CLR_BIT(ah, AR_PHY_ADC_CTL,\r\nAR_PHY_ADC_CTL_OFF_PWDADC);\r\nREG_SET_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_FLTR_CAL);\r\n}\r\nREG_WRITE(ah, AR_PHY_AGC_CONTROL,\r\nREG_READ(ah, AR_PHY_AGC_CONTROL) |\r\nAR_PHY_AGC_CONTROL_CAL);\r\nif (!ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_CAL,\r\n0, AH_WAIT_TIMEOUT)) {\r\nath_dbg(common, CALIBRATE,\r\n"offset calibration failed to complete in 1ms; noisy environment?\n");\r\nreturn false;\r\n}\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nif (!AR_SREV_9287_11_OR_LATER(ah))\r\nREG_SET_BIT(ah, AR_PHY_ADC_CTL,\r\nAR_PHY_ADC_CTL_OFF_PWDADC);\r\nREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL,\r\nAR_PHY_AGC_CONTROL_FLTR_CAL);\r\n}\r\n}\r\nar9002_hw_pa_cal(ah, true);\r\nif (ah->caldata)\r\nah->caldata->nfcal_pending = true;\r\nah->cal_list = ah->cal_list_last = ah->cal_list_curr = NULL;\r\nif (AR_SREV_9100(ah) || AR_SREV_9160_10_OR_LATER(ah)) {\r\nah->supp_cals = IQ_MISMATCH_CAL;\r\nif (AR_SREV_9160_10_OR_LATER(ah))\r\nah->supp_cals |= ADC_GAIN_CAL | ADC_DC_CAL;\r\nif (AR_SREV_9287(ah))\r\nah->supp_cals &= ~ADC_GAIN_CAL;\r\nif (ar9002_hw_is_cal_supported(ah, chan, ADC_GAIN_CAL)) {\r\nINIT_CAL(&ah->adcgain_caldata);\r\nINSERT_CAL(ah, &ah->adcgain_caldata);\r\nath_dbg(common, CALIBRATE,\r\n"enabling ADC Gain Calibration\n");\r\n}\r\nif (ar9002_hw_is_cal_supported(ah, chan, ADC_DC_CAL)) {\r\nINIT_CAL(&ah->adcdc_caldata);\r\nINSERT_CAL(ah, &ah->adcdc_caldata);\r\nath_dbg(common, CALIBRATE,\r\n"enabling ADC DC Calibration\n");\r\n}\r\nif (ar9002_hw_is_cal_supported(ah, chan, IQ_MISMATCH_CAL)) {\r\nINIT_CAL(&ah->iq_caldata);\r\nINSERT_CAL(ah, &ah->iq_caldata);\r\nath_dbg(common, CALIBRATE, "enabling IQ Calibration\n");\r\n}\r\nah->cal_list_curr = ah->cal_list;\r\nif (ah->cal_list_curr)\r\nath9k_hw_reset_calibration(ah, ah->cal_list_curr);\r\n}\r\nif (ah->caldata)\r\nah->caldata->CalValid = 0;\r\nreturn true;\r\n}\r\nstatic void ar9002_hw_init_cal_settings(struct ath_hw *ah)\r\n{\r\nif (AR_SREV_9100(ah)) {\r\nah->iq_caldata.calData = &iq_cal_multi_sample;\r\nah->supp_cals = IQ_MISMATCH_CAL;\r\nreturn;\r\n}\r\nif (AR_SREV_9160_10_OR_LATER(ah)) {\r\nif (AR_SREV_9280_20_OR_LATER(ah)) {\r\nah->iq_caldata.calData = &iq_cal_single_sample;\r\nah->adcgain_caldata.calData =\r\n&adc_gain_cal_single_sample;\r\nah->adcdc_caldata.calData =\r\n&adc_dc_cal_single_sample;\r\n} else {\r\nah->iq_caldata.calData = &iq_cal_multi_sample;\r\nah->adcgain_caldata.calData =\r\n&adc_gain_cal_multi_sample;\r\nah->adcdc_caldata.calData =\r\n&adc_dc_cal_multi_sample;\r\n}\r\nah->supp_cals = ADC_GAIN_CAL | ADC_DC_CAL | IQ_MISMATCH_CAL;\r\nif (AR_SREV_9287(ah))\r\nah->supp_cals &= ~ADC_GAIN_CAL;\r\n}\r\n}\r\nvoid ar9002_hw_attach_calib_ops(struct ath_hw *ah)\r\n{\r\nstruct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);\r\nstruct ath_hw_ops *ops = ath9k_hw_ops(ah);\r\npriv_ops->init_cal_settings = ar9002_hw_init_cal_settings;\r\npriv_ops->init_cal = ar9002_hw_init_cal;\r\npriv_ops->setup_calibration = ar9002_hw_setup_calibration;\r\nops->calibrate = ar9002_hw_calibrate;\r\n}
