static inline void superio_outb(int sio_cip, int reg, int val)\r\n{\r\noutb(reg, sio_cip);\r\noutb(val, sio_cip + 1);\r\n}\r\nstatic inline int superio_inb(int sio_cip, int reg)\r\n{\r\noutb(reg, sio_cip);\r\nreturn inb(sio_cip + 1);\r\n}\r\nstatic inline void superio_select(int sio_cip, int ldn)\r\n{\r\noutb(SIO_VT1211_LDN, sio_cip);\r\noutb(ldn, sio_cip + 1);\r\n}\r\nstatic inline void superio_enter(int sio_cip)\r\n{\r\noutb(0x87, sio_cip);\r\noutb(0x87, sio_cip);\r\n}\r\nstatic inline void superio_exit(int sio_cip)\r\n{\r\noutb(0xaa, sio_cip);\r\n}\r\nstatic inline u8 vt1211_read8(struct vt1211_data *data, u8 reg)\r\n{\r\nreturn inb(data->addr + reg);\r\n}\r\nstatic inline void vt1211_write8(struct vt1211_data *data, u8 reg, u8 val)\r\n{\r\noutb(val, data->addr + reg);\r\n}\r\nstatic struct vt1211_data *vt1211_update_device(struct device *dev)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nint ix, val;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\ndata->vid = vt1211_read8(data, VT1211_REG_VID) & 0x1f;\r\nfor (ix = 0; ix < ARRAY_SIZE(data->in); ix++) {\r\nif (ISVOLT(ix, data->uch_config)) {\r\ndata->in[ix] = vt1211_read8(data,\r\nVT1211_REG_IN(ix));\r\ndata->in_min[ix] = vt1211_read8(data,\r\nVT1211_REG_IN_MIN(ix));\r\ndata->in_max[ix] = vt1211_read8(data,\r\nVT1211_REG_IN_MAX(ix));\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->temp); ix++) {\r\nif (ISTEMP(ix, data->uch_config)) {\r\ndata->temp[ix] = vt1211_read8(data,\r\nregtemp[ix]);\r\ndata->temp_max[ix] = vt1211_read8(data,\r\nregtempmax[ix]);\r\ndata->temp_hyst[ix] = vt1211_read8(data,\r\nregtemphyst[ix]);\r\n}\r\n}\r\nfor (ix = 0; ix < ARRAY_SIZE(data->fan); ix++) {\r\ndata->fan[ix] = vt1211_read8(data,\r\nVT1211_REG_FAN(ix));\r\ndata->fan_min[ix] = vt1211_read8(data,\r\nVT1211_REG_FAN_MIN(ix));\r\ndata->pwm[ix] = vt1211_read8(data,\r\nVT1211_REG_PWM(ix));\r\n}\r\nval = vt1211_read8(data, VT1211_REG_FAN_DIV);\r\ndata->fan_div[0] = (val >> 4) & 3;\r\ndata->fan_div[1] = (val >> 6) & 3;\r\ndata->fan_ctl = val & 0xf;\r\nval = vt1211_read8(data, VT1211_REG_PWM_CTL);\r\ndata->pwm_ctl[0] = val & 0xf;\r\ndata->pwm_ctl[1] = (val >> 4) & 0xf;\r\ndata->pwm_clk = vt1211_read8(data, VT1211_REG_PWM_CLK);\r\ndata->pwm_auto_pwm[0][1] = vt1211_read8(data,\r\nVT1211_REG_PWM_AUTO_PWM(0, 1));\r\ndata->pwm_auto_pwm[0][2] = vt1211_read8(data,\r\nVT1211_REG_PWM_AUTO_PWM(0, 2));\r\ndata->pwm_auto_pwm[1][1] = vt1211_read8(data,\r\nVT1211_REG_PWM_AUTO_PWM(1, 1));\r\ndata->pwm_auto_pwm[1][2] = vt1211_read8(data,\r\nVT1211_REG_PWM_AUTO_PWM(1, 2));\r\nfor (ix = 0; ix < ARRAY_SIZE(data->pwm_auto_temp); ix++) {\r\ndata->pwm_auto_temp[ix] = vt1211_read8(data,\r\nVT1211_REG_PWM_AUTO_TEMP(ix));\r\n}\r\ndata->alarms = (vt1211_read8(data, VT1211_REG_ALARM2) << 8) |\r\nvt1211_read8(data, VT1211_REG_ALARM1);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SHOW_IN_INPUT:\r\nres = IN_FROM_REG(ix, data->in[ix]);\r\nbreak;\r\ncase SHOW_SET_IN_MIN:\r\nres = IN_FROM_REG(ix, data->in_min[ix]);\r\nbreak;\r\ncase SHOW_SET_IN_MAX:\r\nres = IN_FROM_REG(ix, data->in_max[ix]);\r\nbreak;\r\ncase SHOW_IN_ALARM:\r\nres = (data->alarms >> bitalarmin[ix]) & 1;\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_in(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SHOW_SET_IN_MIN:\r\ndata->in_min[ix] = IN_TO_REG(ix, val);\r\nvt1211_write8(data, VT1211_REG_IN_MIN(ix), data->in_min[ix]);\r\nbreak;\r\ncase SHOW_SET_IN_MAX:\r\ndata->in_max[ix] = IN_TO_REG(ix, val);\r\nvt1211_write8(data, VT1211_REG_IN_MAX(ix), data->in_max[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SHOW_TEMP_INPUT:\r\nres = TEMP_FROM_REG(ix, data->temp[ix]);\r\nbreak;\r\ncase SHOW_SET_TEMP_MAX:\r\nres = TEMP_FROM_REG(ix, data->temp_max[ix]);\r\nbreak;\r\ncase SHOW_SET_TEMP_MAX_HYST:\r\nres = TEMP_FROM_REG(ix, data->temp_hyst[ix]);\r\nbreak;\r\ncase SHOW_TEMP_ALARM:\r\nres = (data->alarms >> bitalarmtemp[ix]) & 1;\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_temp(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SHOW_SET_TEMP_MAX:\r\ndata->temp_max[ix] = TEMP_TO_REG(ix, val);\r\nvt1211_write8(data, regtempmax[ix],\r\ndata->temp_max[ix]);\r\nbreak;\r\ncase SHOW_SET_TEMP_MAX_HYST:\r\ndata->temp_hyst[ix] = TEMP_TO_REG(ix, val);\r\nvt1211_write8(data, regtemphyst[ix],\r\ndata->temp_hyst[ix]);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SHOW_FAN_INPUT:\r\nres = RPM_FROM_REG(data->fan[ix], data->fan_div[ix]);\r\nbreak;\r\ncase SHOW_SET_FAN_MIN:\r\nres = RPM_FROM_REG(data->fan_min[ix], data->fan_div[ix]);\r\nbreak;\r\ncase SHOW_SET_FAN_DIV:\r\nres = DIV_FROM_REG(data->fan_div[ix]);\r\nbreak;\r\ncase SHOW_FAN_ALARM:\r\nres = (data->alarms >> bitalarmfan[ix]) & 1;\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_fan(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nreg = vt1211_read8(data, VT1211_REG_FAN_DIV);\r\ndata->fan_div[0] = (reg >> 4) & 3;\r\ndata->fan_div[1] = (reg >> 6) & 3;\r\ndata->fan_ctl = reg & 0xf;\r\nswitch (fn) {\r\ncase SHOW_SET_FAN_MIN:\r\ndata->fan_min[ix] = RPM_TO_REG(val, data->fan_div[ix]);\r\nvt1211_write8(data, VT1211_REG_FAN_MIN(ix),\r\ndata->fan_min[ix]);\r\nbreak;\r\ncase SHOW_SET_FAN_DIV:\r\nswitch (val) {\r\ncase 1:\r\ndata->fan_div[ix] = 0;\r\nbreak;\r\ncase 2:\r\ndata->fan_div[ix] = 1;\r\nbreak;\r\ncase 4:\r\ndata->fan_div[ix] = 2;\r\nbreak;\r\ncase 8:\r\ndata->fan_div[ix] = 3;\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\ndev_warn(dev, "fan div value %ld not supported. "\r\n"Choose one of 1, 2, 4, or 8.\n", val);\r\ngoto EXIT;\r\n}\r\nvt1211_write8(data, VT1211_REG_FAN_DIV,\r\n((data->fan_div[1] << 6) |\r\n(data->fan_div[0] << 4) |\r\ndata->fan_ctl));\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nEXIT:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint res;\r\nswitch (fn) {\r\ncase SHOW_PWM:\r\nres = data->pwm[ix];\r\nbreak;\r\ncase SHOW_SET_PWM_ENABLE:\r\nres = ((data->pwm_ctl[ix] >> 3) & 1) ? 2 : 0;\r\nbreak;\r\ncase SHOW_SET_PWM_FREQ:\r\nres = 90000 >> (data->pwm_clk & 7);\r\nbreak;\r\ncase SHOW_SET_PWM_AUTO_CHANNELS_TEMP:\r\nres = (data->pwm_ctl[ix] & 7) + 1;\r\nbreak;\r\ndefault:\r\nres = 0;\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nreturn sprintf(buf, "%d\n", res);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint fn = sensor_attr_2->nr;\r\nint tmp, reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nswitch (fn) {\r\ncase SHOW_SET_PWM_ENABLE:\r\nreg = vt1211_read8(data, VT1211_REG_FAN_DIV);\r\ndata->fan_div[0] = (reg >> 4) & 3;\r\ndata->fan_div[1] = (reg >> 6) & 3;\r\ndata->fan_ctl = reg & 0xf;\r\nreg = vt1211_read8(data, VT1211_REG_PWM_CTL);\r\ndata->pwm_ctl[0] = reg & 0xf;\r\ndata->pwm_ctl[1] = (reg >> 4) & 0xf;\r\nswitch (val) {\r\ncase 0:\r\ndata->pwm_ctl[ix] &= 7;\r\nif ((data->pwm_ctl[ix ^ 1] & 1) == 0)\r\ndata->fan_ctl &= 0xe;\r\nbreak;\r\ncase 2:\r\ndata->pwm_ctl[ix] |= 8;\r\ndata->fan_ctl |= 1;\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\ndev_warn(dev, "pwm mode %ld not supported. "\r\n"Choose one of 0 or 2.\n", val);\r\ngoto EXIT;\r\n}\r\nvt1211_write8(data, VT1211_REG_PWM_CTL,\r\n((data->pwm_ctl[1] << 4) |\r\ndata->pwm_ctl[0]));\r\nvt1211_write8(data, VT1211_REG_FAN_DIV,\r\n((data->fan_div[1] << 6) |\r\n(data->fan_div[0] << 4) |\r\ndata->fan_ctl));\r\nbreak;\r\ncase SHOW_SET_PWM_FREQ:\r\nval = 135000 / SENSORS_LIMIT(val, 135000 >> 7, 135000);\r\ntmp = 0;\r\nfor (val >>= 1; val > 0; val >>= 1)\r\ntmp++;\r\nreg = vt1211_read8(data, VT1211_REG_PWM_CLK);\r\ndata->pwm_clk = (reg & 0xf8) | tmp;\r\nvt1211_write8(data, VT1211_REG_PWM_CLK, data->pwm_clk);\r\nbreak;\r\ncase SHOW_SET_PWM_AUTO_CHANNELS_TEMP:\r\nif (val < 1 || val > 7) {\r\ncount = -EINVAL;\r\ndev_warn(dev, "temp channel %ld not supported. "\r\n"Choose a value between 1 and 7.\n", val);\r\ngoto EXIT;\r\n}\r\nif (!ISTEMP(val - 1, data->uch_config)) {\r\ncount = -EINVAL;\r\ndev_warn(dev, "temp channel %ld is not available.\n",\r\nval);\r\ngoto EXIT;\r\n}\r\nreg = vt1211_read8(data, VT1211_REG_PWM_CTL);\r\ndata->pwm_ctl[0] = reg & 0xf;\r\ndata->pwm_ctl[1] = (reg >> 4) & 0xf;\r\ndata->pwm_ctl[ix] = (data->pwm_ctl[ix] & 8) | (val - 1);\r\nvt1211_write8(data, VT1211_REG_PWM_CTL,\r\n((data->pwm_ctl[1] << 4) | data->pwm_ctl[0]));\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr fetch (%d)\n", fn);\r\n}\r\nEXIT:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint ap = sensor_attr_2->nr;\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->pwm_ctl[ix] & 7,\r\ndata->pwm_auto_temp[ap]));\r\n}\r\nstatic ssize_t set_pwm_auto_point_temp(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint ap = sensor_attr_2->nr;\r\nint reg;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nreg = vt1211_read8(data, VT1211_REG_PWM_CTL);\r\ndata->pwm_ctl[0] = reg & 0xf;\r\ndata->pwm_ctl[1] = (reg >> 4) & 0xf;\r\ndata->pwm_auto_temp[ap] = TEMP_TO_REG(data->pwm_ctl[ix] & 7, val);\r\nvt1211_write8(data, VT1211_REG_PWM_AUTO_TEMP(ap),\r\ndata->pwm_auto_temp[ap]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_pwm(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint ap = sensor_attr_2->nr;\r\nreturn sprintf(buf, "%d\n", data->pwm_auto_pwm[ix][ap]);\r\n}\r\nstatic ssize_t set_pwm_auto_point_pwm(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *sensor_attr_2 =\r\nto_sensor_dev_attr_2(attr);\r\nint ix = sensor_attr_2->index;\r\nint ap = sensor_attr_2->nr;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_auto_pwm[ix][ap] = SENSORS_LIMIT(val, 0, 255);\r\nvt1211_write8(data, VT1211_REG_PWM_AUTO_PWM(ix, ap),\r\ndata->pwm_auto_pwm[ix][ap]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vrm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", data->vrm);\r\n}\r\nstatic ssize_t set_vrm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));\r\n}\r\nstatic ssize_t show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct vt1211_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic ssize_t show_alarms(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct vt1211_data *data = vt1211_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->alarms);\r\n}\r\nstatic void __devinit vt1211_init_device(struct vt1211_data *data)\r\n{\r\ndata->vrm = vid_which_vrm();\r\ndata->uch_config = vt1211_read8(data, VT1211_REG_UCH_CONFIG);\r\nif (uch_config > -1) {\r\ndata->uch_config = (data->uch_config & 0x83) |\r\n(uch_config << 2);\r\nvt1211_write8(data, VT1211_REG_UCH_CONFIG, data->uch_config);\r\n}\r\nif (int_mode == 0) {\r\nvt1211_write8(data, VT1211_REG_TEMP1_CONFIG, 0);\r\nvt1211_write8(data, VT1211_REG_TEMP2_CONFIG, 0);\r\n}\r\ndata->pwm_auto_pwm[0][3] = 255;\r\ndata->pwm_auto_pwm[1][3] = 255;\r\n}\r\nstatic void vt1211_remove_sysfs(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_in_attr_group); i++)\r\nsysfs_remove_group(&dev->kobj, &vt1211_in_attr_group[i]);\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_temp_attr_group); i++)\r\nsysfs_remove_group(&dev->kobj, &vt1211_temp_attr_group[i]);\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_fan_pwm); i++) {\r\ndevice_remove_file(dev,\r\n&vt1211_sysfs_fan_pwm[i].dev_attr);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_misc); i++)\r\ndevice_remove_file(dev, &vt1211_sysfs_misc[i]);\r\n}\r\nstatic int __devinit vt1211_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct vt1211_data *data;\r\nstruct resource *res;\r\nint i, err;\r\ndata = kzalloc(sizeof(struct vt1211_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ndev_err(dev, "Out of memory\n");\r\ngoto EXIT;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!request_region(res->start, resource_size(res), DRVNAME)) {\r\nerr = -EBUSY;\r\ndev_err(dev, "Failed to request region 0x%lx-0x%lx\n",\r\n(unsigned long)res->start, (unsigned long)res->end);\r\ngoto EXIT_KFREE;\r\n}\r\ndata->addr = res->start;\r\ndata->name = DRVNAME;\r\nmutex_init(&data->update_lock);\r\nplatform_set_drvdata(pdev, data);\r\nvt1211_init_device(data);\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_in_attr_group); i++) {\r\nif (ISVOLT(i, data->uch_config)) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&vt1211_in_attr_group[i]);\r\nif (err)\r\ngoto EXIT_DEV_REMOVE;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_temp_attr_group); i++) {\r\nif (ISTEMP(i, data->uch_config)) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&vt1211_temp_attr_group[i]);\r\nif (err)\r\ngoto EXIT_DEV_REMOVE;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_fan_pwm); i++) {\r\nerr = device_create_file(dev,\r\n&vt1211_sysfs_fan_pwm[i].dev_attr);\r\nif (err)\r\ngoto EXIT_DEV_REMOVE;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(vt1211_sysfs_misc); i++) {\r\nerr = device_create_file(dev,\r\n&vt1211_sysfs_misc[i]);\r\nif (err)\r\ngoto EXIT_DEV_REMOVE;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(dev, "Class registration failed (%d)\n", err);\r\ngoto EXIT_DEV_REMOVE_SILENT;\r\n}\r\nreturn 0;\r\nEXIT_DEV_REMOVE:\r\ndev_err(dev, "Sysfs interface creation failed (%d)\n", err);\r\nEXIT_DEV_REMOVE_SILENT:\r\nvt1211_remove_sysfs(pdev);\r\nrelease_region(res->start, resource_size(res));\r\nEXIT_KFREE:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nEXIT:\r\nreturn err;\r\n}\r\nstatic int __devexit vt1211_remove(struct platform_device *pdev)\r\n{\r\nstruct vt1211_data *data = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nvt1211_remove_sysfs(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nrelease_region(res->start, resource_size(res));\r\nreturn 0;\r\n}\r\nstatic int __init vt1211_device_add(unsigned short address)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + 0x7f,\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\npdev = platform_device_alloc(DRVNAME, address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed (%d)\n", err);\r\ngoto EXIT;\r\n}\r\nres.name = pdev->name;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto EXIT_DEV_PUT;\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto EXIT_DEV_PUT;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto EXIT_DEV_PUT;\r\n}\r\nreturn 0;\r\nEXIT_DEV_PUT:\r\nplatform_device_put(pdev);\r\nEXIT:\r\nreturn err;\r\n}\r\nstatic int __init vt1211_find(int sio_cip, unsigned short *address)\r\n{\r\nint err = -ENODEV;\r\nint devid;\r\nsuperio_enter(sio_cip);\r\ndevid = force_id ? force_id : superio_inb(sio_cip, SIO_VT1211_DEVID);\r\nif (devid != SIO_VT1211_ID)\r\ngoto EXIT;\r\nsuperio_select(sio_cip, SIO_VT1211_LDN_HWMON);\r\nif ((superio_inb(sio_cip, SIO_VT1211_ACTIVE) & 1) == 0) {\r\npr_warn("HW monitor is disabled, skipping\n");\r\ngoto EXIT;\r\n}\r\n*address = ((superio_inb(sio_cip, SIO_VT1211_BADDR) << 8) |\r\n(superio_inb(sio_cip, SIO_VT1211_BADDR + 1))) & 0xff00;\r\nif (*address == 0) {\r\npr_warn("Base address is not set, skipping\n");\r\ngoto EXIT;\r\n}\r\nerr = 0;\r\npr_info("Found VT1211 chip at 0x%04x, revision %u\n",\r\n*address, superio_inb(sio_cip, SIO_VT1211_DEVREV));\r\nEXIT:\r\nsuperio_exit(sio_cip);\r\nreturn err;\r\n}\r\nstatic int __init vt1211_init(void)\r\n{\r\nint err;\r\nunsigned short address = 0;\r\nerr = vt1211_find(SIO_REG_CIP1, &address);\r\nif (err) {\r\nerr = vt1211_find(SIO_REG_CIP2, &address);\r\nif (err)\r\ngoto EXIT;\r\n}\r\nif ((uch_config < -1) || (uch_config > 31)) {\r\nerr = -EINVAL;\r\npr_warn("Invalid UCH configuration %d. "\r\n"Choose a value between 0 and 31.\n", uch_config);\r\ngoto EXIT;\r\n}\r\nif ((int_mode < -1) || (int_mode > 0)) {\r\nerr = -EINVAL;\r\npr_warn("Invalid interrupt mode %d. "\r\n"Only mode 0 is supported.\n", int_mode);\r\ngoto EXIT;\r\n}\r\nerr = platform_driver_register(&vt1211_driver);\r\nif (err)\r\ngoto EXIT;\r\nerr = vt1211_device_add(address);\r\nif (err)\r\ngoto EXIT_DRV_UNREGISTER;\r\nreturn 0;\r\nEXIT_DRV_UNREGISTER:\r\nplatform_driver_unregister(&vt1211_driver);\r\nEXIT:\r\nreturn err;\r\n}\r\nstatic void __exit vt1211_exit(void)\r\n{\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&vt1211_driver);\r\n}
