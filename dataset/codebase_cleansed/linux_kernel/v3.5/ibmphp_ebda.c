static struct ebda_hpc_list * __init alloc_ebda_hpc_list (void)\r\n{\r\nreturn kzalloc(sizeof(struct ebda_hpc_list), GFP_KERNEL);\r\n}\r\nstatic struct controller *alloc_ebda_hpc (u32 slot_count, u32 bus_count)\r\n{\r\nstruct controller *controller;\r\nstruct ebda_hpc_slot *slots;\r\nstruct ebda_hpc_bus *buses;\r\ncontroller = kzalloc(sizeof(struct controller), GFP_KERNEL);\r\nif (!controller)\r\ngoto error;\r\nslots = kcalloc(slot_count, sizeof(struct ebda_hpc_slot), GFP_KERNEL);\r\nif (!slots)\r\ngoto error_contr;\r\ncontroller->slots = slots;\r\nbuses = kcalloc(bus_count, sizeof(struct ebda_hpc_bus), GFP_KERNEL);\r\nif (!buses)\r\ngoto error_slots;\r\ncontroller->buses = buses;\r\nreturn controller;\r\nerror_slots:\r\nkfree(controller->slots);\r\nerror_contr:\r\nkfree(controller);\r\nerror:\r\nreturn NULL;\r\n}\r\nstatic void free_ebda_hpc (struct controller *controller)\r\n{\r\nkfree (controller->slots);\r\nkfree (controller->buses);\r\nkfree (controller);\r\n}\r\nstatic struct ebda_rsrc_list * __init alloc_ebda_rsrc_list (void)\r\n{\r\nreturn kzalloc(sizeof(struct ebda_rsrc_list), GFP_KERNEL);\r\n}\r\nstatic struct ebda_pci_rsrc *alloc_ebda_pci_rsrc (void)\r\n{\r\nreturn kzalloc(sizeof(struct ebda_pci_rsrc), GFP_KERNEL);\r\n}\r\nstatic void __init print_bus_info (void)\r\n{\r\nstruct bus_info *ptr;\r\nlist_for_each_entry(ptr, &bus_info_head, bus_info_list) {\r\ndebug ("%s - slot_min = %x\n", __func__, ptr->slot_min);\r\ndebug ("%s - slot_max = %x\n", __func__, ptr->slot_max);\r\ndebug ("%s - slot_count = %x\n", __func__, ptr->slot_count);\r\ndebug ("%s - bus# = %x\n", __func__, ptr->busno);\r\ndebug ("%s - current_speed = %x\n", __func__, ptr->current_speed);\r\ndebug ("%s - controller_id = %x\n", __func__, ptr->controller_id);\r\ndebug ("%s - slots_at_33_conv = %x\n", __func__, ptr->slots_at_33_conv);\r\ndebug ("%s - slots_at_66_conv = %x\n", __func__, ptr->slots_at_66_conv);\r\ndebug ("%s - slots_at_66_pcix = %x\n", __func__, ptr->slots_at_66_pcix);\r\ndebug ("%s - slots_at_100_pcix = %x\n", __func__, ptr->slots_at_100_pcix);\r\ndebug ("%s - slots_at_133_pcix = %x\n", __func__, ptr->slots_at_133_pcix);\r\n}\r\n}\r\nstatic void print_lo_info (void)\r\n{\r\nstruct rio_detail *ptr;\r\ndebug ("print_lo_info ----\n");\r\nlist_for_each_entry(ptr, &rio_lo_head, rio_detail_list) {\r\ndebug ("%s - rio_node_id = %x\n", __func__, ptr->rio_node_id);\r\ndebug ("%s - rio_type = %x\n", __func__, ptr->rio_type);\r\ndebug ("%s - owner_id = %x\n", __func__, ptr->owner_id);\r\ndebug ("%s - first_slot_num = %x\n", __func__, ptr->first_slot_num);\r\ndebug ("%s - wpindex = %x\n", __func__, ptr->wpindex);\r\ndebug ("%s - chassis_num = %x\n", __func__, ptr->chassis_num);\r\n}\r\n}\r\nstatic void print_vg_info (void)\r\n{\r\nstruct rio_detail *ptr;\r\ndebug ("%s ---\n", __func__);\r\nlist_for_each_entry(ptr, &rio_vg_head, rio_detail_list) {\r\ndebug ("%s - rio_node_id = %x\n", __func__, ptr->rio_node_id);\r\ndebug ("%s - rio_type = %x\n", __func__, ptr->rio_type);\r\ndebug ("%s - owner_id = %x\n", __func__, ptr->owner_id);\r\ndebug ("%s - first_slot_num = %x\n", __func__, ptr->first_slot_num);\r\ndebug ("%s - wpindex = %x\n", __func__, ptr->wpindex);\r\ndebug ("%s - chassis_num = %x\n", __func__, ptr->chassis_num);\r\n}\r\n}\r\nstatic void __init print_ebda_pci_rsrc (void)\r\n{\r\nstruct ebda_pci_rsrc *ptr;\r\nlist_for_each_entry(ptr, &ibmphp_ebda_pci_rsrc_head, ebda_pci_rsrc_list) {\r\ndebug ("%s - rsrc type: %x bus#: %x dev_func: %x start addr: %x end addr: %x\n",\r\n__func__, ptr->rsrc_type ,ptr->bus_num, ptr->dev_fun,ptr->start_addr, ptr->end_addr);\r\n}\r\n}\r\nstatic void __init print_ibm_slot (void)\r\n{\r\nstruct slot *ptr;\r\nlist_for_each_entry(ptr, &ibmphp_slot_head, ibm_slot_list) {\r\ndebug ("%s - slot_number: %x\n", __func__, ptr->number);\r\n}\r\n}\r\nstatic void __init print_opt_vg (void)\r\n{\r\nstruct opt_rio *ptr;\r\ndebug ("%s ---\n", __func__);\r\nlist_for_each_entry(ptr, &opt_vg_head, opt_rio_list) {\r\ndebug ("%s - rio_type %x\n", __func__, ptr->rio_type);\r\ndebug ("%s - chassis_num: %x\n", __func__, ptr->chassis_num);\r\ndebug ("%s - first_slot_num: %x\n", __func__, ptr->first_slot_num);\r\ndebug ("%s - middle_num: %x\n", __func__, ptr->middle_num);\r\n}\r\n}\r\nstatic void __init print_ebda_hpc (void)\r\n{\r\nstruct controller *hpc_ptr;\r\nu16 index;\r\nlist_for_each_entry(hpc_ptr, &ebda_hpc_head, ebda_hpc_list) {\r\nfor (index = 0; index < hpc_ptr->slot_count; index++) {\r\ndebug ("%s - physical slot#: %x\n", __func__, hpc_ptr->slots[index].slot_num);\r\ndebug ("%s - pci bus# of the slot: %x\n", __func__, hpc_ptr->slots[index].slot_bus_num);\r\ndebug ("%s - index into ctlr addr: %x\n", __func__, hpc_ptr->slots[index].ctl_index);\r\ndebug ("%s - cap of the slot: %x\n", __func__, hpc_ptr->slots[index].slot_cap);\r\n}\r\nfor (index = 0; index < hpc_ptr->bus_count; index++) {\r\ndebug ("%s - bus# of each bus controlled by this ctlr: %x\n", __func__, hpc_ptr->buses[index].bus_num);\r\n}\r\ndebug ("%s - type of hpc: %x\n", __func__, hpc_ptr->ctlr_type);\r\nswitch (hpc_ptr->ctlr_type) {\r\ncase 1:\r\ndebug ("%s - bus: %x\n", __func__, hpc_ptr->u.pci_ctlr.bus);\r\ndebug ("%s - dev_fun: %x\n", __func__, hpc_ptr->u.pci_ctlr.dev_fun);\r\ndebug ("%s - irq: %x\n", __func__, hpc_ptr->irq);\r\nbreak;\r\ncase 0:\r\ndebug ("%s - io_start: %x\n", __func__, hpc_ptr->u.isa_ctlr.io_start);\r\ndebug ("%s - io_end: %x\n", __func__, hpc_ptr->u.isa_ctlr.io_end);\r\ndebug ("%s - irq: %x\n", __func__, hpc_ptr->irq);\r\nbreak;\r\ncase 2:\r\ncase 4:\r\ndebug ("%s - wpegbbar: %lx\n", __func__, hpc_ptr->u.wpeg_ctlr.wpegbbar);\r\ndebug ("%s - i2c_addr: %x\n", __func__, hpc_ptr->u.wpeg_ctlr.i2c_addr);\r\ndebug ("%s - irq: %x\n", __func__, hpc_ptr->irq);\r\nbreak;\r\n}\r\n}\r\n}\r\nint __init ibmphp_access_ebda (void)\r\n{\r\nu8 format, num_ctlrs, rio_complete, hs_complete, ebda_sz;\r\nu16 ebda_seg, num_entries, next_offset, offset, blk_id, sub_addr, re, rc_id, re_id, base;\r\nint rc = 0;\r\nrio_complete = 0;\r\nhs_complete = 0;\r\nio_mem = ioremap ((0x40 << 4) + 0x0e, 2);\r\nif (!io_mem )\r\nreturn -ENOMEM;\r\nebda_seg = readw (io_mem);\r\niounmap (io_mem);\r\ndebug ("returned ebda segment: %x\n", ebda_seg);\r\nio_mem = ioremap(ebda_seg<<4, 1);\r\nif (!io_mem)\r\nreturn -ENOMEM;\r\nebda_sz = readb(io_mem);\r\niounmap(io_mem);\r\ndebug("ebda size: %d(KiB)\n", ebda_sz);\r\nif (ebda_sz == 0)\r\nreturn -ENOMEM;\r\nio_mem = ioremap(ebda_seg<<4, (ebda_sz * 1024));\r\nif (!io_mem )\r\nreturn -ENOMEM;\r\nnext_offset = 0x180;\r\nfor (;;) {\r\noffset = next_offset;\r\nif (WARN(offset > (ebda_sz * 1024 - 4),\r\n"ibmphp_ebda: next read is beyond ebda_sz\n"))\r\nbreak;\r\nnext_offset = readw (io_mem + offset);\r\noffset += 2;\r\nif (next_offset == 0)\r\nbreak;\r\nblk_id = readw (io_mem + offset);\r\noffset += 2;\r\nif (blk_id != 0x4853 && blk_id != 0x4752)\r\ncontinue;\r\nif (blk_id == 0x4853) {\r\ndebug ("now enter hot swap block---\n");\r\ndebug ("hot blk id: %x\n", blk_id);\r\nformat = readb (io_mem + offset);\r\noffset += 1;\r\nif (format != 4)\r\ngoto error_nodev;\r\ndebug ("hot blk format: %x\n", format);\r\nbase = offset;\r\nsub_addr = base;\r\nre = readw (io_mem + sub_addr);\r\nsub_addr += 2;\r\nrc_id = readw (io_mem + sub_addr);\r\nsub_addr += 2;\r\nif (rc_id != 0x5243)\r\ngoto error_nodev;\r\nnum_ctlrs = readb (io_mem + sub_addr);\r\nsub_addr += 1;\r\nhpc_list_ptr = alloc_ebda_hpc_list ();\r\nif (!hpc_list_ptr) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nhpc_list_ptr->format = format;\r\nhpc_list_ptr->num_ctlrs = num_ctlrs;\r\nhpc_list_ptr->phys_addr = sub_addr;\r\ndebug ("info about hpc descriptor---\n");\r\ndebug ("hot blk format: %x\n", format);\r\ndebug ("num of controller: %x\n", num_ctlrs);\r\ndebug ("offset of hpc data structure enteries: %x\n ", sub_addr);\r\nsub_addr = base + re;\r\nrc = readw (io_mem + sub_addr);\r\nsub_addr += 2;\r\nre_id = readw (io_mem + sub_addr);\r\nsub_addr += 2;\r\nif (re_id != 0x5245)\r\ngoto error_nodev;\r\nnum_entries = readw (io_mem + sub_addr);\r\nsub_addr += 2;\r\nrsrc_list_ptr = alloc_ebda_rsrc_list ();\r\nif (!rsrc_list_ptr ) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrsrc_list_ptr->format = format;\r\nrsrc_list_ptr->num_entries = num_entries;\r\nrsrc_list_ptr->phys_addr = sub_addr;\r\ndebug ("info about rsrc descriptor---\n");\r\ndebug ("format: %x\n", format);\r\ndebug ("num of rsrc: %x\n", num_entries);\r\ndebug ("offset of rsrc data structure enteries: %x\n ", sub_addr);\r\nhs_complete = 1;\r\n} else {\r\ndebug ("now enter io table ---\n");\r\ndebug ("rio blk id: %x\n", blk_id);\r\nrio_table_ptr = kzalloc(sizeof(struct rio_table_hdr), GFP_KERNEL);\r\nif (!rio_table_ptr) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrio_table_ptr->ver_num = readb (io_mem + offset);\r\nrio_table_ptr->scal_count = readb (io_mem + offset + 1);\r\nrio_table_ptr->riodev_count = readb (io_mem + offset + 2);\r\nrio_table_ptr->offset = offset +3 ;\r\ndebug("info about rio table hdr ---\n");\r\ndebug("ver_num: %x\nscal_count: %x\nriodev_count: %x\noffset of rio table: %x\n ",\r\nrio_table_ptr->ver_num, rio_table_ptr->scal_count,\r\nrio_table_ptr->riodev_count, rio_table_ptr->offset);\r\nrio_complete = 1;\r\n}\r\n}\r\nif (!hs_complete && !rio_complete)\r\ngoto error_nodev;\r\nif (rio_table_ptr) {\r\nif (rio_complete && rio_table_ptr->ver_num == 3) {\r\nrc = ebda_rio_table ();\r\nif (rc)\r\ngoto out;\r\n}\r\n}\r\nrc = ebda_rsrc_controller ();\r\nif (rc)\r\ngoto out;\r\nrc = ebda_rsrc_rsrc ();\r\ngoto out;\r\nerror_nodev:\r\nrc = -ENODEV;\r\nout:\r\niounmap (io_mem);\r\nreturn rc;\r\n}\r\nstatic int __init ebda_rio_table (void)\r\n{\r\nu16 offset;\r\nu8 i;\r\nstruct rio_detail *rio_detail_ptr;\r\noffset = rio_table_ptr->offset;\r\noffset += 12 * rio_table_ptr->scal_count;\r\nfor (i = 0; i < rio_table_ptr->riodev_count; i++) {\r\nrio_detail_ptr = kzalloc(sizeof(struct rio_detail), GFP_KERNEL);\r\nif (!rio_detail_ptr)\r\nreturn -ENOMEM;\r\nrio_detail_ptr->rio_node_id = readb (io_mem + offset);\r\nrio_detail_ptr->bbar = readl (io_mem + offset + 1);\r\nrio_detail_ptr->rio_type = readb (io_mem + offset + 5);\r\nrio_detail_ptr->owner_id = readb (io_mem + offset + 6);\r\nrio_detail_ptr->port0_node_connect = readb (io_mem + offset + 7);\r\nrio_detail_ptr->port0_port_connect = readb (io_mem + offset + 8);\r\nrio_detail_ptr->port1_node_connect = readb (io_mem + offset + 9);\r\nrio_detail_ptr->port1_port_connect = readb (io_mem + offset + 10);\r\nrio_detail_ptr->first_slot_num = readb (io_mem + offset + 11);\r\nrio_detail_ptr->status = readb (io_mem + offset + 12);\r\nrio_detail_ptr->wpindex = readb (io_mem + offset + 13);\r\nrio_detail_ptr->chassis_num = readb (io_mem + offset + 14);\r\nif (rio_detail_ptr->rio_type == 4 || rio_detail_ptr->rio_type == 5)\r\nlist_add (&rio_detail_ptr->rio_detail_list, &rio_vg_head);\r\nelse if (rio_detail_ptr->rio_type == 6 || rio_detail_ptr->rio_type == 7)\r\nlist_add (&rio_detail_ptr->rio_detail_list, &rio_lo_head);\r\nelse\r\nkfree (rio_detail_ptr);\r\noffset += 15;\r\n}\r\nprint_lo_info ();\r\nprint_vg_info ();\r\nreturn 0;\r\n}\r\nstatic struct opt_rio *search_opt_vg (u8 chassis_num)\r\n{\r\nstruct opt_rio *ptr;\r\nlist_for_each_entry(ptr, &opt_vg_head, opt_rio_list) {\r\nif (ptr->chassis_num == chassis_num)\r\nreturn ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __init combine_wpg_for_chassis (void)\r\n{\r\nstruct opt_rio *opt_rio_ptr = NULL;\r\nstruct rio_detail *rio_detail_ptr = NULL;\r\nlist_for_each_entry(rio_detail_ptr, &rio_vg_head, rio_detail_list) {\r\nopt_rio_ptr = search_opt_vg (rio_detail_ptr->chassis_num);\r\nif (!opt_rio_ptr) {\r\nopt_rio_ptr = kzalloc(sizeof(struct opt_rio), GFP_KERNEL);\r\nif (!opt_rio_ptr)\r\nreturn -ENOMEM;\r\nopt_rio_ptr->rio_type = rio_detail_ptr->rio_type;\r\nopt_rio_ptr->chassis_num = rio_detail_ptr->chassis_num;\r\nopt_rio_ptr->first_slot_num = rio_detail_ptr->first_slot_num;\r\nopt_rio_ptr->middle_num = rio_detail_ptr->first_slot_num;\r\nlist_add (&opt_rio_ptr->opt_rio_list, &opt_vg_head);\r\n} else {\r\nopt_rio_ptr->first_slot_num = min (opt_rio_ptr->first_slot_num, rio_detail_ptr->first_slot_num);\r\nopt_rio_ptr->middle_num = max (opt_rio_ptr->middle_num, rio_detail_ptr->first_slot_num);\r\n}\r\n}\r\nprint_opt_vg ();\r\nreturn 0;\r\n}\r\nstatic struct opt_rio_lo *search_opt_lo (u8 chassis_num)\r\n{\r\nstruct opt_rio_lo *ptr;\r\nlist_for_each_entry(ptr, &opt_lo_head, opt_rio_lo_list) {\r\nif (ptr->chassis_num == chassis_num)\r\nreturn ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int combine_wpg_for_expansion (void)\r\n{\r\nstruct opt_rio_lo *opt_rio_lo_ptr = NULL;\r\nstruct rio_detail *rio_detail_ptr = NULL;\r\nlist_for_each_entry(rio_detail_ptr, &rio_lo_head, rio_detail_list) {\r\nopt_rio_lo_ptr = search_opt_lo (rio_detail_ptr->chassis_num);\r\nif (!opt_rio_lo_ptr) {\r\nopt_rio_lo_ptr = kzalloc(sizeof(struct opt_rio_lo), GFP_KERNEL);\r\nif (!opt_rio_lo_ptr)\r\nreturn -ENOMEM;\r\nopt_rio_lo_ptr->rio_type = rio_detail_ptr->rio_type;\r\nopt_rio_lo_ptr->chassis_num = rio_detail_ptr->chassis_num;\r\nopt_rio_lo_ptr->first_slot_num = rio_detail_ptr->first_slot_num;\r\nopt_rio_lo_ptr->middle_num = rio_detail_ptr->first_slot_num;\r\nopt_rio_lo_ptr->pack_count = 1;\r\nlist_add (&opt_rio_lo_ptr->opt_rio_lo_list, &opt_lo_head);\r\n} else {\r\nopt_rio_lo_ptr->first_slot_num = min (opt_rio_lo_ptr->first_slot_num, rio_detail_ptr->first_slot_num);\r\nopt_rio_lo_ptr->middle_num = max (opt_rio_lo_ptr->middle_num, rio_detail_ptr->first_slot_num);\r\nopt_rio_lo_ptr->pack_count = 2;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int first_slot_num (u8 slot_num, u8 first_slot, u8 var)\r\n{\r\nstruct opt_rio *opt_vg_ptr = NULL;\r\nstruct opt_rio_lo *opt_lo_ptr = NULL;\r\nint rc = 0;\r\nif (!var) {\r\nlist_for_each_entry(opt_vg_ptr, &opt_vg_head, opt_rio_list) {\r\nif ((first_slot < opt_vg_ptr->first_slot_num) && (slot_num >= opt_vg_ptr->first_slot_num)) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nlist_for_each_entry(opt_lo_ptr, &opt_lo_head, opt_rio_lo_list) {\r\nif ((first_slot < opt_lo_ptr->first_slot_num) && (slot_num >= opt_lo_ptr->first_slot_num)) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic struct opt_rio_lo * find_rxe_num (u8 slot_num)\r\n{\r\nstruct opt_rio_lo *opt_lo_ptr;\r\nlist_for_each_entry(opt_lo_ptr, &opt_lo_head, opt_rio_lo_list) {\r\nif ((slot_num >= opt_lo_ptr->first_slot_num) && (!first_slot_num (slot_num, opt_lo_ptr->first_slot_num, 1)))\r\nreturn opt_lo_ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct opt_rio * find_chassis_num (u8 slot_num)\r\n{\r\nstruct opt_rio *opt_vg_ptr;\r\nlist_for_each_entry(opt_vg_ptr, &opt_vg_head, opt_rio_list) {\r\nif ((slot_num >= opt_vg_ptr->first_slot_num) && (!first_slot_num (slot_num, opt_vg_ptr->first_slot_num, 0)))\r\nreturn opt_vg_ptr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic u8 calculate_first_slot (u8 slot_num)\r\n{\r\nu8 first_slot = 1;\r\nstruct slot * slot_cur;\r\nlist_for_each_entry(slot_cur, &ibmphp_slot_head, ibm_slot_list) {\r\nif (slot_cur->ctrl) {\r\nif ((slot_cur->ctrl->ctlr_type != 4) && (slot_cur->ctrl->ending_slot_num > first_slot) && (slot_num > slot_cur->ctrl->ending_slot_num))\r\nfirst_slot = slot_cur->ctrl->ending_slot_num;\r\n}\r\n}\r\nreturn first_slot + 1;\r\n}\r\nstatic char *create_file_name (struct slot * slot_cur)\r\n{\r\nstruct opt_rio *opt_vg_ptr = NULL;\r\nstruct opt_rio_lo *opt_lo_ptr = NULL;\r\nstatic char str[SLOT_NAME_SIZE];\r\nint which = 0;\r\nu8 number = 1;\r\nu8 first_slot = 1;\r\nu8 slot_num;\r\nu8 flag = 0;\r\nif (!slot_cur) {\r\nerr ("Structure passed is empty\n");\r\nreturn NULL;\r\n}\r\nslot_num = slot_cur->number;\r\nmemset (str, 0, sizeof(str));\r\nif (rio_table_ptr) {\r\nif (rio_table_ptr->ver_num == 3) {\r\nopt_vg_ptr = find_chassis_num (slot_num);\r\nopt_lo_ptr = find_rxe_num (slot_num);\r\n}\r\n}\r\nif (opt_vg_ptr) {\r\nif (opt_lo_ptr) {\r\nif ((slot_num - opt_vg_ptr->first_slot_num) > (slot_num - opt_lo_ptr->first_slot_num)) {\r\nnumber = opt_lo_ptr->chassis_num;\r\nfirst_slot = opt_lo_ptr->first_slot_num;\r\nwhich = 1;\r\n} else {\r\nfirst_slot = opt_vg_ptr->first_slot_num;\r\nnumber = opt_vg_ptr->chassis_num;\r\nwhich = 0;\r\n}\r\n} else {\r\nfirst_slot = opt_vg_ptr->first_slot_num;\r\nnumber = opt_vg_ptr->chassis_num;\r\nwhich = 0;\r\n}\r\n++flag;\r\n} else if (opt_lo_ptr) {\r\nnumber = opt_lo_ptr->chassis_num;\r\nfirst_slot = opt_lo_ptr->first_slot_num;\r\nwhich = 1;\r\n++flag;\r\n} else if (rio_table_ptr) {\r\nif (rio_table_ptr->ver_num == 3) {\r\nreturn NULL;\r\n}\r\n}\r\nif (!flag) {\r\nif (slot_cur->ctrl->ctlr_type == 4) {\r\nfirst_slot = calculate_first_slot (slot_num);\r\nwhich = 1;\r\n} else {\r\nwhich = 0;\r\n}\r\n}\r\nsprintf(str, "%s%dslot%d",\r\nwhich == 0 ? "chassis" : "rxe",\r\nnumber, slot_num - first_slot + 1);\r\nreturn str;\r\n}\r\nstatic int fillslotinfo(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot;\r\nint rc = 0;\r\nif (!hotplug_slot || !hotplug_slot->private)\r\nreturn -EINVAL;\r\nslot = hotplug_slot->private;\r\nrc = ibmphp_hpc_readslot(slot, READ_ALLSTAT, NULL);\r\nif (rc)\r\nreturn rc;\r\nhotplug_slot->info->power_status = SLOT_POWER(slot->status);\r\nhotplug_slot->info->attention_status = SLOT_ATTN(slot->status, slot->ext_status);\r\nhotplug_slot->info->latch_status = SLOT_LATCH(slot->status);\r\nif (SLOT_PRESENT (slot->status))\r\nhotplug_slot->info->adapter_status = 1;\r\nelse\r\nhotplug_slot->info->adapter_status = 0;\r\nreturn rc;\r\n}\r\nstatic void release_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot;\r\nif (!hotplug_slot || !hotplug_slot->private)\r\nreturn;\r\nslot = hotplug_slot->private;\r\nkfree(slot->hotplug_slot->info);\r\nkfree(slot->hotplug_slot);\r\nslot->ctrl = NULL;\r\nslot->bus_on = NULL;\r\nibmphp_unconfigure_card(&slot, -1);\r\nkfree (slot);\r\n}\r\nstatic int __init ebda_rsrc_controller (void)\r\n{\r\nu16 addr, addr_slot, addr_bus;\r\nu8 ctlr_id, temp, bus_index;\r\nu16 ctlr, slot, bus;\r\nu16 slot_num, bus_num, index;\r\nstruct hotplug_slot *hp_slot_ptr;\r\nstruct controller *hpc_ptr;\r\nstruct ebda_hpc_bus *bus_ptr;\r\nstruct ebda_hpc_slot *slot_ptr;\r\nstruct bus_info *bus_info_ptr1, *bus_info_ptr2;\r\nint rc;\r\nstruct slot *tmp_slot;\r\nchar name[SLOT_NAME_SIZE];\r\naddr = hpc_list_ptr->phys_addr;\r\nfor (ctlr = 0; ctlr < hpc_list_ptr->num_ctlrs; ctlr++) {\r\nbus_index = 1;\r\nctlr_id = readb (io_mem + addr);\r\naddr += 1;\r\nslot_num = readb (io_mem + addr);\r\naddr += 1;\r\naddr_slot = addr;\r\naddr += (slot_num * 4);\r\nbus_num = readb (io_mem + addr);\r\naddr += 1;\r\naddr_bus = addr;\r\naddr += (bus_num * 9);\r\ntemp = readb (io_mem + addr);\r\naddr += 1;\r\nhpc_ptr = alloc_ebda_hpc (slot_num, bus_num);\r\nif (!hpc_ptr ) {\r\nrc = -ENOMEM;\r\ngoto error_no_hpc;\r\n}\r\nhpc_ptr->ctlr_id = ctlr_id;\r\nhpc_ptr->ctlr_relative_id = ctlr;\r\nhpc_ptr->slot_count = slot_num;\r\nhpc_ptr->bus_count = bus_num;\r\ndebug ("now enter ctlr data struture ---\n");\r\ndebug ("ctlr id: %x\n", ctlr_id);\r\ndebug ("ctlr_relative_id: %x\n", hpc_ptr->ctlr_relative_id);\r\ndebug ("count of slots controlled by this ctlr: %x\n", slot_num);\r\ndebug ("count of buses controlled by this ctlr: %x\n", bus_num);\r\nslot_ptr = hpc_ptr->slots;\r\nfor (slot = 0; slot < slot_num; slot++) {\r\nslot_ptr->slot_num = readb (io_mem + addr_slot);\r\nslot_ptr->slot_bus_num = readb (io_mem + addr_slot + slot_num);\r\nslot_ptr->ctl_index = readb (io_mem + addr_slot + 2*slot_num);\r\nslot_ptr->slot_cap = readb (io_mem + addr_slot + 3*slot_num);\r\nbus_info_ptr2 = ibmphp_find_same_bus_num (slot_ptr->slot_bus_num);\r\nif (!bus_info_ptr2) {\r\nbus_info_ptr1 = kzalloc(sizeof(struct bus_info), GFP_KERNEL);\r\nif (!bus_info_ptr1) {\r\nrc = -ENOMEM;\r\ngoto error_no_hp_slot;\r\n}\r\nbus_info_ptr1->slot_min = slot_ptr->slot_num;\r\nbus_info_ptr1->slot_max = slot_ptr->slot_num;\r\nbus_info_ptr1->slot_count += 1;\r\nbus_info_ptr1->busno = slot_ptr->slot_bus_num;\r\nbus_info_ptr1->index = bus_index++;\r\nbus_info_ptr1->current_speed = 0xff;\r\nbus_info_ptr1->current_bus_mode = 0xff;\r\nbus_info_ptr1->controller_id = hpc_ptr->ctlr_id;\r\nlist_add_tail (&bus_info_ptr1->bus_info_list, &bus_info_head);\r\n} else {\r\nbus_info_ptr2->slot_min = min (bus_info_ptr2->slot_min, slot_ptr->slot_num);\r\nbus_info_ptr2->slot_max = max (bus_info_ptr2->slot_max, slot_ptr->slot_num);\r\nbus_info_ptr2->slot_count += 1;\r\n}\r\nslot_ptr++;\r\naddr_slot += 1;\r\n}\r\nbus_ptr = hpc_ptr->buses;\r\nfor (bus = 0; bus < bus_num; bus++) {\r\nbus_ptr->bus_num = readb (io_mem + addr_bus + bus);\r\nbus_ptr->slots_at_33_conv = readb (io_mem + addr_bus + bus_num + 8 * bus);\r\nbus_ptr->slots_at_66_conv = readb (io_mem + addr_bus + bus_num + 8 * bus + 1);\r\nbus_ptr->slots_at_66_pcix = readb (io_mem + addr_bus + bus_num + 8 * bus + 2);\r\nbus_ptr->slots_at_100_pcix = readb (io_mem + addr_bus + bus_num + 8 * bus + 3);\r\nbus_ptr->slots_at_133_pcix = readb (io_mem + addr_bus + bus_num + 8 * bus + 4);\r\nbus_info_ptr2 = ibmphp_find_same_bus_num (bus_ptr->bus_num);\r\nif (bus_info_ptr2) {\r\nbus_info_ptr2->slots_at_33_conv = bus_ptr->slots_at_33_conv;\r\nbus_info_ptr2->slots_at_66_conv = bus_ptr->slots_at_66_conv;\r\nbus_info_ptr2->slots_at_66_pcix = bus_ptr->slots_at_66_pcix;\r\nbus_info_ptr2->slots_at_100_pcix = bus_ptr->slots_at_100_pcix;\r\nbus_info_ptr2->slots_at_133_pcix = bus_ptr->slots_at_133_pcix;\r\n}\r\nbus_ptr++;\r\n}\r\nhpc_ptr->ctlr_type = temp;\r\nswitch (hpc_ptr->ctlr_type) {\r\ncase 1:\r\nhpc_ptr->u.pci_ctlr.bus = readb (io_mem + addr);\r\nhpc_ptr->u.pci_ctlr.dev_fun = readb (io_mem + addr + 1);\r\nhpc_ptr->irq = readb (io_mem + addr + 2);\r\naddr += 3;\r\ndebug ("ctrl bus = %x, ctlr devfun = %x, irq = %x\n",\r\nhpc_ptr->u.pci_ctlr.bus,\r\nhpc_ptr->u.pci_ctlr.dev_fun, hpc_ptr->irq);\r\nbreak;\r\ncase 0:\r\nhpc_ptr->u.isa_ctlr.io_start = readw (io_mem + addr);\r\nhpc_ptr->u.isa_ctlr.io_end = readw (io_mem + addr + 2);\r\nif (!request_region (hpc_ptr->u.isa_ctlr.io_start,\r\n(hpc_ptr->u.isa_ctlr.io_end - hpc_ptr->u.isa_ctlr.io_start + 1),\r\n"ibmphp")) {\r\nrc = -ENODEV;\r\ngoto error_no_hp_slot;\r\n}\r\nhpc_ptr->irq = readb (io_mem + addr + 4);\r\naddr += 5;\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nhpc_ptr->u.wpeg_ctlr.wpegbbar = readl (io_mem + addr);\r\nhpc_ptr->u.wpeg_ctlr.i2c_addr = readb (io_mem + addr + 4);\r\nhpc_ptr->irq = readb (io_mem + addr + 5);\r\naddr += 6;\r\nbreak;\r\ndefault:\r\nrc = -ENODEV;\r\ngoto error_no_hp_slot;\r\n}\r\ncombine_wpg_for_chassis ();\r\ncombine_wpg_for_expansion ();\r\nhpc_ptr->revision = 0xff;\r\nhpc_ptr->options = 0xff;\r\nhpc_ptr->starting_slot_num = hpc_ptr->slots[0].slot_num;\r\nhpc_ptr->ending_slot_num = hpc_ptr->slots[slot_num-1].slot_num;\r\nfor (index = 0; index < hpc_ptr->slot_count; index++) {\r\nhp_slot_ptr = kzalloc(sizeof(*hp_slot_ptr), GFP_KERNEL);\r\nif (!hp_slot_ptr) {\r\nrc = -ENOMEM;\r\ngoto error_no_hp_slot;\r\n}\r\nhp_slot_ptr->info = kzalloc(sizeof(struct hotplug_slot_info), GFP_KERNEL);\r\nif (!hp_slot_ptr->info) {\r\nrc = -ENOMEM;\r\ngoto error_no_hp_info;\r\n}\r\ntmp_slot = kzalloc(sizeof(*tmp_slot), GFP_KERNEL);\r\nif (!tmp_slot) {\r\nrc = -ENOMEM;\r\ngoto error_no_slot;\r\n}\r\ntmp_slot->flag = 1;\r\ntmp_slot->capabilities = hpc_ptr->slots[index].slot_cap;\r\nif ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_133_MAX) == EBDA_SLOT_133_MAX)\r\ntmp_slot->supported_speed = 3;\r\nelse if ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_100_MAX) == EBDA_SLOT_100_MAX)\r\ntmp_slot->supported_speed = 2;\r\nelse if ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_66_MAX) == EBDA_SLOT_66_MAX)\r\ntmp_slot->supported_speed = 1;\r\nif ((hpc_ptr->slots[index].slot_cap & EBDA_SLOT_PCIX_CAP) == EBDA_SLOT_PCIX_CAP)\r\ntmp_slot->supported_bus_mode = 1;\r\nelse\r\ntmp_slot->supported_bus_mode = 0;\r\ntmp_slot->bus = hpc_ptr->slots[index].slot_bus_num;\r\nbus_info_ptr1 = ibmphp_find_same_bus_num (hpc_ptr->slots[index].slot_bus_num);\r\nif (!bus_info_ptr1) {\r\nkfree(tmp_slot);\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\ntmp_slot->bus_on = bus_info_ptr1;\r\nbus_info_ptr1 = NULL;\r\ntmp_slot->ctrl = hpc_ptr;\r\ntmp_slot->ctlr_index = hpc_ptr->slots[index].ctl_index;\r\ntmp_slot->number = hpc_ptr->slots[index].slot_num;\r\ntmp_slot->hotplug_slot = hp_slot_ptr;\r\nhp_slot_ptr->private = tmp_slot;\r\nhp_slot_ptr->release = release_slot;\r\nrc = fillslotinfo(hp_slot_ptr);\r\nif (rc)\r\ngoto error;\r\nrc = ibmphp_init_devno ((struct slot **) &hp_slot_ptr->private);\r\nif (rc)\r\ngoto error;\r\nhp_slot_ptr->ops = &ibmphp_hotplug_slot_ops;\r\nlist_add (& ((struct slot *)(hp_slot_ptr->private))->ibm_slot_list, &ibmphp_slot_head);\r\n}\r\nprint_bus_info ();\r\nlist_add (&hpc_ptr->ebda_hpc_list, &ebda_hpc_head );\r\n}\r\nlist_for_each_entry(tmp_slot, &ibmphp_slot_head, ibm_slot_list) {\r\nsnprintf(name, SLOT_NAME_SIZE, "%s", create_file_name(tmp_slot));\r\npci_hp_register(tmp_slot->hotplug_slot,\r\npci_find_bus(0, tmp_slot->bus), tmp_slot->device, name);\r\n}\r\nprint_ebda_hpc ();\r\nprint_ibm_slot ();\r\nreturn 0;\r\nerror:\r\nkfree (hp_slot_ptr->private);\r\nerror_no_slot:\r\nkfree (hp_slot_ptr->info);\r\nerror_no_hp_info:\r\nkfree (hp_slot_ptr);\r\nerror_no_hp_slot:\r\nfree_ebda_hpc (hpc_ptr);\r\nerror_no_hpc:\r\niounmap (io_mem);\r\nreturn rc;\r\n}\r\nstatic int __init ebda_rsrc_rsrc (void)\r\n{\r\nu16 addr;\r\nshort rsrc;\r\nu8 type, rsrc_type;\r\nstruct ebda_pci_rsrc *rsrc_ptr;\r\naddr = rsrc_list_ptr->phys_addr;\r\ndebug ("now entering rsrc land\n");\r\ndebug ("offset of rsrc: %x\n", rsrc_list_ptr->phys_addr);\r\nfor (rsrc = 0; rsrc < rsrc_list_ptr->num_entries; rsrc++) {\r\ntype = readb (io_mem + addr);\r\naddr += 1;\r\nrsrc_type = type & EBDA_RSRC_TYPE_MASK;\r\nif (rsrc_type == EBDA_IO_RSRC_TYPE) {\r\nrsrc_ptr = alloc_ebda_pci_rsrc ();\r\nif (!rsrc_ptr) {\r\niounmap (io_mem);\r\nreturn -ENOMEM;\r\n}\r\nrsrc_ptr->rsrc_type = type;\r\nrsrc_ptr->bus_num = readb (io_mem + addr);\r\nrsrc_ptr->dev_fun = readb (io_mem + addr + 1);\r\nrsrc_ptr->start_addr = readw (io_mem + addr + 2);\r\nrsrc_ptr->end_addr = readw (io_mem + addr + 4);\r\naddr += 6;\r\ndebug ("rsrc from io type ----\n");\r\ndebug ("rsrc type: %x bus#: %x dev_func: %x start addr: %x end addr: %x\n",\r\nrsrc_ptr->rsrc_type, rsrc_ptr->bus_num, rsrc_ptr->dev_fun, rsrc_ptr->start_addr, rsrc_ptr->end_addr);\r\nlist_add (&rsrc_ptr->ebda_pci_rsrc_list, &ibmphp_ebda_pci_rsrc_head);\r\n}\r\nif (rsrc_type == EBDA_MEM_RSRC_TYPE || rsrc_type == EBDA_PFM_RSRC_TYPE) {\r\nrsrc_ptr = alloc_ebda_pci_rsrc ();\r\nif (!rsrc_ptr ) {\r\niounmap (io_mem);\r\nreturn -ENOMEM;\r\n}\r\nrsrc_ptr->rsrc_type = type;\r\nrsrc_ptr->bus_num = readb (io_mem + addr);\r\nrsrc_ptr->dev_fun = readb (io_mem + addr + 1);\r\nrsrc_ptr->start_addr = readl (io_mem + addr + 2);\r\nrsrc_ptr->end_addr = readl (io_mem + addr + 6);\r\naddr += 10;\r\ndebug ("rsrc from mem or pfm ---\n");\r\ndebug ("rsrc type: %x bus#: %x dev_func: %x start addr: %x end addr: %x\n",\r\nrsrc_ptr->rsrc_type, rsrc_ptr->bus_num, rsrc_ptr->dev_fun, rsrc_ptr->start_addr, rsrc_ptr->end_addr);\r\nlist_add (&rsrc_ptr->ebda_pci_rsrc_list, &ibmphp_ebda_pci_rsrc_head);\r\n}\r\n}\r\nkfree (rsrc_list_ptr);\r\nrsrc_list_ptr = NULL;\r\nprint_ebda_pci_rsrc ();\r\nreturn 0;\r\n}\r\nu16 ibmphp_get_total_controllers (void)\r\n{\r\nreturn hpc_list_ptr->num_ctlrs;\r\n}\r\nstruct slot *ibmphp_get_slot_from_physical_num (u8 physical_num)\r\n{\r\nstruct slot *slot;\r\nlist_for_each_entry(slot, &ibmphp_slot_head, ibm_slot_list) {\r\nif (slot->number == physical_num)\r\nreturn slot;\r\n}\r\nreturn NULL;\r\n}\r\nstruct bus_info *ibmphp_find_same_bus_num (u32 num)\r\n{\r\nstruct bus_info *ptr;\r\nlist_for_each_entry(ptr, &bus_info_head, bus_info_list) {\r\nif (ptr->busno == num)\r\nreturn ptr;\r\n}\r\nreturn NULL;\r\n}\r\nint ibmphp_get_bus_index (u8 num)\r\n{\r\nstruct bus_info *ptr;\r\nlist_for_each_entry(ptr, &bus_info_head, bus_info_list) {\r\nif (ptr->busno == num)\r\nreturn ptr->index;\r\n}\r\nreturn -ENODEV;\r\n}\r\nvoid ibmphp_free_bus_info_queue (void)\r\n{\r\nstruct bus_info *bus_info;\r\nstruct list_head *list;\r\nstruct list_head *next;\r\nlist_for_each_safe (list, next, &bus_info_head ) {\r\nbus_info = list_entry (list, struct bus_info, bus_info_list);\r\nkfree (bus_info);\r\n}\r\n}\r\nvoid ibmphp_free_ebda_hpc_queue (void)\r\n{\r\nstruct controller *controller = NULL;\r\nstruct list_head *list;\r\nstruct list_head *next;\r\nint pci_flag = 0;\r\nlist_for_each_safe (list, next, &ebda_hpc_head) {\r\ncontroller = list_entry (list, struct controller, ebda_hpc_list);\r\nif (controller->ctlr_type == 0)\r\nrelease_region (controller->u.isa_ctlr.io_start, (controller->u.isa_ctlr.io_end - controller->u.isa_ctlr.io_start + 1));\r\nelse if ((controller->ctlr_type == 1) && (!pci_flag)) {\r\n++pci_flag;\r\npci_unregister_driver (&ibmphp_driver);\r\n}\r\nfree_ebda_hpc (controller);\r\n}\r\n}\r\nvoid ibmphp_free_ebda_pci_rsrc_queue (void)\r\n{\r\nstruct ebda_pci_rsrc *resource;\r\nstruct list_head *list;\r\nstruct list_head *next;\r\nlist_for_each_safe (list, next, &ibmphp_ebda_pci_rsrc_head) {\r\nresource = list_entry (list, struct ebda_pci_rsrc, ebda_pci_rsrc_list);\r\nkfree (resource);\r\nresource = NULL;\r\n}\r\n}\r\nint ibmphp_register_pci (void)\r\n{\r\nstruct controller *ctrl;\r\nint rc = 0;\r\nlist_for_each_entry(ctrl, &ebda_hpc_head, ebda_hpc_list) {\r\nif (ctrl->ctlr_type == 1) {\r\nrc = pci_register_driver(&ibmphp_driver);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int ibmphp_probe (struct pci_dev * dev, const struct pci_device_id *ids)\r\n{\r\nstruct controller *ctrl;\r\ndebug ("inside ibmphp_probe\n");\r\nlist_for_each_entry(ctrl, &ebda_hpc_head, ebda_hpc_list) {\r\nif (ctrl->ctlr_type == 1) {\r\nif ((dev->devfn == ctrl->u.pci_ctlr.dev_fun) && (dev->bus->number == ctrl->u.pci_ctlr.bus)) {\r\nctrl->ctrl_dev = dev;\r\ndebug ("found device!!!\n");\r\ndebug ("dev->device = %x, dev->subsystem_device = %x\n", dev->device, dev->subsystem_device);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -ENODEV;\r\n}
