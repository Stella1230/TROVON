static int w1_ds2781_do_io(struct device *dev, char *buf, int addr,\r\nsize_t count, int io)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nif (addr > DS2781_DATA_SIZE || addr < 0)\r\nreturn 0;\r\ncount = min_t(int, count, DS2781_DATA_SIZE - addr);\r\nif (w1_reset_select_slave(sl) == 0) {\r\nif (io) {\r\nw1_write_8(sl->master, W1_DS2781_WRITE_DATA);\r\nw1_write_8(sl->master, addr);\r\nw1_write_block(sl->master, buf, count);\r\n} else {\r\nw1_write_8(sl->master, W1_DS2781_READ_DATA);\r\nw1_write_8(sl->master, addr);\r\ncount = w1_read_block(sl->master, buf, count);\r\n}\r\n}\r\nreturn count;\r\n}\r\nint w1_ds2781_io(struct device *dev, char *buf, int addr, size_t count,\r\nint io)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nint ret;\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&sl->master->mutex);\r\nret = w1_ds2781_do_io(dev, buf, addr, count, io);\r\nmutex_unlock(&sl->master->mutex);\r\nreturn ret;\r\n}\r\nint w1_ds2781_io_nolock(struct device *dev, char *buf, int addr, size_t count,\r\nint io)\r\n{\r\nint ret;\r\nif (!dev)\r\nreturn -ENODEV;\r\nret = w1_ds2781_do_io(dev, buf, addr, count, io);\r\nreturn ret;\r\n}\r\nint w1_ds2781_eeprom_cmd(struct device *dev, int addr, int cmd)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_reset_select_slave(sl) == 0) {\r\nw1_write_8(sl->master, cmd);\r\nw1_write_8(sl->master, addr);\r\n}\r\nmutex_unlock(&sl->master->mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_ds2781_read_bin(struct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nreturn w1_ds2781_io(dev, buf, off, count, 0);\r\n}\r\nstatic int w1_ds2781_add_slave(struct w1_slave *sl)\r\n{\r\nint ret;\r\nint id;\r\nstruct platform_device *pdev;\r\nid = ida_simple_get(&bat_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\nret = id;\r\ngoto noid;\r\n}\r\npdev = platform_device_alloc("ds2781-battery", id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto pdev_alloc_failed;\r\n}\r\npdev->dev.parent = &sl->dev;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto pdev_add_failed;\r\nret = sysfs_create_bin_file(&sl->dev.kobj, &w1_ds2781_bin_attr);\r\nif (ret)\r\ngoto bin_attr_failed;\r\ndev_set_drvdata(&sl->dev, pdev);\r\nreturn 0;\r\nbin_attr_failed:\r\npdev_add_failed:\r\nplatform_device_unregister(pdev);\r\npdev_alloc_failed:\r\nida_simple_remove(&bat_ida, id);\r\nnoid:\r\nreturn ret;\r\n}\r\nstatic void w1_ds2781_remove_slave(struct w1_slave *sl)\r\n{\r\nstruct platform_device *pdev = dev_get_drvdata(&sl->dev);\r\nint id = pdev->id;\r\nplatform_device_unregister(pdev);\r\nida_simple_remove(&bat_ida, id);\r\nsysfs_remove_bin_file(&sl->dev.kobj, &w1_ds2781_bin_attr);\r\n}\r\nstatic int __init w1_ds2781_init(void)\r\n{\r\nida_init(&bat_ida);\r\nreturn w1_register_family(&w1_ds2781_family);\r\n}\r\nstatic void __exit w1_ds2781_exit(void)\r\n{\r\nw1_unregister_family(&w1_ds2781_family);\r\nida_destroy(&bat_ida);\r\n}
