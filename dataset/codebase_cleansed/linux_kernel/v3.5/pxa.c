static inline unsigned int serial_in(struct uart_pxa_port *up, int offset)\r\n{\r\noffset <<= 2;\r\nreturn readl(up->port.membase + offset);\r\n}\r\nstatic inline void serial_out(struct uart_pxa_port *up, int offset, int value)\r\n{\r\noffset <<= 2;\r\nwritel(value, up->port.membase + offset);\r\n}\r\nstatic void serial_pxa_enable_ms(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nstatic void serial_pxa_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nif (up->ier & UART_IER_THRI) {\r\nup->ier &= ~UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic void serial_pxa_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nup->ier &= ~UART_IER_RLSI;\r\nup->port.read_status_mask &= ~UART_LSR_DR;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nstatic inline void receive_chars(struct uart_pxa_port *up, int *status)\r\n{\r\nstruct tty_struct *tty = up->port.state->port.tty;\r\nunsigned int ch, flag;\r\nint max_count = 256;\r\ndo {\r\nup->ier &= ~UART_IER_RTOIE;\r\nserial_out(up, UART_IER, up->ier);\r\nch = serial_in(up, UART_RX);\r\nflag = TTY_NORMAL;\r\nup->port.icount.rx++;\r\nif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\r\nUART_LSR_FE | UART_LSR_OE))) {\r\nif (*status & UART_LSR_BI) {\r\n*status &= ~(UART_LSR_FE | UART_LSR_PE);\r\nup->port.icount.brk++;\r\nif (uart_handle_break(&up->port))\r\ngoto ignore_char;\r\n} else if (*status & UART_LSR_PE)\r\nup->port.icount.parity++;\r\nelse if (*status & UART_LSR_FE)\r\nup->port.icount.frame++;\r\nif (*status & UART_LSR_OE)\r\nup->port.icount.overrun++;\r\n*status &= up->port.read_status_mask;\r\n#ifdef CONFIG_SERIAL_PXA_CONSOLE\r\nif (up->port.line == up->port.cons->index) {\r\n*status |= up->lsr_break_flag;\r\nup->lsr_break_flag = 0;\r\n}\r\n#endif\r\nif (*status & UART_LSR_BI) {\r\nflag = TTY_BREAK;\r\n} else if (*status & UART_LSR_PE)\r\nflag = TTY_PARITY;\r\nelse if (*status & UART_LSR_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(&up->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&up->port, *status, UART_LSR_OE, ch, flag);\r\nignore_char:\r\n*status = serial_in(up, UART_LSR);\r\n} while ((*status & UART_LSR_DR) && (max_count-- > 0));\r\ntty_flip_buffer_push(tty);\r\nup->ier |= UART_IER_RTOIE;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\nstatic void transmit_chars(struct uart_pxa_port *up)\r\n{\r\nstruct circ_buf *xmit = &up->port.state->xmit;\r\nint count;\r\nif (up->port.x_char) {\r\nserial_out(up, UART_TX, up->port.x_char);\r\nup->port.icount.tx++;\r\nup->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {\r\nserial_pxa_stop_tx(&up->port);\r\nreturn;\r\n}\r\ncount = up->port.fifosize / 2;\r\ndo {\r\nserial_out(up, UART_TX, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nup->port.icount.tx++;\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\n} while (--count > 0);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&up->port);\r\nif (uart_circ_empty(xmit))\r\nserial_pxa_stop_tx(&up->port);\r\n}\r\nstatic void serial_pxa_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nif (!(up->ier & UART_IER_THRI)) {\r\nup->ier |= UART_IER_THRI;\r\nserial_out(up, UART_IER, up->ier);\r\n}\r\n}\r\nstatic inline void check_modem_status(struct uart_pxa_port *up)\r\n{\r\nint status;\r\nstatus = serial_in(up, UART_MSR);\r\nif ((status & UART_MSR_ANY_DELTA) == 0)\r\nreturn;\r\nif (status & UART_MSR_TERI)\r\nup->port.icount.rng++;\r\nif (status & UART_MSR_DDSR)\r\nup->port.icount.dsr++;\r\nif (status & UART_MSR_DDCD)\r\nuart_handle_dcd_change(&up->port, status & UART_MSR_DCD);\r\nif (status & UART_MSR_DCTS)\r\nuart_handle_cts_change(&up->port, status & UART_MSR_CTS);\r\nwake_up_interruptible(&up->port.state->port.delta_msr_wait);\r\n}\r\nstatic inline irqreturn_t serial_pxa_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_pxa_port *up = dev_id;\r\nunsigned int iir, lsr;\r\niir = serial_in(up, UART_IIR);\r\nif (iir & UART_IIR_NO_INT)\r\nreturn IRQ_NONE;\r\nlsr = serial_in(up, UART_LSR);\r\nif (lsr & UART_LSR_DR)\r\nreceive_chars(up, &lsr);\r\ncheck_modem_status(up);\r\nif (lsr & UART_LSR_THRE)\r\ntransmit_chars(up);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int serial_pxa_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int serial_pxa_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned char status;\r\nunsigned int ret;\r\nstatus = serial_in(up, UART_MSR);\r\nret = 0;\r\nif (status & UART_MSR_DCD)\r\nret |= TIOCM_CAR;\r\nif (status & UART_MSR_RI)\r\nret |= TIOCM_RNG;\r\nif (status & UART_MSR_DSR)\r\nret |= TIOCM_DSR;\r\nif (status & UART_MSR_CTS)\r\nret |= TIOCM_CTS;\r\nreturn ret;\r\n}\r\nstatic void serial_pxa_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned char mcr = 0;\r\nif (mctrl & TIOCM_RTS)\r\nmcr |= UART_MCR_RTS;\r\nif (mctrl & TIOCM_DTR)\r\nmcr |= UART_MCR_DTR;\r\nif (mctrl & TIOCM_OUT1)\r\nmcr |= UART_MCR_OUT1;\r\nif (mctrl & TIOCM_OUT2)\r\nmcr |= UART_MCR_OUT2;\r\nif (mctrl & TIOCM_LOOP)\r\nmcr |= UART_MCR_LOOP;\r\nmcr |= up->mcr;\r\nserial_out(up, UART_MCR, mcr);\r\n}\r\nstatic void serial_pxa_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nif (break_state == -1)\r\nup->lcr |= UART_LCR_SBC;\r\nelse\r\nup->lcr &= ~UART_LCR_SBC;\r\nserial_out(up, UART_LCR, up->lcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int serial_pxa_startup(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned long flags;\r\nint retval;\r\nif (port->line == 3)\r\nup->mcr |= UART_MCR_AFE;\r\nelse\r\nup->mcr = 0;\r\nup->port.uartclk = clk_get_rate(up->clk);\r\nretval = request_irq(up->port.irq, serial_pxa_irq, 0, up->name, up);\r\nif (retval)\r\nreturn retval;\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_FCR, 0);\r\n(void) serial_in(up, UART_LSR);\r\n(void) serial_in(up, UART_RX);\r\n(void) serial_in(up, UART_IIR);\r\n(void) serial_in(up, UART_MSR);\r\nserial_out(up, UART_LCR, UART_LCR_WLEN8);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl |= TIOCM_OUT2;\r\nserial_pxa_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nup->ier = UART_IER_RLSI | UART_IER_RDI | UART_IER_RTOIE | UART_IER_UUE;\r\nserial_out(up, UART_IER, up->ier);\r\n(void) serial_in(up, UART_LSR);\r\n(void) serial_in(up, UART_RX);\r\n(void) serial_in(up, UART_IIR);\r\n(void) serial_in(up, UART_MSR);\r\nreturn 0;\r\n}\r\nstatic void serial_pxa_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned long flags;\r\nfree_irq(up->port.irq, up);\r\nup->ier = 0;\r\nserial_out(up, UART_IER, 0);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->port.mctrl &= ~TIOCM_OUT2;\r\nserial_pxa_set_mctrl(&up->port, up->port.mctrl);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nserial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);\r\nserial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |\r\nUART_FCR_CLEAR_RCVR |\r\nUART_FCR_CLEAR_XMIT);\r\nserial_out(up, UART_FCR, 0);\r\n}\r\nstatic void\r\nserial_pxa_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nunsigned char cval, fcr = 0;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nunsigned int dll;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncval = UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\ncval = UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\ncval = UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\ncval = UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncval |= UART_LCR_STOP;\r\nif (termios->c_cflag & PARENB)\r\ncval |= UART_LCR_PARITY;\r\nif (!(termios->c_cflag & PARODD))\r\ncval |= UART_LCR_EPAR;\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nif ((up->port.uartclk / quot) < (2400 * 16))\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR1;\r\nelse if ((up->port.uartclk / quot) < (230400 * 16))\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR8;\r\nelse\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_PXAR32;\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->ier |= UART_IER_UUE;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nup->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\r\nif (termios->c_iflag & INPCK)\r\nup->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nup->port.read_status_mask |= UART_LSR_BI;\r\nup->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\r\nif (termios->c_iflag & IGNBRK) {\r\nup->port.ignore_status_mask |= UART_LSR_BI;\r\nif (termios->c_iflag & IGNPAR)\r\nup->port.ignore_status_mask |= UART_LSR_OE;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= UART_LSR_DR;\r\nup->ier &= ~UART_IER_MSI;\r\nif (UART_ENABLE_MS(&up->port, termios->c_cflag))\r\nup->ier |= UART_IER_MSI;\r\nserial_out(up, UART_IER, up->ier);\r\nif (termios->c_cflag & CRTSCTS)\r\nup->mcr |= UART_MCR_AFE;\r\nelse\r\nup->mcr &= ~UART_MCR_AFE;\r\nserial_out(up, UART_LCR, cval | UART_LCR_DLAB);\r\nserial_out(up, UART_DLL, quot & 0xff);\r\ndll = serial_in(up, UART_DLL);\r\nWARN_ON(dll != (quot & 0xff));\r\nserial_out(up, UART_DLM, quot >> 8);\r\nserial_out(up, UART_LCR, cval);\r\nup->lcr = cval;\r\nserial_pxa_set_mctrl(&up->port, up->port.mctrl);\r\nserial_out(up, UART_FCR, fcr);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic void\r\nserial_pxa_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nif (!state)\r\nclk_prepare_enable(up->clk);\r\nelse\r\nclk_disable_unprepare(up->clk);\r\n}\r\nstatic void serial_pxa_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int serial_pxa_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void serial_pxa_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nup->port.type = PORT_PXA;\r\n}\r\nstatic int\r\nserial_pxa_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic const char *\r\nserial_pxa_type(struct uart_port *port)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nreturn up->name;\r\n}\r\nstatic inline void wait_for_xmitr(struct uart_pxa_port *up)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = serial_in(up, UART_LSR);\r\nif (status & UART_LSR_BI)\r\nup->lsr_break_flag = UART_LSR_BI;\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while ((status & BOTH_EMPTY) != BOTH_EMPTY);\r\nif (up->port.flags & UPF_CONS_FLOW) {\r\ntmout = 1000000;\r\nwhile (--tmout &&\r\n((serial_in(up, UART_MSR) & UART_MSR_CTS) == 0))\r\nudelay(1);\r\n}\r\n}\r\nstatic void serial_pxa_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct uart_pxa_port *up = (struct uart_pxa_port *)port;\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_TX, ch);\r\n}\r\nstatic void\r\nserial_pxa_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct uart_pxa_port *up = serial_pxa_ports[co->index];\r\nunsigned int ier;\r\nclk_prepare_enable(up->clk);\r\nier = serial_in(up, UART_IER);\r\nserial_out(up, UART_IER, UART_IER_UUE);\r\nuart_console_write(&up->port, s, count, serial_pxa_console_putchar);\r\nwait_for_xmitr(up);\r\nserial_out(up, UART_IER, ier);\r\nclk_disable_unprepare(up->clk);\r\n}\r\nstatic int __init\r\nserial_pxa_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_pxa_port *up;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index == -1 || co->index >= serial_pxa_reg.nr)\r\nco->index = 0;\r\nup = serial_pxa_ports[co->index];\r\nif (!up)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&up->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int serial_pxa_suspend(struct device *dev)\r\n{\r\nstruct uart_pxa_port *sport = dev_get_drvdata(dev);\r\nif (sport)\r\nuart_suspend_port(&serial_pxa_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_pxa_resume(struct device *dev)\r\n{\r\nstruct uart_pxa_port *sport = dev_get_drvdata(dev);\r\nif (sport)\r\nuart_resume_port(&serial_pxa_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_pxa_probe_dt(struct platform_device *pdev,\r\nstruct uart_pxa_port *sport)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (!np)\r\nreturn 1;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.line = ret;\r\nreturn 0;\r\n}\r\nstatic int serial_pxa_probe(struct platform_device *dev)\r\n{\r\nstruct uart_pxa_port *sport;\r\nstruct resource *mmres, *irqres;\r\nint ret;\r\nmmres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nirqres = platform_get_resource(dev, IORESOURCE_IRQ, 0);\r\nif (!mmres || !irqres)\r\nreturn -ENODEV;\r\nsport = kzalloc(sizeof(struct uart_pxa_port), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\nsport->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(sport->clk)) {\r\nret = PTR_ERR(sport->clk);\r\ngoto err_free;\r\n}\r\nsport->port.type = PORT_PXA;\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.mapbase = mmres->start;\r\nsport->port.irq = irqres->start;\r\nsport->port.fifosize = 64;\r\nsport->port.ops = &serial_pxa_pops;\r\nsport->port.dev = &dev->dev;\r\nsport->port.flags = UPF_IOREMAP | UPF_BOOT_AUTOCONF;\r\nsport->port.uartclk = clk_get_rate(sport->clk);\r\nret = serial_pxa_probe_dt(dev, sport);\r\nif (ret > 0)\r\nsport->port.line = dev->id;\r\nelse if (ret < 0)\r\ngoto err_clk;\r\nsnprintf(sport->name, PXA_NAME_LEN - 1, "UART%d", sport->port.line + 1);\r\nsport->port.membase = ioremap(mmres->start, resource_size(mmres));\r\nif (!sport->port.membase) {\r\nret = -ENOMEM;\r\ngoto err_clk;\r\n}\r\nserial_pxa_ports[sport->port.line] = sport;\r\nuart_add_one_port(&serial_pxa_reg, &sport->port);\r\nplatform_set_drvdata(dev, sport);\r\nreturn 0;\r\nerr_clk:\r\nclk_put(sport->clk);\r\nerr_free:\r\nkfree(sport);\r\nreturn ret;\r\n}\r\nstatic int serial_pxa_remove(struct platform_device *dev)\r\n{\r\nstruct uart_pxa_port *sport = platform_get_drvdata(dev);\r\nplatform_set_drvdata(dev, NULL);\r\nuart_remove_one_port(&serial_pxa_reg, &sport->port);\r\nclk_put(sport->clk);\r\nkfree(sport);\r\nreturn 0;\r\n}\r\nint __init serial_pxa_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&serial_pxa_reg);\r\nif (ret != 0)\r\nreturn ret;\r\nret = platform_driver_register(&serial_pxa_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&serial_pxa_reg);\r\nreturn ret;\r\n}\r\nvoid __exit serial_pxa_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_pxa_driver);\r\nuart_unregister_driver(&serial_pxa_reg);\r\n}
