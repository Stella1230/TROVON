static u32 get_new_brg(int baud, struct max3107_port *s)\r\n{\r\nint i;\r\nconst struct baud_table *baud_tbl = s->baud_tbl;\r\nfor (i = 0; i < 13; i++) {\r\nif (baud == baud_tbl[i].baud)\r\nreturn baud_tbl[i].new_brg;\r\n}\r\nreturn 0;\r\n}\r\nint max3107_rw(struct max3107_port *s, u8 *tx, u8 *rx, int len)\r\n{\r\nstruct spi_message spi_msg;\r\nstruct spi_transfer spi_xfer;\r\nspi_message_init(&spi_msg);\r\nmemset(&spi_xfer, 0, sizeof spi_xfer);\r\nspi_xfer.len = len;\r\nspi_xfer.tx_buf = tx;\r\nspi_xfer.rx_buf = rx;\r\nspi_xfer.speed_hz = MAX3107_SPI_SPEED;\r\nspi_message_add_tail(&spi_xfer, &spi_msg);\r\n#ifdef DBG_TRACE_SPI_DATA\r\n{\r\nint i;\r\npr_info("tx len %d:\n", spi_xfer.len);\r\nfor (i = 0 ; i < spi_xfer.len && i < 32 ; i++)\r\npr_info(" %x", ((u8 *)spi_xfer.tx_buf)[i]);\r\npr_info("\n");\r\n}\r\n#endif\r\nif (spi_sync(s->spi, &spi_msg)) {\r\ndev_err(&s->spi->dev, "spi_sync failure\n");\r\nreturn -EIO;\r\n}\r\n#ifdef DBG_TRACE_SPI_DATA\r\nif (spi_xfer.rx_buf) {\r\nint i;\r\npr_info("rx len %d:\n", spi_xfer.len);\r\nfor (i = 0 ; i < spi_xfer.len && i < 32 ; i++)\r\npr_info(" %x", ((u8 *)spi_xfer.rx_buf)[i]);\r\npr_info("\n");\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void put_data_to_circ_buf(struct max3107_port *s, unsigned char *data,\r\nint len)\r\n{\r\nstruct uart_port *port = &s->port;\r\nstruct tty_struct *tty;\r\nif (!port->state)\r\nreturn;\r\ntty = port->state->port.tty;\r\nif (!tty)\r\nreturn;\r\ntty_insert_flip_string(tty, data, len);\r\nport->icount.rx += len;\r\n}\r\nstatic void max3107_handlerx(struct max3107_port *s, u16 rxlvl)\r\n{\r\nint i;\r\nint j;\r\nint len;\r\nu16 *buf;\r\nu8 *valid_str;\r\nif (!s->rx_enabled)\r\nreturn;\r\nif (rxlvl == 0) {\r\nreturn;\r\n} else if (rxlvl >= MAX3107_RX_FIFO_SIZE) {\r\ndev_warn(&s->spi->dev, "Possible RX FIFO overrun %d\n", rxlvl);\r\nrxlvl = MAX3107_RX_FIFO_SIZE;\r\n}\r\nif ((s->rxbuf == 0) || (s->rxstr == 0)) {\r\ndev_warn(&s->spi->dev, "Rx buffer/str isn't ready\n");\r\nreturn;\r\n}\r\nbuf = s->rxbuf;\r\nvalid_str = s->rxstr;\r\nwhile (rxlvl) {\r\npr_debug("rxlvl %d\n", rxlvl);\r\nmemset(buf, 0, sizeof(u16) * (MAX3107_RX_FIFO_SIZE + 2));\r\nlen = 0;\r\nif (s->irqen_reg & MAX3107_IRQ_RXFIFO_BIT) {\r\npr_debug("Disabling RX INT\n");\r\nbuf[0] = (MAX3107_WRITE_BIT | MAX3107_IRQEN_REG);\r\ns->irqen_reg &= ~MAX3107_IRQ_RXFIFO_BIT;\r\nbuf[0] |= s->irqen_reg;\r\nlen++;\r\n}\r\nlen += rxlvl;\r\nbuf[len] = MAX3107_RXFIFOLVL_REG;\r\nlen++;\r\nif (max3107_rw(s, (u8 *)buf, (u8 *)buf, len * 2)) {\r\ndev_err(&s->spi->dev, "SPI transfer for RX h failed\n");\r\nreturn;\r\n}\r\nj = ((len - 1) - rxlvl);\r\nfor (i = 0; i < rxlvl; i++, j++)\r\nvalid_str[i] = (u8)buf[j];\r\nput_data_to_circ_buf(s, valid_str, rxlvl);\r\nrxlvl = (buf[len - 1] & MAX3107_SPI_RX_DATA_MASK);\r\n}\r\nif (s->rx_enabled) {\r\npr_debug("Enabling RX INT\n");\r\nbuf[0] = (MAX3107_WRITE_BIT | MAX3107_IRQEN_REG);\r\ns->irqen_reg |= MAX3107_IRQ_RXFIFO_BIT;\r\nbuf[0] |= s->irqen_reg;\r\nif (max3107_rw(s, (u8 *)buf, NULL, 2))\r\ndev_err(&s->spi->dev, "RX FIFO INT enabling failed\n");\r\n}\r\nif (s->port.state->port.tty)\r\ntty_flip_buffer_push(s->port.state->port.tty);\r\n}\r\nstatic void max3107_handletx(struct max3107_port *s)\r\n{\r\nstruct circ_buf *xmit = &s->port.state->xmit;\r\nint i;\r\nunsigned long flags;\r\nint len;\r\nu16 *buf;\r\nif (!s->tx_fifo_empty)\r\nreturn;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&s->port))\r\nreturn;\r\nif (!s->txbuf) {\r\ndev_warn(&s->spi->dev, "Txbuf isn't ready\n");\r\nreturn;\r\n}\r\nbuf = s->txbuf;\r\nlen = uart_circ_chars_pending(xmit);\r\nif (len) {\r\nif (len > MAX3107_TX_FIFO_SIZE)\r\nlen = MAX3107_TX_FIFO_SIZE;\r\npr_debug("txlen %d\n", len);\r\ns->port.icount.tx += len;\r\ns->tx_fifo_empty = 0;\r\ni = 0;\r\nif (s->irqen_reg & MAX3107_IRQ_TXEMPTY_BIT) {\r\npr_debug("Disabling TE INT\n");\r\nbuf[i] = (MAX3107_WRITE_BIT | MAX3107_IRQEN_REG);\r\ns->irqen_reg &= ~MAX3107_IRQ_TXEMPTY_BIT;\r\nbuf[i] |= s->irqen_reg;\r\ni++;\r\nlen++;\r\n}\r\nspin_lock_irqsave(&s->port.lock, flags);\r\nfor ( ; i < len ; i++) {\r\nbuf[i] = (MAX3107_WRITE_BIT | MAX3107_THR_REG);\r\nbuf[i] |= ((u16)xmit->buf[xmit->tail] &\r\nMAX3107_SPI_TX_DATA_MASK);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n}\r\nspin_unlock_irqrestore(&s->port.lock, flags);\r\nif (!(s->irqen_reg & MAX3107_IRQ_TXEMPTY_BIT)) {\r\npr_debug("Enabling TE INT\n");\r\nbuf[i] = (MAX3107_WRITE_BIT | MAX3107_IRQEN_REG);\r\ns->irqen_reg |= MAX3107_IRQ_TXEMPTY_BIT;\r\nbuf[i] |= s->irqen_reg;\r\ni++;\r\nlen++;\r\n}\r\nif (!s->tx_enabled) {\r\npr_debug("Enable TX\n");\r\nbuf[i] = (MAX3107_WRITE_BIT | MAX3107_MODE1_REG);\r\nspin_lock_irqsave(&s->data_lock, flags);\r\ns->mode1_reg &= ~MAX3107_MODE1_TXDIS_BIT;\r\nbuf[i] |= s->mode1_reg;\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\ns->tx_enabled = 1;\r\ni++;\r\nlen++;\r\n}\r\nif (max3107_rw(s, (u8 *)buf, NULL, len*2)) {\r\ndev_err(&s->spi->dev,\r\n"SPI transfer TX handling failed\n");\r\nreturn;\r\n}\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&s->port);\r\n}\r\nstatic u16 handle_interrupt(struct max3107_port *s)\r\n{\r\nu16 buf[4];\r\nu8 irq_status;\r\nu16 rx_level;\r\nunsigned long flags;\r\nbuf[0] = MAX3107_IRQSTS_REG;\r\nbuf[1] = MAX3107_STS_IRQSTS_REG;\r\nbuf[2] = MAX3107_LSR_IRQSTS_REG;\r\nbuf[3] = MAX3107_RXFIFOLVL_REG;\r\nif (max3107_rw(s, (u8 *)buf, (u8 *)buf, 8)) {\r\ndev_err(&s->spi->dev,\r\n"SPI transfer for INTR handling failed\n");\r\nreturn 0;\r\n}\r\nirq_status = (u8)buf[0];\r\npr_debug("IRQSTS %x\n", irq_status);\r\nrx_level = (buf[3] & MAX3107_SPI_RX_DATA_MASK);\r\nif (irq_status & MAX3107_IRQ_LSR_BIT) {\r\nif (buf[2] & MAX3107_LSR_RXTO_BIT)\r\npr_debug("RX TO INT\n");\r\n}\r\nif (irq_status & MAX3107_IRQ_TXEMPTY_BIT) {\r\npr_debug("TE INT, disabling TX\n");\r\nbuf[0] = (MAX3107_WRITE_BIT | MAX3107_MODE1_REG);\r\nspin_lock_irqsave(&s->data_lock, flags);\r\ns->mode1_reg |= MAX3107_MODE1_TXDIS_BIT;\r\nbuf[0] |= s->mode1_reg;\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\nif (max3107_rw(s, (u8 *)buf, NULL, 2))\r\ndev_err(&s->spi->dev, "SPI transfer TX dis failed\n");\r\ns->tx_enabled = 0;\r\ns->tx_fifo_empty = 1;\r\n}\r\nif (irq_status & MAX3107_IRQ_RXFIFO_BIT)\r\npr_debug("RFIFO INT\n");\r\nreturn rx_level;\r\n}\r\nstatic void max3107_dowork(struct max3107_port *s)\r\n{\r\nif (!work_pending(&s->work) && !freezing(current) && !s->suspended)\r\nqueue_work(s->workqueue, &s->work);\r\nelse\r\ndev_warn(&s->spi->dev, "interrup isn't serviced normally!\n");\r\n}\r\nstatic void max3107_work(struct work_struct *w)\r\n{\r\nstruct max3107_port *s = container_of(w, struct max3107_port, work);\r\nu16 rxlvl = 0;\r\nint len;\r\nu16 buf[5];\r\nunsigned long flags;\r\nbuf[0] = MAX3107_RXFIFOLVL_REG;\r\nif (max3107_rw(s, (u8 *)buf, (u8 *)buf, 2)) {\r\ndev_err(&s->spi->dev, "SPI transfer RX lev failed\n");\r\nrxlvl = 0;\r\n} else {\r\nrxlvl = (buf[0] & MAX3107_SPI_RX_DATA_MASK);\r\n}\r\ndo {\r\npr_debug("rxlvl %d\n", rxlvl);\r\nmax3107_handlerx(s, rxlvl);\r\nrxlvl = 0;\r\nif (s->handle_irq) {\r\ns->handle_irq = 0;\r\nrxlvl = handle_interrupt(s);\r\n}\r\nmax3107_handletx(s);\r\nlen = 0;\r\nspin_lock_irqsave(&s->data_lock, flags);\r\nif (s->mode1_commit) {\r\npr_debug("mode1_commit\n");\r\nbuf[len] = (MAX3107_WRITE_BIT | MAX3107_MODE1_REG);\r\nbuf[len++] |= s->mode1_reg;\r\ns->mode1_commit = 0;\r\n}\r\nif (s->lcr_commit) {\r\npr_debug("lcr_commit\n");\r\nbuf[len] = (MAX3107_WRITE_BIT | MAX3107_LCR_REG);\r\nbuf[len++] |= s->lcr_reg;\r\ns->lcr_commit = 0;\r\n}\r\nif (s->brg_commit) {\r\npr_debug("brg_commit\n");\r\nbuf[len] = (MAX3107_WRITE_BIT | MAX3107_BRGDIVMSB_REG);\r\nbuf[len++] |= ((s->brg_cfg >> 16) &\r\nMAX3107_SPI_TX_DATA_MASK);\r\nbuf[len] = (MAX3107_WRITE_BIT | MAX3107_BRGDIVLSB_REG);\r\nbuf[len++] |= ((s->brg_cfg >> 8) &\r\nMAX3107_SPI_TX_DATA_MASK);\r\nbuf[len] = (MAX3107_WRITE_BIT | MAX3107_BRGCFG_REG);\r\nbuf[len++] |= ((s->brg_cfg) & 0xff);\r\ns->brg_commit = 0;\r\n}\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\nif (len > 0) {\r\nif (max3107_rw(s, (u8 *)buf, NULL, len * 2))\r\ndev_err(&s->spi->dev,\r\n"SPI transfer config failed\n");\r\n}\r\n} while (rxlvl);\r\n}\r\nstatic void max3107_set_sleep(struct max3107_port *s, int mode)\r\n{\r\nu16 buf[1];\r\nunsigned long flags;\r\npr_debug("enter, mode %d\n", mode);\r\nbuf[0] = (MAX3107_WRITE_BIT | MAX3107_MODE1_REG);\r\nspin_lock_irqsave(&s->data_lock, flags);\r\nswitch (mode) {\r\ncase MAX3107_DISABLE_FORCED_SLEEP:\r\ns->mode1_reg &= ~MAX3107_MODE1_FORCESLEEP_BIT;\r\nbreak;\r\ncase MAX3107_ENABLE_FORCED_SLEEP:\r\ns->mode1_reg |= MAX3107_MODE1_FORCESLEEP_BIT;\r\nbreak;\r\ncase MAX3107_DISABLE_AUTOSLEEP:\r\ns->mode1_reg &= ~MAX3107_MODE1_AUTOSLEEP_BIT;\r\nbreak;\r\ncase MAX3107_ENABLE_AUTOSLEEP:\r\ns->mode1_reg |= MAX3107_MODE1_AUTOSLEEP_BIT;\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\ndev_warn(&s->spi->dev, "invalid sleep mode\n");\r\nreturn;\r\n}\r\nbuf[0] |= s->mode1_reg;\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\nif (max3107_rw(s, (u8 *)buf, NULL, 2))\r\ndev_err(&s->spi->dev, "SPI transfer sleep mode failed\n");\r\nif (mode == MAX3107_DISABLE_AUTOSLEEP ||\r\nmode == MAX3107_DISABLE_FORCED_SLEEP)\r\nmsleep(MAX3107_WAKEUP_DELAY);\r\n}\r\nstatic void max3107_register_init(struct max3107_port *s)\r\n{\r\nu16 buf[11];\r\ns->baud = 9600;\r\nif (s->ext_clk) {\r\ns->brg_cfg = MAX3107_BRG26_B9600;\r\ns->baud_tbl = (struct baud_table *)brg26_ext;\r\n} else {\r\ns->brg_cfg = MAX3107_BRG13_IB9600;\r\ns->baud_tbl = (struct baud_table *)brg13_int;\r\n}\r\nif (s->pdata->init)\r\ns->pdata->init(s);\r\nbuf[0] = (MAX3107_WRITE_BIT | MAX3107_BRGDIVMSB_REG)\r\n| ((s->brg_cfg >> 16) & MAX3107_SPI_TX_DATA_MASK);\r\nbuf[1] = (MAX3107_WRITE_BIT | MAX3107_BRGDIVLSB_REG)\r\n| ((s->brg_cfg >> 8) & MAX3107_SPI_TX_DATA_MASK);\r\nbuf[2] = (MAX3107_WRITE_BIT | MAX3107_BRGCFG_REG)\r\n| ((s->brg_cfg) & 0xff);\r\ns->lcr_reg = MAX3107_LCR_WORD_LEN_8;\r\nbuf[3] = (MAX3107_WRITE_BIT | MAX3107_LCR_REG)\r\n| s->lcr_reg;\r\ns->mode1_reg = 0;\r\ns->mode1_reg |= MAX3107_MODE1_IRQSEL_BIT;\r\ns->mode1_reg |= MAX3107_MODE1_TXDIS_BIT;\r\ns->tx_enabled = 0;\r\ns->rx_enabled = 1;\r\nbuf[4] = (MAX3107_WRITE_BIT | MAX3107_MODE1_REG)\r\n| s->mode1_reg;\r\nbuf[5] = (MAX3107_WRITE_BIT | MAX3107_MODE2_REG);\r\nif (s->loopback) {\r\nbuf[5] |= MAX3107_MODE2_LOOPBACK_BIT;\r\n}\r\nbuf[5] |= MAX3107_MODE2_FIFORST_BIT;\r\ns->tx_fifo_empty = 1;\r\nbuf[6] = (MAX3107_WRITE_BIT | MAX3107_FIFOTRIGLVL_REG);\r\nbuf[6] |= (MAX3107_FIFOTRIGLVL_RX(16) | MAX3107_FIFOTRIGLVL_TX(0));\r\nbuf[7] = (MAX3107_WRITE_BIT | MAX3107_FLOWLVL_REG);\r\nbuf[7] |= (MAX3107_FLOWLVL_RES(48) | MAX3107_FLOWLVL_HALT(96));\r\nbuf[8] = (MAX3107_WRITE_BIT | MAX3107_FLOWCTRL_REG);\r\nbuf[8] |= (MAX3107_FLOWCTRL_AUTOCTS_BIT | MAX3107_FLOWCTRL_AUTORTS_BIT);\r\nbuf[9] = (MAX3107_WRITE_BIT | MAX3107_RXTO_REG);\r\nbuf[9] |= 0x0030;\r\nbuf[10] = (MAX3107_WRITE_BIT | MAX3107_LSR_IRQEN_REG);\r\nbuf[10] |= MAX3107_LSR_RXTO_BIT;\r\nif (max3107_rw(s, (u8 *)buf, NULL, 22))\r\ndev_err(&s->spi->dev, "SPI transfer for init failed\n");\r\nbuf[0] = MAX3107_IRQSTS_REG;\r\ns->irqen_reg = MAX3107_IRQ_LSR_BIT;\r\ns->irqen_reg |= MAX3107_IRQ_RXFIFO_BIT;\r\nbuf[1] = (MAX3107_WRITE_BIT | MAX3107_IRQEN_REG)\r\n| s->irqen_reg;\r\nbuf[2] = (MAX3107_WRITE_BIT | MAX3107_MODE2_REG);\r\nif (s->loopback) {\r\nbuf[2] |= MAX3107_MODE2_LOOPBACK_BIT;\r\n}\r\nif (max3107_rw(s, (u8 *)buf, (u8 *)buf, 6))\r\ndev_err(&s->spi->dev, "SPI transfer for init failed\n");\r\n}\r\nstatic irqreturn_t max3107_irq(int irqno, void *dev_id)\r\n{\r\nstruct max3107_port *s = dev_id;\r\nif (irqno != s->spi->irq) {\r\nreturn IRQ_NONE;\r\n}\r\ns->handle_irq = 1;\r\nmax3107_dowork(s);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid max3107_hw_susp(struct max3107_port *s, int suspend)\r\n{\r\npr_debug("enter, suspend %d\n", suspend);\r\nif (suspend) {\r\ns->suspended = 1;\r\nmax3107_set_sleep(s, MAX3107_ENABLE_AUTOSLEEP);\r\n} else {\r\ns->suspended = 0;\r\nmax3107_set_sleep(s, MAX3107_DISABLE_AUTOSLEEP);\r\n}\r\n}\r\nstatic void max3107_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void max3107_start_tx(struct uart_port *port)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\nmax3107_dowork(s);\r\n}\r\nstatic unsigned int max3107_tx_empty(struct uart_port *port)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\npr_debug("returning %d\n",\r\n(s->tx_fifo_empty && uart_circ_empty(&s->port.state->xmit)));\r\nreturn s->tx_fifo_empty && uart_circ_empty(&s->port.state->xmit);\r\n}\r\nstatic void max3107_stop_rx(struct uart_port *port)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->data_lock, flags);\r\ns->mode1_reg |= MAX3107_MODE1_RXDIS_BIT;\r\ns->mode1_commit = 1;\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\ns->rx_enabled = 0;\r\nmax3107_dowork(s);\r\n}\r\nstatic unsigned int max3107_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void max3107_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void max3107_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\nstruct tty_struct *tty;\r\nint baud;\r\nu16 new_lcr = 0;\r\nu32 new_brg = 0;\r\nunsigned long flags;\r\nif (!port->state)\r\nreturn;\r\ntty = port->state->port.tty;\r\nif (!tty)\r\nreturn;\r\nif ((termios->c_cflag & CSIZE) == CS7)\r\nnew_lcr |= MAX3107_LCR_WORD_LEN_7;\r\nelse\r\nnew_lcr |= MAX3107_LCR_WORD_LEN_8;\r\nif (termios->c_cflag & PARENB) {\r\nnew_lcr |= MAX3107_LCR_PARITY_BIT;\r\nif (!(termios->c_cflag & PARODD))\r\nnew_lcr |= MAX3107_LCR_EVENPARITY_BIT;\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\nnew_lcr |= MAX3107_LCR_STOPLEN_BIT;\r\n}\r\ntermios->c_cflag &= ~CMSPAR;\r\ns->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\ns->port.ignore_status_mask |= MAX3107_ALL_ERRORS;\r\ns->port.state->port.tty->low_latency = 1;\r\nbaud = tty_get_baud_rate(tty);\r\nspin_lock_irqsave(&s->data_lock, flags);\r\nnew_brg = get_new_brg(baud, s);\r\nif (!new_brg) {\r\nbaud = s->baud;\r\nnew_brg = s->brg_cfg;\r\n}\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\ns->baud = baud;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_lock_irqsave(&s->data_lock, flags);\r\nif (s->lcr_reg != new_lcr) {\r\ns->lcr_reg = new_lcr;\r\ns->lcr_commit = 1;\r\n}\r\nif (s->brg_cfg != new_brg) {\r\ns->brg_cfg = new_brg;\r\ns->brg_commit = 1;\r\n}\r\nspin_unlock_irqrestore(&s->data_lock, flags);\r\nmax3107_dowork(s);\r\n}\r\nstatic void max3107_shutdown(struct uart_port *port)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\nif (s->suspended && s->pdata->hw_suspend)\r\ns->pdata->hw_suspend(s, 0);\r\nfree_irq(s->spi->irq, s);\r\nif (s->workqueue) {\r\nflush_workqueue(s->workqueue);\r\ndestroy_workqueue(s->workqueue);\r\ns->workqueue = NULL;\r\n}\r\nif (s->pdata->hw_suspend)\r\ns->pdata->hw_suspend(s, 1);\r\n}\r\nstatic int max3107_startup(struct uart_port *port)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\ns->workqueue = create_freezable_workqueue("max3107");\r\nif (!s->workqueue) {\r\ndev_err(&s->spi->dev, "Workqueue creation failed\n");\r\nreturn -EBUSY;\r\n}\r\nINIT_WORK(&s->work, max3107_work);\r\nif (request_irq(s->spi->irq, max3107_irq, IRQF_TRIGGER_FALLING,\r\n"max3107", s)) {\r\ndev_err(&s->spi->dev, "IRQ reguest failed\n");\r\ndestroy_workqueue(s->workqueue);\r\ns->workqueue = NULL;\r\nreturn -EBUSY;\r\n}\r\nif (s->pdata->hw_suspend)\r\ns->pdata->hw_suspend(s, 0);\r\nmax3107_register_init(s);\r\nreturn 0;\r\n}\r\nstatic const char *max3107_type(struct uart_port *port)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\nreturn s->spi->modalias;\r\n}\r\nstatic void max3107_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int max3107_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void max3107_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct max3107_port *s = container_of(port, struct max3107_port, port);\r\ns->port.type = PORT_MAX3107;\r\n}\r\nstatic int max3107_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nif (ser->type == PORT_UNKNOWN || ser->type == PORT_MAX3107)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void max3107_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic void max3107_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nint max3107_probe(struct spi_device *spi, struct max3107_plat *pdata)\r\n{\r\nstruct max3107_port *s;\r\nu16 buf[2];\r\nint retval;\r\npr_info("enter max3107 probe\n");\r\ns = kzalloc(sizeof(*s), GFP_KERNEL);\r\nif (!s) {\r\npr_err("Allocating port structure failed\n");\r\nreturn -ENOMEM;\r\n}\r\ns->pdata = pdata;\r\ns->rxbuf = kzalloc(sizeof(u16) * (MAX3107_RX_FIFO_SIZE+2), GFP_KERNEL);\r\nif (!s->rxbuf) {\r\npr_err("Allocating RX buffer failed\n");\r\nretval = -ENOMEM;\r\ngoto err_free4;\r\n}\r\ns->rxstr = kzalloc(sizeof(u8) * MAX3107_RX_FIFO_SIZE, GFP_KERNEL);\r\nif (!s->rxstr) {\r\npr_err("Allocating RX buffer failed\n");\r\nretval = -ENOMEM;\r\ngoto err_free3;\r\n}\r\ns->txbuf = kzalloc(sizeof(u16) * MAX3107_TX_FIFO_SIZE + 3, GFP_KERNEL);\r\nif (!s->txbuf) {\r\npr_err("Allocating TX buffer failed\n");\r\nretval = -ENOMEM;\r\ngoto err_free2;\r\n}\r\nspin_lock_init(&s->data_lock);\r\ndev_set_drvdata(&spi->dev, s);\r\nspi->mode = SPI_MODE_0;\r\nspi->dev.platform_data = pdata;\r\nspi->bits_per_word = 16;\r\ns->ext_clk = pdata->ext_clk;\r\ns->loopback = pdata->loopback;\r\nspi_setup(spi);\r\ns->spi = spi;\r\nbuf[0] = MAX3107_REVID_REG;\r\nif (max3107_rw(s, (u8 *)buf, (u8 *)buf, 2)) {\r\ndev_err(&s->spi->dev, "SPI transfer for REVID read failed\n");\r\nretval = -EIO;\r\ngoto err_free1;\r\n}\r\nif ((buf[0] & MAX3107_SPI_RX_DATA_MASK) != MAX3107_REVID1 &&\r\n(buf[0] & MAX3107_SPI_RX_DATA_MASK) != MAX3107_REVID2) {\r\ndev_err(&s->spi->dev, "REVID %x does not match\n",\r\n(buf[0] & MAX3107_SPI_RX_DATA_MASK));\r\nretval = -ENODEV;\r\ngoto err_free1;\r\n}\r\nbuf[0] = (MAX3107_WRITE_BIT | MAX3107_IRQEN_REG | 0x0000);\r\nbuf[0] |= 0x0000;\r\nbuf[1] = (MAX3107_WRITE_BIT | MAX3107_CLKSRC_REG);\r\nif (s->ext_clk) {\r\nbuf[1] |= MAX3107_CLKSRC_EXTCLK_BIT;\r\n}\r\nbuf[1] |= MAX3107_CLKSRC_PLLBYP_BIT;\r\nif (max3107_rw(s, (u8 *)buf, NULL, 4)) {\r\ndev_err(&s->spi->dev, "SPI transfer for init failed\n");\r\nretval = -EIO;\r\ngoto err_free1;\r\n}\r\nif (!driver_registered) {\r\nretval = uart_register_driver(&max3107_uart_driver);\r\nif (retval) {\r\ndev_err(&s->spi->dev, "Registering UART driver failed\n");\r\ngoto err_free1;\r\n}\r\ndriver_registered = 1;\r\n}\r\ns->port.fifosize = 128;\r\ns->port.ops = &max3107_ops;\r\ns->port.line = 0;\r\ns->port.dev = &spi->dev;\r\ns->port.uartclk = 9600;\r\ns->port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;\r\ns->port.irq = s->spi->irq;\r\ns->port.type = PORT_MAX3107;\r\nretval = uart_add_one_port(&max3107_uart_driver, &s->port);\r\nif (retval < 0) {\r\ndev_err(&s->spi->dev, "Adding UART port failed\n");\r\ngoto err_free1;\r\n}\r\nif (pdata->configure) {\r\nretval = pdata->configure(s);\r\nif (retval < 0)\r\ngoto err_free1;\r\n}\r\nif (pdata->hw_suspend)\r\npdata->hw_suspend(s, 1);\r\nreturn 0;\r\nerr_free1:\r\nkfree(s->txbuf);\r\nerr_free2:\r\nkfree(s->rxstr);\r\nerr_free3:\r\nkfree(s->rxbuf);\r\nerr_free4:\r\nkfree(s);\r\nreturn retval;\r\n}\r\nint max3107_remove(struct spi_device *spi)\r\n{\r\nstruct max3107_port *s = dev_get_drvdata(&spi->dev);\r\npr_info("enter max3107 remove\n");\r\nif (uart_remove_one_port(&max3107_uart_driver, &s->port))\r\ndev_warn(&s->spi->dev, "Removing UART port failed\n");\r\nkfree(s->rxbuf);\r\nkfree(s->rxstr);\r\nkfree(s->txbuf);\r\nkfree(s);\r\nreturn 0;\r\n}\r\nint max3107_suspend(struct spi_device *spi, pm_message_t state)\r\n{\r\n#ifdef CONFIG_PM\r\nstruct max3107_port *s = dev_get_drvdata(&spi->dev);\r\npr_debug("enter suspend\n");\r\nuart_suspend_port(&max3107_uart_driver, &s->port);\r\nif (s->pdata->hw_suspend)\r\ns->pdata->hw_suspend(s, 1);\r\n#endif\r\nreturn 0;\r\n}\r\nint max3107_resume(struct spi_device *spi)\r\n{\r\n#ifdef CONFIG_PM\r\nstruct max3107_port *s = dev_get_drvdata(&spi->dev);\r\npr_debug("enter resume\n");\r\nif (s->pdata->hw_suspend)\r\ns->pdata->hw_suspend(s, 0);\r\nuart_resume_port(&max3107_uart_driver, &s->port);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int max3107_probe_generic(struct spi_device *spi)\r\n{\r\nreturn max3107_probe(spi, &generic_plat_data);\r\n}\r\nstatic int __init max3107_init(void)\r\n{\r\npr_info("enter max3107 init\n");\r\nreturn spi_register_driver(&max3107_driver);\r\n}\r\nstatic void __exit max3107_exit(void)\r\n{\r\npr_info("enter max3107 exit\n");\r\nif (driver_registered)\r\nuart_unregister_driver(&max3107_uart_driver);\r\nspi_unregister_driver(&max3107_driver);\r\n}
