unsigned long align_addr(unsigned long addr, struct file *filp,\r\nenum align_flags flags)\r\n{\r\nunsigned long tmp_addr;\r\nif (va_align.flags < 0 || !(va_align.flags & (2 - mmap_is_ia32())))\r\nreturn addr;\r\nif (!(current->flags & PF_RANDOMIZE))\r\nreturn addr;\r\nif (!((flags & ALIGN_VDSO) || filp))\r\nreturn addr;\r\ntmp_addr = addr;\r\nif (!(flags & ALIGN_TOPDOWN))\r\ntmp_addr += va_align.mask;\r\ntmp_addr &= ~va_align.mask;\r\nreturn tmp_addr;\r\n}\r\nstatic int __init control_va_addr_alignment(char *str)\r\n{\r\nif (va_align.flags < 0)\r\nreturn 1;\r\nif (*str == 0)\r\nreturn 1;\r\nif (*str == '=')\r\nstr++;\r\nif (!strcmp(str, "32"))\r\nva_align.flags = ALIGN_VA_32;\r\nelse if (!strcmp(str, "64"))\r\nva_align.flags = ALIGN_VA_64;\r\nelse if (!strcmp(str, "off"))\r\nva_align.flags = 0;\r\nelse if (!strcmp(str, "on"))\r\nva_align.flags = ALIGN_VA_32 | ALIGN_VA_64;\r\nelse\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void find_start_end(unsigned long flags, unsigned long *begin,\r\nunsigned long *end)\r\n{\r\nif (!test_thread_flag(TIF_ADDR32) && (flags & MAP_32BIT)) {\r\nunsigned long new_begin;\r\n*begin = 0x40000000;\r\n*end = 0x80000000;\r\nif (current->flags & PF_RANDOMIZE) {\r\nnew_begin = randomize_range(*begin, *begin + 0x02000000, 0);\r\nif (new_begin)\r\n*begin = new_begin;\r\n}\r\n} else {\r\n*begin = TASK_UNMAPPED_BASE;\r\n*end = TASK_SIZE;\r\n}\r\n}\r\nunsigned long\r\narch_get_unmapped_area(struct file *filp, unsigned long addr,\r\nunsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned long start_addr;\r\nunsigned long begin, end;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nfind_start_end(flags, &begin, &end);\r\nif (len > end)\r\nreturn -ENOMEM;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (end - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\nreturn addr;\r\n}\r\nif (((flags & MAP_32BIT) || test_thread_flag(TIF_ADDR32))\r\n&& len <= mm->cached_hole_size) {\r\nmm->cached_hole_size = 0;\r\nmm->free_area_cache = begin;\r\n}\r\naddr = mm->free_area_cache;\r\nif (addr < begin)\r\naddr = begin;\r\nstart_addr = addr;\r\nfull_search:\r\naddr = align_addr(addr, filp, 0);\r\nfor (vma = find_vma(mm, addr); ; vma = vma->vm_next) {\r\nif (end - len < addr) {\r\nif (start_addr != begin) {\r\nstart_addr = addr = begin;\r\nmm->cached_hole_size = 0;\r\ngoto full_search;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nif (!vma || addr + len <= vma->vm_start) {\r\nmm->free_area_cache = addr + len;\r\nreturn addr;\r\n}\r\nif (addr + mm->cached_hole_size < vma->vm_start)\r\nmm->cached_hole_size = vma->vm_start - addr;\r\naddr = vma->vm_end;\r\naddr = align_addr(addr, filp, 0);\r\n}\r\n}\r\nunsigned long\r\narch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,\r\nconst unsigned long len, const unsigned long pgoff,\r\nconst unsigned long flags)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long addr = addr0, start_addr;\r\nif (len > TASK_SIZE)\r\nreturn -ENOMEM;\r\nif (flags & MAP_FIXED)\r\nreturn addr;\r\nif (!test_thread_flag(TIF_ADDR32) && (flags & MAP_32BIT))\r\ngoto bottomup;\r\nif (addr) {\r\naddr = PAGE_ALIGN(addr);\r\nvma = find_vma(mm, addr);\r\nif (TASK_SIZE - len >= addr &&\r\n(!vma || addr + len <= vma->vm_start))\r\nreturn addr;\r\n}\r\nif (len <= mm->cached_hole_size) {\r\nmm->cached_hole_size = 0;\r\nmm->free_area_cache = mm->mmap_base;\r\n}\r\ntry_again:\r\nstart_addr = addr = mm->free_area_cache;\r\nif (addr < len)\r\ngoto fail;\r\naddr -= len;\r\ndo {\r\naddr = align_addr(addr, filp, ALIGN_TOPDOWN);\r\nvma = find_vma(mm, addr);\r\nif (!vma || addr+len <= vma->vm_start)\r\nreturn mm->free_area_cache = addr;\r\nif (addr + mm->cached_hole_size < vma->vm_start)\r\nmm->cached_hole_size = vma->vm_start - addr;\r\naddr = vma->vm_start-len;\r\n} while (len < vma->vm_start);\r\nfail:\r\nif (start_addr != mm->mmap_base) {\r\nmm->free_area_cache = mm->mmap_base;\r\nmm->cached_hole_size = 0;\r\ngoto try_again;\r\n}\r\nbottomup:\r\nmm->cached_hole_size = ~0UL;\r\nmm->free_area_cache = TASK_UNMAPPED_BASE;\r\naddr = arch_get_unmapped_area(filp, addr0, len, pgoff, flags);\r\nmm->free_area_cache = mm->mmap_base;\r\nmm->cached_hole_size = ~0UL;\r\nreturn addr;\r\n}
