static inline int config_access_valid(struct pci_dn *dn, int where)\r\n{\r\nif (where < 256)\r\nreturn 1;\r\nif (where < 4096 && dn->pci_ext_config_space)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint rtas_read_config(struct pci_dn *pdn, int where, int size, u32 *val)\r\n{\r\nint returnval = -1;\r\nunsigned long buid, addr;\r\nint ret;\r\nif (!pdn)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (!config_access_valid(pdn, where))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\naddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\r\nbuid = pdn->phb->buid;\r\nif (buid) {\r\nret = rtas_call(ibm_read_pci_config, 4, 2, &returnval,\r\naddr, BUID_HI(buid), BUID_LO(buid), size);\r\n} else {\r\nret = rtas_call(read_pci_config, 2, 2, &returnval, addr, size);\r\n}\r\n*val = returnval;\r\nif (ret)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (returnval == EEH_IO_ERROR_VALUE(size) &&\r\neeh_dn_check_failure (pdn->node, NULL))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int rtas_pci_read_config(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct device_node *busdn, *dn;\r\nbusdn = pci_bus_to_OF_node(bus);\r\nfor (dn = busdn->child; dn; dn = dn->sibling) {\r\nstruct pci_dn *pdn = PCI_DN(dn);\r\nif (pdn && pdn->devfn == devfn\r\n&& of_device_is_available(dn))\r\nreturn rtas_read_config(pdn, where, size, val);\r\n}\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nint rtas_write_config(struct pci_dn *pdn, int where, int size, u32 val)\r\n{\r\nunsigned long buid, addr;\r\nint ret;\r\nif (!pdn)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (!config_access_valid(pdn, where))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\naddr = rtas_config_addr(pdn->busno, pdn->devfn, where);\r\nbuid = pdn->phb->buid;\r\nif (buid) {\r\nret = rtas_call(ibm_write_pci_config, 5, 1, NULL, addr,\r\nBUID_HI(buid), BUID_LO(buid), size, (ulong) val);\r\n} else {\r\nret = rtas_call(write_pci_config, 3, 1, NULL, addr, size, (ulong)val);\r\n}\r\nif (ret)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int rtas_pci_write_config(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct device_node *busdn, *dn;\r\nbusdn = pci_bus_to_OF_node(bus);\r\nfor (dn = busdn->child; dn; dn = dn->sibling) {\r\nstruct pci_dn *pdn = PCI_DN(dn);\r\nif (pdn && pdn->devfn == devfn\r\n&& of_device_is_available(dn))\r\nreturn rtas_write_config(pdn, where, size, val);\r\n}\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic int is_python(struct device_node *dev)\r\n{\r\nconst char *model = of_get_property(dev, "model", NULL);\r\nif (model && strstr(model, "Python"))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void python_countermeasures(struct device_node *dev)\r\n{\r\nstruct resource registers;\r\nvoid __iomem *chip_regs;\r\nvolatile u32 val;\r\nif (of_address_to_resource(dev, 0, &registers)) {\r\nprintk(KERN_ERR "Can't get address for Python workarounds !\n");\r\nreturn;\r\n}\r\nchip_regs = ioremap(registers.start & ~(0xfffffUL), 0x100000);\r\n#define PRG_CL_RESET_VALID 0x00010000\r\nval = in_be32(chip_regs + 0xf6030);\r\nif (val & PRG_CL_RESET_VALID) {\r\nprintk(KERN_INFO "Python workaround: ");\r\nval &= ~PRG_CL_RESET_VALID;\r\nout_be32(chip_regs + 0xf6030, val);\r\nval = in_be32(chip_regs + 0xf6030);\r\nprintk("reg0: %x\n", val);\r\n}\r\niounmap(chip_regs);\r\n}\r\nvoid __init init_pci_config_tokens (void)\r\n{\r\nread_pci_config = rtas_token("read-pci-config");\r\nwrite_pci_config = rtas_token("write-pci-config");\r\nibm_read_pci_config = rtas_token("ibm,read-pci-config");\r\nibm_write_pci_config = rtas_token("ibm,write-pci-config");\r\n}\r\nunsigned long __devinit get_phb_buid (struct device_node *phb)\r\n{\r\nstruct resource r;\r\nif (ibm_read_pci_config == -1)\r\nreturn 0;\r\nif (of_address_to_resource(phb, 0, &r))\r\nreturn 0;\r\nreturn r.start;\r\n}\r\nstatic int phb_set_bus_ranges(struct device_node *dev,\r\nstruct pci_controller *phb)\r\n{\r\nconst int *bus_range;\r\nunsigned int len;\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int)) {\r\nreturn 1;\r\n}\r\nphb->first_busno = bus_range[0];\r\nphb->last_busno = bus_range[1];\r\nreturn 0;\r\n}\r\nint __devinit rtas_setup_phb(struct pci_controller *phb)\r\n{\r\nstruct device_node *dev = phb->dn;\r\nif (is_python(dev))\r\npython_countermeasures(dev);\r\nif (phb_set_bus_ranges(dev, phb))\r\nreturn 1;\r\nphb->ops = &rtas_pci_ops;\r\nphb->buid = get_phb_buid(dev);\r\nreturn 0;\r\n}\r\nvoid __init find_and_init_phbs(void)\r\n{\r\nstruct device_node *node;\r\nstruct pci_controller *phb;\r\nstruct device_node *root = of_find_node_by_path("/");\r\nfor_each_child_of_node(root, node) {\r\nif (node->type == NULL || (strcmp(node->type, "pci") != 0 &&\r\nstrcmp(node->type, "pciex") != 0))\r\ncontinue;\r\nphb = pcibios_alloc_controller(node);\r\nif (!phb)\r\ncontinue;\r\nrtas_setup_phb(phb);\r\npci_process_bridge_OF_ranges(phb, node, 0);\r\nisa_bridge_find_early(phb);\r\n}\r\nof_node_put(root);\r\npci_devs_phb_init();\r\neeh_dev_phb_init();\r\nif (of_chosen) {\r\nconst int *prop;\r\nprop = of_get_property(of_chosen,\r\n"linux,pci-probe-only", NULL);\r\nif (prop) {\r\nif (*prop)\r\npci_add_flags(PCI_PROBE_ONLY);\r\nelse\r\npci_clear_flags(PCI_PROBE_ONLY);\r\n}\r\n#ifdef CONFIG_PPC32\r\nprop = of_get_property(of_chosen,\r\n"linux,pci-assign-all-buses", NULL);\r\nif (prop && *prop)\r\npci_add_flags(PCI_REASSIGN_ALL_BUS);\r\n#endif\r\n}\r\n}
