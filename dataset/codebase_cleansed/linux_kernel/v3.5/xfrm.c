static inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\r\n{\r\nreturn (ctx &&\r\n(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\r\n(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\r\n}\r\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\r\n{\r\nreturn selinux_authorizable_ctx(x->security);\r\n}\r\nint selinux_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)\r\n{\r\nint rc;\r\nu32 sel_sid;\r\nif (ctx) {\r\nif (!selinux_authorizable_ctx(ctx))\r\nreturn -EINVAL;\r\nsel_sid = ctx->ctx_sid;\r\n} else\r\nreturn 0;\r\nrc = avc_has_perm(fl_secid, sel_sid, SECCLASS_ASSOCIATION,\r\nASSOCIATION__POLMATCH,\r\nNULL);\r\nif (rc == -EACCES)\r\nreturn -ESRCH;\r\nreturn rc;\r\n}\r\nint selinux_xfrm_state_pol_flow_match(struct xfrm_state *x, struct xfrm_policy *xp,\r\nconst struct flowi *fl)\r\n{\r\nu32 state_sid;\r\nint rc;\r\nif (!xp->security)\r\nif (x->security)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\nelse\r\nif (!x->security)\r\nreturn 0;\r\nelse\r\nif (!selinux_authorizable_xfrm(x))\r\nreturn 0;\r\nstate_sid = x->security->ctx_sid;\r\nif (fl->flowi_secid != state_sid)\r\nreturn 0;\r\nrc = avc_has_perm(fl->flowi_secid, state_sid, SECCLASS_ASSOCIATION,\r\nASSOCIATION__SENDTO,\r\nNULL)? 0:1;\r\nreturn rc;\r\n}\r\nint selinux_xfrm_decode_session(struct sk_buff *skb, u32 *sid, int ckall)\r\n{\r\nstruct sec_path *sp;\r\n*sid = SECSID_NULL;\r\nif (skb == NULL)\r\nreturn 0;\r\nsp = skb->sp;\r\nif (sp) {\r\nint i, sid_set = 0;\r\nfor (i = sp->len-1; i >= 0; i--) {\r\nstruct xfrm_state *x = sp->xvec[i];\r\nif (selinux_authorizable_xfrm(x)) {\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\nif (!sid_set) {\r\n*sid = ctx->ctx_sid;\r\nsid_set = 1;\r\nif (!ckall)\r\nbreak;\r\n} else if (*sid != ctx->ctx_sid)\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int selinux_xfrm_sec_ctx_alloc(struct xfrm_sec_ctx **ctxp,\r\nstruct xfrm_user_sec_ctx *uctx, u32 sid)\r\n{\r\nint rc = 0;\r\nconst struct task_security_struct *tsec = current_security();\r\nstruct xfrm_sec_ctx *ctx = NULL;\r\nchar *ctx_str = NULL;\r\nu32 str_len;\r\nBUG_ON(uctx && sid);\r\nif (!uctx)\r\ngoto not_from_user;\r\nif (uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\r\nreturn -EINVAL;\r\nstr_len = uctx->ctx_len;\r\nif (str_len >= PAGE_SIZE)\r\nreturn -ENOMEM;\r\n*ctxp = ctx = kmalloc(sizeof(*ctx) +\r\nstr_len + 1,\r\nGFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->ctx_doi = uctx->ctx_doi;\r\nctx->ctx_len = str_len;\r\nctx->ctx_alg = uctx->ctx_alg;\r\nmemcpy(ctx->ctx_str,\r\nuctx+1,\r\nstr_len);\r\nctx->ctx_str[str_len] = 0;\r\nrc = security_context_to_sid(ctx->ctx_str,\r\nstr_len,\r\n&ctx->ctx_sid);\r\nif (rc)\r\ngoto out;\r\nrc = avc_has_perm(tsec->sid, ctx->ctx_sid,\r\nSECCLASS_ASSOCIATION,\r\nASSOCIATION__SETCONTEXT, NULL);\r\nif (rc)\r\ngoto out;\r\nreturn rc;\r\nnot_from_user:\r\nrc = security_sid_to_context(sid, &ctx_str, &str_len);\r\nif (rc)\r\ngoto out;\r\n*ctxp = ctx = kmalloc(sizeof(*ctx) +\r\nstr_len,\r\nGFP_ATOMIC);\r\nif (!ctx) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nctx->ctx_doi = XFRM_SC_DOI_LSM;\r\nctx->ctx_alg = XFRM_SC_ALG_SELINUX;\r\nctx->ctx_sid = sid;\r\nctx->ctx_len = str_len;\r\nmemcpy(ctx->ctx_str,\r\nctx_str,\r\nstr_len);\r\ngoto out2;\r\nout:\r\n*ctxp = NULL;\r\nkfree(ctx);\r\nout2:\r\nkfree(ctx_str);\r\nreturn rc;\r\n}\r\nint selinux_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\r\nstruct xfrm_user_sec_ctx *uctx)\r\n{\r\nint err;\r\nBUG_ON(!uctx);\r\nerr = selinux_xfrm_sec_ctx_alloc(ctxp, uctx, 0);\r\nif (err == 0)\r\natomic_inc(&selinux_xfrm_refcount);\r\nreturn err;\r\n}\r\nint selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,\r\nstruct xfrm_sec_ctx **new_ctxp)\r\n{\r\nstruct xfrm_sec_ctx *new_ctx;\r\nif (old_ctx) {\r\nnew_ctx = kmalloc(sizeof(*old_ctx) + old_ctx->ctx_len,\r\nGFP_KERNEL);\r\nif (!new_ctx)\r\nreturn -ENOMEM;\r\nmemcpy(new_ctx, old_ctx, sizeof(*new_ctx));\r\nmemcpy(new_ctx->ctx_str, old_ctx->ctx_str, new_ctx->ctx_len);\r\n*new_ctxp = new_ctx;\r\n}\r\nreturn 0;\r\n}\r\nvoid selinux_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\r\n{\r\nkfree(ctx);\r\n}\r\nint selinux_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\r\n{\r\nconst struct task_security_struct *tsec = current_security();\r\nint rc = 0;\r\nif (ctx) {\r\nrc = avc_has_perm(tsec->sid, ctx->ctx_sid,\r\nSECCLASS_ASSOCIATION,\r\nASSOCIATION__SETCONTEXT, NULL);\r\nif (rc == 0)\r\natomic_dec(&selinux_xfrm_refcount);\r\n}\r\nreturn rc;\r\n}\r\nint selinux_xfrm_state_alloc(struct xfrm_state *x, struct xfrm_user_sec_ctx *uctx,\r\nu32 secid)\r\n{\r\nint err;\r\nBUG_ON(!x);\r\nerr = selinux_xfrm_sec_ctx_alloc(&x->security, uctx, secid);\r\nif (err == 0)\r\natomic_inc(&selinux_xfrm_refcount);\r\nreturn err;\r\n}\r\nvoid selinux_xfrm_state_free(struct xfrm_state *x)\r\n{\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\nkfree(ctx);\r\n}\r\nint selinux_xfrm_state_delete(struct xfrm_state *x)\r\n{\r\nconst struct task_security_struct *tsec = current_security();\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\nint rc = 0;\r\nif (ctx) {\r\nrc = avc_has_perm(tsec->sid, ctx->ctx_sid,\r\nSECCLASS_ASSOCIATION,\r\nASSOCIATION__SETCONTEXT, NULL);\r\nif (rc == 0)\r\natomic_dec(&selinux_xfrm_refcount);\r\n}\r\nreturn rc;\r\n}\r\nint selinux_xfrm_sock_rcv_skb(u32 isec_sid, struct sk_buff *skb,\r\nstruct common_audit_data *ad)\r\n{\r\nint i, rc = 0;\r\nstruct sec_path *sp;\r\nu32 sel_sid = SECINITSID_UNLABELED;\r\nsp = skb->sp;\r\nif (sp) {\r\nfor (i = 0; i < sp->len; i++) {\r\nstruct xfrm_state *x = sp->xvec[i];\r\nif (x && selinux_authorizable_xfrm(x)) {\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\nsel_sid = ctx->ctx_sid;\r\nbreak;\r\n}\r\n}\r\n}\r\nrc = avc_has_perm(isec_sid, sel_sid, SECCLASS_ASSOCIATION,\r\nASSOCIATION__RECVFROM, ad);\r\nreturn rc;\r\n}\r\nint selinux_xfrm_postroute_last(u32 isec_sid, struct sk_buff *skb,\r\nstruct common_audit_data *ad, u8 proto)\r\n{\r\nstruct dst_entry *dst;\r\nint rc = 0;\r\ndst = skb_dst(skb);\r\nif (dst) {\r\nstruct dst_entry *dst_test;\r\nfor (dst_test = dst; dst_test != NULL;\r\ndst_test = dst_test->child) {\r\nstruct xfrm_state *x = dst_test->xfrm;\r\nif (x && selinux_authorizable_xfrm(x))\r\ngoto out;\r\n}\r\n}\r\nswitch (proto) {\r\ncase IPPROTO_AH:\r\ncase IPPROTO_ESP:\r\ncase IPPROTO_COMP:\r\ngoto out;\r\ndefault:\r\nbreak;\r\n}\r\nrc = avc_has_perm(isec_sid, SECINITSID_UNLABELED, SECCLASS_ASSOCIATION,\r\nASSOCIATION__SENDTO, ad);\r\nout:\r\nreturn rc;\r\n}
