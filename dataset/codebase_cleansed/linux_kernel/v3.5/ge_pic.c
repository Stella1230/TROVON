void gef_pic_cascade(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int cascade_irq;\r\ncascade_irq = gef_pic_get_irq();\r\nif (cascade_irq != NO_IRQ)\r\ngeneric_handle_irq(cascade_irq);\r\nchip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic void gef_pic_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nu32 mask;\r\nraw_spin_lock_irqsave(&gef_pic_lock, flags);\r\nmask = in_be32(gef_pic_irq_reg_base + GEF_PIC_INTR_MASK(0));\r\nmask &= ~(1 << hwirq);\r\nout_be32(gef_pic_irq_reg_base + GEF_PIC_INTR_MASK(0), mask);\r\nraw_spin_unlock_irqrestore(&gef_pic_lock, flags);\r\n}\r\nstatic void gef_pic_mask_ack(struct irq_data *d)\r\n{\r\ngef_pic_mask(d);\r\n}\r\nstatic void gef_pic_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nunsigned int hwirq = irqd_to_hwirq(d);\r\nu32 mask;\r\nraw_spin_lock_irqsave(&gef_pic_lock, flags);\r\nmask = in_be32(gef_pic_irq_reg_base + GEF_PIC_INTR_MASK(0));\r\nmask |= (1 << hwirq);\r\nout_be32(gef_pic_irq_reg_base + GEF_PIC_INTR_MASK(0), mask);\r\nraw_spin_unlock_irqrestore(&gef_pic_lock, flags);\r\n}\r\nstatic int gef_pic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nirq_set_chip_and_handler(virq, &gef_pic_chip, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int gef_pic_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\n*out_hwirq = intspec[0];\r\nif (intsize > 1)\r\n*out_flags = intspec[1];\r\nelse\r\n*out_flags = IRQ_TYPE_LEVEL_HIGH;\r\nreturn 0;\r\n}\r\nvoid __init gef_pic_init(struct device_node *np)\r\n{\r\nunsigned long flags;\r\ngef_pic_irq_reg_base = of_iomap(np, 0);\r\nraw_spin_lock_irqsave(&gef_pic_lock, flags);\r\nout_be32(gef_pic_irq_reg_base + GEF_PIC_CPU0_INTR_MASK, 0);\r\nout_be32(gef_pic_irq_reg_base + GEF_PIC_CPU1_INTR_MASK, 0);\r\nout_be32(gef_pic_irq_reg_base + GEF_PIC_CPU0_MCP_MASK, 0);\r\nout_be32(gef_pic_irq_reg_base + GEF_PIC_CPU1_MCP_MASK, 0);\r\nraw_spin_unlock_irqrestore(&gef_pic_lock, flags);\r\ngef_pic_cascade_irq = irq_of_parse_and_map(np, 0);\r\nif (gef_pic_cascade_irq == NO_IRQ) {\r\nprintk(KERN_ERR "SBC610: failed to map cascade interrupt");\r\nreturn;\r\n}\r\ngef_pic_irq_host = irq_domain_add_linear(np, GEF_PIC_NUM_IRQS,\r\n&gef_pic_host_ops, NULL);\r\nif (gef_pic_irq_host == NULL)\r\nreturn;\r\nirq_set_chained_handler(gef_pic_cascade_irq, gef_pic_cascade);\r\n}\r\nunsigned int gef_pic_get_irq(void)\r\n{\r\nu32 cause, mask, active;\r\nunsigned int virq = NO_IRQ;\r\nint hwirq;\r\ncause = in_be32(gef_pic_irq_reg_base + GEF_PIC_INTR_STATUS);\r\nmask = in_be32(gef_pic_irq_reg_base + GEF_PIC_INTR_MASK(0));\r\nactive = cause & mask;\r\nif (active) {\r\nfor (hwirq = GEF_PIC_NUM_IRQS - 1; hwirq > -1; hwirq--) {\r\nif (active & (0x1 << hwirq))\r\nbreak;\r\n}\r\nvirq = irq_linear_revmap(gef_pic_irq_host,\r\n(irq_hw_number_t)hwirq);\r\n}\r\nreturn virq;\r\n}
