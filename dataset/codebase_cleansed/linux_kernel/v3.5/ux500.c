static int ux500_musb_init(struct musb *musb)\r\n{\r\nmusb->xceiv = usb_get_transceiver();\r\nif (!musb->xceiv) {\r\npr_err("HS USB OTG: no transceiver configured\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ux500_musb_exit(struct musb *musb)\r\n{\r\nusb_put_transceiver(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic int __devinit ux500_probe(struct platform_device *pdev)\r\n{\r\nstruct musb_hdrc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct platform_device *musb;\r\nstruct ux500_glue *glue;\r\nstruct clk *clk;\r\nint ret = -ENOMEM;\r\nglue = kzalloc(sizeof(*glue), GFP_KERNEL);\r\nif (!glue) {\r\ndev_err(&pdev->dev, "failed to allocate glue context\n");\r\ngoto err0;\r\n}\r\nmusb = platform_device_alloc("musb-hdrc", -1);\r\nif (!musb) {\r\ndev_err(&pdev->dev, "failed to allocate musb device\n");\r\ngoto err1;\r\n}\r\nclk = clk_get(&pdev->dev, "usb");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err2;\r\n}\r\nret = clk_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\ngoto err3;\r\n}\r\nmusb->dev.parent = &pdev->dev;\r\nmusb->dev.dma_mask = pdev->dev.dma_mask;\r\nmusb->dev.coherent_dma_mask = pdev->dev.coherent_dma_mask;\r\nglue->dev = &pdev->dev;\r\nglue->musb = musb;\r\nglue->clk = clk;\r\npdata->platform_ops = &ux500_ops;\r\nplatform_set_drvdata(pdev, glue);\r\nret = platform_device_add_resources(musb, pdev->resource,\r\npdev->num_resources);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add resources\n");\r\ngoto err4;\r\n}\r\nret = platform_device_add_data(musb, pdata, sizeof(*pdata));\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add platform_data\n");\r\ngoto err4;\r\n}\r\nret = platform_device_add(musb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register musb device\n");\r\ngoto err4;\r\n}\r\nreturn 0;\r\nerr4:\r\nclk_disable(clk);\r\nerr3:\r\nclk_put(clk);\r\nerr2:\r\nplatform_device_put(musb);\r\nerr1:\r\nkfree(glue);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int __devexit ux500_remove(struct platform_device *pdev)\r\n{\r\nstruct ux500_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_del(glue->musb);\r\nplatform_device_put(glue->musb);\r\nclk_disable(glue->clk);\r\nclk_put(glue->clk);\r\nkfree(glue);\r\nreturn 0;\r\n}\r\nstatic int ux500_suspend(struct device *dev)\r\n{\r\nstruct ux500_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nusb_phy_set_suspend(musb->xceiv, 1);\r\nclk_disable(glue->clk);\r\nreturn 0;\r\n}\r\nstatic int ux500_resume(struct device *dev)\r\n{\r\nstruct ux500_glue *glue = dev_get_drvdata(dev);\r\nstruct musb *musb = glue_to_musb(glue);\r\nint ret;\r\nret = clk_enable(glue->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable clock\n");\r\nreturn ret;\r\n}\r\nusb_phy_set_suspend(musb->xceiv, 0);\r\nreturn 0;\r\n}\r\nstatic int __init ux500_init(void)\r\n{\r\nreturn platform_driver_register(&ux500_driver);\r\n}\r\nstatic void __exit ux500_exit(void)\r\n{\r\nplatform_driver_unregister(&ux500_driver);\r\n}
