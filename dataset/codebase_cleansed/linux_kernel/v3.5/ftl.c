static int scan_header(partition_t *part)\r\n{\r\nerase_unit_header_t header;\r\nloff_t offset, max_offset;\r\nsize_t ret;\r\nint err;\r\npart->header.FormattedSize = 0;\r\nmax_offset = (0x100000<part->mbd.mtd->size)?0x100000:part->mbd.mtd->size;\r\nfor (offset = 0;\r\n(offset + sizeof(header)) < max_offset;\r\noffset += part->mbd.mtd->erasesize ? : 0x2000) {\r\nerr = mtd_read(part->mbd.mtd, offset, sizeof(header), &ret,\r\n(unsigned char *)&header);\r\nif (err)\r\nreturn err;\r\nif (strcmp(header.DataOrgTuple+3, "FTL100") == 0) break;\r\n}\r\nif (offset == max_offset) {\r\nprintk(KERN_NOTICE "ftl_cs: FTL header not found.\n");\r\nreturn -ENOENT;\r\n}\r\nif (header.BlockSize != 9 ||\r\n(header.EraseUnitSize < 10) || (header.EraseUnitSize > 31) ||\r\n(header.NumTransferUnits >= le16_to_cpu(header.NumEraseUnits))) {\r\nprintk(KERN_NOTICE "ftl_cs: FTL header corrupt!\n");\r\nreturn -1;\r\n}\r\nif ((1 << header.EraseUnitSize) != part->mbd.mtd->erasesize) {\r\nprintk(KERN_NOTICE "ftl: FTL EraseUnitSize %x != MTD erasesize %x\n",\r\n1 << header.EraseUnitSize,part->mbd.mtd->erasesize);\r\nreturn -1;\r\n}\r\npart->header = header;\r\nreturn 0;\r\n}\r\nstatic int build_maps(partition_t *part)\r\n{\r\nerase_unit_header_t header;\r\nuint16_t xvalid, xtrans, i;\r\nunsigned blocks, j;\r\nint hdr_ok, ret = -1;\r\nssize_t retval;\r\nloff_t offset;\r\npart->DataUnits = le16_to_cpu(part->header.NumEraseUnits) -\r\npart->header.NumTransferUnits;\r\npart->EUNInfo = kmalloc(part->DataUnits * sizeof(struct eun_info_t),\r\nGFP_KERNEL);\r\nif (!part->EUNInfo)\r\ngoto out;\r\nfor (i = 0; i < part->DataUnits; i++)\r\npart->EUNInfo[i].Offset = 0xffffffff;\r\npart->XferInfo =\r\nkmalloc(part->header.NumTransferUnits * sizeof(struct xfer_info_t),\r\nGFP_KERNEL);\r\nif (!part->XferInfo)\r\ngoto out_EUNInfo;\r\nxvalid = xtrans = 0;\r\nfor (i = 0; i < le16_to_cpu(part->header.NumEraseUnits); i++) {\r\noffset = ((i + le16_to_cpu(part->header.FirstPhysicalEUN))\r\n<< part->header.EraseUnitSize);\r\nret = mtd_read(part->mbd.mtd, offset, sizeof(header), &retval,\r\n(unsigned char *)&header);\r\nif (ret)\r\ngoto out_XferInfo;\r\nret = -1;\r\nhdr_ok = (strcmp(header.DataOrgTuple+3, "FTL100") == 0);\r\nif (hdr_ok && (le16_to_cpu(header.LogicalEUN) < part->DataUnits) &&\r\n(part->EUNInfo[le16_to_cpu(header.LogicalEUN)].Offset == 0xffffffff)) {\r\npart->EUNInfo[le16_to_cpu(header.LogicalEUN)].Offset = offset;\r\npart->EUNInfo[le16_to_cpu(header.LogicalEUN)].EraseCount =\r\nle32_to_cpu(header.EraseCount);\r\nxvalid++;\r\n} else {\r\nif (xtrans == part->header.NumTransferUnits) {\r\nprintk(KERN_NOTICE "ftl_cs: format error: too many "\r\n"transfer units!\n");\r\ngoto out_XferInfo;\r\n}\r\nif (hdr_ok && (le16_to_cpu(header.LogicalEUN) == 0xffff)) {\r\npart->XferInfo[xtrans].state = XFER_PREPARED;\r\npart->XferInfo[xtrans].EraseCount = le32_to_cpu(header.EraseCount);\r\n} else {\r\npart->XferInfo[xtrans].state = XFER_UNKNOWN;\r\npart->XferInfo[xtrans].EraseCount =\r\nle32_to_cpu(part->header.EraseCount);\r\n}\r\npart->XferInfo[xtrans].Offset = offset;\r\nxtrans++;\r\n}\r\n}\r\nheader = part->header;\r\nif ((xtrans != header.NumTransferUnits) ||\r\n(xvalid+xtrans != le16_to_cpu(header.NumEraseUnits))) {\r\nprintk(KERN_NOTICE "ftl_cs: format error: erase units "\r\n"don't add up!\n");\r\ngoto out_XferInfo;\r\n}\r\nblocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;\r\npart->VirtualBlockMap = vmalloc(blocks * sizeof(uint32_t));\r\nif (!part->VirtualBlockMap)\r\ngoto out_XferInfo;\r\nmemset(part->VirtualBlockMap, 0xff, blocks * sizeof(uint32_t));\r\npart->BlocksPerUnit = (1 << header.EraseUnitSize) >> header.BlockSize;\r\npart->bam_cache = kmalloc(part->BlocksPerUnit * sizeof(uint32_t),\r\nGFP_KERNEL);\r\nif (!part->bam_cache)\r\ngoto out_VirtualBlockMap;\r\npart->bam_index = 0xffff;\r\npart->FreeTotal = 0;\r\nfor (i = 0; i < part->DataUnits; i++) {\r\npart->EUNInfo[i].Free = 0;\r\npart->EUNInfo[i].Deleted = 0;\r\noffset = part->EUNInfo[i].Offset + le32_to_cpu(header.BAMOffset);\r\nret = mtd_read(part->mbd.mtd, offset,\r\npart->BlocksPerUnit * sizeof(uint32_t), &retval,\r\n(unsigned char *)part->bam_cache);\r\nif (ret)\r\ngoto out_bam_cache;\r\nfor (j = 0; j < part->BlocksPerUnit; j++) {\r\nif (BLOCK_FREE(le32_to_cpu(part->bam_cache[j]))) {\r\npart->EUNInfo[i].Free++;\r\npart->FreeTotal++;\r\n} else if ((BLOCK_TYPE(le32_to_cpu(part->bam_cache[j])) == BLOCK_DATA) &&\r\n(BLOCK_NUMBER(le32_to_cpu(part->bam_cache[j])) < blocks))\r\npart->VirtualBlockMap[BLOCK_NUMBER(le32_to_cpu(part->bam_cache[j]))] =\r\n(i << header.EraseUnitSize) + (j << header.BlockSize);\r\nelse if (BLOCK_DELETED(le32_to_cpu(part->bam_cache[j])))\r\npart->EUNInfo[i].Deleted++;\r\n}\r\n}\r\nret = 0;\r\ngoto out;\r\nout_bam_cache:\r\nkfree(part->bam_cache);\r\nout_VirtualBlockMap:\r\nvfree(part->VirtualBlockMap);\r\nout_XferInfo:\r\nkfree(part->XferInfo);\r\nout_EUNInfo:\r\nkfree(part->EUNInfo);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int erase_xfer(partition_t *part,\r\nuint16_t xfernum)\r\n{\r\nint ret;\r\nstruct xfer_info_t *xfer;\r\nstruct erase_info *erase;\r\nxfer = &part->XferInfo[xfernum];\r\npr_debug("ftl_cs: erasing xfer unit at 0x%x\n", xfer->Offset);\r\nxfer->state = XFER_ERASING;\r\nerase=kmalloc(sizeof(struct erase_info), GFP_KERNEL);\r\nif (!erase)\r\nreturn -ENOMEM;\r\nerase->mtd = part->mbd.mtd;\r\nerase->callback = ftl_erase_callback;\r\nerase->addr = xfer->Offset;\r\nerase->len = 1 << part->header.EraseUnitSize;\r\nerase->priv = (u_long)part;\r\nret = mtd_erase(part->mbd.mtd, erase);\r\nif (!ret)\r\nxfer->EraseCount++;\r\nelse\r\nkfree(erase);\r\nreturn ret;\r\n}\r\nstatic void ftl_erase_callback(struct erase_info *erase)\r\n{\r\npartition_t *part;\r\nstruct xfer_info_t *xfer;\r\nint i;\r\npart = (partition_t *)(erase->priv);\r\nfor (i = 0; i < part->header.NumTransferUnits; i++)\r\nif (part->XferInfo[i].Offset == erase->addr) break;\r\nif (i == part->header.NumTransferUnits) {\r\nprintk(KERN_NOTICE "ftl_cs: internal error: "\r\n"erase lookup failed!\n");\r\nreturn;\r\n}\r\nxfer = &part->XferInfo[i];\r\nif (erase->state == MTD_ERASE_DONE)\r\nxfer->state = XFER_ERASED;\r\nelse {\r\nxfer->state = XFER_FAILED;\r\nprintk(KERN_NOTICE "ftl_cs: erase failed: state = %d\n",\r\nerase->state);\r\n}\r\nkfree(erase);\r\n}\r\nstatic int prepare_xfer(partition_t *part, int i)\r\n{\r\nerase_unit_header_t header;\r\nstruct xfer_info_t *xfer;\r\nint nbam, ret;\r\nuint32_t ctl;\r\nssize_t retlen;\r\nloff_t offset;\r\nxfer = &part->XferInfo[i];\r\nxfer->state = XFER_FAILED;\r\npr_debug("ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);\r\nheader = part->header;\r\nheader.LogicalEUN = cpu_to_le16(0xffff);\r\nheader.EraseCount = cpu_to_le32(xfer->EraseCount);\r\nret = mtd_write(part->mbd.mtd, xfer->Offset, sizeof(header), &retlen,\r\n(u_char *)&header);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nnbam = (part->BlocksPerUnit * sizeof(uint32_t) +\r\nle32_to_cpu(part->header.BAMOffset) + SECTOR_SIZE - 1) / SECTOR_SIZE;\r\noffset = xfer->Offset + le32_to_cpu(part->header.BAMOffset);\r\nctl = cpu_to_le32(BLOCK_CONTROL);\r\nfor (i = 0; i < nbam; i++, offset += sizeof(uint32_t)) {\r\nret = mtd_write(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,\r\n(u_char *)&ctl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nxfer->state = XFER_PREPARED;\r\nreturn 0;\r\n}\r\nstatic int copy_erase_unit(partition_t *part, uint16_t srcunit,\r\nuint16_t xferunit)\r\n{\r\nu_char buf[SECTOR_SIZE];\r\nstruct eun_info_t *eun;\r\nstruct xfer_info_t *xfer;\r\nuint32_t src, dest, free, i;\r\nuint16_t unit;\r\nint ret;\r\nssize_t retlen;\r\nloff_t offset;\r\nuint16_t srcunitswap = cpu_to_le16(srcunit);\r\neun = &part->EUNInfo[srcunit];\r\nxfer = &part->XferInfo[xferunit];\r\npr_debug("ftl_cs: copying block 0x%x to 0x%x\n",\r\neun->Offset, xfer->Offset);\r\nif (part->bam_index != srcunit) {\r\noffset = eun->Offset + le32_to_cpu(part->header.BAMOffset);\r\nret = mtd_read(part->mbd.mtd, offset,\r\npart->BlocksPerUnit * sizeof(uint32_t), &retlen,\r\n(u_char *)(part->bam_cache));\r\npart->bam_index = 0xffff;\r\nif (ret) {\r\nprintk( KERN_WARNING "ftl: Failed to read BAM cache in copy_erase_unit()!\n");\r\nreturn ret;\r\n}\r\n}\r\nxfer->state = XFER_UNKNOWN;\r\noffset = xfer->Offset + 20;\r\nunit = cpu_to_le16(0x7fff);\r\nret = mtd_write(part->mbd.mtd, offset, sizeof(uint16_t), &retlen,\r\n(u_char *)&unit);\r\nif (ret) {\r\nprintk( KERN_WARNING "ftl: Failed to write back to BAM cache in copy_erase_unit()!\n");\r\nreturn ret;\r\n}\r\nsrc = eun->Offset; dest = xfer->Offset;\r\nfree = 0;\r\nret = 0;\r\nfor (i = 0; i < part->BlocksPerUnit; i++) {\r\nswitch (BLOCK_TYPE(le32_to_cpu(part->bam_cache[i]))) {\r\ncase BLOCK_CONTROL:\r\nbreak;\r\ncase BLOCK_DATA:\r\ncase BLOCK_REPLACEMENT:\r\nret = mtd_read(part->mbd.mtd, src, SECTOR_SIZE, &retlen,\r\n(u_char *)buf);\r\nif (ret) {\r\nprintk(KERN_WARNING "ftl: Error reading old xfer unit in copy_erase_unit\n");\r\nreturn ret;\r\n}\r\nret = mtd_write(part->mbd.mtd, dest, SECTOR_SIZE, &retlen,\r\n(u_char *)buf);\r\nif (ret) {\r\nprintk(KERN_WARNING "ftl: Error writing new xfer unit in copy_erase_unit\n");\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\npart->bam_cache[i] = cpu_to_le32(0xffffffff);\r\nfree++;\r\nbreak;\r\n}\r\nsrc += SECTOR_SIZE;\r\ndest += SECTOR_SIZE;\r\n}\r\nret = mtd_write(part->mbd.mtd,\r\nxfer->Offset + le32_to_cpu(part->header.BAMOffset),\r\npart->BlocksPerUnit * sizeof(int32_t),\r\n&retlen,\r\n(u_char *)part->bam_cache);\r\nif (ret) {\r\nprintk( KERN_WARNING "ftl: Error writing BAM in copy_erase_unit\n");\r\nreturn ret;\r\n}\r\nret = mtd_write(part->mbd.mtd, xfer->Offset + 20, sizeof(uint16_t),\r\n&retlen, (u_char *)&srcunitswap);\r\nif (ret) {\r\nprintk(KERN_WARNING "ftl: Error writing new LogicalEUN in copy_erase_unit\n");\r\nreturn ret;\r\n}\r\ni = xfer->EraseCount;\r\nxfer->EraseCount = eun->EraseCount;\r\neun->EraseCount = i;\r\ni = xfer->Offset;\r\nxfer->Offset = eun->Offset;\r\neun->Offset = i;\r\npart->FreeTotal -= eun->Free;\r\npart->FreeTotal += free;\r\neun->Free = free;\r\neun->Deleted = 0;\r\npart->bam_index = srcunit;\r\nreturn 0;\r\n}\r\nstatic int reclaim_block(partition_t *part)\r\n{\r\nuint16_t i, eun, xfer;\r\nuint32_t best;\r\nint queued, ret;\r\npr_debug("ftl_cs: reclaiming space...\n");\r\npr_debug("NumTransferUnits == %x\n", part->header.NumTransferUnits);\r\nbest = 0xffffffff; xfer = 0xffff;\r\ndo {\r\nqueued = 0;\r\nfor (i = 0; i < part->header.NumTransferUnits; i++) {\r\nint n=0;\r\nif (part->XferInfo[i].state == XFER_UNKNOWN) {\r\npr_debug("XferInfo[%d].state == XFER_UNKNOWN\n",i);\r\nn=1;\r\nerase_xfer(part, i);\r\n}\r\nif (part->XferInfo[i].state == XFER_ERASING) {\r\npr_debug("XferInfo[%d].state == XFER_ERASING\n",i);\r\nn=1;\r\nqueued = 1;\r\n}\r\nelse if (part->XferInfo[i].state == XFER_ERASED) {\r\npr_debug("XferInfo[%d].state == XFER_ERASED\n",i);\r\nn=1;\r\nprepare_xfer(part, i);\r\n}\r\nif (part->XferInfo[i].state == XFER_PREPARED) {\r\npr_debug("XferInfo[%d].state == XFER_PREPARED\n",i);\r\nn=1;\r\nif (part->XferInfo[i].EraseCount <= best) {\r\nbest = part->XferInfo[i].EraseCount;\r\nxfer = i;\r\n}\r\n}\r\nif (!n)\r\npr_debug("XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);\r\n}\r\nif (xfer == 0xffff) {\r\nif (queued) {\r\npr_debug("ftl_cs: waiting for transfer "\r\n"unit to be prepared...\n");\r\nmtd_sync(part->mbd.mtd);\r\n} else {\r\nstatic int ne = 0;\r\nif (++ne < 5)\r\nprintk(KERN_NOTICE "ftl_cs: reclaim failed: no "\r\n"suitable transfer units!\n");\r\nelse\r\npr_debug("ftl_cs: reclaim failed: no "\r\n"suitable transfer units!\n");\r\nreturn -EIO;\r\n}\r\n}\r\n} while (xfer == 0xffff);\r\neun = 0;\r\nif ((jiffies % shuffle_freq) == 0) {\r\npr_debug("ftl_cs: recycling freshest block...\n");\r\nbest = 0xffffffff;\r\nfor (i = 0; i < part->DataUnits; i++)\r\nif (part->EUNInfo[i].EraseCount <= best) {\r\nbest = part->EUNInfo[i].EraseCount;\r\neun = i;\r\n}\r\n} else {\r\nbest = 0;\r\nfor (i = 0; i < part->DataUnits; i++)\r\nif (part->EUNInfo[i].Deleted >= best) {\r\nbest = part->EUNInfo[i].Deleted;\r\neun = i;\r\n}\r\nif (best == 0) {\r\nstatic int ne = 0;\r\nif (++ne < 5)\r\nprintk(KERN_NOTICE "ftl_cs: reclaim failed: "\r\n"no free blocks!\n");\r\nelse\r\npr_debug("ftl_cs: reclaim failed: "\r\n"no free blocks!\n");\r\nreturn -EIO;\r\n}\r\n}\r\nret = copy_erase_unit(part, eun, xfer);\r\nif (!ret)\r\nerase_xfer(part, xfer);\r\nelse\r\nprintk(KERN_NOTICE "ftl_cs: copy_erase_unit failed!\n");\r\nreturn ret;\r\n}\r\nstatic void dump_lists(partition_t *part)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "ftl_cs: Free total = %d\n", part->FreeTotal);\r\nfor (i = 0; i < part->DataUnits; i++)\r\nprintk(KERN_DEBUG "ftl_cs: unit %d: %d phys, %d free, "\r\n"%d deleted\n", i,\r\npart->EUNInfo[i].Offset >> part->header.EraseUnitSize,\r\npart->EUNInfo[i].Free, part->EUNInfo[i].Deleted);\r\n}\r\nstatic uint32_t find_free(partition_t *part)\r\n{\r\nuint16_t stop, eun;\r\nuint32_t blk;\r\nsize_t retlen;\r\nint ret;\r\nstop = (part->bam_index == 0xffff) ? 0 : part->bam_index;\r\neun = stop;\r\ndo {\r\nif (part->EUNInfo[eun].Free != 0) break;\r\nif (++eun == part->DataUnits) eun = 0;\r\n} while (eun != stop);\r\nif (part->EUNInfo[eun].Free == 0)\r\nreturn 0;\r\nif (eun != part->bam_index) {\r\npart->bam_index = 0xffff;\r\nret = mtd_read(part->mbd.mtd,\r\npart->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),\r\npart->BlocksPerUnit * sizeof(uint32_t),\r\n&retlen,\r\n(u_char *)(part->bam_cache));\r\nif (ret) {\r\nprintk(KERN_WARNING"ftl: Error reading BAM in find_free\n");\r\nreturn 0;\r\n}\r\npart->bam_index = eun;\r\n}\r\nfor (blk = 0; blk < part->BlocksPerUnit; blk++)\r\nif (BLOCK_FREE(le32_to_cpu(part->bam_cache[blk]))) break;\r\nif (blk == part->BlocksPerUnit) {\r\n#ifdef PSYCHO_DEBUG\r\nstatic int ne = 0;\r\nif (++ne == 1)\r\ndump_lists(part);\r\n#endif\r\nprintk(KERN_NOTICE "ftl_cs: bad free list!\n");\r\nreturn 0;\r\n}\r\npr_debug("ftl_cs: found free block at %d in %d\n", blk, eun);\r\nreturn blk;\r\n}\r\nstatic int ftl_read(partition_t *part, caddr_t buffer,\r\nu_long sector, u_long nblocks)\r\n{\r\nuint32_t log_addr, bsize;\r\nu_long i;\r\nint ret;\r\nsize_t offset, retlen;\r\npr_debug("ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",\r\npart, sector, nblocks);\r\nif (!(part->state & FTL_FORMATTED)) {\r\nprintk(KERN_NOTICE "ftl_cs: bad partition\n");\r\nreturn -EIO;\r\n}\r\nbsize = 1 << part->header.EraseUnitSize;\r\nfor (i = 0; i < nblocks; i++) {\r\nif (((sector+i) * SECTOR_SIZE) >= le32_to_cpu(part->header.FormattedSize)) {\r\nprintk(KERN_NOTICE "ftl_cs: bad read offset\n");\r\nreturn -EIO;\r\n}\r\nlog_addr = part->VirtualBlockMap[sector+i];\r\nif (log_addr == 0xffffffff)\r\nmemset(buffer, 0, SECTOR_SIZE);\r\nelse {\r\noffset = (part->EUNInfo[log_addr / bsize].Offset\r\n+ (log_addr % bsize));\r\nret = mtd_read(part->mbd.mtd, offset, SECTOR_SIZE, &retlen,\r\n(u_char *)buffer);\r\nif (ret) {\r\nprintk(KERN_WARNING "Error reading MTD device in ftl_read()\n");\r\nreturn ret;\r\n}\r\n}\r\nbuffer += SECTOR_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_bam_entry(partition_t *part, uint32_t log_addr,\r\nuint32_t virt_addr)\r\n{\r\nuint32_t bsize, blk, le_virt_addr;\r\n#ifdef PSYCHO_DEBUG\r\nuint32_t old_addr;\r\n#endif\r\nuint16_t eun;\r\nint ret;\r\nsize_t retlen, offset;\r\npr_debug("ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\n",\r\npart, log_addr, virt_addr);\r\nbsize = 1 << part->header.EraseUnitSize;\r\neun = log_addr / bsize;\r\nblk = (log_addr % bsize) / SECTOR_SIZE;\r\noffset = (part->EUNInfo[eun].Offset + blk * sizeof(uint32_t) +\r\nle32_to_cpu(part->header.BAMOffset));\r\n#ifdef PSYCHO_DEBUG\r\nret = mtd_read(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,\r\n(u_char *)&old_addr);\r\nif (ret) {\r\nprintk(KERN_WARNING"ftl: Error reading old_addr in set_bam_entry: %d\n",ret);\r\nreturn ret;\r\n}\r\nold_addr = le32_to_cpu(old_addr);\r\nif (((virt_addr == 0xfffffffe) && !BLOCK_FREE(old_addr)) ||\r\n((virt_addr == 0) && (BLOCK_TYPE(old_addr) != BLOCK_DATA)) ||\r\n(!BLOCK_DELETED(virt_addr) && (old_addr != 0xfffffffe))) {\r\nstatic int ne = 0;\r\nif (++ne < 5) {\r\nprintk(KERN_NOTICE "ftl_cs: set_bam_entry() inconsistency!\n");\r\nprintk(KERN_NOTICE "ftl_cs: log_addr = 0x%x, old = 0x%x"\r\n", new = 0x%x\n", log_addr, old_addr, virt_addr);\r\n}\r\nreturn -EIO;\r\n}\r\n#endif\r\nle_virt_addr = cpu_to_le32(virt_addr);\r\nif (part->bam_index == eun) {\r\n#ifdef PSYCHO_DEBUG\r\nif (le32_to_cpu(part->bam_cache[blk]) != old_addr) {\r\nstatic int ne = 0;\r\nif (++ne < 5) {\r\nprintk(KERN_NOTICE "ftl_cs: set_bam_entry() "\r\n"inconsistency!\n");\r\nprintk(KERN_NOTICE "ftl_cs: log_addr = 0x%x, cache"\r\n" = 0x%x\n",\r\nle32_to_cpu(part->bam_cache[blk]), old_addr);\r\n}\r\nreturn -EIO;\r\n}\r\n#endif\r\npart->bam_cache[blk] = le_virt_addr;\r\n}\r\nret = mtd_write(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,\r\n(u_char *)&le_virt_addr);\r\nif (ret) {\r\nprintk(KERN_NOTICE "ftl_cs: set_bam_entry() failed!\n");\r\nprintk(KERN_NOTICE "ftl_cs: log_addr = 0x%x, new = 0x%x\n",\r\nlog_addr, virt_addr);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ftl_write(partition_t *part, caddr_t buffer,\r\nu_long sector, u_long nblocks)\r\n{\r\nuint32_t bsize, log_addr, virt_addr, old_addr, blk;\r\nu_long i;\r\nint ret;\r\nsize_t retlen, offset;\r\npr_debug("ftl_cs: ftl_write(0x%p, %ld, %ld)\n",\r\npart, sector, nblocks);\r\nif (!(part->state & FTL_FORMATTED)) {\r\nprintk(KERN_NOTICE "ftl_cs: bad partition\n");\r\nreturn -EIO;\r\n}\r\nwhile (part->FreeTotal < nblocks) {\r\nret = reclaim_block(part);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbsize = 1 << part->header.EraseUnitSize;\r\nvirt_addr = sector * SECTOR_SIZE | BLOCK_DATA;\r\nfor (i = 0; i < nblocks; i++) {\r\nif (virt_addr >= le32_to_cpu(part->header.FormattedSize)) {\r\nprintk(KERN_NOTICE "ftl_cs: bad write offset\n");\r\nreturn -EIO;\r\n}\r\nblk = find_free(part);\r\nif (blk == 0) {\r\nstatic int ne = 0;\r\nif (++ne < 5)\r\nprintk(KERN_NOTICE "ftl_cs: internal error: "\r\n"no free blocks!\n");\r\nreturn -ENOSPC;\r\n}\r\nlog_addr = part->bam_index * bsize + blk * SECTOR_SIZE;\r\npart->EUNInfo[part->bam_index].Free--;\r\npart->FreeTotal--;\r\nif (set_bam_entry(part, log_addr, 0xfffffffe))\r\nreturn -EIO;\r\npart->EUNInfo[part->bam_index].Deleted++;\r\noffset = (part->EUNInfo[part->bam_index].Offset +\r\nblk * SECTOR_SIZE);\r\nret = mtd_write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen, buffer);\r\nif (ret) {\r\nprintk(KERN_NOTICE "ftl_cs: block write failed!\n");\r\nprintk(KERN_NOTICE "ftl_cs: log_addr = 0x%x, virt_addr"\r\n" = 0x%x, Offset = 0x%zx\n", log_addr, virt_addr,\r\noffset);\r\nreturn -EIO;\r\n}\r\nold_addr = part->VirtualBlockMap[sector+i];\r\nif (old_addr != 0xffffffff) {\r\npart->VirtualBlockMap[sector+i] = 0xffffffff;\r\npart->EUNInfo[old_addr/bsize].Deleted++;\r\nif (set_bam_entry(part, old_addr, 0))\r\nreturn -EIO;\r\n}\r\nif (set_bam_entry(part, log_addr, virt_addr))\r\nreturn -EIO;\r\npart->VirtualBlockMap[sector+i] = log_addr;\r\npart->EUNInfo[part->bam_index].Deleted--;\r\nbuffer += SECTOR_SIZE;\r\nvirt_addr += SECTOR_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\r\n{\r\npartition_t *part = (void *)dev;\r\nu_long sect;\r\nsect = le32_to_cpu(part->header.FormattedSize)/SECTOR_SIZE;\r\ngeo->heads = 1;\r\ngeo->sectors = 8;\r\ngeo->cylinders = sect >> 3;\r\nreturn 0;\r\n}\r\nstatic int ftl_readsect(struct mtd_blktrans_dev *dev,\r\nunsigned long block, char *buf)\r\n{\r\nreturn ftl_read((void *)dev, buf, block, 1);\r\n}\r\nstatic int ftl_writesect(struct mtd_blktrans_dev *dev,\r\nunsigned long block, char *buf)\r\n{\r\nreturn ftl_write((void *)dev, buf, block, 1);\r\n}\r\nstatic int ftl_discardsect(struct mtd_blktrans_dev *dev,\r\nunsigned long sector, unsigned nr_sects)\r\n{\r\npartition_t *part = (void *)dev;\r\nuint32_t bsize = 1 << part->header.EraseUnitSize;\r\npr_debug("FTL erase sector %ld for %d sectors\n",\r\nsector, nr_sects);\r\nwhile (nr_sects) {\r\nuint32_t old_addr = part->VirtualBlockMap[sector];\r\nif (old_addr != 0xffffffff) {\r\npart->VirtualBlockMap[sector] = 0xffffffff;\r\npart->EUNInfo[old_addr/bsize].Deleted++;\r\nif (set_bam_entry(part, old_addr, 0))\r\nreturn -EIO;\r\n}\r\nnr_sects--;\r\nsector++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ftl_freepart(partition_t *part)\r\n{\r\nvfree(part->VirtualBlockMap);\r\npart->VirtualBlockMap = NULL;\r\nkfree(part->VirtualPageMap);\r\npart->VirtualPageMap = NULL;\r\nkfree(part->EUNInfo);\r\npart->EUNInfo = NULL;\r\nkfree(part->XferInfo);\r\npart->XferInfo = NULL;\r\nkfree(part->bam_cache);\r\npart->bam_cache = NULL;\r\n}\r\nstatic void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\r\n{\r\npartition_t *partition;\r\npartition = kzalloc(sizeof(partition_t), GFP_KERNEL);\r\nif (!partition) {\r\nprintk(KERN_WARNING "No memory to scan for FTL on %s\n",\r\nmtd->name);\r\nreturn;\r\n}\r\npartition->mbd.mtd = mtd;\r\nif ((scan_header(partition) == 0) &&\r\n(build_maps(partition) == 0)) {\r\npartition->state = FTL_FORMATTED;\r\n#ifdef PCMCIA_DEBUG\r\nprintk(KERN_INFO "ftl_cs: opening %d KiB FTL partition\n",\r\nle32_to_cpu(partition->header.FormattedSize) >> 10);\r\n#endif\r\npartition->mbd.size = le32_to_cpu(partition->header.FormattedSize) >> 9;\r\npartition->mbd.tr = tr;\r\npartition->mbd.devnum = -1;\r\nif (!add_mtd_blktrans_dev((void *)partition))\r\nreturn;\r\n}\r\nftl_freepart(partition);\r\nkfree(partition);\r\n}\r\nstatic void ftl_remove_dev(struct mtd_blktrans_dev *dev)\r\n{\r\ndel_mtd_blktrans_dev(dev);\r\nftl_freepart((partition_t *)dev);\r\n}\r\nstatic int __init init_ftl(void)\r\n{\r\nreturn register_mtd_blktrans(&ftl_tr);\r\n}\r\nstatic void __exit cleanup_ftl(void)\r\n{\r\nderegister_mtd_blktrans(&ftl_tr);\r\n}
