static void DoC_Delay(struct DiskOnChip *doc, unsigned short cycles)\r\n{\r\nvolatile char dummy;\r\nint i;\r\nfor (i = 0; i < cycles; i++) {\r\nif (DoC_is_Millennium(doc))\r\ndummy = ReadDOC(doc->virtadr, NOP);\r\nelse\r\ndummy = ReadDOC(doc->virtadr, DOCStatus);\r\n}\r\n}\r\nstatic int _DoC_WaitReady(struct DiskOnChip *doc)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nunsigned long timeo = jiffies + (HZ * 10);\r\npr_debug("_DoC_WaitReady called for out-of-line wait\n");\r\nwhile (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {\r\nDoC_Delay(doc, 2);\r\nif (time_after(jiffies, timeo)) {\r\npr_debug("_DoC_WaitReady timed out.\n");\r\nreturn -EIO;\r\n}\r\nudelay(1);\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int DoC_WaitReady(struct DiskOnChip *doc)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nint ret = 0;\r\nDoC_Delay(doc, 4);\r\nif (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B))\r\nret = _DoC_WaitReady(doc);\r\nDoC_Delay(doc, 2);\r\nreturn ret;\r\n}\r\nstatic int DoC_Command(struct DiskOnChip *doc, unsigned char command,\r\nunsigned char xtraflags)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nif (DoC_is_2000(doc))\r\nxtraflags |= CDSN_CTRL_FLASH_IO;\r\nWriteDOC(xtraflags | CDSN_CTRL_CLE | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(doc, 4);\r\nif (DoC_is_Millennium(doc))\r\nWriteDOC(command, docptr, CDSNSlowIO);\r\nWriteDOC_(command, docptr, doc->ioreg);\r\nif (DoC_is_Millennium(doc))\r\nWriteDOC(command, docptr, WritePipeTerm);\r\nWriteDOC(xtraflags | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(doc, 4);\r\nreturn DoC_WaitReady(doc);\r\n}\r\nstatic int DoC_Address(struct DiskOnChip *doc, int numbytes, unsigned long ofs,\r\nunsigned char xtraflags1, unsigned char xtraflags2)\r\n{\r\nint i;\r\nvoid __iomem *docptr = doc->virtadr;\r\nif (DoC_is_2000(doc))\r\nxtraflags1 |= CDSN_CTRL_FLASH_IO;\r\nWriteDOC(xtraflags1 | CDSN_CTRL_ALE | CDSN_CTRL_CE, docptr, CDSNControl);\r\nDoC_Delay(doc, 4);\r\nif (numbytes == ADDR_COLUMN || numbytes == ADDR_COLUMN_PAGE) {\r\nif (DoC_is_Millennium(doc))\r\nWriteDOC(ofs & 0xff, docptr, CDSNSlowIO);\r\nWriteDOC_(ofs & 0xff, docptr, doc->ioreg);\r\n}\r\nif (doc->page256) {\r\nofs = ofs >> 8;\r\n} else {\r\nofs = ofs >> 9;\r\n}\r\nif (numbytes == ADDR_PAGE || numbytes == ADDR_COLUMN_PAGE) {\r\nfor (i = 0; i < doc->pageadrlen; i++, ofs = ofs >> 8) {\r\nif (DoC_is_Millennium(doc))\r\nWriteDOC(ofs & 0xff, docptr, CDSNSlowIO);\r\nWriteDOC_(ofs & 0xff, docptr, doc->ioreg);\r\n}\r\n}\r\nif (DoC_is_Millennium(doc))\r\nWriteDOC(ofs & 0xff, docptr, WritePipeTerm);\r\nDoC_Delay(doc, 2);\r\nWriteDOC(xtraflags1 | xtraflags2 | CDSN_CTRL_CE, docptr,\r\nCDSNControl);\r\nDoC_Delay(doc, 4);\r\nreturn DoC_WaitReady(doc);\r\n}\r\nstatic void DoC_ReadBuf(struct DiskOnChip *doc, u_char * buf, int len)\r\n{\r\nvolatile int dummy;\r\nint modulus = 0xffff;\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (len <= 0)\r\nreturn;\r\nif (DoC_is_Millennium(doc)) {\r\ndummy = ReadDOC(docptr, ReadPipeInit);\r\nlen--;\r\nmodulus = 0xff;\r\n}\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = ReadDOC_(docptr, doc->ioreg + (i & modulus));\r\nif (DoC_is_Millennium(doc)) {\r\nbuf[i] = ReadDOC(docptr, LastDataRead);\r\n}\r\n}\r\nstatic void DoC_WriteBuf(struct DiskOnChip *doc, const u_char * buf, int len)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nint i;\r\nif (len <= 0)\r\nreturn;\r\nfor (i = 0; i < len; i++)\r\nWriteDOC_(buf[i], docptr, doc->ioreg + i);\r\nif (DoC_is_Millennium(doc)) {\r\nWriteDOC(0x00, docptr, WritePipeTerm);\r\n}\r\n}\r\nstatic inline int DoC_SelectChip(struct DiskOnChip *doc, int chip)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nWriteDOC(CDSN_CTRL_WP, docptr, CDSNControl);\r\nDoC_Delay(doc, 4);\r\nWriteDOC(chip, docptr, CDSNDeviceSelect);\r\nDoC_Delay(doc, 4);\r\nWriteDOC(CDSN_CTRL_CE | CDSN_CTRL_FLASH_IO | CDSN_CTRL_WP, docptr,\r\nCDSNControl);\r\nDoC_Delay(doc, 4);\r\nreturn DoC_WaitReady(doc);\r\n}\r\nstatic inline int DoC_SelectFloor(struct DiskOnChip *doc, int floor)\r\n{\r\nvoid __iomem *docptr = doc->virtadr;\r\nWriteDOC(floor, docptr, FloorSelect);\r\nreturn DoC_WaitReady(doc);\r\n}\r\nstatic int DoC_IdentChip(struct DiskOnChip *doc, int floor, int chip)\r\n{\r\nint mfr, id, i, j;\r\nvolatile char dummy;\r\nDoC_SelectFloor(doc, floor);\r\nDoC_SelectChip(doc, chip);\r\nif (DoC_Command(doc, NAND_CMD_RESET, CDSN_CTRL_WP)) {\r\npr_debug("DoC_Command (reset) for %d,%d returned true\n",\r\nfloor, chip);\r\nreturn 0;\r\n}\r\nif (DoC_Command(doc, NAND_CMD_READID, CDSN_CTRL_WP)) {\r\npr_debug("DoC_Command (ReadID) for %d,%d returned true\n",\r\nfloor, chip);\r\nreturn 0;\r\n}\r\nDoC_Address(doc, ADDR_COLUMN, 0, CDSN_CTRL_WP, 0);\r\nif (DoC_is_Millennium(doc)) {\r\nDoC_Delay(doc, 2);\r\ndummy = ReadDOC(doc->virtadr, ReadPipeInit);\r\nmfr = ReadDOC(doc->virtadr, LastDataRead);\r\nDoC_Delay(doc, 2);\r\ndummy = ReadDOC(doc->virtadr, ReadPipeInit);\r\nid = ReadDOC(doc->virtadr, LastDataRead);\r\n} else {\r\ndummy = ReadDOC(doc->virtadr, CDSNSlowIO);\r\nDoC_Delay(doc, 2);\r\nmfr = ReadDOC_(doc->virtadr, doc->ioreg);\r\ndummy = ReadDOC(doc->virtadr, CDSNSlowIO);\r\nDoC_Delay(doc, 2);\r\nid = ReadDOC_(doc->virtadr, doc->ioreg);\r\n}\r\nif (mfr == 0xff || mfr == 0)\r\nreturn 0;\r\nif (doc->mfr) {\r\nif (doc->mfr == mfr && doc->id == id)\r\nreturn 1;\r\nelse\r\nprintk(KERN_WARNING\r\n"Flash chip at floor %d, chip %d is different:\n",\r\nfloor, chip);\r\n}\r\nfor (i = 0; nand_flash_ids[i].name != NULL; i++) {\r\nif (id == nand_flash_ids[i].id) {\r\nfor (j = 0; nand_manuf_ids[j].id != 0x0; j++) {\r\nif (nand_manuf_ids[j].id == mfr)\r\nbreak;\r\n}\r\nprintk(KERN_INFO\r\n"Flash chip found: Manufacturer ID: %2.2X, "\r\n"Chip ID: %2.2X (%s:%s)\n", mfr, id,\r\nnand_manuf_ids[j].name, nand_flash_ids[i].name);\r\nif (!doc->mfr) {\r\ndoc->mfr = mfr;\r\ndoc->id = id;\r\ndoc->chipshift =\r\nffs((nand_flash_ids[i].chipsize << 20)) - 1;\r\ndoc->page256 = (nand_flash_ids[i].pagesize == 256) ? 1 : 0;\r\ndoc->pageadrlen = doc->chipshift > 25 ? 3 : 2;\r\ndoc->erasesize =\r\nnand_flash_ids[i].erasesize;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_WARNING "Unknown flash chip found: %2.2X %2.2X\n",\r\nid, mfr);\r\nprintk(KERN_WARNING "Please report to dwmw2@infradead.org\n");\r\nreturn 0;\r\n}\r\nstatic void DoC_ScanChips(struct DiskOnChip *this, int maxchips)\r\n{\r\nint floor, chip;\r\nint numchips[MAX_FLOORS];\r\nint ret = 1;\r\nthis->numchips = 0;\r\nthis->mfr = 0;\r\nthis->id = 0;\r\nfor (floor = 0; floor < MAX_FLOORS; floor++) {\r\nret = 1;\r\nnumchips[floor] = 0;\r\nfor (chip = 0; chip < maxchips && ret != 0; chip++) {\r\nret = DoC_IdentChip(this, floor, chip);\r\nif (ret) {\r\nnumchips[floor]++;\r\nthis->numchips++;\r\n}\r\n}\r\n}\r\nif (!this->numchips) {\r\nprintk(KERN_NOTICE "No flash chips recognised.\n");\r\nreturn;\r\n}\r\nthis->chips = kmalloc(sizeof(struct Nand) * this->numchips, GFP_KERNEL);\r\nif (!this->chips) {\r\nprintk(KERN_NOTICE "No memory for allocating chip info structures\n");\r\nreturn;\r\n}\r\nret = 0;\r\nfor (floor = 0; floor < MAX_FLOORS; floor++) {\r\nfor (chip = 0; chip < numchips[floor]; chip++) {\r\nthis->chips[ret].floor = floor;\r\nthis->chips[ret].chip = chip;\r\nthis->chips[ret].curadr = 0;\r\nthis->chips[ret].curmode = 0x50;\r\nret++;\r\n}\r\n}\r\nthis->totlen = this->numchips * (1 << this->chipshift);\r\nprintk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",\r\nthis->numchips, this->totlen >> 20);\r\n}\r\nstatic int DoC2k_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)\r\n{\r\nint tmp1, tmp2, retval;\r\nif (doc1->physadr == doc2->physadr)\r\nreturn 1;\r\ntmp1 = ReadDOC(doc1->virtadr, AliasResolution);\r\ntmp2 = ReadDOC(doc2->virtadr, AliasResolution);\r\nif (tmp1 != tmp2)\r\nreturn 0;\r\nWriteDOC((tmp1 + 1) % 0xff, doc1->virtadr, AliasResolution);\r\ntmp2 = ReadDOC(doc2->virtadr, AliasResolution);\r\nif (tmp2 == (tmp1 + 1) % 0xff)\r\nretval = 1;\r\nelse\r\nretval = 0;\r\nWriteDOC(tmp1, doc1->virtadr, AliasResolution);\r\nreturn retval;\r\n}\r\nvoid DoC2k_init(struct mtd_info *mtd)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nstruct DiskOnChip *old = NULL;\r\nint maxchips;\r\nif (doc2klist)\r\nold = doc2klist->priv;\r\nwhile (old) {\r\nif (DoC2k_is_alias(old, this)) {\r\nprintk(KERN_NOTICE\r\n"Ignoring DiskOnChip 2000 at 0x%lX - already configured\n",\r\nthis->physadr);\r\niounmap(this->virtadr);\r\nkfree(mtd);\r\nreturn;\r\n}\r\nif (old->nextdoc)\r\nold = old->nextdoc->priv;\r\nelse\r\nold = NULL;\r\n}\r\nswitch (this->ChipID) {\r\ncase DOC_ChipID_Doc2kTSOP:\r\nmtd->name = "DiskOnChip 2000 TSOP";\r\nthis->ioreg = DoC_Mil_CDSN_IO;\r\nthis->ChipID = DOC_ChipID_DocMil;\r\nmaxchips = MAX_CHIPS;\r\nbreak;\r\ncase DOC_ChipID_Doc2k:\r\nmtd->name = "DiskOnChip 2000";\r\nthis->ioreg = DoC_2k_CDSN_IO;\r\nmaxchips = MAX_CHIPS;\r\nbreak;\r\ncase DOC_ChipID_DocMil:\r\nmtd->name = "DiskOnChip Millennium";\r\nthis->ioreg = DoC_Mil_CDSN_IO;\r\nmaxchips = MAX_CHIPS_MIL;\r\nbreak;\r\ndefault:\r\nprintk("Unknown ChipID 0x%02x\n", this->ChipID);\r\nkfree(mtd);\r\niounmap(this->virtadr);\r\nreturn;\r\n}\r\nprintk(KERN_NOTICE "%s found at address 0x%lX\n", mtd->name,\r\nthis->physadr);\r\nmtd->type = MTD_NANDFLASH;\r\nmtd->flags = MTD_CAP_NANDFLASH;\r\nmtd->writebufsize = mtd->writesize = 512;\r\nmtd->oobsize = 16;\r\nmtd->ecc_strength = 2;\r\nmtd->owner = THIS_MODULE;\r\nmtd->_erase = doc_erase;\r\nmtd->_read = doc_read;\r\nmtd->_write = doc_write;\r\nmtd->_read_oob = doc_read_oob;\r\nmtd->_write_oob = doc_write_oob;\r\nthis->curfloor = -1;\r\nthis->curchip = -1;\r\nmutex_init(&this->lock);\r\nDoC_ScanChips(this, maxchips);\r\nif (!this->totlen) {\r\nkfree(mtd);\r\niounmap(this->virtadr);\r\n} else {\r\nthis->nextdoc = doc2klist;\r\ndoc2klist = mtd;\r\nmtd->size = this->totlen;\r\nmtd->erasesize = this->erasesize;\r\nmtd_device_register(mtd, NULL, 0);\r\nreturn;\r\n}\r\n}\r\nstatic int doc_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t * retlen, u_char * buf)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip;\r\nunsigned char syndrome[6], eccbuf[6];\r\nvolatile char dummy;\r\nint i, len256 = 0, ret=0;\r\nsize_t left = len;\r\nmutex_lock(&this->lock);\r\nwhile (left) {\r\nlen = left;\r\nif (from + len > ((from | 0x1ff) + 1))\r\nlen = ((from | 0x1ff) + 1) - from;\r\nif (len != 0x200)\r\nprintk(KERN_WARNING\r\n"ECC needs a full sector read (adr: %lx size %lx)\n",\r\n(long) from, (long) len);\r\nmychip = &this->chips[from >> (this->chipshift)];\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(this, mychip->floor);\r\nDoC_SelectChip(this, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(this, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nDoC_Command(this,\r\n(!this->page256\r\n&& (from & 0x100)) ? NAND_CMD_READ1 : NAND_CMD_READ0,\r\nCDSN_CTRL_WP);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, from, CDSN_CTRL_WP,\r\nCDSN_CTRL_ECC_IO);\r\nWriteDOC(DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC(DOC_ECC_EN, docptr, ECCConf);\r\nif (this->page256 && from + len > (from | 0xff) + 1) {\r\nlen256 = (from | 0xff) + 1 - from;\r\nDoC_ReadBuf(this, buf, len256);\r\nDoC_Command(this, NAND_CMD_READ0, CDSN_CTRL_WP);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, from + len256,\r\nCDSN_CTRL_WP, CDSN_CTRL_ECC_IO);\r\n}\r\nDoC_ReadBuf(this, &buf[len256], len - len256);\r\n*retlen += len;\r\nDoC_ReadBuf(this, eccbuf, 6);\r\nif (DoC_is_Millennium(this)) {\r\ndummy = ReadDOC(docptr, ECCConf);\r\ndummy = ReadDOC(docptr, ECCConf);\r\ni = ReadDOC(docptr, ECCConf);\r\n} else {\r\ndummy = ReadDOC(docptr, 2k_ECCStatus);\r\ndummy = ReadDOC(docptr, 2k_ECCStatus);\r\ni = ReadDOC(docptr, 2k_ECCStatus);\r\n}\r\nif (i & 0x80) {\r\nint nb_errors;\r\n#ifdef ECC_DEBUG\r\nprintk(KERN_ERR "DiskOnChip ECC Error: Read at %lx\n", (long)from);\r\n#endif\r\nfor (i = 0; i < 6; i++) {\r\nsyndrome[i] =\r\nReadDOC(docptr, ECCSyndrome0 + i);\r\n}\r\nnb_errors = doc_decode_ecc(buf, syndrome);\r\n#ifdef ECC_DEBUG\r\nprintk(KERN_ERR "Errors corrected: %x\n", nb_errors);\r\n#endif\r\nif (nb_errors < 0) {\r\nret = -EIO;\r\n}\r\n}\r\n#ifdef PSYCHO_DEBUG\r\nprintk(KERN_DEBUG "ECC DATA at %lxB: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\n(long)from, eccbuf[0], eccbuf[1], eccbuf[2],\r\neccbuf[3], eccbuf[4], eccbuf[5]);\r\n#endif\r\nWriteDOC(DOC_ECC_DIS, docptr , ECCConf);\r\nif(0 == ((from + len) & 0x1ff))\r\n{\r\nDoC_WaitReady(this);\r\n}\r\nfrom += len;\r\nleft -= len;\r\nbuf += len;\r\n}\r\nmutex_unlock(&this->lock);\r\nreturn ret;\r\n}\r\nstatic int doc_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t * retlen, const u_char * buf)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nint di;\r\nvoid __iomem *docptr = this->virtadr;\r\nunsigned char eccbuf[6];\r\nvolatile char dummy;\r\nint len256 = 0;\r\nstruct Nand *mychip;\r\nsize_t left = len;\r\nint status;\r\nmutex_lock(&this->lock);\r\nwhile (left) {\r\nlen = left;\r\nif (to + len > ((to | 0x1ff) + 1))\r\nlen = ((to | 0x1ff) + 1) - to;\r\nmychip = &this->chips[to >> (this->chipshift)];\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(this, mychip->floor);\r\nDoC_SelectChip(this, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(this, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nDoC_Command(this, NAND_CMD_RESET, CDSN_CTRL_WP);\r\nDoC_Command(this,\r\n(!this->page256\r\n&& (to & 0x100)) ? NAND_CMD_READ1 : NAND_CMD_READ0,\r\nCDSN_CTRL_WP);\r\nDoC_Command(this, NAND_CMD_SEQIN, 0);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, to, 0, CDSN_CTRL_ECC_IO);\r\nWriteDOC(DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, ECCConf);\r\nif (this->page256 && to + len > (to | 0xff) + 1) {\r\nlen256 = (to | 0xff) + 1 - to;\r\nDoC_WriteBuf(this, buf, len256);\r\nDoC_Command(this, NAND_CMD_PAGEPROG, 0);\r\nDoC_Command(this, NAND_CMD_STATUS, CDSN_CTRL_WP);\r\ndummy = ReadDOC(docptr, CDSNSlowIO);\r\nDoC_Delay(this, 2);\r\nif (ReadDOC_(docptr, this->ioreg) & 1) {\r\nprintk(KERN_ERR "Error programming flash\n");\r\n*retlen = 0;\r\nmutex_unlock(&this->lock);\r\nreturn -EIO;\r\n}\r\nDoC_Command(this, NAND_CMD_SEQIN, 0);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, to + len256, 0,\r\nCDSN_CTRL_ECC_IO);\r\n}\r\nDoC_WriteBuf(this, &buf[len256], len - len256);\r\nWriteDOC(CDSN_CTRL_ECC_IO | CDSN_CTRL_CE, docptr, CDSNControl);\r\nif (DoC_is_Millennium(this)) {\r\nWriteDOC(0, docptr, NOP);\r\nWriteDOC(0, docptr, NOP);\r\nWriteDOC(0, docptr, NOP);\r\n} else {\r\nWriteDOC_(0, docptr, this->ioreg);\r\nWriteDOC_(0, docptr, this->ioreg);\r\nWriteDOC_(0, docptr, this->ioreg);\r\n}\r\nWriteDOC(CDSN_CTRL_ECC_IO | CDSN_CTRL_FLASH_IO | CDSN_CTRL_CE, docptr,\r\nCDSNControl);\r\nfor (di = 0; di < 6; di++) {\r\neccbuf[di] = ReadDOC(docptr, ECCSyndrome0 + di);\r\n}\r\nWriteDOC(DOC_ECC_DIS, docptr, ECCConf);\r\n#ifdef PSYCHO_DEBUG\r\nprintk\r\n("OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",\r\n(long) to, eccbuf[0], eccbuf[1], eccbuf[2], eccbuf[3],\r\neccbuf[4], eccbuf[5]);\r\n#endif\r\nDoC_Command(this, NAND_CMD_PAGEPROG, 0);\r\nDoC_Command(this, NAND_CMD_STATUS, CDSN_CTRL_WP);\r\nif (DoC_is_Millennium(this)) {\r\nReadDOC(docptr, ReadPipeInit);\r\nstatus = ReadDOC(docptr, LastDataRead);\r\n} else {\r\ndummy = ReadDOC(docptr, CDSNSlowIO);\r\nDoC_Delay(this, 2);\r\nstatus = ReadDOC_(docptr, this->ioreg);\r\n}\r\nif (status & 1) {\r\nprintk(KERN_ERR "Error programming flash\n");\r\n*retlen = 0;\r\nmutex_unlock(&this->lock);\r\nreturn -EIO;\r\n}\r\n*retlen += len;\r\n{\r\nunsigned char x[8];\r\nsize_t dummy;\r\nint ret;\r\nfor (di=0; di<6; di++)\r\nx[di] = eccbuf[di];\r\nx[6]=0x55;\r\nx[7]=0x55;\r\nret = doc_write_oob_nolock(mtd, to, 8, &dummy, x);\r\nif (ret) {\r\nmutex_unlock(&this->lock);\r\nreturn ret;\r\n}\r\n}\r\nto += len;\r\nleft -= len;\r\nbuf += len;\r\n}\r\nmutex_unlock(&this->lock);\r\nreturn 0;\r\n}\r\nstatic int doc_read_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nint len256 = 0, ret;\r\nstruct Nand *mychip;\r\nuint8_t *buf = ops->oobbuf;\r\nsize_t len = ops->len;\r\nBUG_ON(ops->mode != MTD_OPS_PLACE_OOB);\r\nofs += ops->ooboffs;\r\nmutex_lock(&this->lock);\r\nmychip = &this->chips[ofs >> this->chipshift];\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(this, mychip->floor);\r\nDoC_SelectChip(this, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(this, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nif (this->page256) {\r\nif (!(ofs & 0x8))\r\nofs += 0x100;\r\nelse\r\nofs -= 0x8;\r\n}\r\nDoC_Command(this, NAND_CMD_READOOB, CDSN_CTRL_WP);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, ofs, CDSN_CTRL_WP, 0);\r\nif (this->page256 && ofs + len > (ofs | 0x7) + 1) {\r\nlen256 = (ofs | 0x7) + 1 - ofs;\r\nDoC_ReadBuf(this, buf, len256);\r\nDoC_Command(this, NAND_CMD_READOOB, CDSN_CTRL_WP);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, ofs & (~0x1ff),\r\nCDSN_CTRL_WP, 0);\r\n}\r\nDoC_ReadBuf(this, &buf[len256], len - len256);\r\nops->retlen = len;\r\nret = DoC_WaitReady(this);\r\nmutex_unlock(&this->lock);\r\nreturn ret;\r\n}\r\nstatic int doc_write_oob_nolock(struct mtd_info *mtd, loff_t ofs, size_t len,\r\nsize_t * retlen, const u_char * buf)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nint len256 = 0;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip = &this->chips[ofs >> this->chipshift];\r\nvolatile int dummy;\r\nint status;\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(this, mychip->floor);\r\nDoC_SelectChip(this, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(this, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nWriteDOC (DOC_ECC_RESET, docptr, ECCConf);\r\nWriteDOC (DOC_ECC_DIS, docptr, ECCConf);\r\nDoC_Command(this, NAND_CMD_RESET, CDSN_CTRL_WP);\r\nDoC_Command(this, NAND_CMD_READOOB, CDSN_CTRL_WP);\r\nif (this->page256) {\r\nif (!(ofs & 0x8))\r\nofs += 0x100;\r\nelse\r\nofs -= 0x8;\r\n}\r\nDoC_Command(this, NAND_CMD_SEQIN, 0);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, ofs, 0, 0);\r\nif (this->page256 && ofs + len > (ofs | 0x7) + 1) {\r\nlen256 = (ofs | 0x7) + 1 - ofs;\r\nDoC_WriteBuf(this, buf, len256);\r\nDoC_Command(this, NAND_CMD_PAGEPROG, 0);\r\nDoC_Command(this, NAND_CMD_STATUS, 0);\r\nif (DoC_is_Millennium(this)) {\r\nReadDOC(docptr, ReadPipeInit);\r\nstatus = ReadDOC(docptr, LastDataRead);\r\n} else {\r\ndummy = ReadDOC(docptr, CDSNSlowIO);\r\nDoC_Delay(this, 2);\r\nstatus = ReadDOC_(docptr, this->ioreg);\r\n}\r\nif (status & 1) {\r\nprintk(KERN_ERR "Error programming oob data\n");\r\n*retlen = 0;\r\nreturn -EIO;\r\n}\r\nDoC_Command(this, NAND_CMD_SEQIN, 0);\r\nDoC_Address(this, ADDR_COLUMN_PAGE, ofs & (~0x1ff), 0, 0);\r\n}\r\nDoC_WriteBuf(this, &buf[len256], len - len256);\r\nDoC_Command(this, NAND_CMD_PAGEPROG, 0);\r\nDoC_Command(this, NAND_CMD_STATUS, 0);\r\nif (DoC_is_Millennium(this)) {\r\nReadDOC(docptr, ReadPipeInit);\r\nstatus = ReadDOC(docptr, LastDataRead);\r\n} else {\r\ndummy = ReadDOC(docptr, CDSNSlowIO);\r\nDoC_Delay(this, 2);\r\nstatus = ReadDOC_(docptr, this->ioreg);\r\n}\r\nif (status & 1) {\r\nprintk(KERN_ERR "Error programming oob data\n");\r\n*retlen = 0;\r\nreturn -EIO;\r\n}\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int doc_write_oob(struct mtd_info *mtd, loff_t ofs,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\nint ret;\r\nBUG_ON(ops->mode != MTD_OPS_PLACE_OOB);\r\nmutex_lock(&this->lock);\r\nret = doc_write_oob_nolock(mtd, ofs + ops->ooboffs, ops->len,\r\n&ops->retlen, ops->oobbuf);\r\nmutex_unlock(&this->lock);\r\nreturn ret;\r\n}\r\nstatic int doc_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct DiskOnChip *this = mtd->priv;\r\n__u32 ofs = instr->addr;\r\n__u32 len = instr->len;\r\nvolatile int dummy;\r\nvoid __iomem *docptr = this->virtadr;\r\nstruct Nand *mychip;\r\nint status;\r\nmutex_lock(&this->lock);\r\nif (ofs & (mtd->erasesize-1) || len & (mtd->erasesize-1)) {\r\nmutex_unlock(&this->lock);\r\nreturn -EINVAL;\r\n}\r\ninstr->state = MTD_ERASING;\r\nwhile(len) {\r\nmychip = &this->chips[ofs >> this->chipshift];\r\nif (this->curfloor != mychip->floor) {\r\nDoC_SelectFloor(this, mychip->floor);\r\nDoC_SelectChip(this, mychip->chip);\r\n} else if (this->curchip != mychip->chip) {\r\nDoC_SelectChip(this, mychip->chip);\r\n}\r\nthis->curfloor = mychip->floor;\r\nthis->curchip = mychip->chip;\r\nDoC_Command(this, NAND_CMD_ERASE1, 0);\r\nDoC_Address(this, ADDR_PAGE, ofs, 0, 0);\r\nDoC_Command(this, NAND_CMD_ERASE2, 0);\r\nDoC_Command(this, NAND_CMD_STATUS, CDSN_CTRL_WP);\r\nif (DoC_is_Millennium(this)) {\r\nReadDOC(docptr, ReadPipeInit);\r\nstatus = ReadDOC(docptr, LastDataRead);\r\n} else {\r\ndummy = ReadDOC(docptr, CDSNSlowIO);\r\nDoC_Delay(this, 2);\r\nstatus = ReadDOC_(docptr, this->ioreg);\r\n}\r\nif (status & 1) {\r\nprintk(KERN_ERR "Error erasing at 0x%x\n", ofs);\r\ninstr->state = MTD_ERASE_FAILED;\r\ngoto callback;\r\n}\r\nofs += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\n}\r\ninstr->state = MTD_ERASE_DONE;\r\ncallback:\r\nmtd_erase_callback(instr);\r\nmutex_unlock(&this->lock);\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_doc2000(void)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct DiskOnChip *this;\r\nwhile ((mtd = doc2klist)) {\r\nthis = mtd->priv;\r\ndoc2klist = this->nextdoc;\r\nmtd_device_unregister(mtd);\r\niounmap(this->virtadr);\r\nkfree(this->chips);\r\nkfree(mtd);\r\n}\r\n}
