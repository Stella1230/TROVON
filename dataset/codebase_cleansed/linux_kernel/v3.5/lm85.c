static inline u16 FAN_TO_REG(unsigned long val)\r\n{\r\nif (!val)\r\nreturn 0xffff;\r\nreturn SENSORS_LIMIT(5400000 / val, 1, 0xfffe);\r\n}\r\nstatic int RANGE_TO_REG(int range)\r\n{\r\nint i;\r\nfor (i = 0; i < 15; ++i) {\r\nif (range <= (lm85_range_map[i] + lm85_range_map[i + 1]) / 2)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int FREQ_TO_REG(const int *map, int freq)\r\n{\r\nint i;\r\nfor (i = 0; i < 7; ++i)\r\nif (freq <= (map[i] + map[i + 1]) / 2)\r\nbreak;\r\nreturn i;\r\n}\r\nstatic int FREQ_FROM_REG(const int *map, u8 reg)\r\n{\r\nreturn map[reg & 0x07];\r\n}\r\nstatic int ZONE_TO_REG(int zone)\r\n{\r\nint i;\r\nfor (i = 0; i <= 7; ++i)\r\nif (zone == lm85_zone_map[i])\r\nbreak;\r\nif (i > 7)\r\ni = 3;\r\nreturn i << 5;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr]));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr]));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_min[nr] = FAN_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_FAN_MIN(nr), data->fan_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_vid_reg(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nint vid;\r\nif (data->has_vid5) {\r\nvid = vid_from_reg(data->vid & 0x3f, data->vrm);\r\n} else {\r\nvid = vid_from_reg(data->vid & 0x1f, data->vrm);\r\n}\r\nreturn sprintf(buf, "%d\n", vid);\r\n}\r\nstatic ssize_t show_vrm_reg(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct lm85_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%ld\n", (long) data->vrm);\r\n}\r\nstatic ssize_t store_vrm_reg(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct lm85_data *data = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\ndata->vrm = val;\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms_reg(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%u\n", data->alarms);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->alarms >> nr) & 1);\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_REG(data->pwm[nr]));\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = PWM_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_PWM(nr), data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\r\n*attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nint pwm_zone, enable;\r\npwm_zone = ZONE_FROM_REG(data->autofan[nr].config);\r\nswitch (pwm_zone) {\r\ncase -1:\r\nenable = 0;\r\nbreak;\r\ncase 0:\r\ncase -2:\r\nenable = 1;\r\nbreak;\r\ndefault:\r\nenable = 2;\r\n}\r\nreturn sprintf(buf, "%d\n", enable);\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute\r\n*attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nu8 config;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nswitch (val) {\r\ncase 0:\r\nconfig = 3;\r\nbreak;\r\ncase 1:\r\nconfig = 7;\r\nbreak;\r\ncase 2:\r\nconfig = 6;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\ndata->autofan[nr].config = lm85_read_value(client,\r\nLM85_REG_AFAN_CONFIG(nr));\r\ndata->autofan[nr].config = (data->autofan[nr].config & ~0xe0)\r\n| (config << 5);\r\nlm85_write_value(client, LM85_REG_AFAN_CONFIG(nr),\r\ndata->autofan[nr].config);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_freq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nint freq;\r\nif (IS_ADT7468_HFPWM(data))\r\nfreq = 22500;\r\nelse\r\nfreq = FREQ_FROM_REG(data->freq_map, data->pwm_freq[nr]);\r\nreturn sprintf(buf, "%d\n", freq);\r\n}\r\nstatic ssize_t set_pwm_freq(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nif (data->type == adt7468 && val >= 11300) {\r\ndata->cfg5 &= ~ADT7468_HFPWM;\r\nlm85_write_value(client, ADT7468_REG_CFG5, data->cfg5);\r\n} else {\r\ndata->pwm_freq[nr] = FREQ_TO_REG(data->freq_map, val);\r\nlm85_write_value(client, LM85_REG_AFAN_RANGE(nr),\r\n(data->zone[nr].range << 4)\r\n| data->pwm_freq[nr]);\r\nif (data->type == adt7468) {\r\ndata->cfg5 |= ADT7468_HFPWM;\r\nlm85_write_value(client, ADT7468_REG_CFG5, data->cfg5);\r\n}\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INSEXT_FROM_REG(nr, data->in[nr],\r\ndata->in_ext[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(nr, data->in_min[nr]));\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_min[nr] = INS_TO_REG(nr, val);\r\nlm85_write_value(client, LM85_REG_IN_MIN(nr), data->in_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", INS_FROM_REG(nr, data->in_max[nr]));\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_max[nr] = INS_TO_REG(nr, val);\r\nlm85_write_value(client, LM85_REG_IN_MAX(nr), data->in_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMPEXT_FROM_REG(data->temp[nr],\r\ndata->temp_ext[nr]));\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_min[nr]));\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (IS_ADT7468_OFF64(data))\r\nval += 64;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_min[nr] = TEMP_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_TEMP_MIN(nr), data->temp_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_max[nr]));\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (IS_ADT7468_OFF64(data))\r\nval += 64;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[nr] = TEMP_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_TEMP_MAX(nr), data->temp_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_channels(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", ZONE_FROM_REG(data->autofan[nr].config));\r\n}\r\nstatic ssize_t set_pwm_auto_channels(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->autofan[nr].config = (data->autofan[nr].config & (~0xe0))\r\n| ZONE_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_AFAN_CONFIG(nr),\r\ndata->autofan[nr].config);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_pwm_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_REG(data->autofan[nr].min_pwm));\r\n}\r\nstatic ssize_t set_pwm_auto_pwm_min(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->autofan[nr].min_pwm = PWM_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_AFAN_MINPWM(nr),\r\ndata->autofan[nr].min_pwm);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_pwm_minctl(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->autofan[nr].min_off);\r\n}\r\nstatic ssize_t set_pwm_auto_pwm_minctl(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nu8 tmp;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->autofan[nr].min_off = val;\r\ntmp = lm85_read_value(client, LM85_REG_AFAN_SPIKE1);\r\ntmp &= ~(0x20 << nr);\r\nif (data->autofan[nr].min_off)\r\ntmp |= 0x20 << nr;\r\nlm85_write_value(client, LM85_REG_AFAN_SPIKE1, tmp);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_temp_off(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->zone[nr].limit) -\r\nHYST_FROM_REG(data->zone[nr].hyst));\r\n}\r\nstatic ssize_t set_temp_auto_temp_off(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nint min;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nmin = TEMP_FROM_REG(data->zone[nr].limit);\r\ndata->zone[nr].hyst = HYST_TO_REG(min - val);\r\nif (nr == 0 || nr == 1) {\r\nlm85_write_value(client, LM85_REG_AFAN_HYST1,\r\n(data->zone[0].hyst << 4)\r\n| data->zone[1].hyst);\r\n} else {\r\nlm85_write_value(client, LM85_REG_AFAN_HYST2,\r\n(data->zone[2].hyst << 4));\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_temp_min(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->zone[nr].limit));\r\n}\r\nstatic ssize_t set_temp_auto_temp_min(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->zone[nr].limit = TEMP_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_AFAN_LIMIT(nr),\r\ndata->zone[nr].limit);\r\ndata->zone[nr].range = RANGE_TO_REG(\r\nTEMP_FROM_REG(data->zone[nr].max_desired) -\r\nTEMP_FROM_REG(data->zone[nr].limit));\r\nlm85_write_value(client, LM85_REG_AFAN_RANGE(nr),\r\n((data->zone[nr].range & 0x0f) << 4)\r\n| (data->pwm_freq[nr] & 0x07));\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_temp_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->zone[nr].limit) +\r\nRANGE_FROM_REG(data->zone[nr].range));\r\n}\r\nstatic ssize_t set_temp_auto_temp_max(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nint min;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nmin = TEMP_FROM_REG(data->zone[nr].limit);\r\ndata->zone[nr].max_desired = TEMP_TO_REG(val);\r\ndata->zone[nr].range = RANGE_TO_REG(\r\nval - min);\r\nlm85_write_value(client, LM85_REG_AFAN_RANGE(nr),\r\n((data->zone[nr].range & 0x0f) << 4)\r\n| (data->pwm_freq[nr] & 0x07));\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_auto_temp_crit(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct lm85_data *data = lm85_update_device(dev);\r\nreturn sprintf(buf, "%d\n", TEMP_FROM_REG(data->zone[nr].critical));\r\n}\r\nstatic ssize_t set_temp_auto_temp_crit(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->zone[nr].critical = TEMP_TO_REG(val);\r\nlm85_write_value(client, LM85_REG_AFAN_CRITICAL(nr),\r\ndata->zone[nr].critical);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic void lm85_init_client(struct i2c_client *client)\r\n{\r\nint value;\r\nvalue = lm85_read_value(client, LM85_REG_CONFIG);\r\nif (!(value & 0x01)) {\r\ndev_info(&client->dev, "Starting monitoring\n");\r\nlm85_write_value(client, LM85_REG_CONFIG, value | 0x01);\r\n}\r\nif (value & 0x02)\r\ndev_warn(&client->dev, "Device configuration is locked\n");\r\nif (!(value & 0x04))\r\ndev_warn(&client->dev, "Device is not ready\n");\r\n}\r\nstatic int lm85_is_fake(struct i2c_client *client)\r\n{\r\nint i;\r\nu8 in_temp, fan;\r\nfor (i = 0; i < 8; i++) {\r\nin_temp = i2c_smbus_read_byte_data(client, 0x20 + i);\r\nfan = i2c_smbus_read_byte_data(client, 0x28 + i);\r\nif (in_temp != 0x00 || fan != 0xff)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int lm85_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint address = client->addr;\r\nconst char *type_name;\r\nint company, verstep;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\nreturn -ENODEV;\r\n}\r\ncompany = lm85_read_value(client, LM85_REG_COMPANY);\r\nverstep = lm85_read_value(client, LM85_REG_VERSTEP);\r\ndev_dbg(&adapter->dev, "Detecting device at 0x%02x with "\r\n"COMPANY: 0x%02x and VERSTEP: 0x%02x\n",\r\naddress, company, verstep);\r\nif ((verstep & LM85_VERSTEP_VMASK) != LM85_VERSTEP_GENERIC &&\r\n(verstep & LM85_VERSTEP_VMASK) != LM85_VERSTEP_GENERIC2) {\r\ndev_dbg(&adapter->dev,\r\n"Autodetection failed: unsupported version\n");\r\nreturn -ENODEV;\r\n}\r\ntype_name = "lm85";\r\nif (company == LM85_COMPANY_NATIONAL) {\r\nswitch (verstep) {\r\ncase LM85_VERSTEP_LM85C:\r\ntype_name = "lm85c";\r\nbreak;\r\ncase LM85_VERSTEP_LM85B:\r\ntype_name = "lm85b";\r\nbreak;\r\ncase LM85_VERSTEP_LM96000_1:\r\ncase LM85_VERSTEP_LM96000_2:\r\nif (lm85_is_fake(client)) {\r\ndev_dbg(&adapter->dev,\r\n"Found Winbond WPCD377I, ignoring\n");\r\nreturn -ENODEV;\r\n}\r\nbreak;\r\n}\r\n} else if (company == LM85_COMPANY_ANALOG_DEV) {\r\nswitch (verstep) {\r\ncase LM85_VERSTEP_ADM1027:\r\ntype_name = "adm1027";\r\nbreak;\r\ncase LM85_VERSTEP_ADT7463:\r\ncase LM85_VERSTEP_ADT7463C:\r\ntype_name = "adt7463";\r\nbreak;\r\ncase LM85_VERSTEP_ADT7468_1:\r\ncase LM85_VERSTEP_ADT7468_2:\r\ntype_name = "adt7468";\r\nbreak;\r\n}\r\n} else if (company == LM85_COMPANY_SMSC) {\r\nswitch (verstep) {\r\ncase LM85_VERSTEP_EMC6D100_A0:\r\ncase LM85_VERSTEP_EMC6D100_A1:\r\ntype_name = "emc6d100";\r\nbreak;\r\ncase LM85_VERSTEP_EMC6D102:\r\ntype_name = "emc6d102";\r\nbreak;\r\ncase LM85_VERSTEP_EMC6D103_A0:\r\ncase LM85_VERSTEP_EMC6D103_A1:\r\ntype_name = "emc6d103";\r\nbreak;\r\ncase LM85_VERSTEP_EMC6D103S:\r\ntype_name = "emc6d103s";\r\nbreak;\r\n}\r\n} else {\r\ndev_dbg(&adapter->dev,\r\n"Autodetection failed: unknown vendor\n");\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, type_name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void lm85_remove_files(struct i2c_client *client, struct lm85_data *data)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &lm85_group);\r\nif (data->type != emc6d103s) {\r\nsysfs_remove_group(&client->dev.kobj, &lm85_group_minctl);\r\nsysfs_remove_group(&client->dev.kobj, &lm85_group_temp_off);\r\n}\r\nif (!data->has_vid5)\r\nsysfs_remove_group(&client->dev.kobj, &lm85_group_in4);\r\nif (data->type == emc6d100)\r\nsysfs_remove_group(&client->dev.kobj, &lm85_group_in567);\r\n}\r\nstatic int lm85_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct lm85_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(struct lm85_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->type = id->driver_data;\r\nmutex_init(&data->update_lock);\r\nswitch (data->type) {\r\ncase adm1027:\r\ncase adt7463:\r\ncase adt7468:\r\ncase emc6d100:\r\ncase emc6d102:\r\ncase emc6d103:\r\ncase emc6d103s:\r\ndata->freq_map = adm1027_freq_map;\r\nbreak;\r\ndefault:\r\ndata->freq_map = lm85_freq_map;\r\n}\r\ndata->vrm = vid_which_vrm();\r\nlm85_init_client(client);\r\nerr = sysfs_create_group(&client->dev.kobj, &lm85_group);\r\nif (err)\r\ngoto err_kfree;\r\nif (data->type != emc6d103s) {\r\nerr = sysfs_create_group(&client->dev.kobj, &lm85_group_minctl);\r\nif (err)\r\ngoto err_remove_files;\r\nerr = sysfs_create_group(&client->dev.kobj,\r\n&lm85_group_temp_off);\r\nif (err)\r\ngoto err_remove_files;\r\n}\r\nif (data->type == adt7463 || data->type == adt7468) {\r\nu8 vid = lm85_read_value(client, LM85_REG_VID);\r\nif (vid & 0x80)\r\ndata->has_vid5 = true;\r\n}\r\nif (!data->has_vid5) {\r\nerr = sysfs_create_group(&client->dev.kobj, &lm85_group_in4);\r\nif (err)\r\ngoto err_remove_files;\r\n}\r\nif (data->type == emc6d100) {\r\nerr = sysfs_create_group(&client->dev.kobj, &lm85_group_in567);\r\nif (err)\r\ngoto err_remove_files;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto err_remove_files;\r\n}\r\nreturn 0;\r\nerr_remove_files:\r\nlm85_remove_files(client, data);\r\nerr_kfree:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int lm85_remove(struct i2c_client *client)\r\n{\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nlm85_remove_files(client, data);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int lm85_read_value(struct i2c_client *client, u8 reg)\r\n{\r\nint res;\r\nswitch (reg) {\r\ncase LM85_REG_FAN(0):\r\ncase LM85_REG_FAN(1):\r\ncase LM85_REG_FAN(2):\r\ncase LM85_REG_FAN(3):\r\ncase LM85_REG_FAN_MIN(0):\r\ncase LM85_REG_FAN_MIN(1):\r\ncase LM85_REG_FAN_MIN(2):\r\ncase LM85_REG_FAN_MIN(3):\r\ncase LM85_REG_ALARM1:\r\nres = i2c_smbus_read_byte_data(client, reg) & 0xff;\r\nres |= i2c_smbus_read_byte_data(client, reg + 1) << 8;\r\nbreak;\r\ndefault:\r\nres = i2c_smbus_read_byte_data(client, reg);\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstatic void lm85_write_value(struct i2c_client *client, u8 reg, int value)\r\n{\r\nswitch (reg) {\r\ncase LM85_REG_FAN(0):\r\ncase LM85_REG_FAN(1):\r\ncase LM85_REG_FAN(2):\r\ncase LM85_REG_FAN(3):\r\ncase LM85_REG_FAN_MIN(0):\r\ncase LM85_REG_FAN_MIN(1):\r\ncase LM85_REG_FAN_MIN(2):\r\ncase LM85_REG_FAN_MIN(3):\r\ni2c_smbus_write_byte_data(client, reg, value & 0xff);\r\ni2c_smbus_write_byte_data(client, reg + 1, value >> 8);\r\nbreak;\r\ndefault:\r\ni2c_smbus_write_byte_data(client, reg, value);\r\nbreak;\r\n}\r\n}\r\nstatic struct lm85_data *lm85_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct lm85_data *data = i2c_get_clientdata(client);\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (!data->valid ||\r\ntime_after(jiffies, data->last_reading + LM85_DATA_INTERVAL)) {\r\ndev_dbg(&client->dev, "Reading sensor values\n");\r\nif (data->type == adm1027 || data->type == adt7463 ||\r\ndata->type == adt7468) {\r\nint ext1 = lm85_read_value(client,\r\nADM1027_REG_EXTEND_ADC1);\r\nint ext2 = lm85_read_value(client,\r\nADM1027_REG_EXTEND_ADC2);\r\nint val = (ext1 << 8) + ext2;\r\nfor (i = 0; i <= 4; i++)\r\ndata->in_ext[i] =\r\n((val >> (i * 2)) & 0x03) << 2;\r\nfor (i = 0; i <= 2; i++)\r\ndata->temp_ext[i] =\r\n(val >> ((i + 4) * 2)) & 0x0c;\r\n}\r\ndata->vid = lm85_read_value(client, LM85_REG_VID);\r\nfor (i = 0; i <= 3; ++i) {\r\ndata->in[i] =\r\nlm85_read_value(client, LM85_REG_IN(i));\r\ndata->fan[i] =\r\nlm85_read_value(client, LM85_REG_FAN(i));\r\n}\r\nif (!data->has_vid5)\r\ndata->in[4] = lm85_read_value(client, LM85_REG_IN(4));\r\nif (data->type == adt7468)\r\ndata->cfg5 = lm85_read_value(client, ADT7468_REG_CFG5);\r\nfor (i = 0; i <= 2; ++i) {\r\ndata->temp[i] =\r\nlm85_read_value(client, LM85_REG_TEMP(i));\r\ndata->pwm[i] =\r\nlm85_read_value(client, LM85_REG_PWM(i));\r\nif (IS_ADT7468_OFF64(data))\r\ndata->temp[i] -= 64;\r\n}\r\ndata->alarms = lm85_read_value(client, LM85_REG_ALARM1);\r\nif (data->type == emc6d100) {\r\nfor (i = 5; i <= 7; ++i) {\r\ndata->in[i] = lm85_read_value(client,\r\nEMC6D100_REG_IN(i));\r\n}\r\ndata->alarms |= lm85_read_value(client,\r\nEMC6D100_REG_ALARM3) << 16;\r\n} else if (data->type == emc6d102 || data->type == emc6d103 ||\r\ndata->type == emc6d103s) {\r\nint ext1 = lm85_read_value(client,\r\nEMC6D102_REG_EXTEND_ADC1);\r\nint ext2 = lm85_read_value(client,\r\nEMC6D102_REG_EXTEND_ADC2);\r\nint ext3 = lm85_read_value(client,\r\nEMC6D102_REG_EXTEND_ADC3);\r\nint ext4 = lm85_read_value(client,\r\nEMC6D102_REG_EXTEND_ADC4);\r\ndata->in_ext[0] = ext3 & 0x0f;\r\ndata->in_ext[1] = ext4 & 0x0f;\r\ndata->in_ext[2] = ext4 >> 4;\r\ndata->in_ext[3] = ext3 >> 4;\r\ndata->in_ext[4] = ext2 >> 4;\r\ndata->temp_ext[0] = ext1 & 0x0f;\r\ndata->temp_ext[1] = ext2 & 0x0f;\r\ndata->temp_ext[2] = ext1 >> 4;\r\n}\r\ndata->last_reading = jiffies;\r\n}\r\nif (!data->valid ||\r\ntime_after(jiffies, data->last_config + LM85_CONFIG_INTERVAL)) {\r\ndev_dbg(&client->dev, "Reading config values\n");\r\nfor (i = 0; i <= 3; ++i) {\r\ndata->in_min[i] =\r\nlm85_read_value(client, LM85_REG_IN_MIN(i));\r\ndata->in_max[i] =\r\nlm85_read_value(client, LM85_REG_IN_MAX(i));\r\ndata->fan_min[i] =\r\nlm85_read_value(client, LM85_REG_FAN_MIN(i));\r\n}\r\nif (!data->has_vid5) {\r\ndata->in_min[4] = lm85_read_value(client,\r\nLM85_REG_IN_MIN(4));\r\ndata->in_max[4] = lm85_read_value(client,\r\nLM85_REG_IN_MAX(4));\r\n}\r\nif (data->type == emc6d100) {\r\nfor (i = 5; i <= 7; ++i) {\r\ndata->in_min[i] = lm85_read_value(client,\r\nEMC6D100_REG_IN_MIN(i));\r\ndata->in_max[i] = lm85_read_value(client,\r\nEMC6D100_REG_IN_MAX(i));\r\n}\r\n}\r\nfor (i = 0; i <= 2; ++i) {\r\nint val;\r\ndata->temp_min[i] =\r\nlm85_read_value(client, LM85_REG_TEMP_MIN(i));\r\ndata->temp_max[i] =\r\nlm85_read_value(client, LM85_REG_TEMP_MAX(i));\r\ndata->autofan[i].config =\r\nlm85_read_value(client, LM85_REG_AFAN_CONFIG(i));\r\nval = lm85_read_value(client, LM85_REG_AFAN_RANGE(i));\r\ndata->pwm_freq[i] = val & 0x07;\r\ndata->zone[i].range = val >> 4;\r\ndata->autofan[i].min_pwm =\r\nlm85_read_value(client, LM85_REG_AFAN_MINPWM(i));\r\ndata->zone[i].limit =\r\nlm85_read_value(client, LM85_REG_AFAN_LIMIT(i));\r\ndata->zone[i].critical =\r\nlm85_read_value(client, LM85_REG_AFAN_CRITICAL(i));\r\nif (IS_ADT7468_OFF64(data)) {\r\ndata->temp_min[i] -= 64;\r\ndata->temp_max[i] -= 64;\r\ndata->zone[i].limit -= 64;\r\ndata->zone[i].critical -= 64;\r\n}\r\n}\r\nif (data->type != emc6d103s) {\r\ni = lm85_read_value(client, LM85_REG_AFAN_SPIKE1);\r\ndata->autofan[0].min_off = (i & 0x20) != 0;\r\ndata->autofan[1].min_off = (i & 0x40) != 0;\r\ndata->autofan[2].min_off = (i & 0x80) != 0;\r\ni = lm85_read_value(client, LM85_REG_AFAN_HYST1);\r\ndata->zone[0].hyst = i >> 4;\r\ndata->zone[1].hyst = i & 0x0f;\r\ni = lm85_read_value(client, LM85_REG_AFAN_HYST2);\r\ndata->zone[2].hyst = i >> 4;\r\n}\r\ndata->last_config = jiffies;\r\n}\r\ndata->valid = 1;\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
