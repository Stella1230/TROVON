static int eeh_event_handler(void * dummy)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event;\r\nstruct eeh_dev *edev;\r\nset_task_comm(current, "eehd");\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nevent = NULL;\r\nif (!list_empty(&eeh_eventlist)) {\r\nevent = list_entry(eeh_eventlist.next, struct eeh_event, list);\r\nlist_del(&event->list);\r\n}\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\nif (event == NULL)\r\nreturn 0;\r\nmutex_lock(&eeh_event_mutex);\r\nedev = event->edev;\r\neeh_mark_slot(eeh_dev_to_of_node(edev), EEH_MODE_RECOVERING);\r\nprintk(KERN_INFO "EEH: Detected PCI bus error on device %s\n",\r\neeh_pci_name(edev->pdev));\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nedev = handle_eeh_events(event);\r\neeh_clear_slot(eeh_dev_to_of_node(edev), EEH_MODE_RECOVERING);\r\npci_dev_put(edev->pdev);\r\nkfree(event);\r\nmutex_unlock(&eeh_event_mutex);\r\nif (edev && edev->freeze_count>0) {\r\nmsleep_interruptible(3600*1000);\r\nif (edev->freeze_count>0)\r\nedev->freeze_count--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void eeh_thread_launcher(struct work_struct *dummy)\r\n{\r\nif (kernel_thread(eeh_event_handler, NULL, CLONE_KERNEL) < 0)\r\nprintk(KERN_ERR "Failed to start EEH daemon\n");\r\n}\r\nint eeh_send_failure_event(struct eeh_dev *edev)\r\n{\r\nunsigned long flags;\r\nstruct eeh_event *event;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nconst char *location;\r\nif (!mem_init_done) {\r\nprintk(KERN_ERR "EEH: event during early boot not handled\n");\r\nlocation = of_get_property(dn, "ibm,loc-code", NULL);\r\nprintk(KERN_ERR "EEH: device node = %s\n", dn->full_name);\r\nprintk(KERN_ERR "EEH: PCI location = %s\n", location);\r\nreturn 1;\r\n}\r\nevent = kmalloc(sizeof(*event), GFP_ATOMIC);\r\nif (event == NULL) {\r\nprintk(KERN_ERR "EEH: out of memory, event not handled\n");\r\nreturn 1;\r\n}\r\nif (edev->pdev)\r\npci_dev_get(edev->pdev);\r\nevent->edev = edev;\r\nspin_lock_irqsave(&eeh_eventlist_lock, flags);\r\nlist_add(&event->list, &eeh_eventlist);\r\nspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\r\nschedule_work(&eeh_event_wq);\r\nreturn 0;\r\n}
