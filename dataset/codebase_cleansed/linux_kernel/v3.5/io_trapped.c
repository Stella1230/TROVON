static int __init trapped_io_setup(char *__unused)\r\n{\r\ntrapped_io_disable = 1;\r\nreturn 1;\r\n}\r\nint register_trapped_io(struct trapped_io *tiop)\r\n{\r\nstruct resource *res;\r\nunsigned long len = 0, flags = 0;\r\nstruct page *pages[TRAPPED_PAGES_MAX];\r\nint k, n;\r\nif (unlikely(trapped_io_disable))\r\nreturn 0;\r\nif ((unsigned long)tiop & (PAGE_SIZE - 1))\r\ngoto bad;\r\nfor (k = 0; k < tiop->num_resources; k++) {\r\nres = tiop->resource + k;\r\nlen += roundup(resource_size(res), PAGE_SIZE);\r\nflags |= res->flags;\r\n}\r\nif (hweight_long(flags) != 1)\r\ngoto bad;\r\nn = len >> PAGE_SHIFT;\r\nif (n >= TRAPPED_PAGES_MAX)\r\ngoto bad;\r\nfor (k = 0; k < n; k++)\r\npages[k] = virt_to_page(tiop);\r\ntiop->virt_base = vmap(pages, n, VM_MAP, PAGE_NONE);\r\nif (!tiop->virt_base)\r\ngoto bad;\r\nlen = 0;\r\nfor (k = 0; k < tiop->num_resources; k++) {\r\nres = tiop->resource + k;\r\npr_info("trapped io 0x%08lx overrides %s 0x%08lx\n",\r\n(unsigned long)(tiop->virt_base + len),\r\nres->flags & IORESOURCE_IO ? "io" : "mmio",\r\n(unsigned long)res->start);\r\nlen += roundup(resource_size(res), PAGE_SIZE);\r\n}\r\ntiop->magic = IO_TRAPPED_MAGIC;\r\nINIT_LIST_HEAD(&tiop->list);\r\nspin_lock_irq(&trapped_lock);\r\n#ifdef CONFIG_HAS_IOPORT\r\nif (flags & IORESOURCE_IO)\r\nlist_add(&tiop->list, &trapped_io);\r\n#endif\r\n#ifdef CONFIG_HAS_IOMEM\r\nif (flags & IORESOURCE_MEM)\r\nlist_add(&tiop->list, &trapped_mem);\r\n#endif\r\nspin_unlock_irq(&trapped_lock);\r\nreturn 0;\r\nbad:\r\npr_warning("unable to install trapped io filter\n");\r\nreturn -1;\r\n}\r\nvoid __iomem *match_trapped_io_handler(struct list_head *list,\r\nunsigned long offset,\r\nunsigned long size)\r\n{\r\nunsigned long voffs;\r\nstruct trapped_io *tiop;\r\nstruct resource *res;\r\nint k, len;\r\nunsigned long flags;\r\nspin_lock_irqsave(&trapped_lock, flags);\r\nlist_for_each_entry(tiop, list, list) {\r\nvoffs = 0;\r\nfor (k = 0; k < tiop->num_resources; k++) {\r\nres = tiop->resource + k;\r\nif (res->start == offset) {\r\nspin_unlock_irqrestore(&trapped_lock, flags);\r\nreturn tiop->virt_base + voffs;\r\n}\r\nlen = resource_size(res);\r\nvoffs += roundup(len, PAGE_SIZE);\r\n}\r\n}\r\nspin_unlock_irqrestore(&trapped_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic struct trapped_io *lookup_tiop(unsigned long address)\r\n{\r\npgd_t *pgd_k;\r\npud_t *pud_k;\r\npmd_t *pmd_k;\r\npte_t *pte_k;\r\npte_t entry;\r\npgd_k = swapper_pg_dir + pgd_index(address);\r\nif (!pgd_present(*pgd_k))\r\nreturn NULL;\r\npud_k = pud_offset(pgd_k, address);\r\nif (!pud_present(*pud_k))\r\nreturn NULL;\r\npmd_k = pmd_offset(pud_k, address);\r\nif (!pmd_present(*pmd_k))\r\nreturn NULL;\r\npte_k = pte_offset_kernel(pmd_k, address);\r\nentry = *pte_k;\r\nreturn pfn_to_kaddr(pte_pfn(entry));\r\n}\r\nstatic unsigned long lookup_address(struct trapped_io *tiop,\r\nunsigned long address)\r\n{\r\nstruct resource *res;\r\nunsigned long vaddr = (unsigned long)tiop->virt_base;\r\nunsigned long len;\r\nint k;\r\nfor (k = 0; k < tiop->num_resources; k++) {\r\nres = tiop->resource + k;\r\nlen = roundup(resource_size(res), PAGE_SIZE);\r\nif (address < (vaddr + len))\r\nreturn res->start + (address - vaddr);\r\nvaddr += len;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long long copy_word(unsigned long src_addr, int src_len,\r\nunsigned long dst_addr, int dst_len)\r\n{\r\nunsigned long long tmp = 0;\r\nswitch (src_len) {\r\ncase 1:\r\ntmp = __raw_readb(src_addr);\r\nbreak;\r\ncase 2:\r\ntmp = __raw_readw(src_addr);\r\nbreak;\r\ncase 4:\r\ntmp = __raw_readl(src_addr);\r\nbreak;\r\ncase 8:\r\ntmp = __raw_readq(src_addr);\r\nbreak;\r\n}\r\nswitch (dst_len) {\r\ncase 1:\r\n__raw_writeb(tmp, dst_addr);\r\nbreak;\r\ncase 2:\r\n__raw_writew(tmp, dst_addr);\r\nbreak;\r\ncase 4:\r\n__raw_writel(tmp, dst_addr);\r\nbreak;\r\ncase 8:\r\n__raw_writeq(tmp, dst_addr);\r\nbreak;\r\n}\r\nreturn tmp;\r\n}\r\nstatic unsigned long from_device(void *dst, const void *src, unsigned long cnt)\r\n{\r\nstruct trapped_io *tiop;\r\nunsigned long src_addr = (unsigned long)src;\r\nunsigned long long tmp;\r\npr_debug("trapped io read 0x%08lx (%ld)\n", src_addr, cnt);\r\ntiop = lookup_tiop(src_addr);\r\nWARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));\r\nsrc_addr = lookup_address(tiop, src_addr);\r\nif (!src_addr)\r\nreturn cnt;\r\ntmp = copy_word(src_addr,\r\nmax_t(unsigned long, cnt,\r\n(tiop->minimum_bus_width / 8)),\r\n(unsigned long)dst, cnt);\r\npr_debug("trapped io read 0x%08lx -> 0x%08llx\n", src_addr, tmp);\r\nreturn 0;\r\n}\r\nstatic unsigned long to_device(void *dst, const void *src, unsigned long cnt)\r\n{\r\nstruct trapped_io *tiop;\r\nunsigned long dst_addr = (unsigned long)dst;\r\nunsigned long long tmp;\r\npr_debug("trapped io write 0x%08lx (%ld)\n", dst_addr, cnt);\r\ntiop = lookup_tiop(dst_addr);\r\nWARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));\r\ndst_addr = lookup_address(tiop, dst_addr);\r\nif (!dst_addr)\r\nreturn cnt;\r\ntmp = copy_word((unsigned long)src, cnt,\r\ndst_addr, max_t(unsigned long, cnt,\r\n(tiop->minimum_bus_width / 8)));\r\npr_debug("trapped io write 0x%08lx -> 0x%08llx\n", dst_addr, tmp);\r\nreturn 0;\r\n}\r\nint handle_trapped_io(struct pt_regs *regs, unsigned long address)\r\n{\r\nmm_segment_t oldfs;\r\ninsn_size_t instruction;\r\nint tmp;\r\nif (trapped_io_disable)\r\nreturn 0;\r\nif (!lookup_tiop(address))\r\nreturn 0;\r\nWARN_ON(user_mode(regs));\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nif (copy_from_user(&instruction, (void *)(regs->pc),\r\nsizeof(instruction))) {\r\nset_fs(oldfs);\r\nreturn 0;\r\n}\r\ntmp = handle_unaligned_access(instruction, regs,\r\n&trapped_io_access, 1, address);\r\nset_fs(oldfs);\r\nreturn tmp == 0;\r\n}
