static inline void copy_timings_omap_to_drm(struct drm_display_mode *mode,\r\nstruct omap_video_timings *timings)\r\n{\r\nmode->clock = timings->pixel_clock;\r\nmode->hdisplay = timings->x_res;\r\nmode->hsync_start = mode->hdisplay + timings->hfp;\r\nmode->hsync_end = mode->hsync_start + timings->hsw;\r\nmode->htotal = mode->hsync_end + timings->hbp;\r\nmode->vdisplay = timings->y_res;\r\nmode->vsync_start = mode->vdisplay + timings->vfp;\r\nmode->vsync_end = mode->vsync_start + timings->vsw;\r\nmode->vtotal = mode->vsync_end + timings->vbp;\r\n}\r\nstatic inline void copy_timings_drm_to_omap(struct omap_video_timings *timings,\r\nstruct drm_display_mode *mode)\r\n{\r\ntimings->pixel_clock = mode->clock;\r\ntimings->x_res = mode->hdisplay;\r\ntimings->hfp = mode->hsync_start - mode->hdisplay;\r\ntimings->hsw = mode->hsync_end - mode->hsync_start;\r\ntimings->hbp = mode->htotal - mode->hsync_end;\r\ntimings->y_res = mode->vdisplay;\r\ntimings->vfp = mode->vsync_start - mode->vdisplay;\r\ntimings->vsw = mode->vsync_end - mode->vsync_start;\r\ntimings->vbp = mode->vtotal - mode->vsync_end;\r\n}\r\nstatic void omap_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nint old_dpms;\r\nDBG("%s: %d", dssdev->name, mode);\r\nold_dpms = connector->dpms;\r\nif (mode < old_dpms)\r\ndrm_helper_connector_dpms(connector, mode);\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nswitch (dssdev->state) {\r\ncase OMAP_DSS_DISPLAY_SUSPENDED:\r\ndssdev->activate_after_resume = true;\r\nbreak;\r\ncase OMAP_DSS_DISPLAY_DISABLED: {\r\nint ret = dssdev->driver->enable(dssdev);\r\nif (ret) {\r\nDBG("%s: failed to enable: %d",\r\ndssdev->name, ret);\r\ndssdev->driver->disable(dssdev);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\n}\r\nif (mode > old_dpms)\r\ndrm_helper_connector_dpms(connector, mode);\r\n}\r\nenum drm_connector_status omap_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nenum drm_connector_status ret;\r\nif (dssdrv->detect) {\r\nif (dssdrv->detect(dssdev)) {\r\nret = connector_status_connected;\r\n} else {\r\nret = connector_status_disconnected;\r\n}\r\n} else {\r\nret = connector_status_unknown;\r\n}\r\nVERB("%s: %d (force=%d)", omap_connector->dssdev->name, ret, force);\r\nreturn ret;\r\n}\r\nstatic void omap_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\ndssdev->driver->disable(dssdev);\r\nDBG("%s", omap_connector->dssdev->name);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(omap_connector);\r\nomap_dss_put_device(dssdev);\r\n}\r\nstatic int omap_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nstruct drm_device *dev = connector->dev;\r\nint n = 0;\r\nDBG("%s", omap_connector->dssdev->name);\r\nif (dssdrv->read_edid) {\r\nvoid *edid = kzalloc(MAX_EDID, GFP_KERNEL);\r\nif ((dssdrv->read_edid(dssdev, edid, MAX_EDID) > 0) &&\r\ndrm_edid_is_valid(edid)) {\r\ndrm_mode_connector_update_edid_property(\r\nconnector, edid);\r\nn = drm_add_edid_modes(connector, edid);\r\nkfree(connector->display_info.raw_edid);\r\nconnector->display_info.raw_edid = edid;\r\n} else {\r\ndrm_mode_connector_update_edid_property(\r\nconnector, NULL);\r\nconnector->display_info.raw_edid = NULL;\r\nkfree(edid);\r\n}\r\n} else {\r\nstruct drm_display_mode *mode = drm_mode_create(dev);\r\nstruct omap_video_timings timings;\r\ndssdrv->get_timings(dssdev, &timings);\r\ncopy_timings_omap_to_drm(mode, &timings);\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\nn = 1;\r\n}\r\nreturn n;\r\n}\r\nstatic int omap_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nstruct omap_video_timings timings = {0};\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *new_mode;\r\nint ret = MODE_BAD;\r\ncopy_timings_drm_to_omap(&timings, mode);\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\nif (!dssdrv->check_timings(dssdev, &timings)) {\r\nnew_mode = drm_mode_duplicate(dev, mode);\r\nnew_mode->clock = timings.pixel_clock;\r\nnew_mode->vrefresh = 0;\r\nif (mode->vrefresh == drm_mode_vrefresh(new_mode))\r\nret = MODE_OK;\r\ndrm_mode_destroy(dev, new_mode);\r\n}\r\nDBG("connector: mode %s: "\r\n"%d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\n(ret == MODE_OK) ? "valid" : "invalid",\r\nmode->base.id, mode->name, mode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal, mode->type, mode->flags);\r\nreturn ret;\r\n}\r\nstruct drm_encoder *omap_connector_attached_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nint i;\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nfor (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {\r\nstruct drm_mode_object *obj;\r\nif (connector->encoder_ids[i] == 0)\r\nbreak;\r\nobj = drm_mode_object_find(connector->dev,\r\nconnector->encoder_ids[i],\r\nDRM_MODE_OBJECT_ENCODER);\r\nif (obj) {\r\nstruct drm_encoder *encoder = obj_to_encoder(obj);\r\nstruct omap_overlay_manager *mgr =\r\nomap_encoder_get_manager(encoder);\r\nDBG("%s: found %s", omap_connector->dssdev->name,\r\nmgr->name);\r\nreturn encoder;\r\n}\r\n}\r\nDBG("%s: no encoder", omap_connector->dssdev->name);\r\nreturn NULL;\r\n}\r\nvoid omap_connector_mode_set(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nstruct omap_dss_device *dssdev = omap_connector->dssdev;\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nstruct omap_video_timings timings;\r\ncopy_timings_drm_to_omap(&timings, mode);\r\nDBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nomap_connector->dssdev->name,\r\nmode->base.id, mode->name, mode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal, mode->type, mode->flags);\r\nif (dssdrv->check_timings(dssdev, &timings)) {\r\ndev_err(dev->dev, "could not set timings\n");\r\nreturn;\r\n}\r\ndssdrv->set_timings(dssdev, &timings);\r\n}\r\nvoid omap_connector_flush(struct drm_connector *connector,\r\nint x, int y, int w, int h)\r\n{\r\nstruct omap_connector *omap_connector = to_omap_connector(connector);\r\nVERB("%s: %d,%d, %dx%d", omap_connector->dssdev->name, x, y, w, h);\r\n}\r\nstruct drm_connector *omap_connector_init(struct drm_device *dev,\r\nint connector_type, struct omap_dss_device *dssdev)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct omap_connector *omap_connector;\r\nDBG("%s", dssdev->name);\r\nomap_dss_get_device(dssdev);\r\nomap_connector = kzalloc(sizeof(struct omap_connector), GFP_KERNEL);\r\nif (!omap_connector) {\r\ndev_err(dev->dev, "could not allocate connector\n");\r\ngoto fail;\r\n}\r\nomap_connector->dssdev = dssdev;\r\nconnector = &omap_connector->base;\r\ndrm_connector_init(dev, connector, &omap_connector_funcs,\r\nconnector_type);\r\ndrm_connector_helper_add(connector, &omap_connector_helper_funcs);\r\n#if 0\r\nif (dssdev->caps & OMAP_DSS_DISPLAY_CAP_HPD)\r\nconnector->polled = 0;\r\nelse\r\n#endif\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\nconnector->interlace_allowed = 1;\r\nconnector->doublescan_allowed = 0;\r\ndrm_sysfs_connector_add(connector);\r\nreturn connector;\r\nfail:\r\nif (connector) {\r\nomap_connector_destroy(connector);\r\n}\r\nreturn NULL;\r\n}
