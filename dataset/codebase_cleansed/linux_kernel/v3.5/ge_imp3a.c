void __init ge_imp3a_pic_init(void)\r\n{\r\nstruct mpic *mpic;\r\nstruct device_node *np;\r\nstruct device_node *cascade_node = NULL;\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "fsl,MPC8572DS-CAMP")) {\r\nmpic = mpic_alloc(NULL, 0,\r\nMPIC_NO_RESET |\r\nMPIC_BIG_ENDIAN |\r\nMPIC_SINGLE_DEST_CPU,\r\n0, 256, " OpenPIC ");\r\n} else {\r\nmpic = mpic_alloc(NULL, 0,\r\nMPIC_BIG_ENDIAN |\r\nMPIC_SINGLE_DEST_CPU,\r\n0, 256, " OpenPIC ");\r\n}\r\nBUG_ON(mpic == NULL);\r\nmpic_init(mpic);\r\nfor_each_node_by_type(np, "interrupt-controller")\r\nif (of_device_is_compatible(np, "gef,fpga-pic-1.00")) {\r\ncascade_node = np;\r\nbreak;\r\n}\r\nif (cascade_node == NULL) {\r\nprintk(KERN_WARNING "IMP3A: No FPGA PIC\n");\r\nreturn;\r\n}\r\ngef_pic_init(cascade_node);\r\nof_node_put(cascade_node);\r\n}\r\nstatic void __init ge_imp3a_setup_arch(void)\r\n{\r\nstruct device_node *regs;\r\n#ifdef CONFIG_PCI\r\nstruct device_node *np;\r\nstruct pci_controller *hose;\r\n#endif\r\ndma_addr_t max = 0xffffffff;\r\nif (ppc_md.progress)\r\nppc_md.progress("ge_imp3a_setup_arch()", 0);\r\n#ifdef CONFIG_PCI\r\nfor_each_node_by_type(np, "pci") {\r\nif (of_device_is_compatible(np, "fsl,mpc8540-pci") ||\r\nof_device_is_compatible(np, "fsl,mpc8548-pcie") ||\r\nof_device_is_compatible(np, "fsl,p2020-pcie")) {\r\nstruct resource rsrc;\r\nof_address_to_resource(np, 0, &rsrc);\r\nif ((rsrc.start & 0xfffff) == primary_phb_addr)\r\nfsl_add_bridge(np, 1);\r\nelse\r\nfsl_add_bridge(np, 0);\r\nhose = pci_find_hose_for_OF_device(np);\r\nmax = min(max, hose->dma_window_base_cur +\r\nhose->dma_window_size);\r\n}\r\n}\r\n#endif\r\nmpc85xx_smp_init();\r\n#ifdef CONFIG_SWIOTLB\r\nif (memblock_end_of_DRAM() > max) {\r\nppc_swiotlb_enable = 1;\r\nset_pci_dma_ops(&swiotlb_dma_ops);\r\nppc_md.pci_dma_dev_setup = pci_dma_dev_setup_swiotlb;\r\n}\r\n#endif\r\nregs = of_find_compatible_node(NULL, NULL, "ge,imp3a-fpga-regs");\r\nif (regs) {\r\nimp3a_regs = of_iomap(regs, 0);\r\nif (imp3a_regs == NULL)\r\nprintk(KERN_WARNING "Unable to map board registers\n");\r\nof_node_put(regs);\r\n}\r\n#if defined(CONFIG_MMIO_NVRAM)\r\nmmio_nvram_init();\r\n#endif\r\nprintk(KERN_INFO "GE Intelligent Platforms IMP3A 3U cPCI SBC\n");\r\n}\r\nstatic unsigned int ge_imp3a_get_pcb_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs);\r\nreturn (reg >> 8) & 0xff;\r\n}\r\nstatic unsigned int ge_imp3a_get_board_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x2);\r\nreturn reg & 0xff;\r\n}\r\nstatic unsigned int ge_imp3a_get_fpga_rev(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x2);\r\nreturn (reg >> 8) & 0xff;\r\n}\r\nstatic unsigned int ge_imp3a_get_cpci_geo_addr(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x6);\r\nreturn (reg & 0x0f00) >> 8;\r\n}\r\nstatic unsigned int ge_imp3a_get_cpci_is_syscon(void)\r\n{\r\nunsigned int reg;\r\nreg = ioread16(imp3a_regs + 0x6);\r\nreturn reg & (1 << 12);\r\n}\r\nstatic void ge_imp3a_show_cpuinfo(struct seq_file *m)\r\n{\r\nseq_printf(m, "Vendor\t\t: GE Intelligent Platforms\n");\r\nseq_printf(m, "Revision\t: %u%c\n", ge_imp3a_get_pcb_rev(),\r\n('A' + ge_imp3a_get_board_rev() - 1));\r\nseq_printf(m, "FPGA Revision\t: %u\n", ge_imp3a_get_fpga_rev());\r\nseq_printf(m, "cPCI geo. addr\t: %u\n", ge_imp3a_get_cpci_geo_addr());\r\nseq_printf(m, "cPCI syscon\t: %s\n",\r\nge_imp3a_get_cpci_is_syscon() ? "yes" : "no");\r\n}\r\nstatic int __init ge_imp3a_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (of_flat_dt_is_compatible(root, "ge,IMP3A")) {\r\n#ifdef CONFIG_PCI\r\nprimary_phb_addr = 0x9000;\r\n#endif\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
