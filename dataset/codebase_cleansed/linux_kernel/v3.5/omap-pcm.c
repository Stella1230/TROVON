static void omap_pcm_dma_irq(int ch, u16 stat, void *data)\r\n{\r\nstruct snd_pcm_substream *substream = data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct omap_runtime_data *prtd = runtime->private_data;\r\nunsigned long flags;\r\nif ((cpu_is_omap1510())) {\r\nspin_lock_irqsave(&prtd->lock, flags);\r\nif ((stat == OMAP_DMA_LAST_IRQ) &&\r\n(prtd->period_index == runtime->periods - 1)) {\r\nspin_unlock_irqrestore(&prtd->lock, flags);\r\nreturn;\r\n}\r\nif (prtd->period_index >= 0) {\r\nif (stat & OMAP_DMA_BLOCK_IRQ) {\r\nprtd->period_index = 0;\r\n} else if (stat & OMAP_DMA_LAST_IRQ) {\r\nprtd->period_index = runtime->periods - 1;\r\n} else if (++prtd->period_index >= runtime->periods) {\r\nprtd->period_index = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&prtd->lock, flags);\r\n}\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int omap_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct omap_runtime_data *prtd = runtime->private_data;\r\nstruct omap_pcm_dma_data *dma_data;\r\nint err = 0;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (!dma_data)\r\nreturn 0;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = params_buffer_bytes(params);\r\nif (prtd->dma_data)\r\nreturn 0;\r\nprtd->dma_data = dma_data;\r\nerr = omap_request_dma(dma_data->dma_req, dma_data->name,\r\nomap_pcm_dma_irq, substream, &prtd->dma_ch);\r\nif (!err) {\r\nomap_dma_link_lch(prtd->dma_ch, prtd->dma_ch);\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct omap_runtime_data *prtd = runtime->private_data;\r\nif (prtd->dma_data == NULL)\r\nreturn 0;\r\nomap_dma_unlink_lch(prtd->dma_ch, prtd->dma_ch);\r\nomap_free_dma(prtd->dma_ch);\r\nprtd->dma_data = NULL;\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nstatic int omap_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct omap_runtime_data *prtd = runtime->private_data;\r\nstruct omap_pcm_dma_data *dma_data = prtd->dma_data;\r\nstruct omap_dma_channel_params dma_params;\r\nint bytes;\r\nif (!prtd->dma_data)\r\nreturn 0;\r\nmemset(&dma_params, 0, sizeof(dma_params));\r\ndma_params.data_type = dma_data->data_type;\r\ndma_params.trigger = dma_data->dma_req;\r\ndma_params.sync_mode = dma_data->sync_mode;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_params.src_amode = OMAP_DMA_AMODE_POST_INC;\r\ndma_params.dst_amode = OMAP_DMA_AMODE_CONSTANT;\r\ndma_params.src_or_dst_synch = OMAP_DMA_DST_SYNC;\r\ndma_params.src_start = runtime->dma_addr;\r\ndma_params.dst_start = dma_data->port_addr;\r\ndma_params.dst_port = OMAP_DMA_PORT_MPUI;\r\ndma_params.dst_fi = dma_data->packet_size;\r\n} else {\r\ndma_params.src_amode = OMAP_DMA_AMODE_CONSTANT;\r\ndma_params.dst_amode = OMAP_DMA_AMODE_POST_INC;\r\ndma_params.src_or_dst_synch = OMAP_DMA_SRC_SYNC;\r\ndma_params.src_start = dma_data->port_addr;\r\ndma_params.dst_start = runtime->dma_addr;\r\ndma_params.src_port = OMAP_DMA_PORT_MPUI;\r\ndma_params.src_fi = dma_data->packet_size;\r\n}\r\nbytes = snd_pcm_lib_period_bytes(substream);\r\ndma_params.elem_count = bytes >> dma_data->data_type;\r\ndma_params.frame_count = runtime->periods;\r\nomap_set_dma_params(prtd->dma_ch, &dma_params);\r\nif ((cpu_is_omap1510()))\r\nomap_enable_dma_irq(prtd->dma_ch, OMAP_DMA_FRAME_IRQ |\r\nOMAP_DMA_LAST_IRQ | OMAP_DMA_BLOCK_IRQ);\r\nelse if (!substream->runtime->no_period_wakeup)\r\nomap_enable_dma_irq(prtd->dma_ch, OMAP_DMA_FRAME_IRQ);\r\nelse {\r\nomap_disable_dma_irq(prtd->dma_ch, OMAP_DMA_BLOCK_IRQ);\r\n}\r\nif (!(cpu_class_is_omap1())) {\r\nomap_set_dma_src_burst_mode(prtd->dma_ch,\r\nOMAP_DMA_DATA_BURST_16);\r\nomap_set_dma_dest_burst_mode(prtd->dma_ch,\r\nOMAP_DMA_DATA_BURST_16);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct omap_runtime_data *prtd = runtime->private_data;\r\nstruct omap_pcm_dma_data *dma_data = prtd->dma_data;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&prtd->lock, flags);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nprtd->period_index = 0;\r\nif (dma_data->set_threshold)\r\ndma_data->set_threshold(substream);\r\nomap_start_dma(prtd->dma_ch);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nprtd->period_index = -1;\r\nomap_stop_dma(prtd->dma_ch);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&prtd->lock, flags);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t omap_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct omap_runtime_data *prtd = runtime->private_data;\r\ndma_addr_t ptr;\r\nsnd_pcm_uframes_t offset;\r\nif (cpu_is_omap1510()) {\r\noffset = prtd->period_index * runtime->period_size;\r\n} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nptr = omap_get_dma_dst_pos(prtd->dma_ch);\r\noffset = bytes_to_frames(runtime, ptr - runtime->dma_addr);\r\n} else {\r\nptr = omap_get_dma_src_pos(prtd->dma_ch);\r\noffset = bytes_to_frames(runtime, ptr - runtime->dma_addr);\r\n}\r\nif (offset >= runtime->buffer_size)\r\noffset = 0;\r\nreturn offset;\r\n}\r\nstatic int omap_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct omap_runtime_data *prtd;\r\nint ret;\r\nsnd_soc_set_runtime_hwparams(substream, &omap_pcm_hardware);\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\ngoto out;\r\nprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\r\nif (prtd == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nspin_lock_init(&prtd->lock);\r\nruntime->private_data = prtd;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int omap_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nkfree(runtime->private_data);\r\nreturn 0;\r\n}\r\nstatic int omap_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn dma_mmap_writecombine(substream->pcm->card->dev, vma,\r\nruntime->dma_area,\r\nruntime->dma_addr,\r\nruntime->dma_bytes);\r\n}\r\nstatic int omap_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,\r\nint stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = omap_pcm_hardware.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_writecombine(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nstatic void omap_pcm_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_writecombine(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}\r\nstatic int omap_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nint ret = 0;\r\nif (!card->dev->dma_mask)\r\ncard->dev->dma_mask = &omap_pcm_dmamask;\r\nif (!card->dev->coherent_dma_mask)\r\ncard->dev->coherent_dma_mask = DMA_BIT_MASK(64);\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {\r\nret = omap_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_PLAYBACK);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = omap_pcm_preallocate_dma_buffer(pcm,\r\nSNDRV_PCM_STREAM_CAPTURE);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nif (ret)\r\nomap_pcm_free_dma_buffers(pcm);\r\nreturn ret;\r\n}\r\nstatic __devinit int omap_pcm_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev,\r\n&omap_soc_platform);\r\n}\r\nstatic int __devexit omap_pcm_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
