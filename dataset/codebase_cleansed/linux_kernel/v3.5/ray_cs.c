static int ray_probe(struct pcmcia_device *p_dev)\r\n{\r\nray_dev_t *local;\r\nstruct net_device *dev;\r\ndev_dbg(&p_dev->dev, "ray_attach()\n");\r\ndev = alloc_etherdev(sizeof(ray_dev_t));\r\nif (!dev)\r\ngoto fail_alloc_dev;\r\nlocal = netdev_priv(dev);\r\nlocal->finder = p_dev;\r\np_dev->resource[0]->end = 0;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->config_flags |= CONF_ENABLE_IRQ;\r\np_dev->config_index = 1;\r\np_dev->priv = dev;\r\nlocal->finder = p_dev;\r\nlocal->card_status = CARD_INSERTED;\r\nlocal->authentication_state = UNAUTHENTICATED;\r\nlocal->num_multi = 0;\r\ndev_dbg(&p_dev->dev, "ray_attach p_dev = %p, dev = %p, local = %p, intr = %p\n",\r\np_dev, dev, local, &ray_interrupt);\r\ndev->netdev_ops = &ray_netdev_ops;\r\ndev->wireless_handlers = &ray_handler_def;\r\n#ifdef WIRELESS_SPY\r\nlocal->wireless_data.spy_data = &local->spy_data;\r\ndev->wireless_data = &local->wireless_data;\r\n#endif\r\ndev_dbg(&p_dev->dev, "ray_cs ray_attach calling ether_setup.)\n");\r\nnetif_stop_queue(dev);\r\ninit_timer(&local->timer);\r\nthis_device = p_dev;\r\nreturn ray_config(p_dev);\r\nfail_alloc_dev:\r\nreturn -ENOMEM;\r\n}\r\nstatic void ray_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev;\r\nray_dev_t *local;\r\ndev_dbg(&link->dev, "ray_detach\n");\r\nthis_device = NULL;\r\ndev = link->priv;\r\nray_release(link);\r\nlocal = netdev_priv(dev);\r\ndel_timer(&local->timer);\r\nif (link->priv) {\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\n}\r\ndev_dbg(&link->dev, "ray_cs ray_detach ending\n");\r\n}\r\nstatic int ray_config(struct pcmcia_device *link)\r\n{\r\nint ret = 0;\r\nint i;\r\nstruct net_device *dev = (struct net_device *)link->priv;\r\nray_dev_t *local = netdev_priv(dev);\r\ndev_dbg(&link->dev, "ray_config\n");\r\nprintk(KERN_INFO "ray_cs Detected: %s%s%s%s\n",\r\nlink->prod_id[0] ? link->prod_id[0] : " ",\r\nlink->prod_id[1] ? link->prod_id[1] : " ",\r\nlink->prod_id[2] ? link->prod_id[2] : " ",\r\nlink->prod_id[3] ? link->prod_id[3] : " ");\r\nret = pcmcia_request_irq(link, ray_interrupt);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\nlink->resource[2]->flags |= WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;\r\nlink->resource[2]->start = 0;\r\nlink->resource[2]->end = 0x8000;\r\nret = pcmcia_request_window(link, link->resource[2], ray_mem_speed);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_map_mem_page(link, link->resource[2], 0);\r\nif (ret)\r\ngoto failed;\r\nlocal->sram = ioremap(link->resource[2]->start,\r\nresource_size(link->resource[2]));\r\nlink->resource[3]->flags |=\r\nWIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;\r\nlink->resource[3]->start = 0;\r\nlink->resource[3]->end = 0x4000;\r\nret = pcmcia_request_window(link, link->resource[3], ray_mem_speed);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_map_mem_page(link, link->resource[3], 0x8000);\r\nif (ret)\r\ngoto failed;\r\nlocal->rmem = ioremap(link->resource[3]->start,\r\nresource_size(link->resource[3]));\r\nlink->resource[4]->flags |=\r\nWIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM | WIN_ENABLE | WIN_USE_WAIT;\r\nlink->resource[4]->start = 0;\r\nlink->resource[4]->end = 0x1000;\r\nret = pcmcia_request_window(link, link->resource[4], ray_mem_speed);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_map_mem_page(link, link->resource[4], 0);\r\nif (ret)\r\ngoto failed;\r\nlocal->amem = ioremap(link->resource[4]->start,\r\nresource_size(link->resource[4]));\r\ndev_dbg(&link->dev, "ray_config sram=%p\n", local->sram);\r\ndev_dbg(&link->dev, "ray_config rmem=%p\n", local->rmem);\r\ndev_dbg(&link->dev, "ray_config amem=%p\n", local->amem);\r\nif (ray_init(dev) < 0) {\r\nray_release(link);\r\nreturn -ENODEV;\r\n}\r\nSET_NETDEV_DEV(dev, &link->dev);\r\ni = register_netdev(dev);\r\nif (i != 0) {\r\nprintk("ray_config register_netdev() failed\n");\r\nray_release(link);\r\nreturn i;\r\n}\r\nprintk(KERN_INFO "%s: RayLink, irq %d, hw_addr %pM\n",\r\ndev->name, dev->irq, dev->dev_addr);\r\nreturn 0;\r\nfailed:\r\nray_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic inline struct ccs __iomem *ccs_base(ray_dev_t *dev)\r\n{\r\nreturn dev->sram + CCS_BASE;\r\n}\r\nstatic inline struct rcs __iomem *rcs_base(ray_dev_t *dev)\r\n{\r\nreturn dev->sram + CCS_BASE;\r\n}\r\nstatic int ray_init(struct net_device *dev)\r\n{\r\nint i;\r\nUCHAR *p;\r\nstruct ccs __iomem *pccs;\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\ndev_dbg(&link->dev, "ray_init(0x%p)\n", dev);\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_init - device not present\n");\r\nreturn -1;\r\n}\r\nlocal->net_type = net_type;\r\nlocal->sta_type = TYPE_STA;\r\nmemcpy_fromio(&local->startup_res, local->sram + ECF_TO_HOST_BASE,\r\nsizeof(struct startup_res_6));\r\nif (local->startup_res.startup_word != 0x80) {\r\nprintk(KERN_INFO "ray_init ERROR card status = %2x\n",\r\nlocal->startup_res.startup_word);\r\nlocal->card_status = CARD_INIT_ERROR;\r\nreturn -1;\r\n}\r\nlocal->fw_ver = local->startup_res.firmware_version[0];\r\nlocal->fw_bld = local->startup_res.firmware_version[1];\r\nlocal->fw_var = local->startup_res.firmware_version[2];\r\ndev_dbg(&link->dev, "ray_init firmware version %d.%d\n", local->fw_ver,\r\nlocal->fw_bld);\r\nlocal->tib_length = 0x20;\r\nif ((local->fw_ver == 5) && (local->fw_bld >= 30))\r\nlocal->tib_length = local->startup_res.tib_length;\r\ndev_dbg(&link->dev, "ray_init tib_length = 0x%02x\n", local->tib_length);\r\npccs = ccs_base(local);\r\nfor (i = 0; i < NUMBER_OF_CCS; i++) {\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\n}\r\ninit_startup_params(local);\r\nif (parse_addr(phy_addr, local->sparm.b4.a_mac_addr)) {\r\np = local->sparm.b4.a_mac_addr;\r\n} else {\r\nmemcpy(&local->sparm.b4.a_mac_addr,\r\n&local->startup_res.station_addr, ADDRLEN);\r\np = local->sparm.b4.a_mac_addr;\r\n}\r\nclear_interrupt(local);\r\nlocal->card_status = CARD_AWAITING_PARAM;\r\ndev_dbg(&link->dev, "ray_init ending\n");\r\nreturn 0;\r\n}\r\nstatic int dl_startup_params(struct net_device *dev)\r\n{\r\nint ccsindex;\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct ccs __iomem *pccs;\r\nstruct pcmcia_device *link = local->finder;\r\ndev_dbg(&link->dev, "dl_startup_params entered\n");\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs dl_startup_params - device not present\n");\r\nreturn -1;\r\n}\r\nif (local->fw_ver == 0x55)\r\nmemcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b4,\r\nsizeof(struct b4_startup_params));\r\nelse\r\nmemcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b5,\r\nsizeof(struct b5_startup_params));\r\nif ((ccsindex = get_free_ccs(local)) < 0)\r\nreturn -1;\r\nlocal->dl_param_ccs = ccsindex;\r\npccs = ccs_base(local) + ccsindex;\r\nwriteb(CCS_DOWNLOAD_STARTUP_PARAMS, &pccs->cmd);\r\ndev_dbg(&link->dev, "dl_startup_params start ccsindex = %d\n",\r\nlocal->dl_param_ccs);\r\nif (interrupt_ecf(local, ccsindex)) {\r\nprintk(KERN_INFO "ray dl_startup_params failed - "\r\n"ECF not ready for intr\n");\r\nlocal->card_status = CARD_DL_PARAM_ERROR;\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\nreturn -2;\r\n}\r\nlocal->card_status = CARD_DL_PARAM;\r\nlocal->timer.expires = jiffies + HZ / 2;\r\nlocal->timer.data = (long)local;\r\nlocal->timer.function = verify_dl_startup;\r\nadd_timer(&local->timer);\r\ndev_dbg(&link->dev,\r\n"ray_cs dl_startup_params started timer for verify_dl_startup\n");\r\nreturn 0;\r\n}\r\nstatic void init_startup_params(ray_dev_t *local)\r\n{\r\nint i;\r\nif (country > JAPAN_TEST)\r\ncountry = USA;\r\nelse if (country < USA)\r\ncountry = USA;\r\nif (local->fw_ver == 0x55) {\r\nmemcpy((UCHAR *) &local->sparm.b4, b4_default_startup_parms,\r\nsizeof(struct b4_startup_params));\r\ni = (hop_dwell * 1024) & 0xffffff;\r\nlocal->sparm.b4.a_hop_time[0] = (i >> 16) & 0xff;\r\nlocal->sparm.b4.a_hop_time[1] = (i >> 8) & 0xff;\r\nlocal->sparm.b4.a_beacon_period[0] = 0;\r\nlocal->sparm.b4.a_beacon_period[1] =\r\n((beacon_period / hop_dwell) - 1) & 0xff;\r\nlocal->sparm.b4.a_curr_country_code = country;\r\nlocal->sparm.b4.a_hop_pattern_length =\r\nhop_pattern_length[(int)country] - 1;\r\nif (bc) {\r\nlocal->sparm.b4.a_ack_timeout = 0x50;\r\nlocal->sparm.b4.a_sifs = 0x3f;\r\n}\r\n} else {\r\nmemcpy((UCHAR *) &local->sparm.b5, b5_default_startup_parms,\r\nsizeof(struct b5_startup_params));\r\nlocal->sparm.b5.a_hop_time[0] = (hop_dwell >> 8) & 0xff;\r\nlocal->sparm.b5.a_hop_time[1] = hop_dwell & 0xff;\r\nlocal->sparm.b5.a_beacon_period[0] =\r\n(beacon_period >> 8) & 0xff;\r\nlocal->sparm.b5.a_beacon_period[1] = beacon_period & 0xff;\r\nif (psm)\r\nlocal->sparm.b5.a_power_mgt_state = 1;\r\nlocal->sparm.b5.a_curr_country_code = country;\r\nlocal->sparm.b5.a_hop_pattern_length =\r\nhop_pattern_length[(int)country];\r\n}\r\nlocal->sparm.b4.a_network_type = net_type & 0x01;\r\nlocal->sparm.b4.a_acting_as_ap_status = TYPE_STA;\r\nif (essid != NULL)\r\nstrncpy(local->sparm.b4.a_current_ess_id, essid, ESSID_SIZE);\r\n}\r\nstatic void verify_dl_startup(u_long data)\r\n{\r\nray_dev_t *local = (ray_dev_t *) data;\r\nstruct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;\r\nUCHAR status;\r\nstruct pcmcia_device *link = local->finder;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs verify_dl_startup - device not present\n");\r\nreturn;\r\n}\r\n#if 0\r\n{\r\nint i;\r\nprintk(KERN_DEBUG\r\n"verify_dl_startup parameters sent via ccs %d:\n",\r\nlocal->dl_param_ccs);\r\nfor (i = 0; i < sizeof(struct b5_startup_params); i++) {\r\nprintk(" %2x",\r\n(unsigned int)readb(local->sram +\r\nHOST_TO_ECF_BASE + i));\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\nstatus = readb(&pccs->buffer_status);\r\nif (status != CCS_BUFFER_FREE) {\r\nprintk(KERN_INFO\r\n"Download startup params failed. Status = %d\n",\r\nstatus);\r\nlocal->card_status = CARD_DL_PARAM_ERROR;\r\nreturn;\r\n}\r\nif (local->sparm.b4.a_network_type == ADHOC)\r\nstart_net((u_long) local);\r\nelse\r\njoin_net((u_long) local);\r\n}\r\nstatic void start_net(u_long data)\r\n{\r\nray_dev_t *local = (ray_dev_t *) data;\r\nstruct ccs __iomem *pccs;\r\nint ccsindex;\r\nstruct pcmcia_device *link = local->finder;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs start_net - device not present\n");\r\nreturn;\r\n}\r\nif ((ccsindex = get_free_ccs(local)) < 0)\r\nreturn;\r\npccs = ccs_base(local) + ccsindex;\r\nwriteb(CCS_START_NETWORK, &pccs->cmd);\r\nwriteb(0, &pccs->var.start_network.update_param);\r\nif (interrupt_ecf(local, ccsindex)) {\r\ndev_dbg(&link->dev, "ray start net failed - card not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\nreturn;\r\n}\r\nlocal->card_status = CARD_DOING_ACQ;\r\n}\r\nstatic void join_net(u_long data)\r\n{\r\nray_dev_t *local = (ray_dev_t *) data;\r\nstruct ccs __iomem *pccs;\r\nint ccsindex;\r\nstruct pcmcia_device *link = local->finder;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs join_net - device not present\n");\r\nreturn;\r\n}\r\nif ((ccsindex = get_free_ccs(local)) < 0)\r\nreturn;\r\npccs = ccs_base(local) + ccsindex;\r\nwriteb(CCS_JOIN_NETWORK, &pccs->cmd);\r\nwriteb(0, &pccs->var.join_network.update_param);\r\nwriteb(0, &pccs->var.join_network.net_initiated);\r\nif (interrupt_ecf(local, ccsindex)) {\r\ndev_dbg(&link->dev, "ray join net failed - card not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\nreturn;\r\n}\r\nlocal->card_status = CARD_DOING_ACQ;\r\n}\r\nstatic void ray_release(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nray_dev_t *local = netdev_priv(dev);\r\ndev_dbg(&link->dev, "ray_release\n");\r\ndel_timer(&local->timer);\r\niounmap(local->sram);\r\niounmap(local->rmem);\r\niounmap(local->amem);\r\npcmcia_disable_device(link);\r\ndev_dbg(&link->dev, "ray_release ending\n");\r\n}\r\nstatic int ray_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int ray_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\nray_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ray_dev_init(struct net_device *dev)\r\n{\r\n#ifdef RAY_IMMEDIATE_INIT\r\nint i;\r\n#endif\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\ndev_dbg(&link->dev, "ray_dev_init(dev=%p)\n", dev);\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_dev_init - device not present\n");\r\nreturn -1;\r\n}\r\n#ifdef RAY_IMMEDIATE_INIT\r\nif ((i = dl_startup_params(dev)) < 0) {\r\nprintk(KERN_INFO "ray_dev_init dl_startup_params failed - "\r\n"returns 0x%x\n", i);\r\nreturn -1;\r\n}\r\n#else\r\ndev_dbg(&link->dev,\r\n"ray_dev_init: postponing card init to ray_open() ; Status = %d\n",\r\nlocal->card_status);\r\n#endif\r\nmemcpy(dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);\r\nmemset(dev->broadcast, 0xff, ETH_ALEN);\r\ndev_dbg(&link->dev, "ray_dev_init ending\n");\r\nreturn 0;\r\n}\r\nstatic int ray_dev_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\ndev_dbg(&link->dev, "ray_dev_config(dev=%p,ifmap=%p)\n", dev, map);\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_dev_config - device not present\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\nshort length = skb->len;\r\nif (!pcmcia_dev_present(link)) {\r\ndev_dbg(&link->dev, "ray_dev_start_xmit - device not present\n");\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\ndev_dbg(&link->dev, "ray_dev_start_xmit(skb=%p, dev=%p)\n", skb, dev);\r\nif (local->authentication_state == NEED_TO_AUTH) {\r\ndev_dbg(&link->dev, "ray_cs Sending authentication request.\n");\r\nif (!build_auth_frame(local, local->auth_id, OPEN_AUTH_REQUEST)) {\r\nlocal->authentication_state = AUTHENTICATED;\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\n}\r\nif (length < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nswitch (ray_hw_xmit(skb->data, length, dev, DATA_TYPE)) {\r\ncase XMIT_NO_CCS:\r\ncase XMIT_NEED_AUTH:\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\ncase XMIT_NO_INTR:\r\ncase XMIT_MSG_BAD:\r\ncase XMIT_OK:\r\ndefault:\r\ndev_kfree_skb(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,\r\nUCHAR msg_type)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct ccs __iomem *pccs;\r\nint ccsindex;\r\nint offset;\r\nstruct tx_msg __iomem *ptx;\r\nshort int addr;\r\npr_debug("ray_hw_xmit(data=%p, len=%d, dev=%p)\n", data, len, dev);\r\nif (len + TX_HEADER_LENGTH > TX_BUF_SIZE) {\r\nprintk(KERN_INFO "ray_hw_xmit packet too large: %d bytes\n",\r\nlen);\r\nreturn XMIT_MSG_BAD;\r\n}\r\nswitch (ccsindex = get_free_tx_ccs(local)) {\r\ncase ECCSBUSY:\r\npr_debug("ray_hw_xmit tx_ccs table busy\n");\r\ncase ECCSFULL:\r\npr_debug("ray_hw_xmit No free tx ccs\n");\r\ncase ECARDGONE:\r\nnetif_stop_queue(dev);\r\nreturn XMIT_NO_CCS;\r\ndefault:\r\nbreak;\r\n}\r\naddr = TX_BUF_BASE + (ccsindex << 11);\r\nif (msg_type == DATA_TYPE) {\r\nlocal->stats.tx_bytes += len;\r\nlocal->stats.tx_packets++;\r\n}\r\nptx = local->sram + addr;\r\nray_build_header(local, ptx, msg_type, data);\r\nif (translate) {\r\noffset = translate_frame(local, ptx, data, len);\r\n} else {\r\nmemcpy_toio(&ptx->var, data, len);\r\noffset = 0;\r\n}\r\npccs = ccs_base(local) + ccsindex;\r\nlen += TX_HEADER_LENGTH + offset;\r\nwriteb(CCS_TX_REQUEST, &pccs->cmd);\r\nwriteb(addr >> 8, &pccs->var.tx_request.tx_data_ptr[0]);\r\nwriteb(local->tib_length, &pccs->var.tx_request.tx_data_ptr[1]);\r\nwriteb(len >> 8, &pccs->var.tx_request.tx_data_length[0]);\r\nwriteb(len & 0xff, &pccs->var.tx_request.tx_data_length[1]);\r\nwriteb(PSM_CAM, &pccs->var.tx_request.pow_sav_mode);\r\nwriteb(local->net_default_tx_rate, &pccs->var.tx_request.tx_rate);\r\nwriteb(0, &pccs->var.tx_request.antenna);\r\npr_debug("ray_hw_xmit default_tx_rate = 0x%x\n",\r\nlocal->net_default_tx_rate);\r\nif (interrupt_ecf(local, ccsindex)) {\r\npr_debug("ray_hw_xmit failed - ECF not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &pccs->buffer_status);\r\nreturn XMIT_NO_INTR;\r\n}\r\nreturn XMIT_OK;\r\n}\r\nstatic int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,\r\nunsigned char *data, int len)\r\n{\r\n__be16 proto = ((struct ethhdr *)data)->h_proto;\r\nif (ntohs(proto) >= 1536) {\r\npr_debug("ray_cs translate_frame DIX II\n");\r\nmemcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));\r\nmemcpy_toio(((void __iomem *)&ptx->var) + sizeof(eth2_llc),\r\n(UCHAR *) &proto, 2);\r\nif (proto == htons(ETH_P_AARP) || proto == htons(ETH_P_IPX)) {\r\nwriteb(0xf8,\r\n&((struct snaphdr_t __iomem *)ptx->var)->org[3]);\r\n}\r\nmemcpy_toio((void __iomem *)&ptx->var +\r\nsizeof(struct snaphdr_t), data + ETH_HLEN,\r\nlen - ETH_HLEN);\r\nreturn (int)sizeof(struct snaphdr_t) - ETH_HLEN;\r\n} else {\r\npr_debug("ray_cs translate_frame 802\n");\r\nif (proto == htons(0xffff)) {\r\npr_debug("ray_cs translate_frame evil IPX\n");\r\nmemcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);\r\nreturn 0 - ETH_HLEN;\r\n}\r\nmemcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);\r\nreturn 0 - ETH_HLEN;\r\n}\r\n}\r\nstatic void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx,\r\nUCHAR msg_type, unsigned char *data)\r\n{\r\nwriteb(PROTOCOL_VER | msg_type, &ptx->mac.frame_ctl_1);\r\nif (local->net_type == ADHOC) {\r\nwriteb(0, &ptx->mac.frame_ctl_2);\r\nmemcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest,\r\n2 * ADDRLEN);\r\nmemcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);\r\n} else {\r\nif (local->sparm.b4.a_acting_as_ap_status) {\r\nwriteb(FC2_FROM_DS, &ptx->mac.frame_ctl_2);\r\nmemcpy_toio(ptx->mac.addr_1,\r\n((struct ethhdr *)data)->h_dest, ADDRLEN);\r\nmemcpy_toio(ptx->mac.addr_2, local->bss_id, 6);\r\nmemcpy_toio(ptx->mac.addr_3,\r\n((struct ethhdr *)data)->h_source, ADDRLEN);\r\n} else {\r\nwriteb(FC2_TO_DS, &ptx->mac.frame_ctl_2);\r\nmemcpy_toio(ptx->mac.addr_1, local->bss_id, ADDRLEN);\r\nmemcpy_toio(ptx->mac.addr_2,\r\n((struct ethhdr *)data)->h_source, ADDRLEN);\r\nmemcpy_toio(ptx->mac.addr_3,\r\n((struct ethhdr *)data)->h_dest, ADDRLEN);\r\n}\r\n}\r\n}\r\nstatic int ray_get_name(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstrcpy(wrqu->name, "IEEE 802.11-FH");\r\nreturn 0;\r\n}\r\nstatic int ray_set_freq(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nint err = -EINPROGRESS;\r\nif (local->card_status != CARD_AWAITING_PARAM)\r\nreturn -EBUSY;\r\nif ((wrqu->freq.m > USA_HOP_MOD) || (wrqu->freq.e > 0))\r\nerr = -EOPNOTSUPP;\r\nelse\r\nlocal->sparm.b5.a_hop_pattern = wrqu->freq.m;\r\nreturn err;\r\n}\r\nstatic int ray_get_freq(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nwrqu->freq.m = local->sparm.b5.a_hop_pattern;\r\nwrqu->freq.e = 0;\r\nreturn 0;\r\n}\r\nstatic int ray_set_essid(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nif (local->card_status != CARD_AWAITING_PARAM)\r\nreturn -EBUSY;\r\nif (wrqu->essid.flags == 0)\r\nreturn -EOPNOTSUPP;\r\nif (wrqu->essid.length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\nmemset(local->sparm.b5.a_current_ess_id, 0, IW_ESSID_MAX_SIZE);\r\nmemcpy(local->sparm.b5.a_current_ess_id, extra, wrqu->essid.length);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int ray_get_essid(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nmemcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);\r\nwrqu->essid.length = strlen(extra);\r\nwrqu->essid.flags = 1;\r\nreturn 0;\r\n}\r\nstatic int ray_get_wap(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nmemcpy(wrqu->ap_addr.sa_data, local->bss_id, ETH_ALEN);\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nreturn 0;\r\n}\r\nstatic int ray_set_rate(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nif (local->card_status != CARD_AWAITING_PARAM)\r\nreturn -EBUSY;\r\nif ((wrqu->bitrate.value != 1000000) && (wrqu->bitrate.value != 2000000))\r\nreturn -EINVAL;\r\nif ((local->fw_ver == 0x55) &&\r\n(wrqu->bitrate.value == 2000000))\r\nlocal->net_default_tx_rate = 3;\r\nelse\r\nlocal->net_default_tx_rate = wrqu->bitrate.value / 500000;\r\nreturn 0;\r\n}\r\nstatic int ray_get_rate(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nif (local->net_default_tx_rate == 3)\r\nwrqu->bitrate.value = 2000000;\r\nelse\r\nwrqu->bitrate.value = local->net_default_tx_rate * 500000;\r\nwrqu->bitrate.fixed = 0;\r\nreturn 0;\r\n}\r\nstatic int ray_set_rts(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nint rthr = wrqu->rts.value;\r\nif (local->card_status != CARD_AWAITING_PARAM)\r\nreturn -EBUSY;\r\nif (wrqu->rts.disabled)\r\nrthr = 32767;\r\nelse {\r\nif ((rthr < 0) || (rthr > 2347))\r\nreturn -EINVAL;\r\n}\r\nlocal->sparm.b5.a_rts_threshold[0] = (rthr >> 8) & 0xFF;\r\nlocal->sparm.b5.a_rts_threshold[1] = rthr & 0xFF;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int ray_get_rts(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nwrqu->rts.value = (local->sparm.b5.a_rts_threshold[0] << 8)\r\n+ local->sparm.b5.a_rts_threshold[1];\r\nwrqu->rts.disabled = (wrqu->rts.value == 32767);\r\nwrqu->rts.fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int ray_set_frag(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nint fthr = wrqu->frag.value;\r\nif (local->card_status != CARD_AWAITING_PARAM)\r\nreturn -EBUSY;\r\nif (wrqu->frag.disabled)\r\nfthr = 32767;\r\nelse {\r\nif ((fthr < 256) || (fthr > 2347))\r\nreturn -EINVAL;\r\n}\r\nlocal->sparm.b5.a_frag_threshold[0] = (fthr >> 8) & 0xFF;\r\nlocal->sparm.b5.a_frag_threshold[1] = fthr & 0xFF;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int ray_get_frag(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nwrqu->frag.value = (local->sparm.b5.a_frag_threshold[0] << 8)\r\n+ local->sparm.b5.a_frag_threshold[1];\r\nwrqu->frag.disabled = (wrqu->frag.value == 32767);\r\nwrqu->frag.fixed = 1;\r\nreturn 0;\r\n}\r\nstatic int ray_set_mode(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nint err = -EINPROGRESS;\r\nchar card_mode = 1;\r\nif (local->card_status != CARD_AWAITING_PARAM)\r\nreturn -EBUSY;\r\nswitch (wrqu->mode) {\r\ncase IW_MODE_ADHOC:\r\ncard_mode = 0;\r\ncase IW_MODE_INFRA:\r\nlocal->sparm.b5.a_network_type = card_mode;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int ray_get_mode(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nif (local->sparm.b5.a_network_type)\r\nwrqu->mode = IW_MODE_INFRA;\r\nelse\r\nwrqu->mode = IW_MODE_ADHOC;\r\nreturn 0;\r\n}\r\nstatic int ray_get_range(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nmemset(range, 0, sizeof(struct iw_range));\r\nwrqu->data.length = sizeof(struct iw_range);\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 9;\r\nrange->throughput = 1.1 * 1000 * 1000;\r\nrange->num_channels = hop_pattern_length[(int)country];\r\nrange->num_frequency = 0;\r\nrange->max_qual.qual = 0;\r\nrange->max_qual.level = 255;\r\nrange->max_qual.noise = 255;\r\nrange->num_bitrates = 2;\r\nrange->bitrate[0] = 1000000;\r\nrange->bitrate[1] = 2000000;\r\nreturn 0;\r\n}\r\nstatic int ray_set_framing(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\ntranslate = *(extra);\r\nreturn 0;\r\n}\r\nstatic int ray_get_framing(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\n*(extra) = translate;\r\nreturn 0;\r\n}\r\nstatic int ray_get_country(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\n*(extra) = country;\r\nreturn 0;\r\n}\r\nstatic int ray_commit(struct net_device *dev, struct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic iw_stats *ray_get_wireless_stats(struct net_device *dev)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\nstruct status __iomem *p = local->sram + STATUS_BASE;\r\nlocal->wstats.status = local->card_status;\r\n#ifdef WIRELESS_SPY\r\nif ((local->spy_data.spy_number > 0)\r\n&& (local->sparm.b5.a_network_type == 0)) {\r\nlocal->wstats.qual.qual = local->spy_data.spy_stat[0].qual;\r\nlocal->wstats.qual.level = local->spy_data.spy_stat[0].level;\r\nlocal->wstats.qual.noise = local->spy_data.spy_stat[0].noise;\r\nlocal->wstats.qual.updated =\r\nlocal->spy_data.spy_stat[0].updated;\r\n}\r\n#endif\r\nif (pcmcia_dev_present(link)) {\r\nlocal->wstats.qual.noise = readb(&p->rxnoise);\r\nlocal->wstats.qual.updated |= 4;\r\n}\r\nreturn &local->wstats;\r\n}\r\nstatic int ray_open(struct net_device *dev)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link;\r\nlink = local->finder;\r\ndev_dbg(&link->dev, "ray_open('%s')\n", dev->name);\r\nif (link->open == 0)\r\nlocal->num_multi = 0;\r\nlink->open++;\r\nif (local->card_status == CARD_AWAITING_PARAM) {\r\nint i;\r\ndev_dbg(&link->dev, "ray_open: doing init now !\n");\r\nif ((i = dl_startup_params(dev)) < 0) {\r\nprintk(KERN_INFO\r\n"ray_dev_init dl_startup_params failed - "\r\n"returns 0x%x\n", i);\r\nreturn -1;\r\n}\r\n}\r\nif (sniffer)\r\nnetif_stop_queue(dev);\r\nelse\r\nnetif_start_queue(dev);\r\ndev_dbg(&link->dev, "ray_open ending\n");\r\nreturn 0;\r\n}\r\nstatic int ray_dev_close(struct net_device *dev)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link;\r\nlink = local->finder;\r\ndev_dbg(&link->dev, "ray_dev_close('%s')\n", dev->name);\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void ray_reset(struct net_device *dev)\r\n{\r\npr_debug("ray_reset entered\n");\r\n}\r\nstatic int interrupt_ecf(ray_dev_t *local, int ccs)\r\n{\r\nint i = 50;\r\nstruct pcmcia_device *link = local->finder;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs interrupt_ecf - device not present\n");\r\nreturn -1;\r\n}\r\ndev_dbg(&link->dev, "interrupt_ecf(local=%p, ccs = 0x%x\n", local, ccs);\r\nwhile (i &&\r\n(readb(local->amem + CIS_OFFSET + ECF_INTR_OFFSET) &\r\nECF_INTR_SET))\r\ni--;\r\nif (i == 0) {\r\ndev_dbg(&link->dev, "ray_cs interrupt_ecf card not ready for interrupt\n");\r\nreturn -1;\r\n}\r\nwriteb(ccs, local->sram + SCB_BASE);\r\nwriteb(ECF_INTR_SET, local->amem + CIS_OFFSET + ECF_INTR_OFFSET);\r\nreturn 0;\r\n}\r\nstatic int get_free_tx_ccs(ray_dev_t *local)\r\n{\r\nint i;\r\nstruct ccs __iomem *pccs = ccs_base(local);\r\nstruct pcmcia_device *link = local->finder;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs get_free_tx_ccs - device not present\n");\r\nreturn ECARDGONE;\r\n}\r\nif (test_and_set_bit(0, &local->tx_ccs_lock)) {\r\ndev_dbg(&link->dev, "ray_cs tx_ccs_lock busy\n");\r\nreturn ECCSBUSY;\r\n}\r\nfor (i = 0; i < NUMBER_OF_TX_CCS; i++) {\r\nif (readb(&(pccs + i)->buffer_status) == CCS_BUFFER_FREE) {\r\nwriteb(CCS_BUFFER_BUSY, &(pccs + i)->buffer_status);\r\nwriteb(CCS_END_LIST, &(pccs + i)->link);\r\nlocal->tx_ccs_lock = 0;\r\nreturn i;\r\n}\r\n}\r\nlocal->tx_ccs_lock = 0;\r\ndev_dbg(&link->dev, "ray_cs ERROR no free tx CCS for raylink card\n");\r\nreturn ECCSFULL;\r\n}\r\nstatic int get_free_ccs(ray_dev_t *local)\r\n{\r\nint i;\r\nstruct ccs __iomem *pccs = ccs_base(local);\r\nstruct pcmcia_device *link = local->finder;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs get_free_ccs - device not present\n");\r\nreturn ECARDGONE;\r\n}\r\nif (test_and_set_bit(0, &local->ccs_lock)) {\r\ndev_dbg(&link->dev, "ray_cs ccs_lock busy\n");\r\nreturn ECCSBUSY;\r\n}\r\nfor (i = NUMBER_OF_TX_CCS; i < NUMBER_OF_CCS; i++) {\r\nif (readb(&(pccs + i)->buffer_status) == CCS_BUFFER_FREE) {\r\nwriteb(CCS_BUFFER_BUSY, &(pccs + i)->buffer_status);\r\nwriteb(CCS_END_LIST, &(pccs + i)->link);\r\nlocal->ccs_lock = 0;\r\nreturn i;\r\n}\r\n}\r\nlocal->ccs_lock = 0;\r\ndev_dbg(&link->dev, "ray_cs ERROR no free CCS for raylink card\n");\r\nreturn ECCSFULL;\r\n}\r\nstatic void authenticate_timeout(u_long data)\r\n{\r\nray_dev_t *local = (ray_dev_t *) data;\r\ndel_timer(&local->timer);\r\nprintk(KERN_INFO "ray_cs Authentication with access point failed"\r\n" - timeout\n");\r\njoin_net((u_long) local);\r\n}\r\nstatic int parse_addr(char *in_str, UCHAR *out)\r\n{\r\nint len;\r\nint i, j, k;\r\nint status;\r\nif (in_str == NULL)\r\nreturn 0;\r\nif ((len = strlen(in_str)) < 2)\r\nreturn 0;\r\nmemset(out, 0, ADDRLEN);\r\nstatus = 1;\r\nj = len - 1;\r\nif (j > 12)\r\nj = 12;\r\ni = 5;\r\nwhile (j > 0) {\r\nif ((k = hex_to_bin(in_str[j--])) != -1)\r\nout[i] = k;\r\nelse\r\nreturn 0;\r\nif (j == 0)\r\nbreak;\r\nif ((k = hex_to_bin(in_str[j--])) != -1)\r\nout[i] += k << 4;\r\nelse\r\nreturn 0;\r\nif (!i--)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic struct net_device_stats *ray_get_stats(struct net_device *dev)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\nstruct status __iomem *p = local->sram + STATUS_BASE;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs net_device_stats - device not present\n");\r\nreturn &local->stats;\r\n}\r\nif (readb(&p->mrx_overflow_for_host)) {\r\nlocal->stats.rx_over_errors += swab16(readw(&p->mrx_overflow));\r\nwriteb(0, &p->mrx_overflow);\r\nwriteb(0, &p->mrx_overflow_for_host);\r\n}\r\nif (readb(&p->mrx_checksum_error_for_host)) {\r\nlocal->stats.rx_crc_errors +=\r\nswab16(readw(&p->mrx_checksum_error));\r\nwriteb(0, &p->mrx_checksum_error);\r\nwriteb(0, &p->mrx_checksum_error_for_host);\r\n}\r\nif (readb(&p->rx_hec_error_for_host)) {\r\nlocal->stats.rx_frame_errors += swab16(readw(&p->rx_hec_error));\r\nwriteb(0, &p->rx_hec_error);\r\nwriteb(0, &p->rx_hec_error_for_host);\r\n}\r\nreturn &local->stats;\r\n}\r\nstatic void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value,\r\nint len)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\nint ccsindex;\r\nint i;\r\nstruct ccs __iomem *pccs;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_update_parm - device not present\n");\r\nreturn;\r\n}\r\nif ((ccsindex = get_free_ccs(local)) < 0) {\r\ndev_dbg(&link->dev, "ray_update_parm - No free ccs\n");\r\nreturn;\r\n}\r\npccs = ccs_base(local) + ccsindex;\r\nwriteb(CCS_UPDATE_PARAMS, &pccs->cmd);\r\nwriteb(objid, &pccs->var.update_param.object_id);\r\nwriteb(1, &pccs->var.update_param.number_objects);\r\nwriteb(0, &pccs->var.update_param.failure_cause);\r\nfor (i = 0; i < len; i++) {\r\nwriteb(value[i], local->sram + HOST_TO_ECF_BASE);\r\n}\r\nif (interrupt_ecf(local, ccsindex)) {\r\ndev_dbg(&link->dev, "ray_cs associate failed - ECF not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\n}\r\n}\r\nstatic void ray_update_multi_list(struct net_device *dev, int all)\r\n{\r\nint ccsindex;\r\nstruct ccs __iomem *pccs;\r\nray_dev_t *local = netdev_priv(dev);\r\nstruct pcmcia_device *link = local->finder;\r\nvoid __iomem *p = local->sram + HOST_TO_ECF_BASE;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_update_multi_list - device not present\n");\r\nreturn;\r\n} else\r\ndev_dbg(&link->dev, "ray_update_multi_list(%p)\n", dev);\r\nif ((ccsindex = get_free_ccs(local)) < 0) {\r\ndev_dbg(&link->dev, "ray_update_multi - No free ccs\n");\r\nreturn;\r\n}\r\npccs = ccs_base(local) + ccsindex;\r\nwriteb(CCS_UPDATE_MULTICAST_LIST, &pccs->cmd);\r\nif (all) {\r\nwriteb(0xff, &pccs->var);\r\nlocal->num_multi = 0xff;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nint i = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nmemcpy_toio(p, ha->addr, ETH_ALEN);\r\ndev_dbg(&link->dev, "ray_update_multi add addr %pm\n",\r\nha->addr);\r\np += ETH_ALEN;\r\ni++;\r\n}\r\nif (i > 256 / ADDRLEN)\r\ni = 256 / ADDRLEN;\r\nwriteb((UCHAR) i, &pccs->var);\r\ndev_dbg(&link->dev, "ray_cs update_multi %d addresses in list\n", i);\r\nlocal->num_multi = i;\r\n}\r\nif (interrupt_ecf(local, ccsindex)) {\r\ndev_dbg(&link->dev,\r\n"ray_cs update_multi failed - ECF not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\n}\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nray_dev_t *local = netdev_priv(dev);\r\nUCHAR promisc;\r\npr_debug("ray_cs set_multicast_list(%p)\n", dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nif (local->sparm.b5.a_promiscuous_mode == 0) {\r\npr_debug("ray_cs set_multicast_list promisc on\n");\r\nlocal->sparm.b5.a_promiscuous_mode = 1;\r\npromisc = 1;\r\nray_update_parm(dev, OBJID_promiscuous_mode,\r\n&promisc, sizeof(promisc));\r\n}\r\n} else {\r\nif (local->sparm.b5.a_promiscuous_mode == 1) {\r\npr_debug("ray_cs set_multicast_list promisc off\n");\r\nlocal->sparm.b5.a_promiscuous_mode = 0;\r\npromisc = 0;\r\nray_update_parm(dev, OBJID_promiscuous_mode,\r\n&promisc, sizeof(promisc));\r\n}\r\n}\r\nif (dev->flags & IFF_ALLMULTI)\r\nray_update_multi_list(dev, 1);\r\nelse {\r\nif (local->num_multi != netdev_mc_count(dev))\r\nray_update_multi_list(dev, 0);\r\n}\r\n}\r\nstatic irqreturn_t ray_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct pcmcia_device *link;\r\nray_dev_t *local;\r\nstruct ccs __iomem *pccs;\r\nstruct rcs __iomem *prcs;\r\nUCHAR rcsindex;\r\nUCHAR tmp;\r\nUCHAR cmd;\r\nUCHAR status;\r\nif (dev == NULL)\r\nreturn IRQ_NONE;\r\npr_debug("ray_cs: interrupt for *dev=%p\n", dev);\r\nlocal = netdev_priv(dev);\r\nlink = (struct pcmcia_device *)local->finder;\r\nif (!pcmcia_dev_present(link)) {\r\npr_debug(\r\n"ray_cs interrupt from device not present or suspended.\n");\r\nreturn IRQ_NONE;\r\n}\r\nrcsindex = readb(&((struct scb __iomem *)(local->sram))->rcs_index);\r\nif (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {\r\ndev_dbg(&link->dev, "ray_cs interrupt bad rcsindex = 0x%x\n", rcsindex);\r\nclear_interrupt(local);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (rcsindex < NUMBER_OF_CCS) {\r\npccs = ccs_base(local) + rcsindex;\r\ncmd = readb(&pccs->cmd);\r\nstatus = readb(&pccs->buffer_status);\r\nswitch (cmd) {\r\ncase CCS_DOWNLOAD_STARTUP_PARAMS:\r\ndel_timer(&local->timer);\r\nif (status == CCS_COMMAND_COMPLETE) {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt download_startup_parameters OK\n");\r\n} else {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt download_startup_parameters fail\n");\r\n}\r\nbreak;\r\ncase CCS_UPDATE_PARAMS:\r\ndev_dbg(&link->dev, "ray_cs interrupt update params done\n");\r\nif (status != CCS_COMMAND_COMPLETE) {\r\ntmp =\r\nreadb(&pccs->var.update_param.\r\nfailure_cause);\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt update params failed - reason %d\n",\r\ntmp);\r\n}\r\nbreak;\r\ncase CCS_REPORT_PARAMS:\r\ndev_dbg(&link->dev, "ray_cs interrupt report params done\n");\r\nbreak;\r\ncase CCS_UPDATE_MULTICAST_LIST:\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt CCS Update Multicast List done\n");\r\nbreak;\r\ncase CCS_UPDATE_POWER_SAVINGS_MODE:\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt update power save mode done\n");\r\nbreak;\r\ncase CCS_START_NETWORK:\r\ncase CCS_JOIN_NETWORK:\r\nif (status == CCS_COMMAND_COMPLETE) {\r\nif (readb\r\n(&pccs->var.start_network.net_initiated) ==\r\n1) {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt network \"%s\" started\n",\r\nlocal->sparm.b4.a_current_ess_id);\r\n} else {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt network \"%s\" joined\n",\r\nlocal->sparm.b4.a_current_ess_id);\r\n}\r\nmemcpy_fromio(&local->bss_id,\r\npccs->var.start_network.bssid,\r\nADDRLEN);\r\nif (local->fw_ver == 0x55)\r\nlocal->net_default_tx_rate = 3;\r\nelse\r\nlocal->net_default_tx_rate =\r\nreadb(&pccs->var.start_network.\r\nnet_default_tx_rate);\r\nlocal->encryption =\r\nreadb(&pccs->var.start_network.encryption);\r\nif (!sniffer && (local->net_type == INFRA)\r\n&& !(local->sparm.b4.a_acting_as_ap_status)) {\r\nauthenticate(local);\r\n}\r\nlocal->card_status = CARD_ACQ_COMPLETE;\r\n} else {\r\nlocal->card_status = CARD_ACQ_FAILED;\r\ndel_timer(&local->timer);\r\nlocal->timer.expires = jiffies + HZ * 5;\r\nlocal->timer.data = (long)local;\r\nif (status == CCS_START_NETWORK) {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt network \"%s\" start failed\n",\r\nlocal->sparm.b4.a_current_ess_id);\r\nlocal->timer.function = start_net;\r\n} else {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt network \"%s\" join failed\n",\r\nlocal->sparm.b4.a_current_ess_id);\r\nlocal->timer.function = join_net;\r\n}\r\nadd_timer(&local->timer);\r\n}\r\nbreak;\r\ncase CCS_START_ASSOCIATION:\r\nif (status == CCS_COMMAND_COMPLETE) {\r\nlocal->card_status = CARD_ASSOC_COMPLETE;\r\ndev_dbg(&link->dev, "ray_cs association successful\n");\r\n} else {\r\ndev_dbg(&link->dev, "ray_cs association failed,\n");\r\nlocal->card_status = CARD_ASSOC_FAILED;\r\njoin_net((u_long) local);\r\n}\r\nbreak;\r\ncase CCS_TX_REQUEST:\r\nif (status == CCS_COMMAND_COMPLETE) {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt tx request complete\n");\r\n} else {\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt tx request failed\n");\r\n}\r\nif (!sniffer)\r\nnetif_start_queue(dev);\r\nnetif_wake_queue(dev);\r\nbreak;\r\ncase CCS_TEST_MEMORY:\r\ndev_dbg(&link->dev, "ray_cs interrupt mem test done\n");\r\nbreak;\r\ncase CCS_SHUTDOWN:\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt Unexpected CCS returned - Shutdown\n");\r\nbreak;\r\ncase CCS_DUMP_MEMORY:\r\ndev_dbg(&link->dev, "ray_cs interrupt dump memory done\n");\r\nbreak;\r\ncase CCS_START_TIMER:\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt DING - raylink timer expired\n");\r\nbreak;\r\ndefault:\r\ndev_dbg(&link->dev,\r\n"ray_cs interrupt Unexpected CCS 0x%x returned 0x%x\n",\r\nrcsindex, cmd);\r\n}\r\nwriteb(CCS_BUFFER_FREE, &pccs->buffer_status);\r\n} else {\r\nprcs = rcs_base(local) + rcsindex;\r\nswitch (readb(&prcs->interrupt_id)) {\r\ncase PROCESS_RX_PACKET:\r\nray_rx(dev, local, prcs);\r\nbreak;\r\ncase REJOIN_NET_COMPLETE:\r\ndev_dbg(&link->dev, "ray_cs interrupt rejoin net complete\n");\r\nlocal->card_status = CARD_ACQ_COMPLETE;\r\nif (local->sparm.b4.a_network_type == ADHOC) {\r\nif (!sniffer)\r\nnetif_start_queue(dev);\r\n} else {\r\nmemcpy_fromio(&local->bss_id,\r\nprcs->var.rejoin_net_complete.\r\nbssid, ADDRLEN);\r\ndev_dbg(&link->dev, "ray_cs new BSSID = %pm\n",\r\nlocal->bss_id);\r\nif (!sniffer)\r\nauthenticate(local);\r\n}\r\nbreak;\r\ncase ROAMING_INITIATED:\r\ndev_dbg(&link->dev, "ray_cs interrupt roaming initiated\n");\r\nnetif_stop_queue(dev);\r\nlocal->card_status = CARD_DOING_ACQ;\r\nbreak;\r\ncase JAPAN_CALL_SIGN_RXD:\r\ndev_dbg(&link->dev, "ray_cs interrupt japan call sign rx\n");\r\nbreak;\r\ndefault:\r\ndev_dbg(&link->dev,\r\n"ray_cs Unexpected interrupt for RCS 0x%x cmd = 0x%x\n",\r\nrcsindex,\r\n(unsigned int)readb(&prcs->interrupt_id));\r\nbreak;\r\n}\r\nwriteb(CCS_BUFFER_FREE, &prcs->buffer_status);\r\n}\r\nclear_interrupt(local);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ray_rx(struct net_device *dev, ray_dev_t *local,\r\nstruct rcs __iomem *prcs)\r\n{\r\nint rx_len;\r\nunsigned int pkt_addr;\r\nvoid __iomem *pmsg;\r\npr_debug("ray_rx process rx packet\n");\r\npkt_addr = ((readb(&prcs->var.rx_packet.rx_data_ptr[0]) << 8)\r\n+ readb(&prcs->var.rx_packet.rx_data_ptr[1])) & RX_BUFF_END;\r\nrx_len = (readb(&prcs->var.rx_packet.rx_data_length[0]) << 8)\r\n+ readb(&prcs->var.rx_packet.rx_data_length[1]);\r\nlocal->last_rsl = readb(&prcs->var.rx_packet.rx_sig_lev);\r\npmsg = local->rmem + pkt_addr;\r\nswitch (readb(pmsg)) {\r\ncase DATA_TYPE:\r\npr_debug("ray_rx data type\n");\r\nrx_data(dev, prcs, pkt_addr, rx_len);\r\nbreak;\r\ncase AUTHENTIC_TYPE:\r\npr_debug("ray_rx authentic type\n");\r\nif (sniffer)\r\nrx_data(dev, prcs, pkt_addr, rx_len);\r\nelse\r\nrx_authenticate(local, prcs, pkt_addr, rx_len);\r\nbreak;\r\ncase DEAUTHENTIC_TYPE:\r\npr_debug("ray_rx deauth type\n");\r\nif (sniffer)\r\nrx_data(dev, prcs, pkt_addr, rx_len);\r\nelse\r\nrx_deauthenticate(local, prcs, pkt_addr, rx_len);\r\nbreak;\r\ncase NULL_MSG_TYPE:\r\npr_debug("ray_cs rx NULL msg\n");\r\nbreak;\r\ncase BEACON_TYPE:\r\npr_debug("ray_rx beacon type\n");\r\nif (sniffer)\r\nrx_data(dev, prcs, pkt_addr, rx_len);\r\ncopy_from_rx_buff(local, (UCHAR *) &local->last_bcn, pkt_addr,\r\nrx_len < sizeof(struct beacon_rx) ?\r\nrx_len : sizeof(struct beacon_rx));\r\nlocal->beacon_rxed = 1;\r\nray_get_stats(dev);\r\nbreak;\r\ndefault:\r\npr_debug("ray_cs unknown pkt type %2x\n",\r\n(unsigned int)readb(pmsg));\r\nbreak;\r\n}\r\n}\r\nstatic void rx_data(struct net_device *dev, struct rcs __iomem *prcs,\r\nunsigned int pkt_addr, int rx_len)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rcs __iomem *prcslink = prcs;\r\nray_dev_t *local = netdev_priv(dev);\r\nUCHAR *rx_ptr;\r\nint total_len;\r\nint tmp;\r\n#ifdef WIRELESS_SPY\r\nint siglev = local->last_rsl;\r\nu_char linksrcaddr[ETH_ALEN];\r\n#endif\r\nif (!sniffer) {\r\nif (translate) {\r\nif (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||\r\nrx_len >\r\n(dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +\r\nFCS_LEN)) {\r\npr_debug(\r\n"ray_cs invalid packet length %d received\n",\r\nrx_len);\r\nreturn;\r\n}\r\n} else {\r\nif (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||\r\nrx_len >\r\n(dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +\r\nFCS_LEN)) {\r\npr_debug(\r\n"ray_cs invalid packet length %d received\n",\r\nrx_len);\r\nreturn;\r\n}\r\n}\r\n}\r\npr_debug("ray_cs rx_data packet\n");\r\nif (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {\r\npr_debug("ray_cs rx'ed fragment\n");\r\ntmp = (readb(&prcs->var.rx_packet.totalpacketlength[0]) << 8)\r\n+ readb(&prcs->var.rx_packet.totalpacketlength[1]);\r\ntotal_len = tmp;\r\nprcslink = prcs;\r\ndo {\r\ntmp -=\r\n(readb(&prcslink->var.rx_packet.rx_data_length[0])\r\n<< 8)\r\n+ readb(&prcslink->var.rx_packet.rx_data_length[1]);\r\nif (readb(&prcslink->var.rx_packet.next_frag_rcs_index)\r\n== 0xFF || tmp < 0)\r\nbreak;\r\nprcslink = rcs_base(local)\r\n+ readb(&prcslink->link_field);\r\n} while (1);\r\nif (tmp < 0) {\r\npr_debug(\r\n"ray_cs rx_data fragment lengths don't add up\n");\r\nlocal->stats.rx_dropped++;\r\nrelease_frag_chain(local, prcs);\r\nreturn;\r\n}\r\n} else {\r\ntotal_len = rx_len;\r\n}\r\nskb = dev_alloc_skb(total_len + 5);\r\nif (skb == NULL) {\r\npr_debug("ray_cs rx_data could not allocate skb\n");\r\nlocal->stats.rx_dropped++;\r\nif (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF)\r\nrelease_frag_chain(local, prcs);\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\npr_debug("ray_cs rx_data total_len = %x, rx_len = %x\n", total_len,\r\nrx_len);\r\nrx_ptr = skb_put(skb, total_len);\r\nrx_ptr +=\r\ncopy_from_rx_buff(local, rx_ptr, pkt_addr & RX_BUFF_END, rx_len);\r\n#ifdef WIRELESS_SPY\r\nskb_copy_from_linear_data_offset(skb,\r\noffsetof(struct mac_header, addr_2),\r\nlinksrcaddr, ETH_ALEN);\r\n#endif\r\nif (!sniffer) {\r\nif (!translate) {\r\nskb_pull(skb, RX_MAC_HEADER_LENGTH);\r\n} else {\r\nuntranslate(local, skb, total_len);\r\n}\r\n} else {\r\n};\r\ntmp = 17;\r\nif (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {\r\nprcslink = prcs;\r\npr_debug("ray_cs rx_data in fragment loop\n");\r\ndo {\r\nprcslink = rcs_base(local)\r\n+\r\nreadb(&prcslink->var.rx_packet.next_frag_rcs_index);\r\nrx_len =\r\n((readb(&prcslink->var.rx_packet.rx_data_length[0])\r\n<< 8)\r\n+\r\nreadb(&prcslink->var.rx_packet.rx_data_length[1]))\r\n& RX_BUFF_END;\r\npkt_addr =\r\n((readb(&prcslink->var.rx_packet.rx_data_ptr[0]) <<\r\n8)\r\n+ readb(&prcslink->var.rx_packet.rx_data_ptr[1]))\r\n& RX_BUFF_END;\r\nrx_ptr +=\r\ncopy_from_rx_buff(local, rx_ptr, pkt_addr, rx_len);\r\n} while (tmp-- &&\r\nreadb(&prcslink->var.rx_packet.next_frag_rcs_index) !=\r\n0xFF);\r\nrelease_frag_chain(local, prcs);\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\nlocal->stats.rx_packets++;\r\nlocal->stats.rx_bytes += total_len;\r\n#ifdef WIRELESS_SPY\r\nif (!memcmp(linksrcaddr, local->bss_id, ETH_ALEN)) {\r\nlocal->wstats.qual.level = siglev;\r\nlocal->wstats.qual.updated = 0x2;\r\n}\r\n{\r\nstruct iw_quality wstats;\r\nwstats.level = siglev;\r\nwstats.updated = 0x2;\r\nwireless_spy_update(dev, linksrcaddr, &wstats);\r\n}\r\n#endif\r\n}\r\nstatic void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)\r\n{\r\nsnaphdr_t *psnap = (snaphdr_t *) (skb->data + RX_MAC_HEADER_LENGTH);\r\nstruct ieee80211_hdr *pmac = (struct ieee80211_hdr *)skb->data;\r\n__be16 type = *(__be16 *) psnap->ethertype;\r\nint delta;\r\nstruct ethhdr *peth;\r\nUCHAR srcaddr[ADDRLEN];\r\nUCHAR destaddr[ADDRLEN];\r\nstatic const UCHAR org_bridge[3] = { 0, 0, 0xf8 };\r\nstatic const UCHAR org_1042[3] = { 0, 0, 0 };\r\nmemcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);\r\nmemcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);\r\n#if 0\r\nif {\r\nprint_hex_dump(KERN_DEBUG, "skb->data before untranslate: ",\r\nDUMP_PREFIX_NONE, 16, 1,\r\nskb->data, 64, true);\r\nprintk(KERN_DEBUG\r\n"type = %08x, xsap = %02x%02x%02x, org = %02x02x02x\n",\r\nntohs(type), psnap->dsap, psnap->ssap, psnap->ctrl,\r\npsnap->org[0], psnap->org[1], psnap->org[2]);\r\nprintk(KERN_DEBUG "untranslate skb->data = %p\n", skb->data);\r\n}\r\n#endif\r\nif (psnap->dsap != 0xaa || psnap->ssap != 0xaa || psnap->ctrl != 3) {\r\npr_debug("ray_cs untranslate NOT SNAP %02x %02x %02x\n",\r\npsnap->dsap, psnap->ssap, psnap->ctrl);\r\ndelta = RX_MAC_HEADER_LENGTH - ETH_HLEN;\r\npeth = (struct ethhdr *)(skb->data + delta);\r\npeth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);\r\n} else {\r\nif (memcmp(psnap->org, org_bridge, 3) == 0) {\r\npr_debug("ray_cs untranslate Bridge encap\n");\r\ndelta = RX_MAC_HEADER_LENGTH\r\n+ sizeof(struct snaphdr_t) - ETH_HLEN;\r\npeth = (struct ethhdr *)(skb->data + delta);\r\npeth->h_proto = type;\r\n} else if (memcmp(psnap->org, org_1042, 3) == 0) {\r\nswitch (ntohs(type)) {\r\ncase ETH_P_IPX:\r\ncase ETH_P_AARP:\r\npr_debug("ray_cs untranslate RFC IPX/AARP\n");\r\ndelta = RX_MAC_HEADER_LENGTH - ETH_HLEN;\r\npeth = (struct ethhdr *)(skb->data + delta);\r\npeth->h_proto =\r\nhtons(len - RX_MAC_HEADER_LENGTH);\r\nbreak;\r\ndefault:\r\npr_debug("ray_cs untranslate RFC default\n");\r\ndelta = RX_MAC_HEADER_LENGTH +\r\nsizeof(struct snaphdr_t) - ETH_HLEN;\r\npeth = (struct ethhdr *)(skb->data + delta);\r\npeth->h_proto = type;\r\nbreak;\r\n}\r\n} else {\r\nprintk("ray_cs untranslate very confused by packet\n");\r\ndelta = RX_MAC_HEADER_LENGTH - ETH_HLEN;\r\npeth = (struct ethhdr *)(skb->data + delta);\r\npeth->h_proto = type;\r\n}\r\n}\r\nskb_pull(skb, delta);\r\npr_debug("untranslate after skb_pull(%d), skb->data = %p\n", delta,\r\nskb->data);\r\nmemcpy(peth->h_dest, destaddr, ADDRLEN);\r\nmemcpy(peth->h_source, srcaddr, ADDRLEN);\r\n#if 0\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "skb->data after untranslate:");\r\nfor (i = 0; i < 64; i++)\r\nprintk("%02x ", skb->data[i]);\r\nprintk("\n");\r\n}\r\n#endif\r\n}\r\nstatic int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr,\r\nint length)\r\n{\r\nint wrap_bytes = (pkt_addr + length) - (RX_BUFF_END + 1);\r\nif (wrap_bytes <= 0) {\r\nmemcpy_fromio(dest, local->rmem + pkt_addr, length);\r\n} else {\r\nmemcpy_fromio(dest, local->rmem + pkt_addr,\r\nlength - wrap_bytes);\r\nmemcpy_fromio(dest + length - wrap_bytes, local->rmem,\r\nwrap_bytes);\r\n}\r\nreturn length;\r\n}\r\nstatic void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs)\r\n{\r\nstruct rcs __iomem *prcslink = prcs;\r\nint tmp = 17;\r\nunsigned rcsindex = readb(&prcs->var.rx_packet.next_frag_rcs_index);\r\nwhile (tmp--) {\r\nwriteb(CCS_BUFFER_FREE, &prcslink->buffer_status);\r\nif (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {\r\npr_debug("ray_cs interrupt bad rcsindex = 0x%x\n",\r\nrcsindex);\r\nbreak;\r\n}\r\nprcslink = rcs_base(local) + rcsindex;\r\nrcsindex = readb(&prcslink->var.rx_packet.next_frag_rcs_index);\r\n}\r\nwriteb(CCS_BUFFER_FREE, &prcslink->buffer_status);\r\n}\r\nstatic void authenticate(ray_dev_t *local)\r\n{\r\nstruct pcmcia_device *link = local->finder;\r\ndev_dbg(&link->dev, "ray_cs Starting authentication.\n");\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs authenticate - device not present\n");\r\nreturn;\r\n}\r\ndel_timer(&local->timer);\r\nif (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {\r\nlocal->timer.function = join_net;\r\n} else {\r\nlocal->timer.function = authenticate_timeout;\r\n}\r\nlocal->timer.expires = jiffies + HZ * 2;\r\nlocal->timer.data = (long)local;\r\nadd_timer(&local->timer);\r\nlocal->authentication_state = AWAITING_RESPONSE;\r\n}\r\nstatic void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,\r\nunsigned int pkt_addr, int rx_len)\r\n{\r\nUCHAR buff[256];\r\nstruct ray_rx_msg *msg = (struct ray_rx_msg *) buff;\r\ndel_timer(&local->timer);\r\ncopy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);\r\nif (local->sparm.b4.a_network_type == ADHOC) {\r\npr_debug("ray_cs rx_auth var= %02x %02x %02x %02x %02x %02x\n",\r\nmsg->var[0], msg->var[1], msg->var[2], msg->var[3],\r\nmsg->var[4], msg->var[5]);\r\nif (msg->var[2] == 1) {\r\npr_debug("ray_cs Sending authentication response.\n");\r\nif (!build_auth_frame\r\n(local, msg->mac.addr_2, OPEN_AUTH_RESPONSE)) {\r\nlocal->authentication_state = NEED_TO_AUTH;\r\nmemcpy(local->auth_id, msg->mac.addr_2,\r\nADDRLEN);\r\n}\r\n}\r\n} else {\r\nif (local->authentication_state == AWAITING_RESPONSE) {\r\nif (msg->var[2] == 2) {\r\nif ((msg->var[3] | msg->var[4]) == 0) {\r\npr_debug("Authentication successful\n");\r\nlocal->card_status = CARD_AUTH_COMPLETE;\r\nassociate(local);\r\nlocal->authentication_state =\r\nAUTHENTICATED;\r\n} else {\r\npr_debug("Authentication refused\n");\r\nlocal->card_status = CARD_AUTH_REFUSED;\r\njoin_net((u_long) local);\r\nlocal->authentication_state =\r\nUNAUTHENTICATED;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void associate(ray_dev_t *local)\r\n{\r\nstruct ccs __iomem *pccs;\r\nstruct pcmcia_device *link = local->finder;\r\nstruct net_device *dev = link->priv;\r\nint ccsindex;\r\nif (!(pcmcia_dev_present(link))) {\r\ndev_dbg(&link->dev, "ray_cs associate - device not present\n");\r\nreturn;\r\n}\r\nif ((ccsindex = get_free_ccs(local)) < 0) {\r\ndev_dbg(&link->dev, "ray_cs associate - No free ccs\n");\r\nreturn;\r\n}\r\ndev_dbg(&link->dev, "ray_cs Starting association with access point\n");\r\npccs = ccs_base(local) + ccsindex;\r\nwriteb(CCS_START_ASSOCIATION, &pccs->cmd);\r\nif (interrupt_ecf(local, ccsindex)) {\r\ndev_dbg(&link->dev, "ray_cs associate failed - ECF not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\ndel_timer(&local->timer);\r\nlocal->timer.expires = jiffies + HZ * 2;\r\nlocal->timer.data = (long)local;\r\nlocal->timer.function = join_net;\r\nadd_timer(&local->timer);\r\nlocal->card_status = CARD_ASSOC_FAILED;\r\nreturn;\r\n}\r\nif (!sniffer)\r\nnetif_start_queue(dev);\r\n}\r\nstatic void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,\r\nunsigned int pkt_addr, int rx_len)\r\n{\r\npr_debug("Deauthentication frame received\n");\r\nlocal->authentication_state = UNAUTHENTICATED;\r\n}\r\nstatic void clear_interrupt(ray_dev_t *local)\r\n{\r\nwriteb(0, local->amem + CIS_OFFSET + HCS_INTR_OFFSET);\r\n}\r\nstatic int ray_cs_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nstruct pcmcia_device *link;\r\nstruct net_device *dev;\r\nray_dev_t *local;\r\nUCHAR *p;\r\nstruct freq_hop_element *pfh;\r\nUCHAR c[33];\r\nlink = this_device;\r\nif (!link)\r\nreturn 0;\r\ndev = (struct net_device *)link->priv;\r\nif (!dev)\r\nreturn 0;\r\nlocal = netdev_priv(dev);\r\nif (!local)\r\nreturn 0;\r\nseq_puts(m, "Raylink Wireless LAN driver status\n");\r\nseq_printf(m, "%s\n", rcsid);\r\nseq_puts(m, "Firmware version = ");\r\nif (local->fw_ver == 0x55)\r\nseq_puts(m, "4 - Use dump_cis for more details\n");\r\nelse\r\nseq_printf(m, "%2d.%02d.%02d\n",\r\nlocal->fw_ver, local->fw_bld, local->fw_var);\r\nfor (i = 0; i < 32; i++)\r\nc[i] = local->sparm.b5.a_current_ess_id[i];\r\nc[32] = 0;\r\nseq_printf(m, "%s network ESSID = \"%s\"\n",\r\nnettype[local->sparm.b5.a_network_type], c);\r\np = local->bss_id;\r\nseq_printf(m, "BSSID = %pM\n", p);\r\nseq_printf(m, "Country code = %d\n",\r\nlocal->sparm.b5.a_curr_country_code);\r\ni = local->card_status;\r\nif (i < 0)\r\ni = 10;\r\nif (i > 16)\r\ni = 10;\r\nseq_printf(m, "Card status = %s\n", card_status[i]);\r\nseq_printf(m, "Framing mode = %s\n", framing[translate]);\r\nseq_printf(m, "Last pkt signal lvl = %d\n", local->last_rsl);\r\nif (local->beacon_rxed) {\r\nseq_printf(m, "Beacon Interval = %d Kus\n",\r\nlocal->last_bcn.beacon_intvl[0]\r\n+ 256 * local->last_bcn.beacon_intvl[1]);\r\np = local->last_bcn.elements;\r\nif (p[0] == C_ESSID_ELEMENT_ID)\r\np += p[1] + 2;\r\nelse {\r\nseq_printf(m,\r\n"Parse beacon failed at essid element id = %d\n",\r\np[0]);\r\nreturn 0;\r\n}\r\nif (p[0] == C_SUPPORTED_RATES_ELEMENT_ID) {\r\nseq_puts(m, "Supported rate codes = ");\r\nfor (i = 2; i < p[1] + 2; i++)\r\nseq_printf(m, "0x%02x ", p[i]);\r\nseq_putc(m, '\n');\r\np += p[1] + 2;\r\n} else {\r\nseq_puts(m, "Parse beacon failed at rates element\n");\r\nreturn 0;\r\n}\r\nif (p[0] == C_FH_PARAM_SET_ELEMENT_ID) {\r\npfh = (struct freq_hop_element *)p;\r\nseq_printf(m, "Hop dwell = %d Kus\n",\r\npfh->dwell_time[0] +\r\n256 * pfh->dwell_time[1]);\r\nseq_printf(m, "Hop set = %d\n",\r\npfh->hop_set);\r\nseq_printf(m, "Hop pattern = %d\n",\r\npfh->hop_pattern);\r\nseq_printf(m, "Hop index = %d\n",\r\npfh->hop_index);\r\np += p[1] + 2;\r\n} else {\r\nseq_puts(m,\r\n"Parse beacon failed at FH param element\n");\r\nreturn 0;\r\n}\r\n} else {\r\nseq_puts(m, "No beacons received\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ray_cs_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ray_cs_proc_show, NULL);\r\n}\r\nstatic int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)\r\n{\r\nint addr;\r\nstruct ccs __iomem *pccs;\r\nstruct tx_msg __iomem *ptx;\r\nint ccsindex;\r\nif ((ccsindex = get_free_tx_ccs(local)) < 0) {\r\npr_debug("ray_cs send authenticate - No free tx ccs\n");\r\nreturn -1;\r\n}\r\npccs = ccs_base(local) + ccsindex;\r\naddr = TX_BUF_BASE + (ccsindex << 11);\r\nwriteb(CCS_TX_REQUEST, &pccs->cmd);\r\nwriteb(addr >> 8, pccs->var.tx_request.tx_data_ptr);\r\nwriteb(0x20, pccs->var.tx_request.tx_data_ptr + 1);\r\nwriteb(TX_AUTHENTICATE_LENGTH_MSB, pccs->var.tx_request.tx_data_length);\r\nwriteb(TX_AUTHENTICATE_LENGTH_LSB,\r\npccs->var.tx_request.tx_data_length + 1);\r\nwriteb(0, &pccs->var.tx_request.pow_sav_mode);\r\nptx = local->sram + addr;\r\nwriteb(PROTOCOL_VER | AUTHENTIC_TYPE, &ptx->mac.frame_ctl_1);\r\nwriteb(0, &ptx->mac.frame_ctl_2);\r\nmemcpy_toio(ptx->mac.addr_1, dest, ADDRLEN);\r\nmemcpy_toio(ptx->mac.addr_2, local->sparm.b4.a_mac_addr, ADDRLEN);\r\nmemcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);\r\nmemset_io(ptx->var, 0, 6);\r\nwriteb(auth_type & 0xff, ptx->var + 2);\r\nif (interrupt_ecf(local, ccsindex)) {\r\npr_debug(\r\n"ray_cs send authentication request failed - ECF not ready for intr\n");\r\nwriteb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ray_cs_essid_proc_write(struct file *file,\r\nconst char __user *buffer, size_t count, loff_t *pos)\r\n{\r\nstatic char proc_essid[33];\r\nunsigned int len = count;\r\nif (len > 32)\r\nlen = 32;\r\nmemset(proc_essid, 0, 33);\r\nif (copy_from_user(proc_essid, buffer, len))\r\nreturn -EFAULT;\r\nessid = proc_essid;\r\nreturn count;\r\n}\r\nstatic ssize_t int_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nstatic char proc_number[10];\r\nchar *p;\r\nint nr, len;\r\nif (!count)\r\nreturn 0;\r\nif (count > 9)\r\nreturn -EINVAL;\r\nif (copy_from_user(proc_number, buffer, count))\r\nreturn -EFAULT;\r\np = proc_number;\r\nnr = 0;\r\nlen = count;\r\ndo {\r\nunsigned int c = *p - '0';\r\nif (c > 9)\r\nreturn -EINVAL;\r\nnr = nr * 10 + c;\r\np++;\r\n} while (--len);\r\n*(int *)PDE(file->f_path.dentry->d_inode)->data = nr;\r\nreturn count;\r\n}\r\nstatic int __init init_ray_cs(void)\r\n{\r\nint rc;\r\npr_debug("%s\n", rcsid);\r\nrc = pcmcia_register_driver(&ray_driver);\r\npr_debug("raylink init_module register_pcmcia_driver returns 0x%x\n",\r\nrc);\r\n#ifdef CONFIG_PROC_FS\r\nproc_mkdir("driver/ray_cs", NULL);\r\nproc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);\r\nproc_create("driver/ray_cs/essid", S_IWUSR, NULL, &ray_cs_essid_proc_fops);\r\nproc_create_data("driver/ray_cs/net_type", S_IWUSR, NULL, &int_proc_fops, &net_type);\r\nproc_create_data("driver/ray_cs/translate", S_IWUSR, NULL, &int_proc_fops, &translate);\r\n#endif\r\nif (translate != 0)\r\ntranslate = 1;\r\nreturn 0;\r\n}\r\nstatic void __exit exit_ray_cs(void)\r\n{\r\npr_debug("ray_cs: cleanup_module\n");\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("driver/ray_cs/ray_cs", NULL);\r\nremove_proc_entry("driver/ray_cs/essid", NULL);\r\nremove_proc_entry("driver/ray_cs/net_type", NULL);\r\nremove_proc_entry("driver/ray_cs/translate", NULL);\r\nremove_proc_entry("driver/ray_cs", NULL);\r\n#endif\r\npcmcia_unregister_driver(&ray_driver);\r\n}
