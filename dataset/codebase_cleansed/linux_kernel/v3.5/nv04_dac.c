int nv04_dac_output_offset(struct drm_encoder *encoder)\r\n{\r\nstruct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;\r\nint offset = 0;\r\nif (dcb->or & (8 | OUTPUT_C))\r\noffset += 0x68;\r\nif (dcb->or & (8 | OUTPUT_B))\r\noffset += 0x2000;\r\nreturn offset;\r\n}\r\nstatic int sample_load_twice(struct drm_device *dev, bool sense[2])\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nbool sense_a, sense_b, sense_b_prime;\r\nint j = 0;\r\nif (!nouveau_wait_eq(dev, 10000000, NV_PRMCIO_INP0__COLOR,\r\n0x00000001, 0x00000000))\r\nreturn -EBUSY;\r\nif (!nouveau_wait_eq(dev, 10000000, NV_PRMCIO_INP0__COLOR,\r\n0x00000001, 0x00000001))\r\nreturn -EBUSY;\r\nif (!nouveau_wait_eq(dev, 10000000, NV_PRMCIO_INP0__COLOR,\r\n0x00000001, 0x00000000))\r\nreturn -EBUSY;\r\nudelay(100);\r\nsense_a = nv_rd08(dev, NV_PRMCIO_INP0) & 0x10;\r\ndo {\r\nudelay(100);\r\nsense_b = nv_rd08(dev, NV_PRMCIO_INP0) & 0x10;\r\nif (sense_a != sense_b) {\r\nsense_b_prime =\r\nnv_rd08(dev, NV_PRMCIO_INP0) & 0x10;\r\nif (sense_b == sense_b_prime) {\r\nsense_a = sense_b;\r\nsense_b = !sense_a;\r\n}\r\n}\r\n} while ((sense_a != sense_b) && ++j < MAX_HBLANK_OSC);\r\nif (j == MAX_HBLANK_OSC)\r\nsense[i] = false;\r\nelse\r\nsense[i] = sense_a;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum drm_connector_status nv04_dac_detect(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nuint8_t saved_seq1, saved_pi, saved_rpc1, saved_cr_mode;\r\nuint8_t saved_palette0[3], saved_palette_mask;\r\nuint32_t saved_rtest_ctrl, saved_rgen_ctrl;\r\nint i;\r\nuint8_t blue;\r\nbool sense = true;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, 0);\r\nsaved_cr_mode = NVReadVgaCrtc(dev, 0, NV_CIO_CR_MODE_INDEX);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CR_MODE_INDEX, saved_cr_mode | 0x80);\r\nsaved_seq1 = NVReadVgaSeq(dev, 0, NV_VIO_SR_CLOCK_INDEX);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_CLOCK_INDEX, saved_seq1 & ~0x20);\r\nsaved_rtest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL,\r\nsaved_rtest_ctrl & ~NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF);\r\nmsleep(10);\r\nsaved_pi = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX,\r\nsaved_pi & ~(0x80 | MASK(NV_CIO_CRE_PIXEL_FORMAT)));\r\nsaved_rpc1 = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_RPC1_INDEX);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_RPC1_INDEX, saved_rpc1 & ~0xc0);\r\nnv_wr08(dev, NV_PRMDIO_READ_MODE_ADDRESS, 0x0);\r\nfor (i = 0; i < 3; i++)\r\nsaved_palette0[i] = nv_rd08(dev, NV_PRMDIO_PALETTE_DATA);\r\nsaved_palette_mask = nv_rd08(dev, NV_PRMDIO_PIXEL_MASK);\r\nnv_wr08(dev, NV_PRMDIO_PIXEL_MASK, 0);\r\nsaved_rgen_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_GENERAL_CONTROL);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_GENERAL_CONTROL,\r\n(saved_rgen_ctrl & ~(NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS |\r\nNV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM)) |\r\nNV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON);\r\nblue = 8;\r\ndo {\r\nbool sense_pair[2];\r\nnv_wr08(dev, NV_PRMDIO_WRITE_MODE_ADDRESS, 0);\r\nnv_wr08(dev, NV_PRMDIO_PALETTE_DATA, 0);\r\nnv_wr08(dev, NV_PRMDIO_PALETTE_DATA, 0);\r\nnv_wr08(dev, NV_PRMDIO_PALETTE_DATA, blue);\r\ni = 0;\r\ndo {\r\nif (sample_load_twice(dev, sense_pair))\r\ngoto out;\r\n} while ((sense_pair[0] != sense_pair[1]) &&\r\n++i < MAX_SAMPLE_PAIRS);\r\nif (i == MAX_SAMPLE_PAIRS)\r\nsense = false;\r\nelse\r\nsense = sense_pair[0];\r\n} while (++blue < 0x18 && sense);\r\nout:\r\nnv_wr08(dev, NV_PRMDIO_PIXEL_MASK, saved_palette_mask);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_GENERAL_CONTROL, saved_rgen_ctrl);\r\nnv_wr08(dev, NV_PRMDIO_WRITE_MODE_ADDRESS, 0);\r\nfor (i = 0; i < 3; i++)\r\nnv_wr08(dev, NV_PRMDIO_PALETTE_DATA, saved_palette0[i]);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL, saved_rtest_ctrl);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX, saved_pi);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_RPC1_INDEX, saved_rpc1);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_CLOCK_INDEX, saved_seq1);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CR_MODE_INDEX, saved_cr_mode);\r\nif (blue == 0x18) {\r\nNV_INFO(dev, "Load detected on head A\n");\r\nreturn connector_status_connected;\r\n}\r\nreturn connector_status_disconnected;\r\n}\r\nuint32_t nv17_dac_sample_load(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;\r\nuint32_t sample, testval, regoffset = nv04_dac_output_offset(encoder);\r\nuint32_t saved_powerctrl_2 = 0, saved_powerctrl_4 = 0, saved_routput,\r\nsaved_rtest_ctrl, saved_gpio0, saved_gpio1, temp, routput;\r\nint head;\r\n#define RGB_TEST_DATA(r, g, b) (r << 0 | g << 10 | b << 20)\r\nif (dcb->type == OUTPUT_TV) {\r\ntestval = RGB_TEST_DATA(0xa0, 0xa0, 0xa0);\r\nif (dev_priv->vbios.tvdactestval)\r\ntestval = dev_priv->vbios.tvdactestval;\r\n} else {\r\ntestval = RGB_TEST_DATA(0x140, 0x140, 0x140);\r\nif (dev_priv->vbios.dactestval)\r\ntestval = dev_priv->vbios.dactestval;\r\n}\r\nsaved_rtest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset,\r\nsaved_rtest_ctrl & ~NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF);\r\nsaved_powerctrl_2 = nvReadMC(dev, NV_PBUS_POWERCTRL_2);\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_2, saved_powerctrl_2 & 0xd7ffffff);\r\nif (regoffset == 0x68) {\r\nsaved_powerctrl_4 = nvReadMC(dev, NV_PBUS_POWERCTRL_4);\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_4, saved_powerctrl_4 & 0xffffffcf);\r\n}\r\nsaved_gpio1 = nouveau_gpio_func_get(dev, DCB_GPIO_TVDAC1);\r\nsaved_gpio0 = nouveau_gpio_func_get(dev, DCB_GPIO_TVDAC0);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, dcb->type == OUTPUT_TV);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, dcb->type == OUTPUT_TV);\r\nmsleep(4);\r\nsaved_routput = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);\r\nhead = (saved_routput & 0x100) >> 8;\r\nif (!(NVReadVgaCrtc(dev, head, NV_CIO_CRE_RPC1_INDEX) & 0xC0))\r\nhead ^= 1;\r\nroutput = (saved_routput & 0xfffffece) | head << 8;\r\nif (dev_priv->card_type >= NV_40) {\r\nif (dcb->type == OUTPUT_TV)\r\nroutput |= 0x1a << 16;\r\nelse\r\nroutput &= ~(0x1a << 16);\r\n}\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, routput);\r\nmsleep(1);\r\ntemp = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, temp | 1);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TESTPOINT_DATA,\r\nNV_PRAMDAC_TESTPOINT_DATA_NOTBLANK | testval);\r\ntemp = NVReadRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL,\r\ntemp | NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED);\r\nmsleep(5);\r\nsample = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\r\nsample &= NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\r\ntemp = NVReadRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL,\r\ntemp & ~NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TESTPOINT_DATA, 0);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, saved_routput);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset, saved_rtest_ctrl);\r\nif (regoffset == 0x68)\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_4, saved_powerctrl_4);\r\nnvWriteMC(dev, NV_PBUS_POWERCTRL_2, saved_powerctrl_2);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC1, saved_gpio1);\r\nnouveau_gpio_func_set(dev, DCB_GPIO_TVDAC0, saved_gpio0);\r\nreturn sample;\r\n}\r\nstatic enum drm_connector_status\r\nnv17_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;\r\nif (nv04_dac_in_use(encoder))\r\nreturn connector_status_disconnected;\r\nif (nv17_dac_sample_load(encoder) &\r\nNV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI) {\r\nNV_INFO(dev, "Load detected on output %c\n",\r\n'@' + ffs(dcb->or));\r\nreturn connector_status_connected;\r\n} else {\r\nreturn connector_status_disconnected;\r\n}\r\n}\r\nstatic bool nv04_dac_mode_fixup(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nif (nv04_dac_in_use(encoder))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void nv04_dac_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nstruct drm_device *dev = encoder->dev;\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nhelper->dpms(encoder, DRM_MODE_DPMS_OFF);\r\nnv04_dfp_disable(dev, head);\r\n}\r\nstatic void nv04_dac_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint head = nouveau_crtc(encoder->crtc)->index;\r\nif (nv_gf4_disp_arch(dev)) {\r\nstruct drm_encoder *rebind;\r\nuint32_t dac_offset = nv04_dac_output_offset(encoder);\r\nuint32_t otherdac;\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + dac_offset,\r\nhead << 8 | NV_PRAMDAC_DACCLK_SEL_DACCLK);\r\nlist_for_each_entry(rebind, &dev->mode_config.encoder_list, head) {\r\nif (rebind == encoder\r\n|| nouveau_encoder(rebind)->dcb->type != OUTPUT_ANALOG)\r\ncontinue;\r\ndac_offset = nv04_dac_output_offset(rebind);\r\notherdac = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + dac_offset);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + dac_offset,\r\n(otherdac & ~0x0100) | (head ^ 1) << 8);\r\n}\r\n}\r\nif (dev_priv->chipset < 0x44)\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0xf0000000);\r\nelse\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0x00100000);\r\n}\r\nstatic void nv04_dac_commit(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct drm_encoder_helper_funcs *helper = encoder->helper_private;\r\nhelper->dpms(encoder, DRM_MODE_DPMS_ON);\r\nNV_INFO(dev, "Output %s is running on CRTC %d using output %c\n",\r\ndrm_get_connector_name(&nouveau_encoder_connector_get(nv_encoder)->base),\r\nnv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\r\n}\r\nvoid nv04_dac_update_dacclk(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;\r\nif (nv_gf4_disp_arch(dev)) {\r\nuint32_t *dac_users = &dev_priv->dac_users[ffs(dcb->or) - 1];\r\nint dacclk_off = NV_PRAMDAC_DACCLK + nv04_dac_output_offset(encoder);\r\nuint32_t dacclk = NVReadRAMDAC(dev, 0, dacclk_off);\r\nif (enable) {\r\n*dac_users |= 1 << dcb->index;\r\nNVWriteRAMDAC(dev, 0, dacclk_off, dacclk | NV_PRAMDAC_DACCLK_SEL_DACCLK);\r\n} else {\r\n*dac_users &= ~(1 << dcb->index);\r\nif (!*dac_users)\r\nNVWriteRAMDAC(dev, 0, dacclk_off,\r\ndacclk & ~NV_PRAMDAC_DACCLK_SEL_DACCLK);\r\n}\r\n}\r\n}\r\nbool nv04_dac_in_use(struct drm_encoder *encoder)\r\n{\r\nstruct drm_nouveau_private *dev_priv = encoder->dev->dev_private;\r\nstruct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;\r\nreturn nv_gf4_disp_arch(encoder->dev) &&\r\n(dev_priv->dac_users[ffs(dcb->or) - 1] & ~(1 << dcb->index));\r\n}\r\nstatic void nv04_dac_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nif (nv_encoder->last_dpms == mode)\r\nreturn;\r\nnv_encoder->last_dpms = mode;\r\nNV_INFO(dev, "Setting dpms mode %d on vga encoder (output %d)\n",\r\nmode, nv_encoder->dcb->index);\r\nnv04_dac_update_dacclk(encoder, mode == DRM_MODE_DPMS_ON);\r\n}\r\nstatic void nv04_dac_save(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nif (nv_gf4_disp_arch(dev))\r\nnv_encoder->restore.output = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK +\r\nnv04_dac_output_offset(encoder));\r\n}\r\nstatic void nv04_dac_restore(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct drm_device *dev = encoder->dev;\r\nif (nv_gf4_disp_arch(dev))\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + nv04_dac_output_offset(encoder),\r\nnv_encoder->restore.output);\r\nnv_encoder->last_dpms = NV_DPMS_CLEARED;\r\n}\r\nstatic void nv04_dac_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nNV_DEBUG_KMS(encoder->dev, "\n");\r\ndrm_encoder_cleanup(encoder);\r\nkfree(nv_encoder);\r\n}\r\nint\r\nnv04_dac_create(struct drm_connector *connector, struct dcb_entry *entry)\r\n{\r\nconst struct drm_encoder_helper_funcs *helper;\r\nstruct nouveau_encoder *nv_encoder = NULL;\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_encoder *encoder;\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nencoder = to_drm_encoder(nv_encoder);\r\nnv_encoder->dcb = entry;\r\nnv_encoder->or = ffs(entry->or) - 1;\r\nif (nv_gf4_disp_arch(dev))\r\nhelper = &nv17_dac_helper_funcs;\r\nelse\r\nhelper = &nv04_dac_helper_funcs;\r\ndrm_encoder_init(dev, encoder, &nv04_dac_funcs, DRM_MODE_ENCODER_DAC);\r\ndrm_encoder_helper_add(encoder, helper);\r\nencoder->possible_crtcs = entry->heads;\r\nencoder->possible_clones = 0;\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}
