static netdev_tx_t loopback_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct pcpu_lstats *lb_stats;\r\nint len;\r\nskb_orphan(skb);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nlb_stats = this_cpu_ptr(dev->lstats);\r\nlen = skb->len;\r\nif (likely(netif_rx(skb) == NET_RX_SUCCESS)) {\r\nu64_stats_update_begin(&lb_stats->syncp);\r\nlb_stats->bytes += len;\r\nlb_stats->packets++;\r\nu64_stats_update_end(&lb_stats->syncp);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic struct rtnl_link_stats64 *loopback_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nu64 bytes = 0;\r\nu64 packets = 0;\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nconst struct pcpu_lstats *lb_stats;\r\nu64 tbytes, tpackets;\r\nunsigned int start;\r\nlb_stats = per_cpu_ptr(dev->lstats, i);\r\ndo {\r\nstart = u64_stats_fetch_begin(&lb_stats->syncp);\r\ntbytes = lb_stats->bytes;\r\ntpackets = lb_stats->packets;\r\n} while (u64_stats_fetch_retry(&lb_stats->syncp, start));\r\nbytes += tbytes;\r\npackets += tpackets;\r\n}\r\nstats->rx_packets = packets;\r\nstats->tx_packets = packets;\r\nstats->rx_bytes = bytes;\r\nstats->tx_bytes = bytes;\r\nreturn stats;\r\n}\r\nstatic u32 always_on(struct net_device *dev)\r\n{\r\nreturn 1;\r\n}\r\nstatic int loopback_dev_init(struct net_device *dev)\r\n{\r\ndev->lstats = alloc_percpu(struct pcpu_lstats);\r\nif (!dev->lstats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void loopback_dev_free(struct net_device *dev)\r\n{\r\nfree_percpu(dev->lstats);\r\nfree_netdev(dev);\r\n}\r\nstatic void loopback_setup(struct net_device *dev)\r\n{\r\ndev->mtu = (16 * 1024) + 20 + 20 + 12;\r\ndev->hard_header_len = ETH_HLEN;\r\ndev->addr_len = ETH_ALEN;\r\ndev->tx_queue_len = 0;\r\ndev->type = ARPHRD_LOOPBACK;\r\ndev->flags = IFF_LOOPBACK;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\ndev->hw_features = NETIF_F_ALL_TSO | NETIF_F_UFO;\r\ndev->features = NETIF_F_SG | NETIF_F_FRAGLIST\r\n| NETIF_F_ALL_TSO\r\n| NETIF_F_UFO\r\n| NETIF_F_HW_CSUM\r\n| NETIF_F_RXCSUM\r\n| NETIF_F_HIGHDMA\r\n| NETIF_F_LLTX\r\n| NETIF_F_NETNS_LOCAL\r\n| NETIF_F_VLAN_CHALLENGED\r\n| NETIF_F_LOOPBACK;\r\ndev->ethtool_ops = &loopback_ethtool_ops;\r\ndev->header_ops = &eth_header_ops;\r\ndev->netdev_ops = &loopback_ops;\r\ndev->destructor = loopback_dev_free;\r\n}\r\nstatic __net_init int loopback_net_init(struct net *net)\r\n{\r\nstruct net_device *dev;\r\nint err;\r\nerr = -ENOMEM;\r\ndev = alloc_netdev(0, "lo", loopback_setup);\r\nif (!dev)\r\ngoto out;\r\ndev_net_set(dev, net);\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out_free_netdev;\r\nnet->loopback_dev = dev;\r\nreturn 0;\r\nout_free_netdev:\r\nfree_netdev(dev);\r\nout:\r\nif (net_eq(net, &init_net))\r\npanic("loopback: Failed to register netdevice: %d\n", err);\r\nreturn err;\r\n}
