static int tsl2550_set_operating_mode(struct i2c_client *client, int mode)\r\n{\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nint ret = i2c_smbus_write_byte(client, TSL2550_MODE_RANGE[mode]);\r\ndata->operating_mode = mode;\r\nreturn ret;\r\n}\r\nstatic int tsl2550_set_power_state(struct i2c_client *client, int state)\r\n{\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nint ret;\r\nif (state == 0)\r\nret = i2c_smbus_write_byte(client, TSL2550_POWER_DOWN);\r\nelse {\r\nret = i2c_smbus_write_byte(client, TSL2550_POWER_UP);\r\ntsl2550_set_operating_mode(client, data->operating_mode);\r\n}\r\ndata->power_state = state;\r\nreturn ret;\r\n}\r\nstatic int tsl2550_get_adc_value(struct i2c_client *client, u8 cmd)\r\n{\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & 0x80))\r\nreturn -EAGAIN;\r\nreturn ret & 0x7f;\r\n}\r\nstatic int tsl2550_calculate_lux(u8 ch0, u8 ch1)\r\n{\r\nunsigned int lux;\r\nu16 c0 = count_lut[ch0];\r\nu16 c1 = count_lut[ch1];\r\nu8 r = 128;\r\nif (c1 <= c0)\r\nif (c0) {\r\nr = c1 * 128 / c0;\r\nlux = ((c0 - c1) * ratio_lut[r]) / 256;\r\n} else\r\nlux = 0;\r\nelse\r\nreturn -EAGAIN;\r\nreturn lux > TSL2550_MAX_LUX ? TSL2550_MAX_LUX : lux;\r\n}\r\nstatic ssize_t tsl2550_show_power_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tsl2550_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nreturn sprintf(buf, "%u\n", data->power_state);\r\n}\r\nstatic ssize_t tsl2550_store_power_state(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nint ret;\r\nif (val < 0 || val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\nret = tsl2550_set_power_state(client, val);\r\nmutex_unlock(&data->update_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t tsl2550_show_operating_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tsl2550_data *data = i2c_get_clientdata(to_i2c_client(dev));\r\nreturn sprintf(buf, "%u\n", data->operating_mode);\r\n}\r\nstatic ssize_t tsl2550_store_operating_mode(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nunsigned long val = simple_strtoul(buf, NULL, 10);\r\nint ret;\r\nif (val < 0 || val > 1)\r\nreturn -EINVAL;\r\nif (data->power_state == 0)\r\nreturn -EBUSY;\r\nmutex_lock(&data->update_lock);\r\nret = tsl2550_set_operating_mode(client, val);\r\nmutex_unlock(&data->update_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t __tsl2550_show_lux(struct i2c_client *client, char *buf)\r\n{\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nu8 ch0, ch1;\r\nint ret;\r\nret = tsl2550_get_adc_value(client, TSL2550_READ_ADC0);\r\nif (ret < 0)\r\nreturn ret;\r\nch0 = ret;\r\nret = tsl2550_get_adc_value(client, TSL2550_READ_ADC1);\r\nif (ret < 0)\r\nreturn ret;\r\nch1 = ret;\r\nret = tsl2550_calculate_lux(ch0, ch1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data->operating_mode == 1)\r\nret *= 5;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t tsl2550_show_lux1_input(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nint ret;\r\nif (!data->power_state)\r\nreturn -EBUSY;\r\nmutex_lock(&data->update_lock);\r\nret = __tsl2550_show_lux(client, buf);\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int tsl2550_init_client(struct i2c_client *client)\r\n{\r\nstruct tsl2550_data *data = i2c_get_clientdata(client);\r\nint err;\r\nerr = i2c_smbus_read_byte_data(client, TSL2550_POWER_UP);\r\nif (err < 0)\r\nreturn err;\r\nif (err != TSL2550_POWER_UP)\r\nreturn -ENODEV;\r\ndata->power_state = 1;\r\nerr = i2c_smbus_write_byte(client,\r\nTSL2550_MODE_RANGE[data->operating_mode]);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int __devinit tsl2550_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct tsl2550_data *data;\r\nint *opmode, err = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WRITE_BYTE\r\n| I2C_FUNC_SMBUS_READ_BYTE_DATA)) {\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\ndata = kzalloc(sizeof(struct tsl2550_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->client = client;\r\ni2c_set_clientdata(client, data);\r\nopmode = client->dev.platform_data;\r\nif (opmode) {\r\nif (*opmode < 0 || *opmode > 1) {\r\ndev_err(&client->dev, "invalid operating_mode (%d)\n",\r\n*opmode);\r\nerr = -EINVAL;\r\ngoto exit_kfree;\r\n}\r\ndata->operating_mode = *opmode;\r\n} else\r\ndata->operating_mode = 0;\r\ndev_info(&client->dev, "%s operating mode\n",\r\ndata->operating_mode ? "extended" : "standard");\r\nmutex_init(&data->update_lock);\r\nerr = tsl2550_init_client(client);\r\nif (err)\r\ngoto exit_kfree;\r\nerr = sysfs_create_group(&client->dev.kobj, &tsl2550_attr_group);\r\nif (err)\r\ngoto exit_kfree;\r\ndev_info(&client->dev, "support ver. %s enabled\n", DRIVER_VERSION);\r\nreturn 0;\r\nexit_kfree:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __devexit tsl2550_remove(struct i2c_client *client)\r\n{\r\nsysfs_remove_group(&client->dev.kobj, &tsl2550_attr_group);\r\ntsl2550_set_power_state(client, 0);\r\nkfree(i2c_get_clientdata(client));\r\nreturn 0;\r\n}\r\nstatic int tsl2550_suspend(struct i2c_client *client, pm_message_t mesg)\r\n{\r\nreturn tsl2550_set_power_state(client, 0);\r\n}\r\nstatic int tsl2550_resume(struct i2c_client *client)\r\n{\r\nreturn tsl2550_set_power_state(client, 1);\r\n}
