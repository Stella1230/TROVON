static inline void\r\nconvert_to_display_mode(struct drm_display_mode *mode,\r\nstruct exynos_drm_panel_info *panel)\r\n{\r\nstruct fb_videomode *timing = &panel->timing;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nmode->clock = timing->pixclock / 1000;\r\nmode->vrefresh = timing->refresh;\r\nmode->hdisplay = timing->xres;\r\nmode->hsync_start = mode->hdisplay + timing->right_margin;\r\nmode->hsync_end = mode->hsync_start + timing->hsync_len;\r\nmode->htotal = mode->hsync_end + timing->left_margin;\r\nmode->vdisplay = timing->yres;\r\nmode->vsync_start = mode->vdisplay + timing->lower_margin;\r\nmode->vsync_end = mode->vsync_start + timing->vsync_len;\r\nmode->vtotal = mode->vsync_end + timing->upper_margin;\r\nmode->width_mm = panel->width_mm;\r\nmode->height_mm = panel->height_mm;\r\nif (timing->vmode & FB_VMODE_INTERLACED)\r\nmode->flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (timing->vmode & FB_VMODE_DOUBLE)\r\nmode->flags |= DRM_MODE_FLAG_DBLSCAN;\r\n}\r\nstatic inline void\r\nconvert_to_video_timing(struct fb_videomode *timing,\r\nstruct drm_display_mode *mode)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nmemset(timing, 0, sizeof(*timing));\r\ntiming->pixclock = mode->clock * 1000;\r\ntiming->refresh = drm_mode_vrefresh(mode);\r\ntiming->xres = mode->hdisplay;\r\ntiming->right_margin = mode->hsync_start - mode->hdisplay;\r\ntiming->hsync_len = mode->hsync_end - mode->hsync_start;\r\ntiming->left_margin = mode->htotal - mode->hsync_end;\r\ntiming->yres = mode->vdisplay;\r\ntiming->lower_margin = mode->vsync_start - mode->vdisplay;\r\ntiming->vsync_len = mode->vsync_end - mode->vsync_start;\r\ntiming->upper_margin = mode->vtotal - mode->vsync_end;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\ntiming->vmode = FB_VMODE_INTERLACED;\r\nelse\r\ntiming->vmode = FB_VMODE_NONINTERLACED;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\ntiming->vmode |= FB_VMODE_DOUBLE;\r\n}\r\nstatic int exynos_drm_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_manager *manager = exynos_connector->manager;\r\nstruct exynos_drm_display_ops *display_ops = manager->display_ops;\r\nunsigned int count;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (!display_ops) {\r\nDRM_DEBUG_KMS("display_ops is null.\n");\r\nreturn 0;\r\n}\r\nif (display_ops->get_edid) {\r\nint ret;\r\nvoid *edid;\r\nedid = kzalloc(MAX_EDID, GFP_KERNEL);\r\nif (!edid) {\r\nDRM_ERROR("failed to allocate edid\n");\r\nreturn 0;\r\n}\r\nret = display_ops->get_edid(manager->dev, connector,\r\nedid, MAX_EDID);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to get edid data.\n");\r\nkfree(edid);\r\nedid = NULL;\r\nreturn 0;\r\n}\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\ncount = drm_add_edid_modes(connector, edid);\r\nkfree(connector->display_info.raw_edid);\r\nconnector->display_info.raw_edid = edid;\r\n} else {\r\nstruct drm_display_mode *mode = drm_mode_create(connector->dev);\r\nstruct exynos_drm_panel_info *panel;\r\nif (display_ops->get_panel)\r\npanel = display_ops->get_panel(manager->dev);\r\nelse {\r\ndrm_mode_destroy(connector->dev, mode);\r\nreturn 0;\r\n}\r\nconvert_to_display_mode(mode, panel);\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\ncount = 1;\r\n}\r\nreturn count;\r\n}\r\nstatic int exynos_drm_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_manager *manager = exynos_connector->manager;\r\nstruct exynos_drm_display_ops *display_ops = manager->display_ops;\r\nstruct fb_videomode timing;\r\nint ret = MODE_BAD;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nconvert_to_video_timing(&timing, mode);\r\nif (display_ops && display_ops->check_timing)\r\nif (!display_ops->check_timing(manager->dev, (void *)&timing))\r\nret = MODE_OK;\r\nreturn ret;\r\n}\r\nstruct drm_encoder *exynos_drm_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct drm_mode_object *obj;\r\nstruct drm_encoder *encoder;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nobj = drm_mode_object_find(dev, exynos_connector->encoder_id,\r\nDRM_MODE_OBJECT_ENCODER);\r\nif (!obj) {\r\nDRM_DEBUG_KMS("Unknown ENCODER ID %d\n",\r\nexynos_connector->encoder_id);\r\nreturn NULL;\r\n}\r\nencoder = obj_to_encoder(obj);\r\nreturn encoder;\r\n}\r\nstatic int exynos_drm_connector_fill_modes(struct drm_connector *connector,\r\nunsigned int max_width, unsigned int max_height)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_manager *manager = exynos_connector->manager;\r\nstruct exynos_drm_manager_ops *ops = manager->ops;\r\nunsigned int width, height;\r\nwidth = max_width;\r\nheight = max_height;\r\nif (ops && ops->get_max_resol)\r\nops->get_max_resol(manager->dev, &width, &height);\r\nreturn drm_helper_probe_single_connector_modes(connector, width,\r\nheight);\r\n}\r\nstatic enum drm_connector_status\r\nexynos_drm_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nstruct exynos_drm_manager *manager = exynos_connector->manager;\r\nstruct exynos_drm_display_ops *display_ops =\r\nmanager->display_ops;\r\nenum drm_connector_status status = connector_status_disconnected;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (display_ops && display_ops->is_connected) {\r\nif (display_ops->is_connected(manager->dev))\r\nstatus = connector_status_connected;\r\nelse\r\nstatus = connector_status_disconnected;\r\n}\r\nreturn status;\r\n}\r\nstatic void exynos_drm_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct exynos_drm_connector *exynos_connector =\r\nto_exynos_connector(connector);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(exynos_connector);\r\n}\r\nstruct drm_connector *exynos_drm_connector_create(struct drm_device *dev,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct exynos_drm_connector *exynos_connector;\r\nstruct exynos_drm_manager *manager = exynos_drm_get_manager(encoder);\r\nstruct drm_connector *connector;\r\nint type;\r\nint err;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nexynos_connector = kzalloc(sizeof(*exynos_connector), GFP_KERNEL);\r\nif (!exynos_connector) {\r\nDRM_ERROR("failed to allocate connector\n");\r\nreturn NULL;\r\n}\r\nconnector = &exynos_connector->drm_connector;\r\nswitch (manager->display_ops->type) {\r\ncase EXYNOS_DISPLAY_TYPE_HDMI:\r\ntype = DRM_MODE_CONNECTOR_HDMIA;\r\nconnector->interlace_allowed = true;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nbreak;\r\ncase EXYNOS_DISPLAY_TYPE_VIDI:\r\ntype = DRM_MODE_CONNECTOR_VIRTUAL;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nbreak;\r\ndefault:\r\ntype = DRM_MODE_CONNECTOR_Unknown;\r\nbreak;\r\n}\r\ndrm_connector_init(dev, connector, &exynos_connector_funcs, type);\r\ndrm_connector_helper_add(connector, &exynos_connector_helper_funcs);\r\nerr = drm_sysfs_connector_add(connector);\r\nif (err)\r\ngoto err_connector;\r\nexynos_connector->encoder_id = encoder->base.id;\r\nexynos_connector->manager = manager;\r\nconnector->encoder = encoder;\r\nerr = drm_mode_connector_attach_encoder(connector, encoder);\r\nif (err) {\r\nDRM_ERROR("failed to attach a connector to a encoder\n");\r\ngoto err_sysfs;\r\n}\r\nDRM_DEBUG_KMS("connector has been created\n");\r\nreturn connector;\r\nerr_sysfs:\r\ndrm_sysfs_connector_remove(connector);\r\nerr_connector:\r\ndrm_connector_cleanup(connector);\r\nkfree(exynos_connector);\r\nreturn NULL;\r\n}
