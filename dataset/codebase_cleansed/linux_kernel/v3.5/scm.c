static __inline__ int scm_check_creds(struct ucred *creds)\r\n{\r\nconst struct cred *cred = current_cred();\r\nif ((creds->pid == task_tgid_vnr(current) || capable(CAP_SYS_ADMIN)) &&\r\n((creds->uid == cred->uid || creds->uid == cred->euid ||\r\ncreds->uid == cred->suid) || capable(CAP_SETUID)) &&\r\n((creds->gid == cred->gid || creds->gid == cred->egid ||\r\ncreds->gid == cred->sgid) || capable(CAP_SETGID))) {\r\nreturn 0;\r\n}\r\nreturn -EPERM;\r\n}\r\nstatic int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\r\n{\r\nint *fdp = (int*)CMSG_DATA(cmsg);\r\nstruct scm_fp_list *fpl = *fplp;\r\nstruct file **fpp;\r\nint i, num;\r\nnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\r\nif (num <= 0)\r\nreturn 0;\r\nif (num > SCM_MAX_FD)\r\nreturn -EINVAL;\r\nif (!fpl)\r\n{\r\nfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\r\nif (!fpl)\r\nreturn -ENOMEM;\r\n*fplp = fpl;\r\nfpl->count = 0;\r\nfpl->max = SCM_MAX_FD;\r\n}\r\nfpp = &fpl->fp[fpl->count];\r\nif (fpl->count + num > fpl->max)\r\nreturn -EINVAL;\r\nfor (i=0; i< num; i++)\r\n{\r\nint fd = fdp[i];\r\nstruct file *file;\r\nif (fd < 0 || !(file = fget_raw(fd)))\r\nreturn -EBADF;\r\n*fpp++ = file;\r\nfpl->count++;\r\n}\r\nreturn num;\r\n}\r\nvoid __scm_destroy(struct scm_cookie *scm)\r\n{\r\nstruct scm_fp_list *fpl = scm->fp;\r\nint i;\r\nif (fpl) {\r\nscm->fp = NULL;\r\nif (current->scm_work_list) {\r\nlist_add_tail(&fpl->list, current->scm_work_list);\r\n} else {\r\nLIST_HEAD(work_list);\r\ncurrent->scm_work_list = &work_list;\r\nlist_add(&fpl->list, &work_list);\r\nwhile (!list_empty(&work_list)) {\r\nfpl = list_first_entry(&work_list, struct scm_fp_list, list);\r\nlist_del(&fpl->list);\r\nfor (i=fpl->count-1; i>=0; i--)\r\nfput(fpl->fp[i]);\r\nkfree(fpl);\r\n}\r\ncurrent->scm_work_list = NULL;\r\n}\r\n}\r\n}\r\nint __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *p)\r\n{\r\nstruct cmsghdr *cmsg;\r\nint err;\r\nfor (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg))\r\n{\r\nerr = -EINVAL;\r\nif (!CMSG_OK(msg, cmsg))\r\ngoto error;\r\nif (cmsg->cmsg_level != SOL_SOCKET)\r\ncontinue;\r\nswitch (cmsg->cmsg_type)\r\n{\r\ncase SCM_RIGHTS:\r\nif (!sock->ops || sock->ops->family != PF_UNIX)\r\ngoto error;\r\nerr=scm_fp_copy(cmsg, &p->fp);\r\nif (err<0)\r\ngoto error;\r\nbreak;\r\ncase SCM_CREDENTIALS:\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct ucred)))\r\ngoto error;\r\nmemcpy(&p->creds, CMSG_DATA(cmsg), sizeof(struct ucred));\r\nerr = scm_check_creds(&p->creds);\r\nif (err)\r\ngoto error;\r\nif (!p->pid || pid_vnr(p->pid) != p->creds.pid) {\r\nstruct pid *pid;\r\nerr = -ESRCH;\r\npid = find_get_pid(p->creds.pid);\r\nif (!pid)\r\ngoto error;\r\nput_pid(p->pid);\r\np->pid = pid;\r\n}\r\nif (!p->cred ||\r\n(p->cred->euid != p->creds.uid) ||\r\n(p->cred->egid != p->creds.gid)) {\r\nstruct cred *cred;\r\nerr = -ENOMEM;\r\ncred = prepare_creds();\r\nif (!cred)\r\ngoto error;\r\ncred->uid = cred->euid = p->creds.uid;\r\ncred->gid = cred->egid = p->creds.gid;\r\nif (p->cred)\r\nput_cred(p->cred);\r\np->cred = cred;\r\n}\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\n}\r\nif (p->fp && !p->fp->count)\r\n{\r\nkfree(p->fp);\r\np->fp = NULL;\r\n}\r\nreturn 0;\r\nerror:\r\nscm_destroy(p);\r\nreturn err;\r\n}\r\nint put_cmsg(struct msghdr * msg, int level, int type, int len, void *data)\r\n{\r\nstruct cmsghdr __user *cm\r\n= (__force struct cmsghdr __user *)msg->msg_control;\r\nstruct cmsghdr cmhdr;\r\nint cmlen = CMSG_LEN(len);\r\nint err;\r\nif (MSG_CMSG_COMPAT & msg->msg_flags)\r\nreturn put_cmsg_compat(msg, level, type, len, data);\r\nif (cm==NULL || msg->msg_controllen < sizeof(*cm)) {\r\nmsg->msg_flags |= MSG_CTRUNC;\r\nreturn 0;\r\n}\r\nif (msg->msg_controllen < cmlen) {\r\nmsg->msg_flags |= MSG_CTRUNC;\r\ncmlen = msg->msg_controllen;\r\n}\r\ncmhdr.cmsg_level = level;\r\ncmhdr.cmsg_type = type;\r\ncmhdr.cmsg_len = cmlen;\r\nerr = -EFAULT;\r\nif (copy_to_user(cm, &cmhdr, sizeof cmhdr))\r\ngoto out;\r\nif (copy_to_user(CMSG_DATA(cm), data, cmlen - sizeof(struct cmsghdr)))\r\ngoto out;\r\ncmlen = CMSG_SPACE(len);\r\nif (msg->msg_controllen < cmlen)\r\ncmlen = msg->msg_controllen;\r\nmsg->msg_control += cmlen;\r\nmsg->msg_controllen -= cmlen;\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nvoid scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)\r\n{\r\nstruct cmsghdr __user *cm\r\n= (__force struct cmsghdr __user*)msg->msg_control;\r\nint fdmax = 0;\r\nint fdnum = scm->fp->count;\r\nstruct file **fp = scm->fp->fp;\r\nint __user *cmfptr;\r\nint err = 0, i;\r\nif (MSG_CMSG_COMPAT & msg->msg_flags) {\r\nscm_detach_fds_compat(msg, scm);\r\nreturn;\r\n}\r\nif (msg->msg_controllen > sizeof(struct cmsghdr))\r\nfdmax = ((msg->msg_controllen - sizeof(struct cmsghdr))\r\n/ sizeof(int));\r\nif (fdnum < fdmax)\r\nfdmax = fdnum;\r\nfor (i=0, cmfptr=(__force int __user *)CMSG_DATA(cm); i<fdmax;\r\ni++, cmfptr++)\r\n{\r\nint new_fd;\r\nerr = security_file_receive(fp[i]);\r\nif (err)\r\nbreak;\r\nerr = get_unused_fd_flags(MSG_CMSG_CLOEXEC & msg->msg_flags\r\n? O_CLOEXEC : 0);\r\nif (err < 0)\r\nbreak;\r\nnew_fd = err;\r\nerr = put_user(new_fd, cmfptr);\r\nif (err) {\r\nput_unused_fd(new_fd);\r\nbreak;\r\n}\r\nget_file(fp[i]);\r\nfd_install(new_fd, fp[i]);\r\n}\r\nif (i > 0)\r\n{\r\nint cmlen = CMSG_LEN(i*sizeof(int));\r\nerr = put_user(SOL_SOCKET, &cm->cmsg_level);\r\nif (!err)\r\nerr = put_user(SCM_RIGHTS, &cm->cmsg_type);\r\nif (!err)\r\nerr = put_user(cmlen, &cm->cmsg_len);\r\nif (!err) {\r\ncmlen = CMSG_SPACE(i*sizeof(int));\r\nmsg->msg_control += cmlen;\r\nmsg->msg_controllen -= cmlen;\r\n}\r\n}\r\nif (i < fdnum || (fdnum && fdmax <= 0))\r\nmsg->msg_flags |= MSG_CTRUNC;\r\n__scm_destroy(scm);\r\n}\r\nstruct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\r\n{\r\nstruct scm_fp_list *new_fpl;\r\nint i;\r\nif (!fpl)\r\nreturn NULL;\r\nnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\r\nGFP_KERNEL);\r\nif (new_fpl) {\r\nfor (i = 0; i < fpl->count; i++)\r\nget_file(fpl->fp[i]);\r\nnew_fpl->max = new_fpl->count;\r\n}\r\nreturn new_fpl;\r\n}
