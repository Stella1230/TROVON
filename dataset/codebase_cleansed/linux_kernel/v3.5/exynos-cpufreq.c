int exynos_verify_speed(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy,\r\nexynos_info->freq_table);\r\n}\r\nunsigned int exynos_getspeed(unsigned int cpu)\r\n{\r\nreturn clk_get_rate(exynos_info->cpu_clk) / 1000;\r\n}\r\nstatic int exynos_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int index, old_index;\r\nunsigned int arm_volt, safe_arm_volt = 0;\r\nint ret = 0;\r\nstruct cpufreq_frequency_table *freq_table = exynos_info->freq_table;\r\nunsigned int *volt_table = exynos_info->volt_table;\r\nunsigned int mpll_freq_khz = exynos_info->mpll_freq_khz;\r\nmutex_lock(&cpufreq_lock);\r\nfreqs.old = policy->cur;\r\nif (frequency_locked && target_freq != locking_frequency) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nif (cpufreq_frequency_table_target(policy, freq_table,\r\nfreqs.old, relation, &old_index)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (cpufreq_frequency_table_target(policy, freq_table,\r\ntarget_freq, relation, &index)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfreqs.new = freq_table[index].frequency;\r\nfreqs.cpu = policy->cpu;\r\nif (exynos_info->need_apll_change != NULL) {\r\nif (exynos_info->need_apll_change(old_index, index) &&\r\n(freq_table[index].frequency < mpll_freq_khz) &&\r\n(freq_table[old_index].frequency < mpll_freq_khz))\r\nsafe_arm_volt = volt_table[exynos_info->pll_safe_idx];\r\n}\r\narm_volt = volt_table[index];\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\nif ((freqs.new > freqs.old) && !safe_arm_volt) {\r\nregulator_set_voltage(arm_regulator, arm_volt,\r\narm_volt);\r\n}\r\nif (safe_arm_volt)\r\nregulator_set_voltage(arm_regulator, safe_arm_volt,\r\nsafe_arm_volt);\r\nif (freqs.new != freqs.old)\r\nexynos_info->set_freq(old_index, index);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nif ((freqs.new < freqs.old) ||\r\n((freqs.new > freqs.old) && safe_arm_volt)) {\r\nregulator_set_voltage(arm_regulator, arm_volt,\r\narm_volt);\r\n}\r\nout:\r\nmutex_unlock(&cpufreq_lock);\r\nreturn ret;\r\n}\r\nstatic int exynos_cpufreq_suspend(struct cpufreq_policy *policy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int exynos_cpufreq_resume(struct cpufreq_policy *policy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int exynos_cpufreq_pm_notifier(struct notifier_block *notifier,\r\nunsigned long pm_event, void *v)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(0);\r\nstatic unsigned int saved_frequency;\r\nunsigned int temp;\r\nmutex_lock(&cpufreq_lock);\r\nswitch (pm_event) {\r\ncase PM_SUSPEND_PREPARE:\r\nif (frequency_locked)\r\ngoto out;\r\nfrequency_locked = true;\r\nif (locking_frequency) {\r\nsaved_frequency = exynos_getspeed(0);\r\nmutex_unlock(&cpufreq_lock);\r\nexynos_target(policy, locking_frequency,\r\nCPUFREQ_RELATION_H);\r\nmutex_lock(&cpufreq_lock);\r\n}\r\nbreak;\r\ncase PM_POST_SUSPEND:\r\nif (saved_frequency) {\r\ntemp = locking_frequency;\r\nlocking_frequency = saved_frequency;\r\nmutex_unlock(&cpufreq_lock);\r\nexynos_target(policy, locking_frequency,\r\nCPUFREQ_RELATION_H);\r\nmutex_lock(&cpufreq_lock);\r\nlocking_frequency = temp;\r\n}\r\nfrequency_locked = false;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&cpufreq_lock);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int exynos_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->cur = policy->min = policy->max = exynos_getspeed(policy->cpu);\r\ncpufreq_frequency_table_get_attr(exynos_info->freq_table, policy->cpu);\r\nlocking_frequency = exynos_getspeed(0);\r\npolicy->cpuinfo.transition_latency = 100000;\r\nif (num_online_cpus() == 1) {\r\ncpumask_copy(policy->related_cpus, cpu_possible_mask);\r\ncpumask_copy(policy->cpus, cpu_online_mask);\r\n} else {\r\ncpumask_setall(policy->cpus);\r\n}\r\nreturn cpufreq_frequency_table_cpuinfo(policy, exynos_info->freq_table);\r\n}\r\nstatic int __init exynos_cpufreq_init(void)\r\n{\r\nint ret = -EINVAL;\r\nexynos_info = kzalloc(sizeof(struct exynos_dvfs_info), GFP_KERNEL);\r\nif (!exynos_info)\r\nreturn -ENOMEM;\r\nif (soc_is_exynos4210())\r\nret = exynos4210_cpufreq_init(exynos_info);\r\nelse if (soc_is_exynos4212() || soc_is_exynos4412())\r\nret = exynos4x12_cpufreq_init(exynos_info);\r\nelse if (soc_is_exynos5250())\r\nret = exynos5250_cpufreq_init(exynos_info);\r\nelse\r\npr_err("%s: CPU type not found\n", __func__);\r\nif (ret)\r\ngoto err_vdd_arm;\r\nif (exynos_info->set_freq == NULL) {\r\npr_err("%s: No set_freq function (ERR)\n", __func__);\r\ngoto err_vdd_arm;\r\n}\r\narm_regulator = regulator_get(NULL, "vdd_arm");\r\nif (IS_ERR(arm_regulator)) {\r\npr_err("%s: failed to get resource vdd_arm\n", __func__);\r\ngoto err_vdd_arm;\r\n}\r\nregister_pm_notifier(&exynos_cpufreq_nb);\r\nif (cpufreq_register_driver(&exynos_driver)) {\r\npr_err("%s: failed to register cpufreq driver\n", __func__);\r\ngoto err_cpufreq;\r\n}\r\nreturn 0;\r\nerr_cpufreq:\r\nunregister_pm_notifier(&exynos_cpufreq_nb);\r\nif (!IS_ERR(arm_regulator))\r\nregulator_put(arm_regulator);\r\nerr_vdd_arm:\r\nkfree(exynos_info);\r\npr_debug("%s: failed initialization\n", __func__);\r\nreturn -EINVAL;\r\n}
