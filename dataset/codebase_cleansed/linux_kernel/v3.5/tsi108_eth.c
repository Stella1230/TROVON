static void dump_eth_one(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nprintk("Dumping %s...\n", dev->name);\r\nprintk("intstat %x intmask %x phy_ok %d"\r\n" link %d speed %d duplex %d\n",\r\nTSI_READ(TSI108_EC_INTSTAT),\r\nTSI_READ(TSI108_EC_INTMASK), data->phy_ok,\r\ndata->link_up, data->speed, data->duplex);\r\nprintk("TX: head %d, tail %d, free %d, stat %x, estat %x, err %x\n",\r\ndata->txhead, data->txtail, data->txfree,\r\nTSI_READ(TSI108_EC_TXSTAT),\r\nTSI_READ(TSI108_EC_TXESTAT),\r\nTSI_READ(TSI108_EC_TXERR));\r\nprintk("RX: head %d, tail %d, free %d, stat %x,"\r\n" estat %x, err %x, pending %d\n\n",\r\ndata->rxhead, data->rxtail, data->rxfree,\r\nTSI_READ(TSI108_EC_RXSTAT),\r\nTSI_READ(TSI108_EC_RXESTAT),\r\nTSI_READ(TSI108_EC_RXERR), data->rxpending);\r\n}\r\nstatic int tsi108_read_mii(struct tsi108_prv_data *data, int reg)\r\n{\r\nunsigned i;\r\nTSI_WRITE_PHY(TSI108_MAC_MII_ADDR,\r\n(data->phy << TSI108_MAC_MII_ADDR_PHY) |\r\n(reg << TSI108_MAC_MII_ADDR_REG));\r\nTSI_WRITE_PHY(TSI108_MAC_MII_CMD, 0);\r\nTSI_WRITE_PHY(TSI108_MAC_MII_CMD, TSI108_MAC_MII_CMD_READ);\r\nfor (i = 0; i < 100; i++) {\r\nif (!(TSI_READ_PHY(TSI108_MAC_MII_IND) &\r\n(TSI108_MAC_MII_IND_NOTVALID | TSI108_MAC_MII_IND_BUSY)))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == 100)\r\nreturn 0xffff;\r\nelse\r\nreturn TSI_READ_PHY(TSI108_MAC_MII_DATAIN);\r\n}\r\nstatic void tsi108_write_mii(struct tsi108_prv_data *data,\r\nint reg, u16 val)\r\n{\r\nunsigned i = 100;\r\nTSI_WRITE_PHY(TSI108_MAC_MII_ADDR,\r\n(data->phy << TSI108_MAC_MII_ADDR_PHY) |\r\n(reg << TSI108_MAC_MII_ADDR_REG));\r\nTSI_WRITE_PHY(TSI108_MAC_MII_DATAOUT, val);\r\nwhile (i--) {\r\nif(!(TSI_READ_PHY(TSI108_MAC_MII_IND) &\r\nTSI108_MAC_MII_IND_BUSY))\r\nbreak;\r\nudelay(10);\r\n}\r\n}\r\nstatic int tsi108_mdio_read(struct net_device *dev, int addr, int reg)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nreturn tsi108_read_mii(data, reg);\r\n}\r\nstatic void tsi108_mdio_write(struct net_device *dev, int addr, int reg, int val)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\ntsi108_write_mii(data, reg, val);\r\n}\r\nstatic inline void tsi108_write_tbi(struct tsi108_prv_data *data,\r\nint reg, u16 val)\r\n{\r\nunsigned i = 1000;\r\nTSI_WRITE(TSI108_MAC_MII_ADDR,\r\n(0x1e << TSI108_MAC_MII_ADDR_PHY)\r\n| (reg << TSI108_MAC_MII_ADDR_REG));\r\nTSI_WRITE(TSI108_MAC_MII_DATAOUT, val);\r\nwhile(i--) {\r\nif(!(TSI_READ(TSI108_MAC_MII_IND) & TSI108_MAC_MII_IND_BUSY))\r\nreturn;\r\nudelay(10);\r\n}\r\nprintk(KERN_ERR "%s function time out\n", __func__);\r\n}\r\nstatic int mii_speed(struct mii_if_info *mii)\r\n{\r\nint advert, lpa, val, media;\r\nint lpa2 = 0;\r\nint speed;\r\nif (!mii_link_ok(mii))\r\nreturn 0;\r\nval = (*mii->mdio_read) (mii->dev, mii->phy_id, MII_BMSR);\r\nif ((val & BMSR_ANEGCOMPLETE) == 0)\r\nreturn 0;\r\nadvert = (*mii->mdio_read) (mii->dev, mii->phy_id, MII_ADVERTISE);\r\nlpa = (*mii->mdio_read) (mii->dev, mii->phy_id, MII_LPA);\r\nmedia = mii_nway_result(advert & lpa);\r\nif (mii->supports_gmii)\r\nlpa2 = mii->mdio_read(mii->dev, mii->phy_id, MII_STAT1000);\r\nspeed = lpa2 & (LPA_1000FULL | LPA_1000HALF) ? 1000 :\r\n(media & (ADVERTISE_100FULL | ADVERTISE_100HALF) ? 100 : 10);\r\nreturn speed;\r\n}\r\nstatic void tsi108_check_phy(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 mac_cfg2_reg, portctrl_reg;\r\nu32 duplex;\r\nu32 speed;\r\nunsigned long flags;\r\nspin_lock_irqsave(&phy_lock, flags);\r\nif (!data->phy_ok)\r\ngoto out;\r\nduplex = mii_check_media(&data->mii_if, netif_msg_link(data), data->init_media);\r\ndata->init_media = 0;\r\nif (netif_carrier_ok(dev)) {\r\nspeed = mii_speed(&data->mii_if);\r\nif ((speed != data->speed) || duplex) {\r\nmac_cfg2_reg = TSI_READ(TSI108_MAC_CFG2);\r\nportctrl_reg = TSI_READ(TSI108_EC_PORTCTRL);\r\nmac_cfg2_reg &= ~TSI108_MAC_CFG2_IFACE_MASK;\r\nif (speed == 1000) {\r\nmac_cfg2_reg |= TSI108_MAC_CFG2_GIG;\r\nportctrl_reg &= ~TSI108_EC_PORTCTRL_NOGIG;\r\n} else {\r\nmac_cfg2_reg |= TSI108_MAC_CFG2_NOGIG;\r\nportctrl_reg |= TSI108_EC_PORTCTRL_NOGIG;\r\n}\r\ndata->speed = speed;\r\nif (data->mii_if.full_duplex) {\r\nmac_cfg2_reg |= TSI108_MAC_CFG2_FULLDUPLEX;\r\nportctrl_reg &= ~TSI108_EC_PORTCTRL_HALFDUPLEX;\r\ndata->duplex = 2;\r\n} else {\r\nmac_cfg2_reg &= ~TSI108_MAC_CFG2_FULLDUPLEX;\r\nportctrl_reg |= TSI108_EC_PORTCTRL_HALFDUPLEX;\r\ndata->duplex = 1;\r\n}\r\nTSI_WRITE(TSI108_MAC_CFG2, mac_cfg2_reg);\r\nTSI_WRITE(TSI108_EC_PORTCTRL, portctrl_reg);\r\n}\r\nif (data->link_up == 0) {\r\nudelay(5);\r\nspin_lock(&data->txlock);\r\nif (is_valid_ether_addr(dev->dev_addr) && data->txfree)\r\nnetif_wake_queue(dev);\r\ndata->link_up = 1;\r\nspin_unlock(&data->txlock);\r\n}\r\n} else {\r\nif (data->link_up == 1) {\r\nnetif_stop_queue(dev);\r\ndata->link_up = 0;\r\nprintk(KERN_NOTICE "%s : link is down\n", dev->name);\r\n}\r\ngoto out;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\n}\r\nstatic inline void\r\ntsi108_stat_carry_one(int carry, int carry_bit, int carry_shift,\r\nunsigned long *upper)\r\n{\r\nif (carry & carry_bit)\r\n*upper += carry_shift;\r\n}\r\nstatic void tsi108_stat_carry(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 carry1, carry2;\r\nspin_lock_irq(&data->misclock);\r\ncarry1 = TSI_READ(TSI108_STAT_CARRY1);\r\ncarry2 = TSI_READ(TSI108_STAT_CARRY2);\r\nTSI_WRITE(TSI108_STAT_CARRY1, carry1);\r\nTSI_WRITE(TSI108_STAT_CARRY2, carry2);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXBYTES,\r\nTSI108_STAT_RXBYTES_CARRY, &data->stats.rx_bytes);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXPKTS,\r\nTSI108_STAT_RXPKTS_CARRY,\r\n&data->stats.rx_packets);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXFCS,\r\nTSI108_STAT_RXFCS_CARRY, &data->rx_fcs);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXMCAST,\r\nTSI108_STAT_RXMCAST_CARRY,\r\n&data->stats.multicast);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXALIGN,\r\nTSI108_STAT_RXALIGN_CARRY,\r\n&data->stats.rx_frame_errors);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXLENGTH,\r\nTSI108_STAT_RXLENGTH_CARRY,\r\n&data->stats.rx_length_errors);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXRUNT,\r\nTSI108_STAT_RXRUNT_CARRY, &data->rx_underruns);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXJUMBO,\r\nTSI108_STAT_RXJUMBO_CARRY, &data->rx_overruns);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXFRAG,\r\nTSI108_STAT_RXFRAG_CARRY, &data->rx_short_fcs);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXJABBER,\r\nTSI108_STAT_RXJABBER_CARRY, &data->rx_long_fcs);\r\ntsi108_stat_carry_one(carry1, TSI108_STAT_CARRY1_RXDROP,\r\nTSI108_STAT_RXDROP_CARRY,\r\n&data->stats.rx_missed_errors);\r\ntsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXBYTES,\r\nTSI108_STAT_TXBYTES_CARRY, &data->stats.tx_bytes);\r\ntsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXPKTS,\r\nTSI108_STAT_TXPKTS_CARRY,\r\n&data->stats.tx_packets);\r\ntsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXEXDEF,\r\nTSI108_STAT_TXEXDEF_CARRY,\r\n&data->stats.tx_aborted_errors);\r\ntsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXEXCOL,\r\nTSI108_STAT_TXEXCOL_CARRY, &data->tx_coll_abort);\r\ntsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXTCOL,\r\nTSI108_STAT_TXTCOL_CARRY,\r\n&data->stats.collisions);\r\ntsi108_stat_carry_one(carry2, TSI108_STAT_CARRY2_TXPAUSE,\r\nTSI108_STAT_TXPAUSEDROP_CARRY,\r\n&data->tx_pause_drop);\r\nspin_unlock_irq(&data->misclock);\r\n}\r\nstatic inline unsigned long\r\ntsi108_read_stat(struct tsi108_prv_data * data, int reg, int carry_bit,\r\nint carry_shift, unsigned long *upper)\r\n{\r\nint carryreg;\r\nunsigned long val;\r\nif (reg < 0xb0)\r\ncarryreg = TSI108_STAT_CARRY1;\r\nelse\r\ncarryreg = TSI108_STAT_CARRY2;\r\nagain:\r\nval = TSI_READ(reg) | *upper;\r\nif (unlikely(TSI_READ(carryreg) & carry_bit)) {\r\n*upper += carry_shift;\r\nTSI_WRITE(carryreg, carry_bit);\r\ngoto again;\r\n}\r\nreturn val;\r\n}\r\nstatic struct net_device_stats *tsi108_get_stats(struct net_device *dev)\r\n{\r\nunsigned long excol;\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nspin_lock_irq(&data->misclock);\r\ndata->tmpstats.rx_packets =\r\ntsi108_read_stat(data, TSI108_STAT_RXPKTS,\r\nTSI108_STAT_CARRY1_RXPKTS,\r\nTSI108_STAT_RXPKTS_CARRY, &data->stats.rx_packets);\r\ndata->tmpstats.tx_packets =\r\ntsi108_read_stat(data, TSI108_STAT_TXPKTS,\r\nTSI108_STAT_CARRY2_TXPKTS,\r\nTSI108_STAT_TXPKTS_CARRY, &data->stats.tx_packets);\r\ndata->tmpstats.rx_bytes =\r\ntsi108_read_stat(data, TSI108_STAT_RXBYTES,\r\nTSI108_STAT_CARRY1_RXBYTES,\r\nTSI108_STAT_RXBYTES_CARRY, &data->stats.rx_bytes);\r\ndata->tmpstats.tx_bytes =\r\ntsi108_read_stat(data, TSI108_STAT_TXBYTES,\r\nTSI108_STAT_CARRY2_TXBYTES,\r\nTSI108_STAT_TXBYTES_CARRY, &data->stats.tx_bytes);\r\ndata->tmpstats.multicast =\r\ntsi108_read_stat(data, TSI108_STAT_RXMCAST,\r\nTSI108_STAT_CARRY1_RXMCAST,\r\nTSI108_STAT_RXMCAST_CARRY, &data->stats.multicast);\r\nexcol = tsi108_read_stat(data, TSI108_STAT_TXEXCOL,\r\nTSI108_STAT_CARRY2_TXEXCOL,\r\nTSI108_STAT_TXEXCOL_CARRY,\r\n&data->tx_coll_abort);\r\ndata->tmpstats.collisions =\r\ntsi108_read_stat(data, TSI108_STAT_TXTCOL,\r\nTSI108_STAT_CARRY2_TXTCOL,\r\nTSI108_STAT_TXTCOL_CARRY, &data->stats.collisions);\r\ndata->tmpstats.collisions += excol;\r\ndata->tmpstats.rx_length_errors =\r\ntsi108_read_stat(data, TSI108_STAT_RXLENGTH,\r\nTSI108_STAT_CARRY1_RXLENGTH,\r\nTSI108_STAT_RXLENGTH_CARRY,\r\n&data->stats.rx_length_errors);\r\ndata->tmpstats.rx_length_errors +=\r\ntsi108_read_stat(data, TSI108_STAT_RXRUNT,\r\nTSI108_STAT_CARRY1_RXRUNT,\r\nTSI108_STAT_RXRUNT_CARRY, &data->rx_underruns);\r\ndata->tmpstats.rx_length_errors +=\r\ntsi108_read_stat(data, TSI108_STAT_RXJUMBO,\r\nTSI108_STAT_CARRY1_RXJUMBO,\r\nTSI108_STAT_RXJUMBO_CARRY, &data->rx_overruns);\r\ndata->tmpstats.rx_frame_errors =\r\ntsi108_read_stat(data, TSI108_STAT_RXALIGN,\r\nTSI108_STAT_CARRY1_RXALIGN,\r\nTSI108_STAT_RXALIGN_CARRY,\r\n&data->stats.rx_frame_errors);\r\ndata->tmpstats.rx_frame_errors +=\r\ntsi108_read_stat(data, TSI108_STAT_RXFCS,\r\nTSI108_STAT_CARRY1_RXFCS, TSI108_STAT_RXFCS_CARRY,\r\n&data->rx_fcs);\r\ndata->tmpstats.rx_frame_errors +=\r\ntsi108_read_stat(data, TSI108_STAT_RXFRAG,\r\nTSI108_STAT_CARRY1_RXFRAG,\r\nTSI108_STAT_RXFRAG_CARRY, &data->rx_short_fcs);\r\ndata->tmpstats.rx_missed_errors =\r\ntsi108_read_stat(data, TSI108_STAT_RXDROP,\r\nTSI108_STAT_CARRY1_RXDROP,\r\nTSI108_STAT_RXDROP_CARRY,\r\n&data->stats.rx_missed_errors);\r\ndata->tmpstats.rx_fifo_errors = data->stats.rx_fifo_errors;\r\ndata->tmpstats.rx_crc_errors = data->stats.rx_crc_errors;\r\ndata->tmpstats.tx_aborted_errors =\r\ntsi108_read_stat(data, TSI108_STAT_TXEXDEF,\r\nTSI108_STAT_CARRY2_TXEXDEF,\r\nTSI108_STAT_TXEXDEF_CARRY,\r\n&data->stats.tx_aborted_errors);\r\ndata->tmpstats.tx_aborted_errors +=\r\ntsi108_read_stat(data, TSI108_STAT_TXPAUSEDROP,\r\nTSI108_STAT_CARRY2_TXPAUSE,\r\nTSI108_STAT_TXPAUSEDROP_CARRY,\r\n&data->tx_pause_drop);\r\ndata->tmpstats.tx_aborted_errors += excol;\r\ndata->tmpstats.tx_errors = data->tmpstats.tx_aborted_errors;\r\ndata->tmpstats.rx_errors = data->tmpstats.rx_length_errors +\r\ndata->tmpstats.rx_crc_errors +\r\ndata->tmpstats.rx_frame_errors +\r\ndata->tmpstats.rx_fifo_errors + data->tmpstats.rx_missed_errors;\r\nspin_unlock_irq(&data->misclock);\r\nreturn &data->tmpstats;\r\n}\r\nstatic void tsi108_restart_rx(struct tsi108_prv_data * data, struct net_device *dev)\r\n{\r\nTSI_WRITE(TSI108_EC_RXQ_PTRHIGH,\r\nTSI108_EC_RXQ_PTRHIGH_VALID);\r\nTSI_WRITE(TSI108_EC_RXCTRL, TSI108_EC_RXCTRL_GO\r\n| TSI108_EC_RXCTRL_QUEUE0);\r\n}\r\nstatic void tsi108_restart_tx(struct tsi108_prv_data * data)\r\n{\r\nTSI_WRITE(TSI108_EC_TXQ_PTRHIGH,\r\nTSI108_EC_TXQ_PTRHIGH_VALID);\r\nTSI_WRITE(TSI108_EC_TXCTRL, TSI108_EC_TXCTRL_IDLEINT |\r\nTSI108_EC_TXCTRL_GO | TSI108_EC_TXCTRL_QUEUE0);\r\n}\r\nstatic void tsi108_complete_tx(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nint tx;\r\nstruct sk_buff *skb;\r\nint release = 0;\r\nwhile (!data->txfree || data->txhead != data->txtail) {\r\ntx = data->txtail;\r\nif (data->txring[tx].misc & TSI108_TX_OWN)\r\nbreak;\r\nskb = data->txskbs[tx];\r\nif (!(data->txring[tx].misc & TSI108_TX_OK))\r\nprintk("%s: bad tx packet, misc %x\n",\r\ndev->name, data->txring[tx].misc);\r\ndata->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;\r\ndata->txfree++;\r\nif (data->txring[tx].misc & TSI108_TX_EOF) {\r\ndev_kfree_skb_any(skb);\r\nrelease++;\r\n}\r\n}\r\nif (release) {\r\nif (is_valid_ether_addr(dev->dev_addr) && data->link_up)\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic int tsi108_send_packet(struct sk_buff * skb, struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nint frags = skb_shinfo(skb)->nr_frags + 1;\r\nint i;\r\nif (!data->phy_ok && net_ratelimit())\r\nprintk(KERN_ERR "%s: Transmit while PHY is down!\n", dev->name);\r\nif (!data->link_up) {\r\nprintk(KERN_ERR "%s: Transmit while link is down!\n",\r\ndev->name);\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (data->txfree < MAX_SKB_FRAGS + 1) {\r\nnetif_stop_queue(dev);\r\nif (net_ratelimit())\r\nprintk(KERN_ERR "%s: Transmit with full tx ring!\n",\r\ndev->name);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (data->txfree - frags < MAX_SKB_FRAGS + 1) {\r\nnetif_stop_queue(dev);\r\n}\r\nspin_lock_irq(&data->txlock);\r\nfor (i = 0; i < frags; i++) {\r\nint misc = 0;\r\nint tx = data->txhead;\r\nif ((tx % TSI108_TX_INT_FREQ == 0) &&\r\n((TSI108_TXRING_LEN - data->txfree) >= TSI108_TX_INT_FREQ))\r\nmisc = TSI108_TX_INT;\r\ndata->txskbs[tx] = skb;\r\nif (i == 0) {\r\ndata->txring[tx].buf0 = dma_map_single(NULL, skb->data,\r\nskb_headlen(skb), DMA_TO_DEVICE);\r\ndata->txring[tx].len = skb_headlen(skb);\r\nmisc |= TSI108_TX_SOF;\r\n} else {\r\nconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i - 1];\r\ndata->txring[tx].buf0 = skb_frag_dma_map(NULL, frag,\r\n0,\r\nskb_frag_size(frag),\r\nDMA_TO_DEVICE);\r\ndata->txring[tx].len = skb_frag_size(frag);\r\n}\r\nif (i == frags - 1)\r\nmisc |= TSI108_TX_EOF;\r\nif (netif_msg_pktdata(data)) {\r\nint i;\r\nprintk("%s: Tx Frame contents (%d)\n", dev->name,\r\nskb->len);\r\nfor (i = 0; i < skb->len; i++)\r\nprintk(" %2.2x", skb->data[i]);\r\nprintk(".\n");\r\n}\r\ndata->txring[tx].misc = misc | TSI108_TX_OWN;\r\ndata->txhead = (data->txhead + 1) % TSI108_TXRING_LEN;\r\ndata->txfree--;\r\n}\r\ntsi108_complete_tx(dev);\r\nif (!(TSI_READ(TSI108_EC_TXSTAT) & TSI108_EC_TXSTAT_QUEUE0))\r\ntsi108_restart_tx(data);\r\nspin_unlock_irq(&data->txlock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int tsi108_complete_rx(struct net_device *dev, int budget)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nint done = 0;\r\nwhile (data->rxfree && done != budget) {\r\nint rx = data->rxtail;\r\nstruct sk_buff *skb;\r\nif (data->rxring[rx].misc & TSI108_RX_OWN)\r\nbreak;\r\nskb = data->rxskbs[rx];\r\ndata->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;\r\ndata->rxfree--;\r\ndone++;\r\nif (data->rxring[rx].misc & TSI108_RX_BAD) {\r\nspin_lock_irq(&data->misclock);\r\nif (data->rxring[rx].misc & TSI108_RX_CRC)\r\ndata->stats.rx_crc_errors++;\r\nif (data->rxring[rx].misc & TSI108_RX_OVER)\r\ndata->stats.rx_fifo_errors++;\r\nspin_unlock_irq(&data->misclock);\r\ndev_kfree_skb_any(skb);\r\ncontinue;\r\n}\r\nif (netif_msg_pktdata(data)) {\r\nint i;\r\nprintk("%s: Rx Frame contents (%d)\n",\r\ndev->name, data->rxring[rx].len);\r\nfor (i = 0; i < data->rxring[rx].len; i++)\r\nprintk(" %2.2x", skb->data[i]);\r\nprintk(".\n");\r\n}\r\nskb_put(skb, data->rxring[rx].len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_receive_skb(skb);\r\n}\r\nreturn done;\r\n}\r\nstatic int tsi108_refill_rx(struct net_device *dev, int budget)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nint done = 0;\r\nwhile (data->rxfree != TSI108_RXRING_LEN && done != budget) {\r\nint rx = data->rxhead;\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb_ip_align(dev, TSI108_RXBUF_SIZE);\r\ndata->rxskbs[rx] = skb;\r\nif (!skb)\r\nbreak;\r\ndata->rxring[rx].buf0 = dma_map_single(NULL, skb->data,\r\nTSI108_RX_SKB_SIZE,\r\nDMA_FROM_DEVICE);\r\ndata->rxring[rx].blen = TSI108_RX_SKB_SIZE;\r\ndata->rxring[rx].misc = TSI108_RX_OWN | TSI108_RX_INT;\r\ndata->rxhead = (data->rxhead + 1) % TSI108_RXRING_LEN;\r\ndata->rxfree++;\r\ndone++;\r\n}\r\nif (done != 0 && !(TSI_READ(TSI108_EC_RXSTAT) &\r\nTSI108_EC_RXSTAT_QUEUE0))\r\ntsi108_restart_rx(data, dev);\r\nreturn done;\r\n}\r\nstatic int tsi108_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct tsi108_prv_data *data = container_of(napi, struct tsi108_prv_data, napi);\r\nstruct net_device *dev = data->dev;\r\nu32 estat = TSI_READ(TSI108_EC_RXESTAT);\r\nu32 intstat = TSI_READ(TSI108_EC_INTSTAT);\r\nint num_received = 0, num_filled = 0;\r\nintstat &= TSI108_INT_RXQUEUE0 | TSI108_INT_RXTHRESH |\r\nTSI108_INT_RXOVERRUN | TSI108_INT_RXERROR | TSI108_INT_RXWAIT;\r\nTSI_WRITE(TSI108_EC_RXESTAT, estat);\r\nTSI_WRITE(TSI108_EC_INTSTAT, intstat);\r\nif (data->rxpending || (estat & TSI108_EC_RXESTAT_Q0_DESCINT))\r\nnum_received = tsi108_complete_rx(dev, budget);\r\nif (data->rxfree < TSI108_RXRING_LEN)\r\nnum_filled = tsi108_refill_rx(dev, budget * 2);\r\nif (intstat & TSI108_INT_RXERROR) {\r\nu32 err = TSI_READ(TSI108_EC_RXERR);\r\nTSI_WRITE(TSI108_EC_RXERR, err);\r\nif (err) {\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "%s: RX error %x\n",\r\ndev->name, err);\r\nif (!(TSI_READ(TSI108_EC_RXSTAT) &\r\nTSI108_EC_RXSTAT_QUEUE0))\r\ntsi108_restart_rx(data, dev);\r\n}\r\n}\r\nif (intstat & TSI108_INT_RXOVERRUN) {\r\nspin_lock_irq(&data->misclock);\r\ndata->stats.rx_fifo_errors++;\r\nspin_unlock_irq(&data->misclock);\r\n}\r\nif (num_received < budget) {\r\ndata->rxpending = 0;\r\nnapi_complete(napi);\r\nTSI_WRITE(TSI108_EC_INTMASK,\r\nTSI_READ(TSI108_EC_INTMASK)\r\n& ~(TSI108_INT_RXQUEUE0\r\n| TSI108_INT_RXTHRESH |\r\nTSI108_INT_RXOVERRUN |\r\nTSI108_INT_RXERROR |\r\nTSI108_INT_RXWAIT));\r\n} else {\r\ndata->rxpending = 1;\r\n}\r\nreturn num_received;\r\n}\r\nstatic void tsi108_rx_int(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nif (napi_schedule_prep(&data->napi)) {\r\nTSI_WRITE(TSI108_EC_INTMASK,\r\nTSI_READ(TSI108_EC_INTMASK) |\r\nTSI108_INT_RXQUEUE0\r\n| TSI108_INT_RXTHRESH |\r\nTSI108_INT_RXOVERRUN | TSI108_INT_RXERROR |\r\nTSI108_INT_RXWAIT);\r\n__napi_schedule(&data->napi);\r\n} else {\r\nif (!netif_running(dev)) {\r\nTSI_WRITE(TSI108_EC_INTMASK,\r\nTSI_READ\r\n(TSI108_EC_INTMASK) |\r\nTSI108_INT_RXQUEUE0 |\r\nTSI108_INT_RXTHRESH |\r\nTSI108_INT_RXOVERRUN |\r\nTSI108_INT_RXERROR |\r\nTSI108_INT_RXWAIT);\r\n}\r\n}\r\n}\r\nstatic void tsi108_check_rxring(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nif (netif_running(dev) && data->rxfree < TSI108_RXRING_LEN / 4)\r\ntsi108_rx_int(dev);\r\n}\r\nstatic void tsi108_tx_int(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 estat = TSI_READ(TSI108_EC_TXESTAT);\r\nTSI_WRITE(TSI108_EC_TXESTAT, estat);\r\nTSI_WRITE(TSI108_EC_INTSTAT, TSI108_INT_TXQUEUE0 |\r\nTSI108_INT_TXIDLE | TSI108_INT_TXERROR);\r\nif (estat & TSI108_EC_TXESTAT_Q0_ERR) {\r\nu32 err = TSI_READ(TSI108_EC_TXERR);\r\nTSI_WRITE(TSI108_EC_TXERR, err);\r\nif (err && net_ratelimit())\r\nprintk(KERN_ERR "%s: TX error %x\n", dev->name, err);\r\n}\r\nif (estat & (TSI108_EC_TXESTAT_Q0_DESCINT | TSI108_EC_TXESTAT_Q0_EOQ)) {\r\nspin_lock(&data->txlock);\r\ntsi108_complete_tx(dev);\r\nspin_unlock(&data->txlock);\r\n}\r\n}\r\nstatic irqreturn_t tsi108_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 stat = TSI_READ(TSI108_EC_INTSTAT);\r\nif (!(stat & TSI108_INT_ANY))\r\nreturn IRQ_NONE;\r\nstat &= ~TSI_READ(TSI108_EC_INTMASK);\r\nif (stat & (TSI108_INT_TXQUEUE0 | TSI108_INT_TXIDLE |\r\nTSI108_INT_TXERROR))\r\ntsi108_tx_int(dev);\r\nif (stat & (TSI108_INT_RXQUEUE0 | TSI108_INT_RXTHRESH |\r\nTSI108_INT_RXWAIT | TSI108_INT_RXOVERRUN |\r\nTSI108_INT_RXERROR))\r\ntsi108_rx_int(dev);\r\nif (stat & TSI108_INT_SFN) {\r\nif (net_ratelimit())\r\nprintk(KERN_DEBUG "%s: SFN error\n", dev->name);\r\nTSI_WRITE(TSI108_EC_INTSTAT, TSI108_INT_SFN);\r\n}\r\nif (stat & TSI108_INT_STATCARRY) {\r\ntsi108_stat_carry(dev);\r\nTSI_WRITE(TSI108_EC_INTSTAT, TSI108_INT_STATCARRY);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsi108_stop_ethernet(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nint i = 1000;\r\nTSI_WRITE(TSI108_EC_TXCTRL, 0);\r\nTSI_WRITE(TSI108_EC_RXCTRL, 0);\r\nwhile(i--) {\r\nif(!(TSI_READ(TSI108_EC_TXSTAT) & TSI108_EC_TXSTAT_ACTIVE))\r\nbreak;\r\nudelay(10);\r\n}\r\ni = 1000;\r\nwhile(i--){\r\nif(!(TSI_READ(TSI108_EC_RXSTAT) & TSI108_EC_RXSTAT_ACTIVE))\r\nreturn;\r\nudelay(10);\r\n}\r\nprintk(KERN_ERR "%s function time out\n", __func__);\r\n}\r\nstatic void tsi108_reset_ether(struct tsi108_prv_data * data)\r\n{\r\nTSI_WRITE(TSI108_MAC_CFG1, TSI108_MAC_CFG1_SOFTRST);\r\nudelay(100);\r\nTSI_WRITE(TSI108_MAC_CFG1, 0);\r\nTSI_WRITE(TSI108_EC_PORTCTRL, TSI108_EC_PORTCTRL_STATRST);\r\nudelay(100);\r\nTSI_WRITE(TSI108_EC_PORTCTRL,\r\nTSI_READ(TSI108_EC_PORTCTRL) &\r\n~TSI108_EC_PORTCTRL_STATRST);\r\nTSI_WRITE(TSI108_EC_TXCFG, TSI108_EC_TXCFG_RST);\r\nudelay(100);\r\nTSI_WRITE(TSI108_EC_TXCFG,\r\nTSI_READ(TSI108_EC_TXCFG) &\r\n~TSI108_EC_TXCFG_RST);\r\nTSI_WRITE(TSI108_EC_RXCFG, TSI108_EC_RXCFG_RST);\r\nudelay(100);\r\nTSI_WRITE(TSI108_EC_RXCFG,\r\nTSI_READ(TSI108_EC_RXCFG) &\r\n~TSI108_EC_RXCFG_RST);\r\nTSI_WRITE(TSI108_MAC_MII_MGMT_CFG,\r\nTSI_READ(TSI108_MAC_MII_MGMT_CFG) |\r\nTSI108_MAC_MII_MGMT_RST);\r\nudelay(100);\r\nTSI_WRITE(TSI108_MAC_MII_MGMT_CFG,\r\n(TSI_READ(TSI108_MAC_MII_MGMT_CFG) &\r\n~(TSI108_MAC_MII_MGMT_RST |\r\nTSI108_MAC_MII_MGMT_CLK)) | 0x07);\r\n}\r\nstatic int tsi108_get_mac(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 word1 = TSI_READ(TSI108_MAC_ADDR1);\r\nu32 word2 = TSI_READ(TSI108_MAC_ADDR2);\r\nif (word2 == 0 && word1 == 0) {\r\ndev->dev_addr[0] = 0x00;\r\ndev->dev_addr[1] = 0x06;\r\ndev->dev_addr[2] = 0xd2;\r\ndev->dev_addr[3] = 0x00;\r\ndev->dev_addr[4] = 0x00;\r\nif (0x8 == data->phy)\r\ndev->dev_addr[5] = 0x01;\r\nelse\r\ndev->dev_addr[5] = 0x02;\r\nword2 = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 24);\r\nword1 = (dev->dev_addr[2] << 0) | (dev->dev_addr[3] << 8) |\r\n(dev->dev_addr[4] << 16) | (dev->dev_addr[5] << 24);\r\nTSI_WRITE(TSI108_MAC_ADDR1, word1);\r\nTSI_WRITE(TSI108_MAC_ADDR2, word2);\r\n} else {\r\ndev->dev_addr[0] = (word2 >> 16) & 0xff;\r\ndev->dev_addr[1] = (word2 >> 24) & 0xff;\r\ndev->dev_addr[2] = (word1 >> 0) & 0xff;\r\ndev->dev_addr[3] = (word1 >> 8) & 0xff;\r\ndev->dev_addr[4] = (word1 >> 16) & 0xff;\r\ndev->dev_addr[5] = (word1 >> 24) & 0xff;\r\n}\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nprintk(KERN_ERR\r\n"%s: Invalid MAC address. word1: %08x, word2: %08x\n",\r\ndev->name, word1, word2);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tsi108_set_mac(struct net_device *dev, void *addr)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 word1, word2;\r\nint i;\r\nif (!is_valid_ether_addr(addr))\r\nreturn -EADDRNOTAVAIL;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = ((unsigned char *)addr)[i + 2];\r\nword2 = (dev->dev_addr[0] << 16) | (dev->dev_addr[1] << 24);\r\nword1 = (dev->dev_addr[2] << 0) | (dev->dev_addr[3] << 8) |\r\n(dev->dev_addr[4] << 16) | (dev->dev_addr[5] << 24);\r\nspin_lock_irq(&data->misclock);\r\nTSI_WRITE(TSI108_MAC_ADDR1, word1);\r\nTSI_WRITE(TSI108_MAC_ADDR2, word2);\r\nspin_lock(&data->txlock);\r\nif (data->txfree && data->link_up)\r\nnetif_wake_queue(dev);\r\nspin_unlock(&data->txlock);\r\nspin_unlock_irq(&data->misclock);\r\nreturn 0;\r\n}\r\nstatic void tsi108_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 rxcfg = TSI_READ(TSI108_EC_RXCFG);\r\nif (dev->flags & IFF_PROMISC) {\r\nrxcfg &= ~(TSI108_EC_RXCFG_UC_HASH | TSI108_EC_RXCFG_MC_HASH);\r\nrxcfg |= TSI108_EC_RXCFG_UFE | TSI108_EC_RXCFG_MFE;\r\ngoto out;\r\n}\r\nrxcfg &= ~(TSI108_EC_RXCFG_UFE | TSI108_EC_RXCFG_MFE);\r\nif (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev)) {\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\nrxcfg |= TSI108_EC_RXCFG_MFE | TSI108_EC_RXCFG_MC_HASH;\r\nmemset(data->mc_hash, 0, sizeof(data->mc_hash));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 hash, crc;\r\ncrc = ether_crc(6, ha->addr);\r\nhash = crc >> 23;\r\n__set_bit(hash, &data->mc_hash[0]);\r\n}\r\nTSI_WRITE(TSI108_EC_HASHADDR,\r\nTSI108_EC_HASHADDR_AUTOINC |\r\nTSI108_EC_HASHADDR_MCAST);\r\nfor (i = 0; i < 16; i++) {\r\nudelay(1);\r\nTSI_WRITE(TSI108_EC_HASHDATA,\r\ndata->mc_hash[i]);\r\n}\r\n}\r\nout:\r\nTSI_WRITE(TSI108_EC_RXCFG, rxcfg);\r\n}\r\nstatic void tsi108_init_phy(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nu32 i = 0;\r\nu16 phyval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&phy_lock, flags);\r\ntsi108_write_mii(data, MII_BMCR, BMCR_RESET);\r\nwhile (--i) {\r\nif(!(tsi108_read_mii(data, MII_BMCR) & BMCR_RESET))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == 0)\r\nprintk(KERN_ERR "%s function time out\n", __func__);\r\nif (data->phy_type == TSI108_PHY_BCM54XX) {\r\ntsi108_write_mii(data, 0x09, 0x0300);\r\ntsi108_write_mii(data, 0x10, 0x1020);\r\ntsi108_write_mii(data, 0x1c, 0x8c00);\r\n}\r\ntsi108_write_mii(data,\r\nMII_BMCR,\r\nBMCR_ANENABLE | BMCR_ANRESTART);\r\nwhile (tsi108_read_mii(data, MII_BMCR) & BMCR_ANRESTART)\r\ncpu_relax();\r\ntsi108_write_tbi(data, 0x11, 0x30);\r\ndata->link_up = 0;\r\nwhile (!((phyval = tsi108_read_mii(data, MII_BMSR)) &\r\nBMSR_LSTATUS)) {\r\nif (i++ > (MII_READ_DELAY / 10)) {\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\nmsleep(10);\r\nspin_lock_irqsave(&phy_lock, flags);\r\n}\r\ndata->mii_if.supports_gmii = mii_check_gmii_support(&data->mii_if);\r\nprintk(KERN_DEBUG "PHY_STAT reg contains %08x\n", phyval);\r\ndata->phy_ok = 1;\r\ndata->init_media = 1;\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\n}\r\nstatic void tsi108_kill_phy(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&phy_lock, flags);\r\ntsi108_write_mii(data, MII_BMCR, BMCR_PDOWN);\r\ndata->phy_ok = 0;\r\nspin_unlock_irqrestore(&phy_lock, flags);\r\n}\r\nstatic int tsi108_open(struct net_device *dev)\r\n{\r\nint i;\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nunsigned int rxring_size = TSI108_RXRING_LEN * sizeof(rx_desc);\r\nunsigned int txring_size = TSI108_TXRING_LEN * sizeof(tx_desc);\r\ni = request_irq(data->irq_num, tsi108_irq, 0, dev->name, dev);\r\nif (i != 0) {\r\nprintk(KERN_ERR "tsi108_eth%d: Could not allocate IRQ%d.\n",\r\ndata->id, data->irq_num);\r\nreturn i;\r\n} else {\r\ndev->irq = data->irq_num;\r\nprintk(KERN_NOTICE\r\n"tsi108_open : Port %d Assigned IRQ %d to %s\n",\r\ndata->id, dev->irq, dev->name);\r\n}\r\ndata->rxring = dma_alloc_coherent(NULL, rxring_size,\r\n&data->rxdma, GFP_KERNEL);\r\nif (!data->rxring) {\r\nprintk(KERN_DEBUG\r\n"TSI108_ETH: failed to allocate memory for rxring!\n");\r\nreturn -ENOMEM;\r\n} else {\r\nmemset(data->rxring, 0, rxring_size);\r\n}\r\ndata->txring = dma_alloc_coherent(NULL, txring_size,\r\n&data->txdma, GFP_KERNEL);\r\nif (!data->txring) {\r\nprintk(KERN_DEBUG\r\n"TSI108_ETH: failed to allocate memory for txring!\n");\r\npci_free_consistent(0, rxring_size, data->rxring, data->rxdma);\r\nreturn -ENOMEM;\r\n} else {\r\nmemset(data->txring, 0, txring_size);\r\n}\r\nfor (i = 0; i < TSI108_RXRING_LEN; i++) {\r\ndata->rxring[i].next0 = data->rxdma + (i + 1) * sizeof(rx_desc);\r\ndata->rxring[i].blen = TSI108_RXBUF_SIZE;\r\ndata->rxring[i].vlan = 0;\r\n}\r\ndata->rxring[TSI108_RXRING_LEN - 1].next0 = data->rxdma;\r\ndata->rxtail = 0;\r\ndata->rxhead = 0;\r\nfor (i = 0; i < TSI108_RXRING_LEN; i++) {\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb_ip_align(dev, TSI108_RXBUF_SIZE);\r\nif (!skb) {\r\nprintk(KERN_WARNING\r\n"%s: Could only allocate %d receive skb(s).\n",\r\ndev->name, i);\r\ndata->rxhead = i;\r\nbreak;\r\n}\r\ndata->rxskbs[i] = skb;\r\ndata->rxskbs[i] = skb;\r\ndata->rxring[i].buf0 = virt_to_phys(data->rxskbs[i]->data);\r\ndata->rxring[i].misc = TSI108_RX_OWN | TSI108_RX_INT;\r\n}\r\ndata->rxfree = i;\r\nTSI_WRITE(TSI108_EC_RXQ_PTRLOW, data->rxdma);\r\nfor (i = 0; i < TSI108_TXRING_LEN; i++) {\r\ndata->txring[i].next0 = data->txdma + (i + 1) * sizeof(tx_desc);\r\ndata->txring[i].misc = 0;\r\n}\r\ndata->txring[TSI108_TXRING_LEN - 1].next0 = data->txdma;\r\ndata->txtail = 0;\r\ndata->txhead = 0;\r\ndata->txfree = TSI108_TXRING_LEN;\r\nTSI_WRITE(TSI108_EC_TXQ_PTRLOW, data->txdma);\r\ntsi108_init_phy(dev);\r\nnapi_enable(&data->napi);\r\nsetup_timer(&data->timer, tsi108_timed_checker, (unsigned long)dev);\r\nmod_timer(&data->timer, jiffies + 1);\r\ntsi108_restart_rx(data, dev);\r\nTSI_WRITE(TSI108_EC_INTSTAT, ~0);\r\nTSI_WRITE(TSI108_EC_INTMASK,\r\n~(TSI108_INT_TXQUEUE0 | TSI108_INT_RXERROR |\r\nTSI108_INT_RXTHRESH | TSI108_INT_RXQUEUE0 |\r\nTSI108_INT_RXOVERRUN | TSI108_INT_RXWAIT |\r\nTSI108_INT_SFN | TSI108_INT_STATCARRY));\r\nTSI_WRITE(TSI108_MAC_CFG1,\r\nTSI108_MAC_CFG1_RXEN | TSI108_MAC_CFG1_TXEN);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int tsi108_close(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&data->napi);\r\ndel_timer_sync(&data->timer);\r\ntsi108_stop_ethernet(dev);\r\ntsi108_kill_phy(dev);\r\nTSI_WRITE(TSI108_EC_INTMASK, ~0);\r\nTSI_WRITE(TSI108_MAC_CFG1, 0);\r\nwhile (!data->txfree || data->txhead != data->txtail) {\r\nint tx = data->txtail;\r\nstruct sk_buff *skb;\r\nskb = data->txskbs[tx];\r\ndata->txtail = (data->txtail + 1) % TSI108_TXRING_LEN;\r\ndata->txfree++;\r\ndev_kfree_skb(skb);\r\n}\r\nfree_irq(data->irq_num, dev);\r\nwhile (data->rxfree) {\r\nint rx = data->rxtail;\r\nstruct sk_buff *skb;\r\nskb = data->rxskbs[rx];\r\ndata->rxtail = (data->rxtail + 1) % TSI108_RXRING_LEN;\r\ndata->rxfree--;\r\ndev_kfree_skb(skb);\r\n}\r\ndma_free_coherent(0,\r\nTSI108_RXRING_LEN * sizeof(rx_desc),\r\ndata->rxring, data->rxdma);\r\ndma_free_coherent(0,\r\nTSI108_TXRING_LEN * sizeof(tx_desc),\r\ndata->txring, data->txdma);\r\nreturn 0;\r\n}\r\nstatic void tsi108_init_mac(struct net_device *dev)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nTSI_WRITE(TSI108_MAC_CFG2, TSI108_MAC_CFG2_DFLT_PREAMBLE |\r\nTSI108_MAC_CFG2_PADCRC);\r\nTSI_WRITE(TSI108_EC_TXTHRESH,\r\n(192 << TSI108_EC_TXTHRESH_STARTFILL) |\r\n(192 << TSI108_EC_TXTHRESH_STOPFILL));\r\nTSI_WRITE(TSI108_STAT_CARRYMASK1,\r\n~(TSI108_STAT_CARRY1_RXBYTES |\r\nTSI108_STAT_CARRY1_RXPKTS |\r\nTSI108_STAT_CARRY1_RXFCS |\r\nTSI108_STAT_CARRY1_RXMCAST |\r\nTSI108_STAT_CARRY1_RXALIGN |\r\nTSI108_STAT_CARRY1_RXLENGTH |\r\nTSI108_STAT_CARRY1_RXRUNT |\r\nTSI108_STAT_CARRY1_RXJUMBO |\r\nTSI108_STAT_CARRY1_RXFRAG |\r\nTSI108_STAT_CARRY1_RXJABBER |\r\nTSI108_STAT_CARRY1_RXDROP));\r\nTSI_WRITE(TSI108_STAT_CARRYMASK2,\r\n~(TSI108_STAT_CARRY2_TXBYTES |\r\nTSI108_STAT_CARRY2_TXPKTS |\r\nTSI108_STAT_CARRY2_TXEXDEF |\r\nTSI108_STAT_CARRY2_TXEXCOL |\r\nTSI108_STAT_CARRY2_TXTCOL |\r\nTSI108_STAT_CARRY2_TXPAUSE));\r\nTSI_WRITE(TSI108_EC_PORTCTRL, TSI108_EC_PORTCTRL_STATEN);\r\nTSI_WRITE(TSI108_MAC_CFG1, 0);\r\nTSI_WRITE(TSI108_EC_RXCFG,\r\nTSI108_EC_RXCFG_SE | TSI108_EC_RXCFG_BFE);\r\nTSI_WRITE(TSI108_EC_TXQ_CFG, TSI108_EC_TXQ_CFG_DESC_INT |\r\nTSI108_EC_TXQ_CFG_EOQ_OWN_INT |\r\nTSI108_EC_TXQ_CFG_WSWP | (TSI108_PBM_PORT <<\r\nTSI108_EC_TXQ_CFG_SFNPORT));\r\nTSI_WRITE(TSI108_EC_RXQ_CFG, TSI108_EC_RXQ_CFG_DESC_INT |\r\nTSI108_EC_RXQ_CFG_EOQ_OWN_INT |\r\nTSI108_EC_RXQ_CFG_WSWP | (TSI108_PBM_PORT <<\r\nTSI108_EC_RXQ_CFG_SFNPORT));\r\nTSI_WRITE(TSI108_EC_TXQ_BUFCFG,\r\nTSI108_EC_TXQ_BUFCFG_BURST256 |\r\nTSI108_EC_TXQ_BUFCFG_BSWP | (TSI108_PBM_PORT <<\r\nTSI108_EC_TXQ_BUFCFG_SFNPORT));\r\nTSI_WRITE(TSI108_EC_RXQ_BUFCFG,\r\nTSI108_EC_RXQ_BUFCFG_BURST256 |\r\nTSI108_EC_RXQ_BUFCFG_BSWP | (TSI108_PBM_PORT <<\r\nTSI108_EC_RXQ_BUFCFG_SFNPORT));\r\nTSI_WRITE(TSI108_EC_INTMASK, ~0);\r\n}\r\nstatic int tsi108_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&data->txlock, flags);\r\nrc = mii_ethtool_gset(&data->mii_if, cmd);\r\nspin_unlock_irqrestore(&data->txlock, flags);\r\nreturn rc;\r\n}\r\nstatic int tsi108_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&data->txlock, flags);\r\nrc = mii_ethtool_sset(&data->mii_if, cmd);\r\nspin_unlock_irqrestore(&data->txlock, flags);\r\nreturn rc;\r\n}\r\nstatic int tsi108_do_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn generic_mii_ioctl(&data->mii_if, if_mii(rq), cmd, NULL);\r\n}\r\nstatic int\r\ntsi108_init_one(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct tsi108_prv_data *data = NULL;\r\nhw_info *einfo;\r\nint err = 0;\r\neinfo = pdev->dev.platform_data;\r\nif (NULL == einfo) {\r\nprintk(KERN_ERR "tsi-eth %d: Missing additional data!\n",\r\npdev->id);\r\nreturn -ENODEV;\r\n}\r\ndev = alloc_etherdev(sizeof(struct tsi108_prv_data));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nprintk("tsi108_eth%d: probe...\n", pdev->id);\r\ndata = netdev_priv(dev);\r\ndata->dev = dev;\r\npr_debug("tsi108_eth%d:regs:phyresgs:phy:irq_num=0x%x:0x%x:0x%x:0x%x\n",\r\npdev->id, einfo->regs, einfo->phyregs,\r\neinfo->phy, einfo->irq_num);\r\ndata->regs = ioremap(einfo->regs, 0x400);\r\nif (NULL == data->regs) {\r\nerr = -ENOMEM;\r\ngoto regs_fail;\r\n}\r\ndata->phyregs = ioremap(einfo->phyregs, 0x400);\r\nif (NULL == data->phyregs) {\r\nerr = -ENOMEM;\r\ngoto phyregs_fail;\r\n}\r\ndata->mii_if.dev = dev;\r\ndata->mii_if.mdio_read = tsi108_mdio_read;\r\ndata->mii_if.mdio_write = tsi108_mdio_write;\r\ndata->mii_if.phy_id = einfo->phy;\r\ndata->mii_if.phy_id_mask = 0x1f;\r\ndata->mii_if.reg_num_mask = 0x1f;\r\ndata->phy = einfo->phy;\r\ndata->phy_type = einfo->phy_type;\r\ndata->irq_num = einfo->irq_num;\r\ndata->id = pdev->id;\r\nnetif_napi_add(dev, &data->napi, tsi108_poll, 64);\r\ndev->netdev_ops = &tsi108_netdev_ops;\r\ndev->ethtool_ops = &tsi108_ethtool_ops;\r\ndev->features = NETIF_F_HIGHDMA;\r\nspin_lock_init(&data->txlock);\r\nspin_lock_init(&data->misclock);\r\ntsi108_reset_ether(data);\r\ntsi108_kill_phy(dev);\r\nif ((err = tsi108_get_mac(dev)) != 0) {\r\nprintk(KERN_ERR "%s: Invalid MAC address. Please correct.\n",\r\ndev->name);\r\ngoto register_fail;\r\n}\r\ntsi108_init_mac(dev);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s: Cannot register net device, aborting.\n",\r\ndev->name);\r\ngoto register_fail;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nprintk(KERN_INFO "%s: Tsi108 Gigabit Ethernet, MAC: %pM\n",\r\ndev->name, dev->dev_addr);\r\n#ifdef DEBUG\r\ndata->msg_enable = DEBUG;\r\ndump_eth_one(dev);\r\n#endif\r\nreturn 0;\r\nregister_fail:\r\niounmap(data->phyregs);\r\nphyregs_fail:\r\niounmap(data->regs);\r\nregs_fail:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void tsi108_timed_checker(unsigned long dev_ptr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_ptr;\r\nstruct tsi108_prv_data *data = netdev_priv(dev);\r\ntsi108_check_phy(dev);\r\ntsi108_check_rxring(dev);\r\nmod_timer(&data->timer, jiffies + CHECK_PHY_INTERVAL);\r\n}\r\nstatic int tsi108_ether_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct tsi108_prv_data *priv = netdev_priv(dev);\r\nunregister_netdev(dev);\r\ntsi108_stop_ethernet(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(priv->regs);\r\niounmap(priv->phyregs);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
