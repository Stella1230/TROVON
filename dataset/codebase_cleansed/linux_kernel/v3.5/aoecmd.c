static struct sk_buff *\r\nnew_skb(ulong len)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(len, GFP_ATOMIC);\r\nif (skb) {\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nskb->protocol = __constant_htons(ETH_P_AOE);\r\n}\r\nreturn skb;\r\n}\r\nstatic struct frame *\r\ngetframe(struct aoetgt *t, int tag)\r\n{\r\nstruct frame *f, *e;\r\nf = t->frames;\r\ne = f + t->nframes;\r\nfor (; f<e; f++)\r\nif (f->tag == tag)\r\nreturn f;\r\nreturn NULL;\r\n}\r\nstatic int\r\nnewtag(struct aoetgt *t)\r\n{\r\nregister ulong n;\r\nn = jiffies & 0xffff;\r\nreturn n |= (++t->lasttag & 0x7fff) << 16;\r\n}\r\nstatic int\r\naoehdr_atainit(struct aoedev *d, struct aoetgt *t, struct aoe_hdr *h)\r\n{\r\nu32 host_tag = newtag(t);\r\nmemcpy(h->src, t->ifp->nd->dev_addr, sizeof h->src);\r\nmemcpy(h->dst, t->addr, sizeof h->dst);\r\nh->type = __constant_cpu_to_be16(ETH_P_AOE);\r\nh->verfl = AOE_HVER;\r\nh->major = cpu_to_be16(d->aoemajor);\r\nh->minor = d->aoeminor;\r\nh->cmd = AOECMD_ATA;\r\nh->tag = cpu_to_be32(host_tag);\r\nreturn host_tag;\r\n}\r\nstatic inline void\r\nput_lba(struct aoe_atahdr *ah, sector_t lba)\r\n{\r\nah->lba0 = lba;\r\nah->lba1 = lba >>= 8;\r\nah->lba2 = lba >>= 8;\r\nah->lba3 = lba >>= 8;\r\nah->lba4 = lba >>= 8;\r\nah->lba5 = lba >>= 8;\r\n}\r\nstatic void\r\nifrotate(struct aoetgt *t)\r\n{\r\nt->ifp++;\r\nif (t->ifp >= &t->ifs[NAOEIFS] || t->ifp->nd == NULL)\r\nt->ifp = t->ifs;\r\nif (t->ifp->nd == NULL) {\r\nprintk(KERN_INFO "aoe: no interface to rotate to\n");\r\nBUG();\r\n}\r\n}\r\nstatic void\r\nskb_pool_put(struct aoedev *d, struct sk_buff *skb)\r\n{\r\n__skb_queue_tail(&d->skbpool, skb);\r\n}\r\nstatic struct sk_buff *\r\nskb_pool_get(struct aoedev *d)\r\n{\r\nstruct sk_buff *skb = skb_peek(&d->skbpool);\r\nif (skb && atomic_read(&skb_shinfo(skb)->dataref) == 1) {\r\n__skb_unlink(skb, &d->skbpool);\r\nreturn skb;\r\n}\r\nif (skb_queue_len(&d->skbpool) < NSKBPOOLMAX &&\r\n(skb = new_skb(ETH_ZLEN)))\r\nreturn skb;\r\nreturn NULL;\r\n}\r\nstatic struct frame *\r\nfreeframe(struct aoedev *d)\r\n{\r\nstruct frame *f, *e, *rf;\r\nstruct aoetgt **t;\r\nstruct sk_buff *skb;\r\nif (d->targets[0] == NULL) {\r\nprintk(KERN_ERR "aoe: NULL TARGETS!\n");\r\nreturn NULL;\r\n}\r\nt = d->tgt;\r\nt++;\r\nif (t >= &d->targets[NTARGETS] || !*t)\r\nt = d->targets;\r\nfor (;;) {\r\nif ((*t)->nout < (*t)->maxout\r\n&& t != d->htgt\r\n&& (*t)->ifp->nd) {\r\nrf = NULL;\r\nf = (*t)->frames;\r\ne = f + (*t)->nframes;\r\nfor (; f < e; f++) {\r\nif (f->tag != FREETAG)\r\ncontinue;\r\nskb = f->skb;\r\nif (!skb\r\n&& !(f->skb = skb = new_skb(ETH_ZLEN)))\r\ncontinue;\r\nif (atomic_read(&skb_shinfo(skb)->dataref)\r\n!= 1) {\r\nif (!rf)\r\nrf = f;\r\ncontinue;\r\n}\r\ngotone: skb_shinfo(skb)->nr_frags = skb->data_len = 0;\r\nskb_trim(skb, 0);\r\nd->tgt = t;\r\nifrotate(*t);\r\nreturn f;\r\n}\r\nf = rf;\r\nif (f == NULL) {\r\nprintk(KERN_ERR\r\n"aoe: freeframe: %s.\n",\r\n"unexpected null rf");\r\nd->flags |= DEVFL_KICKME;\r\nreturn NULL;\r\n}\r\nskb = skb_pool_get(d);\r\nif (skb) {\r\nskb_pool_put(d, f->skb);\r\nf->skb = skb;\r\ngoto gotone;\r\n}\r\n(*t)->dataref++;\r\nif ((*t)->nout == 0)\r\nd->flags |= DEVFL_KICKME;\r\n}\r\nif (t == d->tgt)\r\nbreak;\r\nt++;\r\nif (t >= &d->targets[NTARGETS] || !*t)\r\nt = d->targets;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\naoecmd_ata_rw(struct aoedev *d)\r\n{\r\nstruct frame *f;\r\nstruct aoe_hdr *h;\r\nstruct aoe_atahdr *ah;\r\nstruct buf *buf;\r\nstruct bio_vec *bv;\r\nstruct aoetgt *t;\r\nstruct sk_buff *skb;\r\nulong bcnt;\r\nchar writebit, extbit;\r\nwritebit = 0x10;\r\nextbit = 0x4;\r\nf = freeframe(d);\r\nif (f == NULL)\r\nreturn 0;\r\nt = *d->tgt;\r\nbuf = d->inprocess;\r\nbv = buf->bv;\r\nbcnt = t->ifp->maxbcnt;\r\nif (bcnt == 0)\r\nbcnt = DEFAULTBCNT;\r\nif (bcnt > buf->bv_resid)\r\nbcnt = buf->bv_resid;\r\nskb = f->skb;\r\nh = (struct aoe_hdr *) skb_mac_header(skb);\r\nah = (struct aoe_atahdr *) (h+1);\r\nskb_put(skb, sizeof *h + sizeof *ah);\r\nmemset(h, 0, skb->len);\r\nf->tag = aoehdr_atainit(d, t, h);\r\nt->nout++;\r\nf->waited = 0;\r\nf->buf = buf;\r\nf->bufaddr = page_address(bv->bv_page) + buf->bv_off;\r\nf->bcnt = bcnt;\r\nf->lba = buf->sector;\r\nah->scnt = bcnt >> 9;\r\nput_lba(ah, buf->sector);\r\nif (d->flags & DEVFL_EXT) {\r\nah->aflags |= AOEAFL_EXT;\r\n} else {\r\nextbit = 0;\r\nah->lba3 &= 0x0f;\r\nah->lba3 |= 0xe0;\r\n}\r\nif (bio_data_dir(buf->bio) == WRITE) {\r\nskb_fill_page_desc(skb, 0, bv->bv_page, buf->bv_off, bcnt);\r\nah->aflags |= AOEAFL_WRITE;\r\nskb->len += bcnt;\r\nskb->data_len = bcnt;\r\nt->wpkts++;\r\n} else {\r\nt->rpkts++;\r\nwritebit = 0;\r\n}\r\nah->cmdstat = ATA_CMD_PIO_READ | writebit | extbit;\r\nbuf->nframesout += 1;\r\nbuf->bv_off += bcnt;\r\nbuf->bv_resid -= bcnt;\r\nbuf->resid -= bcnt;\r\nbuf->sector += bcnt >> 9;\r\nif (buf->resid == 0) {\r\nd->inprocess = NULL;\r\n} else if (buf->bv_resid == 0) {\r\nbuf->bv = ++bv;\r\nbuf->bv_resid = bv->bv_len;\r\nWARN_ON(buf->bv_resid == 0);\r\nbuf->bv_off = bv->bv_offset;\r\n}\r\nskb->dev = t->ifp->nd;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (skb)\r\n__skb_queue_tail(&d->sendq, skb);\r\nreturn 1;\r\n}\r\nstatic void\r\naoecmd_cfg_pkts(ushort aoemajor, unsigned char aoeminor, struct sk_buff_head *queue)\r\n{\r\nstruct aoe_hdr *h;\r\nstruct aoe_cfghdr *ch;\r\nstruct sk_buff *skb;\r\nstruct net_device *ifp;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, ifp) {\r\ndev_hold(ifp);\r\nif (!is_aoe_netif(ifp))\r\ngoto cont;\r\nskb = new_skb(sizeof *h + sizeof *ch);\r\nif (skb == NULL) {\r\nprintk(KERN_INFO "aoe: skb alloc failure\n");\r\ngoto cont;\r\n}\r\nskb_put(skb, sizeof *h + sizeof *ch);\r\nskb->dev = ifp;\r\n__skb_queue_tail(queue, skb);\r\nh = (struct aoe_hdr *) skb_mac_header(skb);\r\nmemset(h, 0, sizeof *h + sizeof *ch);\r\nmemset(h->dst, 0xff, sizeof h->dst);\r\nmemcpy(h->src, ifp->dev_addr, sizeof h->src);\r\nh->type = __constant_cpu_to_be16(ETH_P_AOE);\r\nh->verfl = AOE_HVER;\r\nh->major = cpu_to_be16(aoemajor);\r\nh->minor = aoeminor;\r\nh->cmd = AOECMD_CFG;\r\ncont:\r\ndev_put(ifp);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void\r\nresend(struct aoedev *d, struct aoetgt *t, struct frame *f)\r\n{\r\nstruct sk_buff *skb;\r\nstruct aoe_hdr *h;\r\nstruct aoe_atahdr *ah;\r\nchar buf[128];\r\nu32 n;\r\nifrotate(t);\r\nn = newtag(t);\r\nskb = f->skb;\r\nh = (struct aoe_hdr *) skb_mac_header(skb);\r\nah = (struct aoe_atahdr *) (h+1);\r\nsnprintf(buf, sizeof buf,\r\n"%15s e%ld.%d oldtag=%08x@%08lx newtag=%08x s=%pm d=%pm nout=%d\n",\r\n"retransmit", d->aoemajor, d->aoeminor, f->tag, jiffies, n,\r\nh->src, h->dst, t->nout);\r\naoechr_error(buf);\r\nf->tag = n;\r\nh->tag = cpu_to_be32(n);\r\nmemcpy(h->dst, t->addr, sizeof h->dst);\r\nmemcpy(h->src, t->ifp->nd->dev_addr, sizeof h->src);\r\nswitch (ah->cmdstat) {\r\ndefault:\r\nbreak;\r\ncase ATA_CMD_PIO_READ:\r\ncase ATA_CMD_PIO_READ_EXT:\r\ncase ATA_CMD_PIO_WRITE:\r\ncase ATA_CMD_PIO_WRITE_EXT:\r\nput_lba(ah, f->lba);\r\nn = f->bcnt;\r\nif (n > DEFAULTBCNT)\r\nn = DEFAULTBCNT;\r\nah->scnt = n >> 9;\r\nif (ah->aflags & AOEAFL_WRITE) {\r\nskb_fill_page_desc(skb, 0, virt_to_page(f->bufaddr),\r\noffset_in_page(f->bufaddr), n);\r\nskb->len = sizeof *h + sizeof *ah + n;\r\nskb->data_len = n;\r\n}\r\n}\r\nskb->dev = t->ifp->nd;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\n__skb_queue_tail(&d->sendq, skb);\r\n}\r\nstatic int\r\ntsince(int tag)\r\n{\r\nint n;\r\nn = jiffies & 0xffff;\r\nn -= tag & 0xffff;\r\nif (n < 0)\r\nn += 1<<16;\r\nreturn n;\r\n}\r\nstatic struct aoeif *\r\ngetif(struct aoetgt *t, struct net_device *nd)\r\n{\r\nstruct aoeif *p, *e;\r\np = t->ifs;\r\ne = p + NAOEIFS;\r\nfor (; p < e; p++)\r\nif (p->nd == nd)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic struct aoeif *\r\naddif(struct aoetgt *t, struct net_device *nd)\r\n{\r\nstruct aoeif *p;\r\np = getif(t, NULL);\r\nif (!p)\r\nreturn NULL;\r\np->nd = nd;\r\np->maxbcnt = DEFAULTBCNT;\r\np->lost = 0;\r\np->lostjumbo = 0;\r\nreturn p;\r\n}\r\nstatic void\r\nejectif(struct aoetgt *t, struct aoeif *ifp)\r\n{\r\nstruct aoeif *e;\r\nulong n;\r\ne = t->ifs + NAOEIFS - 1;\r\nn = (e - ifp) * sizeof *ifp;\r\nmemmove(ifp, ifp+1, n);\r\ne->nd = NULL;\r\n}\r\nstatic int\r\nsthtith(struct aoedev *d)\r\n{\r\nstruct frame *f, *e, *nf;\r\nstruct sk_buff *skb;\r\nstruct aoetgt *ht = *d->htgt;\r\nf = ht->frames;\r\ne = f + ht->nframes;\r\nfor (; f < e; f++) {\r\nif (f->tag == FREETAG)\r\ncontinue;\r\nnf = freeframe(d);\r\nif (!nf)\r\nreturn 0;\r\nskb = nf->skb;\r\n*nf = *f;\r\nf->skb = skb;\r\nf->tag = FREETAG;\r\nnf->waited = 0;\r\nht->nout--;\r\n(*d->tgt)->nout++;\r\nresend(d, *d->tgt, nf);\r\n}\r\nmemset(ht->ifs, 0, sizeof ht->ifs);\r\nd->htgt = NULL;\r\nreturn 1;\r\n}\r\nstatic inline unsigned char\r\nata_scnt(unsigned char *packet) {\r\nstruct aoe_hdr *h;\r\nstruct aoe_atahdr *ah;\r\nh = (struct aoe_hdr *) packet;\r\nah = (struct aoe_atahdr *) (h+1);\r\nreturn ah->scnt;\r\n}\r\nstatic void\r\nrexmit_timer(ulong vp)\r\n{\r\nstruct sk_buff_head queue;\r\nstruct aoedev *d;\r\nstruct aoetgt *t, **tt, **te;\r\nstruct aoeif *ifp;\r\nstruct frame *f, *e;\r\nregister long timeout;\r\nulong flags, n;\r\nd = (struct aoedev *) vp;\r\ntimeout = d->rttavg;\r\ntimeout += timeout >> 1;\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (d->flags & DEVFL_TKILL) {\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\ntt = d->targets;\r\nte = tt + NTARGETS;\r\nfor (; tt < te && *tt; tt++) {\r\nt = *tt;\r\nf = t->frames;\r\ne = f + t->nframes;\r\nfor (; f < e; f++) {\r\nif (f->tag == FREETAG\r\n|| tsince(f->tag) < timeout)\r\ncontinue;\r\nn = f->waited += timeout;\r\nn /= HZ;\r\nif (n > aoe_deadsecs) {\r\naoedev_downdev(d);\r\nbreak;\r\n}\r\nif (n > HELPWAIT\r\n&& (tt != d->targets || d->targets[1]))\r\nd->htgt = tt;\r\nif (t->nout == t->maxout) {\r\nif (t->maxout > 1)\r\nt->maxout--;\r\nt->lastwadj = jiffies;\r\n}\r\nifp = getif(t, f->skb->dev);\r\nif (ifp && ++ifp->lost > (t->nframes << 1)\r\n&& (ifp != t->ifs || t->ifs[1].nd)) {\r\nejectif(t, ifp);\r\nifp = NULL;\r\n}\r\nif (ata_scnt(skb_mac_header(f->skb)) > DEFAULTBCNT / 512\r\n&& ifp && ++ifp->lostjumbo > (t->nframes << 1)\r\n&& ifp->maxbcnt != DEFAULTBCNT) {\r\nprintk(KERN_INFO\r\n"aoe: e%ld.%d: "\r\n"too many lost jumbo on "\r\n"%s:%pm - "\r\n"falling back to %d frames.\n",\r\nd->aoemajor, d->aoeminor,\r\nifp->nd->name, t->addr,\r\nDEFAULTBCNT);\r\nifp->maxbcnt = 0;\r\n}\r\nresend(d, t, f);\r\n}\r\nif (t->nout == t->maxout\r\n&& t->maxout < t->nframes\r\n&& (jiffies - t->lastwadj)/HZ > 10) {\r\nt->maxout++;\r\nt->lastwadj = jiffies;\r\n}\r\n}\r\nif (!skb_queue_empty(&d->sendq)) {\r\nn = d->rttavg <<= 1;\r\nif (n > MAXTIMER)\r\nd->rttavg = MAXTIMER;\r\n}\r\nif (d->flags & DEVFL_KICKME || d->htgt) {\r\nd->flags &= ~DEVFL_KICKME;\r\naoecmd_work(d);\r\n}\r\n__skb_queue_head_init(&queue);\r\nskb_queue_splice_init(&d->sendq, &queue);\r\nd->timer.expires = jiffies + TIMERTICK;\r\nadd_timer(&d->timer);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\naoenet_xmit(&queue);\r\n}\r\nvoid\r\naoecmd_work(struct aoedev *d)\r\n{\r\nstruct buf *buf;\r\nloop:\r\nif (d->htgt && !sthtith(d))\r\nreturn;\r\nif (d->inprocess == NULL) {\r\nif (list_empty(&d->bufq))\r\nreturn;\r\nbuf = container_of(d->bufq.next, struct buf, bufs);\r\nlist_del(d->bufq.next);\r\nd->inprocess = buf;\r\n}\r\nif (aoecmd_ata_rw(d))\r\ngoto loop;\r\n}\r\nvoid\r\naoecmd_sleepwork(struct work_struct *work)\r\n{\r\nstruct aoedev *d = container_of(work, struct aoedev, work);\r\nif (d->flags & DEVFL_GDALLOC)\r\naoeblk_gdalloc(d);\r\nif (d->flags & DEVFL_NEWSIZE) {\r\nstruct block_device *bd;\r\nunsigned long flags;\r\nu64 ssize;\r\nssize = get_capacity(d->gd);\r\nbd = bdget_disk(d->gd, 0);\r\nif (bd) {\r\nmutex_lock(&bd->bd_inode->i_mutex);\r\ni_size_write(bd->bd_inode, (loff_t)ssize<<9);\r\nmutex_unlock(&bd->bd_inode->i_mutex);\r\nbdput(bd);\r\n}\r\nspin_lock_irqsave(&d->lock, flags);\r\nd->flags |= DEVFL_UP;\r\nd->flags &= ~DEVFL_NEWSIZE;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\n}\r\n}\r\nstatic void\r\nataid_complete(struct aoedev *d, struct aoetgt *t, unsigned char *id)\r\n{\r\nu64 ssize;\r\nu16 n;\r\nn = get_unaligned_le16(&id[83 << 1]);\r\nn |= get_unaligned_le16(&id[86 << 1]);\r\nif (n & (1<<10)) {\r\nd->flags |= DEVFL_EXT;\r\nssize = get_unaligned_le64(&id[100 << 1]);\r\nd->geo.cylinders = ssize;\r\nd->geo.cylinders /= (255 * 63);\r\nd->geo.heads = 255;\r\nd->geo.sectors = 63;\r\n} else {\r\nd->flags &= ~DEVFL_EXT;\r\nssize = get_unaligned_le32(&id[60 << 1]);\r\nd->geo.cylinders = get_unaligned_le16(&id[54 << 1]);\r\nd->geo.heads = get_unaligned_le16(&id[55 << 1]);\r\nd->geo.sectors = get_unaligned_le16(&id[56 << 1]);\r\n}\r\nif (d->ssize != ssize)\r\nprintk(KERN_INFO\r\n"aoe: %pm e%ld.%d v%04x has %llu sectors\n",\r\nt->addr,\r\nd->aoemajor, d->aoeminor,\r\nd->fw_ver, (long long)ssize);\r\nd->ssize = ssize;\r\nd->geo.start = 0;\r\nif (d->flags & (DEVFL_GDALLOC|DEVFL_NEWSIZE))\r\nreturn;\r\nif (d->gd != NULL) {\r\nset_capacity(d->gd, ssize);\r\nd->flags |= DEVFL_NEWSIZE;\r\n} else\r\nd->flags |= DEVFL_GDALLOC;\r\nschedule_work(&d->work);\r\n}\r\nstatic void\r\ncalc_rttavg(struct aoedev *d, int rtt)\r\n{\r\nregister long n;\r\nn = rtt;\r\nif (n < 0) {\r\nn = -rtt;\r\nif (n < MINTIMER)\r\nn = MINTIMER;\r\nelse if (n > MAXTIMER)\r\nn = MAXTIMER;\r\nd->mintimer += (n - d->mintimer) >> 1;\r\n} else if (n < d->mintimer)\r\nn = d->mintimer;\r\nelse if (n > MAXTIMER)\r\nn = MAXTIMER;\r\nn -= d->rttavg;\r\nd->rttavg += n >> 2;\r\n}\r\nstatic struct aoetgt *\r\ngettgt(struct aoedev *d, char *addr)\r\n{\r\nstruct aoetgt **t, **e;\r\nt = d->targets;\r\ne = t + NTARGETS;\r\nfor (; t < e && *t; t++)\r\nif (memcmp((*t)->addr, addr, sizeof((*t)->addr)) == 0)\r\nreturn *t;\r\nreturn NULL;\r\n}\r\nstatic inline void\r\ndiskstats(struct gendisk *disk, struct bio *bio, ulong duration, sector_t sector)\r\n{\r\nunsigned long n_sect = bio->bi_size >> 9;\r\nconst int rw = bio_data_dir(bio);\r\nstruct hd_struct *part;\r\nint cpu;\r\ncpu = part_stat_lock();\r\npart = disk_map_sector_rcu(disk, sector);\r\npart_stat_inc(cpu, part, ios[rw]);\r\npart_stat_add(cpu, part, ticks[rw], duration);\r\npart_stat_add(cpu, part, sectors[rw], n_sect);\r\npart_stat_add(cpu, part, io_ticks, duration);\r\npart_stat_unlock();\r\n}\r\nvoid\r\naoecmd_ata_rsp(struct sk_buff *skb)\r\n{\r\nstruct sk_buff_head queue;\r\nstruct aoedev *d;\r\nstruct aoe_hdr *hin, *hout;\r\nstruct aoe_atahdr *ahin, *ahout;\r\nstruct frame *f;\r\nstruct buf *buf;\r\nstruct aoetgt *t;\r\nstruct aoeif *ifp;\r\nregister long n;\r\nulong flags;\r\nchar ebuf[128];\r\nu16 aoemajor;\r\nhin = (struct aoe_hdr *) skb_mac_header(skb);\r\naoemajor = get_unaligned_be16(&hin->major);\r\nd = aoedev_by_aoeaddr(aoemajor, hin->minor);\r\nif (d == NULL) {\r\nsnprintf(ebuf, sizeof ebuf, "aoecmd_ata_rsp: ata response "\r\n"for unknown device %d.%d\n",\r\naoemajor, hin->minor);\r\naoechr_error(ebuf);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&d->lock, flags);\r\nn = get_unaligned_be32(&hin->tag);\r\nt = gettgt(d, hin->src);\r\nif (t == NULL) {\r\nprintk(KERN_INFO "aoe: can't find target e%ld.%d:%pm\n",\r\nd->aoemajor, d->aoeminor, hin->src);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\nf = getframe(t, n);\r\nif (f == NULL) {\r\ncalc_rttavg(d, -tsince(n));\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nsnprintf(ebuf, sizeof ebuf,\r\n"%15s e%d.%d tag=%08x@%08lx\n",\r\n"unexpected rsp",\r\nget_unaligned_be16(&hin->major),\r\nhin->minor,\r\nget_unaligned_be32(&hin->tag),\r\njiffies);\r\naoechr_error(ebuf);\r\nreturn;\r\n}\r\ncalc_rttavg(d, tsince(f->tag));\r\nahin = (struct aoe_atahdr *) (hin+1);\r\nhout = (struct aoe_hdr *) skb_mac_header(f->skb);\r\nahout = (struct aoe_atahdr *) (hout+1);\r\nbuf = f->buf;\r\nif (ahin->cmdstat & 0xa9) {\r\nprintk(KERN_ERR\r\n"aoe: ata error cmd=%2.2Xh stat=%2.2Xh from e%ld.%d\n",\r\nahout->cmdstat, ahin->cmdstat,\r\nd->aoemajor, d->aoeminor);\r\nif (buf)\r\nbuf->flags |= BUFFL_FAIL;\r\n} else {\r\nif (d->htgt && t == *d->htgt)\r\nd->htgt = NULL;\r\nn = ahout->scnt << 9;\r\nswitch (ahout->cmdstat) {\r\ncase ATA_CMD_PIO_READ:\r\ncase ATA_CMD_PIO_READ_EXT:\r\nif (skb->len - sizeof *hin - sizeof *ahin < n) {\r\nprintk(KERN_ERR\r\n"aoe: %s. skb->len=%d need=%ld\n",\r\n"runt data size in read", skb->len, n);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\nmemcpy(f->bufaddr, ahin+1, n);\r\ncase ATA_CMD_PIO_WRITE:\r\ncase ATA_CMD_PIO_WRITE_EXT:\r\nifp = getif(t, skb->dev);\r\nif (ifp) {\r\nifp->lost = 0;\r\nif (n > DEFAULTBCNT)\r\nifp->lostjumbo = 0;\r\n}\r\nif (f->bcnt -= n) {\r\nf->lba += n >> 9;\r\nf->bufaddr += n;\r\nresend(d, t, f);\r\ngoto xmit;\r\n}\r\nbreak;\r\ncase ATA_CMD_ID_ATA:\r\nif (skb->len - sizeof *hin - sizeof *ahin < 512) {\r\nprintk(KERN_INFO\r\n"aoe: runt data size in ataid. skb->len=%d\n",\r\nskb->len);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\nataid_complete(d, t, (char *) (ahin+1));\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO\r\n"aoe: unrecognized ata command %2.2Xh for %d.%d\n",\r\nahout->cmdstat,\r\nget_unaligned_be16(&hin->major),\r\nhin->minor);\r\n}\r\n}\r\nif (buf && --buf->nframesout == 0 && buf->resid == 0) {\r\ndiskstats(d->gd, buf->bio, jiffies - buf->stime, buf->sector);\r\nif (buf->flags & BUFFL_FAIL)\r\nbio_endio(buf->bio, -EIO);\r\nelse {\r\nbio_flush_dcache_pages(buf->bio);\r\nbio_endio(buf->bio, 0);\r\n}\r\nmempool_free(buf, d->bufpool);\r\n}\r\nf->buf = NULL;\r\nf->tag = FREETAG;\r\nt->nout--;\r\naoecmd_work(d);\r\nxmit:\r\n__skb_queue_head_init(&queue);\r\nskb_queue_splice_init(&d->sendq, &queue);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\naoenet_xmit(&queue);\r\n}\r\nvoid\r\naoecmd_cfg(ushort aoemajor, unsigned char aoeminor)\r\n{\r\nstruct sk_buff_head queue;\r\n__skb_queue_head_init(&queue);\r\naoecmd_cfg_pkts(aoemajor, aoeminor, &queue);\r\naoenet_xmit(&queue);\r\n}\r\nstruct sk_buff *\r\naoecmd_ata_id(struct aoedev *d)\r\n{\r\nstruct aoe_hdr *h;\r\nstruct aoe_atahdr *ah;\r\nstruct frame *f;\r\nstruct sk_buff *skb;\r\nstruct aoetgt *t;\r\nf = freeframe(d);\r\nif (f == NULL)\r\nreturn NULL;\r\nt = *d->tgt;\r\nskb = f->skb;\r\nh = (struct aoe_hdr *) skb_mac_header(skb);\r\nah = (struct aoe_atahdr *) (h+1);\r\nskb_put(skb, sizeof *h + sizeof *ah);\r\nmemset(h, 0, skb->len);\r\nf->tag = aoehdr_atainit(d, t, h);\r\nt->nout++;\r\nf->waited = 0;\r\nah->scnt = 1;\r\nah->cmdstat = ATA_CMD_ID_ATA;\r\nah->lba3 = 0xa0;\r\nskb->dev = t->ifp->nd;\r\nd->rttavg = MAXTIMER;\r\nd->timer.function = rexmit_timer;\r\nreturn skb_clone(skb, GFP_ATOMIC);\r\n}\r\nstatic struct aoetgt *\r\naddtgt(struct aoedev *d, char *addr, ulong nframes)\r\n{\r\nstruct aoetgt *t, **tt, **te;\r\nstruct frame *f, *e;\r\ntt = d->targets;\r\nte = tt + NTARGETS;\r\nfor (; tt < te && *tt; tt++)\r\n;\r\nif (tt == te) {\r\nprintk(KERN_INFO\r\n"aoe: device addtgt failure; too many targets\n");\r\nreturn NULL;\r\n}\r\nt = kcalloc(1, sizeof *t, GFP_ATOMIC);\r\nf = kcalloc(nframes, sizeof *f, GFP_ATOMIC);\r\nif (!t || !f) {\r\nkfree(f);\r\nkfree(t);\r\nprintk(KERN_INFO "aoe: cannot allocate memory to add target\n");\r\nreturn NULL;\r\n}\r\nt->nframes = nframes;\r\nt->frames = f;\r\ne = f + nframes;\r\nfor (; f < e; f++)\r\nf->tag = FREETAG;\r\nmemcpy(t->addr, addr, sizeof t->addr);\r\nt->ifp = t->ifs;\r\nt->maxout = t->nframes;\r\nreturn *tt = t;\r\n}\r\nvoid\r\naoecmd_cfg_rsp(struct sk_buff *skb)\r\n{\r\nstruct aoedev *d;\r\nstruct aoe_hdr *h;\r\nstruct aoe_cfghdr *ch;\r\nstruct aoetgt *t;\r\nstruct aoeif *ifp;\r\nulong flags, sysminor, aoemajor;\r\nstruct sk_buff *sl;\r\nu16 n;\r\nh = (struct aoe_hdr *) skb_mac_header(skb);\r\nch = (struct aoe_cfghdr *) (h+1);\r\naoemajor = get_unaligned_be16(&h->major);\r\nif (aoemajor == 0xfff) {\r\nprintk(KERN_ERR "aoe: Warning: shelf address is all ones. "\r\n"Check shelf dip switches.\n");\r\nreturn;\r\n}\r\nsysminor = SYSMINOR(aoemajor, h->minor);\r\nif (sysminor * AOE_PARTITIONS + AOE_PARTITIONS > MINORMASK) {\r\nprintk(KERN_INFO "aoe: e%ld.%d: minor number too large\n",\r\naoemajor, (int) h->minor);\r\nreturn;\r\n}\r\nn = be16_to_cpu(ch->bufcnt);\r\nif (n > aoe_maxout)\r\nn = aoe_maxout;\r\nd = aoedev_by_sysminor_m(sysminor);\r\nif (d == NULL) {\r\nprintk(KERN_INFO "aoe: device sysminor_m failure\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&d->lock, flags);\r\nt = gettgt(d, h->src);\r\nif (!t) {\r\nt = addtgt(d, h->src, n);\r\nif (!t) {\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\n}\r\nifp = getif(t, skb->dev);\r\nif (!ifp) {\r\nifp = addif(t, skb->dev);\r\nif (!ifp) {\r\nprintk(KERN_INFO\r\n"aoe: device addif failure; "\r\n"too many interfaces?\n");\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\n}\r\nif (ifp->maxbcnt) {\r\nn = ifp->nd->mtu;\r\nn -= sizeof (struct aoe_hdr) + sizeof (struct aoe_atahdr);\r\nn /= 512;\r\nif (n > ch->scnt)\r\nn = ch->scnt;\r\nn = n ? n * 512 : DEFAULTBCNT;\r\nif (n != ifp->maxbcnt) {\r\nprintk(KERN_INFO\r\n"aoe: e%ld.%d: setting %d%s%s:%pm\n",\r\nd->aoemajor, d->aoeminor, n,\r\n" byte data frames on ", ifp->nd->name,\r\nt->addr);\r\nifp->maxbcnt = n;\r\n}\r\n}\r\nif (d->nopen) {\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\n}\r\nd->fw_ver = be16_to_cpu(ch->fwver);\r\nsl = aoecmd_ata_id(d);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nif (sl) {\r\nstruct sk_buff_head queue;\r\n__skb_queue_head_init(&queue);\r\n__skb_queue_tail(&queue, sl);\r\naoenet_xmit(&queue);\r\n}\r\n}\r\nvoid\r\naoecmd_cleanslate(struct aoedev *d)\r\n{\r\nstruct aoetgt **t, **te;\r\nstruct aoeif *p, *e;\r\nd->mintimer = MINTIMER;\r\nt = d->targets;\r\nte = t + NTARGETS;\r\nfor (; t < te && *t; t++) {\r\n(*t)->maxout = (*t)->nframes;\r\np = (*t)->ifs;\r\ne = p + NAOEIFS;\r\nfor (; p < e; p++) {\r\np->lostjumbo = 0;\r\np->lost = 0;\r\np->maxbcnt = DEFAULTBCNT;\r\n}\r\n}\r\n}
