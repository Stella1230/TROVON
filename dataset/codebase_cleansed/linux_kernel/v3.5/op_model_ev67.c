static void\r\nev67_reg_setup(struct op_register_config *reg,\r\nstruct op_counter_config *ctr,\r\nstruct op_system_config *sys)\r\n{\r\nunsigned long ctl, reset, need_reset, i;\r\nctl = 1UL << 4;\r\nif (ctr[1].enabled) {\r\nctl |= (ctr[1].event & 3) << 2;\r\n} else {\r\nif (ctr[0].event == 0)\r\nctl |= 1UL << 2;\r\n}\r\nreg->mux_select = ctl;\r\nreg->proc_mode = 0;\r\nreset = need_reset = 0;\r\nfor (i = 0; i < 2; ++i) {\r\nunsigned long count = ctr[i].count;\r\nif (!ctr[i].enabled)\r\ncontinue;\r\nif (count > 0x100000)\r\ncount = 0x100000;\r\nctr[i].count = count;\r\nreset |= (0x100000 - count) << (i ? 6 : 28);\r\nif (count != 0x100000)\r\nneed_reset |= 1 << i;\r\n}\r\nreg->reset_values = reset;\r\nreg->need_reset = need_reset;\r\n}\r\nstatic void\r\nev67_cpu_setup (void *x)\r\n{\r\nstruct op_register_config *reg = x;\r\nwrperfmon(2, reg->mux_select);\r\nwrperfmon(3, reg->proc_mode);\r\nwrperfmon(6, reg->reset_values | 3);\r\n}\r\nstatic void\r\nev67_reset_ctr(struct op_register_config *reg, unsigned long ctr)\r\n{\r\nwrperfmon(6, reg->reset_values | (1 << ctr));\r\n}\r\nstatic inline void\r\nop_add_pm(unsigned long pc, int kern, unsigned long counter,\r\nstruct op_counter_config *ctr, unsigned long event)\r\n{\r\nunsigned long fake_counter = 2 + event;\r\nif (counter == 1)\r\nfake_counter += PM_NUM_COUNTERS;\r\nif (ctr[fake_counter].enabled)\r\noprofile_add_pc(pc, kern, fake_counter);\r\n}\r\nstatic void\r\nev67_handle_interrupt(unsigned long which, struct pt_regs *regs,\r\nstruct op_counter_config *ctr)\r\n{\r\nunsigned long pmpc, pctr_ctl;\r\nint kern = !user_mode(regs);\r\nint mispredict = 0;\r\nunion {\r\nunsigned long v;\r\nstruct {\r\nunsigned reserved: 30;\r\nunsigned overcount: 3;\r\nunsigned icache_miss: 1;\r\nunsigned trap_type: 4;\r\nunsigned load_store: 1;\r\nunsigned trap: 1;\r\nunsigned mispredict: 1;\r\n} fields;\r\n} i_stat;\r\nenum trap_types {\r\nTRAP_REPLAY,\r\nTRAP_INVALID0,\r\nTRAP_DTB_DOUBLE_MISS_3,\r\nTRAP_DTB_DOUBLE_MISS_4,\r\nTRAP_FP_DISABLED,\r\nTRAP_UNALIGNED,\r\nTRAP_DTB_SINGLE_MISS,\r\nTRAP_DSTREAM_FAULT,\r\nTRAP_OPCDEC,\r\nTRAP_INVALID1,\r\nTRAP_MACHINE_CHECK,\r\nTRAP_INVALID2,\r\nTRAP_ARITHMETIC,\r\nTRAP_INVALID3,\r\nTRAP_MT_FPCR,\r\nTRAP_RESET\r\n};\r\npmpc = wrperfmon(9, 0);\r\nif (pmpc & 1)\r\nreturn;\r\npmpc &= ~2;\r\ni_stat.v = wrperfmon(8, 0);\r\nif (i_stat.fields.trap) {\r\nswitch (i_stat.fields.trap_type) {\r\ncase TRAP_INVALID1:\r\ncase TRAP_INVALID2:\r\ncase TRAP_INVALID3:\r\noprofile_add_pc(regs->pc, kern, which);\r\nif ((pmpc & ((1 << 15) - 1)) == 581)\r\nop_add_pm(regs->pc, kern, which,\r\nctr, PM_ITB_MISS);\r\nreturn;\r\ncase TRAP_REPLAY:\r\nop_add_pm(pmpc, kern, which, ctr,\r\n(i_stat.fields.load_store\r\n? PM_LOAD_STORE : PM_REPLAY));\r\nbreak;\r\ncase TRAP_DTB_DOUBLE_MISS_3:\r\ncase TRAP_DTB_DOUBLE_MISS_4:\r\ncase TRAP_DTB_SINGLE_MISS:\r\nop_add_pm(pmpc, kern, which, ctr, PM_DTB_MISS);\r\nbreak;\r\ncase TRAP_UNALIGNED:\r\nop_add_pm(pmpc, kern, which, ctr, PM_UNALIGNED);\r\nbreak;\r\ncase TRAP_INVALID0:\r\ncase TRAP_FP_DISABLED:\r\ncase TRAP_DSTREAM_FAULT:\r\ncase TRAP_OPCDEC:\r\ncase TRAP_MACHINE_CHECK:\r\ncase TRAP_ARITHMETIC:\r\ncase TRAP_MT_FPCR:\r\ncase TRAP_RESET:\r\nbreak;\r\n}\r\nif (i_stat.fields.mispredict) {\r\nmispredict = 1;\r\nop_add_pm(pmpc, kern, which, ctr, PM_MISPREDICT);\r\n}\r\n}\r\noprofile_add_pc(pmpc, kern, which);\r\npctr_ctl = wrperfmon(5, 0);\r\nif (pctr_ctl & (1UL << 27))\r\nop_add_pm(pmpc, kern, which, ctr, PM_STALLED);\r\nif (!mispredict && pctr_ctl & (1UL << 0))\r\nop_add_pm(pmpc, kern, which, ctr, PM_TAKEN);\r\n}
