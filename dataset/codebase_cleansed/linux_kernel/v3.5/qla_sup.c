static void\r\nqla2x00_lock_nvram_access(struct qla_hw_data *ha)\r\n{\r\nuint16_t data;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha)) {\r\ndata = RD_REG_WORD(&reg->nvram);\r\nwhile (data & NVR_BUSY) {\r\nudelay(100);\r\ndata = RD_REG_WORD(&reg->nvram);\r\n}\r\nWRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);\r\nRD_REG_WORD(&reg->u.isp2300.host_semaphore);\r\nudelay(5);\r\ndata = RD_REG_WORD(&reg->u.isp2300.host_semaphore);\r\nwhile ((data & BIT_0) == 0) {\r\nudelay(100);\r\nWRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0x1);\r\nRD_REG_WORD(&reg->u.isp2300.host_semaphore);\r\nudelay(5);\r\ndata = RD_REG_WORD(&reg->u.isp2300.host_semaphore);\r\n}\r\n}\r\n}\r\nstatic void\r\nqla2x00_unlock_nvram_access(struct qla_hw_data *ha)\r\n{\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha)) {\r\nWRT_REG_WORD(&reg->u.isp2300.host_semaphore, 0);\r\nRD_REG_WORD(&reg->u.isp2300.host_semaphore);\r\n}\r\n}\r\nstatic void\r\nqla2x00_nv_write(struct qla_hw_data *ha, uint16_t data)\r\n{\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nWRT_REG_WORD(&reg->nvram, data | NVR_SELECT | NVR_WRT_ENABLE);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\nWRT_REG_WORD(&reg->nvram, data | NVR_SELECT | NVR_CLOCK |\r\nNVR_WRT_ENABLE);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\nWRT_REG_WORD(&reg->nvram, data | NVR_SELECT | NVR_WRT_ENABLE);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\n}\r\nstatic uint16_t\r\nqla2x00_nvram_request(struct qla_hw_data *ha, uint32_t nv_cmd)\r\n{\r\nuint8_t cnt;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nuint16_t data = 0;\r\nuint16_t reg_data;\r\nnv_cmd <<= 5;\r\nfor (cnt = 0; cnt < 11; cnt++) {\r\nif (nv_cmd & BIT_31)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nelse\r\nqla2x00_nv_write(ha, 0);\r\nnv_cmd <<= 1;\r\n}\r\nfor (cnt = 0; cnt < 16; cnt++) {\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT | NVR_CLOCK);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\ndata <<= 1;\r\nreg_data = RD_REG_WORD(&reg->nvram);\r\nif (reg_data & NVR_DATA_IN)\r\ndata |= BIT_0;\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\n}\r\nWRT_REG_WORD(&reg->nvram, NVR_DESELECT);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\nreturn data;\r\n}\r\nstatic uint16_t\r\nqla2x00_get_nvram_word(struct qla_hw_data *ha, uint32_t addr)\r\n{\r\nuint16_t data;\r\nuint32_t nv_cmd;\r\nnv_cmd = addr << 16;\r\nnv_cmd |= NV_READ_OP;\r\ndata = qla2x00_nvram_request(ha, nv_cmd);\r\nreturn (data);\r\n}\r\nstatic void\r\nqla2x00_nv_deselect(struct qla_hw_data *ha)\r\n{\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nWRT_REG_WORD(&reg->nvram, NVR_DESELECT);\r\nRD_REG_WORD(&reg->nvram);\r\nNVRAM_DELAY();\r\n}\r\nstatic void\r\nqla2x00_write_nvram_word(struct qla_hw_data *ha, uint32_t addr, uint16_t data)\r\n{\r\nint count;\r\nuint16_t word;\r\nuint32_t nv_cmd, wait_cnt;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, 0);\r\nqla2x00_nv_write(ha, 0);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_deselect(ha);\r\nnv_cmd = (addr << 16) | NV_WRITE_OP;\r\nnv_cmd |= data;\r\nnv_cmd <<= 5;\r\nfor (count = 0; count < 27; count++) {\r\nif (nv_cmd & BIT_31)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nelse\r\nqla2x00_nv_write(ha, 0);\r\nnv_cmd <<= 1;\r\n}\r\nqla2x00_nv_deselect(ha);\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\nwait_cnt = NVR_WAIT_CNT;\r\ndo {\r\nif (!--wait_cnt) {\r\nql_dbg(ql_dbg_user, vha, 0x708d,\r\n"NVRAM didn't go ready...\n");\r\nbreak;\r\n}\r\nNVRAM_DELAY();\r\nword = RD_REG_WORD(&reg->nvram);\r\n} while ((word & NVR_DATA_IN) == 0);\r\nqla2x00_nv_deselect(ha);\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nfor (count = 0; count < 10; count++)\r\nqla2x00_nv_write(ha, 0);\r\nqla2x00_nv_deselect(ha);\r\n}\r\nstatic int\r\nqla2x00_write_nvram_word_tmo(struct qla_hw_data *ha, uint32_t addr,\r\nuint16_t data, uint32_t tmo)\r\n{\r\nint ret, count;\r\nuint16_t word;\r\nuint32_t nv_cmd;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nret = QLA_SUCCESS;\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, 0);\r\nqla2x00_nv_write(ha, 0);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_deselect(ha);\r\nnv_cmd = (addr << 16) | NV_WRITE_OP;\r\nnv_cmd |= data;\r\nnv_cmd <<= 5;\r\nfor (count = 0; count < 27; count++) {\r\nif (nv_cmd & BIT_31)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nelse\r\nqla2x00_nv_write(ha, 0);\r\nnv_cmd <<= 1;\r\n}\r\nqla2x00_nv_deselect(ha);\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\ndo {\r\nNVRAM_DELAY();\r\nword = RD_REG_WORD(&reg->nvram);\r\nif (!--tmo) {\r\nret = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\n} while ((word & NVR_DATA_IN) == 0);\r\nqla2x00_nv_deselect(ha);\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nfor (count = 0; count < 10; count++)\r\nqla2x00_nv_write(ha, 0);\r\nqla2x00_nv_deselect(ha);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla2x00_clear_nvram_protection(struct qla_hw_data *ha)\r\n{\r\nint ret, stat;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nuint32_t word, wait_cnt;\r\nuint16_t wprot, wprot_old;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nret = QLA_FUNCTION_FAILED;\r\nwprot_old = cpu_to_le16(qla2x00_get_nvram_word(ha, ha->nvram_base));\r\nstat = qla2x00_write_nvram_word_tmo(ha, ha->nvram_base,\r\n__constant_cpu_to_le16(0x1234), 100000);\r\nwprot = cpu_to_le16(qla2x00_get_nvram_word(ha, ha->nvram_base));\r\nif (stat != QLA_SUCCESS || wprot != 0x1234) {\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, 0);\r\nqla2x00_nv_write(ha, 0);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_deselect(ha);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT | NVR_PR_ENABLE);\r\nqla2x00_nv_deselect(ha);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT | NVR_PR_ENABLE);\r\nqla2x00_nv_deselect(ha);\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\nwait_cnt = NVR_WAIT_CNT;\r\ndo {\r\nif (!--wait_cnt) {\r\nql_dbg(ql_dbg_user, vha, 0x708e,\r\n"NVRAM didn't go ready...\n");\r\nbreak;\r\n}\r\nNVRAM_DELAY();\r\nword = RD_REG_WORD(&reg->nvram);\r\n} while ((word & NVR_DATA_IN) == 0);\r\nif (wait_cnt)\r\nret = QLA_SUCCESS;\r\n} else\r\nqla2x00_write_nvram_word(ha, ha->nvram_base, wprot_old);\r\nreturn ret;\r\n}\r\nstatic void\r\nqla2x00_set_nvram_protection(struct qla_hw_data *ha, int stat)\r\n{\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nuint32_t word, wait_cnt;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nif (stat != QLA_SUCCESS)\r\nreturn;\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, 0);\r\nqla2x00_nv_write(ha, 0);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT);\r\nqla2x00_nv_deselect(ha);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_DATA_OUT | NVR_PR_ENABLE);\r\nqla2x00_nv_deselect(ha);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE);\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\r\nfor (word = 0; word < 8; word++)\r\nqla2x00_nv_write(ha, NVR_PR_ENABLE);\r\nqla2x00_nv_deselect(ha);\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\nwait_cnt = NVR_WAIT_CNT;\r\ndo {\r\nif (!--wait_cnt) {\r\nql_dbg(ql_dbg_user, vha, 0x708f,\r\n"NVRAM didn't go ready...\n");\r\nbreak;\r\n}\r\nNVRAM_DELAY();\r\nword = RD_REG_WORD(&reg->nvram);\r\n} while ((word & NVR_DATA_IN) == 0);\r\n}\r\nstatic inline uint32_t\r\nflash_conf_addr(struct qla_hw_data *ha, uint32_t faddr)\r\n{\r\nreturn ha->flash_conf_off | faddr;\r\n}\r\nstatic inline uint32_t\r\nflash_data_addr(struct qla_hw_data *ha, uint32_t faddr)\r\n{\r\nreturn ha->flash_data_off | faddr;\r\n}\r\nstatic inline uint32_t\r\nnvram_conf_addr(struct qla_hw_data *ha, uint32_t naddr)\r\n{\r\nreturn ha->nvram_conf_off | naddr;\r\n}\r\nstatic inline uint32_t\r\nnvram_data_addr(struct qla_hw_data *ha, uint32_t naddr)\r\n{\r\nreturn ha->nvram_data_off | naddr;\r\n}\r\nstatic uint32_t\r\nqla24xx_read_flash_dword(struct qla_hw_data *ha, uint32_t addr)\r\n{\r\nint rval;\r\nuint32_t cnt, data;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nWRT_REG_DWORD(&reg->flash_addr, addr & ~FARX_DATA_FLAG);\r\nrval = QLA_SUCCESS;\r\nfor (cnt = 3000;\r\n(RD_REG_DWORD(&reg->flash_addr) & FARX_DATA_FLAG) == 0 &&\r\nrval == QLA_SUCCESS; cnt--) {\r\nif (cnt)\r\nudelay(10);\r\nelse\r\nrval = QLA_FUNCTION_TIMEOUT;\r\ncond_resched();\r\n}\r\ndata = 0xDEADDEAD;\r\nif (rval == QLA_SUCCESS)\r\ndata = RD_REG_DWORD(&reg->flash_data);\r\nreturn data;\r\n}\r\nuint32_t *\r\nqla24xx_read_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,\r\nuint32_t dwords)\r\n{\r\nuint32_t i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nfor (i = 0; i < dwords; i++, faddr++)\r\ndwptr[i] = cpu_to_le32(qla24xx_read_flash_dword(ha,\r\nflash_data_addr(ha, faddr)));\r\nreturn dwptr;\r\n}\r\nstatic int\r\nqla24xx_write_flash_dword(struct qla_hw_data *ha, uint32_t addr, uint32_t data)\r\n{\r\nint rval;\r\nuint32_t cnt;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nWRT_REG_DWORD(&reg->flash_data, data);\r\nRD_REG_DWORD(&reg->flash_data);\r\nWRT_REG_DWORD(&reg->flash_addr, addr | FARX_DATA_FLAG);\r\nrval = QLA_SUCCESS;\r\nfor (cnt = 500000; (RD_REG_DWORD(&reg->flash_addr) & FARX_DATA_FLAG) &&\r\nrval == QLA_SUCCESS; cnt--) {\r\nif (cnt)\r\nudelay(10);\r\nelse\r\nrval = QLA_FUNCTION_TIMEOUT;\r\ncond_resched();\r\n}\r\nreturn rval;\r\n}\r\nstatic void\r\nqla24xx_get_flash_manufacturer(struct qla_hw_data *ha, uint8_t *man_id,\r\nuint8_t *flash_id)\r\n{\r\nuint32_t ids;\r\nids = qla24xx_read_flash_dword(ha, flash_conf_addr(ha, 0x03ab));\r\n*man_id = LSB(ids);\r\n*flash_id = MSB(ids);\r\nif (ids != 0xDEADDEAD && (*man_id == 0 || *flash_id == 0)) {\r\nids = qla24xx_read_flash_dword(ha, flash_conf_addr(ha, 0x009f));\r\n*man_id = LSB(ids);\r\n*flash_id = MSB(ids);\r\n}\r\n}\r\nstatic int\r\nqla2xxx_find_flt_start(scsi_qla_host_t *vha, uint32_t *start)\r\n{\r\nconst char *loc, *locations[] = { "DEF", "PCI" };\r\nuint32_t pcihdr, pcids;\r\nuint32_t *dcode;\r\nuint8_t *buf, *bcode, last_image;\r\nuint16_t cnt, chksum, *wptr;\r\nstruct qla_flt_location *fltl;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nloc = locations[0];\r\n*start = 0;\r\nif (IS_QLA24XX_TYPE(ha))\r\n*start = FA_FLASH_LAYOUT_ADDR_24;\r\nelse if (IS_QLA25XX(ha))\r\n*start = FA_FLASH_LAYOUT_ADDR;\r\nelse if (IS_QLA81XX(ha))\r\n*start = FA_FLASH_LAYOUT_ADDR_81;\r\nelse if (IS_QLA82XX(ha)) {\r\n*start = FA_FLASH_LAYOUT_ADDR_82;\r\ngoto end;\r\n} else if (IS_QLA83XX(ha)) {\r\n*start = FA_FLASH_LAYOUT_ADDR_83;\r\ngoto end;\r\n}\r\nbuf = (uint8_t *)req->ring;\r\ndcode = (uint32_t *)req->ring;\r\npcihdr = 0;\r\nlast_image = 1;\r\ndo {\r\nqla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 0x20);\r\nbcode = buf + (pcihdr % 4);\r\nif (bcode[0x0] != 0x55 || bcode[0x1] != 0xaa)\r\ngoto end;\r\npcids = pcihdr + ((bcode[0x19] << 8) | bcode[0x18]);\r\nqla24xx_read_flash_data(vha, dcode, pcids >> 2, 0x20);\r\nbcode = buf + (pcihdr % 4);\r\nif (bcode[0x0] != 'P' || bcode[0x1] != 'C' ||\r\nbcode[0x2] != 'I' || bcode[0x3] != 'R')\r\ngoto end;\r\nlast_image = bcode[0x15] & BIT_7;\r\npcihdr += ((bcode[0x11] << 8) | bcode[0x10]) * 512;\r\n} while (!last_image);\r\nfltl = (struct qla_flt_location *)req->ring;\r\nqla24xx_read_flash_data(vha, dcode, pcihdr >> 2,\r\nsizeof(struct qla_flt_location) >> 2);\r\nif (fltl->sig[0] != 'Q' || fltl->sig[1] != 'F' ||\r\nfltl->sig[2] != 'L' || fltl->sig[3] != 'T')\r\ngoto end;\r\nwptr = (uint16_t *)req->ring;\r\ncnt = sizeof(struct qla_flt_location) >> 1;\r\nfor (chksum = 0; cnt; cnt--)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nql_log(ql_log_fatal, vha, 0x0045,\r\n"Inconsistent FLTL detected: checksum=0x%x.\n", chksum);\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010e,\r\nbuf, sizeof(struct qla_flt_location));\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nloc = locations[1];\r\n*start = (le16_to_cpu(fltl->start_hi) << 16 |\r\nle16_to_cpu(fltl->start_lo)) >> 2;\r\nend:\r\nql_dbg(ql_dbg_init, vha, 0x0046,\r\n"FLTL[%s] = 0x%x.\n",\r\nloc, *start);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla2xxx_get_flt_info(scsi_qla_host_t *vha, uint32_t flt_addr)\r\n{\r\nconst char *loc, *locations[] = { "DEF", "FLT" };\r\nconst uint32_t def_fw[] =\r\n{ FA_RISC_CODE_ADDR, FA_RISC_CODE_ADDR, FA_RISC_CODE_ADDR_81 };\r\nconst uint32_t def_boot[] =\r\n{ FA_BOOT_CODE_ADDR, FA_BOOT_CODE_ADDR, FA_BOOT_CODE_ADDR_81 };\r\nconst uint32_t def_vpd_nvram[] =\r\n{ FA_VPD_NVRAM_ADDR, FA_VPD_NVRAM_ADDR, FA_VPD_NVRAM_ADDR_81 };\r\nconst uint32_t def_vpd0[] =\r\n{ 0, 0, FA_VPD0_ADDR_81 };\r\nconst uint32_t def_vpd1[] =\r\n{ 0, 0, FA_VPD1_ADDR_81 };\r\nconst uint32_t def_nvram0[] =\r\n{ 0, 0, FA_NVRAM0_ADDR_81 };\r\nconst uint32_t def_nvram1[] =\r\n{ 0, 0, FA_NVRAM1_ADDR_81 };\r\nconst uint32_t def_fdt[] =\r\n{ FA_FLASH_DESCR_ADDR_24, FA_FLASH_DESCR_ADDR,\r\nFA_FLASH_DESCR_ADDR_81 };\r\nconst uint32_t def_npiv_conf0[] =\r\n{ FA_NPIV_CONF0_ADDR_24, FA_NPIV_CONF0_ADDR,\r\nFA_NPIV_CONF0_ADDR_81 };\r\nconst uint32_t def_npiv_conf1[] =\r\n{ FA_NPIV_CONF1_ADDR_24, FA_NPIV_CONF1_ADDR,\r\nFA_NPIV_CONF1_ADDR_81 };\r\nconst uint32_t fcp_prio_cfg0[] =\r\n{ FA_FCP_PRIO0_ADDR, FA_FCP_PRIO0_ADDR_25,\r\n0 };\r\nconst uint32_t fcp_prio_cfg1[] =\r\n{ FA_FCP_PRIO1_ADDR, FA_FCP_PRIO1_ADDR_25,\r\n0 };\r\nuint32_t def;\r\nuint16_t *wptr;\r\nuint16_t cnt, chksum;\r\nuint32_t start;\r\nstruct qla_flt_header *flt;\r\nstruct qla_flt_region *region;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\ndef = 0;\r\nif (IS_QLA25XX(ha))\r\ndef = 1;\r\nelse if (IS_QLA81XX(ha))\r\ndef = 2;\r\nha->flt_region_fcp_prio = ha->flags.port0 ?\r\nfcp_prio_cfg0[def] : fcp_prio_cfg1[def];\r\nha->flt_region_flt = flt_addr;\r\nwptr = (uint16_t *)req->ring;\r\nflt = (struct qla_flt_header *)req->ring;\r\nregion = (struct qla_flt_region *)&flt[1];\r\nha->isp_ops->read_optrom(vha, (uint8_t *)req->ring,\r\nflt_addr << 2, OPTROM_BURST_SIZE);\r\nif (*wptr == __constant_cpu_to_le16(0xffff))\r\ngoto no_flash_data;\r\nif (flt->version != __constant_cpu_to_le16(1)) {\r\nql_log(ql_log_warn, vha, 0x0047,\r\n"Unsupported FLT detected: version=0x%x length=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(flt->version), le16_to_cpu(flt->length),\r\nle16_to_cpu(flt->checksum));\r\ngoto no_flash_data;\r\n}\r\ncnt = (sizeof(struct qla_flt_header) + le16_to_cpu(flt->length)) >> 1;\r\nfor (chksum = 0; cnt; cnt--)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nql_log(ql_log_fatal, vha, 0x0048,\r\n"Inconsistent FLT detected: version=0x%x length=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(flt->version), le16_to_cpu(flt->length),\r\nle16_to_cpu(flt->checksum));\r\ngoto no_flash_data;\r\n}\r\nloc = locations[1];\r\ncnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);\r\nfor ( ; cnt; cnt--, region++) {\r\nstart = le32_to_cpu(region->start) >> 2;\r\nql_dbg(ql_dbg_init, vha, 0x0049,\r\n"FLT[%02x]: start=0x%x "\r\n"end=0x%x size=0x%x.\n", le32_to_cpu(region->code),\r\nstart, le32_to_cpu(region->end) >> 2,\r\nle32_to_cpu(region->size));\r\nswitch (le32_to_cpu(region->code) & 0xff) {\r\ncase FLT_REG_FCOE_FW:\r\nif (!IS_QLA8031(ha))\r\nbreak;\r\nha->flt_region_fw = start;\r\nbreak;\r\ncase FLT_REG_FW:\r\nif (IS_QLA8031(ha))\r\nbreak;\r\nha->flt_region_fw = start;\r\nbreak;\r\ncase FLT_REG_BOOT_CODE:\r\nha->flt_region_boot = start;\r\nbreak;\r\ncase FLT_REG_VPD_0:\r\nif (IS_QLA8031(ha))\r\nbreak;\r\nha->flt_region_vpd_nvram = start;\r\nif (IS_QLA82XX(ha))\r\nbreak;\r\nif (ha->flags.port0)\r\nha->flt_region_vpd = start;\r\nbreak;\r\ncase FLT_REG_VPD_1:\r\nif (IS_QLA82XX(ha) || IS_QLA8031(ha))\r\nbreak;\r\nif (!ha->flags.port0)\r\nha->flt_region_vpd = start;\r\nbreak;\r\ncase FLT_REG_NVRAM_0:\r\nif (IS_QLA8031(ha))\r\nbreak;\r\nif (ha->flags.port0)\r\nha->flt_region_nvram = start;\r\nbreak;\r\ncase FLT_REG_NVRAM_1:\r\nif (IS_QLA8031(ha))\r\nbreak;\r\nif (!ha->flags.port0)\r\nha->flt_region_nvram = start;\r\nbreak;\r\ncase FLT_REG_FDT:\r\nha->flt_region_fdt = start;\r\nbreak;\r\ncase FLT_REG_NPIV_CONF_0:\r\nif (ha->flags.port0)\r\nha->flt_region_npiv_conf = start;\r\nbreak;\r\ncase FLT_REG_NPIV_CONF_1:\r\nif (!ha->flags.port0)\r\nha->flt_region_npiv_conf = start;\r\nbreak;\r\ncase FLT_REG_GOLD_FW:\r\nha->flt_region_gold_fw = start;\r\nbreak;\r\ncase FLT_REG_FCP_PRIO_0:\r\nif (ha->flags.port0)\r\nha->flt_region_fcp_prio = start;\r\nbreak;\r\ncase FLT_REG_FCP_PRIO_1:\r\nif (!ha->flags.port0)\r\nha->flt_region_fcp_prio = start;\r\nbreak;\r\ncase FLT_REG_BOOT_CODE_82XX:\r\nha->flt_region_boot = start;\r\nbreak;\r\ncase FLT_REG_FW_82XX:\r\nha->flt_region_fw = start;\r\nbreak;\r\ncase FLT_REG_GOLD_FW_82XX:\r\nha->flt_region_gold_fw = start;\r\nbreak;\r\ncase FLT_REG_BOOTLOAD_82XX:\r\nha->flt_region_bootload = start;\r\nbreak;\r\ncase FLT_REG_VPD_82XX:\r\nha->flt_region_vpd = start;\r\nbreak;\r\ncase FLT_REG_FCOE_VPD_0:\r\nif (!IS_QLA8031(ha))\r\nbreak;\r\nha->flt_region_vpd_nvram = start;\r\nif (ha->flags.port0)\r\nha->flt_region_vpd = start;\r\nbreak;\r\ncase FLT_REG_FCOE_VPD_1:\r\nif (!IS_QLA8031(ha))\r\nbreak;\r\nif (!ha->flags.port0)\r\nha->flt_region_vpd = start;\r\nbreak;\r\ncase FLT_REG_FCOE_NVRAM_0:\r\nif (!IS_QLA8031(ha))\r\nbreak;\r\nif (ha->flags.port0)\r\nha->flt_region_nvram = start;\r\nbreak;\r\ncase FLT_REG_FCOE_NVRAM_1:\r\nif (!IS_QLA8031(ha))\r\nbreak;\r\nif (!ha->flags.port0)\r\nha->flt_region_nvram = start;\r\nbreak;\r\n}\r\n}\r\ngoto done;\r\nno_flash_data:\r\nloc = locations[0];\r\nha->flt_region_fw = def_fw[def];\r\nha->flt_region_boot = def_boot[def];\r\nha->flt_region_vpd_nvram = def_vpd_nvram[def];\r\nha->flt_region_vpd = ha->flags.port0 ?\r\ndef_vpd0[def] : def_vpd1[def];\r\nha->flt_region_nvram = ha->flags.port0 ?\r\ndef_nvram0[def] : def_nvram1[def];\r\nha->flt_region_fdt = def_fdt[def];\r\nha->flt_region_npiv_conf = ha->flags.port0 ?\r\ndef_npiv_conf0[def] : def_npiv_conf1[def];\r\ndone:\r\nql_dbg(ql_dbg_init, vha, 0x004a,\r\n"FLT[%s]: boot=0x%x fw=0x%x vpd_nvram=0x%x vpd=0x%x nvram=0x%x "\r\n"fdt=0x%x flt=0x%x npiv=0x%x fcp_prif_cfg=0x%x.\n",\r\nloc, ha->flt_region_boot, ha->flt_region_fw,\r\nha->flt_region_vpd_nvram, ha->flt_region_vpd, ha->flt_region_nvram,\r\nha->flt_region_fdt, ha->flt_region_flt, ha->flt_region_npiv_conf,\r\nha->flt_region_fcp_prio);\r\n}\r\nstatic void\r\nqla2xxx_get_fdt_info(scsi_qla_host_t *vha)\r\n{\r\n#define FLASH_BLK_SIZE_4K 0x1000\r\n#define FLASH_BLK_SIZE_32K 0x8000\r\n#define FLASH_BLK_SIZE_64K 0x10000\r\nconst char *loc, *locations[] = { "MID", "FDT" };\r\nuint16_t cnt, chksum;\r\nuint16_t *wptr;\r\nstruct qla_fdt_layout *fdt;\r\nuint8_t man_id, flash_id;\r\nuint16_t mid = 0, fid = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nwptr = (uint16_t *)req->ring;\r\nfdt = (struct qla_fdt_layout *)req->ring;\r\nha->isp_ops->read_optrom(vha, (uint8_t *)req->ring,\r\nha->flt_region_fdt << 2, OPTROM_BURST_SIZE);\r\nif (*wptr == __constant_cpu_to_le16(0xffff))\r\ngoto no_flash_data;\r\nif (fdt->sig[0] != 'Q' || fdt->sig[1] != 'L' || fdt->sig[2] != 'I' ||\r\nfdt->sig[3] != 'D')\r\ngoto no_flash_data;\r\nfor (cnt = 0, chksum = 0; cnt < sizeof(struct qla_fdt_layout) >> 1;\r\ncnt++)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nql_dbg(ql_dbg_init, vha, 0x004c,\r\n"Inconsistent FDT detected:"\r\n" checksum=0x%x id=%c version0x%x.\n", chksum,\r\nfdt->sig[0], le16_to_cpu(fdt->version));\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0113,\r\n(uint8_t *)fdt, sizeof(*fdt));\r\ngoto no_flash_data;\r\n}\r\nloc = locations[1];\r\nmid = le16_to_cpu(fdt->man_id);\r\nfid = le16_to_cpu(fdt->id);\r\nha->fdt_wrt_disable = fdt->wrt_disable_bits;\r\nha->fdt_erase_cmd = flash_conf_addr(ha, 0x0300 | fdt->erase_cmd);\r\nha->fdt_block_size = le32_to_cpu(fdt->block_size);\r\nif (fdt->unprotect_sec_cmd) {\r\nha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, 0x0300 |\r\nfdt->unprotect_sec_cmd);\r\nha->fdt_protect_sec_cmd = fdt->protect_sec_cmd ?\r\nflash_conf_addr(ha, 0x0300 | fdt->protect_sec_cmd):\r\nflash_conf_addr(ha, 0x0336);\r\n}\r\ngoto done;\r\nno_flash_data:\r\nloc = locations[0];\r\nif (IS_QLA82XX(ha)) {\r\nha->fdt_block_size = FLASH_BLK_SIZE_64K;\r\ngoto done;\r\n}\r\nqla24xx_get_flash_manufacturer(ha, &man_id, &flash_id);\r\nmid = man_id;\r\nfid = flash_id;\r\nha->fdt_wrt_disable = 0x9c;\r\nha->fdt_erase_cmd = flash_conf_addr(ha, 0x03d8);\r\nswitch (man_id) {\r\ncase 0xbf:\r\nif (flash_id == 0x8e)\r\nha->fdt_block_size = FLASH_BLK_SIZE_64K;\r\nelse\r\nha->fdt_block_size = FLASH_BLK_SIZE_32K;\r\nif (flash_id == 0x80)\r\nha->fdt_erase_cmd = flash_conf_addr(ha, 0x0352);\r\nbreak;\r\ncase 0x13:\r\nha->fdt_block_size = FLASH_BLK_SIZE_64K;\r\nbreak;\r\ncase 0x1f:\r\nha->fdt_block_size = FLASH_BLK_SIZE_4K;\r\nha->fdt_erase_cmd = flash_conf_addr(ha, 0x0320);\r\nha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, 0x0339);\r\nha->fdt_protect_sec_cmd = flash_conf_addr(ha, 0x0336);\r\nbreak;\r\ndefault:\r\nha->fdt_block_size = FLASH_BLK_SIZE_64K;\r\nbreak;\r\n}\r\ndone:\r\nql_dbg(ql_dbg_init, vha, 0x004d,\r\n"FDT[%s]: (0x%x/0x%x) erase=0x%x "\r\n"pr=%x wrtd=0x%x blk=0x%x.\n",\r\nloc, mid, fid,\r\nha->fdt_erase_cmd, ha->fdt_protect_sec_cmd,\r\nha->fdt_wrt_disable, ha->fdt_block_size);\r\n}\r\nstatic void\r\nqla2xxx_get_idc_param(scsi_qla_host_t *vha)\r\n{\r\n#define QLA82XX_IDC_PARAM_ADDR 0x003e885c\r\nuint32_t *wptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nif (!IS_QLA82XX(ha))\r\nreturn;\r\nwptr = (uint32_t *)req->ring;\r\nha->isp_ops->read_optrom(vha, (uint8_t *)req->ring,\r\nQLA82XX_IDC_PARAM_ADDR , 8);\r\nif (*wptr == __constant_cpu_to_le32(0xffffffff)) {\r\nha->nx_dev_init_timeout = QLA82XX_ROM_DEV_INIT_TIMEOUT;\r\nha->nx_reset_timeout = QLA82XX_ROM_DRV_RESET_ACK_TIMEOUT;\r\n} else {\r\nha->nx_dev_init_timeout = le32_to_cpu(*wptr++);\r\nha->nx_reset_timeout = le32_to_cpu(*wptr);\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x004e,\r\n"nx_dev_init_timeout=%d "\r\n"nx_reset_timeout=%d.\n", ha->nx_dev_init_timeout,\r\nha->nx_reset_timeout);\r\nreturn;\r\n}\r\nint\r\nqla2xxx_get_flash_info(scsi_qla_host_t *vha)\r\n{\r\nint ret;\r\nuint32_t flt_addr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\r\n!IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha))\r\nreturn QLA_SUCCESS;\r\nret = qla2xxx_find_flt_start(vha, &flt_addr);\r\nif (ret != QLA_SUCCESS)\r\nreturn ret;\r\nqla2xxx_get_flt_info(vha, flt_addr);\r\nqla2xxx_get_fdt_info(vha);\r\nqla2xxx_get_idc_param(vha);\r\nreturn QLA_SUCCESS;\r\n}\r\nvoid\r\nqla2xxx_flash_npiv_conf(scsi_qla_host_t *vha)\r\n{\r\n#define NPIV_CONFIG_SIZE (16*1024)\r\nvoid *data;\r\nuint16_t *wptr;\r\nuint16_t cnt, chksum;\r\nint i;\r\nstruct qla_npiv_header hdr;\r\nstruct qla_npiv_entry *entry;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\r\n!IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha))\r\nreturn;\r\nif (ha->flags.isp82xx_reset_hdlr_active)\r\nreturn;\r\nha->isp_ops->read_optrom(vha, (uint8_t *)&hdr,\r\nha->flt_region_npiv_conf << 2, sizeof(struct qla_npiv_header));\r\nif (hdr.version == __constant_cpu_to_le16(0xffff))\r\nreturn;\r\nif (hdr.version != __constant_cpu_to_le16(1)) {\r\nql_dbg(ql_dbg_user, vha, 0x7090,\r\n"Unsupported NPIV-Config "\r\n"detected: version=0x%x entries=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(hdr.version), le16_to_cpu(hdr.entries),\r\nle16_to_cpu(hdr.checksum));\r\nreturn;\r\n}\r\ndata = kmalloc(NPIV_CONFIG_SIZE, GFP_KERNEL);\r\nif (!data) {\r\nql_log(ql_log_warn, vha, 0x7091,\r\n"Unable to allocate memory for data.\n");\r\nreturn;\r\n}\r\nha->isp_ops->read_optrom(vha, (uint8_t *)data,\r\nha->flt_region_npiv_conf << 2, NPIV_CONFIG_SIZE);\r\ncnt = (sizeof(struct qla_npiv_header) + le16_to_cpu(hdr.entries) *\r\nsizeof(struct qla_npiv_entry)) >> 1;\r\nfor (wptr = data, chksum = 0; cnt; cnt--)\r\nchksum += le16_to_cpu(*wptr++);\r\nif (chksum) {\r\nql_dbg(ql_dbg_user, vha, 0x7092,\r\n"Inconsistent NPIV-Config "\r\n"detected: version=0x%x entries=0x%x checksum=0x%x.\n",\r\nle16_to_cpu(hdr.version), le16_to_cpu(hdr.entries),\r\nle16_to_cpu(hdr.checksum));\r\ngoto done;\r\n}\r\nentry = data + sizeof(struct qla_npiv_header);\r\ncnt = le16_to_cpu(hdr.entries);\r\nfor (i = 0; cnt; cnt--, entry++, i++) {\r\nuint16_t flags;\r\nstruct fc_vport_identifiers vid;\r\nstruct fc_vport *vport;\r\nmemcpy(&ha->npiv_info[i], entry, sizeof(struct qla_npiv_entry));\r\nflags = le16_to_cpu(entry->flags);\r\nif (flags == 0xffff)\r\ncontinue;\r\nif ((flags & BIT_0) == 0)\r\ncontinue;\r\nmemset(&vid, 0, sizeof(vid));\r\nvid.roles = FC_PORT_ROLE_FCP_INITIATOR;\r\nvid.vport_type = FC_PORTTYPE_NPIV;\r\nvid.disable = false;\r\nvid.port_name = wwn_to_u64(entry->port_name);\r\nvid.node_name = wwn_to_u64(entry->node_name);\r\nql_dbg(ql_dbg_user, vha, 0x7093,\r\n"NPIV[%02x]: wwpn=%llx "\r\n"wwnn=%llx vf_id=0x%x Q_qos=0x%x F_qos=0x%x.\n", cnt,\r\n(unsigned long long)vid.port_name,\r\n(unsigned long long)vid.node_name,\r\nle16_to_cpu(entry->vf_id),\r\nentry->q_qos, entry->f_qos);\r\nif (i < QLA_PRECONFIG_VPORTS) {\r\nvport = fc_vport_create(vha->host, 0, &vid);\r\nif (!vport)\r\nql_log(ql_log_warn, vha, 0x7094,\r\n"NPIV-Config Failed to create vport [%02x]: "\r\n"wwpn=%llx wwnn=%llx.\n", cnt,\r\n(unsigned long long)vid.port_name,\r\n(unsigned long long)vid.node_name);\r\n}\r\n}\r\ndone:\r\nkfree(data);\r\n}\r\nstatic int\r\nqla24xx_unprotect_flash(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nif (ha->flags.fac_supported)\r\nreturn qla81xx_fac_do_write_enable(vha, 1);\r\nWRT_REG_DWORD(&reg->ctrl_status,\r\nRD_REG_DWORD(&reg->ctrl_status) | CSRX_FLASH_ENABLE);\r\nRD_REG_DWORD(&reg->ctrl_status);\r\nif (!ha->fdt_wrt_disable)\r\ngoto done;\r\nqla24xx_write_flash_dword(ha, flash_conf_addr(ha, 0x101), 0);\r\nqla24xx_write_flash_dword(ha, flash_conf_addr(ha, 0x101), 0);\r\ndone:\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int\r\nqla24xx_protect_flash(scsi_qla_host_t *vha)\r\n{\r\nuint32_t cnt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nif (ha->flags.fac_supported)\r\nreturn qla81xx_fac_do_write_enable(vha, 0);\r\nif (!ha->fdt_wrt_disable)\r\ngoto skip_wrt_protect;\r\nqla24xx_write_flash_dword(ha, flash_conf_addr(ha, 0x101),\r\nha->fdt_wrt_disable);\r\nfor (cnt = 300; cnt &&\r\nqla24xx_read_flash_dword(ha, flash_conf_addr(ha, 0x005)) & BIT_0;\r\ncnt--) {\r\nudelay(10);\r\n}\r\nskip_wrt_protect:\r\nWRT_REG_DWORD(&reg->ctrl_status,\r\nRD_REG_DWORD(&reg->ctrl_status) & ~CSRX_FLASH_ENABLE);\r\nRD_REG_DWORD(&reg->ctrl_status);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int\r\nqla24xx_erase_sector(scsi_qla_host_t *vha, uint32_t fdata)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t start, finish;\r\nif (ha->flags.fac_supported) {\r\nstart = fdata >> 2;\r\nfinish = start + (ha->fdt_block_size >> 2) - 1;\r\nreturn qla81xx_fac_erase_sector(vha, flash_data_addr(ha,\r\nstart), flash_data_addr(ha, finish));\r\n}\r\nreturn qla24xx_write_flash_dword(ha, ha->fdt_erase_cmd,\r\n(fdata & 0xff00) | ((fdata << 16) & 0xff0000) |\r\n((fdata >> 16) & 0xff));\r\n}\r\nstatic int\r\nqla24xx_write_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,\r\nuint32_t dwords)\r\n{\r\nint ret;\r\nuint32_t liter;\r\nuint32_t sec_mask, rest_addr;\r\nuint32_t fdata;\r\ndma_addr_t optrom_dma;\r\nvoid *optrom = NULL;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif ((IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha)) &&\r\n!(faddr & 0xfff) && dwords > OPTROM_BURST_DWORDS) {\r\noptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\r\n&optrom_dma, GFP_KERNEL);\r\nif (!optrom) {\r\nql_log(ql_log_warn, vha, 0x7095,\r\n"Unable to allocate "\r\n"memory for optrom burst write (%x KB).\n",\r\nOPTROM_BURST_SIZE / 1024);\r\n}\r\n}\r\nrest_addr = (ha->fdt_block_size >> 2) - 1;\r\nsec_mask = ~rest_addr;\r\nret = qla24xx_unprotect_flash(vha);\r\nif (ret != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7096,\r\n"Unable to unprotect flash for update.\n");\r\ngoto done;\r\n}\r\nfor (liter = 0; liter < dwords; liter++, faddr++, dwptr++) {\r\nfdata = (faddr & sec_mask) << 2;\r\nif ((faddr & rest_addr) == 0) {\r\nif (ha->fdt_unprotect_sec_cmd)\r\nqla24xx_write_flash_dword(ha,\r\nha->fdt_unprotect_sec_cmd,\r\n(fdata & 0xff00) | ((fdata << 16) &\r\n0xff0000) | ((fdata >> 16) & 0xff));\r\nret = qla24xx_erase_sector(vha, fdata);\r\nif (ret != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_user, vha, 0x7007,\r\n"Unable to erase erase sector: address=%x.\n",\r\nfaddr);\r\nbreak;\r\n}\r\n}\r\nif (optrom && (liter + OPTROM_BURST_DWORDS) <= dwords) {\r\nmemcpy(optrom, dwptr, OPTROM_BURST_SIZE);\r\nret = qla2x00_load_ram(vha, optrom_dma,\r\nflash_data_addr(ha, faddr),\r\nOPTROM_BURST_DWORDS);\r\nif (ret != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7097,\r\n"Unable to burst-write optrom segment "\r\n"(%x/%x/%llx).\n", ret,\r\nflash_data_addr(ha, faddr),\r\n(unsigned long long)optrom_dma);\r\nql_log(ql_log_warn, vha, 0x7098,\r\n"Reverting to slow-write.\n");\r\ndma_free_coherent(&ha->pdev->dev,\r\nOPTROM_BURST_SIZE, optrom, optrom_dma);\r\noptrom = NULL;\r\n} else {\r\nliter += OPTROM_BURST_DWORDS - 1;\r\nfaddr += OPTROM_BURST_DWORDS - 1;\r\ndwptr += OPTROM_BURST_DWORDS - 1;\r\ncontinue;\r\n}\r\n}\r\nret = qla24xx_write_flash_dword(ha,\r\nflash_data_addr(ha, faddr), cpu_to_le32(*dwptr));\r\nif (ret != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_user, vha, 0x7006,\r\n"Unable to program flash address=%x data=%x.\n",\r\nfaddr, *dwptr);\r\nbreak;\r\n}\r\nif (ha->fdt_unprotect_sec_cmd &&\r\n((faddr & rest_addr) == rest_addr))\r\nqla24xx_write_flash_dword(ha,\r\nha->fdt_protect_sec_cmd,\r\n(fdata & 0xff00) | ((fdata << 16) &\r\n0xff0000) | ((fdata >> 16) & 0xff));\r\n}\r\nret = qla24xx_protect_flash(vha);\r\nif (ret != QLA_SUCCESS)\r\nql_log(ql_log_warn, vha, 0x7099,\r\n"Unable to protect flash after update.\n");\r\ndone:\r\nif (optrom)\r\ndma_free_coherent(&ha->pdev->dev,\r\nOPTROM_BURST_SIZE, optrom, optrom_dma);\r\nreturn ret;\r\n}\r\nuint8_t *\r\nqla2x00_read_nvram_data(scsi_qla_host_t *vha, uint8_t *buf, uint32_t naddr,\r\nuint32_t bytes)\r\n{\r\nuint32_t i;\r\nuint16_t *wptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nwptr = (uint16_t *)buf;\r\nqla2x00_lock_nvram_access(ha);\r\nfor (i = 0; i < bytes >> 1; i++, naddr++)\r\nwptr[i] = cpu_to_le16(qla2x00_get_nvram_word(ha,\r\nnaddr));\r\nqla2x00_unlock_nvram_access(ha);\r\nreturn buf;\r\n}\r\nuint8_t *\r\nqla24xx_read_nvram_data(scsi_qla_host_t *vha, uint8_t *buf, uint32_t naddr,\r\nuint32_t bytes)\r\n{\r\nuint32_t i;\r\nuint32_t *dwptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA82XX(ha))\r\nreturn buf;\r\ndwptr = (uint32_t *)buf;\r\nfor (i = 0; i < bytes >> 2; i++, naddr++)\r\ndwptr[i] = cpu_to_le32(qla24xx_read_flash_dword(ha,\r\nnvram_data_addr(ha, naddr)));\r\nreturn buf;\r\n}\r\nint\r\nqla2x00_write_nvram_data(scsi_qla_host_t *vha, uint8_t *buf, uint32_t naddr,\r\nuint32_t bytes)\r\n{\r\nint ret, stat;\r\nuint32_t i;\r\nuint16_t *wptr;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nret = QLA_SUCCESS;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqla2x00_lock_nvram_access(ha);\r\nstat = qla2x00_clear_nvram_protection(ha);\r\nwptr = (uint16_t *)buf;\r\nfor (i = 0; i < bytes >> 1; i++, naddr++) {\r\nqla2x00_write_nvram_word(ha, naddr,\r\ncpu_to_le16(*wptr));\r\nwptr++;\r\n}\r\nqla2x00_set_nvram_protection(ha, stat);\r\nqla2x00_unlock_nvram_access(ha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn ret;\r\n}\r\nint\r\nqla24xx_write_nvram_data(scsi_qla_host_t *vha, uint8_t *buf, uint32_t naddr,\r\nuint32_t bytes)\r\n{\r\nint ret;\r\nuint32_t i;\r\nuint32_t *dwptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nret = QLA_SUCCESS;\r\nif (IS_QLA82XX(ha))\r\nreturn ret;\r\nWRT_REG_DWORD(&reg->ctrl_status,\r\nRD_REG_DWORD(&reg->ctrl_status) | CSRX_FLASH_ENABLE);\r\nRD_REG_DWORD(&reg->ctrl_status);\r\nqla24xx_write_flash_dword(ha, nvram_conf_addr(ha, 0x101), 0);\r\nqla24xx_write_flash_dword(ha, nvram_conf_addr(ha, 0x101), 0);\r\ndwptr = (uint32_t *)buf;\r\nfor (i = 0; i < bytes >> 2; i++, naddr++, dwptr++) {\r\nret = qla24xx_write_flash_dword(ha,\r\nnvram_data_addr(ha, naddr), cpu_to_le32(*dwptr));\r\nif (ret != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_user, vha, 0x709a,\r\n"Unable to program nvram address=%x data=%x.\n",\r\nnaddr, *dwptr);\r\nbreak;\r\n}\r\n}\r\nqla24xx_write_flash_dword(ha, nvram_conf_addr(ha, 0x101), 0x8c);\r\nWRT_REG_DWORD(&reg->ctrl_status,\r\nRD_REG_DWORD(&reg->ctrl_status) & ~CSRX_FLASH_ENABLE);\r\nRD_REG_DWORD(&reg->ctrl_status);\r\nreturn ret;\r\n}\r\nuint8_t *\r\nqla25xx_read_nvram_data(scsi_qla_host_t *vha, uint8_t *buf, uint32_t naddr,\r\nuint32_t bytes)\r\n{\r\nuint32_t i;\r\nuint32_t *dwptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndwptr = (uint32_t *)buf;\r\nfor (i = 0; i < bytes >> 2; i++, naddr++)\r\ndwptr[i] = cpu_to_le32(qla24xx_read_flash_dword(ha,\r\nflash_data_addr(ha, ha->flt_region_vpd_nvram | naddr)));\r\nreturn buf;\r\n}\r\nint\r\nqla25xx_write_nvram_data(scsi_qla_host_t *vha, uint8_t *buf, uint32_t naddr,\r\nuint32_t bytes)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\n#define RMW_BUFFER_SIZE (64 * 1024)\r\nuint8_t *dbuf;\r\ndbuf = vmalloc(RMW_BUFFER_SIZE);\r\nif (!dbuf)\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\nha->isp_ops->read_optrom(vha, dbuf, ha->flt_region_vpd_nvram << 2,\r\nRMW_BUFFER_SIZE);\r\nmemcpy(dbuf + (naddr << 2), buf, bytes);\r\nha->isp_ops->write_optrom(vha, dbuf, ha->flt_region_vpd_nvram << 2,\r\nRMW_BUFFER_SIZE);\r\nvfree(dbuf);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic inline void\r\nqla2x00_flip_colors(struct qla_hw_data *ha, uint16_t *pflags)\r\n{\r\nif (IS_QLA2322(ha)) {\r\nif (ha->beacon_color_state == QLA_LED_ALL_ON) {\r\nha->beacon_color_state = 0;\r\n*pflags = GPIO_LED_ALL_OFF;\r\n} else {\r\nha->beacon_color_state = QLA_LED_ALL_ON;\r\n*pflags = GPIO_LED_RGA_ON;\r\n}\r\n} else {\r\nif (ha->beacon_color_state == QLA_LED_GRN_ON) {\r\nha->beacon_color_state = 0;\r\n*pflags = GPIO_LED_GREEN_OFF_AMBER_OFF;\r\n} else {\r\nha->beacon_color_state = QLA_LED_GRN_ON;\r\n*pflags = GPIO_LED_GREEN_ON_AMBER_OFF;\r\n}\r\n}\r\n}\r\nvoid\r\nqla2x00_beacon_blink(struct scsi_qla_host *vha)\r\n{\r\nuint16_t gpio_enable;\r\nuint16_t gpio_data;\r\nuint16_t led_color = 0;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nif (IS_QLA82XX(ha))\r\nreturn;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (ha->pio_address) {\r\ngpio_enable = RD_REG_WORD_PIO(PIO_REG(ha, gpioe));\r\ngpio_data = RD_REG_WORD_PIO(PIO_REG(ha, gpiod));\r\n} else {\r\ngpio_enable = RD_REG_WORD(&reg->gpioe);\r\ngpio_data = RD_REG_WORD(&reg->gpiod);\r\n}\r\ngpio_enable |= GPIO_LED_MASK;\r\nif (ha->pio_address) {\r\nWRT_REG_WORD_PIO(PIO_REG(ha, gpioe), gpio_enable);\r\n} else {\r\nWRT_REG_WORD(&reg->gpioe, gpio_enable);\r\nRD_REG_WORD(&reg->gpioe);\r\n}\r\nqla2x00_flip_colors(ha, &led_color);\r\ngpio_data &= ~GPIO_LED_MASK;\r\ngpio_data |= led_color;\r\nif (ha->pio_address) {\r\nWRT_REG_WORD_PIO(PIO_REG(ha, gpiod), gpio_data);\r\n} else {\r\nWRT_REG_WORD(&reg->gpiod, gpio_data);\r\nRD_REG_WORD(&reg->gpiod);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nint\r\nqla2x00_beacon_on(struct scsi_qla_host *vha)\r\n{\r\nuint16_t gpio_enable;\r\nuint16_t gpio_data;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\r\nha->fw_options[1] |= FO1_DISABLE_GPIO6_7;\r\nif (qla2x00_set_fw_options(vha, ha->fw_options) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x709b,\r\n"Unable to update fw options (beacon on).\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (ha->pio_address) {\r\ngpio_enable = RD_REG_WORD_PIO(PIO_REG(ha, gpioe));\r\ngpio_data = RD_REG_WORD_PIO(PIO_REG(ha, gpiod));\r\n} else {\r\ngpio_enable = RD_REG_WORD(&reg->gpioe);\r\ngpio_data = RD_REG_WORD(&reg->gpiod);\r\n}\r\ngpio_enable |= GPIO_LED_MASK;\r\nif (ha->pio_address) {\r\nWRT_REG_WORD_PIO(PIO_REG(ha, gpioe), gpio_enable);\r\n} else {\r\nWRT_REG_WORD(&reg->gpioe, gpio_enable);\r\nRD_REG_WORD(&reg->gpioe);\r\n}\r\ngpio_data &= ~GPIO_LED_MASK;\r\nif (ha->pio_address) {\r\nWRT_REG_WORD_PIO(PIO_REG(ha, gpiod), gpio_data);\r\n} else {\r\nWRT_REG_WORD(&reg->gpiod, gpio_data);\r\nRD_REG_WORD(&reg->gpiod);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nha->beacon_blink_led = 1;\r\nha->beacon_color_state = 0;\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla2x00_beacon_off(struct scsi_qla_host *vha)\r\n{\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nha->beacon_blink_led = 0;\r\nif (IS_QLA2322(ha))\r\nha->beacon_color_state = QLA_LED_ALL_ON;\r\nelse\r\nha->beacon_color_state = QLA_LED_GRN_ON;\r\nha->isp_ops->beacon_blink(vha);\r\nha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\r\nha->fw_options[1] &= ~FO1_DISABLE_GPIO6_7;\r\nrval = qla2x00_set_fw_options(vha, ha->fw_options);\r\nif (rval != QLA_SUCCESS)\r\nql_log(ql_log_warn, vha, 0x709c,\r\n"Unable to update fw options (beacon off).\n");\r\nreturn rval;\r\n}\r\nstatic inline void\r\nqla24xx_flip_colors(struct qla_hw_data *ha, uint16_t *pflags)\r\n{\r\nif (ha->beacon_color_state == QLA_LED_ALL_ON) {\r\nha->beacon_color_state = 0;\r\n*pflags = 0;\r\n} else {\r\nha->beacon_color_state = QLA_LED_ALL_ON;\r\n*pflags = GPDX_LED_YELLOW_ON | GPDX_LED_AMBER_ON;\r\n}\r\n}\r\nvoid\r\nqla24xx_beacon_blink(struct scsi_qla_host *vha)\r\n{\r\nuint16_t led_color = 0;\r\nuint32_t gpio_data;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ngpio_data = RD_REG_DWORD(&reg->gpiod);\r\ngpio_data |= GPDX_LED_UPDATE_MASK;\r\nWRT_REG_DWORD(&reg->gpiod, gpio_data);\r\ngpio_data = RD_REG_DWORD(&reg->gpiod);\r\nqla24xx_flip_colors(ha, &led_color);\r\ngpio_data &= ~GPDX_LED_COLOR_MASK;\r\ngpio_data |= led_color;\r\nWRT_REG_DWORD(&reg->gpiod, gpio_data);\r\ngpio_data = RD_REG_DWORD(&reg->gpiod);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid\r\nqla83xx_beacon_blink(struct scsi_qla_host *vha)\r\n{\r\nuint32_t led_select_value;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t led_cfg[6];\r\nuint16_t orig_led_cfg[6];\r\nif (!IS_QLA83XX(ha) && !IS_QLA81XX(ha))\r\nreturn;\r\nif (IS_QLA2031(ha) && ha->beacon_blink_led) {\r\nif (ha->flags.port0)\r\nled_select_value = 0x00201320;\r\nelse\r\nled_select_value = 0x00201328;\r\nqla83xx_write_remote_reg(vha, led_select_value, 0x40002000);\r\nqla83xx_write_remote_reg(vha, led_select_value + 4, 0x40002000);\r\nmsleep(1000);\r\nqla83xx_write_remote_reg(vha, led_select_value, 0x40004000);\r\nqla83xx_write_remote_reg(vha, led_select_value + 4, 0x40004000);\r\n} else if ((IS_QLA8031(ha) || IS_QLA81XX(ha)) && ha->beacon_blink_led) {\r\nint rval;\r\nrval = qla81xx_get_led_config(vha, orig_led_cfg);\r\nif (rval == QLA_SUCCESS) {\r\nif (IS_QLA81XX(ha)) {\r\nled_cfg[0] = 0x4000;\r\nled_cfg[1] = 0x2000;\r\nled_cfg[2] = 0;\r\nled_cfg[3] = 0;\r\nled_cfg[4] = 0;\r\nled_cfg[5] = 0;\r\n} else {\r\nled_cfg[0] = 0x4000;\r\nled_cfg[1] = 0x4000;\r\nled_cfg[2] = 0x4000;\r\nled_cfg[3] = 0x2000;\r\nled_cfg[4] = 0;\r\nled_cfg[5] = 0x2000;\r\n}\r\nrval = qla81xx_set_led_config(vha, led_cfg);\r\nmsleep(1000);\r\nif (IS_QLA81XX(ha)) {\r\nled_cfg[0] = 0x4000;\r\nled_cfg[1] = 0x2000;\r\nled_cfg[2] = 0;\r\n} else {\r\nled_cfg[0] = 0x4000;\r\nled_cfg[1] = 0x2000;\r\nled_cfg[2] = 0x4000;\r\nled_cfg[3] = 0x4000;\r\nled_cfg[4] = 0;\r\nled_cfg[5] = 0x2000;\r\n}\r\nrval = qla81xx_set_led_config(vha, led_cfg);\r\n}\r\nqla81xx_set_led_config(vha, orig_led_cfg);\r\n}\r\n}\r\nint\r\nqla24xx_beacon_on(struct scsi_qla_host *vha)\r\n{\r\nuint32_t gpio_data;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nif (IS_QLA82XX(ha))\r\nreturn QLA_SUCCESS;\r\nif (IS_QLA8031(ha) || IS_QLA81XX(ha))\r\ngoto skip_gpio;\r\nif (ha->beacon_blink_led == 0) {\r\nha->fw_options[1] |= ADD_FO1_DISABLE_GPIO_LED_CTRL;\r\nif (qla2x00_set_fw_options(vha, ha->fw_options) != QLA_SUCCESS)\r\nreturn QLA_FUNCTION_FAILED;\r\nif (qla2x00_get_fw_options(vha, ha->fw_options) !=\r\nQLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x7009,\r\n"Unable to update fw options (beacon on).\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nif (IS_QLA2031(ha))\r\ngoto skip_gpio;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ngpio_data = RD_REG_DWORD(&reg->gpiod);\r\ngpio_data |= GPDX_LED_UPDATE_MASK;\r\nWRT_REG_DWORD(&reg->gpiod, gpio_data);\r\nRD_REG_DWORD(&reg->gpiod);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nha->beacon_color_state = 0;\r\nskip_gpio:\r\nha->beacon_blink_led = 1;\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqla24xx_beacon_off(struct scsi_qla_host *vha)\r\n{\r\nuint32_t gpio_data;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nif (IS_QLA82XX(ha))\r\nreturn QLA_SUCCESS;\r\nha->beacon_blink_led = 0;\r\nif (IS_QLA2031(ha))\r\ngoto set_fw_options;\r\nif (IS_QLA8031(ha) || IS_QLA81XX(ha))\r\nreturn QLA_SUCCESS;\r\nha->beacon_color_state = QLA_LED_ALL_ON;\r\nha->isp_ops->beacon_blink(vha);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ngpio_data = RD_REG_DWORD(&reg->gpiod);\r\ngpio_data &= ~GPDX_LED_UPDATE_MASK;\r\nWRT_REG_DWORD(&reg->gpiod, gpio_data);\r\nRD_REG_DWORD(&reg->gpiod);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nset_fw_options:\r\nha->fw_options[1] &= ~ADD_FO1_DISABLE_GPIO_LED_CTRL;\r\nif (qla2x00_set_fw_options(vha, ha->fw_options) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x704d,\r\n"Unable to update fw options (beacon on).\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nif (qla2x00_get_fw_options(vha, ha->fw_options) != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x704e,\r\n"Unable to update fw options (beacon on).\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla2x00_flash_enable(struct qla_hw_data *ha)\r\n{\r\nuint16_t data;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\ndata = RD_REG_WORD(&reg->ctrl_status);\r\ndata |= CSR_FLASH_ENABLE;\r\nWRT_REG_WORD(&reg->ctrl_status, data);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n}\r\nstatic void\r\nqla2x00_flash_disable(struct qla_hw_data *ha)\r\n{\r\nuint16_t data;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\ndata = RD_REG_WORD(&reg->ctrl_status);\r\ndata &= ~(CSR_FLASH_ENABLE);\r\nWRT_REG_WORD(&reg->ctrl_status, data);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n}\r\nstatic uint8_t\r\nqla2x00_read_flash_byte(struct qla_hw_data *ha, uint32_t addr)\r\n{\r\nuint16_t data;\r\nuint16_t bank_select;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nbank_select = RD_REG_WORD(&reg->ctrl_status);\r\nif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\r\nbank_select &= ~0xf8;\r\nbank_select |= addr >> 12 & 0xf0;\r\nbank_select |= CSR_FLASH_64K_BANK;\r\nWRT_REG_WORD(&reg->ctrl_status, bank_select);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->flash_address, (uint16_t)addr);\r\ndata = RD_REG_WORD(&reg->flash_data);\r\nreturn (uint8_t)data;\r\n}\r\nif ((addr & BIT_16) && ((bank_select & CSR_FLASH_64K_BANK) == 0)) {\r\nbank_select |= CSR_FLASH_64K_BANK;\r\nWRT_REG_WORD(&reg->ctrl_status, bank_select);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n} else if (((addr & BIT_16) == 0) &&\r\n(bank_select & CSR_FLASH_64K_BANK)) {\r\nbank_select &= ~(CSR_FLASH_64K_BANK);\r\nWRT_REG_WORD(&reg->ctrl_status, bank_select);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n}\r\nif (ha->pio_address) {\r\nuint16_t data2;\r\nWRT_REG_WORD_PIO(PIO_REG(ha, flash_address), (uint16_t)addr);\r\ndo {\r\ndata = RD_REG_WORD_PIO(PIO_REG(ha, flash_data));\r\nbarrier();\r\ncpu_relax();\r\ndata2 = RD_REG_WORD_PIO(PIO_REG(ha, flash_data));\r\n} while (data != data2);\r\n} else {\r\nWRT_REG_WORD(&reg->flash_address, (uint16_t)addr);\r\ndata = qla2x00_debounce_register(&reg->flash_data);\r\n}\r\nreturn (uint8_t)data;\r\n}\r\nstatic void\r\nqla2x00_write_flash_byte(struct qla_hw_data *ha, uint32_t addr, uint8_t data)\r\n{\r\nuint16_t bank_select;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nbank_select = RD_REG_WORD(&reg->ctrl_status);\r\nif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\r\nbank_select &= ~0xf8;\r\nbank_select |= addr >> 12 & 0xf0;\r\nbank_select |= CSR_FLASH_64K_BANK;\r\nWRT_REG_WORD(&reg->ctrl_status, bank_select);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->flash_address, (uint16_t)addr);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->flash_data, (uint16_t)data);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nreturn;\r\n}\r\nif ((addr & BIT_16) && ((bank_select & CSR_FLASH_64K_BANK) == 0)) {\r\nbank_select |= CSR_FLASH_64K_BANK;\r\nWRT_REG_WORD(&reg->ctrl_status, bank_select);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n} else if (((addr & BIT_16) == 0) &&\r\n(bank_select & CSR_FLASH_64K_BANK)) {\r\nbank_select &= ~(CSR_FLASH_64K_BANK);\r\nWRT_REG_WORD(&reg->ctrl_status, bank_select);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n}\r\nif (ha->pio_address) {\r\nWRT_REG_WORD_PIO(PIO_REG(ha, flash_address), (uint16_t)addr);\r\nWRT_REG_WORD_PIO(PIO_REG(ha, flash_data), (uint16_t)data);\r\n} else {\r\nWRT_REG_WORD(&reg->flash_address, (uint16_t)addr);\r\nRD_REG_WORD(&reg->ctrl_status);\r\nWRT_REG_WORD(&reg->flash_data, (uint16_t)data);\r\nRD_REG_WORD(&reg->ctrl_status);\r\n}\r\n}\r\nstatic int\r\nqla2x00_poll_flash(struct qla_hw_data *ha, uint32_t addr, uint8_t poll_data,\r\nuint8_t man_id, uint8_t flash_id)\r\n{\r\nint status;\r\nuint8_t flash_data;\r\nuint32_t cnt;\r\nstatus = 1;\r\npoll_data &= BIT_7;\r\nfor (cnt = 3000000; cnt; cnt--) {\r\nflash_data = qla2x00_read_flash_byte(ha, addr);\r\nif ((flash_data & BIT_7) == poll_data) {\r\nstatus = 0;\r\nbreak;\r\n}\r\nif (man_id != 0x40 && man_id != 0xda) {\r\nif ((flash_data & BIT_5) && cnt > 2)\r\ncnt = 2;\r\n}\r\nudelay(10);\r\nbarrier();\r\ncond_resched();\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\nqla2x00_program_flash_address(struct qla_hw_data *ha, uint32_t addr,\r\nuint8_t data, uint8_t man_id, uint8_t flash_id)\r\n{\r\nif (IS_OEM_001(ha)) {\r\nqla2x00_write_flash_byte(ha, 0xaaa, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x555, 0x55);\r\nqla2x00_write_flash_byte(ha, 0xaaa, 0xa0);\r\nqla2x00_write_flash_byte(ha, addr, data);\r\n} else {\r\nif (man_id == 0xda && flash_id == 0xc1) {\r\nqla2x00_write_flash_byte(ha, addr, data);\r\nif (addr & 0x7e)\r\nreturn 0;\r\n} else {\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xa0);\r\nqla2x00_write_flash_byte(ha, addr, data);\r\n}\r\n}\r\nudelay(150);\r\nreturn qla2x00_poll_flash(ha, addr, data, man_id, flash_id);\r\n}\r\nstatic int\r\nqla2x00_erase_flash(struct qla_hw_data *ha, uint8_t man_id, uint8_t flash_id)\r\n{\r\nif (IS_OEM_001(ha)) {\r\nqla2x00_write_flash_byte(ha, 0xaaa, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x555, 0x55);\r\nqla2x00_write_flash_byte(ha, 0xaaa, 0x80);\r\nqla2x00_write_flash_byte(ha, 0xaaa, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x555, 0x55);\r\nqla2x00_write_flash_byte(ha, 0xaaa, 0x10);\r\n} else {\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0x80);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0x10);\r\n}\r\nudelay(150);\r\nreturn qla2x00_poll_flash(ha, 0x00, 0x80, man_id, flash_id);\r\n}\r\nstatic int\r\nqla2x00_erase_flash_sector(struct qla_hw_data *ha, uint32_t addr,\r\nuint32_t sec_mask, uint8_t man_id, uint8_t flash_id)\r\n{\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0x80);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nif (man_id == 0x1f && flash_id == 0x13)\r\nqla2x00_write_flash_byte(ha, addr & sec_mask, 0x10);\r\nelse\r\nqla2x00_write_flash_byte(ha, addr & sec_mask, 0x30);\r\nudelay(150);\r\nreturn qla2x00_poll_flash(ha, addr, 0x80, man_id, flash_id);\r\n}\r\nstatic void\r\nqla2x00_get_flash_manufacturer(struct qla_hw_data *ha, uint8_t *man_id,\r\nuint8_t *flash_id)\r\n{\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0x90);\r\n*man_id = qla2x00_read_flash_byte(ha, 0x0000);\r\n*flash_id = qla2x00_read_flash_byte(ha, 0x0001);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555, 0xf0);\r\n}\r\nstatic void\r\nqla2x00_read_flash_data(struct qla_hw_data *ha, uint8_t *tmp_buf,\r\nuint32_t saddr, uint32_t length)\r\n{\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nuint32_t midpoint, ilength;\r\nuint8_t data;\r\nmidpoint = length / 2;\r\nWRT_REG_WORD(&reg->nvram, 0);\r\nRD_REG_WORD(&reg->nvram);\r\nfor (ilength = 0; ilength < length; saddr++, ilength++, tmp_buf++) {\r\nif (ilength == midpoint) {\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\n}\r\ndata = qla2x00_read_flash_byte(ha, saddr);\r\nif (saddr % 100)\r\nudelay(10);\r\n*tmp_buf = data;\r\ncond_resched();\r\n}\r\n}\r\nstatic inline void\r\nqla2x00_suspend_hba(struct scsi_qla_host *vha)\r\n{\r\nint cnt;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nscsi_block_requests(vha->host);\r\nha->isp_ops->disable_intrs(ha);\r\nset_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nWRT_REG_WORD(&reg->hccr, HCCR_PAUSE_RISC);\r\nRD_REG_WORD(&reg->hccr);\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\r\nfor (cnt = 0; cnt < 30000; cnt++) {\r\nif ((RD_REG_WORD(&reg->hccr) & HCCR_RISC_PAUSE) != 0)\r\nbreak;\r\nudelay(100);\r\n}\r\n} else {\r\nudelay(10);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic inline void\r\nqla2x00_resume_hba(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nclear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nqla2x00_wait_for_chip_reset(vha);\r\nscsi_unblock_requests(vha->host);\r\n}\r\nuint8_t *\r\nqla2x00_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nuint32_t addr, midpoint;\r\nuint8_t *data;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nqla2x00_suspend_hba(vha);\r\nmidpoint = ha->optrom_size / 2;\r\nqla2x00_flash_enable(ha);\r\nWRT_REG_WORD(&reg->nvram, 0);\r\nRD_REG_WORD(&reg->nvram);\r\nfor (addr = offset, data = buf; addr < length; addr++, data++) {\r\nif (addr == midpoint) {\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\n}\r\n*data = qla2x00_read_flash_byte(ha, addr);\r\n}\r\nqla2x00_flash_disable(ha);\r\nqla2x00_resume_hba(vha);\r\nreturn buf;\r\n}\r\nint\r\nqla2x00_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nint rval;\r\nuint8_t man_id, flash_id, sec_number, data;\r\nuint16_t wd;\r\nuint32_t addr, liter, sec_mask, rest_addr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\r\nqla2x00_suspend_hba(vha);\r\nrval = QLA_SUCCESS;\r\nsec_number = 0;\r\nWRT_REG_WORD(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &wd);\r\nqla2x00_flash_enable(ha);\r\ndo {\r\nif (IS_OEM_001(ha)) {\r\nman_id = flash_id = 0;\r\nrest_addr = 0xffff;\r\nsec_mask = 0x10000;\r\ngoto update_flash;\r\n}\r\nqla2x00_get_flash_manufacturer(ha, &man_id, &flash_id);\r\nswitch (man_id) {\r\ncase 0x20:\r\nif (flash_id == 0xd2 || flash_id == 0xe3) {\r\nrest_addr = 0xffff;\r\nsec_mask = 0x10000;\r\nbreak;\r\n}\r\nrest_addr = 0x3fff;\r\nsec_mask = 0x1c000;\r\nbreak;\r\ncase 0x40:\r\nrest_addr = 0x1ff;\r\nsec_mask = 0x1fe00;\r\nbreak;\r\ncase 0xbf:\r\nrest_addr = 0xfff;\r\nsec_mask = 0x1f000;\r\nbreak;\r\ncase 0xda:\r\nrest_addr = 0x7f;\r\nsec_mask = 0x1ff80;\r\nbreak;\r\ncase 0xc2:\r\nif (flash_id == 0x38 || flash_id == 0x4f) {\r\nrest_addr = 0xffff;\r\nsec_mask = 0x10000;\r\nbreak;\r\n}\r\ncase 0x1f:\r\nif (flash_id == 0x13) {\r\nrest_addr = 0x7fffffff;\r\nsec_mask = 0x80000000;\r\nbreak;\r\n}\r\ncase 0x01:\r\nif (flash_id == 0x38 || flash_id == 0x40 ||\r\nflash_id == 0x4f) {\r\nrest_addr = 0xffff;\r\nsec_mask = 0x10000;\r\nbreak;\r\n} else if (flash_id == 0x3e) {\r\nrest_addr = 0xffff;\r\nsec_mask = 0x10000;\r\nbreak;\r\n} else if (flash_id == 0x20 || flash_id == 0x6e) {\r\nrest_addr = 0x3fff;\r\nsec_mask = 0x1c000;\r\nbreak;\r\n} else if (flash_id == 0x6d) {\r\nrest_addr = 0x1fff;\r\nsec_mask = 0x1e000;\r\nbreak;\r\n}\r\ndefault:\r\nrest_addr = 0x3fff;\r\nsec_mask = 0x1c000;\r\nbreak;\r\n}\r\nupdate_flash:\r\nif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\r\nif (qla2x00_erase_flash(ha, man_id, flash_id)) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\n}\r\nfor (addr = offset, liter = 0; liter < length; liter++,\r\naddr++) {\r\ndata = buf[liter];\r\nif ((addr & rest_addr) == 0) {\r\nif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\r\nif (addr >= 0x10000UL) {\r\nif (((addr >> 12) & 0xf0) &&\r\n((man_id == 0x01 &&\r\nflash_id == 0x3e) ||\r\n(man_id == 0x20 &&\r\nflash_id == 0xd2))) {\r\nsec_number++;\r\nif (sec_number == 1) {\r\nrest_addr =\r\n0x7fff;\r\nsec_mask =\r\n0x18000;\r\n} else if (\r\nsec_number == 2 ||\r\nsec_number == 3) {\r\nrest_addr =\r\n0x1fff;\r\nsec_mask =\r\n0x1e000;\r\n} else if (\r\nsec_number == 4) {\r\nrest_addr =\r\n0x3fff;\r\nsec_mask =\r\n0x1c000;\r\n}\r\n}\r\n}\r\n} else if (addr == ha->optrom_size / 2) {\r\nWRT_REG_WORD(&reg->nvram, NVR_SELECT);\r\nRD_REG_WORD(&reg->nvram);\r\n}\r\nif (flash_id == 0xda && man_id == 0xc1) {\r\nqla2x00_write_flash_byte(ha, 0x5555,\r\n0xaa);\r\nqla2x00_write_flash_byte(ha, 0x2aaa,\r\n0x55);\r\nqla2x00_write_flash_byte(ha, 0x5555,\r\n0xa0);\r\n} else if (!IS_QLA2322(ha) && !IS_QLA6322(ha)) {\r\nif (qla2x00_erase_flash_sector(ha,\r\naddr, sec_mask, man_id,\r\nflash_id)) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\nif (man_id == 0x01 && flash_id == 0x6d)\r\nsec_number++;\r\n}\r\n}\r\nif (man_id == 0x01 && flash_id == 0x6d) {\r\nif (sec_number == 1 &&\r\naddr == (rest_addr - 1)) {\r\nrest_addr = 0x0fff;\r\nsec_mask = 0x1f000;\r\n} else if (sec_number == 3 && (addr & 0x7ffe)) {\r\nrest_addr = 0x3fff;\r\nsec_mask = 0x1c000;\r\n}\r\n}\r\nif (qla2x00_program_flash_address(ha, addr, data,\r\nman_id, flash_id)) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\n} while (0);\r\nqla2x00_flash_disable(ha);\r\nqla2x00_resume_hba(vha);\r\nreturn rval;\r\n}\r\nuint8_t *\r\nqla24xx_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nscsi_block_requests(vha->host);\r\nset_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\r\nqla24xx_read_flash_data(vha, (uint32_t *)buf, offset >> 2, length >> 2);\r\nclear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\r\nscsi_unblock_requests(vha->host);\r\nreturn buf;\r\n}\r\nint\r\nqla24xx_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nscsi_block_requests(vha->host);\r\nset_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\r\nrval = qla24xx_write_flash_data(vha, (uint32_t *)buf, offset >> 2,\r\nlength >> 2);\r\nclear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\r\nscsi_unblock_requests(vha->host);\r\nreturn rval;\r\n}\r\nuint8_t *\r\nqla25xx_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nint rval;\r\ndma_addr_t optrom_dma;\r\nvoid *optrom;\r\nuint8_t *pbuf;\r\nuint32_t faddr, left, burst;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA25XX(ha) || IS_QLA81XX(ha))\r\ngoto try_fast;\r\nif (offset & 0xfff)\r\ngoto slow_read;\r\nif (length < OPTROM_BURST_SIZE)\r\ngoto slow_read;\r\ntry_fast:\r\noptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\r\n&optrom_dma, GFP_KERNEL);\r\nif (!optrom) {\r\nql_log(ql_log_warn, vha, 0x00cc,\r\n"Unable to allocate memory for optrom burst read (%x KB).\n",\r\nOPTROM_BURST_SIZE / 1024);\r\ngoto slow_read;\r\n}\r\npbuf = buf;\r\nfaddr = offset >> 2;\r\nleft = length >> 2;\r\nburst = OPTROM_BURST_DWORDS;\r\nwhile (left != 0) {\r\nif (burst > left)\r\nburst = left;\r\nrval = qla2x00_dump_ram(vha, optrom_dma,\r\nflash_data_addr(ha, faddr), burst);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x00f5,\r\n"Unable to burst-read optrom segment (%x/%x/%llx).\n",\r\nrval, flash_data_addr(ha, faddr),\r\n(unsigned long long)optrom_dma);\r\nql_log(ql_log_warn, vha, 0x00f6,\r\n"Reverting to slow-read.\n");\r\ndma_free_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\r\noptrom, optrom_dma);\r\ngoto slow_read;\r\n}\r\nmemcpy(pbuf, optrom, burst * 4);\r\nleft -= burst;\r\nfaddr += burst;\r\npbuf += burst * 4;\r\n}\r\ndma_free_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE, optrom,\r\noptrom_dma);\r\nreturn buf;\r\nslow_read:\r\nreturn qla24xx_read_optrom_data(vha, buf, offset, length);\r\n}\r\nstatic void\r\nqla2x00_get_fcode_version(struct qla_hw_data *ha, uint32_t pcids)\r\n{\r\nint ret = QLA_FUNCTION_FAILED;\r\nuint32_t istart, iend, iter, vend;\r\nuint8_t do_next, rbyte, *vbyte;\r\nmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\r\nistart = pcids +\r\n((qla2x00_read_flash_byte(ha, pcids + 0x0B) << 8) |\r\nqla2x00_read_flash_byte(ha, pcids + 0x0A));\r\niend = istart + 0x100;\r\ndo {\r\ndo_next = 0;\r\niter = istart;\r\nwhile ((iter < iend) && !do_next) {\r\niter++;\r\nif (qla2x00_read_flash_byte(ha, iter) == '/') {\r\nif (qla2x00_read_flash_byte(ha, iter + 2) ==\r\n'/')\r\ndo_next++;\r\nelse if (qla2x00_read_flash_byte(ha,\r\niter + 3) == '/')\r\ndo_next++;\r\n}\r\n}\r\nif (!do_next)\r\nbreak;\r\ndo_next = 0;\r\nwhile ((iter > istart) && !do_next) {\r\niter--;\r\nif (qla2x00_read_flash_byte(ha, iter) == ' ')\r\ndo_next++;\r\n}\r\nif (!do_next)\r\nbreak;\r\nvend = iter - 1;\r\ndo_next = 0;\r\nwhile ((iter > istart) && !do_next) {\r\niter--;\r\nrbyte = qla2x00_read_flash_byte(ha, iter);\r\nif (rbyte == ' ' || rbyte == 0xd || rbyte == 0x10)\r\ndo_next++;\r\n}\r\nif (!do_next)\r\nbreak;\r\niter++;\r\nif ((vend - iter) &&\r\n((vend - iter) < sizeof(ha->fcode_revision))) {\r\nvbyte = ha->fcode_revision;\r\nwhile (iter <= vend) {\r\n*vbyte++ = qla2x00_read_flash_byte(ha, iter);\r\niter++;\r\n}\r\nret = QLA_SUCCESS;\r\n}\r\n} while (0);\r\nif (ret != QLA_SUCCESS)\r\nmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\r\n}\r\nint\r\nqla2x00_get_flash_version(scsi_qla_host_t *vha, void *mbuf)\r\n{\r\nint ret = QLA_SUCCESS;\r\nuint8_t code_type, last_image;\r\nuint32_t pcihdr, pcids;\r\nuint8_t *dbyte;\r\nuint16_t *dcode;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->pio_address || !mbuf)\r\nreturn QLA_FUNCTION_FAILED;\r\nmemset(ha->bios_revision, 0, sizeof(ha->bios_revision));\r\nmemset(ha->efi_revision, 0, sizeof(ha->efi_revision));\r\nmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\r\nmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\r\nqla2x00_flash_enable(ha);\r\npcihdr = 0;\r\nlast_image = 1;\r\ndo {\r\nif (qla2x00_read_flash_byte(ha, pcihdr) != 0x55 ||\r\nqla2x00_read_flash_byte(ha, pcihdr + 0x01) != 0xaa) {\r\nql_log(ql_log_fatal, vha, 0x0050,\r\n"No matching ROM signature.\n");\r\nret = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\npcids = pcihdr +\r\n((qla2x00_read_flash_byte(ha, pcihdr + 0x19) << 8) |\r\nqla2x00_read_flash_byte(ha, pcihdr + 0x18));\r\nif (qla2x00_read_flash_byte(ha, pcids) != 'P' ||\r\nqla2x00_read_flash_byte(ha, pcids + 0x1) != 'C' ||\r\nqla2x00_read_flash_byte(ha, pcids + 0x2) != 'I' ||\r\nqla2x00_read_flash_byte(ha, pcids + 0x3) != 'R') {\r\nql_log(ql_log_fatal, vha, 0x0051,\r\n"PCI data struct not found pcir_adr=%x.\n", pcids);\r\nret = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\ncode_type = qla2x00_read_flash_byte(ha, pcids + 0x14);\r\nswitch (code_type) {\r\ncase ROM_CODE_TYPE_BIOS:\r\nha->bios_revision[0] =\r\nqla2x00_read_flash_byte(ha, pcids + 0x12);\r\nha->bios_revision[1] =\r\nqla2x00_read_flash_byte(ha, pcids + 0x13);\r\nql_dbg(ql_dbg_init, vha, 0x0052,\r\n"Read BIOS %d.%d.\n",\r\nha->bios_revision[1], ha->bios_revision[0]);\r\nbreak;\r\ncase ROM_CODE_TYPE_FCODE:\r\nqla2x00_get_fcode_version(ha, pcids);\r\nbreak;\r\ncase ROM_CODE_TYPE_EFI:\r\nha->efi_revision[0] =\r\nqla2x00_read_flash_byte(ha, pcids + 0x12);\r\nha->efi_revision[1] =\r\nqla2x00_read_flash_byte(ha, pcids + 0x13);\r\nql_dbg(ql_dbg_init, vha, 0x0053,\r\n"Read EFI %d.%d.\n",\r\nha->efi_revision[1], ha->efi_revision[0]);\r\nbreak;\r\ndefault:\r\nql_log(ql_log_warn, vha, 0x0054,\r\n"Unrecognized code type %x at pcids %x.\n",\r\ncode_type, pcids);\r\nbreak;\r\n}\r\nlast_image = qla2x00_read_flash_byte(ha, pcids + 0x15) & BIT_7;\r\npcihdr += ((qla2x00_read_flash_byte(ha, pcids + 0x11) << 8) |\r\nqla2x00_read_flash_byte(ha, pcids + 0x10)) * 512;\r\n} while (!last_image);\r\nif (IS_QLA2322(ha)) {\r\nmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\r\ndbyte = mbuf;\r\nmemset(dbyte, 0, 8);\r\ndcode = (uint16_t *)dbyte;\r\nqla2x00_read_flash_data(ha, dbyte, ha->flt_region_fw * 4 + 10,\r\n8);\r\nql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010a,\r\n"Dumping fw "\r\n"ver from flash:.\n");\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010b,\r\n(uint8_t *)dbyte, 8);\r\nif ((dcode[0] == 0xffff && dcode[1] == 0xffff &&\r\ndcode[2] == 0xffff && dcode[3] == 0xffff) ||\r\n(dcode[0] == 0 && dcode[1] == 0 && dcode[2] == 0 &&\r\ndcode[3] == 0)) {\r\nql_log(ql_log_warn, vha, 0x0057,\r\n"Unrecognized fw revision at %x.\n",\r\nha->flt_region_fw * 4);\r\n} else {\r\nha->fw_revision[0] = dbyte[0] << 16 | dbyte[1];\r\nha->fw_revision[1] = dbyte[2] << 16 | dbyte[3];\r\nha->fw_revision[2] = dbyte[4] << 16 | dbyte[5];\r\nql_dbg(ql_dbg_init, vha, 0x0058,\r\n"FW Version: "\r\n"%d.%d.%d.\n", ha->fw_revision[0],\r\nha->fw_revision[1], ha->fw_revision[2]);\r\n}\r\n}\r\nqla2x00_flash_disable(ha);\r\nreturn ret;\r\n}\r\nint\r\nqla24xx_get_flash_version(scsi_qla_host_t *vha, void *mbuf)\r\n{\r\nint ret = QLA_SUCCESS;\r\nuint32_t pcihdr, pcids;\r\nuint32_t *dcode;\r\nuint8_t *bcode;\r\nuint8_t code_type, last_image;\r\nint i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (IS_QLA82XX(ha))\r\nreturn ret;\r\nif (!mbuf)\r\nreturn QLA_FUNCTION_FAILED;\r\nmemset(ha->bios_revision, 0, sizeof(ha->bios_revision));\r\nmemset(ha->efi_revision, 0, sizeof(ha->efi_revision));\r\nmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\r\nmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\r\ndcode = mbuf;\r\npcihdr = ha->flt_region_boot << 2;\r\nlast_image = 1;\r\ndo {\r\nqla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 0x20);\r\nbcode = mbuf + (pcihdr % 4);\r\nif (bcode[0x0] != 0x55 || bcode[0x1] != 0xaa) {\r\nql_log(ql_log_fatal, vha, 0x0059,\r\n"No matching ROM signature.\n");\r\nret = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\npcids = pcihdr + ((bcode[0x19] << 8) | bcode[0x18]);\r\nqla24xx_read_flash_data(vha, dcode, pcids >> 2, 0x20);\r\nbcode = mbuf + (pcihdr % 4);\r\nif (bcode[0x0] != 'P' || bcode[0x1] != 'C' ||\r\nbcode[0x2] != 'I' || bcode[0x3] != 'R') {\r\nql_log(ql_log_fatal, vha, 0x005a,\r\n"PCI data struct not found pcir_adr=%x.\n", pcids);\r\nret = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\ncode_type = bcode[0x14];\r\nswitch (code_type) {\r\ncase ROM_CODE_TYPE_BIOS:\r\nha->bios_revision[0] = bcode[0x12];\r\nha->bios_revision[1] = bcode[0x13];\r\nql_dbg(ql_dbg_init, vha, 0x005b,\r\n"Read BIOS %d.%d.\n",\r\nha->bios_revision[1], ha->bios_revision[0]);\r\nbreak;\r\ncase ROM_CODE_TYPE_FCODE:\r\nha->fcode_revision[0] = bcode[0x12];\r\nha->fcode_revision[1] = bcode[0x13];\r\nql_dbg(ql_dbg_init, vha, 0x005c,\r\n"Read FCODE %d.%d.\n",\r\nha->fcode_revision[1], ha->fcode_revision[0]);\r\nbreak;\r\ncase ROM_CODE_TYPE_EFI:\r\nha->efi_revision[0] = bcode[0x12];\r\nha->efi_revision[1] = bcode[0x13];\r\nql_dbg(ql_dbg_init, vha, 0x005d,\r\n"Read EFI %d.%d.\n",\r\nha->efi_revision[1], ha->efi_revision[0]);\r\nbreak;\r\ndefault:\r\nql_log(ql_log_warn, vha, 0x005e,\r\n"Unrecognized code type %x at pcids %x.\n",\r\ncode_type, pcids);\r\nbreak;\r\n}\r\nlast_image = bcode[0x15] & BIT_7;\r\npcihdr += ((bcode[0x11] << 8) | bcode[0x10]) * 512;\r\n} while (!last_image);\r\nmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\r\ndcode = mbuf;\r\nqla24xx_read_flash_data(vha, dcode, ha->flt_region_fw + 4, 4);\r\nfor (i = 0; i < 4; i++)\r\ndcode[i] = be32_to_cpu(dcode[i]);\r\nif ((dcode[0] == 0xffffffff && dcode[1] == 0xffffffff &&\r\ndcode[2] == 0xffffffff && dcode[3] == 0xffffffff) ||\r\n(dcode[0] == 0 && dcode[1] == 0 && dcode[2] == 0 &&\r\ndcode[3] == 0)) {\r\nql_log(ql_log_warn, vha, 0x005f,\r\n"Unrecognized fw revision at %x.\n",\r\nha->flt_region_fw * 4);\r\n} else {\r\nha->fw_revision[0] = dcode[0];\r\nha->fw_revision[1] = dcode[1];\r\nha->fw_revision[2] = dcode[2];\r\nha->fw_revision[3] = dcode[3];\r\nql_dbg(ql_dbg_init, vha, 0x0060,\r\n"Firmware revision %d.%d.%d.%d.\n",\r\nha->fw_revision[0], ha->fw_revision[1],\r\nha->fw_revision[2], ha->fw_revision[3]);\r\n}\r\nif (!IS_QLA81XX(ha)) {\r\nreturn ret;\r\n}\r\nmemset(ha->gold_fw_version, 0, sizeof(ha->gold_fw_version));\r\ndcode = mbuf;\r\nha->isp_ops->read_optrom(vha, (uint8_t *)dcode,\r\nha->flt_region_gold_fw << 2, 32);\r\nif (dcode[4] == 0xFFFFFFFF && dcode[5] == 0xFFFFFFFF &&\r\ndcode[6] == 0xFFFFFFFF && dcode[7] == 0xFFFFFFFF) {\r\nql_log(ql_log_warn, vha, 0x0056,\r\n"Unrecognized golden fw at 0x%x.\n",\r\nha->flt_region_gold_fw * 4);\r\nreturn ret;\r\n}\r\nfor (i = 4; i < 8; i++)\r\nha->gold_fw_version[i-4] = be32_to_cpu(dcode[i]);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla2xxx_is_vpd_valid(uint8_t *pos, uint8_t *end)\r\n{\r\nif (pos >= end || *pos != 0x82)\r\nreturn 0;\r\npos += 3 + pos[1];\r\nif (pos >= end || *pos != 0x90)\r\nreturn 0;\r\npos += 3 + pos[1];\r\nif (pos >= end || *pos != 0x78)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint\r\nqla2xxx_get_vpd_field(scsi_qla_host_t *vha, char *key, char *str, size_t size)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint8_t *pos = ha->vpd;\r\nuint8_t *end = pos + ha->vpd_size;\r\nint len = 0;\r\nif (!IS_FWI2_CAPABLE(ha) || !qla2xxx_is_vpd_valid(pos, end))\r\nreturn 0;\r\nwhile (pos < end && *pos != 0x78) {\r\nlen = (*pos == 0x82) ? pos[1] : pos[2];\r\nif (!strncmp(pos, key, strlen(key)))\r\nbreak;\r\nif (*pos != 0x90 && *pos != 0x91)\r\npos += len;\r\npos += 3;\r\n}\r\nif (pos < end - len && *pos != 0x78)\r\nreturn snprintf(str, size, "%.*s", len, pos + 3);\r\nreturn 0;\r\n}\r\nint\r\nqla24xx_read_fcp_prio_cfg(scsi_qla_host_t *vha)\r\n{\r\nint len, max_len;\r\nuint32_t fcp_prio_addr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->fcp_prio_cfg) {\r\nha->fcp_prio_cfg = vmalloc(FCP_PRIO_CFG_SIZE);\r\nif (!ha->fcp_prio_cfg) {\r\nql_log(ql_log_warn, vha, 0x00d5,\r\n"Unable to allocate memory for fcp priorty data (%x).\n",\r\nFCP_PRIO_CFG_SIZE);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nmemset(ha->fcp_prio_cfg, 0, FCP_PRIO_CFG_SIZE);\r\nfcp_prio_addr = ha->flt_region_fcp_prio;\r\nha->isp_ops->read_optrom(vha, (uint8_t *)ha->fcp_prio_cfg,\r\nfcp_prio_addr << 2, FCP_PRIO_CFG_HDR_SIZE);\r\nif (!qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 0))\r\ngoto fail;\r\nfcp_prio_addr += (FCP_PRIO_CFG_HDR_SIZE >> 2);\r\nlen = ha->fcp_prio_cfg->num_entries * FCP_PRIO_CFG_ENTRY_SIZE;\r\nmax_len = FCP_PRIO_CFG_SIZE - FCP_PRIO_CFG_HDR_SIZE;\r\nha->isp_ops->read_optrom(vha, (uint8_t *)&ha->fcp_prio_cfg->entry[0],\r\nfcp_prio_addr << 2, (len < max_len ? len : max_len));\r\nif (!qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1))\r\ngoto fail;\r\nha->flags.fcp_prio_enabled = 1;\r\nreturn QLA_SUCCESS;\r\nfail:\r\nvfree(ha->fcp_prio_cfg);\r\nha->fcp_prio_cfg = NULL;\r\nreturn QLA_FUNCTION_FAILED;\r\n}
