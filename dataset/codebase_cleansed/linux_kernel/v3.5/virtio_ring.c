static int vring_add_indirect(struct vring_virtqueue *vq,\r\nstruct scatterlist sg[],\r\nunsigned int out,\r\nunsigned int in,\r\ngfp_t gfp)\r\n{\r\nstruct vring_desc *desc;\r\nunsigned head;\r\nint i;\r\ndesc = kmalloc((out + in) * sizeof(struct vring_desc), gfp);\r\nif (!desc)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < out; i++) {\r\ndesc[i].flags = VRING_DESC_F_NEXT;\r\ndesc[i].addr = sg_phys(sg);\r\ndesc[i].len = sg->length;\r\ndesc[i].next = i+1;\r\nsg++;\r\n}\r\nfor (; i < (out + in); i++) {\r\ndesc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;\r\ndesc[i].addr = sg_phys(sg);\r\ndesc[i].len = sg->length;\r\ndesc[i].next = i+1;\r\nsg++;\r\n}\r\ndesc[i-1].flags &= ~VRING_DESC_F_NEXT;\r\ndesc[i-1].next = 0;\r\nvq->num_free--;\r\nhead = vq->free_head;\r\nvq->vring.desc[head].flags = VRING_DESC_F_INDIRECT;\r\nvq->vring.desc[head].addr = virt_to_phys(desc);\r\nvq->vring.desc[head].len = i * sizeof(struct vring_desc);\r\nvq->free_head = vq->vring.desc[head].next;\r\nreturn head;\r\n}\r\nint virtqueue_add_buf(struct virtqueue *_vq,\r\nstruct scatterlist sg[],\r\nunsigned int out,\r\nunsigned int in,\r\nvoid *data,\r\ngfp_t gfp)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nunsigned int i, avail, uninitialized_var(prev);\r\nint head;\r\nSTART_USE(vq);\r\nBUG_ON(data == NULL);\r\n#ifdef DEBUG\r\n{\r\nktime_t now = ktime_get();\r\nif (vq->last_add_time_valid)\r\nWARN_ON(ktime_to_ms(ktime_sub(now, vq->last_add_time))\r\n> 100);\r\nvq->last_add_time = now;\r\nvq->last_add_time_valid = true;\r\n}\r\n#endif\r\nif (vq->indirect && (out + in) > 1 && vq->num_free) {\r\nhead = vring_add_indirect(vq, sg, out, in, gfp);\r\nif (likely(head >= 0))\r\ngoto add_head;\r\n}\r\nBUG_ON(out + in > vq->vring.num);\r\nBUG_ON(out + in == 0);\r\nif (vq->num_free < out + in) {\r\npr_debug("Can't add buf len %i - avail = %i\n",\r\nout + in, vq->num_free);\r\nif (out)\r\nvq->notify(&vq->vq);\r\nEND_USE(vq);\r\nreturn -ENOSPC;\r\n}\r\nvq->num_free -= out + in;\r\nhead = vq->free_head;\r\nfor (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {\r\nvq->vring.desc[i].flags = VRING_DESC_F_NEXT;\r\nvq->vring.desc[i].addr = sg_phys(sg);\r\nvq->vring.desc[i].len = sg->length;\r\nprev = i;\r\nsg++;\r\n}\r\nfor (; in; i = vq->vring.desc[i].next, in--) {\r\nvq->vring.desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;\r\nvq->vring.desc[i].addr = sg_phys(sg);\r\nvq->vring.desc[i].len = sg->length;\r\nprev = i;\r\nsg++;\r\n}\r\nvq->vring.desc[prev].flags &= ~VRING_DESC_F_NEXT;\r\nvq->free_head = i;\r\nadd_head:\r\nvq->data[head] = data;\r\navail = (vq->vring.avail->idx & (vq->vring.num-1));\r\nvq->vring.avail->ring[avail] = head;\r\nvirtio_wmb(vq);\r\nvq->vring.avail->idx++;\r\nvq->num_added++;\r\nif (unlikely(vq->num_added == (1 << 16) - 1))\r\nvirtqueue_kick(_vq);\r\npr_debug("Added buffer head %i to %p\n", head, vq);\r\nEND_USE(vq);\r\nreturn vq->num_free;\r\n}\r\nbool virtqueue_kick_prepare(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nu16 new, old;\r\nbool needs_kick;\r\nSTART_USE(vq);\r\nvirtio_mb(vq);\r\nold = vq->vring.avail->idx - vq->num_added;\r\nnew = vq->vring.avail->idx;\r\nvq->num_added = 0;\r\n#ifdef DEBUG\r\nif (vq->last_add_time_valid) {\r\nWARN_ON(ktime_to_ms(ktime_sub(ktime_get(),\r\nvq->last_add_time)) > 100);\r\n}\r\nvq->last_add_time_valid = false;\r\n#endif\r\nif (vq->event) {\r\nneeds_kick = vring_need_event(vring_avail_event(&vq->vring),\r\nnew, old);\r\n} else {\r\nneeds_kick = !(vq->vring.used->flags & VRING_USED_F_NO_NOTIFY);\r\n}\r\nEND_USE(vq);\r\nreturn needs_kick;\r\n}\r\nvoid virtqueue_notify(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvq->notify(_vq);\r\n}\r\nvoid virtqueue_kick(struct virtqueue *vq)\r\n{\r\nif (virtqueue_kick_prepare(vq))\r\nvirtqueue_notify(vq);\r\n}\r\nstatic void detach_buf(struct vring_virtqueue *vq, unsigned int head)\r\n{\r\nunsigned int i;\r\nvq->data[head] = NULL;\r\ni = head;\r\nif (vq->vring.desc[i].flags & VRING_DESC_F_INDIRECT)\r\nkfree(phys_to_virt(vq->vring.desc[i].addr));\r\nwhile (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {\r\ni = vq->vring.desc[i].next;\r\nvq->num_free++;\r\n}\r\nvq->vring.desc[i].next = vq->free_head;\r\nvq->free_head = head;\r\nvq->num_free++;\r\n}\r\nstatic inline bool more_used(const struct vring_virtqueue *vq)\r\n{\r\nreturn vq->last_used_idx != vq->vring.used->idx;\r\n}\r\nvoid *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvoid *ret;\r\nunsigned int i;\r\nu16 last_used;\r\nSTART_USE(vq);\r\nif (unlikely(vq->broken)) {\r\nEND_USE(vq);\r\nreturn NULL;\r\n}\r\nif (!more_used(vq)) {\r\npr_debug("No more buffers in queue\n");\r\nEND_USE(vq);\r\nreturn NULL;\r\n}\r\nvirtio_rmb(vq);\r\nlast_used = (vq->last_used_idx & (vq->vring.num - 1));\r\ni = vq->vring.used->ring[last_used].id;\r\n*len = vq->vring.used->ring[last_used].len;\r\nif (unlikely(i >= vq->vring.num)) {\r\nBAD_RING(vq, "id %u out of range\n", i);\r\nreturn NULL;\r\n}\r\nif (unlikely(!vq->data[i])) {\r\nBAD_RING(vq, "id %u is not a head!\n", i);\r\nreturn NULL;\r\n}\r\nret = vq->data[i];\r\ndetach_buf(vq, i);\r\nvq->last_used_idx++;\r\nif (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {\r\nvring_used_event(&vq->vring) = vq->last_used_idx;\r\nvirtio_mb(vq);\r\n}\r\n#ifdef DEBUG\r\nvq->last_add_time_valid = false;\r\n#endif\r\nEND_USE(vq);\r\nreturn ret;\r\n}\r\nvoid virtqueue_disable_cb(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;\r\n}\r\nbool virtqueue_enable_cb(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nSTART_USE(vq);\r\nvq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;\r\nvring_used_event(&vq->vring) = vq->last_used_idx;\r\nvirtio_mb(vq);\r\nif (unlikely(more_used(vq))) {\r\nEND_USE(vq);\r\nreturn false;\r\n}\r\nEND_USE(vq);\r\nreturn true;\r\n}\r\nbool virtqueue_enable_cb_delayed(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nu16 bufs;\r\nSTART_USE(vq);\r\nvq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;\r\nbufs = (u16)(vq->vring.avail->idx - vq->last_used_idx) * 3 / 4;\r\nvring_used_event(&vq->vring) = vq->last_used_idx + bufs;\r\nvirtio_mb(vq);\r\nif (unlikely((u16)(vq->vring.used->idx - vq->last_used_idx) > bufs)) {\r\nEND_USE(vq);\r\nreturn false;\r\n}\r\nEND_USE(vq);\r\nreturn true;\r\n}\r\nvoid *virtqueue_detach_unused_buf(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nunsigned int i;\r\nvoid *buf;\r\nSTART_USE(vq);\r\nfor (i = 0; i < vq->vring.num; i++) {\r\nif (!vq->data[i])\r\ncontinue;\r\nbuf = vq->data[i];\r\ndetach_buf(vq, i);\r\nvq->vring.avail->idx--;\r\nEND_USE(vq);\r\nreturn buf;\r\n}\r\nBUG_ON(vq->num_free != vq->vring.num);\r\nEND_USE(vq);\r\nreturn NULL;\r\n}\r\nirqreturn_t vring_interrupt(int irq, void *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nif (!more_used(vq)) {\r\npr_debug("virtqueue interrupt with no work for %p\n", vq);\r\nreturn IRQ_NONE;\r\n}\r\nif (unlikely(vq->broken))\r\nreturn IRQ_HANDLED;\r\npr_debug("virtqueue callback for %p (%p)\n", vq, vq->vq.callback);\r\nif (vq->vq.callback)\r\nvq->vq.callback(&vq->vq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct virtqueue *vring_new_virtqueue(unsigned int num,\r\nunsigned int vring_align,\r\nstruct virtio_device *vdev,\r\nbool weak_barriers,\r\nvoid *pages,\r\nvoid (*notify)(struct virtqueue *),\r\nvoid (*callback)(struct virtqueue *),\r\nconst char *name)\r\n{\r\nstruct vring_virtqueue *vq;\r\nunsigned int i;\r\nif (num & (num - 1)) {\r\ndev_warn(&vdev->dev, "Bad virtqueue length %u\n", num);\r\nreturn NULL;\r\n}\r\nvq = kmalloc(sizeof(*vq) + sizeof(void *)*num, GFP_KERNEL);\r\nif (!vq)\r\nreturn NULL;\r\nvring_init(&vq->vring, num, pages, vring_align);\r\nvq->vq.callback = callback;\r\nvq->vq.vdev = vdev;\r\nvq->vq.name = name;\r\nvq->notify = notify;\r\nvq->weak_barriers = weak_barriers;\r\nvq->broken = false;\r\nvq->last_used_idx = 0;\r\nvq->num_added = 0;\r\nlist_add_tail(&vq->vq.list, &vdev->vqs);\r\n#ifdef DEBUG\r\nvq->in_use = false;\r\nvq->last_add_time_valid = false;\r\n#endif\r\nvq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC);\r\nvq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);\r\nif (!callback)\r\nvq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;\r\nvq->num_free = num;\r\nvq->free_head = 0;\r\nfor (i = 0; i < num-1; i++) {\r\nvq->vring.desc[i].next = i+1;\r\nvq->data[i] = NULL;\r\n}\r\nvq->data[i] = NULL;\r\nreturn &vq->vq;\r\n}\r\nvoid vring_del_virtqueue(struct virtqueue *vq)\r\n{\r\nlist_del(&vq->list);\r\nkfree(to_vvq(vq));\r\n}\r\nvoid vring_transport_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i;\r\nfor (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++) {\r\nswitch (i) {\r\ncase VIRTIO_RING_F_INDIRECT_DESC:\r\nbreak;\r\ncase VIRTIO_RING_F_EVENT_IDX:\r\nbreak;\r\ndefault:\r\nclear_bit(i, vdev->features);\r\n}\r\n}\r\n}\r\nunsigned int virtqueue_get_vring_size(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nreturn vq->vring.num;\r\n}
