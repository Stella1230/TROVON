static struct davinci_gpio_regs __iomem __init *gpio2regs(unsigned gpio)\r\n{\r\nvoid __iomem *ptr;\r\nif (gpio < 32 * 1)\r\nptr = gpio_base + 0x10;\r\nelse if (gpio < 32 * 2)\r\nptr = gpio_base + 0x38;\r\nelse if (gpio < 32 * 3)\r\nptr = gpio_base + 0x60;\r\nelse if (gpio < 32 * 4)\r\nptr = gpio_base + 0x88;\r\nelse if (gpio < 32 * 5)\r\nptr = gpio_base + 0xb0;\r\nelse\r\nptr = NULL;\r\nreturn ptr;\r\n}\r\nstatic inline struct davinci_gpio_regs __iomem *irq2regs(int irq)\r\n{\r\nstruct davinci_gpio_regs __iomem *g;\r\ng = (__force struct davinci_gpio_regs __iomem *)irq_get_chip_data(irq);\r\nreturn g;\r\n}\r\nstatic inline int __davinci_direction(struct gpio_chip *chip,\r\nunsigned offset, bool out, int value)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nstruct davinci_gpio_regs __iomem *g = d->regs;\r\nunsigned long flags;\r\nu32 temp;\r\nu32 mask = 1 << offset;\r\nspin_lock_irqsave(&d->lock, flags);\r\ntemp = __raw_readl(&g->dir);\r\nif (out) {\r\ntemp &= ~mask;\r\n__raw_writel(mask, value ? &g->set_data : &g->clr_data);\r\n} else {\r\ntemp |= mask;\r\n}\r\n__raw_writel(temp, &g->dir);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int davinci_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn __davinci_direction(chip, offset, false, 0);\r\n}\r\nstatic int\r\ndavinci_direction_out(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nreturn __davinci_direction(chip, offset, true, value);\r\n}\r\nstatic int davinci_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nstruct davinci_gpio_regs __iomem *g = d->regs;\r\nreturn (1 << offset) & __raw_readl(&g->in_data);\r\n}\r\nstatic void\r\ndavinci_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nstruct davinci_gpio_regs __iomem *g = d->regs;\r\n__raw_writel((1 << offset), value ? &g->set_data : &g->clr_data);\r\n}\r\nstatic int __init davinci_gpio_setup(void)\r\n{\r\nint i, base;\r\nunsigned ngpio;\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nstruct davinci_gpio_regs *regs;\r\nif (soc_info->gpio_type != GPIO_TYPE_DAVINCI)\r\nreturn 0;\r\nngpio = soc_info->gpio_num;\r\nif (ngpio == 0) {\r\npr_err("GPIO setup: how many GPIOs?\n");\r\nreturn -EINVAL;\r\n}\r\nif (WARN_ON(DAVINCI_N_GPIO < ngpio))\r\nngpio = DAVINCI_N_GPIO;\r\ngpio_base = ioremap(soc_info->gpio_base, SZ_4K);\r\nif (WARN_ON(!gpio_base))\r\nreturn -ENOMEM;\r\nfor (i = 0, base = 0; base < ngpio; i++, base += 32) {\r\nchips[i].chip.label = "DaVinci";\r\nchips[i].chip.direction_input = davinci_direction_in;\r\nchips[i].chip.get = davinci_gpio_get;\r\nchips[i].chip.direction_output = davinci_direction_out;\r\nchips[i].chip.set = davinci_gpio_set;\r\nchips[i].chip.base = base;\r\nchips[i].chip.ngpio = ngpio - base;\r\nif (chips[i].chip.ngpio > 32)\r\nchips[i].chip.ngpio = 32;\r\nspin_lock_init(&chips[i].lock);\r\nregs = gpio2regs(base);\r\nchips[i].regs = regs;\r\nchips[i].set_data = &regs->set_data;\r\nchips[i].clr_data = &regs->clr_data;\r\nchips[i].in_data = &regs->in_data;\r\ngpiochip_add(&chips[i].chip);\r\n}\r\nsoc_info->gpio_ctlrs = chips;\r\nsoc_info->gpio_ctlrs_num = DIV_ROUND_UP(ngpio, 32);\r\ndavinci_gpio_irq_setup();\r\nreturn 0;\r\n}\r\nstatic void gpio_irq_disable(struct irq_data *d)\r\n{\r\nstruct davinci_gpio_regs __iomem *g = irq2regs(d->irq);\r\nu32 mask = (u32) irq_data_get_irq_handler_data(d);\r\n__raw_writel(mask, &g->clr_falling);\r\n__raw_writel(mask, &g->clr_rising);\r\n}\r\nstatic void gpio_irq_enable(struct irq_data *d)\r\n{\r\nstruct davinci_gpio_regs __iomem *g = irq2regs(d->irq);\r\nu32 mask = (u32) irq_data_get_irq_handler_data(d);\r\nunsigned status = irqd_get_trigger_type(d);\r\nstatus &= IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;\r\nif (!status)\r\nstatus = IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;\r\nif (status & IRQ_TYPE_EDGE_FALLING)\r\n__raw_writel(mask, &g->set_falling);\r\nif (status & IRQ_TYPE_EDGE_RISING)\r\n__raw_writel(mask, &g->set_rising);\r\n}\r\nstatic int gpio_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void\r\ngpio_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct davinci_gpio_regs __iomem *g;\r\nu32 mask = 0xffff;\r\nstruct davinci_gpio_controller *d;\r\nd = (struct davinci_gpio_controller *)irq_desc_get_handler_data(desc);\r\ng = (struct davinci_gpio_regs __iomem *)d->regs;\r\nif (irq & 1)\r\nmask <<= 16;\r\ndesc->irq_data.chip->irq_mask(&desc->irq_data);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\nwhile (1) {\r\nu32 status;\r\nint n;\r\nint res;\r\nstatus = __raw_readl(&g->intstat) & mask;\r\nif (!status)\r\nbreak;\r\n__raw_writel(status, &g->intstat);\r\nn = d->irq_base;\r\nif (irq & 1) {\r\nn += 16;\r\nstatus >>= 16;\r\n}\r\nwhile (status) {\r\nres = ffs(status);\r\nn += res;\r\ngeneric_handle_irq(n - 1);\r\nstatus >>= res;\r\n}\r\n}\r\ndesc->irq_data.chip->irq_unmask(&desc->irq_data);\r\n}\r\nstatic int gpio_to_irq_banked(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct davinci_gpio_controller *d = chip2controller(chip);\r\nif (d->irq_base >= 0)\r\nreturn d->irq_base + offset;\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int gpio_to_irq_unbanked(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nif (offset < soc_info->gpio_unbanked)\r\nreturn soc_info->gpio_irq + offset;\r\nelse\r\nreturn -ENODEV;\r\n}\r\nstatic int gpio_irq_type_unbanked(struct irq_data *data, unsigned trigger)\r\n{\r\nstruct davinci_gpio_controller *d;\r\nstruct davinci_gpio_regs __iomem *g;\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nu32 mask;\r\nd = (struct davinci_gpio_controller *)data->handler_data;\r\ng = (struct davinci_gpio_regs __iomem *)d->regs;\r\nmask = __gpio_mask(data->irq - soc_info->gpio_irq);\r\nif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nreturn -EINVAL;\r\n__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_FALLING)\r\n? &g->set_falling : &g->clr_falling);\r\n__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_RISING)\r\n? &g->set_rising : &g->clr_rising);\r\nreturn 0;\r\n}\r\nstatic int __init davinci_gpio_irq_setup(void)\r\n{\r\nunsigned gpio, irq, bank;\r\nstruct clk *clk;\r\nu32 binten = 0;\r\nunsigned ngpio, bank_irq;\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nstruct davinci_gpio_regs __iomem *g;\r\nngpio = soc_info->gpio_num;\r\nbank_irq = soc_info->gpio_irq;\r\nif (bank_irq == 0) {\r\nprintk(KERN_ERR "Don't know first GPIO bank IRQ.\n");\r\nreturn -EINVAL;\r\n}\r\nclk = clk_get(NULL, "gpio");\r\nif (IS_ERR(clk)) {\r\nprintk(KERN_ERR "Error %ld getting gpio clock?\n",\r\nPTR_ERR(clk));\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_enable(clk);\r\nfor (gpio = 0, bank = 0; gpio < ngpio; bank++, gpio += 32) {\r\nchips[bank].chip.to_irq = gpio_to_irq_banked;\r\nchips[bank].irq_base = soc_info->gpio_unbanked\r\n? -EINVAL\r\n: (soc_info->intc_irq_num + gpio);\r\n}\r\nif (soc_info->gpio_unbanked) {\r\nstatic struct irq_chip_type gpio_unbanked;\r\nchips[0].chip.to_irq = gpio_to_irq_unbanked;\r\nbinten = BIT(0);\r\nirq = bank_irq;\r\ngpio_unbanked = *container_of(irq_get_chip(irq),\r\nstruct irq_chip_type, chip);\r\ngpio_unbanked.chip.name = "GPIO-AINTC";\r\ngpio_unbanked.chip.irq_set_type = gpio_irq_type_unbanked;\r\ng = gpio2regs(0);\r\n__raw_writel(~0, &g->set_falling);\r\n__raw_writel(~0, &g->set_rising);\r\nfor (gpio = 0; gpio < soc_info->gpio_unbanked; gpio++, irq++) {\r\nirq_set_chip(irq, &gpio_unbanked.chip);\r\nirq_set_handler_data(irq, &chips[gpio / 32]);\r\nirq_set_status_flags(irq, IRQ_TYPE_EDGE_BOTH);\r\n}\r\ngoto done;\r\n}\r\nfor (gpio = 0, irq = gpio_to_irq(0), bank = 0;\r\ngpio < ngpio;\r\nbank++, bank_irq++) {\r\nunsigned i;\r\ng = gpio2regs(gpio);\r\n__raw_writel(~0, &g->clr_falling);\r\n__raw_writel(~0, &g->clr_rising);\r\nirq_set_chained_handler(bank_irq, gpio_irq_handler);\r\nirq_set_handler_data(bank_irq, &chips[gpio / 32]);\r\nfor (i = 0; i < 16 && gpio < ngpio; i++, irq++, gpio++) {\r\nirq_set_chip(irq, &gpio_irqchip);\r\nirq_set_chip_data(irq, (__force void *)g);\r\nirq_set_handler_data(irq, (void *)__gpio_mask(gpio));\r\nirq_set_handler(irq, handle_simple_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\nbinten |= BIT(bank);\r\n}\r\ndone:\r\n__raw_writel(binten, gpio_base + 0x08);\r\nprintk(KERN_INFO "DaVinci: %d gpio irqs\n", irq - gpio_to_irq(0));\r\nreturn 0;\r\n}
