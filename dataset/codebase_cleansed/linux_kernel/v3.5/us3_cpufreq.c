static unsigned long read_safari_cfg(void)\r\n{\r\nunsigned long ret;\r\n__asm__ __volatile__("ldxa [%%g0] %1, %0"\r\n: "=&r" (ret)\r\n: "i" (ASI_SAFARI_CONFIG));\r\nreturn ret;\r\n}\r\nstatic void write_safari_cfg(unsigned long val)\r\n{\r\n__asm__ __volatile__("stxa %0, [%%g0] %1\n\t"\r\n"membar #Sync"\r\n:\r\n: "r" (val), "i" (ASI_SAFARI_CONFIG)\r\n: "memory");\r\n}\r\nstatic unsigned long get_current_freq(unsigned int cpu, unsigned long safari_cfg)\r\n{\r\nunsigned long clock_tick = sparc64_get_clock_tick(cpu) / 1000;\r\nunsigned long ret;\r\nswitch (safari_cfg & SAFARI_CFG_DIV_MASK) {\r\ncase SAFARI_CFG_DIV_1:\r\nret = clock_tick / 1;\r\nbreak;\r\ncase SAFARI_CFG_DIV_2:\r\nret = clock_tick / 2;\r\nbreak;\r\ncase SAFARI_CFG_DIV_32:\r\nret = clock_tick / 32;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int us3_freq_get(unsigned int cpu)\r\n{\r\ncpumask_t cpus_allowed;\r\nunsigned long reg;\r\nunsigned int ret;\r\nif (!cpu_online(cpu))\r\nreturn 0;\r\ncpumask_copy(&cpus_allowed, tsk_cpus_allowed(current));\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nreg = read_safari_cfg();\r\nret = get_current_freq(cpu, reg);\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\nreturn ret;\r\n}\r\nstatic void us3_set_cpu_divider_index(unsigned int cpu, unsigned int index)\r\n{\r\nunsigned long new_bits, new_freq, reg;\r\ncpumask_t cpus_allowed;\r\nstruct cpufreq_freqs freqs;\r\nif (!cpu_online(cpu))\r\nreturn;\r\ncpumask_copy(&cpus_allowed, tsk_cpus_allowed(current));\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nnew_freq = sparc64_get_clock_tick(cpu) / 1000;\r\nswitch (index) {\r\ncase 0:\r\nnew_bits = SAFARI_CFG_DIV_1;\r\nnew_freq /= 1;\r\nbreak;\r\ncase 1:\r\nnew_bits = SAFARI_CFG_DIV_2;\r\nnew_freq /= 2;\r\nbreak;\r\ncase 2:\r\nnew_bits = SAFARI_CFG_DIV_32;\r\nnew_freq /= 32;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreg = read_safari_cfg();\r\nfreqs.old = get_current_freq(cpu, reg);\r\nfreqs.new = new_freq;\r\nfreqs.cpu = cpu;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\nreg &= ~SAFARI_CFG_DIV_MASK;\r\nreg |= new_bits;\r\nwrite_safari_cfg(reg);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nset_cpus_allowed_ptr(current, &cpus_allowed);\r\n}\r\nstatic int us3_freq_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int new_index = 0;\r\nif (cpufreq_frequency_table_target(policy,\r\n&us3_freq_table[policy->cpu].table[0],\r\ntarget_freq,\r\nrelation,\r\n&new_index))\r\nreturn -EINVAL;\r\nus3_set_cpu_divider_index(policy->cpu, new_index);\r\nreturn 0;\r\n}\r\nstatic int us3_freq_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy,\r\n&us3_freq_table[policy->cpu].table[0]);\r\n}\r\nstatic int __init us3_freq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nunsigned long clock_tick = sparc64_get_clock_tick(cpu) / 1000;\r\nstruct cpufreq_frequency_table *table =\r\n&us3_freq_table[cpu].table[0];\r\ntable[0].index = 0;\r\ntable[0].frequency = clock_tick / 1;\r\ntable[1].index = 1;\r\ntable[1].frequency = clock_tick / 2;\r\ntable[2].index = 2;\r\ntable[2].frequency = clock_tick / 32;\r\ntable[3].index = 0;\r\ntable[3].frequency = CPUFREQ_TABLE_END;\r\npolicy->cpuinfo.transition_latency = 0;\r\npolicy->cur = clock_tick;\r\nreturn cpufreq_frequency_table_cpuinfo(policy, table);\r\n}\r\nstatic int us3_freq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nif (cpufreq_us3_driver)\r\nus3_set_cpu_divider_index(policy->cpu, 0);\r\nreturn 0;\r\n}\r\nstatic int __init us3_freq_init(void)\r\n{\r\nunsigned long manuf, impl, ver;\r\nint ret;\r\nif (tlb_type != cheetah && tlb_type != cheetah_plus)\r\nreturn -ENODEV;\r\n__asm__("rdpr %%ver, %0" : "=r" (ver));\r\nmanuf = ((ver >> 48) & 0xffff);\r\nimpl = ((ver >> 32) & 0xffff);\r\nif (manuf == CHEETAH_MANUF &&\r\n(impl == CHEETAH_IMPL ||\r\nimpl == CHEETAH_PLUS_IMPL ||\r\nimpl == JAGUAR_IMPL ||\r\nimpl == PANTHER_IMPL)) {\r\nstruct cpufreq_driver *driver;\r\nret = -ENOMEM;\r\ndriver = kzalloc(sizeof(struct cpufreq_driver), GFP_KERNEL);\r\nif (!driver)\r\ngoto err_out;\r\nus3_freq_table = kzalloc(\r\n(NR_CPUS * sizeof(struct us3_freq_percpu_info)),\r\nGFP_KERNEL);\r\nif (!us3_freq_table)\r\ngoto err_out;\r\ndriver->init = us3_freq_cpu_init;\r\ndriver->verify = us3_freq_verify;\r\ndriver->target = us3_freq_target;\r\ndriver->get = us3_freq_get;\r\ndriver->exit = us3_freq_cpu_exit;\r\ndriver->owner = THIS_MODULE,\r\nstrcpy(driver->name, "UltraSPARC-III");\r\ncpufreq_us3_driver = driver;\r\nret = cpufreq_register_driver(driver);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\nif (driver) {\r\nkfree(driver);\r\ncpufreq_us3_driver = NULL;\r\n}\r\nkfree(us3_freq_table);\r\nus3_freq_table = NULL;\r\nreturn ret;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit us3_freq_exit(void)\r\n{\r\nif (cpufreq_us3_driver) {\r\ncpufreq_unregister_driver(cpufreq_us3_driver);\r\nkfree(cpufreq_us3_driver);\r\ncpufreq_us3_driver = NULL;\r\nkfree(us3_freq_table);\r\nus3_freq_table = NULL;\r\n}\r\n}
