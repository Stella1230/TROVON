struct sas_task *sas_alloc_task(gfp_t flags)\r\n{\r\nstruct sas_task *task = kmem_cache_zalloc(sas_task_cache, flags);\r\nif (task) {\r\nINIT_LIST_HEAD(&task->list);\r\nspin_lock_init(&task->task_state_lock);\r\ntask->task_state_flags = SAS_TASK_STATE_PENDING;\r\ninit_timer(&task->timer);\r\ninit_completion(&task->completion);\r\n}\r\nreturn task;\r\n}\r\nvoid sas_free_task(struct sas_task *task)\r\n{\r\nif (task) {\r\nBUG_ON(!list_empty(&task->list));\r\nkmem_cache_free(sas_task_cache, task);\r\n}\r\n}\r\nvoid sas_hash_addr(u8 *hashed, const u8 *sas_addr)\r\n{\r\nconst u32 poly = 0x00DB2777;\r\nu32 r = 0;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nint b;\r\nfor (b = 7; b >= 0; b--) {\r\nr <<= 1;\r\nif ((1 << b) & sas_addr[i]) {\r\nif (!(r & 0x01000000))\r\nr ^= poly;\r\n} else if (r & 0x01000000)\r\nr ^= poly;\r\n}\r\n}\r\nhashed[0] = (r >> 16) & 0xFF;\r\nhashed[1] = (r >> 8) & 0xFF ;\r\nhashed[2] = r & 0xFF;\r\n}\r\nvoid sas_hae_reset(struct work_struct *work)\r\n{\r\nstruct sas_ha_event *ev = to_sas_ha_event(work);\r\nstruct sas_ha_struct *ha = ev->ha;\r\nclear_bit(HAE_RESET, &ha->pending);\r\n}\r\nint sas_register_ha(struct sas_ha_struct *sas_ha)\r\n{\r\nint error = 0;\r\nmutex_init(&sas_ha->disco_mutex);\r\nspin_lock_init(&sas_ha->phy_port_lock);\r\nsas_hash_addr(sas_ha->hashed_sas_addr, sas_ha->sas_addr);\r\nif (sas_ha->lldd_queue_size == 0)\r\nsas_ha->lldd_queue_size = 1;\r\nelse if (sas_ha->lldd_queue_size == -1)\r\nsas_ha->lldd_queue_size = 128;\r\nset_bit(SAS_HA_REGISTERED, &sas_ha->state);\r\nspin_lock_init(&sas_ha->state_lock);\r\nmutex_init(&sas_ha->drain_mutex);\r\nINIT_LIST_HEAD(&sas_ha->defer_q);\r\nerror = sas_register_phys(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't register sas phys:%d\n", error);\r\nreturn error;\r\n}\r\nerror = sas_register_ports(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't register sas ports:%d\n", error);\r\ngoto Undo_phys;\r\n}\r\nerror = sas_init_events(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't start event thread:%d\n", error);\r\ngoto Undo_ports;\r\n}\r\nif (sas_ha->lldd_max_execute_num > 1) {\r\nerror = sas_init_queue(sas_ha);\r\nif (error) {\r\nprintk(KERN_NOTICE "couldn't start queue thread:%d, "\r\n"running in direct mode\n", error);\r\nsas_ha->lldd_max_execute_num = 1;\r\n}\r\n}\r\nINIT_LIST_HEAD(&sas_ha->eh_done_q);\r\nINIT_LIST_HEAD(&sas_ha->eh_ata_q);\r\nreturn 0;\r\nUndo_ports:\r\nsas_unregister_ports(sas_ha);\r\nUndo_phys:\r\nreturn error;\r\n}\r\nint sas_unregister_ha(struct sas_ha_struct *sas_ha)\r\n{\r\nmutex_lock(&sas_ha->drain_mutex);\r\nspin_lock_irq(&sas_ha->state_lock);\r\nclear_bit(SAS_HA_REGISTERED, &sas_ha->state);\r\nspin_unlock_irq(&sas_ha->state_lock);\r\n__sas_drain_work(sas_ha);\r\nmutex_unlock(&sas_ha->drain_mutex);\r\nsas_unregister_ports(sas_ha);\r\nmutex_lock(&sas_ha->drain_mutex);\r\n__sas_drain_work(sas_ha);\r\nmutex_unlock(&sas_ha->drain_mutex);\r\nif (sas_ha->lldd_max_execute_num > 1) {\r\nsas_shutdown_queue(sas_ha);\r\nsas_ha->lldd_max_execute_num = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sas_get_linkerrors(struct sas_phy *phy)\r\n{\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nreturn i->dft->lldd_control_phy(asd_phy, PHY_FUNC_GET_EVENTS, NULL);\r\n}\r\nreturn sas_smp_get_phy_events(phy);\r\n}\r\nint sas_try_ata_reset(struct asd_sas_phy *asd_phy)\r\n{\r\nstruct domain_device *dev = NULL;\r\nif (asd_phy->port)\r\ndev = asd_phy->port->port_dev;\r\nif (dev)\r\ndev = sas_find_dev_by_rphy(dev->rphy);\r\nif (dev && dev_is_sata(dev)) {\r\nsas_ata_schedule_reset(dev);\r\nsas_ata_wait_eh(dev);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int transport_sas_phy_reset(struct sas_phy *phy, int hard_reset)\r\n{\r\nenum phy_func reset_type;\r\nif (hard_reset)\r\nreset_type = PHY_FUNC_HARD_RESET;\r\nelse\r\nreset_type = PHY_FUNC_LINK_RESET;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nif (!hard_reset && sas_try_ata_reset(asd_phy) == 0)\r\nreturn 0;\r\nreturn i->dft->lldd_control_phy(asd_phy, reset_type, NULL);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nstruct domain_device *ata_dev = sas_ex_to_ata(ddev, phy->number);\r\nif (ata_dev && !hard_reset) {\r\nsas_ata_schedule_reset(ata_dev);\r\nsas_ata_wait_eh(ata_dev);\r\nreturn 0;\r\n} else\r\nreturn sas_smp_phy_control(ddev, phy->number, reset_type, NULL);\r\n}\r\n}\r\nstatic int sas_phy_enable(struct sas_phy *phy, int enable)\r\n{\r\nint ret;\r\nenum phy_func cmd;\r\nif (enable)\r\ncmd = PHY_FUNC_LINK_RESET;\r\nelse\r\ncmd = PHY_FUNC_DISABLE;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nif (enable)\r\nret = transport_sas_phy_reset(phy, 0);\r\nelse\r\nret = i->dft->lldd_control_phy(asd_phy, cmd, NULL);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nif (enable)\r\nret = transport_sas_phy_reset(phy, 0);\r\nelse\r\nret = sas_smp_phy_control(ddev, phy->number, cmd, NULL);\r\n}\r\nreturn ret;\r\n}\r\nint sas_phy_reset(struct sas_phy *phy, int hard_reset)\r\n{\r\nint ret;\r\nenum phy_func reset_type;\r\nif (!phy->enabled)\r\nreturn -ENODEV;\r\nif (hard_reset)\r\nreset_type = PHY_FUNC_HARD_RESET;\r\nelse\r\nreset_type = PHY_FUNC_LINK_RESET;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nret = i->dft->lldd_control_phy(asd_phy, reset_type, NULL);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nret = sas_smp_phy_control(ddev, phy->number, reset_type, NULL);\r\n}\r\nreturn ret;\r\n}\r\nint sas_set_phy_speed(struct sas_phy *phy,\r\nstruct sas_phy_linkrates *rates)\r\n{\r\nint ret;\r\nif ((rates->minimum_linkrate &&\r\nrates->minimum_linkrate > phy->maximum_linkrate) ||\r\n(rates->maximum_linkrate &&\r\nrates->maximum_linkrate < phy->minimum_linkrate))\r\nreturn -EINVAL;\r\nif (rates->minimum_linkrate &&\r\nrates->minimum_linkrate < phy->minimum_linkrate_hw)\r\nrates->minimum_linkrate = phy->minimum_linkrate_hw;\r\nif (rates->maximum_linkrate &&\r\nrates->maximum_linkrate > phy->maximum_linkrate_hw)\r\nrates->maximum_linkrate = phy->maximum_linkrate_hw;\r\nif (scsi_is_sas_phy_local(phy)) {\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nret = i->dft->lldd_control_phy(asd_phy, PHY_FUNC_SET_LINK_RATE,\r\nrates);\r\n} else {\r\nstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\r\nstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\r\nret = sas_smp_phy_control(ddev, phy->number,\r\nPHY_FUNC_LINK_RESET, rates);\r\n}\r\nreturn ret;\r\n}\r\nstatic void sas_phy_release(struct sas_phy *phy)\r\n{\r\nkfree(phy->hostdata);\r\nphy->hostdata = NULL;\r\n}\r\nstatic void phy_reset_work(struct work_struct *work)\r\n{\r\nstruct sas_phy_data *d = container_of(work, typeof(*d), reset_work.work);\r\nd->reset_result = transport_sas_phy_reset(d->phy, d->hard_reset);\r\n}\r\nstatic void phy_enable_work(struct work_struct *work)\r\n{\r\nstruct sas_phy_data *d = container_of(work, typeof(*d), enable_work.work);\r\nd->enable_result = sas_phy_enable(d->phy, d->enable);\r\n}\r\nstatic int sas_phy_setup(struct sas_phy *phy)\r\n{\r\nstruct sas_phy_data *d = kzalloc(sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nmutex_init(&d->event_lock);\r\nINIT_SAS_WORK(&d->reset_work, phy_reset_work);\r\nINIT_SAS_WORK(&d->enable_work, phy_enable_work);\r\nd->phy = phy;\r\nphy->hostdata = d;\r\nreturn 0;\r\n}\r\nstatic int queue_phy_reset(struct sas_phy *phy, int hard_reset)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nstruct sas_phy_data *d = phy->hostdata;\r\nint rc;\r\nif (!d)\r\nreturn -ENOMEM;\r\nmutex_lock(&d->event_lock);\r\nd->reset_result = 0;\r\nd->hard_reset = hard_reset;\r\nspin_lock_irq(&ha->state_lock);\r\nsas_queue_work(ha, &d->reset_work);\r\nspin_unlock_irq(&ha->state_lock);\r\nrc = sas_drain_work(ha);\r\nif (rc == 0)\r\nrc = d->reset_result;\r\nmutex_unlock(&d->event_lock);\r\nreturn rc;\r\n}\r\nstatic int queue_phy_enable(struct sas_phy *phy, int enable)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\r\nstruct sas_phy_data *d = phy->hostdata;\r\nint rc;\r\nif (!d)\r\nreturn -ENOMEM;\r\nmutex_lock(&d->event_lock);\r\nd->enable_result = 0;\r\nd->enable = enable;\r\nspin_lock_irq(&ha->state_lock);\r\nsas_queue_work(ha, &d->enable_work);\r\nspin_unlock_irq(&ha->state_lock);\r\nrc = sas_drain_work(ha);\r\nif (rc == 0)\r\nrc = d->enable_result;\r\nmutex_unlock(&d->event_lock);\r\nreturn rc;\r\n}\r\nstruct scsi_transport_template *\r\nsas_domain_attach_transport(struct sas_domain_function_template *dft)\r\n{\r\nstruct scsi_transport_template *stt = sas_attach_transport(&sft);\r\nstruct sas_internal *i;\r\nif (!stt)\r\nreturn stt;\r\ni = to_sas_internal(stt);\r\ni->dft = dft;\r\nstt->create_work_queue = 1;\r\nstt->eh_timed_out = sas_scsi_timed_out;\r\nstt->eh_strategy_handler = sas_scsi_recover_host;\r\nreturn stt;\r\n}\r\nvoid sas_domain_release_transport(struct scsi_transport_template *stt)\r\n{\r\nsas_release_transport(stt);\r\n}\r\nstatic int __init sas_class_init(void)\r\n{\r\nsas_task_cache = KMEM_CACHE(sas_task, SLAB_HWCACHE_ALIGN);\r\nif (!sas_task_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit sas_class_exit(void)\r\n{\r\nkmem_cache_destroy(sas_task_cache);\r\n}
