static int lp855x_read_byte(struct lp855x *lp, u8 reg, u8 *data)\r\n{\r\nint ret;\r\nmutex_lock(&lp->xfer_lock);\r\nret = i2c_smbus_read_byte_data(lp->client, reg);\r\nif (ret < 0) {\r\nmutex_unlock(&lp->xfer_lock);\r\ndev_err(lp->dev, "failed to read 0x%.2x\n", reg);\r\nreturn ret;\r\n}\r\nmutex_unlock(&lp->xfer_lock);\r\n*data = (u8)ret;\r\nreturn 0;\r\n}\r\nstatic int lp855x_write_byte(struct lp855x *lp, u8 reg, u8 data)\r\n{\r\nint ret;\r\nmutex_lock(&lp->xfer_lock);\r\nret = i2c_smbus_write_byte_data(lp->client, reg, data);\r\nmutex_unlock(&lp->xfer_lock);\r\nreturn ret;\r\n}\r\nstatic bool lp855x_is_valid_rom_area(struct lp855x *lp, u8 addr)\r\n{\r\nu8 start, end;\r\nswitch (lp->chip_id) {\r\ncase LP8550:\r\ncase LP8551:\r\ncase LP8552:\r\ncase LP8553:\r\nstart = EEPROM_START;\r\nend = EEPROM_END;\r\nbreak;\r\ncase LP8556:\r\nstart = EPROM_START;\r\nend = EPROM_END;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn (addr >= start && addr <= end);\r\n}\r\nstatic int lp855x_init_registers(struct lp855x *lp)\r\n{\r\nu8 val, addr;\r\nint i, ret;\r\nstruct lp855x_platform_data *pd = lp->pdata;\r\nval = pd->initial_brightness;\r\nret = lp855x_write_byte(lp, BRIGHTNESS_CTRL, val);\r\nif (ret)\r\nreturn ret;\r\nval = pd->device_control;\r\nret = lp855x_write_byte(lp, DEVICE_CTRL, val);\r\nif (ret)\r\nreturn ret;\r\nif (pd->load_new_rom_data && pd->size_program) {\r\nfor (i = 0; i < pd->size_program; i++) {\r\naddr = pd->rom_data[i].addr;\r\nval = pd->rom_data[i].val;\r\nif (!lp855x_is_valid_rom_area(lp, addr))\r\ncontinue;\r\nret = lp855x_write_byte(lp, addr, val);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int lp855x_bl_update_status(struct backlight_device *bl)\r\n{\r\nstruct lp855x *lp = bl_get_data(bl);\r\nenum lp855x_brightness_ctrl_mode mode = lp->pdata->mode;\r\nif (bl->props.state & BL_CORE_SUSPENDED)\r\nbl->props.brightness = 0;\r\nif (mode == PWM_BASED) {\r\nstruct lp855x_pwm_data *pd = &lp->pdata->pwm_data;\r\nint br = bl->props.brightness;\r\nint max_br = bl->props.max_brightness;\r\nif (pd->pwm_set_intensity)\r\npd->pwm_set_intensity(br, max_br);\r\n} else if (mode == REGISTER_BASED) {\r\nu8 val = bl->props.brightness;\r\nlp855x_write_byte(lp, BRIGHTNESS_CTRL, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp855x_bl_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct lp855x *lp = bl_get_data(bl);\r\nenum lp855x_brightness_ctrl_mode mode = lp->pdata->mode;\r\nif (mode == PWM_BASED) {\r\nstruct lp855x_pwm_data *pd = &lp->pdata->pwm_data;\r\nint max_br = bl->props.max_brightness;\r\nif (pd->pwm_get_intensity)\r\nbl->props.brightness = pd->pwm_get_intensity(max_br);\r\n} else if (mode == REGISTER_BASED) {\r\nu8 val = 0;\r\nlp855x_read_byte(lp, BRIGHTNESS_CTRL, &val);\r\nbl->props.brightness = val;\r\n}\r\nreturn bl->props.brightness;\r\n}\r\nstatic int lp855x_backlight_register(struct lp855x *lp)\r\n{\r\nstruct backlight_device *bl;\r\nstruct backlight_properties props;\r\nstruct lp855x_platform_data *pdata = lp->pdata;\r\nchar *name = pdata->name ? : DEFAULT_BL_NAME;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nif (pdata->initial_brightness > props.max_brightness)\r\npdata->initial_brightness = props.max_brightness;\r\nprops.brightness = pdata->initial_brightness;\r\nbl = backlight_device_register(name, lp->dev, lp,\r\n&lp855x_bl_ops, &props);\r\nif (IS_ERR(bl))\r\nreturn PTR_ERR(bl);\r\nlp->bl = bl;\r\nreturn 0;\r\n}\r\nstatic void lp855x_backlight_unregister(struct lp855x *lp)\r\n{\r\nif (lp->bl)\r\nbacklight_device_unregister(lp->bl);\r\n}\r\nstatic ssize_t lp855x_get_chip_id(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp855x *lp = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, BUF_SIZE, "%s\n", lp->chipname);\r\n}\r\nstatic ssize_t lp855x_get_bl_ctl_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp855x *lp = dev_get_drvdata(dev);\r\nenum lp855x_brightness_ctrl_mode mode = lp->pdata->mode;\r\nchar *strmode = NULL;\r\nif (mode == PWM_BASED)\r\nstrmode = "pwm based";\r\nelse if (mode == REGISTER_BASED)\r\nstrmode = "register based";\r\nreturn scnprintf(buf, BUF_SIZE, "%s\n", strmode);\r\n}\r\nstatic int lp855x_probe(struct i2c_client *cl, const struct i2c_device_id *id)\r\n{\r\nstruct lp855x *lp;\r\nstruct lp855x_platform_data *pdata = cl->dev.platform_data;\r\nenum lp855x_brightness_ctrl_mode mode;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&cl->dev, "no platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(cl->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -EIO;\r\nlp = devm_kzalloc(&cl->dev, sizeof(struct lp855x), GFP_KERNEL);\r\nif (!lp)\r\nreturn -ENOMEM;\r\nmode = pdata->mode;\r\nlp->client = cl;\r\nlp->dev = &cl->dev;\r\nlp->pdata = pdata;\r\nlp->chipname = id->name;\r\nlp->chip_id = id->driver_data;\r\ni2c_set_clientdata(cl, lp);\r\nmutex_init(&lp->xfer_lock);\r\nret = lp855x_init_registers(lp);\r\nif (ret) {\r\ndev_err(lp->dev, "i2c communication err: %d", ret);\r\nif (mode == REGISTER_BASED)\r\ngoto err_dev;\r\n}\r\nret = lp855x_backlight_register(lp);\r\nif (ret) {\r\ndev_err(lp->dev,\r\n"failed to register backlight. err: %d\n", ret);\r\ngoto err_dev;\r\n}\r\nret = sysfs_create_group(&lp->dev->kobj, &lp855x_attr_group);\r\nif (ret) {\r\ndev_err(lp->dev, "failed to register sysfs. err: %d\n", ret);\r\ngoto err_sysfs;\r\n}\r\nbacklight_update_status(lp->bl);\r\nreturn 0;\r\nerr_sysfs:\r\nlp855x_backlight_unregister(lp);\r\nerr_dev:\r\nreturn ret;\r\n}\r\nstatic int __devexit lp855x_remove(struct i2c_client *cl)\r\n{\r\nstruct lp855x *lp = i2c_get_clientdata(cl);\r\nlp->bl->props.brightness = 0;\r\nbacklight_update_status(lp->bl);\r\nsysfs_remove_group(&lp->dev->kobj, &lp855x_attr_group);\r\nlp855x_backlight_unregister(lp);\r\nreturn 0;\r\n}
