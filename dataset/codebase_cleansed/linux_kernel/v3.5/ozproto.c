static u8 oz_get_new_session_id(u8 exclude)\r\n{\r\nif (++g_session_id == 0)\r\ng_session_id = 1;\r\nif (g_session_id == exclude) {\r\nif (++g_session_id == 0)\r\ng_session_id = 1;\r\n}\r\nreturn g_session_id;\r\n}\r\nstatic void oz_send_conn_rsp(struct oz_pd *pd, u8 status)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net_device *dev = pd->net_dev;\r\nstruct oz_hdr *oz_hdr;\r\nstruct oz_elt *elt;\r\nstruct oz_elt_connect_rsp *body;\r\nint sz = sizeof(struct oz_hdr) + sizeof(struct oz_elt) +\r\nsizeof(struct oz_elt_connect_rsp);\r\nskb = alloc_skb(sz + OZ_ALLOCATED_SPACE(dev), GFP_ATOMIC);\r\nif (skb == 0)\r\nreturn;\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nskb_reset_network_header(skb);\r\noz_hdr = (struct oz_hdr *)skb_put(skb, sz);\r\nelt = (struct oz_elt *)(oz_hdr+1);\r\nbody = (struct oz_elt_connect_rsp *)(elt+1);\r\nskb->dev = dev;\r\nskb->protocol = htons(OZ_ETHERTYPE);\r\nif (dev_hard_header(skb, dev, OZ_ETHERTYPE, pd->mac_addr,\r\ndev->dev_addr, skb->len) < 0) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\noz_hdr->control = (OZ_PROTOCOL_VERSION<<OZ_VERSION_SHIFT);\r\noz_hdr->last_pkt_num = 0;\r\nput_unaligned(0, &oz_hdr->pkt_num);\r\noz_event_log(OZ_EVT_CONNECT_RSP, 0, 0, 0, 0);\r\nelt->type = OZ_ELT_CONNECT_RSP;\r\nelt->length = sizeof(struct oz_elt_connect_rsp);\r\nmemset(body, 0, sizeof(struct oz_elt_connect_rsp));\r\nbody->status = status;\r\nif (status == 0) {\r\nbody->mode = pd->mode;\r\nbody->session_id = pd->session_id;\r\nput_unaligned(cpu_to_le16(pd->total_apps), &body->apps);\r\n}\r\noz_trace("TX: OZ_ELT_CONNECT_RSP %d", status);\r\ndev_queue_xmit(skb);\r\nreturn;\r\n}\r\nstatic void pd_set_keepalive(struct oz_pd *pd, u8 kalive)\r\n{\r\nunsigned long keep_alive = kalive & OZ_KALIVE_VALUE_MASK;\r\nswitch (kalive & OZ_KALIVE_TYPE_MASK) {\r\ncase OZ_KALIVE_SPECIAL:\r\npd->keep_alive_j =\r\noz_ms_to_jiffies(keep_alive * 1000*60*60*24*20);\r\nbreak;\r\ncase OZ_KALIVE_SECS:\r\npd->keep_alive_j = oz_ms_to_jiffies(keep_alive*1000);\r\nbreak;\r\ncase OZ_KALIVE_MINS:\r\npd->keep_alive_j = oz_ms_to_jiffies(keep_alive*1000*60);\r\nbreak;\r\ncase OZ_KALIVE_HOURS:\r\npd->keep_alive_j = oz_ms_to_jiffies(keep_alive*1000*60*60);\r\nbreak;\r\ndefault:\r\npd->keep_alive_j = 0;\r\n}\r\noz_trace("Keepalive = %lu jiffies\n", pd->keep_alive_j);\r\n}\r\nstatic void pd_set_presleep(struct oz_pd *pd, u8 presleep)\r\n{\r\nif (presleep)\r\npd->presleep_j = oz_ms_to_jiffies(presleep*100);\r\nelse\r\npd->presleep_j = OZ_PRESLEEP_TOUT_J;\r\noz_trace("Presleep time = %lu jiffies\n", pd->presleep_j);\r\n}\r\nstatic struct oz_pd *oz_connect_req(struct oz_pd *cur_pd, struct oz_elt *elt,\r\nu8 *pd_addr, struct net_device *net_dev)\r\n{\r\nstruct oz_pd *pd;\r\nstruct oz_elt_connect_req *body =\r\n(struct oz_elt_connect_req *)(elt+1);\r\nu8 rsp_status = OZ_STATUS_SUCCESS;\r\nu8 stop_needed = 0;\r\nu16 new_apps = g_apps;\r\nstruct net_device *old_net_dev = 0;\r\nstruct oz_pd *free_pd = 0;\r\nif (cur_pd) {\r\npd = cur_pd;\r\nspin_lock_bh(&g_polling_lock);\r\n} else {\r\nstruct oz_pd *pd2 = 0;\r\nstruct list_head *e;\r\npd = oz_pd_alloc(pd_addr);\r\nif (pd == 0)\r\nreturn 0;\r\npd->last_rx_time_j = jiffies;\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each(e, &g_pd_list) {\r\npd2 = container_of(e, struct oz_pd, link);\r\nif (memcmp(pd2->mac_addr, pd_addr, ETH_ALEN) == 0) {\r\nfree_pd = pd;\r\npd = pd2;\r\nbreak;\r\n}\r\n}\r\nif (pd != pd2)\r\nlist_add_tail(&pd->link, &g_pd_list);\r\n}\r\nif (pd == 0) {\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn 0;\r\n}\r\nif (pd->net_dev != net_dev) {\r\nold_net_dev = pd->net_dev;\r\ndev_hold(net_dev);\r\npd->net_dev = net_dev;\r\n}\r\noz_trace("Host vendor: %d\n", body->host_vendor);\r\npd->max_tx_size = OZ_MAX_TX_SIZE;\r\npd->mode = body->mode;\r\npd->pd_info = body->pd_info;\r\nif (pd->mode & OZ_F_ISOC_NO_ELTS) {\r\npd->mode |= OZ_F_ISOC_ANYTIME;\r\npd->ms_per_isoc = body->ms_per_isoc;\r\nif (!pd->ms_per_isoc)\r\npd->ms_per_isoc = 4;\r\n}\r\nif (body->max_len_div16)\r\npd->max_tx_size = ((u16)body->max_len_div16)<<4;\r\noz_trace("Max frame:%u Ms per isoc:%u\n",\r\npd->max_tx_size, pd->ms_per_isoc);\r\npd->max_stream_buffering = 3*1024;\r\npd->timeout_time_j = jiffies + OZ_CONNECTION_TOUT_J;\r\npd->pulse_period_j = OZ_QUANTUM_J;\r\npd_set_presleep(pd, body->presleep);\r\npd_set_keepalive(pd, body->keep_alive);\r\nnew_apps &= le16_to_cpu(get_unaligned(&body->apps));\r\nif ((new_apps & 0x1) && (body->session_id)) {\r\nif (pd->session_id) {\r\nif (pd->session_id != body->session_id) {\r\nrsp_status = OZ_STATUS_SESSION_MISMATCH;\r\ngoto done;\r\n}\r\n} else {\r\nnew_apps &= ~0x1;\r\npd->session_id =\r\noz_get_new_session_id(body->session_id);\r\n}\r\n} else {\r\nif (pd->session_id && !body->session_id) {\r\nrsp_status = OZ_STATUS_SESSION_TEARDOWN;\r\nstop_needed = 1;\r\n} else {\r\nnew_apps &= ~0x1;\r\npd->session_id =\r\noz_get_new_session_id(body->session_id);\r\n}\r\n}\r\ndone:\r\nif (rsp_status == OZ_STATUS_SUCCESS) {\r\nu16 start_apps = new_apps & ~pd->total_apps & ~0x1;\r\nu16 stop_apps = pd->total_apps & ~new_apps & ~0x1;\r\nu16 resume_apps = new_apps & pd->paused_apps & ~0x1;\r\nspin_unlock_bh(&g_polling_lock);\r\noz_pd_set_state(pd, OZ_PD_S_CONNECTED);\r\noz_timer_delete(pd, OZ_TIMER_STOP);\r\noz_trace("new_apps=0x%x total_apps=0x%x paused_apps=0x%x\n",\r\nnew_apps, pd->total_apps, pd->paused_apps);\r\nif (start_apps) {\r\nif (oz_services_start(pd, start_apps, 0))\r\nrsp_status = OZ_STATUS_TOO_MANY_PDS;\r\n}\r\nif (resume_apps)\r\nif (oz_services_start(pd, resume_apps, 1))\r\nrsp_status = OZ_STATUS_TOO_MANY_PDS;\r\nif (stop_apps)\r\noz_services_stop(pd, stop_apps, 0);\r\noz_pd_request_heartbeat(pd);\r\n} else {\r\nspin_unlock_bh(&g_polling_lock);\r\n}\r\noz_send_conn_rsp(pd, rsp_status);\r\nif (rsp_status != OZ_STATUS_SUCCESS) {\r\nif (stop_needed)\r\noz_pd_stop(pd);\r\noz_pd_put(pd);\r\npd = 0;\r\n}\r\nif (old_net_dev)\r\ndev_put(old_net_dev);\r\nif (free_pd)\r\noz_pd_destroy(free_pd);\r\nreturn pd;\r\n}\r\nstatic void oz_add_farewell(struct oz_pd *pd, u8 ep_num, u8 index,\r\nu8 *report, u8 len)\r\n{\r\nstruct oz_farewell *f;\r\nstruct oz_farewell *f2;\r\nint found = 0;\r\nf = kmalloc(sizeof(struct oz_farewell) + len - 1, GFP_ATOMIC);\r\nif (!f)\r\nreturn;\r\nf->ep_num = ep_num;\r\nf->index = index;\r\nmemcpy(f->report, report, len);\r\noz_trace("RX: Adding farewell report\n");\r\nspin_lock(&g_polling_lock);\r\nlist_for_each_entry(f2, &pd->farewell_list, link) {\r\nif ((f2->ep_num == ep_num) && (f2->index == index)) {\r\nfound = 1;\r\nlist_del(&f2->link);\r\nbreak;\r\n}\r\n}\r\nlist_add_tail(&f->link, &pd->farewell_list);\r\nspin_unlock(&g_polling_lock);\r\nif (found)\r\nkfree(f2);\r\n}\r\nstatic void oz_rx_frame(struct sk_buff *skb)\r\n{\r\nu8 *mac_hdr;\r\nu8 *src_addr;\r\nstruct oz_elt *elt;\r\nint length;\r\nstruct oz_pd *pd = 0;\r\nstruct oz_hdr *oz_hdr = (struct oz_hdr *)skb_network_header(skb);\r\nint dup = 0;\r\nu32 pkt_num;\r\noz_event_log(OZ_EVT_RX_PROCESS, 0,\r\n(((u16)oz_hdr->control)<<8)|oz_hdr->last_pkt_num,\r\n0, oz_hdr->pkt_num);\r\noz_trace2(OZ_TRACE_RX_FRAMES,\r\n"RX frame PN=0x%x LPN=0x%x control=0x%x\n",\r\noz_hdr->pkt_num, oz_hdr->last_pkt_num, oz_hdr->control);\r\nmac_hdr = skb_mac_header(skb);\r\nsrc_addr = &mac_hdr[ETH_ALEN] ;\r\nlength = skb->len;\r\nif (oz_get_prot_ver(oz_hdr->control) != OZ_PROTOCOL_VERSION) {\r\noz_trace("Incorrect protocol version: %d\n",\r\noz_get_prot_ver(oz_hdr->control));\r\ngoto done;\r\n}\r\npkt_num = le32_to_cpu(get_unaligned(&oz_hdr->pkt_num));\r\npd = oz_pd_find(src_addr);\r\nif (pd) {\r\npd->last_rx_time_j = jiffies;\r\noz_timer_add(pd, OZ_TIMER_TOUT,\r\npd->last_rx_time_j + pd->presleep_j, 1);\r\nif (pkt_num != pd->last_rx_pkt_num) {\r\npd->last_rx_pkt_num = pkt_num;\r\n} else {\r\ndup = 1;\r\noz_trace("Duplicate frame\n");\r\n}\r\n}\r\nif (pd && !dup && ((pd->mode & OZ_MODE_MASK) == OZ_MODE_TRIGGERED)) {\r\npd->last_sent_frame = &pd->tx_queue;\r\nif (oz_hdr->control & OZ_F_ACK) {\r\noz_retire_tx_frames(pd, oz_hdr->last_pkt_num);\r\n}\r\nif ((oz_hdr->control & OZ_F_ACK_REQUESTED) &&\r\n(pd->state == OZ_PD_S_CONNECTED)) {\r\nint backlog = pd->nb_queued_frames;\r\npd->trigger_pkt_num = pkt_num;\r\nwhile (oz_prepare_frame(pd, 0) >= 0)\r\n;\r\noz_send_queued_frames(pd, backlog);\r\n}\r\n}\r\nlength -= sizeof(struct oz_hdr);\r\nelt = (struct oz_elt *)((u8 *)oz_hdr + sizeof(struct oz_hdr));\r\nwhile (length >= sizeof(struct oz_elt)) {\r\nlength -= sizeof(struct oz_elt) + elt->length;\r\nif (length < 0)\r\nbreak;\r\nswitch (elt->type) {\r\ncase OZ_ELT_CONNECT_REQ:\r\noz_event_log(OZ_EVT_CONNECT_REQ, 0, 0, 0, 0);\r\noz_trace("RX: OZ_ELT_CONNECT_REQ\n");\r\npd = oz_connect_req(pd, elt, src_addr, skb->dev);\r\nbreak;\r\ncase OZ_ELT_DISCONNECT:\r\noz_trace("RX: OZ_ELT_DISCONNECT\n");\r\nif (pd)\r\noz_pd_sleep(pd);\r\nbreak;\r\ncase OZ_ELT_UPDATE_PARAM_REQ: {\r\nstruct oz_elt_update_param *body =\r\n(struct oz_elt_update_param *)(elt + 1);\r\noz_trace("RX: OZ_ELT_UPDATE_PARAM_REQ\n");\r\nif (pd && (pd->state & OZ_PD_S_CONNECTED)) {\r\nspin_lock(&g_polling_lock);\r\npd_set_keepalive(pd, body->keepalive);\r\npd_set_presleep(pd, body->presleep);\r\nspin_unlock(&g_polling_lock);\r\n}\r\n}\r\nbreak;\r\ncase OZ_ELT_FAREWELL_REQ: {\r\nstruct oz_elt_farewell *body =\r\n(struct oz_elt_farewell *)(elt + 1);\r\noz_trace("RX: OZ_ELT_FAREWELL_REQ\n");\r\noz_add_farewell(pd, body->ep_num,\r\nbody->index, body->report,\r\nelt->length + 1 - sizeof(*body));\r\n}\r\nbreak;\r\ncase OZ_ELT_APP_DATA:\r\nif (pd && (pd->state & OZ_PD_S_CONNECTED)) {\r\nstruct oz_app_hdr *app_hdr =\r\n(struct oz_app_hdr *)(elt+1);\r\nif (dup)\r\nbreak;\r\noz_handle_app_elt(pd, app_hdr->app_id, elt);\r\n}\r\nbreak;\r\ndefault:\r\noz_trace("RX: Unknown elt %02x\n", elt->type);\r\n}\r\nelt = oz_next_elt(elt);\r\n}\r\ndone:\r\nif (pd)\r\noz_pd_put(pd);\r\nconsume_skb(skb);\r\n}\r\nvoid oz_protocol_term(void)\r\n{\r\nstruct list_head *chain = 0;\r\ndel_timer_sync(&g_timer);\r\nspin_lock_bh(&g_binding_lock);\r\nwhile (g_binding) {\r\nstruct oz_binding *b = g_binding;\r\ng_binding = b->next;\r\nspin_unlock_bh(&g_binding_lock);\r\ndev_remove_pack(&b->ptype);\r\nif (b->ptype.dev)\r\ndev_put(b->ptype.dev);\r\nkfree(b);\r\nspin_lock_bh(&g_binding_lock);\r\n}\r\nspin_unlock_bh(&g_binding_lock);\r\nspin_lock_bh(&g_polling_lock);\r\nwhile (!list_empty(&g_pd_list)) {\r\nstruct oz_pd *pd =\r\nlist_first_entry(&g_pd_list, struct oz_pd, link);\r\noz_pd_get(pd);\r\nspin_unlock_bh(&g_polling_lock);\r\noz_pd_stop(pd);\r\noz_pd_put(pd);\r\nspin_lock_bh(&g_polling_lock);\r\n}\r\nchain = g_timer_pool;\r\ng_timer_pool = 0;\r\nspin_unlock_bh(&g_polling_lock);\r\nwhile (chain) {\r\nstruct oz_timer *t = container_of(chain, struct oz_timer, link);\r\nchain = chain->next;\r\nkfree(t);\r\n}\r\noz_trace("Protocol stopped\n");\r\n}\r\nstatic void oz_pd_handle_timer(struct oz_pd *pd, int type)\r\n{\r\nswitch (type) {\r\ncase OZ_TIMER_TOUT:\r\noz_pd_sleep(pd);\r\nbreak;\r\ncase OZ_TIMER_STOP:\r\noz_pd_stop(pd);\r\nbreak;\r\ncase OZ_TIMER_HEARTBEAT: {\r\nu16 apps = 0;\r\nspin_lock_bh(&g_polling_lock);\r\npd->heartbeat_requested = 0;\r\nif (pd->state & OZ_PD_S_CONNECTED)\r\napps = pd->total_apps;\r\nspin_unlock_bh(&g_polling_lock);\r\nif (apps)\r\noz_pd_heartbeat(pd, apps);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void oz_protocol_timer(unsigned long arg)\r\n{\r\nstruct oz_timer *t;\r\nstruct oz_timer *t2;\r\nstruct oz_pd *pd;\r\nspin_lock_bh(&g_polling_lock);\r\nif (!g_cur_timer) {\r\noz_event_log(OZ_EVT_TIMER, 0, 0, 0, 0);\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn;\r\n}\r\ng_timer_state = OZ_TIMER_IN_HANDLER;\r\nt = g_cur_timer;\r\ng_cur_timer = 0;\r\nlist_del(&t->link);\r\nspin_unlock_bh(&g_polling_lock);\r\ndo {\r\npd = t->pd;\r\noz_event_log(OZ_EVT_TIMER, 0, t->type, 0, 0);\r\noz_pd_handle_timer(pd, t->type);\r\nspin_lock_bh(&g_polling_lock);\r\nif (g_timer_pool_count < OZ_MAX_TIMER_POOL_SIZE) {\r\nt->link.next = g_timer_pool;\r\ng_timer_pool = &t->link;\r\ng_timer_pool_count++;\r\nt = 0;\r\n}\r\nif (!list_empty(&g_timer_list)) {\r\nt2 = container_of(g_timer_list.next,\r\nstruct oz_timer, link);\r\nif (time_before_eq(t2->due_time, jiffies))\r\nlist_del(&t2->link);\r\nelse\r\nt2 = 0;\r\n} else {\r\nt2 = 0;\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\noz_pd_put(pd);\r\nif (t)\r\nkfree(t);\r\nt = t2;\r\n} while (t);\r\ng_timer_state = OZ_TIMER_IDLE;\r\noz_protocol_timer_start();\r\n}\r\nstatic void oz_protocol_timer_start(void)\r\n{\r\nspin_lock_bh(&g_polling_lock);\r\nif (!list_empty(&g_timer_list)) {\r\ng_cur_timer =\r\ncontainer_of(g_timer_list.next, struct oz_timer, link);\r\nif (g_timer_state == OZ_TIMER_SET) {\r\noz_event_log(OZ_EVT_TIMER_CTRL, 3,\r\n(u16)g_cur_timer->type, 0,\r\n(unsigned)g_cur_timer->due_time);\r\nmod_timer(&g_timer, g_cur_timer->due_time);\r\n} else {\r\noz_event_log(OZ_EVT_TIMER_CTRL, 4,\r\n(u16)g_cur_timer->type, 0,\r\n(unsigned)g_cur_timer->due_time);\r\ng_timer.expires = g_cur_timer->due_time;\r\ng_timer.function = oz_protocol_timer;\r\ng_timer.data = 0;\r\nadd_timer(&g_timer);\r\n}\r\ng_timer_state = OZ_TIMER_SET;\r\n} else {\r\noz_trace("No queued timers\n");\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\n}\r\nvoid oz_timer_add(struct oz_pd *pd, int type, unsigned long due_time,\r\nint remove)\r\n{\r\nstruct list_head *e;\r\nstruct oz_timer *t = 0;\r\nint restart_needed = 0;\r\noz_event_log(OZ_EVT_TIMER_CTRL, 1, (u16)type, 0, (unsigned)due_time);\r\nspin_lock(&g_polling_lock);\r\nif (remove) {\r\nlist_for_each(e, &g_timer_list) {\r\nt = container_of(e, struct oz_timer, link);\r\nif ((t->pd == pd) && (t->type == type)) {\r\nif (g_cur_timer == t) {\r\nrestart_needed = 1;\r\ng_cur_timer = 0;\r\n}\r\nlist_del(e);\r\nbreak;\r\n}\r\nt = 0;\r\n}\r\n}\r\nif (!t) {\r\nif (g_timer_pool) {\r\nt = container_of(g_timer_pool, struct oz_timer, link);\r\ng_timer_pool = g_timer_pool->next;\r\ng_timer_pool_count--;\r\n} else {\r\nt = kmalloc(sizeof(struct oz_timer), GFP_ATOMIC);\r\n}\r\nif (t) {\r\nt->pd = pd;\r\nt->type = type;\r\noz_pd_get(pd);\r\n}\r\n}\r\nif (t) {\r\nstruct oz_timer *t2;\r\nt->due_time = due_time;\r\nlist_for_each(e, &g_timer_list) {\r\nt2 = container_of(e, struct oz_timer, link);\r\nif (time_before(due_time, t2->due_time)) {\r\nif (t2 == g_cur_timer) {\r\ng_cur_timer = 0;\r\nrestart_needed = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nlist_add_tail(&t->link, e);\r\n}\r\nif (g_timer_state == OZ_TIMER_IDLE)\r\nrestart_needed = 1;\r\nelse if (g_timer_state == OZ_TIMER_IN_HANDLER)\r\nrestart_needed = 0;\r\nspin_unlock(&g_polling_lock);\r\nif (restart_needed)\r\noz_protocol_timer_start();\r\n}\r\nvoid oz_timer_delete(struct oz_pd *pd, int type)\r\n{\r\nstruct list_head *chain = 0;\r\nstruct oz_timer *t;\r\nstruct oz_timer *n;\r\nint restart_needed = 0;\r\nint release = 0;\r\noz_event_log(OZ_EVT_TIMER_CTRL, 2, (u16)type, 0, 0);\r\nspin_lock(&g_polling_lock);\r\nlist_for_each_entry_safe(t, n, &g_timer_list, link) {\r\nif ((t->pd == pd) && ((type == 0) || (t->type == type))) {\r\nif (g_cur_timer == t) {\r\nrestart_needed = 1;\r\ng_cur_timer = 0;\r\ndel_timer(&g_timer);\r\n}\r\nlist_del(&t->link);\r\nrelease++;\r\nif (g_timer_pool_count < OZ_MAX_TIMER_POOL_SIZE) {\r\nt->link.next = g_timer_pool;\r\ng_timer_pool = &t->link;\r\ng_timer_pool_count++;\r\n} else {\r\nt->link.next = chain;\r\nchain = &t->link;\r\n}\r\nif (type)\r\nbreak;\r\n}\r\n}\r\nif (g_timer_state == OZ_TIMER_IN_HANDLER)\r\nrestart_needed = 0;\r\nelse if (restart_needed)\r\ng_timer_state = OZ_TIMER_IDLE;\r\nspin_unlock(&g_polling_lock);\r\nif (restart_needed)\r\noz_protocol_timer_start();\r\nwhile (release--)\r\noz_pd_put(pd);\r\nwhile (chain) {\r\nt = container_of(chain, struct oz_timer, link);\r\nchain = chain->next;\r\nkfree(t);\r\n}\r\n}\r\nvoid oz_pd_request_heartbeat(struct oz_pd *pd)\r\n{\r\nunsigned long now = jiffies;\r\nunsigned long t;\r\nspin_lock(&g_polling_lock);\r\nif (pd->heartbeat_requested) {\r\nspin_unlock(&g_polling_lock);\r\nreturn;\r\n}\r\nif (pd->pulse_period_j)\r\nt = ((now / pd->pulse_period_j) + 1) * pd->pulse_period_j;\r\nelse\r\nt = now + 1;\r\npd->heartbeat_requested = 1;\r\nspin_unlock(&g_polling_lock);\r\noz_timer_add(pd, OZ_TIMER_HEARTBEAT, t, 0);\r\n}\r\nstruct oz_pd *oz_pd_find(u8 *mac_addr)\r\n{\r\nstruct oz_pd *pd;\r\nstruct list_head *e;\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each(e, &g_pd_list) {\r\npd = container_of(e, struct oz_pd, link);\r\nif (memcmp(pd->mac_addr, mac_addr, ETH_ALEN) == 0) {\r\natomic_inc(&pd->ref_count);\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn pd;\r\n}\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn 0;\r\n}\r\nvoid oz_app_enable(int app_id, int enable)\r\n{\r\nif (app_id <= OZ_APPID_MAX) {\r\nspin_lock_bh(&g_polling_lock);\r\nif (enable)\r\ng_apps |= (1<<app_id);\r\nelse\r\ng_apps &= ~(1<<app_id);\r\nspin_unlock_bh(&g_polling_lock);\r\n}\r\n}\r\nstatic int oz_pkt_recv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\noz_event_log(OZ_EVT_RX_FRAME, 0, 0, 0, 0);\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (skb == 0)\r\nreturn 0;\r\nspin_lock_bh(&g_rx_queue.lock);\r\nif (g_processing_rx) {\r\n__skb_queue_head(&g_rx_queue, skb);\r\nspin_unlock_bh(&g_rx_queue.lock);\r\n} else {\r\ng_processing_rx = 1;\r\ndo {\r\nspin_unlock_bh(&g_rx_queue.lock);\r\noz_rx_frame(skb);\r\nspin_lock_bh(&g_rx_queue.lock);\r\nif (skb_queue_empty(&g_rx_queue)) {\r\ng_processing_rx = 0;\r\nspin_unlock_bh(&g_rx_queue.lock);\r\nbreak;\r\n}\r\nskb = __skb_dequeue(&g_rx_queue);\r\n} while (1);\r\n}\r\nreturn 0;\r\n}\r\nvoid oz_binding_add(char *net_dev)\r\n{\r\nstruct oz_binding *binding;\r\nbinding = kmalloc(sizeof(struct oz_binding), GFP_ATOMIC);\r\nif (binding) {\r\nbinding->ptype.type = __constant_htons(OZ_ETHERTYPE);\r\nbinding->ptype.func = oz_pkt_recv;\r\nmemcpy(binding->name, net_dev, OZ_MAX_BINDING_LEN);\r\nif (net_dev && *net_dev) {\r\noz_trace("Adding binding: %s\n", net_dev);\r\nbinding->ptype.dev =\r\ndev_get_by_name(&init_net, net_dev);\r\nif (binding->ptype.dev == 0) {\r\noz_trace("Netdev %s not found\n", net_dev);\r\nkfree(binding);\r\nbinding = 0;\r\n}\r\n} else {\r\noz_trace("Binding to all netcards\n");\r\nbinding->ptype.dev = 0;\r\n}\r\nif (binding) {\r\ndev_add_pack(&binding->ptype);\r\nspin_lock_bh(&g_binding_lock);\r\nbinding->next = g_binding;\r\ng_binding = binding;\r\nspin_unlock_bh(&g_binding_lock);\r\n}\r\n}\r\n}\r\nstatic int compare_binding_name(char *s1, char *s2)\r\n{\r\nint i;\r\nfor (i = 0; i < OZ_MAX_BINDING_LEN; i++) {\r\nif (*s1 != *s2)\r\nreturn 0;\r\nif (!*s1++)\r\nreturn 1;\r\ns2++;\r\n}\r\nreturn 1;\r\n}\r\nstatic void pd_stop_all_for_device(struct net_device *net_dev)\r\n{\r\nstruct list_head h;\r\nstruct oz_pd *pd;\r\nstruct oz_pd *n;\r\nINIT_LIST_HEAD(&h);\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each_entry_safe(pd, n, &g_pd_list, link) {\r\nif (pd->net_dev == net_dev) {\r\nlist_move(&pd->link, &h);\r\noz_pd_get(pd);\r\n}\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\nwhile (!list_empty(&h)) {\r\npd = list_first_entry(&h, struct oz_pd, link);\r\noz_pd_stop(pd);\r\noz_pd_put(pd);\r\n}\r\n}\r\nvoid oz_binding_remove(char *net_dev)\r\n{\r\nstruct oz_binding *binding = 0;\r\nstruct oz_binding **link;\r\noz_trace("Removing binding: %s\n", net_dev);\r\nspin_lock_bh(&g_binding_lock);\r\nbinding = g_binding;\r\nlink = &g_binding;\r\nwhile (binding) {\r\nif (compare_binding_name(binding->name, net_dev)) {\r\noz_trace("Binding '%s' found\n", net_dev);\r\n*link = binding->next;\r\nbreak;\r\n} else {\r\nlink = &binding;\r\nbinding = binding->next;\r\n}\r\n}\r\nspin_unlock_bh(&g_binding_lock);\r\nif (binding) {\r\ndev_remove_pack(&binding->ptype);\r\nif (binding->ptype.dev) {\r\ndev_put(binding->ptype.dev);\r\npd_stop_all_for_device(binding->ptype.dev);\r\n}\r\nkfree(binding);\r\n}\r\n}\r\nstatic char *oz_get_next_device_name(char *s, char *dname, int max_size)\r\n{\r\nwhile (*s == ',')\r\ns++;\r\nwhile (*s && (*s != ',') && max_size > 1) {\r\n*dname++ = *s++;\r\nmax_size--;\r\n}\r\n*dname = 0;\r\nreturn s;\r\n}\r\nint oz_protocol_init(char *devs)\r\n{\r\nskb_queue_head_init(&g_rx_queue);\r\nif (devs && (devs[0] == '*')) {\r\noz_binding_add(0);\r\n} else {\r\nchar d[32];\r\nwhile (*devs) {\r\ndevs = oz_get_next_device_name(devs, d, sizeof(d));\r\nif (d[0])\r\noz_binding_add(d);\r\n}\r\n}\r\ninit_timer(&g_timer);\r\nreturn 0;\r\n}\r\nint oz_get_pd_list(struct oz_mac_addr *addr, int max_count)\r\n{\r\nstruct oz_pd *pd;\r\nstruct list_head *e;\r\nint count = 0;\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each(e, &g_pd_list) {\r\nif (count >= max_count)\r\nbreak;\r\npd = container_of(e, struct oz_pd, link);\r\nmemcpy(&addr[count++], pd->mac_addr, ETH_ALEN);\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn count;\r\n}\r\nvoid oz_polling_lock_bh(void)\r\n{\r\nspin_lock_bh(&g_polling_lock);\r\n}\r\nvoid oz_polling_unlock_bh(void)\r\n{\r\nspin_unlock_bh(&g_polling_lock);\r\n}
