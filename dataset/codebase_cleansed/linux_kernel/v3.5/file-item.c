int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nu64 objectid, u64 pos,\r\nu64 disk_offset, u64 disk_num_bytes,\r\nu64 num_bytes, u64 offset, u64 ram_bytes,\r\nu8 compression, u8 encryption, u16 other_encoding)\r\n{\r\nint ret = 0;\r\nstruct btrfs_file_extent_item *item;\r\nstruct btrfs_key file_key;\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *leaf;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nfile_key.objectid = objectid;\r\nfile_key.offset = pos;\r\nbtrfs_set_key_type(&file_key, BTRFS_EXTENT_DATA_KEY);\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &file_key,\r\nsizeof(*item));\r\nif (ret < 0)\r\ngoto out;\r\nBUG_ON(ret);\r\nleaf = path->nodes[0];\r\nitem = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_file_extent_item);\r\nbtrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);\r\nbtrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);\r\nbtrfs_set_file_extent_offset(leaf, item, offset);\r\nbtrfs_set_file_extent_num_bytes(leaf, item, num_bytes);\r\nbtrfs_set_file_extent_ram_bytes(leaf, item, ram_bytes);\r\nbtrfs_set_file_extent_generation(leaf, item, trans->transid);\r\nbtrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);\r\nbtrfs_set_file_extent_compression(leaf, item, compression);\r\nbtrfs_set_file_extent_encryption(leaf, item, encryption);\r\nbtrfs_set_file_extent_other_encoding(leaf, item, other_encoding);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstruct btrfs_csum_item *btrfs_lookup_csum(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nu64 bytenr, int cow)\r\n{\r\nint ret;\r\nstruct btrfs_key file_key;\r\nstruct btrfs_key found_key;\r\nstruct btrfs_csum_item *item;\r\nstruct extent_buffer *leaf;\r\nu64 csum_offset = 0;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nint csums_in_item;\r\nfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nfile_key.offset = bytenr;\r\nbtrfs_set_key_type(&file_key, BTRFS_EXTENT_CSUM_KEY);\r\nret = btrfs_search_slot(trans, root, &file_key, path, 0, cow);\r\nif (ret < 0)\r\ngoto fail;\r\nleaf = path->nodes[0];\r\nif (ret > 0) {\r\nret = 1;\r\nif (path->slots[0] == 0)\r\ngoto fail;\r\npath->slots[0]--;\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\r\nif (btrfs_key_type(&found_key) != BTRFS_EXTENT_CSUM_KEY)\r\ngoto fail;\r\ncsum_offset = (bytenr - found_key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\ncsums_in_item = btrfs_item_size_nr(leaf, path->slots[0]);\r\ncsums_in_item /= csum_size;\r\nif (csum_offset >= csums_in_item) {\r\nret = -EFBIG;\r\ngoto fail;\r\n}\r\n}\r\nitem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\r\nitem = (struct btrfs_csum_item *)((unsigned char *)item +\r\ncsum_offset * csum_size);\r\nreturn item;\r\nfail:\r\nif (ret > 0)\r\nret = -ENOENT;\r\nreturn ERR_PTR(ret);\r\n}\r\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 objectid,\r\nu64 offset, int mod)\r\n{\r\nint ret;\r\nstruct btrfs_key file_key;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nfile_key.objectid = objectid;\r\nfile_key.offset = offset;\r\nbtrfs_set_key_type(&file_key, BTRFS_EXTENT_DATA_KEY);\r\nret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\r\nreturn ret;\r\n}\r\nstatic int __btrfs_lookup_bio_sums(struct btrfs_root *root,\r\nstruct inode *inode, struct bio *bio,\r\nu64 logical_offset, u32 *dst, int dio)\r\n{\r\nu32 sum;\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nint bio_index = 0;\r\nu64 offset = 0;\r\nu64 item_start_offset = 0;\r\nu64 item_last_offset = 0;\r\nu64 disk_bytenr;\r\nu32 diff;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_csum_item *item = NULL;\r\nstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nif (bio->bi_size > PAGE_CACHE_SIZE * 8)\r\npath->reada = 2;\r\nWARN_ON(bio->bi_vcnt <= 0);\r\nif (btrfs_is_free_space_inode(root, inode)) {\r\npath->search_commit_root = 1;\r\npath->skip_locking = 1;\r\n}\r\ndisk_bytenr = (u64)bio->bi_sector << 9;\r\nif (dio)\r\noffset = logical_offset;\r\nwhile (bio_index < bio->bi_vcnt) {\r\nif (!dio)\r\noffset = page_offset(bvec->bv_page) + bvec->bv_offset;\r\nret = btrfs_find_ordered_sum(inode, offset, disk_bytenr, &sum);\r\nif (ret == 0)\r\ngoto found;\r\nif (!item || disk_bytenr < item_start_offset ||\r\ndisk_bytenr >= item_last_offset) {\r\nstruct btrfs_key found_key;\r\nu32 item_size;\r\nif (item)\r\nbtrfs_release_path(path);\r\nitem = btrfs_lookup_csum(NULL, root->fs_info->csum_root,\r\npath, disk_bytenr, 0);\r\nif (IS_ERR(item)) {\r\nret = PTR_ERR(item);\r\nif (ret == -ENOENT || ret == -EFBIG)\r\nret = 0;\r\nsum = 0;\r\nif (BTRFS_I(inode)->root->root_key.objectid ==\r\nBTRFS_DATA_RELOC_TREE_OBJECTID) {\r\nset_extent_bits(io_tree, offset,\r\noffset + bvec->bv_len - 1,\r\nEXTENT_NODATASUM, GFP_NOFS);\r\n} else {\r\nprintk(KERN_INFO "btrfs no csum found "\r\n"for inode %llu start %llu\n",\r\n(unsigned long long)\r\nbtrfs_ino(inode),\r\n(unsigned long long)offset);\r\n}\r\nitem = NULL;\r\nbtrfs_release_path(path);\r\ngoto found;\r\n}\r\nbtrfs_item_key_to_cpu(path->nodes[0], &found_key,\r\npath->slots[0]);\r\nitem_start_offset = found_key.offset;\r\nitem_size = btrfs_item_size_nr(path->nodes[0],\r\npath->slots[0]);\r\nitem_last_offset = item_start_offset +\r\n(item_size / csum_size) *\r\nroot->sectorsize;\r\nitem = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_csum_item);\r\n}\r\ndiff = disk_bytenr - item_start_offset;\r\ndiff = diff / root->sectorsize;\r\ndiff = diff * csum_size;\r\nread_extent_buffer(path->nodes[0], &sum,\r\n((unsigned long)item) + diff,\r\ncsum_size);\r\nfound:\r\nif (dst)\r\n*dst++ = sum;\r\nelse\r\nset_state_private(io_tree, offset, sum);\r\ndisk_bytenr += bvec->bv_len;\r\noffset += bvec->bv_len;\r\nbio_index++;\r\nbvec++;\r\n}\r\nbtrfs_free_path(path);\r\nreturn 0;\r\n}\r\nint btrfs_lookup_bio_sums(struct btrfs_root *root, struct inode *inode,\r\nstruct bio *bio, u32 *dst)\r\n{\r\nreturn __btrfs_lookup_bio_sums(root, inode, bio, 0, dst, 0);\r\n}\r\nint btrfs_lookup_bio_sums_dio(struct btrfs_root *root, struct inode *inode,\r\nstruct bio *bio, u64 offset, u32 *dst)\r\n{\r\nreturn __btrfs_lookup_bio_sums(root, inode, bio, offset, dst, 1);\r\n}\r\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\r\nstruct list_head *list, int search_commit)\r\n{\r\nstruct btrfs_key key;\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_ordered_sum *sums;\r\nstruct btrfs_sector_sum *sector_sum;\r\nstruct btrfs_csum_item *item;\r\nLIST_HEAD(tmplist);\r\nunsigned long offset;\r\nint ret;\r\nsize_t size;\r\nu64 csum_end;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nif (search_commit) {\r\npath->skip_locking = 1;\r\npath->reada = 2;\r\npath->search_commit_root = 1;\r\n}\r\nkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nkey.offset = start;\r\nkey.type = BTRFS_EXTENT_CSUM_KEY;\r\nret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\r\nif (ret < 0)\r\ngoto fail;\r\nif (ret > 0 && path->slots[0] > 0) {\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\r\nif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\r\nkey.type == BTRFS_EXTENT_CSUM_KEY) {\r\noffset = (start - key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\nif (offset * csum_size <\r\nbtrfs_item_size_nr(leaf, path->slots[0] - 1))\r\npath->slots[0]--;\r\n}\r\n}\r\nwhile (start <= end) {\r\nleaf = path->nodes[0];\r\nif (path->slots[0] >= btrfs_header_nritems(leaf)) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret < 0)\r\ngoto fail;\r\nif (ret > 0)\r\nbreak;\r\nleaf = path->nodes[0];\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\nkey.type != BTRFS_EXTENT_CSUM_KEY)\r\nbreak;\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nif (key.offset > end)\r\nbreak;\r\nif (key.offset > start)\r\nstart = key.offset;\r\nsize = btrfs_item_size_nr(leaf, path->slots[0]);\r\ncsum_end = key.offset + (size / csum_size) * root->sectorsize;\r\nif (csum_end <= start) {\r\npath->slots[0]++;\r\ncontinue;\r\n}\r\ncsum_end = min(csum_end, end + 1);\r\nitem = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_csum_item);\r\nwhile (start < csum_end) {\r\nsize = min_t(size_t, csum_end - start,\r\nMAX_ORDERED_SUM_BYTES(root));\r\nsums = kzalloc(btrfs_ordered_sum_size(root, size),\r\nGFP_NOFS);\r\nif (!sums) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nsector_sum = sums->sums;\r\nsums->bytenr = start;\r\nsums->len = size;\r\noffset = (start - key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\noffset *= csum_size;\r\nwhile (size > 0) {\r\nread_extent_buffer(path->nodes[0],\r\n&sector_sum->sum,\r\n((unsigned long)item) +\r\noffset, csum_size);\r\nsector_sum->bytenr = start;\r\nsize -= root->sectorsize;\r\nstart += root->sectorsize;\r\noffset += csum_size;\r\nsector_sum++;\r\n}\r\nlist_add_tail(&sums->list, &tmplist);\r\n}\r\npath->slots[0]++;\r\n}\r\nret = 0;\r\nfail:\r\nwhile (ret < 0 && !list_empty(&tmplist)) {\r\nsums = list_entry(&tmplist, struct btrfs_ordered_sum, list);\r\nlist_del(&sums->list);\r\nkfree(sums);\r\n}\r\nlist_splice_tail(&tmplist, list);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_csum_one_bio(struct btrfs_root *root, struct inode *inode,\r\nstruct bio *bio, u64 file_start, int contig)\r\n{\r\nstruct btrfs_ordered_sum *sums;\r\nstruct btrfs_sector_sum *sector_sum;\r\nstruct btrfs_ordered_extent *ordered;\r\nchar *data;\r\nstruct bio_vec *bvec = bio->bi_io_vec;\r\nint bio_index = 0;\r\nunsigned long total_bytes = 0;\r\nunsigned long this_sum_bytes = 0;\r\nu64 offset;\r\nu64 disk_bytenr;\r\nWARN_ON(bio->bi_vcnt <= 0);\r\nsums = kzalloc(btrfs_ordered_sum_size(root, bio->bi_size), GFP_NOFS);\r\nif (!sums)\r\nreturn -ENOMEM;\r\nsector_sum = sums->sums;\r\ndisk_bytenr = (u64)bio->bi_sector << 9;\r\nsums->len = bio->bi_size;\r\nINIT_LIST_HEAD(&sums->list);\r\nif (contig)\r\noffset = file_start;\r\nelse\r\noffset = page_offset(bvec->bv_page) + bvec->bv_offset;\r\nordered = btrfs_lookup_ordered_extent(inode, offset);\r\nBUG_ON(!ordered);\r\nsums->bytenr = ordered->start;\r\nwhile (bio_index < bio->bi_vcnt) {\r\nif (!contig)\r\noffset = page_offset(bvec->bv_page) + bvec->bv_offset;\r\nif (!contig && (offset >= ordered->file_offset + ordered->len ||\r\noffset < ordered->file_offset)) {\r\nunsigned long bytes_left;\r\nsums->len = this_sum_bytes;\r\nthis_sum_bytes = 0;\r\nbtrfs_add_ordered_sum(inode, ordered, sums);\r\nbtrfs_put_ordered_extent(ordered);\r\nbytes_left = bio->bi_size - total_bytes;\r\nsums = kzalloc(btrfs_ordered_sum_size(root, bytes_left),\r\nGFP_NOFS);\r\nBUG_ON(!sums);\r\nsector_sum = sums->sums;\r\nsums->len = bytes_left;\r\nordered = btrfs_lookup_ordered_extent(inode, offset);\r\nBUG_ON(!ordered);\r\nsums->bytenr = ordered->start;\r\n}\r\ndata = kmap_atomic(bvec->bv_page);\r\nsector_sum->sum = ~(u32)0;\r\nsector_sum->sum = btrfs_csum_data(root,\r\ndata + bvec->bv_offset,\r\nsector_sum->sum,\r\nbvec->bv_len);\r\nkunmap_atomic(data);\r\nbtrfs_csum_final(sector_sum->sum,\r\n(char *)&sector_sum->sum);\r\nsector_sum->bytenr = disk_bytenr;\r\nsector_sum++;\r\nbio_index++;\r\ntotal_bytes += bvec->bv_len;\r\nthis_sum_bytes += bvec->bv_len;\r\ndisk_bytenr += bvec->bv_len;\r\noffset += bvec->bv_len;\r\nbvec++;\r\n}\r\nthis_sum_bytes = 0;\r\nbtrfs_add_ordered_sum(inode, ordered, sums);\r\nbtrfs_put_ordered_extent(ordered);\r\nreturn 0;\r\n}\r\nstatic noinline void truncate_one_csum(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nstruct btrfs_key *key,\r\nu64 bytenr, u64 len)\r\n{\r\nstruct extent_buffer *leaf;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nu64 csum_end;\r\nu64 end_byte = bytenr + len;\r\nu32 blocksize_bits = root->fs_info->sb->s_blocksize_bits;\r\nleaf = path->nodes[0];\r\ncsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\r\ncsum_end <<= root->fs_info->sb->s_blocksize_bits;\r\ncsum_end += key->offset;\r\nif (key->offset < bytenr && csum_end <= end_byte) {\r\nu32 new_size = (bytenr - key->offset) >> blocksize_bits;\r\nnew_size *= csum_size;\r\nbtrfs_truncate_item(trans, root, path, new_size, 1);\r\n} else if (key->offset >= bytenr && csum_end > end_byte &&\r\nend_byte > key->offset) {\r\nu32 new_size = (csum_end - end_byte) >> blocksize_bits;\r\nnew_size *= csum_size;\r\nbtrfs_truncate_item(trans, root, path, new_size, 0);\r\nkey->offset = end_byte;\r\nbtrfs_set_item_key_safe(trans, root, path, key);\r\n} else {\r\nBUG();\r\n}\r\n}\r\nint btrfs_del_csums(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root, u64 bytenr, u64 len)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nu64 end_byte = bytenr + len;\r\nu64 csum_end;\r\nstruct extent_buffer *leaf;\r\nint ret;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\nint blocksize_bits = root->fs_info->sb->s_blocksize_bits;\r\nroot = root->fs_info->csum_root;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nwhile (1) {\r\nkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nkey.offset = end_byte - 1;\r\nkey.type = BTRFS_EXTENT_CSUM_KEY;\r\npath->leave_spinning = 1;\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret > 0) {\r\nif (path->slots[0] == 0)\r\nbreak;\r\npath->slots[0]--;\r\n} else if (ret < 0) {\r\nbreak;\r\n}\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\nkey.type != BTRFS_EXTENT_CSUM_KEY) {\r\nbreak;\r\n}\r\nif (key.offset >= end_byte)\r\nbreak;\r\ncsum_end = btrfs_item_size_nr(leaf, path->slots[0]) / csum_size;\r\ncsum_end <<= blocksize_bits;\r\ncsum_end += key.offset;\r\nif (csum_end <= bytenr)\r\nbreak;\r\nif (key.offset >= bytenr && csum_end <= end_byte) {\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret)\r\ngoto out;\r\nif (key.offset == bytenr)\r\nbreak;\r\n} else if (key.offset < bytenr && csum_end > end_byte) {\r\nunsigned long offset;\r\nunsigned long shift_len;\r\nunsigned long item_offset;\r\noffset = (bytenr - key.offset) >> blocksize_bits;\r\noffset *= csum_size;\r\nshift_len = (len >> blocksize_bits) * csum_size;\r\nitem_offset = btrfs_item_ptr_offset(leaf,\r\npath->slots[0]);\r\nmemset_extent_buffer(leaf, 0, item_offset + offset,\r\nshift_len);\r\nkey.offset = bytenr;\r\nret = btrfs_split_item(trans, root, path, &key, offset);\r\nif (ret && ret != -EAGAIN) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nkey.offset = end_byte - 1;\r\n} else {\r\ntruncate_one_csum(trans, root, path, &key, bytenr, len);\r\nif (key.offset < bytenr)\r\nbreak;\r\n}\r\nbtrfs_release_path(path);\r\n}\r\nret = 0;\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_csum_file_blocks(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_ordered_sum *sums)\r\n{\r\nu64 bytenr;\r\nint ret;\r\nstruct btrfs_key file_key;\r\nstruct btrfs_key found_key;\r\nu64 next_offset;\r\nu64 total_bytes = 0;\r\nint found_next;\r\nstruct btrfs_path *path;\r\nstruct btrfs_csum_item *item;\r\nstruct btrfs_csum_item *item_end;\r\nstruct extent_buffer *leaf = NULL;\r\nu64 csum_offset;\r\nstruct btrfs_sector_sum *sector_sum;\r\nu32 nritems;\r\nu32 ins_size;\r\nu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nsector_sum = sums->sums;\r\nagain:\r\nnext_offset = (u64)-1;\r\nfound_next = 0;\r\nfile_key.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\r\nfile_key.offset = sector_sum->bytenr;\r\nbytenr = sector_sum->bytenr;\r\nbtrfs_set_key_type(&file_key, BTRFS_EXTENT_CSUM_KEY);\r\nitem = btrfs_lookup_csum(trans, root, path, sector_sum->bytenr, 1);\r\nif (!IS_ERR(item)) {\r\nleaf = path->nodes[0];\r\nret = 0;\r\ngoto found;\r\n}\r\nret = PTR_ERR(item);\r\nif (ret != -EFBIG && ret != -ENOENT)\r\ngoto fail_unlock;\r\nif (ret == -EFBIG) {\r\nu32 item_size;\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nif ((item_size / csum_size) >=\r\nMAX_CSUM_ITEMS(root, csum_size)) {\r\ngoto insert;\r\n}\r\n} else {\r\nint slot = path->slots[0] + 1;\r\nnritems = btrfs_header_nritems(path->nodes[0]);\r\nif (path->slots[0] >= nritems - 1) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret == 1)\r\nfound_next = 1;\r\nif (ret != 0)\r\ngoto insert;\r\nslot = 0;\r\n}\r\nbtrfs_item_key_to_cpu(path->nodes[0], &found_key, slot);\r\nif (found_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\nfound_key.type != BTRFS_EXTENT_CSUM_KEY) {\r\nfound_next = 1;\r\ngoto insert;\r\n}\r\nnext_offset = found_key.offset;\r\nfound_next = 1;\r\ngoto insert;\r\n}\r\nbtrfs_release_path(path);\r\nret = btrfs_search_slot(trans, root, &file_key, path,\r\ncsum_size, 1);\r\nif (ret < 0)\r\ngoto fail_unlock;\r\nif (ret > 0) {\r\nif (path->slots[0] == 0)\r\ngoto insert;\r\npath->slots[0]--;\r\n}\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\r\ncsum_offset = (bytenr - found_key.offset) >>\r\nroot->fs_info->sb->s_blocksize_bits;\r\nif (btrfs_key_type(&found_key) != BTRFS_EXTENT_CSUM_KEY ||\r\nfound_key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\r\ncsum_offset >= MAX_CSUM_ITEMS(root, csum_size)) {\r\ngoto insert;\r\n}\r\nif (csum_offset >= btrfs_item_size_nr(leaf, path->slots[0]) /\r\ncsum_size) {\r\nu32 diff = (csum_offset + 1) * csum_size;\r\nif (diff < btrfs_item_size_nr(leaf, path->slots[0]))\r\ngoto csum;\r\ndiff = diff - btrfs_item_size_nr(leaf, path->slots[0]);\r\nif (diff != csum_size)\r\ngoto insert;\r\nbtrfs_extend_item(trans, root, path, diff);\r\ngoto csum;\r\n}\r\ninsert:\r\nbtrfs_release_path(path);\r\ncsum_offset = 0;\r\nif (found_next) {\r\nu64 tmp = total_bytes + root->sectorsize;\r\nu64 next_sector = sector_sum->bytenr;\r\nstruct btrfs_sector_sum *next = sector_sum + 1;\r\nwhile (tmp < sums->len) {\r\nif (next_sector + root->sectorsize != next->bytenr)\r\nbreak;\r\ntmp += root->sectorsize;\r\nnext_sector = next->bytenr;\r\nnext++;\r\n}\r\ntmp = min(tmp, next_offset - file_key.offset);\r\ntmp >>= root->fs_info->sb->s_blocksize_bits;\r\ntmp = max((u64)1, tmp);\r\ntmp = min(tmp, (u64)MAX_CSUM_ITEMS(root, csum_size));\r\nins_size = csum_size * tmp;\r\n} else {\r\nins_size = csum_size;\r\n}\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &file_key,\r\nins_size);\r\npath->leave_spinning = 0;\r\nif (ret < 0)\r\ngoto fail_unlock;\r\nif (ret != 0) {\r\nWARN_ON(1);\r\ngoto fail_unlock;\r\n}\r\ncsum:\r\nleaf = path->nodes[0];\r\nitem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\r\nret = 0;\r\nitem = (struct btrfs_csum_item *)((unsigned char *)item +\r\ncsum_offset * csum_size);\r\nfound:\r\nitem_end = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_csum_item);\r\nitem_end = (struct btrfs_csum_item *)((unsigned char *)item_end +\r\nbtrfs_item_size_nr(leaf, path->slots[0]));\r\nnext_sector:\r\nwrite_extent_buffer(leaf, &sector_sum->sum, (unsigned long)item, csum_size);\r\ntotal_bytes += root->sectorsize;\r\nsector_sum++;\r\nif (total_bytes < sums->len) {\r\nitem = (struct btrfs_csum_item *)((char *)item +\r\ncsum_size);\r\nif (item < item_end && bytenr + PAGE_CACHE_SIZE ==\r\nsector_sum->bytenr) {\r\nbytenr = sector_sum->bytenr;\r\ngoto next_sector;\r\n}\r\n}\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nif (total_bytes < sums->len) {\r\nbtrfs_release_path(path);\r\ncond_resched();\r\ngoto again;\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\nfail_unlock:\r\ngoto out;\r\n}
