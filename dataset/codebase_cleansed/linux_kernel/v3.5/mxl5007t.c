static void set_reg_bits(struct reg_pair_t *reg_pair, u8 reg, u8 mask, u8 val)\r\n{\r\nunsigned int i = 0;\r\nwhile (reg_pair[i].reg || reg_pair[i].val) {\r\nif (reg_pair[i].reg == reg) {\r\nreg_pair[i].val &= ~mask;\r\nreg_pair[i].val |= val;\r\n}\r\ni++;\r\n}\r\nreturn;\r\n}\r\nstatic void copy_reg_bits(struct reg_pair_t *reg_pair1,\r\nstruct reg_pair_t *reg_pair2)\r\n{\r\nunsigned int i, j;\r\ni = j = 0;\r\nwhile (reg_pair1[i].reg || reg_pair1[i].val) {\r\nwhile (reg_pair2[j].reg || reg_pair2[j].val) {\r\nif (reg_pair1[i].reg != reg_pair2[j].reg) {\r\nj++;\r\ncontinue;\r\n}\r\nreg_pair2[j].val = reg_pair1[i].val;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nreturn;\r\n}\r\nstatic void mxl5007t_set_mode_bits(struct mxl5007t_state *state,\r\nenum mxl5007t_mode mode,\r\ns32 if_diff_out_level)\r\n{\r\nswitch (mode) {\r\ncase MxL_MODE_ATSC:\r\nset_reg_bits(state->tab_init, 0x06, 0x1f, 0x12);\r\nbreak;\r\ncase MxL_MODE_DVBT:\r\nset_reg_bits(state->tab_init, 0x06, 0x1f, 0x11);\r\nbreak;\r\ncase MxL_MODE_ISDBT:\r\nset_reg_bits(state->tab_init, 0x06, 0x1f, 0x10);\r\nbreak;\r\ncase MxL_MODE_CABLE:\r\nset_reg_bits(state->tab_init_cable, 0x09, 0xff, 0xc1);\r\nset_reg_bits(state->tab_init_cable, 0x0a, 0xff,\r\n8 - if_diff_out_level);\r\nset_reg_bits(state->tab_init_cable, 0x0b, 0xff, 0x17);\r\nbreak;\r\ndefault:\r\nmxl_fail(-EINVAL);\r\n}\r\nreturn;\r\n}\r\nstatic void mxl5007t_set_if_freq_bits(struct mxl5007t_state *state,\r\nenum mxl5007t_if_freq if_freq,\r\nint invert_if)\r\n{\r\nu8 val;\r\nswitch (if_freq) {\r\ncase MxL_IF_4_MHZ:\r\nval = 0x00;\r\nbreak;\r\ncase MxL_IF_4_5_MHZ:\r\nval = 0x02;\r\nbreak;\r\ncase MxL_IF_4_57_MHZ:\r\nval = 0x03;\r\nbreak;\r\ncase MxL_IF_5_MHZ:\r\nval = 0x04;\r\nbreak;\r\ncase MxL_IF_5_38_MHZ:\r\nval = 0x05;\r\nbreak;\r\ncase MxL_IF_6_MHZ:\r\nval = 0x06;\r\nbreak;\r\ncase MxL_IF_6_28_MHZ:\r\nval = 0x07;\r\nbreak;\r\ncase MxL_IF_9_1915_MHZ:\r\nval = 0x08;\r\nbreak;\r\ncase MxL_IF_35_25_MHZ:\r\nval = 0x09;\r\nbreak;\r\ncase MxL_IF_36_15_MHZ:\r\nval = 0x0a;\r\nbreak;\r\ncase MxL_IF_44_MHZ:\r\nval = 0x0b;\r\nbreak;\r\ndefault:\r\nmxl_fail(-EINVAL);\r\nreturn;\r\n}\r\nset_reg_bits(state->tab_init, 0x02, 0x0f, val);\r\nset_reg_bits(state->tab_init, 0x02, 0x10, invert_if ? 0x10 : 0x00);\r\nstate->if_freq = if_freq;\r\nreturn;\r\n}\r\nstatic void mxl5007t_set_xtal_freq_bits(struct mxl5007t_state *state,\r\nenum mxl5007t_xtal_freq xtal_freq)\r\n{\r\nswitch (xtal_freq) {\r\ncase MxL_XTAL_16_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x00);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x00);\r\nbreak;\r\ncase MxL_XTAL_20_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x10);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x01);\r\nbreak;\r\ncase MxL_XTAL_20_25_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x20);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x02);\r\nbreak;\r\ncase MxL_XTAL_20_48_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x30);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x03);\r\nbreak;\r\ncase MxL_XTAL_24_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x40);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x04);\r\nbreak;\r\ncase MxL_XTAL_25_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x50);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x05);\r\nbreak;\r\ncase MxL_XTAL_25_14_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x60);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x06);\r\nbreak;\r\ncase MxL_XTAL_27_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x70);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x07);\r\nbreak;\r\ncase MxL_XTAL_28_8_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x80);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x08);\r\nbreak;\r\ncase MxL_XTAL_32_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0x90);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x09);\r\nbreak;\r\ncase MxL_XTAL_40_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0xa0);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0a);\r\nbreak;\r\ncase MxL_XTAL_44_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0xb0);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0b);\r\nbreak;\r\ncase MxL_XTAL_48_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0xc0);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0c);\r\nbreak;\r\ncase MxL_XTAL_49_3811_MHZ:\r\nset_reg_bits(state->tab_init, 0x03, 0xf0, 0xd0);\r\nset_reg_bits(state->tab_init, 0x05, 0x0f, 0x0d);\r\nbreak;\r\ndefault:\r\nmxl_fail(-EINVAL);\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nstatic struct reg_pair_t *mxl5007t_calc_init_regs(struct mxl5007t_state *state,\r\nenum mxl5007t_mode mode)\r\n{\r\nstruct mxl5007t_config *cfg = state->config;\r\nmemcpy(&state->tab_init, &init_tab, sizeof(init_tab));\r\nmemcpy(&state->tab_init_cable, &init_tab_cable, sizeof(init_tab_cable));\r\nmxl5007t_set_mode_bits(state, mode, cfg->if_diff_out_level);\r\nmxl5007t_set_if_freq_bits(state, cfg->if_freq_hz, cfg->invert_if);\r\nmxl5007t_set_xtal_freq_bits(state, cfg->xtal_freq_hz);\r\nset_reg_bits(state->tab_init, 0x04, 0x01, cfg->loop_thru_enable);\r\nset_reg_bits(state->tab_init, 0x03, 0x08, cfg->clk_out_enable << 3);\r\nset_reg_bits(state->tab_init, 0x03, 0x07, cfg->clk_out_amp);\r\nif (mode >= MxL_MODE_CABLE) {\r\ncopy_reg_bits(state->tab_init, state->tab_init_cable);\r\nreturn state->tab_init_cable;\r\n} else\r\nreturn state->tab_init;\r\n}\r\nstatic void mxl5007t_set_bw_bits(struct mxl5007t_state *state,\r\nenum mxl5007t_bw_mhz bw)\r\n{\r\nu8 val;\r\nswitch (bw) {\r\ncase MxL_BW_6MHz:\r\nval = 0x15;\r\nbreak;\r\ncase MxL_BW_7MHz:\r\nval = 0x2a;\r\nbreak;\r\ncase MxL_BW_8MHz:\r\nval = 0x3f;\r\nbreak;\r\ndefault:\r\nmxl_fail(-EINVAL);\r\nreturn;\r\n}\r\nset_reg_bits(state->tab_rftune, 0x0c, 0x3f, val);\r\nreturn;\r\n}\r\nstatic struct\r\nreg_pair_t *mxl5007t_calc_rf_tune_regs(struct mxl5007t_state *state,\r\nu32 rf_freq, enum mxl5007t_bw_mhz bw)\r\n{\r\nu32 dig_rf_freq = 0;\r\nu32 temp;\r\nu32 frac_divider = 1000000;\r\nunsigned int i;\r\nmemcpy(&state->tab_rftune, &reg_pair_rftune, sizeof(reg_pair_rftune));\r\nmxl5007t_set_bw_bits(state, bw);\r\ndig_rf_freq = rf_freq / MHz;\r\ntemp = rf_freq % MHz;\r\nfor (i = 0; i < 6; i++) {\r\ndig_rf_freq <<= 1;\r\nfrac_divider /= 2;\r\nif (temp > frac_divider) {\r\ntemp -= frac_divider;\r\ndig_rf_freq++;\r\n}\r\n}\r\nif (temp > 7812)\r\ndig_rf_freq++;\r\nset_reg_bits(state->tab_rftune, 0x0d, 0xff, (u8) dig_rf_freq);\r\nset_reg_bits(state->tab_rftune, 0x0e, 0xff, (u8) (dig_rf_freq >> 8));\r\nif (rf_freq >= 333000000)\r\nset_reg_bits(state->tab_rftune, 0x80, 0x40, 0x40);\r\nreturn state->tab_rftune;\r\n}\r\nstatic int mxl5007t_write_reg(struct mxl5007t_state *state, u8 reg, u8 val)\r\n{\r\nu8 buf[] = { reg, val };\r\nstruct i2c_msg msg = { .addr = state->i2c_props.addr, .flags = 0,\r\n.buf = buf, .len = 2 };\r\nint ret;\r\nret = i2c_transfer(state->i2c_props.adap, &msg, 1);\r\nif (ret != 1) {\r\nmxl_err("failed!");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_write_regs(struct mxl5007t_state *state,\r\nstruct reg_pair_t *reg_pair)\r\n{\r\nunsigned int i = 0;\r\nint ret = 0;\r\nwhile ((ret == 0) && (reg_pair[i].reg || reg_pair[i].val)) {\r\nret = mxl5007t_write_reg(state,\r\nreg_pair[i].reg, reg_pair[i].val);\r\ni++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_read_reg(struct mxl5007t_state *state, u8 reg, u8 *val)\r\n{\r\nu8 buf[2] = { 0xfb, reg };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->i2c_props.addr, .flags = 0,\r\n.buf = buf, .len = 2 },\r\n{ .addr = state->i2c_props.addr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1 },\r\n};\r\nint ret;\r\nret = i2c_transfer(state->i2c_props.adap, msg, 2);\r\nif (ret != 2) {\r\nmxl_err("failed!");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_soft_reset(struct mxl5007t_state *state)\r\n{\r\nu8 d = 0xff;\r\nstruct i2c_msg msg = {\r\n.addr = state->i2c_props.addr, .flags = 0,\r\n.buf = &d, .len = 1\r\n};\r\nint ret = i2c_transfer(state->i2c_props.adap, &msg, 1);\r\nif (ret != 1) {\r\nmxl_err("failed!");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_tuner_init(struct mxl5007t_state *state,\r\nenum mxl5007t_mode mode)\r\n{\r\nstruct reg_pair_t *init_regs;\r\nint ret;\r\nret = mxl5007t_soft_reset(state);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\ninit_regs = mxl5007t_calc_init_regs(state, mode);\r\nret = mxl5007t_write_regs(state, init_regs);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nmdelay(1);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_tuner_rf_tune(struct mxl5007t_state *state, u32 rf_freq_hz,\r\nenum mxl5007t_bw_mhz bw)\r\n{\r\nstruct reg_pair_t *rf_tune_regs;\r\nint ret;\r\nrf_tune_regs = mxl5007t_calc_rf_tune_regs(state, rf_freq_hz, bw);\r\nret = mxl5007t_write_regs(state, rf_tune_regs);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nmsleep(3);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_synth_lock_status(struct mxl5007t_state *state,\r\nint *rf_locked, int *ref_locked)\r\n{\r\nu8 d;\r\nint ret;\r\n*rf_locked = 0;\r\n*ref_locked = 0;\r\nret = mxl5007t_read_reg(state, 0xd8, &d);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nif ((d & 0x0c) == 0x0c)\r\n*rf_locked = 1;\r\nif ((d & 0x03) == 0x03)\r\n*ref_locked = 1;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\nint rf_locked, ref_locked, ret;\r\n*status = 0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = mxl5007t_synth_lock_status(state, &rf_locked, &ref_locked);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nmxl_debug("%s%s", rf_locked ? "rf locked " : "",\r\nref_locked ? "ref locked" : "");\r\nif ((rf_locked) || (ref_locked))\r\n*status |= TUNER_STATUS_LOCKED;\r\nfail:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 delsys = c->delivery_system;\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\nenum mxl5007t_bw_mhz bw;\r\nenum mxl5007t_mode mode;\r\nint ret;\r\nu32 freq = c->frequency;\r\nswitch (delsys) {\r\ncase SYS_ATSC:\r\nmode = MxL_MODE_ATSC;\r\nbw = MxL_BW_6MHz;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_B:\r\nmode = MxL_MODE_CABLE;\r\nbw = MxL_BW_6MHz;\r\nbreak;\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\nmode = MxL_MODE_DVBT;\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nbw = MxL_BW_6MHz;\r\nbreak;\r\ncase 7000000:\r\nbw = MxL_BW_7MHz;\r\nbreak;\r\ncase 8000000:\r\nbw = MxL_BW_8MHz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nmxl_err("modulation type not supported!");\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nmutex_lock(&state->lock);\r\nret = mxl5007t_tuner_init(state, mode);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl5007t_tuner_rf_tune(state, freq, bw);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nstate->frequency = freq;\r\nstate->bandwidth = c->bandwidth_hz;\r\nfail:\r\nmutex_unlock(&state->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_init(struct dvb_frontend *fe)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = mxl5007t_write_reg(state, 0x01, 0x01);\r\nmxl_fail(ret);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = mxl5007t_write_reg(state, 0x01, 0x00);\r\nmxl_fail(ret);\r\nret = mxl5007t_write_reg(state, 0x0f, 0x00);\r\nmxl_fail(ret);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int mxl5007t_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\n*frequency = state->frequency;\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\n*bandwidth = state->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\n*frequency = 0;\r\nswitch (state->if_freq) {\r\ncase MxL_IF_4_MHZ:\r\n*frequency = 4000000;\r\nbreak;\r\ncase MxL_IF_4_5_MHZ:\r\n*frequency = 4500000;\r\nbreak;\r\ncase MxL_IF_4_57_MHZ:\r\n*frequency = 4570000;\r\nbreak;\r\ncase MxL_IF_5_MHZ:\r\n*frequency = 5000000;\r\nbreak;\r\ncase MxL_IF_5_38_MHZ:\r\n*frequency = 5380000;\r\nbreak;\r\ncase MxL_IF_6_MHZ:\r\n*frequency = 6000000;\r\nbreak;\r\ncase MxL_IF_6_28_MHZ:\r\n*frequency = 6280000;\r\nbreak;\r\ncase MxL_IF_9_1915_MHZ:\r\n*frequency = 9191500;\r\nbreak;\r\ncase MxL_IF_35_25_MHZ:\r\n*frequency = 35250000;\r\nbreak;\r\ncase MxL_IF_36_15_MHZ:\r\n*frequency = 36150000;\r\nbreak;\r\ncase MxL_IF_44_MHZ:\r\n*frequency = 44000000;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_release(struct dvb_frontend *fe)\r\n{\r\nstruct mxl5007t_state *state = fe->tuner_priv;\r\nmutex_lock(&mxl5007t_list_mutex);\r\nif (state)\r\nhybrid_tuner_release_state(state);\r\nmutex_unlock(&mxl5007t_list_mutex);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int mxl5007t_get_chip_id(struct mxl5007t_state *state)\r\n{\r\nchar *name;\r\nint ret;\r\nu8 id;\r\nret = mxl5007t_read_reg(state, 0xd9, &id);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nswitch (id) {\r\ncase MxL_5007_V1_F1:\r\nname = "MxL5007.v1.f1";\r\nbreak;\r\ncase MxL_5007_V1_F2:\r\nname = "MxL5007.v1.f2";\r\nbreak;\r\ncase MxL_5007_V2_100_F1:\r\nname = "MxL5007.v2.100.f1";\r\nbreak;\r\ncase MxL_5007_V2_100_F2:\r\nname = "MxL5007.v2.100.f2";\r\nbreak;\r\ncase MxL_5007_V2_200_F1:\r\nname = "MxL5007.v2.200.f1";\r\nbreak;\r\ncase MxL_5007_V2_200_F2:\r\nname = "MxL5007.v2.200.f2";\r\nbreak;\r\ncase MxL_5007_V4:\r\nname = "MxL5007T.v4";\r\nbreak;\r\ndefault:\r\nname = "MxL5007T";\r\nprintk(KERN_WARNING "%s: unknown rev (%02x)\n", __func__, id);\r\nid = MxL_UNKNOWN_ID;\r\n}\r\nstate->chip_id = id;\r\nmxl_info("%s detected @ %d-%04x", name,\r\ni2c_adapter_id(state->i2c_props.adap),\r\nstate->i2c_props.addr);\r\nreturn 0;\r\nfail:\r\nmxl_warn("unable to identify device @ %d-%04x",\r\ni2c_adapter_id(state->i2c_props.adap),\r\nstate->i2c_props.addr);\r\nstate->chip_id = MxL_UNKNOWN_ID;\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *mxl5007t_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, u8 addr,\r\nstruct mxl5007t_config *cfg)\r\n{\r\nstruct mxl5007t_state *state = NULL;\r\nint instance, ret;\r\nmutex_lock(&mxl5007t_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct mxl5007t_state, state,\r\nhybrid_tuner_instance_list,\r\ni2c, addr, "mxl5007t");\r\nswitch (instance) {\r\ncase 0:\r\ngoto fail;\r\ncase 1:\r\nstate->config = cfg;\r\nmutex_init(&state->lock);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = mxl5007t_get_chip_id(state);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfe->tuner_priv = state;\r\nmutex_unlock(&mxl5007t_list_mutex);\r\nmemcpy(&fe->ops.tuner_ops, &mxl5007t_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\nfail:\r\nmutex_unlock(&mxl5007t_list_mutex);\r\nmxl5007t_release(fe);\r\nreturn NULL;\r\n}
