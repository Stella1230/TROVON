struct net_device * __init apne_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\n#ifndef MANUAL_CONFIG\r\nchar tuple[8];\r\n#endif\r\nint err;\r\nif (!MACH_IS_AMIGA)\r\nreturn ERR_PTR(-ENODEV);\r\nif (apne_owned)\r\nreturn ERR_PTR(-ENODEV);\r\nif ( !(AMIGAHW_PRESENT(PCMCIA)) )\r\nreturn ERR_PTR(-ENODEV);\r\nprintk("Looking for PCMCIA ethernet card : ");\r\nif (!(PCMCIA_INSERTED)) {\r\nprintk("NO PCMCIA card inserted\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ndev = alloc_ei_netdev();\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n}\r\npcmcia_disable_irq();\r\n#ifndef MANUAL_CONFIG\r\nif ((pcmcia_copy_tuple(CISTPL_FUNCID, tuple, 8) < 3) ||\r\n(tuple[2] != CISTPL_FUNCID_NETWORK)) {\r\nprintk("not an ethernet card\n");\r\nfree_netdev(dev);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\n#endif\r\nprintk("ethernet PCMCIA card inserted\n");\r\nif (!init_pcmcia()) {\r\nfree_netdev(dev);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (!request_region(IOBASE, 0x20, DRV_NAME)) {\r\nfree_netdev(dev);\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nerr = apne_probe1(dev, IOBASE);\r\nif (err) {\r\nrelease_region(IOBASE, 0x20);\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nerr = register_netdev(dev);\r\nif (!err)\r\nreturn dev;\r\npcmcia_disable_irq();\r\nfree_irq(IRQ_AMIGA_PORTS, dev);\r\npcmcia_reset();\r\nrelease_region(IOBASE, 0x20);\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int __init apne_probe1(struct net_device *dev, int ioaddr)\r\n{\r\nint i;\r\nunsigned char SA_prom[32];\r\nint wordlength = 2;\r\nconst char *name = NULL;\r\nint start_page, stop_page;\r\n#ifndef MANUAL_HWADDR0\r\nint neX000, ctron;\r\n#endif\r\nstatic unsigned version_printed;\r\nif (ei_debug && version_printed++ == 0)\r\nprintk(version);\r\nprintk("PCMCIA NE*000 ethercard probe");\r\n{ unsigned long reset_start_time = jiffies;\r\noutb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);\r\nwhile ((inb(ioaddr + NE_EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nprintk(" not found (no reset ack).\n");\r\nreturn -ENODEV;\r\n}\r\noutb(0xff, ioaddr + NE_EN0_ISR);\r\n}\r\n#ifndef MANUAL_HWADDR0\r\n{\r\nstruct {unsigned long value, offset; } program_seq[] = {\r\n{E8390_NODMA+E8390_PAGE0+E8390_STOP, NE_CMD},\r\n{0x48, NE_EN0_DCFG},\r\n{0x00, NE_EN0_RCNTLO},\r\n{0x00, NE_EN0_RCNTHI},\r\n{0x00, NE_EN0_IMR},\r\n{0xFF, NE_EN0_ISR},\r\n{E8390_RXOFF, NE_EN0_RXCR},\r\n{E8390_TXOFF, NE_EN0_TXCR},\r\n{32, NE_EN0_RCNTLO},\r\n{0x00, NE_EN0_RCNTHI},\r\n{0x00, NE_EN0_RSARLO},\r\n{0x00, NE_EN0_RSARHI},\r\n{E8390_RREAD+E8390_START, NE_CMD},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(program_seq); i++) {\r\noutb(program_seq[i].value, ioaddr + program_seq[i].offset);\r\n}\r\n}\r\nfor(i = 0; i < 32 ; i+=2) {\r\nSA_prom[i] = inb(ioaddr + NE_DATAPORT);\r\nSA_prom[i+1] = inb(ioaddr + NE_DATAPORT);\r\nif (SA_prom[i] != SA_prom[i+1])\r\nwordlength = 1;\r\n}\r\nif (wordlength == 2)\r\nfor (i = 0; i < 16; i++)\r\nSA_prom[i] = SA_prom[i+i];\r\nif (wordlength == 2) {\r\noutb(0x49, ioaddr + NE_EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\n} else {\r\nstart_page = NE1SM_START_PG;\r\nstop_page = NE1SM_STOP_PG;\r\n}\r\nneX000 = (SA_prom[14] == 0x57 && SA_prom[15] == 0x57);\r\nctron = (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);\r\nif (neX000) {\r\nname = (wordlength == 2) ? "NE2000" : "NE1000";\r\n} else if (ctron) {\r\nname = (wordlength == 2) ? "Ctron-8" : "Ctron-16";\r\nstart_page = 0x01;\r\nstop_page = (wordlength == 2) ? 0x40 : 0x20;\r\n} else {\r\nprintk(" not found.\n");\r\nreturn -ENXIO;\r\n}\r\n#else\r\nwordlength = 2;\r\noutb(0x49, ioaddr + NE_EN0_DCFG);\r\nstart_page = NESM_START_PG;\r\nstop_page = NESM_STOP_PG;\r\nSA_prom[0] = MANUAL_HWADDR0;\r\nSA_prom[1] = MANUAL_HWADDR1;\r\nSA_prom[2] = MANUAL_HWADDR2;\r\nSA_prom[3] = MANUAL_HWADDR3;\r\nSA_prom[4] = MANUAL_HWADDR4;\r\nSA_prom[5] = MANUAL_HWADDR5;\r\nname = "NE2000";\r\n#endif\r\ndev->base_addr = ioaddr;\r\ndev->irq = IRQ_AMIGA_PORTS;\r\ndev->netdev_ops = &ei_netdev_ops;\r\ni = request_irq(dev->irq, apne_interrupt, IRQF_SHARED, DRV_NAME, dev);\r\nif (i) return i;\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = SA_prom[i];\r\nprintk(" %pM\n", dev->dev_addr);\r\nprintk("%s: %s found.\n", dev->name, name);\r\nei_status.name = name;\r\nei_status.tx_start_page = start_page;\r\nei_status.stop_page = stop_page;\r\nei_status.word16 = (wordlength == 2);\r\nei_status.rx_start_page = start_page + TX_PAGES;\r\nei_status.reset_8390 = &apne_reset_8390;\r\nei_status.block_input = &apne_block_input;\r\nei_status.block_output = &apne_block_output;\r\nei_status.get_8390_hdr = &apne_get_8390_hdr;\r\nNS8390_init(dev, 0);\r\npcmcia_ack_int(pcmcia_get_intreq());\r\npcmcia_enable_irq();\r\napne_owned = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\napne_reset_8390(struct net_device *dev)\r\n{\r\nunsigned long reset_start_time = jiffies;\r\ninit_pcmcia();\r\nif (ei_debug > 1) printk("resetting the 8390 t=%ld...", jiffies);\r\noutb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);\r\nei_status.txing = 0;\r\nei_status.dmaing = 0;\r\nwhile ((inb(NE_BASE+NE_EN0_ISR) & ENISR_RESET) == 0)\r\nif (time_after(jiffies, reset_start_time + 2*HZ/100)) {\r\nprintk("%s: ne_reset_8390() did not complete.\n", dev->name);\r\nbreak;\r\n}\r\noutb(ENISR_RESET, NE_BASE + NE_EN0_ISR);\r\n}\r\nstatic void\r\napne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)\r\n{\r\nint nic_base = dev->base_addr;\r\nint cnt;\r\nchar *ptrc;\r\nshort *ptrs;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne_get_8390_hdr "\r\n"[DMAstat:%d][irqlock:%d][intr:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock, dev->irq);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\noutb(sizeof(struct e8390_pkt_hdr), nic_base + NE_EN0_RCNTLO);\r\noutb(0, nic_base + NE_EN0_RCNTHI);\r\noutb(0, nic_base + NE_EN0_RSARLO);\r\noutb(ring_page, nic_base + NE_EN0_RSARHI);\r\noutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16) {\r\nptrs = (short*)hdr;\r\nfor(cnt = 0; cnt < (sizeof(struct e8390_pkt_hdr)>>1); cnt++)\r\n*ptrs++ = inw(NE_BASE + NE_DATAPORT);\r\n} else {\r\nptrc = (char*)hdr;\r\nfor(cnt = 0; cnt < sizeof(struct e8390_pkt_hdr); cnt++)\r\n*ptrc++ = inb(NE_BASE + NE_DATAPORT);\r\n}\r\noutb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\nle16_to_cpus(&hdr->count);\r\n}\r\nstatic void\r\napne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)\r\n{\r\nint nic_base = dev->base_addr;\r\nchar *buf = skb->data;\r\nchar *ptrc;\r\nshort *ptrs;\r\nint cnt;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne_block_input "\r\n"[DMAstat:%d][irqlock:%d][intr:%d].\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock, dev->irq);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);\r\noutb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\noutb(count & 0xff, nic_base + NE_EN0_RCNTLO);\r\noutb(count >> 8, nic_base + NE_EN0_RCNTHI);\r\noutb(ring_offset & 0xff, nic_base + NE_EN0_RSARLO);\r\noutb(ring_offset >> 8, nic_base + NE_EN0_RSARHI);\r\noutb(E8390_RREAD+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16) {\r\nptrs = (short*)buf;\r\nfor (cnt = 0; cnt < (count>>1); cnt++)\r\n*ptrs++ = inw(NE_BASE + NE_DATAPORT);\r\nif (count & 0x01) {\r\nbuf[count-1] = inb(NE_BASE + NE_DATAPORT);\r\n}\r\n} else {\r\nptrc = (char*)buf;\r\nfor (cnt = 0; cnt < count; cnt++)\r\n*ptrc++ = inb(NE_BASE + NE_DATAPORT);\r\n}\r\noutb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic void\r\napne_block_output(struct net_device *dev, int count,\r\nconst unsigned char *buf, const int start_page)\r\n{\r\nint nic_base = NE_BASE;\r\nunsigned long dma_start;\r\nchar *ptrc;\r\nshort *ptrs;\r\nint cnt;\r\nif (ei_status.word16 && (count & 0x01))\r\ncount++;\r\nif (ei_status.dmaing) {\r\nprintk("%s: DMAing conflict in ne_block_output."\r\n"[DMAstat:%d][irqlock:%d][intr:%d]\n",\r\ndev->name, ei_status.dmaing, ei_status.irqlock, dev->irq);\r\nreturn;\r\n}\r\nei_status.dmaing |= 0x01;\r\noutb(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);\r\noutb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\noutb(count & 0xff, nic_base + NE_EN0_RCNTLO);\r\noutb(count >> 8, nic_base + NE_EN0_RCNTHI);\r\noutb(0x00, nic_base + NE_EN0_RSARLO);\r\noutb(start_page, nic_base + NE_EN0_RSARHI);\r\noutb(E8390_RWRITE+E8390_START, nic_base + NE_CMD);\r\nif (ei_status.word16) {\r\nptrs = (short*)buf;\r\nfor (cnt = 0; cnt < count>>1; cnt++)\r\noutw(*ptrs++, NE_BASE+NE_DATAPORT);\r\n} else {\r\nptrc = (char*)buf;\r\nfor (cnt = 0; cnt < count; cnt++)\r\noutb(*ptrc++, NE_BASE + NE_DATAPORT);\r\n}\r\ndma_start = jiffies;\r\nwhile ((inb(NE_BASE + NE_EN0_ISR) & ENISR_RDC) == 0)\r\nif (time_after(jiffies, dma_start + 2*HZ/100)) {\r\nprintk("%s: timeout waiting for Tx RDC.\n", dev->name);\r\napne_reset_8390(dev);\r\nNS8390_init(dev,1);\r\nbreak;\r\n}\r\noutb(ENISR_RDC, nic_base + NE_EN0_ISR);\r\nei_status.dmaing &= ~0x01;\r\n}\r\nstatic irqreturn_t apne_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char pcmcia_intreq;\r\nif (!(gayle.inten & GAYLE_IRQ_IRQ))\r\nreturn IRQ_NONE;\r\npcmcia_intreq = pcmcia_get_intreq();\r\nif (!(pcmcia_intreq & GAYLE_IRQ_IRQ)) {\r\npcmcia_ack_int(pcmcia_intreq);\r\nreturn IRQ_NONE;\r\n}\r\nif (ei_debug > 3)\r\nprintk("pcmcia intreq = %x\n", pcmcia_intreq);\r\npcmcia_disable_irq();\r\nei_interrupt(irq, dev_id);\r\npcmcia_ack_int(pcmcia_get_intreq());\r\npcmcia_enable_irq();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init apne_module_init(void)\r\n{\r\napne_dev = apne_probe(-1);\r\nif (IS_ERR(apne_dev))\r\nreturn PTR_ERR(apne_dev);\r\nreturn 0;\r\n}\r\nstatic void __exit apne_module_exit(void)\r\n{\r\nunregister_netdev(apne_dev);\r\npcmcia_disable_irq();\r\nfree_irq(IRQ_AMIGA_PORTS, apne_dev);\r\npcmcia_reset();\r\nrelease_region(IOBASE, 0x20);\r\nfree_netdev(apne_dev);\r\n}\r\nstatic int init_pcmcia(void)\r\n{\r\nu_char config;\r\n#ifndef MANUAL_CONFIG\r\nu_char tuple[32];\r\nint offset_len;\r\n#endif\r\nu_long offset;\r\npcmcia_reset();\r\npcmcia_program_voltage(PCMCIA_0V);\r\npcmcia_access_speed(PCMCIA_SPEED_250NS);\r\npcmcia_write_enable();\r\n#ifdef MANUAL_CONFIG\r\nconfig = MANUAL_CONFIG;\r\n#else\r\nif (pcmcia_copy_tuple(CISTPL_CFTABLE_ENTRY, tuple, 32) < 3)\r\nreturn 0;\r\nconfig = tuple[2] & 0x3f;\r\n#endif\r\n#ifdef MANUAL_OFFSET\r\noffset = MANUAL_OFFSET;\r\n#else\r\nif (pcmcia_copy_tuple(CISTPL_CONFIG, tuple, 32) < 6)\r\nreturn 0;\r\noffset_len = (tuple[2] & 0x3) + 1;\r\noffset = 0;\r\nwhile(offset_len--) {\r\noffset = (offset << 8) | tuple[4+offset_len];\r\n}\r\n#endif\r\nout_8(GAYLE_ATTRIBUTE+offset, config);\r\nreturn 1;\r\n}
