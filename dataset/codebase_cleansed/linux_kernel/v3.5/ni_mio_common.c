static inline unsigned NI_GPCT_SUBDEV(unsigned counter_index)\r\n{\r\nswitch (counter_index) {\r\ncase 0:\r\nreturn NI_GPCT0_SUBDEV;\r\nbreak;\r\ncase 1:\r\nreturn NI_GPCT1_SUBDEV;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nBUG();\r\nreturn NI_GPCT0_SUBDEV;\r\n}\r\nstatic inline void ni_set_bitfield(struct comedi_device *dev, int reg,\r\nunsigned bit_mask, unsigned bit_values)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);\r\nswitch (reg) {\r\ncase Interrupt_A_Enable_Register:\r\ndevpriv->int_a_enable_reg &= ~bit_mask;\r\ndevpriv->int_a_enable_reg |= bit_values & bit_mask;\r\ndevpriv->stc_writew(dev, devpriv->int_a_enable_reg,\r\nInterrupt_A_Enable_Register);\r\nbreak;\r\ncase Interrupt_B_Enable_Register:\r\ndevpriv->int_b_enable_reg &= ~bit_mask;\r\ndevpriv->int_b_enable_reg |= bit_values & bit_mask;\r\ndevpriv->stc_writew(dev, devpriv->int_b_enable_reg,\r\nInterrupt_B_Enable_Register);\r\nbreak;\r\ncase IO_Bidirection_Pin_Register:\r\ndevpriv->io_bidirection_pin_reg &= ~bit_mask;\r\ndevpriv->io_bidirection_pin_reg |= bit_values & bit_mask;\r\ndevpriv->stc_writew(dev, devpriv->io_bidirection_pin_reg,\r\nIO_Bidirection_Pin_Register);\r\nbreak;\r\ncase AI_AO_Select:\r\ndevpriv->ai_ao_select_reg &= ~bit_mask;\r\ndevpriv->ai_ao_select_reg |= bit_values & bit_mask;\r\nni_writeb(devpriv->ai_ao_select_reg, AI_AO_Select);\r\nbreak;\r\ncase G0_G1_Select:\r\ndevpriv->g0_g1_select_reg &= ~bit_mask;\r\ndevpriv->g0_g1_select_reg |= bit_values & bit_mask;\r\nni_writeb(devpriv->g0_g1_select_reg, G0_G1_Select);\r\nbreak;\r\ndefault:\r\nprintk("Warning %s() called with invalid register\n", __func__);\r\nprintk("reg is %d\n", reg);\r\nbreak;\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);\r\n}\r\nstatic inline void ni_set_ai_dma_channel(struct comedi_device *dev, int channel)\r\n{\r\nunsigned bitfield;\r\nif (channel >= 0) {\r\nbitfield =\r\n(ni_stc_dma_channel_select_bitfield(channel) <<\r\nAI_DMA_Select_Shift) & AI_DMA_Select_Mask;\r\n} else {\r\nbitfield = 0;\r\n}\r\nni_set_bitfield(dev, AI_AO_Select, AI_DMA_Select_Mask, bitfield);\r\n}\r\nstatic inline void ni_set_ao_dma_channel(struct comedi_device *dev, int channel)\r\n{\r\nunsigned bitfield;\r\nif (channel >= 0) {\r\nbitfield =\r\n(ni_stc_dma_channel_select_bitfield(channel) <<\r\nAO_DMA_Select_Shift) & AO_DMA_Select_Mask;\r\n} else {\r\nbitfield = 0;\r\n}\r\nni_set_bitfield(dev, AI_AO_Select, AO_DMA_Select_Mask, bitfield);\r\n}\r\nstatic inline void ni_set_gpct_dma_channel(struct comedi_device *dev,\r\nunsigned gpct_index,\r\nint mite_channel)\r\n{\r\nunsigned bitfield;\r\nif (mite_channel >= 0) {\r\nbitfield = GPCT_DMA_Select_Bits(gpct_index, mite_channel);\r\n} else {\r\nbitfield = 0;\r\n}\r\nni_set_bitfield(dev, G0_G1_Select, GPCT_DMA_Select_Mask(gpct_index),\r\nbitfield);\r\n}\r\nstatic inline void ni_set_cdo_dma_channel(struct comedi_device *dev,\r\nint mite_channel)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);\r\ndevpriv->cdio_dma_select_reg &= ~CDO_DMA_Select_Mask;\r\nif (mite_channel >= 0) {\r\ndevpriv->cdio_dma_select_reg |=\r\n(ni_stc_dma_channel_select_bitfield(mite_channel) <<\r\nCDO_DMA_Select_Shift) & CDO_DMA_Select_Mask;\r\n}\r\nni_writeb(devpriv->cdio_dma_select_reg, M_Offset_CDIO_DMA_Select);\r\nmmiowb();\r\nspin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);\r\n}\r\nstatic int ni_request_ai_mite_channel(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(devpriv->ai_mite_chan);\r\ndevpriv->ai_mite_chan =\r\nmite_request_channel(devpriv->mite, devpriv->ai_mite_ring);\r\nif (devpriv->ai_mite_chan == NULL) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ncomedi_error(dev,\r\n"failed to reserve mite dma channel for analog input.");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->ai_mite_chan->dir = COMEDI_INPUT;\r\nni_set_ai_dma_channel(dev, devpriv->ai_mite_chan->channel);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_request_ao_mite_channel(struct comedi_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(devpriv->ao_mite_chan);\r\ndevpriv->ao_mite_chan =\r\nmite_request_channel(devpriv->mite, devpriv->ao_mite_ring);\r\nif (devpriv->ao_mite_chan == NULL) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ncomedi_error(dev,\r\n"failed to reserve mite dma channel for analog outut.");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->ao_mite_chan->dir = COMEDI_OUTPUT;\r\nni_set_ao_dma_channel(dev, devpriv->ao_mite_chan->channel);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_request_gpct_mite_channel(struct comedi_device *dev,\r\nunsigned gpct_index,\r\nenum comedi_io_direction direction)\r\n{\r\nunsigned long flags;\r\nstruct mite_channel *mite_chan;\r\nBUG_ON(gpct_index >= NUM_GPCT);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(devpriv->counter_dev->counters[gpct_index].mite_chan);\r\nmite_chan =\r\nmite_request_channel(devpriv->mite,\r\ndevpriv->gpct_mite_ring[gpct_index]);\r\nif (mite_chan == NULL) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ncomedi_error(dev,\r\n"failed to reserve mite dma channel for counter.");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = direction;\r\nni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],\r\nmite_chan);\r\nni_set_gpct_dma_channel(dev, gpct_index, mite_chan->channel);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_request_cdo_mite_channel(struct comedi_device *dev)\r\n{\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nBUG_ON(devpriv->cdo_mite_chan);\r\ndevpriv->cdo_mite_chan =\r\nmite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);\r\nif (devpriv->cdo_mite_chan == NULL) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\ncomedi_error(dev,\r\n"failed to reserve mite dma channel for correlated digital outut.");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->cdo_mite_chan->dir = COMEDI_OUTPUT;\r\nni_set_cdo_dma_channel(dev, devpriv->cdo_mite_chan->channel);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ni_release_ai_mite_channel(struct comedi_device *dev)\r\n{\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan) {\r\nni_set_ai_dma_channel(dev, -1);\r\nmite_release_channel(devpriv->ai_mite_chan);\r\ndevpriv->ai_mite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\n}\r\nstatic void ni_release_ao_mite_channel(struct comedi_device *dev)\r\n{\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ao_mite_chan) {\r\nni_set_ao_dma_channel(dev, -1);\r\nmite_release_channel(devpriv->ao_mite_chan);\r\ndevpriv->ao_mite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\n}\r\nvoid ni_release_gpct_mite_channel(struct comedi_device *dev,\r\nunsigned gpct_index)\r\n{\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\nBUG_ON(gpct_index >= NUM_GPCT);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->counter_dev->counters[gpct_index].mite_chan) {\r\nstruct mite_channel *mite_chan =\r\ndevpriv->counter_dev->counters[gpct_index].mite_chan;\r\nni_set_gpct_dma_channel(dev, gpct_index, -1);\r\nni_tio_set_mite_channel(&devpriv->\r\ncounter_dev->counters[gpct_index],\r\nNULL);\r\nmite_release_channel(mite_chan);\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\n}\r\nstatic void ni_release_cdo_mite_channel(struct comedi_device *dev)\r\n{\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->cdo_mite_chan) {\r\nni_set_cdo_dma_channel(dev, -1);\r\nmite_release_channel(devpriv->cdo_mite_chan);\r\ndevpriv->cdo_mite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\n}\r\nstatic void ni_e_series_enable_second_irq(struct comedi_device *dev,\r\nunsigned gpct_index, short enable)\r\n{\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nreturn;\r\nswitch (gpct_index) {\r\ncase 0:\r\nif (enable) {\r\ndevpriv->stc_writew(dev, G0_Gate_Second_Irq_Enable,\r\nSecond_IRQ_A_Enable_Register);\r\n} else {\r\ndevpriv->stc_writew(dev, 0,\r\nSecond_IRQ_A_Enable_Register);\r\n}\r\nbreak;\r\ncase 1:\r\nif (enable) {\r\ndevpriv->stc_writew(dev, G1_Gate_Second_Irq_Enable,\r\nSecond_IRQ_B_Enable_Register);\r\n} else {\r\ndevpriv->stc_writew(dev, 0,\r\nSecond_IRQ_B_Enable_Register);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic void ni_clear_ai_fifo(struct comedi_device *dev)\r\n{\r\nif (boardtype.reg_type == ni_reg_6143) {\r\nni_writel(0x10, AIFIFO_Control_6143);\r\nni_writel(0x00, AIFIFO_Control_6143);\r\nwhile (ni_readl(AIFIFO_Status_6143) & 0x10) ;\r\n} else {\r\ndevpriv->stc_writew(dev, 1, ADC_FIFO_Clear);\r\nif (boardtype.reg_type == ni_reg_625x) {\r\nni_writeb(0, M_Offset_Static_AI_Control(0));\r\nni_writeb(1, M_Offset_Static_AI_Control(0));\r\n#if 0\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\n#endif\r\n}\r\n}\r\n}\r\nstatic void win_out2(struct comedi_device *dev, uint32_t data, int reg)\r\n{\r\ndevpriv->stc_writew(dev, data >> 16, reg);\r\ndevpriv->stc_writew(dev, data & 0xffff, reg + 1);\r\n}\r\nstatic uint32_t win_in2(struct comedi_device *dev, int reg)\r\n{\r\nuint32_t bits;\r\nbits = devpriv->stc_readw(dev, reg) << 16;\r\nbits |= devpriv->stc_readw(dev, reg + 1);\r\nreturn bits;\r\n}\r\nstatic inline void ni_ao_win_outw(struct comedi_device *dev, uint16_t data,\r\nint addr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(addr, AO_Window_Address_611x);\r\nni_writew(data, AO_Window_Data_611x);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic inline void ni_ao_win_outl(struct comedi_device *dev, uint32_t data,\r\nint addr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(addr, AO_Window_Address_611x);\r\nni_writel(data, AO_Window_Data_611x);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)\r\n{\r\nunsigned long flags;\r\nunsigned short data;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(addr, AO_Window_Address_611x);\r\ndata = ni_readw(AO_Window_Data_611x);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\nreturn data;\r\n}\r\nstatic inline void ni_set_bits(struct comedi_device *dev, int reg,\r\nunsigned bits, unsigned value)\r\n{\r\nunsigned bit_values;\r\nif (value)\r\nbit_values = bits;\r\nelse\r\nbit_values = 0;\r\nni_set_bitfield(dev, reg, bits, bit_values);\r\n}\r\nstatic irqreturn_t ni_E_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned short a_status;\r\nunsigned short b_status;\r\nunsigned int ai_mite_status = 0;\r\nunsigned int ao_mite_status = 0;\r\nunsigned long flags;\r\n#ifdef PCIDMA\r\nstruct mite_struct *mite = devpriv->mite;\r\n#endif\r\nif (dev->attached == 0)\r\nreturn IRQ_NONE;\r\nsmp_mb();\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\na_status = devpriv->stc_readw(dev, AI_Status_1_Register);\r\nb_status = devpriv->stc_readw(dev, AO_Status_1_Register);\r\n#ifdef PCIDMA\r\nif (mite) {\r\nunsigned long flags_too;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);\r\nif (devpriv->ai_mite_chan) {\r\nai_mite_status = mite_get_status(devpriv->ai_mite_chan);\r\nif (ai_mite_status & CHSR_LINKC)\r\nwritel(CHOR_CLRLC,\r\ndevpriv->mite->mite_io_addr +\r\nMITE_CHOR(devpriv->\r\nai_mite_chan->channel));\r\n}\r\nif (devpriv->ao_mite_chan) {\r\nao_mite_status = mite_get_status(devpriv->ao_mite_chan);\r\nif (ao_mite_status & CHSR_LINKC)\r\nwritel(CHOR_CLRLC,\r\nmite->mite_io_addr +\r\nMITE_CHOR(devpriv->\r\nao_mite_chan->channel));\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);\r\n}\r\n#endif\r\nack_a_interrupt(dev, a_status);\r\nack_b_interrupt(dev, b_status);\r\nif ((a_status & Interrupt_A_St) || (ai_mite_status & CHSR_INT))\r\nhandle_a_interrupt(dev, a_status, ai_mite_status);\r\nif ((b_status & Interrupt_B_St) || (ao_mite_status & CHSR_INT))\r\nhandle_b_interrupt(dev, b_status, ao_mite_status);\r\nhandle_gpct_interrupt(dev, 0);\r\nhandle_gpct_interrupt(dev, 1);\r\nhandle_cdio_interrupt(dev);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ni_sync_ai_dma(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan)\r\nmite_sync_input_dma(devpriv->ai_mite_chan, s->async);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic void mite_handle_b_linkc(struct mite_struct *mite,\r\nstruct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ao_mite_chan) {\r\nmite_sync_output_dma(devpriv->ao_mite_chan, s->async);\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n}\r\nstatic int ni_ao_wait_for_dma_load(struct comedi_device *dev)\r\n{\r\nstatic const int timeout = 10000;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nunsigned short b_status;\r\nb_status = devpriv->stc_readw(dev, AO_Status_1_Register);\r\nif (b_status & AO_FIFO_Half_Full_St)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timed out waiting for dma load");\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nif (devpriv->aimode == AIMODE_SCAN) {\r\n#ifdef PCIDMA\r\nstatic const int timeout = 10;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nni_sync_ai_dma(dev);\r\nif ((s->async->events & COMEDI_CB_EOS))\r\nbreak;\r\nudelay(1);\r\n}\r\n#else\r\nni_handle_fifo_dregs(dev);\r\ns->async->events |= COMEDI_CB_EOS;\r\n#endif\r\n}\r\nif ((devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {\r\nshutdown_ai_command(dev);\r\n}\r\n}\r\nstatic void shutdown_ai_command(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\n#ifdef PCIDMA\r\nni_ai_drain_dma(dev);\r\n#endif\r\nni_handle_fifo_dregs(dev);\r\nget_last_sample_611x(dev);\r\nget_last_sample_6143(dev);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\nstatic void ni_event(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nif (s->\r\nasync->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW |\r\nCOMEDI_CB_EOA)) {\r\nswitch (s - dev->subdevices) {\r\ncase NI_AI_SUBDEV:\r\nni_ai_reset(dev, s);\r\nbreak;\r\ncase NI_AO_SUBDEV:\r\nni_ao_reset(dev, s);\r\nbreak;\r\ncase NI_GPCT0_SUBDEV:\r\ncase NI_GPCT1_SUBDEV:\r\nni_gpct_cancel(dev, s);\r\nbreak;\r\ncase NI_DIO_SUBDEV:\r\nni_cdio_cancel(dev, s);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic void handle_gpct_interrupt(struct comedi_device *dev,\r\nunsigned short counter_index)\r\n{\r\n#ifdef PCIDMA\r\nstruct comedi_subdevice *s =\r\ndev->subdevices + NI_GPCT_SUBDEV(counter_index);\r\nni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],\r\ns);\r\nif (s->async->events)\r\nni_event(dev, s);\r\n#endif\r\n}\r\nstatic void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)\r\n{\r\nunsigned short ack = 0;\r\nif (a_status & AI_SC_TC_St) {\r\nack |= AI_SC_TC_Interrupt_Ack;\r\n}\r\nif (a_status & AI_START1_St) {\r\nack |= AI_START1_Interrupt_Ack;\r\n}\r\nif (a_status & AI_START_St) {\r\nack |= AI_START_Interrupt_Ack;\r\n}\r\nif (a_status & AI_STOP_St) {\r\nack |= AI_STOP_Interrupt_Ack ;\r\n}\r\nif (ack)\r\ndevpriv->stc_writew(dev, ack, Interrupt_A_Ack_Register);\r\n}\r\nstatic void handle_a_interrupt(struct comedi_device *dev, unsigned short status,\r\nunsigned ai_mite_status)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nif (s->type == COMEDI_SUBD_UNUSED)\r\nreturn;\r\n#ifdef DEBUG_INTERRUPT\r\nprintk\r\n("ni_mio_common: interrupt: a_status=%04x ai_mite_status=%08x\n",\r\nstatus, ai_mite_status);\r\nni_mio_print_status_a(status);\r\n#endif\r\n#ifdef PCIDMA\r\nif (ai_mite_status & CHSR_LINKC) {\r\nni_sync_ai_dma(dev);\r\n}\r\nif (ai_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |\r\nCHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |\r\nCHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {\r\nprintk\r\n("unknown mite interrupt, ack! (ai_mite_status=%08x)\n",\r\nai_mite_status);\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\n}\r\n#endif\r\nif (status & (AI_Overrun_St | AI_Overflow_St | AI_SC_TC_Error_St |\r\nAI_SC_TC_St | AI_START1_St)) {\r\nif (status == 0xffff) {\r\nprintk\r\n("ni_mio_common: a_status=0xffff. Card removed?\n");\r\nif (comedi_get_subdevice_runflags(s) & SRF_RUNNING) {\r\ns->async->events |=\r\nCOMEDI_CB_ERROR | COMEDI_CB_EOA;\r\nni_event(dev, s);\r\n}\r\nreturn;\r\n}\r\nif (status & (AI_Overrun_St | AI_Overflow_St |\r\nAI_SC_TC_Error_St)) {\r\nprintk("ni_mio_common: ai error a_status=%04x\n",\r\nstatus);\r\nni_mio_print_status_a(status);\r\nshutdown_ai_command(dev);\r\ns->async->events |= COMEDI_CB_ERROR;\r\nif (status & (AI_Overrun_St | AI_Overflow_St))\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nni_event(dev, s);\r\nreturn;\r\n}\r\nif (status & AI_SC_TC_St) {\r\n#ifdef DEBUG_INTERRUPT\r\nprintk("ni_mio_common: SC_TC interrupt\n");\r\n#endif\r\nif (!devpriv->ai_continuous) {\r\nshutdown_ai_command(dev);\r\n}\r\n}\r\n}\r\n#ifndef PCIDMA\r\nif (status & AI_FIFO_Half_Full_St) {\r\nint i;\r\nstatic const int timeout = 10;\r\nfor (i = 0; i < timeout; ++i) {\r\nni_handle_fifo_half_full(dev);\r\nif ((devpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Half_Full_St) == 0)\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif ((status & AI_STOP_St)) {\r\nni_handle_eos(dev, s);\r\n}\r\nni_event(dev, s);\r\n#ifdef DEBUG_INTERRUPT\r\nstatus = devpriv->stc_readw(dev, AI_Status_1_Register);\r\nif (status & Interrupt_A_St) {\r\nprintk\r\n("handle_a_interrupt: didn't clear interrupt? status=0x%x\n",\r\nstatus);\r\n}\r\n#endif\r\n}\r\nstatic void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)\r\n{\r\nunsigned short ack = 0;\r\nif (b_status & AO_BC_TC_St) {\r\nack |= AO_BC_TC_Interrupt_Ack;\r\n}\r\nif (b_status & AO_Overrun_St) {\r\nack |= AO_Error_Interrupt_Ack;\r\n}\r\nif (b_status & AO_START_St) {\r\nack |= AO_START_Interrupt_Ack;\r\n}\r\nif (b_status & AO_START1_St) {\r\nack |= AO_START1_Interrupt_Ack;\r\n}\r\nif (b_status & AO_UC_TC_St) {\r\nack |= AO_UC_TC_Interrupt_Ack;\r\n}\r\nif (b_status & AO_UI2_TC_St) {\r\nack |= AO_UI2_TC_Interrupt_Ack;\r\n}\r\nif (b_status & AO_UPDATE_St) {\r\nack |= AO_UPDATE_Interrupt_Ack;\r\n}\r\nif (ack)\r\ndevpriv->stc_writew(dev, ack, Interrupt_B_Ack_Register);\r\n}\r\nstatic void handle_b_interrupt(struct comedi_device *dev,\r\nunsigned short b_status, unsigned ao_mite_status)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;\r\n#ifdef DEBUG_INTERRUPT\r\nprintk("ni_mio_common: interrupt: b_status=%04x m1_status=%08x\n",\r\nb_status, ao_mite_status);\r\nni_mio_print_status_b(b_status);\r\n#endif\r\n#ifdef PCIDMA\r\nif (ao_mite_status & CHSR_LINKC) {\r\nmite_handle_b_linkc(devpriv->mite, dev);\r\n}\r\nif (ao_mite_status & ~(CHSR_INT | CHSR_LINKC | CHSR_DONE | CHSR_MRDY |\r\nCHSR_DRDY | CHSR_DRQ1 | CHSR_DRQ0 | CHSR_ERROR |\r\nCHSR_SABORT | CHSR_XFERR | CHSR_LxERR_mask)) {\r\nprintk\r\n("unknown mite interrupt, ack! (ao_mite_status=%08x)\n",\r\nao_mite_status);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\n}\r\n#endif\r\nif (b_status == 0xffff)\r\nreturn;\r\nif (b_status & AO_Overrun_St) {\r\nprintk\r\n("ni_mio_common: AO FIFO underrun status=0x%04x status2=0x%04x\n",\r\nb_status, devpriv->stc_readw(dev, AO_Status_2_Register));\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nif (b_status & AO_BC_TC_St) {\r\nMDPRINTK\r\n("ni_mio_common: AO BC_TC status=0x%04x status2=0x%04x\n",\r\nb_status, devpriv->stc_readw(dev, AO_Status_2_Register));\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\n#ifndef PCIDMA\r\nif (b_status & AO_FIFO_Request_St) {\r\nint ret;\r\nret = ni_ao_fifo_half_empty(dev, s);\r\nif (!ret) {\r\nprintk("ni_mio_common: AO buffer underrun\n");\r\nni_set_bits(dev, Interrupt_B_Enable_Register,\r\nAO_FIFO_Interrupt_Enable |\r\nAO_Error_Interrupt_Enable, 0);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\n}\r\n#endif\r\nni_event(dev, s);\r\n}\r\nstatic void ni_mio_print_status_a(int status)\r\n{\r\nint i;\r\nprintk("A status:");\r\nfor (i = 15; i >= 0; i--) {\r\nif (status & (1 << i)) {\r\nprintk(" %s", status_a_strings[i]);\r\n}\r\n}\r\nprintk("\n");\r\n}\r\nstatic void ni_mio_print_status_b(int status)\r\n{\r\nint i;\r\nprintk("B status:");\r\nfor (i = 15; i >= 0; i--) {\r\nif (status & (1 << i)) {\r\nprintk(" %s", status_b_strings[i]);\r\n}\r\n}\r\nprintk("\n");\r\n}\r\nstatic void ni_ao_fifo_load(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint chan;\r\nint i;\r\nshort d;\r\nu32 packed_data;\r\nint range;\r\nint err = 1;\r\nchan = async->cur_chan;\r\nfor (i = 0; i < n; i++) {\r\nerr &= comedi_buf_get(async, &d);\r\nif (err == 0)\r\nbreak;\r\nrange = CR_RANGE(cmd->chanlist[chan]);\r\nif (boardtype.reg_type & ni_reg_6xxx_mask) {\r\npacked_data = d & 0xffff;\r\nif (boardtype.reg_type != ni_reg_6711) {\r\nerr &= comedi_buf_get(async, &d);\r\nif (err == 0)\r\nbreak;\r\nchan++;\r\ni++;\r\npacked_data |= (d << 16) & 0xffff0000;\r\n}\r\nni_writel(packed_data, DAC_FIFO_Data_611x);\r\n} else {\r\nni_writew(d, DAC_FIFO_Data);\r\n}\r\nchan++;\r\nchan %= cmd->chanlist_len;\r\n}\r\nasync->cur_chan = chan;\r\nif (err == 0) {\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\n}\r\n}\r\nstatic int ni_ao_fifo_half_empty(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint n;\r\nn = comedi_buf_read_n_available(s->async);\r\nif (n == 0) {\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nreturn 0;\r\n}\r\nn /= sizeof(short);\r\nif (n > boardtype.ao_fifo_depth / 2)\r\nn = boardtype.ao_fifo_depth / 2;\r\nni_ao_fifo_load(dev, s, n);\r\ns->async->events |= COMEDI_CB_BLOCK;\r\nreturn 1;\r\n}\r\nstatic int ni_ao_prep_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint n;\r\ndevpriv->stc_writew(dev, 1, DAC_FIFO_Clear);\r\nif (boardtype.reg_type & ni_reg_6xxx_mask)\r\nni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);\r\nn = comedi_buf_read_n_available(s->async);\r\nif (n == 0)\r\nreturn 0;\r\nn /= sizeof(short);\r\nif (n > boardtype.ao_fifo_depth)\r\nn = boardtype.ao_fifo_depth;\r\nni_ao_fifo_load(dev, s, n);\r\nreturn n;\r\n}\r\nstatic void ni_ai_fifo_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, int n)\r\n{\r\nstruct comedi_async *async = s->async;\r\nint i;\r\nif (boardtype.reg_type == ni_reg_611x) {\r\nshort data[2];\r\nu32 dl;\r\nfor (i = 0; i < n / 2; i++) {\r\ndl = ni_readl(ADC_FIFO_Data_611x);\r\ndata[0] = (dl >> 16) & 0xffff;\r\ndata[1] = dl & 0xffff;\r\ncfc_write_array_to_buffer(s, data, sizeof(data));\r\n}\r\nif (n % 2) {\r\ndl = ni_readl(ADC_FIFO_Data_611x);\r\ndata[0] = dl & 0xffff;\r\ncfc_write_to_buffer(s, data[0]);\r\n}\r\n} else if (boardtype.reg_type == ni_reg_6143) {\r\nshort data[2];\r\nu32 dl;\r\nfor (i = 0; i < n / 2; i++) {\r\ndl = ni_readl(AIFIFO_Data_6143);\r\ndata[0] = (dl >> 16) & 0xffff;\r\ndata[1] = dl & 0xffff;\r\ncfc_write_array_to_buffer(s, data, sizeof(data));\r\n}\r\nif (n % 2) {\r\nni_writel(0x01, AIFIFO_Control_6143);\r\ndl = ni_readl(AIFIFO_Data_6143);\r\ndata[0] = (dl >> 16) & 0xffff;\r\ncfc_write_to_buffer(s, data[0]);\r\n}\r\n} else {\r\nif (n > sizeof(devpriv->ai_fifo_buffer) /\r\nsizeof(devpriv->ai_fifo_buffer[0])) {\r\ncomedi_error(dev, "bug! ai_fifo_buffer too small");\r\nasync->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nfor (i = 0; i < n; i++) {\r\ndevpriv->ai_fifo_buffer[i] =\r\nni_readw(ADC_FIFO_Data_Register);\r\n}\r\ncfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,\r\nn *\r\nsizeof(devpriv->ai_fifo_buffer[0]));\r\n}\r\n}\r\nstatic void ni_handle_fifo_half_full(struct comedi_device *dev)\r\n{\r\nint n;\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nn = boardtype.ai_fifo_depth / 2;\r\nni_ai_fifo_read(dev, s, n);\r\n}\r\nstatic int ni_ai_drain_dma(struct comedi_device *dev)\r\n{\r\nint i;\r\nstatic const int timeout = 10000;\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan) {\r\nfor (i = 0; i < timeout; i++) {\r\nif ((devpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Empty_St)\r\n&& mite_bytes_in_transit(devpriv->ai_mite_chan) ==\r\n0)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (i == timeout) {\r\nprintk("ni_mio_common: wait for dma drain timed out\n");\r\nprintk\r\n("mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\n",\r\nmite_bytes_in_transit(devpriv->ai_mite_chan),\r\ndevpriv->stc_readw(dev, AI_Status_1_Register));\r\nretval = -1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nni_sync_ai_dma(dev);\r\nreturn retval;\r\n}\r\nstatic void ni_handle_fifo_dregs(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nshort data[2];\r\nu32 dl;\r\nshort fifo_empty;\r\nint i;\r\nif (boardtype.reg_type == ni_reg_611x) {\r\nwhile ((devpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Empty_St) == 0) {\r\ndl = ni_readl(ADC_FIFO_Data_611x);\r\ndata[0] = (dl >> 16);\r\ndata[1] = (dl & 0xffff);\r\ncfc_write_array_to_buffer(s, data, sizeof(data));\r\n}\r\n} else if (boardtype.reg_type == ni_reg_6143) {\r\ni = 0;\r\nwhile (ni_readl(AIFIFO_Status_6143) & 0x04) {\r\ndl = ni_readl(AIFIFO_Data_6143);\r\ndata[0] = (dl >> 16);\r\ndata[1] = (dl & 0xffff);\r\ncfc_write_array_to_buffer(s, data, sizeof(data));\r\ni += 2;\r\n}\r\nif (ni_readl(AIFIFO_Status_6143) & 0x01) {\r\nni_writel(0x01, AIFIFO_Control_6143);\r\ndl = ni_readl(AIFIFO_Data_6143);\r\ndata[0] = (dl >> 16) & 0xffff;\r\ncfc_write_to_buffer(s, data[0]);\r\n}\r\n} else {\r\nfifo_empty =\r\ndevpriv->stc_readw(dev,\r\nAI_Status_1_Register) & AI_FIFO_Empty_St;\r\nwhile (fifo_empty == 0) {\r\nfor (i = 0;\r\ni <\r\nsizeof(devpriv->ai_fifo_buffer) /\r\nsizeof(devpriv->ai_fifo_buffer[0]); i++) {\r\nfifo_empty =\r\ndevpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Empty_St;\r\nif (fifo_empty)\r\nbreak;\r\ndevpriv->ai_fifo_buffer[i] =\r\nni_readw(ADC_FIFO_Data_Register);\r\n}\r\ncfc_write_array_to_buffer(s, devpriv->ai_fifo_buffer,\r\ni *\r\nsizeof(devpriv->\r\nai_fifo_buffer[0]));\r\n}\r\n}\r\n}\r\nstatic void get_last_sample_611x(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nshort data;\r\nu32 dl;\r\nif (boardtype.reg_type != ni_reg_611x)\r\nreturn;\r\nif (ni_readb(XXX_Status) & 0x80) {\r\ndl = ni_readl(ADC_FIFO_Data_611x);\r\ndata = (dl & 0xffff);\r\ncfc_write_to_buffer(s, data);\r\n}\r\n}\r\nstatic void get_last_sample_6143(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nshort data;\r\nu32 dl;\r\nif (boardtype.reg_type != ni_reg_6143)\r\nreturn;\r\nif (ni_readl(AIFIFO_Status_6143) & 0x01) {\r\nni_writel(0x01, AIFIFO_Control_6143);\r\ndl = ni_readl(AIFIFO_Data_6143);\r\ndata = (dl >> 16) & 0xffff;\r\ncfc_write_to_buffer(s, data);\r\n}\r\n}\r\nstatic void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,\r\nvoid *data, unsigned int num_bytes,\r\nunsigned int chan_index)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int i;\r\nunsigned int length = num_bytes / bytes_per_sample(s);\r\nshort *array = data;\r\nunsigned int *larray = data;\r\nfor (i = 0; i < length; i++) {\r\n#ifdef PCIDMA\r\nif (s->subdev_flags & SDF_LSAMPL)\r\nlarray[i] = le32_to_cpu(larray[i]);\r\nelse\r\narray[i] = le16_to_cpu(array[i]);\r\n#endif\r\nif (s->subdev_flags & SDF_LSAMPL)\r\nlarray[i] += devpriv->ai_offset[chan_index];\r\nelse\r\narray[i] += devpriv->ai_offset[chan_index];\r\nchan_index++;\r\nchan_index %= async->cmd.chanlist_len;\r\n}\r\n}\r\nstatic int ni_ai_setup_MITE_dma(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AI_SUBDEV;\r\nint retval;\r\nunsigned long flags;\r\nretval = ni_request_ai_mite_channel(dev);\r\nif (retval)\r\nreturn retval;\r\ncomedi_buf_write_alloc(s->async, s->async->prealloc_bufsz);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ai_mite_chan == NULL) {\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn -EIO;\r\n}\r\nswitch (boardtype.reg_type) {\r\ncase ni_reg_611x:\r\ncase ni_reg_6143:\r\nmite_prep_dma(devpriv->ai_mite_chan, 32, 16);\r\nbreak;\r\ncase ni_reg_628x:\r\nmite_prep_dma(devpriv->ai_mite_chan, 32, 32);\r\nbreak;\r\ndefault:\r\nmite_prep_dma(devpriv->ai_mite_chan, 16, 16);\r\nbreak;\r\n}\r\nmite_dma_arm(devpriv->ai_mite_chan);\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ni_ao_setup_MITE_dma(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + NI_AO_SUBDEV;\r\nint retval;\r\nunsigned long flags;\r\nretval = ni_request_ao_mite_channel(dev);\r\nif (retval)\r\nreturn retval;\r\ncomedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->ao_mite_chan) {\r\nif (boardtype.reg_type & (ni_reg_611x | ni_reg_6713)) {\r\nmite_prep_dma(devpriv->ao_mite_chan, 32, 32);\r\n} else {\r\nmite_prep_dma(devpriv->ao_mite_chan, 16, 32);\r\n}\r\nmite_dma_arm(devpriv->ao_mite_chan);\r\n} else\r\nretval = -EIO;\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nni_release_ai_mite_channel(dev);\r\ndevpriv->stc_writew(dev, AI_Configuration_Start | AI_Reset,\r\nJoint_Reset_Register);\r\nni_set_bits(dev, Interrupt_A_Enable_Register,\r\nAI_SC_TC_Interrupt_Enable | AI_START1_Interrupt_Enable |\r\nAI_START2_Interrupt_Enable | AI_START_Interrupt_Enable |\r\nAI_STOP_Interrupt_Enable | AI_Error_Interrupt_Enable |\r\nAI_FIFO_Interrupt_Enable, 0);\r\nni_clear_ai_fifo(dev);\r\nif (boardtype.reg_type != ni_reg_6143)\r\nni_writeb(0, Misc_Command);\r\ndevpriv->stc_writew(dev, AI_Disarm, AI_Command_1_Register);\r\ndevpriv->stc_writew(dev,\r\nAI_Start_Stop | AI_Mode_1_Reserved\r\n,\r\nAI_Mode_1_Register);\r\ndevpriv->stc_writew(dev, 0x0000, AI_Mode_2_Register);\r\ndevpriv->stc_writew(dev, (0 << 6) | 0x0000, AI_Mode_3_Register);\r\nif (boardtype.reg_type == ni_reg_611x) {\r\ndevpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |\r\nAI_SOC_Polarity |\r\nAI_LOCALMUX_CLK_Pulse_Width,\r\nAI_Personal_Register);\r\ndevpriv->stc_writew(dev,\r\nAI_SCAN_IN_PROG_Output_Select(3) |\r\nAI_EXTMUX_CLK_Output_Select(0) |\r\nAI_LOCALMUX_CLK_Output_Select(2) |\r\nAI_SC_TC_Output_Select(3) |\r\nAI_CONVERT_Output_Select\r\n(AI_CONVERT_Output_Enable_High),\r\nAI_Output_Control_Register);\r\n} else if (boardtype.reg_type == ni_reg_6143) {\r\ndevpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |\r\nAI_SOC_Polarity |\r\nAI_LOCALMUX_CLK_Pulse_Width,\r\nAI_Personal_Register);\r\ndevpriv->stc_writew(dev,\r\nAI_SCAN_IN_PROG_Output_Select(3) |\r\nAI_EXTMUX_CLK_Output_Select(0) |\r\nAI_LOCALMUX_CLK_Output_Select(2) |\r\nAI_SC_TC_Output_Select(3) |\r\nAI_CONVERT_Output_Select\r\n(AI_CONVERT_Output_Enable_Low),\r\nAI_Output_Control_Register);\r\n} else {\r\nunsigned ai_output_control_bits;\r\ndevpriv->stc_writew(dev, AI_SHIFTIN_Pulse_Width |\r\nAI_SOC_Polarity |\r\nAI_CONVERT_Pulse_Width |\r\nAI_LOCALMUX_CLK_Pulse_Width,\r\nAI_Personal_Register);\r\nai_output_control_bits =\r\nAI_SCAN_IN_PROG_Output_Select(3) |\r\nAI_EXTMUX_CLK_Output_Select(0) |\r\nAI_LOCALMUX_CLK_Output_Select(2) |\r\nAI_SC_TC_Output_Select(3);\r\nif (boardtype.reg_type == ni_reg_622x)\r\nai_output_control_bits |=\r\nAI_CONVERT_Output_Select\r\n(AI_CONVERT_Output_Enable_High);\r\nelse\r\nai_output_control_bits |=\r\nAI_CONVERT_Output_Select\r\n(AI_CONVERT_Output_Enable_Low);\r\ndevpriv->stc_writew(dev, ai_output_control_bits,\r\nAI_Output_Control_Register);\r\n}\r\ndevpriv->stc_writew(dev, AI_SC_TC_Error_Confirm | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack, Interrupt_A_Ack_Register);\r\ndevpriv->stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);\r\nreturn 0;\r\n}\r\nstatic int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags = 0;\r\nint count;\r\nif (in_interrupt() == 0)\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\n#ifndef PCIDMA\r\nni_handle_fifo_dregs(dev);\r\n#else\r\nni_sync_ai_dma(dev);\r\n#endif\r\ncount = s->async->buf_write_count - s->async->buf_read_count;\r\nif (in_interrupt() == 0)\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn count;\r\n}\r\nstatic int ni_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i, n;\r\nconst unsigned int mask = (1 << boardtype.adbits) - 1;\r\nunsigned signbits;\r\nunsigned short d;\r\nunsigned long dl;\r\nni_load_channelgain_list(dev, 1, &insn->chanspec);\r\nni_clear_ai_fifo(dev);\r\nsignbits = devpriv->ai_offset[0];\r\nif (boardtype.reg_type == ni_reg_611x) {\r\nfor (n = 0; n < num_adc_stages_611x; n++) {\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\nudelay(1);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\nd = 0;\r\nfor (i = 0; i < NI_TIMEOUT; i++) {\r\nif (ni_readb(XXX_Status) & 0x80) {\r\nd = (ni_readl(ADC_FIFO_Data_611x) >> 16)\r\n& 0xffff;\r\nbreak;\r\n}\r\nif (!(devpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Empty_St)) {\r\nd = ni_readl(ADC_FIFO_Data_611x) &\r\n0xffff;\r\nbreak;\r\n}\r\n}\r\nif (i == NI_TIMEOUT) {\r\nprintk\r\n("ni_mio_common: timeout in 611x ni_ai_insn_read\n");\r\nreturn -ETIME;\r\n}\r\nd += signbits;\r\ndata[n] = d;\r\n}\r\n} else if (boardtype.reg_type == ni_reg_6143) {\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\ndl = 0;\r\nfor (i = 0; i < NI_TIMEOUT; i++) {\r\nif (ni_readl(AIFIFO_Status_6143) & 0x01) {\r\nni_writel(0x01, AIFIFO_Control_6143);\r\ndl = ni_readl(AIFIFO_Data_6143);\r\nbreak;\r\n}\r\n}\r\nif (i == NI_TIMEOUT) {\r\nprintk\r\n("ni_mio_common: timeout in 6143 ni_ai_insn_read\n");\r\nreturn -ETIME;\r\n}\r\ndata[n] = (((dl >> 16) & 0xFFFF) + signbits) & 0xFFFF;\r\n}\r\n} else {\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse,\r\nAI_Command_1_Register);\r\nfor (i = 0; i < NI_TIMEOUT; i++) {\r\nif (!(devpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Empty_St))\r\nbreak;\r\n}\r\nif (i == NI_TIMEOUT) {\r\nprintk\r\n("ni_mio_common: timeout in ni_ai_insn_read\n");\r\nreturn -ETIME;\r\n}\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\ndata[n] =\r\nni_readl(M_Offset_AI_FIFO_Data) & mask;\r\n} else {\r\nd = ni_readw(ADC_FIFO_Data_Register);\r\nd += signbits;\r\ndata[n] = d;\r\n}\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nvoid ni_prime_channelgain_list(struct comedi_device *dev)\r\n{\r\nint i;\r\ndevpriv->stc_writew(dev, AI_CONVERT_Pulse, AI_Command_1_Register);\r\nfor (i = 0; i < NI_TIMEOUT; ++i) {\r\nif (!(devpriv->stc_readw(dev,\r\nAI_Status_1_Register) &\r\nAI_FIFO_Empty_St)) {\r\ndevpriv->stc_writew(dev, 1, ADC_FIFO_Clear);\r\nreturn;\r\n}\r\nudelay(1);\r\n}\r\nprintk("ni_mio_common: timeout loading channel/gain list\n");\r\n}\r\nstatic void ni_m_series_load_channelgain_list(struct comedi_device *dev,\r\nunsigned int n_chan,\r\nunsigned int *list)\r\n{\r\nunsigned int chan, range, aref;\r\nunsigned int i;\r\nunsigned offset;\r\nunsigned int dither;\r\nunsigned range_code;\r\ndevpriv->stc_writew(dev, 1, Configuration_Memory_Clear);\r\nif ((list[0] & CR_ALT_SOURCE)) {\r\nunsigned bypass_bits;\r\nchan = CR_CHAN(list[0]);\r\nrange = CR_RANGE(list[0]);\r\nrange_code = ni_gainlkup[boardtype.gainlkup][range];\r\ndither = ((list[0] & CR_ALT_FILTER) != 0);\r\nbypass_bits = MSeries_AI_Bypass_Config_FIFO_Bit;\r\nbypass_bits |= chan;\r\nbypass_bits |=\r\n(devpriv->ai_calib_source) &\r\n(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |\r\nMSeries_AI_Bypass_Cal_Sel_Neg_Mask |\r\nMSeries_AI_Bypass_Mode_Mux_Mask |\r\nMSeries_AO_Bypass_AO_Cal_Sel_Mask);\r\nbypass_bits |= MSeries_AI_Bypass_Gain_Bits(range_code);\r\nif (dither)\r\nbypass_bits |= MSeries_AI_Bypass_Dither_Bit;\r\nbypass_bits |= MSeries_AI_Bypass_Polarity_Bit;\r\nni_writel(bypass_bits, M_Offset_AI_Config_FIFO_Bypass);\r\n} else {\r\nni_writel(0, M_Offset_AI_Config_FIFO_Bypass);\r\n}\r\noffset = 0;\r\nfor (i = 0; i < n_chan; i++) {\r\nunsigned config_bits = 0;\r\nchan = CR_CHAN(list[i]);\r\naref = CR_AREF(list[i]);\r\nrange = CR_RANGE(list[i]);\r\ndither = ((list[i] & CR_ALT_FILTER) != 0);\r\nrange_code = ni_gainlkup[boardtype.gainlkup][range];\r\ndevpriv->ai_offset[i] = offset;\r\nswitch (aref) {\r\ncase AREF_DIFF:\r\nconfig_bits |=\r\nMSeries_AI_Config_Channel_Type_Differential_Bits;\r\nbreak;\r\ncase AREF_COMMON:\r\nconfig_bits |=\r\nMSeries_AI_Config_Channel_Type_Common_Ref_Bits;\r\nbreak;\r\ncase AREF_GROUND:\r\nconfig_bits |=\r\nMSeries_AI_Config_Channel_Type_Ground_Ref_Bits;\r\nbreak;\r\ncase AREF_OTHER:\r\nbreak;\r\n}\r\nconfig_bits |= MSeries_AI_Config_Channel_Bits(chan);\r\nconfig_bits |=\r\nMSeries_AI_Config_Bank_Bits(boardtype.reg_type, chan);\r\nconfig_bits |= MSeries_AI_Config_Gain_Bits(range_code);\r\nif (i == n_chan - 1)\r\nconfig_bits |= MSeries_AI_Config_Last_Channel_Bit;\r\nif (dither)\r\nconfig_bits |= MSeries_AI_Config_Dither_Bit;\r\nconfig_bits |= MSeries_AI_Config_Polarity_Bit;\r\nni_writew(config_bits, M_Offset_AI_Config_FIFO_Data);\r\n}\r\nni_prime_channelgain_list(dev);\r\n}\r\nstatic void ni_load_channelgain_list(struct comedi_device *dev,\r\nunsigned int n_chan, unsigned int *list)\r\n{\r\nunsigned int chan, range, aref;\r\nunsigned int i;\r\nunsigned int hi, lo;\r\nunsigned offset;\r\nunsigned int dither;\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\nni_m_series_load_channelgain_list(dev, n_chan, list);\r\nreturn;\r\n}\r\nif (n_chan == 1 && (boardtype.reg_type != ni_reg_611x)\r\n&& (boardtype.reg_type != ni_reg_6143)) {\r\nif (devpriv->changain_state\r\n&& devpriv->changain_spec == list[0]) {\r\nreturn;\r\n}\r\ndevpriv->changain_state = 1;\r\ndevpriv->changain_spec = list[0];\r\n} else {\r\ndevpriv->changain_state = 0;\r\n}\r\ndevpriv->stc_writew(dev, 1, Configuration_Memory_Clear);\r\nif (boardtype.reg_type == ni_reg_6143) {\r\nif ((list[0] & CR_ALT_SOURCE)\r\n&& !devpriv->ai_calib_source_enabled) {\r\nni_writew(devpriv->ai_calib_source |\r\nCalibration_Channel_6143_RelayOn,\r\nCalibration_Channel_6143);\r\nni_writew(devpriv->ai_calib_source,\r\nCalibration_Channel_6143);\r\ndevpriv->ai_calib_source_enabled = 1;\r\nmsleep_interruptible(100);\r\n} else if (!(list[0] & CR_ALT_SOURCE)\r\n&& devpriv->ai_calib_source_enabled) {\r\nni_writew(devpriv->ai_calib_source |\r\nCalibration_Channel_6143_RelayOff,\r\nCalibration_Channel_6143);\r\nni_writew(devpriv->ai_calib_source,\r\nCalibration_Channel_6143);\r\ndevpriv->ai_calib_source_enabled = 0;\r\nmsleep_interruptible(100);\r\n}\r\n}\r\noffset = 1 << (boardtype.adbits - 1);\r\nfor (i = 0; i < n_chan; i++) {\r\nif ((boardtype.reg_type != ni_reg_6143)\r\n&& (list[i] & CR_ALT_SOURCE)) {\r\nchan = devpriv->ai_calib_source;\r\n} else {\r\nchan = CR_CHAN(list[i]);\r\n}\r\naref = CR_AREF(list[i]);\r\nrange = CR_RANGE(list[i]);\r\ndither = ((list[i] & CR_ALT_FILTER) != 0);\r\nrange = ni_gainlkup[boardtype.gainlkup][range];\r\nif (boardtype.reg_type == ni_reg_611x)\r\ndevpriv->ai_offset[i] = offset;\r\nelse\r\ndevpriv->ai_offset[i] = (range & 0x100) ? 0 : offset;\r\nhi = 0;\r\nif ((list[i] & CR_ALT_SOURCE)) {\r\nif (boardtype.reg_type == ni_reg_611x)\r\nni_writew(CR_CHAN(list[i]) & 0x0003,\r\nCalibration_Channel_Select_611x);\r\n} else {\r\nif (boardtype.reg_type == ni_reg_611x)\r\naref = AREF_DIFF;\r\nelse if (boardtype.reg_type == ni_reg_6143)\r\naref = AREF_OTHER;\r\nswitch (aref) {\r\ncase AREF_DIFF:\r\nhi |= AI_DIFFERENTIAL;\r\nbreak;\r\ncase AREF_COMMON:\r\nhi |= AI_COMMON;\r\nbreak;\r\ncase AREF_GROUND:\r\nhi |= AI_GROUND;\r\nbreak;\r\ncase AREF_OTHER:\r\nbreak;\r\n}\r\n}\r\nhi |= AI_CONFIG_CHANNEL(chan);\r\nni_writew(hi, Configuration_Memory_High);\r\nif (boardtype.reg_type != ni_reg_6143) {\r\nlo = range;\r\nif (i == n_chan - 1)\r\nlo |= AI_LAST_CHANNEL;\r\nif (dither)\r\nlo |= AI_DITHER;\r\nni_writew(lo, Configuration_Memory_Low);\r\n}\r\n}\r\nif ((boardtype.reg_type != ni_reg_611x)\r\n&& (boardtype.reg_type != ni_reg_6143)) {\r\nni_prime_channelgain_list(dev);\r\n}\r\n}\r\nstatic int ni_ns_to_timer(const struct comedi_device *dev, unsigned nanosec,\r\nint round_mode)\r\n{\r\nint divider;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivider = (nanosec + devpriv->clock_ns / 2) / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivider = (nanosec) / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndivider = (nanosec + devpriv->clock_ns - 1) / devpriv->clock_ns;\r\nbreak;\r\n}\r\nreturn divider - 1;\r\n}\r\nstatic unsigned ni_timer_to_ns(const struct comedi_device *dev, int timer)\r\n{\r\nreturn devpriv->clock_ns * (timer + 1);\r\n}\r\nstatic unsigned ni_min_ai_scan_period_ns(struct comedi_device *dev,\r\nunsigned num_channels)\r\n{\r\nswitch (boardtype.reg_type) {\r\ncase ni_reg_611x:\r\ncase ni_reg_6143:\r\nreturn boardtype.ai_speed;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn boardtype.ai_speed * num_channels;\r\n}\r\nstatic int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nint sources;\r\nif ((cmd->flags & CMDF_WRITE)) {\r\ncmd->flags &= ~CMDF_WRITE;\r\n}\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\nsources = TRIG_TIMER | TRIG_EXT;\r\nif ((boardtype.reg_type == ni_reg_611x)\r\n|| (boardtype.reg_type == ni_reg_6143))\r\nsources |= TRIG_NOW;\r\ncmd->convert_src &= sources;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW &&\r\ncmd->start_src != TRIG_INT && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT &&\r\ncmd->scan_begin_src != TRIG_OTHER)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src == TRIG_EXT) {\r\nunsigned int tmp = CR_CHAN(cmd->start_arg);\r\nif (tmp > 16)\r\ntmp = 16;\r\ntmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));\r\nif (cmd->start_arg != tmp) {\r\ncmd->start_arg = tmp;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < ni_min_ai_scan_period_ns(dev,\r\ncmd->\r\nchanlist_len))\r\n{\r\ncmd->scan_begin_arg =\r\nni_min_ai_scan_period_ns(dev, cmd->chanlist_len);\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {\r\ncmd->scan_begin_arg = devpriv->clock_ns * 0xffffff;\r\nerr++;\r\n}\r\n} else if (cmd->scan_begin_src == TRIG_EXT) {\r\nunsigned int tmp = CR_CHAN(cmd->scan_begin_arg);\r\nif (tmp > 16)\r\ntmp = 16;\r\ntmp |= (cmd->scan_begin_arg & (CR_INVERT | CR_EDGE));\r\nif (cmd->scan_begin_arg != tmp) {\r\ncmd->scan_begin_arg = tmp;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->scan_begin_arg) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif ((boardtype.reg_type == ni_reg_611x)\r\n|| (boardtype.reg_type == ni_reg_6143)) {\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->convert_arg < boardtype.ai_speed) {\r\ncmd->convert_arg = boardtype.ai_speed;\r\nerr++;\r\n}\r\nif (cmd->convert_arg > devpriv->clock_ns * 0xffff) {\r\ncmd->convert_arg = devpriv->clock_ns * 0xffff;\r\nerr++;\r\n}\r\n}\r\n} else if (cmd->convert_src == TRIG_EXT) {\r\nunsigned int tmp = CR_CHAN(cmd->convert_arg);\r\nif (tmp > 16)\r\ntmp = 16;\r\ntmp |= (cmd->convert_arg & (CR_ALT_FILTER | CR_INVERT));\r\nif (cmd->convert_arg != tmp) {\r\ncmd->convert_arg = tmp;\r\nerr++;\r\n}\r\n} else if (cmd->convert_src == TRIG_NOW) {\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nunsigned int max_count = 0x01000000;\r\nif (boardtype.reg_type == ni_reg_611x)\r\nmax_count -= num_adc_stages_611x;\r\nif (cmd->stop_arg > max_count) {\r\ncmd->stop_arg = max_count;\r\nerr++;\r\n}\r\nif (cmd->stop_arg < 1) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg =\r\nni_timer_to_ns(dev, ni_ns_to_timer(dev,\r\ncmd->scan_begin_arg,\r\ncmd->\r\nflags &\r\nTRIG_ROUND_MASK));\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif ((boardtype.reg_type != ni_reg_611x)\r\n&& (boardtype.reg_type != ni_reg_6143)) {\r\ntmp = cmd->convert_arg;\r\ncmd->convert_arg =\r\nni_timer_to_ns(dev, ni_ns_to_timer(dev,\r\ncmd->convert_arg,\r\ncmd->\r\nflags &\r\nTRIG_ROUND_MASK));\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->scan_end_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->scan_end_arg;\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nint timer;\r\nint mode1 = 0;\r\nint mode2 = 0;\r\nint start_stop_select = 0;\r\nunsigned int stop_count;\r\nint interrupt_a_enable = 0;\r\nMDPRINTK("ni_ai_cmd\n");\r\nif (dev->irq == 0) {\r\ncomedi_error(dev, "cannot run command without an irq");\r\nreturn -EIO;\r\n}\r\nni_clear_ai_fifo(dev);\r\nni_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);\r\ndevpriv->stc_writew(dev, AI_Configuration_Start, Joint_Reset_Register);\r\ndevpriv->an_trig_etc_reg &= ~Analog_Trigger_Enable;\r\ndevpriv->stc_writew(dev, devpriv->an_trig_etc_reg,\r\nAnalog_Trigger_Etc_Register);\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\ncase TRIG_NOW:\r\ndevpriv->stc_writew(dev, AI_START2_Select(0) |\r\nAI_START1_Sync | AI_START1_Edge |\r\nAI_START1_Select(0),\r\nAI_Trigger_Select_Register);\r\nbreak;\r\ncase TRIG_EXT:\r\n{\r\nint chan = CR_CHAN(cmd->start_arg);\r\nunsigned int bits = AI_START2_Select(0) |\r\nAI_START1_Sync | AI_START1_Select(chan + 1);\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= AI_START1_Polarity;\r\nif (cmd->start_arg & CR_EDGE)\r\nbits |= AI_START1_Edge;\r\ndevpriv->stc_writew(dev, bits,\r\nAI_Trigger_Select_Register);\r\nbreak;\r\n}\r\n}\r\nmode2 &= ~AI_Pre_Trigger;\r\nmode2 &= ~AI_SC_Initial_Load_Source;\r\nmode2 &= ~AI_SC_Reload_Mode;\r\ndevpriv->stc_writew(dev, mode2, AI_Mode_2_Register);\r\nif (cmd->chanlist_len == 1 || (boardtype.reg_type == ni_reg_611x)\r\n|| (boardtype.reg_type == ni_reg_6143)) {\r\nstart_stop_select |= AI_STOP_Polarity;\r\nstart_stop_select |= AI_STOP_Select(31);\r\nstart_stop_select |= AI_STOP_Sync;\r\n} else {\r\nstart_stop_select |= AI_STOP_Select(19);\r\n}\r\ndevpriv->stc_writew(dev, start_stop_select,\r\nAI_START_STOP_Select_Register);\r\ndevpriv->ai_cmd2 = 0;\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nstop_count = cmd->stop_arg - 1;\r\nif (boardtype.reg_type == ni_reg_611x) {\r\nstop_count += num_adc_stages_611x;\r\n}\r\ndevpriv->stc_writel(dev, stop_count, AI_SC_Load_A_Registers);\r\nmode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Trigger_Once;\r\ndevpriv->stc_writew(dev, mode1, AI_Mode_1_Register);\r\ndevpriv->stc_writew(dev, AI_SC_Load, AI_Command_1_Register);\r\ndevpriv->ai_continuous = 0;\r\nif (stop_count == 0) {\r\ndevpriv->ai_cmd2 |= AI_End_On_End_Of_Scan;\r\ninterrupt_a_enable |= AI_STOP_Interrupt_Enable;\r\nif (cmd->chanlist_len > 1)\r\nstart_stop_select |=\r\nAI_STOP_Polarity | AI_STOP_Edge;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\ndevpriv->stc_writel(dev, 0, AI_SC_Load_A_Registers);\r\nmode1 |= AI_Start_Stop | AI_Mode_1_Reserved | AI_Continuous;\r\ndevpriv->stc_writew(dev, mode1, AI_Mode_1_Register);\r\ndevpriv->stc_writew(dev, AI_SC_Load, AI_Command_1_Register);\r\ndevpriv->ai_continuous = 1;\r\nbreak;\r\n}\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\nstart_stop_select |= AI_START_Edge | AI_START_Sync;\r\ndevpriv->stc_writew(dev, start_stop_select,\r\nAI_START_STOP_Select_Register);\r\nmode2 |= AI_SI_Reload_Mode(0);\r\nmode2 &= ~AI_SI_Initial_Load_Source;\r\ndevpriv->stc_writew(dev, mode2, AI_Mode_2_Register);\r\ntimer = ni_ns_to_timer(dev, cmd->scan_begin_arg,\r\nTRIG_ROUND_NEAREST);\r\ndevpriv->stc_writel(dev, timer, AI_SI_Load_A_Registers);\r\ndevpriv->stc_writew(dev, AI_SI_Load, AI_Command_1_Register);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->scan_begin_arg & CR_EDGE)\r\nstart_stop_select |= AI_START_Edge;\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\nstart_stop_select |= AI_START_Polarity;\r\nif (cmd->scan_begin_src != cmd->convert_src ||\r\n(cmd->scan_begin_arg & ~CR_EDGE) !=\r\n(cmd->convert_arg & ~CR_EDGE))\r\nstart_stop_select |= AI_START_Sync;\r\nstart_stop_select |=\r\nAI_START_Select(1 + CR_CHAN(cmd->scan_begin_arg));\r\ndevpriv->stc_writew(dev, start_stop_select,\r\nAI_START_STOP_Select_Register);\r\nbreak;\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\ncase TRIG_NOW:\r\nif (cmd->convert_arg == 0 || cmd->convert_src == TRIG_NOW)\r\ntimer = 1;\r\nelse\r\ntimer = ni_ns_to_timer(dev, cmd->convert_arg,\r\nTRIG_ROUND_NEAREST);\r\ndevpriv->stc_writew(dev, 1, AI_SI2_Load_A_Register);\r\ndevpriv->stc_writew(dev, timer, AI_SI2_Load_B_Register);\r\nmode2 &= ~AI_SI2_Initial_Load_Source;\r\nmode2 |= AI_SI2_Reload_Mode;\r\ndevpriv->stc_writew(dev, mode2, AI_Mode_2_Register);\r\ndevpriv->stc_writew(dev, AI_SI2_Load, AI_Command_1_Register);\r\nmode2 |= AI_SI2_Reload_Mode;\r\nmode2 |= AI_SI2_Initial_Load_Source;\r\ndevpriv->stc_writew(dev, mode2, AI_Mode_2_Register);\r\nbreak;\r\ncase TRIG_EXT:\r\nmode1 |= AI_CONVERT_Source_Select(1 + cmd->convert_arg);\r\nif ((cmd->convert_arg & CR_INVERT) == 0)\r\nmode1 |= AI_CONVERT_Source_Polarity;\r\ndevpriv->stc_writew(dev, mode1, AI_Mode_1_Register);\r\nmode2 |= AI_Start_Stop_Gate_Enable | AI_SC_Gate_Enable;\r\ndevpriv->stc_writew(dev, mode2, AI_Mode_2_Register);\r\nbreak;\r\n}\r\nif (dev->irq) {\r\ninterrupt_a_enable |= AI_Error_Interrupt_Enable |\r\nAI_SC_TC_Interrupt_Enable;\r\n#ifndef PCIDMA\r\ninterrupt_a_enable |= AI_FIFO_Interrupt_Enable;\r\n#endif\r\nif (cmd->flags & TRIG_WAKE_EOS\r\n|| (devpriv->ai_cmd2 & AI_End_On_End_Of_Scan)) {\r\ndevpriv->aimode = AIMODE_SCAN;\r\n} else {\r\ndevpriv->aimode = AIMODE_HALF_FULL;\r\n}\r\nswitch (devpriv->aimode) {\r\ncase AIMODE_HALF_FULL:\r\n#ifdef PCIDMA\r\ndevpriv->stc_writew(dev, AI_FIFO_Mode_HF_to_E,\r\nAI_Mode_3_Register);\r\n#else\r\ndevpriv->stc_writew(dev, AI_FIFO_Mode_HF,\r\nAI_Mode_3_Register);\r\n#endif\r\nbreak;\r\ncase AIMODE_SAMPLE:\r\ndevpriv->stc_writew(dev, AI_FIFO_Mode_NE,\r\nAI_Mode_3_Register);\r\nbreak;\r\ncase AIMODE_SCAN:\r\n#ifdef PCIDMA\r\ndevpriv->stc_writew(dev, AI_FIFO_Mode_NE,\r\nAI_Mode_3_Register);\r\n#else\r\ndevpriv->stc_writew(dev, AI_FIFO_Mode_HF,\r\nAI_Mode_3_Register);\r\n#endif\r\ninterrupt_a_enable |= AI_STOP_Interrupt_Enable;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndevpriv->stc_writew(dev, AI_Error_Interrupt_Ack | AI_STOP_Interrupt_Ack | AI_START_Interrupt_Ack | AI_START2_Interrupt_Ack | AI_START1_Interrupt_Ack | AI_SC_TC_Interrupt_Ack | AI_SC_TC_Error_Confirm, Interrupt_A_Ack_Register);\r\nni_set_bits(dev, Interrupt_A_Enable_Register,\r\ninterrupt_a_enable, 1);\r\nMDPRINTK("Interrupt_A_Enable_Register = 0x%04x\n",\r\ndevpriv->int_a_enable_reg);\r\n} else {\r\nni_set_bits(dev, Interrupt_A_Enable_Register, ~0, 0);\r\nMDPRINTK("interrupting on nothing\n");\r\n}\r\ndevpriv->stc_writew(dev, AI_Configuration_End, Joint_Reset_Register);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndevpriv->stc_writew(dev,\r\nAI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |\r\nAI_SC_Arm, AI_Command_1_Register);\r\nbreak;\r\ncase TRIG_EXT:\r\ndevpriv->stc_writew(dev,\r\nAI_SI2_Arm | AI_SI_Arm | AI_DIV_Arm |\r\nAI_SC_Arm, AI_Command_1_Register);\r\nbreak;\r\n}\r\n#ifdef PCIDMA\r\n{\r\nint retval = ni_ai_setup_MITE_dma(dev);\r\nif (retval)\r\nreturn retval;\r\n}\r\n#endif\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\ndevpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,\r\nAI_Command_2_Register);\r\ns->async->inttrig = NULL;\r\nbreak;\r\ncase TRIG_EXT:\r\ns->async->inttrig = NULL;\r\nbreak;\r\ncase TRIG_INT:\r\ns->async->inttrig = &ni_ai_inttrig;\r\nbreak;\r\n}\r\nMDPRINTK("exit ni_ai_cmd\n");\r\nreturn 0;\r\n}\r\nstatic int ni_ai_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\ndevpriv->stc_writew(dev, AI_START1_Pulse | devpriv->ai_cmd2,\r\nAI_Command_2_Register);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int ni_ai_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n < 1)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_ANALOG_TRIG:\r\nreturn ni_ai_config_analog_trig(dev, s, insn, data);\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\nif (data[1] & ~(MSeries_AI_Bypass_Cal_Sel_Pos_Mask |\r\nMSeries_AI_Bypass_Cal_Sel_Neg_Mask |\r\nMSeries_AI_Bypass_Mode_Mux_Mask |\r\nMSeries_AO_Bypass_AO_Cal_Sel_Mask)) {\r\nreturn -EINVAL;\r\n}\r\ndevpriv->ai_calib_source = data[1];\r\n} else if (boardtype.reg_type == ni_reg_6143) {\r\nunsigned int calib_source;\r\ncalib_source = data[1] & 0xf;\r\nif (calib_source > 0xF)\r\nreturn -EINVAL;\r\ndevpriv->ai_calib_source = calib_source;\r\nni_writew(calib_source, Calibration_Channel_6143);\r\n} else {\r\nunsigned int calib_source;\r\nunsigned int calib_source_adjust;\r\ncalib_source = data[1] & 0xf;\r\ncalib_source_adjust = (data[1] >> 4) & 0xff;\r\nif (calib_source >= 8)\r\nreturn -EINVAL;\r\ndevpriv->ai_calib_source = calib_source;\r\nif (boardtype.reg_type == ni_reg_611x) {\r\nni_writeb(calib_source_adjust,\r\nCal_Gain_Select_611x);\r\n}\r\n}\r\nreturn 2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ni_ai_config_analog_trig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int a, b, modebits;\r\nint err = 0;\r\nif (!boardtype.has_analog_trig)\r\nreturn -EINVAL;\r\nif ((data[1] & 0xffff0000) != COMEDI_EV_SCAN_BEGIN) {\r\ndata[1] &= (COMEDI_EV_SCAN_BEGIN | 0xffff);\r\nerr++;\r\n}\r\nif (data[2] >= boardtype.n_adchan) {\r\ndata[2] = boardtype.n_adchan - 1;\r\nerr++;\r\n}\r\nif (data[3] > 255) {\r\ndata[3] = 255;\r\nerr++;\r\n}\r\nif (data[4] > 255) {\r\ndata[4] = 255;\r\nerr++;\r\n}\r\na = data[3];\r\nb = data[4];\r\nmodebits = data[1] & 0xff;\r\nif (modebits & 0xf0) {\r\nif (b < a) {\r\na = data[4];\r\nb = data[3];\r\nmodebits =\r\n((data[1] & 0xf) << 4) | ((data[1] & 0xf0) >> 4);\r\n}\r\ndevpriv->atrig_low = a;\r\ndevpriv->atrig_high = b;\r\nswitch (modebits) {\r\ncase 0x81:\r\ndevpriv->atrig_mode = 6;\r\nbreak;\r\ncase 0x42:\r\ndevpriv->atrig_mode = 3;\r\nbreak;\r\ncase 0x96:\r\ndevpriv->atrig_mode = 2;\r\nbreak;\r\ndefault:\r\ndata[1] &= ~0xff;\r\nerr++;\r\n}\r\n} else {\r\nif (b != 0) {\r\ndata[4] = 0;\r\nerr++;\r\n}\r\nswitch (modebits) {\r\ncase 0x06:\r\ndevpriv->atrig_high = a;\r\ndevpriv->atrig_mode = 0;\r\nbreak;\r\ncase 0x09:\r\ndevpriv->atrig_low = a;\r\ndevpriv->atrig_mode = 1;\r\nbreak;\r\ndefault:\r\ndata[1] &= ~0xff;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn -EAGAIN;\r\nreturn 5;\r\n}\r\nstatic void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,\r\nvoid *data, unsigned int num_bytes,\r\nunsigned int chan_index)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned int range;\r\nunsigned int i;\r\nunsigned int offset;\r\nunsigned int length = num_bytes / sizeof(short);\r\nshort *array = data;\r\noffset = 1 << (boardtype.aobits - 1);\r\nfor (i = 0; i < length; i++) {\r\nrange = CR_RANGE(async->cmd.chanlist[chan_index]);\r\nif (boardtype.ao_unipolar == 0 || (range & 1) == 0)\r\narray[i] -= offset;\r\n#ifdef PCIDMA\r\narray[i] = cpu_to_le16(array[i]);\r\n#endif\r\nchan_index++;\r\nchan_index %= async->cmd.chanlist_len;\r\n}\r\n}\r\nstatic int ni_m_series_ao_config_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec[],\r\nunsigned int n_chans, int timed)\r\n{\r\nunsigned int range;\r\nunsigned int chan;\r\nunsigned int conf;\r\nint i;\r\nint invert = 0;\r\nif (timed) {\r\nfor (i = 0; i < boardtype.n_aochan; ++i) {\r\ndevpriv->ao_conf[i] &= ~MSeries_AO_Update_Timed_Bit;\r\nni_writeb(devpriv->ao_conf[i],\r\nM_Offset_AO_Config_Bank(i));\r\nni_writeb(0xf, M_Offset_AO_Waveform_Order(i));\r\n}\r\n}\r\nfor (i = 0; i < n_chans; i++) {\r\nconst struct comedi_krange *krange;\r\nchan = CR_CHAN(chanspec[i]);\r\nrange = CR_RANGE(chanspec[i]);\r\nkrange = s->range_table->range + range;\r\ninvert = 0;\r\nconf = 0;\r\nswitch (krange->max - krange->min) {\r\ncase 20000000:\r\nconf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;\r\nni_writeb(0, M_Offset_AO_Reference_Attenuation(chan));\r\nbreak;\r\ncase 10000000:\r\nconf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;\r\nni_writeb(0, M_Offset_AO_Reference_Attenuation(chan));\r\nbreak;\r\ncase 4000000:\r\nconf |= MSeries_AO_DAC_Reference_10V_Internal_Bits;\r\nni_writeb(MSeries_Attenuate_x5_Bit,\r\nM_Offset_AO_Reference_Attenuation(chan));\r\nbreak;\r\ncase 2000000:\r\nconf |= MSeries_AO_DAC_Reference_5V_Internal_Bits;\r\nni_writeb(MSeries_Attenuate_x5_Bit,\r\nM_Offset_AO_Reference_Attenuation(chan));\r\nbreak;\r\ndefault:\r\nprintk("%s: bug! unhandled ao reference voltage\n",\r\n__func__);\r\nbreak;\r\n}\r\nswitch (krange->max + krange->min) {\r\ncase 0:\r\nconf |= MSeries_AO_DAC_Offset_0V_Bits;\r\nbreak;\r\ncase 10000000:\r\nconf |= MSeries_AO_DAC_Offset_5V_Bits;\r\nbreak;\r\ndefault:\r\nprintk("%s: bug! unhandled ao offset voltage\n",\r\n__func__);\r\nbreak;\r\n}\r\nif (timed)\r\nconf |= MSeries_AO_Update_Timed_Bit;\r\nni_writeb(conf, M_Offset_AO_Config_Bank(chan));\r\ndevpriv->ao_conf[chan] = conf;\r\nni_writeb(i, M_Offset_AO_Waveform_Order(chan));\r\n}\r\nreturn invert;\r\n}\r\nstatic int ni_old_ao_config_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec[],\r\nunsigned int n_chans)\r\n{\r\nunsigned int range;\r\nunsigned int chan;\r\nunsigned int conf;\r\nint i;\r\nint invert = 0;\r\nfor (i = 0; i < n_chans; i++) {\r\nchan = CR_CHAN(chanspec[i]);\r\nrange = CR_RANGE(chanspec[i]);\r\nconf = AO_Channel(chan);\r\nif (boardtype.ao_unipolar) {\r\nif ((range & 1) == 0) {\r\nconf |= AO_Bipolar;\r\ninvert = (1 << (boardtype.aobits - 1));\r\n} else {\r\ninvert = 0;\r\n}\r\nif (range & 2)\r\nconf |= AO_Ext_Ref;\r\n} else {\r\nconf |= AO_Bipolar;\r\ninvert = (1 << (boardtype.aobits - 1));\r\n}\r\nif (chanspec[i] & CR_DEGLITCH)\r\nconf |= AO_Deglitch;\r\nconf |= (CR_AREF(chanspec[i]) ==\r\nAREF_OTHER) ? AO_Ground_Ref : 0;\r\nni_writew(conf, AO_Configuration);\r\ndevpriv->ao_conf[chan] = conf;\r\n}\r\nreturn invert;\r\n}\r\nstatic int ni_ao_config_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chanspec[], unsigned int n_chans,\r\nint timed)\r\n{\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nreturn ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,\r\ntimed);\r\nelse\r\nreturn ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);\r\n}\r\nstatic int ni_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[0] = devpriv->ao[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int ni_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int invert;\r\ninvert = ni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);\r\ndevpriv->ao[chan] = data[0];\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\nni_writew(data[0], M_Offset_DAC_Direct_Data(chan));\r\n} else\r\nni_writew(data[0] ^ invert,\r\n(chan) ? DAC1_Direct_Data : DAC0_Direct_Data);\r\nreturn 1;\r\n}\r\nstatic int ni_ao_insn_write_671x(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int invert;\r\nao_win_out(1 << chan, AO_Immediate_671x);\r\ninvert = 1 << (boardtype.aobits - 1);\r\nni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);\r\ndevpriv->ao[chan] = data[0];\r\nao_win_out(data[0] ^ invert, DACx_Direct_Data_671x(chan));\r\nreturn 1;\r\n}\r\nstatic int ni_ao_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:\r\nswitch (data[1]) {\r\ncase COMEDI_OUTPUT:\r\ndata[2] = 1 + boardtype.ao_fifo_depth * sizeof(short);\r\nif (devpriv->mite)\r\ndata[2] += devpriv->mite->fifo_size;\r\nbreak;\r\ncase COMEDI_INPUT:\r\ndata[2] = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ni_ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nint ret;\r\nint interrupt_b_bits;\r\nint i;\r\nstatic const int timeout = 1000;\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULL;\r\nni_set_bits(dev, Interrupt_B_Enable_Register,\r\nAO_FIFO_Interrupt_Enable | AO_Error_Interrupt_Enable, 0);\r\ninterrupt_b_bits = AO_Error_Interrupt_Enable;\r\n#ifdef PCIDMA\r\ndevpriv->stc_writew(dev, 1, DAC_FIFO_Clear);\r\nif (boardtype.reg_type & ni_reg_6xxx_mask)\r\nni_ao_win_outl(dev, 0x6, AO_FIFO_Offset_Load_611x);\r\nret = ni_ao_setup_MITE_dma(dev);\r\nif (ret)\r\nreturn ret;\r\nret = ni_ao_wait_for_dma_load(dev);\r\nif (ret < 0)\r\nreturn ret;\r\n#else\r\nret = ni_ao_prep_fifo(dev, s);\r\nif (ret == 0)\r\nreturn -EPIPE;\r\ninterrupt_b_bits |= AO_FIFO_Interrupt_Enable;\r\n#endif\r\ndevpriv->stc_writew(dev, devpriv->ao_mode3 | AO_Not_An_UPDATE,\r\nAO_Mode_3_Register);\r\ndevpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);\r\nfor (i = 0; i < timeout; i++) {\r\nudelay(1);\r\nif ((devpriv->stc_readw(dev,\r\nJoint_Status_2_Register) &\r\nAO_TMRDACWRs_In_Progress_St) == 0)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev,\r\n"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear");\r\nreturn -EIO;\r\n}\r\ndevpriv->stc_writew(dev, AO_Error_Interrupt_Ack,\r\nInterrupt_B_Ack_Register);\r\nni_set_bits(dev, Interrupt_B_Enable_Register, interrupt_b_bits, 1);\r\ndevpriv->stc_writew(dev,\r\ndevpriv->ao_cmd1 | AO_UI_Arm | AO_UC_Arm | AO_BC_Arm\r\n| AO_DAC1_Update_Mode | AO_DAC0_Update_Mode,\r\nAO_Command_1_Register);\r\ndevpriv->stc_writew(dev, devpriv->ao_cmd2 | AO_START1_Pulse,\r\nAO_Command_2_Register);\r\nreturn 0;\r\n}\r\nstatic int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nint bits;\r\nint i;\r\nunsigned trigvar;\r\nif (dev->irq == 0) {\r\ncomedi_error(dev, "cannot run command without an irq");\r\nreturn -EIO;\r\n}\r\ndevpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);\r\ndevpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);\r\nif (boardtype.reg_type & ni_reg_6xxx_mask) {\r\nao_win_out(CLEAR_WG, AO_Misc_611x);\r\nbits = 0;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nint chan;\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nbits |= 1 << chan;\r\nao_win_out(chan, AO_Waveform_Generation_611x);\r\n}\r\nao_win_out(bits, AO_Timed_611x);\r\n}\r\nni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);\r\nif (cmd->stop_src == TRIG_NONE) {\r\ndevpriv->ao_mode1 |= AO_Continuous;\r\ndevpriv->ao_mode1 &= ~AO_Trigger_Once;\r\n} else {\r\ndevpriv->ao_mode1 &= ~AO_Continuous;\r\ndevpriv->ao_mode1 |= AO_Trigger_Once;\r\n}\r\ndevpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\ncase TRIG_NOW:\r\ndevpriv->ao_trigger_select &=\r\n~(AO_START1_Polarity | AO_START1_Select(-1));\r\ndevpriv->ao_trigger_select |= AO_START1_Edge | AO_START1_Sync;\r\ndevpriv->stc_writew(dev, devpriv->ao_trigger_select,\r\nAO_Trigger_Select_Register);\r\nbreak;\r\ncase TRIG_EXT:\r\ndevpriv->ao_trigger_select =\r\nAO_START1_Select(CR_CHAN(cmd->start_arg) + 1);\r\nif (cmd->start_arg & CR_INVERT)\r\ndevpriv->ao_trigger_select |= AO_START1_Polarity;\r\nif (cmd->start_arg & CR_EDGE)\r\ndevpriv->ao_trigger_select |= AO_START1_Edge;\r\ndevpriv->stc_writew(dev, devpriv->ao_trigger_select,\r\nAO_Trigger_Select_Register);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\ndevpriv->ao_mode3 &= ~AO_Trigger_Length;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);\r\ndevpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);\r\ndevpriv->ao_mode2 &= ~AO_BC_Initial_Load_Source;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);\r\nif (cmd->stop_src == TRIG_NONE) {\r\ndevpriv->stc_writel(dev, 0xffffff, AO_BC_Load_A_Register);\r\n} else {\r\ndevpriv->stc_writel(dev, 0, AO_BC_Load_A_Register);\r\n}\r\ndevpriv->stc_writew(dev, AO_BC_Load, AO_Command_1_Register);\r\ndevpriv->ao_mode2 &= ~AO_UC_Initial_Load_Source;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\ndevpriv->stc_writel(dev, cmd->stop_arg - 1,\r\nAO_UC_Load_A_Register);\r\ndevpriv->stc_writew(dev, AO_UC_Load,\r\nAO_Command_1_Register);\r\n} else {\r\ndevpriv->stc_writel(dev, cmd->stop_arg,\r\nAO_UC_Load_A_Register);\r\ndevpriv->stc_writew(dev, AO_UC_Load,\r\nAO_Command_1_Register);\r\ndevpriv->stc_writel(dev, cmd->stop_arg - 1,\r\nAO_UC_Load_A_Register);\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\ndevpriv->stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);\r\ndevpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);\r\ndevpriv->stc_writel(dev, 0xffffff, AO_UC_Load_A_Register);\r\nbreak;\r\ndefault:\r\ndevpriv->stc_writel(dev, 0, AO_UC_Load_A_Register);\r\ndevpriv->stc_writew(dev, AO_UC_Load, AO_Command_1_Register);\r\ndevpriv->stc_writel(dev, cmd->stop_arg, AO_UC_Load_A_Register);\r\n}\r\ndevpriv->ao_mode1 &=\r\n~(AO_UI_Source_Select(0x1f) | AO_UI_Source_Polarity |\r\nAO_UPDATE_Source_Select(0x1f) | AO_UPDATE_Source_Polarity);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndevpriv->ao_cmd2 &= ~AO_BC_Gate_Enable;\r\ntrigvar =\r\nni_ns_to_timer(dev, cmd->scan_begin_arg,\r\nTRIG_ROUND_NEAREST);\r\ndevpriv->stc_writel(dev, 1, AO_UI_Load_A_Register);\r\ndevpriv->stc_writew(dev, AO_UI_Load, AO_Command_1_Register);\r\ndevpriv->stc_writel(dev, trigvar, AO_UI_Load_A_Register);\r\nbreak;\r\ncase TRIG_EXT:\r\ndevpriv->ao_mode1 |=\r\nAO_UPDATE_Source_Select(cmd->scan_begin_arg);\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\ndevpriv->ao_mode1 |= AO_UPDATE_Source_Polarity;\r\ndevpriv->ao_cmd2 |= AO_BC_Gate_Enable;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\ndevpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);\r\ndevpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);\r\ndevpriv->ao_mode2 &=\r\n~(AO_UI_Reload_Mode(3) | AO_UI_Initial_Load_Source);\r\ndevpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);\r\nif (cmd->scan_end_arg > 1) {\r\ndevpriv->ao_mode1 |= AO_Multiple_Channels;\r\ndevpriv->stc_writew(dev,\r\nAO_Number_Of_Channels(cmd->scan_end_arg -\r\n1) |\r\nAO_UPDATE_Output_Select\r\n(AO_Update_Output_High_Z),\r\nAO_Output_Control_Register);\r\n} else {\r\nunsigned bits;\r\ndevpriv->ao_mode1 &= ~AO_Multiple_Channels;\r\nbits = AO_UPDATE_Output_Select(AO_Update_Output_High_Z);\r\nif (boardtype.\r\nreg_type & (ni_reg_m_series_mask | ni_reg_6xxx_mask)) {\r\nbits |= AO_Number_Of_Channels(0);\r\n} else {\r\nbits |=\r\nAO_Number_Of_Channels(CR_CHAN(cmd->chanlist[0]));\r\n}\r\ndevpriv->stc_writew(dev, bits, AO_Output_Control_Register);\r\n}\r\ndevpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);\r\ndevpriv->stc_writew(dev, AO_DAC0_Update_Mode | AO_DAC1_Update_Mode,\r\nAO_Command_1_Register);\r\ndevpriv->ao_mode3 |= AO_Stop_On_Overrun_Error;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);\r\ndevpriv->ao_mode2 &= ~AO_FIFO_Mode_Mask;\r\n#ifdef PCIDMA\r\ndevpriv->ao_mode2 |= AO_FIFO_Mode_HF_to_F;\r\n#else\r\ndevpriv->ao_mode2 |= AO_FIFO_Mode_HF;\r\n#endif\r\ndevpriv->ao_mode2 &= ~AO_FIFO_Retransmit_Enable;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);\r\nbits = AO_BC_Source_Select | AO_UPDATE_Pulse_Width |\r\nAO_TMRDACWR_Pulse_Width;\r\nif (boardtype.ao_fifo_depth)\r\nbits |= AO_FIFO_Enable;\r\nelse\r\nbits |= AO_DMA_PIO_Control;\r\n#if 0\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nbits |= AO_Number_Of_DAC_Packages;\r\n#endif\r\ndevpriv->stc_writew(dev, bits, AO_Personal_Register);\r\ndevpriv->stc_writew(dev, AO_AOFREQ_Enable, AO_Start_Select_Register);\r\ndevpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\ndevpriv->stc_writew(dev, AO_BC_TC_Interrupt_Ack,\r\nInterrupt_B_Ack_Register);\r\nni_set_bits(dev, Interrupt_B_Enable_Register,\r\nAO_BC_TC_Interrupt_Enable, 1);\r\n}\r\ns->async->inttrig = &ni_ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nif ((cmd->flags & CMDF_WRITE) == 0) {\r\ncmd->flags |= CMDF_WRITE;\r\n}\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_INT | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src == TRIG_EXT) {\r\nunsigned int tmp = CR_CHAN(cmd->start_arg);\r\nif (tmp > 18)\r\ntmp = 18;\r\ntmp |= (cmd->start_arg & (CR_INVERT | CR_EDGE));\r\nif (cmd->start_arg != tmp) {\r\ncmd->start_arg = tmp;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < boardtype.ao_speed) {\r\ncmd->scan_begin_arg = boardtype.ao_speed;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > devpriv->clock_ns * 0xffffff) {\r\ncmd->scan_begin_arg = devpriv->clock_ns * 0xffffff;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (cmd->stop_arg > 0x00ffffff) {\r\ncmd->stop_arg = 0x00ffffff;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg =\r\nni_timer_to_ns(dev, ni_ns_to_timer(dev,\r\ncmd->scan_begin_arg,\r\ncmd->\r\nflags &\r\nTRIG_ROUND_MASK));\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nni_release_ao_mite_channel(dev);\r\ndevpriv->stc_writew(dev, AO_Configuration_Start, Joint_Reset_Register);\r\ndevpriv->stc_writew(dev, AO_Disarm, AO_Command_1_Register);\r\nni_set_bits(dev, Interrupt_B_Enable_Register, ~0, 0);\r\ndevpriv->stc_writew(dev, AO_BC_Source_Select, AO_Personal_Register);\r\ndevpriv->stc_writew(dev, 0x3f98, Interrupt_B_Ack_Register);\r\ndevpriv->stc_writew(dev, AO_BC_Source_Select | AO_UPDATE_Pulse_Width |\r\nAO_TMRDACWR_Pulse_Width, AO_Personal_Register);\r\ndevpriv->stc_writew(dev, 0, AO_Output_Control_Register);\r\ndevpriv->stc_writew(dev, 0, AO_Start_Select_Register);\r\ndevpriv->ao_cmd1 = 0;\r\ndevpriv->stc_writew(dev, devpriv->ao_cmd1, AO_Command_1_Register);\r\ndevpriv->ao_cmd2 = 0;\r\ndevpriv->stc_writew(dev, devpriv->ao_cmd2, AO_Command_2_Register);\r\ndevpriv->ao_mode1 = 0;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode1, AO_Mode_1_Register);\r\ndevpriv->ao_mode2 = 0;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode2, AO_Mode_2_Register);\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\ndevpriv->ao_mode3 = AO_Last_Gate_Disable;\r\nelse\r\ndevpriv->ao_mode3 = 0;\r\ndevpriv->stc_writew(dev, devpriv->ao_mode3, AO_Mode_3_Register);\r\ndevpriv->ao_trigger_select = 0;\r\ndevpriv->stc_writew(dev, devpriv->ao_trigger_select,\r\nAO_Trigger_Select_Register);\r\nif (boardtype.reg_type & ni_reg_6xxx_mask) {\r\nunsigned immediate_bits = 0;\r\nunsigned i;\r\nfor (i = 0; i < s->n_chan; ++i) {\r\nimmediate_bits |= 1 << i;\r\n}\r\nao_win_out(immediate_bits, AO_Immediate_671x);\r\nao_win_out(CLEAR_WG, AO_Misc_611x);\r\n}\r\ndevpriv->stc_writew(dev, AO_Configuration_End, Joint_Reset_Register);\r\nreturn 0;\r\n}\r\nstatic int ni_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\n#ifdef DEBUG_DIO\r\nprintk("ni_dio_insn_config() chan=%d io=%d\n",\r\nCR_CHAN(insn->chanspec), data[0]);\r\n#endif\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << CR_CHAN(insn->chanspec);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~(1 << CR_CHAN(insn->chanspec));\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->\r\nio_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :\r\nCOMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dio_control &= ~DIO_Pins_Dir_Mask;\r\ndevpriv->dio_control |= DIO_Pins_Dir(s->io_bits);\r\ndevpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);\r\nreturn 1;\r\n}\r\nstatic int ni_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\n#ifdef DEBUG_DIO\r\nprintk("ni_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0], data[1]);\r\n#endif\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nif (data[0]) {\r\nif ((data[0] & (DIO_SDIN | DIO_SDOUT))\r\n&& devpriv->serial_interval_ns)\r\nreturn -EBUSY;\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\ndevpriv->dio_output &= ~DIO_Parallel_Data_Mask;\r\ndevpriv->dio_output |= DIO_Parallel_Data_Out(s->state);\r\ndevpriv->stc_writew(dev, devpriv->dio_output,\r\nDIO_Output_Register);\r\n}\r\ndata[1] = devpriv->stc_readw(dev, DIO_Parallel_Input_Register);\r\nreturn 2;\r\n}\r\nstatic int ni_m_series_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\n#ifdef DEBUG_DIO\r\nprintk("ni_m_series_dio_insn_config() chan=%d io=%d\n",\r\nCR_CHAN(insn->chanspec), data[0]);\r\n#endif\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << CR_CHAN(insn->chanspec);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~(1 << CR_CHAN(insn->chanspec));\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->\r\nio_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :\r\nCOMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nni_writel(s->io_bits, M_Offset_DIO_Direction);\r\nreturn 1;\r\n}\r\nstatic int ni_m_series_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\n#ifdef DEBUG_DIO\r\nprintk("ni_m_series_dio_insn_bits() mask=0x%x bits=0x%x\n", data[0],\r\ndata[1]);\r\n#endif\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nni_writel(s->state, M_Offset_Static_Digital_Output);\r\n}\r\ndata[1] = ni_readl(M_Offset_Static_Digital_Input);\r\nreturn 2;\r\n}\r\nstatic int ni_cdio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nint sources;\r\nunsigned i;\r\ntmp = cmd->start_src;\r\nsources = TRIG_INT;\r\ncmd->start_src &= sources;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_INT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src == TRIG_INT) {\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\ntmp = cmd->scan_begin_arg;\r\ntmp &= CR_PACK_FLAGS(CDO_Sample_Source_Select_Mask, 0, 0,\r\nCR_INVERT);\r\nif (tmp != cmd->scan_begin_arg) {\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_NOW) {\r\nif (cmd->convert_arg) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_NONE) {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nif (cmd->chanlist[i] != i)\r\nerr = 1;\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned cdo_mode_bits = CDO_FIFO_Mode_Bit | CDO_Halt_On_Error_Bit;\r\nint retval;\r\nni_writel(CDO_Reset_Bit, M_Offset_CDIO_Command);\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_EXT:\r\ncdo_mode_bits |=\r\nCR_CHAN(cmd->scan_begin_arg) &\r\nCDO_Sample_Source_Select_Mask;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\ncdo_mode_bits |= CDO_Polarity_Bit;\r\nni_writel(cdo_mode_bits, M_Offset_CDO_Mode);\r\nif (s->io_bits) {\r\nni_writel(s->state, M_Offset_CDO_FIFO_Data);\r\nni_writel(CDO_SW_Update_Bit, M_Offset_CDIO_Command);\r\nni_writel(s->io_bits, M_Offset_CDO_Mask_Enable);\r\n} else {\r\ncomedi_error(dev,\r\n"attempted to run digital output command with no lines configured as outputs");\r\nreturn -EIO;\r\n}\r\nretval = ni_request_cdo_mite_channel(dev);\r\nif (retval < 0) {\r\nreturn retval;\r\n}\r\ns->async->inttrig = &ni_cdo_inttrig;\r\nreturn 0;\r\n}\r\nstatic int ni_cdo_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\n#endif\r\nint retval = 0;\r\nunsigned i;\r\nconst unsigned timeout = 1000;\r\ns->async->inttrig = NULL;\r\ncomedi_buf_read_alloc(s->async, s->async->prealloc_bufsz);\r\n#ifdef PCIDMA\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->cdo_mite_chan) {\r\nmite_prep_dma(devpriv->cdo_mite_chan, 32, 32);\r\nmite_dma_arm(devpriv->cdo_mite_chan);\r\n} else {\r\ncomedi_error(dev, "BUG: no cdo mite channel?");\r\nretval = -EIO;\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\nif (retval < 0)\r\nreturn retval;\r\n#endif\r\nfor (i = 0; i < timeout; ++i) {\r\nif (ni_readl(M_Offset_CDIO_Status) & CDO_FIFO_Full_Bit)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "dma failed to fill cdo fifo!");\r\nni_cdio_cancel(dev, s);\r\nreturn -EIO;\r\n}\r\nni_writel(CDO_Arm_Bit | CDO_Error_Interrupt_Enable_Set_Bit |\r\nCDO_Empty_FIFO_Interrupt_Enable_Set_Bit,\r\nM_Offset_CDIO_Command);\r\nreturn retval;\r\n}\r\nstatic int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nni_writel(CDO_Disarm_Bit | CDO_Error_Interrupt_Enable_Clear_Bit |\r\nCDO_Empty_FIFO_Interrupt_Enable_Clear_Bit |\r\nCDO_FIFO_Request_Interrupt_Enable_Clear_Bit,\r\nM_Offset_CDIO_Command);\r\nni_writel(0, M_Offset_CDO_Mask_Enable);\r\nni_release_cdo_mite_channel(dev);\r\nreturn 0;\r\n}\r\nstatic void handle_cdio_interrupt(struct comedi_device *dev)\r\n{\r\nunsigned cdio_status;\r\nstruct comedi_subdevice *s = dev->subdevices + NI_DIO_SUBDEV;\r\n#ifdef PCIDMA\r\nunsigned long flags;\r\n#endif\r\nif ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {\r\nreturn;\r\n}\r\n#ifdef PCIDMA\r\nspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\r\nif (devpriv->cdo_mite_chan) {\r\nunsigned cdo_mite_status =\r\nmite_get_status(devpriv->cdo_mite_chan);\r\nif (cdo_mite_status & CHSR_LINKC) {\r\nwritel(CHOR_CLRLC,\r\ndevpriv->mite->mite_io_addr +\r\nMITE_CHOR(devpriv->cdo_mite_chan->channel));\r\n}\r\nmite_sync_output_dma(devpriv->cdo_mite_chan, s->async);\r\n}\r\nspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\r\n#endif\r\ncdio_status = ni_readl(M_Offset_CDIO_Status);\r\nif (cdio_status & (CDO_Overrun_Bit | CDO_Underflow_Bit)) {\r\nni_writel(CDO_Error_Interrupt_Confirm_Bit, M_Offset_CDIO_Command);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nif (cdio_status & CDO_FIFO_Empty_Bit) {\r\nni_writel(CDO_Empty_FIFO_Interrupt_Enable_Clear_Bit,\r\nM_Offset_CDIO_Command);\r\n}\r\nni_event(dev, s);\r\n}\r\nstatic int ni_serial_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint err = insn->n;\r\nunsigned char byte_out, byte_in = 0;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SERIAL_CLOCK:\r\n#ifdef DEBUG_DIO\r\nprintk("SPI serial clock Config cd\n", data[1]);\r\n#endif\r\ndevpriv->serial_hw_mode = 1;\r\ndevpriv->dio_control |= DIO_HW_Serial_Enable;\r\nif (data[1] == SERIAL_DISABLED) {\r\ndevpriv->serial_hw_mode = 0;\r\ndevpriv->dio_control &= ~(DIO_HW_Serial_Enable |\r\nDIO_Software_Serial_Control);\r\ndata[1] = SERIAL_DISABLED;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else if (data[1] <= SERIAL_600NS) {\r\ndevpriv->dio_control &= ~DIO_HW_Serial_Timebase;\r\ndevpriv->clock_and_fout |= Slow_Internal_Timebase;\r\ndevpriv->clock_and_fout &= ~DIO_Serial_Out_Divide_By_2;\r\ndata[1] = SERIAL_600NS;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else if (data[1] <= SERIAL_1_2US) {\r\ndevpriv->dio_control &= ~DIO_HW_Serial_Timebase;\r\ndevpriv->clock_and_fout |= Slow_Internal_Timebase |\r\nDIO_Serial_Out_Divide_By_2;\r\ndata[1] = SERIAL_1_2US;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else if (data[1] <= SERIAL_10US) {\r\ndevpriv->dio_control |= DIO_HW_Serial_Timebase;\r\ndevpriv->clock_and_fout |= Slow_Internal_Timebase |\r\nDIO_Serial_Out_Divide_By_2;\r\ndata[1] = SERIAL_10US;\r\ndevpriv->serial_interval_ns = data[1];\r\n} else {\r\ndevpriv->dio_control &= ~(DIO_HW_Serial_Enable |\r\nDIO_Software_Serial_Control);\r\ndevpriv->serial_hw_mode = 0;\r\ndata[1] = (data[1] / 1000) * 1000;\r\ndevpriv->serial_interval_ns = data[1];\r\n}\r\ndevpriv->stc_writew(dev, devpriv->dio_control,\r\nDIO_Control_Register);\r\ndevpriv->stc_writew(dev, devpriv->clock_and_fout,\r\nClock_and_FOUT_Register);\r\nreturn 1;\r\nbreak;\r\ncase INSN_CONFIG_BIDIRECTIONAL_DATA:\r\nif (devpriv->serial_interval_ns == 0) {\r\nreturn -EINVAL;\r\n}\r\nbyte_out = data[1] & 0xFF;\r\nif (devpriv->serial_hw_mode) {\r\nerr = ni_serial_hw_readwrite8(dev, s, byte_out,\r\n&byte_in);\r\n} else if (devpriv->serial_interval_ns > 0) {\r\nerr = ni_serial_sw_readwrite8(dev, s, byte_out,\r\n&byte_in);\r\n} else {\r\nprintk("ni_serial_insn_config: serial disabled!\n");\r\nreturn -EINVAL;\r\n}\r\nif (err < 0)\r\nreturn err;\r\ndata[1] = byte_in & 0xFF;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ni_serial_hw_readwrite8(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned char data_out,\r\nunsigned char *data_in)\r\n{\r\nunsigned int status1;\r\nint err = 0, count = 20;\r\n#ifdef DEBUG_DIO\r\nprintk("ni_serial_hw_readwrite8: outputting 0x%x\n", data_out);\r\n#endif\r\ndevpriv->dio_output &= ~DIO_Serial_Data_Mask;\r\ndevpriv->dio_output |= DIO_Serial_Data_Out(data_out);\r\ndevpriv->stc_writew(dev, devpriv->dio_output, DIO_Output_Register);\r\nstatus1 = devpriv->stc_readw(dev, Joint_Status_1_Register);\r\nif (status1 & DIO_Serial_IO_In_Progress_St) {\r\nerr = -EBUSY;\r\ngoto Error;\r\n}\r\ndevpriv->dio_control |= DIO_HW_Serial_Start;\r\ndevpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);\r\ndevpriv->dio_control &= ~DIO_HW_Serial_Start;\r\nwhile ((status1 =\r\ndevpriv->stc_readw(dev,\r\nJoint_Status_1_Register)) &\r\nDIO_Serial_IO_In_Progress_St) {\r\nudelay((devpriv->serial_interval_ns + 999) / 1000);\r\nif (--count < 0) {\r\nprintk\r\n("ni_serial_hw_readwrite8: SPI serial I/O didn't finish in time!\n");\r\nerr = -ETIME;\r\ngoto Error;\r\n}\r\n}\r\nudelay((devpriv->serial_interval_ns + 999) / 1000);\r\nif (data_in != NULL) {\r\n*data_in = devpriv->stc_readw(dev, DIO_Serial_Input_Register);\r\n#ifdef DEBUG_DIO\r\nprintk("ni_serial_hw_readwrite8: inputted 0x%x\n", *data_in);\r\n#endif\r\n}\r\nError:\r\ndevpriv->stc_writew(dev, devpriv->dio_control, DIO_Control_Register);\r\nreturn err;\r\n}\r\nstatic int ni_serial_sw_readwrite8(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned char data_out,\r\nunsigned char *data_in)\r\n{\r\nunsigned char mask, input = 0;\r\n#ifdef DEBUG_DIO\r\nprintk("ni_serial_sw_readwrite8: outputting 0x%x\n", data_out);\r\n#endif\r\nudelay((devpriv->serial_interval_ns + 999) / 1000);\r\nfor (mask = 0x80; mask; mask >>= 1) {\r\ndevpriv->dio_output &= ~DIO_SDOUT;\r\nif (data_out & mask) {\r\ndevpriv->dio_output |= DIO_SDOUT;\r\n}\r\ndevpriv->stc_writew(dev, devpriv->dio_output,\r\nDIO_Output_Register);\r\ndevpriv->dio_control |= DIO_Software_Serial_Control;\r\ndevpriv->stc_writew(dev, devpriv->dio_control,\r\nDIO_Control_Register);\r\nudelay((devpriv->serial_interval_ns + 999) / 2000);\r\ndevpriv->dio_control &= ~DIO_Software_Serial_Control;\r\ndevpriv->stc_writew(dev, devpriv->dio_control,\r\nDIO_Control_Register);\r\nudelay((devpriv->serial_interval_ns + 999) / 2000);\r\nif (devpriv->stc_readw(dev,\r\nDIO_Parallel_Input_Register) & DIO_SDIN)\r\n{\r\ninput |= mask;\r\n}\r\n}\r\n#ifdef DEBUG_DIO\r\nprintk("ni_serial_sw_readwrite8: inputted 0x%x\n", input);\r\n#endif\r\nif (data_in)\r\n*data_in = input;\r\nreturn 0;\r\n}\r\nstatic void mio_common_detach(struct comedi_device *dev)\r\n{\r\nif (dev->private) {\r\nif (devpriv->counter_dev) {\r\nni_gpct_device_destroy(devpriv->counter_dev);\r\n}\r\n}\r\nif (dev->subdevices && boardtype.has_8255)\r\nsubdev_8255_cleanup(dev, dev->subdevices + NI_8255_DIO_SUBDEV);\r\n}\r\nstatic void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint i;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nni_ao_win_outw(dev, AO_Channel(i) | 0x0,\r\nAO_Configuration_2_67xx);\r\n}\r\nao_win_out(0x0, AO_Later_Single_Point_Updates);\r\n}\r\nstatic unsigned ni_gpct_to_stc_register(enum ni_gpct_register reg)\r\n{\r\nunsigned stc_register;\r\nswitch (reg) {\r\ncase NITIO_G0_Autoincrement_Reg:\r\nstc_register = G_Autoincrement_Register(0);\r\nbreak;\r\ncase NITIO_G1_Autoincrement_Reg:\r\nstc_register = G_Autoincrement_Register(1);\r\nbreak;\r\ncase NITIO_G0_Command_Reg:\r\nstc_register = G_Command_Register(0);\r\nbreak;\r\ncase NITIO_G1_Command_Reg:\r\nstc_register = G_Command_Register(1);\r\nbreak;\r\ncase NITIO_G0_HW_Save_Reg:\r\nstc_register = G_HW_Save_Register(0);\r\nbreak;\r\ncase NITIO_G1_HW_Save_Reg:\r\nstc_register = G_HW_Save_Register(1);\r\nbreak;\r\ncase NITIO_G0_SW_Save_Reg:\r\nstc_register = G_Save_Register(0);\r\nbreak;\r\ncase NITIO_G1_SW_Save_Reg:\r\nstc_register = G_Save_Register(1);\r\nbreak;\r\ncase NITIO_G0_Mode_Reg:\r\nstc_register = G_Mode_Register(0);\r\nbreak;\r\ncase NITIO_G1_Mode_Reg:\r\nstc_register = G_Mode_Register(1);\r\nbreak;\r\ncase NITIO_G0_LoadA_Reg:\r\nstc_register = G_Load_A_Register(0);\r\nbreak;\r\ncase NITIO_G1_LoadA_Reg:\r\nstc_register = G_Load_A_Register(1);\r\nbreak;\r\ncase NITIO_G0_LoadB_Reg:\r\nstc_register = G_Load_B_Register(0);\r\nbreak;\r\ncase NITIO_G1_LoadB_Reg:\r\nstc_register = G_Load_B_Register(1);\r\nbreak;\r\ncase NITIO_G0_Input_Select_Reg:\r\nstc_register = G_Input_Select_Register(0);\r\nbreak;\r\ncase NITIO_G1_Input_Select_Reg:\r\nstc_register = G_Input_Select_Register(1);\r\nbreak;\r\ncase NITIO_G01_Status_Reg:\r\nstc_register = G_Status_Register;\r\nbreak;\r\ncase NITIO_G01_Joint_Reset_Reg:\r\nstc_register = Joint_Reset_Register;\r\nbreak;\r\ncase NITIO_G01_Joint_Status1_Reg:\r\nstc_register = Joint_Status_1_Register;\r\nbreak;\r\ncase NITIO_G01_Joint_Status2_Reg:\r\nstc_register = Joint_Status_2_Register;\r\nbreak;\r\ncase NITIO_G0_Interrupt_Acknowledge_Reg:\r\nstc_register = Interrupt_A_Ack_Register;\r\nbreak;\r\ncase NITIO_G1_Interrupt_Acknowledge_Reg:\r\nstc_register = Interrupt_B_Ack_Register;\r\nbreak;\r\ncase NITIO_G0_Status_Reg:\r\nstc_register = AI_Status_1_Register;\r\nbreak;\r\ncase NITIO_G1_Status_Reg:\r\nstc_register = AO_Status_1_Register;\r\nbreak;\r\ncase NITIO_G0_Interrupt_Enable_Reg:\r\nstc_register = Interrupt_A_Enable_Register;\r\nbreak;\r\ncase NITIO_G1_Interrupt_Enable_Reg:\r\nstc_register = Interrupt_B_Enable_Register;\r\nbreak;\r\ndefault:\r\nprintk("%s: unhandled register 0x%x in switch.\n",\r\n__func__, reg);\r\nBUG();\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn stc_register;\r\n}\r\nstatic void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nunsigned stc_register;\r\nstatic const unsigned gpct_joint_reset_mask = G0_Reset | G1_Reset;\r\nstatic const unsigned gpct_interrupt_a_enable_mask =\r\nG0_Gate_Interrupt_Enable | G0_TC_Interrupt_Enable;\r\nstatic const unsigned gpct_interrupt_b_enable_mask =\r\nG1_Gate_Interrupt_Enable | G1_TC_Interrupt_Enable;\r\nswitch (reg) {\r\ncase NITIO_G0_Counting_Mode_Reg:\r\nni_writew(bits, M_Offset_G0_Counting_Mode);\r\nbreak;\r\ncase NITIO_G1_Counting_Mode_Reg:\r\nni_writew(bits, M_Offset_G1_Counting_Mode);\r\nbreak;\r\ncase NITIO_G0_Second_Gate_Reg:\r\nni_writew(bits, M_Offset_G0_Second_Gate);\r\nbreak;\r\ncase NITIO_G1_Second_Gate_Reg:\r\nni_writew(bits, M_Offset_G1_Second_Gate);\r\nbreak;\r\ncase NITIO_G0_DMA_Config_Reg:\r\nni_writew(bits, M_Offset_G0_DMA_Config);\r\nbreak;\r\ncase NITIO_G1_DMA_Config_Reg:\r\nni_writew(bits, M_Offset_G1_DMA_Config);\r\nbreak;\r\ncase NITIO_G0_ABZ_Reg:\r\nni_writew(bits, M_Offset_G0_MSeries_ABZ);\r\nbreak;\r\ncase NITIO_G1_ABZ_Reg:\r\nni_writew(bits, M_Offset_G1_MSeries_ABZ);\r\nbreak;\r\ncase NITIO_G0_LoadA_Reg:\r\ncase NITIO_G1_LoadA_Reg:\r\ncase NITIO_G0_LoadB_Reg:\r\ncase NITIO_G1_LoadB_Reg:\r\nstc_register = ni_gpct_to_stc_register(reg);\r\ndevpriv->stc_writel(dev, bits, stc_register);\r\nbreak;\r\ncase NITIO_G0_Interrupt_Enable_Reg:\r\nBUG_ON(bits & ~gpct_interrupt_a_enable_mask);\r\nni_set_bitfield(dev, Interrupt_A_Enable_Register,\r\ngpct_interrupt_a_enable_mask, bits);\r\nbreak;\r\ncase NITIO_G1_Interrupt_Enable_Reg:\r\nBUG_ON(bits & ~gpct_interrupt_b_enable_mask);\r\nni_set_bitfield(dev, Interrupt_B_Enable_Register,\r\ngpct_interrupt_b_enable_mask, bits);\r\nbreak;\r\ncase NITIO_G01_Joint_Reset_Reg:\r\nBUG_ON(bits & ~gpct_joint_reset_mask);\r\ndefault:\r\nstc_register = ni_gpct_to_stc_register(reg);\r\ndevpriv->stc_writew(dev, bits, stc_register);\r\n}\r\n}\r\nstatic unsigned ni_gpct_read_register(struct ni_gpct *counter,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nunsigned stc_register;\r\nswitch (reg) {\r\ncase NITIO_G0_DMA_Status_Reg:\r\nreturn ni_readw(M_Offset_G0_DMA_Status);\r\nbreak;\r\ncase NITIO_G1_DMA_Status_Reg:\r\nreturn ni_readw(M_Offset_G1_DMA_Status);\r\nbreak;\r\ncase NITIO_G0_HW_Save_Reg:\r\ncase NITIO_G1_HW_Save_Reg:\r\ncase NITIO_G0_SW_Save_Reg:\r\ncase NITIO_G1_SW_Save_Reg:\r\nstc_register = ni_gpct_to_stc_register(reg);\r\nreturn devpriv->stc_readl(dev, stc_register);\r\nbreak;\r\ndefault:\r\nstc_register = ni_gpct_to_stc_register(reg);\r\nreturn devpriv->stc_readw(dev, stc_register);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_freq_out_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = devpriv->clock_and_fout & FOUT_Divider_mask;\r\nreturn 1;\r\n}\r\nstatic int ni_freq_out_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndevpriv->clock_and_fout &= ~FOUT_Enable;\r\ndevpriv->stc_writew(dev, devpriv->clock_and_fout,\r\nClock_and_FOUT_Register);\r\ndevpriv->clock_and_fout &= ~FOUT_Divider_mask;\r\ndevpriv->clock_and_fout |= FOUT_Divider(data[0]);\r\ndevpriv->clock_and_fout |= FOUT_Enable;\r\ndevpriv->stc_writew(dev, devpriv->clock_and_fout,\r\nClock_and_FOUT_Register);\r\nreturn insn->n;\r\n}\r\nstatic int ni_set_freq_out_clock(struct comedi_device *dev,\r\nunsigned int clock_source)\r\n{\r\nswitch (clock_source) {\r\ncase NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:\r\ndevpriv->clock_and_fout &= ~FOUT_Timebase_Select;\r\nbreak;\r\ncase NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:\r\ndevpriv->clock_and_fout |= FOUT_Timebase_Select;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndevpriv->stc_writew(dev, devpriv->clock_and_fout,\r\nClock_and_FOUT_Register);\r\nreturn 3;\r\n}\r\nstatic void ni_get_freq_out_clock(struct comedi_device *dev,\r\nunsigned int *clock_source,\r\nunsigned int *clock_period_ns)\r\n{\r\nif (devpriv->clock_and_fout & FOUT_Timebase_Select) {\r\n*clock_source = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;\r\n*clock_period_ns = TIMEBASE_2_NS;\r\n} else {\r\n*clock_source = NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC;\r\n*clock_period_ns = TIMEBASE_1_NS * 2;\r\n}\r\n}\r\nstatic int ni_freq_out_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nreturn ni_set_freq_out_clock(dev, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nni_get_freq_out_clock(dev, &data[1], &data[2]);\r\nreturn 3;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ni_alloc_private(struct comedi_device *dev)\r\n{\r\nint ret;\r\nret = alloc_private(dev, sizeof(struct ni_private));\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_init(&devpriv->window_lock);\r\nspin_lock_init(&devpriv->soft_reg_copy_lock);\r\nspin_lock_init(&devpriv->mite_channel_lock);\r\nreturn 0;\r\n}\r\nstatic int ni_8255_callback(int dir, int port, int data, unsigned long arg)\r\n{\r\nstruct comedi_device *dev = (struct comedi_device *)arg;\r\nif (dir) {\r\nni_writeb(data, Port_A + 2 * port);\r\nreturn 0;\r\n} else {\r\nreturn ni_readb(Port_A + 2 * port);\r\n}\r\n}\r\nstatic int ni_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));\r\nreturn 1;\r\n}\r\nstatic int ni_read_eeprom(struct comedi_device *dev, int addr)\r\n{\r\nint bit;\r\nint bitstring;\r\nbitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);\r\nni_writeb(0x04, Serial_Command);\r\nfor (bit = 0x8000; bit; bit >>= 1) {\r\nni_writeb(0x04 | ((bit & bitstring) ? 0x02 : 0),\r\nSerial_Command);\r\nni_writeb(0x05 | ((bit & bitstring) ? 0x02 : 0),\r\nSerial_Command);\r\n}\r\nbitstring = 0;\r\nfor (bit = 0x80; bit; bit >>= 1) {\r\nni_writeb(0x04, Serial_Command);\r\nni_writeb(0x05, Serial_Command);\r\nbitstring |= ((ni_readb(XXX_Status) & PROMOUT) ? bit : 0);\r\n}\r\nni_writeb(0x00, Serial_Command);\r\nreturn bitstring;\r\n}\r\nstatic int ni_m_series_eeprom_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[0] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)\r\n{\r\ndata[1] = devpriv->pwm_up_count * devpriv->clock_ns;\r\ndata[2] = devpriv->pwm_down_count * devpriv->clock_ns;\r\nreturn 3;\r\n}\r\nstatic int ni_m_series_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned up_count, down_count;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_PWM_OUTPUT:\r\nswitch (data[1]) {\r\ncase TRIG_ROUND_NEAREST:\r\nup_count =\r\n(data[2] +\r\ndevpriv->clock_ns / 2) / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\nup_count = data[2] / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\nup_count =\r\n(data[2] + devpriv->clock_ns -\r\n1) / devpriv->clock_ns;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nswitch (data[3]) {\r\ncase TRIG_ROUND_NEAREST:\r\ndown_count =\r\n(data[4] +\r\ndevpriv->clock_ns / 2) / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndown_count = data[4] / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndown_count =\r\n(data[4] + devpriv->clock_ns -\r\n1) / devpriv->clock_ns;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (up_count * devpriv->clock_ns != data[2] ||\r\ndown_count * devpriv->clock_ns != data[4]) {\r\ndata[2] = up_count * devpriv->clock_ns;\r\ndata[4] = down_count * devpriv->clock_ns;\r\nreturn -EAGAIN;\r\n}\r\nni_writel(MSeries_Cal_PWM_High_Time_Bits(up_count) |\r\nMSeries_Cal_PWM_Low_Time_Bits(down_count),\r\nM_Offset_Cal_PWM);\r\ndevpriv->pwm_up_count = up_count;\r\ndevpriv->pwm_down_count = down_count;\r\nreturn 5;\r\nbreak;\r\ncase INSN_CONFIG_GET_PWM_OUTPUT:\r\nreturn ni_get_pwm_config(dev, data);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_6143_pwm_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned up_count, down_count;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_PWM_OUTPUT:\r\nswitch (data[1]) {\r\ncase TRIG_ROUND_NEAREST:\r\nup_count =\r\n(data[2] +\r\ndevpriv->clock_ns / 2) / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\nup_count = data[2] / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\nup_count =\r\n(data[2] + devpriv->clock_ns -\r\n1) / devpriv->clock_ns;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nswitch (data[3]) {\r\ncase TRIG_ROUND_NEAREST:\r\ndown_count =\r\n(data[4] +\r\ndevpriv->clock_ns / 2) / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndown_count = data[4] / devpriv->clock_ns;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndown_count =\r\n(data[4] + devpriv->clock_ns -\r\n1) / devpriv->clock_ns;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (up_count * devpriv->clock_ns != data[2] ||\r\ndown_count * devpriv->clock_ns != data[4]) {\r\ndata[2] = up_count * devpriv->clock_ns;\r\ndata[4] = down_count * devpriv->clock_ns;\r\nreturn -EAGAIN;\r\n}\r\nni_writel(up_count, Calibration_HighTime_6143);\r\ndevpriv->pwm_up_count = up_count;\r\nni_writel(down_count, Calibration_LowTime_6143);\r\ndevpriv->pwm_down_count = down_count;\r\nreturn 5;\r\nbreak;\r\ncase INSN_CONFIG_GET_PWM_OUTPUT:\r\nreturn ni_get_pwm_config(dev, data);\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ni_calib_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nni_write_caldac(dev, CR_CHAN(insn->chanspec), data[0]);\r\nreturn 1;\r\n}\r\nstatic int ni_calib_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint i, j;\r\nint n_dacs;\r\nint n_chans = 0;\r\nint n_bits;\r\nint diffbits = 0;\r\nint type;\r\nint chan;\r\ntype = boardtype.caldac[0];\r\nif (type == caldac_none)\r\nreturn;\r\nn_bits = caldacs[type].n_bits;\r\nfor (i = 0; i < 3; i++) {\r\ntype = boardtype.caldac[i];\r\nif (type == caldac_none)\r\nbreak;\r\nif (caldacs[type].n_bits != n_bits)\r\ndiffbits = 1;\r\nn_chans += caldacs[type].n_chans;\r\n}\r\nn_dacs = i;\r\ns->n_chan = n_chans;\r\nif (diffbits) {\r\nunsigned int *maxdata_list;\r\nif (n_chans > MAX_N_CALDACS) {\r\nprintk("BUG! MAX_N_CALDACS too small\n");\r\n}\r\ns->maxdata_list = maxdata_list = devpriv->caldac_maxdata_list;\r\nchan = 0;\r\nfor (i = 0; i < n_dacs; i++) {\r\ntype = boardtype.caldac[i];\r\nfor (j = 0; j < caldacs[type].n_chans; j++) {\r\nmaxdata_list[chan] =\r\n(1 << caldacs[type].n_bits) - 1;\r\nchan++;\r\n}\r\n}\r\nfor (chan = 0; chan < s->n_chan; chan++)\r\nni_write_caldac(dev, i, s->maxdata_list[i] / 2);\r\n} else {\r\ntype = boardtype.caldac[0];\r\ns->maxdata = (1 << caldacs[type].n_bits) - 1;\r\nfor (chan = 0; chan < s->n_chan; chan++)\r\nni_write_caldac(dev, i, s->maxdata / 2);\r\n}\r\n}\r\nstatic void ni_write_caldac(struct comedi_device *dev, int addr, int val)\r\n{\r\nunsigned int loadbit = 0, bits = 0, bit, bitstring = 0;\r\nint i;\r\nint type;\r\nif (devpriv->caldacs[addr] == val)\r\nreturn;\r\ndevpriv->caldacs[addr] = val;\r\nfor (i = 0; i < 3; i++) {\r\ntype = boardtype.caldac[i];\r\nif (type == caldac_none)\r\nbreak;\r\nif (addr < caldacs[type].n_chans) {\r\nbits = caldacs[type].packbits(addr, val, &bitstring);\r\nloadbit = SerDacLd(i);\r\nbreak;\r\n}\r\naddr -= caldacs[type].n_chans;\r\n}\r\nfor (bit = 1 << (bits - 1); bit; bit >>= 1) {\r\nni_writeb(((bit & bitstring) ? 0x02 : 0), Serial_Command);\r\nudelay(1);\r\nni_writeb(1 | ((bit & bitstring) ? 0x02 : 0), Serial_Command);\r\nudelay(1);\r\n}\r\nni_writeb(loadbit, Serial_Command);\r\nudelay(1);\r\nni_writeb(0, Serial_Command);\r\n}\r\nstatic int pack_mb88341(int addr, int val, int *bitstring)\r\n{\r\naddr++;\r\n*bitstring = ((addr & 0x1) << 11) |\r\n((addr & 0x2) << 9) |\r\n((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);\r\nreturn 12;\r\n}\r\nstatic int pack_dac8800(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = ((addr & 0x7) << 8) | (val & 0xff);\r\nreturn 11;\r\n}\r\nstatic int pack_dac8043(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = val & 0xfff;\r\nreturn 12;\r\n}\r\nstatic int pack_ad8522(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);\r\nreturn 16;\r\n}\r\nstatic int pack_ad8804(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = ((addr & 0xf) << 8) | (val & 0xff);\r\nreturn 12;\r\n}\r\nstatic int pack_ad8842(int addr, int val, int *bitstring)\r\n{\r\n*bitstring = ((addr + 1) << 8) | (val & 0xff);\r\nreturn 12;\r\n}\r\nstatic int ni_gpct_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nreturn ni_tio_insn_config(counter, insn, data);\r\n}\r\nstatic int ni_gpct_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nreturn ni_tio_rinsn(counter, insn, data);\r\n}\r\nstatic int ni_gpct_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nreturn ni_tio_winsn(counter, insn, data);\r\n}\r\nstatic int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint retval;\r\n#ifdef PCIDMA\r\nstruct ni_gpct *counter = s->private;\r\nretval = ni_request_gpct_mite_channel(dev, counter->counter_index,\r\nCOMEDI_INPUT);\r\nif (retval) {\r\ncomedi_error(dev,\r\n"no dma channel available for use by counter");\r\nreturn retval;\r\n}\r\nni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);\r\nni_e_series_enable_second_irq(dev, counter->counter_index, 1);\r\nretval = ni_tio_cmd(counter, s->async);\r\n#else\r\nretval = -ENOTSUPP;\r\n#endif\r\nreturn retval;\r\n}\r\nstatic int ni_gpct_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\n#ifdef PCIDMA\r\nstruct ni_gpct *counter = s->private;\r\nreturn ni_tio_cmdtest(counter, cmd);\r\n#else\r\nreturn -ENOTSUPP;\r\n#endif\r\n}\r\nstatic int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\n#ifdef PCIDMA\r\nstruct ni_gpct *counter = s->private;\r\nint retval;\r\nretval = ni_tio_cancel(counter);\r\nni_e_series_enable_second_irq(dev, counter->counter_index, 0);\r\nni_release_gpct_mite_channel(dev, counter->counter_index);\r\nreturn retval;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int ni_m_series_set_pfi_routing(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nunsigned pfi_reg_index;\r\nunsigned array_offset;\r\nif ((source & 0x1f) != source)\r\nreturn -EINVAL;\r\npfi_reg_index = 1 + chan / 3;\r\narray_offset = pfi_reg_index - 1;\r\ndevpriv->pfi_output_select_reg[array_offset] &=\r\n~MSeries_PFI_Output_Select_Mask(chan);\r\ndevpriv->pfi_output_select_reg[array_offset] |=\r\nMSeries_PFI_Output_Select_Bits(chan, source);\r\nni_writew(devpriv->pfi_output_select_reg[array_offset],\r\nM_Offset_PFI_Output_Select(pfi_reg_index));\r\nreturn 2;\r\n}\r\nstatic int ni_old_set_pfi_routing(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nif (source != ni_old_get_pfi_routing(dev, chan))\r\nreturn -EINVAL;\r\nreturn 2;\r\n}\r\nstatic int ni_set_pfi_routing(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nreturn ni_m_series_set_pfi_routing(dev, chan, source);\r\nelse\r\nreturn ni_old_set_pfi_routing(dev, chan, source);\r\n}\r\nstatic unsigned ni_m_series_get_pfi_routing(struct comedi_device *dev,\r\nunsigned chan)\r\n{\r\nconst unsigned array_offset = chan / 3;\r\nreturn MSeries_PFI_Output_Select_Source(chan,\r\ndevpriv->\r\npfi_output_select_reg\r\n[array_offset]);\r\n}\r\nstatic unsigned ni_old_get_pfi_routing(struct comedi_device *dev, unsigned chan)\r\n{\r\nswitch (chan) {\r\ncase 0:\r\nreturn NI_PFI_OUTPUT_AI_START1;\r\nbreak;\r\ncase 1:\r\nreturn NI_PFI_OUTPUT_AI_START2;\r\nbreak;\r\ncase 2:\r\nreturn NI_PFI_OUTPUT_AI_CONVERT;\r\nbreak;\r\ncase 3:\r\nreturn NI_PFI_OUTPUT_G_SRC1;\r\nbreak;\r\ncase 4:\r\nreturn NI_PFI_OUTPUT_G_GATE1;\r\nbreak;\r\ncase 5:\r\nreturn NI_PFI_OUTPUT_AO_UPDATE_N;\r\nbreak;\r\ncase 6:\r\nreturn NI_PFI_OUTPUT_AO_START1;\r\nbreak;\r\ncase 7:\r\nreturn NI_PFI_OUTPUT_AI_START_PULSE;\r\nbreak;\r\ncase 8:\r\nreturn NI_PFI_OUTPUT_G_SRC0;\r\nbreak;\r\ncase 9:\r\nreturn NI_PFI_OUTPUT_G_GATE0;\r\nbreak;\r\ndefault:\r\nprintk("%s: bug, unhandled case in switch.\n", __func__);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned ni_get_pfi_routing(struct comedi_device *dev, unsigned chan)\r\n{\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nreturn ni_m_series_get_pfi_routing(dev, chan);\r\nelse\r\nreturn ni_old_get_pfi_routing(dev, chan);\r\n}\r\nstatic int ni_config_filter(struct comedi_device *dev, unsigned pfi_channel,\r\nenum ni_pfi_filter_select filter)\r\n{\r\nunsigned bits;\r\nif ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {\r\nreturn -ENOTSUPP;\r\n}\r\nbits = ni_readl(M_Offset_PFI_Filter);\r\nbits &= ~MSeries_PFI_Filter_Select_Mask(pfi_channel);\r\nbits |= MSeries_PFI_Filter_Select_Bits(pfi_channel, filter);\r\nni_writel(bits, M_Offset_PFI_Filter);\r\nreturn 0;\r\n}\r\nstatic int ni_pfi_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif ((boardtype.reg_type & ni_reg_m_series_mask) == 0) {\r\nreturn -ENOTSUPP;\r\n}\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nni_writew(s->state, M_Offset_PFI_DO);\r\n}\r\ndata[1] = ni_readw(M_Offset_PFI_DI);\r\nreturn 2;\r\n}\r\nstatic int ni_pfi_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan;\r\nif (insn->n < 1)\r\nreturn -EINVAL;\r\nchan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase COMEDI_OUTPUT:\r\nni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 1);\r\nbreak;\r\ncase COMEDI_INPUT:\r\nni_set_bits(dev, IO_Bidirection_Pin_Register, 1 << chan, 0);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(devpriv->io_bidirection_pin_reg & (1 << chan)) ?\r\nCOMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_SET_ROUTING:\r\nreturn ni_set_pfi_routing(dev, chan, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_GET_ROUTING:\r\ndata[1] = ni_get_pfi_routing(dev, chan);\r\nbreak;\r\ncase INSN_CONFIG_FILTER:\r\nreturn ni_config_filter(dev, chan, data[1]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_rtsi_init(struct comedi_device *dev)\r\n{\r\ndevpriv->clock_and_fout2 = MSeries_RTSI_10MHz_Bit;\r\nif (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0) {\r\nprintk("ni_set_master_clock failed, bug?");\r\n}\r\ndevpriv->rtsi_trig_a_output_reg =\r\nRTSI_Trig_Output_Bits(0,\r\nNI_RTSI_OUTPUT_ADR_START1) |\r\nRTSI_Trig_Output_Bits(1,\r\nNI_RTSI_OUTPUT_ADR_START2) |\r\nRTSI_Trig_Output_Bits(2,\r\nNI_RTSI_OUTPUT_SCLKG) |\r\nRTSI_Trig_Output_Bits(3, NI_RTSI_OUTPUT_DACUPDN);\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,\r\nRTSI_Trig_A_Output_Register);\r\ndevpriv->rtsi_trig_b_output_reg =\r\nRTSI_Trig_Output_Bits(4,\r\nNI_RTSI_OUTPUT_DA_START1) |\r\nRTSI_Trig_Output_Bits(5,\r\nNI_RTSI_OUTPUT_G_SRC0) |\r\nRTSI_Trig_Output_Bits(6, NI_RTSI_OUTPUT_G_GATE0);\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\ndevpriv->rtsi_trig_b_output_reg |=\r\nRTSI_Trig_Output_Bits(7, NI_RTSI_OUTPUT_RTSI_OSC);\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,\r\nRTSI_Trig_B_Output_Register);\r\n}\r\nstatic int ni_rtsi_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\ndata[1] = 0;\r\nreturn 2;\r\n}\r\nstatic int ni_mseries_get_pll_parameters(unsigned reference_period_ns,\r\nunsigned *freq_divider,\r\nunsigned *freq_multiplier,\r\nunsigned *actual_period_ns)\r\n{\r\nunsigned div;\r\nunsigned best_div = 1;\r\nstatic const unsigned max_div = 0x10;\r\nunsigned mult;\r\nunsigned best_mult = 1;\r\nstatic const unsigned max_mult = 0x100;\r\nstatic const unsigned pico_per_nano = 1000;\r\nconst unsigned reference_picosec = reference_period_ns * pico_per_nano;\r\nstatic const unsigned target_picosec = 12500;\r\nstatic const unsigned fudge_factor_80_to_20Mhz = 4;\r\nint best_period_picosec = 0;\r\nfor (div = 1; div <= max_div; ++div) {\r\nfor (mult = 1; mult <= max_mult; ++mult) {\r\nunsigned new_period_ps =\r\n(reference_picosec * div) / mult;\r\nif (abs(new_period_ps - target_picosec) <\r\nabs(best_period_picosec - target_picosec)) {\r\nbest_period_picosec = new_period_ps;\r\nbest_div = div;\r\nbest_mult = mult;\r\n}\r\n}\r\n}\r\nif (best_period_picosec == 0) {\r\nprintk("%s: bug, failed to find pll parameters\n", __func__);\r\nreturn -EIO;\r\n}\r\n*freq_divider = best_div;\r\n*freq_multiplier = best_mult;\r\n*actual_period_ns =\r\n(best_period_picosec * fudge_factor_80_to_20Mhz +\r\n(pico_per_nano / 2)) / pico_per_nano;\r\nreturn 0;\r\n}\r\nstatic inline unsigned num_configurable_rtsi_channels(struct comedi_device *dev)\r\n{\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nreturn 8;\r\nelse\r\nreturn 7;\r\n}\r\nstatic int ni_mseries_set_pll_master_clock(struct comedi_device *dev,\r\nunsigned source, unsigned period_ns)\r\n{\r\nstatic const unsigned min_period_ns = 50;\r\nstatic const unsigned max_period_ns = 1000;\r\nstatic const unsigned timeout = 1000;\r\nunsigned pll_control_bits;\r\nunsigned freq_divider;\r\nunsigned freq_multiplier;\r\nunsigned i;\r\nint retval;\r\nif (source == NI_MIO_PLL_PXI10_CLOCK)\r\nperiod_ns = 100;\r\nif (period_ns < min_period_ns || period_ns > max_period_ns) {\r\nprintk\r\n("%s: you must specify an input clock frequency between %i and %i nanosec "\r\n"for the phased-lock loop.\n", __func__,\r\nmin_period_ns, max_period_ns);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nRTSI_Trig_Direction_Register);\r\npll_control_bits =\r\nMSeries_PLL_Enable_Bit | MSeries_PLL_VCO_Mode_75_150MHz_Bits;\r\ndevpriv->clock_and_fout2 |=\r\nMSeries_Timebase1_Select_Bit | MSeries_Timebase3_Select_Bit;\r\ndevpriv->clock_and_fout2 &= ~MSeries_PLL_In_Source_Select_Mask;\r\nswitch (source) {\r\ncase NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:\r\ndevpriv->clock_and_fout2 |=\r\nMSeries_PLL_In_Source_Select_Star_Trigger_Bits;\r\nretval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,\r\n&freq_multiplier,\r\n&devpriv->clock_ns);\r\nif (retval < 0)\r\nreturn retval;\r\nbreak;\r\ncase NI_MIO_PLL_PXI10_CLOCK:\r\ndevpriv->clock_and_fout2 |=\r\nMSeries_PLL_In_Source_Select_PXI_Clock10;\r\nretval = ni_mseries_get_pll_parameters(period_ns, &freq_divider,\r\n&freq_multiplier,\r\n&devpriv->clock_ns);\r\nif (retval < 0)\r\nreturn retval;\r\nbreak;\r\ndefault:\r\n{\r\nunsigned rtsi_channel;\r\nstatic const unsigned max_rtsi_channel = 7;\r\nfor (rtsi_channel = 0; rtsi_channel <= max_rtsi_channel;\r\n++rtsi_channel) {\r\nif (source ==\r\nNI_MIO_PLL_RTSI_CLOCK(rtsi_channel)) {\r\ndevpriv->clock_and_fout2 |=\r\nMSeries_PLL_In_Source_Select_RTSI_Bits\r\n(rtsi_channel);\r\nbreak;\r\n}\r\n}\r\nif (rtsi_channel > max_rtsi_channel)\r\nreturn -EINVAL;\r\nretval = ni_mseries_get_pll_parameters(period_ns,\r\n&freq_divider,\r\n&freq_multiplier,\r\n&devpriv->\r\nclock_ns);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nbreak;\r\n}\r\nni_writew(devpriv->clock_and_fout2, M_Offset_Clock_and_Fout2);\r\npll_control_bits |=\r\nMSeries_PLL_Divisor_Bits(freq_divider) |\r\nMSeries_PLL_Multiplier_Bits(freq_multiplier);\r\nni_writew(pll_control_bits, M_Offset_PLL_Control);\r\ndevpriv->clock_source = source;\r\nfor (i = 0; i < timeout; ++i) {\r\nif (ni_readw(M_Offset_PLL_Status) & MSeries_PLL_Locked_Bit) {\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\nprintk\r\n("%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns.\n",\r\n__func__, source, period_ns);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 3;\r\n}\r\nstatic int ni_set_master_clock(struct comedi_device *dev, unsigned source,\r\nunsigned period_ns)\r\n{\r\nif (source == NI_MIO_INTERNAL_CLOCK) {\r\ndevpriv->rtsi_trig_direction_reg &= ~Use_RTSI_Clock_Bit;\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nRTSI_Trig_Direction_Register);\r\ndevpriv->clock_ns = TIMEBASE_1_NS;\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\ndevpriv->clock_and_fout2 &=\r\n~(MSeries_Timebase1_Select_Bit |\r\nMSeries_Timebase3_Select_Bit);\r\nni_writew(devpriv->clock_and_fout2,\r\nM_Offset_Clock_and_Fout2);\r\nni_writew(0, M_Offset_PLL_Control);\r\n}\r\ndevpriv->clock_source = source;\r\n} else {\r\nif (boardtype.reg_type & ni_reg_m_series_mask) {\r\nreturn ni_mseries_set_pll_master_clock(dev, source,\r\nperiod_ns);\r\n} else {\r\nif (source == NI_MIO_RTSI_CLOCK) {\r\ndevpriv->rtsi_trig_direction_reg |=\r\nUse_RTSI_Clock_Bit;\r\ndevpriv->stc_writew(dev,\r\ndevpriv->\r\nrtsi_trig_direction_reg,\r\nRTSI_Trig_Direction_Register);\r\nif (period_ns == 0) {\r\nprintk\r\n("%s: we don't handle an unspecified clock period correctly yet, returning error.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else {\r\ndevpriv->clock_ns = period_ns;\r\n}\r\ndevpriv->clock_source = source;\r\n} else\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 3;\r\n}\r\nstatic int ni_valid_rtsi_output_source(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nif (chan >= num_configurable_rtsi_channels(dev)) {\r\nif (chan == old_RTSI_clock_channel) {\r\nif (source == NI_RTSI_OUTPUT_RTSI_OSC)\r\nreturn 1;\r\nelse {\r\nprintk\r\n("%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards.\n",\r\n__func__, chan, old_RTSI_clock_channel);\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nswitch (source) {\r\ncase NI_RTSI_OUTPUT_ADR_START1:\r\ncase NI_RTSI_OUTPUT_ADR_START2:\r\ncase NI_RTSI_OUTPUT_SCLKG:\r\ncase NI_RTSI_OUTPUT_DACUPDN:\r\ncase NI_RTSI_OUTPUT_DA_START1:\r\ncase NI_RTSI_OUTPUT_G_SRC0:\r\ncase NI_RTSI_OUTPUT_G_GATE0:\r\ncase NI_RTSI_OUTPUT_RGOUT0:\r\ncase NI_RTSI_OUTPUT_RTSI_BRD_0:\r\nreturn 1;\r\nbreak;\r\ncase NI_RTSI_OUTPUT_RTSI_OSC:\r\nif (boardtype.reg_type & ni_reg_m_series_mask)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nstatic int ni_set_rtsi_routing(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nif (ni_valid_rtsi_output_source(dev, chan, source) == 0)\r\nreturn -EINVAL;\r\nif (chan < 4) {\r\ndevpriv->rtsi_trig_a_output_reg &= ~RTSI_Trig_Output_Mask(chan);\r\ndevpriv->rtsi_trig_a_output_reg |=\r\nRTSI_Trig_Output_Bits(chan, source);\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_a_output_reg,\r\nRTSI_Trig_A_Output_Register);\r\n} else if (chan < 8) {\r\ndevpriv->rtsi_trig_b_output_reg &= ~RTSI_Trig_Output_Mask(chan);\r\ndevpriv->rtsi_trig_b_output_reg |=\r\nRTSI_Trig_Output_Bits(chan, source);\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_b_output_reg,\r\nRTSI_Trig_B_Output_Register);\r\n}\r\nreturn 2;\r\n}\r\nstatic unsigned ni_get_rtsi_routing(struct comedi_device *dev, unsigned chan)\r\n{\r\nif (chan < 4) {\r\nreturn RTSI_Trig_Output_Source(chan,\r\ndevpriv->rtsi_trig_a_output_reg);\r\n} else if (chan < num_configurable_rtsi_channels(dev)) {\r\nreturn RTSI_Trig_Output_Source(chan,\r\ndevpriv->rtsi_trig_b_output_reg);\r\n} else {\r\nif (chan == old_RTSI_clock_channel)\r\nreturn NI_RTSI_OUTPUT_RTSI_OSC;\r\nprintk("%s: bug! should never get here?\n", __func__);\r\nreturn 0;\r\n}\r\n}\r\nstatic int ni_rtsi_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\nif (chan < num_configurable_rtsi_channels(dev)) {\r\ndevpriv->rtsi_trig_direction_reg |=\r\nRTSI_Output_Bit(chan,\r\n(boardtype.\r\nreg_type & ni_reg_m_series_mask) !=\r\n0);\r\n} else if (chan == old_RTSI_clock_channel) {\r\ndevpriv->rtsi_trig_direction_reg |=\r\nDrive_RTSI_Clock_Bit;\r\n}\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nRTSI_Trig_Direction_Register);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nif (chan < num_configurable_rtsi_channels(dev)) {\r\ndevpriv->rtsi_trig_direction_reg &=\r\n~RTSI_Output_Bit(chan,\r\n(boardtype.\r\nreg_type & ni_reg_m_series_mask)\r\n!= 0);\r\n} else if (chan == old_RTSI_clock_channel) {\r\ndevpriv->rtsi_trig_direction_reg &=\r\n~Drive_RTSI_Clock_Bit;\r\n}\r\ndevpriv->stc_writew(dev, devpriv->rtsi_trig_direction_reg,\r\nRTSI_Trig_Direction_Register);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\nif (chan < num_configurable_rtsi_channels(dev)) {\r\ndata[1] =\r\n(devpriv->rtsi_trig_direction_reg &\r\nRTSI_Output_Bit(chan,\r\n(boardtype.reg_type &\r\nni_reg_m_series_mask)\r\n!= 0)) ? INSN_CONFIG_DIO_OUTPUT :\r\nINSN_CONFIG_DIO_INPUT;\r\n} else if (chan == old_RTSI_clock_channel) {\r\ndata[1] =\r\n(devpriv->rtsi_trig_direction_reg &\r\nDrive_RTSI_Clock_Bit)\r\n? INSN_CONFIG_DIO_OUTPUT : INSN_CONFIG_DIO_INPUT;\r\n}\r\nreturn 2;\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nreturn ni_set_master_clock(dev, data[1], data[2]);\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\ndata[1] = devpriv->clock_source;\r\ndata[2] = devpriv->clock_ns;\r\nreturn 3;\r\nbreak;\r\ncase INSN_CONFIG_SET_ROUTING:\r\nreturn ni_set_rtsi_routing(dev, chan, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_GET_ROUTING:\r\ndata[1] = ni_get_rtsi_routing(dev, chan);\r\nreturn 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int cs5529_wait_for_idle(struct comedi_device *dev)\r\n{\r\nunsigned short status;\r\nconst int timeout = HZ;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nstatus = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);\r\nif ((status & CSS_ADC_BUSY) == 0) {\r\nbreak;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (schedule_timeout(1)) {\r\nreturn -EIO;\r\n}\r\n}\r\nif (i == timeout) {\r\nprintk("%s: %s: timeout\n", __FILE__, __func__);\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cs5529_command(struct comedi_device *dev, unsigned short value)\r\n{\r\nstatic const int timeout = 100;\r\nint i;\r\nni_ao_win_outw(dev, value, CAL_ADC_Command_67xx);\r\nfor (i = 0; i < timeout; i++) {\r\nif ((ni_ao_win_inw(dev, CAL_ADC_Status_67xx) & CSS_ADC_BUSY))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "possible problem - never saw adc go busy?");\r\n}\r\n}\r\nstatic void cs5529_config_write(struct comedi_device *dev, unsigned int value,\r\nunsigned int reg_select_bits)\r\n{\r\nni_ao_win_outw(dev, ((value >> 16) & 0xff),\r\nCAL_ADC_Config_Data_High_Word_67xx);\r\nni_ao_win_outw(dev, (value & 0xffff),\r\nCAL_ADC_Config_Data_Low_Word_67xx);\r\nreg_select_bits &= CSCMD_REGISTER_SELECT_MASK;\r\ncs5529_command(dev, CSCMD_COMMAND | reg_select_bits);\r\nif (cs5529_wait_for_idle(dev))\r\ncomedi_error(dev, "time or signal in cs5529_config_write()");\r\n}\r\nstatic unsigned int cs5529_config_read(struct comedi_device *dev,\r\nunsigned int reg_select_bits)\r\n{\r\nunsigned int value;\r\nreg_select_bits &= CSCMD_REGISTER_SELECT_MASK;\r\ncs5529_command(dev, CSCMD_COMMAND | CSCMD_READ | reg_select_bits);\r\nif (cs5529_wait_for_idle(dev))\r\ncomedi_error(dev, "timeout or signal in cs5529_config_read()");\r\nvalue = (ni_ao_win_inw(dev,\r\nCAL_ADC_Config_Data_High_Word_67xx) << 16) &\r\n0xff0000;\r\nvalue |= ni_ao_win_inw(dev, CAL_ADC_Config_Data_Low_Word_67xx) & 0xffff;\r\nreturn value;\r\n}\r\nstatic int cs5529_do_conversion(struct comedi_device *dev, unsigned short *data)\r\n{\r\nint retval;\r\nunsigned short status;\r\ncs5529_command(dev, CSCMD_COMMAND | CSCMD_SINGLE_CONVERSION);\r\nretval = cs5529_wait_for_idle(dev);\r\nif (retval) {\r\ncomedi_error(dev,\r\n"timeout or signal in cs5529_do_conversion()");\r\nreturn -ETIME;\r\n}\r\nstatus = ni_ao_win_inw(dev, CAL_ADC_Status_67xx);\r\nif (status & CSS_OSC_DETECT) {\r\nprintk\r\n("ni_mio_common: cs5529 conversion error, status CSS_OSC_DETECT\n");\r\nreturn -EIO;\r\n}\r\nif (status & CSS_OVERRANGE) {\r\nprintk\r\n("ni_mio_common: cs5529 conversion error, overrange (ignoring)\n");\r\n}\r\nif (data) {\r\n*data = ni_ao_win_inw(dev, CAL_ADC_Data_67xx);\r\n*data ^= (1 << 15);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs5529_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n, retval;\r\nunsigned short sample;\r\nunsigned int channel_select;\r\nconst unsigned int INTERNAL_REF = 0x1000;\r\nif (insn->chanspec & CR_ALT_SOURCE)\r\nchannel_select = INTERNAL_REF;\r\nelse\r\nchannel_select = CR_CHAN(insn->chanspec);\r\nni_ao_win_outw(dev, channel_select, AO_Calibration_Channel_Select_67xx);\r\nfor (n = 0; n < insn->n; n++) {\r\nretval = cs5529_do_conversion(dev, &sample);\r\nif (retval < 0)\r\nreturn retval;\r\ndata[n] = sample;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int init_cs5529(struct comedi_device *dev)\r\n{\r\nunsigned int config_bits =\r\nCSCFG_PORT_MODE | CSCFG_WORD_RATE_2180_CYCLES;\r\n#if 1\r\ncs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET_GAIN,\r\nCSCMD_CONFIG_REGISTER);\r\ncs5529_do_conversion(dev, NULL);\r\n#else\r\ncs5529_config_write(dev, 0x400000, CSCMD_GAIN_REGISTER);\r\ncs5529_config_write(dev, config_bits | CSCFG_SELF_CAL_OFFSET,\r\nCSCMD_CONFIG_REGISTER);\r\nif (cs5529_wait_for_idle(dev))\r\ncomedi_error(dev, "timeout or signal in init_cs5529()\n");\r\n#endif\r\n#ifdef NI_CS5529_DEBUG\r\nprintk("config: 0x%x\n", cs5529_config_read(dev,\r\nCSCMD_CONFIG_REGISTER));\r\nprintk("gain: 0x%x\n", cs5529_config_read(dev, CSCMD_GAIN_REGISTER));\r\nprintk("offset: 0x%x\n", cs5529_config_read(dev,\r\nCSCMD_OFFSET_REGISTER));\r\n#endif\r\nreturn 0;\r\n}
