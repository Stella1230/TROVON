static char *bits_names(unsigned int bits, char *names[], int size)\r\n{\r\nint i, n;\r\nstatic char buf[128];\r\nfor (i = 0, n = 0; i < size; i++) {\r\nif (bits & (1U<<i) && names[i])\r\nn += snprintf(buf + n, sizeof(buf) - n, " %s",\r\nnames[i]);\r\n}\r\nbuf[n] = '\0';\r\nreturn buf;\r\n}\r\nstatic const char *get_wid_type_name(unsigned int wid_value)\r\n{\r\nstatic char *names[16] = {\r\n[AC_WID_AUD_OUT] = "Audio Output",\r\n[AC_WID_AUD_IN] = "Audio Input",\r\n[AC_WID_AUD_MIX] = "Audio Mixer",\r\n[AC_WID_AUD_SEL] = "Audio Selector",\r\n[AC_WID_PIN] = "Pin Complex",\r\n[AC_WID_POWER] = "Power Widget",\r\n[AC_WID_VOL_KNB] = "Volume Knob Widget",\r\n[AC_WID_BEEP] = "Beep Generator Widget",\r\n[AC_WID_VENDOR] = "Vendor Defined Widget",\r\n};\r\nif (wid_value == -1)\r\nreturn "UNKNOWN Widget";\r\nwid_value &= 0xf;\r\nif (names[wid_value])\r\nreturn names[wid_value];\r\nelse\r\nreturn "UNKNOWN Widget";\r\n}\r\nstatic void print_nid_array(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid,\r\nstruct snd_array *array)\r\n{\r\nint i;\r\nstruct hda_nid_item *items = array->list, *item;\r\nstruct snd_kcontrol *kctl;\r\nfor (i = 0; i < array->used; i++) {\r\nitem = &items[i];\r\nif (item->nid == nid) {\r\nkctl = item->kctl;\r\nsnd_iprintf(buffer,\r\n" Control: name=\"%s\", index=%i, device=%i\n",\r\nkctl->id.name, kctl->id.index + item->index,\r\nkctl->id.device);\r\nif (item->flags & HDA_NID_ITEM_AMP)\r\nsnd_iprintf(buffer,\r\n" ControlAmp: chs=%lu, dir=%s, "\r\n"idx=%lu, ofs=%lu\n",\r\nget_amp_channels(kctl),\r\nget_amp_direction(kctl) ? "Out" : "In",\r\nget_amp_index(kctl),\r\nget_amp_offset(kctl));\r\n}\r\n}\r\n}\r\nstatic void print_nid_pcms(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nint pcm, type;\r\nstruct hda_pcm *cpcm;\r\nfor (pcm = 0; pcm < codec->num_pcms; pcm++) {\r\ncpcm = &codec->pcm_info[pcm];\r\nfor (type = 0; type < 2; type++) {\r\nif (cpcm->stream[type].nid != nid || cpcm->pcm == NULL)\r\ncontinue;\r\nsnd_iprintf(buffer, " Device: name=\"%s\", "\r\n"type=\"%s\", device=%i\n",\r\ncpcm->name,\r\nsnd_hda_pcm_type_name[cpcm->pcm_type],\r\ncpcm->pcm->device);\r\n}\r\n}\r\n}\r\nstatic void print_amp_caps(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid, int dir)\r\n{\r\nunsigned int caps;\r\ncaps = snd_hda_param_read(codec, nid,\r\ndir == HDA_OUTPUT ?\r\nAC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\r\nif (caps == -1 || caps == 0) {\r\nsnd_iprintf(buffer, "N/A\n");\r\nreturn;\r\n}\r\nsnd_iprintf(buffer, "ofs=0x%02x, nsteps=0x%02x, stepsize=0x%02x, "\r\n"mute=%x\n",\r\ncaps & AC_AMPCAP_OFFSET,\r\n(caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT,\r\n(caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT,\r\n(caps & AC_AMPCAP_MUTE) >> AC_AMPCAP_MUTE_SHIFT);\r\n}\r\nstatic void print_amp_vals(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid,\r\nint dir, int stereo, int indices)\r\n{\r\nunsigned int val;\r\nint i;\r\ndir = dir == HDA_OUTPUT ? AC_AMP_GET_OUTPUT : AC_AMP_GET_INPUT;\r\nfor (i = 0; i < indices; i++) {\r\nsnd_iprintf(buffer, " [");\r\nif (stereo) {\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_AMP_GAIN_MUTE,\r\nAC_AMP_GET_LEFT | dir | i);\r\nsnd_iprintf(buffer, "0x%02x ", val);\r\n}\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_AMP_GAIN_MUTE,\r\nAC_AMP_GET_RIGHT | dir | i);\r\nsnd_iprintf(buffer, "0x%02x]", val);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void print_pcm_rates(struct snd_info_buffer *buffer, unsigned int pcm)\r\n{\r\nstatic unsigned int rates[] = {\r\n8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200,\r\n96000, 176400, 192000, 384000\r\n};\r\nint i;\r\npcm &= AC_SUPPCM_RATES;\r\nsnd_iprintf(buffer, " rates [0x%x]:", pcm);\r\nfor (i = 0; i < ARRAY_SIZE(rates); i++)\r\nif (pcm & (1 << i))\r\nsnd_iprintf(buffer, " %d", rates[i]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void print_pcm_bits(struct snd_info_buffer *buffer, unsigned int pcm)\r\n{\r\nchar buf[SND_PRINT_BITS_ADVISED_BUFSIZE];\r\nsnd_iprintf(buffer, " bits [0x%x]:", (pcm >> 16) & 0xff);\r\nsnd_print_pcm_bits(pcm, buf, sizeof(buf));\r\nsnd_iprintf(buffer, "%s\n", buf);\r\n}\r\nstatic void print_pcm_formats(struct snd_info_buffer *buffer,\r\nunsigned int streams)\r\n{\r\nsnd_iprintf(buffer, " formats [0x%x]:", streams & 0xf);\r\nif (streams & AC_SUPFMT_PCM)\r\nsnd_iprintf(buffer, " PCM");\r\nif (streams & AC_SUPFMT_FLOAT32)\r\nsnd_iprintf(buffer, " FLOAT");\r\nif (streams & AC_SUPFMT_AC3)\r\nsnd_iprintf(buffer, " AC3");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void print_pcm_caps(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int pcm = snd_hda_param_read(codec, nid, AC_PAR_PCM);\r\nunsigned int stream = snd_hda_param_read(codec, nid, AC_PAR_STREAM);\r\nif (pcm == -1 || stream == -1) {\r\nsnd_iprintf(buffer, "N/A\n");\r\nreturn;\r\n}\r\nprint_pcm_rates(buffer, pcm);\r\nprint_pcm_bits(buffer, pcm);\r\nprint_pcm_formats(buffer, stream);\r\n}\r\nstatic const char *get_jack_connection(u32 cfg)\r\n{\r\nstatic char *names[16] = {\r\n"Unknown", "1/8", "1/4", "ATAPI",\r\n"RCA", "Optical","Digital", "Analog",\r\n"DIN", "XLR", "RJ11", "Comb",\r\nNULL, NULL, NULL, "Other"\r\n};\r\ncfg = (cfg & AC_DEFCFG_CONN_TYPE) >> AC_DEFCFG_CONN_TYPE_SHIFT;\r\nif (names[cfg])\r\nreturn names[cfg];\r\nelse\r\nreturn "UNKNOWN";\r\n}\r\nstatic const char *get_jack_color(u32 cfg)\r\n{\r\nstatic char *names[16] = {\r\n"Unknown", "Black", "Grey", "Blue",\r\n"Green", "Red", "Orange", "Yellow",\r\n"Purple", "Pink", NULL, NULL,\r\nNULL, NULL, "White", "Other",\r\n};\r\ncfg = (cfg & AC_DEFCFG_COLOR) >> AC_DEFCFG_COLOR_SHIFT;\r\nif (names[cfg])\r\nreturn names[cfg];\r\nelse\r\nreturn "UNKNOWN";\r\n}\r\nstatic void print_pin_caps(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid,\r\nint *supports_vref)\r\n{\r\nstatic char *jack_conns[4] = { "Jack", "N/A", "Fixed", "Both" };\r\nunsigned int caps, val;\r\ncaps = snd_hda_param_read(codec, nid, AC_PAR_PIN_CAP);\r\nsnd_iprintf(buffer, " Pincap 0x%08x:", caps);\r\nif (caps & AC_PINCAP_IN)\r\nsnd_iprintf(buffer, " IN");\r\nif (caps & AC_PINCAP_OUT)\r\nsnd_iprintf(buffer, " OUT");\r\nif (caps & AC_PINCAP_HP_DRV)\r\nsnd_iprintf(buffer, " HP");\r\nif (caps & AC_PINCAP_EAPD)\r\nsnd_iprintf(buffer, " EAPD");\r\nif (caps & AC_PINCAP_PRES_DETECT)\r\nsnd_iprintf(buffer, " Detect");\r\nif (caps & AC_PINCAP_BALANCE)\r\nsnd_iprintf(buffer, " Balanced");\r\nif (caps & AC_PINCAP_HDMI) {\r\nif ((codec->vendor_id >> 16) == 0x10ec)\r\nsnd_iprintf(buffer, " R/L");\r\nelse {\r\nif (caps & AC_PINCAP_HBR)\r\nsnd_iprintf(buffer, " HBR");\r\nsnd_iprintf(buffer, " HDMI");\r\n}\r\n}\r\nif (caps & AC_PINCAP_DP)\r\nsnd_iprintf(buffer, " DP");\r\nif (caps & AC_PINCAP_TRIG_REQ)\r\nsnd_iprintf(buffer, " Trigger");\r\nif (caps & AC_PINCAP_IMP_SENSE)\r\nsnd_iprintf(buffer, " ImpSense");\r\nsnd_iprintf(buffer, "\n");\r\nif (caps & AC_PINCAP_VREF) {\r\nunsigned int vref =\r\n(caps & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\r\nsnd_iprintf(buffer, " Vref caps:");\r\nif (vref & AC_PINCAP_VREF_HIZ)\r\nsnd_iprintf(buffer, " HIZ");\r\nif (vref & AC_PINCAP_VREF_50)\r\nsnd_iprintf(buffer, " 50");\r\nif (vref & AC_PINCAP_VREF_GRD)\r\nsnd_iprintf(buffer, " GRD");\r\nif (vref & AC_PINCAP_VREF_80)\r\nsnd_iprintf(buffer, " 80");\r\nif (vref & AC_PINCAP_VREF_100)\r\nsnd_iprintf(buffer, " 100");\r\nsnd_iprintf(buffer, "\n");\r\n*supports_vref = 1;\r\n} else\r\n*supports_vref = 0;\r\nif (caps & AC_PINCAP_EAPD) {\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_EAPD_BTLENABLE, 0);\r\nsnd_iprintf(buffer, " EAPD 0x%x:", val);\r\nif (val & AC_EAPDBTL_BALANCED)\r\nsnd_iprintf(buffer, " BALANCED");\r\nif (val & AC_EAPDBTL_EAPD)\r\nsnd_iprintf(buffer, " EAPD");\r\nif (val & AC_EAPDBTL_LR_SWAP)\r\nsnd_iprintf(buffer, " R/L");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\ncaps = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONFIG_DEFAULT, 0);\r\nsnd_iprintf(buffer, " Pin Default 0x%08x: [%s] %s at %s %s\n", caps,\r\njack_conns[(caps & AC_DEFCFG_PORT_CONN) >> AC_DEFCFG_PORT_CONN_SHIFT],\r\nsnd_hda_get_jack_type(caps),\r\nsnd_hda_get_jack_connectivity(caps),\r\nsnd_hda_get_jack_location(caps));\r\nsnd_iprintf(buffer, " Conn = %s, Color = %s\n",\r\nget_jack_connection(caps),\r\nget_jack_color(caps));\r\nsnd_iprintf(buffer, " DefAssociation = 0x%x, Sequence = 0x%x\n",\r\n(caps & AC_DEFCFG_DEF_ASSOC) >> AC_DEFCFG_ASSOC_SHIFT,\r\ncaps & AC_DEFCFG_SEQUENCE);\r\nif (((caps & AC_DEFCFG_MISC) >> AC_DEFCFG_MISC_SHIFT) &\r\nAC_DEFCFG_MISC_NO_PRESENCE) {\r\nsnd_iprintf(buffer, " Misc = NO_PRESENCE\n");\r\n}\r\n}\r\nstatic void print_pin_ctls(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid,\r\nint supports_vref)\r\n{\r\nunsigned int pinctls;\r\npinctls = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_iprintf(buffer, " Pin-ctls: 0x%02x:", pinctls);\r\nif (pinctls & AC_PINCTL_IN_EN)\r\nsnd_iprintf(buffer, " IN");\r\nif (pinctls & AC_PINCTL_OUT_EN)\r\nsnd_iprintf(buffer, " OUT");\r\nif (pinctls & AC_PINCTL_HP_EN)\r\nsnd_iprintf(buffer, " HP");\r\nif (supports_vref) {\r\nint vref = pinctls & AC_PINCTL_VREFEN;\r\nswitch (vref) {\r\ncase AC_PINCTL_VREF_HIZ:\r\nsnd_iprintf(buffer, " VREF_HIZ");\r\nbreak;\r\ncase AC_PINCTL_VREF_50:\r\nsnd_iprintf(buffer, " VREF_50");\r\nbreak;\r\ncase AC_PINCTL_VREF_GRD:\r\nsnd_iprintf(buffer, " VREF_GRD");\r\nbreak;\r\ncase AC_PINCTL_VREF_80:\r\nsnd_iprintf(buffer, " VREF_80");\r\nbreak;\r\ncase AC_PINCTL_VREF_100:\r\nsnd_iprintf(buffer, " VREF_100");\r\nbreak;\r\n}\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void print_vol_knob(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int cap = snd_hda_param_read(codec, nid,\r\nAC_PAR_VOL_KNB_CAP);\r\nsnd_iprintf(buffer, " Volume-Knob: delta=%d, steps=%d, ",\r\n(cap >> 7) & 1, cap & 0x7f);\r\ncap = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_VOLUME_KNOB_CONTROL, 0);\r\nsnd_iprintf(buffer, "direct=%d, val=%d\n",\r\n(cap >> 7) & 1, cap & 0x7f);\r\n}\r\nstatic void print_audio_io(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid,\r\nunsigned int wid_type)\r\n{\r\nint conv = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\r\nsnd_iprintf(buffer,\r\n" Converter: stream=%d, channel=%d\n",\r\n(conv & AC_CONV_STREAM) >> AC_CONV_STREAM_SHIFT,\r\nconv & AC_CONV_CHANNEL);\r\nif (wid_type == AC_WID_AUD_IN && (conv & AC_CONV_CHANNEL) == 0) {\r\nint sdi = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_SDI_SELECT, 0);\r\nsnd_iprintf(buffer, " SDI-Select: %d\n",\r\nsdi & AC_SDI_SELECT);\r\n}\r\n}\r\nstatic void print_digital_conv(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int digi1 = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_DIGI_CONVERT_1, 0);\r\nsnd_iprintf(buffer, " Digital:");\r\nif (digi1 & AC_DIG1_ENABLE)\r\nsnd_iprintf(buffer, " Enabled");\r\nif (digi1 & AC_DIG1_V)\r\nsnd_iprintf(buffer, " Validity");\r\nif (digi1 & AC_DIG1_VCFG)\r\nsnd_iprintf(buffer, " ValidityCfg");\r\nif (digi1 & AC_DIG1_EMPHASIS)\r\nsnd_iprintf(buffer, " Preemphasis");\r\nif (digi1 & AC_DIG1_COPYRIGHT)\r\nsnd_iprintf(buffer, " Copyright");\r\nif (digi1 & AC_DIG1_NONAUDIO)\r\nsnd_iprintf(buffer, " Non-Audio");\r\nif (digi1 & AC_DIG1_PROFESSIONAL)\r\nsnd_iprintf(buffer, " Pro");\r\nif (digi1 & AC_DIG1_LEVEL)\r\nsnd_iprintf(buffer, " GenLevel");\r\nsnd_iprintf(buffer, "\n");\r\nsnd_iprintf(buffer, " Digital category: 0x%x\n",\r\n(digi1 >> 8) & AC_DIG2_CC);\r\n}\r\nstatic const char *get_pwr_state(u32 state)\r\n{\r\nstatic const char * const buf[4] = {\r\n"D0", "D1", "D2", "D3"\r\n};\r\nif (state < 4)\r\nreturn buf[state];\r\nreturn "UNKNOWN";\r\n}\r\nstatic void print_power_state(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstatic char *names[] = {\r\n[ilog2(AC_PWRST_D0SUP)] = "D0",\r\n[ilog2(AC_PWRST_D1SUP)] = "D1",\r\n[ilog2(AC_PWRST_D2SUP)] = "D2",\r\n[ilog2(AC_PWRST_D3SUP)] = "D3",\r\n[ilog2(AC_PWRST_D3COLDSUP)] = "D3cold",\r\n[ilog2(AC_PWRST_S3D3COLDSUP)] = "S3D3cold",\r\n[ilog2(AC_PWRST_CLKSTOP)] = "CLKSTOP",\r\n[ilog2(AC_PWRST_EPSS)] = "EPSS",\r\n};\r\nint sup = snd_hda_param_read(codec, nid, AC_PAR_POWER_STATE);\r\nint pwr = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_POWER_STATE, 0);\r\nif (sup)\r\nsnd_iprintf(buffer, " Power states: %s\n",\r\nbits_names(sup, names, ARRAY_SIZE(names)));\r\nsnd_iprintf(buffer, " Power: setting=%s, actual=%s\n",\r\nget_pwr_state(pwr & AC_PWRST_SETTING),\r\nget_pwr_state((pwr & AC_PWRST_ACTUAL) >>\r\nAC_PWRST_ACTUAL_SHIFT));\r\n}\r\nstatic void print_unsol_cap(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nint unsol = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_UNSOLICITED_RESPONSE, 0);\r\nsnd_iprintf(buffer,\r\n" Unsolicited: tag=%02x, enabled=%d\n",\r\nunsol & AC_UNSOL_TAG,\r\n(unsol & AC_UNSOL_ENABLED) ? 1 : 0);\r\n}\r\nstatic void print_proc_caps(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int proc_caps = snd_hda_param_read(codec, nid,\r\nAC_PAR_PROC_CAP);\r\nsnd_iprintf(buffer, " Processing caps: benign=%d, ncoeff=%d\n",\r\nproc_caps & AC_PCAP_BENIGN,\r\n(proc_caps & AC_PCAP_NUM_COEF) >> AC_PCAP_NUM_COEF_SHIFT);\r\n}\r\nstatic void print_conn_list(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid,\r\nunsigned int wid_type, hda_nid_t *conn,\r\nint conn_len)\r\n{\r\nint c, curr = -1;\r\nif (conn_len > 1 &&\r\nwid_type != AC_WID_AUD_MIX &&\r\nwid_type != AC_WID_VOL_KNB &&\r\nwid_type != AC_WID_POWER)\r\ncurr = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_CONNECT_SEL, 0);\r\nsnd_iprintf(buffer, " Connection: %d\n", conn_len);\r\nif (conn_len > 0) {\r\nsnd_iprintf(buffer, " ");\r\nfor (c = 0; c < conn_len; c++) {\r\nsnd_iprintf(buffer, " 0x%02x", conn[c]);\r\nif (c == curr)\r\nsnd_iprintf(buffer, "*");\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nstatic void print_gpio(struct snd_info_buffer *buffer,\r\nstruct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int gpio =\r\nsnd_hda_param_read(codec, codec->afg, AC_PAR_GPIO_CAP);\r\nunsigned int enable, direction, wake, unsol, sticky, data;\r\nint i, max;\r\nsnd_iprintf(buffer, "GPIO: io=%d, o=%d, i=%d, "\r\n"unsolicited=%d, wake=%d\n",\r\ngpio & AC_GPIO_IO_COUNT,\r\n(gpio & AC_GPIO_O_COUNT) >> AC_GPIO_O_COUNT_SHIFT,\r\n(gpio & AC_GPIO_I_COUNT) >> AC_GPIO_I_COUNT_SHIFT,\r\n(gpio & AC_GPIO_UNSOLICITED) ? 1 : 0,\r\n(gpio & AC_GPIO_WAKE) ? 1 : 0);\r\nmax = gpio & AC_GPIO_IO_COUNT;\r\nif (!max || max > 8)\r\nreturn;\r\nenable = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_MASK, 0);\r\ndirection = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_DIRECTION, 0);\r\nwake = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_WAKE_MASK, 0);\r\nunsol = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK, 0);\r\nsticky = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_STICKY_MASK, 0);\r\ndata = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_GPIO_DATA, 0);\r\nfor (i = 0; i < max; ++i)\r\nsnd_iprintf(buffer,\r\n" IO[%d]: enable=%d, dir=%d, wake=%d, "\r\n"sticky=%d, data=%d, unsol=%d\n", i,\r\n(enable & (1<<i)) ? 1 : 0,\r\n(direction & (1<<i)) ? 1 : 0,\r\n(wake & (1<<i)) ? 1 : 0,\r\n(sticky & (1<<i)) ? 1 : 0,\r\n(data & (1<<i)) ? 1 : 0,\r\n(unsol & (1<<i)) ? 1 : 0);\r\nprint_nid_array(buffer, codec, nid, &codec->mixers);\r\nprint_nid_array(buffer, codec, nid, &codec->nids);\r\n}\r\nstatic void print_codec_info(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hda_codec *codec = entry->private_data;\r\nhda_nid_t nid;\r\nint i, nodes;\r\nsnd_iprintf(buffer, "Codec: ");\r\nif (codec->vendor_name && codec->chip_name)\r\nsnd_iprintf(buffer, "%s %s\n",\r\ncodec->vendor_name, codec->chip_name);\r\nelse\r\nsnd_iprintf(buffer, "Not Set\n");\r\nsnd_iprintf(buffer, "Address: %d\n", codec->addr);\r\nif (codec->afg)\r\nsnd_iprintf(buffer, "AFG Function Id: 0x%x (unsol %u)\n",\r\ncodec->afg_function_id, codec->afg_unsol);\r\nif (codec->mfg)\r\nsnd_iprintf(buffer, "MFG Function Id: 0x%x (unsol %u)\n",\r\ncodec->mfg_function_id, codec->mfg_unsol);\r\nsnd_iprintf(buffer, "Vendor Id: 0x%08x\n", codec->vendor_id);\r\nsnd_iprintf(buffer, "Subsystem Id: 0x%08x\n", codec->subsystem_id);\r\nsnd_iprintf(buffer, "Revision Id: 0x%x\n", codec->revision_id);\r\nif (codec->mfg)\r\nsnd_iprintf(buffer, "Modem Function Group: 0x%x\n", codec->mfg);\r\nelse\r\nsnd_iprintf(buffer, "No Modem Function Group found\n");\r\nif (! codec->afg)\r\nreturn;\r\nsnd_hda_power_up(codec);\r\nsnd_iprintf(buffer, "Default PCM:\n");\r\nprint_pcm_caps(buffer, codec, codec->afg);\r\nsnd_iprintf(buffer, "Default Amp-In caps: ");\r\nprint_amp_caps(buffer, codec, codec->afg, HDA_INPUT);\r\nsnd_iprintf(buffer, "Default Amp-Out caps: ");\r\nprint_amp_caps(buffer, codec, codec->afg, HDA_OUTPUT);\r\nnodes = snd_hda_get_sub_nodes(codec, codec->afg, &nid);\r\nif (! nid || nodes < 0) {\r\nsnd_iprintf(buffer, "Invalid AFG subtree\n");\r\nsnd_hda_power_down(codec);\r\nreturn;\r\n}\r\nprint_gpio(buffer, codec, codec->afg);\r\nif (codec->proc_widget_hook)\r\ncodec->proc_widget_hook(buffer, codec, codec->afg);\r\nfor (i = 0; i < nodes; i++, nid++) {\r\nunsigned int wid_caps =\r\nsnd_hda_param_read(codec, nid,\r\nAC_PAR_AUDIO_WIDGET_CAP);\r\nunsigned int wid_type = get_wcaps_type(wid_caps);\r\nhda_nid_t conn[HDA_MAX_CONNECTIONS];\r\nint conn_len = 0;\r\nsnd_iprintf(buffer, "Node 0x%02x [%s] wcaps 0x%x:", nid,\r\nget_wid_type_name(wid_type), wid_caps);\r\nif (wid_caps & AC_WCAP_STEREO) {\r\nunsigned int chans = get_wcaps_channels(wid_caps);\r\nif (chans == 2)\r\nsnd_iprintf(buffer, " Stereo");\r\nelse\r\nsnd_iprintf(buffer, " %d-Channels", chans);\r\n} else\r\nsnd_iprintf(buffer, " Mono");\r\nif (wid_caps & AC_WCAP_DIGITAL)\r\nsnd_iprintf(buffer, " Digital");\r\nif (wid_caps & AC_WCAP_IN_AMP)\r\nsnd_iprintf(buffer, " Amp-In");\r\nif (wid_caps & AC_WCAP_OUT_AMP)\r\nsnd_iprintf(buffer, " Amp-Out");\r\nif (wid_caps & AC_WCAP_STRIPE)\r\nsnd_iprintf(buffer, " Stripe");\r\nif (wid_caps & AC_WCAP_LR_SWAP)\r\nsnd_iprintf(buffer, " R/L");\r\nif (wid_caps & AC_WCAP_CP_CAPS)\r\nsnd_iprintf(buffer, " CP");\r\nsnd_iprintf(buffer, "\n");\r\nprint_nid_array(buffer, codec, nid, &codec->mixers);\r\nprint_nid_array(buffer, codec, nid, &codec->nids);\r\nprint_nid_pcms(buffer, codec, nid);\r\nif (wid_type == AC_WID_VOL_KNB)\r\nwid_caps |= AC_WCAP_CONN_LIST;\r\nif (wid_caps & AC_WCAP_CONN_LIST)\r\nconn_len = snd_hda_get_raw_connections(codec, nid, conn,\r\nHDA_MAX_CONNECTIONS);\r\nif (wid_caps & AC_WCAP_IN_AMP) {\r\nsnd_iprintf(buffer, " Amp-In caps: ");\r\nprint_amp_caps(buffer, codec, nid, HDA_INPUT);\r\nsnd_iprintf(buffer, " Amp-In vals: ");\r\nif (wid_type == AC_WID_PIN ||\r\n(codec->single_adc_amp &&\r\nwid_type == AC_WID_AUD_IN))\r\nprint_amp_vals(buffer, codec, nid, HDA_INPUT,\r\nwid_caps & AC_WCAP_STEREO,\r\n1);\r\nelse\r\nprint_amp_vals(buffer, codec, nid, HDA_INPUT,\r\nwid_caps & AC_WCAP_STEREO,\r\nconn_len);\r\n}\r\nif (wid_caps & AC_WCAP_OUT_AMP) {\r\nsnd_iprintf(buffer, " Amp-Out caps: ");\r\nprint_amp_caps(buffer, codec, nid, HDA_OUTPUT);\r\nsnd_iprintf(buffer, " Amp-Out vals: ");\r\nif (wid_type == AC_WID_PIN &&\r\ncodec->pin_amp_workaround)\r\nprint_amp_vals(buffer, codec, nid, HDA_OUTPUT,\r\nwid_caps & AC_WCAP_STEREO,\r\nconn_len);\r\nelse\r\nprint_amp_vals(buffer, codec, nid, HDA_OUTPUT,\r\nwid_caps & AC_WCAP_STEREO, 1);\r\n}\r\nswitch (wid_type) {\r\ncase AC_WID_PIN: {\r\nint supports_vref;\r\nprint_pin_caps(buffer, codec, nid, &supports_vref);\r\nprint_pin_ctls(buffer, codec, nid, supports_vref);\r\nbreak;\r\n}\r\ncase AC_WID_VOL_KNB:\r\nprint_vol_knob(buffer, codec, nid);\r\nbreak;\r\ncase AC_WID_AUD_OUT:\r\ncase AC_WID_AUD_IN:\r\nprint_audio_io(buffer, codec, nid, wid_type);\r\nif (wid_caps & AC_WCAP_DIGITAL)\r\nprint_digital_conv(buffer, codec, nid);\r\nif (wid_caps & AC_WCAP_FORMAT_OVRD) {\r\nsnd_iprintf(buffer, " PCM:\n");\r\nprint_pcm_caps(buffer, codec, nid);\r\n}\r\nbreak;\r\n}\r\nif (wid_caps & AC_WCAP_UNSOL_CAP)\r\nprint_unsol_cap(buffer, codec, nid);\r\nif (wid_caps & AC_WCAP_POWER)\r\nprint_power_state(buffer, codec, nid);\r\nif (wid_caps & AC_WCAP_DELAY)\r\nsnd_iprintf(buffer, " Delay: %d samples\n",\r\n(wid_caps & AC_WCAP_DELAY) >>\r\nAC_WCAP_DELAY_SHIFT);\r\nif (wid_caps & AC_WCAP_CONN_LIST)\r\nprint_conn_list(buffer, codec, nid, wid_type,\r\nconn, conn_len);\r\nif (wid_caps & AC_WCAP_PROC_WID)\r\nprint_proc_caps(buffer, codec, nid);\r\nif (codec->proc_widget_hook)\r\ncodec->proc_widget_hook(buffer, codec, nid);\r\n}\r\nsnd_hda_power_down(codec);\r\n}\r\nint snd_hda_codec_proc_new(struct hda_codec *codec)\r\n{\r\nchar name[32];\r\nstruct snd_info_entry *entry;\r\nint err;\r\nsnprintf(name, sizeof(name), "codec#%d", codec->addr);\r\nerr = snd_card_proc_new(codec->bus->card, name, &entry);\r\nif (err < 0)\r\nreturn err;\r\nsnd_info_set_text_ops(entry, codec, print_codec_info);\r\nreturn 0;\r\n}
