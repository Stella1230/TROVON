static inline u32 mips_read32(struct ssb_mipscore *mcore,\r\nu16 offset)\r\n{\r\nreturn ssb_read32(mcore->dev, offset);\r\n}\r\nstatic inline void mips_write32(struct ssb_mipscore *mcore,\r\nu16 offset,\r\nu32 value)\r\n{\r\nssb_write32(mcore->dev, offset, value);\r\n}\r\nstatic inline u32 ssb_irqflag(struct ssb_device *dev)\r\n{\r\nu32 tpsflag = ssb_read32(dev, SSB_TPSFLAG);\r\nif (tpsflag)\r\nreturn ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;\r\nelse\r\nreturn 0x3f;\r\n}\r\nstatic struct ssb_device *find_device(struct ssb_device *rdev, int irqflag)\r\n{\r\nstruct ssb_bus *bus = rdev->bus;\r\nint i;\r\nfor (i = 0; i < bus->nr_devices; i++) {\r\nstruct ssb_device *dev;\r\ndev = &(bus->devices[i]);\r\nif (ssb_irqflag(dev) == irqflag)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nunsigned int ssb_mips_irq(struct ssb_device *dev)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nstruct ssb_device *mdev = bus->mipscore.dev;\r\nu32 irqflag;\r\nu32 ipsflag;\r\nu32 tmp;\r\nunsigned int irq;\r\nirqflag = ssb_irqflag(dev);\r\nif (irqflag == 0x3f)\r\nreturn 6;\r\nipsflag = ssb_read32(bus->mipscore.dev, SSB_IPSFLAG);\r\nfor (irq = 1; irq <= 4; irq++) {\r\ntmp = ((ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq]);\r\nif (tmp == irqflag)\r\nbreak;\r\n}\r\nif (irq == 5) {\r\nif ((1 << irqflag) & ssb_read32(mdev, SSB_INTVEC))\r\nirq = 0;\r\n}\r\nreturn irq;\r\n}\r\nstatic void clear_irq(struct ssb_bus *bus, unsigned int irq)\r\n{\r\nstruct ssb_device *dev = bus->mipscore.dev;\r\nif (irq == 0) {\r\nssb_write32(dev, SSB_INTVEC, 0);\r\n} else {\r\nssb_write32(dev, SSB_IPSFLAG,\r\nssb_read32(dev, SSB_IPSFLAG) |\r\nipsflag_irq_mask[irq]);\r\n}\r\n}\r\nstatic void set_irq(struct ssb_device *dev, unsigned int irq)\r\n{\r\nunsigned int oldirq = ssb_mips_irq(dev);\r\nstruct ssb_bus *bus = dev->bus;\r\nstruct ssb_device *mdev = bus->mipscore.dev;\r\nu32 irqflag = ssb_irqflag(dev);\r\nBUG_ON(oldirq == 6);\r\ndev->irq = irq + 2;\r\nif (oldirq == 0)\r\nssb_write32(mdev, SSB_INTVEC, (~(1 << irqflag) & ssb_read32(mdev, SSB_INTVEC)));\r\nelse if (oldirq != 5)\r\nclear_irq(bus, oldirq);\r\nif (irq == 0) {\r\nssb_write32(mdev, SSB_INTVEC, ((1 << irqflag) | ssb_read32(mdev, SSB_INTVEC)));\r\n} else {\r\nu32 ipsflag = ssb_read32(mdev, SSB_IPSFLAG);\r\nif ((ipsflag & ipsflag_irq_mask[irq]) != ipsflag_irq_mask[irq]) {\r\nu32 oldipsflag = (ipsflag & ipsflag_irq_mask[irq]) >> ipsflag_irq_shift[irq];\r\nstruct ssb_device *olddev = find_device(dev, oldipsflag);\r\nif (olddev)\r\nset_irq(olddev, 0);\r\n}\r\nirqflag <<= ipsflag_irq_shift[irq];\r\nirqflag |= (ipsflag & ~ipsflag_irq_mask[irq]);\r\nssb_write32(mdev, SSB_IPSFLAG, irqflag);\r\n}\r\nssb_dprintk(KERN_INFO PFX\r\n"set_irq: core 0x%04x, irq %d => %d\n",\r\ndev->id.coreid, oldirq+2, irq+2);\r\n}\r\nstatic void print_irq(struct ssb_device *dev, unsigned int irq)\r\n{\r\nint i;\r\nstatic const char *irq_name[] = {"2(S)", "3", "4", "5", "6", "D", "I"};\r\nssb_dprintk(KERN_INFO PFX\r\n"core 0x%04x, irq :", dev->id.coreid);\r\nfor (i = 0; i <= 6; i++) {\r\nssb_dprintk(" %s%s", irq_name[i], i==irq?"*":" ");\r\n}\r\nssb_dprintk("\n");\r\n}\r\nstatic void dump_irq(struct ssb_bus *bus)\r\n{\r\nint i;\r\nfor (i = 0; i < bus->nr_devices; i++) {\r\nstruct ssb_device *dev;\r\ndev = &(bus->devices[i]);\r\nprint_irq(dev, ssb_mips_irq(dev));\r\n}\r\n}\r\nstatic void ssb_mips_serial_init(struct ssb_mipscore *mcore)\r\n{\r\nstruct ssb_bus *bus = mcore->dev->bus;\r\nif (bus->extif.dev)\r\nmcore->nr_serial_ports = ssb_extif_serial_init(&bus->extif, mcore->serial_ports);\r\nelse if (bus->chipco.dev)\r\nmcore->nr_serial_ports = ssb_chipco_serial_init(&bus->chipco, mcore->serial_ports);\r\nelse\r\nmcore->nr_serial_ports = 0;\r\n}\r\nstatic void ssb_mips_flash_detect(struct ssb_mipscore *mcore)\r\n{\r\nstruct ssb_bus *bus = mcore->dev->bus;\r\nmcore->flash_buswidth = 2;\r\nif (bus->chipco.dev) {\r\nmcore->flash_window = 0x1c000000;\r\nmcore->flash_window_size = 0x02000000;\r\nif ((ssb_read32(bus->chipco.dev, SSB_CHIPCO_FLASH_CFG)\r\n& SSB_CHIPCO_CFG_DS16) == 0)\r\nmcore->flash_buswidth = 1;\r\n} else {\r\nmcore->flash_window = 0x1fc00000;\r\nmcore->flash_window_size = 0x00400000;\r\n}\r\n}\r\nu32 ssb_cpu_clock(struct ssb_mipscore *mcore)\r\n{\r\nstruct ssb_bus *bus = mcore->dev->bus;\r\nu32 pll_type, n, m, rate = 0;\r\nif (bus->chipco.capabilities & SSB_CHIPCO_CAP_PMU)\r\nreturn ssb_pmu_get_cpu_clock(&bus->chipco);\r\nif (bus->extif.dev) {\r\nssb_extif_get_clockcontrol(&bus->extif, &pll_type, &n, &m);\r\n} else if (bus->chipco.dev) {\r\nssb_chipco_get_clockcpu(&bus->chipco, &pll_type, &n, &m);\r\n} else\r\nreturn 0;\r\nif ((pll_type == SSB_PLLTYPE_5) || (bus->chip_id == 0x5365)) {\r\nrate = 200000000;\r\n} else {\r\nrate = ssb_calc_clock_rate(pll_type, n, m);\r\n}\r\nif (pll_type == SSB_PLLTYPE_6) {\r\nrate *= 2;\r\n}\r\nreturn rate;\r\n}\r\nvoid ssb_mipscore_init(struct ssb_mipscore *mcore)\r\n{\r\nstruct ssb_bus *bus;\r\nstruct ssb_device *dev;\r\nunsigned long hz, ns;\r\nunsigned int irq, i;\r\nif (!mcore->dev)\r\nreturn;\r\nssb_dprintk(KERN_INFO PFX "Initializing MIPS core...\n");\r\nbus = mcore->dev->bus;\r\nhz = ssb_clockspeed(bus);\r\nif (!hz)\r\nhz = 100000000;\r\nns = 1000000000 / hz;\r\nif (bus->extif.dev)\r\nssb_extif_timing_init(&bus->extif, ns);\r\nelse if (bus->chipco.dev)\r\nssb_chipco_timing_init(&bus->chipco, ns);\r\nfor (irq = 2, i = 0; i < bus->nr_devices; i++) {\r\nint mips_irq;\r\ndev = &(bus->devices[i]);\r\nmips_irq = ssb_mips_irq(dev);\r\nif (mips_irq > 4)\r\ndev->irq = 0;\r\nelse\r\ndev->irq = mips_irq + 2;\r\nif (dev->irq > 5)\r\ncontinue;\r\nswitch (dev->id.coreid) {\r\ncase SSB_DEV_USB11_HOST:\r\nif ((bus->chip_id == 0x4710) && (irq <= 4)) {\r\nset_irq(dev, irq++);\r\n}\r\nbreak;\r\ncase SSB_DEV_PCI:\r\ncase SSB_DEV_ETHERNET:\r\ncase SSB_DEV_ETHERNET_GBIT:\r\ncase SSB_DEV_80211:\r\ncase SSB_DEV_USB20_HOST:\r\nif (irq <= 4) {\r\nset_irq(dev, irq++);\r\nbreak;\r\n}\r\ncase SSB_DEV_EXTIF:\r\nset_irq(dev, 0);\r\nbreak;\r\n}\r\n}\r\nssb_dprintk(KERN_INFO PFX "after irq reconfiguration\n");\r\ndump_irq(bus);\r\nssb_mips_serial_init(mcore);\r\nssb_mips_flash_detect(mcore);\r\n}
