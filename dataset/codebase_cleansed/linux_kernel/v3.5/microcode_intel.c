static int collect_cpu_info(int cpu_num, struct cpu_signature *csig)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu_num);\r\nunsigned int val[2];\r\nmemset(csig, 0, sizeof(*csig));\r\ncsig->sig = cpuid_eax(0x00000001);\r\nif ((c->x86_model >= 5) || (c->x86 > 6)) {\r\nrdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);\r\ncsig->pf = 1 << ((val[1] >> 18) & 7);\r\n}\r\ncsig->rev = c->microcode;\r\npr_info("CPU%d sig=0x%x, pf=0x%x, revision=0x%x\n",\r\ncpu_num, csig->sig, csig->pf, csig->rev);\r\nreturn 0;\r\n}\r\nstatic inline int update_match_cpu(struct cpu_signature *csig, int sig, int pf)\r\n{\r\nreturn (!sigmatch(sig, csig->sig, pf, csig->pf)) ? 0 : 1;\r\n}\r\nstatic inline int\r\nupdate_match_revision(struct microcode_header_intel *mc_header, int rev)\r\n{\r\nreturn (mc_header->rev <= rev) ? 0 : 1;\r\n}\r\nstatic int microcode_sanity_check(void *mc)\r\n{\r\nunsigned long total_size, data_size, ext_table_size;\r\nstruct microcode_header_intel *mc_header = mc;\r\nstruct extended_sigtable *ext_header = NULL;\r\nint sum, orig_sum, ext_sigcount = 0, i;\r\nstruct extended_signature *ext_sig;\r\ntotal_size = get_totalsize(mc_header);\r\ndata_size = get_datasize(mc_header);\r\nif (data_size + MC_HEADER_SIZE > total_size) {\r\npr_err("error! Bad data size in microcode data file\n");\r\nreturn -EINVAL;\r\n}\r\nif (mc_header->ldrver != 1 || mc_header->hdrver != 1) {\r\npr_err("error! Unknown microcode update format\n");\r\nreturn -EINVAL;\r\n}\r\next_table_size = total_size - (MC_HEADER_SIZE + data_size);\r\nif (ext_table_size) {\r\nif ((ext_table_size < EXT_HEADER_SIZE)\r\n|| ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {\r\npr_err("error! Small exttable size in microcode data file\n");\r\nreturn -EINVAL;\r\n}\r\next_header = mc + MC_HEADER_SIZE + data_size;\r\nif (ext_table_size != exttable_size(ext_header)) {\r\npr_err("error! Bad exttable size in microcode data file\n");\r\nreturn -EFAULT;\r\n}\r\next_sigcount = ext_header->count;\r\n}\r\nif (ext_table_size) {\r\nint ext_table_sum = 0;\r\nint *ext_tablep = (int *)ext_header;\r\ni = ext_table_size / DWSIZE;\r\nwhile (i--)\r\next_table_sum += ext_tablep[i];\r\nif (ext_table_sum) {\r\npr_warning("aborting, bad extended signature table checksum\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\norig_sum = 0;\r\ni = (MC_HEADER_SIZE + data_size) / DWSIZE;\r\nwhile (i--)\r\norig_sum += ((int *)mc)[i];\r\nif (orig_sum) {\r\npr_err("aborting, bad checksum\n");\r\nreturn -EINVAL;\r\n}\r\nif (!ext_table_size)\r\nreturn 0;\r\nfor (i = 0; i < ext_sigcount; i++) {\r\next_sig = (void *)ext_header + EXT_HEADER_SIZE +\r\nEXT_SIGNATURE_SIZE * i;\r\nsum = orig_sum\r\n- (mc_header->sig + mc_header->pf + mc_header->cksum)\r\n+ (ext_sig->sig + ext_sig->pf + ext_sig->cksum);\r\nif (sum) {\r\npr_err("aborting, bad checksum\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nget_matching_microcode(struct cpu_signature *cpu_sig, void *mc, int rev)\r\n{\r\nstruct microcode_header_intel *mc_header = mc;\r\nstruct extended_sigtable *ext_header;\r\nunsigned long total_size = get_totalsize(mc_header);\r\nint ext_sigcount, i;\r\nstruct extended_signature *ext_sig;\r\nif (!update_match_revision(mc_header, rev))\r\nreturn 0;\r\nif (update_match_cpu(cpu_sig, mc_header->sig, mc_header->pf))\r\nreturn 1;\r\nif (total_size <= get_datasize(mc_header) + MC_HEADER_SIZE)\r\nreturn 0;\r\next_header = mc + get_datasize(mc_header) + MC_HEADER_SIZE;\r\next_sigcount = ext_header->count;\r\next_sig = (void *)ext_header + EXT_HEADER_SIZE;\r\nfor (i = 0; i < ext_sigcount; i++) {\r\nif (update_match_cpu(cpu_sig, ext_sig->sig, ext_sig->pf))\r\nreturn 1;\r\next_sig++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int apply_microcode(int cpu)\r\n{\r\nstruct microcode_intel *mc_intel;\r\nstruct ucode_cpu_info *uci;\r\nunsigned int val[2];\r\nint cpu_num = raw_smp_processor_id();\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu_num);\r\nuci = ucode_cpu_info + cpu;\r\nmc_intel = uci->mc;\r\nBUG_ON(cpu_num != cpu);\r\nif (mc_intel == NULL)\r\nreturn 0;\r\nwrmsr(MSR_IA32_UCODE_WRITE,\r\n(unsigned long) mc_intel->bits,\r\n(unsigned long) mc_intel->bits >> 16 >> 16);\r\nwrmsr(MSR_IA32_UCODE_REV, 0, 0);\r\nsync_core();\r\nrdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);\r\nif (val[1] != mc_intel->hdr.rev) {\r\npr_err("CPU%d update to revision 0x%x failed\n",\r\ncpu_num, mc_intel->hdr.rev);\r\nreturn -1;\r\n}\r\npr_info("CPU%d updated to revision 0x%x, date = %04x-%02x-%02x\n",\r\ncpu_num, val[1],\r\nmc_intel->hdr.date & 0xffff,\r\nmc_intel->hdr.date >> 24,\r\n(mc_intel->hdr.date >> 16) & 0xff);\r\nuci->cpu_sig.rev = val[1];\r\nc->microcode = val[1];\r\nreturn 0;\r\n}\r\nstatic enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,\r\nint (*get_ucode_data)(void *, const void *, size_t))\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nu8 *ucode_ptr = data, *new_mc = NULL, *mc = NULL;\r\nint new_rev = uci->cpu_sig.rev;\r\nunsigned int leftover = size;\r\nenum ucode_state state = UCODE_OK;\r\nunsigned int curr_mc_size = 0;\r\nwhile (leftover) {\r\nstruct microcode_header_intel mc_header;\r\nunsigned int mc_size;\r\nif (get_ucode_data(&mc_header, ucode_ptr, sizeof(mc_header)))\r\nbreak;\r\nmc_size = get_totalsize(&mc_header);\r\nif (!mc_size || mc_size > leftover) {\r\npr_err("error! Bad data in microcode data file\n");\r\nbreak;\r\n}\r\nif (!mc || mc_size > curr_mc_size) {\r\nvfree(mc);\r\nmc = vmalloc(mc_size);\r\nif (!mc)\r\nbreak;\r\ncurr_mc_size = mc_size;\r\n}\r\nif (get_ucode_data(mc, ucode_ptr, mc_size) ||\r\nmicrocode_sanity_check(mc) < 0) {\r\nbreak;\r\n}\r\nif (get_matching_microcode(&uci->cpu_sig, mc, new_rev)) {\r\nvfree(new_mc);\r\nnew_rev = mc_header.rev;\r\nnew_mc = mc;\r\nmc = NULL;\r\n}\r\nucode_ptr += mc_size;\r\nleftover -= mc_size;\r\n}\r\nvfree(mc);\r\nif (leftover) {\r\nvfree(new_mc);\r\nstate = UCODE_ERROR;\r\ngoto out;\r\n}\r\nif (!new_mc) {\r\nstate = UCODE_NFOUND;\r\ngoto out;\r\n}\r\nvfree(uci->mc);\r\nuci->mc = (struct microcode_intel *)new_mc;\r\npr_debug("CPU%d found a matching microcode update with version 0x%x (current=0x%x)\n",\r\ncpu, new_rev, uci->cpu_sig.rev);\r\nout:\r\nreturn state;\r\n}\r\nstatic int get_ucode_fw(void *to, const void *from, size_t n)\r\n{\r\nmemcpy(to, from, n);\r\nreturn 0;\r\n}\r\nstatic enum ucode_state request_microcode_fw(int cpu, struct device *device)\r\n{\r\nchar name[30];\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nconst struct firmware *firmware;\r\nenum ucode_state ret;\r\nsprintf(name, "intel-ucode/%02x-%02x-%02x",\r\nc->x86, c->x86_model, c->x86_mask);\r\nif (request_firmware(&firmware, name, device)) {\r\npr_debug("data file %s load failed\n", name);\r\nreturn UCODE_NFOUND;\r\n}\r\nret = generic_load_microcode(cpu, (void *)firmware->data,\r\nfirmware->size, &get_ucode_fw);\r\nrelease_firmware(firmware);\r\nreturn ret;\r\n}\r\nstatic int get_ucode_user(void *to, const void *from, size_t n)\r\n{\r\nreturn copy_from_user(to, from, n);\r\n}\r\nstatic enum ucode_state\r\nrequest_microcode_user(int cpu, const void __user *buf, size_t size)\r\n{\r\nreturn generic_load_microcode(cpu, (void *)buf, size, &get_ucode_user);\r\n}\r\nstatic void microcode_fini_cpu(int cpu)\r\n{\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nvfree(uci->mc);\r\nuci->mc = NULL;\r\n}\r\nstruct microcode_ops * __init init_intel_microcode(void)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(0);\r\nif (c->x86_vendor != X86_VENDOR_INTEL || c->x86 < 6 ||\r\ncpu_has(c, X86_FEATURE_IA64)) {\r\npr_err("Intel CPU family 0x%x not supported\n", c->x86);\r\nreturn NULL;\r\n}\r\nreturn &microcode_intel_ops;\r\n}
