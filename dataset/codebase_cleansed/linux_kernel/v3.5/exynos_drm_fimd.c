static bool fimd_display_is_connected(struct device *dev)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn true;\r\n}\r\nstatic void *fimd_get_panel(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn ctx->panel;\r\n}\r\nstatic int fimd_check_timing(struct device *dev, void *timing)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn 0;\r\n}\r\nstatic int fimd_display_power_on(struct device *dev, int mode)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn 0;\r\n}\r\nstatic void fimd_dpms(struct device *subdrv_dev, int mode)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(subdrv_dev);\r\nDRM_DEBUG_KMS("%s, %d\n", __FILE__, mode);\r\nmutex_lock(&ctx->lock);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nif (ctx->suspended)\r\npm_runtime_get_sync(subdrv_dev);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nif (!ctx->suspended)\r\npm_runtime_put_sync(subdrv_dev);\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("unspecified mode %d\n", mode);\r\nbreak;\r\n}\r\nmutex_unlock(&ctx->lock);\r\n}\r\nstatic void fimd_apply(struct device *subdrv_dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(subdrv_dev);\r\nstruct exynos_drm_manager *mgr = ctx->subdrv.manager;\r\nstruct exynos_drm_manager_ops *mgr_ops = mgr->ops;\r\nstruct exynos_drm_overlay_ops *ovl_ops = mgr->overlay_ops;\r\nstruct fimd_win_data *win_data;\r\nint i;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nfor (i = 0; i < WINDOWS_NR; i++) {\r\nwin_data = &ctx->win_data[i];\r\nif (win_data->enabled && (ovl_ops && ovl_ops->commit))\r\novl_ops->commit(subdrv_dev, i);\r\n}\r\nif (mgr_ops && mgr_ops->commit)\r\nmgr_ops->commit(subdrv_dev);\r\n}\r\nstatic void fimd_commit(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nstruct exynos_drm_panel_info *panel = ctx->panel;\r\nstruct fb_videomode *timing = &panel->timing;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nwritel(ctx->vidcon1, ctx->regs + VIDCON1);\r\nval = VIDTCON0_VBPD(timing->upper_margin - 1) |\r\nVIDTCON0_VFPD(timing->lower_margin - 1) |\r\nVIDTCON0_VSPW(timing->vsync_len - 1);\r\nwritel(val, ctx->regs + VIDTCON0);\r\nval = VIDTCON1_HBPD(timing->left_margin - 1) |\r\nVIDTCON1_HFPD(timing->right_margin - 1) |\r\nVIDTCON1_HSPW(timing->hsync_len - 1);\r\nwritel(val, ctx->regs + VIDTCON1);\r\nval = VIDTCON2_LINEVAL(timing->yres - 1) |\r\nVIDTCON2_HOZVAL(timing->xres - 1);\r\nwritel(val, ctx->regs + VIDTCON2);\r\nval = ctx->vidcon0;\r\nval &= ~(VIDCON0_CLKVAL_F_MASK | VIDCON0_CLKDIR);\r\nif (ctx->clkdiv > 1)\r\nval |= VIDCON0_CLKVAL_F(ctx->clkdiv - 1) | VIDCON0_CLKDIR;\r\nelse\r\nval &= ~VIDCON0_CLKDIR;\r\nval |= VIDCON0_ENVID | VIDCON0_ENVID_F;\r\nwritel(val, ctx->regs + VIDCON0);\r\n}\r\nstatic int fimd_enable_vblank(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nu32 val;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn -EPERM;\r\nif (!test_and_set_bit(0, &ctx->irq_flags)) {\r\nval = readl(ctx->regs + VIDINTCON0);\r\nval |= VIDINTCON0_INT_ENABLE;\r\nval |= VIDINTCON0_INT_FRAME;\r\nval &= ~VIDINTCON0_FRAMESEL0_MASK;\r\nval |= VIDINTCON0_FRAMESEL0_VSYNC;\r\nval &= ~VIDINTCON0_FRAMESEL1_MASK;\r\nval |= VIDINTCON0_FRAMESEL1_NONE;\r\nwritel(val, ctx->regs + VIDINTCON0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fimd_disable_vblank(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nu32 val;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn;\r\nif (test_and_clear_bit(0, &ctx->irq_flags)) {\r\nval = readl(ctx->regs + VIDINTCON0);\r\nval &= ~VIDINTCON0_INT_FRAME;\r\nval &= ~VIDINTCON0_INT_ENABLE;\r\nwritel(val, ctx->regs + VIDINTCON0);\r\n}\r\n}\r\nstatic void fimd_win_mode_set(struct device *dev,\r\nstruct exynos_drm_overlay *overlay)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nstruct fimd_win_data *win_data;\r\nint win;\r\nunsigned long offset;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (!overlay) {\r\ndev_err(dev, "overlay is NULL\n");\r\nreturn;\r\n}\r\nwin = overlay->zpos;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win > WINDOWS_NR)\r\nreturn;\r\noffset = overlay->fb_x * (overlay->bpp >> 3);\r\noffset += overlay->fb_y * overlay->pitch;\r\nDRM_DEBUG_KMS("offset = 0x%lx, pitch = %x\n", offset, overlay->pitch);\r\nwin_data = &ctx->win_data[win];\r\nwin_data->offset_x = overlay->crtc_x;\r\nwin_data->offset_y = overlay->crtc_y;\r\nwin_data->ovl_width = overlay->crtc_width;\r\nwin_data->ovl_height = overlay->crtc_height;\r\nwin_data->fb_width = overlay->fb_width;\r\nwin_data->fb_height = overlay->fb_height;\r\nwin_data->dma_addr = overlay->dma_addr[0] + offset;\r\nwin_data->vaddr = overlay->vaddr[0] + offset;\r\nwin_data->bpp = overlay->bpp;\r\nwin_data->buf_offsize = (overlay->fb_width - overlay->crtc_width) *\r\n(overlay->bpp >> 3);\r\nwin_data->line_size = overlay->crtc_width * (overlay->bpp >> 3);\r\nDRM_DEBUG_KMS("offset_x = %d, offset_y = %d\n",\r\nwin_data->offset_x, win_data->offset_y);\r\nDRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",\r\nwin_data->ovl_width, win_data->ovl_height);\r\nDRM_DEBUG_KMS("paddr = 0x%lx, vaddr = 0x%lx\n",\r\n(unsigned long)win_data->dma_addr,\r\n(unsigned long)win_data->vaddr);\r\nDRM_DEBUG_KMS("fb_width = %d, crtc_width = %d\n",\r\noverlay->fb_width, overlay->crtc_width);\r\n}\r\nstatic void fimd_win_set_pixfmt(struct device *dev, unsigned int win)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nstruct fimd_win_data *win_data = &ctx->win_data[win];\r\nunsigned long val;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nval = WINCONx_ENWIN;\r\nswitch (win_data->bpp) {\r\ncase 1:\r\nval |= WINCON0_BPPMODE_1BPP;\r\nval |= WINCONx_BITSWP;\r\nval |= WINCONx_BURSTLEN_4WORD;\r\nbreak;\r\ncase 2:\r\nval |= WINCON0_BPPMODE_2BPP;\r\nval |= WINCONx_BITSWP;\r\nval |= WINCONx_BURSTLEN_8WORD;\r\nbreak;\r\ncase 4:\r\nval |= WINCON0_BPPMODE_4BPP;\r\nval |= WINCONx_BITSWP;\r\nval |= WINCONx_BURSTLEN_8WORD;\r\nbreak;\r\ncase 8:\r\nval |= WINCON0_BPPMODE_8BPP_PALETTE;\r\nval |= WINCONx_BURSTLEN_8WORD;\r\nval |= WINCONx_BYTSWP;\r\nbreak;\r\ncase 16:\r\nval |= WINCON0_BPPMODE_16BPP_565;\r\nval |= WINCONx_HAWSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase 24:\r\nval |= WINCON0_BPPMODE_24BPP_888;\r\nval |= WINCONx_WSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase 32:\r\nval |= WINCON1_BPPMODE_28BPP_A4888\r\n| WINCON1_BLD_PIX | WINCON1_ALPHA_SEL;\r\nval |= WINCONx_WSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid pixel size so using unpacked 24bpp.\n");\r\nval |= WINCON0_BPPMODE_24BPP_888;\r\nval |= WINCONx_WSWP;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("bpp = %d\n", win_data->bpp);\r\nwritel(val, ctx->regs + WINCON(win));\r\n}\r\nstatic void fimd_win_set_colkey(struct device *dev, unsigned int win)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nunsigned int keycon0 = 0, keycon1 = 0;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nkeycon0 = ~(WxKEYCON0_KEYBL_EN | WxKEYCON0_KEYEN_F |\r\nWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\r\nkeycon1 = WxKEYCON1_COLVAL(0xffffffff);\r\nwritel(keycon0, ctx->regs + WKEYCON0_BASE(win));\r\nwritel(keycon1, ctx->regs + WKEYCON1_BASE(win));\r\n}\r\nstatic void fimd_win_commit(struct device *dev, int zpos)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nstruct fimd_win_data *win_data;\r\nint win = zpos;\r\nunsigned long val, alpha, size;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (ctx->suspended)\r\nreturn;\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win > WINDOWS_NR)\r\nreturn;\r\nwin_data = &ctx->win_data[win];\r\nval = readl(ctx->regs + SHADOWCON);\r\nval |= SHADOWCON_WINx_PROTECT(win);\r\nwritel(val, ctx->regs + SHADOWCON);\r\nval = (unsigned long)win_data->dma_addr;\r\nwritel(val, ctx->regs + VIDWx_BUF_START(win, 0));\r\nsize = win_data->fb_width * win_data->ovl_height * (win_data->bpp >> 3);\r\nval = (unsigned long)(win_data->dma_addr + size);\r\nwritel(val, ctx->regs + VIDWx_BUF_END(win, 0));\r\nDRM_DEBUG_KMS("start addr = 0x%lx, end addr = 0x%lx, size = 0x%lx\n",\r\n(unsigned long)win_data->dma_addr, val, size);\r\nDRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",\r\nwin_data->ovl_width, win_data->ovl_height);\r\nval = VIDW_BUF_SIZE_OFFSET(win_data->buf_offsize) |\r\nVIDW_BUF_SIZE_PAGEWIDTH(win_data->line_size);\r\nwritel(val, ctx->regs + VIDWx_BUF_SIZE(win, 0));\r\nval = VIDOSDxA_TOPLEFT_X(win_data->offset_x) |\r\nVIDOSDxA_TOPLEFT_Y(win_data->offset_y);\r\nwritel(val, ctx->regs + VIDOSD_A(win));\r\nval = VIDOSDxB_BOTRIGHT_X(win_data->offset_x +\r\nwin_data->ovl_width - 1) |\r\nVIDOSDxB_BOTRIGHT_Y(win_data->offset_y +\r\nwin_data->ovl_height - 1);\r\nwritel(val, ctx->regs + VIDOSD_B(win));\r\nDRM_DEBUG_KMS("osd pos: tx = %d, ty = %d, bx = %d, by = %d\n",\r\nwin_data->offset_x, win_data->offset_y,\r\nwin_data->offset_x + win_data->ovl_width - 1,\r\nwin_data->offset_y + win_data->ovl_height - 1);\r\nif (win != 0) {\r\nalpha = VIDISD14C_ALPHA1_R(0xf) |\r\nVIDISD14C_ALPHA1_G(0xf) |\r\nVIDISD14C_ALPHA1_B(0xf);\r\nwritel(alpha, ctx->regs + VIDOSD_C(win));\r\n}\r\nif (win != 3 && win != 4) {\r\nu32 offset = VIDOSD_D(win);\r\nif (win == 0)\r\noffset = VIDOSD_C_SIZE_W0;\r\nval = win_data->ovl_width * win_data->ovl_height;\r\nwritel(val, ctx->regs + offset);\r\nDRM_DEBUG_KMS("osd size = 0x%x\n", (unsigned int)val);\r\n}\r\nfimd_win_set_pixfmt(dev, win);\r\nif (win != 0)\r\nfimd_win_set_colkey(dev, win);\r\nval = readl(ctx->regs + WINCON(win));\r\nval |= WINCONx_ENWIN;\r\nwritel(val, ctx->regs + WINCON(win));\r\nval = readl(ctx->regs + SHADOWCON);\r\nval |= SHADOWCON_CHx_ENABLE(win);\r\nval &= ~SHADOWCON_WINx_PROTECT(win);\r\nwritel(val, ctx->regs + SHADOWCON);\r\nwin_data->enabled = true;\r\n}\r\nstatic void fimd_win_disable(struct device *dev, int zpos)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nstruct fimd_win_data *win_data;\r\nint win = zpos;\r\nu32 val;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (win == DEFAULT_ZPOS)\r\nwin = ctx->default_win;\r\nif (win < 0 || win > WINDOWS_NR)\r\nreturn;\r\nwin_data = &ctx->win_data[win];\r\nval = readl(ctx->regs + SHADOWCON);\r\nval |= SHADOWCON_WINx_PROTECT(win);\r\nwritel(val, ctx->regs + SHADOWCON);\r\nval = readl(ctx->regs + WINCON(win));\r\nval &= ~WINCONx_ENWIN;\r\nwritel(val, ctx->regs + WINCON(win));\r\nval = readl(ctx->regs + SHADOWCON);\r\nval &= ~SHADOWCON_CHx_ENABLE(win);\r\nval &= ~SHADOWCON_WINx_PROTECT(win);\r\nwritel(val, ctx->regs + SHADOWCON);\r\nwin_data->enabled = false;\r\n}\r\nstatic void fimd_finish_pageflip(struct drm_device *drm_dev, int crtc)\r\n{\r\nstruct exynos_drm_private *dev_priv = drm_dev->dev_private;\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct timeval now;\r\nunsigned long flags;\r\nbool is_checked = false;\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nlist_for_each_entry_safe(e, t, &dev_priv->pageflip_event_list,\r\nbase.link) {\r\nif (crtc != e->pipe)\r\ncontinue;\r\nis_checked = true;\r\ndo_gettimeofday(&now);\r\ne->event.sequence = 0;\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\nlist_move_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\n}\r\nif (is_checked) {\r\nif (atomic_read(&drm_dev->vblank_refcount[crtc]) > 0)\r\ndrm_vblank_put(drm_dev, crtc);\r\nif (!drm_dev->vblank_disable_allowed)\r\ndrm_vblank_off(drm_dev, crtc);\r\n}\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\n}\r\nstatic irqreturn_t fimd_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct fimd_context *ctx = (struct fimd_context *)dev_id;\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct drm_device *drm_dev = subdrv->drm_dev;\r\nstruct exynos_drm_manager *manager = subdrv->manager;\r\nu32 val;\r\nval = readl(ctx->regs + VIDINTCON1);\r\nif (val & VIDINTCON1_INT_FRAME)\r\nwritel(VIDINTCON1_INT_FRAME, ctx->regs + VIDINTCON1);\r\nif (manager->pipe < 0)\r\ngoto out;\r\ndrm_handle_vblank(drm_dev, manager->pipe);\r\nfimd_finish_pageflip(drm_dev, manager->pipe);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fimd_subdrv_probe(struct drm_device *drm_dev, struct device *dev)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\ndrm_dev->irq_enabled = 1;\r\ndrm_dev->vblank_disable_allowed = 1;\r\nreturn 0;\r\n}\r\nstatic void fimd_subdrv_remove(struct drm_device *drm_dev)\r\n{\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\n}\r\nstatic int fimd_calc_clkdiv(struct fimd_context *ctx,\r\nstruct fb_videomode *timing)\r\n{\r\nunsigned long clk = clk_get_rate(ctx->lcd_clk);\r\nu32 retrace;\r\nu32 clkdiv;\r\nu32 best_framerate = 0;\r\nu32 framerate;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nretrace = timing->left_margin + timing->hsync_len +\r\ntiming->right_margin + timing->xres;\r\nretrace *= timing->upper_margin + timing->vsync_len +\r\ntiming->lower_margin + timing->yres;\r\nif (!timing->refresh)\r\ntiming->refresh = 60;\r\nclk /= retrace;\r\nfor (clkdiv = 1; clkdiv < 0x100; clkdiv++) {\r\nint tmp;\r\nframerate = clk / clkdiv;\r\ntmp = timing->refresh - framerate;\r\nif (tmp < 0) {\r\nbest_framerate = framerate;\r\ncontinue;\r\n} else {\r\nif (!best_framerate)\r\nbest_framerate = framerate;\r\nelse if (tmp < (best_framerate - framerate))\r\nbest_framerate = framerate;\r\nbreak;\r\n}\r\n}\r\nreturn clkdiv;\r\n}\r\nstatic void fimd_clear_win(struct fimd_context *ctx, int win)\r\n{\r\nu32 val;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nwritel(0, ctx->regs + WINCON(win));\r\nwritel(0, ctx->regs + VIDOSD_A(win));\r\nwritel(0, ctx->regs + VIDOSD_B(win));\r\nwritel(0, ctx->regs + VIDOSD_C(win));\r\nif (win == 1 || win == 2)\r\nwritel(0, ctx->regs + VIDOSD_D(win));\r\nval = readl(ctx->regs + SHADOWCON);\r\nval &= ~SHADOWCON_WINx_PROTECT(win);\r\nwritel(val, ctx->regs + SHADOWCON);\r\n}\r\nstatic int fimd_power_on(struct fimd_context *ctx, bool enable)\r\n{\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct device *dev = subdrv->dev;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nif (enable != false && enable != true)\r\nreturn -EINVAL;\r\nif (enable) {\r\nint ret;\r\nret = clk_enable(ctx->bus_clk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_enable(ctx->lcd_clk);\r\nif (ret < 0) {\r\nclk_disable(ctx->bus_clk);\r\nreturn ret;\r\n}\r\nctx->suspended = false;\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\nfimd_enable_vblank(dev);\r\nfimd_apply(dev);\r\n} else {\r\nclk_disable(ctx->lcd_clk);\r\nclk_disable(ctx->bus_clk);\r\nctx->suspended = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit fimd_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimd_context *ctx;\r\nstruct exynos_drm_subdrv *subdrv;\r\nstruct exynos_drm_fimd_pdata *pdata;\r\nstruct exynos_drm_panel_info *panel;\r\nstruct resource *res;\r\nint win;\r\nint ret = -EINVAL;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(dev, "no platform data specified\n");\r\nreturn -EINVAL;\r\n}\r\npanel = &pdata->panel;\r\nif (!panel) {\r\ndev_err(dev, "panel is null.\n");\r\nreturn -EINVAL;\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->bus_clk = clk_get(dev, "fimd");\r\nif (IS_ERR(ctx->bus_clk)) {\r\ndev_err(dev, "failed to get bus clock\n");\r\nret = PTR_ERR(ctx->bus_clk);\r\ngoto err_clk_get;\r\n}\r\nctx->lcd_clk = clk_get(dev, "sclk_fimd");\r\nif (IS_ERR(ctx->lcd_clk)) {\r\ndev_err(dev, "failed to get lcd clock\n");\r\nret = PTR_ERR(ctx->lcd_clk);\r\ngoto err_bus_clk;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "failed to find registers\n");\r\nret = -ENOENT;\r\ngoto err_clk;\r\n}\r\nctx->regs_res = request_mem_region(res->start, resource_size(res),\r\ndev_name(dev));\r\nif (!ctx->regs_res) {\r\ndev_err(dev, "failed to claim register region\n");\r\nret = -ENOENT;\r\ngoto err_clk;\r\n}\r\nctx->regs = ioremap(res->start, resource_size(res));\r\nif (!ctx->regs) {\r\ndev_err(dev, "failed to map registers\n");\r\nret = -ENXIO;\r\ngoto err_req_region_io;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "irq request failed.\n");\r\ngoto err_req_region_irq;\r\n}\r\nctx->irq = res->start;\r\nret = request_irq(ctx->irq, fimd_irq_handler, 0, "drm_fimd", ctx);\r\nif (ret < 0) {\r\ndev_err(dev, "irq request failed.\n");\r\ngoto err_req_irq;\r\n}\r\nctx->vidcon0 = pdata->vidcon0;\r\nctx->vidcon1 = pdata->vidcon1;\r\nctx->default_win = pdata->default_win;\r\nctx->panel = panel;\r\nsubdrv = &ctx->subdrv;\r\nsubdrv->dev = dev;\r\nsubdrv->manager = &fimd_manager;\r\nsubdrv->probe = fimd_subdrv_probe;\r\nsubdrv->remove = fimd_subdrv_remove;\r\nmutex_init(&ctx->lock);\r\nplatform_set_drvdata(pdev, ctx);\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nctx->clkdiv = fimd_calc_clkdiv(ctx, &panel->timing);\r\npanel->timing.pixclock = clk_get_rate(ctx->lcd_clk) / ctx->clkdiv;\r\nDRM_DEBUG_KMS("pixel clock = %d, clkdiv = %d\n",\r\npanel->timing.pixclock, ctx->clkdiv);\r\nfor (win = 0; win < WINDOWS_NR; win++)\r\nfimd_clear_win(ctx, win);\r\nexynos_drm_subdrv_register(subdrv);\r\nreturn 0;\r\nerr_req_irq:\r\nerr_req_region_irq:\r\niounmap(ctx->regs);\r\nerr_req_region_io:\r\nrelease_resource(ctx->regs_res);\r\nkfree(ctx->regs_res);\r\nerr_clk:\r\nclk_disable(ctx->lcd_clk);\r\nclk_put(ctx->lcd_clk);\r\nerr_bus_clk:\r\nclk_disable(ctx->bus_clk);\r\nclk_put(ctx->bus_clk);\r\nerr_clk_get:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int __devexit fimd_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimd_context *ctx = platform_get_drvdata(pdev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nexynos_drm_subdrv_unregister(&ctx->subdrv);\r\nif (ctx->suspended)\r\ngoto out;\r\nclk_disable(ctx->lcd_clk);\r\nclk_disable(ctx->bus_clk);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_put_sync(dev);\r\nout:\r\npm_runtime_disable(dev);\r\nclk_put(ctx->lcd_clk);\r\nclk_put(ctx->bus_clk);\r\niounmap(ctx->regs);\r\nrelease_resource(ctx->regs_res);\r\nkfree(ctx->regs_res);\r\nfree_irq(ctx->irq, ctx);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic int fimd_suspend(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nreturn fimd_power_on(ctx, false);\r\n}\r\nstatic int fimd_resume(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nif (!pm_runtime_suspended(dev))\r\nreturn fimd_power_on(ctx, true);\r\nreturn 0;\r\n}\r\nstatic int fimd_runtime_suspend(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn fimd_power_on(ctx, false);\r\n}\r\nstatic int fimd_runtime_resume(struct device *dev)\r\n{\r\nstruct fimd_context *ctx = get_fimd_context(dev);\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nreturn fimd_power_on(ctx, true);\r\n}
