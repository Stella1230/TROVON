int\r\nnv50_calc_pll(struct drm_device *dev, struct pll_lims *pll, int clk,\r\nint *N1, int *M1, int *N2, int *M2, int *P)\r\n{\r\nstruct nouveau_pll_vals pll_vals;\r\nint ret;\r\nret = nouveau_calc_pll_mnp(dev, pll, clk, &pll_vals);\r\nif (ret <= 0)\r\nreturn ret;\r\n*N1 = pll_vals.N1;\r\n*M1 = pll_vals.M1;\r\n*N2 = pll_vals.N2;\r\n*M2 = pll_vals.M2;\r\n*P = pll_vals.log2P;\r\nreturn ret;\r\n}\r\nint\r\nnva3_calc_pll(struct drm_device *dev, struct pll_lims *pll, int clk,\r\nint *pN, int *pfN, int *pM, int *P)\r\n{\r\nu32 best_err = ~0, err;\r\nint M, lM, hM, N, fN;\r\n*P = pll->vco1.maxfreq / clk;\r\nif (*P > pll->max_p)\r\n*P = pll->max_p;\r\nif (*P < pll->min_p)\r\n*P = pll->min_p;\r\nlM = (pll->refclk + pll->vco1.max_inputfreq) / pll->vco1.max_inputfreq;\r\nlM = max(lM, (int)pll->vco1.min_m);\r\nhM = (pll->refclk + pll->vco1.min_inputfreq) / pll->vco1.min_inputfreq;\r\nhM = min(hM, (int)pll->vco1.max_m);\r\nfor (M = lM; M <= hM; M++) {\r\nu32 tmp = clk * *P * M;\r\nN = tmp / pll->refclk;\r\nfN = tmp % pll->refclk;\r\nif (!pfN && fN >= pll->refclk / 2)\r\nN++;\r\nif (N < pll->vco1.min_n)\r\ncontinue;\r\nif (N > pll->vco1.max_n)\r\nbreak;\r\nerr = abs(clk - (pll->refclk * N / M / *P));\r\nif (err < best_err) {\r\nbest_err = err;\r\n*pN = N;\r\n*pM = M;\r\n}\r\nif (pfN) {\r\n*pfN = (((fN << 13) / pll->refclk) - 4096) & 0xffff;\r\nreturn clk;\r\n}\r\n}\r\nif (unlikely(best_err == ~0)) {\r\nNV_ERROR(dev, "unable to find matching pll values\n");\r\nreturn -EINVAL;\r\n}\r\nreturn pll->refclk * *pN / *pM / *P;\r\n}
