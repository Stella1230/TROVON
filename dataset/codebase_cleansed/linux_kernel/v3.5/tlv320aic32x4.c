static inline int aic32x4_change_page(struct snd_soc_codec *codec,\r\nunsigned int new_page)\r\n{\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nu8 data[2];\r\nint ret;\r\ndata[0] = 0x00;\r\ndata[1] = new_page & 0xff;\r\nret = codec->hw_write(codec->control_data, data, 2);\r\nif (ret == 2) {\r\naic32x4->page_no = new_page;\r\nreturn 0;\r\n} else {\r\nreturn ret;\r\n}\r\n}\r\nstatic int aic32x4_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int page = reg / 128;\r\nunsigned int fixed_reg = reg % 128;\r\nu8 data[2];\r\nint ret;\r\nif (reg == AIC32X4_PSEL)\r\nreturn aic32x4_change_page(codec, val);\r\nif (aic32x4->page_no != page) {\r\nret = aic32x4_change_page(codec, page);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ndata[0] = fixed_reg & 0xff;\r\ndata[1] = val & 0xff;\r\nif (codec->hw_write(codec->control_data, data, 2) == 2)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic unsigned int aic32x4_read(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int page = reg / 128;\r\nunsigned int fixed_reg = reg % 128;\r\nint ret;\r\nif (aic32x4->page_no != page) {\r\nret = aic32x4_change_page(codec, page);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nreturn i2c_smbus_read_byte_data(codec->control_data, fixed_reg & 0xff);\r\n}\r\nstatic inline int aic32x4_get_divs(int mclk, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(aic32x4_divs); i++) {\r\nif ((aic32x4_divs[i].rate == rate)\r\n&& (aic32x4_divs[i].mclk == mclk)) {\r\nreturn i;\r\n}\r\n}\r\nprintk(KERN_ERR "aic32x4: master clock and sample rate is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int aic32x4_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_dapm_new_controls(&codec->dapm, aic32x4_dapm_widgets,\r\nARRAY_SIZE(aic32x4_dapm_widgets));\r\nsnd_soc_dapm_add_routes(&codec->dapm, aic32x4_dapm_routes,\r\nARRAY_SIZE(aic32x4_dapm_routes));\r\nsnd_soc_dapm_new_widgets(&codec->dapm);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase AIC32X4_FREQ_12000000:\r\ncase AIC32X4_FREQ_24000000:\r\ncase AIC32X4_FREQ_25000000:\r\naic32x4->sysclk = freq;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "aic32x4: invalid frequency to set DAI system clock\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int aic32x4_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 iface_reg_1;\r\nu8 iface_reg_2;\r\nu8 iface_reg_3;\r\niface_reg_1 = snd_soc_read(codec, AIC32X4_IFACE1);\r\niface_reg_1 = iface_reg_1 & ~(3 << 6 | 3 << 2);\r\niface_reg_2 = snd_soc_read(codec, AIC32X4_IFACE2);\r\niface_reg_2 = 0;\r\niface_reg_3 = snd_soc_read(codec, AIC32X4_IFACE3);\r\niface_reg_3 = iface_reg_3 & ~(1 << 3);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface_reg_1 |= AIC32X4_BCLKMASTER | AIC32X4_WCLKMASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aic32x4: invalid DAI master/slave interface\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface_reg_1 |= (AIC32X4_DSP_MODE << AIC32X4_PLLJ_SHIFT);\r\niface_reg_3 |= (1 << 3);\r\niface_reg_2 = 0x01;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface_reg_1 |= (AIC32X4_DSP_MODE << AIC32X4_PLLJ_SHIFT);\r\niface_reg_3 |= (1 << 3);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\niface_reg_1 |=\r\n(AIC32X4_RIGHT_JUSTIFIED_MODE << AIC32X4_PLLJ_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface_reg_1 |=\r\n(AIC32X4_LEFT_JUSTIFIED_MODE << AIC32X4_PLLJ_SHIFT);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aic32x4: invalid DAI interface format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, AIC32X4_IFACE1, iface_reg_1);\r\nsnd_soc_write(codec, AIC32X4_IFACE2, iface_reg_2);\r\nsnd_soc_write(codec, AIC32X4_IFACE3, iface_reg_3);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nu8 data;\r\nint i;\r\ni = aic32x4_get_divs(aic32x4->sysclk, params_rate(params));\r\nif (i < 0) {\r\nprintk(KERN_ERR "aic32x4: sampling rate not supported\n");\r\nreturn i;\r\n}\r\nsnd_soc_write(codec, AIC32X4_CLKMUX, AIC32X4_PLLCLKIN);\r\nsnd_soc_write(codec, AIC32X4_IFACE3, AIC32X4_DACMOD2BCLK);\r\ndata = snd_soc_read(codec, AIC32X4_PLLPR);\r\ndata &= ~(7 << 4);\r\nsnd_soc_write(codec, AIC32X4_PLLPR,\r\n(data | (aic32x4_divs[i].p_val << 4) | 0x01));\r\nsnd_soc_write(codec, AIC32X4_PLLJ, aic32x4_divs[i].pll_j);\r\nsnd_soc_write(codec, AIC32X4_PLLDMSB, (aic32x4_divs[i].pll_d >> 8));\r\nsnd_soc_write(codec, AIC32X4_PLLDLSB,\r\n(aic32x4_divs[i].pll_d & 0xff));\r\ndata = snd_soc_read(codec, AIC32X4_NDAC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_NDAC, data | aic32x4_divs[i].ndac);\r\ndata = snd_soc_read(codec, AIC32X4_MDAC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_MDAC, data | aic32x4_divs[i].mdac);\r\nsnd_soc_write(codec, AIC32X4_DOSRMSB, aic32x4_divs[i].dosr >> 8);\r\nsnd_soc_write(codec, AIC32X4_DOSRLSB,\r\n(aic32x4_divs[i].dosr & 0xff));\r\ndata = snd_soc_read(codec, AIC32X4_NADC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_NADC, data | aic32x4_divs[i].nadc);\r\ndata = snd_soc_read(codec, AIC32X4_MADC);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_MADC, data | aic32x4_divs[i].madc);\r\nsnd_soc_write(codec, AIC32X4_AOSR, aic32x4_divs[i].aosr);\r\ndata = snd_soc_read(codec, AIC32X4_BCLKN);\r\ndata &= ~(0x7f);\r\nsnd_soc_write(codec, AIC32X4_BCLKN, data | aic32x4_divs[i].blck_N);\r\ndata = snd_soc_read(codec, AIC32X4_IFACE1);\r\ndata = data & ~(3 << 4);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ndata |= (AIC32X4_WORD_LEN_20BITS << AIC32X4_DOSRMSB_SHIFT);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndata |= (AIC32X4_WORD_LEN_24BITS << AIC32X4_DOSRMSB_SHIFT);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndata |= (AIC32X4_WORD_LEN_32BITS << AIC32X4_DOSRMSB_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_write(codec, AIC32X4_IFACE1, data);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 dac_reg;\r\ndac_reg = snd_soc_read(codec, AIC32X4_DACMUTE) & ~AIC32X4_MUTEON;\r\nif (mute)\r\nsnd_soc_write(codec, AIC32X4_DACMUTE, dac_reg | AIC32X4_MUTEON);\r\nelse\r\nsnd_soc_write(codec, AIC32X4_DACMUTE, dac_reg);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, AIC32X4_PLLPR,\r\nAIC32X4_PLLEN, AIC32X4_PLLEN);\r\nsnd_soc_update_bits(codec, AIC32X4_NDAC,\r\nAIC32X4_NDACEN, AIC32X4_NDACEN);\r\nsnd_soc_update_bits(codec, AIC32X4_MDAC,\r\nAIC32X4_MDACEN, AIC32X4_MDACEN);\r\nsnd_soc_update_bits(codec, AIC32X4_NADC,\r\nAIC32X4_NADCEN, AIC32X4_NADCEN);\r\nsnd_soc_update_bits(codec, AIC32X4_MADC,\r\nAIC32X4_MADCEN, AIC32X4_MADCEN);\r\nsnd_soc_update_bits(codec, AIC32X4_BCLKN,\r\nAIC32X4_BCLKEN, AIC32X4_BCLKEN);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, AIC32X4_PLLPR,\r\nAIC32X4_PLLEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_NDAC,\r\nAIC32X4_NDACEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_MDAC,\r\nAIC32X4_MDACEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_NADC,\r\nAIC32X4_NADCEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_MADC,\r\nAIC32X4_MADCEN, 0);\r\nsnd_soc_update_bits(codec, AIC32X4_BCLKN,\r\nAIC32X4_BCLKEN, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int aic32x4_suspend(struct snd_soc_codec *codec)\r\n{\r\naic32x4_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_resume(struct snd_soc_codec *codec)\r\n{\r\naic32x4_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct aic32x4_priv *aic32x4 = snd_soc_codec_get_drvdata(codec);\r\nu32 tmp_reg;\r\ncodec->hw_write = (hw_write_t) i2c_master_send;\r\ncodec->control_data = aic32x4->control_data;\r\nsnd_soc_write(codec, AIC32X4_RESET, 0x01);\r\nif (aic32x4->power_cfg & AIC32X4_PWR_MICBIAS_2075_LDOIN) {\r\nsnd_soc_write(codec, AIC32X4_MICBIAS, AIC32X4_MICBIAS_LDOIN |\r\nAIC32X4_MICBIAS_2075V);\r\n}\r\nif (aic32x4->power_cfg & AIC32X4_PWR_AVDD_DVDD_WEAK_DISABLE) {\r\nsnd_soc_write(codec, AIC32X4_PWRCFG, AIC32X4_AVDDWEAKDISABLE);\r\n}\r\ntmp_reg = (aic32x4->power_cfg & AIC32X4_PWR_AIC32X4_LDO_ENABLE) ?\r\nAIC32X4_LDOCTLEN : 0;\r\nsnd_soc_write(codec, AIC32X4_LDOCTL, tmp_reg);\r\ntmp_reg = snd_soc_read(codec, AIC32X4_CMMODE);\r\nif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_LDOIN_RANGE_18_36) {\r\ntmp_reg |= AIC32X4_LDOIN_18_36;\r\n}\r\nif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_HP_LDOIN_POWERED) {\r\ntmp_reg |= AIC32X4_LDOIN2HP;\r\n}\r\nsnd_soc_write(codec, AIC32X4_CMMODE, tmp_reg);\r\nif (aic32x4->swapdacs) {\r\nsnd_soc_write(codec, AIC32X4_DACSETUP, AIC32X4_LDAC2RCHN | AIC32X4_RDAC2LCHN);\r\n} else {\r\nsnd_soc_write(codec, AIC32X4_DACSETUP, AIC32X4_LDAC2LCHN | AIC32X4_RDAC2RCHN);\r\n}\r\nif (aic32x4->micpga_routing & AIC32X4_MICPGA_ROUTE_LMIC_IN2R_10K) {\r\nsnd_soc_write(codec, AIC32X4_LMICPGANIN, AIC32X4_LMICPGANIN_IN2R_10K);\r\n}\r\nif (aic32x4->micpga_routing & AIC32X4_MICPGA_ROUTE_RMIC_IN1L_10K) {\r\nsnd_soc_write(codec, AIC32X4_RMICPGANIN, AIC32X4_RMICPGANIN_IN1L_10K);\r\n}\r\naic32x4_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_add_codec_controls(codec, aic32x4_snd_controls,\r\nARRAY_SIZE(aic32x4_snd_controls));\r\naic32x4_add_widgets(codec);\r\nreturn 0;\r\n}\r\nstatic int aic32x4_remove(struct snd_soc_codec *codec)\r\n{\r\naic32x4_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic __devinit int aic32x4_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct aic32x4_pdata *pdata = i2c->dev.platform_data;\r\nstruct aic32x4_priv *aic32x4;\r\nint ret;\r\naic32x4 = devm_kzalloc(&i2c->dev, sizeof(struct aic32x4_priv),\r\nGFP_KERNEL);\r\nif (aic32x4 == NULL)\r\nreturn -ENOMEM;\r\naic32x4->control_data = i2c;\r\ni2c_set_clientdata(i2c, aic32x4);\r\nif (pdata) {\r\naic32x4->power_cfg = pdata->power_cfg;\r\naic32x4->swapdacs = pdata->swapdacs;\r\naic32x4->micpga_routing = pdata->micpga_routing;\r\n} else {\r\naic32x4->power_cfg = 0;\r\naic32x4->swapdacs = false;\r\naic32x4->micpga_routing = 0;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_aic32x4, &aic32x4_dai, 1);\r\nreturn ret;\r\n}\r\nstatic __devexit int aic32x4_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init aic32x4_modinit(void)\r\n{\r\nint ret = 0;\r\nret = i2c_add_driver(&aic32x4_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register aic32x4 I2C driver: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit aic32x4_exit(void)\r\n{\r\ni2c_del_driver(&aic32x4_i2c_driver);\r\n}
