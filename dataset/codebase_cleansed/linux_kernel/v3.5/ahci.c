static void ahci_pci_save_initial_config(struct pci_dev *pdev,\r\nstruct ahci_host_priv *hpriv)\r\n{\r\nunsigned int force_port_map = 0;\r\nunsigned int mask_port_map = 0;\r\nif (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361) {\r\ndev_info(&pdev->dev, "JMB361 has only one port\n");\r\nforce_port_map = 1;\r\n}\r\nif (hpriv->flags & AHCI_HFLAG_MV_PATA) {\r\nif (pdev->device == 0x6121)\r\nmask_port_map = 0x3;\r\nelse\r\nmask_port_map = 0xf;\r\ndev_info(&pdev->dev,\r\n"Disabling your PATA port. Use the boot option 'ahci.marvell_enable=0' to avoid this.\n");\r\n}\r\nahci_save_initial_config(&pdev->dev, hpriv, force_port_map,\r\nmask_port_map);\r\n}\r\nstatic int ahci_pci_reset_controller(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nahci_reset_controller(host);\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nu16 tmp16;\r\npci_read_config_word(pdev, 0x92, &tmp16);\r\nif ((tmp16 & hpriv->port_map) != hpriv->port_map) {\r\ntmp16 |= hpriv->port_map;\r\npci_write_config_word(pdev, 0x92, tmp16);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ahci_pci_init_controller(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nvoid __iomem *port_mmio;\r\nu32 tmp;\r\nint mv;\r\nif (hpriv->flags & AHCI_HFLAG_MV_PATA) {\r\nif (pdev->device == 0x6121)\r\nmv = 2;\r\nelse\r\nmv = 4;\r\nport_mmio = __ahci_port_base(host, mv);\r\nwritel(0, port_mmio + PORT_IRQ_MASK);\r\ntmp = readl(port_mmio + PORT_IRQ_STAT);\r\nVPRINTK("PORT_IRQ_STAT 0x%x\n", tmp);\r\nif (tmp)\r\nwritel(tmp, port_mmio + PORT_IRQ_STAT);\r\n}\r\nahci_init_controller(host);\r\n}\r\nstatic int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nbool online;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nahci_stop_engine(ap);\r\nrc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),\r\ndeadline, &online, NULL);\r\nahci_start_engine(ap);\r\nDPRINTK("EXIT, rc=%d, class=%u\n", rc, *class);\r\nreturn online ? -EAGAIN : rc;\r\n}\r\nstatic int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nstruct ata_taskfile tf;\r\nbool online;\r\nint rc;\r\nahci_stop_engine(ap);\r\nata_tf_init(link->device, &tf);\r\ntf.command = 0x80;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\nrc = sata_link_hardreset(link, sata_ehc_deb_timing(&link->eh_context),\r\ndeadline, &online, NULL);\r\nahci_start_engine(ap);\r\nif (online) {\r\nrc = ata_wait_after_reset(link, jiffies + 2 * HZ,\r\nahci_check_ready);\r\nif (rc)\r\nahci_kick_engine(ap);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nif (mesg.event & PM_EVENT_SUSPEND &&\r\nhpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(&pdev->dev,\r\n"BIOS update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nif (mesg.event & PM_EVENT_SLEEP) {\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\n}\r\nreturn ata_pci_device_suspend(pdev, mesg);\r\n}\r\nstatic int ahci_pci_device_resume(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_pci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_pci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)\r\n{\r\nint rc;\r\nif (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))\r\nreturn 0;\r\nif (using_dac &&\r\n!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"64-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev, "32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ahci_pci_print_info(struct ata_host *host)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nu16 cc;\r\nconst char *scc_s;\r\npci_read_config_word(pdev, 0x0a, &cc);\r\nif (cc == PCI_CLASS_STORAGE_IDE)\r\nscc_s = "IDE";\r\nelse if (cc == PCI_CLASS_STORAGE_SATA)\r\nscc_s = "SATA";\r\nelse if (cc == PCI_CLASS_STORAGE_RAID)\r\nscc_s = "RAID";\r\nelse\r\nscc_s = "unknown";\r\nahci_print_info(host, scc_s);\r\n}\r\nstatic void ahci_p5wdh_workaround(struct ata_host *host)\r\n{\r\nstatic struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "P5W DH Deluxe",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR,\r\n"ASUSTEK COMPUTER INC"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "P5W DH Deluxe"),\r\n},\r\n},\r\n{ }\r\n};\r\nstruct pci_dev *pdev = to_pci_dev(host->dev);\r\nif (pdev->bus->number == 0 && pdev->devfn == PCI_DEVFN(0x1f, 2) &&\r\ndmi_check_system(sysids)) {\r\nstruct ata_port *ap = host->ports[1];\r\ndev_info(&pdev->dev,\r\n"enabling ASUS P5W DH Deluxe on-board SIMG4726 workaround\n");\r\nap->ops = &ahci_p5wdh_ops;\r\nap->link.flags |= ATA_LFLAG_NO_SRST | ATA_LFLAG_ASSUME_ATA;\r\n}\r\n}\r\nstatic bool ahci_sb600_enable_64bit(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "ASUS M2A-VM",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"ASUSTeK Computer INC."),\r\nDMI_MATCH(DMI_BOARD_NAME, "M2A-VM"),\r\n},\r\n.driver_data = "20071026",\r\n},\r\n{\r\n.ident = "MSI K9A2 Platinum",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"MICRO-STAR INTER"),\r\nDMI_MATCH(DMI_BOARD_NAME, "MS-7376"),\r\n},\r\n},\r\n{\r\n.ident = "ASUS M3A",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"ASUSTeK Computer INC."),\r\nDMI_MATCH(DMI_BOARD_NAME, "M3A"),\r\n},\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *match;\r\nint year, month, date;\r\nchar buf[9];\r\nmatch = dmi_first_match(sysids);\r\nif (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||\r\n!match)\r\nreturn false;\r\nif (!match->driver_data)\r\ngoto enable_64bit;\r\ndmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\r\nsnprintf(buf, sizeof(buf), "%04d%02d%02d", year, month, date);\r\nif (strcmp(buf, match->driver_data) >= 0)\r\ngoto enable_64bit;\r\nelse {\r\ndev_warn(&pdev->dev,\r\n"%s: BIOS too old, forcing 32bit DMA, update BIOS\n",\r\nmatch->ident);\r\nreturn false;\r\n}\r\nenable_64bit:\r\ndev_warn(&pdev->dev, "%s: enabling 64bit DMA\n", match->ident);\r\nreturn true;\r\n}\r\nstatic bool ahci_broken_system_poweroff(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id broken_systems[] = {\r\n{\r\n.ident = "HP Compaq nx6310",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq nx6310"),\r\n},\r\n.driver_data = (void *)0x1FUL,\r\n},\r\n{\r\n.ident = "HP Compaq 6720s",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq 6720s"),\r\n},\r\n.driver_data = (void *)0x1FUL,\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(broken_systems);\r\nif (dmi) {\r\nunsigned long slot = (unsigned long)dmi->driver_data;\r\nreturn slot == PCI_SLOT(pdev->devfn);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ahci_broken_suspend(struct pci_dev *pdev)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "dv4",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP Pavilion dv4 Notebook PC"),\r\n},\r\n.driver_data = "20090105",\r\n},\r\n{\r\n.ident = "dv5",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP Pavilion dv5 Notebook PC"),\r\n},\r\n.driver_data = "20090506",\r\n},\r\n{\r\n.ident = "dv6",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP Pavilion dv6 Notebook PC"),\r\n},\r\n.driver_data = "20090423",\r\n},\r\n{\r\n.ident = "HDX18",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),\r\nDMI_MATCH(DMI_PRODUCT_NAME,\r\n"HP HDX18 Notebook PC"),\r\n},\r\n.driver_data = "20090430",\r\n},\r\n{\r\n.ident = "G725",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "eMachines"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "eMachines G725"),\r\n},\r\n.driver_data = "20091216",\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(sysids);\r\nint year, month, date;\r\nchar buf[9];\r\nif (!dmi || pdev->bus->number || pdev->devfn != PCI_DEVFN(0x1f, 2))\r\nreturn false;\r\ndmi_get_date(DMI_BIOS_DATE, &year, &month, &date);\r\nsnprintf(buf, sizeof(buf), "%04d%02d%02d", year, month, date);\r\nreturn strcmp(buf, dmi->driver_data) < 0;\r\n}\r\nstatic bool ahci_broken_online(struct pci_dev *pdev)\r\n{\r\n#define ENCODE_BUSDEVFN(bus, slot, func) \\r\n(void *)(unsigned long)(((bus) << 8) | PCI_DEVFN((slot), (func)))\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "EP45-DQ6",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"Gigabyte Technology Co., Ltd."),\r\nDMI_MATCH(DMI_BOARD_NAME, "EP45-DQ6"),\r\n},\r\n.driver_data = ENCODE_BUSDEVFN(0x0a, 0x00, 0),\r\n},\r\n{\r\n.ident = "EP45-DS5",\r\n.matches = {\r\nDMI_MATCH(DMI_BOARD_VENDOR,\r\n"Gigabyte Technology Co., Ltd."),\r\nDMI_MATCH(DMI_BOARD_NAME, "EP45-DS5"),\r\n},\r\n.driver_data = ENCODE_BUSDEVFN(0x03, 0x00, 0),\r\n},\r\n{ }\r\n};\r\n#undef ENCODE_BUSDEVFN\r\nconst struct dmi_system_id *dmi = dmi_first_match(sysids);\r\nunsigned int val;\r\nif (!dmi)\r\nreturn false;\r\nval = (unsigned long)dmi->driver_data;\r\nreturn pdev->bus->number == (val >> 8) && pdev->devfn == (val & 0xff);\r\n}\r\nstatic void ahci_gtf_filter_workaround(struct ata_host *host)\r\n{\r\nstatic const struct dmi_system_id sysids[] = {\r\n{\r\n.ident = "Aspire 3810T",\r\n.matches = {\r\nDMI_MATCH(DMI_SYS_VENDOR, "Acer"),\r\nDMI_MATCH(DMI_PRODUCT_NAME, "Aspire 3810T"),\r\n},\r\n.driver_data = (void *)ATA_ACPI_FILTER_FPDMA_OFFSET,\r\n},\r\n{ }\r\n};\r\nconst struct dmi_system_id *dmi = dmi_first_match(sysids);\r\nunsigned int filter;\r\nint i;\r\nif (!dmi)\r\nreturn;\r\nfilter = (unsigned long)dmi->driver_data;\r\ndev_info(host->dev, "applying extra ACPI _GTF filter 0x%x for %s\n",\r\nfilter, dmi->ident);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nata_for_each_link(link, ap, EDGE)\r\nata_for_each_dev(dev, link, ALL)\r\ndev->gtf_filter |= filter;\r\n}\r\n}\r\nstatic inline void ahci_gtf_filter_workaround(struct ata_host *host)\r\n{}\r\nstatic int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nunsigned int board_id = ent->driver_data;\r\nstruct ata_port_info pi = ahci_port_info[board_id];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct ata_host *host;\r\nint n_ports, i, rc;\r\nint ahci_pci_bar = AHCI_PCI_BAR_STANDARD;\r\nVPRINTK("ENTER\n");\r\nWARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nif (pdev->vendor == PCI_VENDOR_ID_MARVELL && !marvell_enable)\r\nreturn -ENODEV;\r\nif (pdev->vendor == PCI_VENDOR_ID_NVIDIA &&\r\npdev->device == PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA &&\r\npdev->subsystem_vendor == PCI_VENDOR_ID_APPLE &&\r\npdev->subsystem_device == 0xcb89)\r\nreturn -ENODEV;\r\nif (pdev->vendor == PCI_VENDOR_ID_PROMISE)\r\ndev_info(&pdev->dev,\r\n"PDC42819 can only drive SATA devices with this driver\n");\r\nif (pdev->vendor == PCI_VENDOR_ID_STMICRO && pdev->device == 0xCC06)\r\nahci_pci_bar = AHCI_PCI_BAR_STA2X11;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions_request_all(pdev, 1 << ahci_pci_bar, DRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\r\n(pdev->device == 0x2652 || pdev->device == 0x2653)) {\r\nu8 map;\r\npci_read_config_byte(pdev, ICH_MAP, &map);\r\nif (map & 0x3) {\r\ndev_info(&pdev->dev,\r\n"controller is in combined mode, can't enable AHCI mode\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv)\r\nreturn -ENOMEM;\r\nhpriv->flags |= (unsigned long)pi.private_data;\r\nif (board_id == board_ahci_mcp65 &&\r\n(pdev->revision == 0xa1 || pdev->revision == 0xa2))\r\nhpriv->flags |= AHCI_HFLAG_NO_MSI;\r\nif (board_id == board_ahci_sb700 && pdev->revision >= 0x40)\r\nhpriv->flags &= ~AHCI_HFLAG_IGN_SERR_INTERNAL;\r\nif (ahci_sb600_enable_64bit(pdev))\r\nhpriv->flags &= ~AHCI_HFLAG_32BIT_ONLY;\r\nif ((hpriv->flags & AHCI_HFLAG_NO_MSI) || pci_enable_msi(pdev))\r\npci_intx(pdev, 1);\r\nhpriv->mmio = pcim_iomap_table(pdev)[ahci_pci_bar];\r\nahci_pci_save_initial_config(pdev, hpriv);\r\nif (hpriv->cap & HOST_CAP_NCQ) {\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (!(hpriv->flags & AHCI_HFLAG_NO_FPDMA_AA))\r\npi.flags |= ATA_FLAG_FPDMA_AA;\r\n}\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nahci_set_em_messages(hpriv, &pi);\r\nif (ahci_broken_system_poweroff(pdev)) {\r\npi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN;\r\ndev_info(&pdev->dev,\r\n"quirky BIOS, skipping spindown on poweroff\n");\r\n}\r\nif (ahci_broken_suspend(pdev)) {\r\nhpriv->flags |= AHCI_HFLAG_NO_SUSPEND;\r\ndev_warn(&pdev->dev,\r\n"BIOS update required for suspend/resume\n");\r\n}\r\nif (ahci_broken_online(pdev)) {\r\nhpriv->flags |= AHCI_HFLAG_SRST_TOUT_IS_OFFLINE;\r\ndev_info(&pdev->dev,\r\n"online status unreliable, applying workaround\n");\r\n}\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->private_data = hpriv;\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nelse\r\nprintk(KERN_INFO "ahci: SSS flag set, parallel bus scan disabled\n");\r\nif (pi.flags & ATA_FLAG_EM)\r\nahci_reset_em(host);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_pbar_desc(ap, ahci_pci_bar, -1, "abar");\r\nata_port_pbar_desc(ap, ahci_pci_bar,\r\n0x100 + ap->port_no * 0x80, "port");\r\nif (ap->flags & ATA_FLAG_EM)\r\nap->em_message_type = hpriv->em_msg_type;\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nahci_p5wdh_workaround(host);\r\nahci_gtf_filter_workaround(host);\r\nrc = ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);\r\nif (rc)\r\nreturn rc;\r\nrc = ahci_pci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_pci_init_controller(host);\r\nahci_pci_print_info(host);\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,\r\n&ahci_sht);\r\n}\r\nstatic int __init ahci_init(void)\r\n{\r\nreturn pci_register_driver(&ahci_pci_driver);\r\n}\r\nstatic void __exit ahci_exit(void)\r\n{\r\npci_unregister_driver(&ahci_pci_driver);\r\n}
