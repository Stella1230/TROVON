void\r\nnouveau_dma_init(struct nouveau_channel *chan)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nstruct nouveau_bo *pushbuf = chan->pushbuf_bo;\r\nif (dev_priv->card_type >= NV_50) {\r\nconst int ib_size = pushbuf->bo.mem.size / 2;\r\nchan->dma.ib_base = (pushbuf->bo.mem.size - ib_size) >> 2;\r\nchan->dma.ib_max = (ib_size / 8) - 1;\r\nchan->dma.ib_put = 0;\r\nchan->dma.ib_free = chan->dma.ib_max - chan->dma.ib_put;\r\nchan->dma.max = (pushbuf->bo.mem.size - ib_size) >> 2;\r\n} else {\r\nchan->dma.max = (pushbuf->bo.mem.size >> 2) - 2;\r\n}\r\nchan->dma.put = 0;\r\nchan->dma.cur = chan->dma.put;\r\nchan->dma.free = chan->dma.max - chan->dma.cur;\r\n}\r\nvoid\r\nOUT_RINGp(struct nouveau_channel *chan, const void *data, unsigned nr_dwords)\r\n{\r\nbool is_iomem;\r\nu32 *mem = ttm_kmap_obj_virtual(&chan->pushbuf_bo->kmap, &is_iomem);\r\nmem = &mem[chan->dma.cur];\r\nif (is_iomem)\r\nmemcpy_toio((void __force __iomem *)mem, data, nr_dwords * 4);\r\nelse\r\nmemcpy(mem, data, nr_dwords * 4);\r\nchan->dma.cur += nr_dwords;\r\n}\r\nstatic inline int\r\nREAD_GET(struct nouveau_channel *chan, uint64_t *prev_get, int *timeout)\r\n{\r\nuint64_t val;\r\nval = nvchan_rd32(chan, chan->user_get);\r\nif (chan->user_get_hi)\r\nval |= (uint64_t)nvchan_rd32(chan, chan->user_get_hi) << 32;\r\nif (val != *prev_get) {\r\n*prev_get = val;\r\n*timeout = 0;\r\n}\r\nif ((++*timeout & 0xff) == 0) {\r\nDRM_UDELAY(1);\r\nif (*timeout > 100000)\r\nreturn -EBUSY;\r\n}\r\nif (val < chan->pushbuf_base ||\r\nval > chan->pushbuf_base + (chan->dma.max << 2))\r\nreturn -EINVAL;\r\nreturn (val - chan->pushbuf_base) >> 2;\r\n}\r\nvoid\r\nnv50_dma_push(struct nouveau_channel *chan, struct nouveau_bo *bo,\r\nint delta, int length)\r\n{\r\nstruct nouveau_bo *pb = chan->pushbuf_bo;\r\nstruct nouveau_vma *vma;\r\nint ip = (chan->dma.ib_put * 2) + chan->dma.ib_base;\r\nu64 offset;\r\nvma = nouveau_bo_vma_find(bo, chan->vm);\r\nBUG_ON(!vma);\r\noffset = vma->offset + delta;\r\nBUG_ON(chan->dma.ib_free < 1);\r\nnouveau_bo_wr32(pb, ip++, lower_32_bits(offset));\r\nnouveau_bo_wr32(pb, ip++, upper_32_bits(offset) | length << 8);\r\nchan->dma.ib_put = (chan->dma.ib_put + 1) & chan->dma.ib_max;\r\nDRM_MEMORYBARRIER();\r\nnouveau_bo_rd32(pb, 0);\r\nnvchan_wr32(chan, 0x8c, chan->dma.ib_put);\r\nchan->dma.ib_free--;\r\n}\r\nstatic int\r\nnv50_dma_push_wait(struct nouveau_channel *chan, int count)\r\n{\r\nuint32_t cnt = 0, prev_get = 0;\r\nwhile (chan->dma.ib_free < count) {\r\nuint32_t get = nvchan_rd32(chan, 0x88);\r\nif (get != prev_get) {\r\nprev_get = get;\r\ncnt = 0;\r\n}\r\nif ((++cnt & 0xff) == 0) {\r\nDRM_UDELAY(1);\r\nif (cnt > 100000)\r\nreturn -EBUSY;\r\n}\r\nchan->dma.ib_free = get - chan->dma.ib_put;\r\nif (chan->dma.ib_free <= 0)\r\nchan->dma.ib_free += chan->dma.ib_max;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_dma_wait(struct nouveau_channel *chan, int slots, int count)\r\n{\r\nuint64_t prev_get = 0;\r\nint ret, cnt = 0;\r\nret = nv50_dma_push_wait(chan, slots + 1);\r\nif (unlikely(ret))\r\nreturn ret;\r\nwhile (chan->dma.free < count) {\r\nint get = READ_GET(chan, &prev_get, &cnt);\r\nif (unlikely(get < 0)) {\r\nif (get == -EINVAL)\r\ncontinue;\r\nreturn get;\r\n}\r\nif (get <= chan->dma.cur) {\r\nchan->dma.free = chan->dma.max - chan->dma.cur;\r\nif (chan->dma.free >= count)\r\nbreak;\r\nFIRE_RING(chan);\r\ndo {\r\nget = READ_GET(chan, &prev_get, &cnt);\r\nif (unlikely(get < 0)) {\r\nif (get == -EINVAL)\r\ncontinue;\r\nreturn get;\r\n}\r\n} while (get == 0);\r\nchan->dma.cur = 0;\r\nchan->dma.put = 0;\r\n}\r\nchan->dma.free = get - chan->dma.cur - 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_dma_wait(struct nouveau_channel *chan, int slots, int size)\r\n{\r\nuint64_t prev_get = 0;\r\nint cnt = 0, get;\r\nif (chan->dma.ib_max)\r\nreturn nv50_dma_wait(chan, slots, size);\r\nwhile (chan->dma.free < size) {\r\nget = READ_GET(chan, &prev_get, &cnt);\r\nif (unlikely(get == -EBUSY))\r\nreturn -EBUSY;\r\nif (unlikely(get == -EINVAL) || get < NOUVEAU_DMA_SKIPS)\r\ncontinue;\r\nif (get <= chan->dma.cur) {\r\nchan->dma.free = chan->dma.max - chan->dma.cur;\r\nif (chan->dma.free >= size)\r\nbreak;\r\nOUT_RING(chan, chan->pushbuf_base | 0x20000000);\r\ndo {\r\nget = READ_GET(chan, &prev_get, &cnt);\r\nif (unlikely(get == -EBUSY))\r\nreturn -EBUSY;\r\nif (unlikely(get == -EINVAL))\r\ncontinue;\r\n} while (get <= NOUVEAU_DMA_SKIPS);\r\nWRITE_PUT(NOUVEAU_DMA_SKIPS);\r\nchan->dma.cur =\r\nchan->dma.put = NOUVEAU_DMA_SKIPS;\r\n}\r\nchan->dma.free = get - chan->dma.cur - 1;\r\n}\r\nreturn 0;\r\n}
