static inline int get_n_events_by_type(int type)\r\n{\r\nBUG_ON(type != EV_SW && type != EV_KEY);\r\nreturn (type == EV_KEY) ? KEY_CNT : SW_CNT;\r\n}\r\nstatic void gpio_keys_disable_button(struct gpio_button_data *bdata)\r\n{\r\nif (!bdata->disabled) {\r\ndisable_irq(bdata->irq);\r\nif (bdata->timer_debounce)\r\ndel_timer_sync(&bdata->timer);\r\nbdata->disabled = true;\r\n}\r\n}\r\nstatic void gpio_keys_enable_button(struct gpio_button_data *bdata)\r\n{\r\nif (bdata->disabled) {\r\nenable_irq(bdata->irq);\r\nbdata->disabled = false;\r\n}\r\n}\r\nstatic ssize_t gpio_keys_attr_show_helper(struct gpio_keys_drvdata *ddata,\r\nchar *buf, unsigned int type,\r\nbool only_disabled)\r\n{\r\nint n_events = get_n_events_by_type(type);\r\nunsigned long *bits;\r\nssize_t ret;\r\nint i;\r\nbits = kcalloc(BITS_TO_LONGS(n_events), sizeof(*bits), GFP_KERNEL);\r\nif (!bits)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ddata->n_buttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->type != type)\r\ncontinue;\r\nif (only_disabled && !bdata->disabled)\r\ncontinue;\r\n__set_bit(bdata->button->code, bits);\r\n}\r\nret = bitmap_scnlistprintf(buf, PAGE_SIZE - 2, bits, n_events);\r\nbuf[ret++] = '\n';\r\nbuf[ret] = '\0';\r\nkfree(bits);\r\nreturn ret;\r\n}\r\nstatic ssize_t gpio_keys_attr_store_helper(struct gpio_keys_drvdata *ddata,\r\nconst char *buf, unsigned int type)\r\n{\r\nint n_events = get_n_events_by_type(type);\r\nunsigned long *bits;\r\nssize_t error;\r\nint i;\r\nbits = kcalloc(BITS_TO_LONGS(n_events), sizeof(*bits), GFP_KERNEL);\r\nif (!bits)\r\nreturn -ENOMEM;\r\nerror = bitmap_parselist(buf, bits, n_events);\r\nif (error)\r\ngoto out;\r\nfor (i = 0; i < ddata->n_buttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->type != type)\r\ncontinue;\r\nif (test_bit(bdata->button->code, bits) &&\r\n!bdata->button->can_disable) {\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nmutex_lock(&ddata->disable_lock);\r\nfor (i = 0; i < ddata->n_buttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->type != type)\r\ncontinue;\r\nif (test_bit(bdata->button->code, bits))\r\ngpio_keys_disable_button(bdata);\r\nelse\r\ngpio_keys_enable_button(bdata);\r\n}\r\nmutex_unlock(&ddata->disable_lock);\r\nout:\r\nkfree(bits);\r\nreturn error;\r\n}\r\nstatic void gpio_keys_gpio_report_event(struct gpio_button_data *bdata)\r\n{\r\nconst struct gpio_keys_button *button = bdata->button;\r\nstruct input_dev *input = bdata->input;\r\nunsigned int type = button->type ?: EV_KEY;\r\nint state = (gpio_get_value_cansleep(button->gpio) ? 1 : 0) ^ button->active_low;\r\nif (type == EV_ABS) {\r\nif (state)\r\ninput_event(input, type, button->code, button->value);\r\n} else {\r\ninput_event(input, type, button->code, !!state);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic void gpio_keys_gpio_work_func(struct work_struct *work)\r\n{\r\nstruct gpio_button_data *bdata =\r\ncontainer_of(work, struct gpio_button_data, work);\r\ngpio_keys_gpio_report_event(bdata);\r\n}\r\nstatic void gpio_keys_gpio_timer(unsigned long _data)\r\n{\r\nstruct gpio_button_data *bdata = (struct gpio_button_data *)_data;\r\nschedule_work(&bdata->work);\r\n}\r\nstatic irqreturn_t gpio_keys_gpio_isr(int irq, void *dev_id)\r\n{\r\nstruct gpio_button_data *bdata = dev_id;\r\nBUG_ON(irq != bdata->irq);\r\nif (bdata->timer_debounce)\r\nmod_timer(&bdata->timer,\r\njiffies + msecs_to_jiffies(bdata->timer_debounce));\r\nelse\r\nschedule_work(&bdata->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gpio_keys_irq_timer(unsigned long _data)\r\n{\r\nstruct gpio_button_data *bdata = (struct gpio_button_data *)_data;\r\nstruct input_dev *input = bdata->input;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bdata->lock, flags);\r\nif (bdata->key_pressed) {\r\ninput_event(input, EV_KEY, bdata->button->code, 0);\r\ninput_sync(input);\r\nbdata->key_pressed = false;\r\n}\r\nspin_unlock_irqrestore(&bdata->lock, flags);\r\n}\r\nstatic irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)\r\n{\r\nstruct gpio_button_data *bdata = dev_id;\r\nconst struct gpio_keys_button *button = bdata->button;\r\nstruct input_dev *input = bdata->input;\r\nunsigned long flags;\r\nBUG_ON(irq != bdata->irq);\r\nspin_lock_irqsave(&bdata->lock, flags);\r\nif (!bdata->key_pressed) {\r\ninput_event(input, EV_KEY, button->code, 1);\r\ninput_sync(input);\r\nif (!bdata->timer_debounce) {\r\ninput_event(input, EV_KEY, button->code, 0);\r\ninput_sync(input);\r\ngoto out;\r\n}\r\nbdata->key_pressed = true;\r\n}\r\nif (bdata->timer_debounce)\r\nmod_timer(&bdata->timer,\r\njiffies + msecs_to_jiffies(bdata->timer_debounce));\r\nout:\r\nspin_unlock_irqrestore(&bdata->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit gpio_keys_setup_key(struct platform_device *pdev,\r\nstruct input_dev *input,\r\nstruct gpio_button_data *bdata,\r\nconst struct gpio_keys_button *button)\r\n{\r\nconst char *desc = button->desc ? button->desc : "gpio_keys";\r\nstruct device *dev = &pdev->dev;\r\nirq_handler_t isr;\r\nunsigned long irqflags;\r\nint irq, error;\r\nbdata->input = input;\r\nbdata->button = button;\r\nspin_lock_init(&bdata->lock);\r\nif (gpio_is_valid(button->gpio)) {\r\nerror = gpio_request(button->gpio, desc);\r\nif (error < 0) {\r\ndev_err(dev, "Failed to request GPIO %d, error %d\n",\r\nbutton->gpio, error);\r\nreturn error;\r\n}\r\nerror = gpio_direction_input(button->gpio);\r\nif (error < 0) {\r\ndev_err(dev,\r\n"Failed to configure direction for GPIO %d, error %d\n",\r\nbutton->gpio, error);\r\ngoto fail;\r\n}\r\nif (button->debounce_interval) {\r\nerror = gpio_set_debounce(button->gpio,\r\nbutton->debounce_interval * 1000);\r\nif (error < 0)\r\nbdata->timer_debounce =\r\nbutton->debounce_interval;\r\n}\r\nirq = gpio_to_irq(button->gpio);\r\nif (irq < 0) {\r\nerror = irq;\r\ndev_err(dev,\r\n"Unable to get irq number for GPIO %d, error %d\n",\r\nbutton->gpio, error);\r\ngoto fail;\r\n}\r\nbdata->irq = irq;\r\nINIT_WORK(&bdata->work, gpio_keys_gpio_work_func);\r\nsetup_timer(&bdata->timer,\r\ngpio_keys_gpio_timer, (unsigned long)bdata);\r\nisr = gpio_keys_gpio_isr;\r\nirqflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;\r\n} else {\r\nif (!button->irq) {\r\ndev_err(dev, "No IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nbdata->irq = button->irq;\r\nif (button->type && button->type != EV_KEY) {\r\ndev_err(dev, "Only EV_KEY allowed for IRQ buttons.\n");\r\nreturn -EINVAL;\r\n}\r\nbdata->timer_debounce = button->debounce_interval;\r\nsetup_timer(&bdata->timer,\r\ngpio_keys_irq_timer, (unsigned long)bdata);\r\nisr = gpio_keys_irq_isr;\r\nirqflags = 0;\r\n}\r\ninput_set_capability(input, button->type ?: EV_KEY, button->code);\r\nif (!button->can_disable)\r\nirqflags |= IRQF_SHARED;\r\nerror = request_any_context_irq(bdata->irq, isr, irqflags, desc, bdata);\r\nif (error < 0) {\r\ndev_err(dev, "Unable to claim irq %d; error %d\n",\r\nbdata->irq, error);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nif (gpio_is_valid(button->gpio))\r\ngpio_free(button->gpio);\r\nreturn error;\r\n}\r\nstatic int gpio_keys_open(struct input_dev *input)\r\n{\r\nstruct gpio_keys_drvdata *ddata = input_get_drvdata(input);\r\nreturn ddata->enable ? ddata->enable(input->dev.parent) : 0;\r\n}\r\nstatic void gpio_keys_close(struct input_dev *input)\r\n{\r\nstruct gpio_keys_drvdata *ddata = input_get_drvdata(input);\r\nif (ddata->disable)\r\nddata->disable(input->dev.parent);\r\n}\r\nstatic int gpio_keys_get_devtree_pdata(struct device *dev,\r\nstruct gpio_keys_platform_data *pdata)\r\n{\r\nstruct device_node *node, *pp;\r\nint i;\r\nstruct gpio_keys_button *buttons;\r\nu32 reg;\r\nnode = dev->of_node;\r\nif (node == NULL)\r\nreturn -ENODEV;\r\nmemset(pdata, 0, sizeof *pdata);\r\npdata->rep = !!of_get_property(node, "autorepeat", NULL);\r\npdata->nbuttons = 0;\r\npp = NULL;\r\nwhile ((pp = of_get_next_child(node, pp)))\r\npdata->nbuttons++;\r\nif (pdata->nbuttons == 0)\r\nreturn -ENODEV;\r\nbuttons = kzalloc(pdata->nbuttons * (sizeof *buttons), GFP_KERNEL);\r\nif (!buttons)\r\nreturn -ENOMEM;\r\npp = NULL;\r\ni = 0;\r\nwhile ((pp = of_get_next_child(node, pp))) {\r\nenum of_gpio_flags flags;\r\nif (!of_find_property(pp, "gpios", NULL)) {\r\npdata->nbuttons--;\r\ndev_warn(dev, "Found button without gpios\n");\r\ncontinue;\r\n}\r\nbuttons[i].gpio = of_get_gpio_flags(pp, 0, &flags);\r\nbuttons[i].active_low = flags & OF_GPIO_ACTIVE_LOW;\r\nif (of_property_read_u32(pp, "linux,code", &reg)) {\r\ndev_err(dev, "Button without keycode: 0x%x\n", buttons[i].gpio);\r\ngoto out_fail;\r\n}\r\nbuttons[i].code = reg;\r\nbuttons[i].desc = of_get_property(pp, "label", NULL);\r\nif (of_property_read_u32(pp, "linux,input-type", &reg) == 0)\r\nbuttons[i].type = reg;\r\nelse\r\nbuttons[i].type = EV_KEY;\r\nbuttons[i].wakeup = !!of_get_property(pp, "gpio-key,wakeup", NULL);\r\nif (of_property_read_u32(pp, "debounce-interval", &reg) == 0)\r\nbuttons[i].debounce_interval = reg;\r\nelse\r\nbuttons[i].debounce_interval = 5;\r\ni++;\r\n}\r\npdata->buttons = buttons;\r\nreturn 0;\r\nout_fail:\r\nkfree(buttons);\r\nreturn -ENODEV;\r\n}\r\nstatic int gpio_keys_get_devtree_pdata(struct device *dev,\r\nstruct gpio_keys_platform_data *altp)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void gpio_remove_key(struct gpio_button_data *bdata)\r\n{\r\nfree_irq(bdata->irq, bdata);\r\nif (bdata->timer_debounce)\r\ndel_timer_sync(&bdata->timer);\r\ncancel_work_sync(&bdata->work);\r\nif (gpio_is_valid(bdata->button->gpio))\r\ngpio_free(bdata->button->gpio);\r\n}\r\nstatic int __devinit gpio_keys_probe(struct platform_device *pdev)\r\n{\r\nconst struct gpio_keys_platform_data *pdata = pdev->dev.platform_data;\r\nstruct gpio_keys_drvdata *ddata;\r\nstruct device *dev = &pdev->dev;\r\nstruct gpio_keys_platform_data alt_pdata;\r\nstruct input_dev *input;\r\nint i, error;\r\nint wakeup = 0;\r\nif (!pdata) {\r\nerror = gpio_keys_get_devtree_pdata(dev, &alt_pdata);\r\nif (error)\r\nreturn error;\r\npdata = &alt_pdata;\r\n}\r\nddata = kzalloc(sizeof(struct gpio_keys_drvdata) +\r\npdata->nbuttons * sizeof(struct gpio_button_data),\r\nGFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!ddata || !input) {\r\ndev_err(dev, "failed to allocate state\n");\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nddata->input = input;\r\nddata->n_buttons = pdata->nbuttons;\r\nddata->enable = pdata->enable;\r\nddata->disable = pdata->disable;\r\nmutex_init(&ddata->disable_lock);\r\nplatform_set_drvdata(pdev, ddata);\r\ninput_set_drvdata(input, ddata);\r\ninput->name = pdata->name ? : pdev->name;\r\ninput->phys = "gpio-keys/input0";\r\ninput->dev.parent = &pdev->dev;\r\ninput->open = gpio_keys_open;\r\ninput->close = gpio_keys_close;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nconst struct gpio_keys_button *button = &pdata->buttons[i];\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nerror = gpio_keys_setup_key(pdev, input, bdata, button);\r\nif (error)\r\ngoto fail2;\r\nif (button->wakeup)\r\nwakeup = 1;\r\n}\r\nerror = sysfs_create_group(&pdev->dev.kobj, &gpio_keys_attr_group);\r\nif (error) {\r\ndev_err(dev, "Unable to export keys/switches, error: %d\n",\r\nerror);\r\ngoto fail2;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "Unable to register input device, error: %d\n",\r\nerror);\r\ngoto fail3;\r\n}\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (gpio_is_valid(bdata->button->gpio))\r\ngpio_keys_gpio_report_event(bdata);\r\n}\r\ninput_sync(input);\r\ndevice_init_wakeup(&pdev->dev, wakeup);\r\nreturn 0;\r\nfail3:\r\nsysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);\r\nfail2:\r\nwhile (--i >= 0)\r\ngpio_remove_key(&ddata->data[i]);\r\nplatform_set_drvdata(pdev, NULL);\r\nfail1:\r\ninput_free_device(input);\r\nkfree(ddata);\r\nif (!pdev->dev.platform_data)\r\nkfree(pdata->buttons);\r\nreturn error;\r\n}\r\nstatic int __devexit gpio_keys_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_keys_drvdata *ddata = platform_get_drvdata(pdev);\r\nstruct input_dev *input = ddata->input;\r\nint i;\r\nsysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nfor (i = 0; i < ddata->n_buttons; i++)\r\ngpio_remove_key(&ddata->data[i]);\r\ninput_unregister_device(input);\r\nif (!pdev->dev.platform_data)\r\nkfree(ddata->data[0].button);\r\nkfree(ddata);\r\nreturn 0;\r\n}\r\nstatic int gpio_keys_suspend(struct device *dev)\r\n{\r\nstruct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);\r\nint i;\r\nif (device_may_wakeup(dev)) {\r\nfor (i = 0; i < ddata->n_buttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->wakeup)\r\nenable_irq_wake(bdata->irq);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_keys_resume(struct device *dev)\r\n{\r\nstruct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < ddata->n_buttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->wakeup && device_may_wakeup(dev))\r\ndisable_irq_wake(bdata->irq);\r\nif (gpio_is_valid(bdata->button->gpio))\r\ngpio_keys_gpio_report_event(bdata);\r\n}\r\ninput_sync(ddata->input);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_keys_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_keys_device_driver);\r\n}\r\nstatic void __exit gpio_keys_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_keys_device_driver);\r\n}
