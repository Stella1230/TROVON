void sas_queue_work(struct sas_ha_struct *ha, struct sas_work *sw)\r\n{\r\nif (!test_bit(SAS_HA_REGISTERED, &ha->state))\r\nreturn;\r\nif (test_bit(SAS_HA_DRAINING, &ha->state)) {\r\nif (list_empty(&sw->drain_node))\r\nlist_add(&sw->drain_node, &ha->defer_q);\r\n} else\r\nscsi_queue_work(ha->core.shost, &sw->work);\r\n}\r\nstatic void sas_queue_event(int event, unsigned long *pending,\r\nstruct sas_work *work,\r\nstruct sas_ha_struct *ha)\r\n{\r\nif (!test_and_set_bit(event, pending)) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&ha->state_lock, flags);\r\nsas_queue_work(ha, work);\r\nspin_unlock_irqrestore(&ha->state_lock, flags);\r\n}\r\n}\r\nvoid __sas_drain_work(struct sas_ha_struct *ha)\r\n{\r\nstruct workqueue_struct *wq = ha->core.shost->work_q;\r\nstruct sas_work *sw, *_sw;\r\nset_bit(SAS_HA_DRAINING, &ha->state);\r\nspin_lock_irq(&ha->state_lock);\r\nspin_unlock_irq(&ha->state_lock);\r\ndrain_workqueue(wq);\r\nspin_lock_irq(&ha->state_lock);\r\nclear_bit(SAS_HA_DRAINING, &ha->state);\r\nlist_for_each_entry_safe(sw, _sw, &ha->defer_q, drain_node) {\r\nlist_del_init(&sw->drain_node);\r\nsas_queue_work(ha, sw);\r\n}\r\nspin_unlock_irq(&ha->state_lock);\r\n}\r\nint sas_drain_work(struct sas_ha_struct *ha)\r\n{\r\nint err;\r\nerr = mutex_lock_interruptible(&ha->drain_mutex);\r\nif (err)\r\nreturn err;\r\nif (test_bit(SAS_HA_REGISTERED, &ha->state))\r\n__sas_drain_work(ha);\r\nmutex_unlock(&ha->drain_mutex);\r\nreturn 0;\r\n}\r\nvoid sas_disable_revalidation(struct sas_ha_struct *ha)\r\n{\r\nmutex_lock(&ha->disco_mutex);\r\nset_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state);\r\nmutex_unlock(&ha->disco_mutex);\r\n}\r\nvoid sas_enable_revalidation(struct sas_ha_struct *ha)\r\n{\r\nint i;\r\nmutex_lock(&ha->disco_mutex);\r\nclear_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state);\r\nfor (i = 0; i < ha->num_phys; i++) {\r\nstruct asd_sas_port *port = ha->sas_port[i];\r\nconst int ev = DISCE_REVALIDATE_DOMAIN;\r\nstruct sas_discovery *d = &port->disc;\r\nif (!test_and_clear_bit(ev, &d->pending))\r\ncontinue;\r\nsas_queue_event(ev, &d->pending, &d->disc_work[ev].work, ha);\r\n}\r\nmutex_unlock(&ha->disco_mutex);\r\n}\r\nstatic void notify_ha_event(struct sas_ha_struct *sas_ha, enum ha_event event)\r\n{\r\nBUG_ON(event >= HA_NUM_EVENTS);\r\nsas_queue_event(event, &sas_ha->pending,\r\n&sas_ha->ha_events[event].work, sas_ha);\r\n}\r\nstatic void notify_port_event(struct asd_sas_phy *phy, enum port_event event)\r\n{\r\nstruct sas_ha_struct *ha = phy->ha;\r\nBUG_ON(event >= PORT_NUM_EVENTS);\r\nsas_queue_event(event, &phy->port_events_pending,\r\n&phy->port_events[event].work, ha);\r\n}\r\nstatic void notify_phy_event(struct asd_sas_phy *phy, enum phy_event event)\r\n{\r\nstruct sas_ha_struct *ha = phy->ha;\r\nBUG_ON(event >= PHY_NUM_EVENTS);\r\nsas_queue_event(event, &phy->phy_events_pending,\r\n&phy->phy_events[event].work, ha);\r\n}\r\nint sas_init_events(struct sas_ha_struct *sas_ha)\r\n{\r\nstatic const work_func_t sas_ha_event_fns[HA_NUM_EVENTS] = {\r\n[HAE_RESET] = sas_hae_reset,\r\n};\r\nint i;\r\nfor (i = 0; i < HA_NUM_EVENTS; i++) {\r\nINIT_SAS_WORK(&sas_ha->ha_events[i].work, sas_ha_event_fns[i]);\r\nsas_ha->ha_events[i].ha = sas_ha;\r\n}\r\nsas_ha->notify_ha_event = notify_ha_event;\r\nsas_ha->notify_port_event = notify_port_event;\r\nsas_ha->notify_phy_event = notify_phy_event;\r\nreturn 0;\r\n}
