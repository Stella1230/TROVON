static int mv88e6xxx_reg_wait_ready(struct mii_bus *bus, int sw_addr)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nret = mdiobus_read(bus, sw_addr, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret & 0x8000) == 0)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint __mv88e6xxx_reg_read(struct mii_bus *bus, int sw_addr, int addr, int reg)\r\n{\r\nint ret;\r\nif (sw_addr == 0)\r\nreturn mdiobus_read(bus, addr, reg);\r\nret = mv88e6xxx_reg_wait_ready(bus, sw_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mdiobus_write(bus, sw_addr, 0, 0x9800 | (addr << 5) | reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mv88e6xxx_reg_wait_ready(bus, sw_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mdiobus_read(bus, sw_addr, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ret & 0xffff;\r\n}\r\nint mv88e6xxx_reg_read(struct dsa_switch *ds, int addr, int reg)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint ret;\r\nmutex_lock(&ps->smi_mutex);\r\nret = __mv88e6xxx_reg_read(ds->master_mii_bus,\r\nds->pd->sw_addr, addr, reg);\r\nmutex_unlock(&ps->smi_mutex);\r\nreturn ret;\r\n}\r\nint __mv88e6xxx_reg_write(struct mii_bus *bus, int sw_addr, int addr,\r\nint reg, u16 val)\r\n{\r\nint ret;\r\nif (sw_addr == 0)\r\nreturn mdiobus_write(bus, addr, reg, val);\r\nret = mv88e6xxx_reg_wait_ready(bus, sw_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mdiobus_write(bus, sw_addr, 1, val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mdiobus_write(bus, sw_addr, 0, 0x9400 | (addr << 5) | reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mv88e6xxx_reg_wait_ready(bus, sw_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nint mv88e6xxx_reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint ret;\r\nmutex_lock(&ps->smi_mutex);\r\nret = __mv88e6xxx_reg_write(ds->master_mii_bus,\r\nds->pd->sw_addr, addr, reg, val);\r\nmutex_unlock(&ps->smi_mutex);\r\nreturn ret;\r\n}\r\nint mv88e6xxx_config_prio(struct dsa_switch *ds)\r\n{\r\nREG_WRITE(REG_GLOBAL, 0x10, 0x0000);\r\nREG_WRITE(REG_GLOBAL, 0x11, 0x0000);\r\nREG_WRITE(REG_GLOBAL, 0x12, 0x5555);\r\nREG_WRITE(REG_GLOBAL, 0x13, 0x5555);\r\nREG_WRITE(REG_GLOBAL, 0x14, 0xaaaa);\r\nREG_WRITE(REG_GLOBAL, 0x15, 0xaaaa);\r\nREG_WRITE(REG_GLOBAL, 0x16, 0xffff);\r\nREG_WRITE(REG_GLOBAL, 0x17, 0xffff);\r\nREG_WRITE(REG_GLOBAL, 0x18, 0xfa41);\r\nreturn 0;\r\n}\r\nint mv88e6xxx_set_addr_direct(struct dsa_switch *ds, u8 *addr)\r\n{\r\nREG_WRITE(REG_GLOBAL, 0x01, (addr[0] << 8) | addr[1]);\r\nREG_WRITE(REG_GLOBAL, 0x02, (addr[2] << 8) | addr[3]);\r\nREG_WRITE(REG_GLOBAL, 0x03, (addr[4] << 8) | addr[5]);\r\nreturn 0;\r\n}\r\nint mv88e6xxx_set_addr_indirect(struct dsa_switch *ds, u8 *addr)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < 6; i++) {\r\nint j;\r\nREG_WRITE(REG_GLOBAL2, 0x0d, 0x8000 | (i << 8) | addr[i]);\r\nfor (j = 0; j < 16; j++) {\r\nret = REG_READ(REG_GLOBAL2, 0x0d);\r\nif ((ret & 0x8000) == 0)\r\nbreak;\r\n}\r\nif (j == 16)\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint mv88e6xxx_phy_read(struct dsa_switch *ds, int addr, int regnum)\r\n{\r\nif (addr >= 0)\r\nreturn mv88e6xxx_reg_read(ds, addr, regnum);\r\nreturn 0xffff;\r\n}\r\nint mv88e6xxx_phy_write(struct dsa_switch *ds, int addr, int regnum, u16 val)\r\n{\r\nif (addr >= 0)\r\nreturn mv88e6xxx_reg_write(ds, addr, regnum, val);\r\nreturn 0;\r\n}\r\nstatic int mv88e6xxx_ppu_disable(struct dsa_switch *ds)\r\n{\r\nint ret;\r\nint i;\r\nret = REG_READ(REG_GLOBAL, 0x04);\r\nREG_WRITE(REG_GLOBAL, 0x04, ret & ~0x4000);\r\nfor (i = 0; i < 1000; i++) {\r\nret = REG_READ(REG_GLOBAL, 0x00);\r\nmsleep(1);\r\nif ((ret & 0xc000) != 0xc000)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mv88e6xxx_ppu_enable(struct dsa_switch *ds)\r\n{\r\nint ret;\r\nint i;\r\nret = REG_READ(REG_GLOBAL, 0x04);\r\nREG_WRITE(REG_GLOBAL, 0x04, ret | 0x4000);\r\nfor (i = 0; i < 1000; i++) {\r\nret = REG_READ(REG_GLOBAL, 0x00);\r\nmsleep(1);\r\nif ((ret & 0xc000) == 0xc000)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void mv88e6xxx_ppu_reenable_work(struct work_struct *ugly)\r\n{\r\nstruct mv88e6xxx_priv_state *ps;\r\nps = container_of(ugly, struct mv88e6xxx_priv_state, ppu_work);\r\nif (mutex_trylock(&ps->ppu_mutex)) {\r\nstruct dsa_switch *ds = ((struct dsa_switch *)ps) - 1;\r\nif (mv88e6xxx_ppu_enable(ds) == 0)\r\nps->ppu_disabled = 0;\r\nmutex_unlock(&ps->ppu_mutex);\r\n}\r\n}\r\nstatic void mv88e6xxx_ppu_reenable_timer(unsigned long _ps)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)_ps;\r\nschedule_work(&ps->ppu_work);\r\n}\r\nstatic int mv88e6xxx_ppu_access_get(struct dsa_switch *ds)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint ret;\r\nmutex_lock(&ps->ppu_mutex);\r\nif (!ps->ppu_disabled) {\r\nret = mv88e6xxx_ppu_disable(ds);\r\nif (ret < 0) {\r\nmutex_unlock(&ps->ppu_mutex);\r\nreturn ret;\r\n}\r\nps->ppu_disabled = 1;\r\n} else {\r\ndel_timer(&ps->ppu_timer);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void mv88e6xxx_ppu_access_put(struct dsa_switch *ds)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nmod_timer(&ps->ppu_timer, jiffies + msecs_to_jiffies(10));\r\nmutex_unlock(&ps->ppu_mutex);\r\n}\r\nvoid mv88e6xxx_ppu_state_init(struct dsa_switch *ds)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nmutex_init(&ps->ppu_mutex);\r\nINIT_WORK(&ps->ppu_work, mv88e6xxx_ppu_reenable_work);\r\ninit_timer(&ps->ppu_timer);\r\nps->ppu_timer.data = (unsigned long)ps;\r\nps->ppu_timer.function = mv88e6xxx_ppu_reenable_timer;\r\n}\r\nint mv88e6xxx_phy_read_ppu(struct dsa_switch *ds, int addr, int regnum)\r\n{\r\nint ret;\r\nret = mv88e6xxx_ppu_access_get(ds);\r\nif (ret >= 0) {\r\nret = mv88e6xxx_reg_read(ds, addr, regnum);\r\nmv88e6xxx_ppu_access_put(ds);\r\n}\r\nreturn ret;\r\n}\r\nint mv88e6xxx_phy_write_ppu(struct dsa_switch *ds, int addr,\r\nint regnum, u16 val)\r\n{\r\nint ret;\r\nret = mv88e6xxx_ppu_access_get(ds);\r\nif (ret >= 0) {\r\nret = mv88e6xxx_reg_write(ds, addr, regnum, val);\r\nmv88e6xxx_ppu_access_put(ds);\r\n}\r\nreturn ret;\r\n}\r\nvoid mv88e6xxx_poll_link(struct dsa_switch *ds)\r\n{\r\nint i;\r\nfor (i = 0; i < DSA_MAX_PORTS; i++) {\r\nstruct net_device *dev;\r\nint uninitialized_var(port_status);\r\nint link;\r\nint speed;\r\nint duplex;\r\nint fc;\r\ndev = ds->ports[i];\r\nif (dev == NULL)\r\ncontinue;\r\nlink = 0;\r\nif (dev->flags & IFF_UP) {\r\nport_status = mv88e6xxx_reg_read(ds, REG_PORT(i), 0x00);\r\nif (port_status < 0)\r\ncontinue;\r\nlink = !!(port_status & 0x0800);\r\n}\r\nif (!link) {\r\nif (netif_carrier_ok(dev)) {\r\nprintk(KERN_INFO "%s: link down\n", dev->name);\r\nnetif_carrier_off(dev);\r\n}\r\ncontinue;\r\n}\r\nswitch (port_status & 0x0300) {\r\ncase 0x0000:\r\nspeed = 10;\r\nbreak;\r\ncase 0x0100:\r\nspeed = 100;\r\nbreak;\r\ncase 0x0200:\r\nspeed = 1000;\r\nbreak;\r\ndefault:\r\nspeed = -1;\r\nbreak;\r\n}\r\nduplex = (port_status & 0x0400) ? 1 : 0;\r\nfc = (port_status & 0x8000) ? 1 : 0;\r\nif (!netif_carrier_ok(dev)) {\r\nprintk(KERN_INFO "%s: link up, %d Mb/s, %s duplex, "\r\n"flow control %sabled\n", dev->name,\r\nspeed, duplex ? "full" : "half",\r\nfc ? "en" : "dis");\r\nnetif_carrier_on(dev);\r\n}\r\n}\r\n}\r\nstatic int mv88e6xxx_stats_wait(struct dsa_switch *ds)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nret = REG_READ(REG_GLOBAL, 0x1d);\r\nif ((ret & 0x8000) == 0)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mv88e6xxx_stats_snapshot(struct dsa_switch *ds, int port)\r\n{\r\nint ret;\r\nREG_WRITE(REG_GLOBAL, 0x1d, 0xdc00 | port);\r\nret = mv88e6xxx_stats_wait(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void mv88e6xxx_stats_read(struct dsa_switch *ds, int stat, u32 *val)\r\n{\r\nu32 _val;\r\nint ret;\r\n*val = 0;\r\nret = mv88e6xxx_reg_write(ds, REG_GLOBAL, 0x1d, 0xcc00 | stat);\r\nif (ret < 0)\r\nreturn;\r\nret = mv88e6xxx_stats_wait(ds);\r\nif (ret < 0)\r\nreturn;\r\nret = mv88e6xxx_reg_read(ds, REG_GLOBAL, 0x1e);\r\nif (ret < 0)\r\nreturn;\r\n_val = ret << 16;\r\nret = mv88e6xxx_reg_read(ds, REG_GLOBAL, 0x1f);\r\nif (ret < 0)\r\nreturn;\r\n*val = _val | ret;\r\n}\r\nvoid mv88e6xxx_get_strings(struct dsa_switch *ds,\r\nint nr_stats, struct mv88e6xxx_hw_stat *stats,\r\nint port, uint8_t *data)\r\n{\r\nint i;\r\nfor (i = 0; i < nr_stats; i++) {\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nstats[i].string, ETH_GSTRING_LEN);\r\n}\r\n}\r\nvoid mv88e6xxx_get_ethtool_stats(struct dsa_switch *ds,\r\nint nr_stats, struct mv88e6xxx_hw_stat *stats,\r\nint port, uint64_t *data)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint ret;\r\nint i;\r\nmutex_lock(&ps->stats_mutex);\r\nret = mv88e6xxx_stats_snapshot(ds, port);\r\nif (ret < 0) {\r\nmutex_unlock(&ps->stats_mutex);\r\nreturn;\r\n}\r\nfor (i = 0; i < nr_stats; i++) {\r\nstruct mv88e6xxx_hw_stat *s = stats + i;\r\nu32 low;\r\nu32 high;\r\nmv88e6xxx_stats_read(ds, s->reg, &low);\r\nif (s->sizeof_stat == 8)\r\nmv88e6xxx_stats_read(ds, s->reg + 1, &high);\r\nelse\r\nhigh = 0;\r\ndata[i] = (((u64)high) << 32) | low;\r\n}\r\nmutex_unlock(&ps->stats_mutex);\r\n}\r\nstatic int __init mv88e6xxx_init(void)\r\n{\r\n#if IS_ENABLED(CONFIG_NET_DSA_MV88E6131)\r\nregister_switch_driver(&mv88e6131_switch_driver);\r\n#endif\r\n#if IS_ENABLED(CONFIG_NET_DSA_MV88E6123_61_65)\r\nregister_switch_driver(&mv88e6123_61_65_switch_driver);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit mv88e6xxx_cleanup(void)\r\n{\r\n#if IS_ENABLED(CONFIG_NET_DSA_MV88E6123_61_65)\r\nunregister_switch_driver(&mv88e6123_61_65_switch_driver);\r\n#endif\r\n#if IS_ENABLED(CONFIG_NET_DSA_MV88E6131)\r\nunregister_switch_driver(&mv88e6131_switch_driver);\r\n#endif\r\n}
