static int amd_ec_wait_write(struct amd_smbus *smbus)\r\n{\r\nint timeout = 500;\r\nwhile ((inb(smbus->base + AMD_EC_SC) & AMD_EC_SC_IBF) && --timeout)\r\nudelay(1);\r\nif (!timeout) {\r\ndev_warn(&smbus->dev->dev,\r\n"Timeout while waiting for IBF to clear\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd_ec_wait_read(struct amd_smbus *smbus)\r\n{\r\nint timeout = 500;\r\nwhile ((~inb(smbus->base + AMD_EC_SC) & AMD_EC_SC_OBF) && --timeout)\r\nudelay(1);\r\nif (!timeout) {\r\ndev_warn(&smbus->dev->dev,\r\n"Timeout while waiting for OBF to set\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd_ec_read(struct amd_smbus *smbus, unsigned char address,\r\nunsigned char *data)\r\n{\r\nint status;\r\nstatus = amd_ec_wait_write(smbus);\r\nif (status)\r\nreturn status;\r\noutb(AMD_EC_CMD_RD, smbus->base + AMD_EC_CMD);\r\nstatus = amd_ec_wait_write(smbus);\r\nif (status)\r\nreturn status;\r\noutb(address, smbus->base + AMD_EC_DATA);\r\nstatus = amd_ec_wait_read(smbus);\r\nif (status)\r\nreturn status;\r\n*data = inb(smbus->base + AMD_EC_DATA);\r\nreturn 0;\r\n}\r\nstatic int amd_ec_write(struct amd_smbus *smbus, unsigned char address,\r\nunsigned char data)\r\n{\r\nint status;\r\nstatus = amd_ec_wait_write(smbus);\r\nif (status)\r\nreturn status;\r\noutb(AMD_EC_CMD_WR, smbus->base + AMD_EC_CMD);\r\nstatus = amd_ec_wait_write(smbus);\r\nif (status)\r\nreturn status;\r\noutb(address, smbus->base + AMD_EC_DATA);\r\nstatus = amd_ec_wait_write(smbus);\r\nif (status)\r\nreturn status;\r\noutb(data, smbus->base + AMD_EC_DATA);\r\nreturn 0;\r\n}\r\nstatic s32 amd8111_access(struct i2c_adapter * adap, u16 addr,\r\nunsigned short flags, char read_write, u8 command, int size,\r\nunion i2c_smbus_data * data)\r\n{\r\nstruct amd_smbus *smbus = adap->algo_data;\r\nunsigned char protocol, len, pec, temp[2];\r\nint i, status;\r\nprotocol = (read_write == I2C_SMBUS_READ) ? AMD_SMB_PRTCL_READ\r\n: AMD_SMB_PRTCL_WRITE;\r\npec = (flags & I2C_CLIENT_PEC) ? AMD_SMB_PRTCL_PEC : 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\nprotocol |= AMD_SMB_PRTCL_QUICK;\r\nread_write = I2C_SMBUS_WRITE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD,\r\ncommand);\r\nif (status)\r\nreturn status;\r\n}\r\nprotocol |= AMD_SMB_PRTCL_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nstatus = amd_ec_write(smbus, AMD_SMB_DATA,\r\ndata->byte);\r\nif (status)\r\nreturn status;\r\n}\r\nprotocol |= AMD_SMB_PRTCL_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nstatus = amd_ec_write(smbus, AMD_SMB_DATA,\r\ndata->word & 0xff);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\r\ndata->word >> 8);\r\nif (status)\r\nreturn status;\r\n}\r\nprotocol |= AMD_SMB_PRTCL_WORD_DATA | pec;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = min_t(u8, data->block[0],\r\nI2C_SMBUS_BLOCK_MAX);\r\nstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\r\nif (status)\r\nreturn status;\r\nfor (i = 0; i < len; i++) {\r\nstatus =\r\namd_ec_write(smbus, AMD_SMB_DATA + i,\r\ndata->block[i + 1]);\r\nif (status)\r\nreturn status;\r\n}\r\n}\r\nprotocol |= AMD_SMB_PRTCL_BLOCK_DATA | pec;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nlen = min_t(u8, data->block[0],\r\nI2C_SMBUS_BLOCK_MAX);\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\r\nif (status)\r\nreturn status;\r\nif (read_write == I2C_SMBUS_WRITE)\r\nfor (i = 0; i < len; i++) {\r\nstatus =\r\namd_ec_write(smbus, AMD_SMB_DATA + i,\r\ndata->block[i + 1]);\r\nif (status)\r\nreturn status;\r\n}\r\nprotocol |= AMD_SMB_PRTCL_I2C_BLOCK_DATA;\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_write(smbus, AMD_SMB_DATA,\r\ndata->word & 0xff);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_write(smbus, AMD_SMB_DATA + 1,\r\ndata->word >> 8);\r\nif (status)\r\nreturn status;\r\nprotocol = AMD_SMB_PRTCL_PROC_CALL | pec;\r\nread_write = I2C_SMBUS_READ;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nlen = min_t(u8, data->block[0],\r\nI2C_SMBUS_BLOCK_MAX - 1);\r\nstatus = amd_ec_write(smbus, AMD_SMB_CMD, command);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_write(smbus, AMD_SMB_BCNT, len);\r\nif (status)\r\nreturn status;\r\nfor (i = 0; i < len; i++) {\r\nstatus = amd_ec_write(smbus, AMD_SMB_DATA + i,\r\ndata->block[i + 1]);\r\nif (status)\r\nreturn status;\r\n}\r\nprotocol = AMD_SMB_PRTCL_BLOCK_PROC_CALL | pec;\r\nread_write = I2C_SMBUS_READ;\r\nbreak;\r\ndefault:\r\ndev_warn(&adap->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatus = amd_ec_write(smbus, AMD_SMB_ADDR, addr << 1);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_write(smbus, AMD_SMB_PRTCL, protocol);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\r\nif (status)\r\nreturn status;\r\nif (~temp[0] & AMD_SMB_STS_DONE) {\r\nudelay(500);\r\nstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\r\nif (status)\r\nreturn status;\r\n}\r\nif (~temp[0] & AMD_SMB_STS_DONE) {\r\nmsleep(1);\r\nstatus = amd_ec_read(smbus, AMD_SMB_STS, temp + 0);\r\nif (status)\r\nreturn status;\r\n}\r\nif ((~temp[0] & AMD_SMB_STS_DONE) || (temp[0] & AMD_SMB_STS_STATUS))\r\nreturn -EIO;\r\nif (read_write == I2C_SMBUS_WRITE)\r\nreturn 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE:\r\ncase I2C_SMBUS_BYTE_DATA:\r\nstatus = amd_ec_read(smbus, AMD_SMB_DATA, &data->byte);\r\nif (status)\r\nreturn status;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\ncase I2C_SMBUS_PROC_CALL:\r\nstatus = amd_ec_read(smbus, AMD_SMB_DATA, temp + 0);\r\nif (status)\r\nreturn status;\r\nstatus = amd_ec_read(smbus, AMD_SMB_DATA + 1, temp + 1);\r\nif (status)\r\nreturn status;\r\ndata->word = (temp[1] << 8) | temp[0];\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\ncase I2C_SMBUS_BLOCK_PROC_CALL:\r\nstatus = amd_ec_read(smbus, AMD_SMB_BCNT, &len);\r\nif (status)\r\nreturn status;\r\nlen = min_t(u8, len, I2C_SMBUS_BLOCK_MAX);\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nfor (i = 0; i < len; i++) {\r\nstatus = amd_ec_read(smbus, AMD_SMB_DATA + i,\r\ndata->block + i + 1);\r\nif (status)\r\nreturn status;\r\n}\r\ndata->block[0] = len;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 amd8111_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BLOCK_DATA |\r\nI2C_FUNC_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_BLOCK_PROC_CALL |\r\nI2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_PEC;\r\n}\r\nstatic int __devinit amd8111_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct amd_smbus *smbus;\r\nint error;\r\nif (!(pci_resource_flags(dev, 0) & IORESOURCE_IO))\r\nreturn -ENODEV;\r\nsmbus = kzalloc(sizeof(struct amd_smbus), GFP_KERNEL);\r\nif (!smbus)\r\nreturn -ENOMEM;\r\nsmbus->dev = dev;\r\nsmbus->base = pci_resource_start(dev, 0);\r\nsmbus->size = pci_resource_len(dev, 0);\r\nerror = acpi_check_resource_conflict(&dev->resource[0]);\r\nif (error) {\r\nerror = -ENODEV;\r\ngoto out_kfree;\r\n}\r\nif (!request_region(smbus->base, smbus->size, amd8111_driver.name)) {\r\nerror = -EBUSY;\r\ngoto out_kfree;\r\n}\r\nsmbus->adapter.owner = THIS_MODULE;\r\nsnprintf(smbus->adapter.name, sizeof(smbus->adapter.name),\r\n"SMBus2 AMD8111 adapter at %04x", smbus->base);\r\nsmbus->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nsmbus->adapter.algo = &smbus_algorithm;\r\nsmbus->adapter.algo_data = smbus;\r\nsmbus->adapter.dev.parent = &dev->dev;\r\npci_write_config_dword(smbus->dev, AMD_PCI_MISC, 0);\r\nerror = i2c_add_adapter(&smbus->adapter);\r\nif (error)\r\ngoto out_release_region;\r\npci_set_drvdata(dev, smbus);\r\nreturn 0;\r\nout_release_region:\r\nrelease_region(smbus->base, smbus->size);\r\nout_kfree:\r\nkfree(smbus);\r\nreturn error;\r\n}\r\nstatic void __devexit amd8111_remove(struct pci_dev *dev)\r\n{\r\nstruct amd_smbus *smbus = pci_get_drvdata(dev);\r\ni2c_del_adapter(&smbus->adapter);\r\nrelease_region(smbus->base, smbus->size);\r\nkfree(smbus);\r\n}\r\nstatic int __init i2c_amd8111_init(void)\r\n{\r\nreturn pci_register_driver(&amd8111_driver);\r\n}\r\nstatic void __exit i2c_amd8111_exit(void)\r\n{\r\npci_unregister_driver(&amd8111_driver);\r\n}
