static void ehci_clock_enable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ehci_mv->clknum; i++)\r\nclk_enable(ehci_mv->clk[i]);\r\n}\r\nstatic void ehci_clock_disable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ehci_mv->clknum; i++)\r\nclk_disable(ehci_mv->clk[i]);\r\n}\r\nstatic int mv_ehci_enable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nint retval;\r\nehci_clock_enable(ehci_mv);\r\nif (ehci_mv->pdata->phy_init) {\r\nretval = ehci_mv->pdata->phy_init(ehci_mv->phy_regs);\r\nif (retval)\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mv_ehci_disable(struct ehci_hcd_mv *ehci_mv)\r\n{\r\nif (ehci_mv->pdata->phy_deinit)\r\nehci_mv->pdata->phy_deinit(ehci_mv->phy_regs);\r\nehci_clock_disable(ehci_mv);\r\n}\r\nstatic int mv_ehci_reset(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct ehci_hcd_mv *ehci_mv = dev_get_drvdata(dev);\r\nint retval;\r\nif (ehci_mv == NULL) {\r\ndev_err(dev, "Can not find private ehci data\n");\r\nreturn -ENODEV;\r\n}\r\nretval = ehci_init(hcd);\r\nif (retval) {\r\ndev_err(dev, "ehci_init failed %d\n", retval);\r\nreturn retval;\r\n}\r\nhcd->has_tt = 1;\r\nehci->sbrn = 0x20;\r\nretval = ehci_reset(ehci);\r\nif (retval) {\r\ndev_err(dev, "ehci_reset failed %d\n", retval);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv_ehci_probe(struct platform_device *pdev)\r\n{\r\nstruct mv_usb_platform_data *pdata = pdev->dev.platform_data;\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct ehci_hcd_mv *ehci_mv;\r\nstruct resource *r;\r\nint clk_i, retval = -ENODEV;\r\nu32 offset;\r\nsize_t size;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "missing platform_data\n");\r\nreturn -ENODEV;\r\n}\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nhcd = usb_create_hcd(&mv_ehci_hc_driver, &pdev->dev, "mv ehci");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nsize = sizeof(*ehci_mv) + sizeof(struct clk *) * pdata->clknum;\r\nehci_mv = kzalloc(size, GFP_KERNEL);\r\nif (ehci_mv == NULL) {\r\ndev_err(&pdev->dev, "cannot allocate ehci_hcd_mv\n");\r\nretval = -ENOMEM;\r\ngoto err_put_hcd;\r\n}\r\nplatform_set_drvdata(pdev, ehci_mv);\r\nehci_mv->pdata = pdata;\r\nehci_mv->hcd = hcd;\r\nehci_mv->clknum = pdata->clknum;\r\nfor (clk_i = 0; clk_i < ehci_mv->clknum; clk_i++) {\r\nehci_mv->clk[clk_i] =\r\nclk_get(&pdev->dev, pdata->clkname[clk_i]);\r\nif (IS_ERR(ehci_mv->clk[clk_i])) {\r\ndev_err(&pdev->dev, "error get clck \"%s\"\n",\r\npdata->clkname[clk_i]);\r\nretval = PTR_ERR(ehci_mv->clk[clk_i]);\r\ngoto err_put_clk;\r\n}\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phyregs");\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no phy I/O memory resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_put_clk;\r\n}\r\nehci_mv->phy_regs = ioremap(r->start, resource_size(r));\r\nif (ehci_mv->phy_regs == 0) {\r\ndev_err(&pdev->dev, "failed to map phy I/O memory\n");\r\nretval = -EFAULT;\r\ngoto err_put_clk;\r\n}\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, "capregs");\r\nif (!r) {\r\ndev_err(&pdev->dev, "no I/O memory resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_iounmap_phyreg;\r\n}\r\nehci_mv->cap_regs = ioremap(r->start, resource_size(r));\r\nif (ehci_mv->cap_regs == NULL) {\r\ndev_err(&pdev->dev, "failed to map I/O memory\n");\r\nretval = -EFAULT;\r\ngoto err_iounmap_phyreg;\r\n}\r\nretval = mv_ehci_enable(ehci_mv);\r\nif (retval) {\r\ndev_err(&pdev->dev, "init phy error %d\n", retval);\r\ngoto err_iounmap_capreg;\r\n}\r\noffset = readl(ehci_mv->cap_regs) & CAPLENGTH_MASK;\r\nehci_mv->op_regs =\r\n(void __iomem *) ((unsigned long) ehci_mv->cap_regs + offset);\r\nhcd->rsrc_start = r->start;\r\nhcd->rsrc_len = r->end - r->start + 1;\r\nhcd->regs = ehci_mv->op_regs;\r\nhcd->irq = platform_get_irq(pdev, 0);\r\nif (!hcd->irq) {\r\ndev_err(&pdev->dev, "Cannot get irq.");\r\nretval = -ENODEV;\r\ngoto err_disable_clk;\r\n}\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = (struct ehci_caps *) ehci_mv->cap_regs;\r\nehci->regs = (struct ehci_regs *) ehci_mv->op_regs;\r\nehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);\r\nehci_mv->mode = pdata->mode;\r\nif (ehci_mv->mode == MV_USB_MODE_OTG) {\r\n#ifdef CONFIG_USB_OTG_UTILS\r\nehci_mv->otg = usb_get_transceiver();\r\nif (!ehci_mv->otg) {\r\ndev_err(&pdev->dev,\r\n"unable to find transceiver\n");\r\nretval = -ENODEV;\r\ngoto err_disable_clk;\r\n}\r\nretval = otg_set_host(ehci_mv->otg->otg, &hcd->self);\r\nif (retval < 0) {\r\ndev_err(&pdev->dev,\r\n"unable to register with transceiver\n");\r\nretval = -ENODEV;\r\ngoto err_put_transceiver;\r\n}\r\nmv_ehci_disable(ehci_mv);\r\n#else\r\ndev_info(&pdev->dev, "MV_USB_MODE_OTG "\r\n"must have CONFIG_USB_OTG_UTILS enabled\n");\r\ngoto err_disable_clk;\r\n#endif\r\n} else {\r\nif (pdata->set_vbus)\r\npdata->set_vbus(1);\r\nretval = usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\r\nif (retval) {\r\ndev_err(&pdev->dev,\r\n"failed to add hcd with err %d\n", retval);\r\ngoto err_set_vbus;\r\n}\r\n}\r\nif (pdata->private_init)\r\npdata->private_init(ehci_mv->op_regs, ehci_mv->phy_regs);\r\ndev_info(&pdev->dev,\r\n"successful find EHCI device with regs 0x%p irq %d"\r\n" working in %s mode\n", hcd->regs, hcd->irq,\r\nehci_mv->mode == MV_USB_MODE_OTG ? "OTG" : "Host");\r\nreturn 0;\r\nerr_set_vbus:\r\nif (pdata->set_vbus)\r\npdata->set_vbus(0);\r\n#ifdef CONFIG_USB_OTG_UTILS\r\nerr_put_transceiver:\r\nif (ehci_mv->otg)\r\nusb_put_transceiver(ehci_mv->otg);\r\n#endif\r\nerr_disable_clk:\r\nmv_ehci_disable(ehci_mv);\r\nerr_iounmap_capreg:\r\niounmap(ehci_mv->cap_regs);\r\nerr_iounmap_phyreg:\r\niounmap(ehci_mv->phy_regs);\r\nerr_put_clk:\r\nfor (clk_i--; clk_i >= 0; clk_i--)\r\nclk_put(ehci_mv->clk[clk_i]);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(ehci_mv);\r\nerr_put_hcd:\r\nusb_put_hcd(hcd);\r\nreturn retval;\r\n}\r\nstatic int mv_ehci_remove(struct platform_device *pdev)\r\n{\r\nstruct ehci_hcd_mv *ehci_mv = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_mv->hcd;\r\nint clk_i;\r\nif (hcd->rh_registered)\r\nusb_remove_hcd(hcd);\r\nif (ehci_mv->otg) {\r\notg_set_host(ehci_mv->otg->otg, NULL);\r\nusb_put_transceiver(ehci_mv->otg);\r\n}\r\nif (ehci_mv->mode == MV_USB_MODE_HOST) {\r\nif (ehci_mv->pdata->set_vbus)\r\nehci_mv->pdata->set_vbus(0);\r\nmv_ehci_disable(ehci_mv);\r\n}\r\niounmap(ehci_mv->cap_regs);\r\niounmap(ehci_mv->phy_regs);\r\nfor (clk_i = 0; clk_i < ehci_mv->clknum; clk_i++)\r\nclk_put(ehci_mv->clk[clk_i]);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(ehci_mv);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic void mv_ehci_shutdown(struct platform_device *pdev)\r\n{\r\nstruct ehci_hcd_mv *ehci_mv = platform_get_drvdata(pdev);\r\nstruct usb_hcd *hcd = ehci_mv->hcd;\r\nif (!hcd->rh_registered)\r\nreturn;\r\nif (hcd->driver->shutdown)\r\nhcd->driver->shutdown(hcd);\r\n}
