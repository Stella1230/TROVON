static int snd_wss_xrate(struct snd_pcm_runtime *runtime)\r\n{\r\nreturn snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_rates);\r\n}\r\nstatic inline void wss_outb(struct snd_wss *chip, u8 offset, u8 val)\r\n{\r\noutb(val, chip->port + offset);\r\n}\r\nstatic inline u8 wss_inb(struct snd_wss *chip, u8 offset)\r\n{\r\nreturn inb(chip->port + offset);\r\n}\r\nstatic void snd_wss_wait(struct snd_wss *chip)\r\n{\r\nint timeout;\r\nfor (timeout = 250;\r\ntimeout > 0 && (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT);\r\ntimeout--)\r\nudelay(100);\r\n}\r\nstatic void snd_wss_dout(struct snd_wss *chip, unsigned char reg,\r\nunsigned char value)\r\n{\r\nint timeout;\r\nfor (timeout = 250;\r\ntimeout > 0 && (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT);\r\ntimeout--)\r\nudelay(10);\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);\r\nwss_outb(chip, CS4231P(REG), value);\r\nmb();\r\n}\r\nvoid snd_wss_out(struct snd_wss *chip, unsigned char reg, unsigned char value)\r\n{\r\nsnd_wss_wait(chip);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\r\nsnd_printk(KERN_DEBUG "out: auto calibration time out "\r\n"- reg = 0x%x, value = 0x%x\n", reg, value);\r\n#endif\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);\r\nwss_outb(chip, CS4231P(REG), value);\r\nchip->image[reg] = value;\r\nmb();\r\nsnd_printdd("codec out - reg 0x%x = 0x%x\n",\r\nchip->mce_bit | reg, value);\r\n}\r\nunsigned char snd_wss_in(struct snd_wss *chip, unsigned char reg)\r\n{\r\nsnd_wss_wait(chip);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\r\nsnd_printk(KERN_DEBUG "in: auto calibration time out "\r\n"- reg = 0x%x\n", reg);\r\n#endif\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | reg);\r\nmb();\r\nreturn wss_inb(chip, CS4231P(REG));\r\n}\r\nvoid snd_cs4236_ext_out(struct snd_wss *chip, unsigned char reg,\r\nunsigned char val)\r\n{\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | 0x17);\r\nwss_outb(chip, CS4231P(REG),\r\nreg | (chip->image[CS4236_EXT_REG] & 0x01));\r\nwss_outb(chip, CS4231P(REG), val);\r\nchip->eimage[CS4236_REG(reg)] = val;\r\n#if 0\r\nprintk(KERN_DEBUG "ext out : reg = 0x%x, val = 0x%x\n", reg, val);\r\n#endif\r\n}\r\nunsigned char snd_cs4236_ext_in(struct snd_wss *chip, unsigned char reg)\r\n{\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | 0x17);\r\nwss_outb(chip, CS4231P(REG),\r\nreg | (chip->image[CS4236_EXT_REG] & 0x01));\r\n#if 1\r\nreturn wss_inb(chip, CS4231P(REG));\r\n#else\r\n{\r\nunsigned char res;\r\nres = wss_inb(chip, CS4231P(REG));\r\nprintk(KERN_DEBUG "ext in : reg = 0x%x, val = 0x%x\n",\r\nreg, res);\r\nreturn res;\r\n}\r\n#endif\r\n}\r\nstatic void snd_wss_busy_wait(struct snd_wss *chip)\r\n{\r\nint timeout;\r\nfor (timeout = 5; timeout > 0; timeout--)\r\nwss_inb(chip, CS4231P(REGSEL));\r\nfor (timeout = 25000;\r\ntimeout > 0 && (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT);\r\ntimeout--)\r\nudelay(10);\r\n}\r\nvoid snd_wss_mce_up(struct snd_wss *chip)\r\n{\r\nunsigned long flags;\r\nint timeout;\r\nsnd_wss_wait(chip);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\r\nsnd_printk(KERN_DEBUG\r\n"mce_up - auto calibration time out (0)\n");\r\n#endif\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->mce_bit |= CS4231_MCE;\r\ntimeout = wss_inb(chip, CS4231P(REGSEL));\r\nif (timeout == 0x80)\r\nsnd_printk(KERN_DEBUG "mce_up [0x%lx]: "\r\n"serious init problem - codec still busy\n",\r\nchip->port);\r\nif (!(timeout & CS4231_MCE))\r\nwss_outb(chip, CS4231P(REGSEL),\r\nchip->mce_bit | (timeout & 0x1f));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nvoid snd_wss_mce_down(struct snd_wss *chip)\r\n{\r\nunsigned long flags;\r\nunsigned long end_time;\r\nint timeout;\r\nint hw_mask = WSS_HW_CS4231_MASK | WSS_HW_CS4232_MASK | WSS_HW_AD1848;\r\nsnd_wss_busy_wait(chip);\r\n#ifdef CONFIG_SND_DEBUG\r\nif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\r\nsnd_printk(KERN_DEBUG "mce_down [0x%lx] - "\r\n"auto calibration time out (0)\n",\r\n(long)CS4231P(REGSEL));\r\n#endif\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->mce_bit &= ~CS4231_MCE;\r\ntimeout = wss_inb(chip, CS4231P(REGSEL));\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | (timeout & 0x1f));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (timeout == 0x80)\r\nsnd_printk(KERN_DEBUG "mce_down [0x%lx]: "\r\n"serious init problem - codec still busy\n",\r\nchip->port);\r\nif ((timeout & CS4231_MCE) == 0 || !(chip->hardware & hw_mask))\r\nreturn;\r\nmsleep(1);\r\nsnd_printdd("(1) jiffies = %lu\n", jiffies);\r\nend_time = jiffies + msecs_to_jiffies(250);\r\nwhile (snd_wss_in(chip, CS4231_TEST_INIT) &\r\nCS4231_CALIB_IN_PROGRESS) {\r\nif (time_after(jiffies, end_time)) {\r\nsnd_printk(KERN_ERR "mce_down - "\r\n"auto calibration time out (2)\n");\r\nreturn;\r\n}\r\nmsleep(1);\r\n}\r\nsnd_printdd("(2) jiffies = %lu\n", jiffies);\r\nend_time = jiffies + msecs_to_jiffies(100);\r\nwhile (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT) {\r\nif (time_after(jiffies, end_time)) {\r\nsnd_printk(KERN_ERR "mce_down - auto calibration time out (3)\n");\r\nreturn;\r\n}\r\nmsleep(1);\r\n}\r\nsnd_printdd("(3) jiffies = %lu\n", jiffies);\r\nsnd_printd("mce_down - exit = 0x%x\n", wss_inb(chip, CS4231P(REGSEL)));\r\n}\r\nstatic unsigned int snd_wss_get_count(unsigned char format, unsigned int size)\r\n{\r\nswitch (format & 0xe0) {\r\ncase CS4231_LINEAR_16:\r\ncase CS4231_LINEAR_16_BIG:\r\nsize >>= 1;\r\nbreak;\r\ncase CS4231_ADPCM_16:\r\nreturn size >> 2;\r\n}\r\nif (format & CS4231_STEREO)\r\nsize >>= 1;\r\nreturn size;\r\n}\r\nstatic int snd_wss_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nunsigned int what;\r\nstruct snd_pcm_substream *s;\r\nint do_start;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ndo_start = 1; break;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndo_start = 0; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwhat = 0;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == chip->playback_substream) {\r\nwhat |= CS4231_PLAYBACK_ENABLE;\r\nsnd_pcm_trigger_done(s, substream);\r\n} else if (s == chip->capture_substream) {\r\nwhat |= CS4231_RECORD_ENABLE;\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\n}\r\nspin_lock(&chip->reg_lock);\r\nif (do_start) {\r\nchip->image[CS4231_IFACE_CTRL] |= what;\r\nif (chip->trigger)\r\nchip->trigger(chip, what, 1);\r\n} else {\r\nchip->image[CS4231_IFACE_CTRL] &= ~what;\r\nif (chip->trigger)\r\nchip->trigger(chip, what, 0);\r\n}\r\nsnd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\r\nspin_unlock(&chip->reg_lock);\r\n#if 0\r\nsnd_wss_debug(chip);\r\n#endif\r\nreturn result;\r\n}\r\nstatic unsigned char snd_wss_get_rate(unsigned int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rates); i++)\r\nif (rate == rates[i])\r\nreturn freq_bits[i];\r\nreturn freq_bits[ARRAY_SIZE(rates) - 1];\r\n}\r\nstatic unsigned char snd_wss_get_format(struct snd_wss *chip,\r\nint format,\r\nint channels)\r\n{\r\nunsigned char rformat;\r\nrformat = CS4231_LINEAR_8;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_MU_LAW: rformat = CS4231_ULAW_8; break;\r\ncase SNDRV_PCM_FORMAT_A_LAW: rformat = CS4231_ALAW_8; break;\r\ncase SNDRV_PCM_FORMAT_S16_LE: rformat = CS4231_LINEAR_16; break;\r\ncase SNDRV_PCM_FORMAT_S16_BE: rformat = CS4231_LINEAR_16_BIG; break;\r\ncase SNDRV_PCM_FORMAT_IMA_ADPCM: rformat = CS4231_ADPCM_16; break;\r\n}\r\nif (channels > 1)\r\nrformat |= CS4231_STEREO;\r\n#if 0\r\nsnd_printk(KERN_DEBUG "get_format: 0x%x (mode=0x%x)\n", format, mode);\r\n#endif\r\nreturn rformat;\r\n}\r\nstatic void snd_wss_calibrate_mute(struct snd_wss *chip, int mute)\r\n{\r\nunsigned long flags;\r\nmute = mute ? 0x80 : 0;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->calibrate_mute == mute) {\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn;\r\n}\r\nif (!mute) {\r\nsnd_wss_dout(chip, CS4231_LEFT_INPUT,\r\nchip->image[CS4231_LEFT_INPUT]);\r\nsnd_wss_dout(chip, CS4231_RIGHT_INPUT,\r\nchip->image[CS4231_RIGHT_INPUT]);\r\nsnd_wss_dout(chip, CS4231_LOOPBACK,\r\nchip->image[CS4231_LOOPBACK]);\r\n} else {\r\nsnd_wss_dout(chip, CS4231_LEFT_INPUT,\r\n0);\r\nsnd_wss_dout(chip, CS4231_RIGHT_INPUT,\r\n0);\r\nsnd_wss_dout(chip, CS4231_LOOPBACK,\r\n0xfd);\r\n}\r\nsnd_wss_dout(chip, CS4231_AUX1_LEFT_INPUT,\r\nmute | chip->image[CS4231_AUX1_LEFT_INPUT]);\r\nsnd_wss_dout(chip, CS4231_AUX1_RIGHT_INPUT,\r\nmute | chip->image[CS4231_AUX1_RIGHT_INPUT]);\r\nsnd_wss_dout(chip, CS4231_AUX2_LEFT_INPUT,\r\nmute | chip->image[CS4231_AUX2_LEFT_INPUT]);\r\nsnd_wss_dout(chip, CS4231_AUX2_RIGHT_INPUT,\r\nmute | chip->image[CS4231_AUX2_RIGHT_INPUT]);\r\nsnd_wss_dout(chip, CS4231_LEFT_OUTPUT,\r\nmute | chip->image[CS4231_LEFT_OUTPUT]);\r\nsnd_wss_dout(chip, CS4231_RIGHT_OUTPUT,\r\nmute | chip->image[CS4231_RIGHT_OUTPUT]);\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK)) {\r\nsnd_wss_dout(chip, CS4231_LEFT_LINE_IN,\r\nmute | chip->image[CS4231_LEFT_LINE_IN]);\r\nsnd_wss_dout(chip, CS4231_RIGHT_LINE_IN,\r\nmute | chip->image[CS4231_RIGHT_LINE_IN]);\r\nsnd_wss_dout(chip, CS4231_MONO_CTRL,\r\nmute ? 0xc0 : chip->image[CS4231_MONO_CTRL]);\r\n}\r\nif (chip->hardware == WSS_HW_INTERWAVE) {\r\nsnd_wss_dout(chip, CS4231_LEFT_MIC_INPUT,\r\nmute | chip->image[CS4231_LEFT_MIC_INPUT]);\r\nsnd_wss_dout(chip, CS4231_RIGHT_MIC_INPUT,\r\nmute | chip->image[CS4231_RIGHT_MIC_INPUT]);\r\nsnd_wss_dout(chip, CS4231_LINE_LEFT_OUTPUT,\r\nmute | chip->image[CS4231_LINE_LEFT_OUTPUT]);\r\nsnd_wss_dout(chip, CS4231_LINE_RIGHT_OUTPUT,\r\nmute | chip->image[CS4231_LINE_RIGHT_OUTPUT]);\r\n}\r\nchip->calibrate_mute = mute;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_wss_playback_format(struct snd_wss *chip,\r\nstruct snd_pcm_hw_params *params,\r\nunsigned char pdfr)\r\n{\r\nunsigned long flags;\r\nint full_calib = 1;\r\nmutex_lock(&chip->mce_mutex);\r\nif (chip->hardware == WSS_HW_CS4231A ||\r\n(chip->hardware & WSS_HW_CS4232_MASK)) {\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif ((chip->image[CS4231_PLAYBK_FORMAT] & 0x0f) == (pdfr & 0x0f)) {\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] | 0x10);\r\nchip->image[CS4231_PLAYBK_FORMAT] = pdfr;\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\r\nchip->image[CS4231_PLAYBK_FORMAT]);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] &= ~0x10);\r\nudelay(100);\r\nfull_calib = 0;\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n} else if (chip->hardware == WSS_HW_AD1845) {\r\nunsigned rate = params_rate(params);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, (pdfr & 0xf0));\r\nsnd_wss_out(chip, AD1845_UPR_FREQ_SEL, (rate >> 8) & 0xff);\r\nsnd_wss_out(chip, AD1845_LWR_FREQ_SEL, rate & 0xff);\r\nfull_calib = 0;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nif (full_calib) {\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->hardware != WSS_HW_INTERWAVE && !chip->single_dma) {\r\nif (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE)\r\npdfr = (pdfr & 0xf0) |\r\n(chip->image[CS4231_REC_FORMAT] & 0x0f);\r\n} else {\r\nchip->image[CS4231_PLAYBK_FORMAT] = pdfr;\r\n}\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, pdfr);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (chip->hardware == WSS_HW_OPL3SA2)\r\nudelay(100);\r\nsnd_wss_mce_down(chip);\r\n}\r\nmutex_unlock(&chip->mce_mutex);\r\n}\r\nstatic void snd_wss_capture_format(struct snd_wss *chip,\r\nstruct snd_pcm_hw_params *params,\r\nunsigned char cdfr)\r\n{\r\nunsigned long flags;\r\nint full_calib = 1;\r\nmutex_lock(&chip->mce_mutex);\r\nif (chip->hardware == WSS_HW_CS4231A ||\r\n(chip->hardware & WSS_HW_CS4232_MASK)) {\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif ((chip->image[CS4231_PLAYBK_FORMAT] & 0x0f) == (cdfr & 0x0f) ||\r\n(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] | 0x20);\r\nsnd_wss_out(chip, CS4231_REC_FORMAT,\r\nchip->image[CS4231_REC_FORMAT] = cdfr);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] &= ~0x20);\r\nfull_calib = 0;\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n} else if (chip->hardware == WSS_HW_AD1845) {\r\nunsigned rate = params_rate(params);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_REC_FORMAT, (cdfr & 0xf0));\r\nsnd_wss_out(chip, AD1845_UPR_FREQ_SEL, (rate >> 8) & 0xff);\r\nsnd_wss_out(chip, AD1845_LWR_FREQ_SEL, rate & 0xff);\r\nfull_calib = 0;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nif (full_calib) {\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->hardware != WSS_HW_INTERWAVE &&\r\n!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {\r\nif (chip->single_dma)\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, cdfr);\r\nelse\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\r\n(chip->image[CS4231_PLAYBK_FORMAT] & 0xf0) |\r\n(cdfr & 0x0f));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n}\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT, cdfr);\r\nelse\r\nsnd_wss_out(chip, CS4231_REC_FORMAT, cdfr);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\n}\r\nmutex_unlock(&chip->mce_mutex);\r\n}\r\nstatic unsigned long snd_wss_timer_resolution(struct snd_timer *timer)\r\n{\r\nstruct snd_wss *chip = snd_timer_chip(timer);\r\nif (chip->hardware & WSS_HW_CS4236B_MASK)\r\nreturn 14467;\r\nelse\r\nreturn chip->image[CS4231_PLAYBK_FORMAT] & 1 ? 9969 : 9920;\r\n}\r\nstatic int snd_wss_timer_start(struct snd_timer *timer)\r\n{\r\nunsigned long flags;\r\nunsigned int ticks;\r\nstruct snd_wss *chip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nticks = timer->sticks;\r\nif ((chip->image[CS4231_ALT_FEATURE_1] & CS4231_TIMER_ENABLE) == 0 ||\r\n(unsigned char)(ticks >> 8) != chip->image[CS4231_TIMER_HIGH] ||\r\n(unsigned char)ticks != chip->image[CS4231_TIMER_LOW]) {\r\nchip->image[CS4231_TIMER_HIGH] = (unsigned char) (ticks >> 8);\r\nsnd_wss_out(chip, CS4231_TIMER_HIGH,\r\nchip->image[CS4231_TIMER_HIGH]);\r\nchip->image[CS4231_TIMER_LOW] = (unsigned char) ticks;\r\nsnd_wss_out(chip, CS4231_TIMER_LOW,\r\nchip->image[CS4231_TIMER_LOW]);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1] |\r\nCS4231_TIMER_ENABLE);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_timer_stop(struct snd_timer *timer)\r\n{\r\nunsigned long flags;\r\nstruct snd_wss *chip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->image[CS4231_ALT_FEATURE_1] &= ~CS4231_TIMER_ENABLE;\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_1,\r\nchip->image[CS4231_ALT_FEATURE_1]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_wss_init(struct snd_wss *chip)\r\n{\r\nunsigned long flags;\r\nsnd_wss_calibrate_mute(chip, 1);\r\nsnd_wss_mce_down(chip);\r\n#ifdef SNDRV_DEBUG_MCE\r\nsnd_printk(KERN_DEBUG "init: (1)\n");\r\n#endif\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |\r\nCS4231_PLAYBACK_PIO |\r\nCS4231_RECORD_ENABLE |\r\nCS4231_RECORD_PIO |\r\nCS4231_CALIB_MODE);\r\nchip->image[CS4231_IFACE_CTRL] |= CS4231_AUTOCALIB;\r\nsnd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\n#ifdef SNDRV_DEBUG_MCE\r\nsnd_printk(KERN_DEBUG "init: (2)\n");\r\n#endif\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->image[CS4231_IFACE_CTRL] &= ~CS4231_AUTOCALIB;\r\nsnd_wss_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\r\nsnd_wss_out(chip,\r\nCS4231_ALT_FEATURE_1, chip->image[CS4231_ALT_FEATURE_1]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\n#ifdef SNDRV_DEBUG_MCE\r\nsnd_printk(KERN_DEBUG "init: (3) - afei = 0x%x\n",\r\nchip->image[CS4231_ALT_FEATURE_1]);\r\n#endif\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_ALT_FEATURE_2,\r\nchip->image[CS4231_ALT_FEATURE_2]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_PLAYBK_FORMAT,\r\nchip->image[CS4231_PLAYBK_FORMAT]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\n#ifdef SNDRV_DEBUG_MCE\r\nsnd_printk(KERN_DEBUG "init: (4)\n");\r\n#endif\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK))\r\nsnd_wss_out(chip, CS4231_REC_FORMAT,\r\nchip->image[CS4231_REC_FORMAT]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\nsnd_wss_calibrate_mute(chip, 0);\r\n#ifdef SNDRV_DEBUG_MCE\r\nsnd_printk(KERN_DEBUG "init: (5)\n");\r\n#endif\r\n}\r\nstatic int snd_wss_open(struct snd_wss *chip, unsigned int mode)\r\n{\r\nunsigned long flags;\r\nmutex_lock(&chip->open_mutex);\r\nif ((chip->mode & mode) ||\r\n((chip->mode & WSS_MODE_OPEN) && chip->single_dma)) {\r\nmutex_unlock(&chip->open_mutex);\r\nreturn -EAGAIN;\r\n}\r\nif (chip->mode & WSS_MODE_OPEN) {\r\nchip->mode |= mode;\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK)) {\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS,\r\nCS4231_PLAYBACK_IRQ |\r\nCS4231_RECORD_IRQ |\r\nCS4231_TIMER_IRQ);\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\r\n}\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nchip->image[CS4231_PIN_CTRL] |= CS4231_IRQ_ENABLE;\r\nsnd_wss_out(chip, CS4231_PIN_CTRL, chip->image[CS4231_PIN_CTRL]);\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK)) {\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS,\r\nCS4231_PLAYBACK_IRQ |\r\nCS4231_RECORD_IRQ |\r\nCS4231_TIMER_IRQ);\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nchip->mode = mode;\r\nmutex_unlock(&chip->open_mutex);\r\nreturn 0;\r\n}\r\nstatic void snd_wss_close(struct snd_wss *chip, unsigned int mode)\r\n{\r\nunsigned long flags;\r\nmutex_lock(&chip->open_mutex);\r\nchip->mode &= ~mode;\r\nif (chip->mode & WSS_MODE_OPEN) {\r\nmutex_unlock(&chip->open_mutex);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK))\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nchip->image[CS4231_PIN_CTRL] &= ~CS4231_IRQ_ENABLE;\r\nsnd_wss_out(chip, CS4231_PIN_CTRL, chip->image[CS4231_PIN_CTRL]);\r\nif (chip->image[CS4231_IFACE_CTRL] & (CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |\r\nCS4231_RECORD_ENABLE | CS4231_RECORD_PIO)) {\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |\r\nCS4231_RECORD_ENABLE | CS4231_RECORD_PIO);\r\nsnd_wss_out(chip, CS4231_IFACE_CTRL,\r\nchip->image[CS4231_IFACE_CTRL]);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_down(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n}\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK))\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS, 0);\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nchip->mode = 0;\r\nmutex_unlock(&chip->open_mutex);\r\n}\r\nstatic int snd_wss_timer_open(struct snd_timer *timer)\r\n{\r\nstruct snd_wss *chip = snd_timer_chip(timer);\r\nsnd_wss_open(chip, WSS_MODE_TIMER);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_timer_close(struct snd_timer *timer)\r\n{\r\nstruct snd_wss *chip = snd_timer_chip(timer);\r\nsnd_wss_close(chip, WSS_MODE_TIMER);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nunsigned char new_pdfr;\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nnew_pdfr = snd_wss_get_format(chip, params_format(hw_params),\r\nparams_channels(hw_params)) |\r\nsnd_wss_get_rate(params_rate(hw_params));\r\nchip->set_playback_format(chip, hw_params, new_pdfr);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_wss_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long flags;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->p_dma_size = size;\r\nchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO);\r\nsnd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\r\ncount = snd_wss_get_count(chip->image[CS4231_PLAYBK_FORMAT], count) - 1;\r\nsnd_wss_out(chip, CS4231_PLY_LWR_CNT, (unsigned char) count);\r\nsnd_wss_out(chip, CS4231_PLY_UPR_CNT, (unsigned char) (count >> 8));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n#if 0\r\nsnd_wss_debug(chip);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_wss_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nunsigned char new_cdfr;\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nnew_cdfr = snd_wss_get_format(chip, params_format(hw_params),\r\nparams_channels(hw_params)) |\r\nsnd_wss_get_rate(params_rate(hw_params));\r\nchip->set_capture_format(chip, hw_params, new_cdfr);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_wss_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long flags;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->c_dma_size = size;\r\nchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_RECORD_ENABLE | CS4231_RECORD_PIO);\r\nsnd_dma_program(chip->dma2, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\ncount = snd_wss_get_count(chip->image[CS4231_PLAYBK_FORMAT],\r\ncount);\r\nelse\r\ncount = snd_wss_get_count(chip->image[CS4231_REC_FORMAT],\r\ncount);\r\ncount--;\r\nif (chip->single_dma && chip->hardware != WSS_HW_INTERWAVE) {\r\nsnd_wss_out(chip, CS4231_PLY_LWR_CNT, (unsigned char) count);\r\nsnd_wss_out(chip, CS4231_PLY_UPR_CNT,\r\n(unsigned char) (count >> 8));\r\n} else {\r\nsnd_wss_out(chip, CS4231_REC_LWR_CNT, (unsigned char) count);\r\nsnd_wss_out(chip, CS4231_REC_UPR_CNT,\r\n(unsigned char) (count >> 8));\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nvoid snd_wss_overrange(struct snd_wss *chip)\r\n{\r\nunsigned long flags;\r\nunsigned char res;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nres = snd_wss_in(chip, CS4231_TEST_INIT);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (res & (0x08 | 0x02))\r\nchip->capture_substream->runtime->overrange++;\r\n}\r\nirqreturn_t snd_wss_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_wss *chip = dev_id;\r\nunsigned char status;\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\nstatus = CS4231_PLAYBACK_IRQ;\r\nelse\r\nstatus = snd_wss_in(chip, CS4231_IRQ_STATUS);\r\nif (status & CS4231_TIMER_IRQ) {\r\nif (chip->timer)\r\nsnd_timer_interrupt(chip->timer, chip->timer->sticks);\r\n}\r\nif (chip->single_dma && chip->hardware != WSS_HW_INTERWAVE) {\r\nif (status & CS4231_PLAYBACK_IRQ) {\r\nif (chip->mode & WSS_MODE_PLAY) {\r\nif (chip->playback_substream)\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\n}\r\nif (chip->mode & WSS_MODE_RECORD) {\r\nif (chip->capture_substream) {\r\nsnd_wss_overrange(chip);\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\n}\r\n}\r\n}\r\n} else {\r\nif (status & CS4231_PLAYBACK_IRQ) {\r\nif (chip->playback_substream)\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\n}\r\nif (status & CS4231_RECORD_IRQ) {\r\nif (chip->capture_substream) {\r\nsnd_wss_overrange(chip);\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\n}\r\n}\r\n}\r\nspin_lock(&chip->reg_lock);\r\nstatus = ~CS4231_ALL_IRQS | ~status;\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nelse\r\nsnd_wss_out(chip, CS4231_IRQ_STATUS, status);\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_wss_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE))\r\nreturn 0;\r\nptr = snd_dma_pointer(chip->dma1, chip->p_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_wss_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE))\r\nreturn 0;\r\nptr = snd_dma_pointer(chip->dma2, chip->c_dma_size);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_ad1848_probe(struct snd_wss *chip)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nunsigned long flags;\r\nunsigned char r;\r\nunsigned short hardware = 0;\r\nint err = 0;\r\nint i;\r\nwhile (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT) {\r\nif (time_after(jiffies, timeout))\r\nreturn -ENODEV;\r\ncond_resched();\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_dout(chip, CS4231_MISC_INFO, 0);\r\nsnd_wss_dout(chip, CS4231_RIGHT_INPUT, 0x45);\r\nr = snd_wss_in(chip, CS4231_RIGHT_INPUT);\r\nif (r != 0x45) {\r\nif ((r & ~CS4231_ENABLE_MIC_GAIN) != 0x45) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nhardware = WSS_HW_AD1847;\r\n} else {\r\nsnd_wss_dout(chip, CS4231_LEFT_INPUT, 0xaa);\r\nr = snd_wss_in(chip, CS4231_LEFT_INPUT);\r\nif ((r | CS4231_ENABLE_MIC_GAIN) != 0xaa) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nwss_inb(chip, CS4231P(STATUS));\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nmb();\r\nif ((chip->hardware & WSS_HW_TYPE_MASK) != WSS_HW_DETECT)\r\ngoto out;\r\nif (hardware) {\r\nchip->hardware = hardware;\r\ngoto out;\r\n}\r\nr = snd_wss_in(chip, CS4231_MISC_INFO);\r\nsnd_wss_dout(chip, CS4231_MISC_INFO, CS4231_MODE2);\r\nfor (i = 0; i < 16; i++) {\r\nif (snd_wss_in(chip, i) != snd_wss_in(chip, 16 + i)) {\r\nif ((r & 0xf) != 0xa)\r\ngoto out_mode;\r\nsnd_wss_dout(chip, CS4231_VERSION, 0);\r\nr = snd_wss_in(chip, CS4231_VERSION) & 0xe7;\r\nif (!r)\r\nchip->hardware = WSS_HW_CMI8330;\r\ngoto out_mode;\r\n}\r\n}\r\nif (r & 0x80)\r\nchip->hardware = WSS_HW_CS4248;\r\nelse\r\nchip->hardware = WSS_HW_AD1848;\r\nout_mode:\r\nsnd_wss_dout(chip, CS4231_MISC_INFO, 0);\r\nout:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn err;\r\n}\r\nstatic int snd_wss_probe(struct snd_wss *chip)\r\n{\r\nunsigned long flags;\r\nint i, id, rev, regnum;\r\nunsigned char *ptr;\r\nunsigned int hw;\r\nid = snd_ad1848_probe(chip);\r\nif (id < 0)\r\nreturn id;\r\nhw = chip->hardware;\r\nif ((hw & WSS_HW_TYPE_MASK) == WSS_HW_DETECT) {\r\nfor (i = 0; i < 50; i++) {\r\nmb();\r\nif (wss_inb(chip, CS4231P(REGSEL)) & CS4231_INIT)\r\nmsleep(2);\r\nelse {\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_wss_out(chip, CS4231_MISC_INFO,\r\nCS4231_MODE2);\r\nid = snd_wss_in(chip, CS4231_MISC_INFO) & 0x0f;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (id == 0x0a)\r\nbreak;\r\n}\r\n}\r\nsnd_printdd("wss: port = 0x%lx, id = 0x%x\n", chip->port, id);\r\nif (id != 0x0a)\r\nreturn -ENODEV;\r\nrev = snd_wss_in(chip, CS4231_VERSION) & 0xe7;\r\nsnd_printdd("CS4231: VERSION (I25) = 0x%x\n", rev);\r\nif (rev == 0x80) {\r\nunsigned char tmp = snd_wss_in(chip, 23);\r\nsnd_wss_out(chip, 23, ~tmp);\r\nif (snd_wss_in(chip, 23) != tmp)\r\nchip->hardware = WSS_HW_AD1845;\r\nelse\r\nchip->hardware = WSS_HW_CS4231;\r\n} else if (rev == 0xa0) {\r\nchip->hardware = WSS_HW_CS4231A;\r\n} else if (rev == 0xa2) {\r\nchip->hardware = WSS_HW_CS4232;\r\n} else if (rev == 0xb2) {\r\nchip->hardware = WSS_HW_CS4232A;\r\n} else if (rev == 0x83) {\r\nchip->hardware = WSS_HW_CS4236;\r\n} else if (rev == 0x03) {\r\nchip->hardware = WSS_HW_CS4236B;\r\n} else {\r\nsnd_printk(KERN_ERR\r\n"unknown CS chip with version 0x%x\n", rev);\r\nreturn -ENODEV;\r\n}\r\n}\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nwss_inb(chip, CS4231P(STATUS));\r\nwss_outb(chip, CS4231P(STATUS), 0);\r\nmb();\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (!(chip->hardware & WSS_HW_AD1848_MASK))\r\nchip->image[CS4231_MISC_INFO] = CS4231_MODE2;\r\nswitch (chip->hardware) {\r\ncase WSS_HW_INTERWAVE:\r\nchip->image[CS4231_MISC_INFO] = CS4231_IW_MODE3;\r\nbreak;\r\ncase WSS_HW_CS4235:\r\ncase WSS_HW_CS4236B:\r\ncase WSS_HW_CS4237B:\r\ncase WSS_HW_CS4238B:\r\ncase WSS_HW_CS4239:\r\nif (hw == WSS_HW_DETECT3)\r\nchip->image[CS4231_MISC_INFO] = CS4231_4236_MODE3;\r\nelse\r\nchip->hardware = WSS_HW_CS4236;\r\nbreak;\r\n}\r\nchip->image[CS4231_IFACE_CTRL] =\r\n(chip->image[CS4231_IFACE_CTRL] & ~CS4231_SINGLE_DMA) |\r\n(chip->single_dma ? CS4231_SINGLE_DMA : 0);\r\nif (chip->hardware != WSS_HW_OPTI93X) {\r\nchip->image[CS4231_ALT_FEATURE_1] = 0x80;\r\nchip->image[CS4231_ALT_FEATURE_2] =\r\nchip->hardware == WSS_HW_INTERWAVE ? 0xc2 : 0x01;\r\n}\r\nif (chip->hardware == WSS_HW_AD1845)\r\nchip->image[AD1845_PWR_DOWN] = 8;\r\nptr = (unsigned char *) &chip->image;\r\nregnum = (chip->hardware & WSS_HW_AD1848_MASK) ? 16 : 32;\r\nsnd_wss_mce_down(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nfor (i = 0; i < regnum; i++)\r\nsnd_wss_out(chip, i, *ptr++);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_wss_mce_up(chip);\r\nsnd_wss_mce_down(chip);\r\nmdelay(2);\r\nif ((hw & WSS_HW_TYPE_MASK) == WSS_HW_DETECT) {\r\nif (chip->hardware == WSS_HW_CS4236B) {\r\nrev = snd_cs4236_ext_in(chip, CS4236_VERSION);\r\nsnd_cs4236_ext_out(chip, CS4236_VERSION, 0xff);\r\nid = snd_cs4236_ext_in(chip, CS4236_VERSION);\r\nsnd_cs4236_ext_out(chip, CS4236_VERSION, rev);\r\nsnd_printdd("CS4231: ext version; rev = 0x%x, id = 0x%x\n", rev, id);\r\nif ((id & 0x1f) == 0x1d) {\r\nchip->hardware = WSS_HW_CS4235;\r\nswitch (id >> 5) {\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"unknown CS4235 chip "\r\n"(enhanced version = 0x%x)\n",\r\nid);\r\n}\r\n} else if ((id & 0x1f) == 0x0b) {\r\nswitch (id >> 5) {\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nchip->hardware = WSS_HW_CS4236B;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"unknown CS4236 chip "\r\n"(enhanced version = 0x%x)\n",\r\nid);\r\n}\r\n} else if ((id & 0x1f) == 0x08) {\r\nchip->hardware = WSS_HW_CS4237B;\r\nswitch (id >> 5) {\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"unknown CS4237B chip "\r\n"(enhanced version = 0x%x)\n",\r\nid);\r\n}\r\n} else if ((id & 0x1f) == 0x09) {\r\nchip->hardware = WSS_HW_CS4238B;\r\nswitch (id >> 5) {\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"unknown CS4238B chip "\r\n"(enhanced version = 0x%x)\n",\r\nid);\r\n}\r\n} else if ((id & 0x1f) == 0x1e) {\r\nchip->hardware = WSS_HW_CS4239;\r\nswitch (id >> 5) {\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_WARNING\r\n"unknown CS4239 chip "\r\n"(enhanced version = 0x%x)\n",\r\nid);\r\n}\r\n} else {\r\nsnd_printk(KERN_WARNING\r\n"unknown CS4236/CS423xB chip "\r\n"(enhanced version = 0x%x)\n", id);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_wss_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nruntime->hw = snd_wss_playback;\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\nruntime->hw.formats &= ~(SNDRV_PCM_FMTBIT_IMA_ADPCM |\r\nSNDRV_PCM_FMTBIT_S16_BE);\r\nif (chip->hardware == WSS_HW_INTERWAVE && chip->dma1 > 3)\r\nruntime->hw.formats &= ~SNDRV_PCM_FMTBIT_MU_LAW;\r\nif (chip->hardware == WSS_HW_CS4235 ||\r\nchip->hardware == WSS_HW_CS4239)\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE;\r\nsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.buffer_bytes_max);\r\nsnd_pcm_limit_isa_dma_size(chip->dma1, &runtime->hw.period_bytes_max);\r\nif (chip->claim_dma) {\r\nif ((err = chip->claim_dma(chip, chip->dma_private_data, chip->dma1)) < 0)\r\nreturn err;\r\n}\r\nerr = snd_wss_open(chip, WSS_MODE_PLAY);\r\nif (err < 0) {\r\nif (chip->release_dma)\r\nchip->release_dma(chip, chip->dma_private_data, chip->dma1);\r\nsnd_free_pages(runtime->dma_area, runtime->dma_bytes);\r\nreturn err;\r\n}\r\nchip->playback_substream = substream;\r\nsnd_pcm_set_sync(substream);\r\nchip->rate_constraint(runtime);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nruntime->hw = snd_wss_capture;\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\nruntime->hw.formats &= ~(SNDRV_PCM_FMTBIT_IMA_ADPCM |\r\nSNDRV_PCM_FMTBIT_S16_BE);\r\nif (chip->hardware == WSS_HW_CS4235 ||\r\nchip->hardware == WSS_HW_CS4239 ||\r\nchip->hardware == WSS_HW_OPTI93X)\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_U8 |\r\nSNDRV_PCM_FMTBIT_S16_LE;\r\nsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.buffer_bytes_max);\r\nsnd_pcm_limit_isa_dma_size(chip->dma2, &runtime->hw.period_bytes_max);\r\nif (chip->claim_dma) {\r\nif ((err = chip->claim_dma(chip, chip->dma_private_data, chip->dma2)) < 0)\r\nreturn err;\r\n}\r\nerr = snd_wss_open(chip, WSS_MODE_RECORD);\r\nif (err < 0) {\r\nif (chip->release_dma)\r\nchip->release_dma(chip, chip->dma_private_data, chip->dma2);\r\nsnd_free_pages(runtime->dma_area, runtime->dma_bytes);\r\nreturn err;\r\n}\r\nchip->capture_substream = substream;\r\nsnd_pcm_set_sync(substream);\r\nchip->rate_constraint(runtime);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nchip->playback_substream = NULL;\r\nsnd_wss_close(chip, WSS_MODE_PLAY);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_wss *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_substream = NULL;\r\nsnd_wss_close(chip, WSS_MODE_RECORD);\r\nreturn 0;\r\n}\r\nstatic void snd_wss_thinkpad_twiddle(struct snd_wss *chip, int on)\r\n{\r\nint tmp;\r\nif (!chip->thinkpad_flag)\r\nreturn;\r\noutb(0x1c, AD1848_THINKPAD_CTL_PORT1);\r\ntmp = inb(AD1848_THINKPAD_CTL_PORT2);\r\nif (on)\r\ntmp |= AD1848_THINKPAD_CS4248_ENABLE_BIT;\r\nelse\r\ntmp &= ~AD1848_THINKPAD_CS4248_ENABLE_BIT;\r\noutb(tmp, AD1848_THINKPAD_CTL_PORT2);\r\n}\r\nstatic void snd_wss_suspend(struct snd_wss *chip)\r\n{\r\nint reg;\r\nunsigned long flags;\r\nsnd_pcm_suspend_all(chip->pcm);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nfor (reg = 0; reg < 32; reg++)\r\nchip->image[reg] = snd_wss_in(chip, reg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (chip->thinkpad_flag)\r\nsnd_wss_thinkpad_twiddle(chip, 0);\r\n}\r\nstatic void snd_wss_resume(struct snd_wss *chip)\r\n{\r\nint reg;\r\nunsigned long flags;\r\nif (chip->thinkpad_flag)\r\nsnd_wss_thinkpad_twiddle(chip, 1);\r\nsnd_wss_mce_up(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nfor (reg = 0; reg < 32; reg++) {\r\nswitch (reg) {\r\ncase CS4231_VERSION:\r\nbreak;\r\ndefault:\r\nsnd_wss_out(chip, reg, chip->image[reg]);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n#if 1\r\nsnd_wss_mce_down(chip);\r\n#else\r\nsnd_wss_busy_wait(chip);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->mce_bit &= ~CS4231_MCE;\r\ntimeout = wss_inb(chip, CS4231P(REGSEL));\r\nwss_outb(chip, CS4231P(REGSEL), chip->mce_bit | (timeout & 0x1f));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (timeout == 0x80)\r\nsnd_printk(KERN_ERR "down [0x%lx]: serious init problem "\r\n"- codec still busy\n", chip->port);\r\nif ((timeout & CS4231_MCE) == 0 ||\r\n!(chip->hardware & (WSS_HW_CS4231_MASK | WSS_HW_CS4232_MASK))) {\r\nreturn;\r\n}\r\nsnd_wss_busy_wait(chip);\r\n#endif\r\n}\r\nstatic int snd_wss_free(struct snd_wss *chip)\r\n{\r\nrelease_and_free_resource(chip->res_port);\r\nrelease_and_free_resource(chip->res_cport);\r\nif (chip->irq >= 0) {\r\ndisable_irq(chip->irq);\r\nif (!(chip->hwshare & WSS_HWSHARE_IRQ))\r\nfree_irq(chip->irq, (void *) chip);\r\n}\r\nif (!(chip->hwshare & WSS_HWSHARE_DMA1) && chip->dma1 >= 0) {\r\nsnd_dma_disable(chip->dma1);\r\nfree_dma(chip->dma1);\r\n}\r\nif (!(chip->hwshare & WSS_HWSHARE_DMA2) &&\r\nchip->dma2 >= 0 && chip->dma2 != chip->dma1) {\r\nsnd_dma_disable(chip->dma2);\r\nfree_dma(chip->dma2);\r\n}\r\nif (chip->timer)\r\nsnd_device_free(chip->card, chip->timer);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_wss *chip = device->device_data;\r\nreturn snd_wss_free(chip);\r\n}\r\nconst char *snd_wss_chip_id(struct snd_wss *chip)\r\n{\r\nswitch (chip->hardware) {\r\ncase WSS_HW_CS4231:\r\nreturn "CS4231";\r\ncase WSS_HW_CS4231A:\r\nreturn "CS4231A";\r\ncase WSS_HW_CS4232:\r\nreturn "CS4232";\r\ncase WSS_HW_CS4232A:\r\nreturn "CS4232A";\r\ncase WSS_HW_CS4235:\r\nreturn "CS4235";\r\ncase WSS_HW_CS4236:\r\nreturn "CS4236";\r\ncase WSS_HW_CS4236B:\r\nreturn "CS4236B";\r\ncase WSS_HW_CS4237B:\r\nreturn "CS4237B";\r\ncase WSS_HW_CS4238B:\r\nreturn "CS4238B";\r\ncase WSS_HW_CS4239:\r\nreturn "CS4239";\r\ncase WSS_HW_INTERWAVE:\r\nreturn "AMD InterWave";\r\ncase WSS_HW_OPL3SA2:\r\nreturn chip->card->shortname;\r\ncase WSS_HW_AD1845:\r\nreturn "AD1845";\r\ncase WSS_HW_OPTI93X:\r\nreturn "OPTi 93x";\r\ncase WSS_HW_AD1847:\r\nreturn "AD1847";\r\ncase WSS_HW_AD1848:\r\nreturn "AD1848";\r\ncase WSS_HW_CS4248:\r\nreturn "CS4248";\r\ncase WSS_HW_CMI8330:\r\nreturn "CMI8330/C3D";\r\ndefault:\r\nreturn "???";\r\n}\r\n}\r\nstatic int snd_wss_new(struct snd_card *card,\r\nunsigned short hardware,\r\nunsigned short hwshare,\r\nstruct snd_wss **rchip)\r\n{\r\nstruct snd_wss *chip;\r\n*rchip = NULL;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nchip->hardware = hardware;\r\nchip->hwshare = hwshare;\r\nspin_lock_init(&chip->reg_lock);\r\nmutex_init(&chip->mce_mutex);\r\nmutex_init(&chip->open_mutex);\r\nchip->card = card;\r\nchip->rate_constraint = snd_wss_xrate;\r\nchip->set_playback_format = snd_wss_playback_format;\r\nchip->set_capture_format = snd_wss_capture_format;\r\nif (chip->hardware == WSS_HW_OPTI93X)\r\nmemcpy(&chip->image, &snd_opti93x_original_image,\r\nsizeof(snd_opti93x_original_image));\r\nelse\r\nmemcpy(&chip->image, &snd_wss_original_image,\r\nsizeof(snd_wss_original_image));\r\nif (chip->hardware & WSS_HW_AD1848_MASK) {\r\nchip->image[CS4231_PIN_CTRL] = 0;\r\nchip->image[CS4231_TEST_INIT] = 0;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nint snd_wss_create(struct snd_card *card,\r\nunsigned long port,\r\nunsigned long cport,\r\nint irq, int dma1, int dma2,\r\nunsigned short hardware,\r\nunsigned short hwshare,\r\nstruct snd_wss **rchip)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_wss_dev_free,\r\n};\r\nstruct snd_wss *chip;\r\nint err;\r\nerr = snd_wss_new(card, hardware, hwshare, &chip);\r\nif (err < 0)\r\nreturn err;\r\nchip->irq = -1;\r\nchip->dma1 = -1;\r\nchip->dma2 = -1;\r\nchip->res_port = request_region(port, 4, "WSS");\r\nif (!chip->res_port) {\r\nsnd_printk(KERN_ERR "wss: can't grab port 0x%lx\n", port);\r\nsnd_wss_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->port = port;\r\nif ((long)cport >= 0) {\r\nchip->res_cport = request_region(cport, 8, "CS4232 Control");\r\nif (!chip->res_cport) {\r\nsnd_printk(KERN_ERR\r\n"wss: can't grab control port 0x%lx\n", cport);\r\nsnd_wss_free(chip);\r\nreturn -ENODEV;\r\n}\r\n}\r\nchip->cport = cport;\r\nif (!(hwshare & WSS_HWSHARE_IRQ))\r\nif (request_irq(irq, snd_wss_interrupt, 0,\r\n"WSS", (void *) chip)) {\r\nsnd_printk(KERN_ERR "wss: can't grab IRQ %d\n", irq);\r\nsnd_wss_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = irq;\r\nif (!(hwshare & WSS_HWSHARE_DMA1) && request_dma(dma1, "WSS - 1")) {\r\nsnd_printk(KERN_ERR "wss: can't grab DMA1 %d\n", dma1);\r\nsnd_wss_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->dma1 = dma1;\r\nif (!(hwshare & WSS_HWSHARE_DMA2) && dma1 != dma2 &&\r\ndma2 >= 0 && request_dma(dma2, "WSS - 2")) {\r\nsnd_printk(KERN_ERR "wss: can't grab DMA2 %d\n", dma2);\r\nsnd_wss_free(chip);\r\nreturn -EBUSY;\r\n}\r\nif (dma1 == dma2 || dma2 < 0) {\r\nchip->single_dma = 1;\r\nchip->dma2 = chip->dma1;\r\n} else\r\nchip->dma2 = dma2;\r\nif (hardware == WSS_HW_THINKPAD) {\r\nchip->thinkpad_flag = 1;\r\nchip->hardware = WSS_HW_DETECT;\r\nsnd_wss_thinkpad_twiddle(chip, 1);\r\n}\r\nif (snd_wss_probe(chip) < 0) {\r\nsnd_wss_free(chip);\r\nreturn -ENODEV;\r\n}\r\nsnd_wss_init(chip);\r\n#if 0\r\nif (chip->hardware & WSS_HW_CS4232_MASK) {\r\nif (chip->res_cport == NULL)\r\nsnd_printk(KERN_ERR "CS4232 control port features are "\r\n"not accessible\n");\r\n}\r\n#endif\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\nsnd_wss_free(chip);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_PM\r\nchip->suspend = snd_wss_suspend;\r\nchip->resume = snd_wss_resume;\r\n#endif\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nint snd_wss_pcm(struct snd_wss *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(chip->card, "WSS", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_wss_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_wss_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nif (chip->single_dma)\r\npcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;\r\nif (chip->hardware != WSS_HW_INTERWAVE)\r\npcm->info_flags |= SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nstrcpy(pcm->name, snd_wss_chip_id(chip));\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, chip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);\r\nchip->pcm = pcm;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic void snd_wss_timer_free(struct snd_timer *timer)\r\n{\r\nstruct snd_wss *chip = timer->private_data;\r\nchip->timer = NULL;\r\n}\r\nint snd_wss_timer(struct snd_wss *chip, int device, struct snd_timer **rtimer)\r\n{\r\nstruct snd_timer *timer;\r\nstruct snd_timer_id tid;\r\nint err;\r\ntid.dev_class = SNDRV_TIMER_CLASS_CARD;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\r\ntid.card = chip->card->number;\r\ntid.device = device;\r\ntid.subdevice = 0;\r\nif ((err = snd_timer_new(chip->card, "CS4231", &tid, &timer)) < 0)\r\nreturn err;\r\nstrcpy(timer->name, snd_wss_chip_id(chip));\r\ntimer->private_data = chip;\r\ntimer->private_free = snd_wss_timer_free;\r\ntimer->hw = snd_wss_timer_table;\r\nchip->timer = timer;\r\nif (rtimer)\r\n*rtimer = timer;\r\nreturn 0;\r\n}\r\nstatic int snd_wss_info_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = {\r\n"Line", "Aux", "Mic", "Mix"\r\n};\r\nstatic char *opl3sa_texts[4] = {\r\n"Line", "CD", "Mic", "Mix"\r\n};\r\nstatic char *gusmax_texts[4] = {\r\n"Line", "Synth", "Mic", "Mix"\r\n};\r\nchar **ptexts = texts;\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nif (snd_BUG_ON(!chip->card))\r\nreturn -EINVAL;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 2;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item > 3)\r\nuinfo->value.enumerated.item = 3;\r\nif (!strcmp(chip->card->driver, "GUS MAX"))\r\nptexts = gusmax_texts;\r\nswitch (chip->hardware) {\r\ncase WSS_HW_INTERWAVE:\r\nptexts = gusmax_texts;\r\nbreak;\r\ncase WSS_HW_OPTI93X:\r\ncase WSS_HW_OPL3SA2:\r\nptexts = opl3sa_texts;\r\nbreak;\r\n}\r\nstrcpy(uinfo->value.enumerated.name, ptexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_get_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.enumerated.item[0] = (chip->image[CS4231_LEFT_INPUT] & CS4231_MIXS_ALL) >> 6;\r\nucontrol->value.enumerated.item[1] = (chip->image[CS4231_RIGHT_INPUT] & CS4231_MIXS_ALL) >> 6;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_wss_put_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nunsigned short left, right;\r\nint change;\r\nif (ucontrol->value.enumerated.item[0] > 3 ||\r\nucontrol->value.enumerated.item[1] > 3)\r\nreturn -EINVAL;\r\nleft = ucontrol->value.enumerated.item[0] << 6;\r\nright = ucontrol->value.enumerated.item[1] << 6;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nleft = (chip->image[CS4231_LEFT_INPUT] & ~CS4231_MIXS_ALL) | left;\r\nright = (chip->image[CS4231_RIGHT_INPUT] & ~CS4231_MIXS_ALL) | right;\r\nchange = left != chip->image[CS4231_LEFT_INPUT] ||\r\nright != chip->image[CS4231_RIGHT_INPUT];\r\nsnd_wss_out(chip, CS4231_LEFT_INPUT, left);\r\nsnd_wss_out(chip, CS4231_RIGHT_INPUT, right);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nint snd_wss_info_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nint snd_wss_get_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nint snd_wss_put_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nval = (chip->image[reg] & ~(mask << shift)) | val;\r\nchange = val != chip->image[reg];\r\nsnd_wss_out(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nint snd_wss_info_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nint snd_wss_get_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->image[left_reg] >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (chip->image[right_reg] >> shift_right) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nint snd_wss_put_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_wss *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned short val1, val2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (left_reg != right_reg) {\r\nval1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;\r\nval2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;\r\nchange = val1 != chip->image[left_reg] ||\r\nval2 != chip->image[right_reg];\r\nsnd_wss_out(chip, left_reg, val1);\r\nsnd_wss_out(chip, right_reg, val2);\r\n} else {\r\nmask = (mask << shift_left) | (mask << shift_right);\r\nval1 = (chip->image[left_reg] & ~mask) | val1 | val2;\r\nchange = val1 != chip->image[left_reg];\r\nsnd_wss_out(chip, left_reg, val1);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nint snd_wss_mixer(struct snd_wss *chip)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx;\r\nint err;\r\nint count = ARRAY_SIZE(snd_wss_controls);\r\nif (snd_BUG_ON(!chip || !chip->pcm))\r\nreturn -EINVAL;\r\ncard = chip->card;\r\nstrcpy(card->mixername, chip->pcm->name);\r\nif (chip->hardware & WSS_HW_AD1848_MASK)\r\ncount = 11;\r\nelse if (chip->hardware == WSS_HW_OPTI93X)\r\ncount = 9;\r\nfor (idx = 0; idx < count; idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_wss_controls[idx],\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nconst struct snd_pcm_ops *snd_wss_get_pcm_ops(int direction)\r\n{\r\nreturn direction == SNDRV_PCM_STREAM_PLAYBACK ?\r\n&snd_wss_playback_ops : &snd_wss_capture_ops;\r\n}\r\nstatic int __init alsa_wss_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_wss_exit(void)\r\n{\r\n}
