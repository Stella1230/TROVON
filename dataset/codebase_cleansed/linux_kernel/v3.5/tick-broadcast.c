static inline void tick_broadcast_clear_oneshot(int cpu) { }\r\nstruct tick_device *tick_get_broadcast_device(void)\r\n{\r\nreturn &tick_broadcast_device;\r\n}\r\nstruct cpumask *tick_get_broadcast_mask(void)\r\n{\r\nreturn to_cpumask(tick_broadcast_mask);\r\n}\r\nstatic void tick_broadcast_start_periodic(struct clock_event_device *bc)\r\n{\r\nif (bc)\r\ntick_setup_periodic(bc, 1);\r\n}\r\nint tick_check_broadcast_device(struct clock_event_device *dev)\r\n{\r\nif ((tick_broadcast_device.evtdev &&\r\ntick_broadcast_device.evtdev->rating >= dev->rating) ||\r\n(dev->features & CLOCK_EVT_FEAT_C3STOP))\r\nreturn 0;\r\nclockevents_exchange_device(tick_broadcast_device.evtdev, dev);\r\ntick_broadcast_device.evtdev = dev;\r\nif (!cpumask_empty(tick_get_broadcast_mask()))\r\ntick_broadcast_start_periodic(dev);\r\nreturn 1;\r\n}\r\nint tick_is_broadcast_device(struct clock_event_device *dev)\r\n{\r\nreturn (dev && tick_broadcast_device.evtdev == dev);\r\n}\r\nint tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\nif (!tick_device_is_functional(dev)) {\r\ndev->event_handler = tick_handle_periodic;\r\ncpumask_set_cpu(cpu, tick_get_broadcast_mask());\r\ntick_broadcast_start_periodic(tick_broadcast_device.evtdev);\r\nret = 1;\r\n} else {\r\nif (!(dev->features & CLOCK_EVT_FEAT_C3STOP)) {\r\nint cpu = smp_processor_id();\r\ncpumask_clear_cpu(cpu, tick_get_broadcast_mask());\r\ntick_broadcast_clear_oneshot(cpu);\r\n}\r\n}\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void tick_do_broadcast(struct cpumask *mask)\r\n{\r\nint cpu = smp_processor_id();\r\nstruct tick_device *td;\r\nif (cpumask_test_cpu(cpu, mask)) {\r\ncpumask_clear_cpu(cpu, mask);\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\ntd->evtdev->event_handler(td->evtdev);\r\n}\r\nif (!cpumask_empty(mask)) {\r\ntd = &per_cpu(tick_cpu_device, cpumask_first(mask));\r\ntd->evtdev->broadcast(mask);\r\n}\r\n}\r\nstatic void tick_do_periodic_broadcast(void)\r\n{\r\nraw_spin_lock(&tick_broadcast_lock);\r\ncpumask_and(to_cpumask(tmpmask),\r\ncpu_online_mask, tick_get_broadcast_mask());\r\ntick_do_broadcast(to_cpumask(tmpmask));\r\nraw_spin_unlock(&tick_broadcast_lock);\r\n}\r\nstatic void tick_handle_periodic_broadcast(struct clock_event_device *dev)\r\n{\r\nktime_t next;\r\ntick_do_periodic_broadcast();\r\nif (dev->mode == CLOCK_EVT_MODE_PERIODIC)\r\nreturn;\r\nfor (next = dev->next_event; ;) {\r\nnext = ktime_add(next, tick_period);\r\nif (!clockevents_program_event(dev, next, false))\r\nreturn;\r\ntick_do_periodic_broadcast();\r\n}\r\n}\r\nstatic void tick_do_broadcast_on_off(unsigned long *reason)\r\n{\r\nstruct clock_event_device *bc, *dev;\r\nstruct tick_device *td;\r\nunsigned long flags;\r\nint cpu, bc_stopped;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\ncpu = smp_processor_id();\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\ndev = td->evtdev;\r\nbc = tick_broadcast_device.evtdev;\r\nif (!dev || !(dev->features & CLOCK_EVT_FEAT_C3STOP))\r\ngoto out;\r\nif (!tick_device_is_functional(dev))\r\ngoto out;\r\nbc_stopped = cpumask_empty(tick_get_broadcast_mask());\r\nswitch (*reason) {\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_ON:\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_FORCE:\r\nif (!cpumask_test_cpu(cpu, tick_get_broadcast_mask())) {\r\ncpumask_set_cpu(cpu, tick_get_broadcast_mask());\r\nif (tick_broadcast_device.mode ==\r\nTICKDEV_MODE_PERIODIC)\r\nclockevents_shutdown(dev);\r\n}\r\nif (*reason == CLOCK_EVT_NOTIFY_BROADCAST_FORCE)\r\ntick_broadcast_force = 1;\r\nbreak;\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_OFF:\r\nif (!tick_broadcast_force &&\r\ncpumask_test_cpu(cpu, tick_get_broadcast_mask())) {\r\ncpumask_clear_cpu(cpu, tick_get_broadcast_mask());\r\nif (tick_broadcast_device.mode ==\r\nTICKDEV_MODE_PERIODIC)\r\ntick_setup_periodic(dev, 0);\r\n}\r\nbreak;\r\n}\r\nif (cpumask_empty(tick_get_broadcast_mask())) {\r\nif (!bc_stopped)\r\nclockevents_shutdown(bc);\r\n} else if (bc_stopped) {\r\nif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\r\ntick_broadcast_start_periodic(bc);\r\nelse\r\ntick_broadcast_setup_oneshot(bc);\r\n}\r\nout:\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\n}\r\nvoid tick_broadcast_on_off(unsigned long reason, int *oncpu)\r\n{\r\nif (!cpumask_test_cpu(*oncpu, cpu_online_mask))\r\nprintk(KERN_ERR "tick-broadcast: ignoring broadcast for "\r\n"offline CPU #%d\n", *oncpu);\r\nelse\r\ntick_do_broadcast_on_off(&reason);\r\n}\r\nvoid tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)\r\n{\r\nif (!broadcast)\r\ndev->event_handler = tick_handle_periodic;\r\nelse\r\ndev->event_handler = tick_handle_periodic_broadcast;\r\n}\r\nvoid tick_shutdown_broadcast(unsigned int *cpup)\r\n{\r\nstruct clock_event_device *bc;\r\nunsigned long flags;\r\nunsigned int cpu = *cpup;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\nbc = tick_broadcast_device.evtdev;\r\ncpumask_clear_cpu(cpu, tick_get_broadcast_mask());\r\nif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC) {\r\nif (bc && cpumask_empty(tick_get_broadcast_mask()))\r\nclockevents_shutdown(bc);\r\n}\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\n}\r\nvoid tick_suspend_broadcast(void)\r\n{\r\nstruct clock_event_device *bc;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\nbc = tick_broadcast_device.evtdev;\r\nif (bc)\r\nclockevents_shutdown(bc);\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\n}\r\nint tick_resume_broadcast(void)\r\n{\r\nstruct clock_event_device *bc;\r\nunsigned long flags;\r\nint broadcast = 0;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\nbc = tick_broadcast_device.evtdev;\r\nif (bc) {\r\nclockevents_set_mode(bc, CLOCK_EVT_MODE_RESUME);\r\nswitch (tick_broadcast_device.mode) {\r\ncase TICKDEV_MODE_PERIODIC:\r\nif (!cpumask_empty(tick_get_broadcast_mask()))\r\ntick_broadcast_start_periodic(bc);\r\nbroadcast = cpumask_test_cpu(smp_processor_id(),\r\ntick_get_broadcast_mask());\r\nbreak;\r\ncase TICKDEV_MODE_ONESHOT:\r\nif (!cpumask_empty(tick_get_broadcast_mask()))\r\nbroadcast = tick_resume_broadcast_oneshot(bc);\r\nbreak;\r\n}\r\n}\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\nreturn broadcast;\r\n}\r\nstruct cpumask *tick_get_broadcast_oneshot_mask(void)\r\n{\r\nreturn to_cpumask(tick_broadcast_oneshot_mask);\r\n}\r\nstatic int tick_broadcast_set_event(ktime_t expires, int force)\r\n{\r\nstruct clock_event_device *bc = tick_broadcast_device.evtdev;\r\nif (bc->mode != CLOCK_EVT_MODE_ONESHOT)\r\nclockevents_set_mode(bc, CLOCK_EVT_MODE_ONESHOT);\r\nreturn clockevents_program_event(bc, expires, force);\r\n}\r\nint tick_resume_broadcast_oneshot(struct clock_event_device *bc)\r\n{\r\nclockevents_set_mode(bc, CLOCK_EVT_MODE_ONESHOT);\r\nreturn 0;\r\n}\r\nvoid tick_check_oneshot_broadcast(int cpu)\r\n{\r\nif (cpumask_test_cpu(cpu, to_cpumask(tick_broadcast_oneshot_mask))) {\r\nstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\r\nclockevents_set_mode(td->evtdev, CLOCK_EVT_MODE_ONESHOT);\r\n}\r\n}\r\nstatic void tick_handle_oneshot_broadcast(struct clock_event_device *dev)\r\n{\r\nstruct tick_device *td;\r\nktime_t now, next_event;\r\nint cpu;\r\nraw_spin_lock(&tick_broadcast_lock);\r\nagain:\r\ndev->next_event.tv64 = KTIME_MAX;\r\nnext_event.tv64 = KTIME_MAX;\r\ncpumask_clear(to_cpumask(tmpmask));\r\nnow = ktime_get();\r\nfor_each_cpu(cpu, tick_get_broadcast_oneshot_mask()) {\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\nif (td->evtdev->next_event.tv64 <= now.tv64)\r\ncpumask_set_cpu(cpu, to_cpumask(tmpmask));\r\nelse if (td->evtdev->next_event.tv64 < next_event.tv64)\r\nnext_event.tv64 = td->evtdev->next_event.tv64;\r\n}\r\ntick_do_broadcast(to_cpumask(tmpmask));\r\nif (next_event.tv64 != KTIME_MAX) {\r\nif (tick_broadcast_set_event(next_event, 0))\r\ngoto again;\r\n}\r\nraw_spin_unlock(&tick_broadcast_lock);\r\n}\r\nvoid tick_broadcast_oneshot_control(unsigned long reason)\r\n{\r\nstruct clock_event_device *bc, *dev;\r\nstruct tick_device *td;\r\nunsigned long flags;\r\nint cpu;\r\nif (tick_broadcast_device.mode == TICKDEV_MODE_PERIODIC)\r\nreturn;\r\ncpu = smp_processor_id();\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\ndev = td->evtdev;\r\nif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\r\nreturn;\r\nbc = tick_broadcast_device.evtdev;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\nif (reason == CLOCK_EVT_NOTIFY_BROADCAST_ENTER) {\r\nif (!cpumask_test_cpu(cpu, tick_get_broadcast_oneshot_mask())) {\r\ncpumask_set_cpu(cpu, tick_get_broadcast_oneshot_mask());\r\nclockevents_set_mode(dev, CLOCK_EVT_MODE_SHUTDOWN);\r\nif (dev->next_event.tv64 < bc->next_event.tv64)\r\ntick_broadcast_set_event(dev->next_event, 1);\r\n}\r\n} else {\r\nif (cpumask_test_cpu(cpu, tick_get_broadcast_oneshot_mask())) {\r\ncpumask_clear_cpu(cpu,\r\ntick_get_broadcast_oneshot_mask());\r\nclockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);\r\nif (dev->next_event.tv64 != KTIME_MAX)\r\ntick_program_event(dev->next_event, 1);\r\n}\r\n}\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\n}\r\nstatic void tick_broadcast_clear_oneshot(int cpu)\r\n{\r\ncpumask_clear_cpu(cpu, tick_get_broadcast_oneshot_mask());\r\n}\r\nstatic void tick_broadcast_init_next_event(struct cpumask *mask,\r\nktime_t expires)\r\n{\r\nstruct tick_device *td;\r\nint cpu;\r\nfor_each_cpu(cpu, mask) {\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\nif (td->evtdev)\r\ntd->evtdev->next_event = expires;\r\n}\r\n}\r\nvoid tick_broadcast_setup_oneshot(struct clock_event_device *bc)\r\n{\r\nint cpu = smp_processor_id();\r\nif (bc->event_handler != tick_handle_oneshot_broadcast) {\r\nint was_periodic = bc->mode == CLOCK_EVT_MODE_PERIODIC;\r\nbc->event_handler = tick_handle_oneshot_broadcast;\r\ntick_do_timer_cpu = cpu;\r\ncpumask_copy(to_cpumask(tmpmask), tick_get_broadcast_mask());\r\ncpumask_clear_cpu(cpu, to_cpumask(tmpmask));\r\ncpumask_or(tick_get_broadcast_oneshot_mask(),\r\ntick_get_broadcast_oneshot_mask(),\r\nto_cpumask(tmpmask));\r\nif (was_periodic && !cpumask_empty(to_cpumask(tmpmask))) {\r\nclockevents_set_mode(bc, CLOCK_EVT_MODE_ONESHOT);\r\ntick_broadcast_init_next_event(to_cpumask(tmpmask),\r\ntick_next_period);\r\ntick_broadcast_set_event(tick_next_period, 1);\r\n} else\r\nbc->next_event.tv64 = KTIME_MAX;\r\n} else {\r\ntick_broadcast_clear_oneshot(cpu);\r\n}\r\n}\r\nvoid tick_broadcast_switch_to_oneshot(void)\r\n{\r\nstruct clock_event_device *bc;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\ntick_broadcast_device.mode = TICKDEV_MODE_ONESHOT;\r\nbc = tick_broadcast_device.evtdev;\r\nif (bc)\r\ntick_broadcast_setup_oneshot(bc);\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\n}\r\nvoid tick_shutdown_broadcast_oneshot(unsigned int *cpup)\r\n{\r\nunsigned long flags;\r\nunsigned int cpu = *cpup;\r\nraw_spin_lock_irqsave(&tick_broadcast_lock, flags);\r\ncpumask_clear_cpu(cpu, tick_get_broadcast_oneshot_mask());\r\nraw_spin_unlock_irqrestore(&tick_broadcast_lock, flags);\r\n}\r\nint tick_broadcast_oneshot_active(void)\r\n{\r\nreturn tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;\r\n}\r\nbool tick_broadcast_oneshot_available(void)\r\n{\r\nstruct clock_event_device *bc = tick_broadcast_device.evtdev;\r\nreturn bc ? bc->features & CLOCK_EVT_FEAT_ONESHOT : false;\r\n}
