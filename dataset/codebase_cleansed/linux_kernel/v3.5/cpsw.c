static void cpsw_intr_enable(struct cpsw_priv *priv)\r\n{\r\n__raw_writel(0xFF, &priv->ss_regs->tx_en);\r\n__raw_writel(0xFF, &priv->ss_regs->rx_en);\r\ncpdma_ctlr_int_ctrl(priv->dma, true);\r\nreturn;\r\n}\r\nstatic void cpsw_intr_disable(struct cpsw_priv *priv)\r\n{\r\n__raw_writel(0, &priv->ss_regs->tx_en);\r\n__raw_writel(0, &priv->ss_regs->rx_en);\r\ncpdma_ctlr_int_ctrl(priv->dma, false);\r\nreturn;\r\n}\r\nvoid cpsw_tx_handler(void *token, int len, int status)\r\n{\r\nstruct sk_buff *skb = token;\r\nstruct net_device *ndev = skb->dev;\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nif (unlikely(netif_queue_stopped(ndev)))\r\nnetif_start_queue(ndev);\r\npriv->stats.tx_packets++;\r\npriv->stats.tx_bytes += len;\r\ndev_kfree_skb_any(skb);\r\n}\r\nvoid cpsw_rx_handler(void *token, int len, int status)\r\n{\r\nstruct sk_buff *skb = token;\r\nstruct net_device *ndev = skb->dev;\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nint ret = 0;\r\nif (unlikely(!netif_running(ndev)) ||\r\nunlikely(!netif_carrier_ok(ndev))) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (likely(status >= 0)) {\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nnetif_receive_skb(skb);\r\npriv->stats.rx_bytes += len;\r\npriv->stats.rx_packets++;\r\nskb = NULL;\r\n}\r\nif (unlikely(!netif_running(ndev))) {\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (likely(!skb)) {\r\nskb = netdev_alloc_skb_ip_align(ndev, priv->rx_packet_max);\r\nif (WARN_ON(!skb))\r\nreturn;\r\nret = cpdma_chan_submit(priv->rxch, skb, skb->data,\r\nskb_tailroom(skb), GFP_KERNEL);\r\n}\r\nWARN_ON(ret < 0);\r\n}\r\nstatic irqreturn_t cpsw_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cpsw_priv *priv = dev_id;\r\nif (likely(netif_running(priv->ndev))) {\r\ncpsw_intr_disable(priv);\r\ncpsw_disable_irq(priv);\r\nnapi_schedule(&priv->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int cpsw_get_slave_port(struct cpsw_priv *priv, u32 slave_num)\r\n{\r\nif (priv->host_port == 0)\r\nreturn slave_num + 1;\r\nelse\r\nreturn slave_num;\r\n}\r\nstatic int cpsw_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct cpsw_priv *priv = napi_to_priv(napi);\r\nint num_tx, num_rx;\r\nnum_tx = cpdma_chan_process(priv->txch, 128);\r\nnum_rx = cpdma_chan_process(priv->rxch, budget);\r\nif (num_rx || num_tx)\r\ncpsw_dbg(priv, intr, "poll %d rx, %d tx pkts\n",\r\nnum_rx, num_tx);\r\nif (num_rx < budget) {\r\nnapi_complete(napi);\r\ncpsw_intr_enable(priv);\r\ncpdma_ctlr_eoi(priv->dma);\r\ncpsw_enable_irq(priv);\r\n}\r\nreturn num_rx;\r\n}\r\nstatic inline void soft_reset(const char *module, void __iomem *reg)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\n__raw_writel(1, reg);\r\ndo {\r\ncpu_relax();\r\n} while ((__raw_readl(reg) & 1) && time_after(timeout, jiffies));\r\nWARN(__raw_readl(reg) & 1, "failed to soft-reset %s\n", module);\r\n}\r\nstatic void cpsw_set_slave_mac(struct cpsw_slave *slave,\r\nstruct cpsw_priv *priv)\r\n{\r\n__raw_writel(mac_hi(priv->mac_addr), &slave->regs->sa_hi);\r\n__raw_writel(mac_lo(priv->mac_addr), &slave->regs->sa_lo);\r\n}\r\nstatic void _cpsw_adjust_link(struct cpsw_slave *slave,\r\nstruct cpsw_priv *priv, bool *link)\r\n{\r\nstruct phy_device *phy = slave->phy;\r\nu32 mac_control = 0;\r\nu32 slave_port;\r\nif (!phy)\r\nreturn;\r\nslave_port = cpsw_get_slave_port(priv, slave->slave_num);\r\nif (phy->link) {\r\nmac_control = priv->data.mac_control;\r\ncpsw_ale_control_set(priv->ale, slave_port,\r\nALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\r\nif (phy->speed == 1000)\r\nmac_control |= BIT(7);\r\nif (phy->duplex)\r\nmac_control |= BIT(0);\r\n*link = true;\r\n} else {\r\nmac_control = 0;\r\ncpsw_ale_control_set(priv->ale, slave_port,\r\nALE_PORT_STATE, ALE_PORT_STATE_DISABLE);\r\n}\r\nif (mac_control != slave->mac_control) {\r\nphy_print_status(phy);\r\n__raw_writel(mac_control, &slave->sliver->mac_control);\r\n}\r\nslave->mac_control = mac_control;\r\n}\r\nstatic void cpsw_adjust_link(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nbool link = false;\r\nfor_each_slave(priv, _cpsw_adjust_link, priv, &link);\r\nif (link) {\r\nnetif_carrier_on(ndev);\r\nif (netif_running(ndev))\r\nnetif_wake_queue(ndev);\r\n} else {\r\nnetif_carrier_off(ndev);\r\nnetif_stop_queue(ndev);\r\n}\r\n}\r\nstatic inline int __show_stat(char *buf, int maxlen, const char *name, u32 val)\r\n{\r\nstatic char *leader = "........................................";\r\nif (!val)\r\nreturn 0;\r\nelse\r\nreturn snprintf(buf, maxlen, "%s %s %10d\n", name,\r\nleader + strlen(name), val);\r\n}\r\nstatic void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)\r\n{\r\nchar name[32];\r\nu32 slave_port;\r\nsprintf(name, "slave-%d", slave->slave_num);\r\nsoft_reset(name, &slave->sliver->soft_reset);\r\n__raw_writel(RX_PRIORITY_MAPPING, &slave->sliver->rx_pri_map);\r\n__raw_writel(TX_PRIORITY_MAPPING, &slave->regs->tx_pri_map);\r\n__raw_writel(priv->rx_packet_max, &slave->sliver->rx_maxlen);\r\ncpsw_set_slave_mac(slave, priv);\r\nslave->mac_control = 0;\r\nslave_port = cpsw_get_slave_port(priv, slave->slave_num);\r\ncpsw_ale_add_mcast(priv->ale, priv->ndev->broadcast,\r\n1 << slave_port, 0, ALE_MCAST_FWD_2);\r\nslave->phy = phy_connect(priv->ndev, slave->data->phy_id,\r\n&cpsw_adjust_link, 0, slave->data->phy_if);\r\nif (IS_ERR(slave->phy)) {\r\ndev_err(priv->dev, "phy %s not found on slave %d\n",\r\nslave->data->phy_id, slave->slave_num);\r\nslave->phy = NULL;\r\n} else {\r\ndev_info(priv->dev, "phy found : id is : 0x%x\n",\r\nslave->phy->phy_id);\r\nphy_start(slave->phy);\r\n}\r\n}\r\nstatic void cpsw_init_host_port(struct cpsw_priv *priv)\r\n{\r\nsoft_reset("cpsw", &priv->regs->soft_reset);\r\ncpsw_ale_start(priv->ale);\r\ncpsw_ale_control_set(priv->ale, 0, ALE_VLAN_AWARE, 0);\r\n__raw_writel(CPDMA_TX_PRIORITY_MAP,\r\n&priv->host_port_regs->cpdma_tx_pri_map);\r\n__raw_writel(0, &priv->host_port_regs->cpdma_rx_chan_map);\r\ncpsw_ale_control_set(priv->ale, priv->host_port,\r\nALE_PORT_STATE, ALE_PORT_STATE_FORWARD);\r\ncpsw_ale_add_ucast(priv->ale, priv->mac_addr, priv->host_port, 0);\r\ncpsw_ale_add_mcast(priv->ale, priv->ndev->broadcast,\r\n1 << priv->host_port, 0, ALE_MCAST_FWD_2);\r\n}\r\nstatic int cpsw_ndo_open(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nint i, ret;\r\nu32 reg;\r\ncpsw_intr_disable(priv);\r\nnetif_carrier_off(ndev);\r\nret = clk_enable(priv->clk);\r\nif (ret < 0) {\r\ndev_err(priv->dev, "unable to turn on device clock\n");\r\nreturn ret;\r\n}\r\nreg = __raw_readl(&priv->regs->id_ver);\r\ndev_info(priv->dev, "initializing cpsw version %d.%d (%d)\n",\r\nCPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),\r\nCPSW_RTL_VERSION(reg));\r\ncpsw_init_host_port(priv);\r\nfor_each_slave(priv, cpsw_slave_open, priv);\r\ncpdma_control_set(priv->dma, CPDMA_TX_PRIO_FIXED, 1);\r\ncpdma_control_set(priv->dma, CPDMA_RX_BUFFER_OFFSET, 0);\r\n__raw_writel(0, &priv->regs->ptype);\r\n__raw_writel(0x7, &priv->regs->stat_port_en);\r\nif (WARN_ON(!priv->data.rx_descs))\r\npriv->data.rx_descs = 128;\r\nfor (i = 0; i < priv->data.rx_descs; i++) {\r\nstruct sk_buff *skb;\r\nret = -ENOMEM;\r\nskb = netdev_alloc_skb_ip_align(priv->ndev,\r\npriv->rx_packet_max);\r\nif (!skb)\r\nbreak;\r\nret = cpdma_chan_submit(priv->rxch, skb, skb->data,\r\nskb_tailroom(skb), GFP_KERNEL);\r\nif (WARN_ON(ret < 0))\r\nbreak;\r\n}\r\ncpsw_info(priv, ifup, "submitted %d rx descriptors\n", i);\r\ncpdma_ctlr_start(priv->dma);\r\ncpsw_intr_enable(priv);\r\nnapi_enable(&priv->napi);\r\ncpdma_ctlr_eoi(priv->dma);\r\nreturn 0;\r\n}\r\nstatic void cpsw_slave_stop(struct cpsw_slave *slave, struct cpsw_priv *priv)\r\n{\r\nif (!slave->phy)\r\nreturn;\r\nphy_stop(slave->phy);\r\nphy_disconnect(slave->phy);\r\nslave->phy = NULL;\r\n}\r\nstatic int cpsw_ndo_stop(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\ncpsw_info(priv, ifdown, "shutting down cpsw device\n");\r\ncpsw_intr_disable(priv);\r\ncpdma_ctlr_int_ctrl(priv->dma, false);\r\ncpdma_ctlr_stop(priv->dma);\r\nnetif_stop_queue(priv->ndev);\r\nnapi_disable(&priv->napi);\r\nnetif_carrier_off(priv->ndev);\r\ncpsw_ale_stop(priv->ale);\r\nfor_each_slave(priv, cpsw_slave_stop, priv);\r\nclk_disable(priv->clk);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nndev->trans_start = jiffies;\r\nif (skb_padto(skb, CPSW_MIN_PACKET_SIZE)) {\r\ncpsw_err(priv, tx_err, "packet pad failed\n");\r\npriv->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nret = cpdma_chan_submit(priv->txch, skb, skb->data,\r\nskb->len, GFP_KERNEL);\r\nif (unlikely(ret != 0)) {\r\ncpsw_err(priv, tx_err, "desc submit failed\n");\r\ngoto fail;\r\n}\r\nreturn NETDEV_TX_OK;\r\nfail:\r\npriv->stats.tx_dropped++;\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nstatic void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)\r\n{\r\nif ((flags & IFF_PROMISC) && (ndev->flags & IFF_PROMISC))\r\ndev_err(&ndev->dev, "promiscuity ignored!\n");\r\nif ((flags & IFF_ALLMULTI) && !(ndev->flags & IFF_ALLMULTI))\r\ndev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");\r\n}\r\nstatic void cpsw_ndo_tx_timeout(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\ncpsw_err(priv, tx_err, "transmit timeout, restarting dma\n");\r\npriv->stats.tx_errors++;\r\ncpsw_intr_disable(priv);\r\ncpdma_ctlr_int_ctrl(priv->dma, false);\r\ncpdma_chan_stop(priv->txch);\r\ncpdma_chan_start(priv->txch);\r\ncpdma_ctlr_int_ctrl(priv->dma, true);\r\ncpsw_intr_enable(priv);\r\ncpdma_ctlr_eoi(priv->dma);\r\n}\r\nstatic struct net_device_stats *cpsw_ndo_get_stats(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nreturn &priv->stats;\r\n}\r\nstatic void cpsw_ndo_poll_controller(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\ncpsw_intr_disable(priv);\r\ncpdma_ctlr_int_ctrl(priv->dma, false);\r\ncpsw_interrupt(ndev->irq, priv);\r\ncpdma_ctlr_int_ctrl(priv->dma, true);\r\ncpsw_intr_enable(priv);\r\ncpdma_ctlr_eoi(priv->dma);\r\n}\r\nstatic void cpsw_get_drvinfo(struct net_device *ndev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nstrcpy(info->driver, "TI CPSW Driver v1.0");\r\nstrcpy(info->version, "1.0");\r\nstrcpy(info->bus_info, priv->pdev->name);\r\n}\r\nstatic u32 cpsw_get_msglevel(struct net_device *ndev)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void cpsw_set_msglevel(struct net_device *ndev, u32 value)\r\n{\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\npriv->msg_enable = value;\r\n}\r\nstatic void cpsw_slave_init(struct cpsw_slave *slave, struct cpsw_priv *priv)\r\n{\r\nvoid __iomem *regs = priv->regs;\r\nint slave_num = slave->slave_num;\r\nstruct cpsw_slave_data *data = priv->data.slave_data + slave_num;\r\nslave->data = data;\r\nslave->regs = regs + data->slave_reg_ofs;\r\nslave->sliver = regs + data->sliver_reg_ofs;\r\n}\r\nstatic int __devinit cpsw_probe(struct platform_device *pdev)\r\n{\r\nstruct cpsw_platform_data *data = pdev->dev.platform_data;\r\nstruct net_device *ndev;\r\nstruct cpsw_priv *priv;\r\nstruct cpdma_params dma_params;\r\nstruct cpsw_ale_params ale_params;\r\nvoid __iomem *regs;\r\nstruct resource *res;\r\nint ret = 0, i, k = 0;\r\nif (!data) {\r\npr_err("platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\nndev = alloc_etherdev(sizeof(struct cpsw_priv));\r\nif (!ndev) {\r\npr_err("error allocating net_device\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\npriv = netdev_priv(ndev);\r\nspin_lock_init(&priv->lock);\r\npriv->data = *data;\r\npriv->pdev = pdev;\r\npriv->ndev = ndev;\r\npriv->dev = &ndev->dev;\r\npriv->msg_enable = netif_msg_init(debug_level, CPSW_DEBUG);\r\npriv->rx_packet_max = max(rx_packet_max, 128);\r\nif (is_valid_ether_addr(data->slave_data[0].mac_addr)) {\r\nmemcpy(priv->mac_addr, data->slave_data[0].mac_addr, ETH_ALEN);\r\npr_info("Detected MACID = %pM", priv->mac_addr);\r\n} else {\r\nrandom_ether_addr(priv->mac_addr);\r\npr_info("Random MACID = %pM", priv->mac_addr);\r\n}\r\nmemcpy(ndev->dev_addr, priv->mac_addr, ETH_ALEN);\r\npriv->slaves = kzalloc(sizeof(struct cpsw_slave) * data->slaves,\r\nGFP_KERNEL);\r\nif (!priv->slaves) {\r\nret = -EBUSY;\r\ngoto clean_ndev_ret;\r\n}\r\nfor (i = 0; i < data->slaves; i++)\r\npriv->slaves[i].slave_num = i;\r\npriv->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(priv->dev, "failed to get device clock)\n");\r\nret = -EBUSY;\r\n}\r\npriv->cpsw_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!priv->cpsw_res) {\r\ndev_err(priv->dev, "error getting i/o resource\n");\r\nret = -ENOENT;\r\ngoto clean_clk_ret;\r\n}\r\nif (!request_mem_region(priv->cpsw_res->start,\r\nresource_size(priv->cpsw_res), ndev->name)) {\r\ndev_err(priv->dev, "failed request i/o region\n");\r\nret = -ENXIO;\r\ngoto clean_clk_ret;\r\n}\r\nregs = ioremap(priv->cpsw_res->start, resource_size(priv->cpsw_res));\r\nif (!regs) {\r\ndev_err(priv->dev, "unable to map i/o region\n");\r\ngoto clean_cpsw_iores_ret;\r\n}\r\npriv->regs = regs;\r\npriv->host_port = data->host_port_num;\r\npriv->host_port_regs = regs + data->host_port_reg_ofs;\r\npriv->cpsw_ss_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!priv->cpsw_ss_res) {\r\ndev_err(priv->dev, "error getting i/o resource\n");\r\nret = -ENOENT;\r\ngoto clean_clk_ret;\r\n}\r\nif (!request_mem_region(priv->cpsw_ss_res->start,\r\nresource_size(priv->cpsw_ss_res), ndev->name)) {\r\ndev_err(priv->dev, "failed request i/o region\n");\r\nret = -ENXIO;\r\ngoto clean_clk_ret;\r\n}\r\nregs = ioremap(priv->cpsw_ss_res->start,\r\nresource_size(priv->cpsw_ss_res));\r\nif (!regs) {\r\ndev_err(priv->dev, "unable to map i/o region\n");\r\ngoto clean_cpsw_ss_iores_ret;\r\n}\r\npriv->ss_regs = regs;\r\nfor_each_slave(priv, cpsw_slave_init, priv);\r\nmemset(&dma_params, 0, sizeof(dma_params));\r\ndma_params.dev = &pdev->dev;\r\ndma_params.dmaregs = cpsw_dma_regs((u32)priv->regs,\r\ndata->cpdma_reg_ofs);\r\ndma_params.rxthresh = cpsw_dma_rxthresh((u32)priv->regs,\r\ndata->cpdma_reg_ofs);\r\ndma_params.rxfree = cpsw_dma_rxfree((u32)priv->regs,\r\ndata->cpdma_reg_ofs);\r\ndma_params.txhdp = cpsw_dma_txhdp((u32)priv->regs,\r\ndata->cpdma_sram_ofs);\r\ndma_params.rxhdp = cpsw_dma_rxhdp((u32)priv->regs,\r\ndata->cpdma_sram_ofs);\r\ndma_params.txcp = cpsw_dma_txcp((u32)priv->regs,\r\ndata->cpdma_sram_ofs);\r\ndma_params.rxcp = cpsw_dma_rxcp((u32)priv->regs,\r\ndata->cpdma_sram_ofs);\r\ndma_params.num_chan = data->channels;\r\ndma_params.has_soft_reset = true;\r\ndma_params.min_packet_size = CPSW_MIN_PACKET_SIZE;\r\ndma_params.desc_mem_size = data->bd_ram_size;\r\ndma_params.desc_align = 16;\r\ndma_params.has_ext_regs = true;\r\ndma_params.desc_mem_phys = data->no_bd_ram ? 0 :\r\n(u32 __force)priv->cpsw_res->start + data->bd_ram_ofs;\r\ndma_params.desc_hw_addr = data->hw_ram_addr ?\r\ndata->hw_ram_addr : dma_params.desc_mem_phys ;\r\npriv->dma = cpdma_ctlr_create(&dma_params);\r\nif (!priv->dma) {\r\ndev_err(priv->dev, "error initializing dma\n");\r\nret = -ENOMEM;\r\ngoto clean_iomap_ret;\r\n}\r\npriv->txch = cpdma_chan_create(priv->dma, tx_chan_num(0),\r\ncpsw_tx_handler);\r\npriv->rxch = cpdma_chan_create(priv->dma, rx_chan_num(0),\r\ncpsw_rx_handler);\r\nif (WARN_ON(!priv->txch || !priv->rxch)) {\r\ndev_err(priv->dev, "error initializing dma channels\n");\r\nret = -ENOMEM;\r\ngoto clean_dma_ret;\r\n}\r\nmemset(&ale_params, 0, sizeof(ale_params));\r\nale_params.dev = &ndev->dev;\r\nale_params.ale_regs = (void *)((u32)priv->regs) +\r\n((u32)data->ale_reg_ofs);\r\nale_params.ale_ageout = ale_ageout;\r\nale_params.ale_entries = data->ale_entries;\r\nale_params.ale_ports = data->slaves;\r\npriv->ale = cpsw_ale_create(&ale_params);\r\nif (!priv->ale) {\r\ndev_err(priv->dev, "error initializing ale engine\n");\r\nret = -ENODEV;\r\ngoto clean_dma_ret;\r\n}\r\nndev->irq = platform_get_irq(pdev, 0);\r\nif (ndev->irq < 0) {\r\ndev_err(priv->dev, "error getting irq resource\n");\r\nret = -ENOENT;\r\ngoto clean_ale_ret;\r\n}\r\nwhile ((res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, k))) {\r\nfor (i = res->start; i <= res->end; i++) {\r\nif (request_irq(i, cpsw_interrupt, IRQF_DISABLED,\r\ndev_name(&pdev->dev), priv)) {\r\ndev_err(priv->dev, "error attaching irq\n");\r\ngoto clean_ale_ret;\r\n}\r\npriv->irqs_table[k] = i;\r\npriv->num_irqs = k;\r\n}\r\nk++;\r\n}\r\nndev->flags |= IFF_ALLMULTI;\r\nndev->netdev_ops = &cpsw_netdev_ops;\r\nSET_ETHTOOL_OPS(ndev, &cpsw_ethtool_ops);\r\nnetif_napi_add(ndev, &priv->napi, cpsw_poll, CPSW_POLL_WEIGHT);\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(priv->dev, "error registering net device\n");\r\nret = -ENODEV;\r\ngoto clean_irq_ret;\r\n}\r\ncpsw_notice(priv, probe, "initialized device (regs %x, irq %d)\n",\r\npriv->cpsw_res->start, ndev->irq);\r\nreturn 0;\r\nclean_irq_ret:\r\nfree_irq(ndev->irq, priv);\r\nclean_ale_ret:\r\ncpsw_ale_destroy(priv->ale);\r\nclean_dma_ret:\r\ncpdma_chan_destroy(priv->txch);\r\ncpdma_chan_destroy(priv->rxch);\r\ncpdma_ctlr_destroy(priv->dma);\r\nclean_iomap_ret:\r\niounmap(priv->regs);\r\nclean_cpsw_ss_iores_ret:\r\nrelease_mem_region(priv->cpsw_ss_res->start,\r\nresource_size(priv->cpsw_ss_res));\r\nclean_cpsw_iores_ret:\r\nrelease_mem_region(priv->cpsw_res->start,\r\nresource_size(priv->cpsw_res));\r\nclean_clk_ret:\r\nclk_put(priv->clk);\r\nkfree(priv->slaves);\r\nclean_ndev_ret:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int __devexit cpsw_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct cpsw_priv *priv = netdev_priv(ndev);\r\npr_info("removing device");\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(ndev->irq, priv);\r\ncpsw_ale_destroy(priv->ale);\r\ncpdma_chan_destroy(priv->txch);\r\ncpdma_chan_destroy(priv->rxch);\r\ncpdma_ctlr_destroy(priv->dma);\r\niounmap(priv->regs);\r\nrelease_mem_region(priv->cpsw_res->start,\r\nresource_size(priv->cpsw_res));\r\nrelease_mem_region(priv->cpsw_ss_res->start,\r\nresource_size(priv->cpsw_ss_res));\r\nclk_put(priv->clk);\r\nkfree(priv->slaves);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int cpsw_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nif (netif_running(ndev))\r\ncpsw_ndo_stop(ndev);\r\nreturn 0;\r\n}\r\nstatic int cpsw_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nif (netif_running(ndev))\r\ncpsw_ndo_open(ndev);\r\nreturn 0;\r\n}\r\nstatic int __init cpsw_init(void)\r\n{\r\nreturn platform_driver_register(&cpsw_driver);\r\n}\r\nstatic void __exit cpsw_exit(void)\r\n{\r\nplatform_driver_unregister(&cpsw_driver);\r\n}
