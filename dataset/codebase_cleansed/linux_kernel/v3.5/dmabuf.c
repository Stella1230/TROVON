static long dmabuf_timeout(struct dma_buffparms *dmap)\r\n{\r\nlong tmout;\r\ntmout = (dmap->fragment_size * HZ) / dmap->data_rate;\r\ntmout += HZ / 5;\r\nif (tmout < (HZ / 2))\r\ntmout = HZ / 2;\r\nif (tmout > 20 * HZ)\r\ntmout = 20 * HZ;\r\nreturn tmout;\r\n}\r\nstatic int sound_alloc_dmap(struct dma_buffparms *dmap)\r\n{\r\nchar *start_addr, *end_addr;\r\nint dma_pagesize;\r\nint sz, size;\r\nstruct page *page;\r\ndmap->mapping_flags &= ~DMA_MAP_MAPPED;\r\nif (dmap->raw_buf != NULL)\r\nreturn 0;\r\nif (dma_buffsize < 4096)\r\ndma_buffsize = 4096;\r\ndma_pagesize = (dmap->dma < 4) ? (64 * 1024) : (128 * 1024);\r\nif(isa_dma_bridge_buggy==2)\r\ndma_pagesize=32768;\r\ndmap->raw_buf = NULL;\r\ndmap->buffsize = dma_buffsize;\r\nif (dmap->buffsize > dma_pagesize)\r\ndmap->buffsize = dma_pagesize;\r\nstart_addr = NULL;\r\nwhile (start_addr == NULL && dmap->buffsize > PAGE_SIZE) {\r\nfor (sz = 0, size = PAGE_SIZE; size < dmap->buffsize; sz++, size <<= 1);\r\ndmap->buffsize = PAGE_SIZE * (1 << sz);\r\nstart_addr = (char *) __get_free_pages(GFP_ATOMIC|GFP_DMA|__GFP_NOWARN, sz);\r\nif (start_addr == NULL)\r\ndmap->buffsize /= 2;\r\n}\r\nif (start_addr == NULL) {\r\nprintk(KERN_WARNING "Sound error: Couldn't allocate DMA buffer\n");\r\nreturn -ENOMEM;\r\n} else {\r\nend_addr = start_addr + dmap->buffsize - 1;\r\nif (debugmem)\r\nprintk(KERN_DEBUG "sound: start 0x%lx, end 0x%lx\n", (long) start_addr, (long) end_addr);\r\nif (((long) start_addr & ~(dma_pagesize - 1)) != ((long) end_addr & ~(dma_pagesize - 1))\r\n|| end_addr >= (char *) (MAX_DMA_ADDRESS)) {\r\nprintk(KERN_ERR "sound: Got invalid address 0x%lx for %db DMA-buffer\n", (long) start_addr, dmap->buffsize);\r\nreturn -EFAULT;\r\n}\r\n}\r\ndmap->raw_buf = start_addr;\r\ndmap->raw_buf_phys = virt_to_bus(start_addr);\r\nfor (page = virt_to_page(start_addr); page <= virt_to_page(end_addr); page++)\r\nSetPageReserved(page);\r\nreturn 0;\r\n}\r\nstatic void sound_free_dmap(struct dma_buffparms *dmap)\r\n{\r\nint sz, size;\r\nstruct page *page;\r\nunsigned long start_addr, end_addr;\r\nif (dmap->raw_buf == NULL)\r\nreturn;\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED)\r\nreturn;\r\nfor (sz = 0, size = PAGE_SIZE; size < dmap->buffsize; sz++, size <<= 1);\r\nstart_addr = (unsigned long) dmap->raw_buf;\r\nend_addr = start_addr + dmap->buffsize;\r\nfor (page = virt_to_page(start_addr); page <= virt_to_page(end_addr); page++)\r\nClearPageReserved(page);\r\nfree_pages((unsigned long) dmap->raw_buf, sz);\r\ndmap->raw_buf = NULL;\r\n}\r\nstatic int sound_start_dma(struct dma_buffparms *dmap, unsigned long physaddr, int count, int dma_mode)\r\n{\r\nunsigned long flags;\r\nint chan = dmap->dma;\r\nflags = claim_dma_lock();\r\ndisable_dma(chan);\r\nclear_dma_ff(chan);\r\nset_dma_mode(chan, dma_mode);\r\nset_dma_addr(chan, physaddr);\r\nset_dma_count(chan, count);\r\nenable_dma(chan);\r\nrelease_dma_lock(flags);\r\nreturn 0;\r\n}\r\nstatic void dma_init_buffers(struct dma_buffparms *dmap)\r\n{\r\ndmap->qlen = dmap->qhead = dmap->qtail = dmap->user_counter = 0;\r\ndmap->byte_counter = 0;\r\ndmap->max_byte_counter = 8000 * 60 * 60;\r\ndmap->bytes_in_use = dmap->buffsize;\r\ndmap->dma_mode = DMODE_NONE;\r\ndmap->mapping_flags = 0;\r\ndmap->neutral_byte = 0x80;\r\ndmap->data_rate = 8000;\r\ndmap->cfrag = -1;\r\ndmap->closing = 0;\r\ndmap->nbufs = 1;\r\ndmap->flags = DMA_BUSY;\r\n}\r\nstatic int open_dmap(struct audio_operations *adev, int mode, struct dma_buffparms *dmap)\r\n{\r\nint err;\r\nif (dmap->flags & DMA_BUSY)\r\nreturn -EBUSY;\r\nif ((err = sound_alloc_dmap(dmap)) < 0)\r\nreturn err;\r\nif (dmap->raw_buf == NULL) {\r\nprintk(KERN_WARNING "Sound: DMA buffers not available\n");\r\nreturn -ENOSPC;\r\n}\r\nif (dmap->dma >= 0 && sound_open_dma(dmap->dma, adev->name)) {\r\nprintk(KERN_WARNING "Unable to grab(2) DMA%d for the audio driver\n", dmap->dma);\r\nreturn -EBUSY;\r\n}\r\ndma_init_buffers(dmap);\r\nspin_lock_init(&dmap->lock);\r\ndmap->open_mode = mode;\r\ndmap->subdivision = dmap->underrun_count = 0;\r\ndmap->fragment_size = 0;\r\ndmap->max_fragments = 65536;\r\ndmap->byte_counter = 0;\r\ndmap->max_byte_counter = 8000 * 60 * 60;\r\ndmap->applic_profile = APF_NORMAL;\r\ndmap->needs_reorg = 1;\r\ndmap->audio_callback = NULL;\r\ndmap->callback_parm = 0;\r\nreturn 0;\r\n}\r\nstatic void close_dmap(struct audio_operations *adev, struct dma_buffparms *dmap)\r\n{\r\nunsigned long flags;\r\nif (dmap->dma >= 0) {\r\nsound_close_dma(dmap->dma);\r\nflags=claim_dma_lock();\r\ndisable_dma(dmap->dma);\r\nrelease_dma_lock(flags);\r\n}\r\nif (dmap->flags & DMA_BUSY)\r\ndmap->dma_mode = DMODE_NONE;\r\ndmap->flags &= ~DMA_BUSY;\r\nif (sound_dmap_flag == DMAP_FREE_ON_CLOSE)\r\nsound_free_dmap(dmap);\r\n}\r\nstatic unsigned int default_set_bits(int dev, unsigned int bits)\r\n{\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\naudio_devs[dev]->d->ioctl(dev, SNDCTL_DSP_SETFMT, (void __user *)&bits);\r\nset_fs(fs);\r\nreturn bits;\r\n}\r\nstatic int default_set_speed(int dev, int speed)\r\n{\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\naudio_devs[dev]->d->ioctl(dev, SNDCTL_DSP_SPEED, (void __user *)&speed);\r\nset_fs(fs);\r\nreturn speed;\r\n}\r\nstatic short default_set_channels(int dev, short channels)\r\n{\r\nint c = channels;\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\naudio_devs[dev]->d->ioctl(dev, SNDCTL_DSP_CHANNELS, (void __user *)&c);\r\nset_fs(fs);\r\nreturn c;\r\n}\r\nstatic void check_driver(struct audio_driver *d)\r\n{\r\nif (d->set_speed == NULL)\r\nd->set_speed = default_set_speed;\r\nif (d->set_bits == NULL)\r\nd->set_bits = default_set_bits;\r\nif (d->set_channels == NULL)\r\nd->set_channels = default_set_channels;\r\n}\r\nint DMAbuf_open(int dev, int mode)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nint retval;\r\nstruct dma_buffparms *dmap_in = NULL;\r\nstruct dma_buffparms *dmap_out = NULL;\r\nif (!adev)\r\nreturn -ENXIO;\r\nif (!(adev->flags & DMA_DUPLEX))\r\nadev->dmap_in = adev->dmap_out;\r\ncheck_driver(adev->d);\r\nif ((retval = adev->d->open(dev, mode)) < 0)\r\nreturn retval;\r\ndmap_out = adev->dmap_out;\r\ndmap_in = adev->dmap_in;\r\nif (dmap_in == dmap_out)\r\nadev->flags &= ~DMA_DUPLEX;\r\nif (mode & OPEN_WRITE) {\r\nif ((retval = open_dmap(adev, mode, dmap_out)) < 0) {\r\nadev->d->close(dev);\r\nreturn retval;\r\n}\r\n}\r\nadev->enable_bits = mode;\r\nif (mode == OPEN_READ || (mode != OPEN_WRITE && (adev->flags & DMA_DUPLEX))) {\r\nif ((retval = open_dmap(adev, mode, dmap_in)) < 0) {\r\nadev->d->close(dev);\r\nif (mode & OPEN_WRITE)\r\nclose_dmap(adev, dmap_out);\r\nreturn retval;\r\n}\r\n}\r\nadev->open_mode = mode;\r\nadev->go = 1;\r\nadev->d->set_bits(dev, 8);\r\nadev->d->set_channels(dev, 1);\r\nadev->d->set_speed(dev, DSP_DEFAULT_SPEED);\r\nif (adev->dmap_out->dma_mode == DMODE_OUTPUT)\r\nmemset(adev->dmap_out->raw_buf, adev->dmap_out->neutral_byte,\r\nadev->dmap_out->bytes_in_use);\r\nreturn 0;\r\n}\r\nvoid DMAbuf_reset(int dev)\r\n{\r\nif (audio_devs[dev]->open_mode & OPEN_WRITE)\r\ndma_reset_output(dev);\r\nif (audio_devs[dev]->open_mode & OPEN_READ)\r\ndma_reset_input(dev);\r\n}\r\nstatic void dma_reset_output(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nunsigned long flags,f ;\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nif (!(dmap->flags & DMA_STARTED))\r\nreturn;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nadev->dmap_out->flags |= DMA_SYNCING;\r\nadev->dmap_out->underrun_count = 0;\r\nif (!signal_pending(current) && adev->dmap_out->qlen &&\r\nadev->dmap_out->underrun_count == 0){\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\ninterruptible_sleep_on_timeout(&adev->out_sleeper,\r\ndmabuf_timeout(dmap));\r\nspin_lock_irqsave(&dmap->lock,flags);\r\n}\r\nadev->dmap_out->flags &= ~(DMA_SYNCING | DMA_ACTIVE);\r\nif (!(adev->flags & DMA_DUPLEX) || !adev->d->halt_output)\r\nadev->d->halt_io(dev);\r\nelse\r\nadev->d->halt_output(dev);\r\nadev->dmap_out->flags &= ~DMA_STARTED;\r\nf=claim_dma_lock();\r\nclear_dma_ff(dmap->dma);\r\ndisable_dma(dmap->dma);\r\nrelease_dma_lock(f);\r\ndmap->byte_counter = 0;\r\nreorganize_buffers(dev, adev->dmap_out, 0);\r\ndmap->qlen = dmap->qhead = dmap->qtail = dmap->user_counter = 0;\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\n}\r\nstatic void dma_reset_input(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nunsigned long flags;\r\nstruct dma_buffparms *dmap = adev->dmap_in;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (!(adev->flags & DMA_DUPLEX) || !adev->d->halt_input)\r\nadev->d->halt_io(dev);\r\nelse\r\nadev->d->halt_input(dev);\r\nadev->dmap_in->flags &= ~DMA_STARTED;\r\ndmap->qlen = dmap->qhead = dmap->qtail = dmap->user_counter = 0;\r\ndmap->byte_counter = 0;\r\nreorganize_buffers(dev, adev->dmap_in, 1);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\n}\r\nvoid DMAbuf_launch_output(int dev, struct dma_buffparms *dmap)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nif (!((adev->enable_bits * adev->go) & PCM_ENABLE_OUTPUT))\r\nreturn;\r\ndmap->dma_mode = DMODE_OUTPUT;\r\nif (!(dmap->flags & DMA_ACTIVE) || !(adev->flags & DMA_AUTOMODE) || (dmap->flags & DMA_NODMA)) {\r\nif (!(dmap->flags & DMA_STARTED)) {\r\nreorganize_buffers(dev, dmap, 0);\r\nif (adev->d->prepare_for_output(dev, dmap->fragment_size, dmap->nbufs))\r\nreturn;\r\nif (!(dmap->flags & DMA_NODMA))\r\nlocal_start_dma(adev, dmap->raw_buf_phys, dmap->bytes_in_use,DMA_MODE_WRITE);\r\ndmap->flags |= DMA_STARTED;\r\n}\r\nif (dmap->counts[dmap->qhead] == 0)\r\ndmap->counts[dmap->qhead] = dmap->fragment_size;\r\ndmap->dma_mode = DMODE_OUTPUT;\r\nadev->d->output_block(dev, dmap->raw_buf_phys + dmap->qhead * dmap->fragment_size,\r\ndmap->counts[dmap->qhead], 1);\r\nif (adev->d->trigger)\r\nadev->d->trigger(dev,adev->enable_bits * adev->go);\r\n}\r\ndmap->flags |= DMA_ACTIVE;\r\n}\r\nint DMAbuf_sync(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nunsigned long flags;\r\nint n = 0;\r\nstruct dma_buffparms *dmap;\r\nif (!adev->go && !(adev->enable_bits & PCM_ENABLE_OUTPUT))\r\nreturn 0;\r\nif (adev->dmap_out->dma_mode == DMODE_OUTPUT) {\r\ndmap = adev->dmap_out;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (dmap->qlen > 0 && !(dmap->flags & DMA_ACTIVE))\r\nDMAbuf_launch_output(dev, dmap);\r\nadev->dmap_out->flags |= DMA_SYNCING;\r\nadev->dmap_out->underrun_count = 0;\r\nwhile (!signal_pending(current) && n++ < adev->dmap_out->nbufs &&\r\nadev->dmap_out->qlen && adev->dmap_out->underrun_count == 0) {\r\nlong t = dmabuf_timeout(dmap);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nt = interruptible_sleep_on_timeout(&adev->out_sleeper, t);\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (!t) {\r\nadev->dmap_out->flags &= ~DMA_SYNCING;\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn adev->dmap_out->qlen;\r\n}\r\n}\r\nadev->dmap_out->flags &= ~(DMA_SYNCING | DMA_ACTIVE);\r\nif (adev->d->local_qlen) {\r\nwhile (!signal_pending(current) &&\r\nadev->d->local_qlen(dev)){\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\ninterruptible_sleep_on_timeout(&adev->out_sleeper,\r\ndmabuf_timeout(dmap));\r\nspin_lock_irqsave(&dmap->lock,flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\n}\r\nadev->dmap_out->dma_mode = DMODE_NONE;\r\nreturn adev->dmap_out->qlen;\r\n}\r\nint DMAbuf_release(int dev, int mode)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap;\r\nunsigned long flags;\r\ndmap = adev->dmap_out;\r\nif (adev->open_mode & OPEN_WRITE)\r\nadev->dmap_out->closing = 1;\r\nif (adev->open_mode & OPEN_READ){\r\nadev->dmap_in->closing = 1;\r\ndmap = adev->dmap_in;\r\n}\r\nif (adev->open_mode & OPEN_WRITE)\r\nif (!(adev->dmap_out->mapping_flags & DMA_MAP_MAPPED))\r\nif (!signal_pending(current) && (adev->dmap_out->dma_mode == DMODE_OUTPUT))\r\nDMAbuf_sync(dev);\r\nif (adev->dmap_out->dma_mode == DMODE_OUTPUT)\r\nmemset(adev->dmap_out->raw_buf, adev->dmap_out->neutral_byte, adev->dmap_out->bytes_in_use);\r\nDMAbuf_reset(dev);\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nadev->d->close(dev);\r\nif (adev->open_mode & OPEN_WRITE)\r\nclose_dmap(adev, adev->dmap_out);\r\nif (adev->open_mode == OPEN_READ ||\r\n(adev->open_mode != OPEN_WRITE &&\r\n(adev->flags & DMA_DUPLEX)))\r\nclose_dmap(adev, adev->dmap_in);\r\nadev->open_mode = 0;\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn 0;\r\n}\r\nint DMAbuf_activate_recording(int dev, struct dma_buffparms *dmap)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nint err;\r\nif (!(adev->open_mode & OPEN_READ))\r\nreturn 0;\r\nif (!(adev->enable_bits & PCM_ENABLE_INPUT))\r\nreturn 0;\r\nif (dmap->dma_mode == DMODE_OUTPUT) {\r\nspin_unlock_irq(&dmap->lock);\r\nDMAbuf_sync(dev);\r\nDMAbuf_reset(dev);\r\nspin_lock_irq(&dmap->lock);\r\ndmap->dma_mode = DMODE_NONE;\r\n}\r\nif (!dmap->dma_mode) {\r\nreorganize_buffers(dev, dmap, 1);\r\nif ((err = adev->d->prepare_for_input(dev,\r\ndmap->fragment_size, dmap->nbufs)) < 0)\r\nreturn err;\r\ndmap->dma_mode = DMODE_INPUT;\r\n}\r\nif (!(dmap->flags & DMA_ACTIVE)) {\r\nif (dmap->needs_reorg)\r\nreorganize_buffers(dev, dmap, 0);\r\nlocal_start_dma(adev, dmap->raw_buf_phys, dmap->bytes_in_use, DMA_MODE_READ);\r\nadev->d->start_input(dev, dmap->raw_buf_phys + dmap->qtail * dmap->fragment_size,\r\ndmap->fragment_size, 0);\r\ndmap->flags |= DMA_ACTIVE;\r\nif (adev->d->trigger)\r\nadev->d->trigger(dev, adev->enable_bits * adev->go);\r\n}\r\nreturn 0;\r\n}\r\nint DMAbuf_getrdbuffer(int dev, char **buf, int *len, int dontblock)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nunsigned long flags;\r\nint err = 0, n = 0;\r\nstruct dma_buffparms *dmap = adev->dmap_in;\r\nint go;\r\nif (!(adev->open_mode & OPEN_READ))\r\nreturn -EIO;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (dmap->needs_reorg)\r\nreorganize_buffers(dev, dmap, 0);\r\nif (adev->dmap_in->mapping_flags & DMA_MAP_MAPPED) {\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn -EINVAL;\r\n} else while (dmap->qlen <= 0 && n++ < 10) {\r\nlong timeout = MAX_SCHEDULE_TIMEOUT;\r\nif (!(adev->enable_bits & PCM_ENABLE_INPUT) || !adev->go) {\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn -EAGAIN;\r\n}\r\nif ((err = DMAbuf_activate_recording(dev, dmap)) < 0) {\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn err;\r\n}\r\nif (dontblock) {\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn -EAGAIN;\r\n}\r\nif ((go = adev->go))\r\ntimeout = dmabuf_timeout(dmap);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\ntimeout = interruptible_sleep_on_timeout(&adev->in_sleeper,\r\ntimeout);\r\nif (!timeout) {\r\nerr = -EIO;\r\nprintk(KERN_WARNING "Sound: DMA (input) timed out - IRQ/DRQ config error?\n");\r\ndma_reset_input(dev);\r\n} else\r\nerr = -EINTR;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\n}\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nif (dmap->qlen <= 0)\r\nreturn err ? err : -EINTR;\r\n*buf = &dmap->raw_buf[dmap->qhead * dmap->fragment_size + dmap->counts[dmap->qhead]];\r\n*len = dmap->fragment_size - dmap->counts[dmap->qhead];\r\nreturn dmap->qhead;\r\n}\r\nint DMAbuf_rmchars(int dev, int buff_no, int c)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_in;\r\nint p = dmap->counts[dmap->qhead] + c;\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED)\r\n{\r\nreturn -EINVAL;\r\n}\r\nelse if (dmap->qlen <= 0)\r\nreturn -EIO;\r\nelse if (p >= dmap->fragment_size) {\r\ndmap->counts[dmap->qhead] = 0;\r\ndmap->qlen--;\r\ndmap->qhead = (dmap->qhead + 1) % dmap->nbufs;\r\n}\r\nelse dmap->counts[dmap->qhead] = p;\r\nreturn 0;\r\n}\r\nint DMAbuf_get_buffer_pointer(int dev, struct dma_buffparms *dmap, int direction)\r\n{\r\nint pos;\r\nunsigned long f;\r\nif (!(dmap->flags & DMA_ACTIVE))\r\npos = 0;\r\nelse {\r\nint chan = dmap->dma;\r\nf=claim_dma_lock();\r\nclear_dma_ff(chan);\r\nif(!isa_dma_bridge_buggy)\r\ndisable_dma(dmap->dma);\r\npos = get_dma_residue(chan);\r\npos = dmap->bytes_in_use - pos;\r\nif (!(dmap->mapping_flags & DMA_MAP_MAPPED)) {\r\nif (direction == DMODE_OUTPUT) {\r\nif (dmap->qhead == 0)\r\nif (pos > dmap->fragment_size)\r\npos = 0;\r\n} else {\r\nif (dmap->qtail == 0)\r\nif (pos > dmap->fragment_size)\r\npos = 0;\r\n}\r\n}\r\nif (pos < 0)\r\npos = 0;\r\nif (pos >= dmap->bytes_in_use)\r\npos = 0;\r\nif(!isa_dma_bridge_buggy)\r\nenable_dma(dmap->dma);\r\nrelease_dma_lock(f);\r\n}\r\nreturn pos;\r\n}\r\nvoid DMAbuf_start_devices(unsigned int devmask)\r\n{\r\nstruct audio_operations *adev;\r\nint dev;\r\nfor (dev = 0; dev < num_audiodevs; dev++) {\r\nif (!(devmask & (1 << dev)))\r\ncontinue;\r\nif (!(adev = audio_devs[dev]))\r\ncontinue;\r\nif (adev->open_mode == 0)\r\ncontinue;\r\nif (adev->go)\r\ncontinue;\r\nadev->go = 1;\r\nif (adev->d->trigger)\r\nadev->d->trigger(dev,adev->enable_bits * adev->go);\r\n}\r\n}\r\nint DMAbuf_space_in_queue(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nint len, max, tmp;\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nint lim = dmap->nbufs;\r\nif (lim < 2)\r\nlim = 2;\r\nif (dmap->qlen >= lim)\r\nreturn 0;\r\nmax = dmap->max_fragments;\r\nif (max > lim)\r\nmax = lim;\r\nlen = dmap->qlen;\r\nif (adev->d->local_qlen) {\r\ntmp = adev->d->local_qlen(dev);\r\nif (tmp && len)\r\ntmp--;\r\nlen += tmp;\r\n}\r\nif (dmap->byte_counter % dmap->fragment_size)\r\nlen = len + 1;\r\nif (len >= max)\r\nreturn 0;\r\nreturn max - len;\r\n}\r\nstatic int output_sleep(int dev, int dontblock)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nint err = 0;\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nlong timeout;\r\nlong timeout_value;\r\nif (dontblock)\r\nreturn -EAGAIN;\r\nif (!(adev->enable_bits & PCM_ENABLE_OUTPUT))\r\nreturn -EAGAIN;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\ntimeout = (adev->go && !(dmap->flags & DMA_NOTIMEOUT));\r\nif (timeout)\r\ntimeout_value = dmabuf_timeout(dmap);\r\nelse\r\ntimeout_value = MAX_SCHEDULE_TIMEOUT;\r\ntimeout_value = interruptible_sleep_on_timeout(&adev->out_sleeper,\r\ntimeout_value);\r\nif (timeout != MAX_SCHEDULE_TIMEOUT && !timeout_value) {\r\nprintk(KERN_WARNING "Sound: DMA (output) timed out - IRQ/DRQ config error?\n");\r\ndma_reset_output(dev);\r\n} else {\r\nif (signal_pending(current))\r\nerr = -EINTR;\r\n}\r\nreturn err;\r\n}\r\nstatic int find_output_space(int dev, char **buf, int *size)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nunsigned long active_offs;\r\nlong len, offs;\r\nint maxfrags;\r\nint occupied_bytes = (dmap->user_counter % dmap->fragment_size);\r\n*buf = dmap->raw_buf;\r\nif (!(maxfrags = DMAbuf_space_in_queue(dev)) && !occupied_bytes)\r\nreturn 0;\r\n#ifdef BE_CONSERVATIVE\r\nactive_offs = dmap->byte_counter + dmap->qhead * dmap->fragment_size;\r\n#else\r\nactive_offs = max(DMAbuf_get_buffer_pointer(dev, dmap, DMODE_OUTPUT), 0);\r\nif (active_offs >= dmap->bytes_in_use)\r\nactive_offs = 0;\r\nactive_offs += dmap->byte_counter;\r\n#endif\r\noffs = (dmap->user_counter % dmap->bytes_in_use) & ~SAMPLE_ROUNDUP;\r\nif (offs < 0 || offs >= dmap->bytes_in_use) {\r\nprintk(KERN_ERR "Sound: Got unexpected offs %ld. Giving up.\n", offs);\r\nprintk("Counter = %ld, bytes=%d\n", dmap->user_counter, dmap->bytes_in_use);\r\nreturn 0;\r\n}\r\n*buf = dmap->raw_buf + offs;\r\nlen = active_offs + dmap->bytes_in_use - dmap->user_counter;\r\nif ((offs + len) > dmap->bytes_in_use)\r\nlen = dmap->bytes_in_use - offs;\r\nif (len < 0) {\r\nreturn 0;\r\n}\r\nif (len > ((maxfrags * dmap->fragment_size) - occupied_bytes))\r\nlen = (maxfrags * dmap->fragment_size) - occupied_bytes;\r\n*size = len & ~SAMPLE_ROUNDUP;\r\nreturn (*size > 0);\r\n}\r\nint DMAbuf_getwrbuffer(int dev, char **buf, int *size, int dontblock)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nunsigned long flags;\r\nint err = -EIO;\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED) {\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (dmap->needs_reorg)\r\nreorganize_buffers(dev, dmap, 0);\r\nif (dmap->dma_mode == DMODE_INPUT) {\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nDMAbuf_reset(dev);\r\nspin_lock_irqsave(&dmap->lock,flags);\r\n}\r\ndmap->dma_mode = DMODE_OUTPUT;\r\nwhile (find_output_space(dev, buf, size) <= 0) {\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nif ((err = output_sleep(dev, dontblock)) < 0) {\r\nreturn err;\r\n}\r\nspin_lock_irqsave(&dmap->lock,flags);\r\n}\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn 0;\r\n}\r\nint DMAbuf_move_wrpointer(int dev, int l)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nunsigned long ptr;\r\nunsigned long end_ptr, p;\r\nint post;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\npost= (dmap->flags & DMA_POST);\r\nptr = (dmap->user_counter / dmap->fragment_size) * dmap->fragment_size;\r\ndmap->flags &= ~DMA_POST;\r\ndmap->cfrag = -1;\r\ndmap->user_counter += l;\r\ndmap->flags |= DMA_DIRTY;\r\nif (dmap->byte_counter >= dmap->max_byte_counter) {\r\nlong decr = dmap->byte_counter;\r\ndmap->byte_counter = (dmap->byte_counter % dmap->bytes_in_use);\r\ndecr -= dmap->byte_counter;\r\ndmap->user_counter -= decr;\r\n}\r\nend_ptr = (dmap->user_counter / dmap->fragment_size) * dmap->fragment_size;\r\np = (dmap->user_counter - 1) % dmap->bytes_in_use;\r\ndmap->neutral_byte = dmap->raw_buf[p];\r\nwhile (ptr < end_ptr) {\r\ndmap->counts[dmap->qtail] = dmap->fragment_size;\r\ndmap->qtail = (dmap->qtail + 1) % dmap->nbufs;\r\ndmap->qlen++;\r\nptr += dmap->fragment_size;\r\n}\r\ndmap->counts[dmap->qtail] = dmap->user_counter - ptr;\r\nif (adev->d->postprocess_write)\r\nadev->d->postprocess_write(dev);\r\nif (!(dmap->flags & DMA_ACTIVE))\r\nif (dmap->qlen > 1 || (dmap->qlen > 0 && (post || dmap->qlen >= dmap->nbufs - 1)))\r\nDMAbuf_launch_output(dev, dmap);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\nreturn 0;\r\n}\r\nint DMAbuf_start_dma(int dev, unsigned long physaddr, int count, int dma_mode)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = (dma_mode == DMA_MODE_WRITE) ? adev->dmap_out : adev->dmap_in;\r\nif (dmap->raw_buf == NULL) {\r\nprintk(KERN_ERR "sound: DMA buffer(1) == NULL\n");\r\nprintk("Device %d, chn=%s\n", dev, (dmap == adev->dmap_out) ? "out" : "in");\r\nreturn 0;\r\n}\r\nif (dmap->dma < 0)\r\nreturn 0;\r\nsound_start_dma(dmap, physaddr, count, dma_mode);\r\nreturn count;\r\n}\r\nstatic int local_start_dma(struct audio_operations *adev, unsigned long physaddr, int count, int dma_mode)\r\n{\r\nstruct dma_buffparms *dmap = (dma_mode == DMA_MODE_WRITE) ? adev->dmap_out : adev->dmap_in;\r\nif (dmap->raw_buf == NULL) {\r\nprintk(KERN_ERR "sound: DMA buffer(2) == NULL\n");\r\nprintk(KERN_ERR "Device %s, chn=%s\n", adev->name, (dmap == adev->dmap_out) ? "out" : "in");\r\nreturn 0;\r\n}\r\nif (dmap->flags & DMA_NODMA)\r\nreturn 1;\r\nif (dmap->dma < 0)\r\nreturn 0;\r\nsound_start_dma(dmap, dmap->raw_buf_phys, dmap->bytes_in_use, dma_mode | DMA_AUTOINIT);\r\ndmap->flags |= DMA_STARTED;\r\nreturn count;\r\n}\r\nstatic void finish_output_interrupt(int dev, struct dma_buffparms *dmap)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nif (dmap->audio_callback != NULL)\r\ndmap->audio_callback(dev, dmap->callback_parm);\r\nwake_up(&adev->out_sleeper);\r\nwake_up(&adev->poll_sleeper);\r\n}\r\nstatic void do_outputintr(int dev, int dummy)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nint this_fragment;\r\nif (dmap->raw_buf == NULL) {\r\nprintk(KERN_ERR "Sound: Error. Audio interrupt (%d) after freeing buffers.\n", dev);\r\nreturn;\r\n}\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED) {\r\ndmap->qhead = (dmap->qhead + 1) % dmap->nbufs;\r\nif (dmap->qhead == 0) {\r\ndmap->byte_counter += dmap->bytes_in_use;\r\nif (dmap->byte_counter >= dmap->max_byte_counter) {\r\nlong decr = dmap->byte_counter;\r\ndmap->byte_counter = (dmap->byte_counter % dmap->bytes_in_use);\r\ndecr -= dmap->byte_counter;\r\ndmap->user_counter -= decr;\r\n}\r\n}\r\ndmap->qlen++;\r\nif (!(adev->flags & DMA_AUTOMODE))\r\ndmap->flags &= ~DMA_ACTIVE;\r\ndmap->counts[dmap->qhead] = dmap->fragment_size;\r\nDMAbuf_launch_output(dev, dmap);\r\nfinish_output_interrupt(dev, dmap);\r\nreturn;\r\n}\r\ndmap->qlen--;\r\nthis_fragment = dmap->qhead;\r\ndmap->qhead = (dmap->qhead + 1) % dmap->nbufs;\r\nif (dmap->qhead == 0) {\r\ndmap->byte_counter += dmap->bytes_in_use;\r\nif (dmap->byte_counter >= dmap->max_byte_counter) {\r\nlong decr = dmap->byte_counter;\r\ndmap->byte_counter = (dmap->byte_counter % dmap->bytes_in_use);\r\ndecr -= dmap->byte_counter;\r\ndmap->user_counter -= decr;\r\n}\r\n}\r\nif (!(adev->flags & DMA_AUTOMODE))\r\ndmap->flags &= ~DMA_ACTIVE;\r\nwhile (dmap->qlen <= -dmap->closing) {\r\ndmap->underrun_count++;\r\ndmap->qlen++;\r\nif ((dmap->flags & DMA_DIRTY) && dmap->applic_profile != APF_CPUINTENS) {\r\ndmap->flags &= ~DMA_DIRTY;\r\nmemset(adev->dmap_out->raw_buf, adev->dmap_out->neutral_byte,\r\nadev->dmap_out->buffsize);\r\n}\r\ndmap->user_counter += dmap->fragment_size;\r\ndmap->qtail = (dmap->qtail + 1) % dmap->nbufs;\r\n}\r\nif (dmap->qlen > 0)\r\nDMAbuf_launch_output(dev, dmap);\r\nfinish_output_interrupt(dev, dmap);\r\n}\r\nvoid DMAbuf_outputintr(int dev, int notify_only)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nunsigned long flags;\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (!(dmap->flags & DMA_NODMA)) {\r\nint chan = dmap->dma, pos, n;\r\nunsigned long f;\r\nf=claim_dma_lock();\r\nif(!isa_dma_bridge_buggy)\r\ndisable_dma(dmap->dma);\r\nclear_dma_ff(chan);\r\npos = dmap->bytes_in_use - get_dma_residue(chan);\r\nif(!isa_dma_bridge_buggy)\r\nenable_dma(dmap->dma);\r\nrelease_dma_lock(f);\r\npos = pos / dmap->fragment_size;\r\nif (pos < 0 || pos >= dmap->nbufs)\r\npos = 0;\r\nn = 0;\r\nwhile (dmap->qhead != pos && n++ < dmap->nbufs)\r\ndo_outputintr(dev, notify_only);\r\n}\r\nelse\r\ndo_outputintr(dev, notify_only);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\n}\r\nstatic void do_inputintr(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_in;\r\nif (dmap->raw_buf == NULL) {\r\nprintk(KERN_ERR "Sound: Fatal error. Audio interrupt after freeing buffers.\n");\r\nreturn;\r\n}\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED) {\r\ndmap->qtail = (dmap->qtail + 1) % dmap->nbufs;\r\nif (dmap->qtail == 0) {\r\ndmap->byte_counter += dmap->bytes_in_use;\r\nif (dmap->byte_counter >= dmap->max_byte_counter) {\r\nlong decr = dmap->byte_counter;\r\ndmap->byte_counter = (dmap->byte_counter % dmap->bytes_in_use) + dmap->bytes_in_use;\r\ndecr -= dmap->byte_counter;\r\ndmap->user_counter -= decr;\r\n}\r\n}\r\ndmap->qlen++;\r\nif (!(adev->flags & DMA_AUTOMODE)) {\r\nif (dmap->needs_reorg)\r\nreorganize_buffers(dev, dmap, 0);\r\nlocal_start_dma(adev, dmap->raw_buf_phys, dmap->bytes_in_use,DMA_MODE_READ);\r\nadev->d->start_input(dev, dmap->raw_buf_phys + dmap->qtail * dmap->fragment_size,\r\ndmap->fragment_size, 1);\r\nif (adev->d->trigger)\r\nadev->d->trigger(dev, adev->enable_bits * adev->go);\r\n}\r\ndmap->flags |= DMA_ACTIVE;\r\n} else if (dmap->qlen >= (dmap->nbufs - 1)) {\r\nprintk(KERN_WARNING "Sound: Recording overrun\n");\r\ndmap->underrun_count++;\r\ndmap->qhead = (dmap->qhead + 1) % dmap->nbufs;\r\ndmap->qtail = (dmap->qtail + 1) % dmap->nbufs;\r\n} else if (dmap->qlen >= 0 && dmap->qlen < dmap->nbufs) {\r\ndmap->qlen++;\r\ndmap->qtail = (dmap->qtail + 1) % dmap->nbufs;\r\nif (dmap->qtail == 0) {\r\ndmap->byte_counter += dmap->bytes_in_use;\r\nif (dmap->byte_counter >= dmap->max_byte_counter) {\r\nlong decr = dmap->byte_counter;\r\ndmap->byte_counter = (dmap->byte_counter % dmap->bytes_in_use) + dmap->bytes_in_use;\r\ndecr -= dmap->byte_counter;\r\ndmap->user_counter -= decr;\r\n}\r\n}\r\n}\r\nif (!(adev->flags & DMA_AUTOMODE) || (dmap->flags & DMA_NODMA)) {\r\nlocal_start_dma(adev, dmap->raw_buf_phys, dmap->bytes_in_use, DMA_MODE_READ);\r\nadev->d->start_input(dev, dmap->raw_buf_phys + dmap->qtail * dmap->fragment_size, dmap->fragment_size, 1);\r\nif (adev->d->trigger)\r\nadev->d->trigger(dev,adev->enable_bits * adev->go);\r\n}\r\ndmap->flags |= DMA_ACTIVE;\r\nif (dmap->qlen > 0)\r\n{\r\nwake_up(&adev->in_sleeper);\r\nwake_up(&adev->poll_sleeper);\r\n}\r\n}\r\nvoid DMAbuf_inputintr(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_in;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nif (!(dmap->flags & DMA_NODMA)) {\r\nint chan = dmap->dma, pos, n;\r\nunsigned long f;\r\nf=claim_dma_lock();\r\nif(!isa_dma_bridge_buggy)\r\ndisable_dma(dmap->dma);\r\nclear_dma_ff(chan);\r\npos = dmap->bytes_in_use - get_dma_residue(chan);\r\nif(!isa_dma_bridge_buggy)\r\nenable_dma(dmap->dma);\r\nrelease_dma_lock(f);\r\npos = pos / dmap->fragment_size;\r\nif (pos < 0 || pos >= dmap->nbufs)\r\npos = 0;\r\nn = 0;\r\nwhile (dmap->qtail != pos && ++n < dmap->nbufs)\r\ndo_inputintr(dev);\r\n} else\r\ndo_inputintr(dev);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\n}\r\nvoid DMAbuf_init(int dev, int dma1, int dma2)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nif (adev && adev->dmap_out == NULL) {\r\nif (adev->d == NULL)\r\npanic("OSS: audio_devs[%d]->d == NULL\n", dev);\r\nif (adev->parent_dev) {\r\nint parent = adev->parent_dev - 1;\r\nadev->dmap_out = audio_devs[parent]->dmap_out;\r\nadev->dmap_in = audio_devs[parent]->dmap_in;\r\n} else {\r\nadev->dmap_out = adev->dmap_in = &adev->dmaps[0];\r\nadev->dmap_out->dma = dma1;\r\nif (adev->flags & DMA_DUPLEX) {\r\nadev->dmap_in = &adev->dmaps[1];\r\nadev->dmap_in->dma = dma2;\r\n}\r\n}\r\nif (sound_dmap_flag == DMAP_KEEP_ON_CLOSE) {\r\nif (adev->dmap_in->raw_buf == NULL)\r\nsound_alloc_dmap(adev->dmap_in);\r\nif (adev->dmap_out->raw_buf == NULL)\r\nsound_alloc_dmap(adev->dmap_out);\r\n}\r\n}\r\n}\r\nstatic unsigned int poll_input(struct file * file, int dev, poll_table *wait)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_in;\r\nif (!(adev->open_mode & OPEN_READ))\r\nreturn 0;\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED) {\r\nif (dmap->qlen)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nif (dmap->dma_mode != DMODE_INPUT) {\r\nif (dmap->dma_mode == DMODE_NONE &&\r\nadev->enable_bits & PCM_ENABLE_INPUT &&\r\n!dmap->qlen && adev->go) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dmap->lock,flags);\r\nDMAbuf_activate_recording(dev, dmap);\r\nspin_unlock_irqrestore(&dmap->lock,flags);\r\n}\r\nreturn 0;\r\n}\r\nif (!dmap->qlen)\r\nreturn 0;\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nstatic unsigned int poll_output(struct file * file, int dev, poll_table *wait)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nstruct dma_buffparms *dmap = adev->dmap_out;\r\nif (!(adev->open_mode & OPEN_WRITE))\r\nreturn 0;\r\nif (dmap->mapping_flags & DMA_MAP_MAPPED) {\r\nif (dmap->qlen)\r\nreturn POLLOUT | POLLWRNORM;\r\nreturn 0;\r\n}\r\nif (dmap->dma_mode == DMODE_INPUT)\r\nreturn 0;\r\nif (dmap->dma_mode == DMODE_NONE)\r\nreturn POLLOUT | POLLWRNORM;\r\nif (!DMAbuf_space_in_queue(dev))\r\nreturn 0;\r\nreturn POLLOUT | POLLWRNORM;\r\n}\r\nunsigned int DMAbuf_poll(struct file * file, int dev, poll_table *wait)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\npoll_wait(file, &adev->poll_sleeper, wait);\r\nreturn poll_input(file, dev, wait) | poll_output(file, dev, wait);\r\n}\r\nvoid DMAbuf_deinit(int dev)\r\n{\r\nstruct audio_operations *adev = audio_devs[dev];\r\nif (!adev)\r\nreturn;\r\nif (sound_dmap_flag == DMAP_KEEP_ON_CLOSE) {\r\nsound_free_dmap(adev->dmap_out);\r\nif (adev->flags & DMA_DUPLEX)\r\nsound_free_dmap(adev->dmap_in);\r\n}\r\n}
