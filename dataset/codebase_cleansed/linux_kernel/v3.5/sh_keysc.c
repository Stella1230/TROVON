static unsigned long sh_keysc_read(struct sh_keysc_priv *p, int reg_nr)\r\n{\r\nreturn ioread16(p->iomem_base + (reg_nr << 2));\r\n}\r\nstatic void sh_keysc_write(struct sh_keysc_priv *p, int reg_nr,\r\nunsigned long value)\r\n{\r\niowrite16(value, p->iomem_base + (reg_nr << 2));\r\n}\r\nstatic void sh_keysc_level_mode(struct sh_keysc_priv *p,\r\nunsigned long keys_set)\r\n{\r\nstruct sh_keysc_info *pdata = &p->pdata;\r\nsh_keysc_write(p, KYOUTDR, 0);\r\nsh_keysc_write(p, KYCR2, KYCR2_IRQ_LEVEL | (keys_set << 8));\r\nif (pdata->kycr2_delay)\r\nudelay(pdata->kycr2_delay);\r\n}\r\nstatic void sh_keysc_map_dbg(struct device *dev, unsigned long *map,\r\nconst char *str)\r\n{\r\nint k;\r\nfor (k = 0; k < BITS_TO_LONGS(SH_KEYSC_MAXKEYS); k++)\r\ndev_dbg(dev, "%s[%d] 0x%lx\n", str, k, map[k]);\r\n}\r\nstatic irqreturn_t sh_keysc_isr(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\nstruct sh_keysc_priv *priv = platform_get_drvdata(pdev);\r\nstruct sh_keysc_info *pdata = &priv->pdata;\r\nint keyout_nr = sh_keysc_mode[pdata->mode].keyout;\r\nint keyin_nr = sh_keysc_mode[pdata->mode].keyin;\r\nDECLARE_BITMAP(keys, SH_KEYSC_MAXKEYS);\r\nDECLARE_BITMAP(keys0, SH_KEYSC_MAXKEYS);\r\nDECLARE_BITMAP(keys1, SH_KEYSC_MAXKEYS);\r\nunsigned char keyin_set, tmp;\r\nint i, k, n;\r\ndev_dbg(&pdev->dev, "isr!\n");\r\nbitmap_fill(keys1, SH_KEYSC_MAXKEYS);\r\nbitmap_zero(keys0, SH_KEYSC_MAXKEYS);\r\ndo {\r\nbitmap_zero(keys, SH_KEYSC_MAXKEYS);\r\nkeyin_set = 0;\r\nsh_keysc_write(priv, KYCR2, KYCR2_IRQ_DISABLED);\r\nfor (i = 0; i < keyout_nr; i++) {\r\nn = keyin_nr * i;\r\nsh_keysc_write(priv, KYOUTDR, 0xffff ^ (3 << (i * 2)));\r\nudelay(pdata->delay);\r\ntmp = sh_keysc_read(priv, KYINDR);\r\nfor (k = 0; k < keyin_nr; k++) {\r\nif (tmp & (1 << k))\r\n__set_bit(n + k, keys);\r\n}\r\nkeyin_set |= tmp ^ ((1 << keyin_nr) - 1);\r\n}\r\nsh_keysc_level_mode(priv, keyin_set);\r\nbitmap_complement(keys, keys, SH_KEYSC_MAXKEYS);\r\nbitmap_and(keys1, keys1, keys, SH_KEYSC_MAXKEYS);\r\nbitmap_or(keys0, keys0, keys, SH_KEYSC_MAXKEYS);\r\nsh_keysc_map_dbg(&pdev->dev, keys, "keys");\r\n} while (sh_keysc_read(priv, KYCR2) & 0x01);\r\nsh_keysc_map_dbg(&pdev->dev, priv->last_keys, "last_keys");\r\nsh_keysc_map_dbg(&pdev->dev, keys0, "keys0");\r\nsh_keysc_map_dbg(&pdev->dev, keys1, "keys1");\r\nfor (i = 0; i < SH_KEYSC_MAXKEYS; i++) {\r\nk = pdata->keycodes[i];\r\nif (!k)\r\ncontinue;\r\nif (test_bit(i, keys0) == test_bit(i, priv->last_keys))\r\ncontinue;\r\nif (test_bit(i, keys1) || test_bit(i, keys0)) {\r\ninput_event(priv->input, EV_KEY, k, 1);\r\n__set_bit(i, priv->last_keys);\r\n}\r\nif (!test_bit(i, keys1)) {\r\ninput_event(priv->input, EV_KEY, k, 0);\r\n__clear_bit(i, priv->last_keys);\r\n}\r\n}\r\ninput_sync(priv->input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit sh_keysc_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_keysc_priv *priv;\r\nstruct sh_keysc_info *pdata;\r\nstruct resource *res;\r\nstruct input_dev *input;\r\nint i;\r\nint irq, error;\r\nif (!pdev->dev.platform_data) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nerror = -EINVAL;\r\ngoto err0;\r\n}\r\nerror = -ENXIO;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\ngoto err0;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq\n");\r\ngoto err0;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate driver data\n");\r\nerror = -ENOMEM;\r\ngoto err0;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nmemcpy(&priv->pdata, pdev->dev.platform_data, sizeof(priv->pdata));\r\npdata = &priv->pdata;\r\npriv->iomem_base = ioremap_nocache(res->start, resource_size(res));\r\nif (priv->iomem_base == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -ENXIO;\r\ngoto err1;\r\n}\r\npriv->input = input_allocate_device();\r\nif (!priv->input) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto err2;\r\n}\r\ninput = priv->input;\r\ninput->evbit[0] = BIT_MASK(EV_KEY);\r\ninput->name = pdev->name;\r\ninput->phys = "sh-keysc-keys/input0";\r\ninput->dev.parent = &pdev->dev;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\ninput->keycode = pdata->keycodes;\r\ninput->keycodesize = sizeof(pdata->keycodes[0]);\r\ninput->keycodemax = ARRAY_SIZE(pdata->keycodes);\r\nerror = request_threaded_irq(irq, NULL, sh_keysc_isr, IRQF_ONESHOT,\r\ndev_name(&pdev->dev), pdev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\ngoto err3;\r\n}\r\nfor (i = 0; i < SH_KEYSC_MAXKEYS; i++)\r\n__set_bit(pdata->keycodes[i], input->keybit);\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto err4;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nsh_keysc_write(priv, KYCR1, (sh_keysc_mode[pdata->mode].kymd << 8) |\r\npdata->scan_timing);\r\nsh_keysc_level_mode(priv, 0);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nerr4:\r\nfree_irq(irq, pdev);\r\nerr3:\r\ninput_free_device(input);\r\nerr2:\r\niounmap(priv->iomem_base);\r\nerr1:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(priv);\r\nerr0:\r\nreturn error;\r\n}\r\nstatic int __devexit sh_keysc_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_keysc_priv *priv = platform_get_drvdata(pdev);\r\nsh_keysc_write(priv, KYCR2, KYCR2_IRQ_DISABLED);\r\ninput_unregister_device(priv->input);\r\nfree_irq(platform_get_irq(pdev, 0), pdev);\r\niounmap(priv->iomem_base);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int sh_keysc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_keysc_priv *priv = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nunsigned short value;\r\nvalue = sh_keysc_read(priv, KYCR1);\r\nif (device_may_wakeup(dev)) {\r\nsh_keysc_write(priv, KYCR1, value | 0x80);\r\nenable_irq_wake(irq);\r\n} else {\r\nsh_keysc_write(priv, KYCR1, value & ~0x80);\r\npm_runtime_put_sync(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_keysc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(irq);\r\nelse\r\npm_runtime_get_sync(dev);\r\nreturn 0;\r\n}
