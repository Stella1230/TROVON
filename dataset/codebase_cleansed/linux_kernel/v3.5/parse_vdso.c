static unsigned long elf_hash(const unsigned char *name)\r\n{\r\nunsigned long h = 0, g;\r\nwhile (*name)\r\n{\r\nh = (h << 4) + *name++;\r\nif (g = h & 0xf0000000)\r\nh ^= g >> 24;\r\nh &= ~g;\r\n}\r\nreturn h;\r\n}\r\nvoid vdso_init_from_sysinfo_ehdr(uintptr_t base)\r\n{\r\nsize_t i;\r\nbool found_vaddr = false;\r\nvdso_info.valid = false;\r\nvdso_info.load_addr = base;\r\nElf64_Ehdr *hdr = (Elf64_Ehdr*)base;\r\nElf64_Phdr *pt = (Elf64_Phdr*)(vdso_info.load_addr + hdr->e_phoff);\r\nElf64_Dyn *dyn = 0;\r\nfor (i = 0; i < hdr->e_phnum; i++)\r\n{\r\nif (pt[i].p_type == PT_LOAD && !found_vaddr) {\r\nfound_vaddr = true;\r\nvdso_info.load_offset = base\r\n+ (uintptr_t)pt[i].p_offset\r\n- (uintptr_t)pt[i].p_vaddr;\r\n} else if (pt[i].p_type == PT_DYNAMIC) {\r\ndyn = (Elf64_Dyn*)(base + pt[i].p_offset);\r\n}\r\n}\r\nif (!found_vaddr || !dyn)\r\nreturn;\r\nElf64_Word *hash = 0;\r\nvdso_info.symstrings = 0;\r\nvdso_info.symtab = 0;\r\nvdso_info.versym = 0;\r\nvdso_info.verdef = 0;\r\nfor (i = 0; dyn[i].d_tag != DT_NULL; i++) {\r\nswitch (dyn[i].d_tag) {\r\ncase DT_STRTAB:\r\nvdso_info.symstrings = (const char *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_SYMTAB:\r\nvdso_info.symtab = (Elf64_Sym *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_HASH:\r\nhash = (Elf64_Word *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_VERSYM:\r\nvdso_info.versym = (Elf64_Versym *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\ncase DT_VERDEF:\r\nvdso_info.verdef = (Elf64_Verdef *)\r\n((uintptr_t)dyn[i].d_un.d_ptr\r\n+ vdso_info.load_offset);\r\nbreak;\r\n}\r\n}\r\nif (!vdso_info.symstrings || !vdso_info.symtab || !hash)\r\nreturn;\r\nif (!vdso_info.verdef)\r\nvdso_info.versym = 0;\r\nvdso_info.nbucket = hash[0];\r\nvdso_info.nchain = hash[1];\r\nvdso_info.bucket = &hash[2];\r\nvdso_info.chain = &hash[vdso_info.nbucket + 2];\r\nvdso_info.valid = true;\r\n}\r\nstatic bool vdso_match_version(Elf64_Versym ver,\r\nconst char *name, Elf64_Word hash)\r\n{\r\nver &= 0x7fff;\r\nElf64_Verdef *def = vdso_info.verdef;\r\nwhile(true) {\r\nif ((def->vd_flags & VER_FLG_BASE) == 0\r\n&& (def->vd_ndx & 0x7fff) == ver)\r\nbreak;\r\nif (def->vd_next == 0)\r\nreturn false;\r\ndef = (Elf64_Verdef *)((char *)def + def->vd_next);\r\n}\r\nElf64_Verdaux *aux = (Elf64_Verdaux*)((char *)def + def->vd_aux);\r\nreturn def->vd_hash == hash\r\n&& !strcmp(name, vdso_info.symstrings + aux->vda_name);\r\n}\r\nvoid *vdso_sym(const char *version, const char *name)\r\n{\r\nunsigned long ver_hash;\r\nif (!vdso_info.valid)\r\nreturn 0;\r\nver_hash = elf_hash(version);\r\nElf64_Word chain = vdso_info.bucket[elf_hash(name) % vdso_info.nbucket];\r\nfor (; chain != STN_UNDEF; chain = vdso_info.chain[chain]) {\r\nElf64_Sym *sym = &vdso_info.symtab[chain];\r\nif (ELF64_ST_TYPE(sym->st_info) != STT_FUNC)\r\ncontinue;\r\nif (ELF64_ST_BIND(sym->st_info) != STB_GLOBAL &&\r\nELF64_ST_BIND(sym->st_info) != STB_WEAK)\r\ncontinue;\r\nif (sym->st_shndx == SHN_UNDEF)\r\ncontinue;\r\nif (strcmp(name, vdso_info.symstrings + sym->st_name))\r\ncontinue;\r\nif (vdso_info.versym\r\n&& !vdso_match_version(vdso_info.versym[chain],\r\nversion, ver_hash))\r\ncontinue;\r\nreturn (void *)(vdso_info.load_offset + sym->st_value);\r\n}\r\nreturn 0;\r\n}\r\nvoid vdso_init_from_auxv(void *auxv)\r\n{\r\nElf64_auxv_t *elf_auxv = auxv;\r\nfor (int i = 0; elf_auxv[i].a_type != AT_NULL; i++)\r\n{\r\nif (elf_auxv[i].a_type == AT_SYSINFO_EHDR) {\r\nvdso_init_from_sysinfo_ehdr(elf_auxv[i].a_un.a_val);\r\nreturn;\r\n}\r\n}\r\nvdso_info.valid = false;\r\n}
