static int __init ali_ircc_init(void)\r\n{\r\nali_chip_t *chip;\r\nchipio_t info;\r\nint ret;\r\nint cfg, cfg_base;\r\nint reg, revision;\r\nint i = 0;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\nret = platform_driver_register(&ali_ircc_driver);\r\nif (ret) {\r\nIRDA_ERROR("%s, Can't register driver!\n",\r\nALI_IRCC_DRIVER_NAME);\r\nreturn ret;\r\n}\r\nret = -ENODEV;\r\nfor (chip= chips; chip->name; chip++, i++)\r\n{\r\nIRDA_DEBUG(2, "%s(), Probing for %s ...\n", __func__, chip->name);\r\nfor (cfg=0; cfg<2; cfg++)\r\n{\r\ncfg_base = chip->cfg[cfg];\r\nif (!cfg_base)\r\ncontinue;\r\nmemset(&info, 0, sizeof(chipio_t));\r\ninfo.cfg_base = cfg_base;\r\ninfo.fir_base = io[i];\r\ninfo.dma = dma[i];\r\ninfo.irq = irq[i];\r\noutb(chip->entr1, cfg_base);\r\noutb(chip->entr2, cfg_base);\r\noutb(0x07, cfg_base);\r\noutb(0x05, cfg_base+1);\r\noutb(chip->cid_index, cfg_base);\r\nreg = inb(cfg_base+1);\r\nif (reg == chip->cid_value)\r\n{\r\nIRDA_DEBUG(2, "%s(), Chip found at 0x%03x\n", __func__, cfg_base);\r\noutb(0x1F, cfg_base);\r\nrevision = inb(cfg_base+1);\r\nIRDA_DEBUG(2, "%s(), Found %s chip, revision=%d\n", __func__,\r\nchip->name, revision);\r\nif (io[i] < 2000)\r\n{\r\nchip->init(chip, &info);\r\n}\r\nelse\r\n{\r\nchip->probe(chip, &info);\r\n}\r\nif (ali_ircc_open(i, &info) == 0)\r\nret = 0;\r\ni++;\r\n}\r\nelse\r\n{\r\nIRDA_DEBUG(2, "%s(), No %s chip at 0x%03x\n", __func__, chip->name, cfg_base);\r\n}\r\noutb(0xbb, cfg_base);\r\n}\r\n}\r\nIRDA_DEBUG(2, "%s(), ----------------- End -----------------\n", __func__);\r\nif (ret)\r\nplatform_driver_unregister(&ali_ircc_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit ali_ircc_cleanup(void)\r\n{\r\nint i;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\nfor (i=0; i < ARRAY_SIZE(dev_self); i++) {\r\nif (dev_self[i])\r\nali_ircc_close(dev_self[i]);\r\n}\r\nplatform_driver_unregister(&ali_ircc_driver);\r\nIRDA_DEBUG(2, "%s(), ----------------- End -----------------\n", __func__);\r\n}\r\nstatic int ali_ircc_open(int i, chipio_t *info)\r\n{\r\nstruct net_device *dev;\r\nstruct ali_ircc_cb *self;\r\nint dongle_id;\r\nint err;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\nif (i >= ARRAY_SIZE(dev_self)) {\r\nIRDA_ERROR("%s(), maximum number of supported chips reached!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nif ((ali_ircc_setup(info)) == -1)\r\nreturn -1;\r\ndev = alloc_irdadev(sizeof(*self));\r\nif (dev == NULL) {\r\nIRDA_ERROR("%s(), can't allocate memory for control block!\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nself = netdev_priv(dev);\r\nself->netdev = dev;\r\nspin_lock_init(&self->lock);\r\ndev_self[i] = self;\r\nself->index = i;\r\nself->io.cfg_base = info->cfg_base;\r\nself->io.fir_base = info->fir_base;\r\nself->io.sir_base = info->sir_base;\r\nself->io.irq = info->irq;\r\nself->io.fir_ext = CHIP_IO_EXTENT;\r\nself->io.dma = info->dma;\r\nself->io.fifo_size = 16;\r\nif (!request_region(self->io.fir_base, self->io.fir_ext,\r\nALI_IRCC_DRIVER_NAME)) {\r\nIRDA_WARNING("%s(), can't get iobase of 0x%03x\n", __func__,\r\nself->io.fir_base);\r\nerr = -ENODEV;\r\ngoto err_out1;\r\n}\r\nirda_init_max_qos_capabilies(&self->qos);\r\nself->qos.baud_rate.bits = IR_9600|IR_19200|IR_38400|IR_57600|\r\nIR_115200|IR_576000|IR_1152000|(IR_4000000 << 8);\r\nself->qos.min_turn_time.bits = qos_mtt_bits;\r\nirda_qos_bits_to_value(&self->qos);\r\nself->rx_buff.truesize = 14384;\r\nself->tx_buff.truesize = 14384;\r\nself->rx_buff.head =\r\ndma_alloc_coherent(NULL, self->rx_buff.truesize,\r\n&self->rx_buff_dma, GFP_KERNEL);\r\nif (self->rx_buff.head == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out2;\r\n}\r\nmemset(self->rx_buff.head, 0, self->rx_buff.truesize);\r\nself->tx_buff.head =\r\ndma_alloc_coherent(NULL, self->tx_buff.truesize,\r\n&self->tx_buff_dma, GFP_KERNEL);\r\nif (self->tx_buff.head == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out3;\r\n}\r\nmemset(self->tx_buff.head, 0, self->tx_buff.truesize);\r\nself->rx_buff.in_frame = FALSE;\r\nself->rx_buff.state = OUTSIDE_FRAME;\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->rx_buff.data = self->rx_buff.head;\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\ndev->netdev_ops = &ali_ircc_sir_ops;\r\nerr = register_netdev(dev);\r\nif (err) {\r\nIRDA_ERROR("%s(), register_netdev() failed!\n", __func__);\r\ngoto err_out4;\r\n}\r\nIRDA_MESSAGE("IrDA: Registered device %s\n", dev->name);\r\ndongle_id = ali_ircc_read_dongle_id(i, info);\r\nIRDA_MESSAGE("%s(), %s, Found dongle: %s\n", __func__,\r\nALI_IRCC_DRIVER_NAME, dongle_types[dongle_id]);\r\nself->io.dongle_id = dongle_id;\r\nIRDA_DEBUG(2, "%s(), ----------------- End -----------------\n", __func__);\r\nreturn 0;\r\nerr_out4:\r\ndma_free_coherent(NULL, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nerr_out3:\r\ndma_free_coherent(NULL, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\nerr_out2:\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\nerr_out1:\r\ndev_self[i] = NULL;\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int __exit ali_ircc_close(struct ali_ircc_cb *self)\r\n{\r\nint iobase;\r\nIRDA_DEBUG(4, "%s(), ---------------- Start ----------------\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\niobase = self->io.fir_base;\r\nunregister_netdev(self->netdev);\r\nIRDA_DEBUG(4, "%s(), Releasing Region %03x\n", __func__, self->io.fir_base);\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\nif (self->tx_buff.head)\r\ndma_free_coherent(NULL, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nif (self->rx_buff.head)\r\ndma_free_coherent(NULL, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\ndev_self[self->index] = NULL;\r\nfree_netdev(self->netdev);\r\nIRDA_DEBUG(2, "%s(), ----------------- End -----------------\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_init_43(ali_chip_t *chip, chipio_t *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_init_53(ali_chip_t *chip, chipio_t *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_probe_53(ali_chip_t *chip, chipio_t *info)\r\n{\r\nint cfg_base = info->cfg_base;\r\nint hi, low, reg;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\noutb(chip->entr1, cfg_base);\r\noutb(chip->entr2, cfg_base);\r\noutb(0x07, cfg_base);\r\noutb(0x05, cfg_base+1);\r\noutb(0x60, cfg_base);\r\nhi = inb(cfg_base+1);\r\noutb(0x61, cfg_base);\r\nlow = inb(cfg_base+1);\r\ninfo->fir_base = (hi<<8) + low;\r\ninfo->sir_base = info->fir_base;\r\nIRDA_DEBUG(2, "%s(), probing fir_base=0x%03x\n", __func__, info->fir_base);\r\noutb(0x70, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->irq = reg & 0x0f;\r\nIRDA_DEBUG(2, "%s(), probing irq=%d\n", __func__, info->irq);\r\noutb(0x74, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->dma = reg & 0x07;\r\nif(info->dma == 0x04)\r\nIRDA_WARNING("%s(), No DMA channel assigned !\n", __func__);\r\nelse\r\nIRDA_DEBUG(2, "%s(), probing dma=%d\n", __func__, info->dma);\r\noutb(0x30, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->enabled = (reg & 0x80) && (reg & 0x01);\r\nIRDA_DEBUG(2, "%s(), probing enabled=%d\n", __func__, info->enabled);\r\noutb(0x22, cfg_base);\r\nreg = inb(cfg_base+1);\r\ninfo->suspended = (reg & 0x20);\r\nIRDA_DEBUG(2, "%s(), probing suspended=%d\n", __func__, info->suspended);\r\noutb(0xbb, cfg_base);\r\nIRDA_DEBUG(2, "%s(), ----------------- End -----------------\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_setup(chipio_t *info)\r\n{\r\nunsigned char tmp;\r\nint version;\r\nint iobase = info->fir_base;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\nSIR2FIR(iobase);\r\noutb(0x40, iobase+FIR_MCR);\r\nswitch_bank(iobase, BANK3);\r\nversion = inb(iobase+FIR_ID_VR);\r\nif(version != 0x00)\r\n{\r\nIRDA_ERROR("%s, Wrong chip version %02x\n",\r\nALI_IRCC_DRIVER_NAME, version);\r\nreturn -1;\r\n}\r\nswitch_bank(iobase, BANK1);\r\noutb(RX_FIFO_Threshold, iobase+FIR_FIFO_TR);\r\noutb(RX_DMA_Threshold, iobase+FIR_DMA_TR);\r\nswitch_bank(iobase, BANK2);\r\noutb(inb(iobase+FIR_IRDA_CR) | IRDA_CR_CRC, iobase+FIR_IRDA_CR);\r\nswitch_bank(iobase, BANK0);\r\ntmp = inb(iobase+FIR_LCR_B);\r\ntmp &=~0x20;\r\ntmp |= 0x80;\r\ntmp &= 0xbf;\r\noutb(tmp, iobase+FIR_LCR_B);\r\noutb(0x00, iobase+FIR_IER);\r\nFIR2SIR(iobase);\r\nIRDA_MESSAGE("%s, driver loaded (Benjamin Kong)\n",\r\nALI_IRCC_DRIVER_NAME);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_read_dongle_id (int i, chipio_t *info)\r\n{\r\nint dongle_id, reg;\r\nint cfg_base = info->cfg_base;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\noutb(chips[i].entr1, cfg_base);\r\noutb(chips[i].entr2, cfg_base);\r\noutb(0x07, cfg_base);\r\noutb(0x05, cfg_base+1);\r\noutb(0xf0, cfg_base);\r\nreg = inb(cfg_base+1);\r\ndongle_id = ((reg>>6)&0x02) | ((reg>>5)&0x01);\r\nIRDA_DEBUG(2, "%s(), probing dongle_id=%d, dongle_types=%s\n", __func__,\r\ndongle_id, dongle_types[dongle_id]);\r\noutb(0xbb, cfg_base);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__);\r\nreturn dongle_id;\r\n}\r\nstatic irqreturn_t ali_ircc_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct ali_ircc_cb *self;\r\nint ret;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\nself = netdev_priv(dev);\r\nspin_lock(&self->lock);\r\nif (self->io.speed > 115200)\r\nret = ali_ircc_fir_interrupt(self);\r\nelse\r\nret = ali_ircc_sir_interrupt(self);\r\nspin_unlock(&self->lock);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ali_ircc_fir_interrupt(struct ali_ircc_cb *self)\r\n{\r\n__u8 eir, OldMessageCount;\r\nint iobase, tmp;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__);\r\niobase = self->io.fir_base;\r\nswitch_bank(iobase, BANK0);\r\nself->InterruptID = inb(iobase+FIR_IIR);\r\nself->BusStatus = inb(iobase+FIR_BSR);\r\nOldMessageCount = (self->LineStatus + 1) & 0x07;\r\nself->LineStatus = inb(iobase+FIR_LSR);\r\neir = self->InterruptID & self->ier;\r\nIRDA_DEBUG(1, "%s(), self->InterruptID = %x\n", __func__,self->InterruptID);\r\nIRDA_DEBUG(1, "%s(), self->LineStatus = %x\n", __func__,self->LineStatus);\r\nIRDA_DEBUG(1, "%s(), self->ier = %x\n", __func__,self->ier);\r\nIRDA_DEBUG(1, "%s(), eir = %x\n", __func__,eir);\r\nSetCOMInterrupts(self, FALSE);\r\nif (eir & IIR_EOM)\r\n{\r\nif (self->io.direction == IO_XMIT)\r\n{\r\nIRDA_DEBUG(1, "%s(), ******* IIR_EOM (Tx) *******\n", __func__);\r\nif(ali_ircc_dma_xmit_complete(self))\r\n{\r\nif (irda_device_txqueue_empty(self->netdev))\r\n{\r\nali_ircc_dma_receive(self);\r\nself->ier = IER_EOM;\r\n}\r\n}\r\nelse\r\n{\r\nself->ier = IER_EOM;\r\n}\r\n}\r\nelse\r\n{\r\nIRDA_DEBUG(1, "%s(), ******* IIR_EOM (Rx) *******\n", __func__);\r\nif(OldMessageCount > ((self->LineStatus+1) & 0x07))\r\n{\r\nself->rcvFramesOverflow = TRUE;\r\nIRDA_DEBUG(1, "%s(), ******* self->rcvFramesOverflow = TRUE ********\n", __func__);\r\n}\r\nif (ali_ircc_dma_receive_complete(self))\r\n{\r\nIRDA_DEBUG(1, "%s(), ******* receive complete ********\n", __func__);\r\nself->ier = IER_EOM;\r\n}\r\nelse\r\n{\r\nIRDA_DEBUG(1, "%s(), ******* Not receive complete ********\n", __func__);\r\nself->ier = IER_EOM | IER_TIMER;\r\n}\r\n}\r\n}\r\nelse if (eir & IIR_TIMER)\r\n{\r\nif(OldMessageCount > ((self->LineStatus+1) & 0x07))\r\n{\r\nself->rcvFramesOverflow = TRUE;\r\nIRDA_DEBUG(1, "%s(), ******* self->rcvFramesOverflow = TRUE *******\n", __func__);\r\n}\r\nswitch_bank(iobase, BANK1);\r\ntmp = inb(iobase+FIR_CR);\r\noutb( tmp& ~CR_TIMER_EN, iobase+FIR_CR);\r\nif (self->io.direction == IO_XMIT)\r\n{\r\nali_ircc_dma_xmit(self);\r\nself->ier = IER_EOM;\r\n}\r\nelse\r\n{\r\nif(ali_ircc_dma_receive_complete(self))\r\n{\r\nself->ier = IER_EOM;\r\n}\r\nelse\r\n{\r\nself->ier = IER_EOM | IER_TIMER;\r\n}\r\n}\r\n}\r\nSetCOMInterrupts(self, TRUE);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ---------------\n", __func__);\r\nreturn IRQ_RETVAL(eir);\r\n}\r\nstatic irqreturn_t ali_ircc_sir_interrupt(struct ali_ircc_cb *self)\r\n{\r\nint iobase;\r\nint iir, lsr;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\niobase = self->io.sir_base;\r\niir = inb(iobase+UART_IIR) & UART_IIR_ID;\r\nif (iir) {\r\nlsr = inb(iobase+UART_LSR);\r\nIRDA_DEBUG(4, "%s(), iir=%02x, lsr=%02x, iobase=%#x\n", __func__,\r\niir, lsr, iobase);\r\nswitch (iir)\r\n{\r\ncase UART_IIR_RLSI:\r\nIRDA_DEBUG(2, "%s(), RLSI\n", __func__);\r\nbreak;\r\ncase UART_IIR_RDI:\r\nali_ircc_sir_receive(self);\r\nbreak;\r\ncase UART_IIR_THRI:\r\nif (lsr & UART_LSR_THRE)\r\n{\r\nali_ircc_sir_write_wakeup(self);\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), unhandled IIR=%#x\n", __func__, iir);\r\nbreak;\r\n}\r\n}\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__);\r\nreturn IRQ_RETVAL(iir);\r\n}\r\nstatic void ali_ircc_sir_receive(struct ali_ircc_cb *self)\r\n{\r\nint boguscount = 0;\r\nint iobase;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\niobase = self->io.sir_base;\r\ndo {\r\nasync_unwrap_char(self->netdev, &self->netdev->stats, &self->rx_buff,\r\ninb(iobase+UART_RX));\r\nif (boguscount++ > 32) {\r\nIRDA_DEBUG(2,"%s(), breaking!\n", __func__);\r\nbreak;\r\n}\r\n} while (inb(iobase+UART_LSR) & UART_LSR_DR);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void ali_ircc_sir_write_wakeup(struct ali_ircc_cb *self)\r\n{\r\nint actual = 0;\r\nint iobase;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__ );\r\niobase = self->io.sir_base;\r\nif (self->tx_buff.len > 0)\r\n{\r\nactual = ali_ircc_sir_write(iobase, self->io.fifo_size,\r\nself->tx_buff.data, self->tx_buff.len);\r\nself->tx_buff.data += actual;\r\nself->tx_buff.len -= actual;\r\n}\r\nelse\r\n{\r\nif (self->new_speed)\r\n{\r\nwhile(!(inb(iobase+UART_LSR) & UART_LSR_TEMT))\r\nIRDA_DEBUG(1, "%s(), UART_LSR_THRE\n", __func__ );\r\nIRDA_DEBUG(1, "%s(), Changing speed! self->new_speed = %d\n", __func__ , self->new_speed);\r\nali_ircc_change_speed(self, self->new_speed);\r\nself->new_speed = 0;\r\nif (self->io.speed > 115200)\r\n{\r\nIRDA_DEBUG(2, "%s(), ali_ircc_change_speed from UART_LSR_TEMT\n", __func__ );\r\nself->ier = IER_EOM;\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nnetif_wake_queue(self->netdev);\r\n}\r\nself->netdev->stats.tx_packets++;\r\noutb(UART_IER_RDI, iobase+UART_IER);\r\n}\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void ali_ircc_change_speed(struct ali_ircc_cb *self, __u32 baud)\r\n{\r\nstruct net_device *dev = self->netdev;\r\nint iobase;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_DEBUG(2, "%s(), setting speed = %d\n", __func__ , baud);\r\niobase = self->io.fir_base;\r\nSetCOMInterrupts(self, FALSE);\r\nif (baud > 115200)\r\n{\r\nali_ircc_fir_change_speed(self, baud);\r\ndev->netdev_ops = &ali_ircc_fir_ops;\r\nself->ier = IER_EOM;\r\nali_ircc_dma_receive(self);\r\n}\r\nelse\r\n{\r\nali_ircc_sir_change_speed(self, baud);\r\ndev->netdev_ops = &ali_ircc_sir_ops;\r\n}\r\nSetCOMInterrupts(self, TRUE);\r\nnetif_wake_queue(self->netdev);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void ali_ircc_fir_change_speed(struct ali_ircc_cb *priv, __u32 baud)\r\n{\r\nint iobase;\r\nstruct ali_ircc_cb *self = (struct ali_ircc_cb *) priv;\r\nstruct net_device *dev;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\ndev = self->netdev;\r\niobase = self->io.fir_base;\r\nIRDA_DEBUG(1, "%s(), self->io.speed = %d, change to speed = %d\n", __func__ ,self->io.speed,baud);\r\nif(self->io.speed <=115200)\r\n{\r\nSIR2FIR(iobase);\r\n}\r\nself->io.speed = baud;\r\nali_ircc_change_dongle_speed(self, baud);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void ali_ircc_sir_change_speed(struct ali_ircc_cb *priv, __u32 speed)\r\n{\r\nstruct ali_ircc_cb *self = (struct ali_ircc_cb *) priv;\r\nunsigned long flags;\r\nint iobase;\r\nint fcr;\r\nint lcr;\r\nint divisor;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_DEBUG(1, "%s(), Setting speed to: %d\n", __func__ , speed);\r\nIRDA_ASSERT(self != NULL, return;);\r\niobase = self->io.sir_base;\r\nif(self->io.speed >115200)\r\n{\r\nali_ircc_change_dongle_speed(self, speed);\r\nFIR2SIR(iobase);\r\n}\r\ninb(iobase+UART_LSR);\r\ninb(iobase+UART_SCR);\r\nself->io.speed = speed;\r\nspin_lock_irqsave(&self->lock, flags);\r\ndivisor = 115200/speed;\r\nfcr = UART_FCR_ENABLE_FIFO;\r\nif (self->io.speed < 38400)\r\nfcr |= UART_FCR_TRIGGER_1;\r\nelse\r\nfcr |= UART_FCR_TRIGGER_14;\r\nlcr = UART_LCR_WLEN8;\r\noutb(UART_LCR_DLAB | lcr, iobase+UART_LCR);\r\noutb(divisor & 0xff, iobase+UART_DLL);\r\noutb(divisor >> 8, iobase+UART_DLM);\r\noutb(lcr, iobase+UART_LCR);\r\noutb(fcr, iobase+UART_FCR);\r\noutb((UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2), iobase+UART_MCR);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void ali_ircc_change_dongle_speed(struct ali_ircc_cb *priv, int speed)\r\n{\r\nstruct ali_ircc_cb *self = (struct ali_ircc_cb *) priv;\r\nint iobase,dongle_id;\r\nint tmp = 0;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__ );\r\niobase = self->io.fir_base;\r\ndongle_id = self->io.dongle_id;\r\nIRDA_DEBUG(1, "%s(), Set Speed for %s , Speed = %d\n", __func__ , dongle_types[dongle_id], speed);\r\nswitch_bank(iobase, BANK2);\r\ntmp = inb(iobase+FIR_IRDA_CR);\r\nif(dongle_id == 0)\r\n{\r\nif(speed == 4000000)\r\n{\r\ntmp &= ~IRDA_CR_HDLC;\r\ntmp |= IRDA_CR_CRC;\r\nswitch_bank(iobase, BANK2);\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\ntmp &= ~0x09;\r\ntmp |= 0x02;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\ntmp &= ~0x01;\r\ntmp |= 0x0a;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\ntmp |= 0x0b;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\ntmp &= ~0x08;\r\ntmp |= 0x03;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\ntmp &= ~0x09;\r\ntmp |= 0x02;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\noutb(tmp & ~0x02, iobase+FIR_IRDA_CR);\r\n}\r\nelse\r\n{\r\nif (speed==1152000)\r\n{\r\ntmp |= 0xA0;\r\n}\r\nelse\r\n{\r\ntmp &=~0x80;\r\ntmp |= 0x20;\r\n}\r\ntmp |= IRDA_CR_CRC;\r\nswitch_bank(iobase, BANK2);\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\ntmp &= ~0x09;\r\ntmp |= 0x02;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\ntmp &= ~0x01;\r\ntmp |= 0x0a;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\ntmp &= ~0x09;\r\ntmp |= 0x02;\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\nudelay(2);\r\noutb(tmp & ~0x02, iobase+FIR_IRDA_CR);\r\n}\r\n}\r\nelse if (dongle_id == 1)\r\n{\r\nswitch(speed)\r\n{\r\ncase 4000000:\r\ntmp &= ~IRDA_CR_HDLC;\r\nbreak;\r\ncase 1152000:\r\ntmp |= 0xA0;\r\nbreak;\r\ncase 576000:\r\ntmp &=~0x80;\r\ntmp |= 0x20;\r\nbreak;\r\n}\r\ntmp |= IRDA_CR_CRC;\r\nswitch_bank(iobase, BANK2);\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\n}\r\nelse\r\n{\r\nif(speed <= 115200)\r\n{\r\ntmp &= ~IRDA_CR_FIR_SIN;\r\nswitch_bank(iobase, BANK2);\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\n}\r\nelse\r\n{\r\nswitch(speed)\r\n{\r\ncase 4000000:\r\ntmp &= ~IRDA_CR_HDLC;\r\nbreak;\r\ncase 1152000:\r\ntmp |= 0xA0;\r\nbreak;\r\ncase 576000:\r\ntmp &=~0x80;\r\ntmp |= 0x20;\r\nbreak;\r\n}\r\ntmp |= IRDA_CR_CRC;\r\ntmp |= IRDA_CR_FIR_SIN;\r\nswitch_bank(iobase, BANK2);\r\noutb(tmp, iobase+FIR_IRDA_CR);\r\n}\r\n}\r\nswitch_bank(iobase, BANK0);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic int ali_ircc_sir_write(int iobase, int fifo_size, __u8 *buf, int len)\r\n{\r\nint actual = 0;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__ );\r\nif (!(inb(iobase+UART_LSR) & UART_LSR_THRE)) {\r\nIRDA_DEBUG(0, "%s(), failed, fifo not empty!\n", __func__ );\r\nreturn 0;\r\n}\r\nwhile ((fifo_size-- > 0) && (actual < len)) {\r\noutb(buf[actual], iobase+UART_TX);\r\nactual++;\r\n}\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn actual;\r\n}\r\nstatic int ali_ircc_net_open(struct net_device *dev)\r\n{\r\nstruct ali_ircc_cb *self;\r\nint iobase;\r\nchar hwname[32];\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\niobase = self->io.fir_base;\r\nif (request_irq(self->io.irq, ali_ircc_interrupt, 0, dev->name, dev))\r\n{\r\nIRDA_WARNING("%s, unable to allocate irq=%d\n",\r\nALI_IRCC_DRIVER_NAME,\r\nself->io.irq);\r\nreturn -EAGAIN;\r\n}\r\nif (request_dma(self->io.dma, dev->name)) {\r\nIRDA_WARNING("%s, unable to allocate dma=%d\n",\r\nALI_IRCC_DRIVER_NAME,\r\nself->io.dma);\r\nfree_irq(self->io.irq, dev);\r\nreturn -EAGAIN;\r\n}\r\noutb(UART_IER_RDI , iobase+UART_IER);\r\nnetif_start_queue(dev);\r\nsprintf(hwname, "ALI-FIR @ 0x%03x", self->io.fir_base);\r\nself->irlap = irlap_open(dev, &self->qos, hwname);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_net_close(struct net_device *dev)\r\n{\r\nstruct ali_ircc_cb *self;\r\nIRDA_DEBUG(4, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\nnetif_stop_queue(dev);\r\nif (self->irlap)\r\nirlap_close(self->irlap);\r\nself->irlap = NULL;\r\ndisable_dma(self->io.dma);\r\nSetCOMInterrupts(self, FALSE);\r\nfree_irq(self->io.irq, dev);\r\nfree_dma(self->io.dma);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ali_ircc_fir_hard_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ali_ircc_cb *self;\r\nunsigned long flags;\r\nint iobase;\r\n__u32 speed;\r\nint mtt, diff;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start -----------------\n", __func__ );\r\nself = netdev_priv(dev);\r\niobase = self->io.fir_base;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1)) {\r\nif (!skb->len) {\r\nali_ircc_change_speed(self, speed);\r\ndev->trans_start = jiffies;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else\r\nself->new_speed = speed;\r\n}\r\nself->tx_fifo.queue[self->tx_fifo.free].start = self->tx_fifo.tail;\r\nself->tx_fifo.queue[self->tx_fifo.free].len = skb->len;\r\nself->tx_fifo.tail += skb->len;\r\ndev->stats.tx_bytes += skb->len;\r\nskb_copy_from_linear_data(skb, self->tx_fifo.queue[self->tx_fifo.free].start,\r\nskb->len);\r\nself->tx_fifo.len++;\r\nself->tx_fifo.free++;\r\nif (self->tx_fifo.len == 1)\r\n{\r\nmtt = irda_get_mtt(skb);\r\nif (mtt)\r\n{\r\ndo_gettimeofday(&self->now);\r\ndiff = self->now.tv_usec - self->stamp.tv_usec;\r\nIRDA_DEBUG(1, "%s(), ******* diff = %d *******\n", __func__ , diff);\r\nif (diff < 0)\r\ndiff += 1000000;\r\nif (mtt > diff)\r\n{\r\nmtt -= diff;\r\nif (mtt > 500)\r\n{\r\nmtt = (mtt+250) / 500;\r\nIRDA_DEBUG(1, "%s(), ************** mtt = %d ***********\n", __func__ , mtt);\r\nif (mtt == 1)\r\n{\r\nswitch_bank(iobase, BANK1);\r\noutb(TIMER_IIR_500, iobase+FIR_TIMER_IIR);\r\n}\r\nelse if (mtt == 2)\r\n{\r\nswitch_bank(iobase, BANK1);\r\noutb(TIMER_IIR_1ms, iobase+FIR_TIMER_IIR);\r\n}\r\nelse\r\n{\r\nswitch_bank(iobase, BANK1);\r\noutb(TIMER_IIR_2ms, iobase+FIR_TIMER_IIR);\r\n}\r\noutb(inb(iobase+FIR_CR) | CR_TIMER_EN, iobase+FIR_CR);\r\nself->io.direction = IO_XMIT;\r\nself->ier = IER_TIMER;\r\nSetCOMInterrupts(self, TRUE);\r\ngoto out;\r\n}\r\nelse\r\nudelay(mtt);\r\n}\r\n}\r\nself->ier = IER_EOM;\r\nSetCOMInterrupts(self, TRUE);\r\nali_ircc_dma_xmit(self);\r\n}\r\nout:\r\nif (self->tx_fifo.free < MAX_TX_WINDOW)\r\nnetif_wake_queue(self->netdev);\r\nswitch_bank(iobase, BANK0);\r\ndev->trans_start = jiffies;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ali_ircc_dma_xmit(struct ali_ircc_cb *self)\r\n{\r\nint iobase, tmp;\r\nunsigned char FIFO_OPTI, Hi, Lo;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start -----------------\n", __func__ );\r\niobase = self->io.fir_base;\r\nif(self->tx_fifo.queue[self->tx_fifo.ptr].len < TX_FIFO_Threshold)\r\nFIFO_OPTI = self->tx_fifo.queue[self->tx_fifo.ptr].len-1;\r\nelse\r\nFIFO_OPTI = TX_FIFO_Threshold;\r\nswitch_bank(iobase, BANK1);\r\noutb(inb(iobase+FIR_CR) & ~CR_DMA_EN, iobase+FIR_CR);\r\nself->io.direction = IO_XMIT;\r\nirda_setup_dma(self->io.dma,\r\n((u8 *)self->tx_fifo.queue[self->tx_fifo.ptr].start -\r\nself->tx_buff.head) + self->tx_buff_dma,\r\nself->tx_fifo.queue[self->tx_fifo.ptr].len,\r\nDMA_TX_MODE);\r\nswitch_bank(iobase, BANK0);\r\noutb(LCR_A_FIFO_RESET, iobase+FIR_LCR_A);\r\nif (self->fifo_opti_buf!=FIFO_OPTI)\r\n{\r\nswitch_bank(iobase, BANK1);\r\noutb(FIFO_OPTI, iobase+FIR_FIFO_TR) ;\r\nself->fifo_opti_buf=FIFO_OPTI;\r\n}\r\nswitch_bank(iobase, BANK1);\r\noutb(TX_DMA_Threshold, iobase+FIR_DMA_TR);\r\nHi = (self->tx_fifo.queue[self->tx_fifo.ptr].len >> 8) & 0x0f;\r\nLo = self->tx_fifo.queue[self->tx_fifo.ptr].len & 0xff;\r\nswitch_bank(iobase, BANK2);\r\noutb(Hi, iobase+FIR_TX_DSR_HI);\r\noutb(Lo, iobase+FIR_TX_DSR_LO);\r\nswitch_bank(iobase, BANK0);\r\ntmp = inb(iobase+FIR_LCR_B);\r\ntmp &= ~0x20;\r\noutb(((unsigned char)(tmp & 0x3f) | LCR_B_TX_MODE) & ~LCR_B_BW, iobase+FIR_LCR_B);\r\nIRDA_DEBUG(1, "%s(), *** Change to TX mode: FIR_LCR_B = 0x%x ***\n", __func__ , inb(iobase+FIR_LCR_B));\r\noutb(0, iobase+FIR_LSR);\r\nswitch_bank(iobase, BANK1);\r\noutb(inb(iobase+FIR_CR) | CR_DMA_EN | CR_DMA_BURST, iobase+FIR_CR);\r\nswitch_bank(iobase, BANK0);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic int ali_ircc_dma_xmit_complete(struct ali_ircc_cb *self)\r\n{\r\nint iobase;\r\nint ret = TRUE;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start -----------------\n", __func__ );\r\niobase = self->io.fir_base;\r\nswitch_bank(iobase, BANK1);\r\noutb(inb(iobase+FIR_CR) & ~CR_DMA_EN, iobase+FIR_CR);\r\nswitch_bank(iobase, BANK0);\r\nif((inb(iobase+FIR_LSR) & LSR_FRAME_ABORT) == LSR_FRAME_ABORT)\r\n{\r\nIRDA_ERROR("%s(), ********* LSR_FRAME_ABORT *********\n", __func__);\r\nself->netdev->stats.tx_errors++;\r\nself->netdev->stats.tx_fifo_errors++;\r\n}\r\nelse\r\n{\r\nself->netdev->stats.tx_packets++;\r\n}\r\nif (self->new_speed)\r\n{\r\nali_ircc_change_speed(self, self->new_speed);\r\nself->new_speed = 0;\r\n}\r\nself->tx_fifo.ptr++;\r\nself->tx_fifo.len--;\r\nif (self->tx_fifo.len)\r\n{\r\nali_ircc_dma_xmit(self);\r\nret = FALSE;\r\n}\r\nelse\r\n{\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\n}\r\nif (self->tx_fifo.free < MAX_TX_WINDOW) {\r\nnetif_wake_queue(self->netdev);\r\n}\r\nswitch_bank(iobase, BANK0);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn ret;\r\n}\r\nstatic int ali_ircc_dma_receive(struct ali_ircc_cb *self)\r\n{\r\nint iobase, tmp;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start -----------------\n", __func__ );\r\niobase = self->io.fir_base;\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\nswitch_bank(iobase, BANK1);\r\noutb(inb(iobase+FIR_CR) & ~CR_DMA_EN, iobase+FIR_CR);\r\nswitch_bank(iobase, BANK0);\r\noutb(0x07, iobase+FIR_LSR);\r\nself->rcvFramesOverflow = FALSE;\r\nself->LineStatus = inb(iobase+FIR_LSR) ;\r\nself->io.direction = IO_RECV;\r\nself->rx_buff.data = self->rx_buff.head;\r\noutb(LCR_A_FIFO_RESET, iobase+FIR_LCR_A);\r\nself->st_fifo.len = self->st_fifo.pending_bytes = 0;\r\nself->st_fifo.tail = self->st_fifo.head = 0;\r\nirda_setup_dma(self->io.dma, self->rx_buff_dma, self->rx_buff.truesize,\r\nDMA_RX_MODE);\r\ntmp = inb(iobase+FIR_LCR_B);\r\noutb((unsigned char)(tmp &0x3f) | LCR_B_RX_MODE | LCR_B_BW , iobase + FIR_LCR_B);\r\nIRDA_DEBUG(1, "%s(), *** Change To RX mode: FIR_LCR_B = 0x%x ***\n", __func__ , inb(iobase+FIR_LCR_B));\r\nswitch_bank(iobase, BANK1);\r\noutb(RX_FIFO_Threshold, iobase+FIR_FIFO_TR);\r\noutb(RX_DMA_Threshold, iobase+FIR_DMA_TR);\r\noutb(CR_DMA_EN | CR_DMA_BURST, iobase+FIR_CR);\r\nswitch_bank(iobase, BANK0);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_dma_receive_complete(struct ali_ircc_cb *self)\r\n{\r\nstruct st_fifo *st_fifo;\r\nstruct sk_buff *skb;\r\n__u8 status, MessageCount;\r\nint len, i, iobase, val;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start -----------------\n", __func__ );\r\nst_fifo = &self->st_fifo;\r\niobase = self->io.fir_base;\r\nswitch_bank(iobase, BANK0);\r\nMessageCount = inb(iobase+ FIR_LSR)&0x07;\r\nif (MessageCount > 0)\r\nIRDA_DEBUG(0, "%s(), Message count = %d,\n", __func__ , MessageCount);\r\nfor (i=0; i<=MessageCount; i++)\r\n{\r\nswitch_bank(iobase, BANK0);\r\nstatus = inb(iobase+FIR_LSR);\r\nswitch_bank(iobase, BANK2);\r\nlen = inb(iobase+FIR_RX_DSR_HI) & 0x0f;\r\nlen = len << 8;\r\nlen |= inb(iobase+FIR_RX_DSR_LO);\r\nIRDA_DEBUG(1, "%s(), RX Length = 0x%.2x,\n", __func__ , len);\r\nIRDA_DEBUG(1, "%s(), RX Status = 0x%.2x,\n", __func__ , status);\r\nif (st_fifo->tail >= MAX_RX_WINDOW) {\r\nIRDA_DEBUG(0, "%s(), window is full!\n", __func__ );\r\ncontinue;\r\n}\r\nst_fifo->entries[st_fifo->tail].status = status;\r\nst_fifo->entries[st_fifo->tail].len = len;\r\nst_fifo->pending_bytes += len;\r\nst_fifo->tail++;\r\nst_fifo->len++;\r\n}\r\nfor (i=0; i<=MessageCount; i++)\r\n{\r\nstatus = st_fifo->entries[st_fifo->head].status;\r\nlen = st_fifo->entries[st_fifo->head].len;\r\nst_fifo->pending_bytes -= len;\r\nst_fifo->head++;\r\nst_fifo->len--;\r\nif ((status & 0xd8) || self->rcvFramesOverflow || (len==0))\r\n{\r\nIRDA_DEBUG(0,"%s(), ************* RX Errors ************\n", __func__ );\r\nself->netdev->stats.rx_errors++;\r\nself->rx_buff.data += len;\r\nif (status & LSR_FIFO_UR)\r\n{\r\nself->netdev->stats.rx_frame_errors++;\r\nIRDA_DEBUG(0,"%s(), ************* FIFO Errors ************\n", __func__ );\r\n}\r\nif (status & LSR_FRAME_ERROR)\r\n{\r\nself->netdev->stats.rx_frame_errors++;\r\nIRDA_DEBUG(0,"%s(), ************* FRAME Errors ************\n", __func__ );\r\n}\r\nif (status & LSR_CRC_ERROR)\r\n{\r\nself->netdev->stats.rx_crc_errors++;\r\nIRDA_DEBUG(0,"%s(), ************* CRC Errors ************\n", __func__ );\r\n}\r\nif(self->rcvFramesOverflow)\r\n{\r\nself->netdev->stats.rx_frame_errors++;\r\nIRDA_DEBUG(0,"%s(), ************* Overran DMA buffer ************\n", __func__ );\r\n}\r\nif(len == 0)\r\n{\r\nself->netdev->stats.rx_frame_errors++;\r\nIRDA_DEBUG(0,"%s(), ********** Receive Frame Size = 0 *********\n", __func__ );\r\n}\r\n}\r\nelse\r\n{\r\nif (st_fifo->pending_bytes < 32)\r\n{\r\nswitch_bank(iobase, BANK0);\r\nval = inb(iobase+FIR_BSR);\r\nif ((val& BSR_FIFO_NOT_EMPTY)== 0x80)\r\n{\r\nIRDA_DEBUG(0, "%s(), ************* BSR_FIFO_NOT_EMPTY ************\n", __func__ );\r\nst_fifo->head--;\r\nst_fifo->len++;\r\nst_fifo->pending_bytes += len;\r\nst_fifo->entries[st_fifo->head].status = status;\r\nst_fifo->entries[st_fifo->head].len = len;\r\nswitch_bank(iobase, BANK1);\r\noutb(TIMER_IIR_500, iobase+FIR_TIMER_IIR);\r\noutb(inb(iobase+FIR_CR) | CR_TIMER_EN, iobase+FIR_CR);\r\nreturn FALSE;\r\n}\r\n}\r\ndo_gettimeofday(&self->stamp);\r\nskb = dev_alloc_skb(len+1);\r\nif (skb == NULL)\r\n{\r\nIRDA_WARNING("%s(), memory squeeze, "\r\n"dropping frame.\n",\r\n__func__);\r\nself->netdev->stats.rx_dropped++;\r\nreturn FALSE;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_put(skb, len);\r\nskb_copy_to_linear_data(skb, self->rx_buff.data, len);\r\nself->rx_buff.data += len;\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\n}\r\n}\r\nswitch_bank(iobase, BANK0);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn TRUE;\r\n}\r\nstatic netdev_tx_t ali_ircc_sir_hard_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ali_ircc_cb *self;\r\nunsigned long flags;\r\nint iobase;\r\n__u32 speed;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_ASSERT(dev != NULL, return NETDEV_TX_OK;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return NETDEV_TX_OK;);\r\niobase = self->io.sir_base;\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&self->lock, flags);\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1)) {\r\nif (!skb->len) {\r\nali_ircc_change_speed(self, speed);\r\ndev->trans_start = jiffies;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else\r\nself->new_speed = speed;\r\n}\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->tx_buff.len = async_wrap_skb(skb, self->tx_buff.data,\r\nself->tx_buff.truesize);\r\nself->netdev->stats.tx_bytes += self->tx_buff.len;\r\noutb(UART_IER_THRI, iobase+UART_IER);\r\ndev->trans_start = jiffies;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ali_ircc_net_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct ali_ircc_cb *self;\r\nunsigned long flags;\r\nint ret = 0;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start ----------------\n", __func__ );\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_DEBUG(2, "%s(), %s, (cmd=0x%X)\n", __func__ , dev->name, cmd);\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nIRDA_DEBUG(1, "%s(), SIOCSBANDWIDTH\n", __func__ );\r\nif (!in_interrupt() && !capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nspin_lock_irqsave(&self->lock, flags);\r\nali_ircc_change_speed(self, irq->ifr_baudrate);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nIRDA_DEBUG(1, "%s(), SIOCSMEDIABUSY\n", __func__ );\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nIRDA_DEBUG(2, "%s(), SIOCGRECEIVING\n", __func__ );\r\nirq->ifr_receiving = ali_ircc_is_receiving(self);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn ret;\r\n}\r\nstatic int ali_ircc_is_receiving(struct ali_ircc_cb *self)\r\n{\r\nunsigned long flags;\r\nint status = FALSE;\r\nint iobase;\r\nIRDA_DEBUG(2, "%s(), ---------------- Start -----------------\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return FALSE;);\r\nspin_lock_irqsave(&self->lock, flags);\r\nif (self->io.speed > 115200)\r\n{\r\niobase = self->io.fir_base;\r\nswitch_bank(iobase, BANK1);\r\nif((inb(iobase+FIR_FIFO_FR) & 0x3f) != 0)\r\n{\r\nIRDA_DEBUG(1, "%s(), We are receiving something\n", __func__ );\r\nstatus = TRUE;\r\n}\r\nswitch_bank(iobase, BANK0);\r\n}\r\nelse\r\n{\r\nstatus = (self->rx_buff.state != OUTSIDE_FRAME);\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\nreturn status;\r\n}\r\nstatic int ali_ircc_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct ali_ircc_cb *self = platform_get_drvdata(dev);\r\nIRDA_MESSAGE("%s, Suspending\n", ALI_IRCC_DRIVER_NAME);\r\nif (self->io.suspended)\r\nreturn 0;\r\nali_ircc_net_close(self->netdev);\r\nself->io.suspended = 1;\r\nreturn 0;\r\n}\r\nstatic int ali_ircc_resume(struct platform_device *dev)\r\n{\r\nstruct ali_ircc_cb *self = platform_get_drvdata(dev);\r\nif (!self->io.suspended)\r\nreturn 0;\r\nali_ircc_net_open(self->netdev);\r\nIRDA_MESSAGE("%s, Waking up\n", ALI_IRCC_DRIVER_NAME);\r\nself->io.suspended = 0;\r\nreturn 0;\r\n}\r\nstatic void SetCOMInterrupts(struct ali_ircc_cb *self , unsigned char enable)\r\n{\r\nunsigned char newMask;\r\nint iobase = self->io.fir_base;\r\nIRDA_DEBUG(2, "%s(), -------- Start -------- ( Enable = %d )\n", __func__ , enable);\r\nif (enable){\r\nif (self->io.direction == IO_XMIT)\r\n{\r\nif (self->io.speed > 115200)\r\n{\r\nnewMask = self->ier;\r\n}\r\nelse\r\n{\r\nnewMask = UART_IER_THRI | UART_IER_RDI;\r\n}\r\n}\r\nelse {\r\nif (self->io.speed > 115200)\r\n{\r\nnewMask = self->ier;\r\n}\r\nelse\r\n{\r\nnewMask = UART_IER_RDI;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nnewMask = 0x00;\r\n}\r\nif (self->io.speed > 115200)\r\n{\r\nswitch_bank(iobase, BANK0);\r\noutb(newMask, iobase+FIR_IER);\r\n}\r\nelse\r\noutb(newMask, iobase+UART_IER);\r\nIRDA_DEBUG(2, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void SIR2FIR(int iobase)\r\n{\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__ );\r\noutb(0x28, iobase+UART_MCR);\r\noutb(0x68, iobase+UART_MCR);\r\noutb(0x88, iobase+UART_MCR);\r\noutb(0x60, iobase+FIR_MCR);\r\noutb(0x20, iobase+FIR_MCR);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\n}\r\nstatic void FIR2SIR(int iobase)\r\n{\r\nunsigned char val;\r\nIRDA_DEBUG(1, "%s(), ---------------- Start ----------------\n", __func__ );\r\noutb(0x20, iobase+FIR_MCR);\r\noutb(0x00, iobase+UART_IER);\r\noutb(0xA0, iobase+FIR_MCR);\r\noutb(0x00, iobase+UART_FCR);\r\noutb(0x07, iobase+UART_FCR);\r\nval = inb(iobase+UART_RX);\r\nval = inb(iobase+UART_LSR);\r\nval = inb(iobase+UART_MSR);\r\nIRDA_DEBUG(1, "%s(), ----------------- End ------------------\n", __func__ );\r\n}
