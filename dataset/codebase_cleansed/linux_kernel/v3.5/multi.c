static __init int rndis_do_config(struct usb_configuration *c)\r\n{\r\nint ret;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nret = rndis_bind_config(c, hostaddr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = acm_bind_config(c, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fsg_bind_config(c->cdev, c, &fsg_common);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rndis_config_register(struct usb_composite_dev *cdev)\r\n{\r\nstatic struct usb_configuration config = {\r\n.bConfigurationValue = MULTI_RNDIS_CONFIG_NUM,\r\n.bmAttributes = USB_CONFIG_ATT_SELFPOWER,\r\n};\r\nconfig.label = strings_dev[MULTI_STRING_RNDIS_CONFIG_IDX].s;\r\nconfig.iConfiguration = strings_dev[MULTI_STRING_RNDIS_CONFIG_IDX].id;\r\nreturn usb_add_config(cdev, &config, rndis_do_config);\r\n}\r\nstatic int rndis_config_register(struct usb_composite_dev *cdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic __init int cdc_do_config(struct usb_configuration *c)\r\n{\r\nint ret;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nret = ecm_bind_config(c, hostaddr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = acm_bind_config(c, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fsg_bind_config(c->cdev, c, &fsg_common);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cdc_config_register(struct usb_composite_dev *cdev)\r\n{\r\nstatic struct usb_configuration config = {\r\n.bConfigurationValue = MULTI_CDC_CONFIG_NUM,\r\n.bmAttributes = USB_CONFIG_ATT_SELFPOWER,\r\n};\r\nconfig.label = strings_dev[MULTI_STRING_CDC_CONFIG_IDX].s;\r\nconfig.iConfiguration = strings_dev[MULTI_STRING_CDC_CONFIG_IDX].id;\r\nreturn usb_add_config(cdev, &config, cdc_do_config);\r\n}\r\nstatic int cdc_config_register(struct usb_composite_dev *cdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __ref multi_bind(struct usb_composite_dev *cdev)\r\n{\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nint status, gcnum;\r\nif (!can_support_ecm(cdev->gadget)) {\r\ndev_err(&gadget->dev, "controller '%s' not usable\n",\r\ngadget->name);\r\nreturn -EINVAL;\r\n}\r\nstatus = gether_setup(cdev->gadget, hostaddr);\r\nif (status < 0)\r\nreturn status;\r\nstatus = gserial_setup(cdev->gadget, 1);\r\nif (status < 0)\r\ngoto fail0;\r\n{\r\nvoid *retp;\r\nretp = fsg_common_from_params(&fsg_common, cdev, &fsg_mod_data);\r\nif (IS_ERR(retp)) {\r\nstatus = PTR_ERR(retp);\r\ngoto fail1;\r\n}\r\n}\r\ngcnum = usb_gadget_controller_number(gadget);\r\nif (gcnum >= 0) {\r\ndevice_desc.bcdDevice = cpu_to_le16(0x0300 | gcnum);\r\n} else {\r\nWARNING(cdev, "controller '%s' not recognized\n", gadget->name);\r\ndevice_desc.bcdDevice = cpu_to_le16(0x0300 | 0x0099);\r\n}\r\nstatus = usb_string_ids_tab(cdev, strings_dev);\r\nif (unlikely(status < 0))\r\ngoto fail2;\r\nstatus = rndis_config_register(cdev);\r\nif (unlikely(status < 0))\r\ngoto fail2;\r\nstatus = cdc_config_register(cdev);\r\nif (unlikely(status < 0))\r\ngoto fail2;\r\ndev_info(&gadget->dev, DRIVER_DESC "\n");\r\nfsg_common_put(&fsg_common);\r\nreturn 0;\r\nfail2:\r\nfsg_common_put(&fsg_common);\r\nfail1:\r\ngserial_cleanup();\r\nfail0:\r\ngether_cleanup();\r\nreturn status;\r\n}\r\nstatic int __exit multi_unbind(struct usb_composite_dev *cdev)\r\n{\r\ngserial_cleanup();\r\ngether_cleanup();\r\nreturn 0;\r\n}\r\nstatic int __init multi_init(void)\r\n{\r\nreturn usb_composite_probe(&multi_driver, multi_bind);\r\n}\r\nstatic void __exit multi_exit(void)\r\n{\r\nusb_composite_unregister(&multi_driver);\r\n}
