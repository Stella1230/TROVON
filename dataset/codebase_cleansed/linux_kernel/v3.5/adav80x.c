static int adav80x_dapm_sysclk_check(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = source->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nconst char *clk;\r\nswitch (adav80x->clk_src) {\r\ncase ADAV80X_CLK_PLL1:\r\nclk = "PLL1";\r\nbreak;\r\ncase ADAV80X_CLK_PLL2:\r\nclk = "PLL2";\r\nbreak;\r\ncase ADAV80X_CLK_XTAL:\r\nclk = "OSC";\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn strcmp(source->name, clk) == 0;\r\n}\r\nstatic int adav80x_dapm_pll_check(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = source->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nreturn adav80x->pll_src == ADAV80X_PLL_SRC_XTAL;\r\n}\r\nstatic int adav80x_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (adav80x->deemph) {\r\nswitch (adav80x->rate) {\r\ncase 32000:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_32;\r\nbreak;\r\ncase 44100:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_44;\r\nbreak;\r\ncase 48000:\r\ncase 64000:\r\ncase 88200:\r\ncase 96000:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_48;\r\nbreak;\r\ndefault:\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_NONE;\r\nbreak;\r\n}\r\n} else {\r\nval = ADAV80X_DAC_CTRL2_DEEMPH_NONE;\r\n}\r\nreturn snd_soc_update_bits(codec, ADAV80X_DAC_CTRL2,\r\nADAV80X_DAC_CTRL2_DEEMPH_MASK, val);\r\n}\r\nstatic int adav80x_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int deemph = ucontrol->value.enumerated.item[0];\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nadav80x->deemph = deemph;\r\nreturn adav80x_set_deemph(codec);\r\n}\r\nstatic int adav80x_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = adav80x->deemph;\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int capture = 0x00;\r\nunsigned int playback = 0x00;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncapture |= ADAV80X_CAPTURE_MODE_MASTER;\r\nplayback |= ADAV80X_PLAYBACK_MODE_MASTER;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncapture |= ADAV80X_CAPTURE_MODE_I2S;\r\nplayback |= ADAV80X_PLAYBACK_MODE_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncapture |= ADAV80X_CAPTURE_MODE_LEFT_J;\r\nplayback |= ADAV80X_PLAYBACK_MODE_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncapture |= ADAV80X_CAPTURE_MODE_RIGHT_J;\r\nplayback |= ADAV80X_PLAYBACK_MODE_RIGHT_J_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, adav80x_port_ctrl_regs[dai->id][0],\r\nADAV80X_CAPTURE_MODE_MASK | ADAV80X_CAPTURE_MODE_MASTER,\r\ncapture);\r\nsnd_soc_write(codec, adav80x_port_ctrl_regs[dai->id][1], playback);\r\nadav80x->dai_fmt[dai->id] = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_adc_clock(struct snd_soc_codec *codec,\r\nunsigned int sample_rate)\r\n{\r\nunsigned int val;\r\nif (sample_rate <= 48000)\r\nval = ADAV80X_ADC_CTRL1_MODULATOR_128FS;\r\nelse\r\nval = ADAV80X_ADC_CTRL1_MODULATOR_64FS;\r\nsnd_soc_update_bits(codec, ADAV80X_ADC_CTRL1,\r\nADAV80X_ADC_CTRL1_MODULATOR_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_dac_clock(struct snd_soc_codec *codec,\r\nunsigned int sample_rate)\r\n{\r\nunsigned int val;\r\nif (sample_rate <= 48000)\r\nval = ADAV80X_DAC_CTRL2_DIV1 | ADAV80X_DAC_CTRL2_INTERPOL_256FS;\r\nelse\r\nval = ADAV80X_DAC_CTRL2_DIV2 | ADAV80X_DAC_CTRL2_INTERPOL_128FS;\r\nsnd_soc_update_bits(codec, ADAV80X_DAC_CTRL2,\r\nADAV80X_DAC_CTRL2_DIV_MASK | ADAV80X_DAC_CTRL2_INTERPOL_MASK,\r\nval);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_capture_pcm_format(struct snd_soc_codec *codec,\r\nstruct snd_soc_dai *dai, snd_pcm_format_t format)\r\n{\r\nunsigned int val;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = ADAV80X_CAPTURE_WORD_LEN16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\nval = ADAV80X_CAPTRUE_WORD_LEN18;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval = ADAV80X_CAPTURE_WORD_LEN20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval = ADAV80X_CAPTURE_WORD_LEN24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, adav80x_port_ctrl_regs[dai->id][0],\r\nADAV80X_CAPTURE_WORD_LEN_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_playback_pcm_format(struct snd_soc_codec *codec,\r\nstruct snd_soc_dai *dai, snd_pcm_format_t format)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (adav80x->dai_fmt[dai->id] != SND_SOC_DAIFMT_RIGHT_J)\r\nreturn 0;\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_18;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nval = ADAV80X_PLAYBACK_MODE_RIGHT_J_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, adav80x_port_ctrl_regs[dai->id][1],\r\nADAV80X_PLAYBACK_MODE_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adav80x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int rate = params_rate(params);\r\nif (rate * 256 != adav80x->sysclk)\r\nreturn -EINVAL;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nadav80x_set_playback_pcm_format(codec, dai,\r\nparams_format(params));\r\nadav80x_set_dac_clock(codec, rate);\r\n} else {\r\nadav80x_set_capture_pcm_format(codec, dai,\r\nparams_format(params));\r\nadav80x_set_adc_clock(codec, rate);\r\n}\r\nadav80x->rate = rate;\r\nadav80x_set_deemph(codec);\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_sysclk(struct snd_soc_codec *codec,\r\nint clk_id, int source,\r\nunsigned int freq, int dir)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nif (dir == SND_SOC_CLOCK_IN) {\r\nswitch (clk_id) {\r\ncase ADAV80X_CLK_XIN:\r\ncase ADAV80X_CLK_XTAL:\r\ncase ADAV80X_CLK_MCLKI:\r\ncase ADAV80X_CLK_PLL1:\r\ncase ADAV80X_CLK_PLL2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadav80x->sysclk = freq;\r\nif (adav80x->clk_src != clk_id) {\r\nunsigned int iclk_ctrl1, iclk_ctrl2;\r\nadav80x->clk_src = clk_id;\r\nif (clk_id == ADAV80X_CLK_XTAL)\r\nclk_id = ADAV80X_CLK_XIN;\r\niclk_ctrl1 = ADAV80X_ICLK_CTRL1_DAC_SRC(clk_id) |\r\nADAV80X_ICLK_CTRL1_ADC_SRC(clk_id) |\r\nADAV80X_ICLK_CTRL1_ICLK2_SRC(clk_id);\r\niclk_ctrl2 = ADAV80X_ICLK_CTRL2_ICLK1_SRC(clk_id);\r\nsnd_soc_write(codec, ADAV80X_ICLK_CTRL1, iclk_ctrl1);\r\nsnd_soc_write(codec, ADAV80X_ICLK_CTRL2, iclk_ctrl2);\r\nsnd_soc_dapm_sync(&codec->dapm);\r\n}\r\n} else {\r\nunsigned int mask;\r\nswitch (clk_id) {\r\ncase ADAV80X_CLK_SYSCLK1:\r\ncase ADAV80X_CLK_SYSCLK2:\r\ncase ADAV80X_CLK_SYSCLK3:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclk_id -= ADAV80X_CLK_SYSCLK1;\r\nmask = ADAV80X_PLL_OUTE_SYSCLKPD(clk_id);\r\nif (freq == 0) {\r\nsnd_soc_update_bits(codec, ADAV80X_PLL_OUTE, mask, mask);\r\nadav80x->sysclk_pd[clk_id] = true;\r\n} else {\r\nsnd_soc_update_bits(codec, ADAV80X_PLL_OUTE, mask, 0);\r\nadav80x->sysclk_pd[clk_id] = false;\r\n}\r\nif (adav80x->sysclk_pd[0])\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "PLL1");\r\nelse\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "PLL1");\r\nif (adav80x->sysclk_pd[1] || adav80x->sysclk_pd[2])\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "PLL2");\r\nelse\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "PLL2");\r\nsnd_soc_dapm_sync(&codec->dapm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_pll(struct snd_soc_codec *codec, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nunsigned int pll_ctrl1 = 0;\r\nunsigned int pll_ctrl2 = 0;\r\nunsigned int pll_src;\r\nswitch (source) {\r\ncase ADAV80X_PLL_SRC_XTAL:\r\ncase ADAV80X_PLL_SRC_XIN:\r\ncase ADAV80X_PLL_SRC_MCLKI:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!freq_out)\r\nreturn 0;\r\nswitch (freq_in) {\r\ncase 27000000:\r\nbreak;\r\ncase 54000000:\r\nif (source == ADAV80X_PLL_SRC_XIN) {\r\npll_ctrl1 |= ADAV80X_PLL_CTRL1_PLLDIV;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (freq_out > 12288000) {\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_DOUB(pll_id);\r\nfreq_out /= 2;\r\n}\r\nswitch (freq_out) {\r\ncase 8192000:\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_32(pll_id);\r\nbreak;\r\ncase 11289600:\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_44(pll_id);\r\nbreak;\r\ncase 12288000:\r\npll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_48(pll_id);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, ADAV80X_PLL_CTRL1, ADAV80X_PLL_CTRL1_PLLDIV,\r\npll_ctrl1);\r\nsnd_soc_update_bits(codec, ADAV80X_PLL_CTRL2,\r\nADAV80X_PLL_CTRL2_PLL_MASK(pll_id), pll_ctrl2);\r\nif (source != adav80x->pll_src) {\r\nif (source == ADAV80X_PLL_SRC_MCLKI)\r\npll_src = ADAV80X_PLL_CLK_SRC_PLL_MCLKI(pll_id);\r\nelse\r\npll_src = ADAV80X_PLL_CLK_SRC_PLL_XIN(pll_id);\r\nsnd_soc_update_bits(codec, ADAV80X_PLL_CLK_SRC,\r\nADAV80X_PLL_CLK_SRC_PLL_MASK(pll_id), pll_src);\r\nadav80x->pll_src = source;\r\nsnd_soc_dapm_sync(&codec->dapm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adav80x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nunsigned int mask = ADAV80X_DAC_CTRL1_PD;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, ADAV80X_DAC_CTRL1, mask, 0x00);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, ADAV80X_DAC_CTRL1, mask, mask);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int adav80x_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nif (!codec->active || !adav80x->rate)\r\nreturn 0;\r\nreturn snd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE, adav80x->rate, adav80x->rate);\r\n}\r\nstatic void adav80x_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nif (!codec->active)\r\nadav80x->rate = 0;\r\n}\r\nstatic int adav80x_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nstruct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);\r\nret = snd_soc_codec_set_cache_io(codec, 7, 9, adav80x->control_type);\r\nif (ret) {\r\ndev_err(codec->dev, "failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "PLL1");\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "PLL2");\r\nsnd_soc_write(codec, ADAV80X_PLL_OUTE, 0x20);\r\nsnd_soc_write(codec, ADAV80X_DAC_CTRL3, 0x6);\r\nreturn adav80x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\n}\r\nstatic int adav80x_suspend(struct snd_soc_codec *codec)\r\n{\r\nreturn adav80x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\n}\r\nstatic int adav80x_resume(struct snd_soc_codec *codec)\r\n{\r\nadav80x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\ncodec->cache_sync = 1;\r\nsnd_soc_cache_sync(codec);\r\nreturn 0;\r\n}\r\nstatic int adav80x_remove(struct snd_soc_codec *codec)\r\n{\r\nreturn adav80x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\n}\r\nstatic int __devinit adav80x_bus_probe(struct device *dev,\r\nenum snd_soc_control_type control_type)\r\n{\r\nstruct adav80x *adav80x;\r\nint ret;\r\nadav80x = kzalloc(sizeof(*adav80x), GFP_KERNEL);\r\nif (!adav80x)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, adav80x);\r\nadav80x->control_type = control_type;\r\nret = snd_soc_register_codec(dev, &adav80x_codec_driver,\r\nadav80x_dais, ARRAY_SIZE(adav80x_dais));\r\nif (ret)\r\nkfree(adav80x);\r\nreturn ret;\r\n}\r\nstatic int __devexit adav80x_bus_remove(struct device *dev)\r\n{\r\nsnd_soc_unregister_codec(dev);\r\nkfree(dev_get_drvdata(dev));\r\nreturn 0;\r\n}\r\nstatic int __devinit adav80x_spi_probe(struct spi_device *spi)\r\n{\r\nreturn adav80x_bus_probe(&spi->dev, SND_SOC_SPI);\r\n}\r\nstatic int __devexit adav80x_spi_remove(struct spi_device *spi)\r\n{\r\nreturn adav80x_bus_remove(&spi->dev);\r\n}\r\nstatic int __devinit adav80x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nreturn adav80x_bus_probe(&client->dev, SND_SOC_I2C);\r\n}\r\nstatic int __devexit adav80x_i2c_remove(struct i2c_client *client)\r\n{\r\nreturn adav80x_bus_remove(&client->dev);\r\n}\r\nstatic int __init adav80x_init(void)\r\n{\r\nint ret = 0;\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\nret = i2c_add_driver(&adav80x_i2c_driver);\r\nif (ret)\r\nreturn ret;\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nret = spi_register_driver(&adav80x_spi_driver);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit adav80x_exit(void)\r\n{\r\n#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)\r\ni2c_del_driver(&adav80x_i2c_driver);\r\n#endif\r\n#if defined(CONFIG_SPI_MASTER)\r\nspi_unregister_driver(&adav80x_spi_driver);\r\n#endif\r\n}
