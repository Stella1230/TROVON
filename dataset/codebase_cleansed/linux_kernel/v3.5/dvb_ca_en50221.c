static char *findstr(char * haystack, int hlen, char * needle, int nlen)\r\n{\r\nint i;\r\nif (hlen < nlen)\r\nreturn NULL;\r\nfor (i = 0; i <= hlen - nlen; i++) {\r\nif (!strncmp(haystack + i, needle, nlen))\r\nreturn haystack + i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int dvb_ca_en50221_check_camstatus(struct dvb_ca_private *ca, int slot)\r\n{\r\nint slot_status;\r\nint cam_present_now;\r\nint cam_changed;\r\nif (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE) {\r\nreturn (atomic_read(&ca->slot_info[slot].camchange_count) != 0);\r\n}\r\nslot_status = ca->pub->poll_slot_status(ca->pub, slot, ca->open);\r\ncam_present_now = (slot_status & DVB_CA_EN50221_POLL_CAM_PRESENT) ? 1 : 0;\r\ncam_changed = (slot_status & DVB_CA_EN50221_POLL_CAM_CHANGED) ? 1 : 0;\r\nif (!cam_changed) {\r\nint cam_present_old = (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE);\r\ncam_changed = (cam_present_now != cam_present_old);\r\n}\r\nif (cam_changed) {\r\nif (!cam_present_now) {\r\nca->slot_info[slot].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;\r\n} else {\r\nca->slot_info[slot].camchange_type = DVB_CA_EN50221_CAMCHANGE_INSERTED;\r\n}\r\natomic_set(&ca->slot_info[slot].camchange_count, 1);\r\n} else {\r\nif ((ca->slot_info[slot].slot_state == DVB_CA_SLOTSTATE_WAITREADY) &&\r\n(slot_status & DVB_CA_EN50221_POLL_CAM_READY)) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_VALIDATE;\r\n}\r\n}\r\nreturn cam_changed;\r\n}\r\nstatic int dvb_ca_en50221_wait_if_status(struct dvb_ca_private *ca, int slot,\r\nu8 waitfor, int timeout_hz)\r\n{\r\nunsigned long timeout;\r\nunsigned long start;\r\ndprintk("%s\n", __func__);\r\nstart = jiffies;\r\ntimeout = jiffies + timeout_hz;\r\nwhile (1) {\r\nint res = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\r\nif (res < 0)\r\nreturn -EIO;\r\nif (res & waitfor) {\r\ndprintk("%s succeeded timeout:%lu\n", __func__, jiffies - start);\r\nreturn 0;\r\n}\r\nif (time_after(jiffies, timeout)) {\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\ndprintk("%s failed timeout:%lu\n", __func__, jiffies - start);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int dvb_ca_en50221_link_init(struct dvb_ca_private *ca, int slot)\r\n{\r\nint ret;\r\nint buf_size;\r\nu8 buf[2];\r\ndprintk("%s\n", __func__);\r\nca->slot_info[slot].da_irq_supported = 0;\r\nca->slot_info[slot].link_buf_size = 2;\r\nif ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN | CMDREG_SR)) != 0)\r\nreturn ret;\r\nif ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_DA, HZ / 10)) != 0)\r\nreturn ret;\r\nif ((ret = dvb_ca_en50221_read_data(ca, slot, buf, 2)) != 2)\r\nreturn -EIO;\r\nif ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN)) != 0)\r\nreturn ret;\r\nbuf_size = (buf[0] << 8) | buf[1];\r\nif (buf_size > HOST_LINK_BUF_SIZE)\r\nbuf_size = HOST_LINK_BUF_SIZE;\r\nca->slot_info[slot].link_buf_size = buf_size;\r\nbuf[0] = buf_size >> 8;\r\nbuf[1] = buf_size & 0xff;\r\ndprintk("Chosen link buffer size of %i\n", buf_size);\r\nif ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN | CMDREG_SW)) != 0)\r\nreturn ret;\r\nif ((ret = dvb_ca_en50221_wait_if_status(ca, slot, STATUSREG_FR, HZ / 10)) != 0)\r\nreturn ret;\r\nif ((ret = dvb_ca_en50221_write_data(ca, slot, buf, 2)) != 2)\r\nreturn -EIO;\r\nif ((ret = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN)) != 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int dvb_ca_en50221_read_tuple(struct dvb_ca_private *ca, int slot,\r\nint *address, int *tupleType, int *tupleLength, u8 * tuple)\r\n{\r\nint i;\r\nint _tupleType;\r\nint _tupleLength;\r\nint _address = *address;\r\nif ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0)\r\nreturn _tupleType;\r\nif (_tupleType == 0xff) {\r\ndprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);\r\n*address += 2;\r\n*tupleType = _tupleType;\r\n*tupleLength = 0;\r\nreturn 0;\r\n}\r\nif ((_tupleLength = ca->pub->read_attribute_mem(ca->pub, slot, _address + 2)) < 0)\r\nreturn _tupleLength;\r\n_address += 4;\r\ndprintk("TUPLE type:0x%x length:%i\n", _tupleType, _tupleLength);\r\nfor (i = 0; i < _tupleLength; i++) {\r\ntuple[i] = ca->pub->read_attribute_mem(ca->pub, slot, _address + (i * 2));\r\ndprintk(" 0x%02x: 0x%02x %c\n",\r\ni, tuple[i] & 0xff,\r\n((tuple[i] > 31) && (tuple[i] < 127)) ? tuple[i] : '.');\r\n}\r\n_address += (_tupleLength * 2);\r\n*tupleType = _tupleType;\r\n*tupleLength = _tupleLength;\r\n*address = _address;\r\nreturn 0;\r\n}\r\nstatic int dvb_ca_en50221_parse_attributes(struct dvb_ca_private *ca, int slot)\r\n{\r\nint address = 0;\r\nint tupleLength;\r\nint tupleType;\r\nu8 tuple[257];\r\nchar *dvb_str;\r\nint rasz;\r\nint status;\r\nint got_cftableentry = 0;\r\nint end_chain = 0;\r\nint i;\r\nu16 manfid = 0;\r\nu16 devid = 0;\r\nif ((status =\r\ndvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)\r\nreturn status;\r\nif (tupleType != 0x1D)\r\nreturn -EINVAL;\r\nif ((status =\r\ndvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)\r\nreturn status;\r\nif (tupleType != 0x1C)\r\nreturn -EINVAL;\r\nif ((status =\r\ndvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType, &tupleLength, tuple)) < 0)\r\nreturn status;\r\nif (tupleType != 0x15)\r\nreturn -EINVAL;\r\nif ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,\r\n&tupleLength, tuple)) < 0)\r\nreturn status;\r\nif (tupleType != 0x20)\r\nreturn -EINVAL;\r\nif (tupleLength != 4)\r\nreturn -EINVAL;\r\nmanfid = (tuple[1] << 8) | tuple[0];\r\ndevid = (tuple[3] << 8) | tuple[2];\r\nif ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,\r\n&tupleLength, tuple)) < 0)\r\nreturn status;\r\nif (tupleType != 0x1A)\r\nreturn -EINVAL;\r\nif (tupleLength < 3)\r\nreturn -EINVAL;\r\nrasz = tuple[0] & 3;\r\nif (tupleLength < (3 + rasz + 14))\r\nreturn -EINVAL;\r\nca->slot_info[slot].config_base = 0;\r\nfor (i = 0; i < rasz + 1; i++) {\r\nca->slot_info[slot].config_base |= (tuple[2 + i] << (8 * i));\r\n}\r\ndvb_str = findstr((char *)tuple, tupleLength, "DVB_CI_V", 8);\r\nif (dvb_str == NULL)\r\nreturn -EINVAL;\r\nif (tupleLength < ((dvb_str - (char *) tuple) + 12))\r\nreturn -EINVAL;\r\nif (strncmp(dvb_str + 8, "1.00", 4)) {\r\nprintk("dvb_ca adapter %d: Unsupported DVB CAM module version %c%c%c%c\n",\r\nca->dvbdev->adapter->num, dvb_str[8], dvb_str[9], dvb_str[10], dvb_str[11]);\r\nreturn -EINVAL;\r\n}\r\nwhile ((!end_chain) && (address < 0x1000)) {\r\nif ((status = dvb_ca_en50221_read_tuple(ca, slot, &address, &tupleType,\r\n&tupleLength, tuple)) < 0)\r\nreturn status;\r\nswitch (tupleType) {\r\ncase 0x1B:\r\nif (tupleLength < (2 + 11 + 17))\r\nbreak;\r\nif (got_cftableentry)\r\nbreak;\r\nca->slot_info[slot].config_option = tuple[0] & 0x3f;\r\nif ((findstr((char *)tuple, tupleLength, "DVB_HOST", 8) == NULL) ||\r\n(findstr((char *)tuple, tupleLength, "DVB_CI_MODULE", 13) == NULL))\r\nbreak;\r\ngot_cftableentry = 1;\r\nbreak;\r\ncase 0x14:\r\nbreak;\r\ncase 0xFF:\r\nend_chain = 1;\r\nbreak;\r\ndefault:\r\ndprintk("dvb_ca: Skipping unknown tuple type:0x%x length:0x%x\n", tupleType,\r\ntupleLength);\r\nbreak;\r\n}\r\n}\r\nif ((address > 0x1000) || (!got_cftableentry))\r\nreturn -EINVAL;\r\ndprintk("Valid DVB CAM detected MANID:%x DEVID:%x CONFIGBASE:0x%x CONFIGOPTION:0x%x\n",\r\nmanfid, devid, ca->slot_info[slot].config_base, ca->slot_info[slot].config_option);\r\nreturn 0;\r\n}\r\nstatic int dvb_ca_en50221_set_configoption(struct dvb_ca_private *ca, int slot)\r\n{\r\nint configoption;\r\ndprintk("%s\n", __func__);\r\nca->pub->write_attribute_mem(ca->pub, slot,\r\nca->slot_info[slot].config_base,\r\nca->slot_info[slot].config_option);\r\nconfigoption = ca->pub->read_attribute_mem(ca->pub, slot, ca->slot_info[slot].config_base);\r\ndprintk("Set configoption 0x%x, read configoption 0x%x\n",\r\nca->slot_info[slot].config_option, configoption & 0x3f);\r\nreturn 0;\r\n}\r\nstatic int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount)\r\n{\r\nint bytes_read;\r\nint status;\r\nu8 buf[HOST_LINK_BUF_SIZE];\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif (ebuf == NULL) {\r\nint buf_free;\r\nif (ca->slot_info[slot].rx_buffer.data == NULL) {\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nbuf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);\r\nif (buf_free < (ca->slot_info[slot].link_buf_size + DVB_RINGBUFFER_PKTHDRSIZE)) {\r\nstatus = -EAGAIN;\r\ngoto exit;\r\n}\r\n}\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)\r\ngoto exit;\r\nif (!(status & STATUSREG_DA)) {\r\nstatus = 0;\r\ngoto exit;\r\n}\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH)) < 0)\r\ngoto exit;\r\nbytes_read = status << 8;\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW)) < 0)\r\ngoto exit;\r\nbytes_read |= status;\r\nif (ebuf == NULL) {\r\nif (bytes_read > ca->slot_info[slot].link_buf_size) {\r\nprintk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\n",\r\nca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nif (bytes_read < 2) {\r\nprintk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",\r\nca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\n} else {\r\nif (bytes_read > ecount) {\r\nprintk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n",\r\nca->dvbdev->adapter->num);\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\n}\r\nfor (i = 0; i < bytes_read; i++) {\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_DATA)) < 0)\r\ngoto exit;\r\nbuf[i] = status;\r\n}\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)\r\ngoto exit;\r\nif (status & STATUSREG_RE) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nif (ebuf == NULL) {\r\nif (ca->slot_info[slot].rx_buffer.data == NULL) {\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\ndvb_ringbuffer_pkt_write(&ca->slot_info[slot].rx_buffer, buf, bytes_read);\r\n} else {\r\nmemcpy(ebuf, buf, bytes_read);\r\n}\r\ndprintk("Received CA packet for slot %i connection id 0x%x last_frag:%i size:0x%x\n", slot,\r\nbuf[0], (buf[1] & 0x80) == 0, bytes_read);\r\nif ((buf[1] & 0x80) == 0x00) {\r\nwake_up_interruptible(&ca->wait_queue);\r\n}\r\nstatus = bytes_read;\r\nexit:\r\nreturn status;\r\n}\r\nstatic int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot, u8 * buf, int bytes_write)\r\n{\r\nint status;\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif (bytes_write > ca->slot_info[slot].link_buf_size)\r\nreturn -EINVAL;\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)\r\ngoto exitnowrite;\r\nif (status & (STATUSREG_DA | STATUSREG_RE)) {\r\nif (status & STATUSREG_DA)\r\ndvb_ca_en50221_thread_wakeup(ca);\r\nstatus = -EAGAIN;\r\ngoto exitnowrite;\r\n}\r\nif ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND,\r\nIRQEN | CMDREG_HC)) != 0)\r\ngoto exit;\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)\r\ngoto exit;\r\nif (!(status & STATUSREG_FR)) {\r\nstatus = -EAGAIN;\r\ngoto exit;\r\n}\r\nif ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_HIGH, bytes_write >> 8)) != 0)\r\ngoto exit;\r\nif ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_SIZE_LOW,\r\nbytes_write & 0xff)) != 0)\r\ngoto exit;\r\nfor (i = 0; i < bytes_write; i++) {\r\nif ((status = ca->pub->write_cam_control(ca->pub, slot, CTRLIF_DATA, buf[i])) != 0)\r\ngoto exit;\r\n}\r\nif ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)\r\ngoto exit;\r\nif (status & STATUSREG_WE) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nstatus = bytes_write;\r\ndprintk("Wrote CA packet for slot %i, connection id 0x%x last_frag:%i size:0x%x\n", slot,\r\nbuf[0], (buf[1] & 0x80) == 0, bytes_write);\r\nexit:\r\nca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);\r\nexitnowrite:\r\nreturn status;\r\n}\r\nstatic int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)\r\n{\r\ndprintk("%s\n", __func__);\r\nca->pub->slot_shutdown(ca->pub, slot);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;\r\nwake_up_interruptible(&ca->wait_queue);\r\ndprintk("Slot %i shutdown\n", slot);\r\nreturn 0;\r\n}\r\nvoid dvb_ca_en50221_camchange_irq(struct dvb_ca_en50221 *pubca, int slot, int change_type)\r\n{\r\nstruct dvb_ca_private *ca = pubca->private;\r\ndprintk("CAMCHANGE IRQ slot:%i change_type:%i\n", slot, change_type);\r\nswitch (change_type) {\r\ncase DVB_CA_EN50221_CAMCHANGE_REMOVED:\r\ncase DVB_CA_EN50221_CAMCHANGE_INSERTED:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nca->slot_info[slot].camchange_type = change_type;\r\natomic_inc(&ca->slot_info[slot].camchange_count);\r\ndvb_ca_en50221_thread_wakeup(ca);\r\n}\r\nvoid dvb_ca_en50221_camready_irq(struct dvb_ca_en50221 *pubca, int slot)\r\n{\r\nstruct dvb_ca_private *ca = pubca->private;\r\ndprintk("CAMREADY IRQ slot:%i\n", slot);\r\nif (ca->slot_info[slot].slot_state == DVB_CA_SLOTSTATE_WAITREADY) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_VALIDATE;\r\ndvb_ca_en50221_thread_wakeup(ca);\r\n}\r\n}\r\nvoid dvb_ca_en50221_frda_irq(struct dvb_ca_en50221 *pubca, int slot)\r\n{\r\nstruct dvb_ca_private *ca = pubca->private;\r\nint flags;\r\ndprintk("FR/DA IRQ slot:%i\n", slot);\r\nswitch (ca->slot_info[slot].slot_state) {\r\ncase DVB_CA_SLOTSTATE_LINKINIT:\r\nflags = ca->pub->read_cam_control(pubca, slot, CTRLIF_STATUS);\r\nif (flags & STATUSREG_DA) {\r\ndprintk("CAM supports DA IRQ\n");\r\nca->slot_info[slot].da_irq_supported = 1;\r\n}\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_RUNNING:\r\nif (ca->open)\r\ndvb_ca_en50221_thread_wakeup(ca);\r\nbreak;\r\n}\r\n}\r\nstatic void dvb_ca_en50221_thread_wakeup(struct dvb_ca_private *ca)\r\n{\r\ndprintk("%s\n", __func__);\r\nca->wakeup = 1;\r\nmb();\r\nwake_up_process(ca->thread);\r\n}\r\nstatic void dvb_ca_en50221_thread_update_delay(struct dvb_ca_private *ca)\r\n{\r\nint delay;\r\nint curdelay = 100000000;\r\nint slot;\r\nfor (slot = 0; slot < ca->slot_count; slot++) {\r\nswitch (ca->slot_info[slot].slot_state) {\r\ndefault:\r\ncase DVB_CA_SLOTSTATE_NONE:\r\ndelay = HZ * 60;\r\nif (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))\r\ndelay = HZ * 5;\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_INVALID:\r\ndelay = HZ * 60;\r\nif (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))\r\ndelay = HZ / 10;\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_UNINITIALISED:\r\ncase DVB_CA_SLOTSTATE_WAITREADY:\r\ncase DVB_CA_SLOTSTATE_VALIDATE:\r\ncase DVB_CA_SLOTSTATE_WAITFR:\r\ncase DVB_CA_SLOTSTATE_LINKINIT:\r\ndelay = HZ / 10;\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_RUNNING:\r\ndelay = HZ * 60;\r\nif (!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE))\r\ndelay = HZ / 10;\r\nif (ca->open) {\r\nif ((!ca->slot_info[slot].da_irq_supported) ||\r\n(!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_DA)))\r\ndelay = HZ / 10;\r\n}\r\nbreak;\r\n}\r\nif (delay < curdelay)\r\ncurdelay = delay;\r\n}\r\nca->delay = curdelay;\r\n}\r\nstatic int dvb_ca_en50221_thread(void *data)\r\n{\r\nstruct dvb_ca_private *ca = data;\r\nint slot;\r\nint flags;\r\nint status;\r\nint pktcount;\r\nvoid *rxbuf;\r\ndprintk("%s\n", __func__);\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nwhile (!kthread_should_stop()) {\r\nif (!ca->wakeup) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(ca->delay);\r\nif (kthread_should_stop())\r\nreturn 0;\r\n}\r\nca->wakeup = 0;\r\nfor (slot = 0; slot < ca->slot_count; slot++) {\r\nmutex_lock(&ca->slot_info[slot].slot_lock);\r\nwhile (dvb_ca_en50221_check_camstatus(ca, slot)) {\r\nif (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE)\r\ndvb_ca_en50221_slot_shutdown(ca, slot);\r\nif (ca->slot_info[slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;\r\n}\r\ndvb_ca_en50221_thread_update_delay(ca);\r\natomic_dec(&ca->slot_info[slot].camchange_count);\r\n}\r\nswitch (ca->slot_info[slot].slot_state) {\r\ncase DVB_CA_SLOTSTATE_NONE:\r\ncase DVB_CA_SLOTSTATE_INVALID:\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_UNINITIALISED:\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITREADY;\r\nca->pub->slot_reset(ca->pub, slot);\r\nca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_WAITREADY:\r\nif (time_after(jiffies, ca->slot_info[slot].timeout)) {\r\nprintk("dvb_ca adaptor %d: PC card did not respond :(\n",\r\nca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_VALIDATE:\r\nif (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {\r\nif ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&\r\n(ca->pub->poll_slot_status)) {\r\nstatus = ca->pub->poll_slot_status(ca->pub, slot, 0);\r\nif (!(status & DVB_CA_EN50221_POLL_CAM_PRESENT)) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\n}\r\nprintk("dvb_ca adapter %d: Invalid PC card inserted :(\n",\r\nca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\nif (dvb_ca_en50221_set_configoption(ca, slot) != 0) {\r\nprintk("dvb_ca adapter %d: Unable to initialise CAM :(\n",\r\nca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\nif (ca->pub->write_cam_control(ca->pub, slot,\r\nCTRLIF_COMMAND, CMDREG_RS) != 0) {\r\nprintk("dvb_ca adapter %d: Unable to reset CAM IF\n",\r\nca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\ndprintk("DVB CAM validated successfully\n");\r\nca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;\r\nca->wakeup = 1;\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_WAITFR:\r\nif (time_after(jiffies, ca->slot_info[slot].timeout)) {\r\nprintk("dvb_ca adapter %d: DVB CAM did not respond :(\n",\r\nca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\nflags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);\r\nif (flags & STATUSREG_FR) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;\r\nca->wakeup = 1;\r\n}\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_LINKINIT:\r\nif (dvb_ca_en50221_link_init(ca, slot) != 0) {\r\nif ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&\r\n(ca->pub->poll_slot_status)) {\r\nstatus = ca->pub->poll_slot_status(ca->pub, slot, 0);\r\nif (!(status & DVB_CA_EN50221_POLL_CAM_PRESENT)) {\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\n}\r\nprintk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\nif (ca->slot_info[slot].rx_buffer.data == NULL) {\r\nrxbuf = vmalloc(RX_BUFFER_SIZE);\r\nif (rxbuf == NULL) {\r\nprintk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nbreak;\r\n}\r\ndvb_ringbuffer_init(&ca->slot_info[slot].rx_buffer, rxbuf, RX_BUFFER_SIZE);\r\n}\r\nca->pub->slot_ts_enable(ca->pub, slot);\r\nca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nprintk("dvb_ca adapter %d: DVB CAM detected and initialised successfully\n", ca->dvbdev->adapter->num);\r\nbreak;\r\ncase DVB_CA_SLOTSTATE_RUNNING:\r\nif (!ca->open)\r\nbreak;\r\npktcount = 0;\r\nwhile ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0)) > 0) {\r\nif (!ca->open)\r\nbreak;\r\nif (dvb_ca_en50221_check_camstatus(ca, slot)) {\r\nca->wakeup = 1;\r\nbreak;\r\n}\r\nif (++pktcount >= MAX_RX_PACKETS_PER_ITERATION) {\r\nca->wakeup = 1;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nmutex_unlock(&ca->slot_info[slot].slot_lock);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_ca_en50221_io_do_ioctl(struct file *file,\r\nunsigned int cmd, void *parg)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_ca_private *ca = dvbdev->priv;\r\nint err = 0;\r\nint slot;\r\ndprintk("%s\n", __func__);\r\nswitch (cmd) {\r\ncase CA_RESET:\r\nfor (slot = 0; slot < ca->slot_count; slot++) {\r\nmutex_lock(&ca->slot_info[slot].slot_lock);\r\nif (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE) {\r\ndvb_ca_en50221_slot_shutdown(ca, slot);\r\nif (ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)\r\ndvb_ca_en50221_camchange_irq(ca->pub,\r\nslot,\r\nDVB_CA_EN50221_CAMCHANGE_INSERTED);\r\n}\r\nmutex_unlock(&ca->slot_info[slot].slot_lock);\r\n}\r\nca->next_read_slot = 0;\r\ndvb_ca_en50221_thread_wakeup(ca);\r\nbreak;\r\ncase CA_GET_CAP: {\r\nstruct ca_caps *caps = parg;\r\ncaps->slot_num = ca->slot_count;\r\ncaps->slot_type = CA_CI_LINK;\r\ncaps->descr_num = 0;\r\ncaps->descr_type = 0;\r\nbreak;\r\n}\r\ncase CA_GET_SLOT_INFO: {\r\nstruct ca_slot_info *info = parg;\r\nif ((info->num > ca->slot_count) || (info->num < 0))\r\nreturn -EINVAL;\r\ninfo->type = CA_CI_LINK;\r\ninfo->flags = 0;\r\nif ((ca->slot_info[info->num].slot_state != DVB_CA_SLOTSTATE_NONE)\r\n&& (ca->slot_info[info->num].slot_state != DVB_CA_SLOTSTATE_INVALID)) {\r\ninfo->flags = CA_CI_MODULE_PRESENT;\r\n}\r\nif (ca->slot_info[info->num].slot_state == DVB_CA_SLOTSTATE_RUNNING) {\r\ninfo->flags |= CA_CI_MODULE_READY;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic long dvb_ca_en50221_io_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn dvb_usercopy(file, cmd, arg, dvb_ca_en50221_io_do_ioctl);\r\n}\r\nstatic ssize_t dvb_ca_en50221_io_write(struct file *file,\r\nconst char __user * buf, size_t count, loff_t * ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_ca_private *ca = dvbdev->priv;\r\nu8 slot, connection_id;\r\nint status;\r\nu8 fragbuf[HOST_LINK_BUF_SIZE];\r\nint fragpos = 0;\r\nint fraglen;\r\nunsigned long timeout;\r\nint written;\r\ndprintk("%s\n", __func__);\r\nif (count < 2)\r\nreturn -EINVAL;\r\nif (copy_from_user(&slot, buf, 1))\r\nreturn -EFAULT;\r\nif (copy_from_user(&connection_id, buf + 1, 1))\r\nreturn -EFAULT;\r\nbuf += 2;\r\ncount -= 2;\r\nif (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)\r\nreturn -EINVAL;\r\nwhile (fragpos < count) {\r\nfraglen = ca->slot_info[slot].link_buf_size - 2;\r\nif (fraglen < 0)\r\nbreak;\r\nif (fraglen > HOST_LINK_BUF_SIZE - 2)\r\nfraglen = HOST_LINK_BUF_SIZE - 2;\r\nif ((count - fragpos) < fraglen)\r\nfraglen = count - fragpos;\r\nfragbuf[0] = connection_id;\r\nfragbuf[1] = ((fragpos + fraglen) < count) ? 0x80 : 0x00;\r\nstatus = copy_from_user(fragbuf + 2, buf + fragpos, fraglen);\r\nif (status) {\r\nstatus = -EFAULT;\r\ngoto exit;\r\n}\r\ntimeout = jiffies + HZ / 2;\r\nwritten = 0;\r\nwhile (!time_after(jiffies, timeout)) {\r\nif (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING) {\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nmutex_lock(&ca->slot_info[slot].slot_lock);\r\nstatus = dvb_ca_en50221_write_data(ca, slot, fragbuf, fraglen + 2);\r\nmutex_unlock(&ca->slot_info[slot].slot_lock);\r\nif (status == (fraglen + 2)) {\r\nwritten = 1;\r\nbreak;\r\n}\r\nif (status != -EAGAIN)\r\ngoto exit;\r\nmsleep(1);\r\n}\r\nif (!written) {\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\nfragpos += fraglen;\r\n}\r\nstatus = count + 2;\r\nexit:\r\nreturn status;\r\n}\r\nstatic int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,\r\nint *result, int *_slot)\r\n{\r\nint slot;\r\nint slot_count = 0;\r\nint idx;\r\nsize_t fraglen;\r\nint connection_id = -1;\r\nint found = 0;\r\nu8 hdr[2];\r\nslot = ca->next_read_slot;\r\nwhile ((slot_count < ca->slot_count) && (!found)) {\r\nif (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)\r\ngoto nextslot;\r\nif (ca->slot_info[slot].rx_buffer.data == NULL) {\r\nreturn 0;\r\n}\r\nidx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);\r\nwhile (idx != -1) {\r\ndvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);\r\nif (connection_id == -1)\r\nconnection_id = hdr[0];\r\nif ((hdr[0] == connection_id) && ((hdr[1] & 0x80) == 0)) {\r\n*_slot = slot;\r\nfound = 1;\r\nbreak;\r\n}\r\nidx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);\r\n}\r\nnextslot:\r\nslot = (slot + 1) % ca->slot_count;\r\nslot_count++;\r\n}\r\nca->next_read_slot = slot;\r\nreturn found;\r\n}\r\nstatic ssize_t dvb_ca_en50221_io_read(struct file *file, char __user * buf,\r\nsize_t count, loff_t * ppos)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_ca_private *ca = dvbdev->priv;\r\nint status;\r\nint result = 0;\r\nu8 hdr[2];\r\nint slot;\r\nint connection_id = -1;\r\nsize_t idx, idx2;\r\nint last_fragment = 0;\r\nsize_t fraglen;\r\nint pktlen;\r\nint dispose = 0;\r\ndprintk("%s\n", __func__);\r\nif (count < 2)\r\nreturn -EINVAL;\r\nif ((status = dvb_ca_en50221_io_read_condition(ca, &result, &slot)) == 0) {\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nstatus = wait_event_interruptible(ca->wait_queue,\r\ndvb_ca_en50221_io_read_condition\r\n(ca, &result, &slot));\r\n}\r\nif ((status < 0) || (result < 0)) {\r\nif (result)\r\nreturn result;\r\nreturn status;\r\n}\r\nidx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);\r\npktlen = 2;\r\ndo {\r\nif (idx == -1) {\r\nprintk("dvb_ca adapter %d: BUG: read packet ended before last_fragment encountered\n", ca->dvbdev->adapter->num);\r\nstatus = -EIO;\r\ngoto exit;\r\n}\r\ndvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2);\r\nif (connection_id == -1)\r\nconnection_id = hdr[0];\r\nif (hdr[0] == connection_id) {\r\nif (pktlen < count) {\r\nif ((pktlen + fraglen - 2) > count) {\r\nfraglen = count - pktlen;\r\n} else {\r\nfraglen -= 2;\r\n}\r\nif ((status = dvb_ringbuffer_pkt_read_user(&ca->slot_info[slot].rx_buffer, idx, 2,\r\nbuf + pktlen, fraglen)) < 0) {\r\ngoto exit;\r\n}\r\npktlen += fraglen;\r\n}\r\nif ((hdr[1] & 0x80) == 0)\r\nlast_fragment = 1;\r\ndispose = 1;\r\n}\r\nidx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);\r\nif (dispose)\r\ndvb_ringbuffer_pkt_dispose(&ca->slot_info[slot].rx_buffer, idx);\r\nidx = idx2;\r\ndispose = 0;\r\n} while (!last_fragment);\r\nhdr[0] = slot;\r\nhdr[1] = connection_id;\r\nstatus = copy_to_user(buf, hdr, 2);\r\nif (status) {\r\nstatus = -EFAULT;\r\ngoto exit;\r\n}\r\nstatus = pktlen;\r\nexit:\r\nreturn status;\r\n}\r\nstatic int dvb_ca_en50221_io_open(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_ca_private *ca = dvbdev->priv;\r\nint err;\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif (!try_module_get(ca->pub->owner))\r\nreturn -EIO;\r\nerr = dvb_generic_open(inode, file);\r\nif (err < 0) {\r\nmodule_put(ca->pub->owner);\r\nreturn err;\r\n}\r\nfor (i = 0; i < ca->slot_count; i++) {\r\nif (ca->slot_info[i].slot_state == DVB_CA_SLOTSTATE_RUNNING) {\r\nif (ca->slot_info[i].rx_buffer.data != NULL) {\r\ndvb_ringbuffer_flush(&ca->slot_info[i].rx_buffer);\r\n}\r\n}\r\n}\r\nca->open = 1;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\ndvb_ca_en50221_thread_wakeup(ca);\r\nreturn 0;\r\n}\r\nstatic int dvb_ca_en50221_io_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_ca_private *ca = dvbdev->priv;\r\nint err;\r\ndprintk("%s\n", __func__);\r\nca->open = 0;\r\ndvb_ca_en50221_thread_update_delay(ca);\r\nerr = dvb_generic_release(inode, file);\r\nmodule_put(ca->pub->owner);\r\nreturn err;\r\n}\r\nstatic unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct dvb_device *dvbdev = file->private_data;\r\nstruct dvb_ca_private *ca = dvbdev->priv;\r\nunsigned int mask = 0;\r\nint slot;\r\nint result = 0;\r\ndprintk("%s\n", __func__);\r\nif (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {\r\nmask |= POLLIN;\r\n}\r\nif (mask)\r\nreturn mask;\r\npoll_wait(file, &ca->wait_queue, wait);\r\nif (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {\r\nmask |= POLLIN;\r\n}\r\nreturn mask;\r\n}\r\nint dvb_ca_en50221_init(struct dvb_adapter *dvb_adapter,\r\nstruct dvb_ca_en50221 *pubca, int flags, int slot_count)\r\n{\r\nint ret;\r\nstruct dvb_ca_private *ca = NULL;\r\nint i;\r\ndprintk("%s\n", __func__);\r\nif (slot_count < 1)\r\nreturn -EINVAL;\r\nif ((ca = kzalloc(sizeof(struct dvb_ca_private), GFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nca->pub = pubca;\r\nca->flags = flags;\r\nca->slot_count = slot_count;\r\nif ((ca->slot_info = kcalloc(slot_count, sizeof(struct dvb_ca_slot), GFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ninit_waitqueue_head(&ca->wait_queue);\r\nca->open = 0;\r\nca->wakeup = 0;\r\nca->next_read_slot = 0;\r\npubca->private = ca;\r\nret = dvb_register_device(dvb_adapter, &ca->dvbdev, &dvbdev_ca, ca, DVB_DEVICE_CA);\r\nif (ret)\r\ngoto error;\r\nfor (i = 0; i < slot_count; i++) {\r\nmemset(&ca->slot_info[i], 0, sizeof(struct dvb_ca_slot));\r\nca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;\r\natomic_set(&ca->slot_info[i].camchange_count, 0);\r\nca->slot_info[i].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;\r\nmutex_init(&ca->slot_info[i].slot_lock);\r\n}\r\nif (signal_pending(current)) {\r\nret = -EINTR;\r\ngoto error;\r\n}\r\nmb();\r\nca->thread = kthread_run(dvb_ca_en50221_thread, ca, "kdvb-ca-%i:%i",\r\nca->dvbdev->adapter->num, ca->dvbdev->id);\r\nif (IS_ERR(ca->thread)) {\r\nret = PTR_ERR(ca->thread);\r\nprintk("dvb_ca_init: failed to start kernel_thread (%d)\n",\r\nret);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nif (ca != NULL) {\r\nif (ca->dvbdev != NULL)\r\ndvb_unregister_device(ca->dvbdev);\r\nkfree(ca->slot_info);\r\nkfree(ca);\r\n}\r\npubca->private = NULL;\r\nreturn ret;\r\n}\r\nvoid dvb_ca_en50221_release(struct dvb_ca_en50221 *pubca)\r\n{\r\nstruct dvb_ca_private *ca = pubca->private;\r\nint i;\r\ndprintk("%s\n", __func__);\r\nkthread_stop(ca->thread);\r\nfor (i = 0; i < ca->slot_count; i++) {\r\ndvb_ca_en50221_slot_shutdown(ca, i);\r\nvfree(ca->slot_info[i].rx_buffer.data);\r\n}\r\nkfree(ca->slot_info);\r\ndvb_unregister_device(ca->dvbdev);\r\nkfree(ca);\r\npubca->private = NULL;\r\n}
