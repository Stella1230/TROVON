static void pfc_iounmap(struct pinmux_info *pip)\r\n{\r\nint k;\r\nfor (k = 0; k < pip->num_resources; k++)\r\nif (pip->window[k].virt)\r\niounmap(pip->window[k].virt);\r\nkfree(pip->window);\r\npip->window = NULL;\r\n}\r\nstatic int pfc_ioremap(struct pinmux_info *pip)\r\n{\r\nstruct resource *res;\r\nint k;\r\nif (!pip->num_resources)\r\nreturn 0;\r\npip->window = kzalloc(pip->num_resources * sizeof(*pip->window),\r\nGFP_NOWAIT);\r\nif (!pip->window)\r\ngoto err1;\r\nfor (k = 0; k < pip->num_resources; k++) {\r\nres = pip->resource + k;\r\nWARN_ON(resource_type(res) != IORESOURCE_MEM);\r\npip->window[k].phys = res->start;\r\npip->window[k].size = resource_size(res);\r\npip->window[k].virt = ioremap_nocache(res->start,\r\nresource_size(res));\r\nif (!pip->window[k].virt)\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\npfc_iounmap(pip);\r\nerr1:\r\nreturn -1;\r\n}\r\nstatic void __iomem *pfc_phys_to_virt(struct pinmux_info *pip,\r\nunsigned long address)\r\n{\r\nstruct pfc_window *window;\r\nint k;\r\nfor (k = 0; k < pip->num_resources; k++) {\r\nwindow = pip->window + k;\r\nif (address < window->phys)\r\ncontinue;\r\nif (address >= (window->phys + window->size))\r\ncontinue;\r\nreturn window->virt + (address - window->phys);\r\n}\r\nreturn (void __iomem *)address;\r\n}\r\nstatic int enum_in_range(pinmux_enum_t enum_id, struct pinmux_range *r)\r\n{\r\nif (enum_id < r->begin)\r\nreturn 0;\r\nif (enum_id > r->end)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned long gpio_read_raw_reg(void __iomem *mapped_reg,\r\nunsigned long reg_width)\r\n{\r\nswitch (reg_width) {\r\ncase 8:\r\nreturn ioread8(mapped_reg);\r\ncase 16:\r\nreturn ioread16(mapped_reg);\r\ncase 32:\r\nreturn ioread32(mapped_reg);\r\n}\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic void gpio_write_raw_reg(void __iomem *mapped_reg,\r\nunsigned long reg_width,\r\nunsigned long data)\r\n{\r\nswitch (reg_width) {\r\ncase 8:\r\niowrite8(data, mapped_reg);\r\nreturn;\r\ncase 16:\r\niowrite16(data, mapped_reg);\r\nreturn;\r\ncase 32:\r\niowrite32(data, mapped_reg);\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nstatic int gpio_read_bit(struct pinmux_data_reg *dr,\r\nunsigned long in_pos)\r\n{\r\nunsigned long pos;\r\npos = dr->reg_width - (in_pos + 1);\r\npr_debug("read_bit: addr = %lx, pos = %ld, "\r\n"r_width = %ld\n", dr->reg, pos, dr->reg_width);\r\nreturn (gpio_read_raw_reg(dr->mapped_reg, dr->reg_width) >> pos) & 1;\r\n}\r\nstatic void gpio_write_bit(struct pinmux_data_reg *dr,\r\nunsigned long in_pos, unsigned long value)\r\n{\r\nunsigned long pos;\r\npos = dr->reg_width - (in_pos + 1);\r\npr_debug("write_bit addr = %lx, value = %d, pos = %ld, "\r\n"r_width = %ld\n",\r\ndr->reg, !!value, pos, dr->reg_width);\r\nif (value)\r\nset_bit(pos, &dr->reg_shadow);\r\nelse\r\nclear_bit(pos, &dr->reg_shadow);\r\ngpio_write_raw_reg(dr->mapped_reg, dr->reg_width, dr->reg_shadow);\r\n}\r\nstatic void config_reg_helper(struct pinmux_info *gpioc,\r\nstruct pinmux_cfg_reg *crp,\r\nunsigned long in_pos,\r\nvoid __iomem **mapped_regp,\r\nunsigned long *maskp,\r\nunsigned long *posp)\r\n{\r\nint k;\r\n*mapped_regp = pfc_phys_to_virt(gpioc, crp->reg);\r\nif (crp->field_width) {\r\n*maskp = (1 << crp->field_width) - 1;\r\n*posp = crp->reg_width - ((in_pos + 1) * crp->field_width);\r\n} else {\r\n*maskp = (1 << crp->var_field_width[in_pos]) - 1;\r\n*posp = crp->reg_width;\r\nfor (k = 0; k <= in_pos; k++)\r\n*posp -= crp->var_field_width[k];\r\n}\r\n}\r\nstatic int read_config_reg(struct pinmux_info *gpioc,\r\nstruct pinmux_cfg_reg *crp,\r\nunsigned long field)\r\n{\r\nvoid __iomem *mapped_reg;\r\nunsigned long mask, pos;\r\nconfig_reg_helper(gpioc, crp, field, &mapped_reg, &mask, &pos);\r\npr_debug("read_reg: addr = %lx, field = %ld, "\r\n"r_width = %ld, f_width = %ld\n",\r\ncrp->reg, field, crp->reg_width, crp->field_width);\r\nreturn (gpio_read_raw_reg(mapped_reg, crp->reg_width) >> pos) & mask;\r\n}\r\nstatic void write_config_reg(struct pinmux_info *gpioc,\r\nstruct pinmux_cfg_reg *crp,\r\nunsigned long field, unsigned long value)\r\n{\r\nvoid __iomem *mapped_reg;\r\nunsigned long mask, pos, data;\r\nconfig_reg_helper(gpioc, crp, field, &mapped_reg, &mask, &pos);\r\npr_debug("write_reg addr = %lx, value = %ld, field = %ld, "\r\n"r_width = %ld, f_width = %ld\n",\r\ncrp->reg, value, field, crp->reg_width, crp->field_width);\r\nmask = ~(mask << pos);\r\nvalue = value << pos;\r\ndata = gpio_read_raw_reg(mapped_reg, crp->reg_width);\r\ndata &= mask;\r\ndata |= value;\r\nif (gpioc->unlock_reg)\r\ngpio_write_raw_reg(pfc_phys_to_virt(gpioc, gpioc->unlock_reg),\r\n32, ~data);\r\ngpio_write_raw_reg(mapped_reg, crp->reg_width, data);\r\n}\r\nstatic int setup_data_reg(struct pinmux_info *gpioc, unsigned gpio)\r\n{\r\nstruct pinmux_gpio *gpiop = &gpioc->gpios[gpio];\r\nstruct pinmux_data_reg *data_reg;\r\nint k, n;\r\nif (!enum_in_range(gpiop->enum_id, &gpioc->data))\r\nreturn -1;\r\nk = 0;\r\nwhile (1) {\r\ndata_reg = gpioc->data_regs + k;\r\nif (!data_reg->reg_width)\r\nbreak;\r\ndata_reg->mapped_reg = pfc_phys_to_virt(gpioc, data_reg->reg);\r\nfor (n = 0; n < data_reg->reg_width; n++) {\r\nif (data_reg->enum_ids[n] == gpiop->enum_id) {\r\ngpiop->flags &= ~PINMUX_FLAG_DREG;\r\ngpiop->flags |= (k << PINMUX_FLAG_DREG_SHIFT);\r\ngpiop->flags &= ~PINMUX_FLAG_DBIT;\r\ngpiop->flags |= (n << PINMUX_FLAG_DBIT_SHIFT);\r\nreturn 0;\r\n}\r\n}\r\nk++;\r\n}\r\nBUG();\r\nreturn -1;\r\n}\r\nstatic void setup_data_regs(struct pinmux_info *gpioc)\r\n{\r\nstruct pinmux_data_reg *drp;\r\nint k;\r\nfor (k = gpioc->first_gpio; k <= gpioc->last_gpio; k++)\r\nsetup_data_reg(gpioc, k);\r\nk = 0;\r\nwhile (1) {\r\ndrp = gpioc->data_regs + k;\r\nif (!drp->reg_width)\r\nbreak;\r\ndrp->reg_shadow = gpio_read_raw_reg(drp->mapped_reg,\r\ndrp->reg_width);\r\nk++;\r\n}\r\n}\r\nstatic int get_data_reg(struct pinmux_info *gpioc, unsigned gpio,\r\nstruct pinmux_data_reg **drp, int *bitp)\r\n{\r\nstruct pinmux_gpio *gpiop = &gpioc->gpios[gpio];\r\nint k, n;\r\nif (!enum_in_range(gpiop->enum_id, &gpioc->data))\r\nreturn -1;\r\nk = (gpiop->flags & PINMUX_FLAG_DREG) >> PINMUX_FLAG_DREG_SHIFT;\r\nn = (gpiop->flags & PINMUX_FLAG_DBIT) >> PINMUX_FLAG_DBIT_SHIFT;\r\n*drp = gpioc->data_regs + k;\r\n*bitp = n;\r\nreturn 0;\r\n}\r\nstatic int get_config_reg(struct pinmux_info *gpioc, pinmux_enum_t enum_id,\r\nstruct pinmux_cfg_reg **crp,\r\nint *fieldp, int *valuep,\r\nunsigned long **cntp)\r\n{\r\nstruct pinmux_cfg_reg *config_reg;\r\nunsigned long r_width, f_width, curr_width, ncomb;\r\nint k, m, n, pos, bit_pos;\r\nk = 0;\r\nwhile (1) {\r\nconfig_reg = gpioc->cfg_regs + k;\r\nr_width = config_reg->reg_width;\r\nf_width = config_reg->field_width;\r\nif (!r_width)\r\nbreak;\r\npos = 0;\r\nm = 0;\r\nfor (bit_pos = 0; bit_pos < r_width; bit_pos += curr_width) {\r\nif (f_width)\r\ncurr_width = f_width;\r\nelse\r\ncurr_width = config_reg->var_field_width[m];\r\nncomb = 1 << curr_width;\r\nfor (n = 0; n < ncomb; n++) {\r\nif (config_reg->enum_ids[pos + n] == enum_id) {\r\n*crp = config_reg;\r\n*fieldp = m;\r\n*valuep = n;\r\n*cntp = &config_reg->cnt[m];\r\nreturn 0;\r\n}\r\n}\r\npos += ncomb;\r\nm++;\r\n}\r\nk++;\r\n}\r\nreturn -1;\r\n}\r\nstatic int get_gpio_enum_id(struct pinmux_info *gpioc, unsigned gpio,\r\nint pos, pinmux_enum_t *enum_idp)\r\n{\r\npinmux_enum_t enum_id = gpioc->gpios[gpio].enum_id;\r\npinmux_enum_t *data = gpioc->gpio_data;\r\nint k;\r\nif (!enum_in_range(enum_id, &gpioc->data)) {\r\nif (!enum_in_range(enum_id, &gpioc->mark)) {\r\npr_err("non data/mark enum_id for gpio %d\n", gpio);\r\nreturn -1;\r\n}\r\n}\r\nif (pos) {\r\n*enum_idp = data[pos + 1];\r\nreturn pos + 1;\r\n}\r\nfor (k = 0; k < gpioc->gpio_data_size; k++) {\r\nif (data[k] == enum_id) {\r\n*enum_idp = data[k + 1];\r\nreturn k + 1;\r\n}\r\n}\r\npr_err("cannot locate data/mark enum_id for gpio %d\n", gpio);\r\nreturn -1;\r\n}\r\nstatic int pinmux_config_gpio(struct pinmux_info *gpioc, unsigned gpio,\r\nint pinmux_type, int cfg_mode)\r\n{\r\nstruct pinmux_cfg_reg *cr = NULL;\r\npinmux_enum_t enum_id;\r\nstruct pinmux_range *range;\r\nint in_range, pos, field, value;\r\nunsigned long *cntp;\r\nswitch (pinmux_type) {\r\ncase PINMUX_TYPE_FUNCTION:\r\nrange = NULL;\r\nbreak;\r\ncase PINMUX_TYPE_OUTPUT:\r\nrange = &gpioc->output;\r\nbreak;\r\ncase PINMUX_TYPE_INPUT:\r\nrange = &gpioc->input;\r\nbreak;\r\ncase PINMUX_TYPE_INPUT_PULLUP:\r\nrange = &gpioc->input_pu;\r\nbreak;\r\ncase PINMUX_TYPE_INPUT_PULLDOWN:\r\nrange = &gpioc->input_pd;\r\nbreak;\r\ndefault:\r\ngoto out_err;\r\n}\r\npos = 0;\r\nenum_id = 0;\r\nfield = 0;\r\nvalue = 0;\r\nwhile (1) {\r\npos = get_gpio_enum_id(gpioc, gpio, pos, &enum_id);\r\nif (pos <= 0)\r\ngoto out_err;\r\nif (!enum_id)\r\nbreak;\r\nin_range = enum_in_range(enum_id, &gpioc->function);\r\nif (!in_range) {\r\nif (range) {\r\nin_range = enum_in_range(enum_id, range);\r\nif (in_range && enum_id == range->force)\r\ncontinue;\r\n} else {\r\nin_range = 1;\r\n}\r\n}\r\nif (!in_range)\r\ncontinue;\r\nif (get_config_reg(gpioc, enum_id, &cr,\r\n&field, &value, &cntp) != 0)\r\ngoto out_err;\r\nswitch (cfg_mode) {\r\ncase GPIO_CFG_DRYRUN:\r\nif (!*cntp ||\r\n(read_config_reg(gpioc, cr, field) != value))\r\ncontinue;\r\nbreak;\r\ncase GPIO_CFG_REQ:\r\nwrite_config_reg(gpioc, cr, field, value);\r\n*cntp = *cntp + 1;\r\nbreak;\r\ncase GPIO_CFG_FREE:\r\n*cntp = *cntp - 1;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\nreturn -1;\r\n}\r\nstatic struct pinmux_info *chip_to_pinmux(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct pinmux_info, chip);\r\n}\r\nstatic int sh_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pinmux_info *gpioc = chip_to_pinmux(chip);\r\nstruct pinmux_data_reg *dummy;\r\nunsigned long flags;\r\nint i, ret, pinmux_type;\r\nret = -EINVAL;\r\nif (!gpioc)\r\ngoto err_out;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif ((gpioc->gpios[offset].flags & PINMUX_FLAG_TYPE) != PINMUX_TYPE_NONE)\r\ngoto err_unlock;\r\nif (get_data_reg(gpioc, offset, &dummy, &i) != 0)\r\npinmux_type = PINMUX_TYPE_FUNCTION;\r\nelse\r\npinmux_type = PINMUX_TYPE_GPIO;\r\nif (pinmux_type == PINMUX_TYPE_FUNCTION) {\r\nif (pinmux_config_gpio(gpioc, offset,\r\npinmux_type,\r\nGPIO_CFG_DRYRUN) != 0)\r\ngoto err_unlock;\r\nif (pinmux_config_gpio(gpioc, offset,\r\npinmux_type,\r\nGPIO_CFG_REQ) != 0)\r\nBUG();\r\n}\r\ngpioc->gpios[offset].flags &= ~PINMUX_FLAG_TYPE;\r\ngpioc->gpios[offset].flags |= pinmux_type;\r\nret = 0;\r\nerr_unlock:\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void sh_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pinmux_info *gpioc = chip_to_pinmux(chip);\r\nunsigned long flags;\r\nint pinmux_type;\r\nif (!gpioc)\r\nreturn;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\npinmux_type = gpioc->gpios[offset].flags & PINMUX_FLAG_TYPE;\r\npinmux_config_gpio(gpioc, offset, pinmux_type, GPIO_CFG_FREE);\r\ngpioc->gpios[offset].flags &= ~PINMUX_FLAG_TYPE;\r\ngpioc->gpios[offset].flags |= PINMUX_TYPE_NONE;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\n}\r\nstatic int pinmux_direction(struct pinmux_info *gpioc,\r\nunsigned gpio, int new_pinmux_type)\r\n{\r\nint pinmux_type;\r\nint ret = -EINVAL;\r\nif (!gpioc)\r\ngoto err_out;\r\npinmux_type = gpioc->gpios[gpio].flags & PINMUX_FLAG_TYPE;\r\nswitch (pinmux_type) {\r\ncase PINMUX_TYPE_GPIO:\r\nbreak;\r\ncase PINMUX_TYPE_OUTPUT:\r\ncase PINMUX_TYPE_INPUT:\r\ncase PINMUX_TYPE_INPUT_PULLUP:\r\ncase PINMUX_TYPE_INPUT_PULLDOWN:\r\npinmux_config_gpio(gpioc, gpio, pinmux_type, GPIO_CFG_FREE);\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\nif (pinmux_config_gpio(gpioc, gpio,\r\nnew_pinmux_type,\r\nGPIO_CFG_DRYRUN) != 0)\r\ngoto err_out;\r\nif (pinmux_config_gpio(gpioc, gpio,\r\nnew_pinmux_type,\r\nGPIO_CFG_REQ) != 0)\r\nBUG();\r\ngpioc->gpios[gpio].flags &= ~PINMUX_FLAG_TYPE;\r\ngpioc->gpios[gpio].flags |= new_pinmux_type;\r\nret = 0;\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int sh_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pinmux_info *gpioc = chip_to_pinmux(chip);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nret = pinmux_direction(gpioc, offset, PINMUX_TYPE_INPUT);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void sh_gpio_set_value(struct pinmux_info *gpioc,\r\nunsigned gpio, int value)\r\n{\r\nstruct pinmux_data_reg *dr = NULL;\r\nint bit = 0;\r\nif (!gpioc || get_data_reg(gpioc, gpio, &dr, &bit) != 0)\r\nBUG();\r\nelse\r\ngpio_write_bit(dr, bit, value);\r\n}\r\nstatic int sh_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct pinmux_info *gpioc = chip_to_pinmux(chip);\r\nunsigned long flags;\r\nint ret;\r\nsh_gpio_set_value(gpioc, offset, value);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nret = pinmux_direction(gpioc, offset, PINMUX_TYPE_OUTPUT);\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int sh_gpio_get_value(struct pinmux_info *gpioc, unsigned gpio)\r\n{\r\nstruct pinmux_data_reg *dr = NULL;\r\nint bit = 0;\r\nif (!gpioc || get_data_reg(gpioc, gpio, &dr, &bit) != 0)\r\nreturn -EINVAL;\r\nreturn gpio_read_bit(dr, bit);\r\n}\r\nstatic int sh_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn sh_gpio_get_value(chip_to_pinmux(chip), offset);\r\n}\r\nstatic void sh_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nsh_gpio_set_value(chip_to_pinmux(chip), offset, value);\r\n}\r\nstatic int sh_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pinmux_info *gpioc = chip_to_pinmux(chip);\r\npinmux_enum_t enum_id;\r\npinmux_enum_t *enum_ids;\r\nint i, k, pos;\r\npos = 0;\r\nenum_id = 0;\r\nwhile (1) {\r\npos = get_gpio_enum_id(gpioc, offset, pos, &enum_id);\r\nif (pos <= 0 || !enum_id)\r\nbreak;\r\nfor (i = 0; i < gpioc->gpio_irq_size; i++) {\r\nenum_ids = gpioc->gpio_irq[i].enum_ids;\r\nfor (k = 0; enum_ids[k]; k++) {\r\nif (enum_ids[k] == enum_id)\r\nreturn gpioc->gpio_irq[i].irq;\r\n}\r\n}\r\n}\r\nreturn -ENOSYS;\r\n}\r\nint register_pinmux(struct pinmux_info *pip)\r\n{\r\nstruct gpio_chip *chip = &pip->chip;\r\nint ret;\r\npr_info("%s handling gpio %d -> %d\n",\r\npip->name, pip->first_gpio, pip->last_gpio);\r\nret = pfc_ioremap(pip);\r\nif (ret < 0)\r\nreturn ret;\r\nsetup_data_regs(pip);\r\nchip->request = sh_gpio_request;\r\nchip->free = sh_gpio_free;\r\nchip->direction_input = sh_gpio_direction_input;\r\nchip->get = sh_gpio_get;\r\nchip->direction_output = sh_gpio_direction_output;\r\nchip->set = sh_gpio_set;\r\nchip->to_irq = sh_gpio_to_irq;\r\nWARN_ON(pip->first_gpio != 0);\r\nchip->label = pip->name;\r\nchip->owner = THIS_MODULE;\r\nchip->base = pip->first_gpio;\r\nchip->ngpio = (pip->last_gpio - pip->first_gpio) + 1;\r\nret = gpiochip_add(chip);\r\nif (ret < 0)\r\npfc_iounmap(pip);\r\nreturn ret;\r\n}\r\nint unregister_pinmux(struct pinmux_info *pip)\r\n{\r\npr_info("%s deregistering\n", pip->name);\r\npfc_iounmap(pip);\r\nreturn gpiochip_remove(&pip->chip);\r\n}
