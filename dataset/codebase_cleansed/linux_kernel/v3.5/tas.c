static struct tas *codec_to_tas(struct aoa_codec *codec)\r\n{\r\nreturn container_of(codec, struct tas, codec);\r\n}\r\nstatic inline int tas_write_reg(struct tas *tas, u8 reg, u8 len, u8 *data)\r\n{\r\nif (len == 1)\r\nreturn i2c_smbus_write_byte_data(tas->i2c, reg, *data);\r\nelse\r\nreturn i2c_smbus_write_i2c_block_data(tas->i2c, reg, len, data);\r\n}\r\nstatic void tas3004_set_drc(struct tas *tas)\r\n{\r\nunsigned char val[6];\r\nif (tas->drc_enabled)\r\nval[0] = 0x50;\r\nelse\r\nval[0] = 0x51;\r\nval[1] = 0x02;\r\nif (tas->drc_range > 0xef)\r\nval[2] = 0xef;\r\nelse if (tas->drc_range < 0)\r\nval[2] = 0x00;\r\nelse\r\nval[2] = tas->drc_range;\r\nval[3] = 0xb0;\r\nval[4] = 0x60;\r\nval[5] = 0xa0;\r\ntas_write_reg(tas, TAS_REG_DRC, 6, val);\r\n}\r\nstatic void tas_set_treble(struct tas *tas)\r\n{\r\nu8 tmp;\r\ntmp = tas3004_treble(tas->treble);\r\ntas_write_reg(tas, TAS_REG_TREBLE, 1, &tmp);\r\n}\r\nstatic void tas_set_bass(struct tas *tas)\r\n{\r\nu8 tmp;\r\ntmp = tas3004_bass(tas->bass);\r\ntas_write_reg(tas, TAS_REG_BASS, 1, &tmp);\r\n}\r\nstatic void tas_set_volume(struct tas *tas)\r\n{\r\nu8 block[6];\r\nint tmp;\r\nu8 left, right;\r\nleft = tas->cached_volume_l;\r\nright = tas->cached_volume_r;\r\nif (left > 177) left = 177;\r\nif (right > 177) right = 177;\r\nif (tas->mute_l) left = 0;\r\nif (tas->mute_r) right = 0;\r\ntmp = tas_gaintable[left];\r\nblock[0] = tmp>>20;\r\nblock[1] = tmp>>12;\r\nblock[2] = tmp>>4;\r\ntmp = tas_gaintable[right];\r\nblock[3] = tmp>>20;\r\nblock[4] = tmp>>12;\r\nblock[5] = tmp>>4;\r\ntas_write_reg(tas, TAS_REG_VOL, 6, block);\r\n}\r\nstatic void tas_set_mixer(struct tas *tas)\r\n{\r\nu8 block[9];\r\nint tmp, i;\r\nu8 val;\r\nfor (i=0;i<3;i++) {\r\nval = tas->mixer_l[i];\r\nif (val > 177) val = 177;\r\ntmp = tas_gaintable[val];\r\nblock[3*i+0] = tmp>>16;\r\nblock[3*i+1] = tmp>>8;\r\nblock[3*i+2] = tmp;\r\n}\r\ntas_write_reg(tas, TAS_REG_LMIX, 9, block);\r\nfor (i=0;i<3;i++) {\r\nval = tas->mixer_r[i];\r\nif (val > 177) val = 177;\r\ntmp = tas_gaintable[val];\r\nblock[3*i+0] = tmp>>16;\r\nblock[3*i+1] = tmp>>8;\r\nblock[3*i+2] = tmp;\r\n}\r\ntas_write_reg(tas, TAS_REG_RMIX, 9, block);\r\n}\r\nstatic int tas_dev_register(struct snd_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tas_snd_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 177;\r\nreturn 0;\r\n}\r\nstatic int tas_snd_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = tas->cached_volume_l;\r\nucontrol->value.integer.value[1] = tas->cached_volume_r;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] > 177)\r\nreturn -EINVAL;\r\nif (ucontrol->value.integer.value[1] < 0 ||\r\nucontrol->value.integer.value[1] > 177)\r\nreturn -EINVAL;\r\nmutex_lock(&tas->mtx);\r\nif (tas->cached_volume_l == ucontrol->value.integer.value[0]\r\n&& tas->cached_volume_r == ucontrol->value.integer.value[1]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->cached_volume_l = ucontrol->value.integer.value[0];\r\ntas->cached_volume_r = ucontrol->value.integer.value[1];\r\nif (tas->hw_enabled)\r\ntas_set_volume(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = !tas->mute_l;\r\nucontrol->value.integer.value[1] = !tas->mute_r;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nif (tas->mute_l == !ucontrol->value.integer.value[0]\r\n&& tas->mute_r == !ucontrol->value.integer.value[1]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->mute_l = !ucontrol->value.integer.value[0];\r\ntas->mute_r = !ucontrol->value.integer.value[1];\r\nif (tas->hw_enabled)\r\ntas_set_volume(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_mixer_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 177;\r\nreturn 0;\r\n}\r\nstatic int tas_snd_mixer_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = tas->mixer_l[idx];\r\nucontrol->value.integer.value[1] = tas->mixer_r[idx];\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_mixer_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nmutex_lock(&tas->mtx);\r\nif (tas->mixer_l[idx] == ucontrol->value.integer.value[0]\r\n&& tas->mixer_r[idx] == ucontrol->value.integer.value[1]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->mixer_l[idx] = ucontrol->value.integer.value[0];\r\ntas->mixer_r[idx] = ucontrol->value.integer.value[1];\r\nif (tas->hw_enabled)\r\ntas_set_mixer(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_drc_range_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = TAS3004_DRC_MAX;\r\nreturn 0;\r\n}\r\nstatic int tas_snd_drc_range_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = tas->drc_range;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_drc_range_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] > TAS3004_DRC_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&tas->mtx);\r\nif (tas->drc_range == ucontrol->value.integer.value[0]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->drc_range = ucontrol->value.integer.value[0];\r\nif (tas->hw_enabled)\r\ntas3004_set_drc(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_drc_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = tas->drc_enabled;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_drc_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nif (tas->drc_enabled == ucontrol->value.integer.value[0]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->drc_enabled = !!ucontrol->value.integer.value[0];\r\nif (tas->hw_enabled)\r\ntas3004_set_drc(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "Line-In", "Microphone" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item > 1)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.enumerated.item[0] = !!(tas->acr & TAS_ACR_INPUT_B);\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nint oldacr;\r\nif (ucontrol->value.enumerated.item[0] > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&tas->mtx);\r\noldacr = tas->acr;\r\ntas->acr &= ~(TAS_ACR_INPUT_B | TAS_ACR_B_MONAUREAL);\r\nif (ucontrol->value.enumerated.item[0])\r\ntas->acr |= TAS_ACR_INPUT_B | TAS_ACR_B_MONAUREAL |\r\nTAS_ACR_B_MON_SEL_RIGHT;\r\nif (oldacr == tas->acr) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nif (tas->hw_enabled)\r\ntas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_treble_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = TAS3004_TREBLE_MIN;\r\nuinfo->value.integer.max = TAS3004_TREBLE_MAX;\r\nreturn 0;\r\n}\r\nstatic int tas_snd_treble_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = tas->treble;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_treble_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] < TAS3004_TREBLE_MIN ||\r\nucontrol->value.integer.value[0] > TAS3004_TREBLE_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&tas->mtx);\r\nif (tas->treble == ucontrol->value.integer.value[0]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->treble = ucontrol->value.integer.value[0];\r\nif (tas->hw_enabled)\r\ntas_set_treble(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_snd_bass_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = TAS3004_BASS_MIN;\r\nuinfo->value.integer.max = TAS3004_BASS_MAX;\r\nreturn 0;\r\n}\r\nstatic int tas_snd_bass_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&tas->mtx);\r\nucontrol->value.integer.value[0] = tas->bass;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_snd_bass_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct tas *tas = snd_kcontrol_chip(kcontrol);\r\nif (ucontrol->value.integer.value[0] < TAS3004_BASS_MIN ||\r\nucontrol->value.integer.value[0] > TAS3004_BASS_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&tas->mtx);\r\nif (tas->bass == ucontrol->value.integer.value[0]) {\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\ntas->bass = ucontrol->value.integer.value[0];\r\nif (tas->hw_enabled)\r\ntas_set_bass(tas);\r\nmutex_unlock(&tas->mtx);\r\nreturn 1;\r\n}\r\nstatic int tas_usable(struct codec_info_item *cii,\r\nstruct transfer_info *ti,\r\nstruct transfer_info *out)\r\n{\r\nreturn 1;\r\n}\r\nstatic int tas_reset_init(struct tas *tas)\r\n{\r\nu8 tmp;\r\ntas->codec.gpio->methods->all_amps_off(tas->codec.gpio);\r\nmsleep(5);\r\ntas->codec.gpio->methods->set_hw_reset(tas->codec.gpio, 0);\r\nmsleep(5);\r\ntas->codec.gpio->methods->set_hw_reset(tas->codec.gpio, 1);\r\nmsleep(20);\r\ntas->codec.gpio->methods->set_hw_reset(tas->codec.gpio, 0);\r\nmsleep(10);\r\ntas->codec.gpio->methods->all_amps_restore(tas->codec.gpio);\r\ntmp = TAS_MCS_SCLK64 | TAS_MCS_SPORT_MODE_I2S | TAS_MCS_SPORT_WL_24BIT;\r\nif (tas_write_reg(tas, TAS_REG_MCS, 1, &tmp))\r\ngoto outerr;\r\ntas->acr |= TAS_ACR_ANALOG_PDOWN;\r\nif (tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr))\r\ngoto outerr;\r\ntmp = 0;\r\nif (tas_write_reg(tas, TAS_REG_MCS2, 1, &tmp))\r\ngoto outerr;\r\ntas3004_set_drc(tas);\r\ntas->treble = TAS3004_TREBLE_ZERO;\r\ntas->bass = TAS3004_BASS_ZERO;\r\ntas_set_treble(tas);\r\ntas_set_bass(tas);\r\ntas->acr &= ~TAS_ACR_ANALOG_PDOWN;\r\nif (tas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr))\r\ngoto outerr;\r\nreturn 0;\r\nouterr:\r\nreturn -ENODEV;\r\n}\r\nstatic int tas_switch_clock(struct codec_info_item *cii, enum clock_switch clock)\r\n{\r\nstruct tas *tas = cii->codec_data;\r\nswitch(clock) {\r\ncase CLOCK_SWITCH_PREPARE_SLAVE:\r\ntas->codec.gpio->methods->all_amps_off(tas->codec.gpio);\r\ntas->hw_enabled = 0;\r\nbreak;\r\ncase CLOCK_SWITCH_SLAVE:\r\nmutex_lock(&tas->mtx);\r\ntas_reset_init(tas);\r\ntas_set_volume(tas);\r\ntas_set_mixer(tas);\r\ntas->hw_enabled = 1;\r\ntas->codec.gpio->methods->all_amps_restore(tas->codec.gpio);\r\nmutex_unlock(&tas->mtx);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas_suspend(struct tas *tas)\r\n{\r\nmutex_lock(&tas->mtx);\r\ntas->hw_enabled = 0;\r\ntas->acr |= TAS_ACR_ANALOG_PDOWN;\r\ntas_write_reg(tas, TAS_REG_ACR, 1, &tas->acr);\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int tas_resume(struct tas *tas)\r\n{\r\nmutex_lock(&tas->mtx);\r\ntas_reset_init(tas);\r\ntas_set_volume(tas);\r\ntas_set_mixer(tas);\r\ntas->hw_enabled = 1;\r\nmutex_unlock(&tas->mtx);\r\nreturn 0;\r\n}\r\nstatic int _tas_suspend(struct codec_info_item *cii, pm_message_t state)\r\n{\r\nreturn tas_suspend(cii->codec_data);\r\n}\r\nstatic int _tas_resume(struct codec_info_item *cii)\r\n{\r\nreturn tas_resume(cii->codec_data);\r\n}\r\nstatic int tas_init_codec(struct aoa_codec *codec)\r\n{\r\nstruct tas *tas = codec_to_tas(codec);\r\nint err;\r\nif (!tas->codec.gpio || !tas->codec.gpio->methods) {\r\nprintk(KERN_ERR PFX "gpios not assigned!!\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&tas->mtx);\r\nif (tas_reset_init(tas)) {\r\nprintk(KERN_ERR PFX "tas failed to initialise\n");\r\nmutex_unlock(&tas->mtx);\r\nreturn -ENXIO;\r\n}\r\ntas->hw_enabled = 1;\r\nmutex_unlock(&tas->mtx);\r\nif (tas->codec.soundbus_dev->attach_codec(tas->codec.soundbus_dev,\r\naoa_get_card(),\r\n&tas_codec_info, tas)) {\r\nprintk(KERN_ERR PFX "error attaching tas to soundbus\n");\r\nreturn -ENODEV;\r\n}\r\nif (aoa_snd_device_new(SNDRV_DEV_LOWLEVEL, tas, &ops)) {\r\nprintk(KERN_ERR PFX "failed to create tas snd device!\n");\r\nreturn -ENODEV;\r\n}\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&volume_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&mute_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&pcm1_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&monitor_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&capture_source_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&drc_range_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&drc_switch_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&treble_control, tas));\r\nif (err)\r\ngoto error;\r\nerr = aoa_snd_ctl_add(snd_ctl_new1(&bass_control, tas));\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\ntas->codec.soundbus_dev->detach_codec(tas->codec.soundbus_dev, tas);\r\nsnd_device_free(aoa_get_card(), tas);\r\nreturn err;\r\n}\r\nstatic void tas_exit_codec(struct aoa_codec *codec)\r\n{\r\nstruct tas *tas = codec_to_tas(codec);\r\nif (!tas->codec.soundbus_dev)\r\nreturn;\r\ntas->codec.soundbus_dev->detach_codec(tas->codec.soundbus_dev, tas);\r\n}\r\nstatic int tas_create(struct i2c_adapter *adapter,\r\nstruct device_node *node,\r\nint addr)\r\n{\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "aoa_codec_tas", I2C_NAME_SIZE);\r\ninfo.addr = addr;\r\ninfo.platform_data = node;\r\nclient = i2c_new_device(adapter, &info);\r\nif (!client)\r\nreturn -ENODEV;\r\nif (!client->driver) {\r\ni2c_unregister_device(client);\r\nreturn -ENODEV;\r\n}\r\nlist_add_tail(&client->detected, &client->driver->clients);\r\nreturn 0;\r\n}\r\nstatic int tas_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *node = client->dev.platform_data;\r\nstruct tas *tas;\r\ntas = kzalloc(sizeof(struct tas), GFP_KERNEL);\r\nif (!tas)\r\nreturn -ENOMEM;\r\nmutex_init(&tas->mtx);\r\ntas->i2c = client;\r\ni2c_set_clientdata(client, tas);\r\ntas->drc_range = TAS3004_DRC_MAX / 2;\r\nstrlcpy(tas->codec.name, "tas", MAX_CODEC_NAME_LEN);\r\ntas->codec.owner = THIS_MODULE;\r\ntas->codec.init = tas_init_codec;\r\ntas->codec.exit = tas_exit_codec;\r\ntas->codec.node = of_node_get(node);\r\nif (aoa_codec_register(&tas->codec)) {\r\ngoto fail;\r\n}\r\nprintk(KERN_DEBUG\r\n"snd-aoa-codec-tas: tas found, addr 0x%02x on %s\n",\r\n(unsigned int)client->addr, node->full_name);\r\nreturn 0;\r\nfail:\r\nmutex_destroy(&tas->mtx);\r\nkfree(tas);\r\nreturn -EINVAL;\r\n}\r\nstatic int tas_i2c_attach(struct i2c_adapter *adapter)\r\n{\r\nstruct device_node *busnode, *dev = NULL;\r\nstruct pmac_i2c_bus *bus;\r\nbus = pmac_i2c_adapter_to_bus(adapter);\r\nif (bus == NULL)\r\nreturn -ENODEV;\r\nbusnode = pmac_i2c_get_bus_node(bus);\r\nwhile ((dev = of_get_next_child(busnode, dev)) != NULL) {\r\nif (of_device_is_compatible(dev, "tas3004")) {\r\nconst u32 *addr;\r\nprintk(KERN_DEBUG PFX "found tas3004\n");\r\naddr = of_get_property(dev, "reg", NULL);\r\nif (!addr)\r\ncontinue;\r\nreturn tas_create(adapter, dev, ((*addr) >> 1) & 0x7f);\r\n}\r\nif (strcmp(dev->name, "deq") == 0) {\r\nconst u32 *_addr;\r\nu32 addr;\r\nprintk(KERN_DEBUG PFX "found 'deq' node\n");\r\n_addr = of_get_property(dev, "i2c-address", NULL);\r\nif (!_addr)\r\ncontinue;\r\naddr = ((*_addr) >> 1) & 0x7f;\r\nif (addr != 0x34 && addr != 0x35)\r\ncontinue;\r\nreturn tas_create(adapter, dev, addr);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int tas_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct tas *tas = i2c_get_clientdata(client);\r\nu8 tmp = TAS_ACR_ANALOG_PDOWN;\r\naoa_codec_unregister(&tas->codec);\r\nof_node_put(tas->codec.node);\r\ntas_write_reg(tas, TAS_REG_ACR, 1, &tmp);\r\nmutex_destroy(&tas->mtx);\r\nkfree(tas);\r\nreturn 0;\r\n}
