void ax25_rt_device_down(struct net_device *dev)\r\n{\r\nax25_route *s, *t, *ax25_rt;\r\nwrite_lock_bh(&ax25_route_lock);\r\nax25_rt = ax25_route_list;\r\nwhile (ax25_rt != NULL) {\r\ns = ax25_rt;\r\nax25_rt = ax25_rt->next;\r\nif (s->dev == dev) {\r\nif (ax25_route_list == s) {\r\nax25_route_list = s->next;\r\nkfree(s->digipeat);\r\nkfree(s);\r\n} else {\r\nfor (t = ax25_route_list; t != NULL; t = t->next) {\r\nif (t->next == s) {\r\nt->next = s->next;\r\nkfree(s->digipeat);\r\nkfree(s);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nwrite_unlock_bh(&ax25_route_lock);\r\n}\r\nstatic int __must_check ax25_rt_add(struct ax25_routes_struct *route)\r\n{\r\nax25_route *ax25_rt;\r\nax25_dev *ax25_dev;\r\nint i;\r\nif ((ax25_dev = ax25_addr_ax25dev(&route->port_addr)) == NULL)\r\nreturn -EINVAL;\r\nif (route->digi_count > AX25_MAX_DIGIS)\r\nreturn -EINVAL;\r\nwrite_lock_bh(&ax25_route_lock);\r\nax25_rt = ax25_route_list;\r\nwhile (ax25_rt != NULL) {\r\nif (ax25cmp(&ax25_rt->callsign, &route->dest_addr) == 0 &&\r\nax25_rt->dev == ax25_dev->dev) {\r\nkfree(ax25_rt->digipeat);\r\nax25_rt->digipeat = NULL;\r\nif (route->digi_count != 0) {\r\nif ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {\r\nwrite_unlock_bh(&ax25_route_lock);\r\nreturn -ENOMEM;\r\n}\r\nax25_rt->digipeat->lastrepeat = -1;\r\nax25_rt->digipeat->ndigi = route->digi_count;\r\nfor (i = 0; i < route->digi_count; i++) {\r\nax25_rt->digipeat->repeated[i] = 0;\r\nax25_rt->digipeat->calls[i] = route->digi_addr[i];\r\n}\r\n}\r\nwrite_unlock_bh(&ax25_route_lock);\r\nreturn 0;\r\n}\r\nax25_rt = ax25_rt->next;\r\n}\r\nif ((ax25_rt = kmalloc(sizeof(ax25_route), GFP_ATOMIC)) == NULL) {\r\nwrite_unlock_bh(&ax25_route_lock);\r\nreturn -ENOMEM;\r\n}\r\natomic_set(&ax25_rt->refcount, 1);\r\nax25_rt->callsign = route->dest_addr;\r\nax25_rt->dev = ax25_dev->dev;\r\nax25_rt->digipeat = NULL;\r\nax25_rt->ip_mode = ' ';\r\nif (route->digi_count != 0) {\r\nif ((ax25_rt->digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {\r\nwrite_unlock_bh(&ax25_route_lock);\r\nkfree(ax25_rt);\r\nreturn -ENOMEM;\r\n}\r\nax25_rt->digipeat->lastrepeat = -1;\r\nax25_rt->digipeat->ndigi = route->digi_count;\r\nfor (i = 0; i < route->digi_count; i++) {\r\nax25_rt->digipeat->repeated[i] = 0;\r\nax25_rt->digipeat->calls[i] = route->digi_addr[i];\r\n}\r\n}\r\nax25_rt->next = ax25_route_list;\r\nax25_route_list = ax25_rt;\r\nwrite_unlock_bh(&ax25_route_lock);\r\nreturn 0;\r\n}\r\nvoid __ax25_put_route(ax25_route *ax25_rt)\r\n{\r\nkfree(ax25_rt->digipeat);\r\nkfree(ax25_rt);\r\n}\r\nstatic int ax25_rt_del(struct ax25_routes_struct *route)\r\n{\r\nax25_route *s, *t, *ax25_rt;\r\nax25_dev *ax25_dev;\r\nif ((ax25_dev = ax25_addr_ax25dev(&route->port_addr)) == NULL)\r\nreturn -EINVAL;\r\nwrite_lock_bh(&ax25_route_lock);\r\nax25_rt = ax25_route_list;\r\nwhile (ax25_rt != NULL) {\r\ns = ax25_rt;\r\nax25_rt = ax25_rt->next;\r\nif (s->dev == ax25_dev->dev &&\r\nax25cmp(&route->dest_addr, &s->callsign) == 0) {\r\nif (ax25_route_list == s) {\r\nax25_route_list = s->next;\r\nax25_put_route(s);\r\n} else {\r\nfor (t = ax25_route_list; t != NULL; t = t->next) {\r\nif (t->next == s) {\r\nt->next = s->next;\r\nax25_put_route(s);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nwrite_unlock_bh(&ax25_route_lock);\r\nreturn 0;\r\n}\r\nstatic int ax25_rt_opt(struct ax25_route_opt_struct *rt_option)\r\n{\r\nax25_route *ax25_rt;\r\nax25_dev *ax25_dev;\r\nint err = 0;\r\nif ((ax25_dev = ax25_addr_ax25dev(&rt_option->port_addr)) == NULL)\r\nreturn -EINVAL;\r\nwrite_lock_bh(&ax25_route_lock);\r\nax25_rt = ax25_route_list;\r\nwhile (ax25_rt != NULL) {\r\nif (ax25_rt->dev == ax25_dev->dev &&\r\nax25cmp(&rt_option->dest_addr, &ax25_rt->callsign) == 0) {\r\nswitch (rt_option->cmd) {\r\ncase AX25_SET_RT_IPMODE:\r\nswitch (rt_option->arg) {\r\ncase ' ':\r\ncase 'D':\r\ncase 'V':\r\nax25_rt->ip_mode = rt_option->arg;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nax25_rt = ax25_rt->next;\r\n}\r\nout:\r\nwrite_unlock_bh(&ax25_route_lock);\r\nreturn err;\r\n}\r\nint ax25_rt_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct ax25_route_opt_struct rt_option;\r\nstruct ax25_routes_struct route;\r\nswitch (cmd) {\r\ncase SIOCADDRT:\r\nif (copy_from_user(&route, arg, sizeof(route)))\r\nreturn -EFAULT;\r\nreturn ax25_rt_add(&route);\r\ncase SIOCDELRT:\r\nif (copy_from_user(&route, arg, sizeof(route)))\r\nreturn -EFAULT;\r\nreturn ax25_rt_del(&route);\r\ncase SIOCAX25OPTRT:\r\nif (copy_from_user(&rt_option, arg, sizeof(rt_option)))\r\nreturn -EFAULT;\r\nreturn ax25_rt_opt(&rt_option);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void *ax25_rt_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(ax25_route_lock)\r\n{\r\nstruct ax25_route *ax25_rt;\r\nint i = 1;\r\nread_lock(&ax25_route_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (ax25_rt = ax25_route_list; ax25_rt != NULL; ax25_rt = ax25_rt->next) {\r\nif (i == *pos)\r\nreturn ax25_rt;\r\n++i;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ax25_rt_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (v == SEQ_START_TOKEN) ? ax25_route_list :\r\n((struct ax25_route *) v)->next;\r\n}\r\nstatic void ax25_rt_seq_stop(struct seq_file *seq, void *v)\r\n__releases(ax25_route_lock)\r\n{\r\nread_unlock(&ax25_route_lock);\r\n}\r\nstatic int ax25_rt_seq_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11];\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "callsign dev mode digipeaters\n");\r\nelse {\r\nstruct ax25_route *ax25_rt = v;\r\nconst char *callsign;\r\nint i;\r\nif (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0)\r\ncallsign = "default";\r\nelse\r\ncallsign = ax2asc(buf, &ax25_rt->callsign);\r\nseq_printf(seq, "%-9s %-4s",\r\ncallsign,\r\nax25_rt->dev ? ax25_rt->dev->name : "???");\r\nswitch (ax25_rt->ip_mode) {\r\ncase 'V':\r\nseq_puts(seq, " vc");\r\nbreak;\r\ncase 'D':\r\nseq_puts(seq, " dg");\r\nbreak;\r\ndefault:\r\nseq_puts(seq, " *");\r\nbreak;\r\n}\r\nif (ax25_rt->digipeat != NULL)\r\nfor (i = 0; i < ax25_rt->digipeat->ndigi; i++)\r\nseq_printf(seq, " %s",\r\nax2asc(buf, &ax25_rt->digipeat->calls[i]));\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ax25_rt_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ax25_rt_seqops);\r\n}\r\nax25_route *ax25_get_route(ax25_address *addr, struct net_device *dev)\r\n{\r\nax25_route *ax25_spe_rt = NULL;\r\nax25_route *ax25_def_rt = NULL;\r\nax25_route *ax25_rt;\r\nread_lock(&ax25_route_lock);\r\nfor (ax25_rt = ax25_route_list; ax25_rt != NULL; ax25_rt = ax25_rt->next) {\r\nif (dev == NULL) {\r\nif (ax25cmp(&ax25_rt->callsign, addr) == 0 && ax25_rt->dev != NULL)\r\nax25_spe_rt = ax25_rt;\r\nif (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0 && ax25_rt->dev != NULL)\r\nax25_def_rt = ax25_rt;\r\n} else {\r\nif (ax25cmp(&ax25_rt->callsign, addr) == 0 && ax25_rt->dev == dev)\r\nax25_spe_rt = ax25_rt;\r\nif (ax25cmp(&ax25_rt->callsign, &null_ax25_address) == 0 && ax25_rt->dev == dev)\r\nax25_def_rt = ax25_rt;\r\n}\r\n}\r\nax25_rt = ax25_def_rt;\r\nif (ax25_spe_rt != NULL)\r\nax25_rt = ax25_spe_rt;\r\nif (ax25_rt != NULL)\r\nax25_hold_route(ax25_rt);\r\nread_unlock(&ax25_route_lock);\r\nreturn ax25_rt;\r\n}\r\nstatic inline void ax25_adjust_path(ax25_address *addr, ax25_digi *digipeat)\r\n{\r\nint k;\r\nfor (k = 0; k < digipeat->ndigi; k++) {\r\nif (ax25cmp(addr, &digipeat->calls[k]) == 0)\r\nbreak;\r\n}\r\ndigipeat->ndigi = k;\r\n}\r\nint ax25_rt_autobind(ax25_cb *ax25, ax25_address *addr)\r\n{\r\nax25_uid_assoc *user;\r\nax25_route *ax25_rt;\r\nint err = 0;\r\nif ((ax25_rt = ax25_get_route(addr, NULL)) == NULL)\r\nreturn -EHOSTUNREACH;\r\nif ((ax25->ax25_dev = ax25_dev_ax25dev(ax25_rt->dev)) == NULL) {\r\nerr = -EHOSTUNREACH;\r\ngoto put;\r\n}\r\nuser = ax25_findbyuid(current_euid());\r\nif (user) {\r\nax25->source_addr = user->call;\r\nax25_uid_put(user);\r\n} else {\r\nif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {\r\nerr = -EPERM;\r\ngoto put;\r\n}\r\nax25->source_addr = *(ax25_address *)ax25->ax25_dev->dev->dev_addr;\r\n}\r\nif (ax25_rt->digipeat != NULL) {\r\nax25->digipeat = kmemdup(ax25_rt->digipeat, sizeof(ax25_digi),\r\nGFP_ATOMIC);\r\nif (ax25->digipeat == NULL) {\r\nerr = -ENOMEM;\r\ngoto put;\r\n}\r\nax25_adjust_path(addr, ax25->digipeat);\r\n}\r\nif (ax25->sk != NULL) {\r\nbh_lock_sock(ax25->sk);\r\nsock_reset_flag(ax25->sk, SOCK_ZAPPED);\r\nbh_unlock_sock(ax25->sk);\r\n}\r\nput:\r\nax25_put_route(ax25_rt);\r\nreturn err;\r\n}\r\nstruct sk_buff *ax25_rt_build_path(struct sk_buff *skb, ax25_address *src,\r\nax25_address *dest, ax25_digi *digi)\r\n{\r\nstruct sk_buff *skbn;\r\nunsigned char *bp;\r\nint len;\r\nlen = digi->ndigi * AX25_ADDR_LEN;\r\nif (skb_headroom(skb) < len) {\r\nif ((skbn = skb_realloc_headroom(skb, len)) == NULL) {\r\nprintk(KERN_CRIT "AX.25: ax25_dg_build_path - out of memory\n");\r\nreturn NULL;\r\n}\r\nif (skb->sk != NULL)\r\nskb_set_owner_w(skbn, skb->sk);\r\nkfree_skb(skb);\r\nskb = skbn;\r\n}\r\nbp = skb_push(skb, len);\r\nax25_addr_build(bp, src, dest, digi, AX25_COMMAND, AX25_MODULUS);\r\nreturn skb;\r\n}\r\nvoid __exit ax25_rt_free(void)\r\n{\r\nax25_route *s, *ax25_rt = ax25_route_list;\r\nwrite_lock_bh(&ax25_route_lock);\r\nwhile (ax25_rt != NULL) {\r\ns = ax25_rt;\r\nax25_rt = ax25_rt->next;\r\nkfree(s->digipeat);\r\nkfree(s);\r\n}\r\nwrite_unlock_bh(&ax25_route_lock);\r\n}
