static int tda18271_toggle_output(struct dvb_frontend *fe, int standby)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint ret = tda18271_set_standby_mode(fe, standby ? 1 : 0,\r\npriv->output_opt & TDA18271_OUTPUT_LT_OFF ? 1 : 0,\r\npriv->output_opt & TDA18271_OUTPUT_XT_OFF ? 1 : 0);\r\nif (tda_fail(ret))\r\ngoto fail;\r\ntda_dbg("%s mode: xtal oscillator %s, slave tuner loop thru %s\n",\r\nstandby ? "standby" : "active",\r\npriv->output_opt & TDA18271_OUTPUT_XT_OFF ? "off" : "on",\r\npriv->output_opt & TDA18271_OUTPUT_LT_OFF ? "off" : "on");\r\nfail:\r\nreturn ret;\r\n}\r\nstatic inline int charge_pump_source(struct dvb_frontend *fe, int force)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nreturn tda18271_charge_pump_source(fe,\r\n(priv->role == TDA18271_SLAVE) ?\r\nTDA18271_CAL_PLL :\r\nTDA18271_MAIN_PLL, force);\r\n}\r\nstatic inline void tda18271_set_if_notch(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nswitch (priv->mode) {\r\ncase TDA18271_ANALOG:\r\nregs[R_MPD] &= ~0x80;\r\nbreak;\r\ncase TDA18271_DIGITAL:\r\nregs[R_MPD] |= 0x80;\r\nbreak;\r\n}\r\n}\r\nstatic int tda18271_channel_configuration(struct dvb_frontend *fe,\r\nstruct tda18271_std_map_item *map,\r\nu32 freq, u32 bw)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint ret;\r\nu32 N;\r\nregs[R_EP3] &= ~0x1f;\r\nregs[R_EP3] |= (map->agc_mode << 3) | map->std;\r\nif (priv->id == TDA18271HDC2) {\r\nregs[R_EP3] &= ~0x04;\r\n}\r\nregs[R_EP4] &= ~0x03;\r\nregs[R_EP4] &= ~0x1c;\r\nregs[R_EP4] |= (map->if_lvl << 2);\r\nregs[R_EP4] &= ~0x80;\r\nregs[R_EP4] |= map->fm_rfn << 7;\r\nregs[R_EB22] = 0x00;\r\nregs[R_EB22] |= map->rfagc_top;\r\nret = tda18271_write_regs(fe, R_EB22, 1);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EP1] |= 0x40;\r\nregs[R_TM] &= ~0x10;\r\ntda18271_calc_ir_measure(fe, &freq);\r\ntda18271_calc_bp_filter(fe, &freq);\r\ntda18271_calc_rf_band(fe, &freq);\r\ntda18271_calc_gain_taper(fe, &freq);\r\nswitch (priv->role) {\r\ncase TDA18271_MASTER:\r\nregs[R_EB1] |= 0x04;\r\nbreak;\r\ncase TDA18271_SLAVE:\r\nregs[R_EB1] &= ~0x04;\r\nbreak;\r\n}\r\nregs[R_EB1] &= ~0x02;\r\nregs[R_EB1] &= ~0x01;\r\nret = tda18271_write_regs(fe, R_EB1, 1);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nN = map->if_freq * 1000 + freq;\r\nswitch (priv->role) {\r\ncase TDA18271_MASTER:\r\ntda18271_calc_main_pll(fe, N);\r\ntda18271_set_if_notch(fe);\r\ntda18271_write_regs(fe, R_MPD, 4);\r\nbreak;\r\ncase TDA18271_SLAVE:\r\ntda18271_calc_cal_pll(fe, N);\r\ntda18271_write_regs(fe, R_CPD, 4);\r\nregs[R_MPD] = regs[R_CPD] & 0x7f;\r\ntda18271_set_if_notch(fe);\r\ntda18271_write_regs(fe, R_MPD, 1);\r\nbreak;\r\n}\r\nret = tda18271_write_regs(fe, R_TM, 7);\r\nif (tda_fail(ret))\r\ngoto fail;\r\ncharge_pump_source(fe, 1);\r\nmsleep(1);\r\ncharge_pump_source(fe, 0);\r\nmsleep(20);\r\nif (priv->id == TDA18271HDC2) {\r\nif (map->fm_rfn)\r\nregs[R_EP3] &= ~0x04;\r\nelse\r\nregs[R_EP3] |= 0x04;\r\nret = tda18271_write_regs(fe, R_EP3, 1);\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_read_thermometer(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint tm;\r\nregs[R_TM] |= 0x10;\r\ntda18271_write_regs(fe, R_TM, 1);\r\ntda18271_read_regs(fe);\r\nif ((((regs[R_TM] & 0x0f) == 0x00) && ((regs[R_TM] & 0x20) == 0x20)) ||\r\n(((regs[R_TM] & 0x0f) == 0x08) && ((regs[R_TM] & 0x20) == 0x00))) {\r\nif ((regs[R_TM] & 0x20) == 0x20)\r\nregs[R_TM] &= ~0x20;\r\nelse\r\nregs[R_TM] |= 0x20;\r\ntda18271_write_regs(fe, R_TM, 1);\r\nmsleep(10);\r\ntda18271_read_regs(fe);\r\n}\r\ntm = tda18271_lookup_thermometer(fe);\r\nregs[R_TM] &= ~0x10;\r\ntda18271_write_regs(fe, R_TM, 1);\r\nregs[R_EP4] &= ~0x03;\r\ntda18271_write_regs(fe, R_EP4, 1);\r\nreturn tm;\r\n}\r\nstatic int tda18271c2_rf_tracking_filters_correction(struct dvb_frontend *fe,\r\nu32 freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_rf_tracking_filter_cal *map = priv->rf_cal_state;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint i, ret;\r\nu8 tm_current, dc_over_dt, rf_tab;\r\ns32 rfcal_comp, approx;\r\nret = tda18271_set_standby_mode(fe, 0, 0, 0);\r\nif (tda_fail(ret))\r\ngoto fail;\r\ntm_current = tda18271_read_thermometer(fe);\r\ntda18271_calc_rf_cal(fe, &freq);\r\nrf_tab = regs[R_EB14];\r\ni = tda18271_lookup_rf_band(fe, &freq, NULL);\r\nif (tda_fail(i))\r\nreturn i;\r\nif ((0 == map[i].rf3) || (freq / 1000 < map[i].rf2)) {\r\napprox = map[i].rf_a1 * (s32)(freq / 1000 - map[i].rf1) +\r\nmap[i].rf_b1 + rf_tab;\r\n} else {\r\napprox = map[i].rf_a2 * (s32)(freq / 1000 - map[i].rf2) +\r\nmap[i].rf_b2 + rf_tab;\r\n}\r\nif (approx < 0)\r\napprox = 0;\r\nif (approx > 255)\r\napprox = 255;\r\ntda18271_lookup_map(fe, RF_CAL_DC_OVER_DT, &freq, &dc_over_dt);\r\nrfcal_comp = dc_over_dt * (s32)(tm_current - priv->tm_rfcal) / 1000;\r\nregs[R_EB14] = (unsigned char)(approx + rfcal_comp);\r\nret = tda18271_write_regs(fe, R_EB14, 1);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_por(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint ret;\r\nregs[R_EB12] &= ~0x20;\r\nret = tda18271_write_regs(fe, R_EB12, 1);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EB18] &= ~0x80;\r\nregs[R_EB18] &= ~0x03;\r\nret = tda18271_write_regs(fe, R_EB18, 1);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EB21] |= 0x03;\r\nret = tda18271_set_standby_mode(fe, 1, 0, 0);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EB23] &= ~0x04;\r\nregs[R_EB23] &= ~0x02;\r\nret = tda18271_write_regs(fe, R_EB21, 3);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_calibrate_rf(struct dvb_frontend *fe, u32 freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nu32 N;\r\nregs[R_EP4] &= ~0x03;\r\ntda18271_write_regs(fe, R_EP4, 1);\r\nregs[R_EP3] |= 0x40;\r\nregs[R_EB18] |= 0x03;\r\ntda18271_write_regs(fe, R_EB18, 1);\r\ntda18271_calc_bp_filter(fe, &freq);\r\ntda18271_calc_gain_taper(fe, &freq);\r\ntda18271_calc_rf_band(fe, &freq);\r\ntda18271_calc_km(fe, &freq);\r\ntda18271_write_regs(fe, R_EP1, 3);\r\ntda18271_write_regs(fe, R_EB13, 1);\r\ntda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 1);\r\ntda18271_charge_pump_source(fe, TDA18271_CAL_PLL, 1);\r\nregs[R_EB14] = 0x00;\r\ntda18271_write_regs(fe, R_EB14, 1);\r\nregs[R_EB20] &= ~0x20;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nregs[R_EP4] |= 0x03;\r\ntda18271_write_regs(fe, R_EP4, 2);\r\nN = freq;\r\ntda18271_calc_cal_pll(fe, N);\r\ntda18271_write_regs(fe, R_CPD, 4);\r\nN += 1000000;\r\ntda18271_calc_main_pll(fe, N);\r\ntda18271_write_regs(fe, R_MPD, 4);\r\nmsleep(5);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\ntda18271_charge_pump_source(fe, TDA18271_MAIN_PLL, 0);\r\ntda18271_charge_pump_source(fe, TDA18271_CAL_PLL, 0);\r\nmsleep(10);\r\nregs[R_EB20] |= 0x20;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nmsleep(60);\r\nregs[R_EP4] &= ~0x03;\r\nregs[R_EP3] &= ~0x40;\r\nregs[R_EB18] &= ~0x03;\r\ntda18271_write_regs(fe, R_EB18, 1);\r\ntda18271_write_regs(fe, R_EP3, 2);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\ntda18271_read_extended(fe);\r\nreturn regs[R_EB14];\r\n}\r\nstatic int tda18271_powerscan(struct dvb_frontend *fe,\r\nu32 *freq_in, u32 *freq_out)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint sgn, bcal, count, wait, ret;\r\nu8 cid_target;\r\nu16 count_limit;\r\nu32 freq;\r\nfreq = *freq_in;\r\ntda18271_calc_rf_band(fe, &freq);\r\ntda18271_calc_rf_cal(fe, &freq);\r\ntda18271_calc_gain_taper(fe, &freq);\r\ntda18271_lookup_cid_target(fe, &freq, &cid_target, &count_limit);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\ntda18271_write_regs(fe, R_EB14, 1);\r\nfreq += 1000000;\r\ntda18271_calc_main_pll(fe, freq);\r\ntda18271_write_regs(fe, R_MPD, 4);\r\nmsleep(5);\r\nregs[R_EP4] &= ~0x03;\r\nregs[R_EP4] |= 0x01;\r\ntda18271_write_regs(fe, R_EP4, 1);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\nret = tda18271_read_extended(fe);\r\nif (tda_fail(ret))\r\nreturn ret;\r\nsgn = 1;\r\n*freq_out = *freq_in;\r\nbcal = 0;\r\ncount = 0;\r\nwait = false;\r\nwhile ((regs[R_EB10] & 0x3f) < cid_target) {\r\nfreq = *freq_in + (sgn * count) + 1000000;\r\ntda18271_calc_main_pll(fe, freq);\r\ntda18271_write_regs(fe, R_MPD, 4);\r\nif (wait) {\r\nmsleep(5);\r\nwait = false;\r\n} else\r\nudelay(100);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\nret = tda18271_read_extended(fe);\r\nif (tda_fail(ret))\r\nreturn ret;\r\ncount += 200;\r\nif (count <= count_limit)\r\ncontinue;\r\nif (sgn <= 0)\r\nbreak;\r\nsgn = -1 * sgn;\r\ncount = 200;\r\nwait = true;\r\n}\r\nif ((regs[R_EB10] & 0x3f) >= cid_target) {\r\nbcal = 1;\r\n*freq_out = freq - 1000000;\r\n} else\r\nbcal = 0;\r\ntda_cal("bcal = %d, freq_in = %d, freq_out = %d (freq = %d)\n",\r\nbcal, *freq_in, *freq_out, freq);\r\nreturn bcal;\r\n}\r\nstatic int tda18271_powerscan_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint ret;\r\nregs[R_EP3] &= ~0x1f;\r\nregs[R_EP3] |= 0x12;\r\nregs[R_EP4] &= ~0x03;\r\nregs[R_EP4] &= ~0x1c;\r\nret = tda18271_write_regs(fe, R_EP3, 2);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EB18] &= ~0x03;\r\nret = tda18271_write_regs(fe, R_EB18, 1);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nregs[R_EB21] &= ~0x03;\r\nregs[R_EB23] |= 0x04;\r\nregs[R_EB23] |= 0x02;\r\nret = tda18271_write_regs(fe, R_EB21, 3);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_rf_tracking_filters_init(struct dvb_frontend *fe, u32 freq)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_rf_tracking_filter_cal *map = priv->rf_cal_state;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint bcal, rf, i;\r\ns32 divisor, dividend;\r\n#define RF1 0\r\n#define RF2 1\r\n#define RF3 2\r\nu32 rf_default[3];\r\nu32 rf_freq[3];\r\ns32 prog_cal[3];\r\ns32 prog_tab[3];\r\ni = tda18271_lookup_rf_band(fe, &freq, NULL);\r\nif (tda_fail(i))\r\nreturn i;\r\nrf_default[RF1] = 1000 * map[i].rf1_def;\r\nrf_default[RF2] = 1000 * map[i].rf2_def;\r\nrf_default[RF3] = 1000 * map[i].rf3_def;\r\nfor (rf = RF1; rf <= RF3; rf++) {\r\nif (0 == rf_default[rf])\r\nreturn 0;\r\ntda_cal("freq = %d, rf = %d\n", freq, rf);\r\nbcal = tda18271_powerscan(fe, &rf_default[rf], &rf_freq[rf]);\r\nif (tda_fail(bcal))\r\nreturn bcal;\r\ntda18271_calc_rf_cal(fe, &rf_freq[rf]);\r\nprog_tab[rf] = (s32)regs[R_EB14];\r\nif (1 == bcal)\r\nprog_cal[rf] =\r\n(s32)tda18271_calibrate_rf(fe, rf_freq[rf]);\r\nelse\r\nprog_cal[rf] = prog_tab[rf];\r\nswitch (rf) {\r\ncase RF1:\r\nmap[i].rf_a1 = 0;\r\nmap[i].rf_b1 = (prog_cal[RF1] - prog_tab[RF1]);\r\nmap[i].rf1 = rf_freq[RF1] / 1000;\r\nbreak;\r\ncase RF2:\r\ndividend = (prog_cal[RF2] - prog_tab[RF2] -\r\nprog_cal[RF1] + prog_tab[RF1]);\r\ndivisor = (s32)(rf_freq[RF2] - rf_freq[RF1]) / 1000;\r\nmap[i].rf_a1 = (dividend / divisor);\r\nmap[i].rf2 = rf_freq[RF2] / 1000;\r\nbreak;\r\ncase RF3:\r\ndividend = (prog_cal[RF3] - prog_tab[RF3] -\r\nprog_cal[RF2] + prog_tab[RF2]);\r\ndivisor = (s32)(rf_freq[RF3] - rf_freq[RF2]) / 1000;\r\nmap[i].rf_a2 = (dividend / divisor);\r\nmap[i].rf_b2 = (prog_cal[RF2] - prog_tab[RF2]);\r\nmap[i].rf3 = rf_freq[RF3] / 1000;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda18271_calc_rf_filter_curve(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned int i;\r\nint ret;\r\ntda_info("tda18271: performing RF tracking filter calibration\n");\r\nmsleep(200);\r\nret = tda18271_powerscan_init(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nfor (i = 0; priv->rf_cal_state[i].rfmax != 0; i++) {\r\nret =\r\ntda18271_rf_tracking_filters_init(fe, 1000 *\r\npriv->rf_cal_state[i].rfmax);\r\nif (tda_fail(ret))\r\ngoto fail;\r\n}\r\npriv->tm_rfcal = tda18271_read_thermometer(fe);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271c2_rf_cal_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint ret;\r\nif ((regs[R_EP1] & 0x10) == 0)\r\npriv->cal_initialized = false;\r\nif (priv->cal_initialized)\r\nreturn 0;\r\nret = tda18271_calc_rf_filter_curve(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nret = tda18271_por(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\ntda_info("tda18271: RF tracking filter calibration complete\n");\r\npriv->cal_initialized = true;\r\ngoto end;\r\nfail:\r\ntda_info("tda18271: RF tracking filter calibration failed!\n");\r\nend:\r\nreturn ret;\r\n}\r\nstatic int tda18271c1_rf_tracking_filter_calibration(struct dvb_frontend *fe,\r\nu32 freq, u32 bw)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint ret;\r\nu32 N = 0;\r\ntda18271_calc_bp_filter(fe, &freq);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nregs[R_EB4] &= 0x07;\r\nregs[R_EB4] |= 0x60;\r\ntda18271_write_regs(fe, R_EB4, 1);\r\nregs[R_EB7] = 0x60;\r\ntda18271_write_regs(fe, R_EB7, 1);\r\nregs[R_EB14] = 0x00;\r\ntda18271_write_regs(fe, R_EB14, 1);\r\nregs[R_EB20] = 0xcc;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nregs[R_EP4] |= 0x03;\r\nswitch (priv->mode) {\r\ncase TDA18271_ANALOG:\r\nN = freq - 1250000;\r\nbreak;\r\ncase TDA18271_DIGITAL:\r\nN = freq + bw / 2;\r\nbreak;\r\n}\r\ntda18271_calc_cal_pll(fe, N);\r\nswitch (priv->mode) {\r\ncase TDA18271_ANALOG:\r\nN = freq - 250000;\r\nbreak;\r\ncase TDA18271_DIGITAL:\r\nN = freq + bw / 2 + 1000000;\r\nbreak;\r\n}\r\ntda18271_calc_main_pll(fe, N);\r\nret = tda18271_write_regs(fe, R_EP3, 11);\r\nif (tda_fail(ret))\r\nreturn ret;\r\nmsleep(5);\r\ntda18271_calc_km(fe, &freq);\r\ntda18271_write_regs(fe, R_EB13, 1);\r\ntda18271_calc_rf_band(fe, &freq);\r\ntda18271_calc_gain_taper(fe, &freq);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\ntda18271_write_regs(fe, R_EP2, 1);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nregs[R_EB4] &= 0x07;\r\nregs[R_EB4] |= 0x40;\r\ntda18271_write_regs(fe, R_EB4, 1);\r\nregs[R_EB7] = 0x40;\r\ntda18271_write_regs(fe, R_EB7, 1);\r\nmsleep(10);\r\nregs[R_EB20] = 0xec;\r\ntda18271_write_regs(fe, R_EB20, 1);\r\nmsleep(60);\r\nregs[R_EP4] &= ~0x03;\r\ntda18271_write_regs(fe, R_EP4, 1);\r\ntda18271_write_regs(fe, R_EP1, 1);\r\nif (0 == tda18271_calc_rf_cal(fe, &freq))\r\ntda18271_write_regs(fe, R_EB14, 1);\r\nreturn 0;\r\n}\r\nstatic int tda18271_ir_cal_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint ret;\r\nret = tda18271_read_regs(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nif ((regs[R_EP1] & 0x08) == 0)\r\nret = tda18271_init_regs(fe);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_init(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = tda18271_set_standby_mode(fe, 0, 0, 0);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nret = tda18271_ir_cal_init(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nif (priv->id == TDA18271HDC2)\r\ntda18271c2_rf_cal_init(fe);\r\nfail:\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int tda18271_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = tda18271_toggle_output(fe, 1);\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int tda18271_agc(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint ret = 0;\r\nswitch (priv->config) {\r\ncase 0:\r\nif (tda18271_debug & DBG_ADV)\r\ntda_dbg("no agc configuration provided\n");\r\nbreak;\r\ncase 3:\r\ntda_dbg("invoking callback\n");\r\nif (fe->callback)\r\nret = fe->callback(priv->i2c_props.adap->algo_data,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nTDA18271_CALLBACK_CMD_AGC_ENABLE,\r\npriv->mode);\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ndefault:\r\ntda_err("unsupported configuration: %d\n", priv->config);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18271_tune(struct dvb_frontend *fe,\r\nstruct tda18271_std_map_item *map, u32 freq, u32 bw)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint ret;\r\ntda_dbg("freq = %d, ifc = %d, bw = %d, agc_mode = %d, std = %d\n",\r\nfreq, map->if_freq, bw, map->agc_mode, map->std);\r\nret = tda18271_agc(fe);\r\nif (tda_fail(ret))\r\ntda_warn("failed to configure agc\n");\r\nret = tda18271_init(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nmutex_lock(&priv->lock);\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\ntda18271c1_rf_tracking_filter_calibration(fe, freq, bw);\r\nbreak;\r\ncase TDA18271HDC2:\r\ntda18271c2_rf_tracking_filters_correction(fe, freq);\r\nbreak;\r\n}\r\nret = tda18271_channel_configuration(fe, map, freq, bw);\r\nmutex_unlock(&priv->lock);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 delsys = c->delivery_system;\r\nu32 bw = c->bandwidth_hz;\r\nu32 freq = c->frequency;\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_std_map *std_map = &priv->std;\r\nstruct tda18271_std_map_item *map;\r\nint ret;\r\npriv->mode = TDA18271_DIGITAL;\r\nswitch (delsys) {\r\ncase SYS_ATSC:\r\nmap = &std_map->atsc_6;\r\nbw = 6000000;\r\nbreak;\r\ncase SYS_ISDBT:\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\nif (bw <= 6000000) {\r\nmap = &std_map->dvbt_6;\r\n} else if (bw <= 7000000) {\r\nmap = &std_map->dvbt_7;\r\n} else {\r\nmap = &std_map->dvbt_8;\r\n}\r\nbreak;\r\ncase SYS_DVBC_ANNEX_B:\r\nbw = 6000000;\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nif (bw <= 6000000) {\r\nmap = &std_map->qam_6;\r\n} else if (bw <= 7000000) {\r\nmap = &std_map->qam_7;\r\n} else {\r\nmap = &std_map->qam_8;\r\n}\r\nbreak;\r\ndefault:\r\ntda_warn("modulation type not supported!\n");\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.analog_ops.standby)\r\nfe->ops.analog_ops.standby(fe);\r\nret = tda18271_tune(fe, map, freq, bw);\r\nif (tda_fail(ret))\r\ngoto fail;\r\npriv->if_freq = map->if_freq;\r\npriv->frequency = freq;\r\npriv->bandwidth = bw;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_set_analog_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_std_map *std_map = &priv->std;\r\nstruct tda18271_std_map_item *map;\r\nchar *mode;\r\nint ret;\r\nu32 freq = params->frequency * 125 *\r\n((params->mode == V4L2_TUNER_RADIO) ? 1 : 1000) / 2;\r\npriv->mode = TDA18271_ANALOG;\r\nif (params->mode == V4L2_TUNER_RADIO) {\r\nmap = &std_map->fm_radio;\r\nmode = "fm";\r\n} else if (params->std & V4L2_STD_MN) {\r\nmap = &std_map->atv_mn;\r\nmode = "MN";\r\n} else if (params->std & V4L2_STD_B) {\r\nmap = &std_map->atv_b;\r\nmode = "B";\r\n} else if (params->std & V4L2_STD_GH) {\r\nmap = &std_map->atv_gh;\r\nmode = "GH";\r\n} else if (params->std & V4L2_STD_PAL_I) {\r\nmap = &std_map->atv_i;\r\nmode = "I";\r\n} else if (params->std & V4L2_STD_DK) {\r\nmap = &std_map->atv_dk;\r\nmode = "DK";\r\n} else if (params->std & V4L2_STD_SECAM_L) {\r\nmap = &std_map->atv_l;\r\nmode = "L";\r\n} else if (params->std & V4L2_STD_SECAM_LC) {\r\nmap = &std_map->atv_lc;\r\nmode = "L'";\r\n} else {\r\nmap = &std_map->atv_i;\r\nmode = "xx";\r\n}\r\ntda_dbg("setting tda18271 to system %s\n", mode);\r\nret = tda18271_tune(fe, map, freq, 0);\r\nif (tda_fail(ret))\r\ngoto fail;\r\npriv->if_freq = map->if_freq;\r\npriv->frequency = freq;\r\npriv->bandwidth = 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int tda18271_release(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nmutex_lock(&tda18271_list_mutex);\r\nif (priv)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&tda18271_list_mutex);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int tda18271_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int tda18271_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\n*bandwidth = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int tda18271_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\n*frequency = (u32)priv->if_freq * 1000;\r\nreturn 0;\r\n}\r\nstatic int tda18271_dump_std_map(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_std_map *std = &priv->std;\r\ntda_dbg("========== STANDARD MAP SETTINGS ==========\n");\r\ntda18271_dump_std_item(fm_radio, " fm ");\r\ntda18271_dump_std_item(atv_b, "atv b ");\r\ntda18271_dump_std_item(atv_dk, "atv dk");\r\ntda18271_dump_std_item(atv_gh, "atv gh");\r\ntda18271_dump_std_item(atv_i, "atv i ");\r\ntda18271_dump_std_item(atv_l, "atv l ");\r\ntda18271_dump_std_item(atv_lc, "atv l'");\r\ntda18271_dump_std_item(atv_mn, "atv mn");\r\ntda18271_dump_std_item(atsc_6, "atsc 6");\r\ntda18271_dump_std_item(dvbt_6, "dvbt 6");\r\ntda18271_dump_std_item(dvbt_7, "dvbt 7");\r\ntda18271_dump_std_item(dvbt_8, "dvbt 8");\r\ntda18271_dump_std_item(qam_6, "qam 6 ");\r\ntda18271_dump_std_item(qam_8, "qam 8 ");\r\nreturn 0;\r\n}\r\nstatic int tda18271_update_std_map(struct dvb_frontend *fe,\r\nstruct tda18271_std_map *map)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_std_map *std = &priv->std;\r\nif (!map)\r\nreturn -EINVAL;\r\ntda18271_update_std(fm_radio, "fm");\r\ntda18271_update_std(atv_b, "atv b");\r\ntda18271_update_std(atv_dk, "atv dk");\r\ntda18271_update_std(atv_gh, "atv gh");\r\ntda18271_update_std(atv_i, "atv i");\r\ntda18271_update_std(atv_l, "atv l");\r\ntda18271_update_std(atv_lc, "atv l'");\r\ntda18271_update_std(atv_mn, "atv mn");\r\ntda18271_update_std(atsc_6, "atsc 6");\r\ntda18271_update_std(dvbt_6, "dvbt 6");\r\ntda18271_update_std(dvbt_7, "dvbt 7");\r\ntda18271_update_std(dvbt_8, "dvbt 8");\r\ntda18271_update_std(qam_6, "qam 6");\r\ntda18271_update_std(qam_8, "qam 8");\r\nreturn 0;\r\n}\r\nstatic int tda18271_get_id(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nchar *name;\r\nmutex_lock(&priv->lock);\r\ntda18271_read_regs(fe);\r\nmutex_unlock(&priv->lock);\r\nswitch (regs[R_ID] & 0x7f) {\r\ncase 3:\r\nname = "TDA18271HD/C1";\r\npriv->id = TDA18271HDC1;\r\nbreak;\r\ncase 4:\r\nname = "TDA18271HD/C2";\r\npriv->id = TDA18271HDC2;\r\nbreak;\r\ndefault:\r\ntda_info("Unknown device (%i) detected @ %d-%04x, device not supported.\n",\r\nregs[R_ID], i2c_adapter_id(priv->i2c_props.adap),\r\npriv->i2c_props.addr);\r\nreturn -EINVAL;\r\n}\r\ntda_info("%s detected @ %d-%04x\n", name,\r\ni2c_adapter_id(priv->i2c_props.adap), priv->i2c_props.addr);\r\nreturn 0;\r\n}\r\nstatic int tda18271_setup_configuration(struct dvb_frontend *fe,\r\nstruct tda18271_config *cfg)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\npriv->gate = (cfg) ? cfg->gate : TDA18271_GATE_AUTO;\r\npriv->role = (cfg) ? cfg->role : TDA18271_MASTER;\r\npriv->config = (cfg) ? cfg->config : 0;\r\npriv->small_i2c = (cfg) ?\r\ncfg->small_i2c : TDA18271_39_BYTE_CHUNK_INIT;\r\npriv->output_opt = (cfg) ?\r\ncfg->output_opt : TDA18271_OUTPUT_LT_XT_ON;\r\nreturn 0;\r\n}\r\nstatic inline int tda18271_need_cal_on_startup(struct tda18271_config *cfg)\r\n{\r\nreturn ((tda18271_cal_on_startup == -1) ?\r\n((cfg) && (cfg->rf_cal_on_startup)) :\r\n(tda18271_cal_on_startup)) ? 1 : 0;\r\n}\r\nstatic int tda18271_set_config(struct dvb_frontend *fe, void *priv_cfg)\r\n{\r\nstruct tda18271_config *cfg = (struct tda18271_config *) priv_cfg;\r\ntda18271_setup_configuration(fe, cfg);\r\nif (tda18271_need_cal_on_startup(cfg))\r\ntda18271_init(fe);\r\nif ((cfg) && (cfg->std_map))\r\ntda18271_update_std_map(fe, cfg->std_map);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tda18271_attach(struct dvb_frontend *fe, u8 addr,\r\nstruct i2c_adapter *i2c,\r\nstruct tda18271_config *cfg)\r\n{\r\nstruct tda18271_priv *priv = NULL;\r\nint instance, ret;\r\nmutex_lock(&tda18271_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct tda18271_priv, priv,\r\nhybrid_tuner_instance_list,\r\ni2c, addr, "tda18271");\r\nswitch (instance) {\r\ncase 0:\r\ngoto fail;\r\ncase 1:\r\nfe->tuner_priv = priv;\r\ntda18271_setup_configuration(fe, cfg);\r\npriv->cal_initialized = false;\r\nmutex_init(&priv->lock);\r\nret = tda18271_get_id(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nret = tda18271_assign_map_layout(fe);\r\nif (tda_fail(ret))\r\ngoto fail;\r\nmutex_lock(&priv->lock);\r\ntda18271_init_regs(fe);\r\nif ((tda18271_need_cal_on_startup(cfg)) &&\r\n(priv->id == TDA18271HDC2))\r\ntda18271c2_rf_cal_init(fe);\r\nmutex_unlock(&priv->lock);\r\nbreak;\r\ndefault:\r\nfe->tuner_priv = priv;\r\nif (cfg) {\r\nif (cfg->gate != TDA18271_GATE_ANALOG)\r\npriv->gate = cfg->gate;\r\nif (cfg->role)\r\npriv->role = cfg->role;\r\nif (cfg->config)\r\npriv->config = cfg->config;\r\nif (cfg->small_i2c)\r\npriv->small_i2c = cfg->small_i2c;\r\nif (cfg->output_opt)\r\npriv->output_opt = cfg->output_opt;\r\nif (cfg->std_map)\r\ntda18271_update_std_map(fe, cfg->std_map);\r\n}\r\nif (tda18271_need_cal_on_startup(cfg))\r\ntda18271_init(fe);\r\nbreak;\r\n}\r\nif ((cfg) && (cfg->std_map))\r\ntda18271_update_std_map(fe, cfg->std_map);\r\nmutex_unlock(&tda18271_list_mutex);\r\nmemcpy(&fe->ops.tuner_ops, &tda18271_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nif (tda18271_debug & (DBG_MAP | DBG_ADV))\r\ntda18271_dump_std_map(fe);\r\nreturn fe;\r\nfail:\r\nmutex_unlock(&tda18271_list_mutex);\r\ntda18271_release(fe);\r\nreturn NULL;\r\n}
