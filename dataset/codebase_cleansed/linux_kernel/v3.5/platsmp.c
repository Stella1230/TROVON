static int __init vexpress_dt_find_scu(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nif (of_flat_dt_match(node, vexpress_dt_cortex_a9_match)) {\r\nphys_addr_t phys_addr;\r\n__be32 *reg = of_get_flat_dt_prop(node, "reg", NULL);\r\nif (WARN_ON(!reg))\r\nreturn -EINVAL;\r\nphys_addr = be32_to_cpup(reg);\r\nvexpress_dt_scu = CORTEX_A9_SCU;\r\nvexpress_dt_cortex_a9_scu_map.pfn = __phys_to_pfn(phys_addr);\r\niotable_init(&vexpress_dt_cortex_a9_scu_map, 1);\r\nvexpress_dt_cortex_a9_scu_base = ioremap(phys_addr, SZ_256);\r\nif (WARN_ON(!vexpress_dt_cortex_a9_scu_base))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init vexpress_dt_smp_map_io(void)\r\n{\r\nif (initial_boot_params)\r\nWARN_ON(of_scan_flat_dt(vexpress_dt_find_scu, NULL));\r\n}\r\nstatic int __init vexpress_dt_cpus_num(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nstatic int prev_depth = -1;\r\nstatic int nr_cpus = -1;\r\nif (prev_depth > depth && nr_cpus > 0)\r\nreturn nr_cpus;\r\nif (nr_cpus < 0 && strcmp(uname, "cpus") == 0)\r\nnr_cpus = 0;\r\nif (nr_cpus >= 0) {\r\nconst char *device_type = of_get_flat_dt_prop(node,\r\n"device_type", NULL);\r\nif (device_type && strcmp(device_type, "cpu") == 0)\r\nnr_cpus++;\r\n}\r\nprev_depth = depth;\r\nreturn 0;\r\n}\r\nstatic void __init vexpress_dt_smp_init_cpus(void)\r\n{\r\nint ncores = 0, i;\r\nswitch (vexpress_dt_scu) {\r\ncase GENERIC_SCU:\r\nncores = of_scan_flat_dt(vexpress_dt_cpus_num, NULL);\r\nbreak;\r\ncase CORTEX_A9_SCU:\r\nncores = scu_get_core_count(vexpress_dt_cortex_a9_scu_base);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nif (ncores < 2)\r\nreturn;\r\nif (ncores > nr_cpu_ids) {\r\npr_warn("SMP: %u cores greater than maximum (%u), clipping\n",\r\nncores, nr_cpu_ids);\r\nncores = nr_cpu_ids;\r\n}\r\nfor (i = 0; i < ncores; ++i)\r\nset_cpu_possible(i, true);\r\nset_smp_cross_call(gic_raise_softirq);\r\n}\r\nstatic void __init vexpress_dt_smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nint i;\r\nswitch (vexpress_dt_scu) {\r\ncase GENERIC_SCU:\r\nfor (i = 0; i < max_cpus; i++)\r\nset_cpu_present(i, true);\r\nbreak;\r\ncase CORTEX_A9_SCU:\r\nscu_enable(vexpress_dt_cortex_a9_scu_base);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void __init vexpress_dt_smp_init_cpus(void)\r\n{\r\nWARN_ON(1);\r\n}\r\nvoid __init vexpress_dt_smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nWARN_ON(1);\r\n}\r\nvoid __init smp_init_cpus(void)\r\n{\r\nif (ct_desc)\r\nct_desc->init_cpu_map();\r\nelse\r\nvexpress_dt_smp_init_cpus();\r\n}\r\nvoid __init platform_smp_prepare_cpus(unsigned int max_cpus)\r\n{\r\nif (ct_desc)\r\nct_desc->smp_enable(max_cpus);\r\nelse\r\nvexpress_dt_smp_prepare_cpus(max_cpus);\r\nv2m_flags_set(virt_to_phys(versatile_secondary_startup));\r\n}
