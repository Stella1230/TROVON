static u32 _vp_set_init_voltage(struct voltagedomain *voltdm, u32 volt)\r\n{\r\nstruct omap_vp_instance *vp = voltdm->vp;\r\nu32 vpconfig;\r\nchar vsel;\r\nvsel = voltdm->pmic->uv_to_vsel(volt);\r\nvpconfig = voltdm->read(vp->vpconfig);\r\nvpconfig &= ~(vp->common->vpconfig_initvoltage_mask |\r\nvp->common->vpconfig_forceupdate |\r\nvp->common->vpconfig_initvdd);\r\nvpconfig |= vsel << __ffs(vp->common->vpconfig_initvoltage_mask);\r\nvoltdm->write(vpconfig, vp->vpconfig);\r\nvoltdm->write((vpconfig | vp->common->vpconfig_initvdd),\r\nvp->vpconfig);\r\nvoltdm->write(vpconfig, vp->vpconfig);\r\nreturn vpconfig;\r\n}\r\nvoid __init omap_vp_init(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vp_instance *vp = voltdm->vp;\r\nu32 val, sys_clk_rate, timeout, waittime;\r\nu32 vddmin, vddmax, vstepmin, vstepmax;\r\nif (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {\r\npr_err("%s: No PMIC info for vdd_%s\n", __func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nvp->enabled = false;\r\nsys_clk_rate = voltdm->sys_clk.rate / 1000;\r\ntimeout = (sys_clk_rate * voltdm->pmic->vp_timeout_us) / 1000;\r\nvddmin = voltdm->pmic->vp_vddmin;\r\nvddmax = voltdm->pmic->vp_vddmax;\r\nwaittime = DIV_ROUND_UP(voltdm->pmic->step_size * sys_clk_rate,\r\n1000 * voltdm->pmic->slew_rate);\r\nvstepmin = voltdm->pmic->vp_vstepmin;\r\nvstepmax = voltdm->pmic->vp_vstepmax;\r\nval = (voltdm->pmic->vp_erroroffset <<\r\n__ffs(voltdm->vp->common->vpconfig_erroroffset_mask)) |\r\nvp->common->vpconfig_timeouten;\r\nvoltdm->write(val, vp->vpconfig);\r\nval = (waittime << vp->common->vstepmin_smpswaittimemin_shift) |\r\n(vstepmin << vp->common->vstepmin_stepmin_shift);\r\nvoltdm->write(val, vp->vstepmin);\r\nval = (vstepmax << vp->common->vstepmax_stepmax_shift) |\r\n(waittime << vp->common->vstepmax_smpswaittimemax_shift);\r\nvoltdm->write(val, vp->vstepmax);\r\nval = (vddmax << vp->common->vlimitto_vddmax_shift) |\r\n(vddmin << vp->common->vlimitto_vddmin_shift) |\r\n(timeout << vp->common->vlimitto_timeout_shift);\r\nvoltdm->write(val, vp->vlimitto);\r\n}\r\nint omap_vp_update_errorgain(struct voltagedomain *voltdm,\r\nunsigned long target_volt)\r\n{\r\nstruct omap_volt_data *volt_data;\r\nif (!voltdm->vp)\r\nreturn -EINVAL;\r\nvolt_data = omap_voltage_get_voltdata(voltdm, target_volt);\r\nif (IS_ERR(volt_data))\r\nreturn -EINVAL;\r\nvoltdm->rmw(voltdm->vp->common->vpconfig_errorgain_mask,\r\nvolt_data->vp_errgain <<\r\n__ffs(voltdm->vp->common->vpconfig_errorgain_mask),\r\nvoltdm->vp->vpconfig);\r\nreturn 0;\r\n}\r\nint omap_vp_forceupdate_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt)\r\n{\r\nstruct omap_vp_instance *vp = voltdm->vp;\r\nu32 vpconfig;\r\nu8 target_vsel, current_vsel;\r\nint ret, timeout = 0;\r\nret = omap_vc_pre_scale(voltdm, target_volt, &target_vsel, &current_vsel);\r\nif (ret)\r\nreturn ret;\r\nwhile (timeout++ < VP_TRANXDONE_TIMEOUT) {\r\nvp->common->ops->clear_txdone(vp->id);\r\nif (!vp->common->ops->check_txdone(vp->id))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout >= VP_TRANXDONE_TIMEOUT) {\r\npr_warning("%s: vdd_%s TRANXDONE timeout exceeded."\r\n"Voltage change aborted", __func__, voltdm->name);\r\nreturn -ETIMEDOUT;\r\n}\r\nvpconfig = _vp_set_init_voltage(voltdm, target_volt);\r\nvoltdm->write(vpconfig | vp->common->vpconfig_forceupdate,\r\nvoltdm->vp->vpconfig);\r\ntimeout = 0;\r\nomap_test_timeout(vp->common->ops->check_txdone(vp->id),\r\nVP_TRANXDONE_TIMEOUT, timeout);\r\nif (timeout >= VP_TRANXDONE_TIMEOUT)\r\npr_err("%s: vdd_%s TRANXDONE timeout exceeded."\r\n"TRANXDONE never got set after the voltage update\n",\r\n__func__, voltdm->name);\r\nomap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);\r\ntimeout = 0;\r\nwhile (timeout++ < VP_TRANXDONE_TIMEOUT) {\r\nvp->common->ops->clear_txdone(vp->id);\r\nif (!vp->common->ops->check_txdone(vp->id))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout >= VP_TRANXDONE_TIMEOUT)\r\npr_warning("%s: vdd_%s TRANXDONE timeout exceeded while trying"\r\n"to clear the TRANXDONE status\n",\r\n__func__, voltdm->name);\r\nvoltdm->write(vpconfig, vp->vpconfig);\r\nreturn 0;\r\n}\r\nvoid omap_vp_enable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vp_instance *vp;\r\nu32 vpconfig, volt;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\nvp = voltdm->vp;\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (vp->enabled)\r\nreturn;\r\nvolt = voltdm_get_voltage(voltdm);\r\nif (!volt) {\r\npr_warning("%s: unable to find current voltage for %s\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nvpconfig = _vp_set_init_voltage(voltdm, volt);\r\nvpconfig |= vp->common->vpconfig_vpenable;\r\nvoltdm->write(vpconfig, vp->vpconfig);\r\nvp->enabled = true;\r\n}\r\nvoid omap_vp_disable(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vp_instance *vp;\r\nu32 vpconfig;\r\nint timeout;\r\nif (!voltdm || IS_ERR(voltdm)) {\r\npr_warning("%s: VDD specified does not exist!\n", __func__);\r\nreturn;\r\n}\r\nvp = voltdm->vp;\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!vp->enabled) {\r\npr_warning("%s: Trying to disable VP for vdd_%s when"\r\n"it is already disabled\n", __func__, voltdm->name);\r\nreturn;\r\n}\r\nvpconfig = voltdm->read(vp->vpconfig);\r\nvpconfig &= ~vp->common->vpconfig_vpenable;\r\nvoltdm->write(vpconfig, vp->vpconfig);\r\nomap_test_timeout((voltdm->read(vp->vstatus)),\r\nVP_IDLE_TIMEOUT, timeout);\r\nif (timeout >= VP_IDLE_TIMEOUT)\r\npr_warning("%s: vdd_%s idle timedout\n",\r\n__func__, voltdm->name);\r\nvp->enabled = false;\r\nreturn;\r\n}
