static int max8925_backlight_set(struct backlight_device *bl, int brightness)\r\n{\r\nstruct max8925_backlight_data *data = bl_get_data(bl);\r\nstruct max8925_chip *chip = data->chip;\r\nunsigned char value;\r\nint ret;\r\nif (brightness > MAX_BRIGHTNESS)\r\nvalue = MAX_BRIGHTNESS;\r\nelse\r\nvalue = brightness;\r\nret = max8925_reg_write(chip->i2c, MAX8925_WLED_CNTL, value);\r\nif (ret < 0)\r\ngoto out;\r\nif (!data->current_brightness && brightness)\r\nret = max8925_set_bits(chip->i2c, MAX8925_WLED_MODE_CNTL, 1, 1);\r\nelse if (!brightness)\r\nret = max8925_set_bits(chip->i2c, MAX8925_WLED_MODE_CNTL, 1, 0);\r\nif (ret < 0)\r\ngoto out;\r\ndev_dbg(chip->dev, "set brightness %d\n", value);\r\ndata->current_brightness = value;\r\nreturn 0;\r\nout:\r\ndev_dbg(chip->dev, "set brightness %d failure with return value:%d\n",\r\nvalue, ret);\r\nreturn ret;\r\n}\r\nstatic int max8925_backlight_update_status(struct backlight_device *bl)\r\n{\r\nint brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.state & BL_CORE_SUSPENDED)\r\nbrightness = 0;\r\nreturn max8925_backlight_set(bl, brightness);\r\n}\r\nstatic int max8925_backlight_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct max8925_backlight_data *data = bl_get_data(bl);\r\nstruct max8925_chip *chip = data->chip;\r\nint ret;\r\nret = max8925_reg_read(chip->i2c, MAX8925_WLED_CNTL);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\ndata->current_brightness = ret;\r\ndev_dbg(chip->dev, "get brightness %d\n", data->current_brightness);\r\nreturn ret;\r\n}\r\nstatic int __devinit max8925_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct max8925_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct max8925_platform_data *max8925_pdata;\r\nstruct max8925_backlight_pdata *pdata = NULL;\r\nstruct max8925_backlight_data *data;\r\nstruct backlight_device *bl;\r\nstruct backlight_properties props;\r\nstruct resource *res;\r\nchar name[MAX8925_NAME_SIZE];\r\nunsigned char value;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No I/O resource!\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdev->dev.parent->platform_data) {\r\nmax8925_pdata = pdev->dev.parent->platform_data;\r\npdata = max8925_pdata->backlight;\r\n}\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "platform data isn't assigned to "\r\n"backlight\n");\r\nreturn -EINVAL;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct max8925_backlight_data),\r\nGFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nstrncpy(name, res->name, MAX8925_NAME_SIZE);\r\ndata->chip = chip;\r\ndata->current_brightness = 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nbl = backlight_device_register(name, &pdev->dev, data,\r\n&max8925_backlight_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&pdev->dev, "failed to register backlight\n");\r\nreturn PTR_ERR(bl);\r\n}\r\nbl->props.brightness = MAX_BRIGHTNESS;\r\nplatform_set_drvdata(pdev, bl);\r\nvalue = 0;\r\nif (pdata->lxw_scl)\r\nvalue |= (1 << 7);\r\nif (pdata->lxw_freq)\r\nvalue |= (LWX_FREQ(pdata->lxw_freq) << 4);\r\nif (pdata->dual_string)\r\nvalue |= (1 << 1);\r\nret = max8925_set_bits(chip->i2c, MAX8925_WLED_MODE_CNTL, 0xfe, value);\r\nif (ret < 0)\r\ngoto out;\r\nbacklight_update_status(bl);\r\nreturn 0;\r\nout:\r\nbacklight_device_unregister(bl);\r\nreturn ret;\r\n}\r\nstatic int __devexit max8925_backlight_remove(struct platform_device *pdev)\r\n{\r\nstruct backlight_device *bl = platform_get_drvdata(pdev);\r\nbacklight_device_unregister(bl);\r\nreturn 0;\r\n}
