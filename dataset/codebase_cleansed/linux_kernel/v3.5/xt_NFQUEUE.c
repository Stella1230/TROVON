static unsigned int\r\nnfqueue_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info *tinfo = par->targinfo;\r\nreturn NF_QUEUE_NR(tinfo->queuenum);\r\n}\r\nstatic u32 hash_v4(const struct sk_buff *skb)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\n__be32 ipaddr;\r\nipaddr = iph->saddr ^ iph->daddr;\r\nreturn jhash_2words((__force u32)ipaddr, iph->protocol, jhash_initval);\r\n}\r\nstatic u32 hash_v6(const struct sk_buff *skb)\r\n{\r\nconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\r\n__be32 addr[4];\r\naddr[0] = ip6h->saddr.s6_addr32[0] ^ ip6h->daddr.s6_addr32[0];\r\naddr[1] = ip6h->saddr.s6_addr32[1] ^ ip6h->daddr.s6_addr32[1];\r\naddr[2] = ip6h->saddr.s6_addr32[2] ^ ip6h->daddr.s6_addr32[2];\r\naddr[3] = ip6h->saddr.s6_addr32[3] ^ ip6h->daddr.s6_addr32[3];\r\nreturn jhash2((__force u32 *)addr, ARRAY_SIZE(addr), jhash_initval);\r\n}\r\nstatic unsigned int\r\nnfqueue_tg_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info_v1 *info = par->targinfo;\r\nu32 queue = info->queuenum;\r\nif (info->queues_total > 1) {\r\nif (par->family == NFPROTO_IPV4)\r\nqueue = (((u64) hash_v4(skb) * info->queues_total) >>\r\n32) + queue;\r\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\r\nelse if (par->family == NFPROTO_IPV6)\r\nqueue = (((u64) hash_v6(skb) * info->queues_total) >>\r\n32) + queue;\r\n#endif\r\n}\r\nreturn NF_QUEUE_NR(queue);\r\n}\r\nstatic unsigned int\r\nnfqueue_tg_v2(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_NFQ_info_v2 *info = par->targinfo;\r\nunsigned int ret = nfqueue_tg_v1(skb, par);\r\nif (info->bypass)\r\nret |= NF_VERDICT_FLAG_QUEUE_BYPASS;\r\nreturn ret;\r\n}\r\nstatic int nfqueue_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_NFQ_info_v2 *info = par->targinfo;\r\nu32 maxid;\r\nif (unlikely(!rnd_inited)) {\r\nget_random_bytes(&jhash_initval, sizeof(jhash_initval));\r\nrnd_inited = true;\r\n}\r\nif (info->queues_total == 0) {\r\npr_err("NFQUEUE: number of total queues is 0\n");\r\nreturn -EINVAL;\r\n}\r\nmaxid = info->queues_total - 1 + info->queuenum;\r\nif (maxid > 0xffff) {\r\npr_err("NFQUEUE: number of queues (%u) out of range (got %u)\n",\r\ninfo->queues_total, maxid);\r\nreturn -ERANGE;\r\n}\r\nif (par->target->revision == 2 && info->bypass > 1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init nfqueue_tg_init(void)\r\n{\r\nreturn xt_register_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));\r\n}\r\nstatic void __exit nfqueue_tg_exit(void)\r\n{\r\nxt_unregister_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));\r\n}
