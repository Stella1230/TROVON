static int pl061_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\ngpiodir = readb(chip->base + GPIODIR);\r\ngpiodir &= ~(1 << offset);\r\nwriteb(gpiodir, chip->base + GPIODIR);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nunsigned long flags;\r\nunsigned char gpiodir;\r\nif (offset >= gc->ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->lock, flags);\r\nwriteb(!!value << offset, chip->base + (1 << (offset + 2)));\r\ngpiodir = readb(chip->base + GPIODIR);\r\ngpiodir |= 1 << offset;\r\nwriteb(gpiodir, chip->base + GPIODIR);\r\nwriteb(!!value << offset, chip->base + (1 << (offset + 2)));\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pl061_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nreturn !!readb(chip->base + (1 << (offset + 2)));\r\n}\r\nstatic void pl061_set_value(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nwriteb(!!value << offset, chip->base + (1 << (offset + 2)));\r\n}\r\nstatic int pl061_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pl061_gpio *chip = container_of(gc, struct pl061_gpio, gc);\r\nif (chip->irq_base <= 0)\r\nreturn -EINVAL;\r\nreturn chip->irq_base + offset;\r\n}\r\nstatic int pl061_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct pl061_gpio *chip = gc->private;\r\nint offset = d->irq - chip->irq_base;\r\nunsigned long flags;\r\nu8 gpiois, gpioibe, gpioiev;\r\nif (offset < 0 || offset >= PL061_GPIO_NR)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&gc->lock, flags);\r\ngpioiev = readb(chip->base + GPIOIEV);\r\ngpiois = readb(chip->base + GPIOIS);\r\nif (trigger & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\ngpiois |= 1 << offset;\r\nif (trigger & IRQ_TYPE_LEVEL_HIGH)\r\ngpioiev |= 1 << offset;\r\nelse\r\ngpioiev &= ~(1 << offset);\r\n} else\r\ngpiois &= ~(1 << offset);\r\nwriteb(gpiois, chip->base + GPIOIS);\r\ngpioibe = readb(chip->base + GPIOIBE);\r\nif ((trigger & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\ngpioibe |= 1 << offset;\r\nelse {\r\ngpioibe &= ~(1 << offset);\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\ngpioiev |= 1 << offset;\r\nelse if (trigger & IRQ_TYPE_EDGE_FALLING)\r\ngpioiev &= ~(1 << offset);\r\n}\r\nwriteb(gpioibe, chip->base + GPIOIBE);\r\nwriteb(gpioiev, chip->base + GPIOIEV);\r\nraw_spin_unlock_irqrestore(&gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void pl061_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nunsigned long pending;\r\nint offset;\r\nstruct pl061_gpio *chip = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nchained_irq_enter(irqchip, desc);\r\npending = readb(chip->base + GPIOMIS);\r\nwriteb(pending, chip->base + GPIOIC);\r\nif (pending) {\r\nfor_each_set_bit(offset, &pending, PL061_GPIO_NR)\r\ngeneric_handle_irq(pl061_to_irq(&chip->gc, offset));\r\n}\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nstatic void __init pl061_init_gc(struct pl061_gpio *chip, int irq_base)\r\n{\r\nstruct irq_chip_type *ct;\r\nchip->irq_gc = irq_alloc_generic_chip("gpio-pl061", 1, irq_base,\r\nchip->base, handle_simple_irq);\r\nchip->irq_gc->private = chip;\r\nct = chip->irq_gc->chip_types;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_set_type = pl061_irq_type;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\nct->regs.mask = GPIOIE;\r\nirq_setup_generic_chip(chip->irq_gc, IRQ_MSK(PL061_GPIO_NR),\r\nIRQ_GC_INIT_NESTED_LOCK, IRQ_NOREQUEST, 0);\r\n}\r\nstatic int pl061_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct pl061_platform_data *pdata;\r\nstruct pl061_gpio *chip;\r\nint ret, irq, i;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\npdata = dev->dev.platform_data;\r\nif (pdata) {\r\nchip->gc.base = pdata->gpio_base;\r\nchip->irq_base = pdata->irq_base;\r\n} else if (dev->dev.of_node) {\r\nchip->gc.base = -1;\r\nchip->irq_base = 0;\r\n} else {\r\nret = -ENODEV;\r\ngoto free_mem;\r\n}\r\nif (!request_mem_region(dev->res.start,\r\nresource_size(&dev->res), "pl061")) {\r\nret = -EBUSY;\r\ngoto free_mem;\r\n}\r\nchip->base = ioremap(dev->res.start, resource_size(&dev->res));\r\nif (chip->base == NULL) {\r\nret = -ENOMEM;\r\ngoto release_region;\r\n}\r\nspin_lock_init(&chip->lock);\r\nchip->gc.direction_input = pl061_direction_input;\r\nchip->gc.direction_output = pl061_direction_output;\r\nchip->gc.get = pl061_get_value;\r\nchip->gc.set = pl061_set_value;\r\nchip->gc.to_irq = pl061_to_irq;\r\nchip->gc.ngpio = PL061_GPIO_NR;\r\nchip->gc.label = dev_name(&dev->dev);\r\nchip->gc.dev = &dev->dev;\r\nchip->gc.owner = THIS_MODULE;\r\nret = gpiochip_add(&chip->gc);\r\nif (ret)\r\ngoto iounmap;\r\nif (chip->irq_base <= 0)\r\nreturn 0;\r\npl061_init_gc(chip, chip->irq_base);\r\nwriteb(0, chip->base + GPIOIE);\r\nirq = dev->irq[0];\r\nif (irq < 0) {\r\nret = -ENODEV;\r\ngoto iounmap;\r\n}\r\nirq_set_chained_handler(irq, pl061_irq_handler);\r\nirq_set_handler_data(irq, chip);\r\nfor (i = 0; i < PL061_GPIO_NR; i++) {\r\nif (pdata) {\r\nif (pdata->directions & (1 << i))\r\npl061_direction_output(&chip->gc, i,\r\npdata->values & (1 << i));\r\nelse\r\npl061_direction_input(&chip->gc, i);\r\n}\r\n}\r\namba_set_drvdata(dev, chip);\r\nreturn 0;\r\niounmap:\r\niounmap(chip->base);\r\nrelease_region:\r\nrelease_mem_region(dev->res.start, resource_size(&dev->res));\r\nfree_mem:\r\nkfree(chip);\r\nreturn ret;\r\n}\r\nstatic int pl061_suspend(struct device *dev)\r\n{\r\nstruct pl061_gpio *chip = dev_get_drvdata(dev);\r\nint offset;\r\nchip->csave_regs.gpio_data = 0;\r\nchip->csave_regs.gpio_dir = readb(chip->base + GPIODIR);\r\nchip->csave_regs.gpio_is = readb(chip->base + GPIOIS);\r\nchip->csave_regs.gpio_ibe = readb(chip->base + GPIOIBE);\r\nchip->csave_regs.gpio_iev = readb(chip->base + GPIOIEV);\r\nchip->csave_regs.gpio_ie = readb(chip->base + GPIOIE);\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (chip->csave_regs.gpio_dir & (1 << offset))\r\nchip->csave_regs.gpio_data |=\r\npl061_get_value(&chip->gc, offset) << offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pl061_resume(struct device *dev)\r\n{\r\nstruct pl061_gpio *chip = dev_get_drvdata(dev);\r\nint offset;\r\nfor (offset = 0; offset < PL061_GPIO_NR; offset++) {\r\nif (chip->csave_regs.gpio_dir & (1 << offset))\r\npl061_direction_output(&chip->gc, offset,\r\nchip->csave_regs.gpio_data &\r\n(1 << offset));\r\nelse\r\npl061_direction_input(&chip->gc, offset);\r\n}\r\nwriteb(chip->csave_regs.gpio_is, chip->base + GPIOIS);\r\nwriteb(chip->csave_regs.gpio_ibe, chip->base + GPIOIBE);\r\nwriteb(chip->csave_regs.gpio_iev, chip->base + GPIOIEV);\r\nwriteb(chip->csave_regs.gpio_ie, chip->base + GPIOIE);\r\nreturn 0;\r\n}\r\nstatic int __init pl061_gpio_init(void)\r\n{\r\nreturn amba_driver_register(&pl061_gpio_driver);\r\n}
