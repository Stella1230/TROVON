static inline struct Scsi_Host *virtio_scsi_host(struct virtio_device *vdev)\r\n{\r\nreturn vdev->priv;\r\n}\r\nstatic void virtscsi_compute_resid(struct scsi_cmnd *sc, u32 resid)\r\n{\r\nif (!resid)\r\nreturn;\r\nif (!scsi_bidi_cmnd(sc)) {\r\nscsi_set_resid(sc, resid);\r\nreturn;\r\n}\r\nscsi_in(sc)->resid = min(resid, scsi_in(sc)->length);\r\nscsi_out(sc)->resid = resid - scsi_in(sc)->resid;\r\n}\r\nstatic void virtscsi_complete_cmd(void *buf)\r\n{\r\nstruct virtio_scsi_cmd *cmd = buf;\r\nstruct scsi_cmnd *sc = cmd->sc;\r\nstruct virtio_scsi_cmd_resp *resp = &cmd->resp.cmd;\r\ndev_dbg(&sc->device->sdev_gendev,\r\n"cmd %p response %u status %#02x sense_len %u\n",\r\nsc, resp->response, resp->status, resp->sense_len);\r\nsc->result = resp->status;\r\nvirtscsi_compute_resid(sc, resp->resid);\r\nswitch (resp->response) {\r\ncase VIRTIO_SCSI_S_OK:\r\nset_host_byte(sc, DID_OK);\r\nbreak;\r\ncase VIRTIO_SCSI_S_OVERRUN:\r\nset_host_byte(sc, DID_ERROR);\r\nbreak;\r\ncase VIRTIO_SCSI_S_ABORTED:\r\nset_host_byte(sc, DID_ABORT);\r\nbreak;\r\ncase VIRTIO_SCSI_S_BAD_TARGET:\r\nset_host_byte(sc, DID_BAD_TARGET);\r\nbreak;\r\ncase VIRTIO_SCSI_S_RESET:\r\nset_host_byte(sc, DID_RESET);\r\nbreak;\r\ncase VIRTIO_SCSI_S_BUSY:\r\nset_host_byte(sc, DID_BUS_BUSY);\r\nbreak;\r\ncase VIRTIO_SCSI_S_TRANSPORT_FAILURE:\r\nset_host_byte(sc, DID_TRANSPORT_DISRUPTED);\r\nbreak;\r\ncase VIRTIO_SCSI_S_TARGET_FAILURE:\r\nset_host_byte(sc, DID_TARGET_FAILURE);\r\nbreak;\r\ncase VIRTIO_SCSI_S_NEXUS_FAILURE:\r\nset_host_byte(sc, DID_NEXUS_FAILURE);\r\nbreak;\r\ndefault:\r\nscmd_printk(KERN_WARNING, sc, "Unknown response %d",\r\nresp->response);\r\ncase VIRTIO_SCSI_S_FAILURE:\r\nset_host_byte(sc, DID_ERROR);\r\nbreak;\r\n}\r\nWARN_ON(resp->sense_len > VIRTIO_SCSI_SENSE_SIZE);\r\nif (sc->sense_buffer) {\r\nmemcpy(sc->sense_buffer, resp->sense,\r\nmin_t(u32, resp->sense_len, VIRTIO_SCSI_SENSE_SIZE));\r\nif (resp->sense_len)\r\nset_driver_byte(sc, DRIVER_SENSE);\r\n}\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\nsc->scsi_done(sc);\r\n}\r\nstatic void virtscsi_vq_done(struct virtqueue *vq, void (*fn)(void *buf))\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nvoid *buf;\r\nunsigned long flags;\r\nunsigned int len;\r\nspin_lock_irqsave(&vscsi->vq_lock, flags);\r\ndo {\r\nvirtqueue_disable_cb(vq);\r\nwhile ((buf = virtqueue_get_buf(vq, &len)) != NULL)\r\nfn(buf);\r\n} while (!virtqueue_enable_cb(vq));\r\nspin_unlock_irqrestore(&vscsi->vq_lock, flags);\r\n}\r\nstatic void virtscsi_req_done(struct virtqueue *vq)\r\n{\r\nvirtscsi_vq_done(vq, virtscsi_complete_cmd);\r\n}\r\nstatic void virtscsi_complete_free(void *buf)\r\n{\r\nstruct virtio_scsi_cmd *cmd = buf;\r\nif (cmd->comp)\r\ncomplete_all(cmd->comp);\r\nelse\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\n}\r\nstatic void virtscsi_ctrl_done(struct virtqueue *vq)\r\n{\r\nvirtscsi_vq_done(vq, virtscsi_complete_free);\r\n}\r\nstatic void virtscsi_event_done(struct virtqueue *vq)\r\n{\r\nvirtscsi_vq_done(vq, virtscsi_complete_free);\r\n}\r\nstatic void virtscsi_map_sgl(struct scatterlist *sg, unsigned int *p_idx,\r\nstruct scsi_data_buffer *sdb)\r\n{\r\nstruct sg_table *table = &sdb->table;\r\nstruct scatterlist *sg_elem;\r\nunsigned int idx = *p_idx;\r\nint i;\r\nfor_each_sg(table->sgl, sg_elem, table->nents, i)\r\nsg_set_buf(&sg[idx++], sg_virt(sg_elem), sg_elem->length);\r\n*p_idx = idx;\r\n}\r\nstatic void virtscsi_map_cmd(struct virtio_scsi *vscsi,\r\nstruct virtio_scsi_cmd *cmd,\r\nunsigned *out_num, unsigned *in_num,\r\nsize_t req_size, size_t resp_size)\r\n{\r\nstruct scsi_cmnd *sc = cmd->sc;\r\nstruct scatterlist *sg = vscsi->sg;\r\nunsigned int idx = 0;\r\nif (sc) {\r\nstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\r\nBUG_ON(scsi_sg_count(sc) > shost->sg_tablesize);\r\nBUG_ON(sc->sc_data_direction == DMA_BIDIRECTIONAL);\r\n}\r\nsg_set_buf(&sg[idx++], &cmd->req, req_size);\r\nif (sc && sc->sc_data_direction != DMA_FROM_DEVICE)\r\nvirtscsi_map_sgl(sg, &idx, scsi_out(sc));\r\n*out_num = idx;\r\nsg_set_buf(&sg[idx++], &cmd->resp, resp_size);\r\nif (sc && sc->sc_data_direction != DMA_TO_DEVICE)\r\nvirtscsi_map_sgl(sg, &idx, scsi_in(sc));\r\n*in_num = idx - *out_num;\r\n}\r\nstatic int virtscsi_kick_cmd(struct virtio_scsi *vscsi, struct virtqueue *vq,\r\nstruct virtio_scsi_cmd *cmd,\r\nsize_t req_size, size_t resp_size, gfp_t gfp)\r\n{\r\nunsigned int out_num, in_num;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&vscsi->vq_lock, flags);\r\nvirtscsi_map_cmd(vscsi, cmd, &out_num, &in_num, req_size, resp_size);\r\nret = virtqueue_add_buf(vq, vscsi->sg, out_num, in_num, cmd, gfp);\r\nif (ret >= 0)\r\nvirtqueue_kick(vq);\r\nspin_unlock_irqrestore(&vscsi->vq_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\r\n{\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nstruct virtio_scsi_cmd *cmd;\r\nint ret;\r\ndev_dbg(&sc->device->sdev_gendev,\r\n"cmd %p CDB: %#02x\n", sc, sc->cmnd[0]);\r\nret = SCSI_MLQUEUE_HOST_BUSY;\r\ncmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);\r\nif (!cmd)\r\ngoto out;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sc = sc;\r\ncmd->req.cmd = (struct virtio_scsi_cmd_req){\r\n.lun[0] = 1,\r\n.lun[1] = sc->device->id,\r\n.lun[2] = (sc->device->lun >> 8) | 0x40,\r\n.lun[3] = sc->device->lun & 0xff,\r\n.tag = (unsigned long)sc,\r\n.task_attr = VIRTIO_SCSI_S_SIMPLE,\r\n.prio = 0,\r\n.crn = 0,\r\n};\r\nBUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);\r\nmemcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);\r\nif (virtscsi_kick_cmd(vscsi, vscsi->req_vq, cmd,\r\nsizeof cmd->req.cmd, sizeof cmd->resp.cmd,\r\nGFP_ATOMIC) >= 0)\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int virtscsi_tmf(struct virtio_scsi *vscsi, struct virtio_scsi_cmd *cmd)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nint ret = FAILED;\r\ncmd->comp = &comp;\r\nif (virtscsi_kick_cmd(vscsi, vscsi->ctrl_vq, cmd,\r\nsizeof cmd->req.tmf, sizeof cmd->resp.tmf,\r\nGFP_NOIO) < 0)\r\ngoto out;\r\nwait_for_completion(&comp);\r\nif (cmd->resp.tmf.response == VIRTIO_SCSI_S_OK ||\r\ncmd->resp.tmf.response == VIRTIO_SCSI_S_FUNCTION_SUCCEEDED)\r\nret = SUCCESS;\r\nout:\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\nreturn ret;\r\n}\r\nstatic int virtscsi_device_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct virtio_scsi *vscsi = shost_priv(sc->device->host);\r\nstruct virtio_scsi_cmd *cmd;\r\nsdev_printk(KERN_INFO, sc->device, "device reset\n");\r\ncmd = mempool_alloc(virtscsi_cmd_pool, GFP_NOIO);\r\nif (!cmd)\r\nreturn FAILED;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sc = sc;\r\ncmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){\r\n.type = VIRTIO_SCSI_T_TMF,\r\n.subtype = VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET,\r\n.lun[0] = 1,\r\n.lun[1] = sc->device->id,\r\n.lun[2] = (sc->device->lun >> 8) | 0x40,\r\n.lun[3] = sc->device->lun & 0xff,\r\n};\r\nreturn virtscsi_tmf(vscsi, cmd);\r\n}\r\nstatic int virtscsi_abort(struct scsi_cmnd *sc)\r\n{\r\nstruct virtio_scsi *vscsi = shost_priv(sc->device->host);\r\nstruct virtio_scsi_cmd *cmd;\r\nscmd_printk(KERN_INFO, sc, "abort\n");\r\ncmd = mempool_alloc(virtscsi_cmd_pool, GFP_NOIO);\r\nif (!cmd)\r\nreturn FAILED;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sc = sc;\r\ncmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){\r\n.type = VIRTIO_SCSI_T_TMF,\r\n.subtype = VIRTIO_SCSI_T_TMF_ABORT_TASK,\r\n.lun[0] = 1,\r\n.lun[1] = sc->device->id,\r\n.lun[2] = (sc->device->lun >> 8) | 0x40,\r\n.lun[3] = sc->device->lun & 0xff,\r\n.tag = (unsigned long)sc,\r\n};\r\nreturn virtscsi_tmf(vscsi, cmd);\r\n}\r\nstatic int virtscsi_init(struct virtio_device *vdev,\r\nstruct virtio_scsi *vscsi)\r\n{\r\nint err;\r\nstruct virtqueue *vqs[3];\r\nvq_callback_t *callbacks[] = {\r\nvirtscsi_ctrl_done,\r\nvirtscsi_event_done,\r\nvirtscsi_req_done\r\n};\r\nconst char *names[] = {\r\n"control",\r\n"event",\r\n"request"\r\n};\r\nerr = vdev->config->find_vqs(vdev, 3, vqs, callbacks, names);\r\nif (err)\r\nreturn err;\r\nvscsi->ctrl_vq = vqs[0];\r\nvscsi->event_vq = vqs[1];\r\nvscsi->req_vq = vqs[2];\r\nvirtscsi_config_set(vdev, cdb_size, VIRTIO_SCSI_CDB_SIZE);\r\nvirtscsi_config_set(vdev, sense_size, VIRTIO_SCSI_SENSE_SIZE);\r\nreturn 0;\r\n}\r\nstatic int __devinit virtscsi_probe(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct virtio_scsi *vscsi;\r\nint err;\r\nu32 sg_elems;\r\nu32 cmd_per_lun;\r\nsg_elems = virtscsi_config_get(vdev, seg_max) ?: 1;\r\nshost = scsi_host_alloc(&virtscsi_host_template,\r\nsizeof(*vscsi) + sizeof(vscsi->sg[0]) * (sg_elems + 2));\r\nif (!shost)\r\nreturn -ENOMEM;\r\nshost->sg_tablesize = sg_elems;\r\nvscsi = shost_priv(shost);\r\nvscsi->vdev = vdev;\r\nvdev->priv = shost;\r\nspin_lock_init(&vscsi->vq_lock);\r\nsg_init_table(vscsi->sg, sg_elems + 2);\r\nerr = virtscsi_init(vdev, vscsi);\r\nif (err)\r\ngoto virtscsi_init_failed;\r\ncmd_per_lun = virtscsi_config_get(vdev, cmd_per_lun) ?: 1;\r\nshost->cmd_per_lun = min_t(u32, cmd_per_lun, shost->can_queue);\r\nshost->max_sectors = virtscsi_config_get(vdev, max_sectors) ?: 0xFFFF;\r\nshost->max_lun = virtscsi_config_get(vdev, max_lun) + 1;\r\nshost->max_id = virtscsi_config_get(vdev, max_target) + 1;\r\nshost->max_channel = 0;\r\nshost->max_cmd_len = VIRTIO_SCSI_CDB_SIZE;\r\nerr = scsi_add_host(shost, &vdev->dev);\r\nif (err)\r\ngoto scsi_add_host_failed;\r\nscsi_scan_host(shost);\r\nreturn 0;\r\nscsi_add_host_failed:\r\nvdev->config->del_vqs(vdev);\r\nvirtscsi_init_failed:\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic void virtscsi_remove_vqs(struct virtio_device *vdev)\r\n{\r\nvdev->config->reset(vdev);\r\nvdev->config->del_vqs(vdev);\r\n}\r\nstatic void __devexit virtscsi_remove(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *shost = virtio_scsi_host(vdev);\r\nscsi_remove_host(shost);\r\nvirtscsi_remove_vqs(vdev);\r\nscsi_host_put(shost);\r\n}\r\nstatic int virtscsi_freeze(struct virtio_device *vdev)\r\n{\r\nvirtscsi_remove_vqs(vdev);\r\nreturn 0;\r\n}\r\nstatic int virtscsi_restore(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nreturn virtscsi_init(vdev, vscsi);\r\n}\r\nstatic int __init init(void)\r\n{\r\nint ret = -ENOMEM;\r\nvirtscsi_cmd_cache = KMEM_CACHE(virtio_scsi_cmd, 0);\r\nif (!virtscsi_cmd_cache) {\r\nprintk(KERN_ERR "kmem_cache_create() for "\r\n"virtscsi_cmd_cache failed\n");\r\ngoto error;\r\n}\r\nvirtscsi_cmd_pool =\r\nmempool_create_slab_pool(VIRTIO_SCSI_MEMPOOL_SZ,\r\nvirtscsi_cmd_cache);\r\nif (!virtscsi_cmd_pool) {\r\nprintk(KERN_ERR "mempool_create() for"\r\n"virtscsi_cmd_pool failed\n");\r\ngoto error;\r\n}\r\nret = register_virtio_driver(&virtio_scsi_driver);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nif (virtscsi_cmd_pool) {\r\nmempool_destroy(virtscsi_cmd_pool);\r\nvirtscsi_cmd_pool = NULL;\r\n}\r\nif (virtscsi_cmd_cache) {\r\nkmem_cache_destroy(virtscsi_cmd_cache);\r\nvirtscsi_cmd_cache = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit fini(void)\r\n{\r\nunregister_virtio_driver(&virtio_scsi_driver);\r\nmempool_destroy(virtscsi_cmd_pool);\r\nkmem_cache_destroy(virtscsi_cmd_cache);\r\n}
