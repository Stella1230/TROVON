static void isku_profile_activated(struct isku_device *isku, uint new_profile)\r\n{\r\nisku->actual_profile = new_profile;\r\n}\r\nstatic int isku_receive(struct usb_device *usb_dev, uint command,\r\nvoid *buf, uint size)\r\n{\r\nreturn roccat_common_receive(usb_dev, command, buf, size);\r\n}\r\nstatic int isku_receive_control_status(struct usb_device *usb_dev)\r\n{\r\nint retval;\r\nstruct isku_control control;\r\ndo {\r\nmsleep(50);\r\nretval = isku_receive(usb_dev, ISKU_COMMAND_CONTROL,\r\n&control, sizeof(struct isku_control));\r\nif (retval)\r\nreturn retval;\r\nswitch (control.value) {\r\ncase ISKU_CONTROL_VALUE_STATUS_OK:\r\nreturn 0;\r\ncase ISKU_CONTROL_VALUE_STATUS_WAIT:\r\ncontinue;\r\ncase ISKU_CONTROL_VALUE_STATUS_INVALID:\r\ncase ISKU_CONTROL_VALUE_STATUS_OVERLOAD:\r\nreturn -EINVAL;\r\ndefault:\r\nhid_err(usb_dev, "isku_receive_control_status: "\r\n"unknown response value 0x%x\n",\r\ncontrol.value);\r\nreturn -EINVAL;\r\n}\r\n} while (1);\r\n}\r\nstatic int isku_send(struct usb_device *usb_dev, uint command,\r\nvoid const *buf, uint size)\r\n{\r\nint retval;\r\nretval = roccat_common_send(usb_dev, command, buf, size);\r\nif (retval)\r\nreturn retval;\r\nreturn isku_receive_control_status(usb_dev);\r\n}\r\nstatic int isku_get_actual_profile(struct usb_device *usb_dev)\r\n{\r\nstruct isku_actual_profile buf;\r\nint retval;\r\nretval = isku_receive(usb_dev, ISKU_COMMAND_ACTUAL_PROFILE,\r\n&buf, sizeof(struct isku_actual_profile));\r\nreturn retval ? retval : buf.actual_profile;\r\n}\r\nstatic int isku_set_actual_profile(struct usb_device *usb_dev, int new_profile)\r\n{\r\nstruct isku_actual_profile buf;\r\nbuf.command = ISKU_COMMAND_ACTUAL_PROFILE;\r\nbuf.size = sizeof(struct isku_actual_profile);\r\nbuf.actual_profile = new_profile;\r\nreturn isku_send(usb_dev, ISKU_COMMAND_ACTUAL_PROFILE, &buf,\r\nsizeof(struct isku_actual_profile));\r\n}\r\nstatic ssize_t isku_sysfs_show_actual_profile(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct isku_device *isku =\r\nhid_get_drvdata(dev_get_drvdata(dev->parent->parent));\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", isku->actual_profile);\r\n}\r\nstatic ssize_t isku_sysfs_set_actual_profile(struct device *dev,\r\nstruct device_attribute *attr, char const *buf, size_t size)\r\n{\r\nstruct isku_device *isku;\r\nstruct usb_device *usb_dev;\r\nunsigned long profile;\r\nint retval;\r\nstruct isku_roccat_report roccat_report;\r\ndev = dev->parent->parent;\r\nisku = hid_get_drvdata(dev_get_drvdata(dev));\r\nusb_dev = interface_to_usbdev(to_usb_interface(dev));\r\nretval = strict_strtoul(buf, 10, &profile);\r\nif (retval)\r\nreturn retval;\r\nif (profile > 4)\r\nreturn -EINVAL;\r\nmutex_lock(&isku->isku_lock);\r\nretval = isku_set_actual_profile(usb_dev, profile);\r\nif (retval) {\r\nmutex_unlock(&isku->isku_lock);\r\nreturn retval;\r\n}\r\nisku_profile_activated(isku, profile);\r\nroccat_report.event = ISKU_REPORT_BUTTON_EVENT_PROFILE;\r\nroccat_report.data1 = profile + 1;\r\nroccat_report.data2 = 0;\r\nroccat_report.profile = profile + 1;\r\nroccat_report_event(isku->chrdev_minor, (uint8_t const *)&roccat_report);\r\nmutex_unlock(&isku->isku_lock);\r\nreturn size;\r\n}\r\nstatic ssize_t isku_sysfs_read(struct file *fp, struct kobject *kobj,\r\nchar *buf, loff_t off, size_t count,\r\nsize_t real_size, uint command)\r\n{\r\nstruct device *dev =\r\ncontainer_of(kobj, struct device, kobj)->parent->parent;\r\nstruct isku_device *isku = hid_get_drvdata(dev_get_drvdata(dev));\r\nstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\r\nint retval;\r\nif (off >= real_size)\r\nreturn 0;\r\nif (off != 0 || count != real_size)\r\nreturn -EINVAL;\r\nmutex_lock(&isku->isku_lock);\r\nretval = isku_receive(usb_dev, command, buf, real_size);\r\nmutex_unlock(&isku->isku_lock);\r\nreturn retval ? retval : real_size;\r\n}\r\nstatic ssize_t isku_sysfs_write(struct file *fp, struct kobject *kobj,\r\nvoid const *buf, loff_t off, size_t count,\r\nsize_t real_size, uint command)\r\n{\r\nstruct device *dev =\r\ncontainer_of(kobj, struct device, kobj)->parent->parent;\r\nstruct isku_device *isku = hid_get_drvdata(dev_get_drvdata(dev));\r\nstruct usb_device *usb_dev = interface_to_usbdev(to_usb_interface(dev));\r\nint retval;\r\nif (off != 0 || count != real_size)\r\nreturn -EINVAL;\r\nmutex_lock(&isku->isku_lock);\r\nretval = isku_send(usb_dev, command, (void *)buf, real_size);\r\nmutex_unlock(&isku->isku_lock);\r\nreturn retval ? retval : real_size;\r\n}\r\nstatic int isku_init_isku_device_struct(struct usb_device *usb_dev,\r\nstruct isku_device *isku)\r\n{\r\nint retval;\r\nmutex_init(&isku->isku_lock);\r\nretval = isku_get_actual_profile(usb_dev);\r\nif (retval < 0)\r\nreturn retval;\r\nisku_profile_activated(isku, retval);\r\nreturn 0;\r\n}\r\nstatic int isku_init_specials(struct hid_device *hdev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct isku_device *isku;\r\nint retval;\r\nif (intf->cur_altsetting->desc.bInterfaceProtocol\r\n!= ISKU_USB_INTERFACE_PROTOCOL) {\r\nhid_set_drvdata(hdev, NULL);\r\nreturn 0;\r\n}\r\nisku = kzalloc(sizeof(*isku), GFP_KERNEL);\r\nif (!isku) {\r\nhid_err(hdev, "can't alloc device descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\nhid_set_drvdata(hdev, isku);\r\nretval = isku_init_isku_device_struct(usb_dev, isku);\r\nif (retval) {\r\nhid_err(hdev, "couldn't init struct isku_device\n");\r\ngoto exit_free;\r\n}\r\nretval = roccat_connect(isku_class, hdev,\r\nsizeof(struct isku_roccat_report));\r\nif (retval < 0) {\r\nhid_err(hdev, "couldn't init char dev\n");\r\n} else {\r\nisku->chrdev_minor = retval;\r\nisku->roccat_claimed = 1;\r\n}\r\nreturn 0;\r\nexit_free:\r\nkfree(isku);\r\nreturn retval;\r\n}\r\nstatic void isku_remove_specials(struct hid_device *hdev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct isku_device *isku;\r\nif (intf->cur_altsetting->desc.bInterfaceProtocol\r\n!= ISKU_USB_INTERFACE_PROTOCOL)\r\nreturn;\r\nisku = hid_get_drvdata(hdev);\r\nif (isku->roccat_claimed)\r\nroccat_disconnect(isku->chrdev_minor);\r\nkfree(isku);\r\n}\r\nstatic int isku_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint retval;\r\nretval = hid_parse(hdev);\r\nif (retval) {\r\nhid_err(hdev, "parse failed\n");\r\ngoto exit;\r\n}\r\nretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (retval) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto exit;\r\n}\r\nretval = isku_init_specials(hdev);\r\nif (retval) {\r\nhid_err(hdev, "couldn't install keyboard\n");\r\ngoto exit_stop;\r\n}\r\nreturn 0;\r\nexit_stop:\r\nhid_hw_stop(hdev);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic void isku_remove(struct hid_device *hdev)\r\n{\r\nisku_remove_specials(hdev);\r\nhid_hw_stop(hdev);\r\n}\r\nstatic void isku_keep_values_up_to_date(struct isku_device *isku,\r\nu8 const *data)\r\n{\r\nstruct isku_report_button const *button_report;\r\nswitch (data[0]) {\r\ncase ISKU_REPORT_NUMBER_BUTTON:\r\nbutton_report = (struct isku_report_button const *)data;\r\nswitch (button_report->event) {\r\ncase ISKU_REPORT_BUTTON_EVENT_PROFILE:\r\nisku_profile_activated(isku, button_report->data1 - 1);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void isku_report_to_chrdev(struct isku_device const *isku,\r\nu8 const *data)\r\n{\r\nstruct isku_roccat_report roccat_report;\r\nstruct isku_report_button const *button_report;\r\nif (data[0] != ISKU_REPORT_NUMBER_BUTTON)\r\nreturn;\r\nbutton_report = (struct isku_report_button const *)data;\r\nroccat_report.event = button_report->event;\r\nroccat_report.data1 = button_report->data1;\r\nroccat_report.data2 = button_report->data2;\r\nroccat_report.profile = isku->actual_profile + 1;\r\nroccat_report_event(isku->chrdev_minor,\r\n(uint8_t const *)&roccat_report);\r\n}\r\nstatic int isku_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nstruct isku_device *isku = hid_get_drvdata(hdev);\r\nif (intf->cur_altsetting->desc.bInterfaceProtocol\r\n!= ISKU_USB_INTERFACE_PROTOCOL)\r\nreturn 0;\r\nif (isku == NULL)\r\nreturn 0;\r\nisku_keep_values_up_to_date(isku, data);\r\nif (isku->roccat_claimed)\r\nisku_report_to_chrdev(isku, data);\r\nreturn 0;\r\n}\r\nstatic int __init isku_init(void)\r\n{\r\nint retval;\r\nisku_class = class_create(THIS_MODULE, "isku");\r\nif (IS_ERR(isku_class))\r\nreturn PTR_ERR(isku_class);\r\nisku_class->dev_attrs = isku_attributes;\r\nisku_class->dev_bin_attrs = isku_bin_attributes;\r\nretval = hid_register_driver(&isku_driver);\r\nif (retval)\r\nclass_destroy(isku_class);\r\nreturn retval;\r\n}\r\nstatic void __exit isku_exit(void)\r\n{\r\nhid_unregister_driver(&isku_driver);\r\nclass_destroy(isku_class);\r\n}
