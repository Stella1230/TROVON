int wsp_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)\r\n{\r\nstruct pci_controller *phb;\r\nstruct msi_desc *entry;\r\nstruct msi_msg msg;\r\nunsigned int virq;\r\nint hwirq;\r\nphb = pci_bus_to_host(dev->bus);\r\nif (!phb)\r\nreturn -ENOENT;\r\nentry = list_first_entry(&dev->msi_list, struct msi_desc, list);\r\nif (entry->msi_attrib.is_64) {\r\nmsg.address_lo = 0;\r\nmsg.address_hi = MSI_ADDR_64 >> 32;\r\n} else {\r\nmsg.address_lo = MSI_ADDR_32;\r\nmsg.address_hi = 0;\r\n}\r\nlist_for_each_entry(entry, &dev->msi_list, list) {\r\nhwirq = wsp_ics_alloc_irq(phb->dn, 1);\r\nif (hwirq < 0) {\r\ndev_warn(&dev->dev, "wsp_msi: hwirq alloc failed!\n");\r\nreturn hwirq;\r\n}\r\nvirq = irq_create_mapping(NULL, hwirq);\r\nif (virq == NO_IRQ) {\r\ndev_warn(&dev->dev, "wsp_msi: virq alloc failed!\n");\r\nreturn -1;\r\n}\r\ndev_dbg(&dev->dev, "wsp_msi: allocated irq %#x/%#x\n",\r\nhwirq, virq);\r\nwsp_ics_set_msi_chip(virq);\r\nirq_set_msi_desc(virq, entry);\r\nmsg.data = hwirq & XIVE_ADDR_MASK;\r\nwrite_msi_msg(virq, &msg);\r\n}\r\nreturn 0;\r\n}\r\nvoid wsp_teardown_msi_irqs(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *phb;\r\nstruct msi_desc *entry;\r\nint hwirq;\r\nphb = pci_bus_to_host(dev->bus);\r\ndev_dbg(&dev->dev, "wsp_msi: tearing down msi irqs\n");\r\nlist_for_each_entry(entry, &dev->msi_list, list) {\r\nif (entry->irq == NO_IRQ)\r\ncontinue;\r\nirq_set_msi_desc(entry->irq, NULL);\r\nwsp_ics_set_std_chip(entry->irq);\r\nhwirq = virq_to_hw(entry->irq);\r\nirq_dispose_mapping(entry->irq);\r\nwsp_ics_free_irq(phb->dn, hwirq);\r\n}\r\n}\r\nvoid wsp_setup_phb_msi(struct pci_controller *phb)\r\n{\r\nout_be64(phb->cfg_data + PCIE_REG_IODA_ADDR, PCIE_REG_IODA_AD_TBL_MVT);\r\nout_be64(phb->cfg_data + PCIE_REG_IODA_DATA0, 1ull << 63);\r\nppc_md.setup_msi_irqs = wsp_setup_msi_irqs;\r\nppc_md.teardown_msi_irqs = wsp_teardown_msi_irqs;\r\n}
