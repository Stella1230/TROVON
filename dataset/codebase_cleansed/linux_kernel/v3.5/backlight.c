int pmac_has_backlight_type(const char *type)\r\n{\r\nstruct device_node* bk_node = of_find_node_by_name(NULL, "backlight");\r\nif (bk_node) {\r\nconst char *prop = of_get_property(bk_node,\r\n"backlight-control", NULL);\r\nif (prop && strncmp(prop, type, strlen(type)) == 0) {\r\nof_node_put(bk_node);\r\nreturn 1;\r\n}\r\nof_node_put(bk_node);\r\n}\r\nreturn 0;\r\n}\r\nint pmac_backlight_curve_lookup(struct fb_info *info, int value)\r\n{\r\nint level = (FB_BACKLIGHT_LEVELS - 1);\r\nif (info && info->bl_dev) {\r\nint i, max = 0;\r\nfor (i = 0; i < FB_BACKLIGHT_LEVELS; i++)\r\nmax = max((int)info->bl_curve[i], max);\r\nfor (i = 0; i < FB_BACKLIGHT_LEVELS; i++) {\r\nint diff = abs(info->bl_curve[i] - value);\r\nif (diff < max) {\r\nmax = diff;\r\nlevel = i;\r\n}\r\n}\r\n}\r\nreturn level;\r\n}\r\nstatic void pmac_backlight_key_worker(struct work_struct *work)\r\n{\r\nif (atomic_read(&kernel_backlight_disabled))\r\nreturn;\r\nmutex_lock(&pmac_backlight_mutex);\r\nif (pmac_backlight) {\r\nstruct backlight_properties *props;\r\nint brightness;\r\nprops = &pmac_backlight->props;\r\nbrightness = props->brightness +\r\n((pmac_backlight_key_queued?-1:1) *\r\n(props->max_brightness / 15));\r\nif (brightness < 0)\r\nbrightness = 0;\r\nelse if (brightness > props->max_brightness)\r\nbrightness = props->max_brightness;\r\nprops->brightness = brightness;\r\nbacklight_update_status(pmac_backlight);\r\n}\r\nmutex_unlock(&pmac_backlight_mutex);\r\n}\r\nvoid pmac_backlight_key(int direction)\r\n{\r\nif (atomic_read(&kernel_backlight_disabled))\r\nreturn;\r\npmac_backlight_key_queued = direction;\r\nschedule_work(&pmac_backlight_key_work);\r\n}\r\nstatic int __pmac_backlight_set_legacy_brightness(int brightness)\r\n{\r\nint error = -ENXIO;\r\nmutex_lock(&pmac_backlight_mutex);\r\nif (pmac_backlight) {\r\nstruct backlight_properties *props;\r\nprops = &pmac_backlight->props;\r\nprops->brightness = brightness *\r\n(props->max_brightness + 1) /\r\n(OLD_BACKLIGHT_MAX + 1);\r\nif (props->brightness > props->max_brightness)\r\nprops->brightness = props->max_brightness;\r\nelse if (props->brightness < 0)\r\nprops->brightness = 0;\r\nbacklight_update_status(pmac_backlight);\r\nerror = 0;\r\n}\r\nmutex_unlock(&pmac_backlight_mutex);\r\nreturn error;\r\n}\r\nstatic void pmac_backlight_set_legacy_worker(struct work_struct *work)\r\n{\r\nif (atomic_read(&kernel_backlight_disabled))\r\nreturn;\r\n__pmac_backlight_set_legacy_brightness(pmac_backlight_set_legacy_queued);\r\n}\r\nvoid pmac_backlight_set_legacy_brightness_pmu(int brightness) {\r\nif (atomic_read(&kernel_backlight_disabled))\r\nreturn;\r\npmac_backlight_set_legacy_queued = brightness;\r\nschedule_work(&pmac_backlight_set_legacy_work);\r\n}\r\nint pmac_backlight_set_legacy_brightness(int brightness)\r\n{\r\nreturn __pmac_backlight_set_legacy_brightness(brightness);\r\n}\r\nint pmac_backlight_get_legacy_brightness()\r\n{\r\nint result = -ENXIO;\r\nmutex_lock(&pmac_backlight_mutex);\r\nif (pmac_backlight) {\r\nstruct backlight_properties *props;\r\nprops = &pmac_backlight->props;\r\nresult = props->brightness *\r\n(OLD_BACKLIGHT_MAX + 1) /\r\n(props->max_brightness + 1);\r\n}\r\nmutex_unlock(&pmac_backlight_mutex);\r\nreturn result;\r\n}\r\nvoid pmac_backlight_disable()\r\n{\r\natomic_inc(&kernel_backlight_disabled);\r\n}\r\nvoid pmac_backlight_enable()\r\n{\r\natomic_dec(&kernel_backlight_disabled);\r\n}
