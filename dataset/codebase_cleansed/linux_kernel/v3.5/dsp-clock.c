static inline u32 is_dsp_clk_active(u32 clk, u8 id)\r\n{\r\nreturn clk & (1 << id);\r\n}\r\nstatic inline void set_dsp_clk_active(u32 *clk, u8 id)\r\n{\r\n*clk |= (1 << id);\r\n}\r\nstatic inline void set_dsp_clk_inactive(u32 *clk, u8 id)\r\n{\r\n*clk &= ~(1 << id);\r\n}\r\nstatic s8 get_clk_type(u8 id)\r\n{\r\ns8 type;\r\nif (id == DSP_CLK_IVA2)\r\ntype = IVA2_CLK;\r\nelse if (id <= DSP_CLK_GPT8)\r\ntype = GPT_CLK;\r\nelse if (id == DSP_CLK_WDT3)\r\ntype = WDT_CLK;\r\nelse if (id <= DSP_CLK_MCBSP5)\r\ntype = MCBSP_CLK;\r\nelse if (id == DSP_CLK_SSI)\r\ntype = SSI_CLK;\r\nelse\r\ntype = -1;\r\nreturn type;\r\n}\r\nvoid dsp_clk_exit(void)\r\n{\r\nint i;\r\ndsp_clock_disable_all(dsp_clocks);\r\nfor (i = 0; i < DM_TIMER_CLOCKS; i++)\r\nomap_dm_timer_free(timer[i]);\r\nclk_put(iva2_clk);\r\nclk_put(ssi.sst_fck);\r\nclk_put(ssi.ssr_fck);\r\nclk_put(ssi.ick);\r\n}\r\nvoid dsp_clk_init(void)\r\n{\r\nstatic struct platform_device dspbridge_device;\r\nint i, id;\r\ndspbridge_device.dev.bus = &platform_bus_type;\r\nfor (i = 0, id = 5; i < DM_TIMER_CLOCKS; i++, id++)\r\ntimer[i] = omap_dm_timer_request_specific(id);\r\niva2_clk = clk_get(&dspbridge_device.dev, "iva2_ck");\r\nif (IS_ERR(iva2_clk))\r\ndev_err(bridge, "failed to get iva2 clock %p\n", iva2_clk);\r\nssi.sst_fck = clk_get(&dspbridge_device.dev, "ssi_sst_fck");\r\nssi.ssr_fck = clk_get(&dspbridge_device.dev, "ssi_ssr_fck");\r\nssi.ick = clk_get(&dspbridge_device.dev, "ssi_ick");\r\nif (IS_ERR(ssi.sst_fck) || IS_ERR(ssi.ssr_fck) || IS_ERR(ssi.ick))\r\ndev_err(bridge, "failed to get ssi: sst %p, ssr %p, ick %p\n",\r\nssi.sst_fck, ssi.ssr_fck, ssi.ick);\r\n}\r\nvoid dsp_gpt_wait_overflow(short int clk_id, unsigned int load)\r\n{\r\nstruct omap_dm_timer *gpt = timer[clk_id - 1];\r\nunsigned long timeout;\r\nif (!gpt)\r\nreturn;\r\nomap_dm_timer_set_int_enable(gpt, OMAP_TIMER_INT_OVERFLOW);\r\nomap_dm_timer_set_load_start(gpt, 0, load);\r\nudelay(80);\r\ntimeout = msecs_to_jiffies(5);\r\nwhile (!(omap_dm_timer_read_status(gpt) & OMAP_TIMER_INT_OVERFLOW)) {\r\nif (time_is_after_jiffies(timeout)) {\r\npr_err("%s: GPTimer interrupt failed\n", __func__);\r\nbreak;\r\n}\r\n}\r\n}\r\nint dsp_clk_enable(enum dsp_clk_id clk_id)\r\n{\r\nint status = 0;\r\nif (is_dsp_clk_active(dsp_clocks, clk_id)) {\r\ndev_err(bridge, "WARN: clock id %d already enabled\n", clk_id);\r\ngoto out;\r\n}\r\nswitch (get_clk_type(clk_id)) {\r\ncase IVA2_CLK:\r\nclk_enable(iva2_clk);\r\nbreak;\r\ncase GPT_CLK:\r\nstatus = omap_dm_timer_start(timer[clk_id - 1]);\r\nbreak;\r\n#ifdef CONFIG_OMAP_MCBSP\r\ncase MCBSP_CLK:\r\nomap_mcbsp_request(MCBSP_ID(clk_id));\r\nomap2_mcbsp_set_clks_src(MCBSP_ID(clk_id), MCBSP_CLKS_PAD_SRC);\r\nbreak;\r\n#endif\r\ncase WDT_CLK:\r\ndev_err(bridge, "ERROR: DSP requested to enable WDT3 clk\n");\r\nbreak;\r\ncase SSI_CLK:\r\nclk_enable(ssi.sst_fck);\r\nclk_enable(ssi.ssr_fck);\r\nclk_enable(ssi.ick);\r\nssi_clk_prepare(true);\r\nbreak;\r\ndefault:\r\ndev_err(bridge, "Invalid clock id for enable\n");\r\nstatus = -EPERM;\r\n}\r\nif (!status)\r\nset_dsp_clk_active(&dsp_clocks, clk_id);\r\nout:\r\nreturn status;\r\n}\r\nu32 dsp_clock_enable_all(u32 dsp_per_clocks)\r\n{\r\nu32 clk_id;\r\nu32 status = -EPERM;\r\nfor (clk_id = 0; clk_id < DSP_CLK_NOT_DEFINED; clk_id++) {\r\nif (is_dsp_clk_active(dsp_per_clocks, clk_id))\r\nstatus = dsp_clk_enable(clk_id);\r\n}\r\nreturn status;\r\n}\r\nint dsp_clk_disable(enum dsp_clk_id clk_id)\r\n{\r\nint status = 0;\r\nif (!is_dsp_clk_active(dsp_clocks, clk_id)) {\r\ndev_err(bridge, "ERR: clock id %d already disabled\n", clk_id);\r\ngoto out;\r\n}\r\nswitch (get_clk_type(clk_id)) {\r\ncase IVA2_CLK:\r\nclk_disable(iva2_clk);\r\nbreak;\r\ncase GPT_CLK:\r\nstatus = omap_dm_timer_stop(timer[clk_id - 1]);\r\nbreak;\r\n#ifdef CONFIG_OMAP_MCBSP\r\ncase MCBSP_CLK:\r\nomap2_mcbsp_set_clks_src(MCBSP_ID(clk_id), MCBSP_CLKS_PRCM_SRC);\r\nomap_mcbsp_free(MCBSP_ID(clk_id));\r\nbreak;\r\n#endif\r\ncase WDT_CLK:\r\ndev_err(bridge, "ERROR: DSP requested to disable WDT3 clk\n");\r\nbreak;\r\ncase SSI_CLK:\r\nssi_clk_prepare(false);\r\nssi_clk_prepare(false);\r\nclk_disable(ssi.sst_fck);\r\nclk_disable(ssi.ssr_fck);\r\nclk_disable(ssi.ick);\r\nbreak;\r\ndefault:\r\ndev_err(bridge, "Invalid clock id for disable\n");\r\nstatus = -EPERM;\r\n}\r\nif (!status)\r\nset_dsp_clk_inactive(&dsp_clocks, clk_id);\r\nout:\r\nreturn status;\r\n}\r\nu32 dsp_clock_disable_all(u32 dsp_per_clocks)\r\n{\r\nu32 clk_id;\r\nu32 status = -EPERM;\r\nfor (clk_id = 0; clk_id < DSP_CLK_NOT_DEFINED; clk_id++) {\r\nif (is_dsp_clk_active(dsp_per_clocks, clk_id))\r\nstatus = dsp_clk_disable(clk_id);\r\n}\r\nreturn status;\r\n}\r\nu32 dsp_clk_get_iva2_rate(void)\r\n{\r\nu32 clk_speed_khz;\r\nclk_speed_khz = clk_get_rate(iva2_clk);\r\nclk_speed_khz /= 1000;\r\ndev_dbg(bridge, "%s: clk speed Khz = %d\n", __func__, clk_speed_khz);\r\nreturn clk_speed_khz;\r\n}\r\nvoid ssi_clk_prepare(bool FLAG)\r\n{\r\nvoid __iomem *ssi_base;\r\nunsigned int value;\r\nssi_base = ioremap(L4_34XX_BASE + OMAP_SSI_OFFSET, OMAP_SSI_SIZE);\r\nif (!ssi_base) {\r\npr_err("%s: error, SSI not configured\n", __func__);\r\nreturn;\r\n}\r\nif (FLAG) {\r\nvalue = SSI_AUTOIDLE | SSI_SIDLE_SMARTIDLE | SSI_MIDLE_NOIDLE;\r\n} else {\r\nvalue = SSI_AUTOIDLE;\r\n}\r\n__raw_writel(value, ssi_base + OMAP_SSI_SYSCONFIG_OFFSET);\r\niounmap(ssi_base);\r\n}
