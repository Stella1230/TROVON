int oz_elt_buf_init(struct oz_elt_buf *buf)\r\n{\r\nmemset(buf, 0, sizeof(struct oz_elt_buf));\r\nINIT_LIST_HEAD(&buf->stream_list);\r\nINIT_LIST_HEAD(&buf->order_list);\r\nINIT_LIST_HEAD(&buf->isoc_list);\r\nbuf->max_free_elts = 32;\r\nspin_lock_init(&buf->lock);\r\nreturn 0;\r\n}\r\nvoid oz_elt_buf_term(struct oz_elt_buf *buf)\r\n{\r\nstruct list_head *e;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nstruct list_head *list;\r\nif (i)\r\nlist = &buf->order_list;\r\nelse\r\nlist = &buf->isoc_list;\r\ne = list->next;\r\nwhile (e != list) {\r\nstruct oz_elt_info *ei =\r\ncontainer_of(e, struct oz_elt_info, link_order);\r\ne = e->next;\r\nkfree(ei);\r\n}\r\n}\r\nwhile (buf->elt_pool) {\r\nstruct oz_elt_info *ei =\r\ncontainer_of(buf->elt_pool, struct oz_elt_info, link);\r\nbuf->elt_pool = buf->elt_pool->next;\r\nkfree(ei);\r\n}\r\nbuf->free_elts = 0;\r\n}\r\nstruct oz_elt_info *oz_elt_info_alloc(struct oz_elt_buf *buf)\r\n{\r\nstruct oz_elt_info *ei = 0;\r\nspin_lock_bh(&buf->lock);\r\nif (buf->free_elts && buf->elt_pool) {\r\nei = container_of(buf->elt_pool, struct oz_elt_info, link);\r\nbuf->elt_pool = ei->link.next;\r\nbuf->free_elts--;\r\nspin_unlock_bh(&buf->lock);\r\nif (ei->magic != OZ_ELT_INFO_MAGIC_FREE) {\r\noz_trace("oz_elt_info_alloc: ei with bad magic: 0x%x\n",\r\nei->magic);\r\n}\r\n} else {\r\nspin_unlock_bh(&buf->lock);\r\nei = kmalloc(sizeof(struct oz_elt_info), GFP_ATOMIC);\r\n}\r\nif (ei) {\r\nei->flags = 0;\r\nei->app_id = 0;\r\nei->callback = 0;\r\nei->context = 0;\r\nei->stream = 0;\r\nei->magic = OZ_ELT_INFO_MAGIC_USED;\r\nINIT_LIST_HEAD(&ei->link);\r\nINIT_LIST_HEAD(&ei->link_order);\r\n}\r\nreturn ei;\r\n}\r\nvoid oz_elt_info_free(struct oz_elt_buf *buf, struct oz_elt_info *ei)\r\n{\r\nif (ei) {\r\nif (ei->magic == OZ_ELT_INFO_MAGIC_USED) {\r\nbuf->free_elts++;\r\nei->link.next = buf->elt_pool;\r\nbuf->elt_pool = &ei->link;\r\nei->magic = OZ_ELT_INFO_MAGIC_FREE;\r\n} else {\r\noz_trace("oz_elt_info_free: bad magic ei: %p"\r\n" magic: 0x%x\n",\r\nei, ei->magic);\r\n}\r\n}\r\n}\r\nvoid oz_elt_info_free_chain(struct oz_elt_buf *buf, struct list_head *list)\r\n{\r\nstruct list_head *e;\r\ne = list->next;\r\nspin_lock_bh(&buf->lock);\r\nwhile (e != list) {\r\nstruct oz_elt_info *ei;\r\nei = container_of(e, struct oz_elt_info, link);\r\ne = e->next;\r\noz_elt_info_free(buf, ei);\r\n}\r\nspin_unlock_bh(&buf->lock);\r\n}\r\nint oz_elt_stream_create(struct oz_elt_buf *buf, u8 id, int max_buf_count)\r\n{\r\nstruct oz_elt_stream *st;\r\noz_trace("oz_elt_stream_create(0x%x)\n", id);\r\nst = kzalloc(sizeof(struct oz_elt_stream), GFP_ATOMIC | __GFP_ZERO);\r\nif (st == 0)\r\nreturn -ENOMEM;\r\natomic_set(&st->ref_count, 1);\r\nst->id = id;\r\nst->max_buf_count = max_buf_count;\r\nINIT_LIST_HEAD(&st->elt_list);\r\nspin_lock_bh(&buf->lock);\r\nlist_add_tail(&st->link, &buf->stream_list);\r\nspin_unlock_bh(&buf->lock);\r\nreturn 0;\r\n}\r\nint oz_elt_stream_delete(struct oz_elt_buf *buf, u8 id)\r\n{\r\nstruct list_head *e;\r\nstruct oz_elt_stream *st;\r\noz_trace("oz_elt_stream_delete(0x%x)\n", id);\r\nspin_lock_bh(&buf->lock);\r\ne = buf->stream_list.next;\r\nwhile (e != &buf->stream_list) {\r\nst = container_of(e, struct oz_elt_stream, link);\r\nif (st->id == id) {\r\nlist_del(e);\r\nbreak;\r\n}\r\nst = 0;\r\n}\r\nif (!st) {\r\nspin_unlock_bh(&buf->lock);\r\nreturn -1;\r\n}\r\ne = st->elt_list.next;\r\nwhile (e != &st->elt_list) {\r\nstruct oz_elt_info *ei =\r\ncontainer_of(e, struct oz_elt_info, link);\r\ne = e->next;\r\nlist_del_init(&ei->link);\r\nlist_del_init(&ei->link_order);\r\nst->buf_count -= ei->length;\r\noz_trace2(OZ_TRACE_STREAM, "Stream down: %d %d %d\n",\r\nst->buf_count,\r\nei->length, atomic_read(&st->ref_count));\r\noz_elt_stream_put(st);\r\noz_elt_info_free(buf, ei);\r\n}\r\nspin_unlock_bh(&buf->lock);\r\noz_elt_stream_put(st);\r\nreturn 0;\r\n}\r\nvoid oz_elt_stream_get(struct oz_elt_stream *st)\r\n{\r\natomic_inc(&st->ref_count);\r\n}\r\nvoid oz_elt_stream_put(struct oz_elt_stream *st)\r\n{\r\nif (atomic_dec_and_test(&st->ref_count)) {\r\noz_trace("Stream destroyed\n");\r\nkfree(st);\r\n}\r\n}\r\nint oz_queue_elt_info(struct oz_elt_buf *buf, u8 isoc, u8 id,\r\nstruct oz_elt_info *ei)\r\n{\r\nstruct oz_elt_stream *st = 0;\r\nstruct list_head *e;\r\nif (id) {\r\nlist_for_each(e, &buf->stream_list) {\r\nst = container_of(e, struct oz_elt_stream, link);\r\nif (st->id == id)\r\nbreak;\r\n}\r\nif (e == &buf->stream_list) {\r\nreturn -1;\r\n}\r\n}\r\nif (st) {\r\nstruct oz_isoc_fixed *body = (struct oz_isoc_fixed *)\r\n&ei->data[sizeof(struct oz_elt)];\r\nif ((body->app_id == OZ_APPID_USB) && (body->type\r\n== OZ_USB_ENDPOINT_DATA) &&\r\n(body->format == OZ_DATA_F_ISOC_FIXED)) {\r\nu8 unit_count = body->frame_number;\r\nbody->frame_number = st->frame_number;\r\nst->frame_number += unit_count;\r\n}\r\noz_elt_stream_get(st);\r\nei->stream = st;\r\nst->buf_count += ei->length;\r\nlist_add_tail(&ei->link, &st->elt_list);\r\noz_trace2(OZ_TRACE_STREAM, "Stream up: %d %d\n",\r\nst->buf_count, ei->length);\r\nwhile ((st->buf_count > st->max_buf_count) &&\r\n!list_empty(&st->elt_list)) {\r\nstruct oz_elt_info *ei2 =\r\nlist_first_entry(&st->elt_list,\r\nstruct oz_elt_info, link);\r\nlist_del_init(&ei2->link);\r\nlist_del_init(&ei2->link_order);\r\nst->buf_count -= ei2->length;\r\noz_elt_info_free(buf, ei2);\r\noz_elt_stream_put(st);\r\n}\r\n}\r\nlist_add_tail(&ei->link_order, isoc ?\r\n&buf->isoc_list : &buf->order_list);\r\nreturn 0;\r\n}\r\nint oz_select_elts_for_tx(struct oz_elt_buf *buf, u8 isoc, unsigned *len,\r\nunsigned max_len, struct list_head *list)\r\n{\r\nint count = 0;\r\nstruct list_head *e;\r\nstruct list_head *el;\r\nstruct oz_elt_info *ei;\r\nspin_lock_bh(&buf->lock);\r\nif (isoc)\r\nel = &buf->isoc_list;\r\nelse\r\nel = &buf->order_list;\r\ne = el->next;\r\nwhile (e != el) {\r\nstruct oz_app_hdr *app_hdr;\r\nei = container_of(e, struct oz_elt_info, link_order);\r\ne = e->next;\r\nif ((*len + ei->length) <= max_len) {\r\napp_hdr = (struct oz_app_hdr *)\r\n&ei->data[sizeof(struct oz_elt)];\r\napp_hdr->elt_seq_num = buf->tx_seq_num[ei->app_id]++;\r\nif (buf->tx_seq_num[ei->app_id] == 0)\r\nbuf->tx_seq_num[ei->app_id] = 1;\r\n*len += ei->length;\r\nlist_del(&ei->link);\r\nlist_del(&ei->link_order);\r\nif (ei->stream) {\r\nei->stream->buf_count -= ei->length;\r\noz_trace2(OZ_TRACE_STREAM,\r\n"Stream down: %d %d\n",\r\nei->stream->buf_count, ei->length);\r\noz_elt_stream_put(ei->stream);\r\nei->stream = 0;\r\n}\r\nINIT_LIST_HEAD(&ei->link_order);\r\nlist_add_tail(&ei->link, list);\r\ncount++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&buf->lock);\r\nreturn count;\r\n}\r\nint oz_are_elts_available(struct oz_elt_buf *buf)\r\n{\r\nreturn buf->order_list.next != &buf->order_list;\r\n}\r\nvoid oz_trim_elt_pool(struct oz_elt_buf *buf)\r\n{\r\nstruct list_head *free = 0;\r\nstruct list_head *e;\r\nspin_lock_bh(&buf->lock);\r\nwhile (buf->free_elts > buf->max_free_elts) {\r\ne = buf->elt_pool;\r\nbuf->elt_pool = e->next;\r\ne->next = free;\r\nfree = e;\r\nbuf->free_elts--;\r\n}\r\nspin_unlock_bh(&buf->lock);\r\nwhile (free) {\r\nstruct oz_elt_info *ei =\r\ncontainer_of(free, struct oz_elt_info, link);\r\nfree = free->next;\r\nkfree(ei);\r\n}\r\n}
