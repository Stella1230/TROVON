static void s3c_dma_cb(struct s3c2410_dma_chan *channel, void *param,\r\nint size, enum s3c2410_dma_buffresult res)\r\n{\r\nstruct cb_data *data = param;\r\ndata->fp(data->fp_param);\r\n}\r\nstatic unsigned s3c_dma_request(enum dma_ch dma_ch,\r\nstruct samsung_dma_info *info)\r\n{\r\nstruct cb_data *data;\r\nif (s3c2410_dma_request(dma_ch, info->client, NULL) < 0) {\r\ns3c2410_dma_free(dma_ch, info->client);\r\nreturn 0;\r\n}\r\ndata = kzalloc(sizeof(struct cb_data), GFP_KERNEL);\r\ndata->ch = dma_ch;\r\nlist_add_tail(&data->node, &dma_list);\r\ns3c2410_dma_devconfig(dma_ch, info->direction, info->fifo);\r\nif (info->cap == DMA_CYCLIC)\r\ns3c2410_dma_setflags(dma_ch, S3C2410_DMAF_CIRCULAR);\r\ns3c2410_dma_config(dma_ch, info->width);\r\nreturn (unsigned)dma_ch;\r\n}\r\nstatic int s3c_dma_release(unsigned ch, struct s3c2410_dma_client *client)\r\n{\r\nstruct cb_data *data;\r\nlist_for_each_entry(data, &dma_list, node)\r\nif (data->ch == ch)\r\nbreak;\r\nlist_del(&data->node);\r\ns3c2410_dma_free(ch, client);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int s3c_dma_prepare(unsigned ch, struct samsung_dma_prep_info *info)\r\n{\r\nstruct cb_data *data;\r\nint len = (info->cap == DMA_CYCLIC) ? info->period : info->len;\r\nlist_for_each_entry(data, &dma_list, node)\r\nif (data->ch == ch)\r\nbreak;\r\nif (!data->fp) {\r\ns3c2410_dma_set_buffdone_fn(ch, s3c_dma_cb);\r\ndata->fp = info->fp;\r\ndata->fp_param = info->fp_param;\r\n}\r\ns3c2410_dma_enqueue(ch, (void *)data, info->buf, len);\r\nreturn 0;\r\n}\r\nstatic inline int s3c_dma_trigger(unsigned ch)\r\n{\r\nreturn s3c2410_dma_ctrl(ch, S3C2410_DMAOP_START);\r\n}\r\nstatic inline int s3c_dma_started(unsigned ch)\r\n{\r\nreturn s3c2410_dma_ctrl(ch, S3C2410_DMAOP_STARTED);\r\n}\r\nstatic inline int s3c_dma_flush(unsigned ch)\r\n{\r\nreturn s3c2410_dma_ctrl(ch, S3C2410_DMAOP_FLUSH);\r\n}\r\nstatic inline int s3c_dma_stop(unsigned ch)\r\n{\r\nreturn s3c2410_dma_ctrl(ch, S3C2410_DMAOP_STOP);\r\n}\r\nvoid *s3c_dma_get_ops(void)\r\n{\r\nreturn &s3c_dma_ops;\r\n}
