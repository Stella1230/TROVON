static int __pe_printk(const char *level, const struct pnv_ioda_pe *pe,\r\nstruct va_format *vaf)\r\n{\r\nchar pfix[32];\r\nif (pe->pdev)\r\nstrlcpy(pfix, dev_name(&pe->pdev->dev), sizeof(pfix));\r\nelse\r\nsprintf(pfix, "%04x:%02x ",\r\npci_domain_nr(pe->pbus), pe->pbus->number);\r\nreturn printk("pci %s%s: [PE# %.3d] %pV", level, pfix, pe->pe_number, vaf);\r\n}\r\nstatic void __devinit pnv_ioda_calc_dev(struct pci_dev *dev, unsigned int flags,\r\nresource_size_t *size,\r\nresource_size_t *align)\r\n{\r\nresource_size_t start;\r\nstruct resource *r;\r\nint i;\r\npr_devel(" -> CDR %s\n", pci_name(dev));\r\n*size = *align = 0;\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nr = &dev->resource[i];\r\nif (!(r->flags & flags))\r\ncontinue;\r\nif (r->start) {\r\nr->end -= r->start;\r\nr->start = 0;\r\n}\r\nr->flags |= IORESOURCE_UNSET;\r\n}\r\nstart = 0;\r\nfor (;;) {\r\nresource_size_t max_size = 0;\r\nint max_no = -1;\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nr = &dev->resource[i];\r\nif (!(r->flags & IORESOURCE_UNSET) ||\r\n!(r->flags & flags))\r\ncontinue;\r\nif (resource_size(r) > max_size) {\r\nmax_size = resource_size(r);\r\nmax_no = i;\r\n}\r\n}\r\nif (max_no < 0)\r\nbreak;\r\nr = &dev->resource[max_no];\r\nif (max_size > *align)\r\n*align = max_size;\r\n*size += max_size;\r\nr->start = start;\r\nstart += max_size;\r\nr->end = r->start + max_size - 1;\r\nr->flags &= ~IORESOURCE_UNSET;\r\npr_devel(" -> R%d %016llx..%016llx\n",\r\nmax_no, r->start, r->end);\r\n}\r\npr_devel(" <- CDR %s size=%llx align=%llx\n",\r\npci_name(dev), *size, *align);\r\n}\r\nstatic void __devinit pnv_ioda_add_wrap(struct list_head *list,\r\nstruct pci_bus *bus,\r\nstruct pci_dev *dev,\r\nresource_size_t size,\r\nresource_size_t align)\r\n{\r\nstruct resource_wrap *w1, *w = kzalloc(sizeof(*w), GFP_KERNEL);\r\nw->size = size;\r\nw->align = align;\r\nw->dev = dev;\r\nw->bus = bus;\r\nlist_for_each_entry(w1, list, link) {\r\nif (w1->align < align) {\r\nlist_add_tail(&w->link, &w1->link);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&w->link, list);\r\n}\r\nstatic void __devinit pnv_ioda_offset_dev(struct pci_dev *dev,\r\nunsigned int flags,\r\nresource_size_t offset)\r\n{\r\nstruct resource *r;\r\nint i;\r\npr_devel(" -> ODR %s [%x] +%016llx\n", pci_name(dev), flags, offset);\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nr = &dev->resource[i];\r\nif (r->flags & flags) {\r\ndev->resource[i].start += offset;\r\ndev->resource[i].end += offset;\r\n}\r\n}\r\npr_devel(" <- ODR %s [%x] +%016llx\n", pci_name(dev), flags, offset);\r\n}\r\nstatic void __devinit pnv_ioda_offset_bus(struct pci_bus *bus,\r\nunsigned int flags,\r\nresource_size_t offset)\r\n{\r\nstruct resource *r;\r\nstruct pci_dev *dev;\r\nstruct pci_bus *cbus;\r\nint i;\r\npr_devel(" -> OBR %s [%x] +%016llx\n",\r\nbus->self ? pci_name(bus->self) : "root", flags, offset);\r\npci_bus_for_each_resource(bus, r, i) {\r\nif (r && (r->flags & flags)) {\r\nr->start += offset;\r\nr->end += offset;\r\n}\r\n}\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\npnv_ioda_offset_dev(dev, flags, offset);\r\nlist_for_each_entry(cbus, &bus->children, node)\r\npnv_ioda_offset_bus(cbus, flags, offset);\r\npr_devel(" <- OBR %s [%x]\n",\r\nbus->self ? pci_name(bus->self) : "root", flags);\r\n}\r\nstatic void __devinit pnv_ioda_calc_bus(struct pci_bus *bus, unsigned int flags,\r\nresource_size_t *size,\r\nresource_size_t *align)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nresource_size_t dev_size, dev_align, start;\r\nresource_size_t min_align, min_balign;\r\nstruct pci_dev *cdev;\r\nstruct pci_bus *cbus;\r\nstruct list_head head;\r\nstruct resource_wrap *w;\r\nunsigned int bres;\r\n*size = *align = 0;\r\npr_devel("-> CBR %s [%x]\n",\r\nbus->self ? pci_name(bus->self) : "root", flags);\r\nif (flags & IORESOURCE_IO) {\r\nbres = 0;\r\nmin_align = phb->ioda.io_segsize;\r\nmin_balign = 0x1000;\r\n} else {\r\nbres = 1;\r\nmin_align = phb->ioda.m32_segsize;\r\nmin_balign = 0x100000;\r\n}\r\nINIT_LIST_HEAD(&head);\r\nlist_for_each_entry(cbus, &bus->children, node) {\r\npnv_ioda_calc_bus(cbus, flags, &dev_size, &dev_align);\r\npnv_ioda_add_wrap(&head, cbus, NULL, dev_size, dev_align);\r\n}\r\nlist_for_each_entry(cdev, &bus->devices, bus_list) {\r\npnv_ioda_calc_dev(cdev, flags, &dev_size, &dev_align);\r\nif (dev_align < min_align)\r\ndev_align = min_align;\r\npnv_ioda_add_wrap(&head, NULL, cdev, dev_size, dev_align);\r\n}\r\nif (list_empty(&head))\r\ngoto empty;\r\nif (bus->self) {\r\nstart = 0;\r\n} else {\r\nif (flags & IORESOURCE_IO)\r\nstart = hose->io_resource.start + 0x1000;\r\nelse\r\nstart = hose->mem_resources[0].start;\r\n}\r\nwhile(!list_empty(&head)) {\r\nw = list_first_entry(&head, struct resource_wrap, link);\r\nlist_del(&w->link);\r\nif (w->size) {\r\nif (start) {\r\nstart = ALIGN(start, w->align);\r\nif (w->dev)\r\npnv_ioda_offset_dev(w->dev,flags,start);\r\nelse if (w->bus)\r\npnv_ioda_offset_bus(w->bus,flags,start);\r\n}\r\nif (w->align > *align)\r\n*align = w->align;\r\n}\r\nstart += w->size;\r\nkfree(w);\r\n}\r\n*size = start;\r\n*align = max_t(resource_size_t, *align,\r\nmax_t(resource_size_t, min_align, min_balign));\r\n*size = ALIGN(*size,\r\nmax_t(resource_size_t, min_align, min_balign));\r\nempty:\r\nif (bus->self) {\r\nstruct resource *res = bus->resource[bres];\r\nif (WARN_ON(res == NULL))\r\nreturn;\r\nres->start = 0;\r\nres->flags = (*size) ? flags : 0;\r\nres->end = (*size) ? (*size - 1) : 0;\r\n}\r\npr_devel("<- CBR %s [%x] *size=%016llx *align=%016llx\n",\r\nbus->self ? pci_name(bus->self) : "root", flags,*size,*align);\r\n}\r\nstatic struct pci_dn *pnv_ioda_get_pdn(struct pci_dev *dev)\r\n{\r\nstruct device_node *np;\r\nnp = pci_device_to_OF_node(dev);\r\nif (!np)\r\nreturn NULL;\r\nreturn PCI_DN(np);\r\n}\r\nstatic void __devinit pnv_ioda_setup_pe_segments(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn = pnv_ioda_get_pdn(dev);\r\nunsigned int pe, i;\r\nresource_size_t pos;\r\nstruct resource io_res;\r\nstruct resource m32_res;\r\nstruct pci_bus_region region;\r\nint rc;\r\npe = pdn ? pdn->pe_number : 0;\r\nio_res.start = m32_res.start = (resource_size_t)-1;\r\nio_res.end = m32_res.end = 0;\r\nio_res.flags = IORESOURCE_IO;\r\nm32_res.flags = IORESOURCE_MEM;\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nstruct resource *r = NULL;\r\nif (dev->resource[i].flags & IORESOURCE_IO)\r\nr = &io_res;\r\nif (dev->resource[i].flags & IORESOURCE_MEM)\r\nr = &m32_res;\r\nif (!r)\r\ncontinue;\r\nif (dev->resource[i].start < r->start)\r\nr->start = dev->resource[i].start;\r\nif (dev->resource[i].end > r->end)\r\nr->end = dev->resource[i].end;\r\n}\r\nif (io_res.start < io_res.end) {\r\npcibios_resource_to_bus(dev, &region, &io_res);\r\npos = region.start;\r\ni = pos / phb->ioda.io_segsize;\r\nwhile(i < phb->ioda.total_pe && pos <= region.end) {\r\nif (phb->ioda.io_segmap[i]) {\r\npr_err("%s: Trying to use IO seg #%d which is"\r\n" already used by PE# %d\n",\r\npci_name(dev), i,\r\nphb->ioda.io_segmap[i]);\r\nbreak;\r\n}\r\nphb->ioda.io_segmap[i] = pe;\r\nrc = opal_pci_map_pe_mmio_window(phb->opal_id, pe,\r\nOPAL_IO_WINDOW_TYPE,\r\n0, i);\r\nif (rc != OPAL_SUCCESS) {\r\npr_err("%s: OPAL error %d setting up mapping"\r\n" for IO seg# %d\n",\r\npci_name(dev), rc, i);\r\nbreak;\r\n}\r\npos += phb->ioda.io_segsize;\r\ni++;\r\n};\r\n}\r\nif (m32_res.start < m32_res.end) {\r\npcibios_resource_to_bus(dev, &region, &m32_res);\r\npos = region.start;\r\ni = pos / phb->ioda.m32_segsize;\r\nwhile(i < phb->ioda.total_pe && pos <= region.end) {\r\nif (phb->ioda.m32_segmap[i]) {\r\npr_err("%s: Trying to use M32 seg #%d which is"\r\n" already used by PE# %d\n",\r\npci_name(dev), i,\r\nphb->ioda.m32_segmap[i]);\r\nbreak;\r\n}\r\nphb->ioda.m32_segmap[i] = pe;\r\nrc = opal_pci_map_pe_mmio_window(phb->opal_id, pe,\r\nOPAL_M32_WINDOW_TYPE,\r\n0, i);\r\nif (rc != OPAL_SUCCESS) {\r\npr_err("%s: OPAL error %d setting up mapping"\r\n" for M32 seg# %d\n",\r\npci_name(dev), rc, i);\r\nbreak;\r\n}\r\npos += phb->ioda.m32_segsize;\r\ni++;\r\n}\r\n}\r\n}\r\nstatic int __devinit pnv_ioda_resource_fit(struct pci_controller *hose,\r\nstruct resource *r)\r\n{\r\nstruct resource *bounds;\r\nif (r->flags & IORESOURCE_IO)\r\nbounds = &hose->io_resource;\r\nelse if (r->flags & IORESOURCE_MEM)\r\nbounds = &hose->mem_resources[0];\r\nelse\r\nreturn 1;\r\nif (r->start >= bounds->start && r->end <= bounds->end)\r\nreturn 1;\r\nr->flags = 0;\r\nreturn 0;\r\n}\r\nstatic void __devinit pnv_ioda_update_resources(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct pci_bus *cbus;\r\nstruct pci_dev *cdev;\r\nunsigned int i;\r\nfor (i = 0; bus->self && (i < 2); i++) {\r\nstruct resource *r = bus->resource[i];\r\nif (r && !pnv_ioda_resource_fit(hose, r))\r\npr_err("%s: Bus %d resource %d disabled, no room\n",\r\npci_name(bus->self), bus->number, i);\r\n}\r\nif (bus->self)\r\npci_setup_bridge(bus);\r\nlist_for_each_entry(cdev, &bus->devices, bus_list) {\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nstruct resource *r = &cdev->resource[i];\r\nif (!pnv_ioda_resource_fit(hose, r))\r\npr_err("%s: Resource %d disabled, no room\n",\r\npci_name(cdev), i);\r\n}\r\npnv_ioda_setup_pe_segments(cdev);\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++)\r\npci_update_resource(cdev, i);\r\n}\r\nlist_for_each_entry(cbus, &bus->children, node)\r\npnv_ioda_update_resources(cbus);\r\n}\r\nstatic int __devinit pnv_ioda_alloc_pe(struct pnv_phb *phb)\r\n{\r\nunsigned long pe;\r\ndo {\r\npe = find_next_zero_bit(phb->ioda.pe_alloc,\r\nphb->ioda.total_pe, 0);\r\nif (pe >= phb->ioda.total_pe)\r\nreturn IODA_INVALID_PE;\r\n} while(test_and_set_bit(pe, phb->ioda.pe_alloc));\r\nphb->ioda.pe_array[pe].pe_number = pe;\r\nreturn pe;\r\n}\r\nstatic void __devinit pnv_ioda_free_pe(struct pnv_phb *phb, int pe)\r\n{\r\nWARN_ON(phb->ioda.pe_array[pe].pdev);\r\nmemset(&phb->ioda.pe_array[pe], 0, sizeof(struct pnv_ioda_pe));\r\nclear_bit(pe, phb->ioda.pe_alloc);\r\n}\r\nstatic struct pnv_ioda_pe * __devinit __pnv_ioda_get_one_pe(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn = pnv_ioda_get_pdn(dev);\r\nif (!pdn)\r\nreturn NULL;\r\nif (pdn->pe_number == IODA_INVALID_PE)\r\nreturn NULL;\r\nreturn &phb->ioda.pe_array[pdn->pe_number];\r\n}\r\nstatic struct pnv_ioda_pe * __devinit pnv_ioda_get_pe(struct pci_dev *dev)\r\n{\r\nstruct pnv_ioda_pe *pe = __pnv_ioda_get_one_pe(dev);\r\nwhile (!pe && dev->bus->self) {\r\ndev = dev->bus->self;\r\npe = __pnv_ioda_get_one_pe(dev);\r\nif (pe)\r\npe = pe->bus_pe;\r\n}\r\nreturn pe;\r\n}\r\nstatic int __devinit pnv_ioda_configure_pe(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe)\r\n{\r\nstruct pci_dev *parent;\r\nuint8_t bcomp, dcomp, fcomp;\r\nlong rc, rid_end, rid;\r\nif (pe->pbus) {\r\nint count;\r\ndcomp = OPAL_IGNORE_RID_DEVICE_NUMBER;\r\nfcomp = OPAL_IGNORE_RID_FUNCTION_NUMBER;\r\nparent = pe->pbus->self;\r\ncount = pe->pbus->subordinate - pe->pbus->secondary + 1;\r\nswitch(count) {\r\ncase 1: bcomp = OpalPciBusAll; break;\r\ncase 2: bcomp = OpalPciBus7Bits; break;\r\ncase 4: bcomp = OpalPciBus6Bits; break;\r\ncase 8: bcomp = OpalPciBus5Bits; break;\r\ncase 16: bcomp = OpalPciBus4Bits; break;\r\ncase 32: bcomp = OpalPciBus3Bits; break;\r\ndefault:\r\npr_err("%s: Number of subordinate busses %d"\r\n" unsupported\n",\r\npci_name(pe->pbus->self), count);\r\nbcomp = OpalPciBusAll;\r\n}\r\nrid_end = pe->rid + (count << 8);\r\n} else {\r\nparent = pe->pdev->bus->self;\r\nbcomp = OpalPciBusAll;\r\ndcomp = OPAL_COMPARE_RID_DEVICE_NUMBER;\r\nfcomp = OPAL_COMPARE_RID_FUNCTION_NUMBER;\r\nrid_end = pe->rid + 1;\r\n}\r\nrc = opal_pci_set_pe(phb->opal_id, pe->pe_number, pe->rid,\r\nbcomp, dcomp, fcomp, OPAL_MAP_PE);\r\nif (rc) {\r\npe_err(pe, "OPAL error %ld trying to setup PELT table\n", rc);\r\nreturn -ENXIO;\r\n}\r\nopal_pci_eeh_freeze_clear(phb->opal_id, pe->pe_number,\r\nOPAL_EEH_ACTION_CLEAR_FREEZE_ALL);\r\nwhile (parent) {\r\nstruct pci_dn *pdn = pnv_ioda_get_pdn(parent);\r\nif (pdn && pdn->pe_number != IODA_INVALID_PE) {\r\nrc = opal_pci_set_peltv(phb->opal_id, pdn->pe_number,\r\npe->pe_number, OPAL_ADD_PE_TO_DOMAIN);\r\n}\r\nparent = parent->bus->self;\r\n}\r\nfor (rid = pe->rid; rid < rid_end; rid++)\r\nphb->ioda.pe_rmap[rid] = pe->pe_number;\r\nif (phb->type == PNV_PHB_IODA1) {\r\npe->mve_number = pe->pe_number;\r\nrc = opal_pci_set_mve(phb->opal_id, pe->mve_number,\r\npe->pe_number);\r\nif (rc) {\r\npe_err(pe, "OPAL error %ld setting up MVE %d\n",\r\nrc, pe->mve_number);\r\npe->mve_number = -1;\r\n} else {\r\nrc = opal_pci_set_mve_enable(phb->opal_id,\r\npe->mve_number, OPAL_ENABLE_MVE);\r\nif (rc) {\r\npe_err(pe, "OPAL error %ld enabling MVE %d\n",\r\nrc, pe->mve_number);\r\npe->mve_number = -1;\r\n}\r\n}\r\n} else if (phb->type == PNV_PHB_IODA2)\r\npe->mve_number = 0;\r\nreturn 0;\r\n}\r\nstatic void __devinit pnv_ioda_link_pe_by_weight(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe)\r\n{\r\nstruct pnv_ioda_pe *lpe;\r\nlist_for_each_entry(lpe, &phb->ioda.pe_list, link) {\r\nif (lpe->dma_weight < pe->dma_weight) {\r\nlist_add_tail(&pe->link, &lpe->link);\r\nreturn;\r\n}\r\n}\r\nlist_add_tail(&pe->link, &phb->ioda.pe_list);\r\n}\r\nstatic unsigned int pnv_ioda_dma_weight(struct pci_dev *dev)\r\n{\r\nif (dev->hdr_type != PCI_HEADER_TYPE_NORMAL)\r\nreturn 0;\r\nif (dev->class == PCI_CLASS_SERIAL_USB_UHCI ||\r\ndev->class == PCI_CLASS_SERIAL_USB_OHCI ||\r\ndev->class == PCI_CLASS_SERIAL_USB_EHCI)\r\nreturn 3;\r\nif ((dev->class >> 8) == PCI_CLASS_STORAGE_RAID)\r\nreturn 15;\r\nreturn 10;\r\n}\r\nstatic struct pnv_ioda_pe * __devinit pnv_ioda_setup_dev_PE(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_dn *pdn = pnv_ioda_get_pdn(dev);\r\nstruct pnv_ioda_pe *pe;\r\nint pe_num;\r\nif (!pdn) {\r\npr_err("%s: Device tree node not associated properly\n",\r\npci_name(dev));\r\nreturn NULL;\r\n}\r\nif (pdn->pe_number != IODA_INVALID_PE)\r\nreturn NULL;\r\nif (dev->bus->number == 0)\r\npe_num = 0;\r\nelse\r\npe_num = pnv_ioda_alloc_pe(phb);\r\nif (pe_num == IODA_INVALID_PE) {\r\npr_warning("%s: Not enough PE# available, disabling device\n",\r\npci_name(dev));\r\nreturn NULL;\r\n}\r\npe = &phb->ioda.pe_array[pe_num];\r\npci_dev_get(dev);\r\npdn->pcidev = dev;\r\npdn->pe_number = pe_num;\r\npe->pdev = dev;\r\npe->pbus = NULL;\r\npe->tce32_seg = -1;\r\npe->mve_number = -1;\r\npe->rid = dev->bus->number << 8 | pdn->devfn;\r\npe_info(pe, "Associated device to PE\n");\r\nif (pnv_ioda_configure_pe(phb, pe)) {\r\nif (pe_num)\r\npnv_ioda_free_pe(phb, pe_num);\r\npdn->pe_number = IODA_INVALID_PE;\r\npe->pdev = NULL;\r\npci_dev_put(dev);\r\nreturn NULL;\r\n}\r\npe->dma_weight = pnv_ioda_dma_weight(dev);\r\nif (pe->dma_weight != 0) {\r\nphb->ioda.dma_weight += pe->dma_weight;\r\nphb->ioda.dma_pe_count++;\r\n}\r\npnv_ioda_link_pe_by_weight(phb, pe);\r\nreturn pe;\r\n}\r\nstatic void pnv_ioda_setup_same_PE(struct pci_bus *bus, struct pnv_ioda_pe *pe)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nstruct pci_dn *pdn = pnv_ioda_get_pdn(dev);\r\nif (pdn == NULL) {\r\npr_warn("%s: No device node associated with device !\n",\r\npci_name(dev));\r\ncontinue;\r\n}\r\npci_dev_get(dev);\r\npdn->pcidev = dev;\r\npdn->pe_number = pe->pe_number;\r\npe->dma_weight += pnv_ioda_dma_weight(dev);\r\nif (dev->subordinate)\r\npnv_ioda_setup_same_PE(dev->subordinate, pe);\r\n}\r\n}\r\nstatic void __devinit pnv_ioda_setup_bus_PE(struct pci_dev *dev,\r\nstruct pnv_ioda_pe *ppe)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(dev->bus);\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pci_bus *bus = dev->subordinate;\r\nstruct pnv_ioda_pe *pe;\r\nint pe_num;\r\nif (!bus) {\r\npr_warning("%s: Bridge without a subordinate bus !\n",\r\npci_name(dev));\r\nreturn;\r\n}\r\npe_num = pnv_ioda_alloc_pe(phb);\r\nif (pe_num == IODA_INVALID_PE) {\r\npr_warning("%s: Not enough PE# available, disabling bus\n",\r\npci_name(dev));\r\nreturn;\r\n}\r\npe = &phb->ioda.pe_array[pe_num];\r\nppe->bus_pe = pe;\r\npe->pbus = bus;\r\npe->pdev = NULL;\r\npe->tce32_seg = -1;\r\npe->mve_number = -1;\r\npe->rid = bus->secondary << 8;\r\npe->dma_weight = 0;\r\npe_info(pe, "Secondary busses %d..%d associated with PE\n",\r\nbus->secondary, bus->subordinate);\r\nif (pnv_ioda_configure_pe(phb, pe)) {\r\nif (pe_num)\r\npnv_ioda_free_pe(phb, pe_num);\r\npe->pbus = NULL;\r\nreturn;\r\n}\r\npnv_ioda_setup_same_PE(bus, pe);\r\nif (pe->dma_weight != 0) {\r\nphb->ioda.dma_weight += pe->dma_weight;\r\nphb->ioda.dma_pe_count++;\r\n}\r\npnv_ioda_link_pe_by_weight(phb, pe);\r\n}\r\nstatic void __devinit pnv_ioda_setup_PEs(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nstruct pnv_ioda_pe *pe;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\npe = pnv_ioda_setup_dev_PE(dev);\r\nif (pe == NULL)\r\ncontinue;\r\nif (dev->pcie_type == PCI_EXP_TYPE_PCI_BRIDGE)\r\npnv_ioda_setup_bus_PE(dev, pe);\r\nelse if (dev->subordinate)\r\npnv_ioda_setup_PEs(dev->subordinate);\r\n}\r\n}\r\nstatic void __devinit pnv_pci_ioda_dma_dev_setup(struct pnv_phb *phb,\r\nstruct pci_dev *dev)\r\n{\r\n}\r\nstatic void __devinit pnv_ioda_setup_bus_dma(struct pnv_ioda_pe *pe,\r\nstruct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nset_iommu_table_base(&dev->dev, &pe->tce32_table);\r\nif (dev->subordinate)\r\npnv_ioda_setup_bus_dma(pe, dev->subordinate);\r\n}\r\n}\r\nstatic void __devinit pnv_pci_ioda_setup_dma_pe(struct pnv_phb *phb,\r\nstruct pnv_ioda_pe *pe,\r\nunsigned int base,\r\nunsigned int segs)\r\n{\r\nstruct page *tce_mem = NULL;\r\nconst __be64 *swinvp;\r\nstruct iommu_table *tbl;\r\nunsigned int i;\r\nint64_t rc;\r\nvoid *addr;\r\n#define TCE32_TABLE_SIZE ((0x10000000 / 0x1000) * 8)\r\nif (WARN_ON(pe->tce32_seg >= 0))\r\nreturn;\r\npe->tce32_seg = base;\r\npe_info(pe, " Setting up 32-bit TCE table at %08x..%08x\n",\r\n(base << 28), ((base + segs) << 28) - 1);\r\ntce_mem = alloc_pages_node(phb->hose->node, GFP_KERNEL,\r\nget_order(TCE32_TABLE_SIZE * segs));\r\nif (!tce_mem) {\r\npe_err(pe, " Failed to allocate a 32-bit TCE memory\n");\r\ngoto fail;\r\n}\r\naddr = page_address(tce_mem);\r\nmemset(addr, 0, TCE32_TABLE_SIZE * segs);\r\nfor (i = 0; i < segs; i++) {\r\nrc = opal_pci_map_pe_dma_window(phb->opal_id,\r\npe->pe_number,\r\nbase + i, 1,\r\n__pa(addr) + TCE32_TABLE_SIZE * i,\r\nTCE32_TABLE_SIZE, 0x1000);\r\nif (rc) {\r\npe_err(pe, " Failed to configure 32-bit TCE table,"\r\n" err %ld\n", rc);\r\ngoto fail;\r\n}\r\n}\r\ntbl = &pe->tce32_table;\r\npnv_pci_setup_iommu_table(tbl, addr, TCE32_TABLE_SIZE * segs,\r\nbase << 28);\r\nswinvp = of_get_property(phb->hose->dn, "ibm,opal-tce-kill", NULL);\r\nif (swinvp) {\r\ntbl->it_busno = 0;\r\ntbl->it_index = (unsigned long)ioremap(be64_to_cpup(swinvp), 8);\r\ntbl->it_type = TCE_PCI_SWINV_CREATE | TCE_PCI_SWINV_FREE\r\n| TCE_PCI_SWINV_PAIR;\r\n}\r\niommu_init_table(tbl, phb->hose->node);\r\nif (pe->pdev)\r\nset_iommu_table_base(&pe->pdev->dev, tbl);\r\nelse\r\npnv_ioda_setup_bus_dma(pe, pe->pbus);\r\nreturn;\r\nfail:\r\nif (pe->tce32_seg >= 0)\r\npe->tce32_seg = -1;\r\nif (tce_mem)\r\n__free_pages(tce_mem, get_order(TCE32_TABLE_SIZE * segs));\r\n}\r\nstatic void __devinit pnv_ioda_setup_dma(struct pnv_phb *phb)\r\n{\r\nstruct pci_controller *hose = phb->hose;\r\nunsigned int residual, remaining, segs, tw, base;\r\nstruct pnv_ioda_pe *pe;\r\nif (phb->ioda.dma_pe_count > phb->ioda.tce32_count)\r\nresidual = 0;\r\nelse\r\nresidual = phb->ioda.tce32_count -\r\nphb->ioda.dma_pe_count;\r\npr_info("PCI: Domain %04x has %ld available 32-bit DMA segments\n",\r\nhose->global_number, phb->ioda.tce32_count);\r\npr_info("PCI: %d PE# for a total weight of %d\n",\r\nphb->ioda.dma_pe_count, phb->ioda.dma_weight);\r\nremaining = phb->ioda.tce32_count;\r\ntw = phb->ioda.dma_weight;\r\nbase = 0;\r\nlist_for_each_entry(pe, &phb->ioda.pe_list, link) {\r\nif (!pe->dma_weight)\r\ncontinue;\r\nif (!remaining) {\r\npe_warn(pe, "No DMA32 resources available\n");\r\ncontinue;\r\n}\r\nsegs = 1;\r\nif (residual) {\r\nsegs += ((pe->dma_weight * residual) + (tw / 2)) / tw;\r\nif (segs > remaining)\r\nsegs = remaining;\r\n}\r\npe_info(pe, "DMA weight %d, assigned %d DMA32 segments\n",\r\npe->dma_weight, segs);\r\npnv_pci_ioda_setup_dma_pe(phb, pe, base, segs);\r\nremaining -= segs;\r\nbase += segs;\r\n}\r\n}\r\nstatic int pnv_pci_ioda_msi_setup(struct pnv_phb *phb, struct pci_dev *dev,\r\nunsigned int hwirq, unsigned int is_64,\r\nstruct msi_msg *msg)\r\n{\r\nstruct pnv_ioda_pe *pe = pnv_ioda_get_pe(dev);\r\nunsigned int xive_num = hwirq - phb->msi_base;\r\nuint64_t addr64;\r\nuint32_t addr32, data;\r\nint rc;\r\nif (pe == NULL)\r\nreturn -ENXIO;\r\nif (pe->mve_number < 0)\r\nreturn -ENXIO;\r\nrc = opal_pci_set_xive_pe(phb->opal_id, pe->pe_number, xive_num);\r\nif (rc) {\r\npr_warn("%s: OPAL error %d setting XIVE %d PE\n",\r\npci_name(dev), rc, xive_num);\r\nreturn -EIO;\r\n}\r\nif (is_64) {\r\nrc = opal_get_msi_64(phb->opal_id, pe->mve_number, xive_num, 1,\r\n&addr64, &data);\r\nif (rc) {\r\npr_warn("%s: OPAL error %d getting 64-bit MSI data\n",\r\npci_name(dev), rc);\r\nreturn -EIO;\r\n}\r\nmsg->address_hi = addr64 >> 32;\r\nmsg->address_lo = addr64 & 0xfffffffful;\r\n} else {\r\nrc = opal_get_msi_32(phb->opal_id, pe->mve_number, xive_num, 1,\r\n&addr32, &data);\r\nif (rc) {\r\npr_warn("%s: OPAL error %d getting 32-bit MSI data\n",\r\npci_name(dev), rc);\r\nreturn -EIO;\r\n}\r\nmsg->address_hi = 0;\r\nmsg->address_lo = addr32;\r\n}\r\nmsg->data = data;\r\npr_devel("%s: %s-bit MSI on hwirq %x (xive #%d),"\r\n" address=%x_%08x data=%x PE# %d\n",\r\npci_name(dev), is_64 ? "64" : "32", hwirq, xive_num,\r\nmsg->address_hi, msg->address_lo, data, pe->pe_number);\r\nreturn 0;\r\n}\r\nstatic void pnv_pci_init_ioda_msis(struct pnv_phb *phb)\r\n{\r\nunsigned int bmap_size;\r\nconst __be32 *prop = of_get_property(phb->hose->dn,\r\n"ibm,opal-msi-ranges", NULL);\r\nif (!prop) {\r\nprop = of_get_property(phb->hose->dn, "msi-ranges", NULL);\r\n}\r\nif (!prop)\r\nreturn;\r\nphb->msi_base = be32_to_cpup(prop);\r\nphb->msi_count = be32_to_cpup(prop + 1);\r\nbmap_size = BITS_TO_LONGS(phb->msi_count) * sizeof(unsigned long);\r\nphb->msi_map = zalloc_maybe_bootmem(bmap_size, GFP_KERNEL);\r\nif (!phb->msi_map) {\r\npr_err("PCI %d: Failed to allocate MSI bitmap !\n",\r\nphb->hose->global_number);\r\nreturn;\r\n}\r\nphb->msi_setup = pnv_pci_ioda_msi_setup;\r\nphb->msi32_support = 1;\r\npr_info(" Allocated bitmap for %d MSIs (base IRQ 0x%x)\n",\r\nphb->msi_count, phb->msi_base);\r\n}\r\nstatic void pnv_pci_init_ioda_msis(struct pnv_phb *phb) { }\r\nstatic void __devinit pnv_pci_ioda_fixup_phb(struct pci_controller *hose)\r\n{\r\nresource_size_t size, align;\r\nstruct pci_bus *child;\r\npnv_ioda_setup_PEs(hose->bus);\r\npnv_ioda_calc_bus(hose->bus, IORESOURCE_IO, &size, &align);\r\npnv_ioda_calc_bus(hose->bus, IORESOURCE_MEM, &size, &align);\r\npnv_ioda_update_resources(hose->bus);\r\npnv_ioda_setup_dma(hose->private_data);\r\nlist_for_each_entry(child, &hose->bus->children, node) {\r\nstruct pci_dev *self = child->self;\r\nif (!self)\r\ncontinue;\r\npcie_bus_configure_settings(child, self->pcie_mpss);\r\n}\r\n}\r\nstatic int __devinit pnv_pci_enable_device_hook(struct pci_dev *dev)\r\n{\r\nstruct pci_dn *pdn = pnv_ioda_get_pdn(dev);\r\nif (!pdn || pdn->pe_number == IODA_INVALID_PE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic u32 pnv_ioda_bdfn_to_pe(struct pnv_phb *phb, struct pci_bus *bus,\r\nu32 devfn)\r\n{\r\nreturn phb->ioda.pe_rmap[(bus->number << 8) | devfn];\r\n}\r\nvoid __init pnv_pci_init_ioda1_phb(struct device_node *np)\r\n{\r\nstruct pci_controller *hose;\r\nstatic int primary = 1;\r\nstruct pnv_phb *phb;\r\nunsigned long size, m32map_off, iomap_off, pemap_off;\r\nconst u64 *prop64;\r\nu64 phb_id;\r\nvoid *aux;\r\nlong rc;\r\npr_info(" Initializing IODA OPAL PHB %s\n", np->full_name);\r\nprop64 = of_get_property(np, "ibm,opal-phbid", NULL);\r\nif (!prop64) {\r\npr_err(" Missing \"ibm,opal-phbid\" property !\n");\r\nreturn;\r\n}\r\nphb_id = be64_to_cpup(prop64);\r\npr_debug(" PHB-ID : 0x%016llx\n", phb_id);\r\nphb = alloc_bootmem(sizeof(struct pnv_phb));\r\nif (phb) {\r\nmemset(phb, 0, sizeof(struct pnv_phb));\r\nphb->hose = hose = pcibios_alloc_controller(np);\r\n}\r\nif (!phb || !phb->hose) {\r\npr_err("PCI: Failed to allocate PCI controller for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nspin_lock_init(&phb->lock);\r\nhose->first_busno = 0;\r\nhose->last_busno = 0xff;\r\nhose->private_data = phb;\r\nphb->opal_id = phb_id;\r\nphb->type = PNV_PHB_IODA1;\r\nif (of_device_is_compatible(np, "ibm,p7ioc-pciex"))\r\nphb->model = PNV_PHB_MODEL_P7IOC;\r\nelse\r\nphb->model = PNV_PHB_MODEL_UNKNOWN;\r\npci_process_bridge_OF_ranges(phb->hose, np, primary);\r\nprimary = 0;\r\nphb->regs = of_iomap(np, 0);\r\nif (phb->regs == NULL)\r\npr_err(" Failed to map registers !\n");\r\nphb->ioda.total_pe = 128;\r\nphb->ioda.m32_size = resource_size(&hose->mem_resources[0]);\r\nphb->ioda.m32_size += 0x10000;\r\nphb->ioda.m32_segsize = phb->ioda.m32_size / phb->ioda.total_pe;\r\nphb->ioda.m32_pci_base = hose->mem_resources[0].start -\r\nhose->pci_mem_offset;\r\nphb->ioda.io_size = hose->pci_io_size;\r\nphb->ioda.io_segsize = phb->ioda.io_size / phb->ioda.total_pe;\r\nphb->ioda.io_pci_base = 0;\r\nsize = _ALIGN_UP(phb->ioda.total_pe / 8, sizeof(unsigned long));\r\nm32map_off = size;\r\nsize += phb->ioda.total_pe;\r\niomap_off = size;\r\nsize += phb->ioda.total_pe;\r\npemap_off = size;\r\nsize += phb->ioda.total_pe * sizeof(struct pnv_ioda_pe);\r\naux = alloc_bootmem(size);\r\nmemset(aux, 0, size);\r\nphb->ioda.pe_alloc = aux;\r\nphb->ioda.m32_segmap = aux + m32map_off;\r\nphb->ioda.io_segmap = aux + iomap_off;\r\nphb->ioda.pe_array = aux + pemap_off;\r\nset_bit(0, phb->ioda.pe_alloc);\r\nINIT_LIST_HEAD(&phb->ioda.pe_list);\r\nphb->ioda.tce32_count = phb->ioda.m32_pci_base >> 28;\r\nhose->mem_resources[1].flags = 0;\r\nhose->mem_resources[1].start = 0;\r\nhose->mem_resources[1].end = 0;\r\nhose->mem_resources[2].flags = 0;\r\nhose->mem_resources[2].start = 0;\r\nhose->mem_resources[2].end = 0;\r\n#if 0\r\nrc = opal_pci_set_phb_mem_window(opal->phb_id,\r\nwindow_type,\r\nwindow_num,\r\nstarting_real_address,\r\nstarting_pci_address,\r\nsegment_size);\r\n#endif\r\npr_info(" %d PE's M32: 0x%x [segment=0x%x] IO: 0x%x [segment=0x%x]\n",\r\nphb->ioda.total_pe,\r\nphb->ioda.m32_size, phb->ioda.m32_segsize,\r\nphb->ioda.io_size, phb->ioda.io_segsize);\r\nif (phb->regs) {\r\npr_devel(" BUID = 0x%016llx\n", in_be64(phb->regs + 0x100));\r\npr_devel(" PHB2_CR = 0x%016llx\n", in_be64(phb->regs + 0x160));\r\npr_devel(" IO_BAR = 0x%016llx\n", in_be64(phb->regs + 0x170));\r\npr_devel(" IO_BAMR = 0x%016llx\n", in_be64(phb->regs + 0x178));\r\npr_devel(" IO_SAR = 0x%016llx\n", in_be64(phb->regs + 0x180));\r\npr_devel(" M32_BAR = 0x%016llx\n", in_be64(phb->regs + 0x190));\r\npr_devel(" M32_BAMR = 0x%016llx\n", in_be64(phb->regs + 0x198));\r\npr_devel(" M32_SAR = 0x%016llx\n", in_be64(phb->regs + 0x1a0));\r\n}\r\nphb->hose->ops = &pnv_pci_ops;\r\nphb->bdfn_to_pe = pnv_ioda_bdfn_to_pe;\r\nphb->dma_dev_setup = pnv_pci_ioda_dma_dev_setup;\r\npnv_pci_init_ioda_msis(phb);\r\nppc_md.pcibios_fixup_phb = pnv_pci_ioda_fixup_phb;\r\nppc_md.pcibios_enable_device_hook = pnv_pci_enable_device_hook;\r\npci_add_flags(PCI_PROBE_ONLY | PCI_REASSIGN_ALL_RSRC);\r\nrc = opal_pci_reset(phb_id, OPAL_PCI_IODA_TABLE_RESET, OPAL_ASSERT_RESET);\r\nif (rc)\r\npr_warning(" OPAL Error %ld performing IODA table reset !\n", rc);\r\nopal_pci_set_pe(phb_id, 0, 0, 7, 1, 1 , OPAL_MAP_PE);\r\n}\r\nvoid __init pnv_pci_init_ioda_hub(struct device_node *np)\r\n{\r\nstruct device_node *phbn;\r\nconst u64 *prop64;\r\nu64 hub_id;\r\npr_info("Probing IODA IO-Hub %s\n", np->full_name);\r\nprop64 = of_get_property(np, "ibm,opal-hubid", NULL);\r\nif (!prop64) {\r\npr_err(" Missing \"ibm,opal-hubid\" property !\n");\r\nreturn;\r\n}\r\nhub_id = be64_to_cpup(prop64);\r\npr_devel(" HUB-ID : 0x%016llx\n", hub_id);\r\nfor_each_child_of_node(np, phbn) {\r\nif (of_device_is_compatible(phbn, "ibm,ioda-phb"))\r\npnv_pci_init_ioda1_phb(phbn);\r\n}\r\n}
