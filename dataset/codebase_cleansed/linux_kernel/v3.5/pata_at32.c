static int pata_at32_setup_timing(struct device *dev,\r\nstruct at32_ide_info *info,\r\nconst struct ata_timing *ata)\r\n{\r\nstruct smc_config *smc = &info->smc;\r\nstruct smc_timing timing;\r\nint active;\r\nint recover;\r\nmemset(&timing, 0, sizeof(struct smc_timing));\r\ntiming.read_cycle = ata->cyc8b;\r\ntiming.nrd_setup = ata->setup;\r\ntiming.nrd_pulse = ata->act8b;\r\ntiming.nrd_recover = ata->rec8b;\r\nsmc_set_timing(smc, &timing);\r\nsmc->nrd_setup = smc->nrd_setup + 1;\r\nactive = smc->nrd_setup + smc->nrd_pulse;\r\nrecover = smc->read_cycle - active;\r\nif (recover < 2)\r\nsmc->read_cycle = active + 2;\r\nsmc->ncs_read_setup = 1;\r\nsmc->ncs_read_pulse = smc->read_cycle - 2;\r\nsmc->write_cycle = smc->read_cycle;\r\nsmc->nwe_setup = smc->nrd_setup;\r\nsmc->nwe_pulse = smc->nrd_pulse;\r\nsmc->ncs_write_setup = smc->ncs_read_setup;\r\nsmc->ncs_write_pulse = smc->ncs_read_pulse;\r\ndev_dbg(dev, "ATA: C=%d S=%d P=%d R=%d\n",\r\nata->cyc8b, ata->setup, ata->act8b, ata->rec8b);\r\ndev_dbg(dev, "SMC: C=%d S=%d P=%d NS=%d NP=%d\n",\r\nsmc->read_cycle, smc->nrd_setup, smc->nrd_pulse,\r\nsmc->ncs_read_setup, smc->ncs_read_pulse);\r\nreturn smc_set_configuration(info->cs, smc);\r\n}\r\nstatic void pata_at32_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct ata_timing timing;\r\nstruct at32_ide_info *info = ap->host->private_data;\r\nint ret;\r\nret = ata_timing_compute(adev, adev->pio_mode, &timing, 1000, 0);\r\nif (ret) {\r\ndev_warn(ap->dev, "Failed to compute ATA timing %d\n", ret);\r\nreturn;\r\n}\r\nret = pata_at32_setup_timing(ap->dev, info, &timing);\r\nif (ret) {\r\ndev_warn(ap->dev, "Failed to setup ATA timing %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nstatic int __init pata_at32_init_one(struct device *dev,\r\nstruct at32_ide_info *info)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nhost = ata_host_alloc(dev, 1);\r\nif (!host)\r\nreturn -ENOMEM;\r\nap = host->ports[0];\r\nap->ops = &at32_port_ops;\r\nap->pio_mask = PIO_MASK;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->ioaddr.altstatus_addr = info->alt_addr + (0x06 << 1);\r\nap->ioaddr.ctl_addr = info->alt_addr + (0x06 << 1);\r\nap->ioaddr.data_addr = info->ide_addr + (ATA_REG_DATA << 1);\r\nap->ioaddr.error_addr = info->ide_addr + (ATA_REG_ERR << 1);\r\nap->ioaddr.feature_addr = info->ide_addr + (ATA_REG_FEATURE << 1);\r\nap->ioaddr.nsect_addr = info->ide_addr + (ATA_REG_NSECT << 1);\r\nap->ioaddr.lbal_addr = info->ide_addr + (ATA_REG_LBAL << 1);\r\nap->ioaddr.lbam_addr = info->ide_addr + (ATA_REG_LBAM << 1);\r\nap->ioaddr.lbah_addr = info->ide_addr + (ATA_REG_LBAH << 1);\r\nap->ioaddr.device_addr = info->ide_addr + (ATA_REG_DEVICE << 1);\r\nap->ioaddr.status_addr = info->ide_addr + (ATA_REG_STATUS << 1);\r\nap->ioaddr.command_addr = info->ide_addr + (ATA_REG_CMD << 1);\r\nhost->private_data = info;\r\nreturn ata_host_activate(host, info->irq, ata_sff_interrupt,\r\nIRQF_SHARED | IRQF_TRIGGER_RISING,\r\n&at32_sht);\r\n}\r\nstatic void __init pata_at32_debug_bus(struct device *dev,\r\nstruct at32_ide_info *info)\r\n{\r\nconst int d1 = 0xff;\r\nconst int d2 = 0x00;\r\nint i;\r\niowrite8(d1, info->alt_addr + (0x06 << 1));\r\niowrite8(d2, info->alt_addr + (0x06 << 1));\r\nfor (i = 0; i < 8; i++) {\r\niowrite8(d1, info->ide_addr + (i << 1));\r\niowrite8(d2, info->ide_addr + (i << 1));\r\n}\r\niowrite16(d1, info->ide_addr);\r\niowrite16(d1 << 8, info->ide_addr);\r\niowrite16(d1, info->ide_addr);\r\niowrite16(d1 << 8, info->ide_addr);\r\n}\r\nstatic int __init pata_at32_probe(struct platform_device *pdev)\r\n{\r\nconst struct ata_timing initial_timing =\r\n{XFER_PIO_0, 70, 290, 240, 600, 165, 150, 600, 0};\r\nstruct device *dev = &pdev->dev;\r\nstruct at32_ide_info *info;\r\nstruct ide_platform_data *board = pdev->dev.platform_data;\r\nstruct resource *res;\r\nint irq;\r\nint ret;\r\nif (!board)\r\nreturn -ENXIO;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\ninfo = kzalloc(sizeof(struct at32_ide_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->irq = irq;\r\ninfo->cs = board->cs;\r\ninfo->res_ide.start = res->start + CF_IDE_OFFSET;\r\ninfo->res_ide.end = info->res_ide.start + CF_RES_SIZE - 1;\r\ninfo->res_ide.name = "ide";\r\ninfo->res_ide.flags = IORESOURCE_MEM;\r\nret = request_resource(res, &info->res_ide);\r\nif (ret)\r\ngoto err_req_res_ide;\r\ninfo->res_alt.start = res->start + CF_ALT_IDE_OFFSET;\r\ninfo->res_alt.end = info->res_alt.start + CF_RES_SIZE - 1;\r\ninfo->res_alt.name = "alt";\r\ninfo->res_alt.flags = IORESOURCE_MEM;\r\nret = request_resource(res, &info->res_alt);\r\nif (ret)\r\ngoto err_req_res_alt;\r\ninfo->smc.bus_width = 2;\r\ninfo->smc.nrd_controlled = 1;\r\ninfo->smc.nwe_controlled = 0;\r\ninfo->smc.nwait_mode = 3;\r\ninfo->smc.byte_write = 0;\r\ninfo->smc.tdf_mode = 0;\r\ninfo->smc.tdf_cycles = 0;\r\nret = pata_at32_setup_timing(dev, info, &initial_timing);\r\nif (ret)\r\ngoto err_setup_timing;\r\nret = -ENOMEM;\r\ninfo->ide_addr = devm_ioremap(dev, info->res_ide.start, 16);\r\ninfo->alt_addr = devm_ioremap(dev, info->res_alt.start, 16);\r\nif (!info->ide_addr || !info->alt_addr)\r\ngoto err_ioremap;\r\n#ifdef DEBUG_BUS\r\npata_at32_debug_bus(dev, info);\r\n#endif\r\nret = pata_at32_init_one(dev, info);\r\nif (ret)\r\ngoto err_ata_device;\r\nreturn 0;\r\nerr_ata_device:\r\nerr_ioremap:\r\nerr_setup_timing:\r\nrelease_resource(&info->res_alt);\r\nerr_req_res_alt:\r\nrelease_resource(&info->res_ide);\r\nerr_req_res_ide:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int __exit pata_at32_remove(struct platform_device *pdev)\r\n{\r\nstruct ata_host *host = platform_get_drvdata(pdev);\r\nstruct at32_ide_info *info;\r\nif (!host)\r\nreturn 0;\r\ninfo = host->private_data;\r\nata_host_detach(host);\r\nif (!info)\r\nreturn 0;\r\nrelease_resource(&info->res_ide);\r\nrelease_resource(&info->res_alt);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int __init pata_at32_init(void)\r\n{\r\nreturn platform_driver_probe(&pata_at32_driver, pata_at32_probe);\r\n}\r\nstatic void __exit pata_at32_exit(void)\r\n{\r\nplatform_driver_unregister(&pata_at32_driver);\r\n}
