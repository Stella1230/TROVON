static int mxc_rnga_data_present(struct hwrng *rng)\r\n{\r\nint level;\r\nvoid __iomem *rng_base = (void __iomem *)rng->priv;\r\nlevel = ((__raw_readl(rng_base + RNGA_STATUS) &\r\nRNGA_STATUS_LEVEL_MASK) >> 8);\r\nreturn level > 0 ? 1 : 0;\r\n}\r\nstatic int mxc_rnga_data_read(struct hwrng *rng, u32 * data)\r\n{\r\nint err;\r\nu32 ctrl;\r\nvoid __iomem *rng_base = (void __iomem *)rng->priv;\r\n*data = __raw_readl(rng_base + RNGA_OUTPUT_FIFO);\r\nerr = __raw_readl(rng_base + RNGA_STATUS) & RNGA_STATUS_ERROR_INT;\r\nif (err) {\r\ndev_dbg(&rng_dev->dev, "Error while reading random number!\n");\r\nctrl = __raw_readl(rng_base + RNGA_CONTROL);\r\n__raw_writel(ctrl | RNGA_CONTROL_CLEAR_INT,\r\nrng_base + RNGA_CONTROL);\r\nreturn 0;\r\n} else\r\nreturn 4;\r\n}\r\nstatic int mxc_rnga_init(struct hwrng *rng)\r\n{\r\nu32 ctrl, osc;\r\nvoid __iomem *rng_base = (void __iomem *)rng->priv;\r\nctrl = __raw_readl(rng_base + RNGA_CONTROL);\r\n__raw_writel(ctrl & ~RNGA_CONTROL_SLEEP, rng_base + RNGA_CONTROL);\r\nosc = __raw_readl(rng_base + RNGA_STATUS);\r\nif (osc & RNGA_STATUS_OSC_DEAD) {\r\ndev_err(&rng_dev->dev, "RNGA Oscillator is dead!\n");\r\nreturn -ENODEV;\r\n}\r\nctrl = __raw_readl(rng_base + RNGA_CONTROL);\r\n__raw_writel(ctrl | RNGA_CONTROL_GO, rng_base + RNGA_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void mxc_rnga_cleanup(struct hwrng *rng)\r\n{\r\nu32 ctrl;\r\nvoid __iomem *rng_base = (void __iomem *)rng->priv;\r\nctrl = __raw_readl(rng_base + RNGA_CONTROL);\r\n__raw_writel(ctrl & ~RNGA_CONTROL_GO, rng_base + RNGA_CONTROL);\r\n}\r\nstatic int __init mxc_rnga_probe(struct platform_device *pdev)\r\n{\r\nint err = -ENODEV;\r\nstruct clk *clk;\r\nstruct resource *res, *mem;\r\nvoid __iomem *rng_base = NULL;\r\nif (rng_dev)\r\nreturn -EBUSY;\r\nclk = clk_get(&pdev->dev, "rng");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Could not get rng_clk!\n");\r\nerr = PTR_ERR(clk);\r\ngoto out;\r\n}\r\nclk_enable(clk);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerr = -ENOENT;\r\ngoto err_region;\r\n}\r\nmem = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (mem == NULL) {\r\nerr = -EBUSY;\r\ngoto err_region;\r\n}\r\nrng_base = ioremap(res->start, resource_size(res));\r\nif (!rng_base) {\r\nerr = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nmxc_rnga.priv = (unsigned long)rng_base;\r\nerr = hwrng_register(&mxc_rnga);\r\nif (err) {\r\ndev_err(&pdev->dev, "MXC RNGA registering failed (%d)\n", err);\r\ngoto err_register;\r\n}\r\nrng_dev = pdev;\r\ndev_info(&pdev->dev, "MXC RNGA Registered.\n");\r\nreturn 0;\r\nerr_register:\r\niounmap(rng_base);\r\nrng_base = NULL;\r\nerr_ioremap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_region:\r\nclk_disable(clk);\r\nclk_put(clk);\r\nout:\r\nreturn err;\r\n}\r\nstatic int __exit mxc_rnga_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvoid __iomem *rng_base = (void __iomem *)mxc_rnga.priv;\r\nstruct clk *clk = clk_get(&pdev->dev, "rng");\r\nhwrng_unregister(&mxc_rnga);\r\niounmap(rng_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable(clk);\r\nclk_put(clk);\r\nreturn 0;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nreturn platform_driver_probe(&mxc_rnga_driver, mxc_rnga_probe);\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nplatform_driver_unregister(&mxc_rnga_driver);\r\n}
