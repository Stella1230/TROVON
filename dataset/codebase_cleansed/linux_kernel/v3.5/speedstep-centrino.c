static int centrino_cpu_init_table(struct cpufreq_policy *policy)\r\n{\r\nstruct cpuinfo_x86 *cpu = &cpu_data(policy->cpu);\r\nstruct cpu_model *model;\r\nfor(model = models; model->cpu_id != NULL; model++)\r\nif (centrino_verify_cpu_id(cpu, model->cpu_id) &&\r\n(model->model_name == NULL ||\r\nstrcmp(cpu->x86_model_id, model->model_name) == 0))\r\nbreak;\r\nif (model->cpu_id == NULL) {\r\npr_debug("no support for CPU model \"%s\": "\r\n"send /proc/cpuinfo to " MAINTAINER "\n",\r\ncpu->x86_model_id);\r\nreturn -ENOENT;\r\n}\r\nif (model->op_points == NULL) {\r\npr_debug("no table support for CPU model \"%s\"\n",\r\ncpu->x86_model_id);\r\npr_debug("try using the acpi-cpufreq driver\n");\r\nreturn -ENOENT;\r\n}\r\nper_cpu(centrino_model, policy->cpu) = model;\r\npr_debug("found \"%s\": max frequency: %dkHz\n",\r\nmodel->model_name, model->max_freq);\r\nreturn 0;\r\n}\r\nstatic inline int centrino_cpu_init_table(struct cpufreq_policy *policy)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int centrino_verify_cpu_id(const struct cpuinfo_x86 *c,\r\nconst struct cpu_id *x)\r\n{\r\nif ((c->x86 == x->x86) &&\r\n(c->x86_model == x->x86_model) &&\r\n(c->x86_mask == x->x86_mask))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned extract_clock(unsigned msr, unsigned int cpu, int failsafe)\r\n{\r\nint i;\r\nif ((per_cpu(centrino_cpu, cpu) == &cpu_ids[CPU_BANIAS]) ||\r\n(per_cpu(centrino_cpu, cpu) == &cpu_ids[CPU_DOTHAN_A1]) ||\r\n(per_cpu(centrino_cpu, cpu) == &cpu_ids[CPU_DOTHAN_B0])) {\r\nmsr = (msr >> 8) & 0xff;\r\nreturn msr * 100000;\r\n}\r\nif ((!per_cpu(centrino_model, cpu)) ||\r\n(!per_cpu(centrino_model, cpu)->op_points))\r\nreturn 0;\r\nmsr &= 0xffff;\r\nfor (i = 0;\r\nper_cpu(centrino_model, cpu)->op_points[i].frequency\r\n!= CPUFREQ_TABLE_END;\r\ni++) {\r\nif (msr == per_cpu(centrino_model, cpu)->op_points[i].index)\r\nreturn per_cpu(centrino_model, cpu)->\r\nop_points[i].frequency;\r\n}\r\nif (failsafe)\r\nreturn per_cpu(centrino_model, cpu)->op_points[i-1].frequency;\r\nelse\r\nreturn 0;\r\n}\r\nstatic unsigned int get_cur_freq(unsigned int cpu)\r\n{\r\nunsigned l, h;\r\nunsigned clock_freq;\r\nrdmsr_on_cpu(cpu, MSR_IA32_PERF_STATUS, &l, &h);\r\nclock_freq = extract_clock(l, cpu, 0);\r\nif (unlikely(clock_freq == 0)) {\r\nrdmsr_on_cpu(cpu, MSR_IA32_PERF_CTL, &l, &h);\r\nclock_freq = extract_clock(l, cpu, 1);\r\n}\r\nreturn clock_freq;\r\n}\r\nstatic int centrino_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpuinfo_x86 *cpu = &cpu_data(policy->cpu);\r\nunsigned freq;\r\nunsigned l, h;\r\nint ret;\r\nint i;\r\nif (cpu->x86_vendor != X86_VENDOR_INTEL ||\r\n!cpu_has(cpu, X86_FEATURE_EST))\r\nreturn -ENODEV;\r\nif (cpu_has(cpu, X86_FEATURE_CONSTANT_TSC))\r\ncentrino_driver.flags |= CPUFREQ_CONST_LOOPS;\r\nif (policy->cpu != 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < N_IDS; i++)\r\nif (centrino_verify_cpu_id(cpu, &cpu_ids[i]))\r\nbreak;\r\nif (i != N_IDS)\r\nper_cpu(centrino_cpu, policy->cpu) = &cpu_ids[i];\r\nif (!per_cpu(centrino_cpu, policy->cpu)) {\r\npr_debug("found unsupported CPU with "\r\n"Enhanced SpeedStep: send /proc/cpuinfo to "\r\nMAINTAINER "\n");\r\nreturn -ENODEV;\r\n}\r\nif (centrino_cpu_init_table(policy)) {\r\nreturn -ENODEV;\r\n}\r\nrdmsr(MSR_IA32_MISC_ENABLE, l, h);\r\nif (!(l & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\r\nl |= MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP;\r\npr_debug("trying to enable Enhanced SpeedStep (%x)\n", l);\r\nwrmsr(MSR_IA32_MISC_ENABLE, l, h);\r\nrdmsr(MSR_IA32_MISC_ENABLE, l, h);\r\nif (!(l & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\r\nprintk(KERN_INFO PFX\r\n"couldn't enable Enhanced SpeedStep\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nfreq = get_cur_freq(policy->cpu);\r\npolicy->cpuinfo.transition_latency = 10000;\r\npolicy->cur = freq;\r\npr_debug("centrino_cpu_init: cur=%dkHz\n", policy->cur);\r\nret = cpufreq_frequency_table_cpuinfo(policy,\r\nper_cpu(centrino_model, policy->cpu)->op_points);\r\nif (ret)\r\nreturn (ret);\r\ncpufreq_frequency_table_get_attr(\r\nper_cpu(centrino_model, policy->cpu)->op_points, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int centrino_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nunsigned int cpu = policy->cpu;\r\nif (!per_cpu(centrino_model, cpu))\r\nreturn -ENODEV;\r\ncpufreq_frequency_table_put_attr(cpu);\r\nper_cpu(centrino_model, cpu) = NULL;\r\nreturn 0;\r\n}\r\nstatic int centrino_verify (struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy,\r\nper_cpu(centrino_model, policy->cpu)->op_points);\r\n}\r\nstatic int centrino_target (struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int newstate = 0;\r\nunsigned int msr, oldmsr = 0, h = 0, cpu = policy->cpu;\r\nstruct cpufreq_freqs freqs;\r\nint retval = 0;\r\nunsigned int j, k, first_cpu, tmp;\r\ncpumask_var_t covered_cpus;\r\nif (unlikely(!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nif (unlikely(per_cpu(centrino_model, cpu) == NULL)) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nif (unlikely(cpufreq_frequency_table_target(policy,\r\nper_cpu(centrino_model, cpu)->op_points,\r\ntarget_freq,\r\nrelation,\r\n&newstate))) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nfirst_cpu = 1;\r\nfor_each_cpu(j, policy->cpus) {\r\nint good_cpu;\r\nif (!cpu_online(j))\r\ncontinue;\r\nif (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)\r\ngood_cpu = cpumask_any_and(policy->cpus,\r\ncpu_online_mask);\r\nelse\r\ngood_cpu = j;\r\nif (good_cpu >= nr_cpu_ids) {\r\npr_debug("couldn't limit to CPUs in this domain\n");\r\nretval = -EAGAIN;\r\nif (first_cpu) {\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\nmsr = per_cpu(centrino_model, cpu)->op_points[newstate].index;\r\nif (first_cpu) {\r\nrdmsr_on_cpu(good_cpu, MSR_IA32_PERF_CTL, &oldmsr, &h);\r\nif (msr == (oldmsr & 0xffff)) {\r\npr_debug("no change needed - msr was and needs "\r\n"to be %x\n", oldmsr);\r\nretval = 0;\r\ngoto out;\r\n}\r\nfreqs.old = extract_clock(oldmsr, cpu, 0);\r\nfreqs.new = extract_clock(msr, cpu, 0);\r\npr_debug("target=%dkHz old=%d new=%d msr=%04x\n",\r\ntarget_freq, freqs.old, freqs.new, msr);\r\nfor_each_cpu(k, policy->cpus) {\r\nif (!cpu_online(k))\r\ncontinue;\r\nfreqs.cpu = k;\r\ncpufreq_notify_transition(&freqs,\r\nCPUFREQ_PRECHANGE);\r\n}\r\nfirst_cpu = 0;\r\noldmsr &= ~0xffff;\r\nmsr &= 0xffff;\r\noldmsr |= msr;\r\n}\r\nwrmsr_on_cpu(good_cpu, MSR_IA32_PERF_CTL, oldmsr, h);\r\nif (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)\r\nbreak;\r\ncpumask_set_cpu(j, covered_cpus);\r\n}\r\nfor_each_cpu(k, policy->cpus) {\r\nif (!cpu_online(k))\r\ncontinue;\r\nfreqs.cpu = k;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nif (unlikely(retval)) {\r\nfor_each_cpu(j, covered_cpus)\r\nwrmsr_on_cpu(j, MSR_IA32_PERF_CTL, oldmsr, h);\r\ntmp = freqs.new;\r\nfreqs.new = freqs.old;\r\nfreqs.old = tmp;\r\nfor_each_cpu(j, policy->cpus) {\r\nif (!cpu_online(j))\r\ncontinue;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\n}\r\n}\r\nretval = 0;\r\nout:\r\nfree_cpumask_var(covered_cpus);\r\nreturn retval;\r\n}\r\nstatic int __init centrino_init(void)\r\n{\r\nif (!x86_match_cpu(centrino_ids))\r\nreturn -ENODEV;\r\nreturn cpufreq_register_driver(&centrino_driver);\r\n}\r\nstatic void __exit centrino_exit(void)\r\n{\r\ncpufreq_unregister_driver(&centrino_driver);\r\n}
