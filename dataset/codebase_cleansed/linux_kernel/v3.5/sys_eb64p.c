static inline void\r\neb64p_update_irq_hw(unsigned int irq, unsigned long mask)\r\n{\r\noutb(mask >> (irq >= 24 ? 24 : 16), (irq >= 24 ? 0x27 : 0x26));\r\n}\r\nstatic inline void\r\neb64p_enable_irq(struct irq_data *d)\r\n{\r\neb64p_update_irq_hw(d->irq, cached_irq_mask &= ~(1 << d->irq));\r\n}\r\nstatic void\r\neb64p_disable_irq(struct irq_data *d)\r\n{\r\neb64p_update_irq_hw(d->irq, cached_irq_mask |= 1 << d->irq);\r\n}\r\nstatic void\r\neb64p_device_interrupt(unsigned long vector)\r\n{\r\nunsigned long pld;\r\nunsigned int i;\r\npld = inb(0x26) | (inb(0x27) << 8);\r\nwhile (pld) {\r\ni = ffz(~pld);\r\npld &= pld - 1;\r\nif (i == 5) {\r\nisa_device_interrupt(vector);\r\n} else {\r\nhandle_irq(16 + i);\r\n}\r\n}\r\n}\r\nstatic void __init\r\neb64p_init_irq(void)\r\n{\r\nlong i;\r\n#if defined(CONFIG_ALPHA_GENERIC) || defined(CONFIG_ALPHA_CABRIOLET)\r\nif (inw(0x806) != 0xffff) {\r\nextern struct alpha_machine_vector cabriolet_mv;\r\nprintk("Detected Cabriolet: correcting HWRPB.\n");\r\nhwrpb->sys_variation |= 2L << 10;\r\nhwrpb_update_checksum(hwrpb);\r\nalpha_mv = cabriolet_mv;\r\nalpha_mv.init_irq();\r\nreturn;\r\n}\r\n#endif\r\noutb(0xff, 0x26);\r\noutb(0xff, 0x27);\r\ninit_i8259a_irqs();\r\nfor (i = 16; i < 32; ++i) {\r\nirq_set_chip_and_handler(i, &eb64p_irq_type, handle_level_irq);\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\ncommon_init_isa_dma();\r\nsetup_irq(16+5, &isa_cascade_irqaction);\r\n}\r\nstatic int __init\r\neb64p_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[5][5] __initdata = {\r\n{16+7, 16+7, 16+7, 16+7, 16+7},\r\n{16+0, 16+0, 16+2, 16+4, 16+9},\r\n{16+1, 16+1, 16+3, 16+8, 16+10},\r\n{ -1, -1, -1, -1, -1},\r\n{16+6, 16+6, 16+6, 16+6, 16+6},\r\n};\r\nconst long min_idsel = 5, max_idsel = 9, irqs_per_slot = 5;\r\nreturn COMMON_TABLE_LOOKUP;\r\n}
