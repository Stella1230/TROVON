static int dump_udp_header(struct sbuff *m, const struct sk_buff *skb,\r\nu8 proto, int fragment, unsigned int offset)\r\n{\r\nstruct udphdr _udph;\r\nconst struct udphdr *uh;\r\nif (proto == IPPROTO_UDP)\r\nsb_add(m, "PROTO=UDP ");\r\nelse\r\nsb_add(m, "PROTO=UDPLITE ");\r\nif (fragment)\r\ngoto out;\r\nuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\r\nif (uh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ", skb->len - offset);\r\nreturn 1;\r\n}\r\nsb_add(m, "SPT=%u DPT=%u LEN=%u ", ntohs(uh->source), ntohs(uh->dest),\r\nntohs(uh->len));\r\nout:\r\nreturn 0;\r\n}\r\nstatic int dump_tcp_header(struct sbuff *m, const struct sk_buff *skb,\r\nu8 proto, int fragment, unsigned int offset,\r\nunsigned int logflags)\r\n{\r\nstruct tcphdr _tcph;\r\nconst struct tcphdr *th;\r\nsb_add(m, "PROTO=TCP ");\r\nif (fragment)\r\nreturn 0;\r\nth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ", skb->len - offset);\r\nreturn 1;\r\n}\r\nsb_add(m, "SPT=%u DPT=%u ", ntohs(th->source), ntohs(th->dest));\r\nif (logflags & XT_LOG_TCPSEQ)\r\nsb_add(m, "SEQ=%u ACK=%u ", ntohl(th->seq), ntohl(th->ack_seq));\r\nsb_add(m, "WINDOW=%u ", ntohs(th->window));\r\nsb_add(m, "RES=0x%02x ", (u_int8_t)(ntohl(tcp_flag_word(th) &\r\nTCP_RESERVED_BITS) >> 22));\r\nif (th->cwr)\r\nsb_add(m, "CWR ");\r\nif (th->ece)\r\nsb_add(m, "ECE ");\r\nif (th->urg)\r\nsb_add(m, "URG ");\r\nif (th->ack)\r\nsb_add(m, "ACK ");\r\nif (th->psh)\r\nsb_add(m, "PSH ");\r\nif (th->rst)\r\nsb_add(m, "RST ");\r\nif (th->syn)\r\nsb_add(m, "SYN ");\r\nif (th->fin)\r\nsb_add(m, "FIN ");\r\nsb_add(m, "URGP=%u ", ntohs(th->urg_ptr));\r\nif ((logflags & XT_LOG_TCPOPT) && th->doff*4 > sizeof(struct tcphdr)) {\r\nu_int8_t _opt[60 - sizeof(struct tcphdr)];\r\nconst u_int8_t *op;\r\nunsigned int i;\r\nunsigned int optsize = th->doff*4 - sizeof(struct tcphdr);\r\nop = skb_header_pointer(skb, offset + sizeof(struct tcphdr),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nsb_add(m, "OPT (TRUNCATED)");\r\nreturn 1;\r\n}\r\nsb_add(m, "OPT (");\r\nfor (i = 0; i < optsize; i++)\r\nsb_add(m, "%02X", op[i]);\r\nsb_add(m, ") ");\r\n}\r\nreturn 0;\r\n}\r\nstatic void dump_ipv4_packet(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb,\r\nunsigned int iphoff)\r\n{\r\nstruct iphdr _iph;\r\nconst struct iphdr *ih;\r\nunsigned int logflags;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nelse\r\nlogflags = NF_LOG_MASK;\r\nih = skb_header_pointer(skb, iphoff, sizeof(_iph), &_iph);\r\nif (ih == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "SRC=%pI4 DST=%pI4 ",\r\n&ih->saddr, &ih->daddr);\r\nsb_add(m, "LEN=%u TOS=0x%02X PREC=0x%02X TTL=%u ID=%u ",\r\nntohs(ih->tot_len), ih->tos & IPTOS_TOS_MASK,\r\nih->tos & IPTOS_PREC_MASK, ih->ttl, ntohs(ih->id));\r\nif (ntohs(ih->frag_off) & IP_CE)\r\nsb_add(m, "CE ");\r\nif (ntohs(ih->frag_off) & IP_DF)\r\nsb_add(m, "DF ");\r\nif (ntohs(ih->frag_off) & IP_MF)\r\nsb_add(m, "MF ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nsb_add(m, "FRAG:%u ", ntohs(ih->frag_off) & IP_OFFSET);\r\nif ((logflags & XT_LOG_IPOPT) &&\r\nih->ihl * 4 > sizeof(struct iphdr)) {\r\nconst unsigned char *op;\r\nunsigned char _opt[4 * 15 - sizeof(struct iphdr)];\r\nunsigned int i, optsize;\r\noptsize = ih->ihl * 4 - sizeof(struct iphdr);\r\nop = skb_header_pointer(skb, iphoff+sizeof(_iph),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "OPT (");\r\nfor (i = 0; i < optsize; i++)\r\nsb_add(m, "%02X", op[i]);\r\nsb_add(m, ") ");\r\n}\r\nswitch (ih->protocol) {\r\ncase IPPROTO_TCP:\r\nif (dump_tcp_header(m, skb, ih->protocol,\r\nntohs(ih->frag_off) & IP_OFFSET,\r\niphoff+ih->ihl*4, logflags))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\nif (dump_udp_header(m, skb, ih->protocol,\r\nntohs(ih->frag_off) & IP_OFFSET,\r\niphoff+ih->ihl*4))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_ICMP: {\r\nstruct icmphdr _icmph;\r\nconst struct icmphdr *ich;\r\nstatic const size_t required_len[NR_ICMP_TYPES+1]\r\n= { [ICMP_ECHOREPLY] = 4,\r\n[ICMP_DEST_UNREACH]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_SOURCE_QUENCH]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_REDIRECT]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_ECHO] = 4,\r\n[ICMP_TIME_EXCEEDED]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_PARAMETERPROB]\r\n= 8 + sizeof(struct iphdr),\r\n[ICMP_TIMESTAMP] = 20,\r\n[ICMP_TIMESTAMPREPLY] = 20,\r\n[ICMP_ADDRESS] = 12,\r\n[ICMP_ADDRESSREPLY] = 12 };\r\nsb_add(m, "PROTO=ICMP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nich = skb_header_pointer(skb, iphoff + ih->ihl * 4,\r\nsizeof(_icmph), &_icmph);\r\nif (ich == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "TYPE=%u CODE=%u ", ich->type, ich->code);\r\nif (ich->type <= NR_ICMP_TYPES &&\r\nrequired_len[ich->type] &&\r\nskb->len-iphoff-ih->ihl*4 < required_len[ich->type]) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nswitch (ich->type) {\r\ncase ICMP_ECHOREPLY:\r\ncase ICMP_ECHO:\r\nsb_add(m, "ID=%u SEQ=%u ",\r\nntohs(ich->un.echo.id),\r\nntohs(ich->un.echo.sequence));\r\nbreak;\r\ncase ICMP_PARAMETERPROB:\r\nsb_add(m, "PARAMETER=%u ",\r\nntohl(ich->un.gateway) >> 24);\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nsb_add(m, "GATEWAY=%pI4 ", &ich->un.gateway);\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_TIME_EXCEEDED:\r\nif (!iphoff) {\r\nsb_add(m, "[");\r\ndump_ipv4_packet(m, info, skb,\r\niphoff + ih->ihl*4+sizeof(_icmph));\r\nsb_add(m, "] ");\r\n}\r\nif (ich->type == ICMP_DEST_UNREACH &&\r\nich->code == ICMP_FRAG_NEEDED)\r\nsb_add(m, "MTU=%u ", ntohs(ich->un.frag.mtu));\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_AH: {\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\nsb_add(m, "PROTO=AH ");\r\nah = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_ahdr), &_ahdr);\r\nif (ah == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "SPI=0x%x ", ntohl(ah->spi));\r\nbreak;\r\n}\r\ncase IPPROTO_ESP: {\r\nstruct ip_esp_hdr _esph;\r\nconst struct ip_esp_hdr *eh;\r\nsb_add(m, "PROTO=ESP ");\r\nif (ntohs(ih->frag_off) & IP_OFFSET)\r\nbreak;\r\neh = skb_header_pointer(skb, iphoff+ih->ihl*4,\r\nsizeof(_esph), &_esph);\r\nif (eh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ",\r\nskb->len - iphoff - ih->ihl*4);\r\nbreak;\r\n}\r\nsb_add(m, "SPI=0x%x ", ntohl(eh->spi));\r\nbreak;\r\n}\r\ndefault:\r\nsb_add(m, "PROTO=%u ", ih->protocol);\r\n}\r\nif ((logflags & XT_LOG_UID) && !iphoff && skb->sk) {\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket && skb->sk->sk_socket->file)\r\nsb_add(m, "UID=%u GID=%u ",\r\nskb->sk->sk_socket->file->f_cred->fsuid,\r\nskb->sk->sk_socket->file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\n}\r\nif (!iphoff && skb->mark)\r\nsb_add(m, "MARK=0x%x ", skb->mark);\r\n}\r\nstatic void dump_ipv4_mac_header(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nunsigned int logflags = 0;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nif (!(logflags & XT_LOG_MACDECODE))\r\ngoto fallback;\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\nsb_add(m, "MACSRC=%pM MACDST=%pM MACPROTO=%04x ",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nfallback:\r\nsb_add(m, "MAC=");\r\nif (dev->hard_header_len &&\r\nskb->mac_header != skb->network_header) {\r\nconst unsigned char *p = skb_mac_header(skb);\r\nunsigned int i;\r\nsb_add(m, "%02x", *p++);\r\nfor (i = 1; i < dev->hard_header_len; i++, p++)\r\nsb_add(m, ":%02x", *p);\r\n}\r\nsb_add(m, " ");\r\n}\r\nstatic void\r\nlog_packet_common(struct sbuff *m,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nsb_add(m, "<%d>%sIN=%s OUT=%s ", loginfo->u.log.level,\r\nprefix,\r\nin ? in->name : "",\r\nout ? out->name : "");\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (skb->nf_bridge) {\r\nconst struct net_device *physindev;\r\nconst struct net_device *physoutdev;\r\nphysindev = skb->nf_bridge->physindev;\r\nif (physindev && in != physindev)\r\nsb_add(m, "PHYSIN=%s ", physindev->name);\r\nphysoutdev = skb->nf_bridge->physoutdev;\r\nif (physoutdev && out != physoutdev)\r\nsb_add(m, "PHYSOUT=%s ", physoutdev->name);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nipt_log_packet(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nstruct sbuff *m = sb_open();\r\nif (!loginfo)\r\nloginfo = &default_loginfo;\r\nlog_packet_common(m, pf, hooknum, skb, in, out, loginfo, prefix);\r\nif (in != NULL)\r\ndump_ipv4_mac_header(m, loginfo, skb);\r\ndump_ipv4_packet(m, loginfo, skb, 0);\r\nsb_close(m);\r\n}\r\nstatic void dump_ipv6_packet(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb, unsigned int ip6hoff,\r\nint recurse)\r\n{\r\nu_int8_t currenthdr;\r\nint fragment;\r\nstruct ipv6hdr _ip6h;\r\nconst struct ipv6hdr *ih;\r\nunsigned int ptr;\r\nunsigned int hdrlen = 0;\r\nunsigned int logflags;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nelse\r\nlogflags = NF_LOG_MASK;\r\nih = skb_header_pointer(skb, ip6hoff, sizeof(_ip6h), &_ip6h);\r\nif (ih == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nsb_add(m, "SRC=%pI6 DST=%pI6 ", &ih->saddr, &ih->daddr);\r\nsb_add(m, "LEN=%Zu TC=%u HOPLIMIT=%u FLOWLBL=%u ",\r\nntohs(ih->payload_len) + sizeof(struct ipv6hdr),\r\n(ntohl(*(__be32 *)ih) & 0x0ff00000) >> 20,\r\nih->hop_limit,\r\n(ntohl(*(__be32 *)ih) & 0x000fffff));\r\nfragment = 0;\r\nptr = ip6hoff + sizeof(struct ipv6hdr);\r\ncurrenthdr = ih->nexthdr;\r\nwhile (currenthdr != NEXTHDR_NONE && ip6t_ext_hdr(currenthdr)) {\r\nstruct ipv6_opt_hdr _hdr;\r\nconst struct ipv6_opt_hdr *hp;\r\nhp = skb_header_pointer(skb, ptr, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\nsb_add(m, "TRUNCATED");\r\nreturn;\r\n}\r\nif (logflags & XT_LOG_IPOPT)\r\nsb_add(m, "OPT ( ");\r\nswitch (currenthdr) {\r\ncase IPPROTO_FRAGMENT: {\r\nstruct frag_hdr _fhdr;\r\nconst struct frag_hdr *fh;\r\nsb_add(m, "FRAG:");\r\nfh = skb_header_pointer(skb, ptr, sizeof(_fhdr),\r\n&_fhdr);\r\nif (fh == NULL) {\r\nsb_add(m, "TRUNCATED ");\r\nreturn;\r\n}\r\nsb_add(m, "%u ", ntohs(fh->frag_off) & 0xFFF8);\r\nif (fh->frag_off & htons(0x0001))\r\nsb_add(m, "INCOMPLETE ");\r\nsb_add(m, "ID:%08x ", ntohl(fh->identification));\r\nif (ntohs(fh->frag_off) & 0xFFF8)\r\nfragment = 1;\r\nhdrlen = 8;\r\nbreak;\r\n}\r\ncase IPPROTO_DSTOPTS:\r\ncase IPPROTO_ROUTING:\r\ncase IPPROTO_HOPOPTS:\r\nif (fragment) {\r\nif (logflags & XT_LOG_IPOPT)\r\nsb_add(m, ")");\r\nreturn;\r\n}\r\nhdrlen = ipv6_optlen(hp);\r\nbreak;\r\ncase IPPROTO_AH:\r\nif (logflags & XT_LOG_IPOPT) {\r\nstruct ip_auth_hdr _ahdr;\r\nconst struct ip_auth_hdr *ah;\r\nsb_add(m, "AH ");\r\nif (fragment) {\r\nsb_add(m, ")");\r\nreturn;\r\n}\r\nah = skb_header_pointer(skb, ptr, sizeof(_ahdr),\r\n&_ahdr);\r\nif (ah == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] )",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "SPI=0x%x ", ntohl(ah->spi));\r\n}\r\nhdrlen = (hp->hdrlen+2)<<2;\r\nbreak;\r\ncase IPPROTO_ESP:\r\nif (logflags & XT_LOG_IPOPT) {\r\nstruct ip_esp_hdr _esph;\r\nconst struct ip_esp_hdr *eh;\r\nsb_add(m, "ESP ");\r\nif (fragment) {\r\nsb_add(m, ")");\r\nreturn;\r\n}\r\neh = skb_header_pointer(skb, ptr, sizeof(_esph),\r\n&_esph);\r\nif (eh == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] )",\r\nskb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "SPI=0x%x )", ntohl(eh->spi));\r\n}\r\nreturn;\r\ndefault:\r\nsb_add(m, "Unknown Ext Hdr %u", currenthdr);\r\nreturn;\r\n}\r\nif (logflags & XT_LOG_IPOPT)\r\nsb_add(m, ") ");\r\ncurrenthdr = hp->nexthdr;\r\nptr += hdrlen;\r\n}\r\nswitch (currenthdr) {\r\ncase IPPROTO_TCP:\r\nif (dump_tcp_header(m, skb, currenthdr, fragment, ptr,\r\nlogflags))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_UDP:\r\ncase IPPROTO_UDPLITE:\r\nif (dump_udp_header(m, skb, currenthdr, fragment, ptr))\r\nreturn;\r\nbreak;\r\ncase IPPROTO_ICMPV6: {\r\nstruct icmp6hdr _icmp6h;\r\nconst struct icmp6hdr *ic;\r\nsb_add(m, "PROTO=ICMPv6 ");\r\nif (fragment)\r\nbreak;\r\nic = skb_header_pointer(skb, ptr, sizeof(_icmp6h), &_icmp6h);\r\nif (ic == NULL) {\r\nsb_add(m, "INCOMPLETE [%u bytes] ", skb->len - ptr);\r\nreturn;\r\n}\r\nsb_add(m, "TYPE=%u CODE=%u ", ic->icmp6_type, ic->icmp6_code);\r\nswitch (ic->icmp6_type) {\r\ncase ICMPV6_ECHO_REQUEST:\r\ncase ICMPV6_ECHO_REPLY:\r\nsb_add(m, "ID=%u SEQ=%u ",\r\nntohs(ic->icmp6_identifier),\r\nntohs(ic->icmp6_sequence));\r\nbreak;\r\ncase ICMPV6_MGM_QUERY:\r\ncase ICMPV6_MGM_REPORT:\r\ncase ICMPV6_MGM_REDUCTION:\r\nbreak;\r\ncase ICMPV6_PARAMPROB:\r\nsb_add(m, "POINTER=%08x ", ntohl(ic->icmp6_pointer));\r\ncase ICMPV6_DEST_UNREACH:\r\ncase ICMPV6_PKT_TOOBIG:\r\ncase ICMPV6_TIME_EXCEED:\r\nif (recurse) {\r\nsb_add(m, "[");\r\ndump_ipv6_packet(m, info, skb,\r\nptr + sizeof(_icmp6h), 0);\r\nsb_add(m, "] ");\r\n}\r\nif (ic->icmp6_type == ICMPV6_PKT_TOOBIG)\r\nsb_add(m, "MTU=%u ", ntohl(ic->icmp6_mtu));\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nsb_add(m, "PROTO=%u ", currenthdr);\r\n}\r\nif ((logflags & XT_LOG_UID) && recurse && skb->sk) {\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket && skb->sk->sk_socket->file)\r\nsb_add(m, "UID=%u GID=%u ",\r\nskb->sk->sk_socket->file->f_cred->fsuid,\r\nskb->sk->sk_socket->file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\n}\r\nif (!recurse && skb->mark)\r\nsb_add(m, "MARK=0x%x ", skb->mark);\r\n}\r\nstatic void dump_ipv6_mac_header(struct sbuff *m,\r\nconst struct nf_loginfo *info,\r\nconst struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nunsigned int logflags = 0;\r\nif (info->type == NF_LOG_TYPE_LOG)\r\nlogflags = info->u.log.logflags;\r\nif (!(logflags & XT_LOG_MACDECODE))\r\ngoto fallback;\r\nswitch (dev->type) {\r\ncase ARPHRD_ETHER:\r\nsb_add(m, "MACSRC=%pM MACDST=%pM MACPROTO=%04x ",\r\neth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\r\nntohs(eth_hdr(skb)->h_proto));\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nfallback:\r\nsb_add(m, "MAC=");\r\nif (dev->hard_header_len &&\r\nskb->mac_header != skb->network_header) {\r\nconst unsigned char *p = skb_mac_header(skb);\r\nunsigned int len = dev->hard_header_len;\r\nunsigned int i;\r\nif (dev->type == ARPHRD_SIT) {\r\np -= ETH_HLEN;\r\nif (p < skb->head)\r\np = NULL;\r\n}\r\nif (p != NULL) {\r\nsb_add(m, "%02x", *p++);\r\nfor (i = 1; i < len; i++)\r\nsb_add(m, ":%02x", *p++);\r\n}\r\nsb_add(m, " ");\r\nif (dev->type == ARPHRD_SIT) {\r\nconst struct iphdr *iph =\r\n(struct iphdr *)skb_mac_header(skb);\r\nsb_add(m, "TUNNEL=%pI4->%pI4 ", &iph->saddr,\r\n&iph->daddr);\r\n}\r\n} else\r\nsb_add(m, " ");\r\n}\r\nstatic void\r\nip6t_log_packet(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nstruct sbuff *m = sb_open();\r\nif (!loginfo)\r\nloginfo = &default_loginfo;\r\nlog_packet_common(m, pf, hooknum, skb, in, out, loginfo, prefix);\r\nif (in != NULL)\r\ndump_ipv6_mac_header(m, loginfo, skb);\r\ndump_ipv6_packet(m, loginfo, skb, skb_network_offset(skb), 1);\r\nsb_close(m);\r\n}\r\nstatic unsigned int\r\nlog_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_log_info *loginfo = par->targinfo;\r\nstruct nf_loginfo li;\r\nli.type = NF_LOG_TYPE_LOG;\r\nli.u.log.level = loginfo->level;\r\nli.u.log.logflags = loginfo->logflags;\r\nif (par->family == NFPROTO_IPV4)\r\nipt_log_packet(NFPROTO_IPV4, par->hooknum, skb, par->in,\r\npar->out, &li, loginfo->prefix);\r\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\r\nelse if (par->family == NFPROTO_IPV6)\r\nip6t_log_packet(NFPROTO_IPV6, par->hooknum, skb, par->in,\r\npar->out, &li, loginfo->prefix);\r\n#endif\r\nelse\r\nWARN_ON_ONCE(1);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int log_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct xt_log_info *loginfo = par->targinfo;\r\nif (par->family != NFPROTO_IPV4 && par->family != NFPROTO_IPV6)\r\nreturn -EINVAL;\r\nif (loginfo->level >= 8) {\r\npr_debug("level %u >= 8\n", loginfo->level);\r\nreturn -EINVAL;\r\n}\r\nif (loginfo->prefix[sizeof(loginfo->prefix)-1] != '\0') {\r\npr_debug("prefix is not null-terminated\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init log_tg_init(void)\r\n{\r\nint ret;\r\nret = xt_register_targets(log_tg_regs, ARRAY_SIZE(log_tg_regs));\r\nif (ret < 0)\r\nreturn ret;\r\nnf_log_register(NFPROTO_IPV4, &ipt_log_logger);\r\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\r\nnf_log_register(NFPROTO_IPV6, &ip6t_log_logger);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit log_tg_exit(void)\r\n{\r\nnf_log_unregister(&ipt_log_logger);\r\n#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)\r\nnf_log_unregister(&ip6t_log_logger);\r\n#endif\r\nxt_unregister_targets(log_tg_regs, ARRAY_SIZE(log_tg_regs));\r\n}
