static void bluecard_activity_led_timeout(u_long arg)\r\n{\r\nbluecard_info_t *info = (bluecard_info_t *)arg;\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nif (!test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))\r\nreturn;\r\nif (test_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state))) {\r\noutb(0x08 | 0x20, iobase + 0x30);\r\n} else {\r\noutb(0x00, iobase + 0x30);\r\n}\r\n}\r\nstatic void bluecard_enable_activity_led(bluecard_info_t *info)\r\n{\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nif (!test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))\r\nreturn;\r\nif (test_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state))) {\r\noutb(0x10 | 0x40, iobase + 0x30);\r\nmod_timer(&(info->timer), jiffies + HZ / 4);\r\n} else {\r\noutb(0x08 | 0x20, iobase + 0x30);\r\nmod_timer(&(info->timer), jiffies + HZ / 2);\r\n}\r\n}\r\nstatic int bluecard_write(unsigned int iobase, unsigned int offset, __u8 *buf, int len)\r\n{\r\nint i, actual;\r\nactual = (len > 15) ? 15 : len;\r\noutb_p(actual, iobase + offset);\r\nfor (i = 0; i < actual; i++)\r\noutb_p(buf[i], iobase + offset + i + 1);\r\nreturn actual;\r\n}\r\nstatic void bluecard_write_wakeup(bluecard_info_t *info)\r\n{\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\nif (!test_bit(XMIT_SENDING_READY, &(info->tx_state)))\r\nreturn;\r\nif (test_and_set_bit(XMIT_SENDING, &(info->tx_state))) {\r\nset_bit(XMIT_WAKEUP, &(info->tx_state));\r\nreturn;\r\n}\r\ndo {\r\nregister unsigned int iobase = info->p_dev->resource[0]->start;\r\nregister unsigned int offset;\r\nregister unsigned char command;\r\nregister unsigned long ready_bit;\r\nregister struct sk_buff *skb;\r\nregister int len;\r\nclear_bit(XMIT_WAKEUP, &(info->tx_state));\r\nif (!pcmcia_dev_present(info->p_dev))\r\nreturn;\r\nif (test_bit(XMIT_BUFFER_NUMBER, &(info->tx_state))) {\r\nif (!test_bit(XMIT_BUF_TWO_READY, &(info->tx_state)))\r\nbreak;\r\noffset = 0x10;\r\ncommand = REG_COMMAND_TX_BUF_TWO;\r\nready_bit = XMIT_BUF_TWO_READY;\r\n} else {\r\nif (!test_bit(XMIT_BUF_ONE_READY, &(info->tx_state)))\r\nbreak;\r\noffset = 0x00;\r\ncommand = REG_COMMAND_TX_BUF_ONE;\r\nready_bit = XMIT_BUF_ONE_READY;\r\n}\r\nif (!(skb = skb_dequeue(&(info->txq))))\r\nbreak;\r\nif (bt_cb(skb)->pkt_type & 0x80) {\r\ninfo->ctrl_reg |= REG_CONTROL_RTS;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\n}\r\nbluecard_enable_activity_led(info);\r\nlen = bluecard_write(iobase, offset, skb->data, skb->len);\r\noutb_p(command, iobase + REG_COMMAND);\r\nclear_bit(ready_bit, &(info->tx_state));\r\nif (bt_cb(skb)->pkt_type & 0x80) {\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\r\nDEFINE_WAIT(wait);\r\nunsigned char baud_reg;\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase PKT_BAUD_RATE_460800:\r\nbaud_reg = REG_CONTROL_BAUD_RATE_460800;\r\nbreak;\r\ncase PKT_BAUD_RATE_230400:\r\nbaud_reg = REG_CONTROL_BAUD_RATE_230400;\r\nbreak;\r\ncase PKT_BAUD_RATE_115200:\r\nbaud_reg = REG_CONTROL_BAUD_RATE_115200;\r\nbreak;\r\ncase PKT_BAUD_RATE_57600:\r\ndefault:\r\nbaud_reg = REG_CONTROL_BAUD_RATE_57600;\r\nbreak;\r\n}\r\nprepare_to_wait(&wq, &wait, TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/10);\r\nfinish_wait(&wq, &wait);\r\ninfo->ctrl_reg &= ~0x03;\r\ninfo->ctrl_reg |= baud_reg;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\ninfo->ctrl_reg &= ~REG_CONTROL_RTS;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\nprepare_to_wait(&wq, &wait, TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\nfinish_wait(&wq, &wait);\r\n}\r\nif (len == skb->len) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_pull(skb, len);\r\nskb_queue_head(&(info->txq), skb);\r\n}\r\ninfo->hdev->stat.byte_tx += len;\r\nchange_bit(XMIT_BUFFER_NUMBER, &(info->tx_state));\r\n} while (test_bit(XMIT_WAKEUP, &(info->tx_state)));\r\nclear_bit(XMIT_SENDING, &(info->tx_state));\r\n}\r\nstatic int bluecard_read(unsigned int iobase, unsigned int offset, __u8 *buf, int size)\r\n{\r\nint i, n, len;\r\noutb(REG_COMMAND_RX_WIN_ONE, iobase + REG_COMMAND);\r\nlen = inb(iobase + offset);\r\nn = 0;\r\ni = 1;\r\nwhile (n < len) {\r\nif (i == 16) {\r\noutb(REG_COMMAND_RX_WIN_TWO, iobase + REG_COMMAND);\r\ni = 0;\r\n}\r\nbuf[n] = inb(iobase + offset + i);\r\nn++;\r\ni++;\r\n}\r\nreturn len;\r\n}\r\nstatic void bluecard_receive(bluecard_info_t *info, unsigned int offset)\r\n{\r\nunsigned int iobase;\r\nunsigned char buf[31];\r\nint i, len;\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\niobase = info->p_dev->resource[0]->start;\r\nif (test_bit(XMIT_SENDING_READY, &(info->tx_state)))\r\nbluecard_enable_activity_led(info);\r\nlen = bluecard_read(iobase, offset, buf, sizeof(buf));\r\nfor (i = 0; i < len; i++) {\r\nif (info->rx_skb == NULL) {\r\ninfo->rx_state = RECV_WAIT_PACKET_TYPE;\r\ninfo->rx_count = 0;\r\nif (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nreturn;\r\n}\r\n}\r\nif (info->rx_state == RECV_WAIT_PACKET_TYPE) {\r\ninfo->rx_skb->dev = (void *) info->hdev;\r\nbt_cb(info->rx_skb)->pkt_type = buf[i];\r\nswitch (bt_cb(info->rx_skb)->pkt_type) {\r\ncase 0x00:\r\nif (offset != 0x00) {\r\nset_bit(XMIT_BUF_ONE_READY, &(info->tx_state));\r\nset_bit(XMIT_BUF_TWO_READY, &(info->tx_state));\r\nset_bit(XMIT_SENDING_READY, &(info->tx_state));\r\nbluecard_write_wakeup(info);\r\n}\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\ncase HCI_EVENT_PKT:\r\ninfo->rx_state = RECV_WAIT_EVENT_HEADER;\r\ninfo->rx_count = HCI_EVENT_HDR_SIZE;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\ninfo->rx_state = RECV_WAIT_ACL_HEADER;\r\ninfo->rx_count = HCI_ACL_HDR_SIZE;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\ninfo->rx_state = RECV_WAIT_SCO_HEADER;\r\ninfo->rx_count = HCI_SCO_HDR_SIZE;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown HCI packet with type 0x%02x received", bt_cb(info->rx_skb)->pkt_type);\r\ninfo->hdev->stat.err_rx++;\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n} else {\r\n*skb_put(info->rx_skb, 1) = buf[i];\r\ninfo->rx_count--;\r\nif (info->rx_count == 0) {\r\nint dlen;\r\nstruct hci_event_hdr *eh;\r\nstruct hci_acl_hdr *ah;\r\nstruct hci_sco_hdr *sh;\r\nswitch (info->rx_state) {\r\ncase RECV_WAIT_EVENT_HEADER:\r\neh = hci_event_hdr(info->rx_skb);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = eh->plen;\r\nbreak;\r\ncase RECV_WAIT_ACL_HEADER:\r\nah = hci_acl_hdr(info->rx_skb);\r\ndlen = __le16_to_cpu(ah->dlen);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = dlen;\r\nbreak;\r\ncase RECV_WAIT_SCO_HEADER:\r\nsh = hci_sco_hdr(info->rx_skb);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = sh->dlen;\r\nbreak;\r\ncase RECV_WAIT_DATA:\r\nhci_recv_frame(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\ninfo->hdev->stat.byte_rx += len;\r\n}\r\nstatic irqreturn_t bluecard_interrupt(int irq, void *dev_inst)\r\n{\r\nbluecard_info_t *info = dev_inst;\r\nunsigned int iobase;\r\nunsigned char reg;\r\nif (!info || !info->hdev)\r\nreturn IRQ_NONE;\r\nif (!test_bit(CARD_READY, &(info->hw_state)))\r\nreturn IRQ_HANDLED;\r\niobase = info->p_dev->resource[0]->start;\r\nspin_lock(&(info->lock));\r\ninfo->ctrl_reg &= ~REG_CONTROL_INTERRUPT;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\nreg = inb(iobase + REG_INTERRUPT);\r\nif ((reg != 0x00) && (reg != 0xff)) {\r\nif (reg & 0x04) {\r\nbluecard_receive(info, 0x00);\r\noutb(0x04, iobase + REG_INTERRUPT);\r\noutb(REG_COMMAND_RX_BUF_ONE, iobase + REG_COMMAND);\r\n}\r\nif (reg & 0x08) {\r\nbluecard_receive(info, 0x10);\r\noutb(0x08, iobase + REG_INTERRUPT);\r\noutb(REG_COMMAND_RX_BUF_TWO, iobase + REG_COMMAND);\r\n}\r\nif (reg & 0x01) {\r\nset_bit(XMIT_BUF_ONE_READY, &(info->tx_state));\r\noutb(0x01, iobase + REG_INTERRUPT);\r\nbluecard_write_wakeup(info);\r\n}\r\nif (reg & 0x02) {\r\nset_bit(XMIT_BUF_TWO_READY, &(info->tx_state));\r\noutb(0x02, iobase + REG_INTERRUPT);\r\nbluecard_write_wakeup(info);\r\n}\r\n}\r\ninfo->ctrl_reg |= REG_CONTROL_INTERRUPT;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\nspin_unlock(&(info->lock));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bluecard_hci_set_baud_rate(struct hci_dev *hdev, int baud)\r\n{\r\nbluecard_info_t *info = hci_get_drvdata(hdev);\r\nstruct sk_buff *skb;\r\nunsigned char cmd[] = { HCI_COMMAND_PKT, 0x09, 0xfc, 0x01, 0x03 };\r\nif (!(skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nreturn -1;\r\n}\r\nswitch (baud) {\r\ncase 460800:\r\ncmd[4] = 0x00;\r\nbt_cb(skb)->pkt_type = PKT_BAUD_RATE_460800;\r\nbreak;\r\ncase 230400:\r\ncmd[4] = 0x01;\r\nbt_cb(skb)->pkt_type = PKT_BAUD_RATE_230400;\r\nbreak;\r\ncase 115200:\r\ncmd[4] = 0x02;\r\nbt_cb(skb)->pkt_type = PKT_BAUD_RATE_115200;\r\nbreak;\r\ncase 57600:\r\ndefault:\r\ncmd[4] = 0x03;\r\nbt_cb(skb)->pkt_type = PKT_BAUD_RATE_57600;\r\nbreak;\r\n}\r\nmemcpy(skb_put(skb, sizeof(cmd)), cmd, sizeof(cmd));\r\nskb_queue_tail(&(info->txq), skb);\r\nbluecard_write_wakeup(info);\r\nreturn 0;\r\n}\r\nstatic int bluecard_hci_flush(struct hci_dev *hdev)\r\n{\r\nbluecard_info_t *info = hci_get_drvdata(hdev);\r\nskb_queue_purge(&(info->txq));\r\nreturn 0;\r\n}\r\nstatic int bluecard_hci_open(struct hci_dev *hdev)\r\n{\r\nbluecard_info_t *info = hci_get_drvdata(hdev);\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nif (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))\r\nbluecard_hci_set_baud_rate(hdev, DEFAULT_BAUD_RATE);\r\nif (test_and_set_bit(HCI_RUNNING, &(hdev->flags)))\r\nreturn 0;\r\nif (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state))) {\r\noutb(0x08 | 0x20, iobase + 0x30);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bluecard_hci_close(struct hci_dev *hdev)\r\n{\r\nbluecard_info_t *info = hci_get_drvdata(hdev);\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nif (!test_and_clear_bit(HCI_RUNNING, &(hdev->flags)))\r\nreturn 0;\r\nbluecard_hci_flush(hdev);\r\nif (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state))) {\r\noutb(0x00, iobase + 0x30);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bluecard_hci_send_frame(struct sk_buff *skb)\r\n{\r\nbluecard_info_t *info;\r\nstruct hci_dev *hdev = (struct hci_dev *)(skb->dev);\r\nif (!hdev) {\r\nBT_ERR("Frame for unknown HCI device (hdev=NULL)");\r\nreturn -ENODEV;\r\n}\r\ninfo = hci_get_drvdata(hdev);\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n};\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&(info->txq), skb);\r\nbluecard_write_wakeup(info);\r\nreturn 0;\r\n}\r\nstatic int bluecard_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int bluecard_open(bluecard_info_t *info)\r\n{\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nstruct hci_dev *hdev;\r\nunsigned char id;\r\nspin_lock_init(&(info->lock));\r\ninit_timer(&(info->timer));\r\ninfo->timer.function = &bluecard_activity_led_timeout;\r\ninfo->timer.data = (u_long)info;\r\nskb_queue_head_init(&(info->txq));\r\ninfo->rx_state = RECV_WAIT_PACKET_TYPE;\r\ninfo->rx_count = 0;\r\ninfo->rx_skb = NULL;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\nreturn -ENOMEM;\r\n}\r\ninfo->hdev = hdev;\r\nhdev->bus = HCI_PCCARD;\r\nhci_set_drvdata(hdev, info);\r\nSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\r\nhdev->open = bluecard_hci_open;\r\nhdev->close = bluecard_hci_close;\r\nhdev->flush = bluecard_hci_flush;\r\nhdev->send = bluecard_hci_send_frame;\r\nhdev->ioctl = bluecard_hci_ioctl;\r\nid = inb(iobase + 0x30);\r\nif ((id & 0x0f) == 0x02)\r\nset_bit(CARD_HAS_PCCARD_ID, &(info->hw_state));\r\nif (id & 0x10)\r\nset_bit(CARD_HAS_POWER_LED, &(info->hw_state));\r\nif (id & 0x20)\r\nset_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state));\r\ninfo->ctrl_reg = REG_CONTROL_BT_RESET | REG_CONTROL_CARD_RESET;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\noutb(0x80, iobase + 0x30);\r\nmsleep(10);\r\noutb(0x00, iobase + 0x30);\r\ninfo->ctrl_reg = REG_CONTROL_BT_ON | REG_CONTROL_BT_RES_PU;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\noutb(0xff, iobase + REG_INTERRUPT);\r\ninfo->ctrl_reg |= REG_CONTROL_INTERRUPT;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\nif ((id & 0x0f) == 0x03) {\r\ninfo->ctrl_reg |= REG_CONTROL_RTS;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\ninfo->ctrl_reg |= 0x03;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\ninfo->ctrl_reg &= ~REG_CONTROL_RTS;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\nset_bit(XMIT_BUF_ONE_READY, &(info->tx_state));\r\nset_bit(XMIT_BUF_TWO_READY, &(info->tx_state));\r\nset_bit(XMIT_SENDING_READY, &(info->tx_state));\r\n}\r\noutb(REG_COMMAND_RX_BUF_ONE, iobase + REG_COMMAND);\r\noutb(REG_COMMAND_RX_BUF_TWO, iobase + REG_COMMAND);\r\nset_bit(CARD_READY, &(info->hw_state));\r\nskb_queue_purge(&(info->txq));\r\noutb((0x0f << RTS_LEVEL_SHIFT_BITS) | 1, iobase + REG_RX_CONTROL);\r\nmsleep(1250);\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\ninfo->hdev = NULL;\r\nhci_free_dev(hdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bluecard_close(bluecard_info_t *info)\r\n{\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nstruct hci_dev *hdev = info->hdev;\r\nif (!hdev)\r\nreturn -ENODEV;\r\nbluecard_hci_close(hdev);\r\nclear_bit(CARD_READY, &(info->hw_state));\r\ninfo->ctrl_reg = REG_CONTROL_BT_RESET | REG_CONTROL_CARD_RESET;\r\noutb(info->ctrl_reg, iobase + REG_CONTROL);\r\noutb(0x80, iobase + 0x30);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nreturn 0;\r\n}\r\nstatic int bluecard_probe(struct pcmcia_device *link)\r\n{\r\nbluecard_info_t *info;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nreturn bluecard_config(link);\r\n}\r\nstatic void bluecard_detach(struct pcmcia_device *link)\r\n{\r\nbluecard_info_t *info = link->priv;\r\nbluecard_release(link);\r\nkfree(info);\r\n}\r\nstatic int bluecard_config(struct pcmcia_device *link)\r\n{\r\nbluecard_info_t *info = link->priv;\r\nint i, n;\r\nlink->config_index = 0x20;\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nlink->resource[0]->end = 64;\r\nlink->io_lines = 6;\r\nfor (n = 0; n < 0x400; n += 0x40) {\r\nlink->resource[0]->start = n ^ 0x300;\r\ni = pcmcia_request_io(link);\r\nif (i == 0)\r\nbreak;\r\n}\r\nif (i != 0)\r\ngoto failed;\r\ni = pcmcia_request_irq(link, bluecard_interrupt);\r\nif (i != 0)\r\ngoto failed;\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\ngoto failed;\r\nif (bluecard_open(info) != 0)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\nbluecard_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void bluecard_release(struct pcmcia_device *link)\r\n{\r\nbluecard_info_t *info = link->priv;\r\nbluecard_close(info);\r\ndel_timer(&(info->timer));\r\npcmcia_disable_device(link);\r\n}\r\nstatic int __init init_bluecard_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&bluecard_driver);\r\n}\r\nstatic void __exit exit_bluecard_cs(void)\r\n{\r\npcmcia_unregister_driver(&bluecard_driver);\r\n}
