void nlmclnt_next_cookie(struct nlm_cookie *c)\r\n{\r\nu32 cookie = atomic_inc_return(&nlm_cookie);\r\nmemcpy(c->data, &cookie, 4);\r\nc->len=4;\r\n}\r\nstatic struct nlm_lockowner *nlm_get_lockowner(struct nlm_lockowner *lockowner)\r\n{\r\natomic_inc(&lockowner->count);\r\nreturn lockowner;\r\n}\r\nstatic void nlm_put_lockowner(struct nlm_lockowner *lockowner)\r\n{\r\nif (!atomic_dec_and_lock(&lockowner->count, &lockowner->host->h_lock))\r\nreturn;\r\nlist_del(&lockowner->list);\r\nspin_unlock(&lockowner->host->h_lock);\r\nnlmclnt_release_host(lockowner->host);\r\nkfree(lockowner);\r\n}\r\nstatic inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\r\n{\r\nstruct nlm_lockowner *lockowner;\r\nlist_for_each_entry(lockowner, &host->h_lockowners, list) {\r\nif (lockowner->pid == pid)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline uint32_t __nlm_alloc_pid(struct nlm_host *host)\r\n{\r\nuint32_t res;\r\ndo {\r\nres = host->h_pidcount++;\r\n} while (nlm_pidbusy(host, res) < 0);\r\nreturn res;\r\n}\r\nstatic struct nlm_lockowner *__nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\r\n{\r\nstruct nlm_lockowner *lockowner;\r\nlist_for_each_entry(lockowner, &host->h_lockowners, list) {\r\nif (lockowner->owner != owner)\r\ncontinue;\r\nreturn nlm_get_lockowner(lockowner);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct nlm_lockowner *nlm_find_lockowner(struct nlm_host *host, fl_owner_t owner)\r\n{\r\nstruct nlm_lockowner *res, *new = NULL;\r\nspin_lock(&host->h_lock);\r\nres = __nlm_find_lockowner(host, owner);\r\nif (res == NULL) {\r\nspin_unlock(&host->h_lock);\r\nnew = kmalloc(sizeof(*new), GFP_KERNEL);\r\nspin_lock(&host->h_lock);\r\nres = __nlm_find_lockowner(host, owner);\r\nif (res == NULL && new != NULL) {\r\nres = new;\r\natomic_set(&new->count, 1);\r\nnew->owner = owner;\r\nnew->pid = __nlm_alloc_pid(host);\r\nnew->host = nlm_get_host(host);\r\nlist_add(&new->list, &host->h_lockowners);\r\nnew = NULL;\r\n}\r\n}\r\nspin_unlock(&host->h_lock);\r\nkfree(new);\r\nreturn res;\r\n}\r\nstatic void nlmclnt_setlockargs(struct nlm_rqst *req, struct file_lock *fl)\r\n{\r\nstruct nlm_args *argp = &req->a_args;\r\nstruct nlm_lock *lock = &argp->lock;\r\nnlmclnt_next_cookie(&argp->cookie);\r\nmemcpy(&lock->fh, NFS_FH(fl->fl_file->f_path.dentry->d_inode), sizeof(struct nfs_fh));\r\nlock->caller = utsname()->nodename;\r\nlock->oh.data = req->a_owner;\r\nlock->oh.len = snprintf(req->a_owner, sizeof(req->a_owner), "%u@%s",\r\n(unsigned int)fl->fl_u.nfs_fl.owner->pid,\r\nutsname()->nodename);\r\nlock->svid = fl->fl_u.nfs_fl.owner->pid;\r\nlock->fl.fl_start = fl->fl_start;\r\nlock->fl.fl_end = fl->fl_end;\r\nlock->fl.fl_type = fl->fl_type;\r\n}\r\nstatic void nlmclnt_release_lockargs(struct nlm_rqst *req)\r\n{\r\nBUG_ON(req->a_args.lock.fl.fl_ops != NULL);\r\n}\r\nint nlmclnt_proc(struct nlm_host *host, int cmd, struct file_lock *fl)\r\n{\r\nstruct nlm_rqst *call;\r\nint status;\r\nnlm_get_host(host);\r\ncall = nlm_alloc_call(host);\r\nif (call == NULL)\r\nreturn -ENOMEM;\r\nnlmclnt_locks_init_private(fl, host);\r\nnlmclnt_setlockargs(call, fl);\r\nif (IS_SETLK(cmd) || IS_SETLKW(cmd)) {\r\nif (fl->fl_type != F_UNLCK) {\r\ncall->a_args.block = IS_SETLKW(cmd) ? 1 : 0;\r\nstatus = nlmclnt_lock(call, fl);\r\n} else\r\nstatus = nlmclnt_unlock(call, fl);\r\n} else if (IS_GETLK(cmd))\r\nstatus = nlmclnt_test(call, fl);\r\nelse\r\nstatus = -EINVAL;\r\nfl->fl_ops->fl_release_private(fl);\r\nfl->fl_ops = NULL;\r\ndprintk("lockd: clnt proc returns %d\n", status);\r\nreturn status;\r\n}\r\nstruct nlm_rqst *nlm_alloc_call(struct nlm_host *host)\r\n{\r\nstruct nlm_rqst *call;\r\nfor(;;) {\r\ncall = kzalloc(sizeof(*call), GFP_KERNEL);\r\nif (call != NULL) {\r\natomic_set(&call->a_count, 1);\r\nlocks_init_lock(&call->a_args.lock.fl);\r\nlocks_init_lock(&call->a_res.lock.fl);\r\ncall->a_host = host;\r\nreturn call;\r\n}\r\nif (signalled())\r\nbreak;\r\nprintk("nlm_alloc_call: failed, waiting for memory\n");\r\nschedule_timeout_interruptible(5*HZ);\r\n}\r\nnlmclnt_release_host(host);\r\nreturn NULL;\r\n}\r\nvoid nlmclnt_release_call(struct nlm_rqst *call)\r\n{\r\nif (!atomic_dec_and_test(&call->a_count))\r\nreturn;\r\nnlmclnt_release_host(call->a_host);\r\nnlmclnt_release_lockargs(call);\r\nkfree(call);\r\n}\r\nstatic void nlmclnt_rpc_release(void *data)\r\n{\r\nnlmclnt_release_call(data);\r\n}\r\nstatic int nlm_wait_on_grace(wait_queue_head_t *queue)\r\n{\r\nDEFINE_WAIT(wait);\r\nint status = -EINTR;\r\nprepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);\r\nif (!signalled ()) {\r\nschedule_timeout(NLMCLNT_GRACE_WAIT);\r\ntry_to_freeze();\r\nif (!signalled ())\r\nstatus = 0;\r\n}\r\nfinish_wait(queue, &wait);\r\nreturn status;\r\n}\r\nstatic int\r\nnlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\r\n{\r\nstruct nlm_host *host = req->a_host;\r\nstruct rpc_clnt *clnt;\r\nstruct nlm_args *argp = &req->a_args;\r\nstruct nlm_res *resp = &req->a_res;\r\nstruct rpc_message msg = {\r\n.rpc_argp = argp,\r\n.rpc_resp = resp,\r\n.rpc_cred = cred,\r\n};\r\nint status;\r\ndprintk("lockd: call procedure %d on %s\n",\r\n(int)proc, host->h_name);\r\ndo {\r\nif (host->h_reclaiming && !argp->reclaim)\r\ngoto in_grace_period;\r\nif ((clnt = nlm_bind_host(host)) == NULL)\r\nreturn -ENOLCK;\r\nmsg.rpc_proc = &clnt->cl_procinfo[proc];\r\nif ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\r\ndprintk("lockd: rpc_call returned error %d\n", -status);\r\nswitch (status) {\r\ncase -EPROTONOSUPPORT:\r\nstatus = -EINVAL;\r\nbreak;\r\ncase -ECONNREFUSED:\r\ncase -ETIMEDOUT:\r\ncase -ENOTCONN:\r\nnlm_rebind_host(host);\r\nstatus = -EAGAIN;\r\nbreak;\r\ncase -ERESTARTSYS:\r\nreturn signalled () ? -EINTR : status;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n} else\r\nif (resp->status == nlm_lck_denied_grace_period) {\r\ndprintk("lockd: server in grace period\n");\r\nif (argp->reclaim) {\r\nprintk(KERN_WARNING\r\n"lockd: spurious grace period reject?!\n");\r\nreturn -ENOLCK;\r\n}\r\n} else {\r\nif (!argp->reclaim) {\r\nwake_up_all(&host->h_gracewait);\r\n}\r\ndprintk("lockd: server returns status %d\n",\r\nntohl(resp->status));\r\nreturn 0;\r\n}\r\nin_grace_period:\r\nstatus = nlm_wait_on_grace(&host->h_gracewait);\r\n} while (status == 0);\r\nreturn status;\r\n}\r\nstatic struct rpc_task *__nlm_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\r\n{\r\nstruct nlm_host *host = req->a_host;\r\nstruct rpc_clnt *clnt;\r\nstruct rpc_task_setup task_setup_data = {\r\n.rpc_message = msg,\r\n.callback_ops = tk_ops,\r\n.callback_data = req,\r\n.flags = RPC_TASK_ASYNC,\r\n};\r\ndprintk("lockd: call procedure %d on %s (async)\n",\r\n(int)proc, host->h_name);\r\nclnt = nlm_bind_host(host);\r\nif (clnt == NULL)\r\ngoto out_err;\r\nmsg->rpc_proc = &clnt->cl_procinfo[proc];\r\ntask_setup_data.rpc_client = clnt;\r\nreturn rpc_run_task(&task_setup_data);\r\nout_err:\r\ntk_ops->rpc_release(req);\r\nreturn ERR_PTR(-ENOLCK);\r\n}\r\nstatic int nlm_do_async_call(struct nlm_rqst *req, u32 proc, struct rpc_message *msg, const struct rpc_call_ops *tk_ops)\r\n{\r\nstruct rpc_task *task;\r\ntask = __nlm_async_call(req, proc, msg, tk_ops);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nrpc_put_task(task);\r\nreturn 0;\r\n}\r\nint nlm_async_call(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_argp = &req->a_args,\r\n.rpc_resp = &req->a_res,\r\n};\r\nreturn nlm_do_async_call(req, proc, &msg, tk_ops);\r\n}\r\nint nlm_async_reply(struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_argp = &req->a_res,\r\n};\r\nreturn nlm_do_async_call(req, proc, &msg, tk_ops);\r\n}\r\nstatic int nlmclnt_async_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc, const struct rpc_call_ops *tk_ops)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_argp = &req->a_args,\r\n.rpc_resp = &req->a_res,\r\n.rpc_cred = cred,\r\n};\r\nstruct rpc_task *task;\r\nint err;\r\ntask = __nlm_async_call(req, proc, &msg, tk_ops);\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nerr = rpc_wait_for_completion_task(task);\r\nrpc_put_task(task);\r\nreturn err;\r\n}\r\nstatic int\r\nnlmclnt_test(struct nlm_rqst *req, struct file_lock *fl)\r\n{\r\nint status;\r\nstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_TEST);\r\nif (status < 0)\r\ngoto out;\r\nswitch (req->a_res.status) {\r\ncase nlm_granted:\r\nfl->fl_type = F_UNLCK;\r\nbreak;\r\ncase nlm_lck_denied:\r\nfl->fl_start = req->a_res.lock.fl.fl_start;\r\nfl->fl_end = req->a_res.lock.fl.fl_end;\r\nfl->fl_type = req->a_res.lock.fl.fl_type;\r\nfl->fl_pid = 0;\r\nbreak;\r\ndefault:\r\nstatus = nlm_stat_to_errno(req->a_res.status);\r\n}\r\nout:\r\nnlmclnt_release_call(req);\r\nreturn status;\r\n}\r\nstatic void nlmclnt_locks_copy_lock(struct file_lock *new, struct file_lock *fl)\r\n{\r\nspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\r\nnew->fl_u.nfs_fl.state = fl->fl_u.nfs_fl.state;\r\nnew->fl_u.nfs_fl.owner = nlm_get_lockowner(fl->fl_u.nfs_fl.owner);\r\nlist_add_tail(&new->fl_u.nfs_fl.list, &fl->fl_u.nfs_fl.owner->host->h_granted);\r\nspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\r\n}\r\nstatic void nlmclnt_locks_release_private(struct file_lock *fl)\r\n{\r\nspin_lock(&fl->fl_u.nfs_fl.owner->host->h_lock);\r\nlist_del(&fl->fl_u.nfs_fl.list);\r\nspin_unlock(&fl->fl_u.nfs_fl.owner->host->h_lock);\r\nnlm_put_lockowner(fl->fl_u.nfs_fl.owner);\r\n}\r\nstatic void nlmclnt_locks_init_private(struct file_lock *fl, struct nlm_host *host)\r\n{\r\nBUG_ON(fl->fl_ops != NULL);\r\nfl->fl_u.nfs_fl.state = 0;\r\nfl->fl_u.nfs_fl.owner = nlm_find_lockowner(host, fl->fl_owner);\r\nINIT_LIST_HEAD(&fl->fl_u.nfs_fl.list);\r\nfl->fl_ops = &nlmclnt_lock_ops;\r\n}\r\nstatic int do_vfs_lock(struct file_lock *fl)\r\n{\r\nint res = 0;\r\nswitch (fl->fl_flags & (FL_POSIX|FL_FLOCK)) {\r\ncase FL_POSIX:\r\nres = posix_lock_file_wait(fl->fl_file, fl);\r\nbreak;\r\ncase FL_FLOCK:\r\nres = flock_lock_file_wait(fl->fl_file, fl);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn res;\r\n}\r\nstatic int\r\nnlmclnt_lock(struct nlm_rqst *req, struct file_lock *fl)\r\n{\r\nstruct rpc_cred *cred = nfs_file_cred(fl->fl_file);\r\nstruct nlm_host *host = req->a_host;\r\nstruct nlm_res *resp = &req->a_res;\r\nstruct nlm_wait *block = NULL;\r\nunsigned char fl_flags = fl->fl_flags;\r\nunsigned char fl_type;\r\nint status = -ENOLCK;\r\nif (nsm_monitor(host) < 0)\r\ngoto out;\r\nreq->a_args.state = nsm_local_state;\r\nfl->fl_flags |= FL_ACCESS;\r\nstatus = do_vfs_lock(fl);\r\nfl->fl_flags = fl_flags;\r\nif (status < 0)\r\ngoto out;\r\nblock = nlmclnt_prepare_block(host, fl);\r\nagain:\r\nresp->status = nlm_lck_blocked;\r\nfor(;;) {\r\nfl->fl_u.nfs_fl.state = host->h_state;\r\nstatus = nlmclnt_call(cred, req, NLMPROC_LOCK);\r\nif (status < 0)\r\nbreak;\r\nif (resp->status == nlm_lck_denied_grace_period)\r\ncontinue;\r\nif (resp->status != nlm_lck_blocked)\r\nbreak;\r\nstatus = nlmclnt_block(block, req, NLMCLNT_POLL_TIMEOUT);\r\nif (status < 0)\r\nbreak;\r\nif (resp->status != nlm_lck_blocked)\r\nbreak;\r\n}\r\nif (resp->status == nlm_lck_blocked) {\r\nif (!req->a_args.block)\r\ngoto out_unlock;\r\nif (nlmclnt_cancel(host, req->a_args.block, fl) == 0)\r\ngoto out_unblock;\r\n}\r\nif (resp->status == nlm_granted) {\r\ndown_read(&host->h_rwsem);\r\nif (fl->fl_u.nfs_fl.state != host->h_state) {\r\nup_read(&host->h_rwsem);\r\ngoto again;\r\n}\r\nfl->fl_flags |= FL_SLEEP;\r\nif (do_vfs_lock(fl) < 0)\r\nprintk(KERN_WARNING "%s: VFS is out of sync with lock manager!\n", __func__);\r\nup_read(&host->h_rwsem);\r\nfl->fl_flags = fl_flags;\r\nstatus = 0;\r\n}\r\nif (status < 0)\r\ngoto out_unlock;\r\nif (resp->status == nlm_lck_denied && (fl_flags & FL_SLEEP))\r\nstatus = -ENOLCK;\r\nelse\r\nstatus = nlm_stat_to_errno(resp->status);\r\nout_unblock:\r\nnlmclnt_finish_block(block);\r\nout:\r\nnlmclnt_release_call(req);\r\nreturn status;\r\nout_unlock:\r\ndprintk("lockd: lock attempt ended in fatal error.\n"\r\n" Attempting to unlock.\n");\r\nnlmclnt_finish_block(block);\r\nfl_type = fl->fl_type;\r\nfl->fl_type = F_UNLCK;\r\ndown_read(&host->h_rwsem);\r\ndo_vfs_lock(fl);\r\nup_read(&host->h_rwsem);\r\nfl->fl_type = fl_type;\r\nfl->fl_flags = fl_flags;\r\nnlmclnt_async_call(cred, req, NLMPROC_UNLOCK, &nlmclnt_unlock_ops);\r\nreturn status;\r\n}\r\nint\r\nnlmclnt_reclaim(struct nlm_host *host, struct file_lock *fl)\r\n{\r\nstruct nlm_rqst reqst, *req;\r\nint status;\r\nreq = &reqst;\r\nmemset(req, 0, sizeof(*req));\r\nlocks_init_lock(&req->a_args.lock.fl);\r\nlocks_init_lock(&req->a_res.lock.fl);\r\nreq->a_host = host;\r\nreq->a_flags = 0;\r\nnlmclnt_setlockargs(req, fl);\r\nreq->a_args.reclaim = 1;\r\nstatus = nlmclnt_call(nfs_file_cred(fl->fl_file), req, NLMPROC_LOCK);\r\nif (status >= 0 && req->a_res.status == nlm_granted)\r\nreturn 0;\r\nprintk(KERN_WARNING "lockd: failed to reclaim lock for pid %d "\r\n"(errno %d, status %d)\n", fl->fl_pid,\r\nstatus, ntohl(req->a_res.status));\r\nreturn -ENOLCK;\r\n}\r\nstatic int\r\nnlmclnt_unlock(struct nlm_rqst *req, struct file_lock *fl)\r\n{\r\nstruct nlm_host *host = req->a_host;\r\nstruct nlm_res *resp = &req->a_res;\r\nint status;\r\nunsigned char fl_flags = fl->fl_flags;\r\nfl->fl_flags |= FL_EXISTS;\r\ndown_read(&host->h_rwsem);\r\nstatus = do_vfs_lock(fl);\r\nup_read(&host->h_rwsem);\r\nfl->fl_flags = fl_flags;\r\nif (status == -ENOENT) {\r\nstatus = 0;\r\ngoto out;\r\n}\r\natomic_inc(&req->a_count);\r\nstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\r\nNLMPROC_UNLOCK, &nlmclnt_unlock_ops);\r\nif (status < 0)\r\ngoto out;\r\nif (resp->status == nlm_granted)\r\ngoto out;\r\nif (resp->status != nlm_lck_denied_nolocks)\r\nprintk("lockd: unexpected unlock status: %d\n",\r\nntohl(resp->status));\r\nstatus = -ENOLCK;\r\nout:\r\nnlmclnt_release_call(req);\r\nreturn status;\r\n}\r\nstatic void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\r\n{\r\nstruct nlm_rqst *req = data;\r\nu32 status = ntohl(req->a_res.status);\r\nif (RPC_ASSASSINATED(task))\r\ngoto die;\r\nif (task->tk_status < 0) {\r\ndprintk("lockd: unlock failed (err = %d)\n", -task->tk_status);\r\nswitch (task->tk_status) {\r\ncase -EACCES:\r\ncase -EIO:\r\ngoto die;\r\ndefault:\r\ngoto retry_rebind;\r\n}\r\n}\r\nif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\r\nrpc_delay(task, NLMCLNT_GRACE_WAIT);\r\ngoto retry_unlock;\r\n}\r\nif (status != NLM_LCK_GRANTED)\r\nprintk(KERN_WARNING "lockd: unexpected unlock status: %d\n", status);\r\ndie:\r\nreturn;\r\nretry_rebind:\r\nnlm_rebind_host(req->a_host);\r\nretry_unlock:\r\nrpc_restart_call(task);\r\n}\r\nstatic int nlmclnt_cancel(struct nlm_host *host, int block, struct file_lock *fl)\r\n{\r\nstruct nlm_rqst *req;\r\nint status;\r\ndprintk("lockd: blocking lock attempt was interrupted by a signal.\n"\r\n" Attempting to cancel lock.\n");\r\nreq = nlm_alloc_call(nlm_get_host(host));\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->a_flags = RPC_TASK_ASYNC;\r\nnlmclnt_setlockargs(req, fl);\r\nreq->a_args.block = block;\r\natomic_inc(&req->a_count);\r\nstatus = nlmclnt_async_call(nfs_file_cred(fl->fl_file), req,\r\nNLMPROC_CANCEL, &nlmclnt_cancel_ops);\r\nif (status == 0 && req->a_res.status == nlm_lck_denied)\r\nstatus = -ENOLCK;\r\nnlmclnt_release_call(req);\r\nreturn status;\r\n}\r\nstatic void nlmclnt_cancel_callback(struct rpc_task *task, void *data)\r\n{\r\nstruct nlm_rqst *req = data;\r\nu32 status = ntohl(req->a_res.status);\r\nif (RPC_ASSASSINATED(task))\r\ngoto die;\r\nif (task->tk_status < 0) {\r\ndprintk("lockd: CANCEL call error %d, retrying.\n",\r\ntask->tk_status);\r\ngoto retry_cancel;\r\n}\r\ndprintk("lockd: cancel status %u (task %u)\n",\r\nstatus, task->tk_pid);\r\nswitch (status) {\r\ncase NLM_LCK_GRANTED:\r\ncase NLM_LCK_DENIED_GRACE_PERIOD:\r\ncase NLM_LCK_DENIED:\r\nbreak;\r\ncase NLM_LCK_DENIED_NOLOCKS:\r\ndprintk("lockd: CANCEL failed (server has no locks)\n");\r\ngoto retry_cancel;\r\ndefault:\r\nprintk(KERN_NOTICE "lockd: weird return %d for CANCEL call\n",\r\nstatus);\r\n}\r\ndie:\r\nreturn;\r\nretry_cancel:\r\nif (req->a_retries++ >= NLMCLNT_MAX_RETRIES)\r\ngoto die;\r\nnlm_rebind_host(req->a_host);\r\nrpc_restart_call(task);\r\nrpc_delay(task, 30 * HZ);\r\n}\r\nstatic int\r\nnlm_stat_to_errno(__be32 status)\r\n{\r\nswitch(ntohl(status)) {\r\ncase NLM_LCK_GRANTED:\r\nreturn 0;\r\ncase NLM_LCK_DENIED:\r\nreturn -EAGAIN;\r\ncase NLM_LCK_DENIED_NOLOCKS:\r\ncase NLM_LCK_DENIED_GRACE_PERIOD:\r\nreturn -ENOLCK;\r\ncase NLM_LCK_BLOCKED:\r\nprintk(KERN_NOTICE "lockd: unexpected status NLM_BLOCKED\n");\r\nreturn -ENOLCK;\r\n#ifdef CONFIG_LOCKD_V4\r\ncase NLM_DEADLCK:\r\nreturn -EDEADLK;\r\ncase NLM_ROFS:\r\nreturn -EROFS;\r\ncase NLM_STALE_FH:\r\nreturn -ESTALE;\r\ncase NLM_FBIG:\r\nreturn -EOVERFLOW;\r\ncase NLM_FAILED:\r\nreturn -ENOLCK;\r\n#endif\r\n}\r\nprintk(KERN_NOTICE "lockd: unexpected server status %d\n",\r\nntohl(status));\r\nreturn -ENOLCK;\r\n}
