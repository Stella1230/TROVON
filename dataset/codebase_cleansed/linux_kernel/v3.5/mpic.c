static inline unsigned int mpic_processor_id(struct mpic *mpic)\r\n{\r\nunsigned int cpu = 0;\r\nif (!(mpic->flags & MPIC_SECONDARY))\r\ncpu = hard_smp_processor_id();\r\nreturn cpu;\r\n}\r\nstatic inline u32 _mpic_read(enum mpic_reg_type type,\r\nstruct mpic_reg_bank *rb,\r\nunsigned int reg)\r\n{\r\nswitch(type) {\r\n#ifdef CONFIG_PPC_DCR\r\ncase mpic_access_dcr:\r\nreturn dcr_read(rb->dhost, reg);\r\n#endif\r\ncase mpic_access_mmio_be:\r\nreturn in_be32(rb->base + (reg >> 2));\r\ncase mpic_access_mmio_le:\r\ndefault:\r\nreturn in_le32(rb->base + (reg >> 2));\r\n}\r\n}\r\nstatic inline void _mpic_write(enum mpic_reg_type type,\r\nstruct mpic_reg_bank *rb,\r\nunsigned int reg, u32 value)\r\n{\r\nswitch(type) {\r\n#ifdef CONFIG_PPC_DCR\r\ncase mpic_access_dcr:\r\ndcr_write(rb->dhost, reg, value);\r\nbreak;\r\n#endif\r\ncase mpic_access_mmio_be:\r\nout_be32(rb->base + (reg >> 2), value);\r\nbreak;\r\ncase mpic_access_mmio_le:\r\ndefault:\r\nout_le32(rb->base + (reg >> 2), value);\r\nbreak;\r\n}\r\n}\r\nstatic inline u32 _mpic_ipi_read(struct mpic *mpic, unsigned int ipi)\r\n{\r\nenum mpic_reg_type type = mpic->reg_type;\r\nunsigned int offset = MPIC_INFO(GREG_IPI_VECTOR_PRI_0) +\r\n(ipi * MPIC_INFO(GREG_IPI_STRIDE));\r\nif ((mpic->flags & MPIC_BROKEN_IPI) && type == mpic_access_mmio_le)\r\ntype = mpic_access_mmio_be;\r\nreturn _mpic_read(type, &mpic->gregs, offset);\r\n}\r\nstatic inline void _mpic_ipi_write(struct mpic *mpic, unsigned int ipi, u32 value)\r\n{\r\nunsigned int offset = MPIC_INFO(GREG_IPI_VECTOR_PRI_0) +\r\n(ipi * MPIC_INFO(GREG_IPI_STRIDE));\r\n_mpic_write(mpic->reg_type, &mpic->gregs, offset, value);\r\n}\r\nstatic inline u32 _mpic_tm_read(struct mpic *mpic, unsigned int tm)\r\n{\r\nunsigned int offset = MPIC_INFO(TIMER_VECTOR_PRI) +\r\n((tm & 3) * MPIC_INFO(TIMER_STRIDE));\r\nif (tm >= 4)\r\noffset += 0x1000 / 4;\r\nreturn _mpic_read(mpic->reg_type, &mpic->tmregs, offset);\r\n}\r\nstatic inline void _mpic_tm_write(struct mpic *mpic, unsigned int tm, u32 value)\r\n{\r\nunsigned int offset = MPIC_INFO(TIMER_VECTOR_PRI) +\r\n((tm & 3) * MPIC_INFO(TIMER_STRIDE));\r\nif (tm >= 4)\r\noffset += 0x1000 / 4;\r\n_mpic_write(mpic->reg_type, &mpic->tmregs, offset, value);\r\n}\r\nstatic inline u32 _mpic_cpu_read(struct mpic *mpic, unsigned int reg)\r\n{\r\nunsigned int cpu = mpic_processor_id(mpic);\r\nreturn _mpic_read(mpic->reg_type, &mpic->cpuregs[cpu], reg);\r\n}\r\nstatic inline void _mpic_cpu_write(struct mpic *mpic, unsigned int reg, u32 value)\r\n{\r\nunsigned int cpu = mpic_processor_id(mpic);\r\n_mpic_write(mpic->reg_type, &mpic->cpuregs[cpu], reg, value);\r\n}\r\nstatic inline u32 _mpic_irq_read(struct mpic *mpic, unsigned int src_no, unsigned int reg)\r\n{\r\nunsigned int isu = src_no >> mpic->isu_shift;\r\nunsigned int idx = src_no & mpic->isu_mask;\r\nunsigned int val;\r\nval = _mpic_read(mpic->reg_type, &mpic->isus[isu],\r\nreg + (idx * MPIC_INFO(IRQ_STRIDE)));\r\n#ifdef CONFIG_MPIC_BROKEN_REGREAD\r\nif (reg == 0)\r\nval = (val & (MPIC_VECPRI_MASK | MPIC_VECPRI_ACTIVITY)) |\r\nmpic->isu_reg0_shadow[src_no];\r\n#endif\r\nreturn val;\r\n}\r\nstatic inline void _mpic_irq_write(struct mpic *mpic, unsigned int src_no,\r\nunsigned int reg, u32 value)\r\n{\r\nunsigned int isu = src_no >> mpic->isu_shift;\r\nunsigned int idx = src_no & mpic->isu_mask;\r\n_mpic_write(mpic->reg_type, &mpic->isus[isu],\r\nreg + (idx * MPIC_INFO(IRQ_STRIDE)), value);\r\n#ifdef CONFIG_MPIC_BROKEN_REGREAD\r\nif (reg == 0)\r\nmpic->isu_reg0_shadow[src_no] =\r\nvalue & ~(MPIC_VECPRI_MASK | MPIC_VECPRI_ACTIVITY);\r\n#endif\r\n}\r\nstatic void _mpic_map_mmio(struct mpic *mpic, phys_addr_t phys_addr,\r\nstruct mpic_reg_bank *rb, unsigned int offset,\r\nunsigned int size)\r\n{\r\nrb->base = ioremap(phys_addr + offset, size);\r\nBUG_ON(rb->base == NULL);\r\n}\r\nstatic void _mpic_map_dcr(struct mpic *mpic, struct mpic_reg_bank *rb,\r\nunsigned int offset, unsigned int size)\r\n{\r\nphys_addr_t phys_addr = dcr_resource_start(mpic->node, 0);\r\nrb->dhost = dcr_map(mpic->node, phys_addr + offset, size);\r\nBUG_ON(!DCR_MAP_OK(rb->dhost));\r\n}\r\nstatic inline void mpic_map(struct mpic *mpic,\r\nphys_addr_t phys_addr, struct mpic_reg_bank *rb,\r\nunsigned int offset, unsigned int size)\r\n{\r\nif (mpic->flags & MPIC_USES_DCR)\r\n_mpic_map_dcr(mpic, rb, offset, size);\r\nelse\r\n_mpic_map_mmio(mpic, phys_addr, rb, offset, size);\r\n}\r\nstatic void __init mpic_test_broken_ipi(struct mpic *mpic)\r\n{\r\nu32 r;\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_IPI_VECTOR_PRI_0), MPIC_VECPRI_MASK);\r\nr = mpic_read(mpic->gregs, MPIC_INFO(GREG_IPI_VECTOR_PRI_0));\r\nif (r == le32_to_cpu(MPIC_VECPRI_MASK)) {\r\nprintk(KERN_INFO "mpic: Detected reversed IPI registers\n");\r\nmpic->flags |= MPIC_BROKEN_IPI;\r\n}\r\n}\r\nstatic inline int mpic_is_ht_interrupt(struct mpic *mpic, unsigned int source)\r\n{\r\nif (source >= 128 || !mpic->fixups)\r\nreturn 0;\r\nreturn mpic->fixups[source].base != NULL;\r\n}\r\nstatic inline void mpic_ht_end_irq(struct mpic *mpic, unsigned int source)\r\n{\r\nstruct mpic_irq_fixup *fixup = &mpic->fixups[source];\r\nif (fixup->applebase) {\r\nunsigned int soff = (fixup->index >> 3) & ~3;\r\nunsigned int mask = 1U << (fixup->index & 0x1f);\r\nwritel(mask, fixup->applebase + soff);\r\n} else {\r\nraw_spin_lock(&mpic->fixup_lock);\r\nwriteb(0x11 + 2 * fixup->index, fixup->base + 2);\r\nwritel(fixup->data, fixup->base + 4);\r\nraw_spin_unlock(&mpic->fixup_lock);\r\n}\r\n}\r\nstatic void mpic_startup_ht_interrupt(struct mpic *mpic, unsigned int source,\r\nbool level)\r\n{\r\nstruct mpic_irq_fixup *fixup = &mpic->fixups[source];\r\nunsigned long flags;\r\nu32 tmp;\r\nif (fixup->base == NULL)\r\nreturn;\r\nDBG("startup_ht_interrupt(0x%x) index: %d\n",\r\nsource, fixup->index);\r\nraw_spin_lock_irqsave(&mpic->fixup_lock, flags);\r\nwriteb(0x10 + 2 * fixup->index, fixup->base + 2);\r\ntmp = readl(fixup->base + 4);\r\ntmp &= ~(0x23U);\r\nif (level)\r\ntmp |= 0x22;\r\nwritel(tmp, fixup->base + 4);\r\nraw_spin_unlock_irqrestore(&mpic->fixup_lock, flags);\r\n#ifdef CONFIG_PM\r\nmpic->save_data[source].fixup_data = tmp | 1;\r\n#endif\r\n}\r\nstatic void mpic_shutdown_ht_interrupt(struct mpic *mpic, unsigned int source)\r\n{\r\nstruct mpic_irq_fixup *fixup = &mpic->fixups[source];\r\nunsigned long flags;\r\nu32 tmp;\r\nif (fixup->base == NULL)\r\nreturn;\r\nDBG("shutdown_ht_interrupt(0x%x)\n", source);\r\nraw_spin_lock_irqsave(&mpic->fixup_lock, flags);\r\nwriteb(0x10 + 2 * fixup->index, fixup->base + 2);\r\ntmp = readl(fixup->base + 4);\r\ntmp |= 1;\r\nwritel(tmp, fixup->base + 4);\r\nraw_spin_unlock_irqrestore(&mpic->fixup_lock, flags);\r\n#ifdef CONFIG_PM\r\nmpic->save_data[source].fixup_data = tmp & ~1;\r\n#endif\r\n}\r\nstatic void __init mpic_scan_ht_msi(struct mpic *mpic, u8 __iomem *devbase,\r\nunsigned int devfn)\r\n{\r\nu8 __iomem *base;\r\nu8 pos, flags;\r\nu64 addr = 0;\r\nfor (pos = readb(devbase + PCI_CAPABILITY_LIST); pos != 0;\r\npos = readb(devbase + pos + PCI_CAP_LIST_NEXT)) {\r\nu8 id = readb(devbase + pos + PCI_CAP_LIST_ID);\r\nif (id == PCI_CAP_ID_HT) {\r\nid = readb(devbase + pos + 3);\r\nif ((id & HT_5BIT_CAP_MASK) == HT_CAPTYPE_MSI_MAPPING)\r\nbreak;\r\n}\r\n}\r\nif (pos == 0)\r\nreturn;\r\nbase = devbase + pos;\r\nflags = readb(base + HT_MSI_FLAGS);\r\nif (!(flags & HT_MSI_FLAGS_FIXED)) {\r\naddr = readl(base + HT_MSI_ADDR_LO) & HT_MSI_ADDR_LO_MASK;\r\naddr = addr | ((u64)readl(base + HT_MSI_ADDR_HI) << 32);\r\n}\r\nprintk(KERN_DEBUG "mpic: - HT:%02x.%x %s MSI mapping found @ 0x%llx\n",\r\nPCI_SLOT(devfn), PCI_FUNC(devfn),\r\nflags & HT_MSI_FLAGS_ENABLE ? "enabled" : "disabled", addr);\r\nif (!(flags & HT_MSI_FLAGS_ENABLE))\r\nwriteb(flags | HT_MSI_FLAGS_ENABLE, base + HT_MSI_FLAGS);\r\n}\r\nstatic void __init mpic_scan_ht_msi(struct mpic *mpic, u8 __iomem *devbase,\r\nunsigned int devfn)\r\n{\r\nreturn;\r\n}\r\nstatic void __init mpic_scan_ht_pic(struct mpic *mpic, u8 __iomem *devbase,\r\nunsigned int devfn, u32 vdid)\r\n{\r\nint i, irq, n;\r\nu8 __iomem *base;\r\nu32 tmp;\r\nu8 pos;\r\nfor (pos = readb(devbase + PCI_CAPABILITY_LIST); pos != 0;\r\npos = readb(devbase + pos + PCI_CAP_LIST_NEXT)) {\r\nu8 id = readb(devbase + pos + PCI_CAP_LIST_ID);\r\nif (id == PCI_CAP_ID_HT) {\r\nid = readb(devbase + pos + 3);\r\nif ((id & HT_5BIT_CAP_MASK) == HT_CAPTYPE_IRQ)\r\nbreak;\r\n}\r\n}\r\nif (pos == 0)\r\nreturn;\r\nbase = devbase + pos;\r\nwriteb(0x01, base + 2);\r\nn = (readl(base + 4) >> 16) & 0xff;\r\nprintk(KERN_INFO "mpic: - HT:%02x.%x [0x%02x] vendor %04x device %04x"\r\n" has %d irqs\n",\r\ndevfn >> 3, devfn & 0x7, pos, vdid & 0xffff, vdid >> 16, n + 1);\r\nfor (i = 0; i <= n; i++) {\r\nwriteb(0x10 + 2 * i, base + 2);\r\ntmp = readl(base + 4);\r\nirq = (tmp >> 16) & 0xff;\r\nDBG("HT PIC index 0x%x, irq 0x%x, tmp: %08x\n", i, irq, tmp);\r\ntmp |= 0x1;\r\nwritel(tmp, base + 4);\r\nmpic->fixups[irq].index = i;\r\nmpic->fixups[irq].base = base;\r\nif ((vdid & 0xffff) == 0x106b)\r\nmpic->fixups[irq].applebase = devbase + 0x60;\r\nelse\r\nmpic->fixups[irq].applebase = NULL;\r\nwriteb(0x11 + 2 * i, base + 2);\r\nmpic->fixups[irq].data = readl(base + 4) | 0x80000000;\r\n}\r\n}\r\nstatic void __init mpic_scan_ht_pics(struct mpic *mpic)\r\n{\r\nunsigned int devfn;\r\nu8 __iomem *cfgspace;\r\nprintk(KERN_INFO "mpic: Setting up HT PICs workarounds for U3/U4\n");\r\nmpic->fixups = kzalloc(128 * sizeof(*mpic->fixups), GFP_KERNEL);\r\nBUG_ON(mpic->fixups == NULL);\r\nraw_spin_lock_init(&mpic->fixup_lock);\r\ncfgspace = ioremap(0xf2000000, 0x10000);\r\nBUG_ON(cfgspace == NULL);\r\nfor (devfn = 0; devfn < 0x100; devfn++) {\r\nu8 __iomem *devbase = cfgspace + (devfn << 8);\r\nu8 hdr_type = readb(devbase + PCI_HEADER_TYPE);\r\nu32 l = readl(devbase + PCI_VENDOR_ID);\r\nu16 s;\r\nDBG("devfn %x, l: %x\n", devfn, l);\r\nif (l == 0xffffffff || l == 0x00000000 ||\r\nl == 0x0000ffff || l == 0xffff0000)\r\ngoto next;\r\ns = readw(devbase + PCI_STATUS);\r\nif (!(s & PCI_STATUS_CAP_LIST))\r\ngoto next;\r\nmpic_scan_ht_pic(mpic, devbase, devfn, l);\r\nmpic_scan_ht_msi(mpic, devbase, devfn);\r\nnext:\r\nif (PCI_FUNC(devfn) == 0 && (hdr_type & 0x80) == 0)\r\ndevfn += 7;\r\n}\r\n}\r\nstatic inline int mpic_is_ht_interrupt(struct mpic *mpic, unsigned int source)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init mpic_scan_ht_pics(struct mpic *mpic)\r\n{\r\n}\r\nstatic struct mpic *mpic_find(unsigned int irq)\r\n{\r\nif (irq < NUM_ISA_INTERRUPTS)\r\nreturn NULL;\r\nreturn irq_get_chip_data(irq);\r\n}\r\nstatic unsigned int mpic_is_ipi(struct mpic *mpic, unsigned int src)\r\n{\r\nreturn (src >= mpic->ipi_vecs[0] && src <= mpic->ipi_vecs[3]);\r\n}\r\nstatic unsigned int mpic_is_tm(struct mpic *mpic, unsigned int src)\r\n{\r\nreturn (src >= mpic->timer_vecs[0] && src <= mpic->timer_vecs[7]);\r\n}\r\nstatic inline u32 mpic_physmask(u32 cpumask)\r\n{\r\nint i;\r\nu32 mask = 0;\r\nfor (i = 0; i < min(32, NR_CPUS); ++i, cpumask >>= 1)\r\nmask |= (cpumask & 1) << get_hard_smp_processor_id(i);\r\nreturn mask;\r\n}\r\nstatic inline struct mpic * mpic_from_ipi(struct irq_data *d)\r\n{\r\nreturn irq_data_get_irq_chip_data(d);\r\n}\r\nstatic inline struct mpic * mpic_from_irq(unsigned int irq)\r\n{\r\nreturn irq_get_chip_data(irq);\r\n}\r\nstatic inline struct mpic * mpic_from_irq_data(struct irq_data *d)\r\n{\r\nreturn irq_data_get_irq_chip_data(d);\r\n}\r\nstatic inline void mpic_eoi(struct mpic *mpic)\r\n{\r\nmpic_cpu_write(MPIC_INFO(CPU_EOI), 0);\r\n(void)mpic_cpu_read(MPIC_INFO(CPU_WHOAMI));\r\n}\r\nvoid mpic_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int loops = 100000;\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nDBG("%p: %s: enable_irq: %d (src %d)\n", mpic, mpic->name, d->irq, src);\r\nmpic_irq_write(src, MPIC_INFO(IRQ_VECTOR_PRI),\r\nmpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) &\r\n~MPIC_VECPRI_MASK);\r\ndo {\r\nif (!loops--) {\r\nprintk(KERN_ERR "%s: timeout on hwirq %u\n",\r\n__func__, src);\r\nbreak;\r\n}\r\n} while(mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) & MPIC_VECPRI_MASK);\r\n}\r\nvoid mpic_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int loops = 100000;\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nDBG("%s: disable_irq: %d (src %d)\n", mpic->name, d->irq, src);\r\nmpic_irq_write(src, MPIC_INFO(IRQ_VECTOR_PRI),\r\nmpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) |\r\nMPIC_VECPRI_MASK);\r\ndo {\r\nif (!loops--) {\r\nprintk(KERN_ERR "%s: timeout on hwirq %u\n",\r\n__func__, src);\r\nbreak;\r\n}\r\n} while(!(mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI)) & MPIC_VECPRI_MASK));\r\n}\r\nvoid mpic_end_irq(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\n#ifdef DEBUG_IRQ\r\nDBG("%s: end_irq: %d\n", mpic->name, d->irq);\r\n#endif\r\nmpic_eoi(mpic);\r\n}\r\nstatic void mpic_unmask_ht_irq(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nmpic_unmask_irq(d);\r\nif (irqd_is_level_type(d))\r\nmpic_ht_end_irq(mpic, src);\r\n}\r\nstatic unsigned int mpic_startup_ht_irq(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nmpic_unmask_irq(d);\r\nmpic_startup_ht_interrupt(mpic, src, irqd_is_level_type(d));\r\nreturn 0;\r\n}\r\nstatic void mpic_shutdown_ht_irq(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nmpic_shutdown_ht_interrupt(mpic, src);\r\nmpic_mask_irq(d);\r\n}\r\nstatic void mpic_end_ht_irq(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\n#ifdef DEBUG_IRQ\r\nDBG("%s: end_irq: %d\n", mpic->name, d->irq);\r\n#endif\r\nif (irqd_is_level_type(d))\r\nmpic_ht_end_irq(mpic, src);\r\nmpic_eoi(mpic);\r\n}\r\nstatic void mpic_unmask_ipi(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_ipi(d);\r\nunsigned int src = virq_to_hw(d->irq) - mpic->ipi_vecs[0];\r\nDBG("%s: enable_ipi: %d (ipi %d)\n", mpic->name, d->irq, src);\r\nmpic_ipi_write(src, mpic_ipi_read(src) & ~MPIC_VECPRI_MASK);\r\n}\r\nstatic void mpic_mask_ipi(struct irq_data *d)\r\n{\r\n}\r\nstatic void mpic_end_ipi(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_ipi(d);\r\nmpic_eoi(mpic);\r\n}\r\nstatic void mpic_unmask_tm(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = virq_to_hw(d->irq) - mpic->timer_vecs[0];\r\nDBG("%s: enable_tm: %d (tm %d)\n", mpic->name, d->irq, src);\r\nmpic_tm_write(src, mpic_tm_read(src) & ~MPIC_VECPRI_MASK);\r\nmpic_tm_read(src);\r\n}\r\nstatic void mpic_mask_tm(struct irq_data *d)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = virq_to_hw(d->irq) - mpic->timer_vecs[0];\r\nmpic_tm_write(src, mpic_tm_read(src) | MPIC_VECPRI_MASK);\r\nmpic_tm_read(src);\r\n}\r\nint mpic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,\r\nbool force)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nif (mpic->flags & MPIC_SINGLE_DEST_CPU) {\r\nint cpuid = irq_choose_cpu(cpumask);\r\nmpic_irq_write(src, MPIC_INFO(IRQ_DESTINATION), 1 << cpuid);\r\n} else {\r\nu32 mask = cpumask_bits(cpumask)[0];\r\nmask &= cpumask_bits(cpu_online_mask)[0];\r\nmpic_irq_write(src, MPIC_INFO(IRQ_DESTINATION),\r\nmpic_physmask(mask));\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int mpic_type_to_vecpri(struct mpic *mpic, unsigned int type)\r\n{\r\nswitch(type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nreturn MPIC_INFO(VECPRI_SENSE_EDGE) |\r\nMPIC_INFO(VECPRI_POLARITY_POSITIVE);\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nreturn MPIC_INFO(VECPRI_SENSE_EDGE) |\r\nMPIC_INFO(VECPRI_POLARITY_NEGATIVE);\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nreturn MPIC_INFO(VECPRI_SENSE_LEVEL) |\r\nMPIC_INFO(VECPRI_POLARITY_POSITIVE);\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ndefault:\r\nreturn MPIC_INFO(VECPRI_SENSE_LEVEL) |\r\nMPIC_INFO(VECPRI_POLARITY_NEGATIVE);\r\n}\r\n}\r\nint mpic_set_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct mpic *mpic = mpic_from_irq_data(d);\r\nunsigned int src = irqd_to_hwirq(d);\r\nunsigned int vecpri, vold, vnew;\r\nDBG("mpic: set_irq_type(mpic:@%p,virq:%d,src:0x%x,type:0x%x)\n",\r\nmpic, d->irq, src, flow_type);\r\nif (src >= mpic->num_sources)\r\nreturn -EINVAL;\r\nvold = mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI));\r\nif (flow_type == IRQ_TYPE_NONE)\r\nflow_type = IRQ_TYPE_DEFAULT;\r\nif (flow_type == IRQ_TYPE_DEFAULT) {\r\nswitch(vold & (MPIC_INFO(VECPRI_POLARITY_MASK) |\r\nMPIC_INFO(VECPRI_SENSE_MASK))) {\r\ncase MPIC_INFO(VECPRI_SENSE_EDGE) |\r\nMPIC_INFO(VECPRI_POLARITY_POSITIVE):\r\nflow_type = IRQ_TYPE_EDGE_RISING;\r\nbreak;\r\ncase MPIC_INFO(VECPRI_SENSE_EDGE) |\r\nMPIC_INFO(VECPRI_POLARITY_NEGATIVE):\r\nflow_type = IRQ_TYPE_EDGE_FALLING;\r\nbreak;\r\ncase MPIC_INFO(VECPRI_SENSE_LEVEL) |\r\nMPIC_INFO(VECPRI_POLARITY_POSITIVE):\r\nflow_type = IRQ_TYPE_LEVEL_HIGH;\r\nbreak;\r\ncase MPIC_INFO(VECPRI_SENSE_LEVEL) |\r\nMPIC_INFO(VECPRI_POLARITY_NEGATIVE):\r\nflow_type = IRQ_TYPE_LEVEL_LOW;\r\nbreak;\r\n}\r\n}\r\nirqd_set_trigger_type(d, flow_type);\r\nif (mpic_is_ht_interrupt(mpic, src))\r\nvecpri = MPIC_VECPRI_POLARITY_POSITIVE |\r\nMPIC_VECPRI_SENSE_EDGE;\r\nelse\r\nvecpri = mpic_type_to_vecpri(mpic, flow_type);\r\nvnew = vold & ~(MPIC_INFO(VECPRI_POLARITY_MASK) |\r\nMPIC_INFO(VECPRI_SENSE_MASK));\r\nvnew |= vecpri;\r\nif (vold != vnew)\r\nmpic_irq_write(src, MPIC_INFO(IRQ_VECTOR_PRI), vnew);\r\nreturn IRQ_SET_MASK_OK_NOCOPY;\r\n}\r\nvoid mpic_set_vector(unsigned int virq, unsigned int vector)\r\n{\r\nstruct mpic *mpic = mpic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nunsigned int vecpri;\r\nDBG("mpic: set_vector(mpic:@%p,virq:%d,src:%d,vector:0x%x)\n",\r\nmpic, virq, src, vector);\r\nif (src >= mpic->num_sources)\r\nreturn;\r\nvecpri = mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI));\r\nvecpri = vecpri & ~MPIC_INFO(VECPRI_VECTOR_MASK);\r\nvecpri |= vector;\r\nmpic_irq_write(src, MPIC_INFO(IRQ_VECTOR_PRI), vecpri);\r\n}\r\nvoid mpic_set_destination(unsigned int virq, unsigned int cpuid)\r\n{\r\nstruct mpic *mpic = mpic_from_irq(virq);\r\nunsigned int src = virq_to_hw(virq);\r\nDBG("mpic: set_destination(mpic:@%p,virq:%d,src:%d,cpuid:0x%x)\n",\r\nmpic, virq, src, cpuid);\r\nif (src >= mpic->num_sources)\r\nreturn;\r\nmpic_irq_write(src, MPIC_INFO(IRQ_DESTINATION), 1 << cpuid);\r\n}\r\nstatic int mpic_host_match(struct irq_domain *h, struct device_node *node)\r\n{\r\nreturn h->of_node == NULL || h->of_node == node;\r\n}\r\nstatic int mpic_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct mpic *mpic = h->host_data;\r\nstruct irq_chip *chip;\r\nDBG("mpic: map virq %d, hwirq 0x%lx\n", virq, hw);\r\nif (hw == mpic->spurious_vec)\r\nreturn -EINVAL;\r\nif (mpic->protected && test_bit(hw, mpic->protected))\r\nreturn -EINVAL;\r\n#ifdef CONFIG_SMP\r\nelse if (hw >= mpic->ipi_vecs[0]) {\r\nWARN_ON(mpic->flags & MPIC_SECONDARY);\r\nDBG("mpic: mapping as IPI\n");\r\nirq_set_chip_data(virq, mpic);\r\nirq_set_chip_and_handler(virq, &mpic->hc_ipi,\r\nhandle_percpu_irq);\r\nreturn 0;\r\n}\r\n#endif\r\nif (hw >= mpic->timer_vecs[0] && hw <= mpic->timer_vecs[7]) {\r\nWARN_ON(mpic->flags & MPIC_SECONDARY);\r\nDBG("mpic: mapping as timer\n");\r\nirq_set_chip_data(virq, mpic);\r\nirq_set_chip_and_handler(virq, &mpic->hc_tm,\r\nhandle_fasteoi_irq);\r\nreturn 0;\r\n}\r\nif (hw >= mpic->num_sources)\r\nreturn -EINVAL;\r\nmpic_msi_reserve_hwirq(mpic, hw);\r\nchip = &mpic->hc_irq;\r\n#ifdef CONFIG_MPIC_U3_HT_IRQS\r\nif (mpic_is_ht_interrupt(mpic, hw))\r\nchip = &mpic->hc_ht_irq;\r\n#endif\r\nDBG("mpic: mapping to irq chip @%p\n", chip);\r\nirq_set_chip_data(virq, mpic);\r\nirq_set_chip_and_handler(virq, chip, handle_fasteoi_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_DEFAULT);\r\nif (!mpic_is_ipi(mpic, hw) && (mpic->flags & MPIC_NO_RESET)) {\r\nmpic_set_vector(virq, hw);\r\nmpic_set_destination(virq, mpic_processor_id(mpic));\r\nmpic_irq_set_priority(virq, 8);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mpic_host_xlate(struct irq_domain *h, struct device_node *ct,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_flags)\r\n{\r\nstruct mpic *mpic = h->host_data;\r\nstatic unsigned char map_mpic_senses[4] = {\r\nIRQ_TYPE_EDGE_RISING,\r\nIRQ_TYPE_LEVEL_LOW,\r\nIRQ_TYPE_LEVEL_HIGH,\r\nIRQ_TYPE_EDGE_FALLING,\r\n};\r\n*out_hwirq = intspec[0];\r\nif (intsize >= 4 && (mpic->flags & MPIC_FSL)) {\r\nswitch (intspec[2]) {\r\ncase 0:\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nif (intspec[0] >= ARRAY_SIZE(mpic->ipi_vecs))\r\nreturn -EINVAL;\r\n*out_hwirq = mpic->ipi_vecs[intspec[0]];\r\nbreak;\r\ncase 3:\r\nif (intspec[0] >= ARRAY_SIZE(mpic->timer_vecs))\r\nreturn -EINVAL;\r\n*out_hwirq = mpic->timer_vecs[intspec[0]];\r\nbreak;\r\ndefault:\r\npr_debug("%s: unknown irq type %u\n",\r\n__func__, intspec[2]);\r\nreturn -EINVAL;\r\n}\r\n*out_flags = map_mpic_senses[intspec[1] & 3];\r\n} else if (intsize > 1) {\r\nu32 mask = 0x3;\r\nif (machine_is(powermac))\r\nmask = 0x1;\r\n*out_flags = map_mpic_senses[intspec[1] & mask];\r\n} else\r\n*out_flags = IRQ_TYPE_NONE;\r\nDBG("mpic: xlate (%d cells: 0x%08x 0x%08x) to line 0x%lx sense 0x%x\n",\r\nintsize, intspec[0], intspec[1], *out_hwirq, *out_flags);\r\nreturn 0;\r\n}\r\nstatic void mpic_cascade(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct mpic *mpic = irq_desc_get_handler_data(desc);\r\nunsigned int virq;\r\nBUG_ON(!(mpic->flags & MPIC_SECONDARY));\r\nvirq = mpic_get_one_irq(mpic);\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\nchip->irq_eoi(&desc->irq_data);\r\n}\r\nstruct mpic * __init mpic_alloc(struct device_node *node,\r\nphys_addr_t phys_addr,\r\nunsigned int flags,\r\nunsigned int isu_size,\r\nunsigned int irq_count,\r\nconst char *name)\r\n{\r\nint i, psize, intvec_top;\r\nstruct mpic *mpic;\r\nu32 greg_feature;\r\nconst char *vers;\r\nconst u32 *psrc;\r\nu32 last_irq;\r\nstatic const struct of_device_id __initconst mpic_device_id[] = {\r\n{ .type = "open-pic", },\r\n{ .compatible = "open-pic", },\r\n{},\r\n};\r\nif (node) {\r\nnode = of_node_get(node);\r\n} else {\r\nnode = of_find_matching_node(NULL, mpic_device_id);\r\nif (!node)\r\nreturn NULL;\r\n}\r\nif (!phys_addr) {\r\nif (of_get_property(node, "dcr-reg", NULL)) {\r\nflags |= MPIC_USES_DCR;\r\n} else {\r\nstruct resource r;\r\nif (of_address_to_resource(node, 0, &r))\r\ngoto err_of_node_put;\r\nphys_addr = r.start;\r\n}\r\n}\r\nif (of_get_property(node, "big-endian", NULL))\r\nflags |= MPIC_BIG_ENDIAN;\r\nif (of_get_property(node, "pic-no-reset", NULL))\r\nflags |= MPIC_NO_RESET;\r\nif (of_get_property(node, "single-cpu-affinity", NULL))\r\nflags |= MPIC_SINGLE_DEST_CPU;\r\nif (of_device_is_compatible(node, "fsl,mpic"))\r\nflags |= MPIC_FSL;\r\nmpic = kzalloc(sizeof(struct mpic), GFP_KERNEL);\r\nif (mpic == NULL)\r\ngoto err_of_node_put;\r\nmpic->name = name;\r\nmpic->node = node;\r\nmpic->paddr = phys_addr;\r\nmpic->flags = flags;\r\nmpic->hc_irq = mpic_irq_chip;\r\nmpic->hc_irq.name = name;\r\nif (!(mpic->flags & MPIC_SECONDARY))\r\nmpic->hc_irq.irq_set_affinity = mpic_set_affinity;\r\n#ifdef CONFIG_MPIC_U3_HT_IRQS\r\nmpic->hc_ht_irq = mpic_irq_ht_chip;\r\nmpic->hc_ht_irq.name = name;\r\nif (!(mpic->flags & MPIC_SECONDARY))\r\nmpic->hc_ht_irq.irq_set_affinity = mpic_set_affinity;\r\n#endif\r\n#ifdef CONFIG_SMP\r\nmpic->hc_ipi = mpic_ipi_chip;\r\nmpic->hc_ipi.name = name;\r\n#endif\r\nmpic->hc_tm = mpic_tm_chip;\r\nmpic->hc_tm.name = name;\r\nmpic->num_sources = 0;\r\nif (mpic->flags & MPIC_LARGE_VECTORS)\r\nintvec_top = 2047;\r\nelse\r\nintvec_top = 255;\r\nmpic->timer_vecs[0] = intvec_top - 12;\r\nmpic->timer_vecs[1] = intvec_top - 11;\r\nmpic->timer_vecs[2] = intvec_top - 10;\r\nmpic->timer_vecs[3] = intvec_top - 9;\r\nmpic->timer_vecs[4] = intvec_top - 8;\r\nmpic->timer_vecs[5] = intvec_top - 7;\r\nmpic->timer_vecs[6] = intvec_top - 6;\r\nmpic->timer_vecs[7] = intvec_top - 5;\r\nmpic->ipi_vecs[0] = intvec_top - 4;\r\nmpic->ipi_vecs[1] = intvec_top - 3;\r\nmpic->ipi_vecs[2] = intvec_top - 2;\r\nmpic->ipi_vecs[3] = intvec_top - 1;\r\nmpic->spurious_vec = intvec_top;\r\npsrc = of_get_property(mpic->node, "protected-sources", &psize);\r\nif (psrc) {\r\nunsigned int mapsize = BITS_TO_LONGS(intvec_top + 1);\r\nmpic->protected = kzalloc(mapsize*sizeof(long), GFP_KERNEL);\r\nBUG_ON(mpic->protected == NULL);\r\nfor (i = 0; i < psize/sizeof(u32); i++) {\r\nif (psrc[i] > intvec_top)\r\ncontinue;\r\n__set_bit(psrc[i], mpic->protected);\r\n}\r\n}\r\n#ifdef CONFIG_MPIC_WEIRD\r\nmpic->hw_set = mpic_infos[MPIC_GET_REGSET(mpic->flags)];\r\n#endif\r\nif (mpic->flags & MPIC_BIG_ENDIAN)\r\nmpic->reg_type = mpic_access_mmio_be;\r\nelse\r\nmpic->reg_type = mpic_access_mmio_le;\r\n#ifdef CONFIG_PPC_DCR\r\nif (mpic->flags & MPIC_USES_DCR)\r\nmpic->reg_type = mpic_access_dcr;\r\n#else\r\nBUG_ON(mpic->flags & MPIC_USES_DCR);\r\n#endif\r\nmpic_map(mpic, mpic->paddr, &mpic->gregs, MPIC_INFO(GREG_BASE), 0x1000);\r\nmpic_map(mpic, mpic->paddr, &mpic->tmregs, MPIC_INFO(TIMER_BASE), 0x1000);\r\nif (!(mpic->flags & MPIC_NO_RESET)) {\r\nprintk(KERN_DEBUG "mpic: Resetting\n");\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))\r\n| MPIC_GREG_GCONF_RESET);\r\nwhile( mpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))\r\n& MPIC_GREG_GCONF_RESET)\r\nmb();\r\n}\r\nif (mpic->flags & MPIC_ENABLE_COREINT)\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))\r\n| MPIC_GREG_GCONF_COREINT);\r\nif (mpic->flags & MPIC_ENABLE_MCK)\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))\r\n| MPIC_GREG_GCONF_MCK);\r\nBUG_ON(num_possible_cpus() > MPIC_MAX_CPUS);\r\nfor_each_possible_cpu(i) {\r\nunsigned int cpu = get_hard_smp_processor_id(i);\r\nmpic_map(mpic, mpic->paddr, &mpic->cpuregs[cpu],\r\nMPIC_INFO(CPU_BASE) + cpu * MPIC_INFO(CPU_STRIDE),\r\n0x1000);\r\n}\r\ngreg_feature = mpic_read(mpic->gregs, MPIC_INFO(GREG_FEATURE_0));\r\nlast_irq = (greg_feature & MPIC_GREG_FEATURE_LAST_SRC_MASK)\r\n>> MPIC_GREG_FEATURE_LAST_SRC_SHIFT;\r\nif (isu_size)\r\nlast_irq = isu_size * MPIC_MAX_ISU - 1;\r\nof_property_read_u32(mpic->node, "last-interrupt-source", &last_irq);\r\nif (irq_count)\r\nlast_irq = irq_count - 1;\r\nif (!isu_size) {\r\nisu_size = last_irq + 1;\r\nmpic->num_sources = isu_size;\r\nmpic_map(mpic, mpic->paddr, &mpic->isus[0],\r\nMPIC_INFO(IRQ_BASE),\r\nMPIC_INFO(IRQ_STRIDE) * isu_size);\r\n}\r\nmpic->isu_size = isu_size;\r\nmpic->isu_shift = 1 + __ilog2(mpic->isu_size - 1);\r\nmpic->isu_mask = (1 << mpic->isu_shift) - 1;\r\nmpic->irqhost = irq_domain_add_linear(mpic->node,\r\nlast_irq + 1,\r\n&mpic_host_ops, mpic);\r\nif (mpic->irqhost == NULL)\r\nreturn NULL;\r\nswitch (greg_feature & MPIC_GREG_FEATURE_VERSION_MASK) {\r\ncase 1:\r\nvers = "1.0";\r\nbreak;\r\ncase 2:\r\nvers = "1.2";\r\nbreak;\r\ncase 3:\r\nvers = "1.3";\r\nbreak;\r\ndefault:\r\nvers = "<unknown>";\r\nbreak;\r\n}\r\nprintk(KERN_INFO "mpic: Setting up MPIC \"%s\" version %s at %llx,"\r\n" max %d CPUs\n",\r\nname, vers, (unsigned long long)mpic->paddr, num_possible_cpus());\r\nprintk(KERN_INFO "mpic: ISU size: %d, shift: %d, mask: %x\n",\r\nmpic->isu_size, mpic->isu_shift, mpic->isu_mask);\r\nmpic->next = mpics;\r\nmpics = mpic;\r\nif (!(mpic->flags & MPIC_SECONDARY)) {\r\nmpic_primary = mpic;\r\nirq_set_default_host(mpic->irqhost);\r\n}\r\nreturn mpic;\r\nerr_of_node_put:\r\nof_node_put(node);\r\nreturn NULL;\r\n}\r\nvoid __init mpic_assign_isu(struct mpic *mpic, unsigned int isu_num,\r\nphys_addr_t paddr)\r\n{\r\nunsigned int isu_first = isu_num * mpic->isu_size;\r\nBUG_ON(isu_num >= MPIC_MAX_ISU);\r\nmpic_map(mpic,\r\npaddr, &mpic->isus[isu_num], 0,\r\nMPIC_INFO(IRQ_STRIDE) * mpic->isu_size);\r\nif ((isu_first + mpic->isu_size) > mpic->num_sources)\r\nmpic->num_sources = isu_first + mpic->isu_size;\r\n}\r\nvoid __init mpic_init(struct mpic *mpic)\r\n{\r\nint i, cpu;\r\nBUG_ON(mpic->num_sources == 0);\r\nprintk(KERN_INFO "mpic: Initializing for %d sources\n", mpic->num_sources);\r\nmpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), 0xf);\r\nfor (i = 0; i < 4; i++) {\r\nmpic_write(mpic->tmregs,\r\ni * MPIC_INFO(TIMER_STRIDE) +\r\nMPIC_INFO(TIMER_DESTINATION),\r\n1 << hard_smp_processor_id());\r\nmpic_write(mpic->tmregs,\r\ni * MPIC_INFO(TIMER_STRIDE) +\r\nMPIC_INFO(TIMER_VECTOR_PRI),\r\nMPIC_VECPRI_MASK |\r\n(9 << MPIC_VECPRI_PRIORITY_SHIFT) |\r\n(mpic->timer_vecs[0] + i));\r\n}\r\nmpic_test_broken_ipi(mpic);\r\nfor (i = 0; i < 4; i++) {\r\nmpic_ipi_write(i,\r\nMPIC_VECPRI_MASK |\r\n(10 << MPIC_VECPRI_PRIORITY_SHIFT) |\r\n(mpic->ipi_vecs[0] + i));\r\n}\r\nDBG("MPIC flags: %x\n", mpic->flags);\r\nif ((mpic->flags & MPIC_U3_HT_IRQS) && !(mpic->flags & MPIC_SECONDARY)) {\r\nmpic_scan_ht_pics(mpic);\r\nmpic_u3msi_init(mpic);\r\n}\r\nmpic_pasemi_msi_init(mpic);\r\ncpu = mpic_processor_id(mpic);\r\nif (!(mpic->flags & MPIC_NO_RESET)) {\r\nfor (i = 0; i < mpic->num_sources; i++) {\r\nu32 vecpri = MPIC_VECPRI_MASK | i |\r\n(8 << MPIC_VECPRI_PRIORITY_SHIFT);\r\nif (mpic->protected && test_bit(i, mpic->protected))\r\ncontinue;\r\nmpic_irq_write(i, MPIC_INFO(IRQ_VECTOR_PRI), vecpri);\r\nmpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION), 1 << cpu);\r\n}\r\n}\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_SPURIOUS), mpic->spurious_vec);\r\nif (!(mpic->flags & MPIC_NO_PTHROU_DIS))\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))\r\n| MPIC_GREG_GCONF_8259_PTHROU_DIS);\r\nif (mpic->flags & MPIC_NO_BIAS)\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0),\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_GLOBAL_CONF_0))\r\n| MPIC_GREG_GCONF_NO_BIAS);\r\nmpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), 0);\r\n#ifdef CONFIG_PM\r\nmpic->save_data = kmalloc(mpic->num_sources * sizeof(*mpic->save_data),\r\nGFP_KERNEL);\r\nBUG_ON(mpic->save_data == NULL);\r\n#endif\r\nif (mpic->flags & MPIC_SECONDARY) {\r\nint virq = irq_of_parse_and_map(mpic->node, 0);\r\nif (virq != NO_IRQ) {\r\nprintk(KERN_INFO "%s: hooking up to IRQ %d\n",\r\nmpic->node->full_name, virq);\r\nirq_set_handler_data(virq, mpic);\r\nirq_set_chained_handler(virq, &mpic_cascade);\r\n}\r\n}\r\n}\r\nvoid __init mpic_set_clk_ratio(struct mpic *mpic, u32 clock_ratio)\r\n{\r\nu32 v;\r\nv = mpic_read(mpic->gregs, MPIC_GREG_GLOBAL_CONF_1);\r\nv &= ~MPIC_GREG_GLOBAL_CONF_1_CLK_RATIO_MASK;\r\nv |= MPIC_GREG_GLOBAL_CONF_1_CLK_RATIO(clock_ratio);\r\nmpic_write(mpic->gregs, MPIC_GREG_GLOBAL_CONF_1, v);\r\n}\r\nvoid __init mpic_set_serial_int(struct mpic *mpic, int enable)\r\n{\r\nunsigned long flags;\r\nu32 v;\r\nraw_spin_lock_irqsave(&mpic_lock, flags);\r\nv = mpic_read(mpic->gregs, MPIC_GREG_GLOBAL_CONF_1);\r\nif (enable)\r\nv |= MPIC_GREG_GLOBAL_CONF_1_SIE;\r\nelse\r\nv &= ~MPIC_GREG_GLOBAL_CONF_1_SIE;\r\nmpic_write(mpic->gregs, MPIC_GREG_GLOBAL_CONF_1, v);\r\nraw_spin_unlock_irqrestore(&mpic_lock, flags);\r\n}\r\nvoid mpic_irq_set_priority(unsigned int irq, unsigned int pri)\r\n{\r\nstruct mpic *mpic = mpic_find(irq);\r\nunsigned int src = virq_to_hw(irq);\r\nunsigned long flags;\r\nu32 reg;\r\nif (!mpic)\r\nreturn;\r\nraw_spin_lock_irqsave(&mpic_lock, flags);\r\nif (mpic_is_ipi(mpic, src)) {\r\nreg = mpic_ipi_read(src - mpic->ipi_vecs[0]) &\r\n~MPIC_VECPRI_PRIORITY_MASK;\r\nmpic_ipi_write(src - mpic->ipi_vecs[0],\r\nreg | (pri << MPIC_VECPRI_PRIORITY_SHIFT));\r\n} else if (mpic_is_tm(mpic, src)) {\r\nreg = mpic_tm_read(src - mpic->timer_vecs[0]) &\r\n~MPIC_VECPRI_PRIORITY_MASK;\r\nmpic_tm_write(src - mpic->timer_vecs[0],\r\nreg | (pri << MPIC_VECPRI_PRIORITY_SHIFT));\r\n} else {\r\nreg = mpic_irq_read(src, MPIC_INFO(IRQ_VECTOR_PRI))\r\n& ~MPIC_VECPRI_PRIORITY_MASK;\r\nmpic_irq_write(src, MPIC_INFO(IRQ_VECTOR_PRI),\r\nreg | (pri << MPIC_VECPRI_PRIORITY_SHIFT));\r\n}\r\nraw_spin_unlock_irqrestore(&mpic_lock, flags);\r\n}\r\nvoid mpic_setup_this_cpu(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nstruct mpic *mpic = mpic_primary;\r\nunsigned long flags;\r\nu32 msk = 1 << hard_smp_processor_id();\r\nunsigned int i;\r\nBUG_ON(mpic == NULL);\r\nDBG("%s: setup_this_cpu(%d)\n", mpic->name, hard_smp_processor_id());\r\nraw_spin_lock_irqsave(&mpic_lock, flags);\r\nif (distribute_irqs) {\r\nfor (i = 0; i < mpic->num_sources ; i++)\r\nmpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION),\r\nmpic_irq_read(i, MPIC_INFO(IRQ_DESTINATION)) | msk);\r\n}\r\nmpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), 0);\r\nraw_spin_unlock_irqrestore(&mpic_lock, flags);\r\n#endif\r\n}\r\nint mpic_cpu_get_priority(void)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nreturn mpic_cpu_read(MPIC_INFO(CPU_CURRENT_TASK_PRI));\r\n}\r\nvoid mpic_cpu_set_priority(int prio)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nprio &= MPIC_CPU_TASKPRI_MASK;\r\nmpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), prio);\r\n}\r\nvoid mpic_teardown_this_cpu(int secondary)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nunsigned long flags;\r\nu32 msk = 1 << hard_smp_processor_id();\r\nunsigned int i;\r\nBUG_ON(mpic == NULL);\r\nDBG("%s: teardown_this_cpu(%d)\n", mpic->name, hard_smp_processor_id());\r\nraw_spin_lock_irqsave(&mpic_lock, flags);\r\nfor (i = 0; i < mpic->num_sources ; i++)\r\nmpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION),\r\nmpic_irq_read(i, MPIC_INFO(IRQ_DESTINATION)) & ~msk);\r\nmpic_cpu_write(MPIC_INFO(CPU_CURRENT_TASK_PRI), 0xf);\r\nmpic_eoi(mpic);\r\nraw_spin_unlock_irqrestore(&mpic_lock, flags);\r\n}\r\nstatic unsigned int _mpic_get_one_irq(struct mpic *mpic, int reg)\r\n{\r\nu32 src;\r\nsrc = mpic_cpu_read(reg) & MPIC_INFO(VECPRI_VECTOR_MASK);\r\n#ifdef DEBUG_LOW\r\nDBG("%s: get_one_irq(reg 0x%x): %d\n", mpic->name, reg, src);\r\n#endif\r\nif (unlikely(src == mpic->spurious_vec)) {\r\nif (mpic->flags & MPIC_SPV_EOI)\r\nmpic_eoi(mpic);\r\nreturn NO_IRQ;\r\n}\r\nif (unlikely(mpic->protected && test_bit(src, mpic->protected))) {\r\nprintk_ratelimited(KERN_WARNING "%s: Got protected source %d !\n",\r\nmpic->name, (int)src);\r\nmpic_eoi(mpic);\r\nreturn NO_IRQ;\r\n}\r\nreturn irq_linear_revmap(mpic->irqhost, src);\r\n}\r\nunsigned int mpic_get_one_irq(struct mpic *mpic)\r\n{\r\nreturn _mpic_get_one_irq(mpic, MPIC_INFO(CPU_INTACK));\r\n}\r\nunsigned int mpic_get_irq(void)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nBUG_ON(mpic == NULL);\r\nreturn mpic_get_one_irq(mpic);\r\n}\r\nunsigned int mpic_get_coreint_irq(void)\r\n{\r\n#ifdef CONFIG_BOOKE\r\nstruct mpic *mpic = mpic_primary;\r\nu32 src;\r\nBUG_ON(mpic == NULL);\r\nsrc = mfspr(SPRN_EPR);\r\nif (unlikely(src == mpic->spurious_vec)) {\r\nif (mpic->flags & MPIC_SPV_EOI)\r\nmpic_eoi(mpic);\r\nreturn NO_IRQ;\r\n}\r\nif (unlikely(mpic->protected && test_bit(src, mpic->protected))) {\r\nprintk_ratelimited(KERN_WARNING "%s: Got protected source %d !\n",\r\nmpic->name, (int)src);\r\nreturn NO_IRQ;\r\n}\r\nreturn irq_linear_revmap(mpic->irqhost, src);\r\n#else\r\nreturn NO_IRQ;\r\n#endif\r\n}\r\nunsigned int mpic_get_mcirq(void)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nBUG_ON(mpic == NULL);\r\nreturn _mpic_get_one_irq(mpic, MPIC_INFO(CPU_MCACK));\r\n}\r\nvoid mpic_request_ipis(void)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nint i;\r\nBUG_ON(mpic == NULL);\r\nprintk(KERN_INFO "mpic: requesting IPIs...\n");\r\nfor (i = 0; i < 4; i++) {\r\nunsigned int vipi = irq_create_mapping(mpic->irqhost,\r\nmpic->ipi_vecs[0] + i);\r\nif (vipi == NO_IRQ) {\r\nprintk(KERN_ERR "Failed to map %s\n", smp_ipi_name[i]);\r\ncontinue;\r\n}\r\nsmp_request_message_ipi(vipi, i);\r\n}\r\n}\r\nvoid smp_mpic_message_pass(int cpu, int msg)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nu32 physmask;\r\nBUG_ON(mpic == NULL);\r\nif ((unsigned int)msg > 3) {\r\nprintk("SMP %d: smp_message_pass: unknown msg %d\n",\r\nsmp_processor_id(), msg);\r\nreturn;\r\n}\r\n#ifdef DEBUG_IPI\r\nDBG("%s: send_ipi(ipi_no: %d)\n", mpic->name, msg);\r\n#endif\r\nphysmask = 1 << get_hard_smp_processor_id(cpu);\r\nmpic_cpu_write(MPIC_INFO(CPU_IPI_DISPATCH_0) +\r\nmsg * MPIC_INFO(CPU_IPI_DISPATCH_STRIDE), physmask);\r\n}\r\nint __init smp_mpic_probe(void)\r\n{\r\nint nr_cpus;\r\nDBG("smp_mpic_probe()...\n");\r\nnr_cpus = cpumask_weight(cpu_possible_mask);\r\nDBG("nr_cpus: %d\n", nr_cpus);\r\nif (nr_cpus > 1)\r\nmpic_request_ipis();\r\nreturn nr_cpus;\r\n}\r\nvoid __devinit smp_mpic_setup_cpu(int cpu)\r\n{\r\nmpic_setup_this_cpu();\r\n}\r\nvoid mpic_reset_core(int cpu)\r\n{\r\nstruct mpic *mpic = mpic_primary;\r\nu32 pir;\r\nint cpuid = get_hard_smp_processor_id(cpu);\r\nint i;\r\npir = mpic_read(mpic->gregs, MPIC_INFO(GREG_PROCESSOR_INIT));\r\npir |= (1 << cpuid);\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_PROCESSOR_INIT), pir);\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_PROCESSOR_INIT));\r\npir &= ~(1 << cpuid);\r\nmpic_write(mpic->gregs, MPIC_INFO(GREG_PROCESSOR_INIT), pir);\r\nmpic_read(mpic->gregs, MPIC_INFO(GREG_PROCESSOR_INIT));\r\nif (mpic->flags & MPIC_FSL) {\r\nfor (i = 0; i < 15; i++) {\r\n_mpic_write(mpic->reg_type, &mpic->cpuregs[cpuid],\r\nMPIC_CPU_EOI, 0);\r\n}\r\n}\r\n}\r\nstatic void mpic_suspend_one(struct mpic *mpic)\r\n{\r\nint i;\r\nfor (i = 0; i < mpic->num_sources; i++) {\r\nmpic->save_data[i].vecprio =\r\nmpic_irq_read(i, MPIC_INFO(IRQ_VECTOR_PRI));\r\nmpic->save_data[i].dest =\r\nmpic_irq_read(i, MPIC_INFO(IRQ_DESTINATION));\r\n}\r\n}\r\nstatic int mpic_suspend(void)\r\n{\r\nstruct mpic *mpic = mpics;\r\nwhile (mpic) {\r\nmpic_suspend_one(mpic);\r\nmpic = mpic->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mpic_resume_one(struct mpic *mpic)\r\n{\r\nint i;\r\nfor (i = 0; i < mpic->num_sources; i++) {\r\nmpic_irq_write(i, MPIC_INFO(IRQ_VECTOR_PRI),\r\nmpic->save_data[i].vecprio);\r\nmpic_irq_write(i, MPIC_INFO(IRQ_DESTINATION),\r\nmpic->save_data[i].dest);\r\n#ifdef CONFIG_MPIC_U3_HT_IRQS\r\nif (mpic->fixups) {\r\nstruct mpic_irq_fixup *fixup = &mpic->fixups[i];\r\nif (fixup->base) {\r\nif ((mpic->save_data[i].fixup_data & 1) == 0)\r\ncontinue;\r\nwriteb(0x10 + 2 * fixup->index, fixup->base + 2);\r\nwritel(mpic->save_data[i].fixup_data & ~1,\r\nfixup->base + 4);\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nstatic void mpic_resume(void)\r\n{\r\nstruct mpic *mpic = mpics;\r\nwhile (mpic) {\r\nmpic_resume_one(mpic);\r\nmpic = mpic->next;\r\n}\r\n}\r\nstatic int mpic_init_sys(void)\r\n{\r\nregister_syscore_ops(&mpic_syscore_ops);\r\nreturn 0;\r\n}
