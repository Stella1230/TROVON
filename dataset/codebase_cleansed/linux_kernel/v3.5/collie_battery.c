static unsigned long collie_read_bat(struct collie_bat *bat)\r\n{\r\nunsigned long value = 0;\r\nif (bat->gpio_bat < 0 || bat->adc_bat < 0)\r\nreturn 0;\r\nmutex_lock(&bat_lock);\r\ngpio_set_value(bat->gpio_bat, 1);\r\nmsleep(5);\r\nucb1x00_adc_enable(ucb);\r\nvalue = ucb1x00_adc_read(ucb, bat->adc_bat, UCB_SYNC);\r\nucb1x00_adc_disable(ucb);\r\ngpio_set_value(bat->gpio_bat, 0);\r\nmutex_unlock(&bat_lock);\r\nvalue = value * 1000000 / bat->adc_bat_divider;\r\nreturn value;\r\n}\r\nstatic unsigned long collie_read_temp(struct collie_bat *bat)\r\n{\r\nunsigned long value = 0;\r\nif (bat->gpio_temp < 0 || bat->adc_temp < 0)\r\nreturn 0;\r\nmutex_lock(&bat_lock);\r\ngpio_set_value(bat->gpio_temp, 1);\r\nmsleep(5);\r\nucb1x00_adc_enable(ucb);\r\nvalue = ucb1x00_adc_read(ucb, bat->adc_temp, UCB_SYNC);\r\nucb1x00_adc_disable(ucb);\r\ngpio_set_value(bat->gpio_temp, 0);\r\nmutex_unlock(&bat_lock);\r\nvalue = value * 10000 / bat->adc_temp_divider;\r\nreturn value;\r\n}\r\nstatic int collie_bat_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct collie_bat *bat = container_of(psy, struct collie_bat, psy);\r\nif (bat->is_present && !bat->is_present(bat)\r\n&& psp != POWER_SUPPLY_PROP_PRESENT) {\r\nreturn -ENODEV;\r\n}\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = bat->status;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = bat->technology;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = collie_read_bat(bat);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nif (bat->full_chrg == -1)\r\nval->intval = bat->bat_max;\r\nelse\r\nval->intval = bat->full_chrg;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = bat->bat_max;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = bat->bat_min;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval = collie_read_temp(bat);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = bat->is_present ? bat->is_present(bat) : 1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void collie_bat_external_power_changed(struct power_supply *psy)\r\n{\r\nschedule_work(&bat_work);\r\n}\r\nstatic irqreturn_t collie_bat_gpio_isr(int irq, void *data)\r\n{\r\npr_info("collie_bat_gpio irq\n");\r\nschedule_work(&bat_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void collie_bat_update(struct collie_bat *bat)\r\n{\r\nint old;\r\nstruct power_supply *psy = &bat->psy;\r\nmutex_lock(&bat->work_lock);\r\nold = bat->status;\r\nif (bat->is_present && !bat->is_present(bat)) {\r\nprintk(KERN_NOTICE "%s not present\n", psy->name);\r\nbat->status = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbat->full_chrg = -1;\r\n} else if (power_supply_am_i_supplied(psy)) {\r\nif (bat->status == POWER_SUPPLY_STATUS_DISCHARGING) {\r\ngpio_set_value(bat->gpio_charge_on, 1);\r\nmdelay(15);\r\n}\r\nif (gpio_get_value(bat->gpio_full)) {\r\nif (old == POWER_SUPPLY_STATUS_CHARGING ||\r\nbat->full_chrg == -1)\r\nbat->full_chrg = collie_read_bat(bat);\r\ngpio_set_value(bat->gpio_charge_on, 0);\r\nbat->status = POWER_SUPPLY_STATUS_FULL;\r\n} else {\r\ngpio_set_value(bat->gpio_charge_on, 1);\r\nbat->status = POWER_SUPPLY_STATUS_CHARGING;\r\n}\r\n} else {\r\ngpio_set_value(bat->gpio_charge_on, 0);\r\nbat->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\n}\r\nif (old != bat->status)\r\npower_supply_changed(psy);\r\nmutex_unlock(&bat->work_lock);\r\n}\r\nstatic void collie_bat_work(struct work_struct *work)\r\n{\r\ncollie_bat_update(&collie_bat_main);\r\n}\r\nstatic int collie_bat_suspend(struct ucb1x00_dev *dev, pm_message_t state)\r\n{\r\nflush_work_sync(&bat_work);\r\nreturn 0;\r\n}\r\nstatic int collie_bat_resume(struct ucb1x00_dev *dev)\r\n{\r\nschedule_work(&bat_work);\r\nreturn 0;\r\n}\r\nstatic int __devinit collie_bat_probe(struct ucb1x00_dev *dev)\r\n{\r\nint ret;\r\nif (!machine_is_collie())\r\nreturn -ENODEV;\r\nucb = dev->ucb;\r\nret = gpio_request_array(collie_batt_gpios,\r\nARRAY_SIZE(collie_batt_gpios));\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&collie_bat_main.work_lock);\r\nINIT_WORK(&bat_work, collie_bat_work);\r\nret = power_supply_register(&dev->ucb->dev, &collie_bat_main.psy);\r\nif (ret)\r\ngoto err_psy_reg_main;\r\nret = power_supply_register(&dev->ucb->dev, &collie_bat_bu.psy);\r\nif (ret)\r\ngoto err_psy_reg_bu;\r\nret = request_irq(gpio_to_irq(COLLIE_GPIO_CO),\r\ncollie_bat_gpio_isr,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"main full", &collie_bat_main);\r\nif (!ret) {\r\nschedule_work(&bat_work);\r\nreturn 0;\r\n}\r\npower_supply_unregister(&collie_bat_bu.psy);\r\nerr_psy_reg_bu:\r\npower_supply_unregister(&collie_bat_main.psy);\r\nerr_psy_reg_main:\r\ncancel_work_sync(&bat_work);\r\ngpio_free_array(collie_batt_gpios, ARRAY_SIZE(collie_batt_gpios));\r\nreturn ret;\r\n}\r\nstatic void __devexit collie_bat_remove(struct ucb1x00_dev *dev)\r\n{\r\nfree_irq(gpio_to_irq(COLLIE_GPIO_CO), &collie_bat_main);\r\npower_supply_unregister(&collie_bat_bu.psy);\r\npower_supply_unregister(&collie_bat_main.psy);\r\ncancel_work_sync(&bat_work);\r\ngpio_free_array(collie_batt_gpios, ARRAY_SIZE(collie_batt_gpios));\r\n}\r\nstatic int __init collie_bat_init(void)\r\n{\r\nreturn ucb1x00_register_driver(&collie_bat_driver);\r\n}\r\nstatic void __exit collie_bat_exit(void)\r\n{\r\nucb1x00_unregister_driver(&collie_bat_driver);\r\n}
