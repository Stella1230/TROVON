static union apci_descriptor *ibm_slot_from_id(int id)\r\n{\r\nint ind = 0, size;\r\nunion apci_descriptor *ret = NULL, *des;\r\nchar *table;\r\nsize = ibm_get_table_from_acpi(&table);\r\ndes = (union apci_descriptor *)table;\r\nif (memcmp(des->header.sig, "aPCI", 4) != 0)\r\ngoto ibm_slot_done;\r\ndes = (union apci_descriptor *)&table[ind += des->header.len];\r\nwhile (ind < size && (des->generic.type != 0x82 ||\r\ndes->slot.slot_num != id)) {\r\ndes = (union apci_descriptor *)&table[ind += des->generic.len];\r\n}\r\nif (ind < size && des->slot.slot_num == id)\r\nret = des;\r\nibm_slot_done:\r\nif (ret) {\r\nret = kmalloc(sizeof(union apci_descriptor), GFP_KERNEL);\r\nmemcpy(ret, des, sizeof(union apci_descriptor));\r\n}\r\nkfree(table);\r\nreturn ret;\r\n}\r\nstatic int ibm_set_attention_status(struct hotplug_slot *slot, u8 status)\r\n{\r\nunion acpi_object args[2];\r\nstruct acpi_object_list params = { .pointer = args, .count = 2 };\r\nacpi_status stat;\r\nunsigned long long rc;\r\nunion apci_descriptor *ibm_slot;\r\nibm_slot = ibm_slot_from_id(hpslot_to_sun(slot));\r\ndbg("%s: set slot %d (%d) attention status to %d\n", __func__,\r\nibm_slot->slot.slot_num, ibm_slot->slot.slot_id,\r\n(status ? 1 : 0));\r\nargs[0].type = ACPI_TYPE_INTEGER;\r\nargs[0].integer.value = ibm_slot->slot.slot_id;\r\nargs[1].type = ACPI_TYPE_INTEGER;\r\nargs[1].integer.value = (status) ? 1 : 0;\r\nkfree(ibm_slot);\r\nstat = acpi_evaluate_integer(ibm_acpi_handle, "APLS", &params, &rc);\r\nif (ACPI_FAILURE(stat)) {\r\nerr("APLS evaluation failed: 0x%08x\n", stat);\r\nreturn -ENODEV;\r\n} else if (!rc) {\r\nerr("APLS method failed: 0x%08llx\n", rc);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ibm_get_attention_status(struct hotplug_slot *slot, u8 *status)\r\n{\r\nunion apci_descriptor *ibm_slot;\r\nibm_slot = ibm_slot_from_id(hpslot_to_sun(slot));\r\nif (ibm_slot->slot.attn & 0xa0 || ibm_slot->slot.status[1] & 0x08)\r\n*status = 1;\r\nelse\r\n*status = 0;\r\ndbg("%s: get slot %d (%d) attention status is %d\n", __func__,\r\nibm_slot->slot.slot_num, ibm_slot->slot.slot_id,\r\n*status);\r\nkfree(ibm_slot);\r\nreturn 0;\r\n}\r\nstatic void ibm_handle_events(acpi_handle handle, u32 event, void *context)\r\n{\r\nu8 detail = event & 0x0f;\r\nu8 subevent = event & 0xf0;\r\nstruct notification *note = context;\r\ndbg("%s: Received notification %02x\n", __func__, event);\r\nif (subevent == 0x80) {\r\ndbg("%s: generationg bus event\n", __func__);\r\nacpi_bus_generate_proc_event(note->device, note->event, detail);\r\nacpi_bus_generate_netlink_event(note->device->pnp.device_class,\r\ndev_name(&note->device->dev),\r\nnote->event, detail);\r\n} else\r\nnote->event = event;\r\n}\r\nstatic int ibm_get_table_from_acpi(char **bufp)\r\n{\r\nunion acpi_object *package;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_status status;\r\nchar *lbuf = NULL;\r\nint i, size = -EIO;\r\nstatus = acpi_evaluate_object(ibm_acpi_handle, "APCI", NULL, &buffer);\r\nif (ACPI_FAILURE(status)) {\r\nerr("%s: APCI evaluation failed\n", __func__);\r\nreturn -ENODEV;\r\n}\r\npackage = (union acpi_object *) buffer.pointer;\r\nif (!(package) ||\r\n(package->type != ACPI_TYPE_PACKAGE) ||\r\n!(package->package.elements)) {\r\nerr("%s: Invalid APCI object\n", __func__);\r\ngoto read_table_done;\r\n}\r\nfor(size = 0, i = 0; i < package->package.count; i++) {\r\nif (package->package.elements[i].type != ACPI_TYPE_BUFFER) {\r\nerr("%s: Invalid APCI element %d\n", __func__, i);\r\ngoto read_table_done;\r\n}\r\nsize += package->package.elements[i].buffer.length;\r\n}\r\nif (bufp == NULL)\r\ngoto read_table_done;\r\nlbuf = kzalloc(size, GFP_KERNEL);\r\ndbg("%s: element count: %i, ASL table size: %i, &table = 0x%p\n",\r\n__func__, package->package.count, size, lbuf);\r\nif (lbuf) {\r\n*bufp = lbuf;\r\n} else {\r\nsize = -ENOMEM;\r\ngoto read_table_done;\r\n}\r\nsize = 0;\r\nfor (i=0; i<package->package.count; i++) {\r\nmemcpy(&lbuf[size],\r\npackage->package.elements[i].buffer.pointer,\r\npackage->package.elements[i].buffer.length);\r\nsize += package->package.elements[i].buffer.length;\r\n}\r\nread_table_done:\r\nkfree(buffer.pointer);\r\nreturn size;\r\n}\r\nstatic ssize_t ibm_read_apci_table(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buffer, loff_t pos, size_t size)\r\n{\r\nint bytes_read = -EINVAL;\r\nchar *table = NULL;\r\ndbg("%s: pos = %d, size = %zd\n", __func__, (int)pos, size);\r\nif (pos == 0) {\r\nbytes_read = ibm_get_table_from_acpi(&table);\r\nif (bytes_read > 0 && bytes_read <= size)\r\nmemcpy(buffer, table, bytes_read);\r\nkfree(table);\r\n}\r\nreturn bytes_read;\r\n}\r\nstatic acpi_status __init ibm_find_acpi_device(acpi_handle handle,\r\nu32 lvl, void *context, void **rv)\r\n{\r\nacpi_handle *phandle = (acpi_handle *)context;\r\nacpi_status status;\r\nstruct acpi_device_info *info;\r\nint retval = 0;\r\nstatus = acpi_get_object_info(handle, &info);\r\nif (ACPI_FAILURE(status)) {\r\nerr("%s: Failed to get device information status=0x%x\n",\r\n__func__, status);\r\nreturn retval;\r\n}\r\nif (info->current_status && (info->valid & ACPI_VALID_HID) &&\r\n(!strcmp(info->hardware_id.string, IBM_HARDWARE_ID1) ||\r\n!strcmp(info->hardware_id.string, IBM_HARDWARE_ID2))) {\r\ndbg("found hardware: %s, handle: %p\n",\r\ninfo->hardware_id.string, handle);\r\n*phandle = handle;\r\nretval = FOUND_APCI;\r\n}\r\nkfree(info);\r\nreturn retval;\r\n}\r\nstatic int __init ibm_acpiphp_init(void)\r\n{\r\nint retval = 0;\r\nacpi_status status;\r\nstruct acpi_device *device;\r\nstruct kobject *sysdir = &pci_slots_kset->kobj;\r\ndbg("%s\n", __func__);\r\nif (acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX, ibm_find_acpi_device, NULL,\r\n&ibm_acpi_handle, NULL) != FOUND_APCI) {\r\nerr("%s: acpi_walk_namespace failed\n", __func__);\r\nretval = -ENODEV;\r\ngoto init_return;\r\n}\r\ndbg("%s: found IBM aPCI device\n", __func__);\r\nif (acpi_bus_get_device(ibm_acpi_handle, &device)) {\r\nerr("%s: acpi_bus_get_device failed\n", __func__);\r\nretval = -ENODEV;\r\ngoto init_return;\r\n}\r\nif (acpiphp_register_attention(&ibm_attention_info)) {\r\nretval = -ENODEV;\r\ngoto init_return;\r\n}\r\nibm_note.device = device;\r\nstatus = acpi_install_notify_handler(ibm_acpi_handle,\r\nACPI_DEVICE_NOTIFY, ibm_handle_events,\r\n&ibm_note);\r\nif (ACPI_FAILURE(status)) {\r\nerr("%s: Failed to register notification handler\n",\r\n__func__);\r\nretval = -EBUSY;\r\ngoto init_cleanup;\r\n}\r\nibm_apci_table_attr.size = ibm_get_table_from_acpi(NULL);\r\nretval = sysfs_create_bin_file(sysdir, &ibm_apci_table_attr);\r\nreturn retval;\r\ninit_cleanup:\r\nacpiphp_unregister_attention(&ibm_attention_info);\r\ninit_return:\r\nreturn retval;\r\n}\r\nstatic void __exit ibm_acpiphp_exit(void)\r\n{\r\nacpi_status status;\r\nstruct kobject *sysdir = &pci_slots_kset->kobj;\r\ndbg("%s\n", __func__);\r\nif (acpiphp_unregister_attention(&ibm_attention_info))\r\nerr("%s: attention info deregistration failed", __func__);\r\nstatus = acpi_remove_notify_handler(\r\nibm_acpi_handle,\r\nACPI_DEVICE_NOTIFY,\r\nibm_handle_events);\r\nif (ACPI_FAILURE(status))\r\nerr("%s: Notification handler removal failed\n", __func__);\r\nsysfs_remove_bin_file(sysdir, &ibm_apci_table_attr);\r\n}
