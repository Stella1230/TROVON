static const char *get_prot_descript(u8 protocol)\r\n{\r\nswitch ((enum ata_tf_protocols)protocol) {\r\ncase ATA_PROT_NODATA:\r\nreturn "ATA no data";\r\ncase ATA_PROT_PIO:\r\nreturn "ATA PIO";\r\ncase ATA_PROT_DMA:\r\nreturn "ATA DMA";\r\ncase ATA_PROT_NCQ:\r\nreturn "ATA NCQ";\r\ncase ATAPI_PROT_NODATA:\r\nreturn "ATAPI no data";\r\ncase ATAPI_PROT_PIO:\r\nreturn "ATAPI PIO";\r\ncase ATAPI_PROT_DMA:\r\nreturn "ATAPI DMA";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic const char *get_dma_dir_descript(int dma_dir)\r\n{\r\nswitch ((enum dma_data_direction)dma_dir) {\r\ncase DMA_BIDIRECTIONAL:\r\nreturn "bidirectional";\r\ncase DMA_TO_DEVICE:\r\nreturn "to device";\r\ncase DMA_FROM_DEVICE:\r\nreturn "from device";\r\ndefault:\r\nreturn "none";\r\n}\r\n}\r\nstatic void sata_dwc_tf_dump(struct ata_taskfile *tf)\r\n{\r\ndev_vdbg(host_pvt.dwc_dev, "taskfile cmd: 0x%02x protocol: %s flags:"\r\n"0x%lx device: %x\n", tf->command,\r\nget_prot_descript(tf->protocol), tf->flags, tf->device);\r\ndev_vdbg(host_pvt.dwc_dev, "feature: 0x%02x nsect: 0x%x lbal: 0x%x "\r\n"lbam: 0x%x lbah: 0x%x\n", tf->feature, tf->nsect, tf->lbal,\r\ntf->lbam, tf->lbah);\r\ndev_vdbg(host_pvt.dwc_dev, "hob_feature: 0x%02x hob_nsect: 0x%x "\r\n"hob_lbal: 0x%x hob_lbam: 0x%x hob_lbah: 0x%x\n",\r\ntf->hob_feature, tf->hob_nsect, tf->hob_lbal, tf->hob_lbam,\r\ntf->hob_lbah);\r\n}\r\nstatic int get_burst_length_encode(int datalength)\r\n{\r\nint items = datalength >> 2;\r\nif (items >= 64)\r\nreturn 5;\r\nif (items >= 32)\r\nreturn 4;\r\nif (items >= 16)\r\nreturn 3;\r\nif (items >= 8)\r\nreturn 2;\r\nif (items >= 4)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void clear_chan_interrupts(int c)\r\n{\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear.tfr.low),\r\nDMA_CHANNEL(c));\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear.block.low),\r\nDMA_CHANNEL(c));\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear.srctran.low),\r\nDMA_CHANNEL(c));\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear.dsttran.low),\r\nDMA_CHANNEL(c));\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear.error.low),\r\nDMA_CHANNEL(c));\r\n}\r\nstatic int dma_request_channel(void)\r\n{\r\nint i;\r\nfor (i = 0; i < DMA_NUM_CHANS; i++) {\r\nif (!(in_le32(&(host_pvt.sata_dma_regs->dma_chan_en.low)) &\\r\nDMA_CHANNEL(i)))\r\nreturn i;\r\n}\r\ndev_err(host_pvt.dwc_dev, "%s NO channel chan_en: 0x%08x\n", __func__,\r\nin_le32(&(host_pvt.sata_dma_regs->dma_chan_en.low)));\r\nreturn -1;\r\n}\r\nstatic irqreturn_t dma_dwc_interrupt(int irq, void *hsdev_instance)\r\n{\r\nint chan;\r\nu32 tfr_reg, err_reg;\r\nunsigned long flags;\r\nstruct sata_dwc_device *hsdev =\r\n(struct sata_dwc_device *)hsdev_instance;\r\nstruct ata_host *host = (struct ata_host *)hsdev->host;\r\nstruct ata_port *ap;\r\nstruct sata_dwc_device_port *hsdevp;\r\nu8 tag = 0;\r\nunsigned int port = 0;\r\nspin_lock_irqsave(&host->lock, flags);\r\nap = host->ports[port];\r\nhsdevp = HSDEVP_FROM_AP(ap);\r\ntag = ap->link.active_tag;\r\ntfr_reg = in_le32(&(host_pvt.sata_dma_regs->interrupt_status.tfr\\r\n.low));\r\nerr_reg = in_le32(&(host_pvt.sata_dma_regs->interrupt_status.error\\r\n.low));\r\ndev_dbg(ap->dev, "eot=0x%08x err=0x%08x pending=%d active port=%d\n",\r\ntfr_reg, err_reg, hsdevp->dma_pending[tag], port);\r\nfor (chan = 0; chan < DMA_NUM_CHANS; chan++) {\r\nif (tfr_reg & DMA_CHANNEL(chan)) {\r\nhost_pvt.dma_interrupt_count++;\r\nsata_dwc_clear_dmacr(hsdevp, tag);\r\nif (hsdevp->dma_pending[tag] ==\r\nSATA_DWC_DMA_PENDING_NONE) {\r\ndev_err(ap->dev, "DMA not pending eot=0x%08x "\r\n"err=0x%08x tag=0x%02x pending=%d\n",\r\ntfr_reg, err_reg, tag,\r\nhsdevp->dma_pending[tag]);\r\n}\r\nif ((host_pvt.dma_interrupt_count % 2) == 0)\r\nsata_dwc_dma_xfer_complete(ap, 1);\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear\\r\n.tfr.low),\r\nDMA_CHANNEL(chan));\r\n}\r\nif (err_reg & DMA_CHANNEL(chan)) {\r\ndev_err(ap->dev, "error interrupt err_reg=0x%08x\n",\r\nerr_reg);\r\nout_le32(&(host_pvt.sata_dma_regs->interrupt_clear\\r\n.error.low),\r\nDMA_CHANNEL(chan));\r\n}\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dma_request_interrupts(struct sata_dwc_device *hsdev, int irq)\r\n{\r\nint retval = 0;\r\nint chan;\r\nfor (chan = 0; chan < DMA_NUM_CHANS; chan++) {\r\nout_le32(&(host_pvt.sata_dma_regs)->interrupt_mask.error.low,\r\nDMA_ENABLE_CHAN(chan));\r\nout_le32(&(host_pvt.sata_dma_regs)->interrupt_mask.tfr.low,\r\nDMA_ENABLE_CHAN(chan));\r\n}\r\nretval = request_irq(irq, dma_dwc_interrupt, 0, "SATA DMA", hsdev);\r\nif (retval) {\r\ndev_err(host_pvt.dwc_dev, "%s: could not get IRQ %d\n",\r\n__func__, irq);\r\nreturn -ENODEV;\r\n}\r\nhsdev->irq_dma = irq;\r\nreturn 0;\r\n}\r\nstatic int map_sg_to_lli(struct scatterlist *sg, int num_elems,\r\nstruct lli *lli, dma_addr_t dma_lli,\r\nvoid __iomem *dmadr_addr, int dir)\r\n{\r\nint i, idx = 0;\r\nint fis_len = 0;\r\ndma_addr_t next_llp;\r\nint bl;\r\ndev_dbg(host_pvt.dwc_dev, "%s: sg=%p nelem=%d lli=%p dma_lli=0x%08x"\r\n" dmadr=0x%08x\n", __func__, sg, num_elems, lli, (u32)dma_lli,\r\n(u32)dmadr_addr);\r\nbl = get_burst_length_encode(AHB_DMA_BRST_DFLT);\r\nfor (i = 0; i < num_elems; i++, sg++) {\r\nu32 addr, offset;\r\nu32 sg_len, len;\r\naddr = (u32) sg_dma_address(sg);\r\nsg_len = sg_dma_len(sg);\r\ndev_dbg(host_pvt.dwc_dev, "%s: elem=%d sg_addr=0x%x sg_len"\r\n"=%d\n", __func__, i, addr, sg_len);\r\nwhile (sg_len) {\r\nif (idx >= SATA_DWC_DMAC_LLI_NUM) {\r\ndev_err(host_pvt.dwc_dev, "LLI table overrun "\r\n"(idx=%d)\n", idx);\r\nbreak;\r\n}\r\nlen = (sg_len > SATA_DWC_DMAC_CTRL_TSIZE_MAX) ?\r\nSATA_DWC_DMAC_CTRL_TSIZE_MAX : sg_len;\r\noffset = addr & 0xffff;\r\nif ((offset + sg_len) > 0x10000)\r\nlen = 0x10000 - offset;\r\nif (fis_len + len > 8192) {\r\ndev_dbg(host_pvt.dwc_dev, "SPLITTING: fis_len="\r\n"%d(0x%x) len=%d(0x%x)\n", fis_len,\r\nfis_len, len, len);\r\nlen = 8192 - fis_len;\r\nfis_len = 0;\r\n} else {\r\nfis_len += len;\r\n}\r\nif (fis_len == 8192)\r\nfis_len = 0;\r\nif (dir == DMA_FROM_DEVICE) {\r\nlli[idx].dar = cpu_to_le32(addr);\r\nlli[idx].sar = cpu_to_le32((u32)dmadr_addr);\r\nlli[idx].ctl.low = cpu_to_le32(\r\nDMA_CTL_TTFC(DMA_CTL_TTFC_P2M_DMAC) |\r\nDMA_CTL_SMS(0) |\r\nDMA_CTL_DMS(1) |\r\nDMA_CTL_SRC_MSIZE(bl) |\r\nDMA_CTL_DST_MSIZE(bl) |\r\nDMA_CTL_SINC_NOCHANGE |\r\nDMA_CTL_SRC_TRWID(2) |\r\nDMA_CTL_DST_TRWID(2) |\r\nDMA_CTL_INT_EN |\r\nDMA_CTL_LLP_SRCEN |\r\nDMA_CTL_LLP_DSTEN);\r\n} else {\r\nlli[idx].sar = cpu_to_le32(addr);\r\nlli[idx].dar = cpu_to_le32((u32)dmadr_addr);\r\nlli[idx].ctl.low = cpu_to_le32(\r\nDMA_CTL_TTFC(DMA_CTL_TTFC_M2P_PER) |\r\nDMA_CTL_SMS(1) |\r\nDMA_CTL_DMS(0) |\r\nDMA_CTL_SRC_MSIZE(bl) |\r\nDMA_CTL_DST_MSIZE(bl) |\r\nDMA_CTL_DINC_NOCHANGE |\r\nDMA_CTL_SRC_TRWID(2) |\r\nDMA_CTL_DST_TRWID(2) |\r\nDMA_CTL_INT_EN |\r\nDMA_CTL_LLP_SRCEN |\r\nDMA_CTL_LLP_DSTEN);\r\n}\r\ndev_dbg(host_pvt.dwc_dev, "%s setting ctl.high len: "\r\n"0x%08x val: 0x%08x\n", __func__,\r\nlen, DMA_CTL_BLK_TS(len / 4));\r\nlli[idx].ctl.high = cpu_to_le32(DMA_CTL_BLK_TS\\r\n(len / 4));\r\nnext_llp = (dma_lli + ((idx + 1) * sizeof(struct \\r\nlli)));\r\nnext_llp = DMA_LLP_LMS(next_llp, DMA_LLP_AHBMASTER2);\r\nlli[idx].llp = cpu_to_le32(next_llp);\r\nidx++;\r\nsg_len -= len;\r\naddr += len;\r\n}\r\n}\r\nif (idx) {\r\nlli[idx-1].llp = 0x00000000;\r\nlli[idx-1].ctl.low &= DMA_CTL_LLP_DISABLE_LE32;\r\ndma_cache_sync(NULL, lli, (sizeof(struct lli) * idx),\r\nDMA_BIDIRECTIONAL);\r\n}\r\nreturn idx;\r\n}\r\nstatic void dma_dwc_xfer_start(int dma_ch)\r\n{\r\nout_le32(&(host_pvt.sata_dma_regs->dma_chan_en.low),\r\nin_le32(&(host_pvt.sata_dma_regs->dma_chan_en.low)) |\r\nDMA_ENABLE_CHAN(dma_ch));\r\n}\r\nstatic int dma_dwc_xfer_setup(struct scatterlist *sg, int num_elems,\r\nstruct lli *lli, dma_addr_t dma_lli,\r\nvoid __iomem *addr, int dir)\r\n{\r\nint dma_ch;\r\nint num_lli;\r\ndma_ch = dma_request_channel();\r\nif (dma_ch == -1) {\r\ndev_err(host_pvt.dwc_dev, "%s: dma channel unavailable\n",\r\n__func__);\r\nreturn -EAGAIN;\r\n}\r\nnum_lli = map_sg_to_lli(sg, num_elems, lli, dma_lli, addr, dir);\r\ndev_dbg(host_pvt.dwc_dev, "%s sg: 0x%p, count: %d lli: %p dma_lli:"\r\n" 0x%0xlx addr: %p lli count: %d\n", __func__, sg, num_elems,\r\nlli, (u32)dma_lli, addr, num_lli);\r\nclear_chan_interrupts(dma_ch);\r\nout_le32(&(host_pvt.sata_dma_regs->chan_regs[dma_ch].cfg.high),\r\nDMA_CFG_PROTCTL | DMA_CFG_FCMOD_REQ);\r\nout_le32(&(host_pvt.sata_dma_regs->chan_regs[dma_ch].cfg.low), 0);\r\nout_le32(&(host_pvt.sata_dma_regs->chan_regs[dma_ch].llp.low),\r\nDMA_LLP_LMS(dma_lli, DMA_LLP_AHBMASTER2));\r\nout_le32(&(host_pvt.sata_dma_regs->chan_regs[dma_ch].ctl.low),\r\nDMA_CTL_LLP_SRCEN | DMA_CTL_LLP_DSTEN);\r\nreturn dma_ch;\r\n}\r\nstatic void dma_dwc_exit(struct sata_dwc_device *hsdev)\r\n{\r\ndev_dbg(host_pvt.dwc_dev, "%s:\n", __func__);\r\nif (host_pvt.sata_dma_regs) {\r\niounmap(host_pvt.sata_dma_regs);\r\nhost_pvt.sata_dma_regs = NULL;\r\n}\r\nif (hsdev->irq_dma) {\r\nfree_irq(hsdev->irq_dma, hsdev);\r\nhsdev->irq_dma = 0;\r\n}\r\n}\r\nstatic int dma_dwc_init(struct sata_dwc_device *hsdev, int irq)\r\n{\r\nint err;\r\nerr = dma_request_interrupts(hsdev, irq);\r\nif (err) {\r\ndev_err(host_pvt.dwc_dev, "%s: dma_request_interrupts returns"\r\n" %d\n", __func__, err);\r\ngoto error_out;\r\n}\r\nout_le32(&(host_pvt.sata_dma_regs->dma_cfg.low), DMA_EN);\r\ndev_notice(host_pvt.dwc_dev, "DMA initialized\n");\r\ndev_dbg(host_pvt.dwc_dev, "SATA DMA registers=0x%p\n", host_pvt.\\r\nsata_dma_regs);\r\nreturn 0;\r\nerror_out:\r\ndma_dwc_exit(hsdev);\r\nreturn err;\r\n}\r\nstatic int sata_dwc_scr_read(struct ata_link *link, unsigned int scr, u32 *val)\r\n{\r\nif (scr > SCR_NOTIFICATION) {\r\ndev_err(link->ap->dev, "%s: Incorrect SCR offset 0x%02x\n",\r\n__func__, scr);\r\nreturn -EINVAL;\r\n}\r\n*val = in_le32((void *)link->ap->ioaddr.scr_addr + (scr * 4));\r\ndev_dbg(link->ap->dev, "%s: id=%d reg=%d val=val=0x%08x\n",\r\n__func__, link->ap->print_id, scr, *val);\r\nreturn 0;\r\n}\r\nstatic int sata_dwc_scr_write(struct ata_link *link, unsigned int scr, u32 val)\r\n{\r\ndev_dbg(link->ap->dev, "%s: id=%d reg=%d val=val=0x%08x\n",\r\n__func__, link->ap->print_id, scr, val);\r\nif (scr > SCR_NOTIFICATION) {\r\ndev_err(link->ap->dev, "%s: Incorrect SCR offset 0x%02x\n",\r\n__func__, scr);\r\nreturn -EINVAL;\r\n}\r\nout_le32((void *)link->ap->ioaddr.scr_addr + (scr * 4), val);\r\nreturn 0;\r\n}\r\nstatic u32 core_scr_read(unsigned int scr)\r\n{\r\nreturn in_le32((void __iomem *)(host_pvt.scr_addr_sstatus) +\\r\n(scr * 4));\r\n}\r\nstatic void core_scr_write(unsigned int scr, u32 val)\r\n{\r\nout_le32((void __iomem *)(host_pvt.scr_addr_sstatus) + (scr * 4),\r\nval);\r\n}\r\nstatic void clear_serror(void)\r\n{\r\nu32 val;\r\nval = core_scr_read(SCR_ERROR);\r\ncore_scr_write(SCR_ERROR, val);\r\n}\r\nstatic void clear_interrupt_bit(struct sata_dwc_device *hsdev, u32 bit)\r\n{\r\nout_le32(&hsdev->sata_dwc_regs->intpr,\r\nin_le32(&hsdev->sata_dwc_regs->intpr));\r\n}\r\nstatic u32 qcmd_tag_to_mask(u8 tag)\r\n{\r\nreturn 0x00000001 << (tag & 0x1f);\r\n}\r\nstatic void sata_dwc_error_intr(struct ata_port *ap,\r\nstruct sata_dwc_device *hsdev, uint intpr)\r\n{\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nunsigned int err_mask = 0, action = 0;\r\nstruct ata_queued_cmd *qc;\r\nu32 serror;\r\nu8 status, tag;\r\nu32 err_reg;\r\nata_ehi_clear_desc(ehi);\r\nserror = core_scr_read(SCR_ERROR);\r\nstatus = ap->ops->sff_check_status(ap);\r\nerr_reg = in_le32(&(host_pvt.sata_dma_regs->interrupt_status.error.\\r\nlow));\r\ntag = ap->link.active_tag;\r\ndev_err(ap->dev, "%s SCR_ERROR=0x%08x intpr=0x%08x status=0x%08x "\r\n"dma_intp=%d pending=%d issued=%d dma_err_status=0x%08x\n",\r\n__func__, serror, intpr, status, host_pvt.dma_interrupt_count,\r\nhsdevp->dma_pending[tag], hsdevp->cmd_issued[tag], err_reg);\r\nclear_serror();\r\nclear_interrupt_bit(hsdev, SATA_DWC_INTPR_ERR);\r\nerr_mask |= AC_ERR_HOST_BUS;\r\naction |= ATA_EH_RESET;\r\nehi->serror |= serror;\r\nehi->action |= action;\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (qc)\r\nqc->err_mask |= err_mask;\r\nelse\r\nehi->err_mask |= err_mask;\r\nata_port_abort(ap);\r\n}\r\nstatic irqreturn_t sata_dwc_isr(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = (struct ata_host *)dev_instance;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_HOST(host);\r\nstruct ata_port *ap;\r\nstruct ata_queued_cmd *qc;\r\nunsigned long flags;\r\nu8 status, tag;\r\nint handled, num_processed, port = 0;\r\nuint intpr, sactive, sactive2, tag_mask;\r\nstruct sata_dwc_device_port *hsdevp;\r\nhost_pvt.sata_dwc_sactive_issued = 0;\r\nspin_lock_irqsave(&host->lock, flags);\r\nintpr = in_le32(&hsdev->sata_dwc_regs->intpr);\r\nap = host->ports[port];\r\nhsdevp = HSDEVP_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s intpr=0x%08x active_tag=%d\n", __func__, intpr,\r\nap->link.active_tag);\r\nif (intpr & SATA_DWC_INTPR_ERR) {\r\nsata_dwc_error_intr(ap, hsdev, intpr);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nif (intpr & SATA_DWC_INTPR_NEWFP) {\r\nclear_interrupt_bit(hsdev, SATA_DWC_INTPR_NEWFP);\r\ntag = (u8)(in_le32(&hsdev->sata_dwc_regs->fptagr));\r\ndev_dbg(ap->dev, "%s: NEWFP tag=%d\n", __func__, tag);\r\nif (hsdevp->cmd_issued[tag] != SATA_DWC_CMD_ISSUED_PEND)\r\ndev_warn(ap->dev, "CMD tag=%d not pending?\n", tag);\r\nhost_pvt.sata_dwc_sactive_issued |= qcmd_tag_to_mask(tag);\r\nqc = ata_qc_from_tag(ap, tag);\r\nqc->ap->link.active_tag = tag;\r\nsata_dwc_bmdma_start_by_tag(qc, tag);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nsactive = core_scr_read(SCR_ACTIVE);\r\ntag_mask = (host_pvt.sata_dwc_sactive_issued | sactive) ^ sactive;\r\nif (host_pvt.sata_dwc_sactive_issued == 0 && tag_mask == 0) {\r\nif (ap->link.active_tag == ATA_TAG_POISON)\r\ntag = 0;\r\nelse\r\ntag = ap->link.active_tag;\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (unlikely(!qc || (qc->tf.flags & ATA_TFLAG_POLLING))) {\r\ndev_err(ap->dev, "%s interrupt with no active qc "\r\n"qc=%p\n", __func__, qc);\r\nap->ops->sff_check_status(ap);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nstatus = ap->ops->sff_check_status(ap);\r\nqc->ap->link.active_tag = tag;\r\nhsdevp->cmd_issued[tag] = SATA_DWC_CMD_ISSUED_NOT;\r\nif (status & ATA_ERR) {\r\ndev_dbg(ap->dev, "interrupt ATA_ERR (0x%x)\n", status);\r\nsata_dwc_qc_complete(ap, qc, 1);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\ndev_dbg(ap->dev, "%s non-NCQ cmd interrupt, protocol: %s\n",\r\n__func__, get_prot_descript(qc->tf.protocol));\r\nDRVSTILLBUSY:\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nhost_pvt.dma_interrupt_count++;\r\nif (hsdevp->dma_pending[tag] == \\r\nSATA_DWC_DMA_PENDING_NONE) {\r\ndev_err(ap->dev, "%s: DMA not pending "\r\n"intpr=0x%08x status=0x%08x pending"\r\n"=%d\n", __func__, intpr, status,\r\nhsdevp->dma_pending[tag]);\r\n}\r\nif ((host_pvt.dma_interrupt_count % 2) == 0)\r\nsata_dwc_dma_xfer_complete(ap, 1);\r\n} else if (ata_is_pio(qc->tf.protocol)) {\r\nata_sff_hsm_move(ap, qc, status, 0);\r\nhandled = 1;\r\ngoto DONE;\r\n} else {\r\nif (unlikely(sata_dwc_qc_complete(ap, qc, 1)))\r\ngoto DRVSTILLBUSY;\r\n}\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\nsactive = core_scr_read(SCR_ACTIVE);\r\ntag_mask = (host_pvt.sata_dwc_sactive_issued | sactive) ^ sactive;\r\nif (sactive != 0 || (host_pvt.sata_dwc_sactive_issued) > 1 || \\r\ntag_mask > 1) {\r\ndev_dbg(ap->dev, "%s NCQ:sactive=0x%08x sactive_issued=0x%08x"\r\n"tag_mask=0x%08x\n", __func__, sactive,\r\nhost_pvt.sata_dwc_sactive_issued, tag_mask);\r\n}\r\nif ((tag_mask | (host_pvt.sata_dwc_sactive_issued)) != \\r\n(host_pvt.sata_dwc_sactive_issued)) {\r\ndev_warn(ap->dev, "Bad tag mask? sactive=0x%08x "\r\n"(host_pvt.sata_dwc_sactive_issued)=0x%08x tag_mask"\r\n"=0x%08x\n", sactive, host_pvt.sata_dwc_sactive_issued,\r\ntag_mask);\r\n}\r\nstatus = ap->ops->sff_check_status(ap);\r\ndev_dbg(ap->dev, "%s ATA status register=0x%x\n", __func__, status);\r\ntag = 0;\r\nnum_processed = 0;\r\nwhile (tag_mask) {\r\nnum_processed++;\r\nwhile (!(tag_mask & 0x00000001)) {\r\ntag++;\r\ntag_mask <<= 1;\r\n}\r\ntag_mask &= (~0x00000001);\r\nqc = ata_qc_from_tag(ap, tag);\r\nqc->ap->link.active_tag = tag;\r\nhsdevp->cmd_issued[tag] = SATA_DWC_CMD_ISSUED_NOT;\r\nif (status & ATA_ERR) {\r\ndev_dbg(ap->dev, "%s ATA_ERR (0x%x)\n", __func__,\r\nstatus);\r\nsata_dwc_qc_complete(ap, qc, 1);\r\nhandled = 1;\r\ngoto DONE;\r\n}\r\ndev_dbg(ap->dev, "%s NCQ command, protocol: %s\n", __func__,\r\nget_prot_descript(qc->tf.protocol));\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nhost_pvt.dma_interrupt_count++;\r\nif (hsdevp->dma_pending[tag] == \\r\nSATA_DWC_DMA_PENDING_NONE)\r\ndev_warn(ap->dev, "%s: DMA not pending?\n",\r\n__func__);\r\nif ((host_pvt.dma_interrupt_count % 2) == 0)\r\nsata_dwc_dma_xfer_complete(ap, 1);\r\n} else {\r\nif (unlikely(sata_dwc_qc_complete(ap, qc, 1)))\r\ngoto STILLBUSY;\r\n}\r\ncontinue;\r\nSTILLBUSY:\r\nap->stats.idle_irq++;\r\ndev_warn(ap->dev, "STILL BUSY IRQ ata%d: irq trap\n",\r\nap->print_id);\r\n}\r\nsactive2 = core_scr_read(SCR_ACTIVE);\r\nif (sactive2 != sactive) {\r\ndev_dbg(ap->dev, "More completed - sactive=0x%x sactive2"\r\n"=0x%x\n", sactive, sactive2);\r\n}\r\nhandled = 1;\r\nDONE:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void sata_dwc_clear_dmacr(struct sata_dwc_device_port *hsdevp, u8 tag)\r\n{\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_HSDEVP(hsdevp);\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_RX) {\r\nout_le32(&(hsdev->sata_dwc_regs->dmacr),\r\nSATA_DWC_DMACR_RX_CLEAR(\r\nin_le32(&(hsdev->sata_dwc_regs->dmacr))));\r\n} else if (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_TX) {\r\nout_le32(&(hsdev->sata_dwc_regs->dmacr),\r\nSATA_DWC_DMACR_TX_CLEAR(\r\nin_le32(&(hsdev->sata_dwc_regs->dmacr))));\r\n} else {\r\ndev_err(host_pvt.dwc_dev, "%s DMA protocol RX and"\r\n"TX DMA not pending tag=0x%02x pending=%d"\r\n" dmacr: 0x%08x\n", __func__, tag,\r\nhsdevp->dma_pending[tag],\r\nin_le32(&(hsdev->sata_dwc_regs->dmacr)));\r\nout_le32(&(hsdev->sata_dwc_regs->dmacr),\r\nSATA_DWC_DMACR_TXRXCH_CLEAR);\r\n}\r\n}\r\nstatic void sata_dwc_dma_xfer_complete(struct ata_port *ap, u32 check_status)\r\n{\r\nstruct ata_queued_cmd *qc;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\nu8 tag = 0;\r\ntag = ap->link.active_tag;\r\nqc = ata_qc_from_tag(ap, tag);\r\nif (!qc) {\r\ndev_err(ap->dev, "failed to get qc");\r\nreturn;\r\n}\r\n#ifdef DEBUG_NCQ\r\nif (tag > 0) {\r\ndev_info(ap->dev, "%s tag=%u cmd=0x%02x dma dir=%s proto=%s "\r\n"dmacr=0x%08x\n", __func__, qc->tag, qc->tf.command,\r\nget_dma_dir_descript(qc->dma_dir),\r\nget_prot_descript(qc->tf.protocol),\r\nin_le32(&(hsdev->sata_dwc_regs->dmacr)));\r\n}\r\n#endif\r\nif (ata_is_dma(qc->tf.protocol)) {\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_NONE) {\r\ndev_err(ap->dev, "%s DMA protocol RX and TX DMA not "\r\n"pending dmacr: 0x%08x\n", __func__,\r\nin_le32(&(hsdev->sata_dwc_regs->dmacr)));\r\n}\r\nhsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_NONE;\r\nsata_dwc_qc_complete(ap, qc, check_status);\r\nap->link.active_tag = ATA_TAG_POISON;\r\n} else {\r\nsata_dwc_qc_complete(ap, qc, check_status);\r\n}\r\n}\r\nstatic int sata_dwc_qc_complete(struct ata_port *ap, struct ata_queued_cmd *qc,\r\nu32 check_status)\r\n{\r\nu8 status = 0;\r\nu32 mask = 0x0;\r\nu8 tag = qc->tag;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nhost_pvt.sata_dwc_sactive_queued = 0;\r\ndev_dbg(ap->dev, "%s checkstatus? %x\n", __func__, check_status);\r\nif (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_TX)\r\ndev_err(ap->dev, "TX DMA PENDING\n");\r\nelse if (hsdevp->dma_pending[tag] == SATA_DWC_DMA_PENDING_RX)\r\ndev_err(ap->dev, "RX DMA PENDING\n");\r\ndev_dbg(ap->dev, "QC complete cmd=0x%02x status=0x%02x ata%u:"\r\n" protocol=%d\n", qc->tf.command, status, ap->print_id,\r\nqc->tf.protocol);\r\nmask = (~(qcmd_tag_to_mask(tag)));\r\nhost_pvt.sata_dwc_sactive_queued = (host_pvt.sata_dwc_sactive_queued) \\r\n& mask;\r\nhost_pvt.sata_dwc_sactive_issued = (host_pvt.sata_dwc_sactive_issued) \\r\n& mask;\r\nata_qc_complete(qc);\r\nreturn 0;\r\n}\r\nstatic void sata_dwc_enable_interrupts(struct sata_dwc_device *hsdev)\r\n{\r\nout_le32(&hsdev->sata_dwc_regs->intmr,\r\nSATA_DWC_INTMR_ERRM |\r\nSATA_DWC_INTMR_NEWFPM |\r\nSATA_DWC_INTMR_PMABRTM |\r\nSATA_DWC_INTMR_DMATM);\r\nout_le32(&hsdev->sata_dwc_regs->errmr, SATA_DWC_SERROR_ERR_BITS);\r\ndev_dbg(host_pvt.dwc_dev, "%s: INTMR = 0x%08x, ERRMR = 0x%08x\n",\r\n__func__, in_le32(&hsdev->sata_dwc_regs->intmr),\r\nin_le32(&hsdev->sata_dwc_regs->errmr));\r\n}\r\nstatic void sata_dwc_setup_port(struct ata_ioports *port, unsigned long base)\r\n{\r\nport->cmd_addr = (void *)base + 0x00;\r\nport->data_addr = (void *)base + 0x00;\r\nport->error_addr = (void *)base + 0x04;\r\nport->feature_addr = (void *)base + 0x04;\r\nport->nsect_addr = (void *)base + 0x08;\r\nport->lbal_addr = (void *)base + 0x0c;\r\nport->lbam_addr = (void *)base + 0x10;\r\nport->lbah_addr = (void *)base + 0x14;\r\nport->device_addr = (void *)base + 0x18;\r\nport->command_addr = (void *)base + 0x1c;\r\nport->status_addr = (void *)base + 0x1c;\r\nport->altstatus_addr = (void *)base + 0x20;\r\nport->ctl_addr = (void *)base + 0x20;\r\n}\r\nstatic int sata_dwc_port_start(struct ata_port *ap)\r\n{\r\nint err = 0;\r\nstruct sata_dwc_device *hsdev;\r\nstruct sata_dwc_device_port *hsdevp = NULL;\r\nstruct device *pdev;\r\nint i;\r\nhsdev = HSDEV_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s: port_no=%d\n", __func__, ap->port_no);\r\nhsdev->host = ap->host;\r\npdev = ap->host->dev;\r\nif (!pdev) {\r\ndev_err(ap->dev, "%s: no ap->host->dev\n", __func__);\r\nerr = -ENODEV;\r\ngoto CLEANUP;\r\n}\r\nhsdevp = kzalloc(sizeof(*hsdevp), GFP_KERNEL);\r\nif (!hsdevp) {\r\ndev_err(ap->dev, "%s: kmalloc failed for hsdevp\n", __func__);\r\nerr = -ENOMEM;\r\ngoto CLEANUP;\r\n}\r\nhsdevp->hsdev = hsdev;\r\nfor (i = 0; i < SATA_DWC_QCMD_MAX; i++)\r\nhsdevp->cmd_issued[i] = SATA_DWC_CMD_ISSUED_NOT;\r\nap->bmdma_prd = 0;\r\nap->bmdma_prd_dma = 0;\r\nfor (i = 0; i < SATA_DWC_QCMD_MAX; i++) {\r\nhsdevp->llit[i] = dma_alloc_coherent(pdev,\r\nSATA_DWC_DMAC_LLI_TBL_SZ,\r\n&(hsdevp->llit_dma[i]),\r\nGFP_ATOMIC);\r\nif (!hsdevp->llit[i]) {\r\ndev_err(ap->dev, "%s: dma_alloc_coherent failed\n",\r\n__func__);\r\nerr = -ENOMEM;\r\ngoto CLEANUP_ALLOC;\r\n}\r\n}\r\nif (ap->port_no == 0) {\r\ndev_dbg(ap->dev, "%s: clearing TXCHEN, RXCHEN in DMAC\n",\r\n__func__);\r\nout_le32(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_TXRXCH_CLEAR);\r\ndev_dbg(ap->dev, "%s: setting burst size in DBTSR\n",\r\n__func__);\r\nout_le32(&hsdev->sata_dwc_regs->dbtsr,\r\n(SATA_DWC_DBTSR_MWR(AHB_DMA_BRST_DFLT) |\r\nSATA_DWC_DBTSR_MRD(AHB_DMA_BRST_DFLT)));\r\n}\r\nclear_serror();\r\nap->private_data = hsdevp;\r\ndev_dbg(ap->dev, "%s: done\n", __func__);\r\nreturn 0;\r\nCLEANUP_ALLOC:\r\nkfree(hsdevp);\r\nCLEANUP:\r\ndev_dbg(ap->dev, "%s: fail. ap->id = %d\n", __func__, ap->print_id);\r\nreturn err;\r\n}\r\nstatic void sata_dwc_port_stop(struct ata_port *ap)\r\n{\r\nint i;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s: ap->id = %d\n", __func__, ap->print_id);\r\nif (hsdevp && hsdev) {\r\nfor (i = 0; i < SATA_DWC_QCMD_MAX; i++) {\r\ndma_free_coherent(ap->host->dev,\r\nSATA_DWC_DMAC_LLI_TBL_SZ,\r\nhsdevp->llit[i], hsdevp->llit_dma[i]);\r\n}\r\nkfree(hsdevp);\r\n}\r\nap->private_data = NULL;\r\n}\r\nstatic void sata_dwc_exec_command_by_tag(struct ata_port *ap,\r\nstruct ata_taskfile *tf,\r\nu8 tag, u32 cmd_issued)\r\n{\r\nunsigned long flags;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s cmd(0x%02x): %s tag=%d\n", __func__, tf->command,\r\nata_get_cmd_descript(tf->command), tag);\r\nspin_lock_irqsave(&ap->host->lock, flags);\r\nhsdevp->cmd_issued[tag] = cmd_issued;\r\nspin_unlock_irqrestore(&ap->host->lock, flags);\r\nclear_serror();\r\nata_sff_exec_command(ap, tf);\r\n}\r\nstatic void sata_dwc_bmdma_setup_by_tag(struct ata_queued_cmd *qc, u8 tag)\r\n{\r\nsata_dwc_exec_command_by_tag(qc->ap, &qc->tf, tag,\r\nSATA_DWC_CMD_ISSUED_PEND);\r\n}\r\nstatic void sata_dwc_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nu8 tag = qc->tag;\r\nif (ata_is_ncq(qc->tf.protocol)) {\r\ndev_dbg(qc->ap->dev, "%s: ap->link.sactive=0x%08x tag=%d\n",\r\n__func__, qc->ap->link.sactive, tag);\r\n} else {\r\ntag = 0;\r\n}\r\nsata_dwc_bmdma_setup_by_tag(qc, tag);\r\n}\r\nstatic void sata_dwc_bmdma_start_by_tag(struct ata_queued_cmd *qc, u8 tag)\r\n{\r\nint start_dma;\r\nu32 reg, dma_chan;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_QC(qc);\r\nstruct ata_port *ap = qc->ap;\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\nint dir = qc->dma_dir;\r\ndma_chan = hsdevp->dma_chan[tag];\r\nif (hsdevp->cmd_issued[tag] != SATA_DWC_CMD_ISSUED_NOT) {\r\nstart_dma = 1;\r\nif (dir == DMA_TO_DEVICE)\r\nhsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_TX;\r\nelse\r\nhsdevp->dma_pending[tag] = SATA_DWC_DMA_PENDING_RX;\r\n} else {\r\ndev_err(ap->dev, "%s: Command not pending cmd_issued=%d "\r\n"(tag=%d) DMA NOT started\n", __func__,\r\nhsdevp->cmd_issued[tag], tag);\r\nstart_dma = 0;\r\n}\r\ndev_dbg(ap->dev, "%s qc=%p tag: %x cmd: 0x%02x dma_dir: %s "\r\n"start_dma? %x\n", __func__, qc, tag, qc->tf.command,\r\nget_dma_dir_descript(qc->dma_dir), start_dma);\r\nsata_dwc_tf_dump(&(qc->tf));\r\nif (start_dma) {\r\nreg = core_scr_read(SCR_ERROR);\r\nif (reg & SATA_DWC_SERROR_ERR_BITS) {\r\ndev_err(ap->dev, "%s: ****** SError=0x%08x ******\n",\r\n__func__, reg);\r\n}\r\nif (dir == DMA_TO_DEVICE)\r\nout_le32(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_TXCHEN);\r\nelse\r\nout_le32(&hsdev->sata_dwc_regs->dmacr,\r\nSATA_DWC_DMACR_RXCHEN);\r\ndma_dwc_xfer_start(dma_chan);\r\n}\r\n}\r\nstatic void sata_dwc_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nu8 tag = qc->tag;\r\nif (ata_is_ncq(qc->tf.protocol)) {\r\ndev_dbg(qc->ap->dev, "%s: ap->link.sactive=0x%08x tag=%d\n",\r\n__func__, qc->ap->link.sactive, tag);\r\n} else {\r\ntag = 0;\r\n}\r\ndev_dbg(qc->ap->dev, "%s\n", __func__);\r\nsata_dwc_bmdma_start_by_tag(qc, tag);\r\n}\r\nstatic void sata_dwc_qc_prep_by_tag(struct ata_queued_cmd *qc, u8 tag)\r\n{\r\nstruct scatterlist *sg = qc->sg;\r\nstruct ata_port *ap = qc->ap;\r\nint dma_chan;\r\nstruct sata_dwc_device *hsdev = HSDEV_FROM_AP(ap);\r\nstruct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);\r\ndev_dbg(ap->dev, "%s: port=%d dma dir=%s n_elem=%d\n",\r\n__func__, ap->port_no, get_dma_dir_descript(qc->dma_dir),\r\nqc->n_elem);\r\ndma_chan = dma_dwc_xfer_setup(sg, qc->n_elem, hsdevp->llit[tag],\r\nhsdevp->llit_dma[tag],\r\n(void *__iomem)(&hsdev->sata_dwc_regs->\\r\ndmadr), qc->dma_dir);\r\nif (dma_chan < 0) {\r\ndev_err(ap->dev, "%s: dma_dwc_xfer_setup returns err %d\n",\r\n__func__, dma_chan);\r\nreturn;\r\n}\r\nhsdevp->dma_chan[tag] = dma_chan;\r\n}\r\nstatic unsigned int sata_dwc_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nu32 sactive;\r\nu8 tag = qc->tag;\r\nstruct ata_port *ap = qc->ap;\r\n#ifdef DEBUG_NCQ\r\nif (qc->tag > 0 || ap->link.sactive > 1)\r\ndev_info(ap->dev, "%s ap id=%d cmd(0x%02x)=%s qc tag=%d "\r\n"prot=%s ap active_tag=0x%08x ap sactive=0x%08x\n",\r\n__func__, ap->print_id, qc->tf.command,\r\nata_get_cmd_descript(qc->tf.command),\r\nqc->tag, get_prot_descript(qc->tf.protocol),\r\nap->link.active_tag, ap->link.sactive);\r\n#endif\r\nif (!ata_is_ncq(qc->tf.protocol))\r\ntag = 0;\r\nsata_dwc_qc_prep_by_tag(qc, tag);\r\nif (ata_is_ncq(qc->tf.protocol)) {\r\nsactive = core_scr_read(SCR_ACTIVE);\r\nsactive |= (0x00000001 << tag);\r\ncore_scr_write(SCR_ACTIVE, sactive);\r\ndev_dbg(qc->ap->dev, "%s: tag=%d ap->link.sactive = 0x%08x "\r\n"sactive=0x%08x\n", __func__, tag, qc->ap->link.sactive,\r\nsactive);\r\nap->ops->sff_tf_load(ap, &qc->tf);\r\nsata_dwc_exec_command_by_tag(ap, &qc->tf, qc->tag,\r\nSATA_DWC_CMD_ISSUED_PEND);\r\n} else {\r\nata_sff_qc_issue(qc);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sata_dwc_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nif ((qc->dma_dir == DMA_NONE) || (qc->tf.protocol == ATA_PROT_PIO))\r\nreturn;\r\n#ifdef DEBUG_NCQ\r\nif (qc->tag > 0)\r\ndev_info(qc->ap->dev, "%s: qc->tag=%d ap->active_tag=0x%08x\n",\r\n__func__, qc->tag, qc->ap->link.active_tag);\r\nreturn ;\r\n#endif\r\n}\r\nstatic void sata_dwc_error_handler(struct ata_port *ap)\r\n{\r\nap->link.flags |= ATA_LFLAG_NO_HRST;\r\nata_sff_error_handler(ap);\r\n}\r\nstatic int sata_dwc_probe(struct platform_device *ofdev)\r\n{\r\nstruct sata_dwc_device *hsdev;\r\nu32 idr, versionr;\r\nchar *ver = (char *)&versionr;\r\nu8 *base = NULL;\r\nint err = 0;\r\nint irq, rc;\r\nstruct ata_host *host;\r\nstruct ata_port_info pi = sata_dwc_port_info[0];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nhsdev = kzalloc(sizeof(*hsdev), GFP_KERNEL);\r\nif (hsdev == NULL) {\r\ndev_err(&ofdev->dev, "kmalloc failed for hsdev\n");\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nbase = of_iomap(ofdev->dev.of_node, 0);\r\nif (!base) {\r\ndev_err(&ofdev->dev, "ioremap failed for SATA register"\r\n" address\n");\r\nerr = -ENODEV;\r\ngoto error_kmalloc;\r\n}\r\nhsdev->reg_base = base;\r\ndev_dbg(&ofdev->dev, "ioremap done for SATA register address\n");\r\nhsdev->sata_dwc_regs = (void *__iomem)(base + SATA_DWC_REG_OFFSET);\r\nhost = ata_host_alloc_pinfo(&ofdev->dev, ppi, SATA_DWC_MAX_PORTS);\r\nif (!host) {\r\ndev_err(&ofdev->dev, "ata_host_alloc_pinfo failed\n");\r\nerr = -ENOMEM;\r\ngoto error_iomap;\r\n}\r\nhost->private_data = hsdev;\r\nhost->ports[0]->ioaddr.cmd_addr = base;\r\nhost->ports[0]->ioaddr.scr_addr = base + SATA_DWC_SCR_OFFSET;\r\nhost_pvt.scr_addr_sstatus = base + SATA_DWC_SCR_OFFSET;\r\nsata_dwc_setup_port(&host->ports[0]->ioaddr, (unsigned long)base);\r\nidr = in_le32(&hsdev->sata_dwc_regs->idr);\r\nversionr = in_le32(&hsdev->sata_dwc_regs->versionr);\r\ndev_notice(&ofdev->dev, "id %d, controller version %c.%c%c\n",\r\nidr, ver[0], ver[1], ver[2]);\r\nirq = irq_of_parse_and_map(ofdev->dev.of_node, 1);\r\nif (irq == NO_IRQ) {\r\ndev_err(&ofdev->dev, "no SATA DMA irq\n");\r\nerr = -ENODEV;\r\ngoto error_out;\r\n}\r\nhost_pvt.sata_dma_regs = of_iomap(ofdev->dev.of_node, 1);\r\nif (!(host_pvt.sata_dma_regs)) {\r\ndev_err(&ofdev->dev, "ioremap failed for AHBDMA register"\r\n" address\n");\r\nerr = -ENODEV;\r\ngoto error_out;\r\n}\r\nhost_pvt.dwc_dev = &ofdev->dev;\r\ndma_dwc_init(hsdev, irq);\r\nsata_dwc_enable_interrupts(hsdev);\r\nirq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\nif (irq == NO_IRQ) {\r\ndev_err(&ofdev->dev, "no SATA DMA irq\n");\r\nerr = -ENODEV;\r\ngoto error_out;\r\n}\r\nrc = ata_host_activate(host, irq, sata_dwc_isr, 0, &sata_dwc_sht);\r\nif (rc != 0)\r\ndev_err(&ofdev->dev, "failed to activate host");\r\ndev_set_drvdata(&ofdev->dev, host);\r\nreturn 0;\r\nerror_out:\r\ndma_dwc_exit(hsdev);\r\nerror_iomap:\r\niounmap(base);\r\nerror_kmalloc:\r\nkfree(hsdev);\r\nerror:\r\nreturn err;\r\n}\r\nstatic int sata_dwc_remove(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct sata_dwc_device *hsdev = host->private_data;\r\nata_host_detach(host);\r\ndev_set_drvdata(dev, NULL);\r\ndma_dwc_exit(hsdev);\r\niounmap(hsdev->reg_base);\r\nkfree(hsdev);\r\nkfree(host);\r\ndev_dbg(&ofdev->dev, "done\n");\r\nreturn 0;\r\n}
