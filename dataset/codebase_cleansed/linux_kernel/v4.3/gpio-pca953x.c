static inline struct pca953x_chip *to_pca(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct pca953x_chip, gpio_chip);\r\n}\r\nstatic int pca953x_read_single(struct pca953x_chip *chip, int reg, u32 *val,\r\nint off)\r\n{\r\nint ret;\r\nint bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);\r\nint offset = off / BANK_SZ;\r\nret = i2c_smbus_read_byte_data(chip->client,\r\n(reg << bank_shift) + offset);\r\n*val = ret;\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "failed reading register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_write_single(struct pca953x_chip *chip, int reg, u32 val,\r\nint off)\r\n{\r\nint ret = 0;\r\nint bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);\r\nint offset = off / BANK_SZ;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\n(reg << bank_shift) + offset, val);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "failed writing register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_write_regs(struct pca953x_chip *chip, int reg, u8 *val)\r\n{\r\nint ret = 0;\r\nif (chip->gpio_chip.ngpio <= 8)\r\nret = i2c_smbus_write_byte_data(chip->client, reg, *val);\r\nelse if (chip->gpio_chip.ngpio >= 24) {\r\nint bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);\r\nret = i2c_smbus_write_i2c_block_data(chip->client,\r\n(reg << bank_shift) | REG_ADDR_AI,\r\nNBANK(chip), val);\r\n} else {\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\nret = i2c_smbus_write_word_data(chip->client,\r\nreg << 1, (u16) *val);\r\nbreak;\r\ncase PCA957X_TYPE:\r\nret = i2c_smbus_write_byte_data(chip->client, reg << 1,\r\nval[0]);\r\nif (ret < 0)\r\nbreak;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\n(reg << 1) + 1,\r\nval[1]);\r\nbreak;\r\n}\r\n}\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "failed writing register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_read_regs(struct pca953x_chip *chip, int reg, u8 *val)\r\n{\r\nint ret;\r\nif (chip->gpio_chip.ngpio <= 8) {\r\nret = i2c_smbus_read_byte_data(chip->client, reg);\r\n*val = ret;\r\n} else if (chip->gpio_chip.ngpio >= 24) {\r\nint bank_shift = fls((chip->gpio_chip.ngpio - 1) / BANK_SZ);\r\nret = i2c_smbus_read_i2c_block_data(chip->client,\r\n(reg << bank_shift) | REG_ADDR_AI,\r\nNBANK(chip), val);\r\n} else {\r\nret = i2c_smbus_read_word_data(chip->client, reg << 1);\r\nval[0] = (u16)ret & 0xFF;\r\nval[1] = (u16)ret >> 8;\r\n}\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "failed reading register\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nu8 reg_val;\r\nint ret, offset = 0;\r\nmutex_lock(&chip->i2c_lock);\r\nreg_val = chip->reg_direction[off / BANK_SZ] | (1u << (off % BANK_SZ));\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_DIRECTION;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_CFG;\r\nbreak;\r\n}\r\nret = pca953x_write_single(chip, offset, reg_val, off);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_direction[off / BANK_SZ] = reg_val;\r\nret = 0;\r\nexit:\r\nmutex_unlock(&chip->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic int pca953x_gpio_direction_output(struct gpio_chip *gc,\r\nunsigned off, int val)\r\n{\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nu8 reg_val;\r\nint ret, offset = 0;\r\nmutex_lock(&chip->i2c_lock);\r\nif (val)\r\nreg_val = chip->reg_output[off / BANK_SZ]\r\n| (1u << (off % BANK_SZ));\r\nelse\r\nreg_val = chip->reg_output[off / BANK_SZ]\r\n& ~(1u << (off % BANK_SZ));\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_OUTPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_OUT;\r\nbreak;\r\n}\r\nret = pca953x_write_single(chip, offset, reg_val, off);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_output[off / BANK_SZ] = reg_val;\r\nreg_val = chip->reg_direction[off / BANK_SZ] & ~(1u << (off % BANK_SZ));\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_DIRECTION;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_CFG;\r\nbreak;\r\n}\r\nret = pca953x_write_single(chip, offset, reg_val, off);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_direction[off / BANK_SZ] = reg_val;\r\nret = 0;\r\nexit:\r\nmutex_unlock(&chip->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)\r\n{\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nu32 reg_val;\r\nint ret, offset = 0;\r\nmutex_lock(&chip->i2c_lock);\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_INPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_IN;\r\nbreak;\r\n}\r\nret = pca953x_read_single(chip, offset, &reg_val, off);\r\nmutex_unlock(&chip->i2c_lock);\r\nif (ret < 0) {\r\nreturn 0;\r\n}\r\nreturn (reg_val & (1u << (off % BANK_SZ))) ? 1 : 0;\r\n}\r\nstatic void pca953x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)\r\n{\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nu8 reg_val;\r\nint ret, offset = 0;\r\nmutex_lock(&chip->i2c_lock);\r\nif (val)\r\nreg_val = chip->reg_output[off / BANK_SZ]\r\n| (1u << (off % BANK_SZ));\r\nelse\r\nreg_val = chip->reg_output[off / BANK_SZ]\r\n& ~(1u << (off % BANK_SZ));\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_OUTPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_OUT;\r\nbreak;\r\n}\r\nret = pca953x_write_single(chip, offset, reg_val, off);\r\nif (ret)\r\ngoto exit;\r\nchip->reg_output[off / BANK_SZ] = reg_val;\r\nexit:\r\nmutex_unlock(&chip->i2c_lock);\r\n}\r\nstatic void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)\r\n{\r\nstruct gpio_chip *gc;\r\ngc = &chip->gpio_chip;\r\ngc->direction_input = pca953x_gpio_direction_input;\r\ngc->direction_output = pca953x_gpio_direction_output;\r\ngc->get = pca953x_gpio_get_value;\r\ngc->set = pca953x_gpio_set_value;\r\ngc->can_sleep = true;\r\ngc->base = chip->gpio_start;\r\ngc->ngpio = gpios;\r\ngc->label = chip->client->name;\r\ngc->dev = &chip->client->dev;\r\ngc->owner = THIS_MODULE;\r\ngc->names = chip->names;\r\n}\r\nstatic void pca953x_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nchip->irq_mask[d->hwirq / BANK_SZ] &= ~(1 << (d->hwirq % BANK_SZ));\r\n}\r\nstatic void pca953x_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nchip->irq_mask[d->hwirq / BANK_SZ] |= 1 << (d->hwirq % BANK_SZ);\r\n}\r\nstatic void pca953x_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nmutex_lock(&chip->irq_lock);\r\n}\r\nstatic void pca953x_irq_bus_sync_unlock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nu8 new_irqs;\r\nint level, i;\r\nfor (i = 0; i < NBANK(chip); i++) {\r\nnew_irqs = chip->irq_trig_fall[i] | chip->irq_trig_raise[i];\r\nnew_irqs &= ~chip->reg_direction[i];\r\nwhile (new_irqs) {\r\nlevel = __ffs(new_irqs);\r\npca953x_gpio_direction_input(&chip->gpio_chip,\r\nlevel + (BANK_SZ * i));\r\nnew_irqs &= ~(1 << level);\r\n}\r\n}\r\nmutex_unlock(&chip->irq_lock);\r\n}\r\nstatic int pca953x_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct pca953x_chip *chip = to_pca(gc);\r\nint bank_nb = d->hwirq / BANK_SZ;\r\nu8 mask = 1 << (d->hwirq % BANK_SZ);\r\nif (!(type & IRQ_TYPE_EDGE_BOTH)) {\r\ndev_err(&chip->client->dev, "irq %d: unsupported type %d\n",\r\nd->irq, type);\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nchip->irq_trig_fall[bank_nb] |= mask;\r\nelse\r\nchip->irq_trig_fall[bank_nb] &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nchip->irq_trig_raise[bank_nb] |= mask;\r\nelse\r\nchip->irq_trig_raise[bank_nb] &= ~mask;\r\nreturn 0;\r\n}\r\nstatic bool pca953x_irq_pending(struct pca953x_chip *chip, u8 *pending)\r\n{\r\nu8 cur_stat[MAX_BANK];\r\nu8 old_stat[MAX_BANK];\r\nbool pending_seen = false;\r\nbool trigger_seen = false;\r\nu8 trigger[MAX_BANK];\r\nint ret, i, offset = 0;\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_INPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_IN;\r\nbreak;\r\n}\r\nret = pca953x_read_regs(chip, offset, cur_stat);\r\nif (ret)\r\nreturn false;\r\nfor (i = 0; i < NBANK(chip); i++)\r\ncur_stat[i] &= chip->reg_direction[i];\r\nmemcpy(old_stat, chip->irq_stat, NBANK(chip));\r\nfor (i = 0; i < NBANK(chip); i++) {\r\ntrigger[i] = (cur_stat[i] ^ old_stat[i]) & chip->irq_mask[i];\r\nif (trigger[i])\r\ntrigger_seen = true;\r\n}\r\nif (!trigger_seen)\r\nreturn false;\r\nmemcpy(chip->irq_stat, cur_stat, NBANK(chip));\r\nfor (i = 0; i < NBANK(chip); i++) {\r\npending[i] = (old_stat[i] & chip->irq_trig_fall[i]) |\r\n(cur_stat[i] & chip->irq_trig_raise[i]);\r\npending[i] &= trigger[i];\r\nif (pending[i])\r\npending_seen = true;\r\n}\r\nreturn pending_seen;\r\n}\r\nstatic irqreturn_t pca953x_irq_handler(int irq, void *devid)\r\n{\r\nstruct pca953x_chip *chip = devid;\r\nu8 pending[MAX_BANK];\r\nu8 level;\r\nunsigned nhandled = 0;\r\nint i;\r\nif (!pca953x_irq_pending(chip, pending))\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < NBANK(chip); i++) {\r\nwhile (pending[i]) {\r\nlevel = __ffs(pending[i]);\r\nhandle_nested_irq(irq_find_mapping(chip->gpio_chip.irqdomain,\r\nlevel + (BANK_SZ * i)));\r\npending[i] &= ~(1 << level);\r\nnhandled++;\r\n}\r\n}\r\nreturn (nhandled > 0) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int pca953x_irq_setup(struct pca953x_chip *chip,\r\nconst struct i2c_device_id *id,\r\nint irq_base)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nint ret, i, offset = 0;\r\nif (client->irq && irq_base != -1\r\n&& (id->driver_data & PCA_INT)) {\r\nswitch (chip->chip_type) {\r\ncase PCA953X_TYPE:\r\noffset = PCA953X_INPUT;\r\nbreak;\r\ncase PCA957X_TYPE:\r\noffset = PCA957X_IN;\r\nbreak;\r\n}\r\nret = pca953x_read_regs(chip, offset, chip->irq_stat);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < NBANK(chip); i++)\r\nchip->irq_stat[i] &= chip->reg_direction[i];\r\nmutex_init(&chip->irq_lock);\r\nret = devm_request_threaded_irq(&client->dev,\r\nclient->irq,\r\nNULL,\r\npca953x_irq_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT |\r\nIRQF_SHARED,\r\ndev_name(&client->dev), chip);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to request irq %d\n",\r\nclient->irq);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(&chip->gpio_chip,\r\n&pca953x_irq_chip,\r\nirq_base,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"could not connect irqchip to gpiochip\n");\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&chip->gpio_chip,\r\n&pca953x_irq_chip,\r\nclient->irq, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pca953x_irq_setup(struct pca953x_chip *chip,\r\nconst struct i2c_device_id *id,\r\nint irq_base)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nif (irq_base != -1 && (id->driver_data & PCA_INT))\r\ndev_warn(&client->dev, "interrupt support not compiled in\n");\r\nreturn 0;\r\n}\r\nstatic int device_pca953x_init(struct pca953x_chip *chip, u32 invert)\r\n{\r\nint ret;\r\nu8 val[MAX_BANK];\r\nret = pca953x_read_regs(chip, PCA953X_OUTPUT, chip->reg_output);\r\nif (ret)\r\ngoto out;\r\nret = pca953x_read_regs(chip, PCA953X_DIRECTION,\r\nchip->reg_direction);\r\nif (ret)\r\ngoto out;\r\nif (invert)\r\nmemset(val, 0xFF, NBANK(chip));\r\nelse\r\nmemset(val, 0, NBANK(chip));\r\nret = pca953x_write_regs(chip, PCA953X_INVERT, val);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int device_pca957x_init(struct pca953x_chip *chip, u32 invert)\r\n{\r\nint ret;\r\nu8 val[MAX_BANK];\r\nret = pca953x_read_regs(chip, PCA957X_OUT, chip->reg_output);\r\nif (ret)\r\ngoto out;\r\nret = pca953x_read_regs(chip, PCA957X_CFG, chip->reg_direction);\r\nif (ret)\r\ngoto out;\r\nif (invert)\r\nmemset(val, 0xFF, NBANK(chip));\r\nelse\r\nmemset(val, 0, NBANK(chip));\r\npca953x_write_regs(chip, PCA957X_INVRT, val);\r\nmemset(val, 0x02, NBANK(chip));\r\npca953x_write_regs(chip, PCA957X_BKEN, val);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pca953x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca953x_platform_data *pdata;\r\nstruct pca953x_chip *chip;\r\nint irq_base = 0;\r\nint ret;\r\nu32 invert = 0;\r\nchip = devm_kzalloc(&client->dev,\r\nsizeof(struct pca953x_chip), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\npdata = dev_get_platdata(&client->dev);\r\nif (pdata) {\r\nirq_base = pdata->irq_base;\r\nchip->gpio_start = pdata->gpio_base;\r\ninvert = pdata->invert;\r\nchip->names = pdata->names;\r\n} else {\r\nchip->gpio_start = -1;\r\nirq_base = 0;\r\n}\r\nchip->client = client;\r\nchip->chip_type = id->driver_data & (PCA953X_TYPE | PCA957X_TYPE);\r\nmutex_init(&chip->i2c_lock);\r\npca953x_setup_gpio(chip, id->driver_data & PCA_GPIO_MASK);\r\nif (chip->chip_type == PCA953X_TYPE)\r\nret = device_pca953x_init(chip, invert);\r\nelse\r\nret = device_pca957x_init(chip, invert);\r\nif (ret)\r\nreturn ret;\r\nret = gpiochip_add(&chip->gpio_chip);\r\nif (ret)\r\nreturn ret;\r\nret = pca953x_irq_setup(chip, id, irq_base);\r\nif (ret)\r\nreturn ret;\r\nif (pdata && pdata->setup) {\r\nret = pdata->setup(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "setup failed, %d\n", ret);\r\n}\r\ni2c_set_clientdata(client, chip);\r\nreturn 0;\r\n}\r\nstatic int pca953x_remove(struct i2c_client *client)\r\n{\r\nstruct pca953x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct pca953x_chip *chip = i2c_get_clientdata(client);\r\nint ret = 0;\r\nif (pdata && pdata->teardown) {\r\nret = pdata->teardown(client, chip->gpio_chip.base,\r\nchip->gpio_chip.ngpio, pdata->context);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "%s failed, %d\n",\r\n"teardown", ret);\r\nreturn ret;\r\n}\r\n}\r\ngpiochip_remove(&chip->gpio_chip);\r\nreturn 0;\r\n}\r\nstatic int __init pca953x_init(void)\r\n{\r\nreturn i2c_add_driver(&pca953x_driver);\r\n}\r\nstatic void __exit pca953x_exit(void)\r\n{\r\ni2c_del_driver(&pca953x_driver);\r\n}
