static void netcp_xgbe_serdes_cmu_init(void __iomem *serdes_regs)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_phyb_1p25g_156p25mhz_cmu0); i++) {\r\nreg_rmw(serdes_regs + cfg_phyb_1p25g_156p25mhz_cmu0[i].ofs,\r\ncfg_phyb_1p25g_156p25mhz_cmu0[i].val,\r\ncfg_phyb_1p25g_156p25mhz_cmu0[i].mask);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cfg_phyb_10p3125g_156p25mhz_cmu1); i++) {\r\nreg_rmw(serdes_regs + cfg_phyb_10p3125g_156p25mhz_cmu1[i].ofs,\r\ncfg_phyb_10p3125g_156p25mhz_cmu1[i].val,\r\ncfg_phyb_10p3125g_156p25mhz_cmu1[i].mask);\r\n}\r\n}\r\nstatic void netcp_xgbe_serdes_lane_config(\r\nvoid __iomem *serdes_regs, int lane)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_phyb_10p3125g_16bit_lane); i++) {\r\nreg_rmw(serdes_regs +\r\ncfg_phyb_10p3125g_16bit_lane[i].ofs +\r\n(0x200 * lane),\r\ncfg_phyb_10p3125g_16bit_lane[i].val,\r\ncfg_phyb_10p3125g_16bit_lane[i].mask);\r\n}\r\nreg_rmw(serdes_regs + (0x200 * lane) + 0x0380,\r\n0x00000000, 0x00000010);\r\nreg_rmw(serdes_regs + (0x200 * lane) + 0x03c0,\r\n0x00000000, 0x00000200);\r\n}\r\nstatic void netcp_xgbe_serdes_com_enable(void __iomem *serdes_regs)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_phyb_10p3125g_comlane); i++) {\r\nreg_rmw(serdes_regs + cfg_phyb_10p3125g_comlane[i].ofs,\r\ncfg_phyb_10p3125g_comlane[i].val,\r\ncfg_phyb_10p3125g_comlane[i].mask);\r\n}\r\n}\r\nstatic void netcp_xgbe_serdes_lane_enable(\r\nvoid __iomem *serdes_regs, int lane)\r\n{\r\nwritel(0xe0e9e038, serdes_regs + 0x1fe0 + (4 * lane));\r\n}\r\nstatic void netcp_xgbe_serdes_phyb_rst_clr(void __iomem *serdes_regs)\r\n{\r\nreg_rmw(serdes_regs + 0x0a00, 0x0000001f, 0x000000ff);\r\n}\r\nstatic void netcp_xgbe_serdes_pll_disable(void __iomem *serdes_regs)\r\n{\r\nwritel(0x88000000, serdes_regs + 0x1ff4);\r\n}\r\nstatic void netcp_xgbe_serdes_pll_enable(void __iomem *serdes_regs)\r\n{\r\nnetcp_xgbe_serdes_phyb_rst_clr(serdes_regs);\r\nwritel(0xee000000, serdes_regs + 0x1ff4);\r\n}\r\nstatic int netcp_xgbe_wait_pll_locked(void __iomem *sw_regs)\r\n{\r\nunsigned long timeout;\r\nint ret = 0;\r\nu32 val_1, val_0;\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\ndo {\r\nval_0 = (readl(sw_regs + XGBE_SGMII_1_OFFSET) & BIT(4));\r\nval_1 = (readl(sw_regs + XGBE_SGMII_2_OFFSET) & BIT(4));\r\nif (val_1 && val_0)\r\nreturn 0;\r\nif (time_after(jiffies, timeout)) {\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\ncpu_relax();\r\n} while (true);\r\npr_err("XGBE serdes not locked: time out.\n");\r\nreturn ret;\r\n}\r\nstatic void netcp_xgbe_serdes_enable_xgmii_port(void __iomem *sw_regs)\r\n{\r\nwritel(0x03, sw_regs + XGBE_CTRL_OFFSET);\r\n}\r\nstatic u32 netcp_xgbe_serdes_read_tbus_val(void __iomem *serdes_regs)\r\n{\r\nu32 tmp;\r\nif (PHY_A(serdes_regs)) {\r\ntmp = (readl(serdes_regs + 0x0ec) >> 24) & 0x0ff;\r\ntmp |= ((readl(serdes_regs + 0x0fc) >> 16) & 0x00f00);\r\n} else {\r\ntmp = (readl(serdes_regs + 0x0f8) >> 16) & 0x0fff;\r\n}\r\nreturn tmp;\r\n}\r\nstatic void netcp_xgbe_serdes_write_tbus_addr(void __iomem *serdes_regs,\r\nint select, int ofs)\r\n{\r\nif (PHY_A(serdes_regs)) {\r\nreg_rmw(serdes_regs + 0x0008, ((select << 5) + ofs) << 24,\r\n~0x00ffffff);\r\nreturn;\r\n}\r\nswitch (select) {\r\ncase 1:\r\nselect = 2;\r\nbreak;\r\ncase 2:\r\nselect = 3;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nreg_rmw(serdes_regs + 0x00fc, ((select << 8) + ofs) << 16, ~0xf800ffff);\r\n}\r\nstatic u32 netcp_xgbe_serdes_read_select_tbus(void __iomem *serdes_regs,\r\nint select, int ofs)\r\n{\r\nnetcp_xgbe_serdes_write_tbus_addr(serdes_regs, select, ofs);\r\nreturn netcp_xgbe_serdes_read_tbus_val(serdes_regs);\r\n}\r\nstatic void netcp_xgbe_serdes_reset_cdr(void __iomem *serdes_regs,\r\nvoid __iomem *sig_detect_reg, int lane)\r\n{\r\nu32 tmp, dlpf, tbus;\r\ntmp = netcp_xgbe_serdes_read_select_tbus(\r\nserdes_regs, lane + 1, 5);\r\ndlpf = tmp >> 2;\r\nif (dlpf < 400 || dlpf > 700) {\r\nreg_rmw(sig_detect_reg, VAL_SH(2, 1), MASK_WID_SH(2, 1));\r\nmdelay(1);\r\nreg_rmw(sig_detect_reg, VAL_SH(0, 1), MASK_WID_SH(2, 1));\r\n} else {\r\ntbus = netcp_xgbe_serdes_read_select_tbus(serdes_regs, lane +\r\n1, 0xe);\r\npr_debug("XGBE: CDR centered, DLPF: %4d,%d,%d.\n",\r\ntmp >> 2, tmp & 3, (tbus >> 2) & 3);\r\n}\r\n}\r\nstatic int netcp_xgbe_check_link_status(void __iomem *serdes_regs,\r\nvoid __iomem *sw_regs, u32 lanes,\r\nu32 *current_state, u32 *lane_down)\r\n{\r\nvoid __iomem *pcsr_base = sw_regs + 0x0600;\r\nvoid __iomem *sig_detect_reg;\r\nu32 pcsr_rx_stat, blk_lock, blk_errs;\r\nint loss, i, status = 1;\r\nfor (i = 0; i < lanes; i++) {\r\nloss = readl(serdes_regs + 0x1fc0 + 0x20 + (i * 0x04)) & 0x1;\r\npcsr_rx_stat = readl(pcsr_base + 0x0c + (i * 0x80));\r\nblk_lock = (pcsr_rx_stat >> 30) & 0x1;\r\nblk_errs = (pcsr_rx_stat >> 16) & 0x0ff;\r\nsig_detect_reg = serdes_regs + (i * 0x200) + 0x200 + 0x04;\r\nif (blk_errs == 0x0ff)\r\nblk_lock = 0;\r\nswitch (current_state[i]) {\r\ncase 0:\r\nif (!loss && blk_lock) {\r\npr_debug("XGBE PCSR Linked Lane: %d\n", i);\r\nreg_rmw(sig_detect_reg, VAL_SH(3, 1),\r\nMASK_WID_SH(2, 1));\r\ncurrent_state[i] = 1;\r\n} else if (!blk_lock) {\r\npr_debug("XGBE PCSR Recover Lane: %d\n", i);\r\nnetcp_xgbe_serdes_reset_cdr(serdes_regs,\r\nsig_detect_reg, i);\r\n}\r\nbreak;\r\ncase 1:\r\nif (!blk_lock) {\r\nlane_down[i] = 1;\r\ncurrent_state[i] = 2;\r\n}\r\nbreak;\r\ncase 2:\r\nif (blk_lock)\r\ncurrent_state[i] = 1;\r\nelse {\r\nnetcp_xgbe_serdes_reset_cdr(serdes_regs,\r\nsig_detect_reg, i);\r\ncurrent_state[i] = 0;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("XGBE: unknown current_state[%d] %d\n",\r\ni, current_state[i]);\r\nbreak;\r\n}\r\nif (blk_errs > 0) {\r\nreg_rmw(pcsr_base + 0x08 + (i * 0x80), VAL_SH(0x19, 0),\r\nMASK_WID_SH(8, 0));\r\nreg_rmw(pcsr_base + 0x08 + (i * 0x80), VAL_SH(0x00, 0),\r\nMASK_WID_SH(8, 0));\r\n}\r\nstatus &= (current_state[i] == 1);\r\n}\r\nreturn status;\r\n}\r\nstatic int netcp_xgbe_serdes_check_lane(void __iomem *serdes_regs,\r\nvoid __iomem *sw_regs)\r\n{\r\nu32 current_state[2] = {0, 0};\r\nint retries = 0, link_up;\r\nu32 lane_down[2];\r\ndo {\r\nlane_down[0] = 0;\r\nlane_down[1] = 0;\r\nlink_up = netcp_xgbe_check_link_status(serdes_regs, sw_regs, 2,\r\ncurrent_state,\r\nlane_down);\r\nif (link_up)\r\nbreak;\r\nif (lane_down[0])\r\npr_debug("XGBE: detected link down on lane 0\n");\r\nif (lane_down[1])\r\npr_debug("XGBE: detected link down on lane 1\n");\r\nif (++retries > 1) {\r\npr_debug("XGBE: timeout waiting for serdes link up\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmdelay(100);\r\n} while (!link_up);\r\npr_debug("XGBE: PCSR link is up\n");\r\nreturn 0;\r\n}\r\nstatic void netcp_xgbe_serdes_setup_cm_c1_c2(void __iomem *serdes_regs,\r\nint lane, int cm, int c1, int c2)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_cm_c1_c2); i++) {\r\nreg_rmw(serdes_regs + cfg_cm_c1_c2[i].ofs + (0x200 * lane),\r\ncfg_cm_c1_c2[i].val,\r\ncfg_cm_c1_c2[i].mask);\r\n}\r\n}\r\nstatic void netcp_xgbe_reset_serdes(void __iomem *serdes_regs)\r\n{\r\nreg_rmw(serdes_regs + PCSR_CPU_CTRL_OFFSET, POR_EN, POR_EN);\r\nusleep_range(10, 100);\r\nreg_rmw(serdes_regs + PCSR_CPU_CTRL_OFFSET, 0, POR_EN);\r\nusleep_range(10, 100);\r\n}\r\nstatic int netcp_xgbe_serdes_config(void __iomem *serdes_regs,\r\nvoid __iomem *sw_regs)\r\n{\r\nu32 ret, i;\r\nnetcp_xgbe_serdes_pll_disable(serdes_regs);\r\nnetcp_xgbe_serdes_cmu_init(serdes_regs);\r\nfor (i = 0; i < 2; i++)\r\nnetcp_xgbe_serdes_lane_config(serdes_regs, i);\r\nnetcp_xgbe_serdes_com_enable(serdes_regs);\r\nfor (i = 0; i < 2; i++)\r\nnetcp_xgbe_serdes_setup_cm_c1_c2(serdes_regs, i, 0, 0, 5);\r\nnetcp_xgbe_serdes_pll_enable(serdes_regs);\r\nfor (i = 0; i < 2; i++)\r\nnetcp_xgbe_serdes_lane_enable(serdes_regs, i);\r\nret = netcp_xgbe_wait_pll_locked(sw_regs);\r\nif (ret)\r\nreturn ret;\r\nnetcp_xgbe_serdes_enable_xgmii_port(sw_regs);\r\nnetcp_xgbe_serdes_check_lane(serdes_regs, sw_regs);\r\nreturn ret;\r\n}\r\nint netcp_xgbe_serdes_init(void __iomem *serdes_regs, void __iomem *xgbe_regs)\r\n{\r\nu32 val;\r\nval = readl(serdes_regs + 0xa00);\r\nif (val & 0x1f) {\r\npr_debug("XGBE: serdes already in operation - reset\n");\r\nnetcp_xgbe_reset_serdes(serdes_regs);\r\n}\r\nreturn netcp_xgbe_serdes_config(serdes_regs, xgbe_regs);\r\n}
