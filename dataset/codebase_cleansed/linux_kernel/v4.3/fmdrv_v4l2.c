static ssize_t fm_v4l2_fops_read(struct file *file, char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu8 rds_mode;\r\nint ret;\r\nstruct fmdev *fmdev;\r\nfmdev = video_drvdata(file);\r\nif (!radio_disconnected) {\r\nfmerr("FM device is already disconnected\n");\r\nreturn -EIO;\r\n}\r\nif (mutex_lock_interruptible(&fmdev->mutex))\r\nreturn -ERESTARTSYS;\r\nret = fm_rx_get_rds_mode(fmdev, &rds_mode);\r\nif (ret < 0) {\r\nfmerr("Unable to read current rds mode\n");\r\ngoto read_unlock;\r\n}\r\nif (rds_mode == FM_RDS_DISABLE) {\r\nret = fmc_set_rds_mode(fmdev, FM_RDS_ENABLE);\r\nif (ret < 0) {\r\nfmerr("Failed to enable rds mode\n");\r\ngoto read_unlock;\r\n}\r\n}\r\nret = fmc_transfer_rds_from_internal_buff(fmdev, file, buf, count);\r\nread_unlock:\r\nmutex_unlock(&fmdev->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t fm_v4l2_fops_write(struct file *file, const char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct tx_rds rds;\r\nint ret;\r\nstruct fmdev *fmdev;\r\nret = copy_from_user(&rds, buf, sizeof(rds));\r\nrds.text[sizeof(rds.text) - 1] = '\0';\r\nfmdbg("(%d)type: %d, text %s, af %d\n",\r\nret, rds.text_type, rds.text, rds.af_freq);\r\nif (ret)\r\nreturn -EFAULT;\r\nfmdev = video_drvdata(file);\r\nif (mutex_lock_interruptible(&fmdev->mutex))\r\nreturn -ERESTARTSYS;\r\nfm_tx_set_radio_text(fmdev, rds.text, rds.text_type);\r\nfm_tx_set_af(fmdev, rds.af_freq);\r\nmutex_unlock(&fmdev->mutex);\r\nreturn sizeof(rds);\r\n}\r\nstatic u32 fm_v4l2_fops_poll(struct file *file, struct poll_table_struct *pts)\r\n{\r\nint ret;\r\nstruct fmdev *fmdev;\r\nfmdev = video_drvdata(file);\r\nmutex_lock(&fmdev->mutex);\r\nret = fmc_is_rds_data_available(fmdev, file, pts);\r\nmutex_unlock(&fmdev->mutex);\r\nif (ret < 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int fm_v4l2_fops_open(struct file *file)\r\n{\r\nint ret;\r\nstruct fmdev *fmdev = NULL;\r\nif (radio_disconnected) {\r\nfmerr("FM device is already opened\n");\r\nreturn -EBUSY;\r\n}\r\nfmdev = video_drvdata(file);\r\nif (mutex_lock_interruptible(&fmdev->mutex))\r\nreturn -ERESTARTSYS;\r\nret = fmc_prepare(fmdev);\r\nif (ret < 0) {\r\nfmerr("Unable to prepare FM CORE\n");\r\ngoto open_unlock;\r\n}\r\nfmdbg("Load FM RX firmware..\n");\r\nret = fmc_set_mode(fmdev, FM_MODE_RX);\r\nif (ret < 0) {\r\nfmerr("Unable to load FM RX firmware\n");\r\ngoto open_unlock;\r\n}\r\nradio_disconnected = 1;\r\nopen_unlock:\r\nmutex_unlock(&fmdev->mutex);\r\nreturn ret;\r\n}\r\nstatic int fm_v4l2_fops_release(struct file *file)\r\n{\r\nint ret;\r\nstruct fmdev *fmdev;\r\nfmdev = video_drvdata(file);\r\nif (!radio_disconnected) {\r\nfmdbg("FM device is already closed\n");\r\nreturn 0;\r\n}\r\nmutex_lock(&fmdev->mutex);\r\nret = fmc_set_mode(fmdev, FM_MODE_OFF);\r\nif (ret < 0) {\r\nfmerr("Unable to turn off the chip\n");\r\ngoto release_unlock;\r\n}\r\nret = fmc_release(fmdev);\r\nif (ret < 0) {\r\nfmerr("FM CORE release failed\n");\r\ngoto release_unlock;\r\n}\r\nradio_disconnected = 0;\r\nrelease_unlock:\r\nmutex_unlock(&fmdev->mutex);\r\nreturn ret;\r\n}\r\nstatic int fm_v4l2_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstrlcpy(capability->driver, FM_DRV_NAME, sizeof(capability->driver));\r\nstrlcpy(capability->card, FM_DRV_CARD_SHORT_NAME,\r\nsizeof(capability->card));\r\nsprintf(capability->bus_info, "UART");\r\ncapability->device_caps = V4L2_CAP_HW_FREQ_SEEK | V4L2_CAP_TUNER |\r\nV4L2_CAP_RADIO | V4L2_CAP_MODULATOR |\r\nV4L2_CAP_AUDIO | V4L2_CAP_READWRITE |\r\nV4L2_CAP_RDS_CAPTURE;\r\ncapability->capabilities = capability->device_caps |\r\nV4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int fm_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fmdev *fmdev = container_of(ctrl->handler,\r\nstruct fmdev, ctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_TUNE_ANTENNA_CAPACITOR:\r\nctrl->val = fm_tx_get_tune_cap_val(fmdev);\r\nbreak;\r\ndefault:\r\nfmwarn("%s: Unknown IOCTL: %d\n", __func__, ctrl->id);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fm_v4l2_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fmdev *fmdev = container_of(ctrl->handler,\r\nstruct fmdev, ctrl_handler);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn fm_rx_set_volume(fmdev, (u16)ctrl->val);\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn fmc_set_mute_mode(fmdev, (u8)ctrl->val);\r\ncase V4L2_CID_TUNE_POWER_LEVEL:\r\nreturn fm_tx_set_pwr_lvl(fmdev, (u8)ctrl->val);\r\ncase V4L2_CID_TUNE_PREEMPHASIS:\r\nreturn fm_tx_set_preemph_filter(fmdev, (u8) ctrl->val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int fm_v4l2_vidioc_g_audio(struct file *file, void *priv,\r\nstruct v4l2_audio *audio)\r\n{\r\nmemset(audio, 0, sizeof(*audio));\r\nstrcpy(audio->name, "Radio");\r\naudio->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int fm_v4l2_vidioc_s_audio(struct file *file, void *priv,\r\nconst struct v4l2_audio *audio)\r\n{\r\nif (audio->index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int fm_v4l2_vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *tuner)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nu32 bottom_freq;\r\nu32 top_freq;\r\nu16 stereo_mono_mode;\r\nu16 rssilvl;\r\nint ret;\r\nif (tuner->index != 0)\r\nreturn -EINVAL;\r\nif (fmdev->curr_fmmode != FM_MODE_RX)\r\nreturn -EPERM;\r\nret = fm_rx_get_band_freq_range(fmdev, &bottom_freq, &top_freq);\r\nif (ret != 0)\r\nreturn ret;\r\nret = fm_rx_get_stereo_mono(fmdev, &stereo_mono_mode);\r\nif (ret != 0)\r\nreturn ret;\r\nret = fm_rx_get_rssi_level(fmdev, &rssilvl);\r\nif (ret != 0)\r\nreturn ret;\r\nstrcpy(tuner->name, "FM");\r\ntuner->type = V4L2_TUNER_RADIO;\r\ntuner->rangelow = bottom_freq * 16;\r\ntuner->rangehigh = top_freq * 16;\r\ntuner->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO |\r\n((fmdev->rx.rds.flag == FM_RDS_ENABLE) ? V4L2_TUNER_SUB_RDS : 0);\r\ntuner->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |\r\nV4L2_TUNER_CAP_LOW |\r\nV4L2_TUNER_CAP_HWSEEK_BOUNDED |\r\nV4L2_TUNER_CAP_HWSEEK_WRAP;\r\ntuner->audmode = (stereo_mono_mode ?\r\nV4L2_TUNER_MODE_MONO : V4L2_TUNER_MODE_STEREO);\r\nrssilvl += 128;\r\ntuner->signal = rssilvl * 257;\r\ntuner->afc = 0;\r\nreturn ret;\r\n}\r\nstatic int fm_v4l2_vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *tuner)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nu16 aud_mode;\r\nu8 rds_mode;\r\nint ret;\r\nif (tuner->index != 0)\r\nreturn -EINVAL;\r\naud_mode = (tuner->audmode == V4L2_TUNER_MODE_STEREO) ?\r\nFM_STEREO_MODE : FM_MONO_MODE;\r\nrds_mode = (tuner->rxsubchans & V4L2_TUNER_SUB_RDS) ?\r\nFM_RDS_ENABLE : FM_RDS_DISABLE;\r\nif (fmdev->curr_fmmode != FM_MODE_RX) {\r\nret = fmc_set_mode(fmdev, FM_MODE_RX);\r\nif (ret < 0) {\r\nfmerr("Failed to set RX mode\n");\r\nreturn ret;\r\n}\r\n}\r\nret = fmc_set_stereo_mono(fmdev, aud_mode);\r\nif (ret < 0) {\r\nfmerr("Failed to set RX stereo/mono mode\n");\r\nreturn ret;\r\n}\r\nret = fmc_set_rds_mode(fmdev, rds_mode);\r\nif (ret < 0)\r\nfmerr("Failed to set RX RDS mode\n");\r\nreturn ret;\r\n}\r\nstatic int fm_v4l2_vidioc_g_freq(struct file *file, void *priv,\r\nstruct v4l2_frequency *freq)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nint ret;\r\nret = fmc_get_freq(fmdev, &freq->frequency);\r\nif (ret < 0) {\r\nfmerr("Failed to get frequency\n");\r\nreturn ret;\r\n}\r\nfreq->frequency = (u32) freq->frequency * 16;\r\nreturn 0;\r\n}\r\nstatic int fm_v4l2_vidioc_s_freq(struct file *file, void *priv,\r\nconst struct v4l2_frequency *freq)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nreturn fmc_set_freq(fmdev, freq->frequency / 16);\r\n}\r\nstatic int fm_v4l2_vidioc_s_hw_freq_seek(struct file *file, void *priv,\r\nconst struct v4l2_hw_freq_seek *seek)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nint ret;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nif (fmdev->curr_fmmode != FM_MODE_RX) {\r\nret = fmc_set_mode(fmdev, FM_MODE_RX);\r\nif (ret != 0) {\r\nfmerr("Failed to set RX mode\n");\r\nreturn ret;\r\n}\r\n}\r\nret = fm_rx_seek(fmdev, seek->seek_upward, seek->wrap_around,\r\nseek->spacing);\r\nif (ret < 0)\r\nfmerr("RX seek failed - %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int fm_v4l2_vidioc_g_modulator(struct file *file, void *priv,\r\nstruct v4l2_modulator *mod)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nif (mod->index != 0)\r\nreturn -EINVAL;\r\nif (fmdev->curr_fmmode != FM_MODE_TX)\r\nreturn -EPERM;\r\nmod->txsubchans = ((fmdev->tx_data.aud_mode == FM_STEREO_MODE) ?\r\nV4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO) |\r\n((fmdev->tx_data.rds.flag == FM_RDS_ENABLE) ?\r\nV4L2_TUNER_SUB_RDS : 0);\r\nmod->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS |\r\nV4L2_TUNER_CAP_LOW;\r\nreturn 0;\r\n}\r\nstatic int fm_v4l2_vidioc_s_modulator(struct file *file, void *priv,\r\nconst struct v4l2_modulator *mod)\r\n{\r\nstruct fmdev *fmdev = video_drvdata(file);\r\nu8 rds_mode;\r\nu16 aud_mode;\r\nint ret;\r\nif (mod->index != 0)\r\nreturn -EINVAL;\r\nif (fmdev->curr_fmmode != FM_MODE_TX) {\r\nret = fmc_set_mode(fmdev, FM_MODE_TX);\r\nif (ret != 0) {\r\nfmerr("Failed to set TX mode\n");\r\nreturn ret;\r\n}\r\n}\r\naud_mode = (mod->txsubchans & V4L2_TUNER_SUB_STEREO) ?\r\nFM_STEREO_MODE : FM_MONO_MODE;\r\nrds_mode = (mod->txsubchans & V4L2_TUNER_SUB_RDS) ?\r\nFM_RDS_ENABLE : FM_RDS_DISABLE;\r\nret = fm_tx_set_stereo_mono(fmdev, aud_mode);\r\nif (ret < 0) {\r\nfmerr("Failed to set mono/stereo mode for TX\n");\r\nreturn ret;\r\n}\r\nret = fm_tx_set_rds_mode(fmdev, rds_mode);\r\nif (ret < 0)\r\nfmerr("Failed to set rds mode for TX\n");\r\nreturn ret;\r\n}\r\nint fm_v4l2_init_video_device(struct fmdev *fmdev, int radio_nr)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nint ret;\r\nstrlcpy(fmdev->v4l2_dev.name, FM_DRV_NAME, sizeof(fmdev->v4l2_dev.name));\r\nret = v4l2_device_register(NULL, &fmdev->v4l2_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&fmdev->mutex);\r\ngradio_dev = fm_viddev_template;\r\nvideo_set_drvdata(&gradio_dev, fmdev);\r\ngradio_dev.lock = &fmdev->mutex;\r\ngradio_dev.v4l2_dev = &fmdev->v4l2_dev;\r\nif (video_register_device(&gradio_dev, VFL_TYPE_RADIO, radio_nr)) {\r\nfmerr("Could not register video device\n");\r\nreturn -ENOMEM;\r\n}\r\nfmdev->radio_dev = &gradio_dev;\r\nfmdev->radio_dev->ctrl_handler = &fmdev->ctrl_handler;\r\nret = v4l2_ctrl_handler_init(&fmdev->ctrl_handler, 5);\r\nif (ret < 0) {\r\nfmerr("(fmdev): Can't init ctrl handler\n");\r\nv4l2_ctrl_handler_free(&fmdev->ctrl_handler);\r\nreturn -EBUSY;\r\n}\r\nv4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, FM_RX_VOLUME_MIN,\r\nFM_RX_VOLUME_MAX, 1, FM_RX_VOLUME_MAX);\r\nv4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nv4l2_ctrl_new_std_menu(&fmdev->ctrl_handler, &fm_ctrl_ops,\r\nV4L2_CID_TUNE_PREEMPHASIS, V4L2_PREEMPHASIS_75_uS,\r\n0, V4L2_PREEMPHASIS_75_uS);\r\nv4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\r\nV4L2_CID_TUNE_POWER_LEVEL, FM_PWR_LVL_LOW,\r\nFM_PWR_LVL_HIGH, 1, FM_PWR_LVL_HIGH);\r\nctrl = v4l2_ctrl_new_std(&fmdev->ctrl_handler, &fm_ctrl_ops,\r\nV4L2_CID_TUNE_ANTENNA_CAPACITOR, 0,\r\n255, 1, 255);\r\nif (ctrl)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nreturn 0;\r\n}\r\nvoid *fm_v4l2_deinit_video_device(void)\r\n{\r\nstruct fmdev *fmdev;\r\nfmdev = video_get_drvdata(&gradio_dev);\r\nv4l2_ctrl_handler_free(&fmdev->ctrl_handler);\r\nvideo_unregister_device(&gradio_dev);\r\nv4l2_device_unregister(&fmdev->v4l2_dev);\r\nreturn fmdev;\r\n}
