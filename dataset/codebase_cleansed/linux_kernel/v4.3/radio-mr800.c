static inline struct amradio_device *to_amradio_dev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct amradio_device, v4l2_dev);\r\n}\r\nstatic int amradio_send_cmd(struct amradio_device *radio, u8 cmd, u8 arg,\r\nu8 *extra, u8 extralen, bool reply)\r\n{\r\nint retval;\r\nint size;\r\nradio->buffer[0] = 0x00;\r\nradio->buffer[1] = 0x55;\r\nradio->buffer[2] = 0xaa;\r\nradio->buffer[3] = extralen;\r\nradio->buffer[4] = cmd;\r\nradio->buffer[5] = arg;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = extra || reply ? 8 : 0;\r\nretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\r\nradio->buffer, BUFFER_LENGTH, &size, USB_TIMEOUT);\r\nif (retval < 0 || size != BUFFER_LENGTH) {\r\nif (video_is_registered(&radio->vdev))\r\namradio_dev_warn(&radio->vdev.dev,\r\n"cmd %02x failed\n", cmd);\r\nreturn retval ? retval : -EIO;\r\n}\r\nif (!extra && !reply)\r\nreturn 0;\r\nif (extra) {\r\nmemcpy(radio->buffer, extra, extralen);\r\nmemset(radio->buffer + extralen, 0, 8 - extralen);\r\nretval = usb_bulk_msg(radio->usbdev, usb_sndintpipe(radio->usbdev, 2),\r\nradio->buffer, BUFFER_LENGTH, &size, USB_TIMEOUT);\r\n} else {\r\nmemset(radio->buffer, 0, 8);\r\nretval = usb_bulk_msg(radio->usbdev, usb_rcvbulkpipe(radio->usbdev, 0x81),\r\nradio->buffer, BUFFER_LENGTH, &size, USB_TIMEOUT);\r\n}\r\nif (retval == 0 && size == BUFFER_LENGTH)\r\nreturn 0;\r\nif (video_is_registered(&radio->vdev) && cmd != AMRADIO_GET_READY_FLAG)\r\namradio_dev_warn(&radio->vdev.dev, "follow-up to cmd %02x failed\n", cmd);\r\nreturn retval ? retval : -EIO;\r\n}\r\nstatic int amradio_set_mute(struct amradio_device *radio, bool mute)\r\n{\r\nint ret = amradio_send_cmd(radio,\r\nAMRADIO_SET_MUTE, mute, NULL, 0, false);\r\nif (!ret)\r\nradio->muted = mute;\r\nreturn ret;\r\n}\r\nstatic int amradio_set_freq(struct amradio_device *radio, int freq)\r\n{\r\nunsigned short freq_send;\r\nu8 buf[3];\r\nint retval;\r\nfreq = clamp_t(unsigned, freq, FREQ_MIN * FREQ_MUL, FREQ_MAX * FREQ_MUL);\r\nfreq_send = 0x10 + (freq >> 3) / 25;\r\nbuf[0] = (freq_send >> 8) & 0xff;\r\nbuf[1] = freq_send & 0xff;\r\nbuf[2] = 0x01;\r\nretval = amradio_send_cmd(radio, AMRADIO_SET_FREQ, 0, buf, 3, false);\r\nif (retval)\r\nreturn retval;\r\nradio->curfreq = freq;\r\nmsleep(40);\r\nreturn 0;\r\n}\r\nstatic int amradio_set_stereo(struct amradio_device *radio, bool stereo)\r\n{\r\nint ret = amradio_send_cmd(radio,\r\nAMRADIO_SET_MONO, !stereo, NULL, 0, false);\r\nif (!ret)\r\nradio->stereo = stereo;\r\nreturn ret;\r\n}\r\nstatic int amradio_get_stat(struct amradio_device *radio, bool *is_stereo, u32 *signal)\r\n{\r\nint ret = amradio_send_cmd(radio,\r\nAMRADIO_GET_SIGNAL, 0, NULL, 0, true);\r\nif (ret)\r\nreturn ret;\r\n*is_stereo = radio->buffer[2] >> 7;\r\n*signal = (radio->buffer[3] & 0xf0) << 8;\r\nreturn 0;\r\n}\r\nstatic void usb_amradio_disconnect(struct usb_interface *intf)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\nvideo_unregister_device(&radio->vdev);\r\namradio_set_mute(radio, true);\r\nusb_set_intfdata(intf, NULL);\r\nv4l2_device_disconnect(&radio->v4l2_dev);\r\nmutex_unlock(&radio->lock);\r\nv4l2_device_put(&radio->v4l2_dev);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct amradio_device *radio = video_drvdata(file);\r\nstrlcpy(v->driver, "radio-mr800", sizeof(v->driver));\r\nstrlcpy(v->card, "AverMedia MR 800 USB FM Radio", sizeof(v->card));\r\nusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER |\r\nV4L2_CAP_HW_FREQ_SEEK;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct amradio_device *radio = video_drvdata(file);\r\nbool is_stereo = false;\r\nint retval;\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nv->signal = 0;\r\nretval = amradio_get_stat(radio, &is_stereo, &v->signal);\r\nif (retval)\r\nreturn retval;\r\nstrcpy(v->name, "FM");\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = FREQ_MIN * FREQ_MUL;\r\nv->rangehigh = FREQ_MAX * FREQ_MUL;\r\nv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_HWSEEK_WRAP;\r\nv->rxsubchans = is_stereo ? V4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\r\nv->audmode = radio->stereo ?\r\nV4L2_TUNER_MODE_STEREO : V4L2_TUNER_MODE_MONO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct amradio_device *radio = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nswitch (v->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nreturn amradio_set_stereo(radio, WANT_MONO);\r\ndefault:\r\nreturn amradio_set_stereo(radio, WANT_STEREO);\r\n}\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct amradio_device *radio = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nreturn amradio_set_freq(radio, f->frequency);\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct amradio_device *radio = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = radio->curfreq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_hw_freq_seek(struct file *file, void *priv,\r\nconst struct v4l2_hw_freq_seek *seek)\r\n{\r\nstatic u8 buf[8] = {\r\n0x3d, 0x32, 0x0f, 0x08, 0x3d, 0x32, 0x0f, 0x08\r\n};\r\nstruct amradio_device *radio = video_drvdata(file);\r\nunsigned long timeout;\r\nint retval;\r\nif (seek->tuner != 0 || !seek->wrap_around)\r\nreturn -EINVAL;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EWOULDBLOCK;\r\nretval = amradio_send_cmd(radio,\r\nAMRADIO_SET_SEARCH_LVL, 0, buf, 8, false);\r\nif (retval)\r\nreturn retval;\r\namradio_set_freq(radio, radio->curfreq);\r\nretval = amradio_send_cmd(radio,\r\nseek->seek_upward ? AMRADIO_SET_SEARCH_UP : AMRADIO_SET_SEARCH_DOWN,\r\n0, NULL, 0, false);\r\nif (retval)\r\nreturn retval;\r\ntimeout = jiffies + msecs_to_jiffies(30000);\r\nfor (;;) {\r\nif (time_after(jiffies, timeout)) {\r\nretval = -ENODATA;\r\nbreak;\r\n}\r\nif (schedule_timeout_interruptible(msecs_to_jiffies(10))) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nretval = amradio_send_cmd(radio, AMRADIO_GET_READY_FLAG,\r\n0, NULL, 0, true);\r\nif (retval)\r\ncontinue;\r\namradio_send_cmd(radio, AMRADIO_GET_FREQ, 0, NULL, 0, true);\r\nif (radio->buffer[1] || radio->buffer[2]) {\r\nradio->curfreq = (radio->buffer[1] << 8) | radio->buffer[2];\r\nradio->curfreq = (radio->curfreq - 0x10) * 200;\r\namradio_send_cmd(radio, AMRADIO_STOP_SEARCH,\r\n0, NULL, 0, false);\r\namradio_set_freq(radio, radio->curfreq);\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\namradio_send_cmd(radio, AMRADIO_STOP_SEARCH, 0, NULL, 0, false);\r\namradio_set_freq(radio, radio->curfreq);\r\nreturn retval;\r\n}\r\nstatic int usb_amradio_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct amradio_device *radio =\r\ncontainer_of(ctrl->handler, struct amradio_device, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nreturn amradio_set_mute(radio, ctrl->val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int usb_amradio_init(struct amradio_device *radio)\r\n{\r\nint retval;\r\nretval = amradio_set_mute(radio, true);\r\nif (retval)\r\ngoto out_err;\r\nretval = amradio_set_stereo(radio, true);\r\nif (retval)\r\ngoto out_err;\r\nretval = amradio_set_freq(radio, radio->curfreq);\r\nif (retval)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\namradio_dev_err(&radio->vdev.dev, "initialization failed\n");\r\nreturn retval;\r\n}\r\nstatic int usb_amradio_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\nif (!radio->muted) {\r\namradio_set_mute(radio, true);\r\nradio->muted = false;\r\n}\r\nmutex_unlock(&radio->lock);\r\ndev_info(&intf->dev, "going into suspend..\n");\r\nreturn 0;\r\n}\r\nstatic int usb_amradio_resume(struct usb_interface *intf)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\namradio_set_stereo(radio, radio->stereo);\r\namradio_set_freq(radio, radio->curfreq);\r\nif (!radio->muted)\r\namradio_set_mute(radio, false);\r\nmutex_unlock(&radio->lock);\r\ndev_info(&intf->dev, "coming out of suspend..\n");\r\nreturn 0;\r\n}\r\nstatic void usb_amradio_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct amradio_device *radio = to_amradio_dev(v4l2_dev);\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nkfree(radio->buffer);\r\nkfree(radio);\r\n}\r\nstatic int usb_amradio_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct amradio_device *radio;\r\nint retval = 0;\r\nradio = kzalloc(sizeof(struct amradio_device), GFP_KERNEL);\r\nif (!radio) {\r\ndev_err(&intf->dev, "kmalloc for amradio_device failed\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\r\nif (!radio->buffer) {\r\ndev_err(&intf->dev, "kmalloc for radio->buffer failed\n");\r\nretval = -ENOMEM;\r\ngoto err_nobuf;\r\n}\r\nretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "couldn't register v4l2_device\n");\r\ngoto err_v4l2;\r\n}\r\nv4l2_ctrl_handler_init(&radio->hdl, 1);\r\nv4l2_ctrl_new_std(&radio->hdl, &usb_amradio_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nif (radio->hdl.error) {\r\nretval = radio->hdl.error;\r\ndev_err(&intf->dev, "couldn't register control\n");\r\ngoto err_ctrl;\r\n}\r\nmutex_init(&radio->lock);\r\nradio->v4l2_dev.ctrl_handler = &radio->hdl;\r\nradio->v4l2_dev.release = usb_amradio_release;\r\nstrlcpy(radio->vdev.name, radio->v4l2_dev.name,\r\nsizeof(radio->vdev.name));\r\nradio->vdev.v4l2_dev = &radio->v4l2_dev;\r\nradio->vdev.fops = &usb_amradio_fops;\r\nradio->vdev.ioctl_ops = &usb_amradio_ioctl_ops;\r\nradio->vdev.release = video_device_release_empty;\r\nradio->vdev.lock = &radio->lock;\r\nradio->usbdev = interface_to_usbdev(intf);\r\nradio->intf = intf;\r\nusb_set_intfdata(intf, &radio->v4l2_dev);\r\nradio->curfreq = 95.16 * FREQ_MUL;\r\nvideo_set_drvdata(&radio->vdev, radio);\r\nretval = usb_amradio_init(radio);\r\nif (retval)\r\ngoto err_vdev;\r\nretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO,\r\nradio_nr);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "could not register video device\n");\r\ngoto err_vdev;\r\n}\r\nreturn 0;\r\nerr_vdev:\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nerr_ctrl:\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nerr_v4l2:\r\nkfree(radio->buffer);\r\nerr_nobuf:\r\nkfree(radio);\r\nerr:\r\nreturn retval;\r\n}
