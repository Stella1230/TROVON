static inline void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)\r\n{\r\nvoid *src = out ? buf : sgdata;\r\nvoid *dst = out ? sgdata : buf;\r\nmemcpy(dst, src, nbytes);\r\n}\r\nvoid scatterwalk_start(struct scatter_walk *walk, struct scatterlist *sg)\r\n{\r\nwalk->sg = sg;\r\nBUG_ON(!sg->length);\r\nwalk->offset = sg->offset;\r\n}\r\nvoid *scatterwalk_map(struct scatter_walk *walk)\r\n{\r\nreturn kmap_atomic(scatterwalk_page(walk)) +\r\noffset_in_page(walk->offset);\r\n}\r\nstatic void scatterwalk_pagedone(struct scatter_walk *walk, int out,\r\nunsigned int more)\r\n{\r\nif (out) {\r\nstruct page *page;\r\npage = sg_page(walk->sg) + ((walk->offset - 1) >> PAGE_SHIFT);\r\nif (ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE && !PageSlab(page))\r\nflush_dcache_page(page);\r\n}\r\nif (more) {\r\nwalk->offset += PAGE_SIZE - 1;\r\nwalk->offset &= PAGE_MASK;\r\nif (walk->offset >= walk->sg->offset + walk->sg->length)\r\nscatterwalk_start(walk, sg_next(walk->sg));\r\n}\r\n}\r\nvoid scatterwalk_done(struct scatter_walk *walk, int out, int more)\r\n{\r\nif (!(scatterwalk_pagelen(walk) & (PAGE_SIZE - 1)) || !more)\r\nscatterwalk_pagedone(walk, out, more);\r\n}\r\nvoid scatterwalk_copychunks(void *buf, struct scatter_walk *walk,\r\nsize_t nbytes, int out)\r\n{\r\nfor (;;) {\r\nunsigned int len_this_page = scatterwalk_pagelen(walk);\r\nu8 *vaddr;\r\nif (len_this_page > nbytes)\r\nlen_this_page = nbytes;\r\nvaddr = scatterwalk_map(walk);\r\nmemcpy_dir(buf, vaddr, len_this_page, out);\r\nscatterwalk_unmap(vaddr);\r\nscatterwalk_advance(walk, len_this_page);\r\nif (nbytes == len_this_page)\r\nbreak;\r\nbuf += len_this_page;\r\nnbytes -= len_this_page;\r\nscatterwalk_pagedone(walk, out, 1);\r\n}\r\n}\r\nvoid scatterwalk_map_and_copy(void *buf, struct scatterlist *sg,\r\nunsigned int start, unsigned int nbytes, int out)\r\n{\r\nstruct scatter_walk walk;\r\nstruct scatterlist tmp[2];\r\nif (!nbytes)\r\nreturn;\r\nsg = scatterwalk_ffwd(tmp, sg, start);\r\nif (sg_page(sg) == virt_to_page(buf) &&\r\nsg->offset == offset_in_page(buf))\r\nreturn;\r\nscatterwalk_start(&walk, sg);\r\nscatterwalk_copychunks(buf, &walk, nbytes, out);\r\nscatterwalk_done(&walk, out, 0);\r\n}\r\nint scatterwalk_bytes_sglen(struct scatterlist *sg, int num_bytes)\r\n{\r\nint offset = 0, n = 0;\r\nif (num_bytes < sg->length)\r\nreturn -1;\r\ndo {\r\noffset += sg->length;\r\nn++;\r\nsg = sg_next(sg);\r\nif (unlikely(!sg && (num_bytes < offset)))\r\nreturn -1;\r\n} while (sg && (num_bytes > offset));\r\nreturn n;\r\n}\r\nstruct scatterlist *scatterwalk_ffwd(struct scatterlist dst[2],\r\nstruct scatterlist *src,\r\nunsigned int len)\r\n{\r\nfor (;;) {\r\nif (!len)\r\nreturn src;\r\nif (src->length > len)\r\nbreak;\r\nlen -= src->length;\r\nsrc = sg_next(src);\r\n}\r\nsg_init_table(dst, 2);\r\nsg_set_page(dst, sg_page(src), src->length - len, src->offset + len);\r\nscatterwalk_crypto_chain(dst, sg_next(src), 0, 2);\r\nreturn dst;\r\n}
