static struct bcap_buffer *to_bcap_vb(struct vb2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct bcap_buffer, vb);\r\n}\r\nstatic int bcap_init_sensor_formats(struct bcap_device *bcap_dev)\r\n{\r\nstruct v4l2_subdev_mbus_code_enum code = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct bcap_format *sf;\r\nunsigned int num_formats = 0;\r\nint i, j;\r\nwhile (!v4l2_subdev_call(bcap_dev->sd, pad,\r\nenum_mbus_code, NULL, &code)) {\r\nnum_formats++;\r\ncode.index++;\r\n}\r\nif (!num_formats)\r\nreturn -ENXIO;\r\nsf = kzalloc(num_formats * sizeof(*sf), GFP_KERNEL);\r\nif (!sf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_formats; i++) {\r\ncode.index = i;\r\nv4l2_subdev_call(bcap_dev->sd, pad,\r\nenum_mbus_code, NULL, &code);\r\nfor (j = 0; j < BCAP_MAX_FMTS; j++)\r\nif (code.code == bcap_formats[j].mbus_code)\r\nbreak;\r\nif (j == BCAP_MAX_FMTS) {\r\nkfree(sf);\r\nreturn -EINVAL;\r\n}\r\nsf[i] = bcap_formats[j];\r\n}\r\nbcap_dev->sensor_formats = sf;\r\nbcap_dev->num_sensor_formats = num_formats;\r\nreturn 0;\r\n}\r\nstatic void bcap_free_sensor_formats(struct bcap_device *bcap_dev)\r\n{\r\nbcap_dev->num_sensor_formats = 0;\r\nkfree(bcap_dev->sensor_formats);\r\nbcap_dev->sensor_formats = NULL;\r\n}\r\nstatic int bcap_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct bcap_device *bcap_dev = vb2_get_drv_priv(vq);\r\nif (fmt && fmt->fmt.pix.sizeimage < bcap_dev->fmt.sizeimage)\r\nreturn -EINVAL;\r\nif (vq->num_buffers + *nbuffers < 2)\r\n*nbuffers = 2;\r\n*nplanes = 1;\r\nsizes[0] = fmt ? fmt->fmt.pix.sizeimage : bcap_dev->fmt.sizeimage;\r\nalloc_ctxs[0] = bcap_dev->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic int bcap_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct bcap_device *bcap_dev = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size = bcap_dev->fmt.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\nv4l2_err(&bcap_dev->v4l2_dev, "buffer too small (%lu < %lu)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nvb->v4l2_buf.field = bcap_dev->fmt.field;\r\nreturn 0;\r\n}\r\nstatic void bcap_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct bcap_device *bcap_dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct bcap_buffer *buf = to_bcap_vb(vb);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bcap_dev->lock, flags);\r\nlist_add_tail(&buf->list, &bcap_dev->dma_queue);\r\nspin_unlock_irqrestore(&bcap_dev->lock, flags);\r\n}\r\nstatic void bcap_buffer_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct bcap_device *bcap_dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct bcap_buffer *buf = to_bcap_vb(vb);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bcap_dev->lock, flags);\r\nlist_del_init(&buf->list);\r\nspin_unlock_irqrestore(&bcap_dev->lock, flags);\r\n}\r\nstatic int bcap_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct bcap_device *bcap_dev = vb2_get_drv_priv(vq);\r\nstruct ppi_if *ppi = bcap_dev->ppi;\r\nstruct bcap_buffer *buf, *tmp;\r\nstruct ppi_params params;\r\ndma_addr_t addr;\r\nint ret;\r\nret = v4l2_subdev_call(bcap_dev->sd, video, s_stream, 1);\r\nif (ret && (ret != -ENOIOCTLCMD)) {\r\nv4l2_err(&bcap_dev->v4l2_dev, "stream on failed in subdev\n");\r\ngoto err;\r\n}\r\nparams.width = bcap_dev->fmt.width;\r\nparams.height = bcap_dev->fmt.height;\r\nparams.bpp = bcap_dev->bpp;\r\nparams.dlen = bcap_dev->dlen;\r\nparams.ppi_control = bcap_dev->cfg->ppi_control;\r\nparams.int_mask = bcap_dev->cfg->int_mask;\r\nif (bcap_dev->cfg->inputs[bcap_dev->cur_input].capabilities\r\n& V4L2_IN_CAP_DV_TIMINGS) {\r\nstruct v4l2_bt_timings *bt = &bcap_dev->dv_timings.bt;\r\nparams.hdelay = bt->hsync + bt->hbackporch;\r\nparams.vdelay = bt->vsync + bt->vbackporch;\r\nparams.line = V4L2_DV_BT_FRAME_WIDTH(bt);\r\nparams.frame = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\n} else if (bcap_dev->cfg->inputs[bcap_dev->cur_input].capabilities\r\n& V4L2_IN_CAP_STD) {\r\nparams.hdelay = 0;\r\nparams.vdelay = 0;\r\nif (bcap_dev->std & V4L2_STD_525_60) {\r\nparams.line = 858;\r\nparams.frame = 525;\r\n} else {\r\nparams.line = 864;\r\nparams.frame = 625;\r\n}\r\n} else {\r\nparams.hdelay = 0;\r\nparams.vdelay = 0;\r\nparams.line = params.width + bcap_dev->cfg->blank_pixels;\r\nparams.frame = params.height;\r\n}\r\nret = ppi->ops->set_params(ppi, &params);\r\nif (ret < 0) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Error in setting ppi params\n");\r\ngoto err;\r\n}\r\nret = ppi->ops->attach_irq(ppi, bcap_isr);\r\nif (ret < 0) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Error in attaching interrupt handler\n");\r\ngoto err;\r\n}\r\nbcap_dev->sequence = 0;\r\nreinit_completion(&bcap_dev->comp);\r\nbcap_dev->stop = false;\r\nbcap_dev->cur_frm = list_entry(bcap_dev->dma_queue.next,\r\nstruct bcap_buffer, list);\r\nlist_del_init(&bcap_dev->cur_frm->list);\r\naddr = vb2_dma_contig_plane_dma_addr(&bcap_dev->cur_frm->vb, 0);\r\nppi->ops->update_addr(ppi, (unsigned long)addr);\r\nppi->ops->start(ppi);\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_safe(buf, tmp, &bcap_dev->dma_queue, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bcap_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct bcap_device *bcap_dev = vb2_get_drv_priv(vq);\r\nstruct ppi_if *ppi = bcap_dev->ppi;\r\nint ret;\r\nbcap_dev->stop = true;\r\nwait_for_completion(&bcap_dev->comp);\r\nppi->ops->stop(ppi);\r\nppi->ops->detach_irq(ppi);\r\nret = v4l2_subdev_call(bcap_dev->sd, video, s_stream, 0);\r\nif (ret && (ret != -ENOIOCTLCMD))\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"stream off failed in subdev\n");\r\nif (bcap_dev->cur_frm)\r\nvb2_buffer_done(&bcap_dev->cur_frm->vb, VB2_BUF_STATE_ERROR);\r\nwhile (!list_empty(&bcap_dev->dma_queue)) {\r\nbcap_dev->cur_frm = list_entry(bcap_dev->dma_queue.next,\r\nstruct bcap_buffer, list);\r\nlist_del_init(&bcap_dev->cur_frm->list);\r\nvb2_buffer_done(&bcap_dev->cur_frm->vb, VB2_BUF_STATE_ERROR);\r\n}\r\n}\r\nstatic irqreturn_t bcap_isr(int irq, void *dev_id)\r\n{\r\nstruct ppi_if *ppi = dev_id;\r\nstruct bcap_device *bcap_dev = ppi->priv;\r\nstruct vb2_buffer *vb = &bcap_dev->cur_frm->vb;\r\ndma_addr_t addr;\r\nspin_lock(&bcap_dev->lock);\r\nif (!list_empty(&bcap_dev->dma_queue)) {\r\nv4l2_get_timestamp(&vb->v4l2_buf.timestamp);\r\nif (ppi->err) {\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\nppi->err = false;\r\n} else {\r\nvb->v4l2_buf.sequence = bcap_dev->sequence++;\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\n}\r\nbcap_dev->cur_frm = list_entry(bcap_dev->dma_queue.next,\r\nstruct bcap_buffer, list);\r\nlist_del_init(&bcap_dev->cur_frm->list);\r\n} else {\r\nif (ppi->err)\r\nppi->err = false;\r\n}\r\nppi->ops->stop(ppi);\r\nif (bcap_dev->stop) {\r\ncomplete(&bcap_dev->comp);\r\n} else {\r\naddr = vb2_dma_contig_plane_dma_addr(&bcap_dev->cur_frm->vb, 0);\r\nppi->ops->update_addr(ppi, (unsigned long)addr);\r\nppi->ops->start(ppi);\r\n}\r\nspin_unlock(&bcap_dev->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcap_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_STD))\r\nreturn -ENODATA;\r\nreturn v4l2_subdev_call(bcap_dev->sd, video, querystd, std);\r\n}\r\nstatic int bcap_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_STD))\r\nreturn -ENODATA;\r\n*std = bcap_dev->std;\r\nreturn 0;\r\n}\r\nstatic int bcap_s_std(struct file *file, void *priv, v4l2_std_id std)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\nint ret;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_STD))\r\nreturn -ENODATA;\r\nif (vb2_is_busy(&bcap_dev->buffer_queue))\r\nreturn -EBUSY;\r\nret = v4l2_subdev_call(bcap_dev->sd, video, s_std, std);\r\nif (ret < 0)\r\nreturn ret;\r\nbcap_dev->std = std;\r\nreturn 0;\r\n}\r\nstatic int bcap_enum_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_DV_TIMINGS))\r\nreturn -ENODATA;\r\ntimings->pad = 0;\r\nreturn v4l2_subdev_call(bcap_dev->sd, pad,\r\nenum_dv_timings, timings);\r\n}\r\nstatic int bcap_query_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_DV_TIMINGS))\r\nreturn -ENODATA;\r\nreturn v4l2_subdev_call(bcap_dev->sd, video,\r\nquery_dv_timings, timings);\r\n}\r\nstatic int bcap_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_DV_TIMINGS))\r\nreturn -ENODATA;\r\n*timings = bcap_dev->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int bcap_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_input input;\r\nint ret;\r\ninput = bcap_dev->cfg->inputs[bcap_dev->cur_input];\r\nif (!(input.capabilities & V4L2_IN_CAP_DV_TIMINGS))\r\nreturn -ENODATA;\r\nif (vb2_is_busy(&bcap_dev->buffer_queue))\r\nreturn -EBUSY;\r\nret = v4l2_subdev_call(bcap_dev->sd, video, s_dv_timings, timings);\r\nif (ret < 0)\r\nreturn ret;\r\nbcap_dev->dv_timings = *timings;\r\nreturn 0;\r\n}\r\nstatic int bcap_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct bfin_capture_config *config = bcap_dev->cfg;\r\nint ret;\r\nu32 status;\r\nif (input->index >= config->num_inputs)\r\nreturn -EINVAL;\r\n*input = config->inputs[input->index];\r\nret = v4l2_subdev_call(bcap_dev->sd, video, g_input_status, &status);\r\nif (!ret)\r\ninput->status = status;\r\nreturn 0;\r\n}\r\nstatic int bcap_g_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\n*index = bcap_dev->cur_input;\r\nreturn 0;\r\n}\r\nstatic int bcap_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct bfin_capture_config *config = bcap_dev->cfg;\r\nstruct bcap_route *route;\r\nint ret;\r\nif (vb2_is_busy(&bcap_dev->buffer_queue))\r\nreturn -EBUSY;\r\nif (index >= config->num_inputs)\r\nreturn -EINVAL;\r\nroute = &config->routes[index];\r\nret = v4l2_subdev_call(bcap_dev->sd, video, s_routing,\r\nroute->input, route->output, 0);\r\nif ((ret < 0) && (ret != -ENOIOCTLCMD)) {\r\nv4l2_err(&bcap_dev->v4l2_dev, "Failed to set input\n");\r\nreturn ret;\r\n}\r\nbcap_dev->cur_input = index;\r\nif (route->ppi_control)\r\nconfig->ppi_control = route->ppi_control;\r\nreturn 0;\r\n}\r\nstatic int bcap_try_format(struct bcap_device *bcap,\r\nstruct v4l2_pix_format *pixfmt,\r\nstruct bcap_format *bcap_fmt)\r\n{\r\nstruct bcap_format *sf = bcap->sensor_formats;\r\nstruct bcap_format *fmt = NULL;\r\nstruct v4l2_subdev_pad_config pad_cfg;\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_TRY,\r\n};\r\nint ret, i;\r\nfor (i = 0; i < bcap->num_sensor_formats; i++) {\r\nfmt = &sf[i];\r\nif (pixfmt->pixelformat == fmt->pixelformat)\r\nbreak;\r\n}\r\nif (i == bcap->num_sensor_formats)\r\nfmt = &sf[0];\r\nv4l2_fill_mbus_format(&format.format, pixfmt, fmt->mbus_code);\r\nret = v4l2_subdev_call(bcap->sd, pad, set_fmt, &pad_cfg,\r\n&format);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_fill_pix_format(pixfmt, &format.format);\r\nif (bcap_fmt) {\r\nfor (i = 0; i < bcap->num_sensor_formats; i++) {\r\nfmt = &sf[i];\r\nif (format.format.code == fmt->mbus_code)\r\nbreak;\r\n}\r\n*bcap_fmt = *fmt;\r\n}\r\npixfmt->bytesperline = pixfmt->width * fmt->bpp / 8;\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\r\nreturn 0;\r\n}\r\nstatic int bcap_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct bcap_format *sf = bcap_dev->sensor_formats;\r\nif (fmt->index >= bcap_dev->num_sensor_formats)\r\nreturn -EINVAL;\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nstrlcpy(fmt->description,\r\nsf[fmt->index].desc,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = sf[fmt->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int bcap_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nreturn bcap_try_format(bcap_dev, pixfmt, NULL);\r\n}\r\nstatic int bcap_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nfmt->fmt.pix = bcap_dev->fmt;\r\nreturn 0;\r\n}\r\nstatic int bcap_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nstruct v4l2_subdev_format format = {\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nstruct bcap_format bcap_fmt;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nint ret;\r\nif (vb2_is_busy(&bcap_dev->buffer_queue))\r\nreturn -EBUSY;\r\nret = bcap_try_format(bcap_dev, pixfmt, &bcap_fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_fill_mbus_format(&format.format, pixfmt, bcap_fmt.mbus_code);\r\nret = v4l2_subdev_call(bcap_dev->sd, pad, set_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn ret;\r\nbcap_dev->fmt = *pixfmt;\r\nbcap_dev->bpp = bcap_fmt.bpp;\r\nbcap_dev->dlen = bcap_fmt.dlen;\r\nreturn 0;\r\n}\r\nstatic int bcap_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nstrlcpy(cap->driver, CAPTURE_DRV_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "Blackfin Platform", sizeof(cap->bus_info));\r\nstrlcpy(cap->card, bcap_dev->cfg->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int bcap_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(bcap_dev->sd, video, g_parm, a);\r\n}\r\nstatic int bcap_s_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nreturn v4l2_subdev_call(bcap_dev->sd, video, s_parm, a);\r\n}\r\nstatic int bcap_log_status(struct file *file, void *priv)\r\n{\r\nstruct bcap_device *bcap_dev = video_drvdata(file);\r\nv4l2_device_call_all(&bcap_dev->v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int bcap_probe(struct platform_device *pdev)\r\n{\r\nstruct bcap_device *bcap_dev;\r\nstruct video_device *vfd;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct bfin_capture_config *config;\r\nstruct vb2_queue *q;\r\nstruct bcap_route *route;\r\nint ret;\r\nconfig = pdev->dev.platform_data;\r\nif (!config || !config->num_inputs) {\r\nv4l2_err(pdev->dev.driver, "Unable to get board config\n");\r\nreturn -ENODEV;\r\n}\r\nbcap_dev = kzalloc(sizeof(*bcap_dev), GFP_KERNEL);\r\nif (!bcap_dev) {\r\nv4l2_err(pdev->dev.driver, "Unable to alloc bcap_dev\n");\r\nreturn -ENOMEM;\r\n}\r\nbcap_dev->cfg = config;\r\nbcap_dev->ppi = ppi_create_instance(pdev, config->ppi_info);\r\nif (!bcap_dev->ppi) {\r\nv4l2_err(pdev->dev.driver, "Unable to create ppi\n");\r\nret = -ENODEV;\r\ngoto err_free_dev;\r\n}\r\nbcap_dev->ppi->priv = bcap_dev;\r\nbcap_dev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(bcap_dev->alloc_ctx)) {\r\nret = PTR_ERR(bcap_dev->alloc_ctx);\r\ngoto err_free_ppi;\r\n}\r\nvfd = &bcap_dev->video_dev;\r\nvfd->release = video_device_release_empty;\r\nvfd->fops = &bcap_fops;\r\nvfd->ioctl_ops = &bcap_ioctl_ops;\r\nvfd->tvnorms = 0;\r\nvfd->v4l2_dev = &bcap_dev->v4l2_dev;\r\nstrncpy(vfd->name, CAPTURE_DRV_NAME, sizeof(vfd->name));\r\nret = v4l2_device_register(&pdev->dev, &bcap_dev->v4l2_dev);\r\nif (ret) {\r\nv4l2_err(pdev->dev.driver,\r\n"Unable to register v4l2 device\n");\r\ngoto err_cleanup_ctx;\r\n}\r\nv4l2_info(&bcap_dev->v4l2_dev, "v4l2 device registered\n");\r\nbcap_dev->v4l2_dev.ctrl_handler = &bcap_dev->ctrl_handler;\r\nret = v4l2_ctrl_handler_init(&bcap_dev->ctrl_handler, 0);\r\nif (ret) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to init control handler\n");\r\ngoto err_unreg_v4l2;\r\n}\r\nspin_lock_init(&bcap_dev->lock);\r\nq = &bcap_dev->buffer_queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nq->drv_priv = bcap_dev;\r\nq->buf_struct_size = sizeof(struct bcap_buffer);\r\nq->ops = &bcap_video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &bcap_dev->mutex;\r\nq->min_buffers_needed = 1;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto err_free_handler;\r\nmutex_init(&bcap_dev->mutex);\r\ninit_completion(&bcap_dev->comp);\r\nINIT_LIST_HEAD(&bcap_dev->dma_queue);\r\nvfd->lock = &bcap_dev->mutex;\r\nvfd->queue = q;\r\nret = video_register_device(&bcap_dev->video_dev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to register video device\n");\r\ngoto err_free_handler;\r\n}\r\nvideo_set_drvdata(&bcap_dev->video_dev, bcap_dev);\r\nv4l2_info(&bcap_dev->v4l2_dev, "video device registered as: %s\n",\r\nvideo_device_node_name(vfd));\r\ni2c_adap = i2c_get_adapter(config->i2c_adapter_id);\r\nif (!i2c_adap) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to find i2c adapter\n");\r\nret = -ENODEV;\r\ngoto err_unreg_vdev;\r\n}\r\nbcap_dev->sd = v4l2_i2c_new_subdev_board(&bcap_dev->v4l2_dev,\r\ni2c_adap,\r\n&config->board_info,\r\nNULL);\r\nif (bcap_dev->sd) {\r\nint i;\r\nfor (i = 0; i < config->num_inputs; i++)\r\nvfd->tvnorms |= config->inputs[i].std;\r\n} else {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to register sub device\n");\r\nret = -ENODEV;\r\ngoto err_unreg_vdev;\r\n}\r\nv4l2_info(&bcap_dev->v4l2_dev, "v4l2 sub device registered\n");\r\nroute = &config->routes[0];\r\nret = v4l2_subdev_call(bcap_dev->sd, video, s_routing,\r\nroute->input, route->output, 0);\r\nif ((ret < 0) && (ret != -ENOIOCTLCMD)) {\r\nv4l2_err(&bcap_dev->v4l2_dev, "Failed to set input\n");\r\ngoto err_unreg_vdev;\r\n}\r\nbcap_dev->cur_input = 0;\r\nif (route->ppi_control)\r\nconfig->ppi_control = route->ppi_control;\r\nif (config->inputs[0].capabilities & V4L2_IN_CAP_STD) {\r\nv4l2_std_id std;\r\nret = v4l2_subdev_call(bcap_dev->sd, video, g_std, &std);\r\nif (ret) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to get std\n");\r\ngoto err_unreg_vdev;\r\n}\r\nbcap_dev->std = std;\r\n}\r\nif (config->inputs[0].capabilities & V4L2_IN_CAP_DV_TIMINGS) {\r\nstruct v4l2_dv_timings dv_timings;\r\nret = v4l2_subdev_call(bcap_dev->sd, video,\r\ng_dv_timings, &dv_timings);\r\nif (ret) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to get dv timings\n");\r\ngoto err_unreg_vdev;\r\n}\r\nbcap_dev->dv_timings = dv_timings;\r\n}\r\nret = bcap_init_sensor_formats(bcap_dev);\r\nif (ret) {\r\nv4l2_err(&bcap_dev->v4l2_dev,\r\n"Unable to create sensor formats table\n");\r\ngoto err_unreg_vdev;\r\n}\r\nreturn 0;\r\nerr_unreg_vdev:\r\nvideo_unregister_device(&bcap_dev->video_dev);\r\nerr_free_handler:\r\nv4l2_ctrl_handler_free(&bcap_dev->ctrl_handler);\r\nerr_unreg_v4l2:\r\nv4l2_device_unregister(&bcap_dev->v4l2_dev);\r\nerr_cleanup_ctx:\r\nvb2_dma_contig_cleanup_ctx(bcap_dev->alloc_ctx);\r\nerr_free_ppi:\r\nppi_delete_instance(bcap_dev->ppi);\r\nerr_free_dev:\r\nkfree(bcap_dev);\r\nreturn ret;\r\n}\r\nstatic int bcap_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct bcap_device *bcap_dev = container_of(v4l2_dev,\r\nstruct bcap_device, v4l2_dev);\r\nbcap_free_sensor_formats(bcap_dev);\r\nvideo_unregister_device(&bcap_dev->video_dev);\r\nv4l2_ctrl_handler_free(&bcap_dev->ctrl_handler);\r\nv4l2_device_unregister(v4l2_dev);\r\nvb2_dma_contig_cleanup_ctx(bcap_dev->alloc_ctx);\r\nppi_delete_instance(bcap_dev->ppi);\r\nkfree(bcap_dev);\r\nreturn 0;\r\n}
