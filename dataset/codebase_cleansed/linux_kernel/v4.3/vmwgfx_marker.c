void vmw_marker_queue_init(struct vmw_marker_queue *queue)\r\n{\r\nINIT_LIST_HEAD(&queue->head);\r\nqueue->lag = 0;\r\nqueue->lag_time = ktime_get_raw_ns();\r\nspin_lock_init(&queue->lock);\r\n}\r\nvoid vmw_marker_queue_takedown(struct vmw_marker_queue *queue)\r\n{\r\nstruct vmw_marker *marker, *next;\r\nspin_lock(&queue->lock);\r\nlist_for_each_entry_safe(marker, next, &queue->head, head) {\r\nkfree(marker);\r\n}\r\nspin_unlock(&queue->lock);\r\n}\r\nint vmw_marker_push(struct vmw_marker_queue *queue,\r\nuint32_t seqno)\r\n{\r\nstruct vmw_marker *marker = kmalloc(sizeof(*marker), GFP_KERNEL);\r\nif (unlikely(!marker))\r\nreturn -ENOMEM;\r\nmarker->seqno = seqno;\r\nmarker->submitted = ktime_get_raw_ns();\r\nspin_lock(&queue->lock);\r\nlist_add_tail(&marker->head, &queue->head);\r\nspin_unlock(&queue->lock);\r\nreturn 0;\r\n}\r\nint vmw_marker_pull(struct vmw_marker_queue *queue,\r\nuint32_t signaled_seqno)\r\n{\r\nstruct vmw_marker *marker, *next;\r\nbool updated = false;\r\nu64 now;\r\nspin_lock(&queue->lock);\r\nnow = ktime_get_raw_ns();\r\nif (list_empty(&queue->head)) {\r\nqueue->lag = 0;\r\nqueue->lag_time = now;\r\nupdated = true;\r\ngoto out_unlock;\r\n}\r\nlist_for_each_entry_safe(marker, next, &queue->head, head) {\r\nif (signaled_seqno - marker->seqno > (1 << 30))\r\ncontinue;\r\nqueue->lag = now - marker->submitted;\r\nqueue->lag_time = now;\r\nupdated = true;\r\nlist_del(&marker->head);\r\nkfree(marker);\r\n}\r\nout_unlock:\r\nspin_unlock(&queue->lock);\r\nreturn (updated) ? 0 : -EBUSY;\r\n}\r\nstatic u64 vmw_fifo_lag(struct vmw_marker_queue *queue)\r\n{\r\nu64 now;\r\nspin_lock(&queue->lock);\r\nnow = ktime_get_raw_ns();\r\nqueue->lag += now - queue->lag_time;\r\nqueue->lag_time = now;\r\nspin_unlock(&queue->lock);\r\nreturn queue->lag;\r\n}\r\nstatic bool vmw_lag_lt(struct vmw_marker_queue *queue,\r\nuint32_t us)\r\n{\r\nu64 cond = (u64) us * NSEC_PER_USEC;\r\nreturn vmw_fifo_lag(queue) <= cond;\r\n}\r\nint vmw_wait_lag(struct vmw_private *dev_priv,\r\nstruct vmw_marker_queue *queue, uint32_t us)\r\n{\r\nstruct vmw_marker *marker;\r\nuint32_t seqno;\r\nint ret;\r\nwhile (!vmw_lag_lt(queue, us)) {\r\nspin_lock(&queue->lock);\r\nif (list_empty(&queue->head))\r\nseqno = atomic_read(&dev_priv->marker_seq);\r\nelse {\r\nmarker = list_first_entry(&queue->head,\r\nstruct vmw_marker, head);\r\nseqno = marker->seqno;\r\n}\r\nspin_unlock(&queue->lock);\r\nret = vmw_wait_seqno(dev_priv, false, seqno, true,\r\n3*HZ);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n(void) vmw_marker_pull(queue, seqno);\r\n}\r\nreturn 0;\r\n}
