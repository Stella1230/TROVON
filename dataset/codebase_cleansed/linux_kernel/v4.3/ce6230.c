static int ce6230_ctrl_msg(struct dvb_usb_device *d, struct usb_req *req)\r\n{\r\nint ret;\r\nunsigned int pipe;\r\nu8 request;\r\nu8 requesttype;\r\nu16 value;\r\nu16 index;\r\nu8 *buf;\r\nrequest = req->cmd;\r\nvalue = req->value;\r\nindex = req->index;\r\nswitch (req->cmd) {\r\ncase I2C_READ:\r\ncase DEMOD_READ:\r\ncase REG_READ:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nbreak;\r\ncase I2C_WRITE:\r\ncase DEMOD_WRITE:\r\ncase REG_WRITE:\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nbreak;\r\ndefault:\r\ndev_err(&d->udev->dev, "%s: unknown command=%02x\n",\r\nKBUILD_MODNAME, req->cmd);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbuf = kmalloc(req->data_len, GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (requesttype == (USB_TYPE_VENDOR | USB_DIR_OUT)) {\r\nmemcpy(buf, req->data, req->data_len);\r\npipe = usb_sndctrlpipe(d->udev, 0);\r\n} else {\r\npipe = usb_rcvctrlpipe(d->udev, 0);\r\n}\r\nmsleep(1);\r\nret = usb_control_msg(d->udev, pipe, request, requesttype, value, index,\r\nbuf, req->data_len, CE6230_USB_TIMEOUT);\r\ndvb_usb_dbg_usb_control_msg(d->udev, request, requesttype, value, index,\r\nbuf, req->data_len);\r\nif (ret < 0)\r\ndev_err(&d->udev->dev, "%s: usb_control_msg() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nelse\r\nret = 0;\r\nif (!ret && requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\r\nmemcpy(req->data, buf, req->data_len);\r\nkfree(buf);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int ce6230_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0, i = 0;\r\nstruct usb_req req;\r\nif (num > 2)\r\nreturn -EOPNOTSUPP;\r\nmemset(&req, 0, sizeof(req));\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\r\nif (msg[i].addr ==\r\nce6230_zl10353_config.demod_address) {\r\nreq.cmd = DEMOD_READ;\r\nreq.value = msg[i].addr >> 1;\r\nreq.index = msg[i].buf[0];\r\nreq.data_len = msg[i+1].len;\r\nreq.data = &msg[i+1].buf[0];\r\nret = ce6230_ctrl_msg(d, &req);\r\n} else {\r\ndev_err(&d->udev->dev, "%s: I2C read not " \\r\n"implemented\n",\r\nKBUILD_MODNAME);\r\nret = -EOPNOTSUPP;\r\n}\r\ni += 2;\r\n} else {\r\nif (msg[i].addr ==\r\nce6230_zl10353_config.demod_address) {\r\nreq.cmd = DEMOD_WRITE;\r\nreq.value = msg[i].addr >> 1;\r\nreq.index = msg[i].buf[0];\r\nreq.data_len = msg[i].len-1;\r\nreq.data = &msg[i].buf[1];\r\nret = ce6230_ctrl_msg(d, &req);\r\n} else {\r\nreq.cmd = I2C_WRITE;\r\nreq.value = 0x2000 + (msg[i].addr >> 1);\r\nreq.index = 0x0000;\r\nreq.data_len = msg[i].len;\r\nreq.data = &msg[i].buf[0];\r\nret = ce6230_ctrl_msg(d, &req);\r\n}\r\ni += 1;\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret ? ret : i;\r\n}\r\nstatic u32 ce6230_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int ce6230_zl10353_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nadap->fe[0] = dvb_attach(zl10353_attach, &ce6230_zl10353_config,\r\n&d->i2c_adap);\r\nif (adap->fe[0] == NULL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ce6230_mxl5003s_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nret = dvb_attach(mxl5005s_attach, adap->fe[0], &d->i2c_adap,\r\n&ce6230_mxl5003s_config) == NULL ? -ENODEV : 0;\r\nreturn ret;\r\n}\r\nstatic int ce6230_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nret = usb_set_interface(d->udev, 1, onoff);\r\nif (ret)\r\ndev_err(&d->udev->dev, "%s: usb_set_interface() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nreturn ret;\r\n}
