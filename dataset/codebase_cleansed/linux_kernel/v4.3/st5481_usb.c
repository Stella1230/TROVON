static void usb_next_ctrl_msg(struct urb *urb,\r\nstruct st5481_adapter *adapter)\r\n{\r\nstruct st5481_ctrl *ctrl = &adapter->ctrl;\r\nint r_index;\r\nif (test_and_set_bit(0, &ctrl->busy)) {\r\nreturn;\r\n}\r\nif ((r_index = fifo_remove(&ctrl->msg_fifo.f)) < 0) {\r\ntest_and_clear_bit(0, &ctrl->busy);\r\nreturn;\r\n}\r\nurb->setup_packet =\r\n(unsigned char *)&ctrl->msg_fifo.data[r_index];\r\nDBG(1, "request=0x%02x,value=0x%04x,index=%x",\r\n((struct ctrl_msg *)urb->setup_packet)->dr.bRequest,\r\n((struct ctrl_msg *)urb->setup_packet)->dr.wValue,\r\n((struct ctrl_msg *)urb->setup_packet)->dr.wIndex);\r\nurb->dev = adapter->usb_dev;\r\nSUBMIT_URB(urb, GFP_ATOMIC);\r\n}\r\nstatic void usb_ctrl_msg(struct st5481_adapter *adapter,\r\nu8 request, u8 requesttype, u16 value, u16 index,\r\nctrl_complete_t complete, void *context)\r\n{\r\nstruct st5481_ctrl *ctrl = &adapter->ctrl;\r\nint w_index;\r\nstruct ctrl_msg *ctrl_msg;\r\nif ((w_index = fifo_add(&ctrl->msg_fifo.f)) < 0) {\r\nWARNING("control msg FIFO full");\r\nreturn;\r\n}\r\nctrl_msg = &ctrl->msg_fifo.data[w_index];\r\nctrl_msg->dr.bRequestType = requesttype;\r\nctrl_msg->dr.bRequest = request;\r\nctrl_msg->dr.wValue = cpu_to_le16p(&value);\r\nctrl_msg->dr.wIndex = cpu_to_le16p(&index);\r\nctrl_msg->dr.wLength = 0;\r\nctrl_msg->complete = complete;\r\nctrl_msg->context = context;\r\nusb_next_ctrl_msg(ctrl->urb, adapter);\r\n}\r\nvoid st5481_usb_device_ctrl_msg(struct st5481_adapter *adapter,\r\nu8 request, u16 value,\r\nctrl_complete_t complete, void *context)\r\n{\r\nusb_ctrl_msg(adapter, request,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, 0, complete, context);\r\n}\r\nvoid st5481_usb_pipe_reset(struct st5481_adapter *adapter,\r\nu_char pipe,\r\nctrl_complete_t complete, void *context)\r\n{\r\nDBG(1, "pipe=%02x", pipe);\r\nusb_ctrl_msg(adapter,\r\nUSB_REQ_CLEAR_FEATURE, USB_DIR_OUT | USB_RECIP_ENDPOINT,\r\n0, pipe, complete, context);\r\n}\r\nvoid st5481_ph_command(struct st5481_adapter *adapter, unsigned int command)\r\n{\r\nDBG(8, "command=%s", ST5481_CMD_string(command));\r\nst5481_usb_device_ctrl_msg(adapter, TXCI, command, NULL, NULL);\r\n}\r\nstatic void usb_ctrl_complete(struct urb *urb)\r\n{\r\nstruct st5481_adapter *adapter = urb->context;\r\nstruct st5481_ctrl *ctrl = &adapter->ctrl;\r\nstruct ctrl_msg *ctrl_msg;\r\nif (unlikely(urb->status < 0)) {\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\nDBG(1, "urb killed status %d", urb->status);\r\nreturn;\r\ndefault:\r\nWARNING("urb status %d", urb->status);\r\nbreak;\r\n}\r\n}\r\nctrl_msg = (struct ctrl_msg *)urb->setup_packet;\r\nif (ctrl_msg->dr.bRequest == USB_REQ_CLEAR_FEATURE) {\r\nle16_to_cpus(&ctrl_msg->dr.wIndex);\r\nusb_reset_endpoint(adapter->usb_dev, ctrl_msg->dr.wIndex);\r\n}\r\nif (ctrl_msg->complete)\r\nctrl_msg->complete(ctrl_msg->context);\r\nclear_bit(0, &ctrl->busy);\r\nusb_next_ctrl_msg(urb, adapter);\r\nreturn;\r\n}\r\nstatic void usb_int_complete(struct urb *urb)\r\n{\r\nu8 *data = urb->transfer_buffer;\r\nu8 irqbyte;\r\nstruct st5481_adapter *adapter = urb->context;\r\nint j;\r\nint status;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nDBG(2, "urb shutting down with status: %d", urb->status);\r\nreturn;\r\ndefault:\r\nWARNING("nonzero urb status received: %d", urb->status);\r\ngoto exit;\r\n}\r\nDBG_PACKET(2, data, INT_PKT_SIZE);\r\nif (urb->actual_length == 0) {\r\ngoto exit;\r\n}\r\nirqbyte = data[MPINT];\r\nif (irqbyte & DEN_INT)\r\nFsmEvent(&adapter->d_out.fsm, EV_DOUT_DEN, NULL);\r\nif (irqbyte & DCOLL_INT)\r\nFsmEvent(&adapter->d_out.fsm, EV_DOUT_COLL, NULL);\r\nirqbyte = data[FFINT_D];\r\nif (irqbyte & OUT_UNDERRUN)\r\nFsmEvent(&adapter->d_out.fsm, EV_DOUT_UNDERRUN, NULL);\r\nif (irqbyte & OUT_DOWN)\r\n;\r\nirqbyte = data[MPINT];\r\nif (irqbyte & RXCI_INT)\r\nFsmEvent(&adapter->l1m, data[CCIST] & 0x0f, NULL);\r\nfor (j = 0; j < 2; j++)\r\nadapter->bcs[j].b_out.flow_event |= data[FFINT_B1 + j];\r\nurb->actual_length = 0;\r\nexit:\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status)\r\nWARNING("usb_submit_urb failed with result %d", status);\r\n}\r\nint st5481_setup_usb(struct st5481_adapter *adapter)\r\n{\r\nstruct usb_device *dev = adapter->usb_dev;\r\nstruct st5481_ctrl *ctrl = &adapter->ctrl;\r\nstruct st5481_intr *intr = &adapter->intr;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *altsetting = NULL;\r\nstruct usb_host_endpoint *endpoint;\r\nint status;\r\nstruct urb *urb;\r\nu8 *buf;\r\nDBG(2, "");\r\nif ((status = usb_reset_configuration(dev)) < 0) {\r\nWARNING("reset_configuration failed,status=%d", status);\r\nreturn status;\r\n}\r\nintf = usb_ifnum_to_if(dev, 0);\r\nif (intf)\r\naltsetting = usb_altnum_to_altsetting(intf, 3);\r\nif (!altsetting)\r\nreturn -ENXIO;\r\nif (altsetting->desc.bNumEndpoints != 7) {\r\nWARNING("expecting 7 got %d endpoints!", altsetting->desc.bNumEndpoints);\r\nreturn -EINVAL;\r\n}\r\naltsetting->endpoint[3].desc.wMaxPacketSize = cpu_to_le16(32);\r\naltsetting->endpoint[4].desc.wMaxPacketSize = cpu_to_le16(32);\r\nif ((status = usb_set_interface(dev, 0, 3)) < 0) {\r\nWARNING("usb_set_interface failed,status=%d", status);\r\nreturn status;\r\n}\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nreturn -ENOMEM;\r\n}\r\nctrl->urb = urb;\r\nusb_fill_control_urb(urb, dev,\r\nusb_sndctrlpipe(dev, 0),\r\nNULL, NULL, 0, usb_ctrl_complete, adapter);\r\nfifo_init(&ctrl->msg_fifo.f, ARRAY_SIZE(ctrl->msg_fifo.data));\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ngoto err1;\r\n}\r\nintr->urb = urb;\r\nbuf = kmalloc(INT_PKT_SIZE, GFP_KERNEL);\r\nif (!buf) {\r\ngoto err2;\r\n}\r\nendpoint = &altsetting->endpoint[EP_INT-1];\r\nusb_fill_int_urb(urb, dev,\r\nusb_rcvintpipe(dev, endpoint->desc.bEndpointAddress),\r\nbuf, INT_PKT_SIZE,\r\nusb_int_complete, adapter,\r\nendpoint->desc.bInterval);\r\nreturn 0;\r\nerr2:\r\nusb_free_urb(intr->urb);\r\nintr->urb = NULL;\r\nerr1:\r\nusb_free_urb(ctrl->urb);\r\nctrl->urb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nvoid st5481_release_usb(struct st5481_adapter *adapter)\r\n{\r\nstruct st5481_intr *intr = &adapter->intr;\r\nstruct st5481_ctrl *ctrl = &adapter->ctrl;\r\nDBG(1, "");\r\nusb_kill_urb(ctrl->urb);\r\nkfree(ctrl->urb->transfer_buffer);\r\nusb_free_urb(ctrl->urb);\r\nctrl->urb = NULL;\r\nusb_kill_urb(intr->urb);\r\nkfree(intr->urb->transfer_buffer);\r\nusb_free_urb(intr->urb);\r\nintr->urb = NULL;\r\n}\r\nvoid st5481_start(struct st5481_adapter *adapter)\r\n{\r\nstatic const u8 init_cmd_table[] = {\r\nSET_DEFAULT, 0,\r\nSTT, 0,\r\nSDA_MIN, 0x0d,\r\nSDA_MAX, 0x29,\r\nSDELAY_VALUE, 0x14,\r\nGPIO_DIR, 0x01,\r\nGPIO_OUT, RED_LED,\r\nFFCTRL_OUT_B1, 6,\r\nFFCTRH_OUT_B1, 20,\r\nFFCTRL_OUT_B2, 6,\r\nFFCTRH_OUT_B2, 20,\r\nMPMSK, RXCI_INT + DEN_INT + DCOLL_INT,\r\n0\r\n};\r\nstruct st5481_intr *intr = &adapter->intr;\r\nint i = 0;\r\nu8 request, value;\r\nDBG(8, "");\r\nadapter->leds = RED_LED;\r\nSUBMIT_URB(intr->urb, GFP_KERNEL);\r\nwhile ((request = init_cmd_table[i++])) {\r\nvalue = init_cmd_table[i++];\r\nst5481_usb_device_ctrl_msg(adapter, request, value, NULL, NULL);\r\n}\r\nst5481_ph_command(adapter, ST5481_CMD_PUP);\r\n}\r\nvoid st5481_stop(struct st5481_adapter *adapter)\r\n{\r\nDBG(8, "");\r\nst5481_usb_device_ctrl_msg(adapter, SET_DEFAULT, 0, NULL, NULL);\r\n}\r\nstatic void\r\nfill_isoc_urb(struct urb *urb, struct usb_device *dev,\r\nunsigned int pipe, void *buf, int num_packets,\r\nint packet_size, usb_complete_t complete,\r\nvoid *context)\r\n{\r\nint k;\r\nurb->dev = dev;\r\nurb->pipe = pipe;\r\nurb->interval = 1;\r\nurb->transfer_buffer = buf;\r\nurb->number_of_packets = num_packets;\r\nurb->transfer_buffer_length = num_packets * packet_size;\r\nurb->actual_length = 0;\r\nurb->complete = complete;\r\nurb->context = context;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nfor (k = 0; k < num_packets; k++) {\r\nurb->iso_frame_desc[k].offset = packet_size * k;\r\nurb->iso_frame_desc[k].length = packet_size;\r\nurb->iso_frame_desc[k].actual_length = 0;\r\n}\r\n}\r\nint\r\nst5481_setup_isocpipes(struct urb *urb[2], struct usb_device *dev,\r\nunsigned int pipe, int num_packets,\r\nint packet_size, int buf_size,\r\nusb_complete_t complete, void *context)\r\n{\r\nint j, retval;\r\nunsigned char *buf;\r\nfor (j = 0; j < 2; j++) {\r\nretval = -ENOMEM;\r\nurb[j] = usb_alloc_urb(num_packets, GFP_KERNEL);\r\nif (!urb[j])\r\ngoto err;\r\nbuf = kmalloc(buf_size, GFP_KERNEL);\r\nif (!buf)\r\ngoto err;\r\nfill_isoc_urb(urb[j], dev, pipe, buf,\r\nnum_packets, packet_size, complete,\r\ncontext);\r\n}\r\nreturn 0;\r\nerr:\r\nfor (j = 0; j < 2; j++) {\r\nif (urb[j]) {\r\nkfree(urb[j]->transfer_buffer);\r\nurb[j]->transfer_buffer = NULL;\r\nusb_free_urb(urb[j]);\r\nurb[j] = NULL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nvoid st5481_release_isocpipes(struct urb *urb[2])\r\n{\r\nint j;\r\nfor (j = 0; j < 2; j++) {\r\nusb_kill_urb(urb[j]);\r\nkfree(urb[j]->transfer_buffer);\r\nusb_free_urb(urb[j]);\r\nurb[j] = NULL;\r\n}\r\n}\r\nstatic void usb_in_complete(struct urb *urb)\r\n{\r\nstruct st5481_in *in = urb->context;\r\nunsigned char *ptr;\r\nstruct sk_buff *skb;\r\nint len, count, status;\r\nif (unlikely(urb->status < 0)) {\r\nswitch (urb->status) {\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\nDBG(1, "urb killed status %d", urb->status);\r\nreturn;\r\ndefault:\r\nWARNING("urb status %d", urb->status);\r\nbreak;\r\n}\r\n}\r\nDBG_ISO_PACKET(0x80, urb);\r\nlen = st5481_isoc_flatten(urb);\r\nptr = urb->transfer_buffer;\r\nwhile (len > 0) {\r\nif (in->mode == L1_MODE_TRANS) {\r\nmemcpy(in->rcvbuf, ptr, len);\r\nstatus = len;\r\nlen = 0;\r\n} else {\r\nstatus = isdnhdlc_decode(&in->hdlc_state, ptr, len, &count,\r\nin->rcvbuf, in->bufsize);\r\nptr += count;\r\nlen -= count;\r\n}\r\nif (status > 0) {\r\nDBG(4, "count=%d", status);\r\nDBG_PACKET(0x400, in->rcvbuf, status);\r\nif (!(skb = dev_alloc_skb(status))) {\r\nWARNING("receive out of memory\n");\r\nbreak;\r\n}\r\nmemcpy(skb_put(skb, status), in->rcvbuf, status);\r\nin->hisax_if->l1l2(in->hisax_if, PH_DATA | INDICATION, skb);\r\n} else if (status == -HDLC_CRC_ERROR) {\r\nINFO("CRC error");\r\n} else if (status == -HDLC_FRAMING_ERROR) {\r\nINFO("framing error");\r\n} else if (status == -HDLC_LENGTH_ERROR) {\r\nINFO("length error");\r\n}\r\n}\r\nurb->dev = in->adapter->usb_dev;\r\nurb->actual_length = 0;\r\nSUBMIT_URB(urb, GFP_ATOMIC);\r\n}\r\nint st5481_setup_in(struct st5481_in *in)\r\n{\r\nstruct usb_device *dev = in->adapter->usb_dev;\r\nint retval;\r\nDBG(4, "");\r\nin->rcvbuf = kmalloc(in->bufsize, GFP_KERNEL);\r\nretval = -ENOMEM;\r\nif (!in->rcvbuf)\r\ngoto err;\r\nretval = st5481_setup_isocpipes(in->urb, dev,\r\nusb_rcvisocpipe(dev, in->ep),\r\nin->num_packets, in->packet_size,\r\nin->num_packets * in->packet_size,\r\nusb_in_complete, in);\r\nif (retval)\r\ngoto err_free;\r\nreturn 0;\r\nerr_free:\r\nkfree(in->rcvbuf);\r\nerr:\r\nreturn retval;\r\n}\r\nvoid st5481_release_in(struct st5481_in *in)\r\n{\r\nDBG(2, "");\r\nst5481_release_isocpipes(in->urb);\r\n}\r\nstatic int st5481_isoc_flatten(struct urb *urb)\r\n{\r\nstruct usb_iso_packet_descriptor *pipd, *pend;\r\nunsigned char *src, *dst;\r\nunsigned int len;\r\nif (urb->status < 0) {\r\nreturn urb->status;\r\n}\r\nfor (pipd = &urb->iso_frame_desc[0],\r\npend = &urb->iso_frame_desc[urb->number_of_packets],\r\ndst = urb->transfer_buffer;\r\npipd < pend;\r\npipd++) {\r\nif (pipd->status < 0) {\r\nreturn (pipd->status);\r\n}\r\nlen = pipd->actual_length;\r\npipd->actual_length = 0;\r\nsrc = urb->transfer_buffer + pipd->offset;\r\nif (src != dst) {\r\nwhile (len--) {\r\n*dst++ = *src++;\r\n}\r\n} else {\r\ndst += len;\r\n}\r\n}\r\nreturn (dst - (unsigned char *)urb->transfer_buffer);\r\n}\r\nstatic void st5481_start_rcv(void *context)\r\n{\r\nstruct st5481_in *in = context;\r\nstruct st5481_adapter *adapter = in->adapter;\r\nDBG(4, "");\r\nin->urb[0]->dev = adapter->usb_dev;\r\nSUBMIT_URB(in->urb[0], GFP_KERNEL);\r\nin->urb[1]->dev = adapter->usb_dev;\r\nSUBMIT_URB(in->urb[1], GFP_KERNEL);\r\n}\r\nvoid st5481_in_mode(struct st5481_in *in, int mode)\r\n{\r\nif (in->mode == mode)\r\nreturn;\r\nin->mode = mode;\r\nusb_unlink_urb(in->urb[0]);\r\nusb_unlink_urb(in->urb[1]);\r\nif (in->mode != L1_MODE_NULL) {\r\nif (in->mode != L1_MODE_TRANS) {\r\nu32 features = HDLC_BITREVERSE;\r\nif (in->mode == L1_MODE_HDLC_56K)\r\nfeatures |= HDLC_56KBIT;\r\nisdnhdlc_rcv_init(&in->hdlc_state, features);\r\n}\r\nst5481_usb_pipe_reset(in->adapter, in->ep, NULL, NULL);\r\nst5481_usb_device_ctrl_msg(in->adapter, in->counter,\r\nin->packet_size,\r\nNULL, NULL);\r\nst5481_start_rcv(in);\r\n} else {\r\nst5481_usb_device_ctrl_msg(in->adapter, in->counter,\r\n0, NULL, NULL);\r\n}\r\n}
