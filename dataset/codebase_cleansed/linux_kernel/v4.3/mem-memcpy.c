static void init_cycle(void)\r\n{\r\ncycle_fd = sys_perf_event_open(&cycle_attr, getpid(), -1, -1,\r\nperf_event_open_cloexec_flag());\r\nif (cycle_fd < 0 && errno == ENOSYS)\r\ndie("No CONFIG_PERF_EVENTS=y kernel support configured?\n");\r\nelse\r\nBUG_ON(cycle_fd < 0);\r\n}\r\nstatic u64 get_cycle(void)\r\n{\r\nint ret;\r\nu64 clk;\r\nret = read(cycle_fd, &clk, sizeof(u64));\r\nBUG_ON(ret != sizeof(u64));\r\nreturn clk;\r\n}\r\nstatic double timeval2double(struct timeval *ts)\r\n{\r\nreturn (double)ts->tv_sec +\r\n(double)ts->tv_usec / (double)1000000;\r\n}\r\nstatic void __bench_mem_routine(struct bench_mem_info *info, int r_idx, size_t len, double totallen)\r\n{\r\nconst struct routine *r = &info->routines[r_idx];\r\ndouble result_bps[2];\r\nu64 result_cycle[2];\r\nresult_cycle[0] = result_cycle[1] = 0ULL;\r\nresult_bps[0] = result_bps[1] = 0.0;\r\nprintf("Routine %s (%s)\n", r->name, r->desc);\r\nif (bench_format == BENCH_FORMAT_DEFAULT)\r\nprintf("# Copying %s Bytes ...\n\n", length_str);\r\nif (!only_prefault && !no_prefault) {\r\nif (use_cycle) {\r\nresult_cycle[0] = info->do_cycle(r, len, false);\r\nresult_cycle[1] = info->do_cycle(r, len, true);\r\n} else {\r\nresult_bps[0] = info->do_gettimeofday(r, len, false);\r\nresult_bps[1] = info->do_gettimeofday(r, len, true);\r\n}\r\n} else {\r\nif (use_cycle)\r\nresult_cycle[pf] = info->do_cycle(r, len, only_prefault);\r\nelse\r\nresult_bps[pf] = info->do_gettimeofday(r, len, only_prefault);\r\n}\r\nswitch (bench_format) {\r\ncase BENCH_FORMAT_DEFAULT:\r\nif (!only_prefault && !no_prefault) {\r\nif (use_cycle) {\r\nprintf(" %14lf Cycle/Byte\n",\r\n(double)result_cycle[0]\r\n/ totallen);\r\nprintf(" %14lf Cycle/Byte (with prefault)\n",\r\n(double)result_cycle[1]\r\n/ totallen);\r\n} else {\r\nprint_bps(result_bps[0]);\r\nprintf("\n");\r\nprint_bps(result_bps[1]);\r\nprintf(" (with prefault)\n");\r\n}\r\n} else {\r\nif (use_cycle) {\r\nprintf(" %14lf Cycle/Byte",\r\n(double)result_cycle[pf]\r\n/ totallen);\r\n} else\r\nprint_bps(result_bps[pf]);\r\nprintf("%s\n", only_prefault ? " (with prefault)" : "");\r\n}\r\nbreak;\r\ncase BENCH_FORMAT_SIMPLE:\r\nif (!only_prefault && !no_prefault) {\r\nif (use_cycle) {\r\nprintf("%lf %lf\n",\r\n(double)result_cycle[0] / totallen,\r\n(double)result_cycle[1] / totallen);\r\n} else {\r\nprintf("%lf %lf\n",\r\nresult_bps[0], result_bps[1]);\r\n}\r\n} else {\r\nif (use_cycle) {\r\nprintf("%lf\n", (double)result_cycle[pf]\r\n/ totallen);\r\n} else\r\nprintf("%lf\n", result_bps[pf]);\r\n}\r\nbreak;\r\ndefault:\r\ndie("unknown format: %d\n", bench_format);\r\nbreak;\r\n}\r\n}\r\nstatic int bench_mem_common(int argc, const char **argv,\r\nconst char *prefix __maybe_unused,\r\nstruct bench_mem_info *info)\r\n{\r\nint i;\r\nsize_t len;\r\ndouble totallen;\r\nargc = parse_options(argc, argv, options,\r\ninfo->usage, 0);\r\nif (no_prefault && only_prefault) {\r\nfprintf(stderr, "Invalid options: -o and -n are mutually exclusive\n");\r\nreturn 1;\r\n}\r\nif (use_cycle)\r\ninit_cycle();\r\nlen = (size_t)perf_atoll((char *)length_str);\r\ntotallen = (double)len * iterations;\r\nif ((s64)len <= 0) {\r\nfprintf(stderr, "Invalid length:%s\n", length_str);\r\nreturn 1;\r\n}\r\nif (only_prefault && no_prefault)\r\nonly_prefault = no_prefault = false;\r\nif (!strncmp(routine, "all", 3)) {\r\nfor (i = 0; info->routines[i].name; i++)\r\n__bench_mem_routine(info, i, len, totallen);\r\nreturn 0;\r\n}\r\nfor (i = 0; info->routines[i].name; i++) {\r\nif (!strcmp(info->routines[i].name, routine))\r\nbreak;\r\n}\r\nif (!info->routines[i].name) {\r\nprintf("Unknown routine:%s\n", routine);\r\nprintf("Available routines...\n");\r\nfor (i = 0; info->routines[i].name; i++) {\r\nprintf("\t%s ... %s\n",\r\ninfo->routines[i].name, info->routines[i].desc);\r\n}\r\nreturn 1;\r\n}\r\n__bench_mem_routine(info, i, len, totallen);\r\nreturn 0;\r\n}\r\nstatic void memcpy_alloc_mem(void **dst, void **src, size_t length)\r\n{\r\n*dst = zalloc(length);\r\nif (!*dst)\r\ndie("memory allocation failed - maybe length is too large?\n");\r\n*src = zalloc(length);\r\nif (!*src)\r\ndie("memory allocation failed - maybe length is too large?\n");\r\nmemset(*src, 0, length);\r\n}\r\nstatic u64 do_memcpy_cycle(const struct routine *r, size_t len, bool prefault)\r\n{\r\nu64 cycle_start = 0ULL, cycle_end = 0ULL;\r\nvoid *src = NULL, *dst = NULL;\r\nmemcpy_t fn = r->fn.memcpy;\r\nint i;\r\nmemcpy_alloc_mem(&dst, &src, len);\r\nif (prefault)\r\nfn(dst, src, len);\r\ncycle_start = get_cycle();\r\nfor (i = 0; i < iterations; ++i)\r\nfn(dst, src, len);\r\ncycle_end = get_cycle();\r\nfree(src);\r\nfree(dst);\r\nreturn cycle_end - cycle_start;\r\n}\r\nstatic double do_memcpy_gettimeofday(const struct routine *r, size_t len,\r\nbool prefault)\r\n{\r\nstruct timeval tv_start, tv_end, tv_diff;\r\nmemcpy_t fn = r->fn.memcpy;\r\nvoid *src = NULL, *dst = NULL;\r\nint i;\r\nmemcpy_alloc_mem(&dst, &src, len);\r\nif (prefault)\r\nfn(dst, src, len);\r\nBUG_ON(gettimeofday(&tv_start, NULL));\r\nfor (i = 0; i < iterations; ++i)\r\nfn(dst, src, len);\r\nBUG_ON(gettimeofday(&tv_end, NULL));\r\ntimersub(&tv_end, &tv_start, &tv_diff);\r\nfree(src);\r\nfree(dst);\r\nreturn (double)(((double)len * iterations) / timeval2double(&tv_diff));\r\n}\r\nint bench_mem_memcpy(int argc, const char **argv,\r\nconst char *prefix __maybe_unused)\r\n{\r\nstruct bench_mem_info info = {\r\n.routines = memcpy_routines,\r\n.do_cycle = do_memcpy_cycle,\r\n.do_gettimeofday = do_memcpy_gettimeofday,\r\n.usage = bench_mem_memcpy_usage,\r\n};\r\nreturn bench_mem_common(argc, argv, prefix, &info);\r\n}\r\nstatic void memset_alloc_mem(void **dst, size_t length)\r\n{\r\n*dst = zalloc(length);\r\nif (!*dst)\r\ndie("memory allocation failed - maybe length is too large?\n");\r\n}\r\nstatic u64 do_memset_cycle(const struct routine *r, size_t len, bool prefault)\r\n{\r\nu64 cycle_start = 0ULL, cycle_end = 0ULL;\r\nmemset_t fn = r->fn.memset;\r\nvoid *dst = NULL;\r\nint i;\r\nmemset_alloc_mem(&dst, len);\r\nif (prefault)\r\nfn(dst, -1, len);\r\ncycle_start = get_cycle();\r\nfor (i = 0; i < iterations; ++i)\r\nfn(dst, i, len);\r\ncycle_end = get_cycle();\r\nfree(dst);\r\nreturn cycle_end - cycle_start;\r\n}\r\nstatic double do_memset_gettimeofday(const struct routine *r, size_t len,\r\nbool prefault)\r\n{\r\nstruct timeval tv_start, tv_end, tv_diff;\r\nmemset_t fn = r->fn.memset;\r\nvoid *dst = NULL;\r\nint i;\r\nmemset_alloc_mem(&dst, len);\r\nif (prefault)\r\nfn(dst, -1, len);\r\nBUG_ON(gettimeofday(&tv_start, NULL));\r\nfor (i = 0; i < iterations; ++i)\r\nfn(dst, i, len);\r\nBUG_ON(gettimeofday(&tv_end, NULL));\r\ntimersub(&tv_end, &tv_start, &tv_diff);\r\nfree(dst);\r\nreturn (double)(((double)len * iterations) / timeval2double(&tv_diff));\r\n}\r\nint bench_mem_memset(int argc, const char **argv,\r\nconst char *prefix __maybe_unused)\r\n{\r\nstruct bench_mem_info info = {\r\n.routines = memset_routines,\r\n.do_cycle = do_memset_cycle,\r\n.do_gettimeofday = do_memset_gettimeofday,\r\n.usage = bench_mem_memset_usage,\r\n};\r\nreturn bench_mem_common(argc, argv, prefix, &info);\r\n}
