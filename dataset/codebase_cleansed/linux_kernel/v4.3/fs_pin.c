void pin_remove(struct fs_pin *pin)\r\n{\r\nspin_lock(&pin_lock);\r\nhlist_del_init(&pin->m_list);\r\nhlist_del_init(&pin->s_list);\r\nspin_unlock(&pin_lock);\r\nspin_lock_irq(&pin->wait.lock);\r\npin->done = 1;\r\nwake_up_locked(&pin->wait);\r\nspin_unlock_irq(&pin->wait.lock);\r\n}\r\nvoid pin_insert_group(struct fs_pin *pin, struct vfsmount *m, struct hlist_head *p)\r\n{\r\nspin_lock(&pin_lock);\r\nif (p)\r\nhlist_add_head(&pin->s_list, p);\r\nhlist_add_head(&pin->m_list, &real_mount(m)->mnt_pins);\r\nspin_unlock(&pin_lock);\r\n}\r\nvoid pin_insert(struct fs_pin *pin, struct vfsmount *m)\r\n{\r\npin_insert_group(pin, m, &m->mnt_sb->s_pins);\r\n}\r\nvoid pin_kill(struct fs_pin *p)\r\n{\r\nwait_queue_t wait;\r\nif (!p) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\ninit_wait(&wait);\r\nspin_lock_irq(&p->wait.lock);\r\nif (likely(!p->done)) {\r\np->done = -1;\r\nspin_unlock_irq(&p->wait.lock);\r\nrcu_read_unlock();\r\np->kill(p);\r\nreturn;\r\n}\r\nif (p->done > 0) {\r\nspin_unlock_irq(&p->wait.lock);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\n__add_wait_queue(&p->wait, &wait);\r\nwhile (1) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irq(&p->wait.lock);\r\nrcu_read_unlock();\r\nschedule();\r\nrcu_read_lock();\r\nif (likely(list_empty(&wait.task_list)))\r\nbreak;\r\nspin_lock_irq(&p->wait.lock);\r\nif (p->done > 0) {\r\nspin_unlock_irq(&p->wait.lock);\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid mnt_pin_kill(struct mount *m)\r\n{\r\nwhile (1) {\r\nstruct hlist_node *p;\r\nrcu_read_lock();\r\np = ACCESS_ONCE(m->mnt_pins.first);\r\nif (!p) {\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\npin_kill(hlist_entry(p, struct fs_pin, m_list));\r\n}\r\n}\r\nvoid group_pin_kill(struct hlist_head *p)\r\n{\r\nwhile (1) {\r\nstruct hlist_node *q;\r\nrcu_read_lock();\r\nq = ACCESS_ONCE(p->first);\r\nif (!q) {\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\npin_kill(hlist_entry(q, struct fs_pin, s_list));\r\n}\r\n}
