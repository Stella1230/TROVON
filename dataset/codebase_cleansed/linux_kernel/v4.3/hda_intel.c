static void __mark_pages_wc(struct azx *chip, struct snd_dma_buffer *dmab, bool on)\r\n{\r\nint pages;\r\nif (azx_snoop(chip))\r\nreturn;\r\nif (!dmab || !dmab->area || !dmab->bytes)\r\nreturn;\r\n#ifdef CONFIG_SND_DMA_SGBUF\r\nif (dmab->dev.type == SNDRV_DMA_TYPE_DEV_SG) {\r\nstruct snd_sg_buf *sgbuf = dmab->private_data;\r\nif (chip->driver_type == AZX_DRIVER_CMEDIA)\r\nreturn;\r\nif (on)\r\nset_pages_array_wc(sgbuf->page_table, sgbuf->pages);\r\nelse\r\nset_pages_array_wb(sgbuf->page_table, sgbuf->pages);\r\nreturn;\r\n}\r\n#endif\r\npages = (dmab->bytes + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nif (on)\r\nset_memory_wc((unsigned long)dmab->area, pages);\r\nelse\r\nset_memory_wb((unsigned long)dmab->area, pages);\r\n}\r\nstatic inline void mark_pages_wc(struct azx *chip, struct snd_dma_buffer *buf,\r\nbool on)\r\n{\r\n__mark_pages_wc(chip, buf, on);\r\n}\r\nstatic inline void mark_runtime_wc(struct azx *chip, struct azx_dev *azx_dev,\r\nstruct snd_pcm_substream *substream, bool on)\r\n{\r\nif (azx_dev->wc_marked != on) {\r\n__mark_pages_wc(chip, snd_pcm_get_dma_buf(substream), on);\r\nazx_dev->wc_marked = on;\r\n}\r\n}\r\nstatic inline void mark_pages_wc(struct azx *chip, struct snd_dma_buffer *buf,\r\nbool on)\r\n{\r\n}\r\nstatic inline void mark_runtime_wc(struct azx *chip, struct azx_dev *azx_dev,\r\nstruct snd_pcm_substream *substream, bool on)\r\n{\r\n}\r\nstatic void update_pci_byte(struct pci_dev *pci, unsigned int reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nunsigned char data;\r\npci_read_config_byte(pci, reg, &data);\r\ndata &= ~mask;\r\ndata |= (val & mask);\r\npci_write_config_byte(pci, reg, data);\r\n}\r\nstatic void azx_init_pci(struct azx *chip)\r\n{\r\nint snoop_type = azx_get_snoop_type(chip);\r\nif (!(chip->driver_caps & AZX_DCAPS_NO_TCSEL)) {\r\ndev_dbg(chip->card->dev, "Clearing TCSEL\n");\r\nupdate_pci_byte(chip->pci, AZX_PCIREG_TCSEL, 0x07, 0);\r\n}\r\nif (snoop_type == AZX_SNOOP_TYPE_ATI) {\r\ndev_dbg(chip->card->dev, "Setting ATI snoop: %d\n",\r\nazx_snoop(chip));\r\nupdate_pci_byte(chip->pci,\r\nATI_SB450_HDAUDIO_MISC_CNTR2_ADDR, 0x07,\r\nazx_snoop(chip) ? ATI_SB450_HDAUDIO_ENABLE_SNOOP : 0);\r\n}\r\nif (snoop_type == AZX_SNOOP_TYPE_NVIDIA) {\r\ndev_dbg(chip->card->dev, "Setting Nvidia snoop: %d\n",\r\nazx_snoop(chip));\r\nupdate_pci_byte(chip->pci,\r\nNVIDIA_HDA_TRANSREG_ADDR,\r\n0x0f, NVIDIA_HDA_ENABLE_COHBITS);\r\nupdate_pci_byte(chip->pci,\r\nNVIDIA_HDA_ISTRM_COH,\r\n0x01, NVIDIA_HDA_ENABLE_COHBIT);\r\nupdate_pci_byte(chip->pci,\r\nNVIDIA_HDA_OSTRM_COH,\r\n0x01, NVIDIA_HDA_ENABLE_COHBIT);\r\n}\r\nif (snoop_type == AZX_SNOOP_TYPE_SCH) {\r\nunsigned short snoop;\r\npci_read_config_word(chip->pci, INTEL_SCH_HDA_DEVC, &snoop);\r\nif ((!azx_snoop(chip) && !(snoop & INTEL_SCH_HDA_DEVC_NOSNOOP)) ||\r\n(azx_snoop(chip) && (snoop & INTEL_SCH_HDA_DEVC_NOSNOOP))) {\r\nsnoop &= ~INTEL_SCH_HDA_DEVC_NOSNOOP;\r\nif (!azx_snoop(chip))\r\nsnoop |= INTEL_SCH_HDA_DEVC_NOSNOOP;\r\npci_write_config_word(chip->pci, INTEL_SCH_HDA_DEVC, snoop);\r\npci_read_config_word(chip->pci,\r\nINTEL_SCH_HDA_DEVC, &snoop);\r\n}\r\ndev_dbg(chip->card->dev, "SCH snoop: %s\n",\r\n(snoop & INTEL_SCH_HDA_DEVC_NOSNOOP) ?\r\n"Disabled" : "Enabled");\r\n}\r\n}\r\nstatic void hda_intel_init_chip(struct azx *chip, bool full_reset)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)\r\nsnd_hdac_set_codec_wakeup(bus, true);\r\nazx_init_chip(chip, full_reset);\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)\r\nsnd_hdac_set_codec_wakeup(bus, false);\r\n}\r\nstatic int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,\r\nunsigned int pos)\r\n{\r\nstruct snd_pcm_substream *substream = azx_dev->core.substream;\r\nint stream = substream->stream;\r\nunsigned int lpib_pos = azx_get_pos_lpib(chip, azx_dev);\r\nint delay;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndelay = pos - lpib_pos;\r\nelse\r\ndelay = lpib_pos - pos;\r\nif (delay < 0) {\r\nif (delay >= azx_dev->core.delay_negative_threshold)\r\ndelay = 0;\r\nelse\r\ndelay += azx_dev->core.bufsize;\r\n}\r\nif (delay >= azx_dev->core.period_bytes) {\r\ndev_info(chip->card->dev,\r\n"Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",\r\ndelay, azx_dev->core.period_bytes);\r\ndelay = 0;\r\nchip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;\r\nchip->get_delay[stream] = NULL;\r\n}\r\nreturn bytes_to_frames(substream->runtime, delay);\r\n}\r\nstatic int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nint ok;\r\nok = azx_position_ok(chip, azx_dev);\r\nif (ok == 1) {\r\nazx_dev->irq_pending = 0;\r\nreturn ok;\r\n} else if (ok == 0) {\r\nazx_dev->irq_pending = 1;\r\nschedule_work(&hda->irq_pending_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int azx_intel_link_power(struct azx *chip, bool enable)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nreturn snd_hdac_display_power(bus, enable);\r\n}\r\nstatic int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)\r\n{\r\nstruct snd_pcm_substream *substream = azx_dev->core.substream;\r\nint stream = substream->stream;\r\nu32 wallclk;\r\nunsigned int pos;\r\nwallclk = azx_readl(chip, WALLCLK) - azx_dev->core.start_wallclk;\r\nif (wallclk < (azx_dev->core.period_wallclk * 2) / 3)\r\nreturn -1;\r\nif (chip->get_position[stream])\r\npos = chip->get_position[stream](chip, azx_dev);\r\nelse {\r\npos = azx_get_pos_posbuf(chip, azx_dev);\r\nif (!pos || pos == (u32)-1) {\r\ndev_info(chip->card->dev,\r\n"Invalid position buffer, using LPIB read method instead.\n");\r\nchip->get_position[stream] = azx_get_pos_lpib;\r\nif (chip->get_position[0] == azx_get_pos_lpib &&\r\nchip->get_position[1] == azx_get_pos_lpib)\r\nazx_bus(chip)->use_posbuf = false;\r\npos = azx_get_pos_lpib(chip, azx_dev);\r\nchip->get_delay[stream] = NULL;\r\n} else {\r\nchip->get_position[stream] = azx_get_pos_posbuf;\r\nif (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)\r\nchip->get_delay[stream] = azx_get_delay_from_lpib;\r\n}\r\n}\r\nif (pos >= azx_dev->core.bufsize)\r\npos = 0;\r\nif (WARN_ONCE(!azx_dev->core.period_bytes,\r\n"hda-intel: zero azx_dev->period_bytes"))\r\nreturn -1;\r\nif (wallclk < (azx_dev->core.period_wallclk * 5) / 4 &&\r\npos % azx_dev->core.period_bytes > azx_dev->core.period_bytes / 2)\r\nreturn chip->bdl_pos_adj[chip->dev_index] ? 0 : -1;\r\nazx_dev->core.start_wallclk += wallclk;\r\nreturn 1;\r\n}\r\nstatic void azx_irq_pending_work(struct work_struct *work)\r\n{\r\nstruct hda_intel *hda = container_of(work, struct hda_intel, irq_pending_work);\r\nstruct azx *chip = &hda->chip;\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct hdac_stream *s;\r\nint pending, ok;\r\nif (!hda->irq_pending_warned) {\r\ndev_info(chip->card->dev,\r\n"IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",\r\nchip->card->number);\r\nhda->irq_pending_warned = 1;\r\n}\r\nfor (;;) {\r\npending = 0;\r\nspin_lock_irq(&bus->reg_lock);\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nstruct azx_dev *azx_dev = stream_to_azx_dev(s);\r\nif (!azx_dev->irq_pending ||\r\n!s->substream ||\r\n!s->running)\r\ncontinue;\r\nok = azx_position_ok(chip, azx_dev);\r\nif (ok > 0) {\r\nazx_dev->irq_pending = 0;\r\nspin_unlock(&bus->reg_lock);\r\nsnd_pcm_period_elapsed(s->substream);\r\nspin_lock(&bus->reg_lock);\r\n} else if (ok < 0) {\r\npending = 0;\r\n} else\r\npending++;\r\n}\r\nspin_unlock_irq(&bus->reg_lock);\r\nif (!pending)\r\nreturn;\r\nmsleep(1);\r\n}\r\n}\r\nstatic void azx_clear_irq_pending(struct azx *chip)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct hdac_stream *s;\r\nspin_lock_irq(&bus->reg_lock);\r\nlist_for_each_entry(s, &bus->stream_list, list) {\r\nstruct azx_dev *azx_dev = stream_to_azx_dev(s);\r\nazx_dev->irq_pending = 0;\r\n}\r\nspin_unlock_irq(&bus->reg_lock);\r\n}\r\nstatic int azx_acquire_irq(struct azx *chip, int do_disconnect)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nif (request_irq(chip->pci->irq, azx_interrupt,\r\nchip->msi ? 0 : IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(chip->card->dev,\r\n"unable to grab IRQ %d, disabling device\n",\r\nchip->pci->irq);\r\nif (do_disconnect)\r\nsnd_card_disconnect(chip->card);\r\nreturn -1;\r\n}\r\nbus->irq = chip->pci->irq;\r\npci_intx(chip->pci, !chip->msi);\r\nreturn 0;\r\n}\r\nstatic unsigned int azx_via_get_position(struct azx *chip,\r\nstruct azx_dev *azx_dev)\r\n{\r\nunsigned int link_pos, mini_pos, bound_pos;\r\nunsigned int mod_link_pos, mod_dma_pos, mod_mini_pos;\r\nunsigned int fifo_size;\r\nlink_pos = snd_hdac_stream_get_pos_lpib(azx_stream(azx_dev));\r\nif (azx_dev->core.substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nreturn link_pos;\r\n}\r\nmod_dma_pos = le32_to_cpu(*azx_dev->core.posbuf);\r\nmod_dma_pos %= azx_dev->core.period_bytes;\r\nfifo_size = readw(azx_bus(chip)->remap_addr +\r\nVIA_IN_STREAM0_FIFO_SIZE_OFFSET);\r\nif (azx_dev->insufficient) {\r\nif (link_pos <= fifo_size)\r\nreturn 0;\r\nazx_dev->insufficient = 0;\r\n}\r\nif (link_pos <= fifo_size)\r\nmini_pos = azx_dev->core.bufsize + link_pos - fifo_size;\r\nelse\r\nmini_pos = link_pos - fifo_size;\r\nmod_mini_pos = mini_pos % azx_dev->core.period_bytes;\r\nmod_link_pos = link_pos % azx_dev->core.period_bytes;\r\nif (mod_link_pos >= fifo_size)\r\nbound_pos = link_pos - mod_link_pos;\r\nelse if (mod_dma_pos >= mod_mini_pos)\r\nbound_pos = mini_pos - mod_mini_pos;\r\nelse {\r\nbound_pos = mini_pos - mod_mini_pos + azx_dev->core.period_bytes;\r\nif (bound_pos >= azx_dev->core.bufsize)\r\nbound_pos = 0;\r\n}\r\nreturn bound_pos + mod_dma_pos;\r\n}\r\nstatic void azx_add_card_list(struct azx *chip)\r\n{\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nmutex_lock(&card_list_lock);\r\nlist_add(&hda->list, &card_list);\r\nmutex_unlock(&card_list_lock);\r\n}\r\nstatic void azx_del_card_list(struct azx *chip)\r\n{\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nmutex_lock(&card_list_lock);\r\nlist_del_init(&hda->list);\r\nmutex_unlock(&card_list_lock);\r\n}\r\nstatic int param_set_xint(const char *val, const struct kernel_param *kp)\r\n{\r\nstruct hda_intel *hda;\r\nstruct azx *chip;\r\nint prev = power_save;\r\nint ret = param_set_int(val, kp);\r\nif (ret || prev == power_save)\r\nreturn ret;\r\nmutex_lock(&card_list_lock);\r\nlist_for_each_entry(hda, &card_list, list) {\r\nchip = &hda->chip;\r\nif (!hda->probe_continued || chip->disabled)\r\ncontinue;\r\nsnd_hda_set_power_save(&chip->bus, power_save * 1000);\r\n}\r\nmutex_unlock(&card_list_lock);\r\nreturn 0;\r\n}\r\nstatic void haswell_set_bclk(struct hda_intel *hda)\r\n{\r\nstruct azx *chip = &hda->chip;\r\nint cdclk_freq;\r\nunsigned int bclk_m, bclk_n;\r\nif (!hda->need_i915_power)\r\nreturn;\r\ncdclk_freq = snd_hdac_get_display_clk(azx_bus(chip));\r\nswitch (cdclk_freq) {\r\ncase 337500:\r\nbclk_m = 16;\r\nbclk_n = 225;\r\nbreak;\r\ncase 450000:\r\ndefault:\r\nbclk_m = 4;\r\nbclk_n = 75;\r\nbreak;\r\ncase 540000:\r\nbclk_m = 4;\r\nbclk_n = 90;\r\nbreak;\r\ncase 675000:\r\nbclk_m = 8;\r\nbclk_n = 225;\r\nbreak;\r\n}\r\nazx_writew(chip, HSW_EM4, bclk_m);\r\nazx_writew(chip, HSW_EM5, bclk_n);\r\n}\r\nstatic int azx_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip;\r\nstruct hda_intel *hda;\r\nstruct hdac_bus *bus;\r\nif (!card)\r\nreturn 0;\r\nchip = card->private_data;\r\nhda = container_of(chip, struct hda_intel, chip);\r\nif (chip->disabled || hda->init_failed || !chip->running)\r\nreturn 0;\r\nbus = azx_bus(chip);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nazx_clear_irq_pending(chip);\r\nazx_stop_chip(chip);\r\nazx_enter_link_reset(chip);\r\nif (bus->irq >= 0) {\r\nfree_irq(bus->irq, chip);\r\nbus->irq = -1;\r\n}\r\nif (chip->msi)\r\npci_disable_msi(chip->pci);\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL\r\n&& hda->need_i915_power)\r\nsnd_hdac_display_power(bus, false);\r\ntrace_azx_suspend(chip);\r\nreturn 0;\r\n}\r\nstatic int azx_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip;\r\nstruct hda_intel *hda;\r\nif (!card)\r\nreturn 0;\r\nchip = card->private_data;\r\nhda = container_of(chip, struct hda_intel, chip);\r\nif (chip->disabled || hda->init_failed || !chip->running)\r\nreturn 0;\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL\r\n&& hda->need_i915_power) {\r\nsnd_hdac_display_power(azx_bus(chip), true);\r\nhaswell_set_bclk(hda);\r\n}\r\nif (chip->msi)\r\nif (pci_enable_msi(pci) < 0)\r\nchip->msi = 0;\r\nif (azx_acquire_irq(chip, 1) < 0)\r\nreturn -EIO;\r\nazx_init_pci(chip);\r\nhda_intel_init_chip(chip, true);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\ntrace_azx_resume(chip);\r\nreturn 0;\r\n}\r\nstatic int azx_runtime_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip;\r\nstruct hda_intel *hda;\r\nif (!card)\r\nreturn 0;\r\nchip = card->private_data;\r\nhda = container_of(chip, struct hda_intel, chip);\r\nif (chip->disabled || hda->init_failed)\r\nreturn 0;\r\nif (!azx_has_pm_runtime(chip))\r\nreturn 0;\r\nazx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) |\r\nSTATESTS_INT_MASK);\r\nazx_stop_chip(chip);\r\nazx_enter_link_reset(chip);\r\nazx_clear_irq_pending(chip);\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL\r\n&& hda->need_i915_power)\r\nsnd_hdac_display_power(azx_bus(chip), false);\r\ntrace_azx_runtime_suspend(chip);\r\nreturn 0;\r\n}\r\nstatic int azx_runtime_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip;\r\nstruct hda_intel *hda;\r\nstruct hdac_bus *bus;\r\nstruct hda_codec *codec;\r\nint status;\r\nif (!card)\r\nreturn 0;\r\nchip = card->private_data;\r\nhda = container_of(chip, struct hda_intel, chip);\r\nif (chip->disabled || hda->init_failed)\r\nreturn 0;\r\nif (!azx_has_pm_runtime(chip))\r\nreturn 0;\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {\r\nbus = azx_bus(chip);\r\nif (hda->need_i915_power) {\r\nsnd_hdac_display_power(bus, true);\r\nhaswell_set_bclk(hda);\r\n} else {\r\nsnd_hdac_set_codec_wakeup(bus, true);\r\nsnd_hdac_set_codec_wakeup(bus, false);\r\n}\r\n}\r\nstatus = azx_readw(chip, STATESTS);\r\nazx_init_pci(chip);\r\nhda_intel_init_chip(chip, true);\r\nif (status) {\r\nlist_for_each_codec(codec, &chip->bus)\r\nif (status & (1 << codec->addr))\r\nschedule_delayed_work(&codec->jackpoll_work,\r\ncodec->jackpoll_interval);\r\n}\r\nazx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) &\r\n~STATESTS_INT_MASK);\r\ntrace_azx_runtime_resume(chip);\r\nreturn 0;\r\n}\r\nstatic int azx_runtime_idle(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct azx *chip;\r\nstruct hda_intel *hda;\r\nif (!card)\r\nreturn 0;\r\nchip = card->private_data;\r\nhda = container_of(chip, struct hda_intel, chip);\r\nif (chip->disabled || hda->init_failed)\r\nreturn 0;\r\nif (!power_save_controller || !azx_has_pm_runtime(chip) ||\r\nazx_bus(chip)->codec_powered || !chip->running)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void azx_vs_set_state(struct pci_dev *pci,\r\nenum vga_switcheroo_state state)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nstruct azx *chip = card->private_data;\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nbool disabled;\r\nwait_for_completion(&hda->probe_wait);\r\nif (hda->init_failed)\r\nreturn;\r\ndisabled = (state == VGA_SWITCHEROO_OFF);\r\nif (chip->disabled == disabled)\r\nreturn;\r\nif (!hda->probe_continued) {\r\nchip->disabled = disabled;\r\nif (!disabled) {\r\ndev_info(chip->card->dev,\r\n"Start delayed initialization\n");\r\nif (azx_probe_continue(chip) < 0) {\r\ndev_err(chip->card->dev, "initialization error\n");\r\nhda->init_failed = true;\r\n}\r\n}\r\n} else {\r\ndev_info(chip->card->dev, "%s via VGA-switcheroo\n",\r\ndisabled ? "Disabling" : "Enabling");\r\nif (disabled) {\r\npm_runtime_put_sync_suspend(card->dev);\r\nazx_suspend(card->dev);\r\npci->current_state = PCI_D3cold;\r\nchip->disabled = true;\r\nif (snd_hda_lock_devices(&chip->bus))\r\ndev_warn(chip->card->dev,\r\n"Cannot lock devices!\n");\r\n} else {\r\nsnd_hda_unlock_devices(&chip->bus);\r\npm_runtime_get_noresume(card->dev);\r\nchip->disabled = false;\r\nazx_resume(card->dev);\r\n}\r\n}\r\n}\r\nstatic bool azx_vs_can_switch(struct pci_dev *pci)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nstruct azx *chip = card->private_data;\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nwait_for_completion(&hda->probe_wait);\r\nif (hda->init_failed)\r\nreturn false;\r\nif (chip->disabled || !hda->probe_continued)\r\nreturn true;\r\nif (snd_hda_lock_devices(&chip->bus))\r\nreturn false;\r\nsnd_hda_unlock_devices(&chip->bus);\r\nreturn true;\r\n}\r\nstatic void init_vga_switcheroo(struct azx *chip)\r\n{\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nstruct pci_dev *p = get_bound_vga(chip->pci);\r\nif (p) {\r\ndev_info(chip->card->dev,\r\n"Handle VGA-switcheroo audio client\n");\r\nhda->use_vga_switcheroo = 1;\r\npci_dev_put(p);\r\n}\r\n}\r\nstatic int register_vga_switcheroo(struct azx *chip)\r\n{\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nint err;\r\nif (!hda->use_vga_switcheroo)\r\nreturn 0;\r\nerr = vga_switcheroo_register_audio_client(chip->pci, &azx_vs_ops,\r\nVGA_SWITCHEROO_DIS,\r\nhda->probe_continued);\r\nif (err < 0)\r\nreturn err;\r\nhda->vga_switcheroo_registered = 1;\r\nvga_switcheroo_init_domain_pm_optimus_hdmi_audio(chip->card->dev,\r\n&hda->hdmi_pm_domain);\r\nreturn 0;\r\n}\r\nstatic int azx_free(struct azx *chip)\r\n{\r\nstruct pci_dev *pci = chip->pci;\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nif (azx_has_pm_runtime(chip) && chip->running)\r\npm_runtime_get_noresume(&pci->dev);\r\nazx_del_card_list(chip);\r\nhda->init_failed = 1;\r\ncomplete_all(&hda->probe_wait);\r\nif (use_vga_switcheroo(hda)) {\r\nif (chip->disabled && hda->probe_continued)\r\nsnd_hda_unlock_devices(&chip->bus);\r\nif (hda->vga_switcheroo_registered)\r\nvga_switcheroo_unregister_client(chip->pci);\r\n}\r\nif (bus->chip_init) {\r\nazx_clear_irq_pending(chip);\r\nazx_stop_all_streams(chip);\r\nazx_stop_chip(chip);\r\n}\r\nif (bus->irq >= 0)\r\nfree_irq(bus->irq, (void*)chip);\r\nif (chip->msi)\r\npci_disable_msi(chip->pci);\r\niounmap(bus->remap_addr);\r\nazx_free_stream_pages(chip);\r\nazx_free_streams(chip);\r\nsnd_hdac_bus_exit(bus);\r\nif (chip->region_requested)\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\r\nrelease_firmware(chip->fw);\r\n#endif\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {\r\nif (hda->need_i915_power)\r\nsnd_hdac_display_power(bus, false);\r\nsnd_hdac_i915_exit(bus);\r\n}\r\nkfree(hda);\r\nreturn 0;\r\n}\r\nstatic int azx_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct azx *chip = device->device_data;\r\nchip->bus.shutdown = 1;\r\nreturn 0;\r\n}\r\nstatic int azx_dev_free(struct snd_device *device)\r\n{\r\nreturn azx_free(device->device_data);\r\n}\r\nstatic struct pci_dev *get_bound_vga(struct pci_dev *pci)\r\n{\r\nstruct pci_dev *p;\r\nswitch (pci->vendor) {\r\ncase PCI_VENDOR_ID_ATI:\r\ncase PCI_VENDOR_ID_AMD:\r\ncase PCI_VENDOR_ID_NVIDIA:\r\nif (pci->devfn == 1) {\r\np = pci_get_domain_bus_and_slot(pci_domain_nr(pci->bus),\r\npci->bus->number, 0);\r\nif (p) {\r\nif ((p->class >> 8) == PCI_CLASS_DISPLAY_VGA)\r\nreturn p;\r\npci_dev_put(p);\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool check_hdmi_disabled(struct pci_dev *pci)\r\n{\r\nbool vga_inactive = false;\r\nstruct pci_dev *p = get_bound_vga(pci);\r\nif (p) {\r\nif (vga_switcheroo_get_client_state(p) == VGA_SWITCHEROO_OFF)\r\nvga_inactive = true;\r\npci_dev_put(p);\r\n}\r\nreturn vga_inactive;\r\n}\r\nstatic int check_position_fix(struct azx *chip, int fix)\r\n{\r\nconst struct snd_pci_quirk *q;\r\nswitch (fix) {\r\ncase POS_FIX_AUTO:\r\ncase POS_FIX_LPIB:\r\ncase POS_FIX_POSBUF:\r\ncase POS_FIX_VIACOMBO:\r\ncase POS_FIX_COMBO:\r\nreturn fix;\r\n}\r\nq = snd_pci_quirk_lookup(chip->pci, position_fix_list);\r\nif (q) {\r\ndev_info(chip->card->dev,\r\n"position_fix set to %d for device %04x:%04x\n",\r\nq->value, q->subvendor, q->subdevice);\r\nreturn q->value;\r\n}\r\nif (chip->driver_caps & AZX_DCAPS_POSFIX_VIA) {\r\ndev_dbg(chip->card->dev, "Using VIACOMBO position fix\n");\r\nreturn POS_FIX_VIACOMBO;\r\n}\r\nif (chip->driver_caps & AZX_DCAPS_POSFIX_LPIB) {\r\ndev_dbg(chip->card->dev, "Using LPIB position fix\n");\r\nreturn POS_FIX_LPIB;\r\n}\r\nreturn POS_FIX_AUTO;\r\n}\r\nstatic void assign_position_fix(struct azx *chip, int fix)\r\n{\r\nstatic azx_get_pos_callback_t callbacks[] = {\r\n[POS_FIX_AUTO] = NULL,\r\n[POS_FIX_LPIB] = azx_get_pos_lpib,\r\n[POS_FIX_POSBUF] = azx_get_pos_posbuf,\r\n[POS_FIX_VIACOMBO] = azx_via_get_position,\r\n[POS_FIX_COMBO] = azx_get_pos_lpib,\r\n};\r\nchip->get_position[0] = chip->get_position[1] = callbacks[fix];\r\nif (fix == POS_FIX_COMBO)\r\nchip->get_position[1] = NULL;\r\nif (fix == POS_FIX_POSBUF &&\r\n(chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)) {\r\nchip->get_delay[0] = chip->get_delay[1] =\r\nazx_get_delay_from_lpib;\r\n}\r\n}\r\nstatic void check_probe_mask(struct azx *chip, int dev)\r\n{\r\nconst struct snd_pci_quirk *q;\r\nchip->codec_probe_mask = probe_mask[dev];\r\nif (chip->codec_probe_mask == -1) {\r\nq = snd_pci_quirk_lookup(chip->pci, probe_mask_list);\r\nif (q) {\r\ndev_info(chip->card->dev,\r\n"probe_mask set to 0x%x for device %04x:%04x\n",\r\nq->value, q->subvendor, q->subdevice);\r\nchip->codec_probe_mask = q->value;\r\n}\r\n}\r\nif (chip->codec_probe_mask != -1 &&\r\n(chip->codec_probe_mask & AZX_FORCE_CODEC_MASK)) {\r\nazx_bus(chip)->codec_mask = chip->codec_probe_mask & 0xff;\r\ndev_info(chip->card->dev, "codec_mask forced to 0x%x\n",\r\n(int)azx_bus(chip)->codec_mask);\r\n}\r\n}\r\nstatic void check_msi(struct azx *chip)\r\n{\r\nconst struct snd_pci_quirk *q;\r\nif (enable_msi >= 0) {\r\nchip->msi = !!enable_msi;\r\nreturn;\r\n}\r\nchip->msi = 1;\r\nq = snd_pci_quirk_lookup(chip->pci, msi_black_list);\r\nif (q) {\r\ndev_info(chip->card->dev,\r\n"msi for device %04x:%04x set to %d\n",\r\nq->subvendor, q->subdevice, q->value);\r\nchip->msi = q->value;\r\nreturn;\r\n}\r\nif (chip->driver_caps & AZX_DCAPS_NO_MSI) {\r\ndev_info(chip->card->dev, "Disabling MSI\n");\r\nchip->msi = 0;\r\n}\r\n}\r\nstatic void azx_check_snoop_available(struct azx *chip)\r\n{\r\nint snoop = hda_snoop;\r\nif (snoop >= 0) {\r\ndev_info(chip->card->dev, "Force to %s mode by module option\n",\r\nsnoop ? "snoop" : "non-snoop");\r\nchip->snoop = snoop;\r\nreturn;\r\n}\r\nsnoop = true;\r\nif (azx_get_snoop_type(chip) == AZX_SNOOP_TYPE_NONE &&\r\nchip->driver_type == AZX_DRIVER_VIA) {\r\nu8 val;\r\npci_read_config_byte(chip->pci, 0x42, &val);\r\nif (!(val & 0x80) && chip->pci->revision == 0x30)\r\nsnoop = false;\r\n}\r\nif (chip->driver_caps & AZX_DCAPS_SNOOP_OFF)\r\nsnoop = false;\r\nchip->snoop = snoop;\r\nif (!snoop)\r\ndev_info(chip->card->dev, "Force to non-snoop mode\n");\r\n}\r\nstatic void azx_probe_work(struct work_struct *work)\r\n{\r\nstruct hda_intel *hda = container_of(work, struct hda_intel, probe_work);\r\nazx_probe_continue(&hda->chip);\r\n}\r\nstatic int azx_create(struct snd_card *card, struct pci_dev *pci,\r\nint dev, unsigned int driver_caps,\r\nstruct azx **rchip)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_disconnect = azx_dev_disconnect,\r\n.dev_free = azx_dev_free,\r\n};\r\nstruct hda_intel *hda;\r\nstruct azx *chip;\r\nint err;\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\nhda = kzalloc(sizeof(*hda), GFP_KERNEL);\r\nif (!hda) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip = &hda->chip;\r\nmutex_init(&chip->open_mutex);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->ops = &pci_hda_ops;\r\nchip->driver_caps = driver_caps;\r\nchip->driver_type = driver_caps & 0xff;\r\ncheck_msi(chip);\r\nchip->dev_index = dev;\r\nchip->jackpoll_ms = jackpoll_ms;\r\nINIT_LIST_HEAD(&chip->pcm_list);\r\nINIT_WORK(&hda->irq_pending_work, azx_irq_pending_work);\r\nINIT_LIST_HEAD(&hda->list);\r\ninit_vga_switcheroo(chip);\r\ninit_completion(&hda->probe_wait);\r\nassign_position_fix(chip, check_position_fix(chip, position_fix[dev]));\r\ncheck_probe_mask(chip, dev);\r\nchip->single_cmd = single_cmd;\r\nazx_check_snoop_available(chip);\r\nif (bdl_pos_adj[dev] < 0) {\r\nswitch (chip->driver_type) {\r\ncase AZX_DRIVER_ICH:\r\ncase AZX_DRIVER_PCH:\r\nbdl_pos_adj[dev] = 1;\r\nbreak;\r\ndefault:\r\nbdl_pos_adj[dev] = 32;\r\nbreak;\r\n}\r\n}\r\nchip->bdl_pos_adj = bdl_pos_adj;\r\nerr = azx_bus_init(chip, model[dev], &pci_hda_io_ops);\r\nif (err < 0) {\r\nkfree(hda);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\ndev_err(card->dev, "Error creating device [card]!\n");\r\nazx_free(chip);\r\nreturn err;\r\n}\r\nINIT_WORK(&hda->probe_work, azx_probe_work);\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic int azx_first_init(struct azx *chip)\r\n{\r\nint dev = chip->dev_index;\r\nstruct pci_dev *pci = chip->pci;\r\nstruct snd_card *card = chip->card;\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nint err;\r\nunsigned short gcap;\r\nunsigned int dma_bits = 64;\r\n#if BITS_PER_LONG != 64\r\nif (chip->driver_type == AZX_DRIVER_ULI) {\r\nu16 tmp3;\r\npci_read_config_word(pci, 0x40, &tmp3);\r\npci_write_config_word(pci, 0x40, tmp3 | 0x10);\r\npci_write_config_dword(pci, PCI_BASE_ADDRESS_1, 0);\r\n}\r\n#endif\r\nerr = pci_request_regions(pci, "ICH HD audio");\r\nif (err < 0)\r\nreturn err;\r\nchip->region_requested = 1;\r\nbus->addr = pci_resource_start(pci, 0);\r\nbus->remap_addr = pci_ioremap_bar(pci, 0);\r\nif (bus->remap_addr == NULL) {\r\ndev_err(card->dev, "ioremap error\n");\r\nreturn -ENXIO;\r\n}\r\nif (chip->msi) {\r\nif (chip->driver_caps & AZX_DCAPS_NO_MSI64) {\r\ndev_dbg(card->dev, "Disabling 64bit MSI\n");\r\npci->no_64bit_msi = true;\r\n}\r\nif (pci_enable_msi(pci) < 0)\r\nchip->msi = 0;\r\n}\r\nif (azx_acquire_irq(chip, 0) < 0)\r\nreturn -EBUSY;\r\npci_set_master(pci);\r\nsynchronize_irq(bus->irq);\r\ngcap = azx_readw(chip, GCAP);\r\ndev_dbg(card->dev, "chipset global capabilities = 0x%x\n", gcap);\r\nif (chip->pci->vendor == PCI_VENDOR_ID_AMD)\r\ndma_bits = 40;\r\nif (chip->pci->vendor == PCI_VENDOR_ID_ATI) {\r\nstruct pci_dev *p_smbus;\r\ndma_bits = 40;\r\np_smbus = pci_get_device(PCI_VENDOR_ID_ATI,\r\nPCI_DEVICE_ID_ATI_SBX00_SMBUS,\r\nNULL);\r\nif (p_smbus) {\r\nif (p_smbus->revision < 0x30)\r\ngcap &= ~AZX_GCAP_64OK;\r\npci_dev_put(p_smbus);\r\n}\r\n}\r\nif (chip->driver_caps & AZX_DCAPS_NO_64BIT) {\r\ndev_dbg(card->dev, "Disabling 64bit DMA\n");\r\ngcap &= ~AZX_GCAP_64OK;\r\n}\r\nif (align_buffer_size >= 0)\r\nchip->align_buffer_size = !!align_buffer_size;\r\nelse {\r\nif (chip->driver_caps & AZX_DCAPS_NO_ALIGN_BUFSIZE)\r\nchip->align_buffer_size = 0;\r\nelse\r\nchip->align_buffer_size = 1;\r\n}\r\nif (!(gcap & AZX_GCAP_64OK))\r\ndma_bits = 32;\r\nif (!dma_set_mask(&pci->dev, DMA_BIT_MASK(dma_bits))) {\r\ndma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(dma_bits));\r\n} else {\r\ndma_set_mask(&pci->dev, DMA_BIT_MASK(32));\r\ndma_set_coherent_mask(&pci->dev, DMA_BIT_MASK(32));\r\n}\r\nchip->capture_streams = (gcap >> 8) & 0x0f;\r\nchip->playback_streams = (gcap >> 12) & 0x0f;\r\nif (!chip->playback_streams && !chip->capture_streams) {\r\nswitch (chip->driver_type) {\r\ncase AZX_DRIVER_ULI:\r\nchip->playback_streams = ULI_NUM_PLAYBACK;\r\nchip->capture_streams = ULI_NUM_CAPTURE;\r\nbreak;\r\ncase AZX_DRIVER_ATIHDMI:\r\ncase AZX_DRIVER_ATIHDMI_NS:\r\nchip->playback_streams = ATIHDMI_NUM_PLAYBACK;\r\nchip->capture_streams = ATIHDMI_NUM_CAPTURE;\r\nbreak;\r\ncase AZX_DRIVER_GENERIC:\r\ndefault:\r\nchip->playback_streams = ICH6_NUM_PLAYBACK;\r\nchip->capture_streams = ICH6_NUM_CAPTURE;\r\nbreak;\r\n}\r\n}\r\nchip->capture_index_offset = 0;\r\nchip->playback_index_offset = chip->capture_streams;\r\nchip->num_streams = chip->playback_streams + chip->capture_streams;\r\nerr = azx_init_streams(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = azx_alloc_stream_pages(chip);\r\nif (err < 0)\r\nreturn err;\r\nazx_init_pci(chip);\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {\r\nstruct hda_intel *hda;\r\nhda = container_of(chip, struct hda_intel, chip);\r\nhaswell_set_bclk(hda);\r\n}\r\nhda_intel_init_chip(chip, (probe_only[dev] & 2) == 0);\r\nif (!azx_bus(chip)->codec_mask) {\r\ndev_err(card->dev, "no codecs found!\n");\r\nreturn -ENODEV;\r\n}\r\nstrcpy(card->driver, "HDA-Intel");\r\nstrlcpy(card->shortname, driver_short_names[chip->driver_type],\r\nsizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx irq %i",\r\ncard->shortname, bus->addr, bus->irq);\r\nreturn 0;\r\n}\r\nstatic void azx_firmware_cb(const struct firmware *fw, void *context)\r\n{\r\nstruct snd_card *card = context;\r\nstruct azx *chip = card->private_data;\r\nstruct pci_dev *pci = chip->pci;\r\nif (!fw) {\r\ndev_err(card->dev, "Cannot load firmware, aborting\n");\r\ngoto error;\r\n}\r\nchip->fw = fw;\r\nif (!chip->disabled) {\r\nif (azx_probe_continue(chip))\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\nsnd_card_free(card);\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic void pci_azx_writel(u32 value, u32 __iomem *addr)\r\n{\r\nwritel(value, addr);\r\n}\r\nstatic u32 pci_azx_readl(u32 __iomem *addr)\r\n{\r\nreturn readl(addr);\r\n}\r\nstatic void pci_azx_writew(u16 value, u16 __iomem *addr)\r\n{\r\nwritew(value, addr);\r\n}\r\nstatic u16 pci_azx_readw(u16 __iomem *addr)\r\n{\r\nreturn readw(addr);\r\n}\r\nstatic void pci_azx_writeb(u8 value, u8 __iomem *addr)\r\n{\r\nwriteb(value, addr);\r\n}\r\nstatic u8 pci_azx_readb(u8 __iomem *addr)\r\n{\r\nreturn readb(addr);\r\n}\r\nstatic int disable_msi_reset_irq(struct azx *chip)\r\n{\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nint err;\r\nfree_irq(bus->irq, chip);\r\nbus->irq = -1;\r\npci_disable_msi(chip->pci);\r\nchip->msi = 0;\r\nerr = azx_acquire_irq(chip, 1);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int dma_alloc_pages(struct hdac_bus *bus,\r\nint type,\r\nsize_t size,\r\nstruct snd_dma_buffer *buf)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nint err;\r\nerr = snd_dma_alloc_pages(type,\r\nbus->dev,\r\nsize, buf);\r\nif (err < 0)\r\nreturn err;\r\nmark_pages_wc(chip, buf, true);\r\nreturn 0;\r\n}\r\nstatic void dma_free_pages(struct hdac_bus *bus, struct snd_dma_buffer *buf)\r\n{\r\nstruct azx *chip = bus_to_azx(bus);\r\nmark_pages_wc(chip, buf, false);\r\nsnd_dma_free_pages(buf);\r\n}\r\nstatic int substream_alloc_pages(struct azx *chip,\r\nstruct snd_pcm_substream *substream,\r\nsize_t size)\r\n{\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nint ret;\r\nmark_runtime_wc(chip, azx_dev, substream, false);\r\nret = snd_pcm_lib_malloc_pages(substream, size);\r\nif (ret < 0)\r\nreturn ret;\r\nmark_runtime_wc(chip, azx_dev, substream, true);\r\nreturn 0;\r\n}\r\nstatic int substream_free_pages(struct azx *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct azx_dev *azx_dev = get_azx_dev(substream);\r\nmark_runtime_wc(chip, azx_dev, substream, false);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void pcm_mmap_prepare(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *area)\r\n{\r\n#ifdef CONFIG_X86\r\nstruct azx_pcm *apcm = snd_pcm_substream_chip(substream);\r\nstruct azx *chip = apcm->chip;\r\nif (!azx_snoop(chip) && chip->driver_type != AZX_DRIVER_CMEDIA)\r\narea->vm_page_prot = pgprot_writecombine(area->vm_page_prot);\r\n#endif\r\n}\r\nstatic int azx_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct hda_intel *hda;\r\nstruct azx *chip;\r\nbool schedule_probe;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0) {\r\ndev_err(&pci->dev, "Error creating card!\n");\r\nreturn err;\r\n}\r\nerr = azx_create(card, pci, dev, pci_id->driver_data, &chip);\r\nif (err < 0)\r\ngoto out_free;\r\ncard->private_data = chip;\r\nhda = container_of(chip, struct hda_intel, chip);\r\npci_set_drvdata(pci, card);\r\nerr = register_vga_switcheroo(chip);\r\nif (err < 0) {\r\ndev_err(card->dev, "Error registering VGA-switcheroo client\n");\r\ngoto out_free;\r\n}\r\nif (check_hdmi_disabled(pci)) {\r\ndev_info(card->dev, "VGA controller is disabled\n");\r\ndev_info(card->dev, "Delaying initialization\n");\r\nchip->disabled = true;\r\n}\r\nschedule_probe = !chip->disabled;\r\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\r\nif (patch[dev] && *patch[dev]) {\r\ndev_info(card->dev, "Applying patch firmware '%s'\n",\r\npatch[dev]);\r\nerr = request_firmware_nowait(THIS_MODULE, true, patch[dev],\r\n&pci->dev, GFP_KERNEL, card,\r\nazx_firmware_cb);\r\nif (err < 0)\r\ngoto out_free;\r\nschedule_probe = false;\r\n}\r\n#endif\r\n#ifndef CONFIG_SND_HDA_I915\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)\r\ndev_err(card->dev, "Haswell must build in CONFIG_SND_HDA_I915\n");\r\n#endif\r\nif (schedule_probe)\r\nschedule_work(&hda->probe_work);\r\ndev++;\r\nif (chip->disabled)\r\ncomplete_all(&hda->probe_wait);\r\nreturn 0;\r\nout_free:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int azx_probe_continue(struct azx *chip)\r\n{\r\nstruct hda_intel *hda = container_of(chip, struct hda_intel, chip);\r\nstruct hdac_bus *bus = azx_bus(chip);\r\nstruct pci_dev *pci = chip->pci;\r\nint dev = chip->dev_index;\r\nint err;\r\nhda->probe_continued = 1;\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {\r\nif (CONTROLLER_IN_GPU(pci))\r\nhda->need_i915_power = 1;\r\nerr = snd_hdac_i915_init(bus);\r\nif (err < 0) {\r\nif (CONTROLLER_IN_GPU(pci))\r\ngoto out_free;\r\nelse\r\ngoto skip_i915;\r\n}\r\nerr = snd_hdac_display_power(bus, true);\r\nif (err < 0) {\r\ndev_err(chip->card->dev,\r\n"Cannot turn on display power on i915\n");\r\ngoto i915_power_fail;\r\n}\r\n}\r\nskip_i915:\r\nerr = azx_first_init(chip);\r\nif (err < 0)\r\ngoto out_free;\r\n#ifdef CONFIG_SND_HDA_INPUT_BEEP\r\nchip->beep_mode = beep_mode[dev];\r\n#endif\r\nerr = azx_probe_codecs(chip, azx_max_codecs[chip->driver_type]);\r\nif (err < 0)\r\ngoto out_free;\r\n#ifdef CONFIG_SND_HDA_PATCH_LOADER\r\nif (chip->fw) {\r\nerr = snd_hda_load_patch(&chip->bus, chip->fw->size,\r\nchip->fw->data);\r\nif (err < 0)\r\ngoto out_free;\r\n#ifndef CONFIG_PM\r\nrelease_firmware(chip->fw);\r\nchip->fw = NULL;\r\n#endif\r\n}\r\n#endif\r\nif ((probe_only[dev] & 1) == 0) {\r\nerr = azx_codec_configure(chip);\r\nif (err < 0)\r\ngoto out_free;\r\n}\r\nerr = snd_card_register(chip->card);\r\nif (err < 0)\r\ngoto out_free;\r\nchip->running = 1;\r\nazx_add_card_list(chip);\r\nsnd_hda_set_power_save(&chip->bus, power_save * 1000);\r\nif (azx_has_pm_runtime(chip) || hda->use_vga_switcheroo)\r\npm_runtime_put_noidle(&pci->dev);\r\nout_free:\r\nif (chip->driver_caps & AZX_DCAPS_I915_POWERWELL\r\n&& !hda->need_i915_power)\r\nsnd_hdac_display_power(bus, false);\r\ni915_power_fail:\r\nif (err < 0)\r\nhda->init_failed = 1;\r\ncomplete_all(&hda->probe_wait);\r\nreturn err;\r\n}\r\nstatic void azx_remove(struct pci_dev *pci)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nif (card)\r\nsnd_card_free(card);\r\n}\r\nstatic void azx_shutdown(struct pci_dev *pci)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nstruct azx *chip;\r\nif (!card)\r\nreturn;\r\nchip = card->private_data;\r\nif (chip && chip->running)\r\nazx_stop_chip(chip);\r\n}
