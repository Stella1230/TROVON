static void uas_do_work(struct work_struct *work)\r\n{\r\nstruct uas_dev_info *devinfo =\r\ncontainer_of(work, struct uas_dev_info, work);\r\nstruct uas_cmd_info *cmdinfo;\r\nstruct scsi_cmnd *cmnd;\r\nunsigned long flags;\r\nint i, err;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (devinfo->resetting)\r\ngoto out;\r\nfor (i = 0; i < devinfo->qdepth; i++) {\r\nif (!devinfo->cmnd[i])\r\ncontinue;\r\ncmnd = devinfo->cmnd[i];\r\ncmdinfo = (void *)&cmnd->SCp;\r\nif (!(cmdinfo->state & IS_IN_WORK_LIST))\r\ncontinue;\r\nerr = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);\r\nif (!err)\r\ncmdinfo->state &= ~IS_IN_WORK_LIST;\r\nelse\r\nschedule_work(&devinfo->work);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_add_work(struct uas_cmd_info *cmdinfo)\r\n{\r\nstruct scsi_pointer *scp = (void *)cmdinfo;\r\nstruct scsi_cmnd *cmnd = container_of(scp, struct scsi_cmnd, SCp);\r\nstruct uas_dev_info *devinfo = cmnd->device->hostdata;\r\nlockdep_assert_held(&devinfo->lock);\r\ncmdinfo->state |= IS_IN_WORK_LIST;\r\nschedule_work(&devinfo->work);\r\n}\r\nstatic void uas_zap_pending(struct uas_dev_info *devinfo, int result)\r\n{\r\nstruct uas_cmd_info *cmdinfo;\r\nstruct scsi_cmnd *cmnd;\r\nunsigned long flags;\r\nint i, err;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nfor (i = 0; i < devinfo->qdepth; i++) {\r\nif (!devinfo->cmnd[i])\r\ncontinue;\r\ncmnd = devinfo->cmnd[i];\r\ncmdinfo = (void *)&cmnd->SCp;\r\nuas_log_cmd_state(cmnd, __func__, 0);\r\ncmdinfo->state &= ~COMMAND_INFLIGHT;\r\ncmnd->result = result << 16;\r\nerr = uas_try_complete(cmnd, __func__);\r\nWARN_ON(err != 0);\r\n}\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\r\n{\r\nstruct sense_iu *sense_iu = urb->transfer_buffer;\r\nstruct scsi_device *sdev = cmnd->device;\r\nif (urb->actual_length > 16) {\r\nunsigned len = be16_to_cpup(&sense_iu->len);\r\nif (len + 16 != urb->actual_length) {\r\nint newlen = min(len + 16, urb->actual_length) - 16;\r\nif (newlen < 0)\r\nnewlen = 0;\r\nsdev_printk(KERN_INFO, sdev, "%s: urb length %d "\r\n"disagrees with IU sense data length %d, "\r\n"using %d bytes of sense data\n", __func__,\r\nurb->actual_length, len, newlen);\r\nlen = newlen;\r\n}\r\nmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\r\n}\r\ncmnd->result = sense_iu->status;\r\n}\r\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\r\nint status)\r\n{\r\nstruct uas_cmd_info *ci = (void *)&cmnd->SCp;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nscmd_printk(KERN_INFO, cmnd,\r\n"%s %d uas-tag %d inflight:%s%s%s%s%s%s%s%s%s%s%s%s ",\r\nprefix, status, cmdinfo->uas_tag,\r\n(ci->state & SUBMIT_STATUS_URB) ? " s-st" : "",\r\n(ci->state & ALLOC_DATA_IN_URB) ? " a-in" : "",\r\n(ci->state & SUBMIT_DATA_IN_URB) ? " s-in" : "",\r\n(ci->state & ALLOC_DATA_OUT_URB) ? " a-out" : "",\r\n(ci->state & SUBMIT_DATA_OUT_URB) ? " s-out" : "",\r\n(ci->state & ALLOC_CMD_URB) ? " a-cmd" : "",\r\n(ci->state & SUBMIT_CMD_URB) ? " s-cmd" : "",\r\n(ci->state & COMMAND_INFLIGHT) ? " CMD" : "",\r\n(ci->state & DATA_IN_URB_INFLIGHT) ? " IN" : "",\r\n(ci->state & DATA_OUT_URB_INFLIGHT) ? " OUT" : "",\r\n(ci->state & COMMAND_ABORTED) ? " abort" : "",\r\n(ci->state & IS_IN_WORK_LIST) ? " work" : "");\r\nscsi_print_command(cmnd);\r\n}\r\nstatic void uas_free_unsubmitted_urbs(struct scsi_cmnd *cmnd)\r\n{\r\nstruct uas_cmd_info *cmdinfo;\r\nif (!cmnd)\r\nreturn;\r\ncmdinfo = (void *)&cmnd->SCp;\r\nif (cmdinfo->state & SUBMIT_CMD_URB)\r\nusb_free_urb(cmdinfo->cmd_urb);\r\nif (!(cmdinfo->state & DATA_IN_URB_INFLIGHT))\r\nusb_free_urb(cmdinfo->data_in_urb);\r\nif (!(cmdinfo->state & DATA_OUT_URB_INFLIGHT))\r\nusb_free_urb(cmdinfo->data_out_urb);\r\n}\r\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nlockdep_assert_held(&devinfo->lock);\r\nif (cmdinfo->state & (COMMAND_INFLIGHT |\r\nDATA_IN_URB_INFLIGHT |\r\nDATA_OUT_URB_INFLIGHT |\r\nCOMMAND_ABORTED))\r\nreturn -EBUSY;\r\ndevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\r\nuas_free_unsubmitted_urbs(cmnd);\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nstatic void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,\r\nunsigned direction)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nint err;\r\ncmdinfo->state |= direction | SUBMIT_STATUS_URB;\r\nerr = uas_submit_urbs(cmnd, cmnd->device->hostdata, GFP_ATOMIC);\r\nif (err) {\r\nuas_add_work(cmdinfo);\r\n}\r\n}\r\nstatic void uas_stat_cmplt(struct urb *urb)\r\n{\r\nstruct iu *iu = urb->transfer_buffer;\r\nstruct Scsi_Host *shost = urb->context;\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nstruct urb *data_in_urb = NULL;\r\nstruct urb *data_out_urb = NULL;\r\nstruct scsi_cmnd *cmnd;\r\nstruct uas_cmd_info *cmdinfo;\r\nunsigned long flags;\r\nunsigned int idx;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (devinfo->resetting)\r\ngoto out;\r\nif (urb->status) {\r\nif (urb->status != -ENOENT && urb->status != -ECONNRESET) {\r\ndev_err(&urb->dev->dev, "stat urb: status %d\n",\r\nurb->status);\r\n}\r\ngoto out;\r\n}\r\nidx = be16_to_cpup(&iu->tag) - 1;\r\nif (idx >= MAX_CMNDS || !devinfo->cmnd[idx]) {\r\ndev_err(&urb->dev->dev,\r\n"stat urb: no pending cmd for uas-tag %d\n", idx + 1);\r\ngoto out;\r\n}\r\ncmnd = devinfo->cmnd[idx];\r\ncmdinfo = (void *)&cmnd->SCp;\r\nif (!(cmdinfo->state & COMMAND_INFLIGHT)) {\r\nuas_log_cmd_state(cmnd, "unexpected status cmplt", 0);\r\ngoto out;\r\n}\r\nswitch (iu->iu_id) {\r\ncase IU_ID_STATUS:\r\nuas_sense(urb, cmnd);\r\nif (cmnd->result != 0) {\r\ndata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\r\ndata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\r\n}\r\ncmdinfo->state &= ~COMMAND_INFLIGHT;\r\nuas_try_complete(cmnd, __func__);\r\nbreak;\r\ncase IU_ID_READ_READY:\r\nif (!cmdinfo->data_in_urb ||\r\n(cmdinfo->state & DATA_IN_URB_INFLIGHT)) {\r\nuas_log_cmd_state(cmnd, "unexpected read rdy", 0);\r\nbreak;\r\n}\r\nuas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);\r\nbreak;\r\ncase IU_ID_WRITE_READY:\r\nif (!cmdinfo->data_out_urb ||\r\n(cmdinfo->state & DATA_OUT_URB_INFLIGHT)) {\r\nuas_log_cmd_state(cmnd, "unexpected write rdy", 0);\r\nbreak;\r\n}\r\nuas_xfer_data(urb, cmnd, SUBMIT_DATA_OUT_URB);\r\nbreak;\r\ncase IU_ID_RESPONSE:\r\nuas_log_cmd_state(cmnd, "unexpected response iu",\r\n((struct response_iu *)iu)->response_code);\r\ndata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\r\ndata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\r\ncmdinfo->state &= ~COMMAND_INFLIGHT;\r\ncmnd->result = DID_ERROR << 16;\r\nuas_try_complete(cmnd, __func__);\r\nbreak;\r\ndefault:\r\nuas_log_cmd_state(cmnd, "bogus IU", iu->iu_id);\r\n}\r\nout:\r\nusb_free_urb(urb);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nif (data_in_urb) {\r\nusb_unlink_urb(data_in_urb);\r\nusb_put_urb(data_in_urb);\r\n}\r\nif (data_out_urb) {\r\nusb_unlink_urb(data_out_urb);\r\nusb_put_urb(data_out_urb);\r\n}\r\n}\r\nstatic void uas_data_cmplt(struct urb *urb)\r\n{\r\nstruct scsi_cmnd *cmnd = urb->context;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\r\nstruct scsi_data_buffer *sdb = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (cmdinfo->data_in_urb == urb) {\r\nsdb = scsi_in(cmnd);\r\ncmdinfo->state &= ~DATA_IN_URB_INFLIGHT;\r\ncmdinfo->data_in_urb = NULL;\r\n} else if (cmdinfo->data_out_urb == urb) {\r\nsdb = scsi_out(cmnd);\r\ncmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;\r\ncmdinfo->data_out_urb = NULL;\r\n}\r\nif (sdb == NULL) {\r\nWARN_ON_ONCE(1);\r\ngoto out;\r\n}\r\nif (devinfo->resetting)\r\ngoto out;\r\nif (cmdinfo->state & SUBMIT_CMD_URB) {\r\nuas_log_cmd_state(cmnd, "unexpected data cmplt", 0);\r\ngoto out;\r\n}\r\nif (urb->status) {\r\nif (urb->status != -ENOENT && urb->status != -ECONNRESET)\r\nuas_log_cmd_state(cmnd, "data cmplt err", urb->status);\r\nsdb->resid = sdb->length;\r\n} else {\r\nsdb->resid = sdb->length - urb->actual_length;\r\n}\r\nuas_try_complete(cmnd, __func__);\r\nout:\r\nusb_free_urb(urb);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\n}\r\nstatic void uas_cmd_cmplt(struct urb *urb)\r\n{\r\nif (urb->status)\r\ndev_err(&urb->dev->dev, "cmd cmplt err %d\n", urb->status);\r\nusb_free_urb(urb);\r\n}\r\nstatic struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct scsi_cmnd *cmnd,\r\nenum dma_data_direction dir)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct scsi_data_buffer *sdb = (dir == DMA_FROM_DEVICE)\r\n? scsi_in(cmnd) : scsi_out(cmnd);\r\nunsigned int pipe = (dir == DMA_FROM_DEVICE)\r\n? devinfo->data_in_pipe : devinfo->data_out_pipe;\r\nif (!urb)\r\ngoto out;\r\nusb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,\r\nuas_data_cmplt, cmnd);\r\nif (devinfo->use_streams)\r\nurb->stream_id = cmdinfo->uas_tag;\r\nurb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;\r\nurb->sg = sdb->table.sgl;\r\nout:\r\nreturn urb;\r\n}\r\nstatic struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct scsi_cmnd *cmnd)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct sense_iu *iu;\r\nif (!urb)\r\ngoto out;\r\niu = kzalloc(sizeof(*iu), gfp);\r\nif (!iu)\r\ngoto free;\r\nusb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),\r\nuas_stat_cmplt, cmnd->device->host);\r\nif (devinfo->use_streams)\r\nurb->stream_id = cmdinfo->uas_tag;\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nout:\r\nreturn urb;\r\nfree:\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nstatic struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\r\nstruct scsi_cmnd *cmnd)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct urb *urb = usb_alloc_urb(0, gfp);\r\nstruct command_iu *iu;\r\nint len;\r\nif (!urb)\r\ngoto out;\r\nlen = cmnd->cmd_len - 16;\r\nif (len < 0)\r\nlen = 0;\r\nlen = ALIGN(len, 4);\r\niu = kzalloc(sizeof(*iu) + len, gfp);\r\nif (!iu)\r\ngoto free;\r\niu->iu_id = IU_ID_COMMAND;\r\niu->tag = cpu_to_be16(cmdinfo->uas_tag);\r\niu->prio_attr = UAS_SIMPLE_TAG;\r\niu->len = len;\r\nint_to_scsilun(sdev->lun, &iu->lun);\r\nmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\r\nusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\r\nuas_cmd_cmplt, NULL);\r\nurb->transfer_flags |= URB_FREE_BUFFER;\r\nout:\r\nreturn urb;\r\nfree:\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nstatic struct urb *uas_submit_sense_urb(struct scsi_cmnd *cmnd, gfp_t gfp)\r\n{\r\nstruct uas_dev_info *devinfo = cmnd->device->hostdata;\r\nstruct urb *urb;\r\nint err;\r\nurb = uas_alloc_sense_urb(devinfo, gfp, cmnd);\r\nif (!urb)\r\nreturn NULL;\r\nusb_anchor_urb(urb, &devinfo->sense_urbs);\r\nerr = usb_submit_urb(urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nuas_log_cmd_state(cmnd, "sense submit err", err);\r\nusb_free_urb(urb);\r\nreturn NULL;\r\n}\r\nreturn urb;\r\n}\r\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\r\nstruct uas_dev_info *devinfo, gfp_t gfp)\r\n{\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nstruct urb *urb;\r\nint err;\r\nlockdep_assert_held(&devinfo->lock);\r\nif (cmdinfo->state & SUBMIT_STATUS_URB) {\r\nurb = uas_submit_sense_urb(cmnd, gfp);\r\nif (!urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~SUBMIT_STATUS_URB;\r\n}\r\nif (cmdinfo->state & ALLOC_DATA_IN_URB) {\r\ncmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, gfp,\r\ncmnd, DMA_FROM_DEVICE);\r\nif (!cmdinfo->data_in_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_DATA_IN_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_DATA_IN_URB) {\r\nusb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);\r\nerr = usb_submit_urb(cmdinfo->data_in_urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(cmdinfo->data_in_urb);\r\nuas_log_cmd_state(cmnd, "data in submit err", err);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->state &= ~SUBMIT_DATA_IN_URB;\r\ncmdinfo->state |= DATA_IN_URB_INFLIGHT;\r\n}\r\nif (cmdinfo->state & ALLOC_DATA_OUT_URB) {\r\ncmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, gfp,\r\ncmnd, DMA_TO_DEVICE);\r\nif (!cmdinfo->data_out_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_DATA_OUT_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_DATA_OUT_URB) {\r\nusb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);\r\nerr = usb_submit_urb(cmdinfo->data_out_urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(cmdinfo->data_out_urb);\r\nuas_log_cmd_state(cmnd, "data out submit err", err);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->state &= ~SUBMIT_DATA_OUT_URB;\r\ncmdinfo->state |= DATA_OUT_URB_INFLIGHT;\r\n}\r\nif (cmdinfo->state & ALLOC_CMD_URB) {\r\ncmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, gfp, cmnd);\r\nif (!cmdinfo->cmd_urb)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\ncmdinfo->state &= ~ALLOC_CMD_URB;\r\n}\r\nif (cmdinfo->state & SUBMIT_CMD_URB) {\r\nusb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);\r\nerr = usb_submit_urb(cmdinfo->cmd_urb, gfp);\r\nif (err) {\r\nusb_unanchor_urb(cmdinfo->cmd_urb);\r\nuas_log_cmd_state(cmnd, "cmd submit err", err);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmdinfo->cmd_urb = NULL;\r\ncmdinfo->state &= ~SUBMIT_CMD_URB;\r\ncmdinfo->state |= COMMAND_INFLIGHT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uas_queuecommand_lck(struct scsi_cmnd *cmnd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\r\nunsigned long flags;\r\nint idx, err;\r\nBUILD_BUG_ON(sizeof(struct uas_cmd_info) > sizeof(struct scsi_pointer));\r\nif (cmnd->device->host->host_self_blocked)\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nif ((devinfo->flags & US_FL_NO_ATA_1X) &&\r\n(cmnd->cmnd[0] == ATA_12 || cmnd->cmnd[0] == ATA_16)) {\r\nmemcpy(cmnd->sense_buffer, usb_stor_sense_invalidCDB,\r\nsizeof(usb_stor_sense_invalidCDB));\r\ncmnd->result = SAM_STAT_CHECK_CONDITION;\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nif (devinfo->resetting) {\r\ncmnd->result = DID_ERROR << 16;\r\ncmnd->scsi_done(cmnd);\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn 0;\r\n}\r\nfor (idx = 0; idx < devinfo->qdepth; idx++) {\r\nif (!devinfo->cmnd[idx])\r\nbreak;\r\n}\r\nif (idx == devinfo->qdepth) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\ncmnd->scsi_done = done;\r\nmemset(cmdinfo, 0, sizeof(*cmdinfo));\r\ncmdinfo->uas_tag = idx + 1;\r\ncmdinfo->state = SUBMIT_STATUS_URB | ALLOC_CMD_URB | SUBMIT_CMD_URB;\r\nswitch (cmnd->sc_data_direction) {\r\ncase DMA_FROM_DEVICE:\r\ncmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\ncmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\r\ncase DMA_TO_DEVICE:\r\ncmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;\r\ncase DMA_NONE:\r\nbreak;\r\n}\r\nif (!devinfo->use_streams)\r\ncmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);\r\nerr = uas_submit_urbs(cmnd, devinfo, GFP_ATOMIC);\r\nif (err) {\r\nif (cmdinfo->state & SUBMIT_STATUS_URB) {\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\n}\r\nuas_add_work(cmdinfo);\r\n}\r\ndevinfo->cmnd[idx] = cmnd;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn 0;\r\n}\r\nint uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct scsi_device *sdev = cmnd->device;\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nstruct usb_device *udev = devinfo->udev;\r\nunsigned long flags;\r\nint err;\r\nerr = usb_lock_device_for_reset(udev, devinfo->intf);\r\nif (err) {\r\nshost_printk(KERN_ERR, sdev->host,\r\n"%s FAILED to get lock err %d\n", __func__, err);\r\nreturn FAILED;\r\n}\r\nshost_printk(KERN_INFO, sdev->host, "%s start\n", __func__);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ndevinfo->resetting = 1;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nusb_kill_anchored_urbs(&devinfo->cmd_urbs);\r\nusb_kill_anchored_urbs(&devinfo->sense_urbs);\r\nusb_kill_anchored_urbs(&devinfo->data_urbs);\r\nuas_zap_pending(devinfo, DID_RESET);\r\nerr = usb_reset_device(udev);\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ndevinfo->resetting = 0;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nusb_unlock_device(udev);\r\nif (err) {\r\nshost_printk(KERN_INFO, sdev->host, "%s FAILED err %d\n",\r\n__func__, err);\r\nreturn FAILED;\r\n}\r\nshost_printk(KERN_INFO, sdev->host, "%s success\n", __func__);\r\nreturn SUCCESS;\r\n}\r\nstatic int uas_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct uas_dev_info *devinfo =\r\n(struct uas_dev_info *)sdev->host->hostdata;\r\nsdev->hostdata = devinfo;\r\nblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\r\nif (devinfo->flags & US_FL_MAX_SECTORS_64)\r\nblk_queue_max_hw_sectors(sdev->request_queue, 64);\r\nelse if (devinfo->flags & US_FL_MAX_SECTORS_240)\r\nblk_queue_max_hw_sectors(sdev->request_queue, 240);\r\nreturn 0;\r\n}\r\nstatic int uas_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct uas_dev_info *devinfo = sdev->hostdata;\r\nif (devinfo->flags & US_FL_NO_REPORT_OPCODES)\r\nsdev->no_report_opcodes = 1;\r\nscsi_change_queue_depth(sdev, devinfo->qdepth - 2);\r\nreturn 0;\r\n}\r\nstatic int uas_switch_interface(struct usb_device *udev,\r\nstruct usb_interface *intf)\r\n{\r\nint alt;\r\nalt = uas_find_uas_alt_setting(intf);\r\nif (alt < 0)\r\nreturn alt;\r\nreturn usb_set_interface(udev,\r\nintf->altsetting[0].desc.bInterfaceNumber, alt);\r\n}\r\nstatic int uas_configure_endpoints(struct uas_dev_info *devinfo)\r\n{\r\nstruct usb_host_endpoint *eps[4] = { };\r\nstruct usb_device *udev = devinfo->udev;\r\nint r;\r\nr = uas_find_endpoints(devinfo->intf->cur_altsetting, eps);\r\nif (r)\r\nreturn r;\r\ndevinfo->cmd_pipe = usb_sndbulkpipe(udev,\r\nusb_endpoint_num(&eps[0]->desc));\r\ndevinfo->status_pipe = usb_rcvbulkpipe(udev,\r\nusb_endpoint_num(&eps[1]->desc));\r\ndevinfo->data_in_pipe = usb_rcvbulkpipe(udev,\r\nusb_endpoint_num(&eps[2]->desc));\r\ndevinfo->data_out_pipe = usb_sndbulkpipe(udev,\r\nusb_endpoint_num(&eps[3]->desc));\r\nif (udev->speed < USB_SPEED_SUPER) {\r\ndevinfo->qdepth = 32;\r\ndevinfo->use_streams = 0;\r\n} else {\r\ndevinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1,\r\n3, MAX_CMNDS, GFP_NOIO);\r\nif (devinfo->qdepth < 0)\r\nreturn devinfo->qdepth;\r\ndevinfo->use_streams = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void uas_free_streams(struct uas_dev_info *devinfo)\r\n{\r\nstruct usb_device *udev = devinfo->udev;\r\nstruct usb_host_endpoint *eps[3];\r\neps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);\r\neps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\r\neps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\r\nusb_free_streams(devinfo->intf, eps, 3, GFP_NOIO);\r\n}\r\nstatic int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nint result = -ENOMEM;\r\nstruct Scsi_Host *shost = NULL;\r\nstruct uas_dev_info *devinfo;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nunsigned long dev_flags;\r\nif (!uas_use_uas_driver(intf, id, &dev_flags))\r\nreturn -ENODEV;\r\nif (uas_switch_interface(udev, intf))\r\nreturn -ENODEV;\r\nshost = scsi_host_alloc(&uas_host_template,\r\nsizeof(struct uas_dev_info));\r\nif (!shost)\r\ngoto set_alt0;\r\nshost->max_cmd_len = 16 + 252;\r\nshost->max_id = 1;\r\nshost->max_lun = 256;\r\nshost->max_channel = 0;\r\nshost->sg_tablesize = udev->bus->sg_tablesize;\r\ndevinfo = (struct uas_dev_info *)shost->hostdata;\r\ndevinfo->intf = intf;\r\ndevinfo->udev = udev;\r\ndevinfo->resetting = 0;\r\ndevinfo->shutdown = 0;\r\ndevinfo->flags = dev_flags;\r\ninit_usb_anchor(&devinfo->cmd_urbs);\r\ninit_usb_anchor(&devinfo->sense_urbs);\r\ninit_usb_anchor(&devinfo->data_urbs);\r\nspin_lock_init(&devinfo->lock);\r\nINIT_WORK(&devinfo->work, uas_do_work);\r\nresult = uas_configure_endpoints(devinfo);\r\nif (result)\r\ngoto set_alt0;\r\nresult = scsi_init_shared_tag_map(shost, devinfo->qdepth - 2);\r\nif (result)\r\ngoto free_streams;\r\nusb_set_intfdata(intf, shost);\r\nresult = scsi_add_host(shost, &intf->dev);\r\nif (result)\r\ngoto free_streams;\r\nscsi_scan_host(shost);\r\nreturn result;\r\nfree_streams:\r\nuas_free_streams(devinfo);\r\nusb_set_intfdata(intf, NULL);\r\nset_alt0:\r\nusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\r\nif (shost)\r\nscsi_host_put(shost);\r\nreturn result;\r\n}\r\nstatic int uas_cmnd_list_empty(struct uas_dev_info *devinfo)\r\n{\r\nunsigned long flags;\r\nint i, r = 1;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\nfor (i = 0; i < devinfo->qdepth; i++) {\r\nif (devinfo->cmnd[i]) {\r\nr = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\nreturn r;\r\n}\r\nstatic int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)\r\n{\r\nunsigned long start_time;\r\nint r;\r\nstart_time = jiffies;\r\ndo {\r\nflush_work(&devinfo->work);\r\nr = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);\r\nif (r == 0)\r\nreturn -ETIME;\r\nr = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);\r\nif (r == 0)\r\nreturn -ETIME;\r\nif (time_after(jiffies, start_time + 5 * HZ))\r\nreturn -ETIME;\r\n} while (!uas_cmnd_list_empty(devinfo));\r\nreturn 0;\r\n}\r\nstatic int uas_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nif (devinfo->shutdown)\r\nreturn 0;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nscsi_block_requests(shost);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (uas_wait_for_pending_cmnds(devinfo) != 0) {\r\nshost_printk(KERN_ERR, shost, "%s: timed out\n", __func__);\r\nscsi_unblock_requests(shost);\r\nreturn 1;\r\n}\r\nuas_free_streams(devinfo);\r\nreturn 0;\r\n}\r\nstatic int uas_post_reset(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nint err;\r\nif (devinfo->shutdown)\r\nreturn 0;\r\nerr = uas_configure_endpoints(devinfo);\r\nif (err) {\r\nshost_printk(KERN_ERR, shost,\r\n"%s: alloc streams error %d after reset",\r\n__func__, err);\r\nreturn 1;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nscsi_report_bus_reset(shost, 0);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_unblock_requests(shost);\r\nreturn 0;\r\n}\r\nstatic int uas_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nif (uas_wait_for_pending_cmnds(devinfo) != 0) {\r\nshost_printk(KERN_ERR, shost, "%s: timed out\n", __func__);\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uas_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int uas_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nint err;\r\nerr = uas_configure_endpoints(devinfo);\r\nif (err) {\r\nshost_printk(KERN_ERR, shost,\r\n"%s: alloc streams error %d after reset",\r\n__func__, err);\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nscsi_report_bus_reset(shost, 0);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void uas_disconnect(struct usb_interface *intf)\r\n{\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devinfo->lock, flags);\r\ndevinfo->resetting = 1;\r\nspin_unlock_irqrestore(&devinfo->lock, flags);\r\ncancel_work_sync(&devinfo->work);\r\nusb_kill_anchored_urbs(&devinfo->cmd_urbs);\r\nusb_kill_anchored_urbs(&devinfo->sense_urbs);\r\nusb_kill_anchored_urbs(&devinfo->data_urbs);\r\nuas_zap_pending(devinfo, DID_NO_CONNECT);\r\nscsi_remove_host(shost);\r\nuas_free_streams(devinfo);\r\nscsi_host_put(shost);\r\n}\r\nstatic void uas_shutdown(struct device *dev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct Scsi_Host *shost = usb_get_intfdata(intf);\r\nstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\r\nif (system_state != SYSTEM_RESTART)\r\nreturn;\r\ndevinfo->shutdown = 1;\r\nuas_free_streams(devinfo);\r\nusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\r\nusb_reset_device(udev);\r\n}
