static int v9fs_set_super(struct super_block *s, void *data)\r\n{\r\ns->s_fs_info = data;\r\nreturn set_anon_super(s, data);\r\n}\r\nstatic void\r\nv9fs_fill_super(struct super_block *sb, struct v9fs_session_info *v9ses,\r\nint flags, void *data)\r\n{\r\nsb->s_maxbytes = MAX_LFS_FILESIZE;\r\nsb->s_blocksize_bits = fls(v9ses->maxdata - 1);\r\nsb->s_blocksize = 1 << sb->s_blocksize_bits;\r\nsb->s_magic = V9FS_MAGIC;\r\nif (v9fs_proto_dotl(v9ses)) {\r\nsb->s_op = &v9fs_super_ops_dotl;\r\nsb->s_xattr = v9fs_xattr_handlers;\r\n} else\r\nsb->s_op = &v9fs_super_ops;\r\nsb->s_bdi = &v9ses->bdi;\r\nif (v9ses->cache)\r\nsb->s_bdi->ra_pages = (VM_MAX_READAHEAD * 1024)/PAGE_CACHE_SIZE;\r\nsb->s_flags |= MS_ACTIVE | MS_DIRSYNC | MS_NOATIME;\r\nif (!v9ses->cache)\r\nsb->s_flags |= MS_SYNCHRONOUS;\r\n#ifdef CONFIG_9P_FS_POSIX_ACL\r\nif ((v9ses->flags & V9FS_ACL_MASK) == V9FS_POSIX_ACL)\r\nsb->s_flags |= MS_POSIXACL;\r\n#endif\r\nsave_mount_options(sb, data);\r\n}\r\nstatic struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,\r\nconst char *dev_name, void *data)\r\n{\r\nstruct super_block *sb = NULL;\r\nstruct inode *inode = NULL;\r\nstruct dentry *root = NULL;\r\nstruct v9fs_session_info *v9ses = NULL;\r\numode_t mode = S_IRWXUGO | S_ISVTX;\r\nstruct p9_fid *fid;\r\nint retval = 0;\r\np9_debug(P9_DEBUG_VFS, "\n");\r\nv9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL);\r\nif (!v9ses)\r\nreturn ERR_PTR(-ENOMEM);\r\nfid = v9fs_session_init(v9ses, dev_name, data);\r\nif (IS_ERR(fid)) {\r\nretval = PTR_ERR(fid);\r\ngoto free_session;\r\n}\r\nsb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses);\r\nif (IS_ERR(sb)) {\r\nretval = PTR_ERR(sb);\r\ngoto clunk_fid;\r\n}\r\nv9fs_fill_super(sb, v9ses, flags, data);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\nsb->s_d_op = &v9fs_cached_dentry_operations;\r\nelse\r\nsb->s_d_op = &v9fs_dentry_operations;\r\ninode = v9fs_get_inode(sb, S_IFDIR | mode, 0);\r\nif (IS_ERR(inode)) {\r\nretval = PTR_ERR(inode);\r\ngoto release_sb;\r\n}\r\nroot = d_make_root(inode);\r\nif (!root) {\r\nretval = -ENOMEM;\r\ngoto release_sb;\r\n}\r\nsb->s_root = root;\r\nif (v9fs_proto_dotl(v9ses)) {\r\nstruct p9_stat_dotl *st = NULL;\r\nst = p9_client_getattr_dotl(fid, P9_STATS_BASIC);\r\nif (IS_ERR(st)) {\r\nretval = PTR_ERR(st);\r\ngoto release_sb;\r\n}\r\nd_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\r\nv9fs_stat2inode_dotl(st, d_inode(root));\r\nkfree(st);\r\n} else {\r\nstruct p9_wstat *st = NULL;\r\nst = p9_client_stat(fid);\r\nif (IS_ERR(st)) {\r\nretval = PTR_ERR(st);\r\ngoto release_sb;\r\n}\r\nd_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\r\nv9fs_stat2inode(st, d_inode(root), sb);\r\np9stat_free(st);\r\nkfree(st);\r\n}\r\nretval = v9fs_get_acl(inode, fid);\r\nif (retval)\r\ngoto release_sb;\r\nv9fs_fid_add(root, fid);\r\np9_debug(P9_DEBUG_VFS, " simple set mount, return 0\n");\r\nreturn dget(sb->s_root);\r\nclunk_fid:\r\np9_client_clunk(fid);\r\nv9fs_session_close(v9ses);\r\nfree_session:\r\nkfree(v9ses);\r\nreturn ERR_PTR(retval);\r\nrelease_sb:\r\np9_client_clunk(fid);\r\ndeactivate_locked_super(sb);\r\nreturn ERR_PTR(retval);\r\n}\r\nstatic void v9fs_kill_super(struct super_block *s)\r\n{\r\nstruct v9fs_session_info *v9ses = s->s_fs_info;\r\np9_debug(P9_DEBUG_VFS, " %p\n", s);\r\nkill_anon_super(s);\r\nv9fs_session_cancel(v9ses);\r\nv9fs_session_close(v9ses);\r\nkfree(v9ses);\r\ns->s_fs_info = NULL;\r\np9_debug(P9_DEBUG_VFS, "exiting kill_super\n");\r\n}\r\nstatic void\r\nv9fs_umount_begin(struct super_block *sb)\r\n{\r\nstruct v9fs_session_info *v9ses;\r\nv9ses = sb->s_fs_info;\r\nv9fs_session_begin_cancel(v9ses);\r\n}\r\nstatic int v9fs_statfs(struct dentry *dentry, struct kstatfs *buf)\r\n{\r\nstruct v9fs_session_info *v9ses;\r\nstruct p9_fid *fid;\r\nstruct p9_rstatfs rs;\r\nint res;\r\nfid = v9fs_fid_lookup(dentry);\r\nif (IS_ERR(fid)) {\r\nres = PTR_ERR(fid);\r\ngoto done;\r\n}\r\nv9ses = v9fs_dentry2v9ses(dentry);\r\nif (v9fs_proto_dotl(v9ses)) {\r\nres = p9_client_statfs(fid, &rs);\r\nif (res == 0) {\r\nbuf->f_type = rs.type;\r\nbuf->f_bsize = rs.bsize;\r\nbuf->f_blocks = rs.blocks;\r\nbuf->f_bfree = rs.bfree;\r\nbuf->f_bavail = rs.bavail;\r\nbuf->f_files = rs.files;\r\nbuf->f_ffree = rs.ffree;\r\nbuf->f_fsid.val[0] = rs.fsid & 0xFFFFFFFFUL;\r\nbuf->f_fsid.val[1] = (rs.fsid >> 32) & 0xFFFFFFFFUL;\r\nbuf->f_namelen = rs.namelen;\r\n}\r\nif (res != -ENOSYS)\r\ngoto done;\r\n}\r\nres = simple_statfs(dentry, buf);\r\ndone:\r\nreturn res;\r\n}\r\nstatic int v9fs_drop_inode(struct inode *inode)\r\n{\r\nstruct v9fs_session_info *v9ses;\r\nv9ses = v9fs_inode2v9ses(inode);\r\nif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\r\nreturn generic_drop_inode(inode);\r\nreturn 1;\r\n}\r\nstatic int v9fs_write_inode(struct inode *inode,\r\nstruct writeback_control *wbc)\r\n{\r\nint ret;\r\nstruct p9_wstat wstat;\r\nstruct v9fs_inode *v9inode;\r\np9_debug(P9_DEBUG_VFS, "%s: inode %p\n", __func__, inode);\r\nv9inode = V9FS_I(inode);\r\nif (!v9inode->writeback_fid)\r\nreturn 0;\r\nv9fs_blank_wstat(&wstat);\r\nret = p9_client_wstat(v9inode->writeback_fid, &wstat);\r\nif (ret < 0) {\r\n__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int v9fs_write_inode_dotl(struct inode *inode,\r\nstruct writeback_control *wbc)\r\n{\r\nint ret;\r\nstruct v9fs_inode *v9inode;\r\nv9inode = V9FS_I(inode);\r\np9_debug(P9_DEBUG_VFS, "%s: inode %p, writeback_fid %p\n",\r\n__func__, inode, v9inode->writeback_fid);\r\nif (!v9inode->writeback_fid)\r\nreturn 0;\r\nret = p9_client_fsync(v9inode->writeback_fid, 0);\r\nif (ret < 0) {\r\n__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
