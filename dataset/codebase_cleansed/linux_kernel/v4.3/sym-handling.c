bool elf__needs_adjust_symbols(GElf_Ehdr ehdr)\r\n{\r\nreturn ehdr.e_type == ET_EXEC ||\r\nehdr.e_type == ET_REL ||\r\nehdr.e_type == ET_DYN;\r\n}\r\nvoid arch__elf_sym_adjust(GElf_Sym *sym)\r\n{\r\nsym->st_value += PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);\r\n}\r\nint arch__choose_best_symbol(struct symbol *syma,\r\nstruct symbol *symb __maybe_unused)\r\n{\r\nchar *sym = syma->name;\r\nif (*sym == '.')\r\nsym++;\r\nif (strlen(sym) >= 3 && !strncmp(sym, "SyS", 3))\r\nreturn SYMBOL_B;\r\nif (strlen(sym) >= 10 && !strncmp(sym, "compat_SyS", 10))\r\nreturn SYMBOL_B;\r\nreturn SYMBOL_A;\r\n}\r\nint arch__compare_symbol_names(const char *namea, const char *nameb)\r\n{\r\nif (*namea == '.')\r\nnamea++;\r\nif (*nameb == '.')\r\nnameb++;\r\nreturn strcmp(namea, nameb);\r\n}\r\nbool arch__prefers_symtab(void)\r\n{\r\nreturn true;\r\n}\r\nvoid arch__fix_tev_from_maps(struct perf_probe_event *pev,\r\nstruct probe_trace_event *tev, struct map *map)\r\n{\r\nif (!pev->uprobes && map->dso->symtab_type == DSO_BINARY_TYPE__KALLSYMS) {\r\ntev->point.address += PPC64LE_LEP_OFFSET;\r\ntev->point.offset += PPC64LE_LEP_OFFSET;\r\n}\r\n}
