static void cypress_set_packet_size(struct psmouse *psmouse, unsigned int n)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\ncytp->pkt_size = n;\r\n}\r\nstatic int cypress_ps2_sendbyte(struct psmouse *psmouse, int value)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nif (ps2_sendbyte(ps2dev, value & 0xff, CYTP_CMD_TIMEOUT) < 0) {\r\npsmouse_dbg(psmouse,\r\n"sending command 0x%02x failed, resp 0x%02x\n",\r\nvalue & 0xff, ps2dev->nak);\r\nif (ps2dev->nak == CYTP_PS2_RETRY)\r\nreturn CYTP_PS2_RETRY;\r\nelse\r\nreturn CYTP_PS2_ERROR;\r\n}\r\n#ifdef CYTP_DEBUG_VERBOSE\r\npsmouse_dbg(psmouse, "sending command 0x%02x succeeded, resp 0xfa\n",\r\nvalue & 0xff);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cypress_ps2_ext_cmd(struct psmouse *psmouse, unsigned short cmd,\r\nunsigned char data)\r\n{\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nint tries = CYTP_PS2_CMD_TRIES;\r\nint rc;\r\nps2_begin_command(ps2dev);\r\ndo {\r\nrc = cypress_ps2_sendbyte(psmouse, cmd & 0xff);\r\nif (rc == CYTP_PS2_RETRY) {\r\nrc = cypress_ps2_sendbyte(psmouse, 0x00);\r\nif (rc == CYTP_PS2_RETRY)\r\nrc = cypress_ps2_sendbyte(psmouse, 0x0a);\r\n}\r\nif (rc == CYTP_PS2_ERROR)\r\ncontinue;\r\nrc = cypress_ps2_sendbyte(psmouse, data);\r\nif (rc == CYTP_PS2_RETRY)\r\nrc = cypress_ps2_sendbyte(psmouse, data);\r\nif (rc == CYTP_PS2_ERROR)\r\ncontinue;\r\nelse\r\nbreak;\r\n} while (--tries > 0);\r\nps2_end_command(ps2dev);\r\nreturn rc;\r\n}\r\nstatic int cypress_ps2_read_cmd_status(struct psmouse *psmouse,\r\nunsigned char cmd,\r\nunsigned char *param)\r\n{\r\nint rc;\r\nstruct ps2dev *ps2dev = &psmouse->ps2dev;\r\nenum psmouse_state old_state;\r\nint pktsize;\r\nps2_begin_command(&psmouse->ps2dev);\r\nold_state = psmouse->state;\r\npsmouse->state = PSMOUSE_CMD_MODE;\r\npsmouse->pktcnt = 0;\r\npktsize = (cmd == CYTP_CMD_READ_TP_METRICS) ? 8 : 3;\r\nmemset(param, 0, pktsize);\r\nrc = cypress_ps2_sendbyte(psmouse, 0xe9);\r\nif (rc < 0)\r\ngoto out;\r\nwait_event_timeout(ps2dev->wait,\r\n(psmouse->pktcnt >= pktsize),\r\nmsecs_to_jiffies(CYTP_CMD_TIMEOUT));\r\nmemcpy(param, psmouse->packet, pktsize);\r\npsmouse_dbg(psmouse, "Command 0x%02x response data (0x): %*ph\n",\r\ncmd, pktsize, param);\r\nout:\r\npsmouse->state = old_state;\r\npsmouse->pktcnt = 0;\r\nps2_end_command(&psmouse->ps2dev);\r\nreturn rc;\r\n}\r\nstatic bool cypress_verify_cmd_state(struct psmouse *psmouse,\r\nunsigned char cmd, unsigned char *param)\r\n{\r\nbool rate_match = false;\r\nbool resolution_match = false;\r\nint i;\r\nif (cmd == CYTP_CMD_READ_CYPRESS_ID ||\r\ncmd == CYTP_CMD_STANDARD_MODE ||\r\ncmd == CYTP_CMD_READ_TP_METRICS)\r\nreturn true;\r\nif ((~param[0] & DFLT_RESP_BITS_VALID) == DFLT_RESP_BITS_VALID &&\r\n(param[0] & DFLT_RESP_BIT_MODE) == DFLT_RESP_STREAM_MODE) {\r\nfor (i = 0; i < sizeof(cytp_resolution); i++)\r\nif (cytp_resolution[i] == param[1])\r\nresolution_match = true;\r\nfor (i = 0; i < sizeof(cytp_rate); i++)\r\nif (cytp_rate[i] == param[2])\r\nrate_match = true;\r\nif (resolution_match && rate_match)\r\nreturn true;\r\n}\r\npsmouse_dbg(psmouse, "verify cmd state failed.\n");\r\nreturn false;\r\n}\r\nstatic int cypress_send_ext_cmd(struct psmouse *psmouse, unsigned char cmd,\r\nunsigned char *param)\r\n{\r\nint tries = CYTP_PS2_CMD_TRIES;\r\nint rc;\r\npsmouse_dbg(psmouse, "send extension cmd 0x%02x, [%d %d %d %d]\n",\r\ncmd, DECODE_CMD_AA(cmd), DECODE_CMD_BB(cmd),\r\nDECODE_CMD_CC(cmd), DECODE_CMD_DD(cmd));\r\ndo {\r\ncypress_ps2_ext_cmd(psmouse,\r\nPSMOUSE_CMD_SETRES, DECODE_CMD_DD(cmd));\r\ncypress_ps2_ext_cmd(psmouse,\r\nPSMOUSE_CMD_SETRES, DECODE_CMD_CC(cmd));\r\ncypress_ps2_ext_cmd(psmouse,\r\nPSMOUSE_CMD_SETRES, DECODE_CMD_BB(cmd));\r\ncypress_ps2_ext_cmd(psmouse,\r\nPSMOUSE_CMD_SETRES, DECODE_CMD_AA(cmd));\r\nrc = cypress_ps2_read_cmd_status(psmouse, cmd, param);\r\nif (rc)\r\ncontinue;\r\nif (cypress_verify_cmd_state(psmouse, cmd, param))\r\nreturn 0;\r\n} while (--tries > 0);\r\nreturn -EIO;\r\n}\r\nint cypress_detect(struct psmouse *psmouse, bool set_properties)\r\n{\r\nunsigned char param[3];\r\nif (cypress_send_ext_cmd(psmouse, CYTP_CMD_READ_CYPRESS_ID, param))\r\nreturn -ENODEV;\r\nif (param[0] != 0x33 || param[1] != 0xCC)\r\nreturn -ENODEV;\r\nif (set_properties) {\r\npsmouse->vendor = "Cypress";\r\npsmouse->name = "Trackpad";\r\n}\r\nreturn 0;\r\n}\r\nstatic int cypress_read_fw_version(struct psmouse *psmouse)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\nunsigned char param[3];\r\nif (cypress_send_ext_cmd(psmouse, CYTP_CMD_READ_CYPRESS_ID, param))\r\nreturn -ENODEV;\r\nif (param[0] != 0x33 || param[1] != 0xCC)\r\nreturn -ENODEV;\r\ncytp->fw_version = param[2] & FW_VERSION_MASX;\r\ncytp->tp_metrics_supported = (param[2] & TP_METRICS_MASK) ? 1 : 0;\r\nif (cytp->fw_version >= 11)\r\ncytp->tp_metrics_supported = 0;\r\npsmouse_dbg(psmouse, "cytp->fw_version = %d\n", cytp->fw_version);\r\npsmouse_dbg(psmouse, "cytp->tp_metrics_supported = %d\n",\r\ncytp->tp_metrics_supported);\r\nreturn 0;\r\n}\r\nstatic int cypress_read_tp_metrics(struct psmouse *psmouse)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\nunsigned char param[8];\r\ncytp->tp_width = CYTP_DEFAULT_WIDTH;\r\ncytp->tp_high = CYTP_DEFAULT_HIGH;\r\ncytp->tp_max_abs_x = CYTP_ABS_MAX_X;\r\ncytp->tp_max_abs_y = CYTP_ABS_MAX_Y;\r\ncytp->tp_min_pressure = CYTP_MIN_PRESSURE;\r\ncytp->tp_max_pressure = CYTP_MAX_PRESSURE;\r\ncytp->tp_res_x = cytp->tp_max_abs_x / cytp->tp_width;\r\ncytp->tp_res_y = cytp->tp_max_abs_y / cytp->tp_high;\r\nif (!cytp->tp_metrics_supported)\r\nreturn 0;\r\nmemset(param, 0, sizeof(param));\r\nif (cypress_send_ext_cmd(psmouse, CYTP_CMD_READ_TP_METRICS, param) == 0) {\r\ncytp->tp_max_abs_x = (param[1] << 8) | param[0];\r\ncytp->tp_max_abs_y = (param[3] << 8) | param[2];\r\ncytp->tp_min_pressure = param[4];\r\ncytp->tp_max_pressure = param[5];\r\n}\r\nif (!cytp->tp_max_pressure ||\r\ncytp->tp_max_pressure < cytp->tp_min_pressure ||\r\n!cytp->tp_width || !cytp->tp_high ||\r\n!cytp->tp_max_abs_x ||\r\ncytp->tp_max_abs_x < cytp->tp_width ||\r\n!cytp->tp_max_abs_y ||\r\ncytp->tp_max_abs_y < cytp->tp_high)\r\nreturn -EINVAL;\r\ncytp->tp_res_x = cytp->tp_max_abs_x / cytp->tp_width;\r\ncytp->tp_res_y = cytp->tp_max_abs_y / cytp->tp_high;\r\n#ifdef CYTP_DEBUG_VERBOSE\r\npsmouse_dbg(psmouse, "Dump trackpad hardware configuration as below:\n");\r\npsmouse_dbg(psmouse, "cytp->tp_width = %d\n", cytp->tp_width);\r\npsmouse_dbg(psmouse, "cytp->tp_high = %d\n", cytp->tp_high);\r\npsmouse_dbg(psmouse, "cytp->tp_max_abs_x = %d\n", cytp->tp_max_abs_x);\r\npsmouse_dbg(psmouse, "cytp->tp_max_abs_y = %d\n", cytp->tp_max_abs_y);\r\npsmouse_dbg(psmouse, "cytp->tp_min_pressure = %d\n", cytp->tp_min_pressure);\r\npsmouse_dbg(psmouse, "cytp->tp_max_pressure = %d\n", cytp->tp_max_pressure);\r\npsmouse_dbg(psmouse, "cytp->tp_res_x = %d\n", cytp->tp_res_x);\r\npsmouse_dbg(psmouse, "cytp->tp_res_y = %d\n", cytp->tp_res_y);\r\npsmouse_dbg(psmouse, "tp_type_APA = %d\n",\r\n(param[6] & TP_METRICS_BIT_APA) ? 1 : 0);\r\npsmouse_dbg(psmouse, "tp_type_MTG = %d\n",\r\n(param[6] & TP_METRICS_BIT_MTG) ? 1 : 0);\r\npsmouse_dbg(psmouse, "tp_palm = %d\n",\r\n(param[6] & TP_METRICS_BIT_PALM) ? 1 : 0);\r\npsmouse_dbg(psmouse, "tp_stubborn = %d\n",\r\n(param[6] & TP_METRICS_BIT_STUBBORN) ? 1 : 0);\r\npsmouse_dbg(psmouse, "tp_1f_jitter = %d\n",\r\n(param[6] & TP_METRICS_BIT_1F_JITTER) >> 2);\r\npsmouse_dbg(psmouse, "tp_2f_jitter = %d\n",\r\n(param[6] & TP_METRICS_BIT_2F_JITTER) >> 4);\r\npsmouse_dbg(psmouse, "tp_1f_spike = %d\n",\r\nparam[7] & TP_METRICS_BIT_1F_SPIKE);\r\npsmouse_dbg(psmouse, "tp_2f_spike = %d\n",\r\n(param[7] & TP_METRICS_BIT_2F_SPIKE) >> 2);\r\npsmouse_dbg(psmouse, "tp_abs_packet_format_set = %d\n",\r\n(param[7] & TP_METRICS_BIT_ABS_PKT_FORMAT_SET) >> 4);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int cypress_query_hardware(struct psmouse *psmouse)\r\n{\r\nint ret;\r\nret = cypress_read_fw_version(psmouse);\r\nif (ret)\r\nreturn ret;\r\nret = cypress_read_tp_metrics(psmouse);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int cypress_set_absolute_mode(struct psmouse *psmouse)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\nunsigned char param[3];\r\nif (cypress_send_ext_cmd(psmouse, CYTP_CMD_ABS_WITH_PRESSURE_MODE, param) < 0)\r\nreturn -1;\r\ncytp->mode = (cytp->mode & ~CYTP_BIT_ABS_REL_MASK)\r\n| CYTP_BIT_ABS_PRESSURE;\r\ncypress_set_packet_size(psmouse, 5);\r\nreturn 0;\r\n}\r\nstatic void cypress_reset(struct psmouse *psmouse)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\ncytp->mode = 0;\r\npsmouse_reset(psmouse);\r\n}\r\nstatic int cypress_set_input_params(struct input_dev *input,\r\nstruct cytp_data *cytp)\r\n{\r\nint ret;\r\nif (!cytp->tp_res_x || !cytp->tp_res_y)\r\nreturn -EINVAL;\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_X, 0, cytp->tp_max_abs_x, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, cytp->tp_max_abs_y, 0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE,\r\ncytp->tp_min_pressure, cytp->tp_max_pressure, 0, 0);\r\ninput_set_abs_params(input, ABS_TOOL_WIDTH, 0, 255, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, cytp->tp_max_abs_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, cytp->tp_max_abs_y, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, 255, 0, 0);\r\nret = input_mt_init_slots(input, CYTP_MAX_MT_SLOTS,\r\nINPUT_MT_DROP_UNUSED|INPUT_MT_TRACK);\r\nif (ret < 0)\r\nreturn ret;\r\n__set_bit(INPUT_PROP_SEMI_MT, input->propbit);\r\ninput_abs_set_res(input, ABS_X, cytp->tp_res_x);\r\ninput_abs_set_res(input, ABS_Y, cytp->tp_res_y);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, cytp->tp_res_x);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, cytp->tp_res_y);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, input->keybit);\r\n__set_bit(BTN_TOOL_QUADTAP, input->keybit);\r\n__set_bit(BTN_TOOL_QUINTTAP, input->keybit);\r\n__clear_bit(EV_REL, input->evbit);\r\n__clear_bit(REL_X, input->relbit);\r\n__clear_bit(REL_Y, input->relbit);\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(BTN_LEFT, input->keybit);\r\n__set_bit(BTN_RIGHT, input->keybit);\r\n__set_bit(BTN_MIDDLE, input->keybit);\r\ninput_set_drvdata(input, cytp);\r\nreturn 0;\r\n}\r\nstatic int cypress_get_finger_count(unsigned char header_byte)\r\n{\r\nunsigned char bits6_7;\r\nint finger_count;\r\nbits6_7 = header_byte >> 6;\r\nfinger_count = bits6_7 & 0x03;\r\nif (finger_count == 1)\r\nreturn 1;\r\nif (header_byte & ABS_HSCROLL_BIT) {\r\nswitch (finger_count) {\r\ncase 0: return 4;\r\ncase 2: return 5;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn finger_count;\r\n}\r\nstatic int cypress_parse_packet(struct psmouse *psmouse,\r\nstruct cytp_data *cytp, struct cytp_report_data *report_data)\r\n{\r\nunsigned char *packet = psmouse->packet;\r\nunsigned char header_byte = packet[0];\r\nmemset(report_data, 0, sizeof(struct cytp_report_data));\r\nreport_data->contact_cnt = cypress_get_finger_count(header_byte);\r\nreport_data->tap = (header_byte & ABS_MULTIFINGER_TAP) ? 1 : 0;\r\nif (report_data->contact_cnt == 1) {\r\nreport_data->contacts[0].x =\r\n((packet[1] & 0x70) << 4) | packet[2];\r\nreport_data->contacts[0].y =\r\n((packet[1] & 0x07) << 8) | packet[3];\r\nif (cytp->mode & CYTP_BIT_ABS_PRESSURE)\r\nreport_data->contacts[0].z = packet[4];\r\n} else if (report_data->contact_cnt >= 2) {\r\nreport_data->contacts[0].x =\r\n((packet[1] & 0x70) << 4) | packet[2];\r\nreport_data->contacts[0].y =\r\n((packet[1] & 0x07) << 8) | packet[3];\r\nif (cytp->mode & CYTP_BIT_ABS_PRESSURE)\r\nreport_data->contacts[0].z = packet[4];\r\nreport_data->contacts[1].x =\r\n((packet[5] & 0xf0) << 4) | packet[6];\r\nreport_data->contacts[1].y =\r\n((packet[5] & 0x0f) << 8) | packet[7];\r\nif (cytp->mode & CYTP_BIT_ABS_PRESSURE)\r\nreport_data->contacts[1].z = report_data->contacts[0].z;\r\n}\r\nreport_data->left = (header_byte & BTN_LEFT_BIT) ? 1 : 0;\r\nreport_data->right = (header_byte & BTN_RIGHT_BIT) ? 1 : 0;\r\nif (report_data->tap)\r\nreport_data->left = 0;\r\n#ifdef CYTP_DEBUG_VERBOSE\r\n{\r\nint i;\r\nint n = report_data->contact_cnt;\r\npsmouse_dbg(psmouse, "Dump parsed report data as below:\n");\r\npsmouse_dbg(psmouse, "contact_cnt = %d\n",\r\nreport_data->contact_cnt);\r\nif (n > CYTP_MAX_MT_SLOTS)\r\nn = CYTP_MAX_MT_SLOTS;\r\nfor (i = 0; i < n; i++)\r\npsmouse_dbg(psmouse, "contacts[%d] = {%d, %d, %d}\n", i,\r\nreport_data->contacts[i].x,\r\nreport_data->contacts[i].y,\r\nreport_data->contacts[i].z);\r\npsmouse_dbg(psmouse, "left = %d\n", report_data->left);\r\npsmouse_dbg(psmouse, "right = %d\n", report_data->right);\r\npsmouse_dbg(psmouse, "middle = %d\n", report_data->middle);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void cypress_process_packet(struct psmouse *psmouse, bool zero_pkt)\r\n{\r\nint i;\r\nstruct input_dev *input = psmouse->dev;\r\nstruct cytp_data *cytp = psmouse->private;\r\nstruct cytp_report_data report_data;\r\nstruct cytp_contact *contact;\r\nstruct input_mt_pos pos[CYTP_MAX_MT_SLOTS];\r\nint slots[CYTP_MAX_MT_SLOTS];\r\nint n;\r\ncypress_parse_packet(psmouse, cytp, &report_data);\r\nn = report_data.contact_cnt;\r\nif (n > CYTP_MAX_MT_SLOTS)\r\nn = CYTP_MAX_MT_SLOTS;\r\nfor (i = 0; i < n; i++) {\r\ncontact = &report_data.contacts[i];\r\npos[i].x = contact->x;\r\npos[i].y = contact->y;\r\n}\r\ninput_mt_assign_slots(input, slots, pos, n, 0);\r\nfor (i = 0; i < n; i++) {\r\ncontact = &report_data.contacts[i];\r\ninput_mt_slot(input, slots[i]);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_POSITION_X, contact->x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, contact->y);\r\ninput_report_abs(input, ABS_MT_PRESSURE, contact->z);\r\n}\r\ninput_mt_sync_frame(input);\r\ninput_mt_report_finger_count(input, report_data.contact_cnt);\r\ninput_report_key(input, BTN_LEFT, report_data.left);\r\ninput_report_key(input, BTN_RIGHT, report_data.right);\r\ninput_report_key(input, BTN_MIDDLE, report_data.middle);\r\ninput_sync(input);\r\n}\r\nstatic psmouse_ret_t cypress_validate_byte(struct psmouse *psmouse)\r\n{\r\nint contact_cnt;\r\nint index = psmouse->pktcnt - 1;\r\nunsigned char *packet = psmouse->packet;\r\nstruct cytp_data *cytp = psmouse->private;\r\nif (index < 0 || index > cytp->pkt_size)\r\nreturn PSMOUSE_BAD_DATA;\r\nif (index == 0 && (packet[0] & 0xfc) == 0) {\r\ncypress_process_packet(psmouse, 1);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nif (index != 0)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif ((cytp->mode & CYTP_BIT_ABS_REL_MASK) == 0)\r\nreturn PSMOUSE_GOOD_DATA;\r\nif ((packet[0] & 0x08) == 0x08)\r\nreturn PSMOUSE_BAD_DATA;\r\ncontact_cnt = cypress_get_finger_count(packet[0]);\r\nif (cytp->mode & CYTP_BIT_ABS_NO_PRESSURE)\r\ncypress_set_packet_size(psmouse, contact_cnt == 2 ? 7 : 4);\r\nelse\r\ncypress_set_packet_size(psmouse, contact_cnt == 2 ? 8 : 5);\r\nreturn PSMOUSE_GOOD_DATA;\r\n}\r\nstatic psmouse_ret_t cypress_protocol_handler(struct psmouse *psmouse)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\nif (psmouse->pktcnt >= cytp->pkt_size) {\r\ncypress_process_packet(psmouse, 0);\r\nreturn PSMOUSE_FULL_PACKET;\r\n}\r\nreturn cypress_validate_byte(psmouse);\r\n}\r\nstatic void cypress_set_rate(struct psmouse *psmouse, unsigned int rate)\r\n{\r\nstruct cytp_data *cytp = psmouse->private;\r\nif (rate >= 80) {\r\npsmouse->rate = 80;\r\ncytp->mode |= CYTP_BIT_HIGH_RATE;\r\n} else {\r\npsmouse->rate = 40;\r\ncytp->mode &= ~CYTP_BIT_HIGH_RATE;\r\n}\r\nps2_command(&psmouse->ps2dev, (unsigned char *)&psmouse->rate,\r\nPSMOUSE_CMD_SETRATE);\r\n}\r\nstatic void cypress_disconnect(struct psmouse *psmouse)\r\n{\r\ncypress_reset(psmouse);\r\nkfree(psmouse->private);\r\npsmouse->private = NULL;\r\n}\r\nstatic int cypress_reconnect(struct psmouse *psmouse)\r\n{\r\nint tries = CYTP_PS2_CMD_TRIES;\r\nint rc;\r\ndo {\r\ncypress_reset(psmouse);\r\nrc = cypress_detect(psmouse, false);\r\n} while (rc && (--tries > 0));\r\nif (rc) {\r\npsmouse_err(psmouse, "Reconnect: unable to detect trackpad.\n");\r\nreturn -1;\r\n}\r\nif (cypress_set_absolute_mode(psmouse)) {\r\npsmouse_err(psmouse, "Reconnect: Unable to initialize Cypress absolute mode.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint cypress_init(struct psmouse *psmouse)\r\n{\r\nstruct cytp_data *cytp;\r\ncytp = kzalloc(sizeof(struct cytp_data), GFP_KERNEL);\r\nif (!cytp)\r\nreturn -ENOMEM;\r\npsmouse->private = cytp;\r\npsmouse->pktsize = 8;\r\ncypress_reset(psmouse);\r\nif (cypress_query_hardware(psmouse)) {\r\npsmouse_err(psmouse, "Unable to query Trackpad hardware.\n");\r\ngoto err_exit;\r\n}\r\nif (cypress_set_absolute_mode(psmouse)) {\r\npsmouse_err(psmouse, "init: Unable to initialize Cypress absolute mode.\n");\r\ngoto err_exit;\r\n}\r\nif (cypress_set_input_params(psmouse->dev, cytp) < 0) {\r\npsmouse_err(psmouse, "init: Unable to set input params.\n");\r\ngoto err_exit;\r\n}\r\npsmouse->model = 1;\r\npsmouse->protocol_handler = cypress_protocol_handler;\r\npsmouse->set_rate = cypress_set_rate;\r\npsmouse->disconnect = cypress_disconnect;\r\npsmouse->reconnect = cypress_reconnect;\r\npsmouse->cleanup = cypress_reset;\r\npsmouse->resync_time = 0;\r\nreturn 0;\r\nerr_exit:\r\ncypress_reset(psmouse);\r\npsmouse->private = NULL;\r\nkfree(cytp);\r\nreturn -1;\r\n}
