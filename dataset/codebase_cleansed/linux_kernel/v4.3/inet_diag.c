static const struct inet_diag_handler *inet_diag_lock_handler(int proto)\r\n{\r\nif (!inet_diag_table[proto])\r\nrequest_module("net-pf-%d-proto-%d-type-%d-%d", PF_NETLINK,\r\nNETLINK_SOCK_DIAG, AF_INET, proto);\r\nmutex_lock(&inet_diag_table_mutex);\r\nif (!inet_diag_table[proto])\r\nreturn ERR_PTR(-ENOENT);\r\nreturn inet_diag_table[proto];\r\n}\r\nstatic void inet_diag_unlock_handler(const struct inet_diag_handler *handler)\r\n{\r\nmutex_unlock(&inet_diag_table_mutex);\r\n}\r\nstatic void inet_diag_msg_common_fill(struct inet_diag_msg *r, struct sock *sk)\r\n{\r\nr->idiag_family = sk->sk_family;\r\nr->id.idiag_sport = htons(sk->sk_num);\r\nr->id.idiag_dport = sk->sk_dport;\r\nr->id.idiag_if = sk->sk_bound_dev_if;\r\nsock_diag_save_cookie(sk, r->id.idiag_cookie);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == AF_INET6) {\r\n*(struct in6_addr *)r->id.idiag_src = sk->sk_v6_rcv_saddr;\r\n*(struct in6_addr *)r->id.idiag_dst = sk->sk_v6_daddr;\r\n} else\r\n#endif\r\n{\r\nmemset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));\r\nmemset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));\r\nr->id.idiag_src[0] = sk->sk_rcv_saddr;\r\nr->id.idiag_dst[0] = sk->sk_daddr;\r\n}\r\n}\r\nstatic size_t inet_sk_attr_size(void)\r\n{\r\nreturn nla_total_size(sizeof(struct tcp_info))\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(sizeof(struct inet_diag_meminfo))\r\n+ nla_total_size(sizeof(struct inet_diag_msg))\r\n+ nla_total_size(SK_MEMINFO_VARS * sizeof(u32))\r\n+ nla_total_size(TCP_CA_NAME_MAX)\r\n+ nla_total_size(sizeof(struct tcpvegas_info))\r\n+ 64;\r\n}\r\nint inet_sk_diag_fill(struct sock *sk, struct inet_connection_sock *icsk,\r\nstruct sk_buff *skb, const struct inet_diag_req_v2 *req,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct tcp_congestion_ops *ca_ops;\r\nconst struct inet_diag_handler *handler;\r\nint ext = req->idiag_ext;\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *attr;\r\nvoid *info = NULL;\r\nhandler = inet_diag_table[req->sdiag_protocol];\r\nBUG_ON(!handler);\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nnlmsg_flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nBUG_ON(!sk_fullsock(sk));\r\ninet_diag_msg_common_fill(r, sk);\r\nr->idiag_state = sk->sk_state;\r\nr->idiag_timer = 0;\r\nr->idiag_retrans = 0;\r\nif (nla_put_u8(skb, INET_DIAG_SHUTDOWN, sk->sk_shutdown))\r\ngoto errout;\r\nif (ext & (1 << (INET_DIAG_TOS - 1)))\r\nif (nla_put_u8(skb, INET_DIAG_TOS, inet->tos) < 0)\r\ngoto errout;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (r->idiag_family == AF_INET6) {\r\nif (ext & (1 << (INET_DIAG_TCLASS - 1)))\r\nif (nla_put_u8(skb, INET_DIAG_TCLASS,\r\ninet6_sk(sk)->tclass) < 0)\r\ngoto errout;\r\nif (((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\r\nnla_put_u8(skb, INET_DIAG_SKV6ONLY, ipv6_only_sock(sk)))\r\ngoto errout;\r\n}\r\n#endif\r\nr->idiag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));\r\nr->idiag_inode = sock_i_ino(sk);\r\nif (ext & (1 << (INET_DIAG_MEMINFO - 1))) {\r\nstruct inet_diag_meminfo minfo = {\r\n.idiag_rmem = sk_rmem_alloc_get(sk),\r\n.idiag_wmem = sk->sk_wmem_queued,\r\n.idiag_fmem = sk->sk_forward_alloc,\r\n.idiag_tmem = sk_wmem_alloc_get(sk),\r\n};\r\nif (nla_put(skb, INET_DIAG_MEMINFO, sizeof(minfo), &minfo) < 0)\r\ngoto errout;\r\n}\r\nif (ext & (1 << (INET_DIAG_SKMEMINFO - 1)))\r\nif (sock_diag_put_meminfo(sk, skb, INET_DIAG_SKMEMINFO))\r\ngoto errout;\r\nif (!icsk) {\r\nhandler->idiag_get_info(sk, r, NULL);\r\ngoto out;\r\n}\r\n#define EXPIRES_IN_MS(tmo) DIV_ROUND_UP((tmo - jiffies) * 1000, HZ)\r\nif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\r\nicsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||\r\nicsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\r\nr->idiag_timer = 1;\r\nr->idiag_retrans = icsk->icsk_retransmits;\r\nr->idiag_expires = EXPIRES_IN_MS(icsk->icsk_timeout);\r\n} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\r\nr->idiag_timer = 4;\r\nr->idiag_retrans = icsk->icsk_probes_out;\r\nr->idiag_expires = EXPIRES_IN_MS(icsk->icsk_timeout);\r\n} else if (timer_pending(&sk->sk_timer)) {\r\nr->idiag_timer = 2;\r\nr->idiag_retrans = icsk->icsk_probes_out;\r\nr->idiag_expires = EXPIRES_IN_MS(sk->sk_timer.expires);\r\n} else {\r\nr->idiag_timer = 0;\r\nr->idiag_expires = 0;\r\n}\r\n#undef EXPIRES_IN_MS\r\nif ((ext & (1 << (INET_DIAG_INFO - 1))) && handler->idiag_info_size) {\r\nattr = nla_reserve(skb, INET_DIAG_INFO,\r\nhandler->idiag_info_size);\r\nif (!attr)\r\ngoto errout;\r\ninfo = nla_data(attr);\r\n}\r\nif (ext & (1 << (INET_DIAG_CONG - 1))) {\r\nint err = 0;\r\nrcu_read_lock();\r\nca_ops = READ_ONCE(icsk->icsk_ca_ops);\r\nif (ca_ops)\r\nerr = nla_put_string(skb, INET_DIAG_CONG, ca_ops->name);\r\nrcu_read_unlock();\r\nif (err < 0)\r\ngoto errout;\r\n}\r\nhandler->idiag_get_info(sk, r, info);\r\nif (sk->sk_state < TCP_TIME_WAIT) {\r\nunion tcp_cc_info info;\r\nsize_t sz = 0;\r\nint attr;\r\nrcu_read_lock();\r\nca_ops = READ_ONCE(icsk->icsk_ca_ops);\r\nif (ca_ops && ca_ops->get_info)\r\nsz = ca_ops->get_info(sk, ext, &attr, &info);\r\nrcu_read_unlock();\r\nif (sz && nla_put(skb, attr, sz, &info) < 0)\r\ngoto errout;\r\n}\r\nout:\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\nerrout:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int inet_csk_diag_fill(struct sock *sk,\r\nstruct sk_buff *skb,\r\nconst struct inet_diag_req_v2 *req,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nreturn inet_sk_diag_fill(sk, inet_csk(sk), skb, req,\r\nuser_ns, portid, seq, nlmsg_flags, unlh);\r\n}\r\nstatic int inet_twsk_diag_fill(struct sock *sk,\r\nstruct sk_buff *skb,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nstruct inet_timewait_sock *tw = inet_twsk(sk);\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nlong tmo;\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nnlmsg_flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nBUG_ON(tw->tw_state != TCP_TIME_WAIT);\r\ntmo = tw->tw_timer.expires - jiffies;\r\nif (tmo < 0)\r\ntmo = 0;\r\ninet_diag_msg_common_fill(r, sk);\r\nr->idiag_retrans = 0;\r\nr->idiag_state = tw->tw_substate;\r\nr->idiag_timer = 3;\r\nr->idiag_expires = jiffies_to_msecs(tmo);\r\nr->idiag_rqueue = 0;\r\nr->idiag_wqueue = 0;\r\nr->idiag_uid = 0;\r\nr->idiag_inode = 0;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\n}\r\nstatic int inet_req_diag_fill(struct sock *sk, struct sk_buff *skb,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nlong tmo;\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nnlmsg_flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\ninet_diag_msg_common_fill(r, sk);\r\nr->idiag_state = TCP_SYN_RECV;\r\nr->idiag_timer = 1;\r\nr->idiag_retrans = inet_reqsk(sk)->num_retrans;\r\nBUILD_BUG_ON(offsetof(struct inet_request_sock, ir_cookie) !=\r\noffsetof(struct sock, sk_cookie));\r\ntmo = inet_reqsk(sk)->rsk_timer.expires - jiffies;\r\nr->idiag_expires = (tmo >= 0) ? jiffies_to_msecs(tmo) : 0;\r\nr->idiag_rqueue = 0;\r\nr->idiag_wqueue = 0;\r\nr->idiag_uid = 0;\r\nr->idiag_inode = 0;\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\n}\r\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb,\r\nconst struct inet_diag_req_v2 *r,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nif (sk->sk_state == TCP_TIME_WAIT)\r\nreturn inet_twsk_diag_fill(sk, skb, portid, seq,\r\nnlmsg_flags, unlh);\r\nif (sk->sk_state == TCP_NEW_SYN_RECV)\r\nreturn inet_req_diag_fill(sk, skb, portid, seq,\r\nnlmsg_flags, unlh);\r\nreturn inet_csk_diag_fill(sk, skb, r, user_ns, portid, seq,\r\nnlmsg_flags, unlh);\r\n}\r\nint inet_diag_dump_one_icsk(struct inet_hashinfo *hashinfo,\r\nstruct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct inet_diag_req_v2 *req)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct sk_buff *rep;\r\nstruct sock *sk;\r\nint err;\r\nerr = -EINVAL;\r\nif (req->sdiag_family == AF_INET)\r\nsk = inet_lookup(net, hashinfo, req->id.idiag_dst[0],\r\nreq->id.idiag_dport, req->id.idiag_src[0],\r\nreq->id.idiag_sport, req->id.idiag_if);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse if (req->sdiag_family == AF_INET6)\r\nsk = inet6_lookup(net, hashinfo,\r\n(struct in6_addr *)req->id.idiag_dst,\r\nreq->id.idiag_dport,\r\n(struct in6_addr *)req->id.idiag_src,\r\nreq->id.idiag_sport,\r\nreq->id.idiag_if);\r\n#endif\r\nelse\r\ngoto out_nosk;\r\nerr = -ENOENT;\r\nif (!sk)\r\ngoto out_nosk;\r\nerr = sock_diag_check_cookie(sk, req->id.idiag_cookie);\r\nif (err)\r\ngoto out;\r\nrep = nlmsg_new(inet_sk_attr_size(), GFP_KERNEL);\r\nif (!rep) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = sk_diag_fill(sk, rep, req,\r\nsk_user_ns(NETLINK_CB(in_skb).sk),\r\nNETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, 0, nlh);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nnlmsg_free(rep);\r\ngoto out;\r\n}\r\nerr = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,\r\nMSG_DONTWAIT);\r\nif (err > 0)\r\nerr = 0;\r\nout:\r\nif (sk)\r\nsock_gen_put(sk);\r\nout_nosk:\r\nreturn err;\r\n}\r\nstatic int inet_diag_get_exact(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct inet_diag_req_v2 *req)\r\n{\r\nconst struct inet_diag_handler *handler;\r\nint err;\r\nhandler = inet_diag_lock_handler(req->sdiag_protocol);\r\nif (IS_ERR(handler))\r\nerr = PTR_ERR(handler);\r\nelse\r\nerr = handler->dump_one(in_skb, nlh, req);\r\ninet_diag_unlock_handler(handler);\r\nreturn err;\r\n}\r\nstatic int bitstring_match(const __be32 *a1, const __be32 *a2, int bits)\r\n{\r\nint words = bits >> 5;\r\nbits &= 0x1f;\r\nif (words) {\r\nif (memcmp(a1, a2, words << 2))\r\nreturn 0;\r\n}\r\nif (bits) {\r\n__be32 w1, w2;\r\n__be32 mask;\r\nw1 = a1[words];\r\nw2 = a2[words];\r\nmask = htonl((0xffffffff) << (32 - bits));\r\nif ((w1 ^ w2) & mask)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int inet_diag_bc_run(const struct nlattr *_bc,\r\nconst struct inet_diag_entry *entry)\r\n{\r\nconst void *bc = nla_data(_bc);\r\nint len = nla_len(_bc);\r\nwhile (len > 0) {\r\nint yes = 1;\r\nconst struct inet_diag_bc_op *op = bc;\r\nswitch (op->code) {\r\ncase INET_DIAG_BC_NOP:\r\nbreak;\r\ncase INET_DIAG_BC_JMP:\r\nyes = 0;\r\nbreak;\r\ncase INET_DIAG_BC_S_GE:\r\nyes = entry->sport >= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_S_LE:\r\nyes = entry->sport <= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_D_GE:\r\nyes = entry->dport >= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_D_LE:\r\nyes = entry->dport <= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_AUTO:\r\nyes = !(entry->userlocks & SOCK_BINDPORT_LOCK);\r\nbreak;\r\ncase INET_DIAG_BC_S_COND:\r\ncase INET_DIAG_BC_D_COND: {\r\nconst struct inet_diag_hostcond *cond;\r\nconst __be32 *addr;\r\ncond = (const struct inet_diag_hostcond *)(op + 1);\r\nif (cond->port != -1 &&\r\ncond->port != (op->code == INET_DIAG_BC_S_COND ?\r\nentry->sport : entry->dport)) {\r\nyes = 0;\r\nbreak;\r\n}\r\nif (op->code == INET_DIAG_BC_S_COND)\r\naddr = entry->saddr;\r\nelse\r\naddr = entry->daddr;\r\nif (cond->family != AF_UNSPEC &&\r\ncond->family != entry->family) {\r\nif (entry->family == AF_INET6 &&\r\ncond->family == AF_INET) {\r\nif (addr[0] == 0 && addr[1] == 0 &&\r\naddr[2] == htonl(0xffff) &&\r\nbitstring_match(addr + 3,\r\ncond->addr,\r\ncond->prefix_len))\r\nbreak;\r\n}\r\nyes = 0;\r\nbreak;\r\n}\r\nif (cond->prefix_len == 0)\r\nbreak;\r\nif (bitstring_match(addr, cond->addr,\r\ncond->prefix_len))\r\nbreak;\r\nyes = 0;\r\nbreak;\r\n}\r\n}\r\nif (yes) {\r\nlen -= op->yes;\r\nbc += op->yes;\r\n} else {\r\nlen -= op->no;\r\nbc += op->no;\r\n}\r\n}\r\nreturn len == 0;\r\n}\r\nstatic void entry_fill_addrs(struct inet_diag_entry *entry,\r\nconst struct sock *sk)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == AF_INET6) {\r\nentry->saddr = sk->sk_v6_rcv_saddr.s6_addr32;\r\nentry->daddr = sk->sk_v6_daddr.s6_addr32;\r\n} else\r\n#endif\r\n{\r\nentry->saddr = &sk->sk_rcv_saddr;\r\nentry->daddr = &sk->sk_daddr;\r\n}\r\n}\r\nint inet_diag_bc_sk(const struct nlattr *bc, struct sock *sk)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct inet_diag_entry entry;\r\nif (!bc)\r\nreturn 1;\r\nentry.family = sk->sk_family;\r\nentry_fill_addrs(&entry, sk);\r\nentry.sport = inet->inet_num;\r\nentry.dport = ntohs(inet->inet_dport);\r\nentry.userlocks = sk_fullsock(sk) ? sk->sk_userlocks : 0;\r\nreturn inet_diag_bc_run(bc, &entry);\r\n}\r\nstatic int valid_cc(const void *bc, int len, int cc)\r\n{\r\nwhile (len >= 0) {\r\nconst struct inet_diag_bc_op *op = bc;\r\nif (cc > len)\r\nreturn 0;\r\nif (cc == len)\r\nreturn 1;\r\nif (op->yes < 4 || op->yes & 3)\r\nreturn 0;\r\nlen -= op->yes;\r\nbc += op->yes;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool valid_hostcond(const struct inet_diag_bc_op *op, int len,\r\nint *min_len)\r\n{\r\nstruct inet_diag_hostcond *cond;\r\nint addr_len;\r\n*min_len += sizeof(struct inet_diag_hostcond);\r\nif (len < *min_len)\r\nreturn false;\r\ncond = (struct inet_diag_hostcond *)(op + 1);\r\nswitch (cond->family) {\r\ncase AF_UNSPEC:\r\naddr_len = 0;\r\nbreak;\r\ncase AF_INET:\r\naddr_len = sizeof(struct in_addr);\r\nbreak;\r\ncase AF_INET6:\r\naddr_len = sizeof(struct in6_addr);\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*min_len += addr_len;\r\nif (len < *min_len)\r\nreturn false;\r\nif (cond->prefix_len > 8 * addr_len)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool valid_port_comparison(const struct inet_diag_bc_op *op,\r\nint len, int *min_len)\r\n{\r\n*min_len += sizeof(struct inet_diag_bc_op);\r\nif (len < *min_len)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\r\n{\r\nconst void *bc = bytecode;\r\nint len = bytecode_len;\r\nwhile (len > 0) {\r\nint min_len = sizeof(struct inet_diag_bc_op);\r\nconst struct inet_diag_bc_op *op = bc;\r\nswitch (op->code) {\r\ncase INET_DIAG_BC_S_COND:\r\ncase INET_DIAG_BC_D_COND:\r\nif (!valid_hostcond(bc, len, &min_len))\r\nreturn -EINVAL;\r\nbreak;\r\ncase INET_DIAG_BC_S_GE:\r\ncase INET_DIAG_BC_S_LE:\r\ncase INET_DIAG_BC_D_GE:\r\ncase INET_DIAG_BC_D_LE:\r\nif (!valid_port_comparison(bc, len, &min_len))\r\nreturn -EINVAL;\r\nbreak;\r\ncase INET_DIAG_BC_AUTO:\r\ncase INET_DIAG_BC_JMP:\r\ncase INET_DIAG_BC_NOP:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (op->code != INET_DIAG_BC_NOP) {\r\nif (op->no < min_len || op->no > len + 4 || op->no & 3)\r\nreturn -EINVAL;\r\nif (op->no < len &&\r\n!valid_cc(bytecode, bytecode_len, len - op->no))\r\nreturn -EINVAL;\r\n}\r\nif (op->yes < min_len || op->yes > len + 4 || op->yes & 3)\r\nreturn -EINVAL;\r\nbc += op->yes;\r\nlen -= op->yes;\r\n}\r\nreturn len == 0 ? 0 : -EINVAL;\r\n}\r\nstatic int inet_csk_diag_dump(struct sock *sk,\r\nstruct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r,\r\nconst struct nlattr *bc)\r\n{\r\nif (!inet_diag_bc_sk(bc, sk))\r\nreturn 0;\r\nreturn inet_csk_diag_fill(sk, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).sk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\r\n}\r\nstatic void twsk_build_assert(void)\r\n{\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_family) !=\r\noffsetof(struct sock, sk_family));\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_num) !=\r\noffsetof(struct inet_sock, inet_num));\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_dport) !=\r\noffsetof(struct inet_sock, inet_dport));\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_rcv_saddr) !=\r\noffsetof(struct inet_sock, inet_rcv_saddr));\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_daddr) !=\r\noffsetof(struct inet_sock, inet_daddr));\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_v6_rcv_saddr) !=\r\noffsetof(struct sock, sk_v6_rcv_saddr));\r\nBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_v6_daddr) !=\r\noffsetof(struct sock, sk_v6_daddr));\r\n#endif\r\n}\r\nstatic int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\r\nstruct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r,\r\nconst struct nlattr *bc)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct inet_diag_entry entry;\r\nint j, s_j, reqnum, s_reqnum;\r\nstruct listen_sock *lopt;\r\nint err = 0;\r\ns_j = cb->args[3];\r\ns_reqnum = cb->args[4];\r\nif (s_j > 0)\r\ns_j--;\r\nentry.family = sk->sk_family;\r\nspin_lock(&icsk->icsk_accept_queue.syn_wait_lock);\r\nlopt = icsk->icsk_accept_queue.listen_opt;\r\nif (!lopt || !listen_sock_qlen(lopt))\r\ngoto out;\r\nif (bc) {\r\nentry.sport = inet->inet_num;\r\nentry.userlocks = sk->sk_userlocks;\r\n}\r\nfor (j = s_j; j < lopt->nr_table_entries; j++) {\r\nstruct request_sock *req, *head = lopt->syn_table[j];\r\nreqnum = 0;\r\nfor (req = head; req; reqnum++, req = req->dl_next) {\r\nstruct inet_request_sock *ireq = inet_rsk(req);\r\nif (reqnum < s_reqnum)\r\ncontinue;\r\nif (r->id.idiag_dport != ireq->ir_rmt_port &&\r\nr->id.idiag_dport)\r\ncontinue;\r\nif (bc) {\r\nentry_fill_addrs(&entry, req_to_sk(req));\r\nentry.dport = ntohs(ireq->ir_rmt_port);\r\nif (!inet_diag_bc_run(bc, &entry))\r\ncontinue;\r\n}\r\nerr = inet_req_diag_fill(req_to_sk(req), skb,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nNLM_F_MULTI, cb->nlh);\r\nif (err < 0) {\r\ncb->args[3] = j + 1;\r\ncb->args[4] = reqnum;\r\ngoto out;\r\n}\r\n}\r\ns_reqnum = 0;\r\n}\r\nout:\r\nspin_unlock(&icsk->icsk_accept_queue.syn_wait_lock);\r\nreturn err;\r\n}\r\nvoid inet_diag_dump_icsk(struct inet_hashinfo *hashinfo, struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r, struct nlattr *bc)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint i, num, s_i, s_num;\r\ns_i = cb->args[1];\r\ns_num = num = cb->args[2];\r\nif (cb->args[0] == 0) {\r\nif (!(r->idiag_states & (TCPF_LISTEN | TCPF_SYN_RECV)))\r\ngoto skip_listen_ht;\r\nfor (i = s_i; i < INET_LHTABLE_SIZE; i++) {\r\nstruct inet_listen_hashbucket *ilb;\r\nstruct hlist_nulls_node *node;\r\nstruct sock *sk;\r\nnum = 0;\r\nilb = &hashinfo->listening_hash[i];\r\nspin_lock_bh(&ilb->lock);\r\nsk_nulls_for_each(sk, node, &ilb->head) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (num < s_num) {\r\nnum++;\r\ncontinue;\r\n}\r\nif (r->sdiag_family != AF_UNSPEC &&\r\nsk->sk_family != r->sdiag_family)\r\ngoto next_listen;\r\nif (r->id.idiag_sport != inet->inet_sport &&\r\nr->id.idiag_sport)\r\ngoto next_listen;\r\nif (!(r->idiag_states & TCPF_LISTEN) ||\r\nr->id.idiag_dport ||\r\ncb->args[3] > 0)\r\ngoto syn_recv;\r\nif (inet_csk_diag_dump(sk, skb, cb, r, bc) < 0) {\r\nspin_unlock_bh(&ilb->lock);\r\ngoto done;\r\n}\r\nsyn_recv:\r\nif (!(r->idiag_states & TCPF_SYN_RECV))\r\ngoto next_listen;\r\nif (inet_diag_dump_reqs(skb, sk, cb, r, bc) < 0) {\r\nspin_unlock_bh(&ilb->lock);\r\ngoto done;\r\n}\r\nnext_listen:\r\ncb->args[3] = 0;\r\ncb->args[4] = 0;\r\n++num;\r\n}\r\nspin_unlock_bh(&ilb->lock);\r\ns_num = 0;\r\ncb->args[3] = 0;\r\ncb->args[4] = 0;\r\n}\r\nskip_listen_ht:\r\ncb->args[0] = 1;\r\ns_i = num = s_num = 0;\r\n}\r\nif (!(r->idiag_states & ~(TCPF_LISTEN | TCPF_SYN_RECV)))\r\ngoto out;\r\nfor (i = s_i; i <= hashinfo->ehash_mask; i++) {\r\nstruct inet_ehash_bucket *head = &hashinfo->ehash[i];\r\nspinlock_t *lock = inet_ehash_lockp(hashinfo, i);\r\nstruct hlist_nulls_node *node;\r\nstruct sock *sk;\r\nnum = 0;\r\nif (hlist_nulls_empty(&head->chain))\r\ncontinue;\r\nif (i > s_i)\r\ns_num = 0;\r\nspin_lock_bh(lock);\r\nsk_nulls_for_each(sk, node, &head->chain) {\r\nint state, res;\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (num < s_num)\r\ngoto next_normal;\r\nstate = (sk->sk_state == TCP_TIME_WAIT) ?\r\ninet_twsk(sk)->tw_substate : sk->sk_state;\r\nif (!(r->idiag_states & (1 << state)))\r\ngoto next_normal;\r\nif (r->sdiag_family != AF_UNSPEC &&\r\nsk->sk_family != r->sdiag_family)\r\ngoto next_normal;\r\nif (r->id.idiag_sport != htons(sk->sk_num) &&\r\nr->id.idiag_sport)\r\ngoto next_normal;\r\nif (r->id.idiag_dport != sk->sk_dport &&\r\nr->id.idiag_dport)\r\ngoto next_normal;\r\ntwsk_build_assert();\r\nif (!inet_diag_bc_sk(bc, sk))\r\ngoto next_normal;\r\nres = sk_diag_fill(sk, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).sk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\ncb->nlh);\r\nif (res < 0) {\r\nspin_unlock_bh(lock);\r\ngoto done;\r\n}\r\nnext_normal:\r\n++num;\r\n}\r\nspin_unlock_bh(lock);\r\n}\r\ndone:\r\ncb->args[1] = i;\r\ncb->args[2] = num;\r\nout:\r\n;\r\n}\r\nstatic int __inet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r,\r\nstruct nlattr *bc)\r\n{\r\nconst struct inet_diag_handler *handler;\r\nint err = 0;\r\nhandler = inet_diag_lock_handler(r->sdiag_protocol);\r\nif (!IS_ERR(handler))\r\nhandler->dump(skb, cb, r, bc);\r\nelse\r\nerr = PTR_ERR(handler);\r\ninet_diag_unlock_handler(handler);\r\nreturn err ? : skb->len;\r\n}\r\nstatic int inet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint hdrlen = sizeof(struct inet_diag_req_v2);\r\nstruct nlattr *bc = NULL;\r\nif (nlmsg_attrlen(cb->nlh, hdrlen))\r\nbc = nlmsg_find_attr(cb->nlh, hdrlen, INET_DIAG_REQ_BYTECODE);\r\nreturn __inet_diag_dump(skb, cb, nlmsg_data(cb->nlh), bc);\r\n}\r\nstatic int inet_diag_type2proto(int type)\r\n{\r\nswitch (type) {\r\ncase TCPDIAG_GETSOCK:\r\nreturn IPPROTO_TCP;\r\ncase DCCPDIAG_GETSOCK:\r\nreturn IPPROTO_DCCP;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int inet_diag_dump_compat(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct inet_diag_req *rc = nlmsg_data(cb->nlh);\r\nint hdrlen = sizeof(struct inet_diag_req);\r\nstruct inet_diag_req_v2 req;\r\nstruct nlattr *bc = NULL;\r\nreq.sdiag_family = AF_UNSPEC;\r\nreq.sdiag_protocol = inet_diag_type2proto(cb->nlh->nlmsg_type);\r\nreq.idiag_ext = rc->idiag_ext;\r\nreq.idiag_states = rc->idiag_states;\r\nreq.id = rc->id;\r\nif (nlmsg_attrlen(cb->nlh, hdrlen))\r\nbc = nlmsg_find_attr(cb->nlh, hdrlen, INET_DIAG_REQ_BYTECODE);\r\nreturn __inet_diag_dump(skb, cb, &req, bc);\r\n}\r\nstatic int inet_diag_get_exact_compat(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh)\r\n{\r\nstruct inet_diag_req *rc = nlmsg_data(nlh);\r\nstruct inet_diag_req_v2 req;\r\nreq.sdiag_family = rc->idiag_family;\r\nreq.sdiag_protocol = inet_diag_type2proto(nlh->nlmsg_type);\r\nreq.idiag_ext = rc->idiag_ext;\r\nreq.idiag_states = rc->idiag_states;\r\nreq.id = rc->id;\r\nreturn inet_diag_get_exact(in_skb, nlh, &req);\r\n}\r\nstatic int inet_diag_rcv_msg_compat(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nint hdrlen = sizeof(struct inet_diag_req);\r\nstruct net *net = sock_net(skb->sk);\r\nif (nlh->nlmsg_type >= INET_DIAG_GETSOCK_MAX ||\r\nnlmsg_len(nlh) < hdrlen)\r\nreturn -EINVAL;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nif (nlmsg_attrlen(nlh, hdrlen)) {\r\nstruct nlattr *attr;\r\nattr = nlmsg_find_attr(nlh, hdrlen,\r\nINET_DIAG_REQ_BYTECODE);\r\nif (!attr ||\r\nnla_len(attr) < sizeof(struct inet_diag_bc_op) ||\r\ninet_diag_bc_audit(nla_data(attr), nla_len(attr)))\r\nreturn -EINVAL;\r\n}\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = inet_diag_dump_compat,\r\n};\r\nreturn netlink_dump_start(net->diag_nlsk, skb, nlh, &c);\r\n}\r\n}\r\nreturn inet_diag_get_exact_compat(skb, nlh);\r\n}\r\nstatic int inet_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\r\n{\r\nint hdrlen = sizeof(struct inet_diag_req_v2);\r\nstruct net *net = sock_net(skb->sk);\r\nif (nlmsg_len(h) < hdrlen)\r\nreturn -EINVAL;\r\nif (h->nlmsg_flags & NLM_F_DUMP) {\r\nif (nlmsg_attrlen(h, hdrlen)) {\r\nstruct nlattr *attr;\r\nattr = nlmsg_find_attr(h, hdrlen,\r\nINET_DIAG_REQ_BYTECODE);\r\nif (!attr ||\r\nnla_len(attr) < sizeof(struct inet_diag_bc_op) ||\r\ninet_diag_bc_audit(nla_data(attr), nla_len(attr)))\r\nreturn -EINVAL;\r\n}\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = inet_diag_dump,\r\n};\r\nreturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\r\n}\r\n}\r\nreturn inet_diag_get_exact(skb, h, nlmsg_data(h));\r\n}\r\nstatic\r\nint inet_diag_handler_get_info(struct sk_buff *skb, struct sock *sk)\r\n{\r\nconst struct inet_diag_handler *handler;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *attr;\r\nstruct inet_diag_msg *r;\r\nvoid *info = NULL;\r\nint err = 0;\r\nnlh = nlmsg_put(skb, 0, 0, SOCK_DIAG_BY_FAMILY, sizeof(*r), 0);\r\nif (!nlh)\r\nreturn -ENOMEM;\r\nr = nlmsg_data(nlh);\r\nmemset(r, 0, sizeof(*r));\r\ninet_diag_msg_common_fill(r, sk);\r\nif (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_STREAM)\r\nr->id.idiag_sport = inet_sk(sk)->inet_sport;\r\nr->idiag_state = sk->sk_state;\r\nif ((err = nla_put_u8(skb, INET_DIAG_PROTOCOL, sk->sk_protocol))) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nhandler = inet_diag_lock_handler(sk->sk_protocol);\r\nif (IS_ERR(handler)) {\r\ninet_diag_unlock_handler(handler);\r\nnlmsg_cancel(skb, nlh);\r\nreturn PTR_ERR(handler);\r\n}\r\nattr = handler->idiag_info_size\r\n? nla_reserve(skb, INET_DIAG_INFO, handler->idiag_info_size)\r\n: NULL;\r\nif (attr)\r\ninfo = nla_data(attr);\r\nhandler->idiag_get_info(sk, r, info);\r\ninet_diag_unlock_handler(handler);\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\n}\r\nint inet_diag_register(const struct inet_diag_handler *h)\r\n{\r\nconst __u16 type = h->idiag_type;\r\nint err = -EINVAL;\r\nif (type >= IPPROTO_MAX)\r\ngoto out;\r\nmutex_lock(&inet_diag_table_mutex);\r\nerr = -EEXIST;\r\nif (!inet_diag_table[type]) {\r\ninet_diag_table[type] = h;\r\nerr = 0;\r\n}\r\nmutex_unlock(&inet_diag_table_mutex);\r\nout:\r\nreturn err;\r\n}\r\nvoid inet_diag_unregister(const struct inet_diag_handler *h)\r\n{\r\nconst __u16 type = h->idiag_type;\r\nif (type >= IPPROTO_MAX)\r\nreturn;\r\nmutex_lock(&inet_diag_table_mutex);\r\ninet_diag_table[type] = NULL;\r\nmutex_unlock(&inet_diag_table_mutex);\r\n}\r\nstatic int __init inet_diag_init(void)\r\n{\r\nconst int inet_diag_table_size = (IPPROTO_MAX *\r\nsizeof(struct inet_diag_handler *));\r\nint err = -ENOMEM;\r\ninet_diag_table = kzalloc(inet_diag_table_size, GFP_KERNEL);\r\nif (!inet_diag_table)\r\ngoto out;\r\nerr = sock_diag_register(&inet_diag_handler);\r\nif (err)\r\ngoto out_free_nl;\r\nerr = sock_diag_register(&inet6_diag_handler);\r\nif (err)\r\ngoto out_free_inet;\r\nsock_diag_register_inet_compat(inet_diag_rcv_msg_compat);\r\nout:\r\nreturn err;\r\nout_free_inet:\r\nsock_diag_unregister(&inet_diag_handler);\r\nout_free_nl:\r\nkfree(inet_diag_table);\r\ngoto out;\r\n}\r\nstatic void __exit inet_diag_exit(void)\r\n{\r\nsock_diag_unregister(&inet6_diag_handler);\r\nsock_diag_unregister(&inet_diag_handler);\r\nsock_diag_unregister_inet_compat(inet_diag_rcv_msg_compat);\r\nkfree(inet_diag_table);\r\n}
