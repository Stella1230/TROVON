int nvec_register_notifier(struct nvec_chip *nvec, struct notifier_block *nb,\r\nunsigned int events)\r\n{\r\nreturn atomic_notifier_chain_register(&nvec->notifier_list, nb);\r\n}\r\nint nvec_unregister_notifier(struct nvec_chip *nvec, struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_unregister(&nvec->notifier_list, nb);\r\n}\r\nstatic int nvec_status_notifier(struct notifier_block *nb,\r\nunsigned long event_type, void *data)\r\n{\r\nstruct nvec_chip *nvec = container_of(nb, struct nvec_chip,\r\nnvec_status_notifier);\r\nunsigned char *msg = (unsigned char *)data;\r\nif (event_type != NVEC_CNTL)\r\nreturn NOTIFY_DONE;\r\ndev_warn(nvec->dev, "unhandled msg type %ld\n", event_type);\r\nprint_hex_dump(KERN_WARNING, "payload: ", DUMP_PREFIX_NONE, 16, 1,\r\nmsg, msg[1] + 2, true);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic struct nvec_msg *nvec_msg_alloc(struct nvec_chip *nvec,\r\nenum nvec_msg_category category)\r\n{\r\nint i = (category == NVEC_MSG_TX) ? (NVEC_POOL_SIZE / 4) : 0;\r\nfor (; i < NVEC_POOL_SIZE; i++) {\r\nif (atomic_xchg(&nvec->msg_pool[i].used, 1) == 0) {\r\ndev_vdbg(nvec->dev, "INFO: Allocate %i\n", i);\r\nreturn &nvec->msg_pool[i];\r\n}\r\n}\r\ndev_err(nvec->dev, "could not allocate %s buffer\n",\r\n(category == NVEC_MSG_TX) ? "TX" : "RX");\r\nreturn NULL;\r\n}\r\nvoid nvec_msg_free(struct nvec_chip *nvec, struct nvec_msg *msg)\r\n{\r\nif (msg != &nvec->tx_scratch)\r\ndev_vdbg(nvec->dev, "INFO: Free %ti\n", msg - nvec->msg_pool);\r\natomic_set(&msg->used, 0);\r\n}\r\nstatic bool nvec_msg_is_event(struct nvec_msg *msg)\r\n{\r\nreturn msg->data[0] >> 7;\r\n}\r\nstatic size_t nvec_msg_size(struct nvec_msg *msg)\r\n{\r\nbool is_event = nvec_msg_is_event(msg);\r\nint event_length = (msg->data[0] & 0x60) >> 5;\r\nif (!is_event || event_length == NVEC_VAR_SIZE)\r\nreturn (msg->pos || msg->size) ? (msg->data[1] + 2) : 0;\r\nelse if (event_length == NVEC_2BYTES)\r\nreturn 2;\r\nelse if (event_length == NVEC_3BYTES)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic void nvec_gpio_set_value(struct nvec_chip *nvec, int value)\r\n{\r\ndev_dbg(nvec->dev, "GPIO changed from %u to %u\n",\r\ngpio_get_value(nvec->gpio), value);\r\ngpio_set_value(nvec->gpio, value);\r\n}\r\nint nvec_write_async(struct nvec_chip *nvec, const unsigned char *data,\r\nshort size)\r\n{\r\nstruct nvec_msg *msg;\r\nunsigned long flags;\r\nmsg = nvec_msg_alloc(nvec, NVEC_MSG_TX);\r\nif (msg == NULL)\r\nreturn -ENOMEM;\r\nmsg->data[0] = size;\r\nmemcpy(msg->data + 1, data, size);\r\nmsg->size = size + 1;\r\nspin_lock_irqsave(&nvec->tx_lock, flags);\r\nlist_add_tail(&msg->node, &nvec->tx_data);\r\nspin_unlock_irqrestore(&nvec->tx_lock, flags);\r\nschedule_work(&nvec->tx_work);\r\nreturn 0;\r\n}\r\nstruct nvec_msg *nvec_write_sync(struct nvec_chip *nvec,\r\nconst unsigned char *data, short size)\r\n{\r\nstruct nvec_msg *msg;\r\nmutex_lock(&nvec->sync_write_mutex);\r\nnvec->sync_write_pending = (data[1] << 8) + data[0];\r\nif (nvec_write_async(nvec, data, size) < 0) {\r\nmutex_unlock(&nvec->sync_write_mutex);\r\nreturn NULL;\r\n}\r\ndev_dbg(nvec->dev, "nvec_sync_write: 0x%04x\n",\r\nnvec->sync_write_pending);\r\nif (!(wait_for_completion_timeout(&nvec->sync_write,\r\nmsecs_to_jiffies(2000)))) {\r\ndev_warn(nvec->dev, "timeout waiting for sync write to complete\n");\r\nmutex_unlock(&nvec->sync_write_mutex);\r\nreturn NULL;\r\n}\r\ndev_dbg(nvec->dev, "nvec_sync_write: pong!\n");\r\nmsg = nvec->last_sync_msg;\r\nmutex_unlock(&nvec->sync_write_mutex);\r\nreturn msg;\r\n}\r\nstatic void nvec_toggle_global_events(struct nvec_chip *nvec, bool state)\r\n{\r\nunsigned char global_events[] = { NVEC_SLEEP, GLOBAL_EVENTS, state };\r\nnvec_write_async(nvec, global_events, 3);\r\n}\r\nstatic void nvec_event_mask(char *ev, u32 mask)\r\n{\r\nev[3] = mask >> 16 & 0xff;\r\nev[4] = mask >> 24 & 0xff;\r\nev[5] = mask >> 0 & 0xff;\r\nev[6] = mask >> 8 & 0xff;\r\n}\r\nstatic void nvec_request_master(struct work_struct *work)\r\n{\r\nstruct nvec_chip *nvec = container_of(work, struct nvec_chip, tx_work);\r\nunsigned long flags;\r\nlong err;\r\nstruct nvec_msg *msg;\r\nspin_lock_irqsave(&nvec->tx_lock, flags);\r\nwhile (!list_empty(&nvec->tx_data)) {\r\nmsg = list_first_entry(&nvec->tx_data, struct nvec_msg, node);\r\nspin_unlock_irqrestore(&nvec->tx_lock, flags);\r\nnvec_gpio_set_value(nvec, 0);\r\nerr = wait_for_completion_interruptible_timeout(\r\n&nvec->ec_transfer, msecs_to_jiffies(5000));\r\nif (err == 0) {\r\ndev_warn(nvec->dev, "timeout waiting for ec transfer\n");\r\nnvec_gpio_set_value(nvec, 1);\r\nmsg->pos = 0;\r\n}\r\nspin_lock_irqsave(&nvec->tx_lock, flags);\r\nif (err > 0) {\r\nlist_del_init(&msg->node);\r\nnvec_msg_free(nvec, msg);\r\n}\r\n}\r\nspin_unlock_irqrestore(&nvec->tx_lock, flags);\r\n}\r\nstatic int parse_msg(struct nvec_chip *nvec, struct nvec_msg *msg)\r\n{\r\nif ((msg->data[0] & 1 << 7) == 0 && msg->data[3]) {\r\ndev_err(nvec->dev, "ec responded %*ph\n", 4, msg->data);\r\nreturn -EINVAL;\r\n}\r\nif ((msg->data[0] >> 7) == 1 && (msg->data[0] & 0x0f) == 5)\r\nprint_hex_dump(KERN_WARNING, "ec system event ",\r\nDUMP_PREFIX_NONE, 16, 1, msg->data,\r\nmsg->data[1] + 2, true);\r\natomic_notifier_call_chain(&nvec->notifier_list, msg->data[0] & 0x8f,\r\nmsg->data);\r\nreturn 0;\r\n}\r\nstatic void nvec_dispatch(struct work_struct *work)\r\n{\r\nstruct nvec_chip *nvec = container_of(work, struct nvec_chip, rx_work);\r\nunsigned long flags;\r\nstruct nvec_msg *msg;\r\nspin_lock_irqsave(&nvec->rx_lock, flags);\r\nwhile (!list_empty(&nvec->rx_data)) {\r\nmsg = list_first_entry(&nvec->rx_data, struct nvec_msg, node);\r\nlist_del_init(&msg->node);\r\nspin_unlock_irqrestore(&nvec->rx_lock, flags);\r\nif (nvec->sync_write_pending ==\r\n(msg->data[2] << 8) + msg->data[0]) {\r\ndev_dbg(nvec->dev, "sync write completed!\n");\r\nnvec->sync_write_pending = 0;\r\nnvec->last_sync_msg = msg;\r\ncomplete(&nvec->sync_write);\r\n} else {\r\nparse_msg(nvec, msg);\r\nnvec_msg_free(nvec, msg);\r\n}\r\nspin_lock_irqsave(&nvec->rx_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&nvec->rx_lock, flags);\r\n}\r\nstatic void nvec_tx_completed(struct nvec_chip *nvec)\r\n{\r\nif (nvec->tx->pos != nvec->tx->size) {\r\ndev_err(nvec->dev, "premature END_TRANS, resending\n");\r\nnvec->tx->pos = 0;\r\nnvec_gpio_set_value(nvec, 0);\r\n} else {\r\nnvec->state = 0;\r\n}\r\n}\r\nstatic void nvec_rx_completed(struct nvec_chip *nvec)\r\n{\r\nif (nvec->rx->pos != nvec_msg_size(nvec->rx)) {\r\ndev_err(nvec->dev, "RX incomplete: Expected %u bytes, got %u\n",\r\n(uint) nvec_msg_size(nvec->rx),\r\n(uint) nvec->rx->pos);\r\nnvec_msg_free(nvec, nvec->rx);\r\nnvec->state = 0;\r\nif (nvec->rx->data[0] == NVEC_BAT)\r\ncomplete(&nvec->ec_transfer);\r\nreturn;\r\n}\r\nspin_lock(&nvec->rx_lock);\r\nlist_add_tail(&nvec->rx->node, &nvec->rx_data);\r\nspin_unlock(&nvec->rx_lock);\r\nnvec->state = 0;\r\nif (!nvec_msg_is_event(nvec->rx))\r\ncomplete(&nvec->ec_transfer);\r\nschedule_work(&nvec->rx_work);\r\n}\r\nstatic void nvec_invalid_flags(struct nvec_chip *nvec, unsigned int status,\r\nbool reset)\r\n{\r\ndev_err(nvec->dev, "unexpected status flags 0x%02x during state %i\n",\r\nstatus, nvec->state);\r\nif (reset)\r\nnvec->state = 0;\r\n}\r\nstatic void nvec_tx_set(struct nvec_chip *nvec)\r\n{\r\nspin_lock(&nvec->tx_lock);\r\nif (list_empty(&nvec->tx_data)) {\r\ndev_err(nvec->dev, "empty tx - sending no-op\n");\r\nmemcpy(nvec->tx_scratch.data, "\x02\x07\x02", 3);\r\nnvec->tx_scratch.size = 3;\r\nnvec->tx_scratch.pos = 0;\r\nnvec->tx = &nvec->tx_scratch;\r\nlist_add_tail(&nvec->tx->node, &nvec->tx_data);\r\n} else {\r\nnvec->tx = list_first_entry(&nvec->tx_data, struct nvec_msg,\r\nnode);\r\nnvec->tx->pos = 0;\r\n}\r\nspin_unlock(&nvec->tx_lock);\r\ndev_dbg(nvec->dev, "Sending message of length %u, command 0x%x\n",\r\n(uint)nvec->tx->size, nvec->tx->data[1]);\r\n}\r\nstatic irqreturn_t nvec_interrupt(int irq, void *dev)\r\n{\r\nunsigned long status;\r\nunsigned int received = 0;\r\nunsigned char to_send = 0xff;\r\nconst unsigned long irq_mask = I2C_SL_IRQ | END_TRANS | RCVD | RNW;\r\nstruct nvec_chip *nvec = dev;\r\nunsigned int state = nvec->state;\r\nstatus = readl(nvec->base + I2C_SL_STATUS);\r\nif ((status & irq_mask) == 0 && (status & ~irq_mask) != 0) {\r\ndev_err(nvec->dev, "unexpected irq mask %lx\n", status);\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((status & I2C_SL_IRQ) == 0) {\r\ndev_err(nvec->dev, "Spurious IRQ\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((status & RNW) == 0) {\r\nreceived = readl(nvec->base + I2C_SL_RCVD);\r\nif (status & RCVD)\r\nwritel(0, nvec->base + I2C_SL_RCVD);\r\n}\r\nif (status == (I2C_SL_IRQ | RCVD))\r\nnvec->state = 0;\r\nswitch (nvec->state) {\r\ncase 0:\r\nif (status != (I2C_SL_IRQ | RCVD))\r\nnvec_invalid_flags(nvec, status, false);\r\nbreak;\r\ncase 1:\r\nif (status != I2C_SL_IRQ) {\r\nnvec_invalid_flags(nvec, status, true);\r\n} else {\r\nnvec->rx = nvec_msg_alloc(nvec, NVEC_MSG_RX);\r\nif (unlikely(nvec->rx == NULL)) {\r\nnvec->state = 0;\r\nbreak;\r\n}\r\nnvec->rx->data[0] = received;\r\nnvec->rx->pos = 1;\r\nnvec->state = 2;\r\n}\r\nbreak;\r\ncase 2:\r\nif (status == (I2C_SL_IRQ | RNW | RCVD)) {\r\nudelay(33);\r\nif (nvec->rx->data[0] != 0x01) {\r\ndev_err(nvec->dev,\r\n"Read without prior read command\n");\r\nnvec->state = 0;\r\nbreak;\r\n}\r\nnvec_msg_free(nvec, nvec->rx);\r\nnvec->state = 3;\r\nnvec_tx_set(nvec);\r\nBUG_ON(nvec->tx->size < 1);\r\nto_send = nvec->tx->data[0];\r\nnvec->tx->pos = 1;\r\n} else if (status == (I2C_SL_IRQ)) {\r\nBUG_ON(nvec->rx == NULL);\r\nnvec->rx->data[1] = received;\r\nnvec->rx->pos = 2;\r\nnvec->state = 4;\r\n} else {\r\nnvec_invalid_flags(nvec, status, true);\r\n}\r\nbreak;\r\ncase 3:\r\nif (status & END_TRANS) {\r\nnvec_tx_completed(nvec);\r\n} else if ((status & RNW) == 0 || (status & RCVD)) {\r\nnvec_invalid_flags(nvec, status, true);\r\n} else if (nvec->tx && nvec->tx->pos < nvec->tx->size) {\r\nto_send = nvec->tx->data[nvec->tx->pos++];\r\n} else {\r\ndev_err(nvec->dev, "tx buffer underflow on %p (%u > %u)\n",\r\nnvec->tx,\r\n(uint) (nvec->tx ? nvec->tx->pos : 0),\r\n(uint) (nvec->tx ? nvec->tx->size : 0));\r\nnvec->state = 0;\r\n}\r\nbreak;\r\ncase 4:\r\nif ((status & (END_TRANS | RNW)) == END_TRANS)\r\nnvec_rx_completed(nvec);\r\nelse if (status & (RNW | RCVD))\r\nnvec_invalid_flags(nvec, status, true);\r\nelse if (nvec->rx && nvec->rx->pos < NVEC_MSG_SIZE)\r\nnvec->rx->data[nvec->rx->pos++] = received;\r\nelse\r\ndev_err(nvec->dev,\r\n"RX buffer overflow on %p: Trying to write byte %u of %u\n",\r\nnvec->rx, nvec->rx ? nvec->rx->pos : 0,\r\nNVEC_MSG_SIZE);\r\nbreak;\r\ndefault:\r\nnvec->state = 0;\r\n}\r\nif ((status & (RCVD | RNW)) == RCVD) {\r\nif (received != nvec->i2c_addr)\r\ndev_err(nvec->dev,\r\n"received address 0x%02x, expected 0x%02x\n",\r\nreceived, nvec->i2c_addr);\r\nnvec->state = 1;\r\n}\r\nif ((status & (RNW | END_TRANS)) == RNW)\r\nwritel(to_send, nvec->base + I2C_SL_RCVD);\r\nif (status == (I2C_SL_IRQ | RNW | RCVD))\r\nnvec_gpio_set_value(nvec, 1);\r\ndev_dbg(nvec->dev,\r\n"Handled: %s 0x%02x, %s 0x%02x in state %u [%s%s%s]\n",\r\n(status & RNW) == 0 ? "received" : "R=",\r\nreceived,\r\n(status & (RNW | END_TRANS)) ? "sent" : "S=",\r\nto_send,\r\nstate,\r\nstatus & END_TRANS ? " END_TRANS" : "",\r\nstatus & RCVD ? " RCVD" : "",\r\nstatus & RNW ? " RNW" : "");\r\nudelay(100);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tegra_init_i2c_slave(struct nvec_chip *nvec)\r\n{\r\nu32 val;\r\nclk_prepare_enable(nvec->i2c_clk);\r\nreset_control_assert(nvec->rst);\r\nudelay(2);\r\nreset_control_deassert(nvec->rst);\r\nval = I2C_CNFG_NEW_MASTER_SFM | I2C_CNFG_PACKET_MODE_EN |\r\n(0x2 << I2C_CNFG_DEBOUNCE_CNT_SHIFT);\r\nwritel(val, nvec->base + I2C_CNFG);\r\nclk_set_rate(nvec->i2c_clk, 8 * 80000);\r\nwritel(I2C_SL_NEWSL, nvec->base + I2C_SL_CNFG);\r\nwritel(0x1E, nvec->base + I2C_SL_DELAY_COUNT);\r\nwritel(nvec->i2c_addr>>1, nvec->base + I2C_SL_ADDR1);\r\nwritel(0, nvec->base + I2C_SL_ADDR2);\r\nenable_irq(nvec->irq);\r\n}\r\nstatic void nvec_disable_i2c_slave(struct nvec_chip *nvec)\r\n{\r\ndisable_irq(nvec->irq);\r\nwritel(I2C_SL_NEWSL | I2C_SL_NACK, nvec->base + I2C_SL_CNFG);\r\nclk_disable_unprepare(nvec->i2c_clk);\r\n}\r\nstatic void nvec_power_off(void)\r\n{\r\nchar ap_pwr_down[] = { NVEC_SLEEP, AP_PWR_DOWN };\r\nnvec_toggle_global_events(nvec_power_handle, false);\r\nnvec_write_async(nvec_power_handle, ap_pwr_down, 2);\r\n}\r\nstatic int nvec_i2c_parse_dt_pdata(struct nvec_chip *nvec)\r\n{\r\nnvec->gpio = of_get_named_gpio(nvec->dev->of_node, "request-gpios", 0);\r\nif (nvec->gpio < 0) {\r\ndev_err(nvec->dev, "no gpio specified");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(nvec->dev->of_node, "slave-addr",\r\n&nvec->i2c_addr)) {\r\ndev_err(nvec->dev, "no i2c address specified");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_nvec_probe(struct platform_device *pdev)\r\n{\r\nint err, ret;\r\nstruct clk *i2c_clk;\r\nstruct nvec_chip *nvec;\r\nstruct nvec_msg *msg;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nchar get_firmware_version[] = { NVEC_CNTL, GET_FIRMWARE_VERSION },\r\nunmute_speakers[] = { NVEC_OEM0, 0x10, 0x59, 0x95 },\r\nenable_event[7] = { NVEC_SYS, CNF_EVENT_REPORTING, true };\r\nif (!pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "must be instantiated using device tree\n");\r\nreturn -ENODEV;\r\n}\r\nnvec = devm_kzalloc(&pdev->dev, sizeof(struct nvec_chip), GFP_KERNEL);\r\nif (!nvec)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, nvec);\r\nnvec->dev = &pdev->dev;\r\nerr = nvec_i2c_parse_dt_pdata(nvec);\r\nif (err < 0)\r\nreturn err;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nnvec->irq = platform_get_irq(pdev, 0);\r\nif (nvec->irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -ENODEV;\r\n}\r\ni2c_clk = devm_clk_get(&pdev->dev, "div-clk");\r\nif (IS_ERR(i2c_clk)) {\r\ndev_err(nvec->dev, "failed to get controller clock\n");\r\nreturn -ENODEV;\r\n}\r\nnvec->rst = devm_reset_control_get(&pdev->dev, "i2c");\r\nif (IS_ERR(nvec->rst)) {\r\ndev_err(nvec->dev, "failed to get controller reset\n");\r\nreturn PTR_ERR(nvec->rst);\r\n}\r\nnvec->base = base;\r\nnvec->i2c_clk = i2c_clk;\r\nnvec->rx = &nvec->msg_pool[0];\r\nATOMIC_INIT_NOTIFIER_HEAD(&nvec->notifier_list);\r\ninit_completion(&nvec->sync_write);\r\ninit_completion(&nvec->ec_transfer);\r\nmutex_init(&nvec->sync_write_mutex);\r\nspin_lock_init(&nvec->tx_lock);\r\nspin_lock_init(&nvec->rx_lock);\r\nINIT_LIST_HEAD(&nvec->rx_data);\r\nINIT_LIST_HEAD(&nvec->tx_data);\r\nINIT_WORK(&nvec->rx_work, nvec_dispatch);\r\nINIT_WORK(&nvec->tx_work, nvec_request_master);\r\nerr = devm_gpio_request_one(&pdev->dev, nvec->gpio, GPIOF_OUT_INIT_HIGH,\r\n"nvec gpio");\r\nif (err < 0) {\r\ndev_err(nvec->dev, "couldn't request gpio\n");\r\nreturn -ENODEV;\r\n}\r\nerr = devm_request_irq(&pdev->dev, nvec->irq, nvec_interrupt, 0,\r\n"nvec", nvec);\r\nif (err) {\r\ndev_err(nvec->dev, "couldn't request irq\n");\r\nreturn -ENODEV;\r\n}\r\ndisable_irq(nvec->irq);\r\ntegra_init_i2c_slave(nvec);\r\nnvec_toggle_global_events(nvec, true);\r\nnvec->nvec_status_notifier.notifier_call = nvec_status_notifier;\r\nnvec_register_notifier(nvec, &nvec->nvec_status_notifier, 0);\r\nnvec_power_handle = nvec;\r\npm_power_off = nvec_power_off;\r\nmsg = nvec_write_sync(nvec, get_firmware_version, 2);\r\nif (msg) {\r\ndev_warn(nvec->dev, "ec firmware version %02x.%02x.%02x / %02x\n",\r\nmsg->data[4], msg->data[5], msg->data[6], msg->data[7]);\r\nnvec_msg_free(nvec, msg);\r\n}\r\nret = mfd_add_devices(nvec->dev, 0, nvec_devices,\r\nARRAY_SIZE(nvec_devices), NULL, 0, NULL);\r\nif (ret)\r\ndev_err(nvec->dev, "error adding subdevices\n");\r\nnvec_write_async(nvec, unmute_speakers, 4);\r\nnvec_event_mask(enable_event, LID_SWITCH);\r\nnvec_write_async(nvec, enable_event, 7);\r\nnvec_event_mask(enable_event, PWR_BUTTON);\r\nnvec_write_async(nvec, enable_event, 7);\r\nreturn 0;\r\n}\r\nstatic int tegra_nvec_remove(struct platform_device *pdev)\r\n{\r\nstruct nvec_chip *nvec = platform_get_drvdata(pdev);\r\nnvec_toggle_global_events(nvec, false);\r\nmfd_remove_devices(nvec->dev);\r\nnvec_unregister_notifier(nvec, &nvec->nvec_status_notifier);\r\ncancel_work_sync(&nvec->rx_work);\r\ncancel_work_sync(&nvec->tx_work);\r\npm_power_off = NULL;\r\nreturn 0;\r\n}\r\nstatic int nvec_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct nvec_chip *nvec = platform_get_drvdata(pdev);\r\nstruct nvec_msg *msg;\r\nchar ap_suspend[] = { NVEC_SLEEP, AP_SUSPEND };\r\ndev_dbg(nvec->dev, "suspending\n");\r\nnvec_toggle_global_events(nvec, false);\r\nmsg = nvec_write_sync(nvec, ap_suspend, sizeof(ap_suspend));\r\nnvec_msg_free(nvec, msg);\r\nnvec_disable_i2c_slave(nvec);\r\nreturn 0;\r\n}\r\nstatic int nvec_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct nvec_chip *nvec = platform_get_drvdata(pdev);\r\ndev_dbg(nvec->dev, "resuming\n");\r\ntegra_init_i2c_slave(nvec);\r\nnvec_toggle_global_events(nvec, true);\r\nreturn 0;\r\n}
