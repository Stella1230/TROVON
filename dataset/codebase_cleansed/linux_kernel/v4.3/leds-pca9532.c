static int pca9532_calcpwm(struct i2c_client *client, int pwm, int blink,\r\nenum led_brightness value)\r\n{\r\nint a = 0, b = 0, i = 0;\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nfor (i = 0; i < data->chip_info->num_leds; i++) {\r\nif (data->leds[i].type == PCA9532_TYPE_LED &&\r\ndata->leds[i].state == PCA9532_PWM0+pwm) {\r\na++;\r\nb += data->leds[i].ldev.brightness;\r\n}\r\n}\r\nif (a == 0) {\r\ndev_err(&client->dev,\r\n"fear of division by zero %d/%d, wanted %d\n",\r\nb, a, value);\r\nreturn -EINVAL;\r\n}\r\nb = b/a;\r\nif (b > 0xFF)\r\nreturn -EINVAL;\r\ndata->pwm[pwm] = b;\r\ndata->psc[pwm] = blink;\r\nreturn 0;\r\n}\r\nstatic int pca9532_setpwm(struct i2c_client *client, int pwm)\r\n{\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nu8 maxleds = data->chip_info->num_leds;\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PWM(maxleds, pwm),\r\ndata->pwm[pwm]);\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PSC(maxleds, pwm),\r\ndata->psc[pwm]);\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic void pca9532_setled(struct pca9532_led *led)\r\n{\r\nstruct i2c_client *client = led->client;\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nu8 maxleds = data->chip_info->num_leds;\r\nchar reg;\r\nmutex_lock(&data->update_lock);\r\nreg = i2c_smbus_read_byte_data(client, LED_REG(maxleds, led->id));\r\nreg = reg & ~(0x3<<LED_NUM(led->id)*2);\r\nreg = reg | (led->state << LED_NUM(led->id)*2);\r\ni2c_smbus_write_byte_data(client, LED_REG(maxleds, led->id), reg);\r\nmutex_unlock(&data->update_lock);\r\n}\r\nstatic void pca9532_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nint err = 0;\r\nstruct pca9532_led *led = ldev_to_led(led_cdev);\r\nif (value == LED_OFF)\r\nled->state = PCA9532_OFF;\r\nelse if (value == LED_FULL)\r\nled->state = PCA9532_ON;\r\nelse {\r\nled->state = PCA9532_PWM0;\r\nerr = pca9532_calcpwm(led->client, 0, 0, value);\r\nif (err)\r\nreturn;\r\n}\r\nschedule_work(&led->work);\r\n}\r\nstatic int pca9532_set_blink(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct pca9532_led *led = ldev_to_led(led_cdev);\r\nstruct i2c_client *client = led->client;\r\nint psc;\r\nint err = 0;\r\nif (*delay_on == 0 && *delay_off == 0) {\r\n*delay_on = 1000;\r\n*delay_off = 1000;\r\n}\r\nif (*delay_on != *delay_off || *delay_on > 1690 || *delay_on < 6)\r\nreturn -EINVAL;\r\npsc = (*delay_on * 152-1)/1000;\r\nerr = pca9532_calcpwm(client, 0, psc, led_cdev->brightness);\r\nif (err)\r\nreturn err;\r\nschedule_work(&led->work);\r\nreturn 0;\r\n}\r\nstatic int pca9532_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct pca9532_data *data = input_get_drvdata(dev);\r\nif (!(type == EV_SND && (code == SND_BELL || code == SND_TONE)))\r\nreturn -1;\r\nif (value > 1 && value < 32767)\r\ndata->pwm[1] = 127;\r\nelse\r\ndata->pwm[1] = 0;\r\nschedule_work(&data->work);\r\nreturn 0;\r\n}\r\nstatic void pca9532_input_work(struct work_struct *work)\r\n{\r\nstruct pca9532_data *data =\r\ncontainer_of(work, struct pca9532_data, work);\r\nu8 maxleds = data->chip_info->num_leds;\r\nmutex_lock(&data->update_lock);\r\ni2c_smbus_write_byte_data(data->client, PCA9532_REG_PWM(maxleds, 1),\r\ndata->pwm[1]);\r\nmutex_unlock(&data->update_lock);\r\n}\r\nstatic void pca9532_led_work(struct work_struct *work)\r\n{\r\nstruct pca9532_led *led;\r\nled = container_of(work, struct pca9532_led, work);\r\nif (led->state == PCA9532_PWM0)\r\npca9532_setpwm(led->client, 0);\r\npca9532_setled(led);\r\n}\r\nstatic int pca9532_gpio_request_pin(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pca9532_data *data = container_of(gc, struct pca9532_data, gpio);\r\nstruct pca9532_led *led = &data->leds[offset];\r\nif (led->type == PCA9532_TYPE_GPIO)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic void pca9532_gpio_set_value(struct gpio_chip *gc, unsigned offset, int val)\r\n{\r\nstruct pca9532_data *data = container_of(gc, struct pca9532_data, gpio);\r\nstruct pca9532_led *led = &data->leds[offset];\r\nif (val)\r\nled->state = PCA9532_ON;\r\nelse\r\nled->state = PCA9532_OFF;\r\npca9532_setled(led);\r\n}\r\nstatic int pca9532_gpio_get_value(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct pca9532_data *data = container_of(gc, struct pca9532_data, gpio);\r\nunsigned char reg;\r\nreg = i2c_smbus_read_byte_data(data->client, PCA9532_REG_INPUT(offset));\r\nreturn !!(reg & (1 << (offset % 8)));\r\n}\r\nstatic int pca9532_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\npca9532_gpio_set_value(gc, offset, 0);\r\nreturn 0;\r\n}\r\nstatic int pca9532_gpio_direction_output(struct gpio_chip *gc, unsigned offset, int val)\r\n{\r\npca9532_gpio_set_value(gc, offset, val);\r\nreturn 0;\r\n}\r\nstatic int pca9532_destroy_devices(struct pca9532_data *data, int n_devs)\r\n{\r\nint i = n_devs;\r\nif (!data)\r\nreturn -EINVAL;\r\nwhile (--i >= 0) {\r\nswitch (data->leds[i].type) {\r\ncase PCA9532_TYPE_NONE:\r\ncase PCA9532_TYPE_GPIO:\r\nbreak;\r\ncase PCA9532_TYPE_LED:\r\nled_classdev_unregister(&data->leds[i].ldev);\r\ncancel_work_sync(&data->leds[i].work);\r\nbreak;\r\ncase PCA9532_TYPE_N2100_BEEP:\r\nif (data->idev != NULL) {\r\ncancel_work_sync(&data->work);\r\ndata->idev = NULL;\r\n}\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_LEDS_PCA9532_GPIO\r\nif (data->gpio.dev)\r\ngpiochip_remove(&data->gpio);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int pca9532_configure(struct i2c_client *client,\r\nstruct pca9532_data *data, struct pca9532_platform_data *pdata)\r\n{\r\nint i, err = 0;\r\nint gpios = 0;\r\nu8 maxleds = data->chip_info->num_leds;\r\nfor (i = 0; i < 2; i++) {\r\ndata->pwm[i] = pdata->pwm[i];\r\ndata->psc[i] = pdata->psc[i];\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PWM(maxleds, i),\r\ndata->pwm[i]);\r\ni2c_smbus_write_byte_data(client, PCA9532_REG_PSC(maxleds, i),\r\ndata->psc[i]);\r\n}\r\nfor (i = 0; i < data->chip_info->num_leds; i++) {\r\nstruct pca9532_led *led = &data->leds[i];\r\nstruct pca9532_led *pled = &pdata->leds[i];\r\nled->client = client;\r\nled->id = i;\r\nled->type = pled->type;\r\nswitch (led->type) {\r\ncase PCA9532_TYPE_NONE:\r\nbreak;\r\ncase PCA9532_TYPE_GPIO:\r\ngpios++;\r\nbreak;\r\ncase PCA9532_TYPE_LED:\r\nled->state = pled->state;\r\nled->name = pled->name;\r\nled->ldev.name = led->name;\r\nled->ldev.brightness = LED_OFF;\r\nled->ldev.brightness_set = pca9532_set_brightness;\r\nled->ldev.blink_set = pca9532_set_blink;\r\nINIT_WORK(&led->work, pca9532_led_work);\r\nerr = led_classdev_register(&client->dev, &led->ldev);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"couldn't register LED %s\n",\r\nled->name);\r\ngoto exit;\r\n}\r\npca9532_setled(led);\r\nbreak;\r\ncase PCA9532_TYPE_N2100_BEEP:\r\nBUG_ON(data->idev);\r\nled->state = PCA9532_PWM1;\r\npca9532_setled(led);\r\ndata->idev = devm_input_allocate_device(&client->dev);\r\nif (data->idev == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->idev->name = pled->name;\r\ndata->idev->phys = "i2c/pca9532";\r\ndata->idev->id.bustype = BUS_HOST;\r\ndata->idev->id.vendor = 0x001f;\r\ndata->idev->id.product = 0x0001;\r\ndata->idev->id.version = 0x0100;\r\ndata->idev->evbit[0] = BIT_MASK(EV_SND);\r\ndata->idev->sndbit[0] = BIT_MASK(SND_BELL) |\r\nBIT_MASK(SND_TONE);\r\ndata->idev->event = pca9532_event;\r\ninput_set_drvdata(data->idev, data);\r\nINIT_WORK(&data->work, pca9532_input_work);\r\nerr = input_register_device(data->idev);\r\nif (err) {\r\ncancel_work_sync(&data->work);\r\ndata->idev = NULL;\r\ngoto exit;\r\n}\r\nbreak;\r\n}\r\n}\r\n#ifdef CONFIG_LEDS_PCA9532_GPIO\r\nif (gpios) {\r\ndata->gpio.label = "gpio-pca9532";\r\ndata->gpio.direction_input = pca9532_gpio_direction_input;\r\ndata->gpio.direction_output = pca9532_gpio_direction_output;\r\ndata->gpio.set = pca9532_gpio_set_value;\r\ndata->gpio.get = pca9532_gpio_get_value;\r\ndata->gpio.request = pca9532_gpio_request_pin;\r\ndata->gpio.can_sleep = 1;\r\ndata->gpio.base = pdata->gpio_base;\r\ndata->gpio.ngpio = data->chip_info->num_leds;\r\ndata->gpio.dev = &client->dev;\r\ndata->gpio.owner = THIS_MODULE;\r\nerr = gpiochip_add(&data->gpio);\r\nif (err) {\r\ndata->gpio.dev = NULL;\r\ndev_warn(&client->dev, "could not add gpiochip\n");\r\n} else {\r\ndev_info(&client->dev, "gpios %i...%i\n",\r\ndata->gpio.base, data->gpio.base +\r\ndata->gpio.ngpio - 1);\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\nexit:\r\npca9532_destroy_devices(data, i);\r\nreturn err;\r\n}\r\nstatic int pca9532_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nstruct pca9532_platform_data *pca9532_pdata =\r\ndev_get_platdata(&client->dev);\r\nif (!pca9532_pdata)\r\nreturn -EIO;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->chip_info = &pca9532_chip_info_tbl[id->driver_data];\r\ndev_info(&client->dev, "setting platform data\n");\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nreturn pca9532_configure(client, data, pca9532_pdata);\r\n}\r\nstatic int pca9532_remove(struct i2c_client *client)\r\n{\r\nstruct pca9532_data *data = i2c_get_clientdata(client);\r\nint err;\r\nerr = pca9532_destroy_devices(data, data->chip_info->num_leds);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}
