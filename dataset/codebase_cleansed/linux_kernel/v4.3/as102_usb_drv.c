static int as102_usb_xfer_cmd(struct as10x_bus_adapter_t *bus_adap,\r\nunsigned char *send_buf, int send_buf_len,\r\nunsigned char *recv_buf, int recv_buf_len)\r\n{\r\nint ret = 0;\r\nif (send_buf != NULL) {\r\nret = usb_control_msg(bus_adap->usb_dev,\r\nusb_sndctrlpipe(bus_adap->usb_dev, 0),\r\nAS102_USB_DEVICE_TX_CTRL_CMD,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE,\r\nbus_adap->cmd_xid,\r\n0,\r\nsend_buf, send_buf_len,\r\nUSB_CTRL_SET_TIMEOUT );\r\nif (ret < 0) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"usb_control_msg(send) failed, err %i\n", ret);\r\nreturn ret;\r\n}\r\nif (ret != send_buf_len) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"only wrote %d of %d bytes\n", ret, send_buf_len);\r\nreturn -1;\r\n}\r\n}\r\nif (recv_buf != NULL) {\r\n#ifdef TRACE\r\ndev_dbg(bus_adap->usb_dev->dev,\r\n"want to read: %d bytes\n", recv_buf_len);\r\n#endif\r\nret = usb_control_msg(bus_adap->usb_dev,\r\nusb_rcvctrlpipe(bus_adap->usb_dev, 0),\r\nAS102_USB_DEVICE_RX_CTRL_CMD,\r\nUSB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE,\r\nbus_adap->cmd_xid,\r\n0,\r\nrecv_buf, recv_buf_len,\r\nUSB_CTRL_GET_TIMEOUT );\r\nif (ret < 0) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"usb_control_msg(recv) failed, err %i\n", ret);\r\nreturn ret;\r\n}\r\n#ifdef TRACE\r\ndev_dbg(bus_adap->usb_dev->dev,\r\n"read %d bytes\n", recv_buf_len);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic int as102_send_ep1(struct as10x_bus_adapter_t *bus_adap,\r\nunsigned char *send_buf,\r\nint send_buf_len,\r\nint swap32)\r\n{\r\nint ret, actual_len;\r\nret = usb_bulk_msg(bus_adap->usb_dev,\r\nusb_sndbulkpipe(bus_adap->usb_dev, 1),\r\nsend_buf, send_buf_len, &actual_len, 200);\r\nif (ret) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"usb_bulk_msg(send) failed, err %i\n", ret);\r\nreturn ret;\r\n}\r\nif (actual_len != send_buf_len) {\r\ndev_dbg(&bus_adap->usb_dev->dev, "only wrote %d of %d bytes\n",\r\nactual_len, send_buf_len);\r\nreturn -1;\r\n}\r\nreturn actual_len;\r\n}\r\nstatic int as102_read_ep2(struct as10x_bus_adapter_t *bus_adap,\r\nunsigned char *recv_buf, int recv_buf_len)\r\n{\r\nint ret, actual_len;\r\nif (recv_buf == NULL)\r\nreturn -EINVAL;\r\nret = usb_bulk_msg(bus_adap->usb_dev,\r\nusb_rcvbulkpipe(bus_adap->usb_dev, 2),\r\nrecv_buf, recv_buf_len, &actual_len, 200);\r\nif (ret) {\r\ndev_dbg(&bus_adap->usb_dev->dev,\r\n"usb_bulk_msg(recv) failed, err %i\n", ret);\r\nreturn ret;\r\n}\r\nif (actual_len != recv_buf_len) {\r\ndev_dbg(&bus_adap->usb_dev->dev, "only read %d of %d bytes\n",\r\nactual_len, recv_buf_len);\r\nreturn -1;\r\n}\r\nreturn actual_len;\r\n}\r\nstatic int as102_submit_urb_stream(struct as102_dev_t *dev, struct urb *urb)\r\n{\r\nint err;\r\nusb_fill_bulk_urb(urb,\r\ndev->bus_adap.usb_dev,\r\nusb_rcvbulkpipe(dev->bus_adap.usb_dev, 0x2),\r\nurb->transfer_buffer,\r\nAS102_USB_BUF_SIZE,\r\nas102_urb_stream_irq,\r\ndev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err)\r\ndev_dbg(&urb->dev->dev,\r\n"%s: usb_submit_urb failed\n", __func__);\r\nreturn err;\r\n}\r\nvoid as102_urb_stream_irq(struct urb *urb)\r\n{\r\nstruct as102_dev_t *as102_dev = urb->context;\r\nif (urb->actual_length > 0) {\r\ndvb_dmx_swfilter(&as102_dev->dvb_dmx,\r\nurb->transfer_buffer,\r\nurb->actual_length);\r\n} else {\r\nif (urb->actual_length == 0)\r\nmemset(urb->transfer_buffer, 0, AS102_USB_BUF_SIZE);\r\n}\r\nif (as102_dev->streaming)\r\nas102_submit_urb_stream(as102_dev, urb);\r\n}\r\nstatic void as102_free_usb_stream_buffer(struct as102_dev_t *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_STREAM_URB; i++)\r\nusb_free_urb(dev->stream_urb[i]);\r\nusb_free_coherent(dev->bus_adap.usb_dev,\r\nMAX_STREAM_URB * AS102_USB_BUF_SIZE,\r\ndev->stream,\r\ndev->dma_addr);\r\n}\r\nstatic int as102_alloc_usb_stream_buffer(struct as102_dev_t *dev)\r\n{\r\nint i;\r\ndev->stream = usb_alloc_coherent(dev->bus_adap.usb_dev,\r\nMAX_STREAM_URB * AS102_USB_BUF_SIZE,\r\nGFP_KERNEL,\r\n&dev->dma_addr);\r\nif (!dev->stream) {\r\ndev_dbg(&dev->bus_adap.usb_dev->dev,\r\n"%s: usb_buffer_alloc failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev->stream, 0, MAX_STREAM_URB * AS102_USB_BUF_SIZE);\r\nfor (i = 0; i < MAX_STREAM_URB; i++) {\r\nstruct urb *urb;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (urb == NULL) {\r\ndev_dbg(&dev->bus_adap.usb_dev->dev,\r\n"%s: usb_alloc_urb failed\n", __func__);\r\nas102_free_usb_stream_buffer(dev);\r\nreturn -ENOMEM;\r\n}\r\nurb->transfer_buffer = dev->stream + (i * AS102_USB_BUF_SIZE);\r\nurb->transfer_dma = dev->dma_addr + (i * AS102_USB_BUF_SIZE);\r\nurb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_buffer_length = AS102_USB_BUF_SIZE;\r\ndev->stream_urb[i] = urb;\r\n}\r\nreturn 0;\r\n}\r\nstatic void as102_usb_stop_stream(struct as102_dev_t *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_STREAM_URB; i++)\r\nusb_kill_urb(dev->stream_urb[i]);\r\n}\r\nstatic int as102_usb_start_stream(struct as102_dev_t *dev)\r\n{\r\nint i, ret = 0;\r\nfor (i = 0; i < MAX_STREAM_URB; i++) {\r\nret = as102_submit_urb_stream(dev, dev->stream_urb[i]);\r\nif (ret) {\r\nas102_usb_stop_stream(dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void as102_usb_release(struct kref *kref)\r\n{\r\nstruct as102_dev_t *as102_dev;\r\nas102_dev = container_of(kref, struct as102_dev_t, kref);\r\nif (as102_dev != NULL) {\r\nusb_put_dev(as102_dev->bus_adap.usb_dev);\r\nkfree(as102_dev);\r\n}\r\n}\r\nstatic void as102_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct as102_dev_t *as102_dev;\r\nas102_dev = usb_get_intfdata(intf);\r\nas102_dvb_unregister(as102_dev);\r\nas102_free_usb_stream_buffer(as102_dev);\r\nusb_set_intfdata(intf, NULL);\r\nusb_deregister_dev(intf, &as102_usb_class_driver);\r\nkref_put(&as102_dev->kref, as102_usb_release);\r\npr_info("%s: device has been disconnected\n", DRIVER_NAME);\r\n}\r\nstatic int as102_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret;\r\nstruct as102_dev_t *as102_dev;\r\nint i;\r\nif (ARRAY_SIZE(as102_usb_id_table) !=\r\n(sizeof(as102_device_names) / sizeof(const char *))) {\r\npr_err("Device names table invalid size");\r\nreturn -EINVAL;\r\n}\r\nas102_dev = kzalloc(sizeof(struct as102_dev_t), GFP_KERNEL);\r\nif (as102_dev == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(as102_usb_id_table); i++) {\r\nif (id == &as102_usb_id_table[i]) {\r\nas102_dev->name = as102_device_names[i];\r\nas102_dev->elna_cfg = as102_elna_cfg[i];\r\n}\r\n}\r\nif (as102_dev->name == NULL)\r\nas102_dev->name = "Unknown AS102 device";\r\nas102_dev->bus_adap.ops = &as102_priv_ops;\r\nas102_dev->bus_adap.cmd = &as102_dev->bus_adap.token.usb.c;\r\nas102_dev->bus_adap.rsp = &as102_dev->bus_adap.token.usb.r;\r\nkref_init(&as102_dev->kref);\r\nusb_set_intfdata(intf, (void *) as102_dev);\r\nas102_dev->bus_adap.usb_dev = usb_get_dev(interface_to_usbdev(intf));\r\nret = usb_register_dev(intf, &as102_usb_class_driver);\r\nif (ret < 0) {\r\ndev_err(&intf->dev,\r\n"%s: usb_register_dev() failed (errno = %d)\n",\r\n__func__, ret);\r\ngoto failed;\r\n}\r\npr_info("%s: device has been detected\n", DRIVER_NAME);\r\nret = as102_alloc_usb_stream_buffer(as102_dev);\r\nif (ret != 0)\r\ngoto failed_stream;\r\nret = as102_dvb_register(as102_dev);\r\nif (ret != 0)\r\ngoto failed_dvb;\r\nreturn ret;\r\nfailed_dvb:\r\nas102_free_usb_stream_buffer(as102_dev);\r\nfailed_stream:\r\nusb_deregister_dev(intf, &as102_usb_class_driver);\r\nfailed:\r\nusb_put_dev(as102_dev->bus_adap.usb_dev);\r\nusb_set_intfdata(intf, NULL);\r\nkfree(as102_dev);\r\nreturn ret;\r\n}\r\nstatic int as102_open(struct inode *inode, struct file *file)\r\n{\r\nint ret = 0, minor = 0;\r\nstruct usb_interface *intf = NULL;\r\nstruct as102_dev_t *dev = NULL;\r\nminor = iminor(inode);\r\nintf = usb_find_interface(&as102_usb_driver, minor);\r\nif (intf == NULL) {\r\npr_err("%s: can't find device for minor %d\n",\r\n__func__, minor);\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\ndev = usb_get_intfdata(intf);\r\nif (dev == NULL) {\r\nret = -EFAULT;\r\ngoto exit;\r\n}\r\nfile->private_data = dev;\r\nkref_get(&dev->kref);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int as102_release(struct inode *inode, struct file *file)\r\n{\r\nstruct as102_dev_t *dev = NULL;\r\ndev = file->private_data;\r\nif (dev != NULL) {\r\nkref_put(&dev->kref, as102_usb_release);\r\n}\r\nreturn 0;\r\n}
