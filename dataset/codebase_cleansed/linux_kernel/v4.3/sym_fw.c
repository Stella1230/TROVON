static void\r\nsym_fw1_patch(struct Scsi_Host *shost)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nstruct sym_fw1a_scr *scripta0;\r\nstruct sym_fw1b_scr *scriptb0;\r\nscripta0 = (struct sym_fw1a_scr *) np->scripta0;\r\nscriptb0 = (struct sym_fw1b_scr *) np->scriptb0;\r\nif (!(np->features & FE_LED0)) {\r\nscripta0->idle[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->reselected[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->start[0] = cpu_to_scr(SCR_NO_OP);\r\n}\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\nif (!SYM_CONF_SET_IARB_ON_ARB_LOST)\r\nscripta0->ungetjob[0] = cpu_to_scr(SCR_NO_OP);\r\n#endif\r\nscriptb0->startpos[0] = cpu_to_scr(np->squeue_ba);\r\nscriptb0->done_pos[0] = cpu_to_scr(np->dqueue_ba);\r\nscriptb0->targtbl[0] = cpu_to_scr(np->targtbl_ba);\r\n}\r\nstatic void\r\nsym_fw2_patch(struct Scsi_Host *shost)\r\n{\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nstruct sym_hcb *np = sym_data->ncb;\r\nstruct sym_fw2a_scr *scripta0;\r\nstruct sym_fw2b_scr *scriptb0;\r\nscripta0 = (struct sym_fw2a_scr *) np->scripta0;\r\nscriptb0 = (struct sym_fw2b_scr *) np->scriptb0;\r\nif (!(np->features & FE_LED0)) {\r\nscripta0->idle[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->reselected[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->start[0] = cpu_to_scr(SCR_NO_OP);\r\n}\r\n#if SYM_CONF_DMA_ADDRESSING_MODE == 2\r\nif (!use_dac(np)) {\r\nscripta0->is_dmap_dirty[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->is_dmap_dirty[1] = 0;\r\nscripta0->is_dmap_dirty[2] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->is_dmap_dirty[3] = 0;\r\n}\r\n#endif\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\nif (!SYM_CONF_SET_IARB_ON_ARB_LOST)\r\nscripta0->ungetjob[0] = cpu_to_scr(SCR_NO_OP);\r\n#endif\r\nscriptb0->startpos[0] = cpu_to_scr(np->squeue_ba);\r\nscriptb0->done_pos[0] = cpu_to_scr(np->dqueue_ba);\r\nscriptb0->targtbl[0] = cpu_to_scr(np->targtbl_ba);\r\nif (!(np->features & FE_C10)) {\r\nscripta0->resel_scntl4[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->resel_scntl4[1] = cpu_to_scr(0);\r\n}\r\nif (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_66 &&\r\npdev->revision < 0x1 &&\r\nnp->pciclk_khz < 60000)) {\r\nscripta0->datao_phase[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->datao_phase[1] = cpu_to_scr(0);\r\n}\r\nif (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 )) {\r\nscripta0->sel_done[0] = cpu_to_scr(SCR_NO_OP);\r\nscripta0->sel_done[1] = cpu_to_scr(0);\r\n}\r\nscriptb0->pm0_data_addr[0] =\r\ncpu_to_scr(np->scripta_ba +\r\noffsetof(struct sym_fw2a_scr, pm0_data));\r\nscriptb0->pm1_data_addr[0] =\r\ncpu_to_scr(np->scripta_ba +\r\noffsetof(struct sym_fw2a_scr, pm1_data));\r\n}\r\nstatic void\r\nsym_fw_fill_data (u32 *in, u32 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < SYM_CONF_MAX_SG; i++) {\r\n*in++ = SCR_CHMOV_TBL ^ SCR_DATA_IN;\r\n*in++ = offsetof (struct sym_dsb, data[i]);\r\n*out++ = SCR_CHMOV_TBL ^ SCR_DATA_OUT;\r\n*out++ = offsetof (struct sym_dsb, data[i]);\r\n}\r\n}\r\nstatic void\r\nsym_fw_setup_bus_addresses(struct sym_hcb *np, struct sym_fw *fw)\r\n{\r\nu32 *pa;\r\nu_short *po;\r\nint i;\r\npo = (u_short *) fw->a_ofs;\r\npa = (u32 *) &np->fwa_bas;\r\nfor (i = 0 ; i < sizeof(np->fwa_bas)/sizeof(u32) ; i++)\r\npa[i] = np->scripta_ba + po[i];\r\npo = (u_short *) fw->b_ofs;\r\npa = (u32 *) &np->fwb_bas;\r\nfor (i = 0 ; i < sizeof(np->fwb_bas)/sizeof(u32) ; i++)\r\npa[i] = np->scriptb_ba + po[i];\r\npo = (u_short *) fw->z_ofs;\r\npa = (u32 *) &np->fwz_bas;\r\nfor (i = 0 ; i < sizeof(np->fwz_bas)/sizeof(u32) ; i++)\r\npa[i] = np->scriptz_ba + po[i];\r\n}\r\nstatic void\r\nsym_fw1_setup(struct sym_hcb *np, struct sym_fw *fw)\r\n{\r\nstruct sym_fw1a_scr *scripta0;\r\nstruct sym_fw1b_scr *scriptb0;\r\nscripta0 = (struct sym_fw1a_scr *) np->scripta0;\r\nscriptb0 = (struct sym_fw1b_scr *) np->scriptb0;\r\nsym_fw_fill_data(scripta0->data_in, scripta0->data_out);\r\nsym_fw_setup_bus_addresses(np, fw);\r\n}\r\nstatic void\r\nsym_fw2_setup(struct sym_hcb *np, struct sym_fw *fw)\r\n{\r\nstruct sym_fw2a_scr *scripta0;\r\nstruct sym_fw2b_scr *scriptb0;\r\nscripta0 = (struct sym_fw2a_scr *) np->scripta0;\r\nscriptb0 = (struct sym_fw2b_scr *) np->scriptb0;\r\nsym_fw_fill_data(scripta0->data_in, scripta0->data_out);\r\nsym_fw_setup_bus_addresses(np, fw);\r\n}\r\nstruct sym_fw *\r\nsym_find_firmware(struct sym_chip *chip)\r\n{\r\nif (chip->features & FE_LDSTR)\r\nreturn &sym_fw2;\r\n#if SYM_CONF_GENERIC_SUPPORT\r\nelse if (!(chip->features & (FE_PFEN|FE_NOPM|FE_DAC)))\r\nreturn &sym_fw1;\r\n#endif\r\nelse\r\nreturn NULL;\r\n}\r\nvoid sym_fw_bind_script(struct sym_hcb *np, u32 *start, int len)\r\n{\r\nu32 opcode, new, old, tmp1, tmp2;\r\nu32 *end, *cur;\r\nint relocs;\r\ncur = start;\r\nend = start + len/4;\r\nwhile (cur < end) {\r\nopcode = *cur;\r\nif (opcode == 0) {\r\nprintf ("%s: ERROR0 IN SCRIPT at %d.\n",\r\nsym_name(np), (int) (cur-start));\r\n++cur;\r\ncontinue;\r\n};\r\nif (opcode == SCR_DATA_ZERO) {\r\n*cur++ = 0;\r\ncontinue;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_SCRIPT)\r\nprintf ("%d: <%x>\n", (int) (cur-start),\r\n(unsigned)opcode);\r\nswitch (opcode >> 28) {\r\ncase 0xf:\r\nrelocs = 0;\r\nbreak;\r\ncase 0xe:\r\nrelocs = 1;\r\nbreak;\r\ncase 0xc:\r\nrelocs = 2;\r\ntmp1 = cur[1];\r\ntmp2 = cur[2];\r\nif ((tmp1 ^ tmp2) & 3) {\r\nprintf ("%s: ERROR1 IN SCRIPT at %d.\n",\r\nsym_name(np), (int) (cur-start));\r\n}\r\nif ((opcode & SCR_NO_FLUSH) &&\r\n!(np->features & FE_PFEN)) {\r\nopcode = (opcode & ~SCR_NO_FLUSH);\r\n}\r\nbreak;\r\ncase 0x0:\r\nif (!(np->features & FE_WIDE))\r\nopcode = (opcode | OPC_MOVE);\r\nrelocs = 1;\r\nbreak;\r\ncase 0x1:\r\nif (!(np->features & FE_WIDE))\r\nopcode = (opcode | OPC_MOVE);\r\nrelocs = 0;\r\nbreak;\r\n#ifdef SYM_CONF_TARGET_ROLE_SUPPORT\r\ncase 0x2:\r\nopcode &= ~0x20000000;\r\nif (!(np->features & FE_WIDE))\r\nopcode = (opcode & ~OPC_TCHMOVE);\r\nrelocs = 1;\r\nbreak;\r\ncase 0x3:\r\nopcode &= ~0x20000000;\r\nif (!(np->features & FE_WIDE))\r\nopcode = (opcode & ~OPC_TCHMOVE);\r\nrelocs = 0;\r\nbreak;\r\n#endif\r\ncase 0x8:\r\nif (opcode & 0x00800000)\r\nrelocs = 0;\r\nelse if ((opcode & 0xf8400000) == 0x80400000)\r\nrelocs = 2;\r\nelse\r\nrelocs = 1;\r\nbreak;\r\ncase 0x4:\r\ncase 0x5:\r\ncase 0x6:\r\ncase 0x7:\r\nrelocs = 1;\r\nbreak;\r\ndefault:\r\nrelocs = 0;\r\nbreak;\r\n};\r\n*cur++ = cpu_to_scr(opcode);\r\nif (!relocs) {\r\n*cur = cpu_to_scr(*cur);\r\n++cur;\r\ncontinue;\r\n}\r\nwhile (relocs--) {\r\nold = *cur;\r\nswitch (old & RELOC_MASK) {\r\ncase RELOC_REGISTER:\r\nnew = (old & ~RELOC_MASK) + np->mmio_ba;\r\nbreak;\r\ncase RELOC_LABEL_A:\r\nnew = (old & ~RELOC_MASK) + np->scripta_ba;\r\nbreak;\r\ncase RELOC_LABEL_B:\r\nnew = (old & ~RELOC_MASK) + np->scriptb_ba;\r\nbreak;\r\ncase RELOC_SOFTC:\r\nnew = (old & ~RELOC_MASK) + np->hcb_ba;\r\nbreak;\r\ncase 0:\r\nif (old == 0) {\r\nnew = old;\r\nbreak;\r\n}\r\ndefault:\r\nnew = 0;\r\npanic("sym_fw_bind_script: "\r\n"weird relocation %x\n", old);\r\nbreak;\r\n}\r\n*cur++ = cpu_to_scr(new);\r\n}\r\n};\r\n}
