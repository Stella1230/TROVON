static inline bool kvaser_is_leaf(const struct usb_device_id *id)\r\n{\r\nreturn id->idProduct >= USB_LEAF_DEVEL_PRODUCT_ID &&\r\nid->idProduct <= USB_MINI_PCIE_HS_PRODUCT_ID;\r\n}\r\nstatic inline bool kvaser_is_usbcan(const struct usb_device_id *id)\r\n{\r\nreturn id->idProduct >= USB_USBCAN_REVB_PRODUCT_ID &&\r\nid->idProduct <= USB_MEMORATOR_PRODUCT_ID;\r\n}\r\nstatic inline int kvaser_usb_send_msg(const struct kvaser_usb *dev,\r\nstruct kvaser_msg *msg)\r\n{\r\nint actual_len;\r\nreturn usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out->bEndpointAddress),\r\nmsg, msg->len, &actual_len,\r\nUSB_SEND_TIMEOUT);\r\n}\r\nstatic int kvaser_usb_wait_msg(const struct kvaser_usb *dev, u8 id,\r\nstruct kvaser_msg *msg)\r\n{\r\nstruct kvaser_msg *tmp;\r\nvoid *buf;\r\nint actual_len;\r\nint err;\r\nint pos;\r\nunsigned long to = jiffies + msecs_to_jiffies(USB_RECV_TIMEOUT);\r\nbuf = kzalloc(RX_BUFFER_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ndo {\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in->bEndpointAddress),\r\nbuf, RX_BUFFER_SIZE, &actual_len,\r\nUSB_RECV_TIMEOUT);\r\nif (err < 0)\r\ngoto end;\r\npos = 0;\r\nwhile (pos <= actual_len - MSG_HEADER_LEN) {\r\ntmp = buf + pos;\r\nif (tmp->len == 0) {\r\npos = round_up(pos, le16_to_cpu(dev->bulk_in->\r\nwMaxPacketSize));\r\ncontinue;\r\n}\r\nif (pos + tmp->len > actual_len) {\r\ndev_err(dev->udev->dev.parent,\r\n"Format error\n");\r\nbreak;\r\n}\r\nif (tmp->id == id) {\r\nmemcpy(msg, tmp, tmp->len);\r\ngoto end;\r\n}\r\npos += tmp->len;\r\n}\r\n} while (time_before(jiffies, to));\r\nerr = -EINVAL;\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int kvaser_usb_send_simple_msg(const struct kvaser_usb *dev,\r\nu8 msg_id, int channel)\r\n{\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = msg_id;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_simple);\r\nmsg->u.simple.channel = channel;\r\nmsg->u.simple.tid = 0xff;\r\nrc = kvaser_usb_send_msg(dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_get_software_info(struct kvaser_usb *dev)\r\n{\r\nstruct kvaser_msg msg;\r\nint err;\r\nerr = kvaser_usb_send_simple_msg(dev, CMD_GET_SOFTWARE_INFO, 0);\r\nif (err)\r\nreturn err;\r\nerr = kvaser_usb_wait_msg(dev, CMD_GET_SOFTWARE_INFO_REPLY, &msg);\r\nif (err)\r\nreturn err;\r\nswitch (dev->family) {\r\ncase KVASER_LEAF:\r\ndev->fw_version = le32_to_cpu(msg.u.leaf.softinfo.fw_version);\r\ndev->max_tx_urbs =\r\nle16_to_cpu(msg.u.leaf.softinfo.max_outstanding_tx);\r\nbreak;\r\ncase KVASER_USBCAN:\r\ndev->fw_version = le32_to_cpu(msg.u.usbcan.softinfo.fw_version);\r\ndev->max_tx_urbs =\r\nle16_to_cpu(msg.u.usbcan.softinfo.max_outstanding_tx);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_get_card_info(struct kvaser_usb *dev)\r\n{\r\nstruct kvaser_msg msg;\r\nint err;\r\nerr = kvaser_usb_send_simple_msg(dev, CMD_GET_CARD_INFO, 0);\r\nif (err)\r\nreturn err;\r\nerr = kvaser_usb_wait_msg(dev, CMD_GET_CARD_INFO_REPLY, &msg);\r\nif (err)\r\nreturn err;\r\ndev->nchannels = msg.u.cardinfo.nchannels;\r\nif ((dev->nchannels > MAX_NET_DEVICES) ||\r\n(dev->family == KVASER_USBCAN &&\r\ndev->nchannels > MAX_USBCAN_NET_DEVICES))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_tx_acknowledge(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct net_device_stats *stats;\r\nstruct kvaser_usb_tx_urb_context *context;\r\nstruct kvaser_usb_net_priv *priv;\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nunsigned long flags;\r\nu8 channel, tid;\r\nchannel = msg->u.tx_acknowledge_header.channel;\r\ntid = msg->u.tx_acknowledge_header.tid;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nif (!netif_device_present(priv->netdev))\r\nreturn;\r\nstats = &priv->netdev->stats;\r\ncontext = &priv->tx_contexts[tid % dev->max_tx_urbs];\r\nif (priv->can.restart_ms &&\r\n(priv->can.state >= CAN_STATE_BUS_OFF)) {\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_RESTARTED;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n} else {\r\nnetdev_err(priv->netdev,\r\n"No memory left for err_skb\n");\r\n}\r\npriv->can.can_stats.restarts++;\r\nnetif_carrier_on(priv->netdev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\nstats->tx_packets++;\r\nstats->tx_bytes += context->dlc;\r\nspin_lock_irqsave(&priv->tx_contexts_lock, flags);\r\ncan_get_echo_skb(priv->netdev, context->echo_index);\r\ncontext->echo_index = dev->max_tx_urbs;\r\n--priv->active_tx_contexts;\r\nnetif_wake_queue(priv->netdev);\r\nspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\r\n}\r\nstatic void kvaser_usb_simple_msg_callback(struct urb *urb)\r\n{\r\nstruct net_device *netdev = urb->context;\r\nkfree(urb->transfer_buffer);\r\nif (urb->status)\r\nnetdev_warn(netdev, "urb status received: %d\n",\r\nurb->status);\r\n}\r\nstatic int kvaser_usb_simple_msg_async(struct kvaser_usb_net_priv *priv,\r\nu8 msg_id)\r\n{\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct net_device *netdev = priv->netdev;\r\nstruct kvaser_msg *msg;\r\nstruct urb *urb;\r\nvoid *buf;\r\nint err;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URBs\n");\r\nreturn -ENOMEM;\r\n}\r\nbuf = kmalloc(sizeof(struct kvaser_msg), GFP_ATOMIC);\r\nif (!buf) {\r\nusb_free_urb(urb);\r\nreturn -ENOMEM;\r\n}\r\nmsg = (struct kvaser_msg *)buf;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_simple);\r\nmsg->id = msg_id;\r\nmsg->u.simple.channel = priv->channel;\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out->bEndpointAddress),\r\nbuf, msg->len,\r\nkvaser_usb_simple_msg_callback, netdev);\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nnetdev_err(netdev, "Error transmitting URB\n");\r\nusb_unanchor_urb(urb);\r\nusb_free_urb(urb);\r\nreturn err;\r\n}\r\nusb_free_urb(urb);\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_rx_error_update_can_state(struct kvaser_usb_net_priv *priv,\r\nconst struct kvaser_usb_error_summary *es,\r\nstruct can_frame *cf)\r\n{\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nenum can_state cur_state, new_state, tx_state, rx_state;\r\nnetdev_dbg(priv->netdev, "Error status: 0x%02x\n", es->status);\r\nnew_state = cur_state = priv->can.state;\r\nif (es->status & (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET))\r\nnew_state = CAN_STATE_BUS_OFF;\r\nelse if (es->status & M16C_STATE_BUS_PASSIVE)\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\nelse if (es->status & M16C_STATE_BUS_ERROR) {\r\nif (cur_state < CAN_STATE_BUS_OFF) {\r\nif ((es->txerr >= 128) || (es->rxerr >= 128))\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\nelse if ((es->txerr >= 96) || (es->rxerr >= 96))\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\nelse if (cur_state > CAN_STATE_ERROR_ACTIVE)\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\n}\r\n}\r\nif (!es->status)\r\nnew_state = CAN_STATE_ERROR_ACTIVE;\r\nif (new_state != cur_state) {\r\ntx_state = (es->txerr >= es->rxerr) ? new_state : 0;\r\nrx_state = (es->txerr <= es->rxerr) ? new_state : 0;\r\ncan_change_state(priv->netdev, cf, tx_state, rx_state);\r\n}\r\nif (priv->can.restart_ms &&\r\n(cur_state >= CAN_STATE_BUS_OFF) &&\r\n(new_state < CAN_STATE_BUS_OFF)) {\r\npriv->can.can_stats.restarts++;\r\n}\r\nswitch (dev->family) {\r\ncase KVASER_LEAF:\r\nif (es->leaf.error_factor) {\r\npriv->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\n}\r\nbreak;\r\ncase KVASER_USBCAN:\r\nif (es->usbcan.error_state & USBCAN_ERROR_STATE_TX_ERROR)\r\nstats->tx_errors++;\r\nif (es->usbcan.error_state & USBCAN_ERROR_STATE_RX_ERROR)\r\nstats->rx_errors++;\r\nif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR) {\r\npriv->can.can_stats.bus_error++;\r\n}\r\nbreak;\r\n}\r\npriv->bec.txerr = es->txerr;\r\npriv->bec.rxerr = es->rxerr;\r\n}\r\nstatic void kvaser_usb_rx_error(const struct kvaser_usb *dev,\r\nconst struct kvaser_usb_error_summary *es)\r\n{\r\nstruct can_frame *cf, tmp_cf = { .can_id = CAN_ERR_FLAG, .can_dlc = CAN_ERR_DLC };\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats;\r\nstruct kvaser_usb_net_priv *priv;\r\nenum can_state old_state, new_state;\r\nif (es->channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", es->channel);\r\nreturn;\r\n}\r\npriv = dev->nets[es->channel];\r\nstats = &priv->netdev->stats;\r\nold_state = priv->can.state;\r\nkvaser_usb_rx_error_update_can_state(priv, es, &tmp_cf);\r\nnew_state = priv->can.state;\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\nmemcpy(cf, &tmp_cf, sizeof(*cf));\r\nif (new_state != old_state) {\r\nif (es->status &\r\n(M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\r\nif (!priv->can.restart_ms)\r\nkvaser_usb_simple_msg_async(priv, CMD_STOP_CHIP);\r\nnetif_carrier_off(priv->netdev);\r\n}\r\nif (priv->can.restart_ms &&\r\n(old_state >= CAN_STATE_BUS_OFF) &&\r\n(new_state < CAN_STATE_BUS_OFF)) {\r\ncf->can_id |= CAN_ERR_RESTARTED;\r\nnetif_carrier_on(priv->netdev);\r\n}\r\n}\r\nswitch (dev->family) {\r\ncase KVASER_LEAF:\r\nif (es->leaf.error_factor) {\r\ncf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\r\nif (es->leaf.error_factor & M16C_EF_ACKE)\r\ncf->data[3] |= (CAN_ERR_PROT_LOC_ACK);\r\nif (es->leaf.error_factor & M16C_EF_CRCE)\r\ncf->data[3] |= (CAN_ERR_PROT_LOC_CRC_SEQ |\r\nCAN_ERR_PROT_LOC_CRC_DEL);\r\nif (es->leaf.error_factor & M16C_EF_FORME)\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nif (es->leaf.error_factor & M16C_EF_STFE)\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nif (es->leaf.error_factor & M16C_EF_BITE0)\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\nif (es->leaf.error_factor & M16C_EF_BITE1)\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\nif (es->leaf.error_factor & M16C_EF_TRE)\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\n}\r\nbreak;\r\ncase KVASER_USBCAN:\r\nif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR) {\r\ncf->can_id |= CAN_ERR_BUSERROR;\r\n}\r\nbreak;\r\n}\r\ncf->data[6] = es->txerr;\r\ncf->data[7] = es->rxerr;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic void kvaser_usbcan_conditionally_rx_error(const struct kvaser_usb *dev,\r\nstruct kvaser_usb_error_summary *es)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nint channel;\r\nbool report_error;\r\nchannel = es->channel;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nreport_error = false;\r\nif (es->txerr != priv->bec.txerr) {\r\nes->usbcan.error_state |= USBCAN_ERROR_STATE_TX_ERROR;\r\nreport_error = true;\r\n}\r\nif (es->rxerr != priv->bec.rxerr) {\r\nes->usbcan.error_state |= USBCAN_ERROR_STATE_RX_ERROR;\r\nreport_error = true;\r\n}\r\nif ((es->status & M16C_STATE_BUS_ERROR) &&\r\n!(es->usbcan.other_ch_status & M16C_STATE_BUS_ERROR)) {\r\nes->usbcan.error_state |= USBCAN_ERROR_STATE_BUSERROR;\r\nreport_error = true;\r\n}\r\nif (report_error)\r\nkvaser_usb_rx_error(dev, es);\r\n}\r\nstatic void kvaser_usbcan_rx_error(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_error_summary es = { };\r\nswitch (msg->id) {\r\ncase CMD_CHIP_STATE_EVENT:\r\nes.channel = msg->u.usbcan.chip_state_event.channel;\r\nes.status = msg->u.usbcan.chip_state_event.status;\r\nes.txerr = msg->u.usbcan.chip_state_event.tx_errors_count;\r\nes.rxerr = msg->u.usbcan.chip_state_event.rx_errors_count;\r\nkvaser_usbcan_conditionally_rx_error(dev, &es);\r\nbreak;\r\ncase CMD_CAN_ERROR_EVENT:\r\nes.channel = 0;\r\nes.status = msg->u.usbcan.error_event.status_ch0;\r\nes.txerr = msg->u.usbcan.error_event.tx_errors_count_ch0;\r\nes.rxerr = msg->u.usbcan.error_event.rx_errors_count_ch0;\r\nes.usbcan.other_ch_status =\r\nmsg->u.usbcan.error_event.status_ch1;\r\nkvaser_usbcan_conditionally_rx_error(dev, &es);\r\nif (dev->nchannels == MAX_USBCAN_NET_DEVICES) {\r\nes.channel = 1;\r\nes.status = msg->u.usbcan.error_event.status_ch1;\r\nes.txerr = msg->u.usbcan.error_event.tx_errors_count_ch1;\r\nes.rxerr = msg->u.usbcan.error_event.rx_errors_count_ch1;\r\nes.usbcan.other_ch_status =\r\nmsg->u.usbcan.error_event.status_ch0;\r\nkvaser_usbcan_conditionally_rx_error(dev, &es);\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev->udev->dev.parent, "Invalid msg id (%d)\n",\r\nmsg->id);\r\n}\r\n}\r\nstatic void kvaser_leaf_rx_error(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_error_summary es = { };\r\nswitch (msg->id) {\r\ncase CMD_CAN_ERROR_EVENT:\r\nes.channel = msg->u.leaf.error_event.channel;\r\nes.status = msg->u.leaf.error_event.status;\r\nes.txerr = msg->u.leaf.error_event.tx_errors_count;\r\nes.rxerr = msg->u.leaf.error_event.rx_errors_count;\r\nes.leaf.error_factor = msg->u.leaf.error_event.error_factor;\r\nbreak;\r\ncase CMD_LEAF_LOG_MESSAGE:\r\nes.channel = msg->u.leaf.log_message.channel;\r\nes.status = msg->u.leaf.log_message.data[0];\r\nes.txerr = msg->u.leaf.log_message.data[2];\r\nes.rxerr = msg->u.leaf.log_message.data[3];\r\nes.leaf.error_factor = msg->u.leaf.log_message.data[1];\r\nbreak;\r\ncase CMD_CHIP_STATE_EVENT:\r\nes.channel = msg->u.leaf.chip_state_event.channel;\r\nes.status = msg->u.leaf.chip_state_event.status;\r\nes.txerr = msg->u.leaf.chip_state_event.tx_errors_count;\r\nes.rxerr = msg->u.leaf.chip_state_event.rx_errors_count;\r\nes.leaf.error_factor = 0;\r\nbreak;\r\ndefault:\r\ndev_err(dev->udev->dev.parent, "Invalid msg id (%d)\n",\r\nmsg->id);\r\nreturn;\r\n}\r\nkvaser_usb_rx_error(dev, &es);\r\n}\r\nstatic void kvaser_usb_rx_can_err(const struct kvaser_usb_net_priv *priv,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &priv->netdev->stats;\r\nif (msg->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\r\nMSG_FLAG_NERR)) {\r\nnetdev_err(priv->netdev, "Unknown error (flags: 0x%02x)\n",\r\nmsg->u.rx_can_header.flag);\r\nstats->rx_errors++;\r\nreturn;\r\n}\r\nif (msg->u.rx_can_header.flag & MSG_FLAG_OVERRUN) {\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nskb = alloc_can_err_skb(priv->netdev, &cf);\r\nif (!skb) {\r\nstats->rx_dropped++;\r\nreturn;\r\n}\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void kvaser_usb_rx_can_msg(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats;\r\nu8 channel = msg->u.rx_can_header.channel;\r\nconst u8 *rx_msg = NULL;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nstats = &priv->netdev->stats;\r\nif ((msg->u.rx_can_header.flag & MSG_FLAG_ERROR_FRAME) &&\r\n(dev->family == KVASER_LEAF && msg->id == CMD_LEAF_LOG_MESSAGE)) {\r\nkvaser_leaf_rx_error(dev, msg);\r\nreturn;\r\n} else if (msg->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\r\nMSG_FLAG_NERR |\r\nMSG_FLAG_OVERRUN)) {\r\nkvaser_usb_rx_can_err(priv, msg);\r\nreturn;\r\n} else if (msg->u.rx_can_header.flag & ~MSG_FLAG_REMOTE_FRAME) {\r\nnetdev_warn(priv->netdev,\r\n"Unhandled frame (flags: 0x%02x)",\r\nmsg->u.rx_can_header.flag);\r\nreturn;\r\n}\r\nswitch (dev->family) {\r\ncase KVASER_LEAF:\r\nrx_msg = msg->u.leaf.rx_can.msg;\r\nbreak;\r\ncase KVASER_USBCAN:\r\nrx_msg = msg->u.usbcan.rx_can.msg;\r\nbreak;\r\n}\r\nskb = alloc_can_skb(priv->netdev, &cf);\r\nif (!skb) {\r\nstats->tx_dropped++;\r\nreturn;\r\n}\r\nif (dev->family == KVASER_LEAF && msg->id == CMD_LEAF_LOG_MESSAGE) {\r\ncf->can_id = le32_to_cpu(msg->u.leaf.log_message.id);\r\nif (cf->can_id & KVASER_EXTENDED_FRAME)\r\ncf->can_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id &= CAN_SFF_MASK;\r\ncf->can_dlc = get_can_dlc(msg->u.leaf.log_message.dlc);\r\nif (msg->u.leaf.log_message.flags & MSG_FLAG_REMOTE_FRAME)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cf->data, &msg->u.leaf.log_message.data,\r\ncf->can_dlc);\r\n} else {\r\ncf->can_id = ((rx_msg[0] & 0x1f) << 6) | (rx_msg[1] & 0x3f);\r\nif (msg->id == CMD_RX_EXT_MESSAGE) {\r\ncf->can_id <<= 18;\r\ncf->can_id |= ((rx_msg[2] & 0x0f) << 14) |\r\n((rx_msg[3] & 0xff) << 6) |\r\n(rx_msg[4] & 0x3f);\r\ncf->can_id |= CAN_EFF_FLAG;\r\n}\r\ncf->can_dlc = get_can_dlc(rx_msg[5]);\r\nif (msg->u.rx_can_header.flag & MSG_FLAG_REMOTE_FRAME)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nelse\r\nmemcpy(cf->data, &rx_msg[6],\r\ncf->can_dlc);\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic void kvaser_usb_start_chip_reply(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nu8 channel = msg->u.simple.channel;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\nif (completion_done(&priv->start_comp) &&\r\nnetif_queue_stopped(priv->netdev)) {\r\nnetif_wake_queue(priv->netdev);\r\n} else {\r\nnetif_start_queue(priv->netdev);\r\ncomplete(&priv->start_comp);\r\n}\r\n}\r\nstatic void kvaser_usb_stop_chip_reply(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nstruct kvaser_usb_net_priv *priv;\r\nu8 channel = msg->u.simple.channel;\r\nif (channel >= dev->nchannels) {\r\ndev_err(dev->udev->dev.parent,\r\n"Invalid channel number (%d)\n", channel);\r\nreturn;\r\n}\r\npriv = dev->nets[channel];\r\ncomplete(&priv->stop_comp);\r\n}\r\nstatic void kvaser_usb_handle_message(const struct kvaser_usb *dev,\r\nconst struct kvaser_msg *msg)\r\n{\r\nswitch (msg->id) {\r\ncase CMD_START_CHIP_REPLY:\r\nkvaser_usb_start_chip_reply(dev, msg);\r\nbreak;\r\ncase CMD_STOP_CHIP_REPLY:\r\nkvaser_usb_stop_chip_reply(dev, msg);\r\nbreak;\r\ncase CMD_RX_STD_MESSAGE:\r\ncase CMD_RX_EXT_MESSAGE:\r\nkvaser_usb_rx_can_msg(dev, msg);\r\nbreak;\r\ncase CMD_LEAF_LOG_MESSAGE:\r\nif (dev->family != KVASER_LEAF)\r\ngoto warn;\r\nkvaser_usb_rx_can_msg(dev, msg);\r\nbreak;\r\ncase CMD_CHIP_STATE_EVENT:\r\ncase CMD_CAN_ERROR_EVENT:\r\nif (dev->family == KVASER_LEAF)\r\nkvaser_leaf_rx_error(dev, msg);\r\nelse\r\nkvaser_usbcan_rx_error(dev, msg);\r\nbreak;\r\ncase CMD_TX_ACKNOWLEDGE:\r\nkvaser_usb_tx_acknowledge(dev, msg);\r\nbreak;\r\ncase CMD_USBCAN_CLOCK_OVERFLOW_EVENT:\r\nif (dev->family != KVASER_USBCAN)\r\ngoto warn;\r\nbreak;\r\ndefault:\r\nwarn: dev_warn(dev->udev->dev.parent,\r\n"Unhandled message (%d)\n", msg->id);\r\nbreak;\r\n}\r\n}\r\nstatic void kvaser_usb_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct kvaser_usb *dev = urb->context;\r\nstruct kvaser_msg *msg;\r\nint pos = 0;\r\nint err, i;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_info(dev->udev->dev.parent, "Rx URB aborted (%d)\n",\r\nurb->status);\r\ngoto resubmit_urb;\r\n}\r\nwhile (pos <= urb->actual_length - MSG_HEADER_LEN) {\r\nmsg = urb->transfer_buffer + pos;\r\nif (msg->len == 0) {\r\npos = round_up(pos, le16_to_cpu(dev->bulk_in->\r\nwMaxPacketSize));\r\ncontinue;\r\n}\r\nif (pos + msg->len > urb->actual_length) {\r\ndev_err(dev->udev->dev.parent, "Format error\n");\r\nbreak;\r\n}\r\nkvaser_usb_handle_message(dev, msg);\r\npos += msg->len;\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in->bEndpointAddress),\r\nurb->transfer_buffer, RX_BUFFER_SIZE,\r\nkvaser_usb_read_bulk_callback, dev);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err == -ENODEV) {\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nif (!dev->nets[i])\r\ncontinue;\r\nnetif_device_detach(dev->nets[i]->netdev);\r\n}\r\n} else if (err) {\r\ndev_err(dev->udev->dev.parent,\r\n"Failed resubmitting read bulk urb: %d\n", err);\r\n}\r\nreturn;\r\n}\r\nstatic int kvaser_usb_setup_rx_urbs(struct kvaser_usb *dev)\r\n{\r\nint i, err = 0;\r\nif (dev->rxinitdone)\r\nreturn 0;\r\nfor (i = 0; i < MAX_RX_URBS; i++) {\r\nstruct urb *urb = NULL;\r\nu8 *buf = NULL;\r\ndma_addr_t buf_dma;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_warn(dev->udev->dev.parent,\r\n"No memory left for URBs\n");\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, RX_BUFFER_SIZE,\r\nGFP_KERNEL, &buf_dma);\r\nif (!buf) {\r\ndev_warn(dev->udev->dev.parent,\r\n"No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in->bEndpointAddress),\r\nbuf, RX_BUFFER_SIZE,\r\nkvaser_usb_read_bulk_callback,\r\ndev);\r\nurb->transfer_dma = buf_dma;\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->rx_submitted);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(dev->udev, RX_BUFFER_SIZE, buf,\r\nbuf_dma);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\ndev->rxbuf[i] = buf;\r\ndev->rxbuf_dma[i] = buf_dma;\r\nusb_free_urb(urb);\r\n}\r\nif (i == 0) {\r\ndev_warn(dev->udev->dev.parent,\r\n"Cannot setup read URBs, error %d\n", err);\r\nreturn err;\r\n} else if (i < MAX_RX_URBS) {\r\ndev_warn(dev->udev->dev.parent,\r\n"RX performances may be slow\n");\r\n}\r\ndev->rxinitdone = true;\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_set_opt_mode(const struct kvaser_usb_net_priv *priv)\r\n{\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = CMD_SET_CTRL_MODE;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_ctrl_mode);\r\nmsg->u.ctrl_mode.tid = 0xff;\r\nmsg->u.ctrl_mode.channel = priv->channel;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nmsg->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\r\nelse\r\nmsg->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\r\nrc = kvaser_usb_send_msg(priv->dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_start_chip(struct kvaser_usb_net_priv *priv)\r\n{\r\nint err;\r\ninit_completion(&priv->start_comp);\r\nerr = kvaser_usb_send_simple_msg(priv->dev, CMD_START_CHIP,\r\npriv->channel);\r\nif (err)\r\nreturn err;\r\nif (!wait_for_completion_timeout(&priv->start_comp,\r\nmsecs_to_jiffies(START_TIMEOUT)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_open(struct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct kvaser_usb *dev = priv->dev;\r\nint err;\r\nerr = open_candev(netdev);\r\nif (err)\r\nreturn err;\r\nerr = kvaser_usb_setup_rx_urbs(dev);\r\nif (err)\r\ngoto error;\r\nerr = kvaser_usb_set_opt_mode(priv);\r\nif (err)\r\ngoto error;\r\nerr = kvaser_usb_start_chip(priv);\r\nif (err) {\r\nnetdev_warn(netdev, "Cannot start device, error %d\n", err);\r\ngoto error;\r\n}\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\nerror:\r\nclose_candev(netdev);\r\nreturn err;\r\n}\r\nstatic void kvaser_usb_reset_tx_urb_contexts(struct kvaser_usb_net_priv *priv)\r\n{\r\nint i, max_tx_urbs;\r\nmax_tx_urbs = priv->dev->max_tx_urbs;\r\npriv->active_tx_contexts = 0;\r\nfor (i = 0; i < max_tx_urbs; i++)\r\npriv->tx_contexts[i].echo_index = max_tx_urbs;\r\n}\r\nstatic void kvaser_usb_unlink_tx_urbs(struct kvaser_usb_net_priv *priv)\r\n{\r\nusb_kill_anchored_urbs(&priv->tx_submitted);\r\nkvaser_usb_reset_tx_urb_contexts(priv);\r\n}\r\nstatic void kvaser_usb_unlink_all_urbs(struct kvaser_usb *dev)\r\n{\r\nint i;\r\nusb_kill_anchored_urbs(&dev->rx_submitted);\r\nfor (i = 0; i < MAX_RX_URBS; i++)\r\nusb_free_coherent(dev->udev, RX_BUFFER_SIZE,\r\ndev->rxbuf[i],\r\ndev->rxbuf_dma[i]);\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nstruct kvaser_usb_net_priv *priv = dev->nets[i];\r\nif (priv)\r\nkvaser_usb_unlink_tx_urbs(priv);\r\n}\r\n}\r\nstatic int kvaser_usb_stop_chip(struct kvaser_usb_net_priv *priv)\r\n{\r\nint err;\r\ninit_completion(&priv->stop_comp);\r\nerr = kvaser_usb_send_simple_msg(priv->dev, CMD_STOP_CHIP,\r\npriv->channel);\r\nif (err)\r\nreturn err;\r\nif (!wait_for_completion_timeout(&priv->stop_comp,\r\nmsecs_to_jiffies(STOP_TIMEOUT)))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_flush_queue(struct kvaser_usb_net_priv *priv)\r\n{\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = CMD_FLUSH_QUEUE;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_flush_queue);\r\nmsg->u.flush_queue.channel = priv->channel;\r\nmsg->u.flush_queue.flags = 0x00;\r\nrc = kvaser_usb_send_msg(priv->dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_close(struct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct kvaser_usb *dev = priv->dev;\r\nint err;\r\nnetif_stop_queue(netdev);\r\nerr = kvaser_usb_flush_queue(priv);\r\nif (err)\r\nnetdev_warn(netdev, "Cannot flush queue, error %d\n", err);\r\nif (kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, priv->channel))\r\nnetdev_warn(netdev, "Cannot reset card, error %d\n", err);\r\nerr = kvaser_usb_stop_chip(priv);\r\nif (err)\r\nnetdev_warn(netdev, "Cannot stop device, error %d\n", err);\r\nkvaser_usb_unlink_tx_urbs(priv);\r\npriv->can.state = CAN_STATE_STOPPED;\r\nclose_candev(priv->netdev);\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct kvaser_usb_tx_urb_context *context = urb->context;\r\nstruct kvaser_usb_net_priv *priv;\r\nstruct net_device *netdev;\r\nif (WARN_ON(!context))\r\nreturn;\r\npriv = context->priv;\r\nnetdev = priv->netdev;\r\nkfree(urb->transfer_buffer);\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (urb->status)\r\nnetdev_info(netdev, "Tx URB aborted (%d)\n", urb->status);\r\n}\r\nstatic netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct kvaser_usb_tx_urb_context *context = NULL;\r\nstruct urb *urb;\r\nvoid *buf;\r\nstruct kvaser_msg *msg;\r\nint i, err, ret = NETDEV_TX_OK;\r\nu8 *msg_tx_can_flags = NULL;\r\nunsigned long flags;\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nnetdev_err(netdev, "No memory left for URBs\n");\r\nstats->tx_dropped++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nbuf = kmalloc(sizeof(struct kvaser_msg), GFP_ATOMIC);\r\nif (!buf) {\r\nstats->tx_dropped++;\r\ndev_kfree_skb(skb);\r\ngoto freeurb;\r\n}\r\nmsg = buf;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_tx_can);\r\nmsg->u.tx_can.channel = priv->channel;\r\nswitch (dev->family) {\r\ncase KVASER_LEAF:\r\nmsg_tx_can_flags = &msg->u.tx_can.leaf.flags;\r\nbreak;\r\ncase KVASER_USBCAN:\r\nmsg_tx_can_flags = &msg->u.tx_can.usbcan.flags;\r\nbreak;\r\n}\r\n*msg_tx_can_flags = 0;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\nmsg->id = CMD_TX_EXT_MESSAGE;\r\nmsg->u.tx_can.msg[0] = (cf->can_id >> 24) & 0x1f;\r\nmsg->u.tx_can.msg[1] = (cf->can_id >> 18) & 0x3f;\r\nmsg->u.tx_can.msg[2] = (cf->can_id >> 14) & 0x0f;\r\nmsg->u.tx_can.msg[3] = (cf->can_id >> 6) & 0xff;\r\nmsg->u.tx_can.msg[4] = cf->can_id & 0x3f;\r\n} else {\r\nmsg->id = CMD_TX_STD_MESSAGE;\r\nmsg->u.tx_can.msg[0] = (cf->can_id >> 6) & 0x1f;\r\nmsg->u.tx_can.msg[1] = cf->can_id & 0x3f;\r\n}\r\nmsg->u.tx_can.msg[5] = cf->can_dlc;\r\nmemcpy(&msg->u.tx_can.msg[6], cf->data, cf->can_dlc);\r\nif (cf->can_id & CAN_RTR_FLAG)\r\n*msg_tx_can_flags |= MSG_FLAG_REMOTE_FRAME;\r\nspin_lock_irqsave(&priv->tx_contexts_lock, flags);\r\nfor (i = 0; i < dev->max_tx_urbs; i++) {\r\nif (priv->tx_contexts[i].echo_index == dev->max_tx_urbs) {\r\ncontext = &priv->tx_contexts[i];\r\ncontext->echo_index = i;\r\ncan_put_echo_skb(skb, netdev, context->echo_index);\r\n++priv->active_tx_contexts;\r\nif (priv->active_tx_contexts >= dev->max_tx_urbs)\r\nnetif_stop_queue(netdev);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\r\nif (!context) {\r\nnetdev_warn(netdev, "cannot find free context\n");\r\nkfree(buf);\r\nret = NETDEV_TX_BUSY;\r\ngoto freeurb;\r\n}\r\ncontext->priv = priv;\r\ncontext->dlc = cf->can_dlc;\r\nmsg->u.tx_can.tid = context->echo_index;\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out->bEndpointAddress),\r\nbuf, msg->len,\r\nkvaser_usb_write_bulk_callback, context);\r\nusb_anchor_urb(urb, &priv->tx_submitted);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err)) {\r\nspin_lock_irqsave(&priv->tx_contexts_lock, flags);\r\ncan_free_echo_skb(netdev, context->echo_index);\r\ncontext->echo_index = dev->max_tx_urbs;\r\n--priv->active_tx_contexts;\r\nnetif_wake_queue(netdev);\r\nspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\r\nusb_unanchor_urb(urb);\r\nstats->tx_dropped++;\r\nif (err == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse\r\nnetdev_warn(netdev, "Failed tx_urb %d\n", err);\r\ngoto freeurb;\r\n}\r\nret = NETDEV_TX_OK;\r\nfreeurb:\r\nusb_free_urb(urb);\r\nreturn ret;\r\n}\r\nstatic int kvaser_usb_set_bittiming(struct net_device *netdev)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nstruct can_bittiming *bt = &priv->can.bittiming;\r\nstruct kvaser_usb *dev = priv->dev;\r\nstruct kvaser_msg *msg;\r\nint rc;\r\nmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->id = CMD_SET_BUS_PARAMS;\r\nmsg->len = MSG_HEADER_LEN + sizeof(struct kvaser_msg_busparams);\r\nmsg->u.busparams.channel = priv->channel;\r\nmsg->u.busparams.tid = 0xff;\r\nmsg->u.busparams.bitrate = cpu_to_le32(bt->bitrate);\r\nmsg->u.busparams.sjw = bt->sjw;\r\nmsg->u.busparams.tseg1 = bt->prop_seg + bt->phase_seg1;\r\nmsg->u.busparams.tseg2 = bt->phase_seg2;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nmsg->u.busparams.no_samp = 3;\r\nelse\r\nmsg->u.busparams.no_samp = 1;\r\nrc = kvaser_usb_send_msg(dev, msg);\r\nkfree(msg);\r\nreturn rc;\r\n}\r\nstatic int kvaser_usb_set_mode(struct net_device *netdev,\r\nenum can_mode mode)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = kvaser_usb_simple_msg_async(priv, CMD_START_CHIP);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_get_berr_counter(const struct net_device *netdev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\r\n*bec = priv->bec;\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_remove_interfaces(struct kvaser_usb *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nif (!dev->nets[i])\r\ncontinue;\r\nunregister_candev(dev->nets[i]->netdev);\r\n}\r\nkvaser_usb_unlink_all_urbs(dev);\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nif (!dev->nets[i])\r\ncontinue;\r\nfree_candev(dev->nets[i]->netdev);\r\n}\r\n}\r\nstatic int kvaser_usb_init_one(struct usb_interface *intf,\r\nconst struct usb_device_id *id, int channel)\r\n{\r\nstruct kvaser_usb *dev = usb_get_intfdata(intf);\r\nstruct net_device *netdev;\r\nstruct kvaser_usb_net_priv *priv;\r\nint err;\r\nerr = kvaser_usb_send_simple_msg(dev, CMD_RESET_CHIP, channel);\r\nif (err)\r\nreturn err;\r\nnetdev = alloc_candev(sizeof(*priv) +\r\ndev->max_tx_urbs * sizeof(*priv->tx_contexts),\r\ndev->max_tx_urbs);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "Cannot alloc candev\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(netdev);\r\ninit_usb_anchor(&priv->tx_submitted);\r\ninit_completion(&priv->start_comp);\r\ninit_completion(&priv->stop_comp);\r\npriv->dev = dev;\r\npriv->netdev = netdev;\r\npriv->channel = channel;\r\nspin_lock_init(&priv->tx_contexts_lock);\r\nkvaser_usb_reset_tx_urb_contexts(priv);\r\npriv->can.state = CAN_STATE_STOPPED;\r\npriv->can.clock.freq = CAN_USB_CLOCK;\r\npriv->can.bittiming_const = &kvaser_usb_bittiming_const;\r\npriv->can.do_set_bittiming = kvaser_usb_set_bittiming;\r\npriv->can.do_set_mode = kvaser_usb_set_mode;\r\nif (id->driver_info & KVASER_HAS_TXRX_ERRORS)\r\npriv->can.do_get_berr_counter = kvaser_usb_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nif (id->driver_info & KVASER_HAS_SILENT_MODE)\r\npriv->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\r\nnetdev->flags |= IFF_ECHO;\r\nnetdev->netdev_ops = &kvaser_usb_netdev_ops;\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\nnetdev->dev_id = channel;\r\ndev->nets[channel] = priv;\r\nerr = register_candev(netdev);\r\nif (err) {\r\ndev_err(&intf->dev, "Failed to register can device\n");\r\nfree_candev(netdev);\r\ndev->nets[channel] = NULL;\r\nreturn err;\r\n}\r\nnetdev_dbg(netdev, "device registered\n");\r\nreturn 0;\r\n}\r\nstatic int kvaser_usb_get_endpoints(const struct usb_interface *intf,\r\nstruct usb_endpoint_descriptor **in,\r\nstruct usb_endpoint_descriptor **out)\r\n{\r\nconst struct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\niface_desc = &intf->altsetting[0];\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!*in && usb_endpoint_is_bulk_in(endpoint))\r\n*in = endpoint;\r\nif (!*out && usb_endpoint_is_bulk_out(endpoint))\r\n*out = endpoint;\r\nif (*in && *out)\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int kvaser_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct kvaser_usb *dev;\r\nint err = -ENOMEM;\r\nint i, retry = 3;\r\ndev = devm_kzalloc(&intf->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nif (kvaser_is_leaf(id)) {\r\ndev->family = KVASER_LEAF;\r\n} else if (kvaser_is_usbcan(id)) {\r\ndev->family = KVASER_USBCAN;\r\n} else {\r\ndev_err(&intf->dev,\r\n"Product ID (%d) does not belong to any known Kvaser USB family",\r\nid->idProduct);\r\nreturn -ENODEV;\r\n}\r\nerr = kvaser_usb_get_endpoints(intf, &dev->bulk_in, &dev->bulk_out);\r\nif (err) {\r\ndev_err(&intf->dev, "Cannot get usb endpoint(s)");\r\nreturn err;\r\n}\r\ndev->udev = interface_to_usbdev(intf);\r\ninit_usb_anchor(&dev->rx_submitted);\r\nusb_set_intfdata(intf, dev);\r\ndo {\r\nerr = kvaser_usb_get_software_info(dev);\r\n} while (--retry && err == -ETIMEDOUT);\r\nif (err) {\r\ndev_err(&intf->dev,\r\n"Cannot get software infos, error %d\n", err);\r\nreturn err;\r\n}\r\ndev_dbg(&intf->dev, "Firmware version: %d.%d.%d\n",\r\n((dev->fw_version >> 24) & 0xff),\r\n((dev->fw_version >> 16) & 0xff),\r\n(dev->fw_version & 0xffff));\r\ndev_dbg(&intf->dev, "Max oustanding tx = %d URBs\n", dev->max_tx_urbs);\r\nerr = kvaser_usb_get_card_info(dev);\r\nif (err) {\r\ndev_err(&intf->dev,\r\n"Cannot get card infos, error %d\n", err);\r\nreturn err;\r\n}\r\nfor (i = 0; i < dev->nchannels; i++) {\r\nerr = kvaser_usb_init_one(intf, id, i);\r\nif (err) {\r\nkvaser_usb_remove_interfaces(dev);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void kvaser_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct kvaser_usb *dev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (!dev)\r\nreturn;\r\nkvaser_usb_remove_interfaces(dev);\r\n}
