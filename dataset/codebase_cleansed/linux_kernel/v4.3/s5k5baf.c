static int s5k5baf_fw_parse(struct device *dev, struct s5k5baf_fw **fw,\r\nsize_t count, const __le16 *data)\r\n{\r\nstruct s5k5baf_fw *f;\r\nu16 *d, i, *end;\r\nint ret;\r\nif (count < S5K5BAG_FW_TAG_LEN + 1) {\r\ndev_err(dev, "firmware file too short (%zu)\n", count);\r\nreturn -EINVAL;\r\n}\r\nret = memcmp(data, S5K5BAF_FW_TAG, S5K5BAG_FW_TAG_LEN * sizeof(u16));\r\nif (ret != 0) {\r\ndev_err(dev, "invalid firmware magic number\n");\r\nreturn -EINVAL;\r\n}\r\ndata += S5K5BAG_FW_TAG_LEN;\r\ncount -= S5K5BAG_FW_TAG_LEN;\r\nd = devm_kzalloc(dev, count * sizeof(u16), GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < count; ++i)\r\nd[i] = le16_to_cpu(data[i]);\r\nf = (struct s5k5baf_fw *)d;\r\nif (count < 1 + 2 * f->count) {\r\ndev_err(dev, "invalid firmware header (count=%d size=%zu)\n",\r\nf->count, 2 * (count + S5K5BAG_FW_TAG_LEN));\r\nreturn -EINVAL;\r\n}\r\nend = d + count;\r\nd += 1 + 2 * f->count;\r\nfor (i = 0; i < f->count; ++i) {\r\nif (f->seq[i].offset + d <= end)\r\ncontinue;\r\ndev_err(dev, "invalid firmware header (seq=%d)\n", i);\r\nreturn -EINVAL;\r\n}\r\n*fw = f;\r\nreturn 0;\r\n}\r\nstatic inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct s5k5baf, ctrls.handler)->sd;\r\n}\r\nstatic inline bool s5k5baf_is_cis_subdev(struct v4l2_subdev *sd)\r\n{\r\nreturn sd->entity.type == MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\n}\r\nstatic inline struct s5k5baf *to_s5k5baf(struct v4l2_subdev *sd)\r\n{\r\nif (s5k5baf_is_cis_subdev(sd))\r\nreturn container_of(sd, struct s5k5baf, cis_sd);\r\nelse\r\nreturn container_of(sd, struct s5k5baf, sd);\r\n}\r\nstatic u16 s5k5baf_i2c_read(struct s5k5baf *state, u16 addr)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\r\n__be16 w, r;\r\nu16 res;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = c->addr, .flags = 0,\r\n.len = 2, .buf = (u8 *)&w },\r\n{ .addr = c->addr, .flags = I2C_M_RD,\r\n.len = 2, .buf = (u8 *)&r },\r\n};\r\nint ret;\r\nif (state->error)\r\nreturn 0;\r\nw = cpu_to_be16(addr);\r\nret = i2c_transfer(c->adapter, msg, 2);\r\nres = be16_to_cpu(r);\r\nv4l2_dbg(3, debug, c, "i2c_read: 0x%04x : 0x%04x\n", addr, res);\r\nif (ret != 2) {\r\nv4l2_err(c, "i2c_read: error during transfer (%d)\n", ret);\r\nstate->error = ret;\r\n}\r\nreturn res;\r\n}\r\nstatic void s5k5baf_i2c_write(struct s5k5baf *state, u16 addr, u16 val)\r\n{\r\nu8 buf[4] = { addr >> 8, addr & 0xFF, val >> 8, val & 0xFF };\r\nstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\r\nint ret;\r\nif (state->error)\r\nreturn;\r\nret = i2c_master_send(c, buf, 4);\r\nv4l2_dbg(3, debug, c, "i2c_write: 0x%04x : 0x%04x\n", addr, val);\r\nif (ret != 4) {\r\nv4l2_err(c, "i2c_write: error during transfer (%d)\n", ret);\r\nstate->error = ret;\r\n}\r\n}\r\nstatic u16 s5k5baf_read(struct s5k5baf *state, u16 addr)\r\n{\r\ns5k5baf_i2c_write(state, REG_CMDRD_ADDR, addr);\r\nreturn s5k5baf_i2c_read(state, REG_CMD_BUF);\r\n}\r\nstatic void s5k5baf_write(struct s5k5baf *state, u16 addr, u16 val)\r\n{\r\ns5k5baf_i2c_write(state, REG_CMDWR_ADDR, addr);\r\ns5k5baf_i2c_write(state, REG_CMD_BUF, val);\r\n}\r\nstatic void s5k5baf_write_arr_seq(struct s5k5baf *state, u16 addr,\r\nu16 count, const u16 *seq)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\r\n__be16 buf[65];\r\ns5k5baf_i2c_write(state, REG_CMDWR_ADDR, addr);\r\nif (state->error)\r\nreturn;\r\nv4l2_dbg(3, debug, c, "i2c_write_seq(count=%d): %*ph\n", count,\r\nmin(2 * count, 64), seq);\r\nbuf[0] = cpu_to_be16(REG_CMD_BUF);\r\nwhile (count > 0) {\r\nint n = min_t(int, count, ARRAY_SIZE(buf) - 1);\r\nint ret, i;\r\nfor (i = 1; i <= n; ++i)\r\nbuf[i] = cpu_to_be16(*seq++);\r\ni *= 2;\r\nret = i2c_master_send(c, (char *)buf, i);\r\nif (ret != i) {\r\nv4l2_err(c, "i2c_write_seq: error during transfer (%d)\n", ret);\r\nstate->error = ret;\r\nbreak;\r\n}\r\ncount -= n;\r\n}\r\n}\r\nstatic void s5k5baf_write_nseq(struct s5k5baf *state, const u16 *nseq)\r\n{\r\nint count;\r\nwhile ((count = *nseq++)) {\r\nu16 addr = *nseq++;\r\n--count;\r\ns5k5baf_write_arr_seq(state, addr, count, nseq);\r\nnseq += count;\r\n}\r\n}\r\nstatic void s5k5baf_synchronize(struct s5k5baf *state, int timeout, u16 addr)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(timeout);\r\nu16 reg;\r\ns5k5baf_write(state, addr, 1);\r\ndo {\r\nreg = s5k5baf_read(state, addr);\r\nif (state->error || !reg)\r\nreturn;\r\nusleep_range(5000, 10000);\r\n} while (time_is_after_jiffies(end));\r\nv4l2_err(&state->sd, "timeout on register synchronize (%#x)\n", addr);\r\nstate->error = -ETIMEDOUT;\r\n}\r\nstatic u16 *s5k5baf_fw_get_seq(struct s5k5baf *state, u16 seq_id)\r\n{\r\nstruct s5k5baf_fw *fw = state->fw;\r\nu16 *data;\r\nint i;\r\nif (fw == NULL)\r\nreturn NULL;\r\ndata = fw->data + 2 * fw->count;\r\nfor (i = 0; i < fw->count; ++i) {\r\nif (fw->seq[i].id == seq_id)\r\nreturn data + fw->seq[i].offset;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void s5k5baf_hw_patch(struct s5k5baf *state)\r\n{\r\nu16 *seq = s5k5baf_fw_get_seq(state, S5K5BAF_FW_ID_PATCH);\r\nif (seq)\r\ns5k5baf_write_nseq(state, seq);\r\n}\r\nstatic void s5k5baf_hw_set_clocks(struct s5k5baf *state)\r\n{\r\nunsigned long mclk = state->mclk_frequency / 1000;\r\nu16 status;\r\nstatic const u16 nseq_clk_cfg[] = {\r\nNSEQ(REG_I_USE_NPVI_CLOCKS,\r\nNPVI_CLOCKS, NMIPI_CLOCKS, 0,\r\nSCLK_PVI_FREQ / 4, PCLK_MIN_FREQ / 4, PCLK_MAX_FREQ / 4,\r\nSCLK_MIPI_FREQ / 4, PCLK_MIN_FREQ / 4, PCLK_MAX_FREQ / 4),\r\nNSEQ(REG_I_USE_REGS_API, 1),\r\n0\r\n};\r\ns5k5baf_write_seq(state, REG_I_INCLK_FREQ_L, mclk & 0xffff, mclk >> 16);\r\ns5k5baf_write_nseq(state, nseq_clk_cfg);\r\ns5k5baf_synchronize(state, 250, REG_I_INIT_PARAMS_UPDATED);\r\nstatus = s5k5baf_read(state, REG_I_ERROR_INFO);\r\nif (!state->error && status) {\r\nv4l2_err(&state->sd, "error configuring PLL (%d)\n", status);\r\nstate->error = -EINVAL;\r\n}\r\n}\r\nstatic void s5k5baf_hw_set_ccm(struct s5k5baf *state)\r\n{\r\nu16 *seq = s5k5baf_fw_get_seq(state, S5K5BAF_FW_ID_CCM);\r\nif (seq)\r\ns5k5baf_write_nseq(state, seq);\r\n}\r\nstatic void s5k5baf_hw_set_cis(struct s5k5baf *state)\r\n{\r\nu16 *seq = s5k5baf_fw_get_seq(state, S5K5BAF_FW_ID_CIS);\r\nif (!seq)\r\nreturn;\r\ns5k5baf_i2c_write(state, REG_CMDWR_PAGE, PAGE_IF_HW);\r\ns5k5baf_write_nseq(state, seq);\r\ns5k5baf_i2c_write(state, REG_CMDWR_PAGE, PAGE_IF_SW);\r\n}\r\nstatic void s5k5baf_hw_sync_cfg(struct s5k5baf *state)\r\n{\r\ns5k5baf_write(state, REG_G_PREV_CFG_CHG, 1);\r\nif (state->apply_crop) {\r\ns5k5baf_write(state, REG_G_INPUTS_CHANGE_REQ, 1);\r\ns5k5baf_write(state, REG_G_PREV_CFG_BYPASS_CHANGED, 1);\r\n}\r\ns5k5baf_synchronize(state, 500, REG_G_NEW_CFG_SYNC);\r\n}\r\nstatic void s5k5baf_hw_set_mirror(struct s5k5baf *state)\r\n{\r\nu16 flip = state->ctrls.vflip->val | (state->ctrls.vflip->val << 1);\r\ns5k5baf_write(state, REG_P_PREV_MIRROR(0), flip);\r\nif (state->streaming)\r\ns5k5baf_hw_sync_cfg(state);\r\n}\r\nstatic void s5k5baf_hw_set_alg(struct s5k5baf *state, u16 alg, bool enable)\r\n{\r\nu16 cur_alg, new_alg;\r\nif (!state->valid_auto_alg)\r\ncur_alg = s5k5baf_read(state, REG_DBG_AUTOALG_EN);\r\nelse\r\ncur_alg = state->auto_alg;\r\nnew_alg = enable ? (cur_alg | alg) : (cur_alg & ~alg);\r\nif (new_alg != cur_alg)\r\ns5k5baf_write(state, REG_DBG_AUTOALG_EN, new_alg);\r\nif (state->error)\r\nreturn;\r\nstate->valid_auto_alg = 1;\r\nstate->auto_alg = new_alg;\r\n}\r\nstatic void s5k5baf_hw_set_awb(struct s5k5baf *state, int awb)\r\n{\r\nstruct s5k5baf_ctrls *ctrls = &state->ctrls;\r\nif (!awb)\r\ns5k5baf_write_seq(state, REG_SF_RGAIN,\r\nctrls->gain_red->val, 1,\r\nS5K5BAF_GAIN_GREEN_DEF, 1,\r\nctrls->gain_blue->val, 1,\r\n1);\r\ns5k5baf_hw_set_alg(state, AALG_WB_EN, awb);\r\n}\r\nstatic void s5k5baf_hw_set_user_exposure(struct s5k5baf *state, int exposure)\r\n{\r\nunsigned int time = exposure / 10;\r\ns5k5baf_write_seq(state, REG_SF_USR_EXPOSURE_L,\r\ntime & 0xffff, time >> 16, 1);\r\n}\r\nstatic void s5k5baf_hw_set_user_gain(struct s5k5baf *state, int gain)\r\n{\r\ns5k5baf_write_seq(state, REG_SF_USR_TOT_GAIN, gain, 1);\r\n}\r\nstatic void s5k5baf_hw_set_auto_exposure(struct s5k5baf *state, int value)\r\n{\r\nif (value == V4L2_EXPOSURE_AUTO) {\r\ns5k5baf_hw_set_alg(state, AALG_AE_EN | AALG_DIVLEI_EN, true);\r\n} else {\r\nunsigned int exp_time = state->ctrls.exposure->val;\r\ns5k5baf_hw_set_user_exposure(state, exp_time);\r\ns5k5baf_hw_set_user_gain(state, state->ctrls.gain->val);\r\ns5k5baf_hw_set_alg(state, AALG_AE_EN | AALG_DIVLEI_EN, false);\r\n}\r\n}\r\nstatic void s5k5baf_hw_set_anti_flicker(struct s5k5baf *state, int v)\r\n{\r\nif (v == V4L2_CID_POWER_LINE_FREQUENCY_AUTO) {\r\ns5k5baf_hw_set_alg(state, AALG_FLICKER_EN, true);\r\n} else {\r\ns5k5baf_write_seq(state, REG_SF_FLICKER_QUANT, v, 1);\r\ns5k5baf_hw_set_alg(state, AALG_FLICKER_EN, false);\r\n}\r\n}\r\nstatic void s5k5baf_hw_set_colorfx(struct s5k5baf *state, int val)\r\n{\r\nstatic const u16 colorfx[] = {\r\n[V4L2_COLORFX_NONE] = 0,\r\n[V4L2_COLORFX_BW] = 1,\r\n[V4L2_COLORFX_NEGATIVE] = 2,\r\n[V4L2_COLORFX_SEPIA] = 3,\r\n[V4L2_COLORFX_SKY_BLUE] = 4,\r\n[V4L2_COLORFX_SKETCH] = 5,\r\n};\r\ns5k5baf_write(state, REG_G_SPEC_EFFECTS, colorfx[val]);\r\n}\r\nstatic int s5k5baf_find_pixfmt(struct v4l2_mbus_framefmt *mf)\r\n{\r\nint i, c = -1;\r\nfor (i = 0; i < ARRAY_SIZE(s5k5baf_formats); i++) {\r\nif (mf->colorspace != s5k5baf_formats[i].colorspace)\r\ncontinue;\r\nif (mf->code == s5k5baf_formats[i].code)\r\nreturn i;\r\nif (c < 0)\r\nc = i;\r\n}\r\nreturn (c < 0) ? 0 : c;\r\n}\r\nstatic int s5k5baf_clear_error(struct s5k5baf *state)\r\n{\r\nint ret = state->error;\r\nstate->error = 0;\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_hw_set_video_bus(struct s5k5baf *state)\r\n{\r\nu16 en_pkts;\r\nif (state->bus_type == V4L2_MBUS_CSI2)\r\nen_pkts = EN_PACKETS_CSI2;\r\nelse\r\nen_pkts = 0;\r\ns5k5baf_write_seq(state, REG_OIF_EN_MIPI_LANES,\r\nstate->nlanes, en_pkts, 1);\r\nreturn s5k5baf_clear_error(state);\r\n}\r\nstatic u16 s5k5baf_get_cfg_error(struct s5k5baf *state)\r\n{\r\nu16 err = s5k5baf_read(state, REG_G_PREV_CFG_ERROR);\r\nif (err)\r\ns5k5baf_write(state, REG_G_PREV_CFG_ERROR, 0);\r\nreturn err;\r\n}\r\nstatic void s5k5baf_hw_set_fiv(struct s5k5baf *state, u16 fiv)\r\n{\r\ns5k5baf_write(state, REG_P_MAX_FR_TIME(0), fiv);\r\ns5k5baf_hw_sync_cfg(state);\r\n}\r\nstatic void s5k5baf_hw_find_min_fiv(struct s5k5baf *state)\r\n{\r\nu16 err, fiv;\r\nint n;\r\nfiv = s5k5baf_read(state, REG_G_ACTUAL_P_FR_TIME);\r\nif (state->error)\r\nreturn;\r\nfor (n = 5; n > 0; --n) {\r\ns5k5baf_hw_set_fiv(state, fiv);\r\nerr = s5k5baf_get_cfg_error(state);\r\nif (state->error)\r\nreturn;\r\nswitch (err) {\r\ncase CFG_ERROR_RANGE:\r\n++fiv;\r\nbreak;\r\ncase 0:\r\nstate->fiv = fiv;\r\nv4l2_info(&state->sd,\r\n"found valid frame interval: %d00us\n", fiv);\r\nreturn;\r\ndefault:\r\nv4l2_err(&state->sd,\r\n"error setting frame interval: %d\n", err);\r\nstate->error = -EINVAL;\r\n}\r\n}\r\nv4l2_err(&state->sd, "cannot find correct frame interval\n");\r\nstate->error = -ERANGE;\r\n}\r\nstatic void s5k5baf_hw_validate_cfg(struct s5k5baf *state)\r\n{\r\nu16 err;\r\nerr = s5k5baf_get_cfg_error(state);\r\nif (state->error)\r\nreturn;\r\nswitch (err) {\r\ncase 0:\r\nstate->apply_cfg = 1;\r\nreturn;\r\ncase CFG_ERROR_RANGE:\r\ns5k5baf_hw_find_min_fiv(state);\r\nif (!state->error)\r\nstate->apply_cfg = 1;\r\nreturn;\r\ndefault:\r\nv4l2_err(&state->sd,\r\n"error setting format: %d\n", err);\r\nstate->error = -EINVAL;\r\n}\r\n}\r\nstatic void s5k5baf_rescale(struct v4l2_rect *r, const struct v4l2_rect *v,\r\nconst struct v4l2_rect *n,\r\nconst struct v4l2_rect *d)\r\n{\r\nr->left = v->left * n->width / d->width;\r\nr->top = v->top * n->height / d->height;\r\nr->width = v->width * n->width / d->width;\r\nr->height = v->height * n->height / d->height;\r\n}\r\nstatic int s5k5baf_hw_set_crop_rects(struct s5k5baf *state)\r\n{\r\nstruct v4l2_rect *p, r;\r\nu16 err;\r\nint ret;\r\np = &state->crop_sink;\r\ns5k5baf_write_seq(state, REG_G_PREVREQ_IN_WIDTH, p->width, p->height,\r\np->left, p->top);\r\ns5k5baf_rescale(&r, &state->crop_source, &state->crop_sink,\r\n&state->compose);\r\ns5k5baf_write_seq(state, REG_G_PREVZOOM_IN_WIDTH, r.width, r.height,\r\nr.left, r.top);\r\ns5k5baf_synchronize(state, 500, REG_G_INPUTS_CHANGE_REQ);\r\ns5k5baf_synchronize(state, 500, REG_G_PREV_CFG_BYPASS_CHANGED);\r\nerr = s5k5baf_get_cfg_error(state);\r\nret = s5k5baf_clear_error(state);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (err) {\r\ncase 0:\r\nbreak;\r\ncase CFG_ERROR_RANGE:\r\ns5k5baf_hw_set_fiv(state, S5K5BAF_MAX_FR_TIME);\r\nerr = s5k5baf_get_cfg_error(state);\r\nret = s5k5baf_clear_error(state);\r\nif (ret < 0)\r\nreturn ret;\r\nif (err) {\r\nv4l2_err(&state->sd,\r\n"crop error on max frame interval: %d\n", err);\r\nstate->error = -EINVAL;\r\n}\r\ns5k5baf_hw_set_fiv(state, state->req_fiv);\r\ns5k5baf_hw_validate_cfg(state);\r\nbreak;\r\ndefault:\r\nv4l2_err(&state->sd, "crop error: %d\n", err);\r\nreturn -EINVAL;\r\n}\r\nif (!state->apply_cfg)\r\nreturn 0;\r\np = &state->crop_source;\r\ns5k5baf_write_seq(state, REG_P_OUT_WIDTH(0), p->width, p->height);\r\ns5k5baf_hw_set_fiv(state, state->req_fiv);\r\ns5k5baf_hw_validate_cfg(state);\r\nreturn s5k5baf_clear_error(state);\r\n}\r\nstatic void s5k5baf_hw_set_config(struct s5k5baf *state)\r\n{\r\nu16 reg_fmt = s5k5baf_formats[state->pixfmt].reg_p_fmt;\r\nstruct v4l2_rect *r = &state->crop_source;\r\ns5k5baf_write_seq(state, REG_P_OUT_WIDTH(0),\r\nr->width, r->height, reg_fmt,\r\nPCLK_MAX_FREQ >> 2, PCLK_MIN_FREQ >> 2,\r\nPVI_MASK_MIPI, CLK_MIPI_INDEX,\r\nFR_RATE_FIXED, FR_RATE_Q_DYNAMIC,\r\nstate->req_fiv, S5K5BAF_MIN_FR_TIME);\r\ns5k5baf_hw_sync_cfg(state);\r\ns5k5baf_hw_validate_cfg(state);\r\n}\r\nstatic void s5k5baf_hw_set_test_pattern(struct s5k5baf *state, int id)\r\n{\r\ns5k5baf_i2c_write(state, REG_PATTERN_WIDTH, 800);\r\ns5k5baf_i2c_write(state, REG_PATTERN_HEIGHT, 511);\r\ns5k5baf_i2c_write(state, REG_PATTERN_PARAM, 0);\r\ns5k5baf_i2c_write(state, REG_PATTERN_SET, id);\r\n}\r\nstatic void s5k5baf_gpio_assert(struct s5k5baf *state, int id)\r\n{\r\nstruct s5k5baf_gpio *gpio = &state->gpios[id];\r\ngpio_set_value(gpio->gpio, gpio->level);\r\n}\r\nstatic void s5k5baf_gpio_deassert(struct s5k5baf *state, int id)\r\n{\r\nstruct s5k5baf_gpio *gpio = &state->gpios[id];\r\ngpio_set_value(gpio->gpio, !gpio->level);\r\n}\r\nstatic int s5k5baf_power_on(struct s5k5baf *state)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(S5K5BAF_NUM_SUPPLIES, state->supplies);\r\nif (ret < 0)\r\ngoto err;\r\nret = clk_set_rate(state->clock, state->mclk_frequency);\r\nif (ret < 0)\r\ngoto err_reg_dis;\r\nret = clk_prepare_enable(state->clock);\r\nif (ret < 0)\r\ngoto err_reg_dis;\r\nv4l2_dbg(1, debug, &state->sd, "clock frequency: %ld\n",\r\nclk_get_rate(state->clock));\r\ns5k5baf_gpio_deassert(state, STBY);\r\nusleep_range(50, 100);\r\ns5k5baf_gpio_deassert(state, RST);\r\nreturn 0;\r\nerr_reg_dis:\r\nregulator_bulk_disable(S5K5BAF_NUM_SUPPLIES, state->supplies);\r\nerr:\r\nv4l2_err(&state->sd, "%s() failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_power_off(struct s5k5baf *state)\r\n{\r\nint ret;\r\nstate->streaming = 0;\r\nstate->apply_cfg = 0;\r\nstate->apply_crop = 0;\r\ns5k5baf_gpio_assert(state, RST);\r\ns5k5baf_gpio_assert(state, STBY);\r\nif (!IS_ERR(state->clock))\r\nclk_disable_unprepare(state->clock);\r\nret = regulator_bulk_disable(S5K5BAF_NUM_SUPPLIES,\r\nstate->supplies);\r\nif (ret < 0)\r\nv4l2_err(&state->sd, "failed to disable regulators\n");\r\nreturn 0;\r\n}\r\nstatic void s5k5baf_hw_init(struct s5k5baf *state)\r\n{\r\ns5k5baf_i2c_write(state, AHB_MSB_ADDR_PTR, PAGE_IF_HW);\r\ns5k5baf_i2c_write(state, REG_CLEAR_HOST_INT, 0);\r\ns5k5baf_i2c_write(state, REG_SW_LOAD_COMPLETE, 1);\r\ns5k5baf_i2c_write(state, REG_CMDRD_PAGE, PAGE_IF_SW);\r\ns5k5baf_i2c_write(state, REG_CMDWR_PAGE, PAGE_IF_SW);\r\n}\r\nstatic void s5k5baf_initialize_data(struct s5k5baf *state)\r\n{\r\nstate->pixfmt = 0;\r\nstate->req_fiv = 10000 / 15;\r\nstate->fiv = state->req_fiv;\r\nstate->valid_auto_alg = 0;\r\n}\r\nstatic int s5k5baf_load_setfile(struct s5k5baf *state)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\r\nconst struct firmware *fw;\r\nint ret;\r\nret = request_firmware(&fw, S5K5BAF_FW_FILENAME, &c->dev);\r\nif (ret < 0) {\r\ndev_warn(&c->dev, "firmware file (%s) not loaded\n",\r\nS5K5BAF_FW_FILENAME);\r\nreturn ret;\r\n}\r\nret = s5k5baf_fw_parse(&c->dev, &state->fw, fw->size / 2,\r\n(__le16 *)fw->data);\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_set_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nint ret = 0;\r\nmutex_lock(&state->lock);\r\nif (state->power != !on)\r\ngoto out;\r\nif (on) {\r\nif (state->fw == NULL)\r\ns5k5baf_load_setfile(state);\r\ns5k5baf_initialize_data(state);\r\nret = s5k5baf_power_on(state);\r\nif (ret < 0)\r\ngoto out;\r\ns5k5baf_hw_init(state);\r\ns5k5baf_hw_patch(state);\r\ns5k5baf_i2c_write(state, REG_SET_HOST_INT, 1);\r\ns5k5baf_hw_set_clocks(state);\r\nret = s5k5baf_hw_set_video_bus(state);\r\nif (ret < 0)\r\ngoto out;\r\ns5k5baf_hw_set_cis(state);\r\ns5k5baf_hw_set_ccm(state);\r\nret = s5k5baf_clear_error(state);\r\nif (!ret)\r\nstate->power++;\r\n} else {\r\ns5k5baf_power_off(state);\r\nstate->power--;\r\n}\r\nout:\r\nmutex_unlock(&state->lock);\r\nif (!ret && on)\r\nret = v4l2_ctrl_handler_setup(&state->ctrls.handler);\r\nreturn ret;\r\n}\r\nstatic void s5k5baf_hw_set_stream(struct s5k5baf *state, int enable)\r\n{\r\ns5k5baf_write_seq(state, REG_G_ENABLE_PREV, enable, 1);\r\n}\r\nstatic int s5k5baf_s_stream(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nint ret;\r\nmutex_lock(&state->lock);\r\nif (state->streaming == !!on) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (on) {\r\ns5k5baf_hw_set_config(state);\r\nret = s5k5baf_hw_set_crop_rects(state);\r\nif (ret < 0)\r\ngoto out;\r\ns5k5baf_hw_set_stream(state, 1);\r\ns5k5baf_i2c_write(state, 0xb0cc, 0x000b);\r\n} else {\r\ns5k5baf_hw_set_stream(state, 0);\r\n}\r\nret = s5k5baf_clear_error(state);\r\nif (!ret)\r\nstate->streaming = !state->streaming;\r\nout:\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_g_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nmutex_lock(&state->lock);\r\nfi->interval.numerator = state->fiv;\r\nfi->interval.denominator = 10000;\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic void s5k5baf_set_frame_interval(struct s5k5baf *state,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct v4l2_fract *i = &fi->interval;\r\nif (fi->interval.denominator == 0)\r\nstate->req_fiv = S5K5BAF_MAX_FR_TIME;\r\nelse\r\nstate->req_fiv = clamp_t(u32,\r\ni->numerator * 10000 / i->denominator,\r\nS5K5BAF_MIN_FR_TIME,\r\nS5K5BAF_MAX_FR_TIME);\r\nstate->fiv = state->req_fiv;\r\nif (state->apply_cfg) {\r\ns5k5baf_hw_set_fiv(state, state->req_fiv);\r\ns5k5baf_hw_validate_cfg(state);\r\n}\r\n*i = (struct v4l2_fract){ state->fiv, 10000 };\r\nif (state->fiv == state->req_fiv)\r\nv4l2_info(&state->sd, "frame interval changed to %d00us\n",\r\nstate->fiv);\r\n}\r\nstatic int s5k5baf_s_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nmutex_lock(&state->lock);\r\ns5k5baf_set_frame_interval(state, fi);\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_enum_frame_interval(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_interval_enum *fie)\r\n{\r\nif (fie->index > S5K5BAF_MAX_FR_TIME - S5K5BAF_MIN_FR_TIME ||\r\nfie->pad != PAD_CIS)\r\nreturn -EINVAL;\r\nv4l_bound_align_image(&fie->width, S5K5BAF_WIN_WIDTH_MIN,\r\nS5K5BAF_CIS_WIDTH, 1,\r\n&fie->height, S5K5BAF_WIN_HEIGHT_MIN,\r\nS5K5BAF_CIS_HEIGHT, 1, 0);\r\nfie->interval.numerator = S5K5BAF_MIN_FR_TIME + fie->index;\r\nfie->interval.denominator = 10000;\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad == PAD_CIS) {\r\nif (code->index > 0)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_FIXED;\r\nreturn 0;\r\n}\r\nif (code->index >= ARRAY_SIZE(s5k5baf_formats))\r\nreturn -EINVAL;\r\ncode->code = s5k5baf_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nint i;\r\nif (fse->index > 0)\r\nreturn -EINVAL;\r\nif (fse->pad == PAD_CIS) {\r\nfse->code = MEDIA_BUS_FMT_FIXED;\r\nfse->min_width = S5K5BAF_CIS_WIDTH;\r\nfse->max_width = S5K5BAF_CIS_WIDTH;\r\nfse->min_height = S5K5BAF_CIS_HEIGHT;\r\nfse->max_height = S5K5BAF_CIS_HEIGHT;\r\nreturn 0;\r\n}\r\ni = ARRAY_SIZE(s5k5baf_formats);\r\nwhile (--i)\r\nif (fse->code == s5k5baf_formats[i].code)\r\nbreak;\r\nfse->code = s5k5baf_formats[i].code;\r\nfse->min_width = S5K5BAF_WIN_WIDTH_MIN;\r\nfse->max_width = S5K5BAF_CIS_WIDTH;\r\nfse->max_height = S5K5BAF_WIN_HEIGHT_MIN;\r\nfse->min_height = S5K5BAF_CIS_HEIGHT;\r\nreturn 0;\r\n}\r\nstatic void s5k5baf_try_cis_format(struct v4l2_mbus_framefmt *mf)\r\n{\r\nmf->width = S5K5BAF_CIS_WIDTH;\r\nmf->height = S5K5BAF_CIS_HEIGHT;\r\nmf->code = MEDIA_BUS_FMT_FIXED;\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmf->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int s5k5baf_try_isp_format(struct v4l2_mbus_framefmt *mf)\r\n{\r\nint pixfmt;\r\nv4l_bound_align_image(&mf->width, S5K5BAF_WIN_WIDTH_MIN,\r\nS5K5BAF_CIS_WIDTH, 1,\r\n&mf->height, S5K5BAF_WIN_HEIGHT_MIN,\r\nS5K5BAF_CIS_HEIGHT, 1, 0);\r\npixfmt = s5k5baf_find_pixfmt(mf);\r\nmf->colorspace = s5k5baf_formats[pixfmt].colorspace;\r\nmf->code = s5k5baf_formats[pixfmt].code;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn pixfmt;\r\n}\r\nstatic int s5k5baf_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nconst struct s5k5baf_pixfmt *pixfmt;\r\nstruct v4l2_mbus_framefmt *mf;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);\r\nfmt->format = *mf;\r\nreturn 0;\r\n}\r\nmf = &fmt->format;\r\nif (fmt->pad == PAD_CIS) {\r\ns5k5baf_try_cis_format(mf);\r\nreturn 0;\r\n}\r\nmf->field = V4L2_FIELD_NONE;\r\nmutex_lock(&state->lock);\r\npixfmt = &s5k5baf_formats[state->pixfmt];\r\nmf->width = state->crop_source.width;\r\nmf->height = state->crop_source.height;\r\nmf->code = pixfmt->code;\r\nmf->colorspace = pixfmt->colorspace;\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nconst struct s5k5baf_pixfmt *pixfmt;\r\nint ret = 0;\r\nmf->field = V4L2_FIELD_NONE;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\n*v4l2_subdev_get_try_format(sd, cfg, fmt->pad) = *mf;\r\nreturn 0;\r\n}\r\nif (fmt->pad == PAD_CIS) {\r\ns5k5baf_try_cis_format(mf);\r\nreturn 0;\r\n}\r\nmutex_lock(&state->lock);\r\nif (state->streaming) {\r\nmutex_unlock(&state->lock);\r\nreturn -EBUSY;\r\n}\r\nstate->pixfmt = s5k5baf_try_isp_format(mf);\r\npixfmt = &s5k5baf_formats[state->pixfmt];\r\nmf->code = pixfmt->code;\r\nmf->colorspace = pixfmt->colorspace;\r\nmf->width = state->crop_source.width;\r\nmf->height = state->crop_source.height;\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic enum selection_rect s5k5baf_get_sel_rect(u32 pad, u32 target)\r\n{\r\nswitch (target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nreturn pad ? R_COMPOSE : R_CIS;\r\ncase V4L2_SEL_TGT_CROP:\r\nreturn pad ? R_CROP_SOURCE : R_CROP_SINK;\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nreturn pad ? R_INVALID : R_CROP_SINK;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nreturn pad ? R_INVALID : R_COMPOSE;\r\ndefault:\r\nreturn R_INVALID;\r\n}\r\n}\r\nstatic int s5k5baf_is_bound_target(u32 target)\r\n{\r\nreturn target == V4L2_SEL_TGT_CROP_BOUNDS ||\r\ntarget == V4L2_SEL_TGT_COMPOSE_BOUNDS;\r\n}\r\nstatic int s5k5baf_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstatic enum selection_rect rtype;\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nrtype = s5k5baf_get_sel_rect(sel->pad, sel->target);\r\nswitch (rtype) {\r\ncase R_INVALID:\r\nreturn -EINVAL;\r\ncase R_CIS:\r\nsel->r = s5k5baf_cis_rect;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nif (rtype == R_COMPOSE)\r\nsel->r = *v4l2_subdev_get_try_compose(sd, cfg, sel->pad);\r\nelse\r\nsel->r = *v4l2_subdev_get_try_crop(sd, cfg, sel->pad);\r\nreturn 0;\r\n}\r\nmutex_lock(&state->lock);\r\nswitch (rtype) {\r\ncase R_CROP_SINK:\r\nsel->r = state->crop_sink;\r\nbreak;\r\ncase R_COMPOSE:\r\nsel->r = state->compose;\r\nbreak;\r\ncase R_CROP_SOURCE:\r\nsel->r = state->crop_source;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (s5k5baf_is_bound_target(sel->target)) {\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\n}\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic void s5k5baf_bound_range(u32 *start, u32 *len, u32 max)\r\n{\r\nif (*len > max)\r\n*len = max;\r\nif (*start + *len > max)\r\n*start = max - *len;\r\n*start &= ~1;\r\n*len &= ~1;\r\nif (*len < S5K5BAF_WIN_WIDTH_MIN)\r\n*len = S5K5BAF_WIN_WIDTH_MIN;\r\n}\r\nstatic void s5k5baf_bound_rect(struct v4l2_rect *r, u32 width, u32 height)\r\n{\r\ns5k5baf_bound_range(&r->left, &r->width, width);\r\ns5k5baf_bound_range(&r->top, &r->height, height);\r\n}\r\nstatic void s5k5baf_set_rect_and_adjust(struct v4l2_rect **rects,\r\nenum selection_rect first,\r\nstruct v4l2_rect *v)\r\n{\r\nstruct v4l2_rect *r, *br;\r\nenum selection_rect i = first;\r\n*rects[first] = *v;\r\ndo {\r\nr = rects[i];\r\nbr = rects[i - 1];\r\ns5k5baf_bound_rect(r, br->width, br->height);\r\n} while (++i != R_INVALID);\r\n*v = *rects[first];\r\n}\r\nstatic bool s5k5baf_cmp_rect(const struct v4l2_rect *r1,\r\nconst struct v4l2_rect *r2)\r\n{\r\nreturn !memcmp(r1, r2, sizeof(*r1));\r\n}\r\nstatic int s5k5baf_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstatic enum selection_rect rtype;\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nstruct v4l2_rect **rects;\r\nint ret = 0;\r\nrtype = s5k5baf_get_sel_rect(sel->pad, sel->target);\r\nif (rtype == R_INVALID || s5k5baf_is_bound_target(sel->target))\r\nreturn -EINVAL;\r\nif (rtype == R_COMPOSE) {\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\n}\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nrects = (struct v4l2_rect * []) {\r\n&s5k5baf_cis_rect,\r\nv4l2_subdev_get_try_crop(sd, cfg, PAD_CIS),\r\nv4l2_subdev_get_try_compose(sd, cfg, PAD_CIS),\r\nv4l2_subdev_get_try_crop(sd, cfg, PAD_OUT)\r\n};\r\ns5k5baf_set_rect_and_adjust(rects, rtype, &sel->r);\r\nreturn 0;\r\n}\r\nrects = (struct v4l2_rect * []) {\r\n&s5k5baf_cis_rect,\r\n&state->crop_sink,\r\n&state->compose,\r\n&state->crop_source\r\n};\r\nmutex_lock(&state->lock);\r\nif (state->streaming) {\r\nif (rtype < R_CROP_SOURCE) {\r\nif (sel->r.width < state->crop_source.width)\r\nsel->r.width = state->crop_source.width;\r\nif (sel->r.height < state->crop_source.height)\r\nsel->r.height = state->crop_source.height;\r\n} else {\r\nsel->r.width = state->crop_source.width;\r\nsel->r.height = state->crop_source.height;\r\n}\r\n}\r\ns5k5baf_set_rect_and_adjust(rects, rtype, &sel->r);\r\nif (!s5k5baf_cmp_rect(&state->crop_sink, &s5k5baf_cis_rect) ||\r\n!s5k5baf_cmp_rect(&state->compose, &s5k5baf_cis_rect))\r\nstate->apply_crop = 1;\r\nif (state->streaming)\r\nret = s5k5baf_hw_set_crop_rects(state);\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = ctrl_to_sd(ctrl);\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nint ret;\r\nv4l2_dbg(1, debug, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);\r\nmutex_lock(&state->lock);\r\nif (state->power == 0)\r\ngoto unlock;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\ns5k5baf_hw_set_awb(state, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_BRIGHTNESS:\r\ns5k5baf_write(state, REG_USER_BRIGHTNESS, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_COLORFX:\r\ns5k5baf_hw_set_colorfx(state, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ns5k5baf_write(state, REG_USER_CONTRAST, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\ns5k5baf_hw_set_auto_exposure(state, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\ns5k5baf_hw_set_mirror(state);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\ns5k5baf_hw_set_anti_flicker(state, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ns5k5baf_write(state, REG_USER_SATURATION, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\ns5k5baf_write(state, REG_USER_SHARPBLUR, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_WHITE_BALANCE_TEMPERATURE:\r\ns5k5baf_write(state, REG_P_COLORTEMP(0), ctrl->val);\r\nif (state->apply_cfg)\r\ns5k5baf_hw_sync_cfg(state);\r\nbreak;\r\ncase V4L2_CID_TEST_PATTERN:\r\ns5k5baf_hw_set_test_pattern(state, ctrl->val);\r\nbreak;\r\n}\r\nunlock:\r\nret = s5k5baf_clear_error(state);\r\nmutex_unlock(&state->lock);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_initialize_ctrls(struct s5k5baf *state)\r\n{\r\nconst struct v4l2_ctrl_ops *ops = &s5k5baf_ctrl_ops;\r\nstruct s5k5baf_ctrls *ctrls = &state->ctrls;\r\nstruct v4l2_ctrl_handler *hdl = &ctrls->handler;\r\nint ret;\r\nret = v4l2_ctrl_handler_init(hdl, 16);\r\nif (ret < 0) {\r\nv4l2_err(&state->sd, "cannot init ctrl handler (%d)\n", ret);\r\nreturn ret;\r\n}\r\nctrls->awb = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTO_WHITE_BALANCE,\r\n0, 1, 1, 1);\r\nctrls->gain_red = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,\r\n0, 255, 1, S5K5BAF_GAIN_RED_DEF);\r\nctrls->gain_blue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,\r\n0, 255, 1, S5K5BAF_GAIN_BLUE_DEF);\r\nv4l2_ctrl_auto_cluster(3, &ctrls->awb, 0, false);\r\nctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP, 0, 1, 1, 0);\r\nctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_cluster(2, &ctrls->hflip);\r\nctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,\r\nV4L2_CID_EXPOSURE_AUTO,\r\nV4L2_EXPOSURE_MANUAL, 0, V4L2_EXPOSURE_AUTO);\r\nctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,\r\n0, 6000000U, 1, 100000U);\r\nctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,\r\n0, 256, 1, 256);\r\nv4l2_ctrl_auto_cluster(3, &ctrls->auto_exp, 0, false);\r\nv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,\r\nV4L2_CID_POWER_LINE_FREQUENCY_AUTO);\r\nv4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_COLORFX,\r\nV4L2_COLORFX_SKY_BLUE, ~0x6f, V4L2_COLORFX_NONE);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_WHITE_BALANCE_TEMPERATURE,\r\n0, 256, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_BRIGHTNESS, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, ops, V4L2_CID_SHARPNESS, -127, 127, 1, 0);\r\nv4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(s5k5baf_test_pattern_menu) - 1,\r\n0, 0, s5k5baf_test_pattern_menu);\r\nif (hdl->error) {\r\nv4l2_err(&state->sd, "error creating controls (%d)\n",\r\nhdl->error);\r\nret = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn ret;\r\n}\r\nstate->sd.ctrl_handler = hdl;\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, PAD_CIS);\r\ns5k5baf_try_cis_format(mf);\r\nif (s5k5baf_is_cis_subdev(sd))\r\nreturn 0;\r\nmf = v4l2_subdev_get_try_format(sd, fh->pad, PAD_OUT);\r\nmf->colorspace = s5k5baf_formats[0].colorspace;\r\nmf->code = s5k5baf_formats[0].code;\r\nmf->width = s5k5baf_cis_rect.width;\r\nmf->height = s5k5baf_cis_rect.height;\r\nmf->field = V4L2_FIELD_NONE;\r\n*v4l2_subdev_get_try_crop(sd, fh->pad, PAD_CIS) = s5k5baf_cis_rect;\r\n*v4l2_subdev_get_try_compose(sd, fh->pad, PAD_CIS) = s5k5baf_cis_rect;\r\n*v4l2_subdev_get_try_crop(sd, fh->pad, PAD_OUT) = s5k5baf_cis_rect;\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_check_fw_revision(struct s5k5baf *state)\r\n{\r\nu16 api_ver = 0, fw_rev = 0, s_id = 0;\r\nint ret;\r\napi_ver = s5k5baf_read(state, REG_FW_APIVER);\r\nfw_rev = s5k5baf_read(state, REG_FW_REVISION) & 0xff;\r\ns_id = s5k5baf_read(state, REG_FW_SENSOR_ID);\r\nret = s5k5baf_clear_error(state);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_info(&state->sd, "FW API=%#x, revision=%#x sensor_id=%#x\n",\r\napi_ver, fw_rev, s_id);\r\nif (api_ver != S5K5BAF_FW_APIVER) {\r\nv4l2_err(&state->sd, "FW API version not supported\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nint ret;\r\nret = v4l2_device_register_subdev(sd->v4l2_dev, &state->cis_sd);\r\nif (ret < 0)\r\nv4l2_err(sd, "failed to register subdev %s\n",\r\nstate->cis_sd.name);\r\nelse\r\nret = media_entity_create_link(&state->cis_sd.entity, PAD_CIS,\r\n&state->sd.entity, PAD_CIS,\r\nMEDIA_LNK_FL_IMMUTABLE |\r\nMEDIA_LNK_FL_ENABLED);\r\nreturn ret;\r\n}\r\nstatic void s5k5baf_unregistered(struct v4l2_subdev *sd)\r\n{\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nv4l2_device_unregister_subdev(&state->cis_sd);\r\n}\r\nstatic int s5k5baf_configure_gpios(struct s5k5baf *state)\r\n{\r\nstatic const char * const name[] = { "S5K5BAF_STBY", "S5K5BAF_RST" };\r\nstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\r\nstruct s5k5baf_gpio *g = state->gpios;\r\nint ret, i;\r\nfor (i = 0; i < NUM_GPIOS; ++i) {\r\nint flags = GPIOF_DIR_OUT;\r\nif (g[i].level)\r\nflags |= GPIOF_INIT_HIGH;\r\nret = devm_gpio_request_one(&c->dev, g[i].gpio, flags, name[i]);\r\nif (ret < 0) {\r\nv4l2_err(c, "failed to request gpio %s\n", name[i]);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_parse_gpios(struct s5k5baf_gpio *gpios, struct device *dev)\r\n{\r\nstatic const char * const names[] = {\r\n"stbyn-gpios",\r\n"rstn-gpios",\r\n};\r\nstruct device_node *node = dev->of_node;\r\nenum of_gpio_flags flags;\r\nint ret, i;\r\nfor (i = 0; i < NUM_GPIOS; ++i) {\r\nret = of_get_named_gpio_flags(node, names[i], 0, &flags);\r\nif (ret < 0) {\r\ndev_err(dev, "no %s GPIO pin provided\n", names[i]);\r\nreturn ret;\r\n}\r\ngpios[i].gpio = ret;\r\ngpios[i].level = !(flags & OF_GPIO_ACTIVE_LOW);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_parse_device_node(struct s5k5baf *state, struct device *dev)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *node_ep;\r\nstruct v4l2_of_endpoint ep;\r\nint ret;\r\nif (!node) {\r\ndev_err(dev, "no device-tree node provided\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(node, "clock-frequency",\r\n&state->mclk_frequency);\r\nif (ret < 0) {\r\nstate->mclk_frequency = S5K5BAF_DEFAULT_MCLK_FREQ;\r\ndev_info(dev, "using default %u Hz clock frequency\n",\r\nstate->mclk_frequency);\r\n}\r\nret = s5k5baf_parse_gpios(state->gpios, dev);\r\nif (ret < 0)\r\nreturn ret;\r\nnode_ep = of_graph_get_next_endpoint(node, NULL);\r\nif (!node_ep) {\r\ndev_err(dev, "no endpoint defined at node %s\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nv4l2_of_parse_endpoint(node_ep, &ep);\r\nof_node_put(node_ep);\r\nstate->bus_type = ep.bus_type;\r\nswitch (state->bus_type) {\r\ncase V4L2_MBUS_CSI2:\r\nstate->nlanes = ep.bus.mipi_csi2.num_data_lanes;\r\nbreak;\r\ncase V4L2_MBUS_PARALLEL:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported bus in endpoint defined at node %s\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5k5baf_configure_subdevs(struct s5k5baf *state,\r\nstruct i2c_client *c)\r\n{\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\nsd = &state->cis_sd;\r\nv4l2_subdev_init(sd, &s5k5baf_cis_subdev_ops);\r\nsd->owner = THIS_MODULE;\r\nv4l2_set_subdevdata(sd, state);\r\nsnprintf(sd->name, sizeof(sd->name), "S5K5BAF-CIS %d-%04x",\r\ni2c_adapter_id(c->adapter), c->addr);\r\nsd->internal_ops = &s5k5baf_cis_subdev_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstate->cis_pad.flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\nret = media_entity_init(&sd->entity, NUM_CIS_PADS, &state->cis_pad, 0);\r\nif (ret < 0)\r\ngoto err;\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, c, &s5k5baf_subdev_ops);\r\nsnprintf(sd->name, sizeof(sd->name), "S5K5BAF-ISP %d-%04x",\r\ni2c_adapter_id(c->adapter), c->addr);\r\nsd->internal_ops = &s5k5baf_subdev_internal_ops;\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstate->pads[PAD_CIS].flags = MEDIA_PAD_FL_SINK;\r\nstate->pads[PAD_OUT].flags = MEDIA_PAD_FL_SOURCE;\r\nsd->entity.type = MEDIA_ENT_T_V4L2_SUBDEV;\r\nret = media_entity_init(&sd->entity, NUM_ISP_PADS, state->pads, 0);\r\nif (!ret)\r\nreturn 0;\r\nmedia_entity_cleanup(&state->cis_sd.entity);\r\nerr:\r\ndev_err(&c->dev, "cannot init media entity %s\n", sd->name);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_configure_regulators(struct s5k5baf *state)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(&state->sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < S5K5BAF_NUM_SUPPLIES; i++)\r\nstate->supplies[i].supply = s5k5baf_supply_names[i];\r\nret = devm_regulator_bulk_get(&c->dev, S5K5BAF_NUM_SUPPLIES,\r\nstate->supplies);\r\nif (ret < 0)\r\nv4l2_err(c, "failed to get regulators\n");\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_probe(struct i2c_client *c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct s5k5baf *state;\r\nint ret;\r\nstate = devm_kzalloc(&c->dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nmutex_init(&state->lock);\r\nstate->crop_sink = s5k5baf_cis_rect;\r\nstate->compose = s5k5baf_cis_rect;\r\nstate->crop_source = s5k5baf_cis_rect;\r\nret = s5k5baf_parse_device_node(state, &c->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5k5baf_configure_subdevs(state, c);\r\nif (ret < 0)\r\nreturn ret;\r\nret = s5k5baf_configure_gpios(state);\r\nif (ret < 0)\r\ngoto err_me;\r\nret = s5k5baf_configure_regulators(state);\r\nif (ret < 0)\r\ngoto err_me;\r\nstate->clock = devm_clk_get(state->sd.dev, S5K5BAF_CLK_NAME);\r\nif (IS_ERR(state->clock)) {\r\nret = -EPROBE_DEFER;\r\ngoto err_me;\r\n}\r\nret = s5k5baf_power_on(state);\r\nif (ret < 0) {\r\nret = -EPROBE_DEFER;\r\ngoto err_me;\r\n}\r\ns5k5baf_hw_init(state);\r\nret = s5k5baf_check_fw_revision(state);\r\ns5k5baf_power_off(state);\r\nif (ret < 0)\r\ngoto err_me;\r\nret = s5k5baf_initialize_ctrls(state);\r\nif (ret < 0)\r\ngoto err_me;\r\nret = v4l2_async_register_subdev(&state->sd);\r\nif (ret < 0)\r\ngoto err_ctrl;\r\nreturn 0;\r\nerr_ctrl:\r\nv4l2_ctrl_handler_free(state->sd.ctrl_handler);\r\nerr_me:\r\nmedia_entity_cleanup(&state->sd.entity);\r\nmedia_entity_cleanup(&state->cis_sd.entity);\r\nreturn ret;\r\n}\r\nstatic int s5k5baf_remove(struct i2c_client *c)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(c);\r\nstruct s5k5baf *state = to_s5k5baf(sd);\r\nv4l2_async_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nmedia_entity_cleanup(&sd->entity);\r\nsd = &state->cis_sd;\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn 0;\r\n}
