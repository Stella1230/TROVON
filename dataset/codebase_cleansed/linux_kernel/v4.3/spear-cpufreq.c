static struct clk *spear1340_cpu_get_possible_parent(unsigned long newfreq)\r\n{\r\nstruct clk *sys_pclk;\r\nint pclk;\r\nconst char *sys_clk_src[] = {\r\n"sys_syn_clk",\r\n"pll1_clk",\r\n"pll2_clk",\r\n"pll3_clk",\r\n};\r\nif (newfreq <= 300000000)\r\npclk = 0;\r\nelse if (newfreq > 300000000 && newfreq <= 500000000)\r\npclk = 3;\r\nelse if (newfreq == 600000000)\r\npclk = 1;\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\nsys_pclk = clk_get(NULL, sys_clk_src[pclk]);\r\nif (IS_ERR(sys_pclk))\r\npr_err("Failed to get %s clock\n", sys_clk_src[pclk]);\r\nreturn sys_pclk;\r\n}\r\nstatic int spear1340_set_cpu_rate(struct clk *sys_pclk, unsigned long newfreq)\r\n{\r\nstruct clk *sys_clk;\r\nint ret = 0;\r\nsys_clk = clk_get_parent(spear_cpufreq.clk);\r\nif (IS_ERR(sys_clk)) {\r\npr_err("failed to get cpu's parent (sys) clock\n");\r\nreturn PTR_ERR(sys_clk);\r\n}\r\nret = clk_set_rate(sys_pclk, newfreq);\r\nif (ret) {\r\npr_err("Failed to set sys clk rate to %lu\n", newfreq);\r\nreturn ret;\r\n}\r\nret = clk_set_parent(sys_clk, sys_pclk);\r\nif (ret) {\r\npr_err("Failed to set sys clk parent\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spear_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nlong newfreq;\r\nstruct clk *srcclk;\r\nint ret, mult = 1;\r\nnewfreq = spear_cpufreq.freq_tbl[index].frequency * 1000;\r\nif (of_machine_is_compatible("st,spear1340")) {\r\nsrcclk = spear1340_cpu_get_possible_parent(newfreq);\r\nif (IS_ERR(srcclk)) {\r\npr_err("Failed to get src clk\n");\r\nreturn PTR_ERR(srcclk);\r\n}\r\nmult = 2;\r\n} else {\r\nsrcclk = spear_cpufreq.clk;\r\n}\r\nnewfreq = clk_round_rate(srcclk, newfreq * mult);\r\nif (newfreq <= 0) {\r\npr_err("clk_round_rate failed for cpu src clock\n");\r\nreturn newfreq;\r\n}\r\nif (mult == 2)\r\nret = spear1340_set_cpu_rate(srcclk, newfreq);\r\nelse\r\nret = clk_set_rate(spear_cpufreq.clk, newfreq);\r\nif (ret)\r\npr_err("CPU Freq: cpu clk_set_rate failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int spear_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->clk = spear_cpufreq.clk;\r\nreturn cpufreq_generic_init(policy, spear_cpufreq.freq_tbl,\r\nspear_cpufreq.transition_latency);\r\n}\r\nstatic int spear_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np;\r\nconst struct property *prop;\r\nstruct cpufreq_frequency_table *freq_tbl;\r\nconst __be32 *val;\r\nint cnt, i, ret;\r\nnp = of_cpu_device_node_get(0);\r\nif (!np) {\r\npr_err("No cpu node found");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(np, "clock-latency",\r\n&spear_cpufreq.transition_latency))\r\nspear_cpufreq.transition_latency = CPUFREQ_ETERNAL;\r\nprop = of_find_property(np, "cpufreq_tbl", NULL);\r\nif (!prop || !prop->value) {\r\npr_err("Invalid cpufreq_tbl");\r\nret = -ENODEV;\r\ngoto out_put_node;\r\n}\r\ncnt = prop->length / sizeof(u32);\r\nval = prop->value;\r\nfreq_tbl = kzalloc(sizeof(*freq_tbl) * (cnt + 1), GFP_KERNEL);\r\nif (!freq_tbl) {\r\nret = -ENOMEM;\r\ngoto out_put_node;\r\n}\r\nfor (i = 0; i < cnt; i++)\r\nfreq_tbl[i].frequency = be32_to_cpup(val++);\r\nfreq_tbl[i].frequency = CPUFREQ_TABLE_END;\r\nspear_cpufreq.freq_tbl = freq_tbl;\r\nof_node_put(np);\r\nspear_cpufreq.clk = clk_get(NULL, "cpu_clk");\r\nif (IS_ERR(spear_cpufreq.clk)) {\r\npr_err("Unable to get CPU clock\n");\r\nret = PTR_ERR(spear_cpufreq.clk);\r\ngoto out_put_mem;\r\n}\r\nret = cpufreq_register_driver(&spear_cpufreq_driver);\r\nif (!ret)\r\nreturn 0;\r\npr_err("failed register driver: %d\n", ret);\r\nclk_put(spear_cpufreq.clk);\r\nout_put_mem:\r\nkfree(freq_tbl);\r\nreturn ret;\r\nout_put_node:\r\nof_node_put(np);\r\nreturn ret;\r\n}
