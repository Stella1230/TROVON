static int vvp_object_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\nstruct ccc_object *obj = lu2ccc(o);\r\nstruct inode *inode = obj->cob_inode;\r\nstruct ll_inode_info *lli;\r\n(*p)(env, cookie, "(%s %d %d) inode: %p ",\r\nlist_empty(&obj->cob_pending_list) ? "-" : "+",\r\nobj->cob_transient_pages, atomic_read(&obj->cob_mmap_cnt),\r\ninode);\r\nif (inode) {\r\nlli = ll_i2info(inode);\r\n(*p)(env, cookie, "%lu/%u %o %u %d %p "DFID,\r\ninode->i_ino, inode->i_generation, inode->i_mode,\r\ninode->i_nlink, atomic_read(&inode->i_count),\r\nlli->lli_clob, PFID(&lli->lli_fid));\r\n}\r\nreturn 0;\r\n}\r\nstatic int vvp_attr_get(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nstruct inode *inode = ccc_object_inode(obj);\r\nattr->cat_size = i_size_read(inode);\r\nattr->cat_mtime = LTIME_S(inode->i_mtime);\r\nattr->cat_atime = LTIME_S(inode->i_atime);\r\nattr->cat_ctime = LTIME_S(inode->i_ctime);\r\nattr->cat_blocks = inode->i_blocks;\r\nattr->cat_uid = from_kuid(&init_user_ns, inode->i_uid);\r\nattr->cat_gid = from_kgid(&init_user_ns, inode->i_gid);\r\nreturn 0;\r\n}\r\nstatic int vvp_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_attr *attr, unsigned valid)\r\n{\r\nstruct inode *inode = ccc_object_inode(obj);\r\nif (valid & CAT_UID)\r\ninode->i_uid = make_kuid(&init_user_ns, attr->cat_uid);\r\nif (valid & CAT_GID)\r\ninode->i_gid = make_kgid(&init_user_ns, attr->cat_gid);\r\nif (valid & CAT_ATIME)\r\nLTIME_S(inode->i_atime) = attr->cat_atime;\r\nif (valid & CAT_MTIME)\r\nLTIME_S(inode->i_mtime) = attr->cat_mtime;\r\nif (valid & CAT_CTIME)\r\nLTIME_S(inode->i_ctime) = attr->cat_ctime;\r\nif (0 && valid & CAT_SIZE)\r\ncl_isize_write_nolock(inode, attr->cat_size);\r\nif (0 && valid & (CAT_UID|CAT_GID|CAT_SIZE))\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic int vvp_conf_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_object_conf *conf)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(conf->coc_inode);\r\nif (conf->coc_opc == OBJECT_CONF_INVALIDATE) {\r\nCDEBUG(D_VFSTRACE, DFID ": losing layout lock\n",\r\nPFID(&lli->lli_fid));\r\nll_layout_version_set(lli, LL_LAYOUT_GEN_NONE);\r\nunmap_mapping_range(conf->coc_inode->i_mapping,\r\n0, OBD_OBJECT_EOF, 0);\r\nreturn 0;\r\n}\r\nif (conf->coc_opc != OBJECT_CONF_SET)\r\nreturn 0;\r\nif (conf->u.coc_md != NULL && conf->u.coc_md->lsm != NULL) {\r\nCDEBUG(D_VFSTRACE, DFID ": layout version change: %u -> %u\n",\r\nPFID(&lli->lli_fid), lli->lli_layout_gen,\r\nconf->u.coc_md->lsm->lsm_layout_gen);\r\nlli->lli_has_smd = lsm_has_objects(conf->u.coc_md->lsm);\r\nll_layout_version_set(lli, conf->u.coc_md->lsm->lsm_layout_gen);\r\n} else {\r\nCDEBUG(D_VFSTRACE, DFID ": layout nuked: %u.\n",\r\nPFID(&lli->lli_fid), lli->lli_layout_gen);\r\nlli->lli_has_smd = false;\r\nll_layout_version_set(lli, LL_LAYOUT_GEN_EMPTY);\r\n}\r\nreturn 0;\r\n}\r\nstruct ccc_object *cl_inode2ccc(struct inode *inode)\r\n{\r\nstruct cl_inode_info *lli = cl_i2info(inode);\r\nstruct cl_object *obj = lli->lli_clob;\r\nstruct lu_object *lu;\r\nLASSERT(obj != NULL);\r\nlu = lu_object_locate(obj->co_lu.lo_header, &vvp_device_type);\r\nLASSERT(lu != NULL);\r\nreturn lu2ccc(lu);\r\n}\r\nstruct lu_object *vvp_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *hdr,\r\nstruct lu_device *dev)\r\n{\r\nreturn ccc_object_alloc(env, hdr, dev, &vvp_ops, &vvp_lu_obj_ops);\r\n}
