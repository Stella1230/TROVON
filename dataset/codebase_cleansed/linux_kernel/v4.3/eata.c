static int eata2x_slave_configure(struct scsi_device *dev)\r\n{\r\nint tqd, utqd;\r\nchar *tag_suffix, *link_suffix;\r\nutqd = MAX_CMD_PER_LUN;\r\ntqd = max_queue_depth;\r\nif (TLDEV(dev->type) && dev->tagged_supported) {\r\nif (tag_mode == TAG_SIMPLE) {\r\ntag_suffix = ", simple tags";\r\n} else if (tag_mode == TAG_ORDERED) {\r\ntag_suffix = ", ordered tags";\r\n} else {\r\ntag_suffix = ", no tags";\r\n}\r\nscsi_change_queue_depth(dev, tqd);\r\n} else if (TLDEV(dev->type) && linked_comm) {\r\nscsi_change_queue_depth(dev, tqd);\r\ntag_suffix = ", untagged";\r\n} else {\r\nscsi_change_queue_depth(dev, utqd);\r\ntag_suffix = "";\r\n}\r\nif (TLDEV(dev->type) && linked_comm && dev->queue_depth > 2)\r\nlink_suffix = ", sorted";\r\nelse if (TLDEV(dev->type))\r\nlink_suffix = ", unsorted";\r\nelse\r\nlink_suffix = "";\r\nsdev_printk(KERN_INFO, dev,\r\n"cmds/lun %d%s%s.\n",\r\ndev->queue_depth, link_suffix, tag_suffix);\r\nreturn 0;\r\n}\r\nstatic int wait_on_busy(unsigned long iobase, unsigned int loop)\r\n{\r\nwhile (inb(iobase + REG_AUX_STATUS) & ABSY_ASSERTED) {\r\nudelay(1L);\r\nif (--loop == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_dma(unsigned long iobase, unsigned long addr, unchar cmd)\r\n{\r\nunsigned char *byaddr;\r\nunsigned long devaddr;\r\nif (wait_on_busy(iobase, (addr ? MAXLOOP * 100 : MAXLOOP)))\r\nreturn 1;\r\nif (addr) {\r\ndevaddr = H2DEV(addr);\r\nbyaddr = (unsigned char *)&devaddr;\r\noutb(byaddr[3], iobase + REG_LOW);\r\noutb(byaddr[2], iobase + REG_LM);\r\noutb(byaddr[1], iobase + REG_MID);\r\noutb(byaddr[0], iobase + REG_MSB);\r\n}\r\noutb(cmd, iobase + REG_CMD);\r\nreturn 0;\r\n}\r\nstatic int read_pio(unsigned long iobase, ushort * start, ushort * end)\r\n{\r\nunsigned int loop = MAXLOOP;\r\nushort *p;\r\nfor (p = start; p <= end; p++) {\r\nwhile (!(inb(iobase + REG_STATUS) & DRQ_ASSERTED)) {\r\nudelay(1L);\r\nif (--loop == 0)\r\nreturn 1;\r\n}\r\nloop = MAXLOOP;\r\n*p = REG2H(inw(iobase));\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *get_pci_dev(unsigned long port_base)\r\n{\r\n#if defined(CONFIG_PCI)\r\nunsigned int addr;\r\nstruct pci_dev *dev = NULL;\r\nwhile ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {\r\naddr = pci_resource_start(dev, 0);\r\n#if defined(DEBUG_PCI_DETECT)\r\nprintk("%s: get_pci_dev, bus %d, devfn 0x%x, addr 0x%x.\n",\r\ndriver_name, dev->bus->number, dev->devfn, addr);\r\n#endif\r\npci_dev_put(dev);\r\nif (addr + PCI_BASE_ADDRESS_0 == port_base)\r\nreturn dev;\r\n}\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic void enable_pci_ports(void)\r\n{\r\n#if defined(CONFIG_PCI)\r\nstruct pci_dev *dev = NULL;\r\nwhile ((dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev))) {\r\n#if defined(DEBUG_PCI_DETECT)\r\nprintk("%s: enable_pci_ports, bus %d, devfn 0x%x.\n",\r\ndriver_name, dev->bus->number, dev->devfn);\r\n#endif\r\nif (pci_enable_device(dev))\r\nprintk\r\n("%s: warning, pci_enable_device failed, bus %d devfn 0x%x.\n",\r\ndriver_name, dev->bus->number, dev->devfn);\r\n}\r\n#endif\r\n}\r\nstatic int port_detect(unsigned long port_base, unsigned int j,\r\nstruct scsi_host_template *tpnt)\r\n{\r\nunsigned char irq, dma_channel, subversion, i, is_pci = 0;\r\nunsigned char protocol_rev;\r\nstruct eata_info info;\r\nchar *bus_type, dma_name[16];\r\nstruct pci_dev *pdev;\r\nunsigned char dma_channel_table[4] = { 5, 6, 7, 0 };\r\nstruct Scsi_Host *shost;\r\nstruct hostdata *ha;\r\nchar name[16];\r\nsprintf(name, "%s%d", driver_name, j);\r\nif (!request_region(port_base, REGION_SIZE, driver_name)) {\r\n#if defined(DEBUG_DETECT)\r\nprintk("%s: address 0x%03lx in use, skipping probe.\n", name,\r\nport_base);\r\n#endif\r\ngoto fail;\r\n}\r\nif (do_dma(port_base, 0, READ_CONFIG_PIO)) {\r\n#if defined(DEBUG_DETECT)\r\nprintk("%s: detect, do_dma failed at 0x%03lx.\n", name,\r\nport_base);\r\n#endif\r\ngoto freelock;\r\n}\r\nif (read_pio(port_base, (ushort *) & info, (ushort *) & info.ipad[0])) {\r\n#if defined(DEBUG_DETECT)\r\nprintk("%s: detect, read_pio failed at 0x%03lx.\n", name,\r\nport_base);\r\n#endif\r\ngoto freelock;\r\n}\r\ninfo.data_len = DEV2H(info.data_len);\r\ninfo.sign = DEV2H(info.sign);\r\ninfo.cp_pad_len = DEV2H16(info.cp_pad_len);\r\ninfo.cp_len = DEV2H(info.cp_len);\r\ninfo.sp_len = DEV2H(info.sp_len);\r\ninfo.scatt_size = DEV2H16(info.scatt_size);\r\ninfo.queue_size = DEV2H16(info.queue_size);\r\nif (info.sign != EATA_SIG_BE) {\r\n#if defined(DEBUG_DETECT)\r\nprintk("%s: signature 0x%04x discarded.\n", name, info.sign);\r\n#endif\r\ngoto freelock;\r\n}\r\nif (info.data_len < EATA_2_0A_SIZE) {\r\nprintk\r\n("%s: config structure size (%d bytes) too short, detaching.\n",\r\nname, info.data_len);\r\ngoto freelock;\r\n} else if (info.data_len == EATA_2_0A_SIZE)\r\nprotocol_rev = 'A';\r\nelse if (info.data_len == EATA_2_0B_SIZE)\r\nprotocol_rev = 'B';\r\nelse\r\nprotocol_rev = 'C';\r\nif (protocol_rev != 'A' && info.forcaddr) {\r\nprintk("%s: warning, port address has been forced.\n", name);\r\nbus_type = "PCI";\r\nis_pci = 1;\r\nsubversion = ESA;\r\n} else if (port_base > MAX_EISA_ADDR\r\n|| (protocol_rev == 'C' && info.pci)) {\r\nbus_type = "PCI";\r\nis_pci = 1;\r\nsubversion = ESA;\r\n} else if (port_base >= MIN_EISA_ADDR\r\n|| (protocol_rev == 'C' && info.eisa)) {\r\nbus_type = "EISA";\r\nsubversion = ESA;\r\n} else if (protocol_rev == 'C' && !info.eisa && !info.pci) {\r\nbus_type = "ISA";\r\nsubversion = ISA;\r\n} else if (port_base > MAX_ISA_ADDR) {\r\nbus_type = "PCI";\r\nis_pci = 1;\r\nsubversion = ESA;\r\n} else {\r\nbus_type = "ISA";\r\nsubversion = ISA;\r\n}\r\nif (!info.haaval || info.ata) {\r\nprintk\r\n("%s: address 0x%03lx, unusable %s board (%d%d), detaching.\n",\r\nname, port_base, bus_type, info.haaval, info.ata);\r\ngoto freelock;\r\n}\r\nif (info.drqvld) {\r\nif (subversion == ESA)\r\nprintk("%s: warning, weird %s board using DMA.\n", name,\r\nbus_type);\r\nsubversion = ISA;\r\ndma_channel = dma_channel_table[3 - info.drqx];\r\n} else {\r\nif (subversion == ISA)\r\nprintk("%s: warning, weird %s board not using DMA.\n",\r\nname, bus_type);\r\nsubversion = ESA;\r\ndma_channel = NO_DMA;\r\n}\r\nif (!info.dmasup)\r\nprintk("%s: warning, DMA protocol support not asserted.\n",\r\nname);\r\nirq = info.irq;\r\nif (subversion == ESA && !info.irq_tr)\r\nprintk\r\n("%s: warning, LEVEL triggering is suggested for IRQ %u.\n",\r\nname, irq);\r\nif (is_pci) {\r\npdev = get_pci_dev(port_base);\r\nif (!pdev)\r\nprintk\r\n("%s: warning, failed to get pci_dev structure.\n",\r\nname);\r\n} else\r\npdev = NULL;\r\nif (pdev && (irq != pdev->irq)) {\r\nprintk("%s: IRQ %u mapped to IO-APIC IRQ %u.\n", name, irq,\r\npdev->irq);\r\nirq = pdev->irq;\r\n}\r\nif (request_irq(irq, do_interrupt_handler,\r\n(subversion == ESA) ? IRQF_SHARED : 0,\r\ndriver_name, (void *)&sha[j])) {\r\nprintk("%s: unable to allocate IRQ %u, detaching.\n", name,\r\nirq);\r\ngoto freelock;\r\n}\r\nif (subversion == ISA && request_dma(dma_channel, driver_name)) {\r\nprintk("%s: unable to allocate DMA channel %u, detaching.\n",\r\nname, dma_channel);\r\ngoto freeirq;\r\n}\r\n#if defined(FORCE_CONFIG)\r\n{\r\nstruct eata_config *cf;\r\ndma_addr_t cf_dma_addr;\r\ncf = pci_zalloc_consistent(pdev, sizeof(struct eata_config),\r\n&cf_dma_addr);\r\nif (!cf) {\r\nprintk\r\n("%s: config, pci_alloc_consistent failed, detaching.\n",\r\nname);\r\ngoto freedma;\r\n}\r\ncf->len = (ushort) H2DEV16((ushort) 510);\r\ncf->ocena = 1;\r\nif (do_dma(port_base, cf_dma_addr, SET_CONFIG_DMA)) {\r\nprintk\r\n("%s: busy timeout sending configuration, detaching.\n",\r\nname);\r\npci_free_consistent(pdev, sizeof(struct eata_config),\r\ncf, cf_dma_addr);\r\ngoto freedma;\r\n}\r\n}\r\n#endif\r\nsh[j] = shost = scsi_register(tpnt, sizeof(struct hostdata));\r\nif (shost == NULL) {\r\nprintk("%s: unable to register host, detaching.\n", name);\r\ngoto freedma;\r\n}\r\nshost->io_port = port_base;\r\nshost->unique_id = port_base;\r\nshost->n_io_port = REGION_SIZE;\r\nshost->dma_channel = dma_channel;\r\nshost->irq = irq;\r\nshost->sg_tablesize = (ushort) info.scatt_size;\r\nshost->this_id = (ushort) info.host_addr[3];\r\nshost->can_queue = (ushort) info.queue_size;\r\nshost->cmd_per_lun = MAX_CMD_PER_LUN;\r\nha = (struct hostdata *)shost->hostdata;\r\nmemset(ha, 0, sizeof(struct hostdata));\r\nha->subversion = subversion;\r\nha->protocol_rev = protocol_rev;\r\nha->is_pci = is_pci;\r\nha->pdev = pdev;\r\nha->board_number = j;\r\nif (ha->subversion == ESA)\r\nshost->unchecked_isa_dma = 0;\r\nelse {\r\nunsigned long flags;\r\nshost->unchecked_isa_dma = 1;\r\nflags = claim_dma_lock();\r\ndisable_dma(dma_channel);\r\nclear_dma_ff(dma_channel);\r\nset_dma_mode(dma_channel, DMA_MODE_CASCADE);\r\nenable_dma(dma_channel);\r\nrelease_dma_lock(flags);\r\n}\r\nstrcpy(ha->board_name, name);\r\nif (shost->sg_tablesize > MAX_SGLIST || shost->sg_tablesize < 2) {\r\nprintk("%s: detect, wrong n. of SG lists %d, fixed.\n",\r\nha->board_name, shost->sg_tablesize);\r\nshost->sg_tablesize = MAX_SGLIST;\r\n}\r\nif (shost->can_queue > MAX_MAILBOXES || shost->can_queue < 2) {\r\nprintk("%s: detect, wrong n. of mbox %d, fixed.\n",\r\nha->board_name, shost->can_queue);\r\nshost->can_queue = MAX_MAILBOXES;\r\n}\r\nif (protocol_rev != 'A') {\r\nif (info.max_chan > 0 && info.max_chan < MAX_CHANNEL)\r\nshost->max_channel = info.max_chan;\r\nif (info.max_id > 7 && info.max_id < MAX_TARGET)\r\nshost->max_id = info.max_id + 1;\r\nif (info.large_sg && shost->sg_tablesize == MAX_SGLIST)\r\nshost->sg_tablesize = MAX_LARGE_SGLIST;\r\n}\r\nif (protocol_rev == 'C') {\r\nif (info.max_lun > 7 && info.max_lun < MAX_LUN)\r\nshost->max_lun = info.max_lun + 1;\r\n}\r\nif (dma_channel == NO_DMA)\r\nsprintf(dma_name, "%s", "BMST");\r\nelse\r\nsprintf(dma_name, "DMA %u", dma_channel);\r\nfor (i = 0; i < shost->can_queue; i++)\r\nha->cp[i].cp_dma_addr = pci_map_single(ha->pdev,\r\n&ha->cp[i],\r\nsizeof(struct mscp),\r\nPCI_DMA_BIDIRECTIONAL);\r\nfor (i = 0; i < shost->can_queue; i++) {\r\nsize_t sz = shost->sg_tablesize *sizeof(struct sg_list);\r\ngfp_t gfp_mask = (shost->unchecked_isa_dma ? GFP_DMA : 0) | GFP_ATOMIC;\r\nha->cp[i].sglist = kmalloc(sz, gfp_mask);\r\nif (!ha->cp[i].sglist) {\r\nprintk\r\n("%s: kmalloc SGlist failed, mbox %d, detaching.\n",\r\nha->board_name, i);\r\ngoto release;\r\n}\r\n}\r\nif (!(ha->sp_cpu_addr = pci_alloc_consistent(ha->pdev,\r\nsizeof(struct mssp),\r\n&ha->sp_dma_addr))) {\r\nprintk("%s: pci_alloc_consistent failed, detaching.\n", ha->board_name);\r\ngoto release;\r\n}\r\nif (max_queue_depth > MAX_TAGGED_CMD_PER_LUN)\r\nmax_queue_depth = MAX_TAGGED_CMD_PER_LUN;\r\nif (max_queue_depth < MAX_CMD_PER_LUN)\r\nmax_queue_depth = MAX_CMD_PER_LUN;\r\nif (tag_mode != TAG_DISABLED && tag_mode != TAG_SIMPLE)\r\ntag_mode = TAG_ORDERED;\r\nif (j == 0) {\r\nprintk\r\n("EATA/DMA 2.0x: Copyright (C) 1994-2003 Dario Ballabio.\n");\r\nprintk\r\n("%s config options -> tm:%d, lc:%c, mq:%d, rs:%c, et:%c, "\r\n"ip:%c, ep:%c, pp:%c.\n", driver_name, tag_mode,\r\nYESNO(linked_comm), max_queue_depth, YESNO(rev_scan),\r\nYESNO(ext_tran), YESNO(isa_probe), YESNO(eisa_probe),\r\nYESNO(pci_probe));\r\n}\r\nprintk("%s: 2.0%c, %s 0x%03lx, IRQ %u, %s, SG %d, MB %d.\n",\r\nha->board_name, ha->protocol_rev, bus_type,\r\n(unsigned long)shost->io_port, shost->irq, dma_name,\r\nshost->sg_tablesize, shost->can_queue);\r\nif (shost->max_id > 8 || shost->max_lun > 8)\r\nprintk\r\n("%s: wide SCSI support enabled, max_id %u, max_lun %llu.\n",\r\nha->board_name, shost->max_id, shost->max_lun);\r\nfor (i = 0; i <= shost->max_channel; i++)\r\nprintk("%s: SCSI channel %u enabled, host target ID %d.\n",\r\nha->board_name, i, info.host_addr[3 - i]);\r\n#if defined(DEBUG_DETECT)\r\nprintk("%s: Vers. 0x%x, ocs %u, tar %u, trnxfr %u, more %u, SYNC 0x%x, "\r\n"sec. %u, infol %d, cpl %d spl %d.\n", name, info.version,\r\ninfo.ocsena, info.tarsup, info.trnxfr, info.morsup, info.sync,\r\ninfo.second, info.data_len, info.cp_len, info.sp_len);\r\nif (protocol_rev == 'B' || protocol_rev == 'C')\r\nprintk("%s: isaena %u, forcaddr %u, max_id %u, max_chan %u, "\r\n"large_sg %u, res1 %u.\n", name, info.isaena,\r\ninfo.forcaddr, info.max_id, info.max_chan, info.large_sg,\r\ninfo.res1);\r\nif (protocol_rev == 'C')\r\nprintk("%s: max_lun %u, m1 %u, idquest %u, pci %u, eisa %u, "\r\n"raidnum %u.\n", name, info.max_lun, info.m1,\r\ninfo.idquest, info.pci, info.eisa, info.raidnum);\r\n#endif\r\nif (ha->pdev) {\r\npci_set_master(ha->pdev);\r\nif (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32)))\r\nprintk("%s: warning, pci_set_dma_mask failed.\n",\r\nha->board_name);\r\n}\r\nreturn 1;\r\nfreedma:\r\nif (subversion == ISA)\r\nfree_dma(dma_channel);\r\nfreeirq:\r\nfree_irq(irq, &sha[j]);\r\nfreelock:\r\nrelease_region(port_base, REGION_SIZE);\r\nfail:\r\nreturn 0;\r\nrelease:\r\neata2x_release(shost);\r\nreturn 0;\r\n}\r\nstatic void internal_setup(char *str, int *ints)\r\n{\r\nint i, argc = ints[0];\r\nchar *cur = str, *pc;\r\nif (argc > 0) {\r\nif (argc > MAX_INT_PARAM)\r\nargc = MAX_INT_PARAM;\r\nfor (i = 0; i < argc; i++)\r\nio_port[i] = ints[i + 1];\r\nio_port[i] = 0;\r\nsetup_done = 1;\r\n}\r\nwhile (cur && (pc = strchr(cur, ':'))) {\r\nint val = 0, c = *++pc;\r\nif (c == 'n' || c == 'N')\r\nval = 0;\r\nelse if (c == 'y' || c == 'Y')\r\nval = 1;\r\nelse\r\nval = (int)simple_strtoul(pc, NULL, 0);\r\nif (!strncmp(cur, "lc:", 3))\r\nlinked_comm = val;\r\nelse if (!strncmp(cur, "tm:", 3))\r\ntag_mode = val;\r\nelse if (!strncmp(cur, "tc:", 3))\r\ntag_mode = val;\r\nelse if (!strncmp(cur, "mq:", 3))\r\nmax_queue_depth = val;\r\nelse if (!strncmp(cur, "ls:", 3))\r\nlink_statistics = val;\r\nelse if (!strncmp(cur, "et:", 3))\r\next_tran = val;\r\nelse if (!strncmp(cur, "rs:", 3))\r\nrev_scan = val;\r\nelse if (!strncmp(cur, "ip:", 3))\r\nisa_probe = val;\r\nelse if (!strncmp(cur, "ep:", 3))\r\neisa_probe = val;\r\nelse if (!strncmp(cur, "pp:", 3))\r\npci_probe = val;\r\nif ((cur = strchr(cur, ',')))\r\n++cur;\r\n}\r\nreturn;\r\n}\r\nstatic int option_setup(char *str)\r\n{\r\nint ints[MAX_INT_PARAM];\r\nchar *cur = str;\r\nint i = 1;\r\nwhile (cur && isdigit(*cur) && i < MAX_INT_PARAM) {\r\nints[i++] = simple_strtoul(cur, NULL, 0);\r\nif ((cur = strchr(cur, ',')) != NULL)\r\ncur++;\r\n}\r\nints[0] = i - 1;\r\ninternal_setup(cur, ints);\r\nreturn 1;\r\n}\r\nstatic void add_pci_ports(void)\r\n{\r\n#if defined(CONFIG_PCI)\r\nunsigned int addr, k;\r\nstruct pci_dev *dev = NULL;\r\nfor (k = 0; k < MAX_PCI; k++) {\r\nif (!(dev = pci_get_class(PCI_CLASS_STORAGE_SCSI << 8, dev)))\r\nbreak;\r\nif (pci_enable_device(dev)) {\r\n#if defined(DEBUG_PCI_DETECT)\r\nprintk\r\n("%s: detect, bus %d, devfn 0x%x, pci_enable_device failed.\n",\r\ndriver_name, dev->bus->number, dev->devfn);\r\n#endif\r\ncontinue;\r\n}\r\naddr = pci_resource_start(dev, 0);\r\n#if defined(DEBUG_PCI_DETECT)\r\nprintk("%s: detect, seq. %d, bus %d, devfn 0x%x, addr 0x%x.\n",\r\ndriver_name, k, dev->bus->number, dev->devfn, addr);\r\n#endif\r\nio_port[MAX_INT_PARAM + (rev_scan ? (MAX_PCI - k) : (1 + k))] =\r\naddr + PCI_BASE_ADDRESS_0;\r\n}\r\npci_dev_put(dev);\r\n#endif\r\n}\r\nstatic int eata2x_detect(struct scsi_host_template *tpnt)\r\n{\r\nunsigned int j = 0, k;\r\ntpnt->proc_name = "eata2x";\r\nif (strlen(boot_options))\r\noption_setup(boot_options);\r\n#if defined(MODULE)\r\nif (io_port[0] != SKIP) {\r\nsetup_done = 1;\r\nio_port[MAX_INT_PARAM] = 0;\r\n}\r\n#endif\r\nfor (k = MAX_INT_PARAM; io_port[k]; k++)\r\nif (io_port[k] == SKIP)\r\ncontinue;\r\nelse if (io_port[k] <= MAX_ISA_ADDR) {\r\nif (!isa_probe)\r\nio_port[k] = SKIP;\r\n} else if (io_port[k] >= MIN_EISA_ADDR\r\n&& io_port[k] <= MAX_EISA_ADDR) {\r\nif (!eisa_probe)\r\nio_port[k] = SKIP;\r\n}\r\nif (pci_probe) {\r\nif (!setup_done)\r\nadd_pci_ports();\r\nelse\r\nenable_pci_ports();\r\n}\r\nfor (k = 0; io_port[k]; k++) {\r\nif (io_port[k] == SKIP)\r\ncontinue;\r\nif (j < MAX_BOARDS && port_detect(io_port[k], j, tpnt))\r\nj++;\r\n}\r\nnum_boards = j;\r\nreturn j;\r\n}\r\nstatic void map_dma(unsigned int i, struct hostdata *ha)\r\n{\r\nunsigned int k, pci_dir;\r\nint count;\r\nstruct scatterlist *sg;\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &ha->cp[i];\r\nSCpnt = cpp->SCpnt;\r\npci_dir = SCpnt->sc_data_direction;\r\nif (SCpnt->sense_buffer)\r\ncpp->sense_addr =\r\nH2DEV(pci_map_single(ha->pdev, SCpnt->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE, PCI_DMA_FROMDEVICE));\r\ncpp->sense_len = SCSI_SENSE_BUFFERSIZE;\r\nif (!scsi_sg_count(SCpnt)) {\r\ncpp->data_len = 0;\r\nreturn;\r\n}\r\ncount = pci_map_sg(ha->pdev, scsi_sglist(SCpnt), scsi_sg_count(SCpnt),\r\npci_dir);\r\nBUG_ON(!count);\r\nscsi_for_each_sg(SCpnt, sg, count, k) {\r\ncpp->sglist[k].address = H2DEV(sg_dma_address(sg));\r\ncpp->sglist[k].num_bytes = H2DEV(sg_dma_len(sg));\r\n}\r\ncpp->sg = 1;\r\ncpp->data_address = H2DEV(pci_map_single(ha->pdev, cpp->sglist,\r\nscsi_sg_count(SCpnt) *\r\nsizeof(struct sg_list),\r\npci_dir));\r\ncpp->data_len = H2DEV((scsi_sg_count(SCpnt) * sizeof(struct sg_list)));\r\n}\r\nstatic void unmap_dma(unsigned int i, struct hostdata *ha)\r\n{\r\nunsigned int pci_dir;\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &ha->cp[i];\r\nSCpnt = cpp->SCpnt;\r\npci_dir = SCpnt->sc_data_direction;\r\nif (DEV2H(cpp->sense_addr))\r\npci_unmap_single(ha->pdev, DEV2H(cpp->sense_addr),\r\nDEV2H(cpp->sense_len), PCI_DMA_FROMDEVICE);\r\nif (scsi_sg_count(SCpnt))\r\npci_unmap_sg(ha->pdev, scsi_sglist(SCpnt), scsi_sg_count(SCpnt),\r\npci_dir);\r\nif (!DEV2H(cpp->data_len))\r\npci_dir = PCI_DMA_BIDIRECTIONAL;\r\nif (DEV2H(cpp->data_address))\r\npci_unmap_single(ha->pdev, DEV2H(cpp->data_address),\r\nDEV2H(cpp->data_len), pci_dir);\r\n}\r\nstatic void sync_dma(unsigned int i, struct hostdata *ha)\r\n{\r\nunsigned int pci_dir;\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &ha->cp[i];\r\nSCpnt = cpp->SCpnt;\r\npci_dir = SCpnt->sc_data_direction;\r\nif (DEV2H(cpp->sense_addr))\r\npci_dma_sync_single_for_cpu(ha->pdev, DEV2H(cpp->sense_addr),\r\nDEV2H(cpp->sense_len),\r\nPCI_DMA_FROMDEVICE);\r\nif (scsi_sg_count(SCpnt))\r\npci_dma_sync_sg_for_cpu(ha->pdev, scsi_sglist(SCpnt),\r\nscsi_sg_count(SCpnt), pci_dir);\r\nif (!DEV2H(cpp->data_len))\r\npci_dir = PCI_DMA_BIDIRECTIONAL;\r\nif (DEV2H(cpp->data_address))\r\npci_dma_sync_single_for_cpu(ha->pdev,\r\nDEV2H(cpp->data_address),\r\nDEV2H(cpp->data_len), pci_dir);\r\n}\r\nstatic void scsi_to_dev_dir(unsigned int i, struct hostdata *ha)\r\n{\r\nunsigned int k;\r\nstatic const unsigned char data_out_cmds[] = {\r\n0x0a, 0x2a, 0x15, 0x55, 0x04, 0x07, 0x18, 0x1d, 0x24, 0x2e,\r\n0x30, 0x31, 0x32, 0x38, 0x39, 0x3a, 0x3b, 0x3d, 0x3f, 0x40,\r\n0x41, 0x4c, 0xaa, 0xae, 0xb0, 0xb1, 0xb2, 0xb6, 0xea, 0x1b, 0x5d\r\n};\r\nstatic const unsigned char data_none_cmds[] = {\r\n0x01, 0x0b, 0x10, 0x11, 0x13, 0x16, 0x17, 0x19, 0x2b, 0x1e,\r\n0x2c, 0xac, 0x2f, 0xaf, 0x33, 0xb3, 0x35, 0x36, 0x45, 0x47,\r\n0x48, 0x49, 0xa9, 0x4b, 0xa5, 0xa6, 0xb5, 0x00\r\n};\r\nstruct mscp *cpp;\r\nstruct scsi_cmnd *SCpnt;\r\ncpp = &ha->cp[i];\r\nSCpnt = cpp->SCpnt;\r\nif (SCpnt->sc_data_direction == DMA_FROM_DEVICE) {\r\ncpp->din = 1;\r\ncpp->dout = 0;\r\nreturn;\r\n} else if (SCpnt->sc_data_direction == DMA_TO_DEVICE) {\r\ncpp->din = 0;\r\ncpp->dout = 1;\r\nreturn;\r\n} else if (SCpnt->sc_data_direction == DMA_NONE) {\r\ncpp->din = 0;\r\ncpp->dout = 0;\r\nreturn;\r\n}\r\nif (SCpnt->sc_data_direction != DMA_BIDIRECTIONAL)\r\npanic("%s: qcomm, invalid SCpnt->sc_data_direction.\n",\r\nha->board_name);\r\nfor (k = 0; k < ARRAY_SIZE(data_out_cmds); k++)\r\nif (SCpnt->cmnd[0] == data_out_cmds[k]) {\r\ncpp->dout = 1;\r\nbreak;\r\n}\r\nif ((cpp->din = !cpp->dout))\r\nfor (k = 0; k < ARRAY_SIZE(data_none_cmds); k++)\r\nif (SCpnt->cmnd[0] == data_none_cmds[k]) {\r\ncpp->din = 0;\r\nbreak;\r\n}\r\n}\r\nstatic int eata2x_queuecommand_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done) (struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *shost = SCpnt->device->host;\r\nstruct hostdata *ha = (struct hostdata *)shost->hostdata;\r\nunsigned int i, k;\r\nstruct mscp *cpp;\r\nif (SCpnt->host_scribble)\r\npanic("%s: qcomm, SCpnt %p already active.\n",\r\nha->board_name, SCpnt);\r\ni = ha->last_cp_used + 1;\r\nfor (k = 0; k < shost->can_queue; k++, i++) {\r\nif (i >= shost->can_queue)\r\ni = 0;\r\nif (ha->cp_stat[i] == FREE) {\r\nha->last_cp_used = i;\r\nbreak;\r\n}\r\n}\r\nif (k == shost->can_queue) {\r\nprintk("%s: qcomm, no free mailbox.\n", ha->board_name);\r\nreturn 1;\r\n}\r\ncpp = &ha->cp[i];\r\nmemset(cpp, 0, sizeof(struct mscp) - CP_TAIL_SIZE);\r\ncpp->sp_dma_addr = H2DEV(ha->sp_dma_addr);\r\nSCpnt->scsi_done = done;\r\ncpp->cpp_index = i;\r\nSCpnt->host_scribble = (unsigned char *)&cpp->cpp_index;\r\nif (do_trace)\r\nscmd_printk(KERN_INFO, SCpnt,\r\n"qcomm, mbox %d.\n", i);\r\ncpp->reqsen = 1;\r\ncpp->dispri = 1;\r\n#if 0\r\nif (SCpnt->device->type == TYPE_TAPE)\r\ncpp->hbaci = 1;\r\n#endif\r\ncpp->one = 1;\r\ncpp->channel = SCpnt->device->channel;\r\ncpp->target = SCpnt->device->id;\r\ncpp->lun = SCpnt->device->lun;\r\ncpp->SCpnt = SCpnt;\r\nmemcpy(cpp->cdb, SCpnt->cmnd, SCpnt->cmd_len);\r\nscsi_to_dev_dir(i, ha);\r\nmap_dma(i, ha);\r\nif (linked_comm && SCpnt->device->queue_depth > 2\r\n&& TLDEV(SCpnt->device->type)) {\r\nha->cp_stat[i] = READY;\r\nflush_dev(SCpnt->device, blk_rq_pos(SCpnt->request), ha, 0);\r\nreturn 0;\r\n}\r\nif (do_dma(shost->io_port, cpp->cp_dma_addr, SEND_CP_DMA)) {\r\nunmap_dma(i, ha);\r\nSCpnt->host_scribble = NULL;\r\nscmd_printk(KERN_INFO, SCpnt, "qcomm, adapter busy.\n");\r\nreturn 1;\r\n}\r\nha->cp_stat[i] = IN_USE;\r\nreturn 0;\r\n}\r\nint eata2x_eh_host_reset(struct scsi_cmnd *SCarg)\r\n{\r\nunsigned int i, time, k, c, limit = 0;\r\nint arg_done = 0;\r\nstruct scsi_cmnd *SCpnt;\r\nstruct Scsi_Host *shost = SCarg->device->host;\r\nstruct hostdata *ha = (struct hostdata *)shost->hostdata;\r\nscmd_printk(KERN_INFO, SCarg, "reset, enter.\n");\r\nspin_lock_irq(shost->host_lock);\r\nif (SCarg->host_scribble == NULL)\r\nprintk("%s: reset, inactive.\n", ha->board_name);\r\nif (ha->in_reset) {\r\nprintk("%s: reset, exit, already in reset.\n", ha->board_name);\r\nspin_unlock_irq(shost->host_lock);\r\nreturn FAILED;\r\n}\r\nif (wait_on_busy(shost->io_port, MAXLOOP)) {\r\nprintk("%s: reset, exit, timeout error.\n", ha->board_name);\r\nspin_unlock_irq(shost->host_lock);\r\nreturn FAILED;\r\n}\r\nha->retries = 0;\r\nfor (c = 0; c <= shost->max_channel; c++)\r\nfor (k = 0; k < shost->max_id; k++) {\r\nha->target_redo[k][c] = 1;\r\nha->target_to[k][c] = 0;\r\n}\r\nfor (i = 0; i < shost->can_queue; i++) {\r\nif (ha->cp_stat[i] == FREE)\r\ncontinue;\r\nif (ha->cp_stat[i] == LOCKED) {\r\nha->cp_stat[i] = FREE;\r\nprintk("%s: reset, locked mbox %d forced free.\n",\r\nha->board_name, i);\r\ncontinue;\r\n}\r\nif (!(SCpnt = ha->cp[i].SCpnt))\r\npanic("%s: reset, mbox %d, SCpnt == NULL.\n", ha->board_name, i);\r\nif (ha->cp_stat[i] == READY || ha->cp_stat[i] == ABORTING) {\r\nha->cp_stat[i] = ABORTING;\r\nprintk("%s: reset, mbox %d aborting.\n",\r\nha->board_name, i);\r\n}\r\nelse {\r\nha->cp_stat[i] = IN_RESET;\r\nprintk("%s: reset, mbox %d in reset.\n",\r\nha->board_name, i);\r\n}\r\nif (SCpnt->host_scribble == NULL)\r\npanic("%s: reset, mbox %d, garbled SCpnt.\n", ha->board_name, i);\r\nif (*(unsigned int *)SCpnt->host_scribble != i)\r\npanic("%s: reset, mbox %d, index mismatch.\n", ha->board_name, i);\r\nif (SCpnt->scsi_done == NULL)\r\npanic("%s: reset, mbox %d, SCpnt->scsi_done == NULL.\n",\r\nha->board_name, i);\r\nif (SCpnt == SCarg)\r\narg_done = 1;\r\n}\r\nif (do_dma(shost->io_port, 0, RESET_PIO)) {\r\nprintk("%s: reset, cannot reset, timeout error.\n", ha->board_name);\r\nspin_unlock_irq(shost->host_lock);\r\nreturn FAILED;\r\n}\r\nprintk("%s: reset, board reset done, enabling interrupts.\n", ha->board_name);\r\n#if defined(DEBUG_RESET)\r\ndo_trace = 1;\r\n#endif\r\nha->in_reset = 1;\r\nspin_unlock_irq(shost->host_lock);\r\ntime = jiffies;\r\nwhile ((jiffies - time) < (10 * HZ) && limit++ < 200000)\r\nudelay(100L);\r\nspin_lock_irq(shost->host_lock);\r\nprintk("%s: reset, interrupts disabled, loops %d.\n", ha->board_name, limit);\r\nfor (i = 0; i < shost->can_queue; i++) {\r\nif (ha->cp_stat[i] == IN_RESET) {\r\nSCpnt = ha->cp[i].SCpnt;\r\nunmap_dma(i, ha);\r\nSCpnt->result = DID_RESET << 16;\r\nSCpnt->host_scribble = NULL;\r\nha->cp_stat[i] = LOCKED;\r\nprintk\r\n("%s, reset, mbox %d locked, DID_RESET, done.\n",\r\nha->board_name, i);\r\n}\r\nelse if (ha->cp_stat[i] == ABORTING) {\r\nSCpnt = ha->cp[i].SCpnt;\r\nunmap_dma(i, ha);\r\nSCpnt->result = DID_RESET << 16;\r\nSCpnt->host_scribble = NULL;\r\nha->cp_stat[i] = FREE;\r\nprintk\r\n("%s, reset, mbox %d aborting, DID_RESET, done.\n",\r\nha->board_name, i);\r\n}\r\nelse\r\ncontinue;\r\nSCpnt->scsi_done(SCpnt);\r\n}\r\nha->in_reset = 0;\r\ndo_trace = 0;\r\nif (arg_done)\r\nprintk("%s: reset, exit, done.\n", ha->board_name);\r\nelse\r\nprintk("%s: reset, exit.\n", ha->board_name);\r\nspin_unlock_irq(shost->host_lock);\r\nreturn SUCCESS;\r\n}\r\nint eata2x_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int *dkinfo)\r\n{\r\nunsigned int size = capacity;\r\nif (ext_tran || (scsicam_bios_param(bdev, capacity, dkinfo) < 0)) {\r\ndkinfo[0] = 255;\r\ndkinfo[1] = 63;\r\ndkinfo[2] = size / (dkinfo[0] * dkinfo[1]);\r\n}\r\n#if defined (DEBUG_GEOMETRY)\r\nprintk("%s: bios_param, head=%d, sec=%d, cyl=%d.\n", driver_name,\r\ndkinfo[0], dkinfo[1], dkinfo[2]);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void sort(unsigned long sk[], unsigned int da[], unsigned int n,\r\nunsigned int rev)\r\n{\r\nunsigned int i, j, k, y;\r\nunsigned long x;\r\nfor (i = 0; i < n - 1; i++) {\r\nk = i;\r\nfor (j = k + 1; j < n; j++)\r\nif (rev) {\r\nif (sk[j] > sk[k])\r\nk = j;\r\n} else {\r\nif (sk[j] < sk[k])\r\nk = j;\r\n}\r\nif (k != i) {\r\nx = sk[k];\r\nsk[k] = sk[i];\r\nsk[i] = x;\r\ny = da[k];\r\nda[k] = da[i];\r\nda[i] = y;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int reorder(struct hostdata *ha, unsigned long cursec,\r\nunsigned int ihdlr, unsigned int il[], unsigned int n_ready)\r\n{\r\nstruct scsi_cmnd *SCpnt;\r\nstruct mscp *cpp;\r\nunsigned int k, n;\r\nunsigned int rev = 0, s = 1, r = 1;\r\nunsigned int input_only = 1, overlap = 0;\r\nunsigned long sl[n_ready], pl[n_ready], ll[n_ready];\r\nunsigned long maxsec = 0, minsec = ULONG_MAX, seek = 0, iseek = 0;\r\nunsigned long ioseek = 0;\r\nstatic unsigned int flushcount = 0, batchcount = 0, sortcount = 0;\r\nstatic unsigned int readycount = 0, ovlcount = 0, inputcount = 0;\r\nstatic unsigned int readysorted = 0, revcount = 0;\r\nstatic unsigned long seeksorted = 0, seeknosort = 0;\r\nif (link_statistics && !(++flushcount % link_statistics))\r\nprintk("fc %d bc %d ic %d oc %d rc %d rs %d sc %d re %d"\r\n" av %ldK as %ldK.\n", flushcount, batchcount,\r\ninputcount, ovlcount, readycount, readysorted, sortcount,\r\nrevcount, seeknosort / (readycount + 1),\r\nseeksorted / (readycount + 1));\r\nif (n_ready <= 1)\r\nreturn 0;\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n];\r\ncpp = &ha->cp[k];\r\nSCpnt = cpp->SCpnt;\r\nif (!cpp->din)\r\ninput_only = 0;\r\nif (blk_rq_pos(SCpnt->request) < minsec)\r\nminsec = blk_rq_pos(SCpnt->request);\r\nif (blk_rq_pos(SCpnt->request) > maxsec)\r\nmaxsec = blk_rq_pos(SCpnt->request);\r\nsl[n] = blk_rq_pos(SCpnt->request);\r\nioseek += blk_rq_sectors(SCpnt->request);\r\nif (!n)\r\ncontinue;\r\nif (sl[n] < sl[n - 1])\r\ns = 0;\r\nif (sl[n] > sl[n - 1])\r\nr = 0;\r\nif (link_statistics) {\r\nif (sl[n] > sl[n - 1])\r\nseek += sl[n] - sl[n - 1];\r\nelse\r\nseek += sl[n - 1] - sl[n];\r\n}\r\n}\r\nif (link_statistics) {\r\nif (cursec > sl[0])\r\nseek += cursec - sl[0];\r\nelse\r\nseek += sl[0] - cursec;\r\n}\r\nif (cursec > ((maxsec + minsec) / 2))\r\nrev = 1;\r\nif (ioseek > ((maxsec - minsec) / 2))\r\nrev = 0;\r\nif (!((rev && r) || (!rev && s)))\r\nsort(sl, il, n_ready, rev);\r\nif (!input_only)\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n];\r\ncpp = &ha->cp[k];\r\nSCpnt = cpp->SCpnt;\r\nll[n] = blk_rq_sectors(SCpnt->request);\r\npl[n] = SCpnt->serial_number;\r\nif (!n)\r\ncontinue;\r\nif ((sl[n] == sl[n - 1])\r\n|| (!rev && ((sl[n - 1] + ll[n - 1]) > sl[n]))\r\n|| (rev && ((sl[n] + ll[n]) > sl[n - 1])))\r\noverlap = 1;\r\n}\r\nif (overlap)\r\nsort(pl, il, n_ready, 0);\r\nif (link_statistics) {\r\nif (cursec > sl[0])\r\niseek = cursec - sl[0];\r\nelse\r\niseek = sl[0] - cursec;\r\nbatchcount++;\r\nreadycount += n_ready;\r\nseeknosort += seek / 1024;\r\nif (input_only)\r\ninputcount++;\r\nif (overlap) {\r\novlcount++;\r\nseeksorted += iseek / 1024;\r\n} else\r\nseeksorted += (iseek + maxsec - minsec) / 1024;\r\nif (rev && !r) {\r\nrevcount++;\r\nreadysorted += n_ready;\r\n}\r\nif (!rev && !s) {\r\nsortcount++;\r\nreadysorted += n_ready;\r\n}\r\n}\r\n#if defined(DEBUG_LINKED_COMMANDS)\r\nif (link_statistics && (overlap || !(flushcount % link_statistics)))\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n];\r\ncpp = &ha->cp[k];\r\nSCpnt = cpp->SCpnt;\r\nscmd_printk(KERN_INFO, SCpnt,\r\n"%s mb %d fc %d nr %d sec %ld ns %u"\r\n" cur %ld s:%c r:%c rev:%c in:%c ov:%c xd %d.\n",\r\n(ihdlr ? "ihdlr" : "qcomm"),\r\nk, flushcount,\r\nn_ready, blk_rq_pos(SCpnt->request),\r\nblk_rq_sectors(SCpnt->request), cursec, YESNO(s),\r\nYESNO(r), YESNO(rev), YESNO(input_only),\r\nYESNO(overlap), cpp->din);\r\n}\r\n#endif\r\nreturn overlap;\r\n}\r\nstatic void flush_dev(struct scsi_device *dev, unsigned long cursec,\r\nstruct hostdata *ha, unsigned int ihdlr)\r\n{\r\nstruct scsi_cmnd *SCpnt;\r\nstruct mscp *cpp;\r\nunsigned int k, n, n_ready = 0, il[MAX_MAILBOXES];\r\nfor (k = 0; k < dev->host->can_queue; k++) {\r\nif (ha->cp_stat[k] != READY && ha->cp_stat[k] != IN_USE)\r\ncontinue;\r\ncpp = &ha->cp[k];\r\nSCpnt = cpp->SCpnt;\r\nif (SCpnt->device != dev)\r\ncontinue;\r\nif (ha->cp_stat[k] == IN_USE)\r\nreturn;\r\nil[n_ready++] = k;\r\n}\r\nif (reorder(ha, cursec, ihdlr, il, n_ready))\r\nn_ready = 1;\r\nfor (n = 0; n < n_ready; n++) {\r\nk = il[n];\r\ncpp = &ha->cp[k];\r\nSCpnt = cpp->SCpnt;\r\nif (do_dma(dev->host->io_port, cpp->cp_dma_addr, SEND_CP_DMA)) {\r\nscmd_printk(KERN_INFO, SCpnt,\r\n"%s, mbox %d, adapter"\r\n" busy, will abort.\n",\r\n(ihdlr ? "ihdlr" : "qcomm"),\r\nk);\r\nha->cp_stat[k] = ABORTING;\r\ncontinue;\r\n}\r\nha->cp_stat[k] = IN_USE;\r\n}\r\n}\r\nstatic irqreturn_t ihdlr(struct Scsi_Host *shost)\r\n{\r\nstruct scsi_cmnd *SCpnt;\r\nunsigned int i, k, c, status, tstatus, reg;\r\nstruct mssp *spp;\r\nstruct mscp *cpp;\r\nstruct hostdata *ha = (struct hostdata *)shost->hostdata;\r\nint irq = shost->irq;\r\nif (!(inb(shost->io_port + REG_AUX_STATUS) & IRQ_ASSERTED))\r\ngoto none;\r\nha->iocount++;\r\nif (do_trace)\r\nprintk("%s: ihdlr, enter, irq %d, count %d.\n", ha->board_name, irq,\r\nha->iocount);\r\nif (wait_on_busy(shost->io_port, 20 * MAXLOOP)) {\r\nreg = inb(shost->io_port + REG_STATUS);\r\nprintk\r\n("%s: ihdlr, busy timeout error, irq %d, reg 0x%x, count %d.\n",\r\nha->board_name, irq, reg, ha->iocount);\r\ngoto none;\r\n}\r\nspp = &ha->sp;\r\nmemcpy(spp, ha->sp_cpu_addr, sizeof(struct mssp));\r\nmemset(ha->sp_cpu_addr, 0, sizeof(struct mssp));\r\nreg = inb(shost->io_port + REG_STATUS);\r\n#if defined (DEBUG_INTERRUPT)\r\n{\r\nunsigned char *bytesp;\r\nint cnt;\r\nbytesp = (unsigned char *)spp;\r\nif (ha->iocount < 200) {\r\nprintk("sp[] =");\r\nfor (cnt = 0; cnt < 15; cnt++)\r\nprintk(" 0x%x", bytesp[cnt]);\r\nprintk("\n");\r\n}\r\n}\r\n#endif\r\nif (spp->eoc == 0 && ha->iocount > 1)\r\nprintk\r\n("%s: ihdlr, spp->eoc == 0, irq %d, reg 0x%x, count %d.\n",\r\nha->board_name, irq, reg, ha->iocount);\r\nif (spp->cpp_index < 0 || spp->cpp_index >= shost->can_queue)\r\nprintk\r\n("%s: ihdlr, bad spp->cpp_index %d, irq %d, reg 0x%x, count %d.\n",\r\nha->board_name, spp->cpp_index, irq, reg, ha->iocount);\r\nif (spp->eoc == 0 || spp->cpp_index < 0\r\n|| spp->cpp_index >= shost->can_queue)\r\ngoto handled;\r\ni = spp->cpp_index;\r\ncpp = &(ha->cp[i]);\r\n#if defined(DEBUG_GENERATE_ABORTS)\r\nif ((ha->iocount > 500) && ((ha->iocount % 500) < 3))\r\ngoto handled;\r\n#endif\r\nif (ha->cp_stat[i] == IGNORE) {\r\nha->cp_stat[i] = FREE;\r\ngoto handled;\r\n} else if (ha->cp_stat[i] == LOCKED) {\r\nha->cp_stat[i] = FREE;\r\nprintk("%s: ihdlr, mbox %d unlocked, count %d.\n", ha->board_name, i,\r\nha->iocount);\r\ngoto handled;\r\n} else if (ha->cp_stat[i] == FREE) {\r\nprintk("%s: ihdlr, mbox %d is free, count %d.\n", ha->board_name, i,\r\nha->iocount);\r\ngoto handled;\r\n} else if (ha->cp_stat[i] == IN_RESET)\r\nprintk("%s: ihdlr, mbox %d is in reset.\n", ha->board_name, i);\r\nelse if (ha->cp_stat[i] != IN_USE)\r\npanic("%s: ihdlr, mbox %d, invalid cp_stat: %d.\n",\r\nha->board_name, i, ha->cp_stat[i]);\r\nha->cp_stat[i] = FREE;\r\nSCpnt = cpp->SCpnt;\r\nif (SCpnt == NULL)\r\npanic("%s: ihdlr, mbox %d, SCpnt == NULL.\n", ha->board_name, i);\r\nif (SCpnt->host_scribble == NULL)\r\npanic("%s: ihdlr, mbox %d, SCpnt %p garbled.\n", ha->board_name,\r\ni, SCpnt);\r\nif (*(unsigned int *)SCpnt->host_scribble != i)\r\npanic("%s: ihdlr, mbox %d, index mismatch %d.\n",\r\nha->board_name, i,\r\n*(unsigned int *)SCpnt->host_scribble);\r\nsync_dma(i, ha);\r\nif (linked_comm && SCpnt->device->queue_depth > 2\r\n&& TLDEV(SCpnt->device->type))\r\nflush_dev(SCpnt->device, blk_rq_pos(SCpnt->request), ha, 1);\r\ntstatus = status_byte(spp->target_status);\r\n#if defined(DEBUG_GENERATE_ERRORS)\r\nif ((ha->iocount > 500) && ((ha->iocount % 200) < 2))\r\nspp->adapter_status = 0x01;\r\n#endif\r\nswitch (spp->adapter_status) {\r\ncase ASOK:\r\nif (tstatus == BUSY && SCpnt->device->type != TYPE_TAPE)\r\nstatus = DID_ERROR << 16;\r\nelse if (tstatus != GOOD && SCpnt->device->type == TYPE_DISK\r\n&& ha->target_redo[SCpnt->device->id][SCpnt->\r\ndevice->\r\nchannel])\r\nstatus = DID_BUS_BUSY << 16;\r\nelse if (tstatus == CHECK_CONDITION\r\n&& SCpnt->device->type == TYPE_DISK\r\n&& (SCpnt->sense_buffer[2] & 0xf) == RECOVERED_ERROR)\r\nstatus = DID_BUS_BUSY << 16;\r\nelse\r\nstatus = DID_OK << 16;\r\nif (tstatus == GOOD)\r\nha->target_redo[SCpnt->device->id][SCpnt->device->\r\nchannel] = 0;\r\nif (spp->target_status && SCpnt->device->type == TYPE_DISK &&\r\n(!(tstatus == CHECK_CONDITION && ha->iocount <= 1000 &&\r\n(SCpnt->sense_buffer[2] & 0xf) == NOT_READY)))\r\nprintk("%s: ihdlr, target %d.%d:%d, "\r\n"target_status 0x%x, sense key 0x%x.\n",\r\nha->board_name,\r\nSCpnt->device->channel, SCpnt->device->id,\r\n(u8)SCpnt->device->lun,\r\nspp->target_status, SCpnt->sense_buffer[2]);\r\nha->target_to[SCpnt->device->id][SCpnt->device->channel] = 0;\r\nif (ha->last_retried_pid == SCpnt->serial_number)\r\nha->retries = 0;\r\nbreak;\r\ncase ASST:\r\ncase 0x02:\r\nif (ha->target_to[SCpnt->device->id][SCpnt->device->channel] > 1)\r\nstatus = DID_ERROR << 16;\r\nelse {\r\nstatus = DID_TIME_OUT << 16;\r\nha->target_to[SCpnt->device->id][SCpnt->device->\r\nchannel]++;\r\n}\r\nbreak;\r\ncase 0x03:\r\ncase 0x04:\r\nfor (c = 0; c <= shost->max_channel; c++)\r\nfor (k = 0; k < shost->max_id; k++)\r\nha->target_redo[k][c] = 1;\r\nif (SCpnt->device->type != TYPE_TAPE\r\n&& ha->retries < MAX_INTERNAL_RETRIES) {\r\n#if defined(DID_SOFT_ERROR)\r\nstatus = DID_SOFT_ERROR << 16;\r\n#else\r\nstatus = DID_BUS_BUSY << 16;\r\n#endif\r\nha->retries++;\r\nha->last_retried_pid = SCpnt->serial_number;\r\n} else\r\nstatus = DID_ERROR << 16;\r\nbreak;\r\ncase 0x05:\r\ncase 0x06:\r\ncase 0x07:\r\ncase 0x08:\r\ncase 0x09:\r\ncase 0x0a:\r\ncase 0x0b:\r\ncase 0x0c:\r\ndefault:\r\nstatus = DID_ERROR << 16;\r\nbreak;\r\n}\r\nSCpnt->result = status | spp->target_status;\r\n#if defined(DEBUG_INTERRUPT)\r\nif (SCpnt->result || do_trace)\r\n#else\r\nif ((spp->adapter_status != ASOK && ha->iocount > 1000) ||\r\n(spp->adapter_status != ASOK &&\r\nspp->adapter_status != ASST && ha->iocount <= 1000) ||\r\ndo_trace || msg_byte(spp->target_status))\r\n#endif\r\nscmd_printk(KERN_INFO, SCpnt, "ihdlr, mbox %2d, err 0x%x:%x,"\r\n" reg 0x%x, count %d.\n",\r\ni, spp->adapter_status, spp->target_status,\r\nreg, ha->iocount);\r\nunmap_dma(i, ha);\r\nSCpnt->host_scribble = NULL;\r\nSCpnt->scsi_done(SCpnt);\r\nif (do_trace)\r\nprintk("%s: ihdlr, exit, irq %d, count %d.\n", ha->board_name,\r\nirq, ha->iocount);\r\nhandled:\r\nreturn IRQ_HANDLED;\r\nnone:\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t do_interrupt_handler(int dummy, void *shap)\r\n{\r\nstruct Scsi_Host *shost;\r\nunsigned int j;\r\nunsigned long spin_flags;\r\nirqreturn_t ret;\r\nif ((j = (unsigned int)((char *)shap - sha)) >= num_boards)\r\nreturn IRQ_NONE;\r\nshost = sh[j];\r\nspin_lock_irqsave(shost->host_lock, spin_flags);\r\nret = ihdlr(shost);\r\nspin_unlock_irqrestore(shost->host_lock, spin_flags);\r\nreturn ret;\r\n}\r\nstatic int eata2x_release(struct Scsi_Host *shost)\r\n{\r\nstruct hostdata *ha = (struct hostdata *)shost->hostdata;\r\nunsigned int i;\r\nfor (i = 0; i < shost->can_queue; i++)\r\nkfree((&ha->cp[i])->sglist);\r\nfor (i = 0; i < shost->can_queue; i++)\r\npci_unmap_single(ha->pdev, ha->cp[i].cp_dma_addr,\r\nsizeof(struct mscp), PCI_DMA_BIDIRECTIONAL);\r\nif (ha->sp_cpu_addr)\r\npci_free_consistent(ha->pdev, sizeof(struct mssp),\r\nha->sp_cpu_addr, ha->sp_dma_addr);\r\nfree_irq(shost->irq, &sha[ha->board_number]);\r\nif (shost->dma_channel != NO_DMA)\r\nfree_dma(shost->dma_channel);\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\nreturn 0;\r\n}
