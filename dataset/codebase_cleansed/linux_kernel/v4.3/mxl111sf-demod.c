static int mxl111sf_demod_read_reg(struct mxl111sf_demod_state *state,\r\nu8 addr, u8 *data)\r\n{\r\nreturn (state->cfg->read_reg) ?\r\nstate->cfg->read_reg(state->mxl_state, addr, data) :\r\n-EINVAL;\r\n}\r\nstatic int mxl111sf_demod_write_reg(struct mxl111sf_demod_state *state,\r\nu8 addr, u8 data)\r\n{\r\nreturn (state->cfg->write_reg) ?\r\nstate->cfg->write_reg(state->mxl_state, addr, data) :\r\n-EINVAL;\r\n}\r\nstatic\r\nint mxl111sf_demod_program_regs(struct mxl111sf_demod_state *state,\r\nstruct mxl111sf_reg_ctrl_info *ctrl_reg_info)\r\n{\r\nreturn (state->cfg->program_regs) ?\r\nstate->cfg->program_regs(state->mxl_state, ctrl_reg_info) :\r\n-EINVAL;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_tps_code_rate(struct mxl111sf_demod_state *state,\r\nenum fe_code_rate *code_rate)\r\n{\r\nu8 val;\r\nint ret = mxl111sf_demod_read_reg(state, V6_CODE_RATE_TPS_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nswitch (val & V6_CODE_RATE_TPS_MASK) {\r\ncase 0:\r\n*code_rate = FEC_1_2;\r\nbreak;\r\ncase 1:\r\n*code_rate = FEC_2_3;\r\nbreak;\r\ncase 2:\r\n*code_rate = FEC_3_4;\r\nbreak;\r\ncase 3:\r\n*code_rate = FEC_5_6;\r\nbreak;\r\ncase 4:\r\n*code_rate = FEC_7_8;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_tps_modulation(struct mxl111sf_demod_state *state,\r\nenum fe_modulation *modulation)\r\n{\r\nu8 val;\r\nint ret = mxl111sf_demod_read_reg(state, V6_MODORDER_TPS_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nswitch ((val & V6_PARAM_CONSTELLATION_MASK) >> 4) {\r\ncase 0:\r\n*modulation = QPSK;\r\nbreak;\r\ncase 1:\r\n*modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\n*modulation = QAM_64;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_tps_guard_fft_mode(struct mxl111sf_demod_state *state,\r\nenum fe_transmit_mode *fft_mode)\r\n{\r\nu8 val;\r\nint ret = mxl111sf_demod_read_reg(state, V6_MODE_TPS_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nswitch ((val & V6_PARAM_FFT_MODE_MASK) >> 2) {\r\ncase 0:\r\n*fft_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\n*fft_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\ncase 2:\r\n*fft_mode = TRANSMISSION_MODE_4K;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_tps_guard_interval(struct mxl111sf_demod_state *state,\r\nenum fe_guard_interval *guard)\r\n{\r\nu8 val;\r\nint ret = mxl111sf_demod_read_reg(state, V6_CP_TPS_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nswitch ((val & V6_PARAM_GI_MASK) >> 4) {\r\ncase 0:\r\n*guard = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\n*guard = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\n*guard = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\n*guard = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_tps_hierarchy(struct mxl111sf_demod_state *state,\r\nenum fe_hierarchy *hierarchy)\r\n{\r\nu8 val;\r\nint ret = mxl111sf_demod_read_reg(state, V6_TPS_HIERACHY_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nswitch ((val & V6_TPS_HIERARCHY_INFO_MASK) >> 6) {\r\ncase 0:\r\n*hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\n*hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\n*hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\n*hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_sync_lock_status(struct mxl111sf_demod_state *state,\r\nint *sync_lock)\r\n{\r\nu8 val = 0;\r\nint ret = mxl111sf_demod_read_reg(state, V6_SYNC_LOCK_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*sync_lock = (val & SYNC_LOCK_MASK) >> 4;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_rs_lock_status(struct mxl111sf_demod_state *state,\r\nint *rs_lock)\r\n{\r\nu8 val = 0;\r\nint ret = mxl111sf_demod_read_reg(state, V6_RS_LOCK_DET_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*rs_lock = (val & RS_LOCK_DET_MASK) >> 3;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_tps_lock_status(struct mxl111sf_demod_state *state,\r\nint *tps_lock)\r\n{\r\nu8 val = 0;\r\nint ret = mxl111sf_demod_read_reg(state, V6_TPS_LOCK_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*tps_lock = (val & V6_PARAM_TPS_LOCK_MASK) >> 6;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic\r\nint mxl1x1sf_demod_get_fec_lock_status(struct mxl111sf_demod_state *state,\r\nint *fec_lock)\r\n{\r\nu8 val = 0;\r\nint ret = mxl111sf_demod_read_reg(state, V6_IRQ_STATUS_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*fec_lock = (val & IRQ_MASK_FEC_LOCK) >> 4;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl1x1sf_demod_reset_irq_status(struct mxl111sf_demod_state *state)\r\n{\r\nreturn mxl111sf_demod_write_reg(state, 0x0e, 0xff);\r\n}\r\nstatic int mxl111sf_demod_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nint ret = 0;\r\nstruct mxl111sf_reg_ctrl_info phy_pll_patch[] = {\r\n{0x00, 0xff, 0x01},\r\n{0x40, 0xff, 0x05},\r\n{0x40, 0xff, 0x01},\r\n{0x41, 0xff, 0xca},\r\n{0x41, 0xff, 0xc0},\r\n{0x00, 0xff, 0x00},\r\n{0, 0, 0}\r\n};\r\nmxl_dbg("()");\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nmsleep(50);\r\n}\r\nret = mxl111sf_demod_program_regs(state, phy_pll_patch);\r\nmxl_fail(ret);\r\nmsleep(50);\r\nret = mxl1x1sf_demod_reset_irq_status(state);\r\nmxl_fail(ret);\r\nmsleep(100);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_demod_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nu32 fec_per_count, fec_per_scale;\r\nu8 val;\r\nint ret;\r\n*ucblocks = 0;\r\nret = mxl111sf_demod_read_reg(state, V6_FEC_PER_COUNT_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nfec_per_count = val;\r\nret = mxl111sf_demod_read_reg(state, V6_FEC_PER_SCALE_REG, &val);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nval &= V6_FEC_PER_SCALE_MASK;\r\nval *= 4;\r\nfec_per_scale = 1 << val;\r\nfec_per_count *= fec_per_scale;\r\n*ucblocks = fec_per_count;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_demod_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nu8 val1, val2, val3;\r\nint ret;\r\n*ber = 0;\r\nret = mxl111sf_demod_read_reg(state, V6_RS_AVG_ERRORS_LSB_REG, &val1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_demod_read_reg(state, V6_RS_AVG_ERRORS_MSB_REG, &val2);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_demod_read_reg(state, V6_N_ACCUMULATE_REG, &val3);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*ber = CALCULATE_BER((val1 | (val2 << 8)), val3);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_demod_calc_snr(struct mxl111sf_demod_state *state,\r\nu16 *snr)\r\n{\r\nu8 val1, val2;\r\nint ret;\r\n*snr = 0;\r\nret = mxl111sf_demod_read_reg(state, V6_SNR_RB_LSB_REG, &val1);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl111sf_demod_read_reg(state, V6_SNR_RB_MSB_REG, &val2);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*snr = CALCULATE_SNR(val1 | ((val2 & 0x03) << 8));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_demod_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nint ret = mxl111sf_demod_calc_snr(state, snr);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\n*snr /= 10;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_demod_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nint ret, locked, cr_lock, sync_lock, fec_lock;\r\n*status = 0;\r\nret = mxl1x1sf_demod_get_rs_lock_status(state, &locked);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_demod_get_tps_lock_status(state, &cr_lock);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_demod_get_sync_lock_status(state, &sync_lock);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nret = mxl1x1sf_demod_get_fec_lock_status(state, &fec_lock);\r\nif (mxl_fail(ret))\r\ngoto fail;\r\nif (locked)\r\n*status |= FE_HAS_SIGNAL;\r\nif (cr_lock)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync_lock)\r\n*status |= FE_HAS_SYNC;\r\nif (fec_lock)\r\n*status |= FE_HAS_VITERBI;\r\nif ((locked) && (cr_lock) && (sync_lock))\r\n*status |= FE_HAS_LOCK;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int mxl111sf_demod_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nenum fe_modulation modulation;\r\nu16 snr;\r\nmxl111sf_demod_calc_snr(state, &snr);\r\nmxl1x1sf_demod_get_tps_modulation(state, &modulation);\r\nswitch (modulation) {\r\ncase QPSK:\r\n*signal_strength = (snr >= 1300) ?\r\nmin(65535, snr * 44) : snr * 38;\r\nbreak;\r\ncase QAM_16:\r\n*signal_strength = (snr >= 1500) ?\r\nmin(65535, snr * 38) : snr * 33;\r\nbreak;\r\ncase QAM_64:\r\n*signal_strength = (snr >= 2000) ?\r\nmin(65535, snr * 29) : snr * 25;\r\nbreak;\r\ndefault:\r\n*signal_strength = 0;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxl111sf_demod_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nmxl_dbg("()");\r\n#if 0\r\np->inversion = ? INVERSION_ON : INVERSION_OFF;\r\n#endif\r\nif (fe->ops.tuner_ops.get_bandwidth)\r\nfe->ops.tuner_ops.get_bandwidth(fe, &p->bandwidth_hz);\r\nif (fe->ops.tuner_ops.get_frequency)\r\nfe->ops.tuner_ops.get_frequency(fe, &p->frequency);\r\nmxl1x1sf_demod_get_tps_code_rate(state, &p->code_rate_HP);\r\nmxl1x1sf_demod_get_tps_code_rate(state, &p->code_rate_LP);\r\nmxl1x1sf_demod_get_tps_modulation(state, &p->modulation);\r\nmxl1x1sf_demod_get_tps_guard_fft_mode(state,\r\n&p->transmission_mode);\r\nmxl1x1sf_demod_get_tps_guard_interval(state,\r\n&p->guard_interval);\r\nmxl1x1sf_demod_get_tps_hierarchy(state,\r\n&p->hierarchy);\r\nreturn 0;\r\n}\r\nstatic\r\nint mxl111sf_demod_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void mxl111sf_demod_release(struct dvb_frontend *fe)\r\n{\r\nstruct mxl111sf_demod_state *state = fe->demodulator_priv;\r\nmxl_dbg("()");\r\nkfree(state);\r\nfe->demodulator_priv = NULL;\r\n}\r\nstruct dvb_frontend *mxl111sf_demod_attach(struct mxl111sf_state *mxl_state,\r\nstruct mxl111sf_demod_config *cfg)\r\n{\r\nstruct mxl111sf_demod_state *state = NULL;\r\nmxl_dbg("()");\r\nstate = kzalloc(sizeof(struct mxl111sf_demod_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->mxl_state = mxl_state;\r\nstate->cfg = cfg;\r\nmemcpy(&state->fe.ops, &mxl111sf_demod_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->fe.demodulator_priv = state;\r\nreturn &state->fe;\r\n}
