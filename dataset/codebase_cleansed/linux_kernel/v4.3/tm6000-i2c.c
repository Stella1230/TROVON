static int tm6000_i2c_send_regs(struct tm6000_core *dev, unsigned char addr,\r\n__u8 reg, char *buf, int len)\r\n{\r\nint rc;\r\nunsigned int i2c_packet_limit = 16;\r\nif (dev->dev_type == TM6010)\r\ni2c_packet_limit = 80;\r\nif (!buf)\r\nreturn -1;\r\nif (len < 1 || len > i2c_packet_limit) {\r\nprintk(KERN_ERR "Incorrect length of i2c packet = %d, limit set to %d\n",\r\nlen, i2c_packet_limit);\r\nreturn -1;\r\n}\r\nrc = tm6000_read_write_usb(dev, USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, REQ_16_SET_GET_I2C_WR1_RDN,\r\naddr | reg << 8, 0, buf, len);\r\nif (rc < 0) {\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int tm6000_i2c_recv_regs(struct tm6000_core *dev, unsigned char addr,\r\n__u8 reg, char *buf, int len)\r\n{\r\nint rc;\r\nu8 b[2];\r\nunsigned int i2c_packet_limit = 16;\r\nif (dev->dev_type == TM6010)\r\ni2c_packet_limit = 64;\r\nif (!buf)\r\nreturn -1;\r\nif (len < 1 || len > i2c_packet_limit) {\r\nprintk(KERN_ERR "Incorrect length of i2c packet = %d, limit set to %d\n",\r\nlen, i2c_packet_limit);\r\nreturn -1;\r\n}\r\nif ((dev->caps.has_zl10353) && (dev->demod_addr << 1 == addr) && (reg % 2 == 0)) {\r\nreg -= 1;\r\nlen += 1;\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nREQ_16_SET_GET_I2C_WR1_RDN, addr | reg << 8, 0, b, len);\r\n*buf = b[1];\r\n} else {\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nREQ_16_SET_GET_I2C_WR1_RDN, addr | reg << 8, 0, buf, len);\r\n}\r\nreturn rc;\r\n}\r\nstatic int tm6000_i2c_recv_regs16(struct tm6000_core *dev, unsigned char addr,\r\n__u16 reg, char *buf, int len)\r\n{\r\nint rc;\r\nunsigned char ureg;\r\nif (!buf || len != 2)\r\nreturn -1;\r\nif (dev->dev_type == TM6010) {\r\nureg = reg & 0xFF;\r\nrc = tm6000_read_write_usb(dev, USB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, REQ_16_SET_GET_I2C_WR1_RDN,\r\naddr | (reg & 0xFF00), 0, &ureg, 1);\r\nif (rc < 0) {\r\nreturn rc;\r\n}\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, REQ_35_AFTEK_TUNER_READ,\r\nreg, 0, buf, len);\r\n} else {\r\nrc = tm6000_read_write_usb(dev, USB_DIR_IN | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, REQ_14_SET_GET_I2C_WR2_RDN,\r\naddr, reg, buf, len);\r\n}\r\nreturn rc;\r\n}\r\nstatic int tm6000_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct tm6000_core *dev = i2c_adap->algo_data;\r\nint addr, rc, i, byte;\r\nif (num <= 0)\r\nreturn 0;\r\nfor (i = 0; i < num; i++) {\r\naddr = (msgs[i].addr << 1) & 0xff;\r\ni2c_dprintk(2, "%s %s addr=0x%x len=%d:",\r\n(msgs[i].flags & I2C_M_RD) ? "read" : "write",\r\ni == num - 1 ? "stop" : "nonstop", addr, msgs[i].len);\r\nif (msgs[i].flags & I2C_M_RD) {\r\ni2c_dprintk(2, " read without preceding write not"\r\n" supported");\r\nrc = -EOPNOTSUPP;\r\ngoto err;\r\n} else if (i + 1 < num && msgs[i].len <= 2 &&\r\n(msgs[i + 1].flags & I2C_M_RD) &&\r\nmsgs[i].addr == msgs[i + 1].addr) {\r\nif (i2c_debug >= 2)\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i].buf[byte]);\r\ni2c_dprintk(2, "; joined to read %s len=%d:",\r\ni == num - 2 ? "stop" : "nonstop",\r\nmsgs[i + 1].len);\r\nif (msgs[i].len == 2) {\r\nrc = tm6000_i2c_recv_regs16(dev, addr,\r\nmsgs[i].buf[0] << 8 | msgs[i].buf[1],\r\nmsgs[i + 1].buf, msgs[i + 1].len);\r\n} else {\r\nrc = tm6000_i2c_recv_regs(dev, addr, msgs[i].buf[0],\r\nmsgs[i + 1].buf, msgs[i + 1].len);\r\n}\r\ni++;\r\nif (addr == dev->tuner_addr << 1) {\r\ntm6000_set_reg(dev, REQ_50_SET_START, 0, 0);\r\ntm6000_set_reg(dev, REQ_51_SET_STOP, 0, 0);\r\n}\r\nif (i2c_debug >= 2)\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i].buf[byte]);\r\n} else {\r\nif (i2c_debug >= 2)\r\nfor (byte = 0; byte < msgs[i].len; byte++)\r\nprintk(KERN_CONT " %02x", msgs[i].buf[byte]);\r\nrc = tm6000_i2c_send_regs(dev, addr, msgs[i].buf[0],\r\nmsgs[i].buf + 1, msgs[i].len - 1);\r\n}\r\nif (i2c_debug >= 2)\r\nprintk(KERN_CONT "\n");\r\nif (rc < 0)\r\ngoto err;\r\n}\r\nreturn num;\r\nerr:\r\ni2c_dprintk(2, " ERROR: %i\n", rc);\r\nreturn rc;\r\n}\r\nstatic int tm6000_i2c_eeprom(struct tm6000_core *dev)\r\n{\r\nint i, rc;\r\nunsigned char *p = dev->eedata;\r\nunsigned char bytes[17];\r\ndev->i2c_client.addr = 0xa0 >> 1;\r\ndev->eedata_size = 0;\r\nbytes[16] = '\0';\r\nfor (i = 0; i < sizeof(dev->eedata); ) {\r\n*p = i;\r\nrc = tm6000_i2c_recv_regs(dev, 0xa0, i, p, 1);\r\nif (rc < 1) {\r\nif (p == dev->eedata)\r\ngoto noeeprom;\r\nelse {\r\nprintk(KERN_WARNING\r\n"%s: i2c eeprom read error (err=%d)\n",\r\ndev->name, rc);\r\n}\r\nreturn -EINVAL;\r\n}\r\ndev->eedata_size++;\r\np++;\r\nif (0 == (i % 16))\r\nprintk(KERN_INFO "%s: i2c eeprom %02x:", dev->name, i);\r\nprintk(KERN_CONT " %02x", dev->eedata[i]);\r\nif ((dev->eedata[i] >= ' ') && (dev->eedata[i] <= 'z'))\r\nbytes[i%16] = dev->eedata[i];\r\nelse\r\nbytes[i%16] = '.';\r\ni++;\r\nif (0 == (i % 16)) {\r\nbytes[16] = '\0';\r\nprintk(KERN_CONT " %s\n", bytes);\r\n}\r\n}\r\nif (0 != (i%16)) {\r\nbytes[i%16] = '\0';\r\nfor (i %= 16; i < 16; i++)\r\nprintk(KERN_CONT " ");\r\nprintk(KERN_CONT " %s\n", bytes);\r\n}\r\nreturn 0;\r\nnoeeprom:\r\nprintk(KERN_INFO "%s: Huh, no eeprom present (err=%d)?\n",\r\ndev->name, rc);\r\nreturn -EINVAL;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL;\r\n}\r\nint tm6000_i2c_register(struct tm6000_core *dev)\r\n{\r\nint rc;\r\ndev->i2c_adap.owner = THIS_MODULE;\r\ndev->i2c_adap.algo = &tm6000_algo;\r\ndev->i2c_adap.dev.parent = &dev->udev->dev;\r\nstrlcpy(dev->i2c_adap.name, dev->name, sizeof(dev->i2c_adap.name));\r\ndev->i2c_adap.algo_data = dev;\r\ni2c_set_adapdata(&dev->i2c_adap, &dev->v4l2_dev);\r\nrc = i2c_add_adapter(&dev->i2c_adap);\r\nif (rc)\r\nreturn rc;\r\ndev->i2c_client.adapter = &dev->i2c_adap;\r\nstrlcpy(dev->i2c_client.name, "tm6000 internal", I2C_NAME_SIZE);\r\ntm6000_i2c_eeprom(dev);\r\nreturn 0;\r\n}\r\nint tm6000_i2c_unregister(struct tm6000_core *dev)\r\n{\r\ni2c_del_adapter(&dev->i2c_adap);\r\nreturn 0;\r\n}
