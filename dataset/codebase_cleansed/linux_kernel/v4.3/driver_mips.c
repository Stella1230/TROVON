static inline bool bcma_core_mips_bcm47162a0_quirk(struct bcma_device *dev)\r\n{\r\nreturn dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM47162 &&\r\ndev->bus->chipinfo.rev == 0 && dev->id.id == BCMA_CORE_MIPS_74K;\r\n}\r\nstatic inline bool bcma_core_mips_bcm5357b0_quirk(struct bcma_device *dev)\r\n{\r\nreturn (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM5357 ||\r\ndev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4749) &&\r\ndev->bus->chipinfo.pkg == 11 &&\r\ndev->id.id == BCMA_CORE_USB20_HOST;\r\n}\r\nstatic inline u32 mips_read32(struct bcma_drv_mips *mcore,\r\nu16 offset)\r\n{\r\nreturn bcma_read32(mcore->core, offset);\r\n}\r\nstatic inline void mips_write32(struct bcma_drv_mips *mcore,\r\nu16 offset,\r\nu32 value)\r\n{\r\nbcma_write32(mcore->core, offset, value);\r\n}\r\nstatic u32 bcma_core_mips_irqflag(struct bcma_device *dev)\r\n{\r\nu32 flag;\r\nif (bcma_core_mips_bcm47162a0_quirk(dev))\r\nreturn dev->core_index;\r\nif (bcma_core_mips_bcm5357b0_quirk(dev))\r\nreturn dev->core_index;\r\nflag = bcma_aread32(dev, BCMA_MIPS_OOBSELOUTA30);\r\nif (flag)\r\nreturn flag & 0x1F;\r\nelse\r\nreturn 0x3f;\r\n}\r\nunsigned int bcma_core_mips_irq(struct bcma_device *dev)\r\n{\r\nstruct bcma_device *mdev = dev->bus->drv_mips.core;\r\nu32 irqflag;\r\nunsigned int irq;\r\nirqflag = bcma_core_mips_irqflag(dev);\r\nif (irqflag == 0x3f)\r\nreturn 6;\r\nfor (irq = 0; irq <= 4; irq++)\r\nif (bcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq)) &\r\n(1 << irqflag))\r\nreturn irq;\r\nreturn 5;\r\n}\r\nstatic void bcma_core_mips_set_irq(struct bcma_device *dev, unsigned int irq)\r\n{\r\nunsigned int oldirq = bcma_core_mips_irq(dev);\r\nstruct bcma_bus *bus = dev->bus;\r\nstruct bcma_device *mdev = bus->drv_mips.core;\r\nu32 irqflag;\r\nirqflag = bcma_core_mips_irqflag(dev);\r\nBUG_ON(oldirq == 6);\r\ndev->irq = irq + 2;\r\nif (oldirq == 0)\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0),\r\nbcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0)) &\r\n~(1 << irqflag));\r\nelse if (oldirq != 5)\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(oldirq), 0);\r\nif (irq == 0) {\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0),\r\nbcma_read32(mdev, BCMA_MIPS_MIPS74K_INTMASK(0)) |\r\n(1 << irqflag));\r\n} else {\r\nu32 irqinitmask = bcma_read32(mdev,\r\nBCMA_MIPS_MIPS74K_INTMASK(irq));\r\nif (irqinitmask) {\r\nstruct bcma_device *core;\r\nlist_for_each_entry(core, &bus->cores, list) {\r\nif ((1 << bcma_core_mips_irqflag(core)) ==\r\nirqinitmask) {\r\nbcma_core_mips_set_irq(core, 0);\r\nbreak;\r\n}\r\n}\r\n}\r\nbcma_write32(mdev, BCMA_MIPS_MIPS74K_INTMASK(irq),\r\n1 << irqflag);\r\n}\r\nbcma_debug(bus, "set_irq: core 0x%04x, irq %d => %d\n",\r\ndev->id.id, oldirq <= 4 ? oldirq + 2 : 0, irq + 2);\r\n}\r\nstatic void bcma_core_mips_set_irq_name(struct bcma_bus *bus, unsigned int irq,\r\nu16 coreid, u8 unit)\r\n{\r\nstruct bcma_device *core;\r\ncore = bcma_find_core_unit(bus, coreid, unit);\r\nif (!core) {\r\nbcma_warn(bus,\r\n"Can not find core (id: 0x%x, unit %i) for IRQ configuration.\n",\r\ncoreid, unit);\r\nreturn;\r\n}\r\nbcma_core_mips_set_irq(core, irq);\r\n}\r\nstatic void bcma_core_mips_print_irq(struct bcma_device *dev, unsigned int irq)\r\n{\r\nint i;\r\nstatic const char *irq_name[] = {"2(S)", "3", "4", "5", "6", "D", "I"};\r\nprintk(KERN_DEBUG KBUILD_MODNAME ": core 0x%04x, irq :", dev->id.id);\r\nfor (i = 0; i <= 6; i++)\r\nprintk(" %s%s", irq_name[i], i == irq ? "*" : " ");\r\nprintk("\n");\r\n}\r\nstatic void bcma_core_mips_dump_irq(struct bcma_bus *bus)\r\n{\r\nstruct bcma_device *core;\r\nlist_for_each_entry(core, &bus->cores, list) {\r\nbcma_core_mips_print_irq(core, bcma_core_mips_irq(core));\r\n}\r\n}\r\nu32 bcma_cpu_clock(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus = mcore->core->bus;\r\nif (bus->drv_cc.capabilities & BCMA_CC_CAP_PMU)\r\nreturn bcma_pmu_get_cpu_clock(&bus->drv_cc);\r\nbcma_err(bus, "No PMU available, need this to get the cpu clock\n");\r\nreturn 0;\r\n}\r\nstatic enum bcma_boot_dev bcma_boot_dev(struct bcma_bus *bus)\r\n{\r\nstruct bcma_drv_cc *cc = &bus->drv_cc;\r\nu8 cc_rev = cc->core->id.rev;\r\nif (cc_rev == 42) {\r\nstruct bcma_device *core;\r\ncore = bcma_find_core(bus, BCMA_CORE_NS_ROM);\r\nif (core) {\r\nswitch (bcma_aread32(core, BCMA_IOST) &\r\nBCMA_NS_ROM_IOST_BOOT_DEV_MASK) {\r\ncase BCMA_NS_ROM_IOST_BOOT_DEV_NOR:\r\nreturn BCMA_BOOT_DEV_SERIAL;\r\ncase BCMA_NS_ROM_IOST_BOOT_DEV_NAND:\r\nreturn BCMA_BOOT_DEV_NAND;\r\ncase BCMA_NS_ROM_IOST_BOOT_DEV_ROM:\r\ndefault:\r\nreturn BCMA_BOOT_DEV_ROM;\r\n}\r\n}\r\n} else {\r\nif (cc_rev == 38) {\r\nif (cc->status & BCMA_CC_CHIPST_5357_NAND_BOOT)\r\nreturn BCMA_BOOT_DEV_NAND;\r\nelse if (cc->status & BIT(5))\r\nreturn BCMA_BOOT_DEV_ROM;\r\n}\r\nif ((cc->capabilities & BCMA_CC_CAP_FLASHT) ==\r\nBCMA_CC_FLASHT_PARA)\r\nreturn BCMA_BOOT_DEV_PARALLEL;\r\nelse\r\nreturn BCMA_BOOT_DEV_SERIAL;\r\n}\r\nreturn BCMA_BOOT_DEV_SERIAL;\r\n}\r\nstatic void bcma_core_mips_flash_detect(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus = mcore->core->bus;\r\nstruct bcma_drv_cc *cc = &bus->drv_cc;\r\nstruct bcma_pflash *pflash = &cc->pflash;\r\nenum bcma_boot_dev boot_dev;\r\nswitch (cc->capabilities & BCMA_CC_CAP_FLASHT) {\r\ncase BCMA_CC_FLASHT_STSER:\r\ncase BCMA_CC_FLASHT_ATSER:\r\nbcma_debug(bus, "Found serial flash\n");\r\nbcma_sflash_init(cc);\r\nbreak;\r\ncase BCMA_CC_FLASHT_PARA:\r\nbcma_debug(bus, "Found parallel flash\n");\r\npflash->present = true;\r\npflash->window = BCMA_SOC_FLASH2;\r\npflash->window_size = BCMA_SOC_FLASH2_SZ;\r\nif ((bcma_read32(cc->core, BCMA_CC_FLASH_CFG) &\r\nBCMA_CC_FLASH_CFG_DS) == 0)\r\npflash->buswidth = 1;\r\nelse\r\npflash->buswidth = 2;\r\nbcma_pflash_data.width = pflash->buswidth;\r\nbcma_pflash_resource.start = pflash->window;\r\nbcma_pflash_resource.end = pflash->window + pflash->window_size;\r\nbreak;\r\ndefault:\r\nbcma_err(bus, "Flash type not supported\n");\r\n}\r\nif (cc->core->id.rev == 38 ||\r\nbus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {\r\nif (cc->capabilities & BCMA_CC_CAP_NFLASH) {\r\nbcma_debug(bus, "Found NAND flash\n");\r\nbcma_nflash_init(cc);\r\n}\r\n}\r\nboot_dev = bcma_boot_dev(bus);\r\nswitch (boot_dev) {\r\ncase BCMA_BOOT_DEV_PARALLEL:\r\ncase BCMA_BOOT_DEV_SERIAL:\r\n#ifdef CONFIG_BCM47XX\r\nbcm47xx_nvram_init_from_mem(BCMA_SOC_FLASH2,\r\nBCMA_SOC_FLASH2_SZ);\r\n#endif\r\nbreak;\r\ncase BCMA_BOOT_DEV_NAND:\r\n#ifdef CONFIG_BCM47XX\r\nbcm47xx_nvram_init_from_mem(BCMA_SOC_FLASH1,\r\nBCMA_SOC_FLASH1_SZ);\r\n#endif\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid bcma_core_mips_early_init(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus = mcore->core->bus;\r\nif (mcore->early_setup_done)\r\nreturn;\r\nbcma_chipco_serial_init(&bus->drv_cc);\r\nbcma_core_mips_flash_detect(mcore);\r\nmcore->early_setup_done = true;\r\n}\r\nstatic void bcma_fix_i2s_irqflag(struct bcma_bus *bus)\r\n{\r\nstruct bcma_device *cpu, *pcie, *i2s;\r\nif (bus->chipinfo.id != BCMA_CHIP_ID_BCM4716 &&\r\nbus->chipinfo.id != BCMA_CHIP_ID_BCM4748)\r\nreturn;\r\ncpu = bcma_find_core(bus, BCMA_CORE_MIPS_74K);\r\npcie = bcma_find_core(bus, BCMA_CORE_PCIE);\r\ni2s = bcma_find_core(bus, BCMA_CORE_I2S);\r\nif (cpu && pcie && i2s &&\r\nbcma_aread32(cpu, BCMA_MIPS_OOBSELINA74) == 0x08060504 &&\r\nbcma_aread32(pcie, BCMA_MIPS_OOBSELINA74) == 0x08060504 &&\r\nbcma_aread32(i2s, BCMA_MIPS_OOBSELOUTA30) == 0x88) {\r\nbcma_awrite32(cpu, BCMA_MIPS_OOBSELINA74, 0x07060504);\r\nbcma_awrite32(pcie, BCMA_MIPS_OOBSELINA74, 0x07060504);\r\nbcma_awrite32(i2s, BCMA_MIPS_OOBSELOUTA30, 0x87);\r\nbcma_debug(bus,\r\n"Moved i2s interrupt to oob line 7 instead of 8\n");\r\n}\r\n}\r\nvoid bcma_core_mips_init(struct bcma_drv_mips *mcore)\r\n{\r\nstruct bcma_bus *bus;\r\nstruct bcma_device *core;\r\nbus = mcore->core->bus;\r\nif (mcore->setup_done)\r\nreturn;\r\nbcma_debug(bus, "Initializing MIPS core...\n");\r\nbcma_core_mips_early_init(mcore);\r\nbcma_fix_i2s_irqflag(bus);\r\nswitch (bus->chipinfo.id) {\r\ncase BCMA_CHIP_ID_BCM4716:\r\ncase BCMA_CHIP_ID_BCM4748:\r\nbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_80211, 0);\r\nbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_MAC_GBIT, 0);\r\nbcma_core_mips_set_irq_name(bus, 3, BCMA_CORE_USB20_HOST, 0);\r\nbcma_core_mips_set_irq_name(bus, 4, BCMA_CORE_PCIE, 0);\r\nbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_CHIPCOMMON, 0);\r\nbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_I2S, 0);\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM5356:\r\ncase BCMA_CHIP_ID_BCM47162:\r\ncase BCMA_CHIP_ID_BCM53572:\r\nbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_80211, 0);\r\nbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_MAC_GBIT, 0);\r\nbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_CHIPCOMMON, 0);\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM5357:\r\ncase BCMA_CHIP_ID_BCM4749:\r\nbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_80211, 0);\r\nbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_MAC_GBIT, 0);\r\nbcma_core_mips_set_irq_name(bus, 3, BCMA_CORE_USB20_HOST, 0);\r\nbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_CHIPCOMMON, 0);\r\nbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_I2S, 0);\r\nbreak;\r\ncase BCMA_CHIP_ID_BCM4706:\r\nbcma_core_mips_set_irq_name(bus, 1, BCMA_CORE_PCIE, 0);\r\nbcma_core_mips_set_irq_name(bus, 2, BCMA_CORE_4706_MAC_GBIT,\r\n0);\r\nbcma_core_mips_set_irq_name(bus, 3, BCMA_CORE_PCIE, 1);\r\nbcma_core_mips_set_irq_name(bus, 4, BCMA_CORE_USB20_HOST, 0);\r\nbcma_core_mips_set_irq_name(bus, 0, BCMA_CORE_4706_CHIPCOMMON,\r\n0);\r\nbreak;\r\ndefault:\r\nlist_for_each_entry(core, &bus->cores, list) {\r\ncore->irq = bcma_core_irq(core, 0);\r\n}\r\nbcma_err(bus,\r\n"Unknown device (0x%x) found, can not configure IRQs\n",\r\nbus->chipinfo.id);\r\n}\r\nbcma_debug(bus, "IRQ reconfiguration done\n");\r\nbcma_core_mips_dump_irq(bus);\r\nmcore->setup_done = true;\r\n}
