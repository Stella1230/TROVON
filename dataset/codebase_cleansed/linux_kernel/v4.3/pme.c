static int __init pcie_pme_setup(char *str)\r\n{\r\nif (!strncmp(str, "nomsi", 5))\r\npcie_pme_msi_disabled = true;\r\nreturn 1;\r\n}\r\nvoid pcie_pme_interrupt_enable(struct pci_dev *dev, bool enable)\r\n{\r\nif (enable)\r\npcie_capability_set_word(dev, PCI_EXP_RTCTL,\r\nPCI_EXP_RTCTL_PMEIE);\r\nelse\r\npcie_capability_clear_word(dev, PCI_EXP_RTCTL,\r\nPCI_EXP_RTCTL_PMEIE);\r\n}\r\nstatic bool pcie_pme_walk_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nbool ret = false;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (!pci_is_pcie(dev) && pci_check_pme_status(dev)) {\r\nif (dev->pme_poll)\r\ndev->pme_poll = false;\r\npci_wakeup_event(dev);\r\npm_request_resume(&dev->dev);\r\nret = true;\r\n}\r\nif (dev->subordinate && pcie_pme_walk_bus(dev->subordinate))\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool pcie_pme_from_pci_bridge(struct pci_bus *bus, u8 devfn)\r\n{\r\nstruct pci_dev *dev;\r\nbool found = false;\r\nif (devfn)\r\nreturn false;\r\ndev = pci_dev_get(bus->self);\r\nif (!dev)\r\nreturn false;\r\nif (pci_is_pcie(dev) && pci_pcie_type(dev) == PCI_EXP_TYPE_PCI_BRIDGE) {\r\ndown_read(&pci_bus_sem);\r\nif (pcie_pme_walk_bus(bus))\r\nfound = true;\r\nup_read(&pci_bus_sem);\r\n}\r\npci_dev_put(dev);\r\nreturn found;\r\n}\r\nstatic void pcie_pme_handle_request(struct pci_dev *port, u16 req_id)\r\n{\r\nu8 busnr = req_id >> 8, devfn = req_id & 0xff;\r\nstruct pci_bus *bus;\r\nstruct pci_dev *dev;\r\nbool found = false;\r\nif (port->devfn == devfn && port->bus->number == busnr) {\r\nif (port->pme_poll)\r\nport->pme_poll = false;\r\nif (pci_check_pme_status(port)) {\r\npm_request_resume(&port->dev);\r\nfound = true;\r\n} else {\r\ndown_read(&pci_bus_sem);\r\nfound = pcie_pme_walk_bus(port->subordinate);\r\nup_read(&pci_bus_sem);\r\n}\r\ngoto out;\r\n}\r\nbus = pci_find_bus(pci_domain_nr(port->bus), busnr);\r\nif (!bus)\r\ngoto out;\r\nfound = pcie_pme_from_pci_bridge(bus, devfn);\r\nif (found)\r\ngoto out;\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\npci_dev_get(dev);\r\nif (dev->devfn == devfn) {\r\nfound = true;\r\nbreak;\r\n}\r\npci_dev_put(dev);\r\n}\r\nup_read(&pci_bus_sem);\r\nif (found) {\r\nfound = pci_check_pme_status(dev);\r\nif (found) {\r\nif (dev->pme_poll)\r\ndev->pme_poll = false;\r\npci_wakeup_event(dev);\r\npm_request_resume(&dev->dev);\r\n}\r\npci_dev_put(dev);\r\n} else if (devfn) {\r\ndev_dbg(&port->dev, "PME interrupt generated for non-existent device %02x:%02x.%d\n",\r\nbusnr, PCI_SLOT(devfn), PCI_FUNC(devfn));\r\nfound = pcie_pme_from_pci_bridge(bus, 0);\r\n}\r\nout:\r\nif (!found)\r\ndev_dbg(&port->dev, "Spurious native PME interrupt!\n");\r\n}\r\nstatic void pcie_pme_work_fn(struct work_struct *work)\r\n{\r\nstruct pcie_pme_service_data *data =\r\ncontainer_of(work, struct pcie_pme_service_data, work);\r\nstruct pci_dev *port = data->srv->port;\r\nu32 rtsta;\r\nspin_lock_irq(&data->lock);\r\nfor (;;) {\r\nif (data->suspend_level != PME_SUSPEND_NONE)\r\nbreak;\r\npcie_capability_read_dword(port, PCI_EXP_RTSTA, &rtsta);\r\nif (rtsta & PCI_EXP_RTSTA_PME) {\r\npcie_clear_root_pme_status(port);\r\nspin_unlock_irq(&data->lock);\r\npcie_pme_handle_request(port, rtsta & 0xffff);\r\nspin_lock_irq(&data->lock);\r\ncontinue;\r\n}\r\nif (!(rtsta & PCI_EXP_RTSTA_PENDING))\r\nbreak;\r\nspin_unlock_irq(&data->lock);\r\ncpu_relax();\r\nspin_lock_irq(&data->lock);\r\n}\r\nif (data->suspend_level == PME_SUSPEND_NONE)\r\npcie_pme_interrupt_enable(port, true);\r\nspin_unlock_irq(&data->lock);\r\n}\r\nstatic irqreturn_t pcie_pme_irq(int irq, void *context)\r\n{\r\nstruct pci_dev *port;\r\nstruct pcie_pme_service_data *data;\r\nu32 rtsta;\r\nunsigned long flags;\r\nport = ((struct pcie_device *)context)->port;\r\ndata = get_service_data((struct pcie_device *)context);\r\nspin_lock_irqsave(&data->lock, flags);\r\npcie_capability_read_dword(port, PCI_EXP_RTSTA, &rtsta);\r\nif (!(rtsta & PCI_EXP_RTSTA_PME)) {\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\npcie_pme_interrupt_enable(port, false);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\nschedule_work(&data->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcie_pme_set_native(struct pci_dev *dev, void *ign)\r\n{\r\ndev_info(&dev->dev, "Signaling PME through PCIe PME interrupt\n");\r\ndevice_set_run_wake(&dev->dev, true);\r\ndev->pme_interrupt = true;\r\nreturn 0;\r\n}\r\nstatic void pcie_pme_mark_devices(struct pci_dev *port)\r\n{\r\npcie_pme_set_native(port, NULL);\r\nif (port->subordinate) {\r\npci_walk_bus(port->subordinate, pcie_pme_set_native, NULL);\r\n} else {\r\nstruct pci_bus *bus = port->bus;\r\nstruct pci_dev *dev;\r\nif (pci_pcie_type(port) != PCI_EXP_TYPE_RC_EC || !bus)\r\nreturn;\r\ndown_read(&pci_bus_sem);\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\nif (pci_is_pcie(dev)\r\n&& pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END)\r\npcie_pme_set_native(dev, NULL);\r\nup_read(&pci_bus_sem);\r\n}\r\n}\r\nstatic int pcie_pme_probe(struct pcie_device *srv)\r\n{\r\nstruct pci_dev *port;\r\nstruct pcie_pme_service_data *data;\r\nint ret;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspin_lock_init(&data->lock);\r\nINIT_WORK(&data->work, pcie_pme_work_fn);\r\ndata->srv = srv;\r\nset_service_data(srv, data);\r\nport = srv->port;\r\npcie_pme_interrupt_enable(port, false);\r\npcie_clear_root_pme_status(port);\r\nret = request_irq(srv->irq, pcie_pme_irq, IRQF_SHARED, "PCIe PME", srv);\r\nif (ret) {\r\nkfree(data);\r\n} else {\r\npcie_pme_mark_devices(port);\r\npcie_pme_interrupt_enable(port, true);\r\n}\r\nreturn ret;\r\n}\r\nstatic bool pcie_pme_check_wakeup(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nif (!bus)\r\nreturn false;\r\nlist_for_each_entry(dev, &bus->devices, bus_list)\r\nif (device_may_wakeup(&dev->dev)\r\n|| pcie_pme_check_wakeup(dev->subordinate))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int pcie_pme_suspend(struct pcie_device *srv)\r\n{\r\nstruct pcie_pme_service_data *data = get_service_data(srv);\r\nstruct pci_dev *port = srv->port;\r\nbool wakeup;\r\nint ret;\r\nif (device_may_wakeup(&port->dev)) {\r\nwakeup = true;\r\n} else {\r\ndown_read(&pci_bus_sem);\r\nwakeup = pcie_pme_check_wakeup(port->subordinate);\r\nup_read(&pci_bus_sem);\r\n}\r\nspin_lock_irq(&data->lock);\r\nif (wakeup) {\r\nret = enable_irq_wake(srv->irq);\r\ndata->suspend_level = PME_SUSPEND_WAKEUP;\r\n}\r\nif (!wakeup || ret) {\r\nstruct pci_dev *port = srv->port;\r\npcie_pme_interrupt_enable(port, false);\r\npcie_clear_root_pme_status(port);\r\ndata->suspend_level = PME_SUSPEND_NOIRQ;\r\n}\r\nspin_unlock_irq(&data->lock);\r\nsynchronize_irq(srv->irq);\r\nreturn 0;\r\n}\r\nstatic int pcie_pme_resume(struct pcie_device *srv)\r\n{\r\nstruct pcie_pme_service_data *data = get_service_data(srv);\r\nspin_lock_irq(&data->lock);\r\nif (data->suspend_level == PME_SUSPEND_NOIRQ) {\r\nstruct pci_dev *port = srv->port;\r\npcie_clear_root_pme_status(port);\r\npcie_pme_interrupt_enable(port, true);\r\n} else {\r\ndisable_irq_wake(srv->irq);\r\n}\r\ndata->suspend_level = PME_SUSPEND_NONE;\r\nspin_unlock_irq(&data->lock);\r\nreturn 0;\r\n}\r\nstatic void pcie_pme_remove(struct pcie_device *srv)\r\n{\r\npcie_pme_suspend(srv);\r\nfree_irq(srv->irq, srv);\r\nkfree(get_service_data(srv));\r\n}\r\nstatic int __init pcie_pme_service_init(void)\r\n{\r\nreturn pcie_port_service_register(&pcie_pme_driver);\r\n}
