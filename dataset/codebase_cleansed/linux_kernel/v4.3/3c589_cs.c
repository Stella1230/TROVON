static int tc589_probe(struct pcmcia_device *link)\r\n{\r\nstruct el3_private *lp;\r\nstruct net_device *dev;\r\ndev_dbg(&link->dev, "3c589_attach()\n");\r\ndev = alloc_etherdev(sizeof(struct el3_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlink->priv = dev;\r\nlp->p_dev = link;\r\nspin_lock_init(&lp->lock);\r\nlink->resource[0]->end = 16;\r\nlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;\r\nlink->config_flags |= CONF_ENABLE_IRQ;\r\nlink->config_index = 1;\r\ndev->netdev_ops = &el3_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\nreturn tc589_config(link);\r\n}\r\nstatic void tc589_detach(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\ndev_dbg(&link->dev, "3c589_detach\n");\r\nunregister_netdev(dev);\r\ntc589_release(link);\r\nfree_netdev(dev);\r\n}\r\nstatic int tc589_config(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\n__be16 *phys_addr;\r\nint ret, i, j, multi = 0, fifo;\r\nunsigned int ioaddr;\r\nstatic const char * const ram_split[] = {"5:3", "3:1", "1:1", "3:5"};\r\nu8 *buf;\r\nsize_t len;\r\ndev_dbg(&link->dev, "3c589_config\n");\r\nphys_addr = (__be16 *)dev->dev_addr;\r\nif (link->manf_id != MANFID_3COM)\r\ndev_info(&link->dev, "hmmm, is this really a 3Com card??\n");\r\nmulti = (link->card_id == PRODID_3COM_3C562);\r\nlink->io_lines = 16;\r\nfor (i = j = 0; j < 0x400; j += 0x10) {\r\nif (multi && (j & 0x80))\r\ncontinue;\r\nlink->resource[0]->start = j ^ 0x300;\r\ni = pcmcia_request_io(link);\r\nif (i == 0)\r\nbreak;\r\n}\r\nif (i != 0)\r\ngoto failed;\r\nret = pcmcia_request_irq(link, el3_interrupt);\r\nif (ret)\r\ngoto failed;\r\nret = pcmcia_enable_device(link);\r\nif (ret)\r\ngoto failed;\r\ndev->irq = link->irq;\r\ndev->base_addr = link->resource[0]->start;\r\nioaddr = dev->base_addr;\r\nEL3WINDOW(0);\r\nlen = pcmcia_get_tuple(link, 0x88, &buf);\r\nif (buf && len >= 6) {\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(le16_to_cpu(buf[i*2]));\r\nkfree(buf);\r\n} else {\r\nkfree(buf);\r\nfor (i = 0; i < 3; i++)\r\nphys_addr[i] = htons(read_eeprom(ioaddr, i));\r\nif (phys_addr[0] == htons(0x6060)) {\r\ndev_err(&link->dev, "IO port conflict at 0x%03lx-0x%03lx\n",\r\ndev->base_addr, dev->base_addr+15);\r\ngoto failed;\r\n}\r\n}\r\noutw(0x3f00, ioaddr + 8);\r\nfifo = inl(ioaddr);\r\nif ((if_port >= 0) && (if_port <= 3))\r\ndev->if_port = if_port;\r\nelse\r\ndev_err(&link->dev, "invalid if_port requested\n");\r\nSET_NETDEV_DEV(dev, &link->dev);\r\nif (register_netdev(dev) != 0) {\r\ndev_err(&link->dev, "register_netdev() failed\n");\r\ngoto failed;\r\n}\r\nnetdev_info(dev, "3Com 3c%s, io %#3lx, irq %d, hw_addr %pM\n",\r\n(multi ? "562" : "589"), dev->base_addr, dev->irq,\r\ndev->dev_addr);\r\nnetdev_info(dev, " %dK FIFO split %s Rx:Tx, %s xcvr\n",\r\n(fifo & 7) ? 32 : 8, ram_split[(fifo >> 16) & 3],\r\nif_names[dev->if_port]);\r\nreturn 0;\r\nfailed:\r\ntc589_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void tc589_release(struct pcmcia_device *link)\r\n{\r\npcmcia_disable_device(link);\r\n}\r\nstatic int tc589_suspend(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open)\r\nnetif_device_detach(dev);\r\nreturn 0;\r\n}\r\nstatic int tc589_resume(struct pcmcia_device *link)\r\n{\r\nstruct net_device *dev = link->priv;\r\nif (link->open) {\r\ntc589_reset(dev);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void tc589_wait_for_completion(struct net_device *dev, int cmd)\r\n{\r\nint i = 100;\r\noutw(cmd, dev->base_addr + EL3_CMD);\r\nwhile (--i > 0)\r\nif (!(inw(dev->base_addr + EL3_STATUS) & 0x1000))\r\nbreak;\r\nif (i == 0)\r\nnetdev_warn(dev, "command 0x%04x did not complete!\n", cmd);\r\n}\r\nstatic u16 read_eeprom(unsigned int ioaddr, int index)\r\n{\r\nint i;\r\noutw(EEPROM_READ + index, ioaddr + 10);\r\nfor (i = 1620; i >= 0; i--)\r\nif ((inw(ioaddr + 10) & EEPROM_BUSY) == 0)\r\nbreak;\r\nreturn inw(ioaddr + 12);\r\n}\r\nstatic void tc589_set_xcvr(struct net_device *dev, int if_port)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nEL3WINDOW(0);\r\nswitch (if_port) {\r\ncase 0:\r\ncase 1:\r\noutw(0, ioaddr + 6);\r\nbreak;\r\ncase 2:\r\noutw(3<<14, ioaddr + 6);\r\nbreak;\r\ncase 3:\r\noutw(1<<14, ioaddr + 6);\r\nbreak;\r\n}\r\noutw((if_port == 2) ? StartCoax : StopCoax, ioaddr + EL3_CMD);\r\nEL3WINDOW(4);\r\noutw(MEDIA_LED | ((if_port < 2) ? MEDIA_TP : 0), ioaddr + WN4_MEDIA);\r\nEL3WINDOW(1);\r\nif (if_port == 2)\r\nlp->media_status = ((dev->if_port == 0) ? 0x8000 : 0x4000);\r\nelse\r\nlp->media_status = ((dev->if_port == 0) ? 0x4010 : 0x8800);\r\n}\r\nstatic void dump_status(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nEL3WINDOW(1);\r\nnetdev_info(dev, " irq status %04x, rx status %04x, tx status %02x tx free %04x\n",\r\ninw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS),\r\ninb(ioaddr+TX_STATUS), inw(ioaddr+TX_FREE));\r\nEL3WINDOW(4);\r\nnetdev_info(dev, " diagnostics: fifo %04x net %04x ethernet %04x media %04x\n",\r\ninw(ioaddr+0x04), inw(ioaddr+0x06), inw(ioaddr+0x08),\r\ninw(ioaddr+0x0a));\r\nEL3WINDOW(1);\r\n}\r\nstatic void tc589_reset(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nint i;\r\nEL3WINDOW(0);\r\noutw(0x0001, ioaddr + 4);\r\noutw(0x3f00, ioaddr + 8);\r\nEL3WINDOW(2);\r\nfor (i = 0; i < 6; i++)\r\noutb(dev->dev_addr[i], ioaddr + i);\r\ntc589_set_xcvr(dev, dev->if_port);\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(6);\r\nfor (i = 0; i < 9; i++)\r\ninb(ioaddr+i);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(1);\r\nset_rx_mode(dev);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\noutw(SetStatusEnb | 0xff, ioaddr + EL3_CMD);\r\noutw(AckIntr | IntLatch | TxAvailable | RxEarly | IntReq,\r\nioaddr + EL3_CMD);\r\noutw(SetIntrEnb | IntLatch | TxAvailable | RxComplete | StatsFull\r\n| AdapterFailure, ioaddr + EL3_CMD);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nsnprintf(info->bus_info, sizeof(info->bus_info),\r\n"PCMCIA 0x%lx", dev->base_addr);\r\n}\r\nstatic int el3_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\r\nif (map->port <= 3) {\r\ndev->if_port = map->port;\r\nnetdev_info(dev, "switched to %s port\n", if_names[dev->if_port]);\r\ntc589_set_xcvr(dev, dev->if_port);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int el3_open(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\nif (!pcmcia_dev_present(link))\r\nreturn -ENODEV;\r\nlink->open++;\r\nnetif_start_queue(dev);\r\ntc589_reset(dev);\r\nsetup_timer(&lp->media, media_check, (unsigned long)dev);\r\nmod_timer(&lp->media, jiffies + HZ);\r\ndev_dbg(&link->dev, "%s: opened, status %4.4x.\n",\r\ndev->name, inw(dev->base_addr + EL3_STATUS));\r\nreturn 0;\r\n}\r\nstatic void el3_tx_timeout(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nnetdev_warn(dev, "Transmit timed out!\n");\r\ndump_status(dev);\r\ndev->stats.tx_errors++;\r\ndev->trans_start = jiffies;\r\ntc589_wait_for_completion(dev, TxReset);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void pop_tx_status(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nint i;\r\nfor (i = 32; i > 0; i--) {\r\nu_char tx_status = inb(ioaddr + TX_STATUS);\r\nif (!(tx_status & 0x84))\r\nbreak;\r\nif (tx_status & 0x30)\r\ntc589_wait_for_completion(dev, TxReset);\r\nif (tx_status & 0x38) {\r\nnetdev_dbg(dev, "transmit error: status 0x%02x\n", tx_status);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\ndev->stats.tx_aborted_errors++;\r\n}\r\noutb(0x00, ioaddr + TX_STATUS);\r\n}\r\n}\r\nstatic netdev_tx_t el3_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nstruct el3_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nnetdev_dbg(dev, "el3_start_xmit(length = %ld) called, status %4.4x.\n",\r\n(long)skb->len, inw(ioaddr + EL3_STATUS));\r\nspin_lock_irqsave(&priv->lock, flags);\r\ndev->stats.tx_bytes += skb->len;\r\noutw(skb->len, ioaddr + TX_FIFO);\r\noutw(0x00, ioaddr + TX_FIFO);\r\noutsl(ioaddr + TX_FIFO, skb->data, (skb->len + 3) >> 2);\r\nif (inw(ioaddr + TX_FREE) <= 1536) {\r\nnetif_stop_queue(dev);\r\noutw(SetTxThreshold + 1536, ioaddr + EL3_CMD);\r\n}\r\npop_tx_status(dev);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic irqreturn_t el3_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr;\r\n__u16 status;\r\nint i = 0, handled = 1;\r\nif (!netif_device_present(dev))\r\nreturn IRQ_NONE;\r\nioaddr = dev->base_addr;\r\nnetdev_dbg(dev, "interrupt, status %4.4x.\n", inw(ioaddr + EL3_STATUS));\r\nspin_lock(&lp->lock);\r\nwhile ((status = inw(ioaddr + EL3_STATUS)) &\r\n(IntLatch | RxComplete | StatsFull)) {\r\nif ((status & 0xe000) != 0x2000) {\r\nnetdev_dbg(dev, "interrupt from dead card\n");\r\nhandled = 0;\r\nbreak;\r\n}\r\nif (status & RxComplete)\r\nel3_rx(dev);\r\nif (status & TxAvailable) {\r\nnetdev_dbg(dev, " TX room bit was handled.\n");\r\noutw(AckIntr | TxAvailable, ioaddr + EL3_CMD);\r\nnetif_wake_queue(dev);\r\n}\r\nif (status & TxComplete)\r\npop_tx_status(dev);\r\nif (status & (AdapterFailure | RxEarly | StatsFull)) {\r\nif (status & StatsFull)\r\nupdate_stats(dev);\r\nif (status & RxEarly) {\r\nel3_rx(dev);\r\noutw(AckIntr | RxEarly, ioaddr + EL3_CMD);\r\n}\r\nif (status & AdapterFailure) {\r\nu16 fifo_diag;\r\nEL3WINDOW(4);\r\nfifo_diag = inw(ioaddr + 4);\r\nEL3WINDOW(1);\r\nnetdev_warn(dev, "adapter failure, FIFO diagnostic register %04x.\n",\r\nfifo_diag);\r\nif (fifo_diag & 0x0400) {\r\ntc589_wait_for_completion(dev, TxReset);\r\noutw(TxEnable, ioaddr + EL3_CMD);\r\n}\r\nif (fifo_diag & 0x2000) {\r\ntc589_wait_for_completion(dev, RxReset);\r\nset_rx_mode(dev);\r\noutw(RxEnable, ioaddr + EL3_CMD);\r\n}\r\noutw(AckIntr | AdapterFailure, ioaddr + EL3_CMD);\r\n}\r\n}\r\nif (++i > 10) {\r\nnetdev_err(dev, "infinite loop in interrupt, status %4.4x.\n",\r\nstatus);\r\noutw(AckIntr | 0xFF, ioaddr + EL3_CMD);\r\nbreak;\r\n}\r\noutw(AckIntr | IntReq | IntLatch, ioaddr + EL3_CMD);\r\n}\r\nlp->last_irq = jiffies;\r\nspin_unlock(&lp->lock);\r\nnetdev_dbg(dev, "exiting interrupt, status %4.4x.\n",\r\ninw(ioaddr + EL3_STATUS));\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void media_check(unsigned long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *)(arg);\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned int ioaddr = dev->base_addr;\r\nu16 media, errs;\r\nunsigned long flags;\r\nif (!netif_device_present(dev))\r\ngoto reschedule;\r\nif ((inw(ioaddr + EL3_STATUS) & IntLatch) &&\r\n(inb(ioaddr + EL3_TIMER) == 0xff)) {\r\nif (!lp->fast_poll)\r\nnetdev_warn(dev, "interrupt(s) dropped!\n");\r\nlocal_irq_save(flags);\r\nel3_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\nlp->fast_poll = HZ;\r\n}\r\nif (lp->fast_poll) {\r\nlp->fast_poll--;\r\nlp->media.expires = jiffies + HZ/100;\r\nadd_timer(&lp->media);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nEL3WINDOW(4);\r\nmedia = inw(ioaddr+WN4_MEDIA) & 0xc810;\r\nif (time_before(jiffies, lp->last_irq + HZ)) {\r\nmedia &= ~0x0010;\r\n} else {\r\nEL3WINDOW(6);\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nerrs = inb(ioaddr + 0);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\ndev->stats.tx_carrier_errors += errs;\r\nif (errs || (lp->media_status & 0x0010))\r\nmedia |= 0x0010;\r\n}\r\nif (media != lp->media_status) {\r\nif ((media & lp->media_status & 0x8000) &&\r\n((lp->media_status ^ media) & 0x0800))\r\nnetdev_info(dev, "%s link beat\n",\r\n(lp->media_status & 0x0800 ? "lost" : "found"));\r\nelse if ((media & lp->media_status & 0x4000) &&\r\n((lp->media_status ^ media) & 0x0010))\r\nnetdev_info(dev, "coax cable %s\n",\r\n(lp->media_status & 0x0010 ? "ok" : "problem"));\r\nif (dev->if_port == 0) {\r\nif (media & 0x8000) {\r\nif (media & 0x0800)\r\nnetdev_info(dev, "flipped to 10baseT\n");\r\nelse\r\ntc589_set_xcvr(dev, 2);\r\n} else if (media & 0x4000) {\r\nif (media & 0x0010)\r\ntc589_set_xcvr(dev, 1);\r\nelse\r\nnetdev_info(dev, "flipped to 10base2\n");\r\n}\r\n}\r\nlp->media_status = media;\r\n}\r\nEL3WINDOW(1);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreschedule:\r\nlp->media.expires = jiffies + HZ;\r\nadd_timer(&lp->media);\r\n}\r\nstatic struct net_device_stats *el3_get_stats(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nunsigned long flags;\r\nstruct pcmcia_device *link = lp->p_dev;\r\nif (pcmcia_dev_present(link)) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\nupdate_stats(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic void update_stats(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nnetdev_dbg(dev, "updating the statistics.\n");\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\nEL3WINDOW(6);\r\ndev->stats.tx_carrier_errors += inb(ioaddr + 0);\r\ndev->stats.tx_heartbeat_errors += inb(ioaddr + 1);\r\ninb(ioaddr + 2);\r\ndev->stats.collisions += inb(ioaddr + 3);\r\ndev->stats.tx_window_errors += inb(ioaddr + 4);\r\ndev->stats.rx_fifo_errors += inb(ioaddr + 5);\r\ndev->stats.tx_packets += inb(ioaddr + 6);\r\ninb(ioaddr + 7);\r\ninb(ioaddr + 8);\r\ninw(ioaddr + 10);\r\ninw(ioaddr + 12);\r\nEL3WINDOW(1);\r\noutw(StatsEnable, ioaddr + EL3_CMD);\r\n}\r\nstatic int el3_rx(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nint worklimit = 32;\r\nshort rx_status;\r\nnetdev_dbg(dev, "in rx_packet(), status %4.4x, rx_status %4.4x.\n",\r\ninw(ioaddr+EL3_STATUS), inw(ioaddr+RX_STATUS));\r\nwhile (!((rx_status = inw(ioaddr + RX_STATUS)) & 0x8000) &&\r\nworklimit > 0) {\r\nworklimit--;\r\nif (rx_status & 0x4000) {\r\nshort error = rx_status & 0x3800;\r\ndev->stats.rx_errors++;\r\nswitch (error) {\r\ncase 0x0000:\r\ndev->stats.rx_over_errors++;\r\nbreak;\r\ncase 0x0800:\r\ndev->stats.rx_length_errors++;\r\nbreak;\r\ncase 0x1000:\r\ndev->stats.rx_frame_errors++;\r\nbreak;\r\ncase 0x1800:\r\ndev->stats.rx_length_errors++;\r\nbreak;\r\ncase 0x2000:\r\ndev->stats.rx_frame_errors++;\r\nbreak;\r\ncase 0x2800:\r\ndev->stats.rx_crc_errors++;\r\nbreak;\r\n}\r\n} else {\r\nshort pkt_len = rx_status & 0x7ff;\r\nstruct sk_buff *skb;\r\nskb = netdev_alloc_skb(dev, pkt_len + 5);\r\nnetdev_dbg(dev, " Receiving packet size %d status %4.4x.\n",\r\npkt_len, rx_status);\r\nif (skb != NULL) {\r\nskb_reserve(skb, 2);\r\ninsl(ioaddr+RX_FIFO, skb_put(skb, pkt_len),\r\n(pkt_len+3)>>2);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += pkt_len;\r\n} else {\r\nnetdev_dbg(dev, "couldn't allocate a sk_buff of size %d.\n",\r\npkt_len);\r\ndev->stats.rx_dropped++;\r\n}\r\n}\r\ntc589_wait_for_completion(dev, RxDiscard);\r\n}\r\nif (worklimit == 0)\r\nnetdev_warn(dev, "too much work in el3_rx!\n");\r\nreturn 0;\r\n}\r\nstatic void set_rx_mode(struct net_device *dev)\r\n{\r\nunsigned int ioaddr = dev->base_addr;\r\nu16 opts = SetRxFilter | RxStation | RxBroadcast;\r\nif (dev->flags & IFF_PROMISC)\r\nopts |= RxMulticast | RxProm;\r\nelse if (!netdev_mc_empty(dev) || (dev->flags & IFF_ALLMULTI))\r\nopts |= RxMulticast;\r\noutw(opts, ioaddr + EL3_CMD);\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct el3_private *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nset_rx_mode(dev);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int el3_close(struct net_device *dev)\r\n{\r\nstruct el3_private *lp = netdev_priv(dev);\r\nstruct pcmcia_device *link = lp->p_dev;\r\nunsigned int ioaddr = dev->base_addr;\r\ndev_dbg(&link->dev, "%s: shutting down ethercard.\n", dev->name);\r\nif (pcmcia_dev_present(link)) {\r\noutw(StatsDisable, ioaddr + EL3_CMD);\r\noutw(RxDisable, ioaddr + EL3_CMD);\r\noutw(TxDisable, ioaddr + EL3_CMD);\r\nif (dev->if_port == 2)\r\noutw(StopCoax, ioaddr + EL3_CMD);\r\nelse if (dev->if_port == 1) {\r\nEL3WINDOW(4);\r\noutw(0, ioaddr + WN4_MEDIA);\r\n}\r\nEL3WINDOW(0);\r\noutw(0x0f00, ioaddr + WN0_IRQ);\r\nif ((inw(ioaddr+EL3_STATUS) & 0xe000) == 0x2000)\r\nupdate_stats(dev);\r\n}\r\nlink->open--;\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&lp->media);\r\nreturn 0;\r\n}
