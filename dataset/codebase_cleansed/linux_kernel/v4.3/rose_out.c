static void rose_send_iframe(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nif (skb == NULL)\r\nreturn;\r\nskb->data[2] |= (rose->vr << 5) & 0xE0;\r\nskb->data[2] |= (rose->vs << 1) & 0x0E;\r\nrose_start_idletimer(sk);\r\nrose_transmit_link(skb, rose->neighbour);\r\n}\r\nvoid rose_kick(struct sock *sk)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nstruct sk_buff *skb, *skbn;\r\nunsigned short start, end;\r\nif (rose->state != ROSE_STATE_3)\r\nreturn;\r\nif (rose->condition & ROSE_COND_PEER_RX_BUSY)\r\nreturn;\r\nif (!skb_peek(&sk->sk_write_queue))\r\nreturn;\r\nstart = (skb_peek(&rose->ack_queue) == NULL) ? rose->va : rose->vs;\r\nend = (rose->va + sysctl_rose_window_size) % ROSE_MODULUS;\r\nif (start == end)\r\nreturn;\r\nrose->vs = start;\r\nskb = skb_dequeue(&sk->sk_write_queue);\r\ndo {\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\r\nskb_queue_head(&sk->sk_write_queue, skb);\r\nbreak;\r\n}\r\nskb_set_owner_w(skbn, sk);\r\nrose_send_iframe(sk, skbn);\r\nrose->vs = (rose->vs + 1) % ROSE_MODULUS;\r\nskb_queue_tail(&rose->ack_queue, skb);\r\n} while (rose->vs != end &&\r\n(skb = skb_dequeue(&sk->sk_write_queue)) != NULL);\r\nrose->vl = rose->vr;\r\nrose->condition &= ~ROSE_COND_ACK_PENDING;\r\nrose_stop_timer(sk);\r\n}\r\nvoid rose_enquiry_response(struct sock *sk)\r\n{\r\nstruct rose_sock *rose = rose_sk(sk);\r\nif (rose->condition & ROSE_COND_OWN_RX_BUSY)\r\nrose_write_internal(sk, ROSE_RNR);\r\nelse\r\nrose_write_internal(sk, ROSE_RR);\r\nrose->vl = rose->vr;\r\nrose->condition &= ~ROSE_COND_ACK_PENDING;\r\nrose_stop_timer(sk);\r\n}
