static void cfs_cpu_core_siblings(int cpu, cpumask_t *mask)\r\n{\r\ncpumask_copy(mask, topology_core_cpumask(cpu));\r\n}\r\nstatic void cfs_cpu_ht_siblings(int cpu, cpumask_t *mask)\r\n{\r\ncpumask_copy(mask, topology_sibling_cpumask(cpu));\r\n}\r\nstatic void cfs_node_to_cpumask(int node, cpumask_t *mask)\r\n{\r\ncpumask_copy(mask, cpumask_of_node(node));\r\n}\r\nvoid\r\ncfs_cpt_table_free(struct cfs_cpt_table *cptab)\r\n{\r\nint i;\r\nif (cptab->ctb_cpu2cpt != NULL) {\r\nLIBCFS_FREE(cptab->ctb_cpu2cpt,\r\nnum_possible_cpus() *\r\nsizeof(cptab->ctb_cpu2cpt[0]));\r\n}\r\nfor (i = 0; cptab->ctb_parts != NULL && i < cptab->ctb_nparts; i++) {\r\nstruct cfs_cpu_partition *part = &cptab->ctb_parts[i];\r\nif (part->cpt_nodemask != NULL) {\r\nLIBCFS_FREE(part->cpt_nodemask,\r\nsizeof(*part->cpt_nodemask));\r\n}\r\nif (part->cpt_cpumask != NULL)\r\nLIBCFS_FREE(part->cpt_cpumask, cpumask_size());\r\n}\r\nif (cptab->ctb_parts != NULL) {\r\nLIBCFS_FREE(cptab->ctb_parts,\r\ncptab->ctb_nparts * sizeof(cptab->ctb_parts[0]));\r\n}\r\nif (cptab->ctb_nodemask != NULL)\r\nLIBCFS_FREE(cptab->ctb_nodemask, sizeof(*cptab->ctb_nodemask));\r\nif (cptab->ctb_cpumask != NULL)\r\nLIBCFS_FREE(cptab->ctb_cpumask, cpumask_size());\r\nLIBCFS_FREE(cptab, sizeof(*cptab));\r\n}\r\nstruct cfs_cpt_table *\r\ncfs_cpt_table_alloc(unsigned int ncpt)\r\n{\r\nstruct cfs_cpt_table *cptab;\r\nint i;\r\nLIBCFS_ALLOC(cptab, sizeof(*cptab));\r\nif (cptab == NULL)\r\nreturn NULL;\r\ncptab->ctb_nparts = ncpt;\r\nLIBCFS_ALLOC(cptab->ctb_cpumask, cpumask_size());\r\nLIBCFS_ALLOC(cptab->ctb_nodemask, sizeof(*cptab->ctb_nodemask));\r\nif (cptab->ctb_cpumask == NULL || cptab->ctb_nodemask == NULL)\r\ngoto failed;\r\nLIBCFS_ALLOC(cptab->ctb_cpu2cpt,\r\nnum_possible_cpus() * sizeof(cptab->ctb_cpu2cpt[0]));\r\nif (cptab->ctb_cpu2cpt == NULL)\r\ngoto failed;\r\nmemset(cptab->ctb_cpu2cpt, -1,\r\nnum_possible_cpus() * sizeof(cptab->ctb_cpu2cpt[0]));\r\nLIBCFS_ALLOC(cptab->ctb_parts, ncpt * sizeof(cptab->ctb_parts[0]));\r\nif (cptab->ctb_parts == NULL)\r\ngoto failed;\r\nfor (i = 0; i < ncpt; i++) {\r\nstruct cfs_cpu_partition *part = &cptab->ctb_parts[i];\r\nLIBCFS_ALLOC(part->cpt_cpumask, cpumask_size());\r\nLIBCFS_ALLOC(part->cpt_nodemask, sizeof(*part->cpt_nodemask));\r\nif (part->cpt_cpumask == NULL || part->cpt_nodemask == NULL)\r\ngoto failed;\r\n}\r\nspin_lock(&cpt_data.cpt_lock);\r\ncptab->ctb_version = cpt_data.cpt_version;\r\nspin_unlock(&cpt_data.cpt_lock);\r\nreturn cptab;\r\nfailed:\r\ncfs_cpt_table_free(cptab);\r\nreturn NULL;\r\n}\r\nint\r\ncfs_cpt_table_print(struct cfs_cpt_table *cptab, char *buf, int len)\r\n{\r\nchar *tmp = buf;\r\nint rc = 0;\r\nint i;\r\nint j;\r\nfor (i = 0; i < cptab->ctb_nparts; i++) {\r\nif (len > 0) {\r\nrc = snprintf(tmp, len, "%d\t: ", i);\r\nlen -= rc;\r\n}\r\nif (len <= 0) {\r\nrc = -EFBIG;\r\ngoto out;\r\n}\r\ntmp += rc;\r\nfor_each_cpu(j, cptab->ctb_parts[i].cpt_cpumask) {\r\nrc = snprintf(tmp, len, "%d ", j);\r\nlen -= rc;\r\nif (len <= 0) {\r\nrc = -EFBIG;\r\ngoto out;\r\n}\r\ntmp += rc;\r\n}\r\n*tmp = '\n';\r\ntmp++;\r\nlen--;\r\n}\r\nout:\r\nif (rc < 0)\r\nreturn rc;\r\nreturn tmp - buf;\r\n}\r\nint\r\ncfs_cpt_number(struct cfs_cpt_table *cptab)\r\n{\r\nreturn cptab->ctb_nparts;\r\n}\r\nint\r\ncfs_cpt_weight(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\nLASSERT(cpt == CFS_CPT_ANY || (cpt >= 0 && cpt < cptab->ctb_nparts));\r\nreturn cpt == CFS_CPT_ANY ?\r\ncpumask_weight(cptab->ctb_cpumask) :\r\ncpumask_weight(cptab->ctb_parts[cpt].cpt_cpumask);\r\n}\r\nint\r\ncfs_cpt_online(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\nLASSERT(cpt == CFS_CPT_ANY || (cpt >= 0 && cpt < cptab->ctb_nparts));\r\nreturn cpt == CFS_CPT_ANY ?\r\ncpumask_any_and(cptab->ctb_cpumask,\r\ncpu_online_mask) < nr_cpu_ids :\r\ncpumask_any_and(cptab->ctb_parts[cpt].cpt_cpumask,\r\ncpu_online_mask) < nr_cpu_ids;\r\n}\r\ncpumask_t *\r\ncfs_cpt_cpumask(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\nLASSERT(cpt == CFS_CPT_ANY || (cpt >= 0 && cpt < cptab->ctb_nparts));\r\nreturn cpt == CFS_CPT_ANY ?\r\ncptab->ctb_cpumask : cptab->ctb_parts[cpt].cpt_cpumask;\r\n}\r\nnodemask_t *\r\ncfs_cpt_nodemask(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\nLASSERT(cpt == CFS_CPT_ANY || (cpt >= 0 && cpt < cptab->ctb_nparts));\r\nreturn cpt == CFS_CPT_ANY ?\r\ncptab->ctb_nodemask : cptab->ctb_parts[cpt].cpt_nodemask;\r\n}\r\nint\r\ncfs_cpt_set_cpu(struct cfs_cpt_table *cptab, int cpt, int cpu)\r\n{\r\nint node;\r\nLASSERT(cpt >= 0 && cpt < cptab->ctb_nparts);\r\nif (cpu < 0 || cpu >= nr_cpu_ids || !cpu_online(cpu)) {\r\nCDEBUG(D_INFO, "CPU %d is invalid or it's offline\n", cpu);\r\nreturn 0;\r\n}\r\nif (cptab->ctb_cpu2cpt[cpu] != -1) {\r\nCDEBUG(D_INFO, "CPU %d is already in partition %d\n",\r\ncpu, cptab->ctb_cpu2cpt[cpu]);\r\nreturn 0;\r\n}\r\ncptab->ctb_cpu2cpt[cpu] = cpt;\r\nLASSERT(!cpumask_test_cpu(cpu, cptab->ctb_cpumask));\r\nLASSERT(!cpumask_test_cpu(cpu, cptab->ctb_parts[cpt].cpt_cpumask));\r\ncpumask_set_cpu(cpu, cptab->ctb_cpumask);\r\ncpumask_set_cpu(cpu, cptab->ctb_parts[cpt].cpt_cpumask);\r\nnode = cpu_to_node(cpu);\r\nif (!node_isset(node, *cptab->ctb_nodemask))\r\nnode_set(node, *cptab->ctb_nodemask);\r\nif (!node_isset(node, *cptab->ctb_parts[cpt].cpt_nodemask))\r\nnode_set(node, *cptab->ctb_parts[cpt].cpt_nodemask);\r\nreturn 1;\r\n}\r\nvoid\r\ncfs_cpt_unset_cpu(struct cfs_cpt_table *cptab, int cpt, int cpu)\r\n{\r\nint node;\r\nint i;\r\nLASSERT(cpt == CFS_CPT_ANY || (cpt >= 0 && cpt < cptab->ctb_nparts));\r\nif (cpu < 0 || cpu >= nr_cpu_ids) {\r\nCDEBUG(D_INFO, "Invalid CPU id %d\n", cpu);\r\nreturn;\r\n}\r\nif (cpt == CFS_CPT_ANY) {\r\ncpt = cptab->ctb_cpu2cpt[cpu];\r\nif (cpt < 0) {\r\nCDEBUG(D_INFO, "Try to unset cpu %d which is not in CPT-table %p\n",\r\ncpt, cptab);\r\nreturn;\r\n}\r\n} else if (cpt != cptab->ctb_cpu2cpt[cpu]) {\r\nCDEBUG(D_INFO,\r\n"CPU %d is not in cpu-partition %d\n", cpu, cpt);\r\nreturn;\r\n}\r\nLASSERT(cpumask_test_cpu(cpu, cptab->ctb_parts[cpt].cpt_cpumask));\r\nLASSERT(cpumask_test_cpu(cpu, cptab->ctb_cpumask));\r\ncpumask_clear_cpu(cpu, cptab->ctb_parts[cpt].cpt_cpumask);\r\ncpumask_clear_cpu(cpu, cptab->ctb_cpumask);\r\ncptab->ctb_cpu2cpt[cpu] = -1;\r\nnode = cpu_to_node(cpu);\r\nLASSERT(node_isset(node, *cptab->ctb_parts[cpt].cpt_nodemask));\r\nLASSERT(node_isset(node, *cptab->ctb_nodemask));\r\nfor_each_cpu(i, cptab->ctb_parts[cpt].cpt_cpumask) {\r\nif (cpu_to_node(i) == node)\r\nbreak;\r\n}\r\nif (i >= nr_cpu_ids)\r\nnode_clear(node, *cptab->ctb_parts[cpt].cpt_nodemask);\r\nfor_each_cpu(i, cptab->ctb_cpumask) {\r\nif (cpu_to_node(i) == node)\r\nbreak;\r\n}\r\nif (i >= nr_cpu_ids)\r\nnode_clear(node, *cptab->ctb_nodemask);\r\nreturn;\r\n}\r\nint\r\ncfs_cpt_set_cpumask(struct cfs_cpt_table *cptab, int cpt, cpumask_t *mask)\r\n{\r\nint i;\r\nif (cpumask_weight(mask) == 0 ||\r\ncpumask_any_and(mask, cpu_online_mask) >= nr_cpu_ids) {\r\nCDEBUG(D_INFO, "No online CPU is found in the CPU mask for CPU partition %d\n",\r\ncpt);\r\nreturn 0;\r\n}\r\nfor_each_cpu(i, mask) {\r\nif (!cfs_cpt_set_cpu(cptab, cpt, i))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\ncfs_cpt_unset_cpumask(struct cfs_cpt_table *cptab, int cpt, cpumask_t *mask)\r\n{\r\nint i;\r\nfor_each_cpu(i, mask)\r\ncfs_cpt_unset_cpu(cptab, cpt, i);\r\n}\r\nint\r\ncfs_cpt_set_node(struct cfs_cpt_table *cptab, int cpt, int node)\r\n{\r\ncpumask_t *mask;\r\nint rc;\r\nif (node < 0 || node >= MAX_NUMNODES) {\r\nCDEBUG(D_INFO,\r\n"Invalid NUMA id %d for CPU partition %d\n", node, cpt);\r\nreturn 0;\r\n}\r\nmutex_lock(&cpt_data.cpt_mutex);\r\nmask = cpt_data.cpt_cpumask;\r\ncfs_node_to_cpumask(node, mask);\r\nrc = cfs_cpt_set_cpumask(cptab, cpt, mask);\r\nmutex_unlock(&cpt_data.cpt_mutex);\r\nreturn rc;\r\n}\r\nvoid\r\ncfs_cpt_unset_node(struct cfs_cpt_table *cptab, int cpt, int node)\r\n{\r\ncpumask_t *mask;\r\nif (node < 0 || node >= MAX_NUMNODES) {\r\nCDEBUG(D_INFO,\r\n"Invalid NUMA id %d for CPU partition %d\n", node, cpt);\r\nreturn;\r\n}\r\nmutex_lock(&cpt_data.cpt_mutex);\r\nmask = cpt_data.cpt_cpumask;\r\ncfs_node_to_cpumask(node, mask);\r\ncfs_cpt_unset_cpumask(cptab, cpt, mask);\r\nmutex_unlock(&cpt_data.cpt_mutex);\r\n}\r\nint\r\ncfs_cpt_set_nodemask(struct cfs_cpt_table *cptab, int cpt, nodemask_t *mask)\r\n{\r\nint i;\r\nfor_each_node_mask(i, *mask) {\r\nif (!cfs_cpt_set_node(cptab, cpt, i))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\ncfs_cpt_unset_nodemask(struct cfs_cpt_table *cptab, int cpt, nodemask_t *mask)\r\n{\r\nint i;\r\nfor_each_node_mask(i, *mask)\r\ncfs_cpt_unset_node(cptab, cpt, i);\r\n}\r\nvoid\r\ncfs_cpt_clear(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\nint last;\r\nint i;\r\nif (cpt == CFS_CPT_ANY) {\r\nlast = cptab->ctb_nparts - 1;\r\ncpt = 0;\r\n} else {\r\nlast = cpt;\r\n}\r\nfor (; cpt <= last; cpt++) {\r\nfor_each_cpu(i, cptab->ctb_parts[cpt].cpt_cpumask)\r\ncfs_cpt_unset_cpu(cptab, cpt, i);\r\n}\r\n}\r\nint\r\ncfs_cpt_spread_node(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\nnodemask_t *mask;\r\nint weight;\r\nint rotor;\r\nint node;\r\nif (cpt < 0 || cpt >= cptab->ctb_nparts) {\r\nmask = cptab->ctb_nodemask;\r\nrotor = cptab->ctb_spread_rotor++;\r\n} else {\r\nmask = cptab->ctb_parts[cpt].cpt_nodemask;\r\nrotor = cptab->ctb_parts[cpt].cpt_spread_rotor++;\r\n}\r\nweight = nodes_weight(*mask);\r\nLASSERT(weight > 0);\r\nrotor %= weight;\r\nfor_each_node_mask(node, *mask) {\r\nif (rotor-- == 0)\r\nreturn node;\r\n}\r\nLBUG();\r\nreturn 0;\r\n}\r\nint\r\ncfs_cpt_current(struct cfs_cpt_table *cptab, int remap)\r\n{\r\nint cpu = smp_processor_id();\r\nint cpt = cptab->ctb_cpu2cpt[cpu];\r\nif (cpt < 0) {\r\nif (!remap)\r\nreturn cpt;\r\ncpt = cpu % cptab->ctb_nparts;\r\n}\r\nreturn cpt;\r\n}\r\nint\r\ncfs_cpt_of_cpu(struct cfs_cpt_table *cptab, int cpu)\r\n{\r\nLASSERT(cpu >= 0 && cpu < nr_cpu_ids);\r\nreturn cptab->ctb_cpu2cpt[cpu];\r\n}\r\nint\r\ncfs_cpt_bind(struct cfs_cpt_table *cptab, int cpt)\r\n{\r\ncpumask_t *cpumask;\r\nnodemask_t *nodemask;\r\nint rc;\r\nint i;\r\nLASSERT(cpt == CFS_CPT_ANY || (cpt >= 0 && cpt < cptab->ctb_nparts));\r\nif (cpt == CFS_CPT_ANY) {\r\ncpumask = cptab->ctb_cpumask;\r\nnodemask = cptab->ctb_nodemask;\r\n} else {\r\ncpumask = cptab->ctb_parts[cpt].cpt_cpumask;\r\nnodemask = cptab->ctb_parts[cpt].cpt_nodemask;\r\n}\r\nif (cpumask_any_and(cpumask, cpu_online_mask) >= nr_cpu_ids) {\r\nCERROR("No online CPU found in CPU partition %d, did someone do CPU hotplug on system? You might need to reload Lustre modules to keep system working well.\n",\r\ncpt);\r\nreturn -EINVAL;\r\n}\r\nfor_each_online_cpu(i) {\r\nif (cpumask_test_cpu(i, cpumask))\r\ncontinue;\r\nrc = set_cpus_allowed_ptr(current, cpumask);\r\nset_mems_allowed(*nodemask);\r\nif (rc == 0)\r\nschedule();\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncfs_cpt_choose_ncpus(struct cfs_cpt_table *cptab, int cpt,\r\ncpumask_t *node, int number)\r\n{\r\ncpumask_t *socket = NULL;\r\ncpumask_t *core = NULL;\r\nint rc = 0;\r\nint cpu;\r\nLASSERT(number > 0);\r\nif (number >= cpumask_weight(node)) {\r\nwhile (!cpumask_empty(node)) {\r\ncpu = cpumask_first(node);\r\nrc = cfs_cpt_set_cpu(cptab, cpt, cpu);\r\nif (!rc)\r\nreturn -EINVAL;\r\ncpumask_clear_cpu(cpu, node);\r\n}\r\nreturn 0;\r\n}\r\nLIBCFS_ALLOC(socket, cpumask_size());\r\nLIBCFS_ALLOC(core, cpumask_size());\r\nif (socket == NULL || core == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nwhile (!cpumask_empty(node)) {\r\ncpu = cpumask_first(node);\r\ncfs_cpu_core_siblings(cpu, socket);\r\ncpumask_and(socket, socket, node);\r\nLASSERT(!cpumask_empty(socket));\r\nwhile (!cpumask_empty(socket)) {\r\nint i;\r\ncfs_cpu_ht_siblings(cpu, core);\r\ncpumask_and(core, core, node);\r\nLASSERT(!cpumask_empty(core));\r\nfor_each_cpu(i, core) {\r\ncpumask_clear_cpu(i, socket);\r\ncpumask_clear_cpu(i, node);\r\nrc = cfs_cpt_set_cpu(cptab, cpt, i);\r\nif (!rc) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (--number == 0)\r\ngoto out;\r\n}\r\ncpu = cpumask_first(socket);\r\n}\r\n}\r\nout:\r\nif (socket != NULL)\r\nLIBCFS_FREE(socket, cpumask_size());\r\nif (core != NULL)\r\nLIBCFS_FREE(core, cpumask_size());\r\nreturn rc;\r\n}\r\nstatic unsigned int\r\ncfs_cpt_num_estimate(void)\r\n{\r\nunsigned nnode = num_online_nodes();\r\nunsigned ncpu = num_online_cpus();\r\nunsigned ncpt;\r\nif (ncpu <= CPT_WEIGHT_MIN) {\r\nncpt = 1;\r\ngoto out;\r\n}\r\nfor (ncpt = 2; ncpu > 2 * ncpt * ncpt; ncpt <<= 1) {}\r\nif (ncpt <= nnode) {\r\nwhile (nnode > ncpt)\r\nnnode >>= 1;\r\n} else {\r\nwhile ((nnode << 1) <= ncpt)\r\nnnode <<= 1;\r\n}\r\nncpt = nnode;\r\nout:\r\n#if (BITS_PER_LONG == 32)\r\nncpt = min(2U, ncpt);\r\n#endif\r\nwhile (ncpu % ncpt != 0)\r\nncpt--;\r\nreturn ncpt;\r\n}\r\nstatic struct cfs_cpt_table *\r\ncfs_cpt_table_create(int ncpt)\r\n{\r\nstruct cfs_cpt_table *cptab = NULL;\r\ncpumask_t *mask = NULL;\r\nint cpt = 0;\r\nint num;\r\nint rc;\r\nint i;\r\nrc = cfs_cpt_num_estimate();\r\nif (ncpt <= 0)\r\nncpt = rc;\r\nif (ncpt > num_online_cpus() || ncpt > 4 * rc) {\r\nCWARN("CPU partition number %d is larger than suggested value (%d), your system may have performance issue or run out of memory while under pressure\n",\r\nncpt, rc);\r\n}\r\nif (num_online_cpus() % ncpt != 0) {\r\nCERROR("CPU number %d is not multiple of cpu_npartition %d, please try different cpu_npartitions value or set pattern string by cpu_pattern=STRING\n",\r\n(int)num_online_cpus(), ncpt);\r\ngoto failed;\r\n}\r\ncptab = cfs_cpt_table_alloc(ncpt);\r\nif (cptab == NULL) {\r\nCERROR("Failed to allocate CPU map(%d)\n", ncpt);\r\ngoto failed;\r\n}\r\nnum = num_online_cpus() / ncpt;\r\nif (num == 0) {\r\nCERROR("CPU changed while setting CPU partition\n");\r\ngoto failed;\r\n}\r\nLIBCFS_ALLOC(mask, cpumask_size());\r\nif (mask == NULL) {\r\nCERROR("Failed to allocate scratch cpumask\n");\r\ngoto failed;\r\n}\r\nfor_each_online_node(i) {\r\ncfs_node_to_cpumask(i, mask);\r\nwhile (!cpumask_empty(mask)) {\r\nstruct cfs_cpu_partition *part;\r\nint n;\r\nif (cpt >= ncpt)\r\ngoto failed;\r\npart = &cptab->ctb_parts[cpt];\r\nn = num - cpumask_weight(part->cpt_cpumask);\r\nLASSERT(n > 0);\r\nrc = cfs_cpt_choose_ncpus(cptab, cpt, mask, n);\r\nif (rc < 0)\r\ngoto failed;\r\nLASSERT(num >= cpumask_weight(part->cpt_cpumask));\r\nif (num == cpumask_weight(part->cpt_cpumask))\r\ncpt++;\r\n}\r\n}\r\nif (cpt != ncpt ||\r\nnum != cpumask_weight(cptab->ctb_parts[ncpt - 1].cpt_cpumask)) {\r\nCERROR("Expect %d(%d) CPU partitions but got %d(%d), CPU hotplug/unplug while setting?\n",\r\ncptab->ctb_nparts, num, cpt,\r\ncpumask_weight(cptab->ctb_parts[ncpt - 1].cpt_cpumask));\r\ngoto failed;\r\n}\r\nLIBCFS_FREE(mask, cpumask_size());\r\nreturn cptab;\r\nfailed:\r\nCERROR("Failed to setup CPU-partition-table with %d CPU-partitions, online HW nodes: %d, HW cpus: %d.\n",\r\nncpt, num_online_nodes(), num_online_cpus());\r\nif (mask != NULL)\r\nLIBCFS_FREE(mask, cpumask_size());\r\nif (cptab != NULL)\r\ncfs_cpt_table_free(cptab);\r\nreturn NULL;\r\n}\r\nstatic struct cfs_cpt_table *\r\ncfs_cpt_table_create_pattern(char *pattern)\r\n{\r\nstruct cfs_cpt_table *cptab;\r\nchar *str = pattern;\r\nint node = 0;\r\nint high;\r\nint ncpt;\r\nint c;\r\nfor (ncpt = 0;; ncpt++) {\r\nstr = strchr(str, '[');\r\nif (str == NULL)\r\nbreak;\r\nstr++;\r\n}\r\nstr = cfs_trimwhite(pattern);\r\nif (*str == 'n' || *str == 'N') {\r\npattern = str + 1;\r\nnode = 1;\r\n}\r\nif (ncpt == 0 ||\r\n(node && ncpt > num_online_nodes()) ||\r\n(!node && ncpt > num_online_cpus())) {\r\nCERROR("Invalid pattern %s, or too many partitions %d\n",\r\npattern, ncpt);\r\nreturn NULL;\r\n}\r\nhigh = node ? MAX_NUMNODES - 1 : nr_cpu_ids - 1;\r\ncptab = cfs_cpt_table_alloc(ncpt);\r\nif (cptab == NULL) {\r\nCERROR("Failed to allocate cpu partition table\n");\r\nreturn NULL;\r\n}\r\nfor (str = cfs_trimwhite(pattern), c = 0;; c++) {\r\nstruct cfs_range_expr *range;\r\nstruct cfs_expr_list *el;\r\nchar *bracket = strchr(str, '[');\r\nint cpt;\r\nint rc;\r\nint i;\r\nint n;\r\nif (bracket == NULL) {\r\nif (*str != 0) {\r\nCERROR("Invalid pattern %s\n", str);\r\ngoto failed;\r\n} else if (c != ncpt) {\r\nCERROR("expect %d partitions but found %d\n",\r\nncpt, c);\r\ngoto failed;\r\n}\r\nbreak;\r\n}\r\nif (sscanf(str, "%d%n", &cpt, &n) < 1) {\r\nCERROR("Invalid cpu pattern %s\n", str);\r\ngoto failed;\r\n}\r\nif (cpt < 0 || cpt >= ncpt) {\r\nCERROR("Invalid partition id %d, total partitions %d\n",\r\ncpt, ncpt);\r\ngoto failed;\r\n}\r\nif (cfs_cpt_weight(cptab, cpt) != 0) {\r\nCERROR("Partition %d has already been set.\n", cpt);\r\ngoto failed;\r\n}\r\nstr = cfs_trimwhite(str + n);\r\nif (str != bracket) {\r\nCERROR("Invalid pattern %s\n", str);\r\ngoto failed;\r\n}\r\nbracket = strchr(str, ']');\r\nif (bracket == NULL) {\r\nCERROR("missing right bracket for cpt %d, %s\n",\r\ncpt, str);\r\ngoto failed;\r\n}\r\nif (cfs_expr_list_parse(str, (bracket - str) + 1,\r\n0, high, &el) != 0) {\r\nCERROR("Can't parse number range: %s\n", str);\r\ngoto failed;\r\n}\r\nlist_for_each_entry(range, &el->el_exprs, re_link) {\r\nfor (i = range->re_lo; i <= range->re_hi; i++) {\r\nif ((i - range->re_lo) % range->re_stride != 0)\r\ncontinue;\r\nrc = node ? cfs_cpt_set_node(cptab, cpt, i) :\r\ncfs_cpt_set_cpu(cptab, cpt, i);\r\nif (!rc) {\r\ncfs_expr_list_free(el);\r\ngoto failed;\r\n}\r\n}\r\n}\r\ncfs_expr_list_free(el);\r\nif (!cfs_cpt_online(cptab, cpt)) {\r\nCERROR("No online CPU is found on partition %d\n", cpt);\r\ngoto failed;\r\n}\r\nstr = cfs_trimwhite(bracket + 1);\r\n}\r\nreturn cptab;\r\nfailed:\r\ncfs_cpt_table_free(cptab);\r\nreturn NULL;\r\n}\r\nstatic int\r\ncfs_cpu_notify(struct notifier_block *self, unsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nbool warn;\r\nswitch (action) {\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\ncase CPU_ONLINE:\r\ncase CPU_ONLINE_FROZEN:\r\nspin_lock(&cpt_data.cpt_lock);\r\ncpt_data.cpt_version++;\r\nspin_unlock(&cpt_data.cpt_lock);\r\ndefault:\r\nif (action != CPU_DEAD && action != CPU_DEAD_FROZEN) {\r\nCDEBUG(D_INFO, "CPU changed [cpu %u action %lx]\n",\r\ncpu, action);\r\nbreak;\r\n}\r\nmutex_lock(&cpt_data.cpt_mutex);\r\ncfs_cpu_ht_siblings(cpu, cpt_data.cpt_cpumask);\r\nwarn = cpumask_any_and(cpt_data.cpt_cpumask,\r\ncpu_online_mask) >= nr_cpu_ids;\r\nmutex_unlock(&cpt_data.cpt_mutex);\r\nCDEBUG(warn ? D_WARNING : D_INFO,\r\n"Lustre: can't support CPU plug-out well now, performance and stability could be impacted [CPU %u action: %lx]\n",\r\ncpu, action);\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nvoid\r\ncfs_cpu_fini(void)\r\n{\r\nif (cfs_cpt_table != NULL)\r\ncfs_cpt_table_free(cfs_cpt_table);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nunregister_hotcpu_notifier(&cfs_cpu_notifier);\r\n#endif\r\nif (cpt_data.cpt_cpumask != NULL)\r\nLIBCFS_FREE(cpt_data.cpt_cpumask, cpumask_size());\r\n}\r\nint\r\ncfs_cpu_init(void)\r\n{\r\nLASSERT(cfs_cpt_table == NULL);\r\nmemset(&cpt_data, 0, sizeof(cpt_data));\r\nLIBCFS_ALLOC(cpt_data.cpt_cpumask, cpumask_size());\r\nif (cpt_data.cpt_cpumask == NULL) {\r\nCERROR("Failed to allocate scratch buffer\n");\r\nreturn -1;\r\n}\r\nspin_lock_init(&cpt_data.cpt_lock);\r\nmutex_init(&cpt_data.cpt_mutex);\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nregister_hotcpu_notifier(&cfs_cpu_notifier);\r\n#endif\r\nif (*cpu_pattern != 0) {\r\ncfs_cpt_table = cfs_cpt_table_create_pattern(cpu_pattern);\r\nif (cfs_cpt_table == NULL) {\r\nCERROR("Failed to create cptab from pattern %s\n",\r\ncpu_pattern);\r\ngoto failed;\r\n}\r\n} else {\r\ncfs_cpt_table = cfs_cpt_table_create(cpu_npartitions);\r\nif (cfs_cpt_table == NULL) {\r\nCERROR("Failed to create ptable with npartitions %d\n",\r\ncpu_npartitions);\r\ngoto failed;\r\n}\r\n}\r\nspin_lock(&cpt_data.cpt_lock);\r\nif (cfs_cpt_table->ctb_version != cpt_data.cpt_version) {\r\nspin_unlock(&cpt_data.cpt_lock);\r\nCERROR("CPU hotplug/unplug during setup\n");\r\ngoto failed;\r\n}\r\nspin_unlock(&cpt_data.cpt_lock);\r\nLCONSOLE(0, "HW CPU cores: %d, npartitions: %d\n",\r\nnum_online_cpus(), cfs_cpt_number(cfs_cpt_table));\r\nreturn 0;\r\nfailed:\r\ncfs_cpu_fini();\r\nreturn -1;\r\n}
