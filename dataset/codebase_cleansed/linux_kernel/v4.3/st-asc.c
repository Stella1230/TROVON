static inline struct asc_port *to_asc_port(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct asc_port, port);\r\n}\r\nstatic inline u32 asc_in(struct uart_port *port, u32 offset)\r\n{\r\n#ifdef readl_relaxed\r\nreturn readl_relaxed(port->membase + offset);\r\n#else\r\nreturn readl(port->membase + offset);\r\n#endif\r\n}\r\nstatic inline void asc_out(struct uart_port *port, u32 offset, u32 value)\r\n{\r\n#ifdef writel_relaxed\r\nwritel_relaxed(value, port->membase + offset);\r\n#else\r\nwritel(value, port->membase + offset);\r\n#endif\r\n}\r\nstatic inline void asc_disable_tx_interrupts(struct uart_port *port)\r\n{\r\nu32 intenable = asc_in(port, ASC_INTEN) & ~ASC_INTEN_THE;\r\nasc_out(port, ASC_INTEN, intenable);\r\n(void)asc_in(port, ASC_INTEN);\r\n}\r\nstatic inline void asc_enable_tx_interrupts(struct uart_port *port)\r\n{\r\nu32 intenable = asc_in(port, ASC_INTEN) | ASC_INTEN_THE;\r\nasc_out(port, ASC_INTEN, intenable);\r\n}\r\nstatic inline void asc_disable_rx_interrupts(struct uart_port *port)\r\n{\r\nu32 intenable = asc_in(port, ASC_INTEN) & ~ASC_INTEN_RBE;\r\nasc_out(port, ASC_INTEN, intenable);\r\n(void)asc_in(port, ASC_INTEN);\r\n}\r\nstatic inline void asc_enable_rx_interrupts(struct uart_port *port)\r\n{\r\nu32 intenable = asc_in(port, ASC_INTEN) | ASC_INTEN_RBE;\r\nasc_out(port, ASC_INTEN, intenable);\r\n}\r\nstatic inline u32 asc_txfifo_is_empty(struct uart_port *port)\r\n{\r\nreturn asc_in(port, ASC_STA) & ASC_STA_TE;\r\n}\r\nstatic inline u32 asc_txfifo_is_half_empty(struct uart_port *port)\r\n{\r\nreturn asc_in(port, ASC_STA) & ASC_STA_THE;\r\n}\r\nstatic inline const char *asc_port_name(struct uart_port *port)\r\n{\r\nreturn to_platform_device(port->dev)->name;\r\n}\r\nstatic inline unsigned asc_hw_txroom(struct uart_port *port)\r\n{\r\nu32 status = asc_in(port, ASC_STA);\r\nif (status & ASC_STA_THE)\r\nreturn port->fifosize / 2;\r\nelse if (!(status & ASC_STA_TF))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void asc_transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nint txroom;\r\nunsigned char c;\r\ntxroom = asc_hw_txroom(port);\r\nif ((txroom != 0) && port->x_char) {\r\nc = port->x_char;\r\nport->x_char = 0;\r\nasc_out(port, ASC_TXBUF, c);\r\nport->icount.tx++;\r\ntxroom = asc_hw_txroom(port);\r\n}\r\nif (uart_tx_stopped(port)) {\r\nasc_disable_tx_interrupts(port);\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit)) {\r\nasc_disable_tx_interrupts(port);\r\nreturn;\r\n}\r\nif (txroom == 0)\r\nreturn;\r\ndo {\r\nc = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nasc_out(port, ASC_TXBUF, c);\r\nport->icount.tx++;\r\ntxroom--;\r\n} while ((txroom > 0) && (!uart_circ_empty(xmit)));\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit))\r\nasc_disable_tx_interrupts(port);\r\n}\r\nstatic void asc_receive_chars(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nunsigned long status;\r\nunsigned long c = 0;\r\nchar flag;\r\nif (port->irq_wake)\r\npm_wakeup_event(tport->tty->dev, 0);\r\nwhile ((status = asc_in(port, ASC_STA)) & ASC_STA_RBF) {\r\nc = asc_in(port, ASC_RXBUF) | ASC_RXBUF_DUMMY_RX;\r\nflag = TTY_NORMAL;\r\nport->icount.rx++;\r\nif ((c & (ASC_RXBUF_FE | ASC_RXBUF_PE)) ||\r\nstatus & ASC_STA_OE) {\r\nif (c & ASC_RXBUF_FE) {\r\nif (c == (ASC_RXBUF_FE | ASC_RXBUF_DUMMY_RX)) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\nc |= ASC_RXBUF_DUMMY_BE;\r\n} else {\r\nport->icount.frame++;\r\n}\r\n} else if (c & ASC_RXBUF_PE) {\r\nport->icount.parity++;\r\n}\r\nif (status & ASC_STA_OE) {\r\nport->icount.overrun++;\r\nc |= ASC_RXBUF_DUMMY_OE;\r\n}\r\nc &= port->read_status_mask;\r\nif (c & ASC_RXBUF_DUMMY_BE)\r\nflag = TTY_BREAK;\r\nelse if (c & ASC_RXBUF_PE)\r\nflag = TTY_PARITY;\r\nelse if (c & ASC_RXBUF_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif (uart_handle_sysrq_char(port, c & 0xff))\r\ncontinue;\r\nuart_insert_char(port, c, ASC_RXBUF_DUMMY_OE, c & 0xff, flag);\r\n}\r\ntty_flip_buffer_push(tport);\r\n}\r\nstatic irqreturn_t asc_interrupt(int irq, void *ptr)\r\n{\r\nstruct uart_port *port = ptr;\r\nu32 status;\r\nspin_lock(&port->lock);\r\nstatus = asc_in(port, ASC_STA);\r\nif (status & ASC_STA_RBF) {\r\nasc_receive_chars(port);\r\n}\r\nif ((status & ASC_STA_THE) &&\r\n(asc_in(port, ASC_INTEN) & ASC_INTEN_THE)) {\r\nasc_transmit_chars(port);\r\n}\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int asc_tx_empty(struct uart_port *port)\r\n{\r\nreturn asc_txfifo_is_empty(port) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic void asc_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int asc_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\n}\r\nstatic void asc_start_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (!uart_circ_empty(xmit))\r\nasc_enable_tx_interrupts(port);\r\n}\r\nstatic void asc_stop_tx(struct uart_port *port)\r\n{\r\nasc_disable_tx_interrupts(port);\r\n}\r\nstatic void asc_stop_rx(struct uart_port *port)\r\n{\r\nasc_disable_rx_interrupts(port);\r\n}\r\nstatic void asc_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int asc_startup(struct uart_port *port)\r\n{\r\nif (request_irq(port->irq, asc_interrupt, IRQF_NO_SUSPEND,\r\nasc_port_name(port), port)) {\r\ndev_err(port->dev, "cannot allocate irq.\n");\r\nreturn -ENODEV;\r\n}\r\nasc_transmit_chars(port);\r\nasc_enable_rx_interrupts(port);\r\nreturn 0;\r\n}\r\nstatic void asc_shutdown(struct uart_port *port)\r\n{\r\nasc_disable_tx_interrupts(port);\r\nasc_disable_rx_interrupts(port);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void asc_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct asc_port *ascport = to_asc_port(port);\r\nunsigned long flags = 0;\r\nu32 ctl;\r\nswitch (state) {\r\ncase UART_PM_STATE_ON:\r\nclk_prepare_enable(ascport->clk);\r\nbreak;\r\ncase UART_PM_STATE_OFF:\r\nspin_lock_irqsave(&port->lock, flags);\r\nctl = asc_in(port, ASC_CTL) & ~ASC_CTL_RUN;\r\nasc_out(port, ASC_CTL, ctl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nclk_disable_unprepare(ascport->clk);\r\nbreak;\r\n}\r\n}\r\nstatic void asc_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct asc_port *ascport = to_asc_port(port);\r\nunsigned int baud;\r\nu32 ctrl_val;\r\ntcflag_t cflag;\r\nunsigned long flags;\r\ntermios->c_cflag &= ~(CMSPAR |\r\n(ascport->hw_flow_control ? 0 : CRTSCTS));\r\nport->uartclk = clk_get_rate(ascport->clk);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\ncflag = termios->c_cflag;\r\nspin_lock_irqsave(&port->lock, flags);\r\nctrl_val = asc_in(port, ASC_CTL);\r\nasc_out(port, ASC_CTL, (ctrl_val & ~ASC_CTL_RUN));\r\nctrl_val = ASC_CTL_RXENABLE | ASC_CTL_FIFOENABLE;\r\nasc_out(port, ASC_TXRESET, 1);\r\nasc_out(port, ASC_RXRESET, 1);\r\nif ((cflag & CSIZE) == CS7) {\r\nctrl_val |= ASC_CTL_MODE_7BIT_PAR;\r\n} else {\r\nctrl_val |= (cflag & PARENB) ? ASC_CTL_MODE_8BIT_PAR :\r\nASC_CTL_MODE_8BIT;\r\n}\r\nctrl_val |= (cflag & CSTOPB) ? ASC_CTL_STOP_2BIT : ASC_CTL_STOP_1BIT;\r\nif (cflag & PARODD)\r\nctrl_val |= ASC_CTL_PARITYODD;\r\nif ((cflag & CRTSCTS))\r\nctrl_val |= ASC_CTL_CTSENABLE;\r\nif ((baud < 19200) && !ascport->force_m1) {\r\nasc_out(port, ASC_BAUDRATE, (port->uartclk / (16 * baud)));\r\n} else {\r\nu64 dividend = (u64)baud * (1 << 16);\r\ndo_div(dividend, port->uartclk / 16);\r\nasc_out(port, ASC_BAUDRATE, dividend);\r\nctrl_val |= ASC_CTL_BAUDMODE;\r\n}\r\nuart_update_timeout(port, cflag, baud);\r\nascport->port.read_status_mask = ASC_RXBUF_DUMMY_OE;\r\nif (termios->c_iflag & INPCK)\r\nascport->port.read_status_mask |= ASC_RXBUF_FE | ASC_RXBUF_PE;\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nascport->port.read_status_mask |= ASC_RXBUF_DUMMY_BE;\r\nascport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nascport->port.ignore_status_mask |= ASC_RXBUF_FE | ASC_RXBUF_PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nascport->port.ignore_status_mask |= ASC_RXBUF_DUMMY_BE;\r\nif (termios->c_iflag & IGNPAR)\r\nascport->port.ignore_status_mask |= ASC_RXBUF_DUMMY_OE;\r\n}\r\nif (!(termios->c_cflag & CREAD))\r\nascport->port.ignore_status_mask |= ASC_RXBUF_DUMMY_RX;\r\nasc_out(port, ASC_TIMEOUT, 20);\r\nasc_out(port, ASC_CTL, (ctrl_val | ASC_CTL_RUN));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *asc_type(struct uart_port *port)\r\n{\r\nreturn (port->type == PORT_ASC) ? DRIVER_NAME : NULL;\r\n}\r\nstatic void asc_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int asc_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void asc_config_port(struct uart_port *port, int flags)\r\n{\r\nif ((flags & UART_CONFIG_TYPE))\r\nport->type = PORT_ASC;\r\n}\r\nstatic int\r\nasc_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int asc_get_poll_char(struct uart_port *port)\r\n{\r\nif (!(asc_in(port, ASC_STA) & ASC_STA_RBF))\r\nreturn NO_POLL_CHAR;\r\nreturn asc_in(port, ASC_RXBUF);\r\n}\r\nstatic void asc_put_poll_char(struct uart_port *port, unsigned char c)\r\n{\r\nwhile (!asc_txfifo_is_half_empty(port))\r\ncpu_relax();\r\nasc_out(port, ASC_TXBUF, c);\r\n}\r\nstatic int asc_init_port(struct asc_port *ascport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct uart_port *port = &ascport->port;\r\nstruct resource *res;\r\nport->iotype = UPIO_MEM;\r\nport->flags = UPF_BOOT_AUTOCONF;\r\nport->ops = &asc_uart_ops;\r\nport->fifosize = ASC_FIFO_SIZE;\r\nport->dev = &pdev->dev;\r\nport->irq = platform_get_irq(pdev, 0);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nport->membase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(port->membase))\r\nreturn PTR_ERR(port->membase);\r\nport->mapbase = res->start;\r\nspin_lock_init(&port->lock);\r\nascport->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (WARN_ON(IS_ERR(ascport->clk)))\r\nreturn -EINVAL;\r\nclk_prepare_enable(ascport->clk);\r\nascport->port.uartclk = clk_get_rate(ascport->clk);\r\nWARN_ON(ascport->port.uartclk == 0);\r\nclk_disable_unprepare(ascport->clk);\r\nreturn 0;\r\n}\r\nstatic struct asc_port *asc_of_get_asc_port(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint id;\r\nif (!np)\r\nreturn NULL;\r\nid = of_alias_get_id(np, ASC_SERIAL_NAME);\r\nif (id < 0)\r\nid = 0;\r\nif (WARN_ON(id >= ASC_MAX_PORTS))\r\nreturn NULL;\r\nasc_ports[id].hw_flow_control = of_property_read_bool(np,\r\n"st,hw-flow-control");\r\nasc_ports[id].force_m1 = of_property_read_bool(np, "st,force_m1");\r\nasc_ports[id].port.line = id;\r\nreturn &asc_ports[id];\r\n}\r\nstatic int asc_serial_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct asc_port *ascport;\r\nascport = asc_of_get_asc_port(pdev);\r\nif (!ascport)\r\nreturn -ENODEV;\r\nret = asc_init_port(ascport, pdev);\r\nif (ret)\r\nreturn ret;\r\nret = uart_add_one_port(&asc_uart_driver, &ascport->port);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, &ascport->port);\r\nreturn 0;\r\n}\r\nstatic int asc_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nreturn uart_remove_one_port(&asc_uart_driver, port);\r\n}\r\nstatic int asc_serial_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nreturn uart_suspend_port(&asc_uart_driver, port);\r\n}\r\nstatic int asc_serial_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct uart_port *port = platform_get_drvdata(pdev);\r\nreturn uart_resume_port(&asc_uart_driver, port);\r\n}\r\nstatic void asc_console_putchar(struct uart_port *port, int ch)\r\n{\r\nunsigned int timeout = 1000000;\r\nwhile (--timeout && !asc_txfifo_is_half_empty(port))\r\nudelay(1);\r\nasc_out(port, ASC_TXBUF, ch);\r\n}\r\nstatic void asc_console_write(struct console *co, const char *s, unsigned count)\r\n{\r\nstruct uart_port *port = &asc_ports[co->index].port;\r\nunsigned long flags;\r\nunsigned long timeout = 1000000;\r\nint locked = 1;\r\nu32 intenable;\r\nlocal_irq_save(flags);\r\nif (port->sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock(&port->lock);\r\nelse\r\nspin_lock(&port->lock);\r\nintenable = asc_in(port, ASC_INTEN);\r\nasc_out(port, ASC_INTEN, 0);\r\n(void)asc_in(port, ASC_INTEN);\r\nuart_console_write(port, s, count, asc_console_putchar);\r\nwhile (--timeout && !asc_txfifo_is_empty(port))\r\nudelay(1);\r\nasc_out(port, ASC_INTEN, intenable);\r\nif (locked)\r\nspin_unlock(&port->lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int asc_console_setup(struct console *co, char *options)\r\n{\r\nstruct asc_port *ascport;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= ASC_MAX_PORTS)\r\nreturn -ENODEV;\r\nascport = &asc_ports[co->index];\r\nif (ascport->port.mapbase == 0 || ascport->port.membase == NULL)\r\nreturn -ENXIO;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&ascport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init asc_init(void)\r\n{\r\nint ret;\r\nstatic char banner[] __initdata =\r\nKERN_INFO "STMicroelectronics ASC driver initialized\n";\r\nprintk(banner);\r\nret = uart_register_driver(&asc_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&asc_serial_driver);\r\nif (ret)\r\nuart_unregister_driver(&asc_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit asc_exit(void)\r\n{\r\nplatform_driver_unregister(&asc_serial_driver);\r\nuart_unregister_driver(&asc_uart_driver);\r\n}
