static int dt9812_read_info(struct comedi_device *dev,\r\nint offset, void *buf, size_t buf_size)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct dt9812_usb_cmd cmd;\r\nint count, ret;\r\ncmd.cmd = cpu_to_le32(DT9812_R_FLASH_DATA);\r\ncmd.u.flash_data_info.address =\r\ncpu_to_le16(DT9812_DIAGS_BOARD_INFO_ADDR + offset);\r\ncmd.u.flash_data_info.numbytes = cpu_to_le16(buf_size);\r\nret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\r\n&cmd, 32, &count, DT9812_USB_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nreturn usb_bulk_msg(usb, usb_rcvbulkpipe(usb, devpriv->cmd_rd.addr),\r\nbuf, buf_size, &count, DT9812_USB_TIMEOUT);\r\n}\r\nstatic int dt9812_read_multiple_registers(struct comedi_device *dev,\r\nint reg_count, u8 *address,\r\nu8 *value)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct dt9812_usb_cmd cmd;\r\nint i, count, ret;\r\ncmd.cmd = cpu_to_le32(DT9812_R_MULTI_BYTE_REG);\r\ncmd.u.read_multi_info.count = reg_count;\r\nfor (i = 0; i < reg_count; i++)\r\ncmd.u.read_multi_info.address[i] = address[i];\r\nret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\r\n&cmd, 32, &count, DT9812_USB_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nreturn usb_bulk_msg(usb, usb_rcvbulkpipe(usb, devpriv->cmd_rd.addr),\r\nvalue, reg_count, &count, DT9812_USB_TIMEOUT);\r\n}\r\nstatic int dt9812_write_multiple_registers(struct comedi_device *dev,\r\nint reg_count, u8 *address,\r\nu8 *value)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct dt9812_usb_cmd cmd;\r\nint i, count;\r\ncmd.cmd = cpu_to_le32(DT9812_W_MULTI_BYTE_REG);\r\ncmd.u.read_multi_info.count = reg_count;\r\nfor (i = 0; i < reg_count; i++) {\r\ncmd.u.write_multi_info.write[i].address = address[i];\r\ncmd.u.write_multi_info.write[i].value = value[i];\r\n}\r\nreturn usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\r\n&cmd, 32, &count, DT9812_USB_TIMEOUT);\r\n}\r\nstatic int dt9812_rmw_multiple_registers(struct comedi_device *dev,\r\nint reg_count,\r\nstruct dt9812_rmw_byte *rmw)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct dt9812_usb_cmd cmd;\r\nint i, count;\r\ncmd.cmd = cpu_to_le32(DT9812_RMW_MULTI_BYTE_REG);\r\ncmd.u.rmw_multi_info.count = reg_count;\r\nfor (i = 0; i < reg_count; i++)\r\ncmd.u.rmw_multi_info.rmw[i] = rmw[i];\r\nreturn usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\r\n&cmd, 32, &count, DT9812_USB_TIMEOUT);\r\n}\r\nstatic int dt9812_digital_in(struct comedi_device *dev, u8 *bits)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nu8 reg[2] = { F020_SFR_P3, F020_SFR_P1 };\r\nu8 value[2];\r\nint ret;\r\ndown(&devpriv->sem);\r\nret = dt9812_read_multiple_registers(dev, 2, reg, value);\r\nif (ret == 0) {\r\n*bits = (value[0] & 0x7f) | ((value[1] & 0x08) << 4);\r\n}\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int dt9812_digital_out(struct comedi_device *dev, u8 bits)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nu8 reg[1] = { F020_SFR_P2 };\r\nu8 value[1] = { bits };\r\nint ret;\r\ndown(&devpriv->sem);\r\nret = dt9812_write_multiple_registers(dev, 1, reg, value);\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic void dt9812_configure_mux(struct comedi_device *dev,\r\nstruct dt9812_rmw_byte *rmw, int channel)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nif (devpriv->device == DT9812_DEVID_DT9812_10) {\r\nrmw->address = F020_SFR_P1;\r\nrmw->and_mask = 0xe0;\r\nrmw->or_value = channel << 5;\r\n} else {\r\nrmw->address = F020_SFR_AMX0SL;\r\nrmw->and_mask = 0xff;\r\nrmw->or_value = channel & 0x07;\r\n}\r\n}\r\nstatic void dt9812_configure_gain(struct comedi_device *dev,\r\nstruct dt9812_rmw_byte *rmw,\r\nenum dt9812_gain gain)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nif (devpriv->device == DT9812_DEVID_DT9812_10)\r\ngain <<= 1;\r\nrmw->address = F020_SFR_ADC0CF;\r\nrmw->and_mask = F020_MASK_ADC0CF_AMP0GN2 |\r\nF020_MASK_ADC0CF_AMP0GN1 |\r\nF020_MASK_ADC0CF_AMP0GN0;\r\nswitch (gain) {\r\ncase DT9812_GAIN_0PT5:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN2 |\r\nF020_MASK_ADC0CF_AMP0GN1;\r\nbreak;\r\ndefault:\r\ncase DT9812_GAIN_1:\r\nrmw->or_value = 0x00;\r\nbreak;\r\ncase DT9812_GAIN_2:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN0;\r\nbreak;\r\ncase DT9812_GAIN_4:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN1;\r\nbreak;\r\ncase DT9812_GAIN_8:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN1 |\r\nF020_MASK_ADC0CF_AMP0GN0;\r\nbreak;\r\ncase DT9812_GAIN_16:\r\nrmw->or_value = F020_MASK_ADC0CF_AMP0GN2;\r\nbreak;\r\n}\r\n}\r\nstatic int dt9812_analog_in(struct comedi_device *dev,\r\nint channel, u16 *value, enum dt9812_gain gain)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct dt9812_rmw_byte rmw[3];\r\nu8 reg[3] = {\r\nF020_SFR_ADC0CN,\r\nF020_SFR_ADC0H,\r\nF020_SFR_ADC0L\r\n};\r\nu8 val[3];\r\nint ret;\r\ndown(&devpriv->sem);\r\ndt9812_configure_gain(dev, &rmw[0], gain);\r\ndt9812_configure_mux(dev, &rmw[1], channel);\r\nrmw[2].address = F020_SFR_ADC0CN;\r\nrmw[2].and_mask = 0xff;\r\nrmw[2].or_value = F020_MASK_ADC0CN_AD0EN | F020_MASK_ADC0CN_AD0BUSY;\r\nret = dt9812_rmw_multiple_registers(dev, 3, rmw);\r\nif (ret)\r\ngoto exit;\r\nret = dt9812_read_multiple_registers(dev, 3, reg, val);\r\nif (ret)\r\ngoto exit;\r\nif ((val[0] & (F020_MASK_ADC0CN_AD0INT | F020_MASK_ADC0CN_AD0BUSY)) ==\r\nF020_MASK_ADC0CN_AD0INT) {\r\nswitch (devpriv->device) {\r\ncase DT9812_DEVID_DT9812_10:\r\n*value = ((val[1] << 8) | val[2]) + 0x800;\r\nbreak;\r\ncase DT9812_DEVID_DT9812_2PT5:\r\n*value = (val[1] << 8) | val[2];\r\nbreak;\r\n}\r\n}\r\nexit:\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int dt9812_analog_out(struct comedi_device *dev, int channel, u16 value)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct dt9812_rmw_byte rmw[3];\r\nint ret;\r\ndown(&devpriv->sem);\r\nswitch (channel) {\r\ncase 0:\r\nrmw[0].address = F020_SFR_DAC0CN;\r\nrmw[0].and_mask = 0xff;\r\nrmw[0].or_value = F020_MASK_DACxCN_DACxEN;\r\nrmw[1].address = F020_SFR_DAC0L;\r\nrmw[1].and_mask = 0xff;\r\nrmw[1].or_value = value & 0xff;\r\nrmw[2].address = F020_SFR_DAC0H;\r\nrmw[2].and_mask = 0xff;\r\nrmw[2].or_value = (value >> 8) & 0xf;\r\nbreak;\r\ncase 1:\r\nrmw[0].address = F020_SFR_DAC1CN;\r\nrmw[0].and_mask = 0xff;\r\nrmw[0].or_value = F020_MASK_DACxCN_DACxEN;\r\nrmw[1].address = F020_SFR_DAC1L;\r\nrmw[1].and_mask = 0xff;\r\nrmw[1].or_value = value & 0xff;\r\nrmw[2].address = F020_SFR_DAC1H;\r\nrmw[2].and_mask = 0xff;\r\nrmw[2].or_value = (value >> 8) & 0xf;\r\nbreak;\r\n}\r\nret = dt9812_rmw_multiple_registers(dev, 3, rmw);\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int dt9812_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nu8 bits = 0;\r\nint ret;\r\nret = dt9812_digital_in(dev, &bits);\r\nif (ret)\r\nreturn ret;\r\ndata[1] = bits;\r\nreturn insn->n;\r\n}\r\nstatic int dt9812_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\ndt9812_digital_out(dev, s->state);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int dt9812_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nu16 val = 0;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nret = dt9812_analog_in(dev, chan, &val, DT9812_GAIN_1);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dt9812_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dt9812_private *devpriv = dev->private;\r\nint ret;\r\ndown(&devpriv->sem);\r\nret = comedi_readback_insn_read(dev, s, insn, data);\r\nup(&devpriv->sem);\r\nreturn ret;\r\n}\r\nstatic int dt9812_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\nint ret;\r\nret = dt9812_analog_out(dev, chan, val);\r\nif (ret)\r\nreturn ret;\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dt9812_find_endpoints(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct usb_host_interface *host = intf->cur_altsetting;\r\nstruct dt9812_private *devpriv = dev->private;\r\nstruct usb_endpoint_descriptor *ep;\r\nint i;\r\nif (host->desc.bNumEndpoints != 5) {\r\ndev_err(dev->class_dev, "Wrong number of endpoints\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < host->desc.bNumEndpoints; ++i) {\r\nint dir = -1;\r\nep = &host->endpoint[i].desc;\r\nswitch (i) {\r\ncase 0:\r\ndir = USB_DIR_IN;\r\nbreak;\r\ncase 1:\r\ndir = USB_DIR_OUT;\r\ndevpriv->cmd_wr.addr = ep->bEndpointAddress;\r\ndevpriv->cmd_wr.size = le16_to_cpu(ep->wMaxPacketSize);\r\nbreak;\r\ncase 2:\r\ndir = USB_DIR_IN;\r\ndevpriv->cmd_rd.addr = ep->bEndpointAddress;\r\ndevpriv->cmd_rd.size = le16_to_cpu(ep->wMaxPacketSize);\r\nbreak;\r\ncase 3:\r\ndir = USB_DIR_OUT;\r\nbreak;\r\ncase 4:\r\ndir = USB_DIR_IN;\r\nbreak;\r\n}\r\nif ((ep->bEndpointAddress & USB_DIR_IN) != dir) {\r\ndev_err(dev->class_dev,\r\n"Endpoint has wrong direction\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt9812_reset_device(struct comedi_device *dev)\r\n{\r\nstruct usb_device *usb = comedi_to_usb_dev(dev);\r\nstruct dt9812_private *devpriv = dev->private;\r\nu32 serial;\r\nu16 vendor;\r\nu16 product;\r\nu8 tmp8;\r\n__le16 tmp16;\r\n__le32 tmp32;\r\nint ret;\r\nint i;\r\nret = dt9812_read_info(dev, 0, &tmp8, sizeof(tmp8));\r\nif (ret) {\r\nusb_reset_configuration(usb);\r\nfor (i = 0; i < 10; i++) {\r\nret = dt9812_read_info(dev, 1, &tmp8, sizeof(tmp8));\r\nif (ret == 0)\r\nbreak;\r\n}\r\nif (ret) {\r\ndev_err(dev->class_dev,\r\n"unable to reset configuration\n");\r\nreturn ret;\r\n}\r\n}\r\nret = dt9812_read_info(dev, 1, &tmp16, sizeof(tmp16));\r\nif (ret) {\r\ndev_err(dev->class_dev, "failed to read vendor id\n");\r\nreturn ret;\r\n}\r\nvendor = le16_to_cpu(tmp16);\r\nret = dt9812_read_info(dev, 3, &tmp16, sizeof(tmp16));\r\nif (ret) {\r\ndev_err(dev->class_dev, "failed to read product id\n");\r\nreturn ret;\r\n}\r\nproduct = le16_to_cpu(tmp16);\r\nret = dt9812_read_info(dev, 5, &tmp16, sizeof(tmp16));\r\nif (ret) {\r\ndev_err(dev->class_dev, "failed to read device id\n");\r\nreturn ret;\r\n}\r\ndevpriv->device = le16_to_cpu(tmp16);\r\nret = dt9812_read_info(dev, 7, &tmp32, sizeof(tmp32));\r\nif (ret) {\r\ndev_err(dev->class_dev, "failed to read serial number\n");\r\nreturn ret;\r\n}\r\nserial = le32_to_cpu(tmp32);\r\ndev_info(dev->class_dev, "USB DT9812 (%4.4x.%4.4x.%4.4x) #0x%8.8x\n",\r\nvendor, product, devpriv->device, serial);\r\nif (devpriv->device != DT9812_DEVID_DT9812_10 &&\r\ndevpriv->device != DT9812_DEVID_DT9812_2PT5) {\r\ndev_err(dev->class_dev, "Unsupported device!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt9812_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct dt9812_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nbool is_unipolar;\r\nint ret;\r\nint i;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nsema_init(&devpriv->sem, 1);\r\nusb_set_intfdata(intf, devpriv);\r\nret = dt9812_find_endpoints(dev);\r\nif (ret)\r\nreturn ret;\r\nret = dt9812_reset_device(dev);\r\nif (ret)\r\nreturn ret;\r\nis_unipolar = (devpriv->device == DT9812_DEVID_DT9812_2PT5);\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = dt9812_di_insn_bits;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = dt9812_do_insn_bits;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 8;\r\ns->maxdata = 0x0fff;\r\ns->range_table = is_unipolar ? &range_unipolar2_5 : &range_bipolar10;\r\ns->insn_read = dt9812_ai_insn_read;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 0x0fff;\r\ns->range_table = is_unipolar ? &range_unipolar2_5 : &range_bipolar10;\r\ns->insn_write = dt9812_ao_insn_write;\r\ns->insn_read = dt9812_ao_insn_read;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++)\r\ns->readback[i] = is_unipolar ? 0x0000 : 0x0800;\r\nreturn 0;\r\n}\r\nstatic void dt9812_detach(struct comedi_device *dev)\r\n{\r\nstruct usb_interface *intf = comedi_to_usb_interface(dev);\r\nstruct dt9812_private *devpriv = dev->private;\r\nif (!devpriv)\r\nreturn;\r\ndown(&devpriv->sem);\r\nusb_set_intfdata(intf, NULL);\r\nup(&devpriv->sem);\r\n}\r\nstatic int dt9812_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn comedi_usb_auto_config(intf, &dt9812_driver, id->driver_info);\r\n}
