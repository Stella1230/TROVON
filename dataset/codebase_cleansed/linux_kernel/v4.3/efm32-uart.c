static void efm32_uart_write32(struct efm32_uart_port *efm_port,\r\nu32 value, unsigned offset)\r\n{\r\nwritel_relaxed(value, efm_port->port.membase + offset);\r\n}\r\nstatic u32 efm32_uart_read32(struct efm32_uart_port *efm_port,\r\nunsigned offset)\r\n{\r\nreturn readl_relaxed(efm_port->port.membase + offset);\r\n}\r\nstatic unsigned int efm32_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nu32 status = efm32_uart_read32(efm_port, UARTn_STATUS);\r\nif (status & UARTn_STATUS_TXC)\r\nreturn TIOCSER_TEMT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void efm32_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic unsigned int efm32_uart_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR;\r\n}\r\nstatic void efm32_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nu32 ien = efm32_uart_read32(efm_port, UARTn_IEN);\r\nefm32_uart_write32(efm_port, UARTn_CMD_TXDIS, UARTn_CMD);\r\nien &= ~(UARTn_IF_TXC | UARTn_IF_TXBL);\r\nefm32_uart_write32(efm_port, ien, UARTn_IEN);\r\n}\r\nstatic void efm32_uart_tx_chars(struct efm32_uart_port *efm_port)\r\n{\r\nstruct uart_port *port = &efm_port->port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nwhile (efm32_uart_read32(efm_port, UARTn_STATUS) &\r\nUARTn_STATUS_TXBL) {\r\nif (port->x_char) {\r\nport->icount.tx++;\r\nefm32_uart_write32(efm_port, port->x_char,\r\nUARTn_TXDATA);\r\nport->x_char = 0;\r\ncontinue;\r\n}\r\nif (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {\r\nport->icount.tx++;\r\nefm32_uart_write32(efm_port, xmit->buf[xmit->tail],\r\nUARTn_TXDATA);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n} else\r\nbreak;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (!port->x_char && uart_circ_empty(xmit) &&\r\nefm32_uart_read32(efm_port, UARTn_STATUS) &\r\nUARTn_STATUS_TXC)\r\nefm32_uart_stop_tx(port);\r\n}\r\nstatic void efm32_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nu32 ien;\r\nefm32_uart_write32(efm_port,\r\nUARTn_IF_TXBL | UARTn_IF_TXC, UARTn_IFC);\r\nien = efm32_uart_read32(efm_port, UARTn_IEN);\r\nefm32_uart_write32(efm_port,\r\nien | UARTn_IF_TXBL | UARTn_IF_TXC, UARTn_IEN);\r\nefm32_uart_write32(efm_port, UARTn_CMD_TXEN, UARTn_CMD);\r\nefm32_uart_tx_chars(efm_port);\r\n}\r\nstatic void efm32_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nefm32_uart_write32(efm_port, UARTn_CMD_RXDIS, UARTn_CMD);\r\n}\r\nstatic void efm32_uart_break_ctl(struct uart_port *port, int ctl)\r\n{\r\n}\r\nstatic void efm32_uart_rx_chars(struct efm32_uart_port *efm_port)\r\n{\r\nstruct uart_port *port = &efm_port->port;\r\nwhile (efm32_uart_read32(efm_port, UARTn_STATUS) &\r\nUARTn_STATUS_RXDATAV) {\r\nu32 rxdata = efm32_uart_read32(efm_port, UARTn_RXDATAX);\r\nint flag = 0;\r\nrxdata &= ~SW_UARTn_RXDATAX_BERR;\r\nport->icount.rx++;\r\nif ((rxdata & UARTn_RXDATAX_FERR) &&\r\n!(rxdata & UARTn_RXDATAX_RXDATA__MASK)) {\r\nrxdata |= SW_UARTn_RXDATAX_BERR;\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (rxdata & UARTn_RXDATAX_PERR)\r\nport->icount.parity++;\r\nelse if (rxdata & UARTn_RXDATAX_FERR)\r\nport->icount.frame++;\r\nrxdata &= port->read_status_mask;\r\nif (rxdata & SW_UARTn_RXDATAX_BERR)\r\nflag = TTY_BREAK;\r\nelse if (rxdata & UARTn_RXDATAX_PERR)\r\nflag = TTY_PARITY;\r\nelse if (rxdata & UARTn_RXDATAX_FERR)\r\nflag = TTY_FRAME;\r\nelse if (uart_handle_sysrq_char(port,\r\nrxdata & UARTn_RXDATAX_RXDATA__MASK))\r\ncontinue;\r\nif ((rxdata & port->ignore_status_mask) == 0)\r\ntty_insert_flip_char(&port->state->port,\r\nrxdata & UARTn_RXDATAX_RXDATA__MASK, flag);\r\n}\r\n}\r\nstatic irqreturn_t efm32_uart_rxirq(int irq, void *data)\r\n{\r\nstruct efm32_uart_port *efm_port = data;\r\nu32 irqflag = efm32_uart_read32(efm_port, UARTn_IF);\r\nint handled = IRQ_NONE;\r\nstruct uart_port *port = &efm_port->port;\r\nstruct tty_port *tport = &port->state->port;\r\nspin_lock(&port->lock);\r\nif (irqflag & UARTn_IF_RXDATAV) {\r\nefm32_uart_write32(efm_port, UARTn_IF_RXDATAV, UARTn_IFC);\r\nefm32_uart_rx_chars(efm_port);\r\nhandled = IRQ_HANDLED;\r\n}\r\nif (irqflag & UARTn_IF_RXOF) {\r\nefm32_uart_write32(efm_port, UARTn_IF_RXOF, UARTn_IFC);\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tport, 0, TTY_OVERRUN);\r\nhandled = IRQ_HANDLED;\r\n}\r\nspin_unlock(&port->lock);\r\ntty_flip_buffer_push(tport);\r\nreturn handled;\r\n}\r\nstatic irqreturn_t efm32_uart_txirq(int irq, void *data)\r\n{\r\nstruct efm32_uart_port *efm_port = data;\r\nu32 irqflag = efm32_uart_read32(efm_port, UARTn_IF);\r\nif (irqflag & UARTn_IF_TXC)\r\nefm32_uart_write32(efm_port, UARTn_IF_TXC, UARTn_IFC);\r\nif (irqflag & (UARTn_IF_TXC | UARTn_IF_TXBL)) {\r\nefm32_uart_tx_chars(efm_port);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic int efm32_uart_startup(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nint ret;\r\nret = clk_enable(efm_port->clk);\r\nif (ret) {\r\nefm_debug(efm_port, "failed to enable clk\n");\r\ngoto err_clk_enable;\r\n}\r\nport->uartclk = clk_get_rate(efm_port->clk);\r\nefm32_uart_write32(efm_port,\r\nUARTn_ROUTE_LOCATION(efm_port->pdata.location) |\r\nUARTn_ROUTE_RXPEN | UARTn_ROUTE_TXPEN,\r\nUARTn_ROUTE);\r\nret = request_irq(port->irq, efm32_uart_rxirq, 0,\r\nDRIVER_NAME, efm_port);\r\nif (ret) {\r\nefm_debug(efm_port, "failed to register rxirq\n");\r\ngoto err_request_irq_rx;\r\n}\r\nefm32_uart_write32(efm_port, 0, UARTn_IEN);\r\nret = request_irq(efm_port->txirq, efm32_uart_txirq, 0,\r\nDRIVER_NAME, efm_port);\r\nif (ret) {\r\nefm_debug(efm_port, "failed to register txirq\n");\r\nfree_irq(port->irq, efm_port);\r\nerr_request_irq_rx:\r\nclk_disable(efm_port->clk);\r\n} else {\r\nefm32_uart_write32(efm_port,\r\nUARTn_IF_RXDATAV | UARTn_IF_RXOF, UARTn_IEN);\r\nefm32_uart_write32(efm_port, UARTn_CMD_RXEN, UARTn_CMD);\r\n}\r\nerr_clk_enable:\r\nreturn ret;\r\n}\r\nstatic void efm32_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nefm32_uart_write32(efm_port, 0, UARTn_IEN);\r\nfree_irq(port->irq, efm_port);\r\nclk_disable(efm_port->clk);\r\n}\r\nstatic void efm32_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *new, struct ktermios *old)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nunsigned long flags;\r\nunsigned baud;\r\nu32 clkdiv;\r\nu32 frame = 0;\r\nnew->c_cflag &= ~(CRTSCTS | CMSPAR);\r\nbaud = uart_get_baud_rate(port, new, old,\r\nDIV_ROUND_CLOSEST(port->uartclk, 16 * 8192),\r\nDIV_ROUND_CLOSEST(port->uartclk, 16));\r\nswitch (new->c_cflag & CSIZE) {\r\ncase CS5:\r\nframe |= UARTn_FRAME_DATABITS(5);\r\nbreak;\r\ncase CS6:\r\nframe |= UARTn_FRAME_DATABITS(6);\r\nbreak;\r\ncase CS7:\r\nframe |= UARTn_FRAME_DATABITS(7);\r\nbreak;\r\ncase CS8:\r\nframe |= UARTn_FRAME_DATABITS(8);\r\nbreak;\r\n}\r\nif (new->c_cflag & CSTOPB)\r\nframe |= UARTn_FRAME_STOPBITS_TWO;\r\nelse\r\nframe |= UARTn_FRAME_STOPBITS_ONE;\r\nif (new->c_cflag & PARENB) {\r\nif (new->c_cflag & PARODD)\r\nframe |= UARTn_FRAME_PARITY_ODD;\r\nelse\r\nframe |= UARTn_FRAME_PARITY_EVEN;\r\n} else\r\nframe |= UARTn_FRAME_PARITY_NONE;\r\nclkdiv = (DIV_ROUND_CLOSEST(4 * port->uartclk, 16 * baud) - 4) << 6;\r\nspin_lock_irqsave(&port->lock, flags);\r\nefm32_uart_write32(efm_port,\r\nUARTn_CMD_TXDIS | UARTn_CMD_RXDIS, UARTn_CMD);\r\nport->read_status_mask = UARTn_RXDATAX_RXDATA__MASK;\r\nif (new->c_iflag & INPCK)\r\nport->read_status_mask |=\r\nUARTn_RXDATAX_FERR | UARTn_RXDATAX_PERR;\r\nif (new->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= SW_UARTn_RXDATAX_BERR;\r\nport->ignore_status_mask = 0;\r\nif (new->c_iflag & IGNPAR)\r\nport->ignore_status_mask |=\r\nUARTn_RXDATAX_FERR | UARTn_RXDATAX_PERR;\r\nif (new->c_iflag & IGNBRK)\r\nport->ignore_status_mask |= SW_UARTn_RXDATAX_BERR;\r\nuart_update_timeout(port, new->c_cflag, baud);\r\nefm32_uart_write32(efm_port, UARTn_CTRL_TXBIL, UARTn_CTRL);\r\nefm32_uart_write32(efm_port, frame, UARTn_FRAME);\r\nefm32_uart_write32(efm_port, clkdiv, UARTn_CLKDIV);\r\nefm32_uart_write32(efm_port, UARTn_CMD_TXEN | UARTn_CMD_RXEN,\r\nUARTn_CMD);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *efm32_uart_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_EFMUART ? "efm32-uart" : NULL;\r\n}\r\nstatic void efm32_uart_release_port(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nclk_unprepare(efm_port->clk);\r\nclk_put(efm_port->clk);\r\niounmap(port->membase);\r\n}\r\nstatic int efm32_uart_request_port(struct uart_port *port)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nint ret;\r\nport->membase = ioremap(port->mapbase, 60);\r\nif (!efm_port->port.membase) {\r\nret = -ENOMEM;\r\nefm_debug(efm_port, "failed to remap\n");\r\ngoto err_ioremap;\r\n}\r\nefm_port->clk = clk_get(port->dev, NULL);\r\nif (IS_ERR(efm_port->clk)) {\r\nret = PTR_ERR(efm_port->clk);\r\nefm_debug(efm_port, "failed to get clock\n");\r\ngoto err_clk_get;\r\n}\r\nret = clk_prepare(efm_port->clk);\r\nif (ret) {\r\nclk_put(efm_port->clk);\r\nerr_clk_get:\r\niounmap(port->membase);\r\nerr_ioremap:\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void efm32_uart_config_port(struct uart_port *port, int type)\r\n{\r\nif (type & UART_CONFIG_TYPE &&\r\n!efm32_uart_request_port(port))\r\nport->type = PORT_EFMUART;\r\n}\r\nstatic int efm32_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *serinfo)\r\n{\r\nint ret = 0;\r\nif (serinfo->type != PORT_UNKNOWN && serinfo->type != PORT_EFMUART)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void efm32_uart_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct efm32_uart_port *efm_port = to_efm_port(port);\r\nunsigned int timeout = 0x400;\r\nu32 status;\r\nwhile (1) {\r\nstatus = efm32_uart_read32(efm_port, UARTn_STATUS);\r\nif (status & UARTn_STATUS_TXBL)\r\nbreak;\r\nif (!timeout--)\r\nreturn;\r\n}\r\nefm32_uart_write32(efm_port, ch, UARTn_TXDATA);\r\n}\r\nstatic void efm32_uart_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct efm32_uart_port *efm_port = efm32_uart_ports[co->index];\r\nu32 status = efm32_uart_read32(efm_port, UARTn_STATUS);\r\nunsigned int timeout = 0x400;\r\nif (!(status & UARTn_STATUS_TXENS))\r\nefm32_uart_write32(efm_port, UARTn_CMD_TXEN, UARTn_CMD);\r\nuart_console_write(&efm_port->port, s, count,\r\nefm32_uart_console_putchar);\r\nwhile (1) {\r\nu32 status = efm32_uart_read32(efm_port, UARTn_STATUS);\r\nif (status & UARTn_STATUS_TXC)\r\nbreak;\r\nif (!timeout--)\r\nbreak;\r\n}\r\nif (!(status & UARTn_STATUS_TXENS))\r\nefm32_uart_write32(efm_port, UARTn_CMD_TXDIS, UARTn_CMD);\r\n}\r\nstatic void efm32_uart_console_get_options(struct efm32_uart_port *efm_port,\r\nint *baud, int *parity, int *bits)\r\n{\r\nu32 ctrl = efm32_uart_read32(efm_port, UARTn_CTRL);\r\nu32 route, clkdiv, frame;\r\nif (ctrl & UARTn_CTRL_SYNC)\r\nreturn;\r\nroute = efm32_uart_read32(efm_port, UARTn_ROUTE);\r\nif (!(route & UARTn_ROUTE_TXPEN))\r\nreturn;\r\nclkdiv = efm32_uart_read32(efm_port, UARTn_CLKDIV);\r\n*baud = DIV_ROUND_CLOSEST(4 * efm_port->port.uartclk,\r\n16 * (4 + (clkdiv >> 6)));\r\nframe = efm32_uart_read32(efm_port, UARTn_FRAME);\r\nif (frame & UARTn_FRAME_PARITY_ODD)\r\n*parity = 'o';\r\nelse if (frame & UARTn_FRAME_PARITY_EVEN)\r\n*parity = 'e';\r\nelse\r\n*parity = 'n';\r\n*bits = (frame & UARTn_FRAME_DATABITS__MASK) -\r\nUARTn_FRAME_DATABITS(4) + 4;\r\nefm_debug(efm_port, "get_opts: options=%d%c%d\n",\r\n*baud, *parity, *bits);\r\n}\r\nstatic int efm32_uart_console_setup(struct console *co, char *options)\r\n{\r\nstruct efm32_uart_port *efm_port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (co->index < 0 || co->index >= ARRAY_SIZE(efm32_uart_ports)) {\r\nunsigned i;\r\nfor (i = 0; i < ARRAY_SIZE(efm32_uart_ports); ++i) {\r\nif (efm32_uart_ports[i]) {\r\npr_warn("efm32-console: fall back to console index %u (from %hhi)\n",\r\ni, co->index);\r\nco->index = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nefm_port = efm32_uart_ports[co->index];\r\nif (!efm_port) {\r\npr_warn("efm32-console: No port at %d\n", co->index);\r\nreturn -ENODEV;\r\n}\r\nret = clk_prepare(efm_port->clk);\r\nif (ret) {\r\ndev_warn(efm_port->port.dev,\r\n"console: clk_prepare failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nefm_port->port.uartclk = clk_get_rate(efm_port->clk);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nefm32_uart_console_get_options(efm_port,\r\n&baud, &parity, &bits);\r\nreturn uart_set_options(&efm_port->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int efm32_uart_probe_dt(struct platform_device *pdev,\r\nstruct efm32_uart_port *efm_port)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 location;\r\nint ret;\r\nif (!np)\r\nreturn 1;\r\nret = of_property_read_u32(np, "energymicro,location", &location);\r\nif (ret)\r\nret = of_property_read_u32(np, "efm32,location", &location);\r\nif (ret)\r\nret = of_property_read_u32(np, "location", &location);\r\nif (!ret) {\r\nif (location > 5) {\r\ndev_err(&pdev->dev, "invalid location\n");\r\nreturn -EINVAL;\r\n}\r\nefm_debug(efm_port, "using location %u\n", location);\r\nefm_port->pdata.location = location;\r\n} else {\r\nefm_debug(efm_port, "fall back to location 0\n");\r\n}\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id: %d\n", ret);\r\nreturn ret;\r\n} else {\r\nefm_port->port.line = ret;\r\nreturn 0;\r\n}\r\n}\r\nstatic int efm32_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct efm32_uart_port *efm_port;\r\nstruct resource *res;\r\nunsigned int line;\r\nint ret;\r\nefm_port = kzalloc(sizeof(*efm_port), GFP_KERNEL);\r\nif (!efm_port) {\r\ndev_dbg(&pdev->dev, "failed to allocate private data\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ndev_dbg(&pdev->dev, "failed to determine base address\n");\r\ngoto err_get_base;\r\n}\r\nif (resource_size(res) < 60) {\r\nret = -EINVAL;\r\ndev_dbg(&pdev->dev, "memory resource too small\n");\r\ngoto err_too_small;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_dbg(&pdev->dev, "failed to get rx irq\n");\r\ngoto err_get_rxirq;\r\n}\r\nefm_port->port.irq = ret;\r\nret = platform_get_irq(pdev, 1);\r\nif (ret <= 0)\r\nret = efm_port->port.irq + 1;\r\nefm_port->txirq = ret;\r\nefm_port->port.dev = &pdev->dev;\r\nefm_port->port.mapbase = res->start;\r\nefm_port->port.type = PORT_EFMUART;\r\nefm_port->port.iotype = UPIO_MEM32;\r\nefm_port->port.fifosize = 2;\r\nefm_port->port.ops = &efm32_uart_pops;\r\nefm_port->port.flags = UPF_BOOT_AUTOCONF;\r\nret = efm32_uart_probe_dt(pdev, efm_port);\r\nif (ret > 0) {\r\nconst struct efm32_uart_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nefm_port->port.line = pdev->id;\r\nif (pdata)\r\nefm_port->pdata = *pdata;\r\n} else if (ret < 0)\r\ngoto err_probe_dt;\r\nline = efm_port->port.line;\r\nif (line >= 0 && line < ARRAY_SIZE(efm32_uart_ports))\r\nefm32_uart_ports[line] = efm_port;\r\nret = uart_add_one_port(&efm32_uart_reg, &efm_port->port);\r\nif (ret) {\r\ndev_dbg(&pdev->dev, "failed to add port: %d\n", ret);\r\nif (line >= 0 && line < ARRAY_SIZE(efm32_uart_ports))\r\nefm32_uart_ports[line] = NULL;\r\nerr_probe_dt:\r\nerr_get_rxirq:\r\nerr_too_small:\r\nerr_get_base:\r\nkfree(efm_port);\r\n} else {\r\nplatform_set_drvdata(pdev, efm_port);\r\ndev_dbg(&pdev->dev, "\\o/\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int efm32_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct efm32_uart_port *efm_port = platform_get_drvdata(pdev);\r\nunsigned int line = efm_port->port.line;\r\nuart_remove_one_port(&efm32_uart_reg, &efm_port->port);\r\nif (line >= 0 && line < ARRAY_SIZE(efm32_uart_ports))\r\nefm32_uart_ports[line] = NULL;\r\nkfree(efm_port);\r\nreturn 0;\r\n}\r\nstatic int __init efm32_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&efm32_uart_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&efm32_uart_driver);\r\nif (ret)\r\nuart_unregister_driver(&efm32_uart_reg);\r\npr_info("EFM32 UART/USART driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit efm32_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&efm32_uart_driver);\r\nuart_unregister_driver(&efm32_uart_reg);\r\n}
