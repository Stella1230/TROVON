static void transfer_done(struct whc *whc)\r\n{\r\nqueue_work(whc->workqueue, &whc->async_work);\r\nqueue_work(whc->workqueue, &whc->periodic_work);\r\n}\r\nirqreturn_t whc_int_handler(struct usb_hcd *hcd)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(hcd);\r\nstruct whc *whc = wusbhc_to_whc(wusbhc);\r\nu32 sts;\r\nsts = le_readl(whc->base + WUSBSTS);\r\nif (!(sts & WUSBSTS_INT_MASK))\r\nreturn IRQ_NONE;\r\nle_writel(sts & WUSBSTS_INT_MASK, whc->base + WUSBSTS);\r\nif (sts & WUSBSTS_GEN_CMD_DONE)\r\nwake_up(&whc->cmd_wq);\r\nif (sts & WUSBSTS_HOST_ERR)\r\ndev_err(&whc->umc->dev, "FIXME: host system error\n");\r\nif (sts & WUSBSTS_ASYNC_SCHED_SYNCED)\r\nwake_up(&whc->async_list_wq);\r\nif (sts & WUSBSTS_PERIODIC_SCHED_SYNCED)\r\nwake_up(&whc->periodic_list_wq);\r\nif (sts & WUSBSTS_DNTS_INT)\r\nqueue_work(whc->workqueue, &whc->dn_work);\r\nif (sts & (WUSBSTS_INT | WUSBSTS_ERR_INT))\r\ntransfer_done(whc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int process_dn_buf(struct whc *whc)\r\n{\r\nstruct wusbhc *wusbhc = &whc->wusbhc;\r\nstruct dn_buf_entry *dn;\r\nint processed = 0;\r\nfor (dn = whc->dn_buf; dn < whc->dn_buf + WHC_N_DN_ENTRIES; dn++) {\r\nif (dn->status & WHC_DN_STATUS_VALID) {\r\nwusbhc_handle_dn(wusbhc, dn->src_addr,\r\n(struct wusb_dn_hdr *)dn->dn_data,\r\ndn->msg_size);\r\ndn->status &= ~WHC_DN_STATUS_VALID;\r\nprocessed++;\r\n}\r\n}\r\nreturn processed;\r\n}\r\nvoid whc_dn_work(struct work_struct *work)\r\n{\r\nstruct whc *whc = container_of(work, struct whc, dn_work);\r\nint processed;\r\ndo {\r\nprocessed = process_dn_buf(whc);\r\n} while (processed);\r\n}
