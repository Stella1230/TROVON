static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\r\n{\r\nreturn container_of(tfm, struct crypto_rng, base);\r\n}\r\nint crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\r\n{\r\nu8 *buf = NULL;\r\nint err;\r\nif (!seed && slen) {\r\nbuf = kmalloc(slen, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nget_random_bytes(buf, slen);\r\nseed = buf;\r\n}\r\nerr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\r\nkzfree(buf);\r\nreturn err;\r\n}\r\nstatic int crypto_rng_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int seedsize(struct crypto_alg *alg)\r\n{\r\nstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\r\nreturn ralg->seedsize;\r\n}\r\nstatic int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nstruct crypto_report_rng rrng;\r\nstrncpy(rrng.type, "rng", sizeof(rrng.type));\r\nrrng.seedsize = seedsize(alg);\r\nif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\r\nsizeof(struct crypto_report_rng), &rrng))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\r\n{\r\nseq_printf(m, "type : rng\n");\r\nseq_printf(m, "seedsize : %u\n", seedsize(alg));\r\n}\r\nstruct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);\r\n}\r\nint crypto_get_default_rng(void)\r\n{\r\nstruct crypto_rng *rng;\r\nint err;\r\nmutex_lock(&crypto_default_rng_lock);\r\nif (!crypto_default_rng) {\r\nrng = crypto_alloc_rng("stdrng", 0, 0);\r\nerr = PTR_ERR(rng);\r\nif (IS_ERR(rng))\r\ngoto unlock;\r\nerr = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\r\nif (err) {\r\ncrypto_free_rng(rng);\r\ngoto unlock;\r\n}\r\ncrypto_default_rng = rng;\r\n}\r\ncrypto_default_rng_refcnt++;\r\nerr = 0;\r\nunlock:\r\nmutex_unlock(&crypto_default_rng_lock);\r\nreturn err;\r\n}\r\nvoid crypto_put_default_rng(void)\r\n{\r\nmutex_lock(&crypto_default_rng_lock);\r\ncrypto_default_rng_refcnt--;\r\nmutex_unlock(&crypto_default_rng_lock);\r\n}\r\nint crypto_del_default_rng(void)\r\n{\r\nint err = -EBUSY;\r\nmutex_lock(&crypto_default_rng_lock);\r\nif (crypto_default_rng_refcnt)\r\ngoto out;\r\ncrypto_free_rng(crypto_default_rng);\r\ncrypto_default_rng = NULL;\r\nerr = 0;\r\nout:\r\nmutex_unlock(&crypto_default_rng_lock);\r\nreturn err;\r\n}\r\nint crypto_register_rng(struct rng_alg *alg)\r\n{\r\nstruct crypto_alg *base = &alg->base;\r\nif (alg->seedsize > PAGE_SIZE / 8)\r\nreturn -EINVAL;\r\nbase->cra_type = &crypto_rng_type;\r\nbase->cra_flags &= ~CRYPTO_ALG_TYPE_MASK;\r\nbase->cra_flags |= CRYPTO_ALG_TYPE_RNG;\r\nreturn crypto_register_alg(base);\r\n}\r\nvoid crypto_unregister_rng(struct rng_alg *alg)\r\n{\r\ncrypto_unregister_alg(&alg->base);\r\n}\r\nint crypto_register_rngs(struct rng_alg *algs, int count)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nret = crypto_register_rng(algs + i);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; --i)\r\ncrypto_unregister_rng(algs + i);\r\nreturn ret;\r\n}\r\nvoid crypto_unregister_rngs(struct rng_alg *algs, int count)\r\n{\r\nint i;\r\nfor (i = count - 1; i >= 0; --i)\r\ncrypto_unregister_rng(algs + i);\r\n}
