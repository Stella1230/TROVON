static ssize_t\r\nefivar_guid_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nchar *str = buf;\r\nif (!entry || !buf)\r\nreturn 0;\r\nefi_guid_to_str(&var->VendorGuid, str);\r\nstr += strlen(str);\r\nstr += sprintf(str, "\n");\r\nreturn str - buf;\r\n}\r\nstatic ssize_t\r\nefivar_attr_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nchar *str = buf;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nvar->DataSize = 1024;\r\nif (efivar_entry_get(entry, &var->Attributes, &var->DataSize, var->Data))\r\nreturn -EIO;\r\nif (var->Attributes & EFI_VARIABLE_NON_VOLATILE)\r\nstr += sprintf(str, "EFI_VARIABLE_NON_VOLATILE\n");\r\nif (var->Attributes & EFI_VARIABLE_BOOTSERVICE_ACCESS)\r\nstr += sprintf(str, "EFI_VARIABLE_BOOTSERVICE_ACCESS\n");\r\nif (var->Attributes & EFI_VARIABLE_RUNTIME_ACCESS)\r\nstr += sprintf(str, "EFI_VARIABLE_RUNTIME_ACCESS\n");\r\nif (var->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD)\r\nstr += sprintf(str, "EFI_VARIABLE_HARDWARE_ERROR_RECORD\n");\r\nif (var->Attributes & EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS)\r\nstr += sprintf(str,\r\n"EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS\n");\r\nif (var->Attributes &\r\nEFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS)\r\nstr += sprintf(str,\r\n"EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS\n");\r\nif (var->Attributes & EFI_VARIABLE_APPEND_WRITE)\r\nstr += sprintf(str, "EFI_VARIABLE_APPEND_WRITE\n");\r\nreturn str - buf;\r\n}\r\nstatic ssize_t\r\nefivar_size_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nchar *str = buf;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nvar->DataSize = 1024;\r\nif (efivar_entry_get(entry, &var->Attributes, &var->DataSize, var->Data))\r\nreturn -EIO;\r\nstr += sprintf(str, "0x%lx\n", var->DataSize);\r\nreturn str - buf;\r\n}\r\nstatic ssize_t\r\nefivar_data_read(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nif (!entry || !buf)\r\nreturn -EINVAL;\r\nvar->DataSize = 1024;\r\nif (efivar_entry_get(entry, &var->Attributes, &var->DataSize, var->Data))\r\nreturn -EIO;\r\nmemcpy(buf, var->Data, var->DataSize);\r\nreturn var->DataSize;\r\n}\r\nstatic inline int\r\nsanity_check(struct efi_variable *var, efi_char16_t *name, efi_guid_t vendor,\r\nunsigned long size, u32 attributes, u8 *data)\r\n{\r\nif (memcmp(name, var->VariableName, sizeof(var->VariableName)) ||\r\nefi_guidcmp(vendor, var->VendorGuid)) {\r\nprintk(KERN_ERR "efivars: Cannot edit the wrong variable!\n");\r\nreturn -EINVAL;\r\n}\r\nif ((size <= 0) || (attributes == 0)){\r\nprintk(KERN_ERR "efivars: DataSize & Attributes must be valid!\n");\r\nreturn -EINVAL;\r\n}\r\nif ((attributes & ~EFI_VARIABLE_MASK) != 0 ||\r\nefivar_validate(name, data, size) == false) {\r\nprintk(KERN_ERR "efivars: Malformed variable content\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool is_compat(void)\r\n{\r\nif (IS_ENABLED(CONFIG_COMPAT) && is_compat_task())\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\ncopy_out_compat(struct efi_variable *dst, struct compat_efi_variable *src)\r\n{\r\nmemcpy(dst->VariableName, src->VariableName, EFI_VAR_NAME_LEN);\r\nmemcpy(dst->Data, src->Data, sizeof(src->Data));\r\ndst->VendorGuid = src->VendorGuid;\r\ndst->DataSize = src->DataSize;\r\ndst->Attributes = src->Attributes;\r\n}\r\nstatic ssize_t\r\nefivar_store_raw(struct efivar_entry *entry, const char *buf, size_t count)\r\n{\r\nstruct efi_variable *new_var, *var = &entry->var;\r\nefi_char16_t *name;\r\nunsigned long size;\r\nefi_guid_t vendor;\r\nu32 attributes;\r\nu8 *data;\r\nint err;\r\nif (is_compat()) {\r\nstruct compat_efi_variable *compat;\r\nif (count != sizeof(*compat))\r\nreturn -EINVAL;\r\ncompat = (struct compat_efi_variable *)buf;\r\nattributes = compat->Attributes;\r\nvendor = compat->VendorGuid;\r\nname = compat->VariableName;\r\nsize = compat->DataSize;\r\ndata = compat->Data;\r\nerr = sanity_check(var, name, vendor, size, attributes, data);\r\nif (err)\r\nreturn err;\r\ncopy_out_compat(&entry->var, compat);\r\n} else {\r\nif (count != sizeof(struct efi_variable))\r\nreturn -EINVAL;\r\nnew_var = (struct efi_variable *)buf;\r\nattributes = new_var->Attributes;\r\nvendor = new_var->VendorGuid;\r\nname = new_var->VariableName;\r\nsize = new_var->DataSize;\r\ndata = new_var->Data;\r\nerr = sanity_check(var, name, vendor, size, attributes, data);\r\nif (err)\r\nreturn err;\r\nmemcpy(&entry->var, new_var, count);\r\n}\r\nerr = efivar_entry_set(entry, attributes, size, data, NULL);\r\nif (err) {\r\nprintk(KERN_WARNING "efivars: set_variable() failed: status=%d\n", err);\r\nreturn -EIO;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nefivar_show_raw(struct efivar_entry *entry, char *buf)\r\n{\r\nstruct efi_variable *var = &entry->var;\r\nstruct compat_efi_variable *compat;\r\nsize_t size;\r\nif (!entry || !buf)\r\nreturn 0;\r\nvar->DataSize = 1024;\r\nif (efivar_entry_get(entry, &entry->var.Attributes,\r\n&entry->var.DataSize, entry->var.Data))\r\nreturn -EIO;\r\nif (is_compat()) {\r\ncompat = (struct compat_efi_variable *)buf;\r\nsize = sizeof(*compat);\r\nmemcpy(compat->VariableName, var->VariableName,\r\nEFI_VAR_NAME_LEN);\r\nmemcpy(compat->Data, var->Data, sizeof(compat->Data));\r\ncompat->VendorGuid = var->VendorGuid;\r\ncompat->DataSize = var->DataSize;\r\ncompat->Attributes = var->Attributes;\r\n} else {\r\nsize = sizeof(*var);\r\nmemcpy(buf, var, size);\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t efivar_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efivar_entry *var = to_efivar_entry(kobj);\r\nstruct efivar_attribute *efivar_attr = to_efivar_attr(attr);\r\nssize_t ret = -EIO;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (efivar_attr->show) {\r\nret = efivar_attr->show(var, buf);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t efivar_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct efivar_entry *var = to_efivar_entry(kobj);\r\nstruct efivar_attribute *efivar_attr = to_efivar_attr(attr);\r\nssize_t ret = -EIO;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (efivar_attr->store)\r\nret = efivar_attr->store(var, buf, count);\r\nreturn ret;\r\n}\r\nstatic void efivar_release(struct kobject *kobj)\r\n{\r\nstruct efivar_entry *var = container_of(kobj, struct efivar_entry, kobj);\r\nkfree(var);\r\n}\r\nstatic ssize_t efivar_create(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct compat_efi_variable *compat = (struct compat_efi_variable *)buf;\r\nstruct efi_variable *new_var = (struct efi_variable *)buf;\r\nstruct efivar_entry *new_entry;\r\nbool need_compat = is_compat();\r\nefi_char16_t *name;\r\nunsigned long size;\r\nu32 attributes;\r\nu8 *data;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (need_compat) {\r\nif (count != sizeof(*compat))\r\nreturn -EINVAL;\r\nattributes = compat->Attributes;\r\nname = compat->VariableName;\r\nsize = compat->DataSize;\r\ndata = compat->Data;\r\n} else {\r\nif (count != sizeof(*new_var))\r\nreturn -EINVAL;\r\nattributes = new_var->Attributes;\r\nname = new_var->VariableName;\r\nsize = new_var->DataSize;\r\ndata = new_var->Data;\r\n}\r\nif ((attributes & ~EFI_VARIABLE_MASK) != 0 ||\r\nefivar_validate(name, data, size) == false) {\r\nprintk(KERN_ERR "efivars: Malformed variable content\n");\r\nreturn -EINVAL;\r\n}\r\nnew_entry = kzalloc(sizeof(*new_entry), GFP_KERNEL);\r\nif (!new_entry)\r\nreturn -ENOMEM;\r\nif (need_compat)\r\ncopy_out_compat(&new_entry->var, compat);\r\nelse\r\nmemcpy(&new_entry->var, new_var, sizeof(*new_var));\r\nerr = efivar_entry_set(new_entry, attributes, size,\r\ndata, &efivar_sysfs_list);\r\nif (err) {\r\nif (err == -EEXIST)\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (efivar_create_sysfs_entry(new_entry)) {\r\nprintk(KERN_WARNING "efivars: failed to create sysfs entry.\n");\r\nkfree(new_entry);\r\n}\r\nreturn count;\r\nout:\r\nkfree(new_entry);\r\nreturn err;\r\n}\r\nstatic ssize_t efivar_delete(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct efi_variable *del_var = (struct efi_variable *)buf;\r\nstruct compat_efi_variable *compat;\r\nstruct efivar_entry *entry;\r\nefi_char16_t *name;\r\nefi_guid_t vendor;\r\nint err = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (is_compat()) {\r\nif (count != sizeof(*compat))\r\nreturn -EINVAL;\r\ncompat = (struct compat_efi_variable *)buf;\r\nname = compat->VariableName;\r\nvendor = compat->VendorGuid;\r\n} else {\r\nif (count != sizeof(*del_var))\r\nreturn -EINVAL;\r\nname = del_var->VariableName;\r\nvendor = del_var->VendorGuid;\r\n}\r\nefivar_entry_iter_begin();\r\nentry = efivar_entry_find(name, vendor, &efivar_sysfs_list, true);\r\nif (!entry)\r\nerr = -EINVAL;\r\nelse if (__efivar_entry_delete(entry))\r\nerr = -EIO;\r\nif (err) {\r\nefivar_entry_iter_end();\r\nreturn err;\r\n}\r\nif (!entry->scanning) {\r\nefivar_entry_iter_end();\r\nefivar_unregister(entry);\r\n} else\r\nefivar_entry_iter_end();\r\nreturn count;\r\n}\r\nstatic int\r\nefivar_create_sysfs_entry(struct efivar_entry *new_var)\r\n{\r\nint i, short_name_size;\r\nchar *short_name;\r\nunsigned long variable_name_size;\r\nefi_char16_t *variable_name;\r\nint ret;\r\nvariable_name = new_var->var.VariableName;\r\nvariable_name_size = ucs2_strlen(variable_name) * sizeof(efi_char16_t);\r\nshort_name_size = variable_name_size / sizeof(efi_char16_t)\r\n+ 1 + EFI_VARIABLE_GUID_LEN + 1;\r\nshort_name = kzalloc(short_name_size, GFP_KERNEL);\r\nif (!short_name)\r\nreturn -ENOMEM;\r\nfor (i=0; i < (int)(variable_name_size / sizeof(efi_char16_t)); i++) {\r\nshort_name[i] = variable_name[i] & 0xFF;\r\n}\r\n*(short_name + strlen(short_name)) = '-';\r\nefi_guid_to_str(&new_var->var.VendorGuid,\r\nshort_name + strlen(short_name));\r\nnew_var->kobj.kset = efivars_kset;\r\nret = kobject_init_and_add(&new_var->kobj, &efivar_ktype,\r\nNULL, "%s", short_name);\r\nkfree(short_name);\r\nif (ret)\r\nreturn ret;\r\nkobject_uevent(&new_var->kobj, KOBJ_ADD);\r\nefivar_entry_add(new_var, &efivar_sysfs_list);\r\nreturn 0;\r\n}\r\nstatic int\r\ncreate_efivars_bin_attributes(void)\r\n{\r\nstruct bin_attribute *attr;\r\nint error;\r\nattr = kzalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nattr->attr.name = "new_var";\r\nattr->attr.mode = 0200;\r\nattr->write = efivar_create;\r\nefivars_new_var = attr;\r\nattr = kzalloc(sizeof(*attr), GFP_KERNEL);\r\nif (!attr) {\r\nerror = -ENOMEM;\r\ngoto out_free;\r\n}\r\nattr->attr.name = "del_var";\r\nattr->attr.mode = 0200;\r\nattr->write = efivar_delete;\r\nefivars_del_var = attr;\r\nsysfs_bin_attr_init(efivars_new_var);\r\nsysfs_bin_attr_init(efivars_del_var);\r\nerror = sysfs_create_bin_file(&efivars_kset->kobj, efivars_new_var);\r\nif (error) {\r\nprintk(KERN_ERR "efivars: unable to create new_var sysfs file"\r\n" due to error %d\n", error);\r\ngoto out_free;\r\n}\r\nerror = sysfs_create_bin_file(&efivars_kset->kobj, efivars_del_var);\r\nif (error) {\r\nprintk(KERN_ERR "efivars: unable to create del_var sysfs file"\r\n" due to error %d\n", error);\r\nsysfs_remove_bin_file(&efivars_kset->kobj, efivars_new_var);\r\ngoto out_free;\r\n}\r\nreturn 0;\r\nout_free:\r\nkfree(efivars_del_var);\r\nefivars_del_var = NULL;\r\nkfree(efivars_new_var);\r\nefivars_new_var = NULL;\r\nreturn error;\r\n}\r\nstatic int efivar_update_sysfs_entry(efi_char16_t *name, efi_guid_t vendor,\r\nunsigned long name_size, void *data)\r\n{\r\nstruct efivar_entry *entry = data;\r\nif (efivar_entry_find(name, vendor, &efivar_sysfs_list, false))\r\nreturn 0;\r\nmemcpy(entry->var.VariableName, name, name_size);\r\nmemcpy(&(entry->var.VendorGuid), &vendor, sizeof(efi_guid_t));\r\nreturn 1;\r\n}\r\nstatic void efivar_update_sysfs_entries(struct work_struct *work)\r\n{\r\nstruct efivar_entry *entry;\r\nint err;\r\nwhile (1) {\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn;\r\nerr = efivar_init(efivar_update_sysfs_entry, entry,\r\ntrue, false, &efivar_sysfs_list);\r\nif (!err)\r\nbreak;\r\nefivar_create_sysfs_entry(entry);\r\n}\r\nkfree(entry);\r\n}\r\nstatic int efivars_sysfs_callback(efi_char16_t *name, efi_guid_t vendor,\r\nunsigned long name_size, void *data)\r\n{\r\nstruct efivar_entry *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nmemcpy(entry->var.VariableName, name, name_size);\r\nmemcpy(&(entry->var.VendorGuid), &vendor, sizeof(efi_guid_t));\r\nefivar_create_sysfs_entry(entry);\r\nreturn 0;\r\n}\r\nstatic int efivar_sysfs_destroy(struct efivar_entry *entry, void *data)\r\n{\r\nefivar_entry_remove(entry);\r\nefivar_unregister(entry);\r\nreturn 0;\r\n}\r\nstatic void efivars_sysfs_exit(void)\r\n{\r\n__efivar_entry_iter(efivar_sysfs_destroy, &efivar_sysfs_list, NULL, NULL);\r\nif (efivars_new_var)\r\nsysfs_remove_bin_file(&efivars_kset->kobj, efivars_new_var);\r\nif (efivars_del_var)\r\nsysfs_remove_bin_file(&efivars_kset->kobj, efivars_del_var);\r\nkfree(efivars_new_var);\r\nkfree(efivars_del_var);\r\nkset_unregister(efivars_kset);\r\n}\r\nint efivars_sysfs_init(void)\r\n{\r\nstruct kobject *parent_kobj = efivars_kobject();\r\nint error = 0;\r\nif (!efi_enabled(EFI_RUNTIME_SERVICES))\r\nreturn -ENODEV;\r\nif (!parent_kobj)\r\nreturn 0;\r\nprintk(KERN_INFO "EFI Variables Facility v%s %s\n", EFIVARS_VERSION,\r\nEFIVARS_DATE);\r\nefivars_kset = kset_create_and_add("vars", NULL, parent_kobj);\r\nif (!efivars_kset) {\r\nprintk(KERN_ERR "efivars: Subsystem registration failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nefivar_init(efivars_sysfs_callback, NULL, false,\r\ntrue, &efivar_sysfs_list);\r\nerror = create_efivars_bin_attributes();\r\nif (error) {\r\nefivars_sysfs_exit();\r\nreturn error;\r\n}\r\nINIT_WORK(&efivar_work, efivar_update_sysfs_entries);\r\nreturn 0;\r\n}
