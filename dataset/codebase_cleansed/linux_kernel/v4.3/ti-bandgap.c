static u32 ti_bandgap_readl(struct ti_bandgap *bgp, u32 reg)\r\n{\r\nreturn readl(bgp->base + reg);\r\n}\r\nstatic void ti_bandgap_writel(struct ti_bandgap *bgp, u32 val, u32 reg)\r\n{\r\nwritel(val, bgp->base + reg);\r\n}\r\nstatic int ti_bandgap_power(struct ti_bandgap *bgp, bool on)\r\n{\r\nint i;\r\nif (!TI_BANDGAP_HAS(bgp, POWER_SWITCH))\r\nreturn -ENOTSUPP;\r\nfor (i = 0; i < bgp->conf->sensor_count; i++)\r\nRMW_BITS(bgp, i, temp_sensor_ctrl, bgap_tempsoff_mask, !on);\r\nreturn 0;\r\n}\r\nstatic u32 ti_errata814_bandgap_read_temp(struct ti_bandgap *bgp, u32 reg)\r\n{\r\nu32 val1, val2;\r\nval1 = ti_bandgap_readl(bgp, reg);\r\nval2 = ti_bandgap_readl(bgp, reg);\r\nif (val1 == val2)\r\nreturn val1;\r\nreturn ti_bandgap_readl(bgp, reg);\r\n}\r\nstatic u32 ti_bandgap_read_temp(struct ti_bandgap *bgp, int id)\r\n{\r\nstruct temp_sensor_registers *tsr;\r\nu32 temp, reg;\r\ntsr = bgp->conf->sensors[id].registers;\r\nreg = tsr->temp_sensor_ctrl;\r\nif (TI_BANDGAP_HAS(bgp, FREEZE_BIT)) {\r\nRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 1);\r\nreg = tsr->ctrl_dtemp_1;\r\n}\r\nif (TI_BANDGAP_HAS(bgp, ERRATA_814))\r\ntemp = ti_errata814_bandgap_read_temp(bgp, reg);\r\nelse\r\ntemp = ti_bandgap_readl(bgp, reg);\r\ntemp &= tsr->bgap_dtemp_mask;\r\nif (TI_BANDGAP_HAS(bgp, FREEZE_BIT))\r\nRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 0);\r\nreturn temp;\r\n}\r\nstatic irqreturn_t ti_bandgap_talert_irq_handler(int irq, void *data)\r\n{\r\nstruct ti_bandgap *bgp = data;\r\nstruct temp_sensor_registers *tsr;\r\nu32 t_hot = 0, t_cold = 0, ctrl;\r\nint i;\r\nspin_lock(&bgp->lock);\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\ntsr = bgp->conf->sensors[i].registers;\r\nctrl = ti_bandgap_readl(bgp, tsr->bgap_status);\r\nt_hot = ctrl & tsr->status_hot_mask;\r\nt_cold = ctrl & tsr->status_cold_mask;\r\nif (!t_cold && !t_hot)\r\ncontinue;\r\nctrl = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\r\nif (t_hot) {\r\nctrl &= ~tsr->mask_hot_mask;\r\nctrl |= tsr->mask_cold_mask;\r\n} else if (t_cold) {\r\nctrl &= ~tsr->mask_cold_mask;\r\nctrl |= tsr->mask_hot_mask;\r\n}\r\nti_bandgap_writel(bgp, ctrl, tsr->bgap_mask_ctrl);\r\ndev_dbg(bgp->dev,\r\n"%s: IRQ from %s sensor: hotevent %d coldevent %d\n",\r\n__func__, bgp->conf->sensors[i].domain,\r\nt_hot, t_cold);\r\nif (bgp->conf->report_temperature)\r\nbgp->conf->report_temperature(bgp, i);\r\n}\r\nspin_unlock(&bgp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ti_bandgap_tshut_irq_handler(int irq, void *data)\r\n{\r\npr_emerg("%s: TSHUT temperature reached. Needs shut down...\n",\r\n__func__);\r\norderly_poweroff(true);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic\r\nint ti_bandgap_adc_to_mcelsius(struct ti_bandgap *bgp, int adc_val, int *t)\r\n{\r\nconst struct ti_bandgap_data *conf = bgp->conf;\r\nif (adc_val < conf->adc_start_val || adc_val > conf->adc_end_val)\r\nreturn -ERANGE;\r\n*t = bgp->conf->conv_table[adc_val - conf->adc_start_val];\r\nreturn 0;\r\n}\r\nstatic\r\nint ti_bandgap_mcelsius_to_adc(struct ti_bandgap *bgp, long temp, int *adc)\r\n{\r\nconst struct ti_bandgap_data *conf = bgp->conf;\r\nconst int *conv_table = bgp->conf->conv_table;\r\nint high, low, mid;\r\nlow = 0;\r\nhigh = conf->adc_end_val - conf->adc_start_val;\r\nmid = (high + low) / 2;\r\nif (temp < conv_table[low] || temp > conv_table[high])\r\nreturn -ERANGE;\r\nwhile (low < high) {\r\nif (temp < conv_table[mid])\r\nhigh = mid - 1;\r\nelse\r\nlow = mid + 1;\r\nmid = (low + high) / 2;\r\n}\r\n*adc = conf->adc_start_val + low;\r\nreturn 0;\r\n}\r\nstatic\r\nint ti_bandgap_add_hyst(struct ti_bandgap *bgp, int adc_val, int hyst_val,\r\nu32 *sum)\r\n{\r\nint temp, ret;\r\nret = ti_bandgap_adc_to_mcelsius(bgp, adc_val, &temp);\r\nif (ret < 0)\r\nreturn ret;\r\ntemp += hyst_val;\r\nret = ti_bandgap_mcelsius_to_adc(bgp, temp, sum);\r\nreturn ret;\r\n}\r\nstatic void ti_bandgap_unmask_interrupts(struct ti_bandgap *bgp, int id,\r\nu32 t_hot, u32 t_cold)\r\n{\r\nstruct temp_sensor_registers *tsr;\r\nu32 temp, reg_val;\r\ntemp = ti_bandgap_read_temp(bgp, id);\r\ntsr = bgp->conf->sensors[id].registers;\r\nreg_val = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\r\nif (temp < t_hot)\r\nreg_val |= tsr->mask_hot_mask;\r\nelse\r\nreg_val &= ~tsr->mask_hot_mask;\r\nif (t_cold < temp)\r\nreg_val |= tsr->mask_cold_mask;\r\nelse\r\nreg_val &= ~tsr->mask_cold_mask;\r\nti_bandgap_writel(bgp, reg_val, tsr->bgap_mask_ctrl);\r\n}\r\nstatic int ti_bandgap_update_alert_threshold(struct ti_bandgap *bgp, int id,\r\nint val, bool hot)\r\n{\r\nstruct temp_sensor_data *ts_data = bgp->conf->sensors[id].ts_data;\r\nstruct temp_sensor_registers *tsr;\r\nu32 thresh_val, reg_val, t_hot, t_cold, ctrl;\r\nint err = 0;\r\ntsr = bgp->conf->sensors[id].registers;\r\nthresh_val = ti_bandgap_readl(bgp, tsr->bgap_threshold);\r\nt_cold = (thresh_val & tsr->threshold_tcold_mask) >>\r\n__ffs(tsr->threshold_tcold_mask);\r\nt_hot = (thresh_val & tsr->threshold_thot_mask) >>\r\n__ffs(tsr->threshold_thot_mask);\r\nif (hot)\r\nt_hot = val;\r\nelse\r\nt_cold = val;\r\nif (t_cold > t_hot) {\r\nif (hot)\r\nerr = ti_bandgap_add_hyst(bgp, t_hot,\r\n-ts_data->hyst_val,\r\n&t_cold);\r\nelse\r\nerr = ti_bandgap_add_hyst(bgp, t_cold,\r\nts_data->hyst_val,\r\n&t_hot);\r\n}\r\nreg_val = thresh_val &\r\n~(tsr->threshold_thot_mask | tsr->threshold_tcold_mask);\r\nreg_val |= (t_hot << __ffs(tsr->threshold_thot_mask)) |\r\n(t_cold << __ffs(tsr->threshold_tcold_mask));\r\nif (TI_BANDGAP_HAS(bgp, ERRATA_813)) {\r\nctrl = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\r\nif (hot)\r\nctrl &= ~tsr->mask_hot_mask;\r\nelse\r\nctrl &= ~tsr->mask_cold_mask;\r\nti_bandgap_writel(bgp, ctrl, tsr->bgap_mask_ctrl);\r\n}\r\nti_bandgap_writel(bgp, reg_val, tsr->bgap_threshold);\r\nif (TI_BANDGAP_HAS(bgp, ERRATA_813)) {\r\nctrl = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\r\nif (hot)\r\nctrl |= tsr->mask_hot_mask;\r\nelse\r\nctrl |= tsr->mask_cold_mask;\r\nti_bandgap_writel(bgp, ctrl, tsr->bgap_mask_ctrl);\r\n}\r\nif (err) {\r\ndev_err(bgp->dev, "failed to reprogram thot threshold\n");\r\nerr = -EIO;\r\ngoto exit;\r\n}\r\nti_bandgap_unmask_interrupts(bgp, id, t_hot, t_cold);\r\nexit:\r\nreturn err;\r\n}\r\nstatic inline int ti_bandgap_validate(struct ti_bandgap *bgp, int id)\r\n{\r\nif (!bgp || IS_ERR(bgp)) {\r\npr_err("%s: invalid bandgap pointer\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((id < 0) || (id >= bgp->conf->sensor_count)) {\r\ndev_err(bgp->dev, "%s: sensor id out of range (%d)\n",\r\n__func__, id);\r\nreturn -ERANGE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _ti_bandgap_write_threshold(struct ti_bandgap *bgp, int id, int val,\r\nbool hot)\r\n{\r\nstruct temp_sensor_data *ts_data;\r\nstruct temp_sensor_registers *tsr;\r\nu32 adc_val;\r\nint ret;\r\nret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\nreturn ret;\r\nif (!TI_BANDGAP_HAS(bgp, TALERT))\r\nreturn -ENOTSUPP;\r\nts_data = bgp->conf->sensors[id].ts_data;\r\ntsr = bgp->conf->sensors[id].registers;\r\nif (hot) {\r\nif (val < ts_data->min_temp + ts_data->hyst_val)\r\nret = -EINVAL;\r\n} else {\r\nif (val > ts_data->max_temp + ts_data->hyst_val)\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\nret = ti_bandgap_mcelsius_to_adc(bgp, val, &adc_val);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock(&bgp->lock);\r\nret = ti_bandgap_update_alert_threshold(bgp, id, adc_val, hot);\r\nspin_unlock(&bgp->lock);\r\nreturn ret;\r\n}\r\nstatic int _ti_bandgap_read_threshold(struct ti_bandgap *bgp, int id,\r\nint *val, bool hot)\r\n{\r\nstruct temp_sensor_registers *tsr;\r\nu32 temp, mask;\r\nint ret = 0;\r\nret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\ngoto exit;\r\nif (!TI_BANDGAP_HAS(bgp, TALERT)) {\r\nret = -ENOTSUPP;\r\ngoto exit;\r\n}\r\ntsr = bgp->conf->sensors[id].registers;\r\nif (hot)\r\nmask = tsr->threshold_thot_mask;\r\nelse\r\nmask = tsr->threshold_tcold_mask;\r\ntemp = ti_bandgap_readl(bgp, tsr->bgap_threshold);\r\ntemp = (temp & mask) >> __ffs(mask);\r\nret = ti_bandgap_adc_to_mcelsius(bgp, temp, &temp);\r\nif (ret) {\r\ndev_err(bgp->dev, "failed to read thot\n");\r\nret = -EIO;\r\ngoto exit;\r\n}\r\n*val = temp;\r\nexit:\r\nreturn ret;\r\n}\r\nint ti_bandgap_read_thot(struct ti_bandgap *bgp, int id, int *thot)\r\n{\r\nreturn _ti_bandgap_read_threshold(bgp, id, thot, true);\r\n}\r\nint ti_bandgap_write_thot(struct ti_bandgap *bgp, int id, int val)\r\n{\r\nreturn _ti_bandgap_write_threshold(bgp, id, val, true);\r\n}\r\nint ti_bandgap_read_tcold(struct ti_bandgap *bgp, int id, int *tcold)\r\n{\r\nreturn _ti_bandgap_read_threshold(bgp, id, tcold, false);\r\n}\r\nint ti_bandgap_write_tcold(struct ti_bandgap *bgp, int id, int val)\r\n{\r\nreturn _ti_bandgap_write_threshold(bgp, id, val, false);\r\n}\r\nstatic void ti_bandgap_read_counter(struct ti_bandgap *bgp, int id,\r\nint *interval)\r\n{\r\nstruct temp_sensor_registers *tsr;\r\nint time;\r\ntsr = bgp->conf->sensors[id].registers;\r\ntime = ti_bandgap_readl(bgp, tsr->bgap_counter);\r\ntime = (time & tsr->counter_mask) >>\r\n__ffs(tsr->counter_mask);\r\ntime = time * 1000 / bgp->clk_rate;\r\n*interval = time;\r\n}\r\nstatic void ti_bandgap_read_counter_delay(struct ti_bandgap *bgp, int id,\r\nint *interval)\r\n{\r\nstruct temp_sensor_registers *tsr;\r\nint reg_val;\r\ntsr = bgp->conf->sensors[id].registers;\r\nreg_val = ti_bandgap_readl(bgp, tsr->bgap_mask_ctrl);\r\nreg_val = (reg_val & tsr->mask_counter_delay_mask) >>\r\n__ffs(tsr->mask_counter_delay_mask);\r\nswitch (reg_val) {\r\ncase 0:\r\n*interval = 0;\r\nbreak;\r\ncase 1:\r\n*interval = 1;\r\nbreak;\r\ncase 2:\r\n*interval = 10;\r\nbreak;\r\ncase 3:\r\n*interval = 100;\r\nbreak;\r\ncase 4:\r\n*interval = 250;\r\nbreak;\r\ncase 5:\r\n*interval = 500;\r\nbreak;\r\ndefault:\r\ndev_warn(bgp->dev, "Wrong counter delay value read from register %X",\r\nreg_val);\r\n}\r\n}\r\nint ti_bandgap_read_update_interval(struct ti_bandgap *bgp, int id,\r\nint *interval)\r\n{\r\nint ret = 0;\r\nret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\ngoto exit;\r\nif (!TI_BANDGAP_HAS(bgp, COUNTER) &&\r\n!TI_BANDGAP_HAS(bgp, COUNTER_DELAY)) {\r\nret = -ENOTSUPP;\r\ngoto exit;\r\n}\r\nif (TI_BANDGAP_HAS(bgp, COUNTER)) {\r\nti_bandgap_read_counter(bgp, id, interval);\r\ngoto exit;\r\n}\r\nti_bandgap_read_counter_delay(bgp, id, interval);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int ti_bandgap_write_counter_delay(struct ti_bandgap *bgp, int id,\r\nu32 interval)\r\n{\r\nint rval;\r\nswitch (interval) {\r\ncase 0:\r\nrval = 0x0;\r\nbreak;\r\ncase 1:\r\nrval = 0x1;\r\nbreak;\r\ncase 10:\r\nrval = 0x2;\r\nbreak;\r\ncase 100:\r\nrval = 0x3;\r\nbreak;\r\ncase 250:\r\nrval = 0x4;\r\nbreak;\r\ncase 500:\r\nrval = 0x5;\r\nbreak;\r\ndefault:\r\ndev_warn(bgp->dev, "Delay %d ms is not supported\n", interval);\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&bgp->lock);\r\nRMW_BITS(bgp, id, bgap_mask_ctrl, mask_counter_delay_mask, rval);\r\nspin_unlock(&bgp->lock);\r\nreturn 0;\r\n}\r\nstatic void ti_bandgap_write_counter(struct ti_bandgap *bgp, int id,\r\nu32 interval)\r\n{\r\ninterval = interval * bgp->clk_rate / 1000;\r\nspin_lock(&bgp->lock);\r\nRMW_BITS(bgp, id, bgap_counter, counter_mask, interval);\r\nspin_unlock(&bgp->lock);\r\n}\r\nint ti_bandgap_write_update_interval(struct ti_bandgap *bgp,\r\nint id, u32 interval)\r\n{\r\nint ret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\ngoto exit;\r\nif (!TI_BANDGAP_HAS(bgp, COUNTER) &&\r\n!TI_BANDGAP_HAS(bgp, COUNTER_DELAY)) {\r\nret = -ENOTSUPP;\r\ngoto exit;\r\n}\r\nif (TI_BANDGAP_HAS(bgp, COUNTER)) {\r\nti_bandgap_write_counter(bgp, id, interval);\r\ngoto exit;\r\n}\r\nret = ti_bandgap_write_counter_delay(bgp, id, interval);\r\nexit:\r\nreturn ret;\r\n}\r\nint ti_bandgap_read_temperature(struct ti_bandgap *bgp, int id,\r\nint *temperature)\r\n{\r\nu32 temp;\r\nint ret;\r\nret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\nreturn ret;\r\nif (!TI_BANDGAP_HAS(bgp, MODE_CONFIG)) {\r\nret = ti_bandgap_force_single_read(bgp, id);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock(&bgp->lock);\r\ntemp = ti_bandgap_read_temp(bgp, id);\r\nspin_unlock(&bgp->lock);\r\nret = ti_bandgap_adc_to_mcelsius(bgp, temp, &temp);\r\nif (ret)\r\nreturn -EIO;\r\n*temperature = temp;\r\nreturn 0;\r\n}\r\nint ti_bandgap_set_sensor_data(struct ti_bandgap *bgp, int id, void *data)\r\n{\r\nint ret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\nreturn ret;\r\nbgp->regval[id].data = data;\r\nreturn 0;\r\n}\r\nvoid *ti_bandgap_get_sensor_data(struct ti_bandgap *bgp, int id)\r\n{\r\nint ret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn bgp->regval[id].data;\r\n}\r\nstatic int\r\nti_bandgap_force_single_read(struct ti_bandgap *bgp, int id)\r\n{\r\nu32 counter = 1000;\r\nstruct temp_sensor_registers *tsr;\r\nif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\r\nRMW_BITS(bgp, id, bgap_mode_ctrl, mode_ctrl_mask, 0);\r\nRMW_BITS(bgp, id, temp_sensor_ctrl, bgap_soc_mask, 1);\r\ntsr = bgp->conf->sensors[id].registers;\r\nwhile (--counter) {\r\nif (ti_bandgap_readl(bgp, tsr->temp_sensor_ctrl) &\r\ntsr->bgap_eocz_mask)\r\nbreak;\r\n}\r\nRMW_BITS(bgp, id, temp_sensor_ctrl, bgap_soc_mask, 0);\r\ncounter = 1000;\r\nwhile (--counter) {\r\nif (!(ti_bandgap_readl(bgp, tsr->temp_sensor_ctrl) &\r\ntsr->bgap_eocz_mask))\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_bandgap_set_continuous_mode(struct ti_bandgap *bgp)\r\n{\r\nint i;\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nti_bandgap_force_single_read(bgp, i);\r\nRMW_BITS(bgp, i, bgap_mode_ctrl, mode_ctrl_mask, 1);\r\n}\r\nreturn 0;\r\n}\r\nint ti_bandgap_get_trend(struct ti_bandgap *bgp, int id, int *trend)\r\n{\r\nstruct temp_sensor_registers *tsr;\r\nu32 temp1, temp2, reg1, reg2;\r\nint t1, t2, interval, ret = 0;\r\nret = ti_bandgap_validate(bgp, id);\r\nif (ret)\r\ngoto exit;\r\nif (!TI_BANDGAP_HAS(bgp, HISTORY_BUFFER) ||\r\n!TI_BANDGAP_HAS(bgp, FREEZE_BIT)) {\r\nret = -ENOTSUPP;\r\ngoto exit;\r\n}\r\nspin_lock(&bgp->lock);\r\ntsr = bgp->conf->sensors[id].registers;\r\nRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 1);\r\nreg1 = tsr->ctrl_dtemp_1;\r\nreg2 = tsr->ctrl_dtemp_2;\r\ntemp1 = ti_bandgap_readl(bgp, reg1);\r\ntemp1 &= tsr->bgap_dtemp_mask;\r\ntemp2 = ti_bandgap_readl(bgp, reg2);\r\ntemp2 &= tsr->bgap_dtemp_mask;\r\nret = ti_bandgap_adc_to_mcelsius(bgp, temp1, &t1);\r\nif (ret)\r\ngoto unfreeze;\r\nret = ti_bandgap_adc_to_mcelsius(bgp, temp2, &t2);\r\nif (ret)\r\ngoto unfreeze;\r\nret = ti_bandgap_read_update_interval(bgp, id, &interval);\r\nif (ret)\r\ngoto unfreeze;\r\nif (interval == 0)\r\ninterval = 1;\r\n*trend = (t1 - t2) / interval;\r\ndev_dbg(bgp->dev, "The temperatures are t1 = %d and t2 = %d and trend =%d\n",\r\nt1, t2, *trend);\r\nunfreeze:\r\nRMW_BITS(bgp, id, bgap_mask_ctrl, mask_freeze_mask, 0);\r\nspin_unlock(&bgp->lock);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int ti_bandgap_tshut_init(struct ti_bandgap *bgp,\r\nstruct platform_device *pdev)\r\n{\r\nint gpio_nr = bgp->tshut_gpio;\r\nint status;\r\nstatus = gpio_request(gpio_nr, "tshut");\r\nif (status < 0) {\r\ndev_err(bgp->dev, "Could not request for TSHUT GPIO:%i\n", 86);\r\nreturn status;\r\n}\r\nstatus = gpio_direction_input(gpio_nr);\r\nif (status) {\r\ndev_err(bgp->dev, "Cannot set input TSHUT GPIO %d\n", gpio_nr);\r\nreturn status;\r\n}\r\nstatus = request_irq(gpio_to_irq(gpio_nr), ti_bandgap_tshut_irq_handler,\r\nIRQF_TRIGGER_RISING, "tshut", NULL);\r\nif (status) {\r\ngpio_free(gpio_nr);\r\ndev_err(bgp->dev, "request irq failed for TSHUT");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_bandgap_talert_init(struct ti_bandgap *bgp,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nbgp->irq = platform_get_irq(pdev, 0);\r\nif (bgp->irq < 0) {\r\ndev_err(&pdev->dev, "get_irq failed\n");\r\nreturn bgp->irq;\r\n}\r\nret = request_threaded_irq(bgp->irq, NULL,\r\nti_bandgap_talert_irq_handler,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"talert", bgp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Request threaded irq failed.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ti_bandgap *ti_bandgap_build(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *of_id;\r\nstruct ti_bandgap *bgp;\r\nstruct resource *res;\r\nint i;\r\nif (!node) {\r\ndev_err(&pdev->dev, "no platform information available\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nbgp = devm_kzalloc(&pdev->dev, sizeof(*bgp), GFP_KERNEL);\r\nif (!bgp) {\r\ndev_err(&pdev->dev, "Unable to allocate mem for driver ref\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nof_id = of_match_device(of_ti_bandgap_match, &pdev->dev);\r\nif (of_id)\r\nbgp->conf = of_id->data;\r\nbgp->regval = devm_kzalloc(&pdev->dev, sizeof(*bgp->regval) *\r\nbgp->conf->sensor_count, GFP_KERNEL);\r\nif (!bgp->regval) {\r\ndev_err(&pdev->dev, "Unable to allocate mem for driver ref\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ni = 0;\r\ndo {\r\nvoid __iomem *chunk;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res)\r\nbreak;\r\nchunk = devm_ioremap_resource(&pdev->dev, res);\r\nif (i == 0)\r\nbgp->base = chunk;\r\nif (IS_ERR(chunk))\r\nreturn ERR_CAST(chunk);\r\ni++;\r\n} while (res);\r\nif (TI_BANDGAP_HAS(bgp, TSHUT)) {\r\nbgp->tshut_gpio = of_get_gpio(node, 0);\r\nif (!gpio_is_valid(bgp->tshut_gpio)) {\r\ndev_err(&pdev->dev, "invalid gpio for tshut (%d)\n",\r\nbgp->tshut_gpio);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nreturn bgp;\r\n}\r\nstatic\r\nint ti_bandgap_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_bandgap *bgp;\r\nint clk_rate, ret = 0, i;\r\nbgp = ti_bandgap_build(pdev);\r\nif (IS_ERR(bgp)) {\r\ndev_err(&pdev->dev, "failed to fetch platform data\n");\r\nreturn PTR_ERR(bgp);\r\n}\r\nbgp->dev = &pdev->dev;\r\nif (TI_BANDGAP_HAS(bgp, TSHUT)) {\r\nret = ti_bandgap_tshut_init(bgp, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to initialize system tshut IRQ\n");\r\nreturn ret;\r\n}\r\n}\r\nbgp->fclock = clk_get(NULL, bgp->conf->fclock_name);\r\nret = IS_ERR(bgp->fclock);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request fclock reference\n");\r\nret = PTR_ERR(bgp->fclock);\r\ngoto free_irqs;\r\n}\r\nbgp->div_clk = clk_get(NULL, bgp->conf->div_ck_name);\r\nret = IS_ERR(bgp->div_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request div_ts_ck clock ref\n");\r\nret = PTR_ERR(bgp->div_clk);\r\ngoto free_irqs;\r\n}\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nstruct temp_sensor_registers *tsr;\r\nu32 val;\r\ntsr = bgp->conf->sensors[i].registers;\r\nval = ti_bandgap_readl(bgp, tsr->bgap_efuse);\r\nif (ret || !val)\r\ndev_info(&pdev->dev,\r\n"Non-trimmed BGAP, Temp not accurate\n");\r\n}\r\nclk_rate = clk_round_rate(bgp->div_clk,\r\nbgp->conf->sensors[0].ts_data->max_freq);\r\nif (clk_rate < bgp->conf->sensors[0].ts_data->min_freq ||\r\nclk_rate <= 0) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "wrong clock rate (%d)\n", clk_rate);\r\ngoto put_clks;\r\n}\r\nret = clk_set_rate(bgp->div_clk, clk_rate);\r\nif (ret)\r\ndev_err(&pdev->dev, "Cannot re-set clock rate. Continuing\n");\r\nbgp->clk_rate = clk_rate;\r\nif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\r\nclk_prepare_enable(bgp->fclock);\r\nspin_lock_init(&bgp->lock);\r\nbgp->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, bgp);\r\nti_bandgap_power(bgp, true);\r\nif (TI_BANDGAP_HAS(bgp, COUNTER))\r\nfor (i = 0; i < bgp->conf->sensor_count; i++)\r\nRMW_BITS(bgp, i, bgap_counter, counter_mask, 1);\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nstruct temp_sensor_data *ts_data;\r\nts_data = bgp->conf->sensors[i].ts_data;\r\nif (TI_BANDGAP_HAS(bgp, TALERT)) {\r\nRMW_BITS(bgp, i, bgap_threshold,\r\nthreshold_tcold_mask, ts_data->t_cold);\r\nRMW_BITS(bgp, i, bgap_threshold,\r\nthreshold_thot_mask, ts_data->t_hot);\r\nRMW_BITS(bgp, i, bgap_mask_ctrl, mask_hot_mask, 1);\r\nRMW_BITS(bgp, i, bgap_mask_ctrl, mask_cold_mask, 1);\r\n}\r\nif (TI_BANDGAP_HAS(bgp, TSHUT_CONFIG)) {\r\nRMW_BITS(bgp, i, tshut_threshold,\r\ntshut_hot_mask, ts_data->tshut_hot);\r\nRMW_BITS(bgp, i, tshut_threshold,\r\ntshut_cold_mask, ts_data->tshut_cold);\r\n}\r\n}\r\nif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\r\nti_bandgap_set_continuous_mode(bgp);\r\nif (TI_BANDGAP_HAS(bgp, COUNTER))\r\nfor (i = 0; i < bgp->conf->sensor_count; i++)\r\nRMW_BITS(bgp, i, bgap_counter, counter_mask,\r\nbgp->clk_rate / 4);\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nchar *domain;\r\nif (bgp->conf->sensors[i].register_cooling) {\r\nret = bgp->conf->sensors[i].register_cooling(bgp, i);\r\nif (ret)\r\ngoto remove_sensors;\r\n}\r\nif (bgp->conf->expose_sensor) {\r\ndomain = bgp->conf->sensors[i].domain;\r\nret = bgp->conf->expose_sensor(bgp, i, domain);\r\nif (ret)\r\ngoto remove_last_cooling;\r\n}\r\n}\r\nif (TI_BANDGAP_HAS(bgp, TALERT)) {\r\nret = ti_bandgap_talert_init(bgp, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize Talert IRQ\n");\r\ni = bgp->conf->sensor_count;\r\ngoto disable_clk;\r\n}\r\n}\r\nreturn 0;\r\nremove_last_cooling:\r\nif (bgp->conf->sensors[i].unregister_cooling)\r\nbgp->conf->sensors[i].unregister_cooling(bgp, i);\r\nremove_sensors:\r\nfor (i--; i >= 0; i--) {\r\nif (bgp->conf->sensors[i].unregister_cooling)\r\nbgp->conf->sensors[i].unregister_cooling(bgp, i);\r\nif (bgp->conf->remove_sensor)\r\nbgp->conf->remove_sensor(bgp, i);\r\n}\r\nti_bandgap_power(bgp, false);\r\ndisable_clk:\r\nif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\r\nclk_disable_unprepare(bgp->fclock);\r\nput_clks:\r\nclk_put(bgp->fclock);\r\nclk_put(bgp->div_clk);\r\nfree_irqs:\r\nif (TI_BANDGAP_HAS(bgp, TSHUT)) {\r\nfree_irq(gpio_to_irq(bgp->tshut_gpio), NULL);\r\ngpio_free(bgp->tshut_gpio);\r\n}\r\nreturn ret;\r\n}\r\nstatic\r\nint ti_bandgap_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_bandgap *bgp = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nif (bgp->conf->sensors[i].unregister_cooling)\r\nbgp->conf->sensors[i].unregister_cooling(bgp, i);\r\nif (bgp->conf->remove_sensor)\r\nbgp->conf->remove_sensor(bgp, i);\r\n}\r\nti_bandgap_power(bgp, false);\r\nif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\r\nclk_disable_unprepare(bgp->fclock);\r\nclk_put(bgp->fclock);\r\nclk_put(bgp->div_clk);\r\nif (TI_BANDGAP_HAS(bgp, TALERT))\r\nfree_irq(bgp->irq, bgp);\r\nif (TI_BANDGAP_HAS(bgp, TSHUT)) {\r\nfree_irq(gpio_to_irq(bgp->tshut_gpio), NULL);\r\ngpio_free(bgp->tshut_gpio);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_bandgap_save_ctxt(struct ti_bandgap *bgp)\r\n{\r\nint i;\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nstruct temp_sensor_registers *tsr;\r\nstruct temp_sensor_regval *rval;\r\nrval = &bgp->regval[i];\r\ntsr = bgp->conf->sensors[i].registers;\r\nif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\r\nrval->bg_mode_ctrl = ti_bandgap_readl(bgp,\r\ntsr->bgap_mode_ctrl);\r\nif (TI_BANDGAP_HAS(bgp, COUNTER))\r\nrval->bg_counter = ti_bandgap_readl(bgp,\r\ntsr->bgap_counter);\r\nif (TI_BANDGAP_HAS(bgp, TALERT)) {\r\nrval->bg_threshold = ti_bandgap_readl(bgp,\r\ntsr->bgap_threshold);\r\nrval->bg_ctrl = ti_bandgap_readl(bgp,\r\ntsr->bgap_mask_ctrl);\r\n}\r\nif (TI_BANDGAP_HAS(bgp, TSHUT_CONFIG))\r\nrval->tshut_threshold = ti_bandgap_readl(bgp,\r\ntsr->tshut_threshold);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_bandgap_restore_ctxt(struct ti_bandgap *bgp)\r\n{\r\nint i;\r\nfor (i = 0; i < bgp->conf->sensor_count; i++) {\r\nstruct temp_sensor_registers *tsr;\r\nstruct temp_sensor_regval *rval;\r\nu32 val = 0;\r\nrval = &bgp->regval[i];\r\ntsr = bgp->conf->sensors[i].registers;\r\nif (TI_BANDGAP_HAS(bgp, COUNTER))\r\nval = ti_bandgap_readl(bgp, tsr->bgap_counter);\r\nif (TI_BANDGAP_HAS(bgp, TSHUT_CONFIG))\r\nti_bandgap_writel(bgp, rval->tshut_threshold,\r\ntsr->tshut_threshold);\r\nti_bandgap_force_single_read(bgp, i);\r\nif (TI_BANDGAP_HAS(bgp, COUNTER))\r\nti_bandgap_writel(bgp, rval->bg_counter,\r\ntsr->bgap_counter);\r\nif (TI_BANDGAP_HAS(bgp, MODE_CONFIG))\r\nti_bandgap_writel(bgp, rval->bg_mode_ctrl,\r\ntsr->bgap_mode_ctrl);\r\nif (TI_BANDGAP_HAS(bgp, TALERT)) {\r\nti_bandgap_writel(bgp, rval->bg_threshold,\r\ntsr->bgap_threshold);\r\nti_bandgap_writel(bgp, rval->bg_ctrl,\r\ntsr->bgap_mask_ctrl);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_bandgap_suspend(struct device *dev)\r\n{\r\nstruct ti_bandgap *bgp = dev_get_drvdata(dev);\r\nint err;\r\nerr = ti_bandgap_save_ctxt(bgp);\r\nti_bandgap_power(bgp, false);\r\nif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\r\nclk_disable_unprepare(bgp->fclock);\r\nreturn err;\r\n}\r\nstatic int ti_bandgap_resume(struct device *dev)\r\n{\r\nstruct ti_bandgap *bgp = dev_get_drvdata(dev);\r\nif (TI_BANDGAP_HAS(bgp, CLK_CTRL))\r\nclk_prepare_enable(bgp->fclock);\r\nti_bandgap_power(bgp, true);\r\nreturn ti_bandgap_restore_ctxt(bgp);\r\n}
