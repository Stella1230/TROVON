static u32 cookie_hash(__be32 saddr, __be32 daddr, __be16 sport, __be16 dport,\r\nu32 count, int c)\r\n{\r\n__u32 *tmp;\r\nnet_get_random_once(syncookie_secret, sizeof(syncookie_secret));\r\ntmp = this_cpu_ptr(ipv4_cookie_scratch);\r\nmemcpy(tmp + 4, syncookie_secret[c], sizeof(syncookie_secret[c]));\r\ntmp[0] = (__force u32)saddr;\r\ntmp[1] = (__force u32)daddr;\r\ntmp[2] = ((__force u32)sport << 16) + (__force u32)dport;\r\ntmp[3] = count;\r\nsha_transform(tmp + 16, (__u8 *)tmp, tmp + 16 + 5);\r\nreturn tmp[17];\r\n}\r\n__u32 cookie_init_timestamp(struct request_sock *req)\r\n{\r\nstruct inet_request_sock *ireq;\r\nu32 ts, ts_now = tcp_time_stamp;\r\nu32 options = 0;\r\nireq = inet_rsk(req);\r\noptions = ireq->wscale_ok ? ireq->snd_wscale : TS_OPT_WSCALE_MASK;\r\nif (ireq->sack_ok)\r\noptions |= TS_OPT_SACK;\r\nif (ireq->ecn_ok)\r\noptions |= TS_OPT_ECN;\r\nts = ts_now & ~TSMASK;\r\nts |= options;\r\nif (ts > ts_now) {\r\nts >>= TSBITS;\r\nts--;\r\nts <<= TSBITS;\r\nts |= options;\r\n}\r\nreturn ts;\r\n}\r\nstatic __u32 secure_tcp_syn_cookie(__be32 saddr, __be32 daddr, __be16 sport,\r\n__be16 dport, __u32 sseq, __u32 data)\r\n{\r\nu32 count = tcp_cookie_time();\r\nreturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\r\nsseq + (count << COOKIEBITS) +\r\n((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\r\n& COOKIEMASK));\r\n}\r\nstatic __u32 check_tcp_syn_cookie(__u32 cookie, __be32 saddr, __be32 daddr,\r\n__be16 sport, __be16 dport, __u32 sseq)\r\n{\r\nu32 diff, count = tcp_cookie_time();\r\ncookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\r\ndiff = (count - (cookie >> COOKIEBITS)) & ((__u32) -1 >> COOKIEBITS);\r\nif (diff >= MAX_SYNCOOKIE_AGE)\r\nreturn (__u32)-1;\r\nreturn (cookie -\r\ncookie_hash(saddr, daddr, sport, dport, count - diff, 1))\r\n& COOKIEMASK;\r\n}\r\nu32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,\r\nu16 *mssp)\r\n{\r\nint mssind;\r\nconst __u16 mss = *mssp;\r\nfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\r\nif (mss >= msstab[mssind])\r\nbreak;\r\n*mssp = msstab[mssind];\r\nreturn secure_tcp_syn_cookie(iph->saddr, iph->daddr,\r\nth->source, th->dest, ntohl(th->seq),\r\nmssind);\r\n}\r\n__u32 cookie_v4_init_sequence(struct sock *sk, const struct sk_buff *skb,\r\n__u16 *mssp)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\ntcp_synq_overflow(sk);\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESSENT);\r\nreturn __cookie_v4_init_sequence(iph, th, mssp);\r\n}\r\nint __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,\r\nu32 cookie)\r\n{\r\n__u32 seq = ntohl(th->seq) - 1;\r\n__u32 mssind = check_tcp_syn_cookie(cookie, iph->saddr, iph->daddr,\r\nth->source, th->dest, seq);\r\nreturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\r\n}\r\nstruct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,\r\nstruct request_sock *req,\r\nstruct dst_entry *dst)\r\n{\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct sock *child;\r\nchild = icsk->icsk_af_ops->syn_recv_sock(sk, skb, req, dst);\r\nif (child) {\r\natomic_set(&req->rsk_refcnt, 1);\r\ninet_csk_reqsk_queue_add(sk, req, child);\r\n} else {\r\nreqsk_free(req);\r\n}\r\nreturn child;\r\n}\r\nbool cookie_timestamp_decode(struct tcp_options_received *tcp_opt)\r\n{\r\nu32 options = tcp_opt->rcv_tsecr;\r\nif (!tcp_opt->saw_tstamp) {\r\ntcp_clear_options(tcp_opt);\r\nreturn true;\r\n}\r\nif (!sysctl_tcp_timestamps)\r\nreturn false;\r\ntcp_opt->sack_ok = (options & TS_OPT_SACK) ? TCP_SACK_SEEN : 0;\r\nif (tcp_opt->sack_ok && !sysctl_tcp_sack)\r\nreturn false;\r\nif ((options & TS_OPT_WSCALE_MASK) == TS_OPT_WSCALE_MASK)\r\nreturn true;\r\ntcp_opt->wscale_ok = 1;\r\ntcp_opt->snd_wscale = options & TS_OPT_WSCALE_MASK;\r\nreturn sysctl_tcp_window_scaling != 0;\r\n}\r\nbool cookie_ecn_ok(const struct tcp_options_received *tcp_opt,\r\nconst struct net *net, const struct dst_entry *dst)\r\n{\r\nbool ecn_ok = tcp_opt->rcv_tsecr & TS_OPT_ECN;\r\nif (!ecn_ok)\r\nreturn false;\r\nif (net->ipv4.sysctl_tcp_ecn)\r\nreturn true;\r\nreturn dst_feature(dst, RTAX_FEATURE_ECN);\r\n}\r\nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\r\nstruct tcp_options_received tcp_opt;\r\nstruct inet_request_sock *ireq;\r\nstruct tcp_request_sock *treq;\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nconst struct tcphdr *th = tcp_hdr(skb);\r\n__u32 cookie = ntohl(th->ack_seq) - 1;\r\nstruct sock *ret = sk;\r\nstruct request_sock *req;\r\nint mss;\r\nstruct rtable *rt;\r\n__u8 rcv_wscale;\r\nstruct flowi4 fl4;\r\nif (!sysctl_tcp_syncookies || !th->ack || th->rst)\r\ngoto out;\r\nif (tcp_synq_no_recent_overflow(sk))\r\ngoto out;\r\nmss = __cookie_v4_check(ip_hdr(skb), th, cookie);\r\nif (mss == 0) {\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\r\ngoto out;\r\n}\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\r\nmemset(&tcp_opt, 0, sizeof(tcp_opt));\r\ntcp_parse_options(skb, &tcp_opt, 0, NULL);\r\nif (!cookie_timestamp_decode(&tcp_opt))\r\ngoto out;\r\nret = NULL;\r\nreq = inet_reqsk_alloc(&tcp_request_sock_ops, sk);\r\nif (!req)\r\ngoto out;\r\nireq = inet_rsk(req);\r\ntreq = tcp_rsk(req);\r\ntreq->rcv_isn = ntohl(th->seq) - 1;\r\ntreq->snt_isn = cookie;\r\nreq->mss = mss;\r\nireq->ir_num = ntohs(th->dest);\r\nireq->ir_rmt_port = th->source;\r\nsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\r\nsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\r\nireq->ir_mark = inet_request_mark(sk, skb);\r\nireq->snd_wscale = tcp_opt.snd_wscale;\r\nireq->sack_ok = tcp_opt.sack_ok;\r\nireq->wscale_ok = tcp_opt.wscale_ok;\r\nireq->tstamp_ok = tcp_opt.saw_tstamp;\r\nreq->ts_recent = tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\r\ntreq->snt_synack = tcp_opt.saw_tstamp ? tcp_opt.rcv_tsecr : 0;\r\ntreq->tfo_listener = false;\r\nireq->ir_iif = sk->sk_bound_dev_if;\r\nireq->opt = tcp_v4_save_options(skb);\r\nif (security_inet_conn_request(sk, skb, req)) {\r\nreqsk_free(req);\r\ngoto out;\r\n}\r\nreq->num_retrans = 0;\r\nflowi4_init_output(&fl4, sk->sk_bound_dev_if, ireq->ir_mark,\r\nRT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, IPPROTO_TCP,\r\ninet_sk_flowi_flags(sk),\r\nopt->srr ? opt->faddr : ireq->ir_rmt_addr,\r\nireq->ir_loc_addr, th->source, th->dest);\r\nsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\r\nrt = ip_route_output_key(sock_net(sk), &fl4);\r\nif (IS_ERR(rt)) {\r\nreqsk_free(req);\r\ngoto out;\r\n}\r\nreq->window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\r\ntcp_select_initial_window(tcp_full_space(sk), req->mss,\r\n&req->rcv_wnd, &req->window_clamp,\r\nireq->wscale_ok, &rcv_wscale,\r\ndst_metric(&rt->dst, RTAX_INITRWND));\r\nireq->rcv_wscale = rcv_wscale;\r\nireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), &rt->dst);\r\nret = tcp_get_cookie_sock(sk, skb, req, &rt->dst);\r\nif (ret)\r\ninet_sk(ret)->cork.fl.u.ip4 = fl4;\r\nout: return ret;\r\n}
