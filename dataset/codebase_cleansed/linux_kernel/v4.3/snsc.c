static irqreturn_t\r\nscdrv_interrupt(int irq, void *subch_data)\r\n{\r\nstruct subch_data_s *sd = subch_data;\r\nunsigned long flags;\r\nint status;\r\nspin_lock_irqsave(&sd->sd_rlock, flags);\r\nspin_lock(&sd->sd_wlock);\r\nstatus = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);\r\nif (status > 0) {\r\nif (status & SAL_IROUTER_INTR_RECV) {\r\nwake_up(&sd->sd_rq);\r\n}\r\nif (status & SAL_IROUTER_INTR_XMIT) {\r\nia64_sn_irtr_intr_disable\r\n(sd->sd_nasid, sd->sd_subch,\r\nSAL_IROUTER_INTR_XMIT);\r\nwake_up(&sd->sd_wq);\r\n}\r\n}\r\nspin_unlock(&sd->sd_wlock);\r\nspin_unlock_irqrestore(&sd->sd_rlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nscdrv_open(struct inode *inode, struct file *file)\r\n{\r\nstruct sysctl_data_s *scd;\r\nstruct subch_data_s *sd;\r\nint rv;\r\nscd = container_of(inode->i_cdev, struct sysctl_data_s, scd_cdev);\r\nsd = kzalloc(sizeof (struct subch_data_s), GFP_KERNEL);\r\nif (sd == NULL) {\r\nprintk("%s: couldn't allocate subchannel data\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nsd->sd_nasid = scd->scd_nasid;\r\nsd->sd_subch = ia64_sn_irtr_open(scd->scd_nasid);\r\nif (sd->sd_subch < 0) {\r\nkfree(sd);\r\nprintk("%s: couldn't allocate subchannel\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nspin_lock_init(&sd->sd_rlock);\r\nspin_lock_init(&sd->sd_wlock);\r\ninit_waitqueue_head(&sd->sd_rq);\r\ninit_waitqueue_head(&sd->sd_wq);\r\nsema_init(&sd->sd_rbs, 1);\r\nsema_init(&sd->sd_wbs, 1);\r\nfile->private_data = sd;\r\nmutex_lock(&scdrv_mutex);\r\nrv = request_irq(SGI_UART_VECTOR, scdrv_interrupt,\r\nIRQF_SHARED, SYSCTL_BASENAME, sd);\r\nif (rv) {\r\nia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);\r\nkfree(sd);\r\nprintk("%s: irq request failed (%d)\n", __func__, rv);\r\nmutex_unlock(&scdrv_mutex);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&scdrv_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nscdrv_release(struct inode *inode, struct file *file)\r\n{\r\nstruct subch_data_s *sd = (struct subch_data_s *) file->private_data;\r\nint rv;\r\nfree_irq(SGI_UART_VECTOR, sd);\r\nrv = ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);\r\nkfree(sd);\r\nreturn rv;\r\n}\r\nstatic inline int\r\nread_status_check(struct subch_data_s *sd, int *len)\r\n{\r\nreturn ia64_sn_irtr_recv(sd->sd_nasid, sd->sd_subch, sd->sd_rb, len);\r\n}\r\nstatic ssize_t\r\nscdrv_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)\r\n{\r\nint status;\r\nint len;\r\nunsigned long flags;\r\nstruct subch_data_s *sd = (struct subch_data_s *) file->private_data;\r\nif (down_trylock(&sd->sd_rbs)) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nreturn -EAGAIN;\r\n}\r\nif (down_interruptible(&sd->sd_rbs)) {\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nlen = CHUNKSIZE;\r\nspin_lock_irqsave(&sd->sd_rlock, flags);\r\nstatus = read_status_check(sd, &len);\r\nwhile (status < 0) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (file->f_flags & O_NONBLOCK) {\r\nspin_unlock_irqrestore(&sd->sd_rlock, flags);\r\nup(&sd->sd_rbs);\r\nreturn -EAGAIN;\r\n}\r\nlen = CHUNKSIZE;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&sd->sd_rq, &wait);\r\nspin_unlock_irqrestore(&sd->sd_rlock, flags);\r\nschedule_timeout(msecs_to_jiffies(SCDRV_TIMEOUT));\r\nremove_wait_queue(&sd->sd_rq, &wait);\r\nif (signal_pending(current)) {\r\nup(&sd->sd_rbs);\r\nreturn -ERESTARTSYS;\r\n}\r\nspin_lock_irqsave(&sd->sd_rlock, flags);\r\nstatus = read_status_check(sd, &len);\r\n}\r\nspin_unlock_irqrestore(&sd->sd_rlock, flags);\r\nif (len > 0) {\r\nif (count < len) {\r\npr_debug("%s: only accepting %d of %d bytes\n",\r\n__func__, (int) count, len);\r\n}\r\nlen = min((int) count, len);\r\nif (copy_to_user(buf, sd->sd_rb, len))\r\nlen = -EFAULT;\r\n}\r\nup(&sd->sd_rbs);\r\nreturn len;\r\n}\r\nstatic inline int\r\nwrite_status_check(struct subch_data_s *sd, int count)\r\n{\r\nreturn ia64_sn_irtr_send(sd->sd_nasid, sd->sd_subch, sd->sd_wb, count);\r\n}\r\nstatic ssize_t\r\nscdrv_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nunsigned long flags;\r\nint status;\r\nstruct subch_data_s *sd = (struct subch_data_s *) file->private_data;\r\nif (down_trylock(&sd->sd_wbs)) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nreturn -EAGAIN;\r\n}\r\nif (down_interruptible(&sd->sd_wbs)) {\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\ncount = min((int) count, CHUNKSIZE);\r\nif (copy_from_user(sd->sd_wb, buf, count)) {\r\nup(&sd->sd_wbs);\r\nreturn -EFAULT;\r\n}\r\nspin_lock_irqsave(&sd->sd_wlock, flags);\r\nstatus = write_status_check(sd, count);\r\nwhile (status <= 0) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (file->f_flags & O_NONBLOCK) {\r\nspin_unlock(&sd->sd_wlock);\r\nup(&sd->sd_wbs);\r\nreturn -EAGAIN;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&sd->sd_wq, &wait);\r\nspin_unlock_irqrestore(&sd->sd_wlock, flags);\r\nschedule_timeout(msecs_to_jiffies(SCDRV_TIMEOUT));\r\nremove_wait_queue(&sd->sd_wq, &wait);\r\nif (signal_pending(current)) {\r\nup(&sd->sd_wbs);\r\nreturn -ERESTARTSYS;\r\n}\r\nspin_lock_irqsave(&sd->sd_wlock, flags);\r\nstatus = write_status_check(sd, count);\r\n}\r\nspin_unlock_irqrestore(&sd->sd_wlock, flags);\r\nup(&sd->sd_wbs);\r\nif ((status >= 0) && (status < count)) {\r\npr_debug("Didn't accept the full chunk; %d of %d\n",\r\nstatus, (int) count);\r\n}\r\nreturn status;\r\n}\r\nstatic unsigned int\r\nscdrv_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nunsigned int mask = 0;\r\nint status = 0;\r\nstruct subch_data_s *sd = (struct subch_data_s *) file->private_data;\r\nunsigned long flags;\r\npoll_wait(file, &sd->sd_rq, wait);\r\npoll_wait(file, &sd->sd_wq, wait);\r\nspin_lock_irqsave(&sd->sd_rlock, flags);\r\nspin_lock(&sd->sd_wlock);\r\nstatus = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);\r\nspin_unlock(&sd->sd_wlock);\r\nspin_unlock_irqrestore(&sd->sd_rlock, flags);\r\nif (status > 0) {\r\nif (status & SAL_IROUTER_INTR_RECV) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (status & SAL_IROUTER_INTR_XMIT) {\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\n}\r\nreturn mask;\r\n}\r\nint __init\r\nscdrv_init(void)\r\n{\r\ngeoid_t geoid;\r\ncnodeid_t cnode;\r\nchar devname[32];\r\nchar *devnamep;\r\nstruct sysctl_data_s *scd;\r\nvoid *salbuf;\r\ndev_t first_dev, dev;\r\nnasid_t event_nasid;\r\nif (!ia64_platform_is("sn2"))\r\nreturn -ENODEV;\r\nevent_nasid = ia64_sn_get_console_nasid();\r\nif (alloc_chrdev_region(&first_dev, 0, num_cnodes,\r\nSYSCTL_BASENAME) < 0) {\r\nprintk("%s: failed to register SN system controller device\n",\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nsnsc_class = class_create(THIS_MODULE, SYSCTL_BASENAME);\r\nfor (cnode = 0; cnode < num_cnodes; cnode++) {\r\ngeoid = cnodeid_get_geoid(cnode);\r\ndevnamep = devname;\r\nformat_module_id(devnamep, geo_module(geoid),\r\nMODULE_FORMAT_BRIEF);\r\ndevnamep = devname + strlen(devname);\r\nsprintf(devnamep, "^%d#%d", geo_slot(geoid),\r\ngeo_slab(geoid));\r\nscd = kzalloc(sizeof (struct sysctl_data_s),\r\nGFP_KERNEL);\r\nif (!scd) {\r\nprintk("%s: failed to allocate device info"\r\n"for %s/%s\n", __func__,\r\nSYSCTL_BASENAME, devname);\r\ncontinue;\r\n}\r\nscd->scd_nasid = cnodeid_to_nasid(cnode);\r\nif (!(salbuf = kmalloc(SCDRV_BUFSZ, GFP_KERNEL))) {\r\nprintk("%s: failed to allocate driver buffer"\r\n"(%s%s)\n", __func__,\r\nSYSCTL_BASENAME, devname);\r\nkfree(scd);\r\ncontinue;\r\n}\r\nif (ia64_sn_irtr_init(scd->scd_nasid, salbuf,\r\nSCDRV_BUFSZ) < 0) {\r\nprintk\r\n("%s: failed to initialize SAL for"\r\n" system controller communication"\r\n" (%s/%s): outdated PROM?\n",\r\n__func__, SYSCTL_BASENAME, devname);\r\nkfree(scd);\r\nkfree(salbuf);\r\ncontinue;\r\n}\r\ndev = first_dev + cnode;\r\ncdev_init(&scd->scd_cdev, &scdrv_fops);\r\nif (cdev_add(&scd->scd_cdev, dev, 1)) {\r\nprintk("%s: failed to register system"\r\n" controller device (%s%s)\n",\r\n__func__, SYSCTL_BASENAME, devname);\r\nkfree(scd);\r\nkfree(salbuf);\r\ncontinue;\r\n}\r\ndevice_create(snsc_class, NULL, dev, NULL,\r\n"%s", devname);\r\nia64_sn_irtr_intr_enable(scd->scd_nasid,\r\n0 ,\r\nSAL_IROUTER_INTR_RECV);\r\nif(scd->scd_nasid == event_nasid) {\r\nscdrv_event_init(scd);\r\n}\r\n}\r\nreturn 0;\r\n}
