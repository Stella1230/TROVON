static map_word lf_read(struct map_info *map, unsigned long ofs)\r\n{\r\nstruct latch_addr_flash_info *info;\r\nmap_word datum;\r\ninfo = (struct latch_addr_flash_info *)map->map_priv_1;\r\nspin_lock(&info->lock);\r\ninfo->set_window(ofs, info->data);\r\ndatum = inline_map_read(map, info->win_mask & ofs);\r\nspin_unlock(&info->lock);\r\nreturn datum;\r\n}\r\nstatic void lf_write(struct map_info *map, map_word datum, unsigned long ofs)\r\n{\r\nstruct latch_addr_flash_info *info;\r\ninfo = (struct latch_addr_flash_info *)map->map_priv_1;\r\nspin_lock(&info->lock);\r\ninfo->set_window(ofs, info->data);\r\ninline_map_write(map, datum, info->win_mask & ofs);\r\nspin_unlock(&info->lock);\r\n}\r\nstatic void lf_copy_from(struct map_info *map, void *to,\r\nunsigned long from, ssize_t len)\r\n{\r\nstruct latch_addr_flash_info *info =\r\n(struct latch_addr_flash_info *) map->map_priv_1;\r\nunsigned n;\r\nwhile (len > 0) {\r\nn = info->win_mask + 1 - (from & info->win_mask);\r\nif (n > len)\r\nn = len;\r\nspin_lock(&info->lock);\r\ninfo->set_window(from, info->data);\r\nmemcpy_fromio(to, map->virt + (from & info->win_mask), n);\r\nspin_unlock(&info->lock);\r\nto += n;\r\nfrom += n;\r\nlen -= n;\r\n}\r\n}\r\nstatic int latch_addr_flash_remove(struct platform_device *dev)\r\n{\r\nstruct latch_addr_flash_info *info;\r\nstruct latch_addr_flash_data *latch_addr_data;\r\ninfo = platform_get_drvdata(dev);\r\nif (info == NULL)\r\nreturn 0;\r\nlatch_addr_data = dev_get_platdata(&dev->dev);\r\nif (info->mtd != NULL) {\r\nmtd_device_unregister(info->mtd);\r\nmap_destroy(info->mtd);\r\n}\r\nif (info->map.virt != NULL)\r\niounmap(info->map.virt);\r\nif (info->res != NULL)\r\nrelease_mem_region(info->res->start, resource_size(info->res));\r\nkfree(info);\r\nif (latch_addr_data->done)\r\nlatch_addr_data->done(latch_addr_data->data);\r\nreturn 0;\r\n}\r\nstatic int latch_addr_flash_probe(struct platform_device *dev)\r\n{\r\nstruct latch_addr_flash_data *latch_addr_data;\r\nstruct latch_addr_flash_info *info;\r\nresource_size_t win_base = dev->resource->start;\r\nresource_size_t win_size = resource_size(dev->resource);\r\nchar **probe_type;\r\nint chipsel;\r\nint err;\r\nlatch_addr_data = dev_get_platdata(&dev->dev);\r\nif (latch_addr_data == NULL)\r\nreturn -ENODEV;\r\npr_notice("latch-addr platform flash device: %#llx byte "\r\n"window at %#.8llx\n",\r\n(unsigned long long)win_size, (unsigned long long)win_base);\r\nchipsel = dev->id;\r\nif (latch_addr_data->init) {\r\nerr = latch_addr_data->init(latch_addr_data->data, chipsel);\r\nif (err != 0)\r\nreturn err;\r\n}\r\ninfo = kzalloc(sizeof(struct latch_addr_flash_info), GFP_KERNEL);\r\nif (info == NULL) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\nplatform_set_drvdata(dev, info);\r\ninfo->res = request_mem_region(win_base, win_size, DRIVER_NAME);\r\nif (info->res == NULL) {\r\ndev_err(&dev->dev, "Could not reserve memory region\n");\r\nerr = -EBUSY;\r\ngoto free_info;\r\n}\r\ninfo->map.name = DRIVER_NAME;\r\ninfo->map.size = latch_addr_data->size;\r\ninfo->map.bankwidth = latch_addr_data->width;\r\ninfo->map.phys = NO_XIP;\r\ninfo->map.virt = ioremap(win_base, win_size);\r\nif (!info->map.virt) {\r\nerr = -ENOMEM;\r\ngoto free_res;\r\n}\r\ninfo->map.map_priv_1 = (unsigned long)info;\r\ninfo->map.read = lf_read;\r\ninfo->map.copy_from = lf_copy_from;\r\ninfo->map.write = lf_write;\r\ninfo->set_window = latch_addr_data->set_window;\r\ninfo->data = latch_addr_data->data;\r\ninfo->win_mask = win_size - 1;\r\nspin_lock_init(&info->lock);\r\nfor (probe_type = rom_probe_types; !info->mtd && *probe_type;\r\nprobe_type++)\r\ninfo->mtd = do_map_probe(*probe_type, &info->map);\r\nif (info->mtd == NULL) {\r\ndev_err(&dev->dev, "map_probe failed\n");\r\nerr = -ENODEV;\r\ngoto iounmap;\r\n}\r\ninfo->mtd->owner = THIS_MODULE;\r\nmtd_device_parse_register(info->mtd, NULL, NULL,\r\nlatch_addr_data->parts,\r\nlatch_addr_data->nr_parts);\r\nreturn 0;\r\niounmap:\r\niounmap(info->map.virt);\r\nfree_res:\r\nrelease_mem_region(info->res->start, resource_size(info->res));\r\nfree_info:\r\nkfree(info);\r\ndone:\r\nif (latch_addr_data->done)\r\nlatch_addr_data->done(latch_addr_data->data);\r\nreturn err;\r\n}
