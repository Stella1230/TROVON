void rs400_gart_adjust_size(struct radeon_device *rdev)\r\n{\r\nswitch (rdev->mc.gtt_size/(1024*1024)) {\r\ncase 32:\r\ncase 64:\r\ncase 128:\r\ncase 256:\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unable to use IGP GART size %uM\n",\r\n(unsigned)(rdev->mc.gtt_size >> 20));\r\nDRM_ERROR("Valid GART size for IGP are 32M,64M,128M,256M,512M,1G,2G\n");\r\nDRM_ERROR("Forcing to 32M GART size\n");\r\nrdev->mc.gtt_size = 32 * 1024 * 1024;\r\nreturn;\r\n}\r\n}\r\nvoid rs400_gart_tlb_flush(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp;\r\nunsigned int timeout = rdev->usec_timeout;\r\nWREG32_MC(RS480_GART_CACHE_CNTRL, RS480_GART_CACHE_INVALIDATE);\r\ndo {\r\ntmp = RREG32_MC(RS480_GART_CACHE_CNTRL);\r\nif ((tmp & RS480_GART_CACHE_INVALIDATE) == 0)\r\nbreak;\r\nDRM_UDELAY(1);\r\ntimeout--;\r\n} while (timeout > 0);\r\nWREG32_MC(RS480_GART_CACHE_CNTRL, 0);\r\n}\r\nint rs400_gart_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->gart.ptr) {\r\nWARN(1, "RS400 GART already initialized\n");\r\nreturn 0;\r\n}\r\nswitch(rdev->mc.gtt_size / (1024 * 1024)) {\r\ncase 32:\r\ncase 64:\r\ncase 128:\r\ncase 256:\r\ncase 512:\r\ncase 1024:\r\ncase 2048:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nr = radeon_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\nif (rs400_debugfs_pcie_gart_info_init(rdev))\r\nDRM_ERROR("Failed to register debugfs file for RS400 GART !\n");\r\nrdev->gart.table_size = rdev->gart.num_gpu_pages * 4;\r\nreturn radeon_gart_table_ram_alloc(rdev);\r\n}\r\nint rs400_gart_enable(struct radeon_device *rdev)\r\n{\r\nuint32_t size_reg;\r\nuint32_t tmp;\r\ntmp = RREG32_MC(RS690_AIC_CTRL_SCRATCH);\r\ntmp |= RS690_DIS_OUT_OF_PCI_GART_ACCESS;\r\nWREG32_MC(RS690_AIC_CTRL_SCRATCH, tmp);\r\nswitch(rdev->mc.gtt_size / (1024 * 1024)) {\r\ncase 32:\r\nsize_reg = RS480_VA_SIZE_32MB;\r\nbreak;\r\ncase 64:\r\nsize_reg = RS480_VA_SIZE_64MB;\r\nbreak;\r\ncase 128:\r\nsize_reg = RS480_VA_SIZE_128MB;\r\nbreak;\r\ncase 256:\r\nsize_reg = RS480_VA_SIZE_256MB;\r\nbreak;\r\ncase 512:\r\nsize_reg = RS480_VA_SIZE_512MB;\r\nbreak;\r\ncase 1024:\r\nsize_reg = RS480_VA_SIZE_1GB;\r\nbreak;\r\ncase 2048:\r\nsize_reg = RS480_VA_SIZE_2GB;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rdev->family == CHIP_RS690 || (rdev->family == CHIP_RS740)) {\r\nWREG32_MC(RS690_MCCFG_AGP_BASE, 0xFFFFFFFF);\r\nWREG32_MC(RS690_MCCFG_AGP_BASE_2, 0);\r\n} else {\r\nWREG32(RADEON_AGP_BASE, 0xFFFFFFFF);\r\nWREG32(RS480_AGP_BASE_2, 0);\r\n}\r\ntmp = REG_SET(RS690_MC_AGP_TOP, rdev->mc.gtt_end >> 16);\r\ntmp |= REG_SET(RS690_MC_AGP_START, rdev->mc.gtt_start >> 16);\r\nif ((rdev->family == CHIP_RS690) || (rdev->family == CHIP_RS740)) {\r\nWREG32_MC(RS690_MCCFG_AGP_LOCATION, tmp);\r\ntmp = RREG32(RADEON_BUS_CNTL) & ~RS600_BUS_MASTER_DIS;\r\nWREG32(RADEON_BUS_CNTL, tmp);\r\n} else {\r\nWREG32(RADEON_MC_AGP_LOCATION, tmp);\r\ntmp = RREG32(RADEON_BUS_CNTL) & ~RADEON_BUS_MASTER_DIS;\r\nWREG32(RADEON_BUS_CNTL, tmp);\r\n}\r\ntmp = (u32)rdev->gart.table_addr & 0xfffff000;\r\ntmp |= (upper_32_bits(rdev->gart.table_addr) & 0xff) << 4;\r\nWREG32_MC(RS480_GART_BASE, tmp);\r\nWREG32_MC(RS480_GART_FEATURE_ID,\r\n(RS480_TLB_ENABLE |\r\nRS480_GTW_LAC_EN | RS480_1LEVEL_GART));\r\nWREG32_MC(RS480_AGP_MODE_CNTL,\r\n(1 << RS480_REQ_TYPE_SNOOP_SHIFT) | RS480_REQ_TYPE_SNOOP_DIS);\r\nif ((rdev->family == CHIP_RS690) || (rdev->family == CHIP_RS740)) {\r\ntmp = RREG32_MC(RS480_MC_MISC_CNTL);\r\ntmp |= RS480_GART_INDEX_REG_EN | RS690_BLOCK_GFX_D3_EN;\r\nWREG32_MC(RS480_MC_MISC_CNTL, tmp);\r\n} else {\r\ntmp = RREG32_MC(RS480_MC_MISC_CNTL);\r\ntmp |= RS480_GART_INDEX_REG_EN;\r\nWREG32_MC(RS480_MC_MISC_CNTL, tmp);\r\n}\r\nWREG32_MC(RS480_AGP_ADDRESS_SPACE_SIZE, (RS480_GART_EN | size_reg));\r\nrs400_gart_tlb_flush(rdev);\r\nDRM_INFO("PCIE GART of %uM enabled (table at 0x%016llX).\n",\r\n(unsigned)(rdev->mc.gtt_size >> 20),\r\n(unsigned long long)rdev->gart.table_addr);\r\nrdev->gart.ready = true;\r\nreturn 0;\r\n}\r\nvoid rs400_gart_disable(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp;\r\ntmp = RREG32_MC(RS690_AIC_CTRL_SCRATCH);\r\ntmp |= RS690_DIS_OUT_OF_PCI_GART_ACCESS;\r\nWREG32_MC(RS690_AIC_CTRL_SCRATCH, tmp);\r\nWREG32_MC(RS480_AGP_ADDRESS_SPACE_SIZE, 0);\r\n}\r\nvoid rs400_gart_fini(struct radeon_device *rdev)\r\n{\r\nradeon_gart_fini(rdev);\r\nrs400_gart_disable(rdev);\r\nradeon_gart_table_ram_free(rdev);\r\n}\r\nuint64_t rs400_gart_get_page_entry(uint64_t addr, uint32_t flags)\r\n{\r\nuint32_t entry;\r\nentry = (lower_32_bits(addr) & PAGE_MASK) |\r\n((upper_32_bits(addr) & 0xff) << 4);\r\nif (flags & RADEON_GART_PAGE_READ)\r\nentry |= RS400_PTE_READABLE;\r\nif (flags & RADEON_GART_PAGE_WRITE)\r\nentry |= RS400_PTE_WRITEABLE;\r\nif (!(flags & RADEON_GART_PAGE_SNOOP))\r\nentry |= RS400_PTE_UNSNOOPED;\r\nreturn entry;\r\n}\r\nvoid rs400_gart_set_page(struct radeon_device *rdev, unsigned i,\r\nuint64_t entry)\r\n{\r\nu32 *gtt = rdev->gart.ptr;\r\ngtt[i] = cpu_to_le32(lower_32_bits(entry));\r\n}\r\nint rs400_mc_wait_for_idle(struct radeon_device *rdev)\r\n{\r\nunsigned i;\r\nuint32_t tmp;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32(RADEON_MC_STATUS);\r\nif (tmp & RADEON_MC_IDLE) {\r\nreturn 0;\r\n}\r\nDRM_UDELAY(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic void rs400_gpu_init(struct radeon_device *rdev)\r\n{\r\nr420_pipes_init(rdev);\r\nif (rs400_mc_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "rs400: Failed to wait MC idle while "\r\n"programming pipes. Bad things might happen. %08x\n", RREG32(RADEON_MC_STATUS));\r\n}\r\n}\r\nstatic void rs400_mc_init(struct radeon_device *rdev)\r\n{\r\nu64 base;\r\nrs400_gart_adjust_size(rdev);\r\nrdev->mc.igp_sideport_enabled = radeon_combios_sideport_present(rdev);\r\nrdev->mc.vram_is_ddr = true;\r\nrdev->mc.vram_width = 128;\r\nr100_vram_init_sizes(rdev);\r\nbase = (RREG32(RADEON_NB_TOM) & 0xffff) << 16;\r\nradeon_vram_location(rdev, &rdev->mc, base);\r\nrdev->mc.gtt_base_align = rdev->mc.gtt_size - 1;\r\nradeon_gtt_location(rdev, &rdev->mc);\r\nradeon_update_bandwidth_info(rdev);\r\n}\r\nuint32_t rs400_mc_rreg(struct radeon_device *rdev, uint32_t reg)\r\n{\r\nunsigned long flags;\r\nuint32_t r;\r\nspin_lock_irqsave(&rdev->mc_idx_lock, flags);\r\nWREG32(RS480_NB_MC_INDEX, reg & 0xff);\r\nr = RREG32(RS480_NB_MC_DATA);\r\nWREG32(RS480_NB_MC_INDEX, 0xff);\r\nspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\r\nreturn r;\r\n}\r\nvoid rs400_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rdev->mc_idx_lock, flags);\r\nWREG32(RS480_NB_MC_INDEX, ((reg) & 0xff) | RS480_NB_MC_IND_WR_EN);\r\nWREG32(RS480_NB_MC_DATA, (v));\r\nWREG32(RS480_NB_MC_INDEX, 0xff);\r\nspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\r\n}\r\nstatic int rs400_debugfs_gart_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t tmp;\r\ntmp = RREG32(RADEON_HOST_PATH_CNTL);\r\nseq_printf(m, "HOST_PATH_CNTL 0x%08x\n", tmp);\r\ntmp = RREG32(RADEON_BUS_CNTL);\r\nseq_printf(m, "BUS_CNTL 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS690_AIC_CTRL_SCRATCH);\r\nseq_printf(m, "AIC_CTRL_SCRATCH 0x%08x\n", tmp);\r\nif (rdev->family == CHIP_RS690 || (rdev->family == CHIP_RS740)) {\r\ntmp = RREG32_MC(RS690_MCCFG_AGP_BASE);\r\nseq_printf(m, "MCCFG_AGP_BASE 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS690_MCCFG_AGP_BASE_2);\r\nseq_printf(m, "MCCFG_AGP_BASE_2 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS690_MCCFG_AGP_LOCATION);\r\nseq_printf(m, "MCCFG_AGP_LOCATION 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS690_MCCFG_FB_LOCATION);\r\nseq_printf(m, "MCCFG_FB_LOCATION 0x%08x\n", tmp);\r\ntmp = RREG32(RS690_HDP_FB_LOCATION);\r\nseq_printf(m, "HDP_FB_LOCATION 0x%08x\n", tmp);\r\n} else {\r\ntmp = RREG32(RADEON_AGP_BASE);\r\nseq_printf(m, "AGP_BASE 0x%08x\n", tmp);\r\ntmp = RREG32(RS480_AGP_BASE_2);\r\nseq_printf(m, "AGP_BASE_2 0x%08x\n", tmp);\r\ntmp = RREG32(RADEON_MC_AGP_LOCATION);\r\nseq_printf(m, "MC_AGP_LOCATION 0x%08x\n", tmp);\r\n}\r\ntmp = RREG32_MC(RS480_GART_BASE);\r\nseq_printf(m, "GART_BASE 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS480_GART_FEATURE_ID);\r\nseq_printf(m, "GART_FEATURE_ID 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS480_AGP_MODE_CNTL);\r\nseq_printf(m, "AGP_MODE_CONTROL 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS480_MC_MISC_CNTL);\r\nseq_printf(m, "MC_MISC_CNTL 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x5F);\r\nseq_printf(m, "MC_MISC_UMA_CNTL 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS480_AGP_ADDRESS_SPACE_SIZE);\r\nseq_printf(m, "AGP_ADDRESS_SPACE_SIZE 0x%08x\n", tmp);\r\ntmp = RREG32_MC(RS480_GART_CACHE_CNTRL);\r\nseq_printf(m, "GART_CACHE_CNTRL 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x3B);\r\nseq_printf(m, "MC_GART_ERROR_ADDRESS 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x3C);\r\nseq_printf(m, "MC_GART_ERROR_ADDRESS_HI 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x30);\r\nseq_printf(m, "GART_ERROR_0 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x31);\r\nseq_printf(m, "GART_ERROR_1 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x32);\r\nseq_printf(m, "GART_ERROR_2 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x33);\r\nseq_printf(m, "GART_ERROR_3 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x34);\r\nseq_printf(m, "GART_ERROR_4 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x35);\r\nseq_printf(m, "GART_ERROR_5 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x36);\r\nseq_printf(m, "GART_ERROR_6 0x%08x\n", tmp);\r\ntmp = RREG32_MC(0x37);\r\nseq_printf(m, "GART_ERROR_7 0x%08x\n", tmp);\r\nreturn 0;\r\n}\r\nstatic int rs400_debugfs_pcie_gart_info_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, rs400_gart_info_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic void rs400_mc_program(struct radeon_device *rdev)\r\n{\r\nstruct r100_mc_save save;\r\nr100_mc_stop(rdev, &save);\r\nif (rs400_mc_wait_for_idle(rdev))\r\ndev_warn(rdev->dev, "rs400: Wait MC idle timeout before updating MC.\n");\r\nWREG32(R_000148_MC_FB_LOCATION,\r\nS_000148_MC_FB_START(rdev->mc.vram_start >> 16) |\r\nS_000148_MC_FB_TOP(rdev->mc.vram_end >> 16));\r\nr100_mc_resume(rdev, &save);\r\n}\r\nstatic int rs400_startup(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr100_set_common_regs(rdev);\r\nrs400_mc_program(rdev);\r\nr300_clock_startup(rdev);\r\nrs400_gpu_init(rdev);\r\nr100_enable_bm(rdev);\r\nr = rs400_gart_enable(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_wb_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP fences (%d).\n", r);\r\nreturn r;\r\n}\r\nif (!rdev->irq.installed) {\r\nr = radeon_irq_kms_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nr100_irq_set(rdev);\r\nrdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\r\nr = r100_cp_init(rdev, 1024 * 1024);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_ib_pool_init(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "IB initialization failed (%d).\n", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint rs400_resume(struct radeon_device *rdev)\r\n{\r\nint r;\r\nrs400_gart_disable(rdev);\r\nr300_clock_startup(rdev);\r\nrs400_mc_program(rdev);\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev, "GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\nradeon_combios_asic_init(rdev->ddev);\r\nr300_clock_startup(rdev);\r\nradeon_surface_init(rdev);\r\nrdev->accel_working = true;\r\nr = rs400_startup(rdev);\r\nif (r) {\r\nrdev->accel_working = false;\r\n}\r\nreturn r;\r\n}\r\nint rs400_suspend(struct radeon_device *rdev)\r\n{\r\nradeon_pm_suspend(rdev);\r\nr100_cp_disable(rdev);\r\nradeon_wb_disable(rdev);\r\nr100_irq_disable(rdev);\r\nrs400_gart_disable(rdev);\r\nreturn 0;\r\n}\r\nvoid rs400_fini(struct radeon_device *rdev)\r\n{\r\nradeon_pm_fini(rdev);\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nradeon_gem_fini(rdev);\r\nrs400_gart_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nradeon_fence_driver_fini(rdev);\r\nradeon_bo_fini(rdev);\r\nradeon_atombios_fini(rdev);\r\nkfree(rdev->bios);\r\nrdev->bios = NULL;\r\n}\r\nint rs400_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nr100_vga_render_disable(rdev);\r\nradeon_scratch_init(rdev);\r\nradeon_surface_init(rdev);\r\nr100_restore_sanity(rdev);\r\nif (!radeon_get_bios(rdev)) {\r\nif (ASIC_IS_AVIVO(rdev))\r\nreturn -EINVAL;\r\n}\r\nif (rdev->is_atom_bios) {\r\ndev_err(rdev->dev, "Expecting combios for RS400/RS480 GPU\n");\r\nreturn -EINVAL;\r\n} else {\r\nr = radeon_combios_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev,\r\n"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\nif (radeon_boot_test_post_card(rdev) == false)\r\nreturn -EINVAL;\r\nradeon_get_clock_info(rdev->ddev);\r\nrs400_mc_init(rdev);\r\nr = radeon_fence_driver_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_bo_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = rs400_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\nr300_set_reg_safe(rdev);\r\nradeon_pm_init(rdev);\r\nrdev->accel_working = true;\r\nr = rs400_startup(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "Disabling GPU acceleration\n");\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nrs400_gart_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nrdev->accel_working = false;\r\n}\r\nreturn 0;\r\n}
