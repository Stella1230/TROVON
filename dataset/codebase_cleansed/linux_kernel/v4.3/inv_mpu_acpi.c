static int __init asus_t100_matched(const struct dmi_system_id *d)\r\n{\r\nmatched_product_name = INV_MPU_ASUS_T100TA;\r\nreturn 0;\r\n}\r\nstatic int asus_acpi_get_sensor_info(struct acpi_device *adev,\r\nstruct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nint i;\r\nacpi_status status;\r\nunion acpi_object *cpm;\r\nstatus = acpi_evaluate_object(adev->handle, "CNF0", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\ncpm = buffer.pointer;\r\nfor (i = 0; i < cpm->package.count; ++i) {\r\nunion acpi_object *elem;\r\nint j;\r\nelem = &(cpm->package.elements[i]);\r\nfor (j = 0; j < elem->package.count; ++j) {\r\nunion acpi_object *sub_elem;\r\nsub_elem = &(elem->package.elements[j]);\r\nif (sub_elem->type == ACPI_TYPE_STRING)\r\nstrlcpy(info->type, sub_elem->string.pointer,\r\nsizeof(info->type));\r\nelse if (sub_elem->type == ACPI_TYPE_INTEGER) {\r\nif (sub_elem->integer.value != client->addr) {\r\ninfo->addr = sub_elem->integer.value;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nkfree(buffer.pointer);\r\nreturn cpm->package.count;\r\n}\r\nstatic int acpi_i2c_check_resource(struct acpi_resource *ares, void *data)\r\n{\r\nu32 *addr = data;\r\nif (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {\r\nstruct acpi_resource_i2c_serialbus *sb;\r\nsb = &ares->data.i2c_serial_bus;\r\nif (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {\r\nif (*addr)\r\n*addr |= (sb->slave_address << 16);\r\nelse\r\n*addr = sb->slave_address;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int inv_mpu_process_acpi_config(struct i2c_client *client,\r\nunsigned short *primary_addr,\r\nunsigned short *secondary_addr)\r\n{\r\nconst struct acpi_device_id *id;\r\nstruct acpi_device *adev;\r\nu32 i2c_addr = 0;\r\nLIST_HEAD(resources);\r\nint ret;\r\nid = acpi_match_device(client->dev.driver->acpi_match_table,\r\n&client->dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nadev = ACPI_COMPANION(&client->dev);\r\nif (!adev)\r\nreturn -ENODEV;\r\nret = acpi_dev_get_resources(adev, &resources,\r\nacpi_i2c_check_resource, &i2c_addr);\r\nif (ret < 0)\r\nreturn ret;\r\nacpi_dev_free_resource_list(&resources);\r\n*primary_addr = i2c_addr & 0x0000ffff;\r\n*secondary_addr = (i2c_addr & 0xffff0000) >> 16;\r\nreturn 0;\r\n}\r\nint inv_mpu_acpi_create_mux_client(struct inv_mpu6050_state *st)\r\n{\r\nst->mux_client = NULL;\r\nif (ACPI_HANDLE(&st->client->dev)) {\r\nstruct i2c_board_info info;\r\nstruct acpi_device *adev;\r\nint ret = -1;\r\nadev = ACPI_COMPANION(&st->client->dev);\r\nmemset(&info, 0, sizeof(info));\r\ndmi_check_system(inv_mpu_dev_list);\r\nswitch (matched_product_name) {\r\ncase INV_MPU_ASUS_T100TA:\r\nret = asus_acpi_get_sensor_info(adev, st->client,\r\n&info);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret < 0) {\r\nunsigned short primary, secondary;\r\nret = inv_mpu_process_acpi_config(st->client, &primary,\r\n&secondary);\r\nif (!ret && secondary) {\r\nchar *name;\r\ninfo.addr = secondary;\r\nstrlcpy(info.type, dev_name(&adev->dev),\r\nsizeof(info.type));\r\nname = strchr(info.type, ':');\r\nif (name)\r\n*name = '\0';\r\nstrlcat(info.type, "-client",\r\nsizeof(info.type));\r\n} else\r\nreturn 0;\r\n}\r\nst->mux_client = i2c_new_device(st->mux_adapter, &info);\r\nif (!st->mux_client)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid inv_mpu_acpi_delete_mux_client(struct inv_mpu6050_state *st)\r\n{\r\nif (st->mux_client)\r\ni2c_unregister_device(st->mux_client);\r\n}\r\nint inv_mpu_acpi_create_mux_client(struct inv_mpu6050_state *st)\r\n{\r\nreturn 0;\r\n}\r\nvoid inv_mpu_acpi_delete_mux_client(struct inv_mpu6050_state *st)\r\n{\r\n}
