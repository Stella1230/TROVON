int squashfs_readpage_block(struct page *target_page, u64 block, int bsize)\r\n{\r\nstruct inode *inode = target_page->mapping->host;\r\nstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\r\nint file_end = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\r\nint mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\r\nint start_index = target_page->index & ~mask;\r\nint end_index = start_index | mask;\r\nint i, n, pages, missing_pages, bytes, res = -ENOMEM;\r\nstruct page **page;\r\nstruct squashfs_page_actor *actor;\r\nvoid *pageaddr;\r\nif (end_index > file_end)\r\nend_index = file_end;\r\npages = end_index - start_index + 1;\r\npage = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\r\nif (page == NULL)\r\nreturn res;\r\nactor = squashfs_page_actor_init_special(page, pages, 0);\r\nif (actor == NULL)\r\ngoto out;\r\nfor (missing_pages = 0, i = 0, n = start_index; i < pages; i++, n++) {\r\npage[i] = (n == target_page->index) ? target_page :\r\ngrab_cache_page_nowait(target_page->mapping, n);\r\nif (page[i] == NULL) {\r\nmissing_pages++;\r\ncontinue;\r\n}\r\nif (PageUptodate(page[i])) {\r\nunlock_page(page[i]);\r\npage_cache_release(page[i]);\r\npage[i] = NULL;\r\nmissing_pages++;\r\n}\r\n}\r\nif (missing_pages) {\r\nres = squashfs_read_cache(target_page, block, bsize, pages,\r\npage);\r\nif (res < 0)\r\ngoto mark_errored;\r\ngoto out;\r\n}\r\nres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\r\nif (res < 0)\r\ngoto mark_errored;\r\nbytes = res % PAGE_CACHE_SIZE;\r\nif (bytes) {\r\npageaddr = kmap_atomic(page[pages - 1]);\r\nmemset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);\r\nkunmap_atomic(pageaddr);\r\n}\r\nfor (i = 0; i < pages; i++) {\r\nflush_dcache_page(page[i]);\r\nSetPageUptodate(page[i]);\r\nunlock_page(page[i]);\r\nif (page[i] != target_page)\r\npage_cache_release(page[i]);\r\n}\r\nkfree(actor);\r\nkfree(page);\r\nreturn 0;\r\nmark_errored:\r\nfor (i = 0; i < pages; i++) {\r\nif (page[i] == NULL || page[i] == target_page)\r\ncontinue;\r\nflush_dcache_page(page[i]);\r\nSetPageError(page[i]);\r\nunlock_page(page[i]);\r\npage_cache_release(page[i]);\r\n}\r\nout:\r\nkfree(actor);\r\nkfree(page);\r\nreturn res;\r\n}\r\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\r\nint pages, struct page **page)\r\n{\r\nstruct inode *i = target_page->mapping->host;\r\nstruct squashfs_cache_entry *buffer = squashfs_get_datablock(i->i_sb,\r\nblock, bsize);\r\nint bytes = buffer->length, res = buffer->error, n, offset = 0;\r\nvoid *pageaddr;\r\nif (res) {\r\nERROR("Unable to read page, block %llx, size %x\n", block,\r\nbsize);\r\ngoto out;\r\n}\r\nfor (n = 0; n < pages && bytes > 0; n++,\r\nbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\r\nint avail = min_t(int, bytes, PAGE_CACHE_SIZE);\r\nif (page[n] == NULL)\r\ncontinue;\r\npageaddr = kmap_atomic(page[n]);\r\nsquashfs_copy_data(pageaddr, buffer, offset, avail);\r\nmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\r\nkunmap_atomic(pageaddr);\r\nflush_dcache_page(page[n]);\r\nSetPageUptodate(page[n]);\r\nunlock_page(page[n]);\r\nif (page[n] != target_page)\r\npage_cache_release(page[n]);\r\n}\r\nout:\r\nsquashfs_cache_put(buffer);\r\nreturn res;\r\n}
