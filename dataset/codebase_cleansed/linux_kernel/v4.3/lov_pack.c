void lov_dump_lmm_common(int level, void *lmmp)\r\n{\r\nstruct lov_mds_md *lmm = lmmp;\r\nstruct ost_id oi;\r\nlmm_oi_le_to_cpu(&oi, &lmm->lmm_oi);\r\nCDEBUG(level, "objid "DOSTID", magic 0x%08x, pattern %#x\n",\r\nPOSTID(&oi), le32_to_cpu(lmm->lmm_magic),\r\nle32_to_cpu(lmm->lmm_pattern));\r\nCDEBUG(level, "stripe_size %u, stripe_count %u, layout_gen %u\n",\r\nle32_to_cpu(lmm->lmm_stripe_size),\r\nle16_to_cpu(lmm->lmm_stripe_count),\r\nle16_to_cpu(lmm->lmm_layout_gen));\r\n}\r\nstatic void lov_dump_lmm_objects(int level, struct lov_ost_data *lod,\r\nint stripe_count)\r\n{\r\nint i;\r\nif (stripe_count > LOV_V1_INSANE_STRIPE_COUNT) {\r\nCDEBUG(level, "bad stripe_count %u > max_stripe_count %u\n",\r\nstripe_count, LOV_V1_INSANE_STRIPE_COUNT);\r\nreturn;\r\n}\r\nfor (i = 0; i < stripe_count; ++i, ++lod) {\r\nstruct ost_id oi;\r\nostid_le_to_cpu(&lod->l_ost_oi, &oi);\r\nCDEBUG(level, "stripe %u idx %u subobj "DOSTID"\n", i,\r\nle32_to_cpu(lod->l_ost_idx), POSTID(&oi));\r\n}\r\n}\r\nvoid lov_dump_lmm_v1(int level, struct lov_mds_md_v1 *lmm)\r\n{\r\nlov_dump_lmm_common(level, lmm);\r\nlov_dump_lmm_objects(level, lmm->lmm_objects,\r\nle16_to_cpu(lmm->lmm_stripe_count));\r\n}\r\nvoid lov_dump_lmm_v3(int level, struct lov_mds_md_v3 *lmm)\r\n{\r\nlov_dump_lmm_common(level, lmm);\r\nCDEBUG(level, "pool_name "LOV_POOLNAMEF"\n", lmm->lmm_pool_name);\r\nlov_dump_lmm_objects(level, lmm->lmm_objects,\r\nle16_to_cpu(lmm->lmm_stripe_count));\r\n}\r\nvoid lov_dump_lmm(int level, void *lmm)\r\n{\r\nint magic;\r\nmagic = le32_to_cpu(((struct lov_mds_md *)lmm)->lmm_magic);\r\nswitch (magic) {\r\ncase LOV_MAGIC_V1:\r\nlov_dump_lmm_v1(level, (struct lov_mds_md_v1 *)lmm);\r\nbreak;\r\ncase LOV_MAGIC_V3:\r\nlov_dump_lmm_v3(level, (struct lov_mds_md_v3 *)lmm);\r\nbreak;\r\ndefault:\r\nCDEBUG(level, "unrecognized lmm_magic %x, assuming %x\n",\r\nmagic, LOV_MAGIC_V1);\r\nlov_dump_lmm_common(level, lmm);\r\nbreak;\r\n}\r\n}\r\nint lov_packmd(struct obd_export *exp, struct lov_mds_md **lmmp,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct lov_mds_md_v1 *lmmv1;\r\nstruct lov_mds_md_v3 *lmmv3;\r\n__u16 stripe_count;\r\nstruct lov_ost_data_v1 *lmm_objects;\r\nint lmm_size, lmm_magic;\r\nint i;\r\nint cplen = 0;\r\nif (lsm) {\r\nlmm_magic = lsm->lsm_magic;\r\n} else {\r\nif (lmmp && *lmmp)\r\nlmm_magic = le32_to_cpu((*lmmp)->lmm_magic);\r\nelse\r\nlmm_magic = LOV_MAGIC;\r\n}\r\nif ((lmm_magic != LOV_MAGIC_V1) &&\r\n(lmm_magic != LOV_MAGIC_V3)) {\r\nCERROR("bad mem LOV MAGIC: 0x%08X != 0x%08X nor 0x%08X\n",\r\nlmm_magic, LOV_MAGIC_V1, LOV_MAGIC_V3);\r\nreturn -EINVAL;\r\n}\r\nif (lsm) {\r\nif (!lmmp) {\r\nstripe_count = lov_get_stripecnt(lov, lmm_magic,\r\nlsm->lsm_stripe_count);\r\nlsm->lsm_stripe_count = stripe_count;\r\n} else if (!lsm_is_released(lsm)) {\r\nstripe_count = lsm->lsm_stripe_count;\r\n} else {\r\nstripe_count = 0;\r\n}\r\n} else {\r\nstripe_count = lov_mds_md_max_stripe_count(\r\nlov->lov_ocd.ocd_max_easize, lmm_magic);\r\nif (stripe_count > lov->desc.ld_tgt_count)\r\nstripe_count = lov->desc.ld_tgt_count;\r\n}\r\nlmm_size = lov_mds_md_size(stripe_count, lmm_magic);\r\nif (!lmmp)\r\nreturn lmm_size;\r\nif (*lmmp && !lsm) {\r\nstripe_count = le16_to_cpu((*lmmp)->lmm_stripe_count);\r\nlmm_size = lov_mds_md_size(stripe_count, lmm_magic);\r\nkvfree(*lmmp);\r\n*lmmp = NULL;\r\nreturn 0;\r\n}\r\nif (!*lmmp) {\r\n*lmmp = libcfs_kvzalloc(lmm_size, GFP_NOFS);\r\nif (!*lmmp)\r\nreturn -ENOMEM;\r\n}\r\nCDEBUG(D_INFO, "lov_packmd: LOV_MAGIC 0x%08X, lmm_size = %d \n",\r\nlmm_magic, lmm_size);\r\nlmmv1 = *lmmp;\r\nlmmv3 = (struct lov_mds_md_v3 *)*lmmp;\r\nif (lmm_magic == LOV_MAGIC_V3)\r\nlmmv3->lmm_magic = cpu_to_le32(LOV_MAGIC_V3);\r\nelse\r\nlmmv1->lmm_magic = cpu_to_le32(LOV_MAGIC_V1);\r\nif (!lsm)\r\nreturn lmm_size;\r\nlmm_oi_cpu_to_le(&lmmv1->lmm_oi, &lsm->lsm_oi);\r\nlmmv1->lmm_stripe_size = cpu_to_le32(lsm->lsm_stripe_size);\r\nlmmv1->lmm_stripe_count = cpu_to_le16(stripe_count);\r\nlmmv1->lmm_pattern = cpu_to_le32(lsm->lsm_pattern);\r\nlmmv1->lmm_layout_gen = cpu_to_le16(lsm->lsm_layout_gen);\r\nif (lsm->lsm_magic == LOV_MAGIC_V3) {\r\ncplen = strlcpy(lmmv3->lmm_pool_name, lsm->lsm_pool_name,\r\nsizeof(lmmv3->lmm_pool_name));\r\nif (cplen >= sizeof(lmmv3->lmm_pool_name))\r\nreturn -E2BIG;\r\nlmm_objects = lmmv3->lmm_objects;\r\n} else {\r\nlmm_objects = lmmv1->lmm_objects;\r\n}\r\nfor (i = 0; i < stripe_count; i++) {\r\nstruct lov_oinfo *loi = lsm->lsm_oinfo[i];\r\nLASSERTF(ostid_id(&loi->loi_oi) != 0, "lmm_oi "DOSTID\r\n" stripe %u/%u idx %u\n", POSTID(&lmmv1->lmm_oi),\r\ni, stripe_count, loi->loi_ost_idx);\r\nostid_cpu_to_le(&loi->loi_oi, &lmm_objects[i].l_ost_oi);\r\nlmm_objects[i].l_ost_gen = cpu_to_le32(loi->loi_ost_gen);\r\nlmm_objects[i].l_ost_idx = cpu_to_le32(loi->loi_ost_idx);\r\n}\r\nreturn lmm_size;\r\n}\r\n__u16 lov_get_stripecnt(struct lov_obd *lov, __u32 magic, __u16 stripe_count)\r\n{\r\n__u32 max_stripes = LOV_MAX_STRIPE_COUNT_OLD;\r\nif (!stripe_count)\r\nstripe_count = lov->desc.ld_default_stripe_count;\r\nif (stripe_count > lov->desc.ld_active_tgt_count)\r\nstripe_count = lov->desc.ld_active_tgt_count;\r\nif (!stripe_count)\r\nstripe_count = 1;\r\nif (lov->lov_ocd.ocd_connect_flags & OBD_CONNECT_MAX_EASIZE &&\r\nlov->lov_ocd.ocd_max_easize)\r\nmax_stripes = lov_mds_md_max_stripe_count(\r\nlov->lov_ocd.ocd_max_easize, magic);\r\nif (stripe_count > max_stripes)\r\nstripe_count = max_stripes;\r\nreturn stripe_count;\r\n}\r\nstatic int lov_verify_lmm(void *lmm, int lmm_bytes, __u16 *stripe_count)\r\n{\r\nint rc;\r\nif (lsm_op_find(le32_to_cpu(*(__u32 *)lmm)) == NULL) {\r\nchar *buffer;\r\nint sz;\r\nCERROR("bad disk LOV MAGIC: 0x%08X; dumping LMM (size=%d):\n",\r\nle32_to_cpu(*(__u32 *)lmm), lmm_bytes);\r\nsz = lmm_bytes * 2 + 1;\r\nbuffer = libcfs_kvzalloc(sz, GFP_NOFS);\r\nif (buffer != NULL) {\r\nint i;\r\nfor (i = 0; i < lmm_bytes; i++)\r\nsprintf(buffer+2*i, "%.2X", ((char *)lmm)[i]);\r\nbuffer[sz - 1] = '\0';\r\nCERROR("%s\n", buffer);\r\nkvfree(buffer);\r\n}\r\nreturn -EINVAL;\r\n}\r\nrc = lsm_op_find(le32_to_cpu(*(__u32 *)lmm))->lsm_lmm_verify(lmm,\r\nlmm_bytes, stripe_count);\r\nreturn rc;\r\n}\r\nint lov_alloc_memmd(struct lov_stripe_md **lsmp, __u16 stripe_count,\r\nint pattern, int magic)\r\n{\r\nint i, lsm_size;\r\nCDEBUG(D_INFO, "alloc lsm, stripe_count %d\n", stripe_count);\r\n*lsmp = lsm_alloc_plain(stripe_count, &lsm_size);\r\nif (!*lsmp) {\r\nCERROR("can't allocate lsmp stripe_count %d\n", stripe_count);\r\nreturn -ENOMEM;\r\n}\r\natomic_set(&(*lsmp)->lsm_refc, 1);\r\nspin_lock_init(&(*lsmp)->lsm_lock);\r\n(*lsmp)->lsm_magic = magic;\r\n(*lsmp)->lsm_stripe_count = stripe_count;\r\n(*lsmp)->lsm_maxbytes = LUSTRE_STRIPE_MAXBYTES * stripe_count;\r\n(*lsmp)->lsm_pattern = pattern;\r\n(*lsmp)->lsm_pool_name[0] = '\0';\r\n(*lsmp)->lsm_layout_gen = 0;\r\nif (stripe_count > 0)\r\n(*lsmp)->lsm_oinfo[0]->loi_ost_idx = ~0;\r\nfor (i = 0; i < stripe_count; i++)\r\nloi_init((*lsmp)->lsm_oinfo[i]);\r\nreturn lsm_size;\r\n}\r\nint lov_free_memmd(struct lov_stripe_md **lsmp)\r\n{\r\nstruct lov_stripe_md *lsm = *lsmp;\r\nint refc;\r\n*lsmp = NULL;\r\nLASSERT(atomic_read(&lsm->lsm_refc) > 0);\r\nrefc = atomic_dec_return(&lsm->lsm_refc);\r\nif (refc == 0) {\r\nLASSERT(lsm_op_find(lsm->lsm_magic) != NULL);\r\nlsm_op_find(lsm->lsm_magic)->lsm_free(lsm);\r\n}\r\nreturn refc;\r\n}\r\nint lov_unpackmd(struct obd_export *exp, struct lov_stripe_md **lsmp,\r\nstruct lov_mds_md *lmm, int lmm_bytes)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint rc = 0, lsm_size;\r\n__u16 stripe_count;\r\n__u32 magic;\r\n__u32 pattern;\r\nif (lmm) {\r\nrc = lov_verify_lmm(lmm, lmm_bytes, &stripe_count);\r\nif (rc)\r\nreturn rc;\r\nmagic = le32_to_cpu(lmm->lmm_magic);\r\npattern = le32_to_cpu(lmm->lmm_pattern);\r\n} else {\r\nmagic = LOV_MAGIC;\r\nstripe_count = lov_get_stripecnt(lov, magic, 0);\r\npattern = LOV_PATTERN_RAID0;\r\n}\r\nif (!lsmp) {\r\nLBUG();\r\nreturn lov_stripe_md_size(stripe_count);\r\n}\r\nif (*lsmp && !lmm) {\r\nlov_free_memmd(lsmp);\r\nreturn 0;\r\n}\r\nlsm_size = lov_alloc_memmd(lsmp, stripe_count, pattern, magic);\r\nif (lsm_size < 0)\r\nreturn lsm_size;\r\nif (!lmm)\r\nreturn lsm_size;\r\nLASSERT(lsm_op_find(magic) != NULL);\r\nrc = lsm_op_find(magic)->lsm_unpackmd(lov, *lsmp, lmm);\r\nif (rc) {\r\nlov_free_memmd(lsmp);\r\nreturn rc;\r\n}\r\nreturn lsm_size;\r\n}\r\nint lov_getstripe(struct obd_export *exp, struct lov_stripe_md *lsm,\r\nstruct lov_user_md *lump)\r\n{\r\nstruct lov_user_md_v3 lum;\r\nstruct lov_mds_md *lmmk = NULL;\r\nint rc, lmm_size;\r\nint lum_size;\r\nmm_segment_t seg;\r\nif (!lsm)\r\nreturn -ENODATA;\r\nseg = get_fs();\r\nset_fs(KERNEL_DS);\r\nlum_size = sizeof(struct lov_user_md_v1);\r\nif (copy_from_user(&lum, lump, lum_size)) {\r\nrc = -EFAULT;\r\ngoto out_set;\r\n} else if ((lum.lmm_magic != LOV_USER_MAGIC) &&\r\n(lum.lmm_magic != LOV_USER_MAGIC_V3)) {\r\nrc = -EINVAL;\r\ngoto out_set;\r\n}\r\nif (lum.lmm_stripe_count &&\r\n(lum.lmm_stripe_count < lsm->lsm_stripe_count)) {\r\nlum.lmm_stripe_count = lsm->lsm_stripe_count;\r\nrc = copy_to_user(lump, &lum, lum_size);\r\nrc = -EOVERFLOW;\r\ngoto out_set;\r\n}\r\nrc = lov_packmd(exp, &lmmk, lsm);\r\nif (rc < 0)\r\ngoto out_set;\r\nlmm_size = rc;\r\nrc = 0;\r\nCLASSERT(sizeof(lum) == sizeof(struct lov_mds_md_v3));\r\nCLASSERT(sizeof(lum.lmm_objects[0]) == sizeof(lmmk->lmm_objects[0]));\r\nif ((cpu_to_le32(LOV_MAGIC) != LOV_MAGIC) &&\r\n((lmmk->lmm_magic == cpu_to_le32(LOV_MAGIC_V1)) ||\r\n(lmmk->lmm_magic == cpu_to_le32(LOV_MAGIC_V3)))) {\r\nlustre_swab_lov_mds_md(lmmk);\r\nlustre_swab_lov_user_md_objects(\r\n(struct lov_user_ost_data *)lmmk->lmm_objects,\r\nlmmk->lmm_stripe_count);\r\n}\r\nif (lum.lmm_magic == LOV_USER_MAGIC) {\r\nif (lmmk->lmm_magic == LOV_MAGIC_V3) {\r\nmemmove((char *)(&lmmk->lmm_stripe_count) +\r\nsizeof(lmmk->lmm_stripe_count),\r\n((struct lov_mds_md_v3 *)lmmk)->lmm_objects,\r\nlmmk->lmm_stripe_count *\r\nsizeof(struct lov_ost_data_v1));\r\nlmm_size -= LOV_MAXPOOLNAME;\r\n}\r\n} else {\r\nlum_size = sizeof(struct lov_user_md_v3);\r\n}\r\nif (lum.lmm_stripe_count == 0)\r\nlmm_size = lum_size;\r\nelse if (lum.lmm_stripe_count < lmmk->lmm_stripe_count) {\r\nrc = -EOVERFLOW;\r\ngoto out_set;\r\n}\r\nlum.lmm_stripe_count = lmmk->lmm_stripe_count;\r\nlum.lmm_layout_gen = lmmk->lmm_layout_gen;\r\n((struct lov_user_md *)lmmk)->lmm_layout_gen = lum.lmm_layout_gen;\r\n((struct lov_user_md *)lmmk)->lmm_stripe_count = lum.lmm_stripe_count;\r\nif (copy_to_user(lump, lmmk, lmm_size))\r\nrc = -EFAULT;\r\nobd_free_diskmd(exp, &lmmk);\r\nout_set:\r\nset_fs(seg);\r\nreturn rc;\r\n}
