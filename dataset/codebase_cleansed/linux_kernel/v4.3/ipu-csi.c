static inline u32 ipu_csi_read(struct ipu_csi *csi, unsigned offset)\r\n{\r\nreturn readl(csi->base + offset);\r\n}\r\nstatic inline void ipu_csi_write(struct ipu_csi *csi, u32 value,\r\nunsigned offset)\r\n{\r\nwritel(value, csi->base + offset);\r\n}\r\nstatic int ipu_csi_set_testgen_mclk(struct ipu_csi *csi, u32 pixel_clk,\r\nu32 ipu_clk)\r\n{\r\nu32 temp;\r\nu32 div_ratio;\r\ndiv_ratio = (ipu_clk / pixel_clk) - 1;\r\nif (div_ratio > 0xFF || div_ratio < 0) {\r\ndev_err(csi->ipu->dev,\r\n"value of pixel_clk extends normal range\n");\r\nreturn -EINVAL;\r\n}\r\ntemp = ipu_csi_read(csi, CSI_SENS_CONF);\r\ntemp &= ~CSI_SENS_CONF_DIVRATIO_MASK;\r\nipu_csi_write(csi, temp | (div_ratio << CSI_SENS_CONF_DIVRATIO_SHIFT),\r\nCSI_SENS_CONF);\r\nreturn 0;\r\n}\r\nstatic int mbus_code_to_bus_cfg(struct ipu_csi_bus_config *cfg, u32 mbus_code)\r\n{\r\nswitch (mbus_code) {\r\ncase MEDIA_BUS_FMT_BGR565_2X8_BE:\r\ncase MEDIA_BUS_FMT_BGR565_2X8_LE:\r\ncase MEDIA_BUS_FMT_RGB565_2X8_BE:\r\ncase MEDIA_BUS_FMT_RGB565_2X8_LE:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB565;\r\ncfg->mipi_dt = MIPI_DT_RGB565;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB444_2X8_PADHI_BE:\r\ncase MEDIA_BUS_FMT_RGB444_2X8_PADHI_LE:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB444;\r\ncfg->mipi_dt = MIPI_DT_RGB444;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_BE:\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_RGB555;\r\ncfg->mipi_dt = MIPI_DT_RGB555;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;\r\ncfg->mipi_dt = MIPI_DT_YUV422;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;\r\ncfg->mipi_dt = MIPI_DT_YUV422;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_UYVY;\r\ncfg->mipi_dt = MIPI_DT_YUV422;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_16;\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_YUV422_YUYV;\r\ncfg->mipi_dt = MIPI_DT_YUV422;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_16;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\ncase MEDIA_BUS_FMT_SGBRG8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG8_1X8:\r\ncase MEDIA_BUS_FMT_SRGGB8_1X8:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\r\ncfg->mipi_dt = MIPI_DT_RAW8;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SGBRG10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SRGGB10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_BE:\r\ncase MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE:\r\ncase MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_BE:\r\ncase MEDIA_BUS_FMT_SBGGR10_2X8_PADLO_LE:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\r\ncfg->mipi_dt = MIPI_DT_RAW10;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR10_1X10:\r\ncase MEDIA_BUS_FMT_SGBRG10_1X10:\r\ncase MEDIA_BUS_FMT_SGRBG10_1X10:\r\ncase MEDIA_BUS_FMT_SRGGB10_1X10:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\r\ncfg->mipi_dt = MIPI_DT_RAW10;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_10;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR12_1X12:\r\ncase MEDIA_BUS_FMT_SGBRG12_1X12:\r\ncase MEDIA_BUS_FMT_SGRBG12_1X12:\r\ncase MEDIA_BUS_FMT_SRGGB12_1X12:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_BAYER;\r\ncfg->mipi_dt = MIPI_DT_RAW12;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_12;\r\nbreak;\r\ncase MEDIA_BUS_FMT_JPEG_1X8:\r\ncfg->data_fmt = CSI_SENS_CONF_DATA_FMT_JPEG;\r\ncfg->mipi_dt = MIPI_DT_RAW8;\r\ncfg->data_width = IPU_CSI_DATA_WIDTH_8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fill_csi_bus_cfg(struct ipu_csi_bus_config *csicfg,\r\nstruct v4l2_mbus_config *mbus_cfg,\r\nstruct v4l2_mbus_framefmt *mbus_fmt)\r\n{\r\nmemset(csicfg, 0, sizeof(*csicfg));\r\nmbus_code_to_bus_cfg(csicfg, mbus_fmt->code);\r\nswitch (mbus_cfg->type) {\r\ncase V4L2_MBUS_PARALLEL:\r\ncsicfg->ext_vsync = 1;\r\ncsicfg->vsync_pol = (mbus_cfg->flags &\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW) ? 1 : 0;\r\ncsicfg->hsync_pol = (mbus_cfg->flags &\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW) ? 1 : 0;\r\ncsicfg->pixclk_pol = (mbus_cfg->flags &\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING) ? 1 : 0;\r\ncsicfg->clk_mode = IPU_CSI_CLK_MODE_GATED_CLK;\r\nbreak;\r\ncase V4L2_MBUS_BT656:\r\ncsicfg->ext_vsync = 0;\r\nif (V4L2_FIELD_HAS_BOTH(mbus_fmt->field))\r\ncsicfg->clk_mode = IPU_CSI_CLK_MODE_CCIR656_INTERLACED;\r\nelse\r\ncsicfg->clk_mode = IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE;\r\nbreak;\r\ncase V4L2_MBUS_CSI2:\r\ncsicfg->clk_mode = IPU_CSI_CLK_MODE_NONGATED_CLK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint ipu_csi_init_interface(struct ipu_csi *csi,\r\nstruct v4l2_mbus_config *mbus_cfg,\r\nstruct v4l2_mbus_framefmt *mbus_fmt)\r\n{\r\nstruct ipu_csi_bus_config cfg;\r\nunsigned long flags;\r\nu32 data = 0;\r\nfill_csi_bus_cfg(&cfg, mbus_cfg, mbus_fmt);\r\ndata |= cfg.data_width << CSI_SENS_CONF_DATA_WIDTH_SHIFT |\r\ncfg.data_fmt << CSI_SENS_CONF_DATA_FMT_SHIFT |\r\ncfg.data_pol << CSI_SENS_CONF_DATA_POL_SHIFT |\r\ncfg.vsync_pol << CSI_SENS_CONF_VSYNC_POL_SHIFT |\r\ncfg.hsync_pol << CSI_SENS_CONF_HSYNC_POL_SHIFT |\r\ncfg.pixclk_pol << CSI_SENS_CONF_PIX_CLK_POL_SHIFT |\r\ncfg.ext_vsync << CSI_SENS_CONF_EXT_VSYNC_SHIFT |\r\ncfg.clk_mode << CSI_SENS_CONF_SENS_PRTCL_SHIFT |\r\ncfg.pack_tight << CSI_SENS_CONF_PACK_TIGHT_SHIFT |\r\ncfg.force_eof << CSI_SENS_CONF_FORCE_EOF_SHIFT |\r\ncfg.data_en_pol << CSI_SENS_CONF_DATA_EN_POL_SHIFT;\r\nspin_lock_irqsave(&csi->lock, flags);\r\nipu_csi_write(csi, data, CSI_SENS_CONF);\r\nipu_csi_write(csi,\r\n(mbus_fmt->width - 1) | ((mbus_fmt->height - 1) << 16),\r\nCSI_SENS_FRM_SIZE);\r\nswitch (cfg.clk_mode) {\r\ncase IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:\r\nipu_csi_write(csi, 0x40030, CSI_CCIR_CODE_1);\r\nipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\r\nbreak;\r\ncase IPU_CSI_CLK_MODE_CCIR656_INTERLACED:\r\nif (mbus_fmt->width == 720 && mbus_fmt->height == 576) {\r\nipu_csi_write(csi, 0x40596 | CSI_CCIR_ERR_DET_EN,\r\nCSI_CCIR_CODE_1);\r\nipu_csi_write(csi, 0xD07DF, CSI_CCIR_CODE_2);\r\nipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\r\n} else if (mbus_fmt->width == 720 && mbus_fmt->height == 480) {\r\nipu_csi_write(csi, 0xD07DF | CSI_CCIR_ERR_DET_EN,\r\nCSI_CCIR_CODE_1);\r\nipu_csi_write(csi, 0x40596, CSI_CCIR_CODE_2);\r\nipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\r\n} else {\r\ndev_err(csi->ipu->dev,\r\n"Unsupported CCIR656 interlaced video mode\n");\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:\r\nipu_csi_write(csi, 0x40030 | CSI_CCIR_ERR_DET_EN,\r\nCSI_CCIR_CODE_1);\r\nipu_csi_write(csi, 0xFF0000, CSI_CCIR_CODE_3);\r\nbreak;\r\ncase IPU_CSI_CLK_MODE_GATED_CLK:\r\ncase IPU_CSI_CLK_MODE_NONGATED_CLK:\r\nipu_csi_write(csi, 0, CSI_CCIR_CODE_1);\r\nbreak;\r\n}\r\ndev_dbg(csi->ipu->dev, "CSI_SENS_CONF = 0x%08X\n",\r\nipu_csi_read(csi, CSI_SENS_CONF));\r\ndev_dbg(csi->ipu->dev, "CSI_ACT_FRM_SIZE = 0x%08X\n",\r\nipu_csi_read(csi, CSI_ACT_FRM_SIZE));\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nreturn 0;\r\n}\r\nbool ipu_csi_is_interlaced(struct ipu_csi *csi)\r\n{\r\nunsigned long flags;\r\nu32 sensor_protocol;\r\nspin_lock_irqsave(&csi->lock, flags);\r\nsensor_protocol =\r\n(ipu_csi_read(csi, CSI_SENS_CONF) &\r\nCSI_SENS_CONF_SENS_PRTCL_MASK) >>\r\nCSI_SENS_CONF_SENS_PRTCL_SHIFT;\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nswitch (sensor_protocol) {\r\ncase IPU_CSI_CLK_MODE_GATED_CLK:\r\ncase IPU_CSI_CLK_MODE_NONGATED_CLK:\r\ncase IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR:\r\nreturn false;\r\ncase IPU_CSI_CLK_MODE_CCIR656_INTERLACED:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR:\r\ncase IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR:\r\nreturn true;\r\ndefault:\r\ndev_err(csi->ipu->dev,\r\n"CSI %d sensor protocol unsupported\n", csi->id);\r\nreturn false;\r\n}\r\n}\r\nvoid ipu_csi_get_window(struct ipu_csi *csi, struct v4l2_rect *w)\r\n{\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&csi->lock, flags);\r\nreg = ipu_csi_read(csi, CSI_ACT_FRM_SIZE);\r\nw->width = (reg & 0xFFFF) + 1;\r\nw->height = (reg >> 16 & 0xFFFF) + 1;\r\nreg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);\r\nw->left = (reg & CSI_HSC_MASK) >> CSI_HSC_SHIFT;\r\nw->top = (reg & CSI_VSC_MASK) >> CSI_VSC_SHIFT;\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\n}\r\nvoid ipu_csi_set_window(struct ipu_csi *csi, struct v4l2_rect *w)\r\n{\r\nunsigned long flags;\r\nu32 reg;\r\nspin_lock_irqsave(&csi->lock, flags);\r\nipu_csi_write(csi, (w->width - 1) | ((w->height - 1) << 16),\r\nCSI_ACT_FRM_SIZE);\r\nreg = ipu_csi_read(csi, CSI_OUT_FRM_CTRL);\r\nreg &= ~(CSI_HSC_MASK | CSI_VSC_MASK);\r\nreg |= ((w->top << CSI_VSC_SHIFT) | (w->left << CSI_HSC_SHIFT));\r\nipu_csi_write(csi, reg, CSI_OUT_FRM_CTRL);\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\n}\r\nvoid ipu_csi_set_test_generator(struct ipu_csi *csi, bool active,\r\nu32 r_value, u32 g_value, u32 b_value,\r\nu32 pix_clk)\r\n{\r\nunsigned long flags;\r\nu32 ipu_clk = clk_get_rate(csi->clk_ipu);\r\nu32 temp;\r\nspin_lock_irqsave(&csi->lock, flags);\r\ntemp = ipu_csi_read(csi, CSI_TST_CTRL);\r\nif (active == false) {\r\ntemp &= ~CSI_TEST_GEN_MODE_EN;\r\nipu_csi_write(csi, temp, CSI_TST_CTRL);\r\n} else {\r\nipu_csi_set_testgen_mclk(csi, pix_clk, ipu_clk);\r\ntemp &= ~(CSI_TEST_GEN_R_MASK | CSI_TEST_GEN_G_MASK |\r\nCSI_TEST_GEN_B_MASK);\r\ntemp |= CSI_TEST_GEN_MODE_EN;\r\ntemp |= (r_value << CSI_TEST_GEN_R_SHIFT) |\r\n(g_value << CSI_TEST_GEN_G_SHIFT) |\r\n(b_value << CSI_TEST_GEN_B_SHIFT);\r\nipu_csi_write(csi, temp, CSI_TST_CTRL);\r\n}\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\n}\r\nint ipu_csi_set_mipi_datatype(struct ipu_csi *csi, u32 vc,\r\nstruct v4l2_mbus_framefmt *mbus_fmt)\r\n{\r\nstruct ipu_csi_bus_config cfg;\r\nunsigned long flags;\r\nu32 temp;\r\nif (vc > 3)\r\nreturn -EINVAL;\r\nmbus_code_to_bus_cfg(&cfg, mbus_fmt->code);\r\nspin_lock_irqsave(&csi->lock, flags);\r\ntemp = ipu_csi_read(csi, CSI_MIPI_DI);\r\ntemp &= ~(0xff << (vc * 8));\r\ntemp |= (cfg.mipi_dt << (vc * 8));\r\nipu_csi_write(csi, temp, CSI_MIPI_DI);\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_csi_set_skip_smfc(struct ipu_csi *csi, u32 skip,\r\nu32 max_ratio, u32 id)\r\n{\r\nunsigned long flags;\r\nu32 temp;\r\nif (max_ratio > 5 || id > 3)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&csi->lock, flags);\r\ntemp = ipu_csi_read(csi, CSI_SKIP);\r\ntemp &= ~(CSI_MAX_RATIO_SKIP_SMFC_MASK | CSI_ID_2_SKIP_MASK |\r\nCSI_SKIP_SMFC_MASK);\r\ntemp |= (max_ratio << CSI_MAX_RATIO_SKIP_SMFC_SHIFT) |\r\n(id << CSI_ID_2_SKIP_SHIFT) |\r\n(skip << CSI_SKIP_SMFC_SHIFT);\r\nipu_csi_write(csi, temp, CSI_SKIP);\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_csi_set_dest(struct ipu_csi *csi, enum ipu_csi_dest csi_dest)\r\n{\r\nunsigned long flags;\r\nu32 csi_sens_conf, dest;\r\nif (csi_dest == IPU_CSI_DEST_IDMAC)\r\ndest = CSI_DATA_DEST_IDMAC;\r\nelse\r\ndest = CSI_DATA_DEST_IC;\r\nspin_lock_irqsave(&csi->lock, flags);\r\ncsi_sens_conf = ipu_csi_read(csi, CSI_SENS_CONF);\r\ncsi_sens_conf &= ~CSI_SENS_CONF_DATA_DEST_MASK;\r\ncsi_sens_conf |= (dest << CSI_SENS_CONF_DATA_DEST_SHIFT);\r\nipu_csi_write(csi, csi_sens_conf, CSI_SENS_CONF);\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nreturn 0;\r\n}\r\nint ipu_csi_enable(struct ipu_csi *csi)\r\n{\r\nipu_module_enable(csi->ipu, csi->module);\r\nreturn 0;\r\n}\r\nint ipu_csi_disable(struct ipu_csi *csi)\r\n{\r\nipu_module_disable(csi->ipu, csi->module);\r\nreturn 0;\r\n}\r\nstruct ipu_csi *ipu_csi_get(struct ipu_soc *ipu, int id)\r\n{\r\nunsigned long flags;\r\nstruct ipu_csi *csi, *ret;\r\nif (id > 1)\r\nreturn ERR_PTR(-EINVAL);\r\ncsi = ipu->csi_priv[id];\r\nret = csi;\r\nspin_lock_irqsave(&csi->lock, flags);\r\nif (csi->inuse) {\r\nret = ERR_PTR(-EBUSY);\r\ngoto unlock;\r\n}\r\ncsi->inuse = true;\r\nunlock:\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\nreturn ret;\r\n}\r\nvoid ipu_csi_put(struct ipu_csi *csi)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&csi->lock, flags);\r\ncsi->inuse = false;\r\nspin_unlock_irqrestore(&csi->lock, flags);\r\n}\r\nint ipu_csi_init(struct ipu_soc *ipu, struct device *dev, int id,\r\nunsigned long base, u32 module, struct clk *clk_ipu)\r\n{\r\nstruct ipu_csi *csi;\r\nif (id > 1)\r\nreturn -ENODEV;\r\ncsi = devm_kzalloc(dev, sizeof(*csi), GFP_KERNEL);\r\nif (!csi)\r\nreturn -ENOMEM;\r\nipu->csi_priv[id] = csi;\r\nspin_lock_init(&csi->lock);\r\ncsi->module = module;\r\ncsi->id = id;\r\ncsi->clk_ipu = clk_ipu;\r\ncsi->base = devm_ioremap(dev, base, PAGE_SIZE);\r\nif (!csi->base)\r\nreturn -ENOMEM;\r\ndev_dbg(dev, "CSI%d base: 0x%08lx remapped to %p\n",\r\nid, base, csi->base);\r\ncsi->ipu = ipu;\r\nreturn 0;\r\n}\r\nvoid ipu_csi_exit(struct ipu_soc *ipu, int id)\r\n{\r\n}\r\nvoid ipu_csi_dump(struct ipu_csi *csi)\r\n{\r\ndev_dbg(csi->ipu->dev, "CSI_SENS_CONF: %08x\n",\r\nipu_csi_read(csi, CSI_SENS_CONF));\r\ndev_dbg(csi->ipu->dev, "CSI_SENS_FRM_SIZE: %08x\n",\r\nipu_csi_read(csi, CSI_SENS_FRM_SIZE));\r\ndev_dbg(csi->ipu->dev, "CSI_ACT_FRM_SIZE: %08x\n",\r\nipu_csi_read(csi, CSI_ACT_FRM_SIZE));\r\ndev_dbg(csi->ipu->dev, "CSI_OUT_FRM_CTRL: %08x\n",\r\nipu_csi_read(csi, CSI_OUT_FRM_CTRL));\r\ndev_dbg(csi->ipu->dev, "CSI_TST_CTRL: %08x\n",\r\nipu_csi_read(csi, CSI_TST_CTRL));\r\ndev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_1: %08x\n",\r\nipu_csi_read(csi, CSI_CCIR_CODE_1));\r\ndev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_2: %08x\n",\r\nipu_csi_read(csi, CSI_CCIR_CODE_2));\r\ndev_dbg(csi->ipu->dev, "CSI_CCIR_CODE_3: %08x\n",\r\nipu_csi_read(csi, CSI_CCIR_CODE_3));\r\ndev_dbg(csi->ipu->dev, "CSI_MIPI_DI: %08x\n",\r\nipu_csi_read(csi, CSI_MIPI_DI));\r\ndev_dbg(csi->ipu->dev, "CSI_SKIP: %08x\n",\r\nipu_csi_read(csi, CSI_SKIP));\r\n}
