static int get_cpu_physical_id(int cpu)\r\n{\r\nreturn topology_core_id(cpu);\r\n}\r\nstatic int get_cpu_physical_id(int cpu)\r\n{\r\nreturn get_hard_smp_processor_id(cpu);\r\n}\r\nstatic u32 get_bus_freq(void)\r\n{\r\nstruct device_node *soc;\r\nu32 sysfreq;\r\nsoc = of_find_node_by_type(NULL, "soc");\r\nif (!soc)\r\nreturn 0;\r\nif (of_property_read_u32(soc, "bus-frequency", &sysfreq))\r\nsysfreq = 0;\r\nof_node_put(soc);\r\nreturn sysfreq;\r\n}\r\nstatic struct device_node *cpu_to_clk_node(int cpu)\r\n{\r\nstruct device_node *np, *clk_np;\r\nif (!cpu_present(cpu))\r\nreturn NULL;\r\nnp = of_get_cpu_node(cpu, NULL);\r\nif (!np)\r\nreturn NULL;\r\nclk_np = of_parse_phandle(np, "clocks", 0);\r\nif (!clk_np)\r\nreturn NULL;\r\nof_node_put(np);\r\nreturn clk_np;\r\n}\r\nstatic void set_affected_cpus(struct cpufreq_policy *policy)\r\n{\r\nstruct device_node *np, *clk_np;\r\nstruct cpumask *dstp = policy->cpus;\r\nint i;\r\nnp = cpu_to_clk_node(policy->cpu);\r\nif (!np)\r\nreturn;\r\nfor_each_present_cpu(i) {\r\nclk_np = cpu_to_clk_node(i);\r\nif (!clk_np)\r\ncontinue;\r\nif (clk_np == np)\r\ncpumask_set_cpu(i, dstp);\r\nof_node_put(clk_np);\r\n}\r\nof_node_put(np);\r\n}\r\nstatic void freq_table_redup(struct cpufreq_frequency_table *freq_table,\r\nint count)\r\n{\r\nint i, j;\r\nfor (i = 1; i < count; i++) {\r\nfor (j = 0; j < i; j++) {\r\nif (freq_table[j].frequency == CPUFREQ_ENTRY_INVALID ||\r\nfreq_table[j].frequency !=\r\nfreq_table[i].frequency)\r\ncontinue;\r\nfreq_table[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void freq_table_sort(struct cpufreq_frequency_table *freq_table,\r\nint count)\r\n{\r\nint i, j, ind;\r\nunsigned int freq, max_freq;\r\nstruct cpufreq_frequency_table table;\r\nfor (i = 0; i < count - 1; i++) {\r\nmax_freq = freq_table[i].frequency;\r\nind = i;\r\nfor (j = i + 1; j < count; j++) {\r\nfreq = freq_table[j].frequency;\r\nif (freq == CPUFREQ_ENTRY_INVALID ||\r\nfreq <= max_freq)\r\ncontinue;\r\nind = j;\r\nmax_freq = freq;\r\n}\r\nif (ind != i) {\r\ntable.driver_data = freq_table[i].driver_data;\r\ntable.frequency = freq_table[i].frequency;\r\nfreq_table[i].driver_data = freq_table[ind].driver_data;\r\nfreq_table[i].frequency = freq_table[ind].frequency;\r\nfreq_table[ind].driver_data = table.driver_data;\r\nfreq_table[ind].frequency = table.frequency;\r\n}\r\n}\r\n}\r\nstatic int qoriq_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct device_node *np, *pnode;\r\nint i, count, ret;\r\nu32 freq, mask;\r\nstruct clk *clk;\r\nstruct cpufreq_frequency_table *table;\r\nstruct cpu_data *data;\r\nunsigned int cpu = policy->cpu;\r\nu64 u64temp;\r\nnp = of_get_cpu_node(cpu, NULL);\r\nif (!np)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\ngoto err_np;\r\npolicy->clk = of_clk_get(np, 0);\r\nif (IS_ERR(policy->clk)) {\r\npr_err("%s: no clock information\n", __func__);\r\ngoto err_nomem2;\r\n}\r\npnode = of_parse_phandle(np, "clocks", 0);\r\nif (!pnode) {\r\npr_err("%s: could not get clock information\n", __func__);\r\ngoto err_nomem2;\r\n}\r\ncount = of_property_count_strings(pnode, "clock-names");\r\ndata->pclk = kcalloc(count, sizeof(struct clk *), GFP_KERNEL);\r\nif (!data->pclk) {\r\npr_err("%s: no memory\n", __func__);\r\ngoto err_node;\r\n}\r\ntable = kcalloc(count + 1, sizeof(*table), GFP_KERNEL);\r\nif (!table) {\r\npr_err("%s: no memory\n", __func__);\r\ngoto err_pclk;\r\n}\r\nif (fmask)\r\nmask = fmask[get_cpu_physical_id(cpu)];\r\nelse\r\nmask = 0x0;\r\nfor (i = 0; i < count; i++) {\r\nclk = of_clk_get(pnode, i);\r\ndata->pclk[i] = clk;\r\nfreq = clk_get_rate(clk);\r\nif (freq < min_cpufreq || (mask & (1 << i)))\r\ntable[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\ntable[i].frequency = freq / 1000;\r\ntable[i].driver_data = i;\r\n}\r\nfreq_table_redup(table, count);\r\nfreq_table_sort(table, count);\r\ntable[i].frequency = CPUFREQ_TABLE_END;\r\nret = cpufreq_table_validate_and_show(policy, table);\r\nif (ret) {\r\npr_err("invalid frequency table: %d\n", ret);\r\ngoto err_nomem1;\r\n}\r\ndata->table = table;\r\nset_affected_cpus(policy);\r\npolicy->driver_data = data;\r\nu64temp = 12ULL * NSEC_PER_SEC;\r\ndo_div(u64temp, get_bus_freq());\r\npolicy->cpuinfo.transition_latency = u64temp + 1;\r\nof_node_put(np);\r\nof_node_put(pnode);\r\nreturn 0;\r\nerr_nomem1:\r\nkfree(table);\r\nerr_pclk:\r\nkfree(data->pclk);\r\nerr_node:\r\nof_node_put(pnode);\r\nerr_nomem2:\r\npolicy->driver_data = NULL;\r\nkfree(data);\r\nerr_np:\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nstatic int __exit qoriq_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct cpu_data *data = policy->driver_data;\r\nkfree(data->pclk);\r\nkfree(data->table);\r\nkfree(data);\r\npolicy->driver_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int qoriq_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct clk *parent;\r\nstruct cpu_data *data = policy->driver_data;\r\nparent = data->pclk[data->table[index].driver_data];\r\nreturn clk_set_parent(policy->clk, parent);\r\n}\r\nstatic int __init qoriq_cpufreq_init(void)\r\n{\r\nint ret;\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nconst struct soc_data *data;\r\nnp = of_find_matching_node(NULL, node_matches);\r\nif (!np)\r\nreturn -ENODEV;\r\nmatch = of_match_node(node_matches, np);\r\ndata = match->data;\r\nif (data) {\r\nif (data->flag)\r\nfmask = data->freq_mask;\r\nmin_cpufreq = get_bus_freq();\r\n} else {\r\nmin_cpufreq = get_bus_freq() / 2;\r\n}\r\nof_node_put(np);\r\nret = cpufreq_register_driver(&qoriq_cpufreq_driver);\r\nif (!ret)\r\npr_info("Freescale QorIQ CPU frequency scaling driver\n");\r\nreturn ret;\r\n}\r\nstatic void __exit qoriq_cpufreq_exit(void)\r\n{\r\ncpufreq_unregister_driver(&qoriq_cpufreq_driver);\r\n}
