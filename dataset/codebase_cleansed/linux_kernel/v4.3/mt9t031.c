static struct mt9t031 *to_mt9t031(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct mt9t031, subdev);\r\n}\r\nstatic int reg_read(struct i2c_client *client, const u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic int reg_set(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, ret | data);\r\n}\r\nstatic int reg_clear(struct i2c_client *client, const u8 reg,\r\nconst u16 data)\r\n{\r\nint ret;\r\nret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, ret & ~data);\r\n}\r\nstatic int set_shutter(struct i2c_client *client, const u32 data)\r\n{\r\nint ret;\r\nret = reg_write(client, MT9T031_SHUTTER_WIDTH_UPPER, data >> 16);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_SHUTTER_WIDTH, data & 0xffff);\r\nreturn ret;\r\n}\r\nstatic int get_shutter(struct i2c_client *client, u32 *data)\r\n{\r\nint ret;\r\nret = reg_read(client, MT9T031_SHUTTER_WIDTH_UPPER);\r\n*data = ret << 16;\r\nif (ret >= 0)\r\nret = reg_read(client, MT9T031_SHUTTER_WIDTH);\r\n*data |= ret & 0xffff;\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int mt9t031_idle(struct i2c_client *client)\r\n{\r\nint ret;\r\nret = reg_write(client, MT9T031_RESET, 1);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_RESET, 0);\r\nif (ret >= 0)\r\nret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 2);\r\nreturn ret >= 0 ? 0 : -EIO;\r\n}\r\nstatic int mt9t031_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nif (enable)\r\nret = reg_set(client, MT9T031_OUTPUT_CONTROL, 2);\r\nelse\r\nret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 2);\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic u16 mt9t031_skip(s32 *source, s32 target, s32 max)\r\n{\r\nunsigned int skip;\r\nif (*source < target + target / 2) {\r\n*source = target;\r\nreturn 1;\r\n}\r\nskip = min(max, *source + target / 2) / target;\r\nif (skip > 8)\r\nskip = 8;\r\n*source = target * skip;\r\nreturn skip;\r\n}\r\nstatic int mt9t031_set_params(struct i2c_client *client,\r\nstruct v4l2_rect *rect, u16 xskip, u16 yskip)\r\n{\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nint ret;\r\nu16 xbin, ybin;\r\nconst u16 hblank = MT9T031_HORIZONTAL_BLANK,\r\nvblank = MT9T031_VERTICAL_BLANK;\r\nxbin = min(xskip, (u16)3);\r\nybin = min(yskip, (u16)3);\r\nswitch (xbin) {\r\ncase 1:\r\nrect->left &= ~1;\r\nbreak;\r\ncase 2:\r\nrect->left &= ~3;\r\nbreak;\r\ncase 3:\r\nrect->left = rect->left > roundup(MT9T031_COLUMN_SKIP, 6) ?\r\n(rect->left / 6) * 6 : roundup(MT9T031_COLUMN_SKIP, 6);\r\n}\r\nrect->top &= ~1;\r\ndev_dbg(&client->dev, "skip %u:%u, rect %ux%u@%u:%u\n",\r\nxskip, yskip, rect->width, rect->height, rect->left, rect->top);\r\nret = reg_set(client, MT9T031_OUTPUT_CONTROL, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = reg_write(client, MT9T031_HORIZONTAL_BLANKING, hblank);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_VERTICAL_BLANKING, vblank);\r\nif (yskip != mt9t031->yskip || xskip != mt9t031->xskip) {\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_COLUMN_ADDRESS_MODE,\r\n((xbin - 1) << 4) | (xskip - 1));\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_ROW_ADDRESS_MODE,\r\n((ybin - 1) << 4) | (yskip - 1));\r\n}\r\ndev_dbg(&client->dev, "new physical left %u, top %u\n",\r\nrect->left, rect->top);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_COLUMN_START, rect->left);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_ROW_START, rect->top);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_WINDOW_WIDTH, rect->width - 1);\r\nif (ret >= 0)\r\nret = reg_write(client, MT9T031_WINDOW_HEIGHT,\r\nrect->height + mt9t031->y_skip_top - 1);\r\nif (ret >= 0 && v4l2_ctrl_g_ctrl(mt9t031->autoexposure) == V4L2_EXPOSURE_AUTO) {\r\nmt9t031->total_h = rect->height + mt9t031->y_skip_top + vblank;\r\nret = set_shutter(client, mt9t031->total_h);\r\n}\r\nif (ret >= 0)\r\nret = reg_clear(client, MT9T031_OUTPUT_CONTROL, 1);\r\nif (ret >= 0) {\r\nmt9t031->rect = *rect;\r\nmt9t031->xskip = xskip;\r\nmt9t031->yskip = yskip;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int mt9t031_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)\r\n{\r\nstruct v4l2_rect rect = a->c;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nrect.width = ALIGN(rect.width, 2);\r\nrect.height = ALIGN(rect.height, 2);\r\nsoc_camera_limit_side(&rect.left, &rect.width,\r\nMT9T031_COLUMN_SKIP, MT9T031_MIN_WIDTH, MT9T031_MAX_WIDTH);\r\nsoc_camera_limit_side(&rect.top, &rect.height,\r\nMT9T031_ROW_SKIP, MT9T031_MIN_HEIGHT, MT9T031_MAX_HEIGHT);\r\nreturn mt9t031_set_params(client, &rect, mt9t031->xskip, mt9t031->yskip);\r\n}\r\nstatic int mt9t031_g_crop(struct v4l2_subdev *sd, struct v4l2_crop *a)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\na->c = mt9t031->rect;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)\r\n{\r\na->bounds.left = MT9T031_COLUMN_SKIP;\r\na->bounds.top = MT9T031_ROW_SKIP;\r\na->bounds.width = MT9T031_MAX_WIDTH;\r\na->bounds.height = MT9T031_MAX_HEIGHT;\r\na->defrect = a->bounds;\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\na->pixelaspect.numerator = 1;\r\na->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->width = mt9t031->rect.width / mt9t031->xskip;\r\nmf->height = mt9t031->rect.height / mt9t031->yskip;\r\nmf->code = MEDIA_BUS_FMT_SBGGR10_1X10;\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nmf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nu16 xskip, yskip;\r\nstruct v4l2_rect rect = mt9t031->rect;\r\nif (format->pad)\r\nreturn -EINVAL;\r\nmf->code = MEDIA_BUS_FMT_SBGGR10_1X10;\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nv4l_bound_align_image(\r\n&mf->width, MT9T031_MIN_WIDTH, MT9T031_MAX_WIDTH, 1,\r\n&mf->height, MT9T031_MIN_HEIGHT, MT9T031_MAX_HEIGHT, 1, 0);\r\nif (format->which == V4L2_SUBDEV_FORMAT_TRY) {\r\ncfg->try_fmt = *mf;\r\nreturn 0;\r\n}\r\nxskip = mt9t031_skip(&rect.width, mf->width, MT9T031_MAX_WIDTH);\r\nyskip = mt9t031_skip(&rect.height, mf->height, MT9T031_MAX_HEIGHT);\r\nmf->code = MEDIA_BUS_FMT_SBGGR10_1X10;\r\nmf->colorspace = V4L2_COLORSPACE_SRGB;\r\nreturn mt9t031_set_params(client, &rect, xskip, yskip);\r\n}\r\nstatic int mt9t031_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nreg->val = reg_read(client, reg->reg);\r\nif (reg->val > 0xffff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nif (reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9t031 *mt9t031 = container_of(ctrl->handler,\r\nstruct mt9t031, hdl);\r\nconst u32 shutter_max = MT9T031_MAX_HEIGHT + MT9T031_VERTICAL_BLANK;\r\ns32 min, max;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nmin = mt9t031->exposure->minimum;\r\nmax = mt9t031->exposure->maximum;\r\nmt9t031->exposure->val =\r\n(shutter_max / 2 + (mt9t031->total_h - 1) * (max - min))\r\n/ shutter_max + min;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9t031_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9t031 *mt9t031 = container_of(ctrl->handler,\r\nstruct mt9t031, hdl);\r\nstruct v4l2_subdev *sd = &mt9t031->subdev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct v4l2_ctrl *exp = mt9t031->exposure;\r\nint data;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, MT9T031_READ_MODE_2, 0x8000);\r\nelse\r\ndata = reg_clear(client, MT9T031_READ_MODE_2, 0x8000);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_HFLIP:\r\nif (ctrl->val)\r\ndata = reg_set(client, MT9T031_READ_MODE_2, 0x4000);\r\nelse\r\ndata = reg_clear(client, MT9T031_READ_MODE_2, 0x4000);\r\nif (data < 0)\r\nreturn -EIO;\r\nreturn 0;\r\ncase V4L2_CID_GAIN:\r\nif (ctrl->val <= ctrl->default_value) {\r\nunsigned long range = ctrl->default_value - ctrl->minimum;\r\ndata = ((ctrl->val - (s32)ctrl->minimum) * 8 + range / 2) / range;\r\ndev_dbg(&client->dev, "Setting gain %d\n", data);\r\ndata = reg_write(client, MT9T031_GLOBAL_GAIN, data);\r\nif (data < 0)\r\nreturn -EIO;\r\n} else {\r\nunsigned long range = ctrl->maximum - ctrl->default_value - 1;\r\nunsigned long gain = ((ctrl->val - (s32)ctrl->default_value - 1) *\r\n1015 + range / 2) / range + 9;\r\nif (gain <= 32)\r\ndata = gain;\r\nelse if (gain <= 64)\r\ndata = ((gain - 32) * 16 + 16) / 32 + 80;\r\nelse\r\ndata = (((gain - 64 + 7) * 32) & 0xff00) | 0x60;\r\ndev_dbg(&client->dev, "Set gain from 0x%x to 0x%x\n",\r\nreg_read(client, MT9T031_GLOBAL_GAIN), data);\r\ndata = reg_write(client, MT9T031_GLOBAL_GAIN, data);\r\nif (data < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nif (ctrl->val == V4L2_EXPOSURE_MANUAL) {\r\nunsigned int range = exp->maximum - exp->minimum;\r\nunsigned int shutter = ((exp->val - (s32)exp->minimum) * 1048 +\r\nrange / 2) / range + 1;\r\nu32 old;\r\nget_shutter(client, &old);\r\ndev_dbg(&client->dev, "Set shutter from %u to %u\n",\r\nold, shutter);\r\nif (set_shutter(client, shutter) < 0)\r\nreturn -EIO;\r\n} else {\r\nconst u16 vblank = MT9T031_VERTICAL_BLANK;\r\nmt9t031->total_h = mt9t031->rect.height +\r\nmt9t031->y_skip_top + vblank;\r\nif (set_shutter(client, mt9t031->total_h) < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9t031_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mt9t031_runtime_resume(struct device *dev)\r\n{\r\nstruct video_device *vdev = to_video_device(dev);\r\nstruct v4l2_subdev *sd = soc_camera_vdev_to_subdev(vdev);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nint ret;\r\nu16 xbin, ybin;\r\nxbin = min(mt9t031->xskip, (u16)3);\r\nybin = min(mt9t031->yskip, (u16)3);\r\nret = reg_write(client, MT9T031_COLUMN_ADDRESS_MODE,\r\n((xbin - 1) << 4) | (mt9t031->xskip - 1));\r\nif (ret < 0)\r\nreturn ret;\r\nret = reg_write(client, MT9T031_ROW_ADDRESS_MODE,\r\n((ybin - 1) << 4) | (mt9t031->yskip - 1));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct video_device *vdev = soc_camera_i2c_to_vdev(client);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nint ret;\r\nif (on) {\r\nret = soc_camera_power_on(&client->dev, ssdd, mt9t031->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nif (vdev)\r\nvdev->dev.type = &mt9t031_dev_type;\r\n} else {\r\nif (vdev)\r\nvdev->dev.type = NULL;\r\nsoc_camera_power_off(&client->dev, ssdd, mt9t031->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9t031_video_probe(struct i2c_client *client)\r\n{\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\ns32 data;\r\nint ret;\r\nret = mt9t031_s_power(&mt9t031->subdev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mt9t031_idle(client);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to initialise the camera\n");\r\ngoto done;\r\n}\r\ndata = reg_read(client, MT9T031_CHIP_VERSION);\r\nswitch (data) {\r\ncase 0x1621:\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"No MT9T031 chip detected, register read %x\n", data);\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\ndev_info(&client->dev, "Detected a MT9T031 chip ID %x\n", data);\r\nret = v4l2_ctrl_handler_setup(&mt9t031->hdl);\r\ndone:\r\nmt9t031_s_power(&mt9t031->subdev, 0);\r\nreturn ret;\r\n}\r\nstatic int mt9t031_g_skip_top_lines(struct v4l2_subdev *sd, u32 *lines)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\n*lines = mt9t031->y_skip_top;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_SBGGR10_1X10;\r\nreturn 0;\r\n}\r\nstatic int mt9t031_g_mbus_config(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\ncfg->flags = V4L2_MBUS_MASTER | V4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING | V4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH | V4L2_MBUS_DATA_ACTIVE_HIGH;\r\ncfg->type = V4L2_MBUS_PARALLEL;\r\ncfg->flags = soc_camera_apply_board_flags(ssdd, cfg);\r\nreturn 0;\r\n}\r\nstatic int mt9t031_s_mbus_config(struct v4l2_subdev *sd,\r\nconst struct v4l2_mbus_config *cfg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nif (soc_camera_apply_board_flags(ssdd, cfg) &\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING)\r\nreturn reg_clear(client, MT9T031_PIXEL_CLOCK_CONTROL, 0x8000);\r\nelse\r\nreturn reg_set(client, MT9T031_PIXEL_CLOCK_CONTROL, 0x8000);\r\n}\r\nstatic int mt9t031_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct mt9t031 *mt9t031;\r\nstruct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nint ret;\r\nif (!ssdd) {\r\ndev_err(&client->dev, "MT9T031 driver needs platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nmt9t031 = devm_kzalloc(&client->dev, sizeof(struct mt9t031), GFP_KERNEL);\r\nif (!mt9t031)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&mt9t031->subdev, client, &mt9t031_subdev_ops);\r\nv4l2_ctrl_handler_init(&mt9t031->hdl, 5);\r\nv4l2_ctrl_new_std(&mt9t031->hdl, &mt9t031_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9t031->hdl, &mt9t031_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&mt9t031->hdl, &mt9t031_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 64);\r\nmt9t031->autoexposure = v4l2_ctrl_new_std_menu(&mt9t031->hdl,\r\n&mt9t031_ctrl_ops, V4L2_CID_EXPOSURE_AUTO, 1, 0,\r\nV4L2_EXPOSURE_AUTO);\r\nmt9t031->exposure = v4l2_ctrl_new_std(&mt9t031->hdl, &mt9t031_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 1, 255, 1, 255);\r\nmt9t031->subdev.ctrl_handler = &mt9t031->hdl;\r\nif (mt9t031->hdl.error)\r\nreturn mt9t031->hdl.error;\r\nv4l2_ctrl_auto_cluster(2, &mt9t031->autoexposure,\r\nV4L2_EXPOSURE_MANUAL, true);\r\nmt9t031->y_skip_top = 0;\r\nmt9t031->rect.left = MT9T031_COLUMN_SKIP;\r\nmt9t031->rect.top = MT9T031_ROW_SKIP;\r\nmt9t031->rect.width = MT9T031_MAX_WIDTH;\r\nmt9t031->rect.height = MT9T031_MAX_HEIGHT;\r\nmt9t031->xskip = 1;\r\nmt9t031->yskip = 1;\r\nmt9t031->clk = v4l2_clk_get(&client->dev, "mclk");\r\nif (IS_ERR(mt9t031->clk)) {\r\nret = PTR_ERR(mt9t031->clk);\r\ngoto eclkget;\r\n}\r\nret = mt9t031_video_probe(client);\r\nif (ret) {\r\nv4l2_clk_put(mt9t031->clk);\r\neclkget:\r\nv4l2_ctrl_handler_free(&mt9t031->hdl);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9t031_remove(struct i2c_client *client)\r\n{\r\nstruct mt9t031 *mt9t031 = to_mt9t031(client);\r\nv4l2_clk_put(mt9t031->clk);\r\nv4l2_device_unregister_subdev(&mt9t031->subdev);\r\nv4l2_ctrl_handler_free(&mt9t031->hdl);\r\nreturn 0;\r\n}
