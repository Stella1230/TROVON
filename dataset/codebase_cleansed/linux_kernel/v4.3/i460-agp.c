static int i460_fetch_size (void)\r\n{\r\nint i;\r\nu8 temp;\r\nstruct aper_size_info_8 *values;\r\npci_read_config_byte(agp_bridge->dev, INTEL_I460_GXBCTL, &temp);\r\ni460.io_page_shift = (temp & I460_4M_PS) ? 22 : 12;\r\npr_debug("i460_fetch_size: io_page_shift=%d\n", i460.io_page_shift);\r\nif (i460.io_page_shift != I460_IO_PAGE_SHIFT) {\r\nprintk(KERN_ERR PFX\r\n"I/O (GART) page-size %luKB doesn't match expected "\r\n"size %luKB\n",\r\n1UL << (i460.io_page_shift - 10),\r\n1UL << (I460_IO_PAGE_SHIFT));\r\nreturn 0;\r\n}\r\nvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\r\npci_read_config_byte(agp_bridge->dev, INTEL_I460_AGPSIZ, &temp);\r\nif (temp & I460_SRAM_IO_DISABLE) {\r\nprintk(KERN_ERR PFX "GART SRAMS disabled on 460GX chipset\n");\r\nprintk(KERN_ERR PFX "AGPGART operation not possible\n");\r\nreturn 0;\r\n}\r\nif ((i460.io_page_shift == 0) && ((temp & I460_AGPSIZ_MASK) == 4)) {\r\nprintk(KERN_ERR PFX "We can't have a 32GB aperture with 4KB GART pages\n");\r\nreturn 0;\r\n}\r\nif (temp & I460_BAPBASE_ENABLE)\r\ni460.dynamic_apbase = INTEL_I460_BAPBASE;\r\nelse\r\ni460.dynamic_apbase = AGP_APBASE;\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nvalues[i].num_entries = (values[i].size << 8) >> (I460_IO_PAGE_SHIFT - 12);\r\nvalues[i].page_order = ilog2((sizeof(u32)*values[i].num_entries) >> PAGE_SHIFT);\r\n}\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif ((temp & I460_AGPSIZ_MASK) == values[i].size_value) {\r\nagp_bridge->previous_size = agp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void i460_tlb_flush (struct agp_memory *mem)\r\n{\r\nreturn;\r\n}\r\nstatic void i460_write_agpsiz (u8 size_value)\r\n{\r\nu8 temp;\r\npci_read_config_byte(agp_bridge->dev, INTEL_I460_AGPSIZ, &temp);\r\npci_write_config_byte(agp_bridge->dev, INTEL_I460_AGPSIZ,\r\n((temp & ~I460_AGPSIZ_MASK) | size_value));\r\n}\r\nstatic void i460_cleanup (void)\r\n{\r\nstruct aper_size_info_8 *previous_size;\r\nprevious_size = A_SIZE_8(agp_bridge->previous_size);\r\ni460_write_agpsiz(previous_size->size_value);\r\nif (I460_IO_PAGE_SHIFT > PAGE_SHIFT)\r\nkfree(i460.lp_desc);\r\n}\r\nstatic int i460_configure (void)\r\n{\r\nunion {\r\nu32 small[2];\r\nu64 large;\r\n} temp;\r\nsize_t size;\r\nu8 scratch;\r\nstruct aper_size_info_8 *current_size;\r\ntemp.large = 0;\r\ncurrent_size = A_SIZE_8(agp_bridge->current_size);\r\ni460_write_agpsiz(current_size->size_value);\r\npci_read_config_dword(agp_bridge->dev, i460.dynamic_apbase, &(temp.small[0]));\r\npci_read_config_dword(agp_bridge->dev, i460.dynamic_apbase + 4, &(temp.small[1]));\r\nagp_bridge->gart_bus_addr = temp.large & ~((1UL << 3) - 1);\r\npci_read_config_byte(agp_bridge->dev, INTEL_I460_GXBCTL, &scratch);\r\npci_write_config_byte(agp_bridge->dev, INTEL_I460_GXBCTL,\r\n(scratch & 0x02) | I460_GXBCTL_OOG | I460_GXBCTL_BWC);\r\nif (I460_IO_PAGE_SHIFT > PAGE_SHIFT) {\r\nsize = current_size->num_entries * sizeof(i460.lp_desc[0]);\r\ni460.lp_desc = kzalloc(size, GFP_KERNEL);\r\nif (!i460.lp_desc)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i460_create_gatt_table (struct agp_bridge_data *bridge)\r\n{\r\nint page_order, num_entries, i;\r\nvoid *temp;\r\ntemp = agp_bridge->current_size;\r\npage_order = A_SIZE_8(temp)->page_order;\r\nnum_entries = A_SIZE_8(temp)->num_entries;\r\ni460.gatt = ioremap(INTEL_I460_ATTBASE, PAGE_SIZE << page_order);\r\nif (!i460.gatt) {\r\nprintk(KERN_ERR PFX "ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\nagp_bridge->gatt_table_real = NULL;\r\nagp_bridge->gatt_table = NULL;\r\nagp_bridge->gatt_bus_addr = 0;\r\nfor (i = 0; i < num_entries; ++i)\r\nWR_GATT(i, 0);\r\nWR_FLUSH_GATT(i - 1);\r\nreturn 0;\r\n}\r\nstatic int i460_free_gatt_table (struct agp_bridge_data *bridge)\r\n{\r\nint num_entries, i;\r\nvoid *temp;\r\ntemp = agp_bridge->current_size;\r\nnum_entries = A_SIZE_8(temp)->num_entries;\r\nfor (i = 0; i < num_entries; ++i)\r\nWR_GATT(i, 0);\r\nWR_FLUSH_GATT(num_entries - 1);\r\niounmap(i460.gatt);\r\nreturn 0;\r\n}\r\nstatic int i460_insert_memory_small_io_page (struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nunsigned long paddr, io_pg_start, io_page_size;\r\nint i, j, k, num_entries;\r\nvoid *temp;\r\npr_debug("i460_insert_memory_small_io_page(mem=%p, pg_start=%ld, type=%d, paddr0=0x%lx)\n",\r\nmem, pg_start, type, page_to_phys(mem->pages[0]));\r\nif (type >= AGP_USER_TYPES || mem->type >= AGP_USER_TYPES)\r\nreturn -EINVAL;\r\nio_pg_start = I460_IOPAGES_PER_KPAGE * pg_start;\r\ntemp = agp_bridge->current_size;\r\nnum_entries = A_SIZE_8(temp)->num_entries;\r\nif ((io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count) > num_entries) {\r\nprintk(KERN_ERR PFX "Looks like we're out of AGP memory\n");\r\nreturn -EINVAL;\r\n}\r\nj = io_pg_start;\r\nwhile (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {\r\nif (!PGE_EMPTY(agp_bridge, RD_GATT(j))) {\r\npr_debug("i460_insert_memory_small_io_page: GATT[%d]=0x%x is busy\n",\r\nj, RD_GATT(j));\r\nreturn -EBUSY;\r\n}\r\nj++;\r\n}\r\nio_page_size = 1UL << I460_IO_PAGE_SHIFT;\r\nfor (i = 0, j = io_pg_start; i < mem->page_count; i++) {\r\npaddr = page_to_phys(mem->pages[i]);\r\nfor (k = 0; k < I460_IOPAGES_PER_KPAGE; k++, j++, paddr += io_page_size)\r\nWR_GATT(j, i460_mask_memory(agp_bridge, paddr, mem->type));\r\n}\r\nWR_FLUSH_GATT(j - 1);\r\nreturn 0;\r\n}\r\nstatic int i460_remove_memory_small_io_page(struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nint i;\r\npr_debug("i460_remove_memory_small_io_page(mem=%p, pg_start=%ld, type=%d)\n",\r\nmem, pg_start, type);\r\npg_start = I460_IOPAGES_PER_KPAGE * pg_start;\r\nfor (i = pg_start; i < (pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count); i++)\r\nWR_GATT(i, 0);\r\nWR_FLUSH_GATT(i - 1);\r\nreturn 0;\r\n}\r\nstatic int i460_alloc_large_page (struct lp_desc *lp)\r\n{\r\nunsigned long order = I460_IO_PAGE_SHIFT - PAGE_SHIFT;\r\nsize_t map_size;\r\nlp->page = alloc_pages(GFP_KERNEL, order);\r\nif (!lp->page) {\r\nprintk(KERN_ERR PFX "Couldn't alloc 4M GART page...\n");\r\nreturn -ENOMEM;\r\n}\r\nmap_size = ((I460_KPAGES_PER_IOPAGE + BITS_PER_LONG - 1) & -BITS_PER_LONG)/8;\r\nlp->alloced_map = kzalloc(map_size, GFP_KERNEL);\r\nif (!lp->alloced_map) {\r\n__free_pages(lp->page, order);\r\nprintk(KERN_ERR PFX "Out of memory, we're in trouble...\n");\r\nreturn -ENOMEM;\r\n}\r\nlp->paddr = page_to_phys(lp->page);\r\nlp->refcount = 0;\r\natomic_add(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);\r\nreturn 0;\r\n}\r\nstatic void i460_free_large_page (struct lp_desc *lp)\r\n{\r\nkfree(lp->alloced_map);\r\nlp->alloced_map = NULL;\r\n__free_pages(lp->page, I460_IO_PAGE_SHIFT - PAGE_SHIFT);\r\natomic_sub(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);\r\n}\r\nstatic int i460_insert_memory_large_io_page (struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nint i, start_offset, end_offset, idx, pg, num_entries;\r\nstruct lp_desc *start, *end, *lp;\r\nvoid *temp;\r\nif (type >= AGP_USER_TYPES || mem->type >= AGP_USER_TYPES)\r\nreturn -EINVAL;\r\ntemp = agp_bridge->current_size;\r\nnum_entries = A_SIZE_8(temp)->num_entries;\r\nstart = &i460.lp_desc[pg_start / I460_KPAGES_PER_IOPAGE];\r\nend = &i460.lp_desc[(pg_start + mem->page_count - 1) / I460_KPAGES_PER_IOPAGE];\r\nstart_offset = pg_start % I460_KPAGES_PER_IOPAGE;\r\nend_offset = (pg_start + mem->page_count - 1) % I460_KPAGES_PER_IOPAGE;\r\nif (end > i460.lp_desc + num_entries) {\r\nprintk(KERN_ERR PFX "Looks like we're out of AGP memory\n");\r\nreturn -EINVAL;\r\n}\r\nfor (lp = start; lp <= end; ++lp) {\r\nif (!lp->alloced_map)\r\ncontinue;\r\nfor (idx = ((lp == start) ? start_offset : 0);\r\nidx < ((lp == end) ? (end_offset + 1) : I460_KPAGES_PER_IOPAGE);\r\nidx++)\r\n{\r\nif (test_bit(idx, lp->alloced_map))\r\nreturn -EBUSY;\r\n}\r\n}\r\nfor (lp = start, i = 0; lp <= end; ++lp) {\r\nif (!lp->alloced_map) {\r\nif (i460_alloc_large_page(lp) < 0)\r\nreturn -ENOMEM;\r\npg = lp - i460.lp_desc;\r\nWR_GATT(pg, i460_mask_memory(agp_bridge,\r\nlp->paddr, 0));\r\nWR_FLUSH_GATT(pg);\r\n}\r\nfor (idx = ((lp == start) ? start_offset : 0);\r\nidx < ((lp == end) ? (end_offset + 1) : I460_KPAGES_PER_IOPAGE);\r\nidx++, i++)\r\n{\r\nmem->pages[i] = lp->page;\r\n__set_bit(idx, lp->alloced_map);\r\n++lp->refcount;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i460_remove_memory_large_io_page (struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nint i, pg, start_offset, end_offset, idx, num_entries;\r\nstruct lp_desc *start, *end, *lp;\r\nvoid *temp;\r\ntemp = agp_bridge->current_size;\r\nnum_entries = A_SIZE_8(temp)->num_entries;\r\nstart = &i460.lp_desc[pg_start / I460_KPAGES_PER_IOPAGE];\r\nend = &i460.lp_desc[(pg_start + mem->page_count - 1) / I460_KPAGES_PER_IOPAGE];\r\nstart_offset = pg_start % I460_KPAGES_PER_IOPAGE;\r\nend_offset = (pg_start + mem->page_count - 1) % I460_KPAGES_PER_IOPAGE;\r\nfor (i = 0, lp = start; lp <= end; ++lp) {\r\nfor (idx = ((lp == start) ? start_offset : 0);\r\nidx < ((lp == end) ? (end_offset + 1) : I460_KPAGES_PER_IOPAGE);\r\nidx++, i++)\r\n{\r\nmem->pages[i] = NULL;\r\n__clear_bit(idx, lp->alloced_map);\r\n--lp->refcount;\r\n}\r\nif (lp->refcount == 0) {\r\npg = lp - i460.lp_desc;\r\nWR_GATT(pg, 0);\r\nWR_FLUSH_GATT(pg);\r\ni460_free_large_page(lp);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int i460_insert_memory (struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT)\r\nreturn i460_insert_memory_small_io_page(mem, pg_start, type);\r\nelse\r\nreturn i460_insert_memory_large_io_page(mem, pg_start, type);\r\n}\r\nstatic int i460_remove_memory (struct agp_memory *mem,\r\noff_t pg_start, int type)\r\n{\r\nif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT)\r\nreturn i460_remove_memory_small_io_page(mem, pg_start, type);\r\nelse\r\nreturn i460_remove_memory_large_io_page(mem, pg_start, type);\r\n}\r\nstatic struct page *i460_alloc_page (struct agp_bridge_data *bridge)\r\n{\r\nvoid *page;\r\nif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT) {\r\npage = agp_generic_alloc_page(agp_bridge);\r\n} else\r\npage = (void *)~0UL;\r\nreturn page;\r\n}\r\nstatic void i460_destroy_page (struct page *page, int flags)\r\n{\r\nif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT) {\r\nagp_generic_destroy_page(page, flags);\r\n}\r\n}\r\nstatic unsigned long i460_mask_memory (struct agp_bridge_data *bridge,\r\ndma_addr_t addr, int type)\r\n{\r\nreturn bridge->driver->masks[0].mask\r\n| (((addr & ~((1 << I460_IO_PAGE_SHIFT) - 1)) & 0xfffff000) >> 12);\r\n}\r\nstatic int agp_intel_i460_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver = &intel_i460_driver;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nprintk(KERN_INFO PFX "Detected Intel 460GX chipset\n");\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void agp_intel_i460_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int __init agp_intel_i460_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_intel_i460_pci_driver);\r\n}\r\nstatic void __exit agp_intel_i460_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_intel_i460_pci_driver);\r\n}
