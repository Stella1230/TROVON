static int hash(int x)\r\n{\r\nreturn x & (TIPC_NAMETBL_SIZE - 1);\r\n}\r\nstatic struct publication *publ_create(u32 type, u32 lower, u32 upper,\r\nu32 scope, u32 node, u32 port_ref,\r\nu32 key)\r\n{\r\nstruct publication *publ = kzalloc(sizeof(*publ), GFP_ATOMIC);\r\nif (publ == NULL) {\r\npr_warn("Publication creation failure, no memory\n");\r\nreturn NULL;\r\n}\r\npubl->type = type;\r\npubl->lower = lower;\r\npubl->upper = upper;\r\npubl->scope = scope;\r\npubl->node = node;\r\npubl->ref = port_ref;\r\npubl->key = key;\r\nINIT_LIST_HEAD(&publ->pport_list);\r\nreturn publ;\r\n}\r\nstatic struct sub_seq *tipc_subseq_alloc(u32 cnt)\r\n{\r\nreturn kcalloc(cnt, sizeof(struct sub_seq), GFP_ATOMIC);\r\n}\r\nstatic struct name_seq *tipc_nameseq_create(u32 type, struct hlist_head *seq_head)\r\n{\r\nstruct name_seq *nseq = kzalloc(sizeof(*nseq), GFP_ATOMIC);\r\nstruct sub_seq *sseq = tipc_subseq_alloc(1);\r\nif (!nseq || !sseq) {\r\npr_warn("Name sequence creation failed, no memory\n");\r\nkfree(nseq);\r\nkfree(sseq);\r\nreturn NULL;\r\n}\r\nspin_lock_init(&nseq->lock);\r\nnseq->type = type;\r\nnseq->sseqs = sseq;\r\nnseq->alloc = 1;\r\nINIT_HLIST_NODE(&nseq->ns_list);\r\nINIT_LIST_HEAD(&nseq->subscriptions);\r\nhlist_add_head_rcu(&nseq->ns_list, seq_head);\r\nreturn nseq;\r\n}\r\nstatic struct sub_seq *nameseq_find_subseq(struct name_seq *nseq,\r\nu32 instance)\r\n{\r\nstruct sub_seq *sseqs = nseq->sseqs;\r\nint low = 0;\r\nint high = nseq->first_free - 1;\r\nint mid;\r\nwhile (low <= high) {\r\nmid = (low + high) / 2;\r\nif (instance < sseqs[mid].lower)\r\nhigh = mid - 1;\r\nelse if (instance > sseqs[mid].upper)\r\nlow = mid + 1;\r\nelse\r\nreturn &sseqs[mid];\r\n}\r\nreturn NULL;\r\n}\r\nstatic u32 nameseq_locate_subseq(struct name_seq *nseq, u32 instance)\r\n{\r\nstruct sub_seq *sseqs = nseq->sseqs;\r\nint low = 0;\r\nint high = nseq->first_free - 1;\r\nint mid;\r\nwhile (low <= high) {\r\nmid = (low + high) / 2;\r\nif (instance < sseqs[mid].lower)\r\nhigh = mid - 1;\r\nelse if (instance > sseqs[mid].upper)\r\nlow = mid + 1;\r\nelse\r\nreturn mid;\r\n}\r\nreturn low;\r\n}\r\nstatic struct publication *tipc_nameseq_insert_publ(struct net *net,\r\nstruct name_seq *nseq,\r\nu32 type, u32 lower,\r\nu32 upper, u32 scope,\r\nu32 node, u32 port, u32 key)\r\n{\r\nstruct tipc_subscription *s;\r\nstruct tipc_subscription *st;\r\nstruct publication *publ;\r\nstruct sub_seq *sseq;\r\nstruct name_info *info;\r\nint created_subseq = 0;\r\nsseq = nameseq_find_subseq(nseq, lower);\r\nif (sseq) {\r\nif ((sseq->lower != lower) || (sseq->upper != upper)) {\r\nreturn NULL;\r\n}\r\ninfo = sseq->info;\r\nlist_for_each_entry(publ, &info->zone_list, zone_list) {\r\nif ((publ->ref == port) && (publ->key == key) &&\r\n(!publ->node || (publ->node == node)))\r\nreturn NULL;\r\n}\r\n} else {\r\nu32 inspos;\r\nstruct sub_seq *freesseq;\r\ninspos = nameseq_locate_subseq(nseq, lower);\r\nif ((inspos < nseq->first_free) &&\r\n(upper >= nseq->sseqs[inspos].lower)) {\r\nreturn NULL;\r\n}\r\nif (nseq->first_free == nseq->alloc) {\r\nstruct sub_seq *sseqs = tipc_subseq_alloc(nseq->alloc * 2);\r\nif (!sseqs) {\r\npr_warn("Cannot publish {%u,%u,%u}, no memory\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nmemcpy(sseqs, nseq->sseqs,\r\nnseq->alloc * sizeof(struct sub_seq));\r\nkfree(nseq->sseqs);\r\nnseq->sseqs = sseqs;\r\nnseq->alloc *= 2;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_ATOMIC);\r\nif (!info) {\r\npr_warn("Cannot publish {%u,%u,%u}, no memory\n",\r\ntype, lower, upper);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&info->node_list);\r\nINIT_LIST_HEAD(&info->cluster_list);\r\nINIT_LIST_HEAD(&info->zone_list);\r\nsseq = &nseq->sseqs[inspos];\r\nfreesseq = &nseq->sseqs[nseq->first_free];\r\nmemmove(sseq + 1, sseq, (freesseq - sseq) * sizeof(*sseq));\r\nmemset(sseq, 0, sizeof(*sseq));\r\nnseq->first_free++;\r\nsseq->lower = lower;\r\nsseq->upper = upper;\r\nsseq->info = info;\r\ncreated_subseq = 1;\r\n}\r\npubl = publ_create(type, lower, upper, scope, node, port, key);\r\nif (!publ)\r\nreturn NULL;\r\nlist_add(&publ->zone_list, &info->zone_list);\r\ninfo->zone_list_size++;\r\nif (in_own_cluster(net, node)) {\r\nlist_add(&publ->cluster_list, &info->cluster_list);\r\ninfo->cluster_list_size++;\r\n}\r\nif (in_own_node(net, node)) {\r\nlist_add(&publ->node_list, &info->node_list);\r\ninfo->node_list_size++;\r\n}\r\nlist_for_each_entry_safe(s, st, &nseq->subscriptions, nameseq_list) {\r\ntipc_subscrp_report_overlap(s, publ->lower, publ->upper,\r\nTIPC_PUBLISHED, publ->ref,\r\npubl->node, created_subseq);\r\n}\r\nreturn publ;\r\n}\r\nstatic struct publication *tipc_nameseq_remove_publ(struct net *net,\r\nstruct name_seq *nseq,\r\nu32 inst, u32 node,\r\nu32 ref, u32 key)\r\n{\r\nstruct publication *publ;\r\nstruct sub_seq *sseq = nameseq_find_subseq(nseq, inst);\r\nstruct name_info *info;\r\nstruct sub_seq *free;\r\nstruct tipc_subscription *s, *st;\r\nint removed_subseq = 0;\r\nif (!sseq)\r\nreturn NULL;\r\ninfo = sseq->info;\r\nlist_for_each_entry(publ, &info->zone_list, zone_list) {\r\nif ((publ->key == key) && (publ->ref == ref) &&\r\n(!publ->node || (publ->node == node)))\r\ngoto found;\r\n}\r\nreturn NULL;\r\nfound:\r\nlist_del(&publ->zone_list);\r\ninfo->zone_list_size--;\r\nif (in_own_cluster(net, node)) {\r\nlist_del(&publ->cluster_list);\r\ninfo->cluster_list_size--;\r\n}\r\nif (in_own_node(net, node)) {\r\nlist_del(&publ->node_list);\r\ninfo->node_list_size--;\r\n}\r\nif (list_empty(&info->zone_list)) {\r\nkfree(info);\r\nfree = &nseq->sseqs[nseq->first_free--];\r\nmemmove(sseq, sseq + 1, (free - (sseq + 1)) * sizeof(*sseq));\r\nremoved_subseq = 1;\r\n}\r\nlist_for_each_entry_safe(s, st, &nseq->subscriptions, nameseq_list) {\r\ntipc_subscrp_report_overlap(s, publ->lower, publ->upper,\r\nTIPC_WITHDRAWN, publ->ref,\r\npubl->node, removed_subseq);\r\n}\r\nreturn publ;\r\n}\r\nstatic void tipc_nameseq_subscribe(struct name_seq *nseq,\r\nstruct tipc_subscription *s)\r\n{\r\nstruct sub_seq *sseq = nseq->sseqs;\r\nlist_add(&s->nameseq_list, &nseq->subscriptions);\r\nif (!sseq)\r\nreturn;\r\nwhile (sseq != &nseq->sseqs[nseq->first_free]) {\r\nif (tipc_subscrp_check_overlap(s, sseq->lower, sseq->upper)) {\r\nstruct publication *crs;\r\nstruct name_info *info = sseq->info;\r\nint must_report = 1;\r\nlist_for_each_entry(crs, &info->zone_list, zone_list) {\r\ntipc_subscrp_report_overlap(s, sseq->lower,\r\nsseq->upper,\r\nTIPC_PUBLISHED,\r\ncrs->ref, crs->node,\r\nmust_report);\r\nmust_report = 0;\r\n}\r\n}\r\nsseq++;\r\n}\r\n}\r\nstatic struct name_seq *nametbl_find_seq(struct net *net, u32 type)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct hlist_head *seq_head;\r\nstruct name_seq *ns;\r\nseq_head = &tn->nametbl->seq_hlist[hash(type)];\r\nhlist_for_each_entry_rcu(ns, seq_head, ns_list) {\r\nif (ns->type == type)\r\nreturn ns;\r\n}\r\nreturn NULL;\r\n}\r\nstruct publication *tipc_nametbl_insert_publ(struct net *net, u32 type,\r\nu32 lower, u32 upper, u32 scope,\r\nu32 node, u32 port, u32 key)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct publication *publ;\r\nstruct name_seq *seq = nametbl_find_seq(net, type);\r\nint index = hash(type);\r\nif ((scope < TIPC_ZONE_SCOPE) || (scope > TIPC_NODE_SCOPE) ||\r\n(lower > upper)) {\r\npr_debug("Failed to publish illegal {%u,%u,%u} with scope %u\n",\r\ntype, lower, upper, scope);\r\nreturn NULL;\r\n}\r\nif (!seq)\r\nseq = tipc_nameseq_create(type, &tn->nametbl->seq_hlist[index]);\r\nif (!seq)\r\nreturn NULL;\r\nspin_lock_bh(&seq->lock);\r\npubl = tipc_nameseq_insert_publ(net, seq, type, lower, upper,\r\nscope, node, port, key);\r\nspin_unlock_bh(&seq->lock);\r\nreturn publ;\r\n}\r\nstruct publication *tipc_nametbl_remove_publ(struct net *net, u32 type,\r\nu32 lower, u32 node, u32 ref,\r\nu32 key)\r\n{\r\nstruct publication *publ;\r\nstruct name_seq *seq = nametbl_find_seq(net, type);\r\nif (!seq)\r\nreturn NULL;\r\nspin_lock_bh(&seq->lock);\r\npubl = tipc_nameseq_remove_publ(net, seq, lower, node, ref, key);\r\nif (!seq->first_free && list_empty(&seq->subscriptions)) {\r\nhlist_del_init_rcu(&seq->ns_list);\r\nkfree(seq->sseqs);\r\nspin_unlock_bh(&seq->lock);\r\nkfree_rcu(seq, rcu);\r\nreturn publ;\r\n}\r\nspin_unlock_bh(&seq->lock);\r\nreturn publ;\r\n}\r\nu32 tipc_nametbl_translate(struct net *net, u32 type, u32 instance,\r\nu32 *destnode)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct sub_seq *sseq;\r\nstruct name_info *info;\r\nstruct publication *publ;\r\nstruct name_seq *seq;\r\nu32 ref = 0;\r\nu32 node = 0;\r\nif (!tipc_in_scope(*destnode, tn->own_addr))\r\nreturn 0;\r\nrcu_read_lock();\r\nseq = nametbl_find_seq(net, type);\r\nif (unlikely(!seq))\r\ngoto not_found;\r\nspin_lock_bh(&seq->lock);\r\nsseq = nameseq_find_subseq(seq, instance);\r\nif (unlikely(!sseq))\r\ngoto no_match;\r\ninfo = sseq->info;\r\nif (likely(!*destnode)) {\r\nif (!list_empty(&info->node_list)) {\r\npubl = list_first_entry(&info->node_list,\r\nstruct publication,\r\nnode_list);\r\nlist_move_tail(&publ->node_list,\r\n&info->node_list);\r\n} else if (!list_empty(&info->cluster_list)) {\r\npubl = list_first_entry(&info->cluster_list,\r\nstruct publication,\r\ncluster_list);\r\nlist_move_tail(&publ->cluster_list,\r\n&info->cluster_list);\r\n} else {\r\npubl = list_first_entry(&info->zone_list,\r\nstruct publication,\r\nzone_list);\r\nlist_move_tail(&publ->zone_list,\r\n&info->zone_list);\r\n}\r\n}\r\nelse if (*destnode == tn->own_addr) {\r\nif (list_empty(&info->node_list))\r\ngoto no_match;\r\npubl = list_first_entry(&info->node_list, struct publication,\r\nnode_list);\r\nlist_move_tail(&publ->node_list, &info->node_list);\r\n} else if (in_own_cluster_exact(net, *destnode)) {\r\nif (list_empty(&info->cluster_list))\r\ngoto no_match;\r\npubl = list_first_entry(&info->cluster_list, struct publication,\r\ncluster_list);\r\nlist_move_tail(&publ->cluster_list, &info->cluster_list);\r\n} else {\r\npubl = list_first_entry(&info->zone_list, struct publication,\r\nzone_list);\r\nlist_move_tail(&publ->zone_list, &info->zone_list);\r\n}\r\nref = publ->ref;\r\nnode = publ->node;\r\nno_match:\r\nspin_unlock_bh(&seq->lock);\r\nnot_found:\r\nrcu_read_unlock();\r\n*destnode = node;\r\nreturn ref;\r\n}\r\nint tipc_nametbl_mc_translate(struct net *net, u32 type, u32 lower, u32 upper,\r\nu32 limit, struct tipc_plist *dports)\r\n{\r\nstruct name_seq *seq;\r\nstruct sub_seq *sseq;\r\nstruct sub_seq *sseq_stop;\r\nstruct name_info *info;\r\nint res = 0;\r\nrcu_read_lock();\r\nseq = nametbl_find_seq(net, type);\r\nif (!seq)\r\ngoto exit;\r\nspin_lock_bh(&seq->lock);\r\nsseq = seq->sseqs + nameseq_locate_subseq(seq, lower);\r\nsseq_stop = seq->sseqs + seq->first_free;\r\nfor (; sseq != sseq_stop; sseq++) {\r\nstruct publication *publ;\r\nif (sseq->lower > upper)\r\nbreak;\r\ninfo = sseq->info;\r\nlist_for_each_entry(publ, &info->node_list, node_list) {\r\nif (publ->scope <= limit)\r\ntipc_plist_push(dports, publ->ref);\r\n}\r\nif (info->cluster_list_size != info->node_list_size)\r\nres = 1;\r\n}\r\nspin_unlock_bh(&seq->lock);\r\nexit:\r\nrcu_read_unlock();\r\nreturn res;\r\n}\r\nstruct publication *tipc_nametbl_publish(struct net *net, u32 type, u32 lower,\r\nu32 upper, u32 scope, u32 port_ref,\r\nu32 key)\r\n{\r\nstruct publication *publ;\r\nstruct sk_buff *buf = NULL;\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nspin_lock_bh(&tn->nametbl_lock);\r\nif (tn->nametbl->local_publ_count >= TIPC_MAX_PUBLICATIONS) {\r\npr_warn("Publication failed, local publication limit reached (%u)\n",\r\nTIPC_MAX_PUBLICATIONS);\r\nspin_unlock_bh(&tn->nametbl_lock);\r\nreturn NULL;\r\n}\r\npubl = tipc_nametbl_insert_publ(net, type, lower, upper, scope,\r\ntn->own_addr, port_ref, key);\r\nif (likely(publ)) {\r\ntn->nametbl->local_publ_count++;\r\nbuf = tipc_named_publish(net, publ);\r\ntipc_named_process_backlog(net);\r\n}\r\nspin_unlock_bh(&tn->nametbl_lock);\r\nif (buf)\r\nnamed_cluster_distribute(net, buf);\r\nreturn publ;\r\n}\r\nint tipc_nametbl_withdraw(struct net *net, u32 type, u32 lower, u32 ref,\r\nu32 key)\r\n{\r\nstruct publication *publ;\r\nstruct sk_buff *skb = NULL;\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nspin_lock_bh(&tn->nametbl_lock);\r\npubl = tipc_nametbl_remove_publ(net, type, lower, tn->own_addr,\r\nref, key);\r\nif (likely(publ)) {\r\ntn->nametbl->local_publ_count--;\r\nskb = tipc_named_withdraw(net, publ);\r\ntipc_named_process_backlog(net);\r\nlist_del_init(&publ->pport_list);\r\nkfree_rcu(publ, rcu);\r\n} else {\r\npr_err("Unable to remove local publication\n"\r\n"(type=%u, lower=%u, ref=%u, key=%u)\n",\r\ntype, lower, ref, key);\r\n}\r\nspin_unlock_bh(&tn->nametbl_lock);\r\nif (skb) {\r\nnamed_cluster_distribute(net, skb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid tipc_nametbl_subscribe(struct tipc_subscription *s)\r\n{\r\nstruct tipc_net *tn = net_generic(s->net, tipc_net_id);\r\nu32 type = s->seq.type;\r\nint index = hash(type);\r\nstruct name_seq *seq;\r\nspin_lock_bh(&tn->nametbl_lock);\r\nseq = nametbl_find_seq(s->net, type);\r\nif (!seq)\r\nseq = tipc_nameseq_create(type, &tn->nametbl->seq_hlist[index]);\r\nif (seq) {\r\nspin_lock_bh(&seq->lock);\r\ntipc_nameseq_subscribe(seq, s);\r\nspin_unlock_bh(&seq->lock);\r\n} else {\r\npr_warn("Failed to create subscription for {%u,%u,%u}\n",\r\ns->seq.type, s->seq.lower, s->seq.upper);\r\n}\r\nspin_unlock_bh(&tn->nametbl_lock);\r\n}\r\nvoid tipc_nametbl_unsubscribe(struct tipc_subscription *s)\r\n{\r\nstruct tipc_net *tn = net_generic(s->net, tipc_net_id);\r\nstruct name_seq *seq;\r\nspin_lock_bh(&tn->nametbl_lock);\r\nseq = nametbl_find_seq(s->net, s->seq.type);\r\nif (seq != NULL) {\r\nspin_lock_bh(&seq->lock);\r\nlist_del_init(&s->nameseq_list);\r\nif (!seq->first_free && list_empty(&seq->subscriptions)) {\r\nhlist_del_init_rcu(&seq->ns_list);\r\nkfree(seq->sseqs);\r\nspin_unlock_bh(&seq->lock);\r\nkfree_rcu(seq, rcu);\r\n} else {\r\nspin_unlock_bh(&seq->lock);\r\n}\r\n}\r\nspin_unlock_bh(&tn->nametbl_lock);\r\n}\r\nint tipc_nametbl_init(struct net *net)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct name_table *tipc_nametbl;\r\nint i;\r\ntipc_nametbl = kzalloc(sizeof(*tipc_nametbl), GFP_ATOMIC);\r\nif (!tipc_nametbl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < TIPC_NAMETBL_SIZE; i++)\r\nINIT_HLIST_HEAD(&tipc_nametbl->seq_hlist[i]);\r\nINIT_LIST_HEAD(&tipc_nametbl->publ_list[TIPC_ZONE_SCOPE]);\r\nINIT_LIST_HEAD(&tipc_nametbl->publ_list[TIPC_CLUSTER_SCOPE]);\r\nINIT_LIST_HEAD(&tipc_nametbl->publ_list[TIPC_NODE_SCOPE]);\r\ntn->nametbl = tipc_nametbl;\r\nspin_lock_init(&tn->nametbl_lock);\r\nreturn 0;\r\n}\r\nstatic void tipc_purge_publications(struct net *net, struct name_seq *seq)\r\n{\r\nstruct publication *publ, *safe;\r\nstruct sub_seq *sseq;\r\nstruct name_info *info;\r\nspin_lock_bh(&seq->lock);\r\nsseq = seq->sseqs;\r\ninfo = sseq->info;\r\nlist_for_each_entry_safe(publ, safe, &info->zone_list, zone_list) {\r\ntipc_nameseq_remove_publ(net, seq, publ->lower, publ->node,\r\npubl->ref, publ->key);\r\nkfree_rcu(publ, rcu);\r\n}\r\nhlist_del_init_rcu(&seq->ns_list);\r\nkfree(seq->sseqs);\r\nspin_unlock_bh(&seq->lock);\r\nkfree_rcu(seq, rcu);\r\n}\r\nvoid tipc_nametbl_stop(struct net *net)\r\n{\r\nu32 i;\r\nstruct name_seq *seq;\r\nstruct hlist_head *seq_head;\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct name_table *tipc_nametbl = tn->nametbl;\r\nspin_lock_bh(&tn->nametbl_lock);\r\nfor (i = 0; i < TIPC_NAMETBL_SIZE; i++) {\r\nif (hlist_empty(&tipc_nametbl->seq_hlist[i]))\r\ncontinue;\r\nseq_head = &tipc_nametbl->seq_hlist[i];\r\nhlist_for_each_entry_rcu(seq, seq_head, ns_list) {\r\ntipc_purge_publications(net, seq);\r\n}\r\n}\r\nspin_unlock_bh(&tn->nametbl_lock);\r\nsynchronize_net();\r\nkfree(tipc_nametbl);\r\n}\r\nstatic int __tipc_nl_add_nametable_publ(struct tipc_nl_msg *msg,\r\nstruct name_seq *seq,\r\nstruct sub_seq *sseq, u32 *last_publ)\r\n{\r\nvoid *hdr;\r\nstruct nlattr *attrs;\r\nstruct nlattr *publ;\r\nstruct publication *p;\r\nif (*last_publ) {\r\nlist_for_each_entry(p, &sseq->info->zone_list, zone_list)\r\nif (p->key == *last_publ)\r\nbreak;\r\nif (p->key != *last_publ)\r\nreturn -EPIPE;\r\n} else {\r\np = list_first_entry(&sseq->info->zone_list, struct publication,\r\nzone_list);\r\n}\r\nlist_for_each_entry_from(p, &sseq->info->zone_list, zone_list) {\r\n*last_publ = p->key;\r\nhdr = genlmsg_put(msg->skb, msg->portid, msg->seq,\r\n&tipc_genl_family, NLM_F_MULTI,\r\nTIPC_NL_NAME_TABLE_GET);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nattrs = nla_nest_start(msg->skb, TIPC_NLA_NAME_TABLE);\r\nif (!attrs)\r\ngoto msg_full;\r\npubl = nla_nest_start(msg->skb, TIPC_NLA_NAME_TABLE_PUBL);\r\nif (!publ)\r\ngoto attr_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_TYPE, seq->type))\r\ngoto publ_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_LOWER, sseq->lower))\r\ngoto publ_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_UPPER, sseq->upper))\r\ngoto publ_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_SCOPE, p->scope))\r\ngoto publ_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_NODE, p->node))\r\ngoto publ_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_REF, p->ref))\r\ngoto publ_msg_full;\r\nif (nla_put_u32(msg->skb, TIPC_NLA_PUBL_KEY, p->key))\r\ngoto publ_msg_full;\r\nnla_nest_end(msg->skb, publ);\r\nnla_nest_end(msg->skb, attrs);\r\ngenlmsg_end(msg->skb, hdr);\r\n}\r\n*last_publ = 0;\r\nreturn 0;\r\npubl_msg_full:\r\nnla_nest_cancel(msg->skb, publ);\r\nattr_msg_full:\r\nnla_nest_cancel(msg->skb, attrs);\r\nmsg_full:\r\ngenlmsg_cancel(msg->skb, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int __tipc_nl_subseq_list(struct tipc_nl_msg *msg, struct name_seq *seq,\r\nu32 *last_lower, u32 *last_publ)\r\n{\r\nstruct sub_seq *sseq;\r\nstruct sub_seq *sseq_start;\r\nint err;\r\nif (*last_lower) {\r\nsseq_start = nameseq_find_subseq(seq, *last_lower);\r\nif (!sseq_start)\r\nreturn -EPIPE;\r\n} else {\r\nsseq_start = seq->sseqs;\r\n}\r\nfor (sseq = sseq_start; sseq != &seq->sseqs[seq->first_free]; sseq++) {\r\nerr = __tipc_nl_add_nametable_publ(msg, seq, sseq, last_publ);\r\nif (err) {\r\n*last_lower = sseq->lower;\r\nreturn err;\r\n}\r\n}\r\n*last_lower = 0;\r\nreturn 0;\r\n}\r\nstatic int tipc_nl_seq_list(struct net *net, struct tipc_nl_msg *msg,\r\nu32 *last_type, u32 *last_lower, u32 *last_publ)\r\n{\r\nstruct tipc_net *tn = net_generic(net, tipc_net_id);\r\nstruct hlist_head *seq_head;\r\nstruct name_seq *seq = NULL;\r\nint err;\r\nint i;\r\nif (*last_type)\r\ni = hash(*last_type);\r\nelse\r\ni = 0;\r\nfor (; i < TIPC_NAMETBL_SIZE; i++) {\r\nseq_head = &tn->nametbl->seq_hlist[i];\r\nif (*last_type) {\r\nseq = nametbl_find_seq(net, *last_type);\r\nif (!seq)\r\nreturn -EPIPE;\r\n} else {\r\nhlist_for_each_entry_rcu(seq, seq_head, ns_list)\r\nbreak;\r\nif (!seq)\r\ncontinue;\r\n}\r\nhlist_for_each_entry_from_rcu(seq, ns_list) {\r\nspin_lock_bh(&seq->lock);\r\nerr = __tipc_nl_subseq_list(msg, seq, last_lower,\r\nlast_publ);\r\nif (err) {\r\n*last_type = seq->type;\r\nspin_unlock_bh(&seq->lock);\r\nreturn err;\r\n}\r\nspin_unlock_bh(&seq->lock);\r\n}\r\n*last_type = 0;\r\n}\r\nreturn 0;\r\n}\r\nint tipc_nl_name_table_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nint err;\r\nint done = cb->args[3];\r\nu32 last_type = cb->args[0];\r\nu32 last_lower = cb->args[1];\r\nu32 last_publ = cb->args[2];\r\nstruct net *net = sock_net(skb->sk);\r\nstruct tipc_nl_msg msg;\r\nif (done)\r\nreturn 0;\r\nmsg.skb = skb;\r\nmsg.portid = NETLINK_CB(cb->skb).portid;\r\nmsg.seq = cb->nlh->nlmsg_seq;\r\nrcu_read_lock();\r\nerr = tipc_nl_seq_list(net, &msg, &last_type, &last_lower, &last_publ);\r\nif (!err) {\r\ndone = 1;\r\n} else if (err != -EMSGSIZE) {\r\ncb->prev_seq = 1;\r\n}\r\nrcu_read_unlock();\r\ncb->args[0] = last_type;\r\ncb->args[1] = last_lower;\r\ncb->args[2] = last_publ;\r\ncb->args[3] = done;\r\nreturn skb->len;\r\n}\r\nvoid tipc_plist_push(struct tipc_plist *pl, u32 port)\r\n{\r\nstruct tipc_plist *nl;\r\nif (likely(!pl->port)) {\r\npl->port = port;\r\nreturn;\r\n}\r\nif (pl->port == port)\r\nreturn;\r\nlist_for_each_entry(nl, &pl->list, list) {\r\nif (nl->port == port)\r\nreturn;\r\n}\r\nnl = kmalloc(sizeof(*nl), GFP_ATOMIC);\r\nif (nl) {\r\nnl->port = port;\r\nlist_add(&nl->list, &pl->list);\r\n}\r\n}\r\nu32 tipc_plist_pop(struct tipc_plist *pl)\r\n{\r\nstruct tipc_plist *nl;\r\nu32 port = 0;\r\nif (likely(list_empty(&pl->list))) {\r\nport = pl->port;\r\npl->port = 0;\r\nreturn port;\r\n}\r\nnl = list_first_entry(&pl->list, typeof(*nl), list);\r\nport = nl->port;\r\nlist_del(&nl->list);\r\nkfree(nl);\r\nreturn port;\r\n}
