static void sh3__flush_wback_region(void *start, int size)\r\n{\r\nunsigned long v, j;\r\nunsigned long begin, end;\r\nunsigned long flags;\r\nbegin = (unsigned long)start & ~(L1_CACHE_BYTES-1);\r\nend = ((unsigned long)start + size + L1_CACHE_BYTES-1)\r\n& ~(L1_CACHE_BYTES-1);\r\nfor (v = begin; v < end; v+=L1_CACHE_BYTES) {\r\nunsigned long addrstart = CACHE_OC_ADDRESS_ARRAY;\r\nfor (j = 0; j < current_cpu_data.dcache.ways; j++) {\r\nunsigned long data, addr, p;\r\np = __pa(v);\r\naddr = addrstart | (v & current_cpu_data.dcache.entry_mask);\r\nlocal_irq_save(flags);\r\ndata = __raw_readl(addr);\r\nif ((data & CACHE_PHYSADDR_MASK) ==\r\n(p & CACHE_PHYSADDR_MASK)) {\r\ndata &= ~SH_CACHE_UPDATED;\r\n__raw_writel(data, addr);\r\nlocal_irq_restore(flags);\r\nbreak;\r\n}\r\nlocal_irq_restore(flags);\r\naddrstart += current_cpu_data.dcache.way_incr;\r\n}\r\n}\r\n}\r\nstatic void sh3__flush_purge_region(void *start, int size)\r\n{\r\nunsigned long v;\r\nunsigned long begin, end;\r\nbegin = (unsigned long)start & ~(L1_CACHE_BYTES-1);\r\nend = ((unsigned long)start + size + L1_CACHE_BYTES-1)\r\n& ~(L1_CACHE_BYTES-1);\r\nfor (v = begin; v < end; v+=L1_CACHE_BYTES) {\r\nunsigned long data, addr;\r\ndata = (v & 0xfffffc00);\r\naddr = CACHE_OC_ADDRESS_ARRAY |\r\n(v & current_cpu_data.dcache.entry_mask) | SH_CACHE_ASSOC;\r\n__raw_writel(data, addr);\r\n}\r\n}\r\nvoid __init sh3_cache_init(void)\r\n{\r\n__flush_wback_region = sh3__flush_wback_region;\r\n__flush_purge_region = sh3__flush_purge_region;\r\n__flush_invalidate_region = sh3__flush_purge_region;\r\n}
