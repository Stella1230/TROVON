static struct pwc_frame_buf *pwc_get_next_fill_buf(struct pwc_device *pdev)\r\n{\r\nunsigned long flags = 0;\r\nstruct pwc_frame_buf *buf = NULL;\r\nspin_lock_irqsave(&pdev->queued_bufs_lock, flags);\r\nif (list_empty(&pdev->queued_bufs))\r\ngoto leave;\r\nbuf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf, list);\r\nlist_del(&buf->list);\r\nleave:\r\nspin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);\r\nreturn buf;\r\n}\r\nstatic void pwc_snapshot_button(struct pwc_device *pdev, int down)\r\n{\r\nif (down) {\r\nPWC_TRACE("Snapshot button pressed.\n");\r\n} else {\r\nPWC_TRACE("Snapshot button released.\n");\r\n}\r\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\r\nif (pdev->button_dev) {\r\ninput_report_key(pdev->button_dev, KEY_CAMERA, down);\r\ninput_sync(pdev->button_dev);\r\n}\r\n#endif\r\n}\r\nstatic void pwc_frame_complete(struct pwc_device *pdev)\r\n{\r\nstruct pwc_frame_buf *fbuf = pdev->fill_buf;\r\nif (pdev->type == 730) {\r\nunsigned char *ptr = (unsigned char *)fbuf->data;\r\nif (ptr[1] == 1 && ptr[0] & 0x10) {\r\nPWC_TRACE("Hyundai CMOS sensor bug. Dropping frame.\n");\r\npdev->drop_frames += 2;\r\n}\r\nif ((ptr[0] ^ pdev->vmirror) & 0x01) {\r\npwc_snapshot_button(pdev, ptr[0] & 0x01);\r\n}\r\nif ((ptr[0] ^ pdev->vmirror) & 0x02) {\r\nif (ptr[0] & 0x02)\r\nPWC_TRACE("Image is mirrored.\n");\r\nelse\r\nPWC_TRACE("Image is normal.\n");\r\n}\r\npdev->vmirror = ptr[0] & 0x03;\r\nif (fbuf->filled == 4)\r\npdev->drop_frames++;\r\n} else if (pdev->type == 740 || pdev->type == 720) {\r\nunsigned char *ptr = (unsigned char *)fbuf->data;\r\nif ((ptr[0] ^ pdev->vmirror) & 0x01) {\r\npwc_snapshot_button(pdev, ptr[0] & 0x01);\r\n}\r\npdev->vmirror = ptr[0] & 0x03;\r\n}\r\nif (pdev->drop_frames > 0) {\r\npdev->drop_frames--;\r\n} else {\r\nif (fbuf->filled < pdev->frame_total_size) {\r\nPWC_DEBUG_FLOW("Frame buffer underflow (%d bytes);"\r\n" discarded.\n", fbuf->filled);\r\n} else {\r\nfbuf->vb.v4l2_buf.field = V4L2_FIELD_NONE;\r\nfbuf->vb.v4l2_buf.sequence = pdev->vframe_count;\r\nvb2_buffer_done(&fbuf->vb, VB2_BUF_STATE_DONE);\r\npdev->fill_buf = NULL;\r\npdev->vsync = 0;\r\n}\r\n}\r\npdev->vframe_count++;\r\n}\r\nstatic void pwc_isoc_handler(struct urb *urb)\r\n{\r\nstruct pwc_device *pdev = (struct pwc_device *)urb->context;\r\nint i, fst, flen;\r\nunsigned char *iso_buf = NULL;\r\nif (urb->status == -ENOENT || urb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN) {\r\nPWC_DEBUG_OPEN("URB (%p) unlinked %ssynchronuously.\n", urb, urb->status == -ENOENT ? "" : "a");\r\nreturn;\r\n}\r\nif (pdev->fill_buf == NULL)\r\npdev->fill_buf = pwc_get_next_fill_buf(pdev);\r\nif (urb->status != 0) {\r\nconst char *errmsg;\r\nerrmsg = "Unknown";\r\nswitch(urb->status) {\r\ncase -ENOSR: errmsg = "Buffer error (overrun)"; break;\r\ncase -EPIPE: errmsg = "Stalled (device not responding)"; break;\r\ncase -EOVERFLOW: errmsg = "Babble (bad cable?)"; break;\r\ncase -EPROTO: errmsg = "Bit-stuff error (bad cable?)"; break;\r\ncase -EILSEQ: errmsg = "CRC/Timeout (could be anything)"; break;\r\ncase -ETIME: errmsg = "Device does not respond"; break;\r\n}\r\nPWC_ERROR("pwc_isoc_handler() called with status %d [%s].\n",\r\nurb->status, errmsg);\r\nif (++pdev->visoc_errors > MAX_ISOC_ERRORS)\r\n{\r\nPWC_ERROR("Too many ISOC errors, bailing out.\n");\r\nif (pdev->fill_buf) {\r\nvb2_buffer_done(&pdev->fill_buf->vb,\r\nVB2_BUF_STATE_ERROR);\r\npdev->fill_buf = NULL;\r\n}\r\n}\r\npdev->vsync = 0;\r\ngoto handler_end;\r\n}\r\npdev->visoc_errors = 0;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nfst = urb->iso_frame_desc[i].status;\r\nflen = urb->iso_frame_desc[i].actual_length;\r\niso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (fst != 0) {\r\nPWC_ERROR("Iso frame %d has error %d\n", i, fst);\r\ncontinue;\r\n}\r\nif (flen > 0 && pdev->vsync) {\r\nstruct pwc_frame_buf *fbuf = pdev->fill_buf;\r\nif (pdev->vsync == 1) {\r\nv4l2_get_timestamp(\r\n&fbuf->vb.v4l2_buf.timestamp);\r\npdev->vsync = 2;\r\n}\r\nif (flen + fbuf->filled > pdev->frame_total_size) {\r\nPWC_ERROR("Frame overflow (%d > %d)\n",\r\nflen + fbuf->filled,\r\npdev->frame_total_size);\r\npdev->vsync = 0;\r\n} else {\r\nmemcpy(fbuf->data + fbuf->filled, iso_buf,\r\nflen);\r\nfbuf->filled += flen;\r\n}\r\n}\r\nif (flen < pdev->vlast_packet_size) {\r\nif (pdev->vsync == 2)\r\npwc_frame_complete(pdev);\r\nif (pdev->fill_buf == NULL)\r\npdev->fill_buf = pwc_get_next_fill_buf(pdev);\r\nif (pdev->fill_buf) {\r\npdev->fill_buf->filled = 0;\r\npdev->vsync = 1;\r\n}\r\n}\r\npdev->vlast_packet_size = flen;\r\n}\r\nhandler_end:\r\ni = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (i != 0)\r\nPWC_ERROR("Error (%d) re-submitting urb in pwc_isoc_handler.\n", i);\r\n}\r\nstatic int pwc_isoc_init(struct pwc_device *pdev)\r\n{\r\nstruct usb_device *udev;\r\nstruct urb *urb;\r\nint i, j, ret;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *idesc = NULL;\r\nint compression = 0;\r\npdev->vsync = 0;\r\npdev->vlast_packet_size = 0;\r\npdev->fill_buf = NULL;\r\npdev->vframe_count = 0;\r\npdev->visoc_errors = 0;\r\nudev = pdev->udev;\r\nretry:\r\nret = pwc_set_video_mode(pdev, pdev->width, pdev->height, pdev->pixfmt,\r\npdev->vframes, &compression, 1);\r\nintf = usb_ifnum_to_if(udev, 0);\r\nif (intf)\r\nidesc = usb_altnum_to_altsetting(intf, pdev->valternate);\r\nif (!idesc)\r\nreturn -EIO;\r\npdev->vmax_packet_size = -1;\r\nfor (i = 0; i < idesc->desc.bNumEndpoints; i++) {\r\nif ((idesc->endpoint[i].desc.bEndpointAddress & 0xF) == pdev->vendpoint) {\r\npdev->vmax_packet_size = le16_to_cpu(idesc->endpoint[i].desc.wMaxPacketSize);\r\nbreak;\r\n}\r\n}\r\nif (pdev->vmax_packet_size < 0 || pdev->vmax_packet_size > ISO_MAX_FRAME_SIZE) {\r\nPWC_ERROR("Failed to find packet size for video endpoint in current alternate setting.\n");\r\nreturn -ENFILE;\r\n}\r\nPWC_DEBUG_OPEN("Setting alternate interface %d\n", pdev->valternate);\r\nret = usb_set_interface(pdev->udev, 0, pdev->valternate);\r\nif (ret == -ENOSPC && compression < 3) {\r\ncompression++;\r\ngoto retry;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nurb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);\r\nif (urb == NULL) {\r\nPWC_ERROR("Failed to allocate urb %d\n", i);\r\npwc_isoc_cleanup(pdev);\r\nreturn -ENOMEM;\r\n}\r\npdev->urbs[i] = urb;\r\nPWC_DEBUG_MEMORY("Allocated URB at 0x%p\n", urb);\r\nurb->interval = 1;\r\nurb->dev = udev;\r\nurb->pipe = usb_rcvisocpipe(udev, pdev->vendpoint);\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_buffer = usb_alloc_coherent(udev,\r\nISO_BUFFER_SIZE,\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (urb->transfer_buffer == NULL) {\r\nPWC_ERROR("Failed to allocate urb buffer %d\n", i);\r\npwc_isoc_cleanup(pdev);\r\nreturn -ENOMEM;\r\n}\r\nurb->transfer_buffer_length = ISO_BUFFER_SIZE;\r\nurb->complete = pwc_isoc_handler;\r\nurb->context = pdev;\r\nurb->start_frame = 0;\r\nurb->number_of_packets = ISO_FRAMES_PER_DESC;\r\nfor (j = 0; j < ISO_FRAMES_PER_DESC; j++) {\r\nurb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;\r\nurb->iso_frame_desc[j].length = pdev->vmax_packet_size;\r\n}\r\n}\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nret = usb_submit_urb(pdev->urbs[i], GFP_KERNEL);\r\nif (ret == -ENOSPC && compression < 3) {\r\ncompression++;\r\npwc_isoc_cleanup(pdev);\r\ngoto retry;\r\n}\r\nif (ret) {\r\nPWC_ERROR("isoc_init() submit_urb %d failed with error %d\n", i, ret);\r\npwc_isoc_cleanup(pdev);\r\nreturn ret;\r\n}\r\nPWC_DEBUG_MEMORY("URB 0x%p submitted.\n", pdev->urbs[i]);\r\n}\r\nPWC_DEBUG_OPEN("<< pwc_isoc_init()\n");\r\nreturn 0;\r\n}\r\nstatic void pwc_iso_stop(struct pwc_device *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (pdev->urbs[i]) {\r\nPWC_DEBUG_MEMORY("Unlinking URB %p\n", pdev->urbs[i]);\r\nusb_kill_urb(pdev->urbs[i]);\r\n}\r\n}\r\n}\r\nstatic void pwc_iso_free(struct pwc_device *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (pdev->urbs[i]) {\r\nPWC_DEBUG_MEMORY("Freeing URB\n");\r\nif (pdev->urbs[i]->transfer_buffer) {\r\nusb_free_coherent(pdev->udev,\r\npdev->urbs[i]->transfer_buffer_length,\r\npdev->urbs[i]->transfer_buffer,\r\npdev->urbs[i]->transfer_dma);\r\n}\r\nusb_free_urb(pdev->urbs[i]);\r\npdev->urbs[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void pwc_isoc_cleanup(struct pwc_device *pdev)\r\n{\r\nPWC_DEBUG_OPEN(">> pwc_isoc_cleanup()\n");\r\npwc_iso_stop(pdev);\r\npwc_iso_free(pdev);\r\nusb_set_interface(pdev->udev, 0, 0);\r\nPWC_DEBUG_OPEN("<< pwc_isoc_cleanup()\n");\r\n}\r\nstatic void pwc_cleanup_queued_bufs(struct pwc_device *pdev,\r\nenum vb2_buffer_state state)\r\n{\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&pdev->queued_bufs_lock, flags);\r\nwhile (!list_empty(&pdev->queued_bufs)) {\r\nstruct pwc_frame_buf *buf;\r\nbuf = list_entry(pdev->queued_bufs.next, struct pwc_frame_buf,\r\nlist);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, state);\r\n}\r\nspin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);\r\n}\r\nstatic const char *pwc_sensor_type_to_string(unsigned int sensor_type)\r\n{\r\nswitch(sensor_type) {\r\ncase 0x00:\r\nreturn "Hyundai CMOS sensor";\r\ncase 0x20:\r\nreturn "Sony CCD sensor + TDA8787";\r\ncase 0x2E:\r\nreturn "Sony CCD sensor + Exas 98L59";\r\ncase 0x2F:\r\nreturn "Sony CCD sensor + ADI 9804";\r\ncase 0x30:\r\nreturn "Sharp CCD sensor + TDA8787";\r\ncase 0x3E:\r\nreturn "Sharp CCD sensor + Exas 98L59";\r\ncase 0x3F:\r\nreturn "Sharp CCD sensor + ADI 9804";\r\ncase 0x40:\r\nreturn "UPA 1021 sensor";\r\ncase 0x100:\r\nreturn "VGA sensor";\r\ncase 0x101:\r\nreturn "PAL MR sensor";\r\ndefault:\r\nreturn "unknown type of sensor";\r\n}\r\n}\r\nstatic void pwc_video_release(struct v4l2_device *v)\r\n{\r\nstruct pwc_device *pdev = container_of(v, struct pwc_device, v4l2_dev);\r\nv4l2_ctrl_handler_free(&pdev->ctrl_handler);\r\nv4l2_device_unregister(&pdev->v4l2_dev);\r\nkfree(pdev->ctrl_buf);\r\nkfree(pdev);\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct pwc_device *pdev = vb2_get_drv_priv(vq);\r\nint size;\r\nif (*nbuffers < MIN_FRAMES)\r\n*nbuffers = MIN_FRAMES;\r\nelse if (*nbuffers > MAX_FRAMES)\r\n*nbuffers = MAX_FRAMES;\r\n*nplanes = 1;\r\nsize = pwc_get_size(pdev, MAX_WIDTH, MAX_HEIGHT);\r\nsizes[0] = PAGE_ALIGN(pwc_image_sizes[size][0] *\r\npwc_image_sizes[size][1] * 3 / 2);\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct pwc_frame_buf *buf = container_of(vb, struct pwc_frame_buf, vb);\r\nbuf->data = vzalloc(PWC_FRAME_SIZE);\r\nif (buf->data == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct pwc_device *pdev = vb2_get_drv_priv(vb->vb2_queue);\r\nif (!pdev->udev)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct pwc_device *pdev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct pwc_frame_buf *buf = container_of(vb, struct pwc_frame_buf, vb);\r\nif (vb->state == VB2_BUF_STATE_DONE) {\r\npwc_decompress(pdev, buf);\r\n}\r\n}\r\nstatic void buffer_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct pwc_frame_buf *buf = container_of(vb, struct pwc_frame_buf, vb);\r\nvfree(buf->data);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct pwc_device *pdev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct pwc_frame_buf *buf = container_of(vb, struct pwc_frame_buf, vb);\r\nunsigned long flags = 0;\r\nif (!pdev->udev) {\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&pdev->queued_bufs_lock, flags);\r\nlist_add_tail(&buf->list, &pdev->queued_bufs);\r\nspin_unlock_irqrestore(&pdev->queued_bufs_lock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct pwc_device *pdev = vb2_get_drv_priv(vq);\r\nint r;\r\nif (!pdev->udev)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&pdev->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\npwc_camera_power(pdev, 1);\r\npwc_set_leds(pdev, leds[0], leds[1]);\r\nr = pwc_isoc_init(pdev);\r\nif (r) {\r\npwc_set_leds(pdev, 0, 0);\r\npwc_camera_power(pdev, 0);\r\npwc_cleanup_queued_bufs(pdev, VB2_BUF_STATE_QUEUED);\r\n}\r\nmutex_unlock(&pdev->v4l2_lock);\r\nreturn r;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct pwc_device *pdev = vb2_get_drv_priv(vq);\r\nmutex_lock(&pdev->v4l2_lock);\r\nif (pdev->udev) {\r\npwc_set_leds(pdev, 0, 0);\r\npwc_camera_power(pdev, 0);\r\npwc_isoc_cleanup(pdev);\r\n}\r\npwc_cleanup_queued_bufs(pdev, VB2_BUF_STATE_ERROR);\r\nif (pdev->fill_buf)\r\nvb2_buffer_done(&pdev->fill_buf->vb, VB2_BUF_STATE_ERROR);\r\nmutex_unlock(&pdev->v4l2_lock);\r\n}\r\nstatic int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct pwc_device *pdev = NULL;\r\nint vendor_id, product_id, type_id;\r\nint rc;\r\nint features = 0;\r\nint compression = 0;\r\nint my_power_save = power_save;\r\nchar serial_number[30], *name;\r\nvendor_id = le16_to_cpu(udev->descriptor.idVendor);\r\nproduct_id = le16_to_cpu(udev->descriptor.idProduct);\r\nPWC_DEBUG_PROBE("probe() called [%04X %04X], if %d\n",\r\nvendor_id, product_id,\r\nintf->altsetting->desc.bInterfaceNumber);\r\nif (intf->altsetting->desc.bInterfaceNumber > 0)\r\nreturn -ENODEV;\r\nif (vendor_id == 0x0471) {\r\nswitch (product_id) {\r\ncase 0x0302:\r\nPWC_INFO("Philips PCA645VC USB webcam detected.\n");\r\nname = "Philips 645 webcam";\r\ntype_id = 645;\r\nbreak;\r\ncase 0x0303:\r\nPWC_INFO("Philips PCA646VC USB webcam detected.\n");\r\nname = "Philips 646 webcam";\r\ntype_id = 646;\r\nbreak;\r\ncase 0x0304:\r\nPWC_INFO("Askey VC010 type 2 USB webcam detected.\n");\r\nname = "Askey VC010 webcam";\r\ntype_id = 646;\r\nbreak;\r\ncase 0x0307:\r\nPWC_INFO("Philips PCVC675K (Vesta) USB webcam detected.\n");\r\nname = "Philips 675 webcam";\r\ntype_id = 675;\r\nbreak;\r\ncase 0x0308:\r\nPWC_INFO("Philips PCVC680K (Vesta Pro) USB webcam detected.\n");\r\nname = "Philips 680 webcam";\r\ntype_id = 680;\r\nbreak;\r\ncase 0x030C:\r\nPWC_INFO("Philips PCVC690K (Vesta Pro Scan) USB webcam detected.\n");\r\nname = "Philips 690 webcam";\r\ntype_id = 690;\r\nbreak;\r\ncase 0x0310:\r\nPWC_INFO("Philips PCVC730K (ToUCam Fun)/PCVC830 (ToUCam II) USB webcam detected.\n");\r\nname = "Philips 730 webcam";\r\ntype_id = 730;\r\nbreak;\r\ncase 0x0311:\r\nPWC_INFO("Philips PCVC740K (ToUCam Pro)/PCVC840 (ToUCam II) USB webcam detected.\n");\r\nname = "Philips 740 webcam";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x0312:\r\nPWC_INFO("Philips PCVC750K (ToUCam Pro Scan) USB webcam detected.\n");\r\nname = "Philips 750 webcam";\r\ntype_id = 750;\r\nbreak;\r\ncase 0x0313:\r\nPWC_INFO("Philips PCVC720K/40 (ToUCam XS) USB webcam detected.\n");\r\nname = "Philips 720K/40 webcam";\r\ntype_id = 720;\r\nbreak;\r\ncase 0x0329:\r\nPWC_INFO("Philips SPC 900NC USB webcam detected.\n");\r\nname = "Philips SPC 900NC webcam";\r\ntype_id = 740;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x069A) {\r\nswitch(product_id) {\r\ncase 0x0001:\r\nPWC_INFO("Askey VC010 type 1 USB webcam detected.\n");\r\nname = "Askey VC010 webcam";\r\ntype_id = 645;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x046d) {\r\nswitch(product_id) {\r\ncase 0x08b0:\r\nPWC_INFO("Logitech QuickCam Pro 3000 USB webcam detected.\n");\r\nname = "Logitech QuickCam Pro 3000";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x08b1:\r\nPWC_INFO("Logitech QuickCam Notebook Pro USB webcam detected.\n");\r\nname = "Logitech QuickCam Notebook Pro";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x08b2:\r\nPWC_INFO("Logitech QuickCam 4000 Pro USB webcam detected.\n");\r\nname = "Logitech QuickCam Pro 4000";\r\ntype_id = 740;\r\nif (my_power_save == -1)\r\nmy_power_save = 1;\r\nbreak;\r\ncase 0x08b3:\r\nPWC_INFO("Logitech QuickCam Zoom USB webcam detected.\n");\r\nname = "Logitech QuickCam Zoom";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x08B4:\r\nPWC_INFO("Logitech QuickCam Zoom (new model) USB webcam detected.\n");\r\nname = "Logitech QuickCam Zoom";\r\ntype_id = 740;\r\nif (my_power_save == -1)\r\nmy_power_save = 1;\r\nbreak;\r\ncase 0x08b5:\r\nPWC_INFO("Logitech QuickCam Orbit/Sphere USB webcam detected.\n");\r\nname = "Logitech QuickCam Orbit";\r\ntype_id = 740;\r\nif (my_power_save == -1)\r\nmy_power_save = 1;\r\nfeatures |= FEATURE_MOTOR_PANTILT;\r\nbreak;\r\ncase 0x08b6:\r\nPWC_INFO("Logitech/Cisco VT Camera webcam detected.\n");\r\nname = "Cisco VT Camera";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x08b7:\r\nPWC_INFO("Logitech ViewPort AV 100 webcam detected.\n");\r\nname = "Logitech ViewPort AV 100";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x08b8:\r\nPWC_INFO("Logitech QuickCam detected (reserved ID).\n");\r\nname = "Logitech QuickCam (res.)";\r\ntype_id = 730;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x055d) {\r\nswitch(product_id) {\r\ncase 0x9000:\r\nPWC_INFO("Samsung MPC-C10 USB webcam detected.\n");\r\nname = "Samsung MPC-C10";\r\ntype_id = 675;\r\nbreak;\r\ncase 0x9001:\r\nPWC_INFO("Samsung MPC-C30 USB webcam detected.\n");\r\nname = "Samsung MPC-C30";\r\ntype_id = 675;\r\nbreak;\r\ncase 0x9002:\r\nPWC_INFO("Samsung SNC-35E (v3.0) USB webcam detected.\n");\r\nname = "Samsung MPC-C30";\r\ntype_id = 740;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x041e) {\r\nswitch(product_id) {\r\ncase 0x400c:\r\nPWC_INFO("Creative Labs Webcam 5 detected.\n");\r\nname = "Creative Labs Webcam 5";\r\ntype_id = 730;\r\nif (my_power_save == -1)\r\nmy_power_save = 1;\r\nbreak;\r\ncase 0x4011:\r\nPWC_INFO("Creative Labs Webcam Pro Ex detected.\n");\r\nname = "Creative Labs Webcam Pro Ex";\r\ntype_id = 740;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x04cc) {\r\nswitch(product_id) {\r\ncase 0x8116:\r\nPWC_INFO("Sotec Afina Eye USB webcam detected.\n");\r\nname = "Sotec Afina Eye";\r\ntype_id = 730;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x06be) {\r\nswitch(product_id) {\r\ncase 0x8116:\r\nPWC_INFO("AME Co. Afina Eye USB webcam detected.\n");\r\nname = "AME Co. Afina Eye";\r\ntype_id = 750;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse if (vendor_id == 0x0d81) {\r\nswitch(product_id) {\r\ncase 0x1900:\r\nPWC_INFO("Visionite VCS-UC300 USB webcam detected.\n");\r\nname = "Visionite VCS-UC300";\r\ntype_id = 740;\r\nbreak;\r\ncase 0x1910:\r\nPWC_INFO("Visionite VCS-UM100 USB webcam detected.\n");\r\nname = "Visionite VCS-UM100";\r\ntype_id = 730;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\n}\r\nelse\r\nreturn -ENODEV;\r\nif (my_power_save == -1)\r\nmy_power_save = 0;\r\nmemset(serial_number, 0, 30);\r\nusb_string(udev, udev->descriptor.iSerialNumber, serial_number, 29);\r\nPWC_DEBUG_PROBE("Device serial number is %s\n", serial_number);\r\nif (udev->descriptor.bNumConfigurations > 1)\r\nPWC_WARNING("Warning: more than 1 configuration available.\n");\r\npdev = kzalloc(sizeof(struct pwc_device), GFP_KERNEL);\r\nif (pdev == NULL) {\r\nPWC_ERROR("Oops, could not allocate memory for pwc_device.\n");\r\nreturn -ENOMEM;\r\n}\r\npdev->type = type_id;\r\npdev->features = features;\r\npwc_construct(pdev);\r\nmutex_init(&pdev->v4l2_lock);\r\nmutex_init(&pdev->vb_queue_lock);\r\nspin_lock_init(&pdev->queued_bufs_lock);\r\nINIT_LIST_HEAD(&pdev->queued_bufs);\r\npdev->udev = udev;\r\npdev->power_save = my_power_save;\r\npdev->vb_queue.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\npdev->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\npdev->vb_queue.drv_priv = pdev;\r\npdev->vb_queue.buf_struct_size = sizeof(struct pwc_frame_buf);\r\npdev->vb_queue.ops = &pwc_vb_queue_ops;\r\npdev->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\npdev->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nrc = vb2_queue_init(&pdev->vb_queue);\r\nif (rc < 0) {\r\nPWC_ERROR("Oops, could not initialize vb2 queue.\n");\r\ngoto err_free_mem;\r\n}\r\npdev->vdev = pwc_template;\r\nstrcpy(pdev->vdev.name, name);\r\npdev->vdev.queue = &pdev->vb_queue;\r\npdev->vdev.queue->lock = &pdev->vb_queue_lock;\r\nvideo_set_drvdata(&pdev->vdev, pdev);\r\npdev->release = le16_to_cpu(udev->descriptor.bcdDevice);\r\nPWC_DEBUG_PROBE("Release: %04x\n", pdev->release);\r\npdev->ctrl_buf = kmalloc(sizeof(pdev->cmd_buf), GFP_KERNEL);\r\nif (!pdev->ctrl_buf) {\r\nPWC_ERROR("Oops, could not allocate memory for pwc_device.\n");\r\nrc = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\n#ifdef CONFIG_USB_PWC_DEBUG\r\nif (pwc_get_cmos_sensor(pdev, &rc) >= 0) {\r\nPWC_DEBUG_OPEN("This %s camera is equipped with a %s (%d).\n",\r\npdev->vdev.name,\r\npwc_sensor_type_to_string(rc), rc);\r\n}\r\n#endif\r\npwc_set_leds(pdev, 0, 0);\r\nrc = pwc_set_video_mode(pdev, MAX_WIDTH, MAX_HEIGHT,\r\nV4L2_PIX_FMT_YUV420, 30, &compression, 1);\r\nif (rc)\r\ngoto err_free_mem;\r\nrc = pwc_init_controls(pdev);\r\nif (rc) {\r\nPWC_ERROR("Failed to register v4l2 controls (%d).\n", rc);\r\ngoto err_free_mem;\r\n}\r\npwc_camera_power(pdev, 0);\r\npdev->v4l2_dev.release = pwc_video_release;\r\nrc = v4l2_device_register(&intf->dev, &pdev->v4l2_dev);\r\nif (rc) {\r\nPWC_ERROR("Failed to register v4l2-device (%d).\n", rc);\r\ngoto err_free_controls;\r\n}\r\npdev->v4l2_dev.ctrl_handler = &pdev->ctrl_handler;\r\npdev->vdev.v4l2_dev = &pdev->v4l2_dev;\r\npdev->vdev.lock = &pdev->v4l2_lock;\r\nrc = video_register_device(&pdev->vdev, VFL_TYPE_GRABBER, -1);\r\nif (rc < 0) {\r\nPWC_ERROR("Failed to register as video device (%d).\n", rc);\r\ngoto err_unregister_v4l2_dev;\r\n}\r\nPWC_INFO("Registered as %s.\n", video_device_node_name(&pdev->vdev));\r\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\r\npdev->button_dev = input_allocate_device();\r\nif (!pdev->button_dev) {\r\nrc = -ENOMEM;\r\ngoto err_video_unreg;\r\n}\r\nusb_make_path(udev, pdev->button_phys, sizeof(pdev->button_phys));\r\nstrlcat(pdev->button_phys, "/input0", sizeof(pdev->button_phys));\r\npdev->button_dev->name = "PWC snapshot button";\r\npdev->button_dev->phys = pdev->button_phys;\r\nusb_to_input_id(pdev->udev, &pdev->button_dev->id);\r\npdev->button_dev->dev.parent = &pdev->udev->dev;\r\npdev->button_dev->evbit[0] = BIT_MASK(EV_KEY);\r\npdev->button_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);\r\nrc = input_register_device(pdev->button_dev);\r\nif (rc) {\r\ninput_free_device(pdev->button_dev);\r\npdev->button_dev = NULL;\r\ngoto err_video_unreg;\r\n}\r\n#endif\r\nreturn 0;\r\nerr_video_unreg:\r\nvideo_unregister_device(&pdev->vdev);\r\nerr_unregister_v4l2_dev:\r\nv4l2_device_unregister(&pdev->v4l2_dev);\r\nerr_free_controls:\r\nv4l2_ctrl_handler_free(&pdev->ctrl_handler);\r\nerr_free_mem:\r\nkfree(pdev->ctrl_buf);\r\nkfree(pdev);\r\nreturn rc;\r\n}\r\nstatic void usb_pwc_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v = usb_get_intfdata(intf);\r\nstruct pwc_device *pdev = container_of(v, struct pwc_device, v4l2_dev);\r\nmutex_lock(&pdev->vb_queue_lock);\r\nmutex_lock(&pdev->v4l2_lock);\r\nif (pdev->vb_queue.streaming)\r\npwc_isoc_cleanup(pdev);\r\npdev->udev = NULL;\r\nv4l2_device_disconnect(&pdev->v4l2_dev);\r\nvideo_unregister_device(&pdev->vdev);\r\nmutex_unlock(&pdev->v4l2_lock);\r\nmutex_unlock(&pdev->vb_queue_lock);\r\n#ifdef CONFIG_USB_PWC_INPUT_EVDEV\r\nif (pdev->button_dev)\r\ninput_unregister_device(pdev->button_dev);\r\n#endif\r\nv4l2_device_put(&pdev->v4l2_dev);\r\n}
