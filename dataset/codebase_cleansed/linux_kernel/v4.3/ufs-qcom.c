static int ufs_qcom_get_connected_tx_lanes(struct ufs_hba *hba, u32 *tx_lanes)\r\n{\r\nint err = 0;\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB(PA_CONNECTEDTXDATALANES), tx_lanes);\r\nif (err)\r\ndev_err(hba->dev, "%s: couldn't read PA_CONNECTEDTXDATALANES %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_host_clk_get(struct device *dev,\r\nconst char *name, struct clk **clk_out)\r\n{\r\nstruct clk *clk;\r\nint err = 0;\r\nclk = devm_clk_get(dev, name);\r\nif (IS_ERR(clk)) {\r\nerr = PTR_ERR(clk);\r\ndev_err(dev, "%s: failed to get %s err %d",\r\n__func__, name, err);\r\n} else {\r\n*clk_out = clk;\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_host_clk_enable(struct device *dev,\r\nconst char *name, struct clk *clk)\r\n{\r\nint err = 0;\r\nerr = clk_prepare_enable(clk);\r\nif (err)\r\ndev_err(dev, "%s: %s enable failed %d\n", __func__, name, err);\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_disable_lane_clks(struct ufs_qcom_host *host)\r\n{\r\nif (!host->is_lane_clks_enabled)\r\nreturn;\r\nclk_disable_unprepare(host->tx_l1_sync_clk);\r\nclk_disable_unprepare(host->tx_l0_sync_clk);\r\nclk_disable_unprepare(host->rx_l1_sync_clk);\r\nclk_disable_unprepare(host->rx_l0_sync_clk);\r\nhost->is_lane_clks_enabled = false;\r\n}\r\nstatic int ufs_qcom_enable_lane_clks(struct ufs_qcom_host *host)\r\n{\r\nint err = 0;\r\nstruct device *dev = host->hba->dev;\r\nif (host->is_lane_clks_enabled)\r\nreturn 0;\r\nerr = ufs_qcom_host_clk_enable(dev, "rx_lane0_sync_clk",\r\nhost->rx_l0_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_enable(dev, "tx_lane0_sync_clk",\r\nhost->tx_l0_sync_clk);\r\nif (err)\r\ngoto disable_rx_l0;\r\nerr = ufs_qcom_host_clk_enable(dev, "rx_lane1_sync_clk",\r\nhost->rx_l1_sync_clk);\r\nif (err)\r\ngoto disable_tx_l0;\r\nerr = ufs_qcom_host_clk_enable(dev, "tx_lane1_sync_clk",\r\nhost->tx_l1_sync_clk);\r\nif (err)\r\ngoto disable_rx_l1;\r\nhost->is_lane_clks_enabled = true;\r\ngoto out;\r\ndisable_rx_l1:\r\nclk_disable_unprepare(host->rx_l1_sync_clk);\r\ndisable_tx_l0:\r\nclk_disable_unprepare(host->tx_l0_sync_clk);\r\ndisable_rx_l0:\r\nclk_disable_unprepare(host->rx_l0_sync_clk);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_init_lane_clks(struct ufs_qcom_host *host)\r\n{\r\nint err = 0;\r\nstruct device *dev = host->hba->dev;\r\nerr = ufs_qcom_host_clk_get(dev,\r\n"rx_lane0_sync_clk", &host->rx_l0_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_get(dev,\r\n"tx_lane0_sync_clk", &host->tx_l0_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_get(dev, "rx_lane1_sync_clk",\r\n&host->rx_l1_sync_clk);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_host_clk_get(dev, "tx_lane1_sync_clk",\r\n&host->tx_l1_sync_clk);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_link_startup_post_change(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct phy *phy = host->generic_phy;\r\nu32 tx_lanes;\r\nint err = 0;\r\nerr = ufs_qcom_get_connected_tx_lanes(hba, &tx_lanes);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_phy_set_tx_lane_enable(phy, tx_lanes);\r\nif (err)\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_set_tx_lane_enable failed\n",\r\n__func__);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_check_hibern8(struct ufs_hba *hba)\r\n{\r\nint err;\r\nu32 tx_fsm_val = 0;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(HBRN8_POLL_TOUT_MS);\r\ndo {\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB(MPHY_TX_FSM_STATE), &tx_fsm_val);\r\nif (err || tx_fsm_val == TX_FSM_HIBERN8)\r\nbreak;\r\nusleep_range(100, 200);\r\n} while (time_before(jiffies, timeout));\r\nif (time_after(jiffies, timeout))\r\nerr = ufshcd_dme_get(hba,\r\nUIC_ARG_MIB(MPHY_TX_FSM_STATE), &tx_fsm_val);\r\nif (err) {\r\ndev_err(hba->dev, "%s: unable to get TX_FSM_STATE, err %d\n",\r\n__func__, err);\r\n} else if (tx_fsm_val != TX_FSM_HIBERN8) {\r\nerr = tx_fsm_val;\r\ndev_err(hba->dev, "%s: invalid TX_FSM_STATE = %d\n",\r\n__func__, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_power_up_sequence(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct phy *phy = host->generic_phy;\r\nint ret = 0;\r\nbool is_rate_B = (UFS_QCOM_LIMIT_HS_RATE == PA_HS_MODE_B)\r\n? true : false;\r\nufs_qcom_assert_reset(hba);\r\nusleep_range(1000, 1100);\r\nret = ufs_qcom_phy_calibrate_phy(phy, is_rate_B);\r\nif (ret) {\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_calibrate_phy() failed, ret = %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nufs_qcom_deassert_reset(hba);\r\nusleep_range(1000, 1100);\r\nret = ufs_qcom_phy_start_serdes(phy);\r\nif (ret) {\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_start_serdes() failed, ret = %d\n",\r\n__func__, ret);\r\ngoto out;\r\n}\r\nret = ufs_qcom_phy_is_pcs_ready(phy);\r\nif (ret)\r\ndev_err(hba->dev, "%s: is_physical_coding_sublayer_ready() failed, ret = %d\n",\r\n__func__, ret);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ufs_qcom_enable_hw_clk_gating(struct ufs_hba *hba)\r\n{\r\nufshcd_writel(hba,\r\nufshcd_readl(hba, REG_UFS_CFG2) | REG_UFS_CFG2_CGC_EN_ALL,\r\nREG_UFS_CFG2);\r\nmb();\r\n}\r\nstatic int ufs_qcom_hce_enable_notify(struct ufs_hba *hba, bool status)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nint err = 0;\r\nswitch (status) {\r\ncase PRE_CHANGE:\r\nufs_qcom_power_up_sequence(hba);\r\nerr = ufs_qcom_enable_lane_clks(host);\r\nbreak;\r\ncase POST_CHANGE:\r\nerr = ufs_qcom_check_hibern8(hba);\r\nufs_qcom_enable_hw_clk_gating(hba);\r\nbreak;\r\ndefault:\r\ndev_err(hba->dev, "%s: invalid status %d\n", __func__, status);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned long\r\nufs_qcom_cfg_timers(struct ufs_hba *hba, u32 gear, u32 hs, u32 rate)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct ufs_clk_info *clki;\r\nu32 core_clk_period_in_ns;\r\nu32 tx_clk_cycles_per_us = 0;\r\nunsigned long core_clk_rate = 0;\r\nu32 core_clk_cycles_per_us = 0;\r\nstatic u32 pwm_fr_table[][2] = {\r\n{UFS_PWM_G1, 0x1},\r\n{UFS_PWM_G2, 0x1},\r\n{UFS_PWM_G3, 0x1},\r\n{UFS_PWM_G4, 0x1},\r\n};\r\nstatic u32 hs_fr_table_rA[][2] = {\r\n{UFS_HS_G1, 0x1F},\r\n{UFS_HS_G2, 0x3e},\r\n};\r\nstatic u32 hs_fr_table_rB[][2] = {\r\n{UFS_HS_G1, 0x24},\r\n{UFS_HS_G2, 0x49},\r\n};\r\nif (ufs_qcom_cap_qunipro(host) && !ufshcd_is_intr_aggr_allowed(hba))\r\ngoto out;\r\nif (gear == 0) {\r\ndev_err(hba->dev, "%s: invalid gear = %d\n", __func__, gear);\r\ngoto out_error;\r\n}\r\nlist_for_each_entry(clki, &hba->clk_list_head, list) {\r\nif (!strcmp(clki->name, "core_clk"))\r\ncore_clk_rate = clk_get_rate(clki->clk);\r\n}\r\nif (core_clk_rate < DEFAULT_CLK_RATE_HZ)\r\ncore_clk_rate = DEFAULT_CLK_RATE_HZ;\r\ncore_clk_cycles_per_us = core_clk_rate / USEC_PER_SEC;\r\nufshcd_writel(hba, core_clk_cycles_per_us, REG_UFS_SYS1CLK_1US);\r\ncore_clk_period_in_ns = NSEC_PER_SEC / core_clk_rate;\r\ncore_clk_period_in_ns <<= OFFSET_CLK_NS_REG;\r\ncore_clk_period_in_ns &= MASK_CLK_NS_REG;\r\nswitch (hs) {\r\ncase FASTAUTO_MODE:\r\ncase FAST_MODE:\r\nif (rate == PA_HS_MODE_A) {\r\nif (gear > ARRAY_SIZE(hs_fr_table_rA)) {\r\ndev_err(hba->dev,\r\n"%s: index %d exceeds table size %zu\n",\r\n__func__, gear,\r\nARRAY_SIZE(hs_fr_table_rA));\r\ngoto out_error;\r\n}\r\ntx_clk_cycles_per_us = hs_fr_table_rA[gear-1][1];\r\n} else if (rate == PA_HS_MODE_B) {\r\nif (gear > ARRAY_SIZE(hs_fr_table_rB)) {\r\ndev_err(hba->dev,\r\n"%s: index %d exceeds table size %zu\n",\r\n__func__, gear,\r\nARRAY_SIZE(hs_fr_table_rB));\r\ngoto out_error;\r\n}\r\ntx_clk_cycles_per_us = hs_fr_table_rB[gear-1][1];\r\n} else {\r\ndev_err(hba->dev, "%s: invalid rate = %d\n",\r\n__func__, rate);\r\ngoto out_error;\r\n}\r\nbreak;\r\ncase SLOWAUTO_MODE:\r\ncase SLOW_MODE:\r\nif (gear > ARRAY_SIZE(pwm_fr_table)) {\r\ndev_err(hba->dev,\r\n"%s: index %d exceeds table size %zu\n",\r\n__func__, gear,\r\nARRAY_SIZE(pwm_fr_table));\r\ngoto out_error;\r\n}\r\ntx_clk_cycles_per_us = pwm_fr_table[gear-1][1];\r\nbreak;\r\ncase UNCHANGED:\r\ndefault:\r\ndev_err(hba->dev, "%s: invalid mode = %d\n", __func__, hs);\r\ngoto out_error;\r\n}\r\nufshcd_writel(hba, core_clk_period_in_ns | tx_clk_cycles_per_us,\r\nREG_UFS_TX_SYMBOL_CLK_NS_US);\r\ngoto out;\r\nout_error:\r\ncore_clk_rate = 0;\r\nout:\r\nreturn core_clk_rate;\r\n}\r\nstatic int ufs_qcom_link_startup_notify(struct ufs_hba *hba, bool status)\r\n{\r\nunsigned long core_clk_rate = 0;\r\nu32 core_clk_cycles_per_100ms;\r\nswitch (status) {\r\ncase PRE_CHANGE:\r\ncore_clk_rate = ufs_qcom_cfg_timers(hba, UFS_PWM_G1,\r\nSLOWAUTO_MODE, 0);\r\nif (!core_clk_rate) {\r\ndev_err(hba->dev, "%s: ufs_qcom_cfg_timers() failed\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ncore_clk_cycles_per_100ms =\r\n(core_clk_rate / MSEC_PER_SEC) * 100;\r\nufshcd_writel(hba, core_clk_cycles_per_100ms,\r\nREG_UFS_PA_LINK_STARTUP_TIMER);\r\nbreak;\r\ncase POST_CHANGE:\r\nufs_qcom_link_startup_post_change(hba);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ufs_qcom_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct phy *phy = host->generic_phy;\r\nint ret = 0;\r\nif (ufs_qcom_is_link_off(hba)) {\r\nufs_qcom_disable_lane_clks(host);\r\nphy_power_off(phy);\r\nufs_qcom_assert_reset(hba);\r\ngoto out;\r\n}\r\nif (!ufs_qcom_is_link_active(hba))\r\nphy_power_off(phy);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ufs_qcom_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct phy *phy = host->generic_phy;\r\nint err;\r\nerr = phy_power_on(phy);\r\nif (err) {\r\ndev_err(hba->dev, "%s: failed enabling regs, err = %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nhba->is_sys_suspended = false;\r\nout:\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_get_pwr_dev_param(struct ufs_qcom_dev_params *qcom_param,\r\nstruct ufs_pa_layer_attr *dev_max,\r\nstruct ufs_pa_layer_attr *agreed_pwr)\r\n{\r\nint min_qcom_gear;\r\nint min_dev_gear;\r\nbool is_dev_sup_hs = false;\r\nbool is_qcom_max_hs = false;\r\nif (dev_max->pwr_rx == FAST_MODE)\r\nis_dev_sup_hs = true;\r\nif (qcom_param->desired_working_mode == FAST) {\r\nis_qcom_max_hs = true;\r\nmin_qcom_gear = min_t(u32, qcom_param->hs_rx_gear,\r\nqcom_param->hs_tx_gear);\r\n} else {\r\nmin_qcom_gear = min_t(u32, qcom_param->pwm_rx_gear,\r\nqcom_param->pwm_tx_gear);\r\n}\r\nif (!is_dev_sup_hs && is_qcom_max_hs) {\r\npr_err("%s: failed to agree on power mode (device doesn't support HS but requested power is HS)\n",\r\n__func__);\r\nreturn -ENOTSUPP;\r\n} else if (is_dev_sup_hs && is_qcom_max_hs) {\r\nagreed_pwr->pwr_rx = agreed_pwr->pwr_tx =\r\nqcom_param->rx_pwr_hs;\r\n} else {\r\nagreed_pwr->pwr_rx = agreed_pwr->pwr_tx =\r\nqcom_param->rx_pwr_pwm;\r\n}\r\nagreed_pwr->lane_tx = min_t(u32, dev_max->lane_tx,\r\nqcom_param->tx_lanes);\r\nagreed_pwr->lane_rx = min_t(u32, dev_max->lane_rx,\r\nqcom_param->rx_lanes);\r\nmin_dev_gear = min_t(u32, dev_max->gear_rx, dev_max->gear_tx);\r\nif ((is_dev_sup_hs && is_qcom_max_hs) ||\r\n(!is_dev_sup_hs && !is_qcom_max_hs))\r\nagreed_pwr->gear_rx = agreed_pwr->gear_tx =\r\nmin_t(u32, min_dev_gear, min_qcom_gear);\r\nelse if (!is_dev_sup_hs)\r\nagreed_pwr->gear_rx = agreed_pwr->gear_tx = min_dev_gear;\r\nelse\r\nagreed_pwr->gear_rx = agreed_pwr->gear_tx = min_qcom_gear;\r\nagreed_pwr->hs_rate = qcom_param->hs_rate;\r\nreturn 0;\r\n}\r\nstatic int ufs_qcom_update_bus_bw_vote(struct ufs_qcom_host *host)\r\n{\r\nint vote;\r\nint err = 0;\r\nchar mode[BUS_VECTOR_NAME_LEN];\r\nufs_qcom_get_speed_mode(&host->dev_req_params, mode);\r\nvote = ufs_qcom_get_bus_vote(host, mode);\r\nif (vote >= 0)\r\nerr = ufs_qcom_set_bus_vote(host, vote);\r\nelse\r\nerr = vote;\r\nif (err)\r\ndev_err(host->hba->dev, "%s: failed %d\n", __func__, err);\r\nelse\r\nhost->bus_vote.saved_vote = vote;\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_pwr_change_notify(struct ufs_hba *hba,\r\nbool status,\r\nstruct ufs_pa_layer_attr *dev_max_params,\r\nstruct ufs_pa_layer_attr *dev_req_params)\r\n{\r\nu32 val;\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct phy *phy = host->generic_phy;\r\nstruct ufs_qcom_dev_params ufs_qcom_cap;\r\nint ret = 0;\r\nint res = 0;\r\nif (!dev_req_params) {\r\npr_err("%s: incoming dev_req_params is NULL\n", __func__);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (status) {\r\ncase PRE_CHANGE:\r\nufs_qcom_cap.tx_lanes = UFS_QCOM_LIMIT_NUM_LANES_TX;\r\nufs_qcom_cap.rx_lanes = UFS_QCOM_LIMIT_NUM_LANES_RX;\r\nufs_qcom_cap.hs_rx_gear = UFS_QCOM_LIMIT_HSGEAR_RX;\r\nufs_qcom_cap.hs_tx_gear = UFS_QCOM_LIMIT_HSGEAR_TX;\r\nufs_qcom_cap.pwm_rx_gear = UFS_QCOM_LIMIT_PWMGEAR_RX;\r\nufs_qcom_cap.pwm_tx_gear = UFS_QCOM_LIMIT_PWMGEAR_TX;\r\nufs_qcom_cap.rx_pwr_pwm = UFS_QCOM_LIMIT_RX_PWR_PWM;\r\nufs_qcom_cap.tx_pwr_pwm = UFS_QCOM_LIMIT_TX_PWR_PWM;\r\nufs_qcom_cap.rx_pwr_hs = UFS_QCOM_LIMIT_RX_PWR_HS;\r\nufs_qcom_cap.tx_pwr_hs = UFS_QCOM_LIMIT_TX_PWR_HS;\r\nufs_qcom_cap.hs_rate = UFS_QCOM_LIMIT_HS_RATE;\r\nufs_qcom_cap.desired_working_mode =\r\nUFS_QCOM_LIMIT_DESIRED_MODE;\r\nret = ufs_qcom_get_pwr_dev_param(&ufs_qcom_cap,\r\ndev_max_params,\r\ndev_req_params);\r\nif (ret) {\r\npr_err("%s: failed to determine capabilities\n",\r\n__func__);\r\ngoto out;\r\n}\r\nbreak;\r\ncase POST_CHANGE:\r\nif (!ufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\r\ndev_req_params->pwr_rx,\r\ndev_req_params->hs_rate)) {\r\ndev_err(hba->dev, "%s: ufs_qcom_cfg_timers() failed\n",\r\n__func__);\r\nret = -EINVAL;\r\n}\r\nval = ~(MAX_U32 << dev_req_params->lane_tx);\r\nres = ufs_qcom_phy_set_tx_lane_enable(phy, val);\r\nif (res) {\r\ndev_err(hba->dev, "%s: ufs_qcom_phy_set_tx_lane_enable() failed res = %d\n",\r\n__func__, res);\r\nret = res;\r\n}\r\nmemcpy(&host->dev_req_params,\r\ndev_req_params, sizeof(*dev_req_params));\r\nufs_qcom_update_bus_bw_vote(host);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic u32 ufs_qcom_get_ufs_hci_version(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nif (host->hw_ver.major == 0x1)\r\nreturn UFSHCI_VERSION_11;\r\nelse\r\nreturn UFSHCI_VERSION_20;\r\n}\r\nstatic void ufs_qcom_advertise_quirks(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nif (host->hw_ver.major == 0x01) {\r\nhba->quirks |= UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS\r\n| UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP\r\n| UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE;\r\nif (host->hw_ver.minor == 0x0001 && host->hw_ver.step == 0x0001)\r\nhba->quirks |= UFSHCD_QUIRK_BROKEN_INTR_AGGR;\r\n}\r\nif (host->hw_ver.major >= 0x2) {\r\nhba->quirks |= UFSHCD_QUIRK_BROKEN_LCC;\r\nhba->quirks |= UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION;\r\nif (!ufs_qcom_cap_qunipro(host))\r\nhba->quirks |= (UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS\r\n| UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE\r\n| UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP);\r\n}\r\n}\r\nstatic void ufs_qcom_set_caps(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nif (host->hw_ver.major >= 0x2)\r\nhost->caps = UFS_QCOM_CAP_QUNIPRO;\r\n}\r\nstatic int ufs_qcom_get_bus_vote(struct ufs_qcom_host *host,\r\nconst char *speed_mode)\r\n{\r\nstruct device *dev = host->hba->dev;\r\nstruct device_node *np = dev->of_node;\r\nint err;\r\nconst char *key = "qcom,bus-vector-names";\r\nif (!speed_mode) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (host->bus_vote.is_max_bw_needed && !!strcmp(speed_mode, "MIN"))\r\nerr = of_property_match_string(np, key, "MAX");\r\nelse\r\nerr = of_property_match_string(np, key, speed_mode);\r\nout:\r\nif (err < 0)\r\ndev_err(dev, "%s: Invalid %s mode %d\n",\r\n__func__, speed_mode, err);\r\nreturn err;\r\n}\r\nstatic int ufs_qcom_set_bus_vote(struct ufs_qcom_host *host, int vote)\r\n{\r\nint err = 0;\r\nif (vote != host->bus_vote.curr_vote)\r\nhost->bus_vote.curr_vote = vote;\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_get_speed_mode(struct ufs_pa_layer_attr *p, char *result)\r\n{\r\nint gear = max_t(u32, p->gear_rx, p->gear_tx);\r\nint lanes = max_t(u32, p->lane_rx, p->lane_tx);\r\nint pwr;\r\nif (!gear)\r\ngear = 1;\r\nif (!lanes)\r\nlanes = 1;\r\nif (!p->pwr_rx && !p->pwr_tx) {\r\npwr = SLOWAUTO_MODE;\r\nsnprintf(result, BUS_VECTOR_NAME_LEN, "MIN");\r\n} else if (p->pwr_rx == FAST_MODE || p->pwr_rx == FASTAUTO_MODE ||\r\np->pwr_tx == FAST_MODE || p->pwr_tx == FASTAUTO_MODE) {\r\npwr = FAST_MODE;\r\nsnprintf(result, BUS_VECTOR_NAME_LEN, "%s_R%s_G%d_L%d", "HS",\r\np->hs_rate == PA_HS_MODE_B ? "B" : "A", gear, lanes);\r\n} else {\r\npwr = SLOW_MODE;\r\nsnprintf(result, BUS_VECTOR_NAME_LEN, "%s_G%d_L%d",\r\n"PWM", gear, lanes);\r\n}\r\n}\r\nstatic int ufs_qcom_setup_clocks(struct ufs_hba *hba, bool on)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nint err = 0;\r\nint vote = 0;\r\nif (!host)\r\nreturn 0;\r\nif (on) {\r\nerr = ufs_qcom_phy_enable_iface_clk(host->generic_phy);\r\nif (err)\r\ngoto out;\r\nerr = ufs_qcom_phy_enable_ref_clk(host->generic_phy);\r\nif (err) {\r\ndev_err(hba->dev, "%s enable phy ref clock failed, err=%d\n",\r\n__func__, err);\r\nufs_qcom_phy_disable_iface_clk(host->generic_phy);\r\ngoto out;\r\n}\r\nufs_qcom_phy_enable_dev_ref_clk(host->generic_phy);\r\nvote = host->bus_vote.saved_vote;\r\nif (vote == host->bus_vote.min_bw_vote)\r\nufs_qcom_update_bus_bw_vote(host);\r\n} else {\r\nufs_qcom_phy_disable_iface_clk(host->generic_phy);\r\nif (!ufs_qcom_is_link_active(hba)) {\r\nufs_qcom_phy_disable_ref_clk(host->generic_phy);\r\nufs_qcom_phy_disable_dev_ref_clk(host->generic_phy);\r\n}\r\nvote = host->bus_vote.min_bw_vote;\r\n}\r\nerr = ufs_qcom_set_bus_vote(host, vote);\r\nif (err)\r\ndev_err(hba->dev, "%s: set bus vote failed %d\n",\r\n__func__, err);\r\nout:\r\nreturn err;\r\n}\r\nstatic ssize_t\r\nshow_ufs_to_mem_max_bus_bw(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ufs_hba *hba = dev_get_drvdata(dev);\r\nstruct ufs_qcom_host *host = hba->priv;\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n",\r\nhost->bus_vote.is_max_bw_needed);\r\n}\r\nstatic ssize_t\r\nstore_ufs_to_mem_max_bus_bw(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ufs_hba *hba = dev_get_drvdata(dev);\r\nstruct ufs_qcom_host *host = hba->priv;\r\nuint32_t value;\r\nif (!kstrtou32(buf, 0, &value)) {\r\nhost->bus_vote.is_max_bw_needed = !!value;\r\nufs_qcom_update_bus_bw_vote(host);\r\n}\r\nreturn count;\r\n}\r\nstatic int ufs_qcom_bus_register(struct ufs_qcom_host *host)\r\n{\r\nint err;\r\nstruct device *dev = host->hba->dev;\r\nstruct device_node *np = dev->of_node;\r\nerr = of_property_count_strings(np, "qcom,bus-vector-names");\r\nif (err < 0 ) {\r\ndev_err(dev, "%s: qcom,bus-vector-names not specified correctly %d\n",\r\n__func__, err);\r\ngoto out;\r\n}\r\nhost->bus_vote.min_bw_vote = ufs_qcom_get_bus_vote(host, "MIN");\r\nhost->bus_vote.max_bw_vote = ufs_qcom_get_bus_vote(host, "MAX");\r\nhost->bus_vote.max_bus_bw.show = show_ufs_to_mem_max_bus_bw;\r\nhost->bus_vote.max_bus_bw.store = store_ufs_to_mem_max_bus_bw;\r\nsysfs_attr_init(&host->bus_vote.max_bus_bw.attr);\r\nhost->bus_vote.max_bus_bw.attr.name = "max_bus_bw";\r\nhost->bus_vote.max_bus_bw.attr.mode = S_IRUGO | S_IWUSR;\r\nerr = device_create_file(dev, &host->bus_vote.max_bus_bw);\r\nout:\r\nreturn err;\r\n}\r\nstatic int get_android_boot_dev(char *str)\r\n{\r\nstrlcpy(android_boot_dev, str, ANDROID_BOOT_DEV_MAX);\r\nreturn 1;\r\n}\r\nstatic int ufs_qcom_init(struct ufs_hba *hba)\r\n{\r\nint err;\r\nstruct device *dev = hba->dev;\r\nstruct ufs_qcom_host *host;\r\nif (strlen(android_boot_dev) && strcmp(android_boot_dev, dev_name(dev)))\r\nreturn -ENODEV;\r\nhost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\r\nif (!host) {\r\nerr = -ENOMEM;\r\ndev_err(dev, "%s: no memory for qcom ufs host\n", __func__);\r\ngoto out;\r\n}\r\nhost->hba = hba;\r\nhba->priv = (void *)host;\r\nhost->generic_phy = devm_phy_get(dev, "ufsphy");\r\nif (IS_ERR(host->generic_phy)) {\r\nerr = PTR_ERR(host->generic_phy);\r\ndev_err(dev, "%s: PHY get failed %d\n", __func__, err);\r\ngoto out;\r\n}\r\nerr = ufs_qcom_bus_register(host);\r\nif (err)\r\ngoto out_host_free;\r\nufs_qcom_get_controller_revision(hba, &host->hw_ver.major,\r\n&host->hw_ver.minor, &host->hw_ver.step);\r\nufs_qcom_phy_save_controller_version(host->generic_phy,\r\nhost->hw_ver.major, host->hw_ver.minor, host->hw_ver.step);\r\nphy_init(host->generic_phy);\r\nerr = phy_power_on(host->generic_phy);\r\nif (err)\r\ngoto out_unregister_bus;\r\nerr = ufs_qcom_init_lane_clks(host);\r\nif (err)\r\ngoto out_disable_phy;\r\nufs_qcom_set_caps(hba);\r\nufs_qcom_advertise_quirks(hba);\r\nhba->caps |= UFSHCD_CAP_CLK_GATING | UFSHCD_CAP_CLK_SCALING;\r\nhba->caps |= UFSHCD_CAP_AUTO_BKOPS_SUSPEND;\r\nufs_qcom_setup_clocks(hba, true);\r\nif (hba->dev->id < MAX_UFS_QCOM_HOSTS)\r\nufs_qcom_hosts[hba->dev->id] = host;\r\ngoto out;\r\nout_disable_phy:\r\nphy_power_off(host->generic_phy);\r\nout_unregister_bus:\r\nphy_exit(host->generic_phy);\r\nout_host_free:\r\ndevm_kfree(dev, host);\r\nhba->priv = NULL;\r\nout:\r\nreturn err;\r\n}\r\nstatic void ufs_qcom_exit(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nufs_qcom_disable_lane_clks(host);\r\nphy_power_off(host->generic_phy);\r\n}\r\nstatic\r\nvoid ufs_qcom_clk_scale_notify(struct ufs_hba *hba)\r\n{\r\nstruct ufs_qcom_host *host = hba->priv;\r\nstruct ufs_pa_layer_attr *dev_req_params = &host->dev_req_params;\r\nif (!dev_req_params)\r\nreturn;\r\nufs_qcom_cfg_timers(hba, dev_req_params->gear_rx,\r\ndev_req_params->pwr_rx,\r\ndev_req_params->hs_rate);\r\n}
