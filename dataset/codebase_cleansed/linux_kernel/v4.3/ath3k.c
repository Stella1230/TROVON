static int ath3k_load_firmware(struct usb_device *udev,\r\nconst struct firmware *firmware)\r\n{\r\nu8 *send_buf;\r\nint err, pipe, len, size, sent = 0;\r\nint count = firmware->size;\r\nBT_DBG("udev %p", udev);\r\npipe = usb_sndctrlpipe(udev, 0);\r\nsend_buf = kmalloc(BULK_SIZE, GFP_KERNEL);\r\nif (!send_buf) {\r\nBT_ERR("Can't allocate memory chunk for firmware");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(send_buf, firmware->data, 20);\r\nerr = usb_control_msg(udev, pipe, USB_REQ_DFU_DNLOAD, USB_TYPE_VENDOR,\r\n0, 0, send_buf, 20, USB_CTRL_SET_TIMEOUT);\r\nif (err < 0) {\r\nBT_ERR("Can't change to loading configuration err");\r\ngoto error;\r\n}\r\nsent += 20;\r\ncount -= 20;\r\npipe = usb_sndbulkpipe(udev, 0x02);\r\nwhile (count) {\r\nusleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);\r\nsize = min_t(uint, count, BULK_SIZE);\r\nmemcpy(send_buf, firmware->data + sent, size);\r\nerr = usb_bulk_msg(udev, pipe, send_buf, size,\r\n&len, 3000);\r\nif (err || (len != size)) {\r\nBT_ERR("Error in firmware loading err = %d,"\r\n"len = %d, size = %d", err, len, size);\r\ngoto error;\r\n}\r\nsent += size;\r\ncount -= size;\r\n}\r\nerror:\r\nkfree(send_buf);\r\nreturn err;\r\n}\r\nstatic int ath3k_get_state(struct usb_device *udev, unsigned char *state)\r\n{\r\nint ret, pipe = 0;\r\nchar *buf;\r\nbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\npipe = usb_rcvctrlpipe(udev, 0);\r\nret = usb_control_msg(udev, pipe, ATH3K_GETSTATE,\r\nUSB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\r\nbuf, sizeof(*buf), USB_CTRL_SET_TIMEOUT);\r\n*state = *buf;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int ath3k_get_version(struct usb_device *udev,\r\nstruct ath3k_version *version)\r\n{\r\nint ret, pipe = 0;\r\nstruct ath3k_version *buf;\r\nconst int size = sizeof(*buf);\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\npipe = usb_rcvctrlpipe(udev, 0);\r\nret = usb_control_msg(udev, pipe, ATH3K_GETVERSION,\r\nUSB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\r\nbuf, size, USB_CTRL_SET_TIMEOUT);\r\nmemcpy(version, buf, size);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int ath3k_load_fwfile(struct usb_device *udev,\r\nconst struct firmware *firmware)\r\n{\r\nu8 *send_buf;\r\nint err, pipe, len, size, count, sent = 0;\r\nint ret;\r\ncount = firmware->size;\r\nsend_buf = kmalloc(BULK_SIZE, GFP_KERNEL);\r\nif (!send_buf) {\r\nBT_ERR("Can't allocate memory chunk for firmware");\r\nreturn -ENOMEM;\r\n}\r\nsize = min_t(uint, count, FW_HDR_SIZE);\r\nmemcpy(send_buf, firmware->data, size);\r\npipe = usb_sndctrlpipe(udev, 0);\r\nret = usb_control_msg(udev, pipe, ATH3K_DNLOAD,\r\nUSB_TYPE_VENDOR, 0, 0, send_buf,\r\nsize, USB_CTRL_SET_TIMEOUT);\r\nif (ret < 0) {\r\nBT_ERR("Can't change to loading configuration err");\r\nkfree(send_buf);\r\nreturn ret;\r\n}\r\nsent += size;\r\ncount -= size;\r\npipe = usb_sndbulkpipe(udev, 0x02);\r\nwhile (count) {\r\nusleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);\r\nsize = min_t(uint, count, BULK_SIZE);\r\nmemcpy(send_buf, firmware->data + sent, size);\r\nerr = usb_bulk_msg(udev, pipe, send_buf, size,\r\n&len, 3000);\r\nif (err || (len != size)) {\r\nBT_ERR("Error in firmware loading err = %d,"\r\n"len = %d, size = %d", err, len, size);\r\nkfree(send_buf);\r\nreturn err;\r\n}\r\nsent += size;\r\ncount -= size;\r\n}\r\nkfree(send_buf);\r\nreturn 0;\r\n}\r\nstatic int ath3k_switch_pid(struct usb_device *udev)\r\n{\r\nint pipe = 0;\r\npipe = usb_sndctrlpipe(udev, 0);\r\nreturn usb_control_msg(udev, pipe, USB_REG_SWITCH_VID_PID,\r\nUSB_TYPE_VENDOR, 0, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic int ath3k_set_normal_mode(struct usb_device *udev)\r\n{\r\nunsigned char fw_state;\r\nint pipe = 0, ret;\r\nret = ath3k_get_state(udev, &fw_state);\r\nif (ret < 0) {\r\nBT_ERR("Can't get state to change to normal mode err");\r\nreturn ret;\r\n}\r\nif ((fw_state & ATH3K_MODE_MASK) == ATH3K_NORMAL_MODE) {\r\nBT_DBG("firmware was already in normal mode");\r\nreturn 0;\r\n}\r\npipe = usb_sndctrlpipe(udev, 0);\r\nreturn usb_control_msg(udev, pipe, ATH3K_SET_NORMAL_MODE,\r\nUSB_TYPE_VENDOR, 0, 0,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\n}\r\nstatic int ath3k_load_patch(struct usb_device *udev)\r\n{\r\nunsigned char fw_state;\r\nchar filename[ATH3K_NAME_LEN] = {0};\r\nconst struct firmware *firmware;\r\nstruct ath3k_version fw_version;\r\n__u32 pt_rom_version, pt_build_version;\r\nint ret;\r\nret = ath3k_get_state(udev, &fw_state);\r\nif (ret < 0) {\r\nBT_ERR("Can't get state to change to load ram patch err");\r\nreturn ret;\r\n}\r\nif (fw_state & ATH3K_PATCH_UPDATE) {\r\nBT_DBG("Patch was already downloaded");\r\nreturn 0;\r\n}\r\nret = ath3k_get_version(udev, &fw_version);\r\nif (ret < 0) {\r\nBT_ERR("Can't get version to change to load ram patch err");\r\nreturn ret;\r\n}\r\nsnprintf(filename, ATH3K_NAME_LEN, "ar3k/AthrBT_0x%08x.dfu",\r\nle32_to_cpu(fw_version.rom_version));\r\nret = request_firmware(&firmware, filename, &udev->dev);\r\nif (ret < 0) {\r\nBT_ERR("Patch file not found %s", filename);\r\nreturn ret;\r\n}\r\npt_rom_version = get_unaligned_le32(firmware->data +\r\nfirmware->size - 8);\r\npt_build_version = get_unaligned_le32(firmware->data +\r\nfirmware->size - 4);\r\nif (pt_rom_version != le32_to_cpu(fw_version.rom_version) ||\r\npt_build_version <= le32_to_cpu(fw_version.build_version)) {\r\nBT_ERR("Patch file version did not match with firmware");\r\nrelease_firmware(firmware);\r\nreturn -EINVAL;\r\n}\r\nret = ath3k_load_fwfile(udev, firmware);\r\nrelease_firmware(firmware);\r\nreturn ret;\r\n}\r\nstatic int ath3k_load_syscfg(struct usb_device *udev)\r\n{\r\nunsigned char fw_state;\r\nchar filename[ATH3K_NAME_LEN] = {0};\r\nconst struct firmware *firmware;\r\nstruct ath3k_version fw_version;\r\nint clk_value, ret;\r\nret = ath3k_get_state(udev, &fw_state);\r\nif (ret < 0) {\r\nBT_ERR("Can't get state to change to load configuration err");\r\nreturn -EBUSY;\r\n}\r\nret = ath3k_get_version(udev, &fw_version);\r\nif (ret < 0) {\r\nBT_ERR("Can't get version to change to load ram patch err");\r\nreturn ret;\r\n}\r\nswitch (fw_version.ref_clock) {\r\ncase ATH3K_XTAL_FREQ_26M:\r\nclk_value = 26;\r\nbreak;\r\ncase ATH3K_XTAL_FREQ_40M:\r\nclk_value = 40;\r\nbreak;\r\ncase ATH3K_XTAL_FREQ_19P2:\r\nclk_value = 19;\r\nbreak;\r\ndefault:\r\nclk_value = 0;\r\nbreak;\r\n}\r\nsnprintf(filename, ATH3K_NAME_LEN, "ar3k/ramps_0x%08x_%d%s",\r\nle32_to_cpu(fw_version.rom_version), clk_value, ".dfu");\r\nret = request_firmware(&firmware, filename, &udev->dev);\r\nif (ret < 0) {\r\nBT_ERR("Configuration file not found %s", filename);\r\nreturn ret;\r\n}\r\nret = ath3k_load_fwfile(udev, firmware);\r\nrelease_firmware(firmware);\r\nreturn ret;\r\n}\r\nstatic int ath3k_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nconst struct firmware *firmware;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint ret;\r\nBT_DBG("intf %p id %p", intf, id);\r\nif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn -ENODEV;\r\nif (!id->driver_info) {\r\nconst struct usb_device_id *match;\r\nmatch = usb_match_id(intf, ath3k_blist_tbl);\r\nif (match)\r\nid = match;\r\n}\r\nif (id->driver_info & BTUSB_ATH3012) {\r\nif (le16_to_cpu(udev->descriptor.bcdDevice) > 0x0001)\r\nreturn -ENODEV;\r\nret = ath3k_load_patch(udev);\r\nif (ret < 0) {\r\nBT_ERR("Loading patch file failed");\r\nreturn ret;\r\n}\r\nret = ath3k_load_syscfg(udev);\r\nif (ret < 0) {\r\nBT_ERR("Loading sysconfig file failed");\r\nreturn ret;\r\n}\r\nret = ath3k_set_normal_mode(udev);\r\nif (ret < 0) {\r\nBT_ERR("Set normal mode failed");\r\nreturn ret;\r\n}\r\nath3k_switch_pid(udev);\r\nreturn 0;\r\n}\r\nret = request_firmware(&firmware, ATH3K_FIRMWARE, &udev->dev);\r\nif (ret < 0) {\r\nif (ret == -ENOENT)\r\nBT_ERR("Firmware file \"%s\" not found",\r\nATH3K_FIRMWARE);\r\nelse\r\nBT_ERR("Firmware file \"%s\" request failed (err=%d)",\r\nATH3K_FIRMWARE, ret);\r\nreturn ret;\r\n}\r\nret = ath3k_load_firmware(udev, firmware);\r\nrelease_firmware(firmware);\r\nreturn ret;\r\n}\r\nstatic void ath3k_disconnect(struct usb_interface *intf)\r\n{\r\nBT_DBG("ath3k_disconnect intf %p", intf);\r\n}
