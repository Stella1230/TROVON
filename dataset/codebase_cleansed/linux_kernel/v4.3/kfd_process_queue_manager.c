static inline struct process_queue_node *get_queue_by_qid(\r\nstruct process_queue_manager *pqm, unsigned int qid)\r\n{\r\nstruct process_queue_node *pqn;\r\nBUG_ON(!pqm);\r\nlist_for_each_entry(pqn, &pqm->queues, process_queue_list) {\r\nif (pqn->q && pqn->q->properties.queue_id == qid)\r\nreturn pqn;\r\nif (pqn->kq && pqn->kq->queue->properties.queue_id == qid)\r\nreturn pqn;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int find_available_queue_slot(struct process_queue_manager *pqm,\r\nunsigned int *qid)\r\n{\r\nunsigned long found;\r\nBUG_ON(!pqm || !qid);\r\npr_debug("kfd: in %s\n", __func__);\r\nfound = find_first_zero_bit(pqm->queue_slot_bitmap,\r\nKFD_MAX_NUM_OF_QUEUES_PER_PROCESS);\r\npr_debug("kfd: the new slot id %lu\n", found);\r\nif (found >= KFD_MAX_NUM_OF_QUEUES_PER_PROCESS) {\r\npr_info("amdkfd: Can not open more queues for process with pasid %d\n",\r\npqm->process->pasid);\r\nreturn -ENOMEM;\r\n}\r\nset_bit(found, pqm->queue_slot_bitmap);\r\n*qid = found;\r\nreturn 0;\r\n}\r\nint pqm_init(struct process_queue_manager *pqm, struct kfd_process *p)\r\n{\r\nBUG_ON(!pqm);\r\nINIT_LIST_HEAD(&pqm->queues);\r\npqm->queue_slot_bitmap =\r\nkzalloc(DIV_ROUND_UP(KFD_MAX_NUM_OF_QUEUES_PER_PROCESS,\r\nBITS_PER_BYTE), GFP_KERNEL);\r\nif (pqm->queue_slot_bitmap == NULL)\r\nreturn -ENOMEM;\r\npqm->process = p;\r\nreturn 0;\r\n}\r\nvoid pqm_uninit(struct process_queue_manager *pqm)\r\n{\r\nint retval;\r\nstruct process_queue_node *pqn, *next;\r\nBUG_ON(!pqm);\r\npr_debug("In func %s\n", __func__);\r\nlist_for_each_entry_safe(pqn, next, &pqm->queues, process_queue_list) {\r\nretval = pqm_destroy_queue(\r\npqm,\r\n(pqn->q != NULL) ?\r\npqn->q->properties.queue_id :\r\npqn->kq->queue->properties.queue_id);\r\nif (retval != 0) {\r\npr_err("kfd: failed to destroy queue\n");\r\nreturn;\r\n}\r\n}\r\nkfree(pqm->queue_slot_bitmap);\r\npqm->queue_slot_bitmap = NULL;\r\n}\r\nstatic int create_cp_queue(struct process_queue_manager *pqm,\r\nstruct kfd_dev *dev, struct queue **q,\r\nstruct queue_properties *q_properties,\r\nstruct file *f, unsigned int qid)\r\n{\r\nint retval;\r\nretval = 0;\r\nq_properties->doorbell_ptr = NULL;\r\nq_properties->doorbell_off =\r\nkfd_queue_id_to_doorbell(dev, pqm->process, qid);\r\nq_properties->vmid = 0;\r\nq_properties->queue_id = qid;\r\nretval = init_queue(q, *q_properties);\r\nif (retval != 0)\r\ngoto err_init_queue;\r\n(*q)->device = dev;\r\n(*q)->process = pqm->process;\r\npr_debug("kfd: PQM After init queue");\r\nreturn retval;\r\nerr_init_queue:\r\nreturn retval;\r\n}\r\nint pqm_create_queue(struct process_queue_manager *pqm,\r\nstruct kfd_dev *dev,\r\nstruct file *f,\r\nstruct queue_properties *properties,\r\nunsigned int flags,\r\nenum kfd_queue_type type,\r\nunsigned int *qid)\r\n{\r\nint retval;\r\nstruct kfd_process_device *pdd;\r\nstruct queue_properties q_properties;\r\nstruct queue *q;\r\nstruct process_queue_node *pqn;\r\nstruct kernel_queue *kq;\r\nint num_queues = 0;\r\nstruct queue *cur;\r\nBUG_ON(!pqm || !dev || !properties || !qid);\r\nmemset(&q_properties, 0, sizeof(struct queue_properties));\r\nmemcpy(&q_properties, properties, sizeof(struct queue_properties));\r\nq = NULL;\r\nkq = NULL;\r\npdd = kfd_get_process_device_data(dev, pqm->process);\r\nif (!pdd) {\r\npr_err("Process device data doesn't exist\n");\r\nreturn -1;\r\n}\r\nif ((pdd->qpd.is_debug) ||\r\n(type == KFD_QUEUE_TYPE_DIQ)) {\r\nlist_for_each_entry(cur, &pdd->qpd.queues_list, list)\r\nnum_queues++;\r\nif (num_queues >= dev->device_info->max_no_of_hqd/2)\r\nreturn (-ENOSPC);\r\n}\r\nretval = find_available_queue_slot(pqm, qid);\r\nif (retval != 0)\r\nreturn retval;\r\nif (list_empty(&pqm->queues)) {\r\npdd->qpd.pqm = pqm;\r\ndev->dqm->ops.register_process(dev->dqm, &pdd->qpd);\r\n}\r\npqn = kzalloc(sizeof(struct process_queue_node), GFP_KERNEL);\r\nif (!pqn) {\r\nretval = -ENOMEM;\r\ngoto err_allocate_pqn;\r\n}\r\nswitch (type) {\r\ncase KFD_QUEUE_TYPE_SDMA:\r\ncase KFD_QUEUE_TYPE_COMPUTE:\r\nif ((sched_policy == KFD_SCHED_POLICY_HWS_NO_OVERSUBSCRIPTION) &&\r\n((dev->dqm->processes_count >= VMID_PER_DEVICE) ||\r\n(dev->dqm->queue_count >= PIPE_PER_ME_CP_SCHEDULING * QUEUES_PER_PIPE))) {\r\npr_err("kfd: over-subscription is not allowed in radeon_kfd.sched_policy == 1\n");\r\nretval = -EPERM;\r\ngoto err_create_queue;\r\n}\r\nretval = create_cp_queue(pqm, dev, &q, &q_properties, f, *qid);\r\nif (retval != 0)\r\ngoto err_create_queue;\r\npqn->q = q;\r\npqn->kq = NULL;\r\nretval = dev->dqm->ops.create_queue(dev->dqm, q, &pdd->qpd,\r\n&q->properties.vmid);\r\npr_debug("DQM returned %d for create_queue\n", retval);\r\nprint_queue(q);\r\nbreak;\r\ncase KFD_QUEUE_TYPE_DIQ:\r\nkq = kernel_queue_init(dev, KFD_QUEUE_TYPE_DIQ);\r\nif (kq == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_create_queue;\r\n}\r\nkq->queue->properties.queue_id = *qid;\r\npqn->kq = kq;\r\npqn->q = NULL;\r\nretval = dev->dqm->ops.create_kernel_queue(dev->dqm,\r\nkq, &pdd->qpd);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (retval != 0) {\r\npr_debug("Error dqm create queue\n");\r\ngoto err_create_queue;\r\n}\r\npr_debug("kfd: PQM After DQM create queue\n");\r\nlist_add(&pqn->process_queue_list, &pqm->queues);\r\nif (q) {\r\n*properties = q->properties;\r\npr_debug("kfd: PQM done creating queue\n");\r\nprint_queue_properties(properties);\r\n}\r\nreturn retval;\r\nerr_create_queue:\r\nkfree(pqn);\r\nerr_allocate_pqn:\r\nclear_bit(*qid, pqm->queue_slot_bitmap);\r\nif (list_empty(&pqm->queues))\r\ndev->dqm->ops.unregister_process(dev->dqm, &pdd->qpd);\r\nreturn retval;\r\n}\r\nint pqm_destroy_queue(struct process_queue_manager *pqm, unsigned int qid)\r\n{\r\nstruct process_queue_node *pqn;\r\nstruct kfd_process_device *pdd;\r\nstruct device_queue_manager *dqm;\r\nstruct kfd_dev *dev;\r\nint retval;\r\ndqm = NULL;\r\nBUG_ON(!pqm);\r\nretval = 0;\r\npr_debug("kfd: In Func %s\n", __func__);\r\npqn = get_queue_by_qid(pqm, qid);\r\nif (pqn == NULL) {\r\npr_err("kfd: queue id does not match any known queue\n");\r\nreturn -EINVAL;\r\n}\r\ndev = NULL;\r\nif (pqn->kq)\r\ndev = pqn->kq->dev;\r\nif (pqn->q)\r\ndev = pqn->q->device;\r\nBUG_ON(!dev);\r\npdd = kfd_get_process_device_data(dev, pqm->process);\r\nif (!pdd) {\r\npr_err("Process device data doesn't exist\n");\r\nreturn -1;\r\n}\r\nif (pqn->kq) {\r\ndqm = pqn->kq->dev->dqm;\r\ndqm->ops.destroy_kernel_queue(dqm, pqn->kq, &pdd->qpd);\r\nkernel_queue_uninit(pqn->kq);\r\n}\r\nif (pqn->q) {\r\ndqm = pqn->q->device->dqm;\r\nretval = dqm->ops.destroy_queue(dqm, &pdd->qpd, pqn->q);\r\nif (retval != 0)\r\nreturn retval;\r\nuninit_queue(pqn->q);\r\n}\r\nlist_del(&pqn->process_queue_list);\r\nkfree(pqn);\r\nclear_bit(qid, pqm->queue_slot_bitmap);\r\nif (list_empty(&pqm->queues))\r\ndqm->ops.unregister_process(dqm, &pdd->qpd);\r\nreturn retval;\r\n}\r\nint pqm_update_queue(struct process_queue_manager *pqm, unsigned int qid,\r\nstruct queue_properties *p)\r\n{\r\nint retval;\r\nstruct process_queue_node *pqn;\r\nBUG_ON(!pqm);\r\npqn = get_queue_by_qid(pqm, qid);\r\nif (!pqn) {\r\npr_debug("amdkfd: No queue %d exists for update operation\n",\r\nqid);\r\nreturn -EFAULT;\r\n}\r\npqn->q->properties.queue_address = p->queue_address;\r\npqn->q->properties.queue_size = p->queue_size;\r\npqn->q->properties.queue_percent = p->queue_percent;\r\npqn->q->properties.priority = p->priority;\r\nretval = pqn->q->device->dqm->ops.update_queue(pqn->q->device->dqm,\r\npqn->q);\r\nif (retval != 0)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstruct kernel_queue *pqm_get_kernel_queue(\r\nstruct process_queue_manager *pqm,\r\nunsigned int qid)\r\n{\r\nstruct process_queue_node *pqn;\r\nBUG_ON(!pqm);\r\npqn = get_queue_by_qid(pqm, qid);\r\nif (pqn && pqn->kq)\r\nreturn pqn->kq;\r\nreturn NULL;\r\n}
