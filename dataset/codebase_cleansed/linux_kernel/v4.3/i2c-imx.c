static inline int is_imx1_i2c(struct imx_i2c_struct *i2c_imx)\r\n{\r\nreturn i2c_imx->hwdata->devtype == IMX1_I2C;\r\n}\r\nstatic inline void imx_i2c_write_reg(unsigned int val,\r\nstruct imx_i2c_struct *i2c_imx, unsigned int reg)\r\n{\r\nwriteb(val, i2c_imx->base + (reg << i2c_imx->hwdata->regshift));\r\n}\r\nstatic inline unsigned char imx_i2c_read_reg(struct imx_i2c_struct *i2c_imx,\r\nunsigned int reg)\r\n{\r\nreturn readb(i2c_imx->base + (reg << i2c_imx->hwdata->regshift));\r\n}\r\nstatic void i2c_imx_dma_request(struct imx_i2c_struct *i2c_imx,\r\ndma_addr_t phy_addr)\r\n{\r\nstruct imx_i2c_dma *dma;\r\nstruct dma_slave_config dma_sconfig;\r\nstruct device *dev = &i2c_imx->adapter.dev;\r\nint ret;\r\ndma = devm_kzalloc(dev, sizeof(*dma), GFP_KERNEL);\r\nif (!dma)\r\nreturn;\r\ndma->chan_tx = dma_request_slave_channel(dev, "tx");\r\nif (!dma->chan_tx) {\r\ndev_dbg(dev, "can't request DMA tx channel\n");\r\ngoto fail_al;\r\n}\r\ndma_sconfig.dst_addr = phy_addr +\r\n(IMX_I2C_I2DR << i2c_imx->hwdata->regshift);\r\ndma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma_sconfig.dst_maxburst = 1;\r\ndma_sconfig.direction = DMA_MEM_TO_DEV;\r\nret = dmaengine_slave_config(dma->chan_tx, &dma_sconfig);\r\nif (ret < 0) {\r\ndev_dbg(dev, "can't configure tx channel\n");\r\ngoto fail_tx;\r\n}\r\ndma->chan_rx = dma_request_slave_channel(dev, "rx");\r\nif (!dma->chan_rx) {\r\ndev_dbg(dev, "can't request DMA rx channel\n");\r\ngoto fail_tx;\r\n}\r\ndma_sconfig.src_addr = phy_addr +\r\n(IMX_I2C_I2DR << i2c_imx->hwdata->regshift);\r\ndma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma_sconfig.src_maxburst = 1;\r\ndma_sconfig.direction = DMA_DEV_TO_MEM;\r\nret = dmaengine_slave_config(dma->chan_rx, &dma_sconfig);\r\nif (ret < 0) {\r\ndev_dbg(dev, "can't configure rx channel\n");\r\ngoto fail_rx;\r\n}\r\ni2c_imx->dma = dma;\r\ninit_completion(&dma->cmd_complete);\r\ndev_info(dev, "using %s (tx) and %s (rx) for DMA transfers\n",\r\ndma_chan_name(dma->chan_tx), dma_chan_name(dma->chan_rx));\r\nreturn;\r\nfail_rx:\r\ndma_release_channel(dma->chan_rx);\r\nfail_tx:\r\ndma_release_channel(dma->chan_tx);\r\nfail_al:\r\ndevm_kfree(dev, dma);\r\ndev_info(dev, "can't use DMA\n");\r\n}\r\nstatic void i2c_imx_dma_callback(void *arg)\r\n{\r\nstruct imx_i2c_struct *i2c_imx = (struct imx_i2c_struct *)arg;\r\nstruct imx_i2c_dma *dma = i2c_imx->dma;\r\ndma_unmap_single(dma->chan_using->device->dev, dma->dma_buf,\r\ndma->dma_len, dma->dma_data_dir);\r\ncomplete(&dma->cmd_complete);\r\n}\r\nstatic int i2c_imx_dma_xfer(struct imx_i2c_struct *i2c_imx,\r\nstruct i2c_msg *msgs)\r\n{\r\nstruct imx_i2c_dma *dma = i2c_imx->dma;\r\nstruct dma_async_tx_descriptor *txdesc;\r\nstruct device *dev = &i2c_imx->adapter.dev;\r\nstruct device *chan_dev = dma->chan_using->device->dev;\r\ndma->dma_buf = dma_map_single(chan_dev, msgs->buf,\r\ndma->dma_len, dma->dma_data_dir);\r\nif (dma_mapping_error(chan_dev, dma->dma_buf)) {\r\ndev_err(dev, "DMA mapping failed\n");\r\ngoto err_map;\r\n}\r\ntxdesc = dmaengine_prep_slave_single(dma->chan_using, dma->dma_buf,\r\ndma->dma_len, dma->dma_transfer_dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc) {\r\ndev_err(dev, "Not able to get desc for DMA xfer\n");\r\ngoto err_desc;\r\n}\r\ntxdesc->callback = i2c_imx_dma_callback;\r\ntxdesc->callback_param = i2c_imx;\r\nif (dma_submit_error(dmaengine_submit(txdesc))) {\r\ndev_err(dev, "DMA submit failed\n");\r\ngoto err_submit;\r\n}\r\ndma_async_issue_pending(dma->chan_using);\r\nreturn 0;\r\nerr_submit:\r\nerr_desc:\r\ndma_unmap_single(chan_dev, dma->dma_buf,\r\ndma->dma_len, dma->dma_data_dir);\r\nerr_map:\r\nreturn -EINVAL;\r\n}\r\nstatic void i2c_imx_dma_free(struct imx_i2c_struct *i2c_imx)\r\n{\r\nstruct imx_i2c_dma *dma = i2c_imx->dma;\r\ndma->dma_buf = 0;\r\ndma->dma_len = 0;\r\ndma_release_channel(dma->chan_tx);\r\ndma->chan_tx = NULL;\r\ndma_release_channel(dma->chan_rx);\r\ndma->chan_rx = NULL;\r\ndma->chan_using = NULL;\r\n}\r\nstatic int i2c_imx_bus_busy(struct imx_i2c_struct *i2c_imx, int for_busy)\r\n{\r\nunsigned long orig_jiffies = jiffies;\r\nunsigned int temp;\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);\r\nwhile (1) {\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\r\nif (temp & I2SR_IAL) {\r\ntemp &= ~I2SR_IAL;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);\r\nreturn -EAGAIN;\r\n}\r\nif (for_busy && (temp & I2SR_IBB))\r\nbreak;\r\nif (!for_busy && !(temp & I2SR_IBB))\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies + msecs_to_jiffies(500))) {\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> I2C bus is busy\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_imx_trx_complete(struct imx_i2c_struct *i2c_imx)\r\n{\r\nwait_event_timeout(i2c_imx->queue, i2c_imx->i2csr & I2SR_IIF, HZ / 10);\r\nif (unlikely(!(i2c_imx->i2csr & I2SR_IIF))) {\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> Timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> TRX complete\n", __func__);\r\ni2c_imx->i2csr = 0;\r\nreturn 0;\r\n}\r\nstatic int i2c_imx_acked(struct imx_i2c_struct *i2c_imx)\r\n{\r\nif (imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR) & I2SR_RXAK) {\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> No ACK\n", __func__);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> ACK received\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void i2c_imx_set_clk(struct imx_i2c_struct *i2c_imx)\r\n{\r\nstruct imx_i2c_clk_pair *i2c_clk_div = i2c_imx->hwdata->clk_div;\r\nunsigned int i2c_clk_rate;\r\nunsigned int div;\r\nint i;\r\ni2c_clk_rate = clk_get_rate(i2c_imx->clk);\r\nif (i2c_imx->cur_clk == i2c_clk_rate)\r\nreturn;\r\ni2c_imx->cur_clk = i2c_clk_rate;\r\ndiv = (i2c_clk_rate + i2c_imx->bitrate - 1) / i2c_imx->bitrate;\r\nif (div < i2c_clk_div[0].div)\r\ni = 0;\r\nelse if (div > i2c_clk_div[i2c_imx->hwdata->ndivs - 1].div)\r\ni = i2c_imx->hwdata->ndivs - 1;\r\nelse\r\nfor (i = 0; i2c_clk_div[i].div < div; i++)\r\n;\r\ni2c_imx->ifdr = i2c_clk_div[i].val;\r\ni2c_imx->disable_delay = (500000U * i2c_clk_div[i].div\r\n+ (i2c_clk_rate / 2) - 1) / (i2c_clk_rate / 2);\r\n#ifdef CONFIG_I2C_DEBUG_BUS\r\ndev_dbg(&i2c_imx->adapter.dev, "I2C_CLK=%d, REQ DIV=%d\n",\r\ni2c_clk_rate, div);\r\ndev_dbg(&i2c_imx->adapter.dev, "IFDR[IC]=0x%x, REAL DIV=%d\n",\r\ni2c_clk_div[i].val, i2c_clk_div[i].div);\r\n#endif\r\n}\r\nstatic int i2c_imx_start(struct imx_i2c_struct *i2c_imx)\r\n{\r\nunsigned int temp = 0;\r\nint result;\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);\r\ni2c_imx_set_clk(i2c_imx);\r\nresult = clk_prepare_enable(i2c_imx->clk);\r\nif (result)\r\nreturn result;\r\nimx_i2c_write_reg(i2c_imx->ifdr, i2c_imx, IMX_I2C_IFDR);\r\nimx_i2c_write_reg(i2c_imx->hwdata->i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);\r\nimx_i2c_write_reg(i2c_imx->hwdata->i2cr_ien_opcode, i2c_imx, IMX_I2C_I2CR);\r\nudelay(50);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp |= I2CR_MSTA;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nresult = i2c_imx_bus_busy(i2c_imx, 1);\r\nif (result)\r\nreturn result;\r\ni2c_imx->stopped = 0;\r\ntemp |= I2CR_IIEN | I2CR_MTX | I2CR_TXAK;\r\ntemp &= ~I2CR_DMAEN;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nreturn result;\r\n}\r\nstatic void i2c_imx_stop(struct imx_i2c_struct *i2c_imx)\r\n{\r\nunsigned int temp = 0;\r\nif (!i2c_imx->stopped) {\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp &= ~(I2CR_MSTA | I2CR_MTX);\r\nif (i2c_imx->dma)\r\ntemp &= ~I2CR_DMAEN;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\n}\r\nif (is_imx1_i2c(i2c_imx)) {\r\nudelay(i2c_imx->disable_delay);\r\n}\r\nif (!i2c_imx->stopped) {\r\ni2c_imx_bus_busy(i2c_imx, 0);\r\ni2c_imx->stopped = 1;\r\n}\r\ntemp = i2c_imx->hwdata->i2cr_ien_opcode ^ I2CR_IEN,\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nclk_disable_unprepare(i2c_imx->clk);\r\n}\r\nstatic irqreturn_t i2c_imx_isr(int irq, void *dev_id)\r\n{\r\nstruct imx_i2c_struct *i2c_imx = dev_id;\r\nunsigned int temp;\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\r\nif (temp & I2SR_IIF) {\r\ni2c_imx->i2csr = temp;\r\ntemp &= ~I2SR_IIF;\r\ntemp |= (i2c_imx->hwdata->i2sr_clr_opcode & I2SR_IIF);\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2SR);\r\nwake_up(&i2c_imx->queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int i2c_imx_dma_write(struct imx_i2c_struct *i2c_imx,\r\nstruct i2c_msg *msgs)\r\n{\r\nint result;\r\nunsigned long time_left;\r\nunsigned int temp = 0;\r\nunsigned long orig_jiffies = jiffies;\r\nstruct imx_i2c_dma *dma = i2c_imx->dma;\r\nstruct device *dev = &i2c_imx->adapter.dev;\r\ndma->chan_using = dma->chan_tx;\r\ndma->dma_transfer_dir = DMA_MEM_TO_DEV;\r\ndma->dma_data_dir = DMA_TO_DEVICE;\r\ndma->dma_len = msgs->len - 1;\r\nresult = i2c_imx_dma_xfer(i2c_imx, msgs);\r\nif (result)\r\nreturn result;\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp |= I2CR_DMAEN;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nimx_i2c_write_reg(msgs->addr << 1, i2c_imx, IMX_I2C_I2DR);\r\nreinit_completion(&i2c_imx->dma->cmd_complete);\r\ntime_left = wait_for_completion_timeout(\r\n&i2c_imx->dma->cmd_complete,\r\nmsecs_to_jiffies(DMA_TIMEOUT));\r\nif (time_left == 0) {\r\ndmaengine_terminate_all(dma->chan_using);\r\nreturn -ETIMEDOUT;\r\n}\r\nwhile (1) {\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\r\nif (temp & I2SR_ICF)\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies +\r\nmsecs_to_jiffies(DMA_TIMEOUT))) {\r\ndev_dbg(dev, "<%s> Timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule();\r\n}\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp &= ~I2CR_DMAEN;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nimx_i2c_write_reg(msgs->buf[msgs->len-1],\r\ni2c_imx, IMX_I2C_I2DR);\r\nresult = i2c_imx_trx_complete(i2c_imx);\r\nif (result)\r\nreturn result;\r\nreturn i2c_imx_acked(i2c_imx);\r\n}\r\nstatic int i2c_imx_dma_read(struct imx_i2c_struct *i2c_imx,\r\nstruct i2c_msg *msgs, bool is_lastmsg)\r\n{\r\nint result;\r\nunsigned long time_left;\r\nunsigned int temp;\r\nunsigned long orig_jiffies = jiffies;\r\nstruct imx_i2c_dma *dma = i2c_imx->dma;\r\nstruct device *dev = &i2c_imx->adapter.dev;\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp |= I2CR_DMAEN;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\ndma->chan_using = dma->chan_rx;\r\ndma->dma_transfer_dir = DMA_DEV_TO_MEM;\r\ndma->dma_data_dir = DMA_FROM_DEVICE;\r\ndma->dma_len = msgs->len - 2;\r\nresult = i2c_imx_dma_xfer(i2c_imx, msgs);\r\nif (result)\r\nreturn result;\r\nreinit_completion(&i2c_imx->dma->cmd_complete);\r\ntime_left = wait_for_completion_timeout(\r\n&i2c_imx->dma->cmd_complete,\r\nmsecs_to_jiffies(DMA_TIMEOUT));\r\nif (time_left == 0) {\r\ndmaengine_terminate_all(dma->chan_using);\r\nreturn -ETIMEDOUT;\r\n}\r\nwhile (1) {\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\r\nif (temp & I2SR_ICF)\r\nbreak;\r\nif (time_after(jiffies, orig_jiffies +\r\nmsecs_to_jiffies(DMA_TIMEOUT))) {\r\ndev_dbg(dev, "<%s> Timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule();\r\n}\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp &= ~I2CR_DMAEN;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp |= I2CR_TXAK;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nmsgs->buf[msgs->len-2] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\r\nresult = i2c_imx_trx_complete(i2c_imx);\r\nif (result)\r\nreturn result;\r\nif (is_lastmsg) {\r\ndev_dbg(dev, "<%s> clear MSTA\n", __func__);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp &= ~(I2CR_MSTA | I2CR_MTX);\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\ni2c_imx_bus_busy(i2c_imx, 0);\r\ni2c_imx->stopped = 1;\r\n} else {\r\ntemp = readb(i2c_imx->base + IMX_I2C_I2CR);\r\ntemp |= I2CR_MTX;\r\nwriteb(temp, i2c_imx->base + IMX_I2C_I2CR);\r\n}\r\nmsgs->buf[msgs->len-1] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\r\nreturn 0;\r\n}\r\nstatic int i2c_imx_write(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)\r\n{\r\nint i, result;\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> write slave address: addr=0x%x\n",\r\n__func__, msgs->addr << 1);\r\nimx_i2c_write_reg(msgs->addr << 1, i2c_imx, IMX_I2C_I2DR);\r\nresult = i2c_imx_trx_complete(i2c_imx);\r\nif (result)\r\nreturn result;\r\nresult = i2c_imx_acked(i2c_imx);\r\nif (result)\r\nreturn result;\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> write data\n", __func__);\r\nfor (i = 0; i < msgs->len; i++) {\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> write byte: B%d=0x%X\n",\r\n__func__, i, msgs->buf[i]);\r\nimx_i2c_write_reg(msgs->buf[i], i2c_imx, IMX_I2C_I2DR);\r\nresult = i2c_imx_trx_complete(i2c_imx);\r\nif (result)\r\nreturn result;\r\nresult = i2c_imx_acked(i2c_imx);\r\nif (result)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs, bool is_lastmsg)\r\n{\r\nint i, result;\r\nunsigned int temp;\r\nint block_data = msgs->flags & I2C_M_RECV_LEN;\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> write slave address: addr=0x%x\n",\r\n__func__, (msgs->addr << 1) | 0x01);\r\nimx_i2c_write_reg((msgs->addr << 1) | 0x01, i2c_imx, IMX_I2C_I2DR);\r\nresult = i2c_imx_trx_complete(i2c_imx);\r\nif (result)\r\nreturn result;\r\nresult = i2c_imx_acked(i2c_imx);\r\nif (result)\r\nreturn result;\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> setup bus\n", __func__);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp &= ~I2CR_MTX;\r\nif ((msgs->len - 1) || block_data)\r\ntemp &= ~I2CR_TXAK;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nimx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> read data\n", __func__);\r\nif (i2c_imx->dma && msgs->len >= DMA_THRESHOLD && !block_data)\r\nreturn i2c_imx_dma_read(i2c_imx, msgs, is_lastmsg);\r\nfor (i = 0; i < msgs->len; i++) {\r\nu8 len = 0;\r\nresult = i2c_imx_trx_complete(i2c_imx);\r\nif (result)\r\nreturn result;\r\nif ((!i) && block_data) {\r\nlen = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\r\nif ((len == 0) || (len > I2C_SMBUS_BLOCK_MAX))\r\nreturn -EPROTO;\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> read length: 0x%X\n",\r\n__func__, len);\r\nmsgs->len += len;\r\n}\r\nif (i == (msgs->len - 1)) {\r\nif (is_lastmsg) {\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> clear MSTA\n", __func__);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp &= ~(I2CR_MSTA | I2CR_MTX);\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\ni2c_imx_bus_busy(i2c_imx, 0);\r\ni2c_imx->stopped = 1;\r\n} else {\r\ntemp = readb(i2c_imx->base + IMX_I2C_I2CR);\r\ntemp |= I2CR_MTX;\r\nwriteb(temp, i2c_imx->base + IMX_I2C_I2CR);\r\n}\r\n} else if (i == (msgs->len - 2)) {\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> set TXAK\n", __func__);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp |= I2CR_TXAK;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\n}\r\nif ((!i) && block_data)\r\nmsgs->buf[0] = len;\r\nelse\r\nmsgs->buf[i] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> read byte: B%d=0x%X\n",\r\n__func__, i, msgs->buf[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_imx_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nunsigned int i, temp;\r\nint result;\r\nbool is_lastmsg = false;\r\nstruct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s>\n", __func__);\r\nresult = i2c_imx_start(i2c_imx);\r\nif (result)\r\ngoto fail0;\r\nfor (i = 0; i < num; i++) {\r\nif (i == num - 1)\r\nis_lastmsg = true;\r\nif (i) {\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> repeated start\n", __func__);\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ntemp |= I2CR_RSTA;\r\nimx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);\r\nresult = i2c_imx_bus_busy(i2c_imx, 1);\r\nif (result)\r\ngoto fail0;\r\n}\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> transfer message: %d\n", __func__, i);\r\n#ifdef CONFIG_I2C_DEBUG_BUS\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> CONTROL: IEN=%d, IIEN=%d, MSTA=%d, MTX=%d, TXAK=%d, RSTA=%d\n",\r\n__func__,\r\n(temp & I2CR_IEN ? 1 : 0), (temp & I2CR_IIEN ? 1 : 0),\r\n(temp & I2CR_MSTA ? 1 : 0), (temp & I2CR_MTX ? 1 : 0),\r\n(temp & I2CR_TXAK ? 1 : 0), (temp & I2CR_RSTA ? 1 : 0));\r\ntemp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);\r\ndev_dbg(&i2c_imx->adapter.dev,\r\n"<%s> STATUS: ICF=%d, IAAS=%d, IBB=%d, IAL=%d, SRW=%d, IIF=%d, RXAK=%d\n",\r\n__func__,\r\n(temp & I2SR_ICF ? 1 : 0), (temp & I2SR_IAAS ? 1 : 0),\r\n(temp & I2SR_IBB ? 1 : 0), (temp & I2SR_IAL ? 1 : 0),\r\n(temp & I2SR_SRW ? 1 : 0), (temp & I2SR_IIF ? 1 : 0),\r\n(temp & I2SR_RXAK ? 1 : 0));\r\n#endif\r\nif (msgs[i].flags & I2C_M_RD)\r\nresult = i2c_imx_read(i2c_imx, &msgs[i], is_lastmsg);\r\nelse {\r\nif (i2c_imx->dma && msgs[i].len >= DMA_THRESHOLD)\r\nresult = i2c_imx_dma_write(i2c_imx, &msgs[i]);\r\nelse\r\nresult = i2c_imx_write(i2c_imx, &msgs[i]);\r\n}\r\nif (result)\r\ngoto fail0;\r\n}\r\nfail0:\r\ni2c_imx_stop(i2c_imx);\r\ndev_dbg(&i2c_imx->adapter.dev, "<%s> exit with: %s: %d\n", __func__,\r\n(result < 0) ? "error" : "success msg",\r\n(result < 0) ? result : num);\r\nreturn (result < 0) ? result : num;\r\n}\r\nstatic u32 i2c_imx_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\r\n| I2C_FUNC_SMBUS_READ_BLOCK_DATA;\r\n}\r\nstatic int i2c_imx_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id = of_match_device(i2c_imx_dt_ids,\r\n&pdev->dev);\r\nstruct imx_i2c_struct *i2c_imx;\r\nstruct resource *res;\r\nstruct imxi2c_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nvoid __iomem *base;\r\nint irq, ret;\r\ndma_addr_t phy_addr;\r\ndev_dbg(&pdev->dev, "<%s>\n", __func__);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "can't get irq number\n");\r\nreturn irq;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nphy_addr = (dma_addr_t)res->start;\r\ni2c_imx = devm_kzalloc(&pdev->dev, sizeof(*i2c_imx), GFP_KERNEL);\r\nif (!i2c_imx)\r\nreturn -ENOMEM;\r\nif (of_id)\r\ni2c_imx->hwdata = of_id->data;\r\nelse\r\ni2c_imx->hwdata = (struct imx_i2c_hwdata *)\r\nplatform_get_device_id(pdev)->driver_data;\r\nstrlcpy(i2c_imx->adapter.name, pdev->name, sizeof(i2c_imx->adapter.name));\r\ni2c_imx->adapter.owner = THIS_MODULE;\r\ni2c_imx->adapter.algo = &i2c_imx_algo;\r\ni2c_imx->adapter.dev.parent = &pdev->dev;\r\ni2c_imx->adapter.nr = pdev->id;\r\ni2c_imx->adapter.dev.of_node = pdev->dev.of_node;\r\ni2c_imx->base = base;\r\ni2c_imx->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(i2c_imx->clk)) {\r\ndev_err(&pdev->dev, "can't get I2C clock\n");\r\nreturn PTR_ERR(i2c_imx->clk);\r\n}\r\nret = clk_prepare_enable(i2c_imx->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't enable I2C clock\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, i2c_imx_isr, 0,\r\npdev->name, i2c_imx);\r\nif (ret) {\r\ndev_err(&pdev->dev, "can't claim irq %d\n", irq);\r\ngoto clk_disable;\r\n}\r\ninit_waitqueue_head(&i2c_imx->queue);\r\ni2c_set_adapdata(&i2c_imx->adapter, i2c_imx);\r\ni2c_imx->bitrate = IMX_I2C_BIT_RATE;\r\nret = of_property_read_u32(pdev->dev.of_node,\r\n"clock-frequency", &i2c_imx->bitrate);\r\nif (ret < 0 && pdata && pdata->bitrate)\r\ni2c_imx->bitrate = pdata->bitrate;\r\nimx_i2c_write_reg(i2c_imx->hwdata->i2cr_ien_opcode ^ I2CR_IEN,\r\ni2c_imx, IMX_I2C_I2CR);\r\nimx_i2c_write_reg(i2c_imx->hwdata->i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);\r\nret = i2c_add_numbered_adapter(&i2c_imx->adapter);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "registration failed\n");\r\ngoto clk_disable;\r\n}\r\nplatform_set_drvdata(pdev, i2c_imx);\r\nclk_disable_unprepare(i2c_imx->clk);\r\ndev_dbg(&i2c_imx->adapter.dev, "claimed irq %d\n", irq);\r\ndev_dbg(&i2c_imx->adapter.dev, "device resources: %pR\n", res);\r\ndev_dbg(&i2c_imx->adapter.dev, "adapter name: \"%s\"\n",\r\ni2c_imx->adapter.name);\r\ndev_info(&i2c_imx->adapter.dev, "IMX I2C adapter registered\n");\r\ni2c_imx_dma_request(i2c_imx, phy_addr);\r\nreturn 0;\r\nclk_disable:\r\nclk_disable_unprepare(i2c_imx->clk);\r\nreturn ret;\r\n}\r\nstatic int i2c_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_i2c_struct *i2c_imx = platform_get_drvdata(pdev);\r\ndev_dbg(&i2c_imx->adapter.dev, "adapter removed\n");\r\ni2c_del_adapter(&i2c_imx->adapter);\r\nif (i2c_imx->dma)\r\ni2c_imx_dma_free(i2c_imx);\r\nimx_i2c_write_reg(0, i2c_imx, IMX_I2C_IADR);\r\nimx_i2c_write_reg(0, i2c_imx, IMX_I2C_IFDR);\r\nimx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2CR);\r\nimx_i2c_write_reg(0, i2c_imx, IMX_I2C_I2SR);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_adap_imx_init(void)\r\n{\r\nreturn platform_driver_register(&i2c_imx_driver);\r\n}\r\nstatic void __exit i2c_adap_imx_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_imx_driver);\r\n}
