static void *___sym_malloc(m_pool_p mp, int size)\r\n{\r\nint i = 0;\r\nint s = (1 << SYM_MEM_SHIFT);\r\nint j;\r\nvoid *a;\r\nm_link_p h = mp->h;\r\nif (size > SYM_MEM_CLUSTER_SIZE)\r\nreturn NULL;\r\nwhile (size > s) {\r\ns <<= 1;\r\n++i;\r\n}\r\nj = i;\r\nwhile (!h[j].next) {\r\nif (s == SYM_MEM_CLUSTER_SIZE) {\r\nh[j].next = (m_link_p) M_GET_MEM_CLUSTER();\r\nif (h[j].next)\r\nh[j].next->next = NULL;\r\nbreak;\r\n}\r\n++j;\r\ns <<= 1;\r\n}\r\na = h[j].next;\r\nif (a) {\r\nh[j].next = h[j].next->next;\r\nwhile (j > i) {\r\nj -= 1;\r\ns >>= 1;\r\nh[j].next = (m_link_p) (a+s);\r\nh[j].next->next = NULL;\r\n}\r\n}\r\n#ifdef DEBUG\r\nprintf("___sym_malloc(%d) = %p\n", size, (void *) a);\r\n#endif\r\nreturn a;\r\n}\r\nstatic void ___sym_mfree(m_pool_p mp, void *ptr, int size)\r\n{\r\nint i = 0;\r\nint s = (1 << SYM_MEM_SHIFT);\r\nm_link_p q;\r\nunsigned long a, b;\r\nm_link_p h = mp->h;\r\n#ifdef DEBUG\r\nprintf("___sym_mfree(%p, %d)\n", ptr, size);\r\n#endif\r\nif (size > SYM_MEM_CLUSTER_SIZE)\r\nreturn;\r\nwhile (size > s) {\r\ns <<= 1;\r\n++i;\r\n}\r\na = (unsigned long)ptr;\r\nwhile (1) {\r\nif (s == SYM_MEM_CLUSTER_SIZE) {\r\n#ifdef SYM_MEM_FREE_UNUSED\r\nM_FREE_MEM_CLUSTER((void *)a);\r\n#else\r\n((m_link_p) a)->next = h[i].next;\r\nh[i].next = (m_link_p) a;\r\n#endif\r\nbreak;\r\n}\r\nb = a ^ s;\r\nq = &h[i];\r\nwhile (q->next && q->next != (m_link_p) b) {\r\nq = q->next;\r\n}\r\nif (!q->next) {\r\n((m_link_p) a)->next = h[i].next;\r\nh[i].next = (m_link_p) a;\r\nbreak;\r\n}\r\nq->next = q->next->next;\r\na = a & b;\r\ns <<= 1;\r\n++i;\r\n}\r\n}\r\nstatic void *__sym_calloc2(m_pool_p mp, int size, char *name, int uflags)\r\n{\r\nvoid *p;\r\np = ___sym_malloc(mp, size);\r\nif (DEBUG_FLAGS & DEBUG_ALLOC) {\r\nprintf ("new %-10s[%4d] @%p.\n", name, size, p);\r\n}\r\nif (p)\r\nmemset(p, 0, size);\r\nelse if (uflags & SYM_MEM_WARN)\r\nprintf ("__sym_calloc2: failed to allocate %s[%d]\n", name, size);\r\nreturn p;\r\n}\r\nstatic void __sym_mfree(m_pool_p mp, void *ptr, int size, char *name)\r\n{\r\nif (DEBUG_FLAGS & DEBUG_ALLOC)\r\nprintf ("freeing %-10s[%4d] @%p.\n", name, size, ptr);\r\n___sym_mfree(mp, ptr, size);\r\n}\r\nstatic void *___mp0_get_mem_cluster(m_pool_p mp)\r\n{\r\nvoid *m = sym_get_mem_cluster();\r\nif (m)\r\n++mp->nump;\r\nreturn m;\r\n}\r\nstatic void ___mp0_free_mem_cluster(m_pool_p mp, void *m)\r\n{\r\nsym_free_mem_cluster(m);\r\n--mp->nump;\r\n}\r\nstatic void * ___get_dma_mem_cluster(m_pool_p mp)\r\n{\r\nm_vtob_p vbp;\r\nvoid *vaddr;\r\nvbp = __sym_calloc(&mp0, sizeof(*vbp), "VTOB");\r\nif (!vbp)\r\ngoto out_err;\r\nvaddr = sym_m_get_dma_mem_cluster(mp, vbp);\r\nif (vaddr) {\r\nint hc = VTOB_HASH_CODE(vaddr);\r\nvbp->next = mp->vtob[hc];\r\nmp->vtob[hc] = vbp;\r\n++mp->nump;\r\n}\r\nreturn vaddr;\r\nout_err:\r\nreturn NULL;\r\n}\r\nstatic void ___free_dma_mem_cluster(m_pool_p mp, void *m)\r\n{\r\nm_vtob_p *vbpp, vbp;\r\nint hc = VTOB_HASH_CODE(m);\r\nvbpp = &mp->vtob[hc];\r\nwhile (*vbpp && (*vbpp)->vaddr != m)\r\nvbpp = &(*vbpp)->next;\r\nif (*vbpp) {\r\nvbp = *vbpp;\r\n*vbpp = (*vbpp)->next;\r\nsym_m_free_dma_mem_cluster(mp, vbp);\r\n__sym_mfree(&mp0, vbp, sizeof(*vbp), "VTOB");\r\n--mp->nump;\r\n}\r\n}\r\nstatic inline m_pool_p ___get_dma_pool(m_pool_ident_t dev_dmat)\r\n{\r\nm_pool_p mp;\r\nfor (mp = mp0.next;\r\nmp && !sym_m_pool_match(mp->dev_dmat, dev_dmat);\r\nmp = mp->next);\r\nreturn mp;\r\n}\r\nstatic m_pool_p ___cre_dma_pool(m_pool_ident_t dev_dmat)\r\n{\r\nm_pool_p mp = __sym_calloc(&mp0, sizeof(*mp), "MPOOL");\r\nif (mp) {\r\nmp->dev_dmat = dev_dmat;\r\nmp->get_mem_cluster = ___get_dma_mem_cluster;\r\n#ifdef SYM_MEM_FREE_UNUSED\r\nmp->free_mem_cluster = ___free_dma_mem_cluster;\r\n#endif\r\nmp->next = mp0.next;\r\nmp0.next = mp;\r\nreturn mp;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ___del_dma_pool(m_pool_p p)\r\n{\r\nm_pool_p *pp = &mp0.next;\r\nwhile (*pp && *pp != p)\r\npp = &(*pp)->next;\r\nif (*pp) {\r\n*pp = (*pp)->next;\r\n__sym_mfree(&mp0, p, sizeof(*p), "MPOOL");\r\n}\r\n}\r\nvoid *__sym_calloc_dma(m_pool_ident_t dev_dmat, int size, char *name)\r\n{\r\nunsigned long flags;\r\nm_pool_p mp;\r\nvoid *m = NULL;\r\nspin_lock_irqsave(&sym53c8xx_lock, flags);\r\nmp = ___get_dma_pool(dev_dmat);\r\nif (!mp)\r\nmp = ___cre_dma_pool(dev_dmat);\r\nif (!mp)\r\ngoto out;\r\nm = __sym_calloc(mp, size, name);\r\n#ifdef SYM_MEM_FREE_UNUSED\r\nif (!mp->nump)\r\n___del_dma_pool(mp);\r\n#endif\r\nout:\r\nspin_unlock_irqrestore(&sym53c8xx_lock, flags);\r\nreturn m;\r\n}\r\nvoid __sym_mfree_dma(m_pool_ident_t dev_dmat, void *m, int size, char *name)\r\n{\r\nunsigned long flags;\r\nm_pool_p mp;\r\nspin_lock_irqsave(&sym53c8xx_lock, flags);\r\nmp = ___get_dma_pool(dev_dmat);\r\nif (!mp)\r\ngoto out;\r\n__sym_mfree(mp, m, size, name);\r\n#ifdef SYM_MEM_FREE_UNUSED\r\nif (!mp->nump)\r\n___del_dma_pool(mp);\r\n#endif\r\nout:\r\nspin_unlock_irqrestore(&sym53c8xx_lock, flags);\r\n}\r\ndma_addr_t __vtobus(m_pool_ident_t dev_dmat, void *m)\r\n{\r\nunsigned long flags;\r\nm_pool_p mp;\r\nint hc = VTOB_HASH_CODE(m);\r\nm_vtob_p vp = NULL;\r\nvoid *a = (void *)((unsigned long)m & ~SYM_MEM_CLUSTER_MASK);\r\ndma_addr_t b;\r\nspin_lock_irqsave(&sym53c8xx_lock, flags);\r\nmp = ___get_dma_pool(dev_dmat);\r\nif (mp) {\r\nvp = mp->vtob[hc];\r\nwhile (vp && vp->vaddr != a)\r\nvp = vp->next;\r\n}\r\nif (!vp)\r\npanic("sym: VTOBUS FAILED!\n");\r\nb = vp->baddr + (m - a);\r\nspin_unlock_irqrestore(&sym53c8xx_lock, flags);\r\nreturn b;\r\n}
