static inline void *ocrdma_get_eqe(struct ocrdma_eq *eq)\r\n{\r\nreturn eq->q.va + (eq->q.tail * sizeof(struct ocrdma_eqe));\r\n}\r\nstatic inline void ocrdma_eq_inc_tail(struct ocrdma_eq *eq)\r\n{\r\neq->q.tail = (eq->q.tail + 1) & (OCRDMA_EQ_LEN - 1);\r\n}\r\nstatic inline void *ocrdma_get_mcqe(struct ocrdma_dev *dev)\r\n{\r\nstruct ocrdma_mcqe *cqe = (struct ocrdma_mcqe *)\r\n(dev->mq.cq.va + (dev->mq.cq.tail * sizeof(struct ocrdma_mcqe)));\r\nif (!(le32_to_cpu(cqe->valid_ae_cmpl_cons) & OCRDMA_MCQE_VALID_MASK))\r\nreturn NULL;\r\nreturn cqe;\r\n}\r\nstatic inline void ocrdma_mcq_inc_tail(struct ocrdma_dev *dev)\r\n{\r\ndev->mq.cq.tail = (dev->mq.cq.tail + 1) & (OCRDMA_MQ_CQ_LEN - 1);\r\n}\r\nstatic inline struct ocrdma_mqe *ocrdma_get_mqe(struct ocrdma_dev *dev)\r\n{\r\nreturn dev->mq.sq.va + (dev->mq.sq.head * sizeof(struct ocrdma_mqe));\r\n}\r\nstatic inline void ocrdma_mq_inc_head(struct ocrdma_dev *dev)\r\n{\r\ndev->mq.sq.head = (dev->mq.sq.head + 1) & (OCRDMA_MQ_LEN - 1);\r\n}\r\nstatic inline void *ocrdma_get_mqe_rsp(struct ocrdma_dev *dev)\r\n{\r\nreturn dev->mq.sq.va + (dev->mqe_ctx.tag * sizeof(struct ocrdma_mqe));\r\n}\r\nenum ib_qp_state get_ibqp_state(enum ocrdma_qp_state qps)\r\n{\r\nswitch (qps) {\r\ncase OCRDMA_QPS_RST:\r\nreturn IB_QPS_RESET;\r\ncase OCRDMA_QPS_INIT:\r\nreturn IB_QPS_INIT;\r\ncase OCRDMA_QPS_RTR:\r\nreturn IB_QPS_RTR;\r\ncase OCRDMA_QPS_RTS:\r\nreturn IB_QPS_RTS;\r\ncase OCRDMA_QPS_SQD:\r\ncase OCRDMA_QPS_SQ_DRAINING:\r\nreturn IB_QPS_SQD;\r\ncase OCRDMA_QPS_SQE:\r\nreturn IB_QPS_SQE;\r\ncase OCRDMA_QPS_ERR:\r\nreturn IB_QPS_ERR;\r\n}\r\nreturn IB_QPS_ERR;\r\n}\r\nstatic enum ocrdma_qp_state get_ocrdma_qp_state(enum ib_qp_state qps)\r\n{\r\nswitch (qps) {\r\ncase IB_QPS_RESET:\r\nreturn OCRDMA_QPS_RST;\r\ncase IB_QPS_INIT:\r\nreturn OCRDMA_QPS_INIT;\r\ncase IB_QPS_RTR:\r\nreturn OCRDMA_QPS_RTR;\r\ncase IB_QPS_RTS:\r\nreturn OCRDMA_QPS_RTS;\r\ncase IB_QPS_SQD:\r\nreturn OCRDMA_QPS_SQD;\r\ncase IB_QPS_SQE:\r\nreturn OCRDMA_QPS_SQE;\r\ncase IB_QPS_ERR:\r\nreturn OCRDMA_QPS_ERR;\r\n}\r\nreturn OCRDMA_QPS_ERR;\r\n}\r\nstatic int ocrdma_get_mbx_errno(u32 status)\r\n{\r\nint err_num;\r\nu8 mbox_status = (status & OCRDMA_MBX_RSP_STATUS_MASK) >>\r\nOCRDMA_MBX_RSP_STATUS_SHIFT;\r\nu8 add_status = (status & OCRDMA_MBX_RSP_ASTATUS_MASK) >>\r\nOCRDMA_MBX_RSP_ASTATUS_SHIFT;\r\nswitch (mbox_status) {\r\ncase OCRDMA_MBX_STATUS_OOR:\r\ncase OCRDMA_MBX_STATUS_MAX_QP_EXCEEDS:\r\nerr_num = -EAGAIN;\r\nbreak;\r\ncase OCRDMA_MBX_STATUS_INVALID_PD:\r\ncase OCRDMA_MBX_STATUS_INVALID_CQ:\r\ncase OCRDMA_MBX_STATUS_INVALID_SRQ_ID:\r\ncase OCRDMA_MBX_STATUS_INVALID_QP:\r\ncase OCRDMA_MBX_STATUS_INVALID_CHANGE:\r\ncase OCRDMA_MBX_STATUS_MTU_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_INVALID_RNR_NAK_TIMER:\r\ncase OCRDMA_MBX_STATUS_PKEY_INDEX_INVALID:\r\ncase OCRDMA_MBX_STATUS_PKEY_INDEX_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_ILLEGAL_FIELD:\r\ncase OCRDMA_MBX_STATUS_INVALID_PBL_ENTRY:\r\ncase OCRDMA_MBX_STATUS_INVALID_LKEY:\r\ncase OCRDMA_MBX_STATUS_INVALID_VA:\r\ncase OCRDMA_MBX_STATUS_INVALID_LENGTH:\r\ncase OCRDMA_MBX_STATUS_INVALID_FBO:\r\ncase OCRDMA_MBX_STATUS_INVALID_ACC_RIGHTS:\r\ncase OCRDMA_MBX_STATUS_INVALID_PBE_SIZE:\r\ncase OCRDMA_MBX_STATUS_ATOMIC_OPS_UNSUP:\r\ncase OCRDMA_MBX_STATUS_SRQ_ERROR:\r\ncase OCRDMA_MBX_STATUS_SRQ_SIZE_UNDERUNS:\r\nerr_num = -EINVAL;\r\nbreak;\r\ncase OCRDMA_MBX_STATUS_PD_INUSE:\r\ncase OCRDMA_MBX_STATUS_QP_BOUND:\r\ncase OCRDMA_MBX_STATUS_MW_STILL_BOUND:\r\ncase OCRDMA_MBX_STATUS_MW_BOUND:\r\nerr_num = -EBUSY;\r\nbreak;\r\ncase OCRDMA_MBX_STATUS_RECVQ_RQE_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_SGE_RECV_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_RQE_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_SRQ_LIMIT_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_ORD_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_IRD_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_SENDQ_WQE_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_SGE_SEND_EXCEEDS:\r\ncase OCRDMA_MBX_STATUS_SGE_WRITE_EXCEEDS:\r\nerr_num = -ENOBUFS;\r\nbreak;\r\ncase OCRDMA_MBX_STATUS_FAILED:\r\nswitch (add_status) {\r\ncase OCRDMA_MBX_ADDI_STATUS_INSUFFICIENT_RESOURCES:\r\nerr_num = -EAGAIN;\r\nbreak;\r\n}\r\ndefault:\r\nerr_num = -EFAULT;\r\n}\r\nreturn err_num;\r\n}\r\nchar *port_speed_string(struct ocrdma_dev *dev)\r\n{\r\nchar *str = "";\r\nu16 speeds_supported;\r\nspeeds_supported = dev->phy.fixed_speeds_supported |\r\ndev->phy.auto_speeds_supported;\r\nif (speeds_supported & OCRDMA_PHY_SPEED_40GBPS)\r\nstr = "40Gbps ";\r\nelse if (speeds_supported & OCRDMA_PHY_SPEED_10GBPS)\r\nstr = "10Gbps ";\r\nelse if (speeds_supported & OCRDMA_PHY_SPEED_1GBPS)\r\nstr = "1Gbps ";\r\nreturn str;\r\n}\r\nstatic int ocrdma_get_mbx_cqe_errno(u16 cqe_status)\r\n{\r\nint err_num = -EINVAL;\r\nswitch (cqe_status) {\r\ncase OCRDMA_MBX_CQE_STATUS_INSUFFICIENT_PRIVILEDGES:\r\nerr_num = -EPERM;\r\nbreak;\r\ncase OCRDMA_MBX_CQE_STATUS_INVALID_PARAMETER:\r\nerr_num = -EINVAL;\r\nbreak;\r\ncase OCRDMA_MBX_CQE_STATUS_INSUFFICIENT_RESOURCES:\r\ncase OCRDMA_MBX_CQE_STATUS_QUEUE_FLUSHING:\r\nerr_num = -EINVAL;\r\nbreak;\r\ncase OCRDMA_MBX_CQE_STATUS_DMA_FAILED:\r\ndefault:\r\nerr_num = -EINVAL;\r\nbreak;\r\n}\r\nreturn err_num;\r\n}\r\nvoid ocrdma_ring_cq_db(struct ocrdma_dev *dev, u16 cq_id, bool armed,\r\nbool solicited, u16 cqe_popped)\r\n{\r\nu32 val = cq_id & OCRDMA_DB_CQ_RING_ID_MASK;\r\nval |= ((cq_id & OCRDMA_DB_CQ_RING_ID_EXT_MASK) <<\r\nOCRDMA_DB_CQ_RING_ID_EXT_MASK_SHIFT);\r\nif (armed)\r\nval |= (1 << OCRDMA_DB_CQ_REARM_SHIFT);\r\nif (solicited)\r\nval |= (1 << OCRDMA_DB_CQ_SOLICIT_SHIFT);\r\nval |= (cqe_popped << OCRDMA_DB_CQ_NUM_POPPED_SHIFT);\r\niowrite32(val, dev->nic_info.db + OCRDMA_DB_CQ_OFFSET);\r\n}\r\nstatic void ocrdma_ring_mq_db(struct ocrdma_dev *dev)\r\n{\r\nu32 val = 0;\r\nval |= dev->mq.sq.id & OCRDMA_MQ_ID_MASK;\r\nval |= 1 << OCRDMA_MQ_NUM_MQE_SHIFT;\r\niowrite32(val, dev->nic_info.db + OCRDMA_DB_MQ_OFFSET);\r\n}\r\nstatic void ocrdma_ring_eq_db(struct ocrdma_dev *dev, u16 eq_id,\r\nbool arm, bool clear_int, u16 num_eqe)\r\n{\r\nu32 val = 0;\r\nval |= eq_id & OCRDMA_EQ_ID_MASK;\r\nval |= ((eq_id & OCRDMA_EQ_ID_EXT_MASK) << OCRDMA_EQ_ID_EXT_MASK_SHIFT);\r\nif (arm)\r\nval |= (1 << OCRDMA_REARM_SHIFT);\r\nif (clear_int)\r\nval |= (1 << OCRDMA_EQ_CLR_SHIFT);\r\nval |= (1 << OCRDMA_EQ_TYPE_SHIFT);\r\nval |= (num_eqe << OCRDMA_NUM_EQE_SHIFT);\r\niowrite32(val, dev->nic_info.db + OCRDMA_DB_EQ_OFFSET);\r\n}\r\nstatic void ocrdma_init_mch(struct ocrdma_mbx_hdr *cmd_hdr,\r\nu8 opcode, u8 subsys, u32 cmd_len)\r\n{\r\ncmd_hdr->subsys_op = (opcode | (subsys << OCRDMA_MCH_SUBSYS_SHIFT));\r\ncmd_hdr->timeout = 20;\r\ncmd_hdr->cmd_len = cmd_len - sizeof(struct ocrdma_mbx_hdr);\r\n}\r\nstatic void *ocrdma_init_emb_mqe(u8 opcode, u32 cmd_len)\r\n{\r\nstruct ocrdma_mqe *mqe;\r\nmqe = kzalloc(sizeof(struct ocrdma_mqe), GFP_KERNEL);\r\nif (!mqe)\r\nreturn NULL;\r\nmqe->hdr.spcl_sge_cnt_emb |=\r\n(OCRDMA_MQE_EMBEDDED << OCRDMA_MQE_HDR_EMB_SHIFT) &\r\nOCRDMA_MQE_HDR_EMB_MASK;\r\nmqe->hdr.pyld_len = cmd_len - sizeof(struct ocrdma_mqe_hdr);\r\nocrdma_init_mch(&mqe->u.emb_req.mch, opcode, OCRDMA_SUBSYS_ROCE,\r\nmqe->hdr.pyld_len);\r\nreturn mqe;\r\n}\r\nstatic void ocrdma_free_q(struct ocrdma_dev *dev, struct ocrdma_queue_info *q)\r\n{\r\ndma_free_coherent(&dev->nic_info.pdev->dev, q->size, q->va, q->dma);\r\n}\r\nstatic int ocrdma_alloc_q(struct ocrdma_dev *dev,\r\nstruct ocrdma_queue_info *q, u16 len, u16 entry_size)\r\n{\r\nmemset(q, 0, sizeof(*q));\r\nq->len = len;\r\nq->entry_size = entry_size;\r\nq->size = len * entry_size;\r\nq->va = dma_alloc_coherent(&dev->nic_info.pdev->dev, q->size,\r\n&q->dma, GFP_KERNEL);\r\nif (!q->va)\r\nreturn -ENOMEM;\r\nmemset(q->va, 0, q->size);\r\nreturn 0;\r\n}\r\nstatic void ocrdma_build_q_pages(struct ocrdma_pa *q_pa, int cnt,\r\ndma_addr_t host_pa, int hw_page_size)\r\n{\r\nint i;\r\nfor (i = 0; i < cnt; i++) {\r\nq_pa[i].lo = (u32) (host_pa & 0xffffffff);\r\nq_pa[i].hi = (u32) upper_32_bits(host_pa);\r\nhost_pa += hw_page_size;\r\n}\r\n}\r\nstatic int ocrdma_mbx_delete_q(struct ocrdma_dev *dev,\r\nstruct ocrdma_queue_info *q, int queue_type)\r\n{\r\nu8 opcode = 0;\r\nint status;\r\nstruct ocrdma_delete_q_req *cmd = dev->mbx_cmd;\r\nswitch (queue_type) {\r\ncase QTYPE_MCCQ:\r\nopcode = OCRDMA_CMD_DELETE_MQ;\r\nbreak;\r\ncase QTYPE_CQ:\r\nopcode = OCRDMA_CMD_DELETE_CQ;\r\nbreak;\r\ncase QTYPE_EQ:\r\nopcode = OCRDMA_CMD_DELETE_EQ;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\nocrdma_init_mch(&cmd->req, opcode, OCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\ncmd->id = q->id;\r\nstatus = be_roce_mcc_cmd(dev->nic_info.netdev,\r\ncmd, sizeof(*cmd), NULL, NULL);\r\nif (!status)\r\nq->created = false;\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_create_eq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\r\n{\r\nint status;\r\nstruct ocrdma_create_eq_req *cmd = dev->mbx_cmd;\r\nstruct ocrdma_create_eq_rsp *rsp = dev->mbx_cmd;\r\nmemset(cmd, 0, sizeof(*cmd));\r\nocrdma_init_mch(&cmd->req, OCRDMA_CMD_CREATE_EQ, OCRDMA_SUBSYS_COMMON,\r\nsizeof(*cmd));\r\ncmd->req.rsvd_version = 2;\r\ncmd->num_pages = 4;\r\ncmd->valid = OCRDMA_CREATE_EQ_VALID;\r\ncmd->cnt = 4 << OCRDMA_CREATE_EQ_CNT_SHIFT;\r\nocrdma_build_q_pages(&cmd->pa[0], cmd->num_pages, eq->q.dma,\r\nPAGE_SIZE_4K);\r\nstatus = be_roce_mcc_cmd(dev->nic_info.netdev, cmd, sizeof(*cmd), NULL,\r\nNULL);\r\nif (!status) {\r\neq->q.id = rsp->vector_eqid & 0xffff;\r\neq->vector = (rsp->vector_eqid >> 16) & 0xffff;\r\neq->q.created = true;\r\n}\r\nreturn status;\r\n}\r\nstatic int ocrdma_create_eq(struct ocrdma_dev *dev,\r\nstruct ocrdma_eq *eq, u16 q_len)\r\n{\r\nint status;\r\nstatus = ocrdma_alloc_q(dev, &eq->q, OCRDMA_EQ_LEN,\r\nsizeof(struct ocrdma_eqe));\r\nif (status)\r\nreturn status;\r\nstatus = ocrdma_mbx_create_eq(dev, eq);\r\nif (status)\r\ngoto mbx_err;\r\neq->dev = dev;\r\nocrdma_ring_eq_db(dev, eq->q.id, true, true, 0);\r\nreturn 0;\r\nmbx_err:\r\nocrdma_free_q(dev, &eq->q);\r\nreturn status;\r\n}\r\nint ocrdma_get_irq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\r\n{\r\nint irq;\r\nif (dev->nic_info.intr_mode == BE_INTERRUPT_MODE_INTX)\r\nirq = dev->nic_info.pdev->irq;\r\nelse\r\nirq = dev->nic_info.msix.vector_list[eq->vector];\r\nreturn irq;\r\n}\r\nstatic void _ocrdma_destroy_eq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\r\n{\r\nif (eq->q.created) {\r\nocrdma_mbx_delete_q(dev, &eq->q, QTYPE_EQ);\r\nocrdma_free_q(dev, &eq->q);\r\n}\r\n}\r\nstatic void ocrdma_destroy_eq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\r\n{\r\nint irq;\r\nocrdma_ring_eq_db(dev, eq->q.id, false, false, 0);\r\nirq = ocrdma_get_irq(dev, eq);\r\nfree_irq(irq, eq);\r\n_ocrdma_destroy_eq(dev, eq);\r\n}\r\nstatic void ocrdma_destroy_eqs(struct ocrdma_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->eq_cnt; i++)\r\nocrdma_destroy_eq(dev, &dev->eq_tbl[i]);\r\n}\r\nstatic int ocrdma_mbx_mq_cq_create(struct ocrdma_dev *dev,\r\nstruct ocrdma_queue_info *cq,\r\nstruct ocrdma_queue_info *eq)\r\n{\r\nstruct ocrdma_create_cq_cmd *cmd = dev->mbx_cmd;\r\nstruct ocrdma_create_cq_cmd_rsp *rsp = dev->mbx_cmd;\r\nint status;\r\nmemset(cmd, 0, sizeof(*cmd));\r\nocrdma_init_mch(&cmd->req, OCRDMA_CMD_CREATE_CQ,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\ncmd->req.rsvd_version = OCRDMA_CREATE_CQ_VER2;\r\ncmd->pgsz_pgcnt = (cq->size / OCRDMA_MIN_Q_PAGE_SIZE) <<\r\nOCRDMA_CREATE_CQ_PAGE_SIZE_SHIFT;\r\ncmd->pgsz_pgcnt |= PAGES_4K_SPANNED(cq->va, cq->size);\r\ncmd->ev_cnt_flags = OCRDMA_CREATE_CQ_DEF_FLAGS;\r\ncmd->eqn = eq->id;\r\ncmd->pdid_cqecnt = cq->size / sizeof(struct ocrdma_mcqe);\r\nocrdma_build_q_pages(&cmd->pa[0], cq->size / OCRDMA_MIN_Q_PAGE_SIZE,\r\ncq->dma, PAGE_SIZE_4K);\r\nstatus = be_roce_mcc_cmd(dev->nic_info.netdev,\r\ncmd, sizeof(*cmd), NULL, NULL);\r\nif (!status) {\r\ncq->id = (u16) (rsp->cq_id & OCRDMA_CREATE_CQ_RSP_CQ_ID_MASK);\r\ncq->created = true;\r\n}\r\nreturn status;\r\n}\r\nstatic u32 ocrdma_encoded_q_len(int q_len)\r\n{\r\nu32 len_encoded = fls(q_len);\r\nif (len_encoded == 16)\r\nlen_encoded = 0;\r\nreturn len_encoded;\r\n}\r\nstatic int ocrdma_mbx_create_mq(struct ocrdma_dev *dev,\r\nstruct ocrdma_queue_info *mq,\r\nstruct ocrdma_queue_info *cq)\r\n{\r\nint num_pages, status;\r\nstruct ocrdma_create_mq_req *cmd = dev->mbx_cmd;\r\nstruct ocrdma_create_mq_rsp *rsp = dev->mbx_cmd;\r\nstruct ocrdma_pa *pa;\r\nmemset(cmd, 0, sizeof(*cmd));\r\nnum_pages = PAGES_4K_SPANNED(mq->va, mq->size);\r\nocrdma_init_mch(&cmd->req, OCRDMA_CMD_CREATE_MQ_EXT,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\ncmd->req.rsvd_version = 1;\r\ncmd->cqid_pages = num_pages;\r\ncmd->cqid_pages |= (cq->id << OCRDMA_CREATE_MQ_CQ_ID_SHIFT);\r\ncmd->async_cqid_valid = OCRDMA_CREATE_MQ_ASYNC_CQ_VALID;\r\ncmd->async_event_bitmap = BIT(OCRDMA_ASYNC_GRP5_EVE_CODE);\r\ncmd->async_event_bitmap |= BIT(OCRDMA_ASYNC_RDMA_EVE_CODE);\r\ncmd->async_cqid_ringsize = cq->id;\r\ncmd->async_cqid_ringsize |= (ocrdma_encoded_q_len(mq->len) <<\r\nOCRDMA_CREATE_MQ_RING_SIZE_SHIFT);\r\ncmd->valid = OCRDMA_CREATE_MQ_VALID;\r\npa = &cmd->pa[0];\r\nocrdma_build_q_pages(pa, num_pages, mq->dma, PAGE_SIZE_4K);\r\nstatus = be_roce_mcc_cmd(dev->nic_info.netdev,\r\ncmd, sizeof(*cmd), NULL, NULL);\r\nif (!status) {\r\nmq->id = rsp->id;\r\nmq->created = true;\r\n}\r\nreturn status;\r\n}\r\nstatic int ocrdma_create_mq(struct ocrdma_dev *dev)\r\n{\r\nint status;\r\nstatus = ocrdma_alloc_q(dev, &dev->mq.cq, OCRDMA_MQ_CQ_LEN,\r\nsizeof(struct ocrdma_mcqe));\r\nif (status)\r\ngoto alloc_err;\r\ndev->eq_tbl[0].cq_cnt++;\r\nstatus = ocrdma_mbx_mq_cq_create(dev, &dev->mq.cq, &dev->eq_tbl[0].q);\r\nif (status)\r\ngoto mbx_cq_free;\r\nmemset(&dev->mqe_ctx, 0, sizeof(dev->mqe_ctx));\r\ninit_waitqueue_head(&dev->mqe_ctx.cmd_wait);\r\nmutex_init(&dev->mqe_ctx.lock);\r\nstatus = ocrdma_alloc_q(dev, &dev->mq.sq, OCRDMA_MQ_LEN,\r\nsizeof(struct ocrdma_mqe));\r\nif (status)\r\ngoto mbx_cq_destroy;\r\nstatus = ocrdma_mbx_create_mq(dev, &dev->mq.sq, &dev->mq.cq);\r\nif (status)\r\ngoto mbx_q_free;\r\nocrdma_ring_cq_db(dev, dev->mq.cq.id, true, false, 0);\r\nreturn 0;\r\nmbx_q_free:\r\nocrdma_free_q(dev, &dev->mq.sq);\r\nmbx_cq_destroy:\r\nocrdma_mbx_delete_q(dev, &dev->mq.cq, QTYPE_CQ);\r\nmbx_cq_free:\r\nocrdma_free_q(dev, &dev->mq.cq);\r\nalloc_err:\r\nreturn status;\r\n}\r\nstatic void ocrdma_destroy_mq(struct ocrdma_dev *dev)\r\n{\r\nstruct ocrdma_queue_info *mbxq, *cq;\r\nmutex_lock(&dev->mqe_ctx.lock);\r\nmbxq = &dev->mq.sq;\r\nif (mbxq->created) {\r\nocrdma_mbx_delete_q(dev, mbxq, QTYPE_MCCQ);\r\nocrdma_free_q(dev, mbxq);\r\n}\r\nmutex_unlock(&dev->mqe_ctx.lock);\r\ncq = &dev->mq.cq;\r\nif (cq->created) {\r\nocrdma_mbx_delete_q(dev, cq, QTYPE_CQ);\r\nocrdma_free_q(dev, cq);\r\n}\r\n}\r\nstatic void ocrdma_process_qpcat_error(struct ocrdma_dev *dev,\r\nstruct ocrdma_qp *qp)\r\n{\r\nenum ib_qp_state new_ib_qps = IB_QPS_ERR;\r\nenum ib_qp_state old_ib_qps;\r\nif (qp == NULL)\r\nBUG();\r\nocrdma_qp_state_change(qp, new_ib_qps, &old_ib_qps);\r\n}\r\nstatic void ocrdma_dispatch_ibevent(struct ocrdma_dev *dev,\r\nstruct ocrdma_ae_mcqe *cqe)\r\n{\r\nstruct ocrdma_qp *qp = NULL;\r\nstruct ocrdma_cq *cq = NULL;\r\nstruct ib_event ib_evt;\r\nint cq_event = 0;\r\nint qp_event = 1;\r\nint srq_event = 0;\r\nint dev_event = 0;\r\nint type = (cqe->valid_ae_event & OCRDMA_AE_MCQE_EVENT_TYPE_MASK) >>\r\nOCRDMA_AE_MCQE_EVENT_TYPE_SHIFT;\r\nif (cqe->qpvalid_qpid & OCRDMA_AE_MCQE_QPVALID)\r\nqp = dev->qp_tbl[cqe->qpvalid_qpid & OCRDMA_AE_MCQE_QPID_MASK];\r\nif (cqe->cqvalid_cqid & OCRDMA_AE_MCQE_CQVALID)\r\ncq = dev->cq_tbl[cqe->cqvalid_cqid & OCRDMA_AE_MCQE_CQID_MASK];\r\nmemset(&ib_evt, 0, sizeof(ib_evt));\r\nib_evt.device = &dev->ibdev;\r\nswitch (type) {\r\ncase OCRDMA_CQ_ERROR:\r\nib_evt.element.cq = &cq->ibcq;\r\nib_evt.event = IB_EVENT_CQ_ERR;\r\ncq_event = 1;\r\nqp_event = 0;\r\nbreak;\r\ncase OCRDMA_CQ_OVERRUN_ERROR:\r\nib_evt.element.cq = &cq->ibcq;\r\nib_evt.event = IB_EVENT_CQ_ERR;\r\ncq_event = 1;\r\nqp_event = 0;\r\nbreak;\r\ncase OCRDMA_CQ_QPCAT_ERROR:\r\nib_evt.element.qp = &qp->ibqp;\r\nib_evt.event = IB_EVENT_QP_FATAL;\r\nocrdma_process_qpcat_error(dev, qp);\r\nbreak;\r\ncase OCRDMA_QP_ACCESS_ERROR:\r\nib_evt.element.qp = &qp->ibqp;\r\nib_evt.event = IB_EVENT_QP_ACCESS_ERR;\r\nbreak;\r\ncase OCRDMA_QP_COMM_EST_EVENT:\r\nib_evt.element.qp = &qp->ibqp;\r\nib_evt.event = IB_EVENT_COMM_EST;\r\nbreak;\r\ncase OCRDMA_SQ_DRAINED_EVENT:\r\nib_evt.element.qp = &qp->ibqp;\r\nib_evt.event = IB_EVENT_SQ_DRAINED;\r\nbreak;\r\ncase OCRDMA_DEVICE_FATAL_EVENT:\r\nib_evt.element.port_num = 1;\r\nib_evt.event = IB_EVENT_DEVICE_FATAL;\r\nqp_event = 0;\r\ndev_event = 1;\r\nbreak;\r\ncase OCRDMA_SRQCAT_ERROR:\r\nib_evt.element.srq = &qp->srq->ibsrq;\r\nib_evt.event = IB_EVENT_SRQ_ERR;\r\nsrq_event = 1;\r\nqp_event = 0;\r\nbreak;\r\ncase OCRDMA_SRQ_LIMIT_EVENT:\r\nib_evt.element.srq = &qp->srq->ibsrq;\r\nib_evt.event = IB_EVENT_SRQ_LIMIT_REACHED;\r\nsrq_event = 1;\r\nqp_event = 0;\r\nbreak;\r\ncase OCRDMA_QP_LAST_WQE_EVENT:\r\nib_evt.element.qp = &qp->ibqp;\r\nib_evt.event = IB_EVENT_QP_LAST_WQE_REACHED;\r\nbreak;\r\ndefault:\r\ncq_event = 0;\r\nqp_event = 0;\r\nsrq_event = 0;\r\ndev_event = 0;\r\npr_err("%s() unknown type=0x%x\n", __func__, type);\r\nbreak;\r\n}\r\nif (type < OCRDMA_MAX_ASYNC_ERRORS)\r\natomic_inc(&dev->async_err_stats[type]);\r\nif (qp_event) {\r\nif (qp->ibqp.event_handler)\r\nqp->ibqp.event_handler(&ib_evt, qp->ibqp.qp_context);\r\n} else if (cq_event) {\r\nif (cq->ibcq.event_handler)\r\ncq->ibcq.event_handler(&ib_evt, cq->ibcq.cq_context);\r\n} else if (srq_event) {\r\nif (qp->srq->ibsrq.event_handler)\r\nqp->srq->ibsrq.event_handler(&ib_evt,\r\nqp->srq->ibsrq.\r\nsrq_context);\r\n} else if (dev_event) {\r\npr_err("%s: Fatal event received\n", dev->ibdev.name);\r\nib_dispatch_event(&ib_evt);\r\n}\r\n}\r\nstatic void ocrdma_process_grp5_aync(struct ocrdma_dev *dev,\r\nstruct ocrdma_ae_mcqe *cqe)\r\n{\r\nstruct ocrdma_ae_pvid_mcqe *evt;\r\nint type = (cqe->valid_ae_event & OCRDMA_AE_MCQE_EVENT_TYPE_MASK) >>\r\nOCRDMA_AE_MCQE_EVENT_TYPE_SHIFT;\r\nswitch (type) {\r\ncase OCRDMA_ASYNC_EVENT_PVID_STATE:\r\nevt = (struct ocrdma_ae_pvid_mcqe *)cqe;\r\nif ((evt->tag_enabled & OCRDMA_AE_PVID_MCQE_ENABLED_MASK) >>\r\nOCRDMA_AE_PVID_MCQE_ENABLED_SHIFT)\r\ndev->pvid = ((evt->tag_enabled &\r\nOCRDMA_AE_PVID_MCQE_TAG_MASK) >>\r\nOCRDMA_AE_PVID_MCQE_TAG_SHIFT);\r\nbreak;\r\ncase OCRDMA_ASYNC_EVENT_COS_VALUE:\r\natomic_set(&dev->update_sl, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ocrdma_process_acqe(struct ocrdma_dev *dev, void *ae_cqe)\r\n{\r\nstruct ocrdma_ae_mcqe *cqe = ae_cqe;\r\nu32 evt_code = (cqe->valid_ae_event & OCRDMA_AE_MCQE_EVENT_CODE_MASK) >>\r\nOCRDMA_AE_MCQE_EVENT_CODE_SHIFT;\r\nif (evt_code == OCRDMA_ASYNC_RDMA_EVE_CODE)\r\nocrdma_dispatch_ibevent(dev, cqe);\r\nelse if (evt_code == OCRDMA_ASYNC_GRP5_EVE_CODE)\r\nocrdma_process_grp5_aync(dev, cqe);\r\nelse\r\npr_err("%s(%d) invalid evt code=0x%x\n", __func__,\r\ndev->id, evt_code);\r\n}\r\nstatic void ocrdma_process_mcqe(struct ocrdma_dev *dev, struct ocrdma_mcqe *cqe)\r\n{\r\nif (dev->mqe_ctx.tag == cqe->tag_lo && dev->mqe_ctx.cmd_done == false) {\r\ndev->mqe_ctx.cqe_status = (cqe->status &\r\nOCRDMA_MCQE_STATUS_MASK) >> OCRDMA_MCQE_STATUS_SHIFT;\r\ndev->mqe_ctx.ext_status =\r\n(cqe->status & OCRDMA_MCQE_ESTATUS_MASK)\r\n>> OCRDMA_MCQE_ESTATUS_SHIFT;\r\ndev->mqe_ctx.cmd_done = true;\r\nwake_up(&dev->mqe_ctx.cmd_wait);\r\n} else\r\npr_err("%s() cqe for invalid tag0x%x.expected=0x%x\n",\r\n__func__, cqe->tag_lo, dev->mqe_ctx.tag);\r\n}\r\nstatic int ocrdma_mq_cq_handler(struct ocrdma_dev *dev, u16 cq_id)\r\n{\r\nu16 cqe_popped = 0;\r\nstruct ocrdma_mcqe *cqe;\r\nwhile (1) {\r\ncqe = ocrdma_get_mcqe(dev);\r\nif (cqe == NULL)\r\nbreak;\r\nocrdma_le32_to_cpu(cqe, sizeof(*cqe));\r\ncqe_popped += 1;\r\nif (cqe->valid_ae_cmpl_cons & OCRDMA_MCQE_AE_MASK)\r\nocrdma_process_acqe(dev, cqe);\r\nelse if (cqe->valid_ae_cmpl_cons & OCRDMA_MCQE_CMPL_MASK)\r\nocrdma_process_mcqe(dev, cqe);\r\nmemset(cqe, 0, sizeof(struct ocrdma_mcqe));\r\nocrdma_mcq_inc_tail(dev);\r\n}\r\nocrdma_ring_cq_db(dev, dev->mq.cq.id, true, false, cqe_popped);\r\nreturn 0;\r\n}\r\nstatic struct ocrdma_cq *_ocrdma_qp_buddy_cq_handler(struct ocrdma_dev *dev,\r\nstruct ocrdma_cq *cq, bool sq)\r\n{\r\nstruct ocrdma_qp *qp;\r\nstruct list_head *cur;\r\nstruct ocrdma_cq *bcq = NULL;\r\nstruct list_head *head = sq?(&cq->sq_head):(&cq->rq_head);\r\nlist_for_each(cur, head) {\r\nif (sq)\r\nqp = list_entry(cur, struct ocrdma_qp, sq_entry);\r\nelse\r\nqp = list_entry(cur, struct ocrdma_qp, rq_entry);\r\nif (qp->srq)\r\ncontinue;\r\nif (qp->sq_cq == qp->rq_cq)\r\ncontinue;\r\nif (qp->sq_cq == cq)\r\nbcq = qp->rq_cq;\r\nelse\r\nbcq = qp->sq_cq;\r\nreturn bcq;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ocrdma_qp_buddy_cq_handler(struct ocrdma_dev *dev,\r\nstruct ocrdma_cq *cq)\r\n{\r\nunsigned long flags;\r\nstruct ocrdma_cq *bcq = NULL;\r\nspin_lock_irqsave(&dev->flush_q_lock, flags);\r\nbcq = _ocrdma_qp_buddy_cq_handler(dev, cq, true);\r\nif (bcq == NULL)\r\nbcq = _ocrdma_qp_buddy_cq_handler(dev, cq, false);\r\nspin_unlock_irqrestore(&dev->flush_q_lock, flags);\r\nif (bcq && bcq->ibcq.comp_handler) {\r\nspin_lock_irqsave(&bcq->comp_handler_lock, flags);\r\n(*bcq->ibcq.comp_handler) (&bcq->ibcq, bcq->ibcq.cq_context);\r\nspin_unlock_irqrestore(&bcq->comp_handler_lock, flags);\r\n}\r\n}\r\nstatic void ocrdma_qp_cq_handler(struct ocrdma_dev *dev, u16 cq_idx)\r\n{\r\nunsigned long flags;\r\nstruct ocrdma_cq *cq;\r\nif (cq_idx >= OCRDMA_MAX_CQ)\r\nBUG();\r\ncq = dev->cq_tbl[cq_idx];\r\nif (cq == NULL)\r\nreturn;\r\nif (cq->ibcq.comp_handler) {\r\nspin_lock_irqsave(&cq->comp_handler_lock, flags);\r\n(*cq->ibcq.comp_handler) (&cq->ibcq, cq->ibcq.cq_context);\r\nspin_unlock_irqrestore(&cq->comp_handler_lock, flags);\r\n}\r\nocrdma_qp_buddy_cq_handler(dev, cq);\r\n}\r\nstatic void ocrdma_cq_handler(struct ocrdma_dev *dev, u16 cq_id)\r\n{\r\nif (cq_id == dev->mq.cq.id)\r\nocrdma_mq_cq_handler(dev, cq_id);\r\nelse\r\nocrdma_qp_cq_handler(dev, cq_id);\r\n}\r\nstatic irqreturn_t ocrdma_irq_handler(int irq, void *handle)\r\n{\r\nstruct ocrdma_eq *eq = handle;\r\nstruct ocrdma_dev *dev = eq->dev;\r\nstruct ocrdma_eqe eqe;\r\nstruct ocrdma_eqe *ptr;\r\nu16 cq_id;\r\nu8 mcode;\r\nint budget = eq->cq_cnt;\r\ndo {\r\nptr = ocrdma_get_eqe(eq);\r\neqe = *ptr;\r\nocrdma_le32_to_cpu(&eqe, sizeof(eqe));\r\nmcode = (eqe.id_valid & OCRDMA_EQE_MAJOR_CODE_MASK)\r\n>> OCRDMA_EQE_MAJOR_CODE_SHIFT;\r\nif (mcode == OCRDMA_MAJOR_CODE_SENTINAL)\r\npr_err("EQ full on eqid = 0x%x, eqe = 0x%x\n",\r\neq->q.id, eqe.id_valid);\r\nif ((eqe.id_valid & OCRDMA_EQE_VALID_MASK) == 0)\r\nbreak;\r\nptr->id_valid = 0;\r\nocrdma_ring_eq_db(dev, eq->q.id, false, true, 1);\r\nif ((eqe.id_valid & OCRDMA_EQE_FOR_CQE_MASK) == 0) {\r\ncq_id = eqe.id_valid >> OCRDMA_EQE_RESOURCE_ID_SHIFT;\r\nocrdma_cq_handler(dev, cq_id);\r\n}\r\nocrdma_eq_inc_tail(eq);\r\nif (budget)\r\nbudget--;\r\n} while (budget);\r\neq->aic_obj.eq_intr_cnt++;\r\nocrdma_ring_eq_db(dev, eq->q.id, true, true, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ocrdma_post_mqe(struct ocrdma_dev *dev, struct ocrdma_mqe *cmd)\r\n{\r\nstruct ocrdma_mqe *mqe;\r\ndev->mqe_ctx.tag = dev->mq.sq.head;\r\ndev->mqe_ctx.cmd_done = false;\r\nmqe = ocrdma_get_mqe(dev);\r\ncmd->hdr.tag_lo = dev->mq.sq.head;\r\nocrdma_copy_cpu_to_le32(mqe, cmd, sizeof(*mqe));\r\nwmb();\r\nocrdma_mq_inc_head(dev);\r\nocrdma_ring_mq_db(dev);\r\n}\r\nstatic int ocrdma_wait_mqe_cmpl(struct ocrdma_dev *dev)\r\n{\r\nlong status;\r\nstatus = wait_event_timeout(dev->mqe_ctx.cmd_wait,\r\n(dev->mqe_ctx.cmd_done != false),\r\nmsecs_to_jiffies(30000));\r\nif (status)\r\nreturn 0;\r\nelse {\r\ndev->mqe_ctx.fw_error_state = true;\r\npr_err("%s(%d) mailbox timeout: fw not responding\n",\r\n__func__, dev->id);\r\nreturn -1;\r\n}\r\n}\r\nstatic int ocrdma_mbx_cmd(struct ocrdma_dev *dev, struct ocrdma_mqe *mqe)\r\n{\r\nint status = 0;\r\nu16 cqe_status, ext_status;\r\nstruct ocrdma_mqe *rsp_mqe;\r\nstruct ocrdma_mbx_rsp *rsp = NULL;\r\nmutex_lock(&dev->mqe_ctx.lock);\r\nif (dev->mqe_ctx.fw_error_state)\r\ngoto mbx_err;\r\nocrdma_post_mqe(dev, mqe);\r\nstatus = ocrdma_wait_mqe_cmpl(dev);\r\nif (status)\r\ngoto mbx_err;\r\ncqe_status = dev->mqe_ctx.cqe_status;\r\next_status = dev->mqe_ctx.ext_status;\r\nrsp_mqe = ocrdma_get_mqe_rsp(dev);\r\nocrdma_copy_le32_to_cpu(mqe, rsp_mqe, (sizeof(*mqe)));\r\nif ((mqe->hdr.spcl_sge_cnt_emb & OCRDMA_MQE_HDR_EMB_MASK) >>\r\nOCRDMA_MQE_HDR_EMB_SHIFT)\r\nrsp = &mqe->u.rsp;\r\nif (cqe_status || ext_status) {\r\npr_err("%s() cqe_status=0x%x, ext_status=0x%x,",\r\n__func__, cqe_status, ext_status);\r\nif (rsp) {\r\npr_err("opcode=0x%x, subsystem=0x%x\n",\r\n(rsp->subsys_op & OCRDMA_MBX_RSP_OPCODE_MASK) >>\r\nOCRDMA_MBX_RSP_OPCODE_SHIFT,\r\n(rsp->subsys_op & OCRDMA_MBX_RSP_SUBSYS_MASK) >>\r\nOCRDMA_MBX_RSP_SUBSYS_SHIFT);\r\n}\r\nstatus = ocrdma_get_mbx_cqe_errno(cqe_status);\r\ngoto mbx_err;\r\n}\r\nif (rsp && (mqe->u.rsp.status & OCRDMA_MBX_RSP_STATUS_MASK))\r\nstatus = ocrdma_get_mbx_errno(mqe->u.rsp.status);\r\nmbx_err:\r\nmutex_unlock(&dev->mqe_ctx.lock);\r\nreturn status;\r\n}\r\nstatic int ocrdma_nonemb_mbx_cmd(struct ocrdma_dev *dev, struct ocrdma_mqe *mqe,\r\nvoid *payload_va)\r\n{\r\nint status = 0;\r\nstruct ocrdma_mbx_rsp *rsp = payload_va;\r\nif ((mqe->hdr.spcl_sge_cnt_emb & OCRDMA_MQE_HDR_EMB_MASK) >>\r\nOCRDMA_MQE_HDR_EMB_SHIFT)\r\nBUG();\r\nstatus = ocrdma_mbx_cmd(dev, mqe);\r\nif (!status)\r\nif (rsp->status & OCRDMA_MBX_RSP_STATUS_MASK)\r\nstatus = ocrdma_get_mbx_errno(rsp->status);\r\nif (status)\r\npr_err("opcode=0x%x, subsystem=0x%x\n",\r\n(rsp->subsys_op & OCRDMA_MBX_RSP_OPCODE_MASK) >>\r\nOCRDMA_MBX_RSP_OPCODE_SHIFT,\r\n(rsp->subsys_op & OCRDMA_MBX_RSP_SUBSYS_MASK) >>\r\nOCRDMA_MBX_RSP_SUBSYS_SHIFT);\r\nreturn status;\r\n}\r\nstatic void ocrdma_get_attr(struct ocrdma_dev *dev,\r\nstruct ocrdma_dev_attr *attr,\r\nstruct ocrdma_mbx_query_config *rsp)\r\n{\r\nattr->max_pd =\r\n(rsp->max_pd_ca_ack_delay & OCRDMA_MBX_QUERY_CFG_MAX_PD_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_PD_SHIFT;\r\nattr->max_dpp_pds =\r\n(rsp->max_dpp_pds_credits & OCRDMA_MBX_QUERY_CFG_MAX_DPP_PDS_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_DPP_PDS_OFFSET;\r\nattr->max_qp =\r\n(rsp->qp_srq_cq_ird_ord & OCRDMA_MBX_QUERY_CFG_MAX_QP_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_QP_SHIFT;\r\nattr->max_srq =\r\n(rsp->max_srq_rpir_qps & OCRDMA_MBX_QUERY_CFG_MAX_SRQ_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_SRQ_OFFSET;\r\nattr->max_send_sge = ((rsp->max_write_send_sge &\r\nOCRDMA_MBX_QUERY_CFG_MAX_SEND_SGE_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_SEND_SGE_SHIFT);\r\nattr->max_recv_sge = (rsp->max_write_send_sge &\r\nOCRDMA_MBX_QUERY_CFG_MAX_SEND_SGE_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_SEND_SGE_SHIFT;\r\nattr->max_srq_sge = (rsp->max_srq_rqe_sge &\r\nOCRDMA_MBX_QUERY_CFG_MAX_SRQ_SGE_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_SRQ_SGE_OFFSET;\r\nattr->max_rdma_sge = (rsp->max_write_send_sge &\r\nOCRDMA_MBX_QUERY_CFG_MAX_WRITE_SGE_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_WRITE_SGE_SHIFT;\r\nattr->max_ord_per_qp = (rsp->max_ird_ord_per_qp &\r\nOCRDMA_MBX_QUERY_CFG_MAX_ORD_PER_QP_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_ORD_PER_QP_SHIFT;\r\nattr->max_ird_per_qp = (rsp->max_ird_ord_per_qp &\r\nOCRDMA_MBX_QUERY_CFG_MAX_IRD_PER_QP_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_IRD_PER_QP_SHIFT;\r\nattr->cq_overflow_detect = (rsp->qp_srq_cq_ird_ord &\r\nOCRDMA_MBX_QUERY_CFG_CQ_OVERFLOW_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_CQ_OVERFLOW_SHIFT;\r\nattr->srq_supported = (rsp->qp_srq_cq_ird_ord &\r\nOCRDMA_MBX_QUERY_CFG_SRQ_SUPPORTED_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_SRQ_SUPPORTED_SHIFT;\r\nattr->local_ca_ack_delay = (rsp->max_pd_ca_ack_delay &\r\nOCRDMA_MBX_QUERY_CFG_CA_ACK_DELAY_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_CA_ACK_DELAY_SHIFT;\r\nattr->max_mw = rsp->max_mw;\r\nattr->max_mr = rsp->max_mr;\r\nattr->max_mr_size = ((u64)rsp->max_mr_size_hi << 32) |\r\nrsp->max_mr_size_lo;\r\nattr->max_fmr = 0;\r\nattr->max_pages_per_frmr = rsp->max_pages_per_frmr;\r\nattr->max_num_mr_pbl = rsp->max_num_mr_pbl;\r\nattr->max_cqe = rsp->max_cq_cqes_per_cq &\r\nOCRDMA_MBX_QUERY_CFG_MAX_CQES_PER_CQ_MASK;\r\nattr->max_cq = (rsp->max_cq_cqes_per_cq &\r\nOCRDMA_MBX_QUERY_CFG_MAX_CQ_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_CQ_OFFSET;\r\nattr->wqe_size = ((rsp->wqe_rqe_stride_max_dpp_cqs &\r\nOCRDMA_MBX_QUERY_CFG_MAX_WQE_SIZE_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_WQE_SIZE_OFFSET) *\r\nOCRDMA_WQE_STRIDE;\r\nattr->rqe_size = ((rsp->wqe_rqe_stride_max_dpp_cqs &\r\nOCRDMA_MBX_QUERY_CFG_MAX_RQE_SIZE_MASK) >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_RQE_SIZE_OFFSET) *\r\nOCRDMA_WQE_STRIDE;\r\nattr->max_inline_data =\r\nattr->wqe_size - (sizeof(struct ocrdma_hdr_wqe) +\r\nsizeof(struct ocrdma_sge));\r\nif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {\r\nattr->ird = 1;\r\nattr->ird_page_size = OCRDMA_MIN_Q_PAGE_SIZE;\r\nattr->num_ird_pages = MAX_OCRDMA_IRD_PAGES;\r\n}\r\ndev->attr.max_wqe = rsp->max_wqes_rqes_per_q >>\r\nOCRDMA_MBX_QUERY_CFG_MAX_WQES_PER_WQ_OFFSET;\r\ndev->attr.max_rqe = rsp->max_wqes_rqes_per_q &\r\nOCRDMA_MBX_QUERY_CFG_MAX_RQES_PER_RQ_MASK;\r\n}\r\nstatic int ocrdma_check_fw_config(struct ocrdma_dev *dev,\r\nstruct ocrdma_fw_conf_rsp *conf)\r\n{\r\nu32 fn_mode;\r\nfn_mode = conf->fn_mode & OCRDMA_FN_MODE_RDMA;\r\nif (fn_mode != OCRDMA_FN_MODE_RDMA)\r\nreturn -EINVAL;\r\ndev->base_eqid = conf->base_eqid;\r\ndev->max_eq = conf->max_eq;\r\nreturn 0;\r\n}\r\nstatic int ocrdma_mbx_query_fw_ver(struct ocrdma_dev *dev)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_mqe *cmd;\r\nstruct ocrdma_fw_ver_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_GET_FW_VER, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\r\nOCRDMA_CMD_GET_FW_VER,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_fw_ver_rsp *)cmd;\r\nmemset(&dev->attr.fw_ver[0], 0, sizeof(dev->attr.fw_ver));\r\nmemcpy(&dev->attr.fw_ver[0], &rsp->running_ver[0],\r\nsizeof(rsp->running_ver));\r\nocrdma_le32_to_cpu(dev->attr.fw_ver, sizeof(rsp->running_ver));\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_query_fw_config(struct ocrdma_dev *dev)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_mqe *cmd;\r\nstruct ocrdma_fw_conf_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_GET_FW_CONFIG, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\r\nOCRDMA_CMD_GET_FW_CONFIG,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_fw_conf_rsp *)cmd;\r\nstatus = ocrdma_check_fw_config(dev, rsp);\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_rdma_stats(struct ocrdma_dev *dev, bool reset)\r\n{\r\nstruct ocrdma_rdma_stats_req *req = dev->stats_mem.va;\r\nstruct ocrdma_mqe *mqe = &dev->stats_mem.mqe;\r\nstruct ocrdma_rdma_stats_resp *old_stats;\r\nint status;\r\nold_stats = kmalloc(sizeof(*old_stats), GFP_KERNEL);\r\nif (old_stats == NULL)\r\nreturn -ENOMEM;\r\nmemset(mqe, 0, sizeof(*mqe));\r\nmqe->hdr.pyld_len = dev->stats_mem.size;\r\nmqe->hdr.spcl_sge_cnt_emb |=\r\n(1 << OCRDMA_MQE_HDR_SGE_CNT_SHIFT) &\r\nOCRDMA_MQE_HDR_SGE_CNT_MASK;\r\nmqe->u.nonemb_req.sge[0].pa_lo = (u32) (dev->stats_mem.pa & 0xffffffff);\r\nmqe->u.nonemb_req.sge[0].pa_hi = (u32) upper_32_bits(dev->stats_mem.pa);\r\nmqe->u.nonemb_req.sge[0].len = dev->stats_mem.size;\r\nmemcpy(old_stats, req, sizeof(struct ocrdma_rdma_stats_resp));\r\nmemset(req, 0, dev->stats_mem.size);\r\nocrdma_init_mch((struct ocrdma_mbx_hdr *)req,\r\nOCRDMA_CMD_GET_RDMA_STATS,\r\nOCRDMA_SUBSYS_ROCE,\r\ndev->stats_mem.size);\r\nif (reset)\r\nreq->reset_stats = reset;\r\nstatus = ocrdma_nonemb_mbx_cmd(dev, mqe, dev->stats_mem.va);\r\nif (status)\r\nmemcpy(req, old_stats, sizeof(struct ocrdma_rdma_stats_resp));\r\nelse\r\nocrdma_le32_to_cpu(req, dev->stats_mem.size);\r\nkfree(old_stats);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_get_ctrl_attribs(struct ocrdma_dev *dev)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_dma_mem dma;\r\nstruct ocrdma_mqe *mqe;\r\nstruct ocrdma_get_ctrl_attribs_rsp *ctrl_attr_rsp;\r\nstruct mgmt_hba_attribs *hba_attribs;\r\nmqe = kzalloc(sizeof(struct ocrdma_mqe), GFP_KERNEL);\r\nif (!mqe)\r\nreturn status;\r\ndma.size = sizeof(struct ocrdma_get_ctrl_attribs_rsp);\r\ndma.va = dma_alloc_coherent(&dev->nic_info.pdev->dev,\r\ndma.size, &dma.pa, GFP_KERNEL);\r\nif (!dma.va)\r\ngoto free_mqe;\r\nmqe->hdr.pyld_len = dma.size;\r\nmqe->hdr.spcl_sge_cnt_emb |=\r\n(1 << OCRDMA_MQE_HDR_SGE_CNT_SHIFT) &\r\nOCRDMA_MQE_HDR_SGE_CNT_MASK;\r\nmqe->u.nonemb_req.sge[0].pa_lo = (u32) (dma.pa & 0xffffffff);\r\nmqe->u.nonemb_req.sge[0].pa_hi = (u32) upper_32_bits(dma.pa);\r\nmqe->u.nonemb_req.sge[0].len = dma.size;\r\nmemset(dma.va, 0, dma.size);\r\nocrdma_init_mch((struct ocrdma_mbx_hdr *)dma.va,\r\nOCRDMA_CMD_GET_CTRL_ATTRIBUTES,\r\nOCRDMA_SUBSYS_COMMON,\r\ndma.size);\r\nstatus = ocrdma_nonemb_mbx_cmd(dev, mqe, dma.va);\r\nif (!status) {\r\nctrl_attr_rsp = (struct ocrdma_get_ctrl_attribs_rsp *)dma.va;\r\nhba_attribs = &ctrl_attr_rsp->ctrl_attribs.hba_attribs;\r\ndev->hba_port_num = (hba_attribs->ptpnum_maxdoms_hbast_cv &\r\nOCRDMA_HBA_ATTRB_PTNUM_MASK)\r\n>> OCRDMA_HBA_ATTRB_PTNUM_SHIFT;\r\nstrncpy(dev->model_number,\r\nhba_attribs->controller_model_number, 31);\r\n}\r\ndma_free_coherent(&dev->nic_info.pdev->dev, dma.size, dma.va, dma.pa);\r\nfree_mqe:\r\nkfree(mqe);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_query_dev(struct ocrdma_dev *dev)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_mbx_query_config *rsp;\r\nstruct ocrdma_mqe *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_CONFIG, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_mbx_query_config *)cmd;\r\nocrdma_get_attr(dev, &dev->attr, rsp);\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_get_link_speed(struct ocrdma_dev *dev, u8 *lnk_speed)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_get_link_speed_rsp *rsp;\r\nstruct ocrdma_mqe *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_NTWK_LINK_CONFIG_V1,\r\nsizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\r\nOCRDMA_CMD_QUERY_NTWK_LINK_CONFIG_V1,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\n((struct ocrdma_mbx_hdr *)cmd->u.cmd)->rsvd_version = 0x1;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_get_link_speed_rsp *)cmd;\r\n*lnk_speed = (rsp->pflt_pps_ld_pnum & OCRDMA_PHY_PS_MASK)\r\n>> OCRDMA_PHY_PS_SHIFT;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_get_phy_info(struct ocrdma_dev *dev)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_mqe *cmd;\r\nstruct ocrdma_get_phy_info_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_PHY_DETAILS, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\r\nOCRDMA_CMD_PHY_DETAILS, OCRDMA_SUBSYS_COMMON,\r\nsizeof(*cmd));\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_get_phy_info_rsp *)cmd;\r\ndev->phy.phy_type =\r\n(rsp->ityp_ptyp & OCRDMA_PHY_TYPE_MASK);\r\ndev->phy.interface_type =\r\n(rsp->ityp_ptyp & OCRDMA_IF_TYPE_MASK)\r\n>> OCRDMA_IF_TYPE_SHIFT;\r\ndev->phy.auto_speeds_supported =\r\n(rsp->fspeed_aspeed & OCRDMA_ASPEED_SUPP_MASK);\r\ndev->phy.fixed_speeds_supported =\r\n(rsp->fspeed_aspeed & OCRDMA_FSPEED_SUPP_MASK)\r\n>> OCRDMA_FSPEED_SUPP_SHIFT;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_alloc_pd(struct ocrdma_dev *dev, struct ocrdma_pd *pd)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_alloc_pd *cmd;\r\nstruct ocrdma_alloc_pd_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_PD, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nif (pd->dpp_enabled)\r\ncmd->enable_dpp_rsvd |= OCRDMA_ALLOC_PD_ENABLE_DPP;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_alloc_pd_rsp *)cmd;\r\npd->id = rsp->dpp_page_pdid & OCRDMA_ALLOC_PD_RSP_PDID_MASK;\r\nif (rsp->dpp_page_pdid & OCRDMA_ALLOC_PD_RSP_DPP) {\r\npd->dpp_enabled = true;\r\npd->dpp_page = rsp->dpp_page_pdid >>\r\nOCRDMA_ALLOC_PD_RSP_DPP_PAGE_SHIFT;\r\n} else {\r\npd->dpp_enabled = false;\r\npd->num_dpp_qp = 0;\r\n}\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_dealloc_pd(struct ocrdma_dev *dev, struct ocrdma_pd *pd)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_dealloc_pd *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_PD, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->id = pd->id;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_alloc_pd_range(struct ocrdma_dev *dev)\r\n{\r\nint status = -ENOMEM;\r\nsize_t pd_bitmap_size;\r\nstruct ocrdma_alloc_pd_range *cmd;\r\nstruct ocrdma_alloc_pd_range_rsp *rsp;\r\nif (dev->attr.max_dpp_pds) {\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_PD_RANGE,\r\nsizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->pd_count = dev->attr.max_dpp_pds;\r\ncmd->enable_dpp_rsvd |= OCRDMA_ALLOC_PD_ENABLE_DPP;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nrsp = (struct ocrdma_alloc_pd_range_rsp *)cmd;\r\nif (!status && (rsp->dpp_page_pdid & OCRDMA_ALLOC_PD_RSP_DPP) &&\r\nrsp->pd_count) {\r\ndev->pd_mgr->dpp_page_index = rsp->dpp_page_pdid >>\r\nOCRDMA_ALLOC_PD_RSP_DPP_PAGE_SHIFT;\r\ndev->pd_mgr->pd_dpp_start = rsp->dpp_page_pdid &\r\nOCRDMA_ALLOC_PD_RNG_RSP_START_PDID_MASK;\r\ndev->pd_mgr->max_dpp_pd = rsp->pd_count;\r\npd_bitmap_size =\r\nBITS_TO_LONGS(rsp->pd_count) * sizeof(long);\r\ndev->pd_mgr->pd_dpp_bitmap = kzalloc(pd_bitmap_size,\r\nGFP_KERNEL);\r\n}\r\nkfree(cmd);\r\n}\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_PD_RANGE, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->pd_count = dev->attr.max_pd - dev->attr.max_dpp_pds;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nrsp = (struct ocrdma_alloc_pd_range_rsp *)cmd;\r\nif (!status && rsp->pd_count) {\r\ndev->pd_mgr->pd_norm_start = rsp->dpp_page_pdid &\r\nOCRDMA_ALLOC_PD_RNG_RSP_START_PDID_MASK;\r\ndev->pd_mgr->max_normal_pd = rsp->pd_count;\r\npd_bitmap_size = BITS_TO_LONGS(rsp->pd_count) * sizeof(long);\r\ndev->pd_mgr->pd_norm_bitmap = kzalloc(pd_bitmap_size,\r\nGFP_KERNEL);\r\n}\r\nkfree(cmd);\r\nif (dev->pd_mgr->pd_norm_bitmap || dev->pd_mgr->pd_dpp_bitmap) {\r\ndev->pd_mgr->pd_prealloc_valid = true;\r\nreturn 0;\r\n}\r\nreturn status;\r\n}\r\nstatic void ocrdma_mbx_dealloc_pd_range(struct ocrdma_dev *dev)\r\n{\r\nstruct ocrdma_dealloc_pd_range *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_PD_RANGE, sizeof(*cmd));\r\nif (!cmd)\r\ngoto mbx_err;\r\nif (dev->pd_mgr->max_normal_pd) {\r\ncmd->start_pd_id = dev->pd_mgr->pd_norm_start;\r\ncmd->pd_count = dev->pd_mgr->max_normal_pd;\r\nocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\n}\r\nif (dev->pd_mgr->max_dpp_pd) {\r\nkfree(cmd);\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_PD_RANGE,\r\nsizeof(*cmd));\r\nif (!cmd)\r\ngoto mbx_err;\r\ncmd->start_pd_id = dev->pd_mgr->pd_dpp_start;\r\ncmd->pd_count = dev->pd_mgr->max_dpp_pd;\r\nocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\n}\r\nmbx_err:\r\nkfree(cmd);\r\n}\r\nvoid ocrdma_alloc_pd_pool(struct ocrdma_dev *dev)\r\n{\r\nint status;\r\ndev->pd_mgr = kzalloc(sizeof(struct ocrdma_pd_resource_mgr),\r\nGFP_KERNEL);\r\nif (!dev->pd_mgr) {\r\npr_err("%s(%d)Memory allocation failure.\n", __func__, dev->id);\r\nreturn;\r\n}\r\nstatus = ocrdma_mbx_alloc_pd_range(dev);\r\nif (status) {\r\npr_err("%s(%d) Unable to initialize PD pool, using default.\n",\r\n__func__, dev->id);\r\n}\r\n}\r\nstatic void ocrdma_free_pd_pool(struct ocrdma_dev *dev)\r\n{\r\nocrdma_mbx_dealloc_pd_range(dev);\r\nkfree(dev->pd_mgr->pd_norm_bitmap);\r\nkfree(dev->pd_mgr->pd_dpp_bitmap);\r\nkfree(dev->pd_mgr);\r\n}\r\nstatic int ocrdma_build_q_conf(u32 *num_entries, int entry_size,\r\nint *num_pages, int *page_size)\r\n{\r\nint i;\r\nint mem_size;\r\n*num_entries = roundup_pow_of_two(*num_entries);\r\nmem_size = *num_entries * entry_size;\r\nfor (i = 0; i < OCRDMA_MAX_Q_PAGE_SIZE_CNT; i++) {\r\nif (mem_size <= (OCRDMA_Q_PAGE_BASE_SIZE << i))\r\nbreak;\r\n}\r\nif (i >= OCRDMA_MAX_Q_PAGE_SIZE_CNT)\r\nreturn -EINVAL;\r\nmem_size = roundup(mem_size,\r\n((OCRDMA_Q_PAGE_BASE_SIZE << i) / OCRDMA_MAX_Q_PAGES));\r\n*num_pages =\r\nmem_size / ((OCRDMA_Q_PAGE_BASE_SIZE << i) / OCRDMA_MAX_Q_PAGES);\r\n*page_size = ((OCRDMA_Q_PAGE_BASE_SIZE << i) / OCRDMA_MAX_Q_PAGES);\r\n*num_entries = mem_size / entry_size;\r\nreturn 0;\r\n}\r\nstatic int ocrdma_mbx_create_ah_tbl(struct ocrdma_dev *dev)\r\n{\r\nint i;\r\nint status = 0;\r\nint max_ah;\r\nstruct ocrdma_create_ah_tbl *cmd;\r\nstruct ocrdma_create_ah_tbl_rsp *rsp;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\ndma_addr_t pa;\r\nstruct ocrdma_pbe *pbes;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_AH_TBL, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nmax_ah = OCRDMA_MAX_AH;\r\ndev->av_tbl.size = sizeof(struct ocrdma_av) * max_ah;\r\ncmd->ah_conf = (OCRDMA_AH_TBL_PAGES <<\r\nOCRDMA_CREATE_AH_NUM_PAGES_SHIFT) &\r\nOCRDMA_CREATE_AH_NUM_PAGES_MASK;\r\nfor (i = 0; i < OCRDMA_MAX_Q_PAGE_SIZE_CNT; i++) {\r\nif (PAGE_SIZE == (OCRDMA_MIN_Q_PAGE_SIZE << i))\r\nbreak;\r\n}\r\ncmd->ah_conf |= (i << OCRDMA_CREATE_AH_PAGE_SIZE_SHIFT) &\r\nOCRDMA_CREATE_AH_PAGE_SIZE_MASK;\r\ncmd->ah_conf |= (sizeof(struct ocrdma_av) <<\r\nOCRDMA_CREATE_AH_ENTRY_SIZE_SHIFT) &\r\nOCRDMA_CREATE_AH_ENTRY_SIZE_MASK;\r\ndev->av_tbl.pbl.va = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,\r\n&dev->av_tbl.pbl.pa,\r\nGFP_KERNEL);\r\nif (dev->av_tbl.pbl.va == NULL)\r\ngoto mem_err;\r\ndev->av_tbl.va = dma_alloc_coherent(&pdev->dev, dev->av_tbl.size,\r\n&pa, GFP_KERNEL);\r\nif (dev->av_tbl.va == NULL)\r\ngoto mem_err_ah;\r\ndev->av_tbl.pa = pa;\r\ndev->av_tbl.num_ah = max_ah;\r\nmemset(dev->av_tbl.va, 0, dev->av_tbl.size);\r\npbes = (struct ocrdma_pbe *)dev->av_tbl.pbl.va;\r\nfor (i = 0; i < dev->av_tbl.size / OCRDMA_MIN_Q_PAGE_SIZE; i++) {\r\npbes[i].pa_lo = (u32)cpu_to_le32(pa & 0xffffffff);\r\npbes[i].pa_hi = (u32)cpu_to_le32(upper_32_bits(pa));\r\npa += PAGE_SIZE;\r\n}\r\ncmd->tbl_addr[0].lo = (u32)(dev->av_tbl.pbl.pa & 0xFFFFFFFF);\r\ncmd->tbl_addr[0].hi = (u32)upper_32_bits(dev->av_tbl.pbl.pa);\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_create_ah_tbl_rsp *)cmd;\r\ndev->av_tbl.ahid = rsp->ahid & 0xFFFF;\r\nkfree(cmd);\r\nreturn 0;\r\nmbx_err:\r\ndma_free_coherent(&pdev->dev, dev->av_tbl.size, dev->av_tbl.va,\r\ndev->av_tbl.pa);\r\ndev->av_tbl.va = NULL;\r\nmem_err_ah:\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, dev->av_tbl.pbl.va,\r\ndev->av_tbl.pbl.pa);\r\ndev->av_tbl.pbl.va = NULL;\r\ndev->av_tbl.size = 0;\r\nmem_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic void ocrdma_mbx_delete_ah_tbl(struct ocrdma_dev *dev)\r\n{\r\nstruct ocrdma_delete_ah_tbl *cmd;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nif (dev->av_tbl.va == NULL)\r\nreturn;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_AH_TBL, sizeof(*cmd));\r\nif (!cmd)\r\nreturn;\r\ncmd->ahid = dev->av_tbl.ahid;\r\nocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\ndma_free_coherent(&pdev->dev, dev->av_tbl.size, dev->av_tbl.va,\r\ndev->av_tbl.pa);\r\ndev->av_tbl.va = NULL;\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, dev->av_tbl.pbl.va,\r\ndev->av_tbl.pbl.pa);\r\nkfree(cmd);\r\n}\r\nstatic u16 ocrdma_bind_eq(struct ocrdma_dev *dev)\r\n{\r\nint i, selected_eq = 0, cq_cnt = 0;\r\nu16 eq_id;\r\nmutex_lock(&dev->dev_lock);\r\ncq_cnt = dev->eq_tbl[0].cq_cnt;\r\neq_id = dev->eq_tbl[0].q.id;\r\nfor (i = 0; i < dev->eq_cnt; i++) {\r\nif (dev->eq_tbl[i].cq_cnt < cq_cnt) {\r\ncq_cnt = dev->eq_tbl[i].cq_cnt;\r\neq_id = dev->eq_tbl[i].q.id;\r\nselected_eq = i;\r\n}\r\n}\r\ndev->eq_tbl[selected_eq].cq_cnt += 1;\r\nmutex_unlock(&dev->dev_lock);\r\nreturn eq_id;\r\n}\r\nstatic void ocrdma_unbind_eq(struct ocrdma_dev *dev, u16 eq_id)\r\n{\r\nint i;\r\nmutex_lock(&dev->dev_lock);\r\ni = ocrdma_get_eq_table_index(dev, eq_id);\r\nif (i == -EINVAL)\r\nBUG();\r\ndev->eq_tbl[i].cq_cnt -= 1;\r\nmutex_unlock(&dev->dev_lock);\r\n}\r\nint ocrdma_mbx_create_cq(struct ocrdma_dev *dev, struct ocrdma_cq *cq,\r\nint entries, int dpp_cq, u16 pd_id)\r\n{\r\nint status = -ENOMEM; int max_hw_cqe;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nstruct ocrdma_create_cq *cmd;\r\nstruct ocrdma_create_cq_rsp *rsp;\r\nu32 hw_pages, cqe_size, page_size, cqe_count;\r\nif (entries > dev->attr.max_cqe) {\r\npr_err("%s(%d) max_cqe=0x%x, requester_cqe=0x%x\n",\r\n__func__, dev->id, dev->attr.max_cqe, entries);\r\nreturn -EINVAL;\r\n}\r\nif (dpp_cq && (ocrdma_get_asic_type(dev) != OCRDMA_ASIC_GEN_SKH_R))\r\nreturn -EINVAL;\r\nif (dpp_cq) {\r\ncq->max_hw_cqe = 1;\r\nmax_hw_cqe = 1;\r\ncqe_size = OCRDMA_DPP_CQE_SIZE;\r\nhw_pages = 1;\r\n} else {\r\ncq->max_hw_cqe = dev->attr.max_cqe;\r\nmax_hw_cqe = dev->attr.max_cqe;\r\ncqe_size = sizeof(struct ocrdma_cqe);\r\nhw_pages = OCRDMA_CREATE_CQ_MAX_PAGES;\r\n}\r\ncq->len = roundup(max_hw_cqe * cqe_size, OCRDMA_MIN_Q_PAGE_SIZE);\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_CQ, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nocrdma_init_mch(&cmd->cmd.req, OCRDMA_CMD_CREATE_CQ,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\ncq->va = dma_alloc_coherent(&pdev->dev, cq->len, &cq->pa, GFP_KERNEL);\r\nif (!cq->va) {\r\nstatus = -ENOMEM;\r\ngoto mem_err;\r\n}\r\nmemset(cq->va, 0, cq->len);\r\npage_size = cq->len / hw_pages;\r\ncmd->cmd.pgsz_pgcnt = (page_size / OCRDMA_MIN_Q_PAGE_SIZE) <<\r\nOCRDMA_CREATE_CQ_PAGE_SIZE_SHIFT;\r\ncmd->cmd.pgsz_pgcnt |= hw_pages;\r\ncmd->cmd.ev_cnt_flags = OCRDMA_CREATE_CQ_DEF_FLAGS;\r\ncq->eqn = ocrdma_bind_eq(dev);\r\ncmd->cmd.req.rsvd_version = OCRDMA_CREATE_CQ_VER3;\r\ncqe_count = cq->len / cqe_size;\r\ncq->cqe_cnt = cqe_count;\r\nif (cqe_count > 1024) {\r\ncmd->cmd.ev_cnt_flags |= (0x3 << OCRDMA_CREATE_CQ_CNT_SHIFT);\r\n} else {\r\nu8 count = 0;\r\nswitch (cqe_count) {\r\ncase 256:\r\ncount = 0;\r\nbreak;\r\ncase 512:\r\ncount = 1;\r\nbreak;\r\ncase 1024:\r\ncount = 2;\r\nbreak;\r\ndefault:\r\ngoto mbx_err;\r\n}\r\ncmd->cmd.ev_cnt_flags |= (count << OCRDMA_CREATE_CQ_CNT_SHIFT);\r\n}\r\ncmd->cmd.eqn = cq->eqn;\r\nif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {\r\nif (dpp_cq)\r\ncmd->cmd.pgsz_pgcnt |= OCRDMA_CREATE_CQ_DPP <<\r\nOCRDMA_CREATE_CQ_TYPE_SHIFT;\r\ncq->phase_change = false;\r\ncmd->cmd.pdid_cqecnt = (cq->len / cqe_size);\r\n} else {\r\ncmd->cmd.pdid_cqecnt = (cq->len / cqe_size) - 1;\r\ncmd->cmd.ev_cnt_flags |= OCRDMA_CREATE_CQ_FLAGS_AUTO_VALID;\r\ncq->phase_change = true;\r\n}\r\ncmd->cmd.pdid_cqecnt |= (pd_id <<\r\nOCRDMA_CREATE_CQ_CMD_PDID_SHIFT);\r\nocrdma_build_q_pages(&cmd->cmd.pa[0], hw_pages, cq->pa, page_size);\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_create_cq_rsp *)cmd;\r\ncq->id = (u16) (rsp->rsp.cq_id & OCRDMA_CREATE_CQ_RSP_CQ_ID_MASK);\r\nkfree(cmd);\r\nreturn 0;\r\nmbx_err:\r\nocrdma_unbind_eq(dev, cq->eqn);\r\ndma_free_coherent(&pdev->dev, cq->len, cq->va, cq->pa);\r\nmem_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_destroy_cq(struct ocrdma_dev *dev, struct ocrdma_cq *cq)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_destroy_cq *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_CQ, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nocrdma_init_mch(&cmd->req, OCRDMA_CMD_DELETE_CQ,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\ncmd->bypass_flush_qid |=\r\n(cq->id << OCRDMA_DESTROY_CQ_QID_SHIFT) &\r\nOCRDMA_DESTROY_CQ_QID_MASK;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nocrdma_unbind_eq(dev, cq->eqn);\r\ndma_free_coherent(&dev->nic_info.pdev->dev, cq->len, cq->va, cq->pa);\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_alloc_lkey(struct ocrdma_dev *dev, struct ocrdma_hw_mr *hwmr,\r\nu32 pdid, int addr_check)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_alloc_lkey *cmd;\r\nstruct ocrdma_alloc_lkey_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_LKEY, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->pdid = pdid;\r\ncmd->pbl_sz_flags |= addr_check;\r\ncmd->pbl_sz_flags |= (hwmr->fr_mr << OCRDMA_ALLOC_LKEY_FMR_SHIFT);\r\ncmd->pbl_sz_flags |=\r\n(hwmr->remote_wr << OCRDMA_ALLOC_LKEY_REMOTE_WR_SHIFT);\r\ncmd->pbl_sz_flags |=\r\n(hwmr->remote_rd << OCRDMA_ALLOC_LKEY_REMOTE_RD_SHIFT);\r\ncmd->pbl_sz_flags |=\r\n(hwmr->local_wr << OCRDMA_ALLOC_LKEY_LOCAL_WR_SHIFT);\r\ncmd->pbl_sz_flags |=\r\n(hwmr->remote_atomic << OCRDMA_ALLOC_LKEY_REMOTE_ATOMIC_SHIFT);\r\ncmd->pbl_sz_flags |=\r\n(hwmr->num_pbls << OCRDMA_ALLOC_LKEY_PBL_SIZE_SHIFT);\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_alloc_lkey_rsp *)cmd;\r\nhwmr->lkey = rsp->lrkey;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_dealloc_lkey(struct ocrdma_dev *dev, int fr_mr, u32 lkey)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_dealloc_lkey *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_LKEY, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->lkey = lkey;\r\ncmd->rsvd_frmr = fr_mr ? 1 : 0;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_reg_mr(struct ocrdma_dev *dev, struct ocrdma_hw_mr *hwmr,\r\nu32 pdid, u32 pbl_cnt, u32 pbe_size, u32 last)\r\n{\r\nint status = -ENOMEM;\r\nint i;\r\nstruct ocrdma_reg_nsmr *cmd;\r\nstruct ocrdma_reg_nsmr_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_REGISTER_NSMR, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->num_pbl_pdid =\r\npdid | (hwmr->num_pbls << OCRDMA_REG_NSMR_NUM_PBL_SHIFT);\r\ncmd->fr_mr = hwmr->fr_mr;\r\ncmd->flags_hpage_pbe_sz |= (hwmr->remote_wr <<\r\nOCRDMA_REG_NSMR_REMOTE_WR_SHIFT);\r\ncmd->flags_hpage_pbe_sz |= (hwmr->remote_rd <<\r\nOCRDMA_REG_NSMR_REMOTE_RD_SHIFT);\r\ncmd->flags_hpage_pbe_sz |= (hwmr->local_wr <<\r\nOCRDMA_REG_NSMR_LOCAL_WR_SHIFT);\r\ncmd->flags_hpage_pbe_sz |= (hwmr->remote_atomic <<\r\nOCRDMA_REG_NSMR_REMOTE_ATOMIC_SHIFT);\r\ncmd->flags_hpage_pbe_sz |= (hwmr->mw_bind <<\r\nOCRDMA_REG_NSMR_BIND_MEMWIN_SHIFT);\r\ncmd->flags_hpage_pbe_sz |= (last << OCRDMA_REG_NSMR_LAST_SHIFT);\r\ncmd->flags_hpage_pbe_sz |= (hwmr->pbe_size / OCRDMA_MIN_HPAGE_SIZE);\r\ncmd->flags_hpage_pbe_sz |= (hwmr->pbl_size / OCRDMA_MIN_HPAGE_SIZE) <<\r\nOCRDMA_REG_NSMR_HPAGE_SIZE_SHIFT;\r\ncmd->totlen_low = hwmr->len;\r\ncmd->totlen_high = upper_32_bits(hwmr->len);\r\ncmd->fbo_low = (u32) (hwmr->fbo & 0xffffffff);\r\ncmd->fbo_high = (u32) upper_32_bits(hwmr->fbo);\r\ncmd->va_loaddr = (u32) hwmr->va;\r\ncmd->va_hiaddr = (u32) upper_32_bits(hwmr->va);\r\nfor (i = 0; i < pbl_cnt; i++) {\r\ncmd->pbl[i].lo = (u32) (hwmr->pbl_table[i].pa & 0xffffffff);\r\ncmd->pbl[i].hi = upper_32_bits(hwmr->pbl_table[i].pa);\r\n}\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_reg_nsmr_rsp *)cmd;\r\nhwmr->lkey = rsp->lrkey;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_reg_mr_cont(struct ocrdma_dev *dev,\r\nstruct ocrdma_hw_mr *hwmr, u32 pbl_cnt,\r\nu32 pbl_offset, u32 last)\r\n{\r\nint status = -ENOMEM;\r\nint i;\r\nstruct ocrdma_reg_nsmr_cont *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_REGISTER_NSMR_CONT, sizeof(*cmd));\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ncmd->lrkey = hwmr->lkey;\r\ncmd->num_pbl_offset = (pbl_cnt << OCRDMA_REG_NSMR_CONT_NUM_PBL_SHIFT) |\r\n(pbl_offset & OCRDMA_REG_NSMR_CONT_PBL_SHIFT_MASK);\r\ncmd->last = last << OCRDMA_REG_NSMR_CONT_LAST_SHIFT;\r\nfor (i = 0; i < pbl_cnt; i++) {\r\ncmd->pbl[i].lo =\r\n(u32) (hwmr->pbl_table[i + pbl_offset].pa & 0xffffffff);\r\ncmd->pbl[i].hi =\r\nupper_32_bits(hwmr->pbl_table[i + pbl_offset].pa);\r\n}\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_reg_mr(struct ocrdma_dev *dev,\r\nstruct ocrdma_hw_mr *hwmr, u32 pdid, int acc)\r\n{\r\nint status;\r\nu32 last = 0;\r\nu32 cur_pbl_cnt, pbl_offset;\r\nu32 pending_pbl_cnt = hwmr->num_pbls;\r\npbl_offset = 0;\r\ncur_pbl_cnt = min(pending_pbl_cnt, MAX_OCRDMA_NSMR_PBL);\r\nif (cur_pbl_cnt == pending_pbl_cnt)\r\nlast = 1;\r\nstatus = ocrdma_mbx_reg_mr(dev, hwmr, pdid,\r\ncur_pbl_cnt, hwmr->pbe_size, last);\r\nif (status) {\r\npr_err("%s() status=%d\n", __func__, status);\r\nreturn status;\r\n}\r\nif (last)\r\nreturn 0;\r\nwhile (!last) {\r\npbl_offset += cur_pbl_cnt;\r\npending_pbl_cnt -= cur_pbl_cnt;\r\ncur_pbl_cnt = min(pending_pbl_cnt, MAX_OCRDMA_NSMR_PBL);\r\nif (cur_pbl_cnt == pending_pbl_cnt)\r\nlast = 1;\r\nstatus = ocrdma_mbx_reg_mr_cont(dev, hwmr, cur_pbl_cnt,\r\npbl_offset, last);\r\nif (status)\r\nbreak;\r\n}\r\nif (status)\r\npr_err("%s() err. status=%d\n", __func__, status);\r\nreturn status;\r\n}\r\nbool ocrdma_is_qp_in_sq_flushlist(struct ocrdma_cq *cq, struct ocrdma_qp *qp)\r\n{\r\nstruct ocrdma_qp *tmp;\r\nbool found = false;\r\nlist_for_each_entry(tmp, &cq->sq_head, sq_entry) {\r\nif (qp == tmp) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nbool ocrdma_is_qp_in_rq_flushlist(struct ocrdma_cq *cq, struct ocrdma_qp *qp)\r\n{\r\nstruct ocrdma_qp *tmp;\r\nbool found = false;\r\nlist_for_each_entry(tmp, &cq->rq_head, rq_entry) {\r\nif (qp == tmp) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nvoid ocrdma_flush_qp(struct ocrdma_qp *qp)\r\n{\r\nbool found;\r\nunsigned long flags;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);\r\nspin_lock_irqsave(&dev->flush_q_lock, flags);\r\nfound = ocrdma_is_qp_in_sq_flushlist(qp->sq_cq, qp);\r\nif (!found)\r\nlist_add_tail(&qp->sq_entry, &qp->sq_cq->sq_head);\r\nif (!qp->srq) {\r\nfound = ocrdma_is_qp_in_rq_flushlist(qp->rq_cq, qp);\r\nif (!found)\r\nlist_add_tail(&qp->rq_entry, &qp->rq_cq->rq_head);\r\n}\r\nspin_unlock_irqrestore(&dev->flush_q_lock, flags);\r\n}\r\nstatic void ocrdma_init_hwq_ptr(struct ocrdma_qp *qp)\r\n{\r\nqp->sq.head = 0;\r\nqp->sq.tail = 0;\r\nqp->rq.head = 0;\r\nqp->rq.tail = 0;\r\n}\r\nint ocrdma_qp_state_change(struct ocrdma_qp *qp, enum ib_qp_state new_ib_state,\r\nenum ib_qp_state *old_ib_state)\r\n{\r\nunsigned long flags;\r\nint status = 0;\r\nenum ocrdma_qp_state new_state;\r\nnew_state = get_ocrdma_qp_state(new_ib_state);\r\nspin_lock_irqsave(&qp->q_lock, flags);\r\nif (old_ib_state)\r\n*old_ib_state = get_ibqp_state(qp->state);\r\nif (new_state == qp->state) {\r\nspin_unlock_irqrestore(&qp->q_lock, flags);\r\nreturn 1;\r\n}\r\nif (new_state == OCRDMA_QPS_INIT) {\r\nocrdma_init_hwq_ptr(qp);\r\nocrdma_del_flush_qp(qp);\r\n} else if (new_state == OCRDMA_QPS_ERR) {\r\nocrdma_flush_qp(qp);\r\n}\r\nqp->state = new_state;\r\nspin_unlock_irqrestore(&qp->q_lock, flags);\r\nreturn status;\r\n}\r\nstatic u32 ocrdma_set_create_qp_mbx_access_flags(struct ocrdma_qp *qp)\r\n{\r\nu32 flags = 0;\r\nif (qp->cap_flags & OCRDMA_QP_INB_RD)\r\nflags |= OCRDMA_CREATE_QP_REQ_INB_RDEN_MASK;\r\nif (qp->cap_flags & OCRDMA_QP_INB_WR)\r\nflags |= OCRDMA_CREATE_QP_REQ_INB_WREN_MASK;\r\nif (qp->cap_flags & OCRDMA_QP_MW_BIND)\r\nflags |= OCRDMA_CREATE_QP_REQ_BIND_MEMWIN_MASK;\r\nif (qp->cap_flags & OCRDMA_QP_LKEY0)\r\nflags |= OCRDMA_CREATE_QP_REQ_ZERO_LKEYEN_MASK;\r\nif (qp->cap_flags & OCRDMA_QP_FAST_REG)\r\nflags |= OCRDMA_CREATE_QP_REQ_FMR_EN_MASK;\r\nreturn flags;\r\n}\r\nstatic int ocrdma_set_create_qp_sq_cmd(struct ocrdma_create_qp_req *cmd,\r\nstruct ib_qp_init_attr *attrs,\r\nstruct ocrdma_qp *qp)\r\n{\r\nint status;\r\nu32 len, hw_pages, hw_page_size;\r\ndma_addr_t pa;\r\nstruct ocrdma_pd *pd = qp->pd;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nu32 max_wqe_allocated;\r\nu32 max_sges = attrs->cap.max_send_sge;\r\nmax_wqe_allocated = min_t(u32, attrs->cap.max_send_wr + 1,\r\ndev->attr.max_wqe);\r\nstatus = ocrdma_build_q_conf(&max_wqe_allocated,\r\ndev->attr.wqe_size, &hw_pages, &hw_page_size);\r\nif (status) {\r\npr_err("%s() req. max_send_wr=0x%x\n", __func__,\r\nmax_wqe_allocated);\r\nreturn -EINVAL;\r\n}\r\nqp->sq.max_cnt = max_wqe_allocated;\r\nlen = (hw_pages * hw_page_size);\r\nqp->sq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);\r\nif (!qp->sq.va)\r\nreturn -EINVAL;\r\nmemset(qp->sq.va, 0, len);\r\nqp->sq.len = len;\r\nqp->sq.pa = pa;\r\nqp->sq.entry_size = dev->attr.wqe_size;\r\nocrdma_build_q_pages(&cmd->wq_addr[0], hw_pages, pa, hw_page_size);\r\ncmd->type_pgsz_pdn |= (ilog2(hw_page_size / OCRDMA_MIN_Q_PAGE_SIZE)\r\n<< OCRDMA_CREATE_QP_REQ_SQ_PAGE_SIZE_SHIFT);\r\ncmd->num_wq_rq_pages |= (hw_pages <<\r\nOCRDMA_CREATE_QP_REQ_NUM_WQ_PAGES_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_NUM_WQ_PAGES_MASK;\r\ncmd->max_sge_send_write |= (max_sges <<\r\nOCRDMA_CREATE_QP_REQ_MAX_SGE_SEND_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_SGE_SEND_MASK;\r\ncmd->max_sge_send_write |= (max_sges <<\r\nOCRDMA_CREATE_QP_REQ_MAX_SGE_WRITE_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_SGE_WRITE_MASK;\r\ncmd->max_wqe_rqe |= (ilog2(qp->sq.max_cnt) <<\r\nOCRDMA_CREATE_QP_REQ_MAX_WQE_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_WQE_MASK;\r\ncmd->wqe_rqe_size |= (dev->attr.wqe_size <<\r\nOCRDMA_CREATE_QP_REQ_WQE_SIZE_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_WQE_SIZE_MASK;\r\nreturn 0;\r\n}\r\nstatic int ocrdma_set_create_qp_rq_cmd(struct ocrdma_create_qp_req *cmd,\r\nstruct ib_qp_init_attr *attrs,\r\nstruct ocrdma_qp *qp)\r\n{\r\nint status;\r\nu32 len, hw_pages, hw_page_size;\r\ndma_addr_t pa = 0;\r\nstruct ocrdma_pd *pd = qp->pd;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nu32 max_rqe_allocated = attrs->cap.max_recv_wr + 1;\r\nstatus = ocrdma_build_q_conf(&max_rqe_allocated, dev->attr.rqe_size,\r\n&hw_pages, &hw_page_size);\r\nif (status) {\r\npr_err("%s() req. max_recv_wr=0x%x\n", __func__,\r\nattrs->cap.max_recv_wr + 1);\r\nreturn status;\r\n}\r\nqp->rq.max_cnt = max_rqe_allocated;\r\nlen = (hw_pages * hw_page_size);\r\nqp->rq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);\r\nif (!qp->rq.va)\r\nreturn -ENOMEM;\r\nmemset(qp->rq.va, 0, len);\r\nqp->rq.pa = pa;\r\nqp->rq.len = len;\r\nqp->rq.entry_size = dev->attr.rqe_size;\r\nocrdma_build_q_pages(&cmd->rq_addr[0], hw_pages, pa, hw_page_size);\r\ncmd->type_pgsz_pdn |= (ilog2(hw_page_size / OCRDMA_MIN_Q_PAGE_SIZE) <<\r\nOCRDMA_CREATE_QP_REQ_RQ_PAGE_SIZE_SHIFT);\r\ncmd->num_wq_rq_pages |=\r\n(hw_pages << OCRDMA_CREATE_QP_REQ_NUM_RQ_PAGES_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_NUM_RQ_PAGES_MASK;\r\ncmd->max_sge_recv_flags |= (attrs->cap.max_recv_sge <<\r\nOCRDMA_CREATE_QP_REQ_MAX_SGE_RECV_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_SGE_RECV_MASK;\r\ncmd->max_wqe_rqe |= (ilog2(qp->rq.max_cnt) <<\r\nOCRDMA_CREATE_QP_REQ_MAX_RQE_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_RQE_MASK;\r\ncmd->wqe_rqe_size |= (dev->attr.rqe_size <<\r\nOCRDMA_CREATE_QP_REQ_RQE_SIZE_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_RQE_SIZE_MASK;\r\nreturn 0;\r\n}\r\nstatic void ocrdma_set_create_qp_dpp_cmd(struct ocrdma_create_qp_req *cmd,\r\nstruct ocrdma_pd *pd,\r\nstruct ocrdma_qp *qp,\r\nu8 enable_dpp_cq, u16 dpp_cq_id)\r\n{\r\npd->num_dpp_qp--;\r\nqp->dpp_enabled = true;\r\ncmd->max_sge_recv_flags |= OCRDMA_CREATE_QP_REQ_ENABLE_DPP_MASK;\r\nif (!enable_dpp_cq)\r\nreturn;\r\ncmd->max_sge_recv_flags |= OCRDMA_CREATE_QP_REQ_ENABLE_DPP_MASK;\r\ncmd->dpp_credits_cqid = dpp_cq_id;\r\ncmd->dpp_credits_cqid |= OCRDMA_CREATE_QP_REQ_DPP_CREDIT_LIMIT <<\r\nOCRDMA_CREATE_QP_REQ_DPP_CREDIT_SHIFT;\r\n}\r\nstatic int ocrdma_set_create_qp_ird_cmd(struct ocrdma_create_qp_req *cmd,\r\nstruct ocrdma_qp *qp)\r\n{\r\nstruct ocrdma_pd *pd = qp->pd;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\ndma_addr_t pa = 0;\r\nint ird_page_size = dev->attr.ird_page_size;\r\nint ird_q_len = dev->attr.num_ird_pages * ird_page_size;\r\nstruct ocrdma_hdr_wqe *rqe;\r\nint i = 0;\r\nif (dev->attr.ird == 0)\r\nreturn 0;\r\nqp->ird_q_va = dma_alloc_coherent(&pdev->dev, ird_q_len,\r\n&pa, GFP_KERNEL);\r\nif (!qp->ird_q_va)\r\nreturn -ENOMEM;\r\nmemset(qp->ird_q_va, 0, ird_q_len);\r\nocrdma_build_q_pages(&cmd->ird_addr[0], dev->attr.num_ird_pages,\r\npa, ird_page_size);\r\nfor (; i < ird_q_len / dev->attr.rqe_size; i++) {\r\nrqe = (struct ocrdma_hdr_wqe *)(qp->ird_q_va +\r\n(i * dev->attr.rqe_size));\r\nrqe->cw = 0;\r\nrqe->cw |= 2;\r\nrqe->cw |= (OCRDMA_TYPE_LKEY << OCRDMA_WQE_TYPE_SHIFT);\r\nrqe->cw |= (8 << OCRDMA_WQE_SIZE_SHIFT);\r\nrqe->cw |= (8 << OCRDMA_WQE_NXT_WQE_SIZE_SHIFT);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ocrdma_get_create_qp_rsp(struct ocrdma_create_qp_rsp *rsp,\r\nstruct ocrdma_qp *qp,\r\nstruct ib_qp_init_attr *attrs,\r\nu16 *dpp_offset, u16 *dpp_credit_lmt)\r\n{\r\nu32 max_wqe_allocated, max_rqe_allocated;\r\nqp->id = rsp->qp_id & OCRDMA_CREATE_QP_RSP_QP_ID_MASK;\r\nqp->rq.dbid = rsp->sq_rq_id & OCRDMA_CREATE_QP_RSP_RQ_ID_MASK;\r\nqp->sq.dbid = rsp->sq_rq_id >> OCRDMA_CREATE_QP_RSP_SQ_ID_SHIFT;\r\nqp->max_ird = rsp->max_ord_ird & OCRDMA_CREATE_QP_RSP_MAX_IRD_MASK;\r\nqp->max_ord = (rsp->max_ord_ird >> OCRDMA_CREATE_QP_RSP_MAX_ORD_SHIFT);\r\nqp->dpp_enabled = false;\r\nif (rsp->dpp_response & OCRDMA_CREATE_QP_RSP_DPP_ENABLED_MASK) {\r\nqp->dpp_enabled = true;\r\n*dpp_credit_lmt = (rsp->dpp_response &\r\nOCRDMA_CREATE_QP_RSP_DPP_CREDITS_MASK) >>\r\nOCRDMA_CREATE_QP_RSP_DPP_CREDITS_SHIFT;\r\n*dpp_offset = (rsp->dpp_response &\r\nOCRDMA_CREATE_QP_RSP_DPP_PAGE_OFFSET_MASK) >>\r\nOCRDMA_CREATE_QP_RSP_DPP_PAGE_OFFSET_SHIFT;\r\n}\r\nmax_wqe_allocated =\r\nrsp->max_wqe_rqe >> OCRDMA_CREATE_QP_RSP_MAX_WQE_SHIFT;\r\nmax_wqe_allocated = 1 << max_wqe_allocated;\r\nmax_rqe_allocated = 1 << ((u16)rsp->max_wqe_rqe);\r\nqp->sq.max_cnt = max_wqe_allocated;\r\nqp->sq.max_wqe_idx = max_wqe_allocated - 1;\r\nif (!attrs->srq) {\r\nqp->rq.max_cnt = max_rqe_allocated;\r\nqp->rq.max_wqe_idx = max_rqe_allocated - 1;\r\n}\r\n}\r\nint ocrdma_mbx_create_qp(struct ocrdma_qp *qp, struct ib_qp_init_attr *attrs,\r\nu8 enable_dpp_cq, u16 dpp_cq_id, u16 *dpp_offset,\r\nu16 *dpp_credit_lmt)\r\n{\r\nint status = -ENOMEM;\r\nu32 flags = 0;\r\nstruct ocrdma_pd *pd = qp->pd;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nstruct ocrdma_cq *cq;\r\nstruct ocrdma_create_qp_req *cmd;\r\nstruct ocrdma_create_qp_rsp *rsp;\r\nint qptype;\r\nswitch (attrs->qp_type) {\r\ncase IB_QPT_GSI:\r\nqptype = OCRDMA_QPT_GSI;\r\nbreak;\r\ncase IB_QPT_RC:\r\nqptype = OCRDMA_QPT_RC;\r\nbreak;\r\ncase IB_QPT_UD:\r\nqptype = OCRDMA_QPT_UD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_QP, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->type_pgsz_pdn |= (qptype << OCRDMA_CREATE_QP_REQ_QPT_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_QPT_MASK;\r\nstatus = ocrdma_set_create_qp_sq_cmd(cmd, attrs, qp);\r\nif (status)\r\ngoto sq_err;\r\nif (attrs->srq) {\r\nstruct ocrdma_srq *srq = get_ocrdma_srq(attrs->srq);\r\ncmd->max_sge_recv_flags |= OCRDMA_CREATE_QP_REQ_USE_SRQ_MASK;\r\ncmd->rq_addr[0].lo = srq->id;\r\nqp->srq = srq;\r\n} else {\r\nstatus = ocrdma_set_create_qp_rq_cmd(cmd, attrs, qp);\r\nif (status)\r\ngoto rq_err;\r\n}\r\nstatus = ocrdma_set_create_qp_ird_cmd(cmd, qp);\r\nif (status)\r\ngoto mbx_err;\r\ncmd->type_pgsz_pdn |= (pd->id << OCRDMA_CREATE_QP_REQ_PD_ID_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_PD_ID_MASK;\r\nflags = ocrdma_set_create_qp_mbx_access_flags(qp);\r\ncmd->max_sge_recv_flags |= flags;\r\ncmd->max_ord_ird |= (dev->attr.max_ord_per_qp <<\r\nOCRDMA_CREATE_QP_REQ_MAX_ORD_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_ORD_MASK;\r\ncmd->max_ord_ird |= (dev->attr.max_ird_per_qp <<\r\nOCRDMA_CREATE_QP_REQ_MAX_IRD_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_MAX_IRD_MASK;\r\ncq = get_ocrdma_cq(attrs->send_cq);\r\ncmd->wq_rq_cqid |= (cq->id << OCRDMA_CREATE_QP_REQ_WQ_CQID_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_WQ_CQID_MASK;\r\nqp->sq_cq = cq;\r\ncq = get_ocrdma_cq(attrs->recv_cq);\r\ncmd->wq_rq_cqid |= (cq->id << OCRDMA_CREATE_QP_REQ_RQ_CQID_SHIFT) &\r\nOCRDMA_CREATE_QP_REQ_RQ_CQID_MASK;\r\nqp->rq_cq = cq;\r\nif (pd->dpp_enabled && attrs->cap.max_inline_data && pd->num_dpp_qp &&\r\n(attrs->cap.max_inline_data <= dev->attr.max_inline_data)) {\r\nocrdma_set_create_qp_dpp_cmd(cmd, pd, qp, enable_dpp_cq,\r\ndpp_cq_id);\r\n}\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_create_qp_rsp *)cmd;\r\nocrdma_get_create_qp_rsp(rsp, qp, attrs, dpp_offset, dpp_credit_lmt);\r\nqp->state = OCRDMA_QPS_RST;\r\nkfree(cmd);\r\nreturn 0;\r\nmbx_err:\r\nif (qp->rq.va)\r\ndma_free_coherent(&pdev->dev, qp->rq.len, qp->rq.va, qp->rq.pa);\r\nrq_err:\r\npr_err("%s(%d) rq_err\n", __func__, dev->id);\r\ndma_free_coherent(&pdev->dev, qp->sq.len, qp->sq.va, qp->sq.pa);\r\nsq_err:\r\npr_err("%s(%d) sq_err\n", __func__, dev->id);\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_query_qp(struct ocrdma_dev *dev, struct ocrdma_qp *qp,\r\nstruct ocrdma_qp_params *param)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_query_qp *cmd;\r\nstruct ocrdma_query_qp_rsp *rsp;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_QP, sizeof(*rsp));\r\nif (!cmd)\r\nreturn status;\r\ncmd->qp_id = qp->id;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_query_qp_rsp *)cmd;\r\nmemcpy(param, &rsp->params, sizeof(struct ocrdma_qp_params));\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_set_av_params(struct ocrdma_qp *qp,\r\nstruct ocrdma_modify_qp *cmd,\r\nstruct ib_qp_attr *attrs,\r\nint attr_mask)\r\n{\r\nint status;\r\nstruct ib_ah_attr *ah_attr = &attrs->ah_attr;\r\nunion ib_gid sgid, zgid;\r\nu32 vlan_id = 0xFFFF;\r\nu8 mac_addr[6];\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);\r\nif ((ah_attr->ah_flags & IB_AH_GRH) == 0)\r\nreturn -EINVAL;\r\nif (atomic_cmpxchg(&dev->update_sl, 1, 0))\r\nocrdma_init_service_level(dev);\r\ncmd->params.tclass_sq_psn |=\r\n(ah_attr->grh.traffic_class << OCRDMA_QP_PARAMS_TCLASS_SHIFT);\r\ncmd->params.rnt_rc_sl_fl |=\r\n(ah_attr->grh.flow_label & OCRDMA_QP_PARAMS_FLOW_LABEL_MASK);\r\ncmd->params.rnt_rc_sl_fl |= (ah_attr->sl << OCRDMA_QP_PARAMS_SL_SHIFT);\r\ncmd->params.hop_lmt_rq_psn |=\r\n(ah_attr->grh.hop_limit << OCRDMA_QP_PARAMS_HOP_LMT_SHIFT);\r\ncmd->flags |= OCRDMA_QP_PARA_FLOW_LBL_VALID;\r\nmemcpy(&cmd->params.dgid[0], &ah_attr->grh.dgid.raw[0],\r\nsizeof(cmd->params.dgid));\r\nstatus = ocrdma_query_gid(&dev->ibdev, 1,\r\nah_attr->grh.sgid_index, &sgid);\r\nif (status)\r\nreturn status;\r\nmemset(&zgid, 0, sizeof(zgid));\r\nif (!memcmp(&sgid, &zgid, sizeof(zgid)))\r\nreturn -EINVAL;\r\nqp->sgid_idx = ah_attr->grh.sgid_index;\r\nmemcpy(&cmd->params.sgid[0], &sgid.raw[0], sizeof(cmd->params.sgid));\r\nstatus = ocrdma_resolve_dmac(dev, ah_attr, &mac_addr[0]);\r\nif (status)\r\nreturn status;\r\ncmd->params.dmac_b0_to_b3 = mac_addr[0] | (mac_addr[1] << 8) |\r\n(mac_addr[2] << 16) | (mac_addr[3] << 24);\r\nocrdma_cpu_to_le32(&cmd->params.dgid[0], sizeof(cmd->params.dgid));\r\nocrdma_cpu_to_le32(&cmd->params.sgid[0], sizeof(cmd->params.sgid));\r\ncmd->params.vlan_dmac_b4_to_b5 = mac_addr[4] | (mac_addr[5] << 8);\r\nif (attr_mask & IB_QP_VID) {\r\nvlan_id = attrs->vlan_id;\r\n} else if (dev->pfc_state) {\r\nvlan_id = 0;\r\npr_err("ocrdma%d:Using VLAN with PFC is recommended\n",\r\ndev->id);\r\npr_err("ocrdma%d:Using VLAN 0 for this connection\n",\r\ndev->id);\r\n}\r\nif (vlan_id < 0x1000) {\r\ncmd->params.vlan_dmac_b4_to_b5 |=\r\nvlan_id << OCRDMA_QP_PARAMS_VLAN_SHIFT;\r\ncmd->flags |= OCRDMA_QP_PARA_VLAN_EN_VALID;\r\ncmd->params.rnt_rc_sl_fl |=\r\n(dev->sl & 0x07) << OCRDMA_QP_PARAMS_SL_SHIFT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ocrdma_set_qp_params(struct ocrdma_qp *qp,\r\nstruct ocrdma_modify_qp *cmd,\r\nstruct ib_qp_attr *attrs, int attr_mask)\r\n{\r\nint status = 0;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);\r\nif (attr_mask & IB_QP_PKEY_INDEX) {\r\ncmd->params.path_mtu_pkey_indx |= (attrs->pkey_index &\r\nOCRDMA_QP_PARAMS_PKEY_INDEX_MASK);\r\ncmd->flags |= OCRDMA_QP_PARA_PKEY_VALID;\r\n}\r\nif (attr_mask & IB_QP_QKEY) {\r\nqp->qkey = attrs->qkey;\r\ncmd->params.qkey = attrs->qkey;\r\ncmd->flags |= OCRDMA_QP_PARA_QKEY_VALID;\r\n}\r\nif (attr_mask & IB_QP_AV) {\r\nstatus = ocrdma_set_av_params(qp, cmd, attrs, attr_mask);\r\nif (status)\r\nreturn status;\r\n} else if (qp->qp_type == IB_QPT_GSI || qp->qp_type == IB_QPT_UD) {\r\ncmd->params.dmac_b0_to_b3 = dev->nic_info.mac_addr[0] |\r\n(dev->nic_info.mac_addr[1] << 8) |\r\n(dev->nic_info.mac_addr[2] << 16) |\r\n(dev->nic_info.mac_addr[3] << 24);\r\ncmd->params.vlan_dmac_b4_to_b5 = dev->nic_info.mac_addr[4] |\r\n(dev->nic_info.mac_addr[5] << 8);\r\n}\r\nif ((attr_mask & IB_QP_EN_SQD_ASYNC_NOTIFY) &&\r\nattrs->en_sqd_async_notify) {\r\ncmd->params.max_sge_recv_flags |=\r\nOCRDMA_QP_PARAMS_FLAGS_SQD_ASYNC;\r\ncmd->flags |= OCRDMA_QP_PARA_DST_QPN_VALID;\r\n}\r\nif (attr_mask & IB_QP_DEST_QPN) {\r\ncmd->params.ack_to_rnr_rtc_dest_qpn |= (attrs->dest_qp_num &\r\nOCRDMA_QP_PARAMS_DEST_QPN_MASK);\r\ncmd->flags |= OCRDMA_QP_PARA_DST_QPN_VALID;\r\n}\r\nif (attr_mask & IB_QP_PATH_MTU) {\r\nif (attrs->path_mtu < IB_MTU_512 ||\r\nattrs->path_mtu > IB_MTU_4096) {\r\npr_err("ocrdma%d: IB MTU %d is not supported\n",\r\ndev->id, ib_mtu_enum_to_int(attrs->path_mtu));\r\nstatus = -EINVAL;\r\ngoto pmtu_err;\r\n}\r\ncmd->params.path_mtu_pkey_indx |=\r\n(ib_mtu_enum_to_int(attrs->path_mtu) <<\r\nOCRDMA_QP_PARAMS_PATH_MTU_SHIFT) &\r\nOCRDMA_QP_PARAMS_PATH_MTU_MASK;\r\ncmd->flags |= OCRDMA_QP_PARA_PMTU_VALID;\r\n}\r\nif (attr_mask & IB_QP_TIMEOUT) {\r\ncmd->params.ack_to_rnr_rtc_dest_qpn |= attrs->timeout <<\r\nOCRDMA_QP_PARAMS_ACK_TIMEOUT_SHIFT;\r\ncmd->flags |= OCRDMA_QP_PARA_ACK_TO_VALID;\r\n}\r\nif (attr_mask & IB_QP_RETRY_CNT) {\r\ncmd->params.rnt_rc_sl_fl |= (attrs->retry_cnt <<\r\nOCRDMA_QP_PARAMS_RETRY_CNT_SHIFT) &\r\nOCRDMA_QP_PARAMS_RETRY_CNT_MASK;\r\ncmd->flags |= OCRDMA_QP_PARA_RETRY_CNT_VALID;\r\n}\r\nif (attr_mask & IB_QP_MIN_RNR_TIMER) {\r\ncmd->params.rnt_rc_sl_fl |= (attrs->min_rnr_timer <<\r\nOCRDMA_QP_PARAMS_RNR_NAK_TIMER_SHIFT) &\r\nOCRDMA_QP_PARAMS_RNR_NAK_TIMER_MASK;\r\ncmd->flags |= OCRDMA_QP_PARA_RNT_VALID;\r\n}\r\nif (attr_mask & IB_QP_RNR_RETRY) {\r\ncmd->params.ack_to_rnr_rtc_dest_qpn |= (attrs->rnr_retry <<\r\nOCRDMA_QP_PARAMS_RNR_RETRY_CNT_SHIFT)\r\n& OCRDMA_QP_PARAMS_RNR_RETRY_CNT_MASK;\r\ncmd->flags |= OCRDMA_QP_PARA_RRC_VALID;\r\n}\r\nif (attr_mask & IB_QP_SQ_PSN) {\r\ncmd->params.tclass_sq_psn |= (attrs->sq_psn & 0x00ffffff);\r\ncmd->flags |= OCRDMA_QP_PARA_SQPSN_VALID;\r\n}\r\nif (attr_mask & IB_QP_RQ_PSN) {\r\ncmd->params.hop_lmt_rq_psn |= (attrs->rq_psn & 0x00ffffff);\r\ncmd->flags |= OCRDMA_QP_PARA_RQPSN_VALID;\r\n}\r\nif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\r\nif (attrs->max_rd_atomic > dev->attr.max_ord_per_qp) {\r\nstatus = -EINVAL;\r\ngoto pmtu_err;\r\n}\r\nqp->max_ord = attrs->max_rd_atomic;\r\ncmd->flags |= OCRDMA_QP_PARA_MAX_ORD_VALID;\r\n}\r\nif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\r\nif (attrs->max_dest_rd_atomic > dev->attr.max_ird_per_qp) {\r\nstatus = -EINVAL;\r\ngoto pmtu_err;\r\n}\r\nqp->max_ird = attrs->max_dest_rd_atomic;\r\ncmd->flags |= OCRDMA_QP_PARA_MAX_IRD_VALID;\r\n}\r\ncmd->params.max_ord_ird = (qp->max_ord <<\r\nOCRDMA_QP_PARAMS_MAX_ORD_SHIFT) |\r\n(qp->max_ird & OCRDMA_QP_PARAMS_MAX_IRD_MASK);\r\npmtu_err:\r\nreturn status;\r\n}\r\nint ocrdma_mbx_modify_qp(struct ocrdma_dev *dev, struct ocrdma_qp *qp,\r\nstruct ib_qp_attr *attrs, int attr_mask)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_modify_qp *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_MODIFY_QP, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->params.id = qp->id;\r\ncmd->flags = 0;\r\nif (attr_mask & IB_QP_STATE) {\r\ncmd->params.max_sge_recv_flags |=\r\n(get_ocrdma_qp_state(attrs->qp_state) <<\r\nOCRDMA_QP_PARAMS_STATE_SHIFT) &\r\nOCRDMA_QP_PARAMS_STATE_MASK;\r\ncmd->flags |= OCRDMA_QP_PARA_QPS_VALID;\r\n} else {\r\ncmd->params.max_sge_recv_flags |=\r\n(qp->state << OCRDMA_QP_PARAMS_STATE_SHIFT) &\r\nOCRDMA_QP_PARAMS_STATE_MASK;\r\n}\r\nstatus = ocrdma_set_qp_params(qp, cmd, attrs, attr_mask);\r\nif (status)\r\ngoto mbx_err;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_destroy_qp(struct ocrdma_dev *dev, struct ocrdma_qp *qp)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_destroy_qp *cmd;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_QP, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->qp_id = qp->id;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nmbx_err:\r\nkfree(cmd);\r\nif (qp->sq.va)\r\ndma_free_coherent(&pdev->dev, qp->sq.len, qp->sq.va, qp->sq.pa);\r\nif (!qp->srq && qp->rq.va)\r\ndma_free_coherent(&pdev->dev, qp->rq.len, qp->rq.va, qp->rq.pa);\r\nif (qp->dpp_enabled)\r\nqp->pd->num_dpp_qp++;\r\nreturn status;\r\n}\r\nint ocrdma_mbx_create_srq(struct ocrdma_dev *dev, struct ocrdma_srq *srq,\r\nstruct ib_srq_init_attr *srq_attr,\r\nstruct ocrdma_pd *pd)\r\n{\r\nint status = -ENOMEM;\r\nint hw_pages, hw_page_size;\r\nint len;\r\nstruct ocrdma_create_srq_rsp *rsp;\r\nstruct ocrdma_create_srq *cmd;\r\ndma_addr_t pa;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nu32 max_rqe_allocated;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_SRQ, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->pgsz_pdid = pd->id & OCRDMA_CREATE_SRQ_PD_ID_MASK;\r\nmax_rqe_allocated = srq_attr->attr.max_wr + 1;\r\nstatus = ocrdma_build_q_conf(&max_rqe_allocated,\r\ndev->attr.rqe_size,\r\n&hw_pages, &hw_page_size);\r\nif (status) {\r\npr_err("%s() req. max_wr=0x%x\n", __func__,\r\nsrq_attr->attr.max_wr);\r\nstatus = -EINVAL;\r\ngoto ret;\r\n}\r\nlen = hw_pages * hw_page_size;\r\nsrq->rq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);\r\nif (!srq->rq.va) {\r\nstatus = -ENOMEM;\r\ngoto ret;\r\n}\r\nocrdma_build_q_pages(&cmd->rq_addr[0], hw_pages, pa, hw_page_size);\r\nsrq->rq.entry_size = dev->attr.rqe_size;\r\nsrq->rq.pa = pa;\r\nsrq->rq.len = len;\r\nsrq->rq.max_cnt = max_rqe_allocated;\r\ncmd->max_sge_rqe = ilog2(max_rqe_allocated);\r\ncmd->max_sge_rqe |= srq_attr->attr.max_sge <<\r\nOCRDMA_CREATE_SRQ_MAX_SGE_RECV_SHIFT;\r\ncmd->pgsz_pdid |= (ilog2(hw_page_size / OCRDMA_MIN_Q_PAGE_SIZE)\r\n<< OCRDMA_CREATE_SRQ_PG_SZ_SHIFT);\r\ncmd->pages_rqe_sz |= (dev->attr.rqe_size\r\n<< OCRDMA_CREATE_SRQ_RQE_SIZE_SHIFT)\r\n& OCRDMA_CREATE_SRQ_RQE_SIZE_MASK;\r\ncmd->pages_rqe_sz |= hw_pages << OCRDMA_CREATE_SRQ_NUM_RQ_PAGES_SHIFT;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_create_srq_rsp *)cmd;\r\nsrq->id = rsp->id;\r\nsrq->rq.dbid = rsp->id;\r\nmax_rqe_allocated = ((rsp->max_sge_rqe_allocated &\r\nOCRDMA_CREATE_SRQ_RSP_MAX_RQE_ALLOCATED_MASK) >>\r\nOCRDMA_CREATE_SRQ_RSP_MAX_RQE_ALLOCATED_SHIFT);\r\nmax_rqe_allocated = (1 << max_rqe_allocated);\r\nsrq->rq.max_cnt = max_rqe_allocated;\r\nsrq->rq.max_wqe_idx = max_rqe_allocated - 1;\r\nsrq->rq.max_sges = (rsp->max_sge_rqe_allocated &\r\nOCRDMA_CREATE_SRQ_RSP_MAX_SGE_RECV_ALLOCATED_MASK) >>\r\nOCRDMA_CREATE_SRQ_RSP_MAX_SGE_RECV_ALLOCATED_SHIFT;\r\ngoto ret;\r\nmbx_err:\r\ndma_free_coherent(&pdev->dev, srq->rq.len, srq->rq.va, pa);\r\nret:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_modify_srq(struct ocrdma_srq *srq, struct ib_srq_attr *srq_attr)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_modify_srq *cmd;\r\nstruct ocrdma_pd *pd = srq->pd;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_MODIFY_SRQ, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->id = srq->id;\r\ncmd->limit_max_rqe |= srq_attr->srq_limit <<\r\nOCRDMA_MODIFY_SRQ_LIMIT_SHIFT;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_query_srq(struct ocrdma_srq *srq, struct ib_srq_attr *srq_attr)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_query_srq *cmd;\r\nstruct ocrdma_dev *dev = get_ocrdma_dev(srq->ibsrq.device);\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_SRQ, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->id = srq->rq.dbid;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status == 0) {\r\nstruct ocrdma_query_srq_rsp *rsp =\r\n(struct ocrdma_query_srq_rsp *)cmd;\r\nsrq_attr->max_sge =\r\nrsp->srq_lmt_max_sge &\r\nOCRDMA_QUERY_SRQ_RSP_MAX_SGE_RECV_MASK;\r\nsrq_attr->max_wr =\r\nrsp->max_rqe_pdid >> OCRDMA_QUERY_SRQ_RSP_MAX_RQE_SHIFT;\r\nsrq_attr->srq_limit = rsp->srq_lmt_max_sge >>\r\nOCRDMA_QUERY_SRQ_RSP_SRQ_LIMIT_SHIFT;\r\n}\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nint ocrdma_mbx_destroy_srq(struct ocrdma_dev *dev, struct ocrdma_srq *srq)\r\n{\r\nint status = -ENOMEM;\r\nstruct ocrdma_destroy_srq *cmd;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_SRQ, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\ncmd->id = srq->id;\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (srq->rq.va)\r\ndma_free_coherent(&pdev->dev, srq->rq.len,\r\nsrq->rq.va, srq->rq.pa);\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_get_dcbx_config(struct ocrdma_dev *dev, u32 ptype,\r\nstruct ocrdma_dcbx_cfg *dcbxcfg)\r\n{\r\nint status = 0;\r\ndma_addr_t pa;\r\nstruct ocrdma_mqe cmd;\r\nstruct ocrdma_get_dcbx_cfg_req *req = NULL;\r\nstruct ocrdma_get_dcbx_cfg_rsp *rsp = NULL;\r\nstruct pci_dev *pdev = dev->nic_info.pdev;\r\nstruct ocrdma_mqe_sge *mqe_sge = cmd.u.nonemb_req.sge;\r\nmemset(&cmd, 0, sizeof(struct ocrdma_mqe));\r\ncmd.hdr.pyld_len = max_t (u32, sizeof(struct ocrdma_get_dcbx_cfg_rsp),\r\nsizeof(struct ocrdma_get_dcbx_cfg_req));\r\nreq = dma_alloc_coherent(&pdev->dev, cmd.hdr.pyld_len, &pa, GFP_KERNEL);\r\nif (!req) {\r\nstatus = -ENOMEM;\r\ngoto mem_err;\r\n}\r\ncmd.hdr.spcl_sge_cnt_emb |= (1 << OCRDMA_MQE_HDR_SGE_CNT_SHIFT) &\r\nOCRDMA_MQE_HDR_SGE_CNT_MASK;\r\nmqe_sge->pa_lo = (u32) (pa & 0xFFFFFFFFUL);\r\nmqe_sge->pa_hi = (u32) upper_32_bits(pa);\r\nmqe_sge->len = cmd.hdr.pyld_len;\r\nmemset(req, 0, sizeof(struct ocrdma_get_dcbx_cfg_req));\r\nocrdma_init_mch(&req->hdr, OCRDMA_CMD_GET_DCBX_CONFIG,\r\nOCRDMA_SUBSYS_DCBX, cmd.hdr.pyld_len);\r\nreq->param_type = ptype;\r\nstatus = ocrdma_mbx_cmd(dev, &cmd);\r\nif (status)\r\ngoto mbx_err;\r\nrsp = (struct ocrdma_get_dcbx_cfg_rsp *)req;\r\nocrdma_le32_to_cpu(rsp, sizeof(struct ocrdma_get_dcbx_cfg_rsp));\r\nmemcpy(dcbxcfg, &rsp->cfg, sizeof(struct ocrdma_dcbx_cfg));\r\nmbx_err:\r\ndma_free_coherent(&pdev->dev, cmd.hdr.pyld_len, req, pa);\r\nmem_err:\r\nreturn status;\r\n}\r\nstatic int ocrdma_parse_dcbxcfg_rsp(struct ocrdma_dev *dev, int ptype,\r\nstruct ocrdma_dcbx_cfg *dcbxcfg,\r\nu8 *srvc_lvl)\r\n{\r\nint status = -EINVAL, indx, slindx;\r\nint ventry_cnt;\r\nstruct ocrdma_app_parameter *app_param;\r\nu8 valid, proto_sel;\r\nu8 app_prio, pfc_prio;\r\nu16 proto;\r\nif (!(dcbxcfg->tcv_aev_opv_st & OCRDMA_DCBX_STATE_MASK)) {\r\npr_info("%s ocrdma%d DCBX is disabled\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id);\r\ngoto out;\r\n}\r\nif (!ocrdma_is_enabled_and_synced(dcbxcfg->pfc_state)) {\r\npr_info("%s ocrdma%d priority flow control(%s) is %s%s\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id,\r\n(ptype > 0 ? "operational" : "admin"),\r\n(dcbxcfg->pfc_state & OCRDMA_STATE_FLAG_ENABLED) ?\r\n"enabled" : "disabled",\r\n(dcbxcfg->pfc_state & OCRDMA_STATE_FLAG_SYNC) ?\r\n"" : ", not sync'ed");\r\ngoto out;\r\n} else {\r\npr_info("%s ocrdma%d priority flow control is enabled and sync'ed\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id);\r\n}\r\nventry_cnt = (dcbxcfg->tcv_aev_opv_st >>\r\nOCRDMA_DCBX_APP_ENTRY_SHIFT)\r\n& OCRDMA_DCBX_STATE_MASK;\r\nfor (indx = 0; indx < ventry_cnt; indx++) {\r\napp_param = &dcbxcfg->app_param[indx];\r\nvalid = (app_param->valid_proto_app >>\r\nOCRDMA_APP_PARAM_VALID_SHIFT)\r\n& OCRDMA_APP_PARAM_VALID_MASK;\r\nproto_sel = (app_param->valid_proto_app\r\n>> OCRDMA_APP_PARAM_PROTO_SEL_SHIFT)\r\n& OCRDMA_APP_PARAM_PROTO_SEL_MASK;\r\nproto = app_param->valid_proto_app &\r\nOCRDMA_APP_PARAM_APP_PROTO_MASK;\r\nif (\r\nvalid && proto == OCRDMA_APP_PROTO_ROCE &&\r\nproto_sel == OCRDMA_PROTO_SELECT_L2) {\r\nfor (slindx = 0; slindx <\r\nOCRDMA_MAX_SERVICE_LEVEL_INDEX; slindx++) {\r\napp_prio = ocrdma_get_app_prio(\r\n(u8 *)app_param->app_prio,\r\nslindx);\r\npfc_prio = ocrdma_get_pfc_prio(\r\n(u8 *)dcbxcfg->pfc_prio,\r\nslindx);\r\nif (app_prio && pfc_prio) {\r\n*srvc_lvl = slindx;\r\nstatus = 0;\r\ngoto out;\r\n}\r\n}\r\nif (slindx == OCRDMA_MAX_SERVICE_LEVEL_INDEX) {\r\npr_info("%s ocrdma%d application priority not set for 0x%x protocol\n",\r\ndev_name(&dev->nic_info.pdev->dev),\r\ndev->id, proto);\r\n}\r\n}\r\n}\r\nout:\r\nreturn status;\r\n}\r\nvoid ocrdma_init_service_level(struct ocrdma_dev *dev)\r\n{\r\nint status = 0, indx;\r\nstruct ocrdma_dcbx_cfg dcbxcfg;\r\nu8 srvc_lvl = OCRDMA_DEFAULT_SERVICE_LEVEL;\r\nint ptype = OCRDMA_PARAMETER_TYPE_OPER;\r\nfor (indx = 0; indx < 2; indx++) {\r\nstatus = ocrdma_mbx_get_dcbx_config(dev, ptype, &dcbxcfg);\r\nif (status) {\r\npr_err("%s(): status=%d\n", __func__, status);\r\nptype = OCRDMA_PARAMETER_TYPE_ADMIN;\r\ncontinue;\r\n}\r\nstatus = ocrdma_parse_dcbxcfg_rsp(dev, ptype,\r\n&dcbxcfg, &srvc_lvl);\r\nif (status) {\r\nptype = OCRDMA_PARAMETER_TYPE_ADMIN;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (status)\r\npr_info("%s ocrdma%d service level default\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id);\r\nelse\r\npr_info("%s ocrdma%d service level %d\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id,\r\nsrvc_lvl);\r\ndev->pfc_state = ocrdma_is_enabled_and_synced(dcbxcfg.pfc_state);\r\ndev->sl = srvc_lvl;\r\n}\r\nint ocrdma_alloc_av(struct ocrdma_dev *dev, struct ocrdma_ah *ah)\r\n{\r\nint i;\r\nint status = -EINVAL;\r\nstruct ocrdma_av *av;\r\nunsigned long flags;\r\nav = dev->av_tbl.va;\r\nspin_lock_irqsave(&dev->av_tbl.lock, flags);\r\nfor (i = 0; i < dev->av_tbl.num_ah; i++) {\r\nif (av->valid == 0) {\r\nav->valid = OCRDMA_AV_VALID;\r\nah->av = av;\r\nah->id = i;\r\nstatus = 0;\r\nbreak;\r\n}\r\nav++;\r\n}\r\nif (i == dev->av_tbl.num_ah)\r\nstatus = -EAGAIN;\r\nspin_unlock_irqrestore(&dev->av_tbl.lock, flags);\r\nreturn status;\r\n}\r\nint ocrdma_free_av(struct ocrdma_dev *dev, struct ocrdma_ah *ah)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->av_tbl.lock, flags);\r\nah->av->valid = 0;\r\nspin_unlock_irqrestore(&dev->av_tbl.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ocrdma_create_eqs(struct ocrdma_dev *dev)\r\n{\r\nint num_eq, i, status = 0;\r\nint irq;\r\nunsigned long flags = 0;\r\nnum_eq = dev->nic_info.msix.num_vectors -\r\ndev->nic_info.msix.start_vector;\r\nif (dev->nic_info.intr_mode == BE_INTERRUPT_MODE_INTX) {\r\nnum_eq = 1;\r\nflags = IRQF_SHARED;\r\n} else {\r\nnum_eq = min_t(u32, num_eq, num_online_cpus());\r\n}\r\nif (!num_eq)\r\nreturn -EINVAL;\r\ndev->eq_tbl = kzalloc(sizeof(struct ocrdma_eq) * num_eq, GFP_KERNEL);\r\nif (!dev->eq_tbl)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_eq; i++) {\r\nstatus = ocrdma_create_eq(dev, &dev->eq_tbl[i],\r\nOCRDMA_EQ_LEN);\r\nif (status) {\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nsprintf(dev->eq_tbl[i].irq_name, "ocrdma%d-%d",\r\ndev->id, i);\r\nirq = ocrdma_get_irq(dev, &dev->eq_tbl[i]);\r\nstatus = request_irq(irq, ocrdma_irq_handler, flags,\r\ndev->eq_tbl[i].irq_name,\r\n&dev->eq_tbl[i]);\r\nif (status)\r\ngoto done;\r\ndev->eq_cnt += 1;\r\n}\r\nreturn 0;\r\ndone:\r\nocrdma_destroy_eqs(dev);\r\nreturn status;\r\n}\r\nstatic int ocrdma_mbx_modify_eqd(struct ocrdma_dev *dev, struct ocrdma_eq *eq,\r\nint num)\r\n{\r\nint i, status = -ENOMEM;\r\nstruct ocrdma_modify_eqd_req *cmd;\r\ncmd = ocrdma_init_emb_mqe(OCRDMA_CMD_MODIFY_EQ_DELAY, sizeof(*cmd));\r\nif (!cmd)\r\nreturn status;\r\nocrdma_init_mch(&cmd->cmd.req, OCRDMA_CMD_MODIFY_EQ_DELAY,\r\nOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\r\ncmd->cmd.num_eq = num;\r\nfor (i = 0; i < num; i++) {\r\ncmd->cmd.set_eqd[i].eq_id = eq[i].q.id;\r\ncmd->cmd.set_eqd[i].phase = 0;\r\ncmd->cmd.set_eqd[i].delay_multiplier =\r\n(eq[i].aic_obj.prev_eqd * 65)/100;\r\n}\r\nstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\r\nif (status)\r\ngoto mbx_err;\r\nmbx_err:\r\nkfree(cmd);\r\nreturn status;\r\n}\r\nstatic int ocrdma_modify_eqd(struct ocrdma_dev *dev, struct ocrdma_eq *eq,\r\nint num)\r\n{\r\nint num_eqs, i = 0;\r\nif (num > 8) {\r\nwhile (num) {\r\nnum_eqs = min(num, 8);\r\nocrdma_mbx_modify_eqd(dev, &eq[i], num_eqs);\r\ni += num_eqs;\r\nnum -= num_eqs;\r\n}\r\n} else {\r\nocrdma_mbx_modify_eqd(dev, eq, num);\r\n}\r\nreturn 0;\r\n}\r\nvoid ocrdma_eqd_set_task(struct work_struct *work)\r\n{\r\nstruct ocrdma_dev *dev =\r\ncontainer_of(work, struct ocrdma_dev, eqd_work.work);\r\nstruct ocrdma_eq *eq = 0;\r\nint i, num = 0, status = -EINVAL;\r\nu64 eq_intr;\r\nfor (i = 0; i < dev->eq_cnt; i++) {\r\neq = &dev->eq_tbl[i];\r\nif (eq->aic_obj.eq_intr_cnt > eq->aic_obj.prev_eq_intr_cnt) {\r\neq_intr = eq->aic_obj.eq_intr_cnt -\r\neq->aic_obj.prev_eq_intr_cnt;\r\nif ((eq_intr > EQ_INTR_PER_SEC_THRSH_HI) &&\r\n(eq->aic_obj.prev_eqd == EQ_AIC_MIN_EQD)) {\r\neq->aic_obj.prev_eqd = EQ_AIC_MAX_EQD;\r\nnum++;\r\n} else if ((eq_intr < EQ_INTR_PER_SEC_THRSH_LOW) &&\r\n(eq->aic_obj.prev_eqd == EQ_AIC_MAX_EQD)) {\r\neq->aic_obj.prev_eqd = EQ_AIC_MIN_EQD;\r\nnum++;\r\n}\r\n}\r\neq->aic_obj.prev_eq_intr_cnt = eq->aic_obj.eq_intr_cnt;\r\n}\r\nif (num)\r\nstatus = ocrdma_modify_eqd(dev, &dev->eq_tbl[0], num);\r\nschedule_delayed_work(&dev->eqd_work, msecs_to_jiffies(1000));\r\n}\r\nint ocrdma_init_hw(struct ocrdma_dev *dev)\r\n{\r\nint status;\r\nstatus = ocrdma_create_eqs(dev);\r\nif (status)\r\ngoto qpeq_err;\r\nstatus = ocrdma_create_mq(dev);\r\nif (status)\r\ngoto mq_err;\r\nstatus = ocrdma_mbx_query_fw_config(dev);\r\nif (status)\r\ngoto conf_err;\r\nstatus = ocrdma_mbx_query_dev(dev);\r\nif (status)\r\ngoto conf_err;\r\nstatus = ocrdma_mbx_query_fw_ver(dev);\r\nif (status)\r\ngoto conf_err;\r\nstatus = ocrdma_mbx_create_ah_tbl(dev);\r\nif (status)\r\ngoto conf_err;\r\nstatus = ocrdma_mbx_get_phy_info(dev);\r\nif (status)\r\ngoto info_attrb_err;\r\nstatus = ocrdma_mbx_get_ctrl_attribs(dev);\r\nif (status)\r\ngoto info_attrb_err;\r\nreturn 0;\r\ninfo_attrb_err:\r\nocrdma_mbx_delete_ah_tbl(dev);\r\nconf_err:\r\nocrdma_destroy_mq(dev);\r\nmq_err:\r\nocrdma_destroy_eqs(dev);\r\nqpeq_err:\r\npr_err("%s() status=%d\n", __func__, status);\r\nreturn status;\r\n}\r\nvoid ocrdma_cleanup_hw(struct ocrdma_dev *dev)\r\n{\r\nocrdma_free_pd_pool(dev);\r\nocrdma_mbx_delete_ah_tbl(dev);\r\nocrdma_destroy_mq(dev);\r\nocrdma_destroy_eqs(dev);\r\n}
