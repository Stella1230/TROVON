static int set_attention_status(struct hotplug_slot *hotplug_slot, u8 value)\r\n{\r\nint rc;\r\nstruct slot *slot = (struct slot *)hotplug_slot->private;\r\nswitch (value) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nvalue = 1;\r\nbreak;\r\n}\r\nrc = rtas_set_indicator(DR_INDICATOR, slot->index, value);\r\nif (!rc)\r\nhotplug_slot->info->attention_status = value;\r\nreturn rc;\r\n}\r\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nint retval, level;\r\nstruct slot *slot = (struct slot *)hotplug_slot->private;\r\nretval = rtas_get_power_level (slot->power_domain, &level);\r\nif (!retval)\r\n*value = level;\r\nreturn retval;\r\n}\r\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = (struct slot *)hotplug_slot->private;\r\n*value = slot->hotplug_slot->info->attention_status;\r\nreturn 0;\r\n}\r\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = (struct slot *)hotplug_slot->private;\r\nint rc, state;\r\nrc = rpaphp_get_sensor_state(slot, &state);\r\n*value = NOT_VALID;\r\nif (rc)\r\nreturn rc;\r\nif (state == EMPTY)\r\n*value = EMPTY;\r\nelse if (state == PRESENT)\r\n*value = slot->state;\r\nreturn 0;\r\n}\r\nstatic enum pci_bus_speed get_max_bus_speed(struct slot *slot)\r\n{\r\nenum pci_bus_speed speed;\r\nswitch (slot->type) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\nspeed = PCI_SPEED_33MHz;\r\nbreak;\r\ncase 7:\r\ncase 8:\r\nspeed = PCI_SPEED_66MHz;\r\nbreak;\r\ncase 11:\r\ncase 14:\r\nspeed = PCI_SPEED_66MHz_PCIX;\r\nbreak;\r\ncase 12:\r\ncase 15:\r\nspeed = PCI_SPEED_100MHz_PCIX;\r\nbreak;\r\ncase 13:\r\ncase 16:\r\nspeed = PCI_SPEED_133MHz_PCIX;\r\nbreak;\r\ndefault:\r\nspeed = PCI_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\nreturn speed;\r\n}\r\nstatic int get_children_props(struct device_node *dn, const int **drc_indexes,\r\nconst int **drc_names, const int **drc_types,\r\nconst int **drc_power_domains)\r\n{\r\nconst int *indexes, *names, *types, *domains;\r\nindexes = of_get_property(dn, "ibm,drc-indexes", NULL);\r\nnames = of_get_property(dn, "ibm,drc-names", NULL);\r\ntypes = of_get_property(dn, "ibm,drc-types", NULL);\r\ndomains = of_get_property(dn, "ibm,drc-power-domains", NULL);\r\nif (!indexes || !names || !types || !domains) {\r\nreturn -EINVAL;\r\n}\r\nif (drc_indexes)\r\n*drc_indexes = indexes;\r\nif (drc_names)\r\n*drc_names = names;\r\nif (drc_types)\r\n*drc_types = types;\r\nif (drc_power_domains)\r\n*drc_power_domains = domains;\r\nreturn 0;\r\n}\r\nint rpaphp_get_drc_props(struct device_node *dn, int *drc_index,\r\nchar **drc_name, char **drc_type, int *drc_power_domain)\r\n{\r\nconst int *indexes, *names;\r\nconst int *types, *domains;\r\nconst unsigned int *my_index;\r\nchar *name_tmp, *type_tmp;\r\nint i, rc;\r\nmy_index = of_get_property(dn, "ibm,my-drc-index", NULL);\r\nif (!my_index) {\r\nreturn -EINVAL;\r\n}\r\nrc = get_children_props(dn->parent, &indexes, &names, &types, &domains);\r\nif (rc < 0) {\r\nreturn -EINVAL;\r\n}\r\nname_tmp = (char *) &names[1];\r\ntype_tmp = (char *) &types[1];\r\nfor (i = 0; i < be32_to_cpu(indexes[0]); i++) {\r\nif ((unsigned int) indexes[i + 1] == *my_index) {\r\nif (drc_name)\r\n*drc_name = name_tmp;\r\nif (drc_type)\r\n*drc_type = type_tmp;\r\nif (drc_index)\r\n*drc_index = be32_to_cpu(*my_index);\r\nif (drc_power_domain)\r\n*drc_power_domain = be32_to_cpu(domains[i+1]);\r\nreturn 0;\r\n}\r\nname_tmp += (strlen(name_tmp) + 1);\r\ntype_tmp += (strlen(type_tmp) + 1);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int is_php_type(char *drc_type)\r\n{\r\nunsigned long value;\r\nchar *endptr;\r\nvalue = simple_strtoul(drc_type, &endptr, 10);\r\nif (endptr == drc_type)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int is_php_dn(struct device_node *dn, const int **indexes,\r\nconst int **names, const int **types, const int **power_domains)\r\n{\r\nconst int *drc_types;\r\nint rc;\r\nrc = get_children_props(dn, indexes, names, &drc_types, power_domains);\r\nif (rc < 0)\r\nreturn 0;\r\nif (!is_php_type((char *) &drc_types[1]))\r\nreturn 0;\r\n*types = drc_types;\r\nreturn 1;\r\n}\r\nint rpaphp_add_slot(struct device_node *dn)\r\n{\r\nstruct slot *slot;\r\nint retval = 0;\r\nint i;\r\nconst int *indexes, *names, *types, *power_domains;\r\nchar *name, *type;\r\nif (!dn->name || strcmp(dn->name, "pci"))\r\nreturn 0;\r\nif (!is_php_dn(dn, &indexes, &names, &types, &power_domains))\r\nreturn 0;\r\ndbg("Entry %s: dn->full_name=%s\n", __func__, dn->full_name);\r\nname = (char *) &names[1];\r\ntype = (char *) &types[1];\r\nfor (i = 0; i < be32_to_cpu(indexes[0]); i++) {\r\nint index;\r\nindex = be32_to_cpu(indexes[i + 1]);\r\nslot = alloc_slot_struct(dn, index, name,\r\nbe32_to_cpu(power_domains[i + 1]));\r\nif (!slot)\r\nreturn -ENOMEM;\r\nslot->type = simple_strtoul(type, NULL, 10);\r\ndbg("Found drc-index:0x%x drc-name:%s drc-type:%s\n",\r\nindex, name, type);\r\nretval = rpaphp_enable_slot(slot);\r\nif (!retval)\r\nretval = rpaphp_register_slot(slot);\r\nif (retval)\r\ndealloc_slot_struct(slot);\r\nname += strlen(name) + 1;\r\ntype += strlen(type) + 1;\r\n}\r\ndbg("%s - Exit: rc[%d]\n", __func__, retval);\r\nreturn retval;\r\n}\r\nstatic void __exit cleanup_slots(void)\r\n{\r\nstruct list_head *tmp, *n;\r\nstruct slot *slot;\r\nlist_for_each_safe(tmp, n, &rpaphp_slot_head) {\r\nslot = list_entry(tmp, struct slot, rpaphp_slot_list);\r\nlist_del(&slot->rpaphp_slot_list);\r\npci_hp_deregister(slot->hotplug_slot);\r\n}\r\nreturn;\r\n}\r\nstatic int __init rpaphp_init(void)\r\n{\r\nstruct device_node *dn;\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\nfor_each_node_by_name(dn, "pci")\r\nrpaphp_add_slot(dn);\r\nreturn 0;\r\n}\r\nstatic void __exit rpaphp_exit(void)\r\n{\r\ncleanup_slots();\r\n}\r\nstatic int enable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = (struct slot *)hotplug_slot->private;\r\nint state;\r\nint retval;\r\nif (slot->state == CONFIGURED)\r\nreturn 0;\r\nretval = rpaphp_get_sensor_state(slot, &state);\r\nif (retval)\r\nreturn retval;\r\nif (state == PRESENT) {\r\npci_lock_rescan_remove();\r\npcibios_add_pci_devices(slot->bus);\r\npci_unlock_rescan_remove();\r\nslot->state = CONFIGURED;\r\n} else if (state == EMPTY) {\r\nslot->state = EMPTY;\r\n} else {\r\nerr("%s: slot[%s] is in invalid state\n", __func__, slot->name);\r\nslot->state = NOT_VALID;\r\nreturn -EINVAL;\r\n}\r\nslot->bus->max_bus_speed = get_max_bus_speed(slot);\r\nreturn 0;\r\n}\r\nstatic int disable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = (struct slot *)hotplug_slot->private;\r\nif (slot->state == NOT_CONFIGURED)\r\nreturn -EINVAL;\r\npci_lock_rescan_remove();\r\npcibios_remove_pci_devices(slot->bus);\r\npci_unlock_rescan_remove();\r\nvm_unmap_aliases();\r\nslot->state = NOT_CONFIGURED;\r\nreturn 0;\r\n}
