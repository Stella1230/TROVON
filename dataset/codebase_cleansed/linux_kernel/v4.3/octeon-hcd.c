static inline struct octeon_hcd *cvmx_usb_to_octeon(struct cvmx_usb_state *p)\r\n{\r\nreturn container_of(p, struct octeon_hcd, usb);\r\n}\r\nstatic inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)\r\n{\r\nreturn container_of((void *)p, struct usb_hcd, hcd_priv);\r\n}\r\nstatic int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)\r\n{\r\nstruct octeon_temp_buffer *temp;\r\nif (urb->num_sgs || urb->sg ||\r\n(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) ||\r\n!(urb->transfer_buffer_length % sizeof(u32)))\r\nreturn 0;\r\ntemp = kmalloc(ALIGN(urb->transfer_buffer_length, sizeof(u32)) +\r\nsizeof(*temp), mem_flags);\r\nif (!temp)\r\nreturn -ENOMEM;\r\ntemp->orig_buffer = urb->transfer_buffer;\r\nif (usb_urb_dir_out(urb))\r\nmemcpy(temp->data, urb->transfer_buffer,\r\nurb->transfer_buffer_length);\r\nurb->transfer_buffer = temp->data;\r\nurb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\r\nreturn 0;\r\n}\r\nstatic void octeon_free_temp_buffer(struct urb *urb)\r\n{\r\nstruct octeon_temp_buffer *temp;\r\nsize_t length;\r\nif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\r\nreturn;\r\ntemp = container_of(urb->transfer_buffer, struct octeon_temp_buffer,\r\ndata);\r\nif (usb_urb_dir_in(urb)) {\r\nif (usb_pipeisoc(urb->pipe))\r\nlength = urb->transfer_buffer_length;\r\nelse\r\nlength = urb->actual_length;\r\nmemcpy(temp->orig_buffer, urb->transfer_buffer, length);\r\n}\r\nurb->transfer_buffer = temp->orig_buffer;\r\nurb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\r\nkfree(temp);\r\n}\r\nstatic int octeon_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint ret;\r\nret = octeon_alloc_temp_buffer(urb, mem_flags);\r\nif (ret)\r\nreturn ret;\r\nret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\r\nif (ret)\r\nocteon_free_temp_buffer(urb);\r\nreturn ret;\r\n}\r\nstatic void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\r\n{\r\nusb_hcd_unmap_urb_for_dma(hcd, urb);\r\nocteon_free_temp_buffer(urb);\r\n}\r\nstatic inline uint32_t cvmx_usb_read_csr32(struct cvmx_usb_state *usb,\r\nuint64_t address)\r\n{\r\nuint32_t result = cvmx_read64_uint32(address ^ 4);\r\nreturn result;\r\n}\r\nstatic inline void cvmx_usb_write_csr32(struct cvmx_usb_state *usb,\r\nuint64_t address, uint32_t value)\r\n{\r\ncvmx_write64_uint32(address ^ 4, value);\r\ncvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));\r\n}\r\nstatic inline int cvmx_usb_pipe_needs_split(struct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe)\r\n{\r\nreturn pipe->device_speed != CVMX_USB_SPEED_HIGH &&\r\nusb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;\r\n}\r\nstatic inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)\r\n{\r\nif (pipe->pid_toggle)\r\nreturn 2;\r\nreturn 0;\r\n}\r\nstatic void cvmx_fifo_setup(struct cvmx_usb_state *usb)\r\n{\r\nunion cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;\r\nunion cvmx_usbcx_gnptxfsiz npsiz;\r\nunion cvmx_usbcx_hptxfsiz psiz;\r\nusbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GHWCFG3(usb->index));\r\nUSB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), cvmx_usbcx_grxfsiz,\r\nrxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);\r\nnpsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));\r\nnpsiz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;\r\nnpsiz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), npsiz.u32);\r\npsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));\r\npsiz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;\r\npsiz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), psiz.u32);\r\nUSB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\r\ncvmx_usbcx_grstctl, txfnum, 0x10);\r\nUSB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\r\ncvmx_usbcx_grstctl, txfflsh, 1);\r\nCVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\r\ncvmx_usbcx_grstctl, c.s.txfflsh == 0, 100);\r\nUSB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\r\ncvmx_usbcx_grstctl, rxfflsh, 1);\r\nCVMX_WAIT_FOR_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\r\ncvmx_usbcx_grstctl, c.s.rxfflsh == 0, 100);\r\n}\r\nstatic int cvmx_usb_shutdown(struct cvmx_usb_state *usb)\r\n{\r\nunion cvmx_usbnx_clk_ctl usbn_clk_ctl;\r\nif (!list_empty(&usb->idle_pipes) ||\r\n!list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||\r\n!list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||\r\n!list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||\r\n!list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))\r\nreturn -EBUSY;\r\nusbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));\r\nusbn_clk_ctl.s.enable = 1;\r\nusbn_clk_ctl.s.por = 1;\r\nusbn_clk_ctl.s.hclk_rst = 1;\r\nusbn_clk_ctl.s.prst = 0;\r\nusbn_clk_ctl.s.hrst = 0;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\nreturn 0;\r\n}\r\nstatic int cvmx_usb_initialize(struct device *dev,\r\nstruct cvmx_usb_state *usb)\r\n{\r\nint channel;\r\nint divisor;\r\nint retries = 0;\r\nunion cvmx_usbcx_hcfg usbcx_hcfg;\r\nunion cvmx_usbnx_clk_ctl usbn_clk_ctl;\r\nunion cvmx_usbcx_gintsts usbc_gintsts;\r\nunion cvmx_usbcx_gahbcfg usbcx_gahbcfg;\r\nunion cvmx_usbcx_gintmsk usbcx_gintmsk;\r\nunion cvmx_usbcx_gusbcfg usbcx_gusbcfg;\r\nunion cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;\r\nretry:\r\nusbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));\r\nusbn_clk_ctl.s.por = 1;\r\nusbn_clk_ctl.s.hrst = 0;\r\nusbn_clk_ctl.s.prst = 0;\r\nusbn_clk_ctl.s.hclk_rst = 0;\r\nusbn_clk_ctl.s.enable = 0;\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND) {\r\nif (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN56XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN50XX))\r\nusbn_clk_ctl.s.p_rtype = 2;\r\nelse\r\nusbn_clk_ctl.s.p_rtype = 1;\r\nswitch (usb->init_flags &\r\nCVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {\r\ncase CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:\r\nusbn_clk_ctl.s.p_c_sel = 0;\r\nbreak;\r\ncase CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:\r\nusbn_clk_ctl.s.p_c_sel = 1;\r\nbreak;\r\ncase CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:\r\nusbn_clk_ctl.s.p_c_sel = 2;\r\nbreak;\r\n}\r\n} else {\r\nif (OCTEON_IS_MODEL(OCTEON_CN3XXX))\r\nusbn_clk_ctl.s.p_rtype = 3;\r\nelse\r\nusbn_clk_ctl.s.p_rtype = 0;\r\nusbn_clk_ctl.s.p_c_sel = 0;\r\n}\r\ndivisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);\r\nif (divisor < 4)\r\ndivisor = 4;\r\nusbn_clk_ctl.s.divide = divisor;\r\nusbn_clk_ctl.s.divide2 = 0;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\nusbn_clk_ctl.s.hclk_rst = 1;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\ncvmx_wait(64);\r\nusbn_clk_ctl.s.por = 0;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\nmdelay(1);\r\nusbn_usbp_ctl_status.u64 =\r\ncvmx_read64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index));\r\nusbn_usbp_ctl_status.s.ate_reset = 1;\r\ncvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),\r\nusbn_usbp_ctl_status.u64);\r\ncvmx_wait(10);\r\nusbn_usbp_ctl_status.s.ate_reset = 0;\r\ncvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),\r\nusbn_usbp_ctl_status.u64);\r\nusbn_clk_ctl.s.prst = 1;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\nusbn_usbp_ctl_status.s.hst_mode = 0;\r\ncvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),\r\nusbn_usbp_ctl_status.u64);\r\nudelay(1);\r\nusbn_clk_ctl.s.hrst = 1;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\nusbn_clk_ctl.s.enable = 1;\r\ncvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\r\nudelay(1);\r\nusbcx_gahbcfg.u32 = 0;\r\nusbcx_gahbcfg.s.dmaen = !(usb->init_flags &\r\nCVMX_USB_INITIALIZE_FLAGS_NO_DMA);\r\nusbcx_gahbcfg.s.hbstlen = 0;\r\nusbcx_gahbcfg.s.nptxfemplvl = 1;\r\nusbcx_gahbcfg.s.ptxfemplvl = 1;\r\nusbcx_gahbcfg.s.glblintrmsk = 1;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),\r\nusbcx_gahbcfg.u32);\r\nusbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GUSBCFG(usb->index));\r\nusbcx_gusbcfg.s.toutcal = 0;\r\nusbcx_gusbcfg.s.ddrsel = 0;\r\nusbcx_gusbcfg.s.usbtrdtim = 0x5;\r\nusbcx_gusbcfg.s.phylpwrclksel = 0;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),\r\nusbcx_gusbcfg.u32);\r\nusbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GINTMSK(usb->index));\r\nusbcx_gintmsk.s.otgintmsk = 1;\r\nusbcx_gintmsk.s.modemismsk = 1;\r\nusbcx_gintmsk.s.hchintmsk = 1;\r\nusbcx_gintmsk.s.sofmsk = 0;\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\r\nusbcx_gintmsk.s.rxflvlmsk = 1;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),\r\nusbcx_gintmsk.u32);\r\nfor (channel = 0; channel < 8; channel++)\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCINTMSKX(channel, usb->index),\r\n0);\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, prtintmsk, 1);\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, disconnintmsk, 1);\r\nusbcx_hcfg.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));\r\nusbcx_hcfg.s.fslssupp = 0;\r\nusbcx_hcfg.s.fslspclksel = 0;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);\r\ncvmx_fifo_setup(usb);\r\nusbc_gintsts.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GINTSTS(usb->index));\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),\r\nusbc_gintsts.u32);\r\ndev_dbg(dev, "gintsts after reset: 0x%x\n", (int)usbc_gintsts.u32);\r\nif (!usbc_gintsts.s.disconnint && !usbc_gintsts.s.prtint)\r\nreturn 0;\r\nif (retries++ >= 5)\r\nreturn -EAGAIN;\r\ndev_info(dev, "controller reset failed (gintsts=0x%x) - retrying\n",\r\n(int)usbc_gintsts.u32);\r\nmsleep(50);\r\ncvmx_usb_shutdown(usb);\r\nmsleep(50);\r\ngoto retry;\r\n}\r\nstatic void cvmx_usb_reset_port(struct cvmx_usb_state *usb)\r\n{\r\nusb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HPRT(usb->index));\r\nUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,\r\nprtrst, 1);\r\nmdelay(50);\r\nUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,\r\nprtrst, 0);\r\nusb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HPRT(usb->index));\r\n}\r\nstatic int cvmx_usb_disable(struct cvmx_usb_state *usb)\r\n{\r\nUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,\r\nprtena, 1);\r\nreturn 0;\r\n}\r\nstatic struct cvmx_usb_port_status cvmx_usb_get_status(\r\nstruct cvmx_usb_state *usb)\r\n{\r\nunion cvmx_usbcx_hprt usbc_hprt;\r\nstruct cvmx_usb_port_status result;\r\nmemset(&result, 0, sizeof(result));\r\nusbc_hprt.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));\r\nresult.port_enabled = usbc_hprt.s.prtena;\r\nresult.port_over_current = usbc_hprt.s.prtovrcurract;\r\nresult.port_powered = usbc_hprt.s.prtpwr;\r\nresult.port_speed = usbc_hprt.s.prtspd;\r\nresult.connected = usbc_hprt.s.prtconnsts;\r\nresult.connect_change =\r\n(result.connected != usb->port_status.connected);\r\nreturn result;\r\n}\r\nstatic struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct cvmx_usb_state *usb,\r\nint device_addr,\r\nint endpoint_num,\r\nenum cvmx_usb_speed\r\ndevice_speed,\r\nint max_packet,\r\nenum cvmx_usb_transfer\r\ntransfer_type,\r\nenum cvmx_usb_direction\r\ntransfer_dir,\r\nint interval, int multi_count,\r\nint hub_device_addr,\r\nint hub_port)\r\n{\r\nstruct cvmx_usb_pipe *pipe;\r\npipe = kzalloc(sizeof(*pipe), GFP_ATOMIC);\r\nif (!pipe)\r\nreturn NULL;\r\nif ((device_speed == CVMX_USB_SPEED_HIGH) &&\r\n(transfer_dir == CVMX_USB_DIRECTION_OUT) &&\r\n(transfer_type == CVMX_USB_TRANSFER_BULK))\r\npipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;\r\npipe->device_addr = device_addr;\r\npipe->endpoint_num = endpoint_num;\r\npipe->device_speed = device_speed;\r\npipe->max_packet = max_packet;\r\npipe->transfer_type = transfer_type;\r\npipe->transfer_dir = transfer_dir;\r\nINIT_LIST_HEAD(&pipe->transactions);\r\nif (!interval)\r\ninterval = 1;\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\npipe->interval = interval*8;\r\npipe->next_tx_frame = ((usb->frame_number+7)&~7) +\r\npipe->interval;\r\n} else {\r\npipe->interval = interval;\r\npipe->next_tx_frame = usb->frame_number + pipe->interval;\r\n}\r\npipe->multi_count = multi_count;\r\npipe->hub_device_addr = hub_device_addr;\r\npipe->hub_port = hub_port;\r\npipe->pid_toggle = 0;\r\npipe->split_sc_frame = -1;\r\nlist_add_tail(&pipe->node, &usb->idle_pipes);\r\nreturn pipe;\r\n}\r\nstatic void cvmx_usb_poll_rx_fifo(struct cvmx_usb_state *usb)\r\n{\r\nunion cvmx_usbcx_grxstsph rx_status;\r\nint channel;\r\nint bytes;\r\nuint64_t address;\r\nuint32_t *ptr;\r\nrx_status.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GRXSTSPH(usb->index));\r\nif (rx_status.s.pktsts != 2)\r\nreturn;\r\nif (!rx_status.s.bcnt)\r\nreturn;\r\nchannel = rx_status.s.chnum;\r\nbytes = rx_status.s.bcnt;\r\nif (!bytes)\r\nreturn;\r\naddress = cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +\r\nchannel * 8);\r\nptr = cvmx_phys_to_ptr(address);\r\ncvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8,\r\naddress + bytes);\r\nwhile (bytes > 0) {\r\n*ptr++ = cvmx_usb_read_csr32(usb,\r\nUSB_FIFO_ADDRESS(channel, usb->index));\r\nbytes -= 4;\r\n}\r\nCVMX_SYNCW;\r\n}\r\nstatic int cvmx_usb_fill_tx_hw(struct cvmx_usb_state *usb,\r\nstruct cvmx_usb_tx_fifo *fifo, int available)\r\n{\r\nwhile (available && (fifo->head != fifo->tail)) {\r\nint i = fifo->tail;\r\nconst uint32_t *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);\r\nuint64_t csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,\r\nusb->index) ^ 4;\r\nint words = available;\r\nif (fifo->entry[i].size <= available) {\r\nwords = fifo->entry[i].size;\r\nfifo->tail++;\r\nif (fifo->tail > MAX_CHANNELS)\r\nfifo->tail = 0;\r\n}\r\navailable -= words;\r\nfifo->entry[i].address += words * 4;\r\nfifo->entry[i].size -= words;\r\nwhile (words > 3) {\r\ncvmx_write64_uint32(csr_address, *ptr++);\r\ncvmx_write64_uint32(csr_address, *ptr++);\r\ncvmx_write64_uint32(csr_address, *ptr++);\r\ncvmx_read64_uint64(\r\nCVMX_USBNX_DMA0_INB_CHN0(usb->index));\r\nwords -= 3;\r\n}\r\ncvmx_write64_uint32(csr_address, *ptr++);\r\nif (--words) {\r\ncvmx_write64_uint32(csr_address, *ptr++);\r\nif (--words)\r\ncvmx_write64_uint32(csr_address, *ptr++);\r\n}\r\ncvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));\r\n}\r\nreturn fifo->head != fifo->tail;\r\n}\r\nstatic void cvmx_usb_poll_tx_fifo(struct cvmx_usb_state *usb)\r\n{\r\nif (usb->periodic.head != usb->periodic.tail) {\r\nunion cvmx_usbcx_hptxsts tx_status;\r\ntx_status.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HPTXSTS(usb->index));\r\nif (cvmx_usb_fill_tx_hw(usb, &usb->periodic,\r\ntx_status.s.ptxfspcavail))\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, ptxfempmsk, 1);\r\nelse\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, ptxfempmsk, 0);\r\n}\r\nif (usb->nonperiodic.head != usb->nonperiodic.tail) {\r\nunion cvmx_usbcx_gnptxsts tx_status;\r\ntx_status.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GNPTXSTS(usb->index));\r\nif (cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,\r\ntx_status.s.nptxfspcavail))\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, nptxfempmsk, 1);\r\nelse\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, nptxfempmsk, 0);\r\n}\r\n}\r\nstatic void cvmx_usb_fill_tx_fifo(struct cvmx_usb_state *usb, int channel)\r\n{\r\nunion cvmx_usbcx_hccharx hcchar;\r\nunion cvmx_usbcx_hcspltx usbc_hcsplt;\r\nunion cvmx_usbcx_hctsizx usbc_hctsiz;\r\nstruct cvmx_usb_tx_fifo *fifo;\r\nhcchar.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCCHARX(channel, usb->index));\r\nif (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)\r\nreturn;\r\nusbc_hcsplt.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCSPLTX(channel, usb->index));\r\nif (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)\r\nreturn;\r\nusbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCTSIZX(channel, usb->index));\r\nif (!usbc_hctsiz.s.xfersize)\r\nreturn;\r\nif ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) ||\r\n(hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))\r\nfifo = &usb->periodic;\r\nelse\r\nfifo = &usb->nonperiodic;\r\nfifo->entry[fifo->head].channel = channel;\r\nfifo->entry[fifo->head].address =\r\ncvmx_read64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +\r\nchannel * 8);\r\nfifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize+3)>>2;\r\nfifo->head++;\r\nif (fifo->head > MAX_CHANNELS)\r\nfifo->head = 0;\r\ncvmx_usb_poll_tx_fifo(usb);\r\n}\r\nstatic void cvmx_usb_start_channel_control(struct cvmx_usb_state *usb,\r\nint channel,\r\nstruct cvmx_usb_pipe *pipe)\r\n{\r\nstruct octeon_hcd *priv = cvmx_usb_to_octeon(usb);\r\nstruct usb_hcd *hcd = octeon_to_hcd(priv);\r\nstruct device *dev = hcd->self.controller;\r\nstruct cvmx_usb_transaction *transaction =\r\nlist_first_entry(&pipe->transactions, typeof(*transaction),\r\nnode);\r\nstruct usb_ctrlrequest *header =\r\ncvmx_phys_to_ptr(transaction->control_header);\r\nint bytes_to_transfer = transaction->buffer_length -\r\ntransaction->actual_bytes;\r\nint packets_to_transfer;\r\nunion cvmx_usbcx_hctsizx usbc_hctsiz;\r\nusbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCTSIZX(channel, usb->index));\r\nswitch (transaction->stage) {\r\ncase CVMX_USB_STAGE_NON_CONTROL:\r\ncase CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:\r\ndev_err(dev, "%s: ERROR - Non control stage\n", __func__);\r\nbreak;\r\ncase CVMX_USB_STAGE_SETUP:\r\nusbc_hctsiz.s.pid = 3;\r\nbytes_to_transfer = sizeof(*header);\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, epdir,\r\nCVMX_USB_DIRECTION_OUT);\r\ncvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +\r\nchannel * 8,\r\ntransaction->control_header);\r\nbreak;\r\ncase CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:\r\nusbc_hctsiz.s.pid = 3;\r\nbytes_to_transfer = 0;\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, epdir,\r\nCVMX_USB_DIRECTION_OUT);\r\nUSB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),\r\ncvmx_usbcx_hcspltx, compsplt, 1);\r\nbreak;\r\ncase CVMX_USB_STAGE_DATA:\r\nusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\nif (header->bRequestType & USB_DIR_IN)\r\nbytes_to_transfer = 0;\r\nelse if (bytes_to_transfer > pipe->max_packet)\r\nbytes_to_transfer = pipe->max_packet;\r\n}\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, epdir,\r\n((header->bRequestType & USB_DIR_IN) ?\r\nCVMX_USB_DIRECTION_IN :\r\nCVMX_USB_DIRECTION_OUT));\r\nbreak;\r\ncase CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:\r\nusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\r\nif (!(header->bRequestType & USB_DIR_IN))\r\nbytes_to_transfer = 0;\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, epdir,\r\n((header->bRequestType & USB_DIR_IN) ?\r\nCVMX_USB_DIRECTION_IN :\r\nCVMX_USB_DIRECTION_OUT));\r\nUSB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),\r\ncvmx_usbcx_hcspltx, compsplt, 1);\r\nbreak;\r\ncase CVMX_USB_STAGE_STATUS:\r\nusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\r\nbytes_to_transfer = 0;\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, epdir,\r\n((header->bRequestType & USB_DIR_IN) ?\r\nCVMX_USB_DIRECTION_OUT :\r\nCVMX_USB_DIRECTION_IN));\r\nbreak;\r\ncase CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:\r\nusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\r\nbytes_to_transfer = 0;\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, epdir,\r\n((header->bRequestType & USB_DIR_IN) ?\r\nCVMX_USB_DIRECTION_OUT :\r\nCVMX_USB_DIRECTION_IN));\r\nUSB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),\r\ncvmx_usbcx_hcspltx, compsplt, 1);\r\nbreak;\r\n}\r\nif (bytes_to_transfer > MAX_TRANSFER_BYTES) {\r\nbytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;\r\nbytes_to_transfer *= pipe->max_packet;\r\n}\r\npackets_to_transfer = DIV_ROUND_UP(bytes_to_transfer,\r\npipe->max_packet);\r\nif (packets_to_transfer == 0)\r\npackets_to_transfer = 1;\r\nelse if ((packets_to_transfer > 1) &&\r\n(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {\r\npackets_to_transfer = 1;\r\nbytes_to_transfer = packets_to_transfer * pipe->max_packet;\r\n} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {\r\npackets_to_transfer = MAX_TRANSFER_PACKETS;\r\nbytes_to_transfer = packets_to_transfer * pipe->max_packet;\r\n}\r\nusbc_hctsiz.s.xfersize = bytes_to_transfer;\r\nusbc_hctsiz.s.pktcnt = packets_to_transfer;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),\r\nusbc_hctsiz.u32);\r\n}\r\nstatic void cvmx_usb_start_channel(struct cvmx_usb_state *usb, int channel,\r\nstruct cvmx_usb_pipe *pipe)\r\n{\r\nstruct cvmx_usb_transaction *transaction =\r\nlist_first_entry(&pipe->transactions, typeof(*transaction),\r\nnode);\r\nCVMX_SYNCW;\r\nusb->pipe_for_channel[channel] = pipe;\r\npipe->channel = channel;\r\npipe->flags |= CVMX_USB_PIPE_FLAGS_SCHEDULED;\r\nusb->idle_hardware_channels &= ~(1<<channel);\r\n{\r\nunion cvmx_usbcx_hcintx usbc_hcint;\r\nunion cvmx_usbcx_hcintmskx usbc_hcintmsk;\r\nunion cvmx_usbcx_haintmsk usbc_haintmsk;\r\nusbc_hcint.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCINTX(channel, usb->index));\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCINTX(channel, usb->index),\r\nusbc_hcint.u32);\r\nusbc_hcintmsk.u32 = 0;\r\nusbc_hcintmsk.s.chhltdmsk = 1;\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {\r\nusbc_hcintmsk.s.datatglerrmsk = 1;\r\nusbc_hcintmsk.s.frmovrunmsk = 1;\r\nusbc_hcintmsk.s.bblerrmsk = 1;\r\nusbc_hcintmsk.s.xacterrmsk = 1;\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\nusbc_hcintmsk.s.nyetmsk = 1;\r\nusbc_hcintmsk.s.ackmsk = 1;\r\n}\r\nusbc_hcintmsk.s.nakmsk = 1;\r\nusbc_hcintmsk.s.stallmsk = 1;\r\nusbc_hcintmsk.s.xfercomplmsk = 1;\r\n}\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCINTMSKX(channel, usb->index),\r\nusbc_hcintmsk.u32);\r\nusbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HAINTMSK(usb->index));\r\nusbc_haintmsk.s.haintmsk |= 1<<channel;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index),\r\nusbc_haintmsk.u32);\r\n}\r\n{\r\nuint64_t reg;\r\nuint64_t dma_address = transaction->buffer +\r\ntransaction->actual_bytes;\r\nif (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)\r\ndma_address = transaction->buffer +\r\ntransaction->iso_packets[0].offset +\r\ntransaction->actual_bytes;\r\nif (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT)\r\nreg = CVMX_USBNX_DMA0_OUTB_CHN0(usb->index);\r\nelse\r\nreg = CVMX_USBNX_DMA0_INB_CHN0(usb->index);\r\ncvmx_write64_uint64(reg + channel * 8, dma_address);\r\n}\r\n{\r\nunion cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0};\r\nunion cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0};\r\nint packets_to_transfer;\r\nint bytes_to_transfer = transaction->buffer_length -\r\ntransaction->actual_bytes;\r\nif (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)\r\nbytes_to_transfer =\r\ntransaction->iso_packets[0].length -\r\ntransaction->actual_bytes;\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\nif ((transaction->stage&1) == 0) {\r\nif (transaction->type == CVMX_USB_TRANSFER_BULK)\r\npipe->split_sc_frame =\r\n(usb->frame_number + 1) & 0x7f;\r\nelse\r\npipe->split_sc_frame =\r\n(usb->frame_number + 2) & 0x7f;\r\n} else\r\npipe->split_sc_frame = -1;\r\nusbc_hcsplt.s.spltena = 1;\r\nusbc_hcsplt.s.hubaddr = pipe->hub_device_addr;\r\nusbc_hcsplt.s.prtaddr = pipe->hub_port;\r\nusbc_hcsplt.s.compsplt = (transaction->stage ==\r\nCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);\r\nif (bytes_to_transfer > pipe->max_packet)\r\nbytes_to_transfer = pipe->max_packet;\r\nif (!usbc_hcsplt.s.compsplt &&\r\n(pipe->transfer_dir ==\r\nCVMX_USB_DIRECTION_OUT) &&\r\n(pipe->transfer_type ==\r\nCVMX_USB_TRANSFER_ISOCHRONOUS)) {\r\npipe->split_sc_frame = -1;\r\nif (transaction->actual_bytes == 0) {\r\nif (bytes_to_transfer <= 188)\r\nusbc_hcsplt.s.xactpos = 3;\r\nelse\r\nusbc_hcsplt.s.xactpos = 2;\r\n} else {\r\nif (bytes_to_transfer <= 188)\r\nusbc_hcsplt.s.xactpos = 1;\r\nelse\r\nusbc_hcsplt.s.xactpos = 0;\r\n}\r\nif (bytes_to_transfer > 188)\r\nbytes_to_transfer = 188;\r\n}\r\n}\r\nif (bytes_to_transfer > MAX_TRANSFER_BYTES) {\r\nbytes_to_transfer = MAX_TRANSFER_BYTES /\r\npipe->max_packet;\r\nbytes_to_transfer *= pipe->max_packet;\r\n}\r\npackets_to_transfer =\r\nDIV_ROUND_UP(bytes_to_transfer, pipe->max_packet);\r\nif (packets_to_transfer == 0)\r\npackets_to_transfer = 1;\r\nelse if ((packets_to_transfer > 1) &&\r\n(usb->init_flags &\r\nCVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {\r\npackets_to_transfer = 1;\r\nbytes_to_transfer = packets_to_transfer *\r\npipe->max_packet;\r\n} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {\r\npackets_to_transfer = MAX_TRANSFER_PACKETS;\r\nbytes_to_transfer = packets_to_transfer *\r\npipe->max_packet;\r\n}\r\nusbc_hctsiz.s.xfersize = bytes_to_transfer;\r\nusbc_hctsiz.s.pktcnt = packets_to_transfer;\r\nusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\r\nif (pipe->flags & CVMX_USB_PIPE_FLAGS_NEED_PING)\r\nusbc_hctsiz.s.dopng = 1;\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCSPLTX(channel, usb->index),\r\nusbc_hcsplt.u32);\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCTSIZX(channel, usb->index),\r\nusbc_hctsiz.u32);\r\n}\r\n{\r\nunion cvmx_usbcx_hccharx usbc_hcchar = {.u32 = 0};\r\nusbc_hcchar.s.oddfrm = usb->frame_number&1;\r\nif (cvmx_usb_pipe_needs_split(usb, pipe))\r\nusbc_hcchar.s.ec = 1;\r\nelse if (pipe->multi_count < 1)\r\nusbc_hcchar.s.ec = 1;\r\nelse if (pipe->multi_count > 3)\r\nusbc_hcchar.s.ec = 3;\r\nelse\r\nusbc_hcchar.s.ec = pipe->multi_count;\r\nusbc_hcchar.s.devaddr = pipe->device_addr;\r\nusbc_hcchar.s.eptype = transaction->type;\r\nusbc_hcchar.s.lspddev =\r\n(pipe->device_speed == CVMX_USB_SPEED_LOW);\r\nusbc_hcchar.s.epdir = pipe->transfer_dir;\r\nusbc_hcchar.s.epnum = pipe->endpoint_num;\r\nusbc_hcchar.s.mps = pipe->max_packet;\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCCHARX(channel, usb->index),\r\nusbc_hcchar.u32);\r\n}\r\nswitch (transaction->type) {\r\ncase CVMX_USB_TRANSFER_CONTROL:\r\ncvmx_usb_start_channel_control(usb, channel, pipe);\r\nbreak;\r\ncase CVMX_USB_TRANSFER_BULK:\r\ncase CVMX_USB_TRANSFER_INTERRUPT:\r\nbreak;\r\ncase CVMX_USB_TRANSFER_ISOCHRONOUS:\r\nif (!cvmx_usb_pipe_needs_split(usb, pipe)) {\r\nif (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {\r\nif (pipe->multi_count < 2)\r\nUSB_SET_FIELD32(\r\nCVMX_USBCX_HCTSIZX(channel,\r\nusb->index),\r\ncvmx_usbcx_hctsizx, pid, 0);\r\nelse\r\nUSB_SET_FIELD32(\r\nCVMX_USBCX_HCTSIZX(channel,\r\nusb->index),\r\ncvmx_usbcx_hctsizx, pid, 3);\r\n}\r\n}\r\nbreak;\r\n}\r\n{\r\nunion cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 =\r\ncvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCTSIZX(channel, usb->index))};\r\ntransaction->xfersize = usbc_hctsiz.s.xfersize;\r\ntransaction->pktcnt = usbc_hctsiz.s.pktcnt;\r\n}\r\nif (cvmx_usb_pipe_needs_split(usb, pipe))\r\nusb->active_split = transaction;\r\nUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\r\ncvmx_usbcx_hccharx, chena, 1);\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\r\ncvmx_usb_fill_tx_fifo(usb, channel);\r\n}\r\nstatic struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(\r\nstruct cvmx_usb_state *usb,\r\nstruct list_head *list,\r\nuint64_t current_frame)\r\n{\r\nstruct cvmx_usb_pipe *pipe;\r\nlist_for_each_entry(pipe, list, node) {\r\nstruct cvmx_usb_transaction *t =\r\nlist_first_entry(&pipe->transactions, typeof(*t),\r\nnode);\r\nif (!(pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&\r\n(pipe->next_tx_frame <= current_frame) &&\r\n((pipe->split_sc_frame == -1) ||\r\n((((int)current_frame - (int)pipe->split_sc_frame)\r\n& 0x7f) < 0x40)) &&\r\n(!usb->active_split || (usb->active_split == t))) {\r\nprefetch(t);\r\nreturn pipe;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void cvmx_usb_schedule(struct cvmx_usb_state *usb, int is_sof)\r\n{\r\nint channel;\r\nstruct cvmx_usb_pipe *pipe;\r\nint need_sof;\r\nenum cvmx_usb_transfer ttype;\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {\r\nunion cvmx_usbcx_hfnum hfnum = {\r\n.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HFNUM(usb->index))\r\n};\r\nunion cvmx_usbcx_hfir hfir = {\r\n.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HFIR(usb->index))\r\n};\r\nif (hfnum.s.frrem < hfir.s.frint/4)\r\ngoto done;\r\n}\r\nwhile (usb->idle_hardware_channels) {\r\nchannel = __fls(usb->idle_hardware_channels);\r\nif (unlikely(channel > 7))\r\nbreak;\r\npipe = NULL;\r\nif (is_sof) {\r\npipe = cvmx_usb_find_ready_pipe(usb,\r\nusb->active_pipes +\r\nCVMX_USB_TRANSFER_ISOCHRONOUS,\r\nusb->frame_number);\r\nif (likely(!pipe))\r\npipe = cvmx_usb_find_ready_pipe(usb,\r\nusb->active_pipes +\r\nCVMX_USB_TRANSFER_INTERRUPT,\r\nusb->frame_number);\r\n}\r\nif (likely(!pipe)) {\r\npipe = cvmx_usb_find_ready_pipe(usb,\r\nusb->active_pipes +\r\nCVMX_USB_TRANSFER_CONTROL,\r\nusb->frame_number);\r\nif (likely(!pipe))\r\npipe = cvmx_usb_find_ready_pipe(usb,\r\nusb->active_pipes +\r\nCVMX_USB_TRANSFER_BULK,\r\nusb->frame_number);\r\n}\r\nif (!pipe)\r\nbreak;\r\ncvmx_usb_start_channel(usb, channel, pipe);\r\n}\r\ndone:\r\nneed_sof = 0;\r\nfor (ttype = CVMX_USB_TRANSFER_CONTROL;\r\nttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {\r\nlist_for_each_entry(pipe, &usb->active_pipes[ttype], node) {\r\nif (pipe->next_tx_frame > usb->frame_number) {\r\nneed_sof = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\r\ncvmx_usbcx_gintmsk, sofmsk, need_sof);\r\n}\r\nstatic void octeon_usb_urb_complete_callback(struct cvmx_usb_state *usb,\r\nenum cvmx_usb_complete status,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct cvmx_usb_transaction\r\n*transaction,\r\nint bytes_transferred,\r\nstruct urb *urb)\r\n{\r\nstruct octeon_hcd *priv = cvmx_usb_to_octeon(usb);\r\nstruct usb_hcd *hcd = octeon_to_hcd(priv);\r\nstruct device *dev = hcd->self.controller;\r\nif (likely(status == CVMX_USB_COMPLETE_SUCCESS))\r\nurb->actual_length = bytes_transferred;\r\nelse\r\nurb->actual_length = 0;\r\nurb->hcpriv = NULL;\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nint i;\r\nstruct cvmx_usb_iso_packet *iso_packet =\r\n(struct cvmx_usb_iso_packet *) urb->setup_packet;\r\nurb->actual_length = 0;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (iso_packet[i].status ==\r\nCVMX_USB_COMPLETE_SUCCESS) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length =\r\niso_packet[i].length;\r\nurb->actual_length +=\r\nurb->iso_frame_desc[i].actual_length;\r\n} else {\r\ndev_dbg(dev, "ISOCHRONOUS packet=%d of %d status=%d pipe=%p transaction=%p size=%d\n",\r\ni, urb->number_of_packets,\r\niso_packet[i].status, pipe,\r\ntransaction, iso_packet[i].length);\r\nurb->iso_frame_desc[i].status = -EREMOTEIO;\r\n}\r\n}\r\nkfree(iso_packet);\r\nurb->setup_packet = NULL;\r\n}\r\nswitch (status) {\r\ncase CVMX_USB_COMPLETE_SUCCESS:\r\nurb->status = 0;\r\nbreak;\r\ncase CVMX_USB_COMPLETE_CANCEL:\r\nif (urb->status == 0)\r\nurb->status = -ENOENT;\r\nbreak;\r\ncase CVMX_USB_COMPLETE_STALL:\r\ndev_dbg(dev, "status=stall pipe=%p transaction=%p size=%d\n",\r\npipe, transaction, bytes_transferred);\r\nurb->status = -EPIPE;\r\nbreak;\r\ncase CVMX_USB_COMPLETE_BABBLEERR:\r\ndev_dbg(dev, "status=babble pipe=%p transaction=%p size=%d\n",\r\npipe, transaction, bytes_transferred);\r\nurb->status = -EPIPE;\r\nbreak;\r\ncase CVMX_USB_COMPLETE_SHORT:\r\ndev_dbg(dev, "status=short pipe=%p transaction=%p size=%d\n",\r\npipe, transaction, bytes_transferred);\r\nurb->status = -EREMOTEIO;\r\nbreak;\r\ncase CVMX_USB_COMPLETE_ERROR:\r\ncase CVMX_USB_COMPLETE_XACTERR:\r\ncase CVMX_USB_COMPLETE_DATATGLERR:\r\ncase CVMX_USB_COMPLETE_FRAMEERR:\r\ndev_dbg(dev, "status=%d pipe=%p transaction=%p size=%d\n",\r\nstatus, pipe, transaction, bytes_transferred);\r\nurb->status = -EPROTO;\r\nbreak;\r\n}\r\nusb_hcd_unlink_urb_from_ep(octeon_to_hcd(priv), urb);\r\nspin_unlock(&priv->lock);\r\nusb_hcd_giveback_urb(octeon_to_hcd(priv), urb, urb->status);\r\nspin_lock(&priv->lock);\r\n}\r\nstatic void cvmx_usb_perform_complete(struct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct cvmx_usb_transaction *transaction,\r\nenum cvmx_usb_complete complete_code)\r\n{\r\nif (usb->active_split == transaction)\r\nusb->active_split = NULL;\r\nif (unlikely(transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {\r\ntransaction->iso_packets[0].length = transaction->actual_bytes;\r\ntransaction->iso_packets[0].status = complete_code;\r\nif ((transaction->iso_number_packets > 1) &&\r\n(complete_code == CVMX_USB_COMPLETE_SUCCESS)) {\r\ntransaction->actual_bytes = 0;\r\ntransaction->iso_number_packets--;\r\ntransaction->iso_packets++;\r\ntransaction->stage = CVMX_USB_STAGE_NON_CONTROL;\r\nreturn;\r\n}\r\n}\r\nlist_del(&transaction->node);\r\nif (list_empty(&pipe->transactions))\r\nlist_move_tail(&pipe->node, &usb->idle_pipes);\r\nocteon_usb_urb_complete_callback(usb, complete_code, pipe,\r\ntransaction,\r\ntransaction->actual_bytes,\r\ntransaction->urb);\r\nkfree(transaction);\r\n}\r\nstatic struct cvmx_usb_transaction *cvmx_usb_submit_transaction(\r\nstruct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nenum cvmx_usb_transfer type,\r\nuint64_t buffer,\r\nint buffer_length,\r\nuint64_t control_header,\r\nint iso_start_frame,\r\nint iso_number_packets,\r\nstruct cvmx_usb_iso_packet *iso_packets,\r\nstruct urb *urb)\r\n{\r\nstruct cvmx_usb_transaction *transaction;\r\nif (unlikely(pipe->transfer_type != type))\r\nreturn NULL;\r\ntransaction = kzalloc(sizeof(*transaction), GFP_ATOMIC);\r\nif (unlikely(!transaction))\r\nreturn NULL;\r\ntransaction->type = type;\r\ntransaction->buffer = buffer;\r\ntransaction->buffer_length = buffer_length;\r\ntransaction->control_header = control_header;\r\ntransaction->iso_start_frame = iso_start_frame;\r\ntransaction->iso_number_packets = iso_number_packets;\r\ntransaction->iso_packets = iso_packets;\r\ntransaction->urb = urb;\r\nif (transaction->type == CVMX_USB_TRANSFER_CONTROL)\r\ntransaction->stage = CVMX_USB_STAGE_SETUP;\r\nelse\r\ntransaction->stage = CVMX_USB_STAGE_NON_CONTROL;\r\nif (!list_empty(&pipe->transactions)) {\r\nlist_add_tail(&transaction->node, &pipe->transactions);\r\n} else {\r\nlist_add_tail(&transaction->node, &pipe->transactions);\r\nlist_move_tail(&pipe->node,\r\n&usb->active_pipes[pipe->transfer_type]);\r\ncvmx_usb_schedule(usb, 0);\r\n}\r\nreturn transaction;\r\n}\r\nstatic struct cvmx_usb_transaction *cvmx_usb_submit_bulk(\r\nstruct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nreturn cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,\r\nurb->transfer_dma,\r\nurb->transfer_buffer_length,\r\n0,\r\n0,\r\n0,\r\nNULL,\r\nurb);\r\n}\r\nstatic struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(\r\nstruct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nreturn cvmx_usb_submit_transaction(usb, pipe,\r\nCVMX_USB_TRANSFER_INTERRUPT,\r\nurb->transfer_dma,\r\nurb->transfer_buffer_length,\r\n0,\r\n0,\r\n0,\r\nNULL,\r\nurb);\r\n}\r\nstatic struct cvmx_usb_transaction *cvmx_usb_submit_control(\r\nstruct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nint buffer_length = urb->transfer_buffer_length;\r\nuint64_t control_header = urb->setup_dma;\r\nstruct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);\r\nif ((header->bRequestType & USB_DIR_IN) == 0)\r\nbuffer_length = le16_to_cpu(header->wLength);\r\nreturn cvmx_usb_submit_transaction(usb, pipe,\r\nCVMX_USB_TRANSFER_CONTROL,\r\nurb->transfer_dma, buffer_length,\r\ncontrol_header,\r\n0,\r\n0,\r\nNULL,\r\nurb);\r\n}\r\nstatic struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(\r\nstruct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct urb *urb)\r\n{\r\nstruct cvmx_usb_iso_packet *packets;\r\npackets = (struct cvmx_usb_iso_packet *) urb->setup_packet;\r\nreturn cvmx_usb_submit_transaction(usb, pipe,\r\nCVMX_USB_TRANSFER_ISOCHRONOUS,\r\nurb->transfer_dma,\r\nurb->transfer_buffer_length,\r\n0,\r\nurb->start_frame,\r\nurb->number_of_packets,\r\npackets, urb);\r\n}\r\nstatic int cvmx_usb_cancel(struct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe,\r\nstruct cvmx_usb_transaction *transaction)\r\n{\r\nif (list_first_entry(&pipe->transactions, typeof(*transaction), node) ==\r\ntransaction && (pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED)) {\r\nunion cvmx_usbcx_hccharx usbc_hcchar;\r\nusb->pipe_for_channel[pipe->channel] = NULL;\r\npipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;\r\nCVMX_SYNCW;\r\nusbc_hcchar.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCCHARX(pipe->channel, usb->index));\r\nif (usbc_hcchar.s.chena) {\r\nusbc_hcchar.s.chdis = 1;\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCCHARX(pipe->channel,\r\nusb->index),\r\nusbc_hcchar.u32);\r\n}\r\n}\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_CANCEL);\r\nreturn 0;\r\n}\r\nstatic int cvmx_usb_cancel_all(struct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe)\r\n{\r\nstruct cvmx_usb_transaction *transaction, *next;\r\nlist_for_each_entry_safe(transaction, next, &pipe->transactions, node) {\r\nint result = cvmx_usb_cancel(usb, pipe, transaction);\r\nif (unlikely(result != 0))\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cvmx_usb_close_pipe(struct cvmx_usb_state *usb,\r\nstruct cvmx_usb_pipe *pipe)\r\n{\r\nif (!list_empty(&pipe->transactions))\r\nreturn -EBUSY;\r\nlist_del(&pipe->node);\r\nkfree(pipe);\r\nreturn 0;\r\n}\r\nstatic int cvmx_usb_get_frame_number(struct cvmx_usb_state *usb)\r\n{\r\nint frame_number;\r\nunion cvmx_usbcx_hfnum usbc_hfnum;\r\nusbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));\r\nframe_number = usbc_hfnum.s.frnum;\r\nreturn frame_number;\r\n}\r\nstatic int cvmx_usb_poll_channel(struct cvmx_usb_state *usb, int channel)\r\n{\r\nstruct octeon_hcd *priv = cvmx_usb_to_octeon(usb);\r\nstruct usb_hcd *hcd = octeon_to_hcd(priv);\r\nstruct device *dev = hcd->self.controller;\r\nunion cvmx_usbcx_hcintx usbc_hcint;\r\nunion cvmx_usbcx_hctsizx usbc_hctsiz;\r\nunion cvmx_usbcx_hccharx usbc_hcchar;\r\nstruct cvmx_usb_pipe *pipe;\r\nstruct cvmx_usb_transaction *transaction;\r\nint bytes_this_transfer;\r\nint bytes_in_last_packet;\r\nint packets_processed;\r\nint buffer_space_left;\r\nusbc_hcint.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCINTX(channel, usb->index));\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {\r\nusbc_hcchar.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCCHARX(channel, usb->index));\r\nif (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCCHARX(channel,\r\nusb->index),\r\nusbc_hcchar.u32);\r\nreturn 0;\r\n}\r\nif (!usbc_hcint.s.chhltd) {\r\nif (usbc_hcchar.s.chena) {\r\nunion cvmx_usbcx_hcintmskx hcintmsk;\r\nhcintmsk.u32 = 0;\r\nhcintmsk.s.chhltdmsk = 1;\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCINTMSKX(channel,\r\nusb->index),\r\nhcintmsk.u32);\r\nusbc_hcchar.s.chdis = 1;\r\ncvmx_usb_write_csr32(usb,\r\nCVMX_USBCX_HCCHARX(channel,\r\nusb->index),\r\nusbc_hcchar.u32);\r\nreturn 0;\r\n} else if (usbc_hcint.s.xfercompl) {\r\n} else {\r\ndev_err(dev, "USB%d: Channel %d interrupt without halt\n",\r\nusb->index, channel);\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\nif (!usbc_hcint.s.chhltd)\r\nreturn 0;\r\n}\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);\r\nusb->idle_hardware_channels |= (1<<channel);\r\npipe = usb->pipe_for_channel[channel];\r\nprefetch(pipe);\r\nif (!pipe)\r\nreturn 0;\r\ntransaction = list_first_entry(&pipe->transactions,\r\ntypeof(*transaction),\r\nnode);\r\nprefetch(transaction);\r\nusb->pipe_for_channel[channel] = NULL;\r\npipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;\r\nusbc_hcchar.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCCHARX(channel, usb->index));\r\nusbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HCTSIZX(channel, usb->index));\r\npackets_processed = transaction->pktcnt - usbc_hctsiz.s.pktcnt;\r\nif (usbc_hcchar.s.epdir) {\r\nbytes_this_transfer = transaction->xfersize -\r\nusbc_hctsiz.s.xfersize;\r\n} else {\r\nbytes_this_transfer = packets_processed * usbc_hcchar.s.mps;\r\nif (bytes_this_transfer > transaction->xfersize)\r\nbytes_this_transfer = transaction->xfersize;\r\n}\r\nif (packets_processed)\r\nbytes_in_last_packet = bytes_this_transfer -\r\n(packets_processed - 1) * usbc_hcchar.s.mps;\r\nelse\r\nbytes_in_last_packet = bytes_this_transfer;\r\nif ((transaction->stage == CVMX_USB_STAGE_SETUP) ||\r\n(transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))\r\nbytes_this_transfer = 0;\r\ntransaction->actual_bytes += bytes_this_transfer;\r\nif (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)\r\nbuffer_space_left = transaction->iso_packets[0].length -\r\ntransaction->actual_bytes;\r\nelse\r\nbuffer_space_left = transaction->buffer_length -\r\ntransaction->actual_bytes;\r\npipe->pid_toggle = !(usbc_hctsiz.s.pid == 0);\r\nif ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&\r\n(pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&\r\n(pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))\r\npipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;\r\nif (unlikely(WARN_ON_ONCE(bytes_this_transfer < 0))) {\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_ERROR);\r\nreturn 0;\r\n}\r\nif (usbc_hcint.s.stall) {\r\npipe->pid_toggle = 0;\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_STALL);\r\n} else if (usbc_hcint.s.xacterr) {\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_XACTERR);\r\n} else if (usbc_hcint.s.bblerr) {\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_BABBLEERR);\r\n} else if (usbc_hcint.s.datatglerr) {\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_DATATGLERR);\r\n} else if (usbc_hcint.s.nyet) {\r\nif (!cvmx_usb_pipe_needs_split(usb, pipe)) {\r\ntransaction->retries = 0;\r\nif ((buffer_space_left == 0) ||\r\n(bytes_in_last_packet < pipe->max_packet))\r\ncvmx_usb_perform_complete(usb, pipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\n} else {\r\ntransaction->retries++;\r\nif ((transaction->retries & 0x3) == 0) {\r\ntransaction->stage &= ~1;\r\npipe->split_sc_frame = -1;\r\n}\r\n}\r\n} else if (usbc_hcint.s.ack) {\r\ntransaction->retries = 0;\r\npipe->flags &= ~CVMX_USB_PIPE_FLAGS_NEED_PING;\r\nswitch (transaction->type) {\r\ncase CVMX_USB_TRANSFER_CONTROL:\r\nswitch (transaction->stage) {\r\ncase CVMX_USB_STAGE_NON_CONTROL:\r\ncase CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:\r\ncvmx_usb_perform_complete(usb, pipe,\r\ntransaction, CVMX_USB_COMPLETE_ERROR);\r\nbreak;\r\ncase CVMX_USB_STAGE_SETUP:\r\npipe->pid_toggle = 1;\r\nif (cvmx_usb_pipe_needs_split(usb, pipe))\r\ntransaction->stage =\r\nCVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;\r\nelse {\r\nstruct usb_ctrlrequest *header =\r\ncvmx_phys_to_ptr(transaction->control_header);\r\nif (header->wLength)\r\ntransaction->stage =\r\nCVMX_USB_STAGE_DATA;\r\nelse\r\ntransaction->stage =\r\nCVMX_USB_STAGE_STATUS;\r\n}\r\nbreak;\r\ncase CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:\r\n{\r\nstruct usb_ctrlrequest *header =\r\ncvmx_phys_to_ptr(transaction->control_header);\r\nif (header->wLength)\r\ntransaction->stage =\r\nCVMX_USB_STAGE_DATA;\r\nelse\r\ntransaction->stage =\r\nCVMX_USB_STAGE_STATUS;\r\n}\r\nbreak;\r\ncase CVMX_USB_STAGE_DATA:\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\ntransaction->stage =\r\nCVMX_USB_STAGE_DATA_SPLIT_COMPLETE;\r\nif (!usbc_hcchar.s.epdir) {\r\nif (buffer_space_left < pipe->max_packet)\r\ntransaction->actual_bytes +=\r\nbuffer_space_left;\r\nelse\r\ntransaction->actual_bytes +=\r\npipe->max_packet;\r\n}\r\n} else if ((buffer_space_left == 0) ||\r\n(bytes_in_last_packet <\r\npipe->max_packet)) {\r\npipe->pid_toggle = 1;\r\ntransaction->stage =\r\nCVMX_USB_STAGE_STATUS;\r\n}\r\nbreak;\r\ncase CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:\r\nif ((buffer_space_left == 0) ||\r\n(bytes_in_last_packet <\r\npipe->max_packet)) {\r\npipe->pid_toggle = 1;\r\ntransaction->stage =\r\nCVMX_USB_STAGE_STATUS;\r\n} else {\r\ntransaction->stage =\r\nCVMX_USB_STAGE_DATA;\r\n}\r\nbreak;\r\ncase CVMX_USB_STAGE_STATUS:\r\nif (cvmx_usb_pipe_needs_split(usb, pipe))\r\ntransaction->stage =\r\nCVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;\r\nelse\r\ncvmx_usb_perform_complete(usb, pipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\nbreak;\r\ncase CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:\r\ncvmx_usb_perform_complete(usb, pipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\nbreak;\r\n}\r\nbreak;\r\ncase CVMX_USB_TRANSFER_BULK:\r\ncase CVMX_USB_TRANSFER_INTERRUPT:\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\nif (transaction->stage ==\r\nCVMX_USB_STAGE_NON_CONTROL)\r\ntransaction->stage =\r\nCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;\r\nelse {\r\nif (buffer_space_left &&\r\n(bytes_in_last_packet ==\r\npipe->max_packet))\r\ntransaction->stage =\r\nCVMX_USB_STAGE_NON_CONTROL;\r\nelse {\r\nif (transaction->type ==\r\nCVMX_USB_TRANSFER_INTERRUPT)\r\npipe->next_tx_frame +=\r\npipe->interval;\r\ncvmx_usb_perform_complete(\r\nusb,\r\npipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\n}\r\n}\r\n} else {\r\nif ((pipe->device_speed ==\r\nCVMX_USB_SPEED_HIGH) &&\r\n(pipe->transfer_type ==\r\nCVMX_USB_TRANSFER_BULK) &&\r\n(pipe->transfer_dir ==\r\nCVMX_USB_DIRECTION_OUT) &&\r\n(usbc_hcint.s.nak))\r\npipe->flags |=\r\nCVMX_USB_PIPE_FLAGS_NEED_PING;\r\nif (!buffer_space_left ||\r\n(bytes_in_last_packet <\r\npipe->max_packet)) {\r\nif (transaction->type ==\r\nCVMX_USB_TRANSFER_INTERRUPT)\r\npipe->next_tx_frame +=\r\npipe->interval;\r\ncvmx_usb_perform_complete(usb, pipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\n}\r\n}\r\nbreak;\r\ncase CVMX_USB_TRANSFER_ISOCHRONOUS:\r\nif (cvmx_usb_pipe_needs_split(usb, pipe)) {\r\nif (pipe->transfer_dir ==\r\nCVMX_USB_DIRECTION_OUT) {\r\nif (!buffer_space_left ||\r\n(bytes_this_transfer < 188)) {\r\npipe->next_tx_frame +=\r\npipe->interval;\r\ncvmx_usb_perform_complete(usb,\r\npipe, transaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\n}\r\n} else {\r\nif (transaction->stage ==\r\nCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {\r\nif ((buffer_space_left == 0) ||\r\n(bytes_in_last_packet <\r\npipe->max_packet)) {\r\npipe->next_tx_frame +=\r\npipe->interval;\r\ncvmx_usb_perform_complete(\r\nusb,\r\npipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\n}\r\n} else\r\ntransaction->stage =\r\nCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;\r\n}\r\n} else {\r\npipe->next_tx_frame += pipe->interval;\r\ncvmx_usb_perform_complete(usb, pipe,\r\ntransaction,\r\nCVMX_USB_COMPLETE_SUCCESS);\r\n}\r\nbreak;\r\n}\r\n} else if (usbc_hcint.s.nak) {\r\nif (usb->active_split == transaction)\r\nusb->active_split = NULL;\r\ntransaction->retries = 0;\r\ntransaction->stage &= ~1;\r\npipe->next_tx_frame += pipe->interval;\r\nif (pipe->next_tx_frame < usb->frame_number)\r\npipe->next_tx_frame = usb->frame_number +\r\npipe->interval -\r\n(usb->frame_number - pipe->next_tx_frame) %\r\npipe->interval;\r\n} else {\r\nstruct cvmx_usb_port_status port;\r\nport = cvmx_usb_get_status(usb);\r\nif (port.port_enabled) {\r\ntransaction->retries++;\r\n} else {\r\ncvmx_usb_perform_complete(usb, pipe, transaction,\r\nCVMX_USB_COMPLETE_ERROR);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void octeon_usb_port_callback(struct cvmx_usb_state *usb)\r\n{\r\nstruct octeon_hcd *priv = cvmx_usb_to_octeon(usb);\r\nspin_unlock(&priv->lock);\r\nusb_hcd_poll_rh_status(octeon_to_hcd(priv));\r\nspin_lock(&priv->lock);\r\n}\r\nstatic int cvmx_usb_poll(struct cvmx_usb_state *usb)\r\n{\r\nunion cvmx_usbcx_hfnum usbc_hfnum;\r\nunion cvmx_usbcx_gintsts usbc_gintsts;\r\nprefetch_range(usb, sizeof(*usb));\r\nusbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));\r\nif ((usb->frame_number&0x3fff) > usbc_hfnum.s.frnum)\r\nusb->frame_number += 0x4000;\r\nusb->frame_number &= ~0x3fffull;\r\nusb->frame_number |= usbc_hfnum.s.frnum;\r\nusbc_gintsts.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_GINTSTS(usb->index));\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),\r\nusbc_gintsts.u32);\r\nif (usbc_gintsts.s.rxflvl) {\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\r\ncvmx_usb_poll_rx_fifo(usb);\r\n}\r\nif (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {\r\nif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\r\ncvmx_usb_poll_tx_fifo(usb);\r\n}\r\nif (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {\r\nunion cvmx_usbcx_hprt usbc_hprt;\r\nocteon_usb_port_callback(usb);\r\nusbc_hprt.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HPRT(usb->index));\r\nusbc_hprt.s.prtena = 0;\r\ncvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),\r\nusbc_hprt.u32);\r\n}\r\nif (usbc_gintsts.s.hchint) {\r\nunion cvmx_usbcx_haint usbc_haint;\r\nusbc_haint.u32 = cvmx_usb_read_csr32(usb,\r\nCVMX_USBCX_HAINT(usb->index));\r\nwhile (usbc_haint.u32) {\r\nint channel;\r\nchannel = __fls(usbc_haint.u32);\r\ncvmx_usb_poll_channel(usb, channel);\r\nusbc_haint.u32 ^= 1<<channel;\r\n}\r\n}\r\ncvmx_usb_schedule(usb, usbc_gintsts.s.sof);\r\nreturn 0;\r\n}\r\nstatic inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)\r\n{\r\nreturn (struct octeon_hcd *)(hcd->hcd_priv);\r\n}\r\nstatic irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)\r\n{\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncvmx_usb_poll(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int octeon_usb_start(struct usb_hcd *hcd)\r\n{\r\nhcd->state = HC_STATE_RUNNING;\r\nreturn 0;\r\n}\r\nstatic void octeon_usb_stop(struct usb_hcd *hcd)\r\n{\r\nhcd->state = HC_STATE_HALT;\r\n}\r\nstatic int octeon_usb_get_frame_number(struct usb_hcd *hcd)\r\n{\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nreturn cvmx_usb_get_frame_number(&priv->usb);\r\n}\r\nstatic int octeon_usb_urb_enqueue(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct cvmx_usb_transaction *transaction = NULL;\r\nstruct cvmx_usb_pipe *pipe;\r\nunsigned long flags;\r\nstruct cvmx_usb_iso_packet *iso_packet;\r\nstruct usb_host_endpoint *ep = urb->ep;\r\nint rc;\r\nurb->status = 0;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrc = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (rc) {\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn rc;\r\n}\r\nif (!ep->hcpriv) {\r\nenum cvmx_usb_transfer transfer_type;\r\nenum cvmx_usb_speed speed;\r\nint split_device = 0;\r\nint split_port = 0;\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_ISOCHRONOUS:\r\ntransfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\ntransfer_type = CVMX_USB_TRANSFER_INTERRUPT;\r\nbreak;\r\ncase PIPE_CONTROL:\r\ntransfer_type = CVMX_USB_TRANSFER_CONTROL;\r\nbreak;\r\ndefault:\r\ntransfer_type = CVMX_USB_TRANSFER_BULK;\r\nbreak;\r\n}\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\nspeed = CVMX_USB_SPEED_LOW;\r\nbreak;\r\ncase USB_SPEED_FULL:\r\nspeed = CVMX_USB_SPEED_FULL;\r\nbreak;\r\ndefault:\r\nspeed = CVMX_USB_SPEED_HIGH;\r\nbreak;\r\n}\r\nif (speed != CVMX_USB_SPEED_HIGH) {\r\nstruct usb_device *dev = urb->dev;\r\nwhile (dev->parent) {\r\nif (dev->parent->speed == USB_SPEED_HIGH) {\r\nsplit_device = dev->parent->devnum;\r\nsplit_port = dev->portnum;\r\nbreak;\r\n}\r\ndev = dev->parent;\r\n}\r\n}\r\npipe = cvmx_usb_open_pipe(&priv->usb, usb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe), speed,\r\nle16_to_cpu(ep->desc.wMaxPacketSize)\r\n& 0x7ff,\r\ntransfer_type,\r\nusb_pipein(urb->pipe) ?\r\nCVMX_USB_DIRECTION_IN :\r\nCVMX_USB_DIRECTION_OUT,\r\nurb->interval,\r\n(le16_to_cpu(ep->desc.wMaxPacketSize)\r\n>> 11) & 0x3,\r\nsplit_device, split_port);\r\nif (!pipe) {\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(dev, "Failed to create pipe\n");\r\nreturn -ENOMEM;\r\n}\r\nep->hcpriv = pipe;\r\n} else {\r\npipe = ep->hcpriv;\r\n}\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_ISOCHRONOUS:\r\ndev_dbg(dev, "Submit isochronous to %d.%d\n",\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe));\r\niso_packet = kmalloc(urb->number_of_packets *\r\nsizeof(struct cvmx_usb_iso_packet),\r\nGFP_ATOMIC);\r\nif (iso_packet) {\r\nint i;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\niso_packet[i].offset =\r\nurb->iso_frame_desc[i].offset;\r\niso_packet[i].length =\r\nurb->iso_frame_desc[i].length;\r\niso_packet[i].status =\r\nCVMX_USB_COMPLETE_ERROR;\r\n}\r\nurb->setup_packet = (char *)iso_packet;\r\ntransaction = cvmx_usb_submit_isochronous(&priv->usb,\r\npipe, urb);\r\nif (!transaction) {\r\nurb->setup_packet = NULL;\r\nkfree(iso_packet);\r\n}\r\n}\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\ndev_dbg(dev, "Submit interrupt to %d.%d\n",\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe));\r\ntransaction = cvmx_usb_submit_interrupt(&priv->usb, pipe, urb);\r\nbreak;\r\ncase PIPE_CONTROL:\r\ndev_dbg(dev, "Submit control to %d.%d\n",\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe));\r\ntransaction = cvmx_usb_submit_control(&priv->usb, pipe, urb);\r\nbreak;\r\ncase PIPE_BULK:\r\ndev_dbg(dev, "Submit bulk to %d.%d\n",\r\nusb_pipedevice(urb->pipe),\r\nusb_pipeendpoint(urb->pipe));\r\ntransaction = cvmx_usb_submit_bulk(&priv->usb, pipe, urb);\r\nbreak;\r\n}\r\nif (!transaction) {\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\ndev_dbg(dev, "Failed to submit\n");\r\nreturn -ENOMEM;\r\n}\r\nurb->hcpriv = transaction;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int octeon_usb_urb_dequeue(struct usb_hcd *hcd,\r\nstruct urb *urb,\r\nint status)\r\n{\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nunsigned long flags;\r\nint rc;\r\nif (!urb->dev)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto out;\r\nurb->status = status;\r\ncvmx_usb_cancel(&priv->usb, urb->ep->hcpriv, urb->hcpriv);\r\nout:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void octeon_usb_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nif (ep->hcpriv) {\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nstruct cvmx_usb_pipe *pipe = ep->hcpriv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncvmx_usb_cancel_all(&priv->usb, pipe);\r\nif (cvmx_usb_close_pipe(&priv->usb, pipe))\r\ndev_dbg(dev, "Closing pipe %p failed\n", pipe);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nep->hcpriv = NULL;\r\n}\r\n}\r\nstatic int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nstruct cvmx_usb_port_status port_status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nport_status = cvmx_usb_get_status(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbuf[0] = 0;\r\nbuf[0] = port_status.connect_change << 1;\r\nreturn buf[0] != 0;\r\n}\r\nstatic int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nstruct device *dev = hcd->self.controller;\r\nstruct cvmx_usb_port_status usb_port_status;\r\nstruct cvmx_usb_state *usb = &priv->usb;\r\nint port_status;\r\nstruct usb_hub_descriptor *desc;\r\nunsigned long flags;\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\ndev_dbg(dev, "ClearHubFeature\n");\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\ndev_dbg(dev, "ClearPortFeature\n");\r\nif (wIndex != 1) {\r\ndev_dbg(dev, " INVALID\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\ndev_dbg(dev, " ENABLE\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncvmx_usb_disable(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\ndev_dbg(dev, " SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(dev, " POWER\n");\r\nbreak;\r\ncase USB_PORT_FEAT_INDICATOR:\r\ndev_dbg(dev, " INDICATOR\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ndev_dbg(dev, " C_CONNECTION\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->usb.port_status =\r\ncvmx_usb_get_status(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\ndev_dbg(dev, " C_RESET\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->usb.port_status =\r\ncvmx_usb_get_status(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ndev_dbg(dev, " C_ENABLE\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->usb.port_status =\r\ncvmx_usb_get_status(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ndev_dbg(dev, " C_SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ndev_dbg(dev, " C_OVER_CURRENT\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\npriv->usb.port_status =\r\ncvmx_usb_get_status(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, " UNKNOWN\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase GetHubDescriptor:\r\ndev_dbg(dev, "GetHubDescriptor\n");\r\ndesc = (struct usb_hub_descriptor *)buf;\r\ndesc->bDescLength = 9;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bNbrPorts = 1;\r\ndesc->wHubCharacteristics = cpu_to_le16(0x08);\r\ndesc->bPwrOn2PwrGood = 1;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->u.hs.DeviceRemovable[0] = 0;\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\nbreak;\r\ncase GetHubStatus:\r\ndev_dbg(dev, "GetHubStatus\n");\r\n*(__le32 *) buf = 0;\r\nbreak;\r\ncase GetPortStatus:\r\ndev_dbg(dev, "GetPortStatus\n");\r\nif (wIndex != 1) {\r\ndev_dbg(dev, " INVALID\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&priv->lock, flags);\r\nusb_port_status = cvmx_usb_get_status(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nport_status = 0;\r\nif (usb_port_status.connect_change) {\r\nport_status |= (1 << USB_PORT_FEAT_C_CONNECTION);\r\ndev_dbg(dev, " C_CONNECTION\n");\r\n}\r\nif (usb_port_status.port_enabled) {\r\nport_status |= (1 << USB_PORT_FEAT_C_ENABLE);\r\ndev_dbg(dev, " C_ENABLE\n");\r\n}\r\nif (usb_port_status.connected) {\r\nport_status |= (1 << USB_PORT_FEAT_CONNECTION);\r\ndev_dbg(dev, " CONNECTION\n");\r\n}\r\nif (usb_port_status.port_enabled) {\r\nport_status |= (1 << USB_PORT_FEAT_ENABLE);\r\ndev_dbg(dev, " ENABLE\n");\r\n}\r\nif (usb_port_status.port_over_current) {\r\nport_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);\r\ndev_dbg(dev, " OVER_CURRENT\n");\r\n}\r\nif (usb_port_status.port_powered) {\r\nport_status |= (1 << USB_PORT_FEAT_POWER);\r\ndev_dbg(dev, " POWER\n");\r\n}\r\nif (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {\r\nport_status |= USB_PORT_STAT_HIGH_SPEED;\r\ndev_dbg(dev, " HIGHSPEED\n");\r\n} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {\r\nport_status |= (1 << USB_PORT_FEAT_LOWSPEED);\r\ndev_dbg(dev, " LOWSPEED\n");\r\n}\r\n*((__le32 *) buf) = cpu_to_le32(port_status);\r\nbreak;\r\ncase SetHubFeature:\r\ndev_dbg(dev, "SetHubFeature\n");\r\nbreak;\r\ncase SetPortFeature:\r\ndev_dbg(dev, "SetPortFeature\n");\r\nif (wIndex != 1) {\r\ndev_dbg(dev, " INVALID\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\ndev_dbg(dev, " SUSPEND\n");\r\nreturn -EINVAL;\r\ncase USB_PORT_FEAT_POWER:\r\ndev_dbg(dev, " POWER\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\nUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),\r\ncvmx_usbcx_hprt, prtpwr, 1);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\ncase USB_PORT_FEAT_RESET:\r\ndev_dbg(dev, " RESET\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\ncvmx_usb_reset_port(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\ncase USB_PORT_FEAT_INDICATOR:\r\ndev_dbg(dev, " INDICATOR\n");\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, " UNKNOWN\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown root hub request\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int octeon_usb_probe(struct platform_device *pdev)\r\n{\r\nint status;\r\nint initialize_flags;\r\nint usb_num;\r\nstruct resource *res_mem;\r\nstruct device_node *usbn_node;\r\nint irq = platform_get_irq(pdev, 0);\r\nstruct device *dev = &pdev->dev;\r\nstruct octeon_hcd *priv;\r\nstruct usb_hcd *hcd;\r\nu32 clock_rate = 48000000;\r\nbool is_crystal_clock = false;\r\nconst char *clock_type;\r\nint i;\r\nif (dev->of_node == NULL) {\r\ndev_err(dev, "Error: empty of_node\n");\r\nreturn -ENXIO;\r\n}\r\nusbn_node = dev->of_node->parent;\r\ni = of_property_read_u32(usbn_node,\r\n"refclk-frequency", &clock_rate);\r\nif (i) {\r\ndev_err(dev, "No USBN \"refclk-frequency\"\n");\r\nreturn -ENXIO;\r\n}\r\nswitch (clock_rate) {\r\ncase 12000000:\r\ninitialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;\r\nbreak;\r\ncase 24000000:\r\ninitialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;\r\nbreak;\r\ncase 48000000:\r\ninitialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Illebal USBN \"refclk-frequency\" %u\n",\r\nclock_rate);\r\nreturn -ENXIO;\r\n}\r\ni = of_property_read_string(usbn_node,\r\n"refclk-type", &clock_type);\r\nif (!i && strcmp("crystal", clock_type) == 0)\r\nis_crystal_clock = true;\r\nif (is_crystal_clock)\r\ninitialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;\r\nelse\r\ninitialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem == NULL) {\r\ndev_err(dev, "found no memory resource\n");\r\nreturn -ENXIO;\r\n}\r\nusb_num = (res_mem->start >> 44) & 1;\r\nif (irq < 0) {\r\nirq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;\r\nirq = irq_create_mapping(NULL, hwirq);\r\n}\r\ndev->coherent_dma_mask = ~0;\r\ndev->dma_mask = &dev->coherent_dma_mask;\r\nif (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {\r\nunion cvmx_iob_n2c_l2c_pri_cnt pri_cnt;\r\npri_cnt.u64 = 0;\r\npri_cnt.s.cnt_enb = 1;\r\npri_cnt.s.cnt_val = 400;\r\ncvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);\r\n}\r\nhcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));\r\nif (!hcd) {\r\ndev_dbg(dev, "Failed to allocate memory for HCD\n");\r\nreturn -1;\r\n}\r\nhcd->uses_new_polling = 1;\r\npriv = (struct octeon_hcd *)hcd->hcd_priv;\r\nspin_lock_init(&priv->lock);\r\npriv->usb.init_flags = initialize_flags;\r\npriv->usb.index = usb_num;\r\nINIT_LIST_HEAD(&priv->usb.idle_pipes);\r\nfor (i = 0; i < ARRAY_SIZE(priv->usb.active_pipes); i++)\r\nINIT_LIST_HEAD(&priv->usb.active_pipes[i]);\r\nif (OCTEON_IS_MODEL(OCTEON_CN31XX)) {\r\npriv->usb.init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;\r\npriv->usb.idle_hardware_channels = 0x1;\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN5XXX)) {\r\npriv->usb.idle_hardware_channels = 0xf7;\r\n} else {\r\npriv->usb.idle_hardware_channels = 0xff;\r\n}\r\nstatus = cvmx_usb_initialize(dev, &priv->usb);\r\nif (status) {\r\ndev_dbg(dev, "USB initialization failed with %d\n", status);\r\nkfree(hcd);\r\nreturn -1;\r\n}\r\nstatus = usb_add_hcd(hcd, irq, 0);\r\nif (status) {\r\ndev_dbg(dev, "USB add HCD failed with %d\n", status);\r\nkfree(hcd);\r\nreturn -1;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\ndev_info(dev, "Registered HCD for port %d on irq %d\n", usb_num, irq);\r\nreturn 0;\r\n}\r\nstatic int octeon_usb_remove(struct platform_device *pdev)\r\n{\r\nint status;\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nstruct octeon_hcd *priv = hcd_to_octeon(hcd);\r\nunsigned long flags;\r\nusb_remove_hcd(hcd);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nstatus = cvmx_usb_shutdown(&priv->usb);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nif (status)\r\ndev_dbg(dev, "USB shutdown failed with %d\n", status);\r\nkfree(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init octeon_usb_driver_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn 0;\r\nreturn platform_driver_register(&octeon_usb_driver);\r\n}\r\nstatic void __exit octeon_usb_driver_exit(void)\r\n{\r\nif (usb_disabled())\r\nreturn;\r\nplatform_driver_unregister(&octeon_usb_driver);\r\n}
