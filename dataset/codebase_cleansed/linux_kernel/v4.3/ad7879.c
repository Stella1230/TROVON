static int ad7879_read(struct ad7879 *ts, u8 reg)\r\n{\r\nreturn ts->bops->read(ts->dev, reg);\r\n}\r\nstatic int ad7879_multi_read(struct ad7879 *ts, u8 first_reg, u8 count, u16 *buf)\r\n{\r\nreturn ts->bops->multi_read(ts->dev, first_reg, count, buf);\r\n}\r\nstatic int ad7879_write(struct ad7879 *ts, u8 reg, u16 val)\r\n{\r\nreturn ts->bops->write(ts->dev, reg, val);\r\n}\r\nstatic int ad7879_report(struct ad7879 *ts)\r\n{\r\nstruct input_dev *input_dev = ts->input;\r\nunsigned Rt;\r\nu16 x, y, z1, z2;\r\nx = ts->conversion_data[AD7879_SEQ_XPOS] & MAX_12BIT;\r\ny = ts->conversion_data[AD7879_SEQ_YPOS] & MAX_12BIT;\r\nz1 = ts->conversion_data[AD7879_SEQ_Z1] & MAX_12BIT;\r\nz2 = ts->conversion_data[AD7879_SEQ_Z2] & MAX_12BIT;\r\nif (ts->swap_xy)\r\nswap(x, y);\r\nif (likely(x && z1)) {\r\nRt = (z2 - z1) * x * ts->x_plate_ohms;\r\nRt /= z1;\r\nRt = (Rt + 2047) >> 12;\r\nif (Rt > ts->pressure_max)\r\nreturn -EINVAL;\r\nif (timer_pending(&ts->timer)) {\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\ninput_report_abs(input_dev, ABS_X, ts->x);\r\ninput_report_abs(input_dev, ABS_Y, ts->y);\r\ninput_report_abs(input_dev, ABS_PRESSURE, ts->Rt);\r\ninput_sync(input_dev);\r\n}\r\nts->x = x;\r\nts->y = y;\r\nts->Rt = Rt;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ad7879_ts_event_release(struct ad7879 *ts)\r\n{\r\nstruct input_dev *input_dev = ts->input;\r\ninput_report_abs(input_dev, ABS_PRESSURE, 0);\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\ninput_sync(input_dev);\r\n}\r\nstatic void ad7879_timer(unsigned long handle)\r\n{\r\nstruct ad7879 *ts = (void *)handle;\r\nad7879_ts_event_release(ts);\r\n}\r\nstatic irqreturn_t ad7879_irq(int irq, void *handle)\r\n{\r\nstruct ad7879 *ts = handle;\r\nad7879_multi_read(ts, AD7879_REG_XPLUS, AD7879_NR_SENSE, ts->conversion_data);\r\nif (!ad7879_report(ts))\r\nmod_timer(&ts->timer, jiffies + TS_PEN_UP_TIMEOUT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __ad7879_enable(struct ad7879 *ts)\r\n{\r\nad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nad7879_write(ts, AD7879_REG_CTRL3, ts->cmd_crtl3);\r\nad7879_write(ts, AD7879_REG_CTRL1, ts->cmd_crtl1);\r\nenable_irq(ts->irq);\r\n}\r\nstatic void __ad7879_disable(struct ad7879 *ts)\r\n{\r\nu16 reg = (ts->cmd_crtl2 & ~AD7879_PM(-1)) |\r\nAD7879_PM(AD7879_PM_SHUTDOWN);\r\ndisable_irq(ts->irq);\r\nif (del_timer_sync(&ts->timer))\r\nad7879_ts_event_release(ts);\r\nad7879_write(ts, AD7879_REG_CTRL2, reg);\r\n}\r\nstatic int ad7879_open(struct input_dev *input)\r\n{\r\nstruct ad7879 *ts = input_get_drvdata(input);\r\nif (!ts->disabled && !ts->suspended)\r\n__ad7879_enable(ts);\r\nreturn 0;\r\n}\r\nstatic void ad7879_close(struct input_dev* input)\r\n{\r\nstruct ad7879 *ts = input_get_drvdata(input);\r\nif (!ts->disabled && !ts->suspended)\r\n__ad7879_disable(ts);\r\n}\r\nstatic int __maybe_unused ad7879_suspend(struct device *dev)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->input->mutex);\r\nif (!ts->suspended && !ts->disabled && ts->input->users)\r\n__ad7879_disable(ts);\r\nts->suspended = true;\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ad7879_resume(struct device *dev)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->input->mutex);\r\nif (ts->suspended && !ts->disabled && ts->input->users)\r\n__ad7879_enable(ts);\r\nts->suspended = false;\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic void ad7879_toggle(struct ad7879 *ts, bool disable)\r\n{\r\nmutex_lock(&ts->input->mutex);\r\nif (!ts->suspended && ts->input->users != 0) {\r\nif (disable) {\r\nif (ts->disabled)\r\n__ad7879_enable(ts);\r\n} else {\r\nif (!ts->disabled)\r\n__ad7879_disable(ts);\r\n}\r\n}\r\nts->disabled = disable;\r\nmutex_unlock(&ts->input->mutex);\r\n}\r\nstatic ssize_t ad7879_disable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", ts->disabled);\r\n}\r\nstatic ssize_t ad7879_disable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ad7879 *ts = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 10, &val);\r\nif (error)\r\nreturn error;\r\nad7879_toggle(ts, val);\r\nreturn count;\r\n}\r\nstatic int ad7879_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned gpio)\r\n{\r\nstruct ad7879 *ts = container_of(chip, struct ad7879, gc);\r\nint err;\r\nmutex_lock(&ts->mutex);\r\nts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIODIR | AD7879_GPIOPOL;\r\nerr = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nmutex_unlock(&ts->mutex);\r\nreturn err;\r\n}\r\nstatic int ad7879_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned gpio, int level)\r\n{\r\nstruct ad7879 *ts = container_of(chip, struct ad7879, gc);\r\nint err;\r\nmutex_lock(&ts->mutex);\r\nts->cmd_crtl2 &= ~AD7879_GPIODIR;\r\nts->cmd_crtl2 |= AD7879_GPIO_EN | AD7879_GPIOPOL;\r\nif (level)\r\nts->cmd_crtl2 |= AD7879_GPIO_DATA;\r\nelse\r\nts->cmd_crtl2 &= ~AD7879_GPIO_DATA;\r\nerr = ad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nmutex_unlock(&ts->mutex);\r\nreturn err;\r\n}\r\nstatic int ad7879_gpio_get_value(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct ad7879 *ts = container_of(chip, struct ad7879, gc);\r\nu16 val;\r\nmutex_lock(&ts->mutex);\r\nval = ad7879_read(ts, AD7879_REG_CTRL2);\r\nmutex_unlock(&ts->mutex);\r\nreturn !!(val & AD7879_GPIO_DATA);\r\n}\r\nstatic void ad7879_gpio_set_value(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct ad7879 *ts = container_of(chip, struct ad7879, gc);\r\nmutex_lock(&ts->mutex);\r\nif (value)\r\nts->cmd_crtl2 |= AD7879_GPIO_DATA;\r\nelse\r\nts->cmd_crtl2 &= ~AD7879_GPIO_DATA;\r\nad7879_write(ts, AD7879_REG_CTRL2, ts->cmd_crtl2);\r\nmutex_unlock(&ts->mutex);\r\n}\r\nstatic int ad7879_gpio_add(struct ad7879 *ts,\r\nconst struct ad7879_platform_data *pdata)\r\n{\r\nint ret = 0;\r\nmutex_init(&ts->mutex);\r\nif (pdata->gpio_export) {\r\nts->gc.direction_input = ad7879_gpio_direction_input;\r\nts->gc.direction_output = ad7879_gpio_direction_output;\r\nts->gc.get = ad7879_gpio_get_value;\r\nts->gc.set = ad7879_gpio_set_value;\r\nts->gc.can_sleep = 1;\r\nts->gc.base = pdata->gpio_base;\r\nts->gc.ngpio = 1;\r\nts->gc.label = "AD7879-GPIO";\r\nts->gc.owner = THIS_MODULE;\r\nts->gc.dev = ts->dev;\r\nret = gpiochip_add(&ts->gc);\r\nif (ret)\r\ndev_err(ts->dev, "failed to register gpio %d\n",\r\nts->gc.base);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ad7879_gpio_remove(struct ad7879 *ts)\r\n{\r\nconst struct ad7879_platform_data *pdata = dev_get_platdata(ts->dev);\r\nif (pdata->gpio_export)\r\ngpiochip_remove(&ts->gc);\r\n}\r\nstatic inline int ad7879_gpio_add(struct ad7879 *ts,\r\nconst struct ad7879_platform_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ad7879_gpio_remove(struct ad7879 *ts)\r\n{\r\n}\r\nstruct ad7879 *ad7879_probe(struct device *dev, u8 devid, unsigned int irq,\r\nconst struct ad7879_bus_ops *bops)\r\n{\r\nstruct ad7879_platform_data *pdata = dev_get_platdata(dev);\r\nstruct ad7879 *ts;\r\nstruct input_dev *input_dev;\r\nint err;\r\nu16 revid;\r\nif (!irq) {\r\ndev_err(dev, "no IRQ?\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (!pdata) {\r\ndev_err(dev, "no platform data?\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nts = kzalloc(sizeof(*ts), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts->bops = bops;\r\nts->dev = dev;\r\nts->input = input_dev;\r\nts->irq = irq;\r\nts->swap_xy = pdata->swap_xy;\r\nsetup_timer(&ts->timer, ad7879_timer, (unsigned long) ts);\r\nts->x_plate_ohms = pdata->x_plate_ohms ? : 400;\r\nts->pressure_max = pdata->pressure_max ? : ~0;\r\nts->first_conversion_delay = pdata->first_conversion_delay;\r\nts->acquisition_time = pdata->acquisition_time;\r\nts->averaging = pdata->averaging;\r\nts->pen_down_acc_interval = pdata->pen_down_acc_interval;\r\nts->median = pdata->median;\r\nsnprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));\r\ninput_dev->name = "AD7879 Touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->dev.parent = dev;\r\ninput_dev->id.bustype = bops->bustype;\r\ninput_dev->open = ad7879_open;\r\ninput_dev->close = ad7879_close;\r\ninput_set_drvdata(input_dev, ts);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(ABS_X, input_dev->absbit);\r\n__set_bit(ABS_Y, input_dev->absbit);\r\n__set_bit(ABS_PRESSURE, input_dev->absbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\ninput_set_abs_params(input_dev, ABS_X,\r\npdata->x_min ? : 0,\r\npdata->x_max ? : MAX_12BIT,\r\n0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\npdata->y_min ? : 0,\r\npdata->y_max ? : MAX_12BIT,\r\n0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE,\r\npdata->pressure_min, pdata->pressure_max, 0, 0);\r\nerr = ad7879_write(ts, AD7879_REG_CTRL2, AD7879_RESET);\r\nif (err < 0) {\r\ndev_err(dev, "Failed to write %s\n", input_dev->name);\r\ngoto err_free_mem;\r\n}\r\nrevid = ad7879_read(ts, AD7879_REG_REVID);\r\ninput_dev->id.product = (revid & 0xff);\r\ninput_dev->id.version = revid >> 8;\r\nif (input_dev->id.product != devid) {\r\ndev_err(dev, "Failed to probe %s (%x vs %x)\n",\r\ninput_dev->name, devid, revid);\r\nerr = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nts->cmd_crtl3 = AD7879_YPLUS_BIT |\r\nAD7879_XPLUS_BIT |\r\nAD7879_Z2_BIT |\r\nAD7879_Z1_BIT |\r\nAD7879_TEMPMASK_BIT |\r\nAD7879_AUXVBATMASK_BIT |\r\nAD7879_GPIOALERTMASK_BIT;\r\nts->cmd_crtl2 = AD7879_PM(AD7879_PM_DYN) | AD7879_DFR |\r\nAD7879_AVG(ts->averaging) |\r\nAD7879_MFS(ts->median) |\r\nAD7879_FCD(ts->first_conversion_delay);\r\nts->cmd_crtl1 = AD7879_MODE_INT | AD7879_MODE_SEQ1 |\r\nAD7879_ACQ(ts->acquisition_time) |\r\nAD7879_TMR(ts->pen_down_acc_interval);\r\nerr = request_threaded_irq(ts->irq, NULL, ad7879_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(dev), ts);\r\nif (err) {\r\ndev_err(dev, "irq %d busy?\n", ts->irq);\r\ngoto err_free_mem;\r\n}\r\n__ad7879_disable(ts);\r\nerr = sysfs_create_group(&dev->kobj, &ad7879_attr_group);\r\nif (err)\r\ngoto err_free_irq;\r\nerr = ad7879_gpio_add(ts, pdata);\r\nif (err)\r\ngoto err_remove_attr;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_remove_gpio;\r\nreturn ts;\r\nerr_remove_gpio:\r\nad7879_gpio_remove(ts);\r\nerr_remove_attr:\r\nsysfs_remove_group(&dev->kobj, &ad7879_attr_group);\r\nerr_free_irq:\r\nfree_irq(ts->irq, ts);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ad7879_remove(struct ad7879 *ts)\r\n{\r\nad7879_gpio_remove(ts);\r\nsysfs_remove_group(&ts->dev->kobj, &ad7879_attr_group);\r\nfree_irq(ts->irq, ts);\r\ninput_unregister_device(ts->input);\r\nkfree(ts);\r\n}
