int cpu_has_xfeatures(u64 xfeatures_needed, const char **feature_name)\r\n{\r\nu64 xfeatures_missing = xfeatures_needed & ~xfeatures_mask;\r\nif (unlikely(feature_name)) {\r\nlong xfeature_idx, max_idx;\r\nu64 xfeatures_print;\r\nif (xfeatures_missing)\r\nxfeatures_print = xfeatures_missing;\r\nelse\r\nxfeatures_print = xfeatures_needed;\r\nxfeature_idx = fls64(xfeatures_print)-1;\r\nmax_idx = ARRAY_SIZE(xfeature_names)-1;\r\nxfeature_idx = min(xfeature_idx, max_idx);\r\n*feature_name = xfeature_names[xfeature_idx];\r\n}\r\nif (xfeatures_missing)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid fpstate_sanitize_xstate(struct fpu *fpu)\r\n{\r\nstruct fxregs_state *fx = &fpu->state.fxsave;\r\nint feature_bit;\r\nu64 xfeatures;\r\nif (!use_xsaveopt())\r\nreturn;\r\nxfeatures = fpu->state.xsave.header.xfeatures;\r\nif ((xfeatures & xfeatures_mask) == xfeatures_mask)\r\nreturn;\r\nif (!(xfeatures & XSTATE_FP)) {\r\nfx->cwd = 0x37f;\r\nfx->swd = 0;\r\nfx->twd = 0;\r\nfx->fop = 0;\r\nfx->rip = 0;\r\nfx->rdp = 0;\r\nmemset(&fx->st_space[0], 0, 128);\r\n}\r\nif (!(xfeatures & XSTATE_SSE))\r\nmemset(&fx->xmm_space[0], 0, 256);\r\nfeature_bit = 0x2;\r\nxfeatures = (xfeatures_mask & ~xfeatures) >> 2;\r\nwhile (xfeatures) {\r\nif (xfeatures & 0x1) {\r\nint offset = xstate_offsets[feature_bit];\r\nint size = xstate_sizes[feature_bit];\r\nmemcpy((void *)fx + offset,\r\n(void *)&init_fpstate.xsave + offset,\r\nsize);\r\n}\r\nxfeatures >>= 1;\r\nfeature_bit++;\r\n}\r\n}\r\nvoid fpu__init_cpu_xstate(void)\r\n{\r\nif (!cpu_has_xsave || !xfeatures_mask)\r\nreturn;\r\ncr4_set_bits(X86_CR4_OSXSAVE);\r\nxsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);\r\n}\r\nstatic void __init setup_xstate_features(void)\r\n{\r\nu32 eax, ebx, ecx, edx, leaf;\r\nxfeatures_nr = fls64(xfeatures_mask);\r\nfor (leaf = 2; leaf < xfeatures_nr; leaf++) {\r\ncpuid_count(XSTATE_CPUID, leaf, &eax, &ebx, &ecx, &edx);\r\nxstate_offsets[leaf] = ebx;\r\nxstate_sizes[leaf] = eax;\r\nprintk(KERN_INFO "x86/fpu: xstate_offset[%d]: %04x, xstate_sizes[%d]: %04x\n", leaf, ebx, leaf, eax);\r\n}\r\n}\r\nstatic void __init print_xstate_feature(u64 xstate_mask)\r\n{\r\nconst char *feature_name;\r\nif (cpu_has_xfeatures(xstate_mask, &feature_name))\r\npr_info("x86/fpu: Supporting XSAVE feature 0x%02Lx: '%s'\n", xstate_mask, feature_name);\r\n}\r\nstatic void __init print_xstate_features(void)\r\n{\r\nprint_xstate_feature(XSTATE_FP);\r\nprint_xstate_feature(XSTATE_SSE);\r\nprint_xstate_feature(XSTATE_YMM);\r\nprint_xstate_feature(XSTATE_BNDREGS);\r\nprint_xstate_feature(XSTATE_BNDCSR);\r\nprint_xstate_feature(XSTATE_OPMASK);\r\nprint_xstate_feature(XSTATE_ZMM_Hi256);\r\nprint_xstate_feature(XSTATE_Hi16_ZMM);\r\n}\r\nstatic void __init setup_xstate_comp(void)\r\n{\r\nunsigned int xstate_comp_sizes[sizeof(xfeatures_mask)*8];\r\nint i;\r\nxstate_comp_offsets[0] = 0;\r\nxstate_comp_offsets[1] = offsetof(struct fxregs_state, xmm_space);\r\nif (!cpu_has_xsaves) {\r\nfor (i = 2; i < xfeatures_nr; i++) {\r\nif (test_bit(i, (unsigned long *)&xfeatures_mask)) {\r\nxstate_comp_offsets[i] = xstate_offsets[i];\r\nxstate_comp_sizes[i] = xstate_sizes[i];\r\n}\r\n}\r\nreturn;\r\n}\r\nxstate_comp_offsets[2] = FXSAVE_SIZE + XSAVE_HDR_SIZE;\r\nfor (i = 2; i < xfeatures_nr; i++) {\r\nif (test_bit(i, (unsigned long *)&xfeatures_mask))\r\nxstate_comp_sizes[i] = xstate_sizes[i];\r\nelse\r\nxstate_comp_sizes[i] = 0;\r\nif (i > 2)\r\nxstate_comp_offsets[i] = xstate_comp_offsets[i-1]\r\n+ xstate_comp_sizes[i-1];\r\n}\r\n}\r\nstatic void __init setup_init_fpu_buf(void)\r\n{\r\nstatic int on_boot_cpu = 1;\r\nWARN_ON_FPU(!on_boot_cpu);\r\non_boot_cpu = 0;\r\nif (!cpu_has_xsave)\r\nreturn;\r\nsetup_xstate_features();\r\nprint_xstate_features();\r\nif (cpu_has_xsaves) {\r\ninit_fpstate.xsave.header.xcomp_bv = (u64)1 << 63 | xfeatures_mask;\r\ninit_fpstate.xsave.header.xfeatures = xfeatures_mask;\r\n}\r\ncopy_kernel_to_xregs_booting(&init_fpstate.xsave);\r\ncopy_xregs_to_kernel_booting(&init_fpstate.xsave);\r\n}\r\nstatic void __init init_xstate_size(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nint i;\r\nif (!cpu_has_xsaves) {\r\ncpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);\r\nxstate_size = ebx;\r\nreturn;\r\n}\r\nxstate_size = FXSAVE_SIZE + XSAVE_HDR_SIZE;\r\nfor (i = 2; i < 64; i++) {\r\nif (test_bit(i, (unsigned long *)&xfeatures_mask)) {\r\ncpuid_count(XSTATE_CPUID, i, &eax, &ebx, &ecx, &edx);\r\nxstate_size += eax;\r\n}\r\n}\r\n}\r\nvoid __init fpu__init_system_xstate(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nstatic int on_boot_cpu = 1;\r\nWARN_ON_FPU(!on_boot_cpu);\r\non_boot_cpu = 0;\r\nif (!cpu_has_xsave) {\r\npr_info("x86/fpu: Legacy x87 FPU detected.\n");\r\nreturn;\r\n}\r\nif (boot_cpu_data.cpuid_level < XSTATE_CPUID) {\r\nWARN_ON_FPU(1);\r\nreturn;\r\n}\r\ncpuid_count(XSTATE_CPUID, 0, &eax, &ebx, &ecx, &edx);\r\nxfeatures_mask = eax + ((u64)edx << 32);\r\nif ((xfeatures_mask & XSTATE_FPSSE) != XSTATE_FPSSE) {\r\npr_err("x86/fpu: FP/SSE not present amongst the CPU's xstate features: 0x%llx.\n", xfeatures_mask);\r\nBUG();\r\n}\r\nxfeatures_mask = xfeatures_mask & XCNTXT_MASK;\r\nfpu__init_cpu_xstate();\r\ninit_xstate_size();\r\nupdate_regset_xstate_info(xstate_size, xfeatures_mask);\r\nfpu__init_prepare_fx_sw_frame();\r\nsetup_init_fpu_buf();\r\nsetup_xstate_comp();\r\npr_info("x86/fpu: Enabled xstate features 0x%llx, context size is 0x%x bytes, using '%s' format.\n",\r\nxfeatures_mask,\r\nxstate_size,\r\ncpu_has_xsaves ? "compacted" : "standard");\r\n}\r\nvoid fpu__resume_cpu(void)\r\n{\r\nif (cpu_has_xsave)\r\nxsetbv(XCR_XFEATURE_ENABLED_MASK, xfeatures_mask);\r\n}\r\nvoid *get_xsave_addr(struct xregs_state *xsave, int xstate_feature)\r\n{\r\nint feature_nr = fls64(xstate_feature) - 1;\r\nif (!boot_cpu_has(X86_FEATURE_XSAVE))\r\nreturn NULL;\r\nxsave = &current->thread.fpu.state.xsave;\r\nWARN_ONCE(!(xfeatures_mask & xstate_feature),\r\n"get of unsupported state");\r\nif (!(xsave->header.xfeatures & xstate_feature))\r\nreturn NULL;\r\nreturn (void *)xsave + xstate_comp_offsets[feature_nr];\r\n}\r\nconst void *get_xsave_field_ptr(int xsave_state)\r\n{\r\nstruct fpu *fpu = &current->thread.fpu;\r\nif (!fpu->fpstate_active)\r\nreturn NULL;\r\nfpu__save(fpu);\r\nreturn get_xsave_addr(&fpu->state.xsave, xsave_state);\r\n}
