static inline struct adnp *to_adnp(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct adnp, gpio);\r\n}\r\nstatic int adnp_read(struct adnp *adnp, unsigned offset, uint8_t *value)\r\n{\r\nint err;\r\nerr = i2c_smbus_read_byte_data(adnp->client, offset);\r\nif (err < 0) {\r\ndev_err(adnp->gpio.dev, "%s failed: %d\n",\r\n"i2c_smbus_read_byte_data()", err);\r\nreturn err;\r\n}\r\n*value = err;\r\nreturn 0;\r\n}\r\nstatic int adnp_write(struct adnp *adnp, unsigned offset, uint8_t value)\r\n{\r\nint err;\r\nerr = i2c_smbus_write_byte_data(adnp->client, offset, value);\r\nif (err < 0) {\r\ndev_err(adnp->gpio.dev, "%s failed: %d\n",\r\n"i2c_smbus_write_byte_data()", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adnp_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct adnp *adnp = to_adnp(chip);\r\nunsigned int reg = offset >> adnp->reg_shift;\r\nunsigned int pos = offset & 7;\r\nu8 value;\r\nint err;\r\nerr = adnp_read(adnp, GPIO_PLR(adnp) + reg, &value);\r\nif (err < 0)\r\nreturn err;\r\nreturn (value & BIT(pos)) ? 1 : 0;\r\n}\r\nstatic void __adnp_gpio_set(struct adnp *adnp, unsigned offset, int value)\r\n{\r\nunsigned int reg = offset >> adnp->reg_shift;\r\nunsigned int pos = offset & 7;\r\nint err;\r\nu8 val;\r\nerr = adnp_read(adnp, GPIO_PLR(adnp) + reg, &val);\r\nif (err < 0)\r\nreturn;\r\nif (value)\r\nval |= BIT(pos);\r\nelse\r\nval &= ~BIT(pos);\r\nadnp_write(adnp, GPIO_PLR(adnp) + reg, val);\r\n}\r\nstatic void adnp_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct adnp *adnp = to_adnp(chip);\r\nmutex_lock(&adnp->i2c_lock);\r\n__adnp_gpio_set(adnp, offset, value);\r\nmutex_unlock(&adnp->i2c_lock);\r\n}\r\nstatic int adnp_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct adnp *adnp = to_adnp(chip);\r\nunsigned int reg = offset >> adnp->reg_shift;\r\nunsigned int pos = offset & 7;\r\nu8 value;\r\nint err;\r\nmutex_lock(&adnp->i2c_lock);\r\nerr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &value);\r\nif (err < 0)\r\ngoto out;\r\nvalue &= ~BIT(pos);\r\nerr = adnp_write(adnp, GPIO_DDR(adnp) + reg, value);\r\nif (err < 0)\r\ngoto out;\r\nerr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &value);\r\nif (err < 0)\r\ngoto out;\r\nif (err & BIT(pos))\r\nerr = -EACCES;\r\nerr = 0;\r\nout:\r\nmutex_unlock(&adnp->i2c_lock);\r\nreturn err;\r\n}\r\nstatic int adnp_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct adnp *adnp = to_adnp(chip);\r\nunsigned int reg = offset >> adnp->reg_shift;\r\nunsigned int pos = offset & 7;\r\nint err;\r\nu8 val;\r\nmutex_lock(&adnp->i2c_lock);\r\nerr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &val);\r\nif (err < 0)\r\ngoto out;\r\nval |= BIT(pos);\r\nerr = adnp_write(adnp, GPIO_DDR(adnp) + reg, val);\r\nif (err < 0)\r\ngoto out;\r\nerr = adnp_read(adnp, GPIO_DDR(adnp) + reg, &val);\r\nif (err < 0)\r\ngoto out;\r\nif (!(val & BIT(pos))) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\n__adnp_gpio_set(adnp, offset, value);\r\nerr = 0;\r\nout:\r\nmutex_unlock(&adnp->i2c_lock);\r\nreturn err;\r\n}\r\nstatic void adnp_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct adnp *adnp = to_adnp(chip);\r\nunsigned int num_regs = 1 << adnp->reg_shift, i, j;\r\nint err;\r\nfor (i = 0; i < num_regs; i++) {\r\nu8 ddr, plr, ier, isr;\r\nmutex_lock(&adnp->i2c_lock);\r\nerr = adnp_read(adnp, GPIO_DDR(adnp) + i, &ddr);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\nreturn;\r\n}\r\nerr = adnp_read(adnp, GPIO_PLR(adnp) + i, &plr);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\nreturn;\r\n}\r\nerr = adnp_read(adnp, GPIO_IER(adnp) + i, &ier);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\nreturn;\r\n}\r\nerr = adnp_read(adnp, GPIO_ISR(adnp) + i, &isr);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\nreturn;\r\n}\r\nmutex_unlock(&adnp->i2c_lock);\r\nfor (j = 0; j < 8; j++) {\r\nunsigned int bit = (i << adnp->reg_shift) + j;\r\nconst char *direction = "input ";\r\nconst char *level = "low ";\r\nconst char *interrupt = "disabled";\r\nconst char *pending = "";\r\nif (ddr & BIT(j))\r\ndirection = "output";\r\nif (plr & BIT(j))\r\nlevel = "high";\r\nif (ier & BIT(j))\r\ninterrupt = "enabled ";\r\nif (isr & BIT(j))\r\npending = "pending";\r\nseq_printf(s, "%2u: %s %s IRQ %s %s\n", bit,\r\ndirection, level, interrupt, pending);\r\n}\r\n}\r\n}\r\nstatic int adnp_gpio_setup(struct adnp *adnp, unsigned int num_gpios)\r\n{\r\nstruct gpio_chip *chip = &adnp->gpio;\r\nint err;\r\nadnp->reg_shift = get_count_order(num_gpios) - 3;\r\nchip->direction_input = adnp_gpio_direction_input;\r\nchip->direction_output = adnp_gpio_direction_output;\r\nchip->get = adnp_gpio_get;\r\nchip->set = adnp_gpio_set;\r\nchip->can_sleep = true;\r\nif (IS_ENABLED(CONFIG_DEBUG_FS))\r\nchip->dbg_show = adnp_gpio_dbg_show;\r\nchip->base = -1;\r\nchip->ngpio = num_gpios;\r\nchip->label = adnp->client->name;\r\nchip->dev = &adnp->client->dev;\r\nchip->of_node = chip->dev->of_node;\r\nchip->owner = THIS_MODULE;\r\nerr = gpiochip_add(chip);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t adnp_irq(int irq, void *data)\r\n{\r\nstruct adnp *adnp = data;\r\nunsigned int num_regs, i;\r\nnum_regs = 1 << adnp->reg_shift;\r\nfor (i = 0; i < num_regs; i++) {\r\nunsigned int base = i << adnp->reg_shift, bit;\r\nu8 changed, level, isr, ier;\r\nunsigned long pending;\r\nint err;\r\nmutex_lock(&adnp->i2c_lock);\r\nerr = adnp_read(adnp, GPIO_PLR(adnp) + i, &level);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\ncontinue;\r\n}\r\nerr = adnp_read(adnp, GPIO_ISR(adnp) + i, &isr);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\ncontinue;\r\n}\r\nerr = adnp_read(adnp, GPIO_IER(adnp) + i, &ier);\r\nif (err < 0) {\r\nmutex_unlock(&adnp->i2c_lock);\r\ncontinue;\r\n}\r\nmutex_unlock(&adnp->i2c_lock);\r\nchanged = level ^ adnp->irq_level[i];\r\npending = changed & ((adnp->irq_fall[i] & ~level) |\r\n(adnp->irq_rise[i] & level));\r\npending |= (adnp->irq_high[i] & level) |\r\n(adnp->irq_low[i] & ~level);\r\npending &= isr & ier;\r\nfor_each_set_bit(bit, &pending, 8) {\r\nunsigned int child_irq;\r\nchild_irq = irq_find_mapping(adnp->gpio.irqdomain,\r\nbase + bit);\r\nhandle_nested_irq(child_irq);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void adnp_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct adnp *adnp = to_adnp(gc);\r\nunsigned int reg = d->hwirq >> adnp->reg_shift;\r\nunsigned int pos = d->hwirq & 7;\r\nadnp->irq_enable[reg] &= ~BIT(pos);\r\n}\r\nstatic void adnp_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct adnp *adnp = to_adnp(gc);\r\nunsigned int reg = d->hwirq >> adnp->reg_shift;\r\nunsigned int pos = d->hwirq & 7;\r\nadnp->irq_enable[reg] |= BIT(pos);\r\n}\r\nstatic int adnp_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct adnp *adnp = to_adnp(gc);\r\nunsigned int reg = d->hwirq >> adnp->reg_shift;\r\nunsigned int pos = d->hwirq & 7;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nadnp->irq_rise[reg] |= BIT(pos);\r\nelse\r\nadnp->irq_rise[reg] &= ~BIT(pos);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nadnp->irq_fall[reg] |= BIT(pos);\r\nelse\r\nadnp->irq_fall[reg] &= ~BIT(pos);\r\nif (type & IRQ_TYPE_LEVEL_HIGH)\r\nadnp->irq_high[reg] |= BIT(pos);\r\nelse\r\nadnp->irq_high[reg] &= ~BIT(pos);\r\nif (type & IRQ_TYPE_LEVEL_LOW)\r\nadnp->irq_low[reg] |= BIT(pos);\r\nelse\r\nadnp->irq_low[reg] &= ~BIT(pos);\r\nreturn 0;\r\n}\r\nstatic void adnp_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct adnp *adnp = to_adnp(gc);\r\nmutex_lock(&adnp->irq_lock);\r\n}\r\nstatic void adnp_irq_bus_unlock(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct adnp *adnp = to_adnp(gc);\r\nunsigned int num_regs = 1 << adnp->reg_shift, i;\r\nmutex_lock(&adnp->i2c_lock);\r\nfor (i = 0; i < num_regs; i++)\r\nadnp_write(adnp, GPIO_IER(adnp) + i, adnp->irq_enable[i]);\r\nmutex_unlock(&adnp->i2c_lock);\r\nmutex_unlock(&adnp->irq_lock);\r\n}\r\nstatic int adnp_irq_setup(struct adnp *adnp)\r\n{\r\nunsigned int num_regs = 1 << adnp->reg_shift, i;\r\nstruct gpio_chip *chip = &adnp->gpio;\r\nint err;\r\nmutex_init(&adnp->irq_lock);\r\nadnp->irq_enable = devm_kzalloc(chip->dev, num_regs * 6, GFP_KERNEL);\r\nif (!adnp->irq_enable)\r\nreturn -ENOMEM;\r\nadnp->irq_level = adnp->irq_enable + (num_regs * 1);\r\nadnp->irq_rise = adnp->irq_enable + (num_regs * 2);\r\nadnp->irq_fall = adnp->irq_enable + (num_regs * 3);\r\nadnp->irq_high = adnp->irq_enable + (num_regs * 4);\r\nadnp->irq_low = adnp->irq_enable + (num_regs * 5);\r\nfor (i = 0; i < num_regs; i++) {\r\nerr = adnp_read(adnp, GPIO_PLR(adnp) + i, &adnp->irq_level[i]);\r\nif (err < 0)\r\nreturn err;\r\nerr = adnp_write(adnp, GPIO_IER(adnp) + i, 0);\r\nif (err < 0)\r\nreturn err;\r\nadnp->irq_enable[i] = 0x00;\r\n}\r\nerr = devm_request_threaded_irq(chip->dev, adnp->client->irq,\r\nNULL, adnp_irq,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\ndev_name(chip->dev), adnp);\r\nif (err != 0) {\r\ndev_err(chip->dev, "can't request IRQ#%d: %d\n",\r\nadnp->client->irq, err);\r\nreturn err;\r\n}\r\nerr = gpiochip_irqchip_add(chip,\r\n&adnp_irq_chip,\r\n0,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(chip->dev,\r\n"could not connect irqchip to gpiochip\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adnp_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nstruct adnp *adnp;\r\nu32 num_gpios;\r\nint err;\r\nerr = of_property_read_u32(np, "nr-gpios", &num_gpios);\r\nif (err < 0)\r\nreturn err;\r\nclient->irq = irq_of_parse_and_map(np, 0);\r\nif (!client->irq)\r\nreturn -EPROBE_DEFER;\r\nadnp = devm_kzalloc(&client->dev, sizeof(*adnp), GFP_KERNEL);\r\nif (!adnp)\r\nreturn -ENOMEM;\r\nmutex_init(&adnp->i2c_lock);\r\nadnp->client = client;\r\nerr = adnp_gpio_setup(adnp, num_gpios);\r\nif (err)\r\nreturn err;\r\nif (of_find_property(np, "interrupt-controller", NULL)) {\r\nerr = adnp_irq_setup(adnp);\r\nif (err)\r\nreturn err;\r\n}\r\ni2c_set_clientdata(client, adnp);\r\nreturn 0;\r\n}\r\nstatic int adnp_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct adnp *adnp = i2c_get_clientdata(client);\r\ngpiochip_remove(&adnp->gpio);\r\nreturn 0;\r\n}
