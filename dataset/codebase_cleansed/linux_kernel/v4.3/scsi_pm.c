static int do_scsi_suspend(struct device *dev, const struct dev_pm_ops *pm)\r\n{\r\nreturn pm && pm->suspend ? pm->suspend(dev) : 0;\r\n}\r\nstatic int do_scsi_freeze(struct device *dev, const struct dev_pm_ops *pm)\r\n{\r\nreturn pm && pm->freeze ? pm->freeze(dev) : 0;\r\n}\r\nstatic int do_scsi_poweroff(struct device *dev, const struct dev_pm_ops *pm)\r\n{\r\nreturn pm && pm->poweroff ? pm->poweroff(dev) : 0;\r\n}\r\nstatic int do_scsi_resume(struct device *dev, const struct dev_pm_ops *pm)\r\n{\r\nreturn pm && pm->resume ? pm->resume(dev) : 0;\r\n}\r\nstatic int do_scsi_thaw(struct device *dev, const struct dev_pm_ops *pm)\r\n{\r\nreturn pm && pm->thaw ? pm->thaw(dev) : 0;\r\n}\r\nstatic int do_scsi_restore(struct device *dev, const struct dev_pm_ops *pm)\r\n{\r\nreturn pm && pm->restore ? pm->restore(dev) : 0;\r\n}\r\nstatic int scsi_dev_type_suspend(struct device *dev,\r\nint (*cb)(struct device *, const struct dev_pm_ops *))\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint err;\r\nasync_synchronize_full_domain(&scsi_sd_pm_domain);\r\nerr = scsi_device_quiesce(to_scsi_device(dev));\r\nif (err == 0) {\r\nerr = cb(dev, pm);\r\nif (err)\r\nscsi_device_resume(to_scsi_device(dev));\r\n}\r\ndev_dbg(dev, "scsi suspend: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int scsi_dev_type_resume(struct device *dev,\r\nint (*cb)(struct device *, const struct dev_pm_ops *))\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint err = 0;\r\nerr = cb(dev, pm);\r\nscsi_device_resume(to_scsi_device(dev));\r\ndev_dbg(dev, "scsi resume: %d\n", err);\r\nif (err == 0) {\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nscsi_bus_suspend_common(struct device *dev,\r\nint (*cb)(struct device *, const struct dev_pm_ops *))\r\n{\r\nint err = 0;\r\nif (scsi_is_sdev_device(dev)) {\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nerr = scsi_dev_type_suspend(dev, cb);\r\n}\r\nreturn err;\r\n}\r\nstatic void async_sdev_resume(void *dev, async_cookie_t cookie)\r\n{\r\nscsi_dev_type_resume(dev, do_scsi_resume);\r\n}\r\nstatic void async_sdev_thaw(void *dev, async_cookie_t cookie)\r\n{\r\nscsi_dev_type_resume(dev, do_scsi_thaw);\r\n}\r\nstatic void async_sdev_restore(void *dev, async_cookie_t cookie)\r\n{\r\nscsi_dev_type_resume(dev, do_scsi_restore);\r\n}\r\nstatic int scsi_bus_resume_common(struct device *dev,\r\nint (*cb)(struct device *, const struct dev_pm_ops *))\r\n{\r\nasync_func_t fn;\r\nif (!scsi_is_sdev_device(dev))\r\nfn = NULL;\r\nelse if (cb == do_scsi_resume)\r\nfn = async_sdev_resume;\r\nelse if (cb == do_scsi_thaw)\r\nfn = async_sdev_thaw;\r\nelse if (cb == do_scsi_restore)\r\nfn = async_sdev_restore;\r\nelse\r\nfn = NULL;\r\nif (fn) {\r\nasync_schedule_domain(fn, dev, &scsi_sd_pm_domain);\r\nif (strncmp(scsi_scan_type, "async", 5) != 0)\r\nasync_synchronize_full_domain(&scsi_sd_pm_domain);\r\n} else {\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int scsi_bus_prepare(struct device *dev)\r\n{\r\nif (scsi_is_sdev_device(dev)) {\r\nasync_synchronize_full_domain(&scsi_sd_probe_domain);\r\n} else if (scsi_is_host_device(dev)) {\r\nscsi_complete_async_scans();\r\n}\r\nreturn 0;\r\n}\r\nstatic int scsi_bus_suspend(struct device *dev)\r\n{\r\nreturn scsi_bus_suspend_common(dev, do_scsi_suspend);\r\n}\r\nstatic int scsi_bus_resume(struct device *dev)\r\n{\r\nreturn scsi_bus_resume_common(dev, do_scsi_resume);\r\n}\r\nstatic int scsi_bus_freeze(struct device *dev)\r\n{\r\nreturn scsi_bus_suspend_common(dev, do_scsi_freeze);\r\n}\r\nstatic int scsi_bus_thaw(struct device *dev)\r\n{\r\nreturn scsi_bus_resume_common(dev, do_scsi_thaw);\r\n}\r\nstatic int scsi_bus_poweroff(struct device *dev)\r\n{\r\nreturn scsi_bus_suspend_common(dev, do_scsi_poweroff);\r\n}\r\nstatic int scsi_bus_restore(struct device *dev)\r\n{\r\nreturn scsi_bus_resume_common(dev, do_scsi_restore);\r\n}\r\nstatic int sdev_runtime_suspend(struct device *dev)\r\n{\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nint err = 0;\r\nif (pm && pm->runtime_suspend) {\r\nerr = blk_pre_runtime_suspend(sdev->request_queue);\r\nif (err)\r\nreturn err;\r\nerr = pm->runtime_suspend(dev);\r\nblk_post_runtime_suspend(sdev->request_queue, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int scsi_runtime_suspend(struct device *dev)\r\n{\r\nint err = 0;\r\ndev_dbg(dev, "scsi_runtime_suspend\n");\r\nif (scsi_is_sdev_device(dev))\r\nerr = sdev_runtime_suspend(dev);\r\nreturn err;\r\n}\r\nstatic int sdev_runtime_resume(struct device *dev)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nconst struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;\r\nint err = 0;\r\nif (pm && pm->runtime_resume) {\r\nblk_pre_runtime_resume(sdev->request_queue);\r\nerr = pm->runtime_resume(dev);\r\nblk_post_runtime_resume(sdev->request_queue, err);\r\n}\r\nreturn err;\r\n}\r\nstatic int scsi_runtime_resume(struct device *dev)\r\n{\r\nint err = 0;\r\ndev_dbg(dev, "scsi_runtime_resume\n");\r\nif (scsi_is_sdev_device(dev))\r\nerr = sdev_runtime_resume(dev);\r\nreturn err;\r\n}\r\nstatic int scsi_runtime_idle(struct device *dev)\r\n{\r\ndev_dbg(dev, "scsi_runtime_idle\n");\r\nif (scsi_is_sdev_device(dev)) {\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_autosuspend(dev);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint scsi_autopm_get_device(struct scsi_device *sdev)\r\n{\r\nint err;\r\nerr = pm_runtime_get_sync(&sdev->sdev_gendev);\r\nif (err < 0 && err !=-EACCES)\r\npm_runtime_put_sync(&sdev->sdev_gendev);\r\nelse\r\nerr = 0;\r\nreturn err;\r\n}\r\nvoid scsi_autopm_put_device(struct scsi_device *sdev)\r\n{\r\npm_runtime_put_sync(&sdev->sdev_gendev);\r\n}\r\nvoid scsi_autopm_get_target(struct scsi_target *starget)\r\n{\r\npm_runtime_get_sync(&starget->dev);\r\n}\r\nvoid scsi_autopm_put_target(struct scsi_target *starget)\r\n{\r\npm_runtime_put_sync(&starget->dev);\r\n}\r\nint scsi_autopm_get_host(struct Scsi_Host *shost)\r\n{\r\nint err;\r\nerr = pm_runtime_get_sync(&shost->shost_gendev);\r\nif (err < 0 && err !=-EACCES)\r\npm_runtime_put_sync(&shost->shost_gendev);\r\nelse\r\nerr = 0;\r\nreturn err;\r\n}\r\nvoid scsi_autopm_put_host(struct Scsi_Host *shost)\r\n{\r\npm_runtime_put_sync(&shost->shost_gendev);\r\n}
