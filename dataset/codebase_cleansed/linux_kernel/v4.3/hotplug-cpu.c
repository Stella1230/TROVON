static int __init setup_cede_offline(char *str)\r\n{\r\nif (!strcmp(str, "off"))\r\ncede_offline_enabled = 0;\r\nelse if (!strcmp(str, "on"))\r\ncede_offline_enabled = 1;\r\nelse\r\nreturn 0;\r\nreturn 1;\r\n}\r\nenum cpu_state_vals get_cpu_current_state(int cpu)\r\n{\r\nreturn per_cpu(current_state, cpu);\r\n}\r\nvoid set_cpu_current_state(int cpu, enum cpu_state_vals state)\r\n{\r\nper_cpu(current_state, cpu) = state;\r\n}\r\nenum cpu_state_vals get_preferred_offline_state(int cpu)\r\n{\r\nreturn per_cpu(preferred_offline_state, cpu);\r\n}\r\nvoid set_preferred_offline_state(int cpu, enum cpu_state_vals state)\r\n{\r\nper_cpu(preferred_offline_state, cpu) = state;\r\n}\r\nvoid set_default_offline_state(int cpu)\r\n{\r\nper_cpu(preferred_offline_state, cpu) = default_offline_state;\r\n}\r\nstatic void rtas_stop_self(void)\r\n{\r\nstatic struct rtas_args args = {\r\n.nargs = 0,\r\n.nret = cpu_to_be32(1),\r\n.rets = &args.args[0],\r\n};\r\nargs.token = cpu_to_be32(rtas_stop_self_token);\r\nlocal_irq_disable();\r\nBUG_ON(rtas_stop_self_token == RTAS_UNKNOWN_SERVICE);\r\nprintk("cpu %u (hwid %u) Ready to die...\n",\r\nsmp_processor_id(), hard_smp_processor_id());\r\nenter_rtas(__pa(&args));\r\npanic("Alas, I survived.\n");\r\n}\r\nstatic void pseries_mach_cpu_die(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nunsigned int hwcpu = hard_smp_processor_id();\r\nu8 cede_latency_hint = 0;\r\nlocal_irq_disable();\r\nidle_task_exit();\r\nxics_teardown_cpu();\r\nif (get_preferred_offline_state(cpu) == CPU_STATE_INACTIVE) {\r\nset_cpu_current_state(cpu, CPU_STATE_INACTIVE);\r\nif (ppc_md.suspend_disable_cpu)\r\nppc_md.suspend_disable_cpu();\r\ncede_latency_hint = 2;\r\nget_lppaca()->idle = 1;\r\nif (!lppaca_shared_proc(get_lppaca()))\r\nget_lppaca()->donate_dedicated_cpu = 1;\r\nwhile (get_preferred_offline_state(cpu) == CPU_STATE_INACTIVE) {\r\nwhile (!prep_irq_for_idle()) {\r\nlocal_irq_enable();\r\nlocal_irq_disable();\r\n}\r\nextended_cede_processor(cede_latency_hint);\r\n}\r\nlocal_irq_disable();\r\nif (!lppaca_shared_proc(get_lppaca()))\r\nget_lppaca()->donate_dedicated_cpu = 0;\r\nget_lppaca()->idle = 0;\r\nif (get_preferred_offline_state(cpu) == CPU_STATE_ONLINE) {\r\nunregister_slb_shadow(hwcpu);\r\nhard_irq_disable();\r\nstart_secondary_resume();\r\n}\r\n}\r\nWARN_ON(get_preferred_offline_state(cpu) != CPU_STATE_OFFLINE);\r\nset_cpu_current_state(cpu, CPU_STATE_OFFLINE);\r\nunregister_slb_shadow(hwcpu);\r\nrtas_stop_self();\r\nBUG();\r\nfor(;;);\r\n}\r\nstatic int pseries_cpu_disable(void)\r\n{\r\nint cpu = smp_processor_id();\r\nset_cpu_online(cpu, false);\r\nvdso_data->processorCount--;\r\nif (cpu == boot_cpuid)\r\nboot_cpuid = cpumask_any(cpu_online_mask);\r\nxics_migrate_irqs_away();\r\nreturn 0;\r\n}\r\nstatic void pseries_cpu_die(unsigned int cpu)\r\n{\r\nint tries;\r\nint cpu_status = 1;\r\nunsigned int pcpu = get_hard_smp_processor_id(cpu);\r\nif (get_preferred_offline_state(cpu) == CPU_STATE_INACTIVE) {\r\ncpu_status = 1;\r\nfor (tries = 0; tries < 5000; tries++) {\r\nif (get_cpu_current_state(cpu) == CPU_STATE_INACTIVE) {\r\ncpu_status = 0;\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\n} else if (get_preferred_offline_state(cpu) == CPU_STATE_OFFLINE) {\r\nfor (tries = 0; tries < 25; tries++) {\r\ncpu_status = smp_query_cpu_stopped(pcpu);\r\nif (cpu_status == QCSS_STOPPED ||\r\ncpu_status == QCSS_HARDWARE_ERROR)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nif (cpu_status != 0) {\r\nprintk("Querying DEAD? cpu %i (%i) shows %i\n",\r\ncpu, pcpu, cpu_status);\r\n}\r\npaca[cpu].cpu_start = 0;\r\n}\r\nstatic int pseries_add_processor(struct device_node *np)\r\n{\r\nunsigned int cpu;\r\ncpumask_var_t candidate_mask, tmp;\r\nint err = -ENOSPC, len, nthreads, i;\r\nconst __be32 *intserv;\r\nintserv = of_get_property(np, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn 0;\r\nzalloc_cpumask_var(&candidate_mask, GFP_KERNEL);\r\nzalloc_cpumask_var(&tmp, GFP_KERNEL);\r\nnthreads = len / sizeof(u32);\r\nfor (i = 0; i < nthreads; i++)\r\ncpumask_set_cpu(i, tmp);\r\ncpu_maps_update_begin();\r\nBUG_ON(!cpumask_subset(cpu_present_mask, cpu_possible_mask));\r\ncpumask_xor(candidate_mask, cpu_possible_mask, cpu_present_mask);\r\nif (cpumask_empty(candidate_mask)) {\r\nprintk(KERN_ERR "Cannot add cpu %s; this system configuration"\r\n" supports %d logical cpus.\n", np->full_name,\r\nnum_possible_cpus());\r\ngoto out_unlock;\r\n}\r\nwhile (!cpumask_empty(tmp))\r\nif (cpumask_subset(tmp, candidate_mask))\r\nbreak;\r\nelse\r\ncpumask_shift_left(tmp, tmp, nthreads);\r\nif (cpumask_empty(tmp)) {\r\nprintk(KERN_ERR "Unable to find space in cpu_present_mask for"\r\n" processor %s with %d thread(s)\n", np->name,\r\nnthreads);\r\ngoto out_unlock;\r\n}\r\nfor_each_cpu(cpu, tmp) {\r\nBUG_ON(cpu_present(cpu));\r\nset_cpu_present(cpu, true);\r\nset_hard_smp_processor_id(cpu, be32_to_cpu(*intserv++));\r\n}\r\nerr = 0;\r\nout_unlock:\r\ncpu_maps_update_done();\r\nfree_cpumask_var(candidate_mask);\r\nfree_cpumask_var(tmp);\r\nreturn err;\r\n}\r\nstatic void pseries_remove_processor(struct device_node *np)\r\n{\r\nunsigned int cpu;\r\nint len, nthreads, i;\r\nconst __be32 *intserv;\r\nu32 thread;\r\nintserv = of_get_property(np, "ibm,ppc-interrupt-server#s", &len);\r\nif (!intserv)\r\nreturn;\r\nnthreads = len / sizeof(u32);\r\ncpu_maps_update_begin();\r\nfor (i = 0; i < nthreads; i++) {\r\nthread = be32_to_cpu(intserv[i]);\r\nfor_each_present_cpu(cpu) {\r\nif (get_hard_smp_processor_id(cpu) != thread)\r\ncontinue;\r\nBUG_ON(cpu_online(cpu));\r\nset_cpu_present(cpu, false);\r\nset_hard_smp_processor_id(cpu, -1);\r\nbreak;\r\n}\r\nif (cpu >= nr_cpu_ids)\r\nprintk(KERN_WARNING "Could not find cpu to remove "\r\n"with physical id 0x%x\n", thread);\r\n}\r\ncpu_maps_update_done();\r\n}\r\nstatic int pseries_smp_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct of_reconfig_data *rd = data;\r\nint err = 0;\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\nerr = pseries_add_processor(rd->dn);\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\npseries_remove_processor(rd->dn);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int parse_cede_parameters(void)\r\n{\r\nmemset(cede_parameters, 0, CEDE_LATENCY_PARAM_MAX_LENGTH);\r\nreturn rtas_call(rtas_token("ibm,get-system-parameter"), 3, 1,\r\nNULL,\r\nCEDE_LATENCY_TOKEN,\r\n__pa(cede_parameters),\r\nCEDE_LATENCY_PARAM_MAX_LENGTH);\r\n}\r\nstatic int __init pseries_cpu_hotplug_init(void)\r\n{\r\nstruct device_node *np;\r\nconst char *typep;\r\nint cpu;\r\nint qcss_tok;\r\nfor_each_node_by_name(np, "interrupt-controller") {\r\ntypep = of_get_property(np, "compatible", NULL);\r\nif (strstr(typep, "open-pic")) {\r\nof_node_put(np);\r\nprintk(KERN_INFO "CPU Hotplug not supported on "\r\n"systems using MPIC\n");\r\nreturn 0;\r\n}\r\n}\r\nrtas_stop_self_token = rtas_token("stop-self");\r\nqcss_tok = rtas_token("query-cpu-stopped-state");\r\nif (rtas_stop_self_token == RTAS_UNKNOWN_SERVICE ||\r\nqcss_tok == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_INFO "CPU Hotplug not supported by firmware "\r\n"- disabling.\n");\r\nreturn 0;\r\n}\r\nppc_md.cpu_die = pseries_mach_cpu_die;\r\nsmp_ops->cpu_disable = pseries_cpu_disable;\r\nsmp_ops->cpu_die = pseries_cpu_die;\r\nif (firmware_has_feature(FW_FEATURE_LPAR)) {\r\nof_reconfig_notifier_register(&pseries_smp_nb);\r\ncpu_maps_update_begin();\r\nif (cede_offline_enabled && parse_cede_parameters() == 0) {\r\ndefault_offline_state = CPU_STATE_INACTIVE;\r\nfor_each_online_cpu(cpu)\r\nset_default_offline_state(cpu);\r\n}\r\ncpu_maps_update_done();\r\n}\r\nreturn 0;\r\n}
