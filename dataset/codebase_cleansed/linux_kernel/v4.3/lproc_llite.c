static ssize_t blocksize_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nstruct obd_statfs osfs;\r\nint rc;\r\nrc = ll_statfs_internal(sbi->ll_sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nreturn sprintf(buf, "%u\n", osfs.os_bsize);\r\nreturn rc;\r\n}\r\nstatic ssize_t kbytestotal_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nstruct obd_statfs osfs;\r\nint rc;\r\nrc = ll_statfs_internal(sbi->ll_sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_blocks;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = sprintf(buf, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t kbytesfree_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nstruct obd_statfs osfs;\r\nint rc;\r\nrc = ll_statfs_internal(sbi->ll_sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bfree;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = sprintf(buf, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t kbytesavail_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nstruct obd_statfs osfs;\r\nint rc;\r\nrc = ll_statfs_internal(sbi->ll_sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bavail;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\nrc = sprintf(buf, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t filestotal_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nstruct obd_statfs osfs;\r\nint rc;\r\nrc = ll_statfs_internal(sbi->ll_sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nreturn sprintf(buf, "%llu\n", osfs.os_files);\r\nreturn rc;\r\n}\r\nstatic ssize_t filesfree_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nstruct obd_statfs osfs;\r\nint rc;\r\nrc = ll_statfs_internal(sbi->ll_sb, &osfs,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nOBD_STATFS_NODELAY);\r\nif (!rc)\r\nreturn sprintf(buf, "%llu\n", osfs.os_ffree);\r\nreturn rc;\r\n}\r\nstatic ssize_t client_type_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%s client\n",\r\nsbi->ll_flags & LL_SBI_RMT_CLIENT ? "remote" : "local");\r\n}\r\nstatic ssize_t fstype_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%s\n", sbi->ll_sb->s_type->name);\r\n}\r\nstatic ssize_t uuid_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%s\n", sbi->ll_sb_uuid.uuid);\r\n}\r\nstatic int ll_site_stats_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nreturn cl_site_stats_print(lu2cl_site(ll_s2sbi(sb)->ll_site), m);\r\n}\r\nstatic ssize_t max_read_ahead_mb_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nlong pages_number;\r\nint mult;\r\nspin_lock(&sbi->ll_lock);\r\npages_number = sbi->ll_ra_info.ra_max_pages;\r\nspin_unlock(&sbi->ll_lock);\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nreturn lprocfs_read_frac_helper(buf, PAGE_SIZE, pages_number, mult);\r\n}\r\nstatic ssize_t max_read_ahead_mb_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long pages_number;\r\nrc = kstrtoul(buffer, 10, &pages_number);\r\nif (rc)\r\nreturn rc;\r\npages_number *= 1 << (20 - PAGE_CACHE_SHIFT);\r\nif (pages_number > totalram_pages / 2) {\r\nCERROR("can't set file readahead more than %lu MB\n",\r\ntotalram_pages >> (20 - PAGE_CACHE_SHIFT + 1));\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\nsbi->ll_ra_info.ra_max_pages = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t max_read_ahead_per_file_mb_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nlong pages_number;\r\nint mult;\r\nspin_lock(&sbi->ll_lock);\r\npages_number = sbi->ll_ra_info.ra_max_pages_per_file;\r\nspin_unlock(&sbi->ll_lock);\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nreturn lprocfs_read_frac_helper(buf, PAGE_SIZE, pages_number, mult);\r\n}\r\nstatic ssize_t max_read_ahead_per_file_mb_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long pages_number;\r\nrc = kstrtoul(buffer, 10, &pages_number);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number > sbi->ll_ra_info.ra_max_pages) {\r\nCERROR("can't set file readahead more than max_read_ahead_mb %lu MB\n",\r\nsbi->ll_ra_info.ra_max_pages);\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\nsbi->ll_ra_info.ra_max_pages_per_file = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t max_read_ahead_whole_mb_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nlong pages_number;\r\nint mult;\r\nspin_lock(&sbi->ll_lock);\r\npages_number = sbi->ll_ra_info.ra_max_read_ahead_whole_pages;\r\nspin_unlock(&sbi->ll_lock);\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nreturn lprocfs_read_frac_helper(buf, PAGE_SIZE, pages_number, mult);\r\n}\r\nstatic ssize_t max_read_ahead_whole_mb_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long pages_number;\r\nrc = kstrtoul(buffer, 10, &pages_number);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number > sbi->ll_ra_info.ra_max_pages_per_file) {\r\nCERROR("can't set max_read_ahead_whole_mb more than max_read_ahead_per_file_mb: %lu\n",\r\nsbi->ll_ra_info.ra_max_pages_per_file >> (20 - PAGE_CACHE_SHIFT));\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\nsbi->ll_ra_info.ra_max_read_ahead_whole_pages = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nreturn count;\r\n}\r\nstatic int ll_max_cached_mb_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct cl_client_cache *cache = &sbi->ll_cache;\r\nint shift = 20 - PAGE_CACHE_SHIFT;\r\nint max_cached_mb;\r\nint unused_mb;\r\nmax_cached_mb = cache->ccc_lru_max >> shift;\r\nunused_mb = atomic_read(&cache->ccc_lru_left) >> shift;\r\nseq_printf(m,\r\n"users: %d\n"\r\n"max_cached_mb: %d\n"\r\n"used_mb: %d\n"\r\n"unused_mb: %d\n"\r\n"reclaim_count: %u\n",\r\natomic_read(&cache->ccc_users),\r\nmax_cached_mb,\r\nmax_cached_mb - unused_mb,\r\nunused_mb,\r\ncache->ccc_lru_shrinkers);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_max_cached_mb_seq_write(struct file *file,\r\nconst char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct super_block *sb = ((struct seq_file *)file->private_data)->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct cl_client_cache *cache = &sbi->ll_cache;\r\nint mult, rc, pages_number;\r\nint diff = 0;\r\nint nrpages = 0;\r\nchar kernbuf[128];\r\nif (count >= sizeof(kernbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(kernbuf, buffer, count))\r\nreturn -EFAULT;\r\nkernbuf[count] = 0;\r\nmult = 1 << (20 - PAGE_CACHE_SHIFT);\r\nbuffer += lprocfs_find_named_value(kernbuf, "max_cached_mb:", &count) -\r\nkernbuf;\r\nrc = lprocfs_write_frac_helper(buffer, count, &pages_number, mult);\r\nif (rc)\r\nreturn rc;\r\nif (pages_number < 0 || pages_number > totalram_pages) {\r\nCERROR("%s: can't set max cache more than %lu MB\n",\r\nll_get_fsname(sb, NULL, 0),\r\ntotalram_pages >> (20 - PAGE_CACHE_SHIFT));\r\nreturn -ERANGE;\r\n}\r\nspin_lock(&sbi->ll_lock);\r\ndiff = pages_number - cache->ccc_lru_max;\r\nspin_unlock(&sbi->ll_lock);\r\nif (diff >= 0) {\r\natomic_add(diff, &cache->ccc_lru_left);\r\nrc = 0;\r\ngoto out;\r\n}\r\ndiff = -diff;\r\nwhile (diff > 0) {\r\nint tmp;\r\ndo {\r\nint ov, nv;\r\nov = atomic_read(&cache->ccc_lru_left);\r\nif (ov == 0)\r\nbreak;\r\nnv = ov > diff ? ov - diff : 0;\r\nrc = atomic_cmpxchg(&cache->ccc_lru_left, ov, nv);\r\nif (likely(ov == rc)) {\r\ndiff -= ov - nv;\r\nnrpages += ov - nv;\r\nbreak;\r\n}\r\n} while (1);\r\nif (diff <= 0)\r\nbreak;\r\nif (sbi->ll_dt_exp == NULL) {\r\nrc = -ENODEV;\r\nbreak;\r\n}\r\ntmp = diff << 1;\r\nrc = obd_set_info_async(NULL, sbi->ll_dt_exp,\r\nsizeof(KEY_CACHE_LRU_SHRINK),\r\nKEY_CACHE_LRU_SHRINK,\r\nsizeof(tmp), &tmp, NULL);\r\nif (rc < 0)\r\nbreak;\r\n}\r\nout:\r\nif (rc >= 0) {\r\nspin_lock(&sbi->ll_lock);\r\ncache->ccc_lru_max = pages_number;\r\nspin_unlock(&sbi->ll_lock);\r\nrc = count;\r\n} else {\r\natomic_add(nrpages, &cache->ccc_lru_left);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t checksum_pages_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%u\n", (sbi->ll_flags & LL_SBI_CHECKSUM) ? 1 : 0);\r\n}\r\nstatic ssize_t checksum_pages_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long val;\r\nif (!sbi->ll_dt_exp)\r\nreturn -EAGAIN;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val)\r\nsbi->ll_flags |= LL_SBI_CHECKSUM;\r\nelse\r\nsbi->ll_flags &= ~LL_SBI_CHECKSUM;\r\nrc = obd_set_info_async(NULL, sbi->ll_dt_exp, sizeof(KEY_CHECKSUM),\r\nKEY_CHECKSUM, sizeof(val), &val, NULL);\r\nif (rc)\r\nCWARN("Failed to set OSC checksum flags: %d\n", rc);\r\nreturn count;\r\n}\r\nstatic ssize_t ll_rd_track_id(struct kobject *kobj, char *buf,\r\nenum stats_track_type type)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nif (sbi->ll_stats_track_type == type)\r\nreturn sprintf(buf, "%d\n", sbi->ll_stats_track_id);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_ALL)\r\nreturn sprintf(buf, "0 (all)\n");\r\nelse\r\nreturn sprintf(buf, "untracked\n");\r\n}\r\nstatic ssize_t ll_wr_track_id(struct kobject *kobj, const char *buffer,\r\nsize_t count,\r\nenum stats_track_type type)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long pid;\r\nrc = kstrtoul(buffer, 10, &pid);\r\nif (rc)\r\nreturn rc;\r\nsbi->ll_stats_track_id = pid;\r\nif (pid == 0)\r\nsbi->ll_stats_track_type = STATS_TRACK_ALL;\r\nelse\r\nsbi->ll_stats_track_type = type;\r\nlprocfs_clear_stats(sbi->ll_stats);\r\nreturn count;\r\n}\r\nstatic ssize_t stats_track_pid_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn ll_rd_track_id(kobj, buf, STATS_TRACK_PID);\r\n}\r\nstatic ssize_t stats_track_pid_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nreturn ll_wr_track_id(kobj, buffer, count, STATS_TRACK_PID);\r\n}\r\nstatic ssize_t stats_track_ppid_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn ll_rd_track_id(kobj, buf, STATS_TRACK_PPID);\r\n}\r\nstatic ssize_t stats_track_ppid_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nreturn ll_wr_track_id(kobj, buffer, count, STATS_TRACK_PPID);\r\n}\r\nstatic ssize_t stats_track_gid_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn ll_rd_track_id(kobj, buf, STATS_TRACK_GID);\r\n}\r\nstatic ssize_t stats_track_gid_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nreturn ll_wr_track_id(kobj, buffer, count, STATS_TRACK_GID);\r\n}\r\nstatic ssize_t statahead_max_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%u\n", sbi->ll_sa_max);\r\n}\r\nstatic ssize_t statahead_max_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val <= LL_SA_RPC_MAX)\r\nsbi->ll_sa_max = val;\r\nelse\r\nCERROR("Bad statahead_max value %lu. Valid values are in the range [0, %d]\n",\r\nval, LL_SA_RPC_MAX);\r\nreturn count;\r\n}\r\nstatic ssize_t statahead_agl_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%u\n", sbi->ll_flags & LL_SBI_AGL_ENABLED ? 1 : 0);\r\n}\r\nstatic ssize_t statahead_agl_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val)\r\nsbi->ll_flags |= LL_SBI_AGL_ENABLED;\r\nelse\r\nsbi->ll_flags &= ~LL_SBI_AGL_ENABLED;\r\nreturn count;\r\n}\r\nstatic int ll_statahead_stats_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct super_block *sb = m->private;\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nseq_printf(m,\r\n"statahead total: %u\n"\r\n"statahead wrong: %u\n"\r\n"agl total: %u\n",\r\natomic_read(&sbi->ll_sa_total),\r\natomic_read(&sbi->ll_sa_wrong),\r\natomic_read(&sbi->ll_agl_total));\r\nreturn 0;\r\n}\r\nstatic ssize_t lazystatfs_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%u\n", sbi->ll_flags & LL_SBI_LAZYSTATFS ? 1 : 0);\r\n}\r\nstatic ssize_t lazystatfs_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val)\r\nsbi->ll_flags |= LL_SBI_LAZYSTATFS;\r\nelse\r\nsbi->ll_flags &= ~LL_SBI_LAZYSTATFS;\r\nreturn count;\r\n}\r\nstatic ssize_t max_easize_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nunsigned int ealen;\r\nint rc;\r\nrc = ll_get_max_mdsize(sbi, &ealen);\r\nif (rc)\r\nreturn rc;\r\nreturn sprintf(buf, "%u\n", ealen);\r\n}\r\nstatic ssize_t default_easize_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nunsigned int ealen;\r\nint rc;\r\nrc = ll_get_default_mdsize(sbi, &ealen);\r\nif (rc)\r\nreturn rc;\r\nreturn sprintf(buf, "%u\n", ealen);\r\n}\r\nstatic int ll_sbi_flags_seq_show(struct seq_file *m, void *v)\r\n{\r\nconst char *str[] = LL_SBI_FLAGS;\r\nstruct super_block *sb = m->private;\r\nint flags = ll_s2sbi(sb)->ll_flags;\r\nint i = 0;\r\nwhile (flags != 0) {\r\nif (ARRAY_SIZE(str) <= i) {\r\nCERROR("%s: Revise array LL_SBI_FLAGS to match sbi flags please.\n",\r\nll_get_fsname(sb, NULL, 0));\r\nreturn -EINVAL;\r\n}\r\nif (flags & 0x1)\r\nseq_printf(m, "%s ", str[i]);\r\nflags >>= 1;\r\n++i;\r\n}\r\nseq_printf(m, "\b\n");\r\nreturn 0;\r\n}\r\nstatic ssize_t xattr_cache_show(struct kobject *kobj,\r\nstruct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nreturn sprintf(buf, "%u\n", sbi->ll_xattr_cache_enabled);\r\n}\r\nstatic ssize_t xattr_cache_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\nint rc;\r\nunsigned long val;\r\nrc = kstrtoul(buffer, 10, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val != 0 && val != 1)\r\nreturn -ERANGE;\r\nif (val == 1 && !(sbi->ll_flags & LL_SBI_XATTR_CACHE))\r\nreturn -ENOTSUPP;\r\nsbi->ll_xattr_cache_enabled = val;\r\nreturn count;\r\n}\r\nstatic void llite_sb_release(struct kobject *kobj)\r\n{\r\nstruct ll_sb_info *sbi = container_of(kobj, struct ll_sb_info,\r\nll_kobj);\r\ncomplete(&sbi->ll_kobj_unregister);\r\n}\r\nvoid ll_stats_ops_tally(struct ll_sb_info *sbi, int op, int count)\r\n{\r\nif (!sbi->ll_stats)\r\nreturn;\r\nif (sbi->ll_stats_track_type == STATS_TRACK_ALL)\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_PID &&\r\nsbi->ll_stats_track_id == current->pid)\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_PPID &&\r\nsbi->ll_stats_track_id == current->real_parent->pid)\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\nelse if (sbi->ll_stats_track_type == STATS_TRACK_GID &&\r\nsbi->ll_stats_track_id ==\r\nfrom_kgid(&init_user_ns, current_gid()))\r\nlprocfs_counter_add(sbi->ll_stats, op, count);\r\n}\r\nint ldebugfs_register_mountpoint(struct dentry *parent,\r\nstruct super_block *sb, char *osc, char *mdc)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct ll_sb_info *sbi = ll_s2sbi(sb);\r\nstruct obd_device *obd;\r\nstruct dentry *dir;\r\nchar name[MAX_STRING_SIZE + 1], *ptr;\r\nint err, id, len, rc;\r\nname[MAX_STRING_SIZE] = '\0';\r\nLASSERT(sbi != NULL);\r\nLASSERT(mdc != NULL);\r\nLASSERT(osc != NULL);\r\nlen = strlen(lsi->lsi_lmd->lmd_profile);\r\nptr = strrchr(lsi->lsi_lmd->lmd_profile, '-');\r\nif (ptr && (strcmp(ptr, "-client") == 0))\r\nlen -= 7;\r\nsnprintf(name, MAX_STRING_SIZE, "%.*s-%p", len,\r\nlsi->lsi_lmd->lmd_profile, sb);\r\ndir = ldebugfs_register(name, parent, NULL, NULL);\r\nif (IS_ERR_OR_NULL(dir)) {\r\nerr = dir ? PTR_ERR(dir) : -ENOMEM;\r\nsbi->ll_debugfs_entry = NULL;\r\nreturn err;\r\n}\r\nsbi->ll_debugfs_entry = dir;\r\nrc = ldebugfs_seq_create(sbi->ll_debugfs_entry, "dump_page_cache", 0444,\r\n&vvp_dump_pgcache_file_ops, sbi);\r\nif (rc)\r\nCWARN("Error adding the dump_page_cache file\n");\r\nrc = ldebugfs_seq_create(sbi->ll_debugfs_entry, "extents_stats", 0644,\r\n&ll_rw_extents_stats_fops, sbi);\r\nif (rc)\r\nCWARN("Error adding the extent_stats file\n");\r\nrc = ldebugfs_seq_create(sbi->ll_debugfs_entry,\r\n"extents_stats_per_process",\r\n0644, &ll_rw_extents_stats_pp_fops, sbi);\r\nif (rc)\r\nCWARN("Error adding the extents_stats_per_process file\n");\r\nrc = ldebugfs_seq_create(sbi->ll_debugfs_entry, "offset_stats", 0644,\r\n&ll_rw_offset_stats_fops, sbi);\r\nif (rc)\r\nCWARN("Error adding the offset_stats file\n");\r\nsbi->ll_stats = lprocfs_alloc_stats(LPROC_LL_FILE_OPCODES,\r\nLPROCFS_STATS_FLAG_NONE);\r\nif (sbi->ll_stats == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (id = 0; id < LPROC_LL_FILE_OPCODES; id++) {\r\n__u32 type = llite_opcode_table[id].type;\r\nvoid *ptr = NULL;\r\nif (type & LPROCFS_TYPE_REGS)\r\nptr = "regs";\r\nelse if (type & LPROCFS_TYPE_BYTES)\r\nptr = "bytes";\r\nelse if (type & LPROCFS_TYPE_PAGES)\r\nptr = "pages";\r\nlprocfs_counter_init(sbi->ll_stats,\r\nllite_opcode_table[id].opcode,\r\n(type & LPROCFS_CNTR_AVGMINMAX),\r\nllite_opcode_table[id].opname, ptr);\r\n}\r\nerr = ldebugfs_register_stats(sbi->ll_debugfs_entry, "stats",\r\nsbi->ll_stats);\r\nif (err)\r\ngoto out;\r\nsbi->ll_ra_stats = lprocfs_alloc_stats(ARRAY_SIZE(ra_stat_string),\r\nLPROCFS_STATS_FLAG_NONE);\r\nif (sbi->ll_ra_stats == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (id = 0; id < ARRAY_SIZE(ra_stat_string); id++)\r\nlprocfs_counter_init(sbi->ll_ra_stats, id, 0,\r\nra_stat_string[id], "pages");\r\nerr = ldebugfs_register_stats(sbi->ll_debugfs_entry, "read_ahead_stats",\r\nsbi->ll_ra_stats);\r\nif (err)\r\ngoto out;\r\nerr = ldebugfs_add_vars(sbi->ll_debugfs_entry,\r\nlprocfs_llite_obd_vars, sb);\r\nif (err)\r\ngoto out;\r\nsbi->ll_kobj.kset = llite_kset;\r\ninit_completion(&sbi->ll_kobj_unregister);\r\nerr = kobject_init_and_add(&sbi->ll_kobj, &llite_ktype, NULL,\r\n"%s", name);\r\nif (err)\r\ngoto out;\r\nobd = class_name2obd(mdc);\r\nerr = sysfs_create_link(&sbi->ll_kobj, &obd->obd_kobj,\r\nobd->obd_type->typ_name);\r\nif (err)\r\ngoto out;\r\nobd = class_name2obd(osc);\r\nerr = sysfs_create_link(&sbi->ll_kobj, &obd->obd_kobj,\r\nobd->obd_type->typ_name);\r\nout:\r\nif (err) {\r\nldebugfs_remove(&sbi->ll_debugfs_entry);\r\nlprocfs_free_stats(&sbi->ll_ra_stats);\r\nlprocfs_free_stats(&sbi->ll_stats);\r\n}\r\nreturn err;\r\n}\r\nvoid ldebugfs_unregister_mountpoint(struct ll_sb_info *sbi)\r\n{\r\nif (sbi->ll_debugfs_entry) {\r\nldebugfs_remove(&sbi->ll_debugfs_entry);\r\nkobject_put(&sbi->ll_kobj);\r\nwait_for_completion(&sbi->ll_kobj_unregister);\r\nlprocfs_free_stats(&sbi->ll_ra_stats);\r\nlprocfs_free_stats(&sbi->ll_stats);\r\n}\r\n}\r\nstatic void ll_display_extents_info(struct ll_rw_extents_info *io_extents,\r\nstruct seq_file *seq, int which)\r\n{\r\nunsigned long read_tot = 0, write_tot = 0, read_cum, write_cum;\r\nunsigned long start, end, r, w;\r\nchar *unitp = "KMGTPEZY";\r\nint i, units = 10;\r\nstruct per_process_info *pp_info = &io_extents->pp_extents[which];\r\nread_cum = 0;\r\nwrite_cum = 0;\r\nstart = 0;\r\nfor (i = 0; i < LL_HIST_MAX; i++) {\r\nread_tot += pp_info->pp_r_hist.oh_buckets[i];\r\nwrite_tot += pp_info->pp_w_hist.oh_buckets[i];\r\n}\r\nfor (i = 0; i < LL_HIST_MAX; i++) {\r\nr = pp_info->pp_r_hist.oh_buckets[i];\r\nw = pp_info->pp_w_hist.oh_buckets[i];\r\nread_cum += r;\r\nwrite_cum += w;\r\nend = 1 << (i + LL_HIST_START - units);\r\nseq_printf(seq, "%4lu%c - %4lu%c%c: %14lu %4lu %4lu | %14lu %4lu %4lu\n",\r\nstart, *unitp, end, *unitp,\r\n(i == LL_HIST_MAX - 1) ? '+' : ' ',\r\nr, pct(r, read_tot), pct(read_cum, read_tot),\r\nw, pct(w, write_tot), pct(write_cum, write_tot));\r\nstart = end;\r\nif (start == 1<<10) {\r\nstart = 1;\r\nunits += 10;\r\nunitp++;\r\n}\r\nif (read_cum == read_tot && write_cum == write_tot)\r\nbreak;\r\n}\r\n}\r\nstatic int ll_rw_extents_stats_pp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timeval now;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nint k;\r\ndo_gettimeofday(&now);\r\nif (!sbi->ll_rw_stats_on) {\r\nseq_printf(seq, "disabled\n"\r\n"write anything in this file to activate, then 0 or \"[D/d]isabled\" to deactivate\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "snapshot_time: %lu.%lu (secs.usecs)\n",\r\nnow.tv_sec, (unsigned long)now.tv_usec);\r\nseq_printf(seq, "%15s %19s | %20s\n", " ", "read", "write");\r\nseq_printf(seq, "%13s %14s %4s %4s | %14s %4s %4s\n",\r\n"extents", "calls", "%", "cum%",\r\n"calls", "%", "cum%");\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (k = 0; k < LL_PROCESS_HIST_MAX; k++) {\r\nif (io_extents->pp_extents[k].pid != 0) {\r\nseq_printf(seq, "\nPID: %d\n",\r\nio_extents->pp_extents[k].pid);\r\nll_display_extents_info(io_extents, seq, k);\r\n}\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_rw_extents_stats_pp_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len,\r\nloff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nint i;\r\nint value = 1, rc = 0;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nrc = lprocfs_write_helper(buf, len, &value);\r\nif (rc < 0 && len < 16) {\r\nchar kernbuf[16];\r\nif (copy_from_user(kernbuf, buf, len))\r\nreturn -EFAULT;\r\nkernbuf[len] = 0;\r\nif (kernbuf[len - 1] == '\n')\r\nkernbuf[len - 1] = 0;\r\nif (strcmp(kernbuf, "disabled") == 0 ||\r\nstrcmp(kernbuf, "Disabled") == 0)\r\nvalue = 0;\r\n}\r\nif (value == 0)\r\nsbi->ll_rw_stats_on = 0;\r\nelse\r\nsbi->ll_rw_stats_on = 1;\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nio_extents->pp_extents[i].pid = 0;\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_r_hist);\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_w_hist);\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nreturn len;\r\n}\r\nstatic int ll_rw_extents_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timeval now;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\ndo_gettimeofday(&now);\r\nif (!sbi->ll_rw_stats_on) {\r\nseq_printf(seq, "disabled\n"\r\n"write anything in this file to activate, then 0 or \"[D/d]isabled\" to deactivate\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "snapshot_time: %lu.%lu (secs.usecs)\n",\r\nnow.tv_sec, (unsigned long)now.tv_usec);\r\nseq_printf(seq, "%15s %19s | %20s\n", " ", "read", "write");\r\nseq_printf(seq, "%13s %14s %4s %4s | %14s %4s %4s\n",\r\n"extents", "calls", "%", "cum%",\r\n"calls", "%", "cum%");\r\nspin_lock(&sbi->ll_lock);\r\nll_display_extents_info(io_extents, seq, LL_PROCESS_HIST_MAX);\r\nspin_unlock(&sbi->ll_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_rw_extents_stats_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nint i;\r\nint value = 1, rc = 0;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nrc = lprocfs_write_helper(buf, len, &value);\r\nif (rc < 0 && len < 16) {\r\nchar kernbuf[16];\r\nif (copy_from_user(kernbuf, buf, len))\r\nreturn -EFAULT;\r\nkernbuf[len] = 0;\r\nif (kernbuf[len - 1] == '\n')\r\nkernbuf[len - 1] = 0;\r\nif (strcmp(kernbuf, "disabled") == 0 ||\r\nstrcmp(kernbuf, "Disabled") == 0)\r\nvalue = 0;\r\n}\r\nif (value == 0)\r\nsbi->ll_rw_stats_on = 0;\r\nelse\r\nsbi->ll_rw_stats_on = 1;\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (i = 0; i <= LL_PROCESS_HIST_MAX; i++) {\r\nio_extents->pp_extents[i].pid = 0;\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_r_hist);\r\nlprocfs_oh_clear(&io_extents->pp_extents[i].pp_w_hist);\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nreturn len;\r\n}\r\nvoid ll_rw_stats_tally(struct ll_sb_info *sbi, pid_t pid,\r\nstruct ll_file_data *file, loff_t pos,\r\nsize_t count, int rw)\r\n{\r\nint i, cur = -1;\r\nstruct ll_rw_process_info *process;\r\nstruct ll_rw_process_info *offset;\r\nint *off_count = &sbi->ll_rw_offset_entry_count;\r\nint *process_count = &sbi->ll_offset_process_count;\r\nstruct ll_rw_extents_info *io_extents = &sbi->ll_rw_extents_info;\r\nif (!sbi->ll_rw_stats_on)\r\nreturn;\r\nprocess = sbi->ll_rw_process_info;\r\noffset = sbi->ll_rw_offset_info;\r\nspin_lock(&sbi->ll_pp_extent_lock);\r\nfor (i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nif (io_extents->pp_extents[i].pid == pid) {\r\ncur = i;\r\nbreak;\r\n}\r\n}\r\nif (cur == -1) {\r\nsbi->ll_extent_process_count =\r\n(sbi->ll_extent_process_count + 1) % LL_PROCESS_HIST_MAX;\r\ncur = sbi->ll_extent_process_count;\r\nio_extents->pp_extents[cur].pid = pid;\r\nlprocfs_oh_clear(&io_extents->pp_extents[cur].pp_r_hist);\r\nlprocfs_oh_clear(&io_extents->pp_extents[cur].pp_w_hist);\r\n}\r\nfor(i = 0; (count >= (1 << LL_HIST_START << i)) &&\r\n(i < (LL_HIST_MAX - 1)); i++);\r\nif (rw == 0) {\r\nio_extents->pp_extents[cur].pp_r_hist.oh_buckets[i]++;\r\nio_extents->pp_extents[LL_PROCESS_HIST_MAX].pp_r_hist.oh_buckets[i]++;\r\n} else {\r\nio_extents->pp_extents[cur].pp_w_hist.oh_buckets[i]++;\r\nio_extents->pp_extents[LL_PROCESS_HIST_MAX].pp_w_hist.oh_buckets[i]++;\r\n}\r\nspin_unlock(&sbi->ll_pp_extent_lock);\r\nspin_lock(&sbi->ll_process_lock);\r\nfor (i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nif (process[i].rw_pid == pid) {\r\nif (process[i].rw_last_file != file) {\r\nprocess[i].rw_range_start = pos;\r\nprocess[i].rw_last_file_pos = pos + count;\r\nprocess[i].rw_smallest_extent = count;\r\nprocess[i].rw_largest_extent = count;\r\nprocess[i].rw_offset = 0;\r\nprocess[i].rw_last_file = file;\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn;\r\n}\r\nif (process[i].rw_last_file_pos != pos) {\r\n*off_count =\r\n(*off_count + 1) % LL_OFFSET_HIST_MAX;\r\noffset[*off_count].rw_op = process[i].rw_op;\r\noffset[*off_count].rw_pid = pid;\r\noffset[*off_count].rw_range_start =\r\nprocess[i].rw_range_start;\r\noffset[*off_count].rw_range_end =\r\nprocess[i].rw_last_file_pos;\r\noffset[*off_count].rw_smallest_extent =\r\nprocess[i].rw_smallest_extent;\r\noffset[*off_count].rw_largest_extent =\r\nprocess[i].rw_largest_extent;\r\noffset[*off_count].rw_offset =\r\nprocess[i].rw_offset;\r\nprocess[i].rw_op = rw;\r\nprocess[i].rw_range_start = pos;\r\nprocess[i].rw_smallest_extent = count;\r\nprocess[i].rw_largest_extent = count;\r\nprocess[i].rw_offset = pos -\r\nprocess[i].rw_last_file_pos;\r\n}\r\nif (process[i].rw_smallest_extent > count)\r\nprocess[i].rw_smallest_extent = count;\r\nif (process[i].rw_largest_extent < count)\r\nprocess[i].rw_largest_extent = count;\r\nprocess[i].rw_last_file_pos = pos + count;\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn;\r\n}\r\n}\r\n*process_count = (*process_count + 1) % LL_PROCESS_HIST_MAX;\r\nprocess[*process_count].rw_pid = pid;\r\nprocess[*process_count].rw_op = rw;\r\nprocess[*process_count].rw_range_start = pos;\r\nprocess[*process_count].rw_last_file_pos = pos + count;\r\nprocess[*process_count].rw_smallest_extent = count;\r\nprocess[*process_count].rw_largest_extent = count;\r\nprocess[*process_count].rw_offset = 0;\r\nprocess[*process_count].rw_last_file = file;\r\nspin_unlock(&sbi->ll_process_lock);\r\n}\r\nstatic int ll_rw_offset_stats_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timeval now;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_process_info *offset = sbi->ll_rw_offset_info;\r\nstruct ll_rw_process_info *process = sbi->ll_rw_process_info;\r\nint i;\r\ndo_gettimeofday(&now);\r\nif (!sbi->ll_rw_stats_on) {\r\nseq_printf(seq, "disabled\n"\r\n"write anything in this file to activate, then 0 or \"[D/d]isabled\" to deactivate\n");\r\nreturn 0;\r\n}\r\nspin_lock(&sbi->ll_process_lock);\r\nseq_printf(seq, "snapshot_time: %lu.%lu (secs.usecs)\n",\r\nnow.tv_sec, (unsigned long)now.tv_usec);\r\nseq_printf(seq, "%3s %10s %14s %14s %17s %17s %14s\n",\r\n"R/W", "PID", "RANGE START", "RANGE END",\r\n"SMALLEST EXTENT", "LARGEST EXTENT", "OFFSET");\r\nfor (i = 0; i < LL_OFFSET_HIST_MAX; i++) {\r\nif (offset[i].rw_pid != 0)\r\nseq_printf(seq,\r\n"%3c %10d %14Lu %14Lu %17lu %17lu %14Lu",\r\noffset[i].rw_op == READ ? 'R' : 'W',\r\noffset[i].rw_pid,\r\noffset[i].rw_range_start,\r\noffset[i].rw_range_end,\r\n(unsigned long)offset[i].rw_smallest_extent,\r\n(unsigned long)offset[i].rw_largest_extent,\r\noffset[i].rw_offset);\r\n}\r\nfor (i = 0; i < LL_PROCESS_HIST_MAX; i++) {\r\nif (process[i].rw_pid != 0)\r\nseq_printf(seq,\r\n"%3c %10d %14Lu %14Lu %17lu %17lu %14Lu",\r\nprocess[i].rw_op == READ ? 'R' : 'W',\r\nprocess[i].rw_pid,\r\nprocess[i].rw_range_start,\r\nprocess[i].rw_last_file_pos,\r\n(unsigned long)process[i].rw_smallest_extent,\r\n(unsigned long)process[i].rw_largest_extent,\r\nprocess[i].rw_offset);\r\n}\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ll_rw_offset_stats_seq_write(struct file *file,\r\nconst char __user *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ll_sb_info *sbi = seq->private;\r\nstruct ll_rw_process_info *process_info = sbi->ll_rw_process_info;\r\nstruct ll_rw_process_info *offset_info = sbi->ll_rw_offset_info;\r\nint value = 1, rc = 0;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nrc = lprocfs_write_helper(buf, len, &value);\r\nif (rc < 0 && len < 16) {\r\nchar kernbuf[16];\r\nif (copy_from_user(kernbuf, buf, len))\r\nreturn -EFAULT;\r\nkernbuf[len] = 0;\r\nif (kernbuf[len - 1] == '\n')\r\nkernbuf[len - 1] = 0;\r\nif (strcmp(kernbuf, "disabled") == 0 ||\r\nstrcmp(kernbuf, "Disabled") == 0)\r\nvalue = 0;\r\n}\r\nif (value == 0)\r\nsbi->ll_rw_stats_on = 0;\r\nelse\r\nsbi->ll_rw_stats_on = 1;\r\nspin_lock(&sbi->ll_process_lock);\r\nsbi->ll_offset_process_count = 0;\r\nsbi->ll_rw_offset_entry_count = 0;\r\nmemset(process_info, 0, sizeof(struct ll_rw_process_info) *\r\nLL_PROCESS_HIST_MAX);\r\nmemset(offset_info, 0, sizeof(struct ll_rw_process_info) *\r\nLL_OFFSET_HIST_MAX);\r\nspin_unlock(&sbi->ll_process_lock);\r\nreturn len;\r\n}\r\nvoid lprocfs_llite_init_vars(struct lprocfs_static_vars *lvars)\r\n{\r\nlvars->obd_vars = lprocfs_llite_obd_vars;\r\n}
