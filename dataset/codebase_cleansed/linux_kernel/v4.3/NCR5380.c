static inline void initialize_SCp(struct scsi_cmnd *cmd)\r\n{\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.buffers_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\n}\r\n}\r\nstatic int NCR5380_poll_politely(struct Scsi_Host *instance, int reg, int bit, int val, int t)\r\n{\r\nNCR5380_local_declare();\r\nint n = 500;\r\nunsigned long end = jiffies + t;\r\nint r;\r\nNCR5380_setup(instance);\r\nwhile( n-- > 0)\r\n{\r\nr = NCR5380_read(reg);\r\nif((r & bit) == val)\r\nreturn 0;\r\ncpu_relax();\r\n}\r\nwhile(time_before(jiffies, end))\r\n{\r\nr = NCR5380_read(reg);\r\nif((r & bit) == val)\r\nreturn 0;\r\nif(!in_interrupt())\r\ncond_resched();\r\nelse\r\ncpu_relax();\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void NCR5380_print(struct Scsi_Host *instance)\r\n{\r\nNCR5380_local_declare();\r\nunsigned char status, data, basr, mr, icr, i;\r\nNCR5380_setup(instance);\r\ndata = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\nstatus = NCR5380_read(STATUS_REG);\r\nmr = NCR5380_read(MODE_REG);\r\nicr = NCR5380_read(INITIATOR_COMMAND_REG);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nprintk("STATUS_REG: %02x ", status);\r\nfor (i = 0; signals[i].mask; ++i)\r\nif (status & signals[i].mask)\r\nprintk(",%s", signals[i].name);\r\nprintk("\nBASR: %02x ", basr);\r\nfor (i = 0; basrs[i].mask; ++i)\r\nif (basr & basrs[i].mask)\r\nprintk(",%s", basrs[i].name);\r\nprintk("\nICR: %02x ", icr);\r\nfor (i = 0; icrs[i].mask; ++i)\r\nif (icr & icrs[i].mask)\r\nprintk(",%s", icrs[i].name);\r\nprintk("\nMODE: %02x ", mr);\r\nfor (i = 0; mrs[i].mask; ++i)\r\nif (mr & mrs[i].mask)\r\nprintk(",%s", mrs[i].name);\r\nprintk("\n");\r\n}\r\nstatic void NCR5380_print_phase(struct Scsi_Host *instance)\r\n{\r\nNCR5380_local_declare();\r\nunsigned char status;\r\nint i;\r\nNCR5380_setup(instance);\r\nstatus = NCR5380_read(STATUS_REG);\r\nif (!(status & SR_REQ))\r\nprintk("scsi%d : REQ not asserted, phase unknown.\n", instance->host_no);\r\nelse {\r\nfor (i = 0; (phases[i].value != PHASE_UNKNOWN) && (phases[i].value != (status & PHASE_MASK)); ++i);\r\nprintk("scsi%d : phase %s\n", instance->host_no, phases[i].name);\r\n}\r\n}\r\nstatic int should_disconnect(unsigned char cmd)\r\n{\r\nswitch (cmd) {\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase SEEK_6:\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase SEEK_10:\r\nreturn DISCONNECT_TIME_TO_DATA;\r\ncase FORMAT_UNIT:\r\ncase SEARCH_HIGH:\r\ncase SEARCH_LOW:\r\ncase SEARCH_EQUAL:\r\nreturn DISCONNECT_LONG;\r\ndefault:\r\nreturn DISCONNECT_NONE;\r\n}\r\n}\r\nstatic void NCR5380_set_timer(struct NCR5380_hostdata *hostdata, unsigned long timeout)\r\n{\r\nhostdata->time_expires = jiffies + timeout;\r\nschedule_delayed_work(&hostdata->coroutine, timeout);\r\n}\r\nstatic irqreturn_t __init probe_intr(int irq, void *dev_id)\r\n{\r\nprobe_irq = irq;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init __maybe_unused NCR5380_probe_irq(struct Scsi_Host *instance,\r\nint possible)\r\n{\r\nNCR5380_local_declare();\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nunsigned long timeout;\r\nint trying_irqs, i, mask;\r\nNCR5380_setup(instance);\r\nfor (trying_irqs = 0, i = 1, mask = 2; i < 16; ++i, mask <<= 1)\r\nif ((mask & possible) && (request_irq(i, &probe_intr, 0, "NCR-probe", NULL) == 0))\r\ntrying_irqs |= mask;\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nprobe_irq = NO_IRQ;\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_SEL);\r\nwhile (probe_irq == NO_IRQ && time_before(jiffies, timeout))\r\nschedule_timeout_uninterruptible(1);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nfor (i = 1, mask = 2; i < 16; ++i, mask <<= 1)\r\nif (trying_irqs & mask)\r\nfree_irq(i, NULL);\r\nreturn probe_irq;\r\n}\r\nstatic const char *NCR5380_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nreturn hostdata->info;\r\n}\r\nstatic void prepare_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nsnprintf(hostdata->info, sizeof(hostdata->info),\r\n"%s, io_port 0x%lx, n_io_port %d, "\r\n"base 0x%lx, irq %d, "\r\n"can_queue %d, cmd_per_lun %d, "\r\n"sg_tablesize %d, this_id %d, "\r\n"flags { %s%s%s}, "\r\n#if defined(USLEEP_POLL) && defined(USLEEP_WAITLONG)\r\n"USLEEP_POLL %lu, USLEEP_WAITLONG %lu, "\r\n#endif\r\n"options { %s} ",\r\ninstance->hostt->name, instance->io_port, instance->n_io_port,\r\ninstance->base, instance->irq,\r\ninstance->can_queue, instance->cmd_per_lun,\r\ninstance->sg_tablesize, instance->this_id,\r\nhostdata->flags & FLAG_NCR53C400 ? "NCR53C400 " : "",\r\nhostdata->flags & FLAG_DTC3181E ? "DTC3181E " : "",\r\nhostdata->flags & FLAG_NO_PSEUDO_DMA ? "NO_PSEUDO_DMA " : "",\r\n#if defined(USLEEP_POLL) && defined(USLEEP_WAITLONG)\r\nUSLEEP_POLL, USLEEP_WAITLONG,\r\n#endif\r\n#ifdef AUTOPROBE_IRQ\r\n"AUTOPROBE_IRQ "\r\n#endif\r\n#ifdef DIFFERENTIAL\r\n"DIFFERENTIAL "\r\n#endif\r\n#ifdef REAL_DMA\r\n"REAL_DMA "\r\n#endif\r\n#ifdef REAL_DMA_POLL\r\n"REAL_DMA_POLL "\r\n#endif\r\n#ifdef PARITY\r\n"PARITY "\r\n#endif\r\n#ifdef PSEUDO_DMA\r\n"PSEUDO_DMA "\r\n#endif\r\n#ifdef UNSAFE\r\n"UNSAFE "\r\n#endif\r\n#ifdef NCR53C400\r\n"NCR53C400 "\r\n#endif\r\n"");\r\n}\r\nstatic void NCR5380_print_status(struct Scsi_Host *instance)\r\n{\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_dprint_phase(NDEBUG_ANY, instance);\r\n}\r\nstatic int __maybe_unused NCR5380_write_info(struct Scsi_Host *instance,\r\nchar *buffer, int length)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nhostdata->spin_max_r = 0;\r\nhostdata->spin_max_w = 0;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused NCR5380_show_info(struct seq_file *m,\r\nstruct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata;\r\nstruct scsi_cmnd *ptr;\r\nhostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\n#ifdef PSEUDO_DMA\r\nseq_printf(m, "Highwater I/O busy spin counts: write %d, read %d\n",\r\nhostdata->spin_max_w, hostdata->spin_max_r);\r\n#endif\r\nspin_lock_irq(instance->host_lock);\r\nif (!hostdata->connected)\r\nseq_printf(m, "scsi%d: no currently connected command\n", instance->host_no);\r\nelse\r\nlprint_Scsi_Cmnd((struct scsi_cmnd *) hostdata->connected, m);\r\nseq_printf(m, "scsi%d: issue_queue\n", instance->host_no);\r\nfor (ptr = (struct scsi_cmnd *) hostdata->issue_queue; ptr; ptr = (struct scsi_cmnd *) ptr->host_scribble)\r\nlprint_Scsi_Cmnd(ptr, m);\r\nseq_printf(m, "scsi%d: disconnected_queue\n", instance->host_no);\r\nfor (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr; ptr = (struct scsi_cmnd *) ptr->host_scribble)\r\nlprint_Scsi_Cmnd(ptr, m);\r\nspin_unlock_irq(instance->host_lock);\r\nreturn 0;\r\n}\r\nstatic void lprint_Scsi_Cmnd(struct scsi_cmnd *cmd, struct seq_file *m)\r\n{\r\nseq_printf(m, "scsi%d : destination target %d, lun %llu\n", cmd->device->host->host_no, cmd->device->id, cmd->device->lun);\r\nseq_puts(m, " command = ");\r\nlprint_command(cmd->cmnd, m);\r\n}\r\nstatic void lprint_command(unsigned char *command, struct seq_file *m)\r\n{\r\nint i, s;\r\nlprint_opcode(command[0], m);\r\nfor (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)\r\nseq_printf(m, "%02x ", command[i]);\r\nseq_putc(m, '\n');\r\n}\r\nstatic void lprint_opcode(int opcode, struct seq_file *m)\r\n{\r\nseq_printf(m, "%2d (0x%02x)", opcode, opcode);\r\n}\r\nstatic int NCR5380_init(struct Scsi_Host *instance, int flags)\r\n{\r\nNCR5380_local_declare();\r\nint i, pass;\r\nunsigned long timeout;\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nif(in_interrupt())\r\nprintk(KERN_ERR "NCR5380_init called with interrupts off!\n");\r\n#ifdef NCR53C400\r\nif (flags & FLAG_NCR53C400)\r\ninstance->NCR5380_instance_name += NCR53C400_address_adjust;\r\n#endif\r\nNCR5380_setup(instance);\r\nhostdata->aborted = 0;\r\nhostdata->id_mask = 1 << instance->this_id;\r\nfor (i = hostdata->id_mask; i <= 0x80; i <<= 1)\r\nif (i > hostdata->id_mask)\r\nhostdata->id_higher_mask |= i;\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\n#ifdef REAL_DMA\r\nhostdata->dmalen = 0;\r\n#endif\r\nhostdata->targets_present = 0;\r\nhostdata->connected = NULL;\r\nhostdata->issue_queue = NULL;\r\nhostdata->disconnected_queue = NULL;\r\nINIT_DELAYED_WORK(&hostdata->coroutine, NCR5380_main);\r\nif (flags & FLAG_NCR53C400)\r\nhostdata->flags = FLAG_HAS_LAST_BYTE_SENT | flags;\r\nelse\r\nhostdata->flags = FLAG_CHECK_LAST_BYTE_SENT | flags;\r\nhostdata->host = instance;\r\nhostdata->time_expires = 0;\r\nprepare_info(instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\n#ifdef NCR53C400\r\nif (hostdata->flags & FLAG_NCR53C400) {\r\nNCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);\r\n}\r\n#endif\r\nfor (pass = 1; (NCR5380_read(STATUS_REG) & SR_BSY) && pass <= 6; ++pass) {\r\nswitch (pass) {\r\ncase 1:\r\ncase 3:\r\ncase 5:\r\nprintk(KERN_INFO "scsi%d: SCSI bus busy, waiting up to five seconds\n", instance->host_no);\r\ntimeout = jiffies + 5 * HZ;\r\nNCR5380_poll_politely(instance, STATUS_REG, SR_BSY, 0, 5*HZ);\r\nbreak;\r\ncase 2:\r\nprintk(KERN_WARNING "scsi%d: bus busy, attempting abort\n", instance->host_no);\r\ndo_abort(instance);\r\nbreak;\r\ncase 4:\r\nprintk(KERN_WARNING "scsi%d: bus busy, attempting reset\n", instance->host_no);\r\ndo_reset(instance);\r\nbreak;\r\ncase 6:\r\nprintk(KERN_ERR "scsi%d: bus locked solid or invalid override\n", instance->host_no);\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void NCR5380_exit(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\ncancel_delayed_work_sync(&hostdata->coroutine);\r\n}\r\nstatic int NCR5380_queue_command_lck(struct scsi_cmnd *cmd, void (*done) (struct scsi_cmnd *))\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nstruct scsi_cmnd *tmp;\r\n#if (NDEBUG & NDEBUG_NO_WRITE)\r\nswitch (cmd->cmnd[0]) {\r\ncase WRITE_6:\r\ncase WRITE_10:\r\nprintk("scsi%d : WRITE attempted with NO_WRITE debugging flag set\n", instance->host_no);\r\ncmd->result = (DID_ERROR << 16);\r\ndone(cmd);\r\nreturn 0;\r\n}\r\n#endif\r\ncmd->host_scribble = NULL;\r\ncmd->scsi_done = done;\r\ncmd->result = 0;\r\nif (!(hostdata->issue_queue) || (cmd->cmnd[0] == REQUEST_SENSE)) {\r\nLIST(cmd, hostdata->issue_queue);\r\ncmd->host_scribble = (unsigned char *) hostdata->issue_queue;\r\nhostdata->issue_queue = cmd;\r\n} else {\r\nfor (tmp = (struct scsi_cmnd *) hostdata->issue_queue; tmp->host_scribble; tmp = (struct scsi_cmnd *) tmp->host_scribble);\r\nLIST(cmd, tmp);\r\ntmp->host_scribble = (unsigned char *) cmd;\r\n}\r\ndprintk(NDEBUG_QUEUES, "scsi%d : command added to %s of queue\n", instance->host_no, (cmd->cmnd[0] == REQUEST_SENSE) ? "head" : "tail");\r\nschedule_delayed_work(&hostdata->coroutine, 0);\r\nreturn 0;\r\n}\r\nirqreturn_t NCR5380_intr(int dummy, void *dev_id)\r\n{\r\nNCR5380_local_declare();\r\nstruct Scsi_Host *instance = dev_id;\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nint done;\r\nunsigned char basr;\r\nunsigned long flags;\r\ndprintk(NDEBUG_INTR, "scsi : NCR5380 irq %d triggered\n",\r\ninstance->irq);\r\ndo {\r\ndone = 1;\r\nspin_lock_irqsave(instance->host_lock, flags);\r\nNCR5380_setup(instance);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nif (basr & BASR_IRQ) {\r\nNCR5380_dprint(NDEBUG_INTR, instance);\r\nif ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == (SR_SEL | SR_IO)) {\r\ndone = 0;\r\ndprintk(NDEBUG_INTR, "scsi%d : SEL interrupt\n", instance->host_no);\r\nNCR5380_reselect(instance);\r\n(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else if (basr & BASR_PARITY_ERROR) {\r\ndprintk(NDEBUG_INTR, "scsi%d : PARITY interrupt\n", instance->host_no);\r\n(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else if ((NCR5380_read(STATUS_REG) & SR_RST) == SR_RST) {\r\ndprintk(NDEBUG_INTR, "scsi%d : RESET interrupt\n", instance->host_no);\r\n(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else {\r\n#if defined(REAL_DMA)\r\nif ((NCR5380_read(MODE_REG) & MR_DMA) && ((basr & BASR_END_DMA_TRANSFER) || !(basr & BASR_PHASE_MATCH))) {\r\nint transferred;\r\nif (!hostdata->connected)\r\npanic("scsi%d : received end of DMA interrupt with no connected cmd\n", instance->hostno);\r\ntransferred = (hostdata->dmalen - NCR5380_dma_residual(instance));\r\nhostdata->connected->SCp.this_residual -= transferred;\r\nhostdata->connected->SCp.ptr += transferred;\r\nhostdata->dmalen = 0;\r\n(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nNCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG, BASR_ACK, 0, 2*HZ);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n}\r\n#else\r\ndprintk(NDEBUG_INTR, "scsi : unknown interrupt, BASR 0x%X, MR 0x%X, SR 0x%x\n", basr, NCR5380_read(MODE_REG), NCR5380_read(STATUS_REG));\r\n(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n#endif\r\n}\r\n}\r\nspin_unlock_irqrestore(instance->host_lock, flags);\r\nif(!done)\r\nschedule_delayed_work(&hostdata->coroutine, 0);\r\n} while (!done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd)\r\n{\r\nNCR5380_local_declare();\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nunsigned char tmp[3], phase;\r\nunsigned char *data;\r\nint len;\r\nunsigned long timeout;\r\nunsigned char value;\r\nint err;\r\nNCR5380_setup(instance);\r\nif (hostdata->selecting)\r\ngoto part2;\r\nhostdata->restart_select = 0;\r\nNCR5380_dprint(NDEBUG_ARBITRATION, instance);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d : starting arbitration, id = %d\n", instance->host_no, instance->this_id);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\r\nNCR5380_write(MODE_REG, MR_ARBITRATE);\r\nspin_unlock_irq(instance->host_lock);\r\nerr = NCR5380_poll_politely(instance, INITIATOR_COMMAND_REG, ICR_ARBITRATION_PROGRESS, ICR_ARBITRATION_PROGRESS, 5*HZ);\r\nspin_lock_irq(instance->host_lock);\r\nif (err < 0) {\r\nprintk(KERN_DEBUG "scsi: arbitration timeout at %d\n", __LINE__);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\ngoto failed;\r\n}\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d : arbitration complete\n", instance->host_no);\r\nudelay(3);\r\nif ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) || (NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_higher_mask) || (NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST)) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d : lost arbitration, deasserting MR_ARBITRATE\n", instance->host_no);\r\ngoto failed;\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_SEL);\r\nif (!(hostdata->flags & FLAG_DTC3181E) &&\r\n(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST)) {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d : lost arbitration, deasserting ICR_ASSERT_SEL\n", instance->host_no);\r\ngoto failed;\r\n}\r\nudelay(2);\r\ndprintk(NDEBUG_ARBITRATION, "scsi%d : won arbitration\n", instance->host_no);\r\nNCR5380_write(OUTPUT_DATA_REG, (hostdata->id_mask | (1 << scmd_id(cmd))));\r\nNCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_BSY | ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL));\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nudelay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL));\r\nudelay(1);\r\ndprintk(NDEBUG_SELECTION, "scsi%d : selecting target %d\n", instance->host_no, scmd_id(cmd));\r\ntimeout = jiffies + msecs_to_jiffies(250);\r\nhostdata->select_time = 0;\r\nhostdata->selecting = cmd;\r\npart2:\r\nvalue = NCR5380_read(STATUS_REG) & (SR_BSY | SR_IO);\r\nif (!value && (hostdata->select_time < HZ/4)) {\r\nhostdata->select_time++;\r\nNCR5380_set_timer(hostdata, 1);\r\nreturn 0;\r\n}\r\nhostdata->selecting = NULL;\r\nif ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == (SR_SEL | SR_IO)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_reselect(instance);\r\nprintk("scsi%d : reselection after won arbitration?\n", instance->host_no);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn -1;\r\n}\r\nudelay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nif (!(NCR5380_read(STATUS_REG) & SR_BSY)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif (hostdata->targets_present & (1 << scmd_id(cmd))) {\r\nprintk(KERN_DEBUG "scsi%d : weirdness\n", instance->host_no);\r\nif (hostdata->restart_select)\r\nprintk(KERN_DEBUG "\trestart select\n");\r\nNCR5380_dprint(NDEBUG_SELECTION, instance);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn -1;\r\n}\r\ncmd->result = DID_BAD_TARGET << 16;\r\ncmd->scsi_done(cmd);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\ndprintk(NDEBUG_SELECTION, "scsi%d : target did not respond within 250ms\n", instance->host_no);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\nreturn 0;\r\n}\r\nhostdata->targets_present |= (1 << scmd_id(cmd));\r\nspin_unlock_irq(instance->host_lock);\r\nerr = NCR5380_poll_politely(instance, STATUS_REG, SR_REQ, SR_REQ, HZ);\r\nspin_lock_irq(instance->host_lock);\r\nif(err) {\r\nprintk(KERN_ERR "scsi%d: timeout at NCR5380.c:%d\n", instance->host_no, __LINE__);\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\ngoto failed;\r\n}\r\ndprintk(NDEBUG_SELECTION, "scsi%d : target %d selected, going into MESSAGE OUT phase.\n", instance->host_no, cmd->device->id);\r\ntmp[0] = IDENTIFY(((instance->irq == NO_IRQ) ? 0 : 1), cmd->device->lun);\r\nlen = 1;\r\ncmd->tag = 0;\r\ndata = tmp;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\ndprintk(NDEBUG_SELECTION, "scsi%d : nexus established.\n", instance->host_no);\r\nhostdata->connected = cmd;\r\nhostdata->busy[cmd->device->id] |= (1 << (cmd->device->lun & 0xFF));\r\ninitialize_SCp(cmd);\r\nreturn 0;\r\nfailed:\r\nreturn -1;\r\n}\r\nstatic int NCR5380_transfer_pio(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data) {\r\nNCR5380_local_declare();\r\nunsigned char p = *phase, tmp;\r\nint c = *count;\r\nunsigned char *d = *data;\r\nint break_allowed = 0;\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nNCR5380_setup(instance);\r\nif (!(p & SR_IO))\r\ndprintk(NDEBUG_PIO, "scsi%d : pio write %d bytes\n", instance->host_no, c);\r\nelse\r\ndprintk(NDEBUG_PIO, "scsi%d : pio read %d bytes\n", instance->host_no, c);\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\nif ((p == PHASE_DATAIN) || (p == PHASE_DATAOUT)) {\r\nbreak_allowed = 1;\r\n}\r\ndo {\r\nwhile (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ) && !break_allowed);\r\nif (!(tmp & SR_REQ)) {\r\nNCR5380_set_timer(hostdata, USLEEP_SLEEP);\r\nbreak;\r\n}\r\ndprintk(NDEBUG_HANDSHAKE, "scsi%d : REQ detected\n", instance->host_no);\r\nif ((tmp & PHASE_MASK) != p) {\r\ndprintk(NDEBUG_HANDSHAKE, "scsi%d : phase mismatch\n", instance->host_no);\r\nNCR5380_dprint_phase(NDEBUG_HANDSHAKE, instance);\r\nbreak;\r\n}\r\nif (!(p & SR_IO))\r\nNCR5380_write(OUTPUT_DATA_REG, *d);\r\nelse\r\n*d = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n++d;\r\nif (!(p & SR_IO)) {\r\nif (!((p & SR_MSG) && c > 1)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_ACK);\r\n} else {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_ATN);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\n}\r\n} else {\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n}\r\nNCR5380_poll_politely(instance, STATUS_REG, SR_REQ, 0, 5*HZ);\r\ndprintk(NDEBUG_HANDSHAKE, "scsi%d : req false, handshake complete\n", instance->host_no);\r\nif (!(p == PHASE_MSGIN && c == 1)) {\r\nif (p == PHASE_MSGOUT && c > 1)\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nelse\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n}\r\n} while (--c);\r\ndprintk(NDEBUG_PIO, "scsi%d : residual %d\n", instance->host_no, c);\r\n*count = c;\r\n*data = d;\r\ntmp = NCR5380_read(STATUS_REG);\r\nif (tmp & SR_REQ)\r\n*phase = tmp & PHASE_MASK;\r\nelse\r\n*phase = PHASE_UNKNOWN;\r\nif (!c || (*phase == p))\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic void do_reset(struct Scsi_Host *host) {\r\nNCR5380_local_declare();\r\nNCR5380_setup(host);\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG) & PHASE_MASK));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);\r\nudelay(25);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n}\r\nstatic int do_abort(struct Scsi_Host *host) {\r\nNCR5380_local_declare();\r\nunsigned char *msgptr, phase, tmp;\r\nint len;\r\nint rc;\r\nNCR5380_setup(host);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nrc = NCR5380_poll_politely(host, STATUS_REG, SR_REQ, SR_REQ, 60 * HZ);\r\nif(rc < 0)\r\nreturn -1;\r\ntmp = (unsigned char)rc;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\r\nif ((tmp & PHASE_MASK) != PHASE_MSGOUT) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\nrc = NCR5380_poll_politely(host, STATUS_REG, SR_REQ, 0, 3*HZ);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nif(rc == -1)\r\nreturn -1;\r\n}\r\ntmp = ABORT;\r\nmsgptr = &tmp;\r\nlen = 1;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(host, &phase, &len, &msgptr);\r\nreturn len ? -1 : 0;\r\n}\r\nstatic int NCR5380_transfer_dma(struct Scsi_Host *instance, unsigned char *phase, int *count, unsigned char **data) {\r\nNCR5380_local_declare();\r\nregister int c = *count;\r\nregister unsigned char p = *phase;\r\nregister unsigned char *d = *data;\r\nunsigned char tmp;\r\nint foo;\r\n#if defined(REAL_DMA_POLL)\r\nint cnt, toPIO;\r\nunsigned char saved_data = 0, overrun = 0, residue;\r\n#endif\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nNCR5380_setup(instance);\r\nif ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {\r\n*phase = tmp;\r\nreturn -1;\r\n}\r\n#if defined(REAL_DMA) || defined(REAL_DMA_POLL)\r\n#ifdef READ_OVERRUNS\r\nif (p & SR_IO) {\r\nc -= 2;\r\n}\r\n#endif\r\ndprintk(NDEBUG_DMA, "scsi%d : initializing DMA channel %d for %s, %d bytes %s %0x\n", instance->host_no, instance->dma_channel, (p & SR_IO) ? "reading" : "writing", c, (p & SR_IO) ? "to" : "from", (unsigned) d);\r\nhostdata->dma_len = (p & SR_IO) ? NCR5380_dma_read_setup(instance, d, c) : NCR5380_dma_write_setup(instance, d, c);\r\n#endif\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\n#ifdef REAL_DMA\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_ENABLE_EOP_INTR | MR_MONITOR_BSY);\r\n#elif defined(REAL_DMA_POLL)\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE);\r\n#else\r\n#if defined(PSEUDO_DMA) && defined(UNSAFE)\r\nspin_unlock_irq(instance->host_lock);\r\n#endif\r\nif (hostdata->flags & FLAG_NCR53C400)\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE |\r\nMR_ENABLE_PAR_CHECK | MR_ENABLE_PAR_INTR |\r\nMR_ENABLE_EOP_INTR | MR_MONITOR_BSY);\r\nelse\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE);\r\n#endif\r\ndprintk(NDEBUG_DMA, "scsi%d : mode reg = 0x%X\n", instance->host_no, NCR5380_read(MODE_REG));\r\nif (p & SR_IO) {\r\nio_recovery_delay(1);\r\nNCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);\r\n} else {\r\nio_recovery_delay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nio_recovery_delay(1);\r\nNCR5380_write(START_DMA_SEND_REG, 0);\r\nio_recovery_delay(1);\r\n}\r\n#if defined(REAL_DMA_POLL)\r\ndo {\r\ntmp = NCR5380_read(BUS_AND_STATUS_REG);\r\n} while ((tmp & BASR_PHASE_MATCH) && !(tmp & (BASR_BUSY_ERROR | BASR_END_DMA_TRANSFER)));\r\nif (p & SR_IO) {\r\n#ifdef READ_OVERRUNS\r\nudelay(10);\r\nif (((NCR5380_read(BUS_AND_STATUS_REG) & (BASR_PHASE_MATCH | BASR_ACK)) == (BASR_PHASE_MATCH | BASR_ACK))) {\r\nsaved_data = NCR5380_read(INPUT_DATA_REGISTER);\r\noverrun = 1;\r\n}\r\n#endif\r\n} else {\r\nint limit = 100;\r\nwhile (((tmp = NCR5380_read(BUS_AND_STATUS_REG)) & BASR_ACK) || (NCR5380_read(STATUS_REG) & SR_REQ)) {\r\nif (!(tmp & BASR_PHASE_MATCH))\r\nbreak;\r\nif (--limit < 0)\r\nbreak;\r\n}\r\n}\r\ndprintk(NDEBUG_DMA, "scsi%d : polled DMA transfer complete, basr 0x%X, sr 0x%X\n", instance->host_no, tmp, NCR5380_read(STATUS_REG));\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nresidue = NCR5380_dma_residual(instance);\r\nc -= residue;\r\n*count -= c;\r\n*data += c;\r\n*phase = NCR5380_read(STATUS_REG) & PHASE_MASK;\r\n#ifdef READ_OVERRUNS\r\nif (*phase == p && (p & SR_IO) && residue == 0) {\r\nif (overrun) {\r\ndprintk(NDEBUG_DMA, "Got an input overrun, using saved byte\n");\r\n**data = saved_data;\r\n*data += 1;\r\n*count -= 1;\r\ncnt = toPIO = 1;\r\n} else {\r\nprintk("No overrun??\n");\r\ncnt = toPIO = 2;\r\n}\r\ndprintk(NDEBUG_DMA, "Doing %d-byte PIO to 0x%X\n", cnt, *data);\r\nNCR5380_transfer_pio(instance, phase, &cnt, data);\r\n*count -= toPIO - cnt;\r\n}\r\n#endif\r\ndprintk(NDEBUG_DMA, "Return with data ptr = 0x%X, count %d, last 0x%X, next 0x%X\n", *data, *count, *(*data + *count - 1), *(*data + *count));\r\nreturn 0;\r\n#elif defined(REAL_DMA)\r\nreturn 0;\r\n#else\r\nif (p & SR_IO) {\r\n#ifdef DMA_WORKS_RIGHT\r\nfoo = NCR5380_pread(instance, d, c);\r\n#else\r\nint diff = 1;\r\nif (hostdata->flags & FLAG_NCR53C400) {\r\ndiff = 0;\r\n}\r\nif (!(foo = NCR5380_pread(instance, d, c - diff))) {\r\nif (!(hostdata->flags & FLAG_NCR53C400)) {\r\nwhile (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_DRQ));\r\nwhile (NCR5380_read(STATUS_REG) & SR_REQ);\r\nd[c - 1] = NCR5380_read(INPUT_DATA_REG);\r\n}\r\n}\r\n#endif\r\n} else {\r\n#ifdef DMA_WORKS_RIGHT\r\nfoo = NCR5380_pwrite(instance, d, c);\r\n#else\r\nint timeout;\r\ndprintk(NDEBUG_C400_PWRITE, "About to pwrite %d bytes\n", c);\r\nif (!(foo = NCR5380_pwrite(instance, d, c))) {\r\nif (!(hostdata->flags & FLAG_HAS_LAST_BYTE_SENT)) {\r\ntimeout = 20000;\r\nwhile (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_DRQ) && (NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH));\r\nif (!timeout)\r\ndprintk(NDEBUG_LAST_BYTE_SENT, "scsi%d : timed out on last byte\n", instance->host_no);\r\nif (hostdata->flags & FLAG_CHECK_LAST_BYTE_SENT) {\r\nhostdata->flags &= ~FLAG_CHECK_LAST_BYTE_SENT;\r\nif (NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT) {\r\nhostdata->flags |= FLAG_HAS_LAST_BYTE_SENT;\r\ndprintk(NDEBUG_LAST_BYTE_SENT, "scsi%d : last byte sent works\n", instance->host_no);\r\n}\r\n}\r\n} else {\r\ndprintk(NDEBUG_C400_PWRITE, "Waiting for LASTBYTE\n");\r\nwhile (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT));\r\ndprintk(NDEBUG_C400_PWRITE, "Got LASTBYTE\n");\r\n}\r\n}\r\n#endif\r\n}\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif ((!(p & SR_IO)) && (hostdata->flags & FLAG_NCR53C400)) {\r\ndprintk(NDEBUG_C400_PWRITE, "53C400w: Checking for IRQ\n");\r\nif (NCR5380_read(BUS_AND_STATUS_REG) & BASR_IRQ) {\r\ndprintk(NDEBUG_C400_PWRITE, "53C400w: got it, reading reset interrupt reg\n");\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n} else {\r\nprintk("53C400w: IRQ NOT THERE!\n");\r\n}\r\n}\r\n*data = d + c;\r\n*count = 0;\r\n*phase = NCR5380_read(STATUS_REG) & PHASE_MASK;\r\n#if defined(PSEUDO_DMA) && defined(UNSAFE)\r\nspin_lock_irq(instance->host_lock);\r\n#endif\r\nreturn foo;\r\n#endif\r\n}\r\nstatic void NCR5380_reselect(struct Scsi_Host *instance) {\r\nNCR5380_local_declare();\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *)\r\ninstance->hostdata;\r\nunsigned char target_mask;\r\nunsigned char lun, phase;\r\nint len;\r\nunsigned char msg[3];\r\nunsigned char *data;\r\nstruct scsi_cmnd *tmp = NULL, *prev;\r\nint abort = 0;\r\nNCR5380_setup(instance);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nhostdata->restart_select = 1;\r\ntarget_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);\r\ndprintk(NDEBUG_SELECTION, "scsi%d : reselect\n", instance->host_no);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);\r\nif(NCR5380_poll_politely(instance, STATUS_REG, SR_SEL, 0, 2*HZ)<0)\r\nabort = 1;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif(NCR5380_poll_politely(instance, STATUS_REG, SR_REQ, SR_REQ, 2*HZ))\r\nabort = 1;\r\nlen = 1;\r\ndata = msg;\r\nphase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nif (!(msg[0] & 0x80)) {\r\nprintk(KERN_ERR "scsi%d : expecting IDENTIFY message, got ", instance->host_no);\r\nspi_print_msg(msg);\r\nabort = 1;\r\n} else {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nlun = (msg[0] & 0x07);\r\nfor (tmp = (struct scsi_cmnd *) hostdata->disconnected_queue, prev = NULL; tmp; prev = tmp, tmp = (struct scsi_cmnd *) tmp->host_scribble)\r\nif ((target_mask == (1 << tmp->device->id)) && (lun == (u8)tmp->device->lun)\r\n) {\r\nif (prev) {\r\nREMOVE(prev, prev->host_scribble, tmp, tmp->host_scribble);\r\nprev->host_scribble = tmp->host_scribble;\r\n} else {\r\nREMOVE(-1, hostdata->disconnected_queue, tmp, tmp->host_scribble);\r\nhostdata->disconnected_queue = (struct scsi_cmnd *) tmp->host_scribble;\r\n}\r\ntmp->host_scribble = NULL;\r\nbreak;\r\n}\r\nif (!tmp) {\r\nprintk(KERN_ERR "scsi%d : warning : target bitmask %02x lun %d not in disconnect_queue.\n", instance->host_no, target_mask, lun);\r\nabort = 1;\r\n}\r\n}\r\nif (abort) {\r\ndo_abort(instance);\r\n} else {\r\nhostdata->connected = tmp;\r\ndprintk(NDEBUG_RESELECTION, "scsi%d : nexus established, target = %d, lun = %llu, tag = %d\n", instance->host_no, tmp->device->id, tmp->device->lun, tmp->tag);\r\n}\r\n}\r\nstatic void NCR5380_dma_complete(NCR5380_instance * instance) {\r\nNCR5380_local_declare();\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nint transferred;\r\nNCR5380_setup(instance);\r\nNCR5380_poll_politely(instance, BUS_AND_STATUS_REG, BASR_ACK, 0, 5*HZ);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif (!(hostdata->connected->SCp.phase & SR_CD)) {\r\ntransferred = instance->dmalen - NCR5380_dma_residual();\r\nhostdata->connected->SCp.this_residual -= transferred;\r\nhostdata->connected->SCp.ptr += transferred;\r\n}\r\n}\r\nstatic int NCR5380_abort(struct scsi_cmnd *cmd)\r\n{\r\nNCR5380_local_declare();\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = (struct NCR5380_hostdata *) instance->hostdata;\r\nstruct scsi_cmnd *tmp, **prev;\r\nscmd_printk(KERN_WARNING, cmd, "aborting command\n");\r\nNCR5380_print_status(instance);\r\nNCR5380_setup(instance);\r\ndprintk(NDEBUG_ABORT, "scsi%d : abort called\n", instance->host_no);\r\ndprintk(NDEBUG_ABORT, " basr 0x%X, sr 0x%X\n", NCR5380_read(BUS_AND_STATUS_REG), NCR5380_read(STATUS_REG));\r\n#if 0\r\nif (hostdata->connected == cmd) {\r\ndprintk(NDEBUG_ABORT, "scsi%d : aborting connected command\n", instance->host_no);\r\nhostdata->aborted = 1;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_ATN);\r\nreturn SUCCESS;\r\n}\r\n#endif\r\ndprintk(NDEBUG_ABORT, "scsi%d : abort going into loop.\n", instance->host_no);\r\nfor (prev = (struct scsi_cmnd **) &(hostdata->issue_queue), tmp = (struct scsi_cmnd *) hostdata->issue_queue; tmp; prev = (struct scsi_cmnd **) &(tmp->host_scribble), tmp = (struct scsi_cmnd *) tmp->host_scribble)\r\nif (cmd == tmp) {\r\nREMOVE(5, *prev, tmp, tmp->host_scribble);\r\n(*prev) = (struct scsi_cmnd *) tmp->host_scribble;\r\ntmp->host_scribble = NULL;\r\ntmp->result = DID_ABORT << 16;\r\ndprintk(NDEBUG_ABORT, "scsi%d : abort removed command from issue queue.\n", instance->host_no);\r\ntmp->scsi_done(tmp);\r\nreturn SUCCESS;\r\n}\r\n#if (NDEBUG & NDEBUG_ABORT)\r\nelse if (prev == tmp)\r\nprintk(KERN_ERR "scsi%d : LOOP\n", instance->host_no);\r\n#endif\r\nif (hostdata->connected) {\r\ndprintk(NDEBUG_ABORT, "scsi%d : abort failed, command connected.\n", instance->host_no);\r\nreturn FAILED;\r\n}\r\nfor (tmp = (struct scsi_cmnd *) hostdata->disconnected_queue; tmp; tmp = (struct scsi_cmnd *) tmp->host_scribble)\r\nif (cmd == tmp) {\r\ndprintk(NDEBUG_ABORT, "scsi%d : aborting disconnected command.\n", instance->host_no);\r\nif (NCR5380_select(instance, cmd))\r\nreturn FAILED;\r\ndprintk(NDEBUG_ABORT, "scsi%d : nexus reestablished.\n", instance->host_no);\r\ndo_abort(instance);\r\nfor (prev = (struct scsi_cmnd **) &(hostdata->disconnected_queue), tmp = (struct scsi_cmnd *) hostdata->disconnected_queue; tmp; prev = (struct scsi_cmnd **) &(tmp->host_scribble), tmp = (struct scsi_cmnd *) tmp->host_scribble)\r\nif (cmd == tmp) {\r\nREMOVE(5, *prev, tmp, tmp->host_scribble);\r\n*prev = (struct scsi_cmnd *) tmp->host_scribble;\r\ntmp->host_scribble = NULL;\r\ntmp->result = DID_ABORT << 16;\r\ntmp->scsi_done(tmp);\r\nreturn SUCCESS;\r\n}\r\n}\r\nprintk(KERN_WARNING "scsi%d : warning : SCSI command probably completed successfully\n"\r\n" before abortion\n", instance->host_no);\r\nreturn FAILED;\r\n}\r\nstatic int NCR5380_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nNCR5380_local_declare();\r\nNCR5380_setup(instance);\r\nNCR5380_print_status(instance);\r\nspin_lock_irq(instance->host_lock);\r\ndo_reset(instance);\r\nspin_unlock_irq(instance->host_lock);\r\nreturn SUCCESS;\r\n}
