int rockchip_drm_dma_attach_device(struct drm_device *drm_dev,\r\nstruct device *dev)\r\n{\r\nstruct dma_iommu_mapping *mapping = drm_dev->dev->archdata.mapping;\r\nint ret;\r\nret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\ndma_set_max_seg_size(dev, DMA_BIT_MASK(32));\r\nreturn arm_iommu_attach_device(dev, mapping);\r\n}\r\nvoid rockchip_drm_dma_detach_device(struct drm_device *drm_dev,\r\nstruct device *dev)\r\n{\r\narm_iommu_detach_device(dev);\r\n}\r\nint rockchip_register_crtc_funcs(struct drm_device *dev,\r\nconst struct rockchip_crtc_funcs *crtc_funcs,\r\nint pipe)\r\n{\r\nstruct rockchip_drm_private *priv = dev->dev_private;\r\nif (pipe > ROCKCHIP_MAX_CRTC)\r\nreturn -EINVAL;\r\npriv->crtc_funcs[pipe] = crtc_funcs;\r\nreturn 0;\r\n}\r\nvoid rockchip_unregister_crtc_funcs(struct drm_device *dev, int pipe)\r\n{\r\nstruct rockchip_drm_private *priv = dev->dev_private;\r\nif (pipe > ROCKCHIP_MAX_CRTC)\r\nreturn;\r\npriv->crtc_funcs[pipe] = NULL;\r\n}\r\nstatic struct drm_crtc *rockchip_crtc_from_pipe(struct drm_device *drm,\r\nint pipe)\r\n{\r\nstruct drm_crtc *crtc;\r\nint i = 0;\r\nlist_for_each_entry(crtc, &drm->mode_config.crtc_list, head)\r\nif (i++ == pipe)\r\nreturn crtc;\r\nreturn NULL;\r\n}\r\nstatic int rockchip_drm_crtc_enable_vblank(struct drm_device *dev, int pipe)\r\n{\r\nstruct rockchip_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc = rockchip_crtc_from_pipe(dev, pipe);\r\nif (crtc && priv->crtc_funcs[pipe] &&\r\npriv->crtc_funcs[pipe]->enable_vblank)\r\nreturn priv->crtc_funcs[pipe]->enable_vblank(crtc);\r\nreturn 0;\r\n}\r\nstatic void rockchip_drm_crtc_disable_vblank(struct drm_device *dev, int pipe)\r\n{\r\nstruct rockchip_drm_private *priv = dev->dev_private;\r\nstruct drm_crtc *crtc = rockchip_crtc_from_pipe(dev, pipe);\r\nif (crtc && priv->crtc_funcs[pipe] &&\r\npriv->crtc_funcs[pipe]->enable_vblank)\r\npriv->crtc_funcs[pipe]->disable_vblank(crtc);\r\n}\r\nstatic int rockchip_drm_load(struct drm_device *drm_dev, unsigned long flags)\r\n{\r\nstruct rockchip_drm_private *private;\r\nstruct dma_iommu_mapping *mapping;\r\nstruct device *dev = drm_dev->dev;\r\nstruct drm_connector *connector;\r\nint ret;\r\nprivate = devm_kzalloc(drm_dev->dev, sizeof(*private), GFP_KERNEL);\r\nif (!private)\r\nreturn -ENOMEM;\r\ndrm_dev->dev_private = private;\r\ndrm_mode_config_init(drm_dev);\r\nrockchip_drm_mode_config_init(drm_dev);\r\ndev->dma_parms = devm_kzalloc(dev, sizeof(*dev->dma_parms),\r\nGFP_KERNEL);\r\nif (!dev->dma_parms) {\r\nret = -ENOMEM;\r\ngoto err_config_cleanup;\r\n}\r\nmapping = arm_iommu_create_mapping(&platform_bus_type, 0x00000000,\r\nSZ_2G);\r\nif (IS_ERR(mapping)) {\r\nret = PTR_ERR(mapping);\r\ngoto err_config_cleanup;\r\n}\r\nret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto err_release_mapping;\r\ndma_set_max_seg_size(dev, DMA_BIT_MASK(32));\r\nret = arm_iommu_attach_device(dev, mapping);\r\nif (ret)\r\ngoto err_release_mapping;\r\nret = component_bind_all(dev, drm_dev);\r\nif (ret)\r\ngoto err_detach_device;\r\nlist_for_each_entry(connector, &drm_dev->mode_config.connector_list,\r\nhead) {\r\nret = drm_connector_register(connector);\r\nif (ret) {\r\ndev_err(drm_dev->dev,\r\n"[CONNECTOR:%d:%s] drm_connector_register failed: %d\n",\r\nconnector->base.id,\r\nconnector->name, ret);\r\ngoto err_unbind;\r\n}\r\n}\r\ndrm_kms_helper_poll_init(drm_dev);\r\ndrm_dev->irq_enabled = true;\r\nret = drm_vblank_init(drm_dev, ROCKCHIP_MAX_CRTC);\r\nif (ret)\r\ngoto err_kms_helper_poll_fini;\r\ndrm_dev->vblank_disable_allowed = true;\r\nret = rockchip_drm_fbdev_init(drm_dev);\r\nif (ret)\r\ngoto err_vblank_cleanup;\r\nreturn 0;\r\nerr_vblank_cleanup:\r\ndrm_vblank_cleanup(drm_dev);\r\nerr_kms_helper_poll_fini:\r\ndrm_kms_helper_poll_fini(drm_dev);\r\nerr_unbind:\r\ncomponent_unbind_all(dev, drm_dev);\r\nerr_detach_device:\r\narm_iommu_detach_device(dev);\r\nerr_release_mapping:\r\narm_iommu_release_mapping(dev->archdata.mapping);\r\nerr_config_cleanup:\r\ndrm_mode_config_cleanup(drm_dev);\r\ndrm_dev->dev_private = NULL;\r\nreturn ret;\r\n}\r\nstatic int rockchip_drm_unload(struct drm_device *drm_dev)\r\n{\r\nstruct device *dev = drm_dev->dev;\r\nrockchip_drm_fbdev_fini(drm_dev);\r\ndrm_vblank_cleanup(drm_dev);\r\ndrm_kms_helper_poll_fini(drm_dev);\r\ncomponent_unbind_all(dev, drm_dev);\r\narm_iommu_detach_device(dev);\r\narm_iommu_release_mapping(dev->archdata.mapping);\r\ndrm_mode_config_cleanup(drm_dev);\r\ndrm_dev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nvoid rockchip_drm_lastclose(struct drm_device *dev)\r\n{\r\nstruct rockchip_drm_private *priv = dev->dev_private;\r\ndrm_fb_helper_restore_fbdev_mode_unlocked(&priv->fbdev_helper);\r\n}\r\nstatic int rockchip_drm_sys_suspend(struct device *dev)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(dev);\r\nstruct drm_connector *connector;\r\nif (!drm)\r\nreturn 0;\r\ndrm_modeset_lock_all(drm);\r\nlist_for_each_entry(connector, &drm->mode_config.connector_list, head) {\r\nint old_dpms = connector->dpms;\r\nif (connector->funcs->dpms)\r\nconnector->funcs->dpms(connector, DRM_MODE_DPMS_OFF);\r\nconnector->dpms = old_dpms;\r\n}\r\ndrm_modeset_unlock_all(drm);\r\nreturn 0;\r\n}\r\nstatic int rockchip_drm_sys_resume(struct device *dev)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(dev);\r\nstruct drm_connector *connector;\r\nenum drm_connector_status status;\r\nbool changed = false;\r\nif (!drm)\r\nreturn 0;\r\ndrm_modeset_lock_all(drm);\r\nlist_for_each_entry(connector, &drm->mode_config.connector_list, head) {\r\nint desired_mode = connector->dpms;\r\nconnector->dpms = DRM_MODE_DPMS_OFF;\r\nif (desired_mode == DRM_MODE_DPMS_ON) {\r\nstatus = connector->funcs->detect(connector, true);\r\nif (status == connector_status_disconnected) {\r\nconnector->encoder = NULL;\r\nconnector->status = status;\r\nchanged = true;\r\ncontinue;\r\n}\r\n}\r\nif (connector->funcs->dpms)\r\nconnector->funcs->dpms(connector, desired_mode);\r\n}\r\ndrm_modeset_unlock_all(drm);\r\ndrm_helper_resume_force_mode(drm);\r\nif (changed)\r\ndrm_kms_helper_hotplug_event(drm);\r\nreturn 0;\r\n}\r\nint rockchip_drm_encoder_get_mux_id(struct device_node *node,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct device_node *ep;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct of_endpoint endpoint;\r\nstruct device_node *port;\r\nint ret;\r\nif (!node || !crtc)\r\nreturn -EINVAL;\r\nfor_each_endpoint_of_node(node, ep) {\r\nport = of_graph_get_remote_port(ep);\r\nof_node_put(port);\r\nif (port == crtc->port) {\r\nret = of_graph_parse_endpoint(ep, &endpoint);\r\nof_node_put(ep);\r\nreturn ret ?: endpoint.id;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int compare_of(struct device *dev, void *data)\r\n{\r\nstruct device_node *np = data;\r\nreturn dev->of_node == np;\r\n}\r\nstatic void rockchip_add_endpoints(struct device *dev,\r\nstruct component_match **match,\r\nstruct device_node *port)\r\n{\r\nstruct device_node *ep, *remote;\r\nfor_each_child_of_node(port, ep) {\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote || !of_device_is_available(remote)) {\r\nof_node_put(remote);\r\ncontinue;\r\n} else if (!of_device_is_available(remote->parent)) {\r\ndev_warn(dev, "parent device of %s is not available\n",\r\nremote->full_name);\r\nof_node_put(remote);\r\ncontinue;\r\n}\r\ncomponent_match_add(dev, match, compare_of, remote);\r\nof_node_put(remote);\r\n}\r\n}\r\nstatic int rockchip_drm_bind(struct device *dev)\r\n{\r\nstruct drm_device *drm;\r\nint ret;\r\ndrm = drm_dev_alloc(&rockchip_drm_driver, dev);\r\nif (!drm)\r\nreturn -ENOMEM;\r\nret = drm_dev_set_unique(drm, "%s", dev_name(dev));\r\nif (ret)\r\ngoto err_free;\r\nret = drm_dev_register(drm, 0);\r\nif (ret)\r\ngoto err_free;\r\ndev_set_drvdata(dev, drm);\r\nreturn 0;\r\nerr_free:\r\ndrm_dev_unref(drm);\r\nreturn ret;\r\n}\r\nstatic void rockchip_drm_unbind(struct device *dev)\r\n{\r\nstruct drm_device *drm = dev_get_drvdata(dev);\r\ndrm_dev_unregister(drm);\r\ndrm_dev_unref(drm);\r\ndev_set_drvdata(dev, NULL);\r\n}\r\nstatic int rockchip_drm_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct component_match *match = NULL;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *port;\r\nint i;\r\nif (!np)\r\nreturn -ENODEV;\r\nfor (i = 0;; i++) {\r\nport = of_parse_phandle(np, "ports", i);\r\nif (!port)\r\nbreak;\r\nif (!of_device_is_available(port->parent)) {\r\nof_node_put(port);\r\ncontinue;\r\n}\r\ncomponent_match_add(dev, &match, compare_of, port->parent);\r\nof_node_put(port);\r\n}\r\nif (i == 0) {\r\ndev_err(dev, "missing 'ports' property\n");\r\nreturn -ENODEV;\r\n}\r\nif (!match) {\r\ndev_err(dev, "No available vop found for display-subsystem.\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0;; i++) {\r\nport = of_parse_phandle(np, "ports", i);\r\nif (!port)\r\nbreak;\r\nif (!of_device_is_available(port->parent)) {\r\nof_node_put(port);\r\ncontinue;\r\n}\r\nrockchip_add_endpoints(dev, &match, port);\r\nof_node_put(port);\r\n}\r\nreturn component_master_add_with_match(dev, &rockchip_drm_ops, match);\r\n}\r\nstatic int rockchip_drm_platform_remove(struct platform_device *pdev)\r\n{\r\ncomponent_master_del(&pdev->dev, &rockchip_drm_ops);\r\nreturn 0;\r\n}
