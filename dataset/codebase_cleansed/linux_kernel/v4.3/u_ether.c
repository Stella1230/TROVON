static inline int qlen(struct usb_gadget *gadget, unsigned qmult)\r\n{\r\nif (gadget_is_dualspeed(gadget) && (gadget->speed == USB_SPEED_HIGH ||\r\ngadget->speed == USB_SPEED_SUPER))\r\nreturn qmult * DEFAULT_QLEN;\r\nelse\r\nreturn DEFAULT_QLEN;\r\n}\r\nstatic int ueth_change_mtu(struct net_device *net, int new_mtu)\r\n{\r\nstruct eth_dev *dev = netdev_priv(net);\r\nunsigned long flags;\r\nint status = 0;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->port_usb)\r\nstatus = -EBUSY;\r\nelse if (new_mtu <= ETH_HLEN || new_mtu > ETH_FRAME_LEN)\r\nstatus = -ERANGE;\r\nelse\r\nnet->mtu = new_mtu;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic void eth_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *p)\r\n{\r\nstruct eth_dev *dev = netdev_priv(net);\r\nstrlcpy(p->driver, "g_ether", sizeof(p->driver));\r\nstrlcpy(p->version, UETH__VERSION, sizeof(p->version));\r\nstrlcpy(p->fw_version, dev->gadget->name, sizeof(p->fw_version));\r\nstrlcpy(p->bus_info, dev_name(&dev->gadget->dev), sizeof(p->bus_info));\r\n}\r\nstatic void defer_kevent(struct eth_dev *dev, int flag)\r\n{\r\nif (test_and_set_bit(flag, &dev->todo))\r\nreturn;\r\nif (!schedule_work(&dev->work))\r\nERROR(dev, "kevent %d may have been dropped\n", flag);\r\nelse\r\nDBG(dev, "kevent %d scheduled\n", flag);\r\n}\r\nstatic int\r\nrx_submit(struct eth_dev *dev, struct usb_request *req, gfp_t gfp_flags)\r\n{\r\nstruct sk_buff *skb;\r\nint retval = -ENOMEM;\r\nsize_t size = 0;\r\nstruct usb_ep *out;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->port_usb)\r\nout = dev->port_usb->out_ep;\r\nelse\r\nout = NULL;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!out)\r\nreturn -ENOTCONN;\r\nsize += sizeof(struct ethhdr) + dev->net->mtu + RX_EXTRA;\r\nsize += dev->port_usb->header_len;\r\nsize += out->maxpacket - 1;\r\nsize -= size % out->maxpacket;\r\nif (dev->port_usb->is_fixed)\r\nsize = max_t(size_t, size, dev->port_usb->fixed_out_len);\r\nskb = alloc_skb(size + NET_IP_ALIGN, gfp_flags);\r\nif (skb == NULL) {\r\nDBG(dev, "no rx skb\n");\r\ngoto enomem;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nreq->buf = skb->data;\r\nreq->length = size;\r\nreq->complete = rx_complete;\r\nreq->context = skb;\r\nretval = usb_ep_queue(out, req, gfp_flags);\r\nif (retval == -ENOMEM)\r\nenomem:\r\ndefer_kevent(dev, WORK_RX_MEMORY);\r\nif (retval) {\r\nDBG(dev, "rx submit --> %d\n", retval);\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nspin_lock_irqsave(&dev->req_lock, flags);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nspin_unlock_irqrestore(&dev->req_lock, flags);\r\n}\r\nreturn retval;\r\n}\r\nstatic void rx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct sk_buff *skb = req->context, *skb2;\r\nstruct eth_dev *dev = ep->driver_data;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nskb_put(skb, req->actual);\r\nif (dev->unwrap) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->port_usb) {\r\nstatus = dev->unwrap(dev->port_usb,\r\nskb,\r\n&dev->rx_frames);\r\n} else {\r\ndev_kfree_skb_any(skb);\r\nstatus = -ENOTCONN;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n} else {\r\nskb_queue_tail(&dev->rx_frames, skb);\r\n}\r\nskb = NULL;\r\nskb2 = skb_dequeue(&dev->rx_frames);\r\nwhile (skb2) {\r\nif (status < 0\r\n|| ETH_HLEN > skb2->len\r\n|| skb2->len > VLAN_ETH_FRAME_LEN) {\r\ndev->net->stats.rx_errors++;\r\ndev->net->stats.rx_length_errors++;\r\nDBG(dev, "rx length %d\n", skb2->len);\r\ndev_kfree_skb_any(skb2);\r\ngoto next_frame;\r\n}\r\nskb2->protocol = eth_type_trans(skb2, dev->net);\r\ndev->net->stats.rx_packets++;\r\ndev->net->stats.rx_bytes += skb2->len;\r\nstatus = netif_rx(skb2);\r\nnext_frame:\r\nskb2 = skb_dequeue(&dev->rx_frames);\r\n}\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nVDBG(dev, "rx shutdown, code %d\n", status);\r\ngoto quiesce;\r\ncase -ECONNABORTED:\r\nDBG(dev, "rx %s reset\n", ep->name);\r\ndefer_kevent(dev, WORK_RX_MEMORY);\r\nquiesce:\r\ndev_kfree_skb_any(skb);\r\ngoto clean;\r\ncase -EOVERFLOW:\r\ndev->net->stats.rx_over_errors++;\r\ndefault:\r\ndev->net->stats.rx_errors++;\r\nDBG(dev, "rx status %d\n", status);\r\nbreak;\r\n}\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nif (!netif_running(dev->net)) {\r\nclean:\r\nspin_lock(&dev->req_lock);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nspin_unlock(&dev->req_lock);\r\nreq = NULL;\r\n}\r\nif (req)\r\nrx_submit(dev, req, GFP_ATOMIC);\r\n}\r\nstatic int prealloc(struct list_head *list, struct usb_ep *ep, unsigned n)\r\n{\r\nunsigned i;\r\nstruct usb_request *req;\r\nif (!n)\r\nreturn -ENOMEM;\r\ni = n;\r\nlist_for_each_entry(req, list, list) {\r\nif (i-- == 0)\r\ngoto extra;\r\n}\r\nwhile (i--) {\r\nreq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (!req)\r\nreturn list_empty(list) ? -ENOMEM : 0;\r\nlist_add(&req->list, list);\r\n}\r\nreturn 0;\r\nextra:\r\nfor (;;) {\r\nstruct list_head *next;\r\nnext = req->list.next;\r\nlist_del(&req->list);\r\nusb_ep_free_request(ep, req);\r\nif (next == list)\r\nbreak;\r\nreq = container_of(next, struct usb_request, list);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alloc_requests(struct eth_dev *dev, struct gether *link, unsigned n)\r\n{\r\nint status;\r\nspin_lock(&dev->req_lock);\r\nstatus = prealloc(&dev->tx_reqs, link->in_ep, n);\r\nif (status < 0)\r\ngoto fail;\r\nstatus = prealloc(&dev->rx_reqs, link->out_ep, n);\r\nif (status < 0)\r\ngoto fail;\r\ngoto done;\r\nfail:\r\nDBG(dev, "can't alloc requests\n");\r\ndone:\r\nspin_unlock(&dev->req_lock);\r\nreturn status;\r\n}\r\nstatic void rx_fill(struct eth_dev *dev, gfp_t gfp_flags)\r\n{\r\nstruct usb_request *req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->req_lock, flags);\r\nwhile (!list_empty(&dev->rx_reqs)) {\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nspin_unlock_irqrestore(&dev->req_lock, flags);\r\nif (rx_submit(dev, req, gfp_flags) < 0) {\r\ndefer_kevent(dev, WORK_RX_MEMORY);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dev->req_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&dev->req_lock, flags);\r\n}\r\nstatic void eth_work(struct work_struct *work)\r\n{\r\nstruct eth_dev *dev = container_of(work, struct eth_dev, work);\r\nif (test_and_clear_bit(WORK_RX_MEMORY, &dev->todo)) {\r\nif (netif_running(dev->net))\r\nrx_fill(dev, GFP_KERNEL);\r\n}\r\nif (dev->todo)\r\nDBG(dev, "work done, flags = 0x%lx\n", dev->todo);\r\n}\r\nstatic void tx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct sk_buff *skb = req->context;\r\nstruct eth_dev *dev = ep->driver_data;\r\nswitch (req->status) {\r\ndefault:\r\ndev->net->stats.tx_errors++;\r\nVDBG(dev, "tx err %d\n", req->status);\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase 0:\r\ndev->net->stats.tx_bytes += skb->len;\r\n}\r\ndev->net->stats.tx_packets++;\r\nspin_lock(&dev->req_lock);\r\nlist_add(&req->list, &dev->tx_reqs);\r\nspin_unlock(&dev->req_lock);\r\ndev_kfree_skb_any(skb);\r\natomic_dec(&dev->tx_qlen);\r\nif (netif_carrier_ok(dev->net))\r\nnetif_wake_queue(dev->net);\r\n}\r\nstatic inline int is_promisc(u16 cdc_filter)\r\n{\r\nreturn cdc_filter & USB_CDC_PACKET_TYPE_PROMISCUOUS;\r\n}\r\nstatic netdev_tx_t eth_start_xmit(struct sk_buff *skb,\r\nstruct net_device *net)\r\n{\r\nstruct eth_dev *dev = netdev_priv(net);\r\nint length = 0;\r\nint retval;\r\nstruct usb_request *req = NULL;\r\nunsigned long flags;\r\nstruct usb_ep *in;\r\nu16 cdc_filter;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->port_usb) {\r\nin = dev->port_usb->in_ep;\r\ncdc_filter = dev->port_usb->cdc_filter;\r\n} else {\r\nin = NULL;\r\ncdc_filter = 0;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (skb && !in) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (skb && !is_promisc(cdc_filter)) {\r\nu8 *dest = skb->data;\r\nif (is_multicast_ether_addr(dest)) {\r\nu16 type;\r\nif (is_broadcast_ether_addr(dest))\r\ntype = USB_CDC_PACKET_TYPE_BROADCAST;\r\nelse\r\ntype = USB_CDC_PACKET_TYPE_ALL_MULTICAST;\r\nif (!(cdc_filter & type)) {\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&dev->req_lock, flags);\r\nif (list_empty(&dev->tx_reqs)) {\r\nspin_unlock_irqrestore(&dev->req_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nreq = container_of(dev->tx_reqs.next, struct usb_request, list);\r\nlist_del(&req->list);\r\nif (list_empty(&dev->tx_reqs))\r\nnetif_stop_queue(net);\r\nspin_unlock_irqrestore(&dev->req_lock, flags);\r\nif (dev->wrap) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->port_usb)\r\nskb = dev->wrap(dev->port_usb, skb);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!skb) {\r\nif (dev->port_usb->supports_multi_frame)\r\ngoto multiframe;\r\ngoto drop;\r\n}\r\n}\r\nlength = skb->len;\r\nreq->buf = skb->data;\r\nreq->context = skb;\r\nreq->complete = tx_complete;\r\nif (dev->port_usb->is_fixed &&\r\nlength == dev->port_usb->fixed_in_len &&\r\n(length % in->maxpacket) == 0)\r\nreq->zero = 0;\r\nelse\r\nreq->zero = 1;\r\nif (req->zero && !dev->zlp && (length % in->maxpacket) == 0)\r\nlength++;\r\nreq->length = length;\r\nif (gadget_is_dualspeed(dev->gadget))\r\nreq->no_interrupt = (dev->gadget->speed == USB_SPEED_HIGH ||\r\ndev->gadget->speed == USB_SPEED_SUPER)\r\n? ((atomic_read(&dev->tx_qlen) % dev->qmult) != 0)\r\n: 0;\r\nretval = usb_ep_queue(in, req, GFP_ATOMIC);\r\nswitch (retval) {\r\ndefault:\r\nDBG(dev, "tx queue err %d\n", retval);\r\nbreak;\r\ncase 0:\r\nnet->trans_start = jiffies;\r\natomic_inc(&dev->tx_qlen);\r\n}\r\nif (retval) {\r\ndev_kfree_skb_any(skb);\r\ndrop:\r\ndev->net->stats.tx_dropped++;\r\nmultiframe:\r\nspin_lock_irqsave(&dev->req_lock, flags);\r\nif (list_empty(&dev->tx_reqs))\r\nnetif_start_queue(net);\r\nlist_add(&req->list, &dev->tx_reqs);\r\nspin_unlock_irqrestore(&dev->req_lock, flags);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void eth_start(struct eth_dev *dev, gfp_t gfp_flags)\r\n{\r\nDBG(dev, "%s\n", __func__);\r\nrx_fill(dev, gfp_flags);\r\natomic_set(&dev->tx_qlen, 0);\r\nnetif_wake_queue(dev->net);\r\n}\r\nstatic int eth_open(struct net_device *net)\r\n{\r\nstruct eth_dev *dev = netdev_priv(net);\r\nstruct gether *link;\r\nDBG(dev, "%s\n", __func__);\r\nif (netif_carrier_ok(dev->net))\r\neth_start(dev, GFP_KERNEL);\r\nspin_lock_irq(&dev->lock);\r\nlink = dev->port_usb;\r\nif (link && link->open)\r\nlink->open(link);\r\nspin_unlock_irq(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int eth_stop(struct net_device *net)\r\n{\r\nstruct eth_dev *dev = netdev_priv(net);\r\nunsigned long flags;\r\nVDBG(dev, "%s\n", __func__);\r\nnetif_stop_queue(net);\r\nDBG(dev, "stop stats: rx/tx %ld/%ld, errs %ld/%ld\n",\r\ndev->net->stats.rx_packets, dev->net->stats.tx_packets,\r\ndev->net->stats.rx_errors, dev->net->stats.tx_errors\r\n);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->port_usb) {\r\nstruct gether *link = dev->port_usb;\r\nconst struct usb_endpoint_descriptor *in;\r\nconst struct usb_endpoint_descriptor *out;\r\nif (link->close)\r\nlink->close(link);\r\nin = link->in_ep->desc;\r\nout = link->out_ep->desc;\r\nusb_ep_disable(link->in_ep);\r\nusb_ep_disable(link->out_ep);\r\nif (netif_carrier_ok(net)) {\r\nDBG(dev, "host still using in/out endpoints\n");\r\nlink->in_ep->desc = in;\r\nlink->out_ep->desc = out;\r\nusb_ep_enable(link->in_ep);\r\nusb_ep_enable(link->out_ep);\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int get_ether_addr(const char *str, u8 *dev_addr)\r\n{\r\nif (str) {\r\nunsigned i;\r\nfor (i = 0; i < 6; i++) {\r\nunsigned char num;\r\nif ((*str == '.') || (*str == ':'))\r\nstr++;\r\nnum = hex_to_bin(*str++) << 4;\r\nnum |= hex_to_bin(*str++);\r\ndev_addr [i] = num;\r\n}\r\nif (is_valid_ether_addr(dev_addr))\r\nreturn 0;\r\n}\r\neth_random_addr(dev_addr);\r\nreturn 1;\r\n}\r\nstatic int get_ether_addr_str(u8 dev_addr[ETH_ALEN], char *str, int len)\r\n{\r\nif (len < 18)\r\nreturn -EINVAL;\r\nsnprintf(str, len, "%pM", dev_addr);\r\nreturn 18;\r\n}\r\nstruct eth_dev *gether_setup_name(struct usb_gadget *g,\r\nconst char *dev_addr, const char *host_addr,\r\nu8 ethaddr[ETH_ALEN], unsigned qmult, const char *netname)\r\n{\r\nstruct eth_dev *dev;\r\nstruct net_device *net;\r\nint status;\r\nnet = alloc_etherdev(sizeof *dev);\r\nif (!net)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev = netdev_priv(net);\r\nspin_lock_init(&dev->lock);\r\nspin_lock_init(&dev->req_lock);\r\nINIT_WORK(&dev->work, eth_work);\r\nINIT_LIST_HEAD(&dev->tx_reqs);\r\nINIT_LIST_HEAD(&dev->rx_reqs);\r\nskb_queue_head_init(&dev->rx_frames);\r\ndev->net = net;\r\ndev->qmult = qmult;\r\nsnprintf(net->name, sizeof(net->name), "%s%%d", netname);\r\nif (get_ether_addr(dev_addr, net->dev_addr))\r\ndev_warn(&g->dev,\r\n"using random %s ethernet address\n", "self");\r\nif (get_ether_addr(host_addr, dev->host_mac))\r\ndev_warn(&g->dev,\r\n"using random %s ethernet address\n", "host");\r\nif (ethaddr)\r\nmemcpy(ethaddr, dev->host_mac, ETH_ALEN);\r\nnet->netdev_ops = &eth_netdev_ops;\r\nnet->ethtool_ops = &ops;\r\ndev->gadget = g;\r\nSET_NETDEV_DEV(net, &g->dev);\r\nSET_NETDEV_DEVTYPE(net, &gadget_type);\r\nstatus = register_netdev(net);\r\nif (status < 0) {\r\ndev_dbg(&g->dev, "register_netdev failed, %d\n", status);\r\nfree_netdev(net);\r\ndev = ERR_PTR(status);\r\n} else {\r\nINFO(dev, "MAC %pM\n", net->dev_addr);\r\nINFO(dev, "HOST MAC %pM\n", dev->host_mac);\r\nnetif_carrier_off(net);\r\n}\r\nreturn dev;\r\n}\r\nstruct net_device *gether_setup_name_default(const char *netname)\r\n{\r\nstruct net_device *net;\r\nstruct eth_dev *dev;\r\nnet = alloc_etherdev(sizeof(*dev));\r\nif (!net)\r\nreturn ERR_PTR(-ENOMEM);\r\ndev = netdev_priv(net);\r\nspin_lock_init(&dev->lock);\r\nspin_lock_init(&dev->req_lock);\r\nINIT_WORK(&dev->work, eth_work);\r\nINIT_LIST_HEAD(&dev->tx_reqs);\r\nINIT_LIST_HEAD(&dev->rx_reqs);\r\nskb_queue_head_init(&dev->rx_frames);\r\ndev->net = net;\r\ndev->qmult = QMULT_DEFAULT;\r\nsnprintf(net->name, sizeof(net->name), "%s%%d", netname);\r\neth_random_addr(dev->dev_mac);\r\npr_warn("using random %s ethernet address\n", "self");\r\neth_random_addr(dev->host_mac);\r\npr_warn("using random %s ethernet address\n", "host");\r\nnet->netdev_ops = &eth_netdev_ops;\r\nnet->ethtool_ops = &ops;\r\nSET_NETDEV_DEVTYPE(net, &gadget_type);\r\nreturn net;\r\n}\r\nint gether_register_netdev(struct net_device *net)\r\n{\r\nstruct eth_dev *dev;\r\nstruct usb_gadget *g;\r\nstruct sockaddr sa;\r\nint status;\r\nif (!net->dev.parent)\r\nreturn -EINVAL;\r\ndev = netdev_priv(net);\r\ng = dev->gadget;\r\nstatus = register_netdev(net);\r\nif (status < 0) {\r\ndev_dbg(&g->dev, "register_netdev failed, %d\n", status);\r\nreturn status;\r\n} else {\r\nINFO(dev, "HOST MAC %pM\n", dev->host_mac);\r\nnetif_carrier_off(net);\r\n}\r\nsa.sa_family = net->type;\r\nmemcpy(sa.sa_data, dev->dev_mac, ETH_ALEN);\r\nrtnl_lock();\r\nstatus = dev_set_mac_address(net, &sa);\r\nrtnl_unlock();\r\nif (status)\r\npr_warn("cannot set self ethernet address: %d\n", status);\r\nelse\r\nINFO(dev, "MAC %pM\n", dev->dev_mac);\r\nreturn status;\r\n}\r\nvoid gether_set_gadget(struct net_device *net, struct usb_gadget *g)\r\n{\r\nstruct eth_dev *dev;\r\ndev = netdev_priv(net);\r\ndev->gadget = g;\r\nSET_NETDEV_DEV(net, &g->dev);\r\n}\r\nint gether_set_dev_addr(struct net_device *net, const char *dev_addr)\r\n{\r\nstruct eth_dev *dev;\r\nu8 new_addr[ETH_ALEN];\r\ndev = netdev_priv(net);\r\nif (get_ether_addr(dev_addr, new_addr))\r\nreturn -EINVAL;\r\nmemcpy(dev->dev_mac, new_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nint gether_get_dev_addr(struct net_device *net, char *dev_addr, int len)\r\n{\r\nstruct eth_dev *dev;\r\ndev = netdev_priv(net);\r\nreturn get_ether_addr_str(dev->dev_mac, dev_addr, len);\r\n}\r\nint gether_set_host_addr(struct net_device *net, const char *host_addr)\r\n{\r\nstruct eth_dev *dev;\r\nu8 new_addr[ETH_ALEN];\r\ndev = netdev_priv(net);\r\nif (get_ether_addr(host_addr, new_addr))\r\nreturn -EINVAL;\r\nmemcpy(dev->host_mac, new_addr, ETH_ALEN);\r\nreturn 0;\r\n}\r\nint gether_get_host_addr(struct net_device *net, char *host_addr, int len)\r\n{\r\nstruct eth_dev *dev;\r\ndev = netdev_priv(net);\r\nreturn get_ether_addr_str(dev->host_mac, host_addr, len);\r\n}\r\nint gether_get_host_addr_cdc(struct net_device *net, char *host_addr, int len)\r\n{\r\nstruct eth_dev *dev;\r\nif (len < 13)\r\nreturn -EINVAL;\r\ndev = netdev_priv(net);\r\nsnprintf(host_addr, len, "%pm", dev->host_mac);\r\nreturn strlen(host_addr);\r\n}\r\nvoid gether_get_host_addr_u8(struct net_device *net, u8 host_mac[ETH_ALEN])\r\n{\r\nstruct eth_dev *dev;\r\ndev = netdev_priv(net);\r\nmemcpy(host_mac, dev->host_mac, ETH_ALEN);\r\n}\r\nvoid gether_set_qmult(struct net_device *net, unsigned qmult)\r\n{\r\nstruct eth_dev *dev;\r\ndev = netdev_priv(net);\r\ndev->qmult = qmult;\r\n}\r\nunsigned gether_get_qmult(struct net_device *net)\r\n{\r\nstruct eth_dev *dev;\r\ndev = netdev_priv(net);\r\nreturn dev->qmult;\r\n}\r\nint gether_get_ifname(struct net_device *net, char *name, int len)\r\n{\r\nrtnl_lock();\r\nstrlcpy(name, netdev_name(net), len);\r\nrtnl_unlock();\r\nreturn strlen(name);\r\n}\r\nvoid gether_cleanup(struct eth_dev *dev)\r\n{\r\nif (!dev)\r\nreturn;\r\nunregister_netdev(dev->net);\r\nflush_work(&dev->work);\r\nfree_netdev(dev->net);\r\n}\r\nstruct net_device *gether_connect(struct gether *link)\r\n{\r\nstruct eth_dev *dev = link->ioport;\r\nint result = 0;\r\nif (!dev)\r\nreturn ERR_PTR(-EINVAL);\r\nlink->in_ep->driver_data = dev;\r\nresult = usb_ep_enable(link->in_ep);\r\nif (result != 0) {\r\nDBG(dev, "enable %s --> %d\n",\r\nlink->in_ep->name, result);\r\ngoto fail0;\r\n}\r\nlink->out_ep->driver_data = dev;\r\nresult = usb_ep_enable(link->out_ep);\r\nif (result != 0) {\r\nDBG(dev, "enable %s --> %d\n",\r\nlink->out_ep->name, result);\r\ngoto fail1;\r\n}\r\nif (result == 0)\r\nresult = alloc_requests(dev, link, qlen(dev->gadget,\r\ndev->qmult));\r\nif (result == 0) {\r\ndev->zlp = link->is_zlp_ok;\r\nDBG(dev, "qlen %d\n", qlen(dev->gadget, dev->qmult));\r\ndev->header_len = link->header_len;\r\ndev->unwrap = link->unwrap;\r\ndev->wrap = link->wrap;\r\nspin_lock(&dev->lock);\r\ndev->port_usb = link;\r\nif (netif_running(dev->net)) {\r\nif (link->open)\r\nlink->open(link);\r\n} else {\r\nif (link->close)\r\nlink->close(link);\r\n}\r\nspin_unlock(&dev->lock);\r\nnetif_carrier_on(dev->net);\r\nif (netif_running(dev->net))\r\neth_start(dev, GFP_ATOMIC);\r\n} else {\r\n(void) usb_ep_disable(link->out_ep);\r\nfail1:\r\n(void) usb_ep_disable(link->in_ep);\r\n}\r\nfail0:\r\nif (result < 0)\r\nreturn ERR_PTR(result);\r\nreturn dev->net;\r\n}\r\nvoid gether_disconnect(struct gether *link)\r\n{\r\nstruct eth_dev *dev = link->ioport;\r\nstruct usb_request *req;\r\nWARN_ON(!dev);\r\nif (!dev)\r\nreturn;\r\nDBG(dev, "%s\n", __func__);\r\nnetif_stop_queue(dev->net);\r\nnetif_carrier_off(dev->net);\r\nusb_ep_disable(link->in_ep);\r\nspin_lock(&dev->req_lock);\r\nwhile (!list_empty(&dev->tx_reqs)) {\r\nreq = container_of(dev->tx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nspin_unlock(&dev->req_lock);\r\nusb_ep_free_request(link->in_ep, req);\r\nspin_lock(&dev->req_lock);\r\n}\r\nspin_unlock(&dev->req_lock);\r\nlink->in_ep->driver_data = NULL;\r\nlink->in_ep->desc = NULL;\r\nusb_ep_disable(link->out_ep);\r\nspin_lock(&dev->req_lock);\r\nwhile (!list_empty(&dev->rx_reqs)) {\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nspin_unlock(&dev->req_lock);\r\nusb_ep_free_request(link->out_ep, req);\r\nspin_lock(&dev->req_lock);\r\n}\r\nspin_unlock(&dev->req_lock);\r\nlink->out_ep->driver_data = NULL;\r\nlink->out_ep->desc = NULL;\r\ndev->header_len = 0;\r\ndev->unwrap = NULL;\r\ndev->wrap = NULL;\r\nspin_lock(&dev->lock);\r\ndev->port_usb = NULL;\r\nspin_unlock(&dev->lock);\r\n}
