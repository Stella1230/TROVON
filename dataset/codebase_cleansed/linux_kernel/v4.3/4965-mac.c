void\r\nil4965_check_abort_status(struct il_priv *il, u8 frame_count, u32 status)\r\n{\r\nif (frame_count == 1 && status == TX_STATUS_FAIL_RFKILL_FLUSH) {\r\nIL_ERR("Tx flush command to flush out all frames\n");\r\nif (!test_bit(S_EXIT_PENDING, &il->status))\r\nqueue_work(il->workqueue, &il->tx_flush);\r\n}\r\n}\r\nvoid\r\nil4965_rx_queue_reset(struct il_priv *il, struct il_rx_queue *rxq)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nINIT_LIST_HEAD(&rxq->rx_free);\r\nINIT_LIST_HEAD(&rxq->rx_used);\r\nfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\r\nif (rxq->pool[i].page != NULL) {\r\npci_unmap_page(il->pci_dev, rxq->pool[i].page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__il_free_pages(il, rxq->pool[i].page);\r\nrxq->pool[i].page = NULL;\r\n}\r\nlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\r\n}\r\nfor (i = 0; i < RX_QUEUE_SIZE; i++)\r\nrxq->queue[i] = NULL;\r\nrxq->read = rxq->write = 0;\r\nrxq->write_actual = 0;\r\nrxq->free_count = 0;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\nint\r\nil4965_rx_init(struct il_priv *il, struct il_rx_queue *rxq)\r\n{\r\nu32 rb_size;\r\nconst u32 rfdnlog = RX_QUEUE_SIZE_LOG;\r\nu32 rb_timeout = 0;\r\nif (il->cfg->mod_params->amsdu_size_8K)\r\nrb_size = FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_8K;\r\nelse\r\nrb_size = FH49_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K;\r\nil_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG, 0);\r\nil_wr(il, FH49_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);\r\nil_wr(il, FH49_RSCSR_CHNL0_RBDCB_BASE_REG, (u32) (rxq->bd_dma >> 8));\r\nil_wr(il, FH49_RSCSR_CHNL0_STTS_WPTR_REG, rxq->rb_stts_dma >> 4);\r\nil_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG,\r\nFH49_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL |\r\nFH49_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL |\r\nFH49_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK |\r\nrb_size |\r\n(rb_timeout << FH49_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) |\r\n(rfdnlog << FH49_RCSR_RX_CONFIG_RBDCB_SIZE_POS));\r\nil_write8(il, CSR_INT_COALESCING, IL_HOST_INT_TIMEOUT_DEF);\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_set_pwr_vmain(struct il_priv *il)\r\n{\r\nil_set_bits_mask_prph(il, APMG_PS_CTRL_REG,\r\nAPMG_PS_CTRL_VAL_PWR_SRC_VMAIN,\r\n~APMG_PS_CTRL_MSK_PWR_SRC);\r\n}\r\nint\r\nil4965_hw_nic_init(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nint ret;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_apm_init(il);\r\nil_write8(il, CSR_INT_COALESCING, IL_HOST_INT_CALIB_TIMEOUT_DEF);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil4965_set_pwr_vmain(il);\r\nil4965_nic_config(il);\r\nif (!rxq->bd) {\r\nret = il_rx_queue_alloc(il);\r\nif (ret) {\r\nIL_ERR("Unable to initialize Rx queue\n");\r\nreturn -ENOMEM;\r\n}\r\n} else\r\nil4965_rx_queue_reset(il, rxq);\r\nil4965_rx_replenish(il);\r\nil4965_rx_init(il, rxq);\r\nspin_lock_irqsave(&il->lock, flags);\r\nrxq->need_update = 1;\r\nil_rx_queue_update_write_ptr(il, rxq);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nif (!il->txq) {\r\nret = il4965_txq_ctx_alloc(il);\r\nif (ret)\r\nreturn ret;\r\n} else\r\nil4965_txq_ctx_reset(il);\r\nset_bit(S_INIT, &il->status);\r\nreturn 0;\r\n}\r\nstatic inline __le32\r\nil4965_dma_addr2rbd_ptr(struct il_priv *il, dma_addr_t dma_addr)\r\n{\r\nreturn cpu_to_le32((u32) (dma_addr >> 8));\r\n}\r\nvoid\r\nil4965_rx_queue_restock(struct il_priv *il)\r\n{\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nstruct list_head *element;\r\nstruct il_rx_buf *rxb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nwhile (il_rx_queue_space(rxq) > 0 && rxq->free_count) {\r\nrxb = rxq->queue[rxq->write];\r\nBUG_ON(rxb && rxb->page);\r\nelement = rxq->rx_free.next;\r\nrxb = list_entry(element, struct il_rx_buf, list);\r\nlist_del(element);\r\nrxq->bd[rxq->write] =\r\nil4965_dma_addr2rbd_ptr(il, rxb->page_dma);\r\nrxq->queue[rxq->write] = rxb;\r\nrxq->write = (rxq->write + 1) & RX_QUEUE_MASK;\r\nrxq->free_count--;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count <= RX_LOW_WATERMARK)\r\nqueue_work(il->workqueue, &il->rx_replenish);\r\nif (rxq->write_actual != (rxq->write & ~0x7)) {\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nrxq->need_update = 1;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nil_rx_queue_update_write_ptr(il, rxq);\r\n}\r\n}\r\nstatic void\r\nil4965_rx_allocate(struct il_priv *il, gfp_t priority)\r\n{\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nstruct list_head *element;\r\nstruct il_rx_buf *rxb;\r\nstruct page *page;\r\ndma_addr_t page_dma;\r\nunsigned long flags;\r\ngfp_t gfp_mask = priority;\r\nwhile (1) {\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (list_empty(&rxq->rx_used)) {\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\nif (rxq->free_count > RX_LOW_WATERMARK)\r\ngfp_mask |= __GFP_NOWARN;\r\nif (il->hw_params.rx_page_order > 0)\r\ngfp_mask |= __GFP_COMP;\r\npage = alloc_pages(gfp_mask, il->hw_params.rx_page_order);\r\nif (!page) {\r\nif (net_ratelimit())\r\nD_INFO("alloc_pages failed, " "order: %d\n",\r\nil->hw_params.rx_page_order);\r\nif (rxq->free_count <= RX_LOW_WATERMARK &&\r\nnet_ratelimit())\r\nIL_ERR("Failed to alloc_pages with %s. "\r\n"Only %u free buffers remaining.\n",\r\npriority ==\r\nGFP_ATOMIC ? "GFP_ATOMIC" : "GFP_KERNEL",\r\nrxq->free_count);\r\nreturn;\r\n}\r\npage_dma =\r\npci_map_page(il->pci_dev, page, 0,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev, page_dma))) {\r\n__free_pages(page, il->hw_params.rx_page_order);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (list_empty(&rxq->rx_used)) {\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\npci_unmap_page(il->pci_dev, page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__free_pages(page, il->hw_params.rx_page_order);\r\nreturn;\r\n}\r\nelement = rxq->rx_used.next;\r\nrxb = list_entry(element, struct il_rx_buf, list);\r\nlist_del(element);\r\nBUG_ON(rxb->page);\r\nrxb->page = page;\r\nrxb->page_dma = page_dma;\r\nlist_add_tail(&rxb->list, &rxq->rx_free);\r\nrxq->free_count++;\r\nil->alloc_rxb_page++;\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\n}\r\n}\r\nvoid\r\nil4965_rx_replenish(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nil4965_rx_allocate(il, GFP_KERNEL);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil4965_rx_queue_restock(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\n}\r\nvoid\r\nil4965_rx_replenish_now(struct il_priv *il)\r\n{\r\nil4965_rx_allocate(il, GFP_ATOMIC);\r\nil4965_rx_queue_restock(il);\r\n}\r\nvoid\r\nil4965_rx_queue_free(struct il_priv *il, struct il_rx_queue *rxq)\r\n{\r\nint i;\r\nfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\r\nif (rxq->pool[i].page != NULL) {\r\npci_unmap_page(il->pci_dev, rxq->pool[i].page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\n__il_free_pages(il, rxq->pool[i].page);\r\nrxq->pool[i].page = NULL;\r\n}\r\n}\r\ndma_free_coherent(&il->pci_dev->dev, 4 * RX_QUEUE_SIZE, rxq->bd,\r\nrxq->bd_dma);\r\ndma_free_coherent(&il->pci_dev->dev, sizeof(struct il_rb_status),\r\nrxq->rb_stts, rxq->rb_stts_dma);\r\nrxq->bd = NULL;\r\nrxq->rb_stts = NULL;\r\n}\r\nint\r\nil4965_rxq_stop(struct il_priv *il)\r\n{\r\nint ret;\r\n_il_wr(il, FH49_MEM_RCSR_CHNL0_CONFIG_REG, 0);\r\nret = _il_poll_bit(il, FH49_MEM_RSSR_RX_STATUS_REG,\r\nFH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\r\nFH49_RSSR_CHNL0_RX_STATUS_CHNL_IDLE,\r\n1000);\r\nif (ret < 0)\r\nIL_ERR("Can't stop Rx DMA.\n");\r\nreturn 0;\r\n}\r\nint\r\nil4965_hwrate_to_mac80211_idx(u32 rate_n_flags, enum ieee80211_band band)\r\n{\r\nint idx = 0;\r\nint band_offset = 0;\r\nif (rate_n_flags & RATE_MCS_HT_MSK) {\r\nidx = (rate_n_flags & 0xff);\r\nreturn idx;\r\n} else {\r\nif (band == IEEE80211_BAND_5GHZ)\r\nband_offset = IL_FIRST_OFDM_RATE;\r\nfor (idx = band_offset; idx < RATE_COUNT_LEGACY; idx++)\r\nif (il_rates[idx].plcp == (rate_n_flags & 0xFF))\r\nreturn idx - band_offset;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nil4965_calc_rssi(struct il_priv *il, struct il_rx_phy_res *rx_resp)\r\n{\r\nstruct il4965_rx_non_cfg_phy *ncphy =\r\n(struct il4965_rx_non_cfg_phy *)rx_resp->non_cfg_phy_buf;\r\nu32 agc =\r\n(le16_to_cpu(ncphy->agc_info) & IL49_AGC_DB_MASK) >>\r\nIL49_AGC_DB_POS;\r\nu32 valid_antennae =\r\n(le16_to_cpu(rx_resp->phy_flags) & IL49_RX_PHY_FLAGS_ANTENNAE_MASK)\r\n>> IL49_RX_PHY_FLAGS_ANTENNAE_OFFSET;\r\nu8 max_rssi = 0;\r\nu32 i;\r\nfor (i = 0; i < 3; i++)\r\nif (valid_antennae & (1 << i))\r\nmax_rssi = max(ncphy->rssi_info[i << 1], max_rssi);\r\nD_STATS("Rssi In A %d B %d C %d Max %d AGC dB %d\n",\r\nncphy->rssi_info[0], ncphy->rssi_info[2], ncphy->rssi_info[4],\r\nmax_rssi, agc);\r\nreturn max_rssi - agc - IL4965_RSSI_OFFSET;\r\n}\r\nstatic u32\r\nil4965_translate_rx_status(struct il_priv *il, u32 decrypt_in)\r\n{\r\nu32 decrypt_out = 0;\r\nif ((decrypt_in & RX_RES_STATUS_STATION_FOUND) ==\r\nRX_RES_STATUS_STATION_FOUND)\r\ndecrypt_out |=\r\n(RX_RES_STATUS_STATION_FOUND |\r\nRX_RES_STATUS_NO_STATION_INFO_MISMATCH);\r\ndecrypt_out |= (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK);\r\nif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\r\nRX_RES_STATUS_SEC_TYPE_NONE)\r\nreturn decrypt_out;\r\nif ((decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) ==\r\nRX_RES_STATUS_SEC_TYPE_ERR)\r\nreturn decrypt_out;\r\nif ((decrypt_in & RX_MPDU_RES_STATUS_DEC_DONE_MSK) !=\r\nRX_MPDU_RES_STATUS_DEC_DONE_MSK)\r\nreturn decrypt_out;\r\nswitch (decrypt_in & RX_RES_STATUS_SEC_TYPE_MSK) {\r\ncase RX_RES_STATUS_SEC_TYPE_CCMP:\r\nif (!(decrypt_in & RX_MPDU_RES_STATUS_MIC_OK))\r\ndecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\r\nelse\r\ndecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\r\nbreak;\r\ncase RX_RES_STATUS_SEC_TYPE_TKIP:\r\nif (!(decrypt_in & RX_MPDU_RES_STATUS_TTAK_OK)) {\r\ndecrypt_out |= RX_RES_STATUS_BAD_KEY_TTAK;\r\nbreak;\r\n}\r\ndefault:\r\nif (!(decrypt_in & RX_MPDU_RES_STATUS_ICV_OK))\r\ndecrypt_out |= RX_RES_STATUS_BAD_ICV_MIC;\r\nelse\r\ndecrypt_out |= RX_RES_STATUS_DECRYPT_OK;\r\nbreak;\r\n}\r\nD_RX("decrypt_in:0x%x decrypt_out = 0x%x\n", decrypt_in, decrypt_out);\r\nreturn decrypt_out;\r\n}\r\nstatic void\r\nil4965_pass_packet_to_mac80211(struct il_priv *il, struct ieee80211_hdr *hdr,\r\nu32 len, u32 ampdu_status, struct il_rx_buf *rxb,\r\nstruct ieee80211_rx_status *stats)\r\n{\r\nstruct sk_buff *skb;\r\n__le16 fc = hdr->frame_control;\r\nif (unlikely(!il->is_open)) {\r\nD_DROP("Dropping packet while interface is not open.\n");\r\nreturn;\r\n}\r\nif (unlikely(test_bit(IL_STOP_REASON_PASSIVE, &il->stop_reason))) {\r\nil_wake_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\r\nD_INFO("Woke queues - frame received on passive channel\n");\r\n}\r\nif (!il->cfg->mod_params->sw_crypto &&\r\nil_set_decrypted_flag(il, hdr, ampdu_status, stats))\r\nreturn;\r\nskb = dev_alloc_skb(SMALL_PACKET_SIZE);\r\nif (!skb) {\r\nIL_ERR("dev_alloc_skb failed\n");\r\nreturn;\r\n}\r\nif (len <= SMALL_PACKET_SIZE) {\r\nmemcpy(skb_put(skb, len), hdr, len);\r\n} else {\r\nskb_add_rx_frag(skb, 0, rxb->page, (void *)hdr - rxb_addr(rxb),\r\nlen, PAGE_SIZE << il->hw_params.rx_page_order);\r\nil->alloc_rxb_page--;\r\nrxb->page = NULL;\r\n}\r\nil_update_stats(il, false, fc, len);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), stats, sizeof(*stats));\r\nieee80211_rx(il->hw, skb);\r\n}\r\nstatic void\r\nil4965_hdl_rx(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct ieee80211_hdr *header;\r\nstruct ieee80211_rx_status rx_status = {};\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il_rx_phy_res *phy_res;\r\n__le32 rx_pkt_status;\r\nstruct il_rx_mpdu_res_start *amsdu;\r\nu32 len;\r\nu32 ampdu_status;\r\nu32 rate_n_flags;\r\nif (pkt->hdr.cmd == N_RX) {\r\nphy_res = (struct il_rx_phy_res *)pkt->u.raw;\r\nheader =\r\n(struct ieee80211_hdr *)(pkt->u.raw + sizeof(*phy_res) +\r\nphy_res->cfg_phy_cnt);\r\nlen = le16_to_cpu(phy_res->byte_count);\r\nrx_pkt_status =\r\n*(__le32 *) (pkt->u.raw + sizeof(*phy_res) +\r\nphy_res->cfg_phy_cnt + len);\r\nampdu_status = le32_to_cpu(rx_pkt_status);\r\n} else {\r\nif (!il->_4965.last_phy_res_valid) {\r\nIL_ERR("MPDU frame without cached PHY data\n");\r\nreturn;\r\n}\r\nphy_res = &il->_4965.last_phy_res;\r\namsdu = (struct il_rx_mpdu_res_start *)pkt->u.raw;\r\nheader = (struct ieee80211_hdr *)(pkt->u.raw + sizeof(*amsdu));\r\nlen = le16_to_cpu(amsdu->byte_count);\r\nrx_pkt_status = *(__le32 *) (pkt->u.raw + sizeof(*amsdu) + len);\r\nampdu_status =\r\nil4965_translate_rx_status(il, le32_to_cpu(rx_pkt_status));\r\n}\r\nif ((unlikely(phy_res->cfg_phy_cnt > 20))) {\r\nD_DROP("dsp size out of range [0,20]: %d\n",\r\nphy_res->cfg_phy_cnt);\r\nreturn;\r\n}\r\nif (!(rx_pkt_status & RX_RES_STATUS_NO_CRC32_ERROR) ||\r\n!(rx_pkt_status & RX_RES_STATUS_NO_RXE_OVERFLOW)) {\r\nD_RX("Bad CRC or FIFO: 0x%08X.\n", le32_to_cpu(rx_pkt_status));\r\nreturn;\r\n}\r\nrate_n_flags = le32_to_cpu(phy_res->rate_n_flags);\r\nrx_status.mactime = le64_to_cpu(phy_res->timestamp);\r\nrx_status.band =\r\n(phy_res->\r\nphy_flags & RX_RES_PHY_FLAGS_BAND_24_MSK) ? IEEE80211_BAND_2GHZ :\r\nIEEE80211_BAND_5GHZ;\r\nrx_status.freq =\r\nieee80211_channel_to_frequency(le16_to_cpu(phy_res->channel),\r\nrx_status.band);\r\nrx_status.rate_idx =\r\nil4965_hwrate_to_mac80211_idx(rate_n_flags, rx_status.band);\r\nrx_status.flag = 0;\r\nil->ucode_beacon_time = le32_to_cpu(phy_res->beacon_time_stamp);\r\nrx_status.signal = il4965_calc_rssi(il, phy_res);\r\nD_STATS("Rssi %d, TSF %llu\n", rx_status.signal,\r\n(unsigned long long)rx_status.mactime);\r\nrx_status.antenna =\r\n(le16_to_cpu(phy_res->phy_flags) & RX_RES_PHY_FLAGS_ANTENNA_MSK) >>\r\nRX_RES_PHY_FLAGS_ANTENNA_POS;\r\nif (phy_res->phy_flags & RX_RES_PHY_FLAGS_SHORT_PREAMBLE_MSK)\r\nrx_status.flag |= RX_FLAG_SHORTPRE;\r\nif (rate_n_flags & RATE_MCS_HT_MSK)\r\nrx_status.flag |= RX_FLAG_HT;\r\nif (rate_n_flags & RATE_MCS_HT40_MSK)\r\nrx_status.flag |= RX_FLAG_40MHZ;\r\nif (rate_n_flags & RATE_MCS_SGI_MSK)\r\nrx_status.flag |= RX_FLAG_SHORT_GI;\r\nif (phy_res->phy_flags & RX_RES_PHY_FLAGS_AGG_MSK) {\r\nrx_status.flag |= RX_FLAG_AMPDU_DETAILS;\r\nrx_status.ampdu_reference = il->_4965.ampdu_ref;\r\n}\r\nil4965_pass_packet_to_mac80211(il, header, len, ampdu_status, rxb,\r\n&rx_status);\r\n}\r\nstatic void\r\nil4965_hdl_rx_phy(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nil->_4965.last_phy_res_valid = true;\r\nil->_4965.ampdu_ref++;\r\nmemcpy(&il->_4965.last_phy_res, pkt->u.raw,\r\nsizeof(struct il_rx_phy_res));\r\n}\r\nstatic int\r\nil4965_get_channels_for_scan(struct il_priv *il, struct ieee80211_vif *vif,\r\nenum ieee80211_band band, u8 is_active,\r\nu8 n_probes, struct il_scan_channel *scan_ch)\r\n{\r\nstruct ieee80211_channel *chan;\r\nconst struct ieee80211_supported_band *sband;\r\nconst struct il_channel_info *ch_info;\r\nu16 passive_dwell = 0;\r\nu16 active_dwell = 0;\r\nint added, i;\r\nu16 channel;\r\nsband = il_get_hw_mode(il, band);\r\nif (!sband)\r\nreturn 0;\r\nactive_dwell = il_get_active_dwell_time(il, band, n_probes);\r\npassive_dwell = il_get_passive_dwell_time(il, band, vif);\r\nif (passive_dwell <= active_dwell)\r\npassive_dwell = active_dwell + 1;\r\nfor (i = 0, added = 0; i < il->scan_request->n_channels; i++) {\r\nchan = il->scan_request->channels[i];\r\nif (chan->band != band)\r\ncontinue;\r\nchannel = chan->hw_value;\r\nscan_ch->channel = cpu_to_le16(channel);\r\nch_info = il_get_channel_info(il, band, channel);\r\nif (!il_is_channel_valid(ch_info)) {\r\nD_SCAN("Channel %d is INVALID for this band.\n",\r\nchannel);\r\ncontinue;\r\n}\r\nif (!is_active || il_is_channel_passive(ch_info) ||\r\n(chan->flags & IEEE80211_CHAN_NO_IR))\r\nscan_ch->type = SCAN_CHANNEL_TYPE_PASSIVE;\r\nelse\r\nscan_ch->type = SCAN_CHANNEL_TYPE_ACTIVE;\r\nif (n_probes)\r\nscan_ch->type |= IL_SCAN_PROBE_MASK(n_probes);\r\nscan_ch->active_dwell = cpu_to_le16(active_dwell);\r\nscan_ch->passive_dwell = cpu_to_le16(passive_dwell);\r\nscan_ch->dsp_atten = 110;\r\nif (band == IEEE80211_BAND_5GHZ)\r\nscan_ch->tx_gain = ((1 << 5) | (3 << 3)) | 3;\r\nelse\r\nscan_ch->tx_gain = ((1 << 5) | (5 << 3));\r\nD_SCAN("Scanning ch=%d prob=0x%X [%s %d]\n", channel,\r\nle32_to_cpu(scan_ch->type),\r\n(scan_ch->\r\ntype & SCAN_CHANNEL_TYPE_ACTIVE) ? "ACTIVE" : "PASSIVE",\r\n(scan_ch->\r\ntype & SCAN_CHANNEL_TYPE_ACTIVE) ? active_dwell :\r\npassive_dwell);\r\nscan_ch++;\r\nadded++;\r\n}\r\nD_SCAN("total channels to scan %d\n", added);\r\nreturn added;\r\n}\r\nstatic void\r\nil4965_toggle_tx_ant(struct il_priv *il, u8 *ant, u8 valid)\r\n{\r\nint i;\r\nu8 ind = *ant;\r\nfor (i = 0; i < RATE_ANT_NUM - 1; i++) {\r\nind = (ind + 1) < RATE_ANT_NUM ? ind + 1 : 0;\r\nif (valid & BIT(ind)) {\r\n*ant = ind;\r\nreturn;\r\n}\r\n}\r\n}\r\nint\r\nil4965_request_scan(struct il_priv *il, struct ieee80211_vif *vif)\r\n{\r\nstruct il_host_cmd cmd = {\r\n.id = C_SCAN,\r\n.len = sizeof(struct il_scan_cmd),\r\n.flags = CMD_SIZE_HUGE,\r\n};\r\nstruct il_scan_cmd *scan;\r\nu32 rate_flags = 0;\r\nu16 cmd_len;\r\nu16 rx_chain = 0;\r\nenum ieee80211_band band;\r\nu8 n_probes = 0;\r\nu8 rx_ant = il->hw_params.valid_rx_ant;\r\nu8 rate;\r\nbool is_active = false;\r\nint chan_mod;\r\nu8 active_chains;\r\nu8 scan_tx_antennas = il->hw_params.valid_tx_ant;\r\nint ret;\r\nlockdep_assert_held(&il->mutex);\r\nif (!il->scan_cmd) {\r\nil->scan_cmd =\r\nkmalloc(sizeof(struct il_scan_cmd) + IL_MAX_SCAN_SIZE,\r\nGFP_KERNEL);\r\nif (!il->scan_cmd) {\r\nD_SCAN("fail to allocate memory for scan\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nscan = il->scan_cmd;\r\nmemset(scan, 0, sizeof(struct il_scan_cmd) + IL_MAX_SCAN_SIZE);\r\nscan->quiet_plcp_th = IL_PLCP_QUIET_THRESH;\r\nscan->quiet_time = IL_ACTIVE_QUIET_TIME;\r\nif (il_is_any_associated(il)) {\r\nu16 interval;\r\nu32 extra;\r\nu32 suspend_time = 100;\r\nu32 scan_suspend_time = 100;\r\nD_INFO("Scanning while associated...\n");\r\ninterval = vif->bss_conf.beacon_int;\r\nscan->suspend_time = 0;\r\nscan->max_out_time = cpu_to_le32(200 * 1024);\r\nif (!interval)\r\ninterval = suspend_time;\r\nextra = (suspend_time / interval) << 22;\r\nscan_suspend_time =\r\n(extra | ((suspend_time % interval) * 1024));\r\nscan->suspend_time = cpu_to_le32(scan_suspend_time);\r\nD_SCAN("suspend_time 0x%X beacon interval %d\n",\r\nscan_suspend_time, interval);\r\n}\r\nif (il->scan_request->n_ssids) {\r\nint i, p = 0;\r\nD_SCAN("Kicking off active scan\n");\r\nfor (i = 0; i < il->scan_request->n_ssids; i++) {\r\nif (!il->scan_request->ssids[i].ssid_len)\r\ncontinue;\r\nscan->direct_scan[p].id = WLAN_EID_SSID;\r\nscan->direct_scan[p].len =\r\nil->scan_request->ssids[i].ssid_len;\r\nmemcpy(scan->direct_scan[p].ssid,\r\nil->scan_request->ssids[i].ssid,\r\nil->scan_request->ssids[i].ssid_len);\r\nn_probes++;\r\np++;\r\n}\r\nis_active = true;\r\n} else\r\nD_SCAN("Start passive scan.\n");\r\nscan->tx_cmd.tx_flags = TX_CMD_FLG_SEQ_CTL_MSK;\r\nscan->tx_cmd.sta_id = il->hw_params.bcast_id;\r\nscan->tx_cmd.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nswitch (il->scan_band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nscan->flags = RXON_FLG_BAND_24G_MSK | RXON_FLG_AUTO_DETECT_MSK;\r\nchan_mod =\r\nle32_to_cpu(il->active.flags & RXON_FLG_CHANNEL_MODE_MSK) >>\r\nRXON_FLG_CHANNEL_MODE_POS;\r\nif (chan_mod == CHANNEL_MODE_PURE_40) {\r\nrate = RATE_6M_PLCP;\r\n} else {\r\nrate = RATE_1M_PLCP;\r\nrate_flags = RATE_MCS_CCK_MSK;\r\n}\r\nbreak;\r\ncase IEEE80211_BAND_5GHZ:\r\nrate = RATE_6M_PLCP;\r\nbreak;\r\ndefault:\r\nIL_WARN("Invalid scan band\n");\r\nreturn -EIO;\r\n}\r\nscan->good_CRC_th =\r\nis_active ? IL_GOOD_CRC_TH_DEFAULT : IL_GOOD_CRC_TH_NEVER;\r\nband = il->scan_band;\r\nif (il->cfg->scan_rx_antennas[band])\r\nrx_ant = il->cfg->scan_rx_antennas[band];\r\nil4965_toggle_tx_ant(il, &il->scan_tx_ant[band], scan_tx_antennas);\r\nrate_flags |= BIT(il->scan_tx_ant[band]) << RATE_MCS_ANT_POS;\r\nscan->tx_cmd.rate_n_flags = cpu_to_le32(rate | rate_flags);\r\nif (test_bit(S_POWER_PMI, &il->status)) {\r\nactive_chains =\r\nrx_ant & ((u8) (il->chain_noise_data.active_chains));\r\nif (!active_chains)\r\nactive_chains = rx_ant;\r\nD_SCAN("chain_noise_data.active_chains: %u\n",\r\nil->chain_noise_data.active_chains);\r\nrx_ant = il4965_first_antenna(active_chains);\r\n}\r\nrx_chain |= il->hw_params.valid_rx_ant << RXON_RX_CHAIN_VALID_POS;\r\nrx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_MIMO_SEL_POS;\r\nrx_chain |= rx_ant << RXON_RX_CHAIN_FORCE_SEL_POS;\r\nrx_chain |= 0x1 << RXON_RX_CHAIN_DRIVER_FORCE_POS;\r\nscan->rx_chain = cpu_to_le16(rx_chain);\r\ncmd_len =\r\nil_fill_probe_req(il, (struct ieee80211_mgmt *)scan->data,\r\nvif->addr, il->scan_request->ie,\r\nil->scan_request->ie_len,\r\nIL_MAX_SCAN_SIZE - sizeof(*scan));\r\nscan->tx_cmd.len = cpu_to_le16(cmd_len);\r\nscan->filter_flags |=\r\n(RXON_FILTER_ACCEPT_GRP_MSK | RXON_FILTER_BCON_AWARE_MSK);\r\nscan->channel_count =\r\nil4965_get_channels_for_scan(il, vif, band, is_active, n_probes,\r\n(void *)&scan->data[cmd_len]);\r\nif (scan->channel_count == 0) {\r\nD_SCAN("channel count %d\n", scan->channel_count);\r\nreturn -EIO;\r\n}\r\ncmd.len +=\r\nle16_to_cpu(scan->tx_cmd.len) +\r\nscan->channel_count * sizeof(struct il_scan_channel);\r\ncmd.data = scan;\r\nscan->len = cpu_to_le16(cmd.len);\r\nset_bit(S_SCAN_HW, &il->status);\r\nret = il_send_cmd_sync(il, &cmd);\r\nif (ret)\r\nclear_bit(S_SCAN_HW, &il->status);\r\nreturn ret;\r\n}\r\nint\r\nil4965_manage_ibss_station(struct il_priv *il, struct ieee80211_vif *vif,\r\nbool add)\r\n{\r\nstruct il_vif_priv *vif_priv = (void *)vif->drv_priv;\r\nif (add)\r\nreturn il4965_add_bssid_station(il, vif->bss_conf.bssid,\r\n&vif_priv->ibss_bssid_sta_id);\r\nreturn il_remove_station(il, vif_priv->ibss_bssid_sta_id,\r\nvif->bss_conf.bssid);\r\n}\r\nvoid\r\nil4965_free_tfds_in_queue(struct il_priv *il, int sta_id, int tid, int freed)\r\n{\r\nlockdep_assert_held(&il->sta_lock);\r\nif (il->stations[sta_id].tid[tid].tfds_in_queue >= freed)\r\nil->stations[sta_id].tid[tid].tfds_in_queue -= freed;\r\nelse {\r\nD_TX("free more than tfds_in_queue (%u:%d)\n",\r\nil->stations[sta_id].tid[tid].tfds_in_queue, freed);\r\nil->stations[sta_id].tid[tid].tfds_in_queue = 0;\r\n}\r\n}\r\nstatic bool\r\nil4965_is_single_rx_stream(struct il_priv *il)\r\n{\r\nreturn il->current_ht_config.smps == IEEE80211_SMPS_STATIC ||\r\nil->current_ht_config.single_chain_sufficient;\r\n}\r\nstatic int\r\nil4965_get_active_rx_chain_count(struct il_priv *il)\r\n{\r\nif (il4965_is_single_rx_stream(il))\r\nreturn IL_NUM_RX_CHAINS_SINGLE;\r\nelse\r\nreturn IL_NUM_RX_CHAINS_MULTIPLE;\r\n}\r\nstatic int\r\nil4965_get_idle_rx_chain_count(struct il_priv *il, int active_cnt)\r\n{\r\nswitch (il->current_ht_config.smps) {\r\ncase IEEE80211_SMPS_STATIC:\r\ncase IEEE80211_SMPS_DYNAMIC:\r\nreturn IL_NUM_IDLE_CHAINS_SINGLE;\r\ncase IEEE80211_SMPS_OFF:\r\nreturn active_cnt;\r\ndefault:\r\nWARN(1, "invalid SMPS mode %d", il->current_ht_config.smps);\r\nreturn active_cnt;\r\n}\r\n}\r\nstatic u8\r\nil4965_count_chain_bitmap(u32 chain_bitmap)\r\n{\r\nu8 res;\r\nres = (chain_bitmap & BIT(0)) >> 0;\r\nres += (chain_bitmap & BIT(1)) >> 1;\r\nres += (chain_bitmap & BIT(2)) >> 2;\r\nres += (chain_bitmap & BIT(3)) >> 3;\r\nreturn res;\r\n}\r\nvoid\r\nil4965_set_rxon_chain(struct il_priv *il)\r\n{\r\nbool is_single = il4965_is_single_rx_stream(il);\r\nbool is_cam = !test_bit(S_POWER_PMI, &il->status);\r\nu8 idle_rx_cnt, active_rx_cnt, valid_rx_cnt;\r\nu32 active_chains;\r\nu16 rx_chain;\r\nif (il->chain_noise_data.active_chains)\r\nactive_chains = il->chain_noise_data.active_chains;\r\nelse\r\nactive_chains = il->hw_params.valid_rx_ant;\r\nrx_chain = active_chains << RXON_RX_CHAIN_VALID_POS;\r\nactive_rx_cnt = il4965_get_active_rx_chain_count(il);\r\nidle_rx_cnt = il4965_get_idle_rx_chain_count(il, active_rx_cnt);\r\nvalid_rx_cnt = il4965_count_chain_bitmap(active_chains);\r\nif (valid_rx_cnt < active_rx_cnt)\r\nactive_rx_cnt = valid_rx_cnt;\r\nif (valid_rx_cnt < idle_rx_cnt)\r\nidle_rx_cnt = valid_rx_cnt;\r\nrx_chain |= active_rx_cnt << RXON_RX_CHAIN_MIMO_CNT_POS;\r\nrx_chain |= idle_rx_cnt << RXON_RX_CHAIN_CNT_POS;\r\nil->staging.rx_chain = cpu_to_le16(rx_chain);\r\nif (!is_single && active_rx_cnt >= IL_NUM_RX_CHAINS_SINGLE && is_cam)\r\nil->staging.rx_chain |= RXON_RX_CHAIN_MIMO_FORCE_MSK;\r\nelse\r\nil->staging.rx_chain &= ~RXON_RX_CHAIN_MIMO_FORCE_MSK;\r\nD_ASSOC("rx_chain=0x%X active=%d idle=%d\n", il->staging.rx_chain,\r\nactive_rx_cnt, idle_rx_cnt);\r\nWARN_ON(active_rx_cnt == 0 || idle_rx_cnt == 0 ||\r\nactive_rx_cnt < idle_rx_cnt);\r\n}\r\nstatic const char *\r\nil4965_get_fh_string(int cmd)\r\n{\r\nswitch (cmd) {\r\nIL_CMD(FH49_RSCSR_CHNL0_STTS_WPTR_REG);\r\nIL_CMD(FH49_RSCSR_CHNL0_RBDCB_BASE_REG);\r\nIL_CMD(FH49_RSCSR_CHNL0_WPTR);\r\nIL_CMD(FH49_MEM_RCSR_CHNL0_CONFIG_REG);\r\nIL_CMD(FH49_MEM_RSSR_SHARED_CTRL_REG);\r\nIL_CMD(FH49_MEM_RSSR_RX_STATUS_REG);\r\nIL_CMD(FH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV);\r\nIL_CMD(FH49_TSSR_TX_STATUS_REG);\r\nIL_CMD(FH49_TSSR_TX_ERROR_REG);\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nint\r\nil4965_dump_fh(struct il_priv *il, char **buf, bool display)\r\n{\r\nint i;\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nint pos = 0;\r\nsize_t bufsz = 0;\r\n#endif\r\nstatic const u32 fh_tbl[] = {\r\nFH49_RSCSR_CHNL0_STTS_WPTR_REG,\r\nFH49_RSCSR_CHNL0_RBDCB_BASE_REG,\r\nFH49_RSCSR_CHNL0_WPTR,\r\nFH49_MEM_RCSR_CHNL0_CONFIG_REG,\r\nFH49_MEM_RSSR_SHARED_CTRL_REG,\r\nFH49_MEM_RSSR_RX_STATUS_REG,\r\nFH49_MEM_RSSR_RX_ENABLE_ERR_IRQ2DRV,\r\nFH49_TSSR_TX_STATUS_REG,\r\nFH49_TSSR_TX_ERROR_REG\r\n};\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (display) {\r\nbufsz = ARRAY_SIZE(fh_tbl) * 48 + 40;\r\n*buf = kmalloc(bufsz, GFP_KERNEL);\r\nif (!*buf)\r\nreturn -ENOMEM;\r\npos +=\r\nscnprintf(*buf + pos, bufsz - pos, "FH register values:\n");\r\nfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\r\npos +=\r\nscnprintf(*buf + pos, bufsz - pos,\r\n" %34s: 0X%08x\n",\r\nil4965_get_fh_string(fh_tbl[i]),\r\nil_rd(il, fh_tbl[i]));\r\n}\r\nreturn pos;\r\n}\r\n#endif\r\nIL_ERR("FH register values:\n");\r\nfor (i = 0; i < ARRAY_SIZE(fh_tbl); i++) {\r\nIL_ERR(" %34s: 0X%08x\n", il4965_get_fh_string(fh_tbl[i]),\r\nil_rd(il, fh_tbl[i]));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_hdl_missed_beacon(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il_missed_beacon_notif *missed_beacon;\r\nmissed_beacon = &pkt->u.missed_beacon;\r\nif (le32_to_cpu(missed_beacon->consecutive_missed_beacons) >\r\nil->missed_beacon_threshold) {\r\nD_CALIB("missed bcn cnsq %d totl %d rcd %d expctd %d\n",\r\nle32_to_cpu(missed_beacon->consecutive_missed_beacons),\r\nle32_to_cpu(missed_beacon->total_missed_becons),\r\nle32_to_cpu(missed_beacon->num_recvd_beacons),\r\nle32_to_cpu(missed_beacon->num_expected_beacons));\r\nif (!test_bit(S_SCANNING, &il->status))\r\nil4965_init_sensitivity(il);\r\n}\r\n}\r\nstatic void\r\nil4965_rx_calc_noise(struct il_priv *il)\r\n{\r\nstruct stats_rx_non_phy *rx_info;\r\nint num_active_rx = 0;\r\nint total_silence = 0;\r\nint bcn_silence_a, bcn_silence_b, bcn_silence_c;\r\nint last_rx_noise;\r\nrx_info = &(il->_4965.stats.rx.general);\r\nbcn_silence_a =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_a) & IN_BAND_FILTER;\r\nbcn_silence_b =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_b) & IN_BAND_FILTER;\r\nbcn_silence_c =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_c) & IN_BAND_FILTER;\r\nif (bcn_silence_a) {\r\ntotal_silence += bcn_silence_a;\r\nnum_active_rx++;\r\n}\r\nif (bcn_silence_b) {\r\ntotal_silence += bcn_silence_b;\r\nnum_active_rx++;\r\n}\r\nif (bcn_silence_c) {\r\ntotal_silence += bcn_silence_c;\r\nnum_active_rx++;\r\n}\r\nif (num_active_rx)\r\nlast_rx_noise = (total_silence / num_active_rx) - 107;\r\nelse\r\nlast_rx_noise = IL_NOISE_MEAS_NOT_AVAILABLE;\r\nD_CALIB("inband silence a %u, b %u, c %u, dBm %d\n", bcn_silence_a,\r\nbcn_silence_b, bcn_silence_c, last_rx_noise);\r\n}\r\nstatic void\r\nil4965_accumulative_stats(struct il_priv *il, __le32 * stats)\r\n{\r\nint i, size;\r\n__le32 *prev_stats;\r\nu32 *accum_stats;\r\nu32 *delta, *max_delta;\r\nstruct stats_general_common *general, *accum_general;\r\nstruct stats_tx *tx, *accum_tx;\r\nprev_stats = (__le32 *) &il->_4965.stats;\r\naccum_stats = (u32 *) &il->_4965.accum_stats;\r\nsize = sizeof(struct il_notif_stats);\r\ngeneral = &il->_4965.stats.general.common;\r\naccum_general = &il->_4965.accum_stats.general.common;\r\ntx = &il->_4965.stats.tx;\r\naccum_tx = &il->_4965.accum_stats.tx;\r\ndelta = (u32 *) &il->_4965.delta_stats;\r\nmax_delta = (u32 *) &il->_4965.max_delta;\r\nfor (i = sizeof(__le32); i < size;\r\ni +=\r\nsizeof(__le32), stats++, prev_stats++, delta++, max_delta++,\r\naccum_stats++) {\r\nif (le32_to_cpu(*stats) > le32_to_cpu(*prev_stats)) {\r\n*delta =\r\n(le32_to_cpu(*stats) - le32_to_cpu(*prev_stats));\r\n*accum_stats += *delta;\r\nif (*delta > *max_delta)\r\n*max_delta = *delta;\r\n}\r\n}\r\naccum_general->temperature = general->temperature;\r\naccum_general->ttl_timestamp = general->ttl_timestamp;\r\n}\r\nstatic void\r\nil4965_hdl_stats(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nconst int recalib_seconds = 60;\r\nbool change;\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nD_RX("Statistics notification received (%d vs %d).\n",\r\n(int)sizeof(struct il_notif_stats),\r\nle32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK);\r\nchange =\r\n((il->_4965.stats.general.common.temperature !=\r\npkt->u.stats.general.common.temperature) ||\r\n((il->_4965.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK) !=\r\n(pkt->u.stats.flag & STATS_REPLY_FLG_HT40_MODE_MSK)));\r\n#ifdef CONFIG_IWLEGACY_DEBUGFS\r\nil4965_accumulative_stats(il, (__le32 *) &pkt->u.stats);\r\n#endif\r\nmemcpy(&il->_4965.stats, &pkt->u.stats, sizeof(il->_4965.stats));\r\nset_bit(S_STATS, &il->status);\r\nmod_timer(&il->stats_periodic,\r\njiffies + msecs_to_jiffies(recalib_seconds * 1000));\r\nif (unlikely(!test_bit(S_SCANNING, &il->status)) &&\r\n(pkt->hdr.cmd == N_STATS)) {\r\nil4965_rx_calc_noise(il);\r\nqueue_work(il->workqueue, &il->run_time_calib_work);\r\n}\r\nif (change)\r\nil4965_temperature_calib(il);\r\n}\r\nstatic void\r\nil4965_hdl_c_stats(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nif (le32_to_cpu(pkt->u.stats.flag) & UCODE_STATS_CLEAR_MSK) {\r\n#ifdef CONFIG_IWLEGACY_DEBUGFS\r\nmemset(&il->_4965.accum_stats, 0,\r\nsizeof(struct il_notif_stats));\r\nmemset(&il->_4965.delta_stats, 0,\r\nsizeof(struct il_notif_stats));\r\nmemset(&il->_4965.max_delta, 0, sizeof(struct il_notif_stats));\r\n#endif\r\nD_RX("Statistics have been cleared\n");\r\n}\r\nil4965_hdl_stats(il, rxb);\r\n}\r\nstatic inline int\r\nil4965_get_ac_from_tid(u16 tid)\r\n{\r\nif (likely(tid < ARRAY_SIZE(tid_to_ac)))\r\nreturn tid_to_ac[tid];\r\nreturn -EINVAL;\r\n}\r\nstatic inline int\r\nil4965_get_fifo_from_tid(u16 tid)\r\n{\r\nconst u8 ac_to_fifo[] = {\r\nIL_TX_FIFO_VO,\r\nIL_TX_FIFO_VI,\r\nIL_TX_FIFO_BE,\r\nIL_TX_FIFO_BK,\r\n};\r\nif (likely(tid < ARRAY_SIZE(tid_to_ac)))\r\nreturn ac_to_fifo[tid_to_ac[tid]];\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nil4965_tx_cmd_build_basic(struct il_priv *il, struct sk_buff *skb,\r\nstruct il_tx_cmd *tx_cmd,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_hdr *hdr, u8 std_id)\r\n{\r\n__le16 fc = hdr->frame_control;\r\n__le32 tx_flags = tx_cmd->tx_flags;\r\ntx_cmd->stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\nif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\r\ntx_flags |= TX_CMD_FLG_ACK_MSK;\r\nif (ieee80211_is_mgmt(fc))\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\nif (ieee80211_is_probe_resp(fc) &&\r\n!(le16_to_cpu(hdr->seq_ctrl) & 0xf))\r\ntx_flags |= TX_CMD_FLG_TSF_MSK;\r\n} else {\r\ntx_flags &= (~TX_CMD_FLG_ACK_MSK);\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\n}\r\nif (ieee80211_is_back_req(fc))\r\ntx_flags |= TX_CMD_FLG_ACK_MSK | TX_CMD_FLG_IMM_BA_RSP_MASK;\r\ntx_cmd->sta_id = std_id;\r\nif (ieee80211_has_morefrags(fc))\r\ntx_flags |= TX_CMD_FLG_MORE_FRAG_MSK;\r\nif (ieee80211_is_data_qos(fc)) {\r\nu8 *qc = ieee80211_get_qos_ctl(hdr);\r\ntx_cmd->tid_tspec = qc[0] & 0xf;\r\ntx_flags &= ~TX_CMD_FLG_SEQ_CTL_MSK;\r\n} else {\r\ntx_flags |= TX_CMD_FLG_SEQ_CTL_MSK;\r\n}\r\nil_tx_cmd_protection(il, info, fc, &tx_flags);\r\ntx_flags &= ~(TX_CMD_FLG_ANT_SEL_MSK);\r\nif (ieee80211_is_mgmt(fc)) {\r\nif (ieee80211_is_assoc_req(fc) || ieee80211_is_reassoc_req(fc))\r\ntx_cmd->timeout.pm_frame_timeout = cpu_to_le16(3);\r\nelse\r\ntx_cmd->timeout.pm_frame_timeout = cpu_to_le16(2);\r\n} else {\r\ntx_cmd->timeout.pm_frame_timeout = 0;\r\n}\r\ntx_cmd->driver_txop = 0;\r\ntx_cmd->tx_flags = tx_flags;\r\ntx_cmd->next_frame_len = 0;\r\n}\r\nstatic void\r\nil4965_tx_cmd_build_rate(struct il_priv *il,\r\nstruct il_tx_cmd *tx_cmd,\r\nstruct ieee80211_tx_info *info,\r\nstruct ieee80211_sta *sta,\r\n__le16 fc)\r\n{\r\nconst u8 rts_retry_limit = 60;\r\nu32 rate_flags;\r\nint rate_idx;\r\nu8 data_retry_limit;\r\nu8 rate_plcp;\r\nif (ieee80211_is_probe_resp(fc))\r\ndata_retry_limit = 3;\r\nelse\r\ndata_retry_limit = IL4965_DEFAULT_TX_RETRY;\r\ntx_cmd->data_retry_limit = data_retry_limit;\r\ntx_cmd->rts_retry_limit = min(data_retry_limit, rts_retry_limit);\r\nif (ieee80211_is_data(fc)) {\r\ntx_cmd->initial_rate_idx = 0;\r\ntx_cmd->tx_flags |= TX_CMD_FLG_STA_RATE_MSK;\r\nreturn;\r\n}\r\nrate_idx = info->control.rates[0].idx;\r\nif ((info->control.rates[0].flags & IEEE80211_TX_RC_MCS) || rate_idx < 0\r\n|| rate_idx > RATE_COUNT_LEGACY)\r\nrate_idx = rate_lowest_index(&il->bands[info->band], sta);\r\nif (info->band == IEEE80211_BAND_5GHZ)\r\nrate_idx += IL_FIRST_OFDM_RATE;\r\nrate_plcp = il_rates[rate_idx].plcp;\r\nrate_flags = 0;\r\nif (rate_idx >= IL_FIRST_CCK_RATE && rate_idx <= IL_LAST_CCK_RATE)\r\nrate_flags |= RATE_MCS_CCK_MSK;\r\nil4965_toggle_tx_ant(il, &il->mgmt_tx_ant, il->hw_params.valid_tx_ant);\r\nrate_flags |= BIT(il->mgmt_tx_ant) << RATE_MCS_ANT_POS;\r\ntx_cmd->rate_n_flags = cpu_to_le32(rate_plcp | rate_flags);\r\n}\r\nstatic void\r\nil4965_tx_cmd_build_hwcrypto(struct il_priv *il, struct ieee80211_tx_info *info,\r\nstruct il_tx_cmd *tx_cmd, struct sk_buff *skb_frag,\r\nint sta_id)\r\n{\r\nstruct ieee80211_key_conf *keyconf = info->control.hw_key;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ntx_cmd->sec_ctl = TX_CMD_SEC_CCM;\r\nmemcpy(tx_cmd->key, keyconf->key, keyconf->keylen);\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU)\r\ntx_cmd->tx_flags |= TX_CMD_FLG_AGG_CCMP_MSK;\r\nD_TX("tx_cmd with AES hwcrypto\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ntx_cmd->sec_ctl = TX_CMD_SEC_TKIP;\r\nieee80211_get_tkip_p2k(keyconf, skb_frag, tx_cmd->key);\r\nD_TX("tx_cmd with tkip hwcrypto\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ntx_cmd->sec_ctl |= TX_CMD_SEC_KEY128;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ntx_cmd->sec_ctl |=\r\n(TX_CMD_SEC_WEP | (keyconf->keyidx & TX_CMD_SEC_MSK) <<\r\nTX_CMD_SEC_SHIFT);\r\nmemcpy(&tx_cmd->key[3], keyconf->key, keyconf->keylen);\r\nD_TX("Configuring packet for WEP encryption " "with key %d\n",\r\nkeyconf->keyidx);\r\nbreak;\r\ndefault:\r\nIL_ERR("Unknown encode cipher %x\n", keyconf->cipher);\r\nbreak;\r\n}\r\n}\r\nint\r\nil4965_tx_skb(struct il_priv *il,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct il_station_priv *sta_priv = NULL;\r\nstruct il_tx_queue *txq;\r\nstruct il_queue *q;\r\nstruct il_device_cmd *out_cmd;\r\nstruct il_cmd_meta *out_meta;\r\nstruct il_tx_cmd *tx_cmd;\r\nint txq_id;\r\ndma_addr_t phys_addr;\r\ndma_addr_t txcmd_phys;\r\ndma_addr_t scratch_phys;\r\nu16 len, firstlen, secondlen;\r\nu16 seq_number = 0;\r\n__le16 fc;\r\nu8 hdr_len;\r\nu8 sta_id;\r\nu8 wait_write_ptr = 0;\r\nu8 tid = 0;\r\nu8 *qc = NULL;\r\nunsigned long flags;\r\nbool is_agg = false;\r\nspin_lock_irqsave(&il->lock, flags);\r\nif (il_is_rfkill(il)) {\r\nD_DROP("Dropping - RF KILL\n");\r\ngoto drop_unlock;\r\n}\r\nfc = hdr->frame_control;\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (ieee80211_is_auth(fc))\r\nD_TX("Sending AUTH frame\n");\r\nelse if (ieee80211_is_assoc_req(fc))\r\nD_TX("Sending ASSOC frame\n");\r\nelse if (ieee80211_is_reassoc_req(fc))\r\nD_TX("Sending REASSOC frame\n");\r\n#endif\r\nhdr_len = ieee80211_hdrlen(fc);\r\nif (!ieee80211_is_data(fc))\r\nsta_id = il->hw_params.bcast_id;\r\nelse {\r\nsta_id = il_sta_id_or_broadcast(il, sta);\r\nif (sta_id == IL_INVALID_STATION) {\r\nD_DROP("Dropping - INVALID STATION: %pM\n", hdr->addr1);\r\ngoto drop_unlock;\r\n}\r\n}\r\nD_TX("station Id %d\n", sta_id);\r\nif (sta)\r\nsta_priv = (void *)sta->drv_priv;\r\nif (sta_priv && sta_priv->asleep &&\r\n(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER)) {\r\nil4965_sta_modify_sleep_tx_count(il, sta_id, 1);\r\n}\r\nWARN_ON_ONCE(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM);\r\ntxq_id = skb_get_queue_mapping(skb);\r\nspin_lock(&il->sta_lock);\r\nif (ieee80211_is_data_qos(fc)) {\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\r\nif (WARN_ON_ONCE(tid >= MAX_TID_COUNT)) {\r\nspin_unlock(&il->sta_lock);\r\ngoto drop_unlock;\r\n}\r\nseq_number = il->stations[sta_id].tid[tid].seq_number;\r\nseq_number &= IEEE80211_SCTL_SEQ;\r\nhdr->seq_ctrl =\r\nhdr->seq_ctrl & cpu_to_le16(IEEE80211_SCTL_FRAG);\r\nhdr->seq_ctrl |= cpu_to_le16(seq_number);\r\nseq_number += 0x10;\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU &&\r\nil->stations[sta_id].tid[tid].agg.state == IL_AGG_ON) {\r\ntxq_id = il->stations[sta_id].tid[tid].agg.txq_id;\r\nis_agg = true;\r\n}\r\n}\r\ntxq = &il->txq[txq_id];\r\nq = &txq->q;\r\nif (unlikely(il_queue_space(q) < q->high_mark)) {\r\nspin_unlock(&il->sta_lock);\r\ngoto drop_unlock;\r\n}\r\nif (ieee80211_is_data_qos(fc)) {\r\nil->stations[sta_id].tid[tid].tfds_in_queue++;\r\nif (!ieee80211_has_morefrags(fc))\r\nil->stations[sta_id].tid[tid].seq_number = seq_number;\r\n}\r\nspin_unlock(&il->sta_lock);\r\ntxq->skbs[q->write_ptr] = skb;\r\nout_cmd = txq->cmd[q->write_ptr];\r\nout_meta = &txq->meta[q->write_ptr];\r\ntx_cmd = &out_cmd->cmd.tx;\r\nmemset(&out_cmd->hdr, 0, sizeof(out_cmd->hdr));\r\nmemset(tx_cmd, 0, sizeof(struct il_tx_cmd));\r\nout_cmd->hdr.cmd = C_TX;\r\nout_cmd->hdr.sequence =\r\ncpu_to_le16((u16)\r\n(QUEUE_TO_SEQ(txq_id) | IDX_TO_SEQ(q->write_ptr)));\r\nmemcpy(tx_cmd->hdr, hdr, hdr_len);\r\ntx_cmd->len = cpu_to_le16((u16) skb->len);\r\nif (info->control.hw_key)\r\nil4965_tx_cmd_build_hwcrypto(il, info, tx_cmd, skb, sta_id);\r\nil4965_tx_cmd_build_basic(il, skb, tx_cmd, info, hdr, sta_id);\r\nil4965_tx_cmd_build_rate(il, tx_cmd, info, sta, fc);\r\nlen = sizeof(struct il_tx_cmd) + sizeof(struct il_cmd_header) + hdr_len;\r\nfirstlen = (len + 3) & ~3;\r\nif (firstlen != len)\r\ntx_cmd->tx_flags |= TX_CMD_FLG_MH_PAD_MSK;\r\ntxcmd_phys =\r\npci_map_single(il->pci_dev, &out_cmd->hdr, firstlen,\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev, txcmd_phys)))\r\ngoto drop_unlock;\r\nsecondlen = skb->len - hdr_len;\r\nif (secondlen > 0) {\r\nphys_addr =\r\npci_map_single(il->pci_dev, skb->data + hdr_len, secondlen,\r\nPCI_DMA_TODEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev, phys_addr)))\r\ngoto drop_unlock;\r\n}\r\nil->ops->txq_attach_buf_to_tfd(il, txq, txcmd_phys, firstlen, 1, 0);\r\ndma_unmap_addr_set(out_meta, mapping, txcmd_phys);\r\ndma_unmap_len_set(out_meta, len, firstlen);\r\nif (secondlen)\r\nil->ops->txq_attach_buf_to_tfd(il, txq, phys_addr, secondlen,\r\n0, 0);\r\nif (!ieee80211_has_morefrags(hdr->frame_control)) {\r\ntxq->need_update = 1;\r\n} else {\r\nwait_write_ptr = 1;\r\ntxq->need_update = 0;\r\n}\r\nscratch_phys =\r\ntxcmd_phys + sizeof(struct il_cmd_header) +\r\noffsetof(struct il_tx_cmd, scratch);\r\npci_dma_sync_single_for_cpu(il->pci_dev, txcmd_phys, firstlen,\r\nPCI_DMA_BIDIRECTIONAL);\r\ntx_cmd->dram_lsb_ptr = cpu_to_le32(scratch_phys);\r\ntx_cmd->dram_msb_ptr = il_get_dma_hi_addr(scratch_phys);\r\nil_update_stats(il, true, fc, skb->len);\r\nD_TX("sequence nr = 0X%x\n", le16_to_cpu(out_cmd->hdr.sequence));\r\nD_TX("tx_flags = 0X%x\n", le32_to_cpu(tx_cmd->tx_flags));\r\nil_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd, sizeof(*tx_cmd));\r\nil_print_hex_dump(il, IL_DL_TX, (u8 *) tx_cmd->hdr, hdr_len);\r\nif (info->flags & IEEE80211_TX_CTL_AMPDU)\r\nil->ops->txq_update_byte_cnt_tbl(il, txq, le16_to_cpu(tx_cmd->len));\r\npci_dma_sync_single_for_device(il->pci_dev, txcmd_phys, firstlen,\r\nPCI_DMA_BIDIRECTIONAL);\r\nq->write_ptr = il_queue_inc_wrap(q->write_ptr, q->n_bd);\r\nil_txq_update_write_ptr(il, txq);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nif (sta_priv && sta_priv->client && !is_agg)\r\natomic_inc(&sta_priv->pending_frames);\r\nif (il_queue_space(q) < q->high_mark && il->mac80211_registered) {\r\nif (wait_write_ptr) {\r\nspin_lock_irqsave(&il->lock, flags);\r\ntxq->need_update = 1;\r\nil_txq_update_write_ptr(il, txq);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\n} else {\r\nil_stop_queue(il, txq);\r\n}\r\n}\r\nreturn 0;\r\ndrop_unlock:\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn -1;\r\n}\r\nstatic inline int\r\nil4965_alloc_dma_ptr(struct il_priv *il, struct il_dma_ptr *ptr, size_t size)\r\n{\r\nptr->addr = dma_alloc_coherent(&il->pci_dev->dev, size, &ptr->dma,\r\nGFP_KERNEL);\r\nif (!ptr->addr)\r\nreturn -ENOMEM;\r\nptr->size = size;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nil4965_free_dma_ptr(struct il_priv *il, struct il_dma_ptr *ptr)\r\n{\r\nif (unlikely(!ptr->addr))\r\nreturn;\r\ndma_free_coherent(&il->pci_dev->dev, ptr->size, ptr->addr, ptr->dma);\r\nmemset(ptr, 0, sizeof(*ptr));\r\n}\r\nvoid\r\nil4965_hw_txq_ctx_free(struct il_priv *il)\r\n{\r\nint txq_id;\r\nif (il->txq) {\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\r\nif (txq_id == il->cmd_queue)\r\nil_cmd_queue_free(il);\r\nelse\r\nil_tx_queue_free(il, txq_id);\r\n}\r\nil4965_free_dma_ptr(il, &il->kw);\r\nil4965_free_dma_ptr(il, &il->scd_bc_tbls);\r\nil_free_txq_mem(il);\r\n}\r\nint\r\nil4965_txq_ctx_alloc(struct il_priv *il)\r\n{\r\nint ret, txq_id;\r\nunsigned long flags;\r\nil4965_hw_txq_ctx_free(il);\r\nret =\r\nil4965_alloc_dma_ptr(il, &il->scd_bc_tbls,\r\nil->hw_params.scd_bc_tbls_size);\r\nif (ret) {\r\nIL_ERR("Scheduler BC Table allocation failed\n");\r\ngoto error_bc_tbls;\r\n}\r\nret = il4965_alloc_dma_ptr(il, &il->kw, IL_KW_SIZE);\r\nif (ret) {\r\nIL_ERR("Keep Warm allocation failed\n");\r\ngoto error_kw;\r\n}\r\nret = il_alloc_txq_mem(il);\r\nif (ret)\r\ngoto error;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil4965_txq_set_sched(il, 0);\r\nil_wr(il, FH49_KW_MEM_ADDR_REG, il->kw.dma >> 4);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++) {\r\nret = il_tx_queue_init(il, txq_id);\r\nif (ret) {\r\nIL_ERR("Tx %d queue init failed\n", txq_id);\r\ngoto error;\r\n}\r\n}\r\nreturn ret;\r\nerror:\r\nil4965_hw_txq_ctx_free(il);\r\nil4965_free_dma_ptr(il, &il->kw);\r\nerror_kw:\r\nil4965_free_dma_ptr(il, &il->scd_bc_tbls);\r\nerror_bc_tbls:\r\nreturn ret;\r\n}\r\nvoid\r\nil4965_txq_ctx_reset(struct il_priv *il)\r\n{\r\nint txq_id;\r\nunsigned long flags;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil4965_txq_set_sched(il, 0);\r\nil_wr(il, FH49_KW_MEM_ADDR_REG, il->kw.dma >> 4);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\r\nil_tx_queue_reset(il, txq_id);\r\n}\r\nstatic void\r\nil4965_txq_ctx_unmap(struct il_priv *il)\r\n{\r\nint txq_id;\r\nif (!il->txq)\r\nreturn;\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\r\nif (txq_id == il->cmd_queue)\r\nil_cmd_queue_unmap(il);\r\nelse\r\nil_tx_queue_unmap(il, txq_id);\r\n}\r\nvoid\r\nil4965_txq_ctx_stop(struct il_priv *il)\r\n{\r\nint ch, ret;\r\n_il_wr_prph(il, IL49_SCD_TXFACT, 0);\r\nfor (ch = 0; ch < il->hw_params.dma_chnl_num; ch++) {\r\n_il_wr(il, FH49_TCSR_CHNL_TX_CONFIG_REG(ch), 0x0);\r\nret =\r\n_il_poll_bit(il, FH49_TSSR_TX_STATUS_REG,\r\nFH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(ch),\r\nFH49_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(ch),\r\n1000);\r\nif (ret < 0)\r\nIL_ERR("Timeout stopping DMA channel %d [0x%08x]",\r\nch, _il_rd(il, FH49_TSSR_TX_STATUS_REG));\r\n}\r\n}\r\nstatic int\r\nil4965_txq_ctx_activate_free(struct il_priv *il)\r\n{\r\nint txq_id;\r\nfor (txq_id = 0; txq_id < il->hw_params.max_txq_num; txq_id++)\r\nif (!test_and_set_bit(txq_id, &il->txq_ctx_active_msk))\r\nreturn txq_id;\r\nreturn -1;\r\n}\r\nstatic void\r\nil4965_tx_queue_stop_scheduler(struct il_priv *il, u16 txq_id)\r\n{\r\nil_wr_prph(il, IL49_SCD_QUEUE_STATUS_BITS(txq_id),\r\n(0 << IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE) |\r\n(1 << IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));\r\n}\r\nstatic int\r\nil4965_tx_queue_set_q2ratid(struct il_priv *il, u16 ra_tid, u16 txq_id)\r\n{\r\nu32 tbl_dw_addr;\r\nu32 tbl_dw;\r\nu16 scd_q2ratid;\r\nscd_q2ratid = ra_tid & IL_SCD_QUEUE_RA_TID_MAP_RATID_MSK;\r\ntbl_dw_addr =\r\nil->scd_base_addr + IL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(txq_id);\r\ntbl_dw = il_read_targ_mem(il, tbl_dw_addr);\r\nif (txq_id & 0x1)\r\ntbl_dw = (scd_q2ratid << 16) | (tbl_dw & 0x0000FFFF);\r\nelse\r\ntbl_dw = scd_q2ratid | (tbl_dw & 0xFFFF0000);\r\nil_write_targ_mem(il, tbl_dw_addr, tbl_dw);\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_txq_agg_enable(struct il_priv *il, int txq_id, int tx_fifo, int sta_id,\r\nint tid, u16 ssn_idx)\r\n{\r\nunsigned long flags;\r\nu16 ra_tid;\r\nint ret;\r\nif ((IL49_FIRST_AMPDU_QUEUE > txq_id) ||\r\n(IL49_FIRST_AMPDU_QUEUE +\r\nil->cfg->num_of_ampdu_queues <= txq_id)) {\r\nIL_WARN("queue number out of range: %d, must be %d to %d\n",\r\ntxq_id, IL49_FIRST_AMPDU_QUEUE,\r\nIL49_FIRST_AMPDU_QUEUE +\r\nil->cfg->num_of_ampdu_queues - 1);\r\nreturn -EINVAL;\r\n}\r\nra_tid = BUILD_RAxTID(sta_id, tid);\r\nret = il4965_sta_tx_modify_enable_tid(il, sta_id, tid);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil4965_tx_queue_stop_scheduler(il, txq_id);\r\nil4965_tx_queue_set_q2ratid(il, ra_tid, txq_id);\r\nil_set_bits_prph(il, IL49_SCD_QUEUECHAIN_SEL, (1 << txq_id));\r\nil->txq[txq_id].q.read_ptr = (ssn_idx & 0xff);\r\nil->txq[txq_id].q.write_ptr = (ssn_idx & 0xff);\r\nil4965_set_wr_ptrs(il, txq_id, ssn_idx);\r\nil_write_targ_mem(il,\r\nil->scd_base_addr +\r\nIL49_SCD_CONTEXT_QUEUE_OFFSET(txq_id),\r\n(SCD_WIN_SIZE << IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS)\r\n& IL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK);\r\nil_write_targ_mem(il,\r\nil->scd_base_addr +\r\nIL49_SCD_CONTEXT_QUEUE_OFFSET(txq_id) + sizeof(u32),\r\n(SCD_FRAME_LIMIT <<\r\nIL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &\r\nIL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK);\r\nil_set_bits_prph(il, IL49_SCD_INTERRUPT_MASK, (1 << txq_id));\r\nil4965_tx_queue_set_status(il, &il->txq[txq_id], tx_fifo, 1);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nil4965_tx_agg_start(struct il_priv *il, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u16 tid, u16 * ssn)\r\n{\r\nint sta_id;\r\nint tx_fifo;\r\nint txq_id;\r\nint ret;\r\nunsigned long flags;\r\nstruct il_tid_data *tid_data;\r\ntx_fifo = il4965_get_fifo_from_tid(tid);\r\nif (unlikely(tx_fifo < 0))\r\nreturn tx_fifo;\r\nD_HT("%s on ra = %pM tid = %d\n", __func__, sta->addr, tid);\r\nsta_id = il_sta_id(sta);\r\nif (sta_id == IL_INVALID_STATION) {\r\nIL_ERR("Start AGG on invalid station\n");\r\nreturn -ENXIO;\r\n}\r\nif (unlikely(tid >= MAX_TID_COUNT))\r\nreturn -EINVAL;\r\nif (il->stations[sta_id].tid[tid].agg.state != IL_AGG_OFF) {\r\nIL_ERR("Start AGG when state is not IL_AGG_OFF !\n");\r\nreturn -ENXIO;\r\n}\r\ntxq_id = il4965_txq_ctx_activate_free(il);\r\nif (txq_id == -1) {\r\nIL_ERR("No free aggregation queue available\n");\r\nreturn -ENXIO;\r\n}\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\ntid_data = &il->stations[sta_id].tid[tid];\r\n*ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\r\ntid_data->agg.txq_id = txq_id;\r\nil_set_swq_id(&il->txq[txq_id], il4965_get_ac_from_tid(tid), txq_id);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nret = il4965_txq_agg_enable(il, txq_id, tx_fifo, sta_id, tid, *ssn);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\ntid_data = &il->stations[sta_id].tid[tid];\r\nif (tid_data->tfds_in_queue == 0) {\r\nD_HT("HW queue is empty\n");\r\ntid_data->agg.state = IL_AGG_ON;\r\nieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\n} else {\r\nD_HT("HW queue is NOT empty: %d packets in HW queue\n",\r\ntid_data->tfds_in_queue);\r\ntid_data->agg.state = IL_EMPTYING_HW_QUEUE_ADDBA;\r\n}\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nil4965_txq_agg_disable(struct il_priv *il, u16 txq_id, u16 ssn_idx, u8 tx_fifo)\r\n{\r\nif ((IL49_FIRST_AMPDU_QUEUE > txq_id) ||\r\n(IL49_FIRST_AMPDU_QUEUE +\r\nil->cfg->num_of_ampdu_queues <= txq_id)) {\r\nIL_WARN("queue number out of range: %d, must be %d to %d\n",\r\ntxq_id, IL49_FIRST_AMPDU_QUEUE,\r\nIL49_FIRST_AMPDU_QUEUE +\r\nil->cfg->num_of_ampdu_queues - 1);\r\nreturn -EINVAL;\r\n}\r\nil4965_tx_queue_stop_scheduler(il, txq_id);\r\nil_clear_bits_prph(il, IL49_SCD_QUEUECHAIN_SEL, (1 << txq_id));\r\nil->txq[txq_id].q.read_ptr = (ssn_idx & 0xff);\r\nil->txq[txq_id].q.write_ptr = (ssn_idx & 0xff);\r\nil4965_set_wr_ptrs(il, txq_id, ssn_idx);\r\nil_clear_bits_prph(il, IL49_SCD_INTERRUPT_MASK, (1 << txq_id));\r\nil_txq_ctx_deactivate(il, txq_id);\r\nil4965_tx_queue_set_status(il, &il->txq[txq_id], tx_fifo, 0);\r\nreturn 0;\r\n}\r\nint\r\nil4965_tx_agg_stop(struct il_priv *il, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u16 tid)\r\n{\r\nint tx_fifo_id, txq_id, sta_id, ssn;\r\nstruct il_tid_data *tid_data;\r\nint write_ptr, read_ptr;\r\nunsigned long flags;\r\ntx_fifo_id = il4965_get_fifo_from_tid(tid);\r\nif (unlikely(tx_fifo_id < 0))\r\nreturn tx_fifo_id;\r\nsta_id = il_sta_id(sta);\r\nif (sta_id == IL_INVALID_STATION) {\r\nIL_ERR("Invalid station for AGG tid %d\n", tid);\r\nreturn -ENXIO;\r\n}\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\ntid_data = &il->stations[sta_id].tid[tid];\r\nssn = (tid_data->seq_number & IEEE80211_SCTL_SEQ) >> 4;\r\ntxq_id = tid_data->agg.txq_id;\r\nswitch (il->stations[sta_id].tid[tid].agg.state) {\r\ncase IL_EMPTYING_HW_QUEUE_ADDBA:\r\nD_HT("AGG stop before setup done\n");\r\ngoto turn_off;\r\ncase IL_AGG_ON:\r\nbreak;\r\ndefault:\r\nIL_WARN("Stopping AGG while state not ON or starting\n");\r\n}\r\nwrite_ptr = il->txq[txq_id].q.write_ptr;\r\nread_ptr = il->txq[txq_id].q.read_ptr;\r\nif (write_ptr != read_ptr) {\r\nD_HT("Stopping a non empty AGG HW QUEUE\n");\r\nil->stations[sta_id].tid[tid].agg.state =\r\nIL_EMPTYING_HW_QUEUE_DELBA;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nD_HT("HW queue is empty\n");\r\nturn_off:\r\nil->stations[sta_id].tid[tid].agg.state = IL_AGG_OFF;\r\nspin_unlock(&il->sta_lock);\r\nspin_lock(&il->lock);\r\nil4965_txq_agg_disable(il, txq_id, ssn, tx_fifo_id);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nreturn 0;\r\n}\r\nint\r\nil4965_txq_check_empty(struct il_priv *il, int sta_id, u8 tid, int txq_id)\r\n{\r\nstruct il_queue *q = &il->txq[txq_id].q;\r\nu8 *addr = il->stations[sta_id].sta.sta.addr;\r\nstruct il_tid_data *tid_data = &il->stations[sta_id].tid[tid];\r\nlockdep_assert_held(&il->sta_lock);\r\nswitch (il->stations[sta_id].tid[tid].agg.state) {\r\ncase IL_EMPTYING_HW_QUEUE_DELBA:\r\nif (txq_id == tid_data->agg.txq_id &&\r\nq->read_ptr == q->write_ptr) {\r\nu16 ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\r\nint tx_fifo = il4965_get_fifo_from_tid(tid);\r\nD_HT("HW queue empty: continue DELBA flow\n");\r\nil4965_txq_agg_disable(il, txq_id, ssn, tx_fifo);\r\ntid_data->agg.state = IL_AGG_OFF;\r\nieee80211_stop_tx_ba_cb_irqsafe(il->vif, addr, tid);\r\n}\r\nbreak;\r\ncase IL_EMPTYING_HW_QUEUE_ADDBA:\r\nif (tid_data->tfds_in_queue == 0) {\r\nD_HT("HW queue empty: continue ADDBA flow\n");\r\ntid_data->agg.state = IL_AGG_ON;\r\nieee80211_start_tx_ba_cb_irqsafe(il->vif, addr, tid);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_non_agg_tx_status(struct il_priv *il, const u8 *addr1)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct il_station_priv *sta_priv;\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(il->vif, addr1);\r\nif (sta) {\r\nsta_priv = (void *)sta->drv_priv;\r\nif (sta_priv->client &&\r\natomic_dec_return(&sta_priv->pending_frames) == 0)\r\nieee80211_sta_block_awake(il->hw, sta, false);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void\r\nil4965_tx_status(struct il_priv *il, struct sk_buff *skb, bool is_agg)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!is_agg)\r\nil4965_non_agg_tx_status(il, hdr->addr1);\r\nieee80211_tx_status_irqsafe(il->hw, skb);\r\n}\r\nint\r\nil4965_tx_queue_reclaim(struct il_priv *il, int txq_id, int idx)\r\n{\r\nstruct il_tx_queue *txq = &il->txq[txq_id];\r\nstruct il_queue *q = &txq->q;\r\nint nfreed = 0;\r\nstruct ieee80211_hdr *hdr;\r\nstruct sk_buff *skb;\r\nif (idx >= q->n_bd || il_queue_used(q, idx) == 0) {\r\nIL_ERR("Read idx for DMA queue txq id (%d), idx %d, "\r\n"is out of range [0-%d] %d %d.\n", txq_id, idx, q->n_bd,\r\nq->write_ptr, q->read_ptr);\r\nreturn 0;\r\n}\r\nfor (idx = il_queue_inc_wrap(idx, q->n_bd); q->read_ptr != idx;\r\nq->read_ptr = il_queue_inc_wrap(q->read_ptr, q->n_bd)) {\r\nskb = txq->skbs[txq->q.read_ptr];\r\nif (WARN_ON_ONCE(skb == NULL))\r\ncontinue;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (ieee80211_is_data_qos(hdr->frame_control))\r\nnfreed++;\r\nil4965_tx_status(il, skb, txq_id >= IL4965_FIRST_AMPDU_QUEUE);\r\ntxq->skbs[txq->q.read_ptr] = NULL;\r\nil->ops->txq_free_tfd(il, txq);\r\n}\r\nreturn nfreed;\r\n}\r\nstatic int\r\nil4965_tx_status_reply_compressed_ba(struct il_priv *il, struct il_ht_agg *agg,\r\nstruct il_compressed_ba_resp *ba_resp)\r\n{\r\nint i, sh, ack;\r\nu16 seq_ctl = le16_to_cpu(ba_resp->seq_ctl);\r\nu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\r\nint successes = 0;\r\nstruct ieee80211_tx_info *info;\r\nu64 bitmap, sent_bitmap;\r\nif (unlikely(!agg->wait_for_ba)) {\r\nif (unlikely(ba_resp->bitmap))\r\nIL_ERR("Received BA when not expected\n");\r\nreturn -EINVAL;\r\n}\r\nagg->wait_for_ba = 0;\r\nD_TX_REPLY("BA %d %d\n", agg->start_idx, ba_resp->seq_ctl);\r\nsh = agg->start_idx - SEQ_TO_IDX(seq_ctl >> 4);\r\nif (sh < 0)\r\nsh += 0x100;\r\nif (agg->frame_count > (64 - sh)) {\r\nD_TX_REPLY("more frames than bitmap size");\r\nreturn -1;\r\n}\r\nbitmap = le64_to_cpu(ba_resp->bitmap) >> sh;\r\nsent_bitmap = bitmap & agg->bitmap;\r\ni = 0;\r\nwhile (sent_bitmap) {\r\nack = sent_bitmap & 1ULL;\r\nsuccesses += ack;\r\nD_TX_REPLY("%s ON i=%d idx=%d raw=%d\n", ack ? "ACK" : "NACK",\r\ni, (agg->start_idx + i) & 0xff, agg->start_idx + i);\r\nsent_bitmap >>= 1;\r\n++i;\r\n}\r\nD_TX_REPLY("Bitmap %llx\n", (unsigned long long)bitmap);\r\ninfo = IEEE80211_SKB_CB(il->txq[scd_flow].skbs[agg->start_idx]);\r\nmemset(&info->status, 0, sizeof(info->status));\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\ninfo->flags |= IEEE80211_TX_STAT_AMPDU;\r\ninfo->status.ampdu_ack_len = successes;\r\ninfo->status.ampdu_len = agg->frame_count;\r\nil4965_hwrate_to_tx_control(il, agg->rate_n_flags, info);\r\nreturn 0;\r\n}\r\nstatic inline bool\r\nil4965_is_tx_success(u32 status)\r\n{\r\nstatus &= TX_STATUS_MSK;\r\nreturn (status == TX_STATUS_SUCCESS || status == TX_STATUS_DIRECT_DONE);\r\n}\r\nstatic u8\r\nil4965_find_station(struct il_priv *il, const u8 *addr)\r\n{\r\nint i;\r\nint start = 0;\r\nint ret = IL_INVALID_STATION;\r\nunsigned long flags;\r\nif (il->iw_mode == NL80211_IFTYPE_ADHOC)\r\nstart = IL_STA_ID;\r\nif (is_broadcast_ether_addr(addr))\r\nreturn il->hw_params.bcast_id;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nfor (i = start; i < il->hw_params.max_stations; i++)\r\nif (il->stations[i].used &&\r\nether_addr_equal(il->stations[i].sta.sta.addr, addr)) {\r\nret = i;\r\ngoto out;\r\n}\r\nD_ASSOC("can not find STA %pM total %d\n", addr, il->num_stations);\r\nout:\r\nif (ret != IL_INVALID_STATION &&\r\n(!(il->stations[ret].used & IL_STA_UCODE_ACTIVE) ||\r\n((il->stations[ret].used & IL_STA_UCODE_ACTIVE) &&\r\n(il->stations[ret].used & IL_STA_UCODE_INPROGRESS)))) {\r\nIL_ERR("Requested station info for sta %d before ready.\n",\r\nret);\r\nret = IL_INVALID_STATION;\r\n}\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nil4965_get_ra_sta_id(struct il_priv *il, struct ieee80211_hdr *hdr)\r\n{\r\nif (il->iw_mode == NL80211_IFTYPE_STATION)\r\nreturn IL_AP_ID;\r\nelse {\r\nu8 *da = ieee80211_get_DA(hdr);\r\nreturn il4965_find_station(il, da);\r\n}\r\n}\r\nstatic inline u32\r\nil4965_get_scd_ssn(struct il4965_tx_resp *tx_resp)\r\n{\r\nreturn le32_to_cpup(&tx_resp->u.status +\r\ntx_resp->frame_count) & IEEE80211_MAX_SN;\r\n}\r\nstatic inline u32\r\nil4965_tx_status_to_mac80211(u32 status)\r\n{\r\nstatus &= TX_STATUS_MSK;\r\nswitch (status) {\r\ncase TX_STATUS_SUCCESS:\r\ncase TX_STATUS_DIRECT_DONE:\r\nreturn IEEE80211_TX_STAT_ACK;\r\ncase TX_STATUS_FAIL_DEST_PS:\r\nreturn IEEE80211_TX_STAT_TX_FILTERED;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\nil4965_tx_status_reply_tx(struct il_priv *il, struct il_ht_agg *agg,\r\nstruct il4965_tx_resp *tx_resp, int txq_id,\r\nu16 start_idx)\r\n{\r\nu16 status;\r\nstruct agg_tx_status *frame_status = tx_resp->u.agg_status;\r\nstruct ieee80211_tx_info *info = NULL;\r\nstruct ieee80211_hdr *hdr = NULL;\r\nu32 rate_n_flags = le32_to_cpu(tx_resp->rate_n_flags);\r\nint i, sh, idx;\r\nu16 seq;\r\nif (agg->wait_for_ba)\r\nD_TX_REPLY("got tx response w/o block-ack\n");\r\nagg->frame_count = tx_resp->frame_count;\r\nagg->start_idx = start_idx;\r\nagg->rate_n_flags = rate_n_flags;\r\nagg->bitmap = 0;\r\nif (agg->frame_count == 1) {\r\nstatus = le16_to_cpu(frame_status[0].status);\r\nidx = start_idx;\r\nD_TX_REPLY("FrameCnt = %d, StartIdx=%d idx=%d\n",\r\nagg->frame_count, agg->start_idx, idx);\r\ninfo = IEEE80211_SKB_CB(il->txq[txq_id].skbs[idx]);\r\ninfo->status.rates[0].count = tx_resp->failure_frame + 1;\r\ninfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\r\ninfo->flags |= il4965_tx_status_to_mac80211(status);\r\nil4965_hwrate_to_tx_control(il, rate_n_flags, info);\r\nD_TX_REPLY("1 Frame 0x%x failure :%d\n", status & 0xff,\r\ntx_resp->failure_frame);\r\nD_TX_REPLY("Rate Info rate_n_flags=%x\n", rate_n_flags);\r\nagg->wait_for_ba = 0;\r\n} else {\r\nu64 bitmap = 0;\r\nint start = agg->start_idx;\r\nstruct sk_buff *skb;\r\nfor (i = 0; i < agg->frame_count; i++) {\r\nu16 sc;\r\nstatus = le16_to_cpu(frame_status[i].status);\r\nseq = le16_to_cpu(frame_status[i].sequence);\r\nidx = SEQ_TO_IDX(seq);\r\ntxq_id = SEQ_TO_QUEUE(seq);\r\nif (status &\r\n(AGG_TX_STATE_FEW_BYTES_MSK |\r\nAGG_TX_STATE_ABORT_MSK))\r\ncontinue;\r\nD_TX_REPLY("FrameCnt = %d, txq_id=%d idx=%d\n",\r\nagg->frame_count, txq_id, idx);\r\nskb = il->txq[txq_id].skbs[idx];\r\nif (WARN_ON_ONCE(skb == NULL))\r\nreturn -1;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nsc = le16_to_cpu(hdr->seq_ctrl);\r\nif (idx != (IEEE80211_SEQ_TO_SN(sc) & 0xff)) {\r\nIL_ERR("BUG_ON idx doesn't match seq control"\r\n" idx=%d, seq_idx=%d, seq=%d\n", idx,\r\nIEEE80211_SEQ_TO_SN(sc), hdr->seq_ctrl);\r\nreturn -1;\r\n}\r\nD_TX_REPLY("AGG Frame i=%d idx %d seq=%d\n", i, idx,\r\nIEEE80211_SEQ_TO_SN(sc));\r\nsh = idx - start;\r\nif (sh > 64) {\r\nsh = (start - idx) + 0xff;\r\nbitmap = bitmap << sh;\r\nsh = 0;\r\nstart = idx;\r\n} else if (sh < -64)\r\nsh = 0xff - (start - idx);\r\nelse if (sh < 0) {\r\nsh = start - idx;\r\nstart = idx;\r\nbitmap = bitmap << sh;\r\nsh = 0;\r\n}\r\nbitmap |= 1ULL << sh;\r\nD_TX_REPLY("start=%d bitmap=0x%llx\n", start,\r\n(unsigned long long)bitmap);\r\n}\r\nagg->bitmap = bitmap;\r\nagg->start_idx = start;\r\nD_TX_REPLY("Frames %d start_idx=%d bitmap=0x%llx\n",\r\nagg->frame_count, agg->start_idx,\r\n(unsigned long long)agg->bitmap);\r\nif (bitmap)\r\nagg->wait_for_ba = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_hdl_tx(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nu16 sequence = le16_to_cpu(pkt->hdr.sequence);\r\nint txq_id = SEQ_TO_QUEUE(sequence);\r\nint idx = SEQ_TO_IDX(sequence);\r\nstruct il_tx_queue *txq = &il->txq[txq_id];\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nstruct ieee80211_tx_info *info;\r\nstruct il4965_tx_resp *tx_resp = (void *)&pkt->u.raw[0];\r\nu32 status = le32_to_cpu(tx_resp->u.status);\r\nint uninitialized_var(tid);\r\nint sta_id;\r\nint freed;\r\nu8 *qc = NULL;\r\nunsigned long flags;\r\nif (idx >= txq->q.n_bd || il_queue_used(&txq->q, idx) == 0) {\r\nIL_ERR("Read idx for DMA queue txq_id (%d) idx %d "\r\n"is out of range [0-%d] %d %d\n", txq_id, idx,\r\ntxq->q.n_bd, txq->q.write_ptr, txq->q.read_ptr);\r\nreturn;\r\n}\r\ntxq->time_stamp = jiffies;\r\nskb = txq->skbs[txq->q.read_ptr];\r\ninfo = IEEE80211_SKB_CB(skb);\r\nmemset(&info->status, 0, sizeof(info->status));\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (ieee80211_is_data_qos(hdr->frame_control)) {\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\n}\r\nsta_id = il4965_get_ra_sta_id(il, hdr);\r\nif (txq->sched_retry && unlikely(sta_id == IL_INVALID_STATION)) {\r\nIL_ERR("Station not known\n");\r\nreturn;\r\n}\r\nif (unlikely((status & TX_STATUS_MSK) == TX_STATUS_FAIL_PASSIVE_NO_RX) &&\r\nil->iw_mode == NL80211_IFTYPE_STATION) {\r\nil_stop_queues_by_reason(il, IL_STOP_REASON_PASSIVE);\r\nD_INFO("Stopped queues - RX waiting on passive channel\n");\r\n}\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nif (txq->sched_retry) {\r\nconst u32 scd_ssn = il4965_get_scd_ssn(tx_resp);\r\nstruct il_ht_agg *agg = NULL;\r\nWARN_ON(!qc);\r\nagg = &il->stations[sta_id].tid[tid].agg;\r\nil4965_tx_status_reply_tx(il, agg, tx_resp, txq_id, idx);\r\nif (tx_resp->frame_count == 1 &&\r\n!il4965_is_tx_success(status))\r\ninfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\r\nif (txq->q.read_ptr != (scd_ssn & 0xff)) {\r\nidx = il_queue_dec_wrap(scd_ssn & 0xff, txq->q.n_bd);\r\nD_TX_REPLY("Retry scheduler reclaim scd_ssn "\r\n"%d idx %d\n", scd_ssn, idx);\r\nfreed = il4965_tx_queue_reclaim(il, txq_id, idx);\r\nif (qc)\r\nil4965_free_tfds_in_queue(il, sta_id, tid,\r\nfreed);\r\nif (il->mac80211_registered &&\r\nil_queue_space(&txq->q) > txq->q.low_mark &&\r\nagg->state != IL_EMPTYING_HW_QUEUE_DELBA)\r\nil_wake_queue(il, txq);\r\n}\r\n} else {\r\ninfo->status.rates[0].count = tx_resp->failure_frame + 1;\r\ninfo->flags |= il4965_tx_status_to_mac80211(status);\r\nil4965_hwrate_to_tx_control(il,\r\nle32_to_cpu(tx_resp->rate_n_flags),\r\ninfo);\r\nD_TX_REPLY("TXQ %d status %s (0x%08x) "\r\n"rate_n_flags 0x%x retries %d\n", txq_id,\r\nil4965_get_tx_fail_reason(status), status,\r\nle32_to_cpu(tx_resp->rate_n_flags),\r\ntx_resp->failure_frame);\r\nfreed = il4965_tx_queue_reclaim(il, txq_id, idx);\r\nif (qc && likely(sta_id != IL_INVALID_STATION))\r\nil4965_free_tfds_in_queue(il, sta_id, tid, freed);\r\nelse if (sta_id == IL_INVALID_STATION)\r\nD_TX_REPLY("Station not known\n");\r\nif (il->mac80211_registered &&\r\nil_queue_space(&txq->q) > txq->q.low_mark)\r\nil_wake_queue(il, txq);\r\n}\r\nif (qc && likely(sta_id != IL_INVALID_STATION))\r\nil4965_txq_check_empty(il, sta_id, tid, txq_id);\r\nil4965_check_abort_status(il, tx_resp->frame_count, status);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\n}\r\nvoid\r\nil4965_hwrate_to_tx_control(struct il_priv *il, u32 rate_n_flags,\r\nstruct ieee80211_tx_info *info)\r\n{\r\nstruct ieee80211_tx_rate *r = &info->status.rates[0];\r\ninfo->status.antenna =\r\n((rate_n_flags & RATE_MCS_ANT_ABC_MSK) >> RATE_MCS_ANT_POS);\r\nif (rate_n_flags & RATE_MCS_HT_MSK)\r\nr->flags |= IEEE80211_TX_RC_MCS;\r\nif (rate_n_flags & RATE_MCS_GF_MSK)\r\nr->flags |= IEEE80211_TX_RC_GREEN_FIELD;\r\nif (rate_n_flags & RATE_MCS_HT40_MSK)\r\nr->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (rate_n_flags & RATE_MCS_DUP_MSK)\r\nr->flags |= IEEE80211_TX_RC_DUP_DATA;\r\nif (rate_n_flags & RATE_MCS_SGI_MSK)\r\nr->flags |= IEEE80211_TX_RC_SHORT_GI;\r\nr->idx = il4965_hwrate_to_mac80211_idx(rate_n_flags, info->band);\r\n}\r\nstatic void\r\nil4965_hdl_compressed_ba(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il_compressed_ba_resp *ba_resp = &pkt->u.compressed_ba;\r\nstruct il_tx_queue *txq = NULL;\r\nstruct il_ht_agg *agg;\r\nint idx;\r\nint sta_id;\r\nint tid;\r\nunsigned long flags;\r\nu16 scd_flow = le16_to_cpu(ba_resp->scd_flow);\r\nu16 ba_resp_scd_ssn = le16_to_cpu(ba_resp->scd_ssn);\r\nif (scd_flow >= il->hw_params.max_txq_num) {\r\nIL_ERR("BUG_ON scd_flow is bigger than number of queues\n");\r\nreturn;\r\n}\r\ntxq = &il->txq[scd_flow];\r\nsta_id = ba_resp->sta_id;\r\ntid = ba_resp->tid;\r\nagg = &il->stations[sta_id].tid[tid].agg;\r\nif (unlikely(agg->txq_id != scd_flow)) {\r\nD_TX_REPLY("BA scd_flow %d does not match txq_id %d\n",\r\nscd_flow, agg->txq_id);\r\nreturn;\r\n}\r\nidx = il_queue_dec_wrap(ba_resp_scd_ssn & 0xff, txq->q.n_bd);\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nD_TX_REPLY("N_COMPRESSED_BA [%d] Received from %pM, " "sta_id = %d\n",\r\nagg->wait_for_ba, (u8 *) &ba_resp->sta_addr_lo32,\r\nba_resp->sta_id);\r\nD_TX_REPLY("TID = %d, SeqCtl = %d, bitmap = 0x%llx," "scd_flow = "\r\n"%d, scd_ssn = %d\n", ba_resp->tid, ba_resp->seq_ctl,\r\n(unsigned long long)le64_to_cpu(ba_resp->bitmap),\r\nba_resp->scd_flow, ba_resp->scd_ssn);\r\nD_TX_REPLY("DAT start_idx = %d, bitmap = 0x%llx\n", agg->start_idx,\r\n(unsigned long long)agg->bitmap);\r\nil4965_tx_status_reply_compressed_ba(il, agg, ba_resp);\r\nif (txq->q.read_ptr != (ba_resp_scd_ssn & 0xff)) {\r\nint freed = il4965_tx_queue_reclaim(il, scd_flow, idx);\r\nil4965_free_tfds_in_queue(il, sta_id, tid, freed);\r\nif (il_queue_space(&txq->q) > txq->q.low_mark &&\r\nil->mac80211_registered &&\r\nagg->state != IL_EMPTYING_HW_QUEUE_DELBA)\r\nil_wake_queue(il, txq);\r\nil4965_txq_check_empty(il, sta_id, tid, scd_flow);\r\n}\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\n}\r\nconst char *\r\nil4965_get_tx_fail_reason(u32 status)\r\n{\r\n#define TX_STATUS_FAIL(x) case TX_STATUS_FAIL_ ## x: return #x\r\n#define TX_STATUS_POSTPONE(x) case TX_STATUS_POSTPONE_ ## x: return #x\r\nswitch (status & TX_STATUS_MSK) {\r\ncase TX_STATUS_SUCCESS:\r\nreturn "SUCCESS";\r\nTX_STATUS_POSTPONE(DELAY);\r\nTX_STATUS_POSTPONE(FEW_BYTES);\r\nTX_STATUS_POSTPONE(QUIET_PERIOD);\r\nTX_STATUS_POSTPONE(CALC_TTAK);\r\nTX_STATUS_FAIL(INTERNAL_CROSSED_RETRY);\r\nTX_STATUS_FAIL(SHORT_LIMIT);\r\nTX_STATUS_FAIL(LONG_LIMIT);\r\nTX_STATUS_FAIL(FIFO_UNDERRUN);\r\nTX_STATUS_FAIL(DRAIN_FLOW);\r\nTX_STATUS_FAIL(RFKILL_FLUSH);\r\nTX_STATUS_FAIL(LIFE_EXPIRE);\r\nTX_STATUS_FAIL(DEST_PS);\r\nTX_STATUS_FAIL(HOST_ABORTED);\r\nTX_STATUS_FAIL(BT_RETRY);\r\nTX_STATUS_FAIL(STA_INVALID);\r\nTX_STATUS_FAIL(FRAG_DROPPED);\r\nTX_STATUS_FAIL(TID_DISABLE);\r\nTX_STATUS_FAIL(FIFO_FLUSHED);\r\nTX_STATUS_FAIL(INSUFFICIENT_CF_POLL);\r\nTX_STATUS_FAIL(PASSIVE_NO_RX);\r\nTX_STATUS_FAIL(NO_BEACON_ON_RADAR);\r\n}\r\nreturn "UNKNOWN";\r\n#undef TX_STATUS_FAIL\r\n#undef TX_STATUS_POSTPONE\r\n}\r\nstatic struct il_link_quality_cmd *\r\nil4965_sta_alloc_lq(struct il_priv *il, u8 sta_id)\r\n{\r\nint i, r;\r\nstruct il_link_quality_cmd *link_cmd;\r\nu32 rate_flags = 0;\r\n__le32 rate_n_flags;\r\nlink_cmd = kzalloc(sizeof(struct il_link_quality_cmd), GFP_KERNEL);\r\nif (!link_cmd) {\r\nIL_ERR("Unable to allocate memory for LQ cmd.\n");\r\nreturn NULL;\r\n}\r\nif (il->band == IEEE80211_BAND_5GHZ)\r\nr = RATE_6M_IDX;\r\nelse\r\nr = RATE_1M_IDX;\r\nif (r >= IL_FIRST_CCK_RATE && r <= IL_LAST_CCK_RATE)\r\nrate_flags |= RATE_MCS_CCK_MSK;\r\nrate_flags |=\r\nil4965_first_antenna(il->hw_params.\r\nvalid_tx_ant) << RATE_MCS_ANT_POS;\r\nrate_n_flags = cpu_to_le32(il_rates[r].plcp | rate_flags);\r\nfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\r\nlink_cmd->rs_table[i].rate_n_flags = rate_n_flags;\r\nlink_cmd->general_params.single_stream_ant_msk =\r\nil4965_first_antenna(il->hw_params.valid_tx_ant);\r\nlink_cmd->general_params.dual_stream_ant_msk =\r\nil->hw_params.valid_tx_ant & ~il4965_first_antenna(il->hw_params.\r\nvalid_tx_ant);\r\nif (!link_cmd->general_params.dual_stream_ant_msk) {\r\nlink_cmd->general_params.dual_stream_ant_msk = ANT_AB;\r\n} else if (il4965_num_of_ant(il->hw_params.valid_tx_ant) == 2) {\r\nlink_cmd->general_params.dual_stream_ant_msk =\r\nil->hw_params.valid_tx_ant;\r\n}\r\nlink_cmd->agg_params.agg_dis_start_th = LINK_QUAL_AGG_DISABLE_START_DEF;\r\nlink_cmd->agg_params.agg_time_limit =\r\ncpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\r\nlink_cmd->sta_id = sta_id;\r\nreturn link_cmd;\r\n}\r\nint\r\nil4965_add_bssid_station(struct il_priv *il, const u8 *addr, u8 *sta_id_r)\r\n{\r\nint ret;\r\nu8 sta_id;\r\nstruct il_link_quality_cmd *link_cmd;\r\nunsigned long flags;\r\nif (sta_id_r)\r\n*sta_id_r = IL_INVALID_STATION;\r\nret = il_add_station_common(il, addr, 0, NULL, &sta_id);\r\nif (ret) {\r\nIL_ERR("Unable to add station %pM\n", addr);\r\nreturn ret;\r\n}\r\nif (sta_id_r)\r\n*sta_id_r = sta_id;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].used |= IL_STA_LOCAL;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nlink_cmd = il4965_sta_alloc_lq(il, sta_id);\r\nif (!link_cmd) {\r\nIL_ERR("Unable to initialize rate scaling for station %pM.\n",\r\naddr);\r\nreturn -ENOMEM;\r\n}\r\nret = il_send_lq_cmd(il, link_cmd, CMD_SYNC, true);\r\nif (ret)\r\nIL_ERR("Link quality command failed (%d)\n", ret);\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].lq = link_cmd;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_static_wepkey_cmd(struct il_priv *il, bool send_if_empty)\r\n{\r\nint i;\r\nu8 buff[sizeof(struct il_wep_cmd) +\r\nsizeof(struct il_wep_key) * WEP_KEYS_MAX];\r\nstruct il_wep_cmd *wep_cmd = (struct il_wep_cmd *)buff;\r\nsize_t cmd_size = sizeof(struct il_wep_cmd);\r\nstruct il_host_cmd cmd = {\r\n.id = C_WEPKEY,\r\n.data = wep_cmd,\r\n.flags = CMD_SYNC,\r\n};\r\nbool not_empty = false;\r\nmight_sleep();\r\nmemset(wep_cmd, 0,\r\ncmd_size + (sizeof(struct il_wep_key) * WEP_KEYS_MAX));\r\nfor (i = 0; i < WEP_KEYS_MAX; i++) {\r\nu8 key_size = il->_4965.wep_keys[i].key_size;\r\nwep_cmd->key[i].key_idx = i;\r\nif (key_size) {\r\nwep_cmd->key[i].key_offset = i;\r\nnot_empty = true;\r\n} else\r\nwep_cmd->key[i].key_offset = WEP_INVALID_OFFSET;\r\nwep_cmd->key[i].key_size = key_size;\r\nmemcpy(&wep_cmd->key[i].key[3], il->_4965.wep_keys[i].key, key_size);\r\n}\r\nwep_cmd->global_key_type = WEP_KEY_WEP_TYPE;\r\nwep_cmd->num_keys = WEP_KEYS_MAX;\r\ncmd_size += sizeof(struct il_wep_key) * WEP_KEYS_MAX;\r\ncmd.len = cmd_size;\r\nif (not_empty || send_if_empty)\r\nreturn il_send_cmd(il, &cmd);\r\nelse\r\nreturn 0;\r\n}\r\nint\r\nil4965_restore_default_wep_keys(struct il_priv *il)\r\n{\r\nlockdep_assert_held(&il->mutex);\r\nreturn il4965_static_wepkey_cmd(il, false);\r\n}\r\nint\r\nil4965_remove_default_wep_key(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf)\r\n{\r\nint ret;\r\nint idx = keyconf->keyidx;\r\nlockdep_assert_held(&il->mutex);\r\nD_WEP("Removing default WEP key: idx=%d\n", idx);\r\nmemset(&il->_4965.wep_keys[idx], 0, sizeof(struct il_wep_key));\r\nif (il_is_rfkill(il)) {\r\nD_WEP("Not sending C_WEPKEY command due to RFKILL.\n");\r\nreturn 0;\r\n}\r\nret = il4965_static_wepkey_cmd(il, 1);\r\nD_WEP("Remove default WEP key: idx=%d ret=%d\n", idx, ret);\r\nreturn ret;\r\n}\r\nint\r\nil4965_set_default_wep_key(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf)\r\n{\r\nint ret;\r\nint len = keyconf->keylen;\r\nint idx = keyconf->keyidx;\r\nlockdep_assert_held(&il->mutex);\r\nif (len != WEP_KEY_LEN_128 && len != WEP_KEY_LEN_64) {\r\nD_WEP("Bad WEP key length %d\n", keyconf->keylen);\r\nreturn -EINVAL;\r\n}\r\nkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkeyconf->hw_key_idx = HW_KEY_DEFAULT;\r\nil->stations[IL_AP_ID].keyinfo.cipher = keyconf->cipher;\r\nil->_4965.wep_keys[idx].key_size = len;\r\nmemcpy(&il->_4965.wep_keys[idx].key, &keyconf->key, len);\r\nret = il4965_static_wepkey_cmd(il, false);\r\nD_WEP("Set default WEP key: len=%d idx=%d ret=%d\n", len, idx, ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nil4965_set_wep_dynamic_key_info(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nunsigned long flags;\r\n__le16 key_flags = 0;\r\nstruct il_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&il->mutex);\r\nkeyconf->flags &= ~IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkey_flags |= (STA_KEY_FLG_WEP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nif (keyconf->keylen == WEP_KEY_LEN_128)\r\nkey_flags |= STA_KEY_FLG_KEY_SIZE_MSK;\r\nif (sta_id == il->hw_params.bcast_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\nil->stations[sta_id].keyinfo.keylen = keyconf->keylen;\r\nil->stations[sta_id].keyinfo.keyidx = keyconf->keyidx;\r\nmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\r\nmemcpy(&il->stations[sta_id].sta.key.key[3], keyconf->key,\r\nkeyconf->keylen);\r\nif ((il->stations[sta_id].sta.key.\r\nkey_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\r\nil->stations[sta_id].sta.key.key_offset =\r\nil_get_free_ucode_key_idx(il);\r\nWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\nil->stations[sta_id].sta.key.key_flags = key_flags;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nstatic int\r\nil4965_set_ccmp_dynamic_key_info(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nunsigned long flags;\r\n__le16 key_flags = 0;\r\nstruct il_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&il->mutex);\r\nkey_flags |= (STA_KEY_FLG_CCMP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nif (sta_id == il->hw_params.bcast_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\nil->stations[sta_id].keyinfo.keylen = keyconf->keylen;\r\nmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, keyconf->keylen);\r\nmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, keyconf->keylen);\r\nif ((il->stations[sta_id].sta.key.\r\nkey_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\r\nil->stations[sta_id].sta.key.key_offset =\r\nil_get_free_ucode_key_idx(il);\r\nWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\nil->stations[sta_id].sta.key.key_flags = key_flags;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nstatic int\r\nil4965_set_tkip_dynamic_key_info(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\n__le16 key_flags = 0;\r\nkey_flags |= (STA_KEY_FLG_TKIP | STA_KEY_FLG_MAP_KEY_MSK);\r\nkey_flags |= cpu_to_le16(keyconf->keyidx << STA_KEY_FLG_KEYID_POS);\r\nkey_flags &= ~STA_KEY_FLG_INVALID;\r\nif (sta_id == il->hw_params.bcast_id)\r\nkey_flags |= STA_KEY_MULTICAST_MSK;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nkeyconf->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].keyinfo.cipher = keyconf->cipher;\r\nil->stations[sta_id].keyinfo.keylen = 16;\r\nif ((il->stations[sta_id].sta.key.\r\nkey_flags & STA_KEY_FLG_ENCRYPT_MSK) == STA_KEY_FLG_NO_ENC)\r\nil->stations[sta_id].sta.key.key_offset =\r\nil_get_free_ucode_key_idx(il);\r\nWARN(il->stations[sta_id].sta.key.key_offset == WEP_INVALID_OFFSET,\r\n"no space for a new key");\r\nil->stations[sta_id].sta.key.key_flags = key_flags;\r\nmemcpy(il->stations[sta_id].keyinfo.key, keyconf->key, 16);\r\nmemcpy(il->stations[sta_id].sta.key.key, keyconf->key, 16);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn ret;\r\n}\r\nvoid\r\nil4965_update_tkip_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\r\nstruct ieee80211_sta *sta, u32 iv32, u16 *phase1key)\r\n{\r\nu8 sta_id;\r\nunsigned long flags;\r\nint i;\r\nif (il_scan_cancel(il)) {\r\nreturn;\r\n}\r\nsta_id = il_sta_id_or_broadcast(il, sta);\r\nif (sta_id == IL_INVALID_STATION)\r\nreturn;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].sta.key.tkip_rx_tsc_byte2 = (u8) iv32;\r\nfor (i = 0; i < 5; i++)\r\nil->stations[sta_id].sta.key.tkip_rx_ttak[i] =\r\ncpu_to_le16(phase1key[i]);\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nil_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\n}\r\nint\r\nil4965_remove_dynamic_key(struct il_priv *il,\r\nstruct ieee80211_key_conf *keyconf, u8 sta_id)\r\n{\r\nunsigned long flags;\r\nu16 key_flags;\r\nu8 keyidx;\r\nstruct il_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&il->mutex);\r\nil->_4965.key_mapping_keys--;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nkey_flags = le16_to_cpu(il->stations[sta_id].sta.key.key_flags);\r\nkeyidx = (key_flags >> STA_KEY_FLG_KEYID_POS) & 0x3;\r\nD_WEP("Remove dynamic key: idx=%d sta=%d\n", keyconf->keyidx, sta_id);\r\nif (keyconf->keyidx != keyidx) {\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nif (il->stations[sta_id].sta.key.key_flags & STA_KEY_FLG_INVALID) {\r\nIL_WARN("Removing wrong key %d 0x%x\n", keyconf->keyidx,\r\nkey_flags);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nif (!test_and_clear_bit\r\n(il->stations[sta_id].sta.key.key_offset, &il->ucode_key_table))\r\nIL_ERR("idx %d not used in uCode key table.\n",\r\nil->stations[sta_id].sta.key.key_offset);\r\nmemset(&il->stations[sta_id].keyinfo, 0, sizeof(struct il_hw_key));\r\nmemset(&il->stations[sta_id].sta.key, 0, sizeof(struct il4965_keyinfo));\r\nil->stations[sta_id].sta.key.key_flags =\r\nSTA_KEY_FLG_NO_ENC | STA_KEY_FLG_INVALID;\r\nil->stations[sta_id].sta.key.key_offset = keyconf->hw_key_idx;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_KEY_MASK;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nif (il_is_rfkill(il)) {\r\nD_WEP\r\n("Not sending C_ADD_STA command because RFKILL enabled.\n");\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nint\r\nil4965_set_dynamic_key(struct il_priv *il, struct ieee80211_key_conf *keyconf,\r\nu8 sta_id)\r\n{\r\nint ret;\r\nlockdep_assert_held(&il->mutex);\r\nil->_4965.key_mapping_keys++;\r\nkeyconf->hw_key_idx = HW_KEY_DYNAMIC;\r\nswitch (keyconf->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nret =\r\nil4965_set_ccmp_dynamic_key_info(il, keyconf, sta_id);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nret =\r\nil4965_set_tkip_dynamic_key_info(il, keyconf, sta_id);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nret = il4965_set_wep_dynamic_key_info(il, keyconf, sta_id);\r\nbreak;\r\ndefault:\r\nIL_ERR("Unknown alg: %s cipher = %x\n", __func__,\r\nkeyconf->cipher);\r\nret = -EINVAL;\r\n}\r\nD_WEP("Set dynamic key: cipher=%x len=%d idx=%d sta=%d ret=%d\n",\r\nkeyconf->cipher, keyconf->keylen, keyconf->keyidx, sta_id, ret);\r\nreturn ret;\r\n}\r\nint\r\nil4965_alloc_bcast_station(struct il_priv *il)\r\n{\r\nstruct il_link_quality_cmd *link_cmd;\r\nunsigned long flags;\r\nu8 sta_id;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nsta_id = il_prep_station(il, il_bcast_addr, false, NULL);\r\nif (sta_id == IL_INVALID_STATION) {\r\nIL_ERR("Unable to prepare broadcast station\n");\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nil->stations[sta_id].used |= IL_STA_DRIVER_ACTIVE;\r\nil->stations[sta_id].used |= IL_STA_BCAST;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nlink_cmd = il4965_sta_alloc_lq(il, sta_id);\r\nif (!link_cmd) {\r\nIL_ERR\r\n("Unable to initialize rate scaling for bcast station.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].lq = link_cmd;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nil4965_update_bcast_station(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nstruct il_link_quality_cmd *link_cmd;\r\nu8 sta_id = il->hw_params.bcast_id;\r\nlink_cmd = il4965_sta_alloc_lq(il, sta_id);\r\nif (!link_cmd) {\r\nIL_ERR("Unable to initialize rate scaling for bcast sta.\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nif (il->stations[sta_id].lq)\r\nkfree(il->stations[sta_id].lq);\r\nelse\r\nD_INFO("Bcast sta rate scaling has not been initialized.\n");\r\nil->stations[sta_id].lq = link_cmd;\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn 0;\r\n}\r\nint\r\nil4965_update_bcast_stations(struct il_priv *il)\r\n{\r\nreturn il4965_update_bcast_station(il);\r\n}\r\nint\r\nil4965_sta_tx_modify_enable_tid(struct il_priv *il, int sta_id, int tid)\r\n{\r\nunsigned long flags;\r\nstruct il_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&il->mutex);\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_TID_DISABLE_TX;\r\nil->stations[sta_id].sta.tid_disable_tx &= cpu_to_le16(~(1 << tid));\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nint\r\nil4965_sta_rx_agg_start(struct il_priv *il, struct ieee80211_sta *sta, int tid,\r\nu16 ssn)\r\n{\r\nunsigned long flags;\r\nint sta_id;\r\nstruct il_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&il->mutex);\r\nsta_id = il_sta_id(sta);\r\nif (sta_id == IL_INVALID_STATION)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].sta.station_flags_msk = 0;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_ADDBA_TID_MSK;\r\nil->stations[sta_id].sta.add_immediate_ba_tid = (u8) tid;\r\nil->stations[sta_id].sta.add_immediate_ba_ssn = cpu_to_le16(ssn);\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nint\r\nil4965_sta_rx_agg_stop(struct il_priv *il, struct ieee80211_sta *sta, int tid)\r\n{\r\nunsigned long flags;\r\nint sta_id;\r\nstruct il_addsta_cmd sta_cmd;\r\nlockdep_assert_held(&il->mutex);\r\nsta_id = il_sta_id(sta);\r\nif (sta_id == IL_INVALID_STATION) {\r\nIL_ERR("Invalid station for AGG tid %d\n", tid);\r\nreturn -ENXIO;\r\n}\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].sta.station_flags_msk = 0;\r\nil->stations[sta_id].sta.sta.modify_mask = STA_MODIFY_DELBA_TID_MSK;\r\nil->stations[sta_id].sta.remove_immediate_ba_tid = (u8) tid;\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nmemcpy(&sta_cmd, &il->stations[sta_id].sta,\r\nsizeof(struct il_addsta_cmd));\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\nreturn il_send_add_sta(il, &sta_cmd, CMD_SYNC);\r\n}\r\nvoid\r\nil4965_sta_modify_sleep_tx_count(struct il_priv *il, int sta_id, int cnt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&il->sta_lock, flags);\r\nil->stations[sta_id].sta.station_flags |= STA_FLG_PWR_SAVE_MSK;\r\nil->stations[sta_id].sta.station_flags_msk = STA_FLG_PWR_SAVE_MSK;\r\nil->stations[sta_id].sta.sta.modify_mask =\r\nSTA_MODIFY_SLEEP_TX_COUNT_MSK;\r\nil->stations[sta_id].sta.sleep_tx_count = cpu_to_le16(cnt);\r\nil->stations[sta_id].sta.mode = STA_CONTROL_MODIFY_MSK;\r\nil_send_add_sta(il, &il->stations[sta_id].sta, CMD_ASYNC);\r\nspin_unlock_irqrestore(&il->sta_lock, flags);\r\n}\r\nvoid\r\nil4965_update_chain_flags(struct il_priv *il)\r\n{\r\nif (il->ops->set_rxon_chain) {\r\nil->ops->set_rxon_chain(il);\r\nif (il->active.rx_chain != il->staging.rx_chain)\r\nil_commit_rxon(il);\r\n}\r\n}\r\nstatic void\r\nil4965_clear_free_frames(struct il_priv *il)\r\n{\r\nstruct list_head *element;\r\nD_INFO("%d frames on pre-allocated heap on clear.\n", il->frames_count);\r\nwhile (!list_empty(&il->free_frames)) {\r\nelement = il->free_frames.next;\r\nlist_del(element);\r\nkfree(list_entry(element, struct il_frame, list));\r\nil->frames_count--;\r\n}\r\nif (il->frames_count) {\r\nIL_WARN("%d frames still in use. Did we lose one?\n",\r\nil->frames_count);\r\nil->frames_count = 0;\r\n}\r\n}\r\nstatic struct il_frame *\r\nil4965_get_free_frame(struct il_priv *il)\r\n{\r\nstruct il_frame *frame;\r\nstruct list_head *element;\r\nif (list_empty(&il->free_frames)) {\r\nframe = kzalloc(sizeof(*frame), GFP_KERNEL);\r\nif (!frame) {\r\nIL_ERR("Could not allocate frame!\n");\r\nreturn NULL;\r\n}\r\nil->frames_count++;\r\nreturn frame;\r\n}\r\nelement = il->free_frames.next;\r\nlist_del(element);\r\nreturn list_entry(element, struct il_frame, list);\r\n}\r\nstatic void\r\nil4965_free_frame(struct il_priv *il, struct il_frame *frame)\r\n{\r\nmemset(frame, 0, sizeof(*frame));\r\nlist_add(&frame->list, &il->free_frames);\r\n}\r\nstatic u32\r\nil4965_fill_beacon_frame(struct il_priv *il, struct ieee80211_hdr *hdr,\r\nint left)\r\n{\r\nlockdep_assert_held(&il->mutex);\r\nif (!il->beacon_skb)\r\nreturn 0;\r\nif (il->beacon_skb->len > left)\r\nreturn 0;\r\nmemcpy(hdr, il->beacon_skb->data, il->beacon_skb->len);\r\nreturn il->beacon_skb->len;\r\n}\r\nstatic void\r\nil4965_set_beacon_tim(struct il_priv *il,\r\nstruct il_tx_beacon_cmd *tx_beacon_cmd, u8 * beacon,\r\nu32 frame_size)\r\n{\r\nu16 tim_idx;\r\nstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)beacon;\r\ntim_idx = mgmt->u.beacon.variable - beacon;\r\nwhile ((tim_idx < (frame_size - 2)) &&\r\n(beacon[tim_idx] != WLAN_EID_TIM))\r\ntim_idx += beacon[tim_idx + 1] + 2;\r\nif ((tim_idx < (frame_size - 1)) && (beacon[tim_idx] == WLAN_EID_TIM)) {\r\ntx_beacon_cmd->tim_idx = cpu_to_le16(tim_idx);\r\ntx_beacon_cmd->tim_size = beacon[tim_idx + 1];\r\n} else\r\nIL_WARN("Unable to find TIM Element in beacon\n");\r\n}\r\nstatic unsigned int\r\nil4965_hw_get_beacon_cmd(struct il_priv *il, struct il_frame *frame)\r\n{\r\nstruct il_tx_beacon_cmd *tx_beacon_cmd;\r\nu32 frame_size;\r\nu32 rate_flags;\r\nu32 rate;\r\nlockdep_assert_held(&il->mutex);\r\nif (!il->beacon_enabled) {\r\nIL_ERR("Trying to build beacon without beaconing enabled\n");\r\nreturn 0;\r\n}\r\ntx_beacon_cmd = &frame->u.beacon;\r\nmemset(tx_beacon_cmd, 0, sizeof(*tx_beacon_cmd));\r\nframe_size =\r\nil4965_fill_beacon_frame(il, tx_beacon_cmd->frame,\r\nsizeof(frame->u) - sizeof(*tx_beacon_cmd));\r\nif (WARN_ON_ONCE(frame_size > MAX_MPDU_SIZE))\r\nreturn 0;\r\nif (!frame_size)\r\nreturn 0;\r\ntx_beacon_cmd->tx.len = cpu_to_le16((u16) frame_size);\r\ntx_beacon_cmd->tx.sta_id = il->hw_params.bcast_id;\r\ntx_beacon_cmd->tx.stop_time.life_time = TX_CMD_LIFE_TIME_INFINITE;\r\ntx_beacon_cmd->tx.tx_flags =\r\nTX_CMD_FLG_SEQ_CTL_MSK | TX_CMD_FLG_TSF_MSK |\r\nTX_CMD_FLG_STA_RATE_MSK;\r\nil4965_set_beacon_tim(il, tx_beacon_cmd, (u8 *) tx_beacon_cmd->frame,\r\nframe_size);\r\nrate = il_get_lowest_plcp(il);\r\nil4965_toggle_tx_ant(il, &il->mgmt_tx_ant, il->hw_params.valid_tx_ant);\r\nrate_flags = BIT(il->mgmt_tx_ant) << RATE_MCS_ANT_POS;\r\nif ((rate >= IL_FIRST_CCK_RATE) && (rate <= IL_LAST_CCK_RATE))\r\nrate_flags |= RATE_MCS_CCK_MSK;\r\ntx_beacon_cmd->tx.rate_n_flags = cpu_to_le32(rate | rate_flags);\r\nreturn sizeof(*tx_beacon_cmd) + frame_size;\r\n}\r\nint\r\nil4965_send_beacon_cmd(struct il_priv *il)\r\n{\r\nstruct il_frame *frame;\r\nunsigned int frame_size;\r\nint rc;\r\nframe = il4965_get_free_frame(il);\r\nif (!frame) {\r\nIL_ERR("Could not obtain free frame buffer for beacon "\r\n"command.\n");\r\nreturn -ENOMEM;\r\n}\r\nframe_size = il4965_hw_get_beacon_cmd(il, frame);\r\nif (!frame_size) {\r\nIL_ERR("Error configuring the beacon command\n");\r\nil4965_free_frame(il, frame);\r\nreturn -EINVAL;\r\n}\r\nrc = il_send_cmd_pdu(il, C_TX_BEACON, frame_size, &frame->u.cmd[0]);\r\nil4965_free_frame(il, frame);\r\nreturn rc;\r\n}\r\nstatic inline dma_addr_t\r\nil4965_tfd_tb_get_addr(struct il_tfd *tfd, u8 idx)\r\n{\r\nstruct il_tfd_tb *tb = &tfd->tbs[idx];\r\ndma_addr_t addr = get_unaligned_le32(&tb->lo);\r\nif (sizeof(dma_addr_t) > sizeof(u32))\r\naddr |=\r\n((dma_addr_t) (le16_to_cpu(tb->hi_n_len) & 0xF) << 16) <<\r\n16;\r\nreturn addr;\r\n}\r\nstatic inline u16\r\nil4965_tfd_tb_get_len(struct il_tfd *tfd, u8 idx)\r\n{\r\nstruct il_tfd_tb *tb = &tfd->tbs[idx];\r\nreturn le16_to_cpu(tb->hi_n_len) >> 4;\r\n}\r\nstatic inline void\r\nil4965_tfd_set_tb(struct il_tfd *tfd, u8 idx, dma_addr_t addr, u16 len)\r\n{\r\nstruct il_tfd_tb *tb = &tfd->tbs[idx];\r\nu16 hi_n_len = len << 4;\r\nput_unaligned_le32(addr, &tb->lo);\r\nif (sizeof(dma_addr_t) > sizeof(u32))\r\nhi_n_len |= ((addr >> 16) >> 16) & 0xF;\r\ntb->hi_n_len = cpu_to_le16(hi_n_len);\r\ntfd->num_tbs = idx + 1;\r\n}\r\nstatic inline u8\r\nil4965_tfd_get_num_tbs(struct il_tfd *tfd)\r\n{\r\nreturn tfd->num_tbs & 0x1f;\r\n}\r\nvoid\r\nil4965_hw_txq_free_tfd(struct il_priv *il, struct il_tx_queue *txq)\r\n{\r\nstruct il_tfd *tfd_tmp = (struct il_tfd *)txq->tfds;\r\nstruct il_tfd *tfd;\r\nstruct pci_dev *dev = il->pci_dev;\r\nint idx = txq->q.read_ptr;\r\nint i;\r\nint num_tbs;\r\ntfd = &tfd_tmp[idx];\r\nnum_tbs = il4965_tfd_get_num_tbs(tfd);\r\nif (num_tbs >= IL_NUM_OF_TBS) {\r\nIL_ERR("Too many chunks: %i\n", num_tbs);\r\nreturn;\r\n}\r\nif (num_tbs)\r\npci_unmap_single(dev, dma_unmap_addr(&txq->meta[idx], mapping),\r\ndma_unmap_len(&txq->meta[idx], len),\r\nPCI_DMA_BIDIRECTIONAL);\r\nfor (i = 1; i < num_tbs; i++)\r\npci_unmap_single(dev, il4965_tfd_tb_get_addr(tfd, i),\r\nil4965_tfd_tb_get_len(tfd, i),\r\nPCI_DMA_TODEVICE);\r\nif (txq->skbs) {\r\nstruct sk_buff *skb = txq->skbs[txq->q.read_ptr];\r\nif (skb) {\r\ndev_kfree_skb_any(skb);\r\ntxq->skbs[txq->q.read_ptr] = NULL;\r\n}\r\n}\r\n}\r\nint\r\nil4965_hw_txq_attach_buf_to_tfd(struct il_priv *il, struct il_tx_queue *txq,\r\ndma_addr_t addr, u16 len, u8 reset, u8 pad)\r\n{\r\nstruct il_queue *q;\r\nstruct il_tfd *tfd, *tfd_tmp;\r\nu32 num_tbs;\r\nq = &txq->q;\r\ntfd_tmp = (struct il_tfd *)txq->tfds;\r\ntfd = &tfd_tmp[q->write_ptr];\r\nif (reset)\r\nmemset(tfd, 0, sizeof(*tfd));\r\nnum_tbs = il4965_tfd_get_num_tbs(tfd);\r\nif (num_tbs >= IL_NUM_OF_TBS) {\r\nIL_ERR("Error can not send more than %d chunks\n",\r\nIL_NUM_OF_TBS);\r\nreturn -EINVAL;\r\n}\r\nBUG_ON(addr & ~DMA_BIT_MASK(36));\r\nif (unlikely(addr & ~IL_TX_DMA_MASK))\r\nIL_ERR("Unaligned address = %llx\n", (unsigned long long)addr);\r\nil4965_tfd_set_tb(tfd, num_tbs, addr, len);\r\nreturn 0;\r\n}\r\nint\r\nil4965_hw_tx_queue_init(struct il_priv *il, struct il_tx_queue *txq)\r\n{\r\nint txq_id = txq->q.id;\r\nil_wr(il, FH49_MEM_CBBC_QUEUE(txq_id), txq->q.dma_addr >> 8);\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_hdl_alive(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il_alive_resp *palive;\r\nstruct delayed_work *pwork;\r\npalive = &pkt->u.alive_frame;\r\nD_INFO("Alive ucode status 0x%08X revision " "0x%01X 0x%01X\n",\r\npalive->is_valid, palive->ver_type, palive->ver_subtype);\r\nif (palive->ver_subtype == INITIALIZE_SUBTYPE) {\r\nD_INFO("Initialization Alive received.\n");\r\nmemcpy(&il->card_alive_init, &pkt->u.alive_frame,\r\nsizeof(struct il_init_alive_resp));\r\npwork = &il->init_alive_start;\r\n} else {\r\nD_INFO("Runtime Alive received.\n");\r\nmemcpy(&il->card_alive, &pkt->u.alive_frame,\r\nsizeof(struct il_alive_resp));\r\npwork = &il->alive_start;\r\n}\r\nif (palive->is_valid == UCODE_VALID_OK)\r\nqueue_delayed_work(il->workqueue, pwork, msecs_to_jiffies(5));\r\nelse\r\nIL_WARN("uCode did not respond OK.\n");\r\n}\r\nstatic void\r\nil4965_bg_stats_periodic(unsigned long data)\r\n{\r\nstruct il_priv *il = (struct il_priv *)data;\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nif (!il_is_ready_rf(il))\r\nreturn;\r\nil_send_stats_request(il, CMD_ASYNC, false);\r\n}\r\nstatic void\r\nil4965_hdl_beacon(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nstruct il4965_beacon_notif *beacon =\r\n(struct il4965_beacon_notif *)pkt->u.raw;\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nu8 rate = il4965_hw_get_rate(beacon->beacon_notify_hdr.rate_n_flags);\r\nD_RX("beacon status %x retries %d iss %d tsf:0x%.8x%.8x rate %d\n",\r\nle32_to_cpu(beacon->beacon_notify_hdr.u.status) & TX_STATUS_MSK,\r\nbeacon->beacon_notify_hdr.failure_frame,\r\nle32_to_cpu(beacon->ibss_mgr_status),\r\nle32_to_cpu(beacon->high_tsf), le32_to_cpu(beacon->low_tsf), rate);\r\n#endif\r\nil->ibss_manager = le32_to_cpu(beacon->ibss_mgr_status);\r\n}\r\nstatic void\r\nil4965_perform_ct_kill_task(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nD_POWER("Stop all queues\n");\r\nif (il->mac80211_registered)\r\nieee80211_stop_queues(il->hw);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_SET,\r\nCSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\r\n_il_rd(il, CSR_UCODE_DRV_GP1);\r\nspin_lock_irqsave(&il->reg_lock, flags);\r\nif (likely(_il_grab_nic_access(il)))\r\n_il_release_nic_access(il);\r\nspin_unlock_irqrestore(&il->reg_lock, flags);\r\n}\r\nstatic void\r\nil4965_hdl_card_state(struct il_priv *il, struct il_rx_buf *rxb)\r\n{\r\nstruct il_rx_pkt *pkt = rxb_addr(rxb);\r\nu32 flags = le32_to_cpu(pkt->u.card_state_notif.flags);\r\nunsigned long status = il->status;\r\nD_RF_KILL("Card state received: HW:%s SW:%s CT:%s\n",\r\n(flags & HW_CARD_DISABLED) ? "Kill" : "On",\r\n(flags & SW_CARD_DISABLED) ? "Kill" : "On",\r\n(flags & CT_CARD_DISABLED) ? "Reached" : "Not reached");\r\nif (flags & (SW_CARD_DISABLED | HW_CARD_DISABLED | CT_CARD_DISABLED)) {\r\n_il_wr(il, CSR_UCODE_DRV_GP1_SET,\r\nCSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\r\nil_wr(il, HBUS_TARG_MBX_C, HBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\r\nif (!(flags & RXON_CARD_DISABLED)) {\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR,\r\nCSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\r\nil_wr(il, HBUS_TARG_MBX_C,\r\nHBUS_TARG_MBX_C_REG_BIT_CMD_BLOCKED);\r\n}\r\n}\r\nif (flags & CT_CARD_DISABLED)\r\nil4965_perform_ct_kill_task(il);\r\nif (flags & HW_CARD_DISABLED)\r\nset_bit(S_RFKILL, &il->status);\r\nelse\r\nclear_bit(S_RFKILL, &il->status);\r\nif (!(flags & RXON_CARD_DISABLED))\r\nil_scan_cancel(il);\r\nif ((test_bit(S_RFKILL, &status) !=\r\ntest_bit(S_RFKILL, &il->status)))\r\nwiphy_rfkill_set_hw_state(il->hw->wiphy,\r\ntest_bit(S_RFKILL, &il->status));\r\nelse\r\nwake_up(&il->wait_command_queue);\r\n}\r\nstatic void\r\nil4965_setup_handlers(struct il_priv *il)\r\n{\r\nil->handlers[N_ALIVE] = il4965_hdl_alive;\r\nil->handlers[N_ERROR] = il_hdl_error;\r\nil->handlers[N_CHANNEL_SWITCH] = il_hdl_csa;\r\nil->handlers[N_SPECTRUM_MEASUREMENT] = il_hdl_spectrum_measurement;\r\nil->handlers[N_PM_SLEEP] = il_hdl_pm_sleep;\r\nil->handlers[N_PM_DEBUG_STATS] = il_hdl_pm_debug_stats;\r\nil->handlers[N_BEACON] = il4965_hdl_beacon;\r\nil->handlers[C_STATS] = il4965_hdl_c_stats;\r\nil->handlers[N_STATS] = il4965_hdl_stats;\r\nil_setup_rx_scan_handlers(il);\r\nil->handlers[N_CARD_STATE] = il4965_hdl_card_state;\r\nil->handlers[N_MISSED_BEACONS] = il4965_hdl_missed_beacon;\r\nil->handlers[N_RX_PHY] = il4965_hdl_rx_phy;\r\nil->handlers[N_RX_MPDU] = il4965_hdl_rx;\r\nil->handlers[N_RX] = il4965_hdl_rx;\r\nil->handlers[N_COMPRESSED_BA] = il4965_hdl_compressed_ba;\r\nil->handlers[C_TX] = il4965_hdl_tx;\r\n}\r\nvoid\r\nil4965_rx_handle(struct il_priv *il)\r\n{\r\nstruct il_rx_buf *rxb;\r\nstruct il_rx_pkt *pkt;\r\nstruct il_rx_queue *rxq = &il->rxq;\r\nu32 r, i;\r\nint reclaim;\r\nunsigned long flags;\r\nu8 fill_rx = 0;\r\nu32 count = 8;\r\nint total_empty;\r\nr = le16_to_cpu(rxq->rb_stts->closed_rb_num) & 0x0FFF;\r\ni = rxq->read;\r\nif (i == r)\r\nD_RX("r = %d, i = %d\n", r, i);\r\ntotal_empty = r - rxq->write_actual;\r\nif (total_empty < 0)\r\ntotal_empty += RX_QUEUE_SIZE;\r\nif (total_empty > (RX_QUEUE_SIZE / 2))\r\nfill_rx = 1;\r\nwhile (i != r) {\r\nint len;\r\nrxb = rxq->queue[i];\r\nBUG_ON(rxb == NULL);\r\nrxq->queue[i] = NULL;\r\npci_unmap_page(il->pci_dev, rxb->page_dma,\r\nPAGE_SIZE << il->hw_params.rx_page_order,\r\nPCI_DMA_FROMDEVICE);\r\npkt = rxb_addr(rxb);\r\nlen = le32_to_cpu(pkt->len_n_flags) & IL_RX_FRAME_SIZE_MSK;\r\nlen += sizeof(u32);\r\nreclaim = il_need_reclaim(il, pkt);\r\nif (il->handlers[pkt->hdr.cmd]) {\r\nD_RX("r = %d, i = %d, %s, 0x%02x\n", r, i,\r\nil_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\r\nil->isr_stats.handlers[pkt->hdr.cmd]++;\r\nil->handlers[pkt->hdr.cmd] (il, rxb);\r\n} else {\r\nD_RX("r %d i %d No handler needed for %s, 0x%02x\n", r,\r\ni, il_get_cmd_string(pkt->hdr.cmd), pkt->hdr.cmd);\r\n}\r\nif (reclaim) {\r\nif (rxb->page)\r\nil_tx_cmd_complete(il, rxb);\r\nelse\r\nIL_WARN("Claim null rxb?\n");\r\n}\r\nspin_lock_irqsave(&rxq->lock, flags);\r\nif (rxb->page != NULL) {\r\nrxb->page_dma =\r\npci_map_page(il->pci_dev, rxb->page, 0,\r\nPAGE_SIZE << il->hw_params.\r\nrx_page_order, PCI_DMA_FROMDEVICE);\r\nif (unlikely(pci_dma_mapping_error(il->pci_dev,\r\nrxb->page_dma))) {\r\n__il_free_pages(il, rxb->page);\r\nrxb->page = NULL;\r\nlist_add_tail(&rxb->list, &rxq->rx_used);\r\n} else {\r\nlist_add_tail(&rxb->list, &rxq->rx_free);\r\nrxq->free_count++;\r\n}\r\n} else\r\nlist_add_tail(&rxb->list, &rxq->rx_used);\r\nspin_unlock_irqrestore(&rxq->lock, flags);\r\ni = (i + 1) & RX_QUEUE_MASK;\r\nif (fill_rx) {\r\ncount++;\r\nif (count >= 8) {\r\nrxq->read = i;\r\nil4965_rx_replenish_now(il);\r\ncount = 0;\r\n}\r\n}\r\n}\r\nrxq->read = i;\r\nif (fill_rx)\r\nil4965_rx_replenish_now(il);\r\nelse\r\nil4965_rx_queue_restock(il);\r\n}\r\nstatic inline void\r\nil4965_synchronize_irq(struct il_priv *il)\r\n{\r\nsynchronize_irq(il->pci_dev->irq);\r\ntasklet_kill(&il->irq_tasklet);\r\n}\r\nstatic void\r\nil4965_irq_tasklet(struct il_priv *il)\r\n{\r\nu32 inta, handled = 0;\r\nu32 inta_fh;\r\nunsigned long flags;\r\nu32 i;\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nu32 inta_mask;\r\n#endif\r\nspin_lock_irqsave(&il->lock, flags);\r\ninta = _il_rd(il, CSR_INT);\r\n_il_wr(il, CSR_INT, inta);\r\ninta_fh = _il_rd(il, CSR_FH_INT_STATUS);\r\n_il_wr(il, CSR_FH_INT_STATUS, inta_fh);\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (il_get_debug_level(il) & IL_DL_ISR) {\r\ninta_mask = _il_rd(il, CSR_INT_MASK);\r\nD_ISR("inta 0x%08x, enabled 0x%08x, fh 0x%08x\n", inta,\r\ninta_mask, inta_fh);\r\n}\r\n#endif\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nif (inta_fh & CSR49_FH_INT_RX_MASK)\r\ninta |= CSR_INT_BIT_FH_RX;\r\nif (inta_fh & CSR49_FH_INT_TX_MASK)\r\ninta |= CSR_INT_BIT_FH_TX;\r\nif (inta & CSR_INT_BIT_HW_ERR) {\r\nIL_ERR("Hardware error detected. Restarting.\n");\r\nil_disable_interrupts(il);\r\nil->isr_stats.hw++;\r\nil_irq_handle_error(il);\r\nhandled |= CSR_INT_BIT_HW_ERR;\r\nreturn;\r\n}\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (il_get_debug_level(il) & (IL_DL_ISR)) {\r\nif (inta & CSR_INT_BIT_SCD) {\r\nD_ISR("Scheduler finished to transmit "\r\n"the frame/frames.\n");\r\nil->isr_stats.sch++;\r\n}\r\nif (inta & CSR_INT_BIT_ALIVE) {\r\nD_ISR("Alive interrupt\n");\r\nil->isr_stats.alive++;\r\n}\r\n}\r\n#endif\r\ninta &= ~(CSR_INT_BIT_SCD | CSR_INT_BIT_ALIVE);\r\nif (inta & CSR_INT_BIT_RF_KILL) {\r\nint hw_rf_kill = 0;\r\nif (!(_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW))\r\nhw_rf_kill = 1;\r\nIL_WARN("RF_KILL bit toggled to %s.\n",\r\nhw_rf_kill ? "disable radio" : "enable radio");\r\nil->isr_stats.rfkill++;\r\nif (hw_rf_kill) {\r\nset_bit(S_RFKILL, &il->status);\r\n} else {\r\nclear_bit(S_RFKILL, &il->status);\r\nil_force_reset(il, true);\r\n}\r\nwiphy_rfkill_set_hw_state(il->hw->wiphy, hw_rf_kill);\r\nhandled |= CSR_INT_BIT_RF_KILL;\r\n}\r\nif (inta & CSR_INT_BIT_CT_KILL) {\r\nIL_ERR("Microcode CT kill error detected.\n");\r\nil->isr_stats.ctkill++;\r\nhandled |= CSR_INT_BIT_CT_KILL;\r\n}\r\nif (inta & CSR_INT_BIT_SW_ERR) {\r\nIL_ERR("Microcode SW error detected. " " Restarting 0x%X.\n",\r\ninta);\r\nil->isr_stats.sw++;\r\nil_irq_handle_error(il);\r\nhandled |= CSR_INT_BIT_SW_ERR;\r\n}\r\nif (inta & CSR_INT_BIT_WAKEUP) {\r\nD_ISR("Wakeup interrupt\n");\r\nil_rx_queue_update_write_ptr(il, &il->rxq);\r\nfor (i = 0; i < il->hw_params.max_txq_num; i++)\r\nil_txq_update_write_ptr(il, &il->txq[i]);\r\nil->isr_stats.wakeup++;\r\nhandled |= CSR_INT_BIT_WAKEUP;\r\n}\r\nif (inta & (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX)) {\r\nil4965_rx_handle(il);\r\nil->isr_stats.rx++;\r\nhandled |= (CSR_INT_BIT_FH_RX | CSR_INT_BIT_SW_RX);\r\n}\r\nif (inta & CSR_INT_BIT_FH_TX) {\r\nD_ISR("uCode load interrupt\n");\r\nil->isr_stats.tx++;\r\nhandled |= CSR_INT_BIT_FH_TX;\r\nil->ucode_write_complete = 1;\r\nwake_up(&il->wait_command_queue);\r\n}\r\nif (inta & ~handled) {\r\nIL_ERR("Unhandled INTA bits 0x%08x\n", inta & ~handled);\r\nil->isr_stats.unhandled++;\r\n}\r\nif (inta & ~(il->inta_mask)) {\r\nIL_WARN("Disabled INTA bits 0x%08x were pending\n",\r\ninta & ~il->inta_mask);\r\nIL_WARN(" with FH49_INT = 0x%08x\n", inta_fh);\r\n}\r\nif (test_bit(S_INT_ENABLED, &il->status))\r\nil_enable_interrupts(il);\r\nelse if (handled & CSR_INT_BIT_RF_KILL)\r\nil_enable_rfkill_int(il);\r\n#ifdef CONFIG_IWLEGACY_DEBUG\r\nif (il_get_debug_level(il) & (IL_DL_ISR)) {\r\ninta = _il_rd(il, CSR_INT);\r\ninta_mask = _il_rd(il, CSR_INT_MASK);\r\ninta_fh = _il_rd(il, CSR_FH_INT_STATUS);\r\nD_ISR("End inta 0x%08x, enabled 0x%08x, fh 0x%08x, "\r\n"flags 0x%08lx\n", inta, inta_mask, inta_fh, flags);\r\n}\r\n#endif\r\n}\r\nstatic ssize_t\r\nil4965_show_debug_level(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nreturn sprintf(buf, "0x%08X\n", il_get_debug_level(il));\r\n}\r\nstatic ssize_t\r\nil4965_store_debug_level(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nIL_ERR("%s is not in hex or decimal form.\n", buf);\r\nelse\r\nil->debug_level = val;\r\nreturn strnlen(buf, count);\r\n}\r\nstatic ssize_t\r\nil4965_show_temperature(struct device *d, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nif (!il_is_alive(il))\r\nreturn -EAGAIN;\r\nreturn sprintf(buf, "%d\n", il->temperature);\r\n}\r\nstatic ssize_t\r\nil4965_show_tx_power(struct device *d, struct device_attribute *attr, char *buf)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nif (!il_is_ready_rf(il))\r\nreturn sprintf(buf, "off\n");\r\nelse\r\nreturn sprintf(buf, "%d\n", il->tx_power_user_lmt);\r\n}\r\nstatic ssize_t\r\nil4965_store_tx_power(struct device *d, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct il_priv *il = dev_get_drvdata(d);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nIL_INFO("%s is not in decimal form.\n", buf);\r\nelse {\r\nret = il_set_tx_power(il, val, false);\r\nif (ret)\r\nIL_ERR("failed setting tx power (0x%08x).\n", ret);\r\nelse\r\nret = count;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nil4965_dealloc_ucode_pci(struct il_priv *il)\r\n{\r\nil_free_fw_desc(il->pci_dev, &il->ucode_code);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_data);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_data_backup);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_init);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_init_data);\r\nil_free_fw_desc(il->pci_dev, &il->ucode_boot);\r\n}\r\nstatic void\r\nil4965_nic_start(struct il_priv *il)\r\n{\r\n_il_wr(il, CSR_RESET, 0);\r\n}\r\nstatic int __must_check\r\nil4965_request_firmware(struct il_priv *il, bool first)\r\n{\r\nconst char *name_pre = il->cfg->fw_name_pre;\r\nchar tag[8];\r\nif (first) {\r\nil->fw_idx = il->cfg->ucode_api_max;\r\nsprintf(tag, "%d", il->fw_idx);\r\n} else {\r\nil->fw_idx--;\r\nsprintf(tag, "%d", il->fw_idx);\r\n}\r\nif (il->fw_idx < il->cfg->ucode_api_min) {\r\nIL_ERR("no suitable firmware found!\n");\r\nreturn -ENOENT;\r\n}\r\nsprintf(il->firmware_name, "%s%s%s", name_pre, tag, ".ucode");\r\nD_INFO("attempting to load firmware '%s'\n", il->firmware_name);\r\nreturn request_firmware_nowait(THIS_MODULE, 1, il->firmware_name,\r\n&il->pci_dev->dev, GFP_KERNEL, il,\r\nil4965_ucode_callback);\r\n}\r\nstatic int\r\nil4965_load_firmware(struct il_priv *il, const struct firmware *ucode_raw,\r\nstruct il4965_firmware_pieces *pieces)\r\n{\r\nstruct il_ucode_header *ucode = (void *)ucode_raw->data;\r\nu32 api_ver, hdr_size;\r\nconst u8 *src;\r\nil->ucode_ver = le32_to_cpu(ucode->ver);\r\napi_ver = IL_UCODE_API(il->ucode_ver);\r\nswitch (api_ver) {\r\ndefault:\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nhdr_size = 24;\r\nif (ucode_raw->size < hdr_size) {\r\nIL_ERR("File size too small!\n");\r\nreturn -EINVAL;\r\n}\r\npieces->inst_size = le32_to_cpu(ucode->v1.inst_size);\r\npieces->data_size = le32_to_cpu(ucode->v1.data_size);\r\npieces->init_size = le32_to_cpu(ucode->v1.init_size);\r\npieces->init_data_size = le32_to_cpu(ucode->v1.init_data_size);\r\npieces->boot_size = le32_to_cpu(ucode->v1.boot_size);\r\nsrc = ucode->v1.data;\r\nbreak;\r\n}\r\nif (ucode_raw->size !=\r\nhdr_size + pieces->inst_size + pieces->data_size +\r\npieces->init_size + pieces->init_data_size + pieces->boot_size) {\r\nIL_ERR("uCode file size %d does not match expected size\n",\r\n(int)ucode_raw->size);\r\nreturn -EINVAL;\r\n}\r\npieces->inst = src;\r\nsrc += pieces->inst_size;\r\npieces->data = src;\r\nsrc += pieces->data_size;\r\npieces->init = src;\r\nsrc += pieces->init_size;\r\npieces->init_data = src;\r\nsrc += pieces->init_data_size;\r\npieces->boot = src;\r\nsrc += pieces->boot_size;\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_ucode_callback(const struct firmware *ucode_raw, void *context)\r\n{\r\nstruct il_priv *il = context;\r\nstruct il_ucode_header *ucode;\r\nint err;\r\nstruct il4965_firmware_pieces pieces;\r\nconst unsigned int api_max = il->cfg->ucode_api_max;\r\nconst unsigned int api_min = il->cfg->ucode_api_min;\r\nu32 api_ver;\r\nu32 max_probe_length = 200;\r\nu32 standard_phy_calibration_size =\r\nIL_DEFAULT_STANDARD_PHY_CALIBRATE_TBL_SIZE;\r\nmemset(&pieces, 0, sizeof(pieces));\r\nif (!ucode_raw) {\r\nif (il->fw_idx <= il->cfg->ucode_api_max)\r\nIL_ERR("request for firmware file '%s' failed.\n",\r\nil->firmware_name);\r\ngoto try_again;\r\n}\r\nD_INFO("Loaded firmware file '%s' (%zd bytes).\n", il->firmware_name,\r\nucode_raw->size);\r\nif (ucode_raw->size < 4) {\r\nIL_ERR("File size way too small!\n");\r\ngoto try_again;\r\n}\r\nucode = (struct il_ucode_header *)ucode_raw->data;\r\nerr = il4965_load_firmware(il, ucode_raw, &pieces);\r\nif (err)\r\ngoto try_again;\r\napi_ver = IL_UCODE_API(il->ucode_ver);\r\nif (api_ver < api_min || api_ver > api_max) {\r\nIL_ERR("Driver unable to support your firmware API. "\r\n"Driver supports v%u, firmware is v%u.\n", api_max,\r\napi_ver);\r\ngoto try_again;\r\n}\r\nif (api_ver != api_max)\r\nIL_ERR("Firmware has old API version. Expected v%u, "\r\n"got v%u. New firmware can be obtained "\r\n"from http://www.intellinuxwireless.org.\n", api_max,\r\napi_ver);\r\nIL_INFO("loaded firmware version %u.%u.%u.%u\n",\r\nIL_UCODE_MAJOR(il->ucode_ver), IL_UCODE_MINOR(il->ucode_ver),\r\nIL_UCODE_API(il->ucode_ver), IL_UCODE_SERIAL(il->ucode_ver));\r\nsnprintf(il->hw->wiphy->fw_version, sizeof(il->hw->wiphy->fw_version),\r\n"%u.%u.%u.%u", IL_UCODE_MAJOR(il->ucode_ver),\r\nIL_UCODE_MINOR(il->ucode_ver), IL_UCODE_API(il->ucode_ver),\r\nIL_UCODE_SERIAL(il->ucode_ver));\r\nD_INFO("f/w package hdr ucode version raw = 0x%x\n", il->ucode_ver);\r\nD_INFO("f/w package hdr runtime inst size = %Zd\n", pieces.inst_size);\r\nD_INFO("f/w package hdr runtime data size = %Zd\n", pieces.data_size);\r\nD_INFO("f/w package hdr init inst size = %Zd\n", pieces.init_size);\r\nD_INFO("f/w package hdr init data size = %Zd\n", pieces.init_data_size);\r\nD_INFO("f/w package hdr boot inst size = %Zd\n", pieces.boot_size);\r\nif (pieces.inst_size > il->hw_params.max_inst_size) {\r\nIL_ERR("uCode instr len %Zd too large to fit in\n",\r\npieces.inst_size);\r\ngoto try_again;\r\n}\r\nif (pieces.data_size > il->hw_params.max_data_size) {\r\nIL_ERR("uCode data len %Zd too large to fit in\n",\r\npieces.data_size);\r\ngoto try_again;\r\n}\r\nif (pieces.init_size > il->hw_params.max_inst_size) {\r\nIL_ERR("uCode init instr len %Zd too large to fit in\n",\r\npieces.init_size);\r\ngoto try_again;\r\n}\r\nif (pieces.init_data_size > il->hw_params.max_data_size) {\r\nIL_ERR("uCode init data len %Zd too large to fit in\n",\r\npieces.init_data_size);\r\ngoto try_again;\r\n}\r\nif (pieces.boot_size > il->hw_params.max_bsm_size) {\r\nIL_ERR("uCode boot instr len %Zd too large to fit in\n",\r\npieces.boot_size);\r\ngoto try_again;\r\n}\r\nil->ucode_code.len = pieces.inst_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_code);\r\nil->ucode_data.len = pieces.data_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_data);\r\nil->ucode_data_backup.len = pieces.data_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_data_backup);\r\nif (!il->ucode_code.v_addr || !il->ucode_data.v_addr ||\r\n!il->ucode_data_backup.v_addr)\r\ngoto err_pci_alloc;\r\nif (pieces.init_size && pieces.init_data_size) {\r\nil->ucode_init.len = pieces.init_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_init);\r\nil->ucode_init_data.len = pieces.init_data_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_init_data);\r\nif (!il->ucode_init.v_addr || !il->ucode_init_data.v_addr)\r\ngoto err_pci_alloc;\r\n}\r\nif (pieces.boot_size) {\r\nil->ucode_boot.len = pieces.boot_size;\r\nil_alloc_fw_desc(il->pci_dev, &il->ucode_boot);\r\nif (!il->ucode_boot.v_addr)\r\ngoto err_pci_alloc;\r\n}\r\nil->sta_key_max_num = STA_KEY_MAX_NUM;\r\nD_INFO("Copying (but not loading) uCode instr len %Zd\n",\r\npieces.inst_size);\r\nmemcpy(il->ucode_code.v_addr, pieces.inst, pieces.inst_size);\r\nD_INFO("uCode instr buf vaddr = 0x%p, paddr = 0x%08x\n",\r\nil->ucode_code.v_addr, (u32) il->ucode_code.p_addr);\r\nD_INFO("Copying (but not loading) uCode data len %Zd\n",\r\npieces.data_size);\r\nmemcpy(il->ucode_data.v_addr, pieces.data, pieces.data_size);\r\nmemcpy(il->ucode_data_backup.v_addr, pieces.data, pieces.data_size);\r\nif (pieces.init_size) {\r\nD_INFO("Copying (but not loading) init instr len %Zd\n",\r\npieces.init_size);\r\nmemcpy(il->ucode_init.v_addr, pieces.init, pieces.init_size);\r\n}\r\nif (pieces.init_data_size) {\r\nD_INFO("Copying (but not loading) init data len %Zd\n",\r\npieces.init_data_size);\r\nmemcpy(il->ucode_init_data.v_addr, pieces.init_data,\r\npieces.init_data_size);\r\n}\r\nD_INFO("Copying (but not loading) boot instr len %Zd\n",\r\npieces.boot_size);\r\nmemcpy(il->ucode_boot.v_addr, pieces.boot, pieces.boot_size);\r\nil->_4965.phy_calib_chain_noise_reset_cmd =\r\nstandard_phy_calibration_size;\r\nil->_4965.phy_calib_chain_noise_gain_cmd =\r\nstandard_phy_calibration_size + 1;\r\nerr = il4965_mac_setup_register(il, max_probe_length);\r\nif (err)\r\ngoto out_unbind;\r\nerr = il_dbgfs_register(il, DRV_NAME);\r\nif (err)\r\nIL_ERR("failed to create debugfs files. Ignoring error: %d\n",\r\nerr);\r\nerr = sysfs_create_group(&il->pci_dev->dev.kobj, &il_attribute_group);\r\nif (err) {\r\nIL_ERR("failed to create sysfs device attributes\n");\r\ngoto out_unbind;\r\n}\r\nrelease_firmware(ucode_raw);\r\ncomplete(&il->_4965.firmware_loading_complete);\r\nreturn;\r\ntry_again:\r\nif (il4965_request_firmware(il, false))\r\ngoto out_unbind;\r\nrelease_firmware(ucode_raw);\r\nreturn;\r\nerr_pci_alloc:\r\nIL_ERR("failed to allocate pci memory\n");\r\nil4965_dealloc_ucode_pci(il);\r\nout_unbind:\r\ncomplete(&il->_4965.firmware_loading_complete);\r\ndevice_release_driver(&il->pci_dev->dev);\r\nrelease_firmware(ucode_raw);\r\n}\r\nstatic const char *\r\nil4965_desc_lookup(u32 num)\r\n{\r\nint i;\r\nint max = ARRAY_SIZE(desc_lookup_text);\r\nif (num < max)\r\nreturn desc_lookup_text[num];\r\nmax = ARRAY_SIZE(advanced_lookup) - 1;\r\nfor (i = 0; i < max; i++) {\r\nif (advanced_lookup[i].num == num)\r\nbreak;\r\n}\r\nreturn advanced_lookup[i].name;\r\n}\r\nvoid\r\nil4965_dump_nic_error_log(struct il_priv *il)\r\n{\r\nu32 data2, line;\r\nu32 desc, time, count, base, data1;\r\nu32 blink1, blink2, ilink1, ilink2;\r\nu32 pc, hcmd;\r\nif (il->ucode_type == UCODE_INIT)\r\nbase = le32_to_cpu(il->card_alive_init.error_event_table_ptr);\r\nelse\r\nbase = le32_to_cpu(il->card_alive.error_event_table_ptr);\r\nif (!il->ops->is_valid_rtc_data_addr(base)) {\r\nIL_ERR("Not valid error log pointer 0x%08X for %s uCode\n",\r\nbase, (il->ucode_type == UCODE_INIT) ? "Init" : "RT");\r\nreturn;\r\n}\r\ncount = il_read_targ_mem(il, base);\r\nif (ERROR_START_OFFSET <= count * ERROR_ELEM_SIZE) {\r\nIL_ERR("Start IWL Error Log Dump:\n");\r\nIL_ERR("Status: 0x%08lX, count: %d\n", il->status, count);\r\n}\r\ndesc = il_read_targ_mem(il, base + 1 * sizeof(u32));\r\nil->isr_stats.err_code = desc;\r\npc = il_read_targ_mem(il, base + 2 * sizeof(u32));\r\nblink1 = il_read_targ_mem(il, base + 3 * sizeof(u32));\r\nblink2 = il_read_targ_mem(il, base + 4 * sizeof(u32));\r\nilink1 = il_read_targ_mem(il, base + 5 * sizeof(u32));\r\nilink2 = il_read_targ_mem(il, base + 6 * sizeof(u32));\r\ndata1 = il_read_targ_mem(il, base + 7 * sizeof(u32));\r\ndata2 = il_read_targ_mem(il, base + 8 * sizeof(u32));\r\nline = il_read_targ_mem(il, base + 9 * sizeof(u32));\r\ntime = il_read_targ_mem(il, base + 11 * sizeof(u32));\r\nhcmd = il_read_targ_mem(il, base + 22 * sizeof(u32));\r\nIL_ERR("Desc Time "\r\n"data1 data2 line\n");\r\nIL_ERR("%-28s (0x%04X) %010u 0x%08X 0x%08X %u\n",\r\nil4965_desc_lookup(desc), desc, time, data1, data2, line);\r\nIL_ERR("pc blink1 blink2 ilink1 ilink2 hcmd\n");\r\nIL_ERR("0x%05X 0x%05X 0x%05X 0x%05X 0x%05X 0x%05X\n", pc, blink1,\r\nblink2, ilink1, ilink2, hcmd);\r\n}\r\nstatic void\r\nil4965_rf_kill_ct_config(struct il_priv *il)\r\n{\r\nstruct il_ct_kill_config cmd;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&il->lock, flags);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR,\r\nCSR_UCODE_DRV_GP1_REG_BIT_CT_KILL_EXIT);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\ncmd.critical_temperature_R =\r\ncpu_to_le32(il->hw_params.ct_kill_threshold);\r\nret = il_send_cmd_pdu(il, C_CT_KILL_CONFIG, sizeof(cmd), &cmd);\r\nif (ret)\r\nIL_ERR("C_CT_KILL_CONFIG failed\n");\r\nelse\r\nD_INFO("C_CT_KILL_CONFIG " "succeeded, "\r\n"critical temperature is %d\n",\r\nil->hw_params.ct_kill_threshold);\r\n}\r\nstatic int\r\nil4965_alive_notify(struct il_priv *il)\r\n{\r\nu32 a;\r\nunsigned long flags;\r\nint i, chan;\r\nu32 reg_val;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil->scd_base_addr = il_rd_prph(il, IL49_SCD_SRAM_BASE_ADDR);\r\na = il->scd_base_addr + IL49_SCD_CONTEXT_DATA_OFFSET;\r\nfor (; a < il->scd_base_addr + IL49_SCD_TX_STTS_BITMAP_OFFSET; a += 4)\r\nil_write_targ_mem(il, a, 0);\r\nfor (; a < il->scd_base_addr + IL49_SCD_TRANSLATE_TBL_OFFSET; a += 4)\r\nil_write_targ_mem(il, a, 0);\r\nfor (;\r\na <\r\nil->scd_base_addr +\r\nIL49_SCD_TRANSLATE_TBL_OFFSET_QUEUE(il->hw_params.max_txq_num);\r\na += 4)\r\nil_write_targ_mem(il, a, 0);\r\nil_wr_prph(il, IL49_SCD_DRAM_BASE_ADDR, il->scd_bc_tbls.dma >> 10);\r\nfor (chan = 0; chan < FH49_TCSR_CHNL_NUM; chan++)\r\nil_wr(il, FH49_TCSR_CHNL_TX_CONFIG_REG(chan),\r\nFH49_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |\r\nFH49_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE);\r\nreg_val = il_rd(il, FH49_TX_CHICKEN_BITS_REG);\r\nil_wr(il, FH49_TX_CHICKEN_BITS_REG,\r\nreg_val | FH49_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);\r\nil_wr_prph(il, IL49_SCD_QUEUECHAIN_SEL, 0);\r\nfor (i = 0; i < il->hw_params.max_txq_num; i++) {\r\nil_wr_prph(il, IL49_SCD_QUEUE_RDPTR(i), 0);\r\nil_wr(il, HBUS_TARG_WRPTR, 0 | (i << 8));\r\nil_write_targ_mem(il,\r\nil->scd_base_addr +\r\nIL49_SCD_CONTEXT_QUEUE_OFFSET(i),\r\n(SCD_WIN_SIZE <<\r\nIL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_POS) &\r\nIL49_SCD_QUEUE_CTX_REG1_WIN_SIZE_MSK);\r\nil_write_targ_mem(il,\r\nil->scd_base_addr +\r\nIL49_SCD_CONTEXT_QUEUE_OFFSET(i) +\r\nsizeof(u32),\r\n(SCD_FRAME_LIMIT <<\r\nIL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &\r\nIL49_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK);\r\n}\r\nil_wr_prph(il, IL49_SCD_INTERRUPT_MASK,\r\n(1 << il->hw_params.max_txq_num) - 1);\r\nil4965_txq_set_sched(il, IL_MASK(0, 6));\r\nil4965_set_wr_ptrs(il, IL_DEFAULT_CMD_QUEUE_NUM, 0);\r\nmemset(&il->queue_stopped[0], 0, sizeof(il->queue_stopped));\r\nfor (i = 0; i < 4; i++)\r\natomic_set(&il->queue_stop_count[i], 0);\r\nil->txq_ctx_active_msk = 0;\r\nBUILD_BUG_ON(ARRAY_SIZE(default_queue_to_tx_fifo) != 7);\r\nfor (i = 0; i < ARRAY_SIZE(default_queue_to_tx_fifo); i++) {\r\nint ac = default_queue_to_tx_fifo[i];\r\nil_txq_ctx_activate(il, i);\r\nif (ac == IL_TX_FIFO_UNUSED)\r\ncontinue;\r\nil4965_tx_queue_set_status(il, &il->txq[i], ac, 0);\r\n}\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nil4965_alive_start(struct il_priv *il)\r\n{\r\nint ret = 0;\r\nD_INFO("Runtime Alive received.\n");\r\nif (il->card_alive.is_valid != UCODE_VALID_OK) {\r\nD_INFO("Alive failed.\n");\r\ngoto restart;\r\n}\r\nif (il4965_verify_ucode(il)) {\r\nD_INFO("Bad runtime uCode load.\n");\r\ngoto restart;\r\n}\r\nret = il4965_alive_notify(il);\r\nif (ret) {\r\nIL_WARN("Could not complete ALIVE transition [ntf]: %d\n", ret);\r\ngoto restart;\r\n}\r\nset_bit(S_ALIVE, &il->status);\r\nil_setup_watchdog(il);\r\nif (il_is_rfkill(il))\r\nreturn;\r\nieee80211_wake_queues(il->hw);\r\nil->active_rate = RATES_MASK;\r\nil_power_update_mode(il, true);\r\nD_INFO("Updated power mode\n");\r\nif (il_is_associated(il)) {\r\nstruct il_rxon_cmd *active_rxon =\r\n(struct il_rxon_cmd *)&il->active;\r\nil->staging.filter_flags |= RXON_FILTER_ASSOC_MSK;\r\nactive_rxon->filter_flags &= ~RXON_FILTER_ASSOC_MSK;\r\n} else {\r\nil_connection_init_rx_config(il);\r\nif (il->ops->set_rxon_chain)\r\nil->ops->set_rxon_chain(il);\r\n}\r\nil_send_bt_config(il);\r\nil4965_reset_run_time_calib(il);\r\nset_bit(S_READY, &il->status);\r\nil_commit_rxon(il);\r\nil4965_rf_kill_ct_config(il);\r\nD_INFO("ALIVE processing complete.\n");\r\nwake_up(&il->wait_command_queue);\r\nreturn;\r\nrestart:\r\nqueue_work(il->workqueue, &il->restart);\r\n}\r\nstatic void\r\n__il4965_down(struct il_priv *il)\r\n{\r\nunsigned long flags;\r\nint exit_pending;\r\nD_INFO(DRV_NAME " is going down\n");\r\nil_scan_cancel_timeout(il, 200);\r\nexit_pending = test_and_set_bit(S_EXIT_PENDING, &il->status);\r\ndel_timer_sync(&il->watchdog);\r\nil_clear_ucode_stations(il);\r\nspin_lock_irq(&il->sta_lock);\r\nmemset(il->_4965.wep_keys, 0, sizeof(il->_4965.wep_keys));\r\nil->_4965.key_mapping_keys = 0;\r\nspin_unlock_irq(&il->sta_lock);\r\nil_dealloc_bcast_stations(il);\r\nil_clear_driver_stations(il);\r\nwake_up_all(&il->wait_command_queue);\r\nif (!exit_pending)\r\nclear_bit(S_EXIT_PENDING, &il->status);\r\n_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_disable_interrupts(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil4965_synchronize_irq(il);\r\nif (il->mac80211_registered)\r\nieee80211_stop_queues(il->hw);\r\nif (!il_is_init(il)) {\r\nil->status =\r\ntest_bit(S_RFKILL, &il->status) << S_RFKILL |\r\ntest_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\r\ntest_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\r\ngoto exit;\r\n}\r\nil->status &=\r\ntest_bit(S_RFKILL, &il->status) << S_RFKILL |\r\ntest_bit(S_GEO_CONFIGURED, &il->status) << S_GEO_CONFIGURED |\r\ntest_bit(S_FW_ERROR, &il->status) << S_FW_ERROR |\r\ntest_bit(S_EXIT_PENDING, &il->status) << S_EXIT_PENDING;\r\nspin_lock_irq(&il->reg_lock);\r\nil4965_txq_ctx_stop(il);\r\nil4965_rxq_stop(il);\r\n_il_wr_prph(il, APMG_CLK_DIS_REG, APMG_CLK_VAL_DMA_CLK_RQT);\r\nudelay(5);\r\n_il_clear_bit(il, CSR_GP_CNTRL, CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);\r\n_il_apm_stop(il);\r\nspin_unlock_irq(&il->reg_lock);\r\nil4965_txq_ctx_unmap(il);\r\nexit:\r\nmemset(&il->card_alive, 0, sizeof(struct il_alive_resp));\r\ndev_kfree_skb(il->beacon_skb);\r\nil->beacon_skb = NULL;\r\nil4965_clear_free_frames(il);\r\n}\r\nstatic void\r\nil4965_down(struct il_priv *il)\r\n{\r\nmutex_lock(&il->mutex);\r\n__il4965_down(il);\r\nmutex_unlock(&il->mutex);\r\nil4965_cancel_deferred_work(il);\r\n}\r\nstatic void\r\nil4965_set_hw_ready(struct il_priv *il)\r\n{\r\nint ret;\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_NIC_READY);\r\nret = _il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\r\nCSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\r\nCSR_HW_IF_CONFIG_REG_BIT_NIC_READY,\r\n100);\r\nif (ret >= 0)\r\nil->hw_ready = true;\r\nD_INFO("hardware %s ready\n", (il->hw_ready) ? "" : "not");\r\n}\r\nstatic void\r\nil4965_prepare_card_hw(struct il_priv *il)\r\n{\r\nint ret;\r\nil->hw_ready = false;\r\nil4965_set_hw_ready(il);\r\nif (il->hw_ready)\r\nreturn;\r\nil_set_bit(il, CSR_HW_IF_CONFIG_REG, CSR_HW_IF_CONFIG_REG_PREPARE);\r\nret =\r\n_il_poll_bit(il, CSR_HW_IF_CONFIG_REG,\r\n~CSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE,\r\nCSR_HW_IF_CONFIG_REG_BIT_NIC_PREPARE_DONE, 150000);\r\nif (ret != -ETIMEDOUT)\r\nil4965_set_hw_ready(il);\r\n}\r\nstatic int\r\n__il4965_up(struct il_priv *il)\r\n{\r\nint i;\r\nint ret;\r\nif (test_bit(S_EXIT_PENDING, &il->status)) {\r\nIL_WARN("Exit pending; will not bring the NIC up\n");\r\nreturn -EIO;\r\n}\r\nif (!il->ucode_data_backup.v_addr || !il->ucode_data.v_addr) {\r\nIL_ERR("ucode not available for device bringup\n");\r\nreturn -EIO;\r\n}\r\nret = il4965_alloc_bcast_station(il);\r\nif (ret) {\r\nil_dealloc_bcast_stations(il);\r\nreturn ret;\r\n}\r\nil4965_prepare_card_hw(il);\r\nif (!il->hw_ready) {\r\nIL_ERR("HW not ready\n");\r\nreturn -EIO;\r\n}\r\nif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\r\nclear_bit(S_RFKILL, &il->status);\r\nelse {\r\nset_bit(S_RFKILL, &il->status);\r\nwiphy_rfkill_set_hw_state(il->hw->wiphy, true);\r\nil_enable_rfkill_int(il);\r\nIL_WARN("Radio disabled by HW RF Kill switch\n");\r\nreturn 0;\r\n}\r\n_il_wr(il, CSR_INT, 0xFFFFFFFF);\r\nil->cmd_queue = IL_DEFAULT_CMD_QUEUE_NUM;\r\nret = il4965_hw_nic_init(il);\r\nif (ret) {\r\nIL_ERR("Unable to init nic\n");\r\nreturn ret;\r\n}\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);\r\n_il_wr(il, CSR_INT, 0xFFFFFFFF);\r\nil_enable_interrupts(il);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\r\n_il_wr(il, CSR_UCODE_DRV_GP1_CLR, CSR_UCODE_SW_BIT_RFKILL);\r\nmemcpy(il->ucode_data_backup.v_addr, il->ucode_data.v_addr,\r\nil->ucode_data.len);\r\nfor (i = 0; i < MAX_HW_RESTARTS; i++) {\r\nret = il->ops->load_ucode(il);\r\nif (ret) {\r\nIL_ERR("Unable to set up bootstrap uCode: %d\n", ret);\r\ncontinue;\r\n}\r\nil4965_nic_start(il);\r\nD_INFO(DRV_NAME " is coming up\n");\r\nreturn 0;\r\n}\r\nset_bit(S_EXIT_PENDING, &il->status);\r\n__il4965_down(il);\r\nclear_bit(S_EXIT_PENDING, &il->status);\r\nIL_ERR("Unable to initialize device after %d attempts.\n", i);\r\nreturn -EIO;\r\n}\r\nstatic void\r\nil4965_bg_init_alive_start(struct work_struct *data)\r\n{\r\nstruct il_priv *il =\r\ncontainer_of(data, struct il_priv, init_alive_start.work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\ngoto out;\r\nil->ops->init_alive_start(il);\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic void\r\nil4965_bg_alive_start(struct work_struct *data)\r\n{\r\nstruct il_priv *il =\r\ncontainer_of(data, struct il_priv, alive_start.work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\ngoto out;\r\nil4965_alive_start(il);\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic void\r\nil4965_bg_run_time_calib_work(struct work_struct *work)\r\n{\r\nstruct il_priv *il = container_of(work, struct il_priv,\r\nrun_time_calib_work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status) ||\r\ntest_bit(S_SCANNING, &il->status)) {\r\nmutex_unlock(&il->mutex);\r\nreturn;\r\n}\r\nif (il->start_calib) {\r\nil4965_chain_noise_calibration(il, (void *)&il->_4965.stats);\r\nil4965_sensitivity_calibration(il, (void *)&il->_4965.stats);\r\n}\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic void\r\nil4965_bg_restart(struct work_struct *data)\r\n{\r\nstruct il_priv *il = container_of(data, struct il_priv, restart);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nif (test_and_clear_bit(S_FW_ERROR, &il->status)) {\r\nmutex_lock(&il->mutex);\r\nil->is_open = 0;\r\n__il4965_down(il);\r\nmutex_unlock(&il->mutex);\r\nil4965_cancel_deferred_work(il);\r\nieee80211_restart_hw(il->hw);\r\n} else {\r\nil4965_down(il);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status)) {\r\nmutex_unlock(&il->mutex);\r\nreturn;\r\n}\r\n__il4965_up(il);\r\nmutex_unlock(&il->mutex);\r\n}\r\n}\r\nstatic void\r\nil4965_bg_rx_replenish(struct work_struct *data)\r\n{\r\nstruct il_priv *il = container_of(data, struct il_priv, rx_replenish);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nreturn;\r\nmutex_lock(&il->mutex);\r\nil4965_rx_replenish(il);\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic int\r\nil4965_mac_setup_register(struct il_priv *il, u32 max_probe_length)\r\n{\r\nint ret;\r\nstruct ieee80211_hw *hw = il->hw;\r\nhw->rate_control_algorithm = "iwl-4965-rs";\r\nieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\r\nieee80211_hw_set(hw, SUPPORTS_PS);\r\nieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\r\nieee80211_hw_set(hw, SPECTRUM_MGMT);\r\nieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);\r\nieee80211_hw_set(hw, SIGNAL_DBM);\r\nieee80211_hw_set(hw, AMPDU_AGGREGATION);\r\nif (il->cfg->sku & IL_SKU_N)\r\nhw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS |\r\nNL80211_FEATURE_STATIC_SMPS;\r\nhw->sta_data_size = sizeof(struct il_station_priv);\r\nhw->vif_data_size = sizeof(struct il_vif_priv);\r\nhw->wiphy->interface_modes =\r\nBIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_ADHOC);\r\nhw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\r\nhw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\r\nREGULATORY_DISABLE_BEACON_HINTS;\r\nhw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nhw->wiphy->max_scan_ssids = PROBE_OPTION_MAX;\r\nhw->wiphy->max_scan_ie_len = max_probe_length - 24 - 2;\r\nhw->queues = 4;\r\nhw->max_listen_interval = IL_CONN_MAX_LISTEN_INTERVAL;\r\nif (il->bands[IEEE80211_BAND_2GHZ].n_channels)\r\nil->hw->wiphy->bands[IEEE80211_BAND_2GHZ] =\r\n&il->bands[IEEE80211_BAND_2GHZ];\r\nif (il->bands[IEEE80211_BAND_5GHZ].n_channels)\r\nil->hw->wiphy->bands[IEEE80211_BAND_5GHZ] =\r\n&il->bands[IEEE80211_BAND_5GHZ];\r\nil_leds_init(il);\r\nret = ieee80211_register_hw(il->hw);\r\nif (ret) {\r\nIL_ERR("Failed to register hw (error %d)\n", ret);\r\nreturn ret;\r\n}\r\nil->mac80211_registered = 1;\r\nreturn 0;\r\n}\r\nint\r\nil4965_mac_start(struct ieee80211_hw *hw)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nint ret;\r\nD_MAC80211("enter\n");\r\nmutex_lock(&il->mutex);\r\nret = __il4965_up(il);\r\nmutex_unlock(&il->mutex);\r\nif (ret)\r\nreturn ret;\r\nif (il_is_rfkill(il))\r\ngoto out;\r\nD_INFO("Start UP work done.\n");\r\nret = wait_event_timeout(il->wait_command_queue,\r\ntest_bit(S_READY, &il->status),\r\nUCODE_READY_TIMEOUT);\r\nif (!ret) {\r\nif (!test_bit(S_READY, &il->status)) {\r\nIL_ERR("START_ALIVE timeout after %dms.\n",\r\njiffies_to_msecs(UCODE_READY_TIMEOUT));\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nil4965_led_enable(il);\r\nout:\r\nil->is_open = 1;\r\nD_MAC80211("leave\n");\r\nreturn 0;\r\n}\r\nvoid\r\nil4965_mac_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nD_MAC80211("enter\n");\r\nif (!il->is_open)\r\nreturn;\r\nil->is_open = 0;\r\nil4965_down(il);\r\nflush_workqueue(il->workqueue);\r\n_il_wr(il, CSR_INT, 0xFFFFFFFF);\r\nil_enable_rfkill_int(il);\r\nD_MAC80211("leave\n");\r\n}\r\nvoid\r\nil4965_mac_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nD_MACDUMP("enter\n");\r\nD_TX("dev->xmit(%d bytes) at rate 0x%02x\n", skb->len,\r\nieee80211_get_tx_rate(hw, IEEE80211_SKB_CB(skb))->bitrate);\r\nif (il4965_tx_skb(il, control->sta, skb))\r\ndev_kfree_skb_any(skb);\r\nD_MACDUMP("leave\n");\r\n}\r\nvoid\r\nil4965_mac_update_tkip_key(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_key_conf *keyconf,\r\nstruct ieee80211_sta *sta, u32 iv32, u16 * phase1key)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nD_MAC80211("enter\n");\r\nil4965_update_tkip_key(il, keyconf, sta, iv32, phase1key);\r\nD_MAC80211("leave\n");\r\n}\r\nint\r\nil4965_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nint ret;\r\nu8 sta_id;\r\nbool is_default_wep_key = false;\r\nD_MAC80211("enter\n");\r\nif (il->cfg->mod_params->sw_crypto) {\r\nD_MAC80211("leave - hwcrypto disabled\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (vif->type == NL80211_IFTYPE_ADHOC &&\r\n!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\r\nD_MAC80211("leave - ad-hoc group key\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nsta_id = il_sta_id_or_broadcast(il, sta);\r\nif (sta_id == IL_INVALID_STATION)\r\nreturn -EINVAL;\r\nmutex_lock(&il->mutex);\r\nil_scan_cancel_timeout(il, 100);\r\nif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkey->cipher == WLAN_CIPHER_SUITE_WEP104) && !sta) {\r\nif (cmd == SET_KEY)\r\nis_default_wep_key = !il->_4965.key_mapping_keys;\r\nelse\r\nis_default_wep_key =\r\n(key->hw_key_idx == HW_KEY_DEFAULT);\r\n}\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nif (is_default_wep_key)\r\nret = il4965_set_default_wep_key(il, key);\r\nelse\r\nret = il4965_set_dynamic_key(il, key, sta_id);\r\nD_MAC80211("enable hwcrypto key\n");\r\nbreak;\r\ncase DISABLE_KEY:\r\nif (is_default_wep_key)\r\nret = il4965_remove_default_wep_key(il, key);\r\nelse\r\nret = il4965_remove_dynamic_key(il, key, sta_id);\r\nD_MAC80211("disable hwcrypto key\n");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&il->mutex);\r\nD_MAC80211("leave\n");\r\nreturn ret;\r\n}\r\nint\r\nil4965_mac_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta, u16 tid, u16 * ssn,\r\nu8 buf_size)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nint ret = -EINVAL;\r\nD_HT("A-MPDU action on addr %pM tid %d\n", sta->addr, tid);\r\nif (!(il->cfg->sku & IL_SKU_N))\r\nreturn -EACCES;\r\nmutex_lock(&il->mutex);\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_RX_START:\r\nD_HT("start Rx\n");\r\nret = il4965_sta_rx_agg_start(il, sta, tid, *ssn);\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_STOP:\r\nD_HT("stop Rx\n");\r\nret = il4965_sta_rx_agg_stop(il, sta, tid);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nret = 0;\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_START:\r\nD_HT("start Tx\n");\r\nret = il4965_tx_agg_start(il, vif, sta, tid, ssn);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_CONT:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\nD_HT("stop Tx\n");\r\nret = il4965_tx_agg_stop(il, vif, sta, tid);\r\nif (test_bit(S_EXIT_PENDING, &il->status))\r\nret = 0;\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_OPERATIONAL:\r\nret = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&il->mutex);\r\nreturn ret;\r\n}\r\nint\r\nil4965_mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nstruct il_station_priv *sta_priv = (void *)sta->drv_priv;\r\nbool is_ap = vif->type == NL80211_IFTYPE_STATION;\r\nint ret;\r\nu8 sta_id;\r\nD_INFO("received request to add station %pM\n", sta->addr);\r\nmutex_lock(&il->mutex);\r\nD_INFO("proceeding to add station %pM\n", sta->addr);\r\nsta_priv->common.sta_id = IL_INVALID_STATION;\r\natomic_set(&sta_priv->pending_frames, 0);\r\nret =\r\nil_add_station_common(il, sta->addr, is_ap, sta, &sta_id);\r\nif (ret) {\r\nIL_ERR("Unable to add station %pM (%d)\n", sta->addr, ret);\r\nmutex_unlock(&il->mutex);\r\nreturn ret;\r\n}\r\nsta_priv->common.sta_id = sta_id;\r\nD_INFO("Initializing rate scaling for station %pM\n", sta->addr);\r\nil4965_rs_rate_init(il, sta, sta_id);\r\nmutex_unlock(&il->mutex);\r\nreturn 0;\r\n}\r\nvoid\r\nil4965_mac_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_channel_switch *ch_switch)\r\n{\r\nstruct il_priv *il = hw->priv;\r\nconst struct il_channel_info *ch_info;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct ieee80211_channel *channel = ch_switch->chandef.chan;\r\nstruct il_ht_config *ht_conf = &il->current_ht_config;\r\nu16 ch;\r\nD_MAC80211("enter\n");\r\nmutex_lock(&il->mutex);\r\nif (il_is_rfkill(il))\r\ngoto out;\r\nif (test_bit(S_EXIT_PENDING, &il->status) ||\r\ntest_bit(S_SCANNING, &il->status) ||\r\ntest_bit(S_CHANNEL_SWITCH_PENDING, &il->status))\r\ngoto out;\r\nif (!il_is_associated(il))\r\ngoto out;\r\nif (!il->ops->set_channel_switch)\r\ngoto out;\r\nch = channel->hw_value;\r\nif (le16_to_cpu(il->active.channel) == ch)\r\ngoto out;\r\nch_info = il_get_channel_info(il, channel->band, ch);\r\nif (!il_is_channel_valid(ch_info)) {\r\nD_MAC80211("invalid channel\n");\r\ngoto out;\r\n}\r\nspin_lock_irq(&il->lock);\r\nil->current_ht_config.smps = conf->smps_mode;\r\nswitch (cfg80211_get_chandef_type(&ch_switch->chandef)) {\r\ncase NL80211_CHAN_NO_HT:\r\ncase NL80211_CHAN_HT20:\r\nil->ht.is_40mhz = false;\r\nil->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\r\nbreak;\r\ncase NL80211_CHAN_HT40MINUS:\r\nil->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\r\nil->ht.is_40mhz = true;\r\nbreak;\r\ncase NL80211_CHAN_HT40PLUS:\r\nil->ht.extension_chan_offset = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\r\nil->ht.is_40mhz = true;\r\nbreak;\r\n}\r\nif ((le16_to_cpu(il->staging.channel) != ch))\r\nil->staging.flags = 0;\r\nil_set_rxon_channel(il, channel);\r\nil_set_rxon_ht(il, ht_conf);\r\nil_set_flags_for_band(il, channel->band, il->vif);\r\nspin_unlock_irq(&il->lock);\r\nil_set_rate(il);\r\nset_bit(S_CHANNEL_SWITCH_PENDING, &il->status);\r\nil->switch_channel = cpu_to_le16(ch);\r\nif (il->ops->set_channel_switch(il, ch_switch)) {\r\nclear_bit(S_CHANNEL_SWITCH_PENDING, &il->status);\r\nil->switch_channel = 0;\r\nieee80211_chswitch_done(il->vif, false);\r\n}\r\nout:\r\nmutex_unlock(&il->mutex);\r\nD_MAC80211("leave\n");\r\n}\r\nvoid\r\nil4965_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\r\nunsigned int *total_flags, u64 multicast)\r\n{\r\nstruct il_priv *il = hw->priv;\r\n__le32 filter_or = 0, filter_nand = 0;\r\n#define CHK(test, flag) do { \\r\nif (*total_flags & (test)) \\r\nfilter_or |= (flag); \\r\nelse \\r\nfilter_nand |= (flag); \\r\n} while (0)\r\nD_MAC80211("Enter: changed: 0x%x, total: 0x%x\n", changed_flags,\r\n*total_flags);\r\nCHK(FIF_OTHER_BSS, RXON_FILTER_PROMISC_MSK);\r\nCHK(FIF_CONTROL, RXON_FILTER_CTL2HOST_MSK | RXON_FILTER_PROMISC_MSK);\r\nCHK(FIF_BCN_PRBRESP_PROMISC, RXON_FILTER_BCON_AWARE_MSK);\r\n#undef CHK\r\nmutex_lock(&il->mutex);\r\nil->staging.filter_flags &= ~filter_nand;\r\nil->staging.filter_flags |= filter_or;\r\nmutex_unlock(&il->mutex);\r\n*total_flags &=\r\nFIF_OTHER_BSS | FIF_ALLMULTI |\r\nFIF_BCN_PRBRESP_PROMISC | FIF_CONTROL;\r\n}\r\nstatic void\r\nil4965_bg_txpower_work(struct work_struct *work)\r\n{\r\nstruct il_priv *il = container_of(work, struct il_priv,\r\ntxpower_work);\r\nmutex_lock(&il->mutex);\r\nif (test_bit(S_EXIT_PENDING, &il->status) ||\r\ntest_bit(S_SCANNING, &il->status))\r\ngoto out;\r\nil->ops->send_tx_power(il);\r\nil->last_temperature = il->temperature;\r\nout:\r\nmutex_unlock(&il->mutex);\r\n}\r\nstatic void\r\nil4965_setup_deferred_work(struct il_priv *il)\r\n{\r\nil->workqueue = create_singlethread_workqueue(DRV_NAME);\r\ninit_waitqueue_head(&il->wait_command_queue);\r\nINIT_WORK(&il->restart, il4965_bg_restart);\r\nINIT_WORK(&il->rx_replenish, il4965_bg_rx_replenish);\r\nINIT_WORK(&il->run_time_calib_work, il4965_bg_run_time_calib_work);\r\nINIT_DELAYED_WORK(&il->init_alive_start, il4965_bg_init_alive_start);\r\nINIT_DELAYED_WORK(&il->alive_start, il4965_bg_alive_start);\r\nil_setup_scan_deferred_work(il);\r\nINIT_WORK(&il->txpower_work, il4965_bg_txpower_work);\r\nsetup_timer(&il->stats_periodic, il4965_bg_stats_periodic,\r\n(unsigned long)il);\r\nsetup_timer(&il->watchdog, il_bg_watchdog, (unsigned long)il);\r\ntasklet_init(&il->irq_tasklet,\r\n(void (*)(unsigned long))il4965_irq_tasklet,\r\n(unsigned long)il);\r\n}\r\nstatic void\r\nil4965_cancel_deferred_work(struct il_priv *il)\r\n{\r\ncancel_work_sync(&il->txpower_work);\r\ncancel_delayed_work_sync(&il->init_alive_start);\r\ncancel_delayed_work(&il->alive_start);\r\ncancel_work_sync(&il->run_time_calib_work);\r\nil_cancel_scan_deferred_work(il);\r\ndel_timer_sync(&il->stats_periodic);\r\n}\r\nstatic void\r\nil4965_init_hw_rates(struct il_priv *il, struct ieee80211_rate *rates)\r\n{\r\nint i;\r\nfor (i = 0; i < RATE_COUNT_LEGACY; i++) {\r\nrates[i].bitrate = il_rates[i].ieee * 5;\r\nrates[i].hw_value = i;\r\nrates[i].hw_value_short = i;\r\nrates[i].flags = 0;\r\nif ((i >= IL_FIRST_CCK_RATE) && (i <= IL_LAST_CCK_RATE)) {\r\nrates[i].flags |=\r\n(il_rates[i].plcp ==\r\nRATE_1M_PLCP) ? 0 : IEEE80211_RATE_SHORT_PREAMBLE;\r\n}\r\n}\r\n}\r\nvoid\r\nil4965_set_wr_ptrs(struct il_priv *il, int txq_id, u32 idx)\r\n{\r\nil_wr(il, HBUS_TARG_WRPTR, (idx & 0xff) | (txq_id << 8));\r\nil_wr_prph(il, IL49_SCD_QUEUE_RDPTR(txq_id), idx);\r\n}\r\nvoid\r\nil4965_tx_queue_set_status(struct il_priv *il, struct il_tx_queue *txq,\r\nint tx_fifo_id, int scd_retry)\r\n{\r\nint txq_id = txq->q.id;\r\nint active = test_bit(txq_id, &il->txq_ctx_active_msk) ? 1 : 0;\r\nil_wr_prph(il, IL49_SCD_QUEUE_STATUS_BITS(txq_id),\r\n(active << IL49_SCD_QUEUE_STTS_REG_POS_ACTIVE) |\r\n(tx_fifo_id << IL49_SCD_QUEUE_STTS_REG_POS_TXF) |\r\n(scd_retry << IL49_SCD_QUEUE_STTS_REG_POS_WSL) |\r\n(scd_retry << IL49_SCD_QUEUE_STTS_REG_POS_SCD_ACK) |\r\nIL49_SCD_QUEUE_STTS_REG_MSK);\r\ntxq->sched_retry = scd_retry;\r\nD_INFO("%s %s Queue %d on AC %d\n", active ? "Activate" : "Deactivate",\r\nscd_retry ? "BA" : "AC", txq_id, tx_fifo_id);\r\n}\r\nstatic int\r\nil4965_init_drv(struct il_priv *il)\r\n{\r\nint ret;\r\nspin_lock_init(&il->sta_lock);\r\nspin_lock_init(&il->hcmd_lock);\r\nINIT_LIST_HEAD(&il->free_frames);\r\nmutex_init(&il->mutex);\r\nil->ieee_channels = NULL;\r\nil->ieee_rates = NULL;\r\nil->band = IEEE80211_BAND_2GHZ;\r\nil->iw_mode = NL80211_IFTYPE_STATION;\r\nil->current_ht_config.smps = IEEE80211_SMPS_STATIC;\r\nil->missed_beacon_threshold = IL_MISSED_BEACON_THRESHOLD_DEF;\r\nil->force_reset.reset_duration = IL_DELAY_NEXT_FORCE_FW_RELOAD;\r\nif (il->ops->set_rxon_chain)\r\nil->ops->set_rxon_chain(il);\r\nil_init_scan_params(il);\r\nret = il_init_channel_map(il);\r\nif (ret) {\r\nIL_ERR("initializing regulatory failed: %d\n", ret);\r\ngoto err;\r\n}\r\nret = il_init_geos(il);\r\nif (ret) {\r\nIL_ERR("initializing geos failed: %d\n", ret);\r\ngoto err_free_channel_map;\r\n}\r\nil4965_init_hw_rates(il, il->ieee_rates);\r\nreturn 0;\r\nerr_free_channel_map:\r\nil_free_channel_map(il);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void\r\nil4965_uninit_drv(struct il_priv *il)\r\n{\r\nil_free_geos(il);\r\nil_free_channel_map(il);\r\nkfree(il->scan_cmd);\r\n}\r\nstatic void\r\nil4965_hw_detect(struct il_priv *il)\r\n{\r\nil->hw_rev = _il_rd(il, CSR_HW_REV);\r\nil->hw_wa_rev = _il_rd(il, CSR_HW_REV_WA_REG);\r\nil->rev_id = il->pci_dev->revision;\r\nD_INFO("HW Revision ID = 0x%X\n", il->rev_id);\r\n}\r\nstatic void\r\nil4965_set_hw_params(struct il_priv *il)\r\n{\r\nil->hw_params.bcast_id = IL4965_BROADCAST_ID;\r\nil->hw_params.max_rxq_size = RX_QUEUE_SIZE;\r\nil->hw_params.max_rxq_log = RX_QUEUE_SIZE_LOG;\r\nif (il->cfg->mod_params->amsdu_size_8K)\r\nil->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_8K);\r\nelse\r\nil->hw_params.rx_page_order = get_order(IL_RX_BUF_SIZE_4K);\r\nil->hw_params.max_beacon_itrvl = IL_MAX_UCODE_BEACON_INTERVAL;\r\nif (il->cfg->mod_params->disable_11n)\r\nil->cfg->sku &= ~IL_SKU_N;\r\nif (il->cfg->mod_params->num_of_queues >= IL_MIN_NUM_QUEUES &&\r\nil->cfg->mod_params->num_of_queues <= IL49_NUM_QUEUES)\r\nil->cfg->num_of_queues =\r\nil->cfg->mod_params->num_of_queues;\r\nil->hw_params.max_txq_num = il->cfg->num_of_queues;\r\nil->hw_params.dma_chnl_num = FH49_TCSR_CHNL_NUM;\r\nil->hw_params.scd_bc_tbls_size =\r\nil->cfg->num_of_queues *\r\nsizeof(struct il4965_scd_bc_tbl);\r\nil->hw_params.tfd_size = sizeof(struct il_tfd);\r\nil->hw_params.max_stations = IL4965_STATION_COUNT;\r\nil->hw_params.max_data_size = IL49_RTC_DATA_SIZE;\r\nil->hw_params.max_inst_size = IL49_RTC_INST_SIZE;\r\nil->hw_params.max_bsm_size = BSM_SRAM_SIZE;\r\nil->hw_params.ht40_channel = BIT(IEEE80211_BAND_5GHZ);\r\nil->hw_params.rx_wrt_ptr_reg = FH49_RSCSR_CHNL0_WPTR;\r\nil->hw_params.tx_chains_num = il4965_num_of_ant(il->cfg->valid_tx_ant);\r\nil->hw_params.rx_chains_num = il4965_num_of_ant(il->cfg->valid_rx_ant);\r\nil->hw_params.valid_tx_ant = il->cfg->valid_tx_ant;\r\nil->hw_params.valid_rx_ant = il->cfg->valid_rx_ant;\r\nil->hw_params.ct_kill_threshold =\r\nCELSIUS_TO_KELVIN(CT_KILL_THRESHOLD_LEGACY);\r\nil->hw_params.sens = &il4965_sensitivity;\r\nil->hw_params.beacon_time_tsf_bits = IL4965_EXT_BEACON_TIME_POS;\r\n}\r\nstatic int\r\nil4965_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = 0;\r\nstruct il_priv *il;\r\nstruct ieee80211_hw *hw;\r\nstruct il_cfg *cfg = (struct il_cfg *)(ent->driver_data);\r\nunsigned long flags;\r\nu16 pci_cmd;\r\nhw = ieee80211_alloc_hw(sizeof(struct il_priv), &il4965_mac_ops);\r\nif (!hw) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nil = hw->priv;\r\nil->hw = hw;\r\nSET_IEEE80211_DEV(hw, &pdev->dev);\r\nD_INFO("*** LOAD DRIVER ***\n");\r\nil->cfg = cfg;\r\nil->ops = &il4965_ops;\r\n#ifdef CONFIG_IWLEGACY_DEBUGFS\r\nil->debugfs_ops = &il4965_debugfs_ops;\r\n#endif\r\nil->pci_dev = pdev;\r\nil->inta_mask = CSR_INI_SET_MASK;\r\npci_disable_link_state(pdev,\r\nPCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\r\nPCIE_LINK_STATE_CLKPM);\r\nif (pci_enable_device(pdev)) {\r\nerr = -ENODEV;\r\ngoto out_ieee80211_free_hw;\r\n}\r\npci_set_master(pdev);\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(36));\r\nif (!err)\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(36));\r\nif (err) {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (!err)\r\nerr =\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\nIL_WARN("No suitable DMA available.\n");\r\ngoto out_pci_disable_device;\r\n}\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err)\r\ngoto out_pci_disable_device;\r\npci_set_drvdata(pdev, il);\r\nil->hw_base = pci_ioremap_bar(pdev, 0);\r\nif (!il->hw_base) {\r\nerr = -ENODEV;\r\ngoto out_pci_release_regions;\r\n}\r\nD_INFO("pci_resource_len = 0x%08llx\n",\r\n(unsigned long long)pci_resource_len(pdev, 0));\r\nD_INFO("pci_resource_base = %p\n", il->hw_base);\r\nspin_lock_init(&il->reg_lock);\r\nspin_lock_init(&il->lock);\r\n_il_wr(il, CSR_RESET, CSR_RESET_REG_FLAG_NEVO_RESET);\r\nil4965_hw_detect(il);\r\nIL_INFO("Detected %s, REV=0x%X\n", il->cfg->name, il->hw_rev);\r\npci_write_config_byte(pdev, PCI_CFG_RETRY_TIMEOUT, 0x00);\r\nil4965_prepare_card_hw(il);\r\nif (!il->hw_ready) {\r\nIL_WARN("Failed, HW not ready\n");\r\nerr = -EIO;\r\ngoto out_iounmap;\r\n}\r\nerr = il_eeprom_init(il);\r\nif (err) {\r\nIL_ERR("Unable to init EEPROM\n");\r\ngoto out_iounmap;\r\n}\r\nerr = il4965_eeprom_check_version(il);\r\nif (err)\r\ngoto out_free_eeprom;\r\nil4965_eeprom_get_mac(il, il->addresses[0].addr);\r\nD_INFO("MAC address: %pM\n", il->addresses[0].addr);\r\nil->hw->wiphy->addresses = il->addresses;\r\nil->hw->wiphy->n_addresses = 1;\r\nil4965_set_hw_params(il);\r\nerr = il4965_init_drv(il);\r\nif (err)\r\ngoto out_free_eeprom;\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_disable_interrupts(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\npci_enable_msi(il->pci_dev);\r\nerr = request_irq(il->pci_dev->irq, il_isr, IRQF_SHARED, DRV_NAME, il);\r\nif (err) {\r\nIL_ERR("Error allocating IRQ %d\n", il->pci_dev->irq);\r\ngoto out_disable_msi;\r\n}\r\nil4965_setup_deferred_work(il);\r\nil4965_setup_handlers(il);\r\npci_read_config_word(il->pci_dev, PCI_COMMAND, &pci_cmd);\r\nif (pci_cmd & PCI_COMMAND_INTX_DISABLE) {\r\npci_cmd &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(il->pci_dev, PCI_COMMAND, pci_cmd);\r\n}\r\nil_enable_rfkill_int(il);\r\nif (_il_rd(il, CSR_GP_CNTRL) & CSR_GP_CNTRL_REG_FLAG_HW_RF_KILL_SW)\r\nclear_bit(S_RFKILL, &il->status);\r\nelse\r\nset_bit(S_RFKILL, &il->status);\r\nwiphy_rfkill_set_hw_state(il->hw->wiphy,\r\ntest_bit(S_RFKILL, &il->status));\r\nil_power_initialize(il);\r\ninit_completion(&il->_4965.firmware_loading_complete);\r\nerr = il4965_request_firmware(il, true);\r\nif (err)\r\ngoto out_destroy_workqueue;\r\nreturn 0;\r\nout_destroy_workqueue:\r\ndestroy_workqueue(il->workqueue);\r\nil->workqueue = NULL;\r\nfree_irq(il->pci_dev->irq, il);\r\nout_disable_msi:\r\npci_disable_msi(il->pci_dev);\r\nil4965_uninit_drv(il);\r\nout_free_eeprom:\r\nil_eeprom_free(il);\r\nout_iounmap:\r\niounmap(il->hw_base);\r\nout_pci_release_regions:\r\npci_release_regions(pdev);\r\nout_pci_disable_device:\r\npci_disable_device(pdev);\r\nout_ieee80211_free_hw:\r\nieee80211_free_hw(il->hw);\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nil4965_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct il_priv *il = pci_get_drvdata(pdev);\r\nunsigned long flags;\r\nif (!il)\r\nreturn;\r\nwait_for_completion(&il->_4965.firmware_loading_complete);\r\nD_INFO("*** UNLOAD DRIVER ***\n");\r\nil_dbgfs_unregister(il);\r\nsysfs_remove_group(&pdev->dev.kobj, &il_attribute_group);\r\nset_bit(S_EXIT_PENDING, &il->status);\r\nil_leds_exit(il);\r\nif (il->mac80211_registered) {\r\nieee80211_unregister_hw(il->hw);\r\nil->mac80211_registered = 0;\r\n} else {\r\nil4965_down(il);\r\n}\r\nil_apm_stop(il);\r\nspin_lock_irqsave(&il->lock, flags);\r\nil_disable_interrupts(il);\r\nspin_unlock_irqrestore(&il->lock, flags);\r\nil4965_synchronize_irq(il);\r\nil4965_dealloc_ucode_pci(il);\r\nif (il->rxq.bd)\r\nil4965_rx_queue_free(il, &il->rxq);\r\nil4965_hw_txq_ctx_free(il);\r\nil_eeprom_free(il);\r\nflush_workqueue(il->workqueue);\r\ndestroy_workqueue(il->workqueue);\r\nil->workqueue = NULL;\r\nfree_irq(il->pci_dev->irq, il);\r\npci_disable_msi(il->pci_dev);\r\niounmap(il->hw_base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nil4965_uninit_drv(il);\r\ndev_kfree_skb(il->beacon_skb);\r\nieee80211_free_hw(il->hw);\r\n}\r\nvoid\r\nil4965_txq_set_sched(struct il_priv *il, u32 mask)\r\n{\r\nil_wr_prph(il, IL49_SCD_TXFACT, mask);\r\n}\r\nstatic int __init\r\nil4965_init(void)\r\n{\r\nint ret;\r\npr_info(DRV_DESCRIPTION ", " DRV_VERSION "\n");\r\npr_info(DRV_COPYRIGHT "\n");\r\nret = il4965_rate_control_register();\r\nif (ret) {\r\npr_err("Unable to register rate control algorithm: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = pci_register_driver(&il4965_driver);\r\nif (ret) {\r\npr_err("Unable to initialize PCI module\n");\r\ngoto error_register;\r\n}\r\nreturn ret;\r\nerror_register:\r\nil4965_rate_control_unregister();\r\nreturn ret;\r\n}\r\nstatic void __exit\r\nil4965_exit(void)\r\n{\r\npci_unregister_driver(&il4965_driver);\r\nil4965_rate_control_unregister();\r\n}
