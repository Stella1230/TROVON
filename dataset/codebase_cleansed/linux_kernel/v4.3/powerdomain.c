static struct powerdomain *_pwrdm_lookup(const char *name)\r\n{\r\nstruct powerdomain *pwrdm, *temp_pwrdm;\r\npwrdm = NULL;\r\nlist_for_each_entry(temp_pwrdm, &pwrdm_list, node) {\r\nif (!strcmp(name, temp_pwrdm->name)) {\r\npwrdm = temp_pwrdm;\r\nbreak;\r\n}\r\n}\r\nreturn pwrdm;\r\n}\r\nstatic int _pwrdm_register(struct powerdomain *pwrdm)\r\n{\r\nint i;\r\nstruct voltagedomain *voltdm;\r\nif (!pwrdm || !pwrdm->name)\r\nreturn -EINVAL;\r\nif (cpu_is_omap44xx() &&\r\npwrdm->prcm_partition == OMAP4430_INVALID_PRCM_PARTITION) {\r\npr_err("powerdomain: %s: missing OMAP4 PRCM partition ID\n",\r\npwrdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (_pwrdm_lookup(pwrdm->name))\r\nreturn -EEXIST;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_has_voltdm)\r\nif (!arch_pwrdm->pwrdm_has_voltdm())\r\ngoto skip_voltdm;\r\nvoltdm = voltdm_lookup(pwrdm->voltdm.name);\r\nif (!voltdm) {\r\npr_err("powerdomain: %s: voltagedomain %s does not exist\n",\r\npwrdm->name, pwrdm->voltdm.name);\r\nreturn -EINVAL;\r\n}\r\npwrdm->voltdm.ptr = voltdm;\r\nINIT_LIST_HEAD(&pwrdm->voltdm_node);\r\nskip_voltdm:\r\nspin_lock_init(&pwrdm->_lock);\r\nlist_add(&pwrdm->node, &pwrdm_list);\r\nfor (i = 0; i < PWRDM_MAX_PWRSTS; i++)\r\npwrdm->state_counter[i] = 0;\r\npwrdm->ret_logic_off_counter = 0;\r\nfor (i = 0; i < pwrdm->banks; i++)\r\npwrdm->ret_mem_off_counter[i] = 0;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_wait_transition)\r\narch_pwrdm->pwrdm_wait_transition(pwrdm);\r\npwrdm->state = pwrdm_read_pwrst(pwrdm);\r\npwrdm->state_counter[pwrdm->state] = 1;\r\npr_debug("powerdomain: registered %s\n", pwrdm->name);\r\nreturn 0;\r\n}\r\nstatic void _update_logic_membank_counters(struct powerdomain *pwrdm)\r\n{\r\nint i;\r\nu8 prev_logic_pwrst, prev_mem_pwrst;\r\nprev_logic_pwrst = pwrdm_read_prev_logic_pwrst(pwrdm);\r\nif ((pwrdm->pwrsts_logic_ret == PWRSTS_OFF_RET) &&\r\n(prev_logic_pwrst == PWRDM_POWER_OFF))\r\npwrdm->ret_logic_off_counter++;\r\nfor (i = 0; i < pwrdm->banks; i++) {\r\nprev_mem_pwrst = pwrdm_read_prev_mem_pwrst(pwrdm, i);\r\nif ((pwrdm->pwrsts_mem_ret[i] == PWRSTS_OFF_RET) &&\r\n(prev_mem_pwrst == PWRDM_POWER_OFF))\r\npwrdm->ret_mem_off_counter[i]++;\r\n}\r\n}\r\nstatic int _pwrdm_state_switch(struct powerdomain *pwrdm, int flag)\r\n{\r\nint prev, next, state, trace_state = 0;\r\nif (pwrdm == NULL)\r\nreturn -EINVAL;\r\nstate = pwrdm_read_pwrst(pwrdm);\r\nswitch (flag) {\r\ncase PWRDM_STATE_NOW:\r\nprev = pwrdm->state;\r\nbreak;\r\ncase PWRDM_STATE_PREV:\r\nprev = pwrdm_read_prev_pwrst(pwrdm);\r\nif (pwrdm->state != prev)\r\npwrdm->state_counter[prev]++;\r\nif (prev == PWRDM_POWER_RET)\r\n_update_logic_membank_counters(pwrdm);\r\nnext = pwrdm_read_next_pwrst(pwrdm);\r\nif (next != prev) {\r\ntrace_state = (PWRDM_TRACE_STATES_FLAG |\r\n((next & OMAP_POWERSTATE_MASK) << 8) |\r\n((prev & OMAP_POWERSTATE_MASK) << 0));\r\ntrace_power_domain_target(pwrdm->name, trace_state,\r\nsmp_processor_id());\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (state != prev)\r\npwrdm->state_counter[state]++;\r\npm_dbg_update_time(pwrdm, prev);\r\npwrdm->state = state;\r\nreturn 0;\r\n}\r\nstatic int _pwrdm_pre_transition_cb(struct powerdomain *pwrdm, void *unused)\r\n{\r\npwrdm_clear_all_prev_pwrst(pwrdm);\r\n_pwrdm_state_switch(pwrdm, PWRDM_STATE_NOW);\r\nreturn 0;\r\n}\r\nstatic int _pwrdm_post_transition_cb(struct powerdomain *pwrdm, void *unused)\r\n{\r\n_pwrdm_state_switch(pwrdm, PWRDM_STATE_PREV);\r\nreturn 0;\r\n}\r\nstatic u8 _pwrdm_save_clkdm_state_and_activate(struct powerdomain *pwrdm,\r\nu8 curr_pwrst, u8 pwrst,\r\nbool *hwsup)\r\n{\r\nu8 sleep_switch;\r\nif (curr_pwrst < PWRDM_POWER_ON) {\r\nif (curr_pwrst > pwrst &&\r\npwrdm->flags & PWRDM_HAS_LOWPOWERSTATECHANGE &&\r\narch_pwrdm->pwrdm_set_lowpwrstchange) {\r\nsleep_switch = LOWPOWERSTATE_SWITCH;\r\n} else {\r\n*hwsup = clkdm_in_hwsup(pwrdm->pwrdm_clkdms[0]);\r\nclkdm_wakeup_nolock(pwrdm->pwrdm_clkdms[0]);\r\nsleep_switch = FORCEWAKEUP_SWITCH;\r\n}\r\n} else {\r\nsleep_switch = ALREADYACTIVE_SWITCH;\r\n}\r\nreturn sleep_switch;\r\n}\r\nstatic void _pwrdm_restore_clkdm_state(struct powerdomain *pwrdm,\r\nu8 sleep_switch, bool hwsup)\r\n{\r\nswitch (sleep_switch) {\r\ncase FORCEWAKEUP_SWITCH:\r\nif (hwsup)\r\nclkdm_allow_idle_nolock(pwrdm->pwrdm_clkdms[0]);\r\nelse\r\nclkdm_sleep_nolock(pwrdm->pwrdm_clkdms[0]);\r\nbreak;\r\ncase LOWPOWERSTATE_SWITCH:\r\nif (pwrdm->flags & PWRDM_HAS_LOWPOWERSTATECHANGE &&\r\narch_pwrdm->pwrdm_set_lowpwrstchange)\r\narch_pwrdm->pwrdm_set_lowpwrstchange(pwrdm);\r\npwrdm_state_switch_nolock(pwrdm);\r\nbreak;\r\n}\r\n}\r\nint pwrdm_register_platform_funcs(struct pwrdm_ops *po)\r\n{\r\nif (!po)\r\nreturn -EINVAL;\r\nif (arch_pwrdm)\r\nreturn -EEXIST;\r\narch_pwrdm = po;\r\nreturn 0;\r\n}\r\nint pwrdm_register_pwrdms(struct powerdomain **ps)\r\n{\r\nstruct powerdomain **p = NULL;\r\nif (!arch_pwrdm)\r\nreturn -EEXIST;\r\nif (!ps)\r\nreturn -EINVAL;\r\nfor (p = ps; *p; p++)\r\n_pwrdm_register(*p);\r\nreturn 0;\r\n}\r\nint pwrdm_complete_init(void)\r\n{\r\nstruct powerdomain *temp_p;\r\nif (list_empty(&pwrdm_list))\r\nreturn -EACCES;\r\nlist_for_each_entry(temp_p, &pwrdm_list, node)\r\npwrdm_set_next_pwrst(temp_p, PWRDM_POWER_ON);\r\nreturn 0;\r\n}\r\nvoid pwrdm_lock(struct powerdomain *pwrdm)\r\n__acquires(&pwrdm->_lock\r\nvoid pwrdm_unlock(struct powerdomain *pwrdm)\r\n__releases(&pwrdm->_lock\r\nstruct powerdomain *pwrdm_lookup(const char *name)\r\n{\r\nstruct powerdomain *pwrdm;\r\nif (!name)\r\nreturn NULL;\r\npwrdm = _pwrdm_lookup(name);\r\nreturn pwrdm;\r\n}\r\nint pwrdm_for_each(int (*fn)(struct powerdomain *pwrdm, void *user),\r\nvoid *user)\r\n{\r\nstruct powerdomain *temp_pwrdm;\r\nint ret = 0;\r\nif (!fn)\r\nreturn -EINVAL;\r\nlist_for_each_entry(temp_pwrdm, &pwrdm_list, node) {\r\nret = (*fn)(temp_pwrdm, user);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint pwrdm_add_clkdm(struct powerdomain *pwrdm, struct clockdomain *clkdm)\r\n{\r\nint i;\r\nint ret = -EINVAL;\r\nif (!pwrdm || !clkdm)\r\nreturn -EINVAL;\r\npr_debug("powerdomain: %s: associating clockdomain %s\n",\r\npwrdm->name, clkdm->name);\r\nfor (i = 0; i < PWRDM_MAX_CLKDMS; i++) {\r\nif (!pwrdm->pwrdm_clkdms[i])\r\nbreak;\r\n#ifdef DEBUG\r\nif (pwrdm->pwrdm_clkdms[i] == clkdm) {\r\nret = -EINVAL;\r\ngoto pac_exit;\r\n}\r\n#endif\r\n}\r\nif (i == PWRDM_MAX_CLKDMS) {\r\npr_debug("powerdomain: %s: increase PWRDM_MAX_CLKDMS for clkdm %s\n",\r\npwrdm->name, clkdm->name);\r\nWARN_ON(1);\r\nret = -ENOMEM;\r\ngoto pac_exit;\r\n}\r\npwrdm->pwrdm_clkdms[i] = clkdm;\r\nret = 0;\r\npac_exit:\r\nreturn ret;\r\n}\r\nint pwrdm_get_mem_bank_count(struct powerdomain *pwrdm)\r\n{\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nreturn pwrdm->banks;\r\n}\r\nint pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (!(pwrdm->pwrsts & (1 << pwrst)))\r\nreturn -EINVAL;\r\npr_debug("powerdomain: %s: setting next powerstate to %0x\n",\r\npwrdm->name, pwrst);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_set_next_pwrst) {\r\ntrace_power_domain_target(pwrdm->name, pwrst,\r\nsmp_processor_id());\r\nret = arch_pwrdm->pwrdm_set_next_pwrst(pwrdm, pwrst);\r\n}\r\nreturn ret;\r\n}\r\nint pwrdm_read_next_pwrst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_next_pwrst)\r\nret = arch_pwrdm->pwrdm_read_next_pwrst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_read_pwrst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (pwrdm->pwrsts == PWRSTS_ON)\r\nreturn PWRDM_POWER_ON;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_pwrst)\r\nret = arch_pwrdm->pwrdm_read_pwrst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_read_prev_pwrst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_prev_pwrst)\r\nret = arch_pwrdm->pwrdm_read_prev_pwrst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_set_logic_retst(struct powerdomain *pwrdm, u8 pwrst)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (!(pwrdm->pwrsts_logic_ret & (1 << pwrst)))\r\nreturn -EINVAL;\r\npr_debug("powerdomain: %s: setting next logic powerstate to %0x\n",\r\npwrdm->name, pwrst);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_set_logic_retst)\r\nret = arch_pwrdm->pwrdm_set_logic_retst(pwrdm, pwrst);\r\nreturn ret;\r\n}\r\nint pwrdm_set_mem_onst(struct powerdomain *pwrdm, u8 bank, u8 pwrst)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (pwrdm->banks < (bank + 1))\r\nreturn -EEXIST;\r\nif (!(pwrdm->pwrsts_mem_on[bank] & (1 << pwrst)))\r\nreturn -EINVAL;\r\npr_debug("powerdomain: %s: setting next memory powerstate for bank %0x while pwrdm-ON to %0x\n",\r\npwrdm->name, bank, pwrst);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_set_mem_onst)\r\nret = arch_pwrdm->pwrdm_set_mem_onst(pwrdm, bank, pwrst);\r\nreturn ret;\r\n}\r\nint pwrdm_set_mem_retst(struct powerdomain *pwrdm, u8 bank, u8 pwrst)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (pwrdm->banks < (bank + 1))\r\nreturn -EEXIST;\r\nif (!(pwrdm->pwrsts_mem_ret[bank] & (1 << pwrst)))\r\nreturn -EINVAL;\r\npr_debug("powerdomain: %s: setting next memory powerstate for bank %0x while pwrdm-RET to %0x\n",\r\npwrdm->name, bank, pwrst);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_set_mem_retst)\r\nret = arch_pwrdm->pwrdm_set_mem_retst(pwrdm, bank, pwrst);\r\nreturn ret;\r\n}\r\nint pwrdm_read_logic_pwrst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_logic_pwrst)\r\nret = arch_pwrdm->pwrdm_read_logic_pwrst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_read_prev_logic_pwrst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_prev_logic_pwrst)\r\nret = arch_pwrdm->pwrdm_read_prev_logic_pwrst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_read_logic_retst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn -EINVAL;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_logic_retst)\r\nret = arch_pwrdm->pwrdm_read_logic_retst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_read_mem_pwrst(struct powerdomain *pwrdm, u8 bank)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn ret;\r\nif (pwrdm->banks < (bank + 1))\r\nreturn ret;\r\nif (pwrdm->flags & PWRDM_HAS_MPU_QUIRK)\r\nbank = 1;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_mem_pwrst)\r\nret = arch_pwrdm->pwrdm_read_mem_pwrst(pwrdm, bank);\r\nreturn ret;\r\n}\r\nint pwrdm_read_prev_mem_pwrst(struct powerdomain *pwrdm, u8 bank)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn ret;\r\nif (pwrdm->banks < (bank + 1))\r\nreturn ret;\r\nif (pwrdm->flags & PWRDM_HAS_MPU_QUIRK)\r\nbank = 1;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_prev_mem_pwrst)\r\nret = arch_pwrdm->pwrdm_read_prev_mem_pwrst(pwrdm, bank);\r\nreturn ret;\r\n}\r\nint pwrdm_read_mem_retst(struct powerdomain *pwrdm, u8 bank)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn ret;\r\nif (pwrdm->banks < (bank + 1))\r\nreturn ret;\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_read_mem_retst)\r\nret = arch_pwrdm->pwrdm_read_mem_retst(pwrdm, bank);\r\nreturn ret;\r\n}\r\nint pwrdm_clear_all_prev_pwrst(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn ret;\r\npr_debug("powerdomain: %s: clearing previous power state reg\n",\r\npwrdm->name);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_clear_all_prev_pwrst)\r\nret = arch_pwrdm->pwrdm_clear_all_prev_pwrst(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_enable_hdwr_sar(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn ret;\r\nif (!(pwrdm->flags & PWRDM_HAS_HDWR_SAR))\r\nreturn ret;\r\npr_debug("powerdomain: %s: setting SAVEANDRESTORE bit\n", pwrdm->name);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_enable_hdwr_sar)\r\nret = arch_pwrdm->pwrdm_enable_hdwr_sar(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_disable_hdwr_sar(struct powerdomain *pwrdm)\r\n{\r\nint ret = -EINVAL;\r\nif (!pwrdm)\r\nreturn ret;\r\nif (!(pwrdm->flags & PWRDM_HAS_HDWR_SAR))\r\nreturn ret;\r\npr_debug("powerdomain: %s: clearing SAVEANDRESTORE bit\n", pwrdm->name);\r\nif (arch_pwrdm && arch_pwrdm->pwrdm_disable_hdwr_sar)\r\nret = arch_pwrdm->pwrdm_disable_hdwr_sar(pwrdm);\r\nreturn ret;\r\n}\r\nbool pwrdm_has_hdwr_sar(struct powerdomain *pwrdm)\r\n{\r\nreturn (pwrdm && pwrdm->flags & PWRDM_HAS_HDWR_SAR) ? 1 : 0;\r\n}\r\nint pwrdm_state_switch_nolock(struct powerdomain *pwrdm)\r\n{\r\nint ret;\r\nif (!pwrdm || !arch_pwrdm)\r\nreturn -EINVAL;\r\nret = arch_pwrdm->pwrdm_wait_transition(pwrdm);\r\nif (!ret)\r\nret = _pwrdm_state_switch(pwrdm, PWRDM_STATE_NOW);\r\nreturn ret;\r\n}\r\nint __deprecated pwrdm_state_switch(struct powerdomain *pwrdm)\r\n{\r\nint ret;\r\npwrdm_lock(pwrdm);\r\nret = pwrdm_state_switch_nolock(pwrdm);\r\npwrdm_unlock(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_pre_transition(struct powerdomain *pwrdm)\r\n{\r\nif (pwrdm)\r\n_pwrdm_pre_transition_cb(pwrdm, NULL);\r\nelse\r\npwrdm_for_each(_pwrdm_pre_transition_cb, NULL);\r\nreturn 0;\r\n}\r\nint pwrdm_post_transition(struct powerdomain *pwrdm)\r\n{\r\nif (pwrdm)\r\n_pwrdm_post_transition_cb(pwrdm, NULL);\r\nelse\r\npwrdm_for_each(_pwrdm_post_transition_cb, NULL);\r\nreturn 0;\r\n}\r\nu8 pwrdm_get_valid_lp_state(struct powerdomain *pwrdm,\r\nbool is_logic_state, u8 req_state)\r\n{\r\nu8 pwrdm_states = is_logic_state ? pwrdm->pwrsts_logic_ret :\r\npwrdm->pwrsts;\r\nu8 default_pwrst = is_logic_state ? PWRDM_POWER_RET : PWRDM_POWER_ON;\r\nu8 new_pwrst;\r\nbool found;\r\nif (pwrdm_states & BIT(req_state))\r\nreturn req_state;\r\nif (!req_state)\r\ngoto up_search;\r\nnew_pwrst = req_state - 1;\r\nfound = true;\r\nwhile (!(pwrdm_states & BIT(new_pwrst))) {\r\nif (new_pwrst == PWRDM_POWER_OFF) {\r\nfound = false;\r\nbreak;\r\n}\r\nnew_pwrst--;\r\n}\r\nif (found)\r\ngoto done;\r\nup_search:\r\nnew_pwrst = req_state + 1;\r\nwhile (!(pwrdm_states & BIT(new_pwrst))) {\r\nif (new_pwrst > PWRDM_POWER_ON) {\r\nWARN(1, "powerdomain: %s: Fix max powerstate to ON\n",\r\npwrdm->name);\r\nreturn PWRDM_POWER_ON;\r\n}\r\nif (new_pwrst == default_pwrst)\r\nbreak;\r\nnew_pwrst++;\r\n}\r\ndone:\r\nreturn new_pwrst;\r\n}\r\nint omap_set_pwrdm_state(struct powerdomain *pwrdm, u8 pwrst)\r\n{\r\nu8 next_pwrst, sleep_switch;\r\nint curr_pwrst;\r\nint ret = 0;\r\nbool hwsup = false;\r\nif (!pwrdm || IS_ERR(pwrdm))\r\nreturn -EINVAL;\r\nwhile (!(pwrdm->pwrsts & (1 << pwrst))) {\r\nif (pwrst == PWRDM_POWER_OFF)\r\nreturn ret;\r\npwrst--;\r\n}\r\npwrdm_lock(pwrdm);\r\ncurr_pwrst = pwrdm_read_pwrst(pwrdm);\r\nif (curr_pwrst < 0) {\r\nret = -EINVAL;\r\ngoto osps_out;\r\n}\r\nnext_pwrst = pwrdm_read_next_pwrst(pwrdm);\r\nif (curr_pwrst == pwrst && next_pwrst == pwrst)\r\ngoto osps_out;\r\nsleep_switch = _pwrdm_save_clkdm_state_and_activate(pwrdm, curr_pwrst,\r\npwrst, &hwsup);\r\nret = pwrdm_set_next_pwrst(pwrdm, pwrst);\r\nif (ret)\r\npr_err("%s: unable to set power state of powerdomain: %s\n",\r\n__func__, pwrdm->name);\r\n_pwrdm_restore_clkdm_state(pwrdm, sleep_switch, hwsup);\r\nosps_out:\r\npwrdm_unlock(pwrdm);\r\nreturn ret;\r\n}\r\nint pwrdm_get_context_loss_count(struct powerdomain *pwrdm)\r\n{\r\nint i, count;\r\nif (!pwrdm) {\r\nWARN(1, "powerdomain: %s: pwrdm is null\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ncount = pwrdm->state_counter[PWRDM_POWER_OFF];\r\ncount += pwrdm->ret_logic_off_counter;\r\nfor (i = 0; i < pwrdm->banks; i++)\r\ncount += pwrdm->ret_mem_off_counter[i];\r\ncount &= INT_MAX;\r\npr_debug("powerdomain: %s: context loss count = %d\n",\r\npwrdm->name, count);\r\nreturn count;\r\n}\r\nbool pwrdm_can_ever_lose_context(struct powerdomain *pwrdm)\r\n{\r\nint i;\r\nif (!pwrdm) {\r\npr_debug("powerdomain: %s: invalid powerdomain pointer\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nif (pwrdm->pwrsts & PWRSTS_OFF)\r\nreturn 1;\r\nif (pwrdm->pwrsts & PWRSTS_RET) {\r\nif (pwrdm->pwrsts_logic_ret & PWRSTS_OFF)\r\nreturn 1;\r\nfor (i = 0; i < pwrdm->banks; i++)\r\nif (pwrdm->pwrsts_mem_ret[i] & PWRSTS_OFF)\r\nreturn 1;\r\n}\r\nfor (i = 0; i < pwrdm->banks; i++)\r\nif (pwrdm->pwrsts_mem_on[i] & PWRSTS_OFF)\r\nreturn 1;\r\nreturn 0;\r\n}
