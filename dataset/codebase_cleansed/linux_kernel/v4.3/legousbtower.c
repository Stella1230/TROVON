static char *legousbtower_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "usb/%s", dev_name(dev));\r\n}\r\nstatic inline void lego_usb_tower_debug_data(struct device *dev,\r\nconst char *function, int size,\r\nconst unsigned char *data)\r\n{\r\ndev_dbg(dev, "%s - length = %d, data = %*ph\n",\r\nfunction, size, size, data);\r\n}\r\nstatic inline void tower_delete (struct lego_usb_tower *dev)\r\n{\r\ntower_abort_transfers (dev);\r\nusb_free_urb(dev->interrupt_in_urb);\r\nusb_free_urb(dev->interrupt_out_urb);\r\nkfree (dev->read_buffer);\r\nkfree (dev->interrupt_in_buffer);\r\nkfree (dev->interrupt_out_buffer);\r\nkfree (dev);\r\n}\r\nstatic int tower_open (struct inode *inode, struct file *file)\r\n{\r\nstruct lego_usb_tower *dev = NULL;\r\nint subminor;\r\nint retval = 0;\r\nstruct usb_interface *interface;\r\nstruct tower_reset_reply reset_reply;\r\nint result;\r\nnonseekable_open(inode, file);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface (&tower_driver, subminor);\r\nif (!interface) {\r\npr_err("error, can't find device for minor %d\n", subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nmutex_lock(&open_disc_mutex);\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nmutex_unlock(&open_disc_mutex);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\nmutex_unlock(&open_disc_mutex);\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->open_count) {\r\nmutex_unlock(&open_disc_mutex);\r\nretval = -EBUSY;\r\ngoto unlock_exit;\r\n}\r\ndev->open_count = 1;\r\nmutex_unlock(&open_disc_mutex);\r\nresult = usb_control_msg (dev->udev,\r\nusb_rcvctrlpipe(dev->udev, 0),\r\nLEGO_USB_TOWER_REQUEST_RESET,\r\nUSB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\r\n0,\r\n0,\r\n&reset_reply,\r\nsizeof(reset_reply),\r\n1000);\r\nif (result < 0) {\r\ndev_err(&dev->udev->dev,\r\n"LEGO USB Tower reset control request failed\n");\r\nretval = result;\r\ngoto unlock_exit;\r\n}\r\ndev->read_buffer_length = 0;\r\ndev->read_packet_length = 0;\r\nusb_fill_int_urb (dev->interrupt_in_urb,\r\ndev->udev,\r\nusb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),\r\ndev->interrupt_in_buffer,\r\nusb_endpoint_maxp(dev->interrupt_in_endpoint),\r\ntower_interrupt_in_callback,\r\ndev,\r\ndev->interrupt_in_interval);\r\ndev->interrupt_in_running = 1;\r\ndev->interrupt_in_done = 0;\r\nmb();\r\nretval = usb_submit_urb (dev->interrupt_in_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&dev->udev->dev,\r\n"Couldn't submit interrupt_in_urb %d\n", retval);\r\ndev->interrupt_in_running = 0;\r\ndev->open_count = 0;\r\ngoto unlock_exit;\r\n}\r\nfile->private_data = dev;\r\nunlock_exit:\r\nmutex_unlock(&dev->lock);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int tower_release (struct inode *inode, struct file *file)\r\n{\r\nstruct lego_usb_tower *dev;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (dev == NULL) {\r\nretval = -ENODEV;\r\ngoto exit_nolock;\r\n}\r\nmutex_lock(&open_disc_mutex);\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->open_count != 1) {\r\ndev_dbg(&dev->udev->dev, "%s: device not opened exactly once\n",\r\n__func__);\r\nretval = -ENODEV;\r\ngoto unlock_exit;\r\n}\r\nif (dev->udev == NULL) {\r\nmutex_unlock(&dev->lock);\r\ntower_delete (dev);\r\ngoto exit;\r\n}\r\nif (dev->interrupt_out_busy) {\r\nwait_event_interruptible_timeout (dev->write_wait, !dev->interrupt_out_busy, 2 * HZ);\r\n}\r\ntower_abort_transfers (dev);\r\ndev->open_count = 0;\r\nunlock_exit:\r\nmutex_unlock(&dev->lock);\r\nexit:\r\nmutex_unlock(&open_disc_mutex);\r\nexit_nolock:\r\nreturn retval;\r\n}\r\nstatic void tower_abort_transfers (struct lego_usb_tower *dev)\r\n{\r\nif (dev == NULL)\r\nreturn;\r\nif (dev->interrupt_in_running) {\r\ndev->interrupt_in_running = 0;\r\nmb();\r\nif (dev->udev)\r\nusb_kill_urb (dev->interrupt_in_urb);\r\n}\r\nif (dev->interrupt_out_busy && dev->udev)\r\nusb_kill_urb(dev->interrupt_out_urb);\r\n}\r\nstatic void tower_check_for_read_packet (struct lego_usb_tower *dev)\r\n{\r\nspin_lock_irq (&dev->read_buffer_lock);\r\nif (!packet_timeout\r\n|| time_after(jiffies, dev->read_last_arrival + dev->packet_timeout_jiffies)\r\n|| dev->read_buffer_length == read_buffer_size) {\r\ndev->read_packet_length = dev->read_buffer_length;\r\n}\r\ndev->interrupt_in_done = 0;\r\nspin_unlock_irq (&dev->read_buffer_lock);\r\n}\r\nstatic unsigned int tower_poll (struct file *file, poll_table *wait)\r\n{\r\nstruct lego_usb_tower *dev;\r\nunsigned int mask = 0;\r\ndev = file->private_data;\r\nif (!dev->udev)\r\nreturn POLLERR | POLLHUP;\r\npoll_wait(file, &dev->read_wait, wait);\r\npoll_wait(file, &dev->write_wait, wait);\r\ntower_check_for_read_packet(dev);\r\nif (dev->read_packet_length > 0) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (!dev->interrupt_out_busy) {\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic loff_t tower_llseek (struct file *file, loff_t off, int whence)\r\n{\r\nreturn -ESPIPE;\r\n}\r\nstatic ssize_t tower_read (struct file *file, char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct lego_usb_tower *dev;\r\nsize_t bytes_to_read;\r\nint i;\r\nint retval = 0;\r\nunsigned long timeout = 0;\r\ndev = file->private_data;\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->udev == NULL) {\r\nretval = -ENODEV;\r\npr_err("No device or device unplugged %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nif (count == 0) {\r\ndev_dbg(&dev->udev->dev, "read request of 0 bytes\n");\r\ngoto unlock_exit;\r\n}\r\nif (read_timeout) {\r\ntimeout = jiffies + msecs_to_jiffies(read_timeout);\r\n}\r\ntower_check_for_read_packet (dev);\r\nwhile (dev->read_packet_length == 0) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\nretval = wait_event_interruptible_timeout(dev->read_wait, dev->interrupt_in_done, dev->packet_timeout_jiffies);\r\nif (retval < 0) {\r\ngoto unlock_exit;\r\n}\r\nif (read_timeout\r\n&& (dev->read_buffer_length || dev->interrupt_out_busy)) {\r\ntimeout = jiffies + msecs_to_jiffies(read_timeout);\r\n}\r\nif (read_timeout && time_after (jiffies, timeout)) {\r\nretval = -ETIMEDOUT;\r\ngoto unlock_exit;\r\n}\r\ntower_check_for_read_packet (dev);\r\n}\r\nbytes_to_read = min(count, dev->read_packet_length);\r\nif (copy_to_user (buffer, dev->read_buffer, bytes_to_read)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\nspin_lock_irq (&dev->read_buffer_lock);\r\ndev->read_buffer_length -= bytes_to_read;\r\ndev->read_packet_length -= bytes_to_read;\r\nfor (i=0; i<dev->read_buffer_length; i++) {\r\ndev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];\r\n}\r\nspin_unlock_irq (&dev->read_buffer_lock);\r\nretval = bytes_to_read;\r\nunlock_exit:\r\nmutex_unlock(&dev->lock);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic ssize_t tower_write (struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\r\n{\r\nstruct lego_usb_tower *dev;\r\nsize_t bytes_to_write;\r\nint retval = 0;\r\ndev = file->private_data;\r\nif (mutex_lock_interruptible(&dev->lock)) {\r\nretval = -ERESTARTSYS;\r\ngoto exit;\r\n}\r\nif (dev->udev == NULL) {\r\nretval = -ENODEV;\r\npr_err("No device or device unplugged %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nif (count == 0) {\r\ndev_dbg(&dev->udev->dev, "write request of 0 bytes\n");\r\ngoto unlock_exit;\r\n}\r\nwhile (dev->interrupt_out_busy) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto unlock_exit;\r\n}\r\nretval = wait_event_interruptible (dev->write_wait, !dev->interrupt_out_busy);\r\nif (retval) {\r\ngoto unlock_exit;\r\n}\r\n}\r\nbytes_to_write = min_t(int, count, write_buffer_size);\r\ndev_dbg(&dev->udev->dev, "%s: count = %Zd, bytes_to_write = %Zd\n",\r\n__func__, count, bytes_to_write);\r\nif (copy_from_user (dev->interrupt_out_buffer, buffer, bytes_to_write)) {\r\nretval = -EFAULT;\r\ngoto unlock_exit;\r\n}\r\nusb_fill_int_urb(dev->interrupt_out_urb,\r\ndev->udev,\r\nusb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),\r\ndev->interrupt_out_buffer,\r\nbytes_to_write,\r\ntower_interrupt_out_callback,\r\ndev,\r\ndev->interrupt_out_interval);\r\ndev->interrupt_out_busy = 1;\r\nwmb();\r\nretval = usb_submit_urb (dev->interrupt_out_urb, GFP_KERNEL);\r\nif (retval) {\r\ndev->interrupt_out_busy = 0;\r\ndev_err(&dev->udev->dev,\r\n"Couldn't submit interrupt_out_urb %d\n", retval);\r\ngoto unlock_exit;\r\n}\r\nretval = bytes_to_write;\r\nunlock_exit:\r\nmutex_unlock(&dev->lock);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic void tower_interrupt_in_callback (struct urb *urb)\r\n{\r\nstruct lego_usb_tower *dev = urb->context;\r\nint status = urb->status;\r\nint retval;\r\nlego_usb_tower_debug_data(&dev->udev->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nif (status) {\r\nif (status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -ESHUTDOWN) {\r\ngoto exit;\r\n} else {\r\ndev_dbg(&dev->udev->dev,\r\n"%s: nonzero status received: %d\n", __func__,\r\nstatus);\r\ngoto resubmit;\r\n}\r\n}\r\nif (urb->actual_length > 0) {\r\nspin_lock (&dev->read_buffer_lock);\r\nif (dev->read_buffer_length + urb->actual_length < read_buffer_size) {\r\nmemcpy (dev->read_buffer + dev->read_buffer_length,\r\ndev->interrupt_in_buffer,\r\nurb->actual_length);\r\ndev->read_buffer_length += urb->actual_length;\r\ndev->read_last_arrival = jiffies;\r\ndev_dbg(&dev->udev->dev, "%s: received %d bytes\n",\r\n__func__, urb->actual_length);\r\n} else {\r\npr_warn("read_buffer overflow, %d bytes dropped\n",\r\nurb->actual_length);\r\n}\r\nspin_unlock (&dev->read_buffer_lock);\r\n}\r\nresubmit:\r\nif (dev->interrupt_in_running && dev->udev) {\r\nretval = usb_submit_urb (dev->interrupt_in_urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&dev->udev->dev,\r\n"%s: usb_submit_urb failed (%d)\n",\r\n__func__, retval);\r\n}\r\nexit:\r\ndev->interrupt_in_done = 1;\r\nwake_up_interruptible (&dev->read_wait);\r\n}\r\nstatic void tower_interrupt_out_callback (struct urb *urb)\r\n{\r\nstruct lego_usb_tower *dev = urb->context;\r\nint status = urb->status;\r\nlego_usb_tower_debug_data(&dev->udev->dev, __func__,\r\nurb->actual_length, urb->transfer_buffer);\r\nif (status && !(status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -ESHUTDOWN)) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s: nonzero write bulk status received: %d\n", __func__,\r\nstatus);\r\n}\r\ndev->interrupt_out_busy = 0;\r\nwake_up_interruptible(&dev->write_wait);\r\n}\r\nstatic int tower_probe (struct usb_interface *interface, const struct usb_device_id *id)\r\n{\r\nstruct device *idev = &interface->dev;\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct lego_usb_tower *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor* endpoint;\r\nstruct tower_get_version_reply get_version_reply;\r\nint i;\r\nint retval = -ENOMEM;\r\nint result;\r\ndev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(idev, "Out of memory\n");\r\ngoto exit;\r\n}\r\nmutex_init(&dev->lock);\r\ndev->udev = udev;\r\ndev->open_count = 0;\r\ndev->read_buffer = NULL;\r\ndev->read_buffer_length = 0;\r\ndev->read_packet_length = 0;\r\nspin_lock_init (&dev->read_buffer_lock);\r\ndev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\r\ndev->read_last_arrival = jiffies;\r\ninit_waitqueue_head (&dev->read_wait);\r\ninit_waitqueue_head (&dev->write_wait);\r\ndev->interrupt_in_buffer = NULL;\r\ndev->interrupt_in_endpoint = NULL;\r\ndev->interrupt_in_urb = NULL;\r\ndev->interrupt_in_running = 0;\r\ndev->interrupt_in_done = 0;\r\ndev->interrupt_out_buffer = NULL;\r\ndev->interrupt_out_endpoint = NULL;\r\ndev->interrupt_out_urb = NULL;\r\ndev->interrupt_out_busy = 0;\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_xfer_int(endpoint)) {\r\nif (usb_endpoint_dir_in(endpoint))\r\ndev->interrupt_in_endpoint = endpoint;\r\nelse\r\ndev->interrupt_out_endpoint = endpoint;\r\n}\r\n}\r\nif(dev->interrupt_in_endpoint == NULL) {\r\ndev_err(idev, "interrupt in endpoint not found\n");\r\ngoto error;\r\n}\r\nif (dev->interrupt_out_endpoint == NULL) {\r\ndev_err(idev, "interrupt out endpoint not found\n");\r\ngoto error;\r\n}\r\ndev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL);\r\nif (!dev->read_buffer) {\r\ndev_err(idev, "Couldn't allocate read_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\r\nif (!dev->interrupt_in_buffer) {\r\ndev_err(idev, "Couldn't allocate interrupt_in_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_in_urb) {\r\ndev_err(idev, "Couldn't allocate interrupt_in_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL);\r\nif (!dev->interrupt_out_buffer) {\r\ndev_err(idev, "Couldn't allocate interrupt_out_buffer\n");\r\ngoto error;\r\n}\r\ndev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->interrupt_out_urb) {\r\ndev_err(idev, "Couldn't allocate interrupt_out_urb\n");\r\ngoto error;\r\n}\r\ndev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\r\ndev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\r\nusb_set_intfdata (interface, dev);\r\nretval = usb_register_dev (interface, &tower_class);\r\nif (retval) {\r\ndev_err(idev, "Not able to get a minor for this device.\n");\r\nusb_set_intfdata (interface, NULL);\r\ngoto error;\r\n}\r\ndev->minor = interface->minor;\r\ndev_info(&interface->dev, "LEGO USB Tower #%d now attached to major "\r\n"%d minor %d\n", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\r\nUSB_MAJOR, dev->minor);\r\nresult = usb_control_msg (udev,\r\nusb_rcvctrlpipe(udev, 0),\r\nLEGO_USB_TOWER_REQUEST_GET_VERSION,\r\nUSB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\r\n0,\r\n0,\r\n&get_version_reply,\r\nsizeof(get_version_reply),\r\n1000);\r\nif (result < 0) {\r\ndev_err(idev, "LEGO USB Tower get version control request failed\n");\r\nretval = result;\r\ngoto error;\r\n}\r\ndev_info(&interface->dev, "LEGO USB Tower firmware version is %d.%d "\r\n"build %d\n", get_version_reply.major,\r\nget_version_reply.minor,\r\nle16_to_cpu(get_version_reply.build_no));\r\nexit:\r\nreturn retval;\r\nerror:\r\ntower_delete(dev);\r\nreturn retval;\r\n}\r\nstatic void tower_disconnect (struct usb_interface *interface)\r\n{\r\nstruct lego_usb_tower *dev;\r\nint minor;\r\ndev = usb_get_intfdata (interface);\r\nmutex_lock(&open_disc_mutex);\r\nusb_set_intfdata (interface, NULL);\r\nminor = dev->minor;\r\nusb_deregister_dev (interface, &tower_class);\r\nmutex_lock(&dev->lock);\r\nmutex_unlock(&open_disc_mutex);\r\nif (!dev->open_count) {\r\nmutex_unlock(&dev->lock);\r\ntower_delete (dev);\r\n} else {\r\ndev->udev = NULL;\r\nwake_up_interruptible_all(&dev->read_wait);\r\nwake_up_interruptible_all(&dev->write_wait);\r\nmutex_unlock(&dev->lock);\r\n}\r\ndev_info(&interface->dev, "LEGO USB Tower #%d now disconnected\n",\r\n(minor - LEGO_USB_TOWER_MINOR_BASE));\r\n}
