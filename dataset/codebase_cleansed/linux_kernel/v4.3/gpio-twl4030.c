static inline struct gpio_twl4030_priv *to_gpio_twl4030(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct gpio_twl4030_priv, gpio_chip);\r\n}\r\nstatic inline int gpio_twl4030_write(u8 address, u8 data)\r\n{\r\nreturn twl_i2c_write_u8(TWL4030_MODULE_GPIO, data, address);\r\n}\r\nstatic inline int gpio_twl4030_read(u8 address)\r\n{\r\nu8 data;\r\nint ret = 0;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_GPIO, &data, address);\r\nreturn (ret < 0) ? ret : data;\r\n}\r\nstatic void twl4030_led_set_value(int led, int value)\r\n{\r\nu8 mask = LEDEN_LEDAON | LEDEN_LEDAPWM;\r\nif (led)\r\nmask <<= 1;\r\nif (value)\r\ncached_leden &= ~mask;\r\nelse\r\ncached_leden |= mask;\r\nWARN_ON_ONCE(twl_i2c_write_u8(TWL4030_MODULE_LED, cached_leden,\r\nTWL4030_LED_LEDEN_REG));\r\n}\r\nstatic int twl4030_set_gpio_direction(int gpio, int is_input)\r\n{\r\nu8 d_bnk = gpio >> 3;\r\nu8 d_msk = BIT(gpio & 0x7);\r\nu8 reg = 0;\r\nu8 base = REG_GPIODATADIR1 + d_bnk;\r\nint ret = 0;\r\nret = gpio_twl4030_read(base);\r\nif (ret >= 0) {\r\nif (is_input)\r\nreg = ret & ~d_msk;\r\nelse\r\nreg = ret | d_msk;\r\nret = gpio_twl4030_write(base, reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int twl4030_set_gpio_dataout(int gpio, int enable)\r\n{\r\nu8 d_bnk = gpio >> 3;\r\nu8 d_msk = BIT(gpio & 0x7);\r\nu8 base = 0;\r\nif (enable)\r\nbase = REG_SETGPIODATAOUT1 + d_bnk;\r\nelse\r\nbase = REG_CLEARGPIODATAOUT1 + d_bnk;\r\nreturn gpio_twl4030_write(base, d_msk);\r\n}\r\nstatic int twl4030_get_gpio_datain(int gpio)\r\n{\r\nu8 d_bnk = gpio >> 3;\r\nu8 d_off = gpio & 0x7;\r\nu8 base = 0;\r\nint ret = 0;\r\nbase = REG_GPIODATAIN1 + d_bnk;\r\nret = gpio_twl4030_read(base);\r\nif (ret > 0)\r\nret = (ret >> d_off) & 0x1;\r\nreturn ret;\r\n}\r\nstatic int twl_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nint status = 0;\r\nmutex_lock(&priv->mutex);\r\nif (offset >= TWL4030_GPIO_MAX) {\r\nu8 ledclr_mask = LEDEN_LEDAON | LEDEN_LEDAEXT\r\n| LEDEN_LEDAPWM | LEDEN_PWM_LENGTHA;\r\nu8 reg = TWL4030_PWMAON_REG;\r\noffset -= TWL4030_GPIO_MAX;\r\nif (offset) {\r\nledclr_mask <<= 1;\r\nreg = TWL4030_PWMBON_REG;\r\n}\r\nstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, 0x7f, reg + 1);\r\nif (status < 0)\r\ngoto done;\r\nstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, 0x7f, reg);\r\nif (status < 0)\r\ngoto done;\r\nstatus = twl_i2c_read_u8(TWL4030_MODULE_LED, &cached_leden,\r\nTWL4030_LED_LEDEN_REG);\r\nif (status < 0)\r\ngoto done;\r\ncached_leden &= ~ledclr_mask;\r\nstatus = twl_i2c_write_u8(TWL4030_MODULE_LED, cached_leden,\r\nTWL4030_LED_LEDEN_REG);\r\nif (status < 0)\r\ngoto done;\r\nstatus = 0;\r\ngoto done;\r\n}\r\nif (!priv->usage_count) {\r\nstruct twl4030_gpio_platform_data *pdata;\r\nu8 value = MASK_GPIO_CTRL_GPIO_ON;\r\npdata = dev_get_platdata(chip->dev);\r\nif (pdata)\r\nvalue |= pdata->mmc_cd & 0x03;\r\nstatus = gpio_twl4030_write(REG_GPIO_CTRL, value);\r\n}\r\ndone:\r\nif (!status)\r\npriv->usage_count |= BIT(offset);\r\nmutex_unlock(&priv->mutex);\r\nreturn status;\r\n}\r\nstatic void twl_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nmutex_lock(&priv->mutex);\r\nif (offset >= TWL4030_GPIO_MAX) {\r\ntwl4030_led_set_value(offset - TWL4030_GPIO_MAX, 1);\r\ngoto out;\r\n}\r\npriv->usage_count &= ~BIT(offset);\r\nif (!priv->usage_count)\r\ngpio_twl4030_write(REG_GPIO_CTRL, 0x0);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int twl_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nif (offset < TWL4030_GPIO_MAX)\r\nret = twl4030_set_gpio_direction(offset, 1);\r\nelse\r\nret = -EINVAL;\r\nif (!ret)\r\npriv->direction &= ~BIT(offset);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int twl_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nint ret;\r\nint status = 0;\r\nmutex_lock(&priv->mutex);\r\nif (!(priv->usage_count & BIT(offset))) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nif (priv->direction & BIT(offset))\r\nstatus = priv->out_state & BIT(offset);\r\nelse\r\nstatus = twl4030_get_gpio_datain(offset);\r\nret = (status <= 0) ? 0 : 1;\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void twl_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nmutex_lock(&priv->mutex);\r\nif (offset < TWL4030_GPIO_MAX)\r\ntwl4030_set_gpio_dataout(offset, value);\r\nelse\r\ntwl4030_led_set_value(offset - TWL4030_GPIO_MAX, value);\r\nif (value)\r\npriv->out_state |= BIT(offset);\r\nelse\r\npriv->out_state &= ~BIT(offset);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int twl_direction_out(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nint ret = 0;\r\nmutex_lock(&priv->mutex);\r\nif (offset < TWL4030_GPIO_MAX) {\r\nret = twl4030_set_gpio_direction(offset, 0);\r\nif (ret) {\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\n}\r\npriv->direction |= BIT(offset);\r\nmutex_unlock(&priv->mutex);\r\ntwl_set(chip, offset, value);\r\nreturn ret;\r\n}\r\nstatic int twl_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_twl4030_priv *priv = to_gpio_twl4030(chip);\r\nreturn (priv->irq_base && (offset < TWL4030_GPIO_MAX))\r\n? (priv->irq_base + offset)\r\n: -EINVAL;\r\n}\r\nstatic int gpio_twl4030_pulls(u32 ups, u32 downs)\r\n{\r\nu8 message[5];\r\nunsigned i, gpio_bit;\r\nfor (gpio_bit = 1, i = 0; i < 5; i++) {\r\nu8 bit_mask;\r\nunsigned j;\r\nfor (bit_mask = 0, j = 0; j < 8; j += 2, gpio_bit <<= 1) {\r\nif (ups & gpio_bit)\r\nbit_mask |= 1 << (j + 1);\r\nelse if (downs & gpio_bit)\r\nbit_mask |= 1 << (j + 0);\r\n}\r\nmessage[i] = bit_mask;\r\n}\r\nreturn twl_i2c_write(TWL4030_MODULE_GPIO, message,\r\nREG_GPIOPUPDCTR1, 5);\r\n}\r\nstatic int gpio_twl4030_debounce(u32 debounce, u8 mmc_cd)\r\n{\r\nu8 message[3];\r\nmessage[0] = (debounce & 0xff) | (mmc_cd & 0x03);\r\ndebounce >>= 8;\r\nmessage[1] = (debounce & 0xff);\r\ndebounce >>= 8;\r\nmessage[2] = (debounce & 0x03);\r\nreturn twl_i2c_write(TWL4030_MODULE_GPIO, message,\r\nREG_GPIO_DEBEN1, 3);\r\n}\r\nstatic struct twl4030_gpio_platform_data *of_gpio_twl4030(struct device *dev,\r\nstruct twl4030_gpio_platform_data *pdata)\r\n{\r\nstruct twl4030_gpio_platform_data *omap_twl_info;\r\nomap_twl_info = devm_kzalloc(dev, sizeof(*omap_twl_info), GFP_KERNEL);\r\nif (!omap_twl_info)\r\nreturn NULL;\r\nif (pdata)\r\n*omap_twl_info = *pdata;\r\nomap_twl_info->use_leds = of_property_read_bool(dev->of_node,\r\n"ti,use-leds");\r\nof_property_read_u32(dev->of_node, "ti,debounce",\r\n&omap_twl_info->debounce);\r\nof_property_read_u32(dev->of_node, "ti,mmc-cd",\r\n(u32 *)&omap_twl_info->mmc_cd);\r\nof_property_read_u32(dev->of_node, "ti,pullups",\r\n&omap_twl_info->pullups);\r\nof_property_read_u32(dev->of_node, "ti,pulldowns",\r\n&omap_twl_info->pulldowns);\r\nreturn omap_twl_info;\r\n}\r\nstatic int gpio_twl4030_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct gpio_twl4030_priv *priv;\r\nint ret, irq_base;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct gpio_twl4030_priv),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (is_module()) {\r\ndev_err(&pdev->dev, "can't dispatch IRQs from modules\n");\r\ngoto no_irqs;\r\n}\r\nirq_base = irq_alloc_descs(-1, 0, TWL4030_GPIO_MAX, 0);\r\nif (irq_base < 0) {\r\ndev_err(&pdev->dev, "Failed to alloc irq_descs\n");\r\nreturn irq_base;\r\n}\r\nirq_domain_add_legacy(node, TWL4030_GPIO_MAX, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nret = twl4030_sih_setup(&pdev->dev, TWL4030_MODULE_GPIO, irq_base);\r\nif (ret < 0)\r\nreturn ret;\r\npriv->irq_base = irq_base;\r\nno_irqs:\r\npriv->gpio_chip = template_chip;\r\npriv->gpio_chip.base = -1;\r\npriv->gpio_chip.ngpio = TWL4030_GPIO_MAX;\r\npriv->gpio_chip.dev = &pdev->dev;\r\nmutex_init(&priv->mutex);\r\nif (node)\r\npdata = of_gpio_twl4030(&pdev->dev, pdata);\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "Platform data is missing\n");\r\nreturn -ENXIO;\r\n}\r\nret = gpio_twl4030_pulls(pdata->pullups, pdata->pulldowns);\r\nif (ret)\r\ndev_dbg(&pdev->dev, "pullups %.05x %.05x --> %d\n",\r\npdata->pullups, pdata->pulldowns, ret);\r\nret = gpio_twl4030_debounce(pdata->debounce, pdata->mmc_cd);\r\nif (ret)\r\ndev_dbg(&pdev->dev, "debounce %.03x %.01x --> %d\n",\r\npdata->debounce, pdata->mmc_cd, ret);\r\nif (pdata->use_leds)\r\npriv->gpio_chip.ngpio += 2;\r\nret = gpiochip_add(&priv->gpio_chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not register gpiochip, %d\n", ret);\r\npriv->gpio_chip.ngpio = 0;\r\ngpio_twl4030_remove(pdev);\r\ngoto out;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nif (pdata->setup) {\r\nint status;\r\nstatus = pdata->setup(&pdev->dev, priv->gpio_chip.base,\r\nTWL4030_GPIO_MAX);\r\nif (status)\r\ndev_dbg(&pdev->dev, "setup --> %d\n", status);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int gpio_twl4030_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_gpio_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct gpio_twl4030_priv *priv = platform_get_drvdata(pdev);\r\nint status;\r\nif (pdata && pdata->teardown) {\r\nstatus = pdata->teardown(&pdev->dev, priv->gpio_chip.base,\r\nTWL4030_GPIO_MAX);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "teardown --> %d\n", status);\r\nreturn status;\r\n}\r\n}\r\ngpiochip_remove(&priv->gpio_chip);\r\nif (is_module())\r\nreturn 0;\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nstatic int __init gpio_twl4030_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_twl4030_driver);\r\n}\r\nstatic void __exit gpio_twl4030_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_twl4030_driver);\r\n}
