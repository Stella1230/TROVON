static int count_idrs(int id, void *p, void *data)\r\n{\r\nint *countp = data;\r\n*countp = *countp + 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t debugfs_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct c4iw_debugfs_data *d = file->private_data;\r\nreturn simple_read_from_buffer(buf, count, ppos, d->buf, d->pos);\r\n}\r\nvoid c4iw_log_wr_stats(struct t4_wq *wq, struct t4_cqe *cqe)\r\n{\r\nstruct wr_log_entry le;\r\nint idx;\r\nif (!wq->rdev->wr_log)\r\nreturn;\r\nidx = (atomic_inc_return(&wq->rdev->wr_log_idx) - 1) &\r\n(wq->rdev->wr_log_size - 1);\r\nle.poll_sge_ts = cxgb4_read_sge_timestamp(wq->rdev->lldi.ports[0]);\r\ngetnstimeofday(&le.poll_host_ts);\r\nle.valid = 1;\r\nle.cqe_sge_ts = CQE_TS(cqe);\r\nif (SQ_TYPE(cqe)) {\r\nle.qid = wq->sq.qid;\r\nle.opcode = CQE_OPCODE(cqe);\r\nle.post_host_ts = wq->sq.sw_sq[wq->sq.cidx].host_ts;\r\nle.post_sge_ts = wq->sq.sw_sq[wq->sq.cidx].sge_ts;\r\nle.wr_id = CQE_WRID_SQ_IDX(cqe);\r\n} else {\r\nle.qid = wq->rq.qid;\r\nle.opcode = FW_RI_RECEIVE;\r\nle.post_host_ts = wq->rq.sw_rq[wq->rq.cidx].host_ts;\r\nle.post_sge_ts = wq->rq.sw_rq[wq->rq.cidx].sge_ts;\r\nle.wr_id = CQE_WRID_MSN(cqe);\r\n}\r\nwq->rdev->wr_log[idx] = le;\r\n}\r\nstatic int wr_log_show(struct seq_file *seq, void *v)\r\n{\r\nstruct c4iw_dev *dev = seq->private;\r\nstruct timespec prev_ts = {0, 0};\r\nstruct wr_log_entry *lep;\r\nint prev_ts_set = 0;\r\nint idx, end;\r\n#define ts2ns(ts) div64_u64((ts) * dev->rdev.lldi.cclk_ps, 1000)\r\nidx = atomic_read(&dev->rdev.wr_log_idx) &\r\n(dev->rdev.wr_log_size - 1);\r\nend = idx - 1;\r\nif (end < 0)\r\nend = dev->rdev.wr_log_size - 1;\r\nlep = &dev->rdev.wr_log[idx];\r\nwhile (idx != end) {\r\nif (lep->valid) {\r\nif (!prev_ts_set) {\r\nprev_ts_set = 1;\r\nprev_ts = lep->poll_host_ts;\r\n}\r\nseq_printf(seq, "%04u: sec %lu nsec %lu qid %u opcode "\r\n"%u %s 0x%x host_wr_delta sec %lu nsec %lu "\r\n"post_sge_ts 0x%llx cqe_sge_ts 0x%llx "\r\n"poll_sge_ts 0x%llx post_poll_delta_ns %llu "\r\n"cqe_poll_delta_ns %llu\n",\r\nidx,\r\ntimespec_sub(lep->poll_host_ts,\r\nprev_ts).tv_sec,\r\ntimespec_sub(lep->poll_host_ts,\r\nprev_ts).tv_nsec,\r\nlep->qid, lep->opcode,\r\nlep->opcode == FW_RI_RECEIVE ?\r\n"msn" : "wrid",\r\nlep->wr_id,\r\ntimespec_sub(lep->poll_host_ts,\r\nlep->post_host_ts).tv_sec,\r\ntimespec_sub(lep->poll_host_ts,\r\nlep->post_host_ts).tv_nsec,\r\nlep->post_sge_ts, lep->cqe_sge_ts,\r\nlep->poll_sge_ts,\r\nts2ns(lep->poll_sge_ts - lep->post_sge_ts),\r\nts2ns(lep->poll_sge_ts - lep->cqe_sge_ts));\r\nprev_ts = lep->poll_host_ts;\r\n}\r\nidx++;\r\nif (idx > (dev->rdev.wr_log_size - 1))\r\nidx = 0;\r\nlep = &dev->rdev.wr_log[idx];\r\n}\r\n#undef ts2ns\r\nreturn 0;\r\n}\r\nstatic int wr_log_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, wr_log_show, inode->i_private);\r\n}\r\nstatic ssize_t wr_log_clear(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct c4iw_dev *dev = ((struct seq_file *)file->private_data)->private;\r\nint i;\r\nif (dev->rdev.wr_log)\r\nfor (i = 0; i < dev->rdev.wr_log_size; i++)\r\ndev->rdev.wr_log[i].valid = 0;\r\nreturn count;\r\n}\r\nstatic int dump_qp(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nstruct c4iw_debugfs_data *qpd = data;\r\nint space;\r\nint cc;\r\nif (id != qp->wq.sq.qid)\r\nreturn 0;\r\nspace = qpd->bufsize - qpd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (qp->ep) {\r\nif (qp->ep->com.local_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *lsin = (struct sockaddr_in *)\r\n&qp->ep->com.local_addr;\r\nstruct sockaddr_in *rsin = (struct sockaddr_in *)\r\n&qp->ep->com.remote_addr;\r\nstruct sockaddr_in *mapped_lsin = (struct sockaddr_in *)\r\n&qp->ep->com.mapped_local_addr;\r\nstruct sockaddr_in *mapped_rsin = (struct sockaddr_in *)\r\n&qp->ep->com.mapped_remote_addr;\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"rc qp sq id %u rq id %u state %u "\r\n"onchip %u ep tid %u state %u "\r\n"%pI4:%u/%u->%pI4:%u/%u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP,\r\nqp->ep->hwtid, (int)qp->ep->com.state,\r\n&lsin->sin_addr, ntohs(lsin->sin_port),\r\nntohs(mapped_lsin->sin_port),\r\n&rsin->sin_addr, ntohs(rsin->sin_port),\r\nntohs(mapped_rsin->sin_port));\r\n} else {\r\nstruct sockaddr_in6 *lsin6 = (struct sockaddr_in6 *)\r\n&qp->ep->com.local_addr;\r\nstruct sockaddr_in6 *rsin6 = (struct sockaddr_in6 *)\r\n&qp->ep->com.remote_addr;\r\nstruct sockaddr_in6 *mapped_lsin6 =\r\n(struct sockaddr_in6 *)\r\n&qp->ep->com.mapped_local_addr;\r\nstruct sockaddr_in6 *mapped_rsin6 =\r\n(struct sockaddr_in6 *)\r\n&qp->ep->com.mapped_remote_addr;\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"rc qp sq id %u rq id %u state %u "\r\n"onchip %u ep tid %u state %u "\r\n"%pI6:%u/%u->%pI6:%u/%u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP,\r\nqp->ep->hwtid, (int)qp->ep->com.state,\r\n&lsin6->sin6_addr,\r\nntohs(lsin6->sin6_port),\r\nntohs(mapped_lsin6->sin6_port),\r\n&rsin6->sin6_addr,\r\nntohs(rsin6->sin6_port),\r\nntohs(mapped_rsin6->sin6_port));\r\n}\r\n} else\r\ncc = snprintf(qpd->buf + qpd->pos, space,\r\n"qp sq id %u rq id %u state %u onchip %u\n",\r\nqp->wq.sq.qid, qp->wq.rq.qid,\r\n(int)qp->attr.state,\r\nqp->wq.sq.flags & T4_SQ_ONCHIP);\r\nif (cc < space)\r\nqpd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int qp_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *qpd = file->private_data;\r\nif (!qpd) {\r\nprintk(KERN_INFO "%s null qpd?\n", __func__);\r\nreturn 0;\r\n}\r\nvfree(qpd->buf);\r\nkfree(qpd);\r\nreturn 0;\r\n}\r\nstatic int qp_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *qpd;\r\nint ret = 0;\r\nint count = 1;\r\nqpd = kmalloc(sizeof *qpd, GFP_KERNEL);\r\nif (!qpd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nqpd->devp = inode->i_private;\r\nqpd->pos = 0;\r\nspin_lock_irq(&qpd->devp->lock);\r\nidr_for_each(&qpd->devp->qpidr, count_idrs, &count);\r\nspin_unlock_irq(&qpd->devp->lock);\r\nqpd->bufsize = count * 128;\r\nqpd->buf = vmalloc(qpd->bufsize);\r\nif (!qpd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&qpd->devp->lock);\r\nidr_for_each(&qpd->devp->qpidr, dump_qp, qpd);\r\nspin_unlock_irq(&qpd->devp->lock);\r\nqpd->buf[qpd->pos++] = 0;\r\nfile->private_data = qpd;\r\ngoto out;\r\nerr1:\r\nkfree(qpd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dump_stag(int id, void *p, void *data)\r\n{\r\nstruct c4iw_debugfs_data *stagd = data;\r\nint space;\r\nint cc;\r\nstruct fw_ri_tpte tpte;\r\nint ret;\r\nspace = stagd->bufsize - stagd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nret = cxgb4_read_tpte(stagd->devp->rdev.lldi.ports[0], (u32)id<<8,\r\n(__be32 *)&tpte);\r\nif (ret) {\r\ndev_err(&stagd->devp->rdev.lldi.pdev->dev,\r\n"%s cxgb4_read_tpte err %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\ncc = snprintf(stagd->buf + stagd->pos, space,\r\n"stag: idx 0x%x valid %d key 0x%x state %d pdid %d "\r\n"perm 0x%x ps %d len 0x%llx va 0x%llx\n",\r\n(u32)id<<8,\r\nFW_RI_TPTE_VALID_G(ntohl(tpte.valid_to_pdid)),\r\nFW_RI_TPTE_STAGKEY_G(ntohl(tpte.valid_to_pdid)),\r\nFW_RI_TPTE_STAGSTATE_G(ntohl(tpte.valid_to_pdid)),\r\nFW_RI_TPTE_PDID_G(ntohl(tpte.valid_to_pdid)),\r\nFW_RI_TPTE_PERM_G(ntohl(tpte.locread_to_qpid)),\r\nFW_RI_TPTE_PS_G(ntohl(tpte.locread_to_qpid)),\r\n((u64)ntohl(tpte.len_hi) << 32) | ntohl(tpte.len_lo),\r\n((u64)ntohl(tpte.va_hi) << 32) | ntohl(tpte.va_lo_fbo));\r\nif (cc < space)\r\nstagd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int stag_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *stagd = file->private_data;\r\nif (!stagd) {\r\nprintk(KERN_INFO "%s null stagd?\n", __func__);\r\nreturn 0;\r\n}\r\nvfree(stagd->buf);\r\nkfree(stagd);\r\nreturn 0;\r\n}\r\nstatic int stag_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *stagd;\r\nint ret = 0;\r\nint count = 1;\r\nstagd = kmalloc(sizeof *stagd, GFP_KERNEL);\r\nif (!stagd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstagd->devp = inode->i_private;\r\nstagd->pos = 0;\r\nspin_lock_irq(&stagd->devp->lock);\r\nidr_for_each(&stagd->devp->mmidr, count_idrs, &count);\r\nspin_unlock_irq(&stagd->devp->lock);\r\nstagd->bufsize = count * 256;\r\nstagd->buf = vmalloc(stagd->bufsize);\r\nif (!stagd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&stagd->devp->lock);\r\nidr_for_each(&stagd->devp->mmidr, dump_stag, stagd);\r\nspin_unlock_irq(&stagd->devp->lock);\r\nstagd->buf[stagd->pos++] = 0;\r\nfile->private_data = stagd;\r\ngoto out;\r\nerr1:\r\nkfree(stagd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int stats_show(struct seq_file *seq, void *v)\r\n{\r\nstruct c4iw_dev *dev = seq->private;\r\nseq_printf(seq, " Object: %10s %10s %10s %10s\n", "Total", "Current",\r\n"Max", "Fail");\r\nseq_printf(seq, " PDID: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.pd.total, dev->rdev.stats.pd.cur,\r\ndev->rdev.stats.pd.max, dev->rdev.stats.pd.fail);\r\nseq_printf(seq, " QID: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.qid.total, dev->rdev.stats.qid.cur,\r\ndev->rdev.stats.qid.max, dev->rdev.stats.qid.fail);\r\nseq_printf(seq, " TPTMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.stag.total, dev->rdev.stats.stag.cur,\r\ndev->rdev.stats.stag.max, dev->rdev.stats.stag.fail);\r\nseq_printf(seq, " PBLMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.pbl.total, dev->rdev.stats.pbl.cur,\r\ndev->rdev.stats.pbl.max, dev->rdev.stats.pbl.fail);\r\nseq_printf(seq, " RQTMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.rqt.total, dev->rdev.stats.rqt.cur,\r\ndev->rdev.stats.rqt.max, dev->rdev.stats.rqt.fail);\r\nseq_printf(seq, " OCQPMEM: %10llu %10llu %10llu %10llu\n",\r\ndev->rdev.stats.ocqp.total, dev->rdev.stats.ocqp.cur,\r\ndev->rdev.stats.ocqp.max, dev->rdev.stats.ocqp.fail);\r\nseq_printf(seq, " DB FULL: %10llu\n", dev->rdev.stats.db_full);\r\nseq_printf(seq, " DB EMPTY: %10llu\n", dev->rdev.stats.db_empty);\r\nseq_printf(seq, " DB DROP: %10llu\n", dev->rdev.stats.db_drop);\r\nseq_printf(seq, " DB State: %s Transitions %llu FC Interruptions %llu\n",\r\ndb_state_str[dev->db_state],\r\ndev->rdev.stats.db_state_transitions,\r\ndev->rdev.stats.db_fc_interruptions);\r\nseq_printf(seq, "TCAM_FULL: %10llu\n", dev->rdev.stats.tcam_full);\r\nseq_printf(seq, "ACT_OFLD_CONN_FAILS: %10llu\n",\r\ndev->rdev.stats.act_ofld_conn_fails);\r\nseq_printf(seq, "PAS_OFLD_CONN_FAILS: %10llu\n",\r\ndev->rdev.stats.pas_ofld_conn_fails);\r\nseq_printf(seq, "NEG_ADV_RCVD: %10llu\n", dev->rdev.stats.neg_adv);\r\nseq_printf(seq, "AVAILABLE IRD: %10u\n", dev->avail_ird);\r\nreturn 0;\r\n}\r\nstatic int stats_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, stats_show, inode->i_private);\r\n}\r\nstatic ssize_t stats_clear(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct c4iw_dev *dev = ((struct seq_file *)file->private_data)->private;\r\nmutex_lock(&dev->rdev.stats.lock);\r\ndev->rdev.stats.pd.max = 0;\r\ndev->rdev.stats.pd.fail = 0;\r\ndev->rdev.stats.qid.max = 0;\r\ndev->rdev.stats.qid.fail = 0;\r\ndev->rdev.stats.stag.max = 0;\r\ndev->rdev.stats.stag.fail = 0;\r\ndev->rdev.stats.pbl.max = 0;\r\ndev->rdev.stats.pbl.fail = 0;\r\ndev->rdev.stats.rqt.max = 0;\r\ndev->rdev.stats.rqt.fail = 0;\r\ndev->rdev.stats.ocqp.max = 0;\r\ndev->rdev.stats.ocqp.fail = 0;\r\ndev->rdev.stats.db_full = 0;\r\ndev->rdev.stats.db_empty = 0;\r\ndev->rdev.stats.db_drop = 0;\r\ndev->rdev.stats.db_state_transitions = 0;\r\ndev->rdev.stats.tcam_full = 0;\r\ndev->rdev.stats.act_ofld_conn_fails = 0;\r\ndev->rdev.stats.pas_ofld_conn_fails = 0;\r\nmutex_unlock(&dev->rdev.stats.lock);\r\nreturn count;\r\n}\r\nstatic int dump_ep(int id, void *p, void *data)\r\n{\r\nstruct c4iw_ep *ep = p;\r\nstruct c4iw_debugfs_data *epd = data;\r\nint space;\r\nint cc;\r\nspace = epd->bufsize - epd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (ep->com.local_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *lsin = (struct sockaddr_in *)\r\n&ep->com.local_addr;\r\nstruct sockaddr_in *rsin = (struct sockaddr_in *)\r\n&ep->com.remote_addr;\r\nstruct sockaddr_in *mapped_lsin = (struct sockaddr_in *)\r\n&ep->com.mapped_local_addr;\r\nstruct sockaddr_in *mapped_rsin = (struct sockaddr_in *)\r\n&ep->com.mapped_remote_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p qp %p state %d flags 0x%lx "\r\n"history 0x%lx hwtid %d atid %d "\r\n"conn_na %u abort_na %u "\r\n"%pI4:%d/%d <-> %pI4:%d/%d\n",\r\nep, ep->com.cm_id, ep->com.qp,\r\n(int)ep->com.state, ep->com.flags,\r\nep->com.history, ep->hwtid, ep->atid,\r\nep->stats.connect_neg_adv,\r\nep->stats.abort_neg_adv,\r\n&lsin->sin_addr, ntohs(lsin->sin_port),\r\nntohs(mapped_lsin->sin_port),\r\n&rsin->sin_addr, ntohs(rsin->sin_port),\r\nntohs(mapped_rsin->sin_port));\r\n} else {\r\nstruct sockaddr_in6 *lsin6 = (struct sockaddr_in6 *)\r\n&ep->com.local_addr;\r\nstruct sockaddr_in6 *rsin6 = (struct sockaddr_in6 *)\r\n&ep->com.remote_addr;\r\nstruct sockaddr_in6 *mapped_lsin6 = (struct sockaddr_in6 *)\r\n&ep->com.mapped_local_addr;\r\nstruct sockaddr_in6 *mapped_rsin6 = (struct sockaddr_in6 *)\r\n&ep->com.mapped_remote_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p qp %p state %d flags 0x%lx "\r\n"history 0x%lx hwtid %d atid %d "\r\n"conn_na %u abort_na %u "\r\n"%pI6:%d/%d <-> %pI6:%d/%d\n",\r\nep, ep->com.cm_id, ep->com.qp,\r\n(int)ep->com.state, ep->com.flags,\r\nep->com.history, ep->hwtid, ep->atid,\r\nep->stats.connect_neg_adv,\r\nep->stats.abort_neg_adv,\r\n&lsin6->sin6_addr, ntohs(lsin6->sin6_port),\r\nntohs(mapped_lsin6->sin6_port),\r\n&rsin6->sin6_addr, ntohs(rsin6->sin6_port),\r\nntohs(mapped_rsin6->sin6_port));\r\n}\r\nif (cc < space)\r\nepd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int dump_listen_ep(int id, void *p, void *data)\r\n{\r\nstruct c4iw_listen_ep *ep = p;\r\nstruct c4iw_debugfs_data *epd = data;\r\nint space;\r\nint cc;\r\nspace = epd->bufsize - epd->pos - 1;\r\nif (space == 0)\r\nreturn 1;\r\nif (ep->com.local_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *lsin = (struct sockaddr_in *)\r\n&ep->com.local_addr;\r\nstruct sockaddr_in *mapped_lsin = (struct sockaddr_in *)\r\n&ep->com.mapped_local_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p state %d flags 0x%lx stid %d "\r\n"backlog %d %pI4:%d/%d\n",\r\nep, ep->com.cm_id, (int)ep->com.state,\r\nep->com.flags, ep->stid, ep->backlog,\r\n&lsin->sin_addr, ntohs(lsin->sin_port),\r\nntohs(mapped_lsin->sin_port));\r\n} else {\r\nstruct sockaddr_in6 *lsin6 = (struct sockaddr_in6 *)\r\n&ep->com.local_addr;\r\nstruct sockaddr_in6 *mapped_lsin6 = (struct sockaddr_in6 *)\r\n&ep->com.mapped_local_addr;\r\ncc = snprintf(epd->buf + epd->pos, space,\r\n"ep %p cm_id %p state %d flags 0x%lx stid %d "\r\n"backlog %d %pI6:%d/%d\n",\r\nep, ep->com.cm_id, (int)ep->com.state,\r\nep->com.flags, ep->stid, ep->backlog,\r\n&lsin6->sin6_addr, ntohs(lsin6->sin6_port),\r\nntohs(mapped_lsin6->sin6_port));\r\n}\r\nif (cc < space)\r\nepd->pos += cc;\r\nreturn 0;\r\n}\r\nstatic int ep_release(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *epd = file->private_data;\r\nif (!epd) {\r\npr_info("%s null qpd?\n", __func__);\r\nreturn 0;\r\n}\r\nvfree(epd->buf);\r\nkfree(epd);\r\nreturn 0;\r\n}\r\nstatic int ep_open(struct inode *inode, struct file *file)\r\n{\r\nstruct c4iw_debugfs_data *epd;\r\nint ret = 0;\r\nint count = 1;\r\nepd = kmalloc(sizeof(*epd), GFP_KERNEL);\r\nif (!epd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nepd->devp = inode->i_private;\r\nepd->pos = 0;\r\nspin_lock_irq(&epd->devp->lock);\r\nidr_for_each(&epd->devp->hwtid_idr, count_idrs, &count);\r\nidr_for_each(&epd->devp->atid_idr, count_idrs, &count);\r\nidr_for_each(&epd->devp->stid_idr, count_idrs, &count);\r\nspin_unlock_irq(&epd->devp->lock);\r\nepd->bufsize = count * 240;\r\nepd->buf = vmalloc(epd->bufsize);\r\nif (!epd->buf) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nspin_lock_irq(&epd->devp->lock);\r\nidr_for_each(&epd->devp->hwtid_idr, dump_ep, epd);\r\nidr_for_each(&epd->devp->atid_idr, dump_ep, epd);\r\nidr_for_each(&epd->devp->stid_idr, dump_listen_ep, epd);\r\nspin_unlock_irq(&epd->devp->lock);\r\nfile->private_data = epd;\r\ngoto out;\r\nerr1:\r\nkfree(epd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int setup_debugfs(struct c4iw_dev *devp)\r\n{\r\nif (!devp->debugfs_root)\r\nreturn -1;\r\ndebugfs_create_file_size("qps", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &qp_debugfs_fops, 4096);\r\ndebugfs_create_file_size("stags", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &stag_debugfs_fops, 4096);\r\ndebugfs_create_file_size("stats", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &stats_debugfs_fops, 4096);\r\ndebugfs_create_file_size("eps", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &ep_debugfs_fops, 4096);\r\nif (c4iw_wr_log)\r\ndebugfs_create_file_size("wr_log", S_IWUSR, devp->debugfs_root,\r\n(void *)devp, &wr_log_debugfs_fops, 4096);\r\nreturn 0;\r\n}\r\nvoid c4iw_release_dev_ucontext(struct c4iw_rdev *rdev,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nstruct list_head *pos, *nxt;\r\nstruct c4iw_qid_list *entry;\r\nmutex_lock(&uctx->lock);\r\nlist_for_each_safe(pos, nxt, &uctx->qpids) {\r\nentry = list_entry(pos, struct c4iw_qid_list, entry);\r\nlist_del_init(&entry->entry);\r\nif (!(entry->qid & rdev->qpmask)) {\r\nc4iw_put_resource(&rdev->resource.qid_table,\r\nentry->qid);\r\nmutex_lock(&rdev->stats.lock);\r\nrdev->stats.qid.cur -= rdev->qpmask + 1;\r\nmutex_unlock(&rdev->stats.lock);\r\n}\r\nkfree(entry);\r\n}\r\nlist_for_each_safe(pos, nxt, &uctx->qpids) {\r\nentry = list_entry(pos, struct c4iw_qid_list, entry);\r\nlist_del_init(&entry->entry);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&uctx->lock);\r\n}\r\nvoid c4iw_init_dev_ucontext(struct c4iw_rdev *rdev,\r\nstruct c4iw_dev_ucontext *uctx)\r\n{\r\nINIT_LIST_HEAD(&uctx->qpids);\r\nINIT_LIST_HEAD(&uctx->cqids);\r\nmutex_init(&uctx->lock);\r\n}\r\nstatic int c4iw_rdev_open(struct c4iw_rdev *rdev)\r\n{\r\nint err;\r\nc4iw_init_dev_ucontext(rdev, &rdev->uctx);\r\nif (rdev->lldi.udb_density != rdev->lldi.ucq_density) {\r\npr_err(MOD "%s: unsupported udb/ucq densities %u/%u\n",\r\npci_name(rdev->lldi.pdev), rdev->lldi.udb_density,\r\nrdev->lldi.ucq_density);\r\nerr = -EINVAL;\r\ngoto err1;\r\n}\r\nif (rdev->lldi.vr->qp.start != rdev->lldi.vr->cq.start ||\r\nrdev->lldi.vr->qp.size != rdev->lldi.vr->cq.size) {\r\npr_err(MOD "%s: unsupported qp and cq id ranges "\r\n"qp start %u size %u cq start %u size %u\n",\r\npci_name(rdev->lldi.pdev), rdev->lldi.vr->qp.start,\r\nrdev->lldi.vr->qp.size, rdev->lldi.vr->cq.size,\r\nrdev->lldi.vr->cq.size);\r\nerr = -EINVAL;\r\ngoto err1;\r\n}\r\nrdev->qpmask = rdev->lldi.udb_density - 1;\r\nrdev->cqmask = rdev->lldi.ucq_density - 1;\r\nPDBG("%s dev %s stag start 0x%0x size 0x%0x num stags %d "\r\n"pbl start 0x%0x size 0x%0x rq start 0x%0x size 0x%0x "\r\n"qp qid start %u size %u cq qid start %u size %u\n",\r\n__func__, pci_name(rdev->lldi.pdev), rdev->lldi.vr->stag.start,\r\nrdev->lldi.vr->stag.size, c4iw_num_stags(rdev),\r\nrdev->lldi.vr->pbl.start,\r\nrdev->lldi.vr->pbl.size, rdev->lldi.vr->rq.start,\r\nrdev->lldi.vr->rq.size,\r\nrdev->lldi.vr->qp.start,\r\nrdev->lldi.vr->qp.size,\r\nrdev->lldi.vr->cq.start,\r\nrdev->lldi.vr->cq.size);\r\nPDBG("udb len 0x%x udb base %p db_reg %p gts_reg %p "\r\n"qpmask 0x%x cqmask 0x%x\n",\r\n(unsigned)pci_resource_len(rdev->lldi.pdev, 2),\r\n(void *)pci_resource_start(rdev->lldi.pdev, 2),\r\nrdev->lldi.db_reg, rdev->lldi.gts_reg,\r\nrdev->qpmask, rdev->cqmask);\r\nif (c4iw_num_stags(rdev) == 0) {\r\nerr = -EINVAL;\r\ngoto err1;\r\n}\r\nrdev->stats.pd.total = T4_MAX_NUM_PD;\r\nrdev->stats.stag.total = rdev->lldi.vr->stag.size;\r\nrdev->stats.pbl.total = rdev->lldi.vr->pbl.size;\r\nrdev->stats.rqt.total = rdev->lldi.vr->rq.size;\r\nrdev->stats.ocqp.total = rdev->lldi.vr->ocq.size;\r\nrdev->stats.qid.total = rdev->lldi.vr->qp.size;\r\nerr = c4iw_init_resource(rdev, c4iw_num_stags(rdev), T4_MAX_NUM_PD);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing resources\n", err);\r\ngoto err1;\r\n}\r\nerr = c4iw_pblpool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing pbl pool\n", err);\r\ngoto err2;\r\n}\r\nerr = c4iw_rqtpool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing rqt pool\n", err);\r\ngoto err3;\r\n}\r\nerr = c4iw_ocqp_pool_create(rdev);\r\nif (err) {\r\nprintk(KERN_ERR MOD "error %d initializing ocqp pool\n", err);\r\ngoto err4;\r\n}\r\nrdev->status_page = (struct t4_dev_status_page *)\r\n__get_free_page(GFP_KERNEL);\r\nif (!rdev->status_page) {\r\npr_err(MOD "error allocating status page\n");\r\ngoto err4;\r\n}\r\nif (c4iw_wr_log) {\r\nrdev->wr_log = kzalloc((1 << c4iw_wr_log_size_order) *\r\nsizeof(*rdev->wr_log), GFP_KERNEL);\r\nif (rdev->wr_log) {\r\nrdev->wr_log_size = 1 << c4iw_wr_log_size_order;\r\natomic_set(&rdev->wr_log_idx, 0);\r\n} else {\r\npr_err(MOD "error allocating wr_log. Logging disabled\n");\r\n}\r\n}\r\nrdev->status_page->db_off = 0;\r\nreturn 0;\r\nerr4:\r\nc4iw_rqtpool_destroy(rdev);\r\nerr3:\r\nc4iw_pblpool_destroy(rdev);\r\nerr2:\r\nc4iw_destroy_resource(&rdev->resource);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void c4iw_rdev_close(struct c4iw_rdev *rdev)\r\n{\r\nkfree(rdev->wr_log);\r\nfree_page((unsigned long)rdev->status_page);\r\nc4iw_pblpool_destroy(rdev);\r\nc4iw_rqtpool_destroy(rdev);\r\nc4iw_destroy_resource(&rdev->resource);\r\n}\r\nstatic void c4iw_dealloc(struct uld_ctx *ctx)\r\n{\r\nc4iw_rdev_close(&ctx->dev->rdev);\r\nidr_destroy(&ctx->dev->cqidr);\r\nidr_destroy(&ctx->dev->qpidr);\r\nidr_destroy(&ctx->dev->mmidr);\r\nidr_destroy(&ctx->dev->hwtid_idr);\r\nidr_destroy(&ctx->dev->stid_idr);\r\nidr_destroy(&ctx->dev->atid_idr);\r\nif (ctx->dev->rdev.bar2_kva)\r\niounmap(ctx->dev->rdev.bar2_kva);\r\nif (ctx->dev->rdev.oc_mw_kva)\r\niounmap(ctx->dev->rdev.oc_mw_kva);\r\nib_dealloc_device(&ctx->dev->ibdev);\r\nctx->dev = NULL;\r\n}\r\nstatic void c4iw_remove(struct uld_ctx *ctx)\r\n{\r\nPDBG("%s c4iw_dev %p\n", __func__, ctx->dev);\r\nc4iw_unregister_device(ctx->dev);\r\nc4iw_dealloc(ctx);\r\n}\r\nstatic int rdma_supported(const struct cxgb4_lld_info *infop)\r\n{\r\nreturn infop->vr->stag.size > 0 && infop->vr->pbl.size > 0 &&\r\ninfop->vr->rq.size > 0 && infop->vr->qp.size > 0 &&\r\ninfop->vr->cq.size > 0;\r\n}\r\nstatic struct c4iw_dev *c4iw_alloc(const struct cxgb4_lld_info *infop)\r\n{\r\nstruct c4iw_dev *devp;\r\nint ret;\r\nif (!rdma_supported(infop)) {\r\nprintk(KERN_INFO MOD "%s: RDMA not supported on this device.\n",\r\npci_name(infop->pdev));\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nif (!ocqp_supported(infop))\r\npr_info("%s: On-Chip Queues not supported on this device.\n",\r\npci_name(infop->pdev));\r\ndevp = (struct c4iw_dev *)ib_alloc_device(sizeof(*devp));\r\nif (!devp) {\r\nprintk(KERN_ERR MOD "Cannot allocate ib device\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndevp->rdev.lldi = *infop;\r\nPDBG("%s: Ing. padding boundary is %d, egrsstatuspagesize = %d\n",\r\n__func__, devp->rdev.lldi.sge_ingpadboundary,\r\ndevp->rdev.lldi.sge_egrstatuspagesize);\r\ndevp->rdev.hw_queue.t4_eq_status_entries =\r\ndevp->rdev.lldi.sge_ingpadboundary > 64 ? 2 : 1;\r\ndevp->rdev.hw_queue.t4_max_eq_size = 65520;\r\ndevp->rdev.hw_queue.t4_max_iq_size = 65520;\r\ndevp->rdev.hw_queue.t4_max_rq_size = 8192 -\r\ndevp->rdev.hw_queue.t4_eq_status_entries - 1;\r\ndevp->rdev.hw_queue.t4_max_sq_size =\r\ndevp->rdev.hw_queue.t4_max_eq_size -\r\ndevp->rdev.hw_queue.t4_eq_status_entries - 1;\r\ndevp->rdev.hw_queue.t4_max_qp_depth =\r\ndevp->rdev.hw_queue.t4_max_rq_size;\r\ndevp->rdev.hw_queue.t4_max_cq_depth =\r\ndevp->rdev.hw_queue.t4_max_iq_size - 2;\r\ndevp->rdev.hw_queue.t4_stat_len =\r\ndevp->rdev.lldi.sge_egrstatuspagesize;\r\ndevp->rdev.bar2_pa = pci_resource_start(devp->rdev.lldi.pdev, 2);\r\nif (is_t5(devp->rdev.lldi.adapter_type)) {\r\ndevp->rdev.bar2_kva = ioremap_wc(devp->rdev.bar2_pa,\r\npci_resource_len(devp->rdev.lldi.pdev, 2));\r\nif (!devp->rdev.bar2_kva) {\r\npr_err(MOD "Unable to ioremap BAR2\n");\r\nib_dealloc_device(&devp->ibdev);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n} else if (ocqp_supported(infop)) {\r\ndevp->rdev.oc_mw_pa =\r\npci_resource_start(devp->rdev.lldi.pdev, 2) +\r\npci_resource_len(devp->rdev.lldi.pdev, 2) -\r\nroundup_pow_of_two(devp->rdev.lldi.vr->ocq.size);\r\ndevp->rdev.oc_mw_kva = ioremap_wc(devp->rdev.oc_mw_pa,\r\ndevp->rdev.lldi.vr->ocq.size);\r\nif (!devp->rdev.oc_mw_kva) {\r\npr_err(MOD "Unable to ioremap onchip mem\n");\r\nib_dealloc_device(&devp->ibdev);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nPDBG(KERN_INFO MOD "ocq memory: "\r\n"hw_start 0x%x size %u mw_pa 0x%lx mw_kva %p\n",\r\ndevp->rdev.lldi.vr->ocq.start, devp->rdev.lldi.vr->ocq.size,\r\ndevp->rdev.oc_mw_pa, devp->rdev.oc_mw_kva);\r\nret = c4iw_rdev_open(&devp->rdev);\r\nif (ret) {\r\nprintk(KERN_ERR MOD "Unable to open CXIO rdev err %d\n", ret);\r\nib_dealloc_device(&devp->ibdev);\r\nreturn ERR_PTR(ret);\r\n}\r\nidr_init(&devp->cqidr);\r\nidr_init(&devp->qpidr);\r\nidr_init(&devp->mmidr);\r\nidr_init(&devp->hwtid_idr);\r\nidr_init(&devp->stid_idr);\r\nidr_init(&devp->atid_idr);\r\nspin_lock_init(&devp->lock);\r\nmutex_init(&devp->rdev.stats.lock);\r\nmutex_init(&devp->db_mutex);\r\nINIT_LIST_HEAD(&devp->db_fc_list);\r\ndevp->avail_ird = devp->rdev.lldi.max_ird_adapter;\r\nif (c4iw_debugfs_root) {\r\ndevp->debugfs_root = debugfs_create_dir(\r\npci_name(devp->rdev.lldi.pdev),\r\nc4iw_debugfs_root);\r\nsetup_debugfs(devp);\r\n}\r\nreturn devp;\r\n}\r\nstatic void *c4iw_uld_add(const struct cxgb4_lld_info *infop)\r\n{\r\nstruct uld_ctx *ctx;\r\nstatic int vers_printed;\r\nint i;\r\nif (!vers_printed++)\r\npr_info("Chelsio T4/T5 RDMA Driver - version %s\n",\r\nDRV_VERSION);\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx) {\r\nctx = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nctx->lldi = *infop;\r\nPDBG("%s found device %s nchan %u nrxq %u ntxq %u nports %u\n",\r\n__func__, pci_name(ctx->lldi.pdev),\r\nctx->lldi.nchan, ctx->lldi.nrxq,\r\nctx->lldi.ntxq, ctx->lldi.nports);\r\nmutex_lock(&dev_mutex);\r\nlist_add_tail(&ctx->entry, &uld_ctx_list);\r\nmutex_unlock(&dev_mutex);\r\nfor (i = 0; i < ctx->lldi.nrxq; i++)\r\nPDBG("rxqid[%u] %u\n", i, ctx->lldi.rxq_ids[i]);\r\nout:\r\nreturn ctx;\r\n}\r\nstatic inline struct sk_buff *copy_gl_to_skb_pkt(const struct pkt_gl *gl,\r\nconst __be64 *rsp,\r\nu32 pktshift)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(gl->tot_len + sizeof(struct cpl_pass_accept_req) +\r\nsizeof(struct rss_header) - pktshift, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn NULL;\r\n__skb_put(skb, gl->tot_len + sizeof(struct cpl_pass_accept_req) +\r\nsizeof(struct rss_header) - pktshift);\r\nskb_copy_to_linear_data(skb, rsp, sizeof(struct cpl_pass_accept_req) +\r\nsizeof(struct rss_header));\r\nskb_copy_to_linear_data_offset(skb, sizeof(struct rss_header) +\r\nsizeof(struct cpl_pass_accept_req),\r\ngl->va + pktshift,\r\ngl->tot_len - pktshift);\r\nreturn skb;\r\n}\r\nstatic inline int recv_rx_pkt(struct c4iw_dev *dev, const struct pkt_gl *gl,\r\nconst __be64 *rsp)\r\n{\r\nunsigned int opcode = *(u8 *)rsp;\r\nstruct sk_buff *skb;\r\nif (opcode != CPL_RX_PKT)\r\ngoto out;\r\nskb = copy_gl_to_skb_pkt(gl , rsp, dev->rdev.lldi.sge_pktshift);\r\nif (skb == NULL)\r\ngoto out;\r\nif (c4iw_handlers[opcode] == NULL) {\r\npr_info("%s no handler opcode 0x%x...\n", __func__,\r\nopcode);\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nc4iw_handlers[opcode](dev, skb);\r\nreturn 1;\r\nout:\r\nreturn 0;\r\n}\r\nstatic int c4iw_uld_rx_handler(void *handle, const __be64 *rsp,\r\nconst struct pkt_gl *gl)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nstruct c4iw_dev *dev = ctx->dev;\r\nstruct sk_buff *skb;\r\nu8 opcode;\r\nif (gl == NULL) {\r\nunsigned int len = 64 - sizeof(struct rsp_ctrl) - 8;\r\nskb = alloc_skb(256, GFP_ATOMIC);\r\nif (!skb)\r\ngoto nomem;\r\n__skb_put(skb, len);\r\nskb_copy_to_linear_data(skb, &rsp[1], len);\r\n} else if (gl == CXGB4_MSG_AN) {\r\nconst struct rsp_ctrl *rc = (void *)rsp;\r\nu32 qid = be32_to_cpu(rc->pldbuflen_qid);\r\nc4iw_ev_handler(dev, qid);\r\nreturn 0;\r\n} else if (unlikely(*(u8 *)rsp != *(u8 *)gl->va)) {\r\nif (recv_rx_pkt(dev, gl, rsp))\r\nreturn 0;\r\npr_info("%s: unexpected FL contents at %p, " \\r\n"RSS %#llx, FL %#llx, len %u\n",\r\npci_name(ctx->lldi.pdev), gl->va,\r\n(unsigned long long)be64_to_cpu(*rsp),\r\n(unsigned long long)be64_to_cpu(\r\n*(__force __be64 *)gl->va),\r\ngl->tot_len);\r\nreturn 0;\r\n} else {\r\nskb = cxgb4_pktgl_to_skb(gl, 128, 128);\r\nif (unlikely(!skb))\r\ngoto nomem;\r\n}\r\nopcode = *(u8 *)rsp;\r\nif (c4iw_handlers[opcode]) {\r\nc4iw_handlers[opcode](dev, skb);\r\n} else {\r\npr_info("%s no handler opcode 0x%x...\n", __func__,\r\nopcode);\r\nkfree_skb(skb);\r\n}\r\nreturn 0;\r\nnomem:\r\nreturn -1;\r\n}\r\nstatic int c4iw_uld_state_change(void *handle, enum cxgb4_state new_state)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nPDBG("%s new_state %u\n", __func__, new_state);\r\nswitch (new_state) {\r\ncase CXGB4_STATE_UP:\r\nprintk(KERN_INFO MOD "%s: Up\n", pci_name(ctx->lldi.pdev));\r\nif (!ctx->dev) {\r\nint ret;\r\nctx->dev = c4iw_alloc(&ctx->lldi);\r\nif (IS_ERR(ctx->dev)) {\r\nprintk(KERN_ERR MOD\r\n"%s: initialization failed: %ld\n",\r\npci_name(ctx->lldi.pdev),\r\nPTR_ERR(ctx->dev));\r\nctx->dev = NULL;\r\nbreak;\r\n}\r\nret = c4iw_register_device(ctx->dev);\r\nif (ret) {\r\nprintk(KERN_ERR MOD\r\n"%s: RDMA registration failed: %d\n",\r\npci_name(ctx->lldi.pdev), ret);\r\nc4iw_dealloc(ctx);\r\n}\r\n}\r\nbreak;\r\ncase CXGB4_STATE_DOWN:\r\nprintk(KERN_INFO MOD "%s: Down\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nbreak;\r\ncase CXGB4_STATE_START_RECOVERY:\r\nprintk(KERN_INFO MOD "%s: Fatal Error\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev) {\r\nstruct ib_event event;\r\nctx->dev->rdev.flags |= T4_FATAL_ERROR;\r\nmemset(&event, 0, sizeof event);\r\nevent.event = IB_EVENT_DEVICE_FATAL;\r\nevent.device = &ctx->dev->ibdev;\r\nib_dispatch_event(&event);\r\nc4iw_remove(ctx);\r\n}\r\nbreak;\r\ncase CXGB4_STATE_DETACH:\r\nprintk(KERN_INFO MOD "%s: Detach\n",\r\npci_name(ctx->lldi.pdev));\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int disable_qp_db(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nt4_disable_wq_db(&qp->wq);\r\nreturn 0;\r\n}\r\nstatic void stop_queues(struct uld_ctx *ctx)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->dev->lock, flags);\r\nctx->dev->rdev.stats.db_state_transitions++;\r\nctx->dev->db_state = STOPPED;\r\nif (ctx->dev->rdev.flags & T4_STATUS_PAGE_DISABLED)\r\nidr_for_each(&ctx->dev->qpidr, disable_qp_db, NULL);\r\nelse\r\nctx->dev->rdev.status_page->db_off = 1;\r\nspin_unlock_irqrestore(&ctx->dev->lock, flags);\r\n}\r\nstatic int enable_qp_db(int id, void *p, void *data)\r\n{\r\nstruct c4iw_qp *qp = p;\r\nt4_enable_wq_db(&qp->wq);\r\nreturn 0;\r\n}\r\nstatic void resume_rc_qp(struct c4iw_qp *qp)\r\n{\r\nspin_lock(&qp->lock);\r\nt4_ring_sq_db(&qp->wq, qp->wq.sq.wq_pidx_inc,\r\nis_t5(qp->rhp->rdev.lldi.adapter_type), NULL);\r\nqp->wq.sq.wq_pidx_inc = 0;\r\nt4_ring_rq_db(&qp->wq, qp->wq.rq.wq_pidx_inc,\r\nis_t5(qp->rhp->rdev.lldi.adapter_type), NULL);\r\nqp->wq.rq.wq_pidx_inc = 0;\r\nspin_unlock(&qp->lock);\r\n}\r\nstatic void resume_a_chunk(struct uld_ctx *ctx)\r\n{\r\nint i;\r\nstruct c4iw_qp *qp;\r\nfor (i = 0; i < DB_FC_RESUME_SIZE; i++) {\r\nqp = list_first_entry(&ctx->dev->db_fc_list, struct c4iw_qp,\r\ndb_fc_entry);\r\nlist_del_init(&qp->db_fc_entry);\r\nresume_rc_qp(qp);\r\nif (list_empty(&ctx->dev->db_fc_list))\r\nbreak;\r\n}\r\n}\r\nstatic void resume_queues(struct uld_ctx *ctx)\r\n{\r\nspin_lock_irq(&ctx->dev->lock);\r\nif (ctx->dev->db_state != STOPPED)\r\ngoto out;\r\nctx->dev->db_state = FLOW_CONTROL;\r\nwhile (1) {\r\nif (list_empty(&ctx->dev->db_fc_list)) {\r\nWARN_ON(ctx->dev->db_state != FLOW_CONTROL);\r\nctx->dev->db_state = NORMAL;\r\nctx->dev->rdev.stats.db_state_transitions++;\r\nif (ctx->dev->rdev.flags & T4_STATUS_PAGE_DISABLED) {\r\nidr_for_each(&ctx->dev->qpidr, enable_qp_db,\r\nNULL);\r\n} else {\r\nctx->dev->rdev.status_page->db_off = 0;\r\n}\r\nbreak;\r\n} else {\r\nif (cxgb4_dbfifo_count(ctx->dev->rdev.lldi.ports[0], 1)\r\n< (ctx->dev->rdev.lldi.dbfifo_int_thresh <<\r\nDB_FC_DRAIN_THRESH)) {\r\nresume_a_chunk(ctx);\r\n}\r\nif (!list_empty(&ctx->dev->db_fc_list)) {\r\nspin_unlock_irq(&ctx->dev->lock);\r\nif (DB_FC_RESUME_DELAY) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(DB_FC_RESUME_DELAY);\r\n}\r\nspin_lock_irq(&ctx->dev->lock);\r\nif (ctx->dev->db_state != FLOW_CONTROL)\r\nbreak;\r\n}\r\n}\r\n}\r\nout:\r\nif (ctx->dev->db_state != NORMAL)\r\nctx->dev->rdev.stats.db_fc_interruptions++;\r\nspin_unlock_irq(&ctx->dev->lock);\r\n}\r\nstatic int add_and_ref_qp(int id, void *p, void *data)\r\n{\r\nstruct qp_list *qp_listp = data;\r\nstruct c4iw_qp *qp = p;\r\nc4iw_qp_add_ref(&qp->ibqp);\r\nqp_listp->qps[qp_listp->idx++] = qp;\r\nreturn 0;\r\n}\r\nstatic int count_qps(int id, void *p, void *data)\r\n{\r\nunsigned *countp = data;\r\n(*countp)++;\r\nreturn 0;\r\n}\r\nstatic void deref_qps(struct qp_list *qp_list)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < qp_list->idx; idx++)\r\nc4iw_qp_rem_ref(&qp_list->qps[idx]->ibqp);\r\n}\r\nstatic void recover_lost_dbs(struct uld_ctx *ctx, struct qp_list *qp_list)\r\n{\r\nint idx;\r\nint ret;\r\nfor (idx = 0; idx < qp_list->idx; idx++) {\r\nstruct c4iw_qp *qp = qp_list->qps[idx];\r\nspin_lock_irq(&qp->rhp->lock);\r\nspin_lock(&qp->lock);\r\nret = cxgb4_sync_txq_pidx(qp->rhp->rdev.lldi.ports[0],\r\nqp->wq.sq.qid,\r\nt4_sq_host_wq_pidx(&qp->wq),\r\nt4_sq_wq_size(&qp->wq));\r\nif (ret) {\r\npr_err(MOD "%s: Fatal error - "\r\n"DB overflow recovery failed - "\r\n"error syncing SQ qid %u\n",\r\npci_name(ctx->lldi.pdev), qp->wq.sq.qid);\r\nspin_unlock(&qp->lock);\r\nspin_unlock_irq(&qp->rhp->lock);\r\nreturn;\r\n}\r\nqp->wq.sq.wq_pidx_inc = 0;\r\nret = cxgb4_sync_txq_pidx(qp->rhp->rdev.lldi.ports[0],\r\nqp->wq.rq.qid,\r\nt4_rq_host_wq_pidx(&qp->wq),\r\nt4_rq_wq_size(&qp->wq));\r\nif (ret) {\r\npr_err(MOD "%s: Fatal error - "\r\n"DB overflow recovery failed - "\r\n"error syncing RQ qid %u\n",\r\npci_name(ctx->lldi.pdev), qp->wq.rq.qid);\r\nspin_unlock(&qp->lock);\r\nspin_unlock_irq(&qp->rhp->lock);\r\nreturn;\r\n}\r\nqp->wq.rq.wq_pidx_inc = 0;\r\nspin_unlock(&qp->lock);\r\nspin_unlock_irq(&qp->rhp->lock);\r\nwhile (cxgb4_dbfifo_count(qp->rhp->rdev.lldi.ports[0], 1) > 0) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(10));\r\n}\r\n}\r\n}\r\nstatic void recover_queues(struct uld_ctx *ctx)\r\n{\r\nint count = 0;\r\nstruct qp_list qp_list;\r\nint ret;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(1000));\r\nret = cxgb4_flush_eq_cache(ctx->dev->rdev.lldi.ports[0]);\r\nif (ret) {\r\nprintk(KERN_ERR MOD "%s: Fatal error - DB overflow recovery failed\n",\r\npci_name(ctx->lldi.pdev));\r\nreturn;\r\n}\r\nspin_lock_irq(&ctx->dev->lock);\r\nWARN_ON(ctx->dev->db_state != STOPPED);\r\nctx->dev->db_state = RECOVERY;\r\nidr_for_each(&ctx->dev->qpidr, count_qps, &count);\r\nqp_list.qps = kzalloc(count * sizeof *qp_list.qps, GFP_ATOMIC);\r\nif (!qp_list.qps) {\r\nprintk(KERN_ERR MOD "%s: Fatal error - DB overflow recovery failed\n",\r\npci_name(ctx->lldi.pdev));\r\nspin_unlock_irq(&ctx->dev->lock);\r\nreturn;\r\n}\r\nqp_list.idx = 0;\r\nidr_for_each(&ctx->dev->qpidr, add_and_ref_qp, &qp_list);\r\nspin_unlock_irq(&ctx->dev->lock);\r\nrecover_lost_dbs(ctx, &qp_list);\r\nderef_qps(&qp_list);\r\nkfree(qp_list.qps);\r\nspin_lock_irq(&ctx->dev->lock);\r\nWARN_ON(ctx->dev->db_state != RECOVERY);\r\nctx->dev->db_state = STOPPED;\r\nspin_unlock_irq(&ctx->dev->lock);\r\n}\r\nstatic int c4iw_uld_control(void *handle, enum cxgb4_control control, ...)\r\n{\r\nstruct uld_ctx *ctx = handle;\r\nswitch (control) {\r\ncase CXGB4_CONTROL_DB_FULL:\r\nstop_queues(ctx);\r\nctx->dev->rdev.stats.db_full++;\r\nbreak;\r\ncase CXGB4_CONTROL_DB_EMPTY:\r\nresume_queues(ctx);\r\nmutex_lock(&ctx->dev->rdev.stats.lock);\r\nctx->dev->rdev.stats.db_empty++;\r\nmutex_unlock(&ctx->dev->rdev.stats.lock);\r\nbreak;\r\ncase CXGB4_CONTROL_DB_DROP:\r\nrecover_queues(ctx);\r\nmutex_lock(&ctx->dev->rdev.stats.lock);\r\nctx->dev->rdev.stats.db_drop++;\r\nmutex_unlock(&ctx->dev->rdev.stats.lock);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING MOD "%s: unknown control cmd %u\n",\r\npci_name(ctx->lldi.pdev), control);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init c4iw_init_module(void)\r\n{\r\nint err;\r\nerr = c4iw_cm_init();\r\nif (err)\r\nreturn err;\r\nc4iw_debugfs_root = debugfs_create_dir(DRV_NAME, NULL);\r\nif (!c4iw_debugfs_root)\r\nprintk(KERN_WARNING MOD\r\n"could not create debugfs entry, continuing\n");\r\nif (ibnl_add_client(RDMA_NL_C4IW, RDMA_NL_IWPM_NUM_OPS,\r\nc4iw_nl_cb_table))\r\npr_err("%s[%u]: Failed to add netlink callback\n"\r\n, __func__, __LINE__);\r\nerr = iwpm_init(RDMA_NL_C4IW);\r\nif (err) {\r\npr_err("port mapper initialization failed with %d\n", err);\r\nibnl_remove_client(RDMA_NL_C4IW);\r\nc4iw_cm_term();\r\ndebugfs_remove_recursive(c4iw_debugfs_root);\r\nreturn err;\r\n}\r\ncxgb4_register_uld(CXGB4_ULD_RDMA, &c4iw_uld_info);\r\nreturn 0;\r\n}\r\nstatic void __exit c4iw_exit_module(void)\r\n{\r\nstruct uld_ctx *ctx, *tmp;\r\nmutex_lock(&dev_mutex);\r\nlist_for_each_entry_safe(ctx, tmp, &uld_ctx_list, entry) {\r\nif (ctx->dev)\r\nc4iw_remove(ctx);\r\nkfree(ctx);\r\n}\r\nmutex_unlock(&dev_mutex);\r\ncxgb4_unregister_uld(CXGB4_ULD_RDMA);\r\niwpm_exit(RDMA_NL_C4IW);\r\nibnl_remove_client(RDMA_NL_C4IW);\r\nc4iw_cm_term();\r\ndebugfs_remove_recursive(c4iw_debugfs_root);\r\n}
