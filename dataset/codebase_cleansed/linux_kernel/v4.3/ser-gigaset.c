static int write_modem(struct cardstate *cs)\r\n{\r\nstruct tty_struct *tty = cs->hw.ser->tty;\r\nstruct bc_state *bcs = &cs->bcs[0];\r\nstruct sk_buff *skb = bcs->tx_skb;\r\nint sent = -EOPNOTSUPP;\r\nif (!tty || !tty->driver || !skb)\r\nreturn -EINVAL;\r\nif (!skb->len) {\r\ndev_kfree_skb_any(skb);\r\nbcs->tx_skb = NULL;\r\nreturn -EINVAL;\r\n}\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (tty->ops->write)\r\nsent = tty->ops->write(tty, skb->data, skb->len);\r\ngig_dbg(DEBUG_OUTPUT, "write_modem: sent %d", sent);\r\nif (sent < 0) {\r\nflush_send_queue(cs);\r\nreturn sent;\r\n}\r\nskb_pull(skb, sent);\r\nif (!skb->len) {\r\ngigaset_skb_sent(bcs, skb);\r\ngig_dbg(DEBUG_INTR, "kfree skb (Adr: %lx)!",\r\n(unsigned long) skb);\r\ndev_kfree_skb_any(skb);\r\nbcs->tx_skb = NULL;\r\n}\r\nreturn sent;\r\n}\r\nstatic int send_cb(struct cardstate *cs)\r\n{\r\nstruct tty_struct *tty = cs->hw.ser->tty;\r\nstruct cmdbuf_t *cb, *tcb;\r\nunsigned long flags;\r\nint sent = 0;\r\nif (!tty || !tty->driver)\r\nreturn -EFAULT;\r\ncb = cs->cmdbuf;\r\nif (!cb)\r\nreturn 0;\r\nif (cb->len) {\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nsent = tty->ops->write(tty, cb->buf + cb->offset, cb->len);\r\nif (sent < 0) {\r\ngig_dbg(DEBUG_OUTPUT, "send_cb: write error %d", sent);\r\nflush_send_queue(cs);\r\nreturn sent;\r\n}\r\ncb->offset += sent;\r\ncb->len -= sent;\r\ngig_dbg(DEBUG_OUTPUT, "send_cb: sent %d, left %u, queued %u",\r\nsent, cb->len, cs->cmdbytes);\r\n}\r\nwhile (cb && !cb->len) {\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\ncs->cmdbytes -= cs->curlen;\r\ntcb = cb;\r\ncs->cmdbuf = cb = cb->next;\r\nif (cb) {\r\ncb->prev = NULL;\r\ncs->curlen = cb->len;\r\n} else {\r\ncs->lastcmdbuf = NULL;\r\ncs->curlen = 0;\r\n}\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nif (tcb->wake_tasklet)\r\ntasklet_schedule(tcb->wake_tasklet);\r\nkfree(tcb);\r\n}\r\nreturn sent;\r\n}\r\nstatic void gigaset_modem_fill(unsigned long data)\r\n{\r\nstruct cardstate *cs = (struct cardstate *) data;\r\nstruct bc_state *bcs;\r\nstruct sk_buff *nextskb;\r\nint sent = 0;\r\nif (!cs) {\r\ngig_dbg(DEBUG_OUTPUT, "%s: no cardstate", __func__);\r\nreturn;\r\n}\r\nbcs = cs->bcs;\r\nif (!bcs) {\r\ngig_dbg(DEBUG_OUTPUT, "%s: no cardstate", __func__);\r\nreturn;\r\n}\r\nif (!bcs->tx_skb) {\r\nsent = send_cb(cs);\r\ngig_dbg(DEBUG_OUTPUT, "%s: send_cb -> %d", __func__, sent);\r\nif (sent)\r\nreturn;\r\nnextskb = skb_dequeue(&bcs->squeue);\r\nif (!nextskb)\r\nreturn;\r\nbcs->tx_skb = nextskb;\r\ngig_dbg(DEBUG_INTR, "Dequeued skb (Adr: %lx)",\r\n(unsigned long) bcs->tx_skb);\r\n}\r\ngig_dbg(DEBUG_OUTPUT, "%s: tx_skb", __func__);\r\nif (write_modem(cs) < 0)\r\ngig_dbg(DEBUG_OUTPUT, "%s: write_modem failed", __func__);\r\n}\r\nstatic void flush_send_queue(struct cardstate *cs)\r\n{\r\nstruct sk_buff *skb;\r\nstruct cmdbuf_t *cb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\nwhile ((cb = cs->cmdbuf) != NULL) {\r\ncs->cmdbuf = cb->next;\r\nif (cb->wake_tasklet)\r\ntasklet_schedule(cb->wake_tasklet);\r\nkfree(cb);\r\n}\r\ncs->cmdbuf = cs->lastcmdbuf = NULL;\r\ncs->cmdbytes = cs->curlen = 0;\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nif (cs->bcs->tx_skb)\r\ndev_kfree_skb_any(cs->bcs->tx_skb);\r\nwhile ((skb = skb_dequeue(&cs->bcs->squeue)) != NULL)\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic int gigaset_write_cmd(struct cardstate *cs, struct cmdbuf_t *cb)\r\n{\r\nunsigned long flags;\r\ngigaset_dbg_buffer(cs->mstate != MS_LOCKED ?\r\nDEBUG_TRANSCMD : DEBUG_LOCKCMD,\r\n"CMD Transmit", cb->len, cb->buf);\r\nspin_lock_irqsave(&cs->cmdlock, flags);\r\ncb->prev = cs->lastcmdbuf;\r\nif (cs->lastcmdbuf)\r\ncs->lastcmdbuf->next = cb;\r\nelse {\r\ncs->cmdbuf = cb;\r\ncs->curlen = cb->len;\r\n}\r\ncs->cmdbytes += cb->len;\r\ncs->lastcmdbuf = cb;\r\nspin_unlock_irqrestore(&cs->cmdlock, flags);\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->connected)\r\ntasklet_schedule(&cs->write_tasklet);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn cb->len;\r\n}\r\nstatic int gigaset_write_room(struct cardstate *cs)\r\n{\r\nunsigned bytes;\r\nbytes = cs->cmdbytes;\r\nreturn bytes < IF_WRITEBUF ? IF_WRITEBUF - bytes : 0;\r\n}\r\nstatic int gigaset_chars_in_buffer(struct cardstate *cs)\r\n{\r\nreturn cs->cmdbytes;\r\n}\r\nstatic int gigaset_brkchars(struct cardstate *cs, const unsigned char buf[6])\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int gigaset_init_bchannel(struct bc_state *bcs)\r\n{\r\ngigaset_bchannel_up(bcs);\r\nreturn 0;\r\n}\r\nstatic int gigaset_close_bchannel(struct bc_state *bcs)\r\n{\r\ngigaset_bchannel_down(bcs);\r\nreturn 0;\r\n}\r\nstatic int gigaset_initbcshw(struct bc_state *bcs)\r\n{\r\nbcs->hw.ser = NULL;\r\nreturn 0;\r\n}\r\nstatic void gigaset_freebcshw(struct bc_state *bcs)\r\n{\r\n}\r\nstatic void gigaset_reinitbcshw(struct bc_state *bcs)\r\n{\r\n}\r\nstatic void gigaset_freecshw(struct cardstate *cs)\r\n{\r\ntasklet_kill(&cs->write_tasklet);\r\nif (!cs->hw.ser)\r\nreturn;\r\ndev_set_drvdata(&cs->hw.ser->dev.dev, NULL);\r\nplatform_device_unregister(&cs->hw.ser->dev);\r\nkfree(cs->hw.ser);\r\ncs->hw.ser = NULL;\r\n}\r\nstatic void gigaset_device_release(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nkfree(dev->platform_data);\r\nkfree(pdev->resource);\r\n}\r\nstatic int gigaset_initcshw(struct cardstate *cs)\r\n{\r\nint rc;\r\nstruct ser_cardstate *scs;\r\nscs = kzalloc(sizeof(struct ser_cardstate), GFP_KERNEL);\r\nif (!scs) {\r\npr_err("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\ncs->hw.ser = scs;\r\ncs->hw.ser->dev.name = GIGASET_MODULENAME;\r\ncs->hw.ser->dev.id = cs->minor_index;\r\ncs->hw.ser->dev.dev.release = gigaset_device_release;\r\nrc = platform_device_register(&cs->hw.ser->dev);\r\nif (rc != 0) {\r\npr_err("error %d registering platform device\n", rc);\r\nkfree(cs->hw.ser);\r\ncs->hw.ser = NULL;\r\nreturn rc;\r\n}\r\ndev_set_drvdata(&cs->hw.ser->dev.dev, cs);\r\ntasklet_init(&cs->write_tasklet,\r\ngigaset_modem_fill, (unsigned long) cs);\r\nreturn 0;\r\n}\r\nstatic int gigaset_set_modem_ctrl(struct cardstate *cs, unsigned old_state,\r\nunsigned new_state)\r\n{\r\nstruct tty_struct *tty = cs->hw.ser->tty;\r\nunsigned int set, clear;\r\nif (!tty || !tty->driver || !tty->ops->tiocmset)\r\nreturn -EINVAL;\r\nset = new_state & ~old_state;\r\nclear = old_state & ~new_state;\r\nif (!set && !clear)\r\nreturn 0;\r\ngig_dbg(DEBUG_IF, "tiocmset set %x clear %x", set, clear);\r\nreturn tty->ops->tiocmset(tty, set, clear);\r\n}\r\nstatic int gigaset_baud_rate(struct cardstate *cs, unsigned cflag)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int gigaset_set_line_ctrl(struct cardstate *cs, unsigned cflag)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic struct cardstate *cs_get(struct tty_struct *tty)\r\n{\r\nstruct cardstate *cs = tty->disc_data;\r\nif (!cs || !cs->hw.ser) {\r\ngig_dbg(DEBUG_ANY, "%s: no cardstate", __func__);\r\nreturn NULL;\r\n}\r\natomic_inc(&cs->hw.ser->refcnt);\r\nreturn cs;\r\n}\r\nstatic void cs_put(struct cardstate *cs)\r\n{\r\nif (atomic_dec_and_test(&cs->hw.ser->refcnt))\r\ncomplete(&cs->hw.ser->dead_cmp);\r\n}\r\nstatic int\r\ngigaset_tty_open(struct tty_struct *tty)\r\n{\r\nstruct cardstate *cs;\r\nint rc;\r\ngig_dbg(DEBUG_INIT, "Starting HLL for Gigaset M101");\r\npr_info(DRIVER_DESC "\n");\r\nif (!driver) {\r\npr_err("%s: no driver structure\n", __func__);\r\nreturn -ENODEV;\r\n}\r\ncs = gigaset_initcs(driver, 1, 1, 0, cidmode, GIGASET_MODULENAME);\r\nif (!cs) {\r\nrc = -ENODEV;\r\ngoto error;\r\n}\r\ncs->dev = &cs->hw.ser->dev.dev;\r\ncs->hw.ser->tty = tty;\r\natomic_set(&cs->hw.ser->refcnt, 1);\r\ninit_completion(&cs->hw.ser->dead_cmp);\r\ntty->disc_data = cs;\r\ntty->receive_room = RBUFSIZE/2;\r\nif (startmode == SM_LOCKED)\r\ncs->mstate = MS_LOCKED;\r\nrc = gigaset_start(cs);\r\nif (rc < 0) {\r\ntasklet_kill(&cs->write_tasklet);\r\ngoto error;\r\n}\r\ngig_dbg(DEBUG_INIT, "Startup of HLL done");\r\nreturn 0;\r\nerror:\r\ngig_dbg(DEBUG_INIT, "Startup of HLL failed");\r\ntty->disc_data = NULL;\r\ngigaset_freecs(cs);\r\nreturn rc;\r\n}\r\nstatic void\r\ngigaset_tty_close(struct tty_struct *tty)\r\n{\r\nstruct cardstate *cs = tty->disc_data;\r\ngig_dbg(DEBUG_INIT, "Stopping HLL for Gigaset M101");\r\nif (!cs) {\r\ngig_dbg(DEBUG_INIT, "%s: no cardstate", __func__);\r\nreturn;\r\n}\r\ntty->disc_data = NULL;\r\nif (!cs->hw.ser)\r\npr_err("%s: no hw cardstate\n", __func__);\r\nelse {\r\nif (!atomic_dec_and_test(&cs->hw.ser->refcnt))\r\nwait_for_completion(&cs->hw.ser->dead_cmp);\r\n}\r\ngigaset_stop(cs);\r\ntasklet_kill(&cs->write_tasklet);\r\nflush_send_queue(cs);\r\ncs->dev = NULL;\r\ngigaset_freecs(cs);\r\ngig_dbg(DEBUG_INIT, "Shutdown of HLL done");\r\n}\r\nstatic int gigaset_tty_hangup(struct tty_struct *tty)\r\n{\r\ngigaset_tty_close(tty);\r\nreturn 0;\r\n}\r\nstatic int\r\ngigaset_tty_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cardstate *cs = cs_get(tty);\r\nint rc, val;\r\nint __user *p = (int __user *)arg;\r\nif (!cs)\r\nreturn -ENXIO;\r\nswitch (cmd) {\r\ncase FIONREAD:\r\nval = 0;\r\nrc = put_user(val, p);\r\nbreak;\r\ncase TCFLSH:\r\nswitch (arg) {\r\ncase TCIFLUSH:\r\nbreak;\r\ncase TCIOFLUSH:\r\ncase TCOFLUSH:\r\nflush_send_queue(cs);\r\nbreak;\r\n}\r\ndefault:\r\nrc = n_tty_ioctl_helper(tty, file, cmd, arg);\r\nbreak;\r\n}\r\ncs_put(cs);\r\nreturn rc;\r\n}\r\nstatic void\r\ngigaset_tty_receive(struct tty_struct *tty, const unsigned char *buf,\r\nchar *cflags, int count)\r\n{\r\nstruct cardstate *cs = cs_get(tty);\r\nunsigned tail, head, n;\r\nstruct inbuf_t *inbuf;\r\nif (!cs)\r\nreturn;\r\ninbuf = cs->inbuf;\r\nif (!inbuf) {\r\ndev_err(cs->dev, "%s: no inbuf\n", __func__);\r\ncs_put(cs);\r\nreturn;\r\n}\r\ntail = inbuf->tail;\r\nhead = inbuf->head;\r\ngig_dbg(DEBUG_INTR, "buffer state: %u -> %u, receive %u bytes",\r\nhead, tail, count);\r\nif (head <= tail) {\r\nn = min_t(unsigned, count, RBUFSIZE - tail);\r\nmemcpy(inbuf->data + tail, buf, n);\r\ntail = (tail + n) % RBUFSIZE;\r\nbuf += n;\r\ncount -= n;\r\n}\r\nif (count > 0) {\r\nn = head - tail - 1;\r\nif (count > n) {\r\ndev_err(cs->dev,\r\n"inbuf overflow, discarding %d bytes\n",\r\ncount - n);\r\ncount = n;\r\n}\r\nmemcpy(inbuf->data + tail, buf, count);\r\ntail += count;\r\n}\r\ngig_dbg(DEBUG_INTR, "setting tail to %u", tail);\r\ninbuf->tail = tail;\r\ngig_dbg(DEBUG_INTR, "%s-->BH", __func__);\r\ngigaset_schedule_event(cs);\r\ncs_put(cs);\r\n}\r\nstatic void\r\ngigaset_tty_wakeup(struct tty_struct *tty)\r\n{\r\nstruct cardstate *cs = cs_get(tty);\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nif (!cs)\r\nreturn;\r\ntasklet_schedule(&cs->write_tasklet);\r\ncs_put(cs);\r\n}\r\nstatic int __init ser_gigaset_init(void)\r\n{\r\nint rc;\r\ngig_dbg(DEBUG_INIT, "%s", __func__);\r\nrc = platform_driver_register(&device_driver);\r\nif (rc != 0) {\r\npr_err("error %d registering platform driver\n", rc);\r\nreturn rc;\r\n}\r\ndriver = gigaset_initdriver(GIGASET_MINOR, GIGASET_MINORS,\r\nGIGASET_MODULENAME, GIGASET_DEVNAME,\r\n&ops, THIS_MODULE);\r\nif (!driver)\r\ngoto error;\r\nrc = tty_register_ldisc(N_GIGASET_M101, &gigaset_ldisc);\r\nif (rc != 0) {\r\npr_err("error %d registering line discipline\n", rc);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nif (driver) {\r\ngigaset_freedriver(driver);\r\ndriver = NULL;\r\n}\r\nplatform_driver_unregister(&device_driver);\r\nreturn rc;\r\n}\r\nstatic void __exit ser_gigaset_exit(void)\r\n{\r\nint rc;\r\ngig_dbg(DEBUG_INIT, "%s", __func__);\r\nif (driver) {\r\ngigaset_freedriver(driver);\r\ndriver = NULL;\r\n}\r\nrc = tty_unregister_ldisc(N_GIGASET_M101);\r\nif (rc != 0)\r\npr_err("error %d unregistering line discipline\n", rc);\r\nplatform_driver_unregister(&device_driver);\r\n}
