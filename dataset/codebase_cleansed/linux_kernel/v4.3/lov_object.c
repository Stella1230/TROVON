static void lov_install_empty(const struct lu_env *env,\r\nstruct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\n}\r\nstatic int lov_init_empty(const struct lu_env *env,\r\nstruct lov_device *dev, struct lov_object *lov,\r\nconst struct cl_object_conf *conf,\r\nunion lov_layout_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lov_install_raid0(const struct lu_env *env,\r\nstruct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\n}\r\nstatic struct cl_object *lov_sub_find(const struct lu_env *env,\r\nstruct cl_device *dev,\r\nconst struct lu_fid *fid,\r\nconst struct cl_object_conf *conf)\r\n{\r\nstruct lu_object *o;\r\no = lu_object_find_at(env, cl2lu_dev(dev), fid, &conf->coc_lu);\r\nLASSERT(ergo(!IS_ERR(o), o->lo_dev->ld_type == &lovsub_device_type));\r\nreturn lu2cl(o);\r\n}\r\nstatic int lov_init_sub(const struct lu_env *env, struct lov_object *lov,\r\nstruct cl_object *stripe, struct lov_layout_raid0 *r0,\r\nint idx)\r\n{\r\nstruct cl_object_header *hdr;\r\nstruct cl_object_header *subhdr;\r\nstruct cl_object_header *parent;\r\nstruct lov_oinfo *oinfo;\r\nint result;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_LOV_INIT)) {\r\ncl_object_kill(env, stripe);\r\ncl_object_put(env, stripe);\r\nreturn -EIO;\r\n}\r\nhdr = cl_object_header(lov2cl(lov));\r\nsubhdr = cl_object_header(stripe);\r\noinfo = lov->lo_lsm->lsm_oinfo[idx];\r\nCDEBUG(D_INODE, DFID"@%p[%d] -> "DFID"@%p: ostid: "DOSTID\r\n" idx: %d gen: %d\n",\r\nPFID(&subhdr->coh_lu.loh_fid), subhdr, idx,\r\nPFID(&hdr->coh_lu.loh_fid), hdr, POSTID(&oinfo->loi_oi),\r\noinfo->loi_ost_idx, oinfo->loi_ost_gen);\r\nspin_lock(&subhdr->coh_attr_guard);\r\nparent = subhdr->coh_parent;\r\nif (parent == NULL) {\r\nsubhdr->coh_parent = hdr;\r\nspin_unlock(&subhdr->coh_attr_guard);\r\nsubhdr->coh_nesting = hdr->coh_nesting + 1;\r\nlu_object_ref_add(&stripe->co_lu, "lov-parent", lov);\r\nr0->lo_sub[idx] = cl2lovsub(stripe);\r\nr0->lo_sub[idx]->lso_super = lov;\r\nr0->lo_sub[idx]->lso_index = idx;\r\nresult = 0;\r\n} else {\r\nstruct lu_object *old_obj;\r\nstruct lov_object *old_lov;\r\nunsigned int mask = D_INODE;\r\nspin_unlock(&subhdr->coh_attr_guard);\r\nold_obj = lu_object_locate(&parent->coh_lu, &lov_device_type);\r\nLASSERT(old_obj != NULL);\r\nold_lov = cl2lov(lu2cl(old_obj));\r\nif (old_lov->lo_layout_invalid) {\r\nlu_object_unhash(env, &stripe->co_lu);\r\nresult = -EAGAIN;\r\n} else {\r\nmask = D_ERROR;\r\nresult = -EIO;\r\n}\r\nLU_OBJECT_DEBUG(mask, env, &stripe->co_lu,\r\n"stripe %d is already owned.\n", idx);\r\nLU_OBJECT_DEBUG(mask, env, old_obj, "owned.\n");\r\nLU_OBJECT_HEADER(mask, env, lov2lu(lov), "try to own.\n");\r\ncl_object_put(env, stripe);\r\n}\r\nreturn result;\r\n}\r\nstatic int lov_init_raid0(const struct lu_env *env,\r\nstruct lov_device *dev, struct lov_object *lov,\r\nconst struct cl_object_conf *conf,\r\nunion lov_layout_state *state)\r\n{\r\nint result;\r\nint i;\r\nstruct cl_object *stripe;\r\nstruct lov_thread_info *lti = lov_env_info(env);\r\nstruct cl_object_conf *subconf = &lti->lti_stripe_conf;\r\nstruct lov_stripe_md *lsm = conf->u.coc_md->lsm;\r\nstruct lu_fid *ofid = &lti->lti_fid;\r\nstruct lov_layout_raid0 *r0 = &state->raid0;\r\nif (lsm->lsm_magic != LOV_MAGIC_V1 && lsm->lsm_magic != LOV_MAGIC_V3) {\r\ndump_lsm(D_ERROR, lsm);\r\nLASSERTF(0, "magic mismatch, expected %d/%d, actual %d.\n",\r\nLOV_MAGIC_V1, LOV_MAGIC_V3, lsm->lsm_magic);\r\n}\r\nLASSERT(lov->lo_lsm == NULL);\r\nlov->lo_lsm = lsm_addref(lsm);\r\nr0->lo_nr = lsm->lsm_stripe_count;\r\nLASSERT(r0->lo_nr <= lov_targets_nr(dev));\r\nr0->lo_sub = libcfs_kvzalloc(r0->lo_nr * sizeof(r0->lo_sub[0]),\r\nGFP_NOFS);\r\nif (r0->lo_sub != NULL) {\r\nresult = 0;\r\nsubconf->coc_inode = conf->coc_inode;\r\nspin_lock_init(&r0->lo_sub_lock);\r\nfor (i = 0; i < r0->lo_nr && result == 0; ++i) {\r\nstruct cl_device *subdev;\r\nstruct lov_oinfo *oinfo = lsm->lsm_oinfo[i];\r\nint ost_idx = oinfo->loi_ost_idx;\r\nif (lov_oinfo_is_dummy(oinfo))\r\ncontinue;\r\nresult = ostid_to_fid(ofid, &oinfo->loi_oi,\r\noinfo->loi_ost_idx);\r\nif (result != 0)\r\ngoto out;\r\nsubdev = lovsub2cl_dev(dev->ld_target[ost_idx]);\r\nsubconf->u.coc_oinfo = oinfo;\r\nLASSERTF(subdev != NULL, "not init ost %d\n", ost_idx);\r\nstripe = lov_sub_find(env, subdev, ofid, subconf);\r\nif (!IS_ERR(stripe)) {\r\nresult = lov_init_sub(env, lov, stripe, r0, i);\r\nif (result == -EAGAIN) {\r\n--i;\r\nresult = 0;\r\n}\r\n} else {\r\nresult = PTR_ERR(stripe);\r\n}\r\n}\r\n} else\r\nresult = -ENOMEM;\r\nout:\r\nreturn result;\r\n}\r\nstatic int lov_init_released(const struct lu_env *env,\r\nstruct lov_device *dev, struct lov_object *lov,\r\nconst struct cl_object_conf *conf,\r\nunion lov_layout_state *state)\r\n{\r\nstruct lov_stripe_md *lsm = conf->u.coc_md->lsm;\r\nLASSERT(lsm != NULL);\r\nLASSERT(lsm_is_released(lsm));\r\nLASSERT(lov->lo_lsm == NULL);\r\nlov->lo_lsm = lsm_addref(lsm);\r\nreturn 0;\r\n}\r\nstatic int lov_delete_empty(const struct lu_env *env, struct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\nLASSERT(lov->lo_type == LLT_EMPTY || lov->lo_type == LLT_RELEASED);\r\nlov_layout_wait(env, lov);\r\ncl_object_prune(env, &lov->lo_cl);\r\nreturn 0;\r\n}\r\nstatic void lov_subobject_kill(const struct lu_env *env, struct lov_object *lov,\r\nstruct lovsub_object *los, int idx)\r\n{\r\nstruct cl_object *sub;\r\nstruct lov_layout_raid0 *r0;\r\nstruct lu_site *site;\r\nstruct lu_site_bkt_data *bkt;\r\nwait_queue_t *waiter;\r\nr0 = &lov->u.raid0;\r\nLASSERT(r0->lo_sub[idx] == los);\r\nsub = lovsub2cl(los);\r\nsite = sub->co_lu.lo_dev->ld_site;\r\nbkt = lu_site_bkt_from_fid(site, &sub->co_lu.lo_header->loh_fid);\r\ncl_object_kill(env, sub);\r\nlu_object_ref_del(&sub->co_lu, "lov-parent", lov);\r\ncl_object_put(env, sub);\r\nif (r0->lo_sub[idx] == los) {\r\nwaiter = &lov_env_info(env)->lti_waiter;\r\ninit_waitqueue_entry(waiter, current);\r\nadd_wait_queue(&bkt->lsb_marche_funebre, waiter);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nwhile (1) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_lock(&r0->lo_sub_lock);\r\nif (r0->lo_sub[idx] == los) {\r\nspin_unlock(&r0->lo_sub_lock);\r\nschedule();\r\n} else {\r\nspin_unlock(&r0->lo_sub_lock);\r\nset_current_state(TASK_RUNNING);\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&bkt->lsb_marche_funebre, waiter);\r\n}\r\nLASSERT(r0->lo_sub[idx] == NULL);\r\n}\r\nstatic int lov_delete_raid0(const struct lu_env *env, struct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\nstruct lov_layout_raid0 *r0 = &state->raid0;\r\nstruct lov_stripe_md *lsm = lov->lo_lsm;\r\nint i;\r\ndump_lsm(D_INODE, lsm);\r\nlov_layout_wait(env, lov);\r\nif (r0->lo_sub != NULL) {\r\nfor (i = 0; i < r0->lo_nr; ++i) {\r\nstruct lovsub_object *los = r0->lo_sub[i];\r\nif (los != NULL) {\r\ncl_locks_prune(env, &los->lso_cl, 1);\r\nlov_subobject_kill(env, lov, los, i);\r\n}\r\n}\r\n}\r\ncl_object_prune(env, &lov->lo_cl);\r\nreturn 0;\r\n}\r\nstatic void lov_fini_empty(const struct lu_env *env, struct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\nLASSERT(lov->lo_type == LLT_EMPTY || lov->lo_type == LLT_RELEASED);\r\n}\r\nstatic void lov_fini_raid0(const struct lu_env *env, struct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\nstruct lov_layout_raid0 *r0 = &state->raid0;\r\nif (r0->lo_sub != NULL) {\r\nkvfree(r0->lo_sub);\r\nr0->lo_sub = NULL;\r\n}\r\ndump_lsm(D_INODE, lov->lo_lsm);\r\nlov_free_memmd(&lov->lo_lsm);\r\n}\r\nstatic void lov_fini_released(const struct lu_env *env, struct lov_object *lov,\r\nunion lov_layout_state *state)\r\n{\r\ndump_lsm(D_INODE, lov->lo_lsm);\r\nlov_free_memmd(&lov->lo_lsm);\r\n}\r\nstatic int lov_print_empty(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\n(*p)(env, cookie, "empty %d\n", lu2lov(o)->lo_layout_invalid);\r\nreturn 0;\r\n}\r\nstatic int lov_print_raid0(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\nstruct lov_object *lov = lu2lov(o);\r\nstruct lov_layout_raid0 *r0 = lov_r0(lov);\r\nstruct lov_stripe_md *lsm = lov->lo_lsm;\r\nint i;\r\n(*p)(env, cookie, "stripes: %d, %s, lsm{%p 0x%08X %d %u %u}:\n",\r\nr0->lo_nr, lov->lo_layout_invalid ? "invalid" : "valid", lsm,\r\nlsm->lsm_magic, atomic_read(&lsm->lsm_refc),\r\nlsm->lsm_stripe_count, lsm->lsm_layout_gen);\r\nfor (i = 0; i < r0->lo_nr; ++i) {\r\nstruct lu_object *sub;\r\nif (r0->lo_sub[i] != NULL) {\r\nsub = lovsub2lu(r0->lo_sub[i]);\r\nlu_object_print(env, cookie, p, sub);\r\n} else {\r\n(*p)(env, cookie, "sub %d absent\n", i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lov_print_released(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\nstruct lov_object *lov = lu2lov(o);\r\nstruct lov_stripe_md *lsm = lov->lo_lsm;\r\n(*p)(env, cookie,\r\n"released: %s, lsm{%p 0x%08X %d %u %u}:\n",\r\nlov->lo_layout_invalid ? "invalid" : "valid", lsm,\r\nlsm->lsm_magic, atomic_read(&lsm->lsm_refc),\r\nlsm->lsm_stripe_count, lsm->lsm_layout_gen);\r\nreturn 0;\r\n}\r\nstatic int lov_attr_get_empty(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nattr->cat_blocks = 0;\r\nreturn 0;\r\n}\r\nstatic int lov_attr_get_raid0(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nstruct lov_object *lov = cl2lov(obj);\r\nstruct lov_layout_raid0 *r0 = lov_r0(lov);\r\nstruct cl_attr *lov_attr = &r0->lo_attr;\r\nint result = 0;\r\nif (!r0->lo_attr_valid) {\r\nstruct lov_stripe_md *lsm = lov->lo_lsm;\r\nstruct ost_lvb *lvb = &lov_env_info(env)->lti_lvb;\r\n__u64 kms = 0;\r\nmemset(lvb, 0, sizeof(*lvb));\r\nlvb->lvb_atime = LLONG_MIN;\r\nlvb->lvb_ctime = LLONG_MIN;\r\nlvb->lvb_mtime = LLONG_MIN;\r\nlov_stripe_lock(lsm);\r\nresult = lov_merge_lvb_kms(lsm, lvb, &kms);\r\nlov_stripe_unlock(lsm);\r\nif (result == 0) {\r\ncl_lvb2attr(lov_attr, lvb);\r\nlov_attr->cat_kms = kms;\r\nr0->lo_attr_valid = 1;\r\n}\r\n}\r\nif (result == 0) {\r\nattr->cat_blocks = lov_attr->cat_blocks;\r\nattr->cat_size = lov_attr->cat_size;\r\nattr->cat_kms = lov_attr->cat_kms;\r\nif (attr->cat_atime < lov_attr->cat_atime)\r\nattr->cat_atime = lov_attr->cat_atime;\r\nif (attr->cat_ctime < lov_attr->cat_ctime)\r\nattr->cat_ctime = lov_attr->cat_ctime;\r\nif (attr->cat_mtime < lov_attr->cat_mtime)\r\nattr->cat_mtime = lov_attr->cat_mtime;\r\n}\r\nreturn result;\r\n}\r\nstatic enum lov_layout_type lov_type(struct lov_stripe_md *lsm)\r\n{\r\nif (lsm == NULL)\r\nreturn LLT_EMPTY;\r\nif (lsm_is_released(lsm))\r\nreturn LLT_RELEASED;\r\nreturn LLT_RAID0;\r\n}\r\nstatic inline void lov_conf_freeze(struct lov_object *lov)\r\n{\r\nif (lov->lo_owner != current)\r\ndown_read(&lov->lo_type_guard);\r\n}\r\nstatic inline void lov_conf_thaw(struct lov_object *lov)\r\n{\r\nif (lov->lo_owner != current)\r\nup_read(&lov->lo_type_guard);\r\n}\r\nstatic void lov_conf_lock(struct lov_object *lov)\r\n{\r\nLASSERT(lov->lo_owner != current);\r\ndown_write(&lov->lo_type_guard);\r\nLASSERT(lov->lo_owner == NULL);\r\nlov->lo_owner = current;\r\n}\r\nstatic void lov_conf_unlock(struct lov_object *lov)\r\n{\r\nlov->lo_owner = NULL;\r\nup_write(&lov->lo_type_guard);\r\n}\r\nstatic int lov_layout_wait(const struct lu_env *env, struct lov_object *lov)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nwhile (atomic_read(&lov->lo_active_ios) > 0) {\r\nCDEBUG(D_INODE, "file:"DFID" wait for active IO, now: %d.\n",\r\nPFID(lu_object_fid(lov2lu(lov))),\r\natomic_read(&lov->lo_active_ios));\r\nl_wait_event(lov->lo_waitq,\r\natomic_read(&lov->lo_active_ios) == 0, &lwi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lov_layout_change(const struct lu_env *unused,\r\nstruct lov_object *lov,\r\nconst struct cl_object_conf *conf)\r\n{\r\nint result;\r\nenum lov_layout_type llt = LLT_EMPTY;\r\nunion lov_layout_state *state = &lov->u;\r\nconst struct lov_layout_operations *old_ops;\r\nconst struct lov_layout_operations *new_ops;\r\nstruct cl_object_header *hdr = cl_object_header(&lov->lo_cl);\r\nvoid *cookie;\r\nstruct lu_env *env;\r\nint refcheck;\r\nLASSERT(0 <= lov->lo_type && lov->lo_type < ARRAY_SIZE(lov_dispatch));\r\nif (conf->u.coc_md != NULL)\r\nllt = lov_type(conf->u.coc_md->lsm);\r\nLASSERT(0 <= llt && llt < ARRAY_SIZE(lov_dispatch));\r\ncookie = cl_env_reenter();\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env)) {\r\ncl_env_reexit(cookie);\r\nreturn PTR_ERR(env);\r\n}\r\nCDEBUG(D_INODE, DFID" from %s to %s\n",\r\nPFID(lu_object_fid(lov2lu(lov))),\r\nllt2str(lov->lo_type), llt2str(llt));\r\nold_ops = &lov_dispatch[lov->lo_type];\r\nnew_ops = &lov_dispatch[llt];\r\nresult = old_ops->llo_delete(env, lov, &lov->u);\r\nif (result == 0) {\r\nold_ops->llo_fini(env, lov, &lov->u);\r\nLASSERT(atomic_read(&lov->lo_active_ios) == 0);\r\nLASSERT(hdr->coh_tree.rnode == NULL);\r\nLASSERT(hdr->coh_pages == 0);\r\nlov->lo_type = LLT_EMPTY;\r\nresult = new_ops->llo_init(env,\r\nlu2lov_dev(lov->lo_cl.co_lu.lo_dev),\r\nlov, conf, state);\r\nif (result == 0) {\r\nnew_ops->llo_install(env, lov, state);\r\nlov->lo_type = llt;\r\n} else {\r\nnew_ops->llo_delete(env, lov, state);\r\nnew_ops->llo_fini(env, lov, state);\r\n}\r\n}\r\ncl_env_put(env, &refcheck);\r\ncl_env_reexit(cookie);\r\nreturn result;\r\n}\r\nint lov_object_init(const struct lu_env *env, struct lu_object *obj,\r\nconst struct lu_object_conf *conf)\r\n{\r\nstruct lov_device *dev = lu2lov_dev(obj->lo_dev);\r\nstruct lov_object *lov = lu2lov(obj);\r\nconst struct cl_object_conf *cconf = lu2cl_conf(conf);\r\nunion lov_layout_state *set = &lov->u;\r\nconst struct lov_layout_operations *ops;\r\nint result;\r\ninit_rwsem(&lov->lo_type_guard);\r\natomic_set(&lov->lo_active_ios, 0);\r\ninit_waitqueue_head(&lov->lo_waitq);\r\ncl_object_page_init(lu2cl(obj), sizeof(struct lov_page));\r\nlov->lo_type = lov_type(cconf->u.coc_md->lsm);\r\nops = &lov_dispatch[lov->lo_type];\r\nresult = ops->llo_init(env, dev, lov, cconf, set);\r\nif (result == 0)\r\nops->llo_install(env, lov, set);\r\nreturn result;\r\n}\r\nstatic int lov_conf_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_object_conf *conf)\r\n{\r\nstruct lov_stripe_md *lsm = NULL;\r\nstruct lov_object *lov = cl2lov(obj);\r\nint result = 0;\r\nlov_conf_lock(lov);\r\nif (conf->coc_opc == OBJECT_CONF_INVALIDATE) {\r\nlov->lo_layout_invalid = true;\r\nresult = 0;\r\ngoto out;\r\n}\r\nif (conf->coc_opc == OBJECT_CONF_WAIT) {\r\nif (lov->lo_layout_invalid &&\r\natomic_read(&lov->lo_active_ios) > 0) {\r\nlov_conf_unlock(lov);\r\nresult = lov_layout_wait(env, lov);\r\nlov_conf_lock(lov);\r\n}\r\ngoto out;\r\n}\r\nLASSERT(conf->coc_opc == OBJECT_CONF_SET);\r\nif (conf->u.coc_md != NULL)\r\nlsm = conf->u.coc_md->lsm;\r\nif ((lsm == NULL && lov->lo_lsm == NULL) ||\r\n((lsm != NULL && lov->lo_lsm != NULL) &&\r\n(lov->lo_lsm->lsm_layout_gen == lsm->lsm_layout_gen) &&\r\n(lov->lo_lsm->lsm_pattern == lsm->lsm_pattern))) {\r\nlov->lo_layout_invalid = false;\r\nresult = 0;\r\ngoto out;\r\n}\r\nif (atomic_read(&lov->lo_active_ios) > 0) {\r\nlov->lo_layout_invalid = true;\r\nresult = -EBUSY;\r\ngoto out;\r\n}\r\nlov->lo_layout_invalid = lov_layout_change(env, lov, conf);\r\nout:\r\nlov_conf_unlock(lov);\r\nCDEBUG(D_INODE, DFID" lo_layout_invalid=%d\n",\r\nPFID(lu_object_fid(lov2lu(lov))), lov->lo_layout_invalid);\r\nreturn result;\r\n}\r\nstatic void lov_object_delete(const struct lu_env *env, struct lu_object *obj)\r\n{\r\nstruct lov_object *lov = lu2lov(obj);\r\nLOV_2DISPATCH_VOID(lov, llo_delete, env, lov, &lov->u);\r\n}\r\nstatic void lov_object_free(const struct lu_env *env, struct lu_object *obj)\r\n{\r\nstruct lov_object *lov = lu2lov(obj);\r\nLOV_2DISPATCH_VOID(lov, llo_fini, env, lov, &lov->u);\r\nlu_object_fini(obj);\r\nOBD_SLAB_FREE_PTR(lov, lov_object_kmem);\r\n}\r\nstatic int lov_object_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\nreturn LOV_2DISPATCH_NOLOCK(lu2lov(o), llo_print, env, cookie, p, o);\r\n}\r\nint lov_page_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_page *page, struct page *vmpage)\r\n{\r\nreturn LOV_2DISPATCH_NOLOCK(cl2lov(obj),\r\nllo_page_init, env, obj, page, vmpage);\r\n}\r\nint lov_io_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_io *io)\r\n{\r\nCL_IO_SLICE_CLEAN(lov_env_io(env), lis_cl);\r\nreturn LOV_2DISPATCH_MAYLOCK(cl2lov(obj), llo_io_init,\r\n!io->ci_ignore_layout, env, obj, io);\r\n}\r\nstatic int lov_attr_get(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nreturn LOV_2DISPATCH_NOLOCK(cl2lov(obj), llo_getattr, env, obj, attr);\r\n}\r\nstatic int lov_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_attr *attr, unsigned valid)\r\n{\r\nreturn 0;\r\n}\r\nint lov_lock_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_lock *lock, const struct cl_io *io)\r\n{\r\nreturn LOV_2DISPATCH_NOLOCK(cl2lov(obj), llo_lock_init, env, obj, lock,\r\nio);\r\n}\r\nstruct lu_object *lov_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *unused,\r\nstruct lu_device *dev)\r\n{\r\nstruct lov_object *lov;\r\nstruct lu_object *obj;\r\nOBD_SLAB_ALLOC_PTR_GFP(lov, lov_object_kmem, GFP_NOFS);\r\nif (lov != NULL) {\r\nobj = lov2lu(lov);\r\nlu_object_init(obj, NULL, dev);\r\nlov->lo_cl.co_ops = &lov_ops;\r\nlov->lo_type = -1;\r\nobj->lo_ops = &lov_lu_obj_ops;\r\n} else\r\nobj = NULL;\r\nreturn obj;\r\n}\r\nstruct lov_stripe_md *lov_lsm_addref(struct lov_object *lov)\r\n{\r\nstruct lov_stripe_md *lsm = NULL;\r\nlov_conf_freeze(lov);\r\nif (lov->lo_lsm != NULL) {\r\nlsm = lsm_addref(lov->lo_lsm);\r\nCDEBUG(D_INODE, "lsm %p addref %d/%d by %p.\n",\r\nlsm, atomic_read(&lsm->lsm_refc),\r\nlov->lo_layout_invalid, current);\r\n}\r\nlov_conf_thaw(lov);\r\nreturn lsm;\r\n}\r\nvoid lov_lsm_decref(struct lov_object *lov, struct lov_stripe_md *lsm)\r\n{\r\nif (lsm == NULL)\r\nreturn;\r\nCDEBUG(D_INODE, "lsm %p decref %d by %p.\n",\r\nlsm, atomic_read(&lsm->lsm_refc), current);\r\nlov_free_memmd(&lsm);\r\n}\r\nstruct lov_stripe_md *lov_lsm_get(struct cl_object *clobj)\r\n{\r\nstruct lu_object *luobj;\r\nstruct lov_stripe_md *lsm = NULL;\r\nif (clobj == NULL)\r\nreturn NULL;\r\nluobj = lu_object_locate(&cl_object_header(clobj)->coh_lu,\r\n&lov_device_type);\r\nif (luobj != NULL)\r\nlsm = lov_lsm_addref(lu2lov(luobj));\r\nreturn lsm;\r\n}\r\nvoid lov_lsm_put(struct cl_object *unused, struct lov_stripe_md *lsm)\r\n{\r\nif (lsm != NULL)\r\nlov_free_memmd(&lsm);\r\n}\r\nint lov_read_and_clear_async_rc(struct cl_object *clob)\r\n{\r\nstruct lu_object *luobj;\r\nint rc = 0;\r\nluobj = lu_object_locate(&cl_object_header(clob)->coh_lu,\r\n&lov_device_type);\r\nif (luobj != NULL) {\r\nstruct lov_object *lov = lu2lov(luobj);\r\nlov_conf_freeze(lov);\r\nswitch (lov->lo_type) {\r\ncase LLT_RAID0: {\r\nstruct lov_stripe_md *lsm;\r\nint i;\r\nlsm = lov->lo_lsm;\r\nLASSERT(lsm != NULL);\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nstruct lov_oinfo *loi = lsm->lsm_oinfo[i];\r\nif (lov_oinfo_is_dummy(loi))\r\ncontinue;\r\nif (loi->loi_ar.ar_rc && !rc)\r\nrc = loi->loi_ar.ar_rc;\r\nloi->loi_ar.ar_rc = 0;\r\n}\r\n}\r\ncase LLT_RELEASED:\r\ncase LLT_EMPTY:\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nlov_conf_thaw(lov);\r\n}\r\nreturn rc;\r\n}
