static irqreturn_t clk_utmi_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_utmi *utmi = (struct clk_utmi *)dev_id;\r\nwake_up(&utmi->wait);\r\ndisable_irq_nosync(utmi->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_utmi_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_utmi *utmi = to_clk_utmi(hw);\r\nstruct at91_pmc *pmc = utmi->pmc;\r\nu32 tmp = at91_pmc_read(AT91_CKGR_UCKR) | AT91_PMC_UPLLEN |\r\nAT91_PMC_UPLLCOUNT | AT91_PMC_BIASEN;\r\npmc_write(pmc, AT91_CKGR_UCKR, tmp);\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_LOCKU)) {\r\nenable_irq(utmi->irq);\r\nwait_event(utmi->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_LOCKU);\r\n}\r\nreturn 0;\r\n}\r\nstatic int clk_utmi_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_utmi *utmi = to_clk_utmi(hw);\r\nstruct at91_pmc *pmc = utmi->pmc;\r\nreturn !!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_LOCKU);\r\n}\r\nstatic void clk_utmi_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_utmi *utmi = to_clk_utmi(hw);\r\nstruct at91_pmc *pmc = utmi->pmc;\r\nu32 tmp = at91_pmc_read(AT91_CKGR_UCKR) & ~AT91_PMC_UPLLEN;\r\npmc_write(pmc, AT91_CKGR_UCKR, tmp);\r\n}\r\nstatic unsigned long clk_utmi_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nreturn parent_rate * UTMI_FIXED_MUL;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_utmi(struct at91_pmc *pmc, unsigned int irq,\r\nconst char *name, const char *parent_name)\r\n{\r\nint ret;\r\nstruct clk_utmi *utmi;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nutmi = kzalloc(sizeof(*utmi), GFP_KERNEL);\r\nif (!utmi)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &utmi_ops;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\ninit.flags = CLK_SET_RATE_GATE;\r\nutmi->hw.init = &init;\r\nutmi->pmc = pmc;\r\nutmi->irq = irq;\r\ninit_waitqueue_head(&utmi->wait);\r\nirq_set_status_flags(utmi->irq, IRQ_NOAUTOEN);\r\nret = request_irq(utmi->irq, clk_utmi_irq_handler,\r\nIRQF_TRIGGER_HIGH, "clk-utmi", utmi);\r\nif (ret) {\r\nkfree(utmi);\r\nreturn ERR_PTR(ret);\r\n}\r\nclk = clk_register(NULL, &utmi->hw);\r\nif (IS_ERR(clk)) {\r\nfree_irq(utmi->irq, utmi);\r\nkfree(utmi);\r\n}\r\nreturn clk;\r\n}\r\nstatic void __init\r\nof_at91_clk_utmi_setup(struct device_node *np, struct at91_pmc *pmc)\r\n{\r\nunsigned int irq;\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\nreturn;\r\nclk = at91_clk_register_utmi(pmc, irq, name, parent_name);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nreturn;\r\n}\r\nvoid __init of_at91sam9x5_clk_utmi_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_utmi_setup(np, pmc);\r\n}
