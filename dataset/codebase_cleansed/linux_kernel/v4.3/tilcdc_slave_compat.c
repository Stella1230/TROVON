static int __init kfree_table_init(struct kfree_table *kft)\r\n{\r\nkft->total = 32;\r\nkft->num = 0;\r\nkft->table = kmalloc(kft->total * sizeof(*kft->table),\r\nGFP_KERNEL);\r\nif (!kft->table)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __init kfree_table_add(struct kfree_table *kft, void *p)\r\n{\r\nif (kft->num == kft->total) {\r\nvoid **old = kft->table;\r\nkft->total *= 2;\r\nkft->table = krealloc(old, kft->total * sizeof(*kft->table),\r\nGFP_KERNEL);\r\nif (!kft->table) {\r\nkft->table = old;\r\nkfree(p);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nkft->table[kft->num++] = p;\r\nreturn 0;\r\n}\r\nstatic void __init kfree_table_free(struct kfree_table *kft)\r\n{\r\nint i;\r\nfor (i = 0; i < kft->num; i++)\r\nkfree(kft->table[i]);\r\nkfree(kft->table);\r\n}\r\nstatic\r\nstruct property * __init tilcdc_prop_dup(const struct property *prop,\r\nstruct kfree_table *kft)\r\n{\r\nstruct property *nprop;\r\nnprop = kzalloc(sizeof(*nprop), GFP_KERNEL);\r\nif (!nprop || kfree_table_add(kft, nprop))\r\nreturn NULL;\r\nnprop->name = kstrdup(prop->name, GFP_KERNEL);\r\nif (!nprop->name || kfree_table_add(kft, nprop->name))\r\nreturn NULL;\r\nnprop->value = kmemdup(prop->value, prop->length, GFP_KERNEL);\r\nif (!nprop->value || kfree_table_add(kft, nprop->value))\r\nreturn NULL;\r\nnprop->length = prop->length;\r\nreturn nprop;\r\n}\r\nstatic void __init tilcdc_copy_props(struct device_node *from,\r\nstruct device_node *to,\r\nconst char * const props[],\r\nstruct kfree_table *kft)\r\n{\r\nstruct property *prop;\r\nint i;\r\nfor (i = 0; props[i]; i++) {\r\nprop = of_find_property(from, props[i], NULL);\r\nif (!prop)\r\ncontinue;\r\nprop = tilcdc_prop_dup(prop, kft);\r\nif (!prop)\r\ncontinue;\r\nprop->next = to->properties;\r\nto->properties = prop;\r\n}\r\n}\r\nstatic int __init tilcdc_prop_str_update(struct property *prop,\r\nconst char *str,\r\nstruct kfree_table *kft)\r\n{\r\nprop->value = kstrdup(str, GFP_KERNEL);\r\nif (kfree_table_add(kft, prop->value) || !prop->value)\r\nreturn -ENOMEM;\r\nprop->length = strlen(str)+1;\r\nreturn 0;\r\n}\r\nstatic void __init tilcdc_node_disable(struct device_node *node)\r\n{\r\nstruct property *prop;\r\nprop = kzalloc(sizeof(*prop), GFP_KERNEL);\r\nif (!prop)\r\nreturn;\r\nprop->name = "status";\r\nprop->value = "disabled";\r\nprop->length = strlen((char *)prop->value)+1;\r\nof_update_property(node, prop);\r\n}\r\nstruct device_node * __init tilcdc_get_overlay(struct kfree_table *kft)\r\n{\r\nconst int size = __dtb_tilcdc_slave_compat_end -\r\n__dtb_tilcdc_slave_compat_begin;\r\nstatic void *overlay_data;\r\nstruct device_node *overlay;\r\nint ret;\r\nif (!size) {\r\npr_warn("%s: No overlay data\n", __func__);\r\nreturn NULL;\r\n}\r\noverlay_data = kmemdup(__dtb_tilcdc_slave_compat_begin,\r\nsize, GFP_KERNEL);\r\nif (!overlay_data || kfree_table_add(kft, overlay_data))\r\nreturn NULL;\r\nof_fdt_unflatten_tree(overlay_data, &overlay);\r\nif (!overlay) {\r\npr_warn("%s: Unfattening overlay tree failed\n", __func__);\r\nreturn NULL;\r\n}\r\nof_node_set_flag(overlay, OF_DETACHED);\r\nret = of_resolve_phandles(overlay);\r\nif (ret) {\r\npr_err("%s: Failed to resolve phandles: %d\n", __func__, ret);\r\nreturn NULL;\r\n}\r\nreturn overlay;\r\n}\r\nvoid __init tilcdc_convert_slave_node(void)\r\n{\r\nstruct device_node *slave = NULL, *lcdc = NULL;\r\nstruct device_node *i2c = NULL, *fragment = NULL;\r\nstruct device_node *overlay, *encoder;\r\nstruct property *prop;\r\nstruct kfree_table kft;\r\nint ret;\r\nif (kfree_table_init(&kft))\r\ngoto out;\r\nlcdc = of_find_matching_node(NULL, tilcdc_of_match);\r\nslave = of_find_matching_node(NULL, tilcdc_slave_of_match);\r\nif (!slave || !of_device_is_available(lcdc))\r\ngoto out;\r\ni2c = of_parse_phandle(slave, "i2c", 0);\r\nif (!i2c) {\r\npr_err("%s: Can't find i2c node trough phandle\n", __func__);\r\ngoto out;\r\n}\r\noverlay = tilcdc_get_overlay(&kft);\r\nif (!overlay)\r\ngoto out;\r\nencoder = of_find_matching_node(overlay, tilcdc_tda998x_of_match);\r\nif (!encoder) {\r\npr_err("%s: Failed to find tda998x node\n", __func__);\r\ngoto out;\r\n}\r\ntilcdc_copy_props(slave, encoder, tilcdc_slave_props, &kft);\r\nfor_each_child_of_node(overlay, fragment) {\r\nprop = of_find_property(fragment, "target-path", NULL);\r\nif (!prop)\r\ncontinue;\r\nif (!strncmp("i2c", (char *)prop->value, prop->length))\r\nif (tilcdc_prop_str_update(prop, i2c->full_name, &kft))\r\ngoto out;\r\nif (!strncmp("lcdc", (char *)prop->value, prop->length))\r\nif (tilcdc_prop_str_update(prop, lcdc->full_name, &kft))\r\ngoto out;\r\n}\r\ntilcdc_node_disable(slave);\r\nret = of_overlay_create(overlay);\r\nif (ret)\r\npr_err("%s: Creating overlay failed: %d\n", __func__, ret);\r\nelse\r\npr_info("%s: ti,tilcdc,slave node successfully converted\n",\r\n__func__);\r\nout:\r\nkfree_table_free(&kft);\r\nof_node_put(i2c);\r\nof_node_put(slave);\r\nof_node_put(lcdc);\r\nof_node_put(fragment);\r\n}\r\nint __init tilcdc_slave_compat_init(void)\r\n{\r\ntilcdc_convert_slave_node();\r\nreturn 0;\r\n}
