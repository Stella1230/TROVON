static int sock_wait_state(struct sock *sk, int state, unsigned long timeo)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint err = 0;\r\npr_debug("sk %p", sk);\r\nadd_wait_queue(sk_sleep(sk), &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (sk->sk_state != state) {\r\nif (!timeo) {\r\nerr = -EINPROGRESS;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nerr = sock_error(sk);\r\nif (err)\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn err;\r\n}\r\nstatic int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nstruct nfc_llcp_local *local;\r\nstruct nfc_dev *dev;\r\nstruct sockaddr_nfc_llcp llcp_addr;\r\nint len, ret = 0;\r\nif (!addr || addr->sa_family != AF_NFC)\r\nreturn -EINVAL;\r\npr_debug("sk %p addr %p family %d\n", sk, addr, addr->sa_family);\r\nmemset(&llcp_addr, 0, sizeof(llcp_addr));\r\nlen = min_t(unsigned int, sizeof(llcp_addr), alen);\r\nmemcpy(&llcp_addr, addr, len);\r\nif (llcp_addr.dsap != 0)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != LLCP_CLOSED) {\r\nret = -EBADFD;\r\ngoto error;\r\n}\r\ndev = nfc_get_device(llcp_addr.dev_idx);\r\nif (dev == NULL) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\nret = -ENODEV;\r\ngoto put_dev;\r\n}\r\nllcp_sock->dev = dev;\r\nllcp_sock->local = nfc_llcp_local_get(local);\r\nllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\r\nllcp_sock->service_name_len = min_t(unsigned int,\r\nllcp_addr.service_name_len,\r\nNFC_LLCP_MAX_SERVICE_NAME);\r\nllcp_sock->service_name = kmemdup(llcp_addr.service_name,\r\nllcp_sock->service_name_len,\r\nGFP_KERNEL);\r\nllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\r\nif (llcp_sock->ssap == LLCP_SAP_MAX) {\r\nret = -EADDRINUSE;\r\ngoto put_dev;\r\n}\r\nllcp_sock->reserved_ssap = llcp_sock->ssap;\r\nnfc_llcp_sock_link(&local->sockets, sk);\r\npr_debug("Socket bound to SAP %d\n", llcp_sock->ssap);\r\nsk->sk_state = LLCP_BOUND;\r\nput_dev:\r\nnfc_put_device(dev);\r\nerror:\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\r\nint alen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nstruct nfc_llcp_local *local;\r\nstruct nfc_dev *dev;\r\nstruct sockaddr_nfc_llcp llcp_addr;\r\nint len, ret = 0;\r\nif (!addr || addr->sa_family != AF_NFC)\r\nreturn -EINVAL;\r\npr_debug("sk %p addr %p family %d\n", sk, addr, addr->sa_family);\r\nmemset(&llcp_addr, 0, sizeof(llcp_addr));\r\nlen = min_t(unsigned int, sizeof(llcp_addr), alen);\r\nmemcpy(&llcp_addr, addr, len);\r\nlock_sock(sk);\r\nif (sk->sk_state != LLCP_CLOSED) {\r\nret = -EBADFD;\r\ngoto error;\r\n}\r\ndev = nfc_get_device(llcp_addr.dev_idx);\r\nif (dev == NULL) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\nret = -ENODEV;\r\ngoto put_dev;\r\n}\r\nllcp_sock->dev = dev;\r\nllcp_sock->local = nfc_llcp_local_get(local);\r\nllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\r\nnfc_llcp_sock_link(&local->raw_sockets, sk);\r\nsk->sk_state = LLCP_BOUND;\r\nput_dev:\r\nnfc_put_device(dev);\r\nerror:\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int llcp_sock_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint ret = 0;\r\npr_debug("sk %p backlog %d\n", sk, backlog);\r\nlock_sock(sk);\r\nif ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM) ||\r\nsk->sk_state != LLCP_BOUND) {\r\nret = -EBADFD;\r\ngoto error;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_ack_backlog = 0;\r\npr_debug("Socket listening\n");\r\nsk->sk_state = LLCP_LISTEN;\r\nerror:\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int nfc_llcp_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nu32 opt;\r\nint err = 0;\r\npr_debug("%p optname %d\n", sk, optname);\r\nif (level != SOL_NFC)\r\nreturn -ENOPROTOOPT;\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase NFC_LLCP_RW:\r\nif (sk->sk_state == LLCP_CONNECTED ||\r\nsk->sk_state == LLCP_BOUND ||\r\nsk->sk_state == LLCP_LISTEN) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt > LLCP_MAX_RW) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nllcp_sock->rw = (u8) opt;\r\nbreak;\r\ncase NFC_LLCP_MIUX:\r\nif (sk->sk_state == LLCP_CONNECTED ||\r\nsk->sk_state == LLCP_BOUND ||\r\nsk->sk_state == LLCP_LISTEN) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (get_user(opt, (u32 __user *) optval)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (opt > LLCP_MAX_MIUX) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nllcp_sock->miux = cpu_to_be16((u16) opt);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\npr_debug("%p rw %d miux %d\n", llcp_sock,\r\nllcp_sock->rw, llcp_sock->miux);\r\nreturn err;\r\n}\r\nstatic int nfc_llcp_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct nfc_llcp_local *local;\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nint len, err = 0;\r\nu16 miux, remote_miu;\r\nu8 rw;\r\npr_debug("%p optname %d\n", sk, optname);\r\nif (level != SOL_NFC)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlocal = llcp_sock->local;\r\nif (!local)\r\nreturn -ENODEV;\r\nlen = min_t(u32, len, sizeof(u32));\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase NFC_LLCP_RW:\r\nrw = llcp_sock->rw > LLCP_MAX_RW ? local->rw : llcp_sock->rw;\r\nif (put_user(rw, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase NFC_LLCP_MIUX:\r\nmiux = be16_to_cpu(llcp_sock->miux) > LLCP_MAX_MIUX ?\r\nbe16_to_cpu(local->miux) : be16_to_cpu(llcp_sock->miux);\r\nif (put_user(miux, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase NFC_LLCP_REMOTE_MIU:\r\nremote_miu = llcp_sock->remote_miu > LLCP_MAX_MIU ?\r\nlocal->remote_miu : llcp_sock->remote_miu;\r\nif (put_user(remote_miu, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase NFC_LLCP_REMOTE_LTO:\r\nif (put_user(local->remote_lto / 10, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ncase NFC_LLCP_REMOTE_RW:\r\nif (put_user(llcp_sock->remote_rw, (u32 __user *) optval))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nvoid nfc_llcp_accept_unlink(struct sock *sk)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\npr_debug("state %d\n", sk->sk_state);\r\nlist_del_init(&llcp_sock->accept_queue);\r\nsk_acceptq_removed(llcp_sock->parent);\r\nllcp_sock->parent = NULL;\r\nsock_put(sk);\r\n}\r\nvoid nfc_llcp_accept_enqueue(struct sock *parent, struct sock *sk)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nstruct nfc_llcp_sock *llcp_sock_parent = nfc_llcp_sock(parent);\r\nsock_hold(sk);\r\nlist_add_tail(&llcp_sock->accept_queue,\r\n&llcp_sock_parent->accept_queue);\r\nllcp_sock->parent = parent;\r\nsk_acceptq_added(parent);\r\n}\r\nstruct sock *nfc_llcp_accept_dequeue(struct sock *parent,\r\nstruct socket *newsock)\r\n{\r\nstruct nfc_llcp_sock *lsk, *n, *llcp_parent;\r\nstruct sock *sk;\r\nllcp_parent = nfc_llcp_sock(parent);\r\nlist_for_each_entry_safe(lsk, n, &llcp_parent->accept_queue,\r\naccept_queue) {\r\nsk = &lsk->sk;\r\nlock_sock(sk);\r\nif (sk->sk_state == LLCP_CLOSED) {\r\nrelease_sock(sk);\r\nnfc_llcp_accept_unlink(sk);\r\ncontinue;\r\n}\r\nif (sk->sk_state == LLCP_CONNECTED || !newsock) {\r\nlist_del_init(&lsk->accept_queue);\r\nsock_put(sk);\r\nif (newsock)\r\nsock_graft(sk, newsock);\r\nrelease_sock(sk);\r\npr_debug("Returning sk state %d\n", sk->sk_state);\r\nsk_acceptq_removed(parent);\r\nreturn sk;\r\n}\r\nrelease_sock(sk);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int llcp_sock_accept(struct socket *sock, struct socket *newsock,\r\nint flags)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct sock *sk = sock->sk, *new_sk;\r\nlong timeo;\r\nint ret = 0;\r\npr_debug("parent %p\n", sk);\r\nlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\r\nif (sk->sk_state != LLCP_LISTEN) {\r\nret = -EBADFD;\r\ngoto error;\r\n}\r\ntimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\r\nadd_wait_queue_exclusive(sk_sleep(sk), &wait);\r\nwhile (!(new_sk = nfc_llcp_accept_dequeue(sk, newsock))) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!timeo) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = sock_intr_errno(timeo);\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nif (ret)\r\ngoto error;\r\nnewsock->state = SS_CONNECTED;\r\npr_debug("new socket %p\n", new_sk);\r\nerror:\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int llcp_sock_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *len, int peer)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, llcp_addr, uaddr);\r\nif (llcp_sock == NULL || llcp_sock->dev == NULL)\r\nreturn -EBADFD;\r\npr_debug("%p %d %d %d\n", sk, llcp_sock->target_idx,\r\nllcp_sock->dsap, llcp_sock->ssap);\r\nmemset(llcp_addr, 0, sizeof(*llcp_addr));\r\n*len = sizeof(struct sockaddr_nfc_llcp);\r\nllcp_addr->sa_family = AF_NFC;\r\nllcp_addr->dev_idx = llcp_sock->dev->idx;\r\nllcp_addr->target_idx = llcp_sock->target_idx;\r\nllcp_addr->nfc_protocol = llcp_sock->nfc_protocol;\r\nllcp_addr->dsap = llcp_sock->dsap;\r\nllcp_addr->ssap = llcp_sock->ssap;\r\nllcp_addr->service_name_len = llcp_sock->service_name_len;\r\nmemcpy(llcp_addr->service_name, llcp_sock->service_name,\r\nllcp_addr->service_name_len);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int llcp_accept_poll(struct sock *parent)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock, *parent_sock;\r\nstruct sock *sk;\r\nparent_sock = nfc_llcp_sock(parent);\r\nlist_for_each_entry(llcp_sock, &parent_sock->accept_queue,\r\naccept_queue) {\r\nsk = &llcp_sock->sk;\r\nif (sk->sk_state == LLCP_CONNECTED)\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int llcp_sock_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nunsigned int mask = 0;\r\npr_debug("%p\n", sk);\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nif (sk->sk_state == LLCP_LISTEN)\r\nreturn llcp_accept_poll(sk);\r\nif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\r\nmask |= POLLERR |\r\n(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (sk->sk_state == LLCP_CLOSED)\r\nmask |= POLLHUP;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nmask |= POLLRDHUP | POLLIN | POLLRDNORM;\r\nif (sk->sk_shutdown == SHUTDOWN_MASK)\r\nmask |= POLLHUP;\r\nif (sock_writeable(sk) && sk->sk_state == LLCP_CONNECTED)\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nelse\r\nset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\r\npr_debug("mask 0x%x\n", mask);\r\nreturn mask;\r\n}\r\nstatic int llcp_sock_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_local *local;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nint err = 0;\r\nif (!sk)\r\nreturn 0;\r\npr_debug("%p\n", sk);\r\nlocal = llcp_sock->local;\r\nif (local == NULL) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nlock_sock(sk);\r\nif (sk->sk_state == LLCP_CONNECTED)\r\nnfc_llcp_send_disconnect(llcp_sock);\r\nif (sk->sk_state == LLCP_LISTEN) {\r\nstruct nfc_llcp_sock *lsk, *n;\r\nstruct sock *accept_sk;\r\nlist_for_each_entry_safe(lsk, n, &llcp_sock->accept_queue,\r\naccept_queue) {\r\naccept_sk = &lsk->sk;\r\nlock_sock(accept_sk);\r\nnfc_llcp_send_disconnect(lsk);\r\nnfc_llcp_accept_unlink(accept_sk);\r\nrelease_sock(accept_sk);\r\n}\r\n}\r\nif (llcp_sock->reserved_ssap < LLCP_SAP_MAX)\r\nnfc_llcp_put_ssap(llcp_sock->local, llcp_sock->ssap);\r\nrelease_sock(sk);\r\nif (sk->sk_state == LLCP_DISCONNECTING)\r\nreturn err;\r\nif (sock->type == SOCK_RAW)\r\nnfc_llcp_sock_unlink(&local->raw_sockets, sk);\r\nelse\r\nnfc_llcp_sock_unlink(&local->sockets, sk);\r\nout:\r\nsock_orphan(sk);\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,\r\nint len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nstruct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr;\r\nstruct nfc_dev *dev;\r\nstruct nfc_llcp_local *local;\r\nint ret = 0;\r\npr_debug("sock %p sk %p flags 0x%x\n", sock, sk, flags);\r\nif (!addr || len < sizeof(struct sockaddr_nfc) ||\r\naddr->sa_family != AF_NFC)\r\nreturn -EINVAL;\r\nif (addr->service_name_len == 0 && addr->dsap == 0)\r\nreturn -EINVAL;\r\npr_debug("addr dev_idx=%u target_idx=%u protocol=%u\n", addr->dev_idx,\r\naddr->target_idx, addr->nfc_protocol);\r\nlock_sock(sk);\r\nif (sk->sk_state == LLCP_CONNECTED) {\r\nret = -EISCONN;\r\ngoto error;\r\n}\r\ndev = nfc_get_device(addr->dev_idx);\r\nif (dev == NULL) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\nret = -ENODEV;\r\ngoto put_dev;\r\n}\r\ndevice_lock(&dev->dev);\r\nif (dev->dep_link_up == false) {\r\nret = -ENOLINK;\r\ndevice_unlock(&dev->dev);\r\ngoto put_dev;\r\n}\r\ndevice_unlock(&dev->dev);\r\nif (local->rf_mode == NFC_RF_INITIATOR &&\r\naddr->target_idx != local->target_idx) {\r\nret = -ENOLINK;\r\ngoto put_dev;\r\n}\r\nllcp_sock->dev = dev;\r\nllcp_sock->local = nfc_llcp_local_get(local);\r\nllcp_sock->ssap = nfc_llcp_get_local_ssap(local);\r\nif (llcp_sock->ssap == LLCP_SAP_MAX) {\r\nret = -ENOMEM;\r\ngoto put_dev;\r\n}\r\nllcp_sock->reserved_ssap = llcp_sock->ssap;\r\nif (addr->service_name_len == 0)\r\nllcp_sock->dsap = addr->dsap;\r\nelse\r\nllcp_sock->dsap = LLCP_SAP_SDP;\r\nllcp_sock->nfc_protocol = addr->nfc_protocol;\r\nllcp_sock->service_name_len = min_t(unsigned int,\r\naddr->service_name_len,\r\nNFC_LLCP_MAX_SERVICE_NAME);\r\nllcp_sock->service_name = kmemdup(addr->service_name,\r\nllcp_sock->service_name_len,\r\nGFP_KERNEL);\r\nnfc_llcp_sock_link(&local->connecting_sockets, sk);\r\nret = nfc_llcp_send_connect(llcp_sock);\r\nif (ret)\r\ngoto sock_unlink;\r\nsk->sk_state = LLCP_CONNECTING;\r\nret = sock_wait_state(sk, LLCP_CONNECTED,\r\nsock_sndtimeo(sk, flags & O_NONBLOCK));\r\nif (ret && ret != -EINPROGRESS)\r\ngoto sock_unlink;\r\nrelease_sock(sk);\r\nreturn ret;\r\nsock_unlink:\r\nnfc_llcp_put_ssap(local, llcp_sock->ssap);\r\nnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\r\nput_dev:\r\nnfc_put_device(dev);\r\nerror:\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int llcp_sock_sendmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\nint ret;\r\npr_debug("sock %p sk %p", sock, sk);\r\nret = sock_error(sk);\r\nif (ret)\r\nreturn ret;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nlock_sock(sk);\r\nif (sk->sk_type == SOCK_DGRAM) {\r\nDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, addr,\r\nmsg->msg_name);\r\nif (msg->msg_namelen < sizeof(*addr)) {\r\nrelease_sock(sk);\r\nreturn -EINVAL;\r\n}\r\nrelease_sock(sk);\r\nreturn nfc_llcp_send_ui_frame(llcp_sock, addr->dsap, addr->ssap,\r\nmsg, len);\r\n}\r\nif (sk->sk_state != LLCP_CONNECTED) {\r\nrelease_sock(sk);\r\nreturn -ENOTCONN;\r\n}\r\nrelease_sock(sk);\r\nreturn nfc_llcp_send_i_frame(llcp_sock, msg, len);\r\n}\r\nstatic int llcp_sock_recvmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t len, int flags)\r\n{\r\nint noblock = flags & MSG_DONTWAIT;\r\nstruct sock *sk = sock->sk;\r\nunsigned int copied, rlen;\r\nstruct sk_buff *skb, *cskb;\r\nint err = 0;\r\npr_debug("%p %zu\n", sk, len);\r\nlock_sock(sk);\r\nif (sk->sk_state == LLCP_CLOSED &&\r\nskb_queue_empty(&sk->sk_receive_queue)) {\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nrelease_sock(sk);\r\nif (flags & (MSG_OOB))\r\nreturn -EOPNOTSUPP;\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb) {\r\npr_err("Recv datagram failed state %d %d %d",\r\nsk->sk_state, err, sock_error(sk));\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nreturn 0;\r\nreturn err;\r\n}\r\nrlen = skb->len;\r\ncopied = min_t(unsigned int, rlen, len);\r\ncskb = skb;\r\nif (skb_copy_datagram_msg(cskb, 0, msg, copied)) {\r\nif (!(flags & MSG_PEEK))\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nreturn -EFAULT;\r\n}\r\nsock_recv_timestamp(msg, sk, skb);\r\nif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {\r\nstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);\r\nDECLARE_SOCKADDR(struct sockaddr_nfc_llcp *, sockaddr,\r\nmsg->msg_name);\r\nmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);\r\npr_debug("Datagram socket %d %d\n", ui_cb->dsap, ui_cb->ssap);\r\nmemset(sockaddr, 0, sizeof(*sockaddr));\r\nsockaddr->sa_family = AF_NFC;\r\nsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;\r\nsockaddr->dsap = ui_cb->dsap;\r\nsockaddr->ssap = ui_cb->ssap;\r\n}\r\nif (!(flags & MSG_PEEK)) {\r\nif (sk->sk_type == SOCK_STREAM ||\r\nsk->sk_type == SOCK_DGRAM ||\r\nsk->sk_type == SOCK_RAW) {\r\nskb_pull(skb, copied);\r\nif (skb->len) {\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\ngoto done;\r\n}\r\n}\r\nkfree_skb(skb);\r\n}\r\ndone:\r\nif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))\r\ncopied = rlen;\r\nreturn copied;\r\n}\r\nstatic void llcp_sock_destruct(struct sock *sk)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\r\npr_debug("%p\n", sk);\r\nif (sk->sk_state == LLCP_CONNECTED)\r\nnfc_put_device(llcp_sock->dev);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nnfc_llcp_sock_free(llcp_sock);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\npr_err("Freeing alive NFC LLCP socket %p\n", sk);\r\nreturn;\r\n}\r\n}\r\nstruct sock *nfc_llcp_sock_alloc(struct socket *sock, int type, gfp_t gfp, int kern)\r\n{\r\nstruct sock *sk;\r\nstruct nfc_llcp_sock *llcp_sock;\r\nsk = sk_alloc(&init_net, PF_NFC, gfp, &llcp_sock_proto, kern);\r\nif (!sk)\r\nreturn NULL;\r\nllcp_sock = nfc_llcp_sock(sk);\r\nsock_init_data(sock, sk);\r\nsk->sk_state = LLCP_CLOSED;\r\nsk->sk_protocol = NFC_SOCKPROTO_LLCP;\r\nsk->sk_type = type;\r\nsk->sk_destruct = llcp_sock_destruct;\r\nllcp_sock->ssap = 0;\r\nllcp_sock->dsap = LLCP_SAP_SDP;\r\nllcp_sock->rw = LLCP_MAX_RW + 1;\r\nllcp_sock->miux = cpu_to_be16(LLCP_MAX_MIUX + 1);\r\nllcp_sock->send_n = llcp_sock->send_ack_n = 0;\r\nllcp_sock->recv_n = llcp_sock->recv_ack_n = 0;\r\nllcp_sock->remote_ready = 1;\r\nllcp_sock->reserved_ssap = LLCP_SAP_MAX;\r\nnfc_llcp_socket_remote_param_init(llcp_sock);\r\nskb_queue_head_init(&llcp_sock->tx_queue);\r\nskb_queue_head_init(&llcp_sock->tx_pending_queue);\r\nINIT_LIST_HEAD(&llcp_sock->accept_queue);\r\nif (sock != NULL)\r\nsock->state = SS_UNCONNECTED;\r\nreturn sk;\r\n}\r\nvoid nfc_llcp_sock_free(struct nfc_llcp_sock *sock)\r\n{\r\nkfree(sock->service_name);\r\nskb_queue_purge(&sock->tx_queue);\r\nskb_queue_purge(&sock->tx_pending_queue);\r\nlist_del_init(&sock->accept_queue);\r\nsock->parent = NULL;\r\nnfc_llcp_local_put(sock->local);\r\n}\r\nstatic int llcp_sock_create(struct net *net, struct socket *sock,\r\nconst struct nfc_protocol *nfc_proto, int kern)\r\n{\r\nstruct sock *sk;\r\npr_debug("%p\n", sock);\r\nif (sock->type != SOCK_STREAM &&\r\nsock->type != SOCK_DGRAM &&\r\nsock->type != SOCK_RAW)\r\nreturn -ESOCKTNOSUPPORT;\r\nif (sock->type == SOCK_RAW)\r\nsock->ops = &llcp_rawsock_ops;\r\nelse\r\nsock->ops = &llcp_sock_ops;\r\nsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\r\nif (sk == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint __init nfc_llcp_sock_init(void)\r\n{\r\nreturn nfc_proto_register(&llcp_nfc_proto);\r\n}\r\nvoid nfc_llcp_sock_exit(void)\r\n{\r\nnfc_proto_unregister(&llcp_nfc_proto);\r\n}
