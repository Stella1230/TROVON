static unsigned long timer16_get_counter(struct timer16_priv *p)\r\n{\r\nunsigned long v1, v2, v3;\r\nint o1, o2;\r\no1 = ctrl_inb(p->mapcommon + TISRC) & p->ovf;\r\ndo {\r\no2 = o1;\r\nv1 = ctrl_inw(p->mapbase + TCNT);\r\nv2 = ctrl_inw(p->mapbase + TCNT);\r\nv3 = ctrl_inw(p->mapbase + TCNT);\r\no1 = ctrl_inb(p->mapcommon + TISRC) & p->ovf;\r\n} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\r\n|| (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\r\nv2 |= 0x10000;\r\nreturn v2;\r\n}\r\nstatic irqreturn_t timer16_interrupt(int irq, void *dev_id)\r\n{\r\nstruct timer16_priv *p = (struct timer16_priv *)dev_id;\r\nctrl_outb(ctrl_inb(p->mapcommon + TISRA) & ~p->imfa,\r\np->mapcommon + TISRA);\r\np->total_cycles += 0x10000;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline struct timer16_priv *cs_to_priv(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct timer16_priv, cs);\r\n}\r\nstatic cycle_t timer16_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct timer16_priv *p = cs_to_priv(cs);\r\nunsigned long flags, raw;\r\nunsigned long value;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nvalue = p->total_cycles;\r\nraw = timer16_get_counter(p);\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn value + raw;\r\n}\r\nstatic int timer16_enable(struct clocksource *cs)\r\n{\r\nstruct timer16_priv *p = cs_to_priv(cs);\r\nWARN_ON(p->cs_enabled);\r\np->total_cycles = 0;\r\nctrl_outw(0x0000, p->mapbase + TCNT);\r\nctrl_outb(0x83, p->mapbase + TCR);\r\nctrl_outb(ctrl_inb(p->mapcommon + TSTR) | p->enb,\r\np->mapcommon + TSTR);\r\np->cs_enabled = true;\r\nreturn 0;\r\n}\r\nstatic void timer16_disable(struct clocksource *cs)\r\n{\r\nstruct timer16_priv *p = cs_to_priv(cs);\r\nWARN_ON(!p->cs_enabled);\r\nctrl_outb(ctrl_inb(p->mapcommon + TSTR) & ~p->enb,\r\np->mapcommon + TSTR);\r\np->cs_enabled = false;\r\n}\r\nstatic int timer16_setup(struct timer16_priv *p, struct platform_device *pdev)\r\n{\r\nstruct resource *res[2];\r\nint ret, irq;\r\nunsigned int ch;\r\nmemset(p, 0, sizeof(*p));\r\np->pdev = pdev;\r\nres[REG_CH] = platform_get_resource(p->pdev,\r\nIORESOURCE_MEM, REG_CH);\r\nres[REG_COMM] = platform_get_resource(p->pdev,\r\nIORESOURCE_MEM, REG_COMM);\r\nif (!res[REG_CH] || !res[REG_COMM]) {\r\ndev_err(&p->pdev->dev, "failed to get I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\nirq = platform_get_irq(p->pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&p->pdev->dev, "failed to get irq\n");\r\nreturn irq;\r\n}\r\np->clk = clk_get(&p->pdev->dev, "fck");\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&p->pdev->dev, "can't get clk\n");\r\nreturn PTR_ERR(p->clk);\r\n}\r\nof_property_read_u32(p->pdev->dev.of_node, "renesas,channel", &ch);\r\np->pdev = pdev;\r\np->mapbase = res[REG_CH]->start;\r\np->mapcommon = res[REG_COMM]->start;\r\np->enb = 1 << ch;\r\np->imfa = 1 << ch;\r\np->imiea = 1 << (4 + ch);\r\np->cs.name = pdev->name;\r\np->cs.rating = 200;\r\np->cs.read = timer16_clocksource_read;\r\np->cs.enable = timer16_enable;\r\np->cs.disable = timer16_disable;\r\np->cs.mask = CLOCKSOURCE_MASK(sizeof(unsigned long) * 8);\r\np->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\nret = request_irq(irq, timer16_interrupt,\r\nIRQF_TIMER, pdev->name, p);\r\nif (ret < 0) {\r\ndev_err(&p->pdev->dev, "failed to request irq %d\n", irq);\r\nreturn ret;\r\n}\r\nclocksource_register_hz(&p->cs, clk_get_rate(p->clk) / 8);\r\nreturn 0;\r\n}\r\nstatic int timer16_probe(struct platform_device *pdev)\r\n{\r\nstruct timer16_priv *p = platform_get_drvdata(pdev);\r\nif (p) {\r\ndev_info(&pdev->dev, "kept as earlytimer\n");\r\nreturn 0;\r\n}\r\np = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nreturn timer16_setup(p, pdev);\r\n}\r\nstatic int timer16_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init timer16_init(void)\r\n{\r\nreturn platform_driver_register(&timer16_driver);\r\n}\r\nstatic void __exit timer16_exit(void)\r\n{\r\nplatform_driver_unregister(&timer16_driver);\r\n}
