int jfs_strfromUCS_le(char *to, const __le16 * from,\r\nint len, struct nls_table *codepage)\r\n{\r\nint i;\r\nint outlen = 0;\r\nstatic int warn_again = 5;\r\nint warn = !!warn_again;\r\nif (codepage) {\r\nfor (i = 0; (i < len) && from[i]; i++) {\r\nint charlen;\r\ncharlen =\r\ncodepage->uni2char(le16_to_cpu(from[i]),\r\n&to[outlen],\r\nNLS_MAX_CHARSET_SIZE);\r\nif (charlen > 0)\r\noutlen += charlen;\r\nelse\r\nto[outlen++] = '?';\r\n}\r\n} else {\r\nfor (i = 0; (i < len) && from[i]; i++) {\r\nif (unlikely(le16_to_cpu(from[i]) & 0xff00)) {\r\nto[i] = '?';\r\nif (unlikely(warn)) {\r\nwarn--;\r\nwarn_again--;\r\nprintk(KERN_ERR\r\n"non-latin1 character 0x%x found in JFS file name\n",\r\nle16_to_cpu(from[i]));\r\nprintk(KERN_ERR\r\n"mount with iocharset=utf8 to access\n");\r\n}\r\n}\r\nelse\r\nto[i] = (char) (le16_to_cpu(from[i]));\r\n}\r\noutlen = i;\r\n}\r\nto[outlen] = 0;\r\nreturn outlen;\r\n}\r\nstatic int jfs_strtoUCS(wchar_t * to, const unsigned char *from, int len,\r\nstruct nls_table *codepage)\r\n{\r\nint charlen;\r\nint i;\r\nif (codepage) {\r\nfor (i = 0; len && *from; i++, from += charlen, len -= charlen)\r\n{\r\ncharlen = codepage->char2uni(from, len, &to[i]);\r\nif (charlen < 1) {\r\njfs_err("jfs_strtoUCS: char2uni returned %d.",\r\ncharlen);\r\njfs_err("charset = %s, char = 0x%x",\r\ncodepage->charset, *from);\r\nreturn charlen;\r\n}\r\n}\r\n} else {\r\nfor (i = 0; (i < len) && from[i]; i++)\r\nto[i] = (wchar_t) from[i];\r\n}\r\nto[i] = 0;\r\nreturn i;\r\n}\r\nint get_UCSname(struct component_name * uniName, struct dentry *dentry)\r\n{\r\nstruct nls_table *nls_tab = JFS_SBI(dentry->d_sb)->nls_tab;\r\nint length = dentry->d_name.len;\r\nif (length > JFS_NAME_MAX)\r\nreturn -ENAMETOOLONG;\r\nuniName->name =\r\nkmalloc((length + 1) * sizeof(wchar_t), GFP_NOFS);\r\nif (uniName->name == NULL)\r\nreturn -ENOMEM;\r\nuniName->namlen = jfs_strtoUCS(uniName->name, dentry->d_name.name,\r\nlength, nls_tab);\r\nif (uniName->namlen < 0) {\r\nkfree(uniName->name);\r\nreturn uniName->namlen;\r\n}\r\nreturn 0;\r\n}
