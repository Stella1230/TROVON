acpi_status acpi_allocate_root_table(u32 initial_table_count)\r\n{\r\nacpi_gbl_root_table_list.max_table_count = initial_table_count;\r\nacpi_gbl_root_table_list.flags = ACPI_ROOT_ALLOW_RESIZE;\r\nreturn (acpi_tb_resize_root_table_list());\r\n}\r\nacpi_status __init\r\nacpi_initialize_tables(struct acpi_table_desc * initial_table_array,\r\nu32 initial_table_count, u8 allow_resize)\r\n{\r\nacpi_physical_address rsdp_address;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_initialize_tables);\r\nif (!initial_table_array) {\r\nstatus = acpi_allocate_root_table(initial_table_count);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} else {\r\nmemset(initial_table_array, 0,\r\n(acpi_size) initial_table_count *\r\nsizeof(struct acpi_table_desc));\r\nacpi_gbl_root_table_list.tables = initial_table_array;\r\nacpi_gbl_root_table_list.max_table_count = initial_table_count;\r\nacpi_gbl_root_table_list.flags = ACPI_ROOT_ORIGIN_UNKNOWN;\r\nif (allow_resize) {\r\nacpi_gbl_root_table_list.flags |=\r\nACPI_ROOT_ALLOW_RESIZE;\r\n}\r\n}\r\nrsdp_address = acpi_os_get_root_pointer();\r\nif (!rsdp_address) {\r\nreturn_ACPI_STATUS(AE_NOT_FOUND);\r\n}\r\nstatus = acpi_tb_parse_root_table(rsdp_address);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status __init acpi_reallocate_root_table(void)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_reallocate_root_table);\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\nacpi_gbl_root_table_list.flags |= ACPI_ROOT_ALLOW_RESIZE;\r\nstatus = acpi_tb_resize_root_table_list();\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_get_table_header(char *signature,\r\nu32 instance, struct acpi_table_header *out_table_header)\r\n{\r\nu32 i;\r\nu32 j;\r\nstruct acpi_table_header *header;\r\nif (!signature || !out_table_header) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\r\ni++) {\r\nif (!ACPI_COMPARE_NAME\r\n(&(acpi_gbl_root_table_list.tables[i].signature),\r\nsignature)) {\r\ncontinue;\r\n}\r\nif (++j < instance) {\r\ncontinue;\r\n}\r\nif (!acpi_gbl_root_table_list.tables[i].pointer) {\r\nif ((acpi_gbl_root_table_list.tables[i].flags &\r\nACPI_TABLE_ORIGIN_MASK) ==\r\nACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL) {\r\nheader =\r\nacpi_os_map_memory(acpi_gbl_root_table_list.\r\ntables[i].address,\r\nsizeof(struct\r\nacpi_table_header));\r\nif (!header) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nmemcpy(out_table_header, header,\r\nsizeof(struct acpi_table_header));\r\nacpi_os_unmap_memory(header,\r\nsizeof(struct\r\nacpi_table_header));\r\n} else {\r\nreturn (AE_NOT_FOUND);\r\n}\r\n} else {\r\nmemcpy(out_table_header,\r\nacpi_gbl_root_table_list.tables[i].pointer,\r\nsizeof(struct acpi_table_header));\r\n}\r\nreturn (AE_OK);\r\n}\r\nreturn (AE_NOT_FOUND);\r\n}\r\nacpi_status\r\nacpi_get_table_with_size(char *signature,\r\nu32 instance, struct acpi_table_header **out_table,\r\nacpi_size *tbl_size)\r\n{\r\nu32 i;\r\nu32 j;\r\nacpi_status status;\r\nif (!signature || !out_table) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\r\ni++) {\r\nif (!ACPI_COMPARE_NAME\r\n(&(acpi_gbl_root_table_list.tables[i].signature),\r\nsignature)) {\r\ncontinue;\r\n}\r\nif (++j < instance) {\r\ncontinue;\r\n}\r\nstatus =\r\nacpi_tb_validate_table(&acpi_gbl_root_table_list.tables[i]);\r\nif (ACPI_SUCCESS(status)) {\r\n*out_table = acpi_gbl_root_table_list.tables[i].pointer;\r\n*tbl_size = acpi_gbl_root_table_list.tables[i].length;\r\n}\r\nif (!acpi_gbl_permanent_mmap) {\r\nacpi_gbl_root_table_list.tables[i].pointer = NULL;\r\n}\r\nreturn (status);\r\n}\r\nreturn (AE_NOT_FOUND);\r\n}\r\nacpi_status\r\nacpi_get_table(char *signature,\r\nu32 instance, struct acpi_table_header **out_table)\r\n{\r\nacpi_size tbl_size;\r\nreturn acpi_get_table_with_size(signature,\r\ninstance, out_table, &tbl_size);\r\n}\r\nacpi_status\r\nacpi_get_table_by_index(u32 table_index, struct acpi_table_header ** table)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_get_table_by_index);\r\nif (!table) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index >= acpi_gbl_root_table_list.current_table_count) {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!acpi_gbl_root_table_list.tables[table_index].pointer) {\r\nstatus =\r\nacpi_tb_validate_table(&acpi_gbl_root_table_list.\r\ntables[table_index]);\r\nif (ACPI_FAILURE(status)) {\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\n}\r\n*table = acpi_gbl_root_table_list.tables[table_index].pointer;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nacpi_status\r\nacpi_install_table_handler(acpi_table_handler handler, void *context)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_table_handler);\r\nif (!handler) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_table_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_table_handler = handler;\r\nacpi_gbl_table_handler_context = context;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_remove_table_handler(acpi_table_handler handler)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_remove_table_handler);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!handler || handler != acpi_gbl_table_handler) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_table_handler = NULL;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}
