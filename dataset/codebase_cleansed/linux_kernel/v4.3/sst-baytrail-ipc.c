static inline u64 sst_byt_header(int msg_id, int data, bool large, int str_id)\r\n{\r\nu64 header;\r\nheader = IPC_HEADER_MSG_ID(msg_id) |\r\nIPC_HEADER_STR_ID(str_id) |\r\nIPC_HEADER_LARGE(large) |\r\nIPC_HEADER_DATA(data) |\r\nSST_BYT_IPCX_BUSY;\r\nreturn header;\r\n}\r\nstatic inline u16 sst_byt_header_msg_id(u64 header)\r\n{\r\nreturn header & IPC_HEADER_MSG_ID_MASK;\r\n}\r\nstatic inline u8 sst_byt_header_str_id(u64 header)\r\n{\r\nreturn (header >> IPC_HEADER_STR_ID_SHIFT) & IPC_HEADER_STR_ID_MASK;\r\n}\r\nstatic inline u16 sst_byt_header_data(u64 header)\r\n{\r\nreturn (header >> IPC_HEADER_DATA_SHIFT) & IPC_HEADER_DATA_MASK;\r\n}\r\nstatic struct sst_byt_stream *sst_byt_get_stream(struct sst_byt *byt,\r\nint stream_id)\r\n{\r\nstruct sst_byt_stream *stream;\r\nlist_for_each_entry(stream, &byt->stream_list, node) {\r\nif (stream->str_id == stream_id)\r\nreturn stream;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sst_byt_stream_update(struct sst_byt *byt, struct ipc_message *msg)\r\n{\r\nstruct sst_byt_stream *stream;\r\nu64 header = msg->header;\r\nu8 stream_id = sst_byt_header_str_id(header);\r\nu8 stream_msg = sst_byt_header_msg_id(header);\r\nstream = sst_byt_get_stream(byt, stream_id);\r\nif (stream == NULL)\r\nreturn;\r\nswitch (stream_msg) {\r\ncase IPC_IA_DROP_STREAM:\r\ncase IPC_IA_PAUSE_STREAM:\r\ncase IPC_IA_FREE_STREAM:\r\nstream->running = false;\r\nbreak;\r\ncase IPC_IA_START_STREAM:\r\ncase IPC_IA_RESUME_STREAM:\r\nstream->running = true;\r\nbreak;\r\n}\r\n}\r\nstatic int sst_byt_process_reply(struct sst_byt *byt, u64 header)\r\n{\r\nstruct ipc_message *msg;\r\nmsg = sst_ipc_reply_find_msg(&byt->ipc, header);\r\nif (msg == NULL)\r\nreturn 1;\r\nif (header & IPC_HEADER_LARGE(true)) {\r\nmsg->rx_size = sst_byt_header_data(header);\r\nsst_dsp_inbox_read(byt->dsp, msg->rx_data, msg->rx_size);\r\n}\r\nsst_byt_stream_update(byt, msg);\r\nlist_del(&msg->list);\r\nsst_ipc_tx_msg_reply_complete(&byt->ipc, msg);\r\nreturn 1;\r\n}\r\nstatic void sst_byt_fw_ready(struct sst_byt *byt, u64 header)\r\n{\r\ndev_dbg(byt->dev, "ipc: DSP is ready 0x%llX\n", header);\r\nbyt->boot_complete = true;\r\nwake_up(&byt->boot_wait);\r\n}\r\nstatic int sst_byt_process_notification(struct sst_byt *byt,\r\nunsigned long *flags)\r\n{\r\nstruct sst_dsp *sst = byt->dsp;\r\nstruct sst_byt_stream *stream;\r\nu64 header;\r\nu8 msg_id, stream_id;\r\nint handled = 1;\r\nheader = sst_dsp_shim_read64_unlocked(sst, SST_IPCD);\r\nmsg_id = sst_byt_header_msg_id(header);\r\nswitch (msg_id) {\r\ncase IPC_SST_PERIOD_ELAPSED:\r\nstream_id = sst_byt_header_str_id(header);\r\nstream = sst_byt_get_stream(byt, stream_id);\r\nif (stream && stream->running && stream->notify_position) {\r\nspin_unlock_irqrestore(&sst->spinlock, *flags);\r\nstream->notify_position(stream, stream->pdata);\r\nspin_lock_irqsave(&sst->spinlock, *flags);\r\n}\r\nbreak;\r\ncase IPC_IA_FW_INIT_CMPLT:\r\nsst_byt_fw_ready(byt, header);\r\nbreak;\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t sst_byt_irq_thread(int irq, void *context)\r\n{\r\nstruct sst_dsp *sst = (struct sst_dsp *) context;\r\nstruct sst_byt *byt = sst_dsp_get_thread_context(sst);\r\nstruct sst_generic_ipc *ipc = &byt->ipc;\r\nu64 header;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nheader = sst_dsp_shim_read64_unlocked(sst, SST_IPCD);\r\nif (header & SST_BYT_IPCD_BUSY) {\r\nif (header & IPC_NOTIFICATION) {\r\nsst_byt_process_notification(byt, &flags);\r\n} else {\r\nsst_byt_process_reply(byt, header);\r\n}\r\nsst_dsp_shim_update_bits64_unlocked(sst, SST_IPCD,\r\nSST_BYT_IPCD_DONE | SST_BYT_IPCD_BUSY |\r\nIPC_HEADER_DATA(IPC_HEADER_DATA_MASK),\r\nSST_BYT_IPCD_DONE);\r\nsst_dsp_shim_update_bits64_unlocked(sst, SST_IMRX,\r\nSST_BYT_IMRX_REQUEST, 0);\r\n}\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nqueue_kthread_work(&ipc->kworker, &ipc->kwork);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct sst_byt_stream *sst_byt_stream_new(struct sst_byt *byt, int id,\r\nu32 (*notify_position)(struct sst_byt_stream *stream, void *data),\r\nvoid *data)\r\n{\r\nstruct sst_byt_stream *stream;\r\nstruct sst_dsp *sst = byt->dsp;\r\nunsigned long flags;\r\nstream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL)\r\nreturn NULL;\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nlist_add(&stream->node, &byt->stream_list);\r\nstream->notify_position = notify_position;\r\nstream->pdata = data;\r\nstream->byt = byt;\r\nstream->str_id = id;\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn stream;\r\n}\r\nint sst_byt_stream_set_bits(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nint bits)\r\n{\r\nstream->request.pcm_params.pcm_wd_sz = bits;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_set_channels(struct sst_byt *byt,\r\nstruct sst_byt_stream *stream, u8 channels)\r\n{\r\nstream->request.pcm_params.num_chan = channels;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_set_rate(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nunsigned int rate)\r\n{\r\nstream->request.pcm_params.sfreq = rate;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_type(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nint codec_type, int stream_type, int operation)\r\n{\r\nstream->request.str_type.codec_type = codec_type;\r\nstream->request.str_type.str_type = stream_type;\r\nstream->request.str_type.operation = operation;\r\nstream->request.str_type.time_slots = 0xc;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_buffer(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nuint32_t buffer_addr, uint32_t buffer_size)\r\n{\r\nstream->request.frame_info.num_entries = 1;\r\nstream->request.frame_info.ring_buf_info[0].addr = buffer_addr;\r\nstream->request.frame_info.ring_buf_info[0].size = buffer_size;\r\nstream->request.frame_info.frag_size =\r\nstream->request.pcm_params.sfreq *\r\nstream->request.pcm_params.num_chan *\r\nstream->request.pcm_params.pcm_wd_sz / 8 *\r\n4 / 1000;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_commit(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nstruct sst_byt_alloc_params *str_req = &stream->request;\r\nstruct sst_byt_alloc_response *reply = &stream->reply;\r\nu64 header;\r\nint ret;\r\nheader = sst_byt_header(IPC_IA_ALLOC_STREAM,\r\nsizeof(*str_req) + sizeof(u32),\r\ntrue, stream->str_id);\r\nret = sst_ipc_tx_message_wait(&byt->ipc, header, str_req,\r\nsizeof(*str_req),\r\nreply, sizeof(*reply));\r\nif (ret < 0) {\r\ndev_err(byt->dev, "ipc: error stream commit failed\n");\r\nreturn ret;\r\n}\r\nstream->commited = true;\r\nreturn 0;\r\n}\r\nint sst_byt_stream_free(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nu64 header;\r\nint ret = 0;\r\nstruct sst_dsp *sst = byt->dsp;\r\nunsigned long flags;\r\nif (!stream->commited)\r\ngoto out;\r\nheader = sst_byt_header(IPC_IA_FREE_STREAM, 0, false, stream->str_id);\r\nret = sst_ipc_tx_message_wait(&byt->ipc, header, NULL, 0, NULL, 0);\r\nif (ret < 0) {\r\ndev_err(byt->dev, "ipc: free stream %d failed\n",\r\nstream->str_id);\r\nreturn -EAGAIN;\r\n}\r\nstream->commited = false;\r\nout:\r\nspin_lock_irqsave(&sst->spinlock, flags);\r\nlist_del(&stream->node);\r\nkfree(stream);\r\nspin_unlock_irqrestore(&sst->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int sst_byt_stream_operations(struct sst_byt *byt, int type,\r\nint stream_id, int wait)\r\n{\r\nu64 header;\r\nheader = sst_byt_header(type, 0, false, stream_id);\r\nif (wait)\r\nreturn sst_ipc_tx_message_wait(&byt->ipc, header, NULL,\r\n0, NULL, 0);\r\nelse\r\nreturn sst_ipc_tx_message_nowait(&byt->ipc, header,\r\nNULL, 0);\r\n}\r\nint sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream,\r\nu32 start_offset)\r\n{\r\nstruct sst_byt_start_stream_params start_stream;\r\nvoid *tx_msg;\r\nsize_t size;\r\nu64 header;\r\nint ret;\r\nstart_stream.byte_offset = start_offset;\r\nheader = sst_byt_header(IPC_IA_START_STREAM,\r\nsizeof(start_stream) + sizeof(u32),\r\ntrue, stream->str_id);\r\ntx_msg = &start_stream;\r\nsize = sizeof(start_stream);\r\nret = sst_ipc_tx_message_nowait(&byt->ipc, header, tx_msg, size);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to start stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_stream_stop(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nint ret;\r\nif (!stream->commited)\r\nreturn 0;\r\nret = sst_byt_stream_operations(byt, IPC_IA_DROP_STREAM,\r\nstream->str_id, 0);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to stop stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_stream_pause(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nint ret;\r\nret = sst_byt_stream_operations(byt, IPC_IA_PAUSE_STREAM,\r\nstream->str_id, 0);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to pause stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_stream_resume(struct sst_byt *byt, struct sst_byt_stream *stream)\r\n{\r\nint ret;\r\nret = sst_byt_stream_operations(byt, IPC_IA_RESUME_STREAM,\r\nstream->str_id, 0);\r\nif (ret < 0)\r\ndev_err(byt->dev, "ipc: error failed to resume stream %d\n",\r\nstream->str_id);\r\nreturn ret;\r\n}\r\nint sst_byt_get_dsp_position(struct sst_byt *byt,\r\nstruct sst_byt_stream *stream, int buffer_size)\r\n{\r\nstruct sst_dsp *sst = byt->dsp;\r\nstruct sst_byt_tstamp fw_tstamp;\r\nu8 str_id = stream->str_id;\r\nu32 tstamp_offset;\r\ntstamp_offset = SST_BYT_TIMESTAMP_OFFSET + str_id * sizeof(fw_tstamp);\r\nmemcpy_fromio(&fw_tstamp,\r\nsst->addr.lpe + tstamp_offset, sizeof(fw_tstamp));\r\nreturn do_div(fw_tstamp.ring_buffer_counter, buffer_size);\r\n}\r\nstruct sst_dsp *sst_byt_get_dsp(struct sst_byt *byt)\r\n{\r\nreturn byt->dsp;\r\n}\r\nint sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\ndev_dbg(byt->dev, "dsp reset\n");\r\nsst_dsp_reset(byt->dsp);\r\nsst_ipc_drop_all(&byt->ipc);\r\ndev_dbg(byt->dev, "dsp in reset\n");\r\ndev_dbg(byt->dev, "free all blocks and unload fw\n");\r\nsst_fw_unload(byt->fw);\r\nreturn 0;\r\n}\r\nint sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\nint ret;\r\ndev_dbg(byt->dev, "reload dsp fw\n");\r\nsst_dsp_reset(byt->dsp);\r\nret = sst_fw_reload(byt->fw);\r\nif (ret < 0) {\r\ndev_err(dev, "error: failed to reload firmware\n");\r\nreturn ret;\r\n}\r\nbyt->boot_complete = false;\r\nsst_dsp_boot(byt->dsp);\r\ndev_dbg(byt->dev, "dsp booting...\n");\r\nreturn 0;\r\n}\r\nint sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\nint err;\r\ndev_dbg(byt->dev, "wait for dsp reboot\n");\r\nerr = wait_event_timeout(byt->boot_wait, byt->boot_complete,\r\nmsecs_to_jiffies(IPC_BOOT_MSECS));\r\nif (err == 0) {\r\ndev_err(byt->dev, "ipc: error DSP boot timeout\n");\r\nreturn -EIO;\r\n}\r\ndev_dbg(byt->dev, "dsp rebooted\n");\r\nreturn 0;\r\n}\r\nstatic void byt_tx_msg(struct sst_generic_ipc *ipc, struct ipc_message *msg)\r\n{\r\nif (msg->header & IPC_HEADER_LARGE(true))\r\nsst_dsp_outbox_write(ipc->dsp, msg->tx_data, msg->tx_size);\r\nsst_dsp_shim_write64_unlocked(ipc->dsp, SST_IPCX, msg->header);\r\n}\r\nstatic void byt_shim_dbg(struct sst_generic_ipc *ipc, const char *text)\r\n{\r\nstruct sst_dsp *sst = ipc->dsp;\r\nu64 isr, ipcd, imrx, ipcx;\r\nipcx = sst_dsp_shim_read64_unlocked(sst, SST_IPCX);\r\nisr = sst_dsp_shim_read64_unlocked(sst, SST_ISRX);\r\nipcd = sst_dsp_shim_read64_unlocked(sst, SST_IPCD);\r\nimrx = sst_dsp_shim_read64_unlocked(sst, SST_IMRX);\r\ndev_err(ipc->dev,\r\n"ipc: --%s-- ipcx 0x%llx isr 0x%llx ipcd 0x%llx imrx 0x%llx\n",\r\ntext, ipcx, isr, ipcd, imrx);\r\n}\r\nstatic void byt_tx_data_copy(struct ipc_message *msg, char *tx_data,\r\nsize_t tx_size)\r\n{\r\n*(u32 *)msg->tx_data = (u32)(msg->header & (u32)-1);\r\nmemcpy(msg->tx_data + sizeof(u32), tx_data, tx_size);\r\nmsg->tx_size += sizeof(u32);\r\n}\r\nstatic u64 byt_reply_msg_match(u64 header, u64 *mask)\r\n{\r\n*mask = IPC_HEADER_MSG_ID_MASK |\r\nIPC_HEADER_STR_ID_MASK << IPC_HEADER_STR_ID_SHIFT;\r\nheader &= *mask;\r\nreturn header;\r\n}\r\nstatic bool byt_is_dsp_busy(struct sst_dsp *dsp)\r\n{\r\nu64 ipcx;\r\nipcx = sst_dsp_shim_read_unlocked(dsp, SST_IPCX);\r\nreturn (ipcx & (SST_IPCX_BUSY | SST_IPCX_DONE));\r\n}\r\nint sst_byt_dsp_init(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt;\r\nstruct sst_generic_ipc *ipc;\r\nstruct sst_fw *byt_sst_fw;\r\nstruct sst_byt_fw_init init;\r\nint err;\r\ndev_dbg(dev, "initialising Byt DSP IPC\n");\r\nbyt = devm_kzalloc(dev, sizeof(*byt), GFP_KERNEL);\r\nif (byt == NULL)\r\nreturn -ENOMEM;\r\nbyt->dev = dev;\r\nipc = &byt->ipc;\r\nipc->dev = dev;\r\nipc->ops.tx_msg = byt_tx_msg;\r\nipc->ops.shim_dbg = byt_shim_dbg;\r\nipc->ops.tx_data_copy = byt_tx_data_copy;\r\nipc->ops.reply_msg_match = byt_reply_msg_match;\r\nipc->ops.is_dsp_busy = byt_is_dsp_busy;\r\nipc->tx_data_max_size = IPC_MAX_MAILBOX_BYTES;\r\nipc->rx_data_max_size = IPC_MAX_MAILBOX_BYTES;\r\nerr = sst_ipc_init(ipc);\r\nif (err != 0)\r\ngoto ipc_init_err;\r\nINIT_LIST_HEAD(&byt->stream_list);\r\ninit_waitqueue_head(&byt->boot_wait);\r\nbyt_dev.thread_context = byt;\r\nbyt->dsp = sst_dsp_new(dev, &byt_dev, pdata);\r\nif (byt->dsp == NULL) {\r\nerr = -ENODEV;\r\ngoto dsp_new_err;\r\n}\r\nipc->dsp = byt->dsp;\r\nsst_dsp_reset(byt->dsp);\r\nbyt_sst_fw = sst_fw_new(byt->dsp, pdata->fw, byt);\r\nif (byt_sst_fw == NULL) {\r\nerr = -ENODEV;\r\ndev_err(dev, "error: failed to load firmware\n");\r\ngoto fw_err;\r\n}\r\nsst_dsp_boot(byt->dsp);\r\nerr = wait_event_timeout(byt->boot_wait, byt->boot_complete,\r\nmsecs_to_jiffies(IPC_BOOT_MSECS));\r\nif (err == 0) {\r\nerr = -EIO;\r\ndev_err(byt->dev, "ipc: error DSP boot timeout\n");\r\ngoto boot_err;\r\n}\r\nsst_dsp_inbox_read(byt->dsp, &init, sizeof(init));\r\ndev_info(byt->dev, "FW version: %02x.%02x.%02x.%02x\n",\r\ninit.fw_version.major, init.fw_version.minor,\r\ninit.fw_version.build, init.fw_version.type);\r\ndev_info(byt->dev, "Build type: %x\n", init.fw_version.type);\r\ndev_info(byt->dev, "Build date: %s %s\n",\r\ninit.build_info.date, init.build_info.time);\r\npdata->dsp = byt;\r\nbyt->fw = byt_sst_fw;\r\nreturn 0;\r\nboot_err:\r\nsst_dsp_reset(byt->dsp);\r\nsst_fw_free(byt_sst_fw);\r\nfw_err:\r\nsst_dsp_free(byt->dsp);\r\ndsp_new_err:\r\nsst_ipc_fini(ipc);\r\nipc_init_err:\r\nreturn err;\r\n}\r\nvoid sst_byt_dsp_free(struct device *dev, struct sst_pdata *pdata)\r\n{\r\nstruct sst_byt *byt = pdata->dsp;\r\nsst_dsp_reset(byt->dsp);\r\nsst_fw_free_all(byt->dsp);\r\nsst_dsp_free(byt->dsp);\r\nsst_ipc_fini(&byt->ipc);\r\n}
