static u32\r\nnetxen_poll_rsp(struct netxen_adapter *adapter)\r\n{\r\nu32 rsp = NX_CDRP_RSP_OK;\r\nint timeout = 0;\r\ndo {\r\nmsleep(1);\r\nif (++timeout > NX_OS_CRB_RETRY_COUNT)\r\nreturn NX_CDRP_RSP_TIMEOUT;\r\nrsp = NXRD32(adapter, NX_CDRP_CRB_OFFSET);\r\n} while (!NX_CDRP_IS_RSP(rsp));\r\nreturn rsp;\r\n}\r\nstatic u32\r\nnetxen_issue_cmd(struct netxen_adapter *adapter, struct netxen_cmd_args *cmd)\r\n{\r\nu32 rsp;\r\nu32 signature = 0;\r\nu32 rcode = NX_RCODE_SUCCESS;\r\nsignature = NX_CDRP_SIGNATURE_MAKE(adapter->ahw.pci_func,\r\nNXHAL_VERSION);\r\nif (netxen_api_lock(adapter))\r\nreturn NX_RCODE_TIMEOUT;\r\nNXWR32(adapter, NX_SIGN_CRB_OFFSET, signature);\r\nNXWR32(adapter, NX_ARG1_CRB_OFFSET, cmd->req.arg1);\r\nNXWR32(adapter, NX_ARG2_CRB_OFFSET, cmd->req.arg2);\r\nNXWR32(adapter, NX_ARG3_CRB_OFFSET, cmd->req.arg3);\r\nNXWR32(adapter, NX_CDRP_CRB_OFFSET, NX_CDRP_FORM_CMD(cmd->req.cmd));\r\nrsp = netxen_poll_rsp(adapter);\r\nif (rsp == NX_CDRP_RSP_TIMEOUT) {\r\nprintk(KERN_ERR "%s: card response timeout.\n",\r\nnetxen_nic_driver_name);\r\nrcode = NX_RCODE_TIMEOUT;\r\n} else if (rsp == NX_CDRP_RSP_FAIL) {\r\nrcode = NXRD32(adapter, NX_ARG1_CRB_OFFSET);\r\nprintk(KERN_ERR "%s: failed card response code:0x%x\n",\r\nnetxen_nic_driver_name, rcode);\r\n} else if (rsp == NX_CDRP_RSP_OK) {\r\ncmd->rsp.cmd = NX_RCODE_SUCCESS;\r\nif (cmd->rsp.arg2)\r\ncmd->rsp.arg2 = NXRD32(adapter, NX_ARG2_CRB_OFFSET);\r\nif (cmd->rsp.arg3)\r\ncmd->rsp.arg3 = NXRD32(adapter, NX_ARG3_CRB_OFFSET);\r\n}\r\nif (cmd->rsp.arg1)\r\ncmd->rsp.arg1 = NXRD32(adapter, NX_ARG1_CRB_OFFSET);\r\nnetxen_api_unlock(adapter);\r\nreturn rcode;\r\n}\r\nstatic int\r\nnetxen_get_minidump_template_size(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = NX_CDRP_CMD_TEMP_SIZE;\r\nmemset(&cmd.rsp, 1, sizeof(struct _cdrp_cmd));\r\nnetxen_issue_cmd(adapter, &cmd);\r\nif (cmd.rsp.cmd != NX_RCODE_SUCCESS) {\r\ndev_info(&adapter->pdev->dev,\r\n"Can't get template size %d\n", cmd.rsp.cmd);\r\nreturn -EIO;\r\n}\r\nadapter->mdump.md_template_size = cmd.rsp.arg2;\r\nadapter->mdump.md_template_ver = cmd.rsp.arg3;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_get_minidump_template(struct netxen_adapter *adapter)\r\n{\r\ndma_addr_t md_template_addr;\r\nvoid *addr;\r\nu32 size;\r\nstruct netxen_cmd_args cmd;\r\nsize = adapter->mdump.md_template_size;\r\nif (size == 0) {\r\ndev_err(&adapter->pdev->dev, "Can not capture Minidump "\r\n"template. Invalid template size.\n");\r\nreturn NX_RCODE_INVALID_ARGS;\r\n}\r\naddr = pci_zalloc_consistent(adapter->pdev, size, &md_template_addr);\r\nif (!addr) {\r\ndev_err(&adapter->pdev->dev, "Unable to allocate dmable memory for template.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\nmemset(&cmd.rsp, 1, sizeof(struct _cdrp_cmd));\r\ncmd.req.cmd = NX_CDRP_CMD_GET_TEMP_HDR;\r\ncmd.req.arg1 = LSD(md_template_addr);\r\ncmd.req.arg2 = MSD(md_template_addr);\r\ncmd.req.arg3 |= size;\r\nnetxen_issue_cmd(adapter, &cmd);\r\nif ((cmd.rsp.cmd == NX_RCODE_SUCCESS) && (size == cmd.rsp.arg2)) {\r\nmemcpy(adapter->mdump.md_template, addr, size);\r\n} else {\r\ndev_err(&adapter->pdev->dev, "Failed to get minidump template, "\r\n"err_code : %d, requested_size : %d, actual_size : %d\n ",\r\ncmd.rsp.cmd, size, cmd.rsp.arg2);\r\n}\r\npci_free_consistent(adapter->pdev, size, addr, md_template_addr);\r\nreturn 0;\r\n}\r\nstatic u32\r\nnetxen_check_template_checksum(struct netxen_adapter *adapter)\r\n{\r\nu64 sum = 0 ;\r\nu32 *buff = adapter->mdump.md_template;\r\nint count = adapter->mdump.md_template_size/sizeof(uint32_t) ;\r\nwhile (count-- > 0)\r\nsum += *buff++ ;\r\nwhile (sum >> 32)\r\nsum = (sum & 0xFFFFFFFF) + (sum >> 32) ;\r\nreturn ~sum;\r\n}\r\nint\r\nnetxen_setup_minidump(struct netxen_adapter *adapter)\r\n{\r\nint err = 0, i;\r\nu32 *template, *tmp_buf;\r\nstruct netxen_minidump_template_hdr *hdr;\r\nerr = netxen_get_minidump_template_size(adapter);\r\nif (err) {\r\nadapter->mdump.fw_supports_md = 0;\r\nif ((err == NX_RCODE_CMD_INVALID) ||\r\n(err == NX_RCODE_CMD_NOT_IMPL)) {\r\ndev_info(&adapter->pdev->dev,\r\n"Flashed firmware version does not support minidump, "\r\n"minimum version required is [ %u.%u.%u ].\n ",\r\nNX_MD_SUPPORT_MAJOR, NX_MD_SUPPORT_MINOR,\r\nNX_MD_SUPPORT_SUBVERSION);\r\n}\r\nreturn err;\r\n}\r\nif (!adapter->mdump.md_template_size) {\r\ndev_err(&adapter->pdev->dev, "Error : Invalid template size "\r\n",should be non-zero.\n");\r\nreturn -EIO;\r\n}\r\nadapter->mdump.md_template =\r\nkmalloc(adapter->mdump.md_template_size, GFP_KERNEL);\r\nif (!adapter->mdump.md_template)\r\nreturn -ENOMEM;\r\nerr = netxen_get_minidump_template(adapter);\r\nif (err) {\r\nif (err == NX_RCODE_CMD_NOT_IMPL)\r\nadapter->mdump.fw_supports_md = 0;\r\ngoto free_template;\r\n}\r\nif (netxen_check_template_checksum(adapter)) {\r\ndev_err(&adapter->pdev->dev, "Minidump template checksum Error\n");\r\nerr = -EIO;\r\ngoto free_template;\r\n}\r\nadapter->mdump.md_capture_mask = NX_DUMP_MASK_DEF;\r\ntmp_buf = (u32 *) adapter->mdump.md_template;\r\ntemplate = (u32 *) adapter->mdump.md_template;\r\nfor (i = 0; i < adapter->mdump.md_template_size/sizeof(u32); i++)\r\n*template++ = __le32_to_cpu(*tmp_buf++);\r\nhdr = (struct netxen_minidump_template_hdr *)\r\nadapter->mdump.md_template;\r\nadapter->mdump.md_capture_buff = NULL;\r\nadapter->mdump.fw_supports_md = 1;\r\nadapter->mdump.md_enabled = 0;\r\nreturn err;\r\nfree_template:\r\nkfree(adapter->mdump.md_template);\r\nadapter->mdump.md_template = NULL;\r\nreturn err;\r\n}\r\nint\r\nnx_fw_cmd_set_mtu(struct netxen_adapter *adapter, int mtu)\r\n{\r\nu32 rcode = NX_RCODE_SUCCESS;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = NX_CDRP_CMD_SET_MTU;\r\ncmd.req.arg1 = recv_ctx->context_id;\r\ncmd.req.arg2 = mtu;\r\ncmd.req.arg3 = 0;\r\nif (recv_ctx->state == NX_HOST_CTX_STATE_ACTIVE)\r\nnetxen_issue_cmd(adapter, &cmd);\r\nif (rcode != NX_RCODE_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint\r\nnx_fw_cmd_set_gbe_port(struct netxen_adapter *adapter,\r\nu32 speed, u32 duplex, u32 autoneg)\r\n{\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.cmd = NX_CDRP_CMD_CONFIG_GBE_PORT;\r\ncmd.req.arg1 = speed;\r\ncmd.req.arg2 = duplex;\r\ncmd.req.arg3 = autoneg;\r\nreturn netxen_issue_cmd(adapter, &cmd);\r\n}\r\nstatic int\r\nnx_fw_cmd_create_rx_ctx(struct netxen_adapter *adapter)\r\n{\r\nvoid *addr;\r\nnx_hostrq_rx_ctx_t *prq;\r\nnx_cardrsp_rx_ctx_t *prsp;\r\nnx_hostrq_rds_ring_t *prq_rds;\r\nnx_hostrq_sds_ring_t *prq_sds;\r\nnx_cardrsp_rds_ring_t *prsp_rds;\r\nnx_cardrsp_sds_ring_t *prsp_sds;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct netxen_cmd_args cmd;\r\ndma_addr_t hostrq_phys_addr, cardrsp_phys_addr;\r\nu64 phys_addr;\r\nint i, nrds_rings, nsds_rings;\r\nsize_t rq_size, rsp_size;\r\nu32 cap, reg, val;\r\nint err;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nnrds_rings = adapter->max_rds_rings;\r\nnsds_rings = adapter->max_sds_rings;\r\nrq_size =\r\nSIZEOF_HOSTRQ_RX(nx_hostrq_rx_ctx_t, nrds_rings, nsds_rings);\r\nrsp_size =\r\nSIZEOF_CARDRSP_RX(nx_cardrsp_rx_ctx_t, nrds_rings, nsds_rings);\r\naddr = pci_alloc_consistent(adapter->pdev,\r\nrq_size, &hostrq_phys_addr);\r\nif (addr == NULL)\r\nreturn -ENOMEM;\r\nprq = addr;\r\naddr = pci_alloc_consistent(adapter->pdev,\r\nrsp_size, &cardrsp_phys_addr);\r\nif (addr == NULL) {\r\nerr = -ENOMEM;\r\ngoto out_free_rq;\r\n}\r\nprsp = addr;\r\nprq->host_rsp_dma_addr = cpu_to_le64(cardrsp_phys_addr);\r\ncap = (NX_CAP0_LEGACY_CONTEXT | NX_CAP0_LEGACY_MN);\r\ncap |= (NX_CAP0_JUMBO_CONTIGUOUS | NX_CAP0_LRO_CONTIGUOUS);\r\nif (adapter->flags & NETXEN_FW_MSS_CAP)\r\ncap |= NX_CAP0_HW_LRO_MSS;\r\nprq->capabilities[0] = cpu_to_le32(cap);\r\nprq->host_int_crb_mode =\r\ncpu_to_le32(NX_HOST_INT_CRB_MODE_SHARED);\r\nprq->host_rds_crb_mode =\r\ncpu_to_le32(NX_HOST_RDS_CRB_MODE_UNIQUE);\r\nprq->num_rds_rings = cpu_to_le16(nrds_rings);\r\nprq->num_sds_rings = cpu_to_le16(nsds_rings);\r\nprq->rds_ring_offset = cpu_to_le32(0);\r\nval = le32_to_cpu(prq->rds_ring_offset) +\r\n(sizeof(nx_hostrq_rds_ring_t) * nrds_rings);\r\nprq->sds_ring_offset = cpu_to_le32(val);\r\nprq_rds = (nx_hostrq_rds_ring_t *)(prq->data +\r\nle32_to_cpu(prq->rds_ring_offset));\r\nfor (i = 0; i < nrds_rings; i++) {\r\nrds_ring = &recv_ctx->rds_rings[i];\r\nprq_rds[i].host_phys_addr = cpu_to_le64(rds_ring->phys_addr);\r\nprq_rds[i].ring_size = cpu_to_le32(rds_ring->num_desc);\r\nprq_rds[i].ring_kind = cpu_to_le32(i);\r\nprq_rds[i].buff_size = cpu_to_le64(rds_ring->dma_size);\r\n}\r\nprq_sds = (nx_hostrq_sds_ring_t *)(prq->data +\r\nle32_to_cpu(prq->sds_ring_offset));\r\nfor (i = 0; i < nsds_rings; i++) {\r\nsds_ring = &recv_ctx->sds_rings[i];\r\nprq_sds[i].host_phys_addr = cpu_to_le64(sds_ring->phys_addr);\r\nprq_sds[i].ring_size = cpu_to_le32(sds_ring->num_desc);\r\nprq_sds[i].msi_index = cpu_to_le16(i);\r\n}\r\nphys_addr = hostrq_phys_addr;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = (u32)(phys_addr >> 32);\r\ncmd.req.arg2 = (u32)(phys_addr & 0xffffffff);\r\ncmd.req.arg3 = rq_size;\r\ncmd.req.cmd = NX_CDRP_CMD_CREATE_RX_CTX;\r\nerr = netxen_issue_cmd(adapter, &cmd);\r\nif (err) {\r\nprintk(KERN_WARNING\r\n"Failed to create rx ctx in firmware%d\n", err);\r\ngoto out_free_rsp;\r\n}\r\nprsp_rds = ((nx_cardrsp_rds_ring_t *)\r\n&prsp->data[le32_to_cpu(prsp->rds_ring_offset)]);\r\nfor (i = 0; i < le16_to_cpu(prsp->num_rds_rings); i++) {\r\nrds_ring = &recv_ctx->rds_rings[i];\r\nreg = le32_to_cpu(prsp_rds[i].host_producer_crb);\r\nrds_ring->crb_rcv_producer = netxen_get_ioaddr(adapter,\r\nNETXEN_NIC_REG(reg - 0x200));\r\n}\r\nprsp_sds = ((nx_cardrsp_sds_ring_t *)\r\n&prsp->data[le32_to_cpu(prsp->sds_ring_offset)]);\r\nfor (i = 0; i < le16_to_cpu(prsp->num_sds_rings); i++) {\r\nsds_ring = &recv_ctx->sds_rings[i];\r\nreg = le32_to_cpu(prsp_sds[i].host_consumer_crb);\r\nsds_ring->crb_sts_consumer = netxen_get_ioaddr(adapter,\r\nNETXEN_NIC_REG(reg - 0x200));\r\nreg = le32_to_cpu(prsp_sds[i].interrupt_crb);\r\nsds_ring->crb_intr_mask = netxen_get_ioaddr(adapter,\r\nNETXEN_NIC_REG(reg - 0x200));\r\n}\r\nrecv_ctx->state = le32_to_cpu(prsp->host_ctx_state);\r\nrecv_ctx->context_id = le16_to_cpu(prsp->context_id);\r\nrecv_ctx->virt_port = prsp->virt_port;\r\nout_free_rsp:\r\npci_free_consistent(adapter->pdev, rsp_size, prsp, cardrsp_phys_addr);\r\nout_free_rq:\r\npci_free_consistent(adapter->pdev, rq_size, prq, hostrq_phys_addr);\r\nreturn err;\r\n}\r\nstatic void\r\nnx_fw_cmd_destroy_rx_ctx(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = recv_ctx->context_id;\r\ncmd.req.arg2 = NX_DESTROY_CTX_RESET;\r\ncmd.req.arg3 = 0;\r\ncmd.req.cmd = NX_CDRP_CMD_DESTROY_RX_CTX;\r\nif (netxen_issue_cmd(adapter, &cmd)) {\r\nprintk(KERN_WARNING\r\n"%s: Failed to destroy rx ctx in firmware\n",\r\nnetxen_nic_driver_name);\r\n}\r\n}\r\nstatic int\r\nnx_fw_cmd_create_tx_ctx(struct netxen_adapter *adapter)\r\n{\r\nnx_hostrq_tx_ctx_t *prq;\r\nnx_hostrq_cds_ring_t *prq_cds;\r\nnx_cardrsp_tx_ctx_t *prsp;\r\nvoid *rq_addr, *rsp_addr;\r\nsize_t rq_size, rsp_size;\r\nu32 temp;\r\nint err = 0;\r\nu64 offset, phys_addr;\r\ndma_addr_t rq_phys_addr, rsp_phys_addr;\r\nstruct nx_host_tx_ring *tx_ring = adapter->tx_ring;\r\nstruct netxen_recv_context *recv_ctx = &adapter->recv_ctx;\r\nstruct netxen_cmd_args cmd;\r\nrq_size = SIZEOF_HOSTRQ_TX(nx_hostrq_tx_ctx_t);\r\nrq_addr = pci_alloc_consistent(adapter->pdev,\r\nrq_size, &rq_phys_addr);\r\nif (!rq_addr)\r\nreturn -ENOMEM;\r\nrsp_size = SIZEOF_CARDRSP_TX(nx_cardrsp_tx_ctx_t);\r\nrsp_addr = pci_alloc_consistent(adapter->pdev,\r\nrsp_size, &rsp_phys_addr);\r\nif (!rsp_addr) {\r\nerr = -ENOMEM;\r\ngoto out_free_rq;\r\n}\r\nmemset(rq_addr, 0, rq_size);\r\nprq = rq_addr;\r\nmemset(rsp_addr, 0, rsp_size);\r\nprsp = rsp_addr;\r\nprq->host_rsp_dma_addr = cpu_to_le64(rsp_phys_addr);\r\ntemp = (NX_CAP0_LEGACY_CONTEXT | NX_CAP0_LEGACY_MN | NX_CAP0_LSO);\r\nprq->capabilities[0] = cpu_to_le32(temp);\r\nprq->host_int_crb_mode =\r\ncpu_to_le32(NX_HOST_INT_CRB_MODE_SHARED);\r\nprq->interrupt_ctl = 0;\r\nprq->msi_index = 0;\r\nprq->dummy_dma_addr = cpu_to_le64(adapter->dummy_dma.phys_addr);\r\noffset = recv_ctx->phys_addr + sizeof(struct netxen_ring_ctx);\r\nprq->cmd_cons_dma_addr = cpu_to_le64(offset);\r\nprq_cds = &prq->cds_ring;\r\nprq_cds->host_phys_addr = cpu_to_le64(tx_ring->phys_addr);\r\nprq_cds->ring_size = cpu_to_le32(tx_ring->num_desc);\r\nphys_addr = rq_phys_addr;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = (u32)(phys_addr >> 32);\r\ncmd.req.arg2 = ((u32)phys_addr & 0xffffffff);\r\ncmd.req.arg3 = rq_size;\r\ncmd.req.cmd = NX_CDRP_CMD_CREATE_TX_CTX;\r\nerr = netxen_issue_cmd(adapter, &cmd);\r\nif (err == NX_RCODE_SUCCESS) {\r\ntemp = le32_to_cpu(prsp->cds_ring.host_producer_crb);\r\ntx_ring->crb_cmd_producer = netxen_get_ioaddr(adapter,\r\nNETXEN_NIC_REG(temp - 0x200));\r\n#if 0\r\nadapter->tx_state =\r\nle32_to_cpu(prsp->host_ctx_state);\r\n#endif\r\nadapter->tx_context_id =\r\nle16_to_cpu(prsp->context_id);\r\n} else {\r\nprintk(KERN_WARNING\r\n"Failed to create tx ctx in firmware%d\n", err);\r\nerr = -EIO;\r\n}\r\npci_free_consistent(adapter->pdev, rsp_size, rsp_addr, rsp_phys_addr);\r\nout_free_rq:\r\npci_free_consistent(adapter->pdev, rq_size, rq_addr, rq_phys_addr);\r\nreturn err;\r\n}\r\nstatic void\r\nnx_fw_cmd_destroy_tx_ctx(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = adapter->tx_context_id;\r\ncmd.req.arg2 = NX_DESTROY_CTX_RESET;\r\ncmd.req.arg3 = 0;\r\ncmd.req.cmd = NX_CDRP_CMD_DESTROY_TX_CTX;\r\nif (netxen_issue_cmd(adapter, &cmd)) {\r\nprintk(KERN_WARNING\r\n"%s: Failed to destroy tx ctx in firmware\n",\r\nnetxen_nic_driver_name);\r\n}\r\n}\r\nint\r\nnx_fw_cmd_query_phy(struct netxen_adapter *adapter, u32 reg, u32 *val)\r\n{\r\nu32 rcode;\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = reg;\r\ncmd.req.arg2 = 0;\r\ncmd.req.arg3 = 0;\r\ncmd.req.cmd = NX_CDRP_CMD_READ_PHY;\r\ncmd.rsp.arg1 = 1;\r\nrcode = netxen_issue_cmd(adapter, &cmd);\r\nif (rcode != NX_RCODE_SUCCESS)\r\nreturn -EIO;\r\nif (val == NULL)\r\nreturn -EIO;\r\n*val = cmd.rsp.arg1;\r\nreturn 0;\r\n}\r\nint\r\nnx_fw_cmd_set_phy(struct netxen_adapter *adapter, u32 reg, u32 val)\r\n{\r\nu32 rcode;\r\nstruct netxen_cmd_args cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.req.arg1 = reg;\r\ncmd.req.arg2 = val;\r\ncmd.req.arg3 = 0;\r\ncmd.req.cmd = NX_CDRP_CMD_WRITE_PHY;\r\nrcode = netxen_issue_cmd(adapter, &cmd);\r\nif (rcode != NX_RCODE_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nnetxen_init_old_ctx(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_recv_context *recv_ctx;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct nx_host_tx_ring *tx_ring;\r\nint ring;\r\nint port = adapter->portnum;\r\nstruct netxen_ring_ctx *hwctx;\r\nu32 signature;\r\ntx_ring = adapter->tx_ring;\r\nrecv_ctx = &adapter->recv_ctx;\r\nhwctx = recv_ctx->hwctx;\r\nhwctx->cmd_ring_addr = cpu_to_le64(tx_ring->phys_addr);\r\nhwctx->cmd_ring_size = cpu_to_le32(tx_ring->num_desc);\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nhwctx->rcv_rings[ring].addr =\r\ncpu_to_le64(rds_ring->phys_addr);\r\nhwctx->rcv_rings[ring].size =\r\ncpu_to_le32(rds_ring->num_desc);\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nif (ring == 0) {\r\nhwctx->sts_ring_addr = cpu_to_le64(sds_ring->phys_addr);\r\nhwctx->sts_ring_size = cpu_to_le32(sds_ring->num_desc);\r\n}\r\nhwctx->sts_rings[ring].addr = cpu_to_le64(sds_ring->phys_addr);\r\nhwctx->sts_rings[ring].size = cpu_to_le32(sds_ring->num_desc);\r\nhwctx->sts_rings[ring].msi_index = cpu_to_le16(ring);\r\n}\r\nhwctx->sts_ring_count = cpu_to_le32(adapter->max_sds_rings);\r\nsignature = (adapter->max_sds_rings > 1) ?\r\nNETXEN_CTX_SIGNATURE_V2 : NETXEN_CTX_SIGNATURE;\r\nNXWR32(adapter, CRB_CTX_ADDR_REG_LO(port),\r\nlower32(recv_ctx->phys_addr));\r\nNXWR32(adapter, CRB_CTX_ADDR_REG_HI(port),\r\nupper32(recv_ctx->phys_addr));\r\nNXWR32(adapter, CRB_CTX_SIGNATURE_REG(port),\r\nsignature | port);\r\nreturn 0;\r\n}\r\nint netxen_alloc_hw_resources(struct netxen_adapter *adapter)\r\n{\r\nvoid *addr;\r\nint err = 0;\r\nint ring;\r\nstruct netxen_recv_context *recv_ctx;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct nx_host_tx_ring *tx_ring;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct net_device *netdev = adapter->netdev;\r\nint port = adapter->portnum;\r\nrecv_ctx = &adapter->recv_ctx;\r\ntx_ring = adapter->tx_ring;\r\naddr = pci_alloc_consistent(pdev,\r\nsizeof(struct netxen_ring_ctx) + sizeof(uint32_t),\r\n&recv_ctx->phys_addr);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate hw context\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(addr, 0, sizeof(struct netxen_ring_ctx));\r\nrecv_ctx->hwctx = addr;\r\nrecv_ctx->hwctx->ctx_id = cpu_to_le32(port);\r\nrecv_ctx->hwctx->cmd_consumer_offset =\r\ncpu_to_le64(recv_ctx->phys_addr +\r\nsizeof(struct netxen_ring_ctx));\r\ntx_ring->hw_consumer =\r\n(__le32 *)(((char *)addr) + sizeof(struct netxen_ring_ctx));\r\naddr = pci_alloc_consistent(pdev, TX_DESC_RINGSIZE(tx_ring),\r\n&tx_ring->phys_addr);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev, "%s: failed to allocate tx desc ring\n",\r\nnetdev->name);\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\ntx_ring->desc_head = addr;\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\naddr = pci_alloc_consistent(adapter->pdev,\r\nRCV_DESC_RINGSIZE(rds_ring),\r\n&rds_ring->phys_addr);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev,\r\n"%s: failed to allocate rds ring [%d]\n",\r\nnetdev->name, ring);\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nrds_ring->desc_head = addr;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id))\r\nrds_ring->crb_rcv_producer =\r\nnetxen_get_ioaddr(adapter,\r\nrecv_crb_registers[port].crb_rcv_producer[ring]);\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\naddr = pci_alloc_consistent(adapter->pdev,\r\nSTATUS_DESC_RINGSIZE(sds_ring),\r\n&sds_ring->phys_addr);\r\nif (addr == NULL) {\r\ndev_err(&pdev->dev,\r\n"%s: failed to allocate sds ring [%d]\n",\r\nnetdev->name, ring);\r\nerr = -ENOMEM;\r\ngoto err_out_free;\r\n}\r\nsds_ring->desc_head = addr;\r\nif (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nsds_ring->crb_sts_consumer =\r\nnetxen_get_ioaddr(adapter,\r\nrecv_crb_registers[port].crb_sts_consumer[ring]);\r\nsds_ring->crb_intr_mask =\r\nnetxen_get_ioaddr(adapter,\r\nrecv_crb_registers[port].sw_int_mask[ring]);\r\n}\r\n}\r\nif (!NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nif (test_and_set_bit(__NX_FW_ATTACHED, &adapter->state))\r\ngoto done;\r\nerr = nx_fw_cmd_create_rx_ctx(adapter);\r\nif (err)\r\ngoto err_out_free;\r\nerr = nx_fw_cmd_create_tx_ctx(adapter);\r\nif (err)\r\ngoto err_out_free;\r\n} else {\r\nerr = netxen_init_old_ctx(adapter);\r\nif (err)\r\ngoto err_out_free;\r\n}\r\ndone:\r\nreturn 0;\r\nerr_out_free:\r\nnetxen_free_hw_resources(adapter);\r\nreturn err;\r\n}\r\nvoid netxen_free_hw_resources(struct netxen_adapter *adapter)\r\n{\r\nstruct netxen_recv_context *recv_ctx;\r\nstruct nx_host_rds_ring *rds_ring;\r\nstruct nx_host_sds_ring *sds_ring;\r\nstruct nx_host_tx_ring *tx_ring;\r\nint ring;\r\nint port = adapter->portnum;\r\nif (!NX_IS_REVISION_P2(adapter->ahw.revision_id)) {\r\nif (!test_and_clear_bit(__NX_FW_ATTACHED, &adapter->state))\r\ngoto done;\r\nnx_fw_cmd_destroy_rx_ctx(adapter);\r\nnx_fw_cmd_destroy_tx_ctx(adapter);\r\n} else {\r\nnetxen_api_lock(adapter);\r\nNXWR32(adapter, CRB_CTX_SIGNATURE_REG(port),\r\nNETXEN_CTX_D3_RESET | port);\r\nnetxen_api_unlock(adapter);\r\n}\r\nmsleep(20);\r\ndone:\r\nrecv_ctx = &adapter->recv_ctx;\r\nif (recv_ctx->hwctx != NULL) {\r\npci_free_consistent(adapter->pdev,\r\nsizeof(struct netxen_ring_ctx) +\r\nsizeof(uint32_t),\r\nrecv_ctx->hwctx,\r\nrecv_ctx->phys_addr);\r\nrecv_ctx->hwctx = NULL;\r\n}\r\ntx_ring = adapter->tx_ring;\r\nif (tx_ring->desc_head != NULL) {\r\npci_free_consistent(adapter->pdev,\r\nTX_DESC_RINGSIZE(tx_ring),\r\ntx_ring->desc_head, tx_ring->phys_addr);\r\ntx_ring->desc_head = NULL;\r\n}\r\nfor (ring = 0; ring < adapter->max_rds_rings; ring++) {\r\nrds_ring = &recv_ctx->rds_rings[ring];\r\nif (rds_ring->desc_head != NULL) {\r\npci_free_consistent(adapter->pdev,\r\nRCV_DESC_RINGSIZE(rds_ring),\r\nrds_ring->desc_head,\r\nrds_ring->phys_addr);\r\nrds_ring->desc_head = NULL;\r\n}\r\n}\r\nfor (ring = 0; ring < adapter->max_sds_rings; ring++) {\r\nsds_ring = &recv_ctx->sds_rings[ring];\r\nif (sds_ring->desc_head != NULL) {\r\npci_free_consistent(adapter->pdev,\r\nSTATUS_DESC_RINGSIZE(sds_ring),\r\nsds_ring->desc_head,\r\nsds_ring->phys_addr);\r\nsds_ring->desc_head = NULL;\r\n}\r\n}\r\n}
