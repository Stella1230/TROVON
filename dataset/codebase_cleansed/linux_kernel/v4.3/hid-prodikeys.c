static ssize_t show_channel(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\ndbg_hid("pcmidi sysfs read channel=%u\n", pk->pm->midi_channel);\r\nreturn sprintf(buf, "%u (min:%u, max:%u)\n", pk->pm->midi_channel,\r\nPCMIDI_CHANNEL_MIN, PCMIDI_CHANNEL_MAX);\r\n}\r\nstatic ssize_t store_channel(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\nunsigned channel = 0;\r\nif (sscanf(buf, "%u", &channel) > 0 && channel <= PCMIDI_CHANNEL_MAX) {\r\ndbg_hid("pcmidi sysfs write channel=%u\n", channel);\r\npk->pm->midi_channel = channel;\r\nreturn strlen(buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t show_sustain(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\ndbg_hid("pcmidi sysfs read sustain=%u\n", pk->pm->midi_sustain);\r\nreturn sprintf(buf, "%u (off:%u, max:%u (ms))\n", pk->pm->midi_sustain,\r\nPCMIDI_SUSTAIN_MIN, PCMIDI_SUSTAIN_MAX);\r\n}\r\nstatic ssize_t store_sustain(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\nunsigned sustain = 0;\r\nif (sscanf(buf, "%u", &sustain) > 0 && sustain <= PCMIDI_SUSTAIN_MAX) {\r\ndbg_hid("pcmidi sysfs write sustain=%u\n", sustain);\r\npk->pm->midi_sustain = sustain;\r\npk->pm->midi_sustain_mode =\r\n(0 == sustain || !pk->pm->midi_mode) ? 0 : 1;\r\nreturn strlen(buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t show_octave(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\ndbg_hid("pcmidi sysfs read octave=%d\n", pk->pm->midi_octave);\r\nreturn sprintf(buf, "%d (min:%d, max:%d)\n", pk->pm->midi_octave,\r\nPCMIDI_OCTAVE_MIN, PCMIDI_OCTAVE_MAX);\r\n}\r\nstatic ssize_t store_octave(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\nint octave = 0;\r\nif (sscanf(buf, "%d", &octave) > 0 &&\r\noctave >= PCMIDI_OCTAVE_MIN && octave <= PCMIDI_OCTAVE_MAX) {\r\ndbg_hid("pcmidi sysfs write octave=%d\n", octave);\r\npk->pm->midi_octave = octave;\r\nreturn strlen(buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void pcmidi_send_note(struct pcmidi_snd *pm,\r\nunsigned char status, unsigned char note, unsigned char velocity)\r\n{\r\nunsigned long flags;\r\nunsigned char buffer[3];\r\nbuffer[0] = status;\r\nbuffer[1] = note;\r\nbuffer[2] = velocity;\r\nspin_lock_irqsave(&pm->rawmidi_in_lock, flags);\r\nif (!pm->in_substream)\r\ngoto drop_note;\r\nif (!test_bit(pm->in_substream->number, &pm->in_triggered))\r\ngoto drop_note;\r\nsnd_rawmidi_receive(pm->in_substream, buffer, 3);\r\ndrop_note:\r\nspin_unlock_irqrestore(&pm->rawmidi_in_lock, flags);\r\nreturn;\r\n}\r\nstatic void pcmidi_sustained_note_release(unsigned long data)\r\n{\r\nstruct pcmidi_sustain *pms = (struct pcmidi_sustain *)data;\r\npcmidi_send_note(pms->pm, pms->status, pms->note, pms->velocity);\r\npms->in_use = 0;\r\n}\r\nstatic void init_sustain_timers(struct pcmidi_snd *pm)\r\n{\r\nstruct pcmidi_sustain *pms;\r\nunsigned i;\r\nfor (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {\r\npms = &pm->sustained_notes[i];\r\npms->in_use = 0;\r\npms->pm = pm;\r\nsetup_timer(&pms->timer, pcmidi_sustained_note_release,\r\n(unsigned long)pms);\r\n}\r\n}\r\nstatic void stop_sustain_timers(struct pcmidi_snd *pm)\r\n{\r\nstruct pcmidi_sustain *pms;\r\nunsigned i;\r\nfor (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {\r\npms = &pm->sustained_notes[i];\r\npms->in_use = 1;\r\ndel_timer_sync(&pms->timer);\r\n}\r\n}\r\nstatic int pcmidi_get_output_report(struct pcmidi_snd *pm)\r\n{\r\nstruct hid_device *hdev = pm->pk->hdev;\r\nstruct hid_report *report;\r\nlist_for_each_entry(report,\r\n&hdev->report_enum[HID_OUTPUT_REPORT].report_list, list) {\r\nif (!(6 == report->id))\r\ncontinue;\r\nif (report->maxfield < 1) {\r\nhid_err(hdev, "output report is empty\n");\r\nbreak;\r\n}\r\nif (report->field[0]->report_count != 2) {\r\nhid_err(hdev, "field count too low\n");\r\nbreak;\r\n}\r\npm->pcmidi_report6 = report;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void pcmidi_submit_output_report(struct pcmidi_snd *pm, int state)\r\n{\r\nstruct hid_device *hdev = pm->pk->hdev;\r\nstruct hid_report *report = pm->pcmidi_report6;\r\nreport->field[0]->value[0] = 0x01;\r\nreport->field[0]->value[1] = state;\r\nhid_hw_request(hdev, report, HID_REQ_SET_REPORT);\r\n}\r\nstatic int pcmidi_handle_report1(struct pcmidi_snd *pm, u8 *data)\r\n{\r\nu32 bit_mask;\r\nbit_mask = data[1];\r\nbit_mask = (bit_mask << 8) | data[2];\r\nbit_mask = (bit_mask << 8) | data[3];\r\ndbg_hid("pcmidi mode: %d\n", pm->midi_mode);\r\nif (pm->midi_mode && bit_mask == 0x004000) {\r\npm->midi_octave--;\r\nif (pm->midi_octave < -2)\r\npm->midi_octave = -2;\r\ndbg_hid("pcmidi mode: %d octave: %d\n",\r\npm->midi_mode, pm->midi_octave);\r\nreturn 1;\r\n}\r\nelse if (pm->midi_mode && bit_mask == 0x000004) {\r\npm->midi_sustain_mode ^= 0x1;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcmidi_handle_report3(struct pcmidi_snd *pm, u8 *data, int size)\r\n{\r\nstruct pcmidi_sustain *pms;\r\nunsigned i, j;\r\nunsigned char status, note, velocity;\r\nunsigned num_notes = (size-1)/2;\r\nfor (j = 0; j < num_notes; j++) {\r\nnote = data[j*2+1];\r\nvelocity = data[j*2+2];\r\nif (note < 0x81) {\r\nstatus = 128 + 16 + pm->midi_channel;\r\nnote = note - 0x54 + PCMIDI_MIDDLE_C +\r\n(pm->midi_octave * 12);\r\nif (0 == velocity)\r\nvelocity = 1;\r\n} else {\r\nstatus = 128 + pm->midi_channel;\r\nnote = note - 0x94 + PCMIDI_MIDDLE_C +\r\n(pm->midi_octave*12);\r\nif (pm->midi_sustain_mode) {\r\nfor (i = 0; i < PCMIDI_SUSTAINED_MAX; i++) {\r\npms = &pm->sustained_notes[i];\r\nif (!pms->in_use) {\r\npms->status = status;\r\npms->note = note;\r\npms->velocity = velocity;\r\npms->in_use = 1;\r\nmod_timer(&pms->timer,\r\njiffies +\r\nmsecs_to_jiffies(pm->midi_sustain));\r\nreturn 1;\r\n}\r\n}\r\n}\r\n}\r\npcmidi_send_note(pm, status, note, velocity);\r\n}\r\nreturn 1;\r\n}\r\nstatic int pcmidi_handle_report4(struct pcmidi_snd *pm, u8 *data)\r\n{\r\nunsigned key;\r\nu32 bit_mask;\r\nu32 bit_index;\r\nbit_mask = data[1];\r\nbit_mask = (bit_mask << 8) | data[2];\r\nbit_mask = (bit_mask << 8) | data[3];\r\nfor (bit_index = 0; bit_index < 24; bit_index++) {\r\nif (!((0x01 << bit_index) & bit_mask)) {\r\ninput_event(pm->input_ep82, EV_KEY,\r\npm->last_key[bit_index], 0);\r\npm->last_key[bit_index] = 0;\r\n}\r\n}\r\nfor (bit_index = 0; bit_index < 24; bit_index++) {\r\nkey = 0;\r\nswitch ((0x01 << bit_index) & bit_mask) {\r\ncase 0x000010:\r\npm->fn_state ^= 0x000010;\r\nif (pm->fn_state)\r\npcmidi_submit_output_report(pm, 0xc5);\r\nelse\r\npcmidi_submit_output_report(pm, 0xc6);\r\ncontinue;\r\ncase 0x020000:\r\npcmidi_submit_output_report(pm, 0xc1);\r\npm->midi_mode ^= 0x01;\r\ndbg_hid("pcmidi mode: %d\n", pm->midi_mode);\r\ncontinue;\r\ncase 0x100000:\r\ndbg_hid("pcmidi mode: %d\n", pm->midi_mode);\r\nif (pm->midi_mode) {\r\npm->midi_octave++;\r\nif (pm->midi_octave > 2)\r\npm->midi_octave = 2;\r\ndbg_hid("pcmidi mode: %d octave: %d\n",\r\npm->midi_mode, pm->midi_octave);\r\ncontinue;\r\n} else\r\nkey = KEY_MESSENGER;\r\nbreak;\r\ncase 0x400000:\r\nkey = KEY_CALENDAR;\r\nbreak;\r\ncase 0x080000:\r\nkey = KEY_ADDRESSBOOK;\r\nbreak;\r\ncase 0x040000:\r\nkey = KEY_DOCUMENTS;\r\nbreak;\r\ncase 0x800000:\r\nkey = KEY_WORDPROCESSOR;\r\nbreak;\r\ncase 0x200000:\r\nkey = KEY_SPREADSHEET;\r\nbreak;\r\ncase 0x010000:\r\nkey = KEY_COFFEE;\r\nbreak;\r\ncase 0x000100:\r\nkey = KEY_HELP;\r\nbreak;\r\ncase 0x000200:\r\nkey = KEY_SEND;\r\nbreak;\r\ncase 0x000400:\r\nkey = KEY_REPLY;\r\nbreak;\r\ncase 0x000800:\r\nkey = KEY_FORWARDMAIL;\r\nbreak;\r\ncase 0x001000:\r\nkey = KEY_NEW;\r\nbreak;\r\ncase 0x002000:\r\nkey = KEY_OPEN;\r\nbreak;\r\ncase 0x004000:\r\nkey = KEY_CLOSE;\r\nbreak;\r\ncase 0x008000:\r\nkey = KEY_SAVE;\r\nbreak;\r\ncase 0x000001:\r\nkey = KEY_UNDO;\r\nbreak;\r\ncase 0x000002:\r\nkey = KEY_REDO;\r\nbreak;\r\ncase 0x000004:\r\nkey = KEY_SPELLCHECK;\r\nbreak;\r\ncase 0x000008:\r\nkey = KEY_PRINT;\r\nbreak;\r\n}\r\nif (key) {\r\ninput_event(pm->input_ep82, EV_KEY, key, 1);\r\npm->last_key[bit_index] = key;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int pcmidi_handle_report(\r\nstruct pcmidi_snd *pm, unsigned report_id, u8 *data, int size)\r\n{\r\nint ret = 0;\r\nswitch (report_id) {\r\ncase 0x01:\r\nret = pcmidi_handle_report1(pm, data);\r\nbreak;\r\ncase 0x03:\r\nret = pcmidi_handle_report3(pm, data, size);\r\nbreak;\r\ncase 0x04:\r\nret = pcmidi_handle_report4(pm, data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pcmidi_setup_extra_keys(\r\nstruct pcmidi_snd *pm, struct input_dev *input)\r\n{\r\nunsigned int keys[] = {\r\nKEY_FN,\r\nKEY_MESSENGER, KEY_CALENDAR,\r\nKEY_ADDRESSBOOK, KEY_DOCUMENTS,\r\nKEY_WORDPROCESSOR,\r\nKEY_SPREADSHEET,\r\nKEY_COFFEE,\r\nKEY_HELP, KEY_SEND,\r\nKEY_REPLY, KEY_FORWARDMAIL,\r\nKEY_NEW, KEY_OPEN,\r\nKEY_CLOSE, KEY_SAVE,\r\nKEY_UNDO, KEY_REDO,\r\nKEY_SPELLCHECK, KEY_PRINT,\r\n0\r\n};\r\nunsigned int *pkeys = &keys[0];\r\nunsigned short i;\r\nif (pm->ifnum != 1)\r\nreturn;\r\npm->input_ep82 = input;\r\nfor (i = 0; i < 24; i++)\r\npm->last_key[i] = 0;\r\nwhile (*pkeys != 0) {\r\nset_bit(*pkeys, pm->input_ep82->keybit);\r\n++pkeys;\r\n}\r\n}\r\nstatic int pcmidi_set_operational(struct pcmidi_snd *pm)\r\n{\r\nif (pm->ifnum != 1)\r\nreturn 0;\r\npcmidi_get_output_report(pm);\r\npcmidi_submit_output_report(pm, 0xc1);\r\nreturn 0;\r\n}\r\nstatic int pcmidi_snd_free(struct snd_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pcmidi_in_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct pcmidi_snd *pm = substream->rmidi->private_data;\r\ndbg_hid("pcmidi in open\n");\r\npm->in_substream = substream;\r\nreturn 0;\r\n}\r\nstatic int pcmidi_in_close(struct snd_rawmidi_substream *substream)\r\n{\r\ndbg_hid("pcmidi in close\n");\r\nreturn 0;\r\n}\r\nstatic void pcmidi_in_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct pcmidi_snd *pm = substream->rmidi->private_data;\r\ndbg_hid("pcmidi in trigger %d\n", up);\r\npm->in_triggered = up;\r\n}\r\nstatic int pcmidi_snd_initialise(struct pcmidi_snd *pm)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_rawmidi *rwmidi;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = pcmidi_snd_free,\r\n};\r\nif (pm->ifnum != 1)\r\nreturn 0;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pm->pk->hdev->dev, index[dev], id[dev],\r\nTHIS_MODULE, 0, &card);\r\nif (err < 0) {\r\npk_error("failed to create pc-midi sound card\n");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\npm->card = card;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, pm, &ops);\r\nif (err < 0) {\r\npk_error("failed to create pc-midi sound device: error %d\n",\r\nerr);\r\ngoto fail;\r\n}\r\nstrncpy(card->driver, shortname, sizeof(card->driver));\r\nstrncpy(card->shortname, shortname, sizeof(card->shortname));\r\nstrncpy(card->longname, longname, sizeof(card->longname));\r\nerr = snd_rawmidi_new(card, card->shortname, 0,\r\n0, 1, &rwmidi);\r\nif (err < 0) {\r\npk_error("failed to create pc-midi rawmidi device: error %d\n",\r\nerr);\r\ngoto fail;\r\n}\r\npm->rwmidi = rwmidi;\r\nstrncpy(rwmidi->name, card->shortname, sizeof(rwmidi->name));\r\nrwmidi->info_flags = SNDRV_RAWMIDI_INFO_INPUT;\r\nrwmidi->private_data = pm;\r\nsnd_rawmidi_set_ops(rwmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&pcmidi_in_ops);\r\nerr = device_create_file(&pm->pk->hdev->dev,\r\nsysfs_device_attr_channel);\r\nif (err < 0) {\r\npk_error("failed to create sysfs attribute channel: error %d\n",\r\nerr);\r\ngoto fail;\r\n}\r\nerr = device_create_file(&pm->pk->hdev->dev,\r\nsysfs_device_attr_sustain);\r\nif (err < 0) {\r\npk_error("failed to create sysfs attribute sustain: error %d\n",\r\nerr);\r\ngoto fail_attr_sustain;\r\n}\r\nerr = device_create_file(&pm->pk->hdev->dev,\r\nsysfs_device_attr_octave);\r\nif (err < 0) {\r\npk_error("failed to create sysfs attribute octave: error %d\n",\r\nerr);\r\ngoto fail_attr_octave;\r\n}\r\nspin_lock_init(&pm->rawmidi_in_lock);\r\ninit_sustain_timers(pm);\r\npcmidi_set_operational(pm);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\npk_error("failed to register pc-midi sound card: error %d\n",\r\nerr);\r\ngoto fail_register;\r\n}\r\ndbg_hid("pcmidi_snd_initialise finished ok\n");\r\nreturn 0;\r\nfail_register:\r\nstop_sustain_timers(pm);\r\ndevice_remove_file(&pm->pk->hdev->dev, sysfs_device_attr_octave);\r\nfail_attr_octave:\r\ndevice_remove_file(&pm->pk->hdev->dev, sysfs_device_attr_sustain);\r\nfail_attr_sustain:\r\ndevice_remove_file(&pm->pk->hdev->dev, sysfs_device_attr_channel);\r\nfail:\r\nif (pm->card) {\r\nsnd_card_free(pm->card);\r\npm->card = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int pcmidi_snd_terminate(struct pcmidi_snd *pm)\r\n{\r\nif (pm->card) {\r\nstop_sustain_timers(pm);\r\ndevice_remove_file(&pm->pk->hdev->dev,\r\nsysfs_device_attr_channel);\r\ndevice_remove_file(&pm->pk->hdev->dev,\r\nsysfs_device_attr_sustain);\r\ndevice_remove_file(&pm->pk->hdev->dev,\r\nsysfs_device_attr_octave);\r\nsnd_card_disconnect(pm->card);\r\nsnd_card_free_when_closed(pm->card);\r\n}\r\nreturn 0;\r\n}\r\nstatic __u8 *pk_report_fixup(struct hid_device *hdev, __u8 *rdesc,\r\nunsigned int *rsize)\r\n{\r\nif (*rsize == 178 &&\r\nrdesc[111] == 0x06 && rdesc[112] == 0x00 &&\r\nrdesc[113] == 0xff) {\r\nhid_info(hdev,\r\n"fixing up pc-midi keyboard report descriptor\n");\r\nrdesc[144] = 0x18;\r\n}\r\nreturn rdesc;\r\n}\r\nstatic int pk_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\nstruct pcmidi_snd *pm;\r\npm = pk->pm;\r\nif (HID_UP_MSVENDOR == (usage->hid & HID_USAGE_PAGE) &&\r\n1 == pm->ifnum) {\r\npcmidi_setup_extra_keys(pm, hi->input);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pk_raw_event(struct hid_device *hdev, struct hid_report *report,\r\nu8 *data, int size)\r\n{\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\nint ret = 0;\r\nif (1 == pk->pm->ifnum) {\r\nif (report->id == data[0])\r\nswitch (report->id) {\r\ncase 0x01:\r\ncase 0x03:\r\ncase 0x04:\r\nret = pcmidi_handle_report(pk->pm,\r\nreport->id, data, size);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int pk_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret;\r\nstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\r\nunsigned short ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\r\nunsigned long quirks = id->driver_data;\r\nstruct pk_device *pk;\r\nstruct pcmidi_snd *pm = NULL;\r\npk = kzalloc(sizeof(*pk), GFP_KERNEL);\r\nif (pk == NULL) {\r\nhid_err(hdev, "can't alloc descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\npk->hdev = hdev;\r\npm = kzalloc(sizeof(*pm), GFP_KERNEL);\r\nif (pm == NULL) {\r\nhid_err(hdev, "can't alloc descriptor\n");\r\nret = -ENOMEM;\r\ngoto err_free_pk;\r\n}\r\npm->pk = pk;\r\npk->pm = pm;\r\npm->ifnum = ifnum;\r\nhid_set_drvdata(hdev, pk);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "hid parse failed\n");\r\ngoto err_free;\r\n}\r\nif (quirks & PK_QUIRK_NOGET) {\r\nhdev->quirks |= HID_QUIRK_NOGET;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\ngoto err_free;\r\n}\r\nret = pcmidi_snd_initialise(pm);\r\nif (ret < 0)\r\ngoto err_stop;\r\nreturn 0;\r\nerr_stop:\r\nhid_hw_stop(hdev);\r\nerr_free:\r\nkfree(pm);\r\nerr_free_pk:\r\nkfree(pk);\r\nreturn ret;\r\n}\r\nstatic void pk_remove(struct hid_device *hdev)\r\n{\r\nstruct pk_device *pk = hid_get_drvdata(hdev);\r\nstruct pcmidi_snd *pm;\r\npm = pk->pm;\r\nif (pm) {\r\npcmidi_snd_terminate(pm);\r\nkfree(pm);\r\n}\r\nhid_hw_stop(hdev);\r\nkfree(pk);\r\n}
