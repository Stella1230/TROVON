struct ab8500_gpadc *ab8500_gpadc_get(char *name)\r\n{\r\nstruct ab8500_gpadc *gpadc;\r\nlist_for_each_entry(gpadc, &ab8500_gpadc_list, node) {\r\nif (!strcmp(name, dev_name(gpadc->dev)))\r\nreturn gpadc;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nint ab8500_gpadc_ad_to_voltage(struct ab8500_gpadc *gpadc, u8 channel,\r\nint ad_value)\r\n{\r\nint res;\r\nswitch (channel) {\r\ncase MAIN_CHARGER_V:\r\nif (!gpadc->cal_data[ADC_INPUT_VMAIN].gain) {\r\nres = ADC_CH_CHG_V_MIN + (ADC_CH_CHG_V_MAX -\r\nADC_CH_CHG_V_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_VMAIN].gain +\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset) / CALIB_SCALE;\r\nbreak;\r\ncase XTAL_TEMP:\r\ncase BAT_CTRL:\r\ncase BTEMP_BALL:\r\ncase ACC_DETECT1:\r\ncase ADC_AUX1:\r\ncase ADC_AUX2:\r\nif (!gpadc->cal_data[ADC_INPUT_BTEMP].gain) {\r\nres = ADC_CH_BTEMP_MIN + (ADC_CH_BTEMP_MAX -\r\nADC_CH_BTEMP_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_BTEMP].gain +\r\ngpadc->cal_data[ADC_INPUT_BTEMP].offset) / CALIB_SCALE;\r\nbreak;\r\ncase MAIN_BAT_V:\r\ncase VBAT_TRUE_MEAS:\r\nif (!gpadc->cal_data[ADC_INPUT_VBAT].gain) {\r\nres = ADC_CH_VBAT_MIN + (ADC_CH_VBAT_MAX -\r\nADC_CH_VBAT_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_VBAT].gain +\r\ngpadc->cal_data[ADC_INPUT_VBAT].offset) / CALIB_SCALE;\r\nbreak;\r\ncase DIE_TEMP:\r\nres = ADC_CH_DIETEMP_MIN +\r\n(ADC_CH_DIETEMP_MAX - ADC_CH_DIETEMP_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase ACC_DETECT2:\r\nres = ADC_CH_ACCDET2_MIN +\r\n(ADC_CH_ACCDET2_MAX - ADC_CH_ACCDET2_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase VBUS_V:\r\nres = ADC_CH_CHG_V_MIN +\r\n(ADC_CH_CHG_V_MAX - ADC_CH_CHG_V_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase MAIN_CHARGER_C:\r\ncase USB_CHARGER_C:\r\nres = ADC_CH_CHG_I_MIN +\r\n(ADC_CH_CHG_I_MAX - ADC_CH_CHG_I_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase BK_BAT_V:\r\nres = ADC_CH_BKBAT_MIN +\r\n(ADC_CH_BKBAT_MAX - ADC_CH_BKBAT_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\ncase IBAT_VIRTUAL_CHANNEL:\r\nif (!gpadc->cal_data[ADC_INPUT_IBAT].gain) {\r\nres = ADC_CH_IBAT_MIN + (ADC_CH_IBAT_MAX -\r\nADC_CH_IBAT_MIN) * ad_value /\r\nADC_RESOLUTION;\r\nbreak;\r\n}\r\nres = (int) (ad_value * gpadc->cal_data[ADC_INPUT_IBAT].gain +\r\ngpadc->cal_data[ADC_INPUT_IBAT].offset)\r\n>> CALIB_SHIFT_IBAT;\r\nbreak;\r\ndefault:\r\ndev_err(gpadc->dev,\r\n"unknown channel, not possible to convert\n");\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nint ab8500_gpadc_sw_hw_convert(struct ab8500_gpadc *gpadc, u8 channel,\r\nu8 avg_sample, u8 trig_edge, u8 trig_timer, u8 conv_type)\r\n{\r\nint ad_value;\r\nint voltage;\r\nad_value = ab8500_gpadc_read_raw(gpadc, channel, avg_sample,\r\ntrig_edge, trig_timer, conv_type);\r\nif (ad_value < 0)\r\nad_value = ab8500_gpadc_read_raw(gpadc, channel, avg_sample,\r\ntrig_edge, trig_timer, conv_type);\r\nif (ad_value < 0) {\r\ndev_err(gpadc->dev, "GPADC raw value failed ch: %d\n",\r\nchannel);\r\nreturn ad_value;\r\n}\r\nvoltage = ab8500_gpadc_ad_to_voltage(gpadc, channel, ad_value);\r\nif (voltage < 0)\r\ndev_err(gpadc->dev, "GPADC to voltage conversion failed ch:"\r\n" %d AD: 0x%x\n", channel, ad_value);\r\nreturn voltage;\r\n}\r\nint ab8500_gpadc_read_raw(struct ab8500_gpadc *gpadc, u8 channel,\r\nu8 avg_sample, u8 trig_edge, u8 trig_timer, u8 conv_type)\r\n{\r\nint raw_data;\r\nraw_data = ab8500_gpadc_double_read_raw(gpadc, channel,\r\navg_sample, trig_edge, trig_timer, conv_type, NULL);\r\nreturn raw_data;\r\n}\r\nint ab8500_gpadc_double_read_raw(struct ab8500_gpadc *gpadc, u8 channel,\r\nu8 avg_sample, u8 trig_edge, u8 trig_timer, u8 conv_type,\r\nint *ibat)\r\n{\r\nint ret;\r\nint looplimit = 0;\r\nunsigned long completion_timeout;\r\nu8 val, low_data, high_data, low_data2, high_data2;\r\nu8 val_reg1 = 0;\r\nunsigned int delay_min = 0;\r\nunsigned int delay_max = 0;\r\nu8 data_low_addr, data_high_addr;\r\nif (!gpadc)\r\nreturn -ENODEV;\r\nif ((gpadc->irq_sw < 0) && (conv_type == ADC_SW))\r\nreturn -ENOTSUPP;\r\nif ((gpadc->irq_hw < 0) && (conv_type == ADC_HW))\r\nreturn -ENOTSUPP;\r\nmutex_lock(&gpadc->ab8500_gpadc_lock);\r\npm_runtime_get_sync(gpadc->dev);\r\ndo {\r\nret = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_STAT_REG, &val);\r\nif (ret < 0)\r\ngoto out;\r\nif (!(val & GPADC_BUSY))\r\nbreak;\r\nmsleep(10);\r\n} while (++looplimit < 10);\r\nif (looplimit >= 10 && (val & GPADC_BUSY)) {\r\ndev_err(gpadc->dev, "gpadc_conversion: GPADC busy");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nval_reg1 |= EN_GPADC;\r\nswitch (avg_sample) {\r\ncase SAMPLE_1:\r\nval = channel | AVG_1;\r\nbreak;\r\ncase SAMPLE_4:\r\nval = channel | AVG_4;\r\nbreak;\r\ncase SAMPLE_8:\r\nval = channel | AVG_8;\r\nbreak;\r\ndefault:\r\nval = channel | AVG_16;\r\nbreak;\r\n}\r\nif (conv_type == ADC_HW) {\r\nret = abx500_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL3_REG, val);\r\nval_reg1 |= EN_TRIG_EDGE;\r\nif (trig_edge)\r\nval_reg1 |= EN_FALLING;\r\n}\r\nelse\r\nret = abx500_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL2_REG, val);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: set avg samples failed\n");\r\ngoto out;\r\n}\r\nswitch (channel) {\r\ncase MAIN_CHARGER_C:\r\ncase USB_CHARGER_C:\r\nval_reg1 |= EN_BUF | EN_ICHAR;\r\nbreak;\r\ncase BTEMP_BALL:\r\nif (!is_ab8500_2p0_or_earlier(gpadc->parent)) {\r\nval_reg1 |= EN_BUF | BTEMP_PULL_UP;\r\ndelay_min = 1000;\r\ndelay_max = 10000;\r\nbreak;\r\n}\r\ndefault:\r\nval_reg1 |= EN_BUF;\r\nbreak;\r\n}\r\nret = abx500_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG, val_reg1);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: set Control register failed\n");\r\ngoto out;\r\n}\r\nif (delay_min != 0)\r\nusleep_range(delay_min, delay_max);\r\nif (conv_type == ADC_HW) {\r\nret = abx500_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_AUTO_TIMER_REG, trig_timer);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: trig timer failed\n");\r\ngoto out;\r\n}\r\ncompletion_timeout = 2 * HZ;\r\ndata_low_addr = AB8500_GPADC_AUTODATAL_REG;\r\ndata_high_addr = AB8500_GPADC_AUTODATAH_REG;\r\n} else {\r\nret = abx500_mask_and_set_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8500_GPADC_CTRL1_REG,\r\nADC_SW_CONV, ADC_SW_CONV);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: start s/w conv failed\n");\r\ngoto out;\r\n}\r\ncompletion_timeout = msecs_to_jiffies(CONVERSION_TIME);\r\ndata_low_addr = AB8500_GPADC_MANDATAL_REG;\r\ndata_high_addr = AB8500_GPADC_MANDATAH_REG;\r\n}\r\nif (!wait_for_completion_timeout(&gpadc->ab8500_gpadc_complete,\r\ncompletion_timeout)) {\r\ndev_err(gpadc->dev,\r\n"timeout didn't receive GPADC conv interrupt\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, data_low_addr, &low_data);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "gpadc_conversion: read low data failed\n");\r\ngoto out;\r\n}\r\nret = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, data_high_addr, &high_data);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "gpadc_conversion: read high data failed\n");\r\ngoto out;\r\n}\r\nif ((channel == BAT_CTRL_AND_IBAT) ||\r\n(channel == VBAT_MEAS_AND_IBAT) ||\r\n(channel == VBAT_TRUE_MEAS_AND_IBAT) ||\r\n(channel == BAT_TEMP_AND_IBAT)) {\r\nif (conv_type == ADC_HW) {\r\nret = -ENOTSUPP;\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: only SW double conversion supported\n");\r\ngoto out;\r\n} else {\r\nret = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8540_GPADC_MANDATA2L_REG,\r\n&low_data2);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: read sw low data 2 failed\n");\r\ngoto out;\r\n}\r\nret = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_GPADC, AB8540_GPADC_MANDATA2H_REG,\r\n&high_data2);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: read sw high data 2 failed\n");\r\ngoto out;\r\n}\r\nif (ibat != NULL) {\r\n*ibat = (high_data2 << 8) | low_data2;\r\n} else {\r\ndev_warn(gpadc->dev,\r\n"gpadc_conversion: ibat not stored\n");\r\n}\r\n}\r\n}\r\nret = abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_CTRL1_REG, DIS_GPADC);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev, "gpadc_conversion: disable gpadc failed\n");\r\ngoto out;\r\n}\r\npm_runtime_mark_last_busy(gpadc->dev);\r\npm_runtime_put_autosuspend(gpadc->dev);\r\nmutex_unlock(&gpadc->ab8500_gpadc_lock);\r\nreturn (high_data << 8) | low_data;\r\nout:\r\n(void) abx500_set_register_interruptible(gpadc->dev, AB8500_GPADC,\r\nAB8500_GPADC_CTRL1_REG, DIS_GPADC);\r\npm_runtime_put(gpadc->dev);\r\nmutex_unlock(&gpadc->ab8500_gpadc_lock);\r\ndev_err(gpadc->dev,\r\n"gpadc_conversion: Failed to AD convert channel %d\n", channel);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ab8500_bm_gpadcconvend_handler(int irq, void *_gpadc)\r\n{\r\nstruct ab8500_gpadc *gpadc = _gpadc;\r\ncomplete(&gpadc->ab8500_gpadc_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ab8500_gpadc_read_calibration_data(struct ab8500_gpadc *gpadc)\r\n{\r\nint i;\r\nint ret[ARRAY_SIZE(otp_cal_regs)];\r\nu8 gpadc_cal[ARRAY_SIZE(otp_cal_regs)];\r\nint ret_otp4[ARRAY_SIZE(otp4_cal_regs)];\r\nu8 gpadc_otp4[ARRAY_SIZE(otp4_cal_regs)];\r\nint vmain_high, vmain_low;\r\nint btemp_high, btemp_low;\r\nint vbat_high, vbat_low;\r\nint ibat_high, ibat_low;\r\ns64 V_gain, V_offset, V2A_gain, V2A_offset;\r\nstruct ab8500 *ab8500;\r\nab8500 = gpadc->parent;\r\nfor (i = 0; i < ARRAY_SIZE(otp_cal_regs); i++) {\r\nret[i] = abx500_get_register_interruptible(gpadc->dev,\r\nAB8500_OTP_EMUL, otp_cal_regs[i], &gpadc_cal[i]);\r\nif (ret[i] < 0)\r\ndev_err(gpadc->dev, "%s: read otp reg 0x%02x failed\n",\r\n__func__, otp_cal_regs[i]);\r\n}\r\nif (is_ab8540(ab8500)) {\r\nif (!(ret[1] < 0 || ret[2] < 0)) {\r\nvmain_high = (((gpadc_cal[1] & 0xFF) << 2) |\r\n((gpadc_cal[2] & 0xC0) >> 6));\r\nvmain_low = ((gpadc_cal[2] & 0x3E) >> 1);\r\ngpadc->cal_data[ADC_INPUT_VMAIN].otp_calib_hi =\r\n(u16)vmain_high;\r\ngpadc->cal_data[ADC_INPUT_VMAIN].otp_calib_lo =\r\n(u16)vmain_low;\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain = CALIB_SCALE *\r\n(19500 - 315) / (vmain_high - vmain_low);\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset = CALIB_SCALE *\r\n19500 - (CALIB_SCALE * (19500 - 315) /\r\n(vmain_high - vmain_low)) * vmain_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain = 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(otp4_cal_regs); i++) {\r\nret_otp4[i] = abx500_get_register_interruptible(\r\ngpadc->dev, AB8500_OTP_EMUL,\r\notp4_cal_regs[i], &gpadc_otp4[i]);\r\nif (ret_otp4[i] < 0)\r\ndev_err(gpadc->dev,\r\n"%s: read otp4 reg 0x%02x failed\n",\r\n__func__, otp4_cal_regs[i]);\r\n}\r\nif (!(ret_otp4[0] < 0 || ret_otp4[1] < 0 || ret_otp4[2] < 0)) {\r\nibat_high = (((gpadc_otp4[0] & 0x07) << 7) |\r\n((gpadc_otp4[1] & 0xFE) >> 1));\r\nibat_low = (((gpadc_otp4[1] & 0x01) << 5) |\r\n((gpadc_otp4[2] & 0xF8) >> 3));\r\ngpadc->cal_data[ADC_INPUT_IBAT].otp_calib_hi =\r\n(u16)ibat_high;\r\ngpadc->cal_data[ADC_INPUT_IBAT].otp_calib_lo =\r\n(u16)ibat_low;\r\nV_gain = ((IBAT_VDROP_H - IBAT_VDROP_L)\r\n<< CALIB_SHIFT_IBAT) / (ibat_high - ibat_low);\r\nV_offset = (IBAT_VDROP_H << CALIB_SHIFT_IBAT) -\r\n(((IBAT_VDROP_H - IBAT_VDROP_L) <<\r\nCALIB_SHIFT_IBAT) / (ibat_high - ibat_low))\r\n* ibat_high;\r\nV2A_gain = (ADC_CH_IBAT_MAX - ADC_CH_IBAT_MIN)/\r\n(ADC_CH_IBAT_MAX_V - ADC_CH_IBAT_MIN_V);\r\nV2A_offset = ((ADC_CH_IBAT_MAX_V * ADC_CH_IBAT_MIN -\r\nADC_CH_IBAT_MAX * ADC_CH_IBAT_MIN_V)\r\n<< CALIB_SHIFT_IBAT)\r\n/ (ADC_CH_IBAT_MAX_V - ADC_CH_IBAT_MIN_V);\r\ngpadc->cal_data[ADC_INPUT_IBAT].gain = V_gain * V2A_gain;\r\ngpadc->cal_data[ADC_INPUT_IBAT].offset = V_offset *\r\nV2A_gain + V2A_offset;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_IBAT].gain = 0;\r\n}\r\ndev_dbg(gpadc->dev, "IBAT gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_IBAT].gain,\r\ngpadc->cal_data[ADC_INPUT_IBAT].offset);\r\n} else {\r\nif (!(ret[0] < 0 || ret[1] < 0 || ret[2] < 0)) {\r\nvmain_high = (((gpadc_cal[0] & 0x03) << 8) |\r\n((gpadc_cal[1] & 0x3F) << 2) |\r\n((gpadc_cal[2] & 0xC0) >> 6));\r\nvmain_low = ((gpadc_cal[2] & 0x3E) >> 1);\r\ngpadc->cal_data[ADC_INPUT_VMAIN].otp_calib_hi =\r\n(u16)vmain_high;\r\ngpadc->cal_data[ADC_INPUT_VMAIN].otp_calib_lo =\r\n(u16)vmain_low;\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain = CALIB_SCALE *\r\n(19500 - 315) / (vmain_high - vmain_low);\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset = CALIB_SCALE *\r\n19500 - (CALIB_SCALE * (19500 - 315) /\r\n(vmain_high - vmain_low)) * vmain_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain = 0;\r\n}\r\n}\r\nif (!(ret[2] < 0 || ret[3] < 0 || ret[4] < 0)) {\r\nbtemp_high = (((gpadc_cal[2] & 0x01) << 9) |\r\n(gpadc_cal[3] << 1) | ((gpadc_cal[4] & 0x80) >> 7));\r\nbtemp_low = ((gpadc_cal[4] & 0x7C) >> 2);\r\ngpadc->cal_data[ADC_INPUT_BTEMP].otp_calib_hi = (u16)btemp_high;\r\ngpadc->cal_data[ADC_INPUT_BTEMP].otp_calib_lo = (u16)btemp_low;\r\ngpadc->cal_data[ADC_INPUT_BTEMP].gain =\r\nCALIB_SCALE * (1300 - 21) / (btemp_high - btemp_low);\r\ngpadc->cal_data[ADC_INPUT_BTEMP].offset = CALIB_SCALE * 1300 -\r\n(CALIB_SCALE * (1300 - 21) / (btemp_high - btemp_low))\r\n* btemp_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_BTEMP].gain = 0;\r\n}\r\nif (!(ret[4] < 0 || ret[5] < 0 || ret[6] < 0)) {\r\nvbat_high = (((gpadc_cal[4] & 0x03) << 8) | gpadc_cal[5]);\r\nvbat_low = ((gpadc_cal[6] & 0xFC) >> 2);\r\ngpadc->cal_data[ADC_INPUT_VBAT].otp_calib_hi = (u16)vbat_high;\r\ngpadc->cal_data[ADC_INPUT_VBAT].otp_calib_lo = (u16)vbat_low;\r\ngpadc->cal_data[ADC_INPUT_VBAT].gain = CALIB_SCALE *\r\n(4700 - 2380) / (vbat_high - vbat_low);\r\ngpadc->cal_data[ADC_INPUT_VBAT].offset = CALIB_SCALE * 4700 -\r\n(CALIB_SCALE * (4700 - 2380) /\r\n(vbat_high - vbat_low)) * vbat_high;\r\n} else {\r\ngpadc->cal_data[ADC_INPUT_VBAT].gain = 0;\r\n}\r\ndev_dbg(gpadc->dev, "VMAIN gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_VMAIN].gain,\r\ngpadc->cal_data[ADC_INPUT_VMAIN].offset);\r\ndev_dbg(gpadc->dev, "BTEMP gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_BTEMP].gain,\r\ngpadc->cal_data[ADC_INPUT_BTEMP].offset);\r\ndev_dbg(gpadc->dev, "VBAT gain %llu offset %llu\n",\r\ngpadc->cal_data[ADC_INPUT_VBAT].gain,\r\ngpadc->cal_data[ADC_INPUT_VBAT].offset);\r\n}\r\nstatic int ab8500_gpadc_runtime_suspend(struct device *dev)\r\n{\r\nstruct ab8500_gpadc *gpadc = dev_get_drvdata(dev);\r\nregulator_disable(gpadc->regu);\r\nreturn 0;\r\n}\r\nstatic int ab8500_gpadc_runtime_resume(struct device *dev)\r\n{\r\nstruct ab8500_gpadc *gpadc = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_enable(gpadc->regu);\r\nif (ret)\r\ndev_err(dev, "Failed to enable vtvout LDO: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ab8500_gpadc_suspend(struct device *dev)\r\n{\r\nstruct ab8500_gpadc *gpadc = dev_get_drvdata(dev);\r\nmutex_lock(&gpadc->ab8500_gpadc_lock);\r\npm_runtime_get_sync(dev);\r\nregulator_disable(gpadc->regu);\r\nreturn 0;\r\n}\r\nstatic int ab8500_gpadc_resume(struct device *dev)\r\n{\r\nstruct ab8500_gpadc *gpadc = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_enable(gpadc->regu);\r\nif (ret)\r\ndev_err(dev, "Failed to enable vtvout LDO: %d\n", ret);\r\npm_runtime_mark_last_busy(gpadc->dev);\r\npm_runtime_put_autosuspend(gpadc->dev);\r\nmutex_unlock(&gpadc->ab8500_gpadc_lock);\r\nreturn ret;\r\n}\r\nstatic int ab8500_gpadc_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct ab8500_gpadc *gpadc;\r\ngpadc = devm_kzalloc(&pdev->dev, sizeof(struct ab8500_gpadc), GFP_KERNEL);\r\nif (!gpadc) {\r\ndev_err(&pdev->dev, "Error: No memory\n");\r\nreturn -ENOMEM;\r\n}\r\ngpadc->irq_sw = platform_get_irq_byname(pdev, "SW_CONV_END");\r\nif (gpadc->irq_sw < 0)\r\ndev_err(gpadc->dev, "failed to get platform sw_conv_end irq\n");\r\ngpadc->irq_hw = platform_get_irq_byname(pdev, "HW_CONV_END");\r\nif (gpadc->irq_hw < 0)\r\ndev_err(gpadc->dev, "failed to get platform hw_conv_end irq\n");\r\ngpadc->dev = &pdev->dev;\r\ngpadc->parent = dev_get_drvdata(pdev->dev.parent);\r\nmutex_init(&gpadc->ab8500_gpadc_lock);\r\ninit_completion(&gpadc->ab8500_gpadc_complete);\r\nif (gpadc->irq_sw >= 0) {\r\nret = request_threaded_irq(gpadc->irq_sw, NULL,\r\nab8500_bm_gpadcconvend_handler,\r\nIRQF_NO_SUSPEND | IRQF_SHARED | IRQF_ONESHOT,\r\n"ab8500-gpadc-sw",\r\ngpadc);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"Failed to register interrupt irq: %d\n",\r\ngpadc->irq_sw);\r\ngoto fail;\r\n}\r\n}\r\nif (gpadc->irq_hw >= 0) {\r\nret = request_threaded_irq(gpadc->irq_hw, NULL,\r\nab8500_bm_gpadcconvend_handler,\r\nIRQF_NO_SUSPEND | IRQF_SHARED | IRQF_ONESHOT,\r\n"ab8500-gpadc-hw",\r\ngpadc);\r\nif (ret < 0) {\r\ndev_err(gpadc->dev,\r\n"Failed to register interrupt irq: %d\n",\r\ngpadc->irq_hw);\r\ngoto fail_irq;\r\n}\r\n}\r\ngpadc->regu = devm_regulator_get(&pdev->dev, "vddadc");\r\nif (IS_ERR(gpadc->regu)) {\r\nret = PTR_ERR(gpadc->regu);\r\ndev_err(gpadc->dev, "failed to get vtvout LDO\n");\r\ngoto fail_irq;\r\n}\r\nplatform_set_drvdata(pdev, gpadc);\r\nret = regulator_enable(gpadc->regu);\r\nif (ret) {\r\ndev_err(gpadc->dev, "Failed to enable vtvout LDO: %d\n", ret);\r\ngoto fail_enable;\r\n}\r\npm_runtime_set_autosuspend_delay(gpadc->dev, GPADC_AUDOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(gpadc->dev);\r\npm_runtime_set_active(gpadc->dev);\r\npm_runtime_enable(gpadc->dev);\r\nab8500_gpadc_read_calibration_data(gpadc);\r\nlist_add_tail(&gpadc->node, &ab8500_gpadc_list);\r\ndev_dbg(gpadc->dev, "probe success\n");\r\nreturn 0;\r\nfail_enable:\r\nfail_irq:\r\nfree_irq(gpadc->irq_sw, gpadc);\r\nfree_irq(gpadc->irq_hw, gpadc);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int ab8500_gpadc_remove(struct platform_device *pdev)\r\n{\r\nstruct ab8500_gpadc *gpadc = platform_get_drvdata(pdev);\r\nlist_del(&gpadc->node);\r\nif (gpadc->irq_sw >= 0)\r\nfree_irq(gpadc->irq_sw, gpadc);\r\nif (gpadc->irq_hw >= 0)\r\nfree_irq(gpadc->irq_hw, gpadc);\r\npm_runtime_get_sync(gpadc->dev);\r\npm_runtime_disable(gpadc->dev);\r\nregulator_disable(gpadc->regu);\r\npm_runtime_set_suspended(gpadc->dev);\r\npm_runtime_put_noidle(gpadc->dev);\r\nreturn 0;\r\n}\r\nstatic int __init ab8500_gpadc_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_gpadc_driver);\r\n}\r\nstatic void __exit ab8500_gpadc_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_gpadc_driver);\r\n}\r\nvoid ab8540_gpadc_get_otp(struct ab8500_gpadc *gpadc,\r\nu16 *vmain_l, u16 *vmain_h, u16 *btemp_l, u16 *btemp_h,\r\nu16 *vbat_l, u16 *vbat_h, u16 *ibat_l, u16 *ibat_h)\r\n{\r\n*vmain_l = gpadc->cal_data[ADC_INPUT_VMAIN].otp_calib_lo;\r\n*vmain_h = gpadc->cal_data[ADC_INPUT_VMAIN].otp_calib_hi;\r\n*btemp_l = gpadc->cal_data[ADC_INPUT_BTEMP].otp_calib_lo;\r\n*btemp_h = gpadc->cal_data[ADC_INPUT_BTEMP].otp_calib_hi;\r\n*vbat_l = gpadc->cal_data[ADC_INPUT_VBAT].otp_calib_lo;\r\n*vbat_h = gpadc->cal_data[ADC_INPUT_VBAT].otp_calib_hi;\r\n*ibat_l = gpadc->cal_data[ADC_INPUT_IBAT].otp_calib_lo;\r\n*ibat_h = gpadc->cal_data[ADC_INPUT_IBAT].otp_calib_hi;\r\nreturn ;\r\n}
