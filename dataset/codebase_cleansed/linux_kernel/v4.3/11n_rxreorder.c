static int mwifiex_11n_dispatch_amsdu_pkt(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rxpd *local_rx_pd = (struct rxpd *)(skb->data);\r\nint ret;\r\nif (le16_to_cpu(local_rx_pd->rx_pkt_type) == PKT_TYPE_AMSDU) {\r\nstruct sk_buff_head list;\r\nstruct sk_buff *rx_skb;\r\n__skb_queue_head_init(&list);\r\nskb_pull(skb, le16_to_cpu(local_rx_pd->rx_pkt_offset));\r\nskb_trim(skb, le16_to_cpu(local_rx_pd->rx_pkt_length));\r\nieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,\r\npriv->wdev.iftype, 0, false);\r\nwhile (!skb_queue_empty(&list)) {\r\nrx_skb = __skb_dequeue(&list);\r\nret = mwifiex_recv_packet(priv, rx_skb);\r\nif (ret == -1)\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Rx of A-MSDU failed");\r\n}\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int mwifiex_11n_dispatch_pkt(struct mwifiex_private *priv, void *payload)\r\n{\r\nint ret = mwifiex_11n_dispatch_amsdu_pkt(priv, payload);\r\nif (!ret)\r\nreturn 0;\r\nif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP)\r\nreturn mwifiex_handle_uap_rx_forward(priv, payload);\r\nreturn mwifiex_process_rx_packet(priv, payload);\r\n}\r\nstatic void\r\nmwifiex_11n_dispatch_pkt_until_start_win(struct mwifiex_private *priv,\r\nstruct mwifiex_rx_reorder_tbl *tbl,\r\nint start_win)\r\n{\r\nint pkt_to_send, i;\r\nvoid *rx_tmp_ptr;\r\nunsigned long flags;\r\npkt_to_send = (start_win > tbl->start_win) ?\r\nmin((start_win - tbl->start_win), tbl->win_size) :\r\ntbl->win_size;\r\nfor (i = 0; i < pkt_to_send; ++i) {\r\nspin_lock_irqsave(&priv->rx_pkt_lock, flags);\r\nrx_tmp_ptr = NULL;\r\nif (tbl->rx_reorder_ptr[i]) {\r\nrx_tmp_ptr = tbl->rx_reorder_ptr[i];\r\ntbl->rx_reorder_ptr[i] = NULL;\r\n}\r\nspin_unlock_irqrestore(&priv->rx_pkt_lock, flags);\r\nif (rx_tmp_ptr)\r\nmwifiex_11n_dispatch_pkt(priv, rx_tmp_ptr);\r\n}\r\nspin_lock_irqsave(&priv->rx_pkt_lock, flags);\r\nfor (i = 0; i < tbl->win_size - pkt_to_send; ++i) {\r\ntbl->rx_reorder_ptr[i] = tbl->rx_reorder_ptr[pkt_to_send + i];\r\ntbl->rx_reorder_ptr[pkt_to_send + i] = NULL;\r\n}\r\ntbl->start_win = start_win;\r\nspin_unlock_irqrestore(&priv->rx_pkt_lock, flags);\r\n}\r\nstatic void\r\nmwifiex_11n_scan_and_dispatch(struct mwifiex_private *priv,\r\nstruct mwifiex_rx_reorder_tbl *tbl)\r\n{\r\nint i, j, xchg;\r\nvoid *rx_tmp_ptr;\r\nunsigned long flags;\r\nfor (i = 0; i < tbl->win_size; ++i) {\r\nspin_lock_irqsave(&priv->rx_pkt_lock, flags);\r\nif (!tbl->rx_reorder_ptr[i]) {\r\nspin_unlock_irqrestore(&priv->rx_pkt_lock, flags);\r\nbreak;\r\n}\r\nrx_tmp_ptr = tbl->rx_reorder_ptr[i];\r\ntbl->rx_reorder_ptr[i] = NULL;\r\nspin_unlock_irqrestore(&priv->rx_pkt_lock, flags);\r\nmwifiex_11n_dispatch_pkt(priv, rx_tmp_ptr);\r\n}\r\nspin_lock_irqsave(&priv->rx_pkt_lock, flags);\r\nif (i > 0) {\r\nxchg = tbl->win_size - i;\r\nfor (j = 0; j < xchg; ++j) {\r\ntbl->rx_reorder_ptr[j] = tbl->rx_reorder_ptr[i + j];\r\ntbl->rx_reorder_ptr[i + j] = NULL;\r\n}\r\n}\r\ntbl->start_win = (tbl->start_win + i) & (MAX_TID_VALUE - 1);\r\nspin_unlock_irqrestore(&priv->rx_pkt_lock, flags);\r\n}\r\nstatic void\r\nmwifiex_del_rx_reorder_entry(struct mwifiex_private *priv,\r\nstruct mwifiex_rx_reorder_tbl *tbl)\r\n{\r\nunsigned long flags;\r\nint start_win;\r\nif (!tbl)\r\nreturn;\r\nspin_lock_irqsave(&priv->adapter->rx_proc_lock, flags);\r\npriv->adapter->rx_locked = true;\r\nif (priv->adapter->rx_processing) {\r\nspin_unlock_irqrestore(&priv->adapter->rx_proc_lock, flags);\r\nflush_workqueue(priv->adapter->rx_workqueue);\r\n} else {\r\nspin_unlock_irqrestore(&priv->adapter->rx_proc_lock, flags);\r\n}\r\nstart_win = (tbl->start_win + tbl->win_size) & (MAX_TID_VALUE - 1);\r\nmwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, start_win);\r\ndel_timer_sync(&tbl->timer_context.timer);\r\ntbl->timer_context.timer_is_set = false;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nlist_del(&tbl->list);\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nkfree(tbl->rx_reorder_ptr);\r\nkfree(tbl);\r\nspin_lock_irqsave(&priv->adapter->rx_proc_lock, flags);\r\npriv->adapter->rx_locked = false;\r\nspin_unlock_irqrestore(&priv->adapter->rx_proc_lock, flags);\r\n}\r\nstruct mwifiex_rx_reorder_tbl *\r\nmwifiex_11n_get_rx_reorder_tbl(struct mwifiex_private *priv, int tid, u8 *ta)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *tbl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nlist_for_each_entry(tbl, &priv->rx_reorder_tbl_ptr, list) {\r\nif (!memcmp(tbl->ta, ta, ETH_ALEN) && tbl->tid == tid) {\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock,\r\nflags);\r\nreturn tbl;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nreturn NULL;\r\n}\r\nvoid mwifiex_11n_del_rx_reorder_tbl_by_ta(struct mwifiex_private *priv, u8 *ta)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *tbl, *tmp;\r\nunsigned long flags;\r\nif (!ta)\r\nreturn;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nlist_for_each_entry_safe(tbl, tmp, &priv->rx_reorder_tbl_ptr, list) {\r\nif (!memcmp(tbl->ta, ta, ETH_ALEN)) {\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock,\r\nflags);\r\nmwifiex_del_rx_reorder_entry(priv, tbl);\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nreturn;\r\n}\r\nstatic int\r\nmwifiex_11n_find_last_seq_num(struct reorder_tmr_cnxt *ctx)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *rx_reorder_tbl_ptr = ctx->ptr;\r\nstruct mwifiex_private *priv = ctx->priv;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nfor (i = rx_reorder_tbl_ptr->win_size - 1; i >= 0; --i) {\r\nif (rx_reorder_tbl_ptr->rx_reorder_ptr[i]) {\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock,\r\nflags);\r\nreturn i;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nreturn -1;\r\n}\r\nstatic void\r\nmwifiex_flush_data(unsigned long context)\r\n{\r\nstruct reorder_tmr_cnxt *ctx =\r\n(struct reorder_tmr_cnxt *) context;\r\nint start_win, seq_num;\r\nctx->timer_is_set = false;\r\nseq_num = mwifiex_11n_find_last_seq_num(ctx);\r\nif (seq_num < 0)\r\nreturn;\r\nmwifiex_dbg(ctx->priv->adapter, INFO, "info: flush data %d\n", seq_num);\r\nstart_win = (ctx->ptr->start_win + seq_num + 1) & (MAX_TID_VALUE - 1);\r\nmwifiex_11n_dispatch_pkt_until_start_win(ctx->priv, ctx->ptr,\r\nstart_win);\r\n}\r\nstatic void\r\nmwifiex_11n_create_rx_reorder_tbl(struct mwifiex_private *priv, u8 *ta,\r\nint tid, int win_size, int seq_num)\r\n{\r\nint i;\r\nstruct mwifiex_rx_reorder_tbl *tbl, *new_node;\r\nu16 last_seq = 0;\r\nunsigned long flags;\r\nstruct mwifiex_sta_node *node;\r\ntbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid, ta);\r\nif (tbl) {\r\nmwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, seq_num);\r\nreturn;\r\n}\r\nnew_node = kzalloc(sizeof(struct mwifiex_rx_reorder_tbl), GFP_KERNEL);\r\nif (!new_node)\r\nreturn;\r\nINIT_LIST_HEAD(&new_node->list);\r\nnew_node->tid = tid;\r\nmemcpy(new_node->ta, ta, ETH_ALEN);\r\nnew_node->start_win = seq_num;\r\nnew_node->init_win = seq_num;\r\nnew_node->flags = 0;\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nif (mwifiex_queuing_ra_based(priv)) {\r\nif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP) {\r\nnode = mwifiex_get_sta_entry(priv, ta);\r\nif (node)\r\nlast_seq = node->rx_seq[tid];\r\n}\r\n} else {\r\nnode = mwifiex_get_sta_entry(priv, ta);\r\nif (node)\r\nlast_seq = node->rx_seq[tid];\r\nelse\r\nlast_seq = priv->rx_seq[tid];\r\n}\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: last_seq=%d start_win=%d\n",\r\nlast_seq, new_node->start_win);\r\nif (last_seq != MWIFIEX_DEF_11N_RX_SEQ_NUM &&\r\nlast_seq >= new_node->start_win) {\r\nnew_node->start_win = last_seq + 1;\r\nnew_node->flags |= RXREOR_INIT_WINDOW_SHIFT;\r\n}\r\nnew_node->win_size = win_size;\r\nnew_node->rx_reorder_ptr = kzalloc(sizeof(void *) * win_size,\r\nGFP_KERNEL);\r\nif (!new_node->rx_reorder_ptr) {\r\nkfree((u8 *) new_node);\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"%s: failed to alloc reorder_ptr\n", __func__);\r\nreturn;\r\n}\r\nnew_node->timer_context.ptr = new_node;\r\nnew_node->timer_context.priv = priv;\r\nnew_node->timer_context.timer_is_set = false;\r\nsetup_timer(&new_node->timer_context.timer, mwifiex_flush_data,\r\n(unsigned long)&new_node->timer_context);\r\nfor (i = 0; i < win_size; ++i)\r\nnew_node->rx_reorder_ptr[i] = NULL;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nlist_add_tail(&new_node->list, &priv->rx_reorder_tbl_ptr);\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\n}\r\nstatic void\r\nmwifiex_11n_rxreorder_timer_restart(struct mwifiex_rx_reorder_tbl *tbl)\r\n{\r\nu32 min_flush_time;\r\nif (tbl->win_size >= MWIFIEX_BA_WIN_SIZE_32)\r\nmin_flush_time = MIN_FLUSH_TIMER_15_MS;\r\nelse\r\nmin_flush_time = MIN_FLUSH_TIMER_MS;\r\nmod_timer(&tbl->timer_context.timer,\r\njiffies + msecs_to_jiffies(min_flush_time * tbl->win_size));\r\ntbl->timer_context.timer_is_set = true;\r\n}\r\nint mwifiex_cmd_11n_addba_req(struct host_cmd_ds_command *cmd, void *data_buf)\r\n{\r\nstruct host_cmd_ds_11n_addba_req *add_ba_req = &cmd->params.add_ba_req;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_11N_ADDBA_REQ);\r\ncmd->size = cpu_to_le16(sizeof(*add_ba_req) + S_DS_GEN);\r\nmemcpy(add_ba_req, data_buf, sizeof(*add_ba_req));\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_11n_addba_rsp_gen(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nstruct host_cmd_ds_11n_addba_req\r\n*cmd_addba_req)\r\n{\r\nstruct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &cmd->params.add_ba_rsp;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nu32 rx_win_size = priv->add_ba_param.rx_win_size;\r\nu8 tid;\r\nint win_size;\r\nunsigned long flags;\r\nuint16_t block_ack_param_set;\r\nif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) &&\r\nISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\r\npriv->adapter->is_hw_11ac_capable &&\r\nmemcmp(priv->cfg_bssid, cmd_addba_req->peer_mac_addr, ETH_ALEN)) {\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nsta_ptr = mwifiex_get_sta_entry(priv,\r\ncmd_addba_req->peer_mac_addr);\r\nif (!sta_ptr) {\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"BA setup with unknown TDLS peer %pM!\n",\r\ncmd_addba_req->peer_mac_addr);\r\nreturn -1;\r\n}\r\nif (sta_ptr->is_11ac_enabled)\r\nrx_win_size = MWIFIEX_11AC_STA_AMPDU_DEF_RXWINSIZE;\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\n}\r\ncmd->command = cpu_to_le16(HostCmd_CMD_11N_ADDBA_RSP);\r\ncmd->size = cpu_to_le16(sizeof(*add_ba_rsp) + S_DS_GEN);\r\nmemcpy(add_ba_rsp->peer_mac_addr, cmd_addba_req->peer_mac_addr,\r\nETH_ALEN);\r\nadd_ba_rsp->dialog_token = cmd_addba_req->dialog_token;\r\nadd_ba_rsp->block_ack_tmo = cmd_addba_req->block_ack_tmo;\r\nadd_ba_rsp->ssn = cmd_addba_req->ssn;\r\nblock_ack_param_set = le16_to_cpu(cmd_addba_req->block_ack_param_set);\r\ntid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)\r\n>> BLOCKACKPARAM_TID_POS;\r\nadd_ba_rsp->status_code = cpu_to_le16(ADDBA_RSP_STATUS_ACCEPT);\r\nblock_ack_param_set &= ~IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK;\r\nif (!priv->add_ba_param.rx_amsdu ||\r\n(priv->aggr_prio_tbl[tid].amsdu == BA_STREAM_NOT_ALLOWED))\r\nblock_ack_param_set &= ~BLOCKACKPARAM_AMSDU_SUPP_MASK;\r\nblock_ack_param_set |= rx_win_size << BLOCKACKPARAM_WINSIZE_POS;\r\nadd_ba_rsp->block_ack_param_set = cpu_to_le16(block_ack_param_set);\r\nwin_size = (le16_to_cpu(add_ba_rsp->block_ack_param_set)\r\n& IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)\r\n>> BLOCKACKPARAM_WINSIZE_POS;\r\ncmd_addba_req->block_ack_param_set = cpu_to_le16(block_ack_param_set);\r\nmwifiex_11n_create_rx_reorder_tbl(priv, cmd_addba_req->peer_mac_addr,\r\ntid, win_size,\r\nle16_to_cpu(cmd_addba_req->ssn));\r\nreturn 0;\r\n}\r\nint mwifiex_cmd_11n_delba(struct host_cmd_ds_command *cmd, void *data_buf)\r\n{\r\nstruct host_cmd_ds_11n_delba *del_ba = &cmd->params.del_ba;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_11N_DELBA);\r\ncmd->size = cpu_to_le16(sizeof(*del_ba) + S_DS_GEN);\r\nmemcpy(del_ba, data_buf, sizeof(*del_ba));\r\nreturn 0;\r\n}\r\nint mwifiex_11n_rx_reorder_pkt(struct mwifiex_private *priv,\r\nu16 seq_num, u16 tid,\r\nu8 *ta, u8 pkt_type, void *payload)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *tbl;\r\nint prev_start_win, start_win, end_win, win_size;\r\nu16 pkt_index;\r\nbool init_window_shift = false;\r\nint ret = 0;\r\ntbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid, ta);\r\nif (!tbl) {\r\nif (pkt_type != PKT_TYPE_BAR)\r\nmwifiex_11n_dispatch_pkt(priv, payload);\r\nreturn ret;\r\n}\r\nif ((pkt_type == PKT_TYPE_AMSDU) && !tbl->amsdu) {\r\nmwifiex_11n_dispatch_pkt(priv, payload);\r\nreturn ret;\r\n}\r\nstart_win = tbl->start_win;\r\nprev_start_win = start_win;\r\nwin_size = tbl->win_size;\r\nend_win = ((start_win + win_size) - 1) & (MAX_TID_VALUE - 1);\r\nif (tbl->flags & RXREOR_INIT_WINDOW_SHIFT) {\r\ninit_window_shift = true;\r\ntbl->flags &= ~RXREOR_INIT_WINDOW_SHIFT;\r\n}\r\nif (tbl->flags & RXREOR_FORCE_NO_DROP) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"RXREOR_FORCE_NO_DROP when HS is activated\n");\r\ntbl->flags &= ~RXREOR_FORCE_NO_DROP;\r\n} else if (init_window_shift && seq_num < start_win &&\r\nseq_num >= tbl->init_win) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"Sender TID sequence number reset %d->%d for SSN %d\n",\r\nstart_win, seq_num, tbl->init_win);\r\ntbl->start_win = start_win = seq_num;\r\nend_win = ((start_win + win_size) - 1) & (MAX_TID_VALUE - 1);\r\n} else {\r\nif ((start_win + TWOPOW11) > (MAX_TID_VALUE - 1)) {\r\nif (seq_num >= ((start_win + TWOPOW11) &\r\n(MAX_TID_VALUE - 1)) &&\r\nseq_num < start_win) {\r\nret = -1;\r\ngoto done;\r\n}\r\n} else if ((seq_num < start_win) ||\r\n(seq_num >= (start_win + TWOPOW11))) {\r\nret = -1;\r\ngoto done;\r\n}\r\n}\r\nif (pkt_type == PKT_TYPE_BAR)\r\nseq_num = ((seq_num + win_size) - 1) & (MAX_TID_VALUE - 1);\r\nif (((end_win < start_win) &&\r\n(seq_num < start_win) && (seq_num > end_win)) ||\r\n((end_win > start_win) && ((seq_num > end_win) ||\r\n(seq_num < start_win)))) {\r\nend_win = seq_num;\r\nif (((seq_num - win_size) + 1) >= 0)\r\nstart_win = (end_win - win_size) + 1;\r\nelse\r\nstart_win = (MAX_TID_VALUE - (win_size - seq_num)) + 1;\r\nmwifiex_11n_dispatch_pkt_until_start_win(priv, tbl, start_win);\r\n}\r\nif (pkt_type != PKT_TYPE_BAR) {\r\nif (seq_num >= start_win)\r\npkt_index = seq_num - start_win;\r\nelse\r\npkt_index = (seq_num+MAX_TID_VALUE) - start_win;\r\nif (tbl->rx_reorder_ptr[pkt_index]) {\r\nret = -1;\r\ngoto done;\r\n}\r\ntbl->rx_reorder_ptr[pkt_index] = payload;\r\n}\r\nmwifiex_11n_scan_and_dispatch(priv, tbl);\r\ndone:\r\nif (!tbl->timer_context.timer_is_set ||\r\nprev_start_win != tbl->start_win)\r\nmwifiex_11n_rxreorder_timer_restart(tbl);\r\nreturn ret;\r\n}\r\nvoid\r\nmwifiex_del_ba_tbl(struct mwifiex_private *priv, int tid, u8 *peer_mac,\r\nu8 type, int initiator)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *tbl;\r\nstruct mwifiex_tx_ba_stream_tbl *ptx_tbl;\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nu8 cleanup_rx_reorder_tbl;\r\nunsigned long flags;\r\nint tid_down;\r\nif (type == TYPE_DELBA_RECEIVE)\r\ncleanup_rx_reorder_tbl = (initiator) ? true : false;\r\nelse\r\ncleanup_rx_reorder_tbl = (initiator) ? false : true;\r\nmwifiex_dbg(priv->adapter, EVENT, "event: DELBA: %pM tid=%d initiator=%d\n",\r\npeer_mac, tid, initiator);\r\nif (cleanup_rx_reorder_tbl) {\r\ntbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,\r\npeer_mac);\r\nif (!tbl) {\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"event: TID, TA not found in table\n");\r\nreturn;\r\n}\r\nmwifiex_del_rx_reorder_entry(priv, tbl);\r\n} else {\r\nptx_tbl = mwifiex_get_ba_tbl(priv, tid, peer_mac);\r\nif (!ptx_tbl) {\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"event: TID, RA not found in table\n");\r\nreturn;\r\n}\r\ntid_down = mwifiex_wmm_downgrade_tid(priv, tid);\r\nra_list = mwifiex_wmm_get_ralist_node(priv, tid_down, peer_mac);\r\nif (ra_list) {\r\nra_list->amsdu_in_ampdu = false;\r\nra_list->ba_status = BA_SETUP_NONE;\r\n}\r\nspin_lock_irqsave(&priv->tx_ba_stream_tbl_lock, flags);\r\nmwifiex_11n_delete_tx_ba_stream_tbl_entry(priv, ptx_tbl);\r\nspin_unlock_irqrestore(&priv->tx_ba_stream_tbl_lock, flags);\r\n}\r\n}\r\nint mwifiex_ret_11n_addba_resp(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_11n_addba_rsp *add_ba_rsp = &resp->params.add_ba_rsp;\r\nint tid, win_size;\r\nstruct mwifiex_rx_reorder_tbl *tbl;\r\nuint16_t block_ack_param_set;\r\nblock_ack_param_set = le16_to_cpu(add_ba_rsp->block_ack_param_set);\r\ntid = (block_ack_param_set & IEEE80211_ADDBA_PARAM_TID_MASK)\r\n>> BLOCKACKPARAM_TID_POS;\r\nif (le16_to_cpu(add_ba_rsp->status_code) != BA_RESULT_SUCCESS) {\r\nmwifiex_dbg(priv->adapter, ERROR, "ADDBA RSP: failed %pM tid=%d)\n",\r\nadd_ba_rsp->peer_mac_addr, tid);\r\ntbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,\r\nadd_ba_rsp->peer_mac_addr);\r\nif (tbl)\r\nmwifiex_del_rx_reorder_entry(priv, tbl);\r\nreturn 0;\r\n}\r\nwin_size = (block_ack_param_set & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK)\r\n>> BLOCKACKPARAM_WINSIZE_POS;\r\ntbl = mwifiex_11n_get_rx_reorder_tbl(priv, tid,\r\nadd_ba_rsp->peer_mac_addr);\r\nif (tbl) {\r\nif ((block_ack_param_set & BLOCKACKPARAM_AMSDU_SUPP_MASK) &&\r\npriv->add_ba_param.rx_amsdu &&\r\n(priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED))\r\ntbl->amsdu = true;\r\nelse\r\ntbl->amsdu = false;\r\n}\r\nmwifiex_dbg(priv->adapter, CMD,\r\n"cmd: ADDBA RSP: %pM tid=%d ssn=%d win_size=%d\n",\r\nadd_ba_rsp->peer_mac_addr, tid, add_ba_rsp->ssn, win_size);\r\nreturn 0;\r\n}\r\nvoid mwifiex_11n_ba_stream_timeout(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_11n_batimeout *event)\r\n{\r\nstruct host_cmd_ds_11n_delba delba;\r\nmemset(&delba, 0, sizeof(struct host_cmd_ds_11n_delba));\r\nmemcpy(delba.peer_mac_addr, event->peer_mac_addr, ETH_ALEN);\r\ndelba.del_ba_param_set |=\r\ncpu_to_le16((u16) event->tid << DELBA_TID_POS);\r\ndelba.del_ba_param_set |= cpu_to_le16(\r\n(u16) event->origninator << DELBA_INITIATOR_POS);\r\ndelba.reason_code = cpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\r\nmwifiex_send_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, &delba, false);\r\n}\r\nvoid mwifiex_11n_cleanup_reorder_tbl(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_rx_reorder_tbl *del_tbl_ptr, *tmp_node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\nlist_for_each_entry_safe(del_tbl_ptr, tmp_node,\r\n&priv->rx_reorder_tbl_ptr, list) {\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nmwifiex_del_rx_reorder_entry(priv, del_tbl_ptr);\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, flags);\r\n}\r\nINIT_LIST_HEAD(&priv->rx_reorder_tbl_ptr);\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, flags);\r\nmwifiex_reset_11n_rx_seq_num(priv);\r\n}\r\nvoid mwifiex_update_rxreor_flags(struct mwifiex_adapter *adapter, u8 flags)\r\n{\r\nstruct mwifiex_private *priv;\r\nstruct mwifiex_rx_reorder_tbl *tbl;\r\nunsigned long lock_flags;\r\nint i;\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\npriv = adapter->priv[i];\r\nif (!priv)\r\ncontinue;\r\nspin_lock_irqsave(&priv->rx_reorder_tbl_lock, lock_flags);\r\nif (list_empty(&priv->rx_reorder_tbl_ptr)) {\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock,\r\nlock_flags);\r\ncontinue;\r\n}\r\nlist_for_each_entry(tbl, &priv->rx_reorder_tbl_ptr, list)\r\ntbl->flags = flags;\r\nspin_unlock_irqrestore(&priv->rx_reorder_tbl_lock, lock_flags);\r\n}\r\nreturn;\r\n}\r\nstatic void mwifiex_update_ampdu_rxwinsize(struct mwifiex_adapter *adapter,\r\nbool coex_flag)\r\n{\r\nu8 i;\r\nu32 rx_win_size;\r\nstruct mwifiex_private *priv;\r\ndev_dbg(adapter->dev, "Update rxwinsize %d\n", coex_flag);\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\nif (!adapter->priv[i])\r\ncontinue;\r\npriv = adapter->priv[i];\r\nrx_win_size = priv->add_ba_param.rx_win_size;\r\nif (coex_flag) {\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_STA)\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_STA_COEX_AMPDU_DEF_RXWINSIZE;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P)\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_STA_COEX_AMPDU_DEF_RXWINSIZE;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP)\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_UAP_COEX_AMPDU_DEF_RXWINSIZE;\r\n} else {\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_STA)\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_STA_AMPDU_DEF_RXWINSIZE;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_P2P)\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_STA_AMPDU_DEF_RXWINSIZE;\r\nif (priv->bss_type == MWIFIEX_BSS_TYPE_UAP)\r\npriv->add_ba_param.rx_win_size =\r\nMWIFIEX_UAP_AMPDU_DEF_RXWINSIZE;\r\n}\r\nif (adapter->coex_win_size && adapter->coex_rx_win_size)\r\npriv->add_ba_param.rx_win_size =\r\nadapter->coex_rx_win_size;\r\nif (rx_win_size != priv->add_ba_param.rx_win_size) {\r\nif (!priv->media_connected)\r\ncontinue;\r\nfor (i = 0; i < MAX_NUM_TID; i++)\r\nmwifiex_11n_delba(priv, i);\r\n}\r\n}\r\n}\r\nvoid mwifiex_coex_ampdu_rxwinsize(struct mwifiex_adapter *adapter)\r\n{\r\nu8 i;\r\nstruct mwifiex_private *priv;\r\nu8 count = 0;\r\nfor (i = 0; i < adapter->priv_num; i++) {\r\nif (adapter->priv[i]) {\r\npriv = adapter->priv[i];\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA) {\r\nif (priv->media_connected)\r\ncount++;\r\n}\r\nif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\r\nif (priv->bss_started)\r\ncount++;\r\n}\r\n}\r\nif (count >= MWIFIEX_BSS_COEX_COUNT)\r\nbreak;\r\n}\r\nif (count >= MWIFIEX_BSS_COEX_COUNT)\r\nmwifiex_update_ampdu_rxwinsize(adapter, true);\r\nelse\r\nmwifiex_update_ampdu_rxwinsize(adapter, false);\r\n}
