void card_bootload(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nunsigned long flags;\r\nu32 *pdata;\r\nu32 size;\r\nu32 i;\r\nu32 templong;\r\nnetdev_dbg(dev, "card_bootload is called\n");\r\npdata = (u32 *)bootimage;\r\nsize = sizeof(bootimage);\r\nif (size & 0x0003)\r\nsize += 4;\r\nspin_lock_irqsave(&info->dpram_lock, flags);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, FT1000_DPRAM_BASE);\r\nfor (i = 0; i < (size >> 2); i++) {\r\ntemplong = *pdata++;\r\noutl(templong, dev->base_addr + FT1000_REG_MAG_DPDATA);\r\n}\r\nspin_unlock_irqrestore(&info->dpram_lock, flags);\r\n}\r\nu16 get_handshake(struct net_device *dev, u16 expected_value)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 handshake;\r\nu32 tempx;\r\nint loopcnt;\r\nloopcnt = 0;\r\nwhile (loopcnt < MAX_DSP_WAIT_LOOPS) {\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nDWNLD_HANDSHAKE_LOC);\r\nhandshake = ft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\n} else {\r\ntempx =\r\nntohl(ft1000_read_dpram_mag_32\r\n(dev, DWNLD_MAG_HANDSHAKE_LOC));\r\nhandshake = (u16)tempx;\r\n}\r\nif ((handshake == expected_value)\r\n|| (handshake == HANDSHAKE_RESET_VALUE)) {\r\nreturn handshake;\r\n}\r\nloopcnt++;\r\nmdelay(DSP_WAIT_SLEEP_TIME);\r\n}\r\nreturn HANDSHAKE_TIMEOUT_VALUE;\r\n}\r\nvoid put_handshake(struct net_device *dev, u16 handshake_value)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu32 tempx;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nDWNLD_HANDSHAKE_LOC);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, handshake_value);\r\n} else {\r\ntempx = (u32)handshake_value;\r\ntempx = ntohl(tempx);\r\nft1000_write_dpram_mag_32(dev, DWNLD_MAG_HANDSHAKE_LOC, tempx);\r\n}\r\n}\r\nu16 get_request_type(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 request_type;\r\nu32 tempx;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR, DWNLD_TYPE_LOC);\r\nrequest_type = ft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\n} else {\r\ntempx = ft1000_read_dpram_mag_32(dev, DWNLD_MAG_TYPE_LOC);\r\ntempx = ntohl(tempx);\r\nrequest_type = (u16)tempx;\r\n}\r\nreturn request_type;\r\n}\r\nlong get_request_value(struct net_device *dev)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nlong value;\r\nu16 w_val;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nDWNLD_SIZE_MSW_LOC);\r\nw_val = ft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\nvalue = (long)(w_val << 16);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nDWNLD_SIZE_LSW_LOC);\r\nw_val = ft1000_read_reg(dev, FT1000_REG_DPRAM_DATA);\r\nvalue = (long)(value | w_val);\r\n} else {\r\nvalue = ft1000_read_dpram_mag_32(dev, DWNLD_MAG_SIZE_LOC);\r\nvalue = ntohl(value);\r\n}\r\nreturn value;\r\n}\r\nvoid put_request_value(struct net_device *dev, long lvalue)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nu16 size;\r\nu32 tempx;\r\nif (info->AsicID == ELECTRABUZZ_ID) {\r\nsize = (u16) (lvalue >> 16);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nDWNLD_SIZE_MSW_LOC);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, size);\r\nsize = (u16) (lvalue);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_ADDR,\r\nDWNLD_SIZE_LSW_LOC);\r\nft1000_write_reg(dev, FT1000_REG_DPRAM_DATA, size);\r\n} else {\r\ntempx = ntohl(lvalue);\r\nft1000_write_dpram_mag_32(dev, DWNLD_MAG_SIZE_LOC, tempx);\r\n}\r\n}\r\nu16 hdr_checksum(struct pseudo_hdr *pHdr)\r\n{\r\nu16 *usPtr = (u16 *)pHdr;\r\nu16 chksum;\r\nchksum = (((((usPtr[0] ^ usPtr[1]) ^ usPtr[2]) ^ usPtr[3]) ^\r\nusPtr[4]) ^ usPtr[5]) ^ usPtr[6];\r\nreturn chksum;\r\n}\r\nint card_download(struct net_device *dev, const u8 *pFileStart,\r\nsize_t FileLength)\r\n{\r\nstruct ft1000_info *info = netdev_priv(dev);\r\nint Status = SUCCESS;\r\nu32 uiState;\r\nu16 handshake;\r\nstruct pseudo_hdr *pHdr;\r\nu16 usHdrLength;\r\nlong word_length;\r\nu16 request;\r\nu16 temp;\r\nstruct prov_record *pprov_record;\r\nu8 *pbuffer;\r\nstruct dsp_file_hdr *pFileHdr5;\r\nstruct dsp_image_info *pDspImageInfoV6 = NULL;\r\nlong requested_version;\r\nbool bGoodVersion = false;\r\nstruct drv_msg *pMailBoxData;\r\nu16 *pUsData = NULL;\r\nu16 *pUsFile = NULL;\r\nu8 *pUcFile = NULL;\r\nu8 *pBootEnd = NULL;\r\nu8 *pCodeEnd = NULL;\r\nint imageN;\r\nlong file_version;\r\nlong loader_code_address = 0;\r\nlong loader_code_size = 0;\r\nlong run_address = 0;\r\nlong run_size = 0;\r\nunsigned long flags;\r\nunsigned long templong;\r\nunsigned long image_chksum = 0;\r\nfile_version = *(long *)pFileStart;\r\nif (file_version != 6) {\r\npr_err("unsupported firmware version %ld\n", file_version);\r\nStatus = FAILURE;\r\n}\r\nuiState = STATE_START_DWNLD;\r\npFileHdr5 = (struct dsp_file_hdr *)pFileStart;\r\npUsFile = (u16 *) ((long)pFileStart + pFileHdr5->loader_offset);\r\npUcFile = (u8 *) ((long)pFileStart + pFileHdr5->loader_offset);\r\npBootEnd = (u8 *) ((long)pFileStart + pFileHdr5->loader_code_end);\r\nloader_code_address = pFileHdr5->loader_code_address;\r\nloader_code_size = pFileHdr5->loader_code_size;\r\nbGoodVersion = false;\r\nwhile ((Status == SUCCESS) && (uiState != STATE_DONE_FILE)) {\r\nswitch (uiState) {\r\ncase STATE_START_DWNLD:\r\nhandshake = get_handshake(dev, HANDSHAKE_DSP_BL_READY);\r\nif (handshake == HANDSHAKE_DSP_BL_READY)\r\nput_handshake(dev, HANDSHAKE_DRIVER_READY);\r\nelse\r\nStatus = FAILURE;\r\nuiState = STATE_BOOT_DWNLD;\r\nbreak;\r\ncase STATE_BOOT_DWNLD:\r\nhandshake = get_handshake(dev, HANDSHAKE_REQUEST);\r\nif (handshake == HANDSHAKE_REQUEST) {\r\nrequest = get_request_type(dev);\r\nswitch (request) {\r\ncase REQUEST_RUN_ADDRESS:\r\nput_request_value(dev,\r\nloader_code_address);\r\nbreak;\r\ncase REQUEST_CODE_LENGTH:\r\nput_request_value(dev,\r\nloader_code_size);\r\nbreak;\r\ncase REQUEST_DONE_BL:\r\npUsFile = (u16 *) ((long)pBootEnd);\r\npUcFile = (u8 *) ((long)pBootEnd);\r\nuiState = STATE_CODE_DWNLD;\r\nbreak;\r\ncase REQUEST_CODE_SEGMENT:\r\nword_length = get_request_value(dev);\r\nif (word_length > MAX_LENGTH) {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nif ((word_length * 2 + (long)pUcFile) >\r\n(long)pBootEnd) {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&info->dpram_lock,\r\nflags);\r\noutw(DWNLD_MAG_PS_HDR_LOC,\r\ndev->base_addr +\r\nFT1000_REG_DPRAM_ADDR);\r\nif (word_length & 0x01)\r\nword_length++;\r\nword_length = word_length / 2;\r\nfor (; word_length > 0; word_length--) {\r\ntemplong = *pUsFile++;\r\ntemplong |=\r\n(*pUsFile++ << 16);\r\npUcFile += 4;\r\noutl(templong,\r\ndev->base_addr +\r\nFT1000_REG_MAG_DPDATAL);\r\n}\r\nspin_unlock_irqrestore(&info->\r\ndpram_lock,\r\nflags);\r\nbreak;\r\ndefault:\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nput_handshake(dev, HANDSHAKE_RESPONSE);\r\n} else {\r\nStatus = FAILURE;\r\n}\r\nbreak;\r\ncase STATE_CODE_DWNLD:\r\nhandshake = get_handshake(dev, HANDSHAKE_REQUEST);\r\nif (handshake == HANDSHAKE_REQUEST) {\r\nrequest = get_request_type(dev);\r\nswitch (request) {\r\ncase REQUEST_FILE_CHECKSUM:\r\nnetdev_dbg(dev,\r\n"ft1000_dnld: REQUEST_FOR_CHECKSUM\n");\r\nput_request_value(dev, image_chksum);\r\nbreak;\r\ncase REQUEST_RUN_ADDRESS:\r\nif (bGoodVersion) {\r\nput_request_value(dev,\r\nrun_address);\r\n} else {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nbreak;\r\ncase REQUEST_CODE_LENGTH:\r\nif (bGoodVersion) {\r\nput_request_value(dev,\r\nrun_size);\r\n} else {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nbreak;\r\ncase REQUEST_DONE_CL:\r\npUsFile = (u16 *) ((long)pFileStart + pFileHdr5->commands_offset);\r\npUcFile = (u8 *) ((long)pFileStart + pFileHdr5->commands_offset);\r\nuiState = STATE_DONE_DWNLD;\r\nbreak;\r\ncase REQUEST_CODE_SEGMENT:\r\nif (!bGoodVersion) {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nword_length = get_request_value(dev);\r\nif (word_length > MAX_LENGTH) {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nif ((word_length * 2 + (long)pUcFile) >\r\n(long)pCodeEnd) {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\noutw(DWNLD_MAG_PS_HDR_LOC,\r\ndev->base_addr +\r\nFT1000_REG_DPRAM_ADDR);\r\nif (word_length & 0x01)\r\nword_length++;\r\nword_length = word_length / 2;\r\nfor (; word_length > 0; word_length--) {\r\ntemplong = *pUsFile++;\r\ntemplong |=\r\n(*pUsFile++ << 16);\r\npUcFile += 4;\r\noutl(templong,\r\ndev->base_addr +\r\nFT1000_REG_MAG_DPDATAL);\r\n}\r\nbreak;\r\ncase REQUEST_MAILBOX_DATA:\r\nword_length =\r\n(long)(info->DSPInfoBlklen + 1) / 2;\r\nput_request_value(dev, word_length);\r\npMailBoxData =\r\n(struct drv_msg *)&info->DSPInfoBlk[0];\r\npUsData =\r\n(u16 *)&pMailBoxData->data[0];\r\nspin_lock_irqsave(&info->dpram_lock,\r\nflags);\r\nif (file_version == 5) {\r\nft1000_write_reg(dev,\r\nFT1000_REG_DPRAM_ADDR,\r\nDWNLD_PS_HDR_LOC);\r\nfor (; word_length > 0; word_length--) {\r\ntemp = ntohs(*pUsData);\r\nft1000_write_reg(dev,\r\nFT1000_REG_DPRAM_DATA,\r\ntemp);\r\npUsData++;\r\n}\r\n} else {\r\noutw(DWNLD_MAG_PS_HDR_LOC,\r\ndev->base_addr +\r\nFT1000_REG_DPRAM_ADDR);\r\nif (word_length & 0x01)\r\nword_length++;\r\nword_length = word_length / 2;\r\nfor (; word_length > 0; word_length--) {\r\ntemplong = *pUsData++;\r\ntemplong |=\r\n(*pUsData++ << 16);\r\noutl(templong,\r\ndev->base_addr +\r\nFT1000_REG_MAG_DPDATAL);\r\n}\r\n}\r\nspin_unlock_irqrestore(&info->\r\ndpram_lock,\r\nflags);\r\nbreak;\r\ncase REQUEST_VERSION_INFO:\r\nword_length =\r\npFileHdr5->version_data_size;\r\nput_request_value(dev, word_length);\r\npUsFile =\r\n(u16 *) ((long)pFileStart +\r\npFileHdr5->\r\nversion_data_offset);\r\nspin_lock_irqsave(&info->dpram_lock,\r\nflags);\r\noutw(DWNLD_MAG_PS_HDR_LOC,\r\ndev->base_addr +\r\nFT1000_REG_DPRAM_ADDR);\r\nif (word_length & 0x01)\r\nword_length++;\r\nword_length = word_length / 2;\r\nfor (; word_length > 0; word_length--) {\r\ntemplong =\r\nntohs(*pUsFile++);\r\ntemp =\r\nntohs(*pUsFile++);\r\ntemplong |=\r\n(temp << 16);\r\noutl(templong,\r\ndev->base_addr +\r\nFT1000_REG_MAG_DPDATAL);\r\n}\r\nspin_unlock_irqrestore(&info->\r\ndpram_lock,\r\nflags);\r\nbreak;\r\ncase REQUEST_CODE_BY_VERSION:\r\nbGoodVersion = false;\r\nrequested_version =\r\nget_request_value(dev);\r\npDspImageInfoV6 =\r\n(struct dsp_image_info *) ((long)\r\npFileStart\r\n+\r\nsizeof\r\n(struct dsp_file_hdr));\r\nfor (imageN = 0;\r\nimageN <\r\npFileHdr5->nDspImages;\r\nimageN++) {\r\ntemp = (u16)\r\n(pDspImageInfoV6->\r\nversion);\r\ntemplong = temp;\r\ntemp = (u16)\r\n(pDspImageInfoV6->\r\nversion >> 16);\r\ntemplong |=\r\n(temp << 16);\r\nif (templong ==\r\nrequested_version) {\r\nbGoodVersion =\r\ntrue;\r\npUsFile =\r\n(u16\r\n*) ((long)\r\npFileStart\r\n+\r\npDspImageInfoV6->\r\nbegin_offset);\r\npUcFile =\r\n(u8\r\n*) ((long)\r\npFileStart\r\n+\r\npDspImageInfoV6->\r\nbegin_offset);\r\npCodeEnd =\r\n(u8\r\n*) ((long)\r\npFileStart\r\n+\r\npDspImageInfoV6->\r\nend_offset);\r\nrun_address =\r\npDspImageInfoV6->\r\nrun_address;\r\nrun_size =\r\npDspImageInfoV6->\r\nimage_size;\r\nimage_chksum =\r\n(u32)\r\npDspImageInfoV6->\r\nchecksum;\r\nnetdev_dbg(dev,\r\n"ft1000_dnld: image_chksum = 0x%8x\n",\r\n(unsigned\r\nint)\r\nimage_chksum);\r\nbreak;\r\n}\r\npDspImageInfoV6++;\r\n}\r\nif (!bGoodVersion) {\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\nput_handshake(dev, HANDSHAKE_RESPONSE);\r\n} else {\r\nStatus = FAILURE;\r\n}\r\nbreak;\r\ncase STATE_DONE_DWNLD:\r\nif (((unsigned long)(pUcFile) - (unsigned long) pFileStart) >=\r\n(unsigned long)FileLength) {\r\nuiState = STATE_DONE_FILE;\r\nbreak;\r\n}\r\npHdr = (struct pseudo_hdr *)pUsFile;\r\nif (pHdr->portdest == 0x80\r\n&& (pHdr->portsrc == 0x00\r\n|| pHdr->portsrc == 0x10 )) {\r\nuiState = STATE_SECTION_PROV;\r\n} else {\r\nnetdev_dbg(dev,\r\n"Download error: Bad Port IDs in Pseudo Record\n");\r\nnetdev_dbg(dev, "\t Port Source = 0x%2.2x\n",\r\npHdr->portsrc);\r\nnetdev_dbg(dev, "\t Port Destination = 0x%2.2x\n",\r\npHdr->portdest);\r\nStatus = FAILURE;\r\n}\r\nbreak;\r\ncase STATE_SECTION_PROV:\r\npHdr = (struct pseudo_hdr *)pUcFile;\r\nif (pHdr->checksum == hdr_checksum(pHdr)) {\r\nif (pHdr->portdest != 0x80 ) {\r\nuiState = STATE_DONE_PROV;\r\nbreak;\r\n}\r\nusHdrLength = ntohs(pHdr->length);\r\npbuffer =\r\nkmalloc(usHdrLength + sizeof(struct pseudo_hdr),\r\nGFP_ATOMIC);\r\nif (pbuffer) {\r\nmemcpy(pbuffer, pUcFile,\r\n(u32) (usHdrLength +\r\nsizeof(struct pseudo_hdr)));\r\npprov_record =\r\nkmalloc(sizeof(struct prov_record),\r\nGFP_ATOMIC);\r\nif (pprov_record) {\r\npprov_record->pprov_data =\r\npbuffer;\r\nlist_add_tail(&pprov_record->\r\nlist,\r\n&info->prov_list);\r\npUcFile =\r\n(u8 *)((unsigned long) pUcFile +\r\n(unsigned long) ((usHdrLength + 1) & 0xFFFFFFFE) + sizeof(struct pseudo_hdr));\r\nif ((unsigned long) (pUcFile) -\r\n(unsigned long) (pFileStart) >=\r\n(unsigned long)FileLength) {\r\nuiState =\r\nSTATE_DONE_FILE;\r\n}\r\n} else {\r\nkfree(pbuffer);\r\nStatus = FAILURE;\r\n}\r\n} else {\r\nStatus = FAILURE;\r\n}\r\n} else {\r\nStatus = FAILURE;\r\n}\r\nbreak;\r\ncase STATE_DONE_PROV:\r\nuiState = STATE_DONE_FILE;\r\nbreak;\r\ndefault:\r\nStatus = FAILURE;\r\nbreak;\r\n}\r\n}\r\nreturn Status;\r\n}
