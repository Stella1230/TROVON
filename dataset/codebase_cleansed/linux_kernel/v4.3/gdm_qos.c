static void init_qos_entry_list(void)\r\n{\r\nqos_free_list.cnt = 0;\r\nINIT_LIST_HEAD(&qos_free_list.head);\r\nspin_lock_init(&qos_free_list.lock);\r\n}\r\nstatic void *alloc_qos_entry(void)\r\n{\r\nstruct qos_entry_s *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&qos_free_list.lock, flags);\r\nif (qos_free_list.cnt) {\r\nentry = list_entry(qos_free_list.head.prev, struct qos_entry_s,\r\nlist);\r\nlist_del(&entry->list);\r\nqos_free_list.cnt--;\r\nspin_unlock_irqrestore(&qos_free_list.lock, flags);\r\nreturn entry;\r\n}\r\nspin_unlock_irqrestore(&qos_free_list.lock, flags);\r\nreturn kmalloc(sizeof(*entry), GFP_ATOMIC);\r\n}\r\nstatic void free_qos_entry(void *entry)\r\n{\r\nstruct qos_entry_s *qentry = (struct qos_entry_s *)entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&qos_free_list.lock, flags);\r\nif (qos_free_list.cnt < MAX_FREE_LIST_CNT) {\r\nlist_add(&qentry->list, &qos_free_list.head);\r\nqos_free_list.cnt++;\r\nspin_unlock_irqrestore(&qos_free_list.lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&qos_free_list.lock, flags);\r\nkfree(entry);\r\n}\r\nstatic void free_qos_entry_list(struct list_head *free_list)\r\n{\r\nstruct qos_entry_s *entry, *n;\r\nint total_free = 0;\r\nlist_for_each_entry_safe(entry, n, free_list, list) {\r\nlist_del(&entry->list);\r\nkfree(entry);\r\ntotal_free++;\r\n}\r\npr_debug("%s: total_free_cnt=%d\n", __func__, total_free);\r\n}\r\nvoid gdm_qos_init(void *nic_ptr)\r\n{\r\nstruct nic *nic = nic_ptr;\r\nstruct qos_cb_s *qcb = &nic->qos;\r\nint i;\r\nfor (i = 0; i < QOS_MAX; i++) {\r\nINIT_LIST_HEAD(&qcb->qos_list[i]);\r\nqcb->csr[i].qos_buf_count = 0;\r\nqcb->csr[i].enabled = false;\r\n}\r\nqcb->qos_list_cnt = 0;\r\nqcb->qos_null_idx = QOS_MAX-1;\r\nqcb->qos_limit_size = 255;\r\nspin_lock_init(&qcb->qos_lock);\r\ninit_qos_entry_list();\r\n}\r\nvoid gdm_qos_release_list(void *nic_ptr)\r\n{\r\nstruct nic *nic = nic_ptr;\r\nstruct qos_cb_s *qcb = &nic->qos;\r\nunsigned long flags;\r\nstruct qos_entry_s *entry, *n;\r\nstruct list_head free_list;\r\nint i;\r\nINIT_LIST_HEAD(&free_list);\r\nspin_lock_irqsave(&qcb->qos_lock, flags);\r\nfor (i = 0; i < QOS_MAX; i++) {\r\nqcb->csr[i].qos_buf_count = 0;\r\nqcb->csr[i].enabled = false;\r\n}\r\nqcb->qos_list_cnt = 0;\r\nqcb->qos_null_idx = QOS_MAX-1;\r\nfor (i = 0; i < QOS_MAX; i++) {\r\nlist_for_each_entry_safe(entry, n, &qcb->qos_list[i], list) {\r\nlist_move_tail(&entry->list, &free_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\nfree_qos_entry_list(&free_list);\r\n}\r\nstatic int chk_ipv4_rule(struct gdm_wimax_csr_s *csr, u8 *stream, u8 *port)\r\n{\r\nint i;\r\nif (csr->classifier_rule_en&IPTYPEOFSERVICE) {\r\nif (((stream[1] & csr->ip2s_mask) < csr->ip2s_lo) ||\r\n((stream[1] & csr->ip2s_mask) > csr->ip2s_hi))\r\nreturn 1;\r\n}\r\nif (csr->classifier_rule_en&PROTOCOL) {\r\nif (stream[9] != csr->protocol)\r\nreturn 1;\r\n}\r\nif (csr->classifier_rule_en&IPMASKEDSRCADDRESS) {\r\nfor (i = 0; i < 4; i++) {\r\nif ((stream[12 + i] & csr->ipsrc_addrmask[i]) !=\r\n(csr->ipsrc_addr[i] & csr->ipsrc_addrmask[i]))\r\nreturn 1;\r\n}\r\n}\r\nif (csr->classifier_rule_en&IPMASKEDDSTADDRESS) {\r\nfor (i = 0; i < 4; i++) {\r\nif ((stream[16 + i] & csr->ipdst_addrmask[i]) !=\r\n(csr->ipdst_addr[i] & csr->ipdst_addrmask[i]))\r\nreturn 1;\r\n}\r\n}\r\nif (csr->classifier_rule_en&PROTOCOLSRCPORTRANGE) {\r\ni = ((port[0]<<8)&0xff00)+port[1];\r\nif ((i < csr->srcport_lo) || (i > csr->srcport_hi))\r\nreturn 1;\r\n}\r\nif (csr->classifier_rule_en&PROTOCOLDSTPORTRANGE) {\r\ni = ((port[2]<<8)&0xff00)+port[3];\r\nif ((i < csr->dstport_lo) || (i > csr->dstport_hi))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_qos_index(struct nic *nic, u8 *iph, u8 *tcpudph)\r\n{\r\nint ip_ver, i;\r\nstruct qos_cb_s *qcb = &nic->qos;\r\nif (iph == NULL || tcpudph == NULL)\r\nreturn -1;\r\nip_ver = (iph[0]>>4)&0xf;\r\nif (ip_ver != 4)\r\nreturn -1;\r\nfor (i = 0; i < QOS_MAX; i++) {\r\nif (!qcb->csr[i].enabled)\r\ncontinue;\r\nif (!qcb->csr[i].classifier_rule_en)\r\ncontinue;\r\nif (chk_ipv4_rule(&qcb->csr[i], iph, tcpudph) == 0)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic void extract_qos_list(struct nic *nic, struct list_head *head)\r\n{\r\nstruct qos_cb_s *qcb = &nic->qos;\r\nstruct qos_entry_s *entry;\r\nint i;\r\nINIT_LIST_HEAD(head);\r\nfor (i = 0; i < QOS_MAX; i++) {\r\nif (!qcb->csr[i].enabled)\r\ncontinue;\r\nif (qcb->csr[i].qos_buf_count >= qcb->qos_limit_size)\r\ncontinue;\r\nif (list_empty(&qcb->qos_list[i]))\r\ncontinue;\r\nentry = list_entry(qcb->qos_list[i].prev, struct qos_entry_s,\r\nlist);\r\nlist_move_tail(&entry->list, head);\r\nqcb->csr[i].qos_buf_count++;\r\nif (!list_empty(&qcb->qos_list[i]))\r\nnetdev_warn(nic->netdev, "Index(%d) is piled!!\n", i);\r\n}\r\n}\r\nstatic void send_qos_list(struct nic *nic, struct list_head *head)\r\n{\r\nstruct qos_entry_s *entry, *n;\r\nlist_for_each_entry_safe(entry, n, head, list) {\r\nlist_del(&entry->list);\r\ngdm_wimax_send_tx(entry->skb, entry->dev);\r\nfree_qos_entry(entry);\r\n}\r\n}\r\nint gdm_qos_send_hci_pkt(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nint index;\r\nstruct qos_cb_s *qcb = &nic->qos;\r\nunsigned long flags;\r\nstruct ethhdr *ethh = (struct ethhdr *)(skb->data + HCI_HEADER_SIZE);\r\nstruct iphdr *iph = (struct iphdr *)((char *)ethh + ETH_HLEN);\r\nstruct tcphdr *tcph;\r\nstruct qos_entry_s *entry = NULL;\r\nstruct list_head send_list;\r\nint ret = 0;\r\ntcph = (struct tcphdr *)iph + iph->ihl*4;\r\nif (ethh->h_proto == cpu_to_be16(ETH_P_IP)) {\r\nif (qcb->qos_list_cnt && !qos_free_list.cnt) {\r\nentry = alloc_qos_entry();\r\nentry->skb = skb;\r\nentry->dev = dev;\r\nnetdev_dbg(dev, "qcb->qos_list_cnt=%d\n",\r\nqcb->qos_list_cnt);\r\n}\r\nspin_lock_irqsave(&qcb->qos_lock, flags);\r\nif (qcb->qos_list_cnt) {\r\nindex = get_qos_index(nic, (u8 *)iph, (u8 *)tcph);\r\nif (index == -1)\r\nindex = qcb->qos_null_idx;\r\nif (!entry) {\r\nentry = alloc_qos_entry();\r\nentry->skb = skb;\r\nentry->dev = dev;\r\n}\r\nlist_add_tail(&entry->list, &qcb->qos_list[index]);\r\nextract_qos_list(nic, &send_list);\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\nsend_qos_list(nic, &send_list);\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\nif (entry)\r\nfree_qos_entry(entry);\r\n}\r\nret = gdm_wimax_send_tx(skb, dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int get_csr(struct qos_cb_s *qcb, u32 sfid, int mode)\r\n{\r\nint i;\r\nfor (i = 0; i < qcb->qos_list_cnt; i++) {\r\nif (qcb->csr[i].sfid == sfid)\r\nreturn i;\r\n}\r\nif (mode) {\r\nfor (i = 0; i < QOS_MAX; i++) {\r\nif (!qcb->csr[i].enabled) {\r\nqcb->csr[i].enabled = true;\r\nqcb->qos_list_cnt++;\r\nreturn i;\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nvoid gdm_recv_qos_hci_packet(void *nic_ptr, u8 *buf, int size)\r\n{\r\nstruct nic *nic = nic_ptr;\r\nint i, index, pos;\r\nu32 sfid;\r\nu8 sub_cmd_evt;\r\nstruct qos_cb_s *qcb = &nic->qos;\r\nstruct qos_entry_s *entry, *n;\r\nstruct list_head send_list;\r\nstruct list_head free_list;\r\nunsigned long flags;\r\nsub_cmd_evt = (u8)buf[4];\r\nif (sub_cmd_evt == QOS_REPORT) {\r\nspin_lock_irqsave(&qcb->qos_lock, flags);\r\nfor (i = 0; i < qcb->qos_list_cnt; i++) {\r\nsfid = ((buf[(i*5)+6]<<24)&0xff000000);\r\nsfid += ((buf[(i*5)+7]<<16)&0xff0000);\r\nsfid += ((buf[(i*5)+8]<<8)&0xff00);\r\nsfid += (buf[(i*5)+9]);\r\nindex = get_csr(qcb, sfid, 0);\r\nif (index == -1) {\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\nnetdev_err(nic->netdev, "QoS ERROR: No SF\n");\r\nreturn;\r\n}\r\nqcb->csr[index].qos_buf_count = buf[(i*5)+10];\r\n}\r\nextract_qos_list(nic, &send_list);\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\nsend_qos_list(nic, &send_list);\r\nreturn;\r\n}\r\npos = 6;\r\nsfid = ((buf[pos++]<<24)&0xff000000);\r\nsfid += ((buf[pos++]<<16)&0xff0000);\r\nsfid += ((buf[pos++]<<8)&0xff00);\r\nsfid += (buf[pos++]);\r\nindex = get_csr(qcb, sfid, 1);\r\nif (index == -1) {\r\nnetdev_err(nic->netdev,\r\n"QoS ERROR: csr Update Error / Wrong index (%d)\n",\r\nindex);\r\nreturn;\r\n}\r\nif (sub_cmd_evt == QOS_ADD) {\r\nnetdev_dbg(nic->netdev, "QOS_ADD SFID = 0x%x, index=%d\n",\r\nsfid, index);\r\nspin_lock_irqsave(&qcb->qos_lock, flags);\r\nqcb->csr[index].sfid = sfid;\r\nqcb->csr[index].classifier_rule_en = ((buf[pos++]<<8)&0xff00);\r\nqcb->csr[index].classifier_rule_en += buf[pos++];\r\nif (qcb->csr[index].classifier_rule_en == 0)\r\nqcb->qos_null_idx = index;\r\nqcb->csr[index].ip2s_mask = buf[pos++];\r\nqcb->csr[index].ip2s_lo = buf[pos++];\r\nqcb->csr[index].ip2s_hi = buf[pos++];\r\nqcb->csr[index].protocol = buf[pos++];\r\nqcb->csr[index].ipsrc_addrmask[0] = buf[pos++];\r\nqcb->csr[index].ipsrc_addrmask[1] = buf[pos++];\r\nqcb->csr[index].ipsrc_addrmask[2] = buf[pos++];\r\nqcb->csr[index].ipsrc_addrmask[3] = buf[pos++];\r\nqcb->csr[index].ipsrc_addr[0] = buf[pos++];\r\nqcb->csr[index].ipsrc_addr[1] = buf[pos++];\r\nqcb->csr[index].ipsrc_addr[2] = buf[pos++];\r\nqcb->csr[index].ipsrc_addr[3] = buf[pos++];\r\nqcb->csr[index].ipdst_addrmask[0] = buf[pos++];\r\nqcb->csr[index].ipdst_addrmask[1] = buf[pos++];\r\nqcb->csr[index].ipdst_addrmask[2] = buf[pos++];\r\nqcb->csr[index].ipdst_addrmask[3] = buf[pos++];\r\nqcb->csr[index].ipdst_addr[0] = buf[pos++];\r\nqcb->csr[index].ipdst_addr[1] = buf[pos++];\r\nqcb->csr[index].ipdst_addr[2] = buf[pos++];\r\nqcb->csr[index].ipdst_addr[3] = buf[pos++];\r\nqcb->csr[index].srcport_lo = ((buf[pos++]<<8)&0xff00);\r\nqcb->csr[index].srcport_lo += buf[pos++];\r\nqcb->csr[index].srcport_hi = ((buf[pos++]<<8)&0xff00);\r\nqcb->csr[index].srcport_hi += buf[pos++];\r\nqcb->csr[index].dstport_lo = ((buf[pos++]<<8)&0xff00);\r\nqcb->csr[index].dstport_lo += buf[pos++];\r\nqcb->csr[index].dstport_hi = ((buf[pos++]<<8)&0xff00);\r\nqcb->csr[index].dstport_hi += buf[pos++];\r\nqcb->qos_limit_size = 254/qcb->qos_list_cnt;\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\n} else if (sub_cmd_evt == QOS_CHANGE_DEL) {\r\nnetdev_dbg(nic->netdev, "QOS_CHANGE_DEL SFID = 0x%x, index=%d\n",\r\nsfid, index);\r\nINIT_LIST_HEAD(&free_list);\r\nspin_lock_irqsave(&qcb->qos_lock, flags);\r\nqcb->csr[index].enabled = false;\r\nqcb->qos_list_cnt--;\r\nqcb->qos_limit_size = 254/qcb->qos_list_cnt;\r\nlist_for_each_entry_safe(entry, n, &qcb->qos_list[index],\r\nlist) {\r\nlist_move_tail(&entry->list, &free_list);\r\n}\r\nspin_unlock_irqrestore(&qcb->qos_lock, flags);\r\nfree_qos_entry_list(&free_list);\r\n}\r\n}
