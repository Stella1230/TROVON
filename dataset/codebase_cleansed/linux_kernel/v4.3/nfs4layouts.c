static inline u32 devid_hashfn(u64 idx)\r\n{\r\nreturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\r\n}\r\nstatic void\r\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\r\n{\r\nconst struct knfsd_fh *fh = &fhp->fh_handle;\r\nsize_t fsid_len = key_len(fh->fh_fsid_type);\r\nstruct nfsd4_deviceid_map *map, *old;\r\nint i;\r\nmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\r\nif (!map)\r\nreturn;\r\nmap->fsid_type = fh->fh_fsid_type;\r\nmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\r\nspin_lock(&nfsd_devid_lock);\r\nif (fhp->fh_export->ex_devid_map)\r\ngoto out_unlock;\r\nfor (i = 0; i < DEVID_HASH_SIZE; i++) {\r\nlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\r\nif (old->fsid_type != fh->fh_fsid_type)\r\ncontinue;\r\nif (memcmp(old->fsid, fh->fh_fsid,\r\nkey_len(old->fsid_type)))\r\ncontinue;\r\nfhp->fh_export->ex_devid_map = old;\r\ngoto out_unlock;\r\n}\r\n}\r\nmap->idx = nfsd_devid_seq++;\r\nlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\r\nfhp->fh_export->ex_devid_map = map;\r\nmap = NULL;\r\nout_unlock:\r\nspin_unlock(&nfsd_devid_lock);\r\nkfree(map);\r\n}\r\nstruct nfsd4_deviceid_map *\r\nnfsd4_find_devid_map(int idx)\r\n{\r\nstruct nfsd4_deviceid_map *map, *ret = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\r\nif (map->idx == idx)\r\nret = map;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint\r\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\r\nu32 device_generation)\r\n{\r\nif (!fhp->fh_export->ex_devid_map) {\r\nnfsd4_alloc_devid_map(fhp);\r\nif (!fhp->fh_export->ex_devid_map)\r\nreturn -ENOMEM;\r\n}\r\nid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\r\nid->generation = device_generation;\r\nid->pad = 0;\r\nreturn 0;\r\n}\r\nvoid nfsd4_setup_layout_type(struct svc_export *exp)\r\n{\r\nstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\r\nif (!(exp->ex_flags & NFSEXP_PNFS))\r\nreturn;\r\nif (sb->s_export_op->get_uuid &&\r\nsb->s_export_op->map_blocks &&\r\nsb->s_export_op->commit_blocks)\r\nexp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\r\n}\r\nstatic void\r\nnfsd4_free_layout_stateid(struct nfs4_stid *stid)\r\n{\r\nstruct nfs4_layout_stateid *ls = layoutstateid(stid);\r\nstruct nfs4_client *clp = ls->ls_stid.sc_client;\r\nstruct nfs4_file *fp = ls->ls_stid.sc_file;\r\ntrace_layoutstate_free(&ls->ls_stid.sc_stateid);\r\nspin_lock(&clp->cl_lock);\r\nlist_del_init(&ls->ls_perclnt);\r\nspin_unlock(&clp->cl_lock);\r\nspin_lock(&fp->fi_lock);\r\nlist_del_init(&ls->ls_perfile);\r\nspin_unlock(&fp->fi_lock);\r\nvfs_setlease(ls->ls_file, F_UNLCK, NULL, (void **)&ls);\r\nfput(ls->ls_file);\r\nif (ls->ls_recalled)\r\natomic_dec(&ls->ls_stid.sc_file->fi_lo_recalls);\r\nkmem_cache_free(nfs4_layout_stateid_cache, ls);\r\n}\r\nstatic int\r\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\r\n{\r\nstruct file_lock *fl;\r\nint status;\r\nfl = locks_alloc_lock();\r\nif (!fl)\r\nreturn -ENOMEM;\r\nlocks_init_lock(fl);\r\nfl->fl_lmops = &nfsd4_layouts_lm_ops;\r\nfl->fl_flags = FL_LAYOUT;\r\nfl->fl_type = F_RDLCK;\r\nfl->fl_end = OFFSET_MAX;\r\nfl->fl_owner = ls;\r\nfl->fl_pid = current->tgid;\r\nfl->fl_file = ls->ls_file;\r\nstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\r\nif (status) {\r\nlocks_free_lock(fl);\r\nreturn status;\r\n}\r\nBUG_ON(fl != NULL);\r\nreturn 0;\r\n}\r\nstatic struct nfs4_layout_stateid *\r\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\r\nstruct nfs4_stid *parent, u32 layout_type)\r\n{\r\nstruct nfs4_client *clp = cstate->clp;\r\nstruct nfs4_file *fp = parent->sc_file;\r\nstruct nfs4_layout_stateid *ls;\r\nstruct nfs4_stid *stp;\r\nstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\r\nif (!stp)\r\nreturn NULL;\r\nstp->sc_free = nfsd4_free_layout_stateid;\r\nget_nfs4_file(fp);\r\nstp->sc_file = fp;\r\nls = layoutstateid(stp);\r\nINIT_LIST_HEAD(&ls->ls_perclnt);\r\nINIT_LIST_HEAD(&ls->ls_perfile);\r\nspin_lock_init(&ls->ls_lock);\r\nINIT_LIST_HEAD(&ls->ls_layouts);\r\nls->ls_layout_type = layout_type;\r\nnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\r\nNFSPROC4_CLNT_CB_LAYOUT);\r\nif (parent->sc_type == NFS4_DELEG_STID)\r\nls->ls_file = get_file(fp->fi_deleg_file);\r\nelse\r\nls->ls_file = find_any_file(fp);\r\nBUG_ON(!ls->ls_file);\r\nif (nfsd4_layout_setlease(ls)) {\r\nfput(ls->ls_file);\r\nput_nfs4_file(fp);\r\nkmem_cache_free(nfs4_layout_stateid_cache, ls);\r\nreturn NULL;\r\n}\r\nspin_lock(&clp->cl_lock);\r\nstp->sc_type = NFS4_LAYOUT_STID;\r\nlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\r\nspin_unlock(&clp->cl_lock);\r\nspin_lock(&fp->fi_lock);\r\nlist_add(&ls->ls_perfile, &fp->fi_lo_states);\r\nspin_unlock(&fp->fi_lock);\r\ntrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\r\nreturn ls;\r\n}\r\n__be32\r\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\r\nstruct nfsd4_compound_state *cstate, stateid_t *stateid,\r\nbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\r\n{\r\nstruct nfs4_layout_stateid *ls;\r\nstruct nfs4_stid *stid;\r\nunsigned char typemask = NFS4_LAYOUT_STID;\r\n__be32 status;\r\nif (create)\r\ntypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\r\nstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\r\nnet_generic(SVC_NET(rqstp), nfsd_net_id));\r\nif (status)\r\ngoto out;\r\nif (!fh_match(&cstate->current_fh.fh_handle,\r\n&stid->sc_file->fi_fhandle)) {\r\nstatus = nfserr_bad_stateid;\r\ngoto out_put_stid;\r\n}\r\nif (stid->sc_type != NFS4_LAYOUT_STID) {\r\nls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\r\nnfs4_put_stid(stid);\r\nstatus = nfserr_jukebox;\r\nif (!ls)\r\ngoto out;\r\n} else {\r\nls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\r\nstatus = nfserr_bad_stateid;\r\nif (stateid->si_generation > stid->sc_stateid.si_generation)\r\ngoto out_put_stid;\r\nif (layout_type != ls->ls_layout_type)\r\ngoto out_put_stid;\r\n}\r\n*lsp = ls;\r\nreturn 0;\r\nout_put_stid:\r\nnfs4_put_stid(stid);\r\nout:\r\nreturn status;\r\n}\r\nstatic void\r\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\r\n{\r\nspin_lock(&ls->ls_lock);\r\nif (ls->ls_recalled)\r\ngoto out_unlock;\r\nls->ls_recalled = true;\r\natomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\r\nif (list_empty(&ls->ls_layouts))\r\ngoto out_unlock;\r\ntrace_layout_recall(&ls->ls_stid.sc_stateid);\r\natomic_inc(&ls->ls_stid.sc_count);\r\nupdate_stateid(&ls->ls_stid.sc_stateid);\r\nmemcpy(&ls->ls_recall_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\r\nnfsd4_run_cb(&ls->ls_recall);\r\nout_unlock:\r\nspin_unlock(&ls->ls_lock);\r\n}\r\nstatic inline u64\r\nlayout_end(struct nfsd4_layout_seg *seg)\r\n{\r\nu64 end = seg->offset + seg->length;\r\nreturn end >= seg->offset ? end : NFS4_MAX_UINT64;\r\n}\r\nstatic void\r\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\r\n{\r\nif (end == NFS4_MAX_UINT64)\r\nlo->length = NFS4_MAX_UINT64;\r\nelse\r\nlo->length = end - lo->offset;\r\n}\r\nstatic bool\r\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\r\n{\r\nif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\r\nreturn false;\r\nif (layout_end(&lo->lo_seg) <= s->offset)\r\nreturn false;\r\nif (layout_end(s) <= lo->lo_seg.offset)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\r\n{\r\nif (lo->iomode != new->iomode)\r\nreturn false;\r\nif (layout_end(new) < lo->offset)\r\nreturn false;\r\nif (layout_end(lo) < new->offset)\r\nreturn false;\r\nlo->offset = min(lo->offset, new->offset);\r\nlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\r\nreturn true;\r\n}\r\nstatic __be32\r\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\r\n{\r\nstruct nfs4_file *fp = ls->ls_stid.sc_file;\r\nstruct nfs4_layout_stateid *l, *n;\r\n__be32 nfserr = nfs_ok;\r\nassert_spin_locked(&fp->fi_lock);\r\nlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\r\nif (l != ls) {\r\nnfsd4_recall_file_layout(l);\r\nnfserr = nfserr_recallconflict;\r\n}\r\n}\r\nreturn nfserr;\r\n}\r\n__be32\r\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\r\n{\r\nstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\r\nstruct nfs4_file *fp = ls->ls_stid.sc_file;\r\nstruct nfs4_layout *lp, *new = NULL;\r\n__be32 nfserr;\r\nspin_lock(&fp->fi_lock);\r\nnfserr = nfsd4_recall_conflict(ls);\r\nif (nfserr)\r\ngoto out;\r\nspin_lock(&ls->ls_lock);\r\nlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\r\nif (layouts_try_merge(&lp->lo_seg, seg))\r\ngoto done;\r\n}\r\nspin_unlock(&ls->ls_lock);\r\nspin_unlock(&fp->fi_lock);\r\nnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\r\nif (!new)\r\nreturn nfserr_jukebox;\r\nmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\r\nnew->lo_state = ls;\r\nspin_lock(&fp->fi_lock);\r\nnfserr = nfsd4_recall_conflict(ls);\r\nif (nfserr)\r\ngoto out;\r\nspin_lock(&ls->ls_lock);\r\nlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\r\nif (layouts_try_merge(&lp->lo_seg, seg))\r\ngoto done;\r\n}\r\natomic_inc(&ls->ls_stid.sc_count);\r\nlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\r\nnew = NULL;\r\ndone:\r\nupdate_stateid(&ls->ls_stid.sc_stateid);\r\nmemcpy(&lgp->lg_sid, &ls->ls_stid.sc_stateid, sizeof(stateid_t));\r\nspin_unlock(&ls->ls_lock);\r\nout:\r\nspin_unlock(&fp->fi_lock);\r\nif (new)\r\nkmem_cache_free(nfs4_layout_cache, new);\r\nreturn nfserr;\r\n}\r\nstatic void\r\nnfsd4_free_layouts(struct list_head *reaplist)\r\n{\r\nwhile (!list_empty(reaplist)) {\r\nstruct nfs4_layout *lp = list_first_entry(reaplist,\r\nstruct nfs4_layout, lo_perstate);\r\nlist_del(&lp->lo_perstate);\r\nnfs4_put_stid(&lp->lo_state->ls_stid);\r\nkmem_cache_free(nfs4_layout_cache, lp);\r\n}\r\n}\r\nstatic void\r\nnfsd4_return_file_layout(struct nfs4_layout *lp, struct nfsd4_layout_seg *seg,\r\nstruct list_head *reaplist)\r\n{\r\nstruct nfsd4_layout_seg *lo = &lp->lo_seg;\r\nu64 end = layout_end(lo);\r\nif (seg->offset <= lo->offset) {\r\nif (layout_end(seg) >= end) {\r\nlist_move_tail(&lp->lo_perstate, reaplist);\r\nreturn;\r\n}\r\nlo->offset = layout_end(seg);\r\n} else {\r\nif (layout_end(seg) < end) {\r\ndprintk("%s: split not supported\n", __func__);\r\nreturn;\r\n}\r\nend = seg->offset;\r\n}\r\nlayout_update_len(lo, end);\r\n}\r\n__be32\r\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\r\nstruct nfsd4_compound_state *cstate,\r\nstruct nfsd4_layoutreturn *lrp)\r\n{\r\nstruct nfs4_layout_stateid *ls;\r\nstruct nfs4_layout *lp, *n;\r\nLIST_HEAD(reaplist);\r\n__be32 nfserr;\r\nint found = 0;\r\nnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\r\nfalse, lrp->lr_layout_type,\r\n&ls);\r\nif (nfserr) {\r\ntrace_layout_return_lookup_fail(&lrp->lr_sid);\r\nreturn nfserr;\r\n}\r\nspin_lock(&ls->ls_lock);\r\nlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\r\nif (layouts_overlapping(lp, &lrp->lr_seg)) {\r\nnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\r\nfound++;\r\n}\r\n}\r\nif (!list_empty(&ls->ls_layouts)) {\r\nif (found) {\r\nupdate_stateid(&ls->ls_stid.sc_stateid);\r\nmemcpy(&lrp->lr_sid, &ls->ls_stid.sc_stateid,\r\nsizeof(stateid_t));\r\n}\r\nlrp->lrs_present = 1;\r\n} else {\r\ntrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\r\nnfs4_unhash_stid(&ls->ls_stid);\r\nlrp->lrs_present = 0;\r\n}\r\nspin_unlock(&ls->ls_lock);\r\nnfs4_put_stid(&ls->ls_stid);\r\nnfsd4_free_layouts(&reaplist);\r\nreturn nfs_ok;\r\n}\r\n__be32\r\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\r\nstruct nfsd4_compound_state *cstate,\r\nstruct nfsd4_layoutreturn *lrp)\r\n{\r\nstruct nfs4_layout_stateid *ls, *n;\r\nstruct nfs4_client *clp = cstate->clp;\r\nstruct nfs4_layout *lp, *t;\r\nLIST_HEAD(reaplist);\r\nlrp->lrs_present = 0;\r\nspin_lock(&clp->cl_lock);\r\nlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\r\nif (ls->ls_layout_type != lrp->lr_layout_type)\r\ncontinue;\r\nif (lrp->lr_return_type == RETURN_FSID &&\r\n!fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\r\n&cstate->current_fh.fh_handle))\r\ncontinue;\r\nspin_lock(&ls->ls_lock);\r\nlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\r\nif (lrp->lr_seg.iomode == IOMODE_ANY ||\r\nlrp->lr_seg.iomode == lp->lo_seg.iomode)\r\nlist_move_tail(&lp->lo_perstate, &reaplist);\r\n}\r\nspin_unlock(&ls->ls_lock);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nnfsd4_free_layouts(&reaplist);\r\nreturn 0;\r\n}\r\nstatic void\r\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\r\nstruct list_head *reaplist)\r\n{\r\nspin_lock(&ls->ls_lock);\r\nlist_splice_init(&ls->ls_layouts, reaplist);\r\nspin_unlock(&ls->ls_lock);\r\n}\r\nvoid\r\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\r\n{\r\nstruct nfs4_layout_stateid *ls, *n;\r\nLIST_HEAD(reaplist);\r\nspin_lock(&clp->cl_lock);\r\nlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\r\nnfsd4_return_all_layouts(ls, &reaplist);\r\nspin_unlock(&clp->cl_lock);\r\nnfsd4_free_layouts(&reaplist);\r\n}\r\nvoid\r\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\r\n{\r\nstruct nfs4_layout_stateid *ls, *n;\r\nLIST_HEAD(reaplist);\r\nspin_lock(&fp->fi_lock);\r\nlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\r\nif (ls->ls_stid.sc_client == clp)\r\nnfsd4_return_all_layouts(ls, &reaplist);\r\n}\r\nspin_unlock(&fp->fi_lock);\r\nnfsd4_free_layouts(&reaplist);\r\n}\r\nstatic void\r\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\r\n{\r\nstruct nfs4_client *clp = ls->ls_stid.sc_client;\r\nchar addr_str[INET6_ADDRSTRLEN];\r\nstatic char *envp[] = {\r\n"HOME=/",\r\n"TERM=linux",\r\n"PATH=/sbin:/usr/sbin:/bin:/usr/bin",\r\nNULL\r\n};\r\nchar *argv[8];\r\nint error;\r\nrpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\r\ntrace_layout_recall_fail(&ls->ls_stid.sc_stateid);\r\nprintk(KERN_WARNING\r\n"nfsd: client %s failed to respond to layout recall. "\r\n" Fencing..\n", addr_str);\r\nargv[0] = "/sbin/nfsd-recall-failed";\r\nargv[1] = addr_str;\r\nargv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\r\nargv[3] = NULL;\r\nerror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\r\nif (error) {\r\nprintk(KERN_ERR "nfsd: fence failed for client %s: %d!\n",\r\naddr_str, error);\r\n}\r\n}\r\nstatic int\r\nnfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)\r\n{\r\nstruct nfs4_layout_stateid *ls =\r\ncontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\r\nLIST_HEAD(reaplist);\r\nswitch (task->tk_status) {\r\ncase 0:\r\nreturn 1;\r\ncase -NFS4ERR_NOMATCHING_LAYOUT:\r\ntrace_layout_recall_done(&ls->ls_stid.sc_stateid);\r\ntask->tk_status = 0;\r\nreturn 1;\r\ncase -NFS4ERR_DELAY:\r\nrpc_delay(task, HZ/100);\r\nreturn 0;\r\ndefault:\r\nnfsd4_cb_layout_fail(ls);\r\nreturn -1;\r\n}\r\n}\r\nstatic void\r\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_layout_stateid *ls =\r\ncontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\r\nLIST_HEAD(reaplist);\r\ntrace_layout_recall_release(&ls->ls_stid.sc_stateid);\r\nnfsd4_return_all_layouts(ls, &reaplist);\r\nnfsd4_free_layouts(&reaplist);\r\nnfs4_put_stid(&ls->ls_stid);\r\n}\r\nstatic bool\r\nnfsd4_layout_lm_break(struct file_lock *fl)\r\n{\r\nfl->fl_break_time = 0;\r\nnfsd4_recall_file_layout(fl->fl_owner);\r\nreturn false;\r\n}\r\nstatic int\r\nnfsd4_layout_lm_change(struct file_lock *onlist, int arg,\r\nstruct list_head *dispose)\r\n{\r\nBUG_ON(!(arg & F_UNLCK));\r\nreturn lease_modify(onlist, arg, dispose);\r\n}\r\nint\r\nnfsd4_init_pnfs(void)\r\n{\r\nint i;\r\nfor (i = 0; i < DEVID_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&nfsd_devid_hash[i]);\r\nnfs4_layout_cache = kmem_cache_create("nfs4_layout",\r\nsizeof(struct nfs4_layout), 0, 0, NULL);\r\nif (!nfs4_layout_cache)\r\nreturn -ENOMEM;\r\nnfs4_layout_stateid_cache = kmem_cache_create("nfs4_layout_stateid",\r\nsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\r\nif (!nfs4_layout_stateid_cache) {\r\nkmem_cache_destroy(nfs4_layout_cache);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnfsd4_exit_pnfs(void)\r\n{\r\nint i;\r\nkmem_cache_destroy(nfs4_layout_cache);\r\nkmem_cache_destroy(nfs4_layout_stateid_cache);\r\nfor (i = 0; i < DEVID_HASH_SIZE; i++) {\r\nstruct nfsd4_deviceid_map *map, *n;\r\nlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\r\nkfree(map);\r\n}\r\n}
