static void rt61pci_bbp_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, const u8 value)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field32(&reg, PHY_CSR3_VALUE, value);\r\nrt2x00_set_field32(&reg, PHY_CSR3_REGNUM, word);\r\nrt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);\r\nrt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 0);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR3, reg);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt61pci_bbp_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, u8 *value)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field32(&reg, PHY_CSR3_REGNUM, word);\r\nrt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);\r\nrt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 1);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR3, reg);\r\nWAIT_FOR_BBP(rt2x00dev, &reg);\r\n}\r\n*value = rt2x00_get_field32(reg, PHY_CSR3_VALUE);\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt61pci_rf_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, const u32 value)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_RF(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field32(&reg, PHY_CSR4_VALUE, value);\r\nrt2x00_set_field32(&reg, PHY_CSR4_NUMBER_OF_BITS, 21);\r\nrt2x00_set_field32(&reg, PHY_CSR4_IF_SELECT, 0);\r\nrt2x00_set_field32(&reg, PHY_CSR4_BUSY, 1);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR4, reg);\r\nrt2x00_rf_write(rt2x00dev, word, value);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt61pci_mcu_request(struct rt2x00_dev *rt2x00dev,\r\nconst u8 command, const u8 token,\r\nconst u8 arg0, const u8 arg1)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_MCU(rt2x00dev, &reg)) {\r\nrt2x00_set_field32(&reg, H2M_MAILBOX_CSR_OWNER, 1);\r\nrt2x00_set_field32(&reg, H2M_MAILBOX_CSR_CMD_TOKEN, token);\r\nrt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG0, arg0);\r\nrt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG1, arg1);\r\nrt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, HOST_CMD_CSR, &reg);\r\nrt2x00_set_field32(&reg, HOST_CMD_CSR_HOST_COMMAND, command);\r\nrt2x00_set_field32(&reg, HOST_CMD_CSR_INTERRUPT_MCU, 1);\r\nrt2x00mmio_register_write(rt2x00dev, HOST_CMD_CSR, reg);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt61pci_eepromregister_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = eeprom->data;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, E2PROM_CSR, &reg);\r\neeprom->reg_data_in = !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_IN);\r\neeprom->reg_data_out = !!rt2x00_get_field32(reg, E2PROM_CSR_DATA_OUT);\r\neeprom->reg_data_clock =\r\n!!rt2x00_get_field32(reg, E2PROM_CSR_DATA_CLOCK);\r\neeprom->reg_chip_select =\r\n!!rt2x00_get_field32(reg, E2PROM_CSR_CHIP_SELECT);\r\n}\r\nstatic void rt61pci_eepromregister_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = eeprom->data;\r\nu32 reg = 0;\r\nrt2x00_set_field32(&reg, E2PROM_CSR_DATA_IN, !!eeprom->reg_data_in);\r\nrt2x00_set_field32(&reg, E2PROM_CSR_DATA_OUT, !!eeprom->reg_data_out);\r\nrt2x00_set_field32(&reg, E2PROM_CSR_DATA_CLOCK,\r\n!!eeprom->reg_data_clock);\r\nrt2x00_set_field32(&reg, E2PROM_CSR_CHIP_SELECT,\r\n!!eeprom->reg_chip_select);\r\nrt2x00mmio_register_write(rt2x00dev, E2PROM_CSR, reg);\r\n}\r\nstatic int rt61pci_rfkill_poll(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR13, &reg);\r\nreturn rt2x00_get_field32(reg, MAC_CSR13_VAL5);\r\n}\r\nstatic void rt61pci_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct rt2x00_led *led =\r\ncontainer_of(led_cdev, struct rt2x00_led, led_dev);\r\nunsigned int enabled = brightness != LED_OFF;\r\nunsigned int a_mode =\r\n(enabled && led->rt2x00dev->curr_band == IEEE80211_BAND_5GHZ);\r\nunsigned int bg_mode =\r\n(enabled && led->rt2x00dev->curr_band == IEEE80211_BAND_2GHZ);\r\nif (led->type == LED_TYPE_RADIO) {\r\nrt2x00_set_field16(&led->rt2x00dev->led_mcu_reg,\r\nMCU_LEDCS_RADIO_STATUS, enabled);\r\nrt61pci_mcu_request(led->rt2x00dev, MCU_LED, 0xff,\r\n(led->rt2x00dev->led_mcu_reg & 0xff),\r\n((led->rt2x00dev->led_mcu_reg >> 8)));\r\n} else if (led->type == LED_TYPE_ASSOC) {\r\nrt2x00_set_field16(&led->rt2x00dev->led_mcu_reg,\r\nMCU_LEDCS_LINK_BG_STATUS, bg_mode);\r\nrt2x00_set_field16(&led->rt2x00dev->led_mcu_reg,\r\nMCU_LEDCS_LINK_A_STATUS, a_mode);\r\nrt61pci_mcu_request(led->rt2x00dev, MCU_LED, 0xff,\r\n(led->rt2x00dev->led_mcu_reg & 0xff),\r\n((led->rt2x00dev->led_mcu_reg >> 8)));\r\n} else if (led->type == LED_TYPE_QUALITY) {\r\nrt61pci_mcu_request(led->rt2x00dev, MCU_LED_STRENGTH, 0xff,\r\nbrightness / (LED_FULL / 6), 0);\r\n}\r\n}\r\nstatic int rt61pci_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct rt2x00_led *led =\r\ncontainer_of(led_cdev, struct rt2x00_led, led_dev);\r\nu32 reg;\r\nrt2x00mmio_register_read(led->rt2x00dev, MAC_CSR14, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR14_ON_PERIOD, *delay_on);\r\nrt2x00_set_field32(&reg, MAC_CSR14_OFF_PERIOD, *delay_off);\r\nrt2x00mmio_register_write(led->rt2x00dev, MAC_CSR14, reg);\r\nreturn 0;\r\n}\r\nstatic void rt61pci_init_led(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_led *led,\r\nenum led_type type)\r\n{\r\nled->rt2x00dev = rt2x00dev;\r\nled->type = type;\r\nled->led_dev.brightness_set = rt61pci_brightness_set;\r\nled->led_dev.blink_set = rt61pci_blink_set;\r\nled->flags = LED_INITIALIZED;\r\n}\r\nstatic int rt61pci_config_shared_key(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_crypto *crypto,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct hw_key_entry key_entry;\r\nstruct rt2x00_field32 field;\r\nu32 mask;\r\nu32 reg;\r\nif (crypto->cmd == SET_KEY) {\r\nmask = (0xf << crypto->bssidx);\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR0, &reg);\r\nreg &= mask;\r\nif (reg && reg == mask)\r\nreturn -ENOSPC;\r\nkey->hw_key_idx += reg ? ffz(reg) : 0;\r\nmemcpy(key_entry.key, crypto->key,\r\nsizeof(key_entry.key));\r\nmemcpy(key_entry.tx_mic, crypto->tx_mic,\r\nsizeof(key_entry.tx_mic));\r\nmemcpy(key_entry.rx_mic, crypto->rx_mic,\r\nsizeof(key_entry.rx_mic));\r\nreg = SHARED_KEY_ENTRY(key->hw_key_idx);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, reg,\r\n&key_entry, sizeof(key_entry));\r\nif (key->hw_key_idx < 8) {\r\nfield.bit_offset = (3 * key->hw_key_idx);\r\nfield.bit_mask = 0x7 << field.bit_offset;\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR1, &reg);\r\nrt2x00_set_field32(&reg, field, crypto->cipher);\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR1, reg);\r\n} else {\r\nfield.bit_offset = (3 * (key->hw_key_idx - 8));\r\nfield.bit_mask = 0x7 << field.bit_offset;\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR5, &reg);\r\nrt2x00_set_field32(&reg, field, crypto->cipher);\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR5, reg);\r\n}\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\n}\r\nmask = 1 << key->hw_key_idx;\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR0, &reg);\r\nif (crypto->cmd == SET_KEY)\r\nreg |= mask;\r\nelse if (crypto->cmd == DISABLE_KEY)\r\nreg &= ~mask;\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR0, reg);\r\nreturn 0;\r\n}\r\nstatic int rt61pci_config_pairwise_key(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_crypto *crypto,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct hw_pairwise_ta_entry addr_entry;\r\nstruct hw_key_entry key_entry;\r\nu32 mask;\r\nu32 reg;\r\nif (crypto->cmd == SET_KEY) {\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR2, &reg);\r\nif (reg && reg == ~0) {\r\nkey->hw_key_idx = 32;\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR3, &reg);\r\nif (reg && reg == ~0)\r\nreturn -ENOSPC;\r\n}\r\nkey->hw_key_idx += reg ? ffz(reg) : 0;\r\nmemcpy(key_entry.key, crypto->key,\r\nsizeof(key_entry.key));\r\nmemcpy(key_entry.tx_mic, crypto->tx_mic,\r\nsizeof(key_entry.tx_mic));\r\nmemcpy(key_entry.rx_mic, crypto->rx_mic,\r\nsizeof(key_entry.rx_mic));\r\nmemset(&addr_entry, 0, sizeof(addr_entry));\r\nmemcpy(&addr_entry, crypto->address, ETH_ALEN);\r\naddr_entry.cipher = crypto->cipher;\r\nreg = PAIRWISE_KEY_ENTRY(key->hw_key_idx);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, reg,\r\n&key_entry, sizeof(key_entry));\r\nreg = PAIRWISE_TA_ENTRY(key->hw_key_idx);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, reg,\r\n&addr_entry, sizeof(addr_entry));\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR4, &reg);\r\nreg |= (1 << crypto->bssidx);\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR4, reg);\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\n}\r\nif (key->hw_key_idx < 32) {\r\nmask = 1 << key->hw_key_idx;\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR2, &reg);\r\nif (crypto->cmd == SET_KEY)\r\nreg |= mask;\r\nelse if (crypto->cmd == DISABLE_KEY)\r\nreg &= ~mask;\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR2, reg);\r\n} else {\r\nmask = 1 << (key->hw_key_idx - 32);\r\nrt2x00mmio_register_read(rt2x00dev, SEC_CSR3, &reg);\r\nif (crypto->cmd == SET_KEY)\r\nreg |= mask;\r\nelse if (crypto->cmd == DISABLE_KEY)\r\nreg &= ~mask;\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR3, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rt61pci_config_filter(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int filter_flags)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_CRC,\r\n!(filter_flags & FIF_FCSFAIL));\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_PHYSICAL,\r\n!(filter_flags & FIF_PLCPFAIL));\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_CONTROL,\r\n!(filter_flags & (FIF_CONTROL | FIF_PSPOLL)));\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_TO_DS,\r\n!rt2x00dev->intf_ap_count);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_VERSION_ERROR, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_MULTICAST,\r\n!(filter_flags & FIF_ALLMULTI));\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_BROADCAST, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DROP_ACK_CTS,\r\n!(filter_flags & FIF_CONTROL));\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\r\n}\r\nstatic void rt61pci_config_intf(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_intf *intf,\r\nstruct rt2x00intf_conf *conf,\r\nconst unsigned int flags)\r\n{\r\nu32 reg;\r\nif (flags & CONFIG_UPDATE_TYPE) {\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TSF_SYNC, conf->sync);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\n}\r\nif (flags & CONFIG_UPDATE_MAC) {\r\nreg = le32_to_cpu(conf->mac[1]);\r\nrt2x00_set_field32(&reg, MAC_CSR3_UNICAST_TO_ME_MASK, 0xff);\r\nconf->mac[1] = cpu_to_le32(reg);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, MAC_CSR2,\r\nconf->mac, sizeof(conf->mac));\r\n}\r\nif (flags & CONFIG_UPDATE_BSSID) {\r\nreg = le32_to_cpu(conf->bssid[1]);\r\nrt2x00_set_field32(&reg, MAC_CSR5_BSS_ID_MASK, 3);\r\nconf->bssid[1] = cpu_to_le32(reg);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, MAC_CSR4,\r\nconf->bssid,\r\nsizeof(conf->bssid));\r\n}\r\n}\r\nstatic void rt61pci_config_erp(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_erp *erp,\r\nu32 changed)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_RX_ACK_TIMEOUT, 0x32);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_TSF_OFFSET, IEEE80211_HEADER);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR4, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_ENABLE, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_PREAMBLE,\r\n!!erp->short_preamble);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR4, reg);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES)\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR5,\r\nerp->basic_rates);\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL,\r\nerp->beacon_int * 16);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR9, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR9_SLOT_TIME, erp->slot_time);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR9, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR8, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR8_SIFS, erp->sifs);\r\nrt2x00_set_field32(&reg, MAC_CSR8_SIFS_AFTER_RX_OFDM, 3);\r\nrt2x00_set_field32(&reg, MAC_CSR8_EIFS, erp->eifs);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR8, reg);\r\n}\r\n}\r\nstatic void rt61pci_config_antenna_5x(struct rt2x00_dev *rt2x00dev,\r\nstruct antenna_setup *ant)\r\n{\r\nu8 r3;\r\nu8 r4;\r\nu8 r77;\r\nrt61pci_bbp_read(rt2x00dev, 3, &r3);\r\nrt61pci_bbp_read(rt2x00dev, 4, &r4);\r\nrt61pci_bbp_read(rt2x00dev, 77, &r77);\r\nrt2x00_set_field8(&r3, BBP_R3_SMART_MODE, rt2x00_rf(rt2x00dev, RF5325));\r\nswitch (ant->rx) {\r\ncase ANTENNA_HW_DIVERSITY:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 2);\r\nrt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,\r\n(rt2x00dev->curr_band != IEEE80211_BAND_5GHZ));\r\nbreak;\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\r\nrt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END, 0);\r\nif (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ)\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\r\nelse\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\r\nbreak;\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\r\nrt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END, 0);\r\nif (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ)\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\r\nelse\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\r\nbreak;\r\n}\r\nrt61pci_bbp_write(rt2x00dev, 77, r77);\r\nrt61pci_bbp_write(rt2x00dev, 3, r3);\r\nrt61pci_bbp_write(rt2x00dev, 4, r4);\r\n}\r\nstatic void rt61pci_config_antenna_2x(struct rt2x00_dev *rt2x00dev,\r\nstruct antenna_setup *ant)\r\n{\r\nu8 r3;\r\nu8 r4;\r\nu8 r77;\r\nrt61pci_bbp_read(rt2x00dev, 3, &r3);\r\nrt61pci_bbp_read(rt2x00dev, 4, &r4);\r\nrt61pci_bbp_read(rt2x00dev, 77, &r77);\r\nrt2x00_set_field8(&r3, BBP_R3_SMART_MODE, rt2x00_rf(rt2x00dev, RF2529));\r\nrt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,\r\n!rt2x00_has_cap_frame_type(rt2x00dev));\r\nswitch (ant->rx) {\r\ncase ANTENNA_HW_DIVERSITY:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 2);\r\nbreak;\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\r\nbreak;\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\r\nbreak;\r\n}\r\nrt61pci_bbp_write(rt2x00dev, 77, r77);\r\nrt61pci_bbp_write(rt2x00dev, 3, r3);\r\nrt61pci_bbp_write(rt2x00dev, 4, r4);\r\n}\r\nstatic void rt61pci_config_antenna_2529_rx(struct rt2x00_dev *rt2x00dev,\r\nconst int p1, const int p2)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR13, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR13_DIR4, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR13_VAL4, p1);\r\nrt2x00_set_field32(&reg, MAC_CSR13_DIR3, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR13_VAL3, !p2);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR13, reg);\r\n}\r\nstatic void rt61pci_config_antenna_2529(struct rt2x00_dev *rt2x00dev,\r\nstruct antenna_setup *ant)\r\n{\r\nu8 r3;\r\nu8 r4;\r\nu8 r77;\r\nrt61pci_bbp_read(rt2x00dev, 3, &r3);\r\nrt61pci_bbp_read(rt2x00dev, 4, &r4);\r\nrt61pci_bbp_read(rt2x00dev, 77, &r77);\r\nswitch (ant->rx) {\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 0);\r\nrt61pci_config_antenna_2529_rx(rt2x00dev, 0, 0);\r\nbreak;\r\ncase ANTENNA_HW_DIVERSITY:\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA_CONTROL, 1);\r\nrt2x00_set_field8(&r77, BBP_R77_RX_ANTENNA, 3);\r\nrt61pci_config_antenna_2529_rx(rt2x00dev, 1, 1);\r\nbreak;\r\n}\r\nrt61pci_bbp_write(rt2x00dev, 77, r77);\r\nrt61pci_bbp_write(rt2x00dev, 3, r3);\r\nrt61pci_bbp_write(rt2x00dev, 4, r4);\r\n}\r\nstatic void rt61pci_config_ant(struct rt2x00_dev *rt2x00dev,\r\nstruct antenna_setup *ant)\r\n{\r\nconst struct antenna_sel *sel;\r\nunsigned int lna;\r\nunsigned int i;\r\nu32 reg;\r\nBUG_ON(ant->rx == ANTENNA_SW_DIVERSITY ||\r\nant->tx == ANTENNA_SW_DIVERSITY);\r\nif (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {\r\nsel = antenna_sel_a;\r\nlna = rt2x00_has_cap_external_lna_a(rt2x00dev);\r\n} else {\r\nsel = antenna_sel_bg;\r\nlna = rt2x00_has_cap_external_lna_bg(rt2x00dev);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(antenna_sel_a); i++)\r\nrt61pci_bbp_write(rt2x00dev, sel[i].word, sel[i].value[lna]);\r\nrt2x00mmio_register_read(rt2x00dev, PHY_CSR0, &reg);\r\nrt2x00_set_field32(&reg, PHY_CSR0_PA_PE_BG,\r\nrt2x00dev->curr_band == IEEE80211_BAND_2GHZ);\r\nrt2x00_set_field32(&reg, PHY_CSR0_PA_PE_A,\r\nrt2x00dev->curr_band == IEEE80211_BAND_5GHZ);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR0, reg);\r\nif (rt2x00_rf(rt2x00dev, RF5225) || rt2x00_rf(rt2x00dev, RF5325))\r\nrt61pci_config_antenna_5x(rt2x00dev, ant);\r\nelse if (rt2x00_rf(rt2x00dev, RF2527))\r\nrt61pci_config_antenna_2x(rt2x00dev, ant);\r\nelse if (rt2x00_rf(rt2x00dev, RF2529)) {\r\nif (rt2x00_has_cap_double_antenna(rt2x00dev))\r\nrt61pci_config_antenna_2x(rt2x00dev, ant);\r\nelse\r\nrt61pci_config_antenna_2529(rt2x00dev, ant);\r\n}\r\n}\r\nstatic void rt61pci_config_lna_gain(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf)\r\n{\r\nu16 eeprom;\r\nshort lna_gain = 0;\r\nif (libconf->conf->chandef.chan->band == IEEE80211_BAND_2GHZ) {\r\nif (rt2x00_has_cap_external_lna_bg(rt2x00dev))\r\nlna_gain += 14;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &eeprom);\r\nlna_gain -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_BG_1);\r\n} else {\r\nif (rt2x00_has_cap_external_lna_a(rt2x00dev))\r\nlna_gain += 14;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &eeprom);\r\nlna_gain -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_A_1);\r\n}\r\nrt2x00dev->lna_gain = lna_gain;\r\n}\r\nstatic void rt61pci_config_channel(struct rt2x00_dev *rt2x00dev,\r\nstruct rf_channel *rf, const int txpower)\r\n{\r\nu8 r3;\r\nu8 r94;\r\nu8 smart;\r\nrt2x00_set_field32(&rf->rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\r\nrt2x00_set_field32(&rf->rf4, RF4_FREQ_OFFSET, rt2x00dev->freq_offset);\r\nsmart = !(rt2x00_rf(rt2x00dev, RF5225) || rt2x00_rf(rt2x00dev, RF2527));\r\nrt61pci_bbp_read(rt2x00dev, 3, &r3);\r\nrt2x00_set_field8(&r3, BBP_R3_SMART_MODE, smart);\r\nrt61pci_bbp_write(rt2x00dev, 3, r3);\r\nr94 = 6;\r\nif (txpower > MAX_TXPOWER && txpower <= (MAX_TXPOWER + r94))\r\nr94 += txpower - MAX_TXPOWER;\r\nelse if (txpower < MIN_TXPOWER && txpower >= (MIN_TXPOWER - r94))\r\nr94 += txpower;\r\nrt61pci_bbp_write(rt2x00dev, 94, r94);\r\nrt61pci_rf_write(rt2x00dev, 1, rf->rf1);\r\nrt61pci_rf_write(rt2x00dev, 2, rf->rf2);\r\nrt61pci_rf_write(rt2x00dev, 3, rf->rf3 & ~0x00000004);\r\nrt61pci_rf_write(rt2x00dev, 4, rf->rf4);\r\nudelay(200);\r\nrt61pci_rf_write(rt2x00dev, 1, rf->rf1);\r\nrt61pci_rf_write(rt2x00dev, 2, rf->rf2);\r\nrt61pci_rf_write(rt2x00dev, 3, rf->rf3 | 0x00000004);\r\nrt61pci_rf_write(rt2x00dev, 4, rf->rf4);\r\nudelay(200);\r\nrt61pci_rf_write(rt2x00dev, 1, rf->rf1);\r\nrt61pci_rf_write(rt2x00dev, 2, rf->rf2);\r\nrt61pci_rf_write(rt2x00dev, 3, rf->rf3 & ~0x00000004);\r\nrt61pci_rf_write(rt2x00dev, 4, rf->rf4);\r\nmsleep(1);\r\n}\r\nstatic void rt61pci_config_txpower(struct rt2x00_dev *rt2x00dev,\r\nconst int txpower)\r\n{\r\nstruct rf_channel rf;\r\nrt2x00_rf_read(rt2x00dev, 1, &rf.rf1);\r\nrt2x00_rf_read(rt2x00dev, 2, &rf.rf2);\r\nrt2x00_rf_read(rt2x00dev, 3, &rf.rf3);\r\nrt2x00_rf_read(rt2x00dev, 4, &rf.rf4);\r\nrt61pci_config_channel(rt2x00dev, &rf, txpower);\r\n}\r\nstatic void rt61pci_config_retry_limit(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR4, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_OFDM_TX_RATE_DOWN, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_OFDM_TX_RATE_STEP, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_OFDM_TX_FALLBACK_CCK, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_LONG_RETRY_LIMIT,\r\nlibconf->conf->long_frame_max_tx_count);\r\nrt2x00_set_field32(&reg, TXRX_CSR4_SHORT_RETRY_LIMIT,\r\nlibconf->conf->short_frame_max_tx_count);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR4, reg);\r\n}\r\nstatic void rt61pci_config_ps(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf)\r\n{\r\nenum dev_state state =\r\n(libconf->conf->flags & IEEE80211_CONF_PS) ?\r\nSTATE_SLEEP : STATE_AWAKE;\r\nu32 reg;\r\nif (state == STATE_SLEEP) {\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR11, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR11_DELAY_AFTER_TBCN,\r\nrt2x00dev->beacon_int - 10);\r\nrt2x00_set_field32(&reg, MAC_CSR11_TBCN_BEFORE_WAKEUP,\r\nlibconf->conf->listen_interval - 1);\r\nrt2x00_set_field32(&reg, MAC_CSR11_WAKEUP_LATENCY, 5);\r\nrt2x00_set_field32(&reg, MAC_CSR11_AUTOWAKE, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR11, reg);\r\nrt2x00_set_field32(&reg, MAC_CSR11_AUTOWAKE, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR11, reg);\r\nrt2x00mmio_register_write(rt2x00dev, SOFT_RESET_CSR,\r\n0x00000005);\r\nrt2x00mmio_register_write(rt2x00dev, IO_CNTL_CSR, 0x0000001c);\r\nrt2x00mmio_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000060);\r\nrt61pci_mcu_request(rt2x00dev, MCU_SLEEP, 0xff, 0, 0);\r\n} else {\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR11, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR11_DELAY_AFTER_TBCN, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR11_TBCN_BEFORE_WAKEUP, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR11_AUTOWAKE, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR11_WAKEUP_LATENCY, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR11, reg);\r\nrt2x00mmio_register_write(rt2x00dev, SOFT_RESET_CSR,\r\n0x00000007);\r\nrt2x00mmio_register_write(rt2x00dev, IO_CNTL_CSR, 0x00000018);\r\nrt2x00mmio_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000020);\r\nrt61pci_mcu_request(rt2x00dev, MCU_WAKEUP, 0xff, 0, 0);\r\n}\r\n}\r\nstatic void rt61pci_config(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf,\r\nconst unsigned int flags)\r\n{\r\nrt61pci_config_lna_gain(rt2x00dev, libconf);\r\nif (flags & IEEE80211_CONF_CHANGE_CHANNEL)\r\nrt61pci_config_channel(rt2x00dev, &libconf->rf,\r\nlibconf->conf->power_level);\r\nif ((flags & IEEE80211_CONF_CHANGE_POWER) &&\r\n!(flags & IEEE80211_CONF_CHANGE_CHANNEL))\r\nrt61pci_config_txpower(rt2x00dev, libconf->conf->power_level);\r\nif (flags & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\r\nrt61pci_config_retry_limit(rt2x00dev, libconf);\r\nif (flags & IEEE80211_CONF_CHANGE_PS)\r\nrt61pci_config_ps(rt2x00dev, libconf);\r\n}\r\nstatic void rt61pci_link_stats(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, STA_CSR0, &reg);\r\nqual->rx_failed = rt2x00_get_field32(reg, STA_CSR0_FCS_ERROR);\r\nrt2x00mmio_register_read(rt2x00dev, STA_CSR1, &reg);\r\nqual->false_cca = rt2x00_get_field32(reg, STA_CSR1_FALSE_CCA_ERROR);\r\n}\r\nstatic inline void rt61pci_set_vgc(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual, u8 vgc_level)\r\n{\r\nif (qual->vgc_level != vgc_level) {\r\nrt61pci_bbp_write(rt2x00dev, 17, vgc_level);\r\nqual->vgc_level = vgc_level;\r\nqual->vgc_level_reg = vgc_level;\r\n}\r\n}\r\nstatic void rt61pci_reset_tuner(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual)\r\n{\r\nrt61pci_set_vgc(rt2x00dev, qual, 0x20);\r\n}\r\nstatic void rt61pci_link_tuner(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual, const u32 count)\r\n{\r\nu8 up_bound;\r\nu8 low_bound;\r\nif (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {\r\nlow_bound = 0x28;\r\nup_bound = 0x48;\r\nif (rt2x00_has_cap_external_lna_a(rt2x00dev)) {\r\nlow_bound += 0x10;\r\nup_bound += 0x10;\r\n}\r\n} else {\r\nlow_bound = 0x20;\r\nup_bound = 0x40;\r\nif (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {\r\nlow_bound += 0x10;\r\nup_bound += 0x10;\r\n}\r\n}\r\nif (!rt2x00dev->intf_associated)\r\ngoto dynamic_cca_tune;\r\nif (qual->rssi >= -35) {\r\nrt61pci_set_vgc(rt2x00dev, qual, 0x60);\r\nreturn;\r\n}\r\nif (qual->rssi >= -58) {\r\nrt61pci_set_vgc(rt2x00dev, qual, up_bound);\r\nreturn;\r\n}\r\nif (qual->rssi >= -66) {\r\nrt61pci_set_vgc(rt2x00dev, qual, low_bound + 0x10);\r\nreturn;\r\n}\r\nif (qual->rssi >= -74) {\r\nrt61pci_set_vgc(rt2x00dev, qual, low_bound + 0x08);\r\nreturn;\r\n}\r\nup_bound -= 2 * (-74 - qual->rssi);\r\nif (low_bound > up_bound)\r\nup_bound = low_bound;\r\nif (qual->vgc_level > up_bound) {\r\nrt61pci_set_vgc(rt2x00dev, qual, up_bound);\r\nreturn;\r\n}\r\ndynamic_cca_tune:\r\nif ((qual->false_cca > 512) && (qual->vgc_level < up_bound))\r\nrt61pci_set_vgc(rt2x00dev, qual, ++qual->vgc_level);\r\nelse if ((qual->false_cca < 100) && (qual->vgc_level > low_bound))\r\nrt61pci_set_vgc(rt2x00dev, qual, --qual->vgc_level);\r\n}\r\nstatic void rt61pci_start_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void rt61pci_kick_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC0, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_AC_VI:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC1, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_AC_BE:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC2, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_AC_BK:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC3, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void rt61pci_stop_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC0, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_AC_VI:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC1, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_AC_BE:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC2, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_AC_BK:\r\nrt2x00mmio_register_read(rt2x00dev, TX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC3, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CNTL_CSR, reg);\r\nbreak;\r\ncase QID_RX:\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic char *rt61pci_get_firmware_name(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu16 chip;\r\nchar *fw_name;\r\npci_read_config_word(to_pci_dev(rt2x00dev->dev), PCI_DEVICE_ID, &chip);\r\nswitch (chip) {\r\ncase RT2561_PCI_ID:\r\nfw_name = FIRMWARE_RT2561;\r\nbreak;\r\ncase RT2561s_PCI_ID:\r\nfw_name = FIRMWARE_RT2561s;\r\nbreak;\r\ncase RT2661_PCI_ID:\r\nfw_name = FIRMWARE_RT2661;\r\nbreak;\r\ndefault:\r\nfw_name = NULL;\r\nbreak;\r\n}\r\nreturn fw_name;\r\n}\r\nstatic int rt61pci_check_firmware(struct rt2x00_dev *rt2x00dev,\r\nconst u8 *data, const size_t len)\r\n{\r\nu16 fw_crc;\r\nu16 crc;\r\nif (len != 8192)\r\nreturn FW_BAD_LENGTH;\r\nfw_crc = (data[len - 2] << 8 | data[len - 1]);\r\ncrc = crc_itu_t(0, data, len - 2);\r\ncrc = crc_itu_t_byte(crc, 0);\r\ncrc = crc_itu_t_byte(crc, 0);\r\nreturn (fw_crc == crc) ? FW_OK : FW_BAD_CRC;\r\n}\r\nstatic int rt61pci_load_firmware(struct rt2x00_dev *rt2x00dev,\r\nconst u8 *data, const size_t len)\r\n{\r\nint i;\r\nu32 reg;\r\nfor (i = 0; i < 100; i++) {\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR0, &reg);\r\nif (reg)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!reg) {\r\nrt2x00_err(rt2x00dev, "Unstable hardware\n");\r\nreturn -EBUSY;\r\n}\r\nreg = 0;\r\nrt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\r\nrt2x00mmio_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);\r\nrt2x00mmio_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);\r\nrt2x00mmio_register_write(rt2x00dev, HOST_CMD_CSR, 0);\r\nreg = 0;\r\nrt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 1);\r\nrt2x00_set_field32(&reg, MCU_CNTL_CSR_SELECT_BANK, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE,\r\ndata, len);\r\nrt2x00_set_field32(&reg, MCU_CNTL_CSR_SELECT_BANK, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\r\nrt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_CNTL_CSR, reg);\r\nfor (i = 0; i < 100; i++) {\r\nrt2x00mmio_register_read(rt2x00dev, MCU_CNTL_CSR, &reg);\r\nif (rt2x00_get_field32(reg, MCU_CNTL_CSR_READY))\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (i == 100) {\r\nrt2x00_err(rt2x00dev, "MCU Control register not ready\n");\r\nreturn -EBUSY;\r\n}\r\nmsleep(1);\r\nreg = 0;\r\nrt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);\r\nrt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\r\nreturn 0;\r\n}\r\nstatic bool rt61pci_get_entry_state(struct queue_entry *entry)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nu32 word;\r\nif (entry->queue->qid == QID_RX) {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nreturn rt2x00_get_field32(word, RXD_W0_OWNER_NIC);\r\n} else {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nreturn (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\r\nrt2x00_get_field32(word, TXD_W0_VALID));\r\n}\r\n}\r\nstatic void rt61pci_clear_entry(struct queue_entry *entry)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nu32 word;\r\nif (entry->queue->qid == QID_RX) {\r\nrt2x00_desc_read(entry_priv->desc, 5, &word);\r\nrt2x00_set_field32(&word, RXD_W5_BUFFER_PHYSICAL_ADDRESS,\r\nskbdesc->skb_dma);\r\nrt2x00_desc_write(entry_priv->desc, 5, word);\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nrt2x00_set_field32(&word, RXD_W0_OWNER_NIC, 1);\r\nrt2x00_desc_write(entry_priv->desc, 0, word);\r\n} else {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nrt2x00_set_field32(&word, TXD_W0_VALID, 0);\r\nrt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 0);\r\nrt2x00_desc_write(entry_priv->desc, 0, word);\r\n}\r\n}\r\nstatic int rt61pci_init_queues(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TX_RING_CSR0, &reg);\r\nrt2x00_set_field32(&reg, TX_RING_CSR0_AC0_RING_SIZE,\r\nrt2x00dev->tx[0].limit);\r\nrt2x00_set_field32(&reg, TX_RING_CSR0_AC1_RING_SIZE,\r\nrt2x00dev->tx[1].limit);\r\nrt2x00_set_field32(&reg, TX_RING_CSR0_AC2_RING_SIZE,\r\nrt2x00dev->tx[2].limit);\r\nrt2x00_set_field32(&reg, TX_RING_CSR0_AC3_RING_SIZE,\r\nrt2x00dev->tx[3].limit);\r\nrt2x00mmio_register_write(rt2x00dev, TX_RING_CSR0, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TX_RING_CSR1, &reg);\r\nrt2x00_set_field32(&reg, TX_RING_CSR1_TXD_SIZE,\r\nrt2x00dev->tx[0].desc_size / 4);\r\nrt2x00mmio_register_write(rt2x00dev, TX_RING_CSR1, reg);\r\nentry_priv = rt2x00dev->tx[0].entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, AC0_BASE_CSR, &reg);\r\nrt2x00_set_field32(&reg, AC0_BASE_CSR_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, AC0_BASE_CSR, reg);\r\nentry_priv = rt2x00dev->tx[1].entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, AC1_BASE_CSR, &reg);\r\nrt2x00_set_field32(&reg, AC1_BASE_CSR_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, AC1_BASE_CSR, reg);\r\nentry_priv = rt2x00dev->tx[2].entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, AC2_BASE_CSR, &reg);\r\nrt2x00_set_field32(&reg, AC2_BASE_CSR_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, AC2_BASE_CSR, reg);\r\nentry_priv = rt2x00dev->tx[3].entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, AC3_BASE_CSR, &reg);\r\nrt2x00_set_field32(&reg, AC3_BASE_CSR_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, AC3_BASE_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, RX_RING_CSR, &reg);\r\nrt2x00_set_field32(&reg, RX_RING_CSR_RING_SIZE, rt2x00dev->rx->limit);\r\nrt2x00_set_field32(&reg, RX_RING_CSR_RXD_SIZE,\r\nrt2x00dev->rx->desc_size / 4);\r\nrt2x00_set_field32(&reg, RX_RING_CSR_RXD_WRITEBACK_SIZE, 4);\r\nrt2x00mmio_register_write(rt2x00dev, RX_RING_CSR, reg);\r\nentry_priv = rt2x00dev->rx->entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, RX_BASE_CSR, &reg);\r\nrt2x00_set_field32(&reg, RX_BASE_CSR_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, RX_BASE_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TX_DMA_DST_CSR, &reg);\r\nrt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC0, 2);\r\nrt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC1, 2);\r\nrt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC2, 2);\r\nrt2x00_set_field32(&reg, TX_DMA_DST_CSR_DEST_AC3, 2);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DMA_DST_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, LOAD_TX_RING_CSR, &reg);\r\nrt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC0, 1);\r\nrt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC1, 1);\r\nrt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC2, 1);\r\nrt2x00_set_field32(&reg, LOAD_TX_RING_CSR_LOAD_TXD_AC3, 1);\r\nrt2x00mmio_register_write(rt2x00dev, LOAD_TX_RING_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, RX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, RX_CNTL_CSR_LOAD_RXD, 1);\r\nrt2x00mmio_register_write(rt2x00dev, RX_CNTL_CSR, reg);\r\nreturn 0;\r\n}\r\nstatic int rt61pci_init_registers(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR0, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_AUTO_TX_SEQ, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR0_TX_WITHOUT_WAITING, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR0, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR1, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID0, 47);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID0_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID1, 30);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID1_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID2, 42);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID2_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID3, 30);\r\nrt2x00_set_field32(&reg, TXRX_CSR1_BBP_ID3_VALID, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR2, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID0, 13);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID0_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID1, 12);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID1_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID2, 11);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID2_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID3, 10);\r\nrt2x00_set_field32(&reg, TXRX_CSR2_BBP_ID3_VALID, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR2, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR3, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID0, 7);\r\nrt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID0_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID1, 6);\r\nrt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID1_VALID, 1);\r\nrt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID2, 5);\r\nrt2x00_set_field32(&reg, TXRX_CSR3_BBP_ID2_VALID, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR3, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR7, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_6MBS, 59);\r\nrt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_9MBS, 53);\r\nrt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_12MBS, 49);\r\nrt2x00_set_field32(&reg, TXRX_CSR7_ACK_CTS_18MBS, 46);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR7, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR8, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_24MBS, 44);\r\nrt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_36MBS, 42);\r\nrt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_48MBS, 42);\r\nrt2x00_set_field32(&reg, TXRX_CSR8_ACK_CTS_54MBS, 42);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR8, reg);\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TSF_SYNC, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_TIMESTAMP_COMPENSATE, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR15, 0x0000000f);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR6, 0x00000fff);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR9, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR9_CW_SELECT, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR9, reg);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR10, 0x0000071c);\r\nif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\r\nreturn -EBUSY;\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR13, 0x0000e000);\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR0, 0x00000000);\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR1, 0x00000000);\r\nrt2x00mmio_register_write(rt2x00dev, SEC_CSR5, 0x00000000);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR1, 0x000023b0);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR5, 0x060a100c);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR6, 0x00080606);\r\nrt2x00mmio_register_write(rt2x00dev, PHY_CSR7, 0x00000a08);\r\nrt2x00mmio_register_write(rt2x00dev, PCI_CFG_CSR, 0x28ca4404);\r\nrt2x00mmio_register_write(rt2x00dev, TEST_MODE_CSR, 0x00000200);\r\nrt2x00mmio_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);\r\nrt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE0, 0);\r\nrt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE1, 0);\r\nrt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE2, 0);\r\nrt2x00mmio_register_write(rt2x00dev, HW_BEACON_BASE3, 0);\r\nrt2x00mmio_register_read(rt2x00dev, STA_CSR0, &reg);\r\nrt2x00mmio_register_read(rt2x00dev, STA_CSR1, &reg);\r\nrt2x00mmio_register_read(rt2x00dev, STA_CSR2, &reg);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);\r\nrt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);\r\nrt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR1, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR1, reg);\r\nreturn 0;\r\n}\r\nstatic int rt61pci_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu8 value;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt61pci_bbp_read(rt2x00dev, 0, &value);\r\nif ((value != 0xff) && (value != 0x00))\r\nreturn 0;\r\nudelay(REGISTER_BUSY_DELAY);\r\n}\r\nrt2x00_err(rt2x00dev, "BBP register access failed, aborting\n");\r\nreturn -EACCES;\r\n}\r\nstatic int rt61pci_init_bbp(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu16 eeprom;\r\nu8 reg_id;\r\nu8 value;\r\nif (unlikely(rt61pci_wait_bbp_ready(rt2x00dev)))\r\nreturn -EACCES;\r\nrt61pci_bbp_write(rt2x00dev, 3, 0x00);\r\nrt61pci_bbp_write(rt2x00dev, 15, 0x30);\r\nrt61pci_bbp_write(rt2x00dev, 21, 0xc8);\r\nrt61pci_bbp_write(rt2x00dev, 22, 0x38);\r\nrt61pci_bbp_write(rt2x00dev, 23, 0x06);\r\nrt61pci_bbp_write(rt2x00dev, 24, 0xfe);\r\nrt61pci_bbp_write(rt2x00dev, 25, 0x0a);\r\nrt61pci_bbp_write(rt2x00dev, 26, 0x0d);\r\nrt61pci_bbp_write(rt2x00dev, 34, 0x12);\r\nrt61pci_bbp_write(rt2x00dev, 37, 0x07);\r\nrt61pci_bbp_write(rt2x00dev, 39, 0xf8);\r\nrt61pci_bbp_write(rt2x00dev, 41, 0x60);\r\nrt61pci_bbp_write(rt2x00dev, 53, 0x10);\r\nrt61pci_bbp_write(rt2x00dev, 54, 0x18);\r\nrt61pci_bbp_write(rt2x00dev, 60, 0x10);\r\nrt61pci_bbp_write(rt2x00dev, 61, 0x04);\r\nrt61pci_bbp_write(rt2x00dev, 62, 0x04);\r\nrt61pci_bbp_write(rt2x00dev, 75, 0xfe);\r\nrt61pci_bbp_write(rt2x00dev, 86, 0xfe);\r\nrt61pci_bbp_write(rt2x00dev, 88, 0xfe);\r\nrt61pci_bbp_write(rt2x00dev, 90, 0x0f);\r\nrt61pci_bbp_write(rt2x00dev, 99, 0x00);\r\nrt61pci_bbp_write(rt2x00dev, 102, 0x16);\r\nrt61pci_bbp_write(rt2x00dev, 107, 0x04);\r\nfor (i = 0; i < EEPROM_BBP_SIZE; i++) {\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i, &eeprom);\r\nif (eeprom != 0xffff && eeprom != 0x0000) {\r\nreg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);\r\nrt61pci_bbp_write(rt2x00dev, reg_id, value);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rt61pci_toggle_irq(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nint mask = (state == STATE_RADIO_IRQ_OFF);\r\nu32 reg;\r\nunsigned long flags;\r\nif (state == STATE_RADIO_IRQ_ON) {\r\nrt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MCU_INT_SOURCE_CSR, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg);\r\n}\r\nspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\r\nrt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_TXDONE, mask);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_RXDONE, mask);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_BEACON_DONE, mask);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_ENABLE_MITIGATION, mask);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_MITIGATION_PERIOD, 0xff);\r\nrt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MCU_INT_MASK_CSR, &reg);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_0, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_1, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_2, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_3, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_4, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_5, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_6, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_7, mask);\r\nrt2x00_set_field32(&reg, MCU_INT_MASK_CSR_TWAKEUP, mask);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);\r\nspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\r\nif (state == STATE_RADIO_IRQ_OFF) {\r\ntasklet_kill(&rt2x00dev->txstatus_tasklet);\r\ntasklet_kill(&rt2x00dev->rxdone_tasklet);\r\ntasklet_kill(&rt2x00dev->autowake_tasklet);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\n}\r\n}\r\nstatic int rt61pci_enable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nif (unlikely(rt61pci_init_queues(rt2x00dev) ||\r\nrt61pci_init_registers(rt2x00dev) ||\r\nrt61pci_init_bbp(rt2x00dev)))\r\nreturn -EIO;\r\nrt2x00mmio_register_read(rt2x00dev, RX_CNTL_CSR, &reg);\r\nrt2x00_set_field32(&reg, RX_CNTL_CSR_ENABLE_RX_DMA, 1);\r\nrt2x00mmio_register_write(rt2x00dev, RX_CNTL_CSR, reg);\r\nreturn 0;\r\n}\r\nstatic void rt61pci_disable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR10, 0x00001818);\r\n}\r\nstatic int rt61pci_set_state(struct rt2x00_dev *rt2x00dev, enum dev_state state)\r\n{\r\nu32 reg, reg2;\r\nunsigned int i;\r\nchar put_to_sleep;\r\nput_to_sleep = (state != STATE_AWAKE);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR12, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR12_FORCE_WAKEUP, !put_to_sleep);\r\nrt2x00_set_field32(&reg, MAC_CSR12_PUT_TO_SLEEP, put_to_sleep);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR12, reg);\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR12, &reg2);\r\nstate = rt2x00_get_field32(reg2, MAC_CSR12_BBP_CURRENT_STATE);\r\nif (state == !put_to_sleep)\r\nreturn 0;\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR12, reg);\r\nmsleep(10);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int rt61pci_set_device_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nint retval = 0;\r\nswitch (state) {\r\ncase STATE_RADIO_ON:\r\nretval = rt61pci_enable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_OFF:\r\nrt61pci_disable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_IRQ_ON:\r\ncase STATE_RADIO_IRQ_OFF:\r\nrt61pci_toggle_irq(rt2x00dev, state);\r\nbreak;\r\ncase STATE_DEEP_SLEEP:\r\ncase STATE_SLEEP:\r\ncase STATE_STANDBY:\r\ncase STATE_AWAKE:\r\nretval = rt61pci_set_state(rt2x00dev, state);\r\nbreak;\r\ndefault:\r\nretval = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (unlikely(retval))\r\nrt2x00_err(rt2x00dev, "Device failed to enter state %d (%d)\n",\r\nstate, retval);\r\nreturn retval;\r\n}\r\nstatic void rt61pci_write_tx_desc(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\n__le32 *txd = entry_priv->desc;\r\nu32 word;\r\nrt2x00_desc_read(txd, 1, &word);\r\nrt2x00_set_field32(&word, TXD_W1_HOST_Q_ID, entry->queue->qid);\r\nrt2x00_set_field32(&word, TXD_W1_AIFSN, entry->queue->aifs);\r\nrt2x00_set_field32(&word, TXD_W1_CWMIN, entry->queue->cw_min);\r\nrt2x00_set_field32(&word, TXD_W1_CWMAX, entry->queue->cw_max);\r\nrt2x00_set_field32(&word, TXD_W1_IV_OFFSET, txdesc->iv_offset);\r\nrt2x00_set_field32(&word, TXD_W1_HW_SEQUENCE,\r\ntest_bit(ENTRY_TXD_GENERATE_SEQ, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W1_BUFFER_COUNT, 1);\r\nrt2x00_desc_write(txd, 1, word);\r\nrt2x00_desc_read(txd, 2, &word);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_SIGNAL, txdesc->u.plcp.signal);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_SERVICE, txdesc->u.plcp.service);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_LOW,\r\ntxdesc->u.plcp.length_low);\r\nrt2x00_set_field32(&word, TXD_W2_PLCP_LENGTH_HIGH,\r\ntxdesc->u.plcp.length_high);\r\nrt2x00_desc_write(txd, 2, word);\r\nif (test_bit(ENTRY_TXD_ENCRYPT, &txdesc->flags)) {\r\n_rt2x00_desc_write(txd, 3, skbdesc->iv[0]);\r\n_rt2x00_desc_write(txd, 4, skbdesc->iv[1]);\r\n}\r\nrt2x00_desc_read(txd, 5, &word);\r\nrt2x00_set_field32(&word, TXD_W5_PID_TYPE, entry->queue->qid);\r\nrt2x00_set_field32(&word, TXD_W5_PID_SUBTYPE,\r\nskbdesc->entry->entry_idx);\r\nrt2x00_set_field32(&word, TXD_W5_TX_POWER,\r\nTXPOWER_TO_DEV(entry->queue->rt2x00dev->tx_power));\r\nrt2x00_set_field32(&word, TXD_W5_WAITING_DMA_DONE_INT, 1);\r\nrt2x00_desc_write(txd, 5, word);\r\nif (entry->queue->qid != QID_BEACON) {\r\nrt2x00_desc_read(txd, 6, &word);\r\nrt2x00_set_field32(&word, TXD_W6_BUFFER_PHYSICAL_ADDRESS,\r\nskbdesc->skb_dma);\r\nrt2x00_desc_write(txd, 6, word);\r\nrt2x00_desc_read(txd, 11, &word);\r\nrt2x00_set_field32(&word, TXD_W11_BUFFER_LENGTH0,\r\ntxdesc->length);\r\nrt2x00_desc_write(txd, 11, word);\r\n}\r\nrt2x00_desc_read(txd, 0, &word);\r\nrt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 1);\r\nrt2x00_set_field32(&word, TXD_W0_VALID, 1);\r\nrt2x00_set_field32(&word, TXD_W0_MORE_FRAG,\r\ntest_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_ACK,\r\ntest_bit(ENTRY_TXD_ACK, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_TIMESTAMP,\r\ntest_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_OFDM,\r\n(txdesc->rate_mode == RATE_MODE_OFDM));\r\nrt2x00_set_field32(&word, TXD_W0_IFS, txdesc->u.plcp.ifs);\r\nrt2x00_set_field32(&word, TXD_W0_RETRY_MODE,\r\ntest_bit(ENTRY_TXD_RETRY_MODE, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_TKIP_MIC,\r\ntest_bit(ENTRY_TXD_ENCRYPT_MMIC, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_KEY_TABLE,\r\ntest_bit(ENTRY_TXD_ENCRYPT_PAIRWISE, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_KEY_INDEX, txdesc->key_idx);\r\nrt2x00_set_field32(&word, TXD_W0_DATABYTE_COUNT, txdesc->length);\r\nrt2x00_set_field32(&word, TXD_W0_BURST,\r\ntest_bit(ENTRY_TXD_BURST, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_CIPHER_ALG, txdesc->cipher);\r\nrt2x00_desc_write(txd, 0, word);\r\nskbdesc->desc = txd;\r\nskbdesc->desc_len = (entry->queue->qid == QID_BEACON) ? TXINFO_SIZE :\r\nTXD_DESC_SIZE;\r\n}\r\nstatic void rt61pci_write_beacon(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nunsigned int beacon_base;\r\nunsigned int padding_len;\r\nu32 orig_reg, reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &reg);\r\norig_reg = reg;\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\nrt61pci_write_tx_desc(entry, txdesc);\r\nrt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_BEACON, entry->skb);\r\npadding_len = roundup(entry->skb->len, 4) - entry->skb->len;\r\nif (padding_len && skb_pad(entry->skb, padding_len)) {\r\nrt2x00_err(rt2x00dev, "Failure padding beacon, aborting\n");\r\nentry->skb = NULL;\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, orig_reg);\r\nreturn;\r\n}\r\nbeacon_base = HW_BEACON_OFFSET(entry->entry_idx);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, beacon_base,\r\nentry_priv->desc, TXINFO_SIZE);\r\nrt2x00mmio_register_multiwrite(rt2x00dev, beacon_base + TXINFO_SIZE,\r\nentry->skb->data,\r\nentry->skb->len + padding_len);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR10, 0x00001008);\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\ndev_kfree_skb_any(entry->skb);\r\nentry->skb = NULL;\r\n}\r\nstatic void rt61pci_clear_beacon(struct queue_entry *entry)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nu32 orig_reg, reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR9, &orig_reg);\r\nreg = orig_reg;\r\nrt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, reg);\r\nrt2x00mmio_register_write(rt2x00dev,\r\nHW_BEACON_OFFSET(entry->entry_idx), 0);\r\nrt2x00mmio_register_write(rt2x00dev, TXRX_CSR9, orig_reg);\r\n}\r\nstatic int rt61pci_agc_to_rssi(struct rt2x00_dev *rt2x00dev, int rxd_w1)\r\n{\r\nu8 offset = rt2x00dev->lna_gain;\r\nu8 lna;\r\nlna = rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_LNA);\r\nswitch (lna) {\r\ncase 3:\r\noffset += 90;\r\nbreak;\r\ncase 2:\r\noffset += 74;\r\nbreak;\r\ncase 1:\r\noffset += 64;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (rt2x00dev->curr_band == IEEE80211_BAND_5GHZ) {\r\nif (lna == 3 || lna == 2)\r\noffset += 10;\r\n}\r\nreturn rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_AGC) * 2 - offset;\r\n}\r\nstatic void rt61pci_fill_rxdone(struct queue_entry *entry,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nu32 word0;\r\nu32 word1;\r\nrt2x00_desc_read(entry_priv->desc, 0, &word0);\r\nrt2x00_desc_read(entry_priv->desc, 1, &word1);\r\nif (rt2x00_get_field32(word0, RXD_W0_CRC_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\r\nrxdesc->cipher = rt2x00_get_field32(word0, RXD_W0_CIPHER_ALG);\r\nrxdesc->cipher_status = rt2x00_get_field32(word0, RXD_W0_CIPHER_ERROR);\r\nif (rxdesc->cipher != CIPHER_NONE) {\r\n_rt2x00_desc_read(entry_priv->desc, 2, &rxdesc->iv[0]);\r\n_rt2x00_desc_read(entry_priv->desc, 3, &rxdesc->iv[1]);\r\nrxdesc->dev_flags |= RXDONE_CRYPTO_IV;\r\n_rt2x00_desc_read(entry_priv->desc, 4, &rxdesc->icv);\r\nrxdesc->dev_flags |= RXDONE_CRYPTO_ICV;\r\nrxdesc->flags |= RX_FLAG_IV_STRIPPED;\r\nrxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\r\nif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)\r\nrxdesc->flags |= RX_FLAG_DECRYPTED;\r\nelse if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)\r\nrxdesc->flags |= RX_FLAG_MMIC_ERROR;\r\n}\r\nrxdesc->signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);\r\nrxdesc->rssi = rt61pci_agc_to_rssi(rt2x00dev, word1);\r\nrxdesc->size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);\r\nif (rt2x00_get_field32(word0, RXD_W0_OFDM))\r\nrxdesc->dev_flags |= RXDONE_SIGNAL_PLCP;\r\nelse\r\nrxdesc->dev_flags |= RXDONE_SIGNAL_BITRATE;\r\nif (rt2x00_get_field32(word0, RXD_W0_MY_BSS))\r\nrxdesc->dev_flags |= RXDONE_MY_BSS;\r\n}\r\nstatic void rt61pci_txdone(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nstruct queue_entry *entry;\r\nstruct queue_entry *entry_done;\r\nstruct queue_entry_priv_mmio *entry_priv;\r\nstruct txdone_entry_desc txdesc;\r\nu32 word;\r\nu32 reg;\r\nint type;\r\nint index;\r\nint i;\r\nfor (i = 0; i < rt2x00dev->tx->limit; i++) {\r\nrt2x00mmio_register_read(rt2x00dev, STA_CSR4, &reg);\r\nif (!rt2x00_get_field32(reg, STA_CSR4_VALID))\r\nbreak;\r\ntype = rt2x00_get_field32(reg, STA_CSR4_PID_TYPE);\r\nqueue = rt2x00queue_get_tx_queue(rt2x00dev, type);\r\nif (unlikely(!queue))\r\ncontinue;\r\nindex = rt2x00_get_field32(reg, STA_CSR4_PID_SUBTYPE);\r\nif (unlikely(index >= queue->limit))\r\ncontinue;\r\nentry = &queue->entries[index];\r\nentry_priv = entry->priv_data;\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nif (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\r\n!rt2x00_get_field32(word, TXD_W0_VALID))\r\nreturn;\r\nentry_done = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\nwhile (entry != entry_done) {\r\nrt2x00_warn(rt2x00dev, "TX status report missed for entry %d\n",\r\nentry_done->entry_idx);\r\nrt2x00lib_txdone_noinfo(entry_done, TXDONE_UNKNOWN);\r\nentry_done = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\n}\r\ntxdesc.flags = 0;\r\nswitch (rt2x00_get_field32(reg, STA_CSR4_TX_RESULT)) {\r\ncase 0:\r\n__set_bit(TXDONE_SUCCESS, &txdesc.flags);\r\nbreak;\r\ncase 6:\r\n__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);\r\ndefault:\r\n__set_bit(TXDONE_FAILURE, &txdesc.flags);\r\n}\r\ntxdesc.retry = rt2x00_get_field32(reg, STA_CSR4_RETRY_COUNT);\r\nif (txdesc.retry)\r\n__set_bit(TXDONE_FALLBACK, &txdesc.flags);\r\nrt2x00lib_txdone(entry, &txdesc);\r\n}\r\n}\r\nstatic void rt61pci_wakeup(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct rt2x00lib_conf libconf = { .conf = &rt2x00dev->hw->conf };\r\nrt61pci_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);\r\n}\r\nstatic inline void rt61pci_enable_interrupt(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_field32 irq_field)\r\n{\r\nu32 reg;\r\nspin_lock_irq(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);\r\nrt2x00_set_field32(&reg, irq_field, 0);\r\nrt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\r\nspin_unlock_irq(&rt2x00dev->irqmask_lock);\r\n}\r\nstatic void rt61pci_enable_mcu_interrupt(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_field32 irq_field)\r\n{\r\nu32 reg;\r\nspin_lock_irq(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, MCU_INT_MASK_CSR, &reg);\r\nrt2x00_set_field32(&reg, irq_field, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);\r\nspin_unlock_irq(&rt2x00dev->irqmask_lock);\r\n}\r\nstatic void rt61pci_txstatus_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nrt61pci_txdone(rt2x00dev);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt61pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_TXDONE);\r\n}\r\nstatic void rt61pci_tbtt_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nrt2x00lib_beacondone(rt2x00dev);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt61pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_BEACON_DONE);\r\n}\r\nstatic void rt61pci_rxdone_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nif (rt2x00mmio_rxdone(rt2x00dev))\r\ntasklet_schedule(&rt2x00dev->rxdone_tasklet);\r\nelse if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt61pci_enable_interrupt(rt2x00dev, INT_MASK_CSR_RXDONE);\r\n}\r\nstatic void rt61pci_autowake_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nrt61pci_wakeup(rt2x00dev);\r\nrt2x00mmio_register_write(rt2x00dev,\r\nM2H_CMD_DONE_CSR, 0xffffffff);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt61pci_enable_mcu_interrupt(rt2x00dev, MCU_INT_MASK_CSR_TWAKEUP);\r\n}\r\nstatic irqreturn_t rt61pci_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = dev_instance;\r\nu32 reg_mcu, mask_mcu;\r\nu32 reg, mask;\r\nrt2x00mmio_register_read(rt2x00dev, MCU_INT_SOURCE_CSR, &reg_mcu);\r\nrt2x00mmio_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg_mcu);\r\nrt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\r\nif (!reg && !reg_mcu)\r\nreturn IRQ_NONE;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn IRQ_HANDLED;\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_RXDONE))\r\ntasklet_schedule(&rt2x00dev->rxdone_tasklet);\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_TXDONE))\r\ntasklet_schedule(&rt2x00dev->txstatus_tasklet);\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_BEACON_DONE))\r\ntasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);\r\nif (rt2x00_get_field32(reg_mcu, MCU_INT_SOURCE_CSR_TWAKEUP))\r\ntasklet_schedule(&rt2x00dev->autowake_tasklet);\r\nmask = reg;\r\nmask_mcu = reg_mcu;\r\nspin_lock(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);\r\nreg |= mask;\r\nrt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, MCU_INT_MASK_CSR, &reg);\r\nreg |= mask_mcu;\r\nrt2x00mmio_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);\r\nspin_unlock(&rt2x00dev->irqmask_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rt61pci_validate_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct eeprom_93cx6 eeprom;\r\nu32 reg;\r\nu16 word;\r\nu8 *mac;\r\ns8 value;\r\nrt2x00mmio_register_read(rt2x00dev, E2PROM_CSR, &reg);\r\neeprom.data = rt2x00dev;\r\neeprom.register_read = rt61pci_eepromregister_read;\r\neeprom.register_write = rt61pci_eepromregister_write;\r\neeprom.width = rt2x00_get_field32(reg, E2PROM_CSR_TYPE_93C46) ?\r\nPCI_EEPROM_WIDTH_93C46 : PCI_EEPROM_WIDTH_93C66;\r\neeprom.reg_data_in = 0;\r\neeprom.reg_data_out = 0;\r\neeprom.reg_data_clock = 0;\r\neeprom.reg_chip_select = 0;\r\neeprom_93cx6_multiread(&eeprom, EEPROM_BASE, rt2x00dev->eeprom,\r\nEEPROM_SIZE / sizeof(u16));\r\nmac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);\r\nif (!is_valid_ether_addr(mac)) {\r\neth_random_addr(mac);\r\nrt2x00_eeprom_dbg(rt2x00dev, "MAC: %pM\n", mac);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_TX_DEFAULT,\r\nANTENNA_B);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_RX_DEFAULT,\r\nANTENNA_B);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_FRAME_TYPE, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_DYN_TXAGC, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_HARDWARE_RADIO, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_RF_TYPE, RF5225);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_ANTENNA, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_NIC, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_NIC_ENABLE_DIVERSITY, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_TX_DIVERSITY, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_RX_FIXED, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_TX_FIXED, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_EXTERNAL_LNA_BG, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_CARDBUS_ACCEL, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_EXTERNAL_LNA_A, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_NIC, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "NIC: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_LED, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_LED_LED_MODE,\r\nLED_MODE_DEFAULT);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_LED, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "Led: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_FREQ_OFFSET, 0);\r\nrt2x00_set_field16(&word, EEPROM_FREQ_SEQ, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_FREQ, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "Freq: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "RSSI OFFSET BG: 0x%04x\n", word);\r\n} else {\r\nvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_1);\r\nif (value < -10 || value > 10)\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);\r\nvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_2);\r\nif (value < -10 || value > 10)\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "RSSI OFFSET A: 0x%04x\n", word);\r\n} else {\r\nvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_1);\r\nif (value < -10 || value > 10)\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);\r\nvalue = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_2);\r\nif (value < -10 || value > 10)\r\nrt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt61pci_init_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nu16 value;\r\nu16 eeprom;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR0, &reg);\r\nrt2x00_set_chip(rt2x00dev, rt2x00_get_field32(reg, MAC_CSR0_CHIPSET),\r\nvalue, rt2x00_get_field32(reg, MAC_CSR0_REVISION));\r\nif (!rt2x00_rf(rt2x00dev, RF5225) &&\r\n!rt2x00_rf(rt2x00dev, RF5325) &&\r\n!rt2x00_rf(rt2x00dev, RF2527) &&\r\n!rt2x00_rf(rt2x00dev, RF2529)) {\r\nrt2x00_err(rt2x00dev, "Invalid RF chipset detected\n");\r\nreturn -ENODEV;\r\n}\r\nif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_NUM) == 2)\r\n__set_bit(CAPABILITY_DOUBLE_ANTENNA, &rt2x00dev->cap_flags);\r\nrt2x00dev->default_ant.tx =\r\nrt2x00_get_field16(eeprom, EEPROM_ANTENNA_TX_DEFAULT);\r\nrt2x00dev->default_ant.rx =\r\nrt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_DEFAULT);\r\nif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_FRAME_TYPE))\r\n__set_bit(CAPABILITY_FRAME_TYPE, &rt2x00dev->cap_flags);\r\nif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))\r\n__set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_FREQ, &eeprom);\r\nif (rt2x00_get_field16(eeprom, EEPROM_FREQ_SEQ))\r\n__set_bit(CAPABILITY_RF_SEQUENCE, &rt2x00dev->cap_flags);\r\nrt2x00dev->freq_offset = rt2x00_get_field16(eeprom, EEPROM_FREQ_OFFSET);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_NIC, &eeprom);\r\nif (rt2x00_get_field16(eeprom, EEPROM_NIC_EXTERNAL_LNA_A))\r\n__set_bit(CAPABILITY_EXTERNAL_LNA_A, &rt2x00dev->cap_flags);\r\nif (rt2x00_get_field16(eeprom, EEPROM_NIC_EXTERNAL_LNA_BG))\r\n__set_bit(CAPABILITY_EXTERNAL_LNA_BG, &rt2x00dev->cap_flags);\r\nif (rt2x00_rf(rt2x00dev, RF2529) &&\r\n!rt2x00_has_cap_double_antenna(rt2x00dev)) {\r\nrt2x00dev->default_ant.rx =\r\nANTENNA_A + rt2x00_get_field16(eeprom, EEPROM_NIC_RX_FIXED);\r\nrt2x00dev->default_ant.tx =\r\nANTENNA_B - rt2x00_get_field16(eeprom, EEPROM_NIC_TX_FIXED);\r\nif (rt2x00_get_field16(eeprom, EEPROM_NIC_TX_DIVERSITY))\r\nrt2x00dev->default_ant.tx = ANTENNA_SW_DIVERSITY;\r\nif (rt2x00_get_field16(eeprom, EEPROM_NIC_ENABLE_DIVERSITY))\r\nrt2x00dev->default_ant.rx = ANTENNA_SW_DIVERSITY;\r\n}\r\n#ifdef CONFIG_RT2X00_LIB_LEDS\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_LED, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_LED_LED_MODE);\r\nrt61pci_init_led(rt2x00dev, &rt2x00dev->led_radio, LED_TYPE_RADIO);\r\nrt61pci_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);\r\nif (value == LED_MODE_SIGNAL_STRENGTH)\r\nrt61pci_init_led(rt2x00dev, &rt2x00dev->led_qual,\r\nLED_TYPE_QUALITY);\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_LED_MODE, value);\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_0,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_GPIO_0));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_1,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_GPIO_1));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_2,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_GPIO_2));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_3,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_GPIO_3));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_GPIO_4,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_GPIO_4));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_ACT,\r\nrt2x00_get_field16(eeprom, EEPROM_LED_POLARITY_ACT));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_READY_BG,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_RDY_G));\r\nrt2x00_set_field16(&rt2x00dev->led_mcu_reg, MCU_LEDCS_POLARITY_READY_A,\r\nrt2x00_get_field16(eeprom,\r\nEEPROM_LED_POLARITY_RDY_A));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int rt61pci_probe_hw_mode(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct hw_mode_spec *spec = &rt2x00dev->spec;\r\nstruct channel_info *info;\r\nchar *tx_power;\r\nunsigned int i;\r\nrt2x00dev->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nieee80211_hw_set(rt2x00dev->hw, PS_NULLFUNC_STACK);\r\nieee80211_hw_set(rt2x00dev->hw, SUPPORTS_PS);\r\nieee80211_hw_set(rt2x00dev->hw, HOST_BROADCAST_PS_BUFFERING);\r\nieee80211_hw_set(rt2x00dev->hw, SIGNAL_DBM);\r\nSET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);\r\nSET_IEEE80211_PERM_ADDR(rt2x00dev->hw,\r\nrt2x00_eeprom_addr(rt2x00dev,\r\nEEPROM_MAC_ADDR_0));\r\nrt2x00dev->hw->max_rates = 1;\r\nrt2x00dev->hw->max_report_rates = 7;\r\nrt2x00dev->hw->max_rate_tries = 1;\r\nspec->supported_bands = SUPPORT_BAND_2GHZ;\r\nspec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;\r\nif (!rt2x00_has_cap_rf_sequence(rt2x00dev)) {\r\nspec->num_channels = 14;\r\nspec->channels = rf_vals_noseq;\r\n} else {\r\nspec->num_channels = 14;\r\nspec->channels = rf_vals_seq;\r\n}\r\nif (rt2x00_rf(rt2x00dev, RF5225) || rt2x00_rf(rt2x00dev, RF5325)) {\r\nspec->supported_bands |= SUPPORT_BAND_5GHZ;\r\nspec->num_channels = ARRAY_SIZE(rf_vals_seq);\r\n}\r\ninfo = kcalloc(spec->num_channels, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->channels_info = info;\r\ntx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_G_START);\r\nfor (i = 0; i < 14; i++) {\r\ninfo[i].max_power = MAX_TXPOWER;\r\ninfo[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);\r\n}\r\nif (spec->num_channels > 14) {\r\ntx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_A_START);\r\nfor (i = 14; i < spec->num_channels; i++) {\r\ninfo[i].max_power = MAX_TXPOWER;\r\ninfo[i].default_power1 =\r\nTXPOWER_FROM_DEV(tx_power[i - 14]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt61pci_probe_hw(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nu32 reg;\r\nrt2x00mmio_register_write(rt2x00dev, SOFT_RESET_CSR, 0x00000007);\r\nretval = rt61pci_validate_eeprom(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nretval = rt61pci_init_eeprom(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nrt2x00mmio_register_read(rt2x00dev, MAC_CSR13, &reg);\r\nrt2x00_set_field32(&reg, MAC_CSR13_DIR5, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_CSR13, reg);\r\nretval = rt61pci_probe_hw_mode(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\n__set_bit(CAPABILITY_CONTROL_FILTERS, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_FIRMWARE, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_DMA, &rt2x00dev->cap_flags);\r\nif (!modparam_nohwcrypt)\r\n__set_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags);\r\n__set_bit(CAPABILITY_LINK_TUNING, &rt2x00dev->cap_flags);\r\nrt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;\r\nreturn 0;\r\n}\r\nstatic int rt61pci_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue_idx,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct data_queue *queue;\r\nstruct rt2x00_field32 field;\r\nint retval;\r\nu32 reg;\r\nu32 offset;\r\nretval = rt2x00mac_conf_tx(hw, vif, queue_idx, params);\r\nif (retval)\r\nreturn retval;\r\nif (queue_idx >= 4)\r\nreturn 0;\r\nqueue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);\r\noffset = AC_TXOP_CSR0 + (sizeof(u32) * (!!(queue_idx & 2)));\r\nfield.bit_offset = (queue_idx & 1) * 16;\r\nfield.bit_mask = 0xffff << field.bit_offset;\r\nrt2x00mmio_register_read(rt2x00dev, offset, &reg);\r\nrt2x00_set_field32(&reg, field, queue->txop);\r\nrt2x00mmio_register_write(rt2x00dev, offset, reg);\r\nfield.bit_offset = queue_idx * 4;\r\nfield.bit_mask = 0xf << field.bit_offset;\r\nrt2x00mmio_register_read(rt2x00dev, AIFSN_CSR, &reg);\r\nrt2x00_set_field32(&reg, field, queue->aifs);\r\nrt2x00mmio_register_write(rt2x00dev, AIFSN_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CWMIN_CSR, &reg);\r\nrt2x00_set_field32(&reg, field, queue->cw_min);\r\nrt2x00mmio_register_write(rt2x00dev, CWMIN_CSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CWMAX_CSR, &reg);\r\nrt2x00_set_field32(&reg, field, queue->cw_max);\r\nrt2x00mmio_register_write(rt2x00dev, CWMAX_CSR, reg);\r\nreturn 0;\r\n}\r\nstatic u64 rt61pci_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nu64 tsf;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR13, &reg);\r\ntsf = (u64) rt2x00_get_field32(reg, TXRX_CSR13_HIGH_TSFTIMER) << 32;\r\nrt2x00mmio_register_read(rt2x00dev, TXRX_CSR12, &reg);\r\ntsf |= rt2x00_get_field32(reg, TXRX_CSR12_LOW_TSFTIMER);\r\nreturn tsf;\r\n}\r\nstatic void rt61pci_queue_init(struct data_queue *queue)\r\n{\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nqueue->limit = 32;\r\nqueue->data_size = DATA_FRAME_SIZE;\r\nqueue->desc_size = RXD_DESC_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nqueue->limit = 32;\r\nqueue->data_size = DATA_FRAME_SIZE;\r\nqueue->desc_size = TXD_DESC_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_BEACON:\r\nqueue->limit = 4;\r\nqueue->data_size = 0;\r\nqueue->desc_size = TXINFO_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_ATIM:\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic int rt61pci_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn rt2x00pci_probe(pci_dev, &rt61pci_ops);\r\n}
