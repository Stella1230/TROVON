int\r\nxfs_break_layouts(\r\nstruct inode *inode,\r\nuint *iolock,\r\nbool with_imutex)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nint error;\r\nASSERT(xfs_isilocked(ip, XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL));\r\nwhile ((error = break_layout(inode, false) == -EWOULDBLOCK)) {\r\nxfs_iunlock(ip, *iolock);\r\nif (with_imutex && (*iolock & XFS_IOLOCK_EXCL))\r\nmutex_unlock(&inode->i_mutex);\r\nerror = break_layout(inode, true);\r\n*iolock = XFS_IOLOCK_EXCL;\r\nif (with_imutex)\r\nmutex_lock(&inode->i_mutex);\r\nxfs_ilock(ip, *iolock);\r\n}\r\nreturn error;\r\n}\r\nint\r\nxfs_fs_get_uuid(\r\nstruct super_block *sb,\r\nu8 *buf,\r\nu32 *len,\r\nu64 *offset)\r\n{\r\nstruct xfs_mount *mp = XFS_M(sb);\r\nprintk_once(KERN_NOTICE\r\n"XFS (%s): using experimental pNFS feature, use at your own risk!\n",\r\nmp->m_fsname);\r\nif (*len < sizeof(uuid_t))\r\nreturn -EINVAL;\r\nmemcpy(buf, &mp->m_sb.sb_uuid, sizeof(uuid_t));\r\n*len = sizeof(uuid_t);\r\n*offset = offsetof(struct xfs_dsb, sb_uuid);\r\nreturn 0;\r\n}\r\nstatic void\r\nxfs_bmbt_to_iomap(\r\nstruct xfs_inode *ip,\r\nstruct iomap *iomap,\r\nstruct xfs_bmbt_irec *imap)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nif (imap->br_startblock == HOLESTARTBLOCK) {\r\niomap->blkno = IOMAP_NULL_BLOCK;\r\niomap->type = IOMAP_HOLE;\r\n} else if (imap->br_startblock == DELAYSTARTBLOCK) {\r\niomap->blkno = IOMAP_NULL_BLOCK;\r\niomap->type = IOMAP_DELALLOC;\r\n} else {\r\niomap->blkno =\r\nXFS_FSB_TO_DADDR(ip->i_mount, imap->br_startblock);\r\nif (imap->br_state == XFS_EXT_UNWRITTEN)\r\niomap->type = IOMAP_UNWRITTEN;\r\nelse\r\niomap->type = IOMAP_MAPPED;\r\n}\r\niomap->offset = XFS_FSB_TO_B(mp, imap->br_startoff);\r\niomap->length = XFS_FSB_TO_B(mp, imap->br_blockcount);\r\n}\r\nint\r\nxfs_fs_map_blocks(\r\nstruct inode *inode,\r\nloff_t offset,\r\nu64 length,\r\nstruct iomap *iomap,\r\nbool write,\r\nu32 *device_generation)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_bmbt_irec imap;\r\nxfs_fileoff_t offset_fsb, end_fsb;\r\nloff_t limit;\r\nint bmapi_flags = XFS_BMAPI_ENTIRE;\r\nint nimaps = 1;\r\nuint lock_flags;\r\nint error = 0;\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nif (XFS_IS_REALTIME_INODE(ip))\r\nreturn -ENXIO;\r\nxfs_ilock(ip, XFS_IOLOCK_EXCL);\r\nerror = -EINVAL;\r\nlimit = mp->m_super->s_maxbytes;\r\nif (!write)\r\nlimit = max(limit, round_up(i_size_read(inode),\r\ninode->i_sb->s_blocksize));\r\nif (offset > limit)\r\ngoto out_unlock;\r\nif (offset > limit - length)\r\nlength = limit - offset;\r\nerror = filemap_write_and_wait(inode->i_mapping);\r\nif (error)\r\ngoto out_unlock;\r\nerror = invalidate_inode_pages2(inode->i_mapping);\r\nif (WARN_ON_ONCE(error))\r\nreturn error;\r\nend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)offset + length);\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nlock_flags = xfs_ilock_data_map_shared(ip);\r\nerror = xfs_bmapi_read(ip, offset_fsb, end_fsb - offset_fsb,\r\n&imap, &nimaps, bmapi_flags);\r\nxfs_iunlock(ip, lock_flags);\r\nif (error)\r\ngoto out_unlock;\r\nif (write) {\r\nenum xfs_prealloc_flags flags = 0;\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nif (!nimaps || imap.br_startblock == HOLESTARTBLOCK) {\r\nerror = xfs_iomap_write_direct(ip, offset, length,\r\n&imap, nimaps);\r\nif (error)\r\ngoto out_unlock;\r\nflags |= XFS_PREALLOC_SET | XFS_PREALLOC_SYNC;\r\n}\r\nerror = xfs_update_prealloc_flags(ip, flags);\r\nif (error)\r\ngoto out_unlock;\r\n}\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nxfs_bmbt_to_iomap(ip, iomap, &imap);\r\n*device_generation = mp->m_generation;\r\nreturn error;\r\nout_unlock:\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_pnfs_validate_isize(\r\nstruct xfs_inode *ip,\r\nxfs_off_t isize)\r\n{\r\nstruct xfs_bmbt_irec imap;\r\nint nimaps = 1;\r\nint error = 0;\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\nerror = xfs_bmapi_read(ip, XFS_B_TO_FSBT(ip->i_mount, isize - 1), 1,\r\n&imap, &nimaps, 0);\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nif (error)\r\nreturn error;\r\nif (imap.br_startblock == HOLESTARTBLOCK ||\r\nimap.br_startblock == DELAYSTARTBLOCK ||\r\nimap.br_state == XFS_EXT_UNWRITTEN)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint\r\nxfs_fs_commit_blocks(\r\nstruct inode *inode,\r\nstruct iomap *maps,\r\nint nr_maps,\r\nstruct iattr *iattr)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_trans *tp;\r\nbool update_isize = false;\r\nint error, i;\r\nloff_t size;\r\nASSERT(iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME));\r\nxfs_ilock(ip, XFS_IOLOCK_EXCL);\r\nsize = i_size_read(inode);\r\nif ((iattr->ia_valid & ATTR_SIZE) && iattr->ia_size > size) {\r\nupdate_isize = true;\r\nsize = iattr->ia_size;\r\n}\r\nfor (i = 0; i < nr_maps; i++) {\r\nu64 start, length, end;\r\nstart = maps[i].offset;\r\nif (start > size)\r\ncontinue;\r\nend = start + maps[i].length;\r\nif (end > size)\r\nend = size;\r\nlength = end - start;\r\nif (!length)\r\ncontinue;\r\nerror = invalidate_inode_pages2_range(inode->i_mapping,\r\nstart >> PAGE_CACHE_SHIFT,\r\n(end - 1) >> PAGE_CACHE_SHIFT);\r\nWARN_ON_ONCE(error);\r\nerror = xfs_iomap_write_unwritten(ip, start, length);\r\nif (error)\r\ngoto out_drop_iolock;\r\n}\r\nif (update_isize) {\r\nerror = xfs_pnfs_validate_isize(ip, size);\r\nif (error)\r\ngoto out_drop_iolock;\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp);\r\ngoto out_drop_iolock;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nxfs_setattr_time(ip, iattr);\r\nif (update_isize) {\r\ni_size_write(inode, iattr->ia_size);\r\nip->i_d.di_size = iattr->ia_size;\r\n}\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp);\r\nout_drop_iolock:\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nreturn error;\r\n}
