static void\r\nicn_free_queue(icn_card *card, int channel)\r\n{\r\nstruct sk_buff_head *queue = &card->spqueue[channel];\r\nstruct sk_buff *skb;\r\nskb_queue_purge(queue);\r\ncard->xlen[channel] = 0;\r\ncard->sndcount[channel] = 0;\r\nif ((skb = card->xskb[channel])) {\r\ncard->xskb[channel] = NULL;\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\nstatic inline void\r\nicn_shiftout(unsigned short port,\r\nunsigned long val,\r\nint firstbit,\r\nint bitcount)\r\n{\r\nregister u_char s;\r\nregister u_char c;\r\nfor (s = firstbit, c = bitcount; c > 0; s--, c--)\r\nOUTB_P((u_char) ((val >> s) & 1) ? 0xff : 0, port);\r\n}\r\nstatic inline void\r\nicn_disable_ram(icn_card *card)\r\n{\r\nOUTB_P(0, ICN_MAPRAM);\r\n}\r\nstatic inline void\r\nicn_enable_ram(icn_card *card)\r\n{\r\nOUTB_P(0xff, ICN_MAPRAM);\r\n}\r\nstatic inline void\r\nicn_map_channel(icn_card *card, int channel)\r\n{\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "icn_map_channel %d %d\n", dev.channel, channel);\r\n#endif\r\nif ((channel == dev.channel) && (card == dev.mcard))\r\nreturn;\r\nif (dev.mcard)\r\nicn_disable_ram(dev.mcard);\r\nicn_shiftout(ICN_BANK, chan2bank[channel], 3, 4);\r\nicn_enable_ram(card);\r\ndev.mcard = card;\r\ndev.channel = channel;\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "icn_map_channel done\n");\r\n#endif\r\n}\r\nstatic inline int\r\nicn_lock_channel(icn_card *card, int channel)\r\n{\r\nregister int retval;\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "icn_lock_channel %d\n", channel);\r\n#endif\r\nif ((dev.channel == channel) && (card == dev.mcard)) {\r\ndev.chanlock++;\r\nretval = 1;\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "icn_lock_channel %d OK\n", channel);\r\n#endif\r\n} else {\r\nretval = 0;\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "icn_lock_channel %d FAILED, dc=%d\n", channel, dev.channel);\r\n#endif\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void\r\n__icn_release_channel(void)\r\n{\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "icn_release_channel l=%d\n", dev.chanlock);\r\n#endif\r\nif (dev.chanlock > 0)\r\ndev.chanlock--;\r\n}\r\nstatic inline void\r\nicn_release_channel(void)\r\n{\r\nulong flags;\r\nspin_lock_irqsave(&dev.devlock, flags);\r\n__icn_release_channel();\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\n}\r\nstatic inline int\r\nicn_trymaplock_channel(icn_card *card, int channel)\r\n{\r\nulong flags;\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "trymaplock c=%d dc=%d l=%d\n", channel, dev.channel,\r\ndev.chanlock);\r\n#endif\r\nspin_lock_irqsave(&dev.devlock, flags);\r\nif ((!dev.chanlock) ||\r\n((dev.channel == channel) && (dev.mcard == card))) {\r\ndev.chanlock++;\r\nicn_map_channel(card, channel);\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "trymaplock %d OK\n", channel);\r\n#endif\r\nreturn 1;\r\n}\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "trymaplock %d FAILED\n", channel);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void\r\nicn_maprelease_channel(icn_card *card, int channel)\r\n{\r\nulong flags;\r\n#ifdef MAP_DEBUG\r\nprintk(KERN_DEBUG "map_release c=%d l=%d\n", channel, dev.chanlock);\r\n#endif\r\nspin_lock_irqsave(&dev.devlock, flags);\r\nif (dev.chanlock > 0)\r\ndev.chanlock--;\r\nif (!dev.chanlock)\r\nicn_map_channel(card, channel);\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\n}\r\nstatic void\r\nicn_pollbchan_receive(int channel, icn_card *card)\r\n{\r\nint mch = channel + ((card->secondhalf) ? 2 : 0);\r\nint eflag;\r\nint cnt;\r\nstruct sk_buff *skb;\r\nif (icn_trymaplock_channel(card, mch)) {\r\nwhile (rbavl) {\r\ncnt = readb(&rbuf_l);\r\nif ((card->rcvidx[channel] + cnt) > 4000) {\r\nprintk(KERN_WARNING\r\n"icn: (%s) bogus packet on ch%d, dropping.\n",\r\nCID,\r\nchannel + 1);\r\ncard->rcvidx[channel] = 0;\r\neflag = 0;\r\n} else {\r\nmemcpy_fromio(&card->rcvbuf[channel][card->rcvidx[channel]],\r\n&rbuf_d, cnt);\r\ncard->rcvidx[channel] += cnt;\r\neflag = readb(&rbuf_f);\r\n}\r\nrbnext;\r\nicn_maprelease_channel(card, mch & 2);\r\nif (!eflag) {\r\nif ((cnt = card->rcvidx[channel])) {\r\nif (!(skb = dev_alloc_skb(cnt))) {\r\nprintk(KERN_WARNING "icn: receive out of memory\n");\r\nbreak;\r\n}\r\nmemcpy(skb_put(skb, cnt), card->rcvbuf[channel], cnt);\r\ncard->rcvidx[channel] = 0;\r\ncard->interface.rcvcallb_skb(card->myid, channel, skb);\r\n}\r\n}\r\nif (!icn_trymaplock_channel(card, mch))\r\nbreak;\r\n}\r\nicn_maprelease_channel(card, mch & 2);\r\n}\r\n}\r\nstatic void\r\nicn_pollbchan_send(int channel, icn_card *card)\r\n{\r\nint mch = channel + ((card->secondhalf) ? 2 : 0);\r\nint cnt;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nisdn_ctrl cmd;\r\nif (!(card->sndcount[channel] || card->xskb[channel] ||\r\n!skb_queue_empty(&card->spqueue[channel])))\r\nreturn;\r\nif (icn_trymaplock_channel(card, mch)) {\r\nwhile (sbfree &&\r\n(card->sndcount[channel] ||\r\n!skb_queue_empty(&card->spqueue[channel]) ||\r\ncard->xskb[channel])) {\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->xmit_lock[channel]) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\n}\r\ncard->xmit_lock[channel]++;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nskb = card->xskb[channel];\r\nif (!skb) {\r\nskb = skb_dequeue(&card->spqueue[channel]);\r\nif (skb) {\r\nif (*(skb_pull(skb, 1)))\r\ncard->xlen[channel] = skb->len;\r\nelse\r\ncard->xlen[channel] = 0;\r\n}\r\n}\r\nif (!skb)\r\nbreak;\r\nif (skb->len > ICN_FRAGSIZE) {\r\nwriteb(0xff, &sbuf_f);\r\ncnt = ICN_FRAGSIZE;\r\n} else {\r\nwriteb(0x0, &sbuf_f);\r\ncnt = skb->len;\r\n}\r\nwriteb(cnt, &sbuf_l);\r\nmemcpy_toio(&sbuf_d, skb->data, cnt);\r\nskb_pull(skb, cnt);\r\nsbnext;\r\nicn_maprelease_channel(card, mch & 2);\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->sndcount[channel] -= cnt;\r\nif (!skb->len) {\r\nif (card->xskb[channel])\r\ncard->xskb[channel] = NULL;\r\ncard->xmit_lock[channel] = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ndev_kfree_skb(skb);\r\nif (card->xlen[channel]) {\r\ncmd.command = ISDN_STAT_BSENT;\r\ncmd.driver = card->myid;\r\ncmd.arg = channel;\r\ncmd.parm.length = card->xlen[channel];\r\ncard->interface.statcallb(&cmd);\r\n}\r\n} else {\r\ncard->xskb[channel] = skb;\r\ncard->xmit_lock[channel] = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nif (!icn_trymaplock_channel(card, mch))\r\nbreak;\r\n}\r\nicn_maprelease_channel(card, mch & 2);\r\n}\r\n}\r\nstatic void\r\nicn_pollbchan(unsigned long data)\r\n{\r\nicn_card *card = (icn_card *) data;\r\nunsigned long flags;\r\nif (card->flags & ICN_FLAGS_B1ACTIVE) {\r\nicn_pollbchan_receive(0, card);\r\nicn_pollbchan_send(0, card);\r\n}\r\nif (card->flags & ICN_FLAGS_B2ACTIVE) {\r\nicn_pollbchan_receive(1, card);\r\nicn_pollbchan_send(1, card);\r\n}\r\nif (card->flags & (ICN_FLAGS_B1ACTIVE | ICN_FLAGS_B2ACTIVE)) {\r\nspin_lock_irqsave(&card->lock, flags);\r\nmod_timer(&card->rb_timer, jiffies + ICN_TIMER_BCREAD);\r\ncard->flags |= ICN_FLAGS_RBTIMER;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n} else\r\ncard->flags &= ~ICN_FLAGS_RBTIMER;\r\n}\r\nstatic void\r\nicn_parse_status(u_char *status, int channel, icn_card *card)\r\n{\r\nicn_stat *s = icn_stat_table;\r\nint action = -1;\r\nunsigned long flags;\r\nisdn_ctrl cmd;\r\nwhile (s->statstr) {\r\nif (!strncmp(status, s->statstr, strlen(s->statstr))) {\r\ncmd.command = s->command;\r\naction = s->action;\r\nbreak;\r\n}\r\ns++;\r\n}\r\nif (action == -1)\r\nreturn;\r\ncmd.driver = card->myid;\r\ncmd.arg = channel;\r\nswitch (action) {\r\ncase 11:\r\nspin_lock_irqsave(&card->lock, flags);\r\nicn_free_queue(card, channel);\r\ncard->rcvidx[channel] = 0;\r\nif (card->flags &\r\n((channel) ? ICN_FLAGS_B2ACTIVE : ICN_FLAGS_B1ACTIVE)) {\r\nisdn_ctrl ncmd;\r\ncard->flags &= ~((channel) ?\r\nICN_FLAGS_B2ACTIVE : ICN_FLAGS_B1ACTIVE);\r\nmemset(&ncmd, 0, sizeof(ncmd));\r\nncmd.driver = card->myid;\r\nncmd.arg = channel;\r\nncmd.command = ISDN_STAT_BHUP;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->interface.statcallb(&cmd);\r\n} else\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase 1:\r\nspin_lock_irqsave(&card->lock, flags);\r\nicn_free_queue(card, channel);\r\ncard->flags |= (channel) ?\r\nICN_FLAGS_B2ACTIVE : ICN_FLAGS_B1ACTIVE;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase 2:\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->flags &= ~((channel) ?\r\nICN_FLAGS_B2ACTIVE : ICN_FLAGS_B1ACTIVE);\r\nicn_free_queue(card, channel);\r\ncard->rcvidx[channel] = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase 3:\r\n{\r\nchar *t = status + 6;\r\nchar *s = strchr(t, ',');\r\n*s++ = '\0';\r\nstrlcpy(cmd.parm.setup.phone, t,\r\nsizeof(cmd.parm.setup.phone));\r\ns = strchr(t = s, ',');\r\n*s++ = '\0';\r\nif (!strlen(t))\r\ncmd.parm.setup.si1 = 0;\r\nelse\r\ncmd.parm.setup.si1 =\r\nsimple_strtoul(t, NULL, 10);\r\ns = strchr(t = s, ',');\r\n*s++ = '\0';\r\nif (!strlen(t))\r\ncmd.parm.setup.si2 = 0;\r\nelse\r\ncmd.parm.setup.si2 =\r\nsimple_strtoul(t, NULL, 10);\r\nstrlcpy(cmd.parm.setup.eazmsn, s,\r\nsizeof(cmd.parm.setup.eazmsn));\r\n}\r\ncmd.parm.setup.plan = 0;\r\ncmd.parm.setup.screen = 0;\r\nbreak;\r\ncase 4:\r\nsprintf(cmd.parm.setup.phone, "LEASED%d", card->myid);\r\nsprintf(cmd.parm.setup.eazmsn, "%d", channel + 1);\r\ncmd.parm.setup.si1 = 7;\r\ncmd.parm.setup.si2 = 0;\r\ncmd.parm.setup.plan = 0;\r\ncmd.parm.setup.screen = 0;\r\nbreak;\r\ncase 5:\r\nstrlcpy(cmd.parm.num, status + 3, sizeof(cmd.parm.num));\r\nbreak;\r\ncase 6:\r\nsnprintf(cmd.parm.num, sizeof(cmd.parm.num), "%d",\r\n(int) simple_strtoul(status + 7, NULL, 16));\r\nbreak;\r\ncase 7:\r\nstatus += 3;\r\nif (strlen(status) == 4)\r\nsnprintf(cmd.parm.num, sizeof(cmd.parm.num), "%s%c%c",\r\nstatus + 2, *status, *(status + 1));\r\nelse\r\nstrlcpy(cmd.parm.num, status + 1, sizeof(cmd.parm.num));\r\nbreak;\r\ncase 8:\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->flags &= ~ICN_FLAGS_B1ACTIVE;\r\nicn_free_queue(card, 0);\r\ncard->rcvidx[0] = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncmd.arg = 0;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncmd.command = ISDN_STAT_DHUP;\r\ncmd.arg = 0;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncmd.command = ISDN_STAT_BHUP;\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->flags &= ~ICN_FLAGS_B2ACTIVE;\r\nicn_free_queue(card, 1);\r\ncard->rcvidx[1] = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncmd.arg = 1;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncmd.command = ISDN_STAT_DHUP;\r\ncmd.arg = 1;\r\ncmd.driver = card->myid;\r\nbreak;\r\n}\r\ncard->interface.statcallb(&cmd);\r\nreturn;\r\n}\r\nstatic void\r\nicn_putmsg(icn_card *card, unsigned char c)\r\n{\r\nulong flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\n*card->msg_buf_write++ = (c == 0xff) ? '\n' : c;\r\nif (card->msg_buf_write == card->msg_buf_read) {\r\nif (++card->msg_buf_read > card->msg_buf_end)\r\ncard->msg_buf_read = card->msg_buf;\r\n}\r\nif (card->msg_buf_write > card->msg_buf_end)\r\ncard->msg_buf_write = card->msg_buf;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic void\r\nicn_polldchan(unsigned long data)\r\n{\r\nicn_card *card = (icn_card *) data;\r\nint mch = card->secondhalf ? 2 : 0;\r\nint avail = 0;\r\nint left;\r\nu_char c;\r\nint ch;\r\nunsigned long flags;\r\nint i;\r\nu_char *p;\r\nisdn_ctrl cmd;\r\nif (icn_trymaplock_channel(card, mch)) {\r\navail = msg_avail;\r\nfor (left = avail, i = readb(&msg_o); left > 0; i++, left--) {\r\nc = readb(&dev.shmem->comm_buffers.iopc_buf[i & 0xff]);\r\nicn_putmsg(card, c);\r\nif (c == 0xff) {\r\ncard->imsg[card->iptr] = 0;\r\ncard->iptr = 0;\r\nif (card->imsg[0] == '0' && card->imsg[1] >= '0' &&\r\ncard->imsg[1] <= '2' && card->imsg[2] == ';') {\r\nch = (card->imsg[1] - '0') - 1;\r\np = &card->imsg[3];\r\nicn_parse_status(p, ch, card);\r\n} else {\r\np = card->imsg;\r\nif (!strncmp(p, "DRV1.", 5)) {\r\nu_char vstr[10];\r\nu_char *q = vstr;\r\nprintk(KERN_INFO "icn: (%s) %s\n", CID, p);\r\nif (!strncmp(p + 7, "TC", 2)) {\r\ncard->ptype = ISDN_PTYPE_1TR6;\r\ncard->interface.features |= ISDN_FEATURE_P_1TR6;\r\nprintk(KERN_INFO\r\n"icn: (%s) 1TR6-Protocol loaded and running\n", CID);\r\n}\r\nif (!strncmp(p + 7, "EC", 2)) {\r\ncard->ptype = ISDN_PTYPE_EURO;\r\ncard->interface.features |= ISDN_FEATURE_P_EURO;\r\nprintk(KERN_INFO\r\n"icn: (%s) Euro-Protocol loaded and running\n", CID);\r\n}\r\np = strstr(card->imsg, "BRV") + 3;\r\nwhile (*p) {\r\nif (*p >= '0' && *p <= '9')\r\n*q++ = *p;\r\np++;\r\n}\r\n*q = '\0';\r\nstrcat(vstr, "000");\r\nvstr[3] = '\0';\r\ncard->fw_rev = (int) simple_strtoul(vstr, NULL, 10);\r\ncontinue;\r\n}\r\n}\r\n} else {\r\ncard->imsg[card->iptr] = c;\r\nif (card->iptr < 59)\r\ncard->iptr++;\r\n}\r\n}\r\nwriteb((readb(&msg_o) + avail) & 0xff, &msg_o);\r\nicn_release_channel();\r\n}\r\nif (avail) {\r\ncmd.command = ISDN_STAT_STAVAIL;\r\ncmd.driver = card->myid;\r\ncmd.arg = avail;\r\ncard->interface.statcallb(&cmd);\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->flags & (ICN_FLAGS_B1ACTIVE | ICN_FLAGS_B2ACTIVE))\r\nif (!(card->flags & ICN_FLAGS_RBTIMER)) {\r\ncard->flags |= ICN_FLAGS_RBTIMER;\r\ndel_timer(&card->rb_timer);\r\ncard->rb_timer.function = icn_pollbchan;\r\ncard->rb_timer.data = (unsigned long) card;\r\ncard->rb_timer.expires = jiffies + ICN_TIMER_BCREAD;\r\nadd_timer(&card->rb_timer);\r\n}\r\nmod_timer(&card->st_timer, jiffies + ICN_TIMER_DCREAD);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic int\r\nicn_sendbuf(int channel, int ack, struct sk_buff *skb, icn_card *card)\r\n{\r\nint len = skb->len;\r\nunsigned long flags;\r\nstruct sk_buff *nskb;\r\nif (len > 4000) {\r\nprintk(KERN_WARNING\r\n"icn: Send packet too large\n");\r\nreturn -EINVAL;\r\n}\r\nif (len) {\r\nif (!(card->flags & (channel) ? ICN_FLAGS_B2ACTIVE : ICN_FLAGS_B1ACTIVE))\r\nreturn 0;\r\nif (card->sndcount[channel] > ICN_MAX_SQUEUE)\r\nreturn 0;\r\n#warning TODO test headroom or use skb->nb to flag ACK\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (nskb) {\r\n*(skb_push(nskb, 1)) = ack ? 1 : 0;\r\nskb_queue_tail(&card->spqueue[channel], nskb);\r\ndev_kfree_skb(skb);\r\n} else\r\nlen = 0;\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->sndcount[channel] += len;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nreturn len;\r\n}\r\nstatic int\r\nicn_check_loader(int cardnumber)\r\n{\r\nint timer = 0;\r\nwhile (1) {\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Loader %d ?\n", cardnumber);\r\n#endif\r\nif (readb(&dev.shmem->data_control.scns) ||\r\nreadb(&dev.shmem->data_control.scnr)) {\r\nif (timer++ > 5) {\r\nprintk(KERN_WARNING\r\n"icn: Boot-Loader %d timed out.\n",\r\ncardnumber);\r\nicn_release_channel();\r\nreturn -EIO;\r\n}\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Loader %d TO?\n", cardnumber);\r\n#endif\r\nmsleep_interruptible(ICN_BOOT_TIMEOUT1);\r\n} else {\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Loader %d OK\n", cardnumber);\r\n#endif\r\nicn_release_channel();\r\nreturn 0;\r\n}\r\n}\r\n}\r\nstatic int\r\nicn_loadboot(u_char __user *buffer, icn_card *card)\r\n{\r\nint ret;\r\nu_char *codebuf;\r\nunsigned long flags;\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "icn_loadboot called, buffaddr=%08lx\n", (ulong) buffer);\r\n#endif\r\nif (!(codebuf = kmalloc(ICN_CODE_STAGE1, GFP_KERNEL))) {\r\nprintk(KERN_WARNING "icn: Could not allocate code buffer\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(codebuf, buffer, ICN_CODE_STAGE1)) {\r\nret = -EFAULT;\r\ngoto out_kfree;\r\n}\r\nif (!card->rvalid) {\r\nif (!request_region(card->port, ICN_PORTLEN, card->regname)) {\r\nprintk(KERN_WARNING\r\n"icn: (%s) ports 0x%03x-0x%03x in use.\n",\r\nCID,\r\ncard->port,\r\ncard->port + ICN_PORTLEN);\r\nret = -EBUSY;\r\ngoto out_kfree;\r\n}\r\ncard->rvalid = 1;\r\nif (card->doubleS0)\r\ncard->other->rvalid = 1;\r\n}\r\nif (!dev.mvalid) {\r\nif (!request_mem_region(dev.memaddr, 0x4000, "icn-isdn (all cards)")) {\r\nprintk(KERN_WARNING\r\n"icn: memory at 0x%08lx in use.\n", dev.memaddr);\r\nret = -EBUSY;\r\ngoto out_kfree;\r\n}\r\ndev.shmem = ioremap(dev.memaddr, 0x4000);\r\ndev.mvalid = 1;\r\n}\r\nOUTB_P(0, ICN_RUN);\r\nOUTB_P(0, ICN_MAPRAM);\r\nicn_shiftout(ICN_CFG, 0x0f, 3, 4);\r\nicn_shiftout(ICN_CFG, dev.memaddr, 23, 10);\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "shmem=%08lx\n", dev.memaddr);\r\n#endif\r\nSLEEP(1);\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Map Bank 0\n");\r\n#endif\r\nspin_lock_irqsave(&dev.devlock, flags);\r\nicn_map_channel(card, 0);\r\nicn_lock_channel(card, 0);\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\nSLEEP(1);\r\nmemcpy_toio(dev.shmem, codebuf, ICN_CODE_STAGE1);\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Bootloader transferred\n");\r\n#endif\r\nif (card->doubleS0) {\r\nSLEEP(1);\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Map Bank 8\n");\r\n#endif\r\nspin_lock_irqsave(&dev.devlock, flags);\r\n__icn_release_channel();\r\nicn_map_channel(card, 2);\r\nicn_lock_channel(card, 2);\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\nSLEEP(1);\r\nmemcpy_toio(dev.shmem, codebuf, ICN_CODE_STAGE1);\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Bootloader transferred\n");\r\n#endif\r\n}\r\nSLEEP(1);\r\nOUTB_P(0xff, ICN_RUN);\r\nif ((ret = icn_check_loader(card->doubleS0 ? 2 : 1))) {\r\ngoto out_kfree;\r\n}\r\nif (!card->doubleS0) {\r\nret = 0;\r\ngoto out_kfree;\r\n}\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Map Bank 0\n");\r\n#endif\r\nspin_lock_irqsave(&dev.devlock, flags);\r\nicn_map_channel(card, 0);\r\nicn_lock_channel(card, 0);\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\nSLEEP(1);\r\nret = (icn_check_loader(1));\r\nout_kfree:\r\nkfree(codebuf);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nicn_loadproto(u_char __user *buffer, icn_card *card)\r\n{\r\nregister u_char __user *p = buffer;\r\nu_char codebuf[256];\r\nuint left = ICN_CODE_STAGE2;\r\nuint cnt;\r\nint timer;\r\nunsigned long flags;\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "icn_loadproto called\n");\r\n#endif\r\nif (!access_ok(VERIFY_READ, buffer, ICN_CODE_STAGE2))\r\nreturn -EFAULT;\r\ntimer = 0;\r\nspin_lock_irqsave(&dev.devlock, flags);\r\nif (card->secondhalf) {\r\nicn_map_channel(card, 2);\r\nicn_lock_channel(card, 2);\r\n} else {\r\nicn_map_channel(card, 0);\r\nicn_lock_channel(card, 0);\r\n}\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\nwhile (left) {\r\nif (sbfree) {\r\ncnt = left;\r\nif (cnt > 256)\r\ncnt = 256;\r\nif (copy_from_user(codebuf, p, cnt)) {\r\nicn_maprelease_channel(card, 0);\r\nreturn -EFAULT;\r\n}\r\nmemcpy_toio(&sbuf_l, codebuf, cnt);\r\nsbnext;\r\np += cnt;\r\nleft -= cnt;\r\ntimer = 0;\r\n} else {\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "boot 2 !sbfree\n");\r\n#endif\r\nif (timer++ > 5) {\r\nicn_maprelease_channel(card, 0);\r\nreturn -EIO;\r\n}\r\nschedule_timeout_interruptible(10);\r\n}\r\n}\r\nwriteb(0x20, &sbuf_n);\r\ntimer = 0;\r\nwhile (1) {\r\nif (readb(&cmd_o) || readb(&cmd_i)) {\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Proto?\n");\r\n#endif\r\nif (timer++ > 5) {\r\nprintk(KERN_WARNING\r\n"icn: (%s) Protocol timed out.\n",\r\nCID);\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Proto TO!\n");\r\n#endif\r\nicn_maprelease_channel(card, 0);\r\nreturn -EIO;\r\n}\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Proto TO?\n");\r\n#endif\r\nmsleep_interruptible(ICN_BOOT_TIMEOUT1);\r\n} else {\r\nif ((card->secondhalf) || (!card->doubleS0)) {\r\n#ifdef BOOT_DEBUG\r\nprintk(KERN_DEBUG "Proto loaded, install poll-timer %d\n",\r\ncard->secondhalf);\r\n#endif\r\nspin_lock_irqsave(&card->lock, flags);\r\ninit_timer(&card->st_timer);\r\ncard->st_timer.expires = jiffies + ICN_TIMER_DCREAD;\r\ncard->st_timer.function = icn_polldchan;\r\ncard->st_timer.data = (unsigned long) card;\r\nadd_timer(&card->st_timer);\r\ncard->flags |= ICN_FLAGS_RUNNING;\r\nif (card->doubleS0) {\r\ninit_timer(&card->other->st_timer);\r\ncard->other->st_timer.expires = jiffies + ICN_TIMER_DCREAD;\r\ncard->other->st_timer.function = icn_polldchan;\r\ncard->other->st_timer.data = (unsigned long) card->other;\r\nadd_timer(&card->other->st_timer);\r\ncard->other->flags |= ICN_FLAGS_RUNNING;\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nicn_maprelease_channel(card, 0);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nstatic int\r\nicn_readstatus(u_char __user *buf, int len, icn_card *card)\r\n{\r\nint count;\r\nu_char __user *p;\r\nfor (p = buf, count = 0; count < len; p++, count++) {\r\nif (card->msg_buf_read == card->msg_buf_write)\r\nreturn count;\r\nif (put_user(*card->msg_buf_read++, p))\r\nreturn -EFAULT;\r\nif (card->msg_buf_read > card->msg_buf_end)\r\ncard->msg_buf_read = card->msg_buf;\r\n}\r\nreturn count;\r\n}\r\nstatic int\r\nicn_writecmd(const u_char *buf, int len, int user, icn_card *card)\r\n{\r\nint mch = card->secondhalf ? 2 : 0;\r\nint pp;\r\nint i;\r\nint count;\r\nint xcount;\r\nint ocount;\r\nint loop;\r\nunsigned long flags;\r\nint lastmap_channel;\r\nstruct icn_card *lastmap_card;\r\nu_char *p;\r\nisdn_ctrl cmd;\r\nu_char msg[0x100];\r\nocount = 1;\r\nxcount = loop = 0;\r\nwhile (len) {\r\ncount = cmd_free;\r\nif (count > len)\r\ncount = len;\r\nif (user) {\r\nif (copy_from_user(msg, buf, count))\r\nreturn -EFAULT;\r\n} else\r\nmemcpy(msg, buf, count);\r\nspin_lock_irqsave(&dev.devlock, flags);\r\nlastmap_card = dev.mcard;\r\nlastmap_channel = dev.channel;\r\nicn_map_channel(card, mch);\r\nicn_putmsg(card, '>');\r\nfor (p = msg, pp = readb(&cmd_i), i = count; i > 0; i--, p++, pp\r\n++) {\r\nwriteb((*p == '\n') ? 0xff : *p,\r\n&dev.shmem->comm_buffers.pcio_buf[pp & 0xff]);\r\nlen--;\r\nxcount++;\r\nicn_putmsg(card, *p);\r\nif ((*p == '\n') && (i > 1)) {\r\nicn_putmsg(card, '>');\r\nocount++;\r\n}\r\nocount++;\r\n}\r\nwriteb((readb(&cmd_i) + count) & 0xff, &cmd_i);\r\nif (lastmap_card)\r\nicn_map_channel(lastmap_card, lastmap_channel);\r\nspin_unlock_irqrestore(&dev.devlock, flags);\r\nif (len) {\r\nmdelay(1);\r\nif (loop++ > 20)\r\nbreak;\r\n} else\r\nbreak;\r\n}\r\nif (len && (!user))\r\nprintk(KERN_WARNING "icn: writemsg incomplete!\n");\r\ncmd.command = ISDN_STAT_STAVAIL;\r\ncmd.driver = card->myid;\r\ncmd.arg = ocount;\r\ncard->interface.statcallb(&cmd);\r\nreturn xcount;\r\n}\r\nstatic void\r\nicn_stopcard(icn_card *card)\r\n{\r\nunsigned long flags;\r\nisdn_ctrl cmd;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->flags & ICN_FLAGS_RUNNING) {\r\ncard->flags &= ~ICN_FLAGS_RUNNING;\r\ndel_timer(&card->st_timer);\r\ndel_timer(&card->rb_timer);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncmd.command = ISDN_STAT_STOP;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\nif (card->doubleS0)\r\nicn_stopcard(card->other);\r\n} else\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic void\r\nicn_stopallcards(void)\r\n{\r\nicn_card *p = cards;\r\nwhile (p) {\r\nicn_stopcard(p);\r\np = p->next;\r\n}\r\n}\r\nstatic void\r\nicn_disable_cards(void)\r\n{\r\nicn_card *card = cards;\r\nwhile (card) {\r\nif (!request_region(card->port, ICN_PORTLEN, "icn-isdn")) {\r\nprintk(KERN_WARNING\r\n"icn: (%s) ports 0x%03x-0x%03x in use.\n",\r\nCID,\r\ncard->port,\r\ncard->port + ICN_PORTLEN);\r\n} else {\r\nOUTB_P(0, ICN_RUN);\r\nOUTB_P(0, ICN_MAPRAM);\r\nrelease_region(card->port, ICN_PORTLEN);\r\n}\r\ncard = card->next;\r\n}\r\n}\r\nstatic int\r\nicn_command(isdn_ctrl *c, icn_card *card)\r\n{\r\nulong a;\r\nulong flags;\r\nint i;\r\nchar cbuf[80];\r\nisdn_ctrl cmd;\r\nicn_cdef cdef;\r\nchar __user *arg;\r\nswitch (c->command) {\r\ncase ISDN_CMD_IOCTL:\r\nmemcpy(&a, c->parm.num, sizeof(ulong));\r\narg = (char __user *)a;\r\nswitch (c->arg) {\r\ncase ICN_IOCTL_SETMMIO:\r\nif (dev.memaddr != (a & 0x0ffc000)) {\r\nif (!request_mem_region(a & 0x0ffc000, 0x4000, "icn-isdn (all cards)")) {\r\nprintk(KERN_WARNING\r\n"icn: memory at 0x%08lx in use.\n",\r\na & 0x0ffc000);\r\nreturn -EINVAL;\r\n}\r\nrelease_mem_region(a & 0x0ffc000, 0x4000);\r\nicn_stopallcards();\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (dev.mvalid) {\r\niounmap(dev.shmem);\r\nrelease_mem_region(dev.memaddr, 0x4000);\r\n}\r\ndev.mvalid = 0;\r\ndev.memaddr = a & 0x0ffc000;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_INFO\r\n"icn: (%s) mmio set to 0x%08lx\n",\r\nCID,\r\ndev.memaddr);\r\n}\r\nbreak;\r\ncase ICN_IOCTL_GETMMIO:\r\nreturn (long) dev.memaddr;\r\ncase ICN_IOCTL_SETPORT:\r\nif (a == 0x300 || a == 0x310 || a == 0x320 || a == 0x330\r\n|| a == 0x340 || a == 0x350 || a == 0x360 ||\r\na == 0x308 || a == 0x318 || a == 0x328 || a == 0x338\r\n|| a == 0x348 || a == 0x358 || a == 0x368) {\r\nif (card->port != (unsigned short) a) {\r\nif (!request_region((unsigned short) a, ICN_PORTLEN, "icn-isdn")) {\r\nprintk(KERN_WARNING\r\n"icn: (%s) ports 0x%03x-0x%03x in use.\n",\r\nCID, (int) a, (int) a + ICN_PORTLEN);\r\nreturn -EINVAL;\r\n}\r\nrelease_region((unsigned short) a, ICN_PORTLEN);\r\nicn_stopcard(card);\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->rvalid)\r\nrelease_region(card->port, ICN_PORTLEN);\r\ncard->port = (unsigned short) a;\r\ncard->rvalid = 0;\r\nif (card->doubleS0) {\r\ncard->other->port = (unsigned short) a;\r\ncard->other->rvalid = 0;\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_INFO\r\n"icn: (%s) port set to 0x%03x\n",\r\nCID, card->port);\r\n}\r\n} else\r\nreturn -EINVAL;\r\nbreak;\r\ncase ICN_IOCTL_GETPORT:\r\nreturn (int) card->port;\r\ncase ICN_IOCTL_GETDOUBLE:\r\nreturn (int) card->doubleS0;\r\ncase ICN_IOCTL_DEBUGVAR:\r\nif (copy_to_user(arg,\r\n&card,\r\nsizeof(ulong)))\r\nreturn -EFAULT;\r\na += sizeof(ulong);\r\n{\r\nulong l = (ulong)&dev;\r\nif (copy_to_user(arg,\r\n&l,\r\nsizeof(ulong)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\ncase ICN_IOCTL_LOADBOOT:\r\nif (dev.firstload) {\r\nicn_disable_cards();\r\ndev.firstload = 0;\r\n}\r\nicn_stopcard(card);\r\nreturn (icn_loadboot(arg, card));\r\ncase ICN_IOCTL_LOADPROTO:\r\nicn_stopcard(card);\r\nif ((i = (icn_loadproto(arg, card))))\r\nreturn i;\r\nif (card->doubleS0)\r\ni = icn_loadproto(arg + ICN_CODE_STAGE2, card->other);\r\nreturn i;\r\nbreak;\r\ncase ICN_IOCTL_ADDCARD:\r\nif (!dev.firstload)\r\nreturn -EBUSY;\r\nif (copy_from_user(&cdef,\r\narg,\r\nsizeof(cdef)))\r\nreturn -EFAULT;\r\nreturn (icn_addcard(cdef.port, cdef.id1, cdef.id2));\r\nbreak;\r\ncase ICN_IOCTL_LEASEDCFG:\r\nif (a) {\r\nif (!card->leased) {\r\ncard->leased = 1;\r\nwhile (card->ptype == ISDN_PTYPE_UNKNOWN) {\r\nmsleep_interruptible(ICN_BOOT_TIMEOUT1);\r\n}\r\nmsleep_interruptible(ICN_BOOT_TIMEOUT1);\r\nsprintf(cbuf, "00;FV2ON\n01;EAZ%c\n02;EAZ%c\n",\r\n(a & 1) ? '1' : 'C', (a & 2) ? '2' : 'C');\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\nprintk(KERN_INFO\r\n"icn: (%s) Leased-line mode enabled\n",\r\nCID);\r\ncmd.command = ISDN_STAT_RUN;\r\ncmd.driver = card->myid;\r\ncmd.arg = 0;\r\ncard->interface.statcallb(&cmd);\r\n}\r\n} else {\r\nif (card->leased) {\r\ncard->leased = 0;\r\nsprintf(cbuf, "00;FV2OFF\n");\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\nprintk(KERN_INFO\r\n"icn: (%s) Leased-line mode disabled\n",\r\nCID);\r\ncmd.command = ISDN_STAT_RUN;\r\ncmd.driver = card->myid;\r\ncmd.arg = 0;\r\ncard->interface.statcallb(&cmd);\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ISDN_CMD_DIAL:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (card->leased)\r\nbreak;\r\nif ((c->arg & 255) < ICN_BCH) {\r\nchar *p;\r\nchar dcode[4];\r\na = c->arg;\r\np = c->parm.setup.phone;\r\nif (*p == 's' || *p == 'S') {\r\np++;\r\nstrcpy(dcode, "SCA");\r\n} else\r\nstrcpy(dcode, "CAL");\r\nsnprintf(cbuf, sizeof(cbuf),\r\n"%02d;D%s_R%s,%02d,%02d,%s\n", (int) (a + 1),\r\ndcode, p, c->parm.setup.si1,\r\nc->parm.setup.si2, c->parm.setup.eazmsn);\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_ACCEPTD:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (c->arg < ICN_BCH) {\r\na = c->arg + 1;\r\nif (card->fw_rev >= 300) {\r\nswitch (card->l2_proto[a - 1]) {\r\ncase ISDN_PROTO_L2_X75I:\r\nsprintf(cbuf, "%02d;BX75\n", (int) a);\r\nbreak;\r\ncase ISDN_PROTO_L2_HDLC:\r\nsprintf(cbuf, "%02d;BTRA\n", (int) a);\r\nbreak;\r\n}\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nsprintf(cbuf, "%02d;DCON_R\n", (int) a);\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_ACCEPTB:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (c->arg < ICN_BCH) {\r\na = c->arg + 1;\r\nif (card->fw_rev >= 300)\r\nswitch (card->l2_proto[a - 1]) {\r\ncase ISDN_PROTO_L2_X75I:\r\nsprintf(cbuf, "%02d;BCON_R,BX75\n", (int) a);\r\nbreak;\r\ncase ISDN_PROTO_L2_HDLC:\r\nsprintf(cbuf, "%02d;BCON_R,BTRA\n", (int) a);\r\nbreak;\r\n} else\r\nsprintf(cbuf, "%02d;BCON_R\n", (int) a);\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_HANGUP:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (c->arg < ICN_BCH) {\r\na = c->arg + 1;\r\nsprintf(cbuf, "%02d;BDIS_R\n%02d;DDIS_R\n", (int) a, (int) a);\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETEAZ:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (card->leased)\r\nbreak;\r\nif (c->arg < ICN_BCH) {\r\na = c->arg + 1;\r\nif (card->ptype == ISDN_PTYPE_EURO) {\r\nsprintf(cbuf, "%02d;MS%s%s\n", (int) a,\r\nc->parm.num[0] ? "N" : "ALL", c->parm.num);\r\n} else\r\nsprintf(cbuf, "%02d;EAZ%s\n", (int) a,\r\nc->parm.num[0] ? (char *)(c->parm.num) : "0123456789");\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_CLREAZ:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (card->leased)\r\nbreak;\r\nif (c->arg < ICN_BCH) {\r\na = c->arg + 1;\r\nif (card->ptype == ISDN_PTYPE_EURO)\r\nsprintf(cbuf, "%02d;MSNC\n", (int) a);\r\nelse\r\nsprintf(cbuf, "%02d;EAZC\n", (int) a);\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETL2:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif ((c->arg & 255) < ICN_BCH) {\r\na = c->arg;\r\nswitch (a >> 8) {\r\ncase ISDN_PROTO_L2_X75I:\r\nsprintf(cbuf, "%02d;BX75\n", (int) (a & 255) + 1);\r\nbreak;\r\ncase ISDN_PROTO_L2_HDLC:\r\nsprintf(cbuf, "%02d;BTRA\n", (int) (a & 255) + 1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni = icn_writecmd(cbuf, strlen(cbuf), 0, card);\r\ncard->l2_proto[a & 255] = (a >> 8);\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETL3:\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline icn_card *\r\nicn_findcard(int driverid)\r\n{\r\nicn_card *p = cards;\r\nwhile (p) {\r\nif (p->myid == driverid)\r\nreturn p;\r\np = p->next;\r\n}\r\nreturn (icn_card *) 0;\r\n}\r\nstatic int\r\nif_command(isdn_ctrl *c)\r\n{\r\nicn_card *card = icn_findcard(c->driver);\r\nif (card)\r\nreturn (icn_command(c, card));\r\nprintk(KERN_ERR\r\n"icn: if_command %d called with invalid driverId %d!\n",\r\nc->command, c->driver);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nif_writecmd(const u_char __user *buf, int len, int id, int channel)\r\n{\r\nicn_card *card = icn_findcard(id);\r\nif (card) {\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn (icn_writecmd(buf, len, 1, card));\r\n}\r\nprintk(KERN_ERR\r\n"icn: if_writecmd called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nif_readstatus(u_char __user *buf, int len, int id, int channel)\r\n{\r\nicn_card *card = icn_findcard(id);\r\nif (card) {\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn (icn_readstatus(buf, len, card));\r\n}\r\nprintk(KERN_ERR\r\n"icn: if_readstatus called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nif_sendbuf(int id, int channel, int ack, struct sk_buff *skb)\r\n{\r\nicn_card *card = icn_findcard(id);\r\nif (card) {\r\nif (!(card->flags & ICN_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn (icn_sendbuf(channel, ack, skb, card));\r\n}\r\nprintk(KERN_ERR\r\n"icn: if_sendbuf called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic icn_card *\r\nicn_initcard(int port, char *id)\r\n{\r\nicn_card *card;\r\nint i;\r\nif (!(card = kzalloc(sizeof(icn_card), GFP_KERNEL))) {\r\nprintk(KERN_WARNING\r\n"icn: (%s) Could not allocate card-struct.\n", id);\r\nreturn (icn_card *) 0;\r\n}\r\nspin_lock_init(&card->lock);\r\ncard->port = port;\r\ncard->interface.owner = THIS_MODULE;\r\ncard->interface.hl_hdrlen = 1;\r\ncard->interface.channels = ICN_BCH;\r\ncard->interface.maxbufsize = 4000;\r\ncard->interface.command = if_command;\r\ncard->interface.writebuf_skb = if_sendbuf;\r\ncard->interface.writecmd = if_writecmd;\r\ncard->interface.readstat = if_readstatus;\r\ncard->interface.features = ISDN_FEATURE_L2_X75I |\r\nISDN_FEATURE_L2_HDLC |\r\nISDN_FEATURE_L3_TRANS |\r\nISDN_FEATURE_P_UNKNOWN;\r\ncard->ptype = ISDN_PTYPE_UNKNOWN;\r\nstrlcpy(card->interface.id, id, sizeof(card->interface.id));\r\ncard->msg_buf_write = card->msg_buf;\r\ncard->msg_buf_read = card->msg_buf;\r\ncard->msg_buf_end = &card->msg_buf[sizeof(card->msg_buf) - 1];\r\nfor (i = 0; i < ICN_BCH; i++) {\r\ncard->l2_proto[i] = ISDN_PROTO_L2_X75I;\r\nskb_queue_head_init(&card->spqueue[i]);\r\n}\r\ncard->next = cards;\r\ncards = card;\r\nif (!register_isdn(&card->interface)) {\r\ncards = cards->next;\r\nprintk(KERN_WARNING\r\n"icn: Unable to register %s\n", id);\r\nkfree(card);\r\nreturn (icn_card *) 0;\r\n}\r\ncard->myid = card->interface.channels;\r\nsprintf(card->regname, "icn-isdn (%s)", card->interface.id);\r\nreturn card;\r\n}\r\nstatic int\r\nicn_addcard(int port, char *id1, char *id2)\r\n{\r\nicn_card *card;\r\nicn_card *card2;\r\nif (!(card = icn_initcard(port, id1))) {\r\nreturn -EIO;\r\n}\r\nif (!strlen(id2)) {\r\nprintk(KERN_INFO\r\n"icn: (%s) ICN-2B, port 0x%x added\n",\r\ncard->interface.id, port);\r\nreturn 0;\r\n}\r\nif (!(card2 = icn_initcard(port, id2))) {\r\nprintk(KERN_INFO\r\n"icn: (%s) half ICN-4B, port 0x%x added\n", id2, port);\r\nreturn 0;\r\n}\r\ncard->doubleS0 = 1;\r\ncard->secondhalf = 0;\r\ncard->other = card2;\r\ncard2->doubleS0 = 1;\r\ncard2->secondhalf = 1;\r\ncard2->other = card;\r\nprintk(KERN_INFO\r\n"icn: (%s and %s) ICN-4B, port 0x%x added\n",\r\ncard->interface.id, card2->interface.id, port);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nicn_setup(char *line)\r\n{\r\nchar *p, *str;\r\nint ints[3];\r\nstatic char sid[20];\r\nstatic char sid2[20];\r\nstr = get_options(line, 2, ints);\r\nif (ints[0])\r\nportbase = ints[1];\r\nif (ints[0] > 1)\r\nmembase = (unsigned long)ints[2];\r\nif (str && *str) {\r\nstrlcpy(sid, str, sizeof(sid));\r\nicn_id = sid;\r\nif ((p = strchr(sid, ','))) {\r\n*p++ = 0;\r\nstrcpy(sid2, p);\r\nicn_id2 = sid2;\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic int __init icn_init(void)\r\n{\r\nchar *p;\r\nchar rev[21];\r\nmemset(&dev, 0, sizeof(icn_dev));\r\ndev.memaddr = (membase & 0x0ffc000);\r\ndev.channel = -1;\r\ndev.mcard = NULL;\r\ndev.firstload = 1;\r\nspin_lock_init(&dev.devlock);\r\nif ((p = strchr(revision, ':'))) {\r\nstrncpy(rev, p + 1, 20);\r\nrev[20] = '\0';\r\np = strchr(rev, '$');\r\nif (p)\r\n*p = 0;\r\n} else\r\nstrcpy(rev, " ??? ");\r\nprintk(KERN_NOTICE "ICN-ISDN-driver Rev%smem=0x%08lx\n", rev,\r\ndev.memaddr);\r\nreturn (icn_addcard(portbase, icn_id, icn_id2));\r\n}\r\nstatic void __exit icn_exit(void)\r\n{\r\nisdn_ctrl cmd;\r\nicn_card *card = cards;\r\nicn_card *last, *tmpcard;\r\nint i;\r\nunsigned long flags;\r\nicn_stopallcards();\r\nwhile (card) {\r\ncmd.command = ISDN_STAT_UNLOAD;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->rvalid) {\r\nOUTB_P(0, ICN_RUN);\r\nOUTB_P(0, ICN_MAPRAM);\r\nif (card->secondhalf || (!card->doubleS0)) {\r\nrelease_region(card->port, ICN_PORTLEN);\r\ncard->rvalid = 0;\r\n}\r\nfor (i = 0; i < ICN_BCH; i++)\r\nicn_free_queue(card, i);\r\n}\r\ntmpcard = card->next;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard = tmpcard;\r\n}\r\ncard = cards;\r\ncards = NULL;\r\nwhile (card) {\r\nlast = card;\r\ncard = card->next;\r\nkfree(last);\r\n}\r\nif (dev.mvalid) {\r\niounmap(dev.shmem);\r\nrelease_mem_region(dev.memaddr, 0x4000);\r\n}\r\nprintk(KERN_NOTICE "ICN-ISDN-driver unloaded\n");\r\n}
