static inline unsigned int dac_convert_reg(unsigned int channel)\r\n{\r\nreturn 0x70 + (2 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int dac_lsb_4020_reg(unsigned int channel)\r\n{\r\nreturn 0x70 + (4 * (channel & 0x1));\r\n}\r\nstatic inline unsigned int dac_msb_4020_reg(unsigned int channel)\r\n{\r\nreturn 0x72 + (4 * (channel & 0x1));\r\n}\r\nstatic inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)\r\n{\r\nreturn threshold & 0xfff;\r\n}\r\nstatic inline uint16_t adc_lo_chan_4020_bits(unsigned int channel)\r\n{\r\nreturn (channel & 0x3) << 8;\r\n}\r\nstatic inline uint16_t adc_hi_chan_4020_bits(unsigned int channel)\r\n{\r\nreturn (channel & 0x3) << 10;\r\n}\r\nstatic inline uint16_t adc_mode_bits(unsigned int mode)\r\n{\r\nreturn (mode & 0xf) << 12;\r\n}\r\nstatic inline uint16_t adc_src_bits(unsigned int source)\r\n{\r\nreturn (source & 0xf) << 3;\r\n}\r\nstatic inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)\r\n{\r\nreturn (channel & 0x3) << 8;\r\n}\r\nstatic inline uint16_t adc_chan_bits(unsigned int channel)\r\n{\r\nreturn channel & 0x3f;\r\n}\r\nstatic inline uint16_t pipe_full_bits(uint16_t hw_status_bits)\r\n{\r\nreturn (hw_status_bits >> 10) & 0x3;\r\n}\r\nstatic inline unsigned int dma_chain_flag_bits(uint16_t prepost_bits)\r\n{\r\nreturn (prepost_bits >> 6) & 0x3;\r\n}\r\nstatic inline unsigned int adc_upper_read_ptr_code(uint16_t prepost_bits)\r\n{\r\nreturn (prepost_bits >> 12) & 0x3;\r\n}\r\nstatic inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)\r\n{\r\nreturn (prepost_bits >> 14) & 0x3;\r\n}\r\nstatic inline uint8_t adc_src_4020_bits(unsigned int source)\r\n{\r\nreturn (source << 4) & ADC_SRC_4020_MASK;\r\n}\r\nstatic inline uint8_t attenuate_bit(unsigned int channel)\r\n{\r\nreturn 1 << (channel & 0x3);\r\n}\r\nstatic inline unsigned int ai_dma_ring_count(const struct pcidas64_board *board)\r\n{\r\nif (board->layout == LAYOUT_4020)\r\nreturn MAX_AI_DMA_RING_COUNT;\r\nreturn MIN_AI_DMA_RING_COUNT;\r\n}\r\nstatic inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,\r\nint use_differential)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nif ((board->layout == LAYOUT_64XX && !use_differential) ||\r\n(board->layout == LAYOUT_60XX && use_differential))\r\nreturn ADC_SE_DIFF_BIT;\r\nreturn 0;\r\n}\r\nstatic unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,\r\nunsigned int range_index)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nreturn board->ai_range_code[range_index] << 8;\r\n}\r\nstatic unsigned int hw_revision(const struct comedi_device *dev,\r\nuint16_t hw_status_bits)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nif (board->layout == LAYOUT_4020)\r\nreturn (hw_status_bits >> 13) & 0x7;\r\nreturn (hw_status_bits >> 12) & 0xf;\r\n}\r\nstatic void set_dac_range_bits(struct comedi_device *dev,\r\nuint16_t *bits, unsigned int channel,\r\nunsigned int range)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nunsigned int code = board->ao_range_code[range];\r\nif (channel > 1)\r\ndev_err(dev->class_dev, "bug! bad channel?\n");\r\nif (code & ~0x3)\r\ndev_err(dev->class_dev, "bug! bad range code?\n");\r\n*bits &= ~(0x3 << (2 * channel));\r\n*bits |= code << (2 * channel);\r\n}\r\nstatic inline int ao_cmd_is_supported(const struct pcidas64_board *board)\r\n{\r\nreturn board->ao_nchan && board->layout != LAYOUT_4020;\r\n}\r\nstatic void abort_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nplx9080_abort_dma(devpriv->plx9080_iobase, channel);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic void disable_plx_interrupts(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\ndevpriv->plx_intcsr_bits = 0;\r\nwritel(devpriv->plx_intcsr_bits,\r\ndevpriv->plx9080_iobase + PLX_INTRCS_REG);\r\n}\r\nstatic void disable_ai_interrupts(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->intr_enable_bits &=\r\n~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &\r\n~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &\r\n~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;\r\nwritew(devpriv->intr_enable_bits,\r\ndevpriv->main_iobase + INTR_ENABLE_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic void enable_ai_interrupts(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nuint32_t bits;\r\nunsigned long flags;\r\nbits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |\r\nEN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\nif (board->layout != LAYOUT_4020)\r\nbits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->intr_enable_bits |= bits;\r\nwritew(devpriv->intr_enable_bits,\r\ndevpriv->main_iobase + INTR_ENABLE_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic void init_plx9080(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nuint32_t bits;\r\nvoid __iomem *plx_iobase = devpriv->plx9080_iobase;\r\ndevpriv->plx_control_bits =\r\nreadl(devpriv->plx9080_iobase + PLX_CONTROL_REG);\r\n#ifdef __BIG_ENDIAN\r\nbits = BIGEND_DMA0 | BIGEND_DMA1;\r\n#else\r\nbits = 0;\r\n#endif\r\nwritel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);\r\ndisable_plx_interrupts(dev);\r\nabort_dma(dev, 0);\r\nabort_dma(dev, 1);\r\nbits = 0;\r\nbits |= PLX_DMA_EN_READYIN_BIT;\r\nbits |= PLX_EN_BTERM_BIT;\r\nbits |= PLX_EN_CHAIN_BIT;\r\nbits |= PLX_EN_DMA_DONE_INTR_BIT;\r\nbits |= PLX_LOCAL_ADDR_CONST_BIT;\r\nbits |= PLX_DMA_INTR_PCI_BIT;\r\nbits |= PLX_DEMAND_MODE_BIT;\r\nbits |= PLX_DMA_LOCAL_BURST_EN_BIT;\r\nif (board->layout == LAYOUT_4020)\r\nbits |= PLX_LOCAL_BUS_32_WIDE_BITS;\r\nelse\r\nbits |= PLX_LOCAL_BUS_16_WIDE_BITS;\r\nwritel(bits, plx_iobase + PLX_DMA1_MODE_REG);\r\nif (ao_cmd_is_supported(board))\r\nwritel(bits, plx_iobase + PLX_DMA0_MODE_REG);\r\ndevpriv->plx_intcsr_bits |=\r\nICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |\r\nICS_DMA0_E | ICS_DMA1_E;\r\nwritel(devpriv->plx_intcsr_bits,\r\ndevpriv->plx9080_iobase + PLX_INTRCS_REG);\r\n}\r\nstatic void disable_ai_pacing(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned long flags;\r\ndisable_ai_interrupts(dev);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_control1_bits &= ~ADC_SW_GATE_BIT;\r\nwritew(devpriv->adc_control1_bits,\r\ndevpriv->main_iobase + ADC_CONTROL1_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nwritew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,\r\ndevpriv->main_iobase + ADC_CONTROL0_REG);\r\n}\r\nstatic int set_ai_fifo_segment_length(struct comedi_device *dev,\r\nunsigned int num_entries)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstatic const int increment_size = 0x100;\r\nconst struct hw_fifo_info *const fifo = board->ai_fifo;\r\nunsigned int num_increments;\r\nuint16_t bits;\r\nif (num_entries < increment_size)\r\nnum_entries = increment_size;\r\nif (num_entries > fifo->max_segment_length)\r\nnum_entries = fifo->max_segment_length;\r\nnum_increments = (num_entries + increment_size / 2) / increment_size;\r\nbits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;\r\ndevpriv->fifo_size_bits &= ~fifo->fifo_size_reg_mask;\r\ndevpriv->fifo_size_bits |= bits;\r\nwritew(devpriv->fifo_size_bits,\r\ndevpriv->main_iobase + FIFO_SIZE_REG);\r\ndevpriv->ai_fifo_segment_length = num_increments * increment_size;\r\nreturn devpriv->ai_fifo_segment_length;\r\n}\r\nstatic int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nunsigned int num_fifo_entries;\r\nint retval;\r\nconst struct hw_fifo_info *const fifo = board->ai_fifo;\r\nnum_fifo_entries = num_samples / fifo->sample_packing_ratio;\r\nretval = set_ai_fifo_segment_length(dev,\r\nnum_fifo_entries /\r\nfifo->num_segments);\r\nif (retval < 0)\r\nreturn retval;\r\nnum_samples = retval * fifo->num_segments * fifo->sample_packing_ratio;\r\nreturn num_samples;\r\n}\r\nstatic unsigned int ai_fifo_size(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nreturn devpriv->ai_fifo_segment_length *\r\nboard->ai_fifo->num_segments *\r\nboard->ai_fifo->sample_packing_ratio;\r\n}\r\nstatic void init_stc_registers(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nuint16_t bits;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (1)\r\ndevpriv->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;\r\nwritew(devpriv->adc_control1_bits,\r\ndevpriv->main_iobase + ADC_CONTROL1_REG);\r\nwritew(0xff, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\r\nbits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;\r\nif (board->layout == LAYOUT_4020)\r\nbits |= INTERNAL_CLOCK_4020_BITS;\r\ndevpriv->hw_config_bits |= bits;\r\nwritew(devpriv->hw_config_bits,\r\ndevpriv->main_iobase + HW_CONFIG_REG);\r\nwritew(0, devpriv->main_iobase + DAQ_SYNC_REG);\r\nwritew(0, devpriv->main_iobase + CALIBRATION_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->fifo_size_bits |= DAC_FIFO_BITS;\r\nset_ai_fifo_segment_length(dev, board->ai_fifo->max_segment_length);\r\ndevpriv->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;\r\ndevpriv->intr_enable_bits =\r\nEN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;\r\nwritew(devpriv->intr_enable_bits,\r\ndevpriv->main_iobase + INTR_ENABLE_REG);\r\ndisable_ai_pacing(dev);\r\n}\r\nstatic int alloc_and_init_dma_members(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct pcidas64_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 0; i < ai_dma_ring_count(board); i++) {\r\ndevpriv->ai_buffer[i] =\r\npci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,\r\n&devpriv->ai_buffer_bus_addr[i]);\r\nif (!devpriv->ai_buffer[i])\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\r\nif (ao_cmd_is_supported(board)) {\r\ndevpriv->ao_buffer[i] =\r\npci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,\r\n&devpriv->\r\nao_buffer_bus_addr[i]);\r\nif (!devpriv->ao_buffer[i])\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndevpriv->ai_dma_desc =\r\npci_alloc_consistent(pcidev, sizeof(struct plx_dma_desc) *\r\nai_dma_ring_count(board),\r\n&devpriv->ai_dma_desc_bus_addr);\r\nif (!devpriv->ai_dma_desc)\r\nreturn -ENOMEM;\r\nif (ao_cmd_is_supported(board)) {\r\ndevpriv->ao_dma_desc =\r\npci_alloc_consistent(pcidev,\r\nsizeof(struct plx_dma_desc) *\r\nAO_DMA_RING_COUNT,\r\n&devpriv->ao_dma_desc_bus_addr);\r\nif (!devpriv->ao_dma_desc)\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ai_dma_ring_count(board); i++) {\r\ndevpriv->ai_dma_desc[i].pci_start_addr =\r\ncpu_to_le32(devpriv->ai_buffer_bus_addr[i]);\r\nif (board->layout == LAYOUT_4020)\r\ndevpriv->ai_dma_desc[i].local_start_addr =\r\ncpu_to_le32(devpriv->local1_iobase +\r\nADC_FIFO_REG);\r\nelse\r\ndevpriv->ai_dma_desc[i].local_start_addr =\r\ncpu_to_le32(devpriv->local0_iobase +\r\nADC_FIFO_REG);\r\ndevpriv->ai_dma_desc[i].transfer_size = cpu_to_le32(0);\r\ndevpriv->ai_dma_desc[i].next =\r\ncpu_to_le32((devpriv->ai_dma_desc_bus_addr +\r\n((i + 1) % ai_dma_ring_count(board)) *\r\nsizeof(devpriv->ai_dma_desc[0])) |\r\nPLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI);\r\n}\r\nif (ao_cmd_is_supported(board)) {\r\nfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\r\ndevpriv->ao_dma_desc[i].pci_start_addr =\r\ncpu_to_le32(devpriv->ao_buffer_bus_addr[i]);\r\ndevpriv->ao_dma_desc[i].local_start_addr =\r\ncpu_to_le32(devpriv->local0_iobase +\r\nDAC_FIFO_REG);\r\ndevpriv->ao_dma_desc[i].transfer_size = cpu_to_le32(0);\r\ndevpriv->ao_dma_desc[i].next =\r\ncpu_to_le32((devpriv->ao_dma_desc_bus_addr +\r\n((i + 1) % (AO_DMA_RING_COUNT)) *\r\nsizeof(devpriv->ao_dma_desc[0])) |\r\nPLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cb_pcidas64_free_dma(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct pcidas64_private *devpriv = dev->private;\r\nint i;\r\nif (!devpriv)\r\nreturn;\r\nfor (i = 0; i < ai_dma_ring_count(board); i++) {\r\nif (devpriv->ai_buffer[i])\r\npci_free_consistent(pcidev,\r\nDMA_BUFFER_SIZE,\r\ndevpriv->ai_buffer[i],\r\ndevpriv->ai_buffer_bus_addr[i]);\r\n}\r\nfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\r\nif (devpriv->ao_buffer[i])\r\npci_free_consistent(pcidev,\r\nDMA_BUFFER_SIZE,\r\ndevpriv->ao_buffer[i],\r\ndevpriv->ao_buffer_bus_addr[i]);\r\n}\r\nif (devpriv->ai_dma_desc)\r\npci_free_consistent(pcidev,\r\nsizeof(struct plx_dma_desc) *\r\nai_dma_ring_count(board),\r\ndevpriv->ai_dma_desc,\r\ndevpriv->ai_dma_desc_bus_addr);\r\nif (devpriv->ao_dma_desc)\r\npci_free_consistent(pcidev,\r\nsizeof(struct plx_dma_desc) *\r\nAO_DMA_RING_COUNT,\r\ndevpriv->ao_dma_desc,\r\ndevpriv->ao_dma_desc_bus_addr);\r\n}\r\nstatic inline void warn_external_queue(struct comedi_device *dev)\r\n{\r\ndev_err(dev->class_dev,\r\n"AO command and AI external channel queue cannot be used simultaneously\n");\r\ndev_err(dev->class_dev,\r\n"Use internal AI channel queue (channels must be consecutive and use same range/aref)\n");\r\n}\r\nstatic void i2c_set_sda(struct comedi_device *dev, int state)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstatic const int data_bit = CTL_EE_W;\r\nvoid __iomem *plx_control_addr = devpriv->plx9080_iobase +\r\nPLX_CONTROL_REG;\r\nif (state) {\r\ndevpriv->plx_control_bits &= ~data_bit;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(i2c_high_udelay);\r\n} else {\r\ndevpriv->plx_control_bits |= data_bit;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(i2c_low_udelay);\r\n}\r\n}\r\nstatic void i2c_set_scl(struct comedi_device *dev, int state)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstatic const int clock_bit = CTL_USERO;\r\nvoid __iomem *plx_control_addr = devpriv->plx9080_iobase +\r\nPLX_CONTROL_REG;\r\nif (state) {\r\ndevpriv->plx_control_bits &= ~clock_bit;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(i2c_high_udelay);\r\n} else {\r\ndevpriv->plx_control_bits |= clock_bit;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(i2c_low_udelay);\r\n}\r\n}\r\nstatic void i2c_write_byte(struct comedi_device *dev, uint8_t byte)\r\n{\r\nuint8_t bit;\r\nunsigned int num_bits = 8;\r\nfor (bit = 1 << (num_bits - 1); bit; bit >>= 1) {\r\ni2c_set_scl(dev, 0);\r\nif ((byte & bit))\r\ni2c_set_sda(dev, 1);\r\nelse\r\ni2c_set_sda(dev, 0);\r\ni2c_set_scl(dev, 1);\r\n}\r\n}\r\nstatic int i2c_read_ack(struct comedi_device *dev)\r\n{\r\ni2c_set_scl(dev, 0);\r\ni2c_set_sda(dev, 1);\r\ni2c_set_scl(dev, 1);\r\nreturn 0;\r\n}\r\nstatic void i2c_start(struct comedi_device *dev)\r\n{\r\ni2c_set_scl(dev, 1);\r\ni2c_set_sda(dev, 1);\r\ni2c_set_sda(dev, 0);\r\n}\r\nstatic void i2c_stop(struct comedi_device *dev)\r\n{\r\ni2c_set_scl(dev, 0);\r\ni2c_set_sda(dev, 0);\r\ni2c_set_scl(dev, 1);\r\ni2c_set_sda(dev, 1);\r\n}\r\nstatic void i2c_write(struct comedi_device *dev, unsigned int address,\r\nconst uint8_t *data, unsigned int length)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int i;\r\nuint8_t bitstream;\r\nstatic const int read_bit = 0x1;\r\ndevpriv->plx_control_bits &= ~CTL_EE_CS;\r\ni2c_stop(dev);\r\ni2c_start(dev);\r\nbitstream = (address << 1) & ~read_bit;\r\ni2c_write_byte(dev, bitstream);\r\nif (i2c_read_ack(dev) != 0) {\r\ndev_err(dev->class_dev, "failed: no acknowledge\n");\r\ni2c_stop(dev);\r\nreturn;\r\n}\r\nfor (i = 0; i < length; i++) {\r\ni2c_write_byte(dev, data[i]);\r\nif (i2c_read_ack(dev) != 0) {\r\ndev_err(dev->class_dev, "failed: no acknowledge\n");\r\ni2c_stop(dev);\r\nreturn;\r\n}\r\n}\r\ni2c_stop(dev);\r\n}\r\nstatic int cb_pcidas64_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int status;\r\nstatus = readw(devpriv->main_iobase + HW_STATUS_REG);\r\nif (board->layout == LAYOUT_4020) {\r\nstatus = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG);\r\nif (status)\r\nreturn 0;\r\n} else {\r\nif (pipe_full_bits(status))\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int bits = 0, n;\r\nunsigned int channel, range, aref;\r\nunsigned long flags;\r\nint ret;\r\nchannel = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\naref = CR_AREF(insn->chanspec);\r\ndisable_ai_pacing(dev);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (insn->chanspec & CR_ALT_FILTER)\r\ndevpriv->adc_control1_bits |= ADC_DITHER_BIT;\r\nelse\r\ndevpriv->adc_control1_bits &= ~ADC_DITHER_BIT;\r\nwritew(devpriv->adc_control1_bits,\r\ndevpriv->main_iobase + ADC_CONTROL1_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (board->layout != LAYOUT_4020) {\r\ndevpriv->hw_config_bits &= ~EXT_QUEUE_BIT;\r\nwritew(devpriv->hw_config_bits,\r\ndevpriv->main_iobase + HW_CONFIG_REG);\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\nunsigned int cal_en_bit;\r\nif (board->layout == LAYOUT_60XX)\r\ncal_en_bit = CAL_EN_60XX_BIT;\r\nelse\r\ncal_en_bit = CAL_EN_64XX_BIT;\r\nwritew(cal_en_bit |\r\nadc_src_bits(devpriv->calibration_source),\r\ndevpriv->main_iobase + CALIBRATION_REG);\r\n} else {\r\nwritew(0, devpriv->main_iobase + CALIBRATION_REG);\r\n}\r\nbits = 0;\r\nbits |= ai_range_bits_6xxx(dev, CR_RANGE(insn->chanspec));\r\nbits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);\r\nif (aref == AREF_COMMON)\r\nbits |= ADC_COMMON_BIT;\r\nbits |= adc_chan_bits(channel);\r\nwritew(adc_chan_bits(channel),\r\ndevpriv->main_iobase + ADC_QUEUE_HIGH_REG);\r\nwritew(bits, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);\r\n} else {\r\nuint8_t old_cal_range_bits = devpriv->i2c_cal_range_bits;\r\ndevpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;\r\nif (insn->chanspec & CR_ALT_SOURCE) {\r\ndevpriv->i2c_cal_range_bits |=\r\nadc_src_4020_bits(devpriv->calibration_source);\r\n} else {\r\ndevpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);\r\n}\r\nif (range == 0)\r\ndevpriv->i2c_cal_range_bits |= attenuate_bit(channel);\r\nelse\r\ndevpriv->i2c_cal_range_bits &= ~attenuate_bit(channel);\r\nif (old_cal_range_bits != devpriv->i2c_cal_range_bits) {\r\nuint8_t i2c_data = devpriv->i2c_cal_range_bits;\r\ni2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,\r\nsizeof(i2c_data));\r\n}\r\nwritew(0, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\r\nwritew(2, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\nwritew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);\r\nwritew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),\r\ndevpriv->main_iobase + ADC_CONVERT_REG);\r\nret = comedi_timeout(dev, s, insn, cb_pcidas64_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nif (board->layout == LAYOUT_4020)\r\ndata[n] = readl(dev->mmio + ADC_FIFO_REG) & 0xffff;\r\nelse\r\ndata[n] = readw(devpriv->main_iobase + PIPE1_READ_REG);\r\n}\r\nreturn n;\r\n}\r\nstatic int ai_config_calibration_source(struct comedi_device *dev,\r\nunsigned int *data)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int source = data[1];\r\nint num_calibration_sources;\r\nif (board->layout == LAYOUT_60XX)\r\nnum_calibration_sources = 16;\r\nelse\r\nnum_calibration_sources = 8;\r\nif (source >= num_calibration_sources) {\r\ndev_dbg(dev->class_dev, "invalid calibration source: %i\n",\r\nsource);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->calibration_source = source;\r\nreturn 2;\r\n}\r\nstatic int ai_config_block_size(struct comedi_device *dev, unsigned int *data)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nint fifo_size;\r\nconst struct hw_fifo_info *const fifo = board->ai_fifo;\r\nunsigned int block_size, requested_block_size;\r\nint retval;\r\nrequested_block_size = data[1];\r\nif (requested_block_size) {\r\nfifo_size = requested_block_size * fifo->num_segments /\r\nbytes_in_sample;\r\nretval = set_ai_fifo_size(dev, fifo_size);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nblock_size = ai_fifo_size(dev) / fifo->num_segments * bytes_in_sample;\r\ndata[1] = block_size;\r\nreturn 2;\r\n}\r\nstatic int ai_config_master_clock_4020(struct comedi_device *dev,\r\nunsigned int *data)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int divisor = data[4];\r\nint retval = 0;\r\nif (divisor < 2) {\r\ndivisor = 2;\r\nretval = -EAGAIN;\r\n}\r\nswitch (data[1]) {\r\ncase COMEDI_EV_SCAN_BEGIN:\r\ndevpriv->ext_clock.divisor = divisor;\r\ndevpriv->ext_clock.chanspec = data[2];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndata[4] = divisor;\r\nreturn retval ? retval : 5;\r\n}\r\nstatic int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nswitch (board->layout) {\r\ncase LAYOUT_4020:\r\nreturn ai_config_master_clock_4020(dev, data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint id = data[0];\r\nswitch (id) {\r\ncase INSN_CONFIG_ALT_SOURCE:\r\nreturn ai_config_calibration_source(dev, data);\r\ncase INSN_CONFIG_BLOCK_SIZE:\r\nreturn ai_config_block_size(dev, data);\r\ncase INSN_CONFIG_TIMER_1:\r\nreturn ai_config_master_clock(dev, data);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int get_divisor(unsigned int ns, unsigned int flags)\r\n{\r\nunsigned int divisor;\r\nswitch (flags & CMDF_ROUND_MASK) {\r\ncase CMDF_ROUND_UP:\r\ndivisor = (ns + TIMER_BASE - 1) / TIMER_BASE;\r\nbreak;\r\ncase CMDF_ROUND_DOWN:\r\ndivisor = ns / TIMER_BASE;\r\nbreak;\r\ncase CMDF_ROUND_NEAREST:\r\ndefault:\r\ndivisor = (ns + TIMER_BASE / 2) / TIMER_BASE;\r\nbreak;\r\n}\r\nreturn divisor;\r\n}\r\nstatic void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nunsigned long long convert_divisor = 0;\r\nunsigned int scan_divisor;\r\nstatic const int min_convert_divisor = 3;\r\nstatic const int max_convert_divisor =\r\nmax_counter_value + min_convert_divisor;\r\nstatic const int min_scan_divisor_4020 = 2;\r\nunsigned long long max_scan_divisor, min_scan_divisor;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (board->layout == LAYOUT_4020) {\r\ncmd->convert_arg = 0;\r\n} else {\r\nconvert_divisor = get_divisor(cmd->convert_arg,\r\ncmd->flags);\r\nif (convert_divisor > max_convert_divisor)\r\nconvert_divisor = max_convert_divisor;\r\nif (convert_divisor < min_convert_divisor)\r\nconvert_divisor = min_convert_divisor;\r\ncmd->convert_arg = convert_divisor * TIMER_BASE;\r\n}\r\n} else if (cmd->convert_src == TRIG_NOW) {\r\ncmd->convert_arg = 0;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nscan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nmin_scan_divisor = convert_divisor * cmd->chanlist_len;\r\nmax_scan_divisor =\r\n(convert_divisor * cmd->chanlist_len - 1) +\r\nmax_counter_value;\r\n} else {\r\nmin_scan_divisor = min_scan_divisor_4020;\r\nmax_scan_divisor = max_counter_value + min_scan_divisor;\r\n}\r\nif (scan_divisor > max_scan_divisor)\r\nscan_divisor = max_scan_divisor;\r\nif (scan_divisor < min_scan_divisor)\r\nscan_divisor = min_scan_divisor;\r\ncmd->scan_begin_arg = scan_divisor * TIMER_BASE;\r\n}\r\n}\r\nstatic int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nif (aref != aref0) {\r\ndev_dbg(dev->class_dev,\r\n"all elements in chanlist must use the same analog reference\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (board->layout == LAYOUT_4020) {\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (chan != (chan0 + i)) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must use consecutive channels\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (cmd->chanlist_len == 3) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist cannot be 3 channels long, use 1, 2, or 4 channels\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nint err = 0;\r\nunsigned int tmp_arg, tmp_arg2;\r\nunsigned int triggers;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\ntriggers = TRIG_TIMER;\r\nif (board->layout == LAYOUT_4020)\r\ntriggers |= TRIG_OTHER;\r\nelse\r\ntriggers |= TRIG_FOLLOW;\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, triggers);\r\ntriggers = TRIG_TIMER;\r\nif (board->layout == LAYOUT_4020)\r\ntriggers |= TRIG_NOW;\r\nelse\r\ntriggers |= TRIG_EXT;\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, triggers);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src,\r\nTRIG_COUNT | TRIG_EXT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\nbreak;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (board->layout == LAYOUT_4020) {\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg,\r\n0);\r\n} else {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_speed);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(\r\n&cmd->scan_begin_arg,\r\ncmd->convert_arg *\r\ncmd->chanlist_len);\r\n}\r\n}\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_EXT:\r\nbreak;\r\ncase TRIG_COUNT:\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp_arg = cmd->convert_arg;\r\ntmp_arg2 = cmd->scan_begin_arg;\r\ncheck_adc_timing(dev, cmd);\r\nif (tmp_arg != cmd->convert_arg)\r\nerr++;\r\nif (tmp_arg2 != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= cb_pcidas64_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int use_hw_sample_counter(struct comedi_cmd *cmd)\r\n{\r\nreturn 0;\r\nif (cmd->stop_src == TRIG_COUNT && cmd->stop_arg <= max_counter_value)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void setup_sample_counters(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nif (use_hw_sample_counter(cmd)) {\r\nwritew(cmd->stop_arg & 0xffff,\r\ndevpriv->main_iobase + ADC_COUNT_LOWER_REG);\r\nwritew((cmd->stop_arg >> 16) & 0xff,\r\ndevpriv->main_iobase + ADC_COUNT_UPPER_REG);\r\n} else {\r\nwritew(1, devpriv->main_iobase + ADC_COUNT_LOWER_REG);\r\n}\r\n}\r\nstatic inline unsigned int dma_transfer_size(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int num_samples;\r\nnum_samples = devpriv->ai_fifo_segment_length *\r\nboard->ai_fifo->sample_packing_ratio;\r\nif (num_samples > DMA_BUFFER_SIZE / sizeof(uint16_t))\r\nnum_samples = DMA_BUFFER_SIZE / sizeof(uint16_t);\r\nreturn num_samples;\r\n}\r\nstatic uint32_t ai_convert_counter_6xxx(const struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nreturn cmd->convert_arg / TIMER_BASE - 3;\r\n}\r\nstatic uint32_t ai_scan_counter_6xxx(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nuint32_t count;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ncount = (cmd->scan_begin_arg -\r\n(cmd->convert_arg * (cmd->chanlist_len - 1))) /\r\nTIMER_BASE;\r\nbreak;\r\ncase TRIG_FOLLOW:\r\ncount = cmd->convert_arg / TIMER_BASE;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn count - 3;\r\n}\r\nstatic uint32_t ai_convert_counter_4020(struct comedi_device *dev,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int divisor;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_TIMER:\r\ndivisor = cmd->scan_begin_arg / TIMER_BASE;\r\nbreak;\r\ncase TRIG_OTHER:\r\ndivisor = devpriv->ext_clock.divisor;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "bug! failed to set ai pacing!\n");\r\ndivisor = 1000;\r\nbreak;\r\n}\r\nreturn divisor - 2;\r\n}\r\nstatic void select_master_clock_4020(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\ndevpriv->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;\r\nif (cmd->scan_begin_src == TRIG_OTHER) {\r\nint chanspec = devpriv->ext_clock.chanspec;\r\nif (CR_CHAN(chanspec))\r\ndevpriv->hw_config_bits |= BNC_CLOCK_4020_BITS;\r\nelse\r\ndevpriv->hw_config_bits |= EXT_CLOCK_4020_BITS;\r\n} else {\r\ndevpriv->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;\r\n}\r\nwritew(devpriv->hw_config_bits,\r\ndevpriv->main_iobase + HW_CONFIG_REG);\r\n}\r\nstatic void select_master_clock(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nswitch (board->layout) {\r\ncase LAYOUT_4020:\r\nselect_master_clock_4020(dev, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic inline void dma_start_sync(struct comedi_device *dev,\r\nunsigned int channel)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (channel)\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |\r\nPLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA1_CS_REG);\r\nelse\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |\r\nPLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nuint32_t convert_counter = 0, scan_counter = 0;\r\ncheck_adc_timing(dev, cmd);\r\nselect_master_clock(dev, cmd);\r\nif (board->layout == LAYOUT_4020) {\r\nconvert_counter = ai_convert_counter_4020(dev, cmd);\r\n} else {\r\nconvert_counter = ai_convert_counter_6xxx(dev, cmd);\r\nscan_counter = ai_scan_counter_6xxx(dev, cmd);\r\n}\r\nwritew(convert_counter & 0xffff,\r\ndevpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);\r\nwritew((convert_counter >> 16) & 0xff,\r\ndevpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\r\nwritew(scan_counter & 0xffff,\r\ndevpriv->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);\r\nwritew((scan_counter >> 16) & 0xff,\r\ndevpriv->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);\r\n}\r\nstatic int use_internal_queue_6xxx(const struct comedi_cmd *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i + 1 < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i + 1]) !=\r\nCR_CHAN(cmd->chanlist[i]) + 1)\r\nreturn 0;\r\nif (CR_RANGE(cmd->chanlist[i + 1]) !=\r\nCR_RANGE(cmd->chanlist[i]))\r\nreturn 0;\r\nif (CR_AREF(cmd->chanlist[i + 1]) != CR_AREF(cmd->chanlist[i]))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int setup_channel_queue(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned short bits;\r\nint i;\r\nif (board->layout != LAYOUT_4020) {\r\nif (use_internal_queue_6xxx(cmd)) {\r\ndevpriv->hw_config_bits &= ~EXT_QUEUE_BIT;\r\nwritew(devpriv->hw_config_bits,\r\ndevpriv->main_iobase + HW_CONFIG_REG);\r\nbits = 0;\r\nbits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));\r\nbits |= ai_range_bits_6xxx(dev,\r\nCR_RANGE(cmd->chanlist[0]));\r\nbits |= se_diff_bit_6xxx(dev,\r\nCR_AREF(cmd->chanlist[0]) ==\r\nAREF_DIFF);\r\nif (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)\r\nbits |= ADC_COMMON_BIT;\r\nwritew(adc_chan_bits\r\n(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),\r\ndevpriv->main_iobase + ADC_QUEUE_HIGH_REG);\r\nwritew(bits,\r\ndevpriv->main_iobase + ADC_QUEUE_LOAD_REG);\r\n} else {\r\nif (dev->write_subdev && dev->write_subdev->busy) {\r\nwarn_external_queue(dev);\r\nreturn -EBUSY;\r\n}\r\ndevpriv->hw_config_bits |= EXT_QUEUE_BIT;\r\nwritew(devpriv->hw_config_bits,\r\ndevpriv->main_iobase + HW_CONFIG_REG);\r\nwritew(0,\r\ndevpriv->main_iobase + DAC_BUFFER_CLEAR_REG);\r\nwritew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nbits = 0;\r\nbits |= adc_chan_bits(CR_CHAN(cmd->\r\nchanlist[i]));\r\nbits |= ai_range_bits_6xxx(dev,\r\nCR_RANGE(cmd->\r\nchanlist\r\n[i]));\r\nbits |= se_diff_bit_6xxx(dev,\r\nCR_AREF(cmd->\r\nchanlist[i]) ==\r\nAREF_DIFF);\r\nif (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)\r\nbits |= ADC_COMMON_BIT;\r\nif (i == cmd->chanlist_len - 1)\r\nbits |= QUEUE_EOSCAN_BIT |\r\nQUEUE_EOSEQ_BIT;\r\nwritew(bits,\r\ndevpriv->main_iobase +\r\nADC_QUEUE_FIFO_REG);\r\n}\r\nwritew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);\r\nwritew(0, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);\r\n}\r\n} else {\r\nunsigned short old_cal_range_bits = devpriv->i2c_cal_range_bits;\r\ndevpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;\r\ndevpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int channel = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nif (range == 0)\r\ndevpriv->i2c_cal_range_bits |=\r\nattenuate_bit(channel);\r\nelse\r\ndevpriv->i2c_cal_range_bits &=\r\n~attenuate_bit(channel);\r\n}\r\nif (old_cal_range_bits != devpriv->i2c_cal_range_bits) {\r\nuint8_t i2c_data = devpriv->i2c_cal_range_bits;\r\ni2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,\r\nsizeof(i2c_data));\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void load_first_dma_descriptor(struct comedi_device *dev,\r\nunsigned int dma_channel,\r\nunsigned int descriptor_bits)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nif (dma_channel) {\r\nwritel(0,\r\ndevpriv->plx9080_iobase + PLX_DMA1_TRANSFER_SIZE_REG);\r\nwritel(0, devpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG);\r\nwritel(0,\r\ndevpriv->plx9080_iobase + PLX_DMA1_LOCAL_ADDRESS_REG);\r\nwritel(descriptor_bits,\r\ndevpriv->plx9080_iobase + PLX_DMA1_DESCRIPTOR_REG);\r\n} else {\r\nwritel(0,\r\ndevpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);\r\nwritel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);\r\nwritel(0,\r\ndevpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);\r\nwritel(descriptor_bits,\r\ndevpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);\r\n}\r\n}\r\nstatic int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nuint32_t bits;\r\nunsigned int i;\r\nunsigned long flags;\r\nint retval;\r\ndisable_ai_pacing(dev);\r\nabort_dma(dev, 1);\r\nretval = setup_channel_queue(dev, cmd);\r\nif (retval < 0)\r\nreturn retval;\r\nwritew(0, devpriv->main_iobase + CALIBRATION_REG);\r\nset_ai_pacing(dev, cmd);\r\nsetup_sample_counters(dev, cmd);\r\nenable_ai_interrupts(dev, cmd);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->adc_control1_bits |= ADC_SW_GATE_BIT;\r\ndevpriv->adc_control1_bits &= ~ADC_DITHER_BIT;\r\nif (board->layout != LAYOUT_4020) {\r\ndevpriv->adc_control1_bits &= ~ADC_MODE_MASK;\r\nif (cmd->convert_src == TRIG_EXT)\r\ndevpriv->adc_control1_bits |= adc_mode_bits(13);\r\nelse\r\ndevpriv->adc_control1_bits |= adc_mode_bits(8);\r\n} else {\r\ndevpriv->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;\r\nif (cmd->chanlist_len == 4)\r\ndevpriv->adc_control1_bits |= FOUR_CHANNEL_4020_BITS;\r\nelse if (cmd->chanlist_len == 2)\r\ndevpriv->adc_control1_bits |= TWO_CHANNEL_4020_BITS;\r\ndevpriv->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;\r\ndevpriv->adc_control1_bits |=\r\nadc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));\r\ndevpriv->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;\r\ndevpriv->adc_control1_bits |=\r\nadc_hi_chan_4020_bits(CR_CHAN(cmd->chanlist\r\n[cmd->chanlist_len - 1]));\r\n}\r\nwritew(devpriv->adc_control1_bits,\r\ndevpriv->main_iobase + ADC_CONTROL1_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nwritew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);\r\nif ((cmd->flags & CMDF_WAKE_EOS) == 0 ||\r\nboard->layout == LAYOUT_4020) {\r\ndevpriv->ai_dma_index = 0;\r\nfor (i = 0; i < ai_dma_ring_count(board); i++)\r\ndevpriv->ai_dma_desc[i].transfer_size =\r\ncpu_to_le32(dma_transfer_size(dev) *\r\nsizeof(uint16_t));\r\nload_first_dma_descriptor(dev, 1,\r\ndevpriv->ai_dma_desc_bus_addr |\r\nPLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI);\r\ndma_start_sync(dev, 1);\r\n}\r\nif (board->layout == LAYOUT_4020) {\r\nbits = 0;\r\nif (cmd->start_src == TRIG_EXT && CR_CHAN(cmd->start_arg))\r\nbits |= EXT_START_TRIG_BNC_BIT;\r\nif (cmd->stop_src == TRIG_EXT && CR_CHAN(cmd->stop_arg))\r\nbits |= EXT_STOP_TRIG_BNC_BIT;\r\nwritew(bits, devpriv->main_iobase + DAQ_ATRIG_LOW_4020_REG);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nbits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;\r\nif (cmd->flags & CMDF_WAKE_EOS)\r\nbits |= ADC_DMA_DISABLE_BIT;\r\nif (cmd->start_src == TRIG_EXT) {\r\nbits |= ADC_START_TRIG_EXT_BITS;\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= ADC_START_TRIG_FALLING_BIT;\r\n} else if (cmd->start_src == TRIG_NOW) {\r\nbits |= ADC_START_TRIG_SOFT_BITS;\r\n}\r\nif (use_hw_sample_counter(cmd))\r\nbits |= ADC_SAMPLE_COUNTER_EN_BIT;\r\nwritew(bits, devpriv->main_iobase + ADC_CONTROL0_REG);\r\ndevpriv->ai_cmd_running = 1;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (cmd->start_src == TRIG_NOW)\r\nwritew(0, devpriv->main_iobase + ADC_START_REG);\r\nreturn 0;\r\n}\r\nstatic void pio_drain_ai_fifo_16(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int i;\r\nuint16_t prepost_bits;\r\nint read_segment, read_index, write_segment, write_index;\r\nint num_samples;\r\ndo {\r\nread_index = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &\r\n0x7fff;\r\nwrite_index = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) &\r\n0x7fff;\r\nprepost_bits = readw(devpriv->main_iobase + PREPOST_REG);\r\nread_segment = adc_upper_read_ptr_code(prepost_bits);\r\nwrite_segment = adc_upper_write_ptr_code(prepost_bits);\r\nif (read_segment != write_segment)\r\nnum_samples =\r\ndevpriv->ai_fifo_segment_length - read_index;\r\nelse\r\nnum_samples = write_index - read_index;\r\nif (num_samples < 0) {\r\ndev_err(dev->class_dev,\r\n"cb_pcidas64: bug! num_samples < 0\n");\r\nbreak;\r\n}\r\nnum_samples = comedi_nsamples_left(s, num_samples);\r\nif (num_samples == 0)\r\nbreak;\r\nfor (i = 0; i < num_samples; i++) {\r\nunsigned short val;\r\nval = readw(devpriv->main_iobase + ADC_FIFO_REG);\r\ncomedi_buf_write_samples(s, &val, 1);\r\n}\r\n} while (read_segment != write_segment);\r\n}\r\nstatic void pio_drain_ai_fifo_32(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int nsamples;\r\nunsigned int i;\r\nuint32_t fifo_data;\r\nint write_code =\r\nreadw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;\r\nint read_code =\r\nreadw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;\r\nnsamples = comedi_nsamples_left(s, 100000);\r\nfor (i = 0; read_code != write_code && i < nsamples;) {\r\nunsigned short val;\r\nfifo_data = readl(dev->mmio + ADC_FIFO_REG);\r\nval = fifo_data & 0xffff;\r\ncomedi_buf_write_samples(s, &val, 1);\r\ni++;\r\nif (i < nsamples) {\r\nval = (fifo_data >> 16) & 0xffff;\r\ncomedi_buf_write_samples(s, &val, 1);\r\ni++;\r\n}\r\nread_code = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &\r\n0x7fff;\r\n}\r\n}\r\nstatic void pio_drain_ai_fifo(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nif (board->layout == LAYOUT_4020)\r\npio_drain_ai_fifo_32(dev);\r\nelse\r\npio_drain_ai_fifo_16(dev);\r\n}\r\nstatic void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nuint32_t next_transfer_addr;\r\nint j;\r\nint num_samples = 0;\r\nvoid __iomem *pci_addr_reg;\r\nif (channel)\r\npci_addr_reg =\r\ndevpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;\r\nelse\r\npci_addr_reg =\r\ndevpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;\r\nfor (j = 0, next_transfer_addr = readl(pci_addr_reg);\r\n(next_transfer_addr <\r\ndevpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] ||\r\nnext_transfer_addr >=\r\ndevpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +\r\nDMA_BUFFER_SIZE) && j < ai_dma_ring_count(board); j++) {\r\nnum_samples = comedi_nsamples_left(s, dma_transfer_size(dev));\r\ncomedi_buf_write_samples(s,\r\ndevpriv->ai_buffer[devpriv->ai_dma_index],\r\nnum_samples);\r\ndevpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %\r\nai_dma_ring_count(board);\r\n}\r\n}\r\nstatic void handle_ai_interrupt(struct comedi_device *dev,\r\nunsigned short status,\r\nunsigned int plx_status)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nuint8_t dma1_status;\r\nunsigned long flags;\r\nif (status & ADC_OVERRUN_BIT) {\r\ndev_err(dev->class_dev, "fifo overrun\n");\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma1_status = readb(devpriv->plx9080_iobase + PLX_DMA1_CS_REG);\r\nif (plx_status & ICS_DMA1_A) {\r\nwriteb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA1_CS_REG);\r\nif (dma1_status & PLX_DMA_EN_BIT)\r\ndrain_dma_buffers(dev, 1);\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif ((status & ADC_DONE_BIT) ||\r\n((cmd->flags & CMDF_WAKE_EOS) &&\r\n(status & ADC_INTR_PENDING_BIT) &&\r\n(board->layout != LAYOUT_4020))) {\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (devpriv->ai_cmd_running) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\npio_drain_ai_fifo(dev);\r\n} else {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\n}\r\nif ((cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) ||\r\n(cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT)))\r\nasync->events |= COMEDI_CB_EOA;\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic inline unsigned int prev_ao_dma_index(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int buffer_index;\r\nif (devpriv->ao_dma_index == 0)\r\nbuffer_index = AO_DMA_RING_COUNT - 1;\r\nelse\r\nbuffer_index = devpriv->ao_dma_index - 1;\r\nreturn buffer_index;\r\n}\r\nstatic int last_ao_dma_load_completed(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int buffer_index;\r\nunsigned int transfer_address;\r\nunsigned short dma_status;\r\nbuffer_index = prev_ao_dma_index(dev);\r\ndma_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nif ((dma_status & PLX_DMA_DONE_BIT) == 0)\r\nreturn 0;\r\ntransfer_address =\r\nreadl(devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);\r\nif (transfer_address != devpriv->ao_buffer_bus_addr[buffer_index])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int ao_dma_needs_restart(struct comedi_device *dev,\r\nunsigned short dma_status)\r\n{\r\nif ((dma_status & PLX_DMA_DONE_BIT) == 0 ||\r\n(dma_status & PLX_DMA_EN_BIT) == 0)\r\nreturn 0;\r\nif (last_ao_dma_load_completed(dev))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void restart_ao_dma(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int dma_desc_bits;\r\ndma_desc_bits =\r\nreadl(devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);\r\ndma_desc_bits &= ~PLX_END_OF_CHAIN_BIT;\r\nload_first_dma_descriptor(dev, 0, dma_desc_bits);\r\ndma_start_sync(dev, 0);\r\n}\r\nstatic unsigned int cb_pcidas64_ao_fill_buffer(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short *dest,\r\nunsigned int max_bytes)\r\n{\r\nunsigned int nsamples = comedi_bytes_to_samples(s, max_bytes);\r\nunsigned int actual_bytes;\r\nnsamples = comedi_nsamples_left(s, nsamples);\r\nactual_bytes = comedi_buf_read_samples(s, dest, nsamples);\r\nreturn comedi_bytes_to_samples(s, actual_bytes);\r\n}\r\nstatic unsigned int load_ao_dma_buffer(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nunsigned int buffer_index = devpriv->ao_dma_index;\r\nunsigned int prev_buffer_index = prev_ao_dma_index(dev);\r\nunsigned int nsamples;\r\nunsigned int nbytes;\r\nunsigned int next_bits;\r\nnsamples = cb_pcidas64_ao_fill_buffer(dev, s,\r\ndevpriv->ao_buffer[buffer_index],\r\nDMA_BUFFER_SIZE);\r\nif (nsamples == 0)\r\nreturn 0;\r\nnbytes = comedi_samples_to_bytes(s, nsamples);\r\ndevpriv->ao_dma_desc[buffer_index].transfer_size = cpu_to_le32(nbytes);\r\nnext_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);\r\nnext_bits |= PLX_END_OF_CHAIN_BIT;\r\ndevpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);\r\nnext_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);\r\nnext_bits &= ~PLX_END_OF_CHAIN_BIT;\r\ndevpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);\r\ndevpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;\r\nreturn nbytes;\r\n}\r\nstatic void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int num_bytes;\r\nunsigned int next_transfer_addr;\r\nvoid __iomem *pci_addr_reg =\r\ndevpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;\r\nunsigned int buffer_index;\r\ndo {\r\nbuffer_index = devpriv->ao_dma_index;\r\nnext_transfer_addr = readl(pci_addr_reg);\r\nif (next_transfer_addr >=\r\ndevpriv->ao_buffer_bus_addr[buffer_index] &&\r\nnext_transfer_addr <\r\ndevpriv->ao_buffer_bus_addr[buffer_index] +\r\nDMA_BUFFER_SIZE)\r\nreturn;\r\nnum_bytes = load_ao_dma_buffer(dev, cmd);\r\n} while (num_bytes >= DMA_BUFFER_SIZE);\r\n}\r\nstatic void handle_ao_interrupt(struct comedi_device *dev,\r\nunsigned short status, unsigned int plx_status)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nuint8_t dma0_status;\r\nunsigned long flags;\r\nif (!s)\r\nreturn;\r\nasync = s->async;\r\ncmd = &async->cmd;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nif (plx_status & ICS_DMA0_A) {\r\nif ((dma0_status & PLX_DMA_EN_BIT) &&\r\n!(dma0_status & PLX_DMA_DONE_BIT))\r\nwriteb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nelse\r\nwriteb(PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (dma0_status & PLX_DMA_EN_BIT) {\r\nload_ao_dma(dev, cmd);\r\nif (ao_dma_needs_restart(dev, dma0_status))\r\nrestart_ao_dma(dev);\r\n}\r\n} else {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nif ((status & DAC_DONE_BIT)) {\r\nif ((cmd->stop_src == TRIG_COUNT &&\r\nasync->scans_done >= cmd->stop_arg) ||\r\nlast_ao_dma_load_completed(dev))\r\nasync->events |= COMEDI_CB_EOA;\r\nelse\r\nasync->events |= COMEDI_CB_ERROR;\r\n}\r\ncomedi_handle_events(dev, s);\r\n}\r\nstatic irqreturn_t handle_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned short status;\r\nuint32_t plx_status;\r\nuint32_t plx_bits;\r\nplx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);\r\nstatus = readw(devpriv->main_iobase + HW_STATUS_REG);\r\nif (!dev->attached)\r\nreturn IRQ_HANDLED;\r\nhandle_ai_interrupt(dev, status, plx_status);\r\nhandle_ao_interrupt(dev, status, plx_status);\r\nif (plx_status & ICS_LDIA) {\r\nplx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);\r\nwritel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nif (devpriv->ai_cmd_running == 0) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\ndevpriv->ai_cmd_running = 0;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndisable_ai_pacing(dev);\r\nabort_dma(dev, 1);\r\nreturn 0;\r\n}\r\nstatic int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nint chan = CR_CHAN(insn->chanspec);\r\nint range = CR_RANGE(insn->chanspec);\r\nwritew(0, devpriv->main_iobase + DAC_CONTROL0_REG);\r\nset_dac_range_bits(dev, &devpriv->dac_control1_bits, chan, range);\r\nwritew(devpriv->dac_control1_bits,\r\ndevpriv->main_iobase + DAC_CONTROL1_REG);\r\nif (board->layout == LAYOUT_4020) {\r\nwritew(data[0] & 0xff,\r\ndevpriv->main_iobase + dac_lsb_4020_reg(chan));\r\nwritew((data[0] >> 8) & 0xf,\r\ndevpriv->main_iobase + dac_msb_4020_reg(chan));\r\n} else {\r\nwritew(data[0], devpriv->main_iobase + dac_convert_reg(chan));\r\n}\r\ns->readback[chan] = data[0];\r\nreturn 1;\r\n}\r\nstatic void set_dac_control0_reg(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |\r\nWAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;\r\nif (cmd->start_src == TRIG_EXT) {\r\nbits |= WAVEFORM_TRIG_EXT_BITS;\r\nif (cmd->start_arg & CR_INVERT)\r\nbits |= WAVEFORM_TRIG_FALLING_BIT;\r\n} else {\r\nbits |= WAVEFORM_TRIG_SOFT_BITS;\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nbits |= DAC_EXT_UPDATE_ENABLE_BIT;\r\nif (cmd->scan_begin_arg & CR_INVERT)\r\nbits |= DAC_EXT_UPDATE_FALLING_BIT;\r\n}\r\nwritew(bits, devpriv->main_iobase + DAC_CONTROL0_REG);\r\n}\r\nstatic void set_dac_control1_reg(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nint channel, range;\r\nchannel = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nset_dac_range_bits(dev, &devpriv->dac_control1_bits, channel,\r\nrange);\r\n}\r\ndevpriv->dac_control1_bits |= DAC_SW_GATE_BIT;\r\nwritew(devpriv->dac_control1_bits,\r\ndevpriv->main_iobase + DAC_CONTROL1_REG);\r\n}\r\nstatic void set_dac_select_reg(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nuint16_t bits;\r\nunsigned int first_channel, last_channel;\r\nfirst_channel = CR_CHAN(cmd->chanlist[0]);\r\nlast_channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\r\nif (last_channel < first_channel)\r\ndev_err(dev->class_dev,\r\n"bug! last ao channel < first ao channel\n");\r\nbits = (first_channel & 0x7) | (last_channel & 0x7) << 3;\r\nwritew(bits, devpriv->main_iobase + DAC_SELECT_REG);\r\n}\r\nstatic unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)\r\n{\r\nreturn get_divisor(ns, flags) - 2;\r\n}\r\nstatic void set_dac_interval_regs(struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nunsigned int divisor;\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn;\r\ndivisor = get_ao_divisor(cmd->scan_begin_arg, cmd->flags);\r\nif (divisor > max_counter_value) {\r\ndev_err(dev->class_dev, "bug! ao divisor too big\n");\r\ndivisor = max_counter_value;\r\n}\r\nwritew(divisor & 0xffff,\r\ndevpriv->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);\r\nwritew((divisor >> 16) & 0xff,\r\ndevpriv->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);\r\n}\r\nstatic int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->write_subdev;\r\nunsigned int nsamples;\r\nunsigned int nbytes;\r\nint i;\r\nwritew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);\r\nwritew(0, devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);\r\nnsamples = cb_pcidas64_ao_fill_buffer(dev, s,\r\ndevpriv->ao_bounce_buffer,\r\nDAC_FIFO_SIZE);\r\nif (nsamples == 0)\r\nreturn -1;\r\nfor (i = 0; i < nsamples; i++) {\r\nwritew(devpriv->ao_bounce_buffer[i],\r\ndevpriv->main_iobase + DAC_FIFO_REG);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg)\r\nreturn 0;\r\nnbytes = load_ao_dma_buffer(dev, cmd);\r\nif (nbytes == 0)\r\nreturn -1;\r\nload_ao_dma(dev, cmd);\r\ndma_start_sync(dev, 0);\r\nreturn 0;\r\n}\r\nstatic inline int external_ai_queue_in_use(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nif (s->busy)\r\nreturn 0;\r\nif (board->layout == LAYOUT_4020)\r\nreturn 0;\r\nelse if (use_internal_queue_6xxx(cmd))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint retval;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nretval = prep_ao_dma(dev, cmd);\r\nif (retval < 0)\r\nreturn -EPIPE;\r\nset_dac_control0_reg(dev, cmd);\r\nif (cmd->start_src == TRIG_INT)\r\nwritew(0, devpriv->main_iobase + DAC_START_REG);\r\ns->async->inttrig = NULL;\r\nreturn 0;\r\n}\r\nstatic int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (external_ai_queue_in_use(dev, s, cmd)) {\r\nwarn_external_queue(dev);\r\nreturn -EBUSY;\r\n}\r\nwritew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);\r\ndevpriv->ao_dma_index = 0;\r\nset_dac_select_reg(dev, cmd);\r\nset_dac_interval_regs(dev, cmd);\r\nload_first_dma_descriptor(dev, 0, devpriv->ao_dma_desc_bus_addr |\r\nPLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT);\r\nset_dac_control1_reg(dev, cmd);\r\ns->async->inttrig = ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int cb_pcidas64_ao_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\r\nint i;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (chan != (chan0 + i)) {\r\ndev_dbg(dev->class_dev,\r\n"chanlist must use consecutive channels\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nint err = 0;\r\nunsigned int tmp_arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_TIMER | TRIG_EXT);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nif (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)\r\nerr |= -EINVAL;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\nboard->ao_scan_speed);\r\nif (get_ao_divisor(cmd->scan_begin_arg, cmd->flags) >\r\nmax_counter_value) {\r\ncmd->scan_begin_arg = (max_counter_value + 2) *\r\nTIMER_BASE;\r\nerr |= -EINVAL;\r\n}\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp_arg = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg = get_divisor(cmd->scan_begin_arg,\r\ncmd->flags) * TIMER_BASE;\r\nif (tmp_arg != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 0)\r\nerr |= cb_pcidas64_ao_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nwritew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);\r\nabort_dma(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int dio_callback_4020(struct comedi_device *dev,\r\nint dir, int port, int data, unsigned long iobase)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nif (dir) {\r\nwritew(data, devpriv->main_iobase + iobase + 2 * port);\r\nreturn 0;\r\n}\r\nreturn readw(devpriv->main_iobase + iobase + 2 * port);\r\n}\r\nstatic int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits;\r\nbits = readb(dev->mmio + DI_REG);\r\nbits &= 0xf;\r\ndata[1] = bits;\r\ndata[0] = 0;\r\nreturn insn->n;\r\n}\r\nstatic int do_wbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nwriteb(s->state, dev->mmio + DO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int dio_60xx_config_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nwriteb(s->io_bits, dev->mmio + DIO_DIRECTION_60XX_REG);\r\nreturn insn->n;\r\n}\r\nstatic int dio_60xx_wbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nwriteb(s->state, dev->mmio + DIO_DATA_60XX_REG);\r\ndata[1] = readb(dev->mmio + DIO_DATA_60XX_REG);\r\nreturn insn->n;\r\n}\r\nstatic int caldac_8800_write(struct comedi_device *dev, unsigned int address,\r\nuint8_t value)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstatic const int num_caldac_channels = 8;\r\nstatic const int bitstream_length = 11;\r\nunsigned int bitstream = ((address & 0x7) << 8) | value;\r\nunsigned int bit, register_bits;\r\nstatic const int caldac_8800_udelay = 1;\r\nif (address >= num_caldac_channels) {\r\ndev_err(dev->class_dev, "illegal caldac channel\n");\r\nreturn -1;\r\n}\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nregister_bits = 0;\r\nif (bitstream & bit)\r\nregister_bits |= SERIAL_DATA_IN_BIT;\r\nudelay(caldac_8800_udelay);\r\nwritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\r\nregister_bits |= SERIAL_CLOCK_BIT;\r\nudelay(caldac_8800_udelay);\r\nwritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\r\n}\r\nudelay(caldac_8800_udelay);\r\nwritew(SELECT_8800_BIT, devpriv->main_iobase + CALIBRATION_REG);\r\nudelay(caldac_8800_udelay);\r\nwritew(0, devpriv->main_iobase + CALIBRATION_REG);\r\nudelay(caldac_8800_udelay);\r\nreturn 0;\r\n}\r\nstatic int caldac_i2c_write(struct comedi_device *dev,\r\nunsigned int caldac_channel, unsigned int value)\r\n{\r\nuint8_t serial_bytes[3];\r\nuint8_t i2c_addr;\r\nenum pointer_bits {\r\nOFFSET_0_2 = 0x1,\r\nGAIN_0_2 = 0x2,\r\nOFFSET_1_3 = 0x4,\r\nGAIN_1_3 = 0x8,\r\n};\r\nenum data_bits {\r\nNOT_CLEAR_REGISTERS = 0x20,\r\n};\r\nswitch (caldac_channel) {\r\ncase 0:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_0_2;\r\nbreak;\r\ncase 1:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_1_3;\r\nbreak;\r\ncase 2:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_0_2;\r\nbreak;\r\ncase 3:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = OFFSET_1_3;\r\nbreak;\r\ncase 4:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = GAIN_0_2;\r\nbreak;\r\ncase 5:\r\ni2c_addr = CALDAC0_I2C_ADDR;\r\nserial_bytes[0] = GAIN_1_3;\r\nbreak;\r\ncase 6:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = GAIN_0_2;\r\nbreak;\r\ncase 7:\r\ni2c_addr = CALDAC1_I2C_ADDR;\r\nserial_bytes[0] = GAIN_1_3;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "invalid caldac channel\n");\r\nreturn -1;\r\n}\r\nserial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);\r\nserial_bytes[2] = value & 0xff;\r\ni2c_write(dev, i2c_addr, serial_bytes, 3);\r\nreturn 0;\r\n}\r\nstatic void caldac_write(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nswitch (board->layout) {\r\ncase LAYOUT_60XX:\r\ncase LAYOUT_64XX:\r\ncaldac_8800_write(dev, channel, value);\r\nbreak;\r\ncase LAYOUT_4020:\r\ncaldac_i2c_write(dev, channel, value);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int cb_pcidas64_calib_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\ncaldac_write(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void ad8402_write(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstatic const int bitstream_length = 10;\r\nunsigned int bit, register_bits;\r\nunsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);\r\nstatic const int ad8402_udelay = 1;\r\nregister_bits = SELECT_8402_64XX_BIT;\r\nudelay(ad8402_udelay);\r\nwritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nif (bitstream & bit)\r\nregister_bits |= SERIAL_DATA_IN_BIT;\r\nelse\r\nregister_bits &= ~SERIAL_DATA_IN_BIT;\r\nudelay(ad8402_udelay);\r\nwritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\r\nudelay(ad8402_udelay);\r\nwritew(register_bits | SERIAL_CLOCK_BIT,\r\ndevpriv->main_iobase + CALIBRATION_REG);\r\n}\r\nudelay(ad8402_udelay);\r\nwritew(0, devpriv->main_iobase + CALIBRATION_REG);\r\n}\r\nstatic int cb_pcidas64_ad8402_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nif (insn->n) {\r\nunsigned int val = data[insn->n - 1];\r\nif (s->readback[chan] != val) {\r\nad8402_write(dev, chan, val);\r\ns->readback[chan] = val;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic uint16_t read_eeprom(struct comedi_device *dev, uint8_t address)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstatic const int bitstream_length = 11;\r\nstatic const int read_command = 0x6;\r\nunsigned int bitstream = (read_command << 8) | address;\r\nunsigned int bit;\r\nvoid __iomem * const plx_control_addr =\r\ndevpriv->plx9080_iobase + PLX_CONTROL_REG;\r\nuint16_t value;\r\nstatic const int value_length = 16;\r\nstatic const int eeprom_udelay = 1;\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits &= ~CTL_EE_CLK & ~CTL_EE_CS;\r\ndevpriv->plx_control_bits |= CTL_USERO;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits |= CTL_EE_CS;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\r\nudelay(eeprom_udelay);\r\nif (bitstream & bit)\r\ndevpriv->plx_control_bits |= CTL_EE_W;\r\nelse\r\ndevpriv->plx_control_bits &= ~CTL_EE_W;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits |= CTL_EE_CLK;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits &= ~CTL_EE_CLK;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\n}\r\nvalue = 0;\r\nfor (bit = 1 << (value_length - 1); bit; bit >>= 1) {\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits |= CTL_EE_CLK;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits &= ~CTL_EE_CLK;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nudelay(eeprom_udelay);\r\nif (readl(plx_control_addr) & CTL_EE_R)\r\nvalue |= bit;\r\n}\r\nudelay(eeprom_udelay);\r\ndevpriv->plx_control_bits &= ~CTL_EE_CS;\r\nwritel(devpriv->plx_control_bits, plx_control_addr);\r\nreturn value;\r\n}\r\nstatic int eeprom_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = read_eeprom(dev, CR_CHAN(insn->chanspec));\r\nreturn 1;\r\n}\r\nstatic int setup_subdevices(struct comedi_device *dev)\r\n{\r\nconst struct pcidas64_board *board = dev->board_ptr;\r\nstruct pcidas64_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nint i;\r\nint ret;\r\nret = comedi_alloc_subdevices(dev, 10);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;\r\nif (board->layout == LAYOUT_60XX)\r\ns->subdev_flags |= SDF_COMMON | SDF_DIFF;\r\nelse if (board->layout == LAYOUT_64XX)\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = board->ai_se_chans;\r\ns->len_chanlist = 0x2000;\r\ns->maxdata = (1 << board->ai_bits) - 1;\r\ns->range_table = board->ai_range_table;\r\ns->insn_read = ai_rinsn;\r\ns->insn_config = ai_config_insn;\r\ns->do_cmd = ai_cmd;\r\ns->do_cmdtest = ai_cmdtest;\r\ns->cancel = ai_cancel;\r\nif (board->layout == LAYOUT_4020) {\r\nuint8_t data;\r\ndevpriv->i2c_cal_range_bits = adc_src_4020_bits(4);\r\nfor (i = 0; i < s->n_chan; i++)\r\ndevpriv->i2c_cal_range_bits |= attenuate_bit(i);\r\ndata = devpriv->i2c_cal_range_bits;\r\ni2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->ao_nchan) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE |\r\nSDF_GROUND | SDF_CMD_WRITE;\r\ns->n_chan = board->ao_nchan;\r\ns->maxdata = (1 << board->ao_bits) - 1;\r\ns->range_table = board->ao_range_table;\r\ns->insn_write = ao_winsn;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nif (ao_cmd_is_supported(board)) {\r\ndev->write_subdev = s;\r\ns->do_cmdtest = ao_cmdtest;\r\ns->do_cmd = ao_cmd;\r\ns->len_chanlist = board->ao_nchan;\r\ns->cancel = ao_cancel;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\nif (board->layout == LAYOUT_64XX) {\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = di_rbits;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nif (board->layout == LAYOUT_64XX) {\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = do_wbits;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[4];\r\nif (board->has_8255) {\r\nif (board->layout == LAYOUT_4020) {\r\nret = subdev_8255_init(dev, s, dio_callback_4020,\r\nI8255_4020_REG);\r\n} else {\r\nret = subdev_8255_mm_init(dev, s, NULL,\r\nDIO_8255_OFFSET);\r\n}\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[5];\r\nif (board->layout == LAYOUT_60XX) {\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_config = dio_60xx_config_insn;\r\ns->insn_bits = dio_60xx_wbits;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[6];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 8;\r\nif (board->layout == LAYOUT_4020)\r\ns->maxdata = 0xfff;\r\nelse\r\ns->maxdata = 0xff;\r\ns->insn_write = cb_pcidas64_calib_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ncaldac_write(dev, i, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\ns = &dev->subdevices[7];\r\nif (board->layout == LAYOUT_64XX) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 2;\r\ns->maxdata = 0xff;\r\ns->insn_write = cb_pcidas64_ad8402_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nad8402_write(dev, i, s->maxdata / 2);\r\ns->readback[i] = s->maxdata / 2;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[8];\r\nif (readl(devpriv->plx9080_iobase + PLX_CONTROL_REG) & CTL_EECHK) {\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_INTERNAL;\r\ns->n_chan = 128;\r\ns->maxdata = 0xffff;\r\ns->insn_read = eeprom_read_insn;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[9];\r\ns->type = COMEDI_SUBD_UNUSED;\r\nreturn 0;\r\n}\r\nstatic int auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct pcidas64_board *board = NULL;\r\nstruct pcidas64_private *devpriv;\r\nuint32_t local_range, local_decode;\r\nint retval;\r\nif (context < ARRAY_SIZE(pcidas64_boards))\r\nboard = &pcidas64_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nretval = comedi_pci_enable(dev);\r\nif (retval)\r\nreturn retval;\r\npci_set_master(pcidev);\r\ndev->board_name = board->name;\r\ndevpriv->main_phys_iobase = pci_resource_start(pcidev, 2);\r\ndevpriv->dio_counter_phys_iobase = pci_resource_start(pcidev, 3);\r\ndevpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);\r\ndevpriv->main_iobase = pci_ioremap_bar(pcidev, 2);\r\ndev->mmio = pci_ioremap_bar(pcidev, 3);\r\nif (!devpriv->plx9080_iobase || !devpriv->main_iobase || !dev->mmio) {\r\ndev_warn(dev->class_dev, "failed to remap io memory\n");\r\nreturn -ENOMEM;\r\n}\r\nlocal_range = readl(devpriv->plx9080_iobase + PLX_LAS0RNG_REG) &\r\nLRNG_MEM_MASK;\r\nlocal_decode = readl(devpriv->plx9080_iobase + PLX_LAS0MAP_REG) &\r\nlocal_range & LMAP_MEM_MASK;\r\ndevpriv->local0_iobase = ((uint32_t)devpriv->main_phys_iobase &\r\n~local_range) | local_decode;\r\nlocal_range = readl(devpriv->plx9080_iobase + PLX_LAS1RNG_REG) &\r\nLRNG_MEM_MASK;\r\nlocal_decode = readl(devpriv->plx9080_iobase + PLX_LAS1MAP_REG) &\r\nlocal_range & LMAP_MEM_MASK;\r\ndevpriv->local1_iobase = ((uint32_t)devpriv->dio_counter_phys_iobase &\r\n~local_range) | local_decode;\r\nretval = alloc_and_init_dma_members(dev);\r\nif (retval < 0)\r\nreturn retval;\r\ndevpriv->hw_revision =\r\nhw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));\r\ndev_dbg(dev->class_dev, "stc hardware revision %i\n",\r\ndevpriv->hw_revision);\r\ninit_plx9080(dev);\r\ninit_stc_registers(dev);\r\nretval = request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (retval) {\r\ndev_dbg(dev->class_dev, "unable to allocate irq %u\n",\r\npcidev->irq);\r\nreturn retval;\r\n}\r\ndev->irq = pcidev->irq;\r\ndev_dbg(dev->class_dev, "irq %u\n", dev->irq);\r\nretval = setup_subdevices(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic void detach(struct comedi_device *dev)\r\n{\r\nstruct pcidas64_private *devpriv = dev->private;\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->plx9080_iobase) {\r\ndisable_plx_interrupts(dev);\r\niounmap(devpriv->plx9080_iobase);\r\n}\r\nif (devpriv->main_iobase)\r\niounmap(devpriv->main_iobase);\r\nif (dev->mmio)\r\niounmap(dev->mmio);\r\n}\r\ncomedi_pci_disable(dev);\r\ncb_pcidas64_free_dma(dev);\r\n}\r\nstatic int cb_pcidas64_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &cb_pcidas64_driver,\r\nid->driver_data);\r\n}
