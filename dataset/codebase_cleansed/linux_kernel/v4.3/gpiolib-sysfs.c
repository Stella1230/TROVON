static ssize_t direction_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nssize_t status;\r\nmutex_lock(&data->mutex);\r\ngpiod_get_direction(desc);\r\nstatus = sprintf(buf, "%s\n",\r\ntest_bit(FLAG_IS_OUT, &desc->flags)\r\n? "out" : "in");\r\nmutex_unlock(&data->mutex);\r\nreturn status;\r\n}\r\nstatic ssize_t direction_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nssize_t status;\r\nmutex_lock(&data->mutex);\r\nif (sysfs_streq(buf, "high"))\r\nstatus = gpiod_direction_output_raw(desc, 1);\r\nelse if (sysfs_streq(buf, "out") || sysfs_streq(buf, "low"))\r\nstatus = gpiod_direction_output_raw(desc, 0);\r\nelse if (sysfs_streq(buf, "in"))\r\nstatus = gpiod_direction_input(desc);\r\nelse\r\nstatus = -EINVAL;\r\nmutex_unlock(&data->mutex);\r\nreturn status ? : size;\r\n}\r\nstatic ssize_t value_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nssize_t status;\r\nmutex_lock(&data->mutex);\r\nstatus = sprintf(buf, "%d\n", gpiod_get_value_cansleep(desc));\r\nmutex_unlock(&data->mutex);\r\nreturn status;\r\n}\r\nstatic ssize_t value_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nssize_t status;\r\nmutex_lock(&data->mutex);\r\nif (!test_bit(FLAG_IS_OUT, &desc->flags)) {\r\nstatus = -EPERM;\r\n} else {\r\nlong value;\r\nstatus = kstrtol(buf, 0, &value);\r\nif (status == 0) {\r\ngpiod_set_value_cansleep(desc, value);\r\nstatus = size;\r\n}\r\n}\r\nmutex_unlock(&data->mutex);\r\nreturn status;\r\n}\r\nstatic irqreturn_t gpio_sysfs_irq(int irq, void *priv)\r\n{\r\nstruct gpiod_data *data = priv;\r\nsysfs_notify_dirent(data->value_kn);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gpio_sysfs_request_irq(struct device *dev, unsigned char flags)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nunsigned long irq_flags;\r\nint ret;\r\ndata->irq = gpiod_to_irq(desc);\r\nif (data->irq < 0)\r\nreturn -EIO;\r\ndata->value_kn = sysfs_get_dirent(dev->kobj.sd, "value");\r\nif (!data->value_kn)\r\nreturn -ENODEV;\r\nirq_flags = IRQF_SHARED;\r\nif (flags & GPIO_IRQF_TRIGGER_FALLING)\r\nirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\r\nIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\r\nif (flags & GPIO_IRQF_TRIGGER_RISING)\r\nirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\r\nIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\r\nret = gpiochip_lock_as_irq(desc->chip, gpio_chip_hwgpio(desc));\r\nif (ret < 0)\r\ngoto err_put_kn;\r\nret = request_any_context_irq(data->irq, gpio_sysfs_irq, irq_flags,\r\n"gpiolib", data);\r\nif (ret < 0)\r\ngoto err_unlock;\r\ndata->irq_flags = flags;\r\nreturn 0;\r\nerr_unlock:\r\ngpiochip_unlock_as_irq(desc->chip, gpio_chip_hwgpio(desc));\r\nerr_put_kn:\r\nsysfs_put(data->value_kn);\r\nreturn ret;\r\n}\r\nstatic void gpio_sysfs_free_irq(struct device *dev)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\ndata->irq_flags = 0;\r\nfree_irq(data->irq, data);\r\ngpiochip_unlock_as_irq(desc->chip, gpio_chip_hwgpio(desc));\r\nsysfs_put(data->value_kn);\r\n}\r\nstatic ssize_t edge_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nssize_t status = 0;\r\nint i;\r\nmutex_lock(&data->mutex);\r\nfor (i = 0; i < ARRAY_SIZE(trigger_types); i++) {\r\nif (data->irq_flags == trigger_types[i].flags) {\r\nstatus = sprintf(buf, "%s\n", trigger_types[i].name);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&data->mutex);\r\nreturn status;\r\n}\r\nstatic ssize_t edge_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nunsigned char flags;\r\nssize_t status = size;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(trigger_types); i++) {\r\nif (sysfs_streq(trigger_types[i].name, buf))\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(trigger_types))\r\nreturn -EINVAL;\r\nflags = trigger_types[i].flags;\r\nmutex_lock(&data->mutex);\r\nif (flags == data->irq_flags) {\r\nstatus = size;\r\ngoto out_unlock;\r\n}\r\nif (data->irq_flags)\r\ngpio_sysfs_free_irq(dev);\r\nif (flags) {\r\nstatus = gpio_sysfs_request_irq(dev, flags);\r\nif (!status)\r\nstatus = size;\r\n}\r\nout_unlock:\r\nmutex_unlock(&data->mutex);\r\nreturn status;\r\n}\r\nstatic int gpio_sysfs_set_active_low(struct device *dev, int value)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nint status = 0;\r\nunsigned int flags = data->irq_flags;\r\nif (!!test_bit(FLAG_ACTIVE_LOW, &desc->flags) == !!value)\r\nreturn 0;\r\nif (value)\r\nset_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nelse\r\nclear_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nif (flags == GPIO_IRQF_TRIGGER_FALLING ||\r\nflags == GPIO_IRQF_TRIGGER_RISING) {\r\ngpio_sysfs_free_irq(dev);\r\nstatus = gpio_sysfs_request_irq(dev, flags);\r\n}\r\nreturn status;\r\n}\r\nstatic ssize_t active_low_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\nssize_t status;\r\nmutex_lock(&data->mutex);\r\nstatus = sprintf(buf, "%d\n",\r\n!!test_bit(FLAG_ACTIVE_LOW, &desc->flags));\r\nmutex_unlock(&data->mutex);\r\nreturn status;\r\n}\r\nstatic ssize_t active_low_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nssize_t status;\r\nlong value;\r\nmutex_lock(&data->mutex);\r\nstatus = kstrtol(buf, 0, &value);\r\nif (status == 0)\r\nstatus = gpio_sysfs_set_active_low(dev, value);\r\nmutex_unlock(&data->mutex);\r\nreturn status ? : size;\r\n}\r\nstatic umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,\r\nint n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nstruct gpio_desc *desc = data->desc;\r\numode_t mode = attr->mode;\r\nbool show_direction = data->direction_can_change;\r\nif (attr == &dev_attr_direction.attr) {\r\nif (!show_direction)\r\nmode = 0;\r\n} else if (attr == &dev_attr_edge.attr) {\r\nif (gpiod_to_irq(desc) < 0)\r\nmode = 0;\r\nif (!show_direction && test_bit(FLAG_IS_OUT, &desc->flags))\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic ssize_t base_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->base);\r\n}\r\nstatic ssize_t label_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", chip->label ? : "");\r\n}\r\nstatic ssize_t ngpio_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", chip->ngpio);\r\n}\r\nstatic ssize_t export_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nlong gpio;\r\nstruct gpio_desc *desc;\r\nint status;\r\nstatus = kstrtol(buf, 0, &gpio);\r\nif (status < 0)\r\ngoto done;\r\ndesc = gpio_to_desc(gpio);\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO %ld\n", __func__, gpio);\r\nreturn -EINVAL;\r\n}\r\nstatus = gpiod_request(desc, "sysfs");\r\nif (status < 0) {\r\nif (status == -EPROBE_DEFER)\r\nstatus = -ENODEV;\r\ngoto done;\r\n}\r\nstatus = gpiod_export(desc, true);\r\nif (status < 0)\r\ngpiod_free(desc);\r\nelse\r\nset_bit(FLAG_SYSFS, &desc->flags);\r\ndone:\r\nif (status)\r\npr_debug("%s: status %d\n", __func__, status);\r\nreturn status ? : len;\r\n}\r\nstatic ssize_t unexport_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nlong gpio;\r\nstruct gpio_desc *desc;\r\nint status;\r\nstatus = kstrtol(buf, 0, &gpio);\r\nif (status < 0)\r\ngoto done;\r\ndesc = gpio_to_desc(gpio);\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO %ld\n", __func__, gpio);\r\nreturn -EINVAL;\r\n}\r\nstatus = -EINVAL;\r\nif (test_and_clear_bit(FLAG_SYSFS, &desc->flags)) {\r\nstatus = 0;\r\ngpiod_free(desc);\r\n}\r\ndone:\r\nif (status)\r\npr_debug("%s: status %d\n", __func__, status);\r\nreturn status ? : len;\r\n}\r\nint gpiod_export(struct gpio_desc *desc, bool direction_may_change)\r\n{\r\nstruct gpio_chip *chip;\r\nstruct gpiod_data *data;\r\nunsigned long flags;\r\nint status;\r\nconst char *ioname = NULL;\r\nstruct device *dev;\r\nint offset;\r\nif (!gpio_class.p) {\r\npr_debug("%s: called too early!\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nif (!desc) {\r\npr_debug("%s: invalid gpio descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nchip = desc->chip;\r\nmutex_lock(&sysfs_lock);\r\nif (!chip || !chip->cdev) {\r\nstatus = -ENODEV;\r\ngoto err_unlock;\r\n}\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (!test_bit(FLAG_REQUESTED, &desc->flags) ||\r\ntest_bit(FLAG_EXPORT, &desc->flags)) {\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\ngpiod_dbg(desc, "%s: unavailable (requested=%d, exported=%d)\n",\r\n__func__,\r\ntest_bit(FLAG_REQUESTED, &desc->flags),\r\ntest_bit(FLAG_EXPORT, &desc->flags));\r\nstatus = -EPERM;\r\ngoto err_unlock;\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nstatus = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\ndata->desc = desc;\r\nmutex_init(&data->mutex);\r\nif (chip->direction_input && chip->direction_output)\r\ndata->direction_can_change = direction_may_change;\r\nelse\r\ndata->direction_can_change = false;\r\noffset = gpio_chip_hwgpio(desc);\r\nif (chip->names && chip->names[offset])\r\nioname = chip->names[offset];\r\ndev = device_create_with_groups(&gpio_class, chip->dev,\r\nMKDEV(0, 0), data, gpio_groups,\r\nioname ? ioname : "gpio%u",\r\ndesc_to_gpio(desc));\r\nif (IS_ERR(dev)) {\r\nstatus = PTR_ERR(dev);\r\ngoto err_free_data;\r\n}\r\nset_bit(FLAG_EXPORT, &desc->flags);\r\nmutex_unlock(&sysfs_lock);\r\nreturn 0;\r\nerr_free_data:\r\nkfree(data);\r\nerr_unlock:\r\nmutex_unlock(&sysfs_lock);\r\ngpiod_dbg(desc, "%s: status %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic int match_export(struct device *dev, const void *desc)\r\n{\r\nstruct gpiod_data *data = dev_get_drvdata(dev);\r\nreturn data->desc == desc;\r\n}\r\nint gpiod_export_link(struct device *dev, const char *name,\r\nstruct gpio_desc *desc)\r\n{\r\nstruct device *cdev;\r\nint ret;\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncdev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (!cdev)\r\nreturn -ENODEV;\r\nret = sysfs_create_link(&dev->kobj, &cdev->kobj, name);\r\nput_device(cdev);\r\nreturn ret;\r\n}\r\nvoid gpiod_unexport(struct gpio_desc *desc)\r\n{\r\nstruct gpiod_data *data;\r\nstruct device *dev;\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO\n", __func__);\r\nreturn;\r\n}\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\ngoto err_unlock;\r\ndev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (!dev)\r\ngoto err_unlock;\r\ndata = dev_get_drvdata(dev);\r\nclear_bit(FLAG_EXPORT, &desc->flags);\r\ndevice_unregister(dev);\r\nif (data->irq_flags)\r\ngpio_sysfs_free_irq(dev);\r\nmutex_unlock(&sysfs_lock);\r\nput_device(dev);\r\nkfree(data);\r\nreturn;\r\nerr_unlock:\r\nmutex_unlock(&sysfs_lock);\r\n}\r\nint gpiochip_sysfs_register(struct gpio_chip *chip)\r\n{\r\nstruct device *dev;\r\nif (!gpio_class.p)\r\nreturn 0;\r\ndev = device_create_with_groups(&gpio_class, chip->dev, MKDEV(0, 0),\r\nchip, gpiochip_groups,\r\n"gpiochip%d", chip->base);\r\nif (IS_ERR(dev))\r\nreturn PTR_ERR(dev);\r\nmutex_lock(&sysfs_lock);\r\nchip->cdev = dev;\r\nmutex_unlock(&sysfs_lock);\r\nreturn 0;\r\n}\r\nvoid gpiochip_sysfs_unregister(struct gpio_chip *chip)\r\n{\r\nstruct gpio_desc *desc;\r\nunsigned int i;\r\nif (!chip->cdev)\r\nreturn;\r\ndevice_unregister(chip->cdev);\r\nmutex_lock(&sysfs_lock);\r\nchip->cdev = NULL;\r\nmutex_unlock(&sysfs_lock);\r\nfor (i = 0; i < chip->ngpio; i++) {\r\ndesc = &chip->desc[i];\r\nif (test_and_clear_bit(FLAG_SYSFS, &desc->flags))\r\ngpiod_free(desc);\r\n}\r\n}\r\nstatic int __init gpiolib_sysfs_init(void)\r\n{\r\nint status;\r\nunsigned long flags;\r\nstruct gpio_chip *chip;\r\nstatus = class_register(&gpio_class);\r\nif (status < 0)\r\nreturn status;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nlist_for_each_entry(chip, &gpio_chips, list) {\r\nif (chip->cdev)\r\ncontinue;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nstatus = gpiochip_sysfs_register(chip);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn status;\r\n}
