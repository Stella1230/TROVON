static void usb_dmac_write(struct usb_dmac *dmac, u32 reg, u32 data)\r\n{\r\nwritel(data, dmac->iomem + reg);\r\n}\r\nstatic u32 usb_dmac_read(struct usb_dmac *dmac, u32 reg)\r\n{\r\nreturn readl(dmac->iomem + reg);\r\n}\r\nstatic u32 usb_dmac_chan_read(struct usb_dmac_chan *chan, u32 reg)\r\n{\r\nreturn readl(chan->iomem + reg);\r\n}\r\nstatic void usb_dmac_chan_write(struct usb_dmac_chan *chan, u32 reg, u32 data)\r\n{\r\nwritel(data, chan->iomem + reg);\r\n}\r\nstatic bool usb_dmac_chan_is_busy(struct usb_dmac_chan *chan)\r\n{\r\nu32 chcr = usb_dmac_chan_read(chan, USB_DMACHCR);\r\nreturn (chcr & (USB_DMACHCR_DE | USB_DMACHCR_TE)) == USB_DMACHCR_DE;\r\n}\r\nstatic u32 usb_dmac_calc_tend(u32 size)\r\n{\r\nreturn 0xffffffff << (32 - (size % USB_DMAC_XFER_SIZE ? :\r\nUSB_DMAC_XFER_SIZE));\r\n}\r\nstatic void usb_dmac_chan_start_sg(struct usb_dmac_chan *chan,\r\nunsigned int index)\r\n{\r\nstruct usb_dmac_desc *desc = chan->desc;\r\nstruct usb_dmac_sg *sg = desc->sg + index;\r\ndma_addr_t src_addr = 0, dst_addr = 0;\r\nWARN_ON_ONCE(usb_dmac_chan_is_busy(chan));\r\nif (desc->direction == DMA_DEV_TO_MEM)\r\ndst_addr = sg->mem_addr;\r\nelse\r\nsrc_addr = sg->mem_addr;\r\ndev_dbg(chan->vc.chan.device->dev,\r\n"chan%u: queue sg %p: %u@%pad -> %pad\n",\r\nchan->index, sg, sg->size, &src_addr, &dst_addr);\r\nusb_dmac_chan_write(chan, USB_DMASAR, src_addr & 0xffffffff);\r\nusb_dmac_chan_write(chan, USB_DMADAR, dst_addr & 0xffffffff);\r\nusb_dmac_chan_write(chan, USB_DMATCR,\r\nDIV_ROUND_UP(sg->size, USB_DMAC_XFER_SIZE));\r\nusb_dmac_chan_write(chan, USB_DMATEND, usb_dmac_calc_tend(sg->size));\r\nusb_dmac_chan_write(chan, USB_DMACHCR, USB_DMAC_CHCR_TS |\r\nUSB_DMACHCR_NULLE | USB_DMACHCR_IE | USB_DMACHCR_DE);\r\n}\r\nstatic void usb_dmac_chan_start_desc(struct usb_dmac_chan *chan)\r\n{\r\nstruct virt_dma_desc *vd;\r\nvd = vchan_next_desc(&chan->vc);\r\nif (!vd) {\r\nchan->desc = NULL;\r\nreturn;\r\n}\r\nlist_del(&vd->node);\r\nchan->desc = to_usb_dmac_desc(vd);\r\nchan->desc->sg_index = 0;\r\nusb_dmac_chan_start_sg(chan, 0);\r\n}\r\nstatic int usb_dmac_init(struct usb_dmac *dmac)\r\n{\r\nu16 dmaor;\r\nusb_dmac_write(dmac, USB_DMAOR, USB_DMAOR_DME);\r\ndmaor = usb_dmac_read(dmac, USB_DMAOR);\r\nif ((dmaor & (USB_DMAOR_AE | USB_DMAOR_DME)) != USB_DMAOR_DME) {\r\ndev_warn(dmac->dev, "DMAOR initialization failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_dmac_desc_alloc(struct usb_dmac_chan *chan, unsigned int sg_len,\r\ngfp_t gfp)\r\n{\r\nstruct usb_dmac_desc *desc;\r\nunsigned long flags;\r\ndesc = kzalloc(sizeof(*desc) + sg_len * sizeof(desc->sg[0]), gfp);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndesc->sg_allocated_len = sg_len;\r\nINIT_LIST_HEAD(&desc->node);\r\nspin_lock_irqsave(&chan->vc.lock, flags);\r\nlist_add_tail(&desc->node, &chan->desc_freed);\r\nspin_unlock_irqrestore(&chan->vc.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void usb_dmac_desc_free(struct usb_dmac_chan *chan)\r\n{\r\nstruct usb_dmac_desc *desc, *_desc;\r\nLIST_HEAD(list);\r\nlist_splice_init(&chan->desc_freed, &list);\r\nlist_splice_init(&chan->desc_got, &list);\r\nlist_for_each_entry_safe(desc, _desc, &list, node) {\r\nlist_del(&desc->node);\r\nkfree(desc);\r\n}\r\nchan->descs_allocated = 0;\r\n}\r\nstatic struct usb_dmac_desc *usb_dmac_desc_get(struct usb_dmac_chan *chan,\r\nunsigned int sg_len, gfp_t gfp)\r\n{\r\nstruct usb_dmac_desc *desc = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chan->vc.lock, flags);\r\nlist_for_each_entry(desc, &chan->desc_freed, node) {\r\nif (sg_len <= desc->sg_allocated_len) {\r\nlist_move_tail(&desc->node, &chan->desc_got);\r\nspin_unlock_irqrestore(&chan->vc.lock, flags);\r\nreturn desc;\r\n}\r\n}\r\nspin_unlock_irqrestore(&chan->vc.lock, flags);\r\nif (!usb_dmac_desc_alloc(chan, sg_len, gfp)) {\r\nspin_lock_irqsave(&chan->vc.lock, flags);\r\ndesc = list_last_entry(&chan->desc_freed, struct usb_dmac_desc,\r\nnode);\r\nlist_move_tail(&desc->node, &chan->desc_got);\r\nspin_unlock_irqrestore(&chan->vc.lock, flags);\r\nreturn desc;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void usb_dmac_desc_put(struct usb_dmac_chan *chan,\r\nstruct usb_dmac_desc *desc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chan->vc.lock, flags);\r\nlist_move_tail(&desc->node, &chan->desc_freed);\r\nspin_unlock_irqrestore(&chan->vc.lock, flags);\r\n}\r\nstatic void usb_dmac_soft_reset(struct usb_dmac_chan *uchan)\r\n{\r\nstruct dma_chan *chan = &uchan->vc.chan;\r\nstruct usb_dmac *dmac = to_usb_dmac(chan->device);\r\nint i;\r\nfor (i = 0; i < dmac->n_channels; ++i) {\r\nif (usb_dmac_chan_is_busy(uchan))\r\nreturn;\r\n}\r\nusb_dmac_write(dmac, USB_DMAOR, 0);\r\nusb_dmac_write(dmac, USB_DMASWR, USB_DMASWR_SWR);\r\nudelay(100);\r\nusb_dmac_write(dmac, USB_DMASWR, 0);\r\nusb_dmac_write(dmac, USB_DMAOR, 1);\r\n}\r\nstatic void usb_dmac_chan_halt(struct usb_dmac_chan *chan)\r\n{\r\nu32 chcr = usb_dmac_chan_read(chan, USB_DMACHCR);\r\nchcr &= ~(USB_DMACHCR_IE | USB_DMACHCR_TE | USB_DMACHCR_DE);\r\nusb_dmac_chan_write(chan, USB_DMACHCR, chcr);\r\nusb_dmac_soft_reset(chan);\r\n}\r\nstatic void usb_dmac_stop(struct usb_dmac *dmac)\r\n{\r\nusb_dmac_write(dmac, USB_DMAOR, 0);\r\n}\r\nstatic int usb_dmac_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nint ret;\r\nwhile (uchan->descs_allocated < USB_DMAC_INITIAL_NR_DESC) {\r\nret = usb_dmac_desc_alloc(uchan, USB_DMAC_INITIAL_NR_SG,\r\nGFP_KERNEL);\r\nif (ret < 0) {\r\nusb_dmac_desc_free(uchan);\r\nreturn ret;\r\n}\r\nuchan->descs_allocated++;\r\n}\r\nreturn pm_runtime_get_sync(chan->device->dev);\r\n}\r\nstatic void usb_dmac_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&uchan->vc.lock, flags);\r\nusb_dmac_chan_halt(uchan);\r\nspin_unlock_irqrestore(&uchan->vc.lock, flags);\r\nusb_dmac_desc_free(uchan);\r\nvchan_free_chan_resources(&uchan->vc);\r\npm_runtime_put(chan->device->dev);\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\nusb_dmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction dir,\r\nunsigned long dma_flags, void *context)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nstruct usb_dmac_desc *desc;\r\nstruct scatterlist *sg;\r\nint i;\r\nif (!sg_len) {\r\ndev_warn(chan->device->dev,\r\n"%s: bad parameter: len=%d\n", __func__, sg_len);\r\nreturn NULL;\r\n}\r\ndesc = usb_dmac_desc_get(uchan, sg_len, GFP_NOWAIT);\r\nif (!desc)\r\nreturn NULL;\r\ndesc->direction = dir;\r\ndesc->sg_len = sg_len;\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\ndesc->sg[i].mem_addr = sg_dma_address(sg);\r\ndesc->sg[i].size = sg_dma_len(sg);\r\n}\r\nreturn vchan_tx_prep(&uchan->vc, &desc->vd, dma_flags);\r\n}\r\nstatic int usb_dmac_chan_terminate_all(struct dma_chan *chan)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nstruct usb_dmac_desc *desc;\r\nunsigned long flags;\r\nLIST_HEAD(head);\r\nLIST_HEAD(list);\r\nspin_lock_irqsave(&uchan->vc.lock, flags);\r\nusb_dmac_chan_halt(uchan);\r\nvchan_get_all_descriptors(&uchan->vc, &head);\r\nif (uchan->desc)\r\nuchan->desc = NULL;\r\nlist_splice_init(&uchan->desc_got, &list);\r\nlist_for_each_entry(desc, &list, node)\r\nlist_move_tail(&desc->node, &uchan->desc_freed);\r\nspin_unlock_irqrestore(&uchan->vc.lock, flags);\r\nvchan_dma_desc_free_list(&uchan->vc, &head);\r\nreturn 0;\r\n}\r\nstatic unsigned int usb_dmac_get_current_residue(struct usb_dmac_chan *chan,\r\nstruct usb_dmac_desc *desc,\r\nint sg_index)\r\n{\r\nstruct usb_dmac_sg *sg = desc->sg + sg_index;\r\nu32 mem_addr = sg->mem_addr & 0xffffffff;\r\nunsigned int residue = sg->size;\r\nif (desc->direction == DMA_DEV_TO_MEM)\r\nresidue -= usb_dmac_chan_read(chan, USB_DMADAR) - mem_addr;\r\nelse\r\nresidue -= usb_dmac_chan_read(chan, USB_DMASAR) - mem_addr;\r\nreturn residue;\r\n}\r\nstatic u32 usb_dmac_chan_get_residue_if_complete(struct usb_dmac_chan *chan,\r\ndma_cookie_t cookie)\r\n{\r\nstruct usb_dmac_desc *desc;\r\nu32 residue = 0;\r\nlist_for_each_entry_reverse(desc, &chan->desc_freed, node) {\r\nif (desc->done_cookie == cookie) {\r\nresidue = desc->residue;\r\nbreak;\r\n}\r\n}\r\nreturn residue;\r\n}\r\nstatic u32 usb_dmac_chan_get_residue(struct usb_dmac_chan *chan,\r\ndma_cookie_t cookie)\r\n{\r\nu32 residue = 0;\r\nstruct virt_dma_desc *vd;\r\nstruct usb_dmac_desc *desc = chan->desc;\r\nint i;\r\nif (!desc) {\r\nvd = vchan_find_desc(&chan->vc, cookie);\r\nif (!vd)\r\nreturn 0;\r\ndesc = to_usb_dmac_desc(vd);\r\n}\r\nfor (i = desc->sg_index + 1; i < desc->sg_len; i++)\r\nresidue += desc->sg[i].size;\r\nresidue += usb_dmac_get_current_residue(chan, desc, desc->sg_index);\r\nreturn residue;\r\n}\r\nstatic enum dma_status usb_dmac_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nenum dma_status status;\r\nunsigned int residue = 0;\r\nunsigned long flags;\r\nstatus = dma_cookie_status(chan, cookie, txstate);\r\nif (!txstate)\r\nreturn status;\r\nspin_lock_irqsave(&uchan->vc.lock, flags);\r\nif (status == DMA_COMPLETE)\r\nresidue = usb_dmac_chan_get_residue_if_complete(uchan, cookie);\r\nelse\r\nresidue = usb_dmac_chan_get_residue(uchan, cookie);\r\nspin_unlock_irqrestore(&uchan->vc.lock, flags);\r\ndma_set_residue(txstate, residue);\r\nreturn status;\r\n}\r\nstatic void usb_dmac_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&uchan->vc.lock, flags);\r\nif (vchan_issue_pending(&uchan->vc) && !uchan->desc)\r\nusb_dmac_chan_start_desc(uchan);\r\nspin_unlock_irqrestore(&uchan->vc.lock, flags);\r\n}\r\nstatic void usb_dmac_virt_desc_free(struct virt_dma_desc *vd)\r\n{\r\nstruct usb_dmac_desc *desc = to_usb_dmac_desc(vd);\r\nstruct usb_dmac_chan *chan = to_usb_dmac_chan(vd->tx.chan);\r\nusb_dmac_desc_put(chan, desc);\r\n}\r\nstatic void usb_dmac_isr_transfer_end(struct usb_dmac_chan *chan)\r\n{\r\nstruct usb_dmac_desc *desc = chan->desc;\r\nBUG_ON(!desc);\r\nif (++desc->sg_index < desc->sg_len) {\r\nusb_dmac_chan_start_sg(chan, desc->sg_index);\r\n} else {\r\ndesc->residue = usb_dmac_get_current_residue(chan, desc,\r\ndesc->sg_index - 1);\r\ndesc->done_cookie = desc->vd.tx.cookie;\r\nvchan_cookie_complete(&desc->vd);\r\nusb_dmac_chan_start_desc(chan);\r\n}\r\n}\r\nstatic irqreturn_t usb_dmac_isr_channel(int irq, void *dev)\r\n{\r\nstruct usb_dmac_chan *chan = dev;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 mask = USB_DMACHCR_TE;\r\nu32 check_bits = USB_DMACHCR_TE | USB_DMACHCR_SP;\r\nu32 chcr;\r\nspin_lock(&chan->vc.lock);\r\nchcr = usb_dmac_chan_read(chan, USB_DMACHCR);\r\nif (chcr & check_bits)\r\nmask |= USB_DMACHCR_DE | check_bits;\r\nif (chcr & USB_DMACHCR_NULL) {\r\nmask |= USB_DMACHCR_NULL;\r\nchcr |= USB_DMACHCR_FTE;\r\nret |= IRQ_HANDLED;\r\n}\r\nusb_dmac_chan_write(chan, USB_DMACHCR, chcr & ~mask);\r\nif (chcr & check_bits) {\r\nusb_dmac_isr_transfer_end(chan);\r\nret |= IRQ_HANDLED;\r\n}\r\nspin_unlock(&chan->vc.lock);\r\nreturn ret;\r\n}\r\nstatic bool usb_dmac_chan_filter(struct dma_chan *chan, void *arg)\r\n{\r\nstruct usb_dmac_chan *uchan = to_usb_dmac_chan(chan);\r\nstruct of_phandle_args *dma_spec = arg;\r\nif (dma_spec->np != chan->device->dev->of_node)\r\nreturn false;\r\nif (uchan->index != dma_spec->args[0])\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct dma_chan *usb_dmac_of_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct usb_dmac_chan *uchan;\r\nstruct dma_chan *chan;\r\ndma_cap_mask_t mask;\r\nif (dma_spec->args_count != 1)\r\nreturn NULL;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchan = dma_request_channel(mask, usb_dmac_chan_filter, dma_spec);\r\nif (!chan)\r\nreturn NULL;\r\nuchan = to_usb_dmac_chan(chan);\r\nreturn chan;\r\n}\r\nstatic int usb_dmac_runtime_suspend(struct device *dev)\r\n{\r\nstruct usb_dmac *dmac = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < dmac->n_channels; ++i)\r\nusb_dmac_chan_halt(&dmac->channels[i]);\r\nreturn 0;\r\n}\r\nstatic int usb_dmac_runtime_resume(struct device *dev)\r\n{\r\nstruct usb_dmac *dmac = dev_get_drvdata(dev);\r\nreturn usb_dmac_init(dmac);\r\n}\r\nstatic int usb_dmac_chan_probe(struct usb_dmac *dmac,\r\nstruct usb_dmac_chan *uchan,\r\nunsigned int index)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dmac->dev);\r\nchar pdev_irqname[5];\r\nchar *irqname;\r\nint ret;\r\nuchan->index = index;\r\nuchan->iomem = dmac->iomem + USB_DMAC_CHAN_OFFSET(index);\r\nsprintf(pdev_irqname, "ch%u", index);\r\nuchan->irq = platform_get_irq_byname(pdev, pdev_irqname);\r\nif (uchan->irq < 0) {\r\ndev_err(dmac->dev, "no IRQ specified for channel %u\n", index);\r\nreturn -ENODEV;\r\n}\r\nirqname = devm_kasprintf(dmac->dev, GFP_KERNEL, "%s:%u",\r\ndev_name(dmac->dev), index);\r\nif (!irqname)\r\nreturn -ENOMEM;\r\nret = devm_request_irq(dmac->dev, uchan->irq, usb_dmac_isr_channel,\r\nIRQF_SHARED, irqname, uchan);\r\nif (ret) {\r\ndev_err(dmac->dev, "failed to request IRQ %u (%d)\n",\r\nuchan->irq, ret);\r\nreturn ret;\r\n}\r\nuchan->vc.desc_free = usb_dmac_virt_desc_free;\r\nvchan_init(&uchan->vc, &dmac->engine);\r\nINIT_LIST_HEAD(&uchan->desc_freed);\r\nINIT_LIST_HEAD(&uchan->desc_got);\r\nreturn 0;\r\n}\r\nstatic int usb_dmac_parse_of(struct device *dev, struct usb_dmac *dmac)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\nret = of_property_read_u32(np, "dma-channels", &dmac->n_channels);\r\nif (ret < 0) {\r\ndev_err(dev, "unable to read dma-channels property\n");\r\nreturn ret;\r\n}\r\nif (dmac->n_channels <= 0 || dmac->n_channels >= 100) {\r\ndev_err(dev, "invalid number of channels %u\n",\r\ndmac->n_channels);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usb_dmac_probe(struct platform_device *pdev)\r\n{\r\nconst enum dma_slave_buswidth widths = USB_DMAC_SLAVE_BUSWIDTH;\r\nstruct dma_device *engine;\r\nstruct usb_dmac *dmac;\r\nstruct resource *mem;\r\nunsigned int i;\r\nint ret;\r\ndmac = devm_kzalloc(&pdev->dev, sizeof(*dmac), GFP_KERNEL);\r\nif (!dmac)\r\nreturn -ENOMEM;\r\ndmac->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, dmac);\r\nret = usb_dmac_parse_of(&pdev->dev, dmac);\r\nif (ret < 0)\r\nreturn ret;\r\ndmac->channels = devm_kcalloc(&pdev->dev, dmac->n_channels,\r\nsizeof(*dmac->channels), GFP_KERNEL);\r\nif (!dmac->channels)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndmac->iomem = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(dmac->iomem))\r\nreturn PTR_ERR(dmac->iomem);\r\npm_runtime_enable(&pdev->dev);\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "runtime PM get sync failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = usb_dmac_init(dmac);\r\npm_runtime_put(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to reset device\n");\r\ngoto error;\r\n}\r\nINIT_LIST_HEAD(&dmac->engine.channels);\r\nfor (i = 0; i < dmac->n_channels; ++i) {\r\nret = usb_dmac_chan_probe(dmac, &dmac->channels[i], i);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nret = of_dma_controller_register(pdev->dev.of_node, usb_dmac_of_xlate,\r\nNULL);\r\nif (ret < 0)\r\ngoto error;\r\nengine = &dmac->engine;\r\ndma_cap_set(DMA_SLAVE, engine->cap_mask);\r\nengine->dev = &pdev->dev;\r\nengine->src_addr_widths = widths;\r\nengine->dst_addr_widths = widths;\r\nengine->directions = BIT(DMA_MEM_TO_DEV) | BIT(DMA_DEV_TO_MEM);\r\nengine->residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\r\nengine->device_alloc_chan_resources = usb_dmac_alloc_chan_resources;\r\nengine->device_free_chan_resources = usb_dmac_free_chan_resources;\r\nengine->device_prep_slave_sg = usb_dmac_prep_slave_sg;\r\nengine->device_terminate_all = usb_dmac_chan_terminate_all;\r\nengine->device_tx_status = usb_dmac_tx_status;\r\nengine->device_issue_pending = usb_dmac_issue_pending;\r\nret = dma_async_device_register(engine);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nof_dma_controller_free(pdev->dev.of_node);\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic void usb_dmac_chan_remove(struct usb_dmac *dmac,\r\nstruct usb_dmac_chan *uchan)\r\n{\r\nusb_dmac_chan_halt(uchan);\r\ndevm_free_irq(dmac->dev, uchan->irq, uchan);\r\n}\r\nstatic int usb_dmac_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_dmac *dmac = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < dmac->n_channels; ++i)\r\nusb_dmac_chan_remove(dmac, &dmac->channels[i]);\r\nof_dma_controller_free(pdev->dev.of_node);\r\ndma_async_device_unregister(&dmac->engine);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void usb_dmac_shutdown(struct platform_device *pdev)\r\n{\r\nstruct usb_dmac *dmac = platform_get_drvdata(pdev);\r\nusb_dmac_stop(dmac);\r\n}
