static struct wm_adsp_buf *wm_adsp_buf_alloc(const void *src, size_t len,\r\nstruct list_head *list)\r\n{\r\nstruct wm_adsp_buf *buf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn NULL;\r\nbuf->buf = vmalloc(len);\r\nif (!buf->buf) {\r\nvfree(buf);\r\nreturn NULL;\r\n}\r\nmemcpy(buf->buf, src, len);\r\nif (list)\r\nlist_add_tail(&buf->list, list);\r\nreturn buf;\r\n}\r\nstatic void wm_adsp_buf_free(struct list_head *list)\r\n{\r\nwhile (!list_empty(list)) {\r\nstruct wm_adsp_buf *buf = list_first_entry(list,\r\nstruct wm_adsp_buf,\r\nlist);\r\nlist_del(&buf->list);\r\nvfree(buf->buf);\r\nkfree(buf);\r\n}\r\n}\r\nstatic void wm_adsp_debugfs_save_wmfwname(struct wm_adsp *dsp, const char *s)\r\n{\r\nchar *tmp = kasprintf(GFP_KERNEL, "%s\n", s);\r\nmutex_lock(&dsp->debugfs_lock);\r\nkfree(dsp->wmfw_file_name);\r\ndsp->wmfw_file_name = tmp;\r\nmutex_unlock(&dsp->debugfs_lock);\r\n}\r\nstatic void wm_adsp_debugfs_save_binname(struct wm_adsp *dsp, const char *s)\r\n{\r\nchar *tmp = kasprintf(GFP_KERNEL, "%s\n", s);\r\nmutex_lock(&dsp->debugfs_lock);\r\nkfree(dsp->bin_file_name);\r\ndsp->bin_file_name = tmp;\r\nmutex_unlock(&dsp->debugfs_lock);\r\n}\r\nstatic void wm_adsp_debugfs_clear(struct wm_adsp *dsp)\r\n{\r\nmutex_lock(&dsp->debugfs_lock);\r\nkfree(dsp->wmfw_file_name);\r\nkfree(dsp->bin_file_name);\r\ndsp->wmfw_file_name = NULL;\r\ndsp->bin_file_name = NULL;\r\nmutex_unlock(&dsp->debugfs_lock);\r\n}\r\nstatic ssize_t wm_adsp_debugfs_wmfw_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct wm_adsp *dsp = file->private_data;\r\nssize_t ret;\r\nmutex_lock(&dsp->debugfs_lock);\r\nif (!dsp->wmfw_file_name || !dsp->running)\r\nret = 0;\r\nelse\r\nret = simple_read_from_buffer(user_buf, count, ppos,\r\ndsp->wmfw_file_name,\r\nstrlen(dsp->wmfw_file_name));\r\nmutex_unlock(&dsp->debugfs_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t wm_adsp_debugfs_bin_read(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct wm_adsp *dsp = file->private_data;\r\nssize_t ret;\r\nmutex_lock(&dsp->debugfs_lock);\r\nif (!dsp->bin_file_name || !dsp->running)\r\nret = 0;\r\nelse\r\nret = simple_read_from_buffer(user_buf, count, ppos,\r\ndsp->bin_file_name,\r\nstrlen(dsp->bin_file_name));\r\nmutex_unlock(&dsp->debugfs_lock);\r\nreturn ret;\r\n}\r\nstatic void wm_adsp2_init_debugfs(struct wm_adsp *dsp,\r\nstruct snd_soc_codec *codec)\r\n{\r\nstruct dentry *root = NULL;\r\nchar *root_name;\r\nint i;\r\nif (!codec->component.debugfs_root) {\r\nadsp_err(dsp, "No codec debugfs root\n");\r\ngoto err;\r\n}\r\nroot_name = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!root_name)\r\ngoto err;\r\nsnprintf(root_name, PAGE_SIZE, "dsp%d", dsp->num);\r\nroot = debugfs_create_dir(root_name, codec->component.debugfs_root);\r\nkfree(root_name);\r\nif (!root)\r\ngoto err;\r\nif (!debugfs_create_bool("running", S_IRUGO, root, &dsp->running))\r\ngoto err;\r\nif (!debugfs_create_x32("fw_id", S_IRUGO, root, &dsp->fw_id))\r\ngoto err;\r\nif (!debugfs_create_x32("fw_version", S_IRUGO, root,\r\n&dsp->fw_id_version))\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(wm_adsp_debugfs_fops); ++i) {\r\nif (!debugfs_create_file(wm_adsp_debugfs_fops[i].name,\r\nS_IRUGO, root, dsp,\r\n&wm_adsp_debugfs_fops[i].fops))\r\ngoto err;\r\n}\r\ndsp->debugfs_root = root;\r\nreturn;\r\nerr:\r\ndebugfs_remove_recursive(root);\r\nadsp_err(dsp, "Failed to create debugfs\n");\r\n}\r\nstatic void wm_adsp2_cleanup_debugfs(struct wm_adsp *dsp)\r\n{\r\nwm_adsp_debugfs_clear(dsp);\r\ndebugfs_remove_recursive(dsp->debugfs_root);\r\n}\r\nstatic inline void wm_adsp2_init_debugfs(struct wm_adsp *dsp,\r\nstruct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic inline void wm_adsp2_cleanup_debugfs(struct wm_adsp *dsp)\r\n{\r\n}\r\nstatic inline void wm_adsp_debugfs_save_wmfwname(struct wm_adsp *dsp,\r\nconst char *s)\r\n{\r\n}\r\nstatic inline void wm_adsp_debugfs_save_binname(struct wm_adsp *dsp,\r\nconst char *s)\r\n{\r\n}\r\nstatic inline void wm_adsp_debugfs_clear(struct wm_adsp *dsp)\r\n{\r\n}\r\nstatic int wm_adsp_fw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct wm_adsp *dsp = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = dsp[e->shift_l].fw;\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_fw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct wm_adsp *dsp = snd_soc_codec_get_drvdata(codec);\r\nif (ucontrol->value.integer.value[0] == dsp[e->shift_l].fw)\r\nreturn 0;\r\nif (ucontrol->value.integer.value[0] >= WM_ADSP_NUM_FW)\r\nreturn -EINVAL;\r\nif (dsp[e->shift_l].running)\r\nreturn -EBUSY;\r\ndsp[e->shift_l].fw = ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic struct wm_adsp_region const *wm_adsp_find_region(struct wm_adsp *dsp,\r\nint type)\r\n{\r\nint i;\r\nfor (i = 0; i < dsp->num_mems; i++)\r\nif (dsp->mem[i].type == type)\r\nreturn &dsp->mem[i];\r\nreturn NULL;\r\n}\r\nstatic unsigned int wm_adsp_region_to_reg(struct wm_adsp_region const *mem,\r\nunsigned int offset)\r\n{\r\nif (WARN_ON(!mem))\r\nreturn offset;\r\nswitch (mem->type) {\r\ncase WMFW_ADSP1_PM:\r\nreturn mem->base + (offset * 3);\r\ncase WMFW_ADSP1_DM:\r\nreturn mem->base + (offset * 2);\r\ncase WMFW_ADSP2_XM:\r\nreturn mem->base + (offset * 2);\r\ncase WMFW_ADSP2_YM:\r\nreturn mem->base + (offset * 2);\r\ncase WMFW_ADSP1_ZM:\r\nreturn mem->base + (offset * 2);\r\ndefault:\r\nWARN(1, "Unknown memory region type");\r\nreturn offset;\r\n}\r\n}\r\nstatic void wm_adsp2_show_fw_status(struct wm_adsp *dsp)\r\n{\r\nu16 scratch[4];\r\nint ret;\r\nret = regmap_raw_read(dsp->regmap, dsp->base + ADSP2_SCRATCH0,\r\nscratch, sizeof(scratch));\r\nif (ret) {\r\nadsp_err(dsp, "Failed to read SCRATCH regs: %d\n", ret);\r\nreturn;\r\n}\r\nadsp_dbg(dsp, "FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\n",\r\nbe16_to_cpu(scratch[0]),\r\nbe16_to_cpu(scratch[1]),\r\nbe16_to_cpu(scratch[2]),\r\nbe16_to_cpu(scratch[3]));\r\n}\r\nstatic int wm_coeff_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct wm_coeff_ctl *ctl = (struct wm_coeff_ctl *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = ctl->len;\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_write_control(struct wm_coeff_ctl *ctl,\r\nconst void *buf, size_t len)\r\n{\r\nstruct wm_adsp_alg_region *alg_region = &ctl->alg_region;\r\nconst struct wm_adsp_region *mem;\r\nstruct wm_adsp *dsp = ctl->dsp;\r\nvoid *scratch;\r\nint ret;\r\nunsigned int reg;\r\nmem = wm_adsp_find_region(dsp, alg_region->type);\r\nif (!mem) {\r\nadsp_err(dsp, "No base for region %x\n",\r\nalg_region->type);\r\nreturn -EINVAL;\r\n}\r\nreg = ctl->alg_region.base + ctl->offset;\r\nreg = wm_adsp_region_to_reg(mem, reg);\r\nscratch = kmemdup(buf, ctl->len, GFP_KERNEL | GFP_DMA);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nret = regmap_raw_write(dsp->regmap, reg, scratch,\r\nctl->len);\r\nif (ret) {\r\nadsp_err(dsp, "Failed to write %zu bytes to %x: %d\n",\r\nctl->len, reg, ret);\r\nkfree(scratch);\r\nreturn ret;\r\n}\r\nadsp_dbg(dsp, "Wrote %zu bytes to %x\n", ctl->len, reg);\r\nkfree(scratch);\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct wm_coeff_ctl *ctl = (struct wm_coeff_ctl *)kcontrol->private_value;\r\nchar *p = ucontrol->value.bytes.data;\r\nmemcpy(ctl->cache, p, ctl->len);\r\nctl->set = 1;\r\nif (!ctl->enabled)\r\nreturn 0;\r\nreturn wm_coeff_write_control(ctl, p, ctl->len);\r\n}\r\nstatic int wm_coeff_read_control(struct wm_coeff_ctl *ctl,\r\nvoid *buf, size_t len)\r\n{\r\nstruct wm_adsp_alg_region *alg_region = &ctl->alg_region;\r\nconst struct wm_adsp_region *mem;\r\nstruct wm_adsp *dsp = ctl->dsp;\r\nvoid *scratch;\r\nint ret;\r\nunsigned int reg;\r\nmem = wm_adsp_find_region(dsp, alg_region->type);\r\nif (!mem) {\r\nadsp_err(dsp, "No base for region %x\n",\r\nalg_region->type);\r\nreturn -EINVAL;\r\n}\r\nreg = ctl->alg_region.base + ctl->offset;\r\nreg = wm_adsp_region_to_reg(mem, reg);\r\nscratch = kmalloc(ctl->len, GFP_KERNEL | GFP_DMA);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nret = regmap_raw_read(dsp->regmap, reg, scratch, ctl->len);\r\nif (ret) {\r\nadsp_err(dsp, "Failed to read %zu bytes from %x: %d\n",\r\nctl->len, reg, ret);\r\nkfree(scratch);\r\nreturn ret;\r\n}\r\nadsp_dbg(dsp, "Read %zu bytes from %x\n", ctl->len, reg);\r\nmemcpy(buf, scratch, ctl->len);\r\nkfree(scratch);\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct wm_coeff_ctl *ctl = (struct wm_coeff_ctl *)kcontrol->private_value;\r\nchar *p = ucontrol->value.bytes.data;\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE) {\r\nif (ctl->enabled)\r\nreturn wm_coeff_read_control(ctl, p, ctl->len);\r\nelse\r\nreturn -EPERM;\r\n}\r\nmemcpy(p, ctl->cache, ctl->len);\r\nreturn 0;\r\n}\r\nstatic int wmfw_add_ctl(struct wm_adsp *dsp, struct wm_coeff_ctl *ctl)\r\n{\r\nstruct snd_kcontrol_new *kcontrol;\r\nint ret;\r\nif (!ctl || !ctl->name)\r\nreturn -EINVAL;\r\nkcontrol = kzalloc(sizeof(*kcontrol), GFP_KERNEL);\r\nif (!kcontrol)\r\nreturn -ENOMEM;\r\nkcontrol->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nkcontrol->name = ctl->name;\r\nkcontrol->info = wm_coeff_info;\r\nkcontrol->get = wm_coeff_get;\r\nkcontrol->put = wm_coeff_put;\r\nkcontrol->private_value = (unsigned long)ctl;\r\nif (ctl->flags) {\r\nif (ctl->flags & WMFW_CTL_FLAG_WRITEABLE)\r\nkcontrol->access |= SNDRV_CTL_ELEM_ACCESS_WRITE;\r\nif (ctl->flags & WMFW_CTL_FLAG_READABLE)\r\nkcontrol->access |= SNDRV_CTL_ELEM_ACCESS_READ;\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE)\r\nkcontrol->access |= SNDRV_CTL_ELEM_ACCESS_VOLATILE;\r\n}\r\nret = snd_soc_add_card_controls(dsp->card,\r\nkcontrol, 1);\r\nif (ret < 0)\r\ngoto err_kcontrol;\r\nkfree(kcontrol);\r\nctl->kcontrol = snd_soc_card_get_kcontrol(dsp->card,\r\nctl->name);\r\nreturn 0;\r\nerr_kcontrol:\r\nkfree(kcontrol);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_init_control_caches(struct wm_adsp *dsp)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (!ctl->enabled || ctl->set)\r\ncontinue;\r\nif (ctl->flags & WMFW_CTL_FLAG_VOLATILE)\r\ncontinue;\r\nret = wm_coeff_read_control(ctl,\r\nctl->cache,\r\nctl->len);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_coeff_sync_controls(struct wm_adsp *dsp)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (!ctl->enabled)\r\ncontinue;\r\nif (ctl->set && !(ctl->flags & WMFW_CTL_FLAG_VOLATILE)) {\r\nret = wm_coeff_write_control(ctl,\r\nctl->cache,\r\nctl->len);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm_adsp_ctl_work(struct work_struct *work)\r\n{\r\nstruct wmfw_ctl_work *ctl_work = container_of(work,\r\nstruct wmfw_ctl_work,\r\nwork);\r\nwmfw_add_ctl(ctl_work->dsp, ctl_work->ctl);\r\nkfree(ctl_work);\r\n}\r\nstatic int wm_adsp_create_control(struct wm_adsp *dsp,\r\nconst struct wm_adsp_alg_region *alg_region,\r\nunsigned int offset, unsigned int len,\r\nconst char *subname, unsigned int subname_len,\r\nunsigned int flags)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nstruct wmfw_ctl_work *ctl_work;\r\nchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nchar *region_name;\r\nint ret;\r\nif (flags & WMFW_CTL_FLAG_SYS)\r\nreturn 0;\r\nswitch (alg_region->type) {\r\ncase WMFW_ADSP1_PM:\r\nregion_name = "PM";\r\nbreak;\r\ncase WMFW_ADSP1_DM:\r\nregion_name = "DM";\r\nbreak;\r\ncase WMFW_ADSP2_XM:\r\nregion_name = "XM";\r\nbreak;\r\ncase WMFW_ADSP2_YM:\r\nregion_name = "YM";\r\nbreak;\r\ncase WMFW_ADSP1_ZM:\r\nregion_name = "ZM";\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "Unknown region type: %d\n", alg_region->type);\r\nreturn -EINVAL;\r\n}\r\nswitch (dsp->fw_ver) {\r\ncase 0:\r\ncase 1:\r\nsnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "DSP%d %s %x",\r\ndsp->num, region_name, alg_region->alg);\r\nbreak;\r\ndefault:\r\nret = snprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\r\n"DSP%d%c %.12s %x", dsp->num, *region_name,\r\nwm_adsp_fw_text[dsp->fw], alg_region->alg);\r\nif (subname) {\r\nint avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;\r\nint skip = 0;\r\nif (subname_len > avail)\r\nskip = subname_len - avail;\r\nsnprintf(name + ret,\r\nSNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret, " %.*s",\r\nsubname_len - skip, subname + skip);\r\n}\r\nbreak;\r\n}\r\nlist_for_each_entry(ctl, &dsp->ctl_list,\r\nlist) {\r\nif (!strcmp(ctl->name, name)) {\r\nif (!ctl->enabled)\r\nctl->enabled = 1;\r\nreturn 0;\r\n}\r\n}\r\nctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nctl->fw_name = wm_adsp_fw_text[dsp->fw];\r\nctl->alg_region = *alg_region;\r\nctl->name = kmemdup(name, strlen(name) + 1, GFP_KERNEL);\r\nif (!ctl->name) {\r\nret = -ENOMEM;\r\ngoto err_ctl;\r\n}\r\nctl->enabled = 1;\r\nctl->set = 0;\r\nctl->ops.xget = wm_coeff_get;\r\nctl->ops.xput = wm_coeff_put;\r\nctl->dsp = dsp;\r\nctl->flags = flags;\r\nctl->offset = offset;\r\nif (len > 512) {\r\nadsp_warn(dsp, "Truncating control %s from %d\n",\r\nctl->name, len);\r\nlen = 512;\r\n}\r\nctl->len = len;\r\nctl->cache = kzalloc(ctl->len, GFP_KERNEL);\r\nif (!ctl->cache) {\r\nret = -ENOMEM;\r\ngoto err_ctl_name;\r\n}\r\nlist_add(&ctl->list, &dsp->ctl_list);\r\nctl_work = kzalloc(sizeof(*ctl_work), GFP_KERNEL);\r\nif (!ctl_work) {\r\nret = -ENOMEM;\r\ngoto err_ctl_cache;\r\n}\r\nctl_work->dsp = dsp;\r\nctl_work->ctl = ctl;\r\nINIT_WORK(&ctl_work->work, wm_adsp_ctl_work);\r\nschedule_work(&ctl_work->work);\r\nreturn 0;\r\nerr_ctl_cache:\r\nkfree(ctl->cache);\r\nerr_ctl_name:\r\nkfree(ctl->name);\r\nerr_ctl:\r\nkfree(ctl);\r\nreturn ret;\r\n}\r\nstatic int wm_coeff_parse_string(int bytes, const u8 **pos, const u8 **str)\r\n{\r\nint length;\r\nswitch (bytes) {\r\ncase 1:\r\nlength = **pos;\r\nbreak;\r\ncase 2:\r\nlength = le16_to_cpu(*((__le16 *)*pos));\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (str)\r\n*str = *pos + bytes;\r\n*pos += ((length + bytes) + 3) & ~0x03;\r\nreturn length;\r\n}\r\nstatic int wm_coeff_parse_int(int bytes, const u8 **pos)\r\n{\r\nint val = 0;\r\nswitch (bytes) {\r\ncase 2:\r\nval = le16_to_cpu(*((__le16 *)*pos));\r\nbreak;\r\ncase 4:\r\nval = le32_to_cpu(*((__le32 *)*pos));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n*pos += bytes;\r\nreturn val;\r\n}\r\nstatic inline void wm_coeff_parse_alg(struct wm_adsp *dsp, const u8 **data,\r\nstruct wm_coeff_parsed_alg *blk)\r\n{\r\nconst struct wmfw_adsp_alg_data *raw;\r\nswitch (dsp->fw_ver) {\r\ncase 0:\r\ncase 1:\r\nraw = (const struct wmfw_adsp_alg_data *)*data;\r\n*data = raw->data;\r\nblk->id = le32_to_cpu(raw->id);\r\nblk->name = raw->name;\r\nblk->name_len = strlen(raw->name);\r\nblk->ncoeff = le32_to_cpu(raw->ncoeff);\r\nbreak;\r\ndefault:\r\nblk->id = wm_coeff_parse_int(sizeof(raw->id), data);\r\nblk->name_len = wm_coeff_parse_string(sizeof(u8), data,\r\n&blk->name);\r\nwm_coeff_parse_string(sizeof(u16), data, NULL);\r\nblk->ncoeff = wm_coeff_parse_int(sizeof(raw->ncoeff), data);\r\nbreak;\r\n}\r\nadsp_dbg(dsp, "Algorithm ID: %#x\n", blk->id);\r\nadsp_dbg(dsp, "Algorithm name: %.*s\n", blk->name_len, blk->name);\r\nadsp_dbg(dsp, "# of coefficient descriptors: %#x\n", blk->ncoeff);\r\n}\r\nstatic inline void wm_coeff_parse_coeff(struct wm_adsp *dsp, const u8 **data,\r\nstruct wm_coeff_parsed_coeff *blk)\r\n{\r\nconst struct wmfw_adsp_coeff_data *raw;\r\nconst u8 *tmp;\r\nint length;\r\nswitch (dsp->fw_ver) {\r\ncase 0:\r\ncase 1:\r\nraw = (const struct wmfw_adsp_coeff_data *)*data;\r\n*data = *data + sizeof(raw->hdr) + le32_to_cpu(raw->hdr.size);\r\nblk->offset = le16_to_cpu(raw->hdr.offset);\r\nblk->mem_type = le16_to_cpu(raw->hdr.type);\r\nblk->name = raw->name;\r\nblk->name_len = strlen(raw->name);\r\nblk->ctl_type = le16_to_cpu(raw->ctl_type);\r\nblk->flags = le16_to_cpu(raw->flags);\r\nblk->len = le32_to_cpu(raw->len);\r\nbreak;\r\ndefault:\r\ntmp = *data;\r\nblk->offset = wm_coeff_parse_int(sizeof(raw->hdr.offset), &tmp);\r\nblk->mem_type = wm_coeff_parse_int(sizeof(raw->hdr.type), &tmp);\r\nlength = wm_coeff_parse_int(sizeof(raw->hdr.size), &tmp);\r\nblk->name_len = wm_coeff_parse_string(sizeof(u8), &tmp,\r\n&blk->name);\r\nwm_coeff_parse_string(sizeof(u8), &tmp, NULL);\r\nwm_coeff_parse_string(sizeof(u16), &tmp, NULL);\r\nblk->ctl_type = wm_coeff_parse_int(sizeof(raw->ctl_type), &tmp);\r\nblk->flags = wm_coeff_parse_int(sizeof(raw->flags), &tmp);\r\nblk->len = wm_coeff_parse_int(sizeof(raw->len), &tmp);\r\n*data = *data + sizeof(raw->hdr) + length;\r\nbreak;\r\n}\r\nadsp_dbg(dsp, "\tCoefficient type: %#x\n", blk->mem_type);\r\nadsp_dbg(dsp, "\tCoefficient offset: %#x\n", blk->offset);\r\nadsp_dbg(dsp, "\tCoefficient name: %.*s\n", blk->name_len, blk->name);\r\nadsp_dbg(dsp, "\tCoefficient flags: %#x\n", blk->flags);\r\nadsp_dbg(dsp, "\tALSA control type: %#x\n", blk->ctl_type);\r\nadsp_dbg(dsp, "\tALSA control len: %#x\n", blk->len);\r\n}\r\nstatic int wm_adsp_parse_coeff(struct wm_adsp *dsp,\r\nconst struct wmfw_region *region)\r\n{\r\nstruct wm_adsp_alg_region alg_region = {};\r\nstruct wm_coeff_parsed_alg alg_blk;\r\nstruct wm_coeff_parsed_coeff coeff_blk;\r\nconst u8 *data = region->data;\r\nint i, ret;\r\nwm_coeff_parse_alg(dsp, &data, &alg_blk);\r\nfor (i = 0; i < alg_blk.ncoeff; i++) {\r\nwm_coeff_parse_coeff(dsp, &data, &coeff_blk);\r\nswitch (coeff_blk.ctl_type) {\r\ncase SNDRV_CTL_ELEM_TYPE_BYTES:\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "Unknown control type: %d\n",\r\ncoeff_blk.ctl_type);\r\nreturn -EINVAL;\r\n}\r\nalg_region.type = coeff_blk.mem_type;\r\nalg_region.alg = alg_blk.id;\r\nret = wm_adsp_create_control(dsp, &alg_region,\r\ncoeff_blk.offset,\r\ncoeff_blk.len,\r\ncoeff_blk.name,\r\ncoeff_blk.name_len,\r\ncoeff_blk.flags);\r\nif (ret < 0)\r\nadsp_err(dsp, "Failed to create control: %.*s, %d\n",\r\ncoeff_blk.name_len, coeff_blk.name, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm_adsp_load(struct wm_adsp *dsp)\r\n{\r\nLIST_HEAD(buf_list);\r\nconst struct firmware *firmware;\r\nstruct regmap *regmap = dsp->regmap;\r\nunsigned int pos = 0;\r\nconst struct wmfw_header *header;\r\nconst struct wmfw_adsp1_sizes *adsp1_sizes;\r\nconst struct wmfw_adsp2_sizes *adsp2_sizes;\r\nconst struct wmfw_footer *footer;\r\nconst struct wmfw_region *region;\r\nconst struct wm_adsp_region *mem;\r\nconst char *region_name;\r\nchar *file, *text;\r\nstruct wm_adsp_buf *buf;\r\nunsigned int reg;\r\nint regions = 0;\r\nint ret, offset, type, sizes;\r\nfile = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (file == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(file, PAGE_SIZE, "%s-dsp%d-%s.wmfw", dsp->part, dsp->num,\r\nwm_adsp_fw[dsp->fw].file);\r\nfile[PAGE_SIZE - 1] = '\0';\r\nret = request_firmware(&firmware, file, dsp->dev);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to request '%s'\n", file);\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\npos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\r\nif (pos >= firmware->size) {\r\nadsp_err(dsp, "%s: file too short, %zu bytes\n",\r\nfile, firmware->size);\r\ngoto out_fw;\r\n}\r\nheader = (void*)&firmware->data[0];\r\nif (memcmp(&header->magic[0], "WMFW", 4) != 0) {\r\nadsp_err(dsp, "%s: invalid magic\n", file);\r\ngoto out_fw;\r\n}\r\nswitch (header->ver) {\r\ncase 0:\r\nadsp_warn(dsp, "%s: Depreciated file format %d\n",\r\nfile, header->ver);\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "%s: unknown file format %d\n",\r\nfile, header->ver);\r\ngoto out_fw;\r\n}\r\nadsp_info(dsp, "Firmware version: %d\n", header->ver);\r\ndsp->fw_ver = header->ver;\r\nif (header->core != dsp->type) {\r\nadsp_err(dsp, "%s: invalid core %d != %d\n",\r\nfile, header->core, dsp->type);\r\ngoto out_fw;\r\n}\r\nswitch (dsp->type) {\r\ncase WMFW_ADSP1:\r\npos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);\r\nadsp1_sizes = (void *)&(header[1]);\r\nfooter = (void *)&(adsp1_sizes[1]);\r\nsizes = sizeof(*adsp1_sizes);\r\nadsp_dbg(dsp, "%s: %d DM, %d PM, %d ZM\n",\r\nfile, le32_to_cpu(adsp1_sizes->dm),\r\nle32_to_cpu(adsp1_sizes->pm),\r\nle32_to_cpu(adsp1_sizes->zm));\r\nbreak;\r\ncase WMFW_ADSP2:\r\npos = sizeof(*header) + sizeof(*adsp2_sizes) + sizeof(*footer);\r\nadsp2_sizes = (void *)&(header[1]);\r\nfooter = (void *)&(adsp2_sizes[1]);\r\nsizes = sizeof(*adsp2_sizes);\r\nadsp_dbg(dsp, "%s: %d XM, %d YM %d PM, %d ZM\n",\r\nfile, le32_to_cpu(adsp2_sizes->xm),\r\nle32_to_cpu(adsp2_sizes->ym),\r\nle32_to_cpu(adsp2_sizes->pm),\r\nle32_to_cpu(adsp2_sizes->zm));\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown DSP type");\r\ngoto out_fw;\r\n}\r\nif (le32_to_cpu(header->len) != sizeof(*header) +\r\nsizes + sizeof(*footer)) {\r\nadsp_err(dsp, "%s: unexpected header length %d\n",\r\nfile, le32_to_cpu(header->len));\r\ngoto out_fw;\r\n}\r\nadsp_dbg(dsp, "%s: timestamp %llu\n", file,\r\nle64_to_cpu(footer->timestamp));\r\nwhile (pos < firmware->size &&\r\npos - firmware->size > sizeof(*region)) {\r\nregion = (void *)&(firmware->data[pos]);\r\nregion_name = "Unknown";\r\nreg = 0;\r\ntext = NULL;\r\noffset = le32_to_cpu(region->offset) & 0xffffff;\r\ntype = be32_to_cpu(region->type) & 0xff;\r\nmem = wm_adsp_find_region(dsp, type);\r\nswitch (type) {\r\ncase WMFW_NAME_TEXT:\r\nregion_name = "Firmware name";\r\ntext = kzalloc(le32_to_cpu(region->len) + 1,\r\nGFP_KERNEL);\r\nbreak;\r\ncase WMFW_ALGORITHM_DATA:\r\nregion_name = "Algorithm";\r\nret = wm_adsp_parse_coeff(dsp, region);\r\nif (ret != 0)\r\ngoto out_fw;\r\nbreak;\r\ncase WMFW_INFO_TEXT:\r\nregion_name = "Information";\r\ntext = kzalloc(le32_to_cpu(region->len) + 1,\r\nGFP_KERNEL);\r\nbreak;\r\ncase WMFW_ABSOLUTE:\r\nregion_name = "Absolute";\r\nreg = offset;\r\nbreak;\r\ncase WMFW_ADSP1_PM:\r\nregion_name = "PM";\r\nreg = wm_adsp_region_to_reg(mem, offset);\r\nbreak;\r\ncase WMFW_ADSP1_DM:\r\nregion_name = "DM";\r\nreg = wm_adsp_region_to_reg(mem, offset);\r\nbreak;\r\ncase WMFW_ADSP2_XM:\r\nregion_name = "XM";\r\nreg = wm_adsp_region_to_reg(mem, offset);\r\nbreak;\r\ncase WMFW_ADSP2_YM:\r\nregion_name = "YM";\r\nreg = wm_adsp_region_to_reg(mem, offset);\r\nbreak;\r\ncase WMFW_ADSP1_ZM:\r\nregion_name = "ZM";\r\nreg = wm_adsp_region_to_reg(mem, offset);\r\nbreak;\r\ndefault:\r\nadsp_warn(dsp,\r\n"%s.%d: Unknown region type %x at %d(%x)\n",\r\nfile, regions, type, pos, pos);\r\nbreak;\r\n}\r\nadsp_dbg(dsp, "%s.%d: %d bytes at %d in %s\n", file,\r\nregions, le32_to_cpu(region->len), offset,\r\nregion_name);\r\nif (text) {\r\nmemcpy(text, region->data, le32_to_cpu(region->len));\r\nadsp_info(dsp, "%s: %s\n", file, text);\r\nkfree(text);\r\n}\r\nif (reg) {\r\nbuf = wm_adsp_buf_alloc(region->data,\r\nle32_to_cpu(region->len),\r\n&buf_list);\r\nif (!buf) {\r\nadsp_err(dsp, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto out_fw;\r\n}\r\nret = regmap_raw_write_async(regmap, reg, buf->buf,\r\nle32_to_cpu(region->len));\r\nif (ret != 0) {\r\nadsp_err(dsp,\r\n"%s.%d: Failed to write %d bytes at %d in %s: %d\n",\r\nfile, regions,\r\nle32_to_cpu(region->len), offset,\r\nregion_name, ret);\r\ngoto out_fw;\r\n}\r\n}\r\npos += le32_to_cpu(region->len) + sizeof(*region);\r\nregions++;\r\n}\r\nret = regmap_async_complete(regmap);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to complete async write: %d\n", ret);\r\ngoto out_fw;\r\n}\r\nif (pos > firmware->size)\r\nadsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",\r\nfile, regions, pos - firmware->size);\r\nwm_adsp_debugfs_save_wmfwname(dsp, file);\r\nout_fw:\r\nregmap_async_complete(regmap);\r\nwm_adsp_buf_free(&buf_list);\r\nrelease_firmware(firmware);\r\nout:\r\nkfree(file);\r\nreturn ret;\r\n}\r\nstatic void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,\r\nconst struct wm_adsp_alg_region *alg_region)\r\n{\r\nstruct wm_coeff_ctl *ctl;\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list) {\r\nif (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&\r\nalg_region->alg == ctl->alg_region.alg &&\r\nalg_region->type == ctl->alg_region.type) {\r\nctl->alg_region.base = alg_region->base;\r\n}\r\n}\r\n}\r\nstatic void *wm_adsp_read_algs(struct wm_adsp *dsp, size_t n_algs,\r\nunsigned int pos, unsigned int len)\r\n{\r\nvoid *alg;\r\nint ret;\r\n__be32 val;\r\nif (n_algs == 0) {\r\nadsp_err(dsp, "No algorithms\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (n_algs > 1024) {\r\nadsp_err(dsp, "Algorithm count %zx excessive\n", n_algs);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nret = regmap_raw_read(dsp->regmap, pos + len, &val, sizeof(val));\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm list end: %d\n",\r\nret);\r\nreturn ERR_PTR(ret);\r\n}\r\nif (be32_to_cpu(val) != 0xbedead)\r\nadsp_warn(dsp, "Algorithm list end %x 0x%x != 0xbeadead\n",\r\npos + len, be32_to_cpu(val));\r\nalg = kzalloc(len * 2, GFP_KERNEL | GFP_DMA);\r\nif (!alg)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = regmap_raw_read(dsp->regmap, pos, alg, len * 2);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm list: %d\n",\r\nret);\r\nkfree(alg);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn alg;\r\n}\r\nstatic struct wm_adsp_alg_region *wm_adsp_create_region(struct wm_adsp *dsp,\r\nint type, __be32 id,\r\n__be32 base)\r\n{\r\nstruct wm_adsp_alg_region *alg_region;\r\nalg_region = kzalloc(sizeof(*alg_region), GFP_KERNEL);\r\nif (!alg_region)\r\nreturn ERR_PTR(-ENOMEM);\r\nalg_region->type = type;\r\nalg_region->alg = be32_to_cpu(id);\r\nalg_region->base = be32_to_cpu(base);\r\nlist_add_tail(&alg_region->list, &dsp->alg_regions);\r\nif (dsp->fw_ver > 0)\r\nwm_adsp_ctl_fixup_base(dsp, alg_region);\r\nreturn alg_region;\r\n}\r\nstatic int wm_adsp1_setup_algs(struct wm_adsp *dsp)\r\n{\r\nstruct wmfw_adsp1_id_hdr adsp1_id;\r\nstruct wmfw_adsp1_alg_hdr *adsp1_alg;\r\nstruct wm_adsp_alg_region *alg_region;\r\nconst struct wm_adsp_region *mem;\r\nunsigned int pos, len;\r\nsize_t n_algs;\r\nint i, ret;\r\nmem = wm_adsp_find_region(dsp, WMFW_ADSP1_DM);\r\nif (WARN_ON(!mem))\r\nreturn -EINVAL;\r\nret = regmap_raw_read(dsp->regmap, mem->base, &adsp1_id,\r\nsizeof(adsp1_id));\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm info: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nn_algs = be32_to_cpu(adsp1_id.n_algs);\r\ndsp->fw_id = be32_to_cpu(adsp1_id.fw.id);\r\nadsp_info(dsp, "Firmware: %x v%d.%d.%d, %zu algorithms\n",\r\ndsp->fw_id,\r\n(be32_to_cpu(adsp1_id.fw.ver) & 0xff0000) >> 16,\r\n(be32_to_cpu(adsp1_id.fw.ver) & 0xff00) >> 8,\r\nbe32_to_cpu(adsp1_id.fw.ver) & 0xff,\r\nn_algs);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,\r\nadsp1_id.fw.id, adsp1_id.zm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,\r\nadsp1_id.fw.id, adsp1_id.dm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\npos = sizeof(adsp1_id) / 2;\r\nlen = (sizeof(*adsp1_alg) * n_algs) / 2;\r\nadsp1_alg = wm_adsp_read_algs(dsp, n_algs, mem->base + pos, len);\r\nif (IS_ERR(adsp1_alg))\r\nreturn PTR_ERR(adsp1_alg);\r\nfor (i = 0; i < n_algs; i++) {\r\nadsp_info(dsp, "%d: ID %x v%d.%d.%d DM@%x ZM@%x\n",\r\ni, be32_to_cpu(adsp1_alg[i].alg.id),\r\n(be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff0000) >> 16,\r\n(be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff00) >> 8,\r\nbe32_to_cpu(adsp1_alg[i].alg.ver) & 0xff,\r\nbe32_to_cpu(adsp1_alg[i].dm),\r\nbe32_to_cpu(adsp1_alg[i].zm));\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,\r\nadsp1_alg[i].alg.id,\r\nadsp1_alg[i].dm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp1_alg[i + 1].dm);\r\nlen -= be32_to_cpu(adsp1_alg[i].dm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region DM with ID %x\n",\r\nbe32_to_cpu(adsp1_alg[i].alg.id));\r\n}\r\n}\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,\r\nadsp1_alg[i].alg.id,\r\nadsp1_alg[i].zm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp1_alg[i + 1].zm);\r\nlen -= be32_to_cpu(adsp1_alg[i].zm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region ZM with ID %x\n",\r\nbe32_to_cpu(adsp1_alg[i].alg.id));\r\n}\r\n}\r\n}\r\nout:\r\nkfree(adsp1_alg);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp2_setup_algs(struct wm_adsp *dsp)\r\n{\r\nstruct wmfw_adsp2_id_hdr adsp2_id;\r\nstruct wmfw_adsp2_alg_hdr *adsp2_alg;\r\nstruct wm_adsp_alg_region *alg_region;\r\nconst struct wm_adsp_region *mem;\r\nunsigned int pos, len;\r\nsize_t n_algs;\r\nint i, ret;\r\nmem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);\r\nif (WARN_ON(!mem))\r\nreturn -EINVAL;\r\nret = regmap_raw_read(dsp->regmap, mem->base, &adsp2_id,\r\nsizeof(adsp2_id));\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read algorithm info: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nn_algs = be32_to_cpu(adsp2_id.n_algs);\r\ndsp->fw_id = be32_to_cpu(adsp2_id.fw.id);\r\ndsp->fw_id_version = be32_to_cpu(adsp2_id.fw.ver);\r\nadsp_info(dsp, "Firmware: %x v%d.%d.%d, %zu algorithms\n",\r\ndsp->fw_id,\r\n(dsp->fw_id_version & 0xff0000) >> 16,\r\n(dsp->fw_id_version & 0xff00) >> 8,\r\ndsp->fw_id_version & 0xff,\r\nn_algs);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,\r\nadsp2_id.fw.id, adsp2_id.xm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,\r\nadsp2_id.fw.id, adsp2_id.ym);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,\r\nadsp2_id.fw.id, adsp2_id.zm);\r\nif (IS_ERR(alg_region))\r\nreturn PTR_ERR(alg_region);\r\npos = sizeof(adsp2_id) / 2;\r\nlen = (sizeof(*adsp2_alg) * n_algs) / 2;\r\nadsp2_alg = wm_adsp_read_algs(dsp, n_algs, mem->base + pos, len);\r\nif (IS_ERR(adsp2_alg))\r\nreturn PTR_ERR(adsp2_alg);\r\nfor (i = 0; i < n_algs; i++) {\r\nadsp_info(dsp,\r\n"%d: ID %x v%d.%d.%d XM@%x YM@%x ZM@%x\n",\r\ni, be32_to_cpu(adsp2_alg[i].alg.id),\r\n(be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff0000) >> 16,\r\n(be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff00) >> 8,\r\nbe32_to_cpu(adsp2_alg[i].alg.ver) & 0xff,\r\nbe32_to_cpu(adsp2_alg[i].xm),\r\nbe32_to_cpu(adsp2_alg[i].ym),\r\nbe32_to_cpu(adsp2_alg[i].zm));\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,\r\nadsp2_alg[i].alg.id,\r\nadsp2_alg[i].xm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp2_alg[i + 1].xm);\r\nlen -= be32_to_cpu(adsp2_alg[i].xm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region XM with ID %x\n",\r\nbe32_to_cpu(adsp2_alg[i].alg.id));\r\n}\r\n}\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,\r\nadsp2_alg[i].alg.id,\r\nadsp2_alg[i].ym);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp2_alg[i + 1].ym);\r\nlen -= be32_to_cpu(adsp2_alg[i].ym);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region YM with ID %x\n",\r\nbe32_to_cpu(adsp2_alg[i].alg.id));\r\n}\r\n}\r\nalg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,\r\nadsp2_alg[i].alg.id,\r\nadsp2_alg[i].zm);\r\nif (IS_ERR(alg_region)) {\r\nret = PTR_ERR(alg_region);\r\ngoto out;\r\n}\r\nif (dsp->fw_ver == 0) {\r\nif (i + 1 < n_algs) {\r\nlen = be32_to_cpu(adsp2_alg[i + 1].zm);\r\nlen -= be32_to_cpu(adsp2_alg[i].zm);\r\nlen *= 4;\r\nwm_adsp_create_control(dsp, alg_region, 0,\r\nlen, NULL, 0, 0);\r\n} else {\r\nadsp_warn(dsp, "Missing length info for region ZM with ID %x\n",\r\nbe32_to_cpu(adsp2_alg[i].alg.id));\r\n}\r\n}\r\n}\r\nout:\r\nkfree(adsp2_alg);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp_load_coeff(struct wm_adsp *dsp)\r\n{\r\nLIST_HEAD(buf_list);\r\nstruct regmap *regmap = dsp->regmap;\r\nstruct wmfw_coeff_hdr *hdr;\r\nstruct wmfw_coeff_item *blk;\r\nconst struct firmware *firmware;\r\nconst struct wm_adsp_region *mem;\r\nstruct wm_adsp_alg_region *alg_region;\r\nconst char *region_name;\r\nint ret, pos, blocks, type, offset, reg;\r\nchar *file;\r\nstruct wm_adsp_buf *buf;\r\nfile = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (file == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(file, PAGE_SIZE, "%s-dsp%d-%s.bin", dsp->part, dsp->num,\r\nwm_adsp_fw[dsp->fw].file);\r\nfile[PAGE_SIZE - 1] = '\0';\r\nret = request_firmware(&firmware, file, dsp->dev);\r\nif (ret != 0) {\r\nadsp_warn(dsp, "Failed to request '%s'\n", file);\r\nret = 0;\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\nif (sizeof(*hdr) >= firmware->size) {\r\nadsp_err(dsp, "%s: file too short, %zu bytes\n",\r\nfile, firmware->size);\r\ngoto out_fw;\r\n}\r\nhdr = (void*)&firmware->data[0];\r\nif (memcmp(hdr->magic, "WMDR", 4) != 0) {\r\nadsp_err(dsp, "%s: invalid magic\n", file);\r\ngoto out_fw;\r\n}\r\nswitch (be32_to_cpu(hdr->rev) & 0xff) {\r\ncase 1:\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "%s: Unsupported coefficient file format %d\n",\r\nfile, be32_to_cpu(hdr->rev) & 0xff);\r\nret = -EINVAL;\r\ngoto out_fw;\r\n}\r\nadsp_dbg(dsp, "%s: v%d.%d.%d\n", file,\r\n(le32_to_cpu(hdr->ver) >> 16) & 0xff,\r\n(le32_to_cpu(hdr->ver) >> 8) & 0xff,\r\nle32_to_cpu(hdr->ver) & 0xff);\r\npos = le32_to_cpu(hdr->len);\r\nblocks = 0;\r\nwhile (pos < firmware->size &&\r\npos - firmware->size > sizeof(*blk)) {\r\nblk = (void*)(&firmware->data[pos]);\r\ntype = le16_to_cpu(blk->type);\r\noffset = le16_to_cpu(blk->offset);\r\nadsp_dbg(dsp, "%s.%d: %x v%d.%d.%d\n",\r\nfile, blocks, le32_to_cpu(blk->id),\r\n(le32_to_cpu(blk->ver) >> 16) & 0xff,\r\n(le32_to_cpu(blk->ver) >> 8) & 0xff,\r\nle32_to_cpu(blk->ver) & 0xff);\r\nadsp_dbg(dsp, "%s.%d: %d bytes at 0x%x in %x\n",\r\nfile, blocks, le32_to_cpu(blk->len), offset, type);\r\nreg = 0;\r\nregion_name = "Unknown";\r\nswitch (type) {\r\ncase (WMFW_NAME_TEXT << 8):\r\ncase (WMFW_INFO_TEXT << 8):\r\nbreak;\r\ncase (WMFW_ABSOLUTE << 8):\r\nif (le32_to_cpu(blk->id) == dsp->fw_id &&\r\noffset == 0) {\r\nregion_name = "global coefficients";\r\nmem = wm_adsp_find_region(dsp, type);\r\nif (!mem) {\r\nadsp_err(dsp, "No ZM\n");\r\nbreak;\r\n}\r\nreg = wm_adsp_region_to_reg(mem, 0);\r\n} else {\r\nregion_name = "register";\r\nreg = offset;\r\n}\r\nbreak;\r\ncase WMFW_ADSP1_DM:\r\ncase WMFW_ADSP1_ZM:\r\ncase WMFW_ADSP2_XM:\r\ncase WMFW_ADSP2_YM:\r\nadsp_dbg(dsp, "%s.%d: %d bytes in %x for %x\n",\r\nfile, blocks, le32_to_cpu(blk->len),\r\ntype, le32_to_cpu(blk->id));\r\nmem = wm_adsp_find_region(dsp, type);\r\nif (!mem) {\r\nadsp_err(dsp, "No base for region %x\n", type);\r\nbreak;\r\n}\r\nreg = 0;\r\nlist_for_each_entry(alg_region,\r\n&dsp->alg_regions, list) {\r\nif (le32_to_cpu(blk->id) == alg_region->alg &&\r\ntype == alg_region->type) {\r\nreg = alg_region->base;\r\nreg = wm_adsp_region_to_reg(mem,\r\nreg);\r\nreg += offset;\r\nbreak;\r\n}\r\n}\r\nif (reg == 0)\r\nadsp_err(dsp, "No %x for algorithm %x\n",\r\ntype, le32_to_cpu(blk->id));\r\nbreak;\r\ndefault:\r\nadsp_err(dsp, "%s.%d: Unknown region type %x at %d\n",\r\nfile, blocks, type, pos);\r\nbreak;\r\n}\r\nif (reg) {\r\nbuf = wm_adsp_buf_alloc(blk->data,\r\nle32_to_cpu(blk->len),\r\n&buf_list);\r\nif (!buf) {\r\nadsp_err(dsp, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto out_fw;\r\n}\r\nadsp_dbg(dsp, "%s.%d: Writing %d bytes at %x\n",\r\nfile, blocks, le32_to_cpu(blk->len),\r\nreg);\r\nret = regmap_raw_write_async(regmap, reg, buf->buf,\r\nle32_to_cpu(blk->len));\r\nif (ret != 0) {\r\nadsp_err(dsp,\r\n"%s.%d: Failed to write to %x in %s: %d\n",\r\nfile, blocks, reg, region_name, ret);\r\n}\r\n}\r\npos += (le32_to_cpu(blk->len) + sizeof(*blk) + 3) & ~0x03;\r\nblocks++;\r\n}\r\nret = regmap_async_complete(regmap);\r\nif (ret != 0)\r\nadsp_err(dsp, "Failed to complete async write: %d\n", ret);\r\nif (pos > firmware->size)\r\nadsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",\r\nfile, blocks, pos - firmware->size);\r\nwm_adsp_debugfs_save_binname(dsp, file);\r\nout_fw:\r\nregmap_async_complete(regmap);\r\nrelease_firmware(firmware);\r\nwm_adsp_buf_free(&buf_list);\r\nout:\r\nkfree(file);\r\nreturn ret;\r\n}\r\nint wm_adsp1_init(struct wm_adsp *dsp)\r\n{\r\nINIT_LIST_HEAD(&dsp->alg_regions);\r\n#ifdef CONFIG_DEBUG_FS\r\nmutex_init(&dsp->debugfs_lock);\r\n#endif\r\nreturn 0;\r\n}\r\nint wm_adsp1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_adsp *dsps = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_adsp *dsp = &dsps[w->shift];\r\nstruct wm_adsp_alg_region *alg_region;\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nint val;\r\ndsp->card = codec->component.card;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_SYS_ENA, ADSP1_SYS_ENA);\r\nif(dsp->sysclk_reg) {\r\nret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read SYSCLK state: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nval = (val & dsp->sysclk_mask)\r\n>> dsp->sysclk_shift;\r\nret = regmap_update_bits(dsp->regmap,\r\ndsp->base + ADSP1_CONTROL_31,\r\nADSP1_CLK_SEL_MASK, val);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to set clock rate: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nret = wm_adsp_load(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_adsp1_setup_algs(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_adsp_load_coeff(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_coeff_init_control_caches(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_coeff_sync_controls(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_CORE_ENA | ADSP1_START,\r\nADSP1_CORE_ENA | ADSP1_START);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_CORE_ENA | ADSP1_START, 0);\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,\r\nADSP1_WDMA_BUFFER_LENGTH_MASK, 0);\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_SYS_ENA, 0);\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list)\r\nctl->enabled = 0;\r\nwhile (!list_empty(&dsp->alg_regions)) {\r\nalg_region = list_first_entry(&dsp->alg_regions,\r\nstruct wm_adsp_alg_region,\r\nlist);\r\nlist_del(&alg_region->list);\r\nkfree(alg_region);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,\r\nADSP1_SYS_ENA, 0);\r\nreturn ret;\r\n}\r\nstatic int wm_adsp2_ena(struct wm_adsp *dsp)\r\n{\r\nunsigned int val;\r\nint ret, count;\r\nret = regmap_update_bits_async(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA, ADSP2_SYS_ENA);\r\nif (ret != 0)\r\nreturn ret;\r\nfor (count = 0; count < 10; ++count) {\r\nret = regmap_read(dsp->regmap, dsp->base + ADSP2_STATUS1,\r\n&val);\r\nif (ret != 0)\r\nreturn ret;\r\nif (val & ADSP2_RAM_RDY)\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!(val & ADSP2_RAM_RDY)) {\r\nadsp_err(dsp, "Failed to start DSP RAM\n");\r\nreturn -EBUSY;\r\n}\r\nadsp_dbg(dsp, "RAM ready after %d polls\n", count);\r\nreturn 0;\r\n}\r\nstatic void wm_adsp2_boot_work(struct work_struct *work)\r\n{\r\nstruct wm_adsp *dsp = container_of(work,\r\nstruct wm_adsp,\r\nboot_work);\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(dsp->regmap, ARIZONA_SYSTEM_CLOCK_1, &val);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to read SYSCLK state: %d\n", ret);\r\nreturn;\r\n}\r\nval = (val & ARIZONA_SYSCLK_FREQ_MASK)\r\n>> ARIZONA_SYSCLK_FREQ_SHIFT;\r\nret = regmap_update_bits_async(dsp->regmap,\r\ndsp->base + ADSP2_CLOCKING,\r\nADSP2_CLK_SEL_MASK, val);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to set clock rate: %d\n", ret);\r\nreturn;\r\n}\r\nret = wm_adsp2_ena(dsp);\r\nif (ret != 0)\r\nreturn;\r\nret = wm_adsp_load(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_adsp2_setup_algs(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_adsp_load_coeff(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_coeff_init_control_caches(dsp);\r\nif (ret != 0)\r\ngoto err;\r\nret = wm_coeff_sync_controls(dsp);\r\nif (ret != 0)\r\ngoto err;\r\ndsp->running = true;\r\nreturn;\r\nerr:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA | ADSP2_CORE_ENA | ADSP2_START, 0);\r\n}\r\nint wm_adsp2_early_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_adsp *dsps = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_adsp *dsp = &dsps[w->shift];\r\ndsp->card = codec->component.card;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nqueue_work(system_unbound_wq, &dsp->boot_work);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint wm_adsp2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_adsp *dsps = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_adsp *dsp = &dsps[w->shift];\r\nstruct wm_adsp_alg_region *alg_region;\r\nstruct wm_coeff_ctl *ctl;\r\nint ret;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nflush_work(&dsp->boot_work);\r\nif (!dsp->running)\r\nreturn -EIO;\r\nret = regmap_update_bits(dsp->regmap,\r\ndsp->base + ADSP2_CONTROL,\r\nADSP2_CORE_ENA | ADSP2_START,\r\nADSP2_CORE_ENA | ADSP2_START);\r\nif (ret != 0)\r\ngoto err;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nwm_adsp2_show_fw_status(dsp);\r\nwm_adsp_debugfs_clear(dsp);\r\ndsp->fw_id = 0;\r\ndsp->fw_id_version = 0;\r\ndsp->running = false;\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA | ADSP2_CORE_ENA |\r\nADSP2_START, 0);\r\nregmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_1, 0);\r\nregmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_2, 0);\r\nregmap_write(dsp->regmap, dsp->base + ADSP2_RDMA_CONFIG_1, 0);\r\nlist_for_each_entry(ctl, &dsp->ctl_list, list)\r\nctl->enabled = 0;\r\nwhile (!list_empty(&dsp->alg_regions)) {\r\nalg_region = list_first_entry(&dsp->alg_regions,\r\nstruct wm_adsp_alg_region,\r\nlist);\r\nlist_del(&alg_region->list);\r\nkfree(alg_region);\r\n}\r\nadsp_dbg(dsp, "Shutdown complete\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\nregmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_SYS_ENA | ADSP2_CORE_ENA | ADSP2_START, 0);\r\nreturn ret;\r\n}\r\nint wm_adsp2_codec_probe(struct wm_adsp *dsp, struct snd_soc_codec *codec)\r\n{\r\nwm_adsp2_init_debugfs(dsp, codec);\r\nreturn snd_soc_add_codec_controls(codec,\r\n&wm_adsp_fw_controls[dsp->num - 1],\r\n1);\r\n}\r\nint wm_adsp2_codec_remove(struct wm_adsp *dsp, struct snd_soc_codec *codec)\r\n{\r\nwm_adsp2_cleanup_debugfs(dsp);\r\nreturn 0;\r\n}\r\nint wm_adsp2_init(struct wm_adsp *dsp)\r\n{\r\nint ret;\r\nret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,\r\nADSP2_MEM_ENA, 0);\r\nif (ret != 0) {\r\nadsp_err(dsp, "Failed to clear memory retention: %d\n", ret);\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&dsp->alg_regions);\r\nINIT_LIST_HEAD(&dsp->ctl_list);\r\nINIT_WORK(&dsp->boot_work, wm_adsp2_boot_work);\r\n#ifdef CONFIG_DEBUG_FS\r\nmutex_init(&dsp->debugfs_lock);\r\n#endif\r\nreturn 0;\r\n}
