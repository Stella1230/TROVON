static int i2c_gpio_set(struct ipath_devdata *dd,\r\nenum i2c_type line,\r\nenum i2c_state new_line_state)\r\n{\r\nu64 out_mask, dir_mask, *gpioval;\r\nunsigned long flags = 0;\r\ngpioval = &dd->ipath_gpio_out;\r\nif (line == i2c_line_scl) {\r\ndir_mask = dd->ipath_gpio_scl;\r\nout_mask = (1UL << dd->ipath_gpio_scl_num);\r\n} else {\r\ndir_mask = dd->ipath_gpio_sda;\r\nout_mask = (1UL << dd->ipath_gpio_sda_num);\r\n}\r\nspin_lock_irqsave(&dd->ipath_gpio_lock, flags);\r\nif (new_line_state == i2c_line_high) {\r\ndd->ipath_extctrl &= ~dir_mask;\r\n} else {\r\ndd->ipath_extctrl |= dir_mask;\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_extctrl, dd->ipath_extctrl);\r\nif (new_line_state == i2c_line_high)\r\n*gpioval |= out_mask;\r\nelse\r\n*gpioval &= ~out_mask;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_gpio_out, *gpioval);\r\nspin_unlock_irqrestore(&dd->ipath_gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int i2c_gpio_get(struct ipath_devdata *dd,\r\nenum i2c_type line,\r\nenum i2c_state *curr_statep)\r\n{\r\nu64 read_val, mask;\r\nint ret;\r\nunsigned long flags = 0;\r\nif (curr_statep == NULL) {\r\nret = 1;\r\ngoto bail;\r\n}\r\nif (line == i2c_line_scl)\r\nmask = dd->ipath_gpio_scl;\r\nelse\r\nmask = dd->ipath_gpio_sda;\r\nspin_lock_irqsave(&dd->ipath_gpio_lock, flags);\r\ndd->ipath_extctrl &= ~mask;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_extctrl, dd->ipath_extctrl);\r\nread_val = ipath_read_kreg64(dd, dd->ipath_kregs->kr_extstatus);\r\nspin_unlock_irqrestore(&dd->ipath_gpio_lock, flags);\r\nif (read_val & mask)\r\n*curr_statep = i2c_line_high;\r\nelse\r\n*curr_statep = i2c_line_low;\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void i2c_wait_for_writes(struct ipath_devdata *dd)\r\n{\r\n(void)ipath_read_kreg32(dd, dd->ipath_kregs->kr_scratch);\r\nrmb();\r\n}\r\nstatic void scl_out(struct ipath_devdata *dd, u8 bit)\r\n{\r\nudelay(1);\r\ni2c_gpio_set(dd, i2c_line_scl, bit ? i2c_line_high : i2c_line_low);\r\ni2c_wait_for_writes(dd);\r\n}\r\nstatic void sda_out(struct ipath_devdata *dd, u8 bit)\r\n{\r\ni2c_gpio_set(dd, i2c_line_sda, bit ? i2c_line_high : i2c_line_low);\r\ni2c_wait_for_writes(dd);\r\n}\r\nstatic u8 sda_in(struct ipath_devdata *dd, int wait)\r\n{\r\nenum i2c_state bit;\r\nif (i2c_gpio_get(dd, i2c_line_sda, &bit))\r\nipath_dbg("get bit failed!\n");\r\nif (wait)\r\ni2c_wait_for_writes(dd);\r\nreturn bit == i2c_line_high ? 1U : 0;\r\n}\r\nstatic int i2c_ackrcv(struct ipath_devdata *dd)\r\n{\r\nu8 ack_received;\r\nack_received = sda_in(dd, 1);\r\nscl_out(dd, i2c_line_high);\r\nack_received = sda_in(dd, 1) == 0;\r\nscl_out(dd, i2c_line_low);\r\nreturn ack_received;\r\n}\r\nstatic int rd_byte(struct ipath_devdata *dd)\r\n{\r\nint bit_cntr, data;\r\ndata = 0;\r\nfor (bit_cntr = 7; bit_cntr >= 0; --bit_cntr) {\r\ndata <<= 1;\r\nscl_out(dd, i2c_line_high);\r\ndata |= sda_in(dd, 0);\r\nscl_out(dd, i2c_line_low);\r\n}\r\nreturn data;\r\n}\r\nstatic int wr_byte(struct ipath_devdata *dd, u8 data)\r\n{\r\nint bit_cntr;\r\nu8 bit;\r\nfor (bit_cntr = 7; bit_cntr >= 0; bit_cntr--) {\r\nbit = (data >> bit_cntr) & 1;\r\nsda_out(dd, bit);\r\nscl_out(dd, i2c_line_high);\r\nscl_out(dd, i2c_line_low);\r\n}\r\nreturn (!i2c_ackrcv(dd)) ? 1 : 0;\r\n}\r\nstatic void send_ack(struct ipath_devdata *dd)\r\n{\r\nsda_out(dd, i2c_line_low);\r\nscl_out(dd, i2c_line_high);\r\nscl_out(dd, i2c_line_low);\r\nsda_out(dd, i2c_line_high);\r\n}\r\nstatic int i2c_startcmd(struct ipath_devdata *dd, u8 offset_dir)\r\n{\r\nint res;\r\nsda_out(dd, i2c_line_high);\r\nscl_out(dd, i2c_line_high);\r\nsda_out(dd, i2c_line_low);\r\nscl_out(dd, i2c_line_low);\r\nres = wr_byte(dd, offset_dir);\r\nif (res)\r\nipath_cdbg(VERBOSE, "No ack to complete start\n");\r\nreturn res;\r\n}\r\nstatic void stop_cmd(struct ipath_devdata *dd)\r\n{\r\nscl_out(dd, i2c_line_low);\r\nsda_out(dd, i2c_line_low);\r\nscl_out(dd, i2c_line_high);\r\nsda_out(dd, i2c_line_high);\r\nudelay(2);\r\n}\r\nstatic int eeprom_reset(struct ipath_devdata *dd)\r\n{\r\nint clock_cycles_left = 9;\r\nu64 *gpioval = &dd->ipath_gpio_out;\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->ipath_gpio_lock, flags);\r\ndd->ipath_extctrl = ipath_read_kreg64(dd, dd->ipath_kregs->kr_extctrl);\r\n*gpioval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_gpio_out);\r\nspin_unlock_irqrestore(&dd->ipath_gpio_lock, flags);\r\nipath_cdbg(VERBOSE, "Resetting i2c eeprom; initial gpioout reg "\r\n"is %llx\n", (unsigned long long) *gpioval);\r\nscl_out(dd, i2c_line_low);\r\nsda_out(dd, i2c_line_high);\r\nwhile (clock_cycles_left--) {\r\nscl_out(dd, i2c_line_high);\r\nif (sda_in(dd, 0)) {\r\nsda_out(dd, i2c_line_low);\r\nscl_out(dd, i2c_line_low);\r\nscl_out(dd, i2c_line_high);\r\nsda_out(dd, i2c_line_high);\r\nret = 0;\r\ngoto bail;\r\n}\r\nscl_out(dd, i2c_line_low);\r\n}\r\nret = 1;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int i2c_probe(struct ipath_devdata *dd, int devaddr)\r\n{\r\nint ret = 0;\r\nret = eeprom_reset(dd);\r\nif (ret) {\r\nipath_dev_err(dd, "Failed reset probing device 0x%02X\n",\r\ndevaddr);\r\nreturn ret;\r\n}\r\nret = i2c_startcmd(dd, devaddr | READ_CMD);\r\nif (ret)\r\nipath_cdbg(VERBOSE, "Failed startcmd for device 0x%02X\n",\r\ndevaddr);\r\nelse {\r\nint data;\r\ndata = rd_byte(dd);\r\nstop_cmd(dd);\r\nipath_cdbg(VERBOSE, "Response from device 0x%02X\n", devaddr);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct i2c_chain_desc *ipath_i2c_type(struct ipath_devdata *dd)\r\n{\r\nint idx;\r\nidx = dd->ipath_i2c_chain_type - 1;\r\nif (idx >= 0 && idx < (ARRAY_SIZE(i2c_chains) - 1))\r\ngoto done;\r\nidx = 0;\r\nwhile (i2c_chains[idx].probe_dev != IPATH_NO_DEV) {\r\nif (!i2c_probe(dd, i2c_chains[idx].probe_dev))\r\nbreak;\r\n++idx;\r\n}\r\nif (idx == 0)\r\neeprom_reset(dd);\r\nif (i2c_chains[idx].probe_dev == IPATH_NO_DEV)\r\nidx = -1;\r\nelse\r\ndd->ipath_i2c_chain_type = idx + 1;\r\ndone:\r\nreturn (idx >= 0) ? i2c_chains + idx : NULL;\r\n}\r\nstatic int ipath_eeprom_internal_read(struct ipath_devdata *dd,\r\nu8 eeprom_offset, void *buffer, int len)\r\n{\r\nint ret;\r\nstruct i2c_chain_desc *icd;\r\nu8 *bp = buffer;\r\nret = 1;\r\nicd = ipath_i2c_type(dd);\r\nif (!icd)\r\ngoto bail;\r\nif (icd->eeprom_dev == IPATH_NO_DEV) {\r\nipath_cdbg(VERBOSE, "Start command only address\n");\r\neeprom_offset = (eeprom_offset << 1) | READ_CMD;\r\nret = i2c_startcmd(dd, eeprom_offset);\r\n} else {\r\nipath_cdbg(VERBOSE, "Start command uses devaddr\n");\r\nif (i2c_startcmd(dd, icd->eeprom_dev | WRITE_CMD)) {\r\nipath_dbg("Failed EEPROM startcmd\n");\r\nstop_cmd(dd);\r\nret = 1;\r\ngoto bail;\r\n}\r\nret = wr_byte(dd, eeprom_offset);\r\nstop_cmd(dd);\r\nif (ret) {\r\nipath_dev_err(dd, "Failed to write EEPROM address\n");\r\nret = 1;\r\ngoto bail;\r\n}\r\nret = i2c_startcmd(dd, icd->eeprom_dev | READ_CMD);\r\n}\r\nif (ret) {\r\nipath_dbg("Failed startcmd for dev %02X\n", icd->eeprom_dev);\r\nstop_cmd(dd);\r\nret = 1;\r\ngoto bail;\r\n}\r\nwhile (len-- > 0) {\r\n*bp++ = rd_byte(dd);\r\nif (len)\r\nsend_ack(dd);\r\n}\r\nstop_cmd(dd);\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int ipath_eeprom_internal_write(struct ipath_devdata *dd, u8 eeprom_offset,\r\nconst void *buffer, int len)\r\n{\r\nint sub_len;\r\nconst u8 *bp = buffer;\r\nint max_wait_time, i;\r\nint ret;\r\nstruct i2c_chain_desc *icd;\r\nret = 1;\r\nicd = ipath_i2c_type(dd);\r\nif (!icd)\r\ngoto bail;\r\nwhile (len > 0) {\r\nif (icd->eeprom_dev == IPATH_NO_DEV) {\r\nif (i2c_startcmd(dd,\r\n(eeprom_offset << 1) | WRITE_CMD)) {\r\nipath_dbg("Failed to start cmd offset %u\n",\r\neeprom_offset);\r\ngoto failed_write;\r\n}\r\n} else {\r\nif (i2c_startcmd(dd, icd->eeprom_dev | WRITE_CMD)) {\r\nipath_dbg("Failed EEPROM startcmd\n");\r\ngoto failed_write;\r\n}\r\nret = wr_byte(dd, eeprom_offset);\r\nif (ret) {\r\nipath_dev_err(dd, "Failed to write EEPROM "\r\n"address\n");\r\ngoto failed_write;\r\n}\r\n}\r\nsub_len = min(len, 4);\r\neeprom_offset += sub_len;\r\nlen -= sub_len;\r\nfor (i = 0; i < sub_len; i++) {\r\nif (wr_byte(dd, *bp++)) {\r\nipath_dbg("no ack after byte %u/%u (%u "\r\n"total remain)\n", i, sub_len,\r\nlen + sub_len - i);\r\ngoto failed_write;\r\n}\r\n}\r\nstop_cmd(dd);\r\nmax_wait_time = 100;\r\nwhile (i2c_startcmd(dd, icd->eeprom_dev | READ_CMD)) {\r\nstop_cmd(dd);\r\nif (!--max_wait_time) {\r\nipath_dbg("Did not get successful read to "\r\n"complete write\n");\r\ngoto failed_write;\r\n}\r\n}\r\nrd_byte(dd);\r\nstop_cmd(dd);\r\n}\r\nret = 0;\r\ngoto bail;\r\nfailed_write:\r\nstop_cmd(dd);\r\nret = 1;\r\nbail:\r\nreturn ret;\r\n}\r\nint ipath_eeprom_read(struct ipath_devdata *dd, u8 eeprom_offset,\r\nvoid *buff, int len)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&dd->ipath_eep_lock);\r\nif (!ret) {\r\nret = ipath_eeprom_internal_read(dd, eeprom_offset, buff, len);\r\nmutex_unlock(&dd->ipath_eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nint ipath_eeprom_write(struct ipath_devdata *dd, u8 eeprom_offset,\r\nconst void *buff, int len)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&dd->ipath_eep_lock);\r\nif (!ret) {\r\nret = ipath_eeprom_internal_write(dd, eeprom_offset, buff, len);\r\nmutex_unlock(&dd->ipath_eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 flash_csum(struct ipath_flash *ifp, int adjust)\r\n{\r\nu8 *ip = (u8 *) ifp;\r\nu8 csum = 0, len;\r\nlen = ifp->if_length;\r\nif (len > sizeof(struct ipath_flash))\r\nlen = sizeof(struct ipath_flash);\r\nwhile (len--)\r\ncsum += *ip++;\r\ncsum -= ifp->if_csum;\r\ncsum = ~csum;\r\nif (adjust)\r\nifp->if_csum = csum;\r\nreturn csum;\r\n}\r\nvoid ipath_get_eeprom_info(struct ipath_devdata *dd)\r\n{\r\nvoid *buf;\r\nstruct ipath_flash *ifp;\r\n__be64 guid;\r\nint len, eep_stat;\r\nu8 csum, *bguid;\r\nint t = dd->ipath_unit;\r\nstruct ipath_devdata *dd0 = ipath_lookup(0);\r\nif (t && dd0->ipath_nguid > 1 && t <= dd0->ipath_nguid) {\r\nu8 oguid;\r\ndd->ipath_guid = dd0->ipath_guid;\r\nbguid = (u8 *) & dd->ipath_guid;\r\noguid = bguid[7];\r\nbguid[7] += t;\r\nif (oguid > bguid[7]) {\r\nif (bguid[6] == 0xff) {\r\nif (bguid[5] == 0xff) {\r\nipath_dev_err(\r\ndd,\r\n"Can't set %s GUID from "\r\n"base, wraps to OUI!\n",\r\nipath_get_unit_name(t));\r\ndd->ipath_guid = 0;\r\ngoto bail;\r\n}\r\nbguid[5]++;\r\n}\r\nbguid[6]++;\r\n}\r\ndd->ipath_nguid = 1;\r\nipath_dbg("nguid %u, so adding %u to device 0 guid, "\r\n"for %llx\n",\r\ndd0->ipath_nguid, t,\r\n(unsigned long long) be64_to_cpu(dd->ipath_guid));\r\ngoto bail;\r\n}\r\nlen = sizeof(struct ipath_flash);\r\nbuf = vmalloc(len);\r\nif (!buf) {\r\nipath_dev_err(dd, "Couldn't allocate memory to read %u "\r\n"bytes from eeprom for GUID\n", len);\r\ngoto bail;\r\n}\r\nmutex_lock(&dd->ipath_eep_lock);\r\neep_stat = ipath_eeprom_internal_read(dd, 0, buf, len);\r\nmutex_unlock(&dd->ipath_eep_lock);\r\nif (eep_stat) {\r\nipath_dev_err(dd, "Failed reading GUID from eeprom\n");\r\ngoto done;\r\n}\r\nifp = (struct ipath_flash *)buf;\r\ncsum = flash_csum(ifp, 0);\r\nif (csum != ifp->if_csum) {\r\ndev_info(&dd->pcidev->dev, "Bad I2C flash checksum: "\r\n"0x%x, not 0x%x\n", csum, ifp->if_csum);\r\ngoto done;\r\n}\r\nif (*(__be64 *) ifp->if_guid == cpu_to_be64(0) ||\r\n*(__be64 *) ifp->if_guid == ~cpu_to_be64(0)) {\r\nipath_dev_err(dd, "Invalid GUID %llx from flash; "\r\n"ignoring\n",\r\n*(unsigned long long *) ifp->if_guid);\r\ngoto done;\r\n}\r\nif (*(u64 *) ifp->if_guid == 0x100007511000000ULL)\r\ndev_info(&dd->pcidev->dev, "Warning, GUID %llx is "\r\n"default, probably not correct!\n",\r\n*(unsigned long long *) ifp->if_guid);\r\nbguid = ifp->if_guid;\r\nif (!bguid[0] && !bguid[1] && !bguid[2]) {\r\nbguid[1] = bguid[3];\r\nbguid[2] = bguid[4];\r\nbguid[3] = bguid[4] = 0;\r\nguid = *(__be64 *) ifp->if_guid;\r\nipath_cdbg(VERBOSE, "Old GUID format in flash, top 3 zero, "\r\n"shifting 2 octets\n");\r\n} else\r\nguid = *(__be64 *) ifp->if_guid;\r\ndd->ipath_guid = guid;\r\ndd->ipath_nguid = ifp->if_numguid;\r\nif ((ifp->if_fversion > 1) && ifp->if_sprefix[0]\r\n&& ((u8 *)ifp->if_sprefix)[0] != 0xFF) {\r\nchar *snp = dd->ipath_serial;\r\nmemcpy(snp, ifp->if_sprefix, sizeof ifp->if_sprefix);\r\nsnp[sizeof ifp->if_sprefix] = '\0';\r\nlen = strlen(snp);\r\nsnp += len;\r\nlen = (sizeof dd->ipath_serial) - len;\r\nif (len > sizeof ifp->if_serial) {\r\nlen = sizeof ifp->if_serial;\r\n}\r\nmemcpy(snp, ifp->if_serial, len);\r\n} else\r\nmemcpy(dd->ipath_serial, ifp->if_serial,\r\nsizeof ifp->if_serial);\r\nif (!strstr(ifp->if_comment, "Tested successfully"))\r\nipath_dev_err(dd, "Board SN %s did not pass functional "\r\n"test: %s\n", dd->ipath_serial,\r\nifp->if_comment);\r\nipath_cdbg(VERBOSE, "Initted GUID to %llx from eeprom\n",\r\n(unsigned long long) be64_to_cpu(dd->ipath_guid));\r\nmemcpy(&dd->ipath_eep_st_errs, &ifp->if_errcntp, IPATH_EEP_LOG_CNT);\r\natomic_set(&dd->ipath_active_time, 0);\r\ndd->ipath_eep_hrs = ifp->if_powerhour[0] | (ifp->if_powerhour[1] << 8);\r\ndone:\r\nvfree(buf);\r\nbail:;\r\n}\r\nint ipath_update_eeprom_log(struct ipath_devdata *dd)\r\n{\r\nvoid *buf;\r\nstruct ipath_flash *ifp;\r\nint len, hi_water;\r\nuint32_t new_time, new_hrs;\r\nu8 csum;\r\nint ret, idx;\r\nunsigned long flags;\r\nret = 0;\r\nfor (idx = 0; idx < IPATH_EEP_LOG_CNT; ++idx) {\r\nif (dd->ipath_eep_st_new_errs[idx]) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nnew_time = atomic_read(&dd->ipath_active_time);\r\nif (ret == 0 && new_time < 3600)\r\nreturn 0;\r\nlen = sizeof(struct ipath_flash);\r\nbuf = vmalloc(len);\r\nret = 1;\r\nif (!buf) {\r\nipath_dev_err(dd, "Couldn't allocate memory to read %u "\r\n"bytes from eeprom for logging\n", len);\r\ngoto bail;\r\n}\r\nret = mutex_lock_interruptible(&dd->ipath_eep_lock);\r\nif (ret) {\r\nipath_dev_err(dd, "Unable to acquire EEPROM for logging\n");\r\ngoto free_bail;\r\n}\r\nret = ipath_eeprom_internal_read(dd, 0, buf, len);\r\nif (ret) {\r\nmutex_unlock(&dd->ipath_eep_lock);\r\nipath_dev_err(dd, "Unable read EEPROM for logging\n");\r\ngoto free_bail;\r\n}\r\nifp = (struct ipath_flash *)buf;\r\ncsum = flash_csum(ifp, 0);\r\nif (csum != ifp->if_csum) {\r\nmutex_unlock(&dd->ipath_eep_lock);\r\nipath_dev_err(dd, "EEPROM cks err (0x%02X, S/B 0x%02X)\n",\r\ncsum, ifp->if_csum);\r\nret = 1;\r\ngoto free_bail;\r\n}\r\nhi_water = 0;\r\nspin_lock_irqsave(&dd->ipath_eep_st_lock, flags);\r\nfor (idx = 0; idx < IPATH_EEP_LOG_CNT; ++idx) {\r\nint new_val = dd->ipath_eep_st_new_errs[idx];\r\nif (new_val) {\r\nnew_val += ifp->if_errcntp[idx];\r\nif (new_val > 0xFF)\r\nnew_val = 0xFF;\r\nif (ifp->if_errcntp[idx] != new_val) {\r\nifp->if_errcntp[idx] = new_val;\r\nhi_water = offsetof(struct ipath_flash,\r\nif_errcntp) + idx;\r\n}\r\ndd->ipath_eep_st_errs[idx] = new_val;\r\ndd->ipath_eep_st_new_errs[idx] = 0;\r\n}\r\n}\r\nif (new_time >= 3600) {\r\nnew_hrs = new_time / 3600;\r\natomic_sub((new_hrs * 3600), &dd->ipath_active_time);\r\nnew_hrs += dd->ipath_eep_hrs;\r\nif (new_hrs > 0xFFFF)\r\nnew_hrs = 0xFFFF;\r\ndd->ipath_eep_hrs = new_hrs;\r\nif ((new_hrs & 0xFF) != ifp->if_powerhour[0]) {\r\nifp->if_powerhour[0] = new_hrs & 0xFF;\r\nhi_water = offsetof(struct ipath_flash, if_powerhour);\r\n}\r\nif ((new_hrs >> 8) != ifp->if_powerhour[1]) {\r\nifp->if_powerhour[1] = new_hrs >> 8;\r\nhi_water = offsetof(struct ipath_flash, if_powerhour)\r\n+ 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dd->ipath_eep_st_lock, flags);\r\nif (hi_water) {\r\ncsum = flash_csum(ifp, 1);\r\nret = ipath_eeprom_internal_write(dd, 0, buf, hi_water + 1);\r\n}\r\nmutex_unlock(&dd->ipath_eep_lock);\r\nif (ret)\r\nipath_dev_err(dd, "Failed updating EEPROM\n");\r\nfree_bail:\r\nvfree(buf);\r\nbail:\r\nreturn ret;\r\n}\r\nvoid ipath_inc_eeprom_err(struct ipath_devdata *dd, u32 eidx, u32 incr)\r\n{\r\nuint new_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->ipath_eep_st_lock, flags);\r\nnew_val = dd->ipath_eep_st_new_errs[eidx] + incr;\r\nif (new_val > 255)\r\nnew_val = 255;\r\ndd->ipath_eep_st_new_errs[eidx] = new_val;\r\nspin_unlock_irqrestore(&dd->ipath_eep_st_lock, flags);\r\nreturn;\r\n}\r\nstatic int ipath_tempsense_internal_read(struct ipath_devdata *dd, u8 regnum)\r\n{\r\nint ret;\r\nstruct i2c_chain_desc *icd;\r\nret = -ENOENT;\r\nicd = ipath_i2c_type(dd);\r\nif (!icd)\r\ngoto bail;\r\nif (icd->temp_dev == IPATH_NO_DEV) {\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nif (i2c_startcmd(dd, icd->temp_dev | WRITE_CMD)) {\r\nipath_dbg("Failed tempsense startcmd\n");\r\nstop_cmd(dd);\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nret = wr_byte(dd, regnum);\r\nstop_cmd(dd);\r\nif (ret) {\r\nipath_dev_err(dd, "Failed tempsense WR command %02X\n",\r\nregnum);\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nif (i2c_startcmd(dd, icd->temp_dev | READ_CMD)) {\r\nipath_dbg("Failed tempsense RD startcmd\n");\r\nstop_cmd(dd);\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nret = rd_byte(dd);\r\nstop_cmd(dd);\r\nbail:\r\nreturn ret;\r\n}\r\nint ipath_tempsense_read(struct ipath_devdata *dd, u8 regnum)\r\n{\r\nint ret;\r\nif (regnum > 7)\r\nreturn -EINVAL;\r\nif (!((1 << regnum) & VALID_TS_RD_REG_MASK))\r\nreturn 0;\r\nret = mutex_lock_interruptible(&dd->ipath_eep_lock);\r\nif (!ret) {\r\nret = ipath_tempsense_internal_read(dd, regnum);\r\nmutex_unlock(&dd->ipath_eep_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipath_tempsense_internal_write(struct ipath_devdata *dd,\r\nu8 regnum, u8 data)\r\n{\r\nint ret = -ENOENT;\r\nstruct i2c_chain_desc *icd;\r\nicd = ipath_i2c_type(dd);\r\nif (!icd)\r\ngoto bail;\r\nif (icd->temp_dev == IPATH_NO_DEV) {\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nif (i2c_startcmd(dd, icd->temp_dev | WRITE_CMD)) {\r\nipath_dbg("Failed tempsense startcmd\n");\r\nstop_cmd(dd);\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nret = wr_byte(dd, regnum);\r\nif (ret) {\r\nstop_cmd(dd);\r\nipath_dev_err(dd, "Failed to write tempsense command %02X\n",\r\nregnum);\r\nret = -ENXIO;\r\ngoto bail;\r\n}\r\nret = wr_byte(dd, data);\r\nstop_cmd(dd);\r\nret = i2c_startcmd(dd, icd->temp_dev | READ_CMD);\r\nif (ret) {\r\nipath_dev_err(dd, "Failed tempsense data wrt to %02X\n",\r\nregnum);\r\nret = -ENXIO;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nint ipath_tempsense_write(struct ipath_devdata *dd, u8 regnum, u8 data)\r\n{\r\nint ret;\r\nif (regnum > 15 || !((1 << regnum) & VALID_TS_WR_REG_MASK))\r\nreturn -EINVAL;\r\nret = mutex_lock_interruptible(&dd->ipath_eep_lock);\r\nif (!ret) {\r\nret = ipath_tempsense_internal_write(dd, regnum, data);\r\nmutex_unlock(&dd->ipath_eep_lock);\r\n}\r\nreturn ret;\r\n}
