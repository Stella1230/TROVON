static void cmdbuf_add(struct pt3_i2cbuf *cbuf, enum ctl_cmd cmd)\r\n{\r\nint buf_idx;\r\nif ((cbuf->num_cmds % 2) == 0)\r\ncbuf->tmp = cmd;\r\nelse {\r\ncbuf->tmp |= cmd << 4;\r\nbuf_idx = cbuf->num_cmds / 2;\r\nif (buf_idx < ARRAY_SIZE(cbuf->data))\r\ncbuf->data[buf_idx] = cbuf->tmp;\r\n}\r\ncbuf->num_cmds++;\r\n}\r\nstatic void put_end(struct pt3_i2cbuf *cbuf)\r\n{\r\ncmdbuf_add(cbuf, I_END);\r\nif (cbuf->num_cmds % 2)\r\ncmdbuf_add(cbuf, I_END);\r\n}\r\nstatic void put_start(struct pt3_i2cbuf *cbuf)\r\n{\r\ncmdbuf_add(cbuf, I_DATA_H);\r\ncmdbuf_add(cbuf, I_CLOCK_H);\r\ncmdbuf_add(cbuf, I_DATA_L);\r\ncmdbuf_add(cbuf, I_CLOCK_L);\r\n}\r\nstatic void put_byte_write(struct pt3_i2cbuf *cbuf, u8 val)\r\n{\r\nu8 mask;\r\nmask = 0x80;\r\nfor (mask = 0x80; mask > 0; mask >>= 1)\r\ncmdbuf_add(cbuf, (val & mask) ? I_DATA_H_NOP : I_DATA_L_NOP);\r\ncmdbuf_add(cbuf, I_DATA_H_ACK0);\r\n}\r\nstatic void put_byte_read(struct pt3_i2cbuf *cbuf, u32 size)\r\n{\r\nint i, j;\r\nfor (i = 0; i < size; i++) {\r\nfor (j = 0; j < 8; j++)\r\ncmdbuf_add(cbuf, I_DATA_H_READ);\r\ncmdbuf_add(cbuf, (i == size - 1) ? I_DATA_H_NOP : I_DATA_L_NOP);\r\n}\r\n}\r\nstatic void put_stop(struct pt3_i2cbuf *cbuf)\r\n{\r\ncmdbuf_add(cbuf, I_DATA_L);\r\ncmdbuf_add(cbuf, I_CLOCK_H);\r\ncmdbuf_add(cbuf, I_DATA_H);\r\n}\r\nstatic void translate(struct pt3_i2cbuf *cbuf, struct i2c_msg *msgs, int num)\r\n{\r\nint i, j;\r\nbool rd;\r\ncbuf->num_cmds = 0;\r\nfor (i = 0; i < num; i++) {\r\nrd = !!(msgs[i].flags & I2C_M_RD);\r\nput_start(cbuf);\r\nput_byte_write(cbuf, msgs[i].addr << 1 | rd);\r\nif (rd)\r\nput_byte_read(cbuf, msgs[i].len);\r\nelse\r\nfor (j = 0; j < msgs[i].len; j++)\r\nput_byte_write(cbuf, msgs[i].buf[j]);\r\n}\r\nif (num > 0) {\r\nput_stop(cbuf);\r\nput_end(cbuf);\r\n}\r\n}\r\nstatic int wait_i2c_result(struct pt3_board *pt3, u32 *result, int max_wait)\r\n{\r\nint i;\r\nu32 v;\r\nfor (i = 0; i < max_wait; i++) {\r\nv = ioread32(pt3->regs[0] + REG_I2C_R);\r\nif (!(v & STAT_SEQ_RUNNING))\r\nbreak;\r\nusleep_range(500, 750);\r\n}\r\nif (i >= max_wait)\r\nreturn -EIO;\r\nif (result)\r\n*result = v;\r\nreturn 0;\r\n}\r\nstatic int send_i2c_cmd(struct pt3_board *pt3, u32 addr)\r\n{\r\nu32 ret;\r\nif (wait_i2c_result(pt3, NULL, 50)) {\r\ndev_warn(&pt3->pdev->dev, "(%s) prev. transaction stalled\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\niowrite32(PT3_I2C_RUN | addr, pt3->regs[0] + REG_I2C_W);\r\nusleep_range(200, 300);\r\nif (wait_i2c_result(pt3, &ret, 500) || (ret & STAT_SEQ_ERROR)) {\r\ndev_warn(&pt3->pdev->dev, "(%s) failed.\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint pt3_init_all_demods(struct pt3_board *pt3)\r\n{\r\nioread32(pt3->regs[0] + REG_I2C_R);\r\nreturn send_i2c_cmd(pt3, PT3_CMD_ADDR_INIT_DEMOD);\r\n}\r\nint pt3_init_all_mxl301rf(struct pt3_board *pt3)\r\n{\r\nusleep_range(1000, 2000);\r\nreturn send_i2c_cmd(pt3, PT3_CMD_ADDR_INIT_TUNER);\r\n}\r\nvoid pt3_i2c_reset(struct pt3_board *pt3)\r\n{\r\niowrite32(PT3_I2C_RESET, pt3->regs[0] + REG_I2C_W);\r\n}\r\nint\r\npt3_i2c_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct pt3_board *pt3;\r\nstruct pt3_i2cbuf *cbuf;\r\nint i;\r\nvoid __iomem *p;\r\npt3 = i2c_get_adapdata(adap);\r\ncbuf = pt3->i2c_buf;\r\nfor (i = 0; i < num; i++)\r\nif (msgs[i].flags & I2C_M_RECV_LEN) {\r\ndev_warn(&pt3->pdev->dev,\r\n"(%s) I2C_M_RECV_LEN not supported.\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ntranslate(cbuf, msgs, num);\r\nmemcpy_toio(pt3->regs[1] + PT3_I2C_BASE + PT3_CMD_ADDR_NORMAL / 2,\r\ncbuf->data, cbuf->num_cmds);\r\nif (send_i2c_cmd(pt3, PT3_CMD_ADDR_NORMAL) < 0)\r\nreturn -EIO;\r\np = pt3->regs[1] + PT3_I2C_BASE;\r\nfor (i = 0; i < num; i++)\r\nif ((msgs[i].flags & I2C_M_RD) && msgs[i].len > 0) {\r\nmemcpy_fromio(msgs[i].buf, p, msgs[i].len);\r\np += msgs[i].len;\r\n}\r\nreturn num;\r\n}\r\nu32 pt3_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}
