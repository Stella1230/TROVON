static void vfio_send_intx_eventfd(void *opaque, void *unused)\r\n{\r\nstruct vfio_pci_device *vdev = opaque;\r\nif (likely(is_intx(vdev) && !vdev->virq_disabled))\r\neventfd_signal(vdev->ctx[0].trigger, 1);\r\n}\r\nvoid vfio_pci_intx_mask(struct vfio_pci_device *vdev)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vdev->irqlock, flags);\r\nif (unlikely(!is_intx(vdev))) {\r\nif (vdev->pci_2_3)\r\npci_intx(pdev, 0);\r\n} else if (!vdev->ctx[0].masked) {\r\nif (vdev->pci_2_3)\r\npci_intx(pdev, 0);\r\nelse\r\ndisable_irq_nosync(pdev->irq);\r\nvdev->ctx[0].masked = true;\r\n}\r\nspin_unlock_irqrestore(&vdev->irqlock, flags);\r\n}\r\nstatic int vfio_pci_intx_unmask_handler(void *opaque, void *unused)\r\n{\r\nstruct vfio_pci_device *vdev = opaque;\r\nstruct pci_dev *pdev = vdev->pdev;\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&vdev->irqlock, flags);\r\nif (unlikely(!is_intx(vdev))) {\r\nif (vdev->pci_2_3)\r\npci_intx(pdev, 1);\r\n} else if (vdev->ctx[0].masked && !vdev->virq_disabled) {\r\nif (vdev->pci_2_3) {\r\nif (!pci_check_and_unmask_intx(pdev))\r\nret = 1;\r\n} else\r\nenable_irq(pdev->irq);\r\nvdev->ctx[0].masked = (ret > 0);\r\n}\r\nspin_unlock_irqrestore(&vdev->irqlock, flags);\r\nreturn ret;\r\n}\r\nvoid vfio_pci_intx_unmask(struct vfio_pci_device *vdev)\r\n{\r\nif (vfio_pci_intx_unmask_handler(vdev, NULL) > 0)\r\nvfio_send_intx_eventfd(vdev, NULL);\r\n}\r\nstatic irqreturn_t vfio_intx_handler(int irq, void *dev_id)\r\n{\r\nstruct vfio_pci_device *vdev = dev_id;\r\nunsigned long flags;\r\nint ret = IRQ_NONE;\r\nspin_lock_irqsave(&vdev->irqlock, flags);\r\nif (!vdev->pci_2_3) {\r\ndisable_irq_nosync(vdev->pdev->irq);\r\nvdev->ctx[0].masked = true;\r\nret = IRQ_HANDLED;\r\n} else if (!vdev->ctx[0].masked &&\r\npci_check_and_mask_intx(vdev->pdev)) {\r\nvdev->ctx[0].masked = true;\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&vdev->irqlock, flags);\r\nif (ret == IRQ_HANDLED)\r\nvfio_send_intx_eventfd(vdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int vfio_intx_enable(struct vfio_pci_device *vdev)\r\n{\r\nif (!is_irq_none(vdev))\r\nreturn -EINVAL;\r\nif (!vdev->pdev->irq)\r\nreturn -ENODEV;\r\nvdev->ctx = kzalloc(sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\r\nif (!vdev->ctx)\r\nreturn -ENOMEM;\r\nvdev->num_ctx = 1;\r\nvdev->ctx[0].masked = vdev->virq_disabled;\r\nif (vdev->pci_2_3)\r\npci_intx(vdev->pdev, !vdev->ctx[0].masked);\r\nvdev->irq_type = VFIO_PCI_INTX_IRQ_INDEX;\r\nreturn 0;\r\n}\r\nstatic int vfio_intx_set_signal(struct vfio_pci_device *vdev, int fd)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nunsigned long irqflags = IRQF_SHARED;\r\nstruct eventfd_ctx *trigger;\r\nunsigned long flags;\r\nint ret;\r\nif (vdev->ctx[0].trigger) {\r\nfree_irq(pdev->irq, vdev);\r\nkfree(vdev->ctx[0].name);\r\neventfd_ctx_put(vdev->ctx[0].trigger);\r\nvdev->ctx[0].trigger = NULL;\r\n}\r\nif (fd < 0)\r\nreturn 0;\r\nvdev->ctx[0].name = kasprintf(GFP_KERNEL, "vfio-intx(%s)",\r\npci_name(pdev));\r\nif (!vdev->ctx[0].name)\r\nreturn -ENOMEM;\r\ntrigger = eventfd_ctx_fdget(fd);\r\nif (IS_ERR(trigger)) {\r\nkfree(vdev->ctx[0].name);\r\nreturn PTR_ERR(trigger);\r\n}\r\nvdev->ctx[0].trigger = trigger;\r\nif (!vdev->pci_2_3)\r\nirqflags = 0;\r\nret = request_irq(pdev->irq, vfio_intx_handler,\r\nirqflags, vdev->ctx[0].name, vdev);\r\nif (ret) {\r\nvdev->ctx[0].trigger = NULL;\r\nkfree(vdev->ctx[0].name);\r\neventfd_ctx_put(trigger);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&vdev->irqlock, flags);\r\nif (!vdev->pci_2_3 && vdev->ctx[0].masked)\r\ndisable_irq_nosync(pdev->irq);\r\nspin_unlock_irqrestore(&vdev->irqlock, flags);\r\nreturn 0;\r\n}\r\nstatic void vfio_intx_disable(struct vfio_pci_device *vdev)\r\n{\r\nvfio_intx_set_signal(vdev, -1);\r\nvfio_virqfd_disable(&vdev->ctx[0].unmask);\r\nvfio_virqfd_disable(&vdev->ctx[0].mask);\r\nvdev->irq_type = VFIO_PCI_NUM_IRQS;\r\nvdev->num_ctx = 0;\r\nkfree(vdev->ctx);\r\n}\r\nstatic irqreturn_t vfio_msihandler(int irq, void *arg)\r\n{\r\nstruct eventfd_ctx *trigger = arg;\r\neventfd_signal(trigger, 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nint ret;\r\nif (!is_irq_none(vdev))\r\nreturn -EINVAL;\r\nvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\r\nif (!vdev->ctx)\r\nreturn -ENOMEM;\r\nif (msix) {\r\nint i;\r\nvdev->msix = kzalloc(nvec * sizeof(struct msix_entry),\r\nGFP_KERNEL);\r\nif (!vdev->msix) {\r\nkfree(vdev->ctx);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < nvec; i++)\r\nvdev->msix[i].entry = i;\r\nret = pci_enable_msix_range(pdev, vdev->msix, 1, nvec);\r\nif (ret < nvec) {\r\nif (ret > 0)\r\npci_disable_msix(pdev);\r\nkfree(vdev->msix);\r\nkfree(vdev->ctx);\r\nreturn ret;\r\n}\r\n} else {\r\nret = pci_enable_msi_range(pdev, 1, nvec);\r\nif (ret < nvec) {\r\nif (ret > 0)\r\npci_disable_msi(pdev);\r\nkfree(vdev->ctx);\r\nreturn ret;\r\n}\r\n}\r\nvdev->num_ctx = nvec;\r\nvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\r\nVFIO_PCI_MSI_IRQ_INDEX;\r\nif (!msix) {\r\nvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_msi_set_vector_signal(struct vfio_pci_device *vdev,\r\nint vector, int fd, bool msix)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nint irq = msix ? vdev->msix[vector].vector : pdev->irq + vector;\r\nchar *name = msix ? "vfio-msix" : "vfio-msi";\r\nstruct eventfd_ctx *trigger;\r\nint ret;\r\nif (vector >= vdev->num_ctx)\r\nreturn -EINVAL;\r\nif (vdev->ctx[vector].trigger) {\r\nfree_irq(irq, vdev->ctx[vector].trigger);\r\nkfree(vdev->ctx[vector].name);\r\neventfd_ctx_put(vdev->ctx[vector].trigger);\r\nvdev->ctx[vector].trigger = NULL;\r\n}\r\nif (fd < 0)\r\nreturn 0;\r\nvdev->ctx[vector].name = kasprintf(GFP_KERNEL, "%s[%d](%s)",\r\nname, vector, pci_name(pdev));\r\nif (!vdev->ctx[vector].name)\r\nreturn -ENOMEM;\r\ntrigger = eventfd_ctx_fdget(fd);\r\nif (IS_ERR(trigger)) {\r\nkfree(vdev->ctx[vector].name);\r\nreturn PTR_ERR(trigger);\r\n}\r\nif (msix) {\r\nstruct msi_msg msg;\r\nget_cached_msi_msg(irq, &msg);\r\npci_write_msi_msg(irq, &msg);\r\n}\r\nret = request_irq(irq, vfio_msihandler, 0,\r\nvdev->ctx[vector].name, trigger);\r\nif (ret) {\r\nkfree(vdev->ctx[vector].name);\r\neventfd_ctx_put(trigger);\r\nreturn ret;\r\n}\r\nvdev->ctx[vector].trigger = trigger;\r\nreturn 0;\r\n}\r\nstatic int vfio_msi_set_block(struct vfio_pci_device *vdev, unsigned start,\r\nunsigned count, int32_t *fds, bool msix)\r\n{\r\nint i, j, ret = 0;\r\nif (start + count > vdev->num_ctx)\r\nreturn -EINVAL;\r\nfor (i = 0, j = start; i < count && !ret; i++, j++) {\r\nint fd = fds ? fds[i] : -1;\r\nret = vfio_msi_set_vector_signal(vdev, j, fd, msix);\r\n}\r\nif (ret) {\r\nfor (--j; j >= start; j--)\r\nvfio_msi_set_vector_signal(vdev, j, -1, msix);\r\n}\r\nreturn ret;\r\n}\r\nstatic void vfio_msi_disable(struct vfio_pci_device *vdev, bool msix)\r\n{\r\nstruct pci_dev *pdev = vdev->pdev;\r\nint i;\r\nvfio_msi_set_block(vdev, 0, vdev->num_ctx, NULL, msix);\r\nfor (i = 0; i < vdev->num_ctx; i++) {\r\nvfio_virqfd_disable(&vdev->ctx[i].unmask);\r\nvfio_virqfd_disable(&vdev->ctx[i].mask);\r\n}\r\nif (msix) {\r\npci_disable_msix(vdev->pdev);\r\nkfree(vdev->msix);\r\n} else\r\npci_disable_msi(pdev);\r\nvdev->irq_type = VFIO_PCI_NUM_IRQS;\r\nvdev->num_ctx = 0;\r\nkfree(vdev->ctx);\r\n}\r\nstatic int vfio_pci_set_intx_unmask(struct vfio_pci_device *vdev,\r\nunsigned index, unsigned start,\r\nunsigned count, uint32_t flags, void *data)\r\n{\r\nif (!is_intx(vdev) || start != 0 || count != 1)\r\nreturn -EINVAL;\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\nvfio_pci_intx_unmask(vdev);\r\n} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\r\nuint8_t unmask = *(uint8_t *)data;\r\nif (unmask)\r\nvfio_pci_intx_unmask(vdev);\r\n} else if (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\r\nint32_t fd = *(int32_t *)data;\r\nif (fd >= 0)\r\nreturn vfio_virqfd_enable((void *) vdev,\r\nvfio_pci_intx_unmask_handler,\r\nvfio_send_intx_eventfd, NULL,\r\n&vdev->ctx[0].unmask, fd);\r\nvfio_virqfd_disable(&vdev->ctx[0].unmask);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_pci_set_intx_mask(struct vfio_pci_device *vdev,\r\nunsigned index, unsigned start,\r\nunsigned count, uint32_t flags, void *data)\r\n{\r\nif (!is_intx(vdev) || start != 0 || count != 1)\r\nreturn -EINVAL;\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\nvfio_pci_intx_mask(vdev);\r\n} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\r\nuint8_t mask = *(uint8_t *)data;\r\nif (mask)\r\nvfio_pci_intx_mask(vdev);\r\n} else if (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_pci_set_intx_trigger(struct vfio_pci_device *vdev,\r\nunsigned index, unsigned start,\r\nunsigned count, uint32_t flags, void *data)\r\n{\r\nif (is_intx(vdev) && !count && (flags & VFIO_IRQ_SET_DATA_NONE)) {\r\nvfio_intx_disable(vdev);\r\nreturn 0;\r\n}\r\nif (!(is_intx(vdev) || is_irq_none(vdev)) || start != 0 || count != 1)\r\nreturn -EINVAL;\r\nif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\r\nint32_t fd = *(int32_t *)data;\r\nint ret;\r\nif (is_intx(vdev))\r\nreturn vfio_intx_set_signal(vdev, fd);\r\nret = vfio_intx_enable(vdev);\r\nif (ret)\r\nreturn ret;\r\nret = vfio_intx_set_signal(vdev, fd);\r\nif (ret)\r\nvfio_intx_disable(vdev);\r\nreturn ret;\r\n}\r\nif (!is_intx(vdev))\r\nreturn -EINVAL;\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\nvfio_send_intx_eventfd(vdev, NULL);\r\n} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\r\nuint8_t trigger = *(uint8_t *)data;\r\nif (trigger)\r\nvfio_send_intx_eventfd(vdev, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_pci_set_msi_trigger(struct vfio_pci_device *vdev,\r\nunsigned index, unsigned start,\r\nunsigned count, uint32_t flags, void *data)\r\n{\r\nint i;\r\nbool msix = (index == VFIO_PCI_MSIX_IRQ_INDEX) ? true : false;\r\nif (irq_is(vdev, index) && !count && (flags & VFIO_IRQ_SET_DATA_NONE)) {\r\nvfio_msi_disable(vdev, msix);\r\nreturn 0;\r\n}\r\nif (!(irq_is(vdev, index) || is_irq_none(vdev)))\r\nreturn -EINVAL;\r\nif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\r\nint32_t *fds = data;\r\nint ret;\r\nif (vdev->irq_type == index)\r\nreturn vfio_msi_set_block(vdev, start, count,\r\nfds, msix);\r\nret = vfio_msi_enable(vdev, start + count, msix);\r\nif (ret)\r\nreturn ret;\r\nret = vfio_msi_set_block(vdev, start, count, fds, msix);\r\nif (ret)\r\nvfio_msi_disable(vdev, msix);\r\nreturn ret;\r\n}\r\nif (!irq_is(vdev, index) || start + count > vdev->num_ctx)\r\nreturn -EINVAL;\r\nfor (i = start; i < start + count; i++) {\r\nif (!vdev->ctx[i].trigger)\r\ncontinue;\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\neventfd_signal(vdev->ctx[i].trigger, 1);\r\n} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\r\nuint8_t *bools = data;\r\nif (bools[i - start])\r\neventfd_signal(vdev->ctx[i].trigger, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vfio_pci_set_ctx_trigger_single(struct eventfd_ctx **ctx,\r\nuint32_t flags, void *data)\r\n{\r\nint32_t fd = *(int32_t *)data;\r\nif (!(flags & VFIO_IRQ_SET_DATA_TYPE_MASK))\r\nreturn -EINVAL;\r\nif (flags & VFIO_IRQ_SET_DATA_NONE) {\r\nif (*ctx)\r\neventfd_signal(*ctx, 1);\r\nreturn 0;\r\n} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\r\nuint8_t trigger = *(uint8_t *)data;\r\nif (trigger && *ctx)\r\neventfd_signal(*ctx, 1);\r\nreturn 0;\r\n}\r\nif (fd == -1) {\r\nif (*ctx)\r\neventfd_ctx_put(*ctx);\r\n*ctx = NULL;\r\nreturn 0;\r\n} else if (fd >= 0) {\r\nstruct eventfd_ctx *efdctx;\r\nefdctx = eventfd_ctx_fdget(fd);\r\nif (IS_ERR(efdctx))\r\nreturn PTR_ERR(efdctx);\r\nif (*ctx)\r\neventfd_ctx_put(*ctx);\r\n*ctx = efdctx;\r\nreturn 0;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic int vfio_pci_set_err_trigger(struct vfio_pci_device *vdev,\r\nunsigned index, unsigned start,\r\nunsigned count, uint32_t flags, void *data)\r\n{\r\nif (index != VFIO_PCI_ERR_IRQ_INDEX)\r\nreturn -EINVAL;\r\nreturn vfio_pci_set_ctx_trigger_single(&vdev->err_trigger, flags, data);\r\n}\r\nstatic int vfio_pci_set_req_trigger(struct vfio_pci_device *vdev,\r\nunsigned index, unsigned start,\r\nunsigned count, uint32_t flags, void *data)\r\n{\r\nif (index != VFIO_PCI_REQ_IRQ_INDEX || start != 0 || count != 1)\r\nreturn -EINVAL;\r\nreturn vfio_pci_set_ctx_trigger_single(&vdev->req_trigger, flags, data);\r\n}\r\nint vfio_pci_set_irqs_ioctl(struct vfio_pci_device *vdev, uint32_t flags,\r\nunsigned index, unsigned start, unsigned count,\r\nvoid *data)\r\n{\r\nint (*func)(struct vfio_pci_device *vdev, unsigned index,\r\nunsigned start, unsigned count, uint32_t flags,\r\nvoid *data) = NULL;\r\nswitch (index) {\r\ncase VFIO_PCI_INTX_IRQ_INDEX:\r\nswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\r\ncase VFIO_IRQ_SET_ACTION_MASK:\r\nfunc = vfio_pci_set_intx_mask;\r\nbreak;\r\ncase VFIO_IRQ_SET_ACTION_UNMASK:\r\nfunc = vfio_pci_set_intx_unmask;\r\nbreak;\r\ncase VFIO_IRQ_SET_ACTION_TRIGGER:\r\nfunc = vfio_pci_set_intx_trigger;\r\nbreak;\r\n}\r\nbreak;\r\ncase VFIO_PCI_MSI_IRQ_INDEX:\r\ncase VFIO_PCI_MSIX_IRQ_INDEX:\r\nswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\r\ncase VFIO_IRQ_SET_ACTION_MASK:\r\ncase VFIO_IRQ_SET_ACTION_UNMASK:\r\nbreak;\r\ncase VFIO_IRQ_SET_ACTION_TRIGGER:\r\nfunc = vfio_pci_set_msi_trigger;\r\nbreak;\r\n}\r\nbreak;\r\ncase VFIO_PCI_ERR_IRQ_INDEX:\r\nswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\r\ncase VFIO_IRQ_SET_ACTION_TRIGGER:\r\nif (pci_is_pcie(vdev->pdev))\r\nfunc = vfio_pci_set_err_trigger;\r\nbreak;\r\n}\r\nbreak;\r\ncase VFIO_PCI_REQ_IRQ_INDEX:\r\nswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\r\ncase VFIO_IRQ_SET_ACTION_TRIGGER:\r\nfunc = vfio_pci_set_req_trigger;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (!func)\r\nreturn -ENOTTY;\r\nreturn func(vdev, index, start, count, flags, data);\r\n}
