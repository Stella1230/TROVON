u32 temac_ior(struct temac_local *lp, int offset)\r\n{\r\nreturn in_be32(lp->regs + offset);\r\n}\r\nvoid temac_iow(struct temac_local *lp, int offset, u32 value)\r\n{\r\nout_be32(lp->regs + offset, value);\r\n}\r\nint temac_indirect_busywait(struct temac_local *lp)\r\n{\r\nunsigned long end = jiffies + 2;\r\nwhile (!(temac_ior(lp, XTE_RDY0_OFFSET) & XTE_RDY0_HARD_ACS_RDY_MASK)) {\r\nif (time_before_eq(end, jiffies)) {\r\nWARN_ON(1);\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nu32 temac_indirect_in32(struct temac_local *lp, int reg)\r\n{\r\nu32 val;\r\nif (temac_indirect_busywait(lp))\r\nreturn -ETIMEDOUT;\r\ntemac_iow(lp, XTE_CTL0_OFFSET, reg);\r\nif (temac_indirect_busywait(lp))\r\nreturn -ETIMEDOUT;\r\nval = temac_ior(lp, XTE_LSW0_OFFSET);\r\nreturn val;\r\n}\r\nvoid temac_indirect_out32(struct temac_local *lp, int reg, u32 value)\r\n{\r\nif (temac_indirect_busywait(lp))\r\nreturn;\r\ntemac_iow(lp, XTE_LSW0_OFFSET, value);\r\ntemac_iow(lp, XTE_CTL0_OFFSET, CNTLREG_WRITE_ENABLE_MASK | reg);\r\ntemac_indirect_busywait(lp);\r\n}\r\nstatic u32 temac_dma_in32(struct temac_local *lp, int reg)\r\n{\r\nreturn in_be32(lp->sdma_regs + (reg << 2));\r\n}\r\nstatic void temac_dma_out32(struct temac_local *lp, int reg, u32 value)\r\n{\r\nout_be32(lp->sdma_regs + (reg << 2), value);\r\n}\r\nstatic u32 temac_dma_dcr_in(struct temac_local *lp, int reg)\r\n{\r\nreturn dcr_read(lp->sdma_dcrs, reg);\r\n}\r\nstatic void temac_dma_dcr_out(struct temac_local *lp, int reg, u32 value)\r\n{\r\ndcr_write(lp->sdma_dcrs, reg, value);\r\n}\r\nstatic int temac_dcr_setup(struct temac_local *lp, struct platform_device *op,\r\nstruct device_node *np)\r\n{\r\nunsigned int dcrs;\r\ndcrs = dcr_resource_start(np, 0);\r\nif (dcrs != 0) {\r\nlp->sdma_dcrs = dcr_map(np, dcrs, dcr_resource_len(np, 0));\r\nlp->dma_in = temac_dma_dcr_in;\r\nlp->dma_out = temac_dma_dcr_out;\r\ndev_dbg(&op->dev, "DCR base: %x\n", dcrs);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int temac_dcr_setup(struct temac_local *lp, struct platform_device *op,\r\nstruct device_node *np)\r\n{\r\nreturn -1;\r\n}\r\nstatic void temac_dma_bd_release(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nint i;\r\nlp->dma_out(lp, DMA_CONTROL_REG, DMA_CONTROL_RST);\r\nfor (i = 0; i < RX_BD_NUM; i++) {\r\nif (!lp->rx_skb[i])\r\nbreak;\r\nelse {\r\ndma_unmap_single(ndev->dev.parent, lp->rx_bd_v[i].phys,\r\nXTE_MAX_JUMBO_FRAME_SIZE, DMA_FROM_DEVICE);\r\ndev_kfree_skb(lp->rx_skb[i]);\r\n}\r\n}\r\nif (lp->rx_bd_v)\r\ndma_free_coherent(ndev->dev.parent,\r\nsizeof(*lp->rx_bd_v) * RX_BD_NUM,\r\nlp->rx_bd_v, lp->rx_bd_p);\r\nif (lp->tx_bd_v)\r\ndma_free_coherent(ndev->dev.parent,\r\nsizeof(*lp->tx_bd_v) * TX_BD_NUM,\r\nlp->tx_bd_v, lp->tx_bd_p);\r\nkfree(lp->rx_skb);\r\n}\r\nstatic int temac_dma_bd_init(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nstruct sk_buff *skb;\r\nint i;\r\nlp->rx_skb = kcalloc(RX_BD_NUM, sizeof(*lp->rx_skb), GFP_KERNEL);\r\nif (!lp->rx_skb)\r\ngoto out;\r\nlp->tx_bd_v = dma_zalloc_coherent(ndev->dev.parent,\r\nsizeof(*lp->tx_bd_v) * TX_BD_NUM,\r\n&lp->tx_bd_p, GFP_KERNEL);\r\nif (!lp->tx_bd_v)\r\ngoto out;\r\nlp->rx_bd_v = dma_zalloc_coherent(ndev->dev.parent,\r\nsizeof(*lp->rx_bd_v) * RX_BD_NUM,\r\n&lp->rx_bd_p, GFP_KERNEL);\r\nif (!lp->rx_bd_v)\r\ngoto out;\r\nfor (i = 0; i < TX_BD_NUM; i++) {\r\nlp->tx_bd_v[i].next = lp->tx_bd_p +\r\nsizeof(*lp->tx_bd_v) * ((i + 1) % TX_BD_NUM);\r\n}\r\nfor (i = 0; i < RX_BD_NUM; i++) {\r\nlp->rx_bd_v[i].next = lp->rx_bd_p +\r\nsizeof(*lp->rx_bd_v) * ((i + 1) % RX_BD_NUM);\r\nskb = netdev_alloc_skb_ip_align(ndev,\r\nXTE_MAX_JUMBO_FRAME_SIZE);\r\nif (!skb)\r\ngoto out;\r\nlp->rx_skb[i] = skb;\r\nlp->rx_bd_v[i].phys = dma_map_single(ndev->dev.parent,\r\nskb->data,\r\nXTE_MAX_JUMBO_FRAME_SIZE,\r\nDMA_FROM_DEVICE);\r\nlp->rx_bd_v[i].len = XTE_MAX_JUMBO_FRAME_SIZE;\r\nlp->rx_bd_v[i].app0 = STS_CTRL_APP0_IRQONEND;\r\n}\r\nlp->dma_out(lp, TX_CHNL_CTRL, 0x10220400 |\r\nCHNL_CTRL_IRQ_EN |\r\nCHNL_CTRL_IRQ_DLY_EN |\r\nCHNL_CTRL_IRQ_COAL_EN);\r\nlp->dma_out(lp, RX_CHNL_CTRL, 0xff070000 |\r\nCHNL_CTRL_IRQ_EN |\r\nCHNL_CTRL_IRQ_DLY_EN |\r\nCHNL_CTRL_IRQ_COAL_EN |\r\nCHNL_CTRL_IRQ_IOE);\r\nlp->dma_out(lp, RX_CURDESC_PTR, lp->rx_bd_p);\r\nlp->dma_out(lp, RX_TAILDESC_PTR,\r\nlp->rx_bd_p + (sizeof(*lp->rx_bd_v) * (RX_BD_NUM - 1)));\r\nlp->dma_out(lp, TX_CURDESC_PTR, lp->tx_bd_p);\r\nlp->tx_bd_ci = 0;\r\nlp->tx_bd_next = 0;\r\nlp->tx_bd_tail = 0;\r\nlp->rx_bd_ci = 0;\r\nreturn 0;\r\nout:\r\ntemac_dma_bd_release(ndev);\r\nreturn -ENOMEM;\r\n}\r\nstatic void temac_do_set_mac_address(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nmutex_lock(&lp->indirect_mutex);\r\ntemac_indirect_out32(lp, XTE_UAW0_OFFSET,\r\n(ndev->dev_addr[0]) |\r\n(ndev->dev_addr[1] << 8) |\r\n(ndev->dev_addr[2] << 16) |\r\n(ndev->dev_addr[3] << 24));\r\ntemac_indirect_out32(lp, XTE_UAW1_OFFSET,\r\n(ndev->dev_addr[4] & 0x000000ff) |\r\n(ndev->dev_addr[5] << 8));\r\nmutex_unlock(&lp->indirect_mutex);\r\n}\r\nstatic int temac_init_mac_address(struct net_device *ndev, void *address)\r\n{\r\nmemcpy(ndev->dev_addr, address, ETH_ALEN);\r\nif (!is_valid_ether_addr(ndev->dev_addr))\r\neth_hw_addr_random(ndev);\r\ntemac_do_set_mac_address(ndev);\r\nreturn 0;\r\n}\r\nstatic int temac_set_mac_address(struct net_device *ndev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);\r\ntemac_do_set_mac_address(ndev);\r\nreturn 0;\r\n}\r\nstatic void temac_set_multicast_list(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nu32 multi_addr_msw, multi_addr_lsw, val;\r\nint i;\r\nmutex_lock(&lp->indirect_mutex);\r\nif (ndev->flags & (IFF_ALLMULTI | IFF_PROMISC) ||\r\nnetdev_mc_count(ndev) > MULTICAST_CAM_TABLE_NUM) {\r\nndev->flags |= IFF_PROMISC;\r\ntemac_indirect_out32(lp, XTE_AFM_OFFSET, XTE_AFM_EPPRM_MASK);\r\ndev_info(&ndev->dev, "Promiscuous mode enabled.\n");\r\n} else if (!netdev_mc_empty(ndev)) {\r\nstruct netdev_hw_addr *ha;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, ndev) {\r\nif (i >= MULTICAST_CAM_TABLE_NUM)\r\nbreak;\r\nmulti_addr_msw = ((ha->addr[3] << 24) |\r\n(ha->addr[2] << 16) |\r\n(ha->addr[1] << 8) |\r\n(ha->addr[0]));\r\ntemac_indirect_out32(lp, XTE_MAW0_OFFSET,\r\nmulti_addr_msw);\r\nmulti_addr_lsw = ((ha->addr[5] << 8) |\r\n(ha->addr[4]) | (i << 16));\r\ntemac_indirect_out32(lp, XTE_MAW1_OFFSET,\r\nmulti_addr_lsw);\r\ni++;\r\n}\r\n} else {\r\nval = temac_indirect_in32(lp, XTE_AFM_OFFSET);\r\ntemac_indirect_out32(lp, XTE_AFM_OFFSET,\r\nval & ~XTE_AFM_EPPRM_MASK);\r\ntemac_indirect_out32(lp, XTE_MAW0_OFFSET, 0);\r\ntemac_indirect_out32(lp, XTE_MAW1_OFFSET, 0);\r\ndev_info(&ndev->dev, "Promiscuous mode disabled.\n");\r\n}\r\nmutex_unlock(&lp->indirect_mutex);\r\n}\r\nstatic u32 temac_setoptions(struct net_device *ndev, u32 options)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nstruct temac_option *tp = &temac_options[0];\r\nint reg;\r\nmutex_lock(&lp->indirect_mutex);\r\nwhile (tp->opt) {\r\nreg = temac_indirect_in32(lp, tp->reg) & ~tp->m_or;\r\nif (options & tp->opt)\r\nreg |= tp->m_or;\r\ntemac_indirect_out32(lp, tp->reg, reg);\r\ntp++;\r\n}\r\nlp->options |= options;\r\nmutex_unlock(&lp->indirect_mutex);\r\nreturn 0;\r\n}\r\nstatic void temac_device_reset(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nu32 timeout;\r\nu32 val;\r\ndev_dbg(&ndev->dev, "%s()\n", __func__);\r\nmutex_lock(&lp->indirect_mutex);\r\ntemac_indirect_out32(lp, XTE_RXC1_OFFSET, XTE_RXC1_RXRST_MASK);\r\ntimeout = 1000;\r\nwhile (temac_indirect_in32(lp, XTE_RXC1_OFFSET) & XTE_RXC1_RXRST_MASK) {\r\nudelay(1);\r\nif (--timeout == 0) {\r\ndev_err(&ndev->dev,\r\n"temac_device_reset RX reset timeout!!\n");\r\nbreak;\r\n}\r\n}\r\ntemac_indirect_out32(lp, XTE_TXC_OFFSET, XTE_TXC_TXRST_MASK);\r\ntimeout = 1000;\r\nwhile (temac_indirect_in32(lp, XTE_TXC_OFFSET) & XTE_TXC_TXRST_MASK) {\r\nudelay(1);\r\nif (--timeout == 0) {\r\ndev_err(&ndev->dev,\r\n"temac_device_reset TX reset timeout!!\n");\r\nbreak;\r\n}\r\n}\r\nval = temac_indirect_in32(lp, XTE_RXC1_OFFSET);\r\ntemac_indirect_out32(lp, XTE_RXC1_OFFSET, val & ~XTE_RXC1_RXEN_MASK);\r\nlp->dma_out(lp, DMA_CONTROL_REG, DMA_CONTROL_RST);\r\ntimeout = 1000;\r\nwhile (lp->dma_in(lp, DMA_CONTROL_REG) & DMA_CONTROL_RST) {\r\nudelay(1);\r\nif (--timeout == 0) {\r\ndev_err(&ndev->dev,\r\n"temac_device_reset DMA reset timeout!!\n");\r\nbreak;\r\n}\r\n}\r\nlp->dma_out(lp, DMA_CONTROL_REG, DMA_TAIL_ENABLE);\r\nif (temac_dma_bd_init(ndev)) {\r\ndev_err(&ndev->dev,\r\n"temac_device_reset descriptor allocation failed\n");\r\n}\r\ntemac_indirect_out32(lp, XTE_RXC0_OFFSET, 0);\r\ntemac_indirect_out32(lp, XTE_RXC1_OFFSET, 0);\r\ntemac_indirect_out32(lp, XTE_TXC_OFFSET, 0);\r\ntemac_indirect_out32(lp, XTE_FCC_OFFSET, XTE_FCC_RXFLO_MASK);\r\nmutex_unlock(&lp->indirect_mutex);\r\ntemac_setoptions(ndev,\r\nlp->options & ~(XTE_OPTION_TXEN | XTE_OPTION_RXEN));\r\ntemac_do_set_mac_address(ndev);\r\ntemac_set_multicast_list(ndev);\r\nif (temac_setoptions(ndev, lp->options))\r\ndev_err(&ndev->dev, "Error setting TEMAC options\n");\r\nndev->trans_start = jiffies;\r\n}\r\nstatic void temac_adjust_link(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nstruct phy_device *phy = lp->phy_dev;\r\nu32 mii_speed;\r\nint link_state;\r\nlink_state = phy->speed | (phy->duplex << 1) | phy->link;\r\nmutex_lock(&lp->indirect_mutex);\r\nif (lp->last_link != link_state) {\r\nmii_speed = temac_indirect_in32(lp, XTE_EMCFG_OFFSET);\r\nmii_speed &= ~XTE_EMCFG_LINKSPD_MASK;\r\nswitch (phy->speed) {\r\ncase SPEED_1000: mii_speed |= XTE_EMCFG_LINKSPD_1000; break;\r\ncase SPEED_100: mii_speed |= XTE_EMCFG_LINKSPD_100; break;\r\ncase SPEED_10: mii_speed |= XTE_EMCFG_LINKSPD_10; break;\r\n}\r\ntemac_indirect_out32(lp, XTE_EMCFG_OFFSET, mii_speed);\r\nlp->last_link = link_state;\r\nphy_print_status(phy);\r\n}\r\nmutex_unlock(&lp->indirect_mutex);\r\n}\r\nstatic void temac_start_xmit_done(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nstruct cdmac_bd *cur_p;\r\nunsigned int stat = 0;\r\ncur_p = &lp->tx_bd_v[lp->tx_bd_ci];\r\nstat = cur_p->app0;\r\nwhile (stat & STS_CTRL_APP0_CMPLT) {\r\ndma_unmap_single(ndev->dev.parent, cur_p->phys, cur_p->len,\r\nDMA_TO_DEVICE);\r\nif (cur_p->app4)\r\ndev_kfree_skb_irq((struct sk_buff *)cur_p->app4);\r\ncur_p->app0 = 0;\r\ncur_p->app1 = 0;\r\ncur_p->app2 = 0;\r\ncur_p->app3 = 0;\r\ncur_p->app4 = 0;\r\nndev->stats.tx_packets++;\r\nndev->stats.tx_bytes += cur_p->len;\r\nlp->tx_bd_ci++;\r\nif (lp->tx_bd_ci >= TX_BD_NUM)\r\nlp->tx_bd_ci = 0;\r\ncur_p = &lp->tx_bd_v[lp->tx_bd_ci];\r\nstat = cur_p->app0;\r\n}\r\nnetif_wake_queue(ndev);\r\n}\r\nstatic inline int temac_check_tx_bd_space(struct temac_local *lp, int num_frag)\r\n{\r\nstruct cdmac_bd *cur_p;\r\nint tail;\r\ntail = lp->tx_bd_tail;\r\ncur_p = &lp->tx_bd_v[tail];\r\ndo {\r\nif (cur_p->app0)\r\nreturn NETDEV_TX_BUSY;\r\ntail++;\r\nif (tail >= TX_BD_NUM)\r\ntail = 0;\r\ncur_p = &lp->tx_bd_v[tail];\r\nnum_frag--;\r\n} while (num_frag >= 0);\r\nreturn 0;\r\n}\r\nstatic int temac_start_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nstruct cdmac_bd *cur_p;\r\ndma_addr_t start_p, tail_p;\r\nint ii;\r\nunsigned long num_frag;\r\nskb_frag_t *frag;\r\nnum_frag = skb_shinfo(skb)->nr_frags;\r\nfrag = &skb_shinfo(skb)->frags[0];\r\nstart_p = lp->tx_bd_p + sizeof(*lp->tx_bd_v) * lp->tx_bd_tail;\r\ncur_p = &lp->tx_bd_v[lp->tx_bd_tail];\r\nif (temac_check_tx_bd_space(lp, num_frag)) {\r\nif (!netif_queue_stopped(ndev))\r\nnetif_stop_queue(ndev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ncur_p->app0 = 0;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nunsigned int csum_start_off = skb_checksum_start_offset(skb);\r\nunsigned int csum_index_off = csum_start_off + skb->csum_offset;\r\ncur_p->app0 |= 1;\r\ncur_p->app1 = (csum_start_off << 16) | csum_index_off;\r\ncur_p->app2 = 0;\r\n}\r\ncur_p->app0 |= STS_CTRL_APP0_SOP;\r\ncur_p->len = skb_headlen(skb);\r\ncur_p->phys = dma_map_single(ndev->dev.parent, skb->data,\r\nskb_headlen(skb), DMA_TO_DEVICE);\r\ncur_p->app4 = (unsigned long)skb;\r\nfor (ii = 0; ii < num_frag; ii++) {\r\nlp->tx_bd_tail++;\r\nif (lp->tx_bd_tail >= TX_BD_NUM)\r\nlp->tx_bd_tail = 0;\r\ncur_p = &lp->tx_bd_v[lp->tx_bd_tail];\r\ncur_p->phys = dma_map_single(ndev->dev.parent,\r\nskb_frag_address(frag),\r\nskb_frag_size(frag), DMA_TO_DEVICE);\r\ncur_p->len = skb_frag_size(frag);\r\ncur_p->app0 = 0;\r\nfrag++;\r\n}\r\ncur_p->app0 |= STS_CTRL_APP0_EOP;\r\ntail_p = lp->tx_bd_p + sizeof(*lp->tx_bd_v) * lp->tx_bd_tail;\r\nlp->tx_bd_tail++;\r\nif (lp->tx_bd_tail >= TX_BD_NUM)\r\nlp->tx_bd_tail = 0;\r\nskb_tx_timestamp(skb);\r\nlp->dma_out(lp, TX_TAILDESC_PTR, tail_p);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ll_temac_recv(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nstruct sk_buff *skb, *new_skb;\r\nunsigned int bdstat;\r\nstruct cdmac_bd *cur_p;\r\ndma_addr_t tail_p;\r\nint length;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->rx_lock, flags);\r\ntail_p = lp->rx_bd_p + sizeof(*lp->rx_bd_v) * lp->rx_bd_ci;\r\ncur_p = &lp->rx_bd_v[lp->rx_bd_ci];\r\nbdstat = cur_p->app0;\r\nwhile ((bdstat & STS_CTRL_APP0_CMPLT)) {\r\nskb = lp->rx_skb[lp->rx_bd_ci];\r\nlength = cur_p->app4 & 0x3FFF;\r\ndma_unmap_single(ndev->dev.parent, cur_p->phys, length,\r\nDMA_FROM_DEVICE);\r\nskb_put(skb, length);\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nskb_checksum_none_assert(skb);\r\nif (((lp->temac_features & TEMAC_FEATURE_RX_CSUM) != 0) &&\r\n(skb->protocol == htons(ETH_P_IP)) &&\r\n(skb->len > 64)) {\r\nskb->csum = cur_p->app3 & 0xFFFF;\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\nif (!skb_defer_rx_timestamp(skb))\r\nnetif_rx(skb);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += length;\r\nnew_skb = netdev_alloc_skb_ip_align(ndev,\r\nXTE_MAX_JUMBO_FRAME_SIZE);\r\nif (!new_skb) {\r\nspin_unlock_irqrestore(&lp->rx_lock, flags);\r\nreturn;\r\n}\r\ncur_p->app0 = STS_CTRL_APP0_IRQONEND;\r\ncur_p->phys = dma_map_single(ndev->dev.parent, new_skb->data,\r\nXTE_MAX_JUMBO_FRAME_SIZE,\r\nDMA_FROM_DEVICE);\r\ncur_p->len = XTE_MAX_JUMBO_FRAME_SIZE;\r\nlp->rx_skb[lp->rx_bd_ci] = new_skb;\r\nlp->rx_bd_ci++;\r\nif (lp->rx_bd_ci >= RX_BD_NUM)\r\nlp->rx_bd_ci = 0;\r\ncur_p = &lp->rx_bd_v[lp->rx_bd_ci];\r\nbdstat = cur_p->app0;\r\n}\r\nlp->dma_out(lp, RX_TAILDESC_PTR, tail_p);\r\nspin_unlock_irqrestore(&lp->rx_lock, flags);\r\n}\r\nstatic irqreturn_t ll_temac_tx_irq(int irq, void *_ndev)\r\n{\r\nstruct net_device *ndev = _ndev;\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nunsigned int status;\r\nstatus = lp->dma_in(lp, TX_IRQ_REG);\r\nlp->dma_out(lp, TX_IRQ_REG, status);\r\nif (status & (IRQ_COAL | IRQ_DLY))\r\ntemac_start_xmit_done(lp->ndev);\r\nif (status & 0x080)\r\ndev_err(&ndev->dev, "DMA error 0x%x\n", status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ll_temac_rx_irq(int irq, void *_ndev)\r\n{\r\nstruct net_device *ndev = _ndev;\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nunsigned int status;\r\nstatus = lp->dma_in(lp, RX_IRQ_REG);\r\nlp->dma_out(lp, RX_IRQ_REG, status);\r\nif (status & (IRQ_COAL | IRQ_DLY))\r\nll_temac_recv(lp->ndev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int temac_open(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nint rc;\r\ndev_dbg(&ndev->dev, "temac_open()\n");\r\nif (lp->phy_node) {\r\nlp->phy_dev = of_phy_connect(lp->ndev, lp->phy_node,\r\ntemac_adjust_link, 0, 0);\r\nif (!lp->phy_dev) {\r\ndev_err(lp->dev, "of_phy_connect() failed\n");\r\nreturn -ENODEV;\r\n}\r\nphy_start(lp->phy_dev);\r\n}\r\ntemac_device_reset(ndev);\r\nrc = request_irq(lp->tx_irq, ll_temac_tx_irq, 0, ndev->name, ndev);\r\nif (rc)\r\ngoto err_tx_irq;\r\nrc = request_irq(lp->rx_irq, ll_temac_rx_irq, 0, ndev->name, ndev);\r\nif (rc)\r\ngoto err_rx_irq;\r\nreturn 0;\r\nerr_rx_irq:\r\nfree_irq(lp->tx_irq, ndev);\r\nerr_tx_irq:\r\nif (lp->phy_dev)\r\nphy_disconnect(lp->phy_dev);\r\nlp->phy_dev = NULL;\r\ndev_err(lp->dev, "request_irq() failed\n");\r\nreturn rc;\r\n}\r\nstatic int temac_stop(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\ndev_dbg(&ndev->dev, "temac_close()\n");\r\nfree_irq(lp->tx_irq, ndev);\r\nfree_irq(lp->rx_irq, ndev);\r\nif (lp->phy_dev)\r\nphy_disconnect(lp->phy_dev);\r\nlp->phy_dev = NULL;\r\ntemac_dma_bd_release(ndev);\r\nreturn 0;\r\n}\r\nstatic void\r\ntemac_poll_controller(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\ndisable_irq(lp->tx_irq);\r\ndisable_irq(lp->rx_irq);\r\nll_temac_rx_irq(lp->tx_irq, ndev);\r\nll_temac_tx_irq(lp->rx_irq, ndev);\r\nenable_irq(lp->tx_irq);\r\nenable_irq(lp->rx_irq);\r\n}\r\nstatic int temac_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nif (!netif_running(ndev))\r\nreturn -EINVAL;\r\nif (!lp->phy_dev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(lp->phy_dev, rq, cmd);\r\n}\r\nstatic ssize_t temac_show_llink_regs(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nint i, len = 0;\r\nfor (i = 0; i < 0x11; i++)\r\nlen += sprintf(buf + len, "%.8x%s", lp->dma_in(lp, i),\r\n(i % 8) == 7 ? "\n" : " ");\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic int temac_get_settings(struct net_device *ndev, struct ethtool_cmd *cmd)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nreturn phy_ethtool_gset(lp->phy_dev, cmd);\r\n}\r\nstatic int temac_set_settings(struct net_device *ndev, struct ethtool_cmd *cmd)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nreturn phy_ethtool_sset(lp->phy_dev, cmd);\r\n}\r\nstatic int temac_nway_reset(struct net_device *ndev)\r\n{\r\nstruct temac_local *lp = netdev_priv(ndev);\r\nreturn phy_start_aneg(lp->phy_dev);\r\n}\r\nstatic int temac_of_probe(struct platform_device *op)\r\n{\r\nstruct device_node *np;\r\nstruct temac_local *lp;\r\nstruct net_device *ndev;\r\nconst void *addr;\r\n__be32 *p;\r\nint size, rc = 0;\r\nndev = alloc_etherdev(sizeof(*lp));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(op, ndev);\r\nSET_NETDEV_DEV(ndev, &op->dev);\r\nndev->flags &= ~IFF_MULTICAST;\r\nndev->features = NETIF_F_SG;\r\nndev->netdev_ops = &temac_netdev_ops;\r\nndev->ethtool_ops = &temac_ethtool_ops;\r\n#if 0\r\nndev->features |= NETIF_F_IP_CSUM;\r\nndev->features |= NETIF_F_HW_CSUM;\r\nndev->features |= NETIF_F_IPV6_CSUM;\r\nndev->features |= NETIF_F_HIGHDMA;\r\nndev->features |= NETIF_F_HW_VLAN_CTAG_TX;\r\nndev->features |= NETIF_F_HW_VLAN_CTAG_RX;\r\nndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\r\nndev->features |= NETIF_F_VLAN_CHALLENGED;\r\nndev->features |= NETIF_F_GSO;\r\nndev->features |= NETIF_F_MULTI_QUEUE;\r\nndev->features |= NETIF_F_LRO;\r\n#endif\r\nlp = netdev_priv(ndev);\r\nlp->ndev = ndev;\r\nlp->dev = &op->dev;\r\nlp->options = XTE_OPTION_DEFAULTS;\r\nspin_lock_init(&lp->rx_lock);\r\nmutex_init(&lp->indirect_mutex);\r\nlp->regs = of_iomap(op->dev.of_node, 0);\r\nif (!lp->regs) {\r\ndev_err(&op->dev, "could not map temac regs.\n");\r\nrc = -ENOMEM;\r\ngoto nodev;\r\n}\r\nlp->temac_features = 0;\r\np = (__be32 *)of_get_property(op->dev.of_node, "xlnx,txcsum", NULL);\r\nif (p && be32_to_cpu(*p)) {\r\nlp->temac_features |= TEMAC_FEATURE_TX_CSUM;\r\nndev->features |= NETIF_F_IP_CSUM;\r\n}\r\np = (__be32 *)of_get_property(op->dev.of_node, "xlnx,rxcsum", NULL);\r\nif (p && be32_to_cpu(*p))\r\nlp->temac_features |= TEMAC_FEATURE_RX_CSUM;\r\nnp = of_parse_phandle(op->dev.of_node, "llink-connected", 0);\r\nif (!np) {\r\ndev_err(&op->dev, "could not find DMA node\n");\r\nrc = -ENODEV;\r\ngoto err_iounmap;\r\n}\r\nif (temac_dcr_setup(lp, op, np)) {\r\nlp->sdma_regs = of_iomap(np, 0);\r\nif (lp->sdma_regs) {\r\nlp->dma_in = temac_dma_in32;\r\nlp->dma_out = temac_dma_out32;\r\ndev_dbg(&op->dev, "MEM base: %p\n", lp->sdma_regs);\r\n} else {\r\ndev_err(&op->dev, "unable to map DMA registers\n");\r\nof_node_put(np);\r\ngoto err_iounmap;\r\n}\r\n}\r\nlp->rx_irq = irq_of_parse_and_map(np, 0);\r\nlp->tx_irq = irq_of_parse_and_map(np, 1);\r\nof_node_put(np);\r\nif (!lp->rx_irq || !lp->tx_irq) {\r\ndev_err(&op->dev, "could not determine irqs\n");\r\nrc = -ENOMEM;\r\ngoto err_iounmap_2;\r\n}\r\naddr = of_get_property(op->dev.of_node, "local-mac-address", &size);\r\nif ((!addr) || (size != 6)) {\r\ndev_err(&op->dev, "could not find MAC address\n");\r\nrc = -ENODEV;\r\ngoto err_iounmap_2;\r\n}\r\ntemac_init_mac_address(ndev, (void *)addr);\r\nrc = temac_mdio_setup(lp, op->dev.of_node);\r\nif (rc)\r\ndev_warn(&op->dev, "error registering MDIO bus\n");\r\nlp->phy_node = of_parse_phandle(op->dev.of_node, "phy-handle", 0);\r\nif (lp->phy_node)\r\ndev_dbg(lp->dev, "using PHY node %s (%p)\n", np->full_name, np);\r\nrc = sysfs_create_group(&lp->dev->kobj, &temac_attr_group);\r\nif (rc) {\r\ndev_err(lp->dev, "Error creating sysfs files\n");\r\ngoto err_iounmap_2;\r\n}\r\nrc = register_netdev(lp->ndev);\r\nif (rc) {\r\ndev_err(lp->dev, "register_netdev() error (%i)\n", rc);\r\ngoto err_register_ndev;\r\n}\r\nreturn 0;\r\nerr_register_ndev:\r\nsysfs_remove_group(&lp->dev->kobj, &temac_attr_group);\r\nerr_iounmap_2:\r\nif (lp->sdma_regs)\r\niounmap(lp->sdma_regs);\r\nerr_iounmap:\r\niounmap(lp->regs);\r\nnodev:\r\nfree_netdev(ndev);\r\nndev = NULL;\r\nreturn rc;\r\n}\r\nstatic int temac_of_remove(struct platform_device *op)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(op);\r\nstruct temac_local *lp = netdev_priv(ndev);\r\ntemac_mdio_teardown(lp);\r\nunregister_netdev(ndev);\r\nsysfs_remove_group(&lp->dev->kobj, &temac_attr_group);\r\nof_node_put(lp->phy_node);\r\nlp->phy_node = NULL;\r\niounmap(lp->regs);\r\nif (lp->sdma_regs)\r\niounmap(lp->sdma_regs);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}
