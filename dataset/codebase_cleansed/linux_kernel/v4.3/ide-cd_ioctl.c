int ide_cdrom_open_real(struct cdrom_device_info *cdi, int purpose)\r\n{\r\nreturn 0;\r\n}\r\nvoid ide_cdrom_release_real(struct cdrom_device_info *cdi)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nif (!cdi->use_count)\r\ndrive->atapi_flags &= ~IDE_AFLAG_TOC_VALID;\r\n}\r\nint ide_cdrom_drive_status(struct cdrom_device_info *cdi, int slot_nr)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nstruct media_event_desc med;\r\nstruct request_sense sense;\r\nint stat;\r\nif (slot_nr != CDSL_CURRENT)\r\nreturn -EINVAL;\r\nstat = cdrom_check_status(drive, &sense);\r\nif (!stat || sense.sense_key == UNIT_ATTENTION)\r\nreturn CDS_DISC_OK;\r\nif (!cdrom_get_media_event(cdi, &med)) {\r\nif (med.media_present)\r\nreturn CDS_DISC_OK;\r\nelse if (med.door_open)\r\nreturn CDS_TRAY_OPEN;\r\nelse\r\nreturn CDS_NO_DISC;\r\n}\r\nif (sense.sense_key == NOT_READY && sense.asc == 0x04\r\n&& sense.ascq == 0x04)\r\nreturn CDS_DISC_OK;\r\nif (sense.sense_key == NOT_READY) {\r\nif (sense.asc == 0x3a && sense.ascq == 1)\r\nreturn CDS_NO_DISC;\r\nelse\r\nreturn CDS_TRAY_OPEN;\r\n}\r\nreturn CDS_DRIVE_NOT_READY;\r\n}\r\nunsigned int ide_cdrom_check_events_real(struct cdrom_device_info *cdi,\r\nunsigned int clearing, int slot_nr)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nint retval;\r\nif (slot_nr == CDSL_CURRENT) {\r\n(void) cdrom_check_status(drive, NULL);\r\nretval = (drive->dev_flags & IDE_DFLAG_MEDIA_CHANGED) ? 1 : 0;\r\ndrive->dev_flags &= ~IDE_DFLAG_MEDIA_CHANGED;\r\nreturn retval ? DISK_EVENT_MEDIA_CHANGE : 0;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic\r\nint cdrom_eject(ide_drive_t *drive, int ejectflag,\r\nstruct request_sense *sense)\r\n{\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct cdrom_device_info *cdi = &cd->devinfo;\r\nchar loej = 0x02;\r\nunsigned char cmd[BLK_MAX_CDB];\r\nif ((drive->atapi_flags & IDE_AFLAG_NO_EJECT) && !ejectflag)\r\nreturn -EDRIVE_CANT_DO_THIS;\r\nif ((drive->atapi_flags & IDE_AFLAG_DOOR_LOCKED) && ejectflag)\r\nreturn 0;\r\nif (ejectflag && (cdi->mask & CDC_CLOSE_TRAY))\r\nloej = 0;\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_START_STOP_UNIT;\r\ncmd[4] = loej | (ejectflag != 0);\r\nreturn ide_cd_queue_pc(drive, cmd, 0, NULL, NULL, sense, 0, 0);\r\n}\r\nstatic\r\nint ide_cd_lockdoor(ide_drive_t *drive, int lockflag,\r\nstruct request_sense *sense)\r\n{\r\nstruct request_sense my_sense;\r\nint stat;\r\nif (sense == NULL)\r\nsense = &my_sense;\r\nif ((drive->dev_flags & IDE_DFLAG_DOORLOCKING) == 0) {\r\nstat = 0;\r\n} else {\r\nunsigned char cmd[BLK_MAX_CDB];\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL;\r\ncmd[4] = lockflag ? 1 : 0;\r\nstat = ide_cd_queue_pc(drive, cmd, 0, NULL, NULL,\r\nsense, 0, 0);\r\n}\r\nif (stat != 0 &&\r\nsense->sense_key == ILLEGAL_REQUEST &&\r\n(sense->asc == 0x24 || sense->asc == 0x20)) {\r\nprintk(KERN_ERR "%s: door locking not supported\n",\r\ndrive->name);\r\ndrive->dev_flags &= ~IDE_DFLAG_DOORLOCKING;\r\nstat = 0;\r\n}\r\nif (stat != 0 && sense->sense_key == NOT_READY && sense->asc == 0x3a)\r\nstat = 0;\r\nif (stat == 0) {\r\nif (lockflag)\r\ndrive->atapi_flags |= IDE_AFLAG_DOOR_LOCKED;\r\nelse\r\ndrive->atapi_flags &= ~IDE_AFLAG_DOOR_LOCKED;\r\n}\r\nreturn stat;\r\n}\r\nint ide_cdrom_tray_move(struct cdrom_device_info *cdi, int position)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nstruct request_sense sense;\r\nif (position) {\r\nint stat = ide_cd_lockdoor(drive, 0, &sense);\r\nif (stat)\r\nreturn stat;\r\n}\r\nreturn cdrom_eject(drive, !position, &sense);\r\n}\r\nint ide_cdrom_lock_door(struct cdrom_device_info *cdi, int lock)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nreturn ide_cd_lockdoor(drive, lock, NULL);\r\n}\r\nint ide_cdrom_select_speed(struct cdrom_device_info *cdi, int speed)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct request_sense sense;\r\nu8 buf[ATAPI_CAPABILITIES_PAGE_SIZE];\r\nint stat;\r\nunsigned char cmd[BLK_MAX_CDB];\r\nif (speed == 0)\r\nspeed = 0xffff;\r\nelse\r\nspeed *= 177;\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_SET_SPEED;\r\ncmd[2] = (speed >> 8) & 0xff;\r\ncmd[3] = speed & 0xff;\r\nif ((cdi->mask & (CDC_CD_R | CDC_CD_RW | CDC_DVD_R)) !=\r\n(CDC_CD_R | CDC_CD_RW | CDC_DVD_R)) {\r\ncmd[4] = (speed >> 8) & 0xff;\r\ncmd[5] = speed & 0xff;\r\n}\r\nstat = ide_cd_queue_pc(drive, cmd, 0, NULL, NULL, &sense, 0, 0);\r\nif (!ide_cdrom_get_capabilities(drive, buf)) {\r\nide_cdrom_update_speed(drive, buf);\r\ncdi->speed = cd->current_speed;\r\n}\r\nreturn 0;\r\n}\r\nint ide_cdrom_get_last_session(struct cdrom_device_info *cdi,\r\nstruct cdrom_multisession *ms_info)\r\n{\r\nstruct atapi_toc *toc;\r\nide_drive_t *drive = cdi->handle;\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct request_sense sense;\r\nint ret;\r\nif ((drive->atapi_flags & IDE_AFLAG_TOC_VALID) == 0 || !info->toc) {\r\nret = ide_cd_read_toc(drive, &sense);\r\nif (ret)\r\nreturn ret;\r\n}\r\ntoc = info->toc;\r\nms_info->addr.lba = toc->last_session_lba;\r\nms_info->xa_flag = toc->xa_flag;\r\nreturn 0;\r\n}\r\nint ide_cdrom_get_mcn(struct cdrom_device_info *cdi,\r\nstruct cdrom_mcn *mcn_info)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nint stat, mcnlen;\r\nchar buf[24];\r\nunsigned char cmd[BLK_MAX_CDB];\r\nunsigned len = sizeof(buf);\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_READ_SUBCHANNEL;\r\ncmd[1] = 2;\r\ncmd[2] = 0x40;\r\ncmd[3] = 2;\r\ncmd[8] = len;\r\nstat = ide_cd_queue_pc(drive, cmd, 0, buf, &len, NULL, 0, 0);\r\nif (stat)\r\nreturn stat;\r\nmcnlen = sizeof(mcn_info->medium_catalog_number) - 1;\r\nmemcpy(mcn_info->medium_catalog_number, buf + 9, mcnlen);\r\nmcn_info->medium_catalog_number[mcnlen] = '\0';\r\nreturn 0;\r\n}\r\nint ide_cdrom_reset(struct cdrom_device_info *cdi)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct request_sense sense;\r\nstruct request *rq;\r\nint ret;\r\nrq = blk_get_request(drive->queue, READ, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_DRV_PRIV;\r\nrq->cmd_flags = REQ_QUIET;\r\nret = blk_execute_rq(drive->queue, cd->disk, rq, 0);\r\nblk_put_request(rq);\r\nif (drive->atapi_flags & IDE_AFLAG_DOOR_LOCKED)\r\n(void)ide_cd_lockdoor(drive, 1, &sense);\r\nreturn ret;\r\n}\r\nstatic int ide_cd_get_toc_entry(ide_drive_t *drive, int track,\r\nstruct atapi_toc_entry **ent)\r\n{\r\nstruct cdrom_info *info = drive->driver_data;\r\nstruct atapi_toc *toc = info->toc;\r\nint ntracks;\r\nif ((drive->atapi_flags & IDE_AFLAG_TOC_VALID) == 0)\r\nreturn -EINVAL;\r\nntracks = toc->hdr.last_track - toc->hdr.first_track + 1;\r\nif (toc->hdr.first_track == CDROM_LEADOUT)\r\nntracks = 0;\r\nif (track == CDROM_LEADOUT)\r\n*ent = &toc->ent[ntracks];\r\nelse if (track < toc->hdr.first_track || track > toc->hdr.last_track)\r\nreturn -EINVAL;\r\nelse\r\n*ent = &toc->ent[track - toc->hdr.first_track];\r\nreturn 0;\r\n}\r\nstatic int ide_cd_fake_play_trkind(ide_drive_t *drive, void *arg)\r\n{\r\nstruct cdrom_ti *ti = arg;\r\nstruct atapi_toc_entry *first_toc, *last_toc;\r\nunsigned long lba_start, lba_end;\r\nint stat;\r\nstruct request_sense sense;\r\nunsigned char cmd[BLK_MAX_CDB];\r\nstat = ide_cd_get_toc_entry(drive, ti->cdti_trk0, &first_toc);\r\nif (stat)\r\nreturn stat;\r\nstat = ide_cd_get_toc_entry(drive, ti->cdti_trk1, &last_toc);\r\nif (stat)\r\nreturn stat;\r\nif (ti->cdti_trk1 != CDROM_LEADOUT)\r\n++last_toc;\r\nlba_start = first_toc->addr.lba;\r\nlba_end = last_toc->addr.lba;\r\nif (lba_end <= lba_start)\r\nreturn -EINVAL;\r\nmemset(cmd, 0, BLK_MAX_CDB);\r\ncmd[0] = GPCMD_PLAY_AUDIO_MSF;\r\nlba_to_msf(lba_start, &cmd[3], &cmd[4], &cmd[5]);\r\nlba_to_msf(lba_end - 1, &cmd[6], &cmd[7], &cmd[8]);\r\nreturn ide_cd_queue_pc(drive, cmd, 0, NULL, NULL, &sense, 0, 0);\r\n}\r\nstatic int ide_cd_read_tochdr(ide_drive_t *drive, void *arg)\r\n{\r\nstruct cdrom_info *cd = drive->driver_data;\r\nstruct cdrom_tochdr *tochdr = arg;\r\nstruct atapi_toc *toc;\r\nint stat;\r\nstat = ide_cd_read_toc(drive, NULL);\r\nif (stat)\r\nreturn stat;\r\ntoc = cd->toc;\r\ntochdr->cdth_trk0 = toc->hdr.first_track;\r\ntochdr->cdth_trk1 = toc->hdr.last_track;\r\nreturn 0;\r\n}\r\nstatic int ide_cd_read_tocentry(ide_drive_t *drive, void *arg)\r\n{\r\nstruct cdrom_tocentry *tocentry = arg;\r\nstruct atapi_toc_entry *toce;\r\nint stat;\r\nstat = ide_cd_get_toc_entry(drive, tocentry->cdte_track, &toce);\r\nif (stat)\r\nreturn stat;\r\ntocentry->cdte_ctrl = toce->control;\r\ntocentry->cdte_adr = toce->adr;\r\nif (tocentry->cdte_format == CDROM_MSF) {\r\nlba_to_msf(toce->addr.lba,\r\n&tocentry->cdte_addr.msf.minute,\r\n&tocentry->cdte_addr.msf.second,\r\n&tocentry->cdte_addr.msf.frame);\r\n} else\r\ntocentry->cdte_addr.lba = toce->addr.lba;\r\nreturn 0;\r\n}\r\nint ide_cdrom_audio_ioctl(struct cdrom_device_info *cdi,\r\nunsigned int cmd, void *arg)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nswitch (cmd) {\r\ncase CDROMPLAYTRKIND:\r\nreturn ide_cd_fake_play_trkind(drive, arg);\r\ncase CDROMREADTOCHDR:\r\nreturn ide_cd_read_tochdr(drive, arg);\r\ncase CDROMREADTOCENTRY:\r\nreturn ide_cd_read_tocentry(drive, arg);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint ide_cdrom_packet(struct cdrom_device_info *cdi,\r\nstruct packet_command *cgc)\r\n{\r\nide_drive_t *drive = cdi->handle;\r\nunsigned int flags = 0;\r\nunsigned len = cgc->buflen;\r\nif (cgc->timeout <= 0)\r\ncgc->timeout = ATAPI_WAIT_PC;\r\nif (cgc->data_direction == CGC_DATA_WRITE)\r\nflags |= REQ_WRITE;\r\nif (cgc->sense)\r\nmemset(cgc->sense, 0, sizeof(struct request_sense));\r\nif (cgc->quiet)\r\nflags |= REQ_QUIET;\r\ncgc->stat = ide_cd_queue_pc(drive, cgc->cmd,\r\ncgc->data_direction == CGC_DATA_WRITE,\r\ncgc->buffer, &len,\r\ncgc->sense, cgc->timeout, flags);\r\nif (!cgc->stat)\r\ncgc->buflen -= len;\r\nreturn cgc->stat;\r\n}
