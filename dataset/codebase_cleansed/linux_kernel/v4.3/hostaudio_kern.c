static int set_dsp(char *name, int *add)\r\n{\r\ndsp = name;\r\nreturn 0;\r\n}\r\nstatic int set_mixer(char *name, int *add)\r\n{\r\nmixer = name;\r\nreturn 0;\r\n}\r\nstatic ssize_t hostaudio_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hostaudio_state *state = file->private_data;\r\nvoid *kbuf;\r\nint err;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostaudio: read called, count = %d\n", count);\r\n#endif\r\nkbuf = kmalloc(count, GFP_KERNEL);\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\nerr = os_read_file(state->fd, kbuf, count);\r\nif (err < 0)\r\ngoto out;\r\nif (copy_to_user(buffer, kbuf, err))\r\nerr = -EFAULT;\r\nout:\r\nkfree(kbuf);\r\nreturn err;\r\n}\r\nstatic ssize_t hostaudio_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hostaudio_state *state = file->private_data;\r\nvoid *kbuf;\r\nint err;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostaudio: write called, count = %d\n", count);\r\n#endif\r\nkbuf = kmalloc(count, GFP_KERNEL);\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\nif (copy_from_user(kbuf, buffer, count))\r\ngoto out;\r\nerr = os_write_file(state->fd, kbuf, count);\r\nif (err < 0)\r\ngoto out;\r\n*ppos += err;\r\nout:\r\nkfree(kbuf);\r\nreturn err;\r\n}\r\nstatic unsigned int hostaudio_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nunsigned int mask = 0;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostaudio: poll called (unimplemented)\n");\r\n#endif\r\nreturn mask;\r\n}\r\nstatic long hostaudio_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct hostaudio_state *state = file->private_data;\r\nunsigned long data = 0;\r\nint err;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostaudio: ioctl called, cmd = %u\n", cmd);\r\n#endif\r\nswitch(cmd){\r\ncase SNDCTL_DSP_SPEED:\r\ncase SNDCTL_DSP_STEREO:\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\ncase SNDCTL_DSP_CHANNELS:\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nif (get_user(data, (int __user *) arg))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerr = os_ioctl_generic(state->fd, cmd, (unsigned long) &data);\r\nswitch(cmd){\r\ncase SNDCTL_DSP_SPEED:\r\ncase SNDCTL_DSP_STEREO:\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\ncase SNDCTL_DSP_CHANNELS:\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nif (put_user(data, (int __user *) arg))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int hostaudio_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hostaudio_state *state;\r\nint r = 0, w = 0;\r\nint ret;\r\n#ifdef DEBUG\r\nkernel_param_lock(THIS_MODULE);\r\nprintk(KERN_DEBUG "hostaudio: open called (host: %s)\n", dsp);\r\nkernel_param_unlock(THIS_MODULE);\r\n#endif\r\nstate = kmalloc(sizeof(struct hostaudio_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nif (file->f_mode & FMODE_READ)\r\nr = 1;\r\nif (file->f_mode & FMODE_WRITE)\r\nw = 1;\r\nkernel_param_lock(THIS_MODULE);\r\nmutex_lock(&hostaudio_mutex);\r\nret = os_open_file(dsp, of_set_rw(OPENFLAGS(), r, w), 0);\r\nmutex_unlock(&hostaudio_mutex);\r\nkernel_param_unlock(THIS_MODULE);\r\nif (ret < 0) {\r\nkfree(state);\r\nreturn ret;\r\n}\r\nstate->fd = ret;\r\nfile->private_data = state;\r\nreturn 0;\r\n}\r\nstatic int hostaudio_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hostaudio_state *state = file->private_data;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostaudio: release called\n");\r\n#endif\r\nos_close_file(state->fd);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic long hostmixer_ioctl_mixdev(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct hostmixer_state *state = file->private_data;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostmixer: ioctl called\n");\r\n#endif\r\nreturn os_ioctl_generic(state->fd, cmd, arg);\r\n}\r\nstatic int hostmixer_open_mixdev(struct inode *inode, struct file *file)\r\n{\r\nstruct hostmixer_state *state;\r\nint r = 0, w = 0;\r\nint ret;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostmixer: open called (host: %s)\n", mixer);\r\n#endif\r\nstate = kmalloc(sizeof(struct hostmixer_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn -ENOMEM;\r\nif (file->f_mode & FMODE_READ)\r\nr = 1;\r\nif (file->f_mode & FMODE_WRITE)\r\nw = 1;\r\nkernel_param_lock(THIS_MODULE);\r\nmutex_lock(&hostaudio_mutex);\r\nret = os_open_file(mixer, of_set_rw(OPENFLAGS(), r, w), 0);\r\nmutex_unlock(&hostaudio_mutex);\r\nkernel_param_unlock(THIS_MODULE);\r\nif (ret < 0) {\r\nkernel_param_lock(THIS_MODULE);\r\nprintk(KERN_ERR "hostaudio_open_mixdev failed to open '%s', "\r\n"err = %d\n", dsp, -ret);\r\nkernel_param_unlock(THIS_MODULE);\r\nkfree(state);\r\nreturn ret;\r\n}\r\nfile->private_data = state;\r\nreturn 0;\r\n}\r\nstatic int hostmixer_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hostmixer_state *state = file->private_data;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "hostmixer: release called\n");\r\n#endif\r\nos_close_file(state->fd);\r\nkfree(state);\r\nreturn 0;\r\n}\r\nstatic int __init hostaudio_init_module(void)\r\n{\r\nkernel_param_lock(THIS_MODULE);\r\nprintk(KERN_INFO "UML Audio Relay (host dsp = %s, host mixer = %s)\n",\r\ndsp, mixer);\r\nkernel_param_unlock(THIS_MODULE);\r\nmodule_data.dev_audio = register_sound_dsp(&hostaudio_fops, -1);\r\nif (module_data.dev_audio < 0) {\r\nprintk(KERN_ERR "hostaudio: couldn't register DSP device!\n");\r\nreturn -ENODEV;\r\n}\r\nmodule_data.dev_mixer = register_sound_mixer(&hostmixer_fops, -1);\r\nif (module_data.dev_mixer < 0) {\r\nprintk(KERN_ERR "hostmixer: couldn't register mixer "\r\n"device!\n");\r\nunregister_sound_dsp(module_data.dev_audio);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hostaudio_cleanup_module (void)\r\n{\r\nunregister_sound_mixer(module_data.dev_mixer);\r\nunregister_sound_dsp(module_data.dev_audio);\r\n}
