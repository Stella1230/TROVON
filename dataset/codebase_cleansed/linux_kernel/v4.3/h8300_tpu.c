static inline unsigned long read_tcnt32(struct tpu_priv *p)\r\n{\r\nunsigned long tcnt;\r\ntcnt = ctrl_inw(p->mapbase1 + TCNT) << 16;\r\ntcnt |= ctrl_inw(p->mapbase2 + TCNT);\r\nreturn tcnt;\r\n}\r\nstatic int tpu_get_counter(struct tpu_priv *p, unsigned long long *val)\r\n{\r\nunsigned long v1, v2, v3;\r\nint o1, o2;\r\no1 = ctrl_inb(p->mapbase1 + TSR) & 0x10;\r\ndo {\r\no2 = o1;\r\nv1 = read_tcnt32(p);\r\nv2 = read_tcnt32(p);\r\nv3 = read_tcnt32(p);\r\no1 = ctrl_inb(p->mapbase1 + TSR) & 0x10;\r\n} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)\r\n|| (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));\r\n*val = v2;\r\nreturn o1;\r\n}\r\nstatic inline struct tpu_priv *cs_to_priv(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct tpu_priv, cs);\r\n}\r\nstatic cycle_t tpu_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct tpu_priv *p = cs_to_priv(cs);\r\nunsigned long flags;\r\nunsigned long long value;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nif (tpu_get_counter(p, &value))\r\nvalue += 0x100000000;\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn value;\r\n}\r\nstatic int tpu_clocksource_enable(struct clocksource *cs)\r\n{\r\nstruct tpu_priv *p = cs_to_priv(cs);\r\nWARN_ON(p->cs_enabled);\r\nctrl_outw(0, p->mapbase1 + TCNT);\r\nctrl_outw(0, p->mapbase2 + TCNT);\r\nctrl_outb(0x0f, p->mapbase1 + TCR);\r\nctrl_outb(0x03, p->mapbase2 + TCR);\r\np->cs_enabled = true;\r\nreturn 0;\r\n}\r\nstatic void tpu_clocksource_disable(struct clocksource *cs)\r\n{\r\nstruct tpu_priv *p = cs_to_priv(cs);\r\nWARN_ON(!p->cs_enabled);\r\nctrl_outb(0, p->mapbase1 + TCR);\r\nctrl_outb(0, p->mapbase2 + TCR);\r\np->cs_enabled = false;\r\n}\r\nstatic int __init tpu_setup(struct tpu_priv *p, struct platform_device *pdev)\r\n{\r\nstruct resource *res[2];\r\nmemset(p, 0, sizeof(*p));\r\np->pdev = pdev;\r\nres[CH_L] = platform_get_resource(p->pdev, IORESOURCE_MEM, CH_L);\r\nres[CH_H] = platform_get_resource(p->pdev, IORESOURCE_MEM, CH_H);\r\nif (!res[CH_L] || !res[CH_H]) {\r\ndev_err(&p->pdev->dev, "failed to get I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\np->clk = clk_get(&p->pdev->dev, "fck");\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&p->pdev->dev, "can't get clk\n");\r\nreturn PTR_ERR(p->clk);\r\n}\r\np->mapbase1 = res[CH_L]->start;\r\np->mapbase2 = res[CH_H]->start;\r\np->cs.name = pdev->name;\r\np->cs.rating = 200;\r\np->cs.read = tpu_clocksource_read;\r\np->cs.enable = tpu_clocksource_enable;\r\np->cs.disable = tpu_clocksource_disable;\r\np->cs.mask = CLOCKSOURCE_MASK(sizeof(unsigned long) * 8);\r\np->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\nclocksource_register_hz(&p->cs, clk_get_rate(p->clk) / 64);\r\nplatform_set_drvdata(pdev, p);\r\nreturn 0;\r\n}\r\nstatic int tpu_probe(struct platform_device *pdev)\r\n{\r\nstruct tpu_priv *p = platform_get_drvdata(pdev);\r\nif (p) {\r\ndev_info(&pdev->dev, "kept as earlytimer\n");\r\nreturn 0;\r\n}\r\np = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nreturn tpu_setup(p, pdev);\r\n}\r\nstatic int tpu_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init tpu_init(void)\r\n{\r\nreturn platform_driver_register(&tpu_driver);\r\n}\r\nstatic void __exit tpu_exit(void)\r\n{\r\nplatform_driver_unregister(&tpu_driver);\r\n}
