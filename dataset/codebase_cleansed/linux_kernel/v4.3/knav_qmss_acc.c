static void __knav_acc_notify(struct knav_range_info *range,\r\nstruct knav_acc_channel *acc)\r\n{\r\nstruct knav_device *kdev = range->kdev;\r\nstruct knav_queue_inst *inst;\r\nint range_base, queue;\r\nrange_base = kdev->base_id + range->queue_base;\r\nif (range->flags & RANGE_MULTI_QUEUE) {\r\nfor (queue = 0; queue < range->num_queues; queue++) {\r\ninst = knav_range_offset_to_inst(kdev, range,\r\nqueue);\r\nif (inst->notify_needed) {\r\ninst->notify_needed = 0;\r\ndev_dbg(kdev->dev, "acc-irq: notifying %d\n",\r\nrange_base + queue);\r\nknav_queue_notify(inst);\r\n}\r\n}\r\n} else {\r\nqueue = acc->channel - range->acc_info.start_channel;\r\ninst = knav_range_offset_to_inst(kdev, range, queue);\r\ndev_dbg(kdev->dev, "acc-irq: notifying %d\n",\r\nrange_base + queue);\r\nknav_queue_notify(inst);\r\n}\r\n}\r\nstatic int knav_acc_set_notify(struct knav_range_info *range,\r\nstruct knav_queue_inst *kq,\r\nbool enabled)\r\n{\r\nstruct knav_pdsp_info *pdsp = range->acc_info.pdsp;\r\nstruct knav_device *kdev = range->kdev;\r\nu32 mask, offset;\r\nif (!enabled || atomic_read(&kq->desc_count) <= 0)\r\nreturn 0;\r\nkq->notify_needed = 1;\r\natomic_inc(&kq->acc->retrigger_count);\r\nmask = BIT(kq->acc->channel % 32);\r\noffset = ACC_INTD_OFFSET_STATUS(kq->acc->channel);\r\ndev_dbg(kdev->dev, "setup-notify: re-triggering irq for %s\n",\r\nkq->acc->name);\r\nwritel_relaxed(mask, pdsp->intd + offset);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t knav_acc_int_handler(int irq, void *_instdata)\r\n{\r\nstruct knav_acc_channel *acc;\r\nstruct knav_queue_inst *kq = NULL;\r\nstruct knav_range_info *range;\r\nstruct knav_pdsp_info *pdsp;\r\nstruct knav_acc_info *info;\r\nstruct knav_device *kdev;\r\nu32 *list, *list_cpu, val, idx, notifies;\r\nint range_base, channel, queue = 0;\r\ndma_addr_t list_dma;\r\nrange = _instdata;\r\ninfo = &range->acc_info;\r\nkdev = range->kdev;\r\npdsp = range->acc_info.pdsp;\r\nacc = range->acc;\r\nrange_base = kdev->base_id + range->queue_base;\r\nif ((range->flags & RANGE_MULTI_QUEUE) == 0) {\r\nfor (queue = 0; queue < range->num_irqs; queue++)\r\nif (range->irqs[queue].irq == irq)\r\nbreak;\r\nkq = knav_range_offset_to_inst(kdev, range, queue);\r\nacc += queue;\r\n}\r\nchannel = acc->channel;\r\nlist_dma = acc->list_dma[acc->list_index];\r\nlist_cpu = acc->list_cpu[acc->list_index];\r\ndev_dbg(kdev->dev, "acc-irq: channel %d, list %d, virt %p, phys %x\n",\r\nchannel, acc->list_index, list_cpu, list_dma);\r\nif (atomic_read(&acc->retrigger_count)) {\r\natomic_dec(&acc->retrigger_count);\r\n__knav_acc_notify(range, acc);\r\nwritel_relaxed(1, pdsp->intd + ACC_INTD_OFFSET_COUNT(channel));\r\nwritel_relaxed(ACC_CHANNEL_INT_BASE + channel,\r\npdsp->intd + ACC_INTD_OFFSET_EOI);\r\nreturn IRQ_HANDLED;\r\n}\r\nnotifies = readl_relaxed(pdsp->intd + ACC_INTD_OFFSET_COUNT(channel));\r\nWARN_ON(!notifies);\r\ndma_sync_single_for_cpu(kdev->dev, list_dma, info->list_size,\r\nDMA_FROM_DEVICE);\r\nfor (list = list_cpu; list < list_cpu + (info->list_size / sizeof(u32));\r\nlist += ACC_LIST_ENTRY_WORDS) {\r\nif (ACC_LIST_ENTRY_WORDS == 1) {\r\ndev_dbg(kdev->dev,\r\n"acc-irq: list %d, entry @%p, %08x\n",\r\nacc->list_index, list, list[0]);\r\n} else if (ACC_LIST_ENTRY_WORDS == 2) {\r\ndev_dbg(kdev->dev,\r\n"acc-irq: list %d, entry @%p, %08x %08x\n",\r\nacc->list_index, list, list[0], list[1]);\r\n} else if (ACC_LIST_ENTRY_WORDS == 4) {\r\ndev_dbg(kdev->dev,\r\n"acc-irq: list %d, entry @%p, %08x %08x %08x %08x\n",\r\nacc->list_index, list, list[0], list[1],\r\nlist[2], list[3]);\r\n}\r\nval = list[ACC_LIST_ENTRY_DESC_IDX];\r\nif (!val)\r\nbreak;\r\nif (range->flags & RANGE_MULTI_QUEUE) {\r\nqueue = list[ACC_LIST_ENTRY_QUEUE_IDX] >> 16;\r\nif (queue < range_base ||\r\nqueue >= range_base + range->num_queues) {\r\ndev_err(kdev->dev,\r\n"bad queue %d, expecting %d-%d\n",\r\nqueue, range_base,\r\nrange_base + range->num_queues);\r\nbreak;\r\n}\r\nqueue -= range_base;\r\nkq = knav_range_offset_to_inst(kdev, range,\r\nqueue);\r\n}\r\nif (atomic_inc_return(&kq->desc_count) >= ACC_DESCS_MAX) {\r\natomic_dec(&kq->desc_count);\r\ndev_err(kdev->dev,\r\n"acc-irq: queue %d full, entry dropped\n",\r\nqueue + range_base);\r\ncontinue;\r\n}\r\nidx = atomic_inc_return(&kq->desc_tail) & ACC_DESCS_MASK;\r\nkq->descs[idx] = val;\r\nkq->notify_needed = 1;\r\ndev_dbg(kdev->dev, "acc-irq: enqueue %08x at %d, queue %d\n",\r\nval, idx, queue + range_base);\r\n}\r\n__knav_acc_notify(range, acc);\r\nmemset(list_cpu, 0, info->list_size);\r\ndma_sync_single_for_device(kdev->dev, list_dma, info->list_size,\r\nDMA_TO_DEVICE);\r\nacc->list_index ^= 1;\r\nwritel_relaxed(1, pdsp->intd + ACC_INTD_OFFSET_COUNT(channel));\r\nwritel_relaxed(ACC_CHANNEL_INT_BASE + channel,\r\npdsp->intd + ACC_INTD_OFFSET_EOI);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int knav_range_setup_acc_irq(struct knav_range_info *range,\r\nint queue, bool enabled)\r\n{\r\nstruct knav_device *kdev = range->kdev;\r\nstruct knav_acc_channel *acc;\r\nunsigned long cpu_map;\r\nint ret = 0, irq;\r\nu32 old, new;\r\nif (range->flags & RANGE_MULTI_QUEUE) {\r\nacc = range->acc;\r\nirq = range->irqs[0].irq;\r\ncpu_map = range->irqs[0].cpu_map;\r\n} else {\r\nacc = range->acc + queue;\r\nirq = range->irqs[queue].irq;\r\ncpu_map = range->irqs[queue].cpu_map;\r\n}\r\nold = acc->open_mask;\r\nif (enabled)\r\nnew = old | BIT(queue);\r\nelse\r\nnew = old & ~BIT(queue);\r\nacc->open_mask = new;\r\ndev_dbg(kdev->dev,\r\n"setup-acc-irq: open mask old %08x, new %08x, channel %s\n",\r\nold, new, acc->name);\r\nif (likely(new == old))\r\nreturn 0;\r\nif (new && !old) {\r\ndev_dbg(kdev->dev,\r\n"setup-acc-irq: requesting %s for channel %s\n",\r\nacc->name, acc->name);\r\nret = request_irq(irq, knav_acc_int_handler, 0, acc->name,\r\nrange);\r\nif (!ret && cpu_map) {\r\nret = irq_set_affinity_hint(irq, to_cpumask(&cpu_map));\r\nif (ret) {\r\ndev_warn(range->kdev->dev,\r\n"Failed to set IRQ affinity\n");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nif (old && !new) {\r\ndev_dbg(kdev->dev, "setup-acc-irq: freeing %s for channel %s\n",\r\nacc->name, acc->name);\r\nfree_irq(irq, range);\r\n}\r\nreturn ret;\r\n}\r\nstatic const char *knav_acc_result_str(enum knav_acc_result result)\r\n{\r\nstatic const char * const result_str[] = {\r\n[ACC_RET_IDLE] = "idle",\r\n[ACC_RET_SUCCESS] = "success",\r\n[ACC_RET_INVALID_COMMAND] = "invalid command",\r\n[ACC_RET_INVALID_CHANNEL] = "invalid channel",\r\n[ACC_RET_INACTIVE_CHANNEL] = "inactive channel",\r\n[ACC_RET_ACTIVE_CHANNEL] = "active channel",\r\n[ACC_RET_INVALID_QUEUE] = "invalid queue",\r\n[ACC_RET_INVALID_RET] = "invalid return code",\r\n};\r\nif (result >= ARRAY_SIZE(result_str))\r\nreturn result_str[ACC_RET_INVALID_RET];\r\nelse\r\nreturn result_str[result];\r\n}\r\nstatic enum knav_acc_result\r\nknav_acc_write(struct knav_device *kdev, struct knav_pdsp_info *pdsp,\r\nstruct knav_reg_acc_command *cmd)\r\n{\r\nu32 result;\r\ndev_dbg(kdev->dev, "acc command %08x %08x %08x %08x %08x\n",\r\ncmd->command, cmd->queue_mask, cmd->list_phys,\r\ncmd->queue_num, cmd->timer_config);\r\nwritel_relaxed(cmd->timer_config, &pdsp->acc_command->timer_config);\r\nwritel_relaxed(cmd->queue_num, &pdsp->acc_command->queue_num);\r\nwritel_relaxed(cmd->list_phys, &pdsp->acc_command->list_phys);\r\nwritel_relaxed(cmd->queue_mask, &pdsp->acc_command->queue_mask);\r\nwritel_relaxed(cmd->command, &pdsp->acc_command->command);\r\ndo {\r\nresult = readl_relaxed(&pdsp->acc_command->command);\r\n} while ((result >> 8) & 0xff);\r\nreturn (result >> 24) & 0xff;\r\n}\r\nstatic void knav_acc_setup_cmd(struct knav_device *kdev,\r\nstruct knav_range_info *range,\r\nstruct knav_reg_acc_command *cmd,\r\nint queue)\r\n{\r\nstruct knav_acc_info *info = &range->acc_info;\r\nstruct knav_acc_channel *acc;\r\nint queue_base;\r\nu32 queue_mask;\r\nif (range->flags & RANGE_MULTI_QUEUE) {\r\nacc = range->acc;\r\nqueue_base = range->queue_base;\r\nqueue_mask = BIT(range->num_queues) - 1;\r\n} else {\r\nacc = range->acc + queue;\r\nqueue_base = range->queue_base + queue;\r\nqueue_mask = 0;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->command = acc->channel;\r\ncmd->queue_mask = queue_mask;\r\ncmd->list_phys = acc->list_dma[0];\r\ncmd->queue_num = info->list_entries << 16;\r\ncmd->queue_num |= queue_base;\r\ncmd->timer_config = ACC_LIST_ENTRY_TYPE << 18;\r\nif (range->flags & RANGE_MULTI_QUEUE)\r\ncmd->timer_config |= ACC_CFG_MULTI_QUEUE;\r\ncmd->timer_config |= info->pacing_mode << 16;\r\ncmd->timer_config |= info->timer_count;\r\n}\r\nstatic void knav_acc_stop(struct knav_device *kdev,\r\nstruct knav_range_info *range,\r\nint queue)\r\n{\r\nstruct knav_reg_acc_command cmd;\r\nstruct knav_acc_channel *acc;\r\nenum knav_acc_result result;\r\nacc = range->acc + queue;\r\nknav_acc_setup_cmd(kdev, range, &cmd, queue);\r\ncmd.command |= ACC_CMD_DISABLE_CHANNEL << 8;\r\nresult = knav_acc_write(kdev, range->acc_info.pdsp, &cmd);\r\ndev_dbg(kdev->dev, "stopped acc channel %s, result %s\n",\r\nacc->name, knav_acc_result_str(result));\r\n}\r\nstatic enum knav_acc_result knav_acc_start(struct knav_device *kdev,\r\nstruct knav_range_info *range,\r\nint queue)\r\n{\r\nstruct knav_reg_acc_command cmd;\r\nstruct knav_acc_channel *acc;\r\nenum knav_acc_result result;\r\nacc = range->acc + queue;\r\nknav_acc_setup_cmd(kdev, range, &cmd, queue);\r\ncmd.command |= ACC_CMD_ENABLE_CHANNEL << 8;\r\nresult = knav_acc_write(kdev, range->acc_info.pdsp, &cmd);\r\ndev_dbg(kdev->dev, "started acc channel %s, result %s\n",\r\nacc->name, knav_acc_result_str(result));\r\nreturn result;\r\n}\r\nstatic int knav_acc_init_range(struct knav_range_info *range)\r\n{\r\nstruct knav_device *kdev = range->kdev;\r\nstruct knav_acc_channel *acc;\r\nenum knav_acc_result result;\r\nint queue;\r\nfor (queue = 0; queue < range->num_queues; queue++) {\r\nacc = range->acc + queue;\r\nknav_acc_stop(kdev, range, queue);\r\nacc->list_index = 0;\r\nresult = knav_acc_start(kdev, range, queue);\r\nif (result != ACC_RET_SUCCESS)\r\nreturn -EIO;\r\nif (range->flags & RANGE_MULTI_QUEUE)\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int knav_acc_init_queue(struct knav_range_info *range,\r\nstruct knav_queue_inst *kq)\r\n{\r\nunsigned id = kq->id - range->queue_base;\r\nkq->descs = devm_kzalloc(range->kdev->dev,\r\nACC_DESCS_MAX * sizeof(u32), GFP_KERNEL);\r\nif (!kq->descs)\r\nreturn -ENOMEM;\r\nkq->acc = range->acc;\r\nif ((range->flags & RANGE_MULTI_QUEUE) == 0)\r\nkq->acc += id;\r\nreturn 0;\r\n}\r\nstatic int knav_acc_open_queue(struct knav_range_info *range,\r\nstruct knav_queue_inst *inst, unsigned flags)\r\n{\r\nunsigned id = inst->id - range->queue_base;\r\nreturn knav_range_setup_acc_irq(range, id, true);\r\n}\r\nstatic int knav_acc_close_queue(struct knav_range_info *range,\r\nstruct knav_queue_inst *inst)\r\n{\r\nunsigned id = inst->id - range->queue_base;\r\nreturn knav_range_setup_acc_irq(range, id, false);\r\n}\r\nstatic int knav_acc_free_range(struct knav_range_info *range)\r\n{\r\nstruct knav_device *kdev = range->kdev;\r\nstruct knav_acc_channel *acc;\r\nstruct knav_acc_info *info;\r\nint channel, channels;\r\ninfo = &range->acc_info;\r\nif (range->flags & RANGE_MULTI_QUEUE)\r\nchannels = 1;\r\nelse\r\nchannels = range->num_queues;\r\nfor (channel = 0; channel < channels; channel++) {\r\nacc = range->acc + channel;\r\nif (!acc->list_cpu[0])\r\ncontinue;\r\ndma_unmap_single(kdev->dev, acc->list_dma[0],\r\ninfo->mem_size, DMA_BIDIRECTIONAL);\r\nfree_pages_exact(acc->list_cpu[0], info->mem_size);\r\n}\r\ndevm_kfree(range->kdev->dev, range->acc);\r\nreturn 0;\r\n}\r\nint knav_init_acc_range(struct knav_device *kdev,\r\nstruct device_node *node,\r\nstruct knav_range_info *range)\r\n{\r\nstruct knav_acc_channel *acc;\r\nstruct knav_pdsp_info *pdsp;\r\nstruct knav_acc_info *info;\r\nint ret, channel, channels;\r\nint list_size, mem_size;\r\ndma_addr_t list_dma;\r\nvoid *list_mem;\r\nu32 config[5];\r\nrange->flags |= RANGE_HAS_ACCUMULATOR;\r\ninfo = &range->acc_info;\r\nret = of_property_read_u32_array(node, "accumulator", config, 5);\r\nif (ret)\r\nreturn ret;\r\ninfo->pdsp_id = config[0];\r\ninfo->start_channel = config[1];\r\ninfo->list_entries = config[2];\r\ninfo->pacing_mode = config[3];\r\ninfo->timer_count = config[4] / ACC_DEFAULT_PERIOD;\r\nif (info->start_channel > ACC_MAX_CHANNEL) {\r\ndev_err(kdev->dev, "channel %d invalid for range %s\n",\r\ninfo->start_channel, range->name);\r\nreturn -EINVAL;\r\n}\r\nif (info->pacing_mode > 3) {\r\ndev_err(kdev->dev, "pacing mode %d invalid for range %s\n",\r\ninfo->pacing_mode, range->name);\r\nreturn -EINVAL;\r\n}\r\npdsp = knav_find_pdsp(kdev, info->pdsp_id);\r\nif (!pdsp) {\r\ndev_err(kdev->dev, "pdsp id %d not found for range %s\n",\r\ninfo->pdsp_id, range->name);\r\nreturn -EINVAL;\r\n}\r\ninfo->pdsp = pdsp;\r\nchannels = range->num_queues;\r\nif (of_get_property(node, "multi-queue", NULL)) {\r\nrange->flags |= RANGE_MULTI_QUEUE;\r\nchannels = 1;\r\nif (range->queue_base & (32 - 1)) {\r\ndev_err(kdev->dev,\r\n"misaligned multi-queue accumulator range %s\n",\r\nrange->name);\r\nreturn -EINVAL;\r\n}\r\nif (range->num_queues > 32) {\r\ndev_err(kdev->dev,\r\n"too many queues in accumulator range %s\n",\r\nrange->name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlist_size = info->list_entries;\r\nlist_size *= ACC_LIST_ENTRY_WORDS * sizeof(u32);\r\ninfo->list_size = list_size;\r\nmem_size = PAGE_ALIGN(list_size * 2);\r\ninfo->mem_size = mem_size;\r\nrange->acc = devm_kzalloc(kdev->dev, channels * sizeof(*range->acc),\r\nGFP_KERNEL);\r\nif (!range->acc)\r\nreturn -ENOMEM;\r\nfor (channel = 0; channel < channels; channel++) {\r\nacc = range->acc + channel;\r\nacc->channel = info->start_channel + channel;\r\nlist_mem = alloc_pages_exact(mem_size, GFP_KERNEL | GFP_DMA);\r\nif (!list_mem)\r\nreturn -ENOMEM;\r\nlist_dma = dma_map_single(kdev->dev, list_mem, mem_size,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(kdev->dev, list_dma)) {\r\nfree_pages_exact(list_mem, mem_size);\r\nreturn -ENOMEM;\r\n}\r\nmemset(list_mem, 0, mem_size);\r\ndma_sync_single_for_device(kdev->dev, list_dma, mem_size,\r\nDMA_TO_DEVICE);\r\nscnprintf(acc->name, sizeof(acc->name), "hwqueue-acc-%d",\r\nacc->channel);\r\nacc->list_cpu[0] = list_mem;\r\nacc->list_cpu[1] = list_mem + list_size;\r\nacc->list_dma[0] = list_dma;\r\nacc->list_dma[1] = list_dma + list_size;\r\ndev_dbg(kdev->dev, "%s: channel %d, phys %08x, virt %8p\n",\r\nacc->name, acc->channel, list_dma, list_mem);\r\n}\r\nrange->ops = &knav_acc_range_ops;\r\nreturn 0;\r\n}
