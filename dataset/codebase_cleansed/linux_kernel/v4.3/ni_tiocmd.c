static void ni_tio_configure_dma(struct ni_gpct *counter,\r\nbool enable, bool read)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned cidx = counter->counter_index;\r\nunsigned mask;\r\nunsigned bits;\r\nmask = GI_READ_ACKS_IRQ | GI_WRITE_ACKS_IRQ;\r\nbits = 0;\r\nif (enable) {\r\nif (read)\r\nbits |= GI_READ_ACKS_IRQ;\r\nelse\r\nbits |= GI_WRITE_ACKS_IRQ;\r\n}\r\nni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), mask, bits);\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nmask = GI_DMA_ENABLE | GI_DMA_INT_ENA | GI_DMA_WRITE;\r\nbits = 0;\r\nif (enable)\r\nbits |= GI_DMA_ENABLE | GI_DMA_INT_ENA;\r\nif (!read)\r\nbits |= GI_DMA_WRITE;\r\nni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), mask, bits);\r\nbreak;\r\n}\r\n}\r\nstatic int ni_tio_input_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (trig_num != cmd->start_src)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (counter->mite_chan)\r\nmite_dma_arm(counter->mite_chan);\r\nelse\r\nret = -EIO;\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);\r\ns->async->inttrig = NULL;\r\nreturn ret;\r\n}\r\nstatic int ni_tio_input_cmd(struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned cidx = counter->counter_index;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint ret = 0;\r\ncomedi_buf_write_alloc(s, async->prealloc_bufsz);\r\ncounter->mite_chan->dir = COMEDI_INPUT;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nmite_prep_dma(counter->mite_chan, 32, 32);\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\nmite_prep_dma(counter->mite_chan, 16, 32);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);\r\nni_tio_configure_dma(counter, true, true);\r\nif (cmd->start_src == TRIG_INT) {\r\nasync->inttrig = &ni_tio_input_inttrig;\r\n} else {\r\nasync->inttrig = NULL;\r\nmite_dma_arm(counter->mite_chan);\r\nif (cmd->start_src == TRIG_NOW)\r\nret = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);\r\nelse if (cmd->start_src == TRIG_EXT)\r\nret = ni_tio_arm(counter, 1, cmd->start_arg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ni_tio_output_cmd(struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\ndev_err(counter->counter_dev->dev->class_dev,\r\n"output commands not yet implemented.\n");\r\nreturn -ENOTSUPP;\r\ncounter->mite_chan->dir = COMEDI_OUTPUT;\r\nmite_prep_dma(counter->mite_chan, 32, 32);\r\nni_tio_configure_dma(counter, true, false);\r\nmite_dma_arm(counter->mite_chan);\r\nreturn ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);\r\n}\r\nstatic int ni_tio_cmd_setup(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct ni_gpct *counter = s->private;\r\nunsigned cidx = counter->counter_index;\r\nint set_gate_source = 0;\r\nunsigned gate_source;\r\nint retval = 0;\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nset_gate_source = 1;\r\ngate_source = cmd->scan_begin_arg;\r\n} else if (cmd->convert_src == TRIG_EXT) {\r\nset_gate_source = 1;\r\ngate_source = cmd->convert_arg;\r\n}\r\nif (set_gate_source)\r\nretval = ni_tio_set_gate_src(counter, 0, gate_source);\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\nni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),\r\nGI_GATE_INTERRUPT_ENABLE(cidx),\r\nGI_GATE_INTERRUPT_ENABLE(cidx));\r\n}\r\nreturn retval;\r\n}\r\nint ni_tio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint retval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (!counter->mite_chan) {\r\ndev_err(counter->counter_dev->dev->class_dev,\r\n"commands only supported with DMA. ");\r\ndev_err(counter->counter_dev->dev->class_dev,\r\n"Interrupt-driven commands not yet implemented.\n");\r\nretval = -EIO;\r\n} else {\r\nretval = ni_tio_cmd_setup(s);\r\nif (retval == 0) {\r\nif (cmd->flags & CMDF_WRITE)\r\nretval = ni_tio_output_cmd(s);\r\nelse\r\nretval = ni_tio_input_cmd(s);\r\n}\r\n}\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nreturn retval;\r\n}\r\nint ni_tio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct ni_gpct *counter = s->private;\r\nint err = 0;\r\nunsigned int sources;\r\nsources = TRIG_NOW | TRIG_INT | TRIG_OTHER;\r\nif (ni_tio_counting_mode_registers_present(counter->counter_dev))\r\nsources |= TRIG_EXT;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, sources);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_EXT | TRIG_OTHER);\r\nerr |= comedi_check_trigger_src(&cmd->convert_src,\r\nTRIG_NOW | TRIG_EXT | TRIG_OTHER);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nif (cmd->convert_src != TRIG_NOW && cmd->scan_begin_src != TRIG_FOLLOW)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\ncase TRIG_INT:\r\ncase TRIG_OTHER:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_EXT:\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src != TRIG_EXT)\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src != TRIG_EXT)\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nint ni_tio_cancel(struct ni_gpct *counter)\r\n{\r\nunsigned cidx = counter->counter_index;\r\nunsigned long flags;\r\nni_tio_arm(counter, 0, 0);\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (counter->mite_chan)\r\nmite_dma_disarm(counter->mite_chan);\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nni_tio_configure_dma(counter, false, false);\r\nni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),\r\nGI_GATE_INTERRUPT_ENABLE(cidx), 0x0);\r\nreturn 0;\r\n}\r\nstatic int should_ack_gate(struct ni_gpct *counter)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nswitch (counter->counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nreturn 1;\r\ncase ni_gpct_variant_e_series:\r\nspin_lock_irqsave(&counter->lock, flags);\r\n{\r\nif (!counter->mite_chan ||\r\ncounter->mite_chan->dir != COMEDI_INPUT ||\r\n(mite_done(counter->mite_chan))) {\r\nretval = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,\r\nint *gate_error,\r\nint *tc_error,\r\nint *perm_stale_data,\r\nint *stale_data)\r\n{\r\nunsigned cidx = counter->counter_index;\r\nconst unsigned short gxx_status = read_register(counter,\r\nNITIO_SHARED_STATUS_REG(cidx));\r\nconst unsigned short gi_status = read_register(counter,\r\nNITIO_STATUS_REG(cidx));\r\nunsigned ack = 0;\r\nif (gate_error)\r\n*gate_error = 0;\r\nif (tc_error)\r\n*tc_error = 0;\r\nif (perm_stale_data)\r\n*perm_stale_data = 0;\r\nif (stale_data)\r\n*stale_data = 0;\r\nif (gxx_status & GI_GATE_ERROR(cidx)) {\r\nack |= GI_GATE_ERROR_CONFIRM(cidx);\r\nif (gate_error) {\r\nif (counter->counter_dev->variant !=\r\nni_gpct_variant_660x)\r\n*gate_error = 1;\r\n}\r\n}\r\nif (gxx_status & GI_TC_ERROR(cidx)) {\r\nack |= GI_TC_ERROR_CONFIRM(cidx);\r\nif (tc_error)\r\n*tc_error = 1;\r\n}\r\nif (gi_status & GI_TC)\r\nack |= GI_TC_INTERRUPT_ACK;\r\nif (gi_status & GI_GATE_INTERRUPT) {\r\nif (should_ack_gate(counter))\r\nack |= GI_GATE_INTERRUPT_ACK;\r\n}\r\nif (ack)\r\nwrite_register(counter, ack, NITIO_INT_ACK_REG(cidx));\r\nif (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &\r\nGI_LOADING_ON_GATE) {\r\nif (gxx_status & GI_STALE_DATA(cidx)) {\r\nif (stale_data)\r\n*stale_data = 1;\r\n}\r\nif (read_register(counter, NITIO_STATUS2_REG(cidx)) &\r\nGI_PERMANENT_STALE(cidx)) {\r\ndev_info(counter->counter_dev->dev->class_dev,\r\n"%s: Gi_Permanent_Stale_Data detected.\n",\r\n__func__);\r\nif (perm_stale_data)\r\n*perm_stale_data = 1;\r\n}\r\n}\r\n}\r\nvoid ni_tio_acknowledge(struct ni_gpct *counter)\r\n{\r\nni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);\r\n}\r\nvoid ni_tio_handle_interrupt(struct ni_gpct *counter,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned cidx = counter->counter_index;\r\nunsigned gpct_mite_status;\r\nunsigned long flags;\r\nint gate_error;\r\nint tc_error;\r\nint perm_stale_data;\r\nni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,\r\n&perm_stale_data, NULL);\r\nif (gate_error) {\r\ndev_notice(counter->counter_dev->dev->class_dev,\r\n"%s: Gi_Gate_Error detected.\n", __func__);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nif (perm_stale_data)\r\ns->async->events |= COMEDI_CB_ERROR;\r\nswitch (counter->counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nif (read_register(counter, NITIO_DMA_STATUS_REG(cidx)) &\r\nGI_DRQ_ERROR) {\r\ndev_notice(counter->counter_dev->dev->class_dev,\r\n"%s: Gi_DRQ_Error detected.\n", __func__);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (!counter->mite_chan) {\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nreturn;\r\n}\r\ngpct_mite_status = mite_get_status(counter->mite_chan);\r\nif (gpct_mite_status & CHSR_LINKC)\r\nwritel(CHOR_CLRLC,\r\ncounter->mite_chan->mite->mite_io_addr +\r\nMITE_CHOR(counter->mite_chan->channel));\r\nmite_sync_input_dma(counter->mite_chan, s);\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\n}\r\nvoid ni_tio_set_mite_channel(struct ni_gpct *counter,\r\nstruct mite_channel *mite_chan)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&counter->lock, flags);\r\ncounter->mite_chan = mite_chan;\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\n}\r\nstatic int __init ni_tiocmd_init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit ni_tiocmd_cleanup_module(void)\r\n{\r\n}
