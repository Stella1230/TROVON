static void vtg_register(struct sti_vtg *vtg)\r\n{\r\nlist_add_tail(&vtg->link, &vtg_lookup);\r\n}\r\nstruct sti_vtg *of_vtg_find(struct device_node *np)\r\n{\r\nstruct sti_vtg *vtg;\r\nlist_for_each_entry(vtg, &vtg_lookup, link) {\r\nif (vtg->np == np)\r\nreturn vtg;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void vtg_reset(struct sti_vtg *vtg)\r\n{\r\nif (vtg->slave)\r\nvtg_reset(vtg->slave);\r\nwritel(1, vtg->regs + VTG_DRST_AUTOC);\r\n}\r\nstatic void vtg_set_output_window(void __iomem *regs,\r\nconst struct drm_display_mode *mode)\r\n{\r\nu32 video_top_field_start;\r\nu32 video_top_field_stop;\r\nu32 video_bottom_field_start;\r\nu32 video_bottom_field_stop;\r\nu32 xstart = sti_vtg_get_pixel_number(*mode, 0);\r\nu32 ystart = sti_vtg_get_line_number(*mode, 0);\r\nu32 xstop = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nu32 ystop = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nvideo_top_field_start = (ystart << 16) | xstart;\r\nvideo_top_field_stop = (ystop << 16) | xstop;\r\nvideo_bottom_field_start = video_top_field_start;\r\nvideo_bottom_field_stop = video_top_field_stop;\r\nwritel(video_top_field_start, regs + VTG_VID_TFO);\r\nwritel(video_top_field_stop, regs + VTG_VID_TFS);\r\nwritel(video_bottom_field_start, regs + VTG_VID_BFO);\r\nwritel(video_bottom_field_stop, regs + VTG_VID_BFS);\r\n}\r\nstatic void vtg_set_mode(struct sti_vtg *vtg,\r\nint type, const struct drm_display_mode *mode)\r\n{\r\nu32 tmp;\r\nif (vtg->slave)\r\nvtg_set_mode(vtg->slave, VTG_TYPE_SLAVE_BY_EXT0, mode);\r\nwritel(mode->htotal, vtg->regs + VTG_CLKLN);\r\nwritel(mode->vtotal * 2, vtg->regs + VTG_HLFLN);\r\nvtg_set_output_window(vtg->regs, mode);\r\ntmp = (mode->hsync_end - mode->hsync_start + HDMI_DELAY) << 16;\r\ntmp |= HDMI_DELAY;\r\nwritel(tmp, vtg->regs + VTG_H_HD_1);\r\ntmp = (mode->vsync_end - mode->vsync_start + 1) << 16;\r\ntmp |= 1;\r\nwritel(tmp, vtg->regs + VTG_TOP_V_VD_1);\r\nwritel(tmp, vtg->regs + VTG_BOT_V_VD_1);\r\ntmp = HDMI_DELAY << 16;\r\ntmp |= HDMI_DELAY;\r\nwritel(tmp, vtg->regs + VTG_TOP_V_HD_1);\r\nwritel(tmp, vtg->regs + VTG_BOT_V_HD_1);\r\ntmp = (mode->hsync_end - mode->hsync_start) << 16;\r\nwritel(tmp, vtg->regs + VTG_H_HD_2);\r\ntmp = (mode->vsync_end - mode->vsync_start + 1) << 16;\r\ntmp |= 1;\r\nwritel(tmp, vtg->regs + VTG_TOP_V_VD_2);\r\nwritel(tmp, vtg->regs + VTG_BOT_V_VD_2);\r\nwritel(0, vtg->regs + VTG_TOP_V_HD_2);\r\nwritel(0, vtg->regs + VTG_BOT_V_HD_2);\r\ntmp = (mode->hsync_end - mode->hsync_start + AWG_DELAY_HD) << 16;\r\ntmp |= mode->htotal + AWG_DELAY_HD;\r\nwritel(tmp, vtg->regs + VTG_H_HD_3);\r\ntmp = (mode->vsync_end - mode->vsync_start) << 16;\r\ntmp |= mode->vtotal;\r\nwritel(tmp, vtg->regs + VTG_TOP_V_VD_3);\r\nwritel(tmp, vtg->regs + VTG_BOT_V_VD_3);\r\ntmp = (mode->htotal + AWG_DELAY_HD) << 16;\r\ntmp |= mode->htotal + AWG_DELAY_HD;\r\nwritel(tmp, vtg->regs + VTG_TOP_V_HD_3);\r\nwritel(tmp, vtg->regs + VTG_BOT_V_HD_3);\r\ntmp = (mode->hsync_end - mode->hsync_start) << 16;\r\nwritel(tmp, vtg->regs + VTG_H_HD_4);\r\ntmp = (mode->vsync_end - mode->vsync_start + 1) << 16;\r\ntmp |= 1;\r\nwritel(tmp, vtg->regs + VTG_TOP_V_VD_4);\r\nwritel(tmp, vtg->regs + VTG_BOT_V_VD_4);\r\nwritel(0, vtg->regs + VTG_TOP_V_HD_4);\r\nwritel(0, vtg->regs + VTG_BOT_V_HD_4);\r\nwritel(type, vtg->regs + VTG_MODE);\r\n}\r\nstatic void vtg_enable_irq(struct sti_vtg *vtg)\r\n{\r\nwritel(0xFFFF, vtg->regs + VTG_HOST_ITS_BCLR);\r\nwritel(0xFFFF, vtg->regs + VTG_HOST_ITM_BCLR);\r\nwritel(VTG_IRQ_MASK, vtg->regs + VTG_HOST_ITM_BSET);\r\n}\r\nvoid sti_vtg_set_config(struct sti_vtg *vtg,\r\nconst struct drm_display_mode *mode)\r\n{\r\nvtg_set_mode(vtg, VTG_TYPE_MASTER, mode);\r\nvtg_reset(vtg);\r\nif (vtg->slave)\r\nvtg_enable_irq(vtg->slave);\r\nelse\r\nvtg_enable_irq(vtg);\r\n}\r\nu32 sti_vtg_get_line_number(struct drm_display_mode mode, int y)\r\n{\r\nu32 start_line = mode.vtotal - mode.vsync_start + 1;\r\nif (mode.flags & DRM_MODE_FLAG_INTERLACE)\r\nstart_line *= 2;\r\nreturn start_line + y;\r\n}\r\nu32 sti_vtg_get_pixel_number(struct drm_display_mode mode, int x)\r\n{\r\nreturn mode.htotal - mode.hsync_start + x;\r\n}\r\nint sti_vtg_register_client(struct sti_vtg *vtg,\r\nstruct notifier_block *nb, int crtc_id)\r\n{\r\nif (vtg->slave)\r\nreturn sti_vtg_register_client(vtg->slave, nb, crtc_id);\r\nvtg->crtc_id = crtc_id;\r\nreturn raw_notifier_chain_register(&vtg->notifier_list, nb);\r\n}\r\nint sti_vtg_unregister_client(struct sti_vtg *vtg, struct notifier_block *nb)\r\n{\r\nif (vtg->slave)\r\nreturn sti_vtg_unregister_client(vtg->slave, nb);\r\nreturn raw_notifier_chain_unregister(&vtg->notifier_list, nb);\r\n}\r\nstatic irqreturn_t vtg_irq_thread(int irq, void *arg)\r\n{\r\nstruct sti_vtg *vtg = arg;\r\nu32 event;\r\nevent = (vtg->irq_status & VTG_IRQ_TOP) ?\r\nVTG_TOP_FIELD_EVENT : VTG_BOTTOM_FIELD_EVENT;\r\nraw_notifier_call_chain(&vtg->notifier_list, event, &vtg->crtc_id);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t vtg_irq(int irq, void *arg)\r\n{\r\nstruct sti_vtg *vtg = arg;\r\nvtg->irq_status = readl(vtg->regs + VTG_HOST_ITS);\r\nwritel(vtg->irq_status, vtg->regs + VTG_HOST_ITS_BCLR);\r\nreadl(vtg->regs + VTG_HOST_ITS);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int vtg_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np;\r\nstruct sti_vtg *vtg;\r\nstruct resource *res;\r\nint ret;\r\nvtg = devm_kzalloc(dev, sizeof(*vtg), GFP_KERNEL);\r\nif (!vtg)\r\nreturn -ENOMEM;\r\nvtg->dev = dev;\r\nvtg->np = pdev->dev.of_node;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nDRM_ERROR("Get memory resource failed\n");\r\nreturn -ENOMEM;\r\n}\r\nvtg->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nnp = of_parse_phandle(pdev->dev.of_node, "st,slave", 0);\r\nif (np) {\r\nvtg->slave = of_vtg_find(np);\r\nif (!vtg->slave)\r\nreturn -EPROBE_DEFER;\r\n} else {\r\nvtg->irq = platform_get_irq(pdev, 0);\r\nif (IS_ERR_VALUE(vtg->irq)) {\r\nDRM_ERROR("Failed to get VTG interrupt\n");\r\nreturn vtg->irq;\r\n}\r\nRAW_INIT_NOTIFIER_HEAD(&vtg->notifier_list);\r\nret = devm_request_threaded_irq(dev, vtg->irq, vtg_irq,\r\nvtg_irq_thread, IRQF_ONESHOT,\r\ndev_name(dev), vtg);\r\nif (IS_ERR_VALUE(ret)) {\r\nDRM_ERROR("Failed to register VTG interrupt\n");\r\nreturn ret;\r\n}\r\n}\r\nvtg_register(vtg);\r\nplatform_set_drvdata(pdev, vtg);\r\nDRM_INFO("%s %s\n", __func__, dev_name(vtg->dev));\r\nreturn 0;\r\n}\r\nstatic int vtg_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}
