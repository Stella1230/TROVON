static u32 rtl8192_CalculateBitShift(u32 bitmask)\r\n{\r\nu32 i;\r\ni = ffs(bitmask) - 1;\r\nreturn i;\r\n}\r\nu8 rtl8192_phy_CheckIsLegalRFPath(struct net_device *dev, u32 eRFPath)\r\n{\r\nu8 ret = 1;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->rf_type == RF_2T4R) {\r\nret = 0;\r\n} else if (priv->rf_type == RF_1T2R) {\r\nif (eRFPath == RF90_PATH_A || eRFPath == RF90_PATH_B)\r\nret = 1;\r\nelse if (eRFPath == RF90_PATH_C || eRFPath == RF90_PATH_D)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_setBBreg(struct net_device *dev, u32 reg_addr, u32 bitmask,\r\nu32 data)\r\n{\r\nu32 reg, bitshift;\r\nif (bitmask != bMaskDWord) {\r\nread_nic_dword(dev, reg_addr, &reg);\r\nbitshift = rtl8192_CalculateBitShift(bitmask);\r\nreg &= ~bitmask;\r\nreg |= data << bitshift;\r\nwrite_nic_dword(dev, reg_addr, reg);\r\n} else {\r\nwrite_nic_dword(dev, reg_addr, data);\r\n}\r\n}\r\nu32 rtl8192_QueryBBReg(struct net_device *dev, u32 reg_addr, u32 bitmask)\r\n{\r\nu32 reg, bitshift;\r\nread_nic_dword(dev, reg_addr, &reg);\r\nbitshift = rtl8192_CalculateBitShift(bitmask);\r\nreturn (reg & bitmask) >> bitshift;\r\n}\r\nstatic u32 rtl8192_phy_RFSerialRead(struct net_device *dev,\r\nRF90_RADIO_PATH_E eRFPath, u32 offset)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 ret = 0;\r\nu32 new_offset = 0;\r\nBB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];\r\nrtl8192_setBBreg(dev, pPhyReg->rfLSSIReadBack, bLSSIReadBackData, 0);\r\noffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256) {\r\nif (offset >= 31) {\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\npriv->RfReg0Value[eRFPath]<<16);\r\nnew_offset = offset - 30;\r\n} else if (offset >= 16) {\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\npriv->RfReg0Value[eRFPath]<<16);\r\nnew_offset = offset - 15;\r\n} else {\r\nnew_offset = offset;\r\n}\r\n} else {\r\nRT_TRACE((COMP_PHY|COMP_ERR),\r\n"check RF type here, need to be 8256\n");\r\nnew_offset = offset;\r\n}\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadAddress,\r\nnew_offset);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x0);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2, bLSSIReadEdge, 0x1);\r\nusleep_range(1000, 1000);\r\nret = rtl8192_QueryBBReg(dev, pPhyReg->rfLSSIReadBack,\r\nbLSSIReadBackData);\r\nif (priv->rf_chip == RF_8256) {\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord,\r\npriv->RfReg0Value[eRFPath] << 16);\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_phy_RFSerialWrite(struct net_device *dev,\r\nRF90_RADIO_PATH_E eRFPath, u32 offset,\r\nu32 data)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 DataAndAddr = 0, new_offset = 0;\r\nBB_REGISTER_DEFINITION_T *pPhyReg = &priv->PHYRegDef[eRFPath];\r\noffset &= 0x3f;\r\nif (priv->rf_chip == RF_8256) {\r\nif (offset >= 31) {\r\npriv->RfReg0Value[eRFPath] |= 0x140;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\npriv->RfReg0Value[eRFPath] << 16);\r\nnew_offset = offset - 30;\r\n} else if (offset >= 16) {\r\npriv->RfReg0Value[eRFPath] |= 0x100;\r\npriv->RfReg0Value[eRFPath] &= (~0x40);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\npriv->RfReg0Value[eRFPath]<<16);\r\nnew_offset = offset - 15;\r\n} else {\r\nnew_offset = offset;\r\n}\r\n} else {\r\nRT_TRACE((COMP_PHY|COMP_ERR),\r\n"check RF type here, need to be 8256\n");\r\nnew_offset = offset;\r\n}\r\nDataAndAddr = (data<<16) | (new_offset&0x3f);\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset, bMaskDWord, DataAndAddr);\r\nif (offset == 0x0)\r\npriv->RfReg0Value[eRFPath] = data;\r\nif (priv->rf_chip == RF_8256) {\r\nif (offset != 0) {\r\npriv->RfReg0Value[eRFPath] &= 0xebf;\r\nrtl8192_setBBreg(dev, pPhyReg->rf3wireOffset,\r\nbMaskDWord,\r\npriv->RfReg0Value[eRFPath] << 16);\r\n}\r\n}\r\n}\r\nvoid rtl8192_phy_SetRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,\r\nu32 reg_addr, u32 bitmask, u32 data)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 reg, bitshift;\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\nreturn;\r\nif (priv->Rf_Mode == RF_OP_By_FW) {\r\nif (bitmask != bMask12Bits) {\r\nreg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);\r\nbitshift = rtl8192_CalculateBitShift(bitmask);\r\nreg &= ~bitmask;\r\nreg |= data << bitshift;\r\nphy_FwRFSerialWrite(dev, eRFPath, reg_addr, reg);\r\n} else {\r\nphy_FwRFSerialWrite(dev, eRFPath, reg_addr, data);\r\n}\r\nudelay(200);\r\n} else {\r\nif (bitmask != bMask12Bits) {\r\nreg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);\r\nbitshift = rtl8192_CalculateBitShift(bitmask);\r\nreg &= ~bitmask;\r\nreg |= data << bitshift;\r\nrtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, reg);\r\n} else {\r\nrtl8192_phy_RFSerialWrite(dev, eRFPath, reg_addr, data);\r\n}\r\n}\r\n}\r\nu32 rtl8192_phy_QueryRFReg(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,\r\nu32 reg_addr, u32 bitmask)\r\n{\r\nu32 reg, bitshift;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\nreturn 0;\r\nif (priv->Rf_Mode == RF_OP_By_FW) {\r\nreg = phy_FwRFSerialRead(dev, eRFPath, reg_addr);\r\nudelay(200);\r\n} else {\r\nreg = rtl8192_phy_RFSerialRead(dev, eRFPath, reg_addr);\r\n}\r\nbitshift = rtl8192_CalculateBitShift(bitmask);\r\nreg = (reg & bitmask) >> bitshift;\r\nreturn reg;\r\n}\r\nstatic u32 phy_FwRFSerialRead(struct net_device *dev, RF90_RADIO_PATH_E eRFPath,\r\nu32 offset)\r\n{\r\nu32 reg = 0;\r\nu32 data = 0;\r\nu8 time = 0;\r\nu32 tmp;\r\ndata |= ((offset&0xFF)<<12);\r\ndata |= ((eRFPath&0x3)<<20);\r\ndata |= 0x80000000;\r\nread_nic_dword(dev, QPNR, &tmp);\r\nwhile (tmp & 0x80000000) {\r\nif (time++ < 100) {\r\nudelay(10);\r\nread_nic_dword(dev, QPNR, &tmp);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nwrite_nic_dword(dev, QPNR, data);\r\nread_nic_dword(dev, QPNR, &tmp);\r\nwhile (tmp & 0x80000000) {\r\nif (time++ < 100) {\r\nudelay(10);\r\nread_nic_dword(dev, QPNR, &tmp);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nread_nic_dword(dev, RF_DATA, &reg);\r\nreturn reg;\r\n}\r\nstatic void phy_FwRFSerialWrite(struct net_device *dev,\r\nRF90_RADIO_PATH_E eRFPath, u32 offset, u32 data)\r\n{\r\nu8 time = 0;\r\nu32 tmp;\r\ndata |= ((offset&0xFF)<<12);\r\ndata |= ((eRFPath&0x3)<<20);\r\ndata |= 0x400000;\r\ndata |= 0x80000000;\r\nread_nic_dword(dev, QPNR, &tmp);\r\nwhile (tmp & 0x80000000) {\r\nif (time++ < 100) {\r\nudelay(10);\r\nread_nic_dword(dev, QPNR, &tmp);\r\n} else {\r\nbreak;\r\n}\r\n}\r\nwrite_nic_dword(dev, QPNR, data);\r\n}\r\nvoid rtl8192_phy_configmac(struct net_device *dev)\r\n{\r\nu32 dwArrayLen = 0, i;\r\nu32 *pdwArray = NULL;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->btxpowerdata_readfromEEPORM) {\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array_PG\n");\r\ndwArrayLen = MACPHY_Array_PGLength;\r\npdwArray = rtl819XMACPHY_Array_PG;\r\n} else {\r\nRT_TRACE(COMP_PHY, "Rtl819XMACPHY_Array\n");\r\ndwArrayLen = MACPHY_ArrayLength;\r\npdwArray = rtl819XMACPHY_Array;\r\n}\r\nfor (i = 0; i < dwArrayLen; i = i+3) {\r\nif (pdwArray[i] == 0x318)\r\npdwArray[i+2] = 0x00000800;\r\nRT_TRACE(COMP_DBG,\r\n"Rtl8190MACPHY_Array[0]=%x Rtl8190MACPHY_Array[1]=%x Rtl8190MACPHY_Array[2]=%x\n",\r\npdwArray[i], pdwArray[i+1], pdwArray[i+2]);\r\nrtl8192_setBBreg(dev, pdwArray[i], pdwArray[i+1],\r\npdwArray[i+2]);\r\n}\r\n}\r\nvoid rtl8192_phyConfigBB(struct net_device *dev, u8 ConfigType)\r\n{\r\nu32 i;\r\n#ifdef TO_DO_LIST\r\nu32 *rtl8192PhyRegArrayTable = NULL, *rtl8192AgcTabArrayTable = NULL;\r\nif (Adapter->bInHctTest) {\r\nPHY_REGArrayLen = PHY_REGArrayLengthDTM;\r\nAGCTAB_ArrayLen = AGCTAB_ArrayLengthDTM;\r\nRtl8190PHY_REGArray_Table = Rtl819XPHY_REGArrayDTM;\r\nRtl8190AGCTAB_Array_Table = Rtl819XAGCTAB_ArrayDTM;\r\n}\r\n#endif\r\nif (ConfigType == BaseBand_Config_PHY_REG) {\r\nfor (i = 0; i < PHY_REG_1T2RArrayLength; i += 2) {\r\nrtl8192_setBBreg(dev, rtl819XPHY_REG_1T2RArray[i],\r\nbMaskDWord,\r\nrtl819XPHY_REG_1T2RArray[i+1]);\r\nRT_TRACE(COMP_DBG,\r\n"i: %x, Rtl819xUsbPHY_REGArray[0]=%x Rtl819xUsbPHY_REGArray[1]=%x\n",\r\ni, rtl819XPHY_REG_1T2RArray[i],\r\nrtl819XPHY_REG_1T2RArray[i+1]);\r\n}\r\n} else if (ConfigType == BaseBand_Config_AGC_TAB) {\r\nfor (i = 0; i < AGCTAB_ArrayLength; i += 2) {\r\nrtl8192_setBBreg(dev, rtl819XAGCTAB_Array[i],\r\nbMaskDWord, rtl819XAGCTAB_Array[i+1]);\r\nRT_TRACE(COMP_DBG,\r\n"i: %x, rtl819XAGCTAB_Array[0]=%x rtl819XAGCTAB_Array[1]=%x\n",\r\ni, rtl819XAGCTAB_Array[i],\r\nrtl819XAGCTAB_Array[i+1]);\r\n}\r\n}\r\n}\r\nstatic void rtl8192_InitBBRFRegDef(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->PHYRegDef[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfs = rFPGA0_XCD_RFInterfaceSW;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfi = rFPGA0_XAB_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfi = rFPGA0_XCD_RFInterfaceRB;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfo = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfo = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_C].rfintfe = rFPGA0_XC_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_D].rfintfe = rFPGA0_XD_RFInterfaceOE;\r\npriv->PHYRegDef[RF90_PATH_A].rf3wireOffset = rFPGA0_XA_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rf3wireOffset = rFPGA0_XB_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rf3wireOffset = rFPGA0_XC_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rf3wireOffset = rFPGA0_XD_LSSIParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSI_Select = rFPGA0_XAB_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSI_Select = rFPGA0_XCD_RFParameter;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxGainStage = rFPGA0_TxGainStage;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara1 = rFPGA0_XA_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara1 = rFPGA0_XB_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara1 = rFPGA0_XC_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara1 = rFPGA0_XD_HSSIParameter1;\r\npriv->PHYRegDef[RF90_PATH_A].rfHSSIPara2 = rFPGA0_XA_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_B].rfHSSIPara2 = rFPGA0_XB_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_C].rfHSSIPara2 = rFPGA0_XC_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_D].rfHSSIPara2 = rFPGA0_XD_HSSIParameter2;\r\npriv->PHYRegDef[RF90_PATH_A].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_B].rfSwitchControl = rFPGA0_XAB_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_C].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_D].rfSwitchControl = rFPGA0_XCD_SwitchControl;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl1 = rOFDM0_XAAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl1 = rOFDM0_XBAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl1 = rOFDM0_XCAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl1 = rOFDM0_XDAGCCore1;\r\npriv->PHYRegDef[RF90_PATH_A].rfAGCControl2 = rOFDM0_XAAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_B].rfAGCControl2 = rOFDM0_XBAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_C].rfAGCControl2 = rOFDM0_XCAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_D].rfAGCControl2 = rOFDM0_XDAGCCore2;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxIQImbalance = rOFDM0_XARxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxIQImbalance = rOFDM0_XBRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxIQImbalance = rOFDM0_XCRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxIQImbalance = rOFDM0_XDRxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfRxAFE = rOFDM0_XARxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfRxAFE = rOFDM0_XBRxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfRxAFE = rOFDM0_XCRxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfRxAFE = rOFDM0_XDRxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxIQImbalance = rOFDM0_XATxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxIQImbalance = rOFDM0_XBTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxIQImbalance = rOFDM0_XCTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxIQImbalance = rOFDM0_XDTxIQImbalance;\r\npriv->PHYRegDef[RF90_PATH_A].rfTxAFE = rOFDM0_XATxAFE;\r\npriv->PHYRegDef[RF90_PATH_B].rfTxAFE = rOFDM0_XBTxAFE;\r\npriv->PHYRegDef[RF90_PATH_C].rfTxAFE = rOFDM0_XCTxAFE;\r\npriv->PHYRegDef[RF90_PATH_D].rfTxAFE = rOFDM0_XDTxAFE;\r\npriv->PHYRegDef[RF90_PATH_A].rfLSSIReadBack = rFPGA0_XA_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_B].rfLSSIReadBack = rFPGA0_XB_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_C].rfLSSIReadBack = rFPGA0_XC_LSSIReadBack;\r\npriv->PHYRegDef[RF90_PATH_D].rfLSSIReadBack = rFPGA0_XD_LSSIReadBack;\r\n}\r\nu8 rtl8192_phy_checkBBAndRF(struct net_device *dev, HW90_BLOCK_E CheckBlock,\r\nRF90_RADIO_PATH_E eRFPath)\r\n{\r\nu8 ret = 0;\r\nu32 i, CheckTimes = 4, reg = 0;\r\nu32 WriteAddr[4];\r\nu32 WriteData[] = {0xfffff027, 0xaa55a02f, 0x00000027, 0x55aa502f};\r\nWriteAddr[HW90_BLOCK_MAC] = 0x100;\r\nWriteAddr[HW90_BLOCK_PHY0] = 0x900;\r\nWriteAddr[HW90_BLOCK_PHY1] = 0x800;\r\nWriteAddr[HW90_BLOCK_RF] = 0x3;\r\nRT_TRACE(COMP_PHY, "%s(), CheckBlock: %d\n", __func__, CheckBlock);\r\nfor (i = 0; i < CheckTimes; i++) {\r\nswitch (CheckBlock) {\r\ncase HW90_BLOCK_MAC:\r\nRT_TRACE(COMP_ERR,\r\n"PHY_CheckBBRFOK(): Never Write 0x100 here!\n");\r\nbreak;\r\ncase HW90_BLOCK_PHY0:\r\ncase HW90_BLOCK_PHY1:\r\nwrite_nic_dword(dev, WriteAddr[CheckBlock],\r\nWriteData[i]);\r\nread_nic_dword(dev, WriteAddr[CheckBlock], &reg);\r\nbreak;\r\ncase HW90_BLOCK_RF:\r\nWriteData[i] &= 0xfff;\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nWriteAddr[HW90_BLOCK_RF],\r\nbMask12Bits, WriteData[i]);\r\nusleep_range(1000, 1000);\r\nreg = rtl8192_phy_QueryRFReg(dev, eRFPath,\r\nWriteAddr[HW90_BLOCK_RF],\r\nbMask12Bits);\r\nusleep_range(1000, 1000);\r\nbreak;\r\ndefault:\r\nret = 1;\r\nbreak;\r\n}\r\nif (reg != WriteData[i]) {\r\nRT_TRACE((COMP_PHY|COMP_ERR),\r\n"error reg: %x, WriteData: %x\n",\r\nreg, WriteData[i]);\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_BB_Config_ParaFile(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 reg_u8 = 0, eCheckItem = 0, status = 0;\r\nu32 reg_u32 = 0;\r\nread_nic_byte(dev, BB_GLOBAL_RESET, &reg_u8);\r\nwrite_nic_byte(dev, BB_GLOBAL_RESET, (reg_u8|BB_GLOBAL_RESET_BIT));\r\nmdelay(50);\r\nread_nic_dword(dev, CPU_GEN, &reg_u32);\r\nwrite_nic_dword(dev, CPU_GEN, (reg_u32&(~CPU_GEN_BB_RST)));\r\nfor (eCheckItem = (HW90_BLOCK_E)HW90_BLOCK_PHY0;\r\neCheckItem <= HW90_BLOCK_PHY1; eCheckItem++) {\r\nstatus = rtl8192_phy_checkBBAndRF(dev, (HW90_BLOCK_E)eCheckItem,\r\n(RF90_RADIO_PATH_E)0);\r\nif (status != 0) {\r\nRT_TRACE((COMP_ERR | COMP_PHY),\r\n"PHY_RF8256_Config(): Check PHY%d Fail!!\n",\r\neCheckItem-1);\r\nreturn;\r\n}\r\n}\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn|bOFDMEn, 0x0);\r\nrtl8192_phyConfigBB(dev, BaseBand_Config_PHY_REG);\r\nread_nic_dword(dev, CPU_GEN, &reg_u32);\r\nwrite_nic_dword(dev, CPU_GEN, (reg_u32|CPU_GEN_BB_RST));\r\nrtl8192_phyConfigBB(dev, BaseBand_Config_AGC_TAB);\r\nwrite_nic_byte_E(dev, 0x5e, 0x00);\r\nif (priv->card_8192_version == (u8)VERSION_819xU_A) {\r\nreg_u32 = priv->AntennaTxPwDiff[1]<<4 |\r\npriv->AntennaTxPwDiff[0];\r\nrtl8192_setBBreg(dev, rFPGA0_TxGainStage, (bXBTxAGC|bXCTxAGC),\r\nreg_u32);\r\nreg_u32 = priv->CrystalCap & 0xf;\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, bXtalCap,\r\nreg_u32);\r\n}\r\npriv->bCckHighPower = (u8)rtl8192_QueryBBReg(dev,\r\nrFPGA0_XA_HSSIParameter2,\r\n0x200);\r\n}\r\nvoid rtl8192_BBConfig(struct net_device *dev)\r\n{\r\nrtl8192_InitBBRFRegDef(dev);\r\nrtl8192_BB_Config_ParaFile(dev);\r\n}\r\nvoid rtl8192_phy_getTxPower(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 tmp;\r\nread_nic_dword(dev, rTxAGC_Rate18_06,\r\n&priv->MCSTxPowerLevelOriginalOffset[0]);\r\nread_nic_dword(dev, rTxAGC_Rate54_24,\r\n&priv->MCSTxPowerLevelOriginalOffset[1]);\r\nread_nic_dword(dev, rTxAGC_Mcs03_Mcs00,\r\n&priv->MCSTxPowerLevelOriginalOffset[2]);\r\nread_nic_dword(dev, rTxAGC_Mcs07_Mcs04,\r\n&priv->MCSTxPowerLevelOriginalOffset[3]);\r\nread_nic_dword(dev, rTxAGC_Mcs11_Mcs08,\r\n&priv->MCSTxPowerLevelOriginalOffset[4]);\r\nread_nic_dword(dev, rTxAGC_Mcs15_Mcs12,\r\n&priv->MCSTxPowerLevelOriginalOffset[5]);\r\nread_nic_byte(dev, rOFDM0_XAAGCCore1, &priv->DefaultInitialGain[0]);\r\nread_nic_byte(dev, rOFDM0_XBAGCCore1, &priv->DefaultInitialGain[1]);\r\nread_nic_byte(dev, rOFDM0_XCAGCCore1, &priv->DefaultInitialGain[2]);\r\nread_nic_byte(dev, rOFDM0_XDAGCCore1, &priv->DefaultInitialGain[3]);\r\nRT_TRACE(COMP_INIT,\r\n"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\n",\r\npriv->DefaultInitialGain[0], priv->DefaultInitialGain[1],\r\npriv->DefaultInitialGain[2], priv->DefaultInitialGain[3]);\r\nread_nic_byte(dev, rOFDM0_RxDetector3, &priv->framesync);\r\nread_nic_byte(dev, rOFDM0_RxDetector2, &tmp);\r\npriv->framesyncC34 = tmp;\r\nRT_TRACE(COMP_INIT, "Default framesync (0x%x) = 0x%x\n",\r\nrOFDM0_RxDetector3, priv->framesync);\r\nread_nic_word(dev, SIFS, &priv->SifsTime);\r\n}\r\nvoid rtl8192_phy_setTxPower(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nPHY_SetRF8256CCKTxPower(dev, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);\r\nbreak;\r\ndefault:\r\nRT_TRACE((COMP_PHY|COMP_ERR),\r\n"error RF chipID(8225 or 8258) in function %s()\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\nvoid rtl8192_phy_RFConfig(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nPHY_RF8256_Config(dev);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "error chip id\n");\r\nbreak;\r\n}\r\n}\r\nvoid rtl8192_phy_updateInitGain(struct net_device *dev)\r\n{\r\n}\r\nu8 rtl8192_phy_ConfigRFWithHeaderFile(struct net_device *dev,\r\nRF90_RADIO_PATH_E eRFPath)\r\n{\r\nint i;\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\nfor (i = 0; i < RadioA_ArrayLength; i = i+2) {\r\nif (rtl819XRadioA_Array[i] == 0xfe) {\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nrtl819XRadioA_Array[i],\r\nbMask12Bits,\r\nrtl819XRadioA_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nfor (i = 0; i < RadioB_ArrayLength; i = i+2) {\r\nif (rtl819XRadioB_Array[i] == 0xfe) {\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nrtl819XRadioB_Array[i],\r\nbMask12Bits,\r\nrtl819XRadioB_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nfor (i = 0; i < RadioC_ArrayLength; i = i+2) {\r\nif (rtl819XRadioC_Array[i] == 0xfe) {\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nrtl819XRadioC_Array[i],\r\nbMask12Bits,\r\nrtl819XRadioC_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nfor (i = 0; i < RadioD_ArrayLength; i = i+2) {\r\nif (rtl819XRadioD_Array[i] == 0xfe) {\r\nmdelay(100);\r\ncontinue;\r\n}\r\nrtl8192_phy_SetRFReg(dev, eRFPath,\r\nrtl819XRadioD_Array[i],\r\nbMask12Bits,\r\nrtl819XRadioD_Array[i+1]);\r\nmdelay(1);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtl8192_SetTxPowerLevel(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 powerlevel = priv->TxPowerLevelCCK[channel-1];\r\nu8 powerlevelOFDM24G = priv->TxPowerLevelOFDM24G[channel-1];\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\n#ifdef TO_DO_LIST\r\nPHY_SetRF8225CckTxPower(Adapter, powerlevel);\r\nPHY_SetRF8225OfdmTxPower(Adapter, powerlevelOFDM24G);\r\n#endif\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256CCKTxPower(dev, powerlevel);\r\nPHY_SetRF8256OFDMTxPower(dev, powerlevelOFDM24G);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "unknown rf chip ID in %s()\n", __func__);\r\nbreak;\r\n}\r\n}\r\nbool rtl8192_SetRFPowerState(struct net_device *dev,\r\nRT_RF_POWER_STATE eRFPowerState)\r\n{\r\nbool bResult = true;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (eRFPowerState == priv->ieee80211->eRFPowerState)\r\nreturn false;\r\nif (priv->SetRFPowerStateInProgress)\r\nreturn false;\r\npriv->SetRFPowerStateInProgress = true;\r\nswitch (priv->rf_chip) {\r\ncase RF_8256:\r\nswitch (eRFPowerState) {\r\ncase eRfOn:\r\nrtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,\r\n0x1);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300,\r\n0x3);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18,\r\n0x3);\r\nrtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0x3, 0x3);\r\nrtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0x3, 0x3);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60,\r\n0x3);\r\nbreak;\r\ncase eRfSleep:\r\nbreak;\r\ncase eRfOff:\r\nrtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,\r\n0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00,\r\n0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x18,\r\n0x0);\r\nrtl8192_setBBreg(dev, rOFDM0_TRxPathEnable, 0xf, 0x0);\r\nrtl8192_setBBreg(dev, rOFDM1_TRxPathEnable, 0xf, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x60,\r\n0x0);\r\nbreak;\r\ndefault:\r\nbResult = false;\r\nRT_TRACE(COMP_ERR, "%s(): unknown state to set: 0x%X\n",\r\n__func__, eRFPowerState);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Not support rf_chip(%x)\n", priv->rf_chip);\r\nbreak;\r\n}\r\n#ifdef TO_DO_LIST\r\nif (bResult) {\r\npHalData->eRFPowerState = eRFPowerState;\r\nswitch (pHalData->RFChipID) {\r\ncase RF_8256:\r\nswitch (pHalData->eRFPowerState) {\r\ncase eRfOff:\r\nif (pMgntInfo->RfOffReason == RF_CHANGE_BY_IPS)\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);\r\nelse\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_POWER_OFF);\r\nbreak;\r\ncase eRfOn:\r\nif (pMgntInfo->bMediaConnect)\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_LINK);\r\nelse\r\nAdapter->HalFunc.LedControlHandler(Adapter, LED_CTL_NO_LINK);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_RF, DBG_LOUD, "%s(): Unknown RF type\n",\r\n__func__);\r\nbreak;\r\n}\r\n}\r\n#endif\r\npriv->SetRFPowerStateInProgress = false;\r\nreturn bResult;\r\n}\r\nstatic u8 rtl8192_phy_SetSwChnlCmdArray(SwChnlCmd *CmdTable, u32 CmdTableIdx,\r\nu32 CmdTableSz, SwChnlCmdID CmdID,\r\nu32 Para1, u32 Para2, u32 msDelay)\r\n{\r\nSwChnlCmd *pCmd;\r\nif (CmdTable == NULL) {\r\nRT_TRACE(COMP_ERR, "%s(): CmdTable cannot be NULL\n", __func__);\r\nreturn false;\r\n}\r\nif (CmdTableIdx >= CmdTableSz) {\r\nRT_TRACE(COMP_ERR, "%s(): Access invalid index, please check size of the table, CmdTableIdx:%d, CmdTableSz:%d\n",\r\n__func__, CmdTableIdx, CmdTableSz);\r\nreturn false;\r\n}\r\npCmd = CmdTable + CmdTableIdx;\r\npCmd->CmdID = CmdID;\r\npCmd->Para1 = Para1;\r\npCmd->Para2 = Para2;\r\npCmd->msDelay = msDelay;\r\nreturn true;\r\n}\r\nstatic u8 rtl8192_phy_SwChnlStepByStep(struct net_device *dev, u8 channel,\r\nu8 *stage, u8 *step, u32 *delay)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nSwChnlCmd PreCommonCmd[MAX_PRECMD_CNT];\r\nu32 PreCommonCmdCnt;\r\nSwChnlCmd PostCommonCmd[MAX_POSTCMD_CNT];\r\nu32 PostCommonCmdCnt;\r\nSwChnlCmd RfDependCmd[MAX_RFDEPENDCMD_CNT];\r\nu32 RfDependCmdCnt;\r\nSwChnlCmd *CurrentCmd = NULL;\r\nu8 eRFPath;\r\nRT_TRACE(COMP_CH, "%s() stage: %d, step: %d, channel: %d\n",\r\n__func__, *stage, *step, channel);\r\nif (!IsLegalChannel(priv->ieee80211, channel)) {\r\nRT_TRACE(COMP_ERR, "set to illegal channel: %d\n", channel);\r\nreturn true;\r\n}\r\nPreCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,\r\nMAX_PRECMD_CNT, CmdID_SetTxPowerLevel,\r\n0, 0, 0);\r\nrtl8192_phy_SetSwChnlCmdArray(PreCommonCmd, PreCommonCmdCnt++,\r\nMAX_PRECMD_CNT, CmdID_End, 0, 0, 0);\r\nPostCommonCmdCnt = 0;\r\nrtl8192_phy_SetSwChnlCmdArray(PostCommonCmd, PostCommonCmdCnt++,\r\nMAX_POSTCMD_CNT, CmdID_End, 0, 0, 0);\r\nRfDependCmdCnt = 0;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\nif (!(channel >= 1 && channel <= 14)) {\r\nRT_TRACE(COMP_ERR,\r\n"illegal channel for Zebra 8225: %d\n",\r\nchannel);\r\nreturn true;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg,\r\nrZebra1_Channel,\r\nRF_CHANNEL_TABLE_ZEBRA[channel],\r\n10);\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8256:\r\nif (!(channel >= 1 && channel <= 14)) {\r\nRT_TRACE(COMP_ERR,\r\n"illegal channel for Zebra 8256: %d\n",\r\nchannel);\r\nreturn true;\r\n}\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_RF_WriteReg,\r\nrZebra1_Channel, channel, 10);\r\nrtl8192_phy_SetSwChnlCmdArray(RfDependCmd, RfDependCmdCnt++,\r\nMAX_RFDEPENDCMD_CNT,\r\nCmdID_End, 0, 0, 0);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);\r\nreturn true;\r\n}\r\ndo {\r\nswitch (*stage) {\r\ncase 0:\r\nCurrentCmd = &PreCommonCmd[*step];\r\nbreak;\r\ncase 1:\r\nCurrentCmd = &RfDependCmd[*step];\r\nbreak;\r\ncase 2:\r\nCurrentCmd = &PostCommonCmd[*step];\r\nbreak;\r\n}\r\nif (CurrentCmd->CmdID == CmdID_End) {\r\nif ((*stage) == 2) {\r\n(*delay) = CurrentCmd->msDelay;\r\nreturn true;\r\n}\r\n(*stage)++;\r\n(*step) = 0;\r\ncontinue;\r\n}\r\nswitch (CurrentCmd->CmdID) {\r\ncase CmdID_SetTxPowerLevel:\r\nif (priv->card_8192_version == (u8)VERSION_819xU_A)\r\nrtl8192_SetTxPowerLevel(dev, channel);\r\nbreak;\r\ncase CmdID_WritePortUlong:\r\nwrite_nic_dword(dev, CurrentCmd->Para1,\r\nCurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUshort:\r\nwrite_nic_word(dev, CurrentCmd->Para1,\r\n(u16)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_WritePortUchar:\r\nwrite_nic_byte(dev, CurrentCmd->Para1,\r\n(u8)CurrentCmd->Para2);\r\nbreak;\r\ncase CmdID_RF_WriteReg:\r\nfor (eRFPath = 0; eRFPath < RF90_PATH_MAX; eRFPath++) {\r\nrtl8192_phy_SetRFReg(dev,\r\n(RF90_RADIO_PATH_E)eRFPath,\r\nCurrentCmd->Para1,\r\nbZebra1_ChannelNum,\r\nCurrentCmd->Para2);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n} while (true);\r\n(*delay) = CurrentCmd->msDelay;\r\n(*step)++;\r\nreturn false;\r\n}\r\nstatic void rtl8192_phy_FinishSwChnlNow(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 delay = 0;\r\nwhile (!rtl8192_phy_SwChnlStepByStep(dev, channel, &priv->SwChnlStage,\r\n&priv->SwChnlStep, &delay)) {\r\nif (!priv->up)\r\nbreak;\r\n}\r\n}\r\nvoid rtl8192_SwChnl_WorkItem(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_TRACE(COMP_CH, "==> SwChnlCallback819xUsbWorkItem(), chan:%d\n",\r\npriv->chan);\r\nrtl8192_phy_FinishSwChnlNow(dev, priv->chan);\r\nRT_TRACE(COMP_CH, "<== SwChnlCallback819xUsbWorkItem()\n");\r\n}\r\nu8 rtl8192_phy_SwChnl(struct net_device *dev, u8 channel)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_TRACE(COMP_CH, "%s(), SwChnlInProgress: %d\n", __func__,\r\npriv->SwChnlInProgress);\r\nif (!priv->up)\r\nreturn false;\r\nif (priv->SwChnlInProgress)\r\nreturn false;\r\nswitch (priv->ieee80211->mode) {\r\ncase WIRELESS_MODE_A:\r\ncase WIRELESS_MODE_N_5G:\r\nif (channel <= 14) {\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_A but channel<=14\n");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_B:\r\nif (channel > 14) {\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_B but channel>14\n");\r\nreturn false;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\ncase WIRELESS_MODE_N_24G:\r\nif (channel > 14) {\r\nRT_TRACE(COMP_ERR, "WIRELESS_MODE_G but channel>14\n");\r\nreturn false;\r\n}\r\nbreak;\r\n}\r\npriv->SwChnlInProgress = true;\r\nif (channel == 0)\r\nchannel = 1;\r\npriv->chan = channel;\r\npriv->SwChnlStage = 0;\r\npriv->SwChnlStep = 0;\r\nif (priv->up)\r\nrtl8192_SwChnl_WorkItem(dev);\r\npriv->SwChnlInProgress = false;\r\nreturn true;\r\n}\r\nvoid rtl8192_SetBWModeWorkItem(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 regBwOpMode;\r\nRT_TRACE(COMP_SWBW, "%s() Switch to %s bandwidth\n", __func__,\r\npriv->CurrentChannelBW == HT_CHANNEL_WIDTH_20?"20MHz":"40MHz");\r\nif (priv->rf_chip == RF_PSEUDO_11N) {\r\npriv->SetBWModeInProgress = false;\r\nreturn;\r\n}\r\nread_nic_byte(dev, BW_OPMODE, &regBwOpMode);\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nregBwOpMode |= BW_OPMODE_20MHZ;\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nregBwOpMode &= ~BW_OPMODE_20MHZ;\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR,\r\n"SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",\r\npriv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch (priv->CurrentChannelBW) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x0);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1,\r\n0x00100000, 1);\r\npriv->cck_present_attentuation =\r\npriv->cck_present_attentuation_20Mdefault +\r\npriv->cck_present_attentuation_difference;\r\nif (priv->cck_present_attentuation > 22)\r\npriv->cck_present_attentuation = 22;\r\nif (priv->cck_present_attentuation < 0)\r\npriv->cck_present_attentuation = 0;\r\nRT_TRACE(COMP_INIT,\r\n"20M, pHalData->CCKPresentAttentuation = %d\n",\r\npriv->cck_present_attentuation);\r\nif (priv->chan == 14 && !priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->chan != 14 && priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else {\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bRFMOD, 0x1);\r\nrtl8192_setBBreg(dev, rFPGA1_RFMOD, bRFMOD, 0x1);\r\nrtl8192_setBBreg(dev, rCCK0_System, bCCKSideBand,\r\npriv->nCur40MhzPrimeSC>>1);\r\nrtl8192_setBBreg(dev, rFPGA0_AnalogParameter1, 0x00100000, 0);\r\nrtl8192_setBBreg(dev, rOFDM1_LSTF, 0xC00,\r\npriv->nCur40MhzPrimeSC);\r\npriv->cck_present_attentuation =\r\npriv->cck_present_attentuation_40Mdefault +\r\npriv->cck_present_attentuation_difference;\r\nif (priv->cck_present_attentuation > 22)\r\npriv->cck_present_attentuation = 22;\r\nif (priv->cck_present_attentuation < 0)\r\npriv->cck_present_attentuation = 0;\r\nRT_TRACE(COMP_INIT,\r\n"40M, pHalData->CCKPresentAttentuation = %d\n",\r\npriv->cck_present_attentuation);\r\nif (priv->chan == 14 && !priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = true;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else if (priv->chan != 14 && priv->bcck_in_ch14) {\r\npriv->bcck_in_ch14 = false;\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n} else {\r\ndm_cck_txpower_adjust(dev, priv->bcck_in_ch14);\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR,\r\n"SetChannelBandwidth819xUsb(): unknown Bandwidth: %#X\n",\r\npriv->CurrentChannelBW);\r\nbreak;\r\n}\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\n#ifdef TO_DO_LIST\r\nPHY_SetRF8225Bandwidth(Adapter, pHalData->CurrentChannelBW);\r\n#endif\r\nbreak;\r\ncase RF_8256:\r\nPHY_SetRF8256Bandwidth(dev, priv->CurrentChannelBW);\r\nbreak;\r\ncase RF_8258:\r\nbreak;\r\ncase RF_PSEUDO_11N:\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown RFChipID: %d\n", priv->rf_chip);\r\nbreak;\r\n}\r\npriv->SetBWModeInProgress = false;\r\nRT_TRACE(COMP_SWBW, "<==SetBWMode819xUsb(), %d\n",\r\natomic_read(&priv->ieee80211->atm_swbw));\r\n}\r\nvoid rtl8192_SetBWMode(struct net_device *dev, HT_CHANNEL_WIDTH bandwidth,\r\nHT_EXTCHNL_OFFSET offset)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->SetBWModeInProgress)\r\nreturn;\r\npriv->SetBWModeInProgress = true;\r\npriv->CurrentChannelBW = bandwidth;\r\nif (offset == HT_EXTCHNL_OFFSET_LOWER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nelse if (offset == HT_EXTCHNL_OFFSET_UPPER)\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nelse\r\npriv->nCur40MhzPrimeSC = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nrtl8192_SetBWModeWorkItem(dev);\r\n}\r\nvoid InitialGain819xUsb(struct net_device *dev, u8 Operation)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->InitialGainOperateType = Operation;\r\nif (priv->up)\r\nqueue_delayed_work(priv->priv_wq, &priv->initialgain_operate_wq, 0);\r\n}\r\nvoid InitialGainOperateWorkItemCallBack(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = container_of(work, struct delayed_work,\r\nwork);\r\nstruct r8192_priv *priv = container_of(dwork, struct r8192_priv,\r\ninitialgain_operate_wq);\r\nstruct net_device *dev = priv->ieee80211->dev;\r\n#define SCAN_RX_INITIAL_GAIN 0x17\r\n#define POWER_DETECTION_TH 0x08\r\nu32 bitmask;\r\nu8 initial_gain;\r\nu8 Operation;\r\nOperation = priv->InitialGainOperateType;\r\nswitch (Operation) {\r\ncase IG_Backup:\r\nRT_TRACE(COMP_SCAN, "IG_Backup, backup the initial gain.\n");\r\ninitial_gain = SCAN_RX_INITIAL_GAIN;\r\nbitmask = bMaskByte0;\r\nif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\r\npriv->initgain_backup.xaagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XAAGCCore1, bitmask);\r\npriv->initgain_backup.xbagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XBAGCCore1, bitmask);\r\npriv->initgain_backup.xcagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XCAGCCore1, bitmask);\r\npriv->initgain_backup.xdagccore1 =\r\n(u8)rtl8192_QueryBBReg(dev, rOFDM0_XDAGCCore1, bitmask);\r\nbitmask = bMaskByte2;\r\npriv->initgain_backup.cca =\r\n(u8)rtl8192_QueryBBReg(dev, rCCK0_CCA, bitmask);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc50 is %x\n",\r\npriv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc58 is %x\n",\r\npriv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc60 is %x\n",\r\npriv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xc68 is %x\n",\r\npriv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan InitialGainBackup 0xa0a is %x\n",\r\npriv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Write scan initial gain = 0x%x\n",\r\ninitial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XAAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XBAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XCAGCCore1, initial_gain);\r\nwrite_nic_byte(dev, rOFDM0_XDAGCCore1, initial_gain);\r\nRT_TRACE(COMP_SCAN, "Write scan 0xa0a = 0x%x\n",\r\nPOWER_DETECTION_TH);\r\nwrite_nic_byte(dev, 0xa0a, POWER_DETECTION_TH);\r\nbreak;\r\ncase IG_Restore:\r\nRT_TRACE(COMP_SCAN, "IG_Restore, restore the initial gain.\n");\r\nbitmask = 0x7f;\r\nif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x8);\r\nrtl8192_setBBreg(dev, rOFDM0_XAAGCCore1, bitmask,\r\n(u32)priv->initgain_backup.xaagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XBAGCCore1, bitmask,\r\n(u32)priv->initgain_backup.xbagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XCAGCCore1, bitmask,\r\n(u32)priv->initgain_backup.xcagccore1);\r\nrtl8192_setBBreg(dev, rOFDM0_XDAGCCore1, bitmask,\r\n(u32)priv->initgain_backup.xdagccore1);\r\nbitmask = bMaskByte2;\r\nrtl8192_setBBreg(dev, rCCK0_CCA, bitmask,\r\n(u32)priv->initgain_backup.cca);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc50 is %x\n",\r\npriv->initgain_backup.xaagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc58 is %x\n",\r\npriv->initgain_backup.xbagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc60 is %x\n",\r\npriv->initgain_backup.xcagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xc68 is %x\n",\r\npriv->initgain_backup.xdagccore1);\r\nRT_TRACE(COMP_SCAN, "Scan BBInitialGainRestore 0xa0a is %x\n",\r\npriv->initgain_backup.cca);\r\nrtl8192_phy_setTxPower(dev, priv->ieee80211->current_network.channel);\r\nif (dm_digtable.dig_algorithm == DIG_ALGO_BY_FALSE_ALARM)\r\nrtl8192_setBBreg(dev, UFWP, bMaskByte1, 0x1);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_SCAN, "Unknown IG Operation.\n");\r\nbreak;\r\n}\r\n}
