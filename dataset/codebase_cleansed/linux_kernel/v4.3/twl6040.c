static unsigned int twl6040_read(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct twl6040 *twl6040 = codec->control_data;\r\nu8 value;\r\nif (reg >= TWL6040_CACHEREGNUM)\r\nreturn -EIO;\r\nswitch (reg) {\r\ncase TWL6040_REG_HSLCTL:\r\ncase TWL6040_REG_HSRCTL:\r\ncase TWL6040_REG_EARCTL:\r\ncase TWL6040_REG_HFLCTL:\r\ncase TWL6040_REG_HFRCTL:\r\nvalue = priv->dl12_cache[reg - TWL6040_REG_HSLCTL];\r\nbreak;\r\ndefault:\r\nvalue = twl6040_reg_read(twl6040, reg);\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic bool twl6040_can_write_to_chip(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (reg) {\r\ncase TWL6040_REG_HSLCTL:\r\ncase TWL6040_REG_HSRCTL:\r\ncase TWL6040_REG_EARCTL:\r\nreturn priv->dl1_unmuted;\r\ncase TWL6040_REG_HFLCTL:\r\ncase TWL6040_REG_HFRCTL:\r\nreturn priv->dl2_unmuted;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic inline void twl6040_update_dl12_cache(struct snd_soc_codec *codec,\r\nu8 reg, u8 value)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (reg) {\r\ncase TWL6040_REG_HSLCTL:\r\ncase TWL6040_REG_HSRCTL:\r\ncase TWL6040_REG_EARCTL:\r\ncase TWL6040_REG_HFLCTL:\r\ncase TWL6040_REG_HFRCTL:\r\npriv->dl12_cache[reg - TWL6040_REG_HSLCTL] = value;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int twl6040_write(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct twl6040 *twl6040 = codec->control_data;\r\nif (reg >= TWL6040_CACHEREGNUM)\r\nreturn -EIO;\r\ntwl6040_update_dl12_cache(codec, reg, value);\r\nif (twl6040_can_write_to_chip(codec, reg))\r\nreturn twl6040_reg_write(twl6040, reg, value);\r\nelse\r\nreturn 0;\r\n}\r\nstatic void twl6040_init_chip(struct snd_soc_codec *codec)\r\n{\r\ntwl6040_read(codec, TWL6040_REG_TRIM1);\r\ntwl6040_read(codec, TWL6040_REG_TRIM2);\r\ntwl6040_read(codec, TWL6040_REG_TRIM3);\r\ntwl6040_read(codec, TWL6040_REG_HSOTRIM);\r\ntwl6040_read(codec, TWL6040_REG_HFOTRIM);\r\ntwl6040_write(codec, TWL6040_REG_MICLCTL, 0x18);\r\ntwl6040_write(codec, TWL6040_REG_MICRCTL, 0x18);\r\ntwl6040_write(codec, TWL6040_REG_HSGAIN, 0xff);\r\ntwl6040_write(codec, TWL6040_REG_EARCTL, 0x1e);\r\ntwl6040_write(codec, TWL6040_REG_HFLGAIN, 0x1d);\r\ntwl6040_write(codec, TWL6040_REG_HFRGAIN, 0x1d);\r\ntwl6040_write(codec, TWL6040_REG_LINEGAIN, 0);\r\n}\r\nstatic int headset_power_mode(struct snd_soc_codec *codec, int high_perf)\r\n{\r\nint hslctl, hsrctl;\r\nint mask = TWL6040_HSDRVMODE | TWL6040_HSDACMODE;\r\nhslctl = twl6040_read(codec, TWL6040_REG_HSLCTL);\r\nhsrctl = twl6040_read(codec, TWL6040_REG_HSRCTL);\r\nif (high_perf) {\r\nhslctl &= ~mask;\r\nhsrctl &= ~mask;\r\n} else {\r\nhslctl |= mask;\r\nhsrctl |= mask;\r\n}\r\ntwl6040_write(codec, TWL6040_REG_HSLCTL, hslctl);\r\ntwl6040_write(codec, TWL6040_REG_HSRCTL, hsrctl);\r\nreturn 0;\r\n}\r\nstatic int twl6040_hs_dac_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nu8 hslctl, hsrctl;\r\nhslctl = twl6040_read(codec, TWL6040_REG_HSLCTL);\r\nhsrctl = twl6040_read(codec, TWL6040_REG_HSRCTL);\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nhslctl |= TWL6040_HSDACENA;\r\nhsrctl |= TWL6040_HSDACENA;\r\n} else {\r\nhslctl &= ~TWL6040_HSDACENA;\r\nhsrctl &= ~TWL6040_HSDACENA;\r\n}\r\ntwl6040_write(codec, TWL6040_REG_HSLCTL, hslctl);\r\ntwl6040_write(codec, TWL6040_REG_HSRCTL, hsrctl);\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int twl6040_ep_drv_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\npriv->hs_power_mode_locked = 1;\r\nret = headset_power_mode(codec, 1);\r\n} else {\r\npriv->hs_power_mode_locked = 0;\r\nret = headset_power_mode(codec, priv->hs_power_mode);\r\n}\r\nmsleep(1);\r\nreturn ret;\r\n}\r\nstatic void twl6040_hs_jack_report(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack, int report)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint status;\r\nmutex_lock(&priv->mutex);\r\nstatus = twl6040_read(codec, TWL6040_REG_STATUS);\r\nif (status & TWL6040_PLUGCOMP)\r\nsnd_soc_jack_report(jack, report, report);\r\nelse\r\nsnd_soc_jack_report(jack, 0, report);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nvoid twl6040_hs_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack, int report)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct twl6040_jack_data *hs_jack = &priv->hs_jack;\r\nhs_jack->jack = jack;\r\nhs_jack->report = report;\r\ntwl6040_hs_jack_report(codec, hs_jack->jack, hs_jack->report);\r\n}\r\nstatic void twl6040_accessory_work(struct work_struct *work)\r\n{\r\nstruct twl6040_data *priv = container_of(work,\r\nstruct twl6040_data, hs_jack.work.work);\r\nstruct snd_soc_codec *codec = priv->codec;\r\nstruct twl6040_jack_data *hs_jack = &priv->hs_jack;\r\ntwl6040_hs_jack_report(codec, hs_jack->jack, hs_jack->report);\r\n}\r\nstatic irqreturn_t twl6040_audio_handler(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&priv->hs_jack.work, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl6040_soc_dapm_put_vibra_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int val;\r\nval = twl6040_read(codec, e->reg);\r\nif (val & TWL6040_VIBENA && !(val & TWL6040_VIBSEL))\r\nreturn -EBUSY;\r\nreturn snd_soc_dapm_put_enum_double(kcontrol, ucontrol);\r\n}\r\nstatic int twl6040_headset_power_get_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = priv->hs_power_mode;\r\nreturn 0;\r\n}\r\nstatic int twl6040_headset_power_put_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint high_perf = ucontrol->value.enumerated.item[0];\r\nint ret = 0;\r\nif (!priv->hs_power_mode_locked)\r\nret = headset_power_mode(codec, high_perf);\r\nif (!ret)\r\npriv->hs_power_mode = high_perf;\r\nreturn ret;\r\n}\r\nstatic int twl6040_pll_get_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = priv->pll_power_mode;\r\nreturn 0;\r\n}\r\nstatic int twl6040_pll_put_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\npriv->pll_power_mode = ucontrol->value.enumerated.item[0];\r\nreturn 0;\r\n}\r\nint twl6040_get_dl1_gain(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nif (snd_soc_dapm_get_pin_status(dapm, "EP"))\r\nreturn -1;\r\nif (snd_soc_dapm_get_pin_status(dapm, "HSOR") ||\r\nsnd_soc_dapm_get_pin_status(dapm, "HSOL")) {\r\nu8 val = snd_soc_read(codec, TWL6040_REG_HSLCTL);\r\nif (val & TWL6040_HSDACMODE)\r\nreturn -8;\r\nelse\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint twl6040_get_clk_id(struct snd_soc_codec *codec)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nreturn priv->pll_power_mode;\r\n}\r\nint twl6040_get_trim_value(struct snd_soc_codec *codec, enum twl6040_trim trim)\r\n{\r\nif (unlikely(trim >= TWL6040_TRIM_INVAL))\r\nreturn -EINVAL;\r\nreturn twl6040_read(codec, TWL6040_REG_TRIM1 + trim);\r\n}\r\nint twl6040_get_hs_step_size(struct snd_soc_codec *codec)\r\n{\r\nstruct twl6040 *twl6040 = codec->control_data;\r\nif (twl6040_get_revid(twl6040) < TWL6040_REV_ES1_3)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int twl6040_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct twl6040 *twl6040 = codec->control_data;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (priv->codec_powered)\r\nbreak;\r\nret = twl6040_power(twl6040, 1);\r\nif (ret)\r\nreturn ret;\r\npriv->codec_powered = 1;\r\ntwl6040_write(codec, TWL6040_REG_GPOCTL, 0x02);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (!priv->codec_powered)\r\nbreak;\r\ntwl6040_power(twl6040, 0);\r\npriv->codec_powered = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl6040_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nsnd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&sysclk_constraints[priv->pll_power_mode]);\r\nreturn 0;\r\n}\r\nstatic int twl6040_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint rate;\r\nrate = params_rate(params);\r\nswitch (rate) {\r\ncase 11250:\r\ncase 22500:\r\ncase 44100:\r\ncase 88200:\r\nif (unlikely(priv->pll == TWL6040_SYSCLK_SEL_HPPLL)) {\r\ndev_err(codec->dev, "HPPLL does not support rate %d\n",\r\nrate);\r\nreturn -EINVAL;\r\n}\r\npriv->sysclk = 17640000;\r\nbreak;\r\ncase 8000:\r\ncase 16000:\r\ncase 32000:\r\ncase 48000:\r\ncase 96000:\r\npriv->sysclk = 19200000;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported rate %d\n", rate);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl6040_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct twl6040 *twl6040 = codec->control_data;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nif (!priv->sysclk) {\r\ndev_err(codec->dev,\r\n"no mclk configured, call set_sysclk() on init\n");\r\nreturn -EINVAL;\r\n}\r\nret = twl6040_set_pll(twl6040, priv->pll, priv->clk_in, priv->sysclk);\r\nif (ret) {\r\ndev_err(codec->dev, "Can not set PLL (%d)\n", ret);\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl6040_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase TWL6040_SYSCLK_SEL_LPPLL:\r\ncase TWL6040_SYSCLK_SEL_HPPLL:\r\npriv->pll = clk_id;\r\npriv->clk_in = freq;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unknown clk_id %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void twl6040_mute_path(struct snd_soc_codec *codec, enum twl6040_dai_id id,\r\nint mute)\r\n{\r\nstruct twl6040 *twl6040 = codec->control_data;\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nint hslctl, hsrctl, earctl;\r\nint hflctl, hfrctl;\r\nswitch (id) {\r\ncase TWL6040_DAI_DL1:\r\nhslctl = twl6040_read(codec, TWL6040_REG_HSLCTL);\r\nhsrctl = twl6040_read(codec, TWL6040_REG_HSRCTL);\r\nearctl = twl6040_read(codec, TWL6040_REG_EARCTL);\r\nif (mute) {\r\nearctl &= ~0x01;\r\nhslctl &= ~(TWL6040_HSDRVENA | TWL6040_HSDACENA);\r\nhsrctl &= ~(TWL6040_HSDRVENA | TWL6040_HSDACENA);\r\n}\r\ntwl6040_reg_write(twl6040, TWL6040_REG_EARCTL, earctl);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_HSLCTL, hslctl);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_HSRCTL, hsrctl);\r\npriv->dl1_unmuted = !mute;\r\nbreak;\r\ncase TWL6040_DAI_DL2:\r\nhflctl = twl6040_read(codec, TWL6040_REG_HFLCTL);\r\nhfrctl = twl6040_read(codec, TWL6040_REG_HFRCTL);\r\nif (mute) {\r\nhflctl &= ~(TWL6040_HFDACENA | TWL6040_HFPGAENA |\r\nTWL6040_HFDRVENA);\r\nhfrctl &= ~(TWL6040_HFDACENA | TWL6040_HFPGAENA |\r\nTWL6040_HFDRVENA);\r\n}\r\ntwl6040_reg_write(twl6040, TWL6040_REG_HFLCTL, hflctl);\r\ntwl6040_reg_write(twl6040, TWL6040_REG_HFRCTL, hfrctl);\r\npriv->dl2_unmuted = !mute;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int twl6040_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nswitch (dai->id) {\r\ncase TWL6040_DAI_LEGACY:\r\ntwl6040_mute_path(dai->codec, TWL6040_DAI_DL1, mute);\r\ntwl6040_mute_path(dai->codec, TWL6040_DAI_DL2, mute);\r\nbreak;\r\ncase TWL6040_DAI_DL1:\r\ncase TWL6040_DAI_DL2:\r\ntwl6040_mute_path(dai->codec, dai->id, mute);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int twl6040_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct twl6040_data *priv;\r\nstruct twl6040 *twl6040 = dev_get_drvdata(codec->dev->parent);\r\nstruct platform_device *pdev = container_of(codec->dev,\r\nstruct platform_device, dev);\r\nint ret = 0;\r\npriv = devm_kzalloc(codec->dev, sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\nsnd_soc_codec_set_drvdata(codec, priv);\r\npriv->codec = codec;\r\ncodec->control_data = twl6040;\r\npriv->plug_irq = platform_get_irq(pdev, 0);\r\nif (priv->plug_irq < 0) {\r\ndev_err(codec->dev, "invalid irq\n");\r\nreturn -EINVAL;\r\n}\r\nINIT_DELAYED_WORK(&priv->hs_jack.work, twl6040_accessory_work);\r\nmutex_init(&priv->mutex);\r\nret = request_threaded_irq(priv->plug_irq, NULL,\r\ntwl6040_audio_handler,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\n"twl6040_irq_plug", codec);\r\nif (ret) {\r\ndev_err(codec->dev, "PLUG IRQ request failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_codec_force_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\ntwl6040_init_chip(codec);\r\nreturn 0;\r\n}\r\nstatic int twl6040_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct twl6040_data *priv = snd_soc_codec_get_drvdata(codec);\r\nfree_irq(priv->plug_irq, codec);\r\nreturn 0;\r\n}\r\nstatic int twl6040_codec_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_twl6040,\r\ntwl6040_dai, ARRAY_SIZE(twl6040_dai));\r\n}\r\nstatic int twl6040_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
