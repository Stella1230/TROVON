acpi_status\r\nacpi_ut_create_list(char *list_name,\r\nu16 object_size, struct acpi_memory_list **return_cache)\r\n{\r\nstruct acpi_memory_list *cache;\r\ncache = acpi_os_allocate(sizeof(struct acpi_memory_list));\r\nif (!cache) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nmemset(cache, 0, sizeof(struct acpi_memory_list));\r\ncache->list_name = list_name;\r\ncache->object_size = object_size;\r\n*return_cache = cache;\r\nreturn (AE_OK);\r\n}\r\nvoid *acpi_ut_allocate_and_track(acpi_size size,\r\nu32 component, const char *module, u32 line)\r\n{\r\nstruct acpi_debug_mem_block *allocation;\r\nacpi_status status;\r\nif (!size) {\r\nACPI_WARNING((module, line,\r\n"Attempt to allocate zero bytes, allocating 1 byte"));\r\nsize = 1;\r\n}\r\nallocation =\r\nacpi_os_allocate(size + sizeof(struct acpi_debug_mem_header));\r\nif (!allocation) {\r\nACPI_WARNING((module, line,\r\n"Could not allocate size %u", (u32)size));\r\nreturn (NULL);\r\n}\r\nstatus = acpi_ut_track_allocation(allocation, size,\r\nACPI_MEM_MALLOC, component, module,\r\nline);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_free(allocation);\r\nreturn (NULL);\r\n}\r\nacpi_gbl_global_list->total_allocated++;\r\nacpi_gbl_global_list->total_size += (u32)size;\r\nacpi_gbl_global_list->current_total_size += (u32)size;\r\nif (acpi_gbl_global_list->current_total_size >\r\nacpi_gbl_global_list->max_occupied) {\r\nacpi_gbl_global_list->max_occupied =\r\nacpi_gbl_global_list->current_total_size;\r\n}\r\nreturn ((void *)&allocation->user_space);\r\n}\r\nvoid *acpi_ut_allocate_zeroed_and_track(acpi_size size,\r\nu32 component,\r\nconst char *module, u32 line)\r\n{\r\nstruct acpi_debug_mem_block *allocation;\r\nacpi_status status;\r\nif (!size) {\r\nACPI_WARNING((module, line,\r\n"Attempt to allocate zero bytes, allocating 1 byte"));\r\nsize = 1;\r\n}\r\nallocation =\r\nacpi_os_allocate_zeroed(size +\r\nsizeof(struct acpi_debug_mem_header));\r\nif (!allocation) {\r\nACPI_ERROR((module, line,\r\n"Could not allocate size %u", (u32)size));\r\nreturn (NULL);\r\n}\r\nstatus = acpi_ut_track_allocation(allocation, size,\r\nACPI_MEM_CALLOC, component, module,\r\nline);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_free(allocation);\r\nreturn (NULL);\r\n}\r\nacpi_gbl_global_list->total_allocated++;\r\nacpi_gbl_global_list->total_size += (u32)size;\r\nacpi_gbl_global_list->current_total_size += (u32)size;\r\nif (acpi_gbl_global_list->current_total_size >\r\nacpi_gbl_global_list->max_occupied) {\r\nacpi_gbl_global_list->max_occupied =\r\nacpi_gbl_global_list->current_total_size;\r\n}\r\nreturn ((void *)&allocation->user_space);\r\n}\r\nvoid\r\nacpi_ut_free_and_track(void *allocation,\r\nu32 component, const char *module, u32 line)\r\n{\r\nstruct acpi_debug_mem_block *debug_block;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE_PTR(ut_free, allocation);\r\nif (NULL == allocation) {\r\nACPI_ERROR((module, line, "Attempt to delete a NULL address"));\r\nreturn_VOID;\r\n}\r\ndebug_block = ACPI_CAST_PTR(struct acpi_debug_mem_block,\r\n(((char *)allocation) -\r\nsizeof(struct acpi_debug_mem_header)));\r\nacpi_gbl_global_list->total_freed++;\r\nacpi_gbl_global_list->current_total_size -= debug_block->size;\r\nstatus = acpi_ut_remove_allocation(debug_block,\r\ncomponent, module, line);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Could not free memory"));\r\n}\r\nacpi_os_free(debug_block);\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "%p freed (block %p)\n",\r\nallocation, debug_block));\r\nreturn_VOID;\r\n}\r\nstatic struct acpi_debug_mem_block *acpi_ut_find_allocation(struct\r\nacpi_debug_mem_block\r\n*allocation)\r\n{\r\nstruct acpi_debug_mem_block *element;\r\nelement = acpi_gbl_global_list->list_head;\r\nif (!element) {\r\nreturn (NULL);\r\n}\r\nwhile (element > allocation) {\r\nif (!element->next) {\r\nreturn (element);\r\n}\r\nelement = element->next;\r\n}\r\nif (element == allocation) {\r\nreturn (element);\r\n}\r\nreturn (element->previous);\r\n}\r\nstatic acpi_status\r\nacpi_ut_track_allocation(struct acpi_debug_mem_block *allocation,\r\nacpi_size size,\r\nu8 alloc_type,\r\nu32 component, const char *module, u32 line)\r\n{\r\nstruct acpi_memory_list *mem_list;\r\nstruct acpi_debug_mem_block *element;\r\nacpi_status status = AE_OK;\r\nACPI_FUNCTION_TRACE_PTR(ut_track_allocation, allocation);\r\nif (acpi_gbl_disable_mem_tracking) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nmem_list = acpi_gbl_global_list;\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nelement = acpi_ut_find_allocation(allocation);\r\nif (element == allocation) {\r\nACPI_ERROR((AE_INFO,\r\n"UtTrackAllocation: Allocation (%p) already present in global list!",\r\nallocation));\r\ngoto unlock_and_exit;\r\n}\r\nallocation->size = (u32)size;\r\nallocation->alloc_type = alloc_type;\r\nallocation->component = component;\r\nallocation->line = line;\r\nstrncpy(allocation->module, module, ACPI_MAX_MODULE_NAME);\r\nallocation->module[ACPI_MAX_MODULE_NAME - 1] = 0;\r\nif (!element) {\r\nif (mem_list->list_head) {\r\n((struct acpi_debug_mem_block *)(mem_list->list_head))->\r\nprevious = allocation;\r\n}\r\nallocation->next = mem_list->list_head;\r\nallocation->previous = NULL;\r\nmem_list->list_head = allocation;\r\n} else {\r\nallocation->next = element->next;\r\nallocation->previous = element;\r\nif (element->next) {\r\n(element->next)->previous = allocation;\r\n}\r\nelement->next = allocation;\r\n}\r\nunlock_and_exit:\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_MEMORY);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ut_remove_allocation(struct acpi_debug_mem_block *allocation,\r\nu32 component, const char *module, u32 line)\r\n{\r\nstruct acpi_memory_list *mem_list;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(ut_remove_allocation);\r\nif (acpi_gbl_disable_mem_tracking) {\r\nreturn (AE_OK);\r\n}\r\nmem_list = acpi_gbl_global_list;\r\nif (NULL == mem_list->list_head) {\r\nACPI_ERROR((module, line,\r\n"Empty allocation list, nothing to free!"));\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_MEMORY);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\nif (allocation->previous) {\r\n(allocation->previous)->next = allocation->next;\r\n} else {\r\nmem_list->list_head = allocation->next;\r\n}\r\nif (allocation->next) {\r\n(allocation->next)->previous = allocation->previous;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Freeing %p, size 0%X\n",\r\n&allocation->user_space, allocation->size));\r\nmemset(&allocation->user_space, 0xEA, allocation->size);\r\nstatus = acpi_ut_release_mutex(ACPI_MTX_MEMORY);\r\nreturn (status);\r\n}\r\nvoid acpi_ut_dump_allocation_info(void)\r\n{\r\nACPI_FUNCTION_TRACE(ut_dump_allocation_info);\r\nreturn_VOID;\r\n}\r\nvoid acpi_ut_dump_allocations(u32 component, const char *module)\r\n{\r\nstruct acpi_debug_mem_block *element;\r\nunion acpi_descriptor *descriptor;\r\nu32 num_outstanding = 0;\r\nu8 descriptor_type;\r\nACPI_FUNCTION_TRACE(ut_dump_allocations);\r\nif (acpi_gbl_disable_mem_tracking) {\r\nreturn_VOID;\r\n}\r\nif (ACPI_FAILURE(acpi_ut_acquire_mutex(ACPI_MTX_MEMORY))) {\r\nreturn_VOID;\r\n}\r\nelement = acpi_gbl_global_list->list_head;\r\nwhile (element) {\r\nif ((element->component & component) &&\r\n((module == NULL)\r\n|| (0 == strcmp(module, element->module)))) {\r\ndescriptor =\r\nACPI_CAST_PTR(union acpi_descriptor,\r\n&element->user_space);\r\nif (element->size <\r\nsizeof(struct acpi_common_descriptor)) {\r\nacpi_os_printf("%p Length 0x%04X %9.9s-%u "\r\n"[Not a Descriptor - too small]\n",\r\ndescriptor, element->size,\r\nelement->module, element->line);\r\n} else {\r\nif (ACPI_GET_DESCRIPTOR_TYPE(descriptor) !=\r\nACPI_DESC_TYPE_CACHED) {\r\nacpi_os_printf\r\n("%p Length 0x%04X %9.9s-%u [%s] ",\r\ndescriptor, element->size,\r\nelement->module, element->line,\r\nacpi_ut_get_descriptor_name\r\n(descriptor));\r\ndescriptor_type = 0;\r\nswitch (ACPI_GET_DESCRIPTOR_TYPE\r\n(descriptor)) {\r\ncase ACPI_DESC_TYPE_OPERAND:\r\nif (element->size ==\r\nsizeof(union\r\nacpi_operand_object))\r\n{\r\ndescriptor_type =\r\nACPI_DESC_TYPE_OPERAND;\r\n}\r\nbreak;\r\ncase ACPI_DESC_TYPE_PARSER:\r\nif (element->size ==\r\nsizeof(union\r\nacpi_parse_object)) {\r\ndescriptor_type =\r\nACPI_DESC_TYPE_PARSER;\r\n}\r\nbreak;\r\ncase ACPI_DESC_TYPE_NAMED:\r\nif (element->size ==\r\nsizeof(struct\r\nacpi_namespace_node))\r\n{\r\ndescriptor_type =\r\nACPI_DESC_TYPE_NAMED;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (descriptor_type) {\r\ncase ACPI_DESC_TYPE_OPERAND:\r\nacpi_os_printf\r\n("%12.12s RefCount 0x%04X\n",\r\nacpi_ut_get_type_name\r\n(descriptor->object.common.\r\ntype),\r\ndescriptor->object.common.\r\nreference_count);\r\nbreak;\r\ncase ACPI_DESC_TYPE_PARSER:\r\nacpi_os_printf\r\n("AmlOpcode 0x%04hX\n",\r\ndescriptor->op.asl.\r\naml_opcode);\r\nbreak;\r\ncase ACPI_DESC_TYPE_NAMED:\r\nacpi_os_printf("%4.4s\n",\r\nacpi_ut_get_node_name\r\n(&descriptor->\r\nnode));\r\nbreak;\r\ndefault:\r\nacpi_os_printf("\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nnum_outstanding++;\r\n}\r\nelement = element->next;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_MEMORY);\r\nif (!num_outstanding) {\r\nACPI_INFO((AE_INFO, "No outstanding allocations"));\r\n} else {\r\nACPI_ERROR((AE_INFO, "%u(0x%X) Outstanding allocations",\r\nnum_outstanding, num_outstanding));\r\n}\r\nreturn_VOID;\r\n}
