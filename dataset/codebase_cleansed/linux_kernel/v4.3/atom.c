static void debug_print_spaces(int n)\r\n{\r\nwhile (n--)\r\nprintk(" ");\r\n}\r\nstatic uint32_t atom_iio_execute(struct atom_context *ctx, int base,\r\nuint32_t index, uint32_t data)\r\n{\r\nuint32_t temp = 0xCDCDCDCD;\r\nwhile (1)\r\nswitch (CU8(base)) {\r\ncase ATOM_IIO_NOP:\r\nbase++;\r\nbreak;\r\ncase ATOM_IIO_READ:\r\ntemp = ctx->card->ioreg_read(ctx->card, CU16(base + 1));\r\nbase += 3;\r\nbreak;\r\ncase ATOM_IIO_WRITE:\r\nctx->card->ioreg_write(ctx->card, CU16(base + 1), temp);\r\nbase += 3;\r\nbreak;\r\ncase ATOM_IIO_CLEAR:\r\ntemp &=\r\n~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\r\nCU8(base + 2));\r\nbase += 3;\r\nbreak;\r\ncase ATOM_IIO_SET:\r\ntemp |=\r\n(0xFFFFFFFF >> (32 - CU8(base + 1))) << CU8(base +\r\n2);\r\nbase += 3;\r\nbreak;\r\ncase ATOM_IIO_MOVE_INDEX:\r\ntemp &=\r\n~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\r\nCU8(base + 3));\r\ntemp |=\r\n((index >> CU8(base + 2)) &\r\n(0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +\r\n3);\r\nbase += 4;\r\nbreak;\r\ncase ATOM_IIO_MOVE_DATA:\r\ntemp &=\r\n~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\r\nCU8(base + 3));\r\ntemp |=\r\n((data >> CU8(base + 2)) &\r\n(0xFFFFFFFF >> (32 - CU8(base + 1)))) << CU8(base +\r\n3);\r\nbase += 4;\r\nbreak;\r\ncase ATOM_IIO_MOVE_ATTR:\r\ntemp &=\r\n~((0xFFFFFFFF >> (32 - CU8(base + 1))) <<\r\nCU8(base + 3));\r\ntemp |=\r\n((ctx->\r\nio_attr >> CU8(base + 2)) & (0xFFFFFFFF >> (32 -\r\nCU8\r\n(base\r\n+\r\n1))))\r\n<< CU8(base + 3);\r\nbase += 4;\r\nbreak;\r\ncase ATOM_IIO_END:\r\nreturn temp;\r\ndefault:\r\nprintk(KERN_INFO "Unknown IIO opcode.\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic uint32_t atom_get_src_int(atom_exec_context *ctx, uint8_t attr,\r\nint *ptr, uint32_t *saved, int print)\r\n{\r\nuint32_t idx, val = 0xCDCDCDCD, align, arg;\r\nstruct atom_context *gctx = ctx->ctx;\r\narg = attr & 7;\r\nalign = (attr >> 3) & 7;\r\nswitch (arg) {\r\ncase ATOM_ARG_REG:\r\nidx = U16(*ptr);\r\n(*ptr) += 2;\r\nif (print)\r\nDEBUG("REG[0x%04X]", idx);\r\nidx += gctx->reg_block;\r\nswitch (gctx->io_mode) {\r\ncase ATOM_IO_MM:\r\nval = gctx->card->reg_read(gctx->card, idx);\r\nbreak;\r\ncase ATOM_IO_PCI:\r\nprintk(KERN_INFO\r\n"PCI registers are not implemented.\n");\r\nreturn 0;\r\ncase ATOM_IO_SYSIO:\r\nprintk(KERN_INFO\r\n"SYSIO registers are not implemented.\n");\r\nreturn 0;\r\ndefault:\r\nif (!(gctx->io_mode & 0x80)) {\r\nprintk(KERN_INFO "Bad IO mode.\n");\r\nreturn 0;\r\n}\r\nif (!gctx->iio[gctx->io_mode & 0x7F]) {\r\nprintk(KERN_INFO\r\n"Undefined indirect IO read method %d.\n",\r\ngctx->io_mode & 0x7F);\r\nreturn 0;\r\n}\r\nval =\r\natom_iio_execute(gctx,\r\ngctx->iio[gctx->io_mode & 0x7F],\r\nidx, 0);\r\n}\r\nbreak;\r\ncase ATOM_ARG_PS:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nval = get_unaligned_le32((u32 *)&ctx->ps[idx]);\r\nif (print)\r\nDEBUG("PS[0x%02X,0x%04X]", idx, val);\r\nbreak;\r\ncase ATOM_ARG_WS:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nif (print)\r\nDEBUG("WS[0x%02X]", idx);\r\nswitch (idx) {\r\ncase ATOM_WS_QUOTIENT:\r\nval = gctx->divmul[0];\r\nbreak;\r\ncase ATOM_WS_REMAINDER:\r\nval = gctx->divmul[1];\r\nbreak;\r\ncase ATOM_WS_DATAPTR:\r\nval = gctx->data_block;\r\nbreak;\r\ncase ATOM_WS_SHIFT:\r\nval = gctx->shift;\r\nbreak;\r\ncase ATOM_WS_OR_MASK:\r\nval = 1 << gctx->shift;\r\nbreak;\r\ncase ATOM_WS_AND_MASK:\r\nval = ~(1 << gctx->shift);\r\nbreak;\r\ncase ATOM_WS_FB_WINDOW:\r\nval = gctx->fb_base;\r\nbreak;\r\ncase ATOM_WS_ATTRIBUTES:\r\nval = gctx->io_attr;\r\nbreak;\r\ncase ATOM_WS_REGPTR:\r\nval = gctx->reg_block;\r\nbreak;\r\ndefault:\r\nval = ctx->ws[idx];\r\n}\r\nbreak;\r\ncase ATOM_ARG_ID:\r\nidx = U16(*ptr);\r\n(*ptr) += 2;\r\nif (print) {\r\nif (gctx->data_block)\r\nDEBUG("ID[0x%04X+%04X]", idx, gctx->data_block);\r\nelse\r\nDEBUG("ID[0x%04X]", idx);\r\n}\r\nval = U32(idx + gctx->data_block);\r\nbreak;\r\ncase ATOM_ARG_FB:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nif ((gctx->fb_base + (idx * 4)) > gctx->scratch_size_bytes) {\r\nDRM_ERROR("ATOM: fb read beyond scratch region: %d vs. %d\n",\r\ngctx->fb_base + (idx * 4), gctx->scratch_size_bytes);\r\nval = 0;\r\n} else\r\nval = gctx->scratch[(gctx->fb_base / 4) + idx];\r\nif (print)\r\nDEBUG("FB[0x%02X]", idx);\r\nbreak;\r\ncase ATOM_ARG_IMM:\r\nswitch (align) {\r\ncase ATOM_SRC_DWORD:\r\nval = U32(*ptr);\r\n(*ptr) += 4;\r\nif (print)\r\nDEBUG("IMM 0x%08X\n", val);\r\nreturn val;\r\ncase ATOM_SRC_WORD0:\r\ncase ATOM_SRC_WORD8:\r\ncase ATOM_SRC_WORD16:\r\nval = U16(*ptr);\r\n(*ptr) += 2;\r\nif (print)\r\nDEBUG("IMM 0x%04X\n", val);\r\nreturn val;\r\ncase ATOM_SRC_BYTE0:\r\ncase ATOM_SRC_BYTE8:\r\ncase ATOM_SRC_BYTE16:\r\ncase ATOM_SRC_BYTE24:\r\nval = U8(*ptr);\r\n(*ptr)++;\r\nif (print)\r\nDEBUG("IMM 0x%02X\n", val);\r\nreturn val;\r\n}\r\nreturn 0;\r\ncase ATOM_ARG_PLL:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nif (print)\r\nDEBUG("PLL[0x%02X]", idx);\r\nval = gctx->card->pll_read(gctx->card, idx);\r\nbreak;\r\ncase ATOM_ARG_MC:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nif (print)\r\nDEBUG("MC[0x%02X]", idx);\r\nval = gctx->card->mc_read(gctx->card, idx);\r\nbreak;\r\n}\r\nif (saved)\r\n*saved = val;\r\nval &= atom_arg_mask[align];\r\nval >>= atom_arg_shift[align];\r\nif (print)\r\nswitch (align) {\r\ncase ATOM_SRC_DWORD:\r\nDEBUG(".[31:0] -> 0x%08X\n", val);\r\nbreak;\r\ncase ATOM_SRC_WORD0:\r\nDEBUG(".[15:0] -> 0x%04X\n", val);\r\nbreak;\r\ncase ATOM_SRC_WORD8:\r\nDEBUG(".[23:8] -> 0x%04X\n", val);\r\nbreak;\r\ncase ATOM_SRC_WORD16:\r\nDEBUG(".[31:16] -> 0x%04X\n", val);\r\nbreak;\r\ncase ATOM_SRC_BYTE0:\r\nDEBUG(".[7:0] -> 0x%02X\n", val);\r\nbreak;\r\ncase ATOM_SRC_BYTE8:\r\nDEBUG(".[15:8] -> 0x%02X\n", val);\r\nbreak;\r\ncase ATOM_SRC_BYTE16:\r\nDEBUG(".[23:16] -> 0x%02X\n", val);\r\nbreak;\r\ncase ATOM_SRC_BYTE24:\r\nDEBUG(".[31:24] -> 0x%02X\n", val);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic void atom_skip_src_int(atom_exec_context *ctx, uint8_t attr, int *ptr)\r\n{\r\nuint32_t align = (attr >> 3) & 7, arg = attr & 7;\r\nswitch (arg) {\r\ncase ATOM_ARG_REG:\r\ncase ATOM_ARG_ID:\r\n(*ptr) += 2;\r\nbreak;\r\ncase ATOM_ARG_PLL:\r\ncase ATOM_ARG_MC:\r\ncase ATOM_ARG_PS:\r\ncase ATOM_ARG_WS:\r\ncase ATOM_ARG_FB:\r\n(*ptr)++;\r\nbreak;\r\ncase ATOM_ARG_IMM:\r\nswitch (align) {\r\ncase ATOM_SRC_DWORD:\r\n(*ptr) += 4;\r\nreturn;\r\ncase ATOM_SRC_WORD0:\r\ncase ATOM_SRC_WORD8:\r\ncase ATOM_SRC_WORD16:\r\n(*ptr) += 2;\r\nreturn;\r\ncase ATOM_SRC_BYTE0:\r\ncase ATOM_SRC_BYTE8:\r\ncase ATOM_SRC_BYTE16:\r\ncase ATOM_SRC_BYTE24:\r\n(*ptr)++;\r\nreturn;\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic uint32_t atom_get_src(atom_exec_context *ctx, uint8_t attr, int *ptr)\r\n{\r\nreturn atom_get_src_int(ctx, attr, ptr, NULL, 1);\r\n}\r\nstatic uint32_t atom_get_src_direct(atom_exec_context *ctx, uint8_t align, int *ptr)\r\n{\r\nuint32_t val = 0xCDCDCDCD;\r\nswitch (align) {\r\ncase ATOM_SRC_DWORD:\r\nval = U32(*ptr);\r\n(*ptr) += 4;\r\nbreak;\r\ncase ATOM_SRC_WORD0:\r\ncase ATOM_SRC_WORD8:\r\ncase ATOM_SRC_WORD16:\r\nval = U16(*ptr);\r\n(*ptr) += 2;\r\nbreak;\r\ncase ATOM_SRC_BYTE0:\r\ncase ATOM_SRC_BYTE8:\r\ncase ATOM_SRC_BYTE16:\r\ncase ATOM_SRC_BYTE24:\r\nval = U8(*ptr);\r\n(*ptr)++;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nstatic uint32_t atom_get_dst(atom_exec_context *ctx, int arg, uint8_t attr,\r\nint *ptr, uint32_t *saved, int print)\r\n{\r\nreturn atom_get_src_int(ctx,\r\narg | atom_dst_to_src[(attr >> 3) &\r\n7][(attr >> 6) & 3] << 3,\r\nptr, saved, print);\r\n}\r\nstatic void atom_skip_dst(atom_exec_context *ctx, int arg, uint8_t attr, int *ptr)\r\n{\r\natom_skip_src_int(ctx,\r\narg | atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) &\r\n3] << 3, ptr);\r\n}\r\nstatic void atom_put_dst(atom_exec_context *ctx, int arg, uint8_t attr,\r\nint *ptr, uint32_t val, uint32_t saved)\r\n{\r\nuint32_t align =\r\natom_dst_to_src[(attr >> 3) & 7][(attr >> 6) & 3], old_val =\r\nval, idx;\r\nstruct atom_context *gctx = ctx->ctx;\r\nold_val &= atom_arg_mask[align] >> atom_arg_shift[align];\r\nval <<= atom_arg_shift[align];\r\nval &= atom_arg_mask[align];\r\nsaved &= ~atom_arg_mask[align];\r\nval |= saved;\r\nswitch (arg) {\r\ncase ATOM_ARG_REG:\r\nidx = U16(*ptr);\r\n(*ptr) += 2;\r\nDEBUG("REG[0x%04X]", idx);\r\nidx += gctx->reg_block;\r\nswitch (gctx->io_mode) {\r\ncase ATOM_IO_MM:\r\nif (idx == 0)\r\ngctx->card->reg_write(gctx->card, idx,\r\nval << 2);\r\nelse\r\ngctx->card->reg_write(gctx->card, idx, val);\r\nbreak;\r\ncase ATOM_IO_PCI:\r\nprintk(KERN_INFO\r\n"PCI registers are not implemented.\n");\r\nreturn;\r\ncase ATOM_IO_SYSIO:\r\nprintk(KERN_INFO\r\n"SYSIO registers are not implemented.\n");\r\nreturn;\r\ndefault:\r\nif (!(gctx->io_mode & 0x80)) {\r\nprintk(KERN_INFO "Bad IO mode.\n");\r\nreturn;\r\n}\r\nif (!gctx->iio[gctx->io_mode & 0xFF]) {\r\nprintk(KERN_INFO\r\n"Undefined indirect IO write method %d.\n",\r\ngctx->io_mode & 0x7F);\r\nreturn;\r\n}\r\natom_iio_execute(gctx, gctx->iio[gctx->io_mode & 0xFF],\r\nidx, val);\r\n}\r\nbreak;\r\ncase ATOM_ARG_PS:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nDEBUG("PS[0x%02X]", idx);\r\nctx->ps[idx] = cpu_to_le32(val);\r\nbreak;\r\ncase ATOM_ARG_WS:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nDEBUG("WS[0x%02X]", idx);\r\nswitch (idx) {\r\ncase ATOM_WS_QUOTIENT:\r\ngctx->divmul[0] = val;\r\nbreak;\r\ncase ATOM_WS_REMAINDER:\r\ngctx->divmul[1] = val;\r\nbreak;\r\ncase ATOM_WS_DATAPTR:\r\ngctx->data_block = val;\r\nbreak;\r\ncase ATOM_WS_SHIFT:\r\ngctx->shift = val;\r\nbreak;\r\ncase ATOM_WS_OR_MASK:\r\ncase ATOM_WS_AND_MASK:\r\nbreak;\r\ncase ATOM_WS_FB_WINDOW:\r\ngctx->fb_base = val;\r\nbreak;\r\ncase ATOM_WS_ATTRIBUTES:\r\ngctx->io_attr = val;\r\nbreak;\r\ncase ATOM_WS_REGPTR:\r\ngctx->reg_block = val;\r\nbreak;\r\ndefault:\r\nctx->ws[idx] = val;\r\n}\r\nbreak;\r\ncase ATOM_ARG_FB:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nif ((gctx->fb_base + (idx * 4)) > gctx->scratch_size_bytes) {\r\nDRM_ERROR("ATOM: fb write beyond scratch region: %d vs. %d\n",\r\ngctx->fb_base + (idx * 4), gctx->scratch_size_bytes);\r\n} else\r\ngctx->scratch[(gctx->fb_base / 4) + idx] = val;\r\nDEBUG("FB[0x%02X]", idx);\r\nbreak;\r\ncase ATOM_ARG_PLL:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nDEBUG("PLL[0x%02X]", idx);\r\ngctx->card->pll_write(gctx->card, idx, val);\r\nbreak;\r\ncase ATOM_ARG_MC:\r\nidx = U8(*ptr);\r\n(*ptr)++;\r\nDEBUG("MC[0x%02X]", idx);\r\ngctx->card->mc_write(gctx->card, idx, val);\r\nreturn;\r\n}\r\nswitch (align) {\r\ncase ATOM_SRC_DWORD:\r\nDEBUG(".[31:0] <- 0x%08X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_WORD0:\r\nDEBUG(".[15:0] <- 0x%04X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_WORD8:\r\nDEBUG(".[23:8] <- 0x%04X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_WORD16:\r\nDEBUG(".[31:16] <- 0x%04X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_BYTE0:\r\nDEBUG(".[7:0] <- 0x%02X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_BYTE8:\r\nDEBUG(".[15:8] <- 0x%02X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_BYTE16:\r\nDEBUG(".[23:16] <- 0x%02X\n", old_val);\r\nbreak;\r\ncase ATOM_SRC_BYTE24:\r\nDEBUG(".[31:24] <- 0x%02X\n", old_val);\r\nbreak;\r\n}\r\n}\r\nstatic void atom_op_add(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src, saved;\r\nint dptr = *ptr;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\ndst += src;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_and(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src, saved;\r\nint dptr = *ptr;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\ndst &= src;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_beep(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nprintk("ATOM BIOS beeped!\n");\r\n}\r\nstatic void atom_op_calltable(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nint idx = U8((*ptr)++);\r\nint r = 0;\r\nif (idx < ATOM_TABLE_NAMES_CNT)\r\nSDEBUG(" table: %d (%s)\n", idx, atom_table_names[idx]);\r\nelse\r\nSDEBUG(" table: %d\n", idx);\r\nif (U16(ctx->ctx->cmd_table + 4 + 2 * idx))\r\nr = amdgpu_atom_execute_table_locked(ctx->ctx, idx, ctx->ps + ctx->ps_shift);\r\nif (r) {\r\nctx->abort = true;\r\n}\r\n}\r\nstatic void atom_op_clear(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t saved;\r\nint dptr = *ptr;\r\nattr &= 0x38;\r\nattr |= atom_def_dst[attr >> 3] << 6;\r\natom_get_dst(ctx, arg, attr, ptr, &saved, 0);\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, 0, saved);\r\n}\r\nstatic void atom_op_compare(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src;\r\nSDEBUG(" src1: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\r\nSDEBUG(" src2: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\nctx->ctx->cs_equal = (dst == src);\r\nctx->ctx->cs_above = (dst > src);\r\nSDEBUG(" result: %s %s\n", ctx->ctx->cs_equal ? "EQ" : "NE",\r\nctx->ctx->cs_above ? "GT" : "LE");\r\n}\r\nstatic void atom_op_delay(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nunsigned count = U8((*ptr)++);\r\nSDEBUG(" count: %d\n", count);\r\nif (arg == ATOM_UNIT_MICROSEC)\r\nudelay(count);\r\nelse if (!drm_can_sleep())\r\nmdelay(count);\r\nelse\r\nmsleep(count);\r\n}\r\nstatic void atom_op_div(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src;\r\nSDEBUG(" src1: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\r\nSDEBUG(" src2: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\nif (src != 0) {\r\nctx->ctx->divmul[0] = dst / src;\r\nctx->ctx->divmul[1] = dst % src;\r\n} else {\r\nctx->ctx->divmul[0] = 0;\r\nctx->ctx->divmul[1] = 0;\r\n}\r\n}\r\nstatic void atom_op_eot(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\n}\r\nstatic void atom_op_jump(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nint execute = 0, target = U16(*ptr);\r\nunsigned long cjiffies;\r\n(*ptr) += 2;\r\nswitch (arg) {\r\ncase ATOM_COND_ABOVE:\r\nexecute = ctx->ctx->cs_above;\r\nbreak;\r\ncase ATOM_COND_ABOVEOREQUAL:\r\nexecute = ctx->ctx->cs_above || ctx->ctx->cs_equal;\r\nbreak;\r\ncase ATOM_COND_ALWAYS:\r\nexecute = 1;\r\nbreak;\r\ncase ATOM_COND_BELOW:\r\nexecute = !(ctx->ctx->cs_above || ctx->ctx->cs_equal);\r\nbreak;\r\ncase ATOM_COND_BELOWOREQUAL:\r\nexecute = !ctx->ctx->cs_above;\r\nbreak;\r\ncase ATOM_COND_EQUAL:\r\nexecute = ctx->ctx->cs_equal;\r\nbreak;\r\ncase ATOM_COND_NOTEQUAL:\r\nexecute = !ctx->ctx->cs_equal;\r\nbreak;\r\n}\r\nif (arg != ATOM_COND_ALWAYS)\r\nSDEBUG(" taken: %s\n", execute ? "yes" : "no");\r\nSDEBUG(" target: 0x%04X\n", target);\r\nif (execute) {\r\nif (ctx->last_jump == (ctx->start + target)) {\r\ncjiffies = jiffies;\r\nif (time_after(cjiffies, ctx->last_jump_jiffies)) {\r\ncjiffies -= ctx->last_jump_jiffies;\r\nif ((jiffies_to_msecs(cjiffies) > 5000)) {\r\nDRM_ERROR("atombios stuck in loop for more than 5secs aborting\n");\r\nctx->abort = true;\r\n}\r\n} else {\r\nctx->last_jump_jiffies = jiffies;\r\n}\r\n} else {\r\nctx->last_jump = ctx->start + target;\r\nctx->last_jump_jiffies = jiffies;\r\n}\r\n*ptr = ctx->start + target;\r\n}\r\n}\r\nstatic void atom_op_mask(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, mask, src, saved;\r\nint dptr = *ptr;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nmask = atom_get_src_direct(ctx, ((attr >> 3) & 7), ptr);\r\nSDEBUG(" mask: 0x%08x", mask);\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\ndst &= mask;\r\ndst |= src;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_move(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t src, saved;\r\nint dptr = *ptr;\r\nif (((attr >> 3) & 7) != ATOM_SRC_DWORD)\r\natom_get_dst(ctx, arg, attr, ptr, &saved, 0);\r\nelse {\r\natom_skip_dst(ctx, arg, attr, ptr);\r\nsaved = 0xCDCDCDCD;\r\n}\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, src, saved);\r\n}\r\nstatic void atom_op_mul(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src;\r\nSDEBUG(" src1: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\r\nSDEBUG(" src2: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\nctx->ctx->divmul[0] = dst * src;\r\n}\r\nstatic void atom_op_nop(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\n}\r\nstatic void atom_op_or(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src, saved;\r\nint dptr = *ptr;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\ndst |= src;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_postcard(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t val = U8((*ptr)++);\r\nSDEBUG("POST card output: 0x%02X\n", val);\r\n}\r\nstatic void atom_op_repeat(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nprintk(KERN_INFO "unimplemented!\n");\r\n}\r\nstatic void atom_op_restorereg(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nprintk(KERN_INFO "unimplemented!\n");\r\n}\r\nstatic void atom_op_savereg(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nprintk(KERN_INFO "unimplemented!\n");\r\n}\r\nstatic void atom_op_setdatablock(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nint idx = U8(*ptr);\r\n(*ptr)++;\r\nSDEBUG(" block: %d\n", idx);\r\nif (!idx)\r\nctx->ctx->data_block = 0;\r\nelse if (idx == 255)\r\nctx->ctx->data_block = ctx->start;\r\nelse\r\nctx->ctx->data_block = U16(ctx->ctx->data_table + 4 + 2 * idx);\r\nSDEBUG(" base: 0x%04X\n", ctx->ctx->data_block);\r\n}\r\nstatic void atom_op_setfbbase(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nSDEBUG(" fb_base: ");\r\nctx->ctx->fb_base = atom_get_src(ctx, attr, ptr);\r\n}\r\nstatic void atom_op_setport(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nint port;\r\nswitch (arg) {\r\ncase ATOM_PORT_ATI:\r\nport = U16(*ptr);\r\nif (port < ATOM_IO_NAMES_CNT)\r\nSDEBUG(" port: %d (%s)\n", port, atom_io_names[port]);\r\nelse\r\nSDEBUG(" port: %d\n", port);\r\nif (!port)\r\nctx->ctx->io_mode = ATOM_IO_MM;\r\nelse\r\nctx->ctx->io_mode = ATOM_IO_IIO | port;\r\n(*ptr) += 2;\r\nbreak;\r\ncase ATOM_PORT_PCI:\r\nctx->ctx->io_mode = ATOM_IO_PCI;\r\n(*ptr)++;\r\nbreak;\r\ncase ATOM_PORT_SYSIO:\r\nctx->ctx->io_mode = ATOM_IO_SYSIO;\r\n(*ptr)++;\r\nbreak;\r\n}\r\n}\r\nstatic void atom_op_setregblock(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nctx->ctx->reg_block = U16(*ptr);\r\n(*ptr) += 2;\r\nSDEBUG(" base: 0x%04X\n", ctx->ctx->reg_block);\r\n}\r\nstatic void atom_op_shift_left(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++), shift;\r\nuint32_t saved, dst;\r\nint dptr = *ptr;\r\nattr &= 0x38;\r\nattr |= atom_def_dst[attr >> 3] << 6;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nshift = atom_get_src_direct(ctx, ATOM_SRC_BYTE0, ptr);\r\nSDEBUG(" shift: %d\n", shift);\r\ndst <<= shift;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_shift_right(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++), shift;\r\nuint32_t saved, dst;\r\nint dptr = *ptr;\r\nattr &= 0x38;\r\nattr |= atom_def_dst[attr >> 3] << 6;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nshift = atom_get_src_direct(ctx, ATOM_SRC_BYTE0, ptr);\r\nSDEBUG(" shift: %d\n", shift);\r\ndst >>= shift;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_shl(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++), shift;\r\nuint32_t saved, dst;\r\nint dptr = *ptr;\r\nuint32_t dst_align = atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) & 3];\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\ndst = saved;\r\nshift = atom_get_src(ctx, attr, ptr);\r\nSDEBUG(" shift: %d\n", shift);\r\ndst <<= shift;\r\ndst &= atom_arg_mask[dst_align];\r\ndst >>= atom_arg_shift[dst_align];\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_shr(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++), shift;\r\nuint32_t saved, dst;\r\nint dptr = *ptr;\r\nuint32_t dst_align = atom_dst_to_src[(attr >> 3) & 7][(attr >> 6) & 3];\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\ndst = saved;\r\nshift = atom_get_src(ctx, attr, ptr);\r\nSDEBUG(" shift: %d\n", shift);\r\ndst >>= shift;\r\ndst &= atom_arg_mask[dst_align];\r\ndst >>= atom_arg_shift[dst_align];\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_sub(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src, saved;\r\nint dptr = *ptr;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\ndst -= src;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_switch(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t src, val, target;\r\nSDEBUG(" switch: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\nwhile (U16(*ptr) != ATOM_CASE_END)\r\nif (U8(*ptr) == ATOM_CASE_MAGIC) {\r\n(*ptr)++;\r\nSDEBUG(" case: ");\r\nval =\r\natom_get_src(ctx, (attr & 0x38) | ATOM_ARG_IMM,\r\nptr);\r\ntarget = U16(*ptr);\r\nif (val == src) {\r\nSDEBUG(" target: %04X\n", target);\r\n*ptr = ctx->start + target;\r\nreturn;\r\n}\r\n(*ptr) += 2;\r\n} else {\r\nprintk(KERN_INFO "Bad case.\n");\r\nreturn;\r\n}\r\n(*ptr) += 2;\r\n}\r\nstatic void atom_op_test(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src;\r\nSDEBUG(" src1: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, NULL, 1);\r\nSDEBUG(" src2: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\nctx->ctx->cs_equal = ((dst & src) == 0);\r\nSDEBUG(" result: %s\n", ctx->ctx->cs_equal ? "EQ" : "NE");\r\n}\r\nstatic void atom_op_xor(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nuint8_t attr = U8((*ptr)++);\r\nuint32_t dst, src, saved;\r\nint dptr = *ptr;\r\nSDEBUG(" dst: ");\r\ndst = atom_get_dst(ctx, arg, attr, ptr, &saved, 1);\r\nSDEBUG(" src: ");\r\nsrc = atom_get_src(ctx, attr, ptr);\r\ndst ^= src;\r\nSDEBUG(" dst: ");\r\natom_put_dst(ctx, arg, attr, &dptr, dst, saved);\r\n}\r\nstatic void atom_op_debug(atom_exec_context *ctx, int *ptr, int arg)\r\n{\r\nprintk(KERN_INFO "unimplemented!\n");\r\n}\r\nstatic int amdgpu_atom_execute_table_locked(struct atom_context *ctx, int index, uint32_t * params)\r\n{\r\nint base = CU16(ctx->cmd_table + 4 + 2 * index);\r\nint len, ws, ps, ptr;\r\nunsigned char op;\r\natom_exec_context ectx;\r\nint ret = 0;\r\nif (!base)\r\nreturn -EINVAL;\r\nlen = CU16(base + ATOM_CT_SIZE_PTR);\r\nws = CU8(base + ATOM_CT_WS_PTR);\r\nps = CU8(base + ATOM_CT_PS_PTR) & ATOM_CT_PS_MASK;\r\nptr = base + ATOM_CT_CODE_PTR;\r\nSDEBUG(">> execute %04X (len %d, WS %d, PS %d)\n", base, len, ws, ps);\r\nectx.ctx = ctx;\r\nectx.ps_shift = ps / 4;\r\nectx.start = base;\r\nectx.ps = params;\r\nectx.abort = false;\r\nectx.last_jump = 0;\r\nif (ws)\r\nectx.ws = kzalloc(4 * ws, GFP_KERNEL);\r\nelse\r\nectx.ws = NULL;\r\ndebug_depth++;\r\nwhile (1) {\r\nop = CU8(ptr++);\r\nif (op < ATOM_OP_NAMES_CNT)\r\nSDEBUG("%s @ 0x%04X\n", atom_op_names[op], ptr - 1);\r\nelse\r\nSDEBUG("[%d] @ 0x%04X\n", op, ptr - 1);\r\nif (ectx.abort) {\r\nDRM_ERROR("atombios stuck executing %04X (len %d, WS %d, PS %d) @ 0x%04X\n",\r\nbase, len, ws, ps, ptr - 1);\r\nret = -EINVAL;\r\ngoto free;\r\n}\r\nif (op < ATOM_OP_CNT && op > 0)\r\nopcode_table[op].func(&ectx, &ptr,\r\nopcode_table[op].arg);\r\nelse\r\nbreak;\r\nif (op == ATOM_OP_EOT)\r\nbreak;\r\n}\r\ndebug_depth--;\r\nSDEBUG("<<\n");\r\nfree:\r\nif (ws)\r\nkfree(ectx.ws);\r\nreturn ret;\r\n}\r\nint amdgpu_atom_execute_table(struct atom_context *ctx, int index, uint32_t * params)\r\n{\r\nint r;\r\nmutex_lock(&ctx->mutex);\r\nctx->data_block = 0;\r\nctx->reg_block = 0;\r\nctx->fb_base = 0;\r\nctx->io_mode = ATOM_IO_MM;\r\nctx->divmul[0] = 0;\r\nctx->divmul[1] = 0;\r\nr = amdgpu_atom_execute_table_locked(ctx, index, params);\r\nmutex_unlock(&ctx->mutex);\r\nreturn r;\r\n}\r\nstatic void atom_index_iio(struct atom_context *ctx, int base)\r\n{\r\nctx->iio = kzalloc(2 * 256, GFP_KERNEL);\r\nif (!ctx->iio)\r\nreturn;\r\nwhile (CU8(base) == ATOM_IIO_START) {\r\nctx->iio[CU8(base + 1)] = base + 2;\r\nbase += 2;\r\nwhile (CU8(base) != ATOM_IIO_END)\r\nbase += atom_iio_len[CU8(base)];\r\nbase += 3;\r\n}\r\n}\r\nstruct atom_context *amdgpu_atom_parse(struct card_info *card, void *bios)\r\n{\r\nint base;\r\nstruct atom_context *ctx =\r\nkzalloc(sizeof(struct atom_context), GFP_KERNEL);\r\nchar *str;\r\nchar name[512];\r\nint i;\r\nif (!ctx)\r\nreturn NULL;\r\nctx->card = card;\r\nctx->bios = bios;\r\nif (CU16(0) != ATOM_BIOS_MAGIC) {\r\nprintk(KERN_INFO "Invalid BIOS magic.\n");\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nif (strncmp\r\n(CSTR(ATOM_ATI_MAGIC_PTR), ATOM_ATI_MAGIC,\r\nstrlen(ATOM_ATI_MAGIC))) {\r\nprintk(KERN_INFO "Invalid ATI magic.\n");\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nbase = CU16(ATOM_ROM_TABLE_PTR);\r\nif (strncmp\r\n(CSTR(base + ATOM_ROM_MAGIC_PTR), ATOM_ROM_MAGIC,\r\nstrlen(ATOM_ROM_MAGIC))) {\r\nprintk(KERN_INFO "Invalid ATOM magic.\n");\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nctx->cmd_table = CU16(base + ATOM_ROM_CMD_PTR);\r\nctx->data_table = CU16(base + ATOM_ROM_DATA_PTR);\r\natom_index_iio(ctx, CU16(ctx->data_table + ATOM_DATA_IIO_PTR) + 4);\r\nif (!ctx->iio) {\r\namdgpu_atom_destroy(ctx);\r\nreturn NULL;\r\n}\r\nstr = CSTR(CU16(base + ATOM_ROM_MSG_PTR));\r\nwhile (*str && ((*str == '\n') || (*str == '\r')))\r\nstr++;\r\nfor (i = 0; i < 511; i++) {\r\nname[i] = str[i];\r\nif (name[i] < '.' || name[i] > 'z') {\r\nname[i] = 0;\r\nbreak;\r\n}\r\n}\r\nprintk(KERN_INFO "ATOM BIOS: %s\n", name);\r\nreturn ctx;\r\n}\r\nint amdgpu_atom_asic_init(struct atom_context *ctx)\r\n{\r\nint hwi = CU16(ctx->data_table + ATOM_DATA_FWI_PTR);\r\nuint32_t ps[16];\r\nint ret;\r\nmemset(ps, 0, 64);\r\nps[0] = cpu_to_le32(CU32(hwi + ATOM_FWI_DEFSCLK_PTR));\r\nps[1] = cpu_to_le32(CU32(hwi + ATOM_FWI_DEFMCLK_PTR));\r\nif (!ps[0] || !ps[1])\r\nreturn 1;\r\nif (!CU16(ctx->cmd_table + 4 + 2 * ATOM_CMD_INIT))\r\nreturn 1;\r\nret = amdgpu_atom_execute_table(ctx, ATOM_CMD_INIT, ps);\r\nif (ret)\r\nreturn ret;\r\nmemset(ps, 0, 64);\r\nreturn ret;\r\n}\r\nvoid amdgpu_atom_destroy(struct atom_context *ctx)\r\n{\r\nkfree(ctx->iio);\r\nkfree(ctx);\r\n}\r\nbool amdgpu_atom_parse_data_header(struct atom_context *ctx, int index,\r\nuint16_t * size, uint8_t * frev, uint8_t * crev,\r\nuint16_t * data_start)\r\n{\r\nint offset = index * 2 + 4;\r\nint idx = CU16(ctx->data_table + offset);\r\nu16 *mdt = (u16 *)(ctx->bios + ctx->data_table + 4);\r\nif (!mdt[index])\r\nreturn false;\r\nif (size)\r\n*size = CU16(idx);\r\nif (frev)\r\n*frev = CU8(idx + 2);\r\nif (crev)\r\n*crev = CU8(idx + 3);\r\n*data_start = idx;\r\nreturn true;\r\n}\r\nbool amdgpu_atom_parse_cmd_header(struct atom_context *ctx, int index, uint8_t * frev,\r\nuint8_t * crev)\r\n{\r\nint offset = index * 2 + 4;\r\nint idx = CU16(ctx->cmd_table + offset);\r\nu16 *mct = (u16 *)(ctx->bios + ctx->cmd_table + 4);\r\nif (!mct[index])\r\nreturn false;\r\nif (frev)\r\n*frev = CU8(idx + 2);\r\nif (crev)\r\n*crev = CU8(idx + 3);\r\nreturn true;\r\n}\r\nint amdgpu_atom_allocate_fb_scratch(struct atom_context *ctx)\r\n{\r\nint index = GetIndexIntoMasterTable(DATA, VRAM_UsageByFirmware);\r\nuint16_t data_offset;\r\nint usage_bytes = 0;\r\nstruct _ATOM_VRAM_USAGE_BY_FIRMWARE *firmware_usage;\r\nif (amdgpu_atom_parse_data_header(ctx, index, NULL, NULL, NULL, &data_offset)) {\r\nfirmware_usage = (struct _ATOM_VRAM_USAGE_BY_FIRMWARE *)(ctx->bios + data_offset);\r\nDRM_DEBUG("atom firmware requested %08x %dkb\n",\r\nle32_to_cpu(firmware_usage->asFirmwareVramReserveInfo[0].ulStartAddrUsedByFirmware),\r\nle16_to_cpu(firmware_usage->asFirmwareVramReserveInfo[0].usFirmwareUseInKb));\r\nusage_bytes = le16_to_cpu(firmware_usage->asFirmwareVramReserveInfo[0].usFirmwareUseInKb) * 1024;\r\n}\r\nctx->scratch_size_bytes = 0;\r\nif (usage_bytes == 0)\r\nusage_bytes = 20 * 1024;\r\nctx->scratch = kzalloc(usage_bytes, GFP_KERNEL);\r\nif (!ctx->scratch)\r\nreturn -ENOMEM;\r\nctx->scratch_size_bytes = usage_bytes;\r\nreturn 0;\r\n}
