static int __cmd_record(int argc, const char **argv, struct perf_mem *mem)\r\n{\r\nint rec_argc, i = 0, j;\r\nconst char **rec_argv;\r\nint ret;\r\nrec_argc = argc + 7;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (!rec_argv)\r\nreturn -1;\r\nrec_argv[i++] = "record";\r\nif (mem->operation & MEM_OPERATION_LOAD)\r\nrec_argv[i++] = "-W";\r\nrec_argv[i++] = "-d";\r\nif (mem->operation & MEM_OPERATION_LOAD) {\r\nrec_argv[i++] = "-e";\r\nrec_argv[i++] = "cpu/mem-loads/pp";\r\n}\r\nif (mem->operation & MEM_OPERATION_STORE) {\r\nrec_argv[i++] = "-e";\r\nrec_argv[i++] = "cpu/mem-stores/pp";\r\n}\r\nfor (j = 1; j < argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nret = cmd_record(i, rec_argv, NULL);\r\nfree(rec_argv);\r\nreturn ret;\r\n}\r\nstatic int\r\ndump_raw_samples(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct perf_mem *mem = container_of(tool, struct perf_mem, tool);\r\nstruct addr_location al;\r\nconst char *fmt;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample) < 0) {\r\nfprintf(stderr, "problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (al.filtered || (mem->hide_unresolved && al.sym == NULL))\r\ngoto out_put;\r\nif (al.map != NULL)\r\nal.map->dso->hit = 1;\r\nif (symbol_conf.field_sep) {\r\nfmt = "%d%s%d%s0x%"PRIx64"%s0x%"PRIx64"%s%"PRIu64\r\n"%s0x%"PRIx64"%s%s:%s\n";\r\n} else {\r\nfmt = "%5d%s%5d%s0x%016"PRIx64"%s0x016%"PRIx64\r\n"%s%5"PRIu64"%s0x%06"PRIx64"%s%s:%s\n";\r\nsymbol_conf.field_sep = " ";\r\n}\r\nprintf(fmt,\r\nsample->pid,\r\nsymbol_conf.field_sep,\r\nsample->tid,\r\nsymbol_conf.field_sep,\r\nsample->ip,\r\nsymbol_conf.field_sep,\r\nsample->addr,\r\nsymbol_conf.field_sep,\r\nsample->weight,\r\nsymbol_conf.field_sep,\r\nsample->data_src,\r\nsymbol_conf.field_sep,\r\nal.map ? (al.map->dso ? al.map->dso->long_name : "???") : "???",\r\nal.sym ? al.sym->name : "???");\r\nout_put:\r\naddr_location__put(&al);\r\nreturn 0;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nreturn dump_raw_samples(tool, event, sample, machine);\r\n}\r\nstatic int report_raw_events(struct perf_mem *mem)\r\n{\r\nstruct perf_data_file file = {\r\n.path = input_name,\r\n.mode = PERF_DATA_MODE_READ,\r\n.force = mem->force,\r\n};\r\nint ret;\r\nstruct perf_session *session = perf_session__new(&file, false,\r\n&mem->tool);\r\nif (session == NULL)\r\nreturn -1;\r\nif (mem->cpu_list) {\r\nret = perf_session__cpu_bitmap(session, mem->cpu_list,\r\nmem->cpu_bitmap);\r\nif (ret < 0)\r\ngoto out_delete;\r\n}\r\nret = symbol__init(&session->header.env);\r\nif (ret < 0)\r\ngoto out_delete;\r\nprintf("# PID, TID, IP, ADDR, LOCAL WEIGHT, DSRC, SYMBOL\n");\r\nret = perf_session__process_events(session);\r\nout_delete:\r\nperf_session__delete(session);\r\nreturn ret;\r\n}\r\nstatic int report_events(int argc, const char **argv, struct perf_mem *mem)\r\n{\r\nconst char **rep_argv;\r\nint ret, i = 0, j, rep_argc;\r\nif (mem->dump_raw)\r\nreturn report_raw_events(mem);\r\nrep_argc = argc + 3;\r\nrep_argv = calloc(rep_argc + 1, sizeof(char *));\r\nif (!rep_argv)\r\nreturn -1;\r\nrep_argv[i++] = "report";\r\nrep_argv[i++] = "--mem-mode";\r\nrep_argv[i++] = "-n";\r\nif (!(mem->operation & MEM_OPERATION_LOAD))\r\nrep_argv[i++] = "--sort=mem,sym,dso,symbol_daddr,"\r\n"dso_daddr,tlb,locked";\r\nfor (j = 1; j < argc; j++, i++)\r\nrep_argv[i] = argv[j];\r\nret = cmd_report(i, rep_argv, NULL);\r\nfree(rep_argv);\r\nreturn ret;\r\n}\r\nstatic int\r\nparse_mem_ops(const struct option *opt, const char *str, int unset)\r\n{\r\nint *mode = (int *)opt->value;\r\nconst struct mem_mode *m;\r\nchar *s, *os = NULL, *p;\r\nint ret = -1;\r\nif (unset)\r\nreturn 0;\r\nif (str) {\r\ns = os = strdup(str);\r\nif (!s)\r\nreturn -1;\r\n*mode = 0;\r\nfor (;;) {\r\np = strchr(s, ',');\r\nif (p)\r\n*p = '\0';\r\nfor (m = mem_modes; m->name; m++) {\r\nif (!strcasecmp(s, m->name))\r\nbreak;\r\n}\r\nif (!m->name) {\r\nfprintf(stderr, "unknown sampling op %s,"\r\n" check man page\n", s);\r\ngoto error;\r\n}\r\n*mode |= m->mode;\r\nif (!p)\r\nbreak;\r\ns = p + 1;\r\n}\r\n}\r\nret = 0;\r\nif (*mode == 0)\r\n*mode = MEM_OPERATION_LOAD;\r\nerror:\r\nfree(os);\r\nreturn ret;\r\n}\r\nint cmd_mem(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct stat st;\r\nstruct perf_mem mem = {\r\n.tool = {\r\n.sample = process_sample_event,\r\n.mmap = perf_event__process_mmap,\r\n.mmap2 = perf_event__process_mmap2,\r\n.comm = perf_event__process_comm,\r\n.lost = perf_event__process_lost,\r\n.fork = perf_event__process_fork,\r\n.build_id = perf_event__process_build_id,\r\n.ordered_events = true,\r\n},\r\n.input_name = "perf.data",\r\n.operation = MEM_OPERATION_LOAD | MEM_OPERATION_STORE,\r\n};\r\nconst struct option mem_options[] = {\r\nOPT_CALLBACK('t', "type", &mem.operation,\r\n"type", "memory operations(load,store) Default load,store",\r\nparse_mem_ops),\r\nOPT_BOOLEAN('D', "dump-raw-samples", &mem.dump_raw,\r\n"dump raw samples in ASCII"),\r\nOPT_BOOLEAN('U', "hide-unresolved", &mem.hide_unresolved,\r\n"Only display entries resolved to a symbol"),\r\nOPT_STRING('i', "input", &input_name, "file",\r\n"input file name"),\r\nOPT_STRING('C', "cpu", &mem.cpu_list, "cpu",\r\n"list of cpus to profile"),\r\nOPT_STRING_NOEMPTY('x', "field-separator", &symbol_conf.field_sep,\r\n"separator",\r\n"separator for columns, no spaces will be added"\r\n" between columns '.' is reserved."),\r\nOPT_BOOLEAN('f', "force", &mem.force, "don't complain, do it"),\r\nOPT_END()\r\n};\r\nconst char *const mem_subcommands[] = { "record", "report", NULL };\r\nconst char *mem_usage[] = {\r\nNULL,\r\nNULL\r\n};\r\nargc = parse_options_subcommand(argc, argv, mem_options, mem_subcommands,\r\nmem_usage, PARSE_OPT_STOP_AT_NON_OPTION);\r\nif (!argc || !(strncmp(argv[0], "rec", 3) || mem.operation))\r\nusage_with_options(mem_usage, mem_options);\r\nif (!mem.input_name || !strlen(mem.input_name)) {\r\nif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\r\nmem.input_name = "-";\r\nelse\r\nmem.input_name = "perf.data";\r\n}\r\nif (!strncmp(argv[0], "rec", 3))\r\nreturn __cmd_record(argc, argv, &mem);\r\nelse if (!strncmp(argv[0], "rep", 3))\r\nreturn report_events(argc, argv, &mem);\r\nelse\r\nusage_with_options(mem_usage, mem_options);\r\nreturn 0;\r\n}
