static void virtio_gpu_crtc_gamma_set(struct drm_crtc *crtc,\r\nu16 *red, u16 *green, u16 *blue,\r\nuint32_t start, uint32_t size)\r\n{\r\n}\r\nstatic void\r\nvirtio_gpu_hide_cursor(struct virtio_gpu_device *vgdev,\r\nstruct virtio_gpu_output *output)\r\n{\r\noutput->cursor.hdr.type = cpu_to_le32(VIRTIO_GPU_CMD_UPDATE_CURSOR);\r\noutput->cursor.resource_id = 0;\r\nvirtio_gpu_cursor_ping(vgdev, output);\r\n}\r\nstatic int virtio_gpu_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width,\r\nuint32_t height,\r\nint32_t hot_x, int32_t hot_y)\r\n{\r\nstruct virtio_gpu_device *vgdev = crtc->dev->dev_private;\r\nstruct virtio_gpu_output *output =\r\ncontainer_of(crtc, struct virtio_gpu_output, crtc);\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct virtio_gpu_object *qobj = NULL;\r\nstruct virtio_gpu_fence *fence = NULL;\r\nint ret = 0;\r\nif (handle == 0) {\r\nvirtio_gpu_hide_cursor(vgdev, output);\r\nreturn 0;\r\n}\r\ngobj = drm_gem_object_lookup(crtc->dev, file_priv, handle);\r\nif (gobj == NULL)\r\nreturn -ENOENT;\r\nqobj = gem_to_virtio_gpu_obj(gobj);\r\nif (!qobj->hw_res_handle) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nvirtio_gpu_cmd_transfer_to_host_2d(vgdev, qobj->hw_res_handle, 0,\r\ncpu_to_le32(64),\r\ncpu_to_le32(64),\r\n0, 0, &fence);\r\noutput->cursor.hdr.type = cpu_to_le32(VIRTIO_GPU_CMD_UPDATE_CURSOR);\r\noutput->cursor.resource_id = cpu_to_le32(qobj->hw_res_handle);\r\noutput->cursor.hot_x = cpu_to_le32(hot_x);\r\noutput->cursor.hot_y = cpu_to_le32(hot_y);\r\nvirtio_gpu_cursor_ping(vgdev, output);\r\nret = 0;\r\nout:\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nreturn ret;\r\n}\r\nstatic int virtio_gpu_crtc_cursor_move(struct drm_crtc *crtc,\r\nint x, int y)\r\n{\r\nstruct virtio_gpu_device *vgdev = crtc->dev->dev_private;\r\nstruct virtio_gpu_output *output =\r\ncontainer_of(crtc, struct virtio_gpu_output, crtc);\r\noutput->cursor.hdr.type = cpu_to_le32(VIRTIO_GPU_CMD_MOVE_CURSOR);\r\noutput->cursor.pos.x = cpu_to_le32(x);\r\noutput->cursor.pos.y = cpu_to_le32(y);\r\nvirtio_gpu_cursor_ping(vgdev, output);\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct virtio_gpu_framebuffer *virtio_gpu_fb\r\n= to_virtio_gpu_framebuffer(fb);\r\nif (virtio_gpu_fb->obj)\r\ndrm_gem_object_unreference_unlocked(virtio_gpu_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(virtio_gpu_fb);\r\n}\r\nstatic int\r\nvirtio_gpu_framebuffer_surface_dirty(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips,\r\nunsigned num_clips)\r\n{\r\nstruct virtio_gpu_framebuffer *virtio_gpu_fb\r\n= to_virtio_gpu_framebuffer(fb);\r\nreturn virtio_gpu_surface_dirty(virtio_gpu_fb, clips, num_clips);\r\n}\r\nint\r\nvirtio_gpu_framebuffer_init(struct drm_device *dev,\r\nstruct virtio_gpu_framebuffer *vgfb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\nstruct virtio_gpu_object *bo;\r\nvgfb->obj = obj;\r\nbo = gem_to_virtio_gpu_obj(obj);\r\nret = drm_framebuffer_init(dev, &vgfb->base, &virtio_gpu_fb_funcs);\r\nif (ret) {\r\nvgfb->obj = NULL;\r\nreturn ret;\r\n}\r\ndrm_helper_mode_fill_fb_struct(&vgfb->base, mode_cmd);\r\nspin_lock_init(&vgfb->dirty_lock);\r\nvgfb->x1 = vgfb->y1 = INT_MAX;\r\nvgfb->x2 = vgfb->y2 = 0;\r\nreturn 0;\r\n}\r\nstatic bool virtio_gpu_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void virtio_gpu_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);\r\nvirtio_gpu_cmd_set_scanout(vgdev, output->index, 0,\r\ncrtc->mode.hdisplay,\r\ncrtc->mode.vdisplay, 0, 0);\r\n}\r\nstatic void virtio_gpu_crtc_enable(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void virtio_gpu_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);\r\nvirtio_gpu_cmd_set_scanout(vgdev, output->index, 0, 0, 0, 0, 0);\r\n}\r\nstatic int virtio_gpu_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic bool virtio_gpu_enc_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void virtio_gpu_enc_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void virtio_gpu_enc_enable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void virtio_gpu_enc_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic int virtio_gpu_conn_get_modes(struct drm_connector *connector)\r\n{\r\nstruct virtio_gpu_output *output =\r\ndrm_connector_to_virtio_gpu_output(connector);\r\nstruct drm_display_mode *mode = NULL;\r\nint count, width, height;\r\nwidth = le32_to_cpu(output->info.r.width);\r\nheight = le32_to_cpu(output->info.r.height);\r\ncount = drm_add_modes_noedid(connector, XRES_MAX, YRES_MAX);\r\nif (width == 0 || height == 0) {\r\nwidth = XRES_DEF;\r\nheight = YRES_DEF;\r\ndrm_set_preferred_mode(connector, XRES_DEF, YRES_DEF);\r\n} else {\r\nDRM_DEBUG("add mode: %dx%d\n", width, height);\r\nmode = drm_cvt_mode(connector->dev, width, height, 60,\r\nfalse, false, false);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int virtio_gpu_conn_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct virtio_gpu_output *output =\r\ndrm_connector_to_virtio_gpu_output(connector);\r\nint width, height;\r\nwidth = le32_to_cpu(output->info.r.width);\r\nheight = le32_to_cpu(output->info.r.height);\r\nif (!(mode->type & DRM_MODE_TYPE_PREFERRED))\r\nreturn MODE_OK;\r\nif (mode->hdisplay == XRES_DEF && mode->vdisplay == YRES_DEF)\r\nreturn MODE_OK;\r\nif (mode->hdisplay <= width && mode->hdisplay >= width - 16 &&\r\nmode->vdisplay <= height && mode->vdisplay >= height - 16)\r\nreturn MODE_OK;\r\nDRM_DEBUG("del mode: %dx%d\n", mode->hdisplay, mode->vdisplay);\r\nreturn MODE_BAD;\r\n}\r\nstatic struct drm_encoder*\r\nvirtio_gpu_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct virtio_gpu_output *virtio_gpu_output =\r\ndrm_connector_to_virtio_gpu_output(connector);\r\nreturn &virtio_gpu_output->enc;\r\n}\r\nstatic void virtio_gpu_conn_save(struct drm_connector *connector)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic void virtio_gpu_conn_restore(struct drm_connector *connector)\r\n{\r\nDRM_DEBUG("\n");\r\n}\r\nstatic enum drm_connector_status virtio_gpu_conn_detect(\r\nstruct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct virtio_gpu_output *output =\r\ndrm_connector_to_virtio_gpu_output(connector);\r\nif (output->info.enabled)\r\nreturn connector_status_connected;\r\nelse\r\nreturn connector_status_disconnected;\r\n}\r\nstatic void virtio_gpu_conn_destroy(struct drm_connector *connector)\r\n{\r\nstruct virtio_gpu_output *virtio_gpu_output =\r\ndrm_connector_to_virtio_gpu_output(connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(virtio_gpu_output);\r\n}\r\nstatic int vgdev_output_init(struct virtio_gpu_device *vgdev, int index)\r\n{\r\nstruct drm_device *dev = vgdev->ddev;\r\nstruct virtio_gpu_output *output = vgdev->outputs + index;\r\nstruct drm_connector *connector = &output->conn;\r\nstruct drm_encoder *encoder = &output->enc;\r\nstruct drm_crtc *crtc = &output->crtc;\r\nstruct drm_plane *plane;\r\noutput->index = index;\r\nif (index == 0) {\r\noutput->info.enabled = cpu_to_le32(true);\r\noutput->info.r.width = cpu_to_le32(XRES_DEF);\r\noutput->info.r.height = cpu_to_le32(YRES_DEF);\r\n}\r\nplane = virtio_gpu_plane_init(vgdev, index);\r\nif (IS_ERR(plane))\r\nreturn PTR_ERR(plane);\r\ndrm_crtc_init_with_planes(dev, crtc, plane, NULL,\r\n&virtio_gpu_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(crtc, 256);\r\ndrm_crtc_helper_add(crtc, &virtio_gpu_crtc_helper_funcs);\r\nplane->crtc = crtc;\r\ndrm_connector_init(dev, connector, &virtio_gpu_connector_funcs,\r\nDRM_MODE_CONNECTOR_VIRTUAL);\r\ndrm_connector_helper_add(connector, &virtio_gpu_conn_helper_funcs);\r\ndrm_encoder_init(dev, encoder, &virtio_gpu_enc_funcs,\r\nDRM_MODE_ENCODER_VIRTUAL);\r\ndrm_encoder_helper_add(encoder, &virtio_gpu_enc_helper_funcs);\r\nencoder->possible_crtcs = 1 << index;\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\ndrm_connector_register(connector);\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nvirtio_gpu_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj = NULL;\r\nstruct virtio_gpu_framebuffer *virtio_gpu_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, file_priv, mode_cmd->handles[0]);\r\nif (!obj)\r\nreturn ERR_PTR(-EINVAL);\r\nvirtio_gpu_fb = kzalloc(sizeof(*virtio_gpu_fb), GFP_KERNEL);\r\nif (virtio_gpu_fb == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = virtio_gpu_framebuffer_init(dev, virtio_gpu_fb, mode_cmd, obj);\r\nif (ret) {\r\nkfree(virtio_gpu_fb);\r\nif (obj)\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn NULL;\r\n}\r\nreturn &virtio_gpu_fb->base;\r\n}\r\nint virtio_gpu_modeset_init(struct virtio_gpu_device *vgdev)\r\n{\r\nint i;\r\ndrm_mode_config_init(vgdev->ddev);\r\nvgdev->ddev->mode_config.funcs = (void *)&virtio_gpu_mode_funcs;\r\nvgdev->ddev->mode_config.min_width = XRES_MIN;\r\nvgdev->ddev->mode_config.min_height = YRES_MIN;\r\nvgdev->ddev->mode_config.max_width = XRES_MAX;\r\nvgdev->ddev->mode_config.max_height = YRES_MAX;\r\nfor (i = 0 ; i < vgdev->num_scanouts; ++i)\r\nvgdev_output_init(vgdev, i);\r\ndrm_mode_config_reset(vgdev->ddev);\r\nreturn 0;\r\n}\r\nvoid virtio_gpu_modeset_fini(struct virtio_gpu_device *vgdev)\r\n{\r\nvirtio_gpu_fbdev_fini(vgdev);\r\ndrm_mode_config_cleanup(vgdev->ddev);\r\n}
