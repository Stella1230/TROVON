void sb_mixer_set_stereo(sb_devc * devc, int mode)\r\n{\r\nsb_chgmixer(devc, OUT_FILTER, STEREO_DAC, (mode ? STEREO_DAC : MONO_DAC));\r\n}\r\nstatic int detect_mixer(sb_devc * devc)\r\n{\r\nreturn 1;\r\n}\r\nstatic void oss_change_bits(sb_devc *devc, unsigned char *regval, int dev, int chn, int newval)\r\n{\r\nunsigned char mask;\r\nint shift;\r\nmask = (1 << (*devc->iomap)[dev][chn].nbits) - 1;\r\nnewval = (int) ((newval * mask) + 50) / 100;\r\nshift = (*devc->iomap)[dev][chn].bitoffs - (*devc->iomap)[dev][LEFT_CHN].nbits + 1;\r\n*regval &= ~(mask << shift);\r\n*regval |= (newval & mask) << shift;\r\n}\r\nstatic int sb_mixer_get(sb_devc * devc, int dev)\r\n{\r\nif (!((1 << dev) & devc->supported_devices))\r\nreturn -EINVAL;\r\nreturn devc->levels[dev];\r\n}\r\nvoid smw_mixer_init(sb_devc * devc)\r\n{\r\nint i;\r\nsb_setmixer(devc, 0x00, 0x18);\r\nsb_setmixer(devc, 0x10, 0x38);\r\ndevc->supported_devices = 0;\r\nfor (i = 0; i < sizeof(smw_mix_regs); i++)\r\nif (smw_mix_regs[i] != 0)\r\ndevc->supported_devices |= (1 << i);\r\ndevc->supported_rec_devices = devc->supported_devices &\r\n~(SOUND_MASK_BASS | SOUND_MASK_TREBLE | SOUND_MASK_PCM | SOUND_MASK_VOLUME);\r\nsb_mixer_reset(devc);\r\n}\r\nint sb_common_mixer_set(sb_devc * devc, int dev, int left, int right)\r\n{\r\nint regoffs;\r\nunsigned char val;\r\nif ((dev < 0) || (dev >= devc->iomap_sz))\r\nreturn -EINVAL;\r\nregoffs = (*devc->iomap)[dev][LEFT_CHN].regno;\r\nif (regoffs == 0)\r\nreturn -EINVAL;\r\nval = sb_getmixer(devc, regoffs);\r\noss_change_bits(devc, &val, dev, LEFT_CHN, left);\r\nif ((*devc->iomap)[dev][RIGHT_CHN].regno != regoffs)\r\n{\r\nsb_setmixer(devc, regoffs, val);\r\nregoffs = (*devc->iomap)[dev][RIGHT_CHN].regno;\r\nif (regoffs == 0)\r\nreturn left | (left << 8);\r\nval = sb_getmixer(devc, regoffs);\r\n}\r\noss_change_bits(devc, &val, dev, RIGHT_CHN, right);\r\nsb_setmixer(devc, regoffs, val);\r\nreturn left | (right << 8);\r\n}\r\nstatic int smw_mixer_set(sb_devc * devc, int dev, int left, int right)\r\n{\r\nint reg, val;\r\nswitch (dev)\r\n{\r\ncase SOUND_MIXER_VOLUME:\r\nsb_setmixer(devc, 0x0b, 96 - (96 * left / 100));\r\nsb_setmixer(devc, 0x0c, 96 - (96 * right / 100));\r\nbreak;\r\ncase SOUND_MIXER_BASS:\r\ncase SOUND_MIXER_TREBLE:\r\ndevc->levels[dev] = left | (right << 8);\r\nval = ((devc->levels[SOUND_MIXER_TREBLE] & 0xff) * 16 / (unsigned) 100) << 4;\r\nval |= ((devc->levels[SOUND_MIXER_BASS] & 0xff) * 16 / (unsigned) 100) & 0x0f;\r\nsb_setmixer(devc, 0x0d, val);\r\nval = (((devc->levels[SOUND_MIXER_TREBLE] >> 8) & 0xff) * 16 / (unsigned) 100) << 4;\r\nval |= (((devc->levels[SOUND_MIXER_BASS] >> 8) & 0xff) * 16 / (unsigned) 100) & 0x0f;\r\nsb_setmixer(devc, 0x0e, val);\r\nbreak;\r\ndefault:\r\nif (dev < 0 || dev >= ARRAY_SIZE(smw_mix_regs))\r\nreturn -EINVAL;\r\nreg = smw_mix_regs[dev];\r\nif (reg == 0)\r\nreturn -EINVAL;\r\nsb_setmixer(devc, reg, (24 - (24 * left / 100)) | 0x20);\r\nsb_setmixer(devc, reg + 1, (24 - (24 * right / 100)) | 0x40);\r\n}\r\ndevc->levels[dev] = left | (right << 8);\r\nreturn left | (right << 8);\r\n}\r\nstatic int sb_mixer_set(sb_devc * devc, int dev, int value)\r\n{\r\nint left = value & 0x000000ff;\r\nint right = (value & 0x0000ff00) >> 8;\r\nint retval;\r\nif (left > 100)\r\nleft = 100;\r\nif (right > 100)\r\nright = 100;\r\nif ((dev < 0) || (dev > 31))\r\nreturn -EINVAL;\r\nif (!(devc->supported_devices & (1 << dev)))\r\nreturn -EINVAL;\r\nswitch (devc->model) {\r\ncase MDL_SMW:\r\nretval = smw_mixer_set(devc, dev, left, right);\r\nbreak;\r\ncase MDL_ESS:\r\nretval = ess_mixer_set(devc, dev, left, right);\r\nbreak;\r\ndefault:\r\nretval = sb_common_mixer_set(devc, dev, left, right);\r\n}\r\nif (retval >= 0) devc->levels[dev] = retval;\r\nreturn retval;\r\n}\r\nstatic void set_recsrc(sb_devc * devc, int src)\r\n{\r\nsb_setmixer(devc, RECORD_SRC, (sb_getmixer(devc, RECORD_SRC) & ~7) | (src & 0x7));\r\n}\r\nstatic int set_recmask(sb_devc * devc, int mask)\r\n{\r\nint devmask, i;\r\nunsigned char regimageL, regimageR;\r\ndevmask = mask & devc->supported_rec_devices;\r\nswitch (devc->model)\r\n{\r\ncase MDL_SBPRO:\r\ncase MDL_ESS:\r\ncase MDL_JAZZ:\r\ncase MDL_SMW:\r\nif (devc->model == MDL_ESS && ess_set_recmask (devc, &devmask)) {\r\nbreak;\r\n}\r\nif (devmask != SOUND_MASK_MIC &&\r\ndevmask != SOUND_MASK_LINE &&\r\ndevmask != SOUND_MASK_CD)\r\n{\r\ndevmask &= ~devc->recmask;\r\n}\r\nif (devmask != SOUND_MASK_MIC &&\r\ndevmask != SOUND_MASK_LINE &&\r\ndevmask != SOUND_MASK_CD)\r\n{\r\ndevmask = SOUND_MASK_MIC;\r\n}\r\nif (devmask ^ devc->recmask)\r\n{\r\nswitch (devmask)\r\n{\r\ncase SOUND_MASK_MIC:\r\nset_recsrc(devc, SRC__MIC);\r\nbreak;\r\ncase SOUND_MASK_LINE:\r\nset_recsrc(devc, SRC__LINE);\r\nbreak;\r\ncase SOUND_MASK_CD:\r\nset_recsrc(devc, SRC__CD);\r\nbreak;\r\ndefault:\r\nset_recsrc(devc, SRC__MIC);\r\n}\r\n}\r\nbreak;\r\ncase MDL_SB16:\r\nif (!devmask)\r\ndevmask = SOUND_MASK_MIC;\r\nif (devc->submodel == SUBMDL_ALS007)\r\n{\r\nswitch (devmask)\r\n{\r\ncase SOUND_MASK_LINE:\r\nsb_setmixer(devc, ALS007_RECORD_SRC, ALS007_LINE);\r\nbreak;\r\ncase SOUND_MASK_CD:\r\nsb_setmixer(devc, ALS007_RECORD_SRC, ALS007_CD);\r\nbreak;\r\ncase SOUND_MASK_SYNTH:\r\nsb_setmixer(devc, ALS007_RECORD_SRC, ALS007_SYNTH);\r\nbreak;\r\ndefault:\r\nsb_setmixer(devc, ALS007_RECORD_SRC, ALS007_MIC);\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nregimageL = regimageR = 0;\r\nfor (i = 0; i < SOUND_MIXER_NRDEVICES; i++)\r\n{\r\nif ((1 << i) & devmask)\r\n{\r\nregimageL |= sb16_recmasks_L[i];\r\nregimageR |= sb16_recmasks_R[i];\r\n}\r\nsb_setmixer (devc, SB16_IMASK_L, regimageL);\r\nsb_setmixer (devc, SB16_IMASK_R, regimageR);\r\n}\r\n}\r\nbreak;\r\n}\r\ndevc->recmask = devmask;\r\nreturn devc->recmask;\r\n}\r\nstatic int set_outmask(sb_devc * devc, int mask)\r\n{\r\nint devmask, i;\r\nunsigned char regimage;\r\ndevmask = mask & devc->supported_out_devices;\r\nswitch (devc->model)\r\n{\r\ncase MDL_SB16:\r\nif (devc->submodel == SUBMDL_ALS007)\r\nbreak;\r\nelse\r\n{\r\nregimage = 0;\r\nfor (i = 0; i < SOUND_MIXER_NRDEVICES; i++)\r\n{\r\nif ((1 << i) & devmask)\r\n{\r\nregimage |= (sb16_recmasks_L[i] | sb16_recmasks_R[i]);\r\n}\r\nsb_setmixer (devc, SB16_OMASK, regimage);\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndevc->outmask = devmask;\r\nreturn devc->outmask;\r\n}\r\nstatic int sb_mixer_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nsb_devc *devc = mixer_devs[dev]->devc;\r\nint val, ret;\r\nint __user *p = arg;\r\nif (devc->model == MDL_SB16) {\r\nif (cmd == SOUND_MIXER_AGC)\r\n{\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nsb_setmixer(devc, 0x43, (~val) & 0x01);\r\nreturn 0;\r\n}\r\nif (cmd == SOUND_MIXER_3DSE)\r\n{\r\nif (devc->minor < 15)\r\nreturn -EINVAL;\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val == 0 || val == 1)\r\nsb_chgmixer(devc, AWE_3DSE, 0x01, val);\r\nelse if (val == 2)\r\n{\r\nret = sb_getmixer(devc, AWE_3DSE)&0x01;\r\nreturn put_user(ret, p);\r\n}\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\n}\r\nif (((cmd >> 8) & 0xff) == 'M')\r\n{\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE)\r\n{\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nswitch (cmd & 0xff)\r\n{\r\ncase SOUND_MIXER_RECSRC:\r\nret = set_recmask(devc, val);\r\nbreak;\r\ncase SOUND_MIXER_OUTSRC:\r\nret = set_outmask(devc, val);\r\nbreak;\r\ndefault:\r\nret = sb_mixer_set(devc, cmd & 0xff, val);\r\n}\r\n}\r\nelse switch (cmd & 0xff)\r\n{\r\ncase SOUND_MIXER_RECSRC:\r\nret = devc->recmask;\r\nbreak;\r\ncase SOUND_MIXER_OUTSRC:\r\nret = devc->outmask;\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nret = devc->supported_devices;\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nret = devc->supported_devices;\r\nif (devc->model == MDL_ESS)\r\nret &= ~(SOUND_MASK_SPEAKER|SOUND_MASK_IMIX);\r\nelse if (devc->model != MDL_JAZZ && devc->model != MDL_SMW)\r\nret &= ~(SOUND_MASK_MIC | SOUND_MASK_SPEAKER | SOUND_MASK_IMIX);\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nret = devc->supported_rec_devices;\r\nbreak;\r\ncase SOUND_MIXER_OUTMASK:\r\nret = devc->supported_out_devices;\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nret = devc->mixer_caps;\r\nbreak;\r\ndefault:\r\nret = sb_mixer_get(devc, cmd & 0xff);\r\nbreak;\r\n}\r\nreturn put_user(ret, p);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic void sb_mixer_reset(sb_devc * devc)\r\n{\r\nchar name[32];\r\nint i;\r\nsprintf(name, "SB_%d", devc->sbmixnum);\r\nif (devc->sbmo.sm_games)\r\ndevc->levels = load_mixer_volumes(name, smg_default_levels, 1);\r\nelse\r\ndevc->levels = load_mixer_volumes(name, sb_default_levels, 1);\r\nfor (i = 0; i < SOUND_MIXER_NRDEVICES; i++)\r\nsb_mixer_set(devc, i, devc->levels[i]);\r\nif (devc->model != MDL_ESS || !ess_mixer_reset (devc)) {\r\nset_recmask(devc, SOUND_MASK_MIC);\r\n}\r\n}\r\nint sb_mixer_init(sb_devc * devc, struct module *owner)\r\n{\r\nint mixer_type = 0;\r\nint m;\r\ndevc->sbmixnum = sbmixnum++;\r\ndevc->levels = NULL;\r\nsb_setmixer(devc, 0x00, 0);\r\nif (!(mixer_type = detect_mixer(devc)))\r\nreturn 0;\r\nswitch (devc->model)\r\n{\r\ncase MDL_ESSPCI:\r\ncase MDL_YMPCI:\r\ncase MDL_SBPRO:\r\ncase MDL_AZTECH:\r\ncase MDL_JAZZ:\r\ndevc->mixer_caps = SOUND_CAP_EXCL_INPUT;\r\ndevc->supported_devices = SBPRO_MIXER_DEVICES;\r\ndevc->supported_rec_devices = SBPRO_RECORDING_DEVICES;\r\ndevc->iomap = &sbpro_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(sbpro_mix);\r\nbreak;\r\ncase MDL_ESS:\r\ness_mixer_init (devc);\r\nbreak;\r\ncase MDL_SMW:\r\ndevc->mixer_caps = SOUND_CAP_EXCL_INPUT;\r\ndevc->supported_devices = 0;\r\ndevc->supported_rec_devices = 0;\r\ndevc->iomap = &sbpro_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(sbpro_mix);\r\nsmw_mixer_init(devc);\r\nbreak;\r\ncase MDL_SB16:\r\ndevc->mixer_caps = 0;\r\ndevc->supported_rec_devices = SB16_RECORDING_DEVICES;\r\ndevc->supported_out_devices = SB16_OUTFILTER_DEVICES;\r\nif (devc->submodel != SUBMDL_ALS007)\r\n{\r\ndevc->supported_devices = SB16_MIXER_DEVICES;\r\ndevc->iomap = &sb16_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(sb16_mix);\r\n}\r\nelse\r\n{\r\ndevc->supported_devices = ALS007_MIXER_DEVICES;\r\ndevc->iomap = &als007_mix;\r\ndevc->iomap_sz = ARRAY_SIZE(als007_mix);\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "sb_mixer: Unsupported mixer type %d\n", devc->model);\r\nreturn 0;\r\n}\r\nm = sound_alloc_mixerdev();\r\nif (m == -1)\r\nreturn 0;\r\nmixer_devs[m] = kmalloc(sizeof(struct mixer_operations), GFP_KERNEL);\r\nif (mixer_devs[m] == NULL)\r\n{\r\nprintk(KERN_ERR "sb_mixer: Can't allocate memory\n");\r\nsound_unload_mixerdev(m);\r\nreturn 0;\r\n}\r\nif (devc->submodel != SUBMDL_ALS007)\r\nmemcpy ((char *) mixer_devs[m], (char *) &sb_mixer_operations, sizeof (struct mixer_operations));\r\nelse\r\nmemcpy ((char *) mixer_devs[m], (char *) &als007_mixer_operations, sizeof (struct mixer_operations));\r\nmixer_devs[m]->devc = devc;\r\nif (owner)\r\nmixer_devs[m]->owner = owner;\r\ndevc->my_mixerdev = m;\r\nsb_mixer_reset(devc);\r\nreturn 1;\r\n}\r\nvoid sb_mixer_unload(sb_devc *devc)\r\n{\r\nif (devc->my_mixerdev == -1)\r\nreturn;\r\nkfree(mixer_devs[devc->my_mixerdev]);\r\nsound_unload_mixerdev(devc->my_mixerdev);\r\nsbmixnum--;\r\n}
