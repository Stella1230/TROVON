static int f2fs_inode_has_encryption_context(struct inode *inode)\r\n{\r\nint res = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\r\nF2FS_XATTR_NAME_ENCRYPTION_CONTEXT, NULL, 0, NULL);\r\nreturn (res > 0);\r\n}\r\nstatic int f2fs_is_encryption_context_consistent_with_policy(\r\nstruct inode *inode, const struct f2fs_encryption_policy *policy)\r\n{\r\nstruct f2fs_encryption_context ctx;\r\nint res = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\r\nF2FS_XATTR_NAME_ENCRYPTION_CONTEXT, &ctx,\r\nsizeof(ctx), NULL);\r\nif (res != sizeof(ctx))\r\nreturn 0;\r\nreturn (memcmp(ctx.master_key_descriptor, policy->master_key_descriptor,\r\nF2FS_KEY_DESCRIPTOR_SIZE) == 0 &&\r\n(ctx.flags == policy->flags) &&\r\n(ctx.contents_encryption_mode ==\r\npolicy->contents_encryption_mode) &&\r\n(ctx.filenames_encryption_mode ==\r\npolicy->filenames_encryption_mode));\r\n}\r\nstatic int f2fs_create_encryption_context_from_policy(\r\nstruct inode *inode, const struct f2fs_encryption_policy *policy)\r\n{\r\nstruct f2fs_encryption_context ctx;\r\nctx.format = F2FS_ENCRYPTION_CONTEXT_FORMAT_V1;\r\nmemcpy(ctx.master_key_descriptor, policy->master_key_descriptor,\r\nF2FS_KEY_DESCRIPTOR_SIZE);\r\nif (!f2fs_valid_contents_enc_mode(policy->contents_encryption_mode)) {\r\nprintk(KERN_WARNING\r\n"%s: Invalid contents encryption mode %d\n", __func__,\r\npolicy->contents_encryption_mode);\r\nreturn -EINVAL;\r\n}\r\nif (!f2fs_valid_filenames_enc_mode(policy->filenames_encryption_mode)) {\r\nprintk(KERN_WARNING\r\n"%s: Invalid filenames encryption mode %d\n", __func__,\r\npolicy->filenames_encryption_mode);\r\nreturn -EINVAL;\r\n}\r\nif (policy->flags & ~F2FS_POLICY_FLAGS_VALID)\r\nreturn -EINVAL;\r\nctx.contents_encryption_mode = policy->contents_encryption_mode;\r\nctx.filenames_encryption_mode = policy->filenames_encryption_mode;\r\nctx.flags = policy->flags;\r\nBUILD_BUG_ON(sizeof(ctx.nonce) != F2FS_KEY_DERIVATION_NONCE_SIZE);\r\nget_random_bytes(ctx.nonce, F2FS_KEY_DERIVATION_NONCE_SIZE);\r\nreturn f2fs_setxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\r\nF2FS_XATTR_NAME_ENCRYPTION_CONTEXT, &ctx,\r\nsizeof(ctx), NULL, XATTR_CREATE);\r\n}\r\nint f2fs_process_policy(const struct f2fs_encryption_policy *policy,\r\nstruct inode *inode)\r\n{\r\nif (policy->version != 0)\r\nreturn -EINVAL;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn -EINVAL;\r\nif (!f2fs_inode_has_encryption_context(inode)) {\r\nif (!f2fs_empty_dir(inode))\r\nreturn -ENOTEMPTY;\r\nreturn f2fs_create_encryption_context_from_policy(inode,\r\npolicy);\r\n}\r\nif (f2fs_is_encryption_context_consistent_with_policy(inode, policy))\r\nreturn 0;\r\nprintk(KERN_WARNING "%s: Policy inconsistent with encryption context\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nint f2fs_get_policy(struct inode *inode, struct f2fs_encryption_policy *policy)\r\n{\r\nstruct f2fs_encryption_context ctx;\r\nint res;\r\nif (!f2fs_encrypted_inode(inode))\r\nreturn -ENODATA;\r\nres = f2fs_getxattr(inode, F2FS_XATTR_INDEX_ENCRYPTION,\r\nF2FS_XATTR_NAME_ENCRYPTION_CONTEXT,\r\n&ctx, sizeof(ctx), NULL);\r\nif (res != sizeof(ctx))\r\nreturn -ENODATA;\r\nif (ctx.format != F2FS_ENCRYPTION_CONTEXT_FORMAT_V1)\r\nreturn -EINVAL;\r\npolicy->version = 0;\r\npolicy->contents_encryption_mode = ctx.contents_encryption_mode;\r\npolicy->filenames_encryption_mode = ctx.filenames_encryption_mode;\r\npolicy->flags = ctx.flags;\r\nmemcpy(&policy->master_key_descriptor, ctx.master_key_descriptor,\r\nF2FS_KEY_DESCRIPTOR_SIZE);\r\nreturn 0;\r\n}\r\nint f2fs_is_child_context_consistent_with_parent(struct inode *parent,\r\nstruct inode *child)\r\n{\r\nstruct f2fs_crypt_info *parent_ci, *child_ci;\r\nint res;\r\nif ((parent == NULL) || (child == NULL)) {\r\npr_err("parent %p child %p\n", parent, child);\r\nBUG_ON(1);\r\n}\r\nif (!f2fs_encrypted_inode(parent))\r\nreturn 1;\r\nif (!f2fs_encrypted_inode(child))\r\nreturn 0;\r\nres = f2fs_get_encryption_info(parent);\r\nif (res)\r\nreturn 0;\r\nres = f2fs_get_encryption_info(child);\r\nif (res)\r\nreturn 0;\r\nparent_ci = F2FS_I(parent)->i_crypt_info;\r\nchild_ci = F2FS_I(child)->i_crypt_info;\r\nif (!parent_ci && !child_ci)\r\nreturn 1;\r\nif (!parent_ci || !child_ci)\r\nreturn 0;\r\nreturn (memcmp(parent_ci->ci_master_key,\r\nchild_ci->ci_master_key,\r\nF2FS_KEY_DESCRIPTOR_SIZE) == 0 &&\r\n(parent_ci->ci_data_mode == child_ci->ci_data_mode) &&\r\n(parent_ci->ci_filename_mode == child_ci->ci_filename_mode) &&\r\n(parent_ci->ci_flags == child_ci->ci_flags));\r\n}\r\nint f2fs_inherit_context(struct inode *parent, struct inode *child,\r\nstruct page *ipage)\r\n{\r\nstruct f2fs_encryption_context ctx;\r\nstruct f2fs_crypt_info *ci;\r\nint res;\r\nres = f2fs_get_encryption_info(parent);\r\nif (res < 0)\r\nreturn res;\r\nci = F2FS_I(parent)->i_crypt_info;\r\nBUG_ON(ci == NULL);\r\nctx.format = F2FS_ENCRYPTION_CONTEXT_FORMAT_V1;\r\nctx.contents_encryption_mode = ci->ci_data_mode;\r\nctx.filenames_encryption_mode = ci->ci_filename_mode;\r\nctx.flags = ci->ci_flags;\r\nmemcpy(ctx.master_key_descriptor, ci->ci_master_key,\r\nF2FS_KEY_DESCRIPTOR_SIZE);\r\nget_random_bytes(ctx.nonce, F2FS_KEY_DERIVATION_NONCE_SIZE);\r\nreturn f2fs_setxattr(child, F2FS_XATTR_INDEX_ENCRYPTION,\r\nF2FS_XATTR_NAME_ENCRYPTION_CONTEXT, &ctx,\r\nsizeof(ctx), ipage, XATTR_CREATE);\r\n}
