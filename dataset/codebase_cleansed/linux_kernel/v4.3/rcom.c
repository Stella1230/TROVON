static int rcom_response(struct dlm_ls *ls)\r\n{\r\nreturn test_bit(LSFL_RCOM_READY, &ls->ls_flags);\r\n}\r\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\r\nstruct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nchar *mb;\r\nint mb_len = sizeof(struct dlm_rcom) + len;\r\nmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\r\nif (!mh) {\r\nlog_print("create_rcom to %d type %d len %d ENOBUFS",\r\nto_nodeid, type, len);\r\nreturn -ENOBUFS;\r\n}\r\nmemset(mb, 0, mb_len);\r\nrc = (struct dlm_rcom *) mb;\r\nrc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\r\nrc->rc_header.h_lockspace = ls->ls_global_id;\r\nrc->rc_header.h_nodeid = dlm_our_nodeid();\r\nrc->rc_header.h_length = mb_len;\r\nrc->rc_header.h_cmd = DLM_RCOM;\r\nrc->rc_type = type;\r\nspin_lock(&ls->ls_recover_lock);\r\nrc->rc_seq = ls->ls_recover_seq;\r\nspin_unlock(&ls->ls_recover_lock);\r\n*mh_ret = mh;\r\n*rc_ret = rc;\r\nreturn 0;\r\n}\r\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\r\nstruct dlm_rcom *rc)\r\n{\r\ndlm_rcom_out(rc);\r\ndlm_lowcomms_commit_buffer(mh);\r\n}\r\nstatic void set_rcom_status(struct dlm_ls *ls, struct rcom_status *rs,\r\nuint32_t flags)\r\n{\r\nrs->rs_flags = cpu_to_le32(flags);\r\n}\r\nstatic void set_rcom_config(struct dlm_ls *ls, struct rcom_config *rf,\r\nuint32_t num_slots)\r\n{\r\nrf->rf_lvblen = cpu_to_le32(ls->ls_lvblen);\r\nrf->rf_lsflags = cpu_to_le32(ls->ls_exflags);\r\nrf->rf_our_slot = cpu_to_le16(ls->ls_slot);\r\nrf->rf_num_slots = cpu_to_le16(num_slots);\r\nrf->rf_generation = cpu_to_le32(ls->ls_generation);\r\n}\r\nstatic int check_rcom_config(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\r\n{\r\nstruct rcom_config *rf = (struct rcom_config *) rc->rc_buf;\r\nif ((rc->rc_header.h_version & 0xFFFF0000) != DLM_HEADER_MAJOR) {\r\nlog_error(ls, "version mismatch: %x nodeid %d: %x",\r\nDLM_HEADER_MAJOR | DLM_HEADER_MINOR, nodeid,\r\nrc->rc_header.h_version);\r\nreturn -EPROTO;\r\n}\r\nif (le32_to_cpu(rf->rf_lvblen) != ls->ls_lvblen ||\r\nle32_to_cpu(rf->rf_lsflags) != ls->ls_exflags) {\r\nlog_error(ls, "config mismatch: %d,%x nodeid %d: %d,%x",\r\nls->ls_lvblen, ls->ls_exflags, nodeid,\r\nle32_to_cpu(rf->rf_lvblen),\r\nle32_to_cpu(rf->rf_lsflags));\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\r\n{\r\nspin_lock(&ls->ls_rcom_spin);\r\n*new_seq = ++ls->ls_rcom_seq;\r\nset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\r\nspin_unlock(&ls->ls_rcom_spin);\r\n}\r\nstatic void disallow_sync_reply(struct dlm_ls *ls)\r\n{\r\nspin_lock(&ls->ls_rcom_spin);\r\nclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\r\nclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\r\nspin_unlock(&ls->ls_rcom_spin);\r\n}\r\nint dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nint error = 0;\r\nls->ls_recover_nodeid = nodeid;\r\nif (nodeid == dlm_our_nodeid()) {\r\nrc = ls->ls_recover_buf;\r\nrc->rc_result = dlm_recover_status(ls);\r\ngoto out;\r\n}\r\nerror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\r\nsizeof(struct rcom_status), &rc, &mh);\r\nif (error)\r\ngoto out;\r\nset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\r\nallow_sync_reply(ls, &rc->rc_id);\r\nmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\r\nsend_rcom(ls, mh, rc);\r\nerror = dlm_wait_function(ls, &rcom_response);\r\ndisallow_sync_reply(ls);\r\nif (error)\r\ngoto out;\r\nrc = ls->ls_recover_buf;\r\nif (rc->rc_result == -ESRCH) {\r\nlog_debug(ls, "remote node %d not ready", nodeid);\r\nrc->rc_result = 0;\r\nerror = 0;\r\n} else {\r\nerror = check_rcom_config(ls, rc, nodeid);\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic void receive_rcom_status(struct dlm_ls *ls, struct dlm_rcom *rc_in)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nstruct rcom_status *rs;\r\nuint32_t status;\r\nint nodeid = rc_in->rc_header.h_nodeid;\r\nint len = sizeof(struct rcom_config);\r\nint num_slots = 0;\r\nint error;\r\nif (!dlm_slots_version(&rc_in->rc_header)) {\r\nstatus = dlm_recover_status(ls);\r\ngoto do_create;\r\n}\r\nrs = (struct rcom_status *)rc_in->rc_buf;\r\nif (!(le32_to_cpu(rs->rs_flags) & DLM_RSF_NEED_SLOTS)) {\r\nstatus = dlm_recover_status(ls);\r\ngoto do_create;\r\n}\r\nspin_lock(&ls->ls_recover_lock);\r\nstatus = ls->ls_recover_status;\r\nnum_slots = ls->ls_num_slots;\r\nspin_unlock(&ls->ls_recover_lock);\r\nlen += num_slots * sizeof(struct rcom_slot);\r\ndo_create:\r\nerror = create_rcom(ls, nodeid, DLM_RCOM_STATUS_REPLY,\r\nlen, &rc, &mh);\r\nif (error)\r\nreturn;\r\nrc->rc_id = rc_in->rc_id;\r\nrc->rc_seq_reply = rc_in->rc_seq;\r\nrc->rc_result = status;\r\nset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, num_slots);\r\nif (!num_slots)\r\ngoto do_send;\r\nspin_lock(&ls->ls_recover_lock);\r\nif (ls->ls_num_slots != num_slots) {\r\nspin_unlock(&ls->ls_recover_lock);\r\nlog_debug(ls, "receive_rcom_status num_slots %d to %d",\r\nnum_slots, ls->ls_num_slots);\r\nrc->rc_result = 0;\r\nset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, 0);\r\ngoto do_send;\r\n}\r\ndlm_slots_copy_out(ls, rc);\r\nspin_unlock(&ls->ls_recover_lock);\r\ndo_send:\r\nsend_rcom(ls, mh, rc);\r\n}\r\nstatic void receive_sync_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\r\n{\r\nspin_lock(&ls->ls_rcom_spin);\r\nif (!test_bit(LSFL_RCOM_WAIT, &ls->ls_flags) ||\r\nrc_in->rc_id != ls->ls_rcom_seq) {\r\nlog_debug(ls, "reject reply %d from %d seq %llx expect %llx",\r\nrc_in->rc_type, rc_in->rc_header.h_nodeid,\r\n(unsigned long long)rc_in->rc_id,\r\n(unsigned long long)ls->ls_rcom_seq);\r\ngoto out;\r\n}\r\nmemcpy(ls->ls_recover_buf, rc_in, rc_in->rc_header.h_length);\r\nset_bit(LSFL_RCOM_READY, &ls->ls_flags);\r\nclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\r\nwake_up(&ls->ls_wait_general);\r\nout:\r\nspin_unlock(&ls->ls_rcom_spin);\r\n}\r\nint dlm_rcom_names(struct dlm_ls *ls, int nodeid, char *last_name, int last_len)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nint error = 0;\r\nls->ls_recover_nodeid = nodeid;\r\nerror = create_rcom(ls, nodeid, DLM_RCOM_NAMES, last_len, &rc, &mh);\r\nif (error)\r\ngoto out;\r\nmemcpy(rc->rc_buf, last_name, last_len);\r\nallow_sync_reply(ls, &rc->rc_id);\r\nmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\r\nsend_rcom(ls, mh, rc);\r\nerror = dlm_wait_function(ls, &rcom_response);\r\ndisallow_sync_reply(ls);\r\nout:\r\nreturn error;\r\n}\r\nstatic void receive_rcom_names(struct dlm_ls *ls, struct dlm_rcom *rc_in)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nint error, inlen, outlen, nodeid;\r\nnodeid = rc_in->rc_header.h_nodeid;\r\ninlen = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\r\noutlen = dlm_config.ci_buffer_size - sizeof(struct dlm_rcom);\r\nerror = create_rcom(ls, nodeid, DLM_RCOM_NAMES_REPLY, outlen, &rc, &mh);\r\nif (error)\r\nreturn;\r\nrc->rc_id = rc_in->rc_id;\r\nrc->rc_seq_reply = rc_in->rc_seq;\r\ndlm_copy_master_names(ls, rc_in->rc_buf, inlen, rc->rc_buf, outlen,\r\nnodeid);\r\nsend_rcom(ls, mh, rc);\r\n}\r\nint dlm_send_rcom_lookup(struct dlm_rsb *r, int dir_nodeid)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nstruct dlm_ls *ls = r->res_ls;\r\nint error;\r\nerror = create_rcom(ls, dir_nodeid, DLM_RCOM_LOOKUP, r->res_length,\r\n&rc, &mh);\r\nif (error)\r\ngoto out;\r\nmemcpy(rc->rc_buf, r->res_name, r->res_length);\r\nrc->rc_id = (unsigned long) r->res_id;\r\nsend_rcom(ls, mh, rc);\r\nout:\r\nreturn error;\r\n}\r\nint dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nstruct dlm_ls *ls = r->res_ls;\r\nint error;\r\nerror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\r\n&rc, &mh);\r\nif (error)\r\ngoto out;\r\nmemcpy(rc->rc_buf, r->res_name, r->res_length);\r\nrc->rc_id = 0xFFFFFFFF;\r\nsend_rcom(ls, mh, rc);\r\nout:\r\nreturn error;\r\n}\r\nstatic void receive_rcom_lookup(struct dlm_ls *ls, struct dlm_rcom *rc_in)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nint error, ret_nodeid, nodeid = rc_in->rc_header.h_nodeid;\r\nint len = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\r\nerror = create_rcom(ls, nodeid, DLM_RCOM_LOOKUP_REPLY, 0, &rc, &mh);\r\nif (error)\r\nreturn;\r\nif (rc_in->rc_id == 0xFFFFFFFF) {\r\nlog_error(ls, "receive_rcom_lookup dump from %d", nodeid);\r\ndlm_dump_rsb_name(ls, rc_in->rc_buf, len);\r\nreturn;\r\n}\r\nerror = dlm_master_lookup(ls, nodeid, rc_in->rc_buf, len,\r\nDLM_LU_RECOVER_MASTER, &ret_nodeid, NULL);\r\nif (error)\r\nret_nodeid = error;\r\nrc->rc_result = ret_nodeid;\r\nrc->rc_id = rc_in->rc_id;\r\nrc->rc_seq_reply = rc_in->rc_seq;\r\nsend_rcom(ls, mh, rc);\r\n}\r\nstatic void receive_rcom_lookup_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\r\n{\r\ndlm_recover_master_reply(ls, rc_in);\r\n}\r\nstatic void pack_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb,\r\nstruct rcom_lock *rl)\r\n{\r\nmemset(rl, 0, sizeof(*rl));\r\nrl->rl_ownpid = cpu_to_le32(lkb->lkb_ownpid);\r\nrl->rl_lkid = cpu_to_le32(lkb->lkb_id);\r\nrl->rl_exflags = cpu_to_le32(lkb->lkb_exflags);\r\nrl->rl_flags = cpu_to_le32(lkb->lkb_flags);\r\nrl->rl_lvbseq = cpu_to_le32(lkb->lkb_lvbseq);\r\nrl->rl_rqmode = lkb->lkb_rqmode;\r\nrl->rl_grmode = lkb->lkb_grmode;\r\nrl->rl_status = lkb->lkb_status;\r\nrl->rl_wait_type = cpu_to_le16(lkb->lkb_wait_type);\r\nif (lkb->lkb_bastfn)\r\nrl->rl_asts |= DLM_CB_BAST;\r\nif (lkb->lkb_astfn)\r\nrl->rl_asts |= DLM_CB_CAST;\r\nrl->rl_namelen = cpu_to_le16(r->res_length);\r\nmemcpy(rl->rl_name, r->res_name, r->res_length);\r\nif (lkb->lkb_lvbptr)\r\nmemcpy(rl->rl_lvb, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\r\n}\r\nint dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\r\n{\r\nstruct dlm_ls *ls = r->res_ls;\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nstruct rcom_lock *rl;\r\nint error, len = sizeof(struct rcom_lock);\r\nif (lkb->lkb_lvbptr)\r\nlen += ls->ls_lvblen;\r\nerror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\r\nif (error)\r\ngoto out;\r\nrl = (struct rcom_lock *) rc->rc_buf;\r\npack_rcom_lock(r, lkb, rl);\r\nrc->rc_id = (unsigned long) r;\r\nsend_rcom(ls, mh, rc);\r\nout:\r\nreturn error;\r\n}\r\nstatic void receive_rcom_lock(struct dlm_ls *ls, struct dlm_rcom *rc_in)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct dlm_mhandle *mh;\r\nint error, nodeid = rc_in->rc_header.h_nodeid;\r\ndlm_recover_master_copy(ls, rc_in);\r\nerror = create_rcom(ls, nodeid, DLM_RCOM_LOCK_REPLY,\r\nsizeof(struct rcom_lock), &rc, &mh);\r\nif (error)\r\nreturn;\r\nmemcpy(rc->rc_buf, rc_in->rc_buf, sizeof(struct rcom_lock));\r\nrc->rc_id = rc_in->rc_id;\r\nrc->rc_seq_reply = rc_in->rc_seq;\r\nsend_rcom(ls, mh, rc);\r\n}\r\nint dlm_send_ls_not_ready(int nodeid, struct dlm_rcom *rc_in)\r\n{\r\nstruct dlm_rcom *rc;\r\nstruct rcom_config *rf;\r\nstruct dlm_mhandle *mh;\r\nchar *mb;\r\nint mb_len = sizeof(struct dlm_rcom) + sizeof(struct rcom_config);\r\nmh = dlm_lowcomms_get_buffer(nodeid, mb_len, GFP_NOFS, &mb);\r\nif (!mh)\r\nreturn -ENOBUFS;\r\nmemset(mb, 0, mb_len);\r\nrc = (struct dlm_rcom *) mb;\r\nrc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\r\nrc->rc_header.h_lockspace = rc_in->rc_header.h_lockspace;\r\nrc->rc_header.h_nodeid = dlm_our_nodeid();\r\nrc->rc_header.h_length = mb_len;\r\nrc->rc_header.h_cmd = DLM_RCOM;\r\nrc->rc_type = DLM_RCOM_STATUS_REPLY;\r\nrc->rc_id = rc_in->rc_id;\r\nrc->rc_seq_reply = rc_in->rc_seq;\r\nrc->rc_result = -ESRCH;\r\nrf = (struct rcom_config *) rc->rc_buf;\r\nrf->rf_lvblen = cpu_to_le32(~0U);\r\ndlm_rcom_out(rc);\r\ndlm_lowcomms_commit_buffer(mh);\r\nreturn 0;\r\n}\r\nvoid dlm_receive_rcom(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\r\n{\r\nint lock_size = sizeof(struct dlm_rcom) + sizeof(struct rcom_lock);\r\nint stop, reply = 0, names = 0, lookup = 0, lock = 0;\r\nuint32_t status;\r\nuint64_t seq;\r\nswitch (rc->rc_type) {\r\ncase DLM_RCOM_STATUS_REPLY:\r\nreply = 1;\r\nbreak;\r\ncase DLM_RCOM_NAMES:\r\nnames = 1;\r\nbreak;\r\ncase DLM_RCOM_NAMES_REPLY:\r\nnames = 1;\r\nreply = 1;\r\nbreak;\r\ncase DLM_RCOM_LOOKUP:\r\nlookup = 1;\r\nbreak;\r\ncase DLM_RCOM_LOOKUP_REPLY:\r\nlookup = 1;\r\nreply = 1;\r\nbreak;\r\ncase DLM_RCOM_LOCK:\r\nlock = 1;\r\nbreak;\r\ncase DLM_RCOM_LOCK_REPLY:\r\nlock = 1;\r\nreply = 1;\r\nbreak;\r\n};\r\nspin_lock(&ls->ls_recover_lock);\r\nstatus = ls->ls_recover_status;\r\nstop = test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\r\nseq = ls->ls_recover_seq;\r\nspin_unlock(&ls->ls_recover_lock);\r\nif (stop && (rc->rc_type != DLM_RCOM_STATUS))\r\ngoto ignore;\r\nif (reply && (rc->rc_seq_reply != seq))\r\ngoto ignore;\r\nif (!(status & DLM_RS_NODES) && (names || lookup || lock))\r\ngoto ignore;\r\nif (!(status & DLM_RS_DIR) && (lookup || lock))\r\ngoto ignore;\r\nswitch (rc->rc_type) {\r\ncase DLM_RCOM_STATUS:\r\nreceive_rcom_status(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_NAMES:\r\nreceive_rcom_names(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_LOOKUP:\r\nreceive_rcom_lookup(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_LOCK:\r\nif (rc->rc_header.h_length < lock_size)\r\ngoto Eshort;\r\nreceive_rcom_lock(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_STATUS_REPLY:\r\nreceive_sync_reply(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_NAMES_REPLY:\r\nreceive_sync_reply(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_LOOKUP_REPLY:\r\nreceive_rcom_lookup_reply(ls, rc);\r\nbreak;\r\ncase DLM_RCOM_LOCK_REPLY:\r\nif (rc->rc_header.h_length < lock_size)\r\ngoto Eshort;\r\ndlm_recover_process_copy(ls, rc);\r\nbreak;\r\ndefault:\r\nlog_error(ls, "receive_rcom bad type %d", rc->rc_type);\r\n}\r\nreturn;\r\nignore:\r\nlog_limit(ls, "dlm_receive_rcom ignore msg %d "\r\n"from %d %llu %llu recover seq %llu sts %x gen %u",\r\nrc->rc_type,\r\nnodeid,\r\n(unsigned long long)rc->rc_seq,\r\n(unsigned long long)rc->rc_seq_reply,\r\n(unsigned long long)seq,\r\nstatus, ls->ls_generation);\r\nreturn;\r\nEshort:\r\nlog_error(ls, "recovery message %d from %d is too short",\r\nrc->rc_type, nodeid);\r\n}
