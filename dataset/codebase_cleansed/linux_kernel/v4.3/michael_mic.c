static inline u32 xswap(u32 val)\r\n{\r\nreturn ((val & 0x00ff00ff) << 8) | ((val & 0xff00ff00) >> 8);\r\n}\r\nstatic int michael_init(struct shash_desc *desc)\r\n{\r\nstruct michael_mic_desc_ctx *mctx = shash_desc_ctx(desc);\r\nstruct michael_mic_ctx *ctx = crypto_shash_ctx(desc->tfm);\r\nmctx->pending_len = 0;\r\nmctx->l = ctx->l;\r\nmctx->r = ctx->r;\r\nreturn 0;\r\n}\r\nstatic int michael_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct michael_mic_desc_ctx *mctx = shash_desc_ctx(desc);\r\nconst __le32 *src;\r\nif (mctx->pending_len) {\r\nint flen = 4 - mctx->pending_len;\r\nif (flen > len)\r\nflen = len;\r\nmemcpy(&mctx->pending[mctx->pending_len], data, flen);\r\nmctx->pending_len += flen;\r\ndata += flen;\r\nlen -= flen;\r\nif (mctx->pending_len < 4)\r\nreturn 0;\r\nsrc = (const __le32 *)mctx->pending;\r\nmctx->l ^= le32_to_cpup(src);\r\nmichael_block(mctx->l, mctx->r);\r\nmctx->pending_len = 0;\r\n}\r\nsrc = (const __le32 *)data;\r\nwhile (len >= 4) {\r\nmctx->l ^= le32_to_cpup(src++);\r\nmichael_block(mctx->l, mctx->r);\r\nlen -= 4;\r\n}\r\nif (len > 0) {\r\nmctx->pending_len = len;\r\nmemcpy(mctx->pending, src, len);\r\n}\r\nreturn 0;\r\n}\r\nstatic int michael_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct michael_mic_desc_ctx *mctx = shash_desc_ctx(desc);\r\nu8 *data = mctx->pending;\r\n__le32 *dst = (__le32 *)out;\r\nswitch (mctx->pending_len) {\r\ncase 0:\r\nmctx->l ^= 0x5a;\r\nbreak;\r\ncase 1:\r\nmctx->l ^= data[0] | 0x5a00;\r\nbreak;\r\ncase 2:\r\nmctx->l ^= data[0] | (data[1] << 8) | 0x5a0000;\r\nbreak;\r\ncase 3:\r\nmctx->l ^= data[0] | (data[1] << 8) | (data[2] << 16) |\r\n0x5a000000;\r\nbreak;\r\n}\r\nmichael_block(mctx->l, mctx->r);\r\nmichael_block(mctx->l, mctx->r);\r\ndst[0] = cpu_to_le32(mctx->l);\r\ndst[1] = cpu_to_le32(mctx->r);\r\nreturn 0;\r\n}\r\nstatic int michael_setkey(struct crypto_shash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct michael_mic_ctx *mctx = crypto_shash_ctx(tfm);\r\nconst __le32 *data = (const __le32 *)key;\r\nif (keylen != 8) {\r\ncrypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nmctx->l = le32_to_cpu(data[0]);\r\nmctx->r = le32_to_cpu(data[1]);\r\nreturn 0;\r\n}\r\nstatic int __init michael_mic_init(void)\r\n{\r\nreturn crypto_register_shash(&alg);\r\n}\r\nstatic void __exit michael_mic_exit(void)\r\n{\r\ncrypto_unregister_shash(&alg);\r\n}
