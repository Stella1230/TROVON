int ide_setting_ioctl(ide_drive_t *drive, struct block_device *bdev,\r\nunsigned int cmd, unsigned long arg,\r\nconst struct ide_ioctl_devset *s)\r\n{\r\nconst struct ide_devset *ds;\r\nint err = -EOPNOTSUPP;\r\nfor (; (ds = s->setting); s++) {\r\nif (ds->get && s->get_ioctl == cmd)\r\ngoto read_val;\r\nelse if (ds->set && s->set_ioctl == cmd)\r\ngoto set_val;\r\n}\r\nreturn err;\r\nread_val:\r\nmutex_lock(&ide_setting_mtx);\r\nerr = ds->get(drive);\r\nmutex_unlock(&ide_setting_mtx);\r\nreturn err >= 0 ? put_user(err, (long __user *)arg) : err;\r\nset_val:\r\nif (bdev != bdev->bd_contains)\r\nerr = -EINVAL;\r\nelse {\r\nif (!capable(CAP_SYS_ADMIN))\r\nerr = -EACCES;\r\nelse {\r\nmutex_lock(&ide_setting_mtx);\r\nerr = ide_devset_execute(drive, ds, arg);\r\nmutex_unlock(&ide_setting_mtx);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int ide_get_identity_ioctl(ide_drive_t *drive, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nu16 *id = NULL;\r\nint size = (cmd == HDIO_GET_IDENTITY) ? (ATA_ID_WORDS * 2) : 142;\r\nint rc = 0;\r\nif ((drive->dev_flags & IDE_DFLAG_ID_READ) == 0) {\r\nrc = -ENOMSG;\r\ngoto out;\r\n}\r\nid = kmalloc(ATA_ID_WORDS * 2, GFP_KERNEL);\r\nif (id == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(id, drive->id, size);\r\nata_id_to_hd_driveid(id);\r\nif (copy_to_user((void __user *)arg, id, size))\r\nrc = -EFAULT;\r\nkfree(id);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int ide_get_nice_ioctl(ide_drive_t *drive, unsigned long arg)\r\n{\r\nreturn put_user((!!(drive->dev_flags & IDE_DFLAG_DSC_OVERLAP)\r\n<< IDE_NICE_DSC_OVERLAP) |\r\n(!!(drive->dev_flags & IDE_DFLAG_NICE1)\r\n<< IDE_NICE_1), (long __user *)arg);\r\n}\r\nstatic int ide_set_nice_ioctl(ide_drive_t *drive, unsigned long arg)\r\n{\r\nif (arg != (arg & ((1 << IDE_NICE_DSC_OVERLAP) | (1 << IDE_NICE_1))))\r\nreturn -EPERM;\r\nif (((arg >> IDE_NICE_DSC_OVERLAP) & 1) &&\r\n(drive->media != ide_tape))\r\nreturn -EPERM;\r\nif ((arg >> IDE_NICE_DSC_OVERLAP) & 1)\r\ndrive->dev_flags |= IDE_DFLAG_DSC_OVERLAP;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_DSC_OVERLAP;\r\nif ((arg >> IDE_NICE_1) & 1)\r\ndrive->dev_flags |= IDE_DFLAG_NICE1;\r\nelse\r\ndrive->dev_flags &= ~IDE_DFLAG_NICE1;\r\nreturn 0;\r\n}\r\nstatic int ide_cmd_ioctl(ide_drive_t *drive, unsigned long arg)\r\n{\r\nu8 *buf = NULL;\r\nint bufsize = 0, err = 0;\r\nu8 args[4], xfer_rate = 0;\r\nstruct ide_cmd cmd;\r\nstruct ide_taskfile *tf = &cmd.tf;\r\nif (NULL == (void *) arg) {\r\nstruct request *rq;\r\nrq = blk_get_request(drive->queue, READ, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_ATA_TASKFILE;\r\nerr = blk_execute_rq(drive->queue, NULL, rq, 0);\r\nblk_put_request(rq);\r\nreturn err;\r\n}\r\nif (copy_from_user(args, (void __user *)arg, 4))\r\nreturn -EFAULT;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ntf->feature = args[2];\r\nif (args[0] == ATA_CMD_SMART) {\r\ntf->nsect = args[3];\r\ntf->lbal = args[1];\r\ntf->lbam = ATA_SMART_LBAM_PASS;\r\ntf->lbah = ATA_SMART_LBAH_PASS;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF;\r\ncmd.valid.in.tf = IDE_VALID_NSECT;\r\n} else {\r\ntf->nsect = args[1];\r\ncmd.valid.out.tf = IDE_VALID_FEATURE | IDE_VALID_NSECT;\r\ncmd.valid.in.tf = IDE_VALID_NSECT;\r\n}\r\ntf->command = args[0];\r\ncmd.protocol = args[3] ? ATA_PROT_PIO : ATA_PROT_NODATA;\r\nif (args[3]) {\r\ncmd.tf_flags |= IDE_TFLAG_IO_16BIT;\r\nbufsize = SECTOR_SIZE * args[3];\r\nbuf = kzalloc(bufsize, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (tf->command == ATA_CMD_SET_FEATURES &&\r\ntf->feature == SETFEATURES_XFER &&\r\ntf->nsect >= XFER_SW_DMA_0) {\r\nxfer_rate = ide_find_dma_mode(drive, tf->nsect);\r\nif (xfer_rate != tf->nsect) {\r\nerr = -EINVAL;\r\ngoto abort;\r\n}\r\ncmd.tf_flags |= IDE_TFLAG_SET_XFER;\r\n}\r\nerr = ide_raw_taskfile(drive, &cmd, buf, args[3]);\r\nargs[0] = tf->status;\r\nargs[1] = tf->error;\r\nargs[2] = tf->nsect;\r\nabort:\r\nif (copy_to_user((void __user *)arg, &args, 4))\r\nerr = -EFAULT;\r\nif (buf) {\r\nif (copy_to_user((void __user *)(arg + 4), buf, bufsize))\r\nerr = -EFAULT;\r\nkfree(buf);\r\n}\r\nreturn err;\r\n}\r\nstatic int ide_task_ioctl(ide_drive_t *drive, unsigned long arg)\r\n{\r\nvoid __user *p = (void __user *)arg;\r\nint err = 0;\r\nu8 args[7];\r\nstruct ide_cmd cmd;\r\nif (copy_from_user(args, p, 7))\r\nreturn -EFAULT;\r\nmemset(&cmd, 0, sizeof(cmd));\r\nmemcpy(&cmd.tf.feature, &args[1], 6);\r\ncmd.tf.command = args[0];\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nerr = ide_no_data_taskfile(drive, &cmd);\r\nargs[0] = cmd.tf.command;\r\nmemcpy(&args[1], &cmd.tf.feature, 6);\r\nif (copy_to_user(p, args, 7))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int generic_drive_reset(ide_drive_t *drive)\r\n{\r\nstruct request *rq;\r\nint ret = 0;\r\nrq = blk_get_request(drive->queue, READ, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_DRV_PRIV;\r\nrq->cmd_len = 1;\r\nrq->cmd[0] = REQ_DRIVE_RESET;\r\nif (blk_execute_rq(drive->queue, NULL, rq, 1))\r\nret = rq->errors;\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nint generic_ide_ioctl(ide_drive_t *drive, struct block_device *bdev,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint err;\r\nerr = ide_setting_ioctl(drive, bdev, cmd, arg, ide_ioctl_settings);\r\nif (err != -EOPNOTSUPP)\r\nreturn err;\r\nswitch (cmd) {\r\ncase HDIO_OBSOLETE_IDENTITY:\r\ncase HDIO_GET_IDENTITY:\r\nif (bdev != bdev->bd_contains)\r\nreturn -EINVAL;\r\nreturn ide_get_identity_ioctl(drive, cmd, arg);\r\ncase HDIO_GET_NICE:\r\nreturn ide_get_nice_ioctl(drive, arg);\r\ncase HDIO_SET_NICE:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn ide_set_nice_ioctl(drive, arg);\r\n#ifdef CONFIG_IDE_TASK_IOCTL\r\ncase HDIO_DRIVE_TASKFILE:\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nif (drive->media == ide_disk)\r\nreturn ide_taskfile_ioctl(drive, arg);\r\nreturn -ENOMSG;\r\n#endif\r\ncase HDIO_DRIVE_CMD:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn ide_cmd_ioctl(drive, arg);\r\ncase HDIO_DRIVE_TASK:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn ide_task_ioctl(drive, arg);\r\ncase HDIO_DRIVE_RESET:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn generic_drive_reset(drive);\r\ncase HDIO_GET_BUSSTATE:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (put_user(BUSSTATE_ON, (long __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase HDIO_SET_BUSSTATE:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}
