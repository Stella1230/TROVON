static struct cpio_data __init find_ucode_in_initrd(void)\r\n{\r\nlong offset = 0;\r\nchar *path;\r\nvoid *start;\r\nsize_t size;\r\n#ifdef CONFIG_X86_32\r\nstruct boot_params *p;\r\np = (struct boot_params *)__pa_nodebug(&boot_params);\r\npath = (char *)__pa_nodebug(ucode_path);\r\nstart = (void *)p->hdr.ramdisk_image;\r\nsize = p->hdr.ramdisk_size;\r\n#else\r\npath = ucode_path;\r\nstart = (void *)(boot_params.hdr.ramdisk_image + PAGE_OFFSET);\r\nsize = boot_params.hdr.ramdisk_size;\r\n#endif\r\nreturn find_cpio_data(path, start, size, &offset);\r\n}\r\nstatic size_t compute_container_size(u8 *data, u32 total_size)\r\n{\r\nsize_t size = 0;\r\nu32 *header = (u32 *)data;\r\nif (header[0] != UCODE_MAGIC ||\r\nheader[1] != UCODE_EQUIV_CPU_TABLE_TYPE ||\r\nheader[2] == 0)\r\nreturn size;\r\nsize = header[2] + CONTAINER_HDR_SZ;\r\ntotal_size -= size;\r\ndata += size;\r\nwhile (total_size) {\r\nu16 patch_size;\r\nheader = (u32 *)data;\r\nif (header[0] != UCODE_UCODE_TYPE)\r\nbreak;\r\npatch_size = header[1];\r\nif (patch_size > PATCH_MAX_SIZE)\r\nbreak;\r\nsize += patch_size + SECTION_HDR_SIZE;\r\ndata += patch_size + SECTION_HDR_SIZE;\r\ntotal_size -= patch_size + SECTION_HDR_SIZE;\r\n}\r\nreturn size;\r\n}\r\nstatic void apply_ucode_in_initrd(void *ucode, size_t size, bool save_patch)\r\n{\r\nstruct equiv_cpu_entry *eq;\r\nsize_t *cont_sz;\r\nu32 *header;\r\nu8 *data, **cont;\r\nu8 (*patch)[PATCH_MAX_SIZE];\r\nu16 eq_id = 0;\r\nint offset, left;\r\nu32 rev, eax, ebx, ecx, edx;\r\nu32 *new_rev;\r\n#ifdef CONFIG_X86_32\r\nnew_rev = (u32 *)__pa_nodebug(&ucode_new_rev);\r\ncont_sz = (size_t *)__pa_nodebug(&container_size);\r\ncont = (u8 **)__pa_nodebug(&container);\r\npatch = (u8 (*)[PATCH_MAX_SIZE])__pa_nodebug(&amd_ucode_patch);\r\n#else\r\nnew_rev = &ucode_new_rev;\r\ncont_sz = &container_size;\r\ncont = &container;\r\npatch = &amd_ucode_patch;\r\n#endif\r\ndata = ucode;\r\nleft = size;\r\nheader = (u32 *)data;\r\nif (header[0] != UCODE_MAGIC ||\r\nheader[1] != UCODE_EQUIV_CPU_TABLE_TYPE ||\r\nheader[2] == 0)\r\nreturn;\r\neax = 0x00000001;\r\necx = 0;\r\nnative_cpuid(&eax, &ebx, &ecx, &edx);\r\nwhile (left > 0) {\r\neq = (struct equiv_cpu_entry *)(data + CONTAINER_HDR_SZ);\r\n*cont = data;\r\noffset = header[2] + CONTAINER_HDR_SZ;\r\ndata += offset;\r\nleft -= offset;\r\neq_id = find_equiv_id(eq, eax);\r\nif (eq_id) {\r\nthis_equiv_id = eq_id;\r\n*cont_sz = compute_container_size(*cont, left + offset);\r\nleft = *cont_sz - offset;\r\nbreak;\r\n}\r\nwhile (left > 0) {\r\nheader = (u32 *)data;\r\nif (header[0] == UCODE_MAGIC &&\r\nheader[1] == UCODE_EQUIV_CPU_TABLE_TYPE)\r\nbreak;\r\noffset = header[1] + SECTION_HDR_SIZE;\r\ndata += offset;\r\nleft -= offset;\r\n}\r\noffset = data - (u8 *)ucode;\r\nucode = data;\r\n}\r\nif (!eq_id) {\r\n*cont = NULL;\r\n*cont_sz = 0;\r\nreturn;\r\n}\r\nnative_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);\r\nwhile (left > 0) {\r\nstruct microcode_amd *mc;\r\nheader = (u32 *)data;\r\nif (header[0] != UCODE_UCODE_TYPE ||\r\nheader[1] == 0)\r\nbreak;\r\nmc = (struct microcode_amd *)(data + SECTION_HDR_SIZE);\r\nif (eq_id == mc->hdr.processor_rev_id && rev < mc->hdr.patch_id) {\r\nif (!__apply_microcode_amd(mc)) {\r\nrev = mc->hdr.patch_id;\r\n*new_rev = rev;\r\nif (save_patch)\r\nmemcpy(patch, mc,\r\nmin_t(u32, header[1], PATCH_MAX_SIZE));\r\n}\r\n}\r\noffset = header[1] + SECTION_HDR_SIZE;\r\ndata += offset;\r\nleft -= offset;\r\n}\r\n}\r\nstatic bool __init load_builtin_amd_microcode(struct cpio_data *cp,\r\nunsigned int family)\r\n{\r\n#ifdef CONFIG_X86_64\r\nchar fw_name[36] = "amd-ucode/microcode_amd.bin";\r\nif (family >= 0x15)\r\nsnprintf(fw_name, sizeof(fw_name),\r\n"amd-ucode/microcode_amd_fam%.2xh.bin", family);\r\nreturn get_builtin_firmware(cp, fw_name);\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nvoid __init load_ucode_amd_bsp(unsigned int family)\r\n{\r\nstruct cpio_data cp;\r\nvoid **data;\r\nsize_t *size;\r\n#ifdef CONFIG_X86_32\r\ndata = (void **)__pa_nodebug(&ucode_cpio.data);\r\nsize = (size_t *)__pa_nodebug(&ucode_cpio.size);\r\n#else\r\ndata = &ucode_cpio.data;\r\nsize = &ucode_cpio.size;\r\n#endif\r\ncp = find_ucode_in_initrd();\r\nif (!cp.data) {\r\nif (!load_builtin_amd_microcode(&cp, family))\r\nreturn;\r\n}\r\n*data = cp.data;\r\n*size = cp.size;\r\napply_ucode_in_initrd(cp.data, cp.size, true);\r\n}\r\nvoid load_ucode_amd_ap(void)\r\n{\r\nstruct microcode_amd *mc;\r\nsize_t *usize;\r\nvoid **ucode;\r\nmc = (struct microcode_amd *)__pa_nodebug(amd_ucode_patch);\r\nif (mc->hdr.patch_id && mc->hdr.processor_rev_id) {\r\n__apply_microcode_amd(mc);\r\nreturn;\r\n}\r\nucode = (void *)__pa_nodebug(&container);\r\nusize = (size_t *)__pa_nodebug(&container_size);\r\nif (!*ucode || !*usize)\r\nreturn;\r\napply_ucode_in_initrd(*ucode, *usize, false);\r\n}\r\nstatic void __init collect_cpu_sig_on_bsp(void *arg)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nuci->cpu_sig.sig = cpuid_eax(0x00000001);\r\n}\r\nstatic void __init get_bsp_sig(void)\r\n{\r\nunsigned int bsp = boot_cpu_data.cpu_index;\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + bsp;\r\nif (!uci->cpu_sig.sig)\r\nsmp_call_function_single(bsp, collect_cpu_sig_on_bsp, NULL, 1);\r\n}\r\nvoid load_ucode_amd_ap(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nstruct equiv_cpu_entry *eq;\r\nstruct microcode_amd *mc;\r\nu32 rev, eax;\r\nu16 eq_id;\r\nif (!cpu)\r\nreturn;\r\nif (!container)\r\nreturn;\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);\r\nuci->cpu_sig.rev = rev;\r\nuci->cpu_sig.sig = eax;\r\neax = cpuid_eax(0x00000001);\r\neq = (struct equiv_cpu_entry *)(container + CONTAINER_HDR_SZ);\r\neq_id = find_equiv_id(eq, eax);\r\nif (!eq_id)\r\nreturn;\r\nif (eq_id == this_equiv_id) {\r\nmc = (struct microcode_amd *)amd_ucode_patch;\r\nif (mc && rev < mc->hdr.patch_id) {\r\nif (!__apply_microcode_amd(mc))\r\nucode_new_rev = mc->hdr.patch_id;\r\n}\r\n} else {\r\nif (!ucode_cpio.data)\r\nreturn;\r\napply_ucode_in_initrd(ucode_cpio.data, ucode_cpio.size, false);\r\n}\r\n}\r\nint __init save_microcode_in_initrd_amd(void)\r\n{\r\nunsigned long cont;\r\nint retval = 0;\r\nenum ucode_state ret;\r\nu8 *cont_va;\r\nu32 eax;\r\nif (!container)\r\nreturn -EINVAL;\r\n#ifdef CONFIG_X86_32\r\nget_bsp_sig();\r\ncont = (unsigned long)container;\r\ncont_va = __va(container);\r\n#else\r\ncont = __pa(container);\r\ncont_va = container;\r\n#endif\r\nif (relocated_ramdisk)\r\ncontainer = (u8 *)(__va(relocated_ramdisk) +\r\n(cont - boot_params.hdr.ramdisk_image));\r\nelse\r\ncontainer = cont_va;\r\nif (ucode_new_rev)\r\npr_info("microcode: updated early to new patch_level=0x%08x\n",\r\nucode_new_rev);\r\neax = cpuid_eax(0x00000001);\r\neax = ((eax >> 8) & 0xf) + ((eax >> 20) & 0xff);\r\nret = load_microcode_amd(smp_processor_id(), eax, container, container_size);\r\nif (ret != UCODE_OK)\r\nretval = -EINVAL;\r\ncontainer = NULL;\r\ncontainer_size = 0;\r\nreturn retval;\r\n}\r\nvoid reload_ucode_amd(void)\r\n{\r\nstruct microcode_amd *mc;\r\nu32 rev, eax;\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);\r\nmc = (struct microcode_amd *)amd_ucode_patch;\r\nif (mc && rev < mc->hdr.patch_id) {\r\nif (!__apply_microcode_amd(mc)) {\r\nucode_new_rev = mc->hdr.patch_id;\r\npr_info("microcode: reload patch_level=0x%08x\n",\r\nucode_new_rev);\r\n}\r\n}\r\n}
