static int gssp_rpc_create(struct net *net, struct rpc_clnt **_clnt)\r\n{\r\nstatic const struct sockaddr_un gssp_localaddr = {\r\n.sun_family = AF_LOCAL,\r\n.sun_path = GSSPROXY_SOCK_PATHNAME,\r\n};\r\nstruct rpc_create_args args = {\r\n.net = net,\r\n.protocol = XPRT_TRANSPORT_LOCAL,\r\n.address = (struct sockaddr *)&gssp_localaddr,\r\n.addrsize = sizeof(gssp_localaddr),\r\n.servername = "localhost",\r\n.program = &gssp_program,\r\n.version = GSSPROXY_VERS_1,\r\n.authflavor = RPC_AUTH_NULL,\r\n.flags = RPC_CLNT_CREATE_NOPING |\r\nRPC_CLNT_CREATE_NO_IDLE_TIMEOUT\r\n};\r\nstruct rpc_clnt *clnt;\r\nint result = 0;\r\nclnt = rpc_create(&args);\r\nif (IS_ERR(clnt)) {\r\ndprintk("RPC: failed to create AF_LOCAL gssproxy "\r\n"client (errno %ld).\n", PTR_ERR(clnt));\r\nresult = PTR_ERR(clnt);\r\n*_clnt = NULL;\r\ngoto out;\r\n}\r\ndprintk("RPC: created new gssp local client (gssp_local_clnt: "\r\n"%p)\n", clnt);\r\n*_clnt = clnt;\r\nout:\r\nreturn result;\r\n}\r\nvoid init_gssp_clnt(struct sunrpc_net *sn)\r\n{\r\nmutex_init(&sn->gssp_lock);\r\nsn->gssp_clnt = NULL;\r\n}\r\nint set_gssp_clnt(struct net *net)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct rpc_clnt *clnt;\r\nint ret;\r\nmutex_lock(&sn->gssp_lock);\r\nret = gssp_rpc_create(net, &clnt);\r\nif (!ret) {\r\nif (sn->gssp_clnt)\r\nrpc_shutdown_client(sn->gssp_clnt);\r\nsn->gssp_clnt = clnt;\r\n}\r\nmutex_unlock(&sn->gssp_lock);\r\nreturn ret;\r\n}\r\nvoid clear_gssp_clnt(struct sunrpc_net *sn)\r\n{\r\nmutex_lock(&sn->gssp_lock);\r\nif (sn->gssp_clnt) {\r\nrpc_shutdown_client(sn->gssp_clnt);\r\nsn->gssp_clnt = NULL;\r\n}\r\nmutex_unlock(&sn->gssp_lock);\r\n}\r\nstatic struct rpc_clnt *get_gssp_clnt(struct sunrpc_net *sn)\r\n{\r\nstruct rpc_clnt *clnt;\r\nmutex_lock(&sn->gssp_lock);\r\nclnt = sn->gssp_clnt;\r\nif (clnt)\r\natomic_inc(&clnt->cl_count);\r\nmutex_unlock(&sn->gssp_lock);\r\nreturn clnt;\r\n}\r\nstatic int gssp_call(struct net *net, struct rpc_message *msg)\r\n{\r\nstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\r\nstruct rpc_clnt *clnt;\r\nint status;\r\nclnt = get_gssp_clnt(sn);\r\nif (!clnt)\r\nreturn -EIO;\r\nstatus = rpc_call_sync(clnt, msg, 0);\r\nif (status < 0) {\r\ndprintk("gssp: rpc_call returned error %d\n", -status);\r\nswitch (status) {\r\ncase -EPROTONOSUPPORT:\r\nstatus = -EINVAL;\r\nbreak;\r\ncase -ECONNREFUSED:\r\ncase -ETIMEDOUT:\r\ncase -ENOTCONN:\r\nstatus = -EAGAIN;\r\nbreak;\r\ncase -ERESTARTSYS:\r\nif (signalled ())\r\nstatus = -EINTR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nrpc_release_client(clnt);\r\nreturn status;\r\n}\r\nstatic void gssp_free_receive_pages(struct gssx_arg_accept_sec_context *arg)\r\n{\r\nint i;\r\nfor (i = 0; i < arg->npages && arg->pages[i]; i++)\r\n__free_page(arg->pages[i]);\r\nkfree(arg->pages);\r\n}\r\nstatic int gssp_alloc_receive_pages(struct gssx_arg_accept_sec_context *arg)\r\n{\r\narg->npages = DIV_ROUND_UP(NGROUPS_MAX * 4, PAGE_SIZE);\r\narg->pages = kzalloc(arg->npages * sizeof(struct page *), GFP_KERNEL);\r\nif (!arg->pages)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint gssp_accept_sec_context_upcall(struct net *net,\r\nstruct gssp_upcall_data *data)\r\n{\r\nstruct gssx_ctx ctxh = {\r\n.state = data->in_handle\r\n};\r\nstruct gssx_arg_accept_sec_context arg = {\r\n.input_token = data->in_token,\r\n};\r\nstruct gssx_ctx rctxh = {\r\n.exported_context_token.len = GSSX_max_output_handle_sz,\r\n.mech.len = GSS_OID_MAX_LEN,\r\n.src_name.display_name.len = GSSX_max_princ_sz\r\n};\r\nstruct gssx_res_accept_sec_context res = {\r\n.context_handle = &rctxh,\r\n.output_token = &data->out_token\r\n};\r\nstruct rpc_message msg = {\r\n.rpc_proc = &gssp_procedures[GSSX_ACCEPT_SEC_CONTEXT],\r\n.rpc_argp = &arg,\r\n.rpc_resp = &res,\r\n.rpc_cred = NULL,\r\n};\r\nstruct xdr_netobj client_name = { 0 , NULL };\r\nint ret;\r\nif (data->in_handle.len != 0)\r\narg.context_handle = &ctxh;\r\nres.output_token->len = GSSX_max_output_token_sz;\r\nret = gssp_alloc_receive_pages(&arg);\r\nif (ret)\r\nreturn ret;\r\nret = gssp_call(net, &msg);\r\ngssp_free_receive_pages(&arg);\r\ndata->major_status = res.status.major_status;\r\ndata->minor_status = res.status.minor_status;\r\nif (res.context_handle) {\r\ndata->out_handle = rctxh.exported_context_token;\r\ndata->mech_oid.len = rctxh.mech.len;\r\nif (rctxh.mech.data)\r\nmemcpy(data->mech_oid.data, rctxh.mech.data,\r\ndata->mech_oid.len);\r\nclient_name = rctxh.src_name.display_name;\r\n}\r\nif (res.options.count == 1) {\r\ngssx_buffer *value = &res.options.data[0].value;\r\nif (value->len == 1) {\r\ndata->creds = *(struct svc_cred *)value->data;\r\ndata->found_creds = 1;\r\n}\r\nkfree(value->data);\r\n}\r\nif (res.options.count != 0) {\r\nkfree(res.options.data);\r\n}\r\nif (data->found_creds && client_name.data != NULL) {\r\nchar *c;\r\ndata->creds.cr_principal = kstrndup(client_name.data,\r\nclient_name.len, GFP_KERNEL);\r\nif (data->creds.cr_principal) {\r\nc = strchr(data->creds.cr_principal, '@');\r\nif (c) {\r\n*c = '\0';\r\nc = strchr(data->creds.cr_principal, '/');\r\nif (c) *c = '@';\r\n}\r\nif (!c) {\r\nkfree(data->creds.cr_principal);\r\ndata->creds.cr_principal = NULL;\r\n}\r\n}\r\n}\r\nkfree(client_name.data);\r\nreturn ret;\r\n}\r\nvoid gssp_free_upcall_data(struct gssp_upcall_data *data)\r\n{\r\nkfree(data->in_handle.data);\r\nkfree(data->out_handle.data);\r\nkfree(data->out_token.data);\r\nfree_svc_cred(&data->creds);\r\n}
