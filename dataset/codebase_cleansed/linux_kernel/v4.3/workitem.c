static inline void\r\ncfs_wi_sched_lock(cfs_wi_sched_t *sched)\r\n{\r\nspin_lock(&sched->ws_lock);\r\n}\r\nstatic inline void\r\ncfs_wi_sched_unlock(cfs_wi_sched_t *sched)\r\n{\r\nspin_unlock(&sched->ws_lock);\r\n}\r\nstatic inline int\r\ncfs_wi_sched_cansleep(cfs_wi_sched_t *sched)\r\n{\r\ncfs_wi_sched_lock(sched);\r\nif (sched->ws_stopping) {\r\ncfs_wi_sched_unlock(sched);\r\nreturn 0;\r\n}\r\nif (!list_empty(&sched->ws_runq)) {\r\ncfs_wi_sched_unlock(sched);\r\nreturn 0;\r\n}\r\ncfs_wi_sched_unlock(sched);\r\nreturn 1;\r\n}\r\nvoid\r\ncfs_wi_exit(struct cfs_wi_sched *sched, cfs_workitem_t *wi)\r\n{\r\nLASSERT(!in_interrupt());\r\nLASSERT(!sched->ws_stopping);\r\ncfs_wi_sched_lock(sched);\r\nLASSERT(wi->wi_running);\r\nif (wi->wi_scheduled) {\r\nLASSERT(!list_empty(&wi->wi_list));\r\nlist_del_init(&wi->wi_list);\r\nLASSERT(sched->ws_nscheduled > 0);\r\nsched->ws_nscheduled--;\r\n}\r\nLASSERT(list_empty(&wi->wi_list));\r\nwi->wi_scheduled = 1;\r\ncfs_wi_sched_unlock(sched);\r\nreturn;\r\n}\r\nint\r\ncfs_wi_deschedule(struct cfs_wi_sched *sched, cfs_workitem_t *wi)\r\n{\r\nint rc;\r\nLASSERT(!in_interrupt());\r\nLASSERT(!sched->ws_stopping);\r\ncfs_wi_sched_lock(sched);\r\nrc = !(wi->wi_running);\r\nif (wi->wi_scheduled) {\r\nLASSERT(!list_empty(&wi->wi_list));\r\nlist_del_init(&wi->wi_list);\r\nLASSERT(sched->ws_nscheduled > 0);\r\nsched->ws_nscheduled--;\r\nwi->wi_scheduled = 0;\r\n}\r\nLASSERT (list_empty(&wi->wi_list));\r\ncfs_wi_sched_unlock(sched);\r\nreturn rc;\r\n}\r\nvoid\r\ncfs_wi_schedule(struct cfs_wi_sched *sched, cfs_workitem_t *wi)\r\n{\r\nLASSERT(!in_interrupt());\r\nLASSERT(!sched->ws_stopping);\r\ncfs_wi_sched_lock(sched);\r\nif (!wi->wi_scheduled) {\r\nLASSERT (list_empty(&wi->wi_list));\r\nwi->wi_scheduled = 1;\r\nsched->ws_nscheduled++;\r\nif (!wi->wi_running) {\r\nlist_add_tail(&wi->wi_list, &sched->ws_runq);\r\nwake_up(&sched->ws_waitq);\r\n} else {\r\nlist_add(&wi->wi_list, &sched->ws_rerunq);\r\n}\r\n}\r\nLASSERT (!list_empty(&wi->wi_list));\r\ncfs_wi_sched_unlock(sched);\r\nreturn;\r\n}\r\nstatic int\r\ncfs_wi_scheduler (void *arg)\r\n{\r\nstruct cfs_wi_sched *sched = (cfs_wi_sched_t *)arg;\r\ncfs_block_allsigs();\r\nif (sched->ws_cptab != NULL)\r\ncfs_cpt_bind(sched->ws_cptab, sched->ws_cpt);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nLASSERT(sched->ws_starting == 1);\r\nsched->ws_starting--;\r\nsched->ws_nthreads++;\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\ncfs_wi_sched_lock(sched);\r\nwhile (!sched->ws_stopping) {\r\nint nloops = 0;\r\nint rc;\r\ncfs_workitem_t *wi;\r\nwhile (!list_empty(&sched->ws_runq) &&\r\nnloops < CFS_WI_RESCHED) {\r\nwi = list_entry(sched->ws_runq.next,\r\ncfs_workitem_t, wi_list);\r\nLASSERT(wi->wi_scheduled && !wi->wi_running);\r\nlist_del_init(&wi->wi_list);\r\nLASSERT(sched->ws_nscheduled > 0);\r\nsched->ws_nscheduled--;\r\nwi->wi_running = 1;\r\nwi->wi_scheduled = 0;\r\ncfs_wi_sched_unlock(sched);\r\nnloops++;\r\nrc = (*wi->wi_action) (wi);\r\ncfs_wi_sched_lock(sched);\r\nif (rc != 0)\r\ncontinue;\r\nwi->wi_running = 0;\r\nif (list_empty(&wi->wi_list))\r\ncontinue;\r\nLASSERT(wi->wi_scheduled);\r\nlist_move_tail(&wi->wi_list, &sched->ws_runq);\r\n}\r\nif (!list_empty(&sched->ws_runq)) {\r\ncfs_wi_sched_unlock(sched);\r\ncond_resched();\r\ncfs_wi_sched_lock(sched);\r\ncontinue;\r\n}\r\ncfs_wi_sched_unlock(sched);\r\nrc = wait_event_interruptible_exclusive(sched->ws_waitq,\r\n!cfs_wi_sched_cansleep(sched));\r\ncfs_wi_sched_lock(sched);\r\n}\r\ncfs_wi_sched_unlock(sched);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nsched->ws_nthreads--;\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nreturn 0;\r\n}\r\nvoid\r\ncfs_wi_sched_destroy(struct cfs_wi_sched *sched)\r\n{\r\nint i;\r\nLASSERT(cfs_wi_data.wi_init);\r\nLASSERT(!cfs_wi_data.wi_stopping);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nif (sched->ws_stopping) {\r\nCDEBUG(D_INFO, "%s is in progress of stopping\n",\r\nsched->ws_name);\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nreturn;\r\n}\r\nLASSERT(!list_empty(&sched->ws_list));\r\nsched->ws_stopping = 1;\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\ni = 2;\r\nwake_up_all(&sched->ws_waitq);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nwhile (sched->ws_nthreads > 0) {\r\nCDEBUG(IS_PO2(++i) ? D_WARNING : D_NET,\r\n"waiting for %d threads of WI sched[%s] to terminate\n",\r\nsched->ws_nthreads, sched->ws_name);\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1) / 20);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\n}\r\nlist_del(&sched->ws_list);\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nLASSERT(sched->ws_nscheduled == 0);\r\nLIBCFS_FREE(sched, sizeof(*sched));\r\n}\r\nint\r\ncfs_wi_sched_create(char *name, struct cfs_cpt_table *cptab,\r\nint cpt, int nthrs, struct cfs_wi_sched **sched_pp)\r\n{\r\nstruct cfs_wi_sched *sched;\r\nint rc;\r\nLASSERT(cfs_wi_data.wi_init);\r\nLASSERT(!cfs_wi_data.wi_stopping);\r\nLASSERT(cptab == NULL || cpt == CFS_CPT_ANY ||\r\n(cpt >= 0 && cpt < cfs_cpt_number(cptab)));\r\nLIBCFS_ALLOC(sched, sizeof(*sched));\r\nif (sched == NULL)\r\nreturn -ENOMEM;\r\nstrncpy(sched->ws_name, name, CFS_WS_NAME_LEN);\r\nsched->ws_name[CFS_WS_NAME_LEN - 1] = '\0';\r\nsched->ws_cptab = cptab;\r\nsched->ws_cpt = cpt;\r\nspin_lock_init(&sched->ws_lock);\r\ninit_waitqueue_head(&sched->ws_waitq);\r\nINIT_LIST_HEAD(&sched->ws_runq);\r\nINIT_LIST_HEAD(&sched->ws_rerunq);\r\nINIT_LIST_HEAD(&sched->ws_list);\r\nrc = 0;\r\nwhile (nthrs > 0) {\r\nchar name[16];\r\nstruct task_struct *task;\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nwhile (sched->ws_starting > 0) {\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nschedule();\r\nspin_lock(&cfs_wi_data.wi_glock);\r\n}\r\nsched->ws_starting++;\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nif (sched->ws_cptab != NULL && sched->ws_cpt >= 0) {\r\nsnprintf(name, sizeof(name), "%s_%02d_%02u",\r\nsched->ws_name, sched->ws_cpt,\r\nsched->ws_nthreads);\r\n} else {\r\nsnprintf(name, sizeof(name), "%s_%02u",\r\nsched->ws_name, sched->ws_nthreads);\r\n}\r\ntask = kthread_run(cfs_wi_scheduler, sched, "%s", name);\r\nif (!IS_ERR(task)) {\r\nnthrs--;\r\ncontinue;\r\n}\r\nrc = PTR_ERR(task);\r\nCERROR("Failed to create thread for WI scheduler %s: %d\n",\r\nname, rc);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nlist_add(&sched->ws_list, &cfs_wi_data.wi_scheds);\r\nsched->ws_starting--;\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\ncfs_wi_sched_destroy(sched);\r\nreturn rc;\r\n}\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nlist_add(&sched->ws_list, &cfs_wi_data.wi_scheds);\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\n*sched_pp = sched;\r\nreturn 0;\r\n}\r\nint\r\ncfs_wi_startup(void)\r\n{\r\nmemset(&cfs_wi_data, 0, sizeof(cfs_wi_data));\r\nspin_lock_init(&cfs_wi_data.wi_glock);\r\nINIT_LIST_HEAD(&cfs_wi_data.wi_scheds);\r\ncfs_wi_data.wi_init = 1;\r\nreturn 0;\r\n}\r\nvoid\r\ncfs_wi_shutdown(void)\r\n{\r\nstruct cfs_wi_sched *sched;\r\nspin_lock(&cfs_wi_data.wi_glock);\r\ncfs_wi_data.wi_stopping = 1;\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nlist_for_each_entry(sched, &cfs_wi_data.wi_scheds, ws_list) {\r\nsched->ws_stopping = 1;\r\nwake_up_all(&sched->ws_waitq);\r\n}\r\nlist_for_each_entry(sched, &cfs_wi_data.wi_scheds, ws_list) {\r\nspin_lock(&cfs_wi_data.wi_glock);\r\nwhile (sched->ws_nthreads != 0) {\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1) / 20);\r\nspin_lock(&cfs_wi_data.wi_glock);\r\n}\r\nspin_unlock(&cfs_wi_data.wi_glock);\r\n}\r\nwhile (!list_empty(&cfs_wi_data.wi_scheds)) {\r\nsched = list_entry(cfs_wi_data.wi_scheds.next,\r\nstruct cfs_wi_sched, ws_list);\r\nlist_del(&sched->ws_list);\r\nLIBCFS_FREE(sched, sizeof(*sched));\r\n}\r\ncfs_wi_data.wi_stopping = 0;\r\ncfs_wi_data.wi_init = 0;\r\n}
