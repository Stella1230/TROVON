void init_mlme_ap_info23a(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nspin_lock_init(&pmlmepriv->bcn_update_lock);\r\n_rtw_init_queue23a(&pacl_list->acl_node_q);\r\nstart_ap_mode23a(padapter);\r\n}\r\nvoid free_mlme_ap_info23a(struct rtw_adapter *padapter)\r\n{\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\npmlmepriv->update_bcn = false;\r\npmlmeext->bstart_bss = false;\r\nrtw_sta_flush23a(padapter);\r\npmlmeinfo->state = MSR_NOLINK;\r\nrtw_free_all_stainfo23a(padapter);\r\npsta = rtw_get_bcmc_stainfo23a(padapter);\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nrtw_free_stainfo23a(padapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\n}\r\nstatic void update_BCNTIM(struct rtw_adapter *padapter)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *pnetwork_mlmeext = &pmlmeinfo->network;\r\nunsigned char *pie = pnetwork_mlmeext->IEs;\r\nu8 *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;\r\nuint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;\r\np = rtw_get_ie23a(pie, WLAN_EID_TIM, &tim_ielen,\r\npnetwork_mlmeext->IELength);\r\nif (p != NULL && tim_ielen > 0) {\r\ntim_ielen += 2;\r\npremainder_ie = p+tim_ielen;\r\ntim_ie_offset = (int)(p - pie);\r\nremainder_ielen = pnetwork_mlmeext->IELength - tim_ie_offset - tim_ielen;\r\ndst_ie = p;\r\n} else {\r\ntim_ielen = 0;\r\noffset = 0;\r\np = rtw_get_ie23a(pie, WLAN_EID_SSID,\r\n&tmp_len, pnetwork_mlmeext->IELength);\r\nif (p != NULL)\r\noffset += tmp_len+2;\r\np = rtw_get_ie23a(pie, WLAN_EID_SUPP_RATES,\r\n&tmp_len, pnetwork_mlmeext->IELength);\r\nif (p != NULL)\r\noffset += tmp_len+2;\r\noffset += 3;\r\npremainder_ie = pie + offset;\r\nremainder_ielen = pnetwork_mlmeext->IELength - offset - tim_ielen;\r\ndst_ie = pie + offset;\r\n}\r\nif (remainder_ielen > 0) {\r\npbackup_remainder_ie = kmalloc(remainder_ielen, GFP_ATOMIC);\r\nif (pbackup_remainder_ie && premainder_ie)\r\nmemcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);\r\n}\r\n*dst_ie++ = WLAN_EID_TIM;\r\nif ((pstapriv->tim_bitmap&0xff00) && (pstapriv->tim_bitmap&0x00fc))\r\ntim_ielen = 5;\r\nelse\r\ntim_ielen = 4;\r\n*dst_ie++ = tim_ielen;\r\n*dst_ie++ = 0;\r\n*dst_ie++ = 1;\r\nif (pstapriv->tim_bitmap & BIT(0))\r\n*dst_ie++ = BIT(0);\r\nelse\r\n*dst_ie++ = 0;\r\nif (tim_ielen == 4) {\r\n*dst_ie++ = pstapriv->tim_bitmap & 0xff;\r\n} else if (tim_ielen == 5) {\r\nput_unaligned_le16(pstapriv->tim_bitmap, dst_ie);\r\ndst_ie += 2;\r\n}\r\nif (pbackup_remainder_ie) {\r\nmemcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);\r\nkfree(pbackup_remainder_ie);\r\n}\r\noffset = (uint)(dst_ie - pie);\r\npnetwork_mlmeext->IELength = offset + remainder_ielen;\r\nset_tx_beacon_cmd23a(padapter);\r\n}\r\nstatic u8 chk_sta_is_alive(struct sta_info *psta)\r\n{\r\nu8 ret = false;\r\nif ((psta->sta_stats.last_rx_data_pkts +\r\npsta->sta_stats.last_rx_ctrl_pkts) !=\r\n(psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts))\r\nret = true;\r\nsta_update_last_rx_pkts(psta);\r\nreturn ret;\r\n}\r\nvoid expire_timeout_chk23a(struct rtw_adapter *padapter)\r\n{\r\nstruct list_head *phead, *plist, *ptmp;\r\nu8 updated = 0;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 chk_alive_num = 0;\r\nstruct sta_info *chk_alive_list[NUM_STA];\r\nint i;\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\nphead = &pstapriv->auth_list;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npsta = container_of(plist, struct sta_info, auth_list);\r\nif (psta->expire_to > 0) {\r\npsta->expire_to--;\r\nif (psta->expire_to == 0) {\r\nlist_del_init(&psta->auth_list);\r\npstapriv->auth_list_cnt--;\r\nDBG_8723A("auth expire %pM\n", psta->hwaddr);\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nrtw_free_stainfo23a(padapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nspin_lock_bh(&pstapriv->auth_list_lock);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->auth_list_lock);\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nif (chk_sta_is_alive(psta) || !psta->expire_to) {\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->keep_alive_trycnt = 0;\r\n} else {\r\npsta->expire_to--;\r\n}\r\nif (psta->expire_to <= 0) {\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (padapter->registrypriv.wifi_spec == 1) {\r\npsta->expire_to = pstapriv->expire_to;\r\ncontinue;\r\n}\r\nif (psta->state & WIFI_SLEEP_STATE) {\r\nif (!(psta->state & WIFI_STA_ALIVE_CHK_STATE)) {\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->state |= WIFI_STA_ALIVE_CHK_STATE;\r\npstapriv->tim_bitmap |= CHKBIT(psta->aid);\r\nupdate_beacon23a(padapter, WLAN_EID_TIM, NULL, false);\r\nif (!pmlmeext->active_keep_alive_check)\r\ncontinue;\r\n}\r\n}\r\nif (pmlmeext->active_keep_alive_check) {\r\nchk_alive_list[chk_alive_num++] = psta;\r\ncontinue;\r\n}\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nDBG_8723A("asoc expire %pM, state = 0x%x\n",\r\npsta->hwaddr, psta->state);\r\nupdated = ap_free_sta23a(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);\r\n} else {\r\nif (psta->sleepq_len > (NR_XMITFRAME/pstapriv->asoc_list_cnt)\r\n&& padapter->xmitpriv.free_xmitframe_cnt < ((NR_XMITFRAME/pstapriv->asoc_list_cnt)/2)\r\n) {\r\nDBG_8723A("%s sta:%pM, sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n",\r\n__func__,\r\npsta->hwaddr,\r\npsta->sleepq_len,\r\npadapter->xmitpriv.free_xmitframe_cnt,\r\npstapriv->asoc_list_cnt);\r\nwakeup_sta_to_xmit23a(padapter, psta);\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nif (chk_alive_num) {\r\nu8 backup_oper_channel = 0;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (rtw_get_oper_ch23a(padapter) != pmlmeext->cur_channel) {\r\nbackup_oper_channel = rtw_get_oper_ch23a(padapter);\r\nSelectChannel23a(padapter, pmlmeext->cur_channel);\r\n}\r\nfor (i = 0; i < chk_alive_num; i++) {\r\nint ret = _FAIL;\r\npsta = chk_alive_list[i];\r\nif (!(psta->state & _FW_LINKED))\r\ncontinue;\r\nif (psta->state & WIFI_SLEEP_STATE)\r\nret = issue_nulldata23a(padapter, psta->hwaddr, 0, 1, 50);\r\nelse\r\nret = issue_nulldata23a(padapter, psta->hwaddr, 0, 3, 50);\r\npsta->keep_alive_trycnt++;\r\nif (ret == _SUCCESS) {\r\nDBG_8723A("asoc check, sta(%pM) is alive\n",\r\npsta->hwaddr);\r\npsta->expire_to = pstapriv->expire_to;\r\npsta->keep_alive_trycnt = 0;\r\ncontinue;\r\n} else if (psta->keep_alive_trycnt <= 3) {\r\nDBG_8723A("ack check for asoc expire, keep_alive_trycnt =%d\n", psta->keep_alive_trycnt);\r\npsta->expire_to = 1;\r\ncontinue;\r\n}\r\npsta->keep_alive_trycnt = 0;\r\nDBG_8723A("asoc expire %pM, state = 0x%x\n",\r\npsta->hwaddr, psta->state);\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (!list_empty(&psta->asoc_list)) {\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated = ap_free_sta23a(padapter, psta, false, WLAN_REASON_DEAUTH_LEAVING);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\n}\r\nif (backup_oper_channel > 0)\r\nSelectChannel23a(padapter, backup_oper_channel);\r\n}\r\nassociated_clients_update23a(padapter, updated);\r\n}\r\nvoid add_RATid23a(struct rtw_adapter *padapter, struct sta_info *psta, u8 rssi_level)\r\n{\r\nint i;\r\nu8 rf_type;\r\nu32 init_rate = 0;\r\nunsigned char sta_band = 0, raid, shortGIrate = false;\r\nunsigned char limit;\r\nunsigned int tx_ra_bitmap = 0;\r\nstruct ht_priv *psta_ht = NULL;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_bssid_ex *pcur_network = &pmlmepriv->cur_network.network;\r\nif (psta)\r\npsta_ht = &psta->htpriv;\r\nelse\r\nreturn;\r\nif (!(psta->state & _FW_LINKED))\r\nreturn;\r\nfor (i = 0; i < sizeof(psta->bssrateset); i++) {\r\nif (psta->bssrateset[i])\r\ntx_ra_bitmap |= rtw_get_bit_value_from_ieee_value23a(psta->bssrateset[i]&0x7f);\r\n}\r\nif (psta_ht->ht_option) {\r\nrf_type = rtl8723a_get_rf_type(padapter);\r\nif (rf_type == RF_2T2R)\r\nlimit = 16;\r\nelse\r\nlimit = 8;\r\nfor (i = 0; i < limit; i++) {\r\nif (psta_ht->ht_cap.mcs.rx_mask[i / 8] & BIT(i % 8))\r\ntx_ra_bitmap |= BIT(i + 12);\r\n}\r\nshortGIrate = psta_ht->sgi;\r\n}\r\nif (pcur_network->DSConfig > 14) {\r\nif (tx_ra_bitmap & 0xffff000)\r\nsta_band |= WIRELESS_11_5N | WIRELESS_11A;\r\nelse\r\nsta_band |= WIRELESS_11A;\r\n} else {\r\nif (tx_ra_bitmap & 0xffff000)\r\nsta_band |= WIRELESS_11_24N | WIRELESS_11G | WIRELESS_11B;\r\nelse if (tx_ra_bitmap & 0xff0)\r\nsta_band |= WIRELESS_11G | WIRELESS_11B;\r\nelse\r\nsta_band |= WIRELESS_11B;\r\n}\r\npsta->wireless_mode = sta_band;\r\nraid = networktype_to_raid23a(sta_band);\r\ninit_rate = get_highest_rate_idx23a(tx_ra_bitmap&0x0fffffff)&0x3f;\r\nif (psta->aid < NUM_STA) {\r\nu8 arg = 0;\r\narg = psta->mac_id&0x1f;\r\narg |= BIT(7);\r\nif (shortGIrate == true)\r\narg |= BIT(5);\r\ntx_ra_bitmap |= ((raid<<28)&0xf0000000);\r\nDBG_8723A("%s => mac_id:%d , raid:%d , bitmap = 0x%x, arg = "\r\n"0x%x\n",\r\n__func__, psta->mac_id, raid, tx_ra_bitmap, arg);\r\nrtl8723a_add_rateatid(padapter, tx_ra_bitmap, arg, rssi_level);\r\nif (shortGIrate == true)\r\ninit_rate |= BIT(6);\r\npsta->raid = raid;\r\npsta->init_rate = init_rate;\r\n} else\r\nDBG_8723A("station aid %d exceed the max number\n", psta->aid);\r\n}\r\nstatic void update_bmc_sta(struct rtw_adapter *padapter)\r\n{\r\nu32 init_rate = 0;\r\nunsigned char network_type, raid;\r\nint i, supportRateNum = 0;\r\nunsigned int tx_ra_bitmap = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_bssid_ex *pcur_network = &pmlmepriv->cur_network.network;\r\nstruct sta_info *psta = rtw_get_bcmc_stainfo23a(padapter);\r\nif (psta) {\r\npsta->aid = 0;\r\npsta->mac_id = psta->aid + 1;\r\npsta->qos_option = 0;\r\npsta->htpriv.ht_option = false;\r\npsta->ieee8021x_blocked = 0;\r\nmemset((void *)&psta->sta_stats, 0,\r\nsizeof(struct stainfo_stats));\r\nsupportRateNum = rtw_get_rateset_len23a((u8 *)&pcur_network->SupportedRates);\r\nnetwork_type = rtw_check_network_type23a((u8 *)&pcur_network->SupportedRates, supportRateNum, 1);\r\nmemcpy(psta->bssrateset, &pcur_network->SupportedRates, supportRateNum);\r\npsta->bssratelen = supportRateNum;\r\nfor (i = 0; i < supportRateNum; i++) {\r\nif (psta->bssrateset[i])\r\ntx_ra_bitmap |= rtw_get_bit_value_from_ieee_value23a(psta->bssrateset[i]&0x7f);\r\n}\r\nif (pcur_network->DSConfig > 14) {\r\nnetwork_type = WIRELESS_11A;\r\ntx_ra_bitmap = 0x150;\r\n} else {\r\nnetwork_type = WIRELESS_11B;\r\ntx_ra_bitmap = 0xf;\r\n}\r\nraid = networktype_to_raid23a(network_type);\r\ninit_rate = get_highest_rate_idx23a(tx_ra_bitmap&0x0fffffff)&0x3f;\r\nrtl8723a_SetHalODMVar(padapter, HAL_ODM_STA_INFO, psta, true);\r\n{\r\nu8 arg = 0;\r\narg = psta->mac_id&0x1f;\r\narg |= BIT(7);\r\ntx_ra_bitmap |= ((raid<<28)&0xf0000000);\r\nDBG_8723A("update_bmc_sta, mask = 0x%x, arg = 0x%x\n", tx_ra_bitmap, arg);\r\nrtl8723a_add_rateatid(padapter, tx_ra_bitmap, arg, 0);\r\n}\r\npsta->raid = raid;\r\npsta->init_rate = init_rate;\r\nspin_lock_bh(&psta->lock);\r\npsta->state = _FW_LINKED;\r\nspin_unlock_bh(&psta->lock);\r\n} else\r\nDBG_8723A("add_RATid23a_bmc_sta error!\n");\r\n}\r\nvoid update_sta_info23a_apmode23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\r\nstruct ht_priv *phtpriv_sta = &psta->htpriv;\r\npsta->mac_id = psta->aid+1;\r\nDBG_8723A("%s\n", __func__);\r\nrtl8723a_SetHalODMVar(padapter, HAL_ODM_STA_INFO, psta, true);\r\nif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\r\npsta->ieee8021x_blocked = true;\r\nelse\r\npsta->ieee8021x_blocked = false;\r\nVCS_update23a(padapter, psta);\r\nif (phtpriv_sta->ht_option) {\r\nphtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;\r\nif ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))\r\nphtpriv_sta->sgi = true;\r\nif ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH_20_40)) {\r\nphtpriv_sta->bwmode = pmlmeext->cur_bwmode;\r\nphtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;\r\n}\r\npsta->qos_option = true;\r\n} else {\r\nphtpriv_sta->ampdu_enable = false;\r\nphtpriv_sta->sgi = false;\r\nphtpriv_sta->bwmode = HT_CHANNEL_WIDTH_20;\r\nphtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\n}\r\nsend_delba23a(padapter, 0, psta->hwaddr);\r\nsend_delba23a(padapter, 1, psta->hwaddr);\r\nphtpriv_sta->agg_enable_bitmap = 0x0;\r\nphtpriv_sta->candidate_tid_bitmap = 0x0;\r\nmemset((void *)&psta->sta_stats, 0, sizeof(struct stainfo_stats));\r\nspin_lock_bh(&psta->lock);\r\npsta->state |= _FW_LINKED;\r\nspin_unlock_bh(&psta->lock);\r\n}\r\nstatic void update_hw_ht_param(struct rtw_adapter *padapter)\r\n{\r\nunsigned char max_AMPDU_len;\r\nunsigned char min_MPDU_spacing;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nDBG_8723A("%s\n", __func__);\r\nmax_AMPDU_len = pmlmeinfo->ht_cap.ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_FACTOR;\r\nmin_MPDU_spacing = (pmlmeinfo->ht_cap.ampdu_params_info &\r\nIEEE80211_HT_AMPDU_PARM_DENSITY) >> 2;\r\nrtl8723a_set_ampdu_min_space(padapter, min_MPDU_spacing);\r\nrtl8723a_set_ampdu_factor(padapter, max_AMPDU_len);\r\npmlmeinfo->SM_PS = (le16_to_cpu(pmlmeinfo->ht_cap.cap_info) &\r\nIEEE80211_HT_CAP_SM_PS) >> 2;\r\nif (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)\r\nDBG_8723A("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);\r\n}\r\nstatic void start_bss_network(struct rtw_adapter *padapter, u8 *pbuf)\r\n{\r\nconst u8 *p;\r\nu8 val8, cur_channel, cur_bwmode, cur_ch_offset;\r\nu16 bcn_interval;\r\nu32 acparm;\r\nstruct registry_priv *pregpriv = &padapter->registrypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct wlan_bssid_ex *pnetwork = &pmlmepriv->cur_network.network;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *pnetwork_mlmeext = &pmlmeinfo->network;\r\nstruct ieee80211_ht_operation *pht_info = NULL;\r\nbcn_interval = (u16)pnetwork->beacon_interval;\r\ncur_channel = pnetwork->DSConfig;\r\ncur_bwmode = HT_CHANNEL_WIDTH_20;\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nif (NULL == cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\r\nWLAN_OUI_TYPE_MICROSOFT_WPS,\r\npnetwork->IEs,\r\npnetwork->IELength))\r\npmlmeext->bstart_bss = true;\r\nif (pmlmepriv->qos_option)\r\npmlmeinfo->WMM_enable = true;\r\nif (pmlmepriv->htpriv.ht_option) {\r\npmlmeinfo->WMM_enable = true;\r\npmlmeinfo->HT_enable = true;\r\nupdate_hw_ht_param(padapter);\r\n}\r\nif (pmlmepriv->cur_network.join_res != true) {\r\nif (psecuritypriv->dot11PrivacyAlgrthm !=\r\nWLAN_CIPHER_SUITE_WEP40 &&\r\npsecuritypriv->dot11PrivacyAlgrthm !=\r\nWLAN_CIPHER_SUITE_WEP104)\r\nflush_all_cam_entry23a(padapter);\r\n}\r\nrtl8723a_set_media_status(padapter, MSR_AP);\r\nhw_var_set_bssid(padapter, pnetwork->MacAddress);\r\nacparm = 0x002F3217;\r\nrtl8723a_set_ac_param_vo(padapter, acparm);\r\nacparm = 0x005E4317;\r\nrtl8723a_set_ac_param_vi(padapter, acparm);\r\nacparm = 0x005ea42b;\r\nrtl8723a_set_ac_param_be(padapter, acparm);\r\nacparm = 0x0000A444;\r\nrtl8723a_set_ac_param_bk(padapter, acparm);\r\nval8 = (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) ?\r\n0xcc : 0xcf;\r\nrtl8723a_set_sec_cfg(padapter, val8);\r\nrtl8723a_set_beacon_interval(padapter, bcn_interval);\r\nUpdateBrateTbl23a(padapter, pnetwork->SupportedRates);\r\nHalSetBrateCfg23a(padapter, pnetwork->SupportedRates);\r\nif (!pmlmepriv->cur_network.join_res) {\r\nrtl8723a_odm_support_ability_set(padapter,\r\nDYNAMIC_ALL_FUNC_ENABLE);\r\n}\r\np = cfg80211_find_ie(WLAN_EID_HT_OPERATION, pnetwork->IEs,\r\npnetwork->IELength);\r\nif (p && p[1]) {\r\npht_info = (struct ieee80211_ht_operation *)(p + 2);\r\nif (pregpriv->cbw40_enable && pht_info->ht_param &\r\nIEEE80211_HT_PARAM_CHAN_WIDTH_ANY) {\r\ncur_bwmode = HT_CHANNEL_WIDTH_40;\r\nswitch (pht_info->ht_param &\r\nIEEE80211_HT_PARAM_CHA_SEC_OFFSET) {\r\ncase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nbreak;\r\ncase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nbreak;\r\ndefault:\r\ncur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nbreak;\r\n}\r\n}\r\n}\r\nset_channel_bwmode23a(padapter, cur_channel, cur_ch_offset, cur_bwmode);\r\nDBG_8723A("CH =%d, BW =%d, offset =%d\n", cur_channel, cur_bwmode,\r\ncur_ch_offset);\r\npmlmeext->cur_channel = cur_channel;\r\npmlmeext->cur_bwmode = cur_bwmode;\r\npmlmeext->cur_ch_offset = cur_ch_offset;\r\npmlmeext->cur_wireless_mode = pmlmepriv->cur_network.network_type;\r\nupdate_wireless_mode23a(padapter);\r\nupdate_capinfo23a(padapter, pnetwork->capability);\r\nmemcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);\r\nif (pmlmeext->bstart_bss) {\r\nupdate_beacon23a(padapter, WLAN_EID_TIM, NULL, false);\r\nif (send_beacon23a(padapter) == _FAIL)\r\nDBG_8723A("issue_beacon23a, fail!\n");\r\n}\r\nupdate_bmc_sta(padapter);\r\n}\r\nint rtw_check_beacon_data23a(struct rtw_adapter *padapter,\r\nstruct ieee80211_mgmt *mgmt, unsigned int len)\r\n{\r\nint ret = _SUCCESS;\r\nu8 *p;\r\nu8 *pHT_caps_ie = NULL;\r\nu8 *pHT_info_ie = NULL;\r\nstruct sta_info *psta = NULL;\r\nu16 ht_cap = false;\r\nuint ie_len = 0;\r\nint group_cipher, pairwise_cipher;\r\nu8 channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];\r\nint supportRateNum = 0;\r\nu8 WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_bssid_ex *pbss_network = &pmlmepriv->cur_network.network;\r\nu8 *ie = pbss_network->IEs;\r\nu8 *pbuf = mgmt->u.beacon.variable;\r\nlen -= offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nDBG_8723A("%s, len =%d\n", __func__, len);\r\nif (!check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nreturn _FAIL;\r\nif (len > MAX_IE_SZ)\r\nreturn _FAIL;\r\npbss_network->IELength = len;\r\nmemset(ie, 0, MAX_IE_SZ);\r\nmemcpy(ie, pbuf, pbss_network->IELength);\r\nif (pbss_network->ifmode != NL80211_IFTYPE_AP &&\r\npbss_network->ifmode != NL80211_IFTYPE_P2P_GO)\r\nreturn _FAIL;\r\npbss_network->Rssi = 0;\r\nmemcpy(pbss_network->MacAddress, myid(&padapter->eeprompriv), ETH_ALEN);\r\np = rtw_get_ie23a(ie, WLAN_EID_SSID, &ie_len, pbss_network->IELength);\r\nif (p && ie_len > 0) {\r\nmemset(&pbss_network->Ssid, 0, sizeof(struct cfg80211_ssid));\r\nmemcpy(pbss_network->Ssid.ssid, (p + 2), ie_len);\r\npbss_network->Ssid.ssid_len = ie_len;\r\n}\r\nchannel = 0;\r\np = rtw_get_ie23a(ie, WLAN_EID_DS_PARAMS, &ie_len,\r\npbss_network->IELength);\r\nif (p && ie_len > 0)\r\nchannel = *(p + 2);\r\npbss_network->DSConfig = channel;\r\nmemset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);\r\np = rtw_get_ie23a(ie, WLAN_EID_SUPP_RATES, &ie_len,\r\npbss_network->IELength);\r\nif (p) {\r\nmemcpy(supportRate, p+2, ie_len);\r\nsupportRateNum = ie_len;\r\n}\r\np = rtw_get_ie23a(ie, WLAN_EID_EXT_SUPP_RATES,\r\n&ie_len, pbss_network->IELength);\r\nif (p) {\r\nmemcpy(supportRate+supportRateNum, p+2, ie_len);\r\nsupportRateNum += ie_len;\r\n}\r\nnetwork_type = rtw_check_network_type23a(supportRate,\r\nsupportRateNum, channel);\r\nrtw_set_supported_rate23a(pbss_network->SupportedRates, network_type);\r\np = rtw_get_ie23a(ie, WLAN_EID_ERP_INFO, &ie_len,\r\npbss_network->IELength);\r\nif (p && ie_len > 0)\r\nERP_IE_handler23a(padapter, p);\r\nif (pbss_network->capability & BIT(4))\r\npbss_network->Privacy = 1;\r\nelse\r\npbss_network->Privacy = 0;\r\npsecuritypriv->wpa_psk = 0;\r\ngroup_cipher = 0; pairwise_cipher = 0;\r\npsecuritypriv->wpa2_group_cipher = 0;\r\npsecuritypriv->wpa2_pairwise_cipher = 0;\r\np = rtw_get_ie23a(ie, WLAN_EID_RSN, &ie_len,\r\npbss_network->IELength);\r\nif (p && ie_len > 0) {\r\nif (rtw_parse_wpa2_ie23a(p, ie_len+2, &group_cipher,\r\n&pairwise_cipher, NULL) == _SUCCESS) {\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npsecuritypriv->dot8021xalg = 1;\r\npsecuritypriv->wpa_psk |= BIT(1);\r\npsecuritypriv->wpa2_group_cipher = group_cipher;\r\npsecuritypriv->wpa2_pairwise_cipher = pairwise_cipher;\r\n}\r\n}\r\nie_len = 0;\r\ngroup_cipher = 0;\r\npairwise_cipher = 0;\r\npsecuritypriv->wpa_group_cipher = 0;\r\npsecuritypriv->wpa_pairwise_cipher = 0;\r\nfor (p = ie; ; p += (ie_len + 2)) {\r\np = rtw_get_ie23a(p, WLAN_EID_VENDOR_SPECIFIC, &ie_len,\r\npbss_network->IELength - (ie_len + 2));\r\nif ((p) && (!memcmp(p+2, RTW_WPA_OUI23A_TYPE, 4))) {\r\nif (rtw_parse_wpa_ie23a(p, ie_len+2, &group_cipher,\r\n&pairwise_cipher, NULL) == _SUCCESS) {\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npsecuritypriv->dot8021xalg = 1;\r\npsecuritypriv->wpa_psk |= BIT(0);\r\npsecuritypriv->wpa_group_cipher = group_cipher;\r\npsecuritypriv->wpa_pairwise_cipher = pairwise_cipher;\r\n}\r\nbreak;\r\n}\r\nif ((p == NULL) || (ie_len == 0))\r\nbreak;\r\n}\r\nie_len = 0;\r\npmlmepriv->qos_option = 0;\r\nif (pregistrypriv->wmm_enable) {\r\nfor (p = ie; ; p += (ie_len + 2)) {\r\np = rtw_get_ie23a(p, WLAN_EID_VENDOR_SPECIFIC, &ie_len,\r\n(pbss_network->IELength -\r\n(ie_len + 2)));\r\nif ((p) && !memcmp(p+2, WMM_PARA_IE, 6)) {\r\npmlmepriv->qos_option = 1;\r\n*(p+8) |= BIT(7);\r\n*(p + 10) &= ~BIT(4);\r\n*(p + 14) &= ~BIT(4);\r\n*(p + 18) &= ~BIT(4);\r\n*(p + 22) &= ~BIT(4);\r\nbreak;\r\n}\r\nif ((p == NULL) || (ie_len == 0))\r\nbreak;\r\n}\r\n}\r\np = rtw_get_ie23a(ie, WLAN_EID_HT_CAPABILITY, &ie_len,\r\npbss_network->IELength);\r\nif (p && ie_len > 0) {\r\nu8 rf_type;\r\nstruct ieee80211_ht_cap *pht_cap = (struct ieee80211_ht_cap *)(p+2);\r\npHT_caps_ie = p;\r\nht_cap = true;\r\nnetwork_type |= WIRELESS_11_24N;\r\nrf_type = rtl8723a_get_rf_type(padapter);\r\nif ((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||\r\n(psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP))\r\npht_cap->ampdu_params_info |= (IEEE80211_HT_AMPDU_PARM_DENSITY & (0x07<<2));\r\nelse\r\npht_cap->ampdu_params_info |= (IEEE80211_HT_AMPDU_PARM_DENSITY&0x00);\r\npht_cap->ampdu_params_info |= (IEEE80211_HT_AMPDU_PARM_FACTOR & 0x03);\r\nif (rf_type == RF_1T1R) {\r\npht_cap->mcs.rx_mask[0] = 0xff;\r\npht_cap->mcs.rx_mask[1] = 0x0;\r\n}\r\nmemcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);\r\n}\r\np = rtw_get_ie23a(ie, WLAN_EID_HT_OPERATION, &ie_len,\r\npbss_network->IELength);\r\nif (p && ie_len > 0)\r\npHT_info_ie = p;\r\npmlmepriv->cur_network.network_type = network_type;\r\npmlmepriv->htpriv.ht_option = false;\r\nif (pregistrypriv->ht_enable && ht_cap) {\r\npmlmepriv->htpriv.ht_option = true;\r\npmlmepriv->qos_option = 1;\r\nif (pregistrypriv->ampdu_enable == 1)\r\npmlmepriv->htpriv.ampdu_enable = true;\r\nHT_caps_handler23a(padapter, pHT_caps_ie);\r\nHT_info_handler23a(padapter, pHT_info_ie);\r\n}\r\npbss_network->Length = get_wlan_bssid_ex_sz(pbss_network);\r\nstart_bss_network(padapter, (u8 *)pbss_network);\r\npsta = rtw_get_stainfo23a(&padapter->stapriv, pbss_network->MacAddress);\r\nif (!psta) {\r\npsta = rtw_alloc_stainfo23a(&padapter->stapriv,\r\npbss_network->MacAddress,\r\nGFP_KERNEL);\r\nif (!psta)\r\nreturn _FAIL;\r\n}\r\npsta->state |= WIFI_AP_STATE;\r\nrtw_indicate_connect23a(padapter);\r\npmlmepriv->cur_network.join_res = true;\r\nreturn ret;\r\n}\r\nvoid rtw_set_macaddr_acl23a(struct rtw_adapter *padapter, int mode)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nDBG_8723A("%s, mode =%d\n", __func__, mode);\r\npacl_list->mode = mode;\r\n}\r\nint rtw_acl_add_sta23a(struct rtw_adapter *padapter, u8 *addr)\r\n{\r\nstruct list_head *plist, *phead;\r\nu8 added = false;\r\nint i, ret = 0;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct rtw_queue *pacl_node_q = &pacl_list->acl_node_q;\r\nDBG_8723A("%s(acl_num =%d) =%pM\n", __func__, pacl_list->num, addr);\r\nif ((NUM_ACL-1) < pacl_list->num)\r\nreturn -1;\r\nspin_lock_bh(&pacl_node_q->lock);\r\nphead = get_list_head(pacl_node_q);\r\nlist_for_each(plist, phead) {\r\npaclnode = container_of(plist, struct rtw_wlan_acl_node, list);\r\nif (!memcmp(paclnode->addr, addr, ETH_ALEN)) {\r\nif (paclnode->valid == true) {\r\nadded = true;\r\nDBG_8723A("%s, sta has been added\n", __func__);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pacl_node_q->lock);\r\nif (added)\r\nreturn ret;\r\nspin_lock_bh(&pacl_node_q->lock);\r\nfor (i = 0; i < NUM_ACL; i++) {\r\npaclnode = &pacl_list->aclnode[i];\r\nif (!paclnode->valid) {\r\nINIT_LIST_HEAD(&paclnode->list);\r\nmemcpy(paclnode->addr, addr, ETH_ALEN);\r\npaclnode->valid = true;\r\nlist_add_tail(&paclnode->list, get_list_head(pacl_node_q));\r\npacl_list->num++;\r\nbreak;\r\n}\r\n}\r\nDBG_8723A("%s, acl_num =%d\n", __func__, pacl_list->num);\r\nspin_unlock_bh(&pacl_node_q->lock);\r\nreturn ret;\r\n}\r\nint rtw_acl_remove_sta23a(struct rtw_adapter *padapter, u8 *addr)\r\n{\r\nstruct list_head *plist, *phead, *ptmp;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct rtw_queue *pacl_node_q = &pacl_list->acl_node_q;\r\nDBG_8723A("%s(acl_num =%d) = %pM\n", __func__, pacl_list->num, addr);\r\nspin_lock_bh(&pacl_node_q->lock);\r\nphead = get_list_head(pacl_node_q);\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npaclnode = container_of(plist, struct rtw_wlan_acl_node, list);\r\nif (!memcmp(paclnode->addr, addr, ETH_ALEN)) {\r\nif (paclnode->valid) {\r\npaclnode->valid = false;\r\nlist_del_init(&paclnode->list);\r\npacl_list->num--;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pacl_node_q->lock);\r\nDBG_8723A("%s, acl_num =%d\n", __func__, pacl_list->num);\r\nreturn 0;\r\n}\r\nstatic void update_bcn_fixed_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_erpinfo_ie(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *pnetwork = &pmlmeinfo->network;\r\nunsigned char *p, *ie = pnetwork->IEs;\r\nu32 len = 0;\r\nDBG_8723A("%s, ERP_enable =%d\n", __func__, pmlmeinfo->ERP_enable);\r\nif (!pmlmeinfo->ERP_enable)\r\nreturn;\r\np = rtw_get_ie23a(ie, WLAN_EID_ERP_INFO, &len, pnetwork->IELength);\r\nif (p && len > 0) {\r\nif (pmlmepriv->num_sta_non_erp == 1)\r\np[2] |= WLAN_ERP_NON_ERP_PRESENT |\r\nWLAN_ERP_USE_PROTECTION;\r\nelse\r\np[2] &= ~(WLAN_ERP_NON_ERP_PRESENT |\r\nWLAN_ERP_USE_PROTECTION);\r\nif (pmlmepriv->num_sta_no_short_preamble > 0)\r\np[2] |= WLAN_ERP_BARKER_PREAMBLE;\r\nelse\r\np[2] &= ~(WLAN_ERP_BARKER_PREAMBLE);\r\nERP_IE_handler23a(padapter, p);\r\n}\r\n}\r\nstatic void update_bcn_htcap_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_htinfo_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_rsn_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_wpa_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_wmm_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_wps_ie(struct rtw_adapter *padapter)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\n}\r\nstatic void update_bcn_p2p_ie(struct rtw_adapter *padapter)\r\n{\r\n}\r\nstatic void update_bcn_vendor_spec_ie(struct rtw_adapter *padapter, u8 *oui)\r\n{\r\nDBG_8723A("%s\n", __func__);\r\nif (!memcmp(RTW_WPA_OUI23A_TYPE, oui, 4))\r\nupdate_bcn_wpa_ie(padapter);\r\nelse if (!memcmp(WMM_OUI23A, oui, 4))\r\nupdate_bcn_wmm_ie(padapter);\r\nelse if (!memcmp(WPS_OUI23A, oui, 4))\r\nupdate_bcn_wps_ie(padapter);\r\nelse if (!memcmp(P2P_OUI23A, oui, 4))\r\nupdate_bcn_p2p_ie(padapter);\r\nelse\r\nDBG_8723A("unknown OUI type!\n");\r\n}\r\nvoid update_beacon23a(struct rtw_adapter *padapter, u8 ie_id, u8 *oui, u8 tx)\r\n{\r\nstruct mlme_priv *pmlmepriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nif (!padapter)\r\nreturn;\r\npmlmepriv = &padapter->mlmepriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\nif (false == pmlmeext->bstart_bss)\r\nreturn;\r\nspin_lock_bh(&pmlmepriv->bcn_update_lock);\r\nswitch (ie_id) {\r\ncase 0xFF:\r\nupdate_bcn_fixed_ie(padapter);\r\nbreak;\r\ncase WLAN_EID_TIM:\r\nupdate_BCNTIM(padapter);\r\nbreak;\r\ncase WLAN_EID_ERP_INFO:\r\nupdate_bcn_erpinfo_ie(padapter);\r\nbreak;\r\ncase WLAN_EID_HT_CAPABILITY:\r\nupdate_bcn_htcap_ie(padapter);\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nupdate_bcn_rsn_ie(padapter);\r\nbreak;\r\ncase WLAN_EID_HT_OPERATION:\r\nupdate_bcn_htinfo_ie(padapter);\r\nbreak;\r\ncase WLAN_EID_VENDOR_SPECIFIC:\r\nupdate_bcn_vendor_spec_ie(padapter, oui);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npmlmepriv->update_bcn = true;\r\nspin_unlock_bh(&pmlmepriv->bcn_update_lock);\r\nif (tx)\r\nset_tx_beacon_cmd23a(padapter);\r\n}\r\nstatic int rtw_ht_operation_update(struct rtw_adapter *padapter)\r\n{\r\nu16 cur_op_mode, new_op_mode;\r\nint op_mode_changes = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv_ap = &pmlmepriv->htpriv;\r\nif (pmlmepriv->htpriv.ht_option)\r\nreturn 0;\r\nDBG_8723A("%s current operation mode = 0x%X\n",\r\n__func__, pmlmepriv->ht_op_mode);\r\nif (!(pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)\r\n&& pmlmepriv->num_sta_ht_no_gf) {\r\npmlmepriv->ht_op_mode |=\r\nIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT;\r\nop_mode_changes++;\r\n} else if ((pmlmepriv->ht_op_mode &\r\nIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT) &&\r\npmlmepriv->num_sta_ht_no_gf == 0) {\r\npmlmepriv->ht_op_mode &=\r\n~IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT;\r\nop_mode_changes++;\r\n}\r\nif (!(pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT) &&\r\n(pmlmepriv->num_sta_no_ht || pmlmepriv->olbc_ht)) {\r\npmlmepriv->ht_op_mode |= IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\r\nop_mode_changes++;\r\n} else if ((pmlmepriv->ht_op_mode &\r\nIEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT) &&\r\n(pmlmepriv->num_sta_no_ht == 0 && !pmlmepriv->olbc_ht)) {\r\npmlmepriv->ht_op_mode &=\r\n~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\r\nop_mode_changes++;\r\n}\r\nif (pmlmepriv->num_sta_no_ht ||\r\n(pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT))\r\nnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED;\r\nelse if ((le16_to_cpu(phtpriv_ap->ht_cap.cap_info) &\r\nIEEE80211_HT_CAP_SUP_WIDTH_20_40) &&\r\npmlmepriv->num_sta_ht_20mhz)\r\nnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_20MHZ;\r\nelse if (pmlmepriv->olbc_ht)\r\nnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_NONMEMBER;\r\nelse\r\nnew_op_mode = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\r\ncur_op_mode = pmlmepriv->ht_op_mode & IEEE80211_HT_OP_MODE_PROTECTION;\r\nif (cur_op_mode != new_op_mode) {\r\npmlmepriv->ht_op_mode &= ~IEEE80211_HT_OP_MODE_PROTECTION;\r\npmlmepriv->ht_op_mode |= new_op_mode;\r\nop_mode_changes++;\r\n}\r\nDBG_8723A("%s new operation mode = 0x%X changes =%d\n",\r\n__func__, pmlmepriv->ht_op_mode, op_mode_changes);\r\nreturn op_mode_changes;\r\n}\r\nvoid associated_clients_update23a(struct rtw_adapter *padapter, u8 updated)\r\n{\r\nif (updated == true) {\r\nstruct list_head *phead, *plist, *ptmp;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nVCS_update23a(padapter, psta);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\n}\r\n}\r\nvoid bss_cap_update_on_sta_join23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 beacon_updated = false;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (!(psta->flags & WLAN_STA_SHORT_PREAMBLE)) {\r\nif (!psta->no_short_preamble_set) {\r\npsta->no_short_preamble_set = 1;\r\npmlmepriv->num_sta_no_short_preamble++;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_preamble == 1)) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n} else {\r\nif (psta->no_short_preamble_set) {\r\npsta->no_short_preamble_set = 0;\r\npmlmepriv->num_sta_no_short_preamble--;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_preamble == 0)) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n}\r\nif (psta->flags & WLAN_STA_NONERP) {\r\nif (!psta->nonerp_set) {\r\npsta->nonerp_set = 1;\r\npmlmepriv->num_sta_non_erp++;\r\nif (pmlmepriv->num_sta_non_erp == 1) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, WLAN_EID_ERP_INFO, NULL, true);\r\n}\r\n}\r\n} else {\r\nif (psta->nonerp_set) {\r\npsta->nonerp_set = 0;\r\npmlmepriv->num_sta_non_erp--;\r\nif (pmlmepriv->num_sta_non_erp == 0) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, WLAN_EID_ERP_INFO, NULL, true);\r\n}\r\n}\r\n}\r\nif (!(psta->capability & WLAN_CAPABILITY_SHORT_SLOT_TIME)) {\r\nif (!psta->no_short_slot_time_set) {\r\npsta->no_short_slot_time_set = 1;\r\npmlmepriv->num_sta_no_short_slot_time++;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_slot_time == 1)) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n} else {\r\nif (psta->no_short_slot_time_set) {\r\npsta->no_short_slot_time_set = 0;\r\npmlmepriv->num_sta_no_short_slot_time--;\r\nif ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&\r\n(pmlmepriv->num_sta_no_short_slot_time == 0)) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\n}\r\nif (psta->flags & WLAN_STA_HT) {\r\nu16 ht_capab = le16_to_cpu(psta->htpriv.ht_cap.cap_info);\r\nDBG_8723A("HT: STA %pM HT Capabilities Info: 0x%04x\n",\r\npsta->hwaddr, ht_capab);\r\nif (psta->no_ht_set) {\r\npsta->no_ht_set = 0;\r\npmlmepriv->num_sta_no_ht--;\r\n}\r\nif ((ht_capab & IEEE80211_HT_CAP_GRN_FLD) == 0) {\r\nif (!psta->no_ht_gf_set) {\r\npsta->no_ht_gf_set = 1;\r\npmlmepriv->num_sta_ht_no_gf++;\r\n}\r\nDBG_8723A("%s STA %pM - no greenfield, num of non-gf stations %d\n",\r\n__func__, psta->hwaddr,\r\npmlmepriv->num_sta_ht_no_gf);\r\n}\r\nif ((ht_capab & IEEE80211_HT_CAP_SUP_WIDTH_20_40) == 0) {\r\nif (!psta->ht_20mhz_set) {\r\npsta->ht_20mhz_set = 1;\r\npmlmepriv->num_sta_ht_20mhz++;\r\n}\r\nDBG_8723A("%s STA %pM - 20 MHz HT, num of 20MHz HT STAs %d\n",\r\n__func__, psta->hwaddr,\r\npmlmepriv->num_sta_ht_20mhz);\r\n}\r\n} else {\r\nif (!psta->no_ht_set) {\r\npsta->no_ht_set = 1;\r\npmlmepriv->num_sta_no_ht++;\r\n}\r\nif (pmlmepriv->htpriv.ht_option) {\r\nDBG_8723A("%s STA %pM - no HT, num of non-HT stations %d\n",\r\n__func__, psta->hwaddr,\r\npmlmepriv->num_sta_no_ht);\r\n}\r\n}\r\nif (rtw_ht_operation_update(padapter) > 0) {\r\nupdate_beacon23a(padapter, WLAN_EID_HT_CAPABILITY, NULL, false);\r\nupdate_beacon23a(padapter, WLAN_EID_HT_OPERATION, NULL, true);\r\n}\r\nassociated_clients_update23a(padapter, beacon_updated);\r\nDBG_8723A("%s, updated =%d\n", __func__, beacon_updated);\r\n}\r\nu8 bss_cap_update_on_sta_leave23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nu8 beacon_updated = false;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nif (!psta)\r\nreturn beacon_updated;\r\nif (psta->no_short_preamble_set) {\r\npsta->no_short_preamble_set = 0;\r\npmlmepriv->num_sta_no_short_preamble--;\r\nif (pmlmeext->cur_wireless_mode > WIRELESS_11B\r\n&& pmlmepriv->num_sta_no_short_preamble == 0) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\nif (psta->nonerp_set) {\r\npsta->nonerp_set = 0;\r\npmlmepriv->num_sta_non_erp--;\r\nif (pmlmepriv->num_sta_non_erp == 0) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, WLAN_EID_ERP_INFO,\r\nNULL, true);\r\n}\r\n}\r\nif (psta->no_short_slot_time_set) {\r\npsta->no_short_slot_time_set = 0;\r\npmlmepriv->num_sta_no_short_slot_time--;\r\nif (pmlmeext->cur_wireless_mode > WIRELESS_11B\r\n&& pmlmepriv->num_sta_no_short_slot_time == 0) {\r\nbeacon_updated = true;\r\nupdate_beacon23a(padapter, 0xFF, NULL, true);\r\n}\r\n}\r\nif (psta->no_ht_gf_set) {\r\npsta->no_ht_gf_set = 0;\r\npmlmepriv->num_sta_ht_no_gf--;\r\n}\r\nif (psta->no_ht_set) {\r\npsta->no_ht_set = 0;\r\npmlmepriv->num_sta_no_ht--;\r\n}\r\nif (psta->ht_20mhz_set) {\r\npsta->ht_20mhz_set = 0;\r\npmlmepriv->num_sta_ht_20mhz--;\r\n}\r\nif (rtw_ht_operation_update(padapter) > 0) {\r\nupdate_beacon23a(padapter, WLAN_EID_HT_CAPABILITY, NULL, false);\r\nupdate_beacon23a(padapter, WLAN_EID_HT_OPERATION, NULL, true);\r\n}\r\nDBG_8723A("%s, updated =%d\n", __func__, beacon_updated);\r\nreturn beacon_updated;\r\n}\r\nu8 ap_free_sta23a(struct rtw_adapter *padapter, struct sta_info *psta, bool active, u16 reason)\r\n{\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nu8 beacon_updated = false;\r\nif (!psta)\r\nreturn beacon_updated;\r\nif (active) {\r\nsend_delba23a(padapter, 0, psta->hwaddr);\r\nsend_delba23a(padapter, 1, psta->hwaddr);\r\nissue_deauth23a(padapter, psta->hwaddr, reason);\r\n}\r\npsta->htpriv.agg_enable_bitmap = 0x0;\r\npsta->htpriv.candidate_tid_bitmap = 0x0;\r\nrtw_clearstakey_cmd23a(padapter, (u8 *)psta, (u8)(psta->mac_id + 3),\r\ntrue);\r\nspin_lock_bh(&psta->lock);\r\npsta->state &= ~_FW_LINKED;\r\nspin_unlock_bh(&psta->lock);\r\nrtw_cfg80211_indicate_sta_disassoc(padapter, psta->hwaddr, reason);\r\nreport_del_sta_event23a(padapter, psta->hwaddr, reason);\r\nbeacon_updated = bss_cap_update_on_sta_leave23a(padapter, psta);\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nrtw_free_stainfo23a(padapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nreturn beacon_updated;\r\n}\r\nint rtw_ap_inform_ch_switch23a(struct rtw_adapter *padapter, u8 new_ch, u8 ch_offset)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nif ((pmlmeinfo->state&0x03) != MSR_AP)\r\nreturn 0;\r\nDBG_8723A("%s(%s): with ch:%u, offset:%u\n", __func__,\r\npadapter->pnetdev->name, new_ch, ch_offset);\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nlist_for_each(plist, phead) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nissue_action_spct_ch_switch23a(padapter, psta->hwaddr, new_ch, ch_offset);\r\npsta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 : (pstapriv->expire_to * 2);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nissue_action_spct_ch_switch23a(padapter, bc_addr, new_ch, ch_offset);\r\nreturn 0;\r\n}\r\nint rtw_sta_flush23a(struct rtw_adapter *padapter)\r\n{\r\nstruct list_head *phead, *plist, *ptmp;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nu8 bc_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 chk_alive_num = 0;\r\nstruct sta_info *chk_alive_list[NUM_STA];\r\nint i;\r\nDBG_8723A("%s(%s)\n", __func__, padapter->pnetdev->name);\r\nif ((pmlmeinfo->state&0x03) != MSR_AP)\r\nreturn 0;\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nchk_alive_list[chk_alive_num++] = psta;\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nfor (i = 0; i < chk_alive_num; i++)\r\nap_free_sta23a(padapter, chk_alive_list[i], true,\r\nWLAN_REASON_DEAUTH_LEAVING);\r\nissue_deauth23a(padapter, bc_addr, WLAN_REASON_DEAUTH_LEAVING);\r\nassociated_clients_update23a(padapter, true);\r\nreturn 0;\r\n}\r\nvoid sta_info_update23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nint flags = psta->flags;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (WLAN_STA_WME&flags)\r\npsta->qos_option = 1;\r\nelse\r\npsta->qos_option = 0;\r\nif (pmlmepriv->qos_option == 0)\r\npsta->qos_option = 0;\r\nif (WLAN_STA_HT&flags) {\r\npsta->htpriv.ht_option = true;\r\npsta->qos_option = 1;\r\n} else {\r\npsta->htpriv.ht_option = false;\r\n}\r\nif (!pmlmepriv->htpriv.ht_option)\r\npsta->htpriv.ht_option = false;\r\nupdate_sta_info23a_apmode23a(padapter, psta);\r\n}\r\nvoid ap_sta_info_defer_update23a(struct rtw_adapter *padapter, struct sta_info *psta)\r\n{\r\nif (psta->state & _FW_LINKED) {\r\nadd_RATid23a(padapter, psta, 0);\r\n}\r\n}\r\nvoid rtw_ap_restore_network(struct rtw_adapter *padapter)\r\n{\r\nstruct mlme_priv *mlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct sta_info *psta;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct list_head *phead, *plist, *ptmp;\r\nu8 chk_alive_num = 0;\r\nstruct sta_info *chk_alive_list[NUM_STA];\r\nint i;\r\nrtw_setopmode_cmd23a(padapter, NL80211_IFTYPE_AP);\r\nset_channel_bwmode23a(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);\r\nstart_bss_network(padapter, (u8 *)&mlmepriv->cur_network.network);\r\nif (padapter->securitypriv.dot11PrivacyAlgrthm ==\r\nWLAN_CIPHER_SUITE_TKIP ||\r\npadapter->securitypriv.dot11PrivacyAlgrthm ==\r\nWLAN_CIPHER_SUITE_CCMP) {\r\nrtw_set_key23a(padapter, psecuritypriv,\r\npsecuritypriv->dot118021XGrpKeyid, 0);\r\n}\r\nif (padapter->securitypriv.dot11PrivacyAlgrthm !=\r\nWLAN_CIPHER_SUITE_TKIP &&\r\npadapter->securitypriv.dot11PrivacyAlgrthm !=\r\nWLAN_CIPHER_SUITE_CCMP) {\r\nreturn;\r\n}\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npsta = container_of(plist, struct sta_info, asoc_list);\r\nchk_alive_list[chk_alive_num++] = psta;\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nfor (i = 0; i < chk_alive_num; i++) {\r\npsta = chk_alive_list[i];\r\nif (psta->state & _FW_LINKED) {\r\nUpdate_RA_Entry23a(padapter, psta);\r\nrtw_setstakey_cmd23a(padapter, (unsigned char *)psta, true);\r\n}\r\n}\r\n}\r\nvoid start_ap_mode23a(struct rtw_adapter *padapter)\r\n{\r\nint i;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\npmlmepriv->update_bcn = false;\r\npmlmeext->bstart_bss = false;\r\npmlmepriv->num_sta_non_erp = 0;\r\npmlmepriv->num_sta_no_short_slot_time = 0;\r\npmlmepriv->num_sta_no_short_preamble = 0;\r\npmlmepriv->num_sta_ht_no_gf = 0;\r\npmlmepriv->num_sta_no_ht = 0;\r\npmlmepriv->num_sta_ht_20mhz = 0;\r\npmlmepriv->olbc = false;\r\npmlmepriv->olbc_ht = false;\r\npmlmepriv->ht_op_mode = 0;\r\nfor (i = 0; i < NUM_STA; i++)\r\npstapriv->sta_aid[i] = NULL;\r\nINIT_LIST_HEAD(&pacl_list->acl_node_q.queue);\r\npacl_list->num = 0;\r\npacl_list->mode = 0;\r\nfor (i = 0; i < NUM_ACL; i++) {\r\nINIT_LIST_HEAD(&pacl_list->aclnode[i].list);\r\npacl_list->aclnode[i].valid = false;\r\n}\r\n}\r\nvoid stop_ap_mode23a(struct rtw_adapter *padapter)\r\n{\r\nstruct list_head *phead, *plist, *ptmp;\r\nstruct rtw_wlan_acl_node *paclnode;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct wlan_acl_pool *pacl_list = &pstapriv->acl_list;\r\nstruct rtw_queue *pacl_node_q = &pacl_list->acl_node_q;\r\npmlmepriv->update_bcn = false;\r\npmlmeext->bstart_bss = false;\r\nmemset((unsigned char *)&padapter->securitypriv, 0, sizeof(struct security_priv));\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;\r\nspin_lock_bh(&pacl_node_q->lock);\r\nphead = get_list_head(pacl_node_q);\r\nlist_for_each_safe(plist, ptmp, phead) {\r\npaclnode = container_of(plist, struct rtw_wlan_acl_node, list);\r\nif (paclnode->valid == true) {\r\npaclnode->valid = false;\r\nlist_del_init(&paclnode->list);\r\npacl_list->num--;\r\n}\r\n}\r\nspin_unlock_bh(&pacl_node_q->lock);\r\nDBG_8723A("%s, free acl_node_queue, num =%d\n", __func__, pacl_list->num);\r\nrtw_sta_flush23a(padapter);\r\nrtw_free_all_stainfo23a(padapter);\r\npsta = rtw_get_bcmc_stainfo23a(padapter);\r\nspin_lock_bh(&pstapriv->sta_hash_lock);\r\nrtw_free_stainfo23a(padapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nrtw_init_bcmc_stainfo23a(padapter);\r\nrtw23a_free_mlme_priv_ie_data(pmlmepriv);\r\n}
