static int hda_codec_match(struct hdac_device *dev, struct hdac_driver *drv)\r\n{\r\nstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\r\nstruct hda_codec_driver *driver =\r\ncontainer_of(drv, struct hda_codec_driver, core);\r\nconst struct hda_codec_preset *preset;\r\nu32 id = codec->probe_id ? codec->probe_id : codec->core.vendor_id;\r\nfor (preset = driver->preset; preset->id; preset++) {\r\nif (preset->id == id &&\r\n(!preset->rev || preset->rev == codec->core.revision_id)) {\r\ncodec->preset = preset;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void hda_codec_unsol_event(struct hdac_device *dev, unsigned int ev)\r\n{\r\nstruct hda_codec *codec = container_of(dev, struct hda_codec, core);\r\nif (codec->patch_ops.unsol_event)\r\ncodec->patch_ops.unsol_event(codec, ev);\r\n}\r\nstatic int codec_refresh_name(struct hda_codec *codec, const char *name)\r\n{\r\nif (name) {\r\nkfree(codec->core.chip_name);\r\ncodec->core.chip_name = kstrdup(name, GFP_KERNEL);\r\n}\r\nreturn codec->core.chip_name ? 0 : -ENOMEM;\r\n}\r\nstatic int hda_codec_driver_probe(struct device *dev)\r\n{\r\nstruct hda_codec *codec = dev_to_hda_codec(dev);\r\nstruct module *owner = dev->driver->owner;\r\nint err;\r\nif (WARN_ON(!codec->preset))\r\nreturn -EINVAL;\r\nerr = codec_refresh_name(codec, codec->preset->name);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hdac_regmap_init(&codec->core);\r\nif (err < 0)\r\ngoto error;\r\nif (!try_module_get(owner)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nerr = codec->preset->patch(codec);\r\nif (err < 0)\r\ngoto error_module;\r\nerr = snd_hda_codec_build_pcms(codec);\r\nif (err < 0)\r\ngoto error_module;\r\nerr = snd_hda_codec_build_controls(codec);\r\nif (err < 0)\r\ngoto error_module;\r\nif (codec->card->registered) {\r\nerr = snd_card_register(codec->card);\r\nif (err < 0)\r\ngoto error_module;\r\nsnd_hda_codec_register(codec);\r\n}\r\ncodec->core.lazy_cache = true;\r\nreturn 0;\r\nerror_module:\r\nmodule_put(owner);\r\nerror:\r\nsnd_hda_codec_cleanup_for_unbind(codec);\r\nreturn err;\r\n}\r\nstatic int hda_codec_driver_remove(struct device *dev)\r\n{\r\nstruct hda_codec *codec = dev_to_hda_codec(dev);\r\nif (codec->patch_ops.free)\r\ncodec->patch_ops.free(codec);\r\nsnd_hda_codec_cleanup_for_unbind(codec);\r\nmodule_put(dev->driver->owner);\r\nreturn 0;\r\n}\r\nstatic void hda_codec_driver_shutdown(struct device *dev)\r\n{\r\nstruct hda_codec *codec = dev_to_hda_codec(dev);\r\nif (!pm_runtime_suspended(dev) && codec->patch_ops.reboot_notify)\r\ncodec->patch_ops.reboot_notify(codec);\r\n}\r\nint __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,\r\nstruct module *owner)\r\n{\r\ndrv->core.driver.name = name;\r\ndrv->core.driver.owner = owner;\r\ndrv->core.driver.bus = &snd_hda_bus_type;\r\ndrv->core.driver.probe = hda_codec_driver_probe;\r\ndrv->core.driver.remove = hda_codec_driver_remove;\r\ndrv->core.driver.shutdown = hda_codec_driver_shutdown;\r\ndrv->core.driver.pm = &hda_codec_driver_pm;\r\ndrv->core.type = HDA_DEV_LEGACY;\r\ndrv->core.match = hda_codec_match;\r\ndrv->core.unsol_event = hda_codec_unsol_event;\r\nreturn driver_register(&drv->core.driver);\r\n}\r\nvoid hda_codec_driver_unregister(struct hda_codec_driver *drv)\r\n{\r\ndriver_unregister(&drv->core.driver);\r\n}\r\nstatic inline bool codec_probed(struct hda_codec *codec)\r\n{\r\nreturn device_attach(hda_codec_dev(codec)) > 0 && codec->preset;\r\n}\r\nstatic void codec_bind_module(struct hda_codec *codec)\r\n{\r\n#ifdef MODULE\r\nrequest_module("snd-hda-codec-id:%08x", codec->core.vendor_id);\r\nif (codec_probed(codec))\r\nreturn;\r\nrequest_module("snd-hda-codec-id:%04x*",\r\n(codec->core.vendor_id >> 16) & 0xffff);\r\nif (codec_probed(codec))\r\nreturn;\r\n#endif\r\n}\r\nstatic bool is_likely_hdmi_codec(struct hda_codec *codec)\r\n{\r\nhda_nid_t nid;\r\nfor_each_hda_codec_node(nid, codec) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nswitch (get_wcaps_type(wcaps)) {\r\ncase AC_WID_AUD_IN:\r\nreturn false;\r\ncase AC_WID_AUD_OUT:\r\nif (!(wcaps & AC_WCAP_DIGITAL))\r\nreturn false;\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int codec_bind_generic(struct hda_codec *codec)\r\n{\r\nif (codec->probe_id)\r\nreturn -ENODEV;\r\nif (is_likely_hdmi_codec(codec)) {\r\ncodec->probe_id = HDA_CODEC_ID_GENERIC_HDMI;\r\n#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)\r\nrequest_module("snd-hda-codec-hdmi");\r\n#endif\r\nif (codec_probed(codec))\r\nreturn 0;\r\n}\r\ncodec->probe_id = HDA_CODEC_ID_GENERIC;\r\n#if IS_MODULE(CONFIG_SND_HDA_GENERIC)\r\nrequest_module("snd-hda-codec-generic");\r\n#endif\r\nif (codec_probed(codec))\r\nreturn 0;\r\nreturn -ENODEV;\r\n}\r\nint snd_hda_codec_configure(struct hda_codec *codec)\r\n{\r\nint err;\r\nif (is_generic_config(codec))\r\ncodec->probe_id = HDA_CODEC_ID_GENERIC;\r\nelse\r\ncodec->probe_id = 0;\r\nerr = snd_hdac_device_register(&codec->core);\r\nif (err < 0)\r\nreturn err;\r\nif (!codec->preset)\r\ncodec_bind_module(codec);\r\nif (!codec->preset) {\r\nerr = codec_bind_generic(codec);\r\nif (err < 0) {\r\ncodec_err(codec, "Unable to bind the codec\n");\r\ngoto error;\r\n}\r\n}\r\nif (codec->core.afg || !*codec->card->mixername)\r\nsnprintf(codec->card->mixername,\r\nsizeof(codec->card->mixername), "%s %s",\r\ncodec->core.vendor_name, codec->core.chip_name);\r\nreturn 0;\r\nerror:\r\nsnd_hdac_device_unregister(&codec->core);\r\nreturn err;\r\n}
