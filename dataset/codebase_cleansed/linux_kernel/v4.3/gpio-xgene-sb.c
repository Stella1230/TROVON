static inline struct xgene_gpio_sb *to_xgene_gpio_sb(struct gpio_chip *gc)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nreturn container_of(bgc, struct xgene_gpio_sb, bgc);\r\n}\r\nstatic void xgene_gpio_set_bit(struct bgpio_chip *bgc, void __iomem *reg, u32 gpio, int val)\r\n{\r\nu32 data;\r\ndata = bgc->read_reg(reg);\r\nif (val)\r\ndata |= GPIO_MASK(gpio);\r\nelse\r\ndata &= ~GPIO_MASK(gpio);\r\nbgc->write_reg(reg, data);\r\n}\r\nstatic int apm_gpio_sb_to_irq(struct gpio_chip *gc, u32 gpio)\r\n{\r\nstruct xgene_gpio_sb *priv = to_xgene_gpio_sb(gc);\r\nif (priv->irq[gpio])\r\nreturn priv->irq[gpio];\r\nreturn -ENXIO;\r\n}\r\nstatic int xgene_gpio_sb_probe(struct platform_device *pdev)\r\n{\r\nstruct xgene_gpio_sb *priv;\r\nu32 ret, i;\r\nu32 default_lines[] = {0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D};\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nret = bgpio_init(&priv->bgc, &pdev->dev, 4,\r\nregs + MPA_GPIO_IN_ADDR,\r\nregs + MPA_GPIO_OUT_ADDR, NULL,\r\nregs + MPA_GPIO_OE_ADDR, NULL, 0);\r\nif (ret)\r\nreturn ret;\r\npriv->bgc.gc.to_irq = apm_gpio_sb_to_irq;\r\npriv->bgc.gc.ngpio = XGENE_MAX_GPIO_DS;\r\npriv->nirq = XGENE_MAX_GPIO_DS_IRQ;\r\npriv->irq = devm_kzalloc(&pdev->dev, sizeof(u32) * XGENE_MAX_GPIO_DS,\r\nGFP_KERNEL);\r\nif (!priv->irq)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < priv->nirq; i++) {\r\npriv->irq[default_lines[i]] = platform_get_irq(pdev, i);\r\nxgene_gpio_set_bit(&priv->bgc, regs + MPA_GPIO_SEL_LO,\r\ndefault_lines[i] * 2, 1);\r\nxgene_gpio_set_bit(&priv->bgc, regs + MPA_GPIO_INT_LVL, i, 1);\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nret = gpiochip_add(&priv->bgc.gc);\r\nif (ret)\r\ndev_err(&pdev->dev, "failed to register X-Gene GPIO Standby driver\n");\r\nelse\r\ndev_info(&pdev->dev, "X-Gene GPIO Standby driver registered\n");\r\nif (priv->nirq > 0) {\r\nacpi_gpiochip_request_interrupts(&priv->bgc.gc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int xgene_gpio_sb_remove(struct platform_device *pdev)\r\n{\r\nstruct xgene_gpio_sb *priv = platform_get_drvdata(pdev);\r\nif (priv->nirq > 0) {\r\nacpi_gpiochip_free_interrupts(&priv->bgc.gc);\r\n}\r\nreturn bgpio_remove(&priv->bgc);\r\n}
