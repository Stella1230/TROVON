static int irda_insert_no_value(void *self, __u8 *buf, int len, __u8 pi,\r\nPV_TYPE type, PI_HANDLER func)\r\n{\r\nirda_param_t p;\r\nint ret;\r\np.pi = pi;\r\np.pl = 0;\r\nret = (*func)(self, &p, PV_GET);\r\nirda_param_pack(buf, "bb", p.pi, p.pl);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 2;\r\n}\r\nstatic int irda_extract_no_value(void *self, __u8 *buf, int len, __u8 pi,\r\nPV_TYPE type, PI_HANDLER func)\r\n{\r\nirda_param_t p;\r\nint ret;\r\nirda_param_unpack(buf, "bb", &p.pi, &p.pl);\r\nret = (*func)(self, &p, PV_PUT);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 2;\r\n}\r\nstatic int irda_insert_integer(void *self, __u8 *buf, int len, __u8 pi,\r\nPV_TYPE type, PI_HANDLER func)\r\n{\r\nirda_param_t p;\r\nint n = 0;\r\nint err;\r\np.pi = pi;\r\np.pl = type & PV_MASK;\r\np.pv.i = 0;\r\nerr = (*func)(self, &p, PV_GET);\r\nif (err < 0)\r\nreturn err;\r\nif (p.pl == 0) {\r\nif (p.pv.i < 0xff) {\r\npr_debug("%s(), using 1 byte\n", __func__);\r\np.pl = 1;\r\n} else if (p.pv.i < 0xffff) {\r\npr_debug("%s(), using 2 bytes\n", __func__);\r\np.pl = 2;\r\n} else {\r\npr_debug("%s(), using 4 bytes\n", __func__);\r\np.pl = 4;\r\n}\r\n}\r\nif (len < (2+p.pl)) {\r\nnet_warn_ratelimited("%s: buffer too short for insertion!\n",\r\n__func__);\r\nreturn -1;\r\n}\r\npr_debug("%s(), pi=%#x, pl=%d, pi=%d\n", __func__,\r\np.pi, p.pl, p.pv.i);\r\nswitch (p.pl) {\r\ncase 1:\r\nn += irda_param_pack(buf, "bbb", p.pi, p.pl, (__u8) p.pv.i);\r\nbreak;\r\ncase 2:\r\nif (type & PV_BIG_ENDIAN)\r\np.pv.i = cpu_to_be16((__u16) p.pv.i);\r\nelse\r\np.pv.i = cpu_to_le16((__u16) p.pv.i);\r\nn += irda_param_pack(buf, "bbs", p.pi, p.pl, (__u16) p.pv.i);\r\nbreak;\r\ncase 4:\r\nif (type & PV_BIG_ENDIAN)\r\ncpu_to_be32s(&p.pv.i);\r\nelse\r\ncpu_to_le32s(&p.pv.i);\r\nn += irda_param_pack(buf, "bbi", p.pi, p.pl, p.pv.i);\r\nbreak;\r\ndefault:\r\nnet_warn_ratelimited("%s: length %d not supported\n",\r\n__func__, p.pl);\r\nreturn -1;\r\n}\r\nreturn p.pl+2;\r\n}\r\nstatic int irda_extract_integer(void *self, __u8 *buf, int len, __u8 pi,\r\nPV_TYPE type, PI_HANDLER func)\r\n{\r\nirda_param_t p;\r\nint n = 0;\r\nint extract_len;\r\nint err;\r\np.pi = pi;\r\np.pl = buf[1];\r\np.pv.i = 0;\r\nextract_len = p.pl;\r\nif (len < (2+p.pl)) {\r\nnet_warn_ratelimited("%s: buffer too short for parsing! Need %d bytes, but len is only %d\n",\r\n__func__, p.pl, len);\r\nreturn -1;\r\n}\r\nif (((type & PV_MASK) != PV_INTEGER) && ((type & PV_MASK) != p.pl)) {\r\nnet_err_ratelimited("%s: invalid parameter length! Expected %d bytes, but value had %d bytes!\n",\r\n__func__, type & PV_MASK, p.pl);\r\nif((p.pl < (type & PV_MASK)) || (type & PV_BIG_ENDIAN)) {\r\nreturn p.pl+2;\r\n} else {\r\nextract_len = type & PV_MASK;\r\n}\r\n}\r\nswitch (extract_len) {\r\ncase 1:\r\nn += irda_param_unpack(buf+2, "b", &p.pv.i);\r\nbreak;\r\ncase 2:\r\nn += irda_param_unpack(buf+2, "s", &p.pv.i);\r\nif (type & PV_BIG_ENDIAN)\r\np.pv.i = be16_to_cpu((__u16) p.pv.i);\r\nelse\r\np.pv.i = le16_to_cpu((__u16) p.pv.i);\r\nbreak;\r\ncase 4:\r\nn += irda_param_unpack(buf+2, "i", &p.pv.i);\r\nif (type & PV_BIG_ENDIAN)\r\nbe32_to_cpus(&p.pv.i);\r\nelse\r\nle32_to_cpus(&p.pv.i);\r\nbreak;\r\ndefault:\r\nnet_warn_ratelimited("%s: length %d not supported\n",\r\n__func__, p.pl);\r\nreturn p.pl+2;\r\n}\r\npr_debug("%s(), pi=%#x, pl=%d, pi=%d\n", __func__,\r\np.pi, p.pl, p.pv.i);\r\nerr = (*func)(self, &p, PV_PUT);\r\nif (err < 0)\r\nreturn err;\r\nreturn p.pl+2;\r\n}\r\nstatic int irda_extract_string(void *self, __u8 *buf, int len, __u8 pi,\r\nPV_TYPE type, PI_HANDLER func)\r\n{\r\nchar str[33];\r\nirda_param_t p;\r\nint err;\r\np.pi = pi;\r\np.pl = buf[1];\r\nif (p.pl > 32)\r\np.pl = 32;\r\npr_debug("%s(), pi=%#x, pl=%d\n", __func__,\r\np.pi, p.pl);\r\nif (len < (2+p.pl)) {\r\nnet_warn_ratelimited("%s: buffer too short for parsing! Need %d bytes, but len is only %d\n",\r\n__func__, p.pl, len);\r\nreturn -1;\r\n}\r\nstrncpy(str, buf+2, p.pl);\r\npr_debug("%s(), str=0x%02x 0x%02x\n",\r\n__func__, (__u8)str[0], (__u8)str[1]);\r\nstr[p.pl] = '\0';\r\np.pv.c = str;\r\nerr = (*func)(self, &p, PV_PUT);\r\nif (err < 0)\r\nreturn err;\r\nreturn p.pl+2;\r\n}\r\nstatic int irda_extract_octseq(void *self, __u8 *buf, int len, __u8 pi,\r\nPV_TYPE type, PI_HANDLER func)\r\n{\r\nirda_param_t p;\r\np.pi = pi;\r\np.pl = buf[1];\r\nif (len < (2+p.pl)) {\r\nnet_warn_ratelimited("%s: buffer too short for parsing! Need %d bytes, but len is only %d\n",\r\n__func__, p.pl, len);\r\nreturn -1;\r\n}\r\npr_debug("%s(), not impl\n", __func__);\r\nreturn p.pl+2;\r\n}\r\nint irda_param_pack(__u8 *buf, char *fmt, ...)\r\n{\r\nirda_pv_t arg;\r\nva_list args;\r\nchar *p;\r\nint n = 0;\r\nva_start(args, fmt);\r\nfor (p = fmt; *p != '\0'; p++) {\r\nswitch (*p) {\r\ncase 'b':\r\nbuf[n++] = (__u8)va_arg(args, int);\r\nbreak;\r\ncase 's':\r\narg.i = (__u16)va_arg(args, int);\r\nput_unaligned((__u16)arg.i, (__u16 *)(buf+n)); n+=2;\r\nbreak;\r\ncase 'i':\r\narg.i = va_arg(args, __u32);\r\nput_unaligned(arg.i, (__u32 *)(buf+n)); n+=4;\r\nbreak;\r\n#if 0\r\ncase 'c':\r\narg.c = va_arg(args, char *);\r\nstrcpy(buf+n, arg.c);\r\nn += strlen(arg.c) + 1;\r\nbreak;\r\n#endif\r\ndefault:\r\nva_end(args);\r\nreturn -1;\r\n}\r\n}\r\nva_end(args);\r\nreturn 0;\r\n}\r\nstatic int irda_param_unpack(__u8 *buf, char *fmt, ...)\r\n{\r\nirda_pv_t arg;\r\nva_list args;\r\nchar *p;\r\nint n = 0;\r\nva_start(args, fmt);\r\nfor (p = fmt; *p != '\0'; p++) {\r\nswitch (*p) {\r\ncase 'b':\r\narg.ip = va_arg(args, __u32 *);\r\n*arg.ip = buf[n++];\r\nbreak;\r\ncase 's':\r\narg.ip = va_arg(args, __u32 *);\r\n*arg.ip = get_unaligned((__u16 *)(buf+n)); n+=2;\r\nbreak;\r\ncase 'i':\r\narg.ip = va_arg(args, __u32 *);\r\n*arg.ip = get_unaligned((__u32 *)(buf+n)); n+=4;\r\nbreak;\r\n#if 0\r\ncase 'c':\r\narg.c = va_arg(args, char *);\r\nstrcpy(arg.c, buf+n);\r\nn += strlen(arg.c) + 1;\r\nbreak;\r\n#endif\r\ndefault:\r\nva_end(args);\r\nreturn -1;\r\n}\r\n}\r\nva_end(args);\r\nreturn 0;\r\n}\r\nint irda_param_insert(void *self, __u8 pi, __u8 *buf, int len,\r\npi_param_info_t *info)\r\n{\r\nconst pi_minor_info_t *pi_minor_info;\r\n__u8 pi_minor;\r\n__u8 pi_major;\r\nint type;\r\nint ret = -1;\r\nint n = 0;\r\nIRDA_ASSERT(buf != NULL, return ret;);\r\nIRDA_ASSERT(info != NULL, return ret;);\r\npi_minor = pi & info->pi_mask;\r\npi_major = pi >> info->pi_major_offset;\r\nif ((pi_major > info->len-1) ||\r\n(pi_minor > info->tables[pi_major].len-1))\r\n{\r\npr_debug("%s(), no handler for parameter=0x%02x\n",\r\n__func__, pi);\r\nreturn -1;\r\n}\r\npi_minor_info = &info->tables[pi_major].pi_minor_call_table[pi_minor];\r\ntype = pi_minor_info->type;\r\nif (!pi_minor_info->func) {\r\nnet_info_ratelimited("%s: no handler for pi=%#x\n",\r\n__func__, pi);\r\nreturn -1;\r\n}\r\nret = (*pv_insert_table[type & PV_MASK])(self, buf+n, len, pi, type,\r\npi_minor_info->func);\r\nreturn ret;\r\n}\r\nstatic int irda_param_extract(void *self, __u8 *buf, int len,\r\npi_param_info_t *info)\r\n{\r\nconst pi_minor_info_t *pi_minor_info;\r\n__u8 pi_minor;\r\n__u8 pi_major;\r\nint type;\r\nint ret = -1;\r\nint n = 0;\r\nIRDA_ASSERT(buf != NULL, return ret;);\r\nIRDA_ASSERT(info != NULL, return ret;);\r\npi_minor = buf[n] & info->pi_mask;\r\npi_major = buf[n] >> info->pi_major_offset;\r\nif ((pi_major > info->len-1) ||\r\n(pi_minor > info->tables[pi_major].len-1))\r\n{\r\npr_debug("%s(), no handler for parameter=0x%02x\n",\r\n__func__, buf[0]);\r\nreturn 2 + buf[n + 1];\r\n}\r\npi_minor_info = &info->tables[pi_major].pi_minor_call_table[pi_minor];\r\ntype = pi_minor_info->type;\r\npr_debug("%s(), pi=[%d,%d], type=%d\n", __func__,\r\npi_major, pi_minor, type);\r\nif (!pi_minor_info->func) {\r\nnet_info_ratelimited("%s: no handler for pi=%#x\n",\r\n__func__, buf[n]);\r\nreturn 2 + buf[n + 1];\r\n}\r\nret = (*pv_extract_table[type & PV_MASK])(self, buf+n, len, buf[n],\r\ntype, pi_minor_info->func);\r\nreturn ret;\r\n}\r\nint irda_param_extract_all(void *self, __u8 *buf, int len,\r\npi_param_info_t *info)\r\n{\r\nint ret = -1;\r\nint n = 0;\r\nIRDA_ASSERT(buf != NULL, return ret;);\r\nIRDA_ASSERT(info != NULL, return ret;);\r\nwhile (len > 2) {\r\nret = irda_param_extract(self, buf+n, len, info);\r\nif (ret < 0)\r\nreturn ret;\r\nn += ret;\r\nlen -= ret;\r\n}\r\nreturn n;\r\n}
