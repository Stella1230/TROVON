static int anysee_ctrl_msg(struct dvb_usb_device *d,\r\nu8 *sbuf, u8 slen, u8 *rbuf, u8 rlen)\r\n{\r\nstruct anysee_state *state = d_to_priv(d);\r\nint act_len, ret, i;\r\nmutex_lock(&d->usb_mutex);\r\nmemcpy(&state->buf[0], sbuf, slen);\r\nstate->buf[60] = state->seq++;\r\ndev_dbg(&d->udev->dev, "%s: >>> %*ph\n", __func__, slen, state->buf);\r\nret = dvb_usbv2_generic_rw_locked(d, state->buf, sizeof(state->buf),\r\nstate->buf, sizeof(state->buf));\r\nif (ret)\r\ngoto error_unlock;\r\nfor (i = 0; i < 3; i++) {\r\nret = usb_bulk_msg(d->udev, usb_rcvbulkpipe(d->udev,\r\nd->props->generic_bulk_ctrl_endpoint),\r\nstate->buf, sizeof(state->buf), &act_len, 2000);\r\nif (ret) {\r\ndev_dbg(&d->udev->dev,\r\n"%s: recv bulk message failed=%d\n",\r\n__func__, ret);\r\n} else {\r\ndev_dbg(&d->udev->dev, "%s: <<< %*ph\n", __func__,\r\nrlen, state->buf);\r\nif (state->buf[63] != 0x4f)\r\ndev_dbg(&d->udev->dev,\r\n"%s: cmd failed\n", __func__);\r\nbreak;\r\n}\r\n}\r\nif (ret) {\r\ndev_err(&d->udev->dev, "%s: recv bulk message failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto error_unlock;\r\n}\r\nif (rbuf && rlen)\r\nmemcpy(rbuf, state->buf, rlen);\r\nerror_unlock:\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int anysee_read_reg(struct dvb_usb_device *d, u16 reg, u8 *val)\r\n{\r\nu8 buf[] = {CMD_REG_READ, reg >> 8, reg & 0xff, 0x01};\r\nint ret;\r\nret = anysee_ctrl_msg(d, buf, sizeof(buf), val, 1);\r\ndev_dbg(&d->udev->dev, "%s: reg=%04x val=%02x\n", __func__, reg, *val);\r\nreturn ret;\r\n}\r\nstatic int anysee_write_reg(struct dvb_usb_device *d, u16 reg, u8 val)\r\n{\r\nu8 buf[] = {CMD_REG_WRITE, reg >> 8, reg & 0xff, 0x01, val};\r\ndev_dbg(&d->udev->dev, "%s: reg=%04x val=%02x\n", __func__, reg, val);\r\nreturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\r\n}\r\nstatic int anysee_wr_reg_mask(struct dvb_usb_device *d, u16 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = anysee_read_reg(d, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn anysee_write_reg(d, reg, val);\r\n}\r\nstatic int anysee_rd_reg_mask(struct dvb_usb_device *d, u16 reg, u8 *val,\r\nu8 mask)\r\n{\r\nint ret, i;\r\nu8 tmp;\r\nret = anysee_read_reg(d, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\ntmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = tmp >> i;\r\nreturn 0;\r\n}\r\nstatic int anysee_get_hw_info(struct dvb_usb_device *d, u8 *id)\r\n{\r\nu8 buf[] = {CMD_GET_HW_INFO};\r\nreturn anysee_ctrl_msg(d, buf, sizeof(buf), id, 3);\r\n}\r\nstatic int anysee_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nu8 buf[] = {CMD_STREAMING_CTRL, (u8)onoff, 0x00};\r\ndev_dbg(&fe_to_d(fe)->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nreturn anysee_ctrl_msg(fe_to_d(fe), buf, sizeof(buf), NULL, 0);\r\n}\r\nstatic int anysee_led_ctrl(struct dvb_usb_device *d, u8 mode, u8 interval)\r\n{\r\nu8 buf[] = {CMD_LED_AND_IR_CTRL, 0x01, mode, interval};\r\ndev_dbg(&d->udev->dev, "%s: state=%d interval=%d\n", __func__,\r\nmode, interval);\r\nreturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\r\n}\r\nstatic int anysee_ir_ctrl(struct dvb_usb_device *d, u8 onoff)\r\n{\r\nu8 buf[] = {CMD_LED_AND_IR_CTRL, 0x02, onoff};\r\ndev_dbg(&d->udev->dev, "%s: onoff=%d\n", __func__, onoff);\r\nreturn anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\r\n}\r\nstatic int anysee_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0, inc, i = 0;\r\nu8 buf[52];\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nwhile (i < num) {\r\nif (num > i + 1 && (msg[i+1].flags & I2C_M_RD)) {\r\nif (msg[i].len > 2 || msg[i+1].len > 60) {\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nbuf[0] = CMD_I2C_READ;\r\nbuf[1] = (msg[i].addr << 1) | 0x01;\r\nbuf[2] = msg[i].buf[0];\r\nbuf[3] = msg[i].buf[1];\r\nbuf[4] = msg[i].len-1;\r\nbuf[5] = msg[i+1].len;\r\nret = anysee_ctrl_msg(d, buf, 6, msg[i+1].buf,\r\nmsg[i+1].len);\r\ninc = 2;\r\n} else {\r\nif (msg[i].len > 48) {\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nbuf[0] = CMD_I2C_WRITE;\r\nbuf[1] = (msg[i].addr << 1);\r\nbuf[2] = msg[i].len;\r\nbuf[3] = 0x01;\r\nmemcpy(&buf[4], msg[i].buf, msg[i].len);\r\nret = anysee_ctrl_msg(d, buf, 4 + msg[i].len, NULL, 0);\r\ninc = 1;\r\n}\r\nif (ret)\r\nbreak;\r\ni += inc;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret ? ret : i;\r\n}\r\nstatic u32 anysee_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int anysee_mt352_demod_init(struct dvb_frontend *fe)\r\n{\r\nstatic u8 clock_config[] = { CLOCK_CTL, 0x38, 0x28 };\r\nstatic u8 reset[] = { RESET, 0x80 };\r\nstatic u8 adc_ctl_1_cfg[] = { ADC_CTL_1, 0x40 };\r\nstatic u8 agc_cfg[] = { AGC_TARGET, 0x28, 0x20 };\r\nstatic u8 gpp_ctl_cfg[] = { GPP_CTL, 0x33 };\r\nstatic u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };\r\nmt352_write(fe, clock_config, sizeof(clock_config));\r\nudelay(200);\r\nmt352_write(fe, reset, sizeof(reset));\r\nmt352_write(fe, adc_ctl_1_cfg, sizeof(adc_ctl_1_cfg));\r\nmt352_write(fe, agc_cfg, sizeof(agc_cfg));\r\nmt352_write(fe, gpp_ctl_cfg, sizeof(gpp_ctl_cfg));\r\nmt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));\r\nreturn 0;\r\n}\r\nstatic int anysee_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct anysee_state *state = d_to_priv(d);\r\nint ret;\r\nu8 hw_info[3];\r\nret = anysee_get_hw_info(d, hw_info);\r\nif (ret)\r\ngoto error;\r\nret = anysee_get_hw_info(d, hw_info);\r\nif (ret)\r\ngoto error;\r\ndev_info(&d->udev->dev, "%s: firmware version %d.%d hardware id %d\n",\r\nKBUILD_MODNAME, hw_info[1], hw_info[2], hw_info[0]);\r\nstate->hw = hw_info[0];\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int anysee_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nreturn anysee_wr_reg_mask(fe_to_d(fe), REG_IOE, (enable << 4), 0x10);\r\n}\r\nstatic int anysee_frontend_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct anysee_state *state = fe_to_priv(fe);\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s: fe=%d onoff=%d\n", __func__, fe->id, onoff);\r\nif (onoff == 0)\r\nreturn 0;\r\nswitch (state->hw) {\r\ncase ANYSEE_HW_507FA:\r\nif (fe->id == 0) {\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOE, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\n} else {\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOE, (0 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\n}\r\nbreak;\r\ncase ANYSEE_HW_508TC:\r\ncase ANYSEE_HW_508PTC:\r\nif (fe->id == 0) {\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 6), 0x40);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOE, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\n} else {\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 6), 0x40);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOE, (0 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\n}\r\nbreak;\r\ndefault:\r\nret = 0;\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int anysee_add_i2c_dev(struct dvb_usb_device *d, const char *type,\r\nu8 addr, void *platform_data)\r\n{\r\nint ret, num;\r\nstruct anysee_state *state = d_to_priv(d);\r\nstruct i2c_client *client;\r\nstruct i2c_adapter *adapter = &d->i2c_adap;\r\nstruct i2c_board_info board_info = {\r\n.addr = addr,\r\n.platform_data = platform_data,\r\n};\r\nstrlcpy(board_info.type, type, I2C_NAME_SIZE);\r\nfor (num = 0; num < ANYSEE_I2C_CLIENT_MAX; num++) {\r\nif (state->i2c_client[num] == NULL)\r\nbreak;\r\n}\r\ndev_dbg(&d->udev->dev, "%s: num=%d\n", __func__, num);\r\nif (num == ANYSEE_I2C_CLIENT_MAX) {\r\ndev_err(&d->udev->dev, "%s: I2C client out of index\n",\r\nKBUILD_MODNAME);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nrequest_module("%s", board_info.type);\r\nclient = i2c_new_device(adapter, &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nstate->i2c_client[num] = client;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void anysee_del_i2c_dev(struct dvb_usb_device *d)\r\n{\r\nint num;\r\nstruct anysee_state *state = d_to_priv(d);\r\nstruct i2c_client *client;\r\nnum = ANYSEE_I2C_CLIENT_MAX;\r\nwhile (num--) {\r\nif (state->i2c_client[num] != NULL)\r\nbreak;\r\n}\r\ndev_dbg(&d->udev->dev, "%s: num=%d\n", __func__, num);\r\nif (num == -1) {\r\ndev_err(&d->udev->dev, "%s: I2C client out of index\n",\r\nKBUILD_MODNAME);\r\ngoto err;\r\n}\r\nclient = state->i2c_client[num];\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\nstate->i2c_client[num] = NULL;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed\n", __func__);\r\n}\r\nstatic int anysee_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct anysee_state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\nu8 tmp;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = 0x60,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = "\x00",\r\n}, {\r\n.addr = 0x60,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &tmp,\r\n}\r\n};\r\nswitch (state->hw) {\r\ncase ANYSEE_HW_507T:\r\nadap->fe[0] = dvb_attach(mt352_attach, &anysee_mt352_config,\r\n&d->i2c_adap);\r\nif (adap->fe[0])\r\nbreak;\r\nadap->fe[0] = dvb_attach(zl10353_attach, &anysee_zl10353_config,\r\n&d->i2c_adap);\r\nbreak;\r\ncase ANYSEE_HW_507CD:\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOA, (0 << 7), 0x80);\r\nif (ret)\r\ngoto error;\r\nadap->fe[0] = dvb_attach(zl10353_attach, &anysee_zl10353_config,\r\n&d->i2c_adap);\r\nbreak;\r\ncase ANYSEE_HW_507DC:\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nadap->fe[0] = dvb_attach(tda10023_attach,\r\n&anysee_tda10023_config, &d->i2c_adap, 0x48);\r\nbreak;\r\ncase ANYSEE_HW_507SI:\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nadap->fe[0] = dvb_attach(cx24116_attach, &anysee_cx24116_config,\r\n&d->i2c_adap);\r\nbreak;\r\ncase ANYSEE_HW_507FA:\r\nret = anysee_wr_reg_mask(d, REG_IOE, (1 << 4), 0x10);\r\nif (ret)\r\ngoto error;\r\ntmp = 0;\r\nret = i2c_transfer(&d->i2c_adap, msg, 2);\r\nif (ret == 2 && tmp == 0xc7) {\r\ndev_dbg(&d->udev->dev, "%s: TDA18212 found\n",\r\n__func__);\r\nstate->has_tda18212 = true;\r\n}\r\nelse\r\ntmp = 0;\r\nret = anysee_wr_reg_mask(d, REG_IOE, (0 << 4), 0x10);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nif (tmp == 0xc7) {\r\nadap->fe[0] = dvb_attach(tda10023_attach,\r\n&anysee_tda10023_tda18212_config,\r\n&d->i2c_adap, 0x48);\r\nif (adap->fe[0])\r\nadap->fe[0]->ops.i2c_gate_ctrl =\r\nanysee_i2c_gate_ctrl;\r\n} else {\r\nadap->fe[0] = dvb_attach(tda10023_attach,\r\n&anysee_tda10023_config,\r\n&d->i2c_adap, 0x48);\r\n}\r\nif (!adap->fe[0])\r\nbreak;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 0), 0x01);\r\nif (ret)\r\ngoto error;\r\nif (tmp == 0xc7) {\r\nadap->fe[1] = dvb_attach(zl10353_attach,\r\n&anysee_zl10353_tda18212_config2,\r\n&d->i2c_adap);\r\nif (adap->fe[1])\r\nadap->fe[1]->ops.i2c_gate_ctrl =\r\nanysee_i2c_gate_ctrl;\r\n} else {\r\nadap->fe[1] = dvb_attach(zl10353_attach,\r\n&anysee_zl10353_config,\r\n&d->i2c_adap);\r\n}\r\nbreak;\r\ncase ANYSEE_HW_508TC:\r\ncase ANYSEE_HW_508PTC:\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 6), 0x40);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nadap->fe[0] = dvb_attach(tda10023_attach,\r\n&anysee_tda10023_tda18212_config,\r\n&d->i2c_adap, 0x48);\r\nif (adap->fe[0])\r\nadap->fe[0]->ops.i2c_gate_ctrl = anysee_i2c_gate_ctrl;\r\nif (!adap->fe[0])\r\nbreak;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 6), 0x40);\r\nif (ret)\r\ngoto error;\r\nadap->fe[1] = dvb_attach(zl10353_attach,\r\n&anysee_zl10353_tda18212_config,\r\n&d->i2c_adap);\r\nif (adap->fe[1])\r\nadap->fe[1]->ops.i2c_gate_ctrl = anysee_i2c_gate_ctrl;\r\nstate->has_ci = true;\r\nbreak;\r\ncase ANYSEE_HW_508S2:\r\ncase ANYSEE_HW_508PS2:\r\nret = anysee_wr_reg_mask(d, REG_IOE, (1 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nadap->fe[0] = dvb_attach(stv0900_attach,\r\n&anysee_stv0900_config, &d->i2c_adap, 0);\r\nstate->has_ci = true;\r\nbreak;\r\ncase ANYSEE_HW_508T2C:\r\nret = anysee_wr_reg_mask(d, REG_IOE, (1 << 5), 0x20);\r\nif (ret)\r\ngoto error;\r\nadap->fe[0] = dvb_attach(cxd2820r_attach,\r\n&anysee_cxd2820r_config, &d->i2c_adap, NULL);\r\nstate->has_ci = true;\r\nbreak;\r\n}\r\nif (!adap->fe[0]) {\r\nret = -ENODEV;\r\ndev_err(&d->udev->dev,\r\n"%s: Unsupported Anysee version. Please report to <linux-media@vger.kernel.org>.\n",\r\nKBUILD_MODNAME);\r\n}\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int anysee_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct anysee_state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct dvb_frontend *fe;\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nswitch (state->hw) {\r\ncase ANYSEE_HW_507T:\r\nfe = dvb_attach(dvb_pll_attach, adap->fe[0], (0xc2 >> 1), NULL,\r\nDVB_PLL_THOMSON_DTT7579);\r\nbreak;\r\ncase ANYSEE_HW_507CD:\r\nfe = dvb_attach(dvb_pll_attach, adap->fe[0], (0xc2 >> 1),\r\n&d->i2c_adap, DVB_PLL_THOMSON_DTT7579);\r\nbreak;\r\ncase ANYSEE_HW_507DC:\r\nfe = dvb_attach(dvb_pll_attach, adap->fe[0], (0xc0 >> 1),\r\n&d->i2c_adap, DVB_PLL_SAMSUNG_DTOS403IH102A);\r\nbreak;\r\ncase ANYSEE_HW_507SI:\r\nfe = dvb_attach(isl6423_attach, adap->fe[0], &d->i2c_adap,\r\n&anysee_isl6423_config);\r\nbreak;\r\ncase ANYSEE_HW_507FA:\r\nif (state->has_tda18212) {\r\nstruct tda18212_config tda18212_config =\r\nanysee_tda18212_config;\r\ntda18212_config.fe = adap->fe[0];\r\nret = anysee_add_i2c_dev(d, "tda18212", 0x60,\r\n&tda18212_config);\r\nif (ret)\r\ngoto err;\r\nif (adap->fe[1]) {\r\nadap->fe[1]->tuner_priv =\r\nadap->fe[0]->tuner_priv;\r\nmemcpy(&adap->fe[1]->ops.tuner_ops,\r\n&adap->fe[0]->ops.tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\n}\r\nreturn 0;\r\n} else {\r\nfe = dvb_attach(dvb_pll_attach, adap->fe[0],\r\n(0xc0 >> 1), &d->i2c_adap,\r\nDVB_PLL_SAMSUNG_DTOS403IH102A);\r\nif (fe && adap->fe[1]) {\r\nfe = dvb_attach(dvb_pll_attach, adap->fe[1],\r\n(0xc0 >> 1), &d->i2c_adap,\r\nDVB_PLL_SAMSUNG_DTOS403IH102A);\r\n}\r\n}\r\nbreak;\r\ncase ANYSEE_HW_508TC:\r\ncase ANYSEE_HW_508PTC:\r\n{\r\nstruct tda18212_config tda18212_config = anysee_tda18212_config;\r\ntda18212_config.fe = adap->fe[0];\r\nret = anysee_add_i2c_dev(d, "tda18212", 0x60, &tda18212_config);\r\nif (ret)\r\ngoto err;\r\nif (adap->fe[1]) {\r\nadap->fe[1]->tuner_priv = adap->fe[0]->tuner_priv;\r\nmemcpy(&adap->fe[1]->ops.tuner_ops,\r\n&adap->fe[0]->ops.tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\n}\r\nreturn 0;\r\n}\r\ncase ANYSEE_HW_508S2:\r\ncase ANYSEE_HW_508PS2:\r\nfe = dvb_attach(stv6110_attach, adap->fe[0],\r\n&anysee_stv6110_config, &d->i2c_adap);\r\nif (fe) {\r\nfe = dvb_attach(isl6423_attach, adap->fe[0],\r\n&d->i2c_adap, &anysee_isl6423_config);\r\n}\r\nbreak;\r\ncase ANYSEE_HW_508T2C:\r\n{\r\nstruct tda18212_config tda18212_config =\r\nanysee_tda18212_config2;\r\ntda18212_config.fe = adap->fe[0];\r\nret = anysee_add_i2c_dev(d, "tda18212", 0x60, &tda18212_config);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\n}\r\ndefault:\r\nfe = NULL;\r\n}\r\nif (fe)\r\nret = 0;\r\nelse\r\nret = -ENODEV;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int anysee_rc_query(struct dvb_usb_device *d)\r\n{\r\nu8 buf[] = {CMD_GET_IR_CODE};\r\nu8 ircode[2];\r\nint ret;\r\nret = anysee_ctrl_msg(d, buf, sizeof(buf), ircode, sizeof(ircode));\r\nif (ret)\r\nreturn ret;\r\nif (ircode[0]) {\r\ndev_dbg(&d->udev->dev, "%s: key pressed %02x\n", __func__,\r\nircode[1]);\r\nrc_keydown(d->rc_dev, RC_TYPE_NEC,\r\nRC_SCANCODE_NEC(0x08, ircode[1]), 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int anysee_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\nrc->allowed_protos = RC_BIT_NEC;\r\nrc->query = anysee_rc_query;\r\nrc->interval = 250;\r\nreturn 0;\r\n}\r\nstatic int anysee_ci_read_attribute_mem(struct dvb_ca_en50221 *ci, int slot,\r\nint addr)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nu8 buf[] = {CMD_CI, 0x02, 0x40 | addr >> 8, addr & 0xff, 0x00, 1};\r\nu8 val;\r\nret = anysee_ctrl_msg(d, buf, sizeof(buf), &val, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic int anysee_ci_write_attribute_mem(struct dvb_ca_en50221 *ci, int slot,\r\nint addr, u8 val)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nu8 buf[] = {CMD_CI, 0x03, 0x40 | addr >> 8, addr & 0xff, 0x00, 1, val};\r\nret = anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int anysee_ci_read_cam_control(struct dvb_ca_en50221 *ci, int slot,\r\nu8 addr)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nu8 buf[] = {CMD_CI, 0x04, 0x40, addr, 0x00, 1};\r\nu8 val;\r\nret = anysee_ctrl_msg(d, buf, sizeof(buf), &val, 1);\r\nif (ret)\r\nreturn ret;\r\nreturn val;\r\n}\r\nstatic int anysee_ci_write_cam_control(struct dvb_ca_en50221 *ci, int slot,\r\nu8 addr, u8 val)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nu8 buf[] = {CMD_CI, 0x05, 0x40, addr, 0x00, 1, val};\r\nret = anysee_ctrl_msg(d, buf, sizeof(buf), NULL, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int anysee_ci_slot_reset(struct dvb_ca_en50221 *ci, int slot)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nstruct anysee_state *state = d_to_priv(d);\r\nstate->ci_cam_ready = jiffies + msecs_to_jiffies(1000);\r\nret = anysee_wr_reg_mask(d, REG_IOA, (0 << 7), 0x80);\r\nif (ret)\r\nreturn ret;\r\nmsleep(300);\r\nret = anysee_wr_reg_mask(d, REG_IOA, (1 << 7), 0x80);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int anysee_ci_slot_shutdown(struct dvb_ca_en50221 *ci, int slot)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nret = anysee_wr_reg_mask(d, REG_IOA, (0 << 7), 0x80);\r\nif (ret)\r\nreturn ret;\r\nmsleep(30);\r\nret = anysee_wr_reg_mask(d, REG_IOA, (1 << 7), 0x80);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int anysee_ci_slot_ts_enable(struct dvb_ca_en50221 *ci, int slot)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nint ret;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 1), 0x02);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int anysee_ci_poll_slot_status(struct dvb_ca_en50221 *ci, int slot,\r\nint open)\r\n{\r\nstruct dvb_usb_device *d = ci->data;\r\nstruct anysee_state *state = d_to_priv(d);\r\nint ret;\r\nu8 tmp = 0;\r\nret = anysee_rd_reg_mask(d, REG_IOC, &tmp, 0x40);\r\nif (ret)\r\nreturn ret;\r\nif (tmp == 0) {\r\nret = DVB_CA_EN50221_POLL_CAM_PRESENT;\r\nif (time_after(jiffies, state->ci_cam_ready))\r\nret |= DVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\nreturn ret;\r\n}\r\nstatic int anysee_ci_init(struct dvb_usb_device *d)\r\n{\r\nstruct anysee_state *state = d_to_priv(d);\r\nint ret;\r\nstate->ci.owner = THIS_MODULE;\r\nstate->ci.read_attribute_mem = anysee_ci_read_attribute_mem;\r\nstate->ci.write_attribute_mem = anysee_ci_write_attribute_mem;\r\nstate->ci.read_cam_control = anysee_ci_read_cam_control;\r\nstate->ci.write_cam_control = anysee_ci_write_cam_control;\r\nstate->ci.slot_reset = anysee_ci_slot_reset;\r\nstate->ci.slot_shutdown = anysee_ci_slot_shutdown;\r\nstate->ci.slot_ts_enable = anysee_ci_slot_ts_enable;\r\nstate->ci.poll_slot_status = anysee_ci_poll_slot_status;\r\nstate->ci.data = d;\r\nret = anysee_wr_reg_mask(d, REG_IOA, (1 << 7), 0x80);\r\nif (ret)\r\nreturn ret;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (0 << 2)|(0 << 1)|(0 << 0), 0x07);\r\nif (ret)\r\nreturn ret;\r\nret = anysee_wr_reg_mask(d, REG_IOD, (1 << 2)|(1 << 1)|(1 << 0), 0x07);\r\nif (ret)\r\nreturn ret;\r\nret = dvb_ca_en50221_init(&d->adapter[0].dvb_adap, &state->ci, 0, 1);\r\nif (ret)\r\nreturn ret;\r\nstate->ci_attached = true;\r\nreturn 0;\r\n}\r\nstatic void anysee_ci_release(struct dvb_usb_device *d)\r\n{\r\nstruct anysee_state *state = d_to_priv(d);\r\nif (state->ci_attached)\r\ndvb_ca_en50221_release(&state->ci);\r\nreturn;\r\n}\r\nstatic int anysee_init(struct dvb_usb_device *d)\r\n{\r\nstruct anysee_state *state = d_to_priv(d);\r\nint ret;\r\nret = usb_set_interface(d->udev, 0, 0);\r\nif (ret)\r\nreturn ret;\r\nret = anysee_led_ctrl(d, 0x01, 0x03);\r\nif (ret)\r\nreturn ret;\r\nret = anysee_ir_ctrl(d, 1);\r\nif (ret)\r\nreturn ret;\r\nif (state->has_ci) {\r\nret = anysee_ci_init(d);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void anysee_exit(struct dvb_usb_device *d)\r\n{\r\nstruct anysee_state *state = d_to_priv(d);\r\nif (state->i2c_client[0])\r\nanysee_del_i2c_dev(d);\r\nreturn anysee_ci_release(d);\r\n}
