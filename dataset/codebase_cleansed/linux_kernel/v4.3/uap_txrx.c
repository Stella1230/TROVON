static bool\r\nmwifiex_uap_del_tx_pkts_in_ralist(struct mwifiex_private *priv,\r\nstruct list_head *ra_list_head)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nstruct sk_buff *skb, *tmp;\r\nbool pkt_deleted = false;\r\nstruct mwifiex_txinfo *tx_info;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nlist_for_each_entry(ra_list, ra_list_head, list) {\r\nif (skb_queue_empty(&ra_list->skb_head))\r\ncontinue;\r\nskb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\nif (tx_info->flags & MWIFIEX_BUF_FLAG_BRIDGED_PKT) {\r\n__skb_unlink(skb, &ra_list->skb_head);\r\nmwifiex_write_data_complete(adapter, skb, 0,\r\n-1);\r\natomic_dec(&priv->wmm.tx_pkts_queued);\r\npkt_deleted = true;\r\n}\r\nif ((atomic_read(&adapter->pending_bridged_pkts) <=\r\nMWIFIEX_BRIDGED_PKTS_THR_LOW))\r\nbreak;\r\n}\r\n}\r\nreturn pkt_deleted;\r\n}\r\nstatic void mwifiex_uap_cleanup_tx_queues(struct mwifiex_private *priv)\r\n{\r\nunsigned long flags;\r\nstruct list_head *ra_list;\r\nint i;\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nfor (i = 0; i < MAX_NUM_TID; i++, priv->del_list_idx++) {\r\nif (priv->del_list_idx == MAX_NUM_TID)\r\npriv->del_list_idx = 0;\r\nra_list = &priv->wmm.tid_tbl_ptr[priv->del_list_idx].ra_list;\r\nif (mwifiex_uap_del_tx_pkts_in_ralist(priv, ra_list)) {\r\npriv->del_list_idx++;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\n}\r\nstatic void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct uap_rxpd *uap_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nstruct sk_buff *new_skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nint hdr_chop;\r\nstruct ethhdr *p_ethhdr;\r\nstruct mwifiex_sta_node *src_node;\r\nuap_rx_pd = (struct uap_rxpd *)(skb->data);\r\nrx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\r\nif ((atomic_read(&adapter->pending_bridged_pkts) >=\r\nMWIFIEX_BRIDGED_PKTS_THR_HIGH)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Tx: Bridge packet limit reached. Drop packet!\n");\r\nkfree_skb(skb);\r\nmwifiex_uap_cleanup_tx_queues(priv);\r\nreturn;\r\n}\r\nif ((!memcmp(&rx_pkt_hdr->rfc1042_hdr, bridge_tunnel_header,\r\nsizeof(bridge_tunnel_header))) ||\r\n(!memcmp(&rx_pkt_hdr->rfc1042_hdr, rfc1042_header,\r\nsizeof(rfc1042_header)) &&\r\nntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_AARP &&\r\nntohs(rx_pkt_hdr->rfc1042_hdr.snap_type) != ETH_P_IPX)) {\r\np_ethhdr = (struct ethhdr *)\r\n((u8 *)(&rx_pkt_hdr->eth803_hdr)\r\n+ sizeof(rx_pkt_hdr->eth803_hdr)\r\n+ sizeof(rx_pkt_hdr->rfc1042_hdr)\r\n- sizeof(rx_pkt_hdr->eth803_hdr.h_dest)\r\n- sizeof(rx_pkt_hdr->eth803_hdr.h_source)\r\n- sizeof(rx_pkt_hdr->rfc1042_hdr.snap_type));\r\nmemcpy(p_ethhdr->h_source, rx_pkt_hdr->eth803_hdr.h_source,\r\nsizeof(p_ethhdr->h_source));\r\nmemcpy(p_ethhdr->h_dest, rx_pkt_hdr->eth803_hdr.h_dest,\r\nsizeof(p_ethhdr->h_dest));\r\nhdr_chop = (u8 *)p_ethhdr - (u8 *)uap_rx_pd;\r\n} else {\r\nhdr_chop = (u8 *)&rx_pkt_hdr->eth803_hdr - (u8 *)uap_rx_pd;\r\n}\r\nskb_pull(skb, hdr_chop);\r\nif (skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"data: Tx: insufficient skb headroom %d\n",\r\nskb_headroom(skb));\r\nnew_skb =\r\nskb_realloc_headroom(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\r\nif (unlikely(!new_skb)) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Tx: cannot allocate new_skb\n");\r\nkfree_skb(skb);\r\npriv->stats.tx_dropped++;\r\nreturn;\r\n}\r\nkfree_skb(skb);\r\nskb = new_skb;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: new skb headroom %d\n",\r\nskb_headroom(skb));\r\n}\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\nmemset(tx_info, 0, sizeof(*tx_info));\r\ntx_info->bss_num = priv->bss_num;\r\ntx_info->bss_type = priv->bss_type;\r\ntx_info->flags |= MWIFIEX_BUF_FLAG_BRIDGED_PKT;\r\nsrc_node = mwifiex_get_sta_entry(priv, rx_pkt_hdr->eth803_hdr.h_source);\r\nif (src_node) {\r\nsrc_node->stats.last_rx = jiffies;\r\nsrc_node->stats.rx_bytes += skb->len;\r\nsrc_node->stats.rx_packets++;\r\nsrc_node->stats.last_tx_rate = uap_rx_pd->rx_rate;\r\nsrc_node->stats.last_tx_htinfo = uap_rx_pd->ht_info;\r\n}\r\nif (is_unicast_ether_addr(rx_pkt_hdr->eth803_hdr.h_dest)) {\r\npriv->stats.rx_bytes += skb->len;\r\npriv->stats.rx_packets++;\r\ntx_info->pkt_len = skb->len;\r\n}\r\n__net_timestamp(skb);\r\nmwifiex_wmm_add_buf_txqueue(priv, skb);\r\natomic_inc(&adapter->tx_pending);\r\natomic_inc(&adapter->pending_bridged_pkts);\r\nreturn;\r\n}\r\nint mwifiex_handle_uap_rx_forward(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct uap_rxpd *uap_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nu8 ra[ETH_ALEN];\r\nstruct sk_buff *skb_uap;\r\nuap_rx_pd = (struct uap_rxpd *)(skb->data);\r\nrx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\r\nif (!priv->media_connected) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"drop packet in disconnected state.\n");\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nmemcpy(ra, rx_pkt_hdr->eth803_hdr.h_dest, ETH_ALEN);\r\nif (is_multicast_ether_addr(ra)) {\r\nskb_uap = skb_copy(skb, GFP_ATOMIC);\r\nmwifiex_uap_queue_bridged_pkt(priv, skb_uap);\r\n} else {\r\nif (mwifiex_get_sta_entry(priv, ra)) {\r\nmwifiex_uap_queue_bridged_pkt(priv, skb);\r\nreturn 0;\r\n}\r\n}\r\nreturn mwifiex_process_rx_packet(priv, skb);\r\n}\r\nint mwifiex_process_uap_rx_packet(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nstruct uap_rxpd *uap_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nu16 rx_pkt_type;\r\nu8 ta[ETH_ALEN], pkt_type;\r\nunsigned long flags;\r\nstruct mwifiex_sta_node *node;\r\nuap_rx_pd = (struct uap_rxpd *)(skb->data);\r\nrx_pkt_type = le16_to_cpu(uap_rx_pd->rx_pkt_type);\r\nrx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\r\nether_addr_copy(ta, rx_pkt_hdr->eth803_hdr.h_source);\r\nif ((le16_to_cpu(uap_rx_pd->rx_pkt_offset) +\r\nle16_to_cpu(uap_rx_pd->rx_pkt_length)) > (u16) skb->len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"wrong rx packet: len=%d, offset=%d, length=%d\n",\r\nskb->len, le16_to_cpu(uap_rx_pd->rx_pkt_offset),\r\nle16_to_cpu(uap_rx_pd->rx_pkt_length));\r\npriv->stats.rx_dropped++;\r\nnode = mwifiex_get_sta_entry(priv, ta);\r\nif (node)\r\nnode->stats.tx_failed++;\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nif (rx_pkt_type == PKT_TYPE_MGMT) {\r\nret = mwifiex_process_mgmt_packet(priv, skb);\r\nif (ret)\r\nmwifiex_dbg(adapter, ERROR,\r\n"Rx of mgmt packet failed");\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (rx_pkt_type != PKT_TYPE_BAR && uap_rx_pd->priority < MAX_NUM_TID) {\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nnode = mwifiex_get_sta_entry(priv, ta);\r\nif (node)\r\nnode->rx_seq[uap_rx_pd->priority] =\r\nle16_to_cpu(uap_rx_pd->seq_num);\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\n}\r\nif (!priv->ap_11n_enabled ||\r\n(!mwifiex_11n_get_rx_reorder_tbl(priv, uap_rx_pd->priority, ta) &&\r\n(le16_to_cpu(uap_rx_pd->rx_pkt_type) != PKT_TYPE_AMSDU))) {\r\nret = mwifiex_handle_uap_rx_forward(priv, skb);\r\nreturn ret;\r\n}\r\npkt_type = (u8)le16_to_cpu(uap_rx_pd->rx_pkt_type);\r\nret = mwifiex_11n_rx_reorder_pkt(priv, le16_to_cpu(uap_rx_pd->seq_num),\r\nuap_rx_pd->priority, ta, pkt_type,\r\nskb);\r\nif (ret || (rx_pkt_type == PKT_TYPE_BAR))\r\ndev_kfree_skb_any(skb);\r\nif (ret)\r\npriv->stats.rx_dropped++;\r\nreturn ret;\r\n}\r\nvoid *mwifiex_process_uap_txpd(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct uap_txpd *txpd;\r\nstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\r\nint pad;\r\nu16 pkt_type, pkt_offset;\r\nint hroom = (priv->adapter->iface_type == MWIFIEX_USB) ? 0 :\r\nINTF_HEADER_LEN;\r\nif (!skb->len) {\r\nmwifiex_dbg(adapter, ERROR,\r\n"Tx: bad packet length: %d\n", skb->len);\r\ntx_info->status_code = -1;\r\nreturn skb->data;\r\n}\r\nBUG_ON(skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN);\r\npkt_type = mwifiex_is_skb_mgmt_frame(skb) ? PKT_TYPE_MGMT : 0;\r\npad = ((void *)skb->data - (sizeof(*txpd) + hroom) - NULL) &\r\n(MWIFIEX_DMA_ALIGN_SZ - 1);\r\nskb_push(skb, sizeof(*txpd) + pad);\r\ntxpd = (struct uap_txpd *)skb->data;\r\nmemset(txpd, 0, sizeof(*txpd));\r\ntxpd->bss_num = priv->bss_num;\r\ntxpd->bss_type = priv->bss_type;\r\ntxpd->tx_pkt_length = cpu_to_le16((u16)(skb->len - (sizeof(*txpd) +\r\npad)));\r\ntxpd->priority = (u8)skb->priority;\r\ntxpd->pkt_delay_2ms = mwifiex_wmm_compute_drv_pkt_delay(priv, skb);\r\nif (tx_info->flags & MWIFIEX_BUF_FLAG_EAPOL_TX_STATUS ||\r\ntx_info->flags & MWIFIEX_BUF_FLAG_ACTION_TX_STATUS) {\r\ntxpd->tx_token_id = tx_info->ack_frame_id;\r\ntxpd->flags |= MWIFIEX_TXPD_FLAGS_REQ_TX_STATUS;\r\n}\r\nif (txpd->priority < ARRAY_SIZE(priv->wmm.user_pri_pkt_tx_ctrl))\r\ntxpd->tx_control =\r\ncpu_to_le32(priv->wmm.user_pri_pkt_tx_ctrl[txpd->priority]);\r\npkt_offset = sizeof(*txpd) + pad;\r\nif (pkt_type == PKT_TYPE_MGMT) {\r\ntxpd->tx_pkt_type = cpu_to_le16(pkt_type);\r\npkt_offset += MWIFIEX_MGMT_FRAME_HEADER_SIZE;\r\n}\r\ntxpd->tx_pkt_offset = cpu_to_le16(pkt_offset);\r\nskb_push(skb, hroom);\r\nif (!txpd->tx_control)\r\ntxpd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);\r\nreturn skb->data;\r\n}
