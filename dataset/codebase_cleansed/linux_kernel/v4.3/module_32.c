static unsigned int count_relocs(const Elf32_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i, r_info, r_addend, _count_relocs;\r\n_count_relocs = 0;\r\nr_info = 0;\r\nr_addend = 0;\r\nfor (i = 0; i < num; i++)\r\nif (ELF32_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\r\n(r_info != ELF32_R_SYM(rela[i].r_info) ||\r\nr_addend != rela[i].r_addend)) {\r\n_count_relocs++;\r\nr_info = ELF32_R_SYM(rela[i].r_info);\r\nr_addend = rela[i].r_addend;\r\n}\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\n_count_relocs++;\r\n#endif\r\nreturn _count_relocs;\r\n}\r\nstatic int relacmp(const void *_x, const void *_y)\r\n{\r\nconst Elf32_Rela *x, *y;\r\ny = (Elf32_Rela *)_x;\r\nx = (Elf32_Rela *)_y;\r\nif (x->r_info < y->r_info)\r\nreturn -1;\r\nelse if (x->r_info > y->r_info)\r\nreturn 1;\r\nelse if (x->r_addend < y->r_addend)\r\nreturn -1;\r\nelse if (x->r_addend > y->r_addend)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void relaswap(void *_x, void *_y, int size)\r\n{\r\nuint32_t *x, *y, tmp;\r\nint i;\r\ny = (uint32_t *)_x;\r\nx = (uint32_t *)_y;\r\nfor (i = 0; i < sizeof(Elf32_Rela) / sizeof(uint32_t); i++) {\r\ntmp = x[i];\r\nx[i] = y[i];\r\ny[i] = tmp;\r\n}\r\n}\r\nstatic unsigned long get_plt_size(const Elf32_Ehdr *hdr,\r\nconst Elf32_Shdr *sechdrs,\r\nconst char *secstrings,\r\nint is_init)\r\n{\r\nunsigned long ret = 0;\r\nunsigned i;\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nif ((strstr(secstrings + sechdrs[i].sh_name, ".init") != 0)\r\n!= is_init)\r\ncontinue;\r\nif (strstr(secstrings + sechdrs[i].sh_name, ".debug") != 0)\r\ncontinue;\r\nif (sechdrs[i].sh_type == SHT_RELA) {\r\npr_debug("Found relocations in section %u\n", i);\r\npr_debug("Ptr: %p. Number: %u\n",\r\n(void *)hdr + sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size / sizeof(Elf32_Rela));\r\nsort((void *)hdr + sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size / sizeof(Elf32_Rela),\r\nsizeof(Elf32_Rela), relacmp, relaswap);\r\nret += count_relocs((void *)hdr\r\n+ sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size\r\n/ sizeof(Elf32_Rela))\r\n* sizeof(struct ppc_plt_entry);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint module_frob_arch_sections(Elf32_Ehdr *hdr,\r\nElf32_Shdr *sechdrs,\r\nchar *secstrings,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < hdr->e_shnum; i++) {\r\nif (strcmp(secstrings + sechdrs[i].sh_name, ".init.plt") == 0)\r\nme->arch.init_plt_section = i;\r\nelse if (strcmp(secstrings + sechdrs[i].sh_name, ".plt") == 0)\r\nme->arch.core_plt_section = i;\r\n}\r\nif (!me->arch.core_plt_section || !me->arch.init_plt_section) {\r\npr_err("Module doesn't contain .plt or .init.plt sections.\n");\r\nreturn -ENOEXEC;\r\n}\r\nsechdrs[me->arch.core_plt_section].sh_size\r\n= get_plt_size(hdr, sechdrs, secstrings, 0);\r\nsechdrs[me->arch.init_plt_section].sh_size\r\n= get_plt_size(hdr, sechdrs, secstrings, 1);\r\nreturn 0;\r\n}\r\nstatic inline int entry_matches(struct ppc_plt_entry *entry, Elf32_Addr val)\r\n{\r\nif (entry->jump[0] == 0x3d800000 + ((val + 0x8000) >> 16)\r\n&& entry->jump[1] == 0x398c0000 + (val & 0xffff))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic uint32_t do_plt_call(void *location,\r\nElf32_Addr val,\r\nElf32_Shdr *sechdrs,\r\nstruct module *mod)\r\n{\r\nstruct ppc_plt_entry *entry;\r\npr_debug("Doing plt for call to 0x%x at 0x%x\n", val, (unsigned int)location);\r\nif (location >= mod->module_core\r\n&& location < mod->module_core + mod->core_size)\r\nentry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;\r\nelse\r\nentry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;\r\nwhile (entry->jump[0]) {\r\nif (entry_matches(entry, val)) return (uint32_t)entry;\r\nentry++;\r\n}\r\nentry->jump[0] = 0x3d800000+((val+0x8000)>>16);\r\nentry->jump[1] = 0x398c0000 + (val&0xffff);\r\nentry->jump[2] = 0x7d8903a6;\r\nentry->jump[3] = 0x4e800420;\r\npr_debug("Initialized plt for 0x%x at %p\n", val, entry);\r\nreturn (uint32_t)entry;\r\n}\r\nint apply_relocate_add(Elf32_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *module)\r\n{\r\nunsigned int i;\r\nElf32_Rela *rela = (void *)sechdrs[relsec].sh_addr;\r\nElf32_Sym *sym;\r\nuint32_t *location;\r\nuint32_t value;\r\npr_debug("Applying ADD relocate section %u to %u\n", relsec,\r\nsechdrs[relsec].sh_info);\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rela[i].r_offset;\r\nsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF32_R_SYM(rela[i].r_info);\r\nvalue = sym->st_value + rela[i].r_addend;\r\nswitch (ELF32_R_TYPE(rela[i].r_info)) {\r\ncase R_PPC_ADDR32:\r\n*(uint32_t *)location = value;\r\nbreak;\r\ncase R_PPC_ADDR16_LO:\r\n*(uint16_t *)location = value;\r\nbreak;\r\ncase R_PPC_ADDR16_HI:\r\n*(uint16_t *)location = (value >> 16);\r\nbreak;\r\ncase R_PPC_ADDR16_HA:\r\n*(uint16_t *)location = (value + 0x8000) >> 16;\r\nbreak;\r\ncase R_PPC_REL24:\r\nif ((int)(value - (uint32_t)location) < -0x02000000\r\n|| (int)(value - (uint32_t)location) >= 0x02000000)\r\nvalue = do_plt_call(location, value,\r\nsechdrs, module);\r\npr_debug("REL24 value = %08X. location = %08X\n",\r\nvalue, (uint32_t)location);\r\npr_debug("Location before: %08X.\n",\r\n*(uint32_t *)location);\r\n*(uint32_t *)location\r\n= (*(uint32_t *)location & ~0x03fffffc)\r\n| ((value - (uint32_t)location)\r\n& 0x03fffffc);\r\npr_debug("Location after: %08X.\n",\r\n*(uint32_t *)location);\r\npr_debug("ie. jump to %08X+%08X = %08X\n",\r\n*(uint32_t *)location & 0x03fffffc,\r\n(uint32_t)location,\r\n(*(uint32_t *)location & 0x03fffffc)\r\n+ (uint32_t)location);\r\nbreak;\r\ncase R_PPC_REL32:\r\n*(uint32_t *)location = value - (uint32_t)location;\r\nbreak;\r\ndefault:\r\npr_err("%s: unknown ADD relocation: %u\n",\r\nmodule->name,\r\nELF32_R_TYPE(rela[i].r_info));\r\nreturn -ENOEXEC;\r\n}\r\n}\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\nmodule->arch.tramp =\r\ndo_plt_call(module->module_core,\r\n(unsigned long)ftrace_caller,\r\nsechdrs, module);\r\n#endif\r\nreturn 0;\r\n}
