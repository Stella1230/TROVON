static u32 hda_read(struct sti_hda *hda, int offset)\r\n{\r\nreturn readl(hda->regs + offset);\r\n}\r\nstatic void hda_write(struct sti_hda *hda, u32 val, int offset)\r\n{\r\nwritel(val, hda->regs + offset);\r\n}\r\nstatic bool hda_get_mode_idx(struct drm_display_mode mode, int *idx)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(hda_supported_modes); i++)\r\nif (drm_mode_equal(&hda_supported_modes[i].mode, &mode)) {\r\n*idx = i;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void hda_enable_hd_dacs(struct sti_hda *hda, bool enable)\r\n{\r\nu32 mask;\r\nif (hda->video_dacs_ctrl) {\r\nu32 val;\r\nswitch ((u32)hda->video_dacs_ctrl & VIDEO_DACS_CONTROL_MASK) {\r\ncase VIDEO_DACS_CONTROL_SYSCFG2535:\r\nmask = DAC_CFG_HD_OFF_MASK;\r\nbreak;\r\ncase VIDEO_DACS_CONTROL_SYSCFG5072:\r\nmask = DAC_CFG_HD_HZUVW_OFF_MASK;\r\nbreak;\r\ndefault:\r\nDRM_INFO("Video DACS control register not supported!");\r\nreturn;\r\n}\r\nval = readl(hda->video_dacs_ctrl);\r\nif (enable)\r\nval &= ~mask;\r\nelse\r\nval |= mask;\r\nwritel(val, hda->video_dacs_ctrl);\r\n}\r\n}\r\nstatic void sti_hda_configure_awg(struct sti_hda *hda, u32 *awg_instr, int nb)\r\n{\r\nunsigned int i;\r\nDRM_DEBUG_DRIVER("\n");\r\nfor (i = 0; i < nb; i++)\r\nhda_write(hda, awg_instr[i], HDA_SYNC_AWGI + i * 4);\r\nfor (i = nb; i < AWG_MAX_INST; i++)\r\nhda_write(hda, 0, HDA_SYNC_AWGI + i * 4);\r\n}\r\nstatic void sti_hda_disable(struct drm_bridge *bridge)\r\n{\r\nstruct sti_hda *hda = bridge->driver_private;\r\nu32 val;\r\nif (!hda->enabled)\r\nreturn;\r\nDRM_DEBUG_DRIVER("\n");\r\nval = hda_read(hda, HDA_ANA_CFG);\r\nval &= ~CFG_AWG_ASYNC_EN;\r\nhda_write(hda, val, HDA_ANA_CFG);\r\nhda_write(hda, 0, HDA_ANA_ANC_CTRL);\r\nhda_enable_hd_dacs(hda, false);\r\nclk_disable_unprepare(hda->clk_hddac);\r\nclk_disable_unprepare(hda->clk_pix);\r\nhda->enabled = false;\r\n}\r\nstatic void sti_hda_pre_enable(struct drm_bridge *bridge)\r\n{\r\nstruct sti_hda *hda = bridge->driver_private;\r\nu32 val, i, mode_idx;\r\nu32 src_filter_y, src_filter_c;\r\nu32 *coef_y, *coef_c;\r\nu32 filter_mode;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (hda->enabled)\r\nreturn;\r\nif (clk_prepare_enable(hda->clk_pix))\r\nDRM_ERROR("Failed to prepare/enable hda_pix clk\n");\r\nif (clk_prepare_enable(hda->clk_hddac))\r\nDRM_ERROR("Failed to prepare/enable hda_hddac clk\n");\r\nif (!hda_get_mode_idx(hda->mode, &mode_idx)) {\r\nDRM_ERROR("Undefined mode\n");\r\nreturn;\r\n}\r\nswitch (hda_supported_modes[mode_idx].vid_cat) {\r\ncase VID_HD_148M:\r\nDRM_ERROR("Beyond HD analog capabilities\n");\r\nreturn;\r\ncase VID_HD_74M:\r\nfilter_mode = CFG_AWG_FLTR_MODE_HD;\r\nsrc_filter_y = HDA_ANA_SRC_Y_CFG_ALT_2X;\r\nsrc_filter_c = HDA_ANA_SRC_C_CFG_ALT_2X;\r\ncoef_y = coef_y_alt_2x;\r\ncoef_c = coef_c_alt_2x;\r\nbreak;\r\ncase VID_ED:\r\nfilter_mode = CFG_AWG_FLTR_MODE_ED;\r\nsrc_filter_y = HDA_ANA_SRC_Y_CFG_4X;\r\nsrc_filter_c = HDA_ANA_SRC_C_CFG_4X;\r\ncoef_y = coef_yc_4x;\r\ncoef_c = coef_yc_4x;\r\nbreak;\r\ncase VID_SD:\r\nDRM_ERROR("Not supported\n");\r\nreturn;\r\ndefault:\r\nDRM_ERROR("Undefined resolution\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_DRIVER("Using HDA mode #%d\n", mode_idx);\r\nhda_enable_hd_dacs(hda, true);\r\nhda_write(hda, SCALE_CTRL_Y_DFLT, HDA_ANA_SCALE_CTRL_Y);\r\nhda_write(hda, SCALE_CTRL_CB_DFLT, HDA_ANA_SCALE_CTRL_CB);\r\nhda_write(hda, SCALE_CTRL_CR_DFLT, HDA_ANA_SCALE_CTRL_CR);\r\nhda_write(hda , src_filter_y, HDA_ANA_SRC_Y_CFG);\r\nhda_write(hda, src_filter_c, HDA_ANA_SRC_C_CFG);\r\nfor (i = 0; i < SAMPLER_COEF_NB; i++) {\r\nhda_write(hda, coef_y[i], HDA_COEFF_Y_PH1_TAP123 + i * 4);\r\nhda_write(hda, coef_c[i], HDA_COEFF_C_PH1_TAP123 + i * 4);\r\n}\r\nval = 0;\r\nval |= (hda->mode.flags & DRM_MODE_FLAG_INTERLACE) ?\r\n0 : CFG_AWG_ASYNC_VSYNC_MTD;\r\nval |= (CFG_PBPR_SYNC_OFF_VAL << CFG_PBPR_SYNC_OFF_SHIFT);\r\nval |= filter_mode;\r\nhda_write(hda, val, HDA_ANA_CFG);\r\nsti_hda_configure_awg(hda, hda_supported_modes[mode_idx].awg_instr,\r\nhda_supported_modes[mode_idx].nb_instr);\r\nval = hda_read(hda, HDA_ANA_CFG);\r\nval |= CFG_AWG_ASYNC_EN;\r\nhda_write(hda, val, HDA_ANA_CFG);\r\nhda->enabled = true;\r\n}\r\nstatic void sti_hda_set_mode(struct drm_bridge *bridge,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct sti_hda *hda = bridge->driver_private;\r\nu32 mode_idx;\r\nint hddac_rate;\r\nint ret;\r\nDRM_DEBUG_DRIVER("\n");\r\nmemcpy(&hda->mode, mode, sizeof(struct drm_display_mode));\r\nif (!hda_get_mode_idx(hda->mode, &mode_idx)) {\r\nDRM_ERROR("Undefined mode\n");\r\nreturn;\r\n}\r\nswitch (hda_supported_modes[mode_idx].vid_cat) {\r\ncase VID_HD_74M:\r\nhddac_rate = mode->clock * 1000 * 2;\r\nbreak;\r\ncase VID_ED:\r\nhddac_rate = mode->clock * 1000 * 4;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Undefined mode\n");\r\nreturn;\r\n}\r\nret = clk_set_rate(hda->clk_hddac, hddac_rate);\r\nif (ret < 0)\r\nDRM_ERROR("Cannot set rate (%dHz) for hda_hddac clk\n",\r\nhddac_rate);\r\nret = clk_set_rate(hda->clk_pix, mode->clock * 1000);\r\nif (ret < 0)\r\nDRM_ERROR("Cannot set rate (%dHz) for hda_pix clk\n",\r\nmode->clock * 1000);\r\n}\r\nstatic void sti_hda_bridge_nope(struct drm_bridge *bridge)\r\n{\r\n}\r\nstatic int sti_hda_connector_get_modes(struct drm_connector *connector)\r\n{\r\nunsigned int i;\r\nint count = 0;\r\nstruct sti_hda_connector *hda_connector\r\n= to_sti_hda_connector(connector);\r\nstruct sti_hda *hda = hda_connector->hda;\r\nDRM_DEBUG_DRIVER("\n");\r\nfor (i = 0; i < ARRAY_SIZE(hda_supported_modes); i++) {\r\nstruct drm_display_mode *mode =\r\ndrm_mode_duplicate(hda->drm_dev,\r\n&hda_supported_modes[i].mode);\r\nif (!mode)\r\ncontinue;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\nif (i == 0)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\ncount++;\r\n}\r\ndrm_mode_sort(&connector->modes);\r\nreturn count;\r\n}\r\nstatic int sti_hda_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nint target = mode->clock * 1000;\r\nint target_min = target - CLK_TOLERANCE_HZ;\r\nint target_max = target + CLK_TOLERANCE_HZ;\r\nint result;\r\nint idx;\r\nstruct sti_hda_connector *hda_connector\r\n= to_sti_hda_connector(connector);\r\nstruct sti_hda *hda = hda_connector->hda;\r\nif (!hda_get_mode_idx(*mode, &idx)) {\r\nreturn MODE_BAD;\r\n} else {\r\nresult = clk_round_rate(hda->clk_pix, target);\r\nDRM_DEBUG_DRIVER("target rate = %d => available rate = %d\n",\r\ntarget, result);\r\nif ((result < target_min) || (result > target_max)) {\r\nDRM_DEBUG_DRIVER("hda pixclk=%d not supported\n",\r\ntarget);\r\nreturn MODE_BAD;\r\n}\r\n}\r\nreturn MODE_OK;\r\n}\r\nstruct drm_encoder *sti_hda_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct sti_hda_connector *hda_connector\r\n= to_sti_hda_connector(connector);\r\nreturn hda_connector->encoder;\r\n}\r\nstatic enum drm_connector_status\r\nsti_hda_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void sti_hda_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct sti_hda_connector *hda_connector\r\n= to_sti_hda_connector(connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(hda_connector);\r\n}\r\nstatic struct drm_encoder *sti_hda_find_encoder(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_DAC)\r\nreturn encoder;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sti_hda_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_hda *hda = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct drm_encoder *encoder;\r\nstruct sti_hda_connector *connector;\r\nstruct drm_connector *drm_connector;\r\nstruct drm_bridge *bridge;\r\nint err;\r\nhda->drm_dev = drm_dev;\r\nencoder = sti_hda_find_encoder(drm_dev);\r\nif (!encoder)\r\nreturn -ENOMEM;\r\nconnector = devm_kzalloc(dev, sizeof(*connector), GFP_KERNEL);\r\nif (!connector)\r\nreturn -ENOMEM;\r\nconnector->hda = hda;\r\nbridge = devm_kzalloc(dev, sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->driver_private = hda;\r\nbridge->funcs = &sti_hda_bridge_funcs;\r\ndrm_bridge_attach(drm_dev, bridge);\r\nencoder->bridge = bridge;\r\nconnector->encoder = encoder;\r\ndrm_connector = (struct drm_connector *)connector;\r\ndrm_connector->polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_connector_init(drm_dev, drm_connector,\r\n&sti_hda_connector_funcs, DRM_MODE_CONNECTOR_Component);\r\ndrm_connector_helper_add(drm_connector,\r\n&sti_hda_connector_helper_funcs);\r\nerr = drm_connector_register(drm_connector);\r\nif (err)\r\ngoto err_connector;\r\nerr = drm_mode_connector_attach_encoder(drm_connector, encoder);\r\nif (err) {\r\nDRM_ERROR("Failed to attach a connector to a encoder\n");\r\ngoto err_sysfs;\r\n}\r\nreturn 0;\r\nerr_sysfs:\r\ndrm_connector_unregister(drm_connector);\r\nerr_connector:\r\ndrm_connector_cleanup(drm_connector);\r\nreturn -EINVAL;\r\n}\r\nstatic void sti_hda_unbind(struct device *dev,\r\nstruct device *master, void *data)\r\n{\r\n}\r\nstatic int sti_hda_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sti_hda *hda;\r\nstruct resource *res;\r\nDRM_INFO("%s\n", __func__);\r\nhda = devm_kzalloc(dev, sizeof(*hda), GFP_KERNEL);\r\nif (!hda)\r\nreturn -ENOMEM;\r\nhda->dev = pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "hda-reg");\r\nif (!res) {\r\nDRM_ERROR("Invalid hda resource\n");\r\nreturn -ENOMEM;\r\n}\r\nhda->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!hda->regs)\r\nreturn -ENOMEM;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"video-dacs-ctrl");\r\nif (res) {\r\nhda->video_dacs_ctrl = devm_ioremap_nocache(dev, res->start,\r\nresource_size(res));\r\nif (!hda->video_dacs_ctrl)\r\nreturn -ENOMEM;\r\n} else {\r\nDRM_DEBUG_DRIVER("No video-dacs-ctrl resource\n");\r\nhda->video_dacs_ctrl = NULL;\r\n}\r\nhda->clk_pix = devm_clk_get(dev, "pix");\r\nif (IS_ERR(hda->clk_pix)) {\r\nDRM_ERROR("Cannot get hda_pix clock\n");\r\nreturn PTR_ERR(hda->clk_pix);\r\n}\r\nhda->clk_hddac = devm_clk_get(dev, "hddac");\r\nif (IS_ERR(hda->clk_hddac)) {\r\nDRM_ERROR("Cannot get hda_hddac clock\n");\r\nreturn PTR_ERR(hda->clk_hddac);\r\n}\r\nplatform_set_drvdata(pdev, hda);\r\nreturn component_add(&pdev->dev, &sti_hda_ops);\r\n}\r\nstatic int sti_hda_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_hda_ops);\r\nreturn 0;\r\n}
