static bool lp8788_is_charger_detected(struct lp8788_charger *pchg)\r\n{\r\nu8 data;\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\r\ndata &= LP8788_CHG_INPUT_STATE_M;\r\nreturn data == LP8788_SYSTEM_SUPPLY || data == LP8788_FULL_FUNCTION;\r\n}\r\nstatic int lp8788_charger_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct lp8788_charger *pchg = dev_get_drvdata(psy->dev.parent);\r\nu8 read;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = lp8788_is_charger_detected(pchg);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_IDCIN, &read);\r\nval->intval = LP8788_ISEL_STEP *\r\n(min_t(int, read, LP8788_ISEL_MAX) + 1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_battery_status(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nenum lp8788_charging_state state;\r\nu8 data;\r\nint ret;\r\nret = lp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\r\nif (ret)\r\nreturn ret;\r\nstate = (data & LP8788_CHG_STATE_M) >> LP8788_CHG_STATE_S;\r\nswitch (state) {\r\ncase LP8788_OFF:\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase LP8788_PRECHARGE:\r\ncase LP8788_CC:\r\ncase LP8788_CV:\r\ncase LP8788_HIGH_CURRENT:\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nbreak;\r\ncase LP8788_MAINTENANCE:\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nbreak;\r\ndefault:\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_battery_health(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nu8 data;\r\nint ret;\r\nret = lp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\r\nif (ret)\r\nreturn ret;\r\nif (data & LP8788_NO_BATT_M)\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nelse if (data & LP8788_BAD_BATT_M)\r\nval->intval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_battery_present(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nu8 data;\r\nint ret;\r\nret = lp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\r\nif (ret)\r\nreturn ret;\r\nval->intval = !(data & LP8788_NO_BATT_M);\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_vbatt_adc(struct lp8788_charger *pchg, int *result)\r\n{\r\nstruct iio_channel *channel = pchg->chan[LP8788_VBATT];\r\nif (!channel)\r\nreturn -EINVAL;\r\nreturn iio_read_channel_processed(channel, result);\r\n}\r\nstatic int lp8788_get_battery_voltage(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nreturn lp8788_get_vbatt_adc(pchg, &val->intval);\r\n}\r\nstatic int lp8788_get_battery_capacity(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nstruct lp8788 *lp = pchg->lp;\r\nstruct lp8788_charger_platform_data *pdata = pchg->pdata;\r\nunsigned int max_vbatt;\r\nint vbatt;\r\nenum lp8788_charging_state state;\r\nu8 data;\r\nint ret;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nmax_vbatt = pdata->max_vbatt_mv;\r\nif (max_vbatt == 0)\r\nreturn -EINVAL;\r\nret = lp8788_read_byte(lp, LP8788_CHG_STATUS, &data);\r\nif (ret)\r\nreturn ret;\r\nstate = (data & LP8788_CHG_STATE_M) >> LP8788_CHG_STATE_S;\r\nif (state == LP8788_MAINTENANCE) {\r\nval->intval = LP8788_MAX_BATT_CAPACITY;\r\n} else {\r\nret = lp8788_get_vbatt_adc(pchg, &vbatt);\r\nif (ret)\r\nreturn ret;\r\nval->intval = (vbatt * LP8788_MAX_BATT_CAPACITY) / max_vbatt;\r\nval->intval = min(val->intval, LP8788_MAX_BATT_CAPACITY);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_battery_temperature(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nstruct iio_channel *channel = pchg->chan[LP8788_BATT_TEMP];\r\nint result;\r\nint ret;\r\nif (!channel)\r\nreturn -EINVAL;\r\nret = iio_read_channel_processed(channel, &result);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nval->intval = result * 10;\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_battery_charging_current(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nu8 read;\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_IBATT, &read);\r\nread &= LP8788_CHG_IBATT_M;\r\nval->intval = LP8788_ISEL_STEP *\r\n(min_t(int, read, LP8788_ISEL_MAX) + 1);\r\nreturn 0;\r\n}\r\nstatic int lp8788_get_charging_termination_voltage(struct lp8788_charger *pchg,\r\nunion power_supply_propval *val)\r\n{\r\nu8 read;\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_VTERM, &read);\r\nread &= LP8788_CHG_VTERM_M;\r\nval->intval = LP8788_VTERM_MIN + LP8788_VTERM_STEP * read;\r\nreturn 0;\r\n}\r\nstatic int lp8788_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct lp8788_charger *pchg = dev_get_drvdata(psy->dev.parent);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nreturn lp8788_get_battery_status(pchg, val);\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nreturn lp8788_get_battery_health(pchg, val);\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nreturn lp8788_get_battery_present(pchg, val);\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nreturn lp8788_get_battery_voltage(pchg, val);\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nreturn lp8788_get_battery_capacity(pchg, val);\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nreturn lp8788_get_battery_temperature(pchg, val);\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nreturn lp8788_get_battery_charging_current(pchg, val);\r\ncase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nreturn lp8788_get_charging_termination_voltage(pchg, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline bool lp8788_is_valid_charger_register(u8 addr)\r\n{\r\nreturn addr >= LP8788_CHG_START && addr <= LP8788_CHG_END;\r\n}\r\nstatic int lp8788_update_charger_params(struct platform_device *pdev,\r\nstruct lp8788_charger *pchg)\r\n{\r\nstruct lp8788 *lp = pchg->lp;\r\nstruct lp8788_charger_platform_data *pdata = pchg->pdata;\r\nstruct lp8788_chg_param *param;\r\nint i;\r\nint ret;\r\nif (!pdata || !pdata->chg_params) {\r\ndev_info(&pdev->dev, "skip updating charger parameters\n");\r\nreturn 0;\r\n}\r\nfor (i = 0; i < pdata->num_chg_params; i++) {\r\nparam = pdata->chg_params + i;\r\nif (!param)\r\ncontinue;\r\nif (lp8788_is_valid_charger_register(param->addr)) {\r\nret = lp8788_write_byte(lp, param->addr, param->val);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_psy_register(struct platform_device *pdev,\r\nstruct lp8788_charger *pchg)\r\n{\r\nstruct power_supply_config charger_cfg = {};\r\ncharger_cfg.supplied_to = battery_supplied_to;\r\ncharger_cfg.num_supplicants = ARRAY_SIZE(battery_supplied_to);\r\npchg->charger = power_supply_register(&pdev->dev,\r\n&lp8788_psy_charger_desc,\r\n&charger_cfg);\r\nif (IS_ERR(pchg->charger))\r\nreturn -EPERM;\r\npchg->battery = power_supply_register(&pdev->dev,\r\n&lp8788_psy_battery_desc, NULL);\r\nif (IS_ERR(pchg->battery)) {\r\npower_supply_unregister(pchg->charger);\r\nreturn -EPERM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lp8788_psy_unregister(struct lp8788_charger *pchg)\r\n{\r\npower_supply_unregister(pchg->battery);\r\npower_supply_unregister(pchg->charger);\r\n}\r\nstatic void lp8788_charger_event(struct work_struct *work)\r\n{\r\nstruct lp8788_charger *pchg =\r\ncontainer_of(work, struct lp8788_charger, charger_work);\r\nstruct lp8788_charger_platform_data *pdata = pchg->pdata;\r\nenum lp8788_charger_event event = lp8788_is_charger_detected(pchg);\r\npdata->charger_event(pchg->lp, event);\r\n}\r\nstatic bool lp8788_find_irq_id(struct lp8788_charger *pchg, int virq, int *id)\r\n{\r\nbool found;\r\nint i;\r\nfor (i = 0; i < pchg->num_irqs; i++) {\r\nif (pchg->irqs[i].virq == virq) {\r\n*id = pchg->irqs[i].which;\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic irqreturn_t lp8788_charger_irq_thread(int virq, void *ptr)\r\n{\r\nstruct lp8788_charger *pchg = ptr;\r\nstruct lp8788_charger_platform_data *pdata = pchg->pdata;\r\nint id = -1;\r\nif (!lp8788_find_irq_id(pchg, virq, &id))\r\nreturn IRQ_NONE;\r\nswitch (id) {\r\ncase LP8788_INT_CHG_INPUT_STATE:\r\ncase LP8788_INT_CHG_STATE:\r\ncase LP8788_INT_EOC:\r\ncase LP8788_INT_BATT_LOW:\r\ncase LP8788_INT_NO_BATT:\r\npower_supply_changed(pchg->charger);\r\npower_supply_changed(pchg->battery);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!pdata)\r\ngoto irq_handled;\r\nif (pdata->charger_event && id == LP8788_INT_CHG_INPUT_STATE)\r\nschedule_work(&pchg->charger_work);\r\nirq_handled:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lp8788_set_irqs(struct platform_device *pdev,\r\nstruct lp8788_charger *pchg, const char *name)\r\n{\r\nstruct resource *r;\r\nstruct irq_domain *irqdm = pchg->lp->irqdm;\r\nint irq_start;\r\nint irq_end;\r\nint virq;\r\nint nr_irq;\r\nint i;\r\nint ret;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, name);\r\nif (!r)\r\nreturn 0;\r\nirq_start = r->start;\r\nirq_end = r->end;\r\nfor (i = irq_start; i <= irq_end; i++) {\r\nnr_irq = pchg->num_irqs;\r\nvirq = irq_create_mapping(irqdm, i);\r\npchg->irqs[nr_irq].virq = virq;\r\npchg->irqs[nr_irq].which = i;\r\npchg->num_irqs++;\r\nret = request_threaded_irq(virq, NULL,\r\nlp8788_charger_irq_thread,\r\n0, name, pchg);\r\nif (ret)\r\nbreak;\r\n}\r\nif (i <= irq_end)\r\ngoto err_free_irq;\r\nreturn 0;\r\nerr_free_irq:\r\nfor (i = 0; i < pchg->num_irqs; i++)\r\nfree_irq(pchg->irqs[i].virq, pchg);\r\nreturn ret;\r\n}\r\nstatic int lp8788_irq_register(struct platform_device *pdev,\r\nstruct lp8788_charger *pchg)\r\n{\r\nconst char *name[] = {\r\nLP8788_CHG_IRQ, LP8788_PRSW_IRQ, LP8788_BATT_IRQ\r\n};\r\nint i;\r\nint ret;\r\nINIT_WORK(&pchg->charger_work, lp8788_charger_event);\r\npchg->num_irqs = 0;\r\nfor (i = 0; i < ARRAY_SIZE(name); i++) {\r\nret = lp8788_set_irqs(pdev, pchg, name[i]);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "irq setup failed: %s\n", name[i]);\r\nreturn ret;\r\n}\r\n}\r\nif (pchg->num_irqs > LP8788_MAX_CHG_IRQS) {\r\ndev_err(&pdev->dev, "invalid total number of irqs: %d\n",\r\npchg->num_irqs);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lp8788_irq_unregister(struct platform_device *pdev,\r\nstruct lp8788_charger *pchg)\r\n{\r\nint i;\r\nint irq;\r\nfor (i = 0; i < pchg->num_irqs; i++) {\r\nirq = pchg->irqs[i].virq;\r\nif (!irq)\r\ncontinue;\r\nfree_irq(irq, pchg);\r\n}\r\n}\r\nstatic void lp8788_setup_adc_channel(struct device *dev,\r\nstruct lp8788_charger *pchg)\r\n{\r\nstruct lp8788_charger_platform_data *pdata = pchg->pdata;\r\nstruct iio_channel *chan;\r\nif (!pdata)\r\nreturn;\r\nchan = iio_channel_get(dev, pdata->adc_vbatt);\r\npchg->chan[LP8788_VBATT] = IS_ERR(chan) ? NULL : chan;\r\nchan = iio_channel_get(dev, pdata->adc_batt_temp);\r\npchg->chan[LP8788_BATT_TEMP] = IS_ERR(chan) ? NULL : chan;\r\n}\r\nstatic void lp8788_release_adc_channel(struct lp8788_charger *pchg)\r\n{\r\nint i;\r\nfor (i = 0; i < LP8788_NUM_CHG_ADC; i++) {\r\nif (!pchg->chan[i])\r\ncontinue;\r\niio_channel_release(pchg->chan[i]);\r\npchg->chan[i] = NULL;\r\n}\r\n}\r\nstatic ssize_t lp8788_show_charger_status(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp8788_charger *pchg = dev_get_drvdata(dev);\r\nenum lp8788_charging_state state;\r\nchar *desc[LP8788_MAX_CHG_STATE] = {\r\n[LP8788_OFF] = "CHARGER OFF",\r\n[LP8788_WARM_UP] = "WARM UP",\r\n[LP8788_LOW_INPUT] = "LOW INPUT STATE",\r\n[LP8788_PRECHARGE] = "CHARGING - PRECHARGE",\r\n[LP8788_CC] = "CHARGING - CC",\r\n[LP8788_CV] = "CHARGING - CV",\r\n[LP8788_MAINTENANCE] = "NO CHARGING - MAINTENANCE",\r\n[LP8788_BATTERY_FAULT] = "BATTERY FAULT",\r\n[LP8788_SYSTEM_SUPPORT] = "SYSTEM SUPPORT",\r\n[LP8788_HIGH_CURRENT] = "HIGH CURRENT",\r\n};\r\nu8 data;\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_STATUS, &data);\r\nstate = (data & LP8788_CHG_STATE_M) >> LP8788_CHG_STATE_S;\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", desc[state]);\r\n}\r\nstatic ssize_t lp8788_show_eoc_time(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp8788_charger *pchg = dev_get_drvdata(dev);\r\nchar *stime[] = { "400ms", "5min", "10min", "15min",\r\n"20min", "25min", "30min" "No timeout" };\r\nu8 val;\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_EOC, &val);\r\nval = (val & LP8788_CHG_EOC_TIME_M) >> LP8788_CHG_EOC_TIME_S;\r\nreturn scnprintf(buf, PAGE_SIZE, "End Of Charge Time: %s\n",\r\nstime[val]);\r\n}\r\nstatic ssize_t lp8788_show_eoc_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp8788_charger *pchg = dev_get_drvdata(dev);\r\nchar *abs_level[] = { "25mA", "49mA", "75mA", "98mA" };\r\nchar *relative_level[] = { "5%", "10%", "15%", "20%" };\r\nchar *level;\r\nu8 val;\r\nu8 mode;\r\nlp8788_read_byte(pchg->lp, LP8788_CHG_EOC, &val);\r\nmode = val & LP8788_CHG_EOC_MODE_M;\r\nval = (val & LP8788_CHG_EOC_LEVEL_M) >> LP8788_CHG_EOC_LEVEL_S;\r\nlevel = mode ? abs_level[val] : relative_level[val];\r\nreturn scnprintf(buf, PAGE_SIZE, "End Of Charge Level: %s\n", level);\r\n}\r\nstatic int lp8788_charger_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nstruct lp8788_charger *pchg;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\npchg = devm_kzalloc(dev, sizeof(struct lp8788_charger), GFP_KERNEL);\r\nif (!pchg)\r\nreturn -ENOMEM;\r\npchg->lp = lp;\r\npchg->pdata = lp->pdata ? lp->pdata->chg_pdata : NULL;\r\nplatform_set_drvdata(pdev, pchg);\r\nret = lp8788_update_charger_params(pdev, pchg);\r\nif (ret)\r\nreturn ret;\r\nlp8788_setup_adc_channel(&pdev->dev, pchg);\r\nret = lp8788_psy_register(pdev, pchg);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&pdev->dev.kobj, &lp8788_attr_group);\r\nif (ret) {\r\nlp8788_psy_unregister(pchg);\r\nreturn ret;\r\n}\r\nret = lp8788_irq_register(pdev, pchg);\r\nif (ret)\r\ndev_warn(dev, "failed to register charger irq: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int lp8788_charger_remove(struct platform_device *pdev)\r\n{\r\nstruct lp8788_charger *pchg = platform_get_drvdata(pdev);\r\nflush_work(&pchg->charger_work);\r\nlp8788_irq_unregister(pdev, pchg);\r\nsysfs_remove_group(&pdev->dev.kobj, &lp8788_attr_group);\r\nlp8788_psy_unregister(pchg);\r\nlp8788_release_adc_channel(pchg);\r\nreturn 0;\r\n}
