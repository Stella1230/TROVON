struct group_info *groups_alloc(int gidsetsize)\r\n{\r\nstruct group_info *group_info;\r\nint nblocks;\r\nint i;\r\nnblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK;\r\nnblocks = nblocks ? : 1;\r\ngroup_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER);\r\nif (!group_info)\r\nreturn NULL;\r\ngroup_info->ngroups = gidsetsize;\r\ngroup_info->nblocks = nblocks;\r\natomic_set(&group_info->usage, 1);\r\nif (gidsetsize <= NGROUPS_SMALL)\r\ngroup_info->blocks[0] = group_info->small_block;\r\nelse {\r\nfor (i = 0; i < nblocks; i++) {\r\nkgid_t *b;\r\nb = (void *)__get_free_page(GFP_USER);\r\nif (!b)\r\ngoto out_undo_partial_alloc;\r\ngroup_info->blocks[i] = b;\r\n}\r\n}\r\nreturn group_info;\r\nout_undo_partial_alloc:\r\nwhile (--i >= 0) {\r\nfree_page((unsigned long)group_info->blocks[i]);\r\n}\r\nkfree(group_info);\r\nreturn NULL;\r\n}\r\nvoid groups_free(struct group_info *group_info)\r\n{\r\nif (group_info->blocks[0] != group_info->small_block) {\r\nint i;\r\nfor (i = 0; i < group_info->nblocks; i++)\r\nfree_page((unsigned long)group_info->blocks[i]);\r\n}\r\nkfree(group_info);\r\n}\r\nstatic int groups_to_user(gid_t __user *grouplist,\r\nconst struct group_info *group_info)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint i;\r\nunsigned int count = group_info->ngroups;\r\nfor (i = 0; i < count; i++) {\r\ngid_t gid;\r\ngid = from_kgid_munged(user_ns, GROUP_AT(group_info, i));\r\nif (put_user(gid, grouplist+i))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int groups_from_user(struct group_info *group_info,\r\ngid_t __user *grouplist)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nint i;\r\nunsigned int count = group_info->ngroups;\r\nfor (i = 0; i < count; i++) {\r\ngid_t gid;\r\nkgid_t kgid;\r\nif (get_user(gid, grouplist+i))\r\nreturn -EFAULT;\r\nkgid = make_kgid(user_ns, gid);\r\nif (!gid_valid(kgid))\r\nreturn -EINVAL;\r\nGROUP_AT(group_info, i) = kgid;\r\n}\r\nreturn 0;\r\n}\r\nstatic void groups_sort(struct group_info *group_info)\r\n{\r\nint base, max, stride;\r\nint gidsetsize = group_info->ngroups;\r\nfor (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)\r\n;\r\nstride /= 3;\r\nwhile (stride) {\r\nmax = gidsetsize - stride;\r\nfor (base = 0; base < max; base++) {\r\nint left = base;\r\nint right = left + stride;\r\nkgid_t tmp = GROUP_AT(group_info, right);\r\nwhile (left >= 0 && gid_gt(GROUP_AT(group_info, left), tmp)) {\r\nGROUP_AT(group_info, right) =\r\nGROUP_AT(group_info, left);\r\nright = left;\r\nleft -= stride;\r\n}\r\nGROUP_AT(group_info, right) = tmp;\r\n}\r\nstride /= 3;\r\n}\r\n}\r\nint groups_search(const struct group_info *group_info, kgid_t grp)\r\n{\r\nunsigned int left, right;\r\nif (!group_info)\r\nreturn 0;\r\nleft = 0;\r\nright = group_info->ngroups;\r\nwhile (left < right) {\r\nunsigned int mid = (left+right)/2;\r\nif (gid_gt(grp, GROUP_AT(group_info, mid)))\r\nleft = mid + 1;\r\nelse if (gid_lt(grp, GROUP_AT(group_info, mid)))\r\nright = mid;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid set_groups(struct cred *new, struct group_info *group_info)\r\n{\r\nput_group_info(new->group_info);\r\ngroups_sort(group_info);\r\nget_group_info(group_info);\r\nnew->group_info = group_info;\r\n}\r\nint set_current_groups(struct group_info *group_info)\r\n{\r\nstruct cred *new;\r\nnew = prepare_creds();\r\nif (!new)\r\nreturn -ENOMEM;\r\nset_groups(new, group_info);\r\nreturn commit_creds(new);\r\n}\r\nbool may_setgroups(void)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nreturn ns_capable(user_ns, CAP_SETGID) &&\r\nuserns_may_setgroups(user_ns);\r\n}\r\nint in_group_p(kgid_t grp)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint retval = 1;\r\nif (!gid_eq(grp, cred->fsgid))\r\nretval = groups_search(cred->group_info, grp);\r\nreturn retval;\r\n}\r\nint in_egroup_p(kgid_t grp)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint retval = 1;\r\nif (!gid_eq(grp, cred->egid))\r\nretval = groups_search(cred->group_info, grp);\r\nreturn retval;\r\n}
