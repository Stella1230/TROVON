static int snd_opl4_seq_use_inc(struct snd_opl4 *opl4)\r\n{\r\nif (!try_module_get(opl4->card->module))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void snd_opl4_seq_use_dec(struct snd_opl4 *opl4)\r\n{\r\nmodule_put(opl4->card->module);\r\n}\r\nstatic int snd_opl4_seq_use(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_opl4 *opl4 = private_data;\r\nint err;\r\nmutex_lock(&opl4->access_mutex);\r\nif (opl4->used) {\r\nmutex_unlock(&opl4->access_mutex);\r\nreturn -EBUSY;\r\n}\r\nopl4->used++;\r\nif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {\r\nerr = snd_opl4_seq_use_inc(opl4);\r\nif (err < 0) {\r\nmutex_unlock(&opl4->access_mutex);\r\nreturn err;\r\n}\r\n}\r\nmutex_unlock(&opl4->access_mutex);\r\nsnd_opl4_synth_reset(opl4);\r\nreturn 0;\r\n}\r\nstatic int snd_opl4_seq_unuse(void *private_data, struct snd_seq_port_subscribe *info)\r\n{\r\nstruct snd_opl4 *opl4 = private_data;\r\nsnd_opl4_synth_shutdown(opl4);\r\nmutex_lock(&opl4->access_mutex);\r\nopl4->used--;\r\nmutex_unlock(&opl4->access_mutex);\r\nif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)\r\nsnd_opl4_seq_use_dec(opl4);\r\nreturn 0;\r\n}\r\nstatic int snd_opl4_seq_event_input(struct snd_seq_event *ev, int direct,\r\nvoid *private_data, int atomic, int hop)\r\n{\r\nstruct snd_opl4 *opl4 = private_data;\r\nsnd_midi_process_event(&opl4_ops, ev, opl4->chset);\r\nreturn 0;\r\n}\r\nstatic void snd_opl4_seq_free_port(void *private_data)\r\n{\r\nstruct snd_opl4 *opl4 = private_data;\r\nsnd_midi_channel_free_set(opl4->chset);\r\n}\r\nstatic int snd_opl4_seq_probe(struct device *_dev)\r\n{\r\nstruct snd_seq_device *dev = to_seq_dev(_dev);\r\nstruct snd_opl4 *opl4;\r\nint client;\r\nstruct snd_seq_port_callback pcallbacks;\r\nopl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\nif (!opl4)\r\nreturn -EINVAL;\r\nif (snd_yrw801_detect(opl4) < 0)\r\nreturn -ENODEV;\r\nopl4->chset = snd_midi_channel_alloc_set(16);\r\nif (!opl4->chset)\r\nreturn -ENOMEM;\r\nopl4->chset->private_data = opl4;\r\nclient = snd_seq_create_kernel_client(opl4->card, opl4->seq_dev_num,\r\n"OPL4 Wavetable");\r\nif (client < 0) {\r\nsnd_midi_channel_free_set(opl4->chset);\r\nreturn client;\r\n}\r\nopl4->seq_client = client;\r\nopl4->chset->client = client;\r\nmemset(&pcallbacks, 0, sizeof(pcallbacks));\r\npcallbacks.owner = THIS_MODULE;\r\npcallbacks.use = snd_opl4_seq_use;\r\npcallbacks.unuse = snd_opl4_seq_unuse;\r\npcallbacks.event_input = snd_opl4_seq_event_input;\r\npcallbacks.private_free = snd_opl4_seq_free_port;\r\npcallbacks.private_data = opl4;\r\nopl4->chset->port = snd_seq_event_port_attach(client, &pcallbacks,\r\nSNDRV_SEQ_PORT_CAP_WRITE |\r\nSNDRV_SEQ_PORT_CAP_SUBS_WRITE,\r\nSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\r\nSNDRV_SEQ_PORT_TYPE_MIDI_GM |\r\nSNDRV_SEQ_PORT_TYPE_HARDWARE |\r\nSNDRV_SEQ_PORT_TYPE_SYNTHESIZER,\r\n16, 24,\r\n"OPL4 Wavetable Port");\r\nif (opl4->chset->port < 0) {\r\nint err = opl4->chset->port;\r\nsnd_midi_channel_free_set(opl4->chset);\r\nsnd_seq_delete_kernel_client(client);\r\nopl4->seq_client = -1;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl4_seq_remove(struct device *_dev)\r\n{\r\nstruct snd_seq_device *dev = to_seq_dev(_dev);\r\nstruct snd_opl4 *opl4;\r\nopl4 = *(struct snd_opl4 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\nif (!opl4)\r\nreturn -EINVAL;\r\nif (opl4->seq_client >= 0) {\r\nsnd_seq_delete_kernel_client(opl4->seq_client);\r\nopl4->seq_client = -1;\r\n}\r\nreturn 0;\r\n}
