static void cw1200_bh_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, bh_work);\r\ncw1200_bh(priv);\r\n}\r\nint cw1200_register_bh(struct cw1200_common *priv)\r\n{\r\nint err = 0;\r\npriv->bh_workqueue = alloc_workqueue("cw1200_bh",\r\nWQ_MEM_RECLAIM | WQ_HIGHPRI\r\n| WQ_CPU_INTENSIVE, 1);\r\nif (!priv->bh_workqueue)\r\nreturn -ENOMEM;\r\nINIT_WORK(&priv->bh_work, cw1200_bh_work);\r\npr_debug("[BH] register.\n");\r\natomic_set(&priv->bh_rx, 0);\r\natomic_set(&priv->bh_tx, 0);\r\natomic_set(&priv->bh_term, 0);\r\natomic_set(&priv->bh_suspend, CW1200_BH_RESUMED);\r\npriv->bh_error = 0;\r\npriv->hw_bufs_used = 0;\r\npriv->buf_id_tx = 0;\r\npriv->buf_id_rx = 0;\r\ninit_waitqueue_head(&priv->bh_wq);\r\ninit_waitqueue_head(&priv->bh_evt_wq);\r\nerr = !queue_work(priv->bh_workqueue, &priv->bh_work);\r\nWARN_ON(err);\r\nreturn err;\r\n}\r\nvoid cw1200_unregister_bh(struct cw1200_common *priv)\r\n{\r\natomic_add(1, &priv->bh_term);\r\nwake_up(&priv->bh_wq);\r\nflush_workqueue(priv->bh_workqueue);\r\ndestroy_workqueue(priv->bh_workqueue);\r\npriv->bh_workqueue = NULL;\r\npr_debug("[BH] unregistered.\n");\r\n}\r\nvoid cw1200_irq_handler(struct cw1200_common *priv)\r\n{\r\npr_debug("[BH] irq.\n");\r\n__cw1200_irq_enable(priv, 0);\r\nif ((priv->bh_error))\r\nreturn;\r\nif (atomic_add_return(1, &priv->bh_rx) == 1)\r\nwake_up(&priv->bh_wq);\r\n}\r\nvoid cw1200_bh_wakeup(struct cw1200_common *priv)\r\n{\r\npr_debug("[BH] wakeup.\n");\r\nif (priv->bh_error) {\r\npr_err("[BH] wakeup failed (BH error)\n");\r\nreturn;\r\n}\r\nif (atomic_add_return(1, &priv->bh_tx) == 1)\r\nwake_up(&priv->bh_wq);\r\n}\r\nint cw1200_bh_suspend(struct cw1200_common *priv)\r\n{\r\npr_debug("[BH] suspend.\n");\r\nif (priv->bh_error) {\r\nwiphy_warn(priv->hw->wiphy, "BH error -- can't suspend\n");\r\nreturn -EINVAL;\r\n}\r\natomic_set(&priv->bh_suspend, CW1200_BH_SUSPEND);\r\nwake_up(&priv->bh_wq);\r\nreturn wait_event_timeout(priv->bh_evt_wq, priv->bh_error ||\r\n(CW1200_BH_SUSPENDED == atomic_read(&priv->bh_suspend)),\r\n1 * HZ) ? 0 : -ETIMEDOUT;\r\n}\r\nint cw1200_bh_resume(struct cw1200_common *priv)\r\n{\r\npr_debug("[BH] resume.\n");\r\nif (priv->bh_error) {\r\nwiphy_warn(priv->hw->wiphy, "BH error -- can't resume\n");\r\nreturn -EINVAL;\r\n}\r\natomic_set(&priv->bh_suspend, CW1200_BH_RESUME);\r\nwake_up(&priv->bh_wq);\r\nreturn wait_event_timeout(priv->bh_evt_wq, priv->bh_error ||\r\n(CW1200_BH_RESUMED == atomic_read(&priv->bh_suspend)),\r\n1 * HZ) ? 0 : -ETIMEDOUT;\r\n}\r\nstatic inline void wsm_alloc_tx_buffer(struct cw1200_common *priv)\r\n{\r\n++priv->hw_bufs_used;\r\n}\r\nint wsm_release_tx_buffer(struct cw1200_common *priv, int count)\r\n{\r\nint ret = 0;\r\nint hw_bufs_used = priv->hw_bufs_used;\r\npriv->hw_bufs_used -= count;\r\nif (WARN_ON(priv->hw_bufs_used < 0))\r\nret = -1;\r\nelse if (hw_bufs_used >= priv->wsm_caps.input_buffers)\r\nret = 1;\r\nif (!priv->hw_bufs_used)\r\nwake_up(&priv->bh_evt_wq);\r\nreturn ret;\r\n}\r\nstatic int cw1200_bh_read_ctrl_reg(struct cw1200_common *priv,\r\nu16 *ctrl_reg)\r\n{\r\nint ret;\r\nret = cw1200_reg_read_16(priv,\r\nST90TDS_CONTROL_REG_ID, ctrl_reg);\r\nif (ret) {\r\nret = cw1200_reg_read_16(priv,\r\nST90TDS_CONTROL_REG_ID, ctrl_reg);\r\nif (ret)\r\npr_err("[BH] Failed to read control register.\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int cw1200_device_wakeup(struct cw1200_common *priv)\r\n{\r\nu16 ctrl_reg;\r\nint ret;\r\npr_debug("[BH] Device wakeup.\n");\r\nret = cw1200_reg_write_32(priv, ST90TDS_TSET_GEN_R_W_REG_ID,\r\ncw1200_dpll_from_clk(priv->hw_refclk));\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nret = cw1200_reg_write_16(priv, ST90TDS_CONTROL_REG_ID,\r\nST90TDS_CONT_WUP_BIT);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nret = cw1200_bh_read_ctrl_reg(priv, &ctrl_reg);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nif (ctrl_reg & ST90TDS_CONT_RDY_BIT) {\r\npr_debug("[BH] Device awake.\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid cw1200_enable_powersave(struct cw1200_common *priv,\r\nbool enable)\r\n{\r\npr_debug("[BH] Powerave is %s.\n",\r\nenable ? "enabled" : "disabled");\r\npriv->powersave_enabled = enable;\r\n}\r\nstatic int cw1200_bh_rx_helper(struct cw1200_common *priv,\r\nuint16_t *ctrl_reg,\r\nint *tx)\r\n{\r\nsize_t read_len = 0;\r\nstruct sk_buff *skb_rx = NULL;\r\nstruct wsm_hdr *wsm;\r\nsize_t wsm_len;\r\nu16 wsm_id;\r\nu8 wsm_seq;\r\nint rx_resync = 1;\r\nsize_t alloc_len;\r\nu8 *data;\r\nread_len = (*ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK) * 2;\r\nif (!read_len)\r\nreturn 0;\r\nif (WARN_ON((read_len < sizeof(struct wsm_hdr)) ||\r\n(read_len > EFFECTIVE_BUF_SIZE))) {\r\npr_debug("Invalid read len: %zu (%04x)",\r\nread_len, *ctrl_reg);\r\ngoto err;\r\n}\r\nread_len = read_len + 2;\r\nalloc_len = priv->hwbus_ops->align_size(\r\npriv->hwbus_priv, read_len);\r\nif (WARN_ON_ONCE(alloc_len > EFFECTIVE_BUF_SIZE)) {\r\npr_debug("Read aligned len: %zu\n",\r\nalloc_len);\r\n}\r\nskb_rx = dev_alloc_skb(alloc_len);\r\nif (WARN_ON(!skb_rx))\r\ngoto err;\r\nskb_trim(skb_rx, 0);\r\nskb_put(skb_rx, read_len);\r\ndata = skb_rx->data;\r\nif (WARN_ON(!data))\r\ngoto err;\r\nif (WARN_ON(cw1200_data_read(priv, data, alloc_len))) {\r\npr_err("rx blew up, len %zu\n", alloc_len);\r\ngoto err;\r\n}\r\n*ctrl_reg = __le16_to_cpu(\r\n((__le16 *)data)[alloc_len / 2 - 1]);\r\nwsm = (struct wsm_hdr *)data;\r\nwsm_len = __le16_to_cpu(wsm->len);\r\nif (WARN_ON(wsm_len > read_len))\r\ngoto err;\r\nif (priv->wsm_enable_wsm_dumps)\r\nprint_hex_dump_bytes("<-- ",\r\nDUMP_PREFIX_NONE,\r\ndata, wsm_len);\r\nwsm_id = __le16_to_cpu(wsm->id) & 0xFFF;\r\nwsm_seq = (__le16_to_cpu(wsm->id) >> 13) & 7;\r\nskb_trim(skb_rx, wsm_len);\r\nif (wsm_id == 0x0800) {\r\nwsm_handle_exception(priv,\r\n&data[sizeof(*wsm)],\r\nwsm_len - sizeof(*wsm));\r\ngoto err;\r\n} else if (!rx_resync) {\r\nif (WARN_ON(wsm_seq != priv->wsm_rx_seq))\r\ngoto err;\r\n}\r\npriv->wsm_rx_seq = (wsm_seq + 1) & 7;\r\nrx_resync = 0;\r\nif (wsm_id & 0x0400) {\r\nint rc = wsm_release_tx_buffer(priv, 1);\r\nif (WARN_ON(rc < 0))\r\nreturn rc;\r\nelse if (rc > 0)\r\n*tx = 1;\r\n}\r\nif (WARN_ON(wsm_handle_rx(priv, wsm_id, wsm, &skb_rx)))\r\ngoto err;\r\nif (skb_rx) {\r\ndev_kfree_skb(skb_rx);\r\nskb_rx = NULL;\r\n}\r\nreturn 0;\r\nerr:\r\nif (skb_rx) {\r\ndev_kfree_skb(skb_rx);\r\nskb_rx = NULL;\r\n}\r\nreturn -1;\r\n}\r\nstatic int cw1200_bh_tx_helper(struct cw1200_common *priv,\r\nint *pending_tx,\r\nint *tx_burst)\r\n{\r\nsize_t tx_len;\r\nu8 *data;\r\nint ret;\r\nstruct wsm_hdr *wsm;\r\nif (priv->device_can_sleep) {\r\nret = cw1200_device_wakeup(priv);\r\nif (WARN_ON(ret < 0)) {\r\n*pending_tx = 1;\r\nreturn 0;\r\n} else if (ret) {\r\npriv->device_can_sleep = false;\r\n} else {\r\n*pending_tx = 1;\r\nreturn 0;\r\n}\r\n}\r\nwsm_alloc_tx_buffer(priv);\r\nret = wsm_get_tx(priv, &data, &tx_len, tx_burst);\r\nif (ret <= 0) {\r\nwsm_release_tx_buffer(priv, 1);\r\nif (WARN_ON(ret < 0))\r\nreturn ret;\r\nreturn 0;\r\n}\r\nwsm = (struct wsm_hdr *)data;\r\nBUG_ON(tx_len < sizeof(*wsm));\r\nBUG_ON(__le16_to_cpu(wsm->len) != tx_len);\r\natomic_add(1, &priv->bh_tx);\r\ntx_len = priv->hwbus_ops->align_size(\r\npriv->hwbus_priv, tx_len);\r\nif (WARN_ON_ONCE(tx_len > EFFECTIVE_BUF_SIZE))\r\npr_debug("Write aligned len: %zu\n", tx_len);\r\nwsm->id &= __cpu_to_le16(0xffff ^ WSM_TX_SEQ(WSM_TX_SEQ_MAX));\r\nwsm->id |= __cpu_to_le16(WSM_TX_SEQ(priv->wsm_tx_seq));\r\nif (WARN_ON(cw1200_data_write(priv, data, tx_len))) {\r\npr_err("tx blew up, len %zu\n", tx_len);\r\nwsm_release_tx_buffer(priv, 1);\r\nreturn -1;\r\n}\r\nif (priv->wsm_enable_wsm_dumps)\r\nprint_hex_dump_bytes("--> ",\r\nDUMP_PREFIX_NONE,\r\ndata,\r\n__le16_to_cpu(wsm->len));\r\nwsm_txed(priv, data);\r\npriv->wsm_tx_seq = (priv->wsm_tx_seq + 1) & WSM_TX_SEQ_MAX;\r\nif (*tx_burst > 1) {\r\ncw1200_debug_tx_burst(priv);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cw1200_bh(void *arg)\r\n{\r\nstruct cw1200_common *priv = arg;\r\nint rx, tx, term, suspend;\r\nu16 ctrl_reg = 0;\r\nint tx_allowed;\r\nint pending_tx = 0;\r\nint tx_burst;\r\nlong status;\r\nu32 dummy;\r\nint ret;\r\nfor (;;) {\r\nif (!priv->hw_bufs_used &&\r\npriv->powersave_enabled &&\r\n!priv->device_can_sleep &&\r\n!atomic_read(&priv->recent_scan)) {\r\nstatus = 1 * HZ;\r\npr_debug("[BH] Device wakedown. No data.\n");\r\ncw1200_reg_write_16(priv, ST90TDS_CONTROL_REG_ID, 0);\r\npriv->device_can_sleep = true;\r\n} else if (priv->hw_bufs_used) {\r\nstatus = 1 * HZ;\r\n} else {\r\nstatus = MAX_SCHEDULE_TIMEOUT;\r\n}\r\nif ((priv->hw_type != -1) &&\r\n(atomic_read(&priv->bh_rx) == 0) &&\r\n(atomic_read(&priv->bh_tx) == 0))\r\ncw1200_reg_read(priv, ST90TDS_CONFIG_REG_ID,\r\n&dummy, sizeof(dummy));\r\npr_debug("[BH] waiting ...\n");\r\nstatus = wait_event_interruptible_timeout(priv->bh_wq, ({\r\nrx = atomic_xchg(&priv->bh_rx, 0);\r\ntx = atomic_xchg(&priv->bh_tx, 0);\r\nterm = atomic_xchg(&priv->bh_term, 0);\r\nsuspend = pending_tx ?\r\n0 : atomic_read(&priv->bh_suspend);\r\n(rx || tx || term || suspend || priv->bh_error);\r\n}), status);\r\npr_debug("[BH] - rx: %d, tx: %d, term: %d, bh_err: %d, suspend: %d, status: %ld\n",\r\nrx, tx, term, suspend, priv->bh_error, status);\r\nif ((status < 0 && status != -ERESTARTSYS) ||\r\nterm || priv->bh_error) {\r\nbreak;\r\n}\r\nif (!status) {\r\nunsigned long timestamp = jiffies;\r\nlong timeout;\r\nint pending = 0;\r\nint i;\r\nif (priv->hw_bufs_used && (!rx || !tx)) {\r\nwiphy_warn(priv->hw->wiphy,\r\n"Missed interrupt? (%d frames outstanding)\n",\r\npriv->hw_bufs_used);\r\nrx = 1;\r\nfor (i = 0; i < 4; ++i)\r\npending += cw1200_queue_get_xmit_timestamp(\r\n&priv->tx_queue[i],\r\n&timestamp,\r\npriv->pending_frame_id);\r\ntimeout = timestamp +\r\nWSM_CMD_LAST_CHANCE_TIMEOUT +\r\n1 * HZ -\r\njiffies;\r\nif (pending && timeout < 0) {\r\nwiphy_warn(priv->hw->wiphy,\r\n"Timeout waiting for TX confirm (%d/%d pending, %ld vs %lu).\n",\r\npriv->hw_bufs_used, pending,\r\ntimestamp, jiffies);\r\nbreak;\r\n}\r\n} else if (!priv->device_can_sleep &&\r\n!atomic_read(&priv->recent_scan)) {\r\npr_debug("[BH] Device wakedown. Timeout.\n");\r\ncw1200_reg_write_16(priv,\r\nST90TDS_CONTROL_REG_ID, 0);\r\npriv->device_can_sleep = true;\r\n}\r\ngoto done;\r\n} else if (suspend) {\r\npr_debug("[BH] Device suspend.\n");\r\nif (priv->powersave_enabled) {\r\npr_debug("[BH] Device wakedown. Suspend.\n");\r\ncw1200_reg_write_16(priv,\r\nST90TDS_CONTROL_REG_ID, 0);\r\npriv->device_can_sleep = true;\r\n}\r\natomic_set(&priv->bh_suspend, CW1200_BH_SUSPENDED);\r\nwake_up(&priv->bh_evt_wq);\r\nstatus = wait_event_interruptible(priv->bh_wq,\r\nCW1200_BH_RESUME == atomic_read(&priv->bh_suspend));\r\nif (status < 0) {\r\nwiphy_err(priv->hw->wiphy,\r\n"Failed to wait for resume: %ld.\n",\r\nstatus);\r\nbreak;\r\n}\r\npr_debug("[BH] Device resume.\n");\r\natomic_set(&priv->bh_suspend, CW1200_BH_RESUMED);\r\nwake_up(&priv->bh_evt_wq);\r\natomic_add(1, &priv->bh_rx);\r\ngoto done;\r\n}\r\nrx:\r\ntx += pending_tx;\r\npending_tx = 0;\r\nif (cw1200_bh_read_ctrl_reg(priv, &ctrl_reg))\r\nbreak;\r\nif (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK) {\r\nret = cw1200_bh_rx_helper(priv, &ctrl_reg, &tx);\r\nif (ret < 0)\r\nbreak;\r\nif (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK) {\r\nret = cw1200_bh_rx_helper(priv, &ctrl_reg, &tx);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\ntx:\r\nif (tx) {\r\ntx = 0;\r\nBUG_ON(priv->hw_bufs_used > priv->wsm_caps.input_buffers);\r\ntx_burst = priv->wsm_caps.input_buffers - priv->hw_bufs_used;\r\ntx_allowed = tx_burst > 0;\r\nif (!tx_allowed) {\r\npending_tx = tx;\r\ngoto done_rx;\r\n}\r\nret = cw1200_bh_tx_helper(priv, &pending_tx, &tx_burst);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > 0)\r\ntx = ret;\r\nif (cw1200_bh_read_ctrl_reg(priv, &ctrl_reg))\r\nbreak;\r\n}\r\ndone_rx:\r\nif (priv->bh_error)\r\nbreak;\r\nif (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK)\r\ngoto rx;\r\nif (tx)\r\ngoto tx;\r\ndone:\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\n__cw1200_irq_enable(priv, 1);\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\n}\r\npriv->hwbus_ops->lock(priv->hwbus_priv);\r\n__cw1200_irq_enable(priv, 0);\r\npriv->hwbus_ops->unlock(priv->hwbus_priv);\r\nif (!term) {\r\npr_err("[BH] Fatal error, exiting.\n");\r\npriv->bh_error = 1;\r\n}\r\nreturn 0;\r\n}
