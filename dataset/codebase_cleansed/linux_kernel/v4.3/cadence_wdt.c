static inline void cdns_wdt_writereg(struct cdns_wdt *wdt, u32 offset, u32 val)\r\n{\r\nwritel_relaxed(val, wdt->regs + offset);\r\n}\r\nstatic int cdns_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct cdns_wdt *wdt = watchdog_get_drvdata(wdd);\r\nspin_lock(&wdt->io_lock);\r\ncdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET,\r\nCDNS_WDT_ZMR_ZKEY_VAL & (~CDNS_WDT_ZMR_WDEN_MASK));\r\nspin_unlock(&wdt->io_lock);\r\nreturn 0;\r\n}\r\nstatic int cdns_wdt_reload(struct watchdog_device *wdd)\r\n{\r\nstruct cdns_wdt *wdt = watchdog_get_drvdata(wdd);\r\nspin_lock(&wdt->io_lock);\r\ncdns_wdt_writereg(wdt, CDNS_WDT_RESTART_OFFSET,\r\nCDNS_WDT_RESTART_KEY);\r\nspin_unlock(&wdt->io_lock);\r\nreturn 0;\r\n}\r\nstatic int cdns_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct cdns_wdt *wdt = watchdog_get_drvdata(wdd);\r\nunsigned int data = 0;\r\nunsigned short count;\r\nunsigned long clock_f = clk_get_rate(wdt->clk);\r\ncount = (wdd->timeout * (clock_f / wdt->prescaler)) /\r\nCDNS_WDT_COUNTER_VALUE_DIVISOR + 1;\r\nif (count > CDNS_WDT_COUNTER_MAX)\r\ncount = CDNS_WDT_COUNTER_MAX;\r\nspin_lock(&wdt->io_lock);\r\ncdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET,\r\nCDNS_WDT_ZMR_ZKEY_VAL);\r\ncount = (count << 2) & CDNS_WDT_CCR_CRV_MASK;\r\ndata = count | CDNS_WDT_REGISTER_ACCESS_KEY | wdt->ctrl_clksel;\r\ncdns_wdt_writereg(wdt, CDNS_WDT_CCR_OFFSET, data);\r\ndata = CDNS_WDT_ZMR_WDEN_MASK | CDNS_WDT_ZMR_RSTLEN_16 |\r\nCDNS_WDT_ZMR_ZKEY_VAL;\r\nif (wdt->rst) {\r\ndata |= CDNS_WDT_ZMR_RSTEN_MASK;\r\ndata &= ~CDNS_WDT_ZMR_IRQEN_MASK;\r\n} else {\r\ndata &= ~CDNS_WDT_ZMR_RSTEN_MASK;\r\ndata |= CDNS_WDT_ZMR_IRQEN_MASK;\r\n}\r\ncdns_wdt_writereg(wdt, CDNS_WDT_ZMR_OFFSET, data);\r\ncdns_wdt_writereg(wdt, CDNS_WDT_RESTART_OFFSET,\r\nCDNS_WDT_RESTART_KEY);\r\nspin_unlock(&wdt->io_lock);\r\nreturn 0;\r\n}\r\nstatic int cdns_wdt_settimeout(struct watchdog_device *wdd,\r\nunsigned int new_time)\r\n{\r\nwdd->timeout = new_time;\r\nreturn cdns_wdt_start(wdd);\r\n}\r\nstatic irqreturn_t cdns_wdt_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = dev_id;\r\ndev_info(&pdev->dev,\r\n"Watchdog timed out. Internal reset not enabled\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cdns_wdt_notify_sys(struct notifier_block *this, unsigned long code,\r\nvoid *unused)\r\n{\r\nstruct cdns_wdt *wdt = container_of(this, struct cdns_wdt,\r\ncdns_wdt_notifier);\r\nif (code == SYS_DOWN || code == SYS_HALT)\r\ncdns_wdt_stop(&wdt->cdns_wdt_device);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int cdns_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret, irq;\r\nunsigned long clock_f;\r\nstruct cdns_wdt *wdt;\r\nstruct watchdog_device *cdns_wdt_device;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\ncdns_wdt_device = &wdt->cdns_wdt_device;\r\ncdns_wdt_device->info = &cdns_wdt_info;\r\ncdns_wdt_device->ops = &cdns_wdt_ops;\r\ncdns_wdt_device->timeout = CDNS_WDT_DEFAULT_TIMEOUT;\r\ncdns_wdt_device->min_timeout = CDNS_WDT_MIN_TIMEOUT;\r\ncdns_wdt_device->max_timeout = CDNS_WDT_MAX_TIMEOUT;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nwdt->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(wdt->regs))\r\nreturn PTR_ERR(wdt->regs);\r\nwdt->rst = of_property_read_bool(pdev->dev.of_node, "reset-on-timeout");\r\nirq = platform_get_irq(pdev, 0);\r\nif (!wdt->rst && irq >= 0) {\r\nret = devm_request_irq(&pdev->dev, irq, cdns_wdt_irq_handler, 0,\r\npdev->name, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"cannot register interrupt handler err=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\ncdns_wdt_device->parent = &pdev->dev;\r\nret = watchdog_init_timeout(cdns_wdt_device, wdt_timeout, &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to set timeout value\n");\r\nreturn ret;\r\n}\r\nwatchdog_set_nowayout(cdns_wdt_device, nowayout);\r\nwatchdog_set_drvdata(cdns_wdt_device, wdt);\r\nwdt->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(wdt->clk)) {\r\ndev_err(&pdev->dev, "input clock not found\n");\r\nret = PTR_ERR(wdt->clk);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(wdt->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to enable clock\n");\r\nreturn ret;\r\n}\r\nclock_f = clk_get_rate(wdt->clk);\r\nif (clock_f <= CDNS_WDT_CLK_75MHZ) {\r\nwdt->prescaler = CDNS_WDT_PRESCALE_512;\r\nwdt->ctrl_clksel = CDNS_WDT_PRESCALE_SELECT_512;\r\n} else {\r\nwdt->prescaler = CDNS_WDT_PRESCALE_4096;\r\nwdt->ctrl_clksel = CDNS_WDT_PRESCALE_SELECT_4096;\r\n}\r\nspin_lock_init(&wdt->io_lock);\r\nwdt->cdns_wdt_notifier.notifier_call = &cdns_wdt_notify_sys;\r\nret = register_reboot_notifier(&wdt->cdns_wdt_notifier);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "cannot register reboot notifier err=%d)\n",\r\nret);\r\ngoto err_clk_disable;\r\n}\r\nret = watchdog_register_device(cdns_wdt_device);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register wdt device\n");\r\ngoto err_clk_disable;\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\ndev_dbg(&pdev->dev, "Xilinx Watchdog Timer at %p with timeout %ds%s\n",\r\nwdt->regs, cdns_wdt_device->timeout,\r\nnowayout ? ", nowayout" : "");\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(wdt->clk);\r\nreturn ret;\r\n}\r\nstatic int cdns_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct cdns_wdt *wdt = platform_get_drvdata(pdev);\r\ncdns_wdt_stop(&wdt->cdns_wdt_device);\r\nwatchdog_unregister_device(&wdt->cdns_wdt_device);\r\nunregister_reboot_notifier(&wdt->cdns_wdt_notifier);\r\nclk_disable_unprepare(wdt->clk);\r\nreturn 0;\r\n}\r\nstatic void cdns_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct cdns_wdt *wdt = platform_get_drvdata(pdev);\r\ncdns_wdt_stop(&wdt->cdns_wdt_device);\r\nclk_disable_unprepare(wdt->clk);\r\n}\r\nstatic int __maybe_unused cdns_wdt_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = container_of(dev,\r\nstruct platform_device, dev);\r\nstruct cdns_wdt *wdt = platform_get_drvdata(pdev);\r\ncdns_wdt_stop(&wdt->cdns_wdt_device);\r\nclk_disable_unprepare(wdt->clk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused cdns_wdt_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct platform_device *pdev = container_of(dev,\r\nstruct platform_device, dev);\r\nstruct cdns_wdt *wdt = platform_get_drvdata(pdev);\r\nret = clk_prepare_enable(wdt->clk);\r\nif (ret) {\r\ndev_err(dev, "unable to enable clock\n");\r\nreturn ret;\r\n}\r\ncdns_wdt_start(&wdt->cdns_wdt_device);\r\nreturn 0;\r\n}
