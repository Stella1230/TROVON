static __inline__ int\r\neat_words(const uint32_t **buf, const uint32_t *buf_end, unsigned num_words)\r\n{\r\nif ((buf_end - *buf) >= num_words) {\r\n*buf += num_words;\r\nreturn 0;\r\n}\r\nDRM_ERROR("Illegal termination of DMA command buffer\n");\r\nreturn 1;\r\n}\r\nstatic __inline__ drm_local_map_t *via_drm_lookup_agp_map(drm_via_state_t *seq,\r\nunsigned long offset,\r\nunsigned long size,\r\nstruct drm_device *dev)\r\n{\r\nstruct drm_map_list *r_list;\r\ndrm_local_map_t *map = seq->map_cache;\r\nif (map && map->offset <= offset\r\n&& (offset + size) <= (map->offset + map->size)) {\r\nreturn map;\r\n}\r\nlist_for_each_entry(r_list, &dev->maplist, head) {\r\nmap = r_list->map;\r\nif (!map)\r\ncontinue;\r\nif (map->offset <= offset\r\n&& (offset + size) <= (map->offset + map->size)\r\n&& !(map->flags & _DRM_RESTRICTED)\r\n&& (map->type == _DRM_AGP)) {\r\nseq->map_cache = map;\r\nreturn map;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic __inline__ int finish_current_sequence(drm_via_state_t * cur_seq)\r\n{\r\nswitch (cur_seq->unfinished) {\r\ncase z_address:\r\nDRM_DEBUG("Z Buffer start address is 0x%x\n", cur_seq->z_addr);\r\nbreak;\r\ncase dest_address:\r\nDRM_DEBUG("Destination start address is 0x%x\n",\r\ncur_seq->d_addr);\r\nbreak;\r\ncase tex_address:\r\nif (cur_seq->agp_texture) {\r\nunsigned start =\r\ncur_seq->tex_level_lo[cur_seq->texture];\r\nunsigned end = cur_seq->tex_level_hi[cur_seq->texture];\r\nunsigned long lo = ~0, hi = 0, tmp;\r\nuint32_t *addr, *pitch, *height, tex;\r\nunsigned i;\r\nint npot;\r\nif (end > 9)\r\nend = 9;\r\nif (start > 9)\r\nstart = 9;\r\naddr =\r\n&(cur_seq->t_addr[tex = cur_seq->texture][start]);\r\npitch = &(cur_seq->pitch[tex][start]);\r\nheight = &(cur_seq->height[tex][start]);\r\nnpot = cur_seq->tex_npot[tex];\r\nfor (i = start; i <= end; ++i) {\r\ntmp = *addr++;\r\nif (tmp < lo)\r\nlo = tmp;\r\nif (i == 0 && npot)\r\ntmp += (*height++ * *pitch++);\r\nelse\r\ntmp += (*height++ << *pitch++);\r\nif (tmp > hi)\r\nhi = tmp;\r\n}\r\nif (!via_drm_lookup_agp_map\r\n(cur_seq, lo, hi - lo, cur_seq->dev)) {\r\nDRM_ERROR\r\n("AGP texture is not in allowed map\n");\r\nreturn 2;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncur_seq->unfinished = no_sequence;\r\nreturn 0;\r\n}\r\nstatic __inline__ int\r\ninvestigate_hazard(uint32_t cmd, hazard_t hz, drm_via_state_t *cur_seq)\r\n{\r\nregister uint32_t tmp, *tmp_addr;\r\nif (cur_seq->unfinished && (cur_seq->unfinished != seqs[hz])) {\r\nint ret;\r\nif ((ret = finish_current_sequence(cur_seq)))\r\nreturn ret;\r\n}\r\nswitch (hz) {\r\ncase check_for_header2:\r\nif (cmd == HALCYON_HEADER2)\r\nreturn 1;\r\nreturn 0;\r\ncase check_for_header1:\r\nif ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)\r\nreturn 1;\r\nreturn 0;\r\ncase check_for_header2_err:\r\nif (cmd == HALCYON_HEADER2)\r\nreturn 1;\r\nDRM_ERROR("Illegal DMA HALCYON_HEADER2 command\n");\r\nbreak;\r\ncase check_for_header1_err:\r\nif ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)\r\nreturn 1;\r\nDRM_ERROR("Illegal DMA HALCYON_HEADER1 command\n");\r\nbreak;\r\ncase check_for_fire:\r\nif ((cmd & HALCYON_FIREMASK) == HALCYON_FIRECMD)\r\nreturn 1;\r\nDRM_ERROR("Illegal DMA HALCYON_FIRECMD command\n");\r\nbreak;\r\ncase check_for_dummy:\r\nif (HC_DUMMY == cmd)\r\nreturn 0;\r\nDRM_ERROR("Illegal DMA HC_DUMMY command\n");\r\nbreak;\r\ncase check_for_dd:\r\nif (0xdddddddd == cmd)\r\nreturn 0;\r\nDRM_ERROR("Illegal DMA 0xdddddddd command\n");\r\nbreak;\r\ncase check_z_buffer_addr0:\r\ncur_seq->unfinished = z_address;\r\ncur_seq->z_addr = (cur_seq->z_addr & 0xFF000000) |\r\n(cmd & 0x00FFFFFF);\r\nreturn 0;\r\ncase check_z_buffer_addr1:\r\ncur_seq->unfinished = z_address;\r\ncur_seq->z_addr = (cur_seq->z_addr & 0x00FFFFFF) |\r\n((cmd & 0xFF) << 24);\r\nreturn 0;\r\ncase check_z_buffer_addr_mode:\r\ncur_seq->unfinished = z_address;\r\nif ((cmd & 0x0000C000) == 0)\r\nreturn 0;\r\nDRM_ERROR("Attempt to place Z buffer in system memory\n");\r\nreturn 2;\r\ncase check_destination_addr0:\r\ncur_seq->unfinished = dest_address;\r\ncur_seq->d_addr = (cur_seq->d_addr & 0xFF000000) |\r\n(cmd & 0x00FFFFFF);\r\nreturn 0;\r\ncase check_destination_addr1:\r\ncur_seq->unfinished = dest_address;\r\ncur_seq->d_addr = (cur_seq->d_addr & 0x00FFFFFF) |\r\n((cmd & 0xFF) << 24);\r\nreturn 0;\r\ncase check_destination_addr_mode:\r\ncur_seq->unfinished = dest_address;\r\nif ((cmd & 0x0000C000) == 0)\r\nreturn 0;\r\nDRM_ERROR\r\n("Attempt to place 3D drawing buffer in system memory\n");\r\nreturn 2;\r\ncase check_texture_addr0:\r\ncur_seq->unfinished = tex_address;\r\ntmp = (cmd >> 24);\r\ntmp_addr = &cur_seq->t_addr[cur_seq->texture][tmp];\r\n*tmp_addr = (*tmp_addr & 0xFF000000) | (cmd & 0x00FFFFFF);\r\nreturn 0;\r\ncase check_texture_addr1:\r\ncur_seq->unfinished = tex_address;\r\ntmp = ((cmd >> 24) - 0x20);\r\ntmp += tmp << 1;\r\ntmp_addr = &cur_seq->t_addr[cur_seq->texture][tmp];\r\n*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF) << 24);\r\ntmp_addr++;\r\n*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF00) << 16);\r\ntmp_addr++;\r\n*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF0000) << 8);\r\nreturn 0;\r\ncase check_texture_addr2:\r\ncur_seq->unfinished = tex_address;\r\ncur_seq->tex_level_lo[tmp = cur_seq->texture] = cmd & 0x3F;\r\ncur_seq->tex_level_hi[tmp] = (cmd & 0xFC0) >> 6;\r\nreturn 0;\r\ncase check_texture_addr3:\r\ncur_seq->unfinished = tex_address;\r\ntmp = ((cmd >> 24) - HC_SubA_HTXnL0Pit);\r\nif (tmp == 0 &&\r\n(cmd & HC_HTXnEnPit_MASK)) {\r\ncur_seq->pitch[cur_seq->texture][tmp] =\r\n(cmd & HC_HTXnLnPit_MASK);\r\ncur_seq->tex_npot[cur_seq->texture] = 1;\r\n} else {\r\ncur_seq->pitch[cur_seq->texture][tmp] =\r\n(cmd & HC_HTXnLnPitE_MASK) >> HC_HTXnLnPitE_SHIFT;\r\ncur_seq->tex_npot[cur_seq->texture] = 0;\r\nif (cmd & 0x000FFFFF) {\r\nDRM_ERROR\r\n("Unimplemented texture level 0 pitch mode.\n");\r\nreturn 2;\r\n}\r\n}\r\nreturn 0;\r\ncase check_texture_addr4:\r\ncur_seq->unfinished = tex_address;\r\ntmp_addr = &cur_seq->t_addr[cur_seq->texture][9];\r\n*tmp_addr = (*tmp_addr & 0x00FFFFFF) | ((cmd & 0xFF) << 24);\r\nreturn 0;\r\ncase check_texture_addr5:\r\ncase check_texture_addr6:\r\ncur_seq->unfinished = tex_address;\r\nreturn 0;\r\ncase check_texture_addr7:\r\ncur_seq->unfinished = tex_address;\r\ntmp_addr = &(cur_seq->height[cur_seq->texture][0]);\r\ntmp_addr[5] = 1 << ((cmd & 0x00F00000) >> 20);\r\ntmp_addr[4] = 1 << ((cmd & 0x000F0000) >> 16);\r\ntmp_addr[3] = 1 << ((cmd & 0x0000F000) >> 12);\r\ntmp_addr[2] = 1 << ((cmd & 0x00000F00) >> 8);\r\ntmp_addr[1] = 1 << ((cmd & 0x000000F0) >> 4);\r\ntmp_addr[0] = 1 << (cmd & 0x0000000F);\r\nreturn 0;\r\ncase check_texture_addr8:\r\ncur_seq->unfinished = tex_address;\r\ntmp_addr = &(cur_seq->height[cur_seq->texture][0]);\r\ntmp_addr[9] = 1 << ((cmd & 0x0000F000) >> 12);\r\ntmp_addr[8] = 1 << ((cmd & 0x00000F00) >> 8);\r\ntmp_addr[7] = 1 << ((cmd & 0x000000F0) >> 4);\r\ntmp_addr[6] = 1 << (cmd & 0x0000000F);\r\nreturn 0;\r\ncase check_texture_addr_mode:\r\ncur_seq->unfinished = tex_address;\r\nif (2 == (tmp = cmd & 0x00000003)) {\r\nDRM_ERROR\r\n("Attempt to fetch texture from system memory.\n");\r\nreturn 2;\r\n}\r\ncur_seq->agp_texture = (tmp == 3);\r\ncur_seq->tex_palette_size[cur_seq->texture] =\r\n(cmd >> 16) & 0x000000007;\r\nreturn 0;\r\ncase check_for_vertex_count:\r\ncur_seq->vertex_count = cmd & 0x0000FFFF;\r\nreturn 0;\r\ncase check_number_texunits:\r\ncur_seq->multitex = (cmd >> 3) & 1;\r\nreturn 0;\r\ndefault:\r\nDRM_ERROR("Illegal DMA data: 0x%x\n", cmd);\r\nreturn 2;\r\n}\r\nreturn 2;\r\n}\r\nstatic __inline__ int\r\nvia_check_prim_list(uint32_t const **buffer, const uint32_t * buf_end,\r\ndrm_via_state_t *cur_seq)\r\n{\r\ndrm_via_private_t *dev_priv =\r\n(drm_via_private_t *) cur_seq->dev->dev_private;\r\nuint32_t a_fire, bcmd, dw_count;\r\nint ret = 0;\r\nint have_fire;\r\nconst uint32_t *buf = *buffer;\r\nwhile (buf < buf_end) {\r\nhave_fire = 0;\r\nif ((buf_end - buf) < 2) {\r\nDRM_ERROR\r\n("Unexpected termination of primitive list.\n");\r\nret = 1;\r\nbreak;\r\n}\r\nif ((*buf & HC_ACMD_MASK) != HC_ACMD_HCmdB)\r\nbreak;\r\nbcmd = *buf++;\r\nif ((*buf & HC_ACMD_MASK) != HC_ACMD_HCmdA) {\r\nDRM_ERROR("Expected Vertex List A command, got 0x%x\n",\r\n*buf);\r\nret = 1;\r\nbreak;\r\n}\r\na_fire =\r\n*buf++ | HC_HPLEND_MASK | HC_HPMValidN_MASK |\r\nHC_HE3Fire_MASK;\r\nif (cur_seq->agp && ((bcmd & (0xF << 11)) == 0)) {\r\nDRM_ERROR("Illegal B command vertex data for AGP.\n");\r\nret = 1;\r\nbreak;\r\n}\r\ndw_count = 0;\r\nif (bcmd & (1 << 7))\r\ndw_count += (cur_seq->multitex) ? 2 : 1;\r\nif (bcmd & (1 << 8))\r\ndw_count += (cur_seq->multitex) ? 2 : 1;\r\nif (bcmd & (1 << 9))\r\ndw_count++;\r\nif (bcmd & (1 << 10))\r\ndw_count++;\r\nif (bcmd & (1 << 11))\r\ndw_count++;\r\nif (bcmd & (1 << 12))\r\ndw_count++;\r\nif (bcmd & (1 << 13))\r\ndw_count++;\r\nif (bcmd & (1 << 14))\r\ndw_count++;\r\nwhile (buf < buf_end) {\r\nif (*buf == a_fire) {\r\nif (dev_priv->num_fire_offsets >=\r\nVIA_FIRE_BUF_SIZE) {\r\nDRM_ERROR("Fire offset buffer full.\n");\r\nret = 1;\r\nbreak;\r\n}\r\ndev_priv->fire_offsets[dev_priv->\r\nnum_fire_offsets++] =\r\nbuf;\r\nhave_fire = 1;\r\nbuf++;\r\nif (buf < buf_end && *buf == a_fire)\r\nbuf++;\r\nbreak;\r\n}\r\nif ((*buf == HALCYON_HEADER2) ||\r\n((*buf & HALCYON_FIREMASK) == HALCYON_FIRECMD)) {\r\nDRM_ERROR("Missing Vertex Fire command, "\r\n"Stray Vertex Fire command or verifier "\r\n"lost sync.\n");\r\nret = 1;\r\nbreak;\r\n}\r\nif ((ret = eat_words(&buf, buf_end, dw_count)))\r\nbreak;\r\n}\r\nif (buf >= buf_end && !have_fire) {\r\nDRM_ERROR("Missing Vertex Fire command or verifier "\r\n"lost sync.\n");\r\nret = 1;\r\nbreak;\r\n}\r\nif (cur_seq->agp && ((buf - cur_seq->buf_start) & 0x01)) {\r\nDRM_ERROR("AGP Primitive list end misaligned.\n");\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\n*buffer = buf;\r\nreturn ret;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_check_header2(uint32_t const **buffer, const uint32_t *buf_end,\r\ndrm_via_state_t *hc_state)\r\n{\r\nuint32_t cmd;\r\nint hz_mode;\r\nhazard_t hz;\r\nconst uint32_t *buf = *buffer;\r\nconst hazard_t *hz_table;\r\nif ((buf_end - buf) < 2) {\r\nDRM_ERROR\r\n("Illegal termination of DMA HALCYON_HEADER2 sequence.\n");\r\nreturn state_error;\r\n}\r\nbuf++;\r\ncmd = (*buf++ & 0xFFFF0000) >> 16;\r\nswitch (cmd) {\r\ncase HC_ParaType_CmdVdata:\r\nif (via_check_prim_list(&buf, buf_end, hc_state))\r\nreturn state_error;\r\n*buffer = buf;\r\nreturn state_command;\r\ncase HC_ParaType_NotTex:\r\nhz_table = table1;\r\nbreak;\r\ncase HC_ParaType_Tex:\r\nhc_state->texture = 0;\r\nhz_table = table2;\r\nbreak;\r\ncase (HC_ParaType_Tex | (HC_SubType_Tex1 << 8)):\r\nhc_state->texture = 1;\r\nhz_table = table2;\r\nbreak;\r\ncase (HC_ParaType_Tex | (HC_SubType_TexGeneral << 8)):\r\nhz_table = table3;\r\nbreak;\r\ncase HC_ParaType_Auto:\r\nif (eat_words(&buf, buf_end, 2))\r\nreturn state_error;\r\n*buffer = buf;\r\nreturn state_command;\r\ncase (HC_ParaType_Palette | (HC_SubType_Stipple << 8)):\r\nif (eat_words(&buf, buf_end, 32))\r\nreturn state_error;\r\n*buffer = buf;\r\nreturn state_command;\r\ncase (HC_ParaType_Palette | (HC_SubType_TexPalette0 << 8)):\r\ncase (HC_ParaType_Palette | (HC_SubType_TexPalette1 << 8)):\r\nDRM_ERROR("Texture palettes are rejected because of "\r\n"lack of info how to determine their size.\n");\r\nreturn state_error;\r\ncase (HC_ParaType_Palette | (HC_SubType_FogTable << 8)):\r\nDRM_ERROR("Fog factor palettes are rejected because of "\r\n"lack of info how to determine their size.\n");\r\nreturn state_error;\r\ndefault:\r\nDRM_ERROR("Invalid or unimplemented HALCYON_HEADER2 "\r\n"DMA subcommand: 0x%x. Previous dword: 0x%x\n",\r\ncmd, *(buf - 2));\r\n*buffer = buf;\r\nreturn state_error;\r\n}\r\nwhile (buf < buf_end) {\r\ncmd = *buf++;\r\nif ((hz = hz_table[cmd >> 24])) {\r\nif ((hz_mode = investigate_hazard(cmd, hz, hc_state))) {\r\nif (hz_mode == 1) {\r\nbuf--;\r\nbreak;\r\n}\r\nreturn state_error;\r\n}\r\n} else if (hc_state->unfinished &&\r\nfinish_current_sequence(hc_state)) {\r\nreturn state_error;\r\n}\r\n}\r\nif (hc_state->unfinished && finish_current_sequence(hc_state))\r\nreturn state_error;\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_parse_header2(drm_via_private_t *dev_priv, uint32_t const **buffer,\r\nconst uint32_t *buf_end, int *fire_count)\r\n{\r\nuint32_t cmd;\r\nconst uint32_t *buf = *buffer;\r\nconst uint32_t *next_fire;\r\nint burst = 0;\r\nnext_fire = dev_priv->fire_offsets[*fire_count];\r\nbuf++;\r\ncmd = (*buf & 0xFFFF0000) >> 16;\r\nVIA_WRITE(HC_REG_TRANS_SET + HC_REG_BASE, *buf++);\r\nswitch (cmd) {\r\ncase HC_ParaType_CmdVdata:\r\nwhile ((buf < buf_end) &&\r\n(*fire_count < dev_priv->num_fire_offsets) &&\r\n(*buf & HC_ACMD_MASK) == HC_ACMD_HCmdB) {\r\nwhile (buf <= next_fire) {\r\nVIA_WRITE(HC_REG_TRANS_SPACE + HC_REG_BASE +\r\n(burst & 63), *buf++);\r\nburst += 4;\r\n}\r\nif ((buf < buf_end)\r\n&& ((*buf & HALCYON_FIREMASK) == HALCYON_FIRECMD))\r\nbuf++;\r\nif (++(*fire_count) < dev_priv->num_fire_offsets)\r\nnext_fire = dev_priv->fire_offsets[*fire_count];\r\n}\r\nbreak;\r\ndefault:\r\nwhile (buf < buf_end) {\r\nif (*buf == HC_HEADER2 ||\r\n(*buf & HALCYON_HEADER1MASK) == HALCYON_HEADER1 ||\r\n(*buf & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5 ||\r\n(*buf & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)\r\nbreak;\r\nVIA_WRITE(HC_REG_TRANS_SPACE + HC_REG_BASE +\r\n(burst & 63), *buf++);\r\nburst += 4;\r\n}\r\n}\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nstatic __inline__ int verify_mmio_address(uint32_t address)\r\n{\r\nif ((address > 0x3FF) && (address < 0xC00)) {\r\nDRM_ERROR("Invalid VIDEO DMA command. "\r\n"Attempt to access 3D- or command burst area.\n");\r\nreturn 1;\r\n} else if ((address > 0xCFF) && (address < 0x1300)) {\r\nDRM_ERROR("Invalid VIDEO DMA command. "\r\n"Attempt to access PCI DMA area.\n");\r\nreturn 1;\r\n} else if (address > 0x13FF) {\r\nDRM_ERROR("Invalid VIDEO DMA command. "\r\n"Attempt to access VGA registers.\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ int\r\nverify_video_tail(uint32_t const **buffer, const uint32_t * buf_end,\r\nuint32_t dwords)\r\n{\r\nconst uint32_t *buf = *buffer;\r\nif (buf_end - buf < dwords) {\r\nDRM_ERROR("Illegal termination of video command.\n");\r\nreturn 1;\r\n}\r\nwhile (dwords--) {\r\nif (*buf++) {\r\nDRM_ERROR("Illegal video command tail.\n");\r\nreturn 1;\r\n}\r\n}\r\n*buffer = buf;\r\nreturn 0;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_check_header1(uint32_t const **buffer, const uint32_t * buf_end)\r\n{\r\nuint32_t cmd;\r\nconst uint32_t *buf = *buffer;\r\nverifier_state_t ret = state_command;\r\nwhile (buf < buf_end) {\r\ncmd = *buf;\r\nif ((cmd > ((0x3FF >> 2) | HALCYON_HEADER1)) &&\r\n(cmd < ((0xC00 >> 2) | HALCYON_HEADER1))) {\r\nif ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1)\r\nbreak;\r\nDRM_ERROR("Invalid HALCYON_HEADER1 command. "\r\n"Attempt to access 3D- or command burst area.\n");\r\nret = state_error;\r\nbreak;\r\n} else if (cmd > ((0xCFF >> 2) | HALCYON_HEADER1)) {\r\nif ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1)\r\nbreak;\r\nDRM_ERROR("Invalid HALCYON_HEADER1 command. "\r\n"Attempt to access VGA registers.\n");\r\nret = state_error;\r\nbreak;\r\n} else {\r\nbuf += 2;\r\n}\r\n}\r\n*buffer = buf;\r\nreturn ret;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_parse_header1(drm_via_private_t *dev_priv, uint32_t const **buffer,\r\nconst uint32_t *buf_end)\r\n{\r\nregister uint32_t cmd;\r\nconst uint32_t *buf = *buffer;\r\nwhile (buf < buf_end) {\r\ncmd = *buf;\r\nif ((cmd & HALCYON_HEADER1MASK) != HALCYON_HEADER1)\r\nbreak;\r\nVIA_WRITE((cmd & ~HALCYON_HEADER1MASK) << 2, *++buf);\r\nbuf++;\r\n}\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_check_vheader5(uint32_t const **buffer, const uint32_t *buf_end)\r\n{\r\nuint32_t data;\r\nconst uint32_t *buf = *buffer;\r\nif (buf_end - buf < 4) {\r\nDRM_ERROR("Illegal termination of video header5 command\n");\r\nreturn state_error;\r\n}\r\ndata = *buf++ & ~VIA_VIDEOMASK;\r\nif (verify_mmio_address(data))\r\nreturn state_error;\r\ndata = *buf++;\r\nif (*buf++ != 0x00F50000) {\r\nDRM_ERROR("Illegal header5 header data\n");\r\nreturn state_error;\r\n}\r\nif (*buf++ != 0x00000000) {\r\nDRM_ERROR("Illegal header5 header data\n");\r\nreturn state_error;\r\n}\r\nif (eat_words(&buf, buf_end, data))\r\nreturn state_error;\r\nif ((data & 3) && verify_video_tail(&buf, buf_end, 4 - (data & 3)))\r\nreturn state_error;\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_parse_vheader5(drm_via_private_t *dev_priv, uint32_t const **buffer,\r\nconst uint32_t *buf_end)\r\n{\r\nuint32_t addr, count, i;\r\nconst uint32_t *buf = *buffer;\r\naddr = *buf++ & ~VIA_VIDEOMASK;\r\ni = count = *buf;\r\nbuf += 3;\r\nwhile (i--)\r\nVIA_WRITE(addr, *buf++);\r\nif (count & 3)\r\nbuf += 4 - (count & 3);\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_check_vheader6(uint32_t const **buffer, const uint32_t * buf_end)\r\n{\r\nuint32_t data;\r\nconst uint32_t *buf = *buffer;\r\nuint32_t i;\r\nif (buf_end - buf < 4) {\r\nDRM_ERROR("Illegal termination of video header6 command\n");\r\nreturn state_error;\r\n}\r\nbuf++;\r\ndata = *buf++;\r\nif (*buf++ != 0x00F60000) {\r\nDRM_ERROR("Illegal header6 header data\n");\r\nreturn state_error;\r\n}\r\nif (*buf++ != 0x00000000) {\r\nDRM_ERROR("Illegal header6 header data\n");\r\nreturn state_error;\r\n}\r\nif ((buf_end - buf) < (data << 1)) {\r\nDRM_ERROR("Illegal termination of video header6 command\n");\r\nreturn state_error;\r\n}\r\nfor (i = 0; i < data; ++i) {\r\nif (verify_mmio_address(*buf++))\r\nreturn state_error;\r\nbuf++;\r\n}\r\ndata <<= 1;\r\nif ((data & 3) && verify_video_tail(&buf, buf_end, 4 - (data & 3)))\r\nreturn state_error;\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nstatic __inline__ verifier_state_t\r\nvia_parse_vheader6(drm_via_private_t *dev_priv, uint32_t const **buffer,\r\nconst uint32_t *buf_end)\r\n{\r\nuint32_t addr, count, i;\r\nconst uint32_t *buf = *buffer;\r\ni = count = *++buf;\r\nbuf += 3;\r\nwhile (i--) {\r\naddr = *buf++;\r\nVIA_WRITE(addr, *buf++);\r\n}\r\ncount <<= 1;\r\nif (count & 3)\r\nbuf += 4 - (count & 3);\r\n*buffer = buf;\r\nreturn state_command;\r\n}\r\nint\r\nvia_verify_command_stream(const uint32_t * buf, unsigned int size,\r\nstruct drm_device * dev, int agp)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\ndrm_via_state_t *hc_state = &dev_priv->hc_state;\r\ndrm_via_state_t saved_state = *hc_state;\r\nuint32_t cmd;\r\nconst uint32_t *buf_end = buf + (size >> 2);\r\nverifier_state_t state = state_command;\r\nint cme_video;\r\nint supported_3d;\r\ncme_video = (dev_priv->chipset == VIA_PRO_GROUP_A ||\r\ndev_priv->chipset == VIA_DX9_0);\r\nsupported_3d = dev_priv->chipset != VIA_DX9_0;\r\nhc_state->dev = dev;\r\nhc_state->unfinished = no_sequence;\r\nhc_state->map_cache = NULL;\r\nhc_state->agp = agp;\r\nhc_state->buf_start = buf;\r\ndev_priv->num_fire_offsets = 0;\r\nwhile (buf < buf_end) {\r\nswitch (state) {\r\ncase state_header2:\r\nstate = via_check_header2(&buf, buf_end, hc_state);\r\nbreak;\r\ncase state_header1:\r\nstate = via_check_header1(&buf, buf_end);\r\nbreak;\r\ncase state_vheader5:\r\nstate = via_check_vheader5(&buf, buf_end);\r\nbreak;\r\ncase state_vheader6:\r\nstate = via_check_vheader6(&buf, buf_end);\r\nbreak;\r\ncase state_command:\r\nif ((HALCYON_HEADER2 == (cmd = *buf)) &&\r\nsupported_3d)\r\nstate = state_header2;\r\nelse if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)\r\nstate = state_header1;\r\nelse if (cme_video\r\n&& (cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5)\r\nstate = state_vheader5;\r\nelse if (cme_video\r\n&& (cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)\r\nstate = state_vheader6;\r\nelse if ((cmd == HALCYON_HEADER2) && !supported_3d) {\r\nDRM_ERROR("Accelerated 3D is not supported on this chipset yet.\n");\r\nstate = state_error;\r\n} else {\r\nDRM_ERROR\r\n("Invalid / Unimplemented DMA HEADER command. 0x%x\n",\r\ncmd);\r\nstate = state_error;\r\n}\r\nbreak;\r\ncase state_error:\r\ndefault:\r\n*hc_state = saved_state;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (state == state_error) {\r\n*hc_state = saved_state;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nvia_parse_command_stream(struct drm_device *dev, const uint32_t *buf,\r\nunsigned int size)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nuint32_t cmd;\r\nconst uint32_t *buf_end = buf + (size >> 2);\r\nverifier_state_t state = state_command;\r\nint fire_count = 0;\r\nwhile (buf < buf_end) {\r\nswitch (state) {\r\ncase state_header2:\r\nstate =\r\nvia_parse_header2(dev_priv, &buf, buf_end,\r\n&fire_count);\r\nbreak;\r\ncase state_header1:\r\nstate = via_parse_header1(dev_priv, &buf, buf_end);\r\nbreak;\r\ncase state_vheader5:\r\nstate = via_parse_vheader5(dev_priv, &buf, buf_end);\r\nbreak;\r\ncase state_vheader6:\r\nstate = via_parse_vheader6(dev_priv, &buf, buf_end);\r\nbreak;\r\ncase state_command:\r\nif (HALCYON_HEADER2 == (cmd = *buf))\r\nstate = state_header2;\r\nelse if ((cmd & HALCYON_HEADER1MASK) == HALCYON_HEADER1)\r\nstate = state_header1;\r\nelse if ((cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER5)\r\nstate = state_vheader5;\r\nelse if ((cmd & VIA_VIDEOMASK) == VIA_VIDEO_HEADER6)\r\nstate = state_vheader6;\r\nelse {\r\nDRM_ERROR\r\n("Invalid / Unimplemented DMA HEADER command. 0x%x\n",\r\ncmd);\r\nstate = state_error;\r\n}\r\nbreak;\r\ncase state_error:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (state == state_error)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void\r\nsetup_hazard_table(hz_init_t init_table[], hazard_t table[], int size)\r\n{\r\nint i;\r\nfor (i = 0; i < 256; ++i)\r\ntable[i] = forbidden_command;\r\nfor (i = 0; i < size; ++i)\r\ntable[init_table[i].code] = init_table[i].hz;\r\n}\r\nvoid via_init_command_verifier(void)\r\n{\r\nsetup_hazard_table(init_table1, table1,\r\nsizeof(init_table1) / sizeof(hz_init_t));\r\nsetup_hazard_table(init_table2, table2,\r\nsizeof(init_table2) / sizeof(hz_init_t));\r\nsetup_hazard_table(init_table3, table3,\r\nsizeof(init_table3) / sizeof(hz_init_t));\r\n}
