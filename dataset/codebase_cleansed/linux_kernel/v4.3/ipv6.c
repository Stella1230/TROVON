static inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,\r\nconst struct in6_addr *saddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nreturn csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);\r\n}\r\nstatic inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct dccp_hdr *dh = dccp_hdr(skb);\r\ndccp_csum_outgoing(skb);\r\ndh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &sk->sk_v6_daddr);\r\n}\r\nstatic inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\r\n{\r\nreturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\r\nipv6_hdr(skb)->saddr.s6_addr32,\r\ndccp_hdr(skb)->dccph_dport,\r\ndccp_hdr(skb)->dccph_sport );\r\n}\r\nstatic void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\nconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\r\nconst struct dccp_hdr *dh = (struct dccp_hdr *)(skb->data + offset);\r\nstruct dccp_sock *dp;\r\nstruct ipv6_pinfo *np;\r\nstruct sock *sk;\r\nint err;\r\n__u64 seq;\r\nstruct net *net = dev_net(skb->dev);\r\nif (skb->len < offset + sizeof(*dh) ||\r\nskb->len < offset + __dccp_basic_hdr_len(dh)) {\r\nICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\r\nICMP6_MIB_INERRORS);\r\nreturn;\r\n}\r\nsk = __inet6_lookup_established(net, &dccp_hashinfo,\r\n&hdr->daddr, dh->dccph_dport,\r\n&hdr->saddr, ntohs(dh->dccph_sport),\r\ninet6_iif(skb));\r\nif (!sk) {\r\nICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),\r\nICMP6_MIB_INERRORS);\r\nreturn;\r\n}\r\nif (sk->sk_state == DCCP_TIME_WAIT) {\r\ninet_twsk_put(inet_twsk(sk));\r\nreturn;\r\n}\r\nseq = dccp_hdr_seq(dh);\r\nif (sk->sk_state == DCCP_NEW_SYN_RECV)\r\nreturn dccp_req_err(sk, seq);\r\nbh_lock_sock(sk);\r\nif (sock_owned_by_user(sk))\r\nNET_INC_STATS_BH(net, LINUX_MIB_LOCKDROPPEDICMPS);\r\nif (sk->sk_state == DCCP_CLOSED)\r\ngoto out;\r\ndp = dccp_sk(sk);\r\nif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\r\n!between48(seq, dp->dccps_awl, dp->dccps_awh)) {\r\nNET_INC_STATS_BH(net, LINUX_MIB_OUTOFWINDOWICMPS);\r\ngoto out;\r\n}\r\nnp = inet6_sk(sk);\r\nif (type == NDISC_REDIRECT) {\r\nstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\r\nif (dst)\r\ndst->ops->redirect(dst, sk, skb);\r\ngoto out;\r\n}\r\nif (type == ICMPV6_PKT_TOOBIG) {\r\nstruct dst_entry *dst = NULL;\r\nif (!ip6_sk_accept_pmtu(sk))\r\ngoto out;\r\nif (sock_owned_by_user(sk))\r\ngoto out;\r\nif ((1 << sk->sk_state) & (DCCPF_LISTEN | DCCPF_CLOSED))\r\ngoto out;\r\ndst = inet6_csk_update_pmtu(sk, ntohl(info));\r\nif (!dst)\r\ngoto out;\r\nif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst))\r\ndccp_sync_mss(sk, dst_mtu(dst));\r\ngoto out;\r\n}\r\nicmpv6_err_convert(type, code, &err);\r\nswitch (sk->sk_state) {\r\ncase DCCP_REQUESTING:\r\ncase DCCP_RESPOND:\r\nif (!sock_owned_by_user(sk)) {\r\nDCCP_INC_STATS_BH(DCCP_MIB_ATTEMPTFAILS);\r\nsk->sk_err = err;\r\nsk->sk_error_report(sk);\r\ndccp_done(sk);\r\n} else\r\nsk->sk_err_soft = err;\r\ngoto out;\r\n}\r\nif (!sock_owned_by_user(sk) && np->recverr) {\r\nsk->sk_err = err;\r\nsk->sk_error_report(sk);\r\n} else\r\nsk->sk_err_soft = err;\r\nout:\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n}\r\nstatic int dccp_v6_send_response(struct sock *sk, struct request_sock *req)\r\n{\r\nstruct inet_request_sock *ireq = inet_rsk(req);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sk_buff *skb;\r\nstruct in6_addr *final_p, final;\r\nstruct flowi6 fl6;\r\nint err = -1;\r\nstruct dst_entry *dst;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_DCCP;\r\nfl6.daddr = ireq->ir_v6_rmt_addr;\r\nfl6.saddr = ireq->ir_v6_loc_addr;\r\nfl6.flowlabel = 0;\r\nfl6.flowi6_oif = ireq->ir_iif;\r\nfl6.fl6_dport = ireq->ir_rmt_port;\r\nfl6.fl6_sport = htons(ireq->ir_num);\r\nsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\r\nfinal_p = fl6_update_dst(&fl6, np->opt, &final);\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ndst = NULL;\r\ngoto done;\r\n}\r\nskb = dccp_make_response(sk, dst, req);\r\nif (skb != NULL) {\r\nstruct dccp_hdr *dh = dccp_hdr(skb);\r\ndh->dccph_checksum = dccp_v6_csum_finish(skb,\r\n&ireq->ir_v6_loc_addr,\r\n&ireq->ir_v6_rmt_addr);\r\nfl6.daddr = ireq->ir_v6_rmt_addr;\r\nerr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\r\nerr = net_xmit_eval(err);\r\n}\r\ndone:\r\ndst_release(dst);\r\nreturn err;\r\n}\r\nstatic void dccp_v6_reqsk_destructor(struct request_sock *req)\r\n{\r\ndccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\r\nkfree_skb(inet_rsk(req)->pktopts);\r\n}\r\nstatic void dccp_v6_ctl_send_reset(struct sock *sk, struct sk_buff *rxskb)\r\n{\r\nconst struct ipv6hdr *rxip6h;\r\nstruct sk_buff *skb;\r\nstruct flowi6 fl6;\r\nstruct net *net = dev_net(skb_dst(rxskb)->dev);\r\nstruct sock *ctl_sk = net->dccp.v6_ctl_sk;\r\nstruct dst_entry *dst;\r\nif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\r\nreturn;\r\nif (!ipv6_unicast_destination(rxskb))\r\nreturn;\r\nskb = dccp_ctl_make_reset(ctl_sk, rxskb);\r\nif (skb == NULL)\r\nreturn;\r\nrxip6h = ipv6_hdr(rxskb);\r\ndccp_hdr(skb)->dccph_checksum = dccp_v6_csum_finish(skb, &rxip6h->saddr,\r\n&rxip6h->daddr);\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.daddr = rxip6h->saddr;\r\nfl6.saddr = rxip6h->daddr;\r\nfl6.flowi6_proto = IPPROTO_DCCP;\r\nfl6.flowi6_oif = inet6_iif(rxskb);\r\nfl6.fl6_dport = dccp_hdr(skb)->dccph_dport;\r\nfl6.fl6_sport = dccp_hdr(skb)->dccph_sport;\r\nsecurity_skb_classify_flow(rxskb, flowi6_to_flowi(&fl6));\r\ndst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\r\nif (!IS_ERR(dst)) {\r\nskb_dst_set(skb, dst);\r\nip6_xmit(ctl_sk, skb, &fl6, NULL, 0);\r\nDCCP_INC_STATS_BH(DCCP_MIB_OUTSEGS);\r\nDCCP_INC_STATS_BH(DCCP_MIB_OUTRSTS);\r\nreturn;\r\n}\r\nkfree_skb(skb);\r\n}\r\nstatic struct sock *dccp_v6_hnd_req(struct sock *sk,struct sk_buff *skb)\r\n{\r\nconst struct dccp_hdr *dh = dccp_hdr(skb);\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct request_sock *req;\r\nstruct sock *nsk;\r\nreq = inet6_csk_search_req(sk, dh->dccph_sport, &iph->saddr,\r\n&iph->daddr, inet6_iif(skb));\r\nif (req) {\r\nnsk = dccp_check_req(sk, skb, req);\r\nif (!nsk)\r\nreqsk_put(req);\r\nreturn nsk;\r\n}\r\nnsk = __inet6_lookup_established(sock_net(sk), &dccp_hashinfo,\r\n&iph->saddr, dh->dccph_sport,\r\n&iph->daddr, ntohs(dh->dccph_dport),\r\ninet6_iif(skb));\r\nif (nsk != NULL) {\r\nif (nsk->sk_state != DCCP_TIME_WAIT) {\r\nbh_lock_sock(nsk);\r\nreturn nsk;\r\n}\r\ninet_twsk_put(inet_twsk(nsk));\r\nreturn NULL;\r\n}\r\nreturn sk;\r\n}\r\nstatic int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct request_sock *req;\r\nstruct dccp_request_sock *dreq;\r\nstruct inet_request_sock *ireq;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\r\nstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn dccp_v4_conn_request(sk, skb);\r\nif (!ipv6_unicast_destination(skb))\r\nreturn 0;\r\nif (dccp_bad_service_code(sk, service)) {\r\ndcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\r\ngoto drop;\r\n}\r\ndcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\r\nif (inet_csk_reqsk_queue_is_full(sk))\r\ngoto drop;\r\nif (sk_acceptq_is_full(sk) && inet_csk_reqsk_queue_young(sk) > 1)\r\ngoto drop;\r\nreq = inet_reqsk_alloc(&dccp6_request_sock_ops, sk);\r\nif (req == NULL)\r\ngoto drop;\r\nif (dccp_reqsk_init(req, dccp_sk(sk), skb))\r\ngoto drop_and_free;\r\ndreq = dccp_rsk(req);\r\nif (dccp_parse_options(sk, dreq, skb))\r\ngoto drop_and_free;\r\nif (security_inet_conn_request(sk, skb, req))\r\ngoto drop_and_free;\r\nireq = inet_rsk(req);\r\nireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\r\nireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\r\nireq->ireq_family = AF_INET6;\r\nif (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||\r\nnp->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\r\nnp->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\r\natomic_inc(&skb->users);\r\nireq->pktopts = skb;\r\n}\r\nireq->ir_iif = sk->sk_bound_dev_if;\r\nif (!sk->sk_bound_dev_if &&\r\nipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\r\nireq->ir_iif = inet6_iif(skb);\r\ndreq->dreq_isr = dcb->dccpd_seq;\r\ndreq->dreq_gsr = dreq->dreq_isr;\r\ndreq->dreq_iss = dccp_v6_init_sequence(skb);\r\ndreq->dreq_gss = dreq->dreq_iss;\r\ndreq->dreq_service = service;\r\nif (dccp_v6_send_response(sk, req))\r\ngoto drop_and_free;\r\ninet6_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\r\nreturn 0;\r\ndrop_and_free:\r\nreqsk_free(req);\r\ndrop:\r\nDCCP_INC_STATS_BH(DCCP_MIB_ATTEMPTFAILS);\r\nreturn -1;\r\n}\r\nstatic struct sock *dccp_v6_request_recv_sock(struct sock *sk,\r\nstruct sk_buff *skb,\r\nstruct request_sock *req,\r\nstruct dst_entry *dst)\r\n{\r\nstruct inet_request_sock *ireq = inet_rsk(req);\r\nstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\r\nstruct inet_sock *newinet;\r\nstruct dccp6_sock *newdp6;\r\nstruct sock *newsk;\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst);\r\nif (newsk == NULL)\r\nreturn NULL;\r\nnewdp6 = (struct dccp6_sock *)newsk;\r\nnewinet = inet_sk(newsk);\r\nnewinet->pinet6 = &newdp6->inet6;\r\nnewnp = inet6_sk(newsk);\r\nmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\r\nnewnp->saddr = newsk->sk_v6_rcv_saddr;\r\ninet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\r\nnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\r\nnewnp->pktoptions = NULL;\r\nnewnp->opt = NULL;\r\nnewnp->mcast_oif = inet6_iif(skb);\r\nnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\r\ndccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\r\nreturn newsk;\r\n}\r\nif (sk_acceptq_is_full(sk))\r\ngoto out_overflow;\r\nif (dst == NULL) {\r\nstruct in6_addr *final_p, final;\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_DCCP;\r\nfl6.daddr = ireq->ir_v6_rmt_addr;\r\nfinal_p = fl6_update_dst(&fl6, np->opt, &final);\r\nfl6.saddr = ireq->ir_v6_loc_addr;\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nfl6.fl6_dport = ireq->ir_rmt_port;\r\nfl6.fl6_sport = htons(ireq->ir_num);\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst))\r\ngoto out;\r\n}\r\nnewsk = dccp_create_openreq_child(sk, req, skb);\r\nif (newsk == NULL)\r\ngoto out_nonewsk;\r\n__ip6_dst_store(newsk, dst, NULL, NULL);\r\nnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\r\nNETIF_F_TSO);\r\nnewdp6 = (struct dccp6_sock *)newsk;\r\nnewinet = inet_sk(newsk);\r\nnewinet->pinet6 = &newdp6->inet6;\r\nnewnp = inet6_sk(newsk);\r\nmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\r\nnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\r\nnewnp->saddr = ireq->ir_v6_loc_addr;\r\nnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\r\nnewsk->sk_bound_dev_if = ireq->ir_iif;\r\nnewinet->inet_opt = NULL;\r\nnewnp->rxopt.all = np->rxopt.all;\r\nnewnp->pktoptions = NULL;\r\nif (ireq->pktopts != NULL) {\r\nnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\r\nconsume_skb(ireq->pktopts);\r\nireq->pktopts = NULL;\r\nif (newnp->pktoptions)\r\nskb_set_owner_r(newnp->pktoptions, newsk);\r\n}\r\nnewnp->opt = NULL;\r\nnewnp->mcast_oif = inet6_iif(skb);\r\nnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\r\nif (np->opt != NULL)\r\nnewnp->opt = ipv6_dup_options(newsk, np->opt);\r\ninet_csk(newsk)->icsk_ext_hdr_len = 0;\r\nif (newnp->opt != NULL)\r\ninet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\r\nnewnp->opt->opt_flen);\r\ndccp_sync_mss(newsk, dst_mtu(dst));\r\nnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\r\nnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\r\nif (__inet_inherit_port(sk, newsk) < 0) {\r\ninet_csk_prepare_forced_close(newsk);\r\ndccp_done(newsk);\r\ngoto out;\r\n}\r\n__inet_hash(newsk, NULL);\r\nreturn newsk;\r\nout_overflow:\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\r\nout_nonewsk:\r\ndst_release(dst);\r\nout:\r\nNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\r\nreturn NULL;\r\n}\r\nstatic int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sk_buff *opt_skb = NULL;\r\nif (skb->protocol == htons(ETH_P_IP))\r\nreturn dccp_v4_do_rcv(sk, skb);\r\nif (sk_filter(sk, skb))\r\ngoto discard;\r\nif (np->rxopt.all)\r\nopt_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (sk->sk_state == DCCP_OPEN) {\r\nif (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))\r\ngoto reset;\r\nif (opt_skb) {\r\n__kfree_skb(opt_skb);\r\n}\r\nreturn 0;\r\n}\r\nif (sk->sk_state == DCCP_LISTEN) {\r\nstruct sock *nsk = dccp_v6_hnd_req(sk, skb);\r\nif (nsk == NULL)\r\ngoto discard;\r\nif (nsk != sk) {\r\nif (dccp_child_process(sk, nsk, skb))\r\ngoto reset;\r\nif (opt_skb != NULL)\r\n__kfree_skb(opt_skb);\r\nreturn 0;\r\n}\r\n}\r\nif (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))\r\ngoto reset;\r\nif (opt_skb) {\r\n__kfree_skb(opt_skb);\r\n}\r\nreturn 0;\r\nreset:\r\ndccp_v6_ctl_send_reset(sk, skb);\r\ndiscard:\r\nif (opt_skb != NULL)\r\n__kfree_skb(opt_skb);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int dccp_v6_rcv(struct sk_buff *skb)\r\n{\r\nconst struct dccp_hdr *dh;\r\nstruct sock *sk;\r\nint min_cov;\r\nif (dccp_invalid_packet(skb))\r\ngoto discard_it;\r\nif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr)) {\r\nDCCP_WARN("dropped packet with invalid checksum\n");\r\ngoto discard_it;\r\n}\r\ndh = dccp_hdr(skb);\r\nDCCP_SKB_CB(skb)->dccpd_seq = dccp_hdr_seq(dh);\r\nDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\r\nif (dccp_packet_without_ack(skb))\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\r\nelse\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\r\nsk = __inet6_lookup_skb(&dccp_hashinfo, skb,\r\ndh->dccph_sport, dh->dccph_dport,\r\ninet6_iif(skb));\r\nif (sk == NULL) {\r\ndccp_pr_debug("failed to look up flow ID in table and "\r\n"get corresponding socket\n");\r\ngoto no_dccp_socket;\r\n}\r\nif (sk->sk_state == DCCP_TIME_WAIT) {\r\ndccp_pr_debug("sk->sk_state == DCCP_TIME_WAIT: do_time_wait\n");\r\ninet_twsk_put(inet_twsk(sk));\r\ngoto no_dccp_socket;\r\n}\r\nmin_cov = dccp_sk(sk)->dccps_pcrlen;\r\nif (dh->dccph_cscov && (min_cov == 0 || dh->dccph_cscov < min_cov)) {\r\ndccp_pr_debug("Packet CsCov %d does not satisfy MinCsCov %d\n",\r\ndh->dccph_cscov, min_cov);\r\ngoto discard_and_relse;\r\n}\r\nif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\r\ngoto discard_and_relse;\r\nreturn sk_receive_skb(sk, skb, 1) ? -1 : 0;\r\nno_dccp_socket:\r\nif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\r\ngoto discard_it;\r\nif (dh->dccph_type != DCCP_PKT_RESET) {\r\nDCCP_SKB_CB(skb)->dccpd_reset_code =\r\nDCCP_RESET_CODE_NO_CONNECTION;\r\ndccp_v6_ctl_send_reset(sk, skb);\r\n}\r\ndiscard_it:\r\nkfree_skb(skb);\r\nreturn 0;\r\ndiscard_and_relse:\r\nsock_put(sk);\r\ngoto discard_it;\r\n}\r\nstatic int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\r\nint addr_len)\r\n{\r\nstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct in6_addr *saddr = NULL, *final_p, final;\r\nstruct flowi6 fl6;\r\nstruct dst_entry *dst;\r\nint addr_type;\r\nint err;\r\ndp->dccps_role = DCCP_ROLE_CLIENT;\r\nif (addr_len < SIN6_LEN_RFC2133)\r\nreturn -EINVAL;\r\nif (usin->sin6_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nif (np->sndflow) {\r\nfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\r\nIP6_ECN_flow_init(fl6.flowlabel);\r\nif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\r\nstruct ip6_flowlabel *flowlabel;\r\nflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\r\nif (flowlabel == NULL)\r\nreturn -EINVAL;\r\nfl6_sock_release(flowlabel);\r\n}\r\n}\r\nif (ipv6_addr_any(&usin->sin6_addr))\r\nusin->sin6_addr.s6_addr[15] = 1;\r\naddr_type = ipv6_addr_type(&usin->sin6_addr);\r\nif (addr_type & IPV6_ADDR_MULTICAST)\r\nreturn -ENETUNREACH;\r\nif (addr_type & IPV6_ADDR_LINKLOCAL) {\r\nif (addr_len >= sizeof(struct sockaddr_in6) &&\r\nusin->sin6_scope_id) {\r\nif (sk->sk_bound_dev_if &&\r\nsk->sk_bound_dev_if != usin->sin6_scope_id)\r\nreturn -EINVAL;\r\nsk->sk_bound_dev_if = usin->sin6_scope_id;\r\n}\r\nif (!sk->sk_bound_dev_if)\r\nreturn -EINVAL;\r\n}\r\nsk->sk_v6_daddr = usin->sin6_addr;\r\nnp->flow_label = fl6.flowlabel;\r\nif (addr_type == IPV6_ADDR_MAPPED) {\r\nu32 exthdrlen = icsk->icsk_ext_hdr_len;\r\nstruct sockaddr_in sin;\r\nSOCK_DEBUG(sk, "connect: ipv4 mapped\n");\r\nif (__ipv6_only_sock(sk))\r\nreturn -ENETUNREACH;\r\nsin.sin_family = AF_INET;\r\nsin.sin_port = usin->sin6_port;\r\nsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\r\nicsk->icsk_af_ops = &dccp_ipv6_mapped;\r\nsk->sk_backlog_rcv = dccp_v4_do_rcv;\r\nerr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\r\nif (err) {\r\nicsk->icsk_ext_hdr_len = exthdrlen;\r\nicsk->icsk_af_ops = &dccp_ipv6_af_ops;\r\nsk->sk_backlog_rcv = dccp_v6_do_rcv;\r\ngoto failure;\r\n}\r\nnp->saddr = sk->sk_v6_rcv_saddr;\r\nreturn err;\r\n}\r\nif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\r\nsaddr = &sk->sk_v6_rcv_saddr;\r\nfl6.flowi6_proto = IPPROTO_DCCP;\r\nfl6.daddr = sk->sk_v6_daddr;\r\nfl6.saddr = saddr ? *saddr : np->saddr;\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nfl6.fl6_dport = usin->sin6_port;\r\nfl6.fl6_sport = inet->inet_sport;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\nfinal_p = fl6_update_dst(&fl6, np->opt, &final);\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ngoto failure;\r\n}\r\nif (saddr == NULL) {\r\nsaddr = &fl6.saddr;\r\nsk->sk_v6_rcv_saddr = *saddr;\r\n}\r\nnp->saddr = *saddr;\r\ninet->inet_rcv_saddr = LOOPBACK4_IPV6;\r\n__ip6_dst_store(sk, dst, NULL, NULL);\r\nicsk->icsk_ext_hdr_len = 0;\r\nif (np->opt != NULL)\r\nicsk->icsk_ext_hdr_len = (np->opt->opt_flen +\r\nnp->opt->opt_nflen);\r\ninet->inet_dport = usin->sin6_port;\r\ndccp_set_state(sk, DCCP_REQUESTING);\r\nerr = inet6_hash_connect(&dccp_death_row, sk);\r\nif (err)\r\ngoto late_failure;\r\ndp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,\r\nsk->sk_v6_daddr.s6_addr32,\r\ninet->inet_sport,\r\ninet->inet_dport);\r\nerr = dccp_connect(sk);\r\nif (err)\r\ngoto late_failure;\r\nreturn 0;\r\nlate_failure:\r\ndccp_set_state(sk, DCCP_CLOSED);\r\n__sk_dst_reset(sk);\r\nfailure:\r\ninet->inet_dport = 0;\r\nsk->sk_route_caps = 0;\r\nreturn err;\r\n}\r\nstatic int dccp_v6_init_sock(struct sock *sk)\r\n{\r\nstatic __u8 dccp_v6_ctl_sock_initialized;\r\nint err = dccp_init_sock(sk, dccp_v6_ctl_sock_initialized);\r\nif (err == 0) {\r\nif (unlikely(!dccp_v6_ctl_sock_initialized))\r\ndccp_v6_ctl_sock_initialized = 1;\r\ninet_csk(sk)->icsk_af_ops = &dccp_ipv6_af_ops;\r\n}\r\nreturn err;\r\n}\r\nstatic void dccp_v6_destroy_sock(struct sock *sk)\r\n{\r\ndccp_destroy_sock(sk);\r\ninet6_destroy_sock(sk);\r\n}\r\nstatic int __net_init dccp_v6_init_net(struct net *net)\r\n{\r\nif (dccp_hashinfo.bhash == NULL)\r\nreturn -ESOCKTNOSUPPORT;\r\nreturn inet_ctl_sock_create(&net->dccp.v6_ctl_sk, PF_INET6,\r\nSOCK_DCCP, IPPROTO_DCCP, net);\r\n}\r\nstatic void __net_exit dccp_v6_exit_net(struct net *net)\r\n{\r\ninet_ctl_sock_destroy(net->dccp.v6_ctl_sk);\r\n}\r\nstatic int __init dccp_v6_init(void)\r\n{\r\nint err = proto_register(&dccp_v6_prot, 1);\r\nif (err != 0)\r\ngoto out;\r\nerr = inet6_add_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\r\nif (err != 0)\r\ngoto out_unregister_proto;\r\ninet6_register_protosw(&dccp_v6_protosw);\r\nerr = register_pernet_subsys(&dccp_v6_ops);\r\nif (err != 0)\r\ngoto out_destroy_ctl_sock;\r\nout:\r\nreturn err;\r\nout_destroy_ctl_sock:\r\ninet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\r\ninet6_unregister_protosw(&dccp_v6_protosw);\r\nout_unregister_proto:\r\nproto_unregister(&dccp_v6_prot);\r\ngoto out;\r\n}\r\nstatic void __exit dccp_v6_exit(void)\r\n{\r\nunregister_pernet_subsys(&dccp_v6_ops);\r\ninet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\r\ninet6_unregister_protosw(&dccp_v6_protosw);\r\nproto_unregister(&dccp_v6_prot);\r\n}
