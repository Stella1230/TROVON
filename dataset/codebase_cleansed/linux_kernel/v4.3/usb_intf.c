static int r871x_suspend(struct usb_interface *pusb_intf, pm_message_t state)\r\n{\r\nstruct net_device *pnetdev = usb_get_intfdata(pusb_intf);\r\nnetdev_info(pnetdev, "Suspending...\n");\r\nif (!pnetdev || !netif_running(pnetdev)) {\r\nnetdev_info(pnetdev, "Unable to suspend\n");\r\nreturn 0;\r\n}\r\nif (pnetdev->netdev_ops->ndo_stop)\r\npnetdev->netdev_ops->ndo_stop(pnetdev);\r\nmdelay(10);\r\nnetif_device_detach(pnetdev);\r\nreturn 0;\r\n}\r\nstatic int r871x_resume(struct usb_interface *pusb_intf)\r\n{\r\nstruct net_device *pnetdev = usb_get_intfdata(pusb_intf);\r\nnetdev_info(pnetdev, "Resuming...\n");\r\nif (!pnetdev || !netif_running(pnetdev)) {\r\nnetdev_info(pnetdev, "Unable to resume\n");\r\nreturn 0;\r\n}\r\nnetif_device_attach(pnetdev);\r\nif (pnetdev->netdev_ops->ndo_open)\r\npnetdev->netdev_ops->ndo_open(pnetdev);\r\nreturn 0;\r\n}\r\nstatic int r871x_reset_resume(struct usb_interface *pusb_intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic uint r8712_usb_dvobj_init(struct _adapter *padapter)\r\n{\r\nuint status = _SUCCESS;\r\nstruct usb_host_interface *phost_iface;\r\nstruct usb_interface_descriptor *piface_desc;\r\nstruct dvobj_priv *pdvobjpriv = &padapter->dvobjpriv;\r\nstruct usb_device *pusbd = pdvobjpriv->pusbdev;\r\npdvobjpriv->padapter = padapter;\r\npadapter->EepromAddressSize = 6;\r\nphost_iface = &pintf->altsetting[0];\r\npiface_desc = &phost_iface->desc;\r\npdvobjpriv->nr_endpoint = piface_desc->bNumEndpoints;\r\nif (pusbd->speed == USB_SPEED_HIGH) {\r\npdvobjpriv->ishighspeed = true;\r\ndev_info(&pusbd->dev, "r8712u: USB_SPEED_HIGH with %d endpoints\n",\r\npdvobjpriv->nr_endpoint);\r\n} else {\r\npdvobjpriv->ishighspeed = false;\r\ndev_info(&pusbd->dev, "r8712u: USB_SPEED_LOW with %d endpoints\n",\r\npdvobjpriv->nr_endpoint);\r\n}\r\nif ((r8712_alloc_io_queue(padapter)) == _FAIL)\r\nstatus = _FAIL;\r\nreturn status;\r\n}\r\nstatic void r8712_usb_dvobj_deinit(struct _adapter *padapter)\r\n{\r\n}\r\nvoid rtl871x_intf_stop(struct _adapter *padapter)\r\n{\r\nif (!padapter->bSurpriseRemoved) {\r\n}\r\nif (padapter->dvobjpriv.inirp_deinit)\r\npadapter->dvobjpriv.inirp_deinit(padapter);\r\nr8712_usb_write_port_cancel(padapter);\r\n}\r\nvoid r871x_dev_unload(struct _adapter *padapter)\r\n{\r\nif (padapter->bup == true) {\r\npadapter->bDriverStopped = true;\r\nrtl871x_intf_stop(padapter);\r\nr8712_stop_drv_threads(padapter);\r\nif (!padapter->bSurpriseRemoved) {\r\npadapter->hw_init_completed = false;\r\nrtl8712_hal_deinit(padapter);\r\n}\r\nif (padapter->dvobj_deinit)\r\npadapter->dvobj_deinit(padapter);\r\npadapter->bup = false;\r\n}\r\n}\r\nstatic void disable_ht_for_spec_devid(const struct usb_device_id *pdid,\r\nstruct _adapter *padapter)\r\n{\r\nu16 vid, pid;\r\nu32 flags;\r\nint i;\r\nint num = sizeof(specific_device_id_tbl) /\r\nsizeof(struct specific_device_id);\r\nfor (i = 0; i < num; i++) {\r\nvid = specific_device_id_tbl[i].idVendor;\r\npid = specific_device_id_tbl[i].idProduct;\r\nflags = specific_device_id_tbl[i].flags;\r\nif ((pdid->idVendor == vid) && (pdid->idProduct == pid) &&\r\n(flags&SPEC_DEV_ID_DISABLE_HT)) {\r\npadapter->registrypriv.ht_enable = 0;\r\npadapter->registrypriv.cbw40_enable = 0;\r\npadapter->registrypriv.ampdu_enable = 0;\r\n}\r\n}\r\n}\r\nstatic int r871xu_drv_init(struct usb_interface *pusb_intf,\r\nconst struct usb_device_id *pdid)\r\n{\r\nuint status;\r\nstruct _adapter *padapter = NULL;\r\nstruct dvobj_priv *pdvobjpriv;\r\nstruct net_device *pnetdev;\r\nstruct usb_device *udev;\r\nudev = interface_to_usbdev(pusb_intf);\r\nusb_get_dev(udev);\r\npintf = pusb_intf;\r\npnetdev = r8712_init_netdev();\r\nif (!pnetdev)\r\ngoto error;\r\npadapter = netdev_priv(pnetdev);\r\ndisable_ht_for_spec_devid(pdid, padapter);\r\npdvobjpriv = &padapter->dvobjpriv;\r\npdvobjpriv->padapter = padapter;\r\npadapter->dvobjpriv.pusbdev = udev;\r\npadapter->pusb_intf = pusb_intf;\r\nusb_set_intfdata(pusb_intf, pnetdev);\r\nSET_NETDEV_DEV(pnetdev, &pusb_intf->dev);\r\npnetdev->dev.type = &wlan_type;\r\npadapter->dvobj_init = &r8712_usb_dvobj_init;\r\npadapter->dvobj_deinit = &r8712_usb_dvobj_deinit;\r\npadapter->halpriv.hal_bus_init = &r8712_usb_hal_bus_init;\r\npadapter->dvobjpriv.inirp_init = &r8712_usb_inirp_init;\r\npadapter->dvobjpriv.inirp_deinit = &r8712_usb_inirp_deinit;\r\nif (!padapter->dvobj_init)\r\ngoto error;\r\nelse {\r\nstatus = padapter->dvobj_init(padapter);\r\nif (status != _SUCCESS)\r\ngoto error;\r\n}\r\nstatus = r8712_init_drv_sw(padapter);\r\nif (status == _FAIL)\r\ngoto error;\r\n{\r\nint i, offset;\r\nu8 mac[6];\r\nu8 tmpU1b, AutoloadFail, eeprom_CustomerID;\r\nu8 *pdata = padapter->eeprompriv.efuse_eeprom_data;\r\ntmpU1b = r8712_read8(padapter, EE_9346CR);\r\ndev_info(&udev->dev, "r8712u: Boot from %s: Autoload %s\n",\r\n(tmpU1b & _9356SEL) ? "EEPROM" : "EFUSE",\r\n(tmpU1b & _EEPROM_EN) ? "OK" : "Failed");\r\nif (tmpU1b & _EEPROM_EN) {\r\nAutoloadFail = true;\r\ntmpU1b = r8712_read8(padapter, EFUSE_TEST+3);\r\nr8712_write8(padapter, EFUSE_TEST + 3, tmpU1b | 0x80);\r\nmsleep(20);\r\nr8712_write8(padapter, EFUSE_TEST + 3,\r\n(tmpU1b & (~BIT(7))));\r\ntmpU1b = (u8)((r8712_read32(padapter, PMC_FSM) >> 15) &\r\n0x1F);\r\nif (tmpU1b == 0x3)\r\npadapter->registrypriv.chip_version =\r\nRTL8712_3rdCUT;\r\nelse\r\npadapter->registrypriv.chip_version =\r\n(tmpU1b >> 1) + 1;\r\nswitch (padapter->registrypriv.chip_version) {\r\ncase RTL8712_1stCUT:\r\ncase RTL8712_2ndCUT:\r\ncase RTL8712_3rdCUT:\r\nbreak;\r\ndefault:\r\npadapter->registrypriv.chip_version =\r\nRTL8712_2ndCUT;\r\nbreak;\r\n}\r\nfor (i = 0, offset = 0; i < 128; i += 8, offset++)\r\nr8712_efuse_pg_packet_read(padapter, offset,\r\n&pdata[i]);\r\nif (!r8712_initmac || !mac_pton(r8712_initmac, mac)) {\r\nether_addr_copy(mac, &pdata[0x12]);\r\n}\r\neeprom_CustomerID = pdata[0x52];\r\nswitch (eeprom_CustomerID) {\r\ncase EEPROM_CID_ALPHA:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_ALPHA;\r\nbreak;\r\ncase EEPROM_CID_CAMEO:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_CAMEO;\r\nbreak;\r\ncase EEPROM_CID_SITECOM:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_Sitecom;\r\nbreak;\r\ncase EEPROM_CID_COREGA:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_COREGA;\r\nbreak;\r\ncase EEPROM_CID_Senao:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_Senao;\r\nbreak;\r\ncase EEPROM_CID_EDIMAX_BELKIN:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_Edimax_Belkin;\r\nbreak;\r\ncase EEPROM_CID_SERCOMM_BELKIN:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_Sercomm_Belkin;\r\nbreak;\r\ncase EEPROM_CID_WNC_COREGA:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_WNC_COREGA;\r\nbreak;\r\ncase EEPROM_CID_WHQL:\r\nbreak;\r\ncase EEPROM_CID_NetCore:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_Netcore;\r\nbreak;\r\ncase EEPROM_CID_CAMEO1:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_CAMEO1;\r\nbreak;\r\ncase EEPROM_CID_CLEVO:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_819x_CLEVO;\r\nbreak;\r\ndefault:\r\npadapter->eeprompriv.CustomerID =\r\nRT_CID_DEFAULT;\r\nbreak;\r\n}\r\ndev_info(&udev->dev, "r8712u: CustomerID = 0x%.4x\n",\r\npadapter->eeprompriv.CustomerID);\r\nswitch (padapter->eeprompriv.CustomerID) {\r\ncase RT_CID_DEFAULT:\r\ncase RT_CID_819x_ALPHA:\r\ncase RT_CID_819x_CAMEO:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE1;\r\npadapter->ledpriv.bRegUseLed = true;\r\nbreak;\r\ncase RT_CID_819x_Sitecom:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE2;\r\npadapter->ledpriv.bRegUseLed = true;\r\nbreak;\r\ncase RT_CID_COREGA:\r\ncase RT_CID_819x_Senao:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE3;\r\npadapter->ledpriv.bRegUseLed = true;\r\nbreak;\r\ncase RT_CID_819x_Edimax_Belkin:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE4;\r\npadapter->ledpriv.bRegUseLed = true;\r\nbreak;\r\ncase RT_CID_819x_Sercomm_Belkin:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE5;\r\npadapter->ledpriv.bRegUseLed = true;\r\nbreak;\r\ncase RT_CID_819x_WNC_COREGA:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE6;\r\npadapter->ledpriv.bRegUseLed = true;\r\nbreak;\r\ndefault:\r\npadapter->ledpriv.LedStrategy = SW_LED_MODE0;\r\npadapter->ledpriv.bRegUseLed = false;\r\nbreak;\r\n}\r\n} else\r\nAutoloadFail = false;\r\nif (((mac[0] == 0xff) && (mac[1] == 0xff) &&\r\n(mac[2] == 0xff) && (mac[3] == 0xff) &&\r\n(mac[4] == 0xff) && (mac[5] == 0xff)) ||\r\n((mac[0] == 0x00) && (mac[1] == 0x00) &&\r\n(mac[2] == 0x00) && (mac[3] == 0x00) &&\r\n(mac[4] == 0x00) && (mac[5] == 0x00)) ||\r\n(!AutoloadFail)) {\r\nmac[0] = 0x00;\r\nmac[1] = 0xe0;\r\nmac[2] = 0x4c;\r\nmac[3] = 0x87;\r\nmac[4] = 0x00;\r\nmac[5] = 0x00;\r\n}\r\nif (r8712_initmac) {\r\nmac[0] &= 0xFE;\r\ndev_info(&udev->dev,\r\n"r8712u: MAC Address from user = %pM\n", mac);\r\n} else\r\ndev_info(&udev->dev,\r\n"r8712u: MAC Address from efuse = %pM\n", mac);\r\nether_addr_copy(pnetdev->dev_addr, mac);\r\n}\r\nif (rtl871x_load_fw(padapter))\r\ngoto error;\r\nspin_lock_init(&padapter->lockRxFF0Filter);\r\nmutex_init(&padapter->mutex_start);\r\nreturn 0;\r\nerror:\r\nusb_put_dev(udev);\r\nusb_set_intfdata(pusb_intf, NULL);\r\nif (padapter && padapter->dvobj_deinit != NULL)\r\npadapter->dvobj_deinit(padapter);\r\nif (pnetdev)\r\nfree_netdev(pnetdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void r871xu_dev_remove(struct usb_interface *pusb_intf)\r\n{\r\nstruct net_device *pnetdev = usb_get_intfdata(pusb_intf);\r\nstruct usb_device *udev = interface_to_usbdev(pusb_intf);\r\nif (pnetdev) {\r\nstruct _adapter *padapter = netdev_priv(pnetdev);\r\nusb_set_intfdata(pusb_intf, NULL);\r\nrelease_firmware(padapter->fw);\r\nwait_for_completion(&padapter->rtl8712_fw_ready);\r\nif (drvpriv.drv_registered == true)\r\npadapter->bSurpriseRemoved = true;\r\nunregister_netdev(pnetdev);\r\nflush_scheduled_work();\r\nudelay(1);\r\nr8712_stop_drv_timers(padapter);\r\nr871x_dev_unload(padapter);\r\nr8712_free_drv_sw(padapter);\r\nusb_put_dev(udev);\r\n}\r\nif (udev->state != USB_STATE_NOTATTACHED)\r\nusb_reset_device(udev);\r\n}\r\nstatic int __init r8712u_drv_entry(void)\r\n{\r\ndrvpriv.drv_registered = true;\r\nreturn usb_register(&drvpriv.r871xu_drv);\r\n}\r\nstatic void __exit r8712u_drv_halt(void)\r\n{\r\ndrvpriv.drv_registered = false;\r\nusb_deregister(&drvpriv.r871xu_drv);\r\n}
