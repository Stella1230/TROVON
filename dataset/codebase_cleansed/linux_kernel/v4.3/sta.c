static inline void __cw1200_free_event_queue(struct list_head *list)\r\n{\r\nstruct cw1200_wsm_event *event, *tmp;\r\nlist_for_each_entry_safe(event, tmp, list, link) {\r\nlist_del(&event->link);\r\nkfree(event);\r\n}\r\n}\r\nint cw1200_start(struct ieee80211_hw *dev)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nint ret = 0;\r\ncw1200_pm_stay_awake(&priv->pm_state, HZ);\r\nmutex_lock(&priv->conf_mutex);\r\nWSM_EDCA_SET(&priv->edca, 0, 0x0002, 0x0003, 0x0007, 47, 0xc8, false);\r\nWSM_EDCA_SET(&priv->edca, 1, 0x0002, 0x0007, 0x000f, 94, 0xc8, false);\r\nWSM_EDCA_SET(&priv->edca, 2, 0x0003, 0x000f, 0x03ff, 0, 0xc8, false);\r\nWSM_EDCA_SET(&priv->edca, 3, 0x0007, 0x000f, 0x03ff, 0, 0xc8, false);\r\nret = wsm_set_edca_params(priv, &priv->edca);\r\nif (ret)\r\ngoto out;\r\nret = cw1200_set_uapsd_param(priv, &priv->edca);\r\nif (ret)\r\ngoto out;\r\npriv->setbssparams_done = false;\r\nmemcpy(priv->mac_addr, dev->wiphy->perm_addr, ETH_ALEN);\r\npriv->mode = NL80211_IFTYPE_MONITOR;\r\npriv->wep_default_key_id = -1;\r\npriv->cqm_beacon_loss_count = 10;\r\nret = cw1200_setup_mac(priv);\r\nif (ret)\r\ngoto out;\r\nout:\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn ret;\r\n}\r\nvoid cw1200_stop(struct ieee80211_hw *dev)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nLIST_HEAD(list);\r\nint i;\r\nwsm_lock_tx(priv);\r\nwhile (down_trylock(&priv->scan.lock)) {\r\npriv->scan.req = NULL;\r\nschedule();\r\n}\r\nup(&priv->scan.lock);\r\ncancel_delayed_work_sync(&priv->scan.probe_work);\r\ncancel_delayed_work_sync(&priv->scan.timeout);\r\ncancel_delayed_work_sync(&priv->clear_recent_scan_work);\r\ncancel_delayed_work_sync(&priv->join_timeout);\r\ncw1200_cqm_bssloss_sm(priv, 0, 0, 0);\r\ncancel_work_sync(&priv->unjoin_work);\r\ncancel_delayed_work_sync(&priv->link_id_gc_work);\r\nflush_workqueue(priv->workqueue);\r\ndel_timer_sync(&priv->mcast_timeout);\r\nmutex_lock(&priv->conf_mutex);\r\npriv->mode = NL80211_IFTYPE_UNSPECIFIED;\r\npriv->listening = false;\r\nspin_lock(&priv->event_queue_lock);\r\nlist_splice_init(&priv->event_queue, &list);\r\nspin_unlock(&priv->event_queue_lock);\r\n__cw1200_free_event_queue(&list);\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\npriv->join_pending = false;\r\nfor (i = 0; i < 4; i++)\r\ncw1200_queue_clear(&priv->tx_queue[i]);\r\nmutex_unlock(&priv->conf_mutex);\r\ntx_policy_clean(priv);\r\nif (atomic_xchg(&priv->tx_lock, 1) != 1)\r\npr_debug("[STA] TX is force-unlocked due to stop request.\n");\r\nwsm_unlock_tx(priv);\r\natomic_xchg(&priv->tx_lock, 0);\r\n}\r\nvoid __cw1200_cqm_bssloss_sm(struct cw1200_common *priv,\r\nint init, int good, int bad)\r\n{\r\nint tx = 0;\r\npriv->delayed_link_loss = 0;\r\ncancel_work_sync(&priv->bss_params_work);\r\npr_debug("[STA] CQM BSSLOSS_SM: state: %d init %d good %d bad: %d txlock: %d uj: %d\n",\r\npriv->bss_loss_state,\r\ninit, good, bad,\r\natomic_read(&priv->tx_lock),\r\npriv->delayed_unjoin);\r\nif (priv->delayed_unjoin)\r\nreturn;\r\nif (init) {\r\nqueue_delayed_work(priv->workqueue,\r\n&priv->bss_loss_work,\r\nHZ);\r\npriv->bss_loss_state = 0;\r\nif (!priv->vif->p2p && !atomic_read(&priv->tx_lock))\r\ntx = 1;\r\n} else if (good) {\r\ncancel_delayed_work_sync(&priv->bss_loss_work);\r\npriv->bss_loss_state = 0;\r\nqueue_work(priv->workqueue, &priv->bss_params_work);\r\n} else if (bad) {\r\nif (priv->bss_loss_state < 3)\r\ntx = 1;\r\n} else {\r\ncancel_delayed_work_sync(&priv->bss_loss_work);\r\npriv->bss_loss_state = 0;\r\n}\r\nif (!cw1200_bssloss_mitigation)\r\ntx = 0;\r\nif (tx) {\r\nstruct sk_buff *skb;\r\npriv->bss_loss_state++;\r\nskb = ieee80211_nullfunc_get(priv->hw, priv->vif);\r\nWARN_ON(!skb);\r\nif (skb)\r\ncw1200_tx(priv->hw, NULL, skb);\r\n}\r\n}\r\nint cw1200_add_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nint ret;\r\nstruct cw1200_common *priv = dev->priv;\r\nvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\r\nIEEE80211_VIF_SUPPORTS_UAPSD |\r\nIEEE80211_VIF_SUPPORTS_CQM_RSSI;\r\nmutex_lock(&priv->conf_mutex);\r\nif (priv->mode != NL80211_IFTYPE_MONITOR) {\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_AP:\r\npriv->mode = vif->type;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->vif = vif;\r\nmemcpy(priv->mac_addr, vif->addr, ETH_ALEN);\r\nret = cw1200_setup_mac(priv);\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn ret;\r\n}\r\nvoid cw1200_remove_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nstruct wsm_reset reset = {\r\n.reset_statistics = true,\r\n};\r\nint i;\r\nmutex_lock(&priv->conf_mutex);\r\nswitch (priv->join_status) {\r\ncase CW1200_JOIN_STATUS_JOINING:\r\ncase CW1200_JOIN_STATUS_PRE_STA:\r\ncase CW1200_JOIN_STATUS_STA:\r\ncase CW1200_JOIN_STATUS_IBSS:\r\nwsm_lock_tx(priv);\r\nif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\nbreak;\r\ncase CW1200_JOIN_STATUS_AP:\r\nfor (i = 0; priv->link_id_map; ++i) {\r\nif (priv->link_id_map & BIT(i)) {\r\nreset.link_id = i;\r\nwsm_reset(priv, &reset);\r\npriv->link_id_map &= ~BIT(i);\r\n}\r\n}\r\nmemset(priv->link_id_db, 0, sizeof(priv->link_id_db));\r\npriv->sta_asleep_mask = 0;\r\npriv->enable_beacon = false;\r\npriv->tx_multicast = false;\r\npriv->aid0_bit_set = false;\r\npriv->buffered_multicasts = false;\r\npriv->pspoll_mask = 0;\r\nreset.link_id = 0;\r\nwsm_reset(priv, &reset);\r\nbreak;\r\ncase CW1200_JOIN_STATUS_MONITOR:\r\ncw1200_update_listening(priv, false);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npriv->vif = NULL;\r\npriv->mode = NL80211_IFTYPE_MONITOR;\r\neth_zero_addr(priv->mac_addr);\r\nmemset(&priv->p2p_ps_modeinfo, 0, sizeof(priv->p2p_ps_modeinfo));\r\ncw1200_free_keys(priv);\r\ncw1200_setup_mac(priv);\r\npriv->listening = false;\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\nif (!__cw1200_flush(priv, true))\r\nwsm_unlock_tx(priv);\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nint cw1200_change_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif,\r\nenum nl80211_iftype new_type,\r\nbool p2p)\r\n{\r\nint ret = 0;\r\npr_debug("change_interface new: %d (%d), old: %d (%d)\n", new_type,\r\np2p, vif->type, vif->p2p);\r\nif (new_type != vif->type || vif->p2p != p2p) {\r\ncw1200_remove_interface(dev, vif);\r\nvif->type = new_type;\r\nvif->p2p = p2p;\r\nret = cw1200_add_interface(dev, vif);\r\n}\r\nreturn ret;\r\n}\r\nint cw1200_config(struct ieee80211_hw *dev, u32 changed)\r\n{\r\nint ret = 0;\r\nstruct cw1200_common *priv = dev->priv;\r\nstruct ieee80211_conf *conf = &dev->conf;\r\npr_debug("CONFIG CHANGED: %08x\n", changed);\r\ndown(&priv->scan.lock);\r\nmutex_lock(&priv->conf_mutex);\r\nif (changed & IEEE80211_CONF_CHANGE_POWER) {\r\npriv->output_power = conf->power_level;\r\npr_debug("[STA] TX power: %d\n", priv->output_power);\r\nwsm_set_output_power(priv, priv->output_power * 10);\r\n}\r\nif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) &&\r\n(priv->channel != conf->chandef.chan)) {\r\nstruct ieee80211_channel *ch = conf->chandef.chan;\r\nstruct wsm_switch_channel channel = {\r\n.channel_number = ch->hw_value,\r\n};\r\npr_debug("[STA] Freq %d (wsm ch: %d).\n",\r\nch->center_freq, ch->hw_value);\r\nif (!__cw1200_flush(priv, false)) {\r\nif (!wsm_switch_channel(priv, &channel)) {\r\nret = wait_event_timeout(priv->channel_switch_done,\r\n!priv->channel_switch_in_progress,\r\n3 * HZ);\r\nif (ret) {\r\npriv->channel = ch;\r\nret = 0;\r\n} else {\r\nret = -ETIMEDOUT;\r\n}\r\n} else {\r\nwsm_unlock_tx(priv);\r\n}\r\n}\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_PS) {\r\nif (!(conf->flags & IEEE80211_CONF_PS))\r\npriv->powersave_mode.mode = WSM_PSM_ACTIVE;\r\nelse if (conf->dynamic_ps_timeout <= 0)\r\npriv->powersave_mode.mode = WSM_PSM_PS;\r\nelse\r\npriv->powersave_mode.mode = WSM_PSM_FAST_PS;\r\nif (conf->dynamic_ps_timeout >= 0x80)\r\npriv->powersave_mode.fast_psm_idle_period = 0xFF;\r\nelse\r\npriv->powersave_mode.fast_psm_idle_period =\r\nconf->dynamic_ps_timeout << 1;\r\nif (priv->join_status == CW1200_JOIN_STATUS_STA &&\r\npriv->bss_params.aid)\r\ncw1200_set_pm(priv, &priv->powersave_mode);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_IDLE) {\r\nstruct wsm_operational_mode mode = {\r\n.power_mode = cw1200_power_mode,\r\n.disable_more_flag_usage = true,\r\n};\r\nwsm_lock_tx(priv);\r\nif ((priv->join_status == CW1200_JOIN_STATUS_MONITOR) &&\r\n(conf->flags & IEEE80211_CONF_IDLE) &&\r\n!priv->listening) {\r\ncw1200_disable_listening(priv);\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\n}\r\nwsm_set_operational_mode(priv, &mode);\r\nwsm_unlock_tx(priv);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\r\npr_debug("[STA] Retry limits: %d (long), %d (short).\n",\r\nconf->long_frame_max_tx_count,\r\nconf->short_frame_max_tx_count);\r\nspin_lock_bh(&priv->tx_policy_cache.lock);\r\npriv->long_frame_max_tx_count = conf->long_frame_max_tx_count;\r\npriv->short_frame_max_tx_count =\r\n(conf->short_frame_max_tx_count < 0x0F) ?\r\nconf->short_frame_max_tx_count : 0x0F;\r\npriv->hw->max_rate_tries = priv->short_frame_max_tx_count;\r\nspin_unlock_bh(&priv->tx_policy_cache.lock);\r\n}\r\nmutex_unlock(&priv->conf_mutex);\r\nup(&priv->scan.lock);\r\nreturn ret;\r\n}\r\nvoid cw1200_update_filtering(struct cw1200_common *priv)\r\n{\r\nint ret;\r\nbool bssid_filtering = !priv->rx_filter.bssid;\r\nbool is_p2p = priv->vif && priv->vif->p2p;\r\nbool is_sta = priv->vif && NL80211_IFTYPE_STATION == priv->vif->type;\r\nstatic struct wsm_beacon_filter_control bf_ctrl;\r\nstatic struct wsm_mib_beacon_filter_table bf_tbl = {\r\n.entry[0].ie_id = WLAN_EID_VENDOR_SPECIFIC,\r\n.entry[0].flags = WSM_BEACON_FILTER_IE_HAS_CHANGED |\r\nWSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |\r\nWSM_BEACON_FILTER_IE_HAS_APPEARED,\r\n.entry[0].oui[0] = 0x50,\r\n.entry[0].oui[1] = 0x6F,\r\n.entry[0].oui[2] = 0x9A,\r\n.entry[1].ie_id = WLAN_EID_HT_OPERATION,\r\n.entry[1].flags = WSM_BEACON_FILTER_IE_HAS_CHANGED |\r\nWSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |\r\nWSM_BEACON_FILTER_IE_HAS_APPEARED,\r\n.entry[2].ie_id = WLAN_EID_ERP_INFO,\r\n.entry[2].flags = WSM_BEACON_FILTER_IE_HAS_CHANGED |\r\nWSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |\r\nWSM_BEACON_FILTER_IE_HAS_APPEARED,\r\n};\r\nif (priv->join_status == CW1200_JOIN_STATUS_PASSIVE)\r\nreturn;\r\nelse if (priv->join_status == CW1200_JOIN_STATUS_MONITOR)\r\nbssid_filtering = false;\r\nif (priv->disable_beacon_filter) {\r\nbf_ctrl.enabled = 0;\r\nbf_ctrl.bcn_count = 1;\r\nbf_tbl.num = __cpu_to_le32(0);\r\n} else if (is_p2p || !is_sta) {\r\nbf_ctrl.enabled = WSM_BEACON_FILTER_ENABLE |\r\nWSM_BEACON_FILTER_AUTO_ERP;\r\nbf_ctrl.bcn_count = 0;\r\nbf_tbl.num = __cpu_to_le32(2);\r\n} else {\r\nbf_ctrl.enabled = WSM_BEACON_FILTER_ENABLE;\r\nbf_ctrl.bcn_count = 0;\r\nbf_tbl.num = __cpu_to_le32(3);\r\n}\r\nif (is_p2p)\r\nbssid_filtering = false;\r\nret = wsm_set_rx_filter(priv, &priv->rx_filter);\r\nif (!ret)\r\nret = wsm_set_beacon_filter_table(priv, &bf_tbl);\r\nif (!ret)\r\nret = wsm_beacon_filter_control(priv, &bf_ctrl);\r\nif (!ret)\r\nret = wsm_set_bssid_filtering(priv, bssid_filtering);\r\nif (!ret)\r\nret = wsm_set_multicast_filter(priv, &priv->multicast_filter);\r\nif (ret)\r\nwiphy_err(priv->hw->wiphy,\r\n"Update filtering failed: %d.\n", ret);\r\nreturn;\r\n}\r\nvoid cw1200_update_filtering_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common,\r\nupdate_filtering_work);\r\ncw1200_update_filtering(priv);\r\n}\r\nvoid cw1200_set_beacon_wakeup_period_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common,\r\nset_beacon_wakeup_period_work);\r\nwsm_set_beacon_wakeup_period(priv,\r\npriv->beacon_int * priv->join_dtim_period >\r\nMAX_BEACON_SKIP_TIME_MS ? 1 :\r\npriv->join_dtim_period, 0);\r\n}\r\nu64 cw1200_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nstatic u8 broadcast_ipv6[ETH_ALEN] = {\r\n0x33, 0x33, 0x00, 0x00, 0x00, 0x01\r\n};\r\nstatic u8 broadcast_ipv4[ETH_ALEN] = {\r\n0x01, 0x00, 0x5e, 0x00, 0x00, 0x01\r\n};\r\nstruct cw1200_common *priv = hw->priv;\r\nstruct netdev_hw_addr *ha;\r\nint count = 0;\r\npriv->has_multicast_subscription = false;\r\nmemset(&priv->multicast_filter, 0x00, sizeof(priv->multicast_filter));\r\nif (netdev_hw_addr_list_count(mc_list) > WSM_MAX_GRP_ADDRTABLE_ENTRIES)\r\nreturn 0;\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\npr_debug("[STA] multicast: %pM\n", ha->addr);\r\nmemcpy(&priv->multicast_filter.macaddrs[count],\r\nha->addr, ETH_ALEN);\r\nif (!ether_addr_equal(ha->addr, broadcast_ipv4) &&\r\n!ether_addr_equal(ha->addr, broadcast_ipv6))\r\npriv->has_multicast_subscription = true;\r\ncount++;\r\n}\r\nif (count) {\r\npriv->multicast_filter.enable = __cpu_to_le32(1);\r\npriv->multicast_filter.num_addrs = __cpu_to_le32(count);\r\n}\r\nreturn netdev_hw_addr_list_count(mc_list);\r\n}\r\nvoid cw1200_configure_filter(struct ieee80211_hw *dev,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nbool listening = !!(*total_flags &\r\n(FIF_OTHER_BSS |\r\nFIF_BCN_PRBRESP_PROMISC |\r\nFIF_PROBE_REQ));\r\n*total_flags &= FIF_OTHER_BSS |\r\nFIF_FCSFAIL |\r\nFIF_BCN_PRBRESP_PROMISC |\r\nFIF_PROBE_REQ;\r\ndown(&priv->scan.lock);\r\nmutex_lock(&priv->conf_mutex);\r\npriv->rx_filter.promiscuous = 0;\r\npriv->rx_filter.bssid = (*total_flags & (FIF_OTHER_BSS |\r\nFIF_PROBE_REQ)) ? 1 : 0;\r\npriv->rx_filter.fcs = (*total_flags & FIF_FCSFAIL) ? 1 : 0;\r\npriv->disable_beacon_filter = !(*total_flags &\r\n(FIF_BCN_PRBRESP_PROMISC |\r\nFIF_PROBE_REQ));\r\nif (priv->listening != listening) {\r\npriv->listening = listening;\r\nwsm_lock_tx(priv);\r\ncw1200_update_listening(priv, listening);\r\nwsm_unlock_tx(priv);\r\n}\r\ncw1200_update_filtering(priv);\r\nmutex_unlock(&priv->conf_mutex);\r\nup(&priv->scan.lock);\r\n}\r\nint cw1200_conf_tx(struct ieee80211_hw *dev, struct ieee80211_vif *vif,\r\nu16 queue, const struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nint ret = 0;\r\nbool old_uapsd_flags;\r\nmutex_lock(&priv->conf_mutex);\r\nif (queue < dev->queues) {\r\nold_uapsd_flags = le16_to_cpu(priv->uapsd_info.uapsd_flags);\r\nWSM_TX_QUEUE_SET(&priv->tx_queue_params, queue, 0, 0, 0);\r\nret = wsm_set_tx_queue_params(priv,\r\n&priv->tx_queue_params.params[queue], queue);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nWSM_EDCA_SET(&priv->edca, queue, params->aifs,\r\nparams->cw_min, params->cw_max,\r\nparams->txop, 0xc8,\r\nparams->uapsd);\r\nret = wsm_set_edca_params(priv, &priv->edca);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (priv->mode == NL80211_IFTYPE_STATION) {\r\nret = cw1200_set_uapsd_param(priv, &priv->edca);\r\nif (!ret && priv->setbssparams_done &&\r\n(priv->join_status == CW1200_JOIN_STATUS_STA) &&\r\n(old_uapsd_flags != le16_to_cpu(priv->uapsd_info.uapsd_flags)))\r\nret = cw1200_set_pm(priv, &priv->powersave_mode);\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn ret;\r\n}\r\nint cw1200_get_stats(struct ieee80211_hw *dev,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nmemcpy(stats, &priv->stats, sizeof(*stats));\r\nreturn 0;\r\n}\r\nint cw1200_set_pm(struct cw1200_common *priv, const struct wsm_set_pm *arg)\r\n{\r\nstruct wsm_set_pm pm = *arg;\r\nif (priv->uapsd_info.uapsd_flags != 0)\r\npm.mode &= ~WSM_PSM_FAST_PS_FLAG;\r\nif (memcmp(&pm, &priv->firmware_ps_mode,\r\nsizeof(struct wsm_set_pm))) {\r\npriv->firmware_ps_mode = pm;\r\nreturn wsm_set_pm(priv, &pm);\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nint cw1200_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nint ret = -EOPNOTSUPP;\r\nstruct cw1200_common *priv = dev->priv;\r\nstruct ieee80211_key_seq seq;\r\nmutex_lock(&priv->conf_mutex);\r\nif (cmd == SET_KEY) {\r\nu8 *peer_addr = NULL;\r\nint pairwise = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?\r\n1 : 0;\r\nint idx = cw1200_alloc_key(priv);\r\nstruct wsm_add_key *wsm_key = &priv->keys[idx];\r\nif (idx < 0) {\r\nret = -EINVAL;\r\ngoto finally;\r\n}\r\nif (sta)\r\npeer_addr = sta->addr;\r\nkey->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE |\r\nIEEE80211_KEY_FLAG_RESERVE_TAILROOM;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nif (key->keylen > 16) {\r\ncw1200_free_key(priv, idx);\r\nret = -EINVAL;\r\ngoto finally;\r\n}\r\nif (pairwise) {\r\nwsm_key->type = WSM_KEY_TYPE_WEP_PAIRWISE;\r\nmemcpy(wsm_key->wep_pairwise.peer,\r\npeer_addr, ETH_ALEN);\r\nmemcpy(wsm_key->wep_pairwise.keydata,\r\n&key->key[0], key->keylen);\r\nwsm_key->wep_pairwise.keylen = key->keylen;\r\n} else {\r\nwsm_key->type = WSM_KEY_TYPE_WEP_DEFAULT;\r\nmemcpy(wsm_key->wep_group.keydata,\r\n&key->key[0], key->keylen);\r\nwsm_key->wep_group.keylen = key->keylen;\r\nwsm_key->wep_group.keyid = key->keyidx;\r\n}\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nieee80211_get_key_rx_seq(key, 0, &seq);\r\nif (pairwise) {\r\nwsm_key->type = WSM_KEY_TYPE_TKIP_PAIRWISE;\r\nmemcpy(wsm_key->tkip_pairwise.peer,\r\npeer_addr, ETH_ALEN);\r\nmemcpy(wsm_key->tkip_pairwise.keydata,\r\n&key->key[0], 16);\r\nmemcpy(wsm_key->tkip_pairwise.tx_mic_key,\r\n&key->key[16], 8);\r\nmemcpy(wsm_key->tkip_pairwise.rx_mic_key,\r\n&key->key[24], 8);\r\n} else {\r\nsize_t mic_offset =\r\n(priv->mode == NL80211_IFTYPE_AP) ?\r\n16 : 24;\r\nwsm_key->type = WSM_KEY_TYPE_TKIP_GROUP;\r\nmemcpy(wsm_key->tkip_group.keydata,\r\n&key->key[0], 16);\r\nmemcpy(wsm_key->tkip_group.rx_mic_key,\r\n&key->key[mic_offset], 8);\r\nwsm_key->tkip_group.rx_seqnum[0] = seq.tkip.iv16 & 0xff;\r\nwsm_key->tkip_group.rx_seqnum[1] = (seq.tkip.iv16 >> 8) & 0xff;\r\nwsm_key->tkip_group.rx_seqnum[2] = seq.tkip.iv32 & 0xff;\r\nwsm_key->tkip_group.rx_seqnum[3] = (seq.tkip.iv32 >> 8) & 0xff;\r\nwsm_key->tkip_group.rx_seqnum[4] = (seq.tkip.iv32 >> 16) & 0xff;\r\nwsm_key->tkip_group.rx_seqnum[5] = (seq.tkip.iv32 >> 24) & 0xff;\r\nwsm_key->tkip_group.rx_seqnum[6] = 0;\r\nwsm_key->tkip_group.rx_seqnum[7] = 0;\r\nwsm_key->tkip_group.keyid = key->keyidx;\r\n}\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nieee80211_get_key_rx_seq(key, 0, &seq);\r\nif (pairwise) {\r\nwsm_key->type = WSM_KEY_TYPE_AES_PAIRWISE;\r\nmemcpy(wsm_key->aes_pairwise.peer,\r\npeer_addr, ETH_ALEN);\r\nmemcpy(wsm_key->aes_pairwise.keydata,\r\n&key->key[0], 16);\r\n} else {\r\nwsm_key->type = WSM_KEY_TYPE_AES_GROUP;\r\nmemcpy(wsm_key->aes_group.keydata,\r\n&key->key[0], 16);\r\nwsm_key->aes_group.rx_seqnum[0] = seq.ccmp.pn[5];\r\nwsm_key->aes_group.rx_seqnum[1] = seq.ccmp.pn[4];\r\nwsm_key->aes_group.rx_seqnum[2] = seq.ccmp.pn[3];\r\nwsm_key->aes_group.rx_seqnum[3] = seq.ccmp.pn[2];\r\nwsm_key->aes_group.rx_seqnum[4] = seq.ccmp.pn[1];\r\nwsm_key->aes_group.rx_seqnum[5] = seq.ccmp.pn[0];\r\nwsm_key->aes_group.rx_seqnum[6] = 0;\r\nwsm_key->aes_group.rx_seqnum[7] = 0;\r\nwsm_key->aes_group.keyid = key->keyidx;\r\n}\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_SMS4:\r\nif (pairwise) {\r\nwsm_key->type = WSM_KEY_TYPE_WAPI_PAIRWISE;\r\nmemcpy(wsm_key->wapi_pairwise.peer,\r\npeer_addr, ETH_ALEN);\r\nmemcpy(wsm_key->wapi_pairwise.keydata,\r\n&key->key[0], 16);\r\nmemcpy(wsm_key->wapi_pairwise.mic_key,\r\n&key->key[16], 16);\r\nwsm_key->wapi_pairwise.keyid = key->keyidx;\r\n} else {\r\nwsm_key->type = WSM_KEY_TYPE_WAPI_GROUP;\r\nmemcpy(wsm_key->wapi_group.keydata,\r\n&key->key[0], 16);\r\nmemcpy(wsm_key->wapi_group.mic_key,\r\n&key->key[16], 16);\r\nwsm_key->wapi_group.keyid = key->keyidx;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("Unhandled key type %d\n", key->cipher);\r\ncw1200_free_key(priv, idx);\r\nret = -EOPNOTSUPP;\r\ngoto finally;\r\n}\r\nret = wsm_add_key(priv, wsm_key);\r\nif (!ret)\r\nkey->hw_key_idx = idx;\r\nelse\r\ncw1200_free_key(priv, idx);\r\n} else if (cmd == DISABLE_KEY) {\r\nstruct wsm_remove_key wsm_key = {\r\n.index = key->hw_key_idx,\r\n};\r\nif (wsm_key.index > WSM_KEY_MAX_INDEX) {\r\nret = -EINVAL;\r\ngoto finally;\r\n}\r\ncw1200_free_key(priv, wsm_key.index);\r\nret = wsm_remove_key(priv, &wsm_key);\r\n} else {\r\npr_warn("Unhandled key command %d\n", cmd);\r\n}\r\nfinally:\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn ret;\r\n}\r\nvoid cw1200_wep_key_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, wep_key_work);\r\nu8 queue_id = cw1200_queue_get_queue_id(priv->pending_frame_id);\r\nstruct cw1200_queue *queue = &priv->tx_queue[queue_id];\r\n__le32 wep_default_key_id = __cpu_to_le32(\r\npriv->wep_default_key_id);\r\npr_debug("[STA] Setting default WEP key: %d\n",\r\npriv->wep_default_key_id);\r\nwsm_flush_tx(priv);\r\nwsm_write_mib(priv, WSM_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID,\r\n&wep_default_key_id, sizeof(wep_default_key_id));\r\ncw1200_queue_requeue(queue, priv->pending_frame_id);\r\nwsm_unlock_tx(priv);\r\n}\r\nint cw1200_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\r\n{\r\nint ret = 0;\r\n__le32 val32;\r\nstruct cw1200_common *priv = hw->priv;\r\nif (priv->mode == NL80211_IFTYPE_UNSPECIFIED)\r\nreturn 0;\r\nif (value != (u32) -1)\r\nval32 = __cpu_to_le32(value);\r\nelse\r\nval32 = 0;\r\nif (priv->mode == NL80211_IFTYPE_UNSPECIFIED) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (priv->rts_threshold == value)\r\ngoto out;\r\npr_debug("[STA] Setting RTS threshold: %d\n",\r\npriv->rts_threshold);\r\nret = wsm_write_mib(priv, WSM_MIB_ID_DOT11_RTS_THRESHOLD,\r\n&val32, sizeof(val32));\r\nif (!ret)\r\npriv->rts_threshold = value;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __cw1200_flush(struct cw1200_common *priv, bool drop)\r\n{\r\nint i, ret;\r\nfor (;;) {\r\nif (drop) {\r\nfor (i = 0; i < 4; ++i)\r\ncw1200_queue_clear(&priv->tx_queue[i]);\r\n} else {\r\nret = wait_event_timeout(\r\npriv->tx_queue_stats.wait_link_id_empty,\r\ncw1200_queue_stats_is_empty(\r\n&priv->tx_queue_stats, -1),\r\n2 * HZ);\r\n}\r\nif (!drop && ret <= 0) {\r\nret = -ETIMEDOUT;\r\nbreak;\r\n} else {\r\nret = 0;\r\n}\r\nwsm_lock_tx(priv);\r\nif (!cw1200_queue_stats_is_empty(&priv->tx_queue_stats, -1)) {\r\nwsm_unlock_tx(priv);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid cw1200_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nu32 queues, bool drop)\r\n{\r\nstruct cw1200_common *priv = hw->priv;\r\nswitch (priv->mode) {\r\ncase NL80211_IFTYPE_MONITOR:\r\ndrop = true;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nif (!priv->enable_beacon)\r\ndrop = true;\r\nbreak;\r\n}\r\nif (!__cw1200_flush(priv, drop))\r\nwsm_unlock_tx(priv);\r\nreturn;\r\n}\r\nvoid cw1200_free_event_queue(struct cw1200_common *priv)\r\n{\r\nLIST_HEAD(list);\r\nspin_lock(&priv->event_queue_lock);\r\nlist_splice_init(&priv->event_queue, &list);\r\nspin_unlock(&priv->event_queue_lock);\r\n__cw1200_free_event_queue(&list);\r\n}\r\nvoid cw1200_event_handler(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, event_handler);\r\nstruct cw1200_wsm_event *event;\r\nLIST_HEAD(list);\r\nspin_lock(&priv->event_queue_lock);\r\nlist_splice_init(&priv->event_queue, &list);\r\nspin_unlock(&priv->event_queue_lock);\r\nlist_for_each_entry(event, &list, link) {\r\nswitch (event->evt.id) {\r\ncase WSM_EVENT_ERROR:\r\npr_err("Unhandled WSM Error from LMAC\n");\r\nbreak;\r\ncase WSM_EVENT_BSS_LOST:\r\npr_debug("[CQM] BSS lost.\n");\r\ncancel_work_sync(&priv->unjoin_work);\r\nif (!down_trylock(&priv->scan.lock)) {\r\ncw1200_cqm_bssloss_sm(priv, 1, 0, 0);\r\nup(&priv->scan.lock);\r\n} else {\r\npriv->delayed_link_loss = 1;\r\nqueue_delayed_work(priv->workqueue,\r\n&priv->bss_loss_work, 5*HZ);\r\n}\r\nbreak;\r\ncase WSM_EVENT_BSS_REGAINED:\r\npr_debug("[CQM] BSS regained.\n");\r\ncw1200_cqm_bssloss_sm(priv, 0, 0, 0);\r\ncancel_work_sync(&priv->unjoin_work);\r\nbreak;\r\ncase WSM_EVENT_RADAR_DETECTED:\r\nwiphy_info(priv->hw->wiphy, "radar pulse detected\n");\r\nbreak;\r\ncase WSM_EVENT_RCPI_RSSI:\r\n{\r\nint rcpi_rssi = (int)(event->evt.data & 0xFF);\r\nint cqm_evt;\r\nif (priv->cqm_use_rssi)\r\nrcpi_rssi = (s8)rcpi_rssi;\r\nelse\r\nrcpi_rssi = rcpi_rssi / 2 - 110;\r\ncqm_evt = (rcpi_rssi <= priv->cqm_rssi_thold) ?\r\nNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW :\r\nNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\r\npr_debug("[CQM] RSSI event: %d.\n", rcpi_rssi);\r\nieee80211_cqm_rssi_notify(priv->vif, cqm_evt,\r\nGFP_KERNEL);\r\nbreak;\r\n}\r\ncase WSM_EVENT_BT_INACTIVE:\r\npr_warn("Unhandled BT INACTIVE from LMAC\n");\r\nbreak;\r\ncase WSM_EVENT_BT_ACTIVE:\r\npr_warn("Unhandled BT ACTIVE from LMAC\n");\r\nbreak;\r\n}\r\n}\r\n__cw1200_free_event_queue(&list);\r\n}\r\nvoid cw1200_bss_loss_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, bss_loss_work.work);\r\npr_debug("[CQM] Reporting connection loss.\n");\r\nwsm_lock_tx(priv);\r\nif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\n}\r\nvoid cw1200_bss_params_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, bss_params_work);\r\nmutex_lock(&priv->conf_mutex);\r\npriv->bss_params.reset_beacon_loss = 1;\r\nwsm_set_bss_params(priv, &priv->bss_params);\r\npriv->bss_params.reset_beacon_loss = 0;\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nstatic int cw1200_parse_sdd_file(struct cw1200_common *priv)\r\n{\r\nconst u8 *p = priv->sdd->data;\r\nint ret = 0;\r\nwhile (p + 2 <= priv->sdd->data + priv->sdd->size) {\r\nif (p + p[1] + 2 > priv->sdd->data + priv->sdd->size) {\r\npr_warn("Malformed sdd structure\n");\r\nreturn -1;\r\n}\r\nswitch (p[0]) {\r\ncase SDD_PTA_CFG_ELT_ID: {\r\nu16 v;\r\nif (p[1] < 4) {\r\npr_warn("SDD_PTA_CFG_ELT_ID malformed\n");\r\nret = -1;\r\nbreak;\r\n}\r\nv = le16_to_cpu(*((__le16 *)(p + 2)));\r\nif (!v)\r\nbreak;\r\nv = le16_to_cpu(*((__le16 *)(p + 4)));\r\npriv->conf_listen_interval = (v >> 7) & 0x1F;\r\npr_debug("PTA found; Listen Interval %d\n",\r\npriv->conf_listen_interval);\r\nbreak;\r\n}\r\ncase SDD_REFERENCE_FREQUENCY_ELT_ID: {\r\nu16 clk = le16_to_cpu(*((__le16 *)(p + 2)));\r\nif (clk != priv->hw_refclk)\r\npr_warn("SDD file doesn't match configured refclk (%d vs %d)\n",\r\nclk, priv->hw_refclk);\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\np += p[1] + 2;\r\n}\r\nif (!priv->bt_present) {\r\npr_debug("PTA element NOT found.\n");\r\npriv->conf_listen_interval = 0;\r\n}\r\nreturn ret;\r\n}\r\nint cw1200_setup_mac(struct cw1200_common *priv)\r\n{\r\nint ret = 0;\r\nstruct wsm_rcpi_rssi_threshold threshold = {\r\n.rssiRcpiMode = WSM_RCPI_RSSI_THRESHOLD_ENABLE |\r\nWSM_RCPI_RSSI_DONT_USE_UPPER |\r\nWSM_RCPI_RSSI_DONT_USE_LOWER,\r\n.rollingAverageCount = 16,\r\n};\r\nstruct wsm_configuration cfg = {\r\n.dot11StationId = &priv->mac_addr[0],\r\n};\r\nif (threshold.rssiRcpiMode & WSM_RCPI_RSSI_USE_RSSI)\r\npriv->cqm_use_rssi = true;\r\nif (!priv->sdd) {\r\nret = request_firmware(&priv->sdd, priv->sdd_path, priv->pdev);\r\nif (ret) {\r\npr_err("Can't load sdd file %s.\n", priv->sdd_path);\r\nreturn ret;\r\n}\r\ncw1200_parse_sdd_file(priv);\r\n}\r\ncfg.dpdData = priv->sdd->data;\r\ncfg.dpdData_size = priv->sdd->size;\r\nret = wsm_configuration(priv, &cfg);\r\nif (ret)\r\nreturn ret;\r\nwsm_set_rcpi_rssi_threshold(priv, &threshold);\r\nreturn 0;\r\n}\r\nstatic void cw1200_join_complete(struct cw1200_common *priv)\r\n{\r\npr_debug("[STA] Join complete (%d)\n", priv->join_complete_status);\r\npriv->join_pending = false;\r\nif (priv->join_complete_status) {\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\ncw1200_update_listening(priv, priv->listening);\r\ncw1200_do_unjoin(priv);\r\nieee80211_connection_loss(priv->vif);\r\n} else {\r\nif (priv->mode == NL80211_IFTYPE_ADHOC)\r\npriv->join_status = CW1200_JOIN_STATUS_IBSS;\r\nelse\r\npriv->join_status = CW1200_JOIN_STATUS_PRE_STA;\r\n}\r\nwsm_unlock_tx(priv);\r\n}\r\nvoid cw1200_join_complete_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, join_complete_work);\r\nmutex_lock(&priv->conf_mutex);\r\ncw1200_join_complete(priv);\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nvoid cw1200_join_complete_cb(struct cw1200_common *priv,\r\nstruct wsm_join_complete *arg)\r\n{\r\npr_debug("[STA] cw1200_join_complete_cb called, status=%d.\n",\r\narg->status);\r\nif (cancel_delayed_work(&priv->join_timeout)) {\r\npriv->join_complete_status = arg->status;\r\nqueue_work(priv->workqueue, &priv->join_complete_work);\r\n}\r\n}\r\nstatic void cw1200_do_join(struct cw1200_common *priv)\r\n{\r\nconst u8 *bssid;\r\nstruct ieee80211_bss_conf *conf = &priv->vif->bss_conf;\r\nstruct cfg80211_bss *bss = NULL;\r\nstruct wsm_protected_mgmt_policy mgmt_policy;\r\nstruct wsm_join join = {\r\n.mode = conf->ibss_joined ?\r\nWSM_JOIN_MODE_IBSS : WSM_JOIN_MODE_BSS,\r\n.preamble_type = WSM_JOIN_PREAMBLE_LONG,\r\n.probe_for_join = 1,\r\n.atim_window = 0,\r\n.basic_rate_set = cw1200_rate_mask_to_wsm(priv,\r\nconf->basic_rates),\r\n};\r\nif (delayed_work_pending(&priv->join_timeout)) {\r\npr_warn("[STA] - Join request already pending, skipping..\n");\r\nwsm_unlock_tx(priv);\r\nreturn;\r\n}\r\nif (priv->join_status)\r\ncw1200_do_unjoin(priv);\r\nbssid = priv->vif->bss_conf.bssid;\r\nbss = cfg80211_get_bss(priv->hw->wiphy, priv->channel, bssid, NULL, 0,\r\nIEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\r\nif (!bss && !conf->ibss_joined) {\r\nwsm_unlock_tx(priv);\r\nreturn;\r\n}\r\nmutex_lock(&priv->conf_mutex);\r\nif (atomic_read(&priv->scan.in_progress)) {\r\nwsm_unlock_tx(priv);\r\ngoto done_put;\r\n}\r\npriv->join_pending = true;\r\nif (!join.basic_rate_set)\r\njoin.basic_rate_set = 7;\r\nif (!priv->beacon_int)\r\npriv->beacon_int = 1;\r\njoin.beacon_interval = priv->beacon_int;\r\nif (priv->bt_present) {\r\nif (((priv->conf_listen_interval * 100) %\r\npriv->beacon_int) == 0)\r\npriv->listen_interval =\r\n((priv->conf_listen_interval * 100) /\r\npriv->beacon_int);\r\nelse\r\npriv->listen_interval =\r\n((priv->conf_listen_interval * 100) /\r\npriv->beacon_int + 1);\r\n}\r\nif (priv->hw->conf.ps_dtim_period)\r\npriv->join_dtim_period = priv->hw->conf.ps_dtim_period;\r\njoin.dtim_period = priv->join_dtim_period;\r\njoin.channel_number = priv->channel->hw_value;\r\njoin.band = (priv->channel->band == IEEE80211_BAND_5GHZ) ?\r\nWSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;\r\nmemcpy(join.bssid, bssid, sizeof(join.bssid));\r\npr_debug("[STA] Join BSSID: %pM DTIM: %d, interval: %d\n",\r\njoin.bssid,\r\njoin.dtim_period, priv->beacon_int);\r\nif (!conf->ibss_joined) {\r\nconst u8 *ssidie;\r\nrcu_read_lock();\r\nssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);\r\nif (ssidie) {\r\njoin.ssid_len = ssidie[1];\r\nmemcpy(join.ssid, &ssidie[2], join.ssid_len);\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (priv->vif->p2p) {\r\njoin.flags |= WSM_JOIN_FLAGS_P2P_GO;\r\njoin.basic_rate_set =\r\ncw1200_rate_mask_to_wsm(priv, 0xFF0);\r\n}\r\nif (!conf->ibss_joined) {\r\njoin.flags |= WSM_JOIN_FLAGS_FORCE;\r\njoin.flags |= WSM_JOIN_FLAGS_FORCE_WITH_COMPLETE_IND;\r\n}\r\nwsm_flush_tx(priv);\r\ncw1200_pm_stay_awake(&priv->pm_state,\r\nCW1200_JOIN_TIMEOUT + CW1200_AUTH_TIMEOUT);\r\ncw1200_update_listening(priv, false);\r\nwsm_set_block_ack_policy(priv, priv->ba_tx_tid_mask,\r\npriv->ba_rx_tid_mask);\r\nif (join.flags & WSM_JOIN_FLAGS_FORCE_WITH_COMPLETE_IND) {\r\npriv->join_status = CW1200_JOIN_STATUS_JOINING;\r\nqueue_delayed_work(priv->workqueue,\r\n&priv->join_timeout,\r\nCW1200_JOIN_TIMEOUT);\r\n}\r\nmgmt_policy.protectedMgmtEnable = 0;\r\nmgmt_policy.unprotectedMgmtFramesAllowed = 1;\r\nmgmt_policy.encryptionForAuthFrame = 1;\r\nwsm_set_protected_mgmt_policy(priv, &mgmt_policy);\r\nif (wsm_join(priv, &join)) {\r\npr_err("[STA] cw1200_join_work: wsm_join failed!\n");\r\ncancel_delayed_work_sync(&priv->join_timeout);\r\ncw1200_update_listening(priv, priv->listening);\r\nif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\n} else {\r\nif (!(join.flags & WSM_JOIN_FLAGS_FORCE_WITH_COMPLETE_IND))\r\ncw1200_join_complete(priv);\r\ncw1200_upload_keys(priv);\r\npriv->disable_beacon_filter = true;\r\n}\r\ncw1200_update_filtering(priv);\r\ndone_put:\r\nmutex_unlock(&priv->conf_mutex);\r\nif (bss)\r\ncfg80211_put_bss(priv->hw->wiphy, bss);\r\n}\r\nvoid cw1200_join_timeout(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, join_timeout.work);\r\npr_debug("[WSM] Join timed out.\n");\r\nwsm_lock_tx(priv);\r\nif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\r\nwsm_unlock_tx(priv);\r\n}\r\nstatic void cw1200_do_unjoin(struct cw1200_common *priv)\r\n{\r\nstruct wsm_reset reset = {\r\n.reset_statistics = true,\r\n};\r\ncancel_delayed_work_sync(&priv->join_timeout);\r\nmutex_lock(&priv->conf_mutex);\r\npriv->join_pending = false;\r\nif (atomic_read(&priv->scan.in_progress)) {\r\nif (priv->delayed_unjoin)\r\nwiphy_dbg(priv->hw->wiphy, "Delayed unjoin is already scheduled.\n");\r\nelse\r\npriv->delayed_unjoin = true;\r\ngoto done;\r\n}\r\npriv->delayed_link_loss = false;\r\nif (!priv->join_status)\r\ngoto done;\r\nif (priv->join_status == CW1200_JOIN_STATUS_AP)\r\ngoto done;\r\ncancel_work_sync(&priv->update_filtering_work);\r\ncancel_work_sync(&priv->set_beacon_wakeup_period_work);\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\nwsm_flush_tx(priv);\r\nwsm_keep_alive_period(priv, 0);\r\nwsm_reset(priv, &reset);\r\nwsm_set_output_power(priv, priv->output_power * 10);\r\npriv->join_dtim_period = 0;\r\ncw1200_setup_mac(priv);\r\ncw1200_free_event_queue(priv);\r\ncancel_work_sync(&priv->event_handler);\r\ncw1200_update_listening(priv, priv->listening);\r\ncw1200_cqm_bssloss_sm(priv, 0, 0, 0);\r\nwsm_set_block_ack_policy(priv, 0, 0);\r\npriv->disable_beacon_filter = false;\r\ncw1200_update_filtering(priv);\r\nmemset(&priv->association_mode, 0,\r\nsizeof(priv->association_mode));\r\nmemset(&priv->bss_params, 0, sizeof(priv->bss_params));\r\npriv->setbssparams_done = false;\r\nmemset(&priv->firmware_ps_mode, 0,\r\nsizeof(priv->firmware_ps_mode));\r\npr_debug("[STA] Unjoin completed.\n");\r\ndone:\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nvoid cw1200_unjoin_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, unjoin_work);\r\ncw1200_do_unjoin(priv);\r\nieee80211_connection_loss(priv->vif);\r\nwsm_unlock_tx(priv);\r\n}\r\nint cw1200_enable_listening(struct cw1200_common *priv)\r\n{\r\nstruct wsm_start start = {\r\n.mode = WSM_START_MODE_P2P_DEV,\r\n.band = WSM_PHY_BAND_2_4G,\r\n.beacon_interval = 100,\r\n.dtim_period = 1,\r\n.probe_delay = 0,\r\n.basic_rate_set = 0x0F,\r\n};\r\nif (priv->channel) {\r\nstart.band = priv->channel->band == IEEE80211_BAND_5GHZ ?\r\nWSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;\r\nstart.channel_number = priv->channel->hw_value;\r\n} else {\r\nstart.band = WSM_PHY_BAND_2_4G;\r\nstart.channel_number = 1;\r\n}\r\nreturn wsm_start(priv, &start);\r\n}\r\nint cw1200_disable_listening(struct cw1200_common *priv)\r\n{\r\nint ret;\r\nstruct wsm_reset reset = {\r\n.reset_statistics = true,\r\n};\r\nret = wsm_reset(priv, &reset);\r\nreturn ret;\r\n}\r\nvoid cw1200_update_listening(struct cw1200_common *priv, bool enabled)\r\n{\r\nif (enabled) {\r\nif (priv->join_status == CW1200_JOIN_STATUS_PASSIVE) {\r\nif (!cw1200_enable_listening(priv))\r\npriv->join_status = CW1200_JOIN_STATUS_MONITOR;\r\nwsm_set_probe_responder(priv, true);\r\n}\r\n} else {\r\nif (priv->join_status == CW1200_JOIN_STATUS_MONITOR) {\r\nif (!cw1200_disable_listening(priv))\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\nwsm_set_probe_responder(priv, false);\r\n}\r\n}\r\n}\r\nint cw1200_set_uapsd_param(struct cw1200_common *priv,\r\nconst struct wsm_edca_params *arg)\r\n{\r\nint ret;\r\nu16 uapsd_flags = 0;\r\nif (arg->uapsd_enable[0])\r\nuapsd_flags |= 1 << 3;\r\nif (arg->uapsd_enable[1])\r\nuapsd_flags |= 1 << 2;\r\nif (arg->uapsd_enable[2])\r\nuapsd_flags |= 1 << 1;\r\nif (arg->uapsd_enable[3])\r\nuapsd_flags |= 1;\r\npriv->uapsd_info.uapsd_flags = cpu_to_le16(uapsd_flags);\r\npriv->uapsd_info.min_auto_trigger_interval = 0;\r\npriv->uapsd_info.max_auto_trigger_interval = 0;\r\npriv->uapsd_info.auto_trigger_step = 0;\r\nret = wsm_set_uapsd_info(priv, &priv->uapsd_info);\r\nreturn ret;\r\n}\r\nint cw1200_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct cw1200_common *priv = hw->priv;\r\nstruct cw1200_sta_priv *sta_priv =\r\n(struct cw1200_sta_priv *)&sta->drv_priv;\r\nstruct cw1200_link_entry *entry;\r\nstruct sk_buff *skb;\r\nif (priv->mode != NL80211_IFTYPE_AP)\r\nreturn 0;\r\nsta_priv->link_id = cw1200_find_link_id(priv, sta->addr);\r\nif (WARN_ON(!sta_priv->link_id)) {\r\nwiphy_info(priv->hw->wiphy,\r\n"[AP] No more link IDs available.\n");\r\nreturn -ENOENT;\r\n}\r\nentry = &priv->link_id_db[sta_priv->link_id - 1];\r\nspin_lock_bh(&priv->ps_state_lock);\r\nif ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==\r\nIEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\r\npriv->sta_asleep_mask |= BIT(sta_priv->link_id);\r\nentry->status = CW1200_LINK_HARD;\r\nwhile ((skb = skb_dequeue(&entry->rx_queue)))\r\nieee80211_rx_irqsafe(priv->hw, skb);\r\nspin_unlock_bh(&priv->ps_state_lock);\r\nreturn 0;\r\n}\r\nint cw1200_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct cw1200_common *priv = hw->priv;\r\nstruct cw1200_sta_priv *sta_priv =\r\n(struct cw1200_sta_priv *)&sta->drv_priv;\r\nstruct cw1200_link_entry *entry;\r\nif (priv->mode != NL80211_IFTYPE_AP || !sta_priv->link_id)\r\nreturn 0;\r\nentry = &priv->link_id_db[sta_priv->link_id - 1];\r\nspin_lock_bh(&priv->ps_state_lock);\r\nentry->status = CW1200_LINK_RESERVE;\r\nentry->timestamp = jiffies;\r\nwsm_lock_tx_async(priv);\r\nif (queue_work(priv->workqueue, &priv->link_id_work) <= 0)\r\nwsm_unlock_tx(priv);\r\nspin_unlock_bh(&priv->ps_state_lock);\r\nflush_workqueue(priv->workqueue);\r\nreturn 0;\r\n}\r\nstatic void __cw1200_sta_notify(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif,\r\nenum sta_notify_cmd notify_cmd,\r\nint link_id)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nu32 bit, prev;\r\nif (link_id)\r\nbit = BIT(link_id);\r\nelse if (WARN_ON_ONCE(notify_cmd != STA_NOTIFY_AWAKE))\r\nbit = 0;\r\nelse\r\nbit = priv->link_id_map;\r\nprev = priv->sta_asleep_mask & bit;\r\nswitch (notify_cmd) {\r\ncase STA_NOTIFY_SLEEP:\r\nif (!prev) {\r\nif (priv->buffered_multicasts &&\r\n!priv->sta_asleep_mask)\r\nqueue_work(priv->workqueue,\r\n&priv->multicast_start_work);\r\npriv->sta_asleep_mask |= bit;\r\n}\r\nbreak;\r\ncase STA_NOTIFY_AWAKE:\r\nif (prev) {\r\npriv->sta_asleep_mask &= ~bit;\r\npriv->pspoll_mask &= ~bit;\r\nif (priv->tx_multicast && link_id &&\r\n!priv->sta_asleep_mask)\r\nqueue_work(priv->workqueue,\r\n&priv->multicast_stop_work);\r\ncw1200_bh_wakeup(priv);\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid cw1200_sta_notify(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif,\r\nenum sta_notify_cmd notify_cmd,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nstruct cw1200_sta_priv *sta_priv =\r\n(struct cw1200_sta_priv *)&sta->drv_priv;\r\nspin_lock_bh(&priv->ps_state_lock);\r\n__cw1200_sta_notify(dev, vif, notify_cmd, sta_priv->link_id);\r\nspin_unlock_bh(&priv->ps_state_lock);\r\n}\r\nstatic void cw1200_ps_notify(struct cw1200_common *priv,\r\nint link_id, bool ps)\r\n{\r\nif (link_id > CW1200_MAX_STA_IN_AP_MODE)\r\nreturn;\r\npr_debug("%s for LinkId: %d. STAs asleep: %.8X\n",\r\nps ? "Stop" : "Start",\r\nlink_id, priv->sta_asleep_mask);\r\n__cw1200_sta_notify(priv->hw, priv->vif,\r\nps ? STA_NOTIFY_SLEEP : STA_NOTIFY_AWAKE, link_id);\r\n}\r\nstatic int cw1200_set_tim_impl(struct cw1200_common *priv, bool aid0_bit_set)\r\n{\r\nstruct sk_buff *skb;\r\nstruct wsm_update_ie update_ie = {\r\n.what = WSM_UPDATE_IE_BEACON,\r\n.count = 1,\r\n};\r\nu16 tim_offset, tim_length;\r\npr_debug("[AP] mcast: %s.\n", aid0_bit_set ? "ena" : "dis");\r\nskb = ieee80211_beacon_get_tim(priv->hw, priv->vif,\r\n&tim_offset, &tim_length);\r\nif (!skb) {\r\nif (!__cw1200_flush(priv, true))\r\nwsm_unlock_tx(priv);\r\nreturn -ENOENT;\r\n}\r\nif (tim_offset && tim_length >= 6) {\r\nskb->data[tim_offset + 2] = 0;\r\nif (aid0_bit_set)\r\nskb->data[tim_offset + 4] |= 1;\r\nelse\r\nskb->data[tim_offset + 4] &= ~1;\r\n}\r\nupdate_ie.ies = &skb->data[tim_offset];\r\nupdate_ie.length = tim_length;\r\nwsm_update_ie(priv, &update_ie);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nvoid cw1200_set_tim_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, set_tim_work);\r\n(void)cw1200_set_tim_impl(priv, priv->aid0_bit_set);\r\n}\r\nint cw1200_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,\r\nbool set)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nqueue_work(priv->workqueue, &priv->set_tim_work);\r\nreturn 0;\r\n}\r\nvoid cw1200_set_cts_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, set_cts_work);\r\nu8 erp_ie[3] = {WLAN_EID_ERP_INFO, 0x1, 0};\r\nstruct wsm_update_ie update_ie = {\r\n.what = WSM_UPDATE_IE_BEACON,\r\n.count = 1,\r\n.ies = erp_ie,\r\n.length = 3,\r\n};\r\nu32 erp_info;\r\n__le32 use_cts_prot;\r\nmutex_lock(&priv->conf_mutex);\r\nerp_info = priv->erp_info;\r\nmutex_unlock(&priv->conf_mutex);\r\nuse_cts_prot =\r\nerp_info & WLAN_ERP_USE_PROTECTION ?\r\n__cpu_to_le32(1) : 0;\r\nerp_ie[ERP_INFO_BYTE_OFFSET] = erp_info;\r\npr_debug("[STA] ERP information 0x%x\n", erp_info);\r\nwsm_write_mib(priv, WSM_MIB_ID_NON_ERP_PROTECTION,\r\n&use_cts_prot, sizeof(use_cts_prot));\r\nwsm_update_ie(priv, &update_ie);\r\nreturn;\r\n}\r\nstatic int cw1200_set_btcoexinfo(struct cw1200_common *priv)\r\n{\r\nstruct wsm_override_internal_txrate arg;\r\nint ret = 0;\r\nif (priv->mode == NL80211_IFTYPE_STATION) {\r\ncw1200_upload_pspoll(priv);\r\ncw1200_upload_null(priv);\r\ncw1200_upload_qosnull(priv);\r\n} else {\r\nreturn 0;\r\n}\r\nmemset(&arg, 0, sizeof(struct wsm_override_internal_txrate));\r\nif (!priv->vif->p2p) {\r\nif (priv->bss_params.operational_rate_set & ~0xF) {\r\npr_debug("[STA] STA has ERP rates\n");\r\narg.internalTxRate = (__ffs(\r\npriv->bss_params.operational_rate_set & ~0xF));\r\n} else {\r\npr_debug("[STA] STA has non ERP rates\n");\r\narg.internalTxRate = (__ffs(le32_to_cpu(priv->association_mode.basic_rate_set)));\r\n}\r\narg.nonErpInternalTxRate = (__ffs(le32_to_cpu(priv->association_mode.basic_rate_set)));\r\n} else {\r\narg.internalTxRate = (__ffs(priv->bss_params.operational_rate_set & ~0xF));\r\narg.nonErpInternalTxRate = (__ffs(priv->bss_params.operational_rate_set & ~0xF));\r\n}\r\npr_debug("[STA] BTCOEX_INFO MODE %d, internalTxRate : %x, nonErpInternalTxRate: %x\n",\r\npriv->mode,\r\narg.internalTxRate,\r\narg.nonErpInternalTxRate);\r\nret = wsm_write_mib(priv, WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,\r\n&arg, sizeof(arg));\r\nreturn ret;\r\n}\r\nvoid cw1200_bss_info_changed(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info,\r\nu32 changed)\r\n{\r\nstruct cw1200_common *priv = dev->priv;\r\nbool do_join = false;\r\nmutex_lock(&priv->conf_mutex);\r\npr_debug("BSS CHANGED: %08x\n", changed);\r\nif (changed & BSS_CHANGED_ARP_FILTER) {\r\nstruct wsm_mib_arp_ipv4_filter filter = {0};\r\nint i;\r\npr_debug("[STA] BSS_CHANGED_ARP_FILTER cnt: %d\n",\r\ninfo->arp_addr_cnt);\r\nif (info->arp_addr_cnt > 0 &&\r\ninfo->arp_addr_cnt <= WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES) {\r\nfor (i = 0; i < info->arp_addr_cnt; i++) {\r\nfilter.ipv4addrs[i] = info->arp_addr_list[i];\r\npr_debug("[STA] addr[%d]: 0x%X\n",\r\ni, filter.ipv4addrs[i]);\r\n}\r\nfilter.enable = __cpu_to_le32(1);\r\n}\r\npr_debug("[STA] arp ip filter enable: %d\n",\r\n__le32_to_cpu(filter.enable));\r\nwsm_set_arp_ipv4_filter(priv, &filter);\r\n}\r\nif (changed &\r\n(BSS_CHANGED_BEACON |\r\nBSS_CHANGED_AP_PROBE_RESP |\r\nBSS_CHANGED_BSSID |\r\nBSS_CHANGED_SSID |\r\nBSS_CHANGED_IBSS)) {\r\npr_debug("BSS_CHANGED_BEACON\n");\r\npriv->beacon_int = info->beacon_int;\r\ncw1200_update_beaconing(priv);\r\ncw1200_upload_beacon(priv);\r\n}\r\nif (changed & BSS_CHANGED_BEACON_ENABLED) {\r\npr_debug("BSS_CHANGED_BEACON_ENABLED (%d)\n", info->enable_beacon);\r\nif (priv->enable_beacon != info->enable_beacon) {\r\ncw1200_enable_beaconing(priv, info->enable_beacon);\r\npriv->enable_beacon = info->enable_beacon;\r\n}\r\n}\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\npr_debug("CHANGED_BEACON_INT\n");\r\nif (info->ibss_joined)\r\ndo_join = true;\r\nelse if (priv->join_status == CW1200_JOIN_STATUS_AP)\r\ncw1200_update_beaconing(priv);\r\n}\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nwsm_lock_tx(priv);\r\npriv->wep_default_key_id = -1;\r\nwsm_unlock_tx(priv);\r\n}\r\nif (changed & BSS_CHANGED_BSSID) {\r\npr_debug("BSS_CHANGED_BSSID\n");\r\ndo_join = true;\r\n}\r\nif (changed &\r\n(BSS_CHANGED_ASSOC |\r\nBSS_CHANGED_BSSID |\r\nBSS_CHANGED_IBSS |\r\nBSS_CHANGED_BASIC_RATES |\r\nBSS_CHANGED_HT)) {\r\npr_debug("BSS_CHANGED_ASSOC\n");\r\nif (info->assoc) {\r\nif (priv->join_status < CW1200_JOIN_STATUS_PRE_STA) {\r\nieee80211_connection_loss(vif);\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn;\r\n} else if (priv->join_status == CW1200_JOIN_STATUS_PRE_STA) {\r\npriv->join_status = CW1200_JOIN_STATUS_STA;\r\n}\r\n} else {\r\ndo_join = true;\r\n}\r\nif (info->assoc || info->ibss_joined) {\r\nstruct ieee80211_sta *sta = NULL;\r\n__le32 htprot = 0;\r\nif (info->dtim_period)\r\npriv->join_dtim_period = info->dtim_period;\r\npriv->beacon_int = info->beacon_int;\r\nrcu_read_lock();\r\nif (info->bssid && !info->ibss_joined)\r\nsta = ieee80211_find_sta(vif, info->bssid);\r\nif (sta) {\r\npriv->ht_info.ht_cap = sta->ht_cap;\r\npriv->bss_params.operational_rate_set =\r\ncw1200_rate_mask_to_wsm(priv,\r\nsta->supp_rates[priv->channel->band]);\r\npriv->ht_info.channel_type = cfg80211_get_chandef_type(&dev->conf.chandef);\r\npriv->ht_info.operation_mode = info->ht_operation_mode;\r\n} else {\r\nmemset(&priv->ht_info, 0,\r\nsizeof(priv->ht_info));\r\npriv->bss_params.operational_rate_set = -1;\r\n}\r\nrcu_read_unlock();\r\nif (priv->ht_info.operation_mode &\r\nIEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)\r\nhtprot |= cpu_to_le32(WSM_NON_GREENFIELD_STA_PRESENT);\r\nhtprot |= cpu_to_le32((priv->ht_info.operation_mode & IEEE80211_HT_OP_MODE_PROTECTION) << 2);\r\nwsm_write_mib(priv, WSM_MIB_ID_SET_HT_PROTECTION,\r\n&htprot, sizeof(htprot));\r\npriv->association_mode.greenfield =\r\ncw1200_ht_greenfield(&priv->ht_info);\r\npriv->association_mode.flags =\r\nWSM_ASSOCIATION_MODE_SNOOP_ASSOC_FRAMES |\r\nWSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE |\r\nWSM_ASSOCIATION_MODE_USE_HT_MODE |\r\nWSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET |\r\nWSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING;\r\npriv->association_mode.preamble =\r\ninfo->use_short_preamble ?\r\nWSM_JOIN_PREAMBLE_SHORT :\r\nWSM_JOIN_PREAMBLE_LONG;\r\npriv->association_mode.basic_rate_set = __cpu_to_le32(\r\ncw1200_rate_mask_to_wsm(priv,\r\ninfo->basic_rates));\r\npriv->association_mode.mpdu_start_spacing =\r\ncw1200_ht_ampdu_density(&priv->ht_info);\r\ncw1200_cqm_bssloss_sm(priv, 0, 0, 0);\r\ncancel_work_sync(&priv->unjoin_work);\r\npriv->bss_params.beacon_lost_count = priv->cqm_beacon_loss_count;\r\npriv->bss_params.aid = info->aid;\r\nif (priv->join_dtim_period < 1)\r\npriv->join_dtim_period = 1;\r\npr_debug("[STA] DTIM %d, interval: %d\n",\r\npriv->join_dtim_period, priv->beacon_int);\r\npr_debug("[STA] Preamble: %d, Greenfield: %d, Aid: %d, Rates: 0x%.8X, Basic: 0x%.8X\n",\r\npriv->association_mode.preamble,\r\npriv->association_mode.greenfield,\r\npriv->bss_params.aid,\r\npriv->bss_params.operational_rate_set,\r\npriv->association_mode.basic_rate_set);\r\nwsm_set_association_mode(priv, &priv->association_mode);\r\nif (!info->ibss_joined) {\r\nwsm_keep_alive_period(priv, 30 );\r\nwsm_set_bss_params(priv, &priv->bss_params);\r\npriv->setbssparams_done = true;\r\ncw1200_set_beacon_wakeup_period_work(&priv->set_beacon_wakeup_period_work);\r\ncw1200_set_pm(priv, &priv->powersave_mode);\r\n}\r\nif (priv->vif->p2p) {\r\npr_debug("[STA] Setting p2p powersave configuration.\n");\r\nwsm_set_p2p_ps_modeinfo(priv,\r\n&priv->p2p_ps_modeinfo);\r\n}\r\nif (priv->bt_present)\r\ncw1200_set_btcoexinfo(priv);\r\n} else {\r\nmemset(&priv->association_mode, 0,\r\nsizeof(priv->association_mode));\r\nmemset(&priv->bss_params, 0, sizeof(priv->bss_params));\r\n}\r\n}\r\nif (changed & (BSS_CHANGED_ASSOC |\r\nBSS_CHANGED_ERP_CTS_PROT |\r\nBSS_CHANGED_ERP_PREAMBLE)) {\r\nu32 prev_erp_info = priv->erp_info;\r\nif (info->use_cts_prot)\r\npriv->erp_info |= WLAN_ERP_USE_PROTECTION;\r\nelse if (!(prev_erp_info & WLAN_ERP_NON_ERP_PRESENT))\r\npriv->erp_info &= ~WLAN_ERP_USE_PROTECTION;\r\nif (info->use_short_preamble)\r\npriv->erp_info |= WLAN_ERP_BARKER_PREAMBLE;\r\nelse\r\npriv->erp_info &= ~WLAN_ERP_BARKER_PREAMBLE;\r\npr_debug("[STA] ERP Protection: %x\n", priv->erp_info);\r\nif (prev_erp_info != priv->erp_info)\r\nqueue_work(priv->workqueue, &priv->set_cts_work);\r\n}\r\nif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_SLOT)) {\r\n__le32 slot_time = info->use_short_slot ?\r\n__cpu_to_le32(9) : __cpu_to_le32(20);\r\npr_debug("[STA] Slot time: %d us.\n",\r\n__le32_to_cpu(slot_time));\r\nwsm_write_mib(priv, WSM_MIB_ID_DOT11_SLOT_TIME,\r\n&slot_time, sizeof(slot_time));\r\n}\r\nif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_CQM)) {\r\nstruct wsm_rcpi_rssi_threshold threshold = {\r\n.rollingAverageCount = 8,\r\n};\r\npr_debug("[CQM] RSSI threshold subscribe: %d +- %d\n",\r\ninfo->cqm_rssi_thold, info->cqm_rssi_hyst);\r\npriv->cqm_rssi_thold = info->cqm_rssi_thold;\r\npriv->cqm_rssi_hyst = info->cqm_rssi_hyst;\r\nif (info->cqm_rssi_thold || info->cqm_rssi_hyst) {\r\nif (priv->cqm_use_rssi) {\r\nthreshold.upperThreshold =\r\ninfo->cqm_rssi_thold + info->cqm_rssi_hyst;\r\nthreshold.lowerThreshold =\r\ninfo->cqm_rssi_thold;\r\nthreshold.rssiRcpiMode |= WSM_RCPI_RSSI_USE_RSSI;\r\n} else {\r\nthreshold.upperThreshold = (info->cqm_rssi_thold + info->cqm_rssi_hyst + 110) * 2;\r\nthreshold.lowerThreshold = (info->cqm_rssi_thold + 110) * 2;\r\n}\r\nthreshold.rssiRcpiMode |= WSM_RCPI_RSSI_THRESHOLD_ENABLE;\r\n} else {\r\nthreshold.rssiRcpiMode |=\r\nWSM_RCPI_RSSI_THRESHOLD_ENABLE |\r\nWSM_RCPI_RSSI_DONT_USE_UPPER |\r\nWSM_RCPI_RSSI_DONT_USE_LOWER;\r\nif (priv->cqm_use_rssi)\r\nthreshold.rssiRcpiMode |= WSM_RCPI_RSSI_USE_RSSI;\r\n}\r\nwsm_set_rcpi_rssi_threshold(priv, &threshold);\r\n}\r\nmutex_unlock(&priv->conf_mutex);\r\nif (do_join) {\r\nwsm_lock_tx(priv);\r\ncw1200_do_join(priv);\r\n}\r\n}\r\nvoid cw1200_multicast_start_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, multicast_start_work);\r\nlong tmo = priv->join_dtim_period *\r\n(priv->beacon_int + 20) * HZ / 1024;\r\ncancel_work_sync(&priv->multicast_stop_work);\r\nif (!priv->aid0_bit_set) {\r\nwsm_lock_tx(priv);\r\ncw1200_set_tim_impl(priv, true);\r\npriv->aid0_bit_set = true;\r\nmod_timer(&priv->mcast_timeout, jiffies + tmo);\r\nwsm_unlock_tx(priv);\r\n}\r\n}\r\nvoid cw1200_multicast_stop_work(struct work_struct *work)\r\n{\r\nstruct cw1200_common *priv =\r\ncontainer_of(work, struct cw1200_common, multicast_stop_work);\r\nif (priv->aid0_bit_set) {\r\ndel_timer_sync(&priv->mcast_timeout);\r\nwsm_lock_tx(priv);\r\npriv->aid0_bit_set = false;\r\ncw1200_set_tim_impl(priv, false);\r\nwsm_unlock_tx(priv);\r\n}\r\n}\r\nvoid cw1200_mcast_timeout(unsigned long arg)\r\n{\r\nstruct cw1200_common *priv =\r\n(struct cw1200_common *)arg;\r\nwiphy_warn(priv->hw->wiphy,\r\n"Multicast delivery timeout.\n");\r\nspin_lock_bh(&priv->ps_state_lock);\r\npriv->tx_multicast = priv->aid0_bit_set &&\r\npriv->buffered_multicasts;\r\nif (priv->tx_multicast)\r\ncw1200_bh_wakeup(priv);\r\nspin_unlock_bh(&priv->ps_state_lock);\r\n}\r\nint cw1200_ampdu_action(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta, u16 tid, u16 *ssn,\r\nu8 buf_size)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nvoid cw1200_suspend_resume(struct cw1200_common *priv,\r\nstruct wsm_suspend_resume *arg)\r\n{\r\npr_debug("[AP] %s: %s\n",\r\narg->stop ? "stop" : "start",\r\narg->multicast ? "broadcast" : "unicast");\r\nif (arg->multicast) {\r\nbool cancel_tmo = false;\r\nspin_lock_bh(&priv->ps_state_lock);\r\nif (arg->stop) {\r\npriv->tx_multicast = false;\r\n} else {\r\ncw1200_pm_stay_awake(&priv->pm_state,\r\npriv->join_dtim_period *\r\n(priv->beacon_int + 20) * HZ / 1024);\r\npriv->tx_multicast = (priv->aid0_bit_set &&\r\npriv->buffered_multicasts);\r\nif (priv->tx_multicast) {\r\ncancel_tmo = true;\r\ncw1200_bh_wakeup(priv);\r\n}\r\n}\r\nspin_unlock_bh(&priv->ps_state_lock);\r\nif (cancel_tmo)\r\ndel_timer_sync(&priv->mcast_timeout);\r\n} else {\r\nspin_lock_bh(&priv->ps_state_lock);\r\ncw1200_ps_notify(priv, arg->link_id, arg->stop);\r\nspin_unlock_bh(&priv->ps_state_lock);\r\nif (!arg->stop)\r\ncw1200_bh_wakeup(priv);\r\n}\r\nreturn;\r\n}\r\nstatic int cw1200_upload_beacon(struct cw1200_common *priv)\r\n{\r\nint ret = 0;\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct wsm_template_frame frame = {\r\n.frame_type = WSM_FRAME_TYPE_BEACON,\r\n};\r\nu16 tim_offset;\r\nu16 tim_len;\r\nif (priv->mode == NL80211_IFTYPE_STATION ||\r\npriv->mode == NL80211_IFTYPE_MONITOR ||\r\npriv->mode == NL80211_IFTYPE_UNSPECIFIED)\r\ngoto done;\r\nif (priv->vif->p2p)\r\nframe.rate = WSM_TRANSMIT_RATE_6;\r\nframe.skb = ieee80211_beacon_get_tim(priv->hw, priv->vif,\r\n&tim_offset, &tim_len);\r\nif (!frame.skb)\r\nreturn -ENOMEM;\r\nret = wsm_set_template_frame(priv, &frame);\r\nif (ret)\r\ngoto done;\r\nmgmt = (void *)frame.skb->data;\r\nmgmt->frame_control =\r\n__cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_PROBE_RESP);\r\nframe.frame_type = WSM_FRAME_TYPE_PROBE_RESPONSE;\r\nif (priv->vif->p2p) {\r\nret = wsm_set_probe_responder(priv, true);\r\n} else {\r\nret = wsm_set_template_frame(priv, &frame);\r\nwsm_set_probe_responder(priv, false);\r\n}\r\ndone:\r\ndev_kfree_skb(frame.skb);\r\nreturn ret;\r\n}\r\nstatic int cw1200_upload_pspoll(struct cw1200_common *priv)\r\n{\r\nint ret = 0;\r\nstruct wsm_template_frame frame = {\r\n.frame_type = WSM_FRAME_TYPE_PS_POLL,\r\n.rate = 0xFF,\r\n};\r\nframe.skb = ieee80211_pspoll_get(priv->hw, priv->vif);\r\nif (!frame.skb)\r\nreturn -ENOMEM;\r\nret = wsm_set_template_frame(priv, &frame);\r\ndev_kfree_skb(frame.skb);\r\nreturn ret;\r\n}\r\nstatic int cw1200_upload_null(struct cw1200_common *priv)\r\n{\r\nint ret = 0;\r\nstruct wsm_template_frame frame = {\r\n.frame_type = WSM_FRAME_TYPE_NULL,\r\n.rate = 0xFF,\r\n};\r\nframe.skb = ieee80211_nullfunc_get(priv->hw, priv->vif);\r\nif (!frame.skb)\r\nreturn -ENOMEM;\r\nret = wsm_set_template_frame(priv, &frame);\r\ndev_kfree_skb(frame.skb);\r\nreturn ret;\r\n}\r\nstatic int cw1200_upload_qosnull(struct cw1200_common *priv)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cw1200_enable_beaconing(struct cw1200_common *priv,\r\nbool enable)\r\n{\r\nstruct wsm_beacon_transmit transmit = {\r\n.enable_beaconing = enable,\r\n};\r\nreturn wsm_beacon_transmit(priv, &transmit);\r\n}\r\nstatic int cw1200_start_ap(struct cw1200_common *priv)\r\n{\r\nint ret;\r\nstruct ieee80211_bss_conf *conf = &priv->vif->bss_conf;\r\nstruct wsm_start start = {\r\n.mode = priv->vif->p2p ?\r\nWSM_START_MODE_P2P_GO : WSM_START_MODE_AP,\r\n.band = (priv->channel->band == IEEE80211_BAND_5GHZ) ?\r\nWSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,\r\n.channel_number = priv->channel->hw_value,\r\n.beacon_interval = conf->beacon_int,\r\n.dtim_period = conf->dtim_period,\r\n.preamble = conf->use_short_preamble ?\r\nWSM_JOIN_PREAMBLE_SHORT :\r\nWSM_JOIN_PREAMBLE_LONG,\r\n.probe_delay = 100,\r\n.basic_rate_set = cw1200_rate_mask_to_wsm(priv,\r\nconf->basic_rates),\r\n};\r\nstruct wsm_operational_mode mode = {\r\n.power_mode = cw1200_power_mode,\r\n.disable_more_flag_usage = true,\r\n};\r\nmemset(start.ssid, 0, sizeof(start.ssid));\r\nif (!conf->hidden_ssid) {\r\nstart.ssid_len = conf->ssid_len;\r\nmemcpy(start.ssid, conf->ssid, start.ssid_len);\r\n}\r\npriv->beacon_int = conf->beacon_int;\r\npriv->join_dtim_period = conf->dtim_period;\r\nmemset(&priv->link_id_db, 0, sizeof(priv->link_id_db));\r\npr_debug("[AP] ch: %d(%d), bcn: %d(%d), brt: 0x%.8X, ssid: %.*s.\n",\r\nstart.channel_number, start.band,\r\nstart.beacon_interval, start.dtim_period,\r\nstart.basic_rate_set,\r\nstart.ssid_len, start.ssid);\r\nret = wsm_start(priv, &start);\r\nif (!ret)\r\nret = cw1200_upload_keys(priv);\r\nif (!ret && priv->vif->p2p) {\r\npr_debug("[AP] Setting p2p powersave configuration.\n");\r\nwsm_set_p2p_ps_modeinfo(priv, &priv->p2p_ps_modeinfo);\r\n}\r\nif (!ret) {\r\nwsm_set_block_ack_policy(priv, 0, 0);\r\npriv->join_status = CW1200_JOIN_STATUS_AP;\r\ncw1200_update_filtering(priv);\r\n}\r\nwsm_set_operational_mode(priv, &mode);\r\nreturn ret;\r\n}\r\nstatic int cw1200_update_beaconing(struct cw1200_common *priv)\r\n{\r\nstruct ieee80211_bss_conf *conf = &priv->vif->bss_conf;\r\nstruct wsm_reset reset = {\r\n.link_id = 0,\r\n.reset_statistics = true,\r\n};\r\nif (priv->mode == NL80211_IFTYPE_AP) {\r\nif (priv->join_status != CW1200_JOIN_STATUS_AP ||\r\npriv->beacon_int != conf->beacon_int) {\r\npr_debug("ap restarting\n");\r\nwsm_lock_tx(priv);\r\nif (priv->join_status != CW1200_JOIN_STATUS_PASSIVE)\r\nwsm_reset(priv, &reset);\r\npriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\r\ncw1200_start_ap(priv);\r\nwsm_unlock_tx(priv);\r\n} else\r\npr_debug("ap started join_status: %d\n",\r\npriv->join_status);\r\n}\r\nreturn 0;\r\n}
