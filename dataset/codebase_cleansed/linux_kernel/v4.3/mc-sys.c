int __must_check fsl_create_mc_io(struct device *dev,\r\nphys_addr_t mc_portal_phys_addr,\r\nuint32_t mc_portal_size,\r\nstruct fsl_mc_resource *resource,\r\nuint32_t flags, struct fsl_mc_io **new_mc_io)\r\n{\r\nstruct fsl_mc_io *mc_io;\r\nvoid __iomem *mc_portal_virt_addr;\r\nstruct resource *res;\r\nmc_io = devm_kzalloc(dev, sizeof(*mc_io), GFP_KERNEL);\r\nif (!mc_io)\r\nreturn -ENOMEM;\r\nmc_io->dev = dev;\r\nmc_io->flags = flags;\r\nmc_io->portal_phys_addr = mc_portal_phys_addr;\r\nmc_io->portal_size = mc_portal_size;\r\nmc_io->resource = resource;\r\nres = devm_request_mem_region(dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size,\r\n"mc_portal");\r\nif (!res) {\r\ndev_err(dev,\r\n"devm_request_mem_region failed for MC portal %#llx\n",\r\nmc_portal_phys_addr);\r\nreturn -EBUSY;\r\n}\r\nmc_portal_virt_addr = devm_ioremap_nocache(dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size);\r\nif (!mc_portal_virt_addr) {\r\ndev_err(dev,\r\n"devm_ioremap_nocache failed for MC portal %#llx\n",\r\nmc_portal_phys_addr);\r\nreturn -ENXIO;\r\n}\r\nmc_io->portal_virt_addr = mc_portal_virt_addr;\r\n*new_mc_io = mc_io;\r\nreturn 0;\r\n}\r\nvoid fsl_destroy_mc_io(struct fsl_mc_io *mc_io)\r\n{\r\ndevm_iounmap(mc_io->dev, mc_io->portal_virt_addr);\r\ndevm_release_mem_region(mc_io->dev,\r\nmc_io->portal_phys_addr,\r\nmc_io->portal_size);\r\nmc_io->portal_virt_addr = NULL;\r\ndevm_kfree(mc_io->dev, mc_io);\r\n}\r\nstatic int mc_status_to_error(enum mc_cmd_status status)\r\n{\r\nstatic const int mc_status_to_error_map[] = {\r\n[MC_CMD_STATUS_OK] = 0,\r\n[MC_CMD_STATUS_AUTH_ERR] = -EACCES,\r\n[MC_CMD_STATUS_NO_PRIVILEGE] = -EPERM,\r\n[MC_CMD_STATUS_DMA_ERR] = -EIO,\r\n[MC_CMD_STATUS_CONFIG_ERR] = -ENXIO,\r\n[MC_CMD_STATUS_TIMEOUT] = -ETIMEDOUT,\r\n[MC_CMD_STATUS_NO_RESOURCE] = -ENAVAIL,\r\n[MC_CMD_STATUS_NO_MEMORY] = -ENOMEM,\r\n[MC_CMD_STATUS_BUSY] = -EBUSY,\r\n[MC_CMD_STATUS_UNSUPPORTED_OP] = -ENOTSUPP,\r\n[MC_CMD_STATUS_INVALID_STATE] = -ENODEV,\r\n};\r\nif (WARN_ON((u32)status >= ARRAY_SIZE(mc_status_to_error_map)))\r\nreturn -EINVAL;\r\nreturn mc_status_to_error_map[status];\r\n}\r\nstatic const char *mc_status_to_string(enum mc_cmd_status status)\r\n{\r\nstatic const char *const status_strings[] = {\r\n[MC_CMD_STATUS_OK] = "Command completed successfully",\r\n[MC_CMD_STATUS_READY] = "Command ready to be processed",\r\n[MC_CMD_STATUS_AUTH_ERR] = "Authentication error",\r\n[MC_CMD_STATUS_NO_PRIVILEGE] = "No privilege",\r\n[MC_CMD_STATUS_DMA_ERR] = "DMA or I/O error",\r\n[MC_CMD_STATUS_CONFIG_ERR] = "Configuration error",\r\n[MC_CMD_STATUS_TIMEOUT] = "Operation timed out",\r\n[MC_CMD_STATUS_NO_RESOURCE] = "No resources",\r\n[MC_CMD_STATUS_NO_MEMORY] = "No memory available",\r\n[MC_CMD_STATUS_BUSY] = "Device is busy",\r\n[MC_CMD_STATUS_UNSUPPORTED_OP] = "Unsupported operation",\r\n[MC_CMD_STATUS_INVALID_STATE] = "Invalid state"\r\n};\r\nif ((unsigned int)status >= ARRAY_SIZE(status_strings))\r\nreturn "Unknown MC error";\r\nreturn status_strings[status];\r\n}\r\nstatic inline void mc_write_command(struct mc_command __iomem *portal,\r\nstruct mc_command *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\r\nwriteq(cmd->params[i], &portal->params[i]);\r\nwriteq(cmd->header, &portal->header);\r\n}\r\nstatic inline enum mc_cmd_status mc_read_response(struct mc_command __iomem *\r\nportal,\r\nstruct mc_command *resp)\r\n{\r\nint i;\r\nenum mc_cmd_status status;\r\nresp->header = readq(&portal->header);\r\nstatus = MC_CMD_HDR_READ_STATUS(resp->header);\r\nif (status != MC_CMD_STATUS_OK)\r\nreturn status;\r\nfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\r\nresp->params[i] = readq(&portal->params[i]);\r\nreturn status;\r\n}\r\nint mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)\r\n{\r\nenum mc_cmd_status status;\r\nunsigned long jiffies_until_timeout =\r\njiffies + MC_CMD_COMPLETION_TIMEOUT_JIFFIES;\r\nmc_write_command(mc_io->portal_virt_addr, cmd);\r\nfor (;;) {\r\nstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\r\nif (status != MC_CMD_STATUS_READY)\r\nbreak;\r\nusleep_range(MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS,\r\nMC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\r\nif (time_after_eq(jiffies, jiffies_until_timeout)) {\r\npr_debug("MC command timed out (portal: %#llx, obj handle: %#x, command: %#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)\r\nMC_CMD_HDR_READ_TOKEN(cmd->header),\r\n(unsigned int)\r\nMC_CMD_HDR_READ_CMDID(cmd->header));\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nif (status != MC_CMD_STATUS_OK) {\r\npr_debug("MC command failed: portal: %#llx, obj handle: %#x, command: %#x, status: %s (%#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)MC_CMD_HDR_READ_TOKEN(cmd->header),\r\n(unsigned int)MC_CMD_HDR_READ_CMDID(cmd->header),\r\nmc_status_to_string(status),\r\n(unsigned int)status);\r\nreturn mc_status_to_error(status);\r\n}\r\nreturn 0;\r\n}
