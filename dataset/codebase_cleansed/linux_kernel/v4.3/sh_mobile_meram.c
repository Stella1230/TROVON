static inline void meram_write_icb(void __iomem *base, unsigned int idx,\r\nunsigned int off, unsigned long val)\r\n{\r\niowrite32(val, MERAM_ICB_OFFSET(base, idx, off));\r\n}\r\nstatic inline unsigned long meram_read_icb(void __iomem *base, unsigned int idx,\r\nunsigned int off)\r\n{\r\nreturn ioread32(MERAM_ICB_OFFSET(base, idx, off));\r\n}\r\nstatic inline void meram_write_reg(void __iomem *base, unsigned int off,\r\nunsigned long val)\r\n{\r\niowrite32(val, base + off);\r\n}\r\nstatic inline unsigned long meram_read_reg(void __iomem *base, unsigned int off)\r\n{\r\nreturn ioread32(base + off);\r\n}\r\nstatic unsigned long meram_alloc(struct sh_mobile_meram_priv *priv, size_t size)\r\n{\r\nreturn gen_pool_alloc(priv->pool, size);\r\n}\r\nstatic void meram_free(struct sh_mobile_meram_priv *priv, unsigned long mem,\r\nsize_t size)\r\n{\r\ngen_pool_free(priv->pool, mem, size);\r\n}\r\nstatic int meram_plane_alloc(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_fb_plane *plane,\r\nsize_t size)\r\n{\r\nunsigned long mem;\r\nunsigned long idx;\r\nidx = find_first_zero_bit(&priv->used_icb, 28);\r\nif (idx == 28)\r\nreturn -ENOMEM;\r\nplane->cache = &priv->icbs[idx];\r\nidx = find_next_zero_bit(&priv->used_icb, 32, 28);\r\nif (idx == 32)\r\nreturn -ENOMEM;\r\nplane->marker = &priv->icbs[idx];\r\nmem = meram_alloc(priv, size * 1024);\r\nif (mem == 0)\r\nreturn -ENOMEM;\r\n__set_bit(plane->marker->index, &priv->used_icb);\r\n__set_bit(plane->cache->index, &priv->used_icb);\r\nplane->marker->offset = mem - priv->meram;\r\nplane->marker->size = size;\r\nreturn 0;\r\n}\r\nstatic void meram_plane_free(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_fb_plane *plane)\r\n{\r\nmeram_free(priv, priv->meram + plane->marker->offset,\r\nplane->marker->size * 1024);\r\n__clear_bit(plane->marker->index, &priv->used_icb);\r\n__clear_bit(plane->cache->index, &priv->used_icb);\r\n}\r\nstatic int is_nvcolor(int cspace)\r\n{\r\nif (cspace == SH_MOBILE_MERAM_PF_NV ||\r\ncspace == SH_MOBILE_MERAM_PF_NV24)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void meram_set_next_addr(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_fb_cache *cache,\r\nunsigned long base_addr_y,\r\nunsigned long base_addr_c)\r\n{\r\nstruct sh_mobile_meram_icb *icb = cache->planes[0].marker;\r\nunsigned long target;\r\nicb->current_reg ^= 1;\r\ntarget = icb->current_reg ? MExxSARB : MExxSARA;\r\nmeram_write_icb(priv->base, cache->planes[0].cache->index, target,\r\nbase_addr_y);\r\nmeram_write_icb(priv->base, cache->planes[0].marker->index, target,\r\nbase_addr_y + cache->planes[0].marker->cache_unit);\r\nif (cache->nplanes == 2) {\r\nmeram_write_icb(priv->base, cache->planes[1].cache->index,\r\ntarget, base_addr_c);\r\nmeram_write_icb(priv->base, cache->planes[1].marker->index,\r\ntarget, base_addr_c +\r\ncache->planes[1].marker->cache_unit);\r\n}\r\n}\r\nstatic void\r\nmeram_get_next_icb_addr(struct sh_mobile_meram_info *pdata,\r\nstruct sh_mobile_meram_fb_cache *cache,\r\nunsigned long *icb_addr_y, unsigned long *icb_addr_c)\r\n{\r\nstruct sh_mobile_meram_icb *icb = cache->planes[0].marker;\r\nunsigned long icb_offset;\r\nif (pdata->addr_mode == SH_MOBILE_MERAM_MODE0)\r\nicb_offset = 0x80000000 | (icb->current_reg << 29);\r\nelse\r\nicb_offset = 0xc0000000 | (icb->current_reg << 23);\r\n*icb_addr_y = icb_offset | (cache->planes[0].marker->index << 24);\r\nif (cache->nplanes == 2)\r\n*icb_addr_c = icb_offset\r\n| (cache->planes[1].marker->index << 24);\r\n}\r\nstatic int meram_plane_init(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_fb_plane *plane,\r\nunsigned int xres, unsigned int yres,\r\nunsigned int *out_pitch)\r\n{\r\nstruct sh_mobile_meram_icb *marker = plane->marker;\r\nunsigned long total_byte_count = MERAM_CALC_BYTECOUNT(xres, yres);\r\nunsigned long bnm;\r\nunsigned int lcdc_pitch;\r\nunsigned int xpitch;\r\nunsigned int line_cnt;\r\nunsigned int save_lines;\r\nlcdc_pitch = (xres - 1) | 1023;\r\nlcdc_pitch = lcdc_pitch | (lcdc_pitch >> 1);\r\nlcdc_pitch = lcdc_pitch | (lcdc_pitch >> 2);\r\nlcdc_pitch += 1;\r\nif (lcdc_pitch == 8192 && yres >= 1024) {\r\nlcdc_pitch = xpitch = MERAM_LINE_WIDTH;\r\nline_cnt = total_byte_count >> 11;\r\n*out_pitch = xres;\r\nsave_lines = plane->marker->size / 16 / MERAM_SEC_LINE;\r\nsave_lines *= MERAM_SEC_LINE;\r\n} else {\r\nxpitch = xres;\r\nline_cnt = yres;\r\n*out_pitch = lcdc_pitch;\r\nsave_lines = plane->marker->size / (lcdc_pitch >> 10) / 2;\r\nsave_lines &= 0xff;\r\n}\r\nbnm = (save_lines - 1) << 16;\r\nmeram_write_icb(priv->base, plane->cache->index, MExxBSIZE,\r\nMERAM_MExxBSIZE_VAL(0x0, line_cnt - 1, xpitch - 1));\r\nmeram_write_icb(priv->base, plane->marker->index, MExxBSIZE,\r\nMERAM_MExxBSIZE_VAL(0xf, line_cnt - 1, xpitch - 1));\r\nmeram_write_icb(priv->base, plane->cache->index, MExxMNCF, bnm);\r\nmeram_write_icb(priv->base, plane->marker->index, MExxMNCF, bnm);\r\nmeram_write_icb(priv->base, plane->cache->index, MExxSBSIZE, xpitch);\r\nmeram_write_icb(priv->base, plane->marker->index, MExxSBSIZE, xpitch);\r\nplane->cache->cache_unit = xres * save_lines;\r\nplane->marker->cache_unit = xres * save_lines;\r\nmeram_write_icb(priv->base, plane->cache->index, MExxCTL,\r\nMERAM_MExxCTL_VAL(plane->marker->index, marker->offset)\r\n| MExxCTL_WD1 | MExxCTL_WD0 | MExxCTL_WS | MExxCTL_CM |\r\nMExxCTL_MD_FB);\r\nmeram_write_icb(priv->base, plane->marker->index, MExxCTL,\r\nMERAM_MExxCTL_VAL(plane->cache->index, marker->offset +\r\nplane->marker->size / 2) |\r\nMExxCTL_WD1 | MExxCTL_WD0 | MExxCTL_WS | MExxCTL_CM |\r\nMExxCTL_MD_FB);\r\nreturn 0;\r\n}\r\nstatic void meram_plane_cleanup(struct sh_mobile_meram_priv *priv,\r\nstruct sh_mobile_meram_fb_plane *plane)\r\n{\r\nmeram_write_icb(priv->base, plane->cache->index, MExxCTL,\r\nMExxCTL_WBF | MExxCTL_WF | MExxCTL_RF);\r\nmeram_write_icb(priv->base, plane->marker->index, MExxCTL,\r\nMExxCTL_WBF | MExxCTL_WF | MExxCTL_RF);\r\nplane->cache->cache_unit = 0;\r\nplane->marker->cache_unit = 0;\r\n}\r\nunsigned long sh_mobile_meram_alloc(struct sh_mobile_meram_info *pdata,\r\nsize_t size)\r\n{\r\nstruct sh_mobile_meram_priv *priv = pdata->priv;\r\nreturn meram_alloc(priv, size);\r\n}\r\nvoid sh_mobile_meram_free(struct sh_mobile_meram_info *pdata, unsigned long mem,\r\nsize_t size)\r\n{\r\nstruct sh_mobile_meram_priv *priv = pdata->priv;\r\nmeram_free(priv, mem, size);\r\n}\r\nstatic struct sh_mobile_meram_fb_cache *\r\nmeram_cache_alloc(struct sh_mobile_meram_priv *priv,\r\nconst struct sh_mobile_meram_cfg *cfg,\r\nint pixelformat)\r\n{\r\nunsigned int nplanes = is_nvcolor(pixelformat) ? 2 : 1;\r\nstruct sh_mobile_meram_fb_cache *cache;\r\nint ret;\r\ncache = kzalloc(sizeof(*cache), GFP_KERNEL);\r\nif (cache == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ncache->nplanes = nplanes;\r\nret = meram_plane_alloc(priv, &cache->planes[0],\r\ncfg->icb[0].meram_size);\r\nif (ret < 0)\r\ngoto error;\r\ncache->planes[0].marker->current_reg = 1;\r\ncache->planes[0].marker->pixelformat = pixelformat;\r\nif (cache->nplanes == 1)\r\nreturn cache;\r\nret = meram_plane_alloc(priv, &cache->planes[1],\r\ncfg->icb[1].meram_size);\r\nif (ret < 0) {\r\nmeram_plane_free(priv, &cache->planes[0]);\r\ngoto error;\r\n}\r\nreturn cache;\r\nerror:\r\nkfree(cache);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid *sh_mobile_meram_cache_alloc(struct sh_mobile_meram_info *pdata,\r\nconst struct sh_mobile_meram_cfg *cfg,\r\nunsigned int xres, unsigned int yres,\r\nunsigned int pixelformat, unsigned int *pitch)\r\n{\r\nstruct sh_mobile_meram_fb_cache *cache;\r\nstruct sh_mobile_meram_priv *priv = pdata->priv;\r\nstruct platform_device *pdev = pdata->pdev;\r\nunsigned int nplanes = is_nvcolor(pixelformat) ? 2 : 1;\r\nunsigned int out_pitch;\r\nif (priv == NULL)\r\nreturn ERR_PTR(-ENODEV);\r\nif (pixelformat != SH_MOBILE_MERAM_PF_NV &&\r\npixelformat != SH_MOBILE_MERAM_PF_NV24 &&\r\npixelformat != SH_MOBILE_MERAM_PF_RGB)\r\nreturn ERR_PTR(-EINVAL);\r\ndev_dbg(&pdev->dev, "registering %dx%d (%s)", xres, yres,\r\n!pixelformat ? "yuv" : "rgb");\r\nif (xres > 8192) {\r\ndev_err(&pdev->dev, "width exceeding the limit (> 8192).");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (cfg->icb[0].meram_size == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (nplanes == 2 && cfg->icb[1].meram_size == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nmutex_lock(&priv->lock);\r\ncache = meram_cache_alloc(priv, cfg, pixelformat);\r\nif (IS_ERR(cache)) {\r\ndev_err(&pdev->dev, "MERAM allocation failed (%ld).",\r\nPTR_ERR(cache));\r\ngoto err;\r\n}\r\nmeram_plane_init(priv, &cache->planes[0], xres, yres, &out_pitch);\r\n*pitch = out_pitch;\r\nif (pixelformat == SH_MOBILE_MERAM_PF_NV)\r\nmeram_plane_init(priv, &cache->planes[1],\r\nxres, (yres + 1) / 2, &out_pitch);\r\nelse if (pixelformat == SH_MOBILE_MERAM_PF_NV24)\r\nmeram_plane_init(priv, &cache->planes[1],\r\n2 * xres, (yres + 1) / 2, &out_pitch);\r\nerr:\r\nmutex_unlock(&priv->lock);\r\nreturn cache;\r\n}\r\nvoid\r\nsh_mobile_meram_cache_free(struct sh_mobile_meram_info *pdata, void *data)\r\n{\r\nstruct sh_mobile_meram_fb_cache *cache = data;\r\nstruct sh_mobile_meram_priv *priv = pdata->priv;\r\nmutex_lock(&priv->lock);\r\nmeram_plane_cleanup(priv, &cache->planes[0]);\r\nmeram_plane_free(priv, &cache->planes[0]);\r\nif (cache->nplanes == 2) {\r\nmeram_plane_cleanup(priv, &cache->planes[1]);\r\nmeram_plane_free(priv, &cache->planes[1]);\r\n}\r\nkfree(cache);\r\nmutex_unlock(&priv->lock);\r\n}\r\nvoid\r\nsh_mobile_meram_cache_update(struct sh_mobile_meram_info *pdata, void *data,\r\nunsigned long base_addr_y,\r\nunsigned long base_addr_c,\r\nunsigned long *icb_addr_y,\r\nunsigned long *icb_addr_c)\r\n{\r\nstruct sh_mobile_meram_fb_cache *cache = data;\r\nstruct sh_mobile_meram_priv *priv = pdata->priv;\r\nmutex_lock(&priv->lock);\r\nmeram_set_next_addr(priv, cache, base_addr_y, base_addr_c);\r\nmeram_get_next_icb_addr(pdata, cache, icb_addr_y, icb_addr_c);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int sh_mobile_meram_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_mobile_meram_priv *priv = platform_get_drvdata(pdev);\r\nunsigned int i, j;\r\nfor (i = 0; i < MERAM_REGS_SIZE; i++)\r\npriv->regs[i] = meram_read_reg(priv->base, common_regs[i]);\r\nfor (i = 0; i < 32; i++) {\r\nif (!test_bit(i, &priv->used_icb))\r\ncontinue;\r\nfor (j = 0; j < ICB_REGS_SIZE; j++) {\r\npriv->icbs[i].regs[j] =\r\nmeram_read_icb(priv->base, i, icb_regs[j]);\r\nif (icb_regs[j] == MExxCTL)\r\npriv->icbs[i].regs[j] |=\r\nMExxCTL_WBF | MExxCTL_WF | MExxCTL_RF;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_meram_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct sh_mobile_meram_priv *priv = platform_get_drvdata(pdev);\r\nunsigned int i, j;\r\nfor (i = 0; i < 32; i++) {\r\nif (!test_bit(i, &priv->used_icb))\r\ncontinue;\r\nfor (j = 0; j < ICB_REGS_SIZE; j++)\r\nmeram_write_icb(priv->base, i, icb_regs[j],\r\npriv->icbs[i].regs[j]);\r\n}\r\nfor (i = 0; i < MERAM_REGS_SIZE; i++)\r\nmeram_write_reg(priv->base, common_regs[i], priv->regs[i]);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_meram_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_meram_priv *priv;\r\nstruct sh_mobile_meram_info *pdata = pdev->dev.platform_data;\r\nstruct resource *regs;\r\nstruct resource *meram;\r\nunsigned int i;\r\nint error;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmeram = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (regs == NULL || meram == NULL) {\r\ndev_err(&pdev->dev, "cannot get platform resources\n");\r\nreturn -ENOENT;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "cannot allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&priv->lock);\r\npriv->used_icb = pdata->reserved_icbs;\r\nfor (i = 0; i < MERAM_ICB_NUM; ++i)\r\npriv->icbs[i].index = i;\r\npdata->priv = priv;\r\npdata->pdev = pdev;\r\nif (!request_mem_region(regs->start, resource_size(regs), pdev->name)) {\r\ndev_err(&pdev->dev, "MERAM registers region already claimed\n");\r\nerror = -EBUSY;\r\ngoto err_req_regs;\r\n}\r\nif (!request_mem_region(meram->start, resource_size(meram),\r\npdev->name)) {\r\ndev_err(&pdev->dev, "MERAM memory region already claimed\n");\r\nerror = -EBUSY;\r\ngoto err_req_meram;\r\n}\r\npriv->base = ioremap_nocache(regs->start, resource_size(regs));\r\nif (!priv->base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nerror = -EFAULT;\r\ngoto err_ioremap;\r\n}\r\npriv->meram = meram->start;\r\npriv->pool = gen_pool_create(ilog2(MERAM_GRANULARITY), -1);\r\nif (priv->pool == NULL) {\r\nerror = -ENOMEM;\r\ngoto err_genpool;\r\n}\r\nerror = gen_pool_add(priv->pool, meram->start, resource_size(meram),\r\n-1);\r\nif (error < 0)\r\ngoto err_genpool;\r\nif (pdata->addr_mode == SH_MOBILE_MERAM_MODE1)\r\nmeram_write_reg(priv->base, MEVCR1, MEVCR1_AMD1);\r\nplatform_set_drvdata(pdev, priv);\r\npm_runtime_enable(&pdev->dev);\r\ndev_info(&pdev->dev, "sh_mobile_meram initialized.");\r\nreturn 0;\r\nerr_genpool:\r\nif (priv->pool)\r\ngen_pool_destroy(priv->pool);\r\niounmap(priv->base);\r\nerr_ioremap:\r\nrelease_mem_region(meram->start, resource_size(meram));\r\nerr_req_meram:\r\nrelease_mem_region(regs->start, resource_size(regs));\r\nerr_req_regs:\r\nmutex_destroy(&priv->lock);\r\nkfree(priv);\r\nreturn error;\r\n}\r\nstatic int sh_mobile_meram_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_meram_priv *priv = platform_get_drvdata(pdev);\r\nstruct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *meram = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npm_runtime_disable(&pdev->dev);\r\ngen_pool_destroy(priv->pool);\r\niounmap(priv->base);\r\nrelease_mem_region(meram->start, resource_size(meram));\r\nrelease_mem_region(regs->start, resource_size(regs));\r\nmutex_destroy(&priv->lock);\r\nkfree(priv);\r\nreturn 0;\r\n}
