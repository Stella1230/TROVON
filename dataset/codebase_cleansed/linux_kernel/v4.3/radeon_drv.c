static inline void radeon_register_atpx_handler(void) {}\r\nstatic inline void radeon_unregister_atpx_handler(void) {}\r\nstatic int radeon_suspend(struct drm_device *dev, pm_message_t state)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nreturn 0;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_RS600)\r\nRADEON_WRITE(R500_DxMODE_INT_MASK, 0);\r\nRADEON_WRITE(RADEON_GEN_INT_CNTL, 0);\r\nreturn 0;\r\n}\r\nstatic int radeon_resume(struct drm_device *dev)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_R600)\r\nreturn 0;\r\nif ((dev_priv->flags & RADEON_FAMILY_MASK) >= CHIP_RS600)\r\nRADEON_WRITE(R500_DxMODE_INT_MASK, dev_priv->r500_disp_irq_reg);\r\nRADEON_WRITE(RADEON_GEN_INT_CNTL, dev_priv->irq_enable_reg);\r\nreturn 0;\r\n}\r\nstatic int radeon_kick_out_firmware_fb(struct pci_dev *pdev)\r\n{\r\nstruct apertures_struct *ap;\r\nbool primary = false;\r\nap = alloc_apertures(1);\r\nif (!ap)\r\nreturn -ENOMEM;\r\nap->ranges[0].base = pci_resource_start(pdev, 0);\r\nap->ranges[0].size = pci_resource_len(pdev, 0);\r\n#ifdef CONFIG_X86\r\nprimary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;\r\n#endif\r\nremove_conflicting_framebuffers(ap, "radeondrmfb", primary);\r\nkfree(ap);\r\nreturn 0;\r\n}\r\nstatic int radeon_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\nret = radeon_kick_out_firmware_fb(pdev);\r\nif (ret)\r\nreturn ret;\r\nreturn drm_get_pci_dev(pdev, ent, &kms_driver);\r\n}\r\nstatic void\r\nradeon_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\ndrm_put_dev(dev);\r\n}\r\nstatic int radeon_pmops_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nreturn radeon_suspend_kms(drm_dev, true, true);\r\n}\r\nstatic int radeon_pmops_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nreturn radeon_resume_kms(drm_dev, true, true);\r\n}\r\nstatic int radeon_pmops_freeze(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nreturn radeon_suspend_kms(drm_dev, false, true);\r\n}\r\nstatic int radeon_pmops_thaw(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nreturn radeon_resume_kms(drm_dev, false, true);\r\n}\r\nstatic int radeon_pmops_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nint ret;\r\nif (!radeon_is_px(drm_dev)) {\r\npm_runtime_forbid(dev);\r\nreturn -EBUSY;\r\n}\r\ndrm_dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\r\ndrm_kms_helper_poll_disable(drm_dev);\r\nvga_switcheroo_set_dynamic_switch(pdev, VGA_SWITCHEROO_OFF);\r\nret = radeon_suspend_kms(drm_dev, false, false);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_ignore_hotplug(pdev);\r\npci_set_power_state(pdev, PCI_D3cold);\r\ndrm_dev->switch_power_state = DRM_SWITCH_POWER_DYNAMIC_OFF;\r\nreturn 0;\r\n}\r\nstatic int radeon_pmops_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nint ret;\r\nif (!radeon_is_px(drm_dev))\r\nreturn -EINVAL;\r\ndrm_dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pdev);\r\nret = radeon_resume_kms(drm_dev, false, false);\r\ndrm_kms_helper_poll_enable(drm_dev);\r\nvga_switcheroo_set_dynamic_switch(pdev, VGA_SWITCHEROO_ON);\r\ndrm_dev->switch_power_state = DRM_SWITCH_POWER_ON;\r\nreturn 0;\r\n}\r\nstatic int radeon_pmops_runtime_idle(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct drm_device *drm_dev = pci_get_drvdata(pdev);\r\nstruct drm_crtc *crtc;\r\nif (!radeon_is_px(drm_dev)) {\r\npm_runtime_forbid(dev);\r\nreturn -EBUSY;\r\n}\r\nlist_for_each_entry(crtc, &drm_dev->mode_config.crtc_list, head) {\r\nif (crtc->enabled) {\r\nDRM_DEBUG_DRIVER("failing to power off - crtc active\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_autosuspend(dev);\r\nreturn 1;\r\n}\r\nlong radeon_drm_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev;\r\nlong ret;\r\ndev = file_priv->minor->dev;\r\nret = pm_runtime_get_sync(dev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drm_ioctl(filp, cmd, arg);\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn ret;\r\n}\r\nstatic int __init radeon_init(void)\r\n{\r\n#ifdef CONFIG_VGA_CONSOLE\r\nif (vgacon_text_force() && radeon_modeset == -1) {\r\nDRM_INFO("VGACON disable radeon kernel modesetting.\n");\r\nradeon_modeset = 0;\r\n}\r\n#endif\r\nif (radeon_modeset == -1)\r\nradeon_modeset = 1;\r\nif (radeon_modeset == 1) {\r\nDRM_INFO("radeon kernel modesetting enabled.\n");\r\ndriver = &kms_driver;\r\npdriver = &radeon_kms_pci_driver;\r\ndriver->driver_features |= DRIVER_MODESET;\r\ndriver->num_ioctls = radeon_max_kms_ioctl;\r\nradeon_register_atpx_handler();\r\n} else {\r\n#ifdef CONFIG_DRM_RADEON_UMS\r\nDRM_INFO("radeon userspace modesetting enabled.\n");\r\ndriver = &driver_old;\r\npdriver = &radeon_pci_driver;\r\ndriver->driver_features &= ~DRIVER_MODESET;\r\ndriver->num_ioctls = radeon_max_ioctl;\r\n#else\r\nDRM_ERROR("No UMS support in radeon module!\n");\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nradeon_kfd_init();\r\nreturn drm_pci_init(driver, pdriver);\r\n}\r\nstatic void __exit radeon_exit(void)\r\n{\r\nradeon_kfd_fini();\r\ndrm_pci_exit(driver, pdriver);\r\nradeon_unregister_atpx_handler();\r\n}
