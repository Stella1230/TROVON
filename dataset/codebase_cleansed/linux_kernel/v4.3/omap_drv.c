static void omap_fb_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nDBG("dev=%p", dev);\r\nif (priv->fbdev)\r\ndrm_fb_helper_hotplug_event(priv->fbdev);\r\n}\r\nstatic void omap_atomic_wait_for_completion(struct drm_device *dev,\r\nstruct drm_atomic_state *old_state)\r\n{\r\nstruct drm_crtc_state *old_crtc_state;\r\nstruct drm_crtc *crtc;\r\nunsigned int i;\r\nint ret;\r\nfor_each_crtc_in_state(old_state, crtc, old_crtc_state, i) {\r\nif (!crtc->state->enable)\r\ncontinue;\r\nret = omap_crtc_wait_pending(crtc);\r\nif (!ret)\r\ndev_warn(dev->dev,\r\n"atomic complete timeout (pipe %u)!\n", i);\r\n}\r\n}\r\nstatic void omap_atomic_complete(struct omap_atomic_state_commit *commit)\r\n{\r\nstruct drm_device *dev = commit->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_atomic_state *old_state = commit->state;\r\ndispc_runtime_get();\r\ndrm_atomic_helper_commit_modeset_disables(dev, old_state);\r\ndrm_atomic_helper_commit_planes(dev, old_state);\r\ndrm_atomic_helper_commit_modeset_enables(dev, old_state);\r\nomap_atomic_wait_for_completion(dev, old_state);\r\ndrm_atomic_helper_cleanup_planes(dev, old_state);\r\ndispc_runtime_put();\r\ndrm_atomic_state_free(old_state);\r\nspin_lock(&priv->commit.lock);\r\npriv->commit.pending &= ~commit->crtcs;\r\nspin_unlock(&priv->commit.lock);\r\nwake_up_all(&priv->commit.wait);\r\nkfree(commit);\r\n}\r\nstatic void omap_atomic_work(struct work_struct *work)\r\n{\r\nstruct omap_atomic_state_commit *commit =\r\ncontainer_of(work, struct omap_atomic_state_commit, work);\r\nomap_atomic_complete(commit);\r\n}\r\nstatic bool omap_atomic_is_pending(struct omap_drm_private *priv,\r\nstruct omap_atomic_state_commit *commit)\r\n{\r\nbool pending;\r\nspin_lock(&priv->commit.lock);\r\npending = priv->commit.pending & commit->crtcs;\r\nspin_unlock(&priv->commit.lock);\r\nreturn pending;\r\n}\r\nstatic int omap_atomic_commit(struct drm_device *dev,\r\nstruct drm_atomic_state *state, bool async)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_atomic_state_commit *commit;\r\nunsigned long flags;\r\nunsigned int i;\r\nint ret;\r\nret = drm_atomic_helper_prepare_planes(dev, state);\r\nif (ret)\r\nreturn ret;\r\ncommit = kzalloc(sizeof(*commit), GFP_KERNEL);\r\nif (commit == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nINIT_WORK(&commit->work, omap_atomic_work);\r\ncommit->dev = dev;\r\ncommit->state = state;\r\nfor (i = 0; i < dev->mode_config.num_crtc; ++i) {\r\nif (state->crtcs[i])\r\ncommit->crtcs |= 1 << drm_crtc_index(state->crtcs[i]);\r\n}\r\nwait_event(priv->commit.wait, !omap_atomic_is_pending(priv, commit));\r\nspin_lock(&priv->commit.lock);\r\npriv->commit.pending |= commit->crtcs;\r\nspin_unlock(&priv->commit.lock);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nfor (i = 0; i < dev->mode_config.num_crtc; ++i) {\r\nstruct drm_crtc_state *cstate = state->crtc_states[i];\r\nif (cstate && cstate->event)\r\nlist_add_tail(&cstate->event->base.link,\r\n&priv->commit.events);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ndrm_atomic_helper_swap_state(dev, state);\r\nif (async)\r\nschedule_work(&commit->work);\r\nelse\r\nomap_atomic_complete(commit);\r\nreturn 0;\r\nerror:\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\nreturn ret;\r\n}\r\nstatic int get_connector_type(struct omap_dss_device *dssdev)\r\n{\r\nswitch (dssdev->type) {\r\ncase OMAP_DISPLAY_TYPE_HDMI:\r\nreturn DRM_MODE_CONNECTOR_HDMIA;\r\ncase OMAP_DISPLAY_TYPE_DVI:\r\nreturn DRM_MODE_CONNECTOR_DVID;\r\ndefault:\r\nreturn DRM_MODE_CONNECTOR_Unknown;\r\n}\r\n}\r\nstatic bool channel_used(struct drm_device *dev, enum omap_channel channel)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nint i;\r\nfor (i = 0; i < priv->num_crtcs; i++) {\r\nstruct drm_crtc *crtc = priv->crtcs[i];\r\nif (omap_crtc_channel(crtc) == channel)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void omap_disconnect_dssdevs(void)\r\n{\r\nstruct omap_dss_device *dssdev = NULL;\r\nfor_each_dss_dev(dssdev)\r\ndssdev->driver->disconnect(dssdev);\r\n}\r\nstatic int omap_connect_dssdevs(void)\r\n{\r\nint r;\r\nstruct omap_dss_device *dssdev = NULL;\r\nbool no_displays = true;\r\nfor_each_dss_dev(dssdev) {\r\nr = dssdev->driver->connect(dssdev);\r\nif (r == -EPROBE_DEFER) {\r\nomap_dss_put_device(dssdev);\r\ngoto cleanup;\r\n} else if (r) {\r\ndev_warn(dssdev->dev, "could not connect display: %s\n",\r\ndssdev->name);\r\n} else {\r\nno_displays = false;\r\n}\r\n}\r\nif (no_displays)\r\nreturn -EPROBE_DEFER;\r\nreturn 0;\r\ncleanup:\r\nomap_disconnect_dssdevs();\r\nreturn r;\r\n}\r\nstatic int omap_modeset_create_crtc(struct drm_device *dev, int id,\r\nenum omap_channel channel)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_plane *plane;\r\nstruct drm_crtc *crtc;\r\nplane = omap_plane_init(dev, id, DRM_PLANE_TYPE_PRIMARY);\r\nif (IS_ERR(plane))\r\nreturn PTR_ERR(plane);\r\ncrtc = omap_crtc_init(dev, plane, channel, id);\r\nBUG_ON(priv->num_crtcs >= ARRAY_SIZE(priv->crtcs));\r\npriv->crtcs[id] = crtc;\r\npriv->num_crtcs++;\r\npriv->planes[id] = plane;\r\npriv->num_planes++;\r\nreturn 0;\r\n}\r\nstatic int omap_modeset_init_properties(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nif (priv->has_dmm) {\r\ndev->mode_config.rotation_property =\r\ndrm_mode_create_rotation_property(dev,\r\nBIT(DRM_ROTATE_0) | BIT(DRM_ROTATE_90) |\r\nBIT(DRM_ROTATE_180) | BIT(DRM_ROTATE_270) |\r\nBIT(DRM_REFLECT_X) | BIT(DRM_REFLECT_Y));\r\nif (!dev->mode_config.rotation_property)\r\nreturn -ENOMEM;\r\n}\r\npriv->zorder_prop = drm_property_create_range(dev, 0, "zorder", 0, 3);\r\nif (!priv->zorder_prop)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int omap_modeset_init(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct omap_dss_device *dssdev = NULL;\r\nint num_ovls = dss_feat_get_num_ovls();\r\nint num_mgrs = dss_feat_get_num_mgrs();\r\nint num_crtcs;\r\nint i, id = 0;\r\nint ret;\r\ndrm_mode_config_init(dev);\r\nomap_drm_irq_install(dev);\r\nret = omap_modeset_init_properties(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nnum_crtcs = min3(num_crtc, num_mgrs, num_ovls);\r\ndssdev = NULL;\r\nfor_each_dss_dev(dssdev) {\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nenum omap_channel channel;\r\nstruct omap_overlay_manager *mgr;\r\nif (!omapdss_device_is_connected(dssdev))\r\ncontinue;\r\nencoder = omap_encoder_init(dev, dssdev);\r\nif (!encoder) {\r\ndev_err(dev->dev, "could not create encoder: %s\n",\r\ndssdev->name);\r\nreturn -ENOMEM;\r\n}\r\nconnector = omap_connector_init(dev,\r\nget_connector_type(dssdev), dssdev, encoder);\r\nif (!connector) {\r\ndev_err(dev->dev, "could not create connector: %s\n",\r\ndssdev->name);\r\nreturn -ENOMEM;\r\n}\r\nBUG_ON(priv->num_encoders >= ARRAY_SIZE(priv->encoders));\r\nBUG_ON(priv->num_connectors >= ARRAY_SIZE(priv->connectors));\r\npriv->encoders[priv->num_encoders++] = encoder;\r\npriv->connectors[priv->num_connectors++] = connector;\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nif (id == num_crtcs)\r\ncontinue;\r\nmgr = omapdss_find_mgr_from_display(dssdev);\r\nchannel = mgr->id;\r\nif (!channel_used(dev, channel)) {\r\nret = omap_modeset_create_crtc(dev, id, channel);\r\nif (ret < 0) {\r\ndev_err(dev->dev,\r\n"could not create CRTC (channel %u)\n",\r\nchannel);\r\nreturn ret;\r\n}\r\nid++;\r\n}\r\n}\r\nfor (; id < num_crtcs; id++) {\r\nfor (i = 0; i < num_mgrs; i++) {\r\nif (!channel_used(dev, i))\r\nbreak;\r\n}\r\nif (i == num_mgrs) {\r\ndev_err(dev->dev, "no managers left for crtc\n");\r\nreturn -ENOMEM;\r\n}\r\nret = omap_modeset_create_crtc(dev, id, i);\r\nif (ret < 0) {\r\ndev_err(dev->dev,\r\n"could not create CRTC (channel %u)\n", i);\r\nreturn ret;\r\n}\r\n}\r\nfor (; id < num_ovls; id++) {\r\nstruct drm_plane *plane;\r\nplane = omap_plane_init(dev, id, DRM_PLANE_TYPE_OVERLAY);\r\nif (IS_ERR(plane))\r\nreturn PTR_ERR(plane);\r\nBUG_ON(priv->num_planes >= ARRAY_SIZE(priv->planes));\r\npriv->planes[priv->num_planes++] = plane;\r\n}\r\nfor (i = 0; i < priv->num_encoders; i++) {\r\nstruct drm_encoder *encoder = priv->encoders[i];\r\nstruct omap_dss_device *dssdev =\r\nomap_encoder_get_dssdev(encoder);\r\nstruct omap_dss_device *output;\r\noutput = omapdss_find_output_from_display(dssdev);\r\nencoder->possible_crtcs = 0;\r\nfor (id = 0; id < priv->num_crtcs; id++) {\r\nstruct drm_crtc *crtc = priv->crtcs[id];\r\nenum omap_channel crtc_channel;\r\ncrtc_channel = omap_crtc_channel(crtc);\r\nif (output->dispc_channel == crtc_channel) {\r\nencoder->possible_crtcs |= (1 << id);\r\nbreak;\r\n}\r\n}\r\nomap_dss_put_device(output);\r\n}\r\nDBG("registered %d planes, %d crtcs, %d encoders and %d connectors\n",\r\npriv->num_planes, priv->num_crtcs, priv->num_encoders,\r\npriv->num_connectors);\r\ndev->mode_config.min_width = 32;\r\ndev->mode_config.min_height = 32;\r\ndev->mode_config.max_width = 2048;\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.funcs = &omap_mode_config_funcs;\r\ndrm_mode_config_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void omap_modeset_free(struct drm_device *dev)\r\n{\r\ndrm_mode_config_cleanup(dev);\r\n}\r\nstatic int ioctl_get_param(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_omap_param *args = data;\r\nDBG("%p: param=%llu", dev, args->param);\r\nswitch (args->param) {\r\ncase OMAP_PARAM_CHIPSET_ID:\r\nargs->value = priv->omaprev;\r\nbreak;\r\ndefault:\r\nDBG("unknown parameter %lld", args->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioctl_set_param(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_param *args = data;\r\nswitch (args->param) {\r\ndefault:\r\nDBG("unknown parameter %lld", args->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioctl_gem_new(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_new *args = data;\r\nVERB("%p:%p: size=0x%08x, flags=%08x", dev, file_priv,\r\nargs->size.bytes, args->flags);\r\nreturn omap_gem_new_handle(dev, file_priv, args->size,\r\nargs->flags, &args->handle);\r\n}\r\nstatic int ioctl_gem_cpu_prep(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_cpu_prep *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nVERB("%p:%p: handle=%d, op=%x", dev, file_priv, args->handle, args->op);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nret = omap_gem_op_sync(obj, args->op);\r\nif (!ret)\r\nret = omap_gem_op_start(obj, args->op);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int ioctl_gem_cpu_fini(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_cpu_fini *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nVERB("%p:%p: handle=%d", dev, file_priv, args->handle);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nret = 0;\r\nif (!ret)\r\nret = omap_gem_op_finish(obj, args->op);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int ioctl_gem_info(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_omap_gem_info *args = data;\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nVERB("%p:%p: handle=%d", dev, file_priv, args->handle);\r\nobj = drm_gem_object_lookup(dev, file_priv, args->handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nargs->size = omap_gem_mmap_size(obj);\r\nargs->offset = omap_gem_mmap_offset(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int dev_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct omap_drm_platform_data *pdata = dev->dev->platform_data;\r\nstruct omap_drm_private *priv;\r\nunsigned int i;\r\nint ret;\r\nDBG("load: dev=%p", dev);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->omaprev = pdata->omaprev;\r\ndev->dev_private = priv;\r\npriv->wq = alloc_ordered_workqueue("omapdrm", 0);\r\ninit_waitqueue_head(&priv->commit.wait);\r\nspin_lock_init(&priv->commit.lock);\r\nINIT_LIST_HEAD(&priv->commit.events);\r\nspin_lock_init(&priv->list_lock);\r\nINIT_LIST_HEAD(&priv->obj_list);\r\nomap_gem_init(dev);\r\nret = omap_modeset_init(dev);\r\nif (ret) {\r\ndev_err(dev->dev, "omap_modeset_init failed: ret=%d\n", ret);\r\ndev->dev_private = NULL;\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nret = drm_vblank_init(dev, priv->num_crtcs);\r\nif (ret)\r\ndev_warn(dev->dev, "could not init vblank\n");\r\nfor (i = 0; i < priv->num_crtcs; i++)\r\ndrm_crtc_vblank_off(priv->crtcs[i]);\r\npriv->fbdev = omap_fbdev_init(dev);\r\nif (!priv->fbdev) {\r\ndev_warn(dev->dev, "omap_fbdev_init failed\n");\r\n}\r\ndev_set_drvdata(dev->dev, dev);\r\ndrm_kms_helper_poll_init(dev);\r\nreturn 0;\r\n}\r\nstatic int dev_unload(struct drm_device *dev)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nDBG("unload: dev=%p", dev);\r\ndrm_kms_helper_poll_fini(dev);\r\nif (priv->fbdev)\r\nomap_fbdev_free(dev);\r\nomap_modeset_free(dev);\r\nomap_gem_deinit(dev);\r\ndestroy_workqueue(priv->wq);\r\ndrm_vblank_cleanup(dev);\r\nomap_drm_irq_uninstall(dev);\r\nkfree(dev->dev_private);\r\ndev->dev_private = NULL;\r\ndev_set_drvdata(dev->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int dev_open(struct drm_device *dev, struct drm_file *file)\r\n{\r\nfile->driver_priv = NULL;\r\nDBG("open: dev=%p, file=%p", dev, file);\r\nreturn 0;\r\n}\r\nstatic void dev_lastclose(struct drm_device *dev)\r\n{\r\nint i;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nint ret;\r\nDBG("lastclose: dev=%p", dev);\r\nif (dev->mode_config.rotation_property) {\r\nfor (i = 0; i < priv->num_crtcs; i++) {\r\ndrm_object_property_set_value(&priv->crtcs[i]->base,\r\ndev->mode_config.rotation_property, 0);\r\n}\r\nfor (i = 0; i < priv->num_planes; i++) {\r\ndrm_object_property_set_value(&priv->planes[i]->base,\r\ndev->mode_config.rotation_property, 0);\r\n}\r\n}\r\nif (priv->fbdev) {\r\nret = drm_fb_helper_restore_fbdev_mode_unlocked(priv->fbdev);\r\nif (ret)\r\nDBG("failed to restore crtc mode");\r\n}\r\n}\r\nstatic void dev_preclose(struct drm_device *dev, struct drm_file *file)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_pending_event *event;\r\nunsigned long flags;\r\nDBG("preclose: dev=%p", dev);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry(event, &priv->commit.events, link) {\r\nif (event->file_priv == file) {\r\nfile->event_space += event->event->length;\r\nevent->file_priv = NULL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void dev_postclose(struct drm_device *dev, struct drm_file *file)\r\n{\r\nDBG("postclose: dev=%p, file=%p", dev, file);\r\n}\r\nstatic int pdev_probe(struct platform_device *device)\r\n{\r\nint r;\r\nif (omapdss_is_initialized() == false)\r\nreturn -EPROBE_DEFER;\r\nomap_crtc_pre_init();\r\nr = omap_connect_dssdevs();\r\nif (r) {\r\nomap_crtc_pre_uninit();\r\nreturn r;\r\n}\r\nDBG("%s", device->name);\r\nreturn drm_platform_init(&omap_drm_driver, device);\r\n}\r\nstatic int pdev_remove(struct platform_device *device)\r\n{\r\nDBG("");\r\ndrm_put_dev(platform_get_drvdata(device));\r\nomap_disconnect_dssdevs();\r\nomap_crtc_pre_uninit();\r\nreturn 0;\r\n}\r\nstatic int omap_drm_suspend(struct device *dev)\r\n{\r\nstruct drm_device *drm_dev = dev_get_drvdata(dev);\r\ndrm_kms_helper_poll_disable(drm_dev);\r\nreturn 0;\r\n}\r\nstatic int omap_drm_resume(struct device *dev)\r\n{\r\nstruct drm_device *drm_dev = dev_get_drvdata(dev);\r\ndrm_kms_helper_poll_enable(drm_dev);\r\nreturn omap_gem_resume(dev);\r\n}\r\nstatic int __init omap_drm_init(void)\r\n{\r\nint r;\r\nDBG("init");\r\nr = platform_driver_register(&omap_dmm_driver);\r\nif (r) {\r\npr_err("DMM driver registration failed\n");\r\nreturn r;\r\n}\r\nr = platform_driver_register(&pdev);\r\nif (r) {\r\npr_err("omapdrm driver registration failed\n");\r\nplatform_driver_unregister(&omap_dmm_driver);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit omap_drm_fini(void)\r\n{\r\nDBG("fini");\r\nplatform_driver_unregister(&pdev);\r\nplatform_driver_unregister(&omap_dmm_driver);\r\n}
