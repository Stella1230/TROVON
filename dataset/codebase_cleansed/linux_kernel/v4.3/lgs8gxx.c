static int lgs8gxx_write_reg(struct lgs8gxx_state *priv, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .flags = 0, .buf = buf, .len = 2 };\r\nmsg.addr = priv->config->demod_address;\r\nif (priv->config->prod != LGS8GXX_PROD_LGS8G75 && reg >= 0xC0)\r\nmsg.addr += 0x02;\r\nif (debug >= 2)\r\ndprintk("%s: reg=0x%02X, data=0x%02X\n", __func__, reg, data);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret != 1)\r\ndprintk("%s: error reg=0x%x, data=0x%x, ret=%i\n",\r\n__func__, reg, data, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int lgs8gxx_read_reg(struct lgs8gxx_state *priv, u8 reg, u8 *p_data)\r\n{\r\nint ret;\r\nu8 dev_addr;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .flags = 0, .buf = b0, .len = 1 },\r\n{ .flags = I2C_M_RD, .buf = b1, .len = 1 },\r\n};\r\ndev_addr = priv->config->demod_address;\r\nif (priv->config->prod != LGS8GXX_PROD_LGS8G75 && reg >= 0xC0)\r\ndev_addr += 0x02;\r\nmsg[1].addr = msg[0].addr = dev_addr;\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret != 2) {\r\ndprintk("%s: error reg=0x%x, ret=%i\n", __func__, reg, ret);\r\nreturn -1;\r\n}\r\n*p_data = b1[0];\r\nif (debug >= 2)\r\ndprintk("%s: reg=0x%02X, data=0x%02X\n", __func__, reg, b1[0]);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_soft_reset(struct lgs8gxx_state *priv)\r\n{\r\nlgs8gxx_write_reg(priv, 0x02, 0x00);\r\nmsleep(1);\r\nlgs8gxx_write_reg(priv, 0x02, 0x01);\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int wait_reg_mask(struct lgs8gxx_state *priv, u8 reg, u8 mask,\r\nu8 val, u8 delay, u8 tries)\r\n{\r\nu8 t;\r\nint i;\r\nfor (i = 0; i < tries; i++) {\r\nlgs8gxx_read_reg(priv, reg, &t);\r\nif ((t & mask) == val)\r\nreturn 0;\r\nmsleep(delay);\r\n}\r\nreturn 1;\r\n}\r\nstatic int lgs8gxx_set_ad_mode(struct lgs8gxx_state *priv)\r\n{\r\nconst struct lgs8gxx_config *config = priv->config;\r\nu8 if_conf;\r\nif_conf = 0x10;\r\nif_conf |=\r\n((config->ext_adc) ? 0x80 : 0x00) |\r\n((config->if_neg_center) ? 0x04 : 0x00) |\r\n((config->if_freq == 0) ? 0x08 : 0x00) |\r\n((config->adc_signed) ? 0x02 : 0x00) |\r\n((config->if_neg_edge) ? 0x01 : 0x00);\r\nif (config->ext_adc &&\r\n(config->prod == LGS8GXX_PROD_LGS8G52)) {\r\nlgs8gxx_write_reg(priv, 0xBA, 0x40);\r\n}\r\nlgs8gxx_write_reg(priv, 0x07, if_conf);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_set_if_freq(struct lgs8gxx_state *priv, u32 freq )\r\n{\r\nu64 val;\r\nu32 v32;\r\nu32 if_clk;\r\nif_clk = priv->config->if_clk_freq;\r\nval = freq;\r\nif (freq != 0) {\r\nval <<= 32;\r\nif (if_clk != 0)\r\ndo_div(val, if_clk);\r\nv32 = val & 0xFFFFFFFF;\r\ndprintk("Set IF Freq to %dkHz\n", freq);\r\n} else {\r\nv32 = 0;\r\ndprintk("Set IF Freq to baseband\n");\r\n}\r\ndprintk("AFC_INIT_FREQ = 0x%08X\n", v32);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_write_reg(priv, 0x08, 0xFF & (v32));\r\nlgs8gxx_write_reg(priv, 0x09, 0xFF & (v32 >> 8));\r\nlgs8gxx_write_reg(priv, 0x0A, 0xFF & (v32 >> 16));\r\nlgs8gxx_write_reg(priv, 0x0B, 0xFF & (v32 >> 24));\r\n} else {\r\nlgs8gxx_write_reg(priv, 0x09, 0xFF & (v32));\r\nlgs8gxx_write_reg(priv, 0x0A, 0xFF & (v32 >> 8));\r\nlgs8gxx_write_reg(priv, 0x0B, 0xFF & (v32 >> 16));\r\nlgs8gxx_write_reg(priv, 0x0C, 0xFF & (v32 >> 24));\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_get_afc_phase(struct lgs8gxx_state *priv)\r\n{\r\nu64 val;\r\nu32 v32 = 0;\r\nu8 reg_addr, t;\r\nint i;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\r\nreg_addr = 0x23;\r\nelse\r\nreg_addr = 0x48;\r\nfor (i = 0; i < 4; i++) {\r\nlgs8gxx_read_reg(priv, reg_addr, &t);\r\nv32 <<= 8;\r\nv32 |= t;\r\nreg_addr--;\r\n}\r\nval = v32;\r\nval *= priv->config->if_clk_freq;\r\nval >>= 32;\r\ndprintk("AFC = %u kHz\n", (u32)val);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_set_mode_auto(struct lgs8gxx_state *priv)\r\n{\r\nu8 t;\r\nu8 prod = priv->config->prod;\r\nif (prod == LGS8GXX_PROD_LGS8913)\r\nlgs8gxx_write_reg(priv, 0xC6, 0x01);\r\nif (prod == LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_read_reg(priv, 0x0C, &t);\r\nt &= (~0x04);\r\nlgs8gxx_write_reg(priv, 0x0C, t | 0x80);\r\nlgs8gxx_write_reg(priv, 0x39, 0x00);\r\nlgs8gxx_write_reg(priv, 0x3D, 0x04);\r\n} else if (prod == LGS8GXX_PROD_LGS8913 ||\r\nprod == LGS8GXX_PROD_LGS8GL5 ||\r\nprod == LGS8GXX_PROD_LGS8G42 ||\r\nprod == LGS8GXX_PROD_LGS8G52 ||\r\nprod == LGS8GXX_PROD_LGS8G54) {\r\nlgs8gxx_read_reg(priv, 0x7E, &t);\r\nlgs8gxx_write_reg(priv, 0x7E, t | 0x01);\r\nlgs8gxx_read_reg(priv, 0xC5, &t);\r\nlgs8gxx_write_reg(priv, 0xC5, t & 0xE0);\r\n}\r\nif (prod == LGS8GXX_PROD_LGS8913) {\r\nlgs8gxx_write_reg(priv, 0xC1, 0x03);\r\nlgs8gxx_read_reg(priv, 0x7C, &t);\r\nt = (t & 0x8C) | 0x03;\r\nlgs8gxx_write_reg(priv, 0x7C, t);\r\nlgs8gxx_read_reg(priv, 0xC3, &t);\r\nt = (t & 0xEF) | 0x10;\r\nlgs8gxx_write_reg(priv, 0xC3, t);\r\n}\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G52)\r\nlgs8gxx_write_reg(priv, 0xD9, 0x40);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_set_mode_manual(struct lgs8gxx_state *priv)\r\n{\r\nu8 t;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nu8 t2;\r\nlgs8gxx_read_reg(priv, 0x0C, &t);\r\nt &= (~0x80);\r\nlgs8gxx_write_reg(priv, 0x0C, t);\r\nlgs8gxx_read_reg(priv, 0x0C, &t);\r\nlgs8gxx_read_reg(priv, 0x19, &t2);\r\nif (((t&0x03) == 0x01) && (t2&0x01)) {\r\nlgs8gxx_write_reg(priv, 0x6E, 0x05);\r\nlgs8gxx_write_reg(priv, 0x39, 0x02);\r\nlgs8gxx_write_reg(priv, 0x39, 0x03);\r\nlgs8gxx_write_reg(priv, 0x3D, 0x05);\r\nlgs8gxx_write_reg(priv, 0x3E, 0x28);\r\nlgs8gxx_write_reg(priv, 0x53, 0x80);\r\n} else {\r\nlgs8gxx_write_reg(priv, 0x6E, 0x3F);\r\nlgs8gxx_write_reg(priv, 0x39, 0x00);\r\nlgs8gxx_write_reg(priv, 0x3D, 0x04);\r\n}\r\nlgs8gxx_soft_reset(priv);\r\nreturn 0;\r\n}\r\nlgs8gxx_write_reg(priv, 0x7E, 0);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8913)\r\nlgs8gxx_write_reg(priv, 0xC1, 0);\r\nlgs8gxx_read_reg(priv, 0xC5, &t);\r\nt = (t & 0xE0) | 0x06;\r\nlgs8gxx_write_reg(priv, 0xC5, t);\r\nlgs8gxx_soft_reset(priv);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_is_locked(struct lgs8gxx_state *priv, u8 *locked)\r\n{\r\nint ret = 0;\r\nu8 t;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\r\nret = lgs8gxx_read_reg(priv, 0x13, &t);\r\nelse\r\nret = lgs8gxx_read_reg(priv, 0x4B, &t);\r\nif (ret != 0)\r\nreturn ret;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\r\n*locked = ((t & 0x80) == 0x80) ? 1 : 0;\r\nelse\r\n*locked = ((t & 0xC0) == 0xC0) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_wait_ca_lock(struct lgs8gxx_state *priv, u8 *locked)\r\n{\r\nint ret = 0;\r\nu8 reg, mask, val;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nreg = 0x13;\r\nmask = 0x80;\r\nval = 0x80;\r\n} else {\r\nreg = 0x4B;\r\nmask = 0xC0;\r\nval = 0xC0;\r\n}\r\nret = wait_reg_mask(priv, reg, mask, val, 50, 40);\r\n*locked = (ret == 0) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_is_autodetect_finished(struct lgs8gxx_state *priv,\r\nu8 *finished)\r\n{\r\nint ret = 0;\r\nu8 reg, mask, val;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nreg = 0x1f;\r\nmask = 0xC0;\r\nval = 0x80;\r\n} else {\r\nreg = 0xA4;\r\nmask = 0x03;\r\nval = 0x01;\r\n}\r\nret = wait_reg_mask(priv, reg, mask, val, 10, 20);\r\n*finished = (ret == 0) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_autolock_gi(struct lgs8gxx_state *priv, u8 gi, u8 cpn,\r\nu8 *locked)\r\n{\r\nint err = 0;\r\nu8 ad_fini = 0;\r\nu8 t1, t2;\r\nif (gi == GI_945)\r\ndprintk("try GI 945\n");\r\nelse if (gi == GI_595)\r\ndprintk("try GI 595\n");\r\nelse if (gi == GI_420)\r\ndprintk("try GI 420\n");\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_read_reg(priv, 0x0C, &t1);\r\nlgs8gxx_read_reg(priv, 0x18, &t2);\r\nt1 &= ~(GI_MASK);\r\nt1 |= gi;\r\nt2 &= 0xFE;\r\nt2 |= cpn ? 0x01 : 0x00;\r\nlgs8gxx_write_reg(priv, 0x0C, t1);\r\nlgs8gxx_write_reg(priv, 0x18, t2);\r\n} else {\r\nlgs8gxx_write_reg(priv, 0x04, gi);\r\n}\r\nlgs8gxx_soft_reset(priv);\r\nerr = lgs8gxx_wait_ca_lock(priv, locked);\r\nif (err || !(*locked))\r\nreturn err;\r\nerr = lgs8gxx_is_autodetect_finished(priv, &ad_fini);\r\nif (err != 0)\r\nreturn err;\r\nif (ad_fini) {\r\ndprintk("auto detect finished\n");\r\n} else\r\n*locked = 0;\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_auto_detect(struct lgs8gxx_state *priv,\r\nu8 *detected_param, u8 *gi)\r\n{\r\nint i, j;\r\nint err = 0;\r\nu8 locked = 0, tmp_gi;\r\ndprintk("%s\n", __func__);\r\nlgs8gxx_set_mode_auto(priv);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_write_reg(priv, 0x67, 0xAA);\r\nlgs8gxx_write_reg(priv, 0x6E, 0x3F);\r\n} else {\r\nlgs8gxx_write_reg(priv, 0x03, 00);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nfor (j = 0; j < 2; j++) {\r\ntmp_gi = GI_945;\r\nerr = lgs8gxx_autolock_gi(priv, GI_945, j, &locked);\r\nif (err)\r\ngoto out;\r\nif (locked)\r\ngoto locked;\r\n}\r\nfor (j = 0; j < 2; j++) {\r\ntmp_gi = GI_420;\r\nerr = lgs8gxx_autolock_gi(priv, GI_420, j, &locked);\r\nif (err)\r\ngoto out;\r\nif (locked)\r\ngoto locked;\r\n}\r\ntmp_gi = GI_595;\r\nerr = lgs8gxx_autolock_gi(priv, GI_595, 1, &locked);\r\nif (err)\r\ngoto out;\r\nif (locked)\r\ngoto locked;\r\n}\r\nlocked:\r\nif ((err == 0) && (locked == 1)) {\r\nu8 t;\r\nif (priv->config->prod != LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_read_reg(priv, 0xA2, &t);\r\n*detected_param = t;\r\n} else {\r\nlgs8gxx_read_reg(priv, 0x1F, &t);\r\n*detected_param = t & 0x3F;\r\n}\r\nif (tmp_gi == GI_945)\r\ndprintk("GI 945 locked\n");\r\nelse if (tmp_gi == GI_595)\r\ndprintk("GI 595 locked\n");\r\nelse if (tmp_gi == GI_420)\r\ndprintk("GI 420 locked\n");\r\n*gi = tmp_gi;\r\n}\r\nif (!locked)\r\nerr = -1;\r\nout:\r\nreturn err;\r\n}\r\nstatic void lgs8gxx_auto_lock(struct lgs8gxx_state *priv)\r\n{\r\ns8 err;\r\nu8 gi = 0x2;\r\nu8 detected_param = 0;\r\nerr = lgs8gxx_auto_detect(priv, &detected_param, &gi);\r\nif (err != 0) {\r\ndprintk("lgs8gxx_auto_detect failed\n");\r\n} else\r\ndprintk("detected param = 0x%02X\n", detected_param);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8913) {\r\nu8 inter_leave_len = detected_param & TIM_MASK ;\r\ninter_leave_len = (inter_leave_len == TIM_MIDDLE) ? 0x60 : 0x40;\r\ndetected_param &= CF_MASK | SC_MASK | LGS_FEC_MASK;\r\ndetected_param |= inter_leave_len;\r\n}\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nu8 t;\r\nlgs8gxx_read_reg(priv, 0x19, &t);\r\nt &= 0x81;\r\nt |= detected_param << 1;\r\nlgs8gxx_write_reg(priv, 0x19, t);\r\n} else {\r\nlgs8gxx_write_reg(priv, 0x7D, detected_param);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8913)\r\nlgs8gxx_write_reg(priv, 0xC0, detected_param);\r\n}\r\nlgs8gxx_set_mode_manual(priv);\r\nswitch (gi) {\r\ncase GI_945:\r\npriv->curr_gi = 945; break;\r\ncase GI_595:\r\npriv->curr_gi = 595; break;\r\ncase GI_420:\r\npriv->curr_gi = 420; break;\r\ndefault:\r\npriv->curr_gi = 945; break;\r\n}\r\n}\r\nstatic int lgs8gxx_set_mpeg_mode(struct lgs8gxx_state *priv,\r\nu8 serial, u8 clk_pol, u8 clk_gated)\r\n{\r\nint ret = 0;\r\nu8 t, reg_addr;\r\nreg_addr = (priv->config->prod == LGS8GXX_PROD_LGS8G75) ? 0x30 : 0xC2;\r\nret = lgs8gxx_read_reg(priv, reg_addr, &t);\r\nif (ret != 0)\r\nreturn ret;\r\nt &= 0xF8;\r\nt |= serial ? TS_SERIAL : TS_PARALLEL;\r\nt |= clk_pol ? TS_CLK_INVERTED : TS_CLK_NORMAL;\r\nt |= clk_gated ? TS_CLK_GATED : TS_CLK_FREERUN;\r\nret = lgs8gxx_write_reg(priv, reg_addr, t);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int lgs8g75_set_adc_vpp(struct lgs8gxx_state *priv,\r\nu8 sel)\r\n{\r\nu8 r26 = 0x73, r27 = 0x90;\r\nif (priv->config->prod != LGS8GXX_PROD_LGS8G75)\r\nreturn 0;\r\nr26 |= (sel & 0x01) << 7;\r\nr27 |= (sel & 0x02) >> 1;\r\nlgs8gxx_write_reg(priv, 0x26, r26);\r\nlgs8gxx_write_reg(priv, 0x27, r27);\r\nreturn 0;\r\n}\r\nstatic int lgs8913_init(struct lgs8gxx_state *priv)\r\n{\r\nu8 t;\r\nlgs8gxx_write_reg(priv, 0xc1, 0x3);\r\nlgs8gxx_read_reg(priv, 0x7c, &t);\r\nlgs8gxx_write_reg(priv, 0x7c, (t&0x8c) | 0x3);\r\nlgs8gxx_read_reg(priv, 0xc3, &t);\r\nlgs8gxx_write_reg(priv, 0xc3, t&0x10);\r\nreturn 0;\r\n}\r\nstatic int lgs8g75_init_data(struct lgs8gxx_state *priv)\r\n{\r\nconst struct firmware *fw;\r\nint rc;\r\nint i;\r\nrc = request_firmware(&fw, LGS8GXX_FIRMWARE, &priv->i2c->dev);\r\nif (rc)\r\nreturn rc;\r\nlgs8gxx_write_reg(priv, 0xC6, 0x40);\r\nlgs8gxx_write_reg(priv, 0x3D, 0x04);\r\nlgs8gxx_write_reg(priv, 0x39, 0x00);\r\nlgs8gxx_write_reg(priv, 0x3A, 0x00);\r\nlgs8gxx_write_reg(priv, 0x38, 0x00);\r\nlgs8gxx_write_reg(priv, 0x3B, 0x00);\r\nlgs8gxx_write_reg(priv, 0x38, 0x00);\r\nfor (i = 0; i < fw->size; i++) {\r\nlgs8gxx_write_reg(priv, 0x38, 0x00);\r\nlgs8gxx_write_reg(priv, 0x3A, (u8)(i&0xff));\r\nlgs8gxx_write_reg(priv, 0x3B, (u8)(i>>8));\r\nlgs8gxx_write_reg(priv, 0x3C, fw->data[i]);\r\n}\r\nlgs8gxx_write_reg(priv, 0x38, 0x00);\r\nrelease_firmware(fw);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_init(struct dvb_frontend *fe)\r\n{\r\nstruct lgs8gxx_state *priv =\r\n(struct lgs8gxx_state *)fe->demodulator_priv;\r\nconst struct lgs8gxx_config *config = priv->config;\r\nu8 data = 0;\r\ns8 err;\r\ndprintk("%s\n", __func__);\r\nlgs8gxx_read_reg(priv, 0, &data);\r\ndprintk("reg 0 = 0x%02X\n", data);\r\nif (config->prod == LGS8GXX_PROD_LGS8G75)\r\nlgs8g75_set_adc_vpp(priv, config->adc_vpp);\r\nerr = lgs8gxx_set_mpeg_mode(priv, config->serial_ts,\r\nconfig->ts_clk_pol,\r\nconfig->ts_clk_gated);\r\nif (err != 0)\r\nreturn -EIO;\r\nif (config->prod == LGS8GXX_PROD_LGS8913)\r\nlgs8913_init(priv);\r\nlgs8gxx_set_if_freq(priv, priv->config->if_freq);\r\nlgs8gxx_set_ad_mode(priv);\r\nreturn 0;\r\n}\r\nstatic void lgs8gxx_release(struct dvb_frontend *fe)\r\n{\r\nstruct lgs8gxx_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nkfree(state);\r\n}\r\nstatic int lgs8gxx_write(struct dvb_frontend *fe, const u8 buf[], int len)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\nif (len != 2)\r\nreturn -EINVAL;\r\nreturn lgs8gxx_write_reg(priv, buf[0], buf[1]);\r\n}\r\nstatic int lgs8gxx_set_fe(struct dvb_frontend *fe)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nlgs8gxx_auto_lock(priv);\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_get_fe(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fe_params = &fe->dtv_property_cache;\r\ndprintk("%s\n", __func__);\r\nfe_params->inversion = INVERSION_OFF;\r\nfe_params->bandwidth_hz = 8000000;\r\nfe_params->code_rate_HP = FEC_AUTO;\r\nfe_params->code_rate_LP = FEC_AUTO;\r\nfe_params->modulation = QAM_AUTO;\r\nfe_params->transmission_mode = TRANSMISSION_MODE_AUTO;\r\nfe_params->guard_interval = GUARD_INTERVAL_AUTO;\r\nfe_params->hierarchy = HIERARCHY_NONE;\r\nreturn 0;\r\n}\r\nstatic\r\nint lgs8gxx_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 800;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_read_status(struct dvb_frontend *fe,\r\nenum fe_status *fe_status)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\ns8 ret;\r\nu8 t, locked = 0;\r\ndprintk("%s\n", __func__);\r\n*fe_status = 0;\r\nlgs8gxx_get_afc_phase(priv);\r\nlgs8gxx_is_locked(priv, &locked);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nif (locked)\r\n*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nret = lgs8gxx_read_reg(priv, 0x4B, &t);\r\nif (ret != 0)\r\nreturn -EIO;\r\ndprintk("Reg 0x4B: 0x%02X\n", t);\r\n*fe_status = 0;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8913) {\r\nif ((t & 0x40) == 0x40)\r\n*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nif ((t & 0x80) == 0x80)\r\n*fe_status |= FE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\n} else {\r\nif ((t & 0x80) == 0x80)\r\n*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n}\r\ndprintk("%s: fe_status=0x%x\n", __func__, *fe_status);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_read_signal_agc(struct lgs8gxx_state *priv, u16 *signal)\r\n{\r\nu16 v;\r\nu8 agc_lvl[2], cat;\r\ndprintk("%s()\n", __func__);\r\nlgs8gxx_read_reg(priv, 0x3F, &agc_lvl[0]);\r\nlgs8gxx_read_reg(priv, 0x3E, &agc_lvl[1]);\r\nv = agc_lvl[0];\r\nv <<= 8;\r\nv |= agc_lvl[1];\r\ndprintk("agc_lvl: 0x%04X\n", v);\r\nif (v < 0x100)\r\ncat = 0;\r\nelse if (v < 0x190)\r\ncat = 5;\r\nelse if (v < 0x2A8)\r\ncat = 4;\r\nelse if (v < 0x381)\r\ncat = 3;\r\nelse if (v < 0x400)\r\ncat = 2;\r\nelse if (v == 0x400)\r\ncat = 1;\r\nelse\r\ncat = 0;\r\n*signal = cat * 65535 / 5;\r\nreturn 0;\r\n}\r\nstatic int lgs8913_read_signal_strength(struct lgs8gxx_state *priv, u16 *signal)\r\n{\r\nu8 t; s8 ret;\r\ns16 max_strength = 0;\r\nu8 str;\r\nu16 i, gi = priv->curr_gi;\r\ndprintk("%s\n", __func__);\r\nret = lgs8gxx_read_reg(priv, 0x4B, &t);\r\nif (ret != 0)\r\nreturn -EIO;\r\nif (fake_signal_str) {\r\nif ((t & 0xC0) == 0xC0) {\r\ndprintk("Fake signal strength\n");\r\n*signal = 0x7FFF;\r\n} else\r\n*signal = 0;\r\nreturn 0;\r\n}\r\ndprintk("gi = %d\n", gi);\r\nfor (i = 0; i < gi; i++) {\r\nif ((i & 0xFF) == 0)\r\nlgs8gxx_write_reg(priv, 0x84, 0x03 & (i >> 8));\r\nlgs8gxx_write_reg(priv, 0x83, i & 0xFF);\r\nlgs8gxx_read_reg(priv, 0x94, &str);\r\nif (max_strength < str)\r\nmax_strength = str;\r\n}\r\n*signal = max_strength;\r\ndprintk("%s: signal=0x%02X\n", __func__, *signal);\r\nlgs8gxx_read_reg(priv, 0x95, &t);\r\ndprintk("%s: AVG Noise=0x%02X\n", __func__, t);\r\nreturn 0;\r\n}\r\nstatic int lgs8g75_read_signal_strength(struct lgs8gxx_state *priv, u16 *signal)\r\n{\r\nu8 t;\r\ns16 v = 0;\r\ndprintk("%s\n", __func__);\r\nlgs8gxx_read_reg(priv, 0xB1, &t);\r\nv |= t;\r\nv <<= 8;\r\nlgs8gxx_read_reg(priv, 0xB0, &t);\r\nv |= t;\r\n*signal = v;\r\ndprintk("%s: signal=0x%02X\n", __func__, *signal);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_read_signal_strength(struct dvb_frontend *fe, u16 *signal)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8913)\r\nreturn lgs8913_read_signal_strength(priv, signal);\r\nelse if (priv->config->prod == LGS8GXX_PROD_LGS8G75)\r\nreturn lgs8g75_read_signal_strength(priv, signal);\r\nelse\r\nreturn lgs8gxx_read_signal_agc(priv, signal);\r\n}\r\nstatic int lgs8gxx_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\nu8 t;\r\n*snr = 0;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75)\r\nlgs8gxx_read_reg(priv, 0x34, &t);\r\nelse\r\nlgs8gxx_read_reg(priv, 0x95, &t);\r\ndprintk("AVG Noise=0x%02X\n", t);\r\n*snr = 256 - t;\r\n*snr <<= 8;\r\ndprintk("snr=0x%x\n", *snr);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\n*ucblocks = 0;\r\ndprintk("%s: ucblocks=0x%x\n", __func__, *ucblocks);\r\nreturn 0;\r\n}\r\nstatic void packet_counter_start(struct lgs8gxx_state *priv)\r\n{\r\nu8 orig, t;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_read_reg(priv, 0x30, &orig);\r\norig &= 0xE7;\r\nt = orig | 0x10;\r\nlgs8gxx_write_reg(priv, 0x30, t);\r\nt = orig | 0x18;\r\nlgs8gxx_write_reg(priv, 0x30, t);\r\nt = orig | 0x10;\r\nlgs8gxx_write_reg(priv, 0x30, t);\r\n} else {\r\nlgs8gxx_write_reg(priv, 0xC6, 0x01);\r\nlgs8gxx_write_reg(priv, 0xC6, 0x41);\r\nlgs8gxx_write_reg(priv, 0xC6, 0x01);\r\n}\r\n}\r\nstatic void packet_counter_stop(struct lgs8gxx_state *priv)\r\n{\r\nu8 t;\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nlgs8gxx_read_reg(priv, 0x30, &t);\r\nt &= 0xE7;\r\nlgs8gxx_write_reg(priv, 0x30, t);\r\n} else {\r\nlgs8gxx_write_reg(priv, 0xC6, 0x81);\r\n}\r\n}\r\nstatic int lgs8gxx_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\nu8 reg_err, reg_total, t;\r\nu32 total_cnt = 0, err_cnt = 0;\r\nint i;\r\ndprintk("%s\n", __func__);\r\npacket_counter_start(priv);\r\nmsleep(200);\r\npacket_counter_stop(priv);\r\nif (priv->config->prod == LGS8GXX_PROD_LGS8G75) {\r\nreg_total = 0x28; reg_err = 0x2C;\r\n} else {\r\nreg_total = 0xD0; reg_err = 0xD4;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\ntotal_cnt <<= 8;\r\nlgs8gxx_read_reg(priv, reg_total+3-i, &t);\r\ntotal_cnt |= t;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nerr_cnt <<= 8;\r\nlgs8gxx_read_reg(priv, reg_err+3-i, &t);\r\nerr_cnt |= t;\r\n}\r\ndprintk("error=%d total=%d\n", err_cnt, total_cnt);\r\nif (total_cnt == 0)\r\n*ber = 0;\r\nelse\r\n*ber = err_cnt * 100 / total_cnt;\r\ndprintk("%s: ber=0x%x\n", __func__, *ber);\r\nreturn 0;\r\n}\r\nstatic int lgs8gxx_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct lgs8gxx_state *priv = fe->demodulator_priv;\r\nif (priv->config->tuner_address == 0)\r\nreturn 0;\r\nif (enable) {\r\nu8 v = 0x80 | priv->config->tuner_address;\r\nreturn lgs8gxx_write_reg(priv, 0x01, v);\r\n}\r\nreturn lgs8gxx_write_reg(priv, 0x01, 0);\r\n}\r\nstruct dvb_frontend *lgs8gxx_attach(const struct lgs8gxx_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct lgs8gxx_state *priv = NULL;\r\nu8 data = 0;\r\ndprintk("%s()\n", __func__);\r\nif (config == NULL || i2c == NULL)\r\nreturn NULL;\r\npriv = kzalloc(sizeof(struct lgs8gxx_state), GFP_KERNEL);\r\nif (priv == NULL)\r\ngoto error_out;\r\npriv->config = config;\r\npriv->i2c = i2c;\r\nif (lgs8gxx_read_reg(priv, 0, &data) != 0) {\r\ndprintk("%s lgs8gxx not found at i2c addr 0x%02X\n",\r\n__func__, priv->config->demod_address);\r\ngoto error_out;\r\n}\r\nlgs8gxx_read_reg(priv, 1, &data);\r\nmemcpy(&priv->frontend.ops, &lgs8gxx_ops,\r\nsizeof(struct dvb_frontend_ops));\r\npriv->frontend.demodulator_priv = priv;\r\nif (config->prod == LGS8GXX_PROD_LGS8G75)\r\nlgs8g75_init_data(priv);\r\nreturn &priv->frontend;\r\nerror_out:\r\ndprintk("%s() error_out\n", __func__);\r\nkfree(priv);\r\nreturn NULL;\r\n}
