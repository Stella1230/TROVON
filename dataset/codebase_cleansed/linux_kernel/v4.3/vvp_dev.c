static void *vvp_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct vvp_thread_info *info;\r\nOBD_SLAB_ALLOC_PTR_GFP(info, vvp_thread_kmem, GFP_NOFS);\r\nif (info == NULL)\r\ninfo = ERR_PTR(-ENOMEM);\r\nreturn info;\r\n}\r\nstatic void vvp_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct vvp_thread_info *info = data;\r\nOBD_SLAB_FREE_PTR(info, vvp_thread_kmem);\r\n}\r\nstatic void *vvp_session_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct vvp_session *session;\r\nOBD_SLAB_ALLOC_PTR_GFP(session, vvp_session_kmem, GFP_NOFS);\r\nif (session == NULL)\r\nsession = ERR_PTR(-ENOMEM);\r\nreturn session;\r\n}\r\nstatic void vvp_session_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct vvp_session *session = data;\r\nOBD_SLAB_FREE_PTR(session, vvp_session_kmem);\r\n}\r\nstatic struct lu_device *vvp_device_alloc(const struct lu_env *env,\r\nstruct lu_device_type *t,\r\nstruct lustre_cfg *cfg)\r\n{\r\nreturn ccc_device_alloc(env, t, cfg, &vvp_lu_ops, &vvp_cl_ops);\r\n}\r\nint vvp_global_init(void)\r\n{\r\nint result;\r\nresult = lu_kmem_init(vvp_caches);\r\nif (result == 0) {\r\nresult = ccc_global_init(&vvp_device_type);\r\nif (result != 0)\r\nlu_kmem_fini(vvp_caches);\r\n}\r\nreturn result;\r\n}\r\nvoid vvp_global_fini(void)\r\n{\r\nccc_global_fini(&vvp_device_type);\r\nlu_kmem_fini(vvp_caches);\r\n}\r\nint cl_sb_init(struct super_block *sb)\r\n{\r\nstruct ll_sb_info *sbi;\r\nstruct cl_device *cl;\r\nstruct lu_env *env;\r\nint rc = 0;\r\nint refcheck;\r\nsbi = ll_s2sbi(sb);\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\ncl = cl_type_setup(env, NULL, &vvp_device_type,\r\nsbi->ll_dt_exp->exp_obd->obd_lu_dev);\r\nif (!IS_ERR(cl)) {\r\ncl2ccc_dev(cl)->cdv_sb = sb;\r\nsbi->ll_cl = cl;\r\nsbi->ll_site = cl2lu_dev(cl)->ld_site;\r\n}\r\ncl_env_put(env, &refcheck);\r\n} else\r\nrc = PTR_ERR(env);\r\nreturn rc;\r\n}\r\nint cl_sb_fini(struct super_block *sb)\r\n{\r\nstruct ll_sb_info *sbi;\r\nstruct lu_env *env;\r\nstruct cl_device *cld;\r\nint refcheck;\r\nint result;\r\nsbi = ll_s2sbi(sb);\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\ncld = sbi->ll_cl;\r\nif (cld != NULL) {\r\ncl_stack_fini(env, cld);\r\nsbi->ll_cl = NULL;\r\nsbi->ll_site = NULL;\r\n}\r\ncl_env_put(env, &refcheck);\r\nresult = 0;\r\n} else {\r\nCERROR("Cannot cleanup cl-stack due to memory shortage.\n");\r\nresult = PTR_ERR(env);\r\n}\r\nlu_types_stop();\r\nreturn result;\r\n}\r\nstatic void vvp_pgcache_id_unpack(loff_t pos, struct vvp_pgcache_id *id)\r\n{\r\nCLASSERT(sizeof(pos) == sizeof(__u64));\r\nid->vpi_index = pos & 0xffffffff;\r\nid->vpi_depth = (pos >> PGC_DEPTH_SHIFT) & 0xf;\r\nid->vpi_bucket = (unsigned long long)pos >> PGC_OBJ_SHIFT;\r\n}\r\nstatic loff_t vvp_pgcache_id_pack(struct vvp_pgcache_id *id)\r\n{\r\nreturn\r\n((__u64)id->vpi_index) |\r\n((__u64)id->vpi_depth << PGC_DEPTH_SHIFT) |\r\n((__u64)id->vpi_bucket << PGC_OBJ_SHIFT);\r\n}\r\nstatic int vvp_pgcache_obj_get(struct cfs_hash *hs, struct cfs_hash_bd *bd,\r\nstruct hlist_node *hnode, void *data)\r\n{\r\nstruct vvp_pgcache_id *id = data;\r\nstruct lu_object_header *hdr = cfs_hash_object(hs, hnode);\r\nif (id->vpi_curdep-- > 0)\r\nreturn 0;\r\nif (lu_object_is_dying(hdr))\r\nreturn 1;\r\ncfs_hash_get(hs, hnode);\r\nid->vpi_obj = hdr;\r\nreturn 1;\r\n}\r\nstatic struct cl_object *vvp_pgcache_obj(const struct lu_env *env,\r\nstruct lu_device *dev,\r\nstruct vvp_pgcache_id *id)\r\n{\r\nLASSERT(lu_device_is_cl(dev));\r\nid->vpi_depth &= 0xf;\r\nid->vpi_obj = NULL;\r\nid->vpi_curdep = id->vpi_depth;\r\ncfs_hash_hlist_for_each(dev->ld_site->ls_obj_hash, id->vpi_bucket,\r\nvvp_pgcache_obj_get, id);\r\nif (id->vpi_obj != NULL) {\r\nstruct lu_object *lu_obj;\r\nlu_obj = lu_object_locate(id->vpi_obj, dev->ld_type);\r\nif (lu_obj != NULL) {\r\nlu_object_ref_add(lu_obj, "dump", current);\r\nreturn lu2cl(lu_obj);\r\n}\r\nlu_object_put(env, lu_object_top(id->vpi_obj));\r\n} else if (id->vpi_curdep > 0) {\r\nid->vpi_depth = 0xf;\r\n}\r\nreturn NULL;\r\n}\r\nstatic loff_t vvp_pgcache_find(const struct lu_env *env,\r\nstruct lu_device *dev, loff_t pos)\r\n{\r\nstruct cl_object *clob;\r\nstruct lu_site *site;\r\nstruct vvp_pgcache_id id;\r\nsite = dev->ld_site;\r\nvvp_pgcache_id_unpack(pos, &id);\r\nwhile (1) {\r\nif (id.vpi_bucket >= CFS_HASH_NHLIST(site->ls_obj_hash))\r\nreturn ~0ULL;\r\nclob = vvp_pgcache_obj(env, dev, &id);\r\nif (clob != NULL) {\r\nstruct cl_object_header *hdr;\r\nint nr;\r\nstruct cl_page *pg;\r\nhdr = cl_object_header(clob);\r\nspin_lock(&hdr->coh_page_guard);\r\nnr = radix_tree_gang_lookup(&hdr->coh_tree,\r\n(void **)&pg,\r\nid.vpi_index, 1);\r\nif (nr > 0) {\r\nid.vpi_index = pg->cp_index;\r\nnr = !(pg->cp_index > 0xffffffff);\r\n}\r\nspin_unlock(&hdr->coh_page_guard);\r\nlu_object_ref_del(&clob->co_lu, "dump", current);\r\ncl_object_put(env, clob);\r\nif (nr > 0)\r\nreturn vvp_pgcache_id_pack(&id);\r\n}\r\n++id.vpi_depth;\r\nid.vpi_depth &= 0xf;\r\nif (id.vpi_depth == 0 && ++id.vpi_bucket == 0)\r\nreturn ~0ULL;\r\nid.vpi_index = 0;\r\n}\r\n}\r\nstatic void vvp_pgcache_page_show(const struct lu_env *env,\r\nstruct seq_file *seq, struct cl_page *page)\r\n{\r\nstruct ccc_page *cpg;\r\nstruct page *vmpage;\r\nint has_flags;\r\ncpg = cl2ccc_page(cl_page_at(page, &vvp_device_type));\r\nvmpage = cpg->cpg_page;\r\nseq_printf(seq, " %5i | %p %p %s %s %s %s | %p %lu/%u(%p) %lu %u [",\r\n0 ,\r\ncpg, page,\r\n"none",\r\ncpg->cpg_write_queued ? "wq" : "- ",\r\ncpg->cpg_defer_uptodate ? "du" : "- ",\r\nPageWriteback(vmpage) ? "wb" : "-",\r\nvmpage, vmpage->mapping->host->i_ino,\r\nvmpage->mapping->host->i_generation,\r\nvmpage->mapping->host, vmpage->index,\r\npage_count(vmpage));\r\nhas_flags = 0;\r\nseq_page_flag(seq, vmpage, locked, has_flags);\r\nseq_page_flag(seq, vmpage, error, has_flags);\r\nseq_page_flag(seq, vmpage, referenced, has_flags);\r\nseq_page_flag(seq, vmpage, uptodate, has_flags);\r\nseq_page_flag(seq, vmpage, dirty, has_flags);\r\nseq_page_flag(seq, vmpage, writeback, has_flags);\r\nseq_printf(seq, "%s]\n", has_flags ? "" : "-");\r\n}\r\nstatic int vvp_pgcache_show(struct seq_file *f, void *v)\r\n{\r\nloff_t pos;\r\nstruct ll_sb_info *sbi;\r\nstruct cl_object *clob;\r\nstruct lu_env *env;\r\nstruct cl_page *page;\r\nstruct cl_object_header *hdr;\r\nstruct vvp_pgcache_id id;\r\nint refcheck;\r\nint result;\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\npos = *(loff_t *) v;\r\nvvp_pgcache_id_unpack(pos, &id);\r\nsbi = f->private;\r\nclob = vvp_pgcache_obj(env, &sbi->ll_cl->cd_lu_dev, &id);\r\nif (clob != NULL) {\r\nhdr = cl_object_header(clob);\r\nspin_lock(&hdr->coh_page_guard);\r\npage = cl_page_lookup(hdr, id.vpi_index);\r\nspin_unlock(&hdr->coh_page_guard);\r\nseq_printf(f, "%8x@"DFID": ",\r\nid.vpi_index, PFID(&hdr->coh_lu.loh_fid));\r\nif (page != NULL) {\r\nvvp_pgcache_page_show(env, f, page);\r\ncl_page_put(env, page);\r\n} else\r\nseq_puts(f, "missing\n");\r\nlu_object_ref_del(&clob->co_lu, "dump", current);\r\ncl_object_put(env, clob);\r\n} else\r\nseq_printf(f, "%llx missing\n", pos);\r\ncl_env_put(env, &refcheck);\r\nresult = 0;\r\n} else\r\nresult = PTR_ERR(env);\r\nreturn result;\r\n}\r\nstatic void *vvp_pgcache_start(struct seq_file *f, loff_t *pos)\r\n{\r\nstruct ll_sb_info *sbi;\r\nstruct lu_env *env;\r\nint refcheck;\r\nsbi = f->private;\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\nsbi = f->private;\r\nif (sbi->ll_site->ls_obj_hash->hs_cur_bits > 64 - PGC_OBJ_SHIFT)\r\npos = ERR_PTR(-EFBIG);\r\nelse {\r\n*pos = vvp_pgcache_find(env, &sbi->ll_cl->cd_lu_dev,\r\n*pos);\r\nif (*pos == ~0ULL)\r\npos = NULL;\r\n}\r\ncl_env_put(env, &refcheck);\r\n}\r\nreturn pos;\r\n}\r\nstatic void *vvp_pgcache_next(struct seq_file *f, void *v, loff_t *pos)\r\n{\r\nstruct ll_sb_info *sbi;\r\nstruct lu_env *env;\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nif (!IS_ERR(env)) {\r\nsbi = f->private;\r\n*pos = vvp_pgcache_find(env, &sbi->ll_cl->cd_lu_dev, *pos + 1);\r\nif (*pos == ~0ULL)\r\npos = NULL;\r\ncl_env_put(env, &refcheck);\r\n}\r\nreturn pos;\r\n}\r\nstatic void vvp_pgcache_stop(struct seq_file *f, void *v)\r\n{\r\n}\r\nstatic int vvp_dump_pgcache_seq_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct seq_file *seq;\r\nint rc;\r\nrc = seq_open(filp, &vvp_pgcache_ops);\r\nif (rc)\r\nreturn rc;\r\nseq = filp->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}
