static int value_set(struct bt_ctf_field_type *type,\r\nstruct bt_ctf_event *event,\r\nconst char *name, u64 val)\r\n{\r\nstruct bt_ctf_field *field;\r\nbool sign = bt_ctf_field_type_integer_get_signed(type);\r\nint ret;\r\nfield = bt_ctf_field_create(type);\r\nif (!field) {\r\npr_err("failed to create a field %s\n", name);\r\nreturn -1;\r\n}\r\nif (sign) {\r\nret = bt_ctf_field_signed_integer_set_value(field, val);\r\nif (ret) {\r\npr_err("failed to set field value %s\n", name);\r\ngoto err;\r\n}\r\n} else {\r\nret = bt_ctf_field_unsigned_integer_set_value(field, val);\r\nif (ret) {\r\npr_err("failed to set field value %s\n", name);\r\ngoto err;\r\n}\r\n}\r\nret = bt_ctf_event_set_payload(event, name, field);\r\nif (ret) {\r\npr_err("failed to set payload %s\n", name);\r\ngoto err;\r\n}\r\npr2(" SET [%s = %" PRIu64 "]\n", name, val);\r\nerr:\r\nbt_ctf_field_put(field);\r\nreturn ret;\r\n}\r\nstatic struct bt_ctf_field_type*\r\nget_tracepoint_field_type(struct ctf_writer *cw, struct format_field *field)\r\n{\r\nunsigned long flags = field->flags;\r\nif (flags & FIELD_IS_STRING)\r\nreturn cw->data.string;\r\nif (!(flags & FIELD_IS_SIGNED)) {\r\nif (flags & FIELD_IS_LONG || flags & FIELD_IS_POINTER)\r\nreturn cw->data.u64_hex;\r\n}\r\nif (flags & FIELD_IS_SIGNED) {\r\nif (field->size == 8)\r\nreturn cw->data.s64;\r\nelse\r\nreturn cw->data.s32;\r\n}\r\nif (field->size == 8)\r\nreturn cw->data.u64;\r\nelse\r\nreturn cw->data.u32;\r\n}\r\nstatic unsigned long long adjust_signedness(unsigned long long value_int, int size)\r\n{\r\nunsigned long long value_mask;\r\nswitch (size) {\r\ncase 1:\r\nvalue_mask = 0x7fULL;\r\nbreak;\r\ncase 2:\r\nvalue_mask = 0x7fffULL;\r\nbreak;\r\ncase 4:\r\nvalue_mask = 0x7fffffffULL;\r\nbreak;\r\ncase 8:\r\ndefault:\r\nreturn value_int;\r\n}\r\nif ((value_int & (~0ULL - value_mask)) == 0)\r\nreturn value_int;\r\nreturn (value_int & value_mask) | ~value_mask;\r\n}\r\nstatic int add_tracepoint_field_value(struct ctf_writer *cw,\r\nstruct bt_ctf_event_class *event_class,\r\nstruct bt_ctf_event *event,\r\nstruct perf_sample *sample,\r\nstruct format_field *fmtf)\r\n{\r\nstruct bt_ctf_field_type *type;\r\nstruct bt_ctf_field *array_field;\r\nstruct bt_ctf_field *field;\r\nconst char *name = fmtf->name;\r\nvoid *data = sample->raw_data;\r\nunsigned long flags = fmtf->flags;\r\nunsigned int n_items;\r\nunsigned int i;\r\nunsigned int offset;\r\nunsigned int len;\r\nint ret;\r\nname = fmtf->alias;\r\noffset = fmtf->offset;\r\nlen = fmtf->size;\r\nif (flags & FIELD_IS_STRING)\r\nflags &= ~FIELD_IS_ARRAY;\r\nif (flags & FIELD_IS_DYNAMIC) {\r\nunsigned long long tmp_val;\r\ntmp_val = pevent_read_number(fmtf->event->pevent,\r\ndata + offset, len);\r\noffset = tmp_val;\r\nlen = offset >> 16;\r\noffset &= 0xffff;\r\n}\r\nif (flags & FIELD_IS_ARRAY) {\r\ntype = bt_ctf_event_class_get_field_by_name(\r\nevent_class, name);\r\narray_field = bt_ctf_field_create(type);\r\nbt_ctf_field_type_put(type);\r\nif (!array_field) {\r\npr_err("Failed to create array type %s\n", name);\r\nreturn -1;\r\n}\r\nlen = fmtf->size / fmtf->arraylen;\r\nn_items = fmtf->arraylen;\r\n} else {\r\nn_items = 1;\r\narray_field = NULL;\r\n}\r\ntype = get_tracepoint_field_type(cw, fmtf);\r\nfor (i = 0; i < n_items; i++) {\r\nif (flags & FIELD_IS_ARRAY)\r\nfield = bt_ctf_field_array_get_field(array_field, i);\r\nelse\r\nfield = bt_ctf_field_create(type);\r\nif (!field) {\r\npr_err("failed to create a field %s\n", name);\r\nreturn -1;\r\n}\r\nif (flags & FIELD_IS_STRING)\r\nret = bt_ctf_field_string_set_value(field,\r\ndata + offset + i * len);\r\nelse {\r\nunsigned long long value_int;\r\nvalue_int = pevent_read_number(\r\nfmtf->event->pevent,\r\ndata + offset + i * len, len);\r\nif (!(flags & FIELD_IS_SIGNED))\r\nret = bt_ctf_field_unsigned_integer_set_value(\r\nfield, value_int);\r\nelse\r\nret = bt_ctf_field_signed_integer_set_value(\r\nfield, adjust_signedness(value_int, len));\r\n}\r\nif (ret) {\r\npr_err("failed to set file value %s\n", name);\r\ngoto err_put_field;\r\n}\r\nif (!(flags & FIELD_IS_ARRAY)) {\r\nret = bt_ctf_event_set_payload(event, name, field);\r\nif (ret) {\r\npr_err("failed to set payload %s\n", name);\r\ngoto err_put_field;\r\n}\r\n}\r\nbt_ctf_field_put(field);\r\n}\r\nif (flags & FIELD_IS_ARRAY) {\r\nret = bt_ctf_event_set_payload(event, name, array_field);\r\nif (ret) {\r\npr_err("Failed add payload array %s\n", name);\r\nreturn -1;\r\n}\r\nbt_ctf_field_put(array_field);\r\n}\r\nreturn 0;\r\nerr_put_field:\r\nbt_ctf_field_put(field);\r\nreturn -1;\r\n}\r\nstatic int add_tracepoint_fields_values(struct ctf_writer *cw,\r\nstruct bt_ctf_event_class *event_class,\r\nstruct bt_ctf_event *event,\r\nstruct format_field *fields,\r\nstruct perf_sample *sample)\r\n{\r\nstruct format_field *field;\r\nint ret;\r\nfor (field = fields; field; field = field->next) {\r\nret = add_tracepoint_field_value(cw, event_class, event, sample,\r\nfield);\r\nif (ret)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_tracepoint_values(struct ctf_writer *cw,\r\nstruct bt_ctf_event_class *event_class,\r\nstruct bt_ctf_event *event,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nstruct format_field *common_fields = evsel->tp_format->format.common_fields;\r\nstruct format_field *fields = evsel->tp_format->format.fields;\r\nint ret;\r\nret = add_tracepoint_fields_values(cw, event_class, event,\r\ncommon_fields, sample);\r\nif (!ret)\r\nret = add_tracepoint_fields_values(cw, event_class, event,\r\nfields, sample);\r\nreturn ret;\r\n}\r\nstatic int add_generic_values(struct ctf_writer *cw,\r\nstruct bt_ctf_event *event,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nu64 type = evsel->attr.sample_type;\r\nint ret;\r\nif (type & PERF_SAMPLE_IP) {\r\nret = value_set_u64_hex(cw, event, "perf_ip", sample->ip);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (type & PERF_SAMPLE_TID) {\r\nret = value_set_s32(cw, event, "perf_tid", sample->tid);\r\nif (ret)\r\nreturn -1;\r\nret = value_set_s32(cw, event, "perf_pid", sample->pid);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif ((type & PERF_SAMPLE_ID) ||\r\n(type & PERF_SAMPLE_IDENTIFIER)) {\r\nret = value_set_u64(cw, event, "perf_id", sample->id);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (type & PERF_SAMPLE_STREAM_ID) {\r\nret = value_set_u64(cw, event, "perf_stream_id", sample->stream_id);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (type & PERF_SAMPLE_PERIOD) {\r\nret = value_set_u64(cw, event, "perf_period", sample->period);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (type & PERF_SAMPLE_WEIGHT) {\r\nret = value_set_u64(cw, event, "perf_weight", sample->weight);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (type & PERF_SAMPLE_DATA_SRC) {\r\nret = value_set_u64(cw, event, "perf_data_src",\r\nsample->data_src);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif (type & PERF_SAMPLE_TRANSACTION) {\r\nret = value_set_u64(cw, event, "perf_transaction",\r\nsample->transaction);\r\nif (ret)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ctf_stream__flush(struct ctf_stream *cs)\r\n{\r\nint err = 0;\r\nif (cs) {\r\nerr = bt_ctf_stream_flush(cs->stream);\r\nif (err)\r\npr_err("CTF stream %d flush failed\n", cs->cpu);\r\npr("Flush stream for cpu %d (%u samples)\n",\r\ncs->cpu, cs->count);\r\ncs->count = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic struct ctf_stream *ctf_stream__create(struct ctf_writer *cw, int cpu)\r\n{\r\nstruct ctf_stream *cs;\r\nstruct bt_ctf_field *pkt_ctx = NULL;\r\nstruct bt_ctf_field *cpu_field = NULL;\r\nstruct bt_ctf_stream *stream = NULL;\r\nint ret;\r\ncs = zalloc(sizeof(*cs));\r\nif (!cs) {\r\npr_err("Failed to allocate ctf stream\n");\r\nreturn NULL;\r\n}\r\nstream = bt_ctf_writer_create_stream(cw->writer, cw->stream_class);\r\nif (!stream) {\r\npr_err("Failed to create CTF stream\n");\r\ngoto out;\r\n}\r\npkt_ctx = bt_ctf_stream_get_packet_context(stream);\r\nif (!pkt_ctx) {\r\npr_err("Failed to obtain packet context\n");\r\ngoto out;\r\n}\r\ncpu_field = bt_ctf_field_structure_get_field(pkt_ctx, "cpu_id");\r\nbt_ctf_field_put(pkt_ctx);\r\nif (!cpu_field) {\r\npr_err("Failed to obtain cpu field\n");\r\ngoto out;\r\n}\r\nret = bt_ctf_field_unsigned_integer_set_value(cpu_field, (u32) cpu);\r\nif (ret) {\r\npr_err("Failed to update CPU number\n");\r\ngoto out;\r\n}\r\nbt_ctf_field_put(cpu_field);\r\ncs->cpu = cpu;\r\ncs->stream = stream;\r\nreturn cs;\r\nout:\r\nif (cpu_field)\r\nbt_ctf_field_put(cpu_field);\r\nif (stream)\r\nbt_ctf_stream_put(stream);\r\nfree(cs);\r\nreturn NULL;\r\n}\r\nstatic void ctf_stream__delete(struct ctf_stream *cs)\r\n{\r\nif (cs) {\r\nbt_ctf_stream_put(cs->stream);\r\nfree(cs);\r\n}\r\n}\r\nstatic struct ctf_stream *ctf_stream(struct ctf_writer *cw, int cpu)\r\n{\r\nstruct ctf_stream *cs = cw->stream[cpu];\r\nif (!cs) {\r\ncs = ctf_stream__create(cw, cpu);\r\ncw->stream[cpu] = cs;\r\n}\r\nreturn cs;\r\n}\r\nstatic int get_sample_cpu(struct ctf_writer *cw, struct perf_sample *sample,\r\nstruct perf_evsel *evsel)\r\n{\r\nint cpu = 0;\r\nif (evsel->attr.sample_type & PERF_SAMPLE_CPU)\r\ncpu = sample->cpu;\r\nif (cpu > cw->stream_cnt) {\r\npr_err("Event was recorded for CPU %d, limit is at %d.\n",\r\ncpu, cw->stream_cnt);\r\ncpu = 0;\r\n}\r\nreturn cpu;\r\n}\r\nstatic bool is_flush_needed(struct ctf_stream *cs)\r\n{\r\nreturn cs->count >= STREAM_FLUSH_COUNT;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *_event __maybe_unused,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct convert *c = container_of(tool, struct convert, tool);\r\nstruct evsel_priv *priv = evsel->priv;\r\nstruct ctf_writer *cw = &c->writer;\r\nstruct ctf_stream *cs;\r\nstruct bt_ctf_event_class *event_class;\r\nstruct bt_ctf_event *event;\r\nint ret;\r\nif (WARN_ONCE(!priv, "Failed to setup all events.\n"))\r\nreturn 0;\r\nevent_class = priv->event_class;\r\nc->events_count++;\r\nc->events_size += _event->header.size;\r\npr_time2(sample->time, "sample %" PRIu64 "\n", c->events_count);\r\nevent = bt_ctf_event_create(event_class);\r\nif (!event) {\r\npr_err("Failed to create an CTF event\n");\r\nreturn -1;\r\n}\r\nbt_ctf_clock_set_time(cw->clock, sample->time);\r\nret = add_generic_values(cw, event, evsel, sample);\r\nif (ret)\r\nreturn -1;\r\nif (evsel->attr.type == PERF_TYPE_TRACEPOINT) {\r\nret = add_tracepoint_values(cw, event_class, event,\r\nevsel, sample);\r\nif (ret)\r\nreturn -1;\r\n}\r\ncs = ctf_stream(cw, get_sample_cpu(cw, sample, evsel));\r\nif (cs) {\r\nif (is_flush_needed(cs))\r\nctf_stream__flush(cs);\r\ncs->count++;\r\nbt_ctf_stream_append_event(cs->stream, event);\r\n}\r\nbt_ctf_event_put(event);\r\nreturn cs ? 0 : -1;\r\n}\r\nstatic char *change_name(char *name, char *orig_name, int dup)\r\n{\r\nchar *new_name = NULL;\r\nsize_t len;\r\nif (!name)\r\nname = orig_name;\r\nif (dup >= 10)\r\ngoto out;\r\nif (dup < 0)\r\nlen = strlen(name) + sizeof("_");\r\nelse\r\nlen = strlen(orig_name) + sizeof("_dupl_X");\r\nnew_name = malloc(len);\r\nif (!new_name)\r\ngoto out;\r\nif (dup < 0)\r\nsnprintf(new_name, len, "_%s", name);\r\nelse\r\nsnprintf(new_name, len, "%s_dupl_%d", orig_name, dup);\r\nout:\r\nif (name != orig_name)\r\nfree(name);\r\nreturn new_name;\r\n}\r\nstatic int event_class_add_field(struct bt_ctf_event_class *event_class,\r\nstruct bt_ctf_field_type *type,\r\nstruct format_field *field)\r\n{\r\nstruct bt_ctf_field_type *t = NULL;\r\nchar *name;\r\nint dup = 1;\r\nint ret;\r\nif (field->alias != field->name)\r\nreturn bt_ctf_event_class_add_field(event_class, type,\r\n(char *)field->alias);\r\nname = field->name;\r\nif (bt_ctf_validate_identifier(name))\r\nname = change_name(name, field->name, -1);\r\nif (!name) {\r\npr_err("Failed to fix invalid identifier.");\r\nreturn -1;\r\n}\r\nwhile ((t = bt_ctf_event_class_get_field_by_name(event_class, name))) {\r\nbt_ctf_field_type_put(t);\r\nname = change_name(name, field->name, dup++);\r\nif (!name) {\r\npr_err("Failed to create dup name for '%s'\n", field->name);\r\nreturn -1;\r\n}\r\n}\r\nret = bt_ctf_event_class_add_field(event_class, type, name);\r\nif (!ret)\r\nfield->alias = name;\r\nreturn ret;\r\n}\r\nstatic int add_tracepoint_fields_types(struct ctf_writer *cw,\r\nstruct format_field *fields,\r\nstruct bt_ctf_event_class *event_class)\r\n{\r\nstruct format_field *field;\r\nint ret;\r\nfor (field = fields; field; field = field->next) {\r\nstruct bt_ctf_field_type *type;\r\nunsigned long flags = field->flags;\r\npr2(" field '%s'\n", field->name);\r\ntype = get_tracepoint_field_type(cw, field);\r\nif (!type)\r\nreturn -1;\r\nif (flags & FIELD_IS_STRING)\r\nflags &= ~FIELD_IS_ARRAY;\r\nif (flags & FIELD_IS_ARRAY)\r\ntype = bt_ctf_field_type_array_create(type, field->arraylen);\r\nret = event_class_add_field(event_class, type, field);\r\nif (flags & FIELD_IS_ARRAY)\r\nbt_ctf_field_type_put(type);\r\nif (ret) {\r\npr_err("Failed to add field '%s': %d\n",\r\nfield->name, ret);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_tracepoint_types(struct ctf_writer *cw,\r\nstruct perf_evsel *evsel,\r\nstruct bt_ctf_event_class *class)\r\n{\r\nstruct format_field *common_fields = evsel->tp_format->format.common_fields;\r\nstruct format_field *fields = evsel->tp_format->format.fields;\r\nint ret;\r\nret = add_tracepoint_fields_types(cw, common_fields, class);\r\nif (!ret)\r\nret = add_tracepoint_fields_types(cw, fields, class);\r\nreturn ret;\r\n}\r\nstatic int add_generic_types(struct ctf_writer *cw, struct perf_evsel *evsel,\r\nstruct bt_ctf_event_class *event_class)\r\n{\r\nu64 type = evsel->attr.sample_type;\r\n#define ADD_FIELD(cl, t, n) \\r\ndo { \\r\npr2(" field '%s'\n", n); \\r\nif (bt_ctf_event_class_add_field(cl, t, n)) { \\r\npr_err("Failed to add field '%s';\n", n); \\r\nreturn -1; \\r\n} \\r\n} while (0)\r\nif (type & PERF_SAMPLE_IP)\r\nADD_FIELD(event_class, cw->data.u64_hex, "perf_ip");\r\nif (type & PERF_SAMPLE_TID) {\r\nADD_FIELD(event_class, cw->data.s32, "perf_tid");\r\nADD_FIELD(event_class, cw->data.s32, "perf_pid");\r\n}\r\nif ((type & PERF_SAMPLE_ID) ||\r\n(type & PERF_SAMPLE_IDENTIFIER))\r\nADD_FIELD(event_class, cw->data.u64, "perf_id");\r\nif (type & PERF_SAMPLE_STREAM_ID)\r\nADD_FIELD(event_class, cw->data.u64, "perf_stream_id");\r\nif (type & PERF_SAMPLE_PERIOD)\r\nADD_FIELD(event_class, cw->data.u64, "perf_period");\r\nif (type & PERF_SAMPLE_WEIGHT)\r\nADD_FIELD(event_class, cw->data.u64, "perf_weight");\r\nif (type & PERF_SAMPLE_DATA_SRC)\r\nADD_FIELD(event_class, cw->data.u64, "perf_data_src");\r\nif (type & PERF_SAMPLE_TRANSACTION)\r\nADD_FIELD(event_class, cw->data.u64, "perf_transaction");\r\n#undef ADD_FIELD\r\nreturn 0;\r\n}\r\nstatic int add_event(struct ctf_writer *cw, struct perf_evsel *evsel)\r\n{\r\nstruct bt_ctf_event_class *event_class;\r\nstruct evsel_priv *priv;\r\nconst char *name = perf_evsel__name(evsel);\r\nint ret;\r\npr("Adding event '%s' (type %d)\n", name, evsel->attr.type);\r\nevent_class = bt_ctf_event_class_create(name);\r\nif (!event_class)\r\nreturn -1;\r\nret = add_generic_types(cw, evsel, event_class);\r\nif (ret)\r\ngoto err;\r\nif (evsel->attr.type == PERF_TYPE_TRACEPOINT) {\r\nret = add_tracepoint_types(cw, evsel, event_class);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = bt_ctf_stream_class_add_event_class(cw->stream_class, event_class);\r\nif (ret) {\r\npr("Failed to add event class into stream.\n");\r\ngoto err;\r\n}\r\npriv = malloc(sizeof(*priv));\r\nif (!priv)\r\ngoto err;\r\npriv->event_class = event_class;\r\nevsel->priv = priv;\r\nreturn 0;\r\nerr:\r\nbt_ctf_event_class_put(event_class);\r\npr_err("Failed to add event '%s'.\n", name);\r\nreturn -1;\r\n}\r\nstatic int setup_events(struct ctf_writer *cw, struct perf_session *session)\r\n{\r\nstruct perf_evlist *evlist = session->evlist;\r\nstruct perf_evsel *evsel;\r\nint ret;\r\nevlist__for_each(evlist, evsel) {\r\nret = add_event(cw, evsel);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_streams(struct ctf_writer *cw, struct perf_session *session)\r\n{\r\nstruct ctf_stream **stream;\r\nstruct perf_header *ph = &session->header;\r\nint ncpus;\r\nncpus = ph->env.nr_cpus_avail ?: MAX_CPUS;\r\nstream = zalloc(sizeof(*stream) * ncpus);\r\nif (!stream) {\r\npr_err("Failed to allocate streams.\n");\r\nreturn -ENOMEM;\r\n}\r\ncw->stream = stream;\r\ncw->stream_cnt = ncpus;\r\nreturn 0;\r\n}\r\nstatic void free_streams(struct ctf_writer *cw)\r\n{\r\nint cpu;\r\nfor (cpu = 0; cpu < cw->stream_cnt; cpu++)\r\nctf_stream__delete(cw->stream[cpu]);\r\nfree(cw->stream);\r\n}\r\nstatic int ctf_writer__setup_env(struct ctf_writer *cw,\r\nstruct perf_session *session)\r\n{\r\nstruct perf_header *header = &session->header;\r\nstruct bt_ctf_writer *writer = cw->writer;\r\n#define ADD(__n, __v) \\r\ndo { \\r\nif (bt_ctf_writer_add_environment_field(writer, __n, __v)) \\r\nreturn -1; \\r\n} while (0)\r\nADD("host", header->env.hostname);\r\nADD("sysname", "Linux");\r\nADD("release", header->env.os_release);\r\nADD("version", header->env.version);\r\nADD("machine", header->env.arch);\r\nADD("domain", "kernel");\r\nADD("tracer_name", "perf");\r\n#undef ADD\r\nreturn 0;\r\n}\r\nstatic int ctf_writer__setup_clock(struct ctf_writer *cw)\r\n{\r\nstruct bt_ctf_clock *clock = cw->clock;\r\nbt_ctf_clock_set_description(clock, "perf clock");\r\n#define SET(__n, __v) \\r\ndo { \\r\nif (bt_ctf_clock_set_##__n(clock, __v)) \\r\nreturn -1; \\r\n} while (0)\r\nSET(frequency, 1000000000);\r\nSET(offset_s, 0);\r\nSET(offset, 0);\r\nSET(precision, 10);\r\nSET(is_absolute, 0);\r\n#undef SET\r\nreturn 0;\r\n}\r\nstatic struct bt_ctf_field_type *create_int_type(int size, bool sign, bool hex)\r\n{\r\nstruct bt_ctf_field_type *type;\r\ntype = bt_ctf_field_type_integer_create(size);\r\nif (!type)\r\nreturn NULL;\r\nif (sign &&\r\nbt_ctf_field_type_integer_set_signed(type, 1))\r\ngoto err;\r\nif (hex &&\r\nbt_ctf_field_type_integer_set_base(type, BT_CTF_INTEGER_BASE_HEXADECIMAL))\r\ngoto err;\r\npr2("Created type: INTEGER %d-bit %ssigned %s\n",\r\nsize, sign ? "un" : "", hex ? "hex" : "");\r\nreturn type;\r\nerr:\r\nbt_ctf_field_type_put(type);\r\nreturn NULL;\r\n}\r\nstatic void ctf_writer__cleanup_data(struct ctf_writer *cw)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(cw->data.array); i++)\r\nbt_ctf_field_type_put(cw->data.array[i]);\r\n}\r\nstatic int ctf_writer__init_data(struct ctf_writer *cw)\r\n{\r\n#define CREATE_INT_TYPE(type, size, sign, hex) \\r\ndo { \\r\n(type) = create_int_type(size, sign, hex); \\r\nif (!(type)) \\r\ngoto err; \\r\n} while (0)\r\nCREATE_INT_TYPE(cw->data.s64, 64, true, false);\r\nCREATE_INT_TYPE(cw->data.u64, 64, false, false);\r\nCREATE_INT_TYPE(cw->data.s32, 32, true, false);\r\nCREATE_INT_TYPE(cw->data.u32, 32, false, false);\r\nCREATE_INT_TYPE(cw->data.u64_hex, 64, false, true);\r\ncw->data.string = bt_ctf_field_type_string_create();\r\nif (cw->data.string)\r\nreturn 0;\r\nerr:\r\nctf_writer__cleanup_data(cw);\r\npr_err("Failed to create data types.\n");\r\nreturn -1;\r\n}\r\nstatic void ctf_writer__cleanup(struct ctf_writer *cw)\r\n{\r\nctf_writer__cleanup_data(cw);\r\nbt_ctf_clock_put(cw->clock);\r\nfree_streams(cw);\r\nbt_ctf_stream_class_put(cw->stream_class);\r\nbt_ctf_writer_put(cw->writer);\r\nmemset(cw, 0, sizeof(*cw));\r\n}\r\nstatic int ctf_writer__init(struct ctf_writer *cw, const char *path)\r\n{\r\nstruct bt_ctf_writer *writer;\r\nstruct bt_ctf_stream_class *stream_class;\r\nstruct bt_ctf_clock *clock;\r\nstruct bt_ctf_field_type *pkt_ctx_type;\r\nint ret;\r\nwriter = bt_ctf_writer_create(path);\r\nif (!writer)\r\ngoto err;\r\ncw->writer = writer;\r\nclock = bt_ctf_clock_create("perf_clock");\r\nif (!clock) {\r\npr("Failed to create CTF clock.\n");\r\ngoto err_cleanup;\r\n}\r\ncw->clock = clock;\r\nif (ctf_writer__setup_clock(cw)) {\r\npr("Failed to setup CTF clock.\n");\r\ngoto err_cleanup;\r\n}\r\nstream_class = bt_ctf_stream_class_create("perf_stream");\r\nif (!stream_class) {\r\npr("Failed to create CTF stream class.\n");\r\ngoto err_cleanup;\r\n}\r\ncw->stream_class = stream_class;\r\nif (bt_ctf_stream_class_set_clock(stream_class, clock)) {\r\npr("Failed to assign CTF clock to stream class.\n");\r\ngoto err_cleanup;\r\n}\r\nif (ctf_writer__init_data(cw))\r\ngoto err_cleanup;\r\npkt_ctx_type = bt_ctf_stream_class_get_packet_context_type(stream_class);\r\nif (!pkt_ctx_type)\r\ngoto err_cleanup;\r\nret = bt_ctf_field_type_structure_add_field(pkt_ctx_type, cw->data.u32, "cpu_id");\r\nbt_ctf_field_type_put(pkt_ctx_type);\r\nif (ret)\r\ngoto err_cleanup;\r\nif (bt_ctf_writer_add_clock(writer, clock)) {\r\npr("Failed to assign CTF clock to writer.\n");\r\ngoto err_cleanup;\r\n}\r\nreturn 0;\r\nerr_cleanup:\r\nctf_writer__cleanup(cw);\r\nerr:\r\npr_err("Failed to setup CTF writer.\n");\r\nreturn -1;\r\n}\r\nstatic int ctf_writer__flush_streams(struct ctf_writer *cw)\r\n{\r\nint cpu, ret = 0;\r\nfor (cpu = 0; cpu < cw->stream_cnt && !ret; cpu++)\r\nret = ctf_stream__flush(cw->stream[cpu]);\r\nreturn ret;\r\n}\r\nstatic int convert__config(const char *var, const char *value, void *cb)\r\n{\r\nstruct convert *c = cb;\r\nif (!strcmp(var, "convert.queue-size")) {\r\nc->queue_size = perf_config_u64(var, value);\r\nreturn 0;\r\n}\r\nreturn perf_default_config(var, value, cb);\r\n}\r\nint bt_convert__perf2ctf(const char *input, const char *path, bool force)\r\n{\r\nstruct perf_session *session;\r\nstruct perf_data_file file = {\r\n.path = input,\r\n.mode = PERF_DATA_MODE_READ,\r\n.force = force,\r\n};\r\nstruct convert c = {\r\n.tool = {\r\n.sample = process_sample_event,\r\n.mmap = perf_event__process_mmap,\r\n.mmap2 = perf_event__process_mmap2,\r\n.comm = perf_event__process_comm,\r\n.exit = perf_event__process_exit,\r\n.fork = perf_event__process_fork,\r\n.lost = perf_event__process_lost,\r\n.tracing_data = perf_event__process_tracing_data,\r\n.build_id = perf_event__process_build_id,\r\n.ordered_events = true,\r\n.ordering_requires_timestamps = true,\r\n},\r\n};\r\nstruct ctf_writer *cw = &c.writer;\r\nint err = -1;\r\nperf_config(convert__config, &c);\r\nif (ctf_writer__init(cw, path))\r\nreturn -1;\r\nsession = perf_session__new(&file, 0, &c.tool);\r\nif (!session)\r\ngoto free_writer;\r\nif (c.queue_size) {\r\nordered_events__set_alloc_size(&session->ordered_events,\r\nc.queue_size);\r\n}\r\nif (ctf_writer__setup_env(cw, session))\r\ngoto free_session;\r\nif (setup_events(cw, session))\r\ngoto free_session;\r\nif (setup_streams(cw, session))\r\ngoto free_session;\r\nerr = perf_session__process_events(session);\r\nif (!err)\r\nerr = ctf_writer__flush_streams(cw);\r\nelse\r\npr_err("Error during conversion.\n");\r\nfprintf(stderr,\r\n"[ perf data convert: Converted '%s' into CTF data '%s' ]\n",\r\nfile.path, path);\r\nfprintf(stderr,\r\n"[ perf data convert: Converted and wrote %.3f MB (%" PRIu64 " samples) ]\n",\r\n(double) c.events_size / 1024.0 / 1024.0,\r\nc.events_count);\r\nperf_session__delete(session);\r\nctf_writer__cleanup(cw);\r\nreturn err;\r\nfree_session:\r\nperf_session__delete(session);\r\nfree_writer:\r\nctf_writer__cleanup(cw);\r\npr_err("Error during conversion setup.\n");\r\nreturn err;\r\n}
