__be32 *\r\nxdr_encode_netobj(__be32 *p, const struct xdr_netobj *obj)\r\n{\r\nunsigned int quadlen = XDR_QUADLEN(obj->len);\r\np[quadlen] = 0;\r\n*p++ = cpu_to_be32(obj->len);\r\nmemcpy(p, obj->data, obj->len);\r\nreturn p + XDR_QUADLEN(obj->len);\r\n}\r\n__be32 *\r\nxdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)\r\n{\r\nunsigned int len;\r\nif ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)\r\nreturn NULL;\r\nobj->len = len;\r\nobj->data = (u8 *) p;\r\nreturn p + XDR_QUADLEN(len);\r\n}\r\n__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)\r\n{\r\nif (likely(nbytes != 0)) {\r\nunsigned int quadlen = XDR_QUADLEN(nbytes);\r\nunsigned int padding = (quadlen << 2) - nbytes;\r\nif (ptr != NULL)\r\nmemcpy(p, ptr, nbytes);\r\nif (padding != 0)\r\nmemset((char *)p + nbytes, 0, padding);\r\np += quadlen;\r\n}\r\nreturn p;\r\n}\r\n__be32 *xdr_encode_opaque(__be32 *p, const void *ptr, unsigned int nbytes)\r\n{\r\n*p++ = cpu_to_be32(nbytes);\r\nreturn xdr_encode_opaque_fixed(p, ptr, nbytes);\r\n}\r\n__be32 *\r\nxdr_encode_string(__be32 *p, const char *string)\r\n{\r\nreturn xdr_encode_array(p, string, strlen(string));\r\n}\r\n__be32 *\r\nxdr_decode_string_inplace(__be32 *p, char **sp,\r\nunsigned int *lenp, unsigned int maxlen)\r\n{\r\nu32 len;\r\nlen = be32_to_cpu(*p++);\r\nif (len > maxlen)\r\nreturn NULL;\r\n*lenp = len;\r\n*sp = (char *) p;\r\nreturn p + XDR_QUADLEN(len);\r\n}\r\nvoid\r\nxdr_terminate_string(struct xdr_buf *buf, const u32 len)\r\n{\r\nchar *kaddr;\r\nkaddr = kmap_atomic(buf->pages[0]);\r\nkaddr[buf->page_base + len] = '\0';\r\nkunmap_atomic(kaddr);\r\n}\r\nvoid\r\nxdr_inline_pages(struct xdr_buf *xdr, unsigned int offset,\r\nstruct page **pages, unsigned int base, unsigned int len)\r\n{\r\nstruct kvec *head = xdr->head;\r\nstruct kvec *tail = xdr->tail;\r\nchar *buf = (char *)head->iov_base;\r\nunsigned int buflen = head->iov_len;\r\nhead->iov_len = offset;\r\nxdr->pages = pages;\r\nxdr->page_base = base;\r\nxdr->page_len = len;\r\ntail->iov_base = buf + offset;\r\ntail->iov_len = buflen - offset;\r\nxdr->buflen += len;\r\n}\r\nstatic void\r\n_shift_data_right_pages(struct page **pages, size_t pgto_base,\r\nsize_t pgfrom_base, size_t len)\r\n{\r\nstruct page **pgfrom, **pgto;\r\nchar *vfrom, *vto;\r\nsize_t copy;\r\nBUG_ON(pgto_base <= pgfrom_base);\r\npgto_base += len;\r\npgfrom_base += len;\r\npgto = pages + (pgto_base >> PAGE_CACHE_SHIFT);\r\npgfrom = pages + (pgfrom_base >> PAGE_CACHE_SHIFT);\r\npgto_base &= ~PAGE_CACHE_MASK;\r\npgfrom_base &= ~PAGE_CACHE_MASK;\r\ndo {\r\nif (pgto_base == 0) {\r\npgto_base = PAGE_CACHE_SIZE;\r\npgto--;\r\n}\r\nif (pgfrom_base == 0) {\r\npgfrom_base = PAGE_CACHE_SIZE;\r\npgfrom--;\r\n}\r\ncopy = len;\r\nif (copy > pgto_base)\r\ncopy = pgto_base;\r\nif (copy > pgfrom_base)\r\ncopy = pgfrom_base;\r\npgto_base -= copy;\r\npgfrom_base -= copy;\r\nvto = kmap_atomic(*pgto);\r\nif (*pgto != *pgfrom) {\r\nvfrom = kmap_atomic(*pgfrom);\r\nmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\r\nkunmap_atomic(vfrom);\r\n} else\r\nmemmove(vto + pgto_base, vto + pgfrom_base, copy);\r\nflush_dcache_page(*pgto);\r\nkunmap_atomic(vto);\r\n} while ((len -= copy) != 0);\r\n}\r\nstatic void\r\n_copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\r\n{\r\nstruct page **pgto;\r\nchar *vto;\r\nsize_t copy;\r\npgto = pages + (pgbase >> PAGE_CACHE_SHIFT);\r\npgbase &= ~PAGE_CACHE_MASK;\r\nfor (;;) {\r\ncopy = PAGE_CACHE_SIZE - pgbase;\r\nif (copy > len)\r\ncopy = len;\r\nvto = kmap_atomic(*pgto);\r\nmemcpy(vto + pgbase, p, copy);\r\nkunmap_atomic(vto);\r\nlen -= copy;\r\nif (len == 0)\r\nbreak;\r\npgbase += copy;\r\nif (pgbase == PAGE_CACHE_SIZE) {\r\nflush_dcache_page(*pgto);\r\npgbase = 0;\r\npgto++;\r\n}\r\np += copy;\r\n}\r\nflush_dcache_page(*pgto);\r\n}\r\nvoid\r\n_copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\r\n{\r\nstruct page **pgfrom;\r\nchar *vfrom;\r\nsize_t copy;\r\npgfrom = pages + (pgbase >> PAGE_CACHE_SHIFT);\r\npgbase &= ~PAGE_CACHE_MASK;\r\ndo {\r\ncopy = PAGE_CACHE_SIZE - pgbase;\r\nif (copy > len)\r\ncopy = len;\r\nvfrom = kmap_atomic(*pgfrom);\r\nmemcpy(p, vfrom + pgbase, copy);\r\nkunmap_atomic(vfrom);\r\npgbase += copy;\r\nif (pgbase == PAGE_CACHE_SIZE) {\r\npgbase = 0;\r\npgfrom++;\r\n}\r\np += copy;\r\n} while ((len -= copy) != 0);\r\n}\r\nstatic void\r\nxdr_shrink_bufhead(struct xdr_buf *buf, size_t len)\r\n{\r\nstruct kvec *head, *tail;\r\nsize_t copy, offs;\r\nunsigned int pglen = buf->page_len;\r\ntail = buf->tail;\r\nhead = buf->head;\r\nWARN_ON_ONCE(len > head->iov_len);\r\nif (len > head->iov_len)\r\nlen = head->iov_len;\r\nif (tail->iov_len != 0) {\r\nif (tail->iov_len > len) {\r\ncopy = tail->iov_len - len;\r\nmemmove((char *)tail->iov_base + len,\r\ntail->iov_base, copy);\r\n}\r\ncopy = len;\r\nif (copy > pglen)\r\ncopy = pglen;\r\noffs = len - copy;\r\nif (offs >= tail->iov_len)\r\ncopy = 0;\r\nelse if (copy > tail->iov_len - offs)\r\ncopy = tail->iov_len - offs;\r\nif (copy != 0)\r\n_copy_from_pages((char *)tail->iov_base + offs,\r\nbuf->pages,\r\nbuf->page_base + pglen + offs - len,\r\ncopy);\r\nif (len > pglen) {\r\noffs = copy = len - pglen;\r\nif (copy > tail->iov_len)\r\ncopy = tail->iov_len;\r\nmemcpy(tail->iov_base,\r\n(char *)head->iov_base +\r\nhead->iov_len - offs,\r\ncopy);\r\n}\r\n}\r\nif (pglen != 0) {\r\nif (pglen > len)\r\n_shift_data_right_pages(buf->pages,\r\nbuf->page_base + len,\r\nbuf->page_base,\r\npglen - len);\r\ncopy = len;\r\nif (len > pglen)\r\ncopy = pglen;\r\n_copy_to_pages(buf->pages, buf->page_base,\r\n(char *)head->iov_base + head->iov_len - len,\r\ncopy);\r\n}\r\nhead->iov_len -= len;\r\nbuf->buflen -= len;\r\nif (buf->len > buf->buflen)\r\nbuf->len = buf->buflen;\r\n}\r\nstatic void\r\nxdr_shrink_pagelen(struct xdr_buf *buf, size_t len)\r\n{\r\nstruct kvec *tail;\r\nsize_t copy;\r\nunsigned int pglen = buf->page_len;\r\nunsigned int tailbuf_len;\r\ntail = buf->tail;\r\nBUG_ON (len > pglen);\r\ntailbuf_len = buf->buflen - buf->head->iov_len - buf->page_len;\r\nif (tailbuf_len != 0) {\r\nunsigned int free_space = tailbuf_len - tail->iov_len;\r\nif (len < free_space)\r\nfree_space = len;\r\ntail->iov_len += free_space;\r\ncopy = len;\r\nif (tail->iov_len > len) {\r\nchar *p = (char *)tail->iov_base + len;\r\nmemmove(p, tail->iov_base, tail->iov_len - len);\r\n} else\r\ncopy = tail->iov_len;\r\n_copy_from_pages((char *)tail->iov_base,\r\nbuf->pages, buf->page_base + pglen - len,\r\ncopy);\r\n}\r\nbuf->page_len -= len;\r\nbuf->buflen -= len;\r\nif (buf->len > buf->buflen)\r\nbuf->len = buf->buflen;\r\n}\r\nvoid\r\nxdr_shift_buf(struct xdr_buf *buf, size_t len)\r\n{\r\nxdr_shrink_bufhead(buf, len);\r\n}\r\nunsigned int xdr_stream_pos(const struct xdr_stream *xdr)\r\n{\r\nreturn (unsigned int)(XDR_QUADLEN(xdr->buf->len) - xdr->nwords) << 2;\r\n}\r\nvoid xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p)\r\n{\r\nstruct kvec *iov = buf->head;\r\nint scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;\r\nxdr_set_scratch_buffer(xdr, NULL, 0);\r\nBUG_ON(scratch_len < 0);\r\nxdr->buf = buf;\r\nxdr->iov = iov;\r\nxdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);\r\nxdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);\r\nBUG_ON(iov->iov_len > scratch_len);\r\nif (p != xdr->p && p != NULL) {\r\nsize_t len;\r\nBUG_ON(p < xdr->p || p > xdr->end);\r\nlen = (char *)p - (char *)xdr->p;\r\nxdr->p = p;\r\nbuf->len += len;\r\niov->iov_len += len;\r\n}\r\n}\r\nvoid xdr_commit_encode(struct xdr_stream *xdr)\r\n{\r\nint shift = xdr->scratch.iov_len;\r\nvoid *page;\r\nif (shift == 0)\r\nreturn;\r\npage = page_address(*xdr->page_ptr);\r\nmemcpy(xdr->scratch.iov_base, page, shift);\r\nmemmove(page, page + shift, (void *)xdr->p - page);\r\nxdr->scratch.iov_len = 0;\r\n}\r\nstatic __be32 *xdr_get_next_encode_buffer(struct xdr_stream *xdr,\r\nsize_t nbytes)\r\n{\r\nstatic __be32 *p;\r\nint space_left;\r\nint frag1bytes, frag2bytes;\r\nif (nbytes > PAGE_SIZE)\r\nreturn NULL;\r\nif (xdr->buf->len + nbytes > xdr->buf->buflen)\r\nreturn NULL;\r\nfrag1bytes = (xdr->end - xdr->p) << 2;\r\nfrag2bytes = nbytes - frag1bytes;\r\nif (xdr->iov)\r\nxdr->iov->iov_len += frag1bytes;\r\nelse\r\nxdr->buf->page_len += frag1bytes;\r\nxdr->page_ptr++;\r\nxdr->iov = NULL;\r\nxdr->scratch.iov_base = xdr->p;\r\nxdr->scratch.iov_len = frag1bytes;\r\np = page_address(*xdr->page_ptr);\r\nxdr->p = (void *)p + frag2bytes;\r\nspace_left = xdr->buf->buflen - xdr->buf->len;\r\nxdr->end = (void *)p + min_t(int, space_left, PAGE_SIZE);\r\nxdr->buf->page_len += frag2bytes;\r\nxdr->buf->len += nbytes;\r\nreturn p;\r\n}\r\n__be32 * xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes)\r\n{\r\n__be32 *p = xdr->p;\r\n__be32 *q;\r\nxdr_commit_encode(xdr);\r\nnbytes += 3;\r\nnbytes &= ~3;\r\nq = p + (nbytes >> 2);\r\nif (unlikely(q > xdr->end || q < p))\r\nreturn xdr_get_next_encode_buffer(xdr, nbytes);\r\nxdr->p = q;\r\nif (xdr->iov)\r\nxdr->iov->iov_len += nbytes;\r\nelse\r\nxdr->buf->page_len += nbytes;\r\nxdr->buf->len += nbytes;\r\nreturn p;\r\n}\r\nvoid xdr_truncate_encode(struct xdr_stream *xdr, size_t len)\r\n{\r\nstruct xdr_buf *buf = xdr->buf;\r\nstruct kvec *head = buf->head;\r\nstruct kvec *tail = buf->tail;\r\nint fraglen;\r\nint new;\r\nif (len > buf->len) {\r\nWARN_ON_ONCE(1);\r\nreturn;\r\n}\r\nxdr_commit_encode(xdr);\r\nfraglen = min_t(int, buf->len - len, tail->iov_len);\r\ntail->iov_len -= fraglen;\r\nbuf->len -= fraglen;\r\nif (tail->iov_len) {\r\nxdr->p = tail->iov_base + tail->iov_len;\r\nWARN_ON_ONCE(!xdr->end);\r\nWARN_ON_ONCE(!xdr->iov);\r\nreturn;\r\n}\r\nWARN_ON_ONCE(fraglen);\r\nfraglen = min_t(int, buf->len - len, buf->page_len);\r\nbuf->page_len -= fraglen;\r\nbuf->len -= fraglen;\r\nnew = buf->page_base + buf->page_len;\r\nxdr->page_ptr = buf->pages + (new >> PAGE_SHIFT);\r\nif (buf->page_len) {\r\nxdr->p = page_address(*xdr->page_ptr);\r\nxdr->end = (void *)xdr->p + PAGE_SIZE;\r\nxdr->p = (void *)xdr->p + (new % PAGE_SIZE);\r\nWARN_ON_ONCE(xdr->iov);\r\nreturn;\r\n}\r\nif (fraglen) {\r\nxdr->end = head->iov_base + head->iov_len;\r\nxdr->page_ptr--;\r\n}\r\nhead->iov_len = len;\r\nbuf->len = len;\r\nxdr->p = head->iov_base + head->iov_len;\r\nxdr->iov = buf->head;\r\n}\r\nint xdr_restrict_buflen(struct xdr_stream *xdr, int newbuflen)\r\n{\r\nstruct xdr_buf *buf = xdr->buf;\r\nint left_in_this_buf = (void *)xdr->end - (void *)xdr->p;\r\nint end_offset = buf->len + left_in_this_buf;\r\nif (newbuflen < 0 || newbuflen < buf->len)\r\nreturn -1;\r\nif (newbuflen > buf->buflen)\r\nreturn 0;\r\nif (newbuflen < end_offset)\r\nxdr->end = (void *)xdr->end + newbuflen - end_offset;\r\nbuf->buflen = newbuflen;\r\nreturn 0;\r\n}\r\nvoid xdr_write_pages(struct xdr_stream *xdr, struct page **pages, unsigned int base,\r\nunsigned int len)\r\n{\r\nstruct xdr_buf *buf = xdr->buf;\r\nstruct kvec *iov = buf->tail;\r\nbuf->pages = pages;\r\nbuf->page_base = base;\r\nbuf->page_len = len;\r\niov->iov_base = (char *)xdr->p;\r\niov->iov_len = 0;\r\nxdr->iov = iov;\r\nif (len & 3) {\r\nunsigned int pad = 4 - (len & 3);\r\nBUG_ON(xdr->p >= xdr->end);\r\niov->iov_base = (char *)xdr->p + (len & 3);\r\niov->iov_len += pad;\r\nlen += pad;\r\n*xdr->p++ = 0;\r\n}\r\nbuf->buflen += len;\r\nbuf->len += len;\r\n}\r\nstatic void xdr_set_iov(struct xdr_stream *xdr, struct kvec *iov,\r\nunsigned int len)\r\n{\r\nif (len > iov->iov_len)\r\nlen = iov->iov_len;\r\nxdr->p = (__be32*)iov->iov_base;\r\nxdr->end = (__be32*)(iov->iov_base + len);\r\nxdr->iov = iov;\r\nxdr->page_ptr = NULL;\r\n}\r\nstatic int xdr_set_page_base(struct xdr_stream *xdr,\r\nunsigned int base, unsigned int len)\r\n{\r\nunsigned int pgnr;\r\nunsigned int maxlen;\r\nunsigned int pgoff;\r\nunsigned int pgend;\r\nvoid *kaddr;\r\nmaxlen = xdr->buf->page_len;\r\nif (base >= maxlen)\r\nreturn -EINVAL;\r\nmaxlen -= base;\r\nif (len > maxlen)\r\nlen = maxlen;\r\nbase += xdr->buf->page_base;\r\npgnr = base >> PAGE_SHIFT;\r\nxdr->page_ptr = &xdr->buf->pages[pgnr];\r\nkaddr = page_address(*xdr->page_ptr);\r\npgoff = base & ~PAGE_MASK;\r\nxdr->p = (__be32*)(kaddr + pgoff);\r\npgend = pgoff + len;\r\nif (pgend > PAGE_SIZE)\r\npgend = PAGE_SIZE;\r\nxdr->end = (__be32*)(kaddr + pgend);\r\nxdr->iov = NULL;\r\nreturn 0;\r\n}\r\nstatic void xdr_set_next_page(struct xdr_stream *xdr)\r\n{\r\nunsigned int newbase;\r\nnewbase = (1 + xdr->page_ptr - xdr->buf->pages) << PAGE_SHIFT;\r\nnewbase -= xdr->buf->page_base;\r\nif (xdr_set_page_base(xdr, newbase, PAGE_SIZE) < 0)\r\nxdr_set_iov(xdr, xdr->buf->tail, xdr->buf->len);\r\n}\r\nstatic bool xdr_set_next_buffer(struct xdr_stream *xdr)\r\n{\r\nif (xdr->page_ptr != NULL)\r\nxdr_set_next_page(xdr);\r\nelse if (xdr->iov == xdr->buf->head) {\r\nif (xdr_set_page_base(xdr, 0, PAGE_SIZE) < 0)\r\nxdr_set_iov(xdr, xdr->buf->tail, xdr->buf->len);\r\n}\r\nreturn xdr->p != xdr->end;\r\n}\r\nvoid xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p)\r\n{\r\nxdr->buf = buf;\r\nxdr->scratch.iov_base = NULL;\r\nxdr->scratch.iov_len = 0;\r\nxdr->nwords = XDR_QUADLEN(buf->len);\r\nif (buf->head[0].iov_len != 0)\r\nxdr_set_iov(xdr, buf->head, buf->len);\r\nelse if (buf->page_len != 0)\r\nxdr_set_page_base(xdr, 0, buf->len);\r\nif (p != NULL && p > xdr->p && xdr->end >= p) {\r\nxdr->nwords -= p - xdr->p;\r\nxdr->p = p;\r\n}\r\n}\r\nvoid xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\r\nstruct page **pages, unsigned int len)\r\n{\r\nmemset(buf, 0, sizeof(*buf));\r\nbuf->pages = pages;\r\nbuf->page_len = len;\r\nbuf->buflen = len;\r\nbuf->len = len;\r\nxdr_init_decode(xdr, buf, NULL);\r\n}\r\nstatic __be32 * __xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\r\n{\r\nunsigned int nwords = XDR_QUADLEN(nbytes);\r\n__be32 *p = xdr->p;\r\n__be32 *q = p + nwords;\r\nif (unlikely(nwords > xdr->nwords || q > xdr->end || q < p))\r\nreturn NULL;\r\nxdr->p = q;\r\nxdr->nwords -= nwords;\r\nreturn p;\r\n}\r\nvoid xdr_set_scratch_buffer(struct xdr_stream *xdr, void *buf, size_t buflen)\r\n{\r\nxdr->scratch.iov_base = buf;\r\nxdr->scratch.iov_len = buflen;\r\n}\r\nstatic __be32 *xdr_copy_to_scratch(struct xdr_stream *xdr, size_t nbytes)\r\n{\r\n__be32 *p;\r\nvoid *cpdest = xdr->scratch.iov_base;\r\nsize_t cplen = (char *)xdr->end - (char *)xdr->p;\r\nif (nbytes > xdr->scratch.iov_len)\r\nreturn NULL;\r\nmemcpy(cpdest, xdr->p, cplen);\r\ncpdest += cplen;\r\nnbytes -= cplen;\r\nif (!xdr_set_next_buffer(xdr))\r\nreturn NULL;\r\np = __xdr_inline_decode(xdr, nbytes);\r\nif (p == NULL)\r\nreturn NULL;\r\nmemcpy(cpdest, p, nbytes);\r\nreturn xdr->scratch.iov_base;\r\n}\r\n__be32 * xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\r\n{\r\n__be32 *p;\r\nif (nbytes == 0)\r\nreturn xdr->p;\r\nif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\r\nreturn NULL;\r\np = __xdr_inline_decode(xdr, nbytes);\r\nif (p != NULL)\r\nreturn p;\r\nreturn xdr_copy_to_scratch(xdr, nbytes);\r\n}\r\nstatic unsigned int xdr_align_pages(struct xdr_stream *xdr, unsigned int len)\r\n{\r\nstruct xdr_buf *buf = xdr->buf;\r\nstruct kvec *iov;\r\nunsigned int nwords = XDR_QUADLEN(len);\r\nunsigned int cur = xdr_stream_pos(xdr);\r\nif (xdr->nwords == 0)\r\nreturn 0;\r\niov = buf->head;\r\nif (iov->iov_len > cur) {\r\nxdr_shrink_bufhead(buf, iov->iov_len - cur);\r\nxdr->nwords = XDR_QUADLEN(buf->len - cur);\r\n}\r\nif (nwords > xdr->nwords) {\r\nnwords = xdr->nwords;\r\nlen = nwords << 2;\r\n}\r\nif (buf->page_len <= len)\r\nlen = buf->page_len;\r\nelse if (nwords < xdr->nwords) {\r\nxdr_shrink_pagelen(buf, buf->page_len - len);\r\nxdr->nwords = XDR_QUADLEN(buf->len - cur);\r\n}\r\nreturn len;\r\n}\r\nunsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len)\r\n{\r\nstruct xdr_buf *buf = xdr->buf;\r\nstruct kvec *iov;\r\nunsigned int nwords;\r\nunsigned int end;\r\nunsigned int padding;\r\nlen = xdr_align_pages(xdr, len);\r\nif (len == 0)\r\nreturn 0;\r\nnwords = XDR_QUADLEN(len);\r\npadding = (nwords << 2) - len;\r\nxdr->iov = iov = buf->tail;\r\nend = ((xdr->nwords - nwords) << 2) + padding;\r\nif (end > iov->iov_len)\r\nend = iov->iov_len;\r\nxdr->p = (__be32 *)((char *)iov->iov_base + padding);\r\nxdr->end = (__be32 *)((char *)iov->iov_base + end);\r\nxdr->page_ptr = NULL;\r\nxdr->nwords = XDR_QUADLEN(end - padding);\r\nreturn len;\r\n}\r\nvoid xdr_enter_page(struct xdr_stream *xdr, unsigned int len)\r\n{\r\nlen = xdr_align_pages(xdr, len);\r\nif (len != 0)\r\nxdr_set_page_base(xdr, 0, len);\r\n}\r\nvoid\r\nxdr_buf_from_iov(struct kvec *iov, struct xdr_buf *buf)\r\n{\r\nbuf->head[0] = *iov;\r\nbuf->tail[0] = empty_iov;\r\nbuf->page_len = 0;\r\nbuf->buflen = buf->len = iov->iov_len;\r\n}\r\nint\r\nxdr_buf_subsegment(struct xdr_buf *buf, struct xdr_buf *subbuf,\r\nunsigned int base, unsigned int len)\r\n{\r\nsubbuf->buflen = subbuf->len = len;\r\nif (base < buf->head[0].iov_len) {\r\nsubbuf->head[0].iov_base = buf->head[0].iov_base + base;\r\nsubbuf->head[0].iov_len = min_t(unsigned int, len,\r\nbuf->head[0].iov_len - base);\r\nlen -= subbuf->head[0].iov_len;\r\nbase = 0;\r\n} else {\r\nbase -= buf->head[0].iov_len;\r\nsubbuf->head[0].iov_len = 0;\r\n}\r\nif (base < buf->page_len) {\r\nsubbuf->page_len = min(buf->page_len - base, len);\r\nbase += buf->page_base;\r\nsubbuf->page_base = base & ~PAGE_CACHE_MASK;\r\nsubbuf->pages = &buf->pages[base >> PAGE_CACHE_SHIFT];\r\nlen -= subbuf->page_len;\r\nbase = 0;\r\n} else {\r\nbase -= buf->page_len;\r\nsubbuf->page_len = 0;\r\n}\r\nif (base < buf->tail[0].iov_len) {\r\nsubbuf->tail[0].iov_base = buf->tail[0].iov_base + base;\r\nsubbuf->tail[0].iov_len = min_t(unsigned int, len,\r\nbuf->tail[0].iov_len - base);\r\nlen -= subbuf->tail[0].iov_len;\r\nbase = 0;\r\n} else {\r\nbase -= buf->tail[0].iov_len;\r\nsubbuf->tail[0].iov_len = 0;\r\n}\r\nif (base || len)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid xdr_buf_trim(struct xdr_buf *buf, unsigned int len)\r\n{\r\nsize_t cur;\r\nunsigned int trim = len;\r\nif (buf->tail[0].iov_len) {\r\ncur = min_t(size_t, buf->tail[0].iov_len, trim);\r\nbuf->tail[0].iov_len -= cur;\r\ntrim -= cur;\r\nif (!trim)\r\ngoto fix_len;\r\n}\r\nif (buf->page_len) {\r\ncur = min_t(unsigned int, buf->page_len, trim);\r\nbuf->page_len -= cur;\r\ntrim -= cur;\r\nif (!trim)\r\ngoto fix_len;\r\n}\r\nif (buf->head[0].iov_len) {\r\ncur = min_t(size_t, buf->head[0].iov_len, trim);\r\nbuf->head[0].iov_len -= cur;\r\ntrim -= cur;\r\n}\r\nfix_len:\r\nbuf->len -= (len - trim);\r\n}\r\nstatic void __read_bytes_from_xdr_buf(struct xdr_buf *subbuf, void *obj, unsigned int len)\r\n{\r\nunsigned int this_len;\r\nthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\r\nmemcpy(obj, subbuf->head[0].iov_base, this_len);\r\nlen -= this_len;\r\nobj += this_len;\r\nthis_len = min_t(unsigned int, len, subbuf->page_len);\r\nif (this_len)\r\n_copy_from_pages(obj, subbuf->pages, subbuf->page_base, this_len);\r\nlen -= this_len;\r\nobj += this_len;\r\nthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\r\nmemcpy(obj, subbuf->tail[0].iov_base, this_len);\r\n}\r\nint read_bytes_from_xdr_buf(struct xdr_buf *buf, unsigned int base, void *obj, unsigned int len)\r\n{\r\nstruct xdr_buf subbuf;\r\nint status;\r\nstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\r\nif (status != 0)\r\nreturn status;\r\n__read_bytes_from_xdr_buf(&subbuf, obj, len);\r\nreturn 0;\r\n}\r\nstatic void __write_bytes_to_xdr_buf(struct xdr_buf *subbuf, void *obj, unsigned int len)\r\n{\r\nunsigned int this_len;\r\nthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\r\nmemcpy(subbuf->head[0].iov_base, obj, this_len);\r\nlen -= this_len;\r\nobj += this_len;\r\nthis_len = min_t(unsigned int, len, subbuf->page_len);\r\nif (this_len)\r\n_copy_to_pages(subbuf->pages, subbuf->page_base, obj, this_len);\r\nlen -= this_len;\r\nobj += this_len;\r\nthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\r\nmemcpy(subbuf->tail[0].iov_base, obj, this_len);\r\n}\r\nint write_bytes_to_xdr_buf(struct xdr_buf *buf, unsigned int base, void *obj, unsigned int len)\r\n{\r\nstruct xdr_buf subbuf;\r\nint status;\r\nstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\r\nif (status != 0)\r\nreturn status;\r\n__write_bytes_to_xdr_buf(&subbuf, obj, len);\r\nreturn 0;\r\n}\r\nint\r\nxdr_decode_word(struct xdr_buf *buf, unsigned int base, u32 *obj)\r\n{\r\n__be32 raw;\r\nint status;\r\nstatus = read_bytes_from_xdr_buf(buf, base, &raw, sizeof(*obj));\r\nif (status)\r\nreturn status;\r\n*obj = be32_to_cpu(raw);\r\nreturn 0;\r\n}\r\nint\r\nxdr_encode_word(struct xdr_buf *buf, unsigned int base, u32 obj)\r\n{\r\n__be32 raw = cpu_to_be32(obj);\r\nreturn write_bytes_to_xdr_buf(buf, base, &raw, sizeof(obj));\r\n}\r\nint xdr_buf_read_netobj(struct xdr_buf *buf, struct xdr_netobj *obj, unsigned int offset)\r\n{\r\nstruct xdr_buf subbuf;\r\nif (xdr_decode_word(buf, offset, &obj->len))\r\nreturn -EFAULT;\r\nif (xdr_buf_subsegment(buf, &subbuf, offset + 4, obj->len))\r\nreturn -EFAULT;\r\nobj->data = subbuf.head[0].iov_base;\r\nif (subbuf.head[0].iov_len == obj->len)\r\nreturn 0;\r\nobj->data = subbuf.tail[0].iov_base;\r\nif (subbuf.tail[0].iov_len == obj->len)\r\nreturn 0;\r\nif (obj->len > buf->buflen - buf->len)\r\nreturn -ENOMEM;\r\nif (buf->tail[0].iov_len != 0)\r\nobj->data = buf->tail[0].iov_base + buf->tail[0].iov_len;\r\nelse\r\nobj->data = buf->head[0].iov_base + buf->head[0].iov_len;\r\n__read_bytes_from_xdr_buf(&subbuf, obj->data, obj->len);\r\nreturn 0;\r\n}\r\nstatic int\r\nxdr_xcode_array2(struct xdr_buf *buf, unsigned int base,\r\nstruct xdr_array2_desc *desc, int encode)\r\n{\r\nchar *elem = NULL, *c;\r\nunsigned int copied = 0, todo, avail_here;\r\nstruct page **ppages = NULL;\r\nint err;\r\nif (encode) {\r\nif (xdr_encode_word(buf, base, desc->array_len) != 0)\r\nreturn -EINVAL;\r\n} else {\r\nif (xdr_decode_word(buf, base, &desc->array_len) != 0 ||\r\ndesc->array_len > desc->array_maxlen ||\r\n(unsigned long) base + 4 + desc->array_len *\r\ndesc->elem_size > buf->len)\r\nreturn -EINVAL;\r\n}\r\nbase += 4;\r\nif (!desc->xcode)\r\nreturn 0;\r\ntodo = desc->array_len * desc->elem_size;\r\nif (todo && base < buf->head->iov_len) {\r\nc = buf->head->iov_base + base;\r\navail_here = min_t(unsigned int, todo,\r\nbuf->head->iov_len - base);\r\ntodo -= avail_here;\r\nwhile (avail_here >= desc->elem_size) {\r\nerr = desc->xcode(desc, c);\r\nif (err)\r\ngoto out;\r\nc += desc->elem_size;\r\navail_here -= desc->elem_size;\r\n}\r\nif (avail_here) {\r\nif (!elem) {\r\nelem = kmalloc(desc->elem_size, GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!elem)\r\ngoto out;\r\n}\r\nif (encode) {\r\nerr = desc->xcode(desc, elem);\r\nif (err)\r\ngoto out;\r\nmemcpy(c, elem, avail_here);\r\n} else\r\nmemcpy(elem, c, avail_here);\r\ncopied = avail_here;\r\n}\r\nbase = buf->head->iov_len;\r\n}\r\nbase -= buf->head->iov_len;\r\nif (todo && base < buf->page_len) {\r\nunsigned int avail_page;\r\navail_here = min(todo, buf->page_len - base);\r\ntodo -= avail_here;\r\nbase += buf->page_base;\r\nppages = buf->pages + (base >> PAGE_CACHE_SHIFT);\r\nbase &= ~PAGE_CACHE_MASK;\r\navail_page = min_t(unsigned int, PAGE_CACHE_SIZE - base,\r\navail_here);\r\nc = kmap(*ppages) + base;\r\nwhile (avail_here) {\r\navail_here -= avail_page;\r\nif (copied || avail_page < desc->elem_size) {\r\nunsigned int l = min(avail_page,\r\ndesc->elem_size - copied);\r\nif (!elem) {\r\nelem = kmalloc(desc->elem_size,\r\nGFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!elem)\r\ngoto out;\r\n}\r\nif (encode) {\r\nif (!copied) {\r\nerr = desc->xcode(desc, elem);\r\nif (err)\r\ngoto out;\r\n}\r\nmemcpy(c, elem + copied, l);\r\ncopied += l;\r\nif (copied == desc->elem_size)\r\ncopied = 0;\r\n} else {\r\nmemcpy(elem + copied, c, l);\r\ncopied += l;\r\nif (copied == desc->elem_size) {\r\nerr = desc->xcode(desc, elem);\r\nif (err)\r\ngoto out;\r\ncopied = 0;\r\n}\r\n}\r\navail_page -= l;\r\nc += l;\r\n}\r\nwhile (avail_page >= desc->elem_size) {\r\nerr = desc->xcode(desc, c);\r\nif (err)\r\ngoto out;\r\nc += desc->elem_size;\r\navail_page -= desc->elem_size;\r\n}\r\nif (avail_page) {\r\nunsigned int l = min(avail_page,\r\ndesc->elem_size - copied);\r\nif (!elem) {\r\nelem = kmalloc(desc->elem_size,\r\nGFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!elem)\r\ngoto out;\r\n}\r\nif (encode) {\r\nif (!copied) {\r\nerr = desc->xcode(desc, elem);\r\nif (err)\r\ngoto out;\r\n}\r\nmemcpy(c, elem + copied, l);\r\ncopied += l;\r\nif (copied == desc->elem_size)\r\ncopied = 0;\r\n} else {\r\nmemcpy(elem + copied, c, l);\r\ncopied += l;\r\nif (copied == desc->elem_size) {\r\nerr = desc->xcode(desc, elem);\r\nif (err)\r\ngoto out;\r\ncopied = 0;\r\n}\r\n}\r\n}\r\nif (avail_here) {\r\nkunmap(*ppages);\r\nppages++;\r\nc = kmap(*ppages);\r\n}\r\navail_page = min(avail_here,\r\n(unsigned int) PAGE_CACHE_SIZE);\r\n}\r\nbase = buf->page_len;\r\n}\r\nbase -= buf->page_len;\r\nif (todo) {\r\nc = buf->tail->iov_base + base;\r\nif (copied) {\r\nunsigned int l = desc->elem_size - copied;\r\nif (encode)\r\nmemcpy(c, elem + copied, l);\r\nelse {\r\nmemcpy(elem + copied, c, l);\r\nerr = desc->xcode(desc, elem);\r\nif (err)\r\ngoto out;\r\n}\r\ntodo -= l;\r\nc += l;\r\n}\r\nwhile (todo) {\r\nerr = desc->xcode(desc, c);\r\nif (err)\r\ngoto out;\r\nc += desc->elem_size;\r\ntodo -= desc->elem_size;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nkfree(elem);\r\nif (ppages)\r\nkunmap(*ppages);\r\nreturn err;\r\n}\r\nint\r\nxdr_decode_array2(struct xdr_buf *buf, unsigned int base,\r\nstruct xdr_array2_desc *desc)\r\n{\r\nif (base >= buf->len)\r\nreturn -EINVAL;\r\nreturn xdr_xcode_array2(buf, base, desc, 0);\r\n}\r\nint\r\nxdr_encode_array2(struct xdr_buf *buf, unsigned int base,\r\nstruct xdr_array2_desc *desc)\r\n{\r\nif ((unsigned long) base + 4 + desc->array_len * desc->elem_size >\r\nbuf->head->iov_len + buf->page_len + buf->tail->iov_len)\r\nreturn -EINVAL;\r\nreturn xdr_xcode_array2(buf, base, desc, 1);\r\n}\r\nint\r\nxdr_process_buf(struct xdr_buf *buf, unsigned int offset, unsigned int len,\r\nint (*actor)(struct scatterlist *, void *), void *data)\r\n{\r\nint i, ret = 0;\r\nunsigned int page_len, thislen, page_offset;\r\nstruct scatterlist sg[1];\r\nsg_init_table(sg, 1);\r\nif (offset >= buf->head[0].iov_len) {\r\noffset -= buf->head[0].iov_len;\r\n} else {\r\nthislen = buf->head[0].iov_len - offset;\r\nif (thislen > len)\r\nthislen = len;\r\nsg_set_buf(sg, buf->head[0].iov_base + offset, thislen);\r\nret = actor(sg, data);\r\nif (ret)\r\ngoto out;\r\noffset = 0;\r\nlen -= thislen;\r\n}\r\nif (len == 0)\r\ngoto out;\r\nif (offset >= buf->page_len) {\r\noffset -= buf->page_len;\r\n} else {\r\npage_len = buf->page_len - offset;\r\nif (page_len > len)\r\npage_len = len;\r\nlen -= page_len;\r\npage_offset = (offset + buf->page_base) & (PAGE_CACHE_SIZE - 1);\r\ni = (offset + buf->page_base) >> PAGE_CACHE_SHIFT;\r\nthislen = PAGE_CACHE_SIZE - page_offset;\r\ndo {\r\nif (thislen > page_len)\r\nthislen = page_len;\r\nsg_set_page(sg, buf->pages[i], thislen, page_offset);\r\nret = actor(sg, data);\r\nif (ret)\r\ngoto out;\r\npage_len -= thislen;\r\ni++;\r\npage_offset = 0;\r\nthislen = PAGE_CACHE_SIZE;\r\n} while (page_len != 0);\r\noffset = 0;\r\n}\r\nif (len == 0)\r\ngoto out;\r\nif (offset < buf->tail[0].iov_len) {\r\nthislen = buf->tail[0].iov_len - offset;\r\nif (thislen > len)\r\nthislen = len;\r\nsg_set_buf(sg, buf->tail[0].iov_base + offset, thislen);\r\nret = actor(sg, data);\r\nlen -= thislen;\r\n}\r\nif (len != 0)\r\nret = -EINVAL;\r\nout:\r\nreturn ret;\r\n}
