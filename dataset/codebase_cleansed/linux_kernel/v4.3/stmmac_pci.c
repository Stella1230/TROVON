static int stmmac_pci_find_phy_addr(struct stmmac_pci_info *info)\r\n{\r\nconst char *name = dmi_get_system_info(DMI_BOARD_NAME);\r\nunsigned int func = PCI_FUNC(info->pdev->devfn);\r\nstruct stmmac_pci_dmi_data *dmi;\r\nif (!name)\r\nreturn 1;\r\nfor (dmi = info->dmi; dmi->name && *dmi->name; dmi++) {\r\nif (!strcmp(dmi->name, name) && dmi->func == func)\r\nreturn dmi->phy_addr;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void stmmac_default_data(struct plat_stmmacenet_data *plat)\r\n{\r\nplat->bus_id = 1;\r\nplat->phy_addr = 0;\r\nplat->interface = PHY_INTERFACE_MODE_GMII;\r\nplat->clk_csr = 2;\r\nplat->has_gmac = 1;\r\nplat->force_sf_dma_mode = 1;\r\nplat->mdio_bus_data->phy_reset = NULL;\r\nplat->mdio_bus_data->phy_mask = 0;\r\nplat->dma_cfg->pbl = 32;\r\nplat->dma_cfg->burst_len = DMA_AXI_BLEN_256;\r\nplat->multicast_filter_bins = HASH_TABLE_SIZE;\r\nplat->unicast_filter_entries = 1;\r\n}\r\nstatic int quark_default_data(struct plat_stmmacenet_data *plat,\r\nstruct stmmac_pci_info *info)\r\n{\r\nstruct pci_dev *pdev = info->pdev;\r\nint ret;\r\nret = stmmac_pci_find_phy_addr(info);\r\nif (ret < 0)\r\nreturn ret;\r\nplat->bus_id = PCI_DEVID(pdev->bus->number, pdev->devfn);\r\nplat->phy_addr = ret;\r\nplat->interface = PHY_INTERFACE_MODE_RMII;\r\nplat->clk_csr = 2;\r\nplat->has_gmac = 1;\r\nplat->force_sf_dma_mode = 1;\r\nplat->mdio_bus_data->phy_reset = NULL;\r\nplat->mdio_bus_data->phy_mask = 0;\r\nplat->dma_cfg->pbl = 16;\r\nplat->dma_cfg->burst_len = DMA_AXI_BLEN_256;\r\nplat->dma_cfg->fixed_burst = 1;\r\nplat->multicast_filter_bins = HASH_TABLE_SIZE;\r\nplat->unicast_filter_entries = 1;\r\nreturn 0;\r\n}\r\nstatic int stmmac_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct stmmac_pci_info *info = (struct stmmac_pci_info *)id->driver_data;\r\nstruct plat_stmmacenet_data *plat;\r\nstruct stmmac_resources res;\r\nint i;\r\nint ret;\r\nplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\r\nif (!plat)\r\nreturn -ENOMEM;\r\nplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\r\nsizeof(*plat->mdio_bus_data),\r\nGFP_KERNEL);\r\nif (!plat->mdio_bus_data)\r\nreturn -ENOMEM;\r\nplat->dma_cfg = devm_kzalloc(&pdev->dev, sizeof(*plat->dma_cfg),\r\nGFP_KERNEL);\r\nif (!plat->dma_cfg)\r\nreturn -ENOMEM;\r\nret = pcim_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "%s: ERROR: failed to enable device\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nfor (i = 0; i <= PCI_STD_RESOURCE_END; i++) {\r\nif (pci_resource_len(pdev, i) == 0)\r\ncontinue;\r\nret = pcim_iomap_regions(pdev, BIT(i), pci_name(pdev));\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\npci_set_master(pdev);\r\nif (info) {\r\ninfo->pdev = pdev;\r\nif (info->setup) {\r\nret = info->setup(plat, info);\r\nif (ret)\r\nreturn ret;\r\n}\r\n} else\r\nstmmac_default_data(plat);\r\npci_enable_msi(pdev);\r\nmemset(&res, 0, sizeof(res));\r\nres.addr = pcim_iomap_table(pdev)[i];\r\nres.wol_irq = pdev->irq;\r\nres.irq = pdev->irq;\r\nreturn stmmac_dvr_probe(&pdev->dev, plat, &res);\r\n}\r\nstatic void stmmac_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nstmmac_dvr_remove(ndev);\r\n}\r\nstatic int stmmac_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nreturn stmmac_suspend(ndev);\r\n}\r\nstatic int stmmac_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct net_device *ndev = pci_get_drvdata(pdev);\r\nreturn stmmac_resume(ndev);\r\n}
