static int __dw_read_encoded_value(u8 **p, u8 *end, u64 *val,\r\nu8 encoding)\r\n{\r\nu8 *cur = *p;\r\n*val = 0;\r\nswitch (encoding) {\r\ncase DW_EH_PE_omit:\r\n*val = 0;\r\ngoto out;\r\ncase DW_EH_PE_ptr:\r\n*val = dw_read(cur, unsigned long, end);\r\ngoto out;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (encoding & DW_EH_PE_APPL_MASK) {\r\ncase DW_EH_PE_absptr:\r\nbreak;\r\ncase DW_EH_PE_pcrel:\r\n*val = (unsigned long) cur;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((encoding & 0x07) == 0x00)\r\nencoding |= DW_EH_PE_udata4;\r\nswitch (encoding & DW_EH_PE_FORMAT_MASK) {\r\ncase DW_EH_PE_sdata4:\r\n*val += dw_read(cur, s32, end);\r\nbreak;\r\ncase DW_EH_PE_udata4:\r\n*val += dw_read(cur, u32, end);\r\nbreak;\r\ncase DW_EH_PE_sdata8:\r\n*val += dw_read(cur, s64, end);\r\nbreak;\r\ncase DW_EH_PE_udata8:\r\n*val += dw_read(cur, u64, end);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout:\r\n*p = cur;\r\nreturn 0;\r\n}\r\nstatic u64 elf_section_offset(int fd, const char *name)\r\n{\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nu64 offset = 0;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL)\r\nreturn 0;\r\ndo {\r\nif (gelf_getehdr(elf, &ehdr) == NULL)\r\nbreak;\r\nif (!elf_section_by_name(elf, &ehdr, &shdr, name, NULL))\r\nbreak;\r\noffset = shdr.sh_offset;\r\n} while (0);\r\nelf_end(elf);\r\nreturn offset;\r\n}\r\nstatic int elf_is_exec(int fd, const char *name)\r\n{\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nint retval = 0;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL)\r\nreturn 0;\r\nif (gelf_getehdr(elf, &ehdr) == NULL)\r\ngoto out;\r\nretval = (ehdr.e_type == ET_EXEC);\r\nout:\r\nelf_end(elf);\r\npr_debug("unwind: elf_is_exec(%s): %d\n", name, retval);\r\nreturn retval;\r\n}\r\nstatic int unwind_spec_ehframe(struct dso *dso, struct machine *machine,\r\nu64 offset, u64 *table_data, u64 *segbase,\r\nu64 *fde_count)\r\n{\r\nstruct eh_frame_hdr hdr;\r\nu8 *enc = (u8 *) &hdr.enc;\r\nu8 *end = (u8 *) &hdr.data;\r\nssize_t r;\r\nr = dso__data_read_offset(dso, machine, offset,\r\n(u8 *) &hdr, sizeof(hdr));\r\nif (r != sizeof(hdr))\r\nreturn -EINVAL;\r\ndw_read_encoded_value(enc, end, hdr.eh_frame_ptr_enc);\r\n*fde_count = dw_read_encoded_value(enc, end, hdr.fde_count_enc);\r\n*segbase = offset;\r\n*table_data = (enc - (u8 *) &hdr) + offset;\r\nreturn 0;\r\n}\r\nstatic int read_unwind_spec_eh_frame(struct dso *dso, struct machine *machine,\r\nu64 *table_data, u64 *segbase,\r\nu64 *fde_count)\r\n{\r\nint ret = -EINVAL, fd;\r\nu64 offset = dso->data.eh_frame_hdr_offset;\r\nif (offset == 0) {\r\nfd = dso__data_get_fd(dso, machine);\r\nif (fd < 0)\r\nreturn -EINVAL;\r\noffset = elf_section_offset(fd, ".eh_frame_hdr");\r\ndso->data.eh_frame_hdr_offset = offset;\r\ndso__data_put_fd(dso);\r\n}\r\nif (offset)\r\nret = unwind_spec_ehframe(dso, machine, offset,\r\ntable_data, segbase,\r\nfde_count);\r\nreturn ret;\r\n}\r\nstatic int read_unwind_spec_debug_frame(struct dso *dso,\r\nstruct machine *machine, u64 *offset)\r\n{\r\nint fd;\r\nu64 ofs = dso->data.debug_frame_offset;\r\nif (ofs == 0) {\r\nfd = dso__data_get_fd(dso, machine);\r\nif (fd < 0)\r\nreturn -EINVAL;\r\nofs = elf_section_offset(fd, ".debug_frame");\r\ndso->data.debug_frame_offset = ofs;\r\ndso__data_put_fd(dso);\r\n}\r\n*offset = ofs;\r\nif (*offset)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic struct map *find_map(unw_word_t ip, struct unwind_info *ui)\r\n{\r\nstruct addr_location al;\r\nthread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,\r\nMAP__FUNCTION, ip, &al);\r\nreturn al.map;\r\n}\r\nstatic int\r\nfind_proc_info(unw_addr_space_t as, unw_word_t ip, unw_proc_info_t *pi,\r\nint need_unwind_info, void *arg)\r\n{\r\nstruct unwind_info *ui = arg;\r\nstruct map *map;\r\nunw_dyn_info_t di;\r\nu64 table_data, segbase, fde_count;\r\nmap = find_map(ip, ui);\r\nif (!map || !map->dso)\r\nreturn -EINVAL;\r\npr_debug("unwind: find_proc_info dso %s\n", map->dso->name);\r\nif (!read_unwind_spec_eh_frame(map->dso, ui->machine,\r\n&table_data, &segbase, &fde_count)) {\r\nmemset(&di, 0, sizeof(di));\r\ndi.format = UNW_INFO_FORMAT_REMOTE_TABLE;\r\ndi.start_ip = map->start;\r\ndi.end_ip = map->end;\r\ndi.u.rti.segbase = map->start + segbase;\r\ndi.u.rti.table_data = map->start + table_data;\r\ndi.u.rti.table_len = fde_count * sizeof(struct table_entry)\r\n/ sizeof(unw_word_t);\r\nreturn dwarf_search_unwind_table(as, ip, &di, pi,\r\nneed_unwind_info, arg);\r\n}\r\n#ifndef NO_LIBUNWIND_DEBUG_FRAME\r\nif (!read_unwind_spec_debug_frame(map->dso, ui->machine, &segbase)) {\r\nint fd = dso__data_get_fd(map->dso, ui->machine);\r\nint is_exec = elf_is_exec(fd, map->dso->name);\r\nunw_word_t base = is_exec ? 0 : map->start;\r\nif (fd >= 0)\r\ndso__data_put_fd(map->dso);\r\nmemset(&di, 0, sizeof(di));\r\nif (dwarf_find_debug_frame(0, &di, ip, base, map->dso->name,\r\nmap->start, map->end))\r\nreturn dwarf_search_unwind_table(as, ip, &di, pi,\r\nneed_unwind_info, arg);\r\n}\r\n#endif\r\nreturn -EINVAL;\r\n}\r\nstatic int access_fpreg(unw_addr_space_t __maybe_unused as,\r\nunw_regnum_t __maybe_unused num,\r\nunw_fpreg_t __maybe_unused *val,\r\nint __maybe_unused __write,\r\nvoid __maybe_unused *arg)\r\n{\r\npr_err("unwind: access_fpreg unsupported\n");\r\nreturn -UNW_EINVAL;\r\n}\r\nstatic int get_dyn_info_list_addr(unw_addr_space_t __maybe_unused as,\r\nunw_word_t __maybe_unused *dil_addr,\r\nvoid __maybe_unused *arg)\r\n{\r\nreturn -UNW_ENOINFO;\r\n}\r\nstatic int resume(unw_addr_space_t __maybe_unused as,\r\nunw_cursor_t __maybe_unused *cu,\r\nvoid __maybe_unused *arg)\r\n{\r\npr_err("unwind: resume unsupported\n");\r\nreturn -UNW_EINVAL;\r\n}\r\nstatic int\r\nget_proc_name(unw_addr_space_t __maybe_unused as,\r\nunw_word_t __maybe_unused addr,\r\nchar __maybe_unused *bufp, size_t __maybe_unused buf_len,\r\nunw_word_t __maybe_unused *offp, void __maybe_unused *arg)\r\n{\r\npr_err("unwind: get_proc_name unsupported\n");\r\nreturn -UNW_EINVAL;\r\n}\r\nstatic int access_dso_mem(struct unwind_info *ui, unw_word_t addr,\r\nunw_word_t *data)\r\n{\r\nstruct addr_location al;\r\nssize_t size;\r\nthread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,\r\nMAP__FUNCTION, addr, &al);\r\nif (!al.map) {\r\npr_debug("unwind: no map for %lx\n", (unsigned long)addr);\r\nreturn -1;\r\n}\r\nif (!al.map->dso)\r\nreturn -1;\r\nsize = dso__data_read_addr(al.map->dso, al.map, ui->machine,\r\naddr, (u8 *) data, sizeof(*data));\r\nreturn !(size == sizeof(*data));\r\n}\r\nstatic int access_mem(unw_addr_space_t __maybe_unused as,\r\nunw_word_t addr, unw_word_t *valp,\r\nint __write, void *arg)\r\n{\r\nstruct unwind_info *ui = arg;\r\nstruct stack_dump *stack = &ui->sample->user_stack;\r\nu64 start, end;\r\nint offset;\r\nint ret;\r\nif (__write || !stack || !ui->sample->user_regs.regs) {\r\n*valp = 0;\r\nreturn 0;\r\n}\r\nret = perf_reg_value(&start, &ui->sample->user_regs, PERF_REG_SP);\r\nif (ret)\r\nreturn ret;\r\nend = start + stack->size;\r\nif (addr + sizeof(unw_word_t) < addr)\r\nreturn -EINVAL;\r\nif (addr < start || addr + sizeof(unw_word_t) >= end) {\r\nret = access_dso_mem(ui, addr, valp);\r\nif (ret) {\r\npr_debug("unwind: access_mem %p not inside range"\r\n" 0x%" PRIx64 "-0x%" PRIx64 "\n",\r\n(void *) addr, start, end);\r\n*valp = 0;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\noffset = addr - start;\r\n*valp = *(unw_word_t *)&stack->data[offset];\r\npr_debug("unwind: access_mem addr %p val %lx, offset %d\n",\r\n(void *) addr, (unsigned long)*valp, offset);\r\nreturn 0;\r\n}\r\nstatic int access_reg(unw_addr_space_t __maybe_unused as,\r\nunw_regnum_t regnum, unw_word_t *valp,\r\nint __write, void *arg)\r\n{\r\nstruct unwind_info *ui = arg;\r\nint id, ret;\r\nu64 val;\r\nif (__write) {\r\npr_err("unwind: access_reg w %d\n", regnum);\r\nreturn 0;\r\n}\r\nif (!ui->sample->user_regs.regs) {\r\n*valp = 0;\r\nreturn 0;\r\n}\r\nid = libunwind__arch_reg_id(regnum);\r\nif (id < 0)\r\nreturn -EINVAL;\r\nret = perf_reg_value(&val, &ui->sample->user_regs, id);\r\nif (ret) {\r\npr_err("unwind: can't read reg %d\n", regnum);\r\nreturn ret;\r\n}\r\n*valp = (unw_word_t) val;\r\npr_debug("unwind: reg %d, val %lx\n", regnum, (unsigned long)*valp);\r\nreturn 0;\r\n}\r\nstatic void put_unwind_info(unw_addr_space_t __maybe_unused as,\r\nunw_proc_info_t *pi __maybe_unused,\r\nvoid *arg __maybe_unused)\r\n{\r\npr_debug("unwind: put_unwind_info called\n");\r\n}\r\nstatic int entry(u64 ip, struct thread *thread,\r\nunwind_entry_cb_t cb, void *arg)\r\n{\r\nstruct unwind_entry e;\r\nstruct addr_location al;\r\nthread__find_addr_location(thread, PERF_RECORD_MISC_USER,\r\nMAP__FUNCTION, ip, &al);\r\ne.ip = ip;\r\ne.map = al.map;\r\ne.sym = al.sym;\r\npr_debug("unwind: %s:ip = 0x%" PRIx64 " (0x%" PRIx64 ")\n",\r\nal.sym ? al.sym->name : "''",\r\nip,\r\nal.map ? al.map->map_ip(al.map, ip) : (u64) 0);\r\nreturn cb(&e, arg);\r\n}\r\nstatic void display_error(int err)\r\n{\r\nswitch (err) {\r\ncase UNW_EINVAL:\r\npr_err("unwind: Only supports local.\n");\r\nbreak;\r\ncase UNW_EUNSPEC:\r\npr_err("unwind: Unspecified error.\n");\r\nbreak;\r\ncase UNW_EBADREG:\r\npr_err("unwind: Register unavailable.\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint unwind__prepare_access(struct thread *thread)\r\n{\r\nunw_addr_space_t addr_space;\r\nif (callchain_param.record_mode != CALLCHAIN_DWARF)\r\nreturn 0;\r\naddr_space = unw_create_addr_space(&accessors, 0);\r\nif (!addr_space) {\r\npr_err("unwind: Can't create unwind address space.\n");\r\nreturn -ENOMEM;\r\n}\r\nunw_set_caching_policy(addr_space, UNW_CACHE_GLOBAL);\r\nthread__set_priv(thread, addr_space);\r\nreturn 0;\r\n}\r\nvoid unwind__flush_access(struct thread *thread)\r\n{\r\nunw_addr_space_t addr_space;\r\nif (callchain_param.record_mode != CALLCHAIN_DWARF)\r\nreturn;\r\naddr_space = thread__priv(thread);\r\nunw_flush_cache(addr_space, 0, 0);\r\n}\r\nvoid unwind__finish_access(struct thread *thread)\r\n{\r\nunw_addr_space_t addr_space;\r\nif (callchain_param.record_mode != CALLCHAIN_DWARF)\r\nreturn;\r\naddr_space = thread__priv(thread);\r\nunw_destroy_addr_space(addr_space);\r\n}\r\nstatic int get_entries(struct unwind_info *ui, unwind_entry_cb_t cb,\r\nvoid *arg, int max_stack)\r\n{\r\nunw_addr_space_t addr_space;\r\nunw_cursor_t c;\r\nint ret;\r\naddr_space = thread__priv(ui->thread);\r\nif (addr_space == NULL)\r\nreturn -1;\r\nret = unw_init_remote(&c, addr_space, ui);\r\nif (ret)\r\ndisplay_error(ret);\r\nwhile (!ret && (unw_step(&c) > 0) && max_stack--) {\r\nunw_word_t ip;\r\nunw_get_reg(&c, UNW_REG_IP, &ip);\r\nret = ip ? entry(ip, ui->thread, cb, arg) : 0;\r\n}\r\nreturn ret;\r\n}\r\nint unwind__get_entries(unwind_entry_cb_t cb, void *arg,\r\nstruct thread *thread,\r\nstruct perf_sample *data, int max_stack)\r\n{\r\nu64 ip;\r\nstruct unwind_info ui = {\r\n.sample = data,\r\n.thread = thread,\r\n.machine = thread->mg->machine,\r\n};\r\nint ret;\r\nif (!data->user_regs.regs)\r\nreturn -EINVAL;\r\nret = perf_reg_value(&ip, &data->user_regs, PERF_REG_IP);\r\nif (ret)\r\nreturn ret;\r\nret = entry(ip, thread, cb, arg);\r\nif (ret)\r\nreturn -ENOMEM;\r\nreturn --max_stack > 0 ? get_entries(&ui, cb, arg, max_stack) : 0;\r\n}
