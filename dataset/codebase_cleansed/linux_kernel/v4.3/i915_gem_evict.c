static bool\r\nmark_free(struct i915_vma *vma, struct list_head *unwind)\r\n{\r\nif (vma->pin_count)\r\nreturn false;\r\nif (WARN_ON(!list_empty(&vma->exec_list)))\r\nreturn false;\r\nlist_add(&vma->exec_list, unwind);\r\nreturn drm_mm_scan_add_block(&vma->node);\r\n}\r\nint\r\ni915_gem_evict_something(struct drm_device *dev, struct i915_address_space *vm,\r\nint min_size, unsigned alignment, unsigned cache_level,\r\nunsigned long start, unsigned long end,\r\nunsigned flags)\r\n{\r\nstruct list_head eviction_list, unwind_list;\r\nstruct i915_vma *vma;\r\nint ret = 0;\r\nint pass = 0;\r\ntrace_i915_gem_evict(dev, min_size, alignment, flags);\r\nINIT_LIST_HEAD(&unwind_list);\r\nif (start != 0 || end != vm->total) {\r\ndrm_mm_init_scan_with_range(&vm->mm, min_size,\r\nalignment, cache_level,\r\nstart, end);\r\n} else\r\ndrm_mm_init_scan(&vm->mm, min_size, alignment, cache_level);\r\nsearch_again:\r\nlist_for_each_entry(vma, &vm->inactive_list, mm_list) {\r\nif (mark_free(vma, &unwind_list))\r\ngoto found;\r\n}\r\nif (flags & PIN_NONBLOCK)\r\ngoto none;\r\nlist_for_each_entry(vma, &vm->active_list, mm_list) {\r\nif (mark_free(vma, &unwind_list))\r\ngoto found;\r\n}\r\nnone:\r\nwhile (!list_empty(&unwind_list)) {\r\nvma = list_first_entry(&unwind_list,\r\nstruct i915_vma,\r\nexec_list);\r\nret = drm_mm_scan_remove_block(&vma->node);\r\nBUG_ON(ret);\r\nlist_del_init(&vma->exec_list);\r\n}\r\nif (flags & PIN_NONBLOCK)\r\nreturn -ENOSPC;\r\nif (pass++ == 0) {\r\nret = i915_gpu_idle(dev);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_retire_requests(dev);\r\ngoto search_again;\r\n}\r\nreturn intel_has_pending_fb_unpin(dev) ? -EAGAIN : -ENOSPC;\r\nfound:\r\nINIT_LIST_HEAD(&eviction_list);\r\nwhile (!list_empty(&unwind_list)) {\r\nvma = list_first_entry(&unwind_list,\r\nstruct i915_vma,\r\nexec_list);\r\nif (drm_mm_scan_remove_block(&vma->node)) {\r\nlist_move(&vma->exec_list, &eviction_list);\r\ndrm_gem_object_reference(&vma->obj->base);\r\ncontinue;\r\n}\r\nlist_del_init(&vma->exec_list);\r\n}\r\nwhile (!list_empty(&eviction_list)) {\r\nstruct drm_gem_object *obj;\r\nvma = list_first_entry(&eviction_list,\r\nstruct i915_vma,\r\nexec_list);\r\nobj = &vma->obj->base;\r\nlist_del_init(&vma->exec_list);\r\nif (ret == 0)\r\nret = i915_vma_unbind(vma);\r\ndrm_gem_object_unreference(obj);\r\n}\r\nreturn ret;\r\n}\r\nint i915_gem_evict_vm(struct i915_address_space *vm, bool do_idle)\r\n{\r\nstruct i915_vma *vma, *next;\r\nint ret;\r\nWARN_ON(!mutex_is_locked(&vm->dev->struct_mutex));\r\ntrace_i915_gem_evict_vm(vm);\r\nif (do_idle) {\r\nret = i915_gpu_idle(vm->dev);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_retire_requests(vm->dev);\r\nWARN_ON(!list_empty(&vm->active_list));\r\n}\r\nlist_for_each_entry_safe(vma, next, &vm->inactive_list, mm_list)\r\nif (vma->pin_count == 0)\r\nWARN_ON(i915_vma_unbind(vma));\r\nreturn 0;\r\n}\r\nint\r\ni915_gem_evict_everything(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct i915_address_space *vm, *v;\r\nbool lists_empty = true;\r\nint ret;\r\nlist_for_each_entry(vm, &dev_priv->vm_list, global_link) {\r\nlists_empty = (list_empty(&vm->inactive_list) &&\r\nlist_empty(&vm->active_list));\r\nif (!lists_empty)\r\nlists_empty = false;\r\n}\r\nif (lists_empty)\r\nreturn -ENOSPC;\r\ntrace_i915_gem_evict_everything(dev);\r\nret = i915_gpu_idle(dev);\r\nif (ret)\r\nreturn ret;\r\ni915_gem_retire_requests(dev);\r\nlist_for_each_entry_safe(vm, v, &dev_priv->vm_list, global_link)\r\nWARN_ON(i915_gem_evict_vm(vm, false));\r\nreturn 0;\r\n}
