static int vv6410_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nint err = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nerr = vv6410_set_hflip(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nerr = vv6410_set_vflip(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nerr = vv6410_set_analog_gain(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nerr = vv6410_set_exposure(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int vv6410_probe(struct sd *sd)\r\n{\r\nu16 data;\r\nint err;\r\nerr = stv06xx_read_sensor(sd, VV6410_DEVICEH, &data);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nif (data != 0x19)\r\nreturn -ENODEV;\r\npr_info("vv6410 sensor detected\n");\r\nsd->gspca_dev.cam.cam_mode = vv6410_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(vv6410_mode);\r\nreturn 0;\r\n}\r\nstatic int vv6410_init_controls(struct sd *sd)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 2);\r\nv4l2_ctrl_new_std(hdl, &vv6410_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 32768, 1, 20000);\r\nv4l2_ctrl_new_std(hdl, &vv6410_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 15, 1, 10);\r\nreturn hdl->error;\r\n}\r\nstatic int vv6410_init(struct sd *sd)\r\n{\r\nint err = 0, i;\r\nfor (i = 0; i < ARRAY_SIZE(stv_bridge_init); i++)\r\nstv06xx_write_bridge(sd, stv_bridge_init[i].addr, stv_bridge_init[i].data);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor_bytes(sd, (u8 *) vv6410_sensor_init,\r\nARRAY_SIZE(vv6410_sensor_init));\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_start(struct sd *sd)\r\n{\r\nint err;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\nu32 priv = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\r\nif (priv & VV6410_SUBSAMPLE) {\r\nPDEBUG(D_CONF, "Enabling subsampling");\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\r\n} else {\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x00);\r\n}\r\nerr = stv06xx_write_bridge(sd, STV_LED_CTRL, LED_ON);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor(sd, VV6410_SETUP0, 0);\r\nif (err < 0)\r\nreturn err;\r\nPDEBUG(D_STREAM, "Starting stream");\r\nreturn 0;\r\n}\r\nstatic int vv6410_stop(struct sd *sd)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nint err;\r\nerr = stv06xx_write_bridge(sd, STV_LED_CTRL, LED_OFF);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor(sd, VV6410_SETUP0, VV6410_LOW_POWER_MODE);\r\nif (err < 0)\r\nreturn err;\r\nPDEBUG(D_STREAM, "Halting stream");\r\nreturn 0;\r\n}\r\nstatic int vv6410_dump(struct sd *sd)\r\n{\r\nu8 i;\r\nint err = 0;\r\npr_info("Dumping all vv6410 sensor registers\n");\r\nfor (i = 0; i < 0xff && !err; i++) {\r\nu16 data;\r\nerr = stv06xx_read_sensor(sd, i, &data);\r\npr_info("Register 0x%x contained 0x%x\n", i, data);\r\n}\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu16 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nerr = stv06xx_read_sensor(sd, VV6410_DATAFORMAT, &i2c_data);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ni2c_data |= VV6410_HFLIP;\r\nelse\r\ni2c_data &= ~VV6410_HFLIP;\r\nPDEBUG(D_CONF, "Set horizontal flip to %d", val);\r\nerr = stv06xx_write_sensor(sd, VV6410_DATAFORMAT, i2c_data);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu16 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nerr = stv06xx_read_sensor(sd, VV6410_DATAFORMAT, &i2c_data);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ni2c_data |= VV6410_VFLIP;\r\nelse\r\ni2c_data &= ~VV6410_VFLIP;\r\nPDEBUG(D_CONF, "Set vertical flip to %d", val);\r\nerr = stv06xx_write_sensor(sd, VV6410_DATAFORMAT, i2c_data);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_set_analog_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Set analog gain to %d", val);\r\nerr = stv06xx_write_sensor(sd, VV6410_ANALOGGAIN, 0xf0 | (val & 0xf));\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nunsigned int fine, coarse;\r\nval = (val * val >> 14) + val / 4;\r\nfine = val % VV6410_CIF_LINELENGTH;\r\ncoarse = min(512, val / VV6410_CIF_LINELENGTH);\r\nPDEBUG(D_CONF, "Set coarse exposure to %d, fine exposure to %d",\r\ncoarse, fine);\r\nerr = stv06xx_write_sensor(sd, VV6410_FINEH, fine >> 8);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, VV6410_FINEL, fine & 0xff);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, VV6410_COARSEH, coarse >> 8);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, VV6410_COARSEL, coarse & 0xff);\r\nout:\r\nreturn err;\r\n}
