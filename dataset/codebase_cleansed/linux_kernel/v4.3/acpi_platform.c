struct platform_device *acpi_create_platform_device(struct acpi_device *adev)\r\n{\r\nstruct platform_device *pdev = NULL;\r\nstruct acpi_device *acpi_parent;\r\nstruct platform_device_info pdevinfo;\r\nstruct resource_entry *rentry;\r\nstruct list_head resource_list;\r\nstruct resource *resources = NULL;\r\nint count;\r\nif (adev->physical_node_count)\r\nreturn NULL;\r\nif (!acpi_match_device_ids(adev, forbidden_id_list))\r\nreturn ERR_PTR(-EINVAL);\r\nINIT_LIST_HEAD(&resource_list);\r\ncount = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\r\nif (count < 0) {\r\nreturn NULL;\r\n} else if (count > 0) {\r\nresources = kmalloc(count * sizeof(struct resource),\r\nGFP_KERNEL);\r\nif (!resources) {\r\ndev_err(&adev->dev, "No memory for resources\n");\r\nacpi_dev_free_resource_list(&resource_list);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncount = 0;\r\nlist_for_each_entry(rentry, &resource_list, node)\r\nresources[count++] = *rentry->res;\r\nacpi_dev_free_resource_list(&resource_list);\r\n}\r\nmemset(&pdevinfo, 0, sizeof(pdevinfo));\r\npdevinfo.parent = NULL;\r\nacpi_parent = adev->parent;\r\nif (acpi_parent) {\r\nstruct acpi_device_physical_node *entry;\r\nstruct list_head *list;\r\nmutex_lock(&acpi_parent->physical_node_lock);\r\nlist = &acpi_parent->physical_node_list;\r\nif (!list_empty(list)) {\r\nentry = list_first_entry(list,\r\nstruct acpi_device_physical_node,\r\nnode);\r\npdevinfo.parent = entry->dev;\r\n}\r\nmutex_unlock(&acpi_parent->physical_node_lock);\r\n}\r\npdevinfo.name = dev_name(&adev->dev);\r\npdevinfo.id = -1;\r\npdevinfo.res = resources;\r\npdevinfo.num_res = count;\r\npdevinfo.fwnode = acpi_fwnode_handle(adev);\r\npdevinfo.dma_mask = acpi_check_dma(adev, NULL) ? DMA_BIT_MASK(32) : 0;\r\npdev = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(pdev))\r\ndev_err(&adev->dev, "platform device creation failed: %ld\n",\r\nPTR_ERR(pdev));\r\nelse\r\ndev_dbg(&adev->dev, "created platform device %s\n",\r\ndev_name(&pdev->dev));\r\nkfree(resources);\r\nreturn pdev;\r\n}
