static void lovsub_req_completion(const struct lu_env *env,\r\nconst struct cl_req_slice *slice, int ioret)\r\n{\r\nstruct lovsub_req *lsr;\r\nlsr = cl2lovsub_req(slice);\r\nOBD_SLAB_FREE_PTR(lsr, lovsub_req_kmem);\r\n}\r\nstatic void lovsub_req_attr_set(const struct lu_env *env,\r\nconst struct cl_req_slice *slice,\r\nconst struct cl_object *obj,\r\nstruct cl_req_attr *attr, u64 flags)\r\n{\r\nstruct lovsub_object *subobj;\r\nsubobj = cl2lovsub(obj);\r\nattr->cra_oa->o_stripe_idx = subobj->lso_index;\r\n}\r\nstatic int lovsub_device_init(const struct lu_env *env, struct lu_device *d,\r\nconst char *name, struct lu_device *next)\r\n{\r\nstruct lovsub_device *lsd = lu2lovsub_dev(d);\r\nstruct lu_device_type *ldt;\r\nint rc;\r\nnext->ld_site = d->ld_site;\r\nldt = next->ld_type;\r\nLASSERT(ldt != NULL);\r\nrc = ldt->ldt_ops->ldto_device_init(env, next, ldt->ldt_name, NULL);\r\nif (rc) {\r\nnext->ld_site = NULL;\r\nreturn rc;\r\n}\r\nlu_device_get(next);\r\nlu_ref_add(&next->ld_reference, "lu-stack", &lu_site_init);\r\nlsd->acid_next = lu2cl_dev(next);\r\nreturn rc;\r\n}\r\nstatic struct lu_device *lovsub_device_fini(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct lu_device *next;\r\nstruct lovsub_device *lsd;\r\nlsd = lu2lovsub_dev(d);\r\nnext = cl2lu_dev(lsd->acid_next);\r\nlsd->acid_super = NULL;\r\nlsd->acid_next = NULL;\r\nreturn next;\r\n}\r\nstatic struct lu_device *lovsub_device_free(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct lovsub_device *lsd = lu2lovsub_dev(d);\r\nstruct lu_device *next = cl2lu_dev(lsd->acid_next);\r\nif (atomic_read(&d->ld_ref) && d->ld_site) {\r\nLIBCFS_DEBUG_MSG_DATA_DECL(msgdata, D_ERROR, NULL);\r\nlu_site_print(env, d->ld_site, &msgdata, lu_cdebug_printer);\r\n}\r\ncl_device_fini(lu2cl_dev(d));\r\nkfree(lsd);\r\nreturn next;\r\n}\r\nstatic int lovsub_req_init(const struct lu_env *env, struct cl_device *dev,\r\nstruct cl_req *req)\r\n{\r\nstruct lovsub_req *lsr;\r\nint result;\r\nOBD_SLAB_ALLOC_PTR_GFP(lsr, lovsub_req_kmem, GFP_NOFS);\r\nif (lsr != NULL) {\r\ncl_req_slice_add(req, &lsr->lsrq_cl, dev, &lovsub_req_ops);\r\nresult = 0;\r\n} else\r\nresult = -ENOMEM;\r\nreturn result;\r\n}\r\nstatic struct lu_device *lovsub_device_alloc(const struct lu_env *env,\r\nstruct lu_device_type *t,\r\nstruct lustre_cfg *cfg)\r\n{\r\nstruct lu_device *d;\r\nstruct lovsub_device *lsd;\r\nlsd = kzalloc(sizeof(*lsd), GFP_NOFS);\r\nif (lsd != NULL) {\r\nint result;\r\nresult = cl_device_init(&lsd->acid_cl, t);\r\nif (result == 0) {\r\nd = lovsub2lu_dev(lsd);\r\nd->ld_ops = &lovsub_lu_ops;\r\nlsd->acid_cl.cd_ops = &lovsub_cl_ops;\r\n} else\r\nd = ERR_PTR(result);\r\n} else\r\nd = ERR_PTR(-ENOMEM);\r\nreturn d;\r\n}
