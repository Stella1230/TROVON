static\r\nstruct rxrpc_local *rxrpc_alloc_local(struct sockaddr_rxrpc *srx)\r\n{\r\nstruct rxrpc_local *local;\r\nlocal = kzalloc(sizeof(struct rxrpc_local), GFP_KERNEL);\r\nif (local) {\r\nINIT_WORK(&local->destroyer, &rxrpc_destroy_local);\r\nINIT_WORK(&local->acceptor, &rxrpc_accept_incoming_calls);\r\nINIT_WORK(&local->rejecter, &rxrpc_reject_packets);\r\nINIT_WORK(&local->event_processor, &rxrpc_process_local_events);\r\nINIT_LIST_HEAD(&local->services);\r\nINIT_LIST_HEAD(&local->link);\r\ninit_rwsem(&local->defrag_sem);\r\nskb_queue_head_init(&local->accept_queue);\r\nskb_queue_head_init(&local->reject_queue);\r\nskb_queue_head_init(&local->event_queue);\r\nspin_lock_init(&local->lock);\r\nrwlock_init(&local->services_lock);\r\natomic_set(&local->usage, 1);\r\nlocal->debug_id = atomic_inc_return(&rxrpc_debug_id);\r\nmemcpy(&local->srx, srx, sizeof(*srx));\r\n}\r\n_leave(" = %p", local);\r\nreturn local;\r\n}\r\nstatic int rxrpc_create_local(struct rxrpc_local *local)\r\n{\r\nstruct sock *sock;\r\nint ret, opt;\r\n_enter("%p{%d}", local, local->srx.transport_type);\r\nret = sock_create_kern(&init_net, PF_INET, local->srx.transport_type,\r\nIPPROTO_UDP, &local->socket);\r\nif (ret < 0) {\r\n_leave(" = %d [socket]", ret);\r\nreturn ret;\r\n}\r\nif (local->srx.transport_len > sizeof(sa_family_t)) {\r\n_debug("bind");\r\nret = kernel_bind(local->socket,\r\n(struct sockaddr *) &local->srx.transport,\r\nlocal->srx.transport_len);\r\nif (ret < 0) {\r\n_debug("bind failed");\r\ngoto error;\r\n}\r\n}\r\nopt = 1;\r\nret = kernel_setsockopt(local->socket, SOL_IP, IP_RECVERR,\r\n(char *) &opt, sizeof(opt));\r\nif (ret < 0) {\r\n_debug("setsockopt failed");\r\ngoto error;\r\n}\r\nopt = IP_PMTUDISC_DO;\r\nret = kernel_setsockopt(local->socket, SOL_IP, IP_MTU_DISCOVER,\r\n(char *) &opt, sizeof(opt));\r\nif (ret < 0) {\r\n_debug("setsockopt failed");\r\ngoto error;\r\n}\r\nwrite_lock_bh(&rxrpc_local_lock);\r\nlist_add(&local->link, &rxrpc_locals);\r\nwrite_unlock_bh(&rxrpc_local_lock);\r\nsock = local->socket->sk;\r\nsock->sk_user_data = local;\r\nsock->sk_data_ready = rxrpc_data_ready;\r\nsock->sk_error_report = rxrpc_UDP_error_report;\r\n_leave(" = 0");\r\nreturn 0;\r\nerror:\r\nkernel_sock_shutdown(local->socket, SHUT_RDWR);\r\nlocal->socket->sk->sk_user_data = NULL;\r\nsock_release(local->socket);\r\nlocal->socket = NULL;\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstruct rxrpc_local *rxrpc_lookup_local(struct sockaddr_rxrpc *srx)\r\n{\r\nstruct rxrpc_local *local;\r\nint ret;\r\n_enter("{%d,%u,%pI4+%hu}",\r\nsrx->transport_type,\r\nsrx->transport.family,\r\n&srx->transport.sin.sin_addr,\r\nntohs(srx->transport.sin.sin_port));\r\ndown_write(&rxrpc_local_sem);\r\nread_lock_bh(&rxrpc_local_lock);\r\nlist_for_each_entry(local, &rxrpc_locals, link) {\r\n_debug("CMP {%d,%u,%pI4+%hu}",\r\nlocal->srx.transport_type,\r\nlocal->srx.transport.family,\r\n&local->srx.transport.sin.sin_addr,\r\nntohs(local->srx.transport.sin.sin_port));\r\nif (local->srx.transport_type != srx->transport_type ||\r\nlocal->srx.transport.family != srx->transport.family)\r\ncontinue;\r\nswitch (srx->transport.family) {\r\ncase AF_INET:\r\nif (local->srx.transport.sin.sin_port !=\r\nsrx->transport.sin.sin_port)\r\ncontinue;\r\nif (memcmp(&local->srx.transport.sin.sin_addr,\r\n&srx->transport.sin.sin_addr,\r\nsizeof(struct in_addr)) != 0)\r\ncontinue;\r\ngoto found_local;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nread_unlock_bh(&rxrpc_local_lock);\r\nlocal = rxrpc_alloc_local(srx);\r\nif (!local) {\r\nup_write(&rxrpc_local_sem);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = rxrpc_create_local(local);\r\nif (ret < 0) {\r\nup_write(&rxrpc_local_sem);\r\nkfree(local);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nup_write(&rxrpc_local_sem);\r\n_net("LOCAL new %d {%d,%u,%pI4+%hu}",\r\nlocal->debug_id,\r\nlocal->srx.transport_type,\r\nlocal->srx.transport.family,\r\n&local->srx.transport.sin.sin_addr,\r\nntohs(local->srx.transport.sin.sin_port));\r\n_leave(" = %p [new]", local);\r\nreturn local;\r\nfound_local:\r\nrxrpc_get_local(local);\r\nread_unlock_bh(&rxrpc_local_lock);\r\nup_write(&rxrpc_local_sem);\r\n_net("LOCAL old %d {%d,%u,%pI4+%hu}",\r\nlocal->debug_id,\r\nlocal->srx.transport_type,\r\nlocal->srx.transport.family,\r\n&local->srx.transport.sin.sin_addr,\r\nntohs(local->srx.transport.sin.sin_port));\r\n_leave(" = %p [reuse]", local);\r\nreturn local;\r\n}\r\nvoid rxrpc_put_local(struct rxrpc_local *local)\r\n{\r\n_enter("%p{u=%d}", local, atomic_read(&local->usage));\r\nASSERTCMP(atomic_read(&local->usage), >, 0);\r\nwrite_lock_bh(&rxrpc_local_lock);\r\nif (unlikely(atomic_dec_and_test(&local->usage))) {\r\n_debug("destroy local");\r\nrxrpc_queue_work(&local->destroyer);\r\n}\r\nwrite_unlock_bh(&rxrpc_local_lock);\r\n_leave("");\r\n}\r\nstatic void rxrpc_destroy_local(struct work_struct *work)\r\n{\r\nstruct rxrpc_local *local =\r\ncontainer_of(work, struct rxrpc_local, destroyer);\r\n_enter("%p{%d}", local, atomic_read(&local->usage));\r\ndown_write(&rxrpc_local_sem);\r\nwrite_lock_bh(&rxrpc_local_lock);\r\nif (atomic_read(&local->usage) > 0) {\r\nwrite_unlock_bh(&rxrpc_local_lock);\r\nup_read(&rxrpc_local_sem);\r\n_leave(" [resurrected]");\r\nreturn;\r\n}\r\nlist_del(&local->link);\r\nlocal->socket->sk->sk_user_data = NULL;\r\nwrite_unlock_bh(&rxrpc_local_lock);\r\ndowngrade_write(&rxrpc_local_sem);\r\nASSERT(list_empty(&local->services));\r\nASSERT(!work_pending(&local->acceptor));\r\nASSERT(!work_pending(&local->rejecter));\r\nASSERT(!work_pending(&local->event_processor));\r\nrxrpc_purge_queue(&local->accept_queue);\r\nrxrpc_purge_queue(&local->reject_queue);\r\nrxrpc_purge_queue(&local->event_queue);\r\nkernel_sock_shutdown(local->socket, SHUT_RDWR);\r\nsock_release(local->socket);\r\nup_read(&rxrpc_local_sem);\r\n_net("DESTROY LOCAL %d", local->debug_id);\r\nkfree(local);\r\nif (list_empty(&rxrpc_locals))\r\nwake_up_all(&rxrpc_local_wq);\r\n_leave("");\r\n}\r\nvoid __exit rxrpc_destroy_all_locals(void)\r\n{\r\nDECLARE_WAITQUEUE(myself,current);\r\n_enter("");\r\nif (!list_empty(&rxrpc_locals)) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&rxrpc_local_wq, &myself);\r\nwhile (!list_empty(&rxrpc_locals)) {\r\nschedule();\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\n}\r\nremove_wait_queue(&rxrpc_local_wq, &myself);\r\nset_current_state(TASK_RUNNING);\r\n}\r\n_leave("");\r\n}\r\nstatic void rxrpc_send_version_request(struct rxrpc_local *local,\r\nstruct rxrpc_header *hdr,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sockaddr_in sin;\r\nstruct msghdr msg;\r\nstruct kvec iov[2];\r\nsize_t len;\r\nint ret;\r\n_enter("");\r\nsin.sin_family = AF_INET;\r\nsin.sin_port = udp_hdr(skb)->source;\r\nsin.sin_addr.s_addr = ip_hdr(skb)->saddr;\r\nmsg.msg_name = &sin;\r\nmsg.msg_namelen = sizeof(sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nhdr->seq = 0;\r\nhdr->serial = 0;\r\nhdr->type = RXRPC_PACKET_TYPE_VERSION;\r\nhdr->flags = RXRPC_LAST_PACKET | (~hdr->flags & RXRPC_CLIENT_INITIATED);\r\nhdr->userStatus = 0;\r\nhdr->_rsvd = 0;\r\niov[0].iov_base = hdr;\r\niov[0].iov_len = sizeof(*hdr);\r\niov[1].iov_base = (char *)rxrpc_version_string;\r\niov[1].iov_len = sizeof(rxrpc_version_string);\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\n_proto("Tx VERSION (reply)");\r\nret = kernel_sendmsg(local->socket, &msg, iov, 2, len);\r\nif (ret < 0)\r\n_debug("sendmsg failed: %d", ret);\r\n_leave("");\r\n}\r\nstatic void rxrpc_process_local_events(struct work_struct *work)\r\n{\r\nstruct rxrpc_local *local = container_of(work, struct rxrpc_local, event_processor);\r\nstruct sk_buff *skb;\r\nchar v;\r\n_enter("");\r\natomic_inc(&local->usage);\r\nwhile ((skb = skb_dequeue(&local->event_queue))) {\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nkdebug("{%d},{%u}", local->debug_id, sp->hdr.type);\r\nswitch (sp->hdr.type) {\r\ncase RXRPC_PACKET_TYPE_VERSION:\r\nif (skb_copy_bits(skb, 0, &v, 1) < 0)\r\nreturn;\r\n_proto("Rx VERSION { %02x }", v);\r\nif (v == 0)\r\nrxrpc_send_version_request(local, &sp->hdr, skb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nrxrpc_put_local(local);\r\nrxrpc_free_skb(skb);\r\n}\r\nrxrpc_put_local(local);\r\n_leave("");\r\n}
