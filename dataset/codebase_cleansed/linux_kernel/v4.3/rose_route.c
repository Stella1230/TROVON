static int __must_check rose_add_node(struct rose_route_struct *rose_route,\r\nstruct net_device *dev)\r\n{\r\nstruct rose_node *rose_node, *rose_tmpn, *rose_tmpp;\r\nstruct rose_neigh *rose_neigh;\r\nint i, res = 0;\r\nspin_lock_bh(&rose_node_list_lock);\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nrose_node = rose_node_list;\r\nwhile (rose_node != NULL) {\r\nif ((rose_node->mask == rose_route->mask) &&\r\n(rosecmpm(&rose_route->address, &rose_node->address,\r\nrose_route->mask) == 0))\r\nbreak;\r\nrose_node = rose_node->next;\r\n}\r\nif (rose_node != NULL && rose_node->loopback) {\r\nres = -EINVAL;\r\ngoto out;\r\n}\r\nrose_neigh = rose_neigh_list;\r\nwhile (rose_neigh != NULL) {\r\nif (ax25cmp(&rose_route->neighbour,\r\n&rose_neigh->callsign) == 0 &&\r\nrose_neigh->dev == dev)\r\nbreak;\r\nrose_neigh = rose_neigh->next;\r\n}\r\nif (rose_neigh == NULL) {\r\nrose_neigh = kmalloc(sizeof(*rose_neigh), GFP_ATOMIC);\r\nif (rose_neigh == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nrose_neigh->callsign = rose_route->neighbour;\r\nrose_neigh->digipeat = NULL;\r\nrose_neigh->ax25 = NULL;\r\nrose_neigh->dev = dev;\r\nrose_neigh->count = 0;\r\nrose_neigh->use = 0;\r\nrose_neigh->dce_mode = 0;\r\nrose_neigh->loopback = 0;\r\nrose_neigh->number = rose_neigh_no++;\r\nrose_neigh->restarted = 0;\r\nskb_queue_head_init(&rose_neigh->queue);\r\ninit_timer(&rose_neigh->ftimer);\r\ninit_timer(&rose_neigh->t0timer);\r\nif (rose_route->ndigis != 0) {\r\nrose_neigh->digipeat =\r\nkmalloc(sizeof(ax25_digi), GFP_ATOMIC);\r\nif (rose_neigh->digipeat == NULL) {\r\nkfree(rose_neigh);\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nrose_neigh->digipeat->ndigi = rose_route->ndigis;\r\nrose_neigh->digipeat->lastrepeat = -1;\r\nfor (i = 0; i < rose_route->ndigis; i++) {\r\nrose_neigh->digipeat->calls[i] =\r\nrose_route->digipeaters[i];\r\nrose_neigh->digipeat->repeated[i] = 0;\r\n}\r\n}\r\nrose_neigh->next = rose_neigh_list;\r\nrose_neigh_list = rose_neigh;\r\n}\r\nif (rose_node == NULL) {\r\nrose_tmpn = rose_node_list;\r\nrose_tmpp = NULL;\r\nwhile (rose_tmpn != NULL) {\r\nif (rose_tmpn->mask > rose_route->mask) {\r\nrose_tmpp = rose_tmpn;\r\nrose_tmpn = rose_tmpn->next;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nrose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC);\r\nif (rose_node == NULL) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nrose_node->address = rose_route->address;\r\nrose_node->mask = rose_route->mask;\r\nrose_node->count = 1;\r\nrose_node->loopback = 0;\r\nrose_node->neighbour[0] = rose_neigh;\r\nif (rose_tmpn == NULL) {\r\nif (rose_tmpp == NULL) {\r\nrose_node_list = rose_node;\r\nrose_node->next = NULL;\r\n} else {\r\nrose_tmpp->next = rose_node;\r\nrose_node->next = NULL;\r\n}\r\n} else {\r\nif (rose_tmpp == NULL) {\r\nrose_node->next = rose_node_list;\r\nrose_node_list = rose_node;\r\n} else {\r\nrose_tmpp->next = rose_node;\r\nrose_node->next = rose_tmpn;\r\n}\r\n}\r\nrose_neigh->count++;\r\ngoto out;\r\n}\r\nif (rose_node->count < 3) {\r\nrose_node->neighbour[rose_node->count] = rose_neigh;\r\nrose_node->count++;\r\nrose_neigh->count++;\r\n}\r\nout:\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\nspin_unlock_bh(&rose_node_list_lock);\r\nreturn res;\r\n}\r\nstatic void rose_remove_node(struct rose_node *rose_node)\r\n{\r\nstruct rose_node *s;\r\nif ((s = rose_node_list) == rose_node) {\r\nrose_node_list = rose_node->next;\r\nkfree(rose_node);\r\nreturn;\r\n}\r\nwhile (s != NULL && s->next != NULL) {\r\nif (s->next == rose_node) {\r\ns->next = rose_node->next;\r\nkfree(rose_node);\r\nreturn;\r\n}\r\ns = s->next;\r\n}\r\n}\r\nstatic void rose_remove_neigh(struct rose_neigh *rose_neigh)\r\n{\r\nstruct rose_neigh *s;\r\nrose_stop_ftimer(rose_neigh);\r\nrose_stop_t0timer(rose_neigh);\r\nskb_queue_purge(&rose_neigh->queue);\r\nif ((s = rose_neigh_list) == rose_neigh) {\r\nrose_neigh_list = rose_neigh->next;\r\nif (rose_neigh->ax25)\r\nax25_cb_put(rose_neigh->ax25);\r\nkfree(rose_neigh->digipeat);\r\nkfree(rose_neigh);\r\nreturn;\r\n}\r\nwhile (s != NULL && s->next != NULL) {\r\nif (s->next == rose_neigh) {\r\ns->next = rose_neigh->next;\r\nif (rose_neigh->ax25)\r\nax25_cb_put(rose_neigh->ax25);\r\nkfree(rose_neigh->digipeat);\r\nkfree(rose_neigh);\r\nreturn;\r\n}\r\ns = s->next;\r\n}\r\n}\r\nstatic void rose_remove_route(struct rose_route *rose_route)\r\n{\r\nstruct rose_route *s;\r\nif (rose_route->neigh1 != NULL)\r\nrose_route->neigh1->use--;\r\nif (rose_route->neigh2 != NULL)\r\nrose_route->neigh2->use--;\r\nif ((s = rose_route_list) == rose_route) {\r\nrose_route_list = rose_route->next;\r\nkfree(rose_route);\r\nreturn;\r\n}\r\nwhile (s != NULL && s->next != NULL) {\r\nif (s->next == rose_route) {\r\ns->next = rose_route->next;\r\nkfree(rose_route);\r\nreturn;\r\n}\r\ns = s->next;\r\n}\r\n}\r\nstatic int rose_del_node(struct rose_route_struct *rose_route,\r\nstruct net_device *dev)\r\n{\r\nstruct rose_node *rose_node;\r\nstruct rose_neigh *rose_neigh;\r\nint i, err = 0;\r\nspin_lock_bh(&rose_node_list_lock);\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nrose_node = rose_node_list;\r\nwhile (rose_node != NULL) {\r\nif ((rose_node->mask == rose_route->mask) &&\r\n(rosecmpm(&rose_route->address, &rose_node->address,\r\nrose_route->mask) == 0))\r\nbreak;\r\nrose_node = rose_node->next;\r\n}\r\nif (rose_node == NULL || rose_node->loopback) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nrose_neigh = rose_neigh_list;\r\nwhile (rose_neigh != NULL) {\r\nif (ax25cmp(&rose_route->neighbour,\r\n&rose_neigh->callsign) == 0 &&\r\nrose_neigh->dev == dev)\r\nbreak;\r\nrose_neigh = rose_neigh->next;\r\n}\r\nif (rose_neigh == NULL) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < rose_node->count; i++) {\r\nif (rose_node->neighbour[i] == rose_neigh) {\r\nrose_neigh->count--;\r\nif (rose_neigh->count == 0 && rose_neigh->use == 0)\r\nrose_remove_neigh(rose_neigh);\r\nrose_node->count--;\r\nif (rose_node->count == 0) {\r\nrose_remove_node(rose_node);\r\n} else {\r\nswitch (i) {\r\ncase 0:\r\nrose_node->neighbour[0] =\r\nrose_node->neighbour[1];\r\ncase 1:\r\nrose_node->neighbour[1] =\r\nrose_node->neighbour[2];\r\ncase 2:\r\nbreak;\r\n}\r\n}\r\ngoto out;\r\n}\r\n}\r\nerr = -EINVAL;\r\nout:\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\nspin_unlock_bh(&rose_node_list_lock);\r\nreturn err;\r\n}\r\nvoid rose_add_loopback_neigh(void)\r\n{\r\nstruct rose_neigh *sn;\r\nrose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);\r\nif (!rose_loopback_neigh)\r\nreturn;\r\nsn = rose_loopback_neigh;\r\nsn->callsign = null_ax25_address;\r\nsn->digipeat = NULL;\r\nsn->ax25 = NULL;\r\nsn->dev = NULL;\r\nsn->count = 0;\r\nsn->use = 0;\r\nsn->dce_mode = 1;\r\nsn->loopback = 1;\r\nsn->number = rose_neigh_no++;\r\nsn->restarted = 1;\r\nskb_queue_head_init(&sn->queue);\r\ninit_timer(&sn->ftimer);\r\ninit_timer(&sn->t0timer);\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nsn->next = rose_neigh_list;\r\nrose_neigh_list = sn;\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\n}\r\nint rose_add_loopback_node(rose_address *address)\r\n{\r\nstruct rose_node *rose_node;\r\nint err = 0;\r\nspin_lock_bh(&rose_node_list_lock);\r\nrose_node = rose_node_list;\r\nwhile (rose_node != NULL) {\r\nif ((rose_node->mask == 10) &&\r\n(rosecmpm(address, &rose_node->address, 10) == 0) &&\r\nrose_node->loopback)\r\nbreak;\r\nrose_node = rose_node->next;\r\n}\r\nif (rose_node != NULL)\r\ngoto out;\r\nif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nrose_node->address = *address;\r\nrose_node->mask = 10;\r\nrose_node->count = 1;\r\nrose_node->loopback = 1;\r\nrose_node->neighbour[0] = rose_loopback_neigh;\r\nrose_node->next = rose_node_list;\r\nrose_node_list = rose_node;\r\nrose_loopback_neigh->count++;\r\nout:\r\nspin_unlock_bh(&rose_node_list_lock);\r\nreturn err;\r\n}\r\nvoid rose_del_loopback_node(rose_address *address)\r\n{\r\nstruct rose_node *rose_node;\r\nspin_lock_bh(&rose_node_list_lock);\r\nrose_node = rose_node_list;\r\nwhile (rose_node != NULL) {\r\nif ((rose_node->mask == 10) &&\r\n(rosecmpm(address, &rose_node->address, 10) == 0) &&\r\nrose_node->loopback)\r\nbreak;\r\nrose_node = rose_node->next;\r\n}\r\nif (rose_node == NULL)\r\ngoto out;\r\nrose_remove_node(rose_node);\r\nrose_loopback_neigh->count--;\r\nout:\r\nspin_unlock_bh(&rose_node_list_lock);\r\n}\r\nvoid rose_rt_device_down(struct net_device *dev)\r\n{\r\nstruct rose_neigh *s, *rose_neigh;\r\nstruct rose_node *t, *rose_node;\r\nint i;\r\nspin_lock_bh(&rose_node_list_lock);\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nrose_neigh = rose_neigh_list;\r\nwhile (rose_neigh != NULL) {\r\ns = rose_neigh;\r\nrose_neigh = rose_neigh->next;\r\nif (s->dev != dev)\r\ncontinue;\r\nrose_node = rose_node_list;\r\nwhile (rose_node != NULL) {\r\nt = rose_node;\r\nrose_node = rose_node->next;\r\nfor (i = 0; i < t->count; i++) {\r\nif (t->neighbour[i] != s)\r\ncontinue;\r\nt->count--;\r\nswitch (i) {\r\ncase 0:\r\nt->neighbour[0] = t->neighbour[1];\r\ncase 1:\r\nt->neighbour[1] = t->neighbour[2];\r\ncase 2:\r\nbreak;\r\n}\r\n}\r\nif (t->count <= 0)\r\nrose_remove_node(t);\r\n}\r\nrose_remove_neigh(s);\r\n}\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\nspin_unlock_bh(&rose_node_list_lock);\r\n}\r\nstatic int rose_clear_routes(void)\r\n{\r\nstruct rose_neigh *s, *rose_neigh;\r\nstruct rose_node *t, *rose_node;\r\nspin_lock_bh(&rose_node_list_lock);\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nrose_neigh = rose_neigh_list;\r\nrose_node = rose_node_list;\r\nwhile (rose_node != NULL) {\r\nt = rose_node;\r\nrose_node = rose_node->next;\r\nif (!t->loopback)\r\nrose_remove_node(t);\r\n}\r\nwhile (rose_neigh != NULL) {\r\ns = rose_neigh;\r\nrose_neigh = rose_neigh->next;\r\nif (s->use == 0 && !s->loopback) {\r\ns->count = 0;\r\nrose_remove_neigh(s);\r\n}\r\n}\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\nspin_unlock_bh(&rose_node_list_lock);\r\nreturn 0;\r\n}\r\nstatic struct net_device *rose_ax25_dev_find(char *devname)\r\n{\r\nstruct net_device *dev;\r\nif ((dev = __dev_get_by_name(&init_net, devname)) == NULL)\r\nreturn NULL;\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)\r\nreturn dev;\r\nreturn NULL;\r\n}\r\nstruct net_device *rose_dev_first(void)\r\n{\r\nstruct net_device *dev, *first = NULL;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE)\r\nif (first == NULL || strncmp(dev->name, first->name, 3) < 0)\r\nfirst = dev;\r\n}\r\nrcu_read_unlock();\r\nreturn first;\r\n}\r\nstruct net_device *rose_dev_get(rose_address *addr)\r\n{\r\nstruct net_device *dev;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0) {\r\ndev_hold(dev);\r\ngoto out;\r\n}\r\n}\r\ndev = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn dev;\r\n}\r\nstatic int rose_dev_exists(rose_address *addr)\r\n{\r\nstruct net_device *dev;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0)\r\ngoto out;\r\n}\r\ndev = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn dev != NULL;\r\n}\r\nstruct rose_route *rose_route_free_lci(unsigned int lci, struct rose_neigh *neigh)\r\n{\r\nstruct rose_route *rose_route;\r\nfor (rose_route = rose_route_list; rose_route != NULL; rose_route = rose_route->next)\r\nif ((rose_route->neigh1 == neigh && rose_route->lci1 == lci) ||\r\n(rose_route->neigh2 == neigh && rose_route->lci2 == lci))\r\nreturn rose_route;\r\nreturn NULL;\r\n}\r\nstruct rose_neigh *rose_get_neigh(rose_address *addr, unsigned char *cause,\r\nunsigned char *diagnostic, int route_frame)\r\n{\r\nstruct rose_neigh *res = NULL;\r\nstruct rose_node *node;\r\nint failed = 0;\r\nint i;\r\nif (!route_frame) spin_lock_bh(&rose_node_list_lock);\r\nfor (node = rose_node_list; node != NULL; node = node->next) {\r\nif (rosecmpm(addr, &node->address, node->mask) == 0) {\r\nfor (i = 0; i < node->count; i++) {\r\nif (node->neighbour[i]->restarted) {\r\nres = node->neighbour[i];\r\ngoto out;\r\n}\r\n}\r\n}\r\n}\r\nif (!route_frame) {\r\nfor (node = rose_node_list; node != NULL; node = node->next) {\r\nif (rosecmpm(addr, &node->address, node->mask) == 0) {\r\nfor (i = 0; i < node->count; i++) {\r\nif (!rose_ftimer_running(node->neighbour[i])) {\r\nres = node->neighbour[i];\r\nfailed = 0;\r\ngoto out;\r\n}\r\nfailed = 1;\r\n}\r\n}\r\n}\r\n}\r\nif (failed) {\r\n*cause = ROSE_OUT_OF_ORDER;\r\n*diagnostic = 0;\r\n} else {\r\n*cause = ROSE_NOT_OBTAINABLE;\r\n*diagnostic = 0;\r\n}\r\nout:\r\nif (!route_frame) spin_unlock_bh(&rose_node_list_lock);\r\nreturn res;\r\n}\r\nint rose_rt_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nstruct rose_route_struct rose_route;\r\nstruct net_device *dev;\r\nint err;\r\nswitch (cmd) {\r\ncase SIOCADDRT:\r\nif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\r\nreturn -EFAULT;\r\nif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\r\nreturn -EINVAL;\r\nif (rose_dev_exists(&rose_route.address))\r\nreturn -EINVAL;\r\nif (rose_route.mask > 10)\r\nreturn -EINVAL;\r\nif (rose_route.ndigis > AX25_MAX_DIGIS)\r\nreturn -EINVAL;\r\nerr = rose_add_node(&rose_route, dev);\r\nreturn err;\r\ncase SIOCDELRT:\r\nif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\r\nreturn -EFAULT;\r\nif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\r\nreturn -EINVAL;\r\nerr = rose_del_node(&rose_route, dev);\r\nreturn err;\r\ncase SIOCRSCLRRT:\r\nreturn rose_clear_routes();\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rose_del_route_by_neigh(struct rose_neigh *rose_neigh)\r\n{\r\nstruct rose_route *rose_route, *s;\r\nrose_neigh->restarted = 0;\r\nrose_stop_t0timer(rose_neigh);\r\nrose_start_ftimer(rose_neigh);\r\nskb_queue_purge(&rose_neigh->queue);\r\nspin_lock_bh(&rose_route_list_lock);\r\nrose_route = rose_route_list;\r\nwhile (rose_route != NULL) {\r\nif ((rose_route->neigh1 == rose_neigh && rose_route->neigh2 == rose_neigh) ||\r\n(rose_route->neigh1 == rose_neigh && rose_route->neigh2 == NULL) ||\r\n(rose_route->neigh2 == rose_neigh && rose_route->neigh1 == NULL)) {\r\ns = rose_route->next;\r\nrose_remove_route(rose_route);\r\nrose_route = s;\r\ncontinue;\r\n}\r\nif (rose_route->neigh1 == rose_neigh) {\r\nrose_route->neigh1->use--;\r\nrose_route->neigh1 = NULL;\r\nrose_transmit_clear_request(rose_route->neigh2, rose_route->lci2, ROSE_OUT_OF_ORDER, 0);\r\n}\r\nif (rose_route->neigh2 == rose_neigh) {\r\nrose_route->neigh2->use--;\r\nrose_route->neigh2 = NULL;\r\nrose_transmit_clear_request(rose_route->neigh1, rose_route->lci1, ROSE_OUT_OF_ORDER, 0);\r\n}\r\nrose_route = rose_route->next;\r\n}\r\nspin_unlock_bh(&rose_route_list_lock);\r\n}\r\nvoid rose_link_failed(ax25_cb *ax25, int reason)\r\n{\r\nstruct rose_neigh *rose_neigh;\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nrose_neigh = rose_neigh_list;\r\nwhile (rose_neigh != NULL) {\r\nif (rose_neigh->ax25 == ax25)\r\nbreak;\r\nrose_neigh = rose_neigh->next;\r\n}\r\nif (rose_neigh != NULL) {\r\nrose_neigh->ax25 = NULL;\r\nax25_cb_put(ax25);\r\nrose_del_route_by_neigh(rose_neigh);\r\nrose_kill_by_neigh(rose_neigh);\r\n}\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\n}\r\nvoid rose_link_device_down(struct net_device *dev)\r\n{\r\nstruct rose_neigh *rose_neigh;\r\nfor (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {\r\nif (rose_neigh->dev == dev) {\r\nrose_del_route_by_neigh(rose_neigh);\r\nrose_kill_by_neigh(rose_neigh);\r\n}\r\n}\r\n}\r\nint rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\r\n{\r\nstruct rose_neigh *rose_neigh, *new_neigh;\r\nstruct rose_route *rose_route;\r\nstruct rose_facilities_struct facilities;\r\nrose_address *src_addr, *dest_addr;\r\nstruct sock *sk;\r\nunsigned short frametype;\r\nunsigned int lci, new_lci;\r\nunsigned char cause, diagnostic;\r\nstruct net_device *dev;\r\nint res = 0;\r\nchar buf[11];\r\nif (skb->len < ROSE_MIN_LEN)\r\nreturn res;\r\nframetype = skb->data[2];\r\nlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\r\nif (frametype == ROSE_CALL_REQUEST &&\r\n(skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\r\nskb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\r\nROSE_CALL_REQ_ADDR_LEN_VAL))\r\nreturn res;\r\nsrc_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_SRC_ADDR_OFF);\r\ndest_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nspin_lock_bh(&rose_route_list_lock);\r\nrose_neigh = rose_neigh_list;\r\nwhile (rose_neigh != NULL) {\r\nif (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 &&\r\nax25->ax25_dev->dev == rose_neigh->dev)\r\nbreak;\r\nrose_neigh = rose_neigh->next;\r\n}\r\nif (rose_neigh == NULL) {\r\nprintk("rose_route : unknown neighbour or device %s\n",\r\nax2asc(buf, &ax25->dest_addr));\r\ngoto out;\r\n}\r\nrose_stop_ftimer(rose_neigh);\r\nif (lci == 0) {\r\nrose_link_rx_restart(skb, rose_neigh, frametype);\r\ngoto out;\r\n}\r\nif ((sk = rose_find_socket(lci, rose_neigh)) != NULL) {\r\nif (frametype == ROSE_CALL_REQUEST) {\r\nstruct rose_sock *rose = rose_sk(sk);\r\nrose_clear_queues(sk);\r\nrose->cause = ROSE_NETWORK_CONGESTION;\r\nrose->diagnostic = 0;\r\nrose->neighbour->use--;\r\nrose->neighbour = NULL;\r\nrose->lci = 0;\r\nrose->state = ROSE_STATE_0;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_err = 0;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\n}\r\n}\r\nelse {\r\nskb_reset_transport_header(skb);\r\nres = rose_process_rx_frame(sk, skb);\r\ngoto out;\r\n}\r\n}\r\nif (frametype == ROSE_CALL_REQUEST)\r\nif ((dev = rose_dev_get(dest_addr)) != NULL) {\r\nres = rose_rx_call_request(skb, dev, rose_neigh, lci);\r\ndev_put(dev);\r\ngoto out;\r\n}\r\nif (!sysctl_rose_routing_control) {\r\nrose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 0);\r\ngoto out;\r\n}\r\nrose_route = rose_route_list;\r\nwhile (rose_route != NULL) {\r\nif (rose_route->lci1 == lci &&\r\nrose_route->neigh1 == rose_neigh) {\r\nif (frametype == ROSE_CALL_REQUEST) {\r\nrose_remove_route(rose_route);\r\nbreak;\r\n} else if (rose_route->neigh2 != NULL) {\r\nskb->data[0] &= 0xF0;\r\nskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\r\nskb->data[1] = (rose_route->lci2 >> 0) & 0xFF;\r\nrose_transmit_link(skb, rose_route->neigh2);\r\nif (frametype == ROSE_CLEAR_CONFIRMATION)\r\nrose_remove_route(rose_route);\r\nres = 1;\r\ngoto out;\r\n} else {\r\nif (frametype == ROSE_CLEAR_CONFIRMATION)\r\nrose_remove_route(rose_route);\r\ngoto out;\r\n}\r\n}\r\nif (rose_route->lci2 == lci &&\r\nrose_route->neigh2 == rose_neigh) {\r\nif (frametype == ROSE_CALL_REQUEST) {\r\nrose_remove_route(rose_route);\r\nbreak;\r\n} else if (rose_route->neigh1 != NULL) {\r\nskb->data[0] &= 0xF0;\r\nskb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;\r\nskb->data[1] = (rose_route->lci1 >> 0) & 0xFF;\r\nrose_transmit_link(skb, rose_route->neigh1);\r\nif (frametype == ROSE_CLEAR_CONFIRMATION)\r\nrose_remove_route(rose_route);\r\nres = 1;\r\ngoto out;\r\n} else {\r\nif (frametype == ROSE_CLEAR_CONFIRMATION)\r\nrose_remove_route(rose_route);\r\ngoto out;\r\n}\r\n}\r\nrose_route = rose_route->next;\r\n}\r\nif (frametype != ROSE_CALL_REQUEST) {\r\nres = 0;\r\ngoto out;\r\n}\r\nmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\r\nif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\r\nskb->len - ROSE_CALL_REQ_FACILITIES_OFF,\r\n&facilities)) {\r\nrose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\r\ngoto out;\r\n}\r\nrose_route = rose_route_list;\r\nwhile (rose_route != NULL) {\r\nif (rose_route->rand == facilities.rand &&\r\nrosecmp(src_addr, &rose_route->src_addr) == 0 &&\r\nax25cmp(&facilities.dest_call, &rose_route->src_call) == 0 &&\r\nax25cmp(&facilities.source_call, &rose_route->dest_call) == 0) {\r\nrose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 120);\r\ngoto out;\r\n}\r\nrose_route = rose_route->next;\r\n}\r\nif ((new_neigh = rose_get_neigh(dest_addr, &cause, &diagnostic, 1)) == NULL) {\r\nrose_transmit_clear_request(rose_neigh, lci, cause, diagnostic);\r\ngoto out;\r\n}\r\nif ((new_lci = rose_new_lci(new_neigh)) == 0) {\r\nrose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 71);\r\ngoto out;\r\n}\r\nif ((rose_route = kmalloc(sizeof(*rose_route), GFP_ATOMIC)) == NULL) {\r\nrose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 120);\r\ngoto out;\r\n}\r\nrose_route->lci1 = lci;\r\nrose_route->src_addr = *src_addr;\r\nrose_route->dest_addr = *dest_addr;\r\nrose_route->src_call = facilities.dest_call;\r\nrose_route->dest_call = facilities.source_call;\r\nrose_route->rand = facilities.rand;\r\nrose_route->neigh1 = rose_neigh;\r\nrose_route->lci2 = new_lci;\r\nrose_route->neigh2 = new_neigh;\r\nrose_route->neigh1->use++;\r\nrose_route->neigh2->use++;\r\nrose_route->next = rose_route_list;\r\nrose_route_list = rose_route;\r\nskb->data[0] &= 0xF0;\r\nskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\r\nskb->data[1] = (rose_route->lci2 >> 0) & 0xFF;\r\nrose_transmit_link(skb, rose_route->neigh2);\r\nres = 1;\r\nout:\r\nspin_unlock_bh(&rose_route_list_lock);\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\nreturn res;\r\n}\r\nstatic void *rose_node_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rose_node_list_lock)\r\n{\r\nstruct rose_node *rose_node;\r\nint i = 1;\r\nspin_lock_bh(&rose_node_list_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (rose_node = rose_node_list; rose_node && i < *pos;\r\nrose_node = rose_node->next, ++i);\r\nreturn (i == *pos) ? rose_node : NULL;\r\n}\r\nstatic void *rose_node_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (v == SEQ_START_TOKEN) ? rose_node_list\r\n: ((struct rose_node *)v)->next;\r\n}\r\nstatic void rose_node_stop(struct seq_file *seq, void *v)\r\n__releases(rose_node_list_lock)\r\n{\r\nspin_unlock_bh(&rose_node_list_lock);\r\n}\r\nstatic int rose_node_show(struct seq_file *seq, void *v)\r\n{\r\nchar rsbuf[11];\r\nint i;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "address mask n neigh neigh neigh\n");\r\nelse {\r\nconst struct rose_node *rose_node = v;\r\nseq_printf(seq, "%-10s %04d %d",\r\nrose2asc(rsbuf, &rose_node->address),\r\nrose_node->mask,\r\nrose_node->count);\r\nfor (i = 0; i < rose_node->count; i++)\r\nseq_printf(seq, " %05d",\r\nrose_node->neighbour[i]->number);\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_nodes_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &rose_node_seqops);\r\n}\r\nstatic void *rose_neigh_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rose_neigh_list_lock)\r\n{\r\nstruct rose_neigh *rose_neigh;\r\nint i = 1;\r\nspin_lock_bh(&rose_neigh_list_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (rose_neigh = rose_neigh_list; rose_neigh && i < *pos;\r\nrose_neigh = rose_neigh->next, ++i);\r\nreturn (i == *pos) ? rose_neigh : NULL;\r\n}\r\nstatic void *rose_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (v == SEQ_START_TOKEN) ? rose_neigh_list\r\n: ((struct rose_neigh *)v)->next;\r\n}\r\nstatic void rose_neigh_stop(struct seq_file *seq, void *v)\r\n__releases(rose_neigh_list_lock)\r\n{\r\nspin_unlock_bh(&rose_neigh_list_lock);\r\n}\r\nstatic int rose_neigh_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11];\r\nint i;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"addr callsign dev count use mode restart t0 tf digipeaters\n");\r\nelse {\r\nstruct rose_neigh *rose_neigh = v;\r\nseq_printf(seq, "%05d %-9s %-4s %3d %3d %3s %3s %3lu %3lu",\r\nrose_neigh->number,\r\n(rose_neigh->loopback) ? "RSLOOP-0" : ax2asc(buf, &rose_neigh->callsign),\r\nrose_neigh->dev ? rose_neigh->dev->name : "???",\r\nrose_neigh->count,\r\nrose_neigh->use,\r\n(rose_neigh->dce_mode) ? "DCE" : "DTE",\r\n(rose_neigh->restarted) ? "yes" : "no",\r\nax25_display_timer(&rose_neigh->t0timer) / HZ,\r\nax25_display_timer(&rose_neigh->ftimer) / HZ);\r\nif (rose_neigh->digipeat != NULL) {\r\nfor (i = 0; i < rose_neigh->digipeat->ndigi; i++)\r\nseq_printf(seq, " %s", ax2asc(buf, &rose_neigh->digipeat->calls[i]));\r\n}\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_neigh_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &rose_neigh_seqops);\r\n}\r\nstatic void *rose_route_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rose_route_list_lock)\r\n{\r\nstruct rose_route *rose_route;\r\nint i = 1;\r\nspin_lock_bh(&rose_route_list_lock);\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (rose_route = rose_route_list; rose_route && i < *pos;\r\nrose_route = rose_route->next, ++i);\r\nreturn (i == *pos) ? rose_route : NULL;\r\n}\r\nstatic void *rose_route_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (v == SEQ_START_TOKEN) ? rose_route_list\r\n: ((struct rose_route *)v)->next;\r\n}\r\nstatic void rose_route_stop(struct seq_file *seq, void *v)\r\n__releases(rose_route_list_lock)\r\n{\r\nspin_unlock_bh(&rose_route_list_lock);\r\n}\r\nstatic int rose_route_show(struct seq_file *seq, void *v)\r\n{\r\nchar buf[11], rsbuf[11];\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"lci address callsign neigh <-> lci address callsign neigh\n");\r\nelse {\r\nstruct rose_route *rose_route = v;\r\nif (rose_route->neigh1)\r\nseq_printf(seq,\r\n"%3.3X %-10s %-9s %05d ",\r\nrose_route->lci1,\r\nrose2asc(rsbuf, &rose_route->src_addr),\r\nax2asc(buf, &rose_route->src_call),\r\nrose_route->neigh1->number);\r\nelse\r\nseq_puts(seq,\r\n"000 * * 00000 ");\r\nif (rose_route->neigh2)\r\nseq_printf(seq,\r\n"%3.3X %-10s %-9s %05d\n",\r\nrose_route->lci2,\r\nrose2asc(rsbuf, &rose_route->dest_addr),\r\nax2asc(buf, &rose_route->dest_call),\r\nrose_route->neigh2->number);\r\nelse\r\nseq_puts(seq,\r\n"000 * * 00000\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int rose_route_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &rose_route_seqops);\r\n}\r\nvoid __exit rose_rt_free(void)\r\n{\r\nstruct rose_neigh *s, *rose_neigh = rose_neigh_list;\r\nstruct rose_node *t, *rose_node = rose_node_list;\r\nstruct rose_route *u, *rose_route = rose_route_list;\r\nwhile (rose_neigh != NULL) {\r\ns = rose_neigh;\r\nrose_neigh = rose_neigh->next;\r\nrose_remove_neigh(s);\r\n}\r\nwhile (rose_node != NULL) {\r\nt = rose_node;\r\nrose_node = rose_node->next;\r\nrose_remove_node(t);\r\n}\r\nwhile (rose_route != NULL) {\r\nu = rose_route;\r\nrose_route = rose_route->next;\r\nrose_remove_route(u);\r\n}\r\n}
