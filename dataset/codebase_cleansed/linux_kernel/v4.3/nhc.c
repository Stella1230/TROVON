static int lowpan_nhc_insert(struct lowpan_nhc *nhc)\r\n{\r\nstruct rb_node **new = &rb_root.rb_node, *parent = NULL;\r\nwhile (*new) {\r\nstruct lowpan_nhc *this = container_of(*new, struct lowpan_nhc,\r\nnode);\r\nint result, len_dif, len;\r\nlen_dif = nhc->idlen - this->idlen;\r\nif (nhc->idlen < this->idlen)\r\nlen = nhc->idlen;\r\nelse\r\nlen = this->idlen;\r\nresult = memcmp(nhc->id, this->id, len);\r\nif (!result)\r\nresult = len_dif;\r\nparent = *new;\r\nif (result < 0)\r\nnew = &((*new)->rb_left);\r\nelse if (result > 0)\r\nnew = &((*new)->rb_right);\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&nhc->node, parent, new);\r\nrb_insert_color(&nhc->node, &rb_root);\r\nreturn 0;\r\n}\r\nstatic void lowpan_nhc_remove(struct lowpan_nhc *nhc)\r\n{\r\nrb_erase(&nhc->node, &rb_root);\r\n}\r\nstatic struct lowpan_nhc *lowpan_nhc_by_nhcid(const struct sk_buff *skb)\r\n{\r\nstruct rb_node *node = rb_root.rb_node;\r\nconst u8 *nhcid_skb_ptr = skb->data;\r\nwhile (node) {\r\nstruct lowpan_nhc *nhc = container_of(node, struct lowpan_nhc,\r\nnode);\r\nu8 nhcid_skb_ptr_masked[LOWPAN_NHC_MAX_ID_LEN];\r\nint result, i;\r\nif (nhcid_skb_ptr + nhc->idlen > skb->data + skb->len)\r\nreturn NULL;\r\nmemcpy(nhcid_skb_ptr_masked, nhcid_skb_ptr, nhc->idlen);\r\nfor (i = 0; i < nhc->idlen; i++)\r\nnhcid_skb_ptr_masked[i] &= nhc->idmask[i];\r\nresult = memcmp(nhcid_skb_ptr_masked, nhc->id, nhc->idlen);\r\nif (result < 0)\r\nnode = node->rb_left;\r\nelse if (result > 0)\r\nnode = node->rb_right;\r\nelse\r\nreturn nhc;\r\n}\r\nreturn NULL;\r\n}\r\nint lowpan_nhc_check_compression(struct sk_buff *skb,\r\nconst struct ipv6hdr *hdr, u8 **hc_ptr,\r\nu8 *iphc0)\r\n{\r\nstruct lowpan_nhc *nhc;\r\nspin_lock_bh(&lowpan_nhc_lock);\r\nnhc = lowpan_nexthdr_nhcs[hdr->nexthdr];\r\nif (nhc && nhc->compress)\r\n*iphc0 |= LOWPAN_IPHC_NH_C;\r\nelse\r\nlowpan_push_hc_data(hc_ptr, &hdr->nexthdr,\r\nsizeof(hdr->nexthdr));\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nreturn 0;\r\n}\r\nint lowpan_nhc_do_compression(struct sk_buff *skb, const struct ipv6hdr *hdr,\r\nu8 **hc_ptr)\r\n{\r\nint ret;\r\nstruct lowpan_nhc *nhc;\r\nspin_lock_bh(&lowpan_nhc_lock);\r\nnhc = lowpan_nexthdr_nhcs[hdr->nexthdr];\r\nif (unlikely(!nhc || !nhc->compress)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (skb->transport_header == skb->network_header)\r\nskb_set_transport_header(skb, sizeof(struct ipv6hdr));\r\nret = nhc->compress(skb, hc_ptr);\r\nif (ret < 0)\r\ngoto out;\r\nskb_pull(skb, nhc->nexthdrlen);\r\nout:\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nreturn ret;\r\n}\r\nint lowpan_nhc_do_uncompression(struct sk_buff *skb, struct net_device *dev,\r\nstruct ipv6hdr *hdr)\r\n{\r\nstruct lowpan_nhc *nhc;\r\nint ret;\r\nspin_lock_bh(&lowpan_nhc_lock);\r\nnhc = lowpan_nhc_by_nhcid(skb);\r\nif (nhc) {\r\nif (nhc->uncompress) {\r\nret = nhc->uncompress(skb, sizeof(struct ipv6hdr) +\r\nnhc->nexthdrlen);\r\nif (ret < 0) {\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nreturn ret;\r\n}\r\n} else {\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nnetdev_warn(dev, "received nhc id for %s which is not implemented.\n",\r\nnhc->name);\r\nreturn -ENOTSUPP;\r\n}\r\n} else {\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nnetdev_warn(dev, "received unknown nhc id which was not found.\n");\r\nreturn -ENOENT;\r\n}\r\nhdr->nexthdr = nhc->nexthdr;\r\nskb_reset_transport_header(skb);\r\nraw_dump_table(__func__, "raw transport header dump",\r\nskb_transport_header(skb), nhc->nexthdrlen);\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nreturn 0;\r\n}\r\nint lowpan_nhc_add(struct lowpan_nhc *nhc)\r\n{\r\nint ret;\r\nif (!nhc->idlen || !nhc->idsetup)\r\nreturn -EINVAL;\r\nWARN_ONCE(nhc->idlen > LOWPAN_NHC_MAX_ID_LEN,\r\n"LOWPAN_NHC_MAX_ID_LEN should be updated to %zd.\n",\r\nnhc->idlen);\r\nnhc->idsetup(nhc);\r\nspin_lock_bh(&lowpan_nhc_lock);\r\nif (lowpan_nexthdr_nhcs[nhc->nexthdr]) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nret = lowpan_nhc_insert(nhc);\r\nif (ret < 0)\r\ngoto out;\r\nlowpan_nexthdr_nhcs[nhc->nexthdr] = nhc;\r\nout:\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nreturn ret;\r\n}\r\nvoid lowpan_nhc_del(struct lowpan_nhc *nhc)\r\n{\r\nspin_lock_bh(&lowpan_nhc_lock);\r\nlowpan_nhc_remove(nhc);\r\nlowpan_nexthdr_nhcs[nhc->nexthdr] = NULL;\r\nspin_unlock_bh(&lowpan_nhc_lock);\r\nsynchronize_net();\r\n}
