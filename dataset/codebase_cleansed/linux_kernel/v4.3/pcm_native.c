void snd_pcm_stream_lock(struct snd_pcm_substream *substream)\r\n{\r\nif (substream->pcm->nonatomic) {\r\ndown_read_nested(&snd_pcm_link_rwsem, SINGLE_DEPTH_NESTING);\r\nmutex_lock(&substream->self_group.mutex);\r\n} else {\r\nread_lock(&snd_pcm_link_rwlock);\r\nspin_lock(&substream->self_group.lock);\r\n}\r\n}\r\nvoid snd_pcm_stream_unlock(struct snd_pcm_substream *substream)\r\n{\r\nif (substream->pcm->nonatomic) {\r\nmutex_unlock(&substream->self_group.mutex);\r\nup_read(&snd_pcm_link_rwsem);\r\n} else {\r\nspin_unlock(&substream->self_group.lock);\r\nread_unlock(&snd_pcm_link_rwlock);\r\n}\r\n}\r\nvoid snd_pcm_stream_lock_irq(struct snd_pcm_substream *substream)\r\n{\r\nif (!substream->pcm->nonatomic)\r\nlocal_irq_disable();\r\nsnd_pcm_stream_lock(substream);\r\n}\r\nvoid snd_pcm_stream_unlock_irq(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_stream_unlock(substream);\r\nif (!substream->pcm->nonatomic)\r\nlocal_irq_enable();\r\n}\r\nunsigned long _snd_pcm_stream_lock_irqsave(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags = 0;\r\nif (!substream->pcm->nonatomic)\r\nlocal_irq_save(flags);\r\nsnd_pcm_stream_lock(substream);\r\nreturn flags;\r\n}\r\nvoid snd_pcm_stream_unlock_irqrestore(struct snd_pcm_substream *substream,\r\nunsigned long flags)\r\n{\r\nsnd_pcm_stream_unlock(substream);\r\nif (!substream->pcm->nonatomic)\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline mm_segment_t snd_enter_user(void)\r\n{\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\nreturn fs;\r\n}\r\nstatic inline void snd_leave_user(mm_segment_t fs)\r\n{\r\nset_fs(fs);\r\n}\r\nint snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_pcm *pcm = substream->pcm;\r\nstruct snd_pcm_str *pstr = substream->pstr;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->card = pcm->card->number;\r\ninfo->device = pcm->device;\r\ninfo->stream = substream->stream;\r\ninfo->subdevice = substream->number;\r\nstrlcpy(info->id, pcm->id, sizeof(info->id));\r\nstrlcpy(info->name, pcm->name, sizeof(info->name));\r\ninfo->dev_class = pcm->dev_class;\r\ninfo->dev_subclass = pcm->dev_subclass;\r\ninfo->subdevices_count = pstr->substream_count;\r\ninfo->subdevices_avail = pstr->substream_count - pstr->substream_opened;\r\nstrlcpy(info->subname, substream->name, sizeof(info->subname));\r\nruntime = substream->runtime;\r\nif (runtime) {\r\ninfo->sync = runtime->sync;\r\nsubstream->ops->ioctl(substream, SNDRV_PCM_IOCTL1_INFO, info);\r\n}\r\nreturn 0;\r\n}\r\nint snd_pcm_info_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_info __user * _info)\r\n{\r\nstruct snd_pcm_info *info;\r\nint err;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (! info)\r\nreturn -ENOMEM;\r\nerr = snd_pcm_info(substream, info);\r\nif (err >= 0) {\r\nif (copy_to_user(_info, info, sizeof(*info)))\r\nerr = -EFAULT;\r\n}\r\nkfree(info);\r\nreturn err;\r\n}\r\nstatic bool hw_support_mmap(struct snd_pcm_substream *substream)\r\n{\r\nif (!(substream->runtime->hw.info & SNDRV_PCM_INFO_MMAP))\r\nreturn false;\r\n#if defined(CONFIG_C6X) || defined(CONFIG_FRV) || defined(CONFIG_MN10300) ||\\r\ndefined(CONFIG_PARISC) || defined(CONFIG_XTENSA)\r\nif (!substream->ops->mmap &&\r\nsubstream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV)\r\nreturn false;\r\n#endif\r\nreturn true;\r\n}\r\nint snd_pcm_hw_refine(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nunsigned int k;\r\nstruct snd_pcm_hardware *hw;\r\nstruct snd_interval *i = NULL;\r\nstruct snd_mask *m = NULL;\r\nstruct snd_pcm_hw_constraints *constrs = &substream->runtime->hw_constraints;\r\nunsigned int rstamps[constrs->rules_num];\r\nunsigned int vstamps[SNDRV_PCM_HW_PARAM_LAST_INTERVAL + 1];\r\nunsigned int stamp = 2;\r\nint changed, again;\r\nparams->info = 0;\r\nparams->fifo_size = 0;\r\nif (params->rmask & (1 << SNDRV_PCM_HW_PARAM_SAMPLE_BITS))\r\nparams->msbits = 0;\r\nif (params->rmask & (1 << SNDRV_PCM_HW_PARAM_RATE)) {\r\nparams->rate_num = 0;\r\nparams->rate_den = 0;\r\n}\r\nfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++) {\r\nm = hw_param_mask(params, k);\r\nif (snd_mask_empty(m))\r\nreturn -EINVAL;\r\nif (!(params->rmask & (1 << k)))\r\ncontinue;\r\n#ifdef RULES_DEBUG\r\npr_debug("%s = ", snd_pcm_hw_param_names[k]);\r\npr_cont("%04x%04x%04x%04x -> ", m->bits[3], m->bits[2], m->bits[1], m->bits[0]);\r\n#endif\r\nchanged = snd_mask_refine(m, constrs_mask(constrs, k));\r\n#ifdef RULES_DEBUG\r\npr_cont("%04x%04x%04x%04x\n", m->bits[3], m->bits[2], m->bits[1], m->bits[0]);\r\n#endif\r\nif (changed)\r\nparams->cmask |= 1 << k;\r\nif (changed < 0)\r\nreturn changed;\r\n}\r\nfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++) {\r\ni = hw_param_interval(params, k);\r\nif (snd_interval_empty(i))\r\nreturn -EINVAL;\r\nif (!(params->rmask & (1 << k)))\r\ncontinue;\r\n#ifdef RULES_DEBUG\r\npr_debug("%s = ", snd_pcm_hw_param_names[k]);\r\nif (i->empty)\r\npr_cont("empty");\r\nelse\r\npr_cont("%c%u %u%c",\r\ni->openmin ? '(' : '[', i->min,\r\ni->max, i->openmax ? ')' : ']');\r\npr_cont(" -> ");\r\n#endif\r\nchanged = snd_interval_refine(i, constrs_interval(constrs, k));\r\n#ifdef RULES_DEBUG\r\nif (i->empty)\r\npr_cont("empty\n");\r\nelse\r\npr_cont("%c%u %u%c\n",\r\ni->openmin ? '(' : '[', i->min,\r\ni->max, i->openmax ? ')' : ']');\r\n#endif\r\nif (changed)\r\nparams->cmask |= 1 << k;\r\nif (changed < 0)\r\nreturn changed;\r\n}\r\nfor (k = 0; k < constrs->rules_num; k++)\r\nrstamps[k] = 0;\r\nfor (k = 0; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++)\r\nvstamps[k] = (params->rmask & (1 << k)) ? 1 : 0;\r\ndo {\r\nagain = 0;\r\nfor (k = 0; k < constrs->rules_num; k++) {\r\nstruct snd_pcm_hw_rule *r = &constrs->rules[k];\r\nunsigned int d;\r\nint doit = 0;\r\nif (r->cond && !(r->cond & params->flags))\r\ncontinue;\r\nfor (d = 0; r->deps[d] >= 0; d++) {\r\nif (vstamps[r->deps[d]] > rstamps[k]) {\r\ndoit = 1;\r\nbreak;\r\n}\r\n}\r\nif (!doit)\r\ncontinue;\r\n#ifdef RULES_DEBUG\r\npr_debug("Rule %d [%p]: ", k, r->func);\r\nif (r->var >= 0) {\r\npr_cont("%s = ", snd_pcm_hw_param_names[r->var]);\r\nif (hw_is_mask(r->var)) {\r\nm = hw_param_mask(params, r->var);\r\npr_cont("%x", *m->bits);\r\n} else {\r\ni = hw_param_interval(params, r->var);\r\nif (i->empty)\r\npr_cont("empty");\r\nelse\r\npr_cont("%c%u %u%c",\r\ni->openmin ? '(' : '[', i->min,\r\ni->max, i->openmax ? ')' : ']');\r\n}\r\n}\r\n#endif\r\nchanged = r->func(params, r);\r\n#ifdef RULES_DEBUG\r\nif (r->var >= 0) {\r\npr_cont(" -> ");\r\nif (hw_is_mask(r->var))\r\npr_cont("%x", *m->bits);\r\nelse {\r\nif (i->empty)\r\npr_cont("empty");\r\nelse\r\npr_cont("%c%u %u%c",\r\ni->openmin ? '(' : '[', i->min,\r\ni->max, i->openmax ? ')' : ']');\r\n}\r\n}\r\npr_cont("\n");\r\n#endif\r\nrstamps[k] = stamp;\r\nif (changed && r->var >= 0) {\r\nparams->cmask |= (1 << r->var);\r\nvstamps[r->var] = stamp;\r\nagain = 1;\r\n}\r\nif (changed < 0)\r\nreturn changed;\r\nstamp++;\r\n}\r\n} while (again);\r\nif (!params->msbits) {\r\ni = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\r\nif (snd_interval_single(i))\r\nparams->msbits = snd_interval_value(i);\r\n}\r\nif (!params->rate_den) {\r\ni = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (snd_interval_single(i)) {\r\nparams->rate_num = snd_interval_value(i);\r\nparams->rate_den = 1;\r\n}\r\n}\r\nhw = &substream->runtime->hw;\r\nif (!params->info) {\r\nparams->info = hw->info & ~(SNDRV_PCM_INFO_FIFO_IN_FRAMES |\r\nSNDRV_PCM_INFO_DRAIN_TRIGGER);\r\nif (!hw_support_mmap(substream))\r\nparams->info &= ~(SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID);\r\n}\r\nif (!params->fifo_size) {\r\nm = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\ni = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nif (snd_mask_min(m) == snd_mask_max(m) &&\r\nsnd_interval_min(i) == snd_interval_max(i)) {\r\nchanged = substream->ops->ioctl(substream,\r\nSNDRV_PCM_IOCTL1_FIFO_SIZE, params);\r\nif (changed < 0)\r\nreturn changed;\r\n}\r\n}\r\nparams->rmask = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_hw_refine_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params __user * _params)\r\n{\r\nstruct snd_pcm_hw_params *params;\r\nint err;\r\nparams = memdup_user(_params, sizeof(*params));\r\nif (IS_ERR(params))\r\nreturn PTR_ERR(params);\r\nerr = snd_pcm_hw_refine(substream, params);\r\nif (copy_to_user(_params, params, sizeof(*params))) {\r\nif (!err)\r\nerr = -EFAULT;\r\n}\r\nkfree(params);\r\nreturn err;\r\n}\r\nstatic int period_to_usecs(struct snd_pcm_runtime *runtime)\r\n{\r\nint usecs;\r\nif (! runtime->rate)\r\nreturn -1;\r\nusecs = (750000 / runtime->rate) * runtime->period_size;\r\nusecs += ((750000 % runtime->rate) * runtime->period_size) /\r\nruntime->rate;\r\nreturn usecs;\r\n}\r\nstatic void snd_pcm_set_state(struct snd_pcm_substream *substream, int state)\r\n{\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_DISCONNECTED)\r\nsubstream->runtime->status->state = state;\r\nsnd_pcm_stream_unlock_irq(substream);\r\n}\r\nstatic int snd_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint err, usecs;\r\nunsigned int bits;\r\nsnd_pcm_uframes_t frames;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_OPEN:\r\ncase SNDRV_PCM_STATE_SETUP:\r\ncase SNDRV_PCM_STATE_PREPARED:\r\nbreak;\r\ndefault:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn -EBADFD;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\n#if IS_ENABLED(CONFIG_SND_PCM_OSS)\r\nif (!substream->oss.oss)\r\n#endif\r\nif (atomic_read(&substream->mmap_count))\r\nreturn -EBADFD;\r\nparams->rmask = ~0U;\r\nerr = snd_pcm_hw_refine(substream, params);\r\nif (err < 0)\r\ngoto _error;\r\nerr = snd_pcm_hw_params_choose(substream, params);\r\nif (err < 0)\r\ngoto _error;\r\nif (substream->ops->hw_params != NULL) {\r\nerr = substream->ops->hw_params(substream, params);\r\nif (err < 0)\r\ngoto _error;\r\n}\r\nruntime->access = params_access(params);\r\nruntime->format = params_format(params);\r\nruntime->subformat = params_subformat(params);\r\nruntime->channels = params_channels(params);\r\nruntime->rate = params_rate(params);\r\nruntime->period_size = params_period_size(params);\r\nruntime->periods = params_periods(params);\r\nruntime->buffer_size = params_buffer_size(params);\r\nruntime->info = params->info;\r\nruntime->rate_num = params->rate_num;\r\nruntime->rate_den = params->rate_den;\r\nruntime->no_period_wakeup =\r\n(params->info & SNDRV_PCM_INFO_NO_PERIOD_WAKEUP) &&\r\n(params->flags & SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP);\r\nbits = snd_pcm_format_physical_width(runtime->format);\r\nruntime->sample_bits = bits;\r\nbits *= runtime->channels;\r\nruntime->frame_bits = bits;\r\nframes = 1;\r\nwhile (bits % 8 != 0) {\r\nbits *= 2;\r\nframes *= 2;\r\n}\r\nruntime->byte_align = bits / 8;\r\nruntime->min_align = frames;\r\nruntime->tstamp_mode = SNDRV_PCM_TSTAMP_NONE;\r\nruntime->period_step = 1;\r\nruntime->control->avail_min = runtime->period_size;\r\nruntime->start_threshold = 1;\r\nruntime->stop_threshold = runtime->buffer_size;\r\nruntime->silence_threshold = 0;\r\nruntime->silence_size = 0;\r\nruntime->boundary = runtime->buffer_size;\r\nwhile (runtime->boundary * 2 <= LONG_MAX - runtime->buffer_size)\r\nruntime->boundary *= 2;\r\nsnd_pcm_timer_resolution_change(substream);\r\nsnd_pcm_set_state(substream, SNDRV_PCM_STATE_SETUP);\r\nif (pm_qos_request_active(&substream->latency_pm_qos_req))\r\npm_qos_remove_request(&substream->latency_pm_qos_req);\r\nif ((usecs = period_to_usecs(runtime)) >= 0)\r\npm_qos_add_request(&substream->latency_pm_qos_req,\r\nPM_QOS_CPU_DMA_LATENCY, usecs);\r\nreturn 0;\r\n_error:\r\nsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\r\nif (substream->ops->hw_free != NULL)\r\nsubstream->ops->hw_free(substream);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params __user * _params)\r\n{\r\nstruct snd_pcm_hw_params *params;\r\nint err;\r\nparams = memdup_user(_params, sizeof(*params));\r\nif (IS_ERR(params))\r\nreturn PTR_ERR(params);\r\nerr = snd_pcm_hw_params(substream, params);\r\nif (copy_to_user(_params, params, sizeof(*params))) {\r\nif (!err)\r\nerr = -EFAULT;\r\n}\r\nkfree(params);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint result = 0;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_SETUP:\r\ncase SNDRV_PCM_STATE_PREPARED:\r\nbreak;\r\ndefault:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn -EBADFD;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (atomic_read(&substream->mmap_count))\r\nreturn -EBADFD;\r\nif (substream->ops->hw_free)\r\nresult = substream->ops->hw_free(substream);\r\nsnd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);\r\npm_qos_remove_request(&substream->latency_pm_qos_req);\r\nreturn result;\r\n}\r\nstatic int snd_pcm_sw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_sw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint err;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn -EBADFD;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (params->tstamp_mode > SNDRV_PCM_TSTAMP_LAST)\r\nreturn -EINVAL;\r\nif (params->proto >= SNDRV_PROTOCOL_VERSION(2, 0, 12) &&\r\nparams->tstamp_type > SNDRV_PCM_TSTAMP_TYPE_LAST)\r\nreturn -EINVAL;\r\nif (params->avail_min == 0)\r\nreturn -EINVAL;\r\nif (params->silence_size >= runtime->boundary) {\r\nif (params->silence_threshold != 0)\r\nreturn -EINVAL;\r\n} else {\r\nif (params->silence_size > params->silence_threshold)\r\nreturn -EINVAL;\r\nif (params->silence_threshold > runtime->buffer_size)\r\nreturn -EINVAL;\r\n}\r\nerr = 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nruntime->tstamp_mode = params->tstamp_mode;\r\nif (params->proto >= SNDRV_PROTOCOL_VERSION(2, 0, 12))\r\nruntime->tstamp_type = params->tstamp_type;\r\nruntime->period_step = params->period_step;\r\nruntime->control->avail_min = params->avail_min;\r\nruntime->start_threshold = params->start_threshold;\r\nruntime->stop_threshold = params->stop_threshold;\r\nruntime->silence_threshold = params->silence_threshold;\r\nruntime->silence_size = params->silence_size;\r\nparams->boundary = runtime->boundary;\r\nif (snd_pcm_running(substream)) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nruntime->silence_size > 0)\r\nsnd_pcm_playback_silence(substream, ULONG_MAX);\r\nerr = snd_pcm_update_state(substream, runtime);\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_sw_params_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_sw_params __user * _params)\r\n{\r\nstruct snd_pcm_sw_params params;\r\nint err;\r\nif (copy_from_user(&params, _params, sizeof(params)))\r\nreturn -EFAULT;\r\nerr = snd_pcm_sw_params(substream, &params);\r\nif (copy_to_user(_params, &params, sizeof(params)))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nint snd_pcm_status(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_status *status)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_stream_lock_irq(substream);\r\nsnd_pcm_unpack_audio_tstamp_config(status->audio_tstamp_data,\r\n&runtime->audio_tstamp_config);\r\nif (runtime->audio_tstamp_config.type_requested ==\r\nSNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT) {\r\nif (runtime->hw.info & SNDRV_PCM_INFO_HAS_WALL_CLOCK)\r\nruntime->audio_tstamp_config.type_requested =\r\nSNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK;\r\nelse\r\nruntime->audio_tstamp_config.type_requested =\r\nSNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT;\r\nruntime->audio_tstamp_report.valid = 0;\r\n} else\r\nruntime->audio_tstamp_report.valid = 1;\r\nstatus->state = runtime->status->state;\r\nstatus->suspended_state = runtime->status->suspended_state;\r\nif (status->state == SNDRV_PCM_STATE_OPEN)\r\ngoto _end;\r\nstatus->trigger_tstamp = runtime->trigger_tstamp;\r\nif (snd_pcm_running(substream)) {\r\nsnd_pcm_update_hw_ptr(substream);\r\nif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE) {\r\nstatus->tstamp = runtime->status->tstamp;\r\nstatus->driver_tstamp = runtime->driver_tstamp;\r\nstatus->audio_tstamp =\r\nruntime->status->audio_tstamp;\r\nif (runtime->audio_tstamp_report.valid == 1)\r\nsnd_pcm_pack_audio_tstamp_report(&status->audio_tstamp_data,\r\n&status->audio_tstamp_accuracy,\r\n&runtime->audio_tstamp_report);\r\ngoto _tstamp_end;\r\n}\r\n} else {\r\nif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)\r\nsnd_pcm_gettime(runtime, &status->tstamp);\r\n}\r\n_tstamp_end:\r\nstatus->appl_ptr = runtime->control->appl_ptr;\r\nstatus->hw_ptr = runtime->status->hw_ptr;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nstatus->avail = snd_pcm_playback_avail(runtime);\r\nif (runtime->status->state == SNDRV_PCM_STATE_RUNNING ||\r\nruntime->status->state == SNDRV_PCM_STATE_DRAINING) {\r\nstatus->delay = runtime->buffer_size - status->avail;\r\nstatus->delay += runtime->delay;\r\n} else\r\nstatus->delay = 0;\r\n} else {\r\nstatus->avail = snd_pcm_capture_avail(runtime);\r\nif (runtime->status->state == SNDRV_PCM_STATE_RUNNING)\r\nstatus->delay = status->avail + runtime->delay;\r\nelse\r\nstatus->delay = 0;\r\n}\r\nstatus->avail_max = runtime->avail_max;\r\nstatus->overrange = runtime->overrange;\r\nruntime->avail_max = 0;\r\nruntime->overrange = 0;\r\n_end:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_status_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_status __user * _status,\r\nbool ext)\r\n{\r\nstruct snd_pcm_status status;\r\nint res;\r\nmemset(&status, 0, sizeof(status));\r\nif (ext && get_user(status.audio_tstamp_data,\r\n(u32 __user *)(&_status->audio_tstamp_data)))\r\nreturn -EFAULT;\r\nres = snd_pcm_status(substream, &status);\r\nif (res < 0)\r\nreturn res;\r\nif (copy_to_user(_status, &status, sizeof(status)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_channel_info(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_channel_info * info)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int channel;\r\nchannel = info->channel;\r\nruntime = substream->runtime;\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn -EBADFD;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (channel >= runtime->channels)\r\nreturn -EINVAL;\r\nmemset(info, 0, sizeof(*info));\r\ninfo->channel = channel;\r\nreturn substream->ops->ioctl(substream, SNDRV_PCM_IOCTL1_CHANNEL_INFO, info);\r\n}\r\nstatic int snd_pcm_channel_info_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_channel_info __user * _info)\r\n{\r\nstruct snd_pcm_channel_info info;\r\nint res;\r\nif (copy_from_user(&info, _info, sizeof(info)))\r\nreturn -EFAULT;\r\nres = snd_pcm_channel_info(substream, &info);\r\nif (res < 0)\r\nreturn res;\r\nif (copy_to_user(_info, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_trigger_tstamp(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->trigger_master == NULL)\r\nreturn;\r\nif (runtime->trigger_master == substream) {\r\nif (!runtime->trigger_tstamp_latched)\r\nsnd_pcm_gettime(runtime, &runtime->trigger_tstamp);\r\n} else {\r\nsnd_pcm_trigger_tstamp(runtime->trigger_master);\r\nruntime->trigger_tstamp = runtime->trigger_master->runtime->trigger_tstamp;\r\n}\r\nruntime->trigger_master = NULL;\r\n}\r\nstatic int snd_pcm_action_group(struct action_ops *ops,\r\nstruct snd_pcm_substream *substream,\r\nint state, int do_lock)\r\n{\r\nstruct snd_pcm_substream *s = NULL;\r\nstruct snd_pcm_substream *s1;\r\nint res = 0, depth = 1;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (do_lock && s != substream) {\r\nif (s->pcm->nonatomic)\r\nmutex_lock_nested(&s->self_group.mutex, depth);\r\nelse\r\nspin_lock_nested(&s->self_group.lock, depth);\r\ndepth++;\r\n}\r\nres = ops->pre_action(s, state);\r\nif (res < 0)\r\ngoto _unlock;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nres = ops->do_action(s, state);\r\nif (res < 0) {\r\nif (ops->undo_action) {\r\nsnd_pcm_group_for_each_entry(s1, substream) {\r\nif (s1 == s)\r\nbreak;\r\nops->undo_action(s1, state);\r\n}\r\n}\r\ns = NULL;\r\ngoto _unlock;\r\n}\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nops->post_action(s, state);\r\n}\r\n_unlock:\r\nif (do_lock) {\r\nsnd_pcm_group_for_each_entry(s1, substream) {\r\nif (s1 != substream) {\r\nif (s1->pcm->nonatomic)\r\nmutex_unlock(&s1->self_group.mutex);\r\nelse\r\nspin_unlock(&s1->self_group.lock);\r\n}\r\nif (s1 == s)\r\nbreak;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int snd_pcm_action_single(struct action_ops *ops,\r\nstruct snd_pcm_substream *substream,\r\nint state)\r\n{\r\nint res;\r\nres = ops->pre_action(substream, state);\r\nif (res < 0)\r\nreturn res;\r\nres = ops->do_action(substream, state);\r\nif (res == 0)\r\nops->post_action(substream, state);\r\nelse if (ops->undo_action)\r\nops->undo_action(substream, state);\r\nreturn res;\r\n}\r\nstatic int snd_pcm_action(struct action_ops *ops,\r\nstruct snd_pcm_substream *substream,\r\nint state)\r\n{\r\nint res;\r\nif (!snd_pcm_stream_linked(substream))\r\nreturn snd_pcm_action_single(ops, substream, state);\r\nif (substream->pcm->nonatomic) {\r\nif (!mutex_trylock(&substream->group->mutex)) {\r\nmutex_unlock(&substream->self_group.mutex);\r\nmutex_lock(&substream->group->mutex);\r\nmutex_lock(&substream->self_group.mutex);\r\n}\r\nres = snd_pcm_action_group(ops, substream, state, 1);\r\nmutex_unlock(&substream->group->mutex);\r\n} else {\r\nif (!spin_trylock(&substream->group->lock)) {\r\nspin_unlock(&substream->self_group.lock);\r\nspin_lock(&substream->group->lock);\r\nspin_lock(&substream->self_group.lock);\r\n}\r\nres = snd_pcm_action_group(ops, substream, state, 1);\r\nspin_unlock(&substream->group->lock);\r\n}\r\nreturn res;\r\n}\r\nstatic int snd_pcm_action_lock_irq(struct action_ops *ops,\r\nstruct snd_pcm_substream *substream,\r\nint state)\r\n{\r\nint res;\r\nsnd_pcm_stream_lock_irq(substream);\r\nres = snd_pcm_action(ops, substream, state);\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn res;\r\n}\r\nstatic int snd_pcm_action_nonatomic(struct action_ops *ops,\r\nstruct snd_pcm_substream *substream,\r\nint state)\r\n{\r\nint res;\r\ndown_read(&snd_pcm_link_rwsem);\r\nif (snd_pcm_stream_linked(substream))\r\nres = snd_pcm_action_group(ops, substream, state, 0);\r\nelse\r\nres = snd_pcm_action_single(ops, substream, state);\r\nup_read(&snd_pcm_link_rwsem);\r\nreturn res;\r\n}\r\nstatic int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->status->state != SNDRV_PCM_STATE_PREPARED)\r\nreturn -EBADFD;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\n!snd_pcm_playback_data(substream))\r\nreturn -EPIPE;\r\nruntime->trigger_tstamp_latched = false;\r\nruntime->trigger_master = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_start(struct snd_pcm_substream *substream, int state)\r\n{\r\nif (substream->runtime->trigger_master != substream)\r\nreturn 0;\r\nreturn substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);\r\n}\r\nstatic void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state)\r\n{\r\nif (substream->runtime->trigger_master == substream)\r\nsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);\r\n}\r\nstatic void snd_pcm_post_start(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_trigger_tstamp(substream);\r\nruntime->hw_ptr_jiffies = jiffies;\r\nruntime->hw_ptr_buffer_jiffies = (runtime->buffer_size * HZ) /\r\nruntime->rate;\r\nruntime->status->state = state;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nruntime->silence_size > 0)\r\nsnd_pcm_playback_silence(substream, ULONG_MAX);\r\nif (substream->timer)\r\nsnd_timer_notify(substream->timer, SNDRV_TIMER_EVENT_MSTART,\r\n&runtime->trigger_tstamp);\r\n}\r\nint snd_pcm_start(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_action(&snd_pcm_action_start, substream,\r\nSNDRV_PCM_STATE_RUNNING);\r\n}\r\nstatic int snd_pcm_pre_stop(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nruntime->trigger_master = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_stop(struct snd_pcm_substream *substream, int state)\r\n{\r\nif (substream->runtime->trigger_master == substream &&\r\nsnd_pcm_running(substream))\r\nsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_post_stop(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->status->state != state) {\r\nsnd_pcm_trigger_tstamp(substream);\r\nruntime->status->state = state;\r\nif (substream->timer)\r\nsnd_timer_notify(substream->timer, SNDRV_TIMER_EVENT_MSTOP,\r\n&runtime->trigger_tstamp);\r\n}\r\nwake_up(&runtime->sleep);\r\nwake_up(&runtime->tsleep);\r\n}\r\nint snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t state)\r\n{\r\nreturn snd_pcm_action(&snd_pcm_action_stop, substream, state);\r\n}\r\nint snd_pcm_drain_done(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_action_single(&snd_pcm_action_stop, substream,\r\nSNDRV_PCM_STATE_SETUP);\r\n}\r\nint snd_pcm_stop_xrun(struct snd_pcm_substream *substream)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\nif (snd_pcm_running(substream))\r\nret = snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\nreturn ret;\r\n}\r\nstatic int snd_pcm_pre_pause(struct snd_pcm_substream *substream, int push)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (!(runtime->info & SNDRV_PCM_INFO_PAUSE))\r\nreturn -ENOSYS;\r\nif (push) {\r\nif (runtime->status->state != SNDRV_PCM_STATE_RUNNING)\r\nreturn -EBADFD;\r\n} else if (runtime->status->state != SNDRV_PCM_STATE_PAUSED)\r\nreturn -EBADFD;\r\nruntime->trigger_master = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_pause(struct snd_pcm_substream *substream, int push)\r\n{\r\nif (substream->runtime->trigger_master != substream)\r\nreturn 0;\r\nif (push)\r\nsnd_pcm_update_hw_ptr(substream);\r\nsubstream->runtime->hw_ptr_jiffies = jiffies - HZ * 1000;\r\nreturn substream->ops->trigger(substream,\r\npush ? SNDRV_PCM_TRIGGER_PAUSE_PUSH :\r\nSNDRV_PCM_TRIGGER_PAUSE_RELEASE);\r\n}\r\nstatic void snd_pcm_undo_pause(struct snd_pcm_substream *substream, int push)\r\n{\r\nif (substream->runtime->trigger_master == substream)\r\nsubstream->ops->trigger(substream,\r\npush ? SNDRV_PCM_TRIGGER_PAUSE_RELEASE :\r\nSNDRV_PCM_TRIGGER_PAUSE_PUSH);\r\n}\r\nstatic void snd_pcm_post_pause(struct snd_pcm_substream *substream, int push)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_trigger_tstamp(substream);\r\nif (push) {\r\nruntime->status->state = SNDRV_PCM_STATE_PAUSED;\r\nif (substream->timer)\r\nsnd_timer_notify(substream->timer,\r\nSNDRV_TIMER_EVENT_MPAUSE,\r\n&runtime->trigger_tstamp);\r\nwake_up(&runtime->sleep);\r\nwake_up(&runtime->tsleep);\r\n} else {\r\nruntime->status->state = SNDRV_PCM_STATE_RUNNING;\r\nif (substream->timer)\r\nsnd_timer_notify(substream->timer,\r\nSNDRV_TIMER_EVENT_MCONTINUE,\r\n&runtime->trigger_tstamp);\r\n}\r\n}\r\nstatic int snd_pcm_pause(struct snd_pcm_substream *substream, int push)\r\n{\r\nreturn snd_pcm_action(&snd_pcm_action_pause, substream, push);\r\n}\r\nstatic int snd_pcm_pre_suspend(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_SUSPENDED)\r\nreturn -EBUSY;\r\nruntime->trigger_master = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_suspend(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->trigger_master != substream)\r\nreturn 0;\r\nif (! snd_pcm_running(substream))\r\nreturn 0;\r\nsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_SUSPEND);\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_post_suspend(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_trigger_tstamp(substream);\r\nruntime->status->suspended_state = runtime->status->state;\r\nruntime->status->state = SNDRV_PCM_STATE_SUSPENDED;\r\nif (substream->timer)\r\nsnd_timer_notify(substream->timer, SNDRV_TIMER_EVENT_MSUSPEND,\r\n&runtime->trigger_tstamp);\r\nwake_up(&runtime->sleep);\r\nwake_up(&runtime->tsleep);\r\n}\r\nint snd_pcm_suspend(struct snd_pcm_substream *substream)\r\n{\r\nint err;\r\nunsigned long flags;\r\nif (! substream)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\nerr = snd_pcm_action(&snd_pcm_action_suspend, substream, 0);\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\nreturn err;\r\n}\r\nint snd_pcm_suspend_all(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint stream, err = 0;\r\nif (! pcm)\r\nreturn 0;\r\nfor (stream = 0; stream < 2; stream++) {\r\nfor (substream = pcm->streams[stream].substream;\r\nsubstream; substream = substream->next) {\r\nif (substream->runtime == NULL)\r\ncontinue;\r\nerr = snd_pcm_suspend(substream);\r\nif (err < 0 && err != -EBUSY)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_pre_resume(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (!(runtime->info & SNDRV_PCM_INFO_RESUME))\r\nreturn -ENOSYS;\r\nruntime->trigger_master = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_resume(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->trigger_master != substream)\r\nreturn 0;\r\nif (runtime->status->suspended_state != SNDRV_PCM_STATE_RUNNING &&\r\n(runtime->status->suspended_state != SNDRV_PCM_STATE_DRAINING ||\r\nsubstream->stream != SNDRV_PCM_STREAM_PLAYBACK))\r\nreturn 0;\r\nreturn substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_RESUME);\r\n}\r\nstatic void snd_pcm_undo_resume(struct snd_pcm_substream *substream, int state)\r\n{\r\nif (substream->runtime->trigger_master == substream &&\r\nsnd_pcm_running(substream))\r\nsubstream->ops->trigger(substream, SNDRV_PCM_TRIGGER_SUSPEND);\r\n}\r\nstatic void snd_pcm_post_resume(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_trigger_tstamp(substream);\r\nruntime->status->state = runtime->status->suspended_state;\r\nif (substream->timer)\r\nsnd_timer_notify(substream->timer, SNDRV_TIMER_EVENT_MRESUME,\r\n&runtime->trigger_tstamp);\r\n}\r\nstatic int snd_pcm_resume(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_card *card = substream->pcm->card;\r\nint res;\r\nsnd_power_lock(card);\r\nif ((res = snd_power_wait(card, SNDRV_CTL_POWER_D0)) >= 0)\r\nres = snd_pcm_action_lock_irq(&snd_pcm_action_resume, substream, 0);\r\nsnd_power_unlock(card);\r\nreturn res;\r\n}\r\nstatic int snd_pcm_resume(struct snd_pcm_substream *substream)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int snd_pcm_xrun(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_card *card = substream->pcm->card;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint result;\r\nsnd_power_lock(card);\r\nif (runtime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\nresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\r\nif (result < 0)\r\ngoto _unlock;\r\n}\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_XRUN:\r\nresult = 0;\r\nbreak;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nresult = snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nbreak;\r\ndefault:\r\nresult = -EBADFD;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\n_unlock:\r\nsnd_power_unlock(card);\r\nreturn result;\r\n}\r\nstatic int snd_pcm_pre_reset(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_RUNNING:\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nreturn 0;\r\ndefault:\r\nreturn -EBADFD;\r\n}\r\n}\r\nstatic int snd_pcm_do_reset(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err = substream->ops->ioctl(substream, SNDRV_PCM_IOCTL1_RESET, NULL);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw_ptr_base = 0;\r\nruntime->hw_ptr_interrupt = runtime->status->hw_ptr -\r\nruntime->status->hw_ptr % runtime->period_size;\r\nruntime->silence_start = runtime->status->hw_ptr;\r\nruntime->silence_filled = 0;\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_post_reset(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->control->appl_ptr = runtime->status->hw_ptr;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\r\nruntime->silence_size > 0)\r\nsnd_pcm_playback_silence(substream, ULONG_MAX);\r\n}\r\nstatic int snd_pcm_reset(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_action_nonatomic(&snd_pcm_action_reset, substream, 0);\r\n}\r\nstatic int snd_pcm_pre_prepare(struct snd_pcm_substream *substream,\r\nint f_flags)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN ||\r\nruntime->status->state == SNDRV_PCM_STATE_DISCONNECTED)\r\nreturn -EBADFD;\r\nif (snd_pcm_running(substream))\r\nreturn -EBUSY;\r\nsubstream->f_flags = f_flags;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_prepare(struct snd_pcm_substream *substream, int state)\r\n{\r\nint err;\r\nerr = substream->ops->prepare(substream);\r\nif (err < 0)\r\nreturn err;\r\nreturn snd_pcm_do_reset(substream, 0);\r\n}\r\nstatic void snd_pcm_post_prepare(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->control->appl_ptr = runtime->status->hw_ptr;\r\nsnd_pcm_set_state(substream, SNDRV_PCM_STATE_PREPARED);\r\n}\r\nstatic int snd_pcm_prepare(struct snd_pcm_substream *substream,\r\nstruct file *file)\r\n{\r\nint res;\r\nstruct snd_card *card = substream->pcm->card;\r\nint f_flags;\r\nif (file)\r\nf_flags = file->f_flags;\r\nelse\r\nf_flags = substream->f_flags;\r\nsnd_power_lock(card);\r\nif ((res = snd_power_wait(card, SNDRV_CTL_POWER_D0)) >= 0)\r\nres = snd_pcm_action_nonatomic(&snd_pcm_action_prepare,\r\nsubstream, f_flags);\r\nsnd_power_unlock(card);\r\nreturn res;\r\n}\r\nstatic int snd_pcm_pre_drain_init(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_OPEN:\r\ncase SNDRV_PCM_STATE_DISCONNECTED:\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nreturn -EBADFD;\r\n}\r\nruntime->trigger_master = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_do_drain_init(struct snd_pcm_substream *substream, int state)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\nif (! snd_pcm_playback_empty(substream)) {\r\nsnd_pcm_do_start(substream, SNDRV_PCM_STATE_DRAINING);\r\nsnd_pcm_post_start(substream, SNDRV_PCM_STATE_DRAINING);\r\n} else {\r\nruntime->status->state = SNDRV_PCM_STATE_SETUP;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nruntime->status->state = SNDRV_PCM_STATE_DRAINING;\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nruntime->status->state = SNDRV_PCM_STATE_SETUP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nif (runtime->status->state == SNDRV_PCM_STATE_RUNNING) {\r\nint new_state = snd_pcm_capture_avail(runtime) > 0 ?\r\nSNDRV_PCM_STATE_DRAINING : SNDRV_PCM_STATE_SETUP;\r\nsnd_pcm_do_stop(substream, new_state);\r\nsnd_pcm_post_stop(substream, new_state);\r\n}\r\n}\r\nif (runtime->status->state == SNDRV_PCM_STATE_DRAINING &&\r\nruntime->trigger_master == substream &&\r\n(runtime->hw.info & SNDRV_PCM_INFO_DRAIN_TRIGGER))\r\nreturn substream->ops->trigger(substream,\r\nSNDRV_PCM_TRIGGER_DRAIN);\r\nreturn 0;\r\n}\r\nstatic void snd_pcm_post_drain_init(struct snd_pcm_substream *substream, int state)\r\n{\r\n}\r\nstatic int snd_pcm_drain(struct snd_pcm_substream *substream,\r\nstruct file *file)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_pcm_substream *s;\r\nwait_queue_t wait;\r\nint result = 0;\r\nint nonblock = 0;\r\ncard = substream->pcm->card;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nsnd_power_lock(card);\r\nif (runtime->status->state == SNDRV_PCM_STATE_SUSPENDED) {\r\nresult = snd_power_wait(card, SNDRV_CTL_POWER_D0);\r\nif (result < 0) {\r\nsnd_power_unlock(card);\r\nreturn result;\r\n}\r\n}\r\nif (file) {\r\nif (file->f_flags & O_NONBLOCK)\r\nnonblock = 1;\r\n} else if (substream->f_flags & O_NONBLOCK)\r\nnonblock = 1;\r\ndown_read(&snd_pcm_link_rwsem);\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (runtime->status->state == SNDRV_PCM_STATE_PAUSED)\r\nsnd_pcm_pause(substream, 0);\r\nresult = snd_pcm_action(&snd_pcm_action_drain_init, substream, 0);\r\nif (result < 0)\r\ngoto unlock;\r\nif (nonblock) {\r\nresult = -EAGAIN;\r\ngoto unlock;\r\n}\r\nfor (;;) {\r\nlong tout;\r\nstruct snd_pcm_runtime *to_check;\r\nif (signal_pending(current)) {\r\nresult = -ERESTARTSYS;\r\nbreak;\r\n}\r\nto_check = NULL;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s->stream != SNDRV_PCM_STREAM_PLAYBACK)\r\ncontinue;\r\nruntime = s->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_DRAINING) {\r\nto_check = runtime;\r\nbreak;\r\n}\r\n}\r\nif (!to_check)\r\nbreak;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&to_check->sleep, &wait);\r\nsnd_pcm_stream_unlock_irq(substream);\r\nup_read(&snd_pcm_link_rwsem);\r\nsnd_power_unlock(card);\r\nif (runtime->no_period_wakeup)\r\ntout = MAX_SCHEDULE_TIMEOUT;\r\nelse {\r\ntout = 10;\r\nif (runtime->rate) {\r\nlong t = runtime->period_size * 2 / runtime->rate;\r\ntout = max(t, tout);\r\n}\r\ntout = msecs_to_jiffies(tout * 1000);\r\n}\r\ntout = schedule_timeout_interruptible(tout);\r\nsnd_power_lock(card);\r\ndown_read(&snd_pcm_link_rwsem);\r\nsnd_pcm_stream_lock_irq(substream);\r\nremove_wait_queue(&to_check->sleep, &wait);\r\nif (card->shutdown) {\r\nresult = -ENODEV;\r\nbreak;\r\n}\r\nif (tout == 0) {\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_SUSPENDED)\r\nresult = -ESTRPIPE;\r\nelse {\r\ndev_dbg(substream->pcm->card->dev,\r\n"playback drain error (DMA or IRQ trouble?)\n");\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\r\nresult = -EIO;\r\n}\r\nbreak;\r\n}\r\n}\r\nunlock:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nup_read(&snd_pcm_link_rwsem);\r\nsnd_power_unlock(card);\r\nreturn result;\r\n}\r\nstatic int snd_pcm_drop(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nint result = 0;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN ||\r\nruntime->status->state == SNDRV_PCM_STATE_DISCONNECTED ||\r\nruntime->status->state == SNDRV_PCM_STATE_SUSPENDED)\r\nreturn -EBADFD;\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (runtime->status->state == SNDRV_PCM_STATE_PAUSED)\r\nsnd_pcm_pause(substream, 0);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_SETUP);\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn result;\r\n}\r\nstatic bool is_pcm_file(struct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nunsigned int minor;\r\nif (!S_ISCHR(inode->i_mode) || imajor(inode) != snd_major)\r\nreturn false;\r\nminor = iminor(inode);\r\nreturn snd_lookup_minor_data(minor, SNDRV_DEVICE_TYPE_PCM_PLAYBACK) ||\r\nsnd_lookup_minor_data(minor, SNDRV_DEVICE_TYPE_PCM_CAPTURE);\r\n}\r\nstatic int snd_pcm_link(struct snd_pcm_substream *substream, int fd)\r\n{\r\nint res = 0;\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream1;\r\nstruct snd_pcm_group *group;\r\nstruct fd f = fdget(fd);\r\nif (!f.file)\r\nreturn -EBADFD;\r\nif (!is_pcm_file(f.file)) {\r\nres = -EBADFD;\r\ngoto _badf;\r\n}\r\npcm_file = f.file->private_data;\r\nsubstream1 = pcm_file->substream;\r\ngroup = kmalloc(sizeof(*group), GFP_KERNEL);\r\nif (!group) {\r\nres = -ENOMEM;\r\ngoto _nolock;\r\n}\r\ndown_write(&snd_pcm_link_rwsem);\r\nwrite_lock_irq(&snd_pcm_link_rwlock);\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN ||\r\nsubstream->runtime->status->state != substream1->runtime->status->state ||\r\nsubstream->pcm->nonatomic != substream1->pcm->nonatomic) {\r\nres = -EBADFD;\r\ngoto _end;\r\n}\r\nif (snd_pcm_stream_linked(substream1)) {\r\nres = -EALREADY;\r\ngoto _end;\r\n}\r\nif (!snd_pcm_stream_linked(substream)) {\r\nsubstream->group = group;\r\ngroup = NULL;\r\nspin_lock_init(&substream->group->lock);\r\nmutex_init(&substream->group->mutex);\r\nINIT_LIST_HEAD(&substream->group->substreams);\r\nlist_add_tail(&substream->link_list, &substream->group->substreams);\r\nsubstream->group->count = 1;\r\n}\r\nlist_add_tail(&substream1->link_list, &substream->group->substreams);\r\nsubstream->group->count++;\r\nsubstream1->group = substream->group;\r\n_end:\r\nwrite_unlock_irq(&snd_pcm_link_rwlock);\r\nup_write(&snd_pcm_link_rwsem);\r\n_nolock:\r\nsnd_card_unref(substream1->pcm->card);\r\nkfree(group);\r\n_badf:\r\nfdput(f);\r\nreturn res;\r\n}\r\nstatic void relink_to_local(struct snd_pcm_substream *substream)\r\n{\r\nsubstream->group = &substream->self_group;\r\nINIT_LIST_HEAD(&substream->self_group.substreams);\r\nlist_add_tail(&substream->link_list, &substream->self_group.substreams);\r\n}\r\nstatic int snd_pcm_unlink(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_substream *s;\r\nint res = 0;\r\ndown_write(&snd_pcm_link_rwsem);\r\nwrite_lock_irq(&snd_pcm_link_rwlock);\r\nif (!snd_pcm_stream_linked(substream)) {\r\nres = -EALREADY;\r\ngoto _end;\r\n}\r\nlist_del(&substream->link_list);\r\nsubstream->group->count--;\r\nif (substream->group->count == 1) {\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nrelink_to_local(s);\r\nbreak;\r\n}\r\nkfree(substream->group);\r\n}\r\nrelink_to_local(substream);\r\n_end:\r\nwrite_unlock_irq(&snd_pcm_link_rwlock);\r\nup_write(&snd_pcm_link_rwsem);\r\nreturn res;\r\n}\r\nstatic int snd_pcm_hw_rule_mul(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval t;\r\nsnd_interval_mul(hw_param_interval_c(params, rule->deps[0]),\r\nhw_param_interval_c(params, rule->deps[1]), &t);\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int snd_pcm_hw_rule_div(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval t;\r\nsnd_interval_div(hw_param_interval_c(params, rule->deps[0]),\r\nhw_param_interval_c(params, rule->deps[1]), &t);\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int snd_pcm_hw_rule_muldivk(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval t;\r\nsnd_interval_muldivk(hw_param_interval_c(params, rule->deps[0]),\r\nhw_param_interval_c(params, rule->deps[1]),\r\n(unsigned long) rule->private, &t);\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int snd_pcm_hw_rule_mulkdiv(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval t;\r\nsnd_interval_mulkdiv(hw_param_interval_c(params, rule->deps[0]),\r\n(unsigned long) rule->private,\r\nhw_param_interval_c(params, rule->deps[1]), &t);\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int snd_pcm_hw_rule_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int k;\r\nstruct snd_interval *i = hw_param_interval(params, rule->deps[0]);\r\nstruct snd_mask m;\r\nstruct snd_mask *mask = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nsnd_mask_any(&m);\r\nfor (k = 0; k <= SNDRV_PCM_FORMAT_LAST; ++k) {\r\nint bits;\r\nif (! snd_mask_test(mask, k))\r\ncontinue;\r\nbits = snd_pcm_format_physical_width(k);\r\nif (bits <= 0)\r\ncontinue;\r\nif ((unsigned)bits < i->min || (unsigned)bits > i->max)\r\nsnd_mask_reset(&m, k);\r\n}\r\nreturn snd_mask_refine(mask, &m);\r\n}\r\nstatic int snd_pcm_hw_rule_sample_bits(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval t;\r\nunsigned int k;\r\nt.min = UINT_MAX;\r\nt.max = 0;\r\nt.openmin = 0;\r\nt.openmax = 0;\r\nfor (k = 0; k <= SNDRV_PCM_FORMAT_LAST; ++k) {\r\nint bits;\r\nif (! snd_mask_test(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT), k))\r\ncontinue;\r\nbits = snd_pcm_format_physical_width(k);\r\nif (bits <= 0)\r\ncontinue;\r\nif (t.min > (unsigned)bits)\r\nt.min = bits;\r\nif (t.max < (unsigned)bits)\r\nt.max = bits;\r\n}\r\nt.integer = 1;\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nstatic int snd_pcm_hw_rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_pcm_hardware *hw = rule->private;\r\nreturn snd_interval_list(hw_param_interval(params, rule->var),\r\nsnd_pcm_known_rates.count,\r\nsnd_pcm_known_rates.list, hw->rates);\r\n}\r\nstatic int snd_pcm_hw_rule_buffer_bytes_max(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval t;\r\nstruct snd_pcm_substream *substream = rule->private;\r\nt.min = 0;\r\nt.max = substream->buffer_bytes_max;\r\nt.openmin = 0;\r\nt.openmax = 0;\r\nt.integer = 1;\r\nreturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\r\n}\r\nint snd_pcm_hw_constraints_init(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_hw_constraints *constrs = &runtime->hw_constraints;\r\nint k, err;\r\nfor (k = SNDRV_PCM_HW_PARAM_FIRST_MASK; k <= SNDRV_PCM_HW_PARAM_LAST_MASK; k++) {\r\nsnd_mask_any(constrs_mask(constrs, k));\r\n}\r\nfor (k = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL; k <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; k++) {\r\nsnd_interval_any(constrs_interval(constrs, k));\r\n}\r\nsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_CHANNELS));\r\nsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_BUFFER_SIZE));\r\nsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_BUFFER_BYTES));\r\nsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_SAMPLE_BITS));\r\nsnd_interval_setinteger(constrs_interval(constrs, SNDRV_PCM_HW_PARAM_FRAME_BITS));\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\r\nsnd_pcm_hw_rule_format, NULL,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nsnd_pcm_hw_rule_sample_bits, NULL,\r\nSNDRV_PCM_HW_PARAM_FORMAT,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nsnd_pcm_hw_rule_div, NULL,\r\nSNDRV_PCM_HW_PARAM_FRAME_BITS, SNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FRAME_BITS,\r\nsnd_pcm_hw_rule_mul, NULL,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS, SNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FRAME_BITS,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 8,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FRAME_BITS,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 8,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_pcm_hw_rule_div, NULL,\r\nSNDRV_PCM_HW_PARAM_FRAME_BITS, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 1000000,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_PERIOD_TIME, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 1000000,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_BUFFER_TIME, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIODS,\r\nsnd_pcm_hw_rule_div, NULL,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\nsnd_pcm_hw_rule_div, NULL,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_PERIODS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 8,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\nsnd_pcm_hw_rule_muldivk, (void*) 1000000,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME, SNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\nsnd_pcm_hw_rule_mul, NULL,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_PERIODS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 8,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\nsnd_pcm_hw_rule_muldivk, (void*) 1000000,\r\nSNDRV_PCM_HW_PARAM_BUFFER_TIME, SNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nsnd_pcm_hw_rule_muldivk, (void*) 8,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nsnd_pcm_hw_rule_muldivk, (void*) 8,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 1000000,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE, SNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_TIME,\r\nsnd_pcm_hw_rule_mulkdiv, (void*) 1000000,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, SNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_hardware *hw = &runtime->hw;\r\nint err;\r\nunsigned int mask = 0;\r\nif (hw->info & SNDRV_PCM_INFO_INTERLEAVED)\r\nmask |= 1 << SNDRV_PCM_ACCESS_RW_INTERLEAVED;\r\nif (hw->info & SNDRV_PCM_INFO_NONINTERLEAVED)\r\nmask |= 1 << SNDRV_PCM_ACCESS_RW_NONINTERLEAVED;\r\nif (hw_support_mmap(substream)) {\r\nif (hw->info & SNDRV_PCM_INFO_INTERLEAVED)\r\nmask |= 1 << SNDRV_PCM_ACCESS_MMAP_INTERLEAVED;\r\nif (hw->info & SNDRV_PCM_INFO_NONINTERLEAVED)\r\nmask |= 1 << SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED;\r\nif (hw->info & SNDRV_PCM_INFO_COMPLEX)\r\nmask |= 1 << SNDRV_PCM_ACCESS_MMAP_COMPLEX;\r\n}\r\nerr = snd_pcm_hw_constraint_mask(runtime, SNDRV_PCM_HW_PARAM_ACCESS, mask);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_mask64(runtime, SNDRV_PCM_HW_PARAM_FORMAT, hw->formats);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_mask(runtime, SNDRV_PCM_HW_PARAM_SUBFORMAT, 1 << SNDRV_PCM_SUBFORMAT_STD);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw->channels_min, hw->channels_max);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_RATE,\r\nhw->rate_min, hw->rate_max);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nhw->period_bytes_min, hw->period_bytes_max);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIODS,\r\nhw->periods_min, hw->periods_max);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nhw->period_bytes_min, hw->buffer_bytes_max);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nsnd_pcm_hw_rule_buffer_bytes_max, substream,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, -1);\r\nif (err < 0)\r\nreturn err;\r\nif (runtime->dma_bytes) {\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 0, runtime->dma_bytes);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!(hw->rates & (SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_CONTINUOUS))) {\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_pcm_hw_rule_rate, hw,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn 0;\r\n}\r\nstatic void pcm_release_private(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_unlink(substream);\r\n}\r\nvoid snd_pcm_release_substream(struct snd_pcm_substream *substream)\r\n{\r\nsubstream->ref_count--;\r\nif (substream->ref_count > 0)\r\nreturn;\r\nsnd_pcm_drop(substream);\r\nif (substream->hw_opened) {\r\nif (substream->ops->hw_free != NULL)\r\nsubstream->ops->hw_free(substream);\r\nsubstream->ops->close(substream);\r\nsubstream->hw_opened = 0;\r\n}\r\nif (pm_qos_request_active(&substream->latency_pm_qos_req))\r\npm_qos_remove_request(&substream->latency_pm_qos_req);\r\nif (substream->pcm_release) {\r\nsubstream->pcm_release(substream);\r\nsubstream->pcm_release = NULL;\r\n}\r\nsnd_pcm_detach_substream(substream);\r\n}\r\nint snd_pcm_open_substream(struct snd_pcm *pcm, int stream,\r\nstruct file *file,\r\nstruct snd_pcm_substream **rsubstream)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nerr = snd_pcm_attach_substream(pcm, stream, file, &substream);\r\nif (err < 0)\r\nreturn err;\r\nif (substream->ref_count > 1) {\r\n*rsubstream = substream;\r\nreturn 0;\r\n}\r\nerr = snd_pcm_hw_constraints_init(substream);\r\nif (err < 0) {\r\npcm_dbg(pcm, "snd_pcm_hw_constraints_init failed\n");\r\ngoto error;\r\n}\r\nif ((err = substream->ops->open(substream)) < 0)\r\ngoto error;\r\nsubstream->hw_opened = 1;\r\nerr = snd_pcm_hw_constraints_complete(substream);\r\nif (err < 0) {\r\npcm_dbg(pcm, "snd_pcm_hw_constraints_complete failed\n");\r\ngoto error;\r\n}\r\n*rsubstream = substream;\r\nreturn 0;\r\nerror:\r\nsnd_pcm_release_substream(substream);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_open_file(struct file *file,\r\nstruct snd_pcm *pcm,\r\nint stream)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nint err;\r\nerr = snd_pcm_open_substream(pcm, stream, file, &substream);\r\nif (err < 0)\r\nreturn err;\r\npcm_file = kzalloc(sizeof(*pcm_file), GFP_KERNEL);\r\nif (pcm_file == NULL) {\r\nsnd_pcm_release_substream(substream);\r\nreturn -ENOMEM;\r\n}\r\npcm_file->substream = substream;\r\nif (substream->ref_count == 1) {\r\nsubstream->file = pcm_file;\r\nsubstream->pcm_release = pcm_release_private;\r\n}\r\nfile->private_data = pcm_file;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_playback_open(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err = nonseekable_open(inode, file);\r\nif (err < 0)\r\nreturn err;\r\npcm = snd_lookup_minor_data(iminor(inode),\r\nSNDRV_DEVICE_TYPE_PCM_PLAYBACK);\r\nerr = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);\r\nif (pcm)\r\nsnd_card_unref(pcm->card);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_capture_open(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err = nonseekable_open(inode, file);\r\nif (err < 0)\r\nreturn err;\r\npcm = snd_lookup_minor_data(iminor(inode),\r\nSNDRV_DEVICE_TYPE_PCM_CAPTURE);\r\nerr = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_CAPTURE);\r\nif (pcm)\r\nsnd_card_unref(pcm->card);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_open(struct file *file, struct snd_pcm *pcm, int stream)\r\n{\r\nint err;\r\nwait_queue_t wait;\r\nif (pcm == NULL) {\r\nerr = -ENODEV;\r\ngoto __error1;\r\n}\r\nerr = snd_card_file_add(pcm->card, file);\r\nif (err < 0)\r\ngoto __error1;\r\nif (!try_module_get(pcm->card->module)) {\r\nerr = -EFAULT;\r\ngoto __error2;\r\n}\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&pcm->open_wait, &wait);\r\nmutex_lock(&pcm->open_mutex);\r\nwhile (1) {\r\nerr = snd_pcm_open_file(file, pcm, stream);\r\nif (err >= 0)\r\nbreak;\r\nif (err == -EAGAIN) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nerr = -EBUSY;\r\nbreak;\r\n}\r\n} else\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nmutex_unlock(&pcm->open_mutex);\r\nschedule();\r\nmutex_lock(&pcm->open_mutex);\r\nif (pcm->card->shutdown) {\r\nerr = -ENODEV;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nerr = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nremove_wait_queue(&pcm->open_wait, &wait);\r\nmutex_unlock(&pcm->open_mutex);\r\nif (err < 0)\r\ngoto __error;\r\nreturn err;\r\n__error:\r\nmodule_put(pcm->card->module);\r\n__error2:\r\nsnd_card_file_remove(pcm->card, file);\r\n__error1:\r\nreturn err;\r\n}\r\nstatic int snd_pcm_release(struct inode *inode, struct file *file)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_file *pcm_file;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (snd_BUG_ON(!substream))\r\nreturn -ENXIO;\r\npcm = substream->pcm;\r\nmutex_lock(&pcm->open_mutex);\r\nsnd_pcm_release_substream(substream);\r\nkfree(pcm_file);\r\nmutex_unlock(&pcm->open_mutex);\r\nwake_up(&pcm->open_wait);\r\nmodule_put(pcm->card->module);\r\nsnd_card_file_remove(pcm->card, file);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_sframes_t snd_pcm_playback_rewind(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t appl_ptr;\r\nsnd_pcm_sframes_t ret;\r\nsnd_pcm_sframes_t hw_avail;\r\nif (frames == 0)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\nbreak;\r\ncase SNDRV_PCM_STATE_DRAINING:\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nif (snd_pcm_update_hw_ptr(substream) >= 0)\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nret = -EPIPE;\r\ngoto __end;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nret = -ESTRPIPE;\r\ngoto __end;\r\ndefault:\r\nret = -EBADFD;\r\ngoto __end;\r\n}\r\nhw_avail = snd_pcm_playback_hw_avail(runtime);\r\nif (hw_avail <= 0) {\r\nret = 0;\r\ngoto __end;\r\n}\r\nif (frames > (snd_pcm_uframes_t)hw_avail)\r\nframes = hw_avail;\r\nappl_ptr = runtime->control->appl_ptr - frames;\r\nif (appl_ptr < 0)\r\nappl_ptr += runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\nret = frames;\r\n__end:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_sframes_t snd_pcm_capture_rewind(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t appl_ptr;\r\nsnd_pcm_sframes_t ret;\r\nsnd_pcm_sframes_t hw_avail;\r\nif (frames == 0)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nbreak;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nif (snd_pcm_update_hw_ptr(substream) >= 0)\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nret = -EPIPE;\r\ngoto __end;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nret = -ESTRPIPE;\r\ngoto __end;\r\ndefault:\r\nret = -EBADFD;\r\ngoto __end;\r\n}\r\nhw_avail = snd_pcm_capture_hw_avail(runtime);\r\nif (hw_avail <= 0) {\r\nret = 0;\r\ngoto __end;\r\n}\r\nif (frames > (snd_pcm_uframes_t)hw_avail)\r\nframes = hw_avail;\r\nappl_ptr = runtime->control->appl_ptr - frames;\r\nif (appl_ptr < 0)\r\nappl_ptr += runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\nret = frames;\r\n__end:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_sframes_t snd_pcm_playback_forward(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t appl_ptr;\r\nsnd_pcm_sframes_t ret;\r\nsnd_pcm_sframes_t avail;\r\nif (frames == 0)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nbreak;\r\ncase SNDRV_PCM_STATE_DRAINING:\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nif (snd_pcm_update_hw_ptr(substream) >= 0)\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nret = -EPIPE;\r\ngoto __end;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nret = -ESTRPIPE;\r\ngoto __end;\r\ndefault:\r\nret = -EBADFD;\r\ngoto __end;\r\n}\r\navail = snd_pcm_playback_avail(runtime);\r\nif (avail <= 0) {\r\nret = 0;\r\ngoto __end;\r\n}\r\nif (frames > (snd_pcm_uframes_t)avail)\r\nframes = avail;\r\nappl_ptr = runtime->control->appl_ptr + frames;\r\nif (appl_ptr >= (snd_pcm_sframes_t)runtime->boundary)\r\nappl_ptr -= runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\nret = frames;\r\n__end:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn ret;\r\n}\r\nstatic snd_pcm_sframes_t snd_pcm_capture_forward(struct snd_pcm_substream *substream,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t appl_ptr;\r\nsnd_pcm_sframes_t ret;\r\nsnd_pcm_sframes_t avail;\r\nif (frames == 0)\r\nreturn 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_DRAINING:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nbreak;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nif (snd_pcm_update_hw_ptr(substream) >= 0)\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nret = -EPIPE;\r\ngoto __end;\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nret = -ESTRPIPE;\r\ngoto __end;\r\ndefault:\r\nret = -EBADFD;\r\ngoto __end;\r\n}\r\navail = snd_pcm_capture_avail(runtime);\r\nif (avail <= 0) {\r\nret = 0;\r\ngoto __end;\r\n}\r\nif (frames > (snd_pcm_uframes_t)avail)\r\nframes = avail;\r\nappl_ptr = runtime->control->appl_ptr + frames;\r\nif (appl_ptr >= (snd_pcm_sframes_t)runtime->boundary)\r\nappl_ptr -= runtime->boundary;\r\nruntime->control->appl_ptr = appl_ptr;\r\nret = frames;\r\n__end:\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn ret;\r\n}\r\nstatic int snd_pcm_hwsync(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ngoto __badfd;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nif ((err = snd_pcm_update_hw_ptr(substream)) < 0)\r\nbreak;\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = 0;\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\nbreak;\r\ndefault:\r\n__badfd:\r\nerr = -EBADFD;\r\nbreak;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_delay(struct snd_pcm_substream *substream,\r\nsnd_pcm_sframes_t __user *res)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nsnd_pcm_sframes_t n = 0;\r\nsnd_pcm_stream_lock_irq(substream);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ngoto __badfd;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\nif ((err = snd_pcm_update_hw_ptr(substream)) < 0)\r\nbreak;\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_SUSPENDED:\r\nerr = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nn = snd_pcm_playback_hw_avail(runtime);\r\nelse\r\nn = snd_pcm_capture_avail(runtime);\r\nn += runtime->delay;\r\nbreak;\r\ncase SNDRV_PCM_STATE_XRUN:\r\nerr = -EPIPE;\r\nbreak;\r\ndefault:\r\n__badfd:\r\nerr = -EBADFD;\r\nbreak;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (!err)\r\nif (put_user(n, res))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int snd_pcm_sync_ptr(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_sync_ptr __user *_sync_ptr)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_pcm_sync_ptr sync_ptr;\r\nvolatile struct snd_pcm_mmap_status *status;\r\nvolatile struct snd_pcm_mmap_control *control;\r\nint err;\r\nmemset(&sync_ptr, 0, sizeof(sync_ptr));\r\nif (get_user(sync_ptr.flags, (unsigned __user *)&(_sync_ptr->flags)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&sync_ptr.c.control, &(_sync_ptr->c.control), sizeof(struct snd_pcm_mmap_control)))\r\nreturn -EFAULT;\r\nstatus = runtime->status;\r\ncontrol = runtime->control;\r\nif (sync_ptr.flags & SNDRV_PCM_SYNC_PTR_HWSYNC) {\r\nerr = snd_pcm_hwsync(substream);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_APPL))\r\ncontrol->appl_ptr = sync_ptr.c.control.appl_ptr;\r\nelse\r\nsync_ptr.c.control.appl_ptr = control->appl_ptr;\r\nif (!(sync_ptr.flags & SNDRV_PCM_SYNC_PTR_AVAIL_MIN))\r\ncontrol->avail_min = sync_ptr.c.control.avail_min;\r\nelse\r\nsync_ptr.c.control.avail_min = control->avail_min;\r\nsync_ptr.s.status.state = status->state;\r\nsync_ptr.s.status.hw_ptr = status->hw_ptr;\r\nsync_ptr.s.status.tstamp = status->tstamp;\r\nsync_ptr.s.status.suspended_state = status->suspended_state;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (copy_to_user(_sync_ptr, &sync_ptr, sizeof(sync_ptr)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_tstamp(struct snd_pcm_substream *substream, int __user *_arg)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint arg;\r\nif (get_user(arg, _arg))\r\nreturn -EFAULT;\r\nif (arg < 0 || arg > SNDRV_PCM_TSTAMP_TYPE_LAST)\r\nreturn -EINVAL;\r\nruntime->tstamp_type = arg;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_common_ioctl1(struct file *file,\r\nstruct snd_pcm_substream *substream,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL_PVERSION:\r\nreturn put_user(SNDRV_PCM_VERSION, (int __user *)arg) ? -EFAULT : 0;\r\ncase SNDRV_PCM_IOCTL_INFO:\r\nreturn snd_pcm_info_user(substream, arg);\r\ncase SNDRV_PCM_IOCTL_TSTAMP:\r\nreturn 0;\r\ncase SNDRV_PCM_IOCTL_TTSTAMP:\r\nreturn snd_pcm_tstamp(substream, arg);\r\ncase SNDRV_PCM_IOCTL_HW_REFINE:\r\nreturn snd_pcm_hw_refine_user(substream, arg);\r\ncase SNDRV_PCM_IOCTL_HW_PARAMS:\r\nreturn snd_pcm_hw_params_user(substream, arg);\r\ncase SNDRV_PCM_IOCTL_HW_FREE:\r\nreturn snd_pcm_hw_free(substream);\r\ncase SNDRV_PCM_IOCTL_SW_PARAMS:\r\nreturn snd_pcm_sw_params_user(substream, arg);\r\ncase SNDRV_PCM_IOCTL_STATUS:\r\nreturn snd_pcm_status_user(substream, arg, false);\r\ncase SNDRV_PCM_IOCTL_STATUS_EXT:\r\nreturn snd_pcm_status_user(substream, arg, true);\r\ncase SNDRV_PCM_IOCTL_CHANNEL_INFO:\r\nreturn snd_pcm_channel_info_user(substream, arg);\r\ncase SNDRV_PCM_IOCTL_PREPARE:\r\nreturn snd_pcm_prepare(substream, file);\r\ncase SNDRV_PCM_IOCTL_RESET:\r\nreturn snd_pcm_reset(substream);\r\ncase SNDRV_PCM_IOCTL_START:\r\nreturn snd_pcm_action_lock_irq(&snd_pcm_action_start, substream, SNDRV_PCM_STATE_RUNNING);\r\ncase SNDRV_PCM_IOCTL_LINK:\r\nreturn snd_pcm_link(substream, (int)(unsigned long) arg);\r\ncase SNDRV_PCM_IOCTL_UNLINK:\r\nreturn snd_pcm_unlink(substream);\r\ncase SNDRV_PCM_IOCTL_RESUME:\r\nreturn snd_pcm_resume(substream);\r\ncase SNDRV_PCM_IOCTL_XRUN:\r\nreturn snd_pcm_xrun(substream);\r\ncase SNDRV_PCM_IOCTL_HWSYNC:\r\nreturn snd_pcm_hwsync(substream);\r\ncase SNDRV_PCM_IOCTL_DELAY:\r\nreturn snd_pcm_delay(substream, arg);\r\ncase SNDRV_PCM_IOCTL_SYNC_PTR:\r\nreturn snd_pcm_sync_ptr(substream, arg);\r\n#ifdef CONFIG_SND_SUPPORT_OLD_API\r\ncase SNDRV_PCM_IOCTL_HW_REFINE_OLD:\r\nreturn snd_pcm_hw_refine_old_user(substream, arg);\r\ncase SNDRV_PCM_IOCTL_HW_PARAMS_OLD:\r\nreturn snd_pcm_hw_params_old_user(substream, arg);\r\n#endif\r\ncase SNDRV_PCM_IOCTL_DRAIN:\r\nreturn snd_pcm_drain(substream, file);\r\ncase SNDRV_PCM_IOCTL_DROP:\r\nreturn snd_pcm_drop(substream);\r\ncase SNDRV_PCM_IOCTL_PAUSE:\r\n{\r\nint res;\r\nsnd_pcm_stream_lock_irq(substream);\r\nres = snd_pcm_pause(substream, (int)(unsigned long)arg);\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn res;\r\n}\r\n}\r\npcm_dbg(substream->pcm, "unknown ioctl = 0x%x\n", cmd);\r\nreturn -ENOTTY;\r\n}\r\nstatic int snd_pcm_playback_ioctl1(struct file *file,\r\nstruct snd_pcm_substream *substream,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nif (snd_BUG_ON(!substream))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(substream->stream != SNDRV_PCM_STREAM_PLAYBACK))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL_WRITEI_FRAMES:\r\n{\r\nstruct snd_xferi xferi;\r\nstruct snd_xferi __user *_xferi = arg;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t result;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (put_user(0, &_xferi->result))\r\nreturn -EFAULT;\r\nif (copy_from_user(&xferi, _xferi, sizeof(xferi)))\r\nreturn -EFAULT;\r\nresult = snd_pcm_lib_write(substream, xferi.buf, xferi.frames);\r\n__put_user(result, &_xferi->result);\r\nreturn result < 0 ? result : 0;\r\n}\r\ncase SNDRV_PCM_IOCTL_WRITEN_FRAMES:\r\n{\r\nstruct snd_xfern xfern;\r\nstruct snd_xfern __user *_xfern = arg;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvoid __user **bufs;\r\nsnd_pcm_sframes_t result;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (runtime->channels > 128)\r\nreturn -EINVAL;\r\nif (put_user(0, &_xfern->result))\r\nreturn -EFAULT;\r\nif (copy_from_user(&xfern, _xfern, sizeof(xfern)))\r\nreturn -EFAULT;\r\nbufs = memdup_user(xfern.bufs,\r\nsizeof(void *) * runtime->channels);\r\nif (IS_ERR(bufs))\r\nreturn PTR_ERR(bufs);\r\nresult = snd_pcm_lib_writev(substream, bufs, xfern.frames);\r\nkfree(bufs);\r\n__put_user(result, &_xfern->result);\r\nreturn result < 0 ? result : 0;\r\n}\r\ncase SNDRV_PCM_IOCTL_REWIND:\r\n{\r\nsnd_pcm_uframes_t frames;\r\nsnd_pcm_uframes_t __user *_frames = arg;\r\nsnd_pcm_sframes_t result;\r\nif (get_user(frames, _frames))\r\nreturn -EFAULT;\r\nif (put_user(0, _frames))\r\nreturn -EFAULT;\r\nresult = snd_pcm_playback_rewind(substream, frames);\r\n__put_user(result, _frames);\r\nreturn result < 0 ? result : 0;\r\n}\r\ncase SNDRV_PCM_IOCTL_FORWARD:\r\n{\r\nsnd_pcm_uframes_t frames;\r\nsnd_pcm_uframes_t __user *_frames = arg;\r\nsnd_pcm_sframes_t result;\r\nif (get_user(frames, _frames))\r\nreturn -EFAULT;\r\nif (put_user(0, _frames))\r\nreturn -EFAULT;\r\nresult = snd_pcm_playback_forward(substream, frames);\r\n__put_user(result, _frames);\r\nreturn result < 0 ? result : 0;\r\n}\r\n}\r\nreturn snd_pcm_common_ioctl1(file, substream, cmd, arg);\r\n}\r\nstatic int snd_pcm_capture_ioctl1(struct file *file,\r\nstruct snd_pcm_substream *substream,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nif (snd_BUG_ON(!substream))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(substream->stream != SNDRV_PCM_STREAM_CAPTURE))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL_READI_FRAMES:\r\n{\r\nstruct snd_xferi xferi;\r\nstruct snd_xferi __user *_xferi = arg;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_sframes_t result;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (put_user(0, &_xferi->result))\r\nreturn -EFAULT;\r\nif (copy_from_user(&xferi, _xferi, sizeof(xferi)))\r\nreturn -EFAULT;\r\nresult = snd_pcm_lib_read(substream, xferi.buf, xferi.frames);\r\n__put_user(result, &_xferi->result);\r\nreturn result < 0 ? result : 0;\r\n}\r\ncase SNDRV_PCM_IOCTL_READN_FRAMES:\r\n{\r\nstruct snd_xfern xfern;\r\nstruct snd_xfern __user *_xfern = arg;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvoid *bufs;\r\nsnd_pcm_sframes_t result;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (runtime->channels > 128)\r\nreturn -EINVAL;\r\nif (put_user(0, &_xfern->result))\r\nreturn -EFAULT;\r\nif (copy_from_user(&xfern, _xfern, sizeof(xfern)))\r\nreturn -EFAULT;\r\nbufs = memdup_user(xfern.bufs,\r\nsizeof(void *) * runtime->channels);\r\nif (IS_ERR(bufs))\r\nreturn PTR_ERR(bufs);\r\nresult = snd_pcm_lib_readv(substream, bufs, xfern.frames);\r\nkfree(bufs);\r\n__put_user(result, &_xfern->result);\r\nreturn result < 0 ? result : 0;\r\n}\r\ncase SNDRV_PCM_IOCTL_REWIND:\r\n{\r\nsnd_pcm_uframes_t frames;\r\nsnd_pcm_uframes_t __user *_frames = arg;\r\nsnd_pcm_sframes_t result;\r\nif (get_user(frames, _frames))\r\nreturn -EFAULT;\r\nif (put_user(0, _frames))\r\nreturn -EFAULT;\r\nresult = snd_pcm_capture_rewind(substream, frames);\r\n__put_user(result, _frames);\r\nreturn result < 0 ? result : 0;\r\n}\r\ncase SNDRV_PCM_IOCTL_FORWARD:\r\n{\r\nsnd_pcm_uframes_t frames;\r\nsnd_pcm_uframes_t __user *_frames = arg;\r\nsnd_pcm_sframes_t result;\r\nif (get_user(frames, _frames))\r\nreturn -EFAULT;\r\nif (put_user(0, _frames))\r\nreturn -EFAULT;\r\nresult = snd_pcm_capture_forward(substream, frames);\r\n__put_user(result, _frames);\r\nreturn result < 0 ? result : 0;\r\n}\r\n}\r\nreturn snd_pcm_common_ioctl1(file, substream, cmd, arg);\r\n}\r\nstatic long snd_pcm_playback_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\npcm_file = file->private_data;\r\nif (((cmd >> 8) & 0xff) != 'A')\r\nreturn -ENOTTY;\r\nreturn snd_pcm_playback_ioctl1(file, pcm_file->substream, cmd,\r\n(void __user *)arg);\r\n}\r\nstatic long snd_pcm_capture_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\npcm_file = file->private_data;\r\nif (((cmd >> 8) & 0xff) != 'A')\r\nreturn -ENOTTY;\r\nreturn snd_pcm_capture_ioctl1(file, pcm_file->substream, cmd,\r\n(void __user *)arg);\r\n}\r\nint snd_pcm_kernel_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nmm_segment_t fs;\r\nint result;\r\nfs = snd_enter_user();\r\nswitch (substream->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nresult = snd_pcm_playback_ioctl1(NULL, substream, cmd,\r\n(void __user *)arg);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nresult = snd_pcm_capture_ioctl1(NULL, substream, cmd,\r\n(void __user *)arg);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nsnd_leave_user(fs);\r\nreturn result;\r\n}\r\nstatic ssize_t snd_pcm_read(struct file *file, char __user *buf, size_t count,\r\nloff_t * offset)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t result;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (!frame_aligned(runtime, count))\r\nreturn -EINVAL;\r\ncount = bytes_to_frames(runtime, count);\r\nresult = snd_pcm_lib_read(substream, buf, count);\r\nif (result > 0)\r\nresult = frames_to_bytes(runtime, result);\r\nreturn result;\r\n}\r\nstatic ssize_t snd_pcm_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t * offset)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t result;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (!frame_aligned(runtime, count))\r\nreturn -EINVAL;\r\ncount = bytes_to_frames(runtime, count);\r\nresult = snd_pcm_lib_write(substream, buf, count);\r\nif (result > 0)\r\nresult = frames_to_bytes(runtime, result);\r\nreturn result;\r\n}\r\nstatic ssize_t snd_pcm_readv(struct kiocb *iocb, struct iov_iter *to)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t result;\r\nunsigned long i;\r\nvoid __user **bufs;\r\nsnd_pcm_uframes_t frames;\r\npcm_file = iocb->ki_filp->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (!iter_is_iovec(to))\r\nreturn -EINVAL;\r\nif (to->nr_segs > 1024 || to->nr_segs != runtime->channels)\r\nreturn -EINVAL;\r\nif (!frame_aligned(runtime, to->iov->iov_len))\r\nreturn -EINVAL;\r\nframes = bytes_to_samples(runtime, to->iov->iov_len);\r\nbufs = kmalloc(sizeof(void *) * to->nr_segs, GFP_KERNEL);\r\nif (bufs == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < to->nr_segs; ++i)\r\nbufs[i] = to->iov[i].iov_base;\r\nresult = snd_pcm_lib_readv(substream, bufs, frames);\r\nif (result > 0)\r\nresult = frames_to_bytes(runtime, result);\r\nkfree(bufs);\r\nreturn result;\r\n}\r\nstatic ssize_t snd_pcm_writev(struct kiocb *iocb, struct iov_iter *from)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nsnd_pcm_sframes_t result;\r\nunsigned long i;\r\nvoid __user **bufs;\r\nsnd_pcm_uframes_t frames;\r\npcm_file = iocb->ki_filp->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (!iter_is_iovec(from))\r\nreturn -EINVAL;\r\nif (from->nr_segs > 128 || from->nr_segs != runtime->channels ||\r\n!frame_aligned(runtime, from->iov->iov_len))\r\nreturn -EINVAL;\r\nframes = bytes_to_samples(runtime, from->iov->iov_len);\r\nbufs = kmalloc(sizeof(void *) * from->nr_segs, GFP_KERNEL);\r\nif (bufs == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < from->nr_segs; ++i)\r\nbufs[i] = from->iov[i].iov_base;\r\nresult = snd_pcm_lib_writev(substream, bufs, frames);\r\nif (result > 0)\r\nresult = frames_to_bytes(runtime, result);\r\nkfree(bufs);\r\nreturn result;\r\n}\r\nstatic unsigned int snd_pcm_playback_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int mask;\r\nsnd_pcm_uframes_t avail;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\npoll_wait(file, &runtime->sleep, wait);\r\nsnd_pcm_stream_lock_irq(substream);\r\navail = snd_pcm_playback_avail(runtime);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_RUNNING:\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nif (avail >= runtime->control->avail_min) {\r\nmask = POLLOUT | POLLWRNORM;\r\nbreak;\r\n}\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nmask = 0;\r\nbreak;\r\ndefault:\r\nmask = POLLOUT | POLLWRNORM | POLLERR;\r\nbreak;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn mask;\r\n}\r\nstatic unsigned int snd_pcm_capture_poll(struct file *file, poll_table * wait)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int mask;\r\nsnd_pcm_uframes_t avail;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\npoll_wait(file, &runtime->sleep, wait);\r\nsnd_pcm_stream_lock_irq(substream);\r\navail = snd_pcm_capture_avail(runtime);\r\nswitch (runtime->status->state) {\r\ncase SNDRV_PCM_STATE_RUNNING:\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nif (avail >= runtime->control->avail_min) {\r\nmask = POLLIN | POLLRDNORM;\r\nbreak;\r\n}\r\nmask = 0;\r\nbreak;\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nif (avail > 0) {\r\nmask = POLLIN | POLLRDNORM;\r\nbreak;\r\n}\r\ndefault:\r\nmask = POLLIN | POLLRDNORM | POLLERR;\r\nbreak;\r\n}\r\nsnd_pcm_stream_unlock_irq(substream);\r\nreturn mask;\r\n}\r\nstatic int snd_pcm_mmap_status_fault(struct vm_area_struct *area,\r\nstruct vm_fault *vmf)\r\n{\r\nstruct snd_pcm_substream *substream = area->vm_private_data;\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\nreturn VM_FAULT_SIGBUS;\r\nruntime = substream->runtime;\r\nvmf->page = virt_to_page(runtime->status);\r\nget_page(vmf->page);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_mmap_status(struct snd_pcm_substream *substream, struct file *file,\r\nstruct vm_area_struct *area)\r\n{\r\nlong size;\r\nif (!(area->vm_flags & VM_READ))\r\nreturn -EINVAL;\r\nsize = area->vm_end - area->vm_start;\r\nif (size != PAGE_ALIGN(sizeof(struct snd_pcm_mmap_status)))\r\nreturn -EINVAL;\r\narea->vm_ops = &snd_pcm_vm_ops_status;\r\narea->vm_private_data = substream;\r\narea->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_mmap_control_fault(struct vm_area_struct *area,\r\nstruct vm_fault *vmf)\r\n{\r\nstruct snd_pcm_substream *substream = area->vm_private_data;\r\nstruct snd_pcm_runtime *runtime;\r\nif (substream == NULL)\r\nreturn VM_FAULT_SIGBUS;\r\nruntime = substream->runtime;\r\nvmf->page = virt_to_page(runtime->control);\r\nget_page(vmf->page);\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_mmap_control(struct snd_pcm_substream *substream, struct file *file,\r\nstruct vm_area_struct *area)\r\n{\r\nlong size;\r\nif (!(area->vm_flags & VM_READ))\r\nreturn -EINVAL;\r\nsize = area->vm_end - area->vm_start;\r\nif (size != PAGE_ALIGN(sizeof(struct snd_pcm_mmap_control)))\r\nreturn -EINVAL;\r\narea->vm_ops = &snd_pcm_vm_ops_control;\r\narea->vm_private_data = substream;\r\narea->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_mmap_status(struct snd_pcm_substream *substream, struct file *file,\r\nstruct vm_area_struct *area)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic int snd_pcm_mmap_control(struct snd_pcm_substream *substream, struct file *file,\r\nstruct vm_area_struct *area)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic inline struct page *\r\nsnd_pcm_default_page_ops(struct snd_pcm_substream *substream, unsigned long ofs)\r\n{\r\nvoid *vaddr = substream->runtime->dma_area + ofs;\r\nreturn virt_to_page(vaddr);\r\n}\r\nstatic int snd_pcm_mmap_data_fault(struct vm_area_struct *area,\r\nstruct vm_fault *vmf)\r\n{\r\nstruct snd_pcm_substream *substream = area->vm_private_data;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned long offset;\r\nstruct page * page;\r\nsize_t dma_bytes;\r\nif (substream == NULL)\r\nreturn VM_FAULT_SIGBUS;\r\nruntime = substream->runtime;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\ndma_bytes = PAGE_ALIGN(runtime->dma_bytes);\r\nif (offset > dma_bytes - PAGE_SIZE)\r\nreturn VM_FAULT_SIGBUS;\r\nif (substream->ops->page)\r\npage = substream->ops->page(substream, offset);\r\nelse\r\npage = snd_pcm_default_page_ops(substream, offset);\r\nif (!page)\r\nreturn VM_FAULT_SIGBUS;\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nint snd_pcm_lib_default_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *area)\r\n{\r\narea->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\n#ifdef CONFIG_GENERIC_ALLOCATOR\r\nif (substream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV_IRAM) {\r\narea->vm_page_prot = pgprot_writecombine(area->vm_page_prot);\r\nreturn remap_pfn_range(area, area->vm_start,\r\nsubstream->dma_buffer.addr >> PAGE_SHIFT,\r\narea->vm_end - area->vm_start, area->vm_page_prot);\r\n}\r\n#endif\r\n#ifndef CONFIG_X86\r\nif (!substream->ops->page &&\r\nsubstream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV)\r\nreturn dma_mmap_coherent(substream->dma_buffer.dev.dev,\r\narea,\r\nsubstream->runtime->dma_area,\r\nsubstream->runtime->dma_addr,\r\narea->vm_end - area->vm_start);\r\n#endif\r\narea->vm_ops = &snd_pcm_vm_ops_data_fault;\r\nreturn 0;\r\n}\r\nint snd_pcm_lib_mmap_iomem(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *area)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;;\r\narea->vm_page_prot = pgprot_noncached(area->vm_page_prot);\r\nreturn vm_iomap_memory(area, runtime->dma_addr, runtime->dma_bytes);\r\n}\r\nint snd_pcm_mmap_data(struct snd_pcm_substream *substream, struct file *file,\r\nstruct vm_area_struct *area)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nlong size;\r\nunsigned long offset;\r\nsize_t dma_bytes;\r\nint err;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (!(area->vm_flags & (VM_WRITE|VM_READ)))\r\nreturn -EINVAL;\r\n} else {\r\nif (!(area->vm_flags & VM_READ))\r\nreturn -EINVAL;\r\n}\r\nruntime = substream->runtime;\r\nif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (!(runtime->info & SNDRV_PCM_INFO_MMAP))\r\nreturn -ENXIO;\r\nif (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\r\nruntime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\r\nreturn -EINVAL;\r\nsize = area->vm_end - area->vm_start;\r\noffset = area->vm_pgoff << PAGE_SHIFT;\r\ndma_bytes = PAGE_ALIGN(runtime->dma_bytes);\r\nif ((size_t)size > dma_bytes)\r\nreturn -EINVAL;\r\nif (offset > dma_bytes - size)\r\nreturn -EINVAL;\r\narea->vm_ops = &snd_pcm_vm_ops_data;\r\narea->vm_private_data = substream;\r\nif (substream->ops->mmap)\r\nerr = substream->ops->mmap(substream, area);\r\nelse\r\nerr = snd_pcm_lib_default_mmap(substream, area);\r\nif (!err)\r\natomic_inc(&substream->mmap_count);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_mmap(struct file *file, struct vm_area_struct *area)\r\n{\r\nstruct snd_pcm_file * pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nunsigned long offset;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\noffset = area->vm_pgoff << PAGE_SHIFT;\r\nswitch (offset) {\r\ncase SNDRV_PCM_MMAP_OFFSET_STATUS:\r\nif (pcm_file->no_compat_mmap)\r\nreturn -ENXIO;\r\nreturn snd_pcm_mmap_status(substream, file, area);\r\ncase SNDRV_PCM_MMAP_OFFSET_CONTROL:\r\nif (pcm_file->no_compat_mmap)\r\nreturn -ENXIO;\r\nreturn snd_pcm_mmap_control(substream, file, area);\r\ndefault:\r\nreturn snd_pcm_mmap_data(substream, file, area);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_fasync(int fd, struct file * file, int on)\r\n{\r\nstruct snd_pcm_file * pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\npcm_file = file->private_data;\r\nsubstream = pcm_file->substream;\r\nif (PCM_RUNTIME_CHECK(substream))\r\nreturn -ENXIO;\r\nruntime = substream->runtime;\r\nreturn fasync_helper(fd, file, on, &runtime->fasync);\r\n}\r\nstatic void snd_pcm_hw_convert_from_old_params(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_params_old *oparams)\r\n{\r\nunsigned int i;\r\nmemset(params, 0, sizeof(*params));\r\nparams->flags = oparams->flags;\r\nfor (i = 0; i < ARRAY_SIZE(oparams->masks); i++)\r\nparams->masks[i].bits[0] = oparams->masks[i];\r\nmemcpy(params->intervals, oparams->intervals, sizeof(oparams->intervals));\r\nparams->rmask = __OLD_TO_NEW_MASK(oparams->rmask);\r\nparams->cmask = __OLD_TO_NEW_MASK(oparams->cmask);\r\nparams->info = oparams->info;\r\nparams->msbits = oparams->msbits;\r\nparams->rate_num = oparams->rate_num;\r\nparams->rate_den = oparams->rate_den;\r\nparams->fifo_size = oparams->fifo_size;\r\n}\r\nstatic void snd_pcm_hw_convert_to_old_params(struct snd_pcm_hw_params_old *oparams,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nunsigned int i;\r\nmemset(oparams, 0, sizeof(*oparams));\r\noparams->flags = params->flags;\r\nfor (i = 0; i < ARRAY_SIZE(oparams->masks); i++)\r\noparams->masks[i] = params->masks[i].bits[0];\r\nmemcpy(oparams->intervals, params->intervals, sizeof(oparams->intervals));\r\noparams->rmask = __NEW_TO_OLD_MASK(params->rmask);\r\noparams->cmask = __NEW_TO_OLD_MASK(params->cmask);\r\noparams->info = params->info;\r\noparams->msbits = params->msbits;\r\noparams->rate_num = params->rate_num;\r\noparams->rate_den = params->rate_den;\r\noparams->fifo_size = params->fifo_size;\r\n}\r\nstatic int snd_pcm_hw_refine_old_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params_old __user * _oparams)\r\n{\r\nstruct snd_pcm_hw_params *params;\r\nstruct snd_pcm_hw_params_old *oparams = NULL;\r\nint err;\r\nparams = kmalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\noparams = memdup_user(_oparams, sizeof(*oparams));\r\nif (IS_ERR(oparams)) {\r\nerr = PTR_ERR(oparams);\r\ngoto out;\r\n}\r\nsnd_pcm_hw_convert_from_old_params(params, oparams);\r\nerr = snd_pcm_hw_refine(substream, params);\r\nsnd_pcm_hw_convert_to_old_params(oparams, params);\r\nif (copy_to_user(_oparams, oparams, sizeof(*oparams))) {\r\nif (!err)\r\nerr = -EFAULT;\r\n}\r\nkfree(oparams);\r\nout:\r\nkfree(params);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_hw_params_old_user(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params_old __user * _oparams)\r\n{\r\nstruct snd_pcm_hw_params *params;\r\nstruct snd_pcm_hw_params_old *oparams = NULL;\r\nint err;\r\nparams = kmalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\noparams = memdup_user(_oparams, sizeof(*oparams));\r\nif (IS_ERR(oparams)) {\r\nerr = PTR_ERR(oparams);\r\ngoto out;\r\n}\r\nsnd_pcm_hw_convert_from_old_params(params, oparams);\r\nerr = snd_pcm_hw_params(substream, params);\r\nsnd_pcm_hw_convert_to_old_params(oparams, params);\r\nif (copy_to_user(_oparams, oparams, sizeof(*oparams))) {\r\nif (!err)\r\nerr = -EFAULT;\r\n}\r\nkfree(oparams);\r\nout:\r\nkfree(params);\r\nreturn err;\r\n}\r\nstatic unsigned long snd_pcm_get_unmapped_area(struct file *file,\r\nunsigned long addr,\r\nunsigned long len,\r\nunsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct snd_pcm_file *pcm_file = file->private_data;\r\nstruct snd_pcm_substream *substream = pcm_file->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long offset = pgoff << PAGE_SHIFT;\r\nswitch (offset) {\r\ncase SNDRV_PCM_MMAP_OFFSET_STATUS:\r\nreturn (unsigned long)runtime->status;\r\ncase SNDRV_PCM_MMAP_OFFSET_CONTROL:\r\nreturn (unsigned long)runtime->control;\r\ndefault:\r\nreturn (unsigned long)runtime->dma_area + offset;\r\n}\r\n}
