static void octeon_md5_store_hash(struct md5_state *ctx)\r\n{\r\nu64 *hash = (u64 *)ctx->hash;\r\nwrite_octeon_64bit_hash_dword(hash[0], 0);\r\nwrite_octeon_64bit_hash_dword(hash[1], 1);\r\n}\r\nstatic void octeon_md5_read_hash(struct md5_state *ctx)\r\n{\r\nu64 *hash = (u64 *)ctx->hash;\r\nhash[0] = read_octeon_64bit_hash_dword(0);\r\nhash[1] = read_octeon_64bit_hash_dword(1);\r\n}\r\nstatic void octeon_md5_transform(const void *_block)\r\n{\r\nconst u64 *block = _block;\r\nwrite_octeon_64bit_block_dword(block[0], 0);\r\nwrite_octeon_64bit_block_dword(block[1], 1);\r\nwrite_octeon_64bit_block_dword(block[2], 2);\r\nwrite_octeon_64bit_block_dword(block[3], 3);\r\nwrite_octeon_64bit_block_dword(block[4], 4);\r\nwrite_octeon_64bit_block_dword(block[5], 5);\r\nwrite_octeon_64bit_block_dword(block[6], 6);\r\nocteon_md5_start(block[7]);\r\n}\r\nstatic int octeon_md5_init(struct shash_desc *desc)\r\n{\r\nstruct md5_state *mctx = shash_desc_ctx(desc);\r\nmctx->hash[0] = cpu_to_le32(MD5_H0);\r\nmctx->hash[1] = cpu_to_le32(MD5_H1);\r\nmctx->hash[2] = cpu_to_le32(MD5_H2);\r\nmctx->hash[3] = cpu_to_le32(MD5_H3);\r\nmctx->byte_count = 0;\r\nreturn 0;\r\n}\r\nstatic int octeon_md5_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct md5_state *mctx = shash_desc_ctx(desc);\r\nconst u32 avail = sizeof(mctx->block) - (mctx->byte_count & 0x3f);\r\nstruct octeon_cop2_state state;\r\nunsigned long flags;\r\nmctx->byte_count += len;\r\nif (avail > len) {\r\nmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail),\r\ndata, len);\r\nreturn 0;\r\n}\r\nmemcpy((char *)mctx->block + (sizeof(mctx->block) - avail), data,\r\navail);\r\nflags = octeon_crypto_enable(&state);\r\nocteon_md5_store_hash(mctx);\r\nocteon_md5_transform(mctx->block);\r\ndata += avail;\r\nlen -= avail;\r\nwhile (len >= sizeof(mctx->block)) {\r\nocteon_md5_transform(data);\r\ndata += sizeof(mctx->block);\r\nlen -= sizeof(mctx->block);\r\n}\r\nocteon_md5_read_hash(mctx);\r\nocteon_crypto_disable(&state, flags);\r\nmemcpy(mctx->block, data, len);\r\nreturn 0;\r\n}\r\nstatic int octeon_md5_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct md5_state *mctx = shash_desc_ctx(desc);\r\nconst unsigned int offset = mctx->byte_count & 0x3f;\r\nchar *p = (char *)mctx->block + offset;\r\nint padding = 56 - (offset + 1);\r\nstruct octeon_cop2_state state;\r\nunsigned long flags;\r\n*p++ = 0x80;\r\nflags = octeon_crypto_enable(&state);\r\nocteon_md5_store_hash(mctx);\r\nif (padding < 0) {\r\nmemset(p, 0x00, padding + sizeof(u64));\r\nocteon_md5_transform(mctx->block);\r\np = (char *)mctx->block;\r\npadding = 56;\r\n}\r\nmemset(p, 0, padding);\r\nmctx->block[14] = cpu_to_le32(mctx->byte_count << 3);\r\nmctx->block[15] = cpu_to_le32(mctx->byte_count >> 29);\r\nocteon_md5_transform(mctx->block);\r\nocteon_md5_read_hash(mctx);\r\nocteon_crypto_disable(&state, flags);\r\nmemcpy(out, mctx->hash, sizeof(mctx->hash));\r\nmemset(mctx, 0, sizeof(*mctx));\r\nreturn 0;\r\n}\r\nstatic int octeon_md5_export(struct shash_desc *desc, void *out)\r\n{\r\nstruct md5_state *ctx = shash_desc_ctx(desc);\r\nmemcpy(out, ctx, sizeof(*ctx));\r\nreturn 0;\r\n}\r\nstatic int octeon_md5_import(struct shash_desc *desc, const void *in)\r\n{\r\nstruct md5_state *ctx = shash_desc_ctx(desc);\r\nmemcpy(ctx, in, sizeof(*ctx));\r\nreturn 0;\r\n}\r\nstatic int __init md5_mod_init(void)\r\n{\r\nif (!octeon_has_crypto())\r\nreturn -ENOTSUPP;\r\nreturn crypto_register_shash(&alg);\r\n}\r\nstatic void __exit md5_mod_fini(void)\r\n{\r\ncrypto_unregister_shash(&alg);\r\n}
