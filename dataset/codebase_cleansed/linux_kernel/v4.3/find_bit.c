static unsigned long _find_next_bit(const unsigned long *addr,\r\nunsigned long nbits, unsigned long start, unsigned long invert)\r\n{\r\nunsigned long tmp;\r\nif (!nbits || start >= nbits)\r\nreturn nbits;\r\ntmp = addr[start / BITS_PER_LONG] ^ invert;\r\ntmp &= BITMAP_FIRST_WORD_MASK(start);\r\nstart = round_down(start, BITS_PER_LONG);\r\nwhile (!tmp) {\r\nstart += BITS_PER_LONG;\r\nif (start >= nbits)\r\nreturn nbits;\r\ntmp = addr[start / BITS_PER_LONG] ^ invert;\r\n}\r\nreturn min(start + __ffs(tmp), nbits);\r\n}\r\nunsigned long find_next_bit(const unsigned long *addr, unsigned long size,\r\nunsigned long offset)\r\n{\r\nreturn _find_next_bit(addr, size, offset, 0UL);\r\n}\r\nunsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\r\nunsigned long offset)\r\n{\r\nreturn _find_next_bit(addr, size, offset, ~0UL);\r\n}\r\nunsigned long find_first_bit(const unsigned long *addr, unsigned long size)\r\n{\r\nunsigned long idx;\r\nfor (idx = 0; idx * BITS_PER_LONG < size; idx++) {\r\nif (addr[idx])\r\nreturn min(idx * BITS_PER_LONG + __ffs(addr[idx]), size);\r\n}\r\nreturn size;\r\n}\r\nunsigned long find_first_zero_bit(const unsigned long *addr, unsigned long size)\r\n{\r\nunsigned long idx;\r\nfor (idx = 0; idx * BITS_PER_LONG < size; idx++) {\r\nif (addr[idx] != ~0UL)\r\nreturn min(idx * BITS_PER_LONG + ffz(addr[idx]), size);\r\n}\r\nreturn size;\r\n}\r\nunsigned long find_last_bit(const unsigned long *addr, unsigned long size)\r\n{\r\nif (size) {\r\nunsigned long val = BITMAP_LAST_WORD_MASK(size);\r\nunsigned long idx = (size-1) / BITS_PER_LONG;\r\ndo {\r\nval &= addr[idx];\r\nif (val)\r\nreturn idx * BITS_PER_LONG + __fls(val);\r\nval = ~0ul;\r\n} while (idx--);\r\n}\r\nreturn size;\r\n}\r\nstatic inline unsigned long ext2_swab(const unsigned long y)\r\n{\r\n#if BITS_PER_LONG == 64\r\nreturn (unsigned long) __swab64((u64) y);\r\n#elif BITS_PER_LONG == 32\r\nreturn (unsigned long) __swab32((u32) y);\r\n#else\r\n#error BITS_PER_LONG not defined\r\n#endif\r\n}\r\nstatic unsigned long _find_next_bit_le(const unsigned long *addr,\r\nunsigned long nbits, unsigned long start, unsigned long invert)\r\n{\r\nunsigned long tmp;\r\nif (!nbits || start >= nbits)\r\nreturn nbits;\r\ntmp = addr[start / BITS_PER_LONG] ^ invert;\r\ntmp &= ext2_swab(BITMAP_FIRST_WORD_MASK(start));\r\nstart = round_down(start, BITS_PER_LONG);\r\nwhile (!tmp) {\r\nstart += BITS_PER_LONG;\r\nif (start >= nbits)\r\nreturn nbits;\r\ntmp = addr[start / BITS_PER_LONG] ^ invert;\r\n}\r\nreturn min(start + __ffs(ext2_swab(tmp)), nbits);\r\n}\r\nunsigned long find_next_zero_bit_le(const void *addr, unsigned\r\nlong size, unsigned long offset)\r\n{\r\nreturn _find_next_bit_le(addr, size, offset, ~0UL);\r\n}\r\nunsigned long find_next_bit_le(const void *addr, unsigned\r\nlong size, unsigned long offset)\r\n{\r\nreturn _find_next_bit_le(addr, size, offset, 0UL);\r\n}
