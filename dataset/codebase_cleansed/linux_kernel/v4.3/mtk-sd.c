static void sdr_set_bits(void __iomem *reg, u32 bs)\r\n{\r\nu32 val = readl(reg);\r\nval |= bs;\r\nwritel(val, reg);\r\n}\r\nstatic void sdr_clr_bits(void __iomem *reg, u32 bs)\r\n{\r\nu32 val = readl(reg);\r\nval &= ~bs;\r\nwritel(val, reg);\r\n}\r\nstatic void sdr_set_field(void __iomem *reg, u32 field, u32 val)\r\n{\r\nunsigned int tv = readl(reg);\r\ntv &= ~field;\r\ntv |= ((val) << (ffs((unsigned int)field) - 1));\r\nwritel(tv, reg);\r\n}\r\nstatic void sdr_get_field(void __iomem *reg, u32 field, u32 *val)\r\n{\r\nunsigned int tv = readl(reg);\r\n*val = ((tv & field) >> (ffs((unsigned int)field) - 1));\r\n}\r\nstatic void msdc_reset_hw(struct msdc_host *host)\r\n{\r\nu32 val;\r\nsdr_set_bits(host->base + MSDC_CFG, MSDC_CFG_RST);\r\nwhile (readl(host->base + MSDC_CFG) & MSDC_CFG_RST)\r\ncpu_relax();\r\nsdr_set_bits(host->base + MSDC_FIFOCS, MSDC_FIFOCS_CLR);\r\nwhile (readl(host->base + MSDC_FIFOCS) & MSDC_FIFOCS_CLR)\r\ncpu_relax();\r\nval = readl(host->base + MSDC_INT);\r\nwritel(val, host->base + MSDC_INT);\r\n}\r\nstatic u8 msdc_dma_calcs(u8 *buf, u32 len)\r\n{\r\nu32 i, sum = 0;\r\nfor (i = 0; i < len; i++)\r\nsum += buf[i];\r\nreturn 0xff - (u8) sum;\r\n}\r\nstatic inline void msdc_dma_setup(struct msdc_host *host, struct msdc_dma *dma,\r\nstruct mmc_data *data)\r\n{\r\nunsigned int j, dma_len;\r\ndma_addr_t dma_address;\r\nu32 dma_ctrl;\r\nstruct scatterlist *sg;\r\nstruct mt_gpdma_desc *gpd;\r\nstruct mt_bdma_desc *bd;\r\nsg = data->sg;\r\ngpd = dma->gpd;\r\nbd = dma->bd;\r\ngpd->gpd_info |= GPDMA_DESC_HWO;\r\ngpd->gpd_info |= GPDMA_DESC_BDP;\r\ngpd->gpd_info &= ~GPDMA_DESC_CHECKSUM;\r\ngpd->gpd_info |= msdc_dma_calcs((u8 *) gpd, 16) << 8;\r\nfor_each_sg(data->sg, sg, data->sg_count, j) {\r\ndma_address = sg_dma_address(sg);\r\ndma_len = sg_dma_len(sg);\r\nbd[j].bd_info &= ~BDMA_DESC_BLKPAD;\r\nbd[j].bd_info &= ~BDMA_DESC_DWPAD;\r\nbd[j].ptr = (u32)dma_address;\r\nbd[j].bd_data_len &= ~BDMA_DESC_BUFLEN;\r\nbd[j].bd_data_len |= (dma_len & BDMA_DESC_BUFLEN);\r\nif (j == data->sg_count - 1)\r\nbd[j].bd_info |= BDMA_DESC_EOL;\r\nelse\r\nbd[j].bd_info &= ~BDMA_DESC_EOL;\r\nbd[j].bd_info &= ~BDMA_DESC_CHECKSUM;\r\nbd[j].bd_info |= msdc_dma_calcs((u8 *)(&bd[j]), 16) << 8;\r\n}\r\nsdr_set_field(host->base + MSDC_DMA_CFG, MSDC_DMA_CFG_DECSEN, 1);\r\ndma_ctrl = readl_relaxed(host->base + MSDC_DMA_CTRL);\r\ndma_ctrl &= ~(MSDC_DMA_CTRL_BRUSTSZ | MSDC_DMA_CTRL_MODE);\r\ndma_ctrl |= (MSDC_BURST_64B << 12 | 1 << 8);\r\nwritel_relaxed(dma_ctrl, host->base + MSDC_DMA_CTRL);\r\nwritel((u32)dma->gpd_addr, host->base + MSDC_DMA_SA);\r\n}\r\nstatic void msdc_prepare_data(struct msdc_host *host, struct mmc_request *mrq)\r\n{\r\nstruct mmc_data *data = mrq->data;\r\nif (!(data->host_cookie & MSDC_PREPARE_FLAG)) {\r\nbool read = (data->flags & MMC_DATA_READ) != 0;\r\ndata->host_cookie |= MSDC_PREPARE_FLAG;\r\ndata->sg_count = dma_map_sg(host->dev, data->sg, data->sg_len,\r\nread ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\r\n}\r\n}\r\nstatic void msdc_unprepare_data(struct msdc_host *host, struct mmc_request *mrq)\r\n{\r\nstruct mmc_data *data = mrq->data;\r\nif (data->host_cookie & MSDC_ASYNC_FLAG)\r\nreturn;\r\nif (data->host_cookie & MSDC_PREPARE_FLAG) {\r\nbool read = (data->flags & MMC_DATA_READ) != 0;\r\ndma_unmap_sg(host->dev, data->sg, data->sg_len,\r\nread ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\r\ndata->host_cookie &= ~MSDC_PREPARE_FLAG;\r\n}\r\n}\r\nstatic void msdc_set_timeout(struct msdc_host *host, u32 ns, u32 clks)\r\n{\r\nu32 timeout, clk_ns;\r\nu32 mode = 0;\r\nhost->timeout_ns = ns;\r\nhost->timeout_clks = clks;\r\nif (host->sclk == 0) {\r\ntimeout = 0;\r\n} else {\r\nclk_ns = 1000000000UL / host->sclk;\r\ntimeout = (ns + clk_ns - 1) / clk_ns + clks;\r\ntimeout = (timeout + (0x1 << 20) - 1) >> 20;\r\nsdr_get_field(host->base + MSDC_CFG, MSDC_CFG_CKMOD, &mode);\r\ntimeout = mode >= 2 ? timeout * 2 : timeout;\r\ntimeout = timeout > 1 ? timeout - 1 : 0;\r\ntimeout = timeout > 255 ? 255 : timeout;\r\n}\r\nsdr_set_field(host->base + SDC_CFG, SDC_CFG_DTOC, timeout);\r\n}\r\nstatic void msdc_gate_clock(struct msdc_host *host)\r\n{\r\nclk_disable_unprepare(host->src_clk);\r\nclk_disable_unprepare(host->h_clk);\r\n}\r\nstatic void msdc_ungate_clock(struct msdc_host *host)\r\n{\r\nclk_prepare_enable(host->h_clk);\r\nclk_prepare_enable(host->src_clk);\r\nwhile (!(readl(host->base + MSDC_CFG) & MSDC_CFG_CKSTB))\r\ncpu_relax();\r\n}\r\nstatic void msdc_set_mclk(struct msdc_host *host, int ddr, u32 hz)\r\n{\r\nu32 mode;\r\nu32 flags;\r\nu32 div;\r\nu32 sclk;\r\nif (!hz) {\r\ndev_dbg(host->dev, "set mclk to 0\n");\r\nhost->mclk = 0;\r\nsdr_clr_bits(host->base + MSDC_CFG, MSDC_CFG_CKPDN);\r\nreturn;\r\n}\r\nflags = readl(host->base + MSDC_INTEN);\r\nsdr_clr_bits(host->base + MSDC_INTEN, flags);\r\nif (ddr) {\r\nmode = 0x2;\r\nif (hz >= (host->src_clk_freq >> 2)) {\r\ndiv = 0;\r\nsclk = host->src_clk_freq >> 2;\r\n} else {\r\ndiv = (host->src_clk_freq + ((hz << 2) - 1)) / (hz << 2);\r\nsclk = (host->src_clk_freq >> 2) / div;\r\ndiv = (div >> 1);\r\n}\r\n} else if (hz >= host->src_clk_freq) {\r\nmode = 0x1;\r\ndiv = 0;\r\nsclk = host->src_clk_freq;\r\n} else {\r\nmode = 0x0;\r\nif (hz >= (host->src_clk_freq >> 1)) {\r\ndiv = 0;\r\nsclk = host->src_clk_freq >> 1;\r\n} else {\r\ndiv = (host->src_clk_freq + ((hz << 2) - 1)) / (hz << 2);\r\nsclk = (host->src_clk_freq >> 2) / div;\r\n}\r\n}\r\nsdr_set_field(host->base + MSDC_CFG, MSDC_CFG_CKMOD | MSDC_CFG_CKDIV,\r\n(mode << 8) | (div % 0xff));\r\nsdr_set_bits(host->base + MSDC_CFG, MSDC_CFG_CKPDN);\r\nwhile (!(readl(host->base + MSDC_CFG) & MSDC_CFG_CKSTB))\r\ncpu_relax();\r\nhost->sclk = sclk;\r\nhost->mclk = hz;\r\nhost->ddr = ddr;\r\nmsdc_set_timeout(host, host->timeout_ns, host->timeout_clks);\r\nsdr_set_bits(host->base + MSDC_INTEN, flags);\r\ndev_dbg(host->dev, "sclk: %d, ddr: %d\n", host->sclk, ddr);\r\n}\r\nstatic inline u32 msdc_cmd_find_resp(struct msdc_host *host,\r\nstruct mmc_request *mrq, struct mmc_command *cmd)\r\n{\r\nu32 resp;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1:\r\nresp = 0x1;\r\nbreak;\r\ncase MMC_RSP_R1B:\r\nresp = 0x7;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nresp = 0x2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nresp = 0x3;\r\nbreak;\r\ncase MMC_RSP_NONE:\r\ndefault:\r\nresp = 0x0;\r\nbreak;\r\n}\r\nreturn resp;\r\n}\r\nstatic inline u32 msdc_cmd_prepare_raw_cmd(struct msdc_host *host,\r\nstruct mmc_request *mrq, struct mmc_command *cmd)\r\n{\r\nu32 opcode = cmd->opcode;\r\nu32 resp = msdc_cmd_find_resp(host, mrq, cmd);\r\nu32 rawcmd = (opcode & 0x3f) | ((resp & 0x7) << 7);\r\nhost->cmd_rsp = resp;\r\nif ((opcode == SD_IO_RW_DIRECT && cmd->flags == (unsigned int) -1) ||\r\nopcode == MMC_STOP_TRANSMISSION)\r\nrawcmd |= (0x1 << 14);\r\nelse if (opcode == SD_SWITCH_VOLTAGE)\r\nrawcmd |= (0x1 << 30);\r\nelse if (opcode == SD_APP_SEND_SCR ||\r\nopcode == SD_APP_SEND_NUM_WR_BLKS ||\r\n(opcode == SD_SWITCH && mmc_cmd_type(cmd) == MMC_CMD_ADTC) ||\r\n(opcode == SD_APP_SD_STATUS && mmc_cmd_type(cmd) == MMC_CMD_ADTC) ||\r\n(opcode == MMC_SEND_EXT_CSD && mmc_cmd_type(cmd) == MMC_CMD_ADTC))\r\nrawcmd |= (0x1 << 11);\r\nif (cmd->data) {\r\nstruct mmc_data *data = cmd->data;\r\nif (mmc_op_multi(opcode)) {\r\nif (mmc_card_mmc(host->mmc->card) && mrq->sbc &&\r\n!(mrq->sbc->arg & 0xFFFF0000))\r\nrawcmd |= 0x2 << 28;\r\n}\r\nrawcmd |= ((data->blksz & 0xFFF) << 16);\r\nif (data->flags & MMC_DATA_WRITE)\r\nrawcmd |= (0x1 << 13);\r\nif (data->blocks > 1)\r\nrawcmd |= (0x2 << 11);\r\nelse\r\nrawcmd |= (0x1 << 11);\r\nsdr_clr_bits(host->base + MSDC_CFG, MSDC_CFG_PIO);\r\nif (host->timeout_ns != data->timeout_ns ||\r\nhost->timeout_clks != data->timeout_clks)\r\nmsdc_set_timeout(host, data->timeout_ns,\r\ndata->timeout_clks);\r\nwritel(data->blocks, host->base + SDC_BLK_NUM);\r\n}\r\nreturn rawcmd;\r\n}\r\nstatic void msdc_start_data(struct msdc_host *host, struct mmc_request *mrq,\r\nstruct mmc_command *cmd, struct mmc_data *data)\r\n{\r\nbool read;\r\nWARN_ON(host->data);\r\nhost->data = data;\r\nread = data->flags & MMC_DATA_READ;\r\nmod_delayed_work(system_wq, &host->req_timeout, DAT_TIMEOUT);\r\nmsdc_dma_setup(host, &host->dma, data);\r\nsdr_set_bits(host->base + MSDC_INTEN, data_ints_mask);\r\nsdr_set_field(host->base + MSDC_DMA_CTRL, MSDC_DMA_CTRL_START, 1);\r\ndev_dbg(host->dev, "DMA start\n");\r\ndev_dbg(host->dev, "%s: cmd=%d DMA data: %d blocks; read=%d\n",\r\n__func__, cmd->opcode, data->blocks, read);\r\n}\r\nstatic int msdc_auto_cmd_done(struct msdc_host *host, int events,\r\nstruct mmc_command *cmd)\r\n{\r\nu32 *rsp = cmd->resp;\r\nrsp[0] = readl(host->base + SDC_ACMD_RESP);\r\nif (events & MSDC_INT_ACMDRDY) {\r\ncmd->error = 0;\r\n} else {\r\nmsdc_reset_hw(host);\r\nif (events & MSDC_INT_ACMDCRCERR) {\r\ncmd->error = -EILSEQ;\r\nhost->error |= REQ_STOP_EIO;\r\n} else if (events & MSDC_INT_ACMDTMO) {\r\ncmd->error = -ETIMEDOUT;\r\nhost->error |= REQ_STOP_TMO;\r\n}\r\ndev_err(host->dev,\r\n"%s: AUTO_CMD%d arg=%08X; rsp %08X; cmd_error=%d\n",\r\n__func__, cmd->opcode, cmd->arg, rsp[0], cmd->error);\r\n}\r\nreturn cmd->error;\r\n}\r\nstatic void msdc_track_cmd_data(struct msdc_host *host,\r\nstruct mmc_command *cmd, struct mmc_data *data)\r\n{\r\nif (host->error)\r\ndev_dbg(host->dev, "%s: cmd=%d arg=%08X; host->error=0x%08X\n",\r\n__func__, cmd->opcode, cmd->arg, host->error);\r\n}\r\nstatic void msdc_request_done(struct msdc_host *host, struct mmc_request *mrq)\r\n{\r\nunsigned long flags;\r\nbool ret;\r\nret = cancel_delayed_work(&host->req_timeout);\r\nif (!ret) {\r\nreturn;\r\n}\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->mrq = NULL;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmsdc_track_cmd_data(host, mrq->cmd, mrq->data);\r\nif (mrq->data)\r\nmsdc_unprepare_data(host, mrq);\r\nmmc_request_done(host->mmc, mrq);\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\n}\r\nstatic bool msdc_cmd_done(struct msdc_host *host, int events,\r\nstruct mmc_request *mrq, struct mmc_command *cmd)\r\n{\r\nbool done = false;\r\nbool sbc_error;\r\nunsigned long flags;\r\nu32 *rsp = cmd->resp;\r\nif (mrq->sbc && cmd == mrq->cmd &&\r\n(events & (MSDC_INT_ACMDRDY | MSDC_INT_ACMDCRCERR\r\n| MSDC_INT_ACMDTMO)))\r\nmsdc_auto_cmd_done(host, events, mrq->sbc);\r\nsbc_error = mrq->sbc && mrq->sbc->error;\r\nif (!sbc_error && !(events & (MSDC_INT_CMDRDY\r\n| MSDC_INT_RSPCRCERR\r\n| MSDC_INT_CMDTMO)))\r\nreturn done;\r\nspin_lock_irqsave(&host->lock, flags);\r\ndone = !host->cmd;\r\nhost->cmd = NULL;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (done)\r\nreturn true;\r\nsdr_clr_bits(host->base + MSDC_INTEN, MSDC_INTEN_CMDRDY |\r\nMSDC_INTEN_RSPCRCERR | MSDC_INTEN_CMDTMO |\r\nMSDC_INTEN_ACMDRDY | MSDC_INTEN_ACMDCRCERR |\r\nMSDC_INTEN_ACMDTMO);\r\nwritel(cmd->arg, host->base + SDC_ARG);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\nrsp[0] = readl(host->base + SDC_RESP3);\r\nrsp[1] = readl(host->base + SDC_RESP2);\r\nrsp[2] = readl(host->base + SDC_RESP1);\r\nrsp[3] = readl(host->base + SDC_RESP0);\r\n} else {\r\nrsp[0] = readl(host->base + SDC_RESP0);\r\n}\r\n}\r\nif (!sbc_error && !(events & MSDC_INT_CMDRDY)) {\r\nmsdc_reset_hw(host);\r\nif (events & MSDC_INT_RSPCRCERR) {\r\ncmd->error = -EILSEQ;\r\nhost->error |= REQ_CMD_EIO;\r\n} else if (events & MSDC_INT_CMDTMO) {\r\ncmd->error = -ETIMEDOUT;\r\nhost->error |= REQ_CMD_TMO;\r\n}\r\n}\r\nif (cmd->error)\r\ndev_dbg(host->dev,\r\n"%s: cmd=%d arg=%08X; rsp %08X; cmd_error=%d\n",\r\n__func__, cmd->opcode, cmd->arg, rsp[0],\r\ncmd->error);\r\nmsdc_cmd_next(host, mrq, cmd);\r\nreturn true;\r\n}\r\nstatic inline bool msdc_cmd_is_ready(struct msdc_host *host,\r\nstruct mmc_request *mrq, struct mmc_command *cmd)\r\n{\r\nunsigned long tmo = jiffies + msecs_to_jiffies(20);\r\nwhile ((readl(host->base + SDC_STS) & SDC_STS_CMDBUSY) &&\r\ntime_before(jiffies, tmo))\r\ncpu_relax();\r\nif (readl(host->base + SDC_STS) & SDC_STS_CMDBUSY) {\r\ndev_err(host->dev, "CMD bus busy detected\n");\r\nhost->error |= REQ_CMD_BUSY;\r\nmsdc_cmd_done(host, MSDC_INT_CMDTMO, mrq, cmd);\r\nreturn false;\r\n}\r\nif (mmc_resp_type(cmd) == MMC_RSP_R1B || cmd->data) {\r\ntmo = jiffies + msecs_to_jiffies(20);\r\nwhile ((readl(host->base + SDC_STS) & SDC_STS_SDCBUSY) &&\r\ntime_before(jiffies, tmo))\r\ncpu_relax();\r\nif (readl(host->base + SDC_STS) & SDC_STS_SDCBUSY) {\r\ndev_err(host->dev, "Controller busy detected\n");\r\nhost->error |= REQ_CMD_BUSY;\r\nmsdc_cmd_done(host, MSDC_INT_CMDTMO, mrq, cmd);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void msdc_start_command(struct msdc_host *host,\r\nstruct mmc_request *mrq, struct mmc_command *cmd)\r\n{\r\nu32 rawcmd;\r\nWARN_ON(host->cmd);\r\nhost->cmd = cmd;\r\nif (!msdc_cmd_is_ready(host, mrq, cmd))\r\nreturn;\r\nif ((readl(host->base + MSDC_FIFOCS) & MSDC_FIFOCS_TXCNT) >> 16 ||\r\nreadl(host->base + MSDC_FIFOCS) & MSDC_FIFOCS_RXCNT) {\r\ndev_err(host->dev, "TX/RX FIFO non-empty before start of IO. Reset\n");\r\nmsdc_reset_hw(host);\r\n}\r\ncmd->error = 0;\r\nrawcmd = msdc_cmd_prepare_raw_cmd(host, mrq, cmd);\r\nmod_delayed_work(system_wq, &host->req_timeout, DAT_TIMEOUT);\r\nsdr_set_bits(host->base + MSDC_INTEN, MSDC_INTEN_CMDRDY |\r\nMSDC_INTEN_RSPCRCERR | MSDC_INTEN_CMDTMO |\r\nMSDC_INTEN_ACMDRDY | MSDC_INTEN_ACMDCRCERR |\r\nMSDC_INTEN_ACMDTMO);\r\nwritel(cmd->arg, host->base + SDC_ARG);\r\nwritel(rawcmd, host->base + SDC_CMD);\r\n}\r\nstatic void msdc_cmd_next(struct msdc_host *host,\r\nstruct mmc_request *mrq, struct mmc_command *cmd)\r\n{\r\nif (cmd->error || (mrq->sbc && mrq->sbc->error))\r\nmsdc_request_done(host, mrq);\r\nelse if (cmd == mrq->sbc)\r\nmsdc_start_command(host, mrq, mrq->cmd);\r\nelse if (!cmd->data)\r\nmsdc_request_done(host, mrq);\r\nelse\r\nmsdc_start_data(host, mrq, cmd, cmd->data);\r\n}\r\nstatic void msdc_ops_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nhost->error = 0;\r\nWARN_ON(host->mrq);\r\nhost->mrq = mrq;\r\npm_runtime_get_sync(host->dev);\r\nif (mrq->data)\r\nmsdc_prepare_data(host, mrq);\r\nif (mrq->sbc && (!mmc_card_mmc(mmc->card) ||\r\n(mrq->sbc->arg & 0xFFFF0000)))\r\nmsdc_start_command(host, mrq, mrq->sbc);\r\nelse\r\nmsdc_start_command(host, mrq, mrq->cmd);\r\n}\r\nstatic void msdc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,\r\nbool is_first_req)\r\n{\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nstruct mmc_data *data = mrq->data;\r\nif (!data)\r\nreturn;\r\nmsdc_prepare_data(host, mrq);\r\ndata->host_cookie |= MSDC_ASYNC_FLAG;\r\n}\r\nstatic void msdc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\r\nint err)\r\n{\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nstruct mmc_data *data;\r\ndata = mrq->data;\r\nif (!data)\r\nreturn;\r\nif (data->host_cookie) {\r\ndata->host_cookie &= ~MSDC_ASYNC_FLAG;\r\nmsdc_unprepare_data(host, mrq);\r\n}\r\n}\r\nstatic void msdc_data_xfer_next(struct msdc_host *host,\r\nstruct mmc_request *mrq, struct mmc_data *data)\r\n{\r\nif (mmc_op_multi(mrq->cmd->opcode) && mrq->stop && !mrq->stop->error &&\r\n(!data->bytes_xfered || !mrq->sbc))\r\nmsdc_start_command(host, mrq, mrq->stop);\r\nelse\r\nmsdc_request_done(host, mrq);\r\n}\r\nstatic bool msdc_data_xfer_done(struct msdc_host *host, u32 events,\r\nstruct mmc_request *mrq, struct mmc_data *data)\r\n{\r\nstruct mmc_command *stop = data->stop;\r\nunsigned long flags;\r\nbool done;\r\nunsigned int check_data = events &\r\n(MSDC_INT_XFER_COMPL | MSDC_INT_DATCRCERR | MSDC_INT_DATTMO\r\n| MSDC_INT_DMA_BDCSERR | MSDC_INT_DMA_GPDCSERR\r\n| MSDC_INT_DMA_PROTECT);\r\nspin_lock_irqsave(&host->lock, flags);\r\ndone = !host->data;\r\nif (check_data)\r\nhost->data = NULL;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (done)\r\nreturn true;\r\nif (check_data || (stop && stop->error)) {\r\ndev_dbg(host->dev, "DMA status: 0x%8X\n",\r\nreadl(host->base + MSDC_DMA_CFG));\r\nsdr_set_field(host->base + MSDC_DMA_CTRL, MSDC_DMA_CTRL_STOP,\r\n1);\r\nwhile (readl(host->base + MSDC_DMA_CFG) & MSDC_DMA_CFG_STS)\r\ncpu_relax();\r\nsdr_clr_bits(host->base + MSDC_INTEN, data_ints_mask);\r\ndev_dbg(host->dev, "DMA stop\n");\r\nif ((events & MSDC_INT_XFER_COMPL) && (!stop || !stop->error)) {\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\n} else {\r\ndev_err(host->dev, "interrupt events: %x\n", events);\r\nmsdc_reset_hw(host);\r\nhost->error |= REQ_DAT_ERR;\r\ndata->bytes_xfered = 0;\r\nif (events & MSDC_INT_DATTMO)\r\ndata->error = -ETIMEDOUT;\r\ndev_err(host->dev, "%s: cmd=%d; blocks=%d",\r\n__func__, mrq->cmd->opcode, data->blocks);\r\ndev_err(host->dev, "data_error=%d xfer_size=%d\n",\r\n(int)data->error, data->bytes_xfered);\r\n}\r\nmsdc_data_xfer_next(host, mrq, data);\r\ndone = true;\r\n}\r\nreturn done;\r\n}\r\nstatic void msdc_set_buswidth(struct msdc_host *host, u32 width)\r\n{\r\nu32 val = readl(host->base + SDC_CFG);\r\nval &= ~SDC_CFG_BUSWIDTH;\r\nswitch (width) {\r\ndefault:\r\ncase MMC_BUS_WIDTH_1:\r\nval |= (MSDC_BUS_1BITS << 16);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nval |= (MSDC_BUS_4BITS << 16);\r\nbreak;\r\ncase MMC_BUS_WIDTH_8:\r\nval |= (MSDC_BUS_8BITS << 16);\r\nbreak;\r\n}\r\nwritel(val, host->base + SDC_CFG);\r\ndev_dbg(host->dev, "Bus Width = %d", width);\r\n}\r\nstatic int msdc_ops_switch_volt(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nint min_uv, max_uv;\r\nint ret = 0;\r\nif (!IS_ERR(mmc->supply.vqmmc)) {\r\nif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\r\nmin_uv = 3300000;\r\nmax_uv = 3300000;\r\n} else if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180) {\r\nmin_uv = 1800000;\r\nmax_uv = 1800000;\r\n} else {\r\ndev_err(host->dev, "Unsupported signal voltage!\n");\r\nreturn -EINVAL;\r\n}\r\nret = regulator_set_voltage(mmc->supply.vqmmc, min_uv, max_uv);\r\nif (ret) {\r\ndev_err(host->dev,\r\n"Regulator set error %d: %d - %d\n",\r\nret, min_uv, max_uv);\r\n} else {\r\nif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)\r\npinctrl_select_state(host->pinctrl, host->pins_uhs);\r\nelse\r\npinctrl_select_state(host->pinctrl, host->pins_default);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int msdc_card_busy(struct mmc_host *mmc)\r\n{\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nu32 status = readl(host->base + MSDC_PS);\r\nif (((status >> 16) & 0xf) != 0xf)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void msdc_request_timeout(struct work_struct *work)\r\n{\r\nstruct msdc_host *host = container_of(work, struct msdc_host,\r\nreq_timeout.work);\r\ndev_err(host->dev, "%s: aborting cmd/data/mrq\n", __func__);\r\nif (host->mrq) {\r\ndev_err(host->dev, "%s: aborting mrq=%p cmd=%d\n", __func__,\r\nhost->mrq, host->mrq->cmd->opcode);\r\nif (host->cmd) {\r\ndev_err(host->dev, "%s: aborting cmd=%d\n",\r\n__func__, host->cmd->opcode);\r\nmsdc_cmd_done(host, MSDC_INT_CMDTMO, host->mrq,\r\nhost->cmd);\r\n} else if (host->data) {\r\ndev_err(host->dev, "%s: abort data: cmd%d; %d blocks\n",\r\n__func__, host->mrq->cmd->opcode,\r\nhost->data->blocks);\r\nmsdc_data_xfer_done(host, MSDC_INT_DATTMO, host->mrq,\r\nhost->data);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t msdc_irq(int irq, void *dev_id)\r\n{\r\nstruct msdc_host *host = (struct msdc_host *) dev_id;\r\nwhile (true) {\r\nunsigned long flags;\r\nstruct mmc_request *mrq;\r\nstruct mmc_command *cmd;\r\nstruct mmc_data *data;\r\nu32 events, event_mask;\r\nspin_lock_irqsave(&host->lock, flags);\r\nevents = readl(host->base + MSDC_INT);\r\nevent_mask = readl(host->base + MSDC_INTEN);\r\nwritel(events & event_mask, host->base + MSDC_INT);\r\nmrq = host->mrq;\r\ncmd = host->cmd;\r\ndata = host->data;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (!(events & event_mask))\r\nbreak;\r\nif (!mrq) {\r\ndev_err(host->dev,\r\n"%s: MRQ=NULL; events=%08X; event_mask=%08X\n",\r\n__func__, events, event_mask);\r\nWARN_ON(1);\r\nbreak;\r\n}\r\ndev_dbg(host->dev, "%s: events=%08X\n", __func__, events);\r\nif (cmd)\r\nmsdc_cmd_done(host, events, mrq, cmd);\r\nelse if (data)\r\nmsdc_data_xfer_done(host, events, mrq, data);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void msdc_init_hw(struct msdc_host *host)\r\n{\r\nu32 val;\r\nsdr_set_bits(host->base + MSDC_CFG, MSDC_CFG_MODE | MSDC_CFG_CKPDN);\r\nmsdc_reset_hw(host);\r\nsdr_clr_bits(host->base + MSDC_PS, MSDC_PS_CDEN);\r\nwritel(0, host->base + MSDC_INTEN);\r\nval = readl(host->base + MSDC_INT);\r\nwritel(val, host->base + MSDC_INT);\r\nwritel(0, host->base + MSDC_PAD_TUNE);\r\nwritel(0, host->base + MSDC_IOCON);\r\nsdr_set_field(host->base + MSDC_IOCON, MSDC_IOCON_DDLSEL, 1);\r\nwritel(0x403c004f, host->base + MSDC_PATCH_BIT);\r\nsdr_set_field(host->base + MSDC_PATCH_BIT, MSDC_CKGEN_MSDC_DLY_SEL, 1);\r\nwritel(0xffff0089, host->base + MSDC_PATCH_BIT1);\r\nsdr_set_bits(host->base + SDC_CFG, SDC_CFG_SDIO);\r\nsdr_clr_bits(host->base + SDC_CFG, SDC_CFG_SDIOIDE);\r\nsdr_set_field(host->base + SDC_CFG, SDC_CFG_DTOC, 3);\r\ndev_dbg(host->dev, "init hardware done!");\r\n}\r\nstatic void msdc_deinit_hw(struct msdc_host *host)\r\n{\r\nu32 val;\r\nwritel(0, host->base + MSDC_INTEN);\r\nval = readl(host->base + MSDC_INT);\r\nwritel(val, host->base + MSDC_INT);\r\n}\r\nstatic void msdc_init_gpd_bd(struct msdc_host *host, struct msdc_dma *dma)\r\n{\r\nstruct mt_gpdma_desc *gpd = dma->gpd;\r\nstruct mt_bdma_desc *bd = dma->bd;\r\nint i;\r\nmemset(gpd, 0, sizeof(struct mt_gpdma_desc));\r\ngpd->gpd_info = GPDMA_DESC_BDP;\r\ngpd->ptr = (u32)dma->bd_addr;\r\nmemset(bd, 0, sizeof(struct mt_bdma_desc) * MAX_BD_NUM);\r\nfor (i = 0; i < (MAX_BD_NUM - 1); i++)\r\nbd[i].next = (u32)dma->bd_addr + sizeof(*bd) * (i + 1);\r\n}\r\nstatic void msdc_ops_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nint ret;\r\nu32 ddr = 0;\r\npm_runtime_get_sync(host->dev);\r\nif (ios->timing == MMC_TIMING_UHS_DDR50 ||\r\nios->timing == MMC_TIMING_MMC_DDR52)\r\nddr = 1;\r\nmsdc_set_buswidth(host, ios->bus_width);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_UP:\r\nif (!IS_ERR(mmc->supply.vmmc)) {\r\nret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc,\r\nios->vdd);\r\nif (ret) {\r\ndev_err(host->dev, "Failed to set vmmc power!\n");\r\ngoto end;\r\n}\r\n}\r\nbreak;\r\ncase MMC_POWER_ON:\r\nif (!IS_ERR(mmc->supply.vqmmc) && !host->vqmmc_enabled) {\r\nret = regulator_enable(mmc->supply.vqmmc);\r\nif (ret)\r\ndev_err(host->dev, "Failed to set vqmmc power!\n");\r\nelse\r\nhost->vqmmc_enabled = true;\r\n}\r\nbreak;\r\ncase MMC_POWER_OFF:\r\nif (!IS_ERR(mmc->supply.vmmc))\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\r\nif (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled) {\r\nregulator_disable(mmc->supply.vqmmc);\r\nhost->vqmmc_enabled = false;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (host->mclk != ios->clock || host->ddr != ddr)\r\nmsdc_set_mclk(host, ddr, ios->clock);\r\nend:\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\n}\r\nstatic int msdc_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct msdc_host *host;\r\nstruct resource *res;\r\nint ret;\r\nif (!pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "No DT found\n");\r\nreturn -EINVAL;\r\n}\r\nmmc = mmc_alloc_host(sizeof(struct msdc_host), &pdev->dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nhost = mmc_priv(mmc);\r\nret = mmc_of_parse(mmc);\r\nif (ret)\r\ngoto host_free;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->base)) {\r\nret = PTR_ERR(host->base);\r\ngoto host_free;\r\n}\r\nret = mmc_regulator_get_supply(mmc);\r\nif (ret == -EPROBE_DEFER)\r\ngoto host_free;\r\nhost->src_clk = devm_clk_get(&pdev->dev, "source");\r\nif (IS_ERR(host->src_clk)) {\r\nret = PTR_ERR(host->src_clk);\r\ngoto host_free;\r\n}\r\nhost->h_clk = devm_clk_get(&pdev->dev, "hclk");\r\nif (IS_ERR(host->h_clk)) {\r\nret = PTR_ERR(host->h_clk);\r\ngoto host_free;\r\n}\r\nhost->irq = platform_get_irq(pdev, 0);\r\nif (host->irq < 0) {\r\nret = -EINVAL;\r\ngoto host_free;\r\n}\r\nhost->pinctrl = devm_pinctrl_get(&pdev->dev);\r\nif (IS_ERR(host->pinctrl)) {\r\nret = PTR_ERR(host->pinctrl);\r\ndev_err(&pdev->dev, "Cannot find pinctrl!\n");\r\ngoto host_free;\r\n}\r\nhost->pins_default = pinctrl_lookup_state(host->pinctrl, "default");\r\nif (IS_ERR(host->pins_default)) {\r\nret = PTR_ERR(host->pins_default);\r\ndev_err(&pdev->dev, "Cannot find pinctrl default!\n");\r\ngoto host_free;\r\n}\r\nhost->pins_uhs = pinctrl_lookup_state(host->pinctrl, "state_uhs");\r\nif (IS_ERR(host->pins_uhs)) {\r\nret = PTR_ERR(host->pins_uhs);\r\ndev_err(&pdev->dev, "Cannot find pinctrl uhs!\n");\r\ngoto host_free;\r\n}\r\nhost->dev = &pdev->dev;\r\nhost->mmc = mmc;\r\nhost->src_clk_freq = clk_get_rate(host->src_clk);\r\nmmc->ops = &mt_msdc_ops;\r\nmmc->f_min = host->src_clk_freq / (4 * 255);\r\nmmc->caps |= MMC_CAP_ERASE | MMC_CAP_CMD23;\r\nmmc->max_segs = MAX_BD_NUM;\r\nmmc->max_seg_size = BDMA_DESC_BUFLEN;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_req_size = 512 * 1024;\r\nmmc->max_blk_count = mmc->max_req_size / 512;\r\nhost->dma_mask = DMA_BIT_MASK(32);\r\nmmc_dev(mmc)->dma_mask = &host->dma_mask;\r\nhost->timeout_clks = 3 * 1048576;\r\nhost->dma.gpd = dma_alloc_coherent(&pdev->dev,\r\nsizeof(struct mt_gpdma_desc),\r\n&host->dma.gpd_addr, GFP_KERNEL);\r\nhost->dma.bd = dma_alloc_coherent(&pdev->dev,\r\nMAX_BD_NUM * sizeof(struct mt_bdma_desc),\r\n&host->dma.bd_addr, GFP_KERNEL);\r\nif (!host->dma.gpd || !host->dma.bd) {\r\nret = -ENOMEM;\r\ngoto release_mem;\r\n}\r\nmsdc_init_gpd_bd(host, &host->dma);\r\nINIT_DELAYED_WORK(&host->req_timeout, msdc_request_timeout);\r\nspin_lock_init(&host->lock);\r\nplatform_set_drvdata(pdev, mmc);\r\nmsdc_ungate_clock(host);\r\nmsdc_init_hw(host);\r\nret = devm_request_irq(&pdev->dev, host->irq, msdc_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT, pdev->name, host);\r\nif (ret)\r\ngoto release;\r\npm_runtime_set_active(host->dev);\r\npm_runtime_set_autosuspend_delay(host->dev, MTK_MMC_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(host->dev);\r\npm_runtime_enable(host->dev);\r\nret = mmc_add_host(mmc);\r\nif (ret)\r\ngoto end;\r\nreturn 0;\r\nend:\r\npm_runtime_disable(host->dev);\r\nrelease:\r\nplatform_set_drvdata(pdev, NULL);\r\nmsdc_deinit_hw(host);\r\nmsdc_gate_clock(host);\r\nrelease_mem:\r\nif (host->dma.gpd)\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct mt_gpdma_desc),\r\nhost->dma.gpd, host->dma.gpd_addr);\r\nif (host->dma.bd)\r\ndma_free_coherent(&pdev->dev,\r\nMAX_BD_NUM * sizeof(struct mt_bdma_desc),\r\nhost->dma.bd, host->dma.bd_addr);\r\nhost_free:\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int msdc_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct msdc_host *host;\r\nmmc = platform_get_drvdata(pdev);\r\nhost = mmc_priv(mmc);\r\npm_runtime_get_sync(host->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nmmc_remove_host(host->mmc);\r\nmsdc_deinit_hw(host);\r\nmsdc_gate_clock(host);\r\npm_runtime_disable(host->dev);\r\npm_runtime_put_noidle(host->dev);\r\ndma_free_coherent(&pdev->dev,\r\nsizeof(struct mt_gpdma_desc),\r\nhost->dma.gpd, host->dma.gpd_addr);\r\ndma_free_coherent(&pdev->dev, MAX_BD_NUM * sizeof(struct mt_bdma_desc),\r\nhost->dma.bd, host->dma.bd_addr);\r\nmmc_free_host(host->mmc);\r\nreturn 0;\r\n}\r\nstatic void msdc_save_reg(struct msdc_host *host)\r\n{\r\nhost->save_para.msdc_cfg = readl(host->base + MSDC_CFG);\r\nhost->save_para.iocon = readl(host->base + MSDC_IOCON);\r\nhost->save_para.sdc_cfg = readl(host->base + SDC_CFG);\r\nhost->save_para.pad_tune = readl(host->base + MSDC_PAD_TUNE);\r\nhost->save_para.patch_bit0 = readl(host->base + MSDC_PATCH_BIT);\r\nhost->save_para.patch_bit1 = readl(host->base + MSDC_PATCH_BIT1);\r\n}\r\nstatic void msdc_restore_reg(struct msdc_host *host)\r\n{\r\nwritel(host->save_para.msdc_cfg, host->base + MSDC_CFG);\r\nwritel(host->save_para.iocon, host->base + MSDC_IOCON);\r\nwritel(host->save_para.sdc_cfg, host->base + SDC_CFG);\r\nwritel(host->save_para.pad_tune, host->base + MSDC_PAD_TUNE);\r\nwritel(host->save_para.patch_bit0, host->base + MSDC_PATCH_BIT);\r\nwritel(host->save_para.patch_bit1, host->base + MSDC_PATCH_BIT1);\r\n}\r\nstatic int msdc_runtime_suspend(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nmsdc_save_reg(host);\r\nmsdc_gate_clock(host);\r\nreturn 0;\r\n}\r\nstatic int msdc_runtime_resume(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct msdc_host *host = mmc_priv(mmc);\r\nmsdc_ungate_clock(host);\r\nmsdc_restore_reg(host);\r\nreturn 0;\r\n}
