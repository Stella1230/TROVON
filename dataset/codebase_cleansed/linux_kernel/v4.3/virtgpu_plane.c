static void virtio_gpu_plane_destroy(struct drm_plane *plane)\r\n{\r\nkfree(plane);\r\n}\r\nstatic int virtio_gpu_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nreturn 0;\r\n}\r\nstatic void virtio_gpu_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct virtio_gpu_device *vgdev = dev->dev_private;\r\nstruct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(plane->crtc);\r\nstruct virtio_gpu_framebuffer *vgfb;\r\nstruct virtio_gpu_object *bo;\r\nuint32_t handle;\r\nif (plane->fb) {\r\nvgfb = to_virtio_gpu_framebuffer(plane->fb);\r\nbo = gem_to_virtio_gpu_obj(vgfb->obj);\r\nhandle = bo->hw_res_handle;\r\n} else {\r\nhandle = 0;\r\n}\r\nDRM_DEBUG("handle 0x%x, crtc %dx%d+%d+%d\n", handle,\r\nplane->state->crtc_w, plane->state->crtc_h,\r\nplane->state->crtc_x, plane->state->crtc_y);\r\nvirtio_gpu_cmd_set_scanout(vgdev, output->index, handle,\r\nplane->state->crtc_w,\r\nplane->state->crtc_h,\r\nplane->state->crtc_x,\r\nplane->state->crtc_y);\r\n}\r\nstruct drm_plane *virtio_gpu_plane_init(struct virtio_gpu_device *vgdev,\r\nint index)\r\n{\r\nstruct drm_device *dev = vgdev->ddev;\r\nstruct drm_plane *plane;\r\nint ret;\r\nplane = kzalloc(sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = drm_universal_plane_init(dev, plane, 1 << index,\r\n&virtio_gpu_plane_funcs,\r\nvirtio_gpu_formats,\r\nARRAY_SIZE(virtio_gpu_formats),\r\nDRM_PLANE_TYPE_PRIMARY);\r\nif (ret)\r\ngoto err_plane_init;\r\ndrm_plane_helper_add(plane, &virtio_gpu_plane_helper_funcs);\r\nreturn plane;\r\nerr_plane_init:\r\nkfree(plane);\r\nreturn ERR_PTR(ret);\r\n}
