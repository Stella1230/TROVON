static bool dynamic_country_user_possible(struct ath_regulatory *reg)\r\n{\r\nif (config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))\r\nreturn true;\r\nswitch (reg->country_code) {\r\ncase CTRY_UNITED_STATES:\r\ncase CTRY_JAPAN1:\r\ncase CTRY_JAPAN2:\r\ncase CTRY_JAPAN3:\r\ncase CTRY_JAPAN4:\r\ncase CTRY_JAPAN5:\r\ncase CTRY_JAPAN6:\r\ncase CTRY_JAPAN7:\r\ncase CTRY_JAPAN8:\r\ncase CTRY_JAPAN9:\r\ncase CTRY_JAPAN10:\r\ncase CTRY_JAPAN11:\r\ncase CTRY_JAPAN12:\r\ncase CTRY_JAPAN13:\r\ncase CTRY_JAPAN14:\r\ncase CTRY_JAPAN15:\r\ncase CTRY_JAPAN16:\r\ncase CTRY_JAPAN17:\r\ncase CTRY_JAPAN18:\r\ncase CTRY_JAPAN19:\r\ncase CTRY_JAPAN20:\r\ncase CTRY_JAPAN21:\r\ncase CTRY_JAPAN22:\r\ncase CTRY_JAPAN23:\r\ncase CTRY_JAPAN24:\r\ncase CTRY_JAPAN25:\r\ncase CTRY_JAPAN26:\r\ncase CTRY_JAPAN27:\r\ncase CTRY_JAPAN28:\r\ncase CTRY_JAPAN29:\r\ncase CTRY_JAPAN30:\r\ncase CTRY_JAPAN31:\r\ncase CTRY_JAPAN32:\r\ncase CTRY_JAPAN33:\r\ncase CTRY_JAPAN34:\r\ncase CTRY_JAPAN35:\r\ncase CTRY_JAPAN36:\r\ncase CTRY_JAPAN37:\r\ncase CTRY_JAPAN38:\r\ncase CTRY_JAPAN39:\r\ncase CTRY_JAPAN40:\r\ncase CTRY_JAPAN41:\r\ncase CTRY_JAPAN42:\r\ncase CTRY_JAPAN43:\r\ncase CTRY_JAPAN44:\r\ncase CTRY_JAPAN45:\r\ncase CTRY_JAPAN46:\r\ncase CTRY_JAPAN47:\r\ncase CTRY_JAPAN48:\r\ncase CTRY_JAPAN49:\r\ncase CTRY_JAPAN50:\r\ncase CTRY_JAPAN51:\r\ncase CTRY_JAPAN52:\r\ncase CTRY_JAPAN53:\r\ncase CTRY_JAPAN54:\r\ncase CTRY_JAPAN55:\r\ncase CTRY_JAPAN56:\r\ncase CTRY_JAPAN57:\r\ncase CTRY_JAPAN58:\r\ncase CTRY_JAPAN59:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)\r\n{\r\nif (!config_enabled(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))\r\nreturn false;\r\nif (!dynamic_country_user_possible(reg))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline bool is_wwr_sku(u16 regd)\r\n{\r\nreturn ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&\r\n(((regd & WORLD_SKU_MASK) == WORLD_SKU_PREFIX) ||\r\n(regd == WORLD));\r\n}\r\nstatic u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)\r\n{\r\nreturn reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;\r\n}\r\nbool ath_is_world_regd(struct ath_regulatory *reg)\r\n{\r\nreturn is_wwr_sku(ath_regd_get_eepromRD(reg));\r\n}\r\nstatic const struct ieee80211_regdomain *ath_default_world_regdomain(void)\r\n{\r\nreturn &ath_world_regdom_64;\r\n}\r\nstatic const struct\r\nieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)\r\n{\r\nswitch (reg->regpair->reg_domain) {\r\ncase 0x60:\r\ncase 0x61:\r\ncase 0x62:\r\nreturn &ath_world_regdom_60_61_62;\r\ncase 0x63:\r\ncase 0x65:\r\nreturn &ath_world_regdom_63_65;\r\ncase 0x64:\r\nreturn &ath_world_regdom_64;\r\ncase 0x66:\r\ncase 0x69:\r\nreturn &ath_world_regdom_66_69;\r\ncase 0x67:\r\ncase 0x68:\r\ncase 0x6A:\r\ncase 0x6C:\r\nreturn &ath_world_regdom_67_68_6A_6C;\r\ndefault:\r\nWARN_ON(1);\r\nreturn ath_default_world_regdomain();\r\n}\r\n}\r\nbool ath_is_49ghz_allowed(u16 regdomain)\r\n{\r\nreturn regdomain == MKK9_MKKC;\r\n}\r\nstatic bool ath_is_radar_freq(u16 center_freq)\r\n{\r\nreturn (center_freq >= 5260 && center_freq <= 5700);\r\n}\r\nstatic void ath_force_clear_no_ir_chan(struct wiphy *wiphy,\r\nstruct ieee80211_channel *ch)\r\n{\r\nconst struct ieee80211_reg_rule *reg_rule;\r\nreg_rule = freq_reg_info(wiphy, MHZ_TO_KHZ(ch->center_freq));\r\nif (IS_ERR(reg_rule))\r\nreturn;\r\nif (!(reg_rule->flags & NL80211_RRF_NO_IR))\r\nif (ch->flags & IEEE80211_CHAN_NO_IR)\r\nch->flags &= ~IEEE80211_CHAN_NO_IR;\r\n}\r\nstatic void ath_force_clear_no_ir_freq(struct wiphy *wiphy, u16 center_freq)\r\n{\r\nstruct ieee80211_channel *ch;\r\nch = ieee80211_get_channel(wiphy, center_freq);\r\nif (!ch)\r\nreturn;\r\nath_force_clear_no_ir_chan(wiphy, ch);\r\n}\r\nstatic void ath_force_no_ir_chan(struct ieee80211_channel *ch)\r\n{\r\nch->flags |= IEEE80211_CHAN_NO_IR;\r\n}\r\nstatic void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)\r\n{\r\nstruct ieee80211_channel *ch;\r\nch = ieee80211_get_channel(wiphy, center_freq);\r\nif (!ch)\r\nreturn;\r\nath_force_no_ir_chan(ch);\r\n}\r\nstatic void\r\n__ath_reg_apply_beaconing_flags(struct wiphy *wiphy,\r\nstruct ath_regulatory *reg,\r\nenum nl80211_reg_initiator initiator,\r\nstruct ieee80211_channel *ch)\r\n{\r\nif (ath_is_radar_freq(ch->center_freq) ||\r\n(ch->flags & IEEE80211_CHAN_RADAR))\r\nreturn;\r\nswitch (initiator) {\r\ncase NL80211_REGDOM_SET_BY_COUNTRY_IE:\r\nath_force_clear_no_ir_chan(wiphy, ch);\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_USER:\r\nif (ath_reg_dyn_country_user_allow(reg))\r\nath_force_clear_no_ir_chan(wiphy, ch);\r\nbreak;\r\ndefault:\r\nif (ch->beacon_found)\r\nch->flags &= ~IEEE80211_CHAN_NO_IR;\r\n}\r\n}\r\nstatic void\r\nath_reg_apply_beaconing_flags(struct wiphy *wiphy,\r\nstruct ath_regulatory *reg,\r\nenum nl80211_reg_initiator initiator)\r\n{\r\nenum ieee80211_band band;\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch;\r\nunsigned int i;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nif (!wiphy->bands[band])\r\ncontinue;\r\nsband = wiphy->bands[band];\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nch = &sband->channels[i];\r\n__ath_reg_apply_beaconing_flags(wiphy, reg,\r\ninitiator, ch);\r\n}\r\n}\r\n}\r\nstatic void\r\nath_reg_apply_ir_flags(struct wiphy *wiphy,\r\nstruct ath_regulatory *reg,\r\nenum nl80211_reg_initiator initiator)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nsband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (!sband)\r\nreturn;\r\nswitch(initiator) {\r\ncase NL80211_REGDOM_SET_BY_COUNTRY_IE:\r\nath_force_clear_no_ir_freq(wiphy, 2467);\r\nath_force_clear_no_ir_freq(wiphy, 2472);\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_USER:\r\nif (!ath_reg_dyn_country_user_allow(reg))\r\nbreak;\r\nath_force_clear_no_ir_freq(wiphy, 2467);\r\nath_force_clear_no_ir_freq(wiphy, 2472);\r\nbreak;\r\ndefault:\r\nath_force_no_ir_freq(wiphy, 2467);\r\nath_force_no_ir_freq(wiphy, 2472);\r\n}\r\n}\r\nstatic void ath_reg_apply_radar_flags(struct wiphy *wiphy)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch;\r\nunsigned int i;\r\nif (!wiphy->bands[IEEE80211_BAND_5GHZ])\r\nreturn;\r\nsband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nch = &sband->channels[i];\r\nif (!ath_is_radar_freq(ch->center_freq))\r\ncontinue;\r\nif (!(ch->flags & IEEE80211_CHAN_DISABLED))\r\nch->flags |= IEEE80211_CHAN_RADAR |\r\nIEEE80211_CHAN_NO_IR;\r\n}\r\n}\r\nstatic void ath_reg_apply_world_flags(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator,\r\nstruct ath_regulatory *reg)\r\n{\r\nswitch (reg->regpair->reg_domain) {\r\ncase 0x60:\r\ncase 0x63:\r\ncase 0x66:\r\ncase 0x67:\r\ncase 0x6C:\r\nath_reg_apply_beaconing_flags(wiphy, reg, initiator);\r\nbreak;\r\ncase 0x68:\r\nath_reg_apply_beaconing_flags(wiphy, reg, initiator);\r\nath_reg_apply_ir_flags(wiphy, reg, initiator);\r\nbreak;\r\ndefault:\r\nif (ath_reg_dyn_country_user_allow(reg))\r\nath_reg_apply_beaconing_flags(wiphy, reg, initiator);\r\n}\r\n}\r\nstatic u16 ath_regd_find_country_by_name(char *alpha2)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\r\nif (!memcmp(allCountries[i].isoName, alpha2, 2))\r\nreturn allCountries[i].countryCode;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __ath_reg_dyn_country(struct wiphy *wiphy,\r\nstruct ath_regulatory *reg,\r\nstruct regulatory_request *request)\r\n{\r\nu16 country_code;\r\nif (request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\r\n!ath_is_world_regd(reg))\r\nreturn -EINVAL;\r\ncountry_code = ath_regd_find_country_by_name(request->alpha2);\r\nif (country_code == (u16) -1)\r\nreturn -EINVAL;\r\nreg->current_rd = COUNTRY_ERD_FLAG;\r\nreg->current_rd |= country_code;\r\n__ath_regd_init(reg);\r\nath_reg_apply_world_flags(wiphy, request->initiator, reg);\r\nreturn 0;\r\n}\r\nstatic void ath_reg_dyn_country(struct wiphy *wiphy,\r\nstruct ath_regulatory *reg,\r\nstruct regulatory_request *request)\r\n{\r\nif (__ath_reg_dyn_country(wiphy, reg, request))\r\nreturn;\r\nprintk(KERN_DEBUG "ath: regdomain 0x%0x "\r\n"dynamically updated by %s\n",\r\nreg->current_rd,\r\nreg_initiator_name(request->initiator));\r\n}\r\nvoid ath_reg_notifier_apply(struct wiphy *wiphy,\r\nstruct regulatory_request *request,\r\nstruct ath_regulatory *reg)\r\n{\r\nstruct ath_common *common = container_of(reg, struct ath_common,\r\nregulatory);\r\nath_reg_apply_radar_flags(wiphy);\r\nif (!request)\r\nreturn;\r\nreg->region = request->dfs_region;\r\nswitch (request->initiator) {\r\ncase NL80211_REGDOM_SET_BY_CORE:\r\nif (!ath_is_world_regd(&common->reg_world_copy))\r\nbreak;\r\nmemcpy(reg, &common->reg_world_copy,\r\nsizeof(struct ath_regulatory));\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_DRIVER:\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_USER:\r\nif (ath_reg_dyn_country_user_allow(reg))\r\nath_reg_dyn_country(wiphy, reg, request);\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_COUNTRY_IE:\r\nath_reg_dyn_country(wiphy, reg, request);\r\nbreak;\r\n}\r\n}\r\nstatic bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)\r\n{\r\nu16 rd = ath_regd_get_eepromRD(reg);\r\nint i;\r\nif (rd & COUNTRY_ERD_FLAG) {\r\nu16 cc = rd & ~COUNTRY_ERD_FLAG;\r\nprintk(KERN_DEBUG\r\n"ath: EEPROM indicates we should expect "\r\n"a country code\n");\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++)\r\nif (allCountries[i].countryCode == cc)\r\nreturn true;\r\n} else {\r\nif (rd != CTRY_DEFAULT)\r\nprintk(KERN_DEBUG "ath: EEPROM indicates we "\r\n"should expect a direct regpair map\n");\r\nfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)\r\nif (regDomainPairs[i].reg_domain == rd)\r\nreturn true;\r\n}\r\nprintk(KERN_DEBUG\r\n"ath: invalid regulatory domain/country code 0x%x\n", rd);\r\nreturn false;\r\n}\r\nstatic struct country_code_to_enum_rd*\r\nath_regd_find_country(u16 countryCode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\r\nif (allCountries[i].countryCode == countryCode)\r\nreturn &allCountries[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct country_code_to_enum_rd*\r\nath_regd_find_country_by_rd(int regdmn)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\r\nif (allCountries[i].regDmnEnum == regdmn)\r\nreturn &allCountries[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic u16 ath_regd_get_default_country(u16 rd)\r\n{\r\nif (rd & COUNTRY_ERD_FLAG) {\r\nstruct country_code_to_enum_rd *country = NULL;\r\nu16 cc = rd & ~COUNTRY_ERD_FLAG;\r\ncountry = ath_regd_find_country(cc);\r\nif (country != NULL)\r\nreturn cc;\r\n}\r\nreturn CTRY_DEFAULT;\r\n}\r\nstatic struct reg_dmn_pair_mapping*\r\nath_get_regpair(int regdmn)\r\n{\r\nint i;\r\nif (regdmn == NO_ENUMRD)\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {\r\nif (regDomainPairs[i].reg_domain == regdmn)\r\nreturn &regDomainPairs[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nath_regd_init_wiphy(struct ath_regulatory *reg,\r\nstruct wiphy *wiphy,\r\nvoid (*reg_notifier)(struct wiphy *wiphy,\r\nstruct regulatory_request *request))\r\n{\r\nconst struct ieee80211_regdomain *regd;\r\nwiphy->reg_notifier = reg_notifier;\r\nwiphy->regulatory_flags |= REGULATORY_STRICT_REG |\r\nREGULATORY_CUSTOM_REG;\r\nif (ath_is_world_regd(reg)) {\r\nregd = ath_world_regdomain(reg);\r\nwiphy->regulatory_flags |= REGULATORY_COUNTRY_IE_FOLLOW_POWER;\r\n} else {\r\nregd = ath_default_world_regdomain();\r\n}\r\nwiphy_apply_custom_regulatory(wiphy, regd);\r\nath_reg_apply_radar_flags(wiphy);\r\nath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);\r\nreturn 0;\r\n}\r\nstatic void ath_regd_sanitize(struct ath_regulatory *reg)\r\n{\r\nif (reg->current_rd != COUNTRY_ERD_FLAG)\r\nreturn;\r\nprintk(KERN_DEBUG "ath: EEPROM regdomain sanitized\n");\r\nreg->current_rd = 0x64;\r\n}\r\nstatic int __ath_regd_init(struct ath_regulatory *reg)\r\n{\r\nstruct country_code_to_enum_rd *country = NULL;\r\nu16 regdmn;\r\nif (!reg)\r\nreturn -EINVAL;\r\nath_regd_sanitize(reg);\r\nprintk(KERN_DEBUG "ath: EEPROM regdomain: 0x%0x\n", reg->current_rd);\r\nif (!ath_regd_is_eeprom_valid(reg)) {\r\npr_err("Invalid EEPROM contents\n");\r\nreturn -EINVAL;\r\n}\r\nregdmn = ath_regd_get_eepromRD(reg);\r\nreg->country_code = ath_regd_get_default_country(regdmn);\r\nif (reg->country_code == CTRY_DEFAULT &&\r\nregdmn == CTRY_DEFAULT) {\r\nprintk(KERN_DEBUG "ath: EEPROM indicates default "\r\n"country code should be used\n");\r\nreg->country_code = CTRY_UNITED_STATES;\r\n}\r\nif (reg->country_code == CTRY_DEFAULT) {\r\ncountry = NULL;\r\n} else {\r\nprintk(KERN_DEBUG "ath: doing EEPROM country->regdmn "\r\n"map search\n");\r\ncountry = ath_regd_find_country(reg->country_code);\r\nif (country == NULL) {\r\nprintk(KERN_DEBUG\r\n"ath: no valid country maps found for "\r\n"country code: 0x%0x\n",\r\nreg->country_code);\r\nreturn -EINVAL;\r\n} else {\r\nregdmn = country->regDmnEnum;\r\nprintk(KERN_DEBUG "ath: country maps to "\r\n"regdmn code: 0x%0x\n",\r\nregdmn);\r\n}\r\n}\r\nreg->regpair = ath_get_regpair(regdmn);\r\nif (!reg->regpair) {\r\nprintk(KERN_DEBUG "ath: "\r\n"No regulatory domain pair found, cannot continue\n");\r\nreturn -EINVAL;\r\n}\r\nif (!country)\r\ncountry = ath_regd_find_country_by_rd(regdmn);\r\nif (country) {\r\nreg->alpha2[0] = country->isoName[0];\r\nreg->alpha2[1] = country->isoName[1];\r\n} else {\r\nreg->alpha2[0] = '0';\r\nreg->alpha2[1] = '0';\r\n}\r\nprintk(KERN_DEBUG "ath: Country alpha2 being used: %c%c\n",\r\nreg->alpha2[0], reg->alpha2[1]);\r\nprintk(KERN_DEBUG "ath: Regpair used: 0x%0x\n",\r\nreg->regpair->reg_domain);\r\nreturn 0;\r\n}\r\nint\r\nath_regd_init(struct ath_regulatory *reg,\r\nstruct wiphy *wiphy,\r\nvoid (*reg_notifier)(struct wiphy *wiphy,\r\nstruct regulatory_request *request))\r\n{\r\nstruct ath_common *common = container_of(reg, struct ath_common,\r\nregulatory);\r\nint r;\r\nr = __ath_regd_init(reg);\r\nif (r)\r\nreturn r;\r\nif (ath_is_world_regd(reg))\r\nmemcpy(&common->reg_world_copy, reg,\r\nsizeof(struct ath_regulatory));\r\nath_regd_init_wiphy(reg, wiphy, reg_notifier);\r\nreturn 0;\r\n}\r\nu32 ath_regd_get_band_ctl(struct ath_regulatory *reg,\r\nenum ieee80211_band band)\r\n{\r\nif (!reg->regpair ||\r\n(reg->country_code == CTRY_DEFAULT &&\r\nis_wwr_sku(ath_regd_get_eepromRD(reg)))) {\r\nreturn SD_NO_CTL;\r\n}\r\nif (ath_regd_get_eepromRD(reg) == CTRY_DEFAULT) {\r\nswitch (reg->region) {\r\ncase NL80211_DFS_FCC:\r\nreturn CTL_FCC;\r\ncase NL80211_DFS_ETSI:\r\nreturn CTL_ETSI;\r\ncase NL80211_DFS_JP:\r\nreturn CTL_MKK;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nswitch (band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nreturn reg->regpair->reg_2ghz_ctl;\r\ncase IEEE80211_BAND_5GHZ:\r\nreturn reg->regpair->reg_5ghz_ctl;\r\ndefault:\r\nreturn NO_CTL;\r\n}\r\n}
