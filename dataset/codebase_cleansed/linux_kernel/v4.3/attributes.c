int __init hfsplus_create_attr_tree_cache(void)\r\n{\r\nif (hfsplus_attr_tree_cachep)\r\nreturn -EEXIST;\r\nhfsplus_attr_tree_cachep =\r\nkmem_cache_create("hfsplus_attr_cache",\r\nsizeof(hfsplus_attr_entry), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!hfsplus_attr_tree_cachep)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid hfsplus_destroy_attr_tree_cache(void)\r\n{\r\nkmem_cache_destroy(hfsplus_attr_tree_cachep);\r\n}\r\nint hfsplus_attr_bin_cmp_key(const hfsplus_btree_key *k1,\r\nconst hfsplus_btree_key *k2)\r\n{\r\n__be32 k1_cnid, k2_cnid;\r\nk1_cnid = k1->attr.cnid;\r\nk2_cnid = k2->attr.cnid;\r\nif (k1_cnid != k2_cnid)\r\nreturn be32_to_cpu(k1_cnid) < be32_to_cpu(k2_cnid) ? -1 : 1;\r\nreturn hfsplus_strcmp(\r\n(const struct hfsplus_unistr *)&k1->attr.key_name,\r\n(const struct hfsplus_unistr *)&k2->attr.key_name);\r\n}\r\nint hfsplus_attr_build_key(struct super_block *sb, hfsplus_btree_key *key,\r\nu32 cnid, const char *name)\r\n{\r\nint len;\r\nmemset(key, 0, sizeof(struct hfsplus_attr_key));\r\nkey->attr.cnid = cpu_to_be32(cnid);\r\nif (name) {\r\nint res = hfsplus_asc2uni(sb,\r\n(struct hfsplus_unistr *)&key->attr.key_name,\r\nHFSPLUS_ATTR_MAX_STRLEN, name, strlen(name));\r\nif (res)\r\nreturn res;\r\nlen = be16_to_cpu(key->attr.key_name.length);\r\n} else {\r\nkey->attr.key_name.length = 0;\r\nlen = 0;\r\n}\r\nkey->key_len =\r\ncpu_to_be16(offsetof(struct hfsplus_attr_key, key_name) +\r\n2 * len);\r\nreturn 0;\r\n}\r\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\r\n{\r\nreturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\r\n}\r\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\r\n{\r\nif (entry)\r\nkmem_cache_free(hfsplus_attr_tree_cachep, entry);\r\n}\r\nstatic int hfsplus_attr_build_record(hfsplus_attr_entry *entry, int record_type,\r\nu32 cnid, const void *value, size_t size)\r\n{\r\nif (record_type == HFSPLUS_ATTR_FORK_DATA) {\r\nmemset(entry, 0, sizeof(*entry));\r\nreturn sizeof(struct hfsplus_attr_fork_data);\r\n} else if (record_type == HFSPLUS_ATTR_EXTENTS) {\r\nmemset(entry, 0, sizeof(*entry));\r\nreturn sizeof(struct hfsplus_attr_extents);\r\n} else if (record_type == HFSPLUS_ATTR_INLINE_DATA) {\r\nu16 len;\r\nmemset(entry, 0, sizeof(struct hfsplus_attr_inline_data));\r\nentry->inline_data.record_type = cpu_to_be32(record_type);\r\nif (size <= HFSPLUS_MAX_INLINE_DATA_SIZE)\r\nlen = size;\r\nelse\r\nreturn HFSPLUS_INVALID_ATTR_RECORD;\r\nentry->inline_data.length = cpu_to_be16(len);\r\nmemcpy(entry->inline_data.raw_bytes, value, len);\r\nlen = round_up(len, 2);\r\nreturn offsetof(struct hfsplus_attr_inline_data, raw_bytes) +\r\nlen;\r\n} else\r\nmemset(entry, 0, sizeof(*entry));\r\nreturn HFSPLUS_INVALID_ATTR_RECORD;\r\n}\r\nint hfsplus_find_attr(struct super_block *sb, u32 cnid,\r\nconst char *name, struct hfs_find_data *fd)\r\n{\r\nint err = 0;\r\nhfs_dbg(ATTR_MOD, "find_attr: %s,%d\n", name ? name : NULL, cnid);\r\nif (!HFSPLUS_SB(sb)->attr_tree) {\r\npr_err("attributes file doesn't exist\n");\r\nreturn -EINVAL;\r\n}\r\nif (name) {\r\nerr = hfsplus_attr_build_key(sb, fd->search_key, cnid, name);\r\nif (err)\r\ngoto failed_find_attr;\r\nerr = hfs_brec_find(fd, hfs_find_rec_by_key);\r\nif (err)\r\ngoto failed_find_attr;\r\n} else {\r\nerr = hfsplus_attr_build_key(sb, fd->search_key, cnid, NULL);\r\nif (err)\r\ngoto failed_find_attr;\r\nerr = hfs_brec_find(fd, hfs_find_1st_rec_by_cnid);\r\nif (err)\r\ngoto failed_find_attr;\r\n}\r\nfailed_find_attr:\r\nreturn err;\r\n}\r\nint hfsplus_attr_exists(struct inode *inode, const char *name)\r\n{\r\nint err = 0;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfs_find_data fd;\r\nif (!HFSPLUS_SB(sb)->attr_tree)\r\nreturn 0;\r\nerr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\r\nif (err)\r\nreturn 0;\r\nerr = hfsplus_find_attr(sb, inode->i_ino, name, &fd);\r\nif (err)\r\ngoto attr_not_found;\r\nhfs_find_exit(&fd);\r\nreturn 1;\r\nattr_not_found:\r\nhfs_find_exit(&fd);\r\nreturn 0;\r\n}\r\nint hfsplus_create_attr(struct inode *inode,\r\nconst char *name,\r\nconst void *value, size_t size)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfs_find_data fd;\r\nhfsplus_attr_entry *entry_ptr;\r\nint entry_size;\r\nint err;\r\nhfs_dbg(ATTR_MOD, "create_attr: %s,%ld\n",\r\nname ? name : NULL, inode->i_ino);\r\nif (!HFSPLUS_SB(sb)->attr_tree) {\r\npr_err("attributes file doesn't exist\n");\r\nreturn -EINVAL;\r\n}\r\nentry_ptr = hfsplus_alloc_attr_entry();\r\nif (!entry_ptr)\r\nreturn -ENOMEM;\r\nerr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\r\nif (err)\r\ngoto failed_init_create_attr;\r\nif (name) {\r\nerr = hfsplus_attr_build_key(sb, fd.search_key,\r\ninode->i_ino, name);\r\nif (err)\r\ngoto failed_create_attr;\r\n} else {\r\nerr = -EINVAL;\r\ngoto failed_create_attr;\r\n}\r\nentry_size = hfsplus_attr_build_record(entry_ptr,\r\nHFSPLUS_ATTR_INLINE_DATA,\r\ninode->i_ino,\r\nvalue, size);\r\nif (entry_size == HFSPLUS_INVALID_ATTR_RECORD) {\r\nerr = -EINVAL;\r\ngoto failed_create_attr;\r\n}\r\nerr = hfs_brec_find(&fd, hfs_find_rec_by_key);\r\nif (err != -ENOENT) {\r\nif (!err)\r\nerr = -EEXIST;\r\ngoto failed_create_attr;\r\n}\r\nerr = hfs_brec_insert(&fd, entry_ptr, entry_size);\r\nif (err)\r\ngoto failed_create_attr;\r\nhfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\r\nfailed_create_attr:\r\nhfs_find_exit(&fd);\r\nfailed_init_create_attr:\r\nhfsplus_destroy_attr_entry(entry_ptr);\r\nreturn err;\r\n}\r\nstatic int __hfsplus_delete_attr(struct inode *inode, u32 cnid,\r\nstruct hfs_find_data *fd)\r\n{\r\nint err = 0;\r\n__be32 found_cnid, record_type;\r\nhfs_bnode_read(fd->bnode, &found_cnid,\r\nfd->keyoffset +\r\noffsetof(struct hfsplus_attr_key, cnid),\r\nsizeof(__be32));\r\nif (cnid != be32_to_cpu(found_cnid))\r\nreturn -ENOENT;\r\nhfs_bnode_read(fd->bnode, &record_type,\r\nfd->entryoffset, sizeof(record_type));\r\nswitch (be32_to_cpu(record_type)) {\r\ncase HFSPLUS_ATTR_INLINE_DATA:\r\nbreak;\r\ncase HFSPLUS_ATTR_FORK_DATA:\r\ncase HFSPLUS_ATTR_EXTENTS:\r\npr_err("only inline data xattr are supported\n");\r\nreturn -EOPNOTSUPP;\r\ndefault:\r\npr_err("invalid extended attribute record\n");\r\nreturn -ENOENT;\r\n}\r\nerr = hfs_brec_remove(fd);\r\nif (err)\r\nreturn err;\r\nhfsplus_mark_inode_dirty(inode, HFSPLUS_I_ATTR_DIRTY);\r\nreturn err;\r\n}\r\nint hfsplus_delete_attr(struct inode *inode, const char *name)\r\n{\r\nint err = 0;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfs_find_data fd;\r\nhfs_dbg(ATTR_MOD, "delete_attr: %s,%ld\n",\r\nname ? name : NULL, inode->i_ino);\r\nif (!HFSPLUS_SB(sb)->attr_tree) {\r\npr_err("attributes file doesn't exist\n");\r\nreturn -EINVAL;\r\n}\r\nerr = hfs_find_init(HFSPLUS_SB(sb)->attr_tree, &fd);\r\nif (err)\r\nreturn err;\r\nif (name) {\r\nerr = hfsplus_attr_build_key(sb, fd.search_key,\r\ninode->i_ino, name);\r\nif (err)\r\ngoto out;\r\n} else {\r\npr_err("invalid extended attribute name\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = hfs_brec_find(&fd, hfs_find_rec_by_key);\r\nif (err)\r\ngoto out;\r\nerr = __hfsplus_delete_attr(inode, inode->i_ino, &fd);\r\nif (err)\r\ngoto out;\r\nout:\r\nhfs_find_exit(&fd);\r\nreturn err;\r\n}\r\nint hfsplus_delete_all_attrs(struct inode *dir, u32 cnid)\r\n{\r\nint err = 0;\r\nstruct hfs_find_data fd;\r\nhfs_dbg(ATTR_MOD, "delete_all_attrs: %d\n", cnid);\r\nif (!HFSPLUS_SB(dir->i_sb)->attr_tree) {\r\npr_err("attributes file doesn't exist\n");\r\nreturn -EINVAL;\r\n}\r\nerr = hfs_find_init(HFSPLUS_SB(dir->i_sb)->attr_tree, &fd);\r\nif (err)\r\nreturn err;\r\nfor (;;) {\r\nerr = hfsplus_find_attr(dir->i_sb, cnid, NULL, &fd);\r\nif (err) {\r\nif (err != -ENOENT)\r\npr_err("xattr search failed\n");\r\ngoto end_delete_all;\r\n}\r\nerr = __hfsplus_delete_attr(dir, cnid, &fd);\r\nif (err)\r\ngoto end_delete_all;\r\n}\r\nend_delete_all:\r\nhfs_find_exit(&fd);\r\nreturn err;\r\n}
