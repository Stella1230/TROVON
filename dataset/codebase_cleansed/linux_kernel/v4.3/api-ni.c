static char *\r\nlnet_get_routes(void)\r\n{\r\nreturn routes;\r\n}\r\nstatic char *\r\nlnet_get_networks(void)\r\n{\r\nchar *nets;\r\nint rc;\r\nif (*networks != 0 && *ip2nets != 0) {\r\nLCONSOLE_ERROR_MSG(0x101, "Please specify EITHER 'networks' or 'ip2nets' but not both at once\n");\r\nreturn NULL;\r\n}\r\nif (*ip2nets != 0) {\r\nrc = lnet_parse_ip2nets(&nets, ip2nets);\r\nreturn (rc == 0) ? nets : NULL;\r\n}\r\nif (*networks != 0)\r\nreturn networks;\r\nreturn "tcp";\r\n}\r\nstatic void\r\nlnet_init_locks(void)\r\n{\r\nspin_lock_init(&the_lnet.ln_eq_wait_lock);\r\ninit_waitqueue_head(&the_lnet.ln_eq_waitq);\r\nmutex_init(&the_lnet.ln_lnd_mutex);\r\nmutex_init(&the_lnet.ln_api_mutex);\r\n}\r\nstatic int\r\nlnet_create_remote_nets_table(void)\r\n{\r\nint i;\r\nstruct list_head *hash;\r\nLASSERT(the_lnet.ln_remote_nets_hash == NULL);\r\nLASSERT(the_lnet.ln_remote_nets_hbits > 0);\r\nLIBCFS_ALLOC(hash, LNET_REMOTE_NETS_HASH_SIZE * sizeof(*hash));\r\nif (hash == NULL) {\r\nCERROR("Failed to create remote nets hash table\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < LNET_REMOTE_NETS_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&hash[i]);\r\nthe_lnet.ln_remote_nets_hash = hash;\r\nreturn 0;\r\n}\r\nstatic void\r\nlnet_destroy_remote_nets_table(void)\r\n{\r\nint i;\r\nif (the_lnet.ln_remote_nets_hash == NULL)\r\nreturn;\r\nfor (i = 0; i < LNET_REMOTE_NETS_HASH_SIZE; i++)\r\nLASSERT(list_empty(&the_lnet.ln_remote_nets_hash[i]));\r\nLIBCFS_FREE(the_lnet.ln_remote_nets_hash,\r\nLNET_REMOTE_NETS_HASH_SIZE *\r\nsizeof(the_lnet.ln_remote_nets_hash[0]));\r\nthe_lnet.ln_remote_nets_hash = NULL;\r\n}\r\nstatic void\r\nlnet_destroy_locks(void)\r\n{\r\nif (the_lnet.ln_res_lock != NULL) {\r\ncfs_percpt_lock_free(the_lnet.ln_res_lock);\r\nthe_lnet.ln_res_lock = NULL;\r\n}\r\nif (the_lnet.ln_net_lock != NULL) {\r\ncfs_percpt_lock_free(the_lnet.ln_net_lock);\r\nthe_lnet.ln_net_lock = NULL;\r\n}\r\n}\r\nstatic int\r\nlnet_create_locks(void)\r\n{\r\nlnet_init_locks();\r\nthe_lnet.ln_res_lock = cfs_percpt_lock_alloc(lnet_cpt_table());\r\nif (the_lnet.ln_res_lock == NULL)\r\ngoto failed;\r\nthe_lnet.ln_net_lock = cfs_percpt_lock_alloc(lnet_cpt_table());\r\nif (the_lnet.ln_net_lock == NULL)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\nlnet_destroy_locks();\r\nreturn -ENOMEM;\r\n}\r\nstatic void lnet_assert_wire_constants(void)\r\n{\r\nCLASSERT(LNET_PROTO_TCP_MAGIC == 0xeebc0ded);\r\nCLASSERT(LNET_PROTO_TCP_VERSION_MAJOR == 1);\r\nCLASSERT(LNET_PROTO_TCP_VERSION_MINOR == 0);\r\nCLASSERT(LNET_MSG_ACK == 0);\r\nCLASSERT(LNET_MSG_PUT == 1);\r\nCLASSERT(LNET_MSG_GET == 2);\r\nCLASSERT(LNET_MSG_REPLY == 3);\r\nCLASSERT(LNET_MSG_HELLO == 4);\r\nCLASSERT((int)sizeof(lnet_handle_wire_t) == 16);\r\nCLASSERT((int)offsetof(lnet_handle_wire_t, wh_interface_cookie) == 0);\r\nCLASSERT((int)sizeof(((lnet_handle_wire_t *)0)->wh_interface_cookie) == 8);\r\nCLASSERT((int)offsetof(lnet_handle_wire_t, wh_object_cookie) == 8);\r\nCLASSERT((int)sizeof(((lnet_handle_wire_t *)0)->wh_object_cookie) == 8);\r\nCLASSERT((int)sizeof(lnet_magicversion_t) == 8);\r\nCLASSERT((int)offsetof(lnet_magicversion_t, magic) == 0);\r\nCLASSERT((int)sizeof(((lnet_magicversion_t *)0)->magic) == 4);\r\nCLASSERT((int)offsetof(lnet_magicversion_t, version_major) == 4);\r\nCLASSERT((int)sizeof(((lnet_magicversion_t *)0)->version_major) == 2);\r\nCLASSERT((int)offsetof(lnet_magicversion_t, version_minor) == 6);\r\nCLASSERT((int)sizeof(((lnet_magicversion_t *)0)->version_minor) == 2);\r\nCLASSERT((int)sizeof(lnet_hdr_t) == 72);\r\nCLASSERT((int)offsetof(lnet_hdr_t, dest_nid) == 0);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->dest_nid) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, src_nid) == 8);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->src_nid) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, dest_pid) == 16);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->dest_pid) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, src_pid) == 20);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->src_pid) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, type) == 24);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->type) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, payload_length) == 28);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->payload_length) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg) == 32);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg) == 40);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.ack.dst_wmd) == 32);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.ack.dst_wmd) == 16);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.ack.match_bits) == 48);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.ack.match_bits) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.ack.mlength) == 56);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.ack.mlength) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.put.ack_wmd) == 32);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.put.ack_wmd) == 16);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.put.match_bits) == 48);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.put.match_bits) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.put.hdr_data) == 56);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.put.hdr_data) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.put.ptl_index) == 64);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.put.ptl_index) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.put.offset) == 68);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.put.offset) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.get.return_wmd) == 32);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.get.return_wmd) == 16);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.get.match_bits) == 48);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.get.match_bits) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.get.ptl_index) == 56);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.get.ptl_index) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.get.src_offset) == 60);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.get.src_offset) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.get.sink_length) == 64);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.get.sink_length) == 4);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.reply.dst_wmd) == 32);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.reply.dst_wmd) == 16);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.hello.incarnation) == 32);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.hello.incarnation) == 8);\r\nCLASSERT((int)offsetof(lnet_hdr_t, msg.hello.type) == 40);\r\nCLASSERT((int)sizeof(((lnet_hdr_t *)0)->msg.hello.type) == 4);\r\n}\r\nstatic lnd_t *\r\nlnet_find_lnd_by_type(int type)\r\n{\r\nlnd_t *lnd;\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, &the_lnet.ln_lnds) {\r\nlnd = list_entry(tmp, lnd_t, lnd_list);\r\nif ((int)lnd->lnd_type == type)\r\nreturn lnd;\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\nlnet_register_lnd(lnd_t *lnd)\r\n{\r\nmutex_lock(&the_lnet.ln_lnd_mutex);\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(libcfs_isknown_lnd(lnd->lnd_type));\r\nLASSERT(lnet_find_lnd_by_type(lnd->lnd_type) == NULL);\r\nlist_add_tail(&lnd->lnd_list, &the_lnet.ln_lnds);\r\nlnd->lnd_refcount = 0;\r\nCDEBUG(D_NET, "%s LND registered\n", libcfs_lnd2str(lnd->lnd_type));\r\nmutex_unlock(&the_lnet.ln_lnd_mutex);\r\n}\r\nvoid\r\nlnet_unregister_lnd(lnd_t *lnd)\r\n{\r\nmutex_lock(&the_lnet.ln_lnd_mutex);\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(lnet_find_lnd_by_type(lnd->lnd_type) == lnd);\r\nLASSERT(lnd->lnd_refcount == 0);\r\nlist_del(&lnd->lnd_list);\r\nCDEBUG(D_NET, "%s LND unregistered\n", libcfs_lnd2str(lnd->lnd_type));\r\nmutex_unlock(&the_lnet.ln_lnd_mutex);\r\n}\r\nvoid\r\nlnet_counters_get(lnet_counters_t *counters)\r\n{\r\nlnet_counters_t *ctr;\r\nint i;\r\nmemset(counters, 0, sizeof(*counters));\r\nlnet_net_lock(LNET_LOCK_EX);\r\ncfs_percpt_for_each(ctr, i, the_lnet.ln_counters) {\r\ncounters->msgs_max += ctr->msgs_max;\r\ncounters->msgs_alloc += ctr->msgs_alloc;\r\ncounters->errors += ctr->errors;\r\ncounters->send_count += ctr->send_count;\r\ncounters->recv_count += ctr->recv_count;\r\ncounters->route_count += ctr->route_count;\r\ncounters->drop_count += ctr->drop_count;\r\ncounters->send_length += ctr->send_length;\r\ncounters->recv_length += ctr->recv_length;\r\ncounters->route_length += ctr->route_length;\r\ncounters->drop_length += ctr->drop_length;\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n}\r\nvoid\r\nlnet_counters_reset(void)\r\n{\r\nlnet_counters_t *counters;\r\nint i;\r\nlnet_net_lock(LNET_LOCK_EX);\r\ncfs_percpt_for_each(counters, i, the_lnet.ln_counters)\r\nmemset(counters, 0, sizeof(lnet_counters_t));\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n}\r\nstatic __u64\r\nlnet_create_interface_cookie(void)\r\n{\r\nreturn ktime_get_ns();\r\n}\r\nstatic char *\r\nlnet_res_type2str(int type)\r\n{\r\nswitch (type) {\r\ndefault:\r\nLBUG();\r\ncase LNET_COOKIE_TYPE_MD:\r\nreturn "MD";\r\ncase LNET_COOKIE_TYPE_ME:\r\nreturn "ME";\r\ncase LNET_COOKIE_TYPE_EQ:\r\nreturn "EQ";\r\n}\r\n}\r\nstatic void\r\nlnet_res_container_cleanup(struct lnet_res_container *rec)\r\n{\r\nint count = 0;\r\nif (rec->rec_type == 0)\r\nreturn;\r\nwhile (!list_empty(&rec->rec_active)) {\r\nstruct list_head *e = rec->rec_active.next;\r\nlist_del_init(e);\r\nif (rec->rec_type == LNET_COOKIE_TYPE_EQ) {\r\nlnet_eq_free(list_entry(e, lnet_eq_t, eq_list));\r\n} else if (rec->rec_type == LNET_COOKIE_TYPE_MD) {\r\nlnet_md_free(list_entry(e, lnet_libmd_t, md_list));\r\n} else {\r\nLBUG();\r\n}\r\ncount++;\r\n}\r\nif (count > 0) {\r\nCERROR("%d active elements on exit of %s container\n",\r\ncount, lnet_res_type2str(rec->rec_type));\r\n}\r\nif (rec->rec_lh_hash != NULL) {\r\nLIBCFS_FREE(rec->rec_lh_hash,\r\nLNET_LH_HASH_SIZE * sizeof(rec->rec_lh_hash[0]));\r\nrec->rec_lh_hash = NULL;\r\n}\r\nrec->rec_type = 0;\r\n}\r\nstatic int\r\nlnet_res_container_setup(struct lnet_res_container *rec, int cpt, int type)\r\n{\r\nint rc = 0;\r\nint i;\r\nLASSERT(rec->rec_type == 0);\r\nrec->rec_type = type;\r\nINIT_LIST_HEAD(&rec->rec_active);\r\nrec->rec_lh_cookie = (cpt << LNET_COOKIE_TYPE_BITS) | type;\r\nLIBCFS_CPT_ALLOC(rec->rec_lh_hash, lnet_cpt_table(), cpt,\r\nLNET_LH_HASH_SIZE * sizeof(rec->rec_lh_hash[0]));\r\nif (rec->rec_lh_hash == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < LNET_LH_HASH_SIZE; i++)\r\nINIT_LIST_HEAD(&rec->rec_lh_hash[i]);\r\nreturn 0;\r\nout:\r\nCERROR("Failed to setup %s resource container\n",\r\nlnet_res_type2str(type));\r\nlnet_res_container_cleanup(rec);\r\nreturn rc;\r\n}\r\nstatic void\r\nlnet_res_containers_destroy(struct lnet_res_container **recs)\r\n{\r\nstruct lnet_res_container *rec;\r\nint i;\r\ncfs_percpt_for_each(rec, i, recs)\r\nlnet_res_container_cleanup(rec);\r\ncfs_percpt_free(recs);\r\n}\r\nstatic struct lnet_res_container **\r\nlnet_res_containers_create(int type)\r\n{\r\nstruct lnet_res_container **recs;\r\nstruct lnet_res_container *rec;\r\nint rc;\r\nint i;\r\nrecs = cfs_percpt_alloc(lnet_cpt_table(), sizeof(*rec));\r\nif (recs == NULL) {\r\nCERROR("Failed to allocate %s resource containers\n",\r\nlnet_res_type2str(type));\r\nreturn NULL;\r\n}\r\ncfs_percpt_for_each(rec, i, recs) {\r\nrc = lnet_res_container_setup(rec, i, type);\r\nif (rc != 0) {\r\nlnet_res_containers_destroy(recs);\r\nreturn NULL;\r\n}\r\n}\r\nreturn recs;\r\n}\r\nlnet_libhandle_t *\r\nlnet_res_lh_lookup(struct lnet_res_container *rec, __u64 cookie)\r\n{\r\nstruct list_head *head;\r\nlnet_libhandle_t *lh;\r\nunsigned int hash;\r\nif ((cookie & LNET_COOKIE_MASK) != rec->rec_type)\r\nreturn NULL;\r\nhash = cookie >> (LNET_COOKIE_TYPE_BITS + LNET_CPT_BITS);\r\nhead = &rec->rec_lh_hash[hash & LNET_LH_HASH_MASK];\r\nlist_for_each_entry(lh, head, lh_hash_chain) {\r\nif (lh->lh_cookie == cookie)\r\nreturn lh;\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\nlnet_res_lh_initialize(struct lnet_res_container *rec, lnet_libhandle_t *lh)\r\n{\r\nunsigned int ibits = LNET_COOKIE_TYPE_BITS + LNET_CPT_BITS;\r\nunsigned int hash;\r\nlh->lh_cookie = rec->rec_lh_cookie;\r\nrec->rec_lh_cookie += 1 << ibits;\r\nhash = (lh->lh_cookie >> ibits) & LNET_LH_HASH_MASK;\r\nlist_add(&lh->lh_hash_chain, &rec->rec_lh_hash[hash]);\r\n}\r\nstatic int\r\nlnet_prepare(lnet_pid_t requested_pid)\r\n{\r\nstruct lnet_res_container **recs;\r\nint rc = 0;\r\nLASSERT(the_lnet.ln_refcount == 0);\r\nthe_lnet.ln_routing = 0;\r\nLASSERT((requested_pid & LNET_PID_USERFLAG) == 0);\r\nthe_lnet.ln_pid = requested_pid;\r\nINIT_LIST_HEAD(&the_lnet.ln_test_peers);\r\nINIT_LIST_HEAD(&the_lnet.ln_nis);\r\nINIT_LIST_HEAD(&the_lnet.ln_nis_cpt);\r\nINIT_LIST_HEAD(&the_lnet.ln_nis_zombie);\r\nINIT_LIST_HEAD(&the_lnet.ln_routers);\r\nrc = lnet_create_remote_nets_table();\r\nif (rc != 0)\r\ngoto failed;\r\nthe_lnet.ln_interface_cookie = lnet_create_interface_cookie();\r\nthe_lnet.ln_counters = cfs_percpt_alloc(lnet_cpt_table(),\r\nsizeof(lnet_counters_t));\r\nif (the_lnet.ln_counters == NULL) {\r\nCERROR("Failed to allocate counters for LNet\n");\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nrc = lnet_peer_tables_create();\r\nif (rc != 0)\r\ngoto failed;\r\nrc = lnet_msg_containers_create();\r\nif (rc != 0)\r\ngoto failed;\r\nrc = lnet_res_container_setup(&the_lnet.ln_eq_container, 0,\r\nLNET_COOKIE_TYPE_EQ);\r\nif (rc != 0)\r\ngoto failed;\r\nrecs = lnet_res_containers_create(LNET_COOKIE_TYPE_ME);\r\nif (recs == NULL) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nthe_lnet.ln_me_containers = recs;\r\nrecs = lnet_res_containers_create(LNET_COOKIE_TYPE_MD);\r\nif (recs == NULL) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nthe_lnet.ln_md_containers = recs;\r\nrc = lnet_portals_create();\r\nif (rc != 0) {\r\nCERROR("Failed to create portals for LNet: %d\n", rc);\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nlnet_unprepare();\r\nreturn rc;\r\n}\r\nint\r\nlnet_unprepare(void)\r\n{\r\nlnet_fail_nid(LNET_NID_ANY, 0);\r\nLASSERT(the_lnet.ln_refcount == 0);\r\nLASSERT(list_empty(&the_lnet.ln_test_peers));\r\nLASSERT(list_empty(&the_lnet.ln_nis));\r\nLASSERT(list_empty(&the_lnet.ln_nis_cpt));\r\nLASSERT(list_empty(&the_lnet.ln_nis_zombie));\r\nlnet_portals_destroy();\r\nif (the_lnet.ln_md_containers != NULL) {\r\nlnet_res_containers_destroy(the_lnet.ln_md_containers);\r\nthe_lnet.ln_md_containers = NULL;\r\n}\r\nif (the_lnet.ln_me_containers != NULL) {\r\nlnet_res_containers_destroy(the_lnet.ln_me_containers);\r\nthe_lnet.ln_me_containers = NULL;\r\n}\r\nlnet_res_container_cleanup(&the_lnet.ln_eq_container);\r\nlnet_msg_containers_destroy();\r\nlnet_peer_tables_destroy();\r\nlnet_rtrpools_free();\r\nif (the_lnet.ln_counters != NULL) {\r\ncfs_percpt_free(the_lnet.ln_counters);\r\nthe_lnet.ln_counters = NULL;\r\n}\r\nlnet_destroy_remote_nets_table();\r\nreturn 0;\r\n}\r\nlnet_ni_t *\r\nlnet_net2ni_locked(__u32 net, int cpt)\r\n{\r\nstruct list_head *tmp;\r\nlnet_ni_t *ni;\r\nLASSERT(cpt != LNET_LOCK_EX);\r\nlist_for_each(tmp, &the_lnet.ln_nis) {\r\nni = list_entry(tmp, lnet_ni_t, ni_list);\r\nif (LNET_NIDNET(ni->ni_nid) == net) {\r\nlnet_ni_addref_locked(ni, cpt);\r\nreturn ni;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nlnet_ni_t *\r\nlnet_net2ni(__u32 net)\r\n{\r\nlnet_ni_t *ni;\r\nlnet_net_lock(0);\r\nni = lnet_net2ni_locked(net, 0);\r\nlnet_net_unlock(0);\r\nreturn ni;\r\n}\r\nstatic unsigned int\r\nlnet_nid_cpt_hash(lnet_nid_t nid, unsigned int number)\r\n{\r\n__u64 key = nid;\r\nunsigned int val;\r\nLASSERT(number >= 1 && number <= LNET_CPT_NUMBER);\r\nif (number == 1)\r\nreturn 0;\r\nval = hash_long(key, LNET_CPT_BITS);\r\nif (val < number)\r\nreturn val;\r\nreturn (unsigned int)(key + val + (val >> 1)) % number;\r\n}\r\nint\r\nlnet_cpt_of_nid_locked(lnet_nid_t nid)\r\n{\r\nstruct lnet_ni *ni;\r\nif (LNET_CPT_NUMBER == 1)\r\nreturn 0;\r\nif (!list_empty(&the_lnet.ln_nis_cpt)) {\r\nlist_for_each_entry(ni, &the_lnet.ln_nis_cpt, ni_cptlist) {\r\nif (LNET_NIDNET(ni->ni_nid) != LNET_NIDNET(nid))\r\ncontinue;\r\nLASSERT(ni->ni_cpts != NULL);\r\nreturn ni->ni_cpts[lnet_nid_cpt_hash\r\n(nid, ni->ni_ncpts)];\r\n}\r\n}\r\nreturn lnet_nid_cpt_hash(nid, LNET_CPT_NUMBER);\r\n}\r\nint\r\nlnet_cpt_of_nid(lnet_nid_t nid)\r\n{\r\nint cpt;\r\nint cpt2;\r\nif (LNET_CPT_NUMBER == 1)\r\nreturn 0;\r\nif (list_empty(&the_lnet.ln_nis_cpt))\r\nreturn lnet_nid_cpt_hash(nid, LNET_CPT_NUMBER);\r\ncpt = lnet_net_lock_current();\r\ncpt2 = lnet_cpt_of_nid_locked(nid);\r\nlnet_net_unlock(cpt);\r\nreturn cpt2;\r\n}\r\nint\r\nlnet_islocalnet(__u32 net)\r\n{\r\nstruct lnet_ni *ni;\r\nint cpt;\r\ncpt = lnet_net_lock_current();\r\nni = lnet_net2ni_locked(net, cpt);\r\nif (ni != NULL)\r\nlnet_ni_decref_locked(ni, cpt);\r\nlnet_net_unlock(cpt);\r\nreturn ni != NULL;\r\n}\r\nlnet_ni_t *\r\nlnet_nid2ni_locked(lnet_nid_t nid, int cpt)\r\n{\r\nstruct lnet_ni *ni;\r\nstruct list_head *tmp;\r\nLASSERT(cpt != LNET_LOCK_EX);\r\nlist_for_each(tmp, &the_lnet.ln_nis) {\r\nni = list_entry(tmp, lnet_ni_t, ni_list);\r\nif (ni->ni_nid == nid) {\r\nlnet_ni_addref_locked(ni, cpt);\r\nreturn ni;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nlnet_islocalnid(lnet_nid_t nid)\r\n{\r\nstruct lnet_ni *ni;\r\nint cpt;\r\ncpt = lnet_net_lock_current();\r\nni = lnet_nid2ni_locked(nid, cpt);\r\nif (ni != NULL)\r\nlnet_ni_decref_locked(ni, cpt);\r\nlnet_net_unlock(cpt);\r\nreturn ni != NULL;\r\n}\r\nint\r\nlnet_count_acceptor_nis(void)\r\n{\r\nint count = 0;\r\nstruct list_head *tmp;\r\nstruct lnet_ni *ni;\r\nint cpt;\r\ncpt = lnet_net_lock_current();\r\nlist_for_each(tmp, &the_lnet.ln_nis) {\r\nni = list_entry(tmp, lnet_ni_t, ni_list);\r\nif (ni->ni_lnd->lnd_accept != NULL)\r\ncount++;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn count;\r\n}\r\nstatic int\r\nlnet_ni_tq_credits(lnet_ni_t *ni)\r\n{\r\nint credits;\r\nLASSERT(ni->ni_ncpts >= 1);\r\nif (ni->ni_ncpts == 1)\r\nreturn ni->ni_maxtxcredits;\r\ncredits = ni->ni_maxtxcredits / ni->ni_ncpts;\r\ncredits = max(credits, 8 * ni->ni_peertxcredits);\r\ncredits = min(credits, ni->ni_maxtxcredits);\r\nreturn credits;\r\n}\r\nstatic void\r\nlnet_shutdown_lndnis(void)\r\n{\r\nint i;\r\nint islo;\r\nlnet_ni_t *ni;\r\nLASSERT(!the_lnet.ln_shutdown);\r\nLASSERT(the_lnet.ln_refcount == 0);\r\nLASSERT(list_empty(&the_lnet.ln_nis_zombie));\r\nlnet_net_lock(LNET_LOCK_EX);\r\nthe_lnet.ln_shutdown = 1;\r\nwhile (!list_empty(&the_lnet.ln_nis)) {\r\nni = list_entry(the_lnet.ln_nis.next,\r\nlnet_ni_t, ni_list);\r\nlist_move(&ni->ni_list, &the_lnet.ln_nis_zombie);\r\nlnet_ni_decref_locked(ni, 0);\r\nif (!list_empty(&ni->ni_cptlist)) {\r\nlist_del_init(&ni->ni_cptlist);\r\nlnet_ni_decref_locked(ni, 0);\r\n}\r\n}\r\nif (the_lnet.ln_eq_waitni != NULL) {\r\nlnet_ni_decref_locked(the_lnet.ln_eq_waitni, 0);\r\nthe_lnet.ln_eq_waitni = NULL;\r\n}\r\nif (the_lnet.ln_loni != NULL) {\r\nlnet_ni_decref_locked(the_lnet.ln_loni, 0);\r\nthe_lnet.ln_loni = NULL;\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nfor (i = 0; i < the_lnet.ln_nportals; i++)\r\nLNetClearLazyPortal(i);\r\nlnet_peer_tables_cleanup();\r\nlnet_net_lock(LNET_LOCK_EX);\r\ni = 2;\r\nwhile (!list_empty(&the_lnet.ln_nis_zombie)) {\r\nint *ref;\r\nint j;\r\nni = list_entry(the_lnet.ln_nis_zombie.next,\r\nlnet_ni_t, ni_list);\r\nlist_del_init(&ni->ni_list);\r\ncfs_percpt_for_each(ref, j, ni->ni_refs) {\r\nif (*ref == 0)\r\ncontinue;\r\nlist_add(&ni->ni_list, &the_lnet.ln_nis_zombie);\r\nbreak;\r\n}\r\nif (!list_empty(&ni->ni_list)) {\r\nlnet_net_unlock(LNET_LOCK_EX);\r\n++i;\r\nif ((i & (-i)) == i) {\r\nCDEBUG(D_WARNING, "Waiting for zombie LNI %s\n",\r\nlibcfs_nid2str(ni->ni_nid));\r\n}\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\nlnet_net_lock(LNET_LOCK_EX);\r\ncontinue;\r\n}\r\nni->ni_lnd->lnd_refcount--;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nislo = ni->ni_lnd->lnd_type == LOLND;\r\nLASSERT(!in_interrupt());\r\n(ni->ni_lnd->lnd_shutdown)(ni);\r\nif (!islo)\r\nCDEBUG(D_LNI, "Removed LNI %s\n",\r\nlibcfs_nid2str(ni->ni_nid));\r\nlnet_ni_free(ni);\r\ni = 2;\r\nlnet_net_lock(LNET_LOCK_EX);\r\n}\r\nthe_lnet.ln_shutdown = 0;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nif (the_lnet.ln_network_tokens != NULL) {\r\nLIBCFS_FREE(the_lnet.ln_network_tokens,\r\nthe_lnet.ln_network_tokens_nob);\r\nthe_lnet.ln_network_tokens = NULL;\r\n}\r\n}\r\nstatic int\r\nlnet_startup_lndnis(void)\r\n{\r\nlnd_t *lnd;\r\nstruct lnet_ni *ni;\r\nstruct lnet_tx_queue *tq;\r\nstruct list_head nilist;\r\nint i;\r\nint rc = 0;\r\nint lnd_type;\r\nint nicount = 0;\r\nchar *nets = lnet_get_networks();\r\nINIT_LIST_HEAD(&nilist);\r\nif (nets == NULL)\r\ngoto failed;\r\nrc = lnet_parse_networks(&nilist, nets);\r\nif (rc != 0)\r\ngoto failed;\r\nwhile (!list_empty(&nilist)) {\r\nni = list_entry(nilist.next, lnet_ni_t, ni_list);\r\nlnd_type = LNET_NETTYP(LNET_NIDNET(ni->ni_nid));\r\nLASSERT(libcfs_isknown_lnd(lnd_type));\r\nif (lnd_type == CIBLND ||\r\nlnd_type == OPENIBLND ||\r\nlnd_type == IIBLND ||\r\nlnd_type == VIBLND) {\r\nCERROR("LND %s obsoleted\n",\r\nlibcfs_lnd2str(lnd_type));\r\ngoto failed;\r\n}\r\nmutex_lock(&the_lnet.ln_lnd_mutex);\r\nlnd = lnet_find_lnd_by_type(lnd_type);\r\nif (lnd == NULL) {\r\nmutex_unlock(&the_lnet.ln_lnd_mutex);\r\nrc = request_module("%s",\r\nlibcfs_lnd2modname(lnd_type));\r\nmutex_lock(&the_lnet.ln_lnd_mutex);\r\nlnd = lnet_find_lnd_by_type(lnd_type);\r\nif (lnd == NULL) {\r\nmutex_unlock(&the_lnet.ln_lnd_mutex);\r\nCERROR("Can't load LND %s, module %s, rc=%d\n",\r\nlibcfs_lnd2str(lnd_type),\r\nlibcfs_lnd2modname(lnd_type), rc);\r\ngoto failed;\r\n}\r\n}\r\nlnet_net_lock(LNET_LOCK_EX);\r\nlnd->lnd_refcount++;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nni->ni_lnd = lnd;\r\nrc = (lnd->lnd_startup)(ni);\r\nmutex_unlock(&the_lnet.ln_lnd_mutex);\r\nif (rc != 0) {\r\nLCONSOLE_ERROR_MSG(0x105, "Error %d starting up LNI %s\n",\r\nrc, libcfs_lnd2str(lnd->lnd_type));\r\nlnet_net_lock(LNET_LOCK_EX);\r\nlnd->lnd_refcount--;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\ngoto failed;\r\n}\r\nLASSERT(ni->ni_peertimeout <= 0 || lnd->lnd_query != NULL);\r\nlist_del(&ni->ni_list);\r\nlnet_net_lock(LNET_LOCK_EX);\r\nlnet_ni_addref_locked(ni, 0);\r\nlist_add_tail(&ni->ni_list, &the_lnet.ln_nis);\r\nif (ni->ni_cpts != NULL) {\r\nlist_add_tail(&ni->ni_cptlist,\r\n&the_lnet.ln_nis_cpt);\r\nlnet_ni_addref_locked(ni, 0);\r\n}\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nif (lnd->lnd_type == LOLND) {\r\nlnet_ni_addref(ni);\r\nLASSERT(the_lnet.ln_loni == NULL);\r\nthe_lnet.ln_loni = ni;\r\ncontinue;\r\n}\r\nif (ni->ni_peertxcredits == 0 ||\r\nni->ni_maxtxcredits == 0) {\r\nLCONSOLE_ERROR_MSG(0x107, "LNI %s has no %scredits\n",\r\nlibcfs_lnd2str(lnd->lnd_type),\r\nni->ni_peertxcredits == 0 ?\r\n"" : "per-peer ");\r\ngoto failed;\r\n}\r\ncfs_percpt_for_each(tq, i, ni->ni_tx_queues) {\r\ntq->tq_credits_min =\r\ntq->tq_credits_max =\r\ntq->tq_credits = lnet_ni_tq_credits(ni);\r\n}\r\nCDEBUG(D_LNI, "Added LNI %s [%d/%d/%d/%d]\n",\r\nlibcfs_nid2str(ni->ni_nid), ni->ni_peertxcredits,\r\nlnet_ni_tq_credits(ni) * LNET_CPT_NUMBER,\r\nni->ni_peerrtrcredits, ni->ni_peertimeout);\r\nnicount++;\r\n}\r\nif (the_lnet.ln_eq_waitni != NULL && nicount > 1) {\r\nlnd_type = the_lnet.ln_eq_waitni->ni_lnd->lnd_type;\r\nLCONSOLE_ERROR_MSG(0x109, "LND %s can only run single-network\n",\r\nlibcfs_lnd2str(lnd_type));\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nlnet_shutdown_lndnis();\r\nwhile (!list_empty(&nilist)) {\r\nni = list_entry(nilist.next, lnet_ni_t, ni_list);\r\nlist_del(&ni->ni_list);\r\nlnet_ni_free(ni);\r\n}\r\nreturn -ENETDOWN;\r\n}\r\nint\r\nlnet_init(void)\r\n{\r\nint rc;\r\nlnet_assert_wire_constants();\r\nLASSERT(!the_lnet.ln_init);\r\nmemset(&the_lnet, 0, sizeof(the_lnet));\r\nthe_lnet.ln_cpt_table = cfs_cpt_table;\r\nthe_lnet.ln_cpt_number = cfs_cpt_number(cfs_cpt_table);\r\nLASSERT(the_lnet.ln_cpt_number > 0);\r\nif (the_lnet.ln_cpt_number > LNET_CPT_MAX) {\r\nCERROR("Can't have %d CPTs for LNet (max allowed is %d), please change setting of CPT-table and retry\n",\r\nthe_lnet.ln_cpt_number, LNET_CPT_MAX);\r\nreturn -1;\r\n}\r\nwhile ((1 << the_lnet.ln_cpt_bits) < the_lnet.ln_cpt_number)\r\nthe_lnet.ln_cpt_bits++;\r\nrc = lnet_create_locks();\r\nif (rc != 0) {\r\nCERROR("Can't create LNet global locks: %d\n", rc);\r\nreturn -1;\r\n}\r\nthe_lnet.ln_refcount = 0;\r\nthe_lnet.ln_init = 1;\r\nLNetInvalidateHandle(&the_lnet.ln_rc_eqh);\r\nINIT_LIST_HEAD(&the_lnet.ln_lnds);\r\nINIT_LIST_HEAD(&the_lnet.ln_rcd_zombie);\r\nINIT_LIST_HEAD(&the_lnet.ln_rcd_deathrow);\r\nif (rnet_htable_size <= 0)\r\nrnet_htable_size = LNET_REMOTE_NETS_HASH_DEFAULT;\r\nelse if (rnet_htable_size > LNET_REMOTE_NETS_HASH_MAX)\r\nrnet_htable_size = LNET_REMOTE_NETS_HASH_MAX;\r\nthe_lnet.ln_remote_nets_hbits = max_t(int, 1,\r\norder_base_2(rnet_htable_size) - 1);\r\nlnet_register_lnd(&the_lolnd);\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_fini(void)\r\n{\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount == 0);\r\nwhile (!list_empty(&the_lnet.ln_lnds))\r\nlnet_unregister_lnd(list_entry(the_lnet.ln_lnds.next,\r\nlnd_t, lnd_list));\r\nlnet_destroy_locks();\r\nthe_lnet.ln_init = 0;\r\n}\r\nint\r\nLNetNIInit(lnet_pid_t requested_pid)\r\n{\r\nint im_a_router = 0;\r\nint rc;\r\nmutex_lock(&the_lnet.ln_api_mutex);\r\nLASSERT(the_lnet.ln_init);\r\nCDEBUG(D_OTHER, "refs %d\n", the_lnet.ln_refcount);\r\nif (the_lnet.ln_refcount > 0) {\r\nrc = the_lnet.ln_refcount++;\r\ngoto out;\r\n}\r\nif (requested_pid == LNET_PID_ANY) {\r\nrc = -ENETDOWN;\r\ngoto failed0;\r\n}\r\nrc = lnet_prepare(requested_pid);\r\nif (rc != 0)\r\ngoto failed0;\r\nrc = lnet_startup_lndnis();\r\nif (rc != 0)\r\ngoto failed1;\r\nrc = lnet_parse_routes(lnet_get_routes(), &im_a_router);\r\nif (rc != 0)\r\ngoto failed2;\r\nrc = lnet_check_routes();\r\nif (rc != 0)\r\ngoto failed2;\r\nrc = lnet_rtrpools_alloc(im_a_router);\r\nif (rc != 0)\r\ngoto failed2;\r\nrc = lnet_acceptor_start();\r\nif (rc != 0)\r\ngoto failed2;\r\nthe_lnet.ln_refcount = 1;\r\nrc = lnet_ping_target_init();\r\nif (rc != 0)\r\ngoto failed3;\r\nrc = lnet_router_checker_start();\r\nif (rc != 0)\r\ngoto failed4;\r\nlnet_proc_init();\r\ngoto out;\r\nfailed4:\r\nlnet_ping_target_fini();\r\nfailed3:\r\nthe_lnet.ln_refcount = 0;\r\nlnet_acceptor_stop();\r\nfailed2:\r\nlnet_destroy_routes();\r\nlnet_shutdown_lndnis();\r\nfailed1:\r\nlnet_unprepare();\r\nfailed0:\r\nLASSERT(rc < 0);\r\nout:\r\nmutex_unlock(&the_lnet.ln_api_mutex);\r\nreturn rc;\r\n}\r\nint\r\nLNetNIFini(void)\r\n{\r\nmutex_lock(&the_lnet.ln_api_mutex);\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\nif (the_lnet.ln_refcount != 1) {\r\nthe_lnet.ln_refcount--;\r\n} else {\r\nLASSERT(!the_lnet.ln_niinit_self);\r\nlnet_proc_fini();\r\nlnet_router_checker_stop();\r\nlnet_ping_target_fini();\r\nthe_lnet.ln_refcount = 0;\r\nlnet_acceptor_stop();\r\nlnet_destroy_routes();\r\nlnet_shutdown_lndnis();\r\nlnet_unprepare();\r\n}\r\nmutex_unlock(&the_lnet.ln_api_mutex);\r\nreturn 0;\r\n}\r\nint\r\nLNetCtl(unsigned int cmd, void *arg)\r\n{\r\nstruct libcfs_ioctl_data *data = arg;\r\nlnet_process_id_t id = {0};\r\nlnet_ni_t *ni;\r\nint rc;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\nswitch (cmd) {\r\ncase IOC_LIBCFS_GET_NI:\r\nrc = LNetGetId(data->ioc_count, &id);\r\ndata->ioc_nid = id.nid;\r\nreturn rc;\r\ncase IOC_LIBCFS_FAIL_NID:\r\nreturn lnet_fail_nid(data->ioc_nid, data->ioc_count);\r\ncase IOC_LIBCFS_ADD_ROUTE:\r\nrc = lnet_add_route(data->ioc_net, data->ioc_count,\r\ndata->ioc_nid, data->ioc_priority);\r\nreturn (rc != 0) ? rc : lnet_check_routes();\r\ncase IOC_LIBCFS_DEL_ROUTE:\r\nreturn lnet_del_route(data->ioc_net, data->ioc_nid);\r\ncase IOC_LIBCFS_GET_ROUTE:\r\nreturn lnet_get_route(data->ioc_count,\r\n&data->ioc_net, &data->ioc_count,\r\n&data->ioc_nid, &data->ioc_flags,\r\n&data->ioc_priority);\r\ncase IOC_LIBCFS_NOTIFY_ROUTER:\r\nreturn lnet_notify(NULL, data->ioc_nid, data->ioc_flags,\r\ncfs_time_current() -\r\ncfs_time_seconds(get_seconds() -\r\n(time_t)data->ioc_u64[0]));\r\ncase IOC_LIBCFS_PORTALS_COMPATIBILITY:\r\nreturn 0;\r\ncase IOC_LIBCFS_LNET_DIST:\r\nrc = LNetDist(data->ioc_nid, &data->ioc_nid, &data->ioc_u32[1]);\r\nif (rc < 0 && rc != -EHOSTUNREACH)\r\nreturn rc;\r\ndata->ioc_u32[0] = rc;\r\nreturn 0;\r\ncase IOC_LIBCFS_TESTPROTOCOMPAT:\r\nlnet_net_lock(LNET_LOCK_EX);\r\nthe_lnet.ln_testprotocompat = data->ioc_flags;\r\nlnet_net_unlock(LNET_LOCK_EX);\r\nreturn 0;\r\ncase IOC_LIBCFS_PING:\r\nid.nid = data->ioc_nid;\r\nid.pid = data->ioc_u32[0];\r\nrc = lnet_ping(id, data->ioc_u32[1],\r\n(lnet_process_id_t *)data->ioc_pbuf1,\r\ndata->ioc_plen1/sizeof(lnet_process_id_t));\r\nif (rc < 0)\r\nreturn rc;\r\ndata->ioc_count = rc;\r\nreturn 0;\r\ncase IOC_LIBCFS_DEBUG_PEER: {\r\nid = *((lnet_process_id_t *) arg);\r\nlnet_debug_peer(id.nid);\r\nni = lnet_net2ni(LNET_NIDNET(id.nid));\r\nif (ni == NULL) {\r\nCDEBUG(D_WARNING, "No NI for %s\n", libcfs_id2str(id));\r\n} else {\r\nif (ni->ni_lnd->lnd_ctl == NULL) {\r\nCDEBUG(D_WARNING, "No ctl for %s\n",\r\nlibcfs_id2str(id));\r\n} else {\r\n(void)ni->ni_lnd->lnd_ctl(ni, cmd, arg);\r\n}\r\nlnet_ni_decref(ni);\r\n}\r\nreturn 0;\r\n}\r\ndefault:\r\nni = lnet_net2ni(data->ioc_net);\r\nif (ni == NULL)\r\nreturn -EINVAL;\r\nif (ni->ni_lnd->lnd_ctl == NULL)\r\nrc = -EINVAL;\r\nelse\r\nrc = ni->ni_lnd->lnd_ctl(ni, cmd, arg);\r\nlnet_ni_decref(ni);\r\nreturn rc;\r\n}\r\n}\r\nint\r\nLNetGetId(unsigned int index, lnet_process_id_t *id)\r\n{\r\nstruct lnet_ni *ni;\r\nstruct list_head *tmp;\r\nint cpt;\r\nint rc = -ENOENT;\r\nLASSERT(the_lnet.ln_init);\r\nif (the_lnet.ln_refcount == 0)\r\nreturn rc;\r\ncpt = lnet_net_lock_current();\r\nlist_for_each(tmp, &the_lnet.ln_nis) {\r\nif (index-- != 0)\r\ncontinue;\r\nni = list_entry(tmp, lnet_ni_t, ni_list);\r\nid->nid = ni->ni_nid;\r\nid->pid = the_lnet.ln_pid;\r\nrc = 0;\r\nbreak;\r\n}\r\nlnet_net_unlock(cpt);\r\nreturn rc;\r\n}\r\nvoid\r\nLNetSnprintHandle(char *str, int len, lnet_handle_any_t h)\r\n{\r\nsnprintf(str, len, "%#llx", h.cookie);\r\n}\r\nstatic int\r\nlnet_create_ping_info(void)\r\n{\r\nint i;\r\nint n;\r\nint rc;\r\nunsigned int infosz;\r\nlnet_ni_t *ni;\r\nlnet_process_id_t id;\r\nlnet_ping_info_t *pinfo;\r\nfor (n = 0; ; n++) {\r\nrc = LNetGetId(n, &id);\r\nif (rc == -ENOENT)\r\nbreak;\r\nLASSERT(rc == 0);\r\n}\r\ninfosz = offsetof(lnet_ping_info_t, pi_ni[n]);\r\nLIBCFS_ALLOC(pinfo, infosz);\r\nif (pinfo == NULL) {\r\nCERROR("Can't allocate ping info[%d]\n", n);\r\nreturn -ENOMEM;\r\n}\r\npinfo->pi_nnis = n;\r\npinfo->pi_pid = the_lnet.ln_pid;\r\npinfo->pi_magic = LNET_PROTO_PING_MAGIC;\r\npinfo->pi_features = LNET_PING_FEAT_NI_STATUS;\r\nfor (i = 0; i < n; i++) {\r\nlnet_ni_status_t *ns = &pinfo->pi_ni[i];\r\nrc = LNetGetId(i, &id);\r\nLASSERT(rc == 0);\r\nns->ns_nid = id.nid;\r\nns->ns_status = LNET_NI_STATUS_UP;\r\nlnet_net_lock(0);\r\nni = lnet_nid2ni_locked(id.nid, 0);\r\nLASSERT(ni != NULL);\r\nlnet_ni_lock(ni);\r\nLASSERT(ni->ni_status == NULL);\r\nni->ni_status = ns;\r\nlnet_ni_unlock(ni);\r\nlnet_ni_decref_locked(ni, 0);\r\nlnet_net_unlock(0);\r\n}\r\nthe_lnet.ln_ping_info = pinfo;\r\nreturn 0;\r\n}\r\nstatic void\r\nlnet_destroy_ping_info(void)\r\n{\r\nstruct lnet_ni *ni;\r\nlnet_net_lock(0);\r\nlist_for_each_entry(ni, &the_lnet.ln_nis, ni_list) {\r\nlnet_ni_lock(ni);\r\nni->ni_status = NULL;\r\nlnet_ni_unlock(ni);\r\n}\r\nlnet_net_unlock(0);\r\nLIBCFS_FREE(the_lnet.ln_ping_info,\r\noffsetof(lnet_ping_info_t,\r\npi_ni[the_lnet.ln_ping_info->pi_nnis]));\r\nthe_lnet.ln_ping_info = NULL;\r\n}\r\nint\r\nlnet_ping_target_init(void)\r\n{\r\nlnet_md_t md = { NULL };\r\nlnet_handle_me_t meh;\r\nlnet_process_id_t id;\r\nint rc;\r\nint rc2;\r\nint infosz;\r\nrc = lnet_create_ping_info();\r\nif (rc != 0)\r\nreturn rc;\r\nrc = LNetEQAlloc(2, LNET_EQ_HANDLER_NONE, &the_lnet.ln_ping_target_eq);\r\nif (rc != 0) {\r\nCERROR("Can't allocate ping EQ: %d\n", rc);\r\ngoto failed_0;\r\n}\r\nmemset(&id, 0, sizeof(lnet_process_id_t));\r\nid.nid = LNET_NID_ANY;\r\nid.pid = LNET_PID_ANY;\r\nrc = LNetMEAttach(LNET_RESERVED_PORTAL, id,\r\nLNET_PROTO_PING_MATCHBITS, 0,\r\nLNET_UNLINK, LNET_INS_AFTER,\r\n&meh);\r\nif (rc != 0) {\r\nCERROR("Can't create ping ME: %d\n", rc);\r\ngoto failed_1;\r\n}\r\ninfosz = offsetof(lnet_ping_info_t,\r\npi_ni[the_lnet.ln_ping_info->pi_nnis]);\r\nmd.start = the_lnet.ln_ping_info;\r\nmd.length = infosz;\r\nmd.threshold = LNET_MD_THRESH_INF;\r\nmd.max_size = 0;\r\nmd.options = LNET_MD_OP_GET | LNET_MD_TRUNCATE |\r\nLNET_MD_MANAGE_REMOTE;\r\nmd.user_ptr = NULL;\r\nmd.eq_handle = the_lnet.ln_ping_target_eq;\r\nrc = LNetMDAttach(meh, md,\r\nLNET_RETAIN,\r\n&the_lnet.ln_ping_target_md);\r\nif (rc != 0) {\r\nCERROR("Can't attach ping MD: %d\n", rc);\r\ngoto failed_2;\r\n}\r\nreturn 0;\r\nfailed_2:\r\nrc2 = LNetMEUnlink(meh);\r\nLASSERT(rc2 == 0);\r\nfailed_1:\r\nrc2 = LNetEQFree(the_lnet.ln_ping_target_eq);\r\nLASSERT(rc2 == 0);\r\nfailed_0:\r\nlnet_destroy_ping_info();\r\nreturn rc;\r\n}\r\nvoid\r\nlnet_ping_target_fini(void)\r\n{\r\nlnet_event_t event;\r\nint rc;\r\nint which;\r\nint timeout_ms = 1000;\r\nsigset_t blocked = cfs_block_allsigs();\r\nLNetMDUnlink(the_lnet.ln_ping_target_md);\r\nfor (;;) {\r\nrc = LNetEQPoll(&the_lnet.ln_ping_target_eq, 1,\r\ntimeout_ms, &event, &which);\r\nLASSERT(rc >= 0 || rc == -EOVERFLOW);\r\nif (rc == 0) {\r\nCWARN("Still waiting for ping MD to unlink\n");\r\ntimeout_ms *= 2;\r\ncontinue;\r\n}\r\nif (event.unlinked)\r\nbreak;\r\n}\r\nrc = LNetEQFree(the_lnet.ln_ping_target_eq);\r\nLASSERT(rc == 0);\r\nlnet_destroy_ping_info();\r\ncfs_restore_sigs(blocked);\r\n}\r\nint\r\nlnet_ping(lnet_process_id_t id, int timeout_ms, lnet_process_id_t *ids, int n_ids)\r\n{\r\nlnet_handle_eq_t eqh;\r\nlnet_handle_md_t mdh;\r\nlnet_event_t event;\r\nlnet_md_t md = { NULL };\r\nint which;\r\nint unlinked = 0;\r\nint replied = 0;\r\nconst int a_long_time = 60000;\r\nint infosz = offsetof(lnet_ping_info_t, pi_ni[n_ids]);\r\nlnet_ping_info_t *info;\r\nlnet_process_id_t tmpid;\r\nint i;\r\nint nob;\r\nint rc;\r\nint rc2;\r\nsigset_t blocked;\r\nif (n_ids <= 0 ||\r\nid.nid == LNET_NID_ANY ||\r\ntimeout_ms > 500000 ||\r\nn_ids > 20)\r\nreturn -EINVAL;\r\nif (id.pid == LNET_PID_ANY)\r\nid.pid = LUSTRE_SRV_LNET_PID;\r\nLIBCFS_ALLOC(info, infosz);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nrc = LNetEQAlloc(2, LNET_EQ_HANDLER_NONE, &eqh);\r\nif (rc != 0) {\r\nCERROR("Can't allocate EQ: %d\n", rc);\r\ngoto out_0;\r\n}\r\nmd.start = info;\r\nmd.length = infosz;\r\nmd.threshold = 2;\r\nmd.max_size = 0;\r\nmd.options = LNET_MD_TRUNCATE;\r\nmd.user_ptr = NULL;\r\nmd.eq_handle = eqh;\r\nrc = LNetMDBind(md, LNET_UNLINK, &mdh);\r\nif (rc != 0) {\r\nCERROR("Can't bind MD: %d\n", rc);\r\ngoto out_1;\r\n}\r\nrc = LNetGet(LNET_NID_ANY, mdh, id,\r\nLNET_RESERVED_PORTAL,\r\nLNET_PROTO_PING_MATCHBITS, 0);\r\nif (rc != 0) {\r\nrc2 = LNetMDUnlink(mdh);\r\nLASSERT(rc2 == 0);\r\nunlinked = 1;\r\ntimeout_ms = a_long_time;\r\n}\r\ndo {\r\nif (unlinked)\r\nblocked = cfs_block_allsigs();\r\nrc2 = LNetEQPoll(&eqh, 1, timeout_ms, &event, &which);\r\nif (unlinked)\r\ncfs_restore_sigs(blocked);\r\nCDEBUG(D_NET, "poll %d(%d %d)%s\n", rc2,\r\n(rc2 <= 0) ? -1 : event.type,\r\n(rc2 <= 0) ? -1 : event.status,\r\n(rc2 > 0 && event.unlinked) ? " unlinked" : "");\r\nLASSERT(rc2 != -EOVERFLOW);\r\nif (rc2 <= 0 || event.status != 0) {\r\nif (!replied && rc == 0)\r\nrc = (rc2 < 0) ? rc2 :\r\n(rc2 == 0) ? -ETIMEDOUT :\r\nevent.status;\r\nif (!unlinked) {\r\nLNetMDUnlink(mdh);\r\nunlinked = 1;\r\ntimeout_ms = a_long_time;\r\n} else if (rc2 == 0) {\r\nCWARN("ping %s: late network completion\n",\r\nlibcfs_id2str(id));\r\n}\r\n} else if (event.type == LNET_EVENT_REPLY) {\r\nreplied = 1;\r\nrc = event.mlength;\r\n}\r\n} while (rc2 <= 0 || !event.unlinked);\r\nif (!replied) {\r\nif (rc >= 0)\r\nCWARN("%s: Unexpected rc >= 0 but no reply!\n",\r\nlibcfs_id2str(id));\r\nrc = -EIO;\r\ngoto out_1;\r\n}\r\nnob = rc;\r\nLASSERT(nob >= 0 && nob <= infosz);\r\nrc = -EPROTO;\r\nif (nob < 8) {\r\nCERROR("%s: ping info too short %d\n",\r\nlibcfs_id2str(id), nob);\r\ngoto out_1;\r\n}\r\nif (info->pi_magic == __swab32(LNET_PROTO_PING_MAGIC)) {\r\nlnet_swap_pinginfo(info);\r\n} else if (info->pi_magic != LNET_PROTO_PING_MAGIC) {\r\nCERROR("%s: Unexpected magic %08x\n",\r\nlibcfs_id2str(id), info->pi_magic);\r\ngoto out_1;\r\n}\r\nif ((info->pi_features & LNET_PING_FEAT_NI_STATUS) == 0) {\r\nCERROR("%s: ping w/o NI status: 0x%x\n",\r\nlibcfs_id2str(id), info->pi_features);\r\ngoto out_1;\r\n}\r\nif (nob < offsetof(lnet_ping_info_t, pi_ni[0])) {\r\nCERROR("%s: Short reply %d(%d min)\n", libcfs_id2str(id),\r\nnob, (int)offsetof(lnet_ping_info_t, pi_ni[0]));\r\ngoto out_1;\r\n}\r\nif (info->pi_nnis < n_ids)\r\nn_ids = info->pi_nnis;\r\nif (nob < offsetof(lnet_ping_info_t, pi_ni[n_ids])) {\r\nCERROR("%s: Short reply %d(%d expected)\n", libcfs_id2str(id),\r\nnob, (int)offsetof(lnet_ping_info_t, pi_ni[n_ids]));\r\ngoto out_1;\r\n}\r\nrc = -EFAULT;\r\nmemset(&tmpid, 0, sizeof(tmpid));\r\nfor (i = 0; i < n_ids; i++) {\r\ntmpid.pid = info->pi_pid;\r\ntmpid.nid = info->pi_ni[i].ns_nid;\r\nif (copy_to_user(&ids[i], &tmpid, sizeof(tmpid)))\r\ngoto out_1;\r\n}\r\nrc = info->pi_nnis;\r\nout_1:\r\nrc2 = LNetEQFree(eqh);\r\nif (rc2 != 0)\r\nCERROR("rc2 %d\n", rc2);\r\nLASSERT(rc2 == 0);\r\nout_0:\r\nLIBCFS_FREE(info, infosz);\r\nreturn rc;\r\n}
