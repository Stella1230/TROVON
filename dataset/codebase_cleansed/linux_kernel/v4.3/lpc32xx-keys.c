static void lpc32xx_mod_states(struct lpc32xx_kscan_drv *kscandat, int col)\r\n{\r\nstruct input_dev *input = kscandat->input;\r\nunsigned row, changed, scancode, keycode;\r\nu8 key;\r\nkey = readl(LPC32XX_KS_DATA(kscandat->kscan_base, col));\r\nchanged = key ^ kscandat->lastkeystates[col];\r\nkscandat->lastkeystates[col] = key;\r\nfor (row = 0; changed; row++, changed >>= 1) {\r\nif (changed & 1) {\r\nscancode = MATRIX_SCAN_CODE(row, col,\r\nkscandat->row_shift);\r\nkeycode = kscandat->keymap[scancode];\r\ninput_event(input, EV_MSC, MSC_SCAN, scancode);\r\ninput_report_key(input, keycode, key & (1 << row));\r\n}\r\n}\r\n}\r\nstatic irqreturn_t lpc32xx_kscan_irq(int irq, void *dev_id)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = dev_id;\r\nint i;\r\nfor (i = 0; i < kscandat->matrix_sz; i++)\r\nlpc32xx_mod_states(kscandat, i);\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\ninput_sync(kscandat->input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc32xx_kscan_open(struct input_dev *dev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = input_get_drvdata(dev);\r\nint error;\r\nerror = clk_prepare_enable(kscandat->clk);\r\nif (error)\r\nreturn error;\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_kscan_close(struct input_dev *dev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat = input_get_drvdata(dev);\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nclk_disable_unprepare(kscandat->clk);\r\n}\r\nstatic int lpc32xx_parse_dt(struct device *dev,\r\nstruct lpc32xx_kscan_drv *kscandat)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 rows = 0, columns = 0;\r\nint err;\r\nerr = matrix_keypad_parse_of_params(dev, &rows, &columns);\r\nif (err)\r\nreturn err;\r\nif (rows != columns) {\r\ndev_err(dev, "rows and columns must be equal!\n");\r\nreturn -EINVAL;\r\n}\r\nkscandat->matrix_sz = rows;\r\nkscandat->row_shift = get_count_order(columns);\r\nof_property_read_u32(np, "nxp,debounce-delay-ms", &kscandat->deb_clks);\r\nof_property_read_u32(np, "nxp,scan-delay-ms", &kscandat->scan_delay);\r\nif (!kscandat->deb_clks || !kscandat->scan_delay) {\r\ndev_err(dev, "debounce or scan delay not specified\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_kscan_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_kscan_drv *kscandat;\r\nstruct input_dev *input;\r\nstruct resource *res;\r\nsize_t keymap_size;\r\nint error;\r\nint irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get platform I/O memory\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0 || irq >= NR_IRQS) {\r\ndev_err(&pdev->dev, "failed to get platform irq\n");\r\nreturn -EINVAL;\r\n}\r\nkscandat = devm_kzalloc(&pdev->dev, sizeof(*kscandat),\r\nGFP_KERNEL);\r\nif (!kscandat)\r\nreturn -ENOMEM;\r\nerror = lpc32xx_parse_dt(&pdev->dev, kscandat);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to parse device tree\n");\r\nreturn error;\r\n}\r\nkeymap_size = sizeof(kscandat->keymap[0]) *\r\n(kscandat->matrix_sz << kscandat->row_shift);\r\nkscandat->keymap = devm_kzalloc(&pdev->dev, keymap_size, GFP_KERNEL);\r\nif (!kscandat->keymap)\r\nreturn -ENOMEM;\r\nkscandat->input = input = devm_input_allocate_device(&pdev->dev);\r\nif (!input) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = pdev->name;\r\ninput->phys = "lpc32xx/input0";\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\ninput->open = lpc32xx_kscan_open;\r\ninput->close = lpc32xx_kscan_close;\r\ninput->dev.parent = &pdev->dev;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nerror = matrix_keypad_build_keymap(NULL, NULL,\r\nkscandat->matrix_sz,\r\nkscandat->matrix_sz,\r\nkscandat->keymap, kscandat->input);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to build keymap\n");\r\nreturn error;\r\n}\r\ninput_set_drvdata(kscandat->input, kscandat);\r\nkscandat->kscan_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(kscandat->kscan_base))\r\nreturn PTR_ERR(kscandat->kscan_base);\r\nkscandat->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(kscandat->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(kscandat->clk);\r\n}\r\nerror = clk_prepare_enable(kscandat->clk);\r\nif (error)\r\nreturn error;\r\nwritel(kscandat->deb_clks, LPC32XX_KS_DEB(kscandat->kscan_base));\r\nwritel(kscandat->scan_delay, LPC32XX_KS_SCAN_CTL(kscandat->kscan_base));\r\nwritel(LPC32XX_KSCAN_FTST_USE32K_CLK,\r\nLPC32XX_KS_FAST_TST(kscandat->kscan_base));\r\nwritel(kscandat->matrix_sz,\r\nLPC32XX_KS_MATRIX_DIM(kscandat->kscan_base));\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nclk_disable_unprepare(kscandat->clk);\r\nerror = devm_request_irq(&pdev->dev, irq, lpc32xx_kscan_irq, 0,\r\npdev->name, kscandat);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(kscandat->input);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\nreturn error;\r\n}\r\nplatform_set_drvdata(pdev, kscandat);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_kscan_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\r\nstruct input_dev *input = kscandat->input;\r\nmutex_lock(&input->mutex);\r\nif (input->users) {\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\nclk_disable_unprepare(kscandat->clk);\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_kscan_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);\r\nstruct input_dev *input = kscandat->input;\r\nint retval = 0;\r\nmutex_lock(&input->mutex);\r\nif (input->users) {\r\nretval = clk_prepare_enable(kscandat->clk);\r\nif (retval == 0)\r\nwritel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));\r\n}\r\nmutex_unlock(&input->mutex);\r\nreturn retval;\r\n}
