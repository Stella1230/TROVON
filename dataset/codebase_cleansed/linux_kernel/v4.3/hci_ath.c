static int ath_wakeup_ar3k(struct tty_struct *tty)\r\n{\r\nint status = tty->driver->ops->tiocmget(tty);\r\nif (status & TIOCM_CTS)\r\nreturn status;\r\ntty->driver->ops->tiocmget(tty);\r\ntty->driver->ops->tiocmset(tty, 0x00, TIOCM_RTS);\r\nmdelay(20);\r\ntty->driver->ops->tiocmget(tty);\r\ntty->driver->ops->tiocmset(tty, TIOCM_RTS, 0x00);\r\nmdelay(20);\r\nstatus = tty->driver->ops->tiocmget(tty);\r\nreturn status;\r\n}\r\nstatic void ath_hci_uart_work(struct work_struct *work)\r\n{\r\nint status;\r\nstruct ath_struct *ath;\r\nstruct hci_uart *hu;\r\nstruct tty_struct *tty;\r\nath = container_of(work, struct ath_struct, ctxtsw);\r\nhu = ath->hu;\r\ntty = hu->tty;\r\nif (ath->cur_sleep) {\r\nstatus = ath_wakeup_ar3k(tty);\r\nif (!(status & TIOCM_CTS))\r\nreturn;\r\n}\r\nclear_bit(HCI_UART_SENDING, &hu->tx_state);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int ath_open(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath;\r\nBT_DBG("hu %p", hu);\r\nath = kzalloc(sizeof(*ath), GFP_KERNEL);\r\nif (!ath)\r\nreturn -ENOMEM;\r\nskb_queue_head_init(&ath->txq);\r\nhu->priv = ath;\r\nath->hu = hu;\r\nINIT_WORK(&ath->ctxtsw, ath_hci_uart_work);\r\nreturn 0;\r\n}\r\nstatic int ath_close(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ath->txq);\r\nkfree_skb(ath->rx_skb);\r\ncancel_work_sync(&ath->ctxtsw);\r\nhu->priv = NULL;\r\nkfree(ath);\r\nreturn 0;\r\n}\r\nstatic int ath_flush(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&ath->txq);\r\nreturn 0;\r\n}\r\nstatic int ath_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\r\n{\r\nstruct sk_buff *skb;\r\nu8 buf[10];\r\nint err;\r\nbuf[0] = 0x01;\r\nbuf[1] = 0x01;\r\nbuf[2] = 0x00;\r\nbuf[3] = sizeof(bdaddr_t);\r\nmemcpy(buf + 4, bdaddr, sizeof(bdaddr_t));\r\nskb = __hci_cmd_sync(hdev, 0xfc0b, sizeof(buf), buf, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Change address command failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ath_setup(struct hci_uart *hu)\r\n{\r\nBT_DBG("hu %p", hu);\r\nhu->hdev->set_bdaddr = ath_set_bdaddr;\r\nreturn 0;\r\n}\r\nstatic int ath_recv(struct hci_uart *hu, const void *data, int count)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nath->rx_skb = h4_recv_buf(hu->hdev, ath->rx_skb, data, count,\r\nath_recv_pkts, ARRAY_SIZE(ath_recv_pkts));\r\nif (IS_ERR(ath->rx_skb)) {\r\nint err = PTR_ERR(ath->rx_skb);\r\nBT_ERR("%s: Frame reassembly failed (%d)", hu->hdev->name, err);\r\nath->rx_skb = NULL;\r\nreturn err;\r\n}\r\nreturn count;\r\n}\r\nstatic int ath_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nif (bt_cb(skb)->pkt_type == HCI_SCODATA_PKT) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nif (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT) {\r\nstruct hci_command_hdr *hdr = (void *)skb->data;\r\nif (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP)\r\nath->cur_sleep = skb->data[HCI_COMMAND_HDR_SIZE];\r\n}\r\nBT_DBG("hu %p skb %p", hu, skb);\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&ath->txq, skb);\r\nset_bit(HCI_UART_SENDING, &hu->tx_state);\r\nschedule_work(&ath->ctxtsw);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *ath_dequeue(struct hci_uart *hu)\r\n{\r\nstruct ath_struct *ath = hu->priv;\r\nreturn skb_dequeue(&ath->txq);\r\n}\r\nint __init ath_init(void)\r\n{\r\nreturn hci_uart_register_proto(&athp);\r\n}\r\nint __exit ath_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&athp);\r\n}
