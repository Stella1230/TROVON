static const struct gma_limit_t *psb_intel_limit(struct drm_crtc *crtc,\r\nint refclk)\r\n{\r\nconst struct gma_limit_t *limit;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))\r\nlimit = &psb_intel_limits[INTEL_LIMIT_I9XX_LVDS];\r\nelse\r\nlimit = &psb_intel_limits[INTEL_LIMIT_I9XX_SDVO_DAC];\r\nreturn limit;\r\n}\r\nstatic void psb_intel_clock(int refclk, struct gma_clock_t *clock)\r\n{\r\nclock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);\r\nclock->p = clock->p1 * clock->p2;\r\nclock->vco = refclk * clock->m / (clock->n + 2);\r\nclock->dot = clock->vco / clock->p;\r\n}\r\nstatic int psb_intel_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int psb_intel_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nconst struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint refclk;\r\nstruct gma_clock_t clock;\r\nu32 dpll = 0, fp = 0, dspcntr, pipeconf;\r\nbool ok, is_sdvo = false;\r\nbool is_lvds = false, is_tv = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nconst struct gma_limit_t *limit;\r\nif (crtc->primary->fb == NULL) {\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\nreturn 0;\r\n}\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nif (!connector->encoder\r\n|| connector->encoder->crtc != crtc)\r\ncontinue;\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\nis_lvds = true;\r\nbreak;\r\ncase INTEL_OUTPUT_SDVO:\r\nis_sdvo = true;\r\nbreak;\r\ncase INTEL_OUTPUT_TVOUT:\r\nis_tv = true;\r\nbreak;\r\n}\r\n}\r\nrefclk = 96000;\r\nlimit = gma_crtc->clock_funcs->limit(crtc, refclk);\r\nok = limit->find_pll(limit, crtc, adjusted_mode->clock, refclk,\r\n&clock);\r\nif (!ok) {\r\nDRM_ERROR("Couldn't find PLL settings for mode! target: %d, actual: %d",\r\nadjusted_mode->clock, clock.dot);\r\nreturn 0;\r\n}\r\nfp = clock.n << 16 | clock.m1 << 8 | clock.m2;\r\ndpll = DPLL_VGA_MODE_DIS;\r\nif (is_lvds) {\r\ndpll |= DPLLB_MODE_LVDS;\r\ndpll |= DPLL_DVO_HIGH_SPEED;\r\n} else\r\ndpll |= DPLLB_MODE_DAC_SERIAL;\r\nif (is_sdvo) {\r\nint sdvo_pixel_multiply =\r\nadjusted_mode->clock / mode->clock;\r\ndpll |= DPLL_DVO_HIGH_SPEED;\r\ndpll |=\r\n(sdvo_pixel_multiply - 1) << SDVO_MULTIPLIER_SHIFT_HIRES;\r\n}\r\ndpll |= (1 << (clock.p1 - 1)) << 16;\r\nswitch (clock.p2) {\r\ncase 5:\r\ndpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;\r\nbreak;\r\ncase 7:\r\ndpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;\r\nbreak;\r\ncase 10:\r\ndpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;\r\nbreak;\r\ncase 14:\r\ndpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;\r\nbreak;\r\n}\r\nif (is_tv) {\r\ndpll |= 3;\r\n}\r\ndpll |= PLL_REF_INPUT_DREFCLK;\r\npipeconf = REG_READ(map->conf);\r\ndspcntr = DISPPLANE_GAMMA_ENABLE;\r\nif (pipe == 0)\r\ndspcntr |= DISPPLANE_SEL_PIPE_A;\r\nelse\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\ndspcntr |= DISPLAY_PLANE_ENABLE;\r\npipeconf |= PIPEACONF_ENABLE;\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (psb_intel_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\ndrm_mode_debug_printmodeline(mode);\r\nif (dpll & DPLL_VCO_ENABLE) {\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll & ~DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\n}\r\nif (is_lvds) {\r\nu32 lvds = REG_READ(LVDS);\r\nlvds &= ~LVDS_PIPEB_SELECT;\r\nif (pipe == 1)\r\nlvds |= LVDS_PIPEB_SELECT;\r\nlvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;\r\nlvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\r\nif (clock.p2 == 7)\r\nlvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\r\nREG_WRITE(LVDS, lvds);\r\nREG_READ(LVDS);\r\n}\r\nREG_WRITE(map->fp0, fp);\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->dpll, dpll);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16));\r\nREG_WRITE(map->size,\r\n((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(map->pos, 0);\r\nREG_WRITE(map->src,\r\n((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\r\nREG_WRITE(map->conf, pipeconf);\r\nREG_READ(map->conf);\r\ngma_wait_for_vblank(dev);\r\nREG_WRITE(map->cntr, dspcntr);\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\ngma_wait_for_vblank(dev);\r\nreturn 0;\r\n}\r\nstatic int psb_intel_crtc_clock_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 dpll;\r\nu32 fp;\r\nstruct gma_clock_t clock;\r\nbool is_lvds;\r\nstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\r\nif (gma_power_begin(dev, false)) {\r\ndpll = REG_READ(map->dpll);\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = REG_READ(map->fp0);\r\nelse\r\nfp = REG_READ(map->fp1);\r\nis_lvds = (pipe == 1) && (REG_READ(LVDS) & LVDS_PORT_EN);\r\ngma_power_end(dev);\r\n} else {\r\ndpll = p->dpll;\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = p->fp0;\r\nelse\r\nfp = p->fp1;\r\nis_lvds = (pipe == 1) && (dev_priv->regs.psb.saveLVDS &\r\nLVDS_PORT_EN);\r\n}\r\nclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\r\nclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\r\nclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\r\nif (is_lvds) {\r\nclock.p1 =\r\nffs((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT);\r\nclock.p2 = 14;\r\nif ((dpll & PLL_REF_INPUT_MASK) ==\r\nPLLB_REF_INPUT_SPREADSPECTRUMIN) {\r\npsb_intel_clock(66000, &clock);\r\n} else\r\npsb_intel_clock(48000, &clock);\r\n} else {\r\nif (dpll & PLL_P1_DIVIDE_BY_TWO)\r\nclock.p1 = 2;\r\nelse {\r\nclock.p1 =\r\n((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\r\n}\r\nif (dpll & PLL_P2_DIVIDE_BY_4)\r\nclock.p2 = 4;\r\nelse\r\nclock.p2 = 2;\r\npsb_intel_clock(48000, &clock);\r\n}\r\nreturn clock.dot;\r\n}\r\nstruct drm_display_mode *psb_intel_crtc_mode_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nstruct drm_display_mode *mode;\r\nint htot;\r\nint hsync;\r\nint vtot;\r\nint vsync;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nif (gma_power_begin(dev, false)) {\r\nhtot = REG_READ(map->htotal);\r\nhsync = REG_READ(map->hsync);\r\nvtot = REG_READ(map->vtotal);\r\nvsync = REG_READ(map->vsync);\r\ngma_power_end(dev);\r\n} else {\r\nhtot = p->htotal;\r\nhsync = p->hsync;\r\nvtot = p->vtotal;\r\nvsync = p->vsync;\r\n}\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn NULL;\r\nmode->clock = psb_intel_crtc_clock_get(dev, crtc);\r\nmode->hdisplay = (htot & 0xffff) + 1;\r\nmode->htotal = ((htot & 0xffff0000) >> 16) + 1;\r\nmode->hsync_start = (hsync & 0xffff) + 1;\r\nmode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;\r\nmode->vdisplay = (vtot & 0xffff) + 1;\r\nmode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;\r\nmode->vsync_start = (vsync & 0xffff) + 1;\r\nmode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nreturn mode;\r\n}\r\nstatic void psb_intel_cursor_init(struct drm_device *dev,\r\nstruct gma_crtc *gma_crtc)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 control[3] = { CURACNTR, CURBCNTR, CURCCNTR };\r\nu32 base[3] = { CURABASE, CURBBASE, CURCBASE };\r\nstruct gtt_range *cursor_gt;\r\nif (dev_priv->ops->cursor_needs_phys) {\r\ncursor_gt = psb_gtt_alloc_range(dev, 4 * PAGE_SIZE, "cursor", 1,\r\nPAGE_SIZE);\r\nif (!cursor_gt) {\r\ngma_crtc->cursor_gt = NULL;\r\ngoto out;\r\n}\r\ngma_crtc->cursor_gt = cursor_gt;\r\ngma_crtc->cursor_addr = dev_priv->stolen_base +\r\ncursor_gt->offset;\r\n} else {\r\ngma_crtc->cursor_gt = NULL;\r\n}\r\nout:\r\nREG_WRITE(control[gma_crtc->pipe], 0);\r\nREG_WRITE(base[gma_crtc->pipe], 0);\r\n}\r\nvoid psb_intel_crtc_init(struct drm_device *dev, int pipe,\r\nstruct psb_intel_mode_device *mode_dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc;\r\nint i;\r\nuint16_t *r_base, *g_base, *b_base;\r\ngma_crtc = kzalloc(sizeof(struct gma_crtc) +\r\n(INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)),\r\nGFP_KERNEL);\r\nif (gma_crtc == NULL)\r\nreturn;\r\ngma_crtc->crtc_state =\r\nkzalloc(sizeof(struct psb_intel_crtc_state), GFP_KERNEL);\r\nif (!gma_crtc->crtc_state) {\r\ndev_err(dev->dev, "Crtc state error: No memory\n");\r\nkfree(gma_crtc);\r\nreturn;\r\n}\r\ndrm_crtc_init(dev, &gma_crtc->base, dev_priv->ops->crtc_funcs);\r\ngma_crtc->clock_funcs = dev_priv->ops->clock_funcs;\r\ndrm_mode_crtc_set_gamma_size(&gma_crtc->base, 256);\r\ngma_crtc->pipe = pipe;\r\ngma_crtc->plane = pipe;\r\nr_base = gma_crtc->base.gamma_store;\r\ng_base = r_base + 256;\r\nb_base = g_base + 256;\r\nfor (i = 0; i < 256; i++) {\r\ngma_crtc->lut_r[i] = i;\r\ngma_crtc->lut_g[i] = i;\r\ngma_crtc->lut_b[i] = i;\r\nr_base[i] = i << 8;\r\ng_base[i] = i << 8;\r\nb_base[i] = i << 8;\r\ngma_crtc->lut_adj[i] = 0;\r\n}\r\ngma_crtc->mode_dev = mode_dev;\r\ngma_crtc->cursor_addr = 0;\r\ndrm_crtc_helper_add(&gma_crtc->base,\r\ndev_priv->ops->crtc_helper);\r\ngma_crtc->mode_set.crtc = &gma_crtc->base;\r\nBUG_ON(pipe >= ARRAY_SIZE(dev_priv->plane_to_crtc_mapping) ||\r\ndev_priv->plane_to_crtc_mapping[gma_crtc->plane] != NULL);\r\ndev_priv->plane_to_crtc_mapping[gma_crtc->plane] = &gma_crtc->base;\r\ndev_priv->pipe_to_crtc_mapping[gma_crtc->pipe] = &gma_crtc->base;\r\ngma_crtc->mode_set.connectors = (struct drm_connector **)(gma_crtc + 1);\r\ngma_crtc->mode_set.num_connectors = 0;\r\npsb_intel_cursor_init(dev, gma_crtc);\r\ngma_crtc->active = true;\r\n}\r\nstruct drm_crtc *psb_intel_get_crtc_from_pipe(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_crtc *crtc = NULL;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nif (gma_crtc->pipe == pipe)\r\nbreak;\r\n}\r\nreturn crtc;\r\n}\r\nint gma_connector_clones(struct drm_device *dev, int type_mask)\r\n{\r\nint index_mask = 0;\r\nstruct drm_connector *connector;\r\nint entry = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list,\r\nhead) {\r\nstruct gma_encoder *gma_encoder = gma_attached_encoder(connector);\r\nif (type_mask & (1 << gma_encoder->type))\r\nindex_mask |= (1 << entry);\r\nentry++;\r\n}\r\nreturn index_mask;\r\n}
